================================================================================
HEMLOCK PROGRAMMING LANGUAGE - COMPLETE DOCUMENTATION (Italiano)
================================================================================

This file contains the complete documentation for the Hemlock programming
language and the hpm package manager in Italiano.
It is optimized for LLM consumption.

Source: https://github.com/hemlang/hem-doc

--------------------------------------------------------------------------------
TABLE OF CONTENTS
--------------------------------------------------------------------------------

  1. Benvenuto
  2. Riferimento del Linguaggio

[Primi Passi]
  3. Avvio Rapido
  4. Installazione
  5. Percorsi di Apprendimento
  6. Tutorial

[Guida al Linguaggio]
  7. Array
  8. Flusso di Controllo
  9. Funzioni
  10. Gestione degli Errori
  11. Gestione della Memoria
  12. Moduli
  13. Oggetti
  14. Pattern Matching
  15. Rune
  16. Sintassi
  17. Stringhe
  18. Tipi

[Argomenti Avanzati]
  19. Argomenti da Riga di Comando
  20. Async e Concorrenza
  21. Esecuzione di Comandi
  22. FFI
  23. File IO
  24. Impacchettamento e Distribuzione
  25. Memory Ownership
  26. Operazioni Atomiche
  27. Profilazione
  28. Segnali

[Riferimento API]
  29. API degli Array
  30. API dei File
  31. API della Memoria
  32. API delle Stringhe
  33. API di Concorrenza
  34. Funzioni Integrate
  35. Operatori
  36. Sistema di Tipi

[Design e Filosofia]
  37. Filosofia
  38. Implementazione
  39. Sintassi delle Firme

[Contribuire]
  40. Linee Guida
  41. Test

[hpm: Primi Passi]
  42. Avvio Rapido
  43. Configurazione del Progetto
  44. Installazione

[hpm: Guida Utente]
  45. Comandi
  46. Configurazione
  47. Risoluzione dei Problemi

[hpm: Sviluppo Pacchetti]
  48. Creazione di Pacchetti
  49. Specifiche dei Pacchetti
  50. Versionamento

[hpm: Riferimento]
  51. Architettura
  52. Codici di Uscita


================================================================================
DOCUMENTATION
================================================================================

--------------------------------------------------------------------------------
## Benvenuto
--------------------------------------------------------------------------------

# Benvenuto in Hemlock

> "Un piccolo linguaggio non sicuro per scrivere cose non sicure in modo sicuro."

**Hemlock** Ã¨ un linguaggio di scripting di sistema che combina la potenza del C con l'ergonomia dei moderni linguaggi di scripting. Offre gestione manuale della memoria, controllo esplicito e concorrenza asincrona strutturata integrata.

## Cos'Ã¨ Hemlock?

Hemlock Ã¨ progettato per programmatori che vogliono:

- **Controllo esplicito** sulla memoria e l'esecuzione
- **Sintassi simile al C** con comoditÃ  moderne
- **Nessun comportamento nascosto** o magia
- **Vera concorrenza asincrona parallela** con concorrenza basata su pthread

Hemlock NON Ã¨ un linguaggio a memoria sicura con garbage collection. Invece, ti fornisce gli strumenti per essere sicuro (`buffer`, annotazioni di tipo, controllo dei limiti) senza obbligarti a usarli (`ptr`, memoria manuale, operazioni non sicure).

## Esempio Rapido

```hemlock
// Ciao, Hemlock!
fn greet(name: string): string {
    return `Ciao, ${name}!`;
}

let message = greet("Mondo");
print(message);

// Gestione manuale della memoria
let buf = buffer(64);
buf[0] = 72;  // 'H'
buf[1] = 105; // 'i'
print(buf);
free(buf);
```

## FunzionalitÃ  in Breve

| FunzionalitÃ  | Descrizione |
|--------------|-------------|
| **Sistema di Tipi** | i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object |
| **Memoria** | Gestione manuale con `alloc()`, `buffer()`, `free()` |
| **Async** | `async`/`await` integrato con vero parallelismo pthread |
| **FFI** | Chiamare funzioni C direttamente da librerie condivise |
| **Libreria Standard** | 40 moduli inclusi crypto, http, sqlite, json e altro |

## Primi Passi

Pronto a iniziare? Ecco come cominciare:

1. **[Installazione](#getting-started-installation)** - Scarica e configura Hemlock
2. **[Avvio Rapido](#getting-started-quick-start)** - Scrivi il tuo primo programma in pochi minuti
3. **[Tutorial](#getting-started-tutorial)** - Impara Hemlock passo dopo passo

## Sezioni della Documentazione

- **Primi Passi** - Installazione, guida all'avvio rapido e tutorial
- **Guida al Linguaggio** - Approfondimento su sintassi, tipi, funzioni e altro
- **Argomenti Avanzati** - Programmazione asincrona, FFI, segnali e atomiche
- **Riferimento API** - Riferimento completo per le funzioni integrate e la libreria standard
- **Design e Filosofia** - Comprendere perchÃ© Hemlock Ã¨ cosÃ¬ com'Ã¨

## Gestore di Pacchetti

Hemlock include **hpm**, un gestore di pacchetti per gestire le dipendenze:

```bash
hpm init mio-progetto
hpm add un-pacchetto
hpm run
```

Consulta le sezioni della documentazione di hpm per maggiori dettagli.

---

Usa la navigazione a sinistra per esplorare la documentazione, oppure usa la barra di ricerca per trovare argomenti specifici.


--------------------------------------------------------------------------------
## Riferimento del Linguaggio
--------------------------------------------------------------------------------

# Filosofia di Design del Linguaggio Hemlock

> "Un piccolo linguaggio non sicuro per scrivere cose non sicure in modo sicuro."

Questo documento fornisce una panoramica della filosofia di design di Hemlock e un riferimento rapido del linguaggio.
Esplora le altre sezioni della documentazione per guide dettagliate e riferimenti API.

---

## IdentitÃ  Fondamentale

Hemlock Ã¨ un **linguaggio di scripting di sistema** con gestione manuale della memoria e controllo esplicito:
- La potenza del C con l'ergonomia dei moderni linguaggi di scripting
- Concorrenza asincrona strutturata integrata
- Nessun comportamento nascosto o magia

**Hemlock NON Ã¨:** A memoria sicura, un linguaggio con GC, o nasconde complessitÃ .
**Hemlock Ãˆ:** Esplicito piuttosto che implicito, educativo, un "livello di scripting C" per lavoro di sistema.

---

## Principi di Design

### 1. Esplicito Piuttosto che Implicito
- Punto e virgola obbligatorio (nessun ASI)
- Gestione manuale della memoria (alloc/free)
- Annotazioni di tipo opzionali ma verificate a runtime

### 2. Dinamico di Default, Tipizzato per Scelta
- Ogni valore ha un tag di tipo a runtime
- I letterali inferiscono i tipi: `42` â†’ i32, `5000000000` â†’ i64, `3.14` â†’ f64
- Annotazioni di tipo opzionali impongono controlli a runtime

### 3. Non Sicuro Ã¨ una FunzionalitÃ 
- Aritmetica dei puntatori permessa (responsabilitÃ  dell'utente)
- Nessun controllo dei limiti su `ptr` raw (usare `buffer` per sicurezza)
- Double-free puÃ² causare crash

### 4. Concorrenza Strutturata di Prima Classe
- `async`/`await` integrato con parallelismo basato su pthread
- Canali per la comunicazione
- `spawn`/`join`/`detach` per la gestione dei task

### 5. Sintassi Simile al C
- Blocchi `{}` sempre richiesti
- Commenti: `// riga` e `/* blocco */`
- Operatori come il C: `+`, `-`, `*`, `%`, `&&`, `||`, `!`, `&`, `|`, `^`, `<<`, `>>`
- Incremento/decremento: `++x`, `x++`, `--x`, `x--` (prefisso e postfisso)
- Assegnazione composta: `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`
- `/` restituisce sempre float (usare `divi()` per divisione intera)
- Sintassi dei tipi: `let x: type = value;`

---

## Riferimento Rapido

### Tipi
```
Con segno:   i8, i16, i32, i64
Senza segno: u8, u16, u32, u64
Float:       f32, f64
Altri:       bool, string, rune, array, ptr, buffer, null, object, file, task, channel
Alias:       integer (i32), number (f64), byte (u8)
```

**Promozione dei tipi:** i8 â†’ i16 â†’ i32 â†’ i64 â†’ f32 â†’ f64 (i float vincono sempre, ma i64/u64 + f32 â†’ f64 per preservare la precisione)

### Letterali
```hemlock
let x = 42;              // i32
let big = 5000000000;    // i64 (> max i32)
let hex = 0xDEADBEEF;    // letterale esadecimale
let bin = 0b1010;        // letterale binario
let oct = 0o777;         // letterale ottale
let sep = 1_000_000;     // separatori numerici permessi
let pi = 3.14;           // f64
let half = .5;           // f64 (senza zero iniziale)
let s = "hello";         // string
let esc = "\x41\u{1F600}"; // escape esadecimali e unicode
let ch = 'A';            // rune
let emoji = 'ðŸš€';        // rune (Unicode)
let arr = [1, 2, 3];     // array
let obj = { x: 10 };     // object
```

### Conversione di Tipo
```hemlock
// Funzioni costruttore di tipo - parsano stringhe in tipi
let n = i32("42");       // Parsa stringa a i32
let f = f64("3.14");     // Parsa stringa a f64
let b = bool("true");    // Parsa stringa a bool ("true" o "false")

// Tutti i tipi numerici supportati
let a = i8("-128");      // i8, i16, i32, i64
let c = u8("255");       // u8, u16, u32, u64
let d = f32("1.5");      // f32, f64

// Numeri esadecimali e negativi
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42

// Anche gli alias di tipo funzionano
let x = integer("100");  // Come i32("100")
let y = number("1.5");   // Come f64("1.5")
let z = byte("200");     // Come u8("200")

// Convertire tra tipi numerici
let big = i64(42);       // i32 a i64
let truncated = i32(3.99); // f64 a i32 (tronca a 3)

// Le annotazioni di tipo validano i tipi (ma non parsano stringhe)
let f: f64 = 100;        // i32 a f64 via annotazione (coercizione numerica OK)
// let n: i32 = "42";    // ERRORE - usare i32("42") per parsare stringhe
```

### Introspezione
```hemlock
typeof(42);              // "i32"
typeof("hello");         // "string"
typeof([1, 2, 3]);       // "array"
typeof(null);            // "null"
len("hello");            // 5 (lunghezza stringa in byte)
len([1, 2, 3]);          // 3 (lunghezza array)
```

### Memoria
```hemlock
let p = alloc(64);       // puntatore raw
let b = buffer(64);      // buffer sicuro (controllo limiti)
memset(p, 0, 64);
memcpy(dest, src, 64);
free(p);                 // pulizia manuale richiesta
```

### Flusso di Controllo
```hemlock
if (x > 0) { } else if (x < 0) { } else { }
while (cond) { break; continue; }
for (let i = 0; i < 10; i++) { }
for (item in array) { }
loop { if (done) { break; } }   // ciclo infinito (piÃ¹ pulito di while(true))
switch (x) { case 1: break; default: break; }  // fall-through stile C
defer cleanup();         // eseguito quando la funzione ritorna

// Etichette di ciclo per break/continue mirati in cicli annidati
outer: while (cond) {
    inner: for (let i = 0; i < 10; i++) {
        if (i == 5) { break outer; }     // esce dal ciclo esterno
        if (i == 3) { continue outer; }  // continua il ciclo esterno
    }
}
```

### Pattern Matching
```hemlock
// Espressione match - restituisce un valore
let result = match (value) {
    0 => "zero",                    // Pattern letterale
    1 | 2 | 3 => "piccolo",         // Pattern OR
    n if n < 10 => "medio",         // Espressione guard
    n => "grande: " + n             // Binding di variabile
};

// Pattern di tipo
match (val) {
    n: i32 => "intero",
    s: string => "stringa",
    _ => "altro"                    // Wildcard
}

// Destrutturazione di oggetti
match (point) {
    { x: 0, y: 0 } => "origine",
    { x, y } => "a " + x + "," + y
}

// Destrutturazione di array con rest
match (arr) {
    [] => "vuoto",
    [first, ...rest] => "testa: " + first,
    _ => "altro"
}

// Pattern annidati
match (user) {
    { name, address: { city } } => name + " in " + city
}
```

Vedere `docs/language-guide/pattern-matching.md` per la documentazione completa.

### Operatori di Null Coalescing
```hemlock
// Null coalescing (??) - restituisce sinistra se non-null, altrimenti destra
let name = user.name ?? "Anonimo";
let first = a ?? b ?? c ?? "fallback";

// Assegnazione null coalescing (??=) - assegna solo se null
let config = null;
config ??= { timeout: 30 };    // config Ã¨ ora { timeout: 30 }
config ??= { timeout: 60 };    // config invariato (non null)

// Funziona con proprietÃ  e indici
obj.field ??= "default";
arr[0] ??= "primo";

// Navigazione sicura (?.) - restituisce null se l'oggetto Ã¨ null
let city = user?.address?.city;  // null se qualsiasi parte Ã¨ null
let upper = name?.to_upper();    // chiamata metodo sicura
let item = arr?.[0];             // indicizzazione sicura
```

### Funzioni
```hemlock
fn add(a: i32, b: i32): i32 { return a + b; }
fn greet(name: string, msg?: "Ciao") { print(msg + " " + name); }
let f = fn(x) { return x * 2; };  // anonima/closure

// Funzioni con corpo espressione (sintassi freccia)
fn double(x: i32): i32 => x * 2;
fn max(a: i32, b: i32): i32 => a > b ? a : b;
let square = fn(x: i32): i32 => x * x;  // anonima con corpo espressione

// Modificatori di parametro
fn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // passaggio per riferimento
fn print_all(const items: array) { for (i in items) { print(i); } }  // immutabile
```

### Argomenti Nominati
```hemlock
// Le funzioni possono essere chiamate con argomenti nominati
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " ha " + age + " anni");
}

// Argomenti posizionali (tradizionali)
create_user("Alice", 25, false);

// Argomenti nominati - possono essere in qualsiasi ordine
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);

// Salta parametri opzionali nominando ciÃ² che ti serve
create_user("David", active: false);  // Usa default age=18

// Gli argomenti nominati devono venire dopo quelli posizionali
create_user("Eve", age: 21);          // OK: posizionale poi nominato
// create_user(name: "Bad", 25);      // ERRORE: posizionale dopo nominato
```

**Regole:**
- Gli argomenti nominati usano la sintassi `nome: valore`
- Possono apparire in qualsiasi ordine dopo gli argomenti posizionali
- Gli argomenti posizionali non possono seguire quelli nominati
- Funziona con parametri default/opzionali
- Nomi di parametri sconosciuti causano errori runtime

### Oggetti e Enum
```hemlock
define Person { name: string, age: i32, active?: true }
let p: Person = { name: "Alice", age: 30 };
let json = p.serialize();
let restored = json.deserialize();

// Sintassi shorthand per oggetti (stile ES6)
let name = "Alice";
let age = 30;
let person = { name, age };         // equivalente a { name: name, age: age }

// Operatore spread per oggetti
let defaults = { theme: "dark", size: "medium" };
let config = { ...defaults, size: "large" };  // copia defaults, sovrascrive size

enum Color { RED, GREEN, BLUE }
enum Status { OK = 0, ERROR = 1 }
```

### Tipi Composti (Intersezione/Duck Types)
```hemlock
// Definisci tipi strutturali
define HasName { name: string }
define HasAge { age: i32 }
define HasEmail { email: string }

// Tipo composto: l'oggetto deve soddisfare TUTTI i tipi
let person: HasName & HasAge = { name: "Alice", age: 30 };

// Parametri di funzione con tipi composti
fn greet(p: HasName & HasAge) {
    print(p.name + " ha " + p.age);
}

// Tre o piÃ¹ tipi
fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}

// Campi extra permessi (duck typing)
let employee: HasName & HasAge = {
    name: "Bob",
    age: 25,
    department: "Engineering"  // OK - campi extra ignorati
};
```

I tipi composti forniscono comportamento simile alle interfacce senza una parola chiave `interface` separata,
costruendo sui paradigmi `define` e duck typing esistenti.

### Alias di Tipo
```hemlock
// Alias di tipo semplice
type Integer = i32;
type Text = string;

// Alias di tipo funzione
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// Alias di tipo composto (ottimo per interfacce riutilizzabili)
define HasName { name: string }
define HasAge { age: i32 }
type Person = HasName & HasAge;

// Alias di tipo generico
type Pair<T> = { first: T, second: T };

// Usare alias di tipo
let x: Integer = 42;
let cb: Callback = fn(n) { print(n); };
let p: Person = { name: "Alice", age: 30 };
```

Gli alias di tipo creano scorciatoie nominate per tipi complessi, migliorando leggibilitÃ  e manutenibilitÃ .

### Tipi di Funzione
```hemlock
// Annotazioni di tipo funzione per parametri
fn apply_fn(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Funzione di ordine superiore che restituisce una funzione
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Tipi di funzione async
fn run_async(handler: async fn(): void) {
    spawn(handler);
}

// Tipi di funzione con piÃ¹ parametri
type BinaryOp = fn(i32, i32): i32;
let add: BinaryOp = fn(a, b) { return a + b; };
```

### Parametri Const
```hemlock
// Parametro const - immutabilitÃ  profonda
fn print_all(const items: array) {
    // items.push(4);  // ERRORE: non puÃ² mutare parametro const
    for (item in items) {
        print(item);
    }
}

// Const con oggetti - nessuna mutazione attraverso alcun percorso
fn describe(const person: object) {
    print(person.name);       // OK: lettura permessa
    // person.name = "Bob";   // ERRORE: non puÃ² mutare
}

// Accesso annidato permesso per lettura
fn get_city(const user: object) {
    return user.address.city;  // OK: lettura proprietÃ  annidate
}
```

Il modificatore `const` previene qualsiasi mutazione del parametro, incluse proprietÃ  annidate.
Questo fornisce sicurezza a compile-time per funzioni che non dovrebbero modificare i loro input.

### Parametri Ref (Passaggio per Riferimento)
```hemlock
// Parametro ref - la variabile del chiamante viene modificata direttamente
fn increment(ref x: i32) {
    x = x + 1;  // Modifica la variabile originale
}

let count = 10;
increment(count);
print(count);  // 11 - l'originale Ã¨ stato modificato

// Classica funzione swap
fn swap(ref a: i32, ref b: i32) {
    let temp = a;
    a = b;
    b = temp;
}

let x = 1;
let y = 2;
swap(x, y);
print(x, y);  // 2 1

// Mescola parametri ref e regolari
fn add_to(ref target: i32, amount: i32) {
    target = target + amount;
}

let total = 100;
add_to(total, 50);
print(total);  // 150
```

Il modificatore `ref` passa un riferimento alla variabile del chiamante, permettendo alla funzione di
modificarla direttamente. Senza `ref`, i primitivi sono passati per valore (copiati). Usa `ref` quando
devi mutare lo stato del chiamante senza restituire un valore.

**Regole:**
- I parametri `ref` devono ricevere variabili, non letterali o espressioni
- Funziona con tutti i tipi (primitivi, array, oggetti)
- Combina con annotazioni di tipo: `ref x: i32`
- Non puÃ² combinarsi con `const` (sono opposti)

### Firme di Metodo in Define
```hemlock
// Define con firme di metodo (pattern interfaccia)
define Comparable {
    value: i32,
    fn compare(other: Self): i32   // Firma di metodo richiesta
}

// Gli oggetti devono fornire il metodo richiesto
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};

// Metodi opzionali con ?
define Serializable {
    fn serialize(): string,        // Richiesto
    fn pretty?(): string           // Metodo opzionale
}

// Il tipo Self si riferisce al tipo che definisce
define Cloneable {
    fn clone(): Self   // Restituisce lo stesso tipo dell'oggetto
}
```

Le firme di metodo nei blocchi `define` usano delimitatori virgola (come interfacce TypeScript),
stabilendo contratti che gli oggetti devono soddisfare e abilitando pattern di programmazione
simili alle interfacce con il sistema duck typing di Hemlock.

### Gestione degli Errori
```hemlock
try { throw "errore"; } catch (e) { print(e); } finally { cleanup(); }
panic("irrecuperabile");  // esce immediatamente, non catturabile
```

### Async/Concorrenza
```hemlock
async fn compute(n: i32): i32 { return n * n; }
let task = spawn(compute, 42);
let result = await task;     // oppure join(task)
detach(spawn(background_work));

let ch = channel(10);
ch.send(value);
let val = ch.recv();
ch.close();
```

**Ownership della memoria:** I task ricevono copie dei valori primitivi ma condividono i puntatori. Se passi un `ptr` a un task spawned, devi assicurarti che la memoria rimanga valida fino al completamento del task. Usa `join()` prima di `free()`, o usa i canali per segnalare il completamento.

### Input Utente
```hemlock
let name = read_line();          // Legge riga da stdin (blocca)
print("Ciao, " + name);
eprint("Messaggio di errore");   // Stampa su stderr

// read_line() restituisce null su EOF
while (true) {
    let line = read_line();
    if (line == null) { break; }
    print("Ricevuto:", line);
}
```

### I/O su File
```hemlock
let f = open("file.txt", "r");  // modi: r, w, a, r+, w+, a+
let content = f.read();
f.write("data");
f.seek(0);
f.close();
```

### Segnali
```hemlock
signal(SIGINT, fn(sig) { print("Interrotto"); });
raise(SIGUSR1);
```

---

## Metodi Stringa (19)

`substr`, `slice`, `find`, `contains`, `split`, `trim`, `to_upper`, `to_lower`,
`starts_with`, `ends_with`, `replace`, `replace_all`, `repeat`, `char_at`,
`byte_at`, `chars`, `bytes`, `to_bytes`, `deserialize`

Template string: `` `Ciao ${name}!` ``

**MutabilitÃ  delle stringhe:** Le stringhe sono mutabili via assegnazione indice (`s[0] = 'H'`), ma tutti i metodi stringa restituiscono nuove stringhe senza modificare l'originale. Questo permette mutazione in-place quando necessario mantenendo il method chaining funzionale.

**ProprietÃ  lunghezza stringa:**
```hemlock
let s = "ciao ðŸš€";
print(s.length);       // 6 (conteggio caratteri/rune)
print(s.byte_length);  // 9 (conteggio byte - emoji Ã¨ 4 byte UTF-8)
```

## Metodi Array (18)

`push`, `pop`, `shift`, `unshift`, `insert`, `remove`, `find`, `contains`,
`slice`, `join`, `concat`, `reverse`, `first`, `last`, `clear`, `map`, `filter`, `reduce`

Array tipizzati: `let nums: array<i32> = [1, 2, 3];`

---

## Libreria Standard (40 moduli)

Importa con prefisso `@stdlib/`:
```hemlock
import { sin, cos, PI } from "@stdlib/math";
import { HashMap, Queue, Set } from "@stdlib/collections";
import { read_file, write_file } from "@stdlib/fs";
import { TcpStream, UdpSocket } from "@stdlib/net";
```

| Modulo | Descrizione |
|--------|-------------|
| `arena` | Allocatore di memoria arena (bump allocation) |
| `args` | Parsing argomenti da riga di comando |
| `assert` | UtilitÃ  di asserzione |
| `async` | ThreadPool, parallel_map |
| `async_fs` | Operazioni I/O file async |
| `collections` | HashMap, Queue, Stack, Set, LinkedList, LRUCache |
| `compression` | gzip, gunzip, deflate |
| `crypto` | aes_encrypt, rsa_sign, random_bytes |
| `csv` | Parsing e generazione CSV |
| `datetime` | Classe DateTime, formattazione, parsing |
| `encoding` | base64_encode, hex_encode, url_encode |
| `env` | getenv, setenv, exit, get_pid |
| `fmt` | UtilitÃ  di formattazione stringhe |
| `fs` | read_file, write_file, list_dir, exists |
| `glob` | Pattern matching file |
| `hash` | sha256, sha512, md5, djb2 |
| `http` | http_get, http_post, http_request |
| `ipc` | Comunicazione inter-processo |
| `iter` | UtilitÃ  iteratore |
| `json` | parse, stringify, pretty, get, set |
| `logging` | Logger con livelli |
| `math` | sin, cos, sqrt, pow, rand, PI, E |
| `net` | TcpListener, TcpStream, UdpSocket |
| `os` | platform, arch, cpu_count, hostname |
| `path` | Manipolazione path file |
| `process` | fork, exec, wait, kill |
| `random` | Generazione numeri casuali |
| `regex` | compile, test (POSIX ERE) |
| `retry` | Logica retry con backoff |
| `semver` | Semantic versioning |
| `shell` | UtilitÃ  comandi shell |
| `sqlite` | Database SQLite, query, exec, transazioni |
| `strings` | pad_left, is_alpha, reverse, lines |
| `terminal` | Colori e stili ANSI |
| `testing` | describe, test, expect |
| `time` | now, time_ms, sleep, clock |
| `toml` | Parsing e generazione TOML |
| `url` | Parsing e manipolazione URL |
| `uuid` | Generazione UUID |
| `websocket` | Client WebSocket |

Vedere `stdlib/docs/` per documentazione dettagliata dei moduli.

---

## FFI (Foreign Function Interface)

Dichiara e chiama funzioni C da librerie condivise:
```hemlock
import "libc.so.6";

extern fn strlen(s: string): i32;
extern fn getpid(): i32;

let len = strlen("Ciao!");  // 5
let pid = getpid();
```

Esporta funzioni FFI dai moduli:
```hemlock
// string_utils.hml
import "libc.so.6";

export extern fn strlen(s: string): i32;
export fn string_length(s: string): i32 {
    return strlen(s);
}
```

FFI dinamico (binding runtime):
```hemlock
let lib = ffi_open("libc.so.6");
let puts = ffi_bind(lib, "puts", [FFI_POINTER], FFI_INT);
puts("Ciao dal C!");
ffi_close(lib);
```

Tipi: `FFI_INT`, `FFI_DOUBLE`, `FFI_POINTER`, `FFI_STRING`, `FFI_VOID`, ecc.

---

## Operazioni Atomiche

Programmazione concorrente lock-free con operazioni atomiche:

```hemlock
// Alloca memoria per i32 atomico
let p = alloc(4);
ptr_write_i32(p, 0);

// Load/store atomici
let val = atomic_load_i32(p);        // Legge atomicamente
atomic_store_i32(p, 42);             // Scrive atomicamente

// Operazioni fetch-and-modify (restituiscono il valore VECCHIO)
let old = atomic_add_i32(p, 10);     // Aggiunge, restituisce vecchio
old = atomic_sub_i32(p, 5);          // Sottrae, restituisce vecchio
old = atomic_and_i32(p, 0xFF);       // AND bit a bit
old = atomic_or_i32(p, 0x10);        // OR bit a bit
old = atomic_xor_i32(p, 0x0F);       // XOR bit a bit

// Compare-and-swap (CAS)
let success = atomic_cas_i32(p, 42, 100);  // Se *p == 42, imposta a 100
// Restituisce true se lo swap ha successo, false altrimenti

// Atomic exchange
old = atomic_exchange_i32(p, 999);   // Scambia, restituisce vecchio

free(p);

// Varianti i64 disponibili (atomic_load_i64, atomic_add_i64, ecc.)

// Memory fence (barriera completa)
atomic_fence();
```

Tutte le operazioni usano sequential consistency (`memory_order_seq_cst`).

---

## Struttura del Progetto

```
hemlock/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ frontend/         # Condiviso: lexer, parser, AST, moduli
â”‚   â”œâ”€â”€ backends/
â”‚   â”‚   â”œâ”€â”€ interpreter/  # hemlock: interprete tree-walking
â”‚   â”‚   â””â”€â”€ compiler/     # hemlockc: generatore codice C
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ lsp/          # Language Server Protocol
â”‚   â”‚   â””â”€â”€ bundler/      # Strumenti bundle/package
â”œâ”€â”€ runtime/              # Runtime programmi compilati (libhemlock_runtime.a)
â”œâ”€â”€ stdlib/               # Libreria standard (40 moduli)
â”‚   â””â”€â”€ docs/             # Documentazione moduli
â”œâ”€â”€ docs/                 # Documentazione completa
â”‚   â”œâ”€â”€ language-guide/   # Tipi, stringhe, array, ecc.
â”‚   â”œâ”€â”€ reference/        # Riferimenti API
â”‚   â””â”€â”€ advanced/         # Async, FFI, segnali, ecc.
â”œâ”€â”€ tests/                # 625+ test
â””â”€â”€ examples/             # Programmi esempio
```

---

## Linee Guida per lo Stile del Codice

### Costanti e Numeri Magici

Quando aggiungi costanti numeriche al codebase C, segui queste linee guida:

1. **Definisci le costanti in `include/hemlock_limits.h`** - Questo file Ã¨ la posizione centrale per tutti i limiti compile-time e runtime, capacitÃ  e costanti nominate.

2. **Usa nomi descrittivi con prefisso `HML_`** - Tutte le costanti dovrebbero avere prefisso `HML_` per chiarezza del namespace.

3. **Evita numeri magici** - Sostituisci valori numerici hard-coded con costanti nominate. Esempi:
   - Limiti range tipo: `HML_I8_MIN`, `HML_I8_MAX`, `HML_U32_MAX`
   - CapacitÃ  buffer: `HML_INITIAL_ARRAY_CAPACITY`, `HML_INITIAL_LEXER_BUFFER_CAPACITY`
   - Conversioni tempo: `HML_NANOSECONDS_PER_SECOND`, `HML_MILLISECONDS_PER_SECOND`
   - Seed hash: `HML_DJB2_HASH_SEED`
   - Valori ASCII: `HML_ASCII_CASE_OFFSET`, `HML_ASCII_PRINTABLE_START`

4. **Includi `hemlock_limits.h`** - I file sorgente dovrebbero includere questo header (spesso via `internal.h`) per accedere alle costanti.

5. **Documenta lo scopo** - Aggiungi un commento che spiega cosa rappresenta ogni costante.

---

## Cosa NON Fare

âŒ Aggiungere comportamento implicito (ASI, GC, auto-cleanup)
âŒ Nascondere complessitÃ  (ottimizzazioni magiche, refcount nascosti)
âŒ Rompere semantica esistente (punto e virgola, memoria manuale, stringhe mutabili)
âŒ Perdere precisione in conversioni implicite
âŒ Usare numeri magici - definisci costanti nominate in `hemlock_limits.h` invece

---

## Testing

```bash
make test              # Esegui test interprete
make test-compiler     # Esegui test compilatore
make parity            # Esegui test paritÃ  (entrambi devono corrispondere)
make test-all          # Esegui tutte le suite di test
```

**Importante:** I test potrebbero bloccarsi per problemi async/concorrenza. Usa sempre un timeout quando esegui i test:
```bash
timeout 60 make test   # 60 secondi timeout
timeout 120 make parity
```

Categorie test: primitives, memory, strings, arrays, functions, objects, async, ffi, defer, signals, switch, bitwise, typed_arrays, modules, stdlib_*

---

## Architettura Compilatore/Interprete

Hemlock ha due backend di esecuzione che condividono un frontend comune:

```
Sorgente (.hml)
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FRONTEND CONDIVISO         â”‚
â”‚  - Lexer (src/frontend/)    â”‚
â”‚  - Parser (src/frontend/)   â”‚
â”‚  - AST (src/frontend/)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ INTERPRETE â”‚    â”‚ COMPILATOREâ”‚
â”‚ (hemlock)  â”‚    â”‚ (hemlockc) â”‚
â”‚            â”‚    â”‚            â”‚
â”‚ Tree-walk  â”‚    â”‚ Type check â”‚
â”‚ evaluation â”‚    â”‚ AST â†’ C    â”‚
â”‚            â”‚    â”‚ gcc link   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Type Checking del Compilatore

Il compilatore (`hemlockc`) include type checking compile-time, **abilitato di default**:

```bash
hemlockc program.hml -o program    # Type check, poi compila
hemlockc --check program.hml       # Solo type check, non compila
hemlockc --no-type-check prog.hml  # Disabilita type checking
hemlockc --strict-types prog.hml   # Avvisa su tipi 'any' impliciti
```

Il type checker:
- Valida le annotazioni di tipo a compile time
- Tratta il codice non tipizzato come dinamico (tipo `any`) - sempre valido
- Fornisce hint di ottimizzazione per unboxing
- Usa conversioni numeriche permissive (range validato a runtime)

### Struttura Directory

```
hemlock/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ frontend/           # Condiviso: lexer, parser, AST, moduli
â”‚   â”‚   â”œâ”€â”€ lexer.c
â”‚   â”‚   â”œâ”€â”€ parser/
â”‚   â”‚   â”œâ”€â”€ ast.c
â”‚   â”‚   â””â”€â”€ module.c
â”‚   â”œâ”€â”€ backends/
â”‚   â”‚   â”œâ”€â”€ interpreter/    # hemlock: interprete tree-walking
â”‚   â”‚   â”‚   â”œâ”€â”€ main.c
â”‚   â”‚   â”‚   â”œâ”€â”€ runtime/
â”‚   â”‚   â”‚   â””â”€â”€ builtins/
â”‚   â”‚   â””â”€â”€ compiler/       # hemlockc: generatore codice C
â”‚   â”‚       â”œâ”€â”€ main.c
â”‚   â”‚       â””â”€â”€ codegen/
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ lsp/            # Language server
â”‚   â”‚   â””â”€â”€ bundler/        # Strumenti bundle/package
â”œâ”€â”€ runtime/                # libhemlock_runtime.a per programmi compilati
â”œâ”€â”€ stdlib/                 # Libreria standard condivisa
â””â”€â”€ tests/
    â”œâ”€â”€ parity/             # Test che DEVONO passare entrambi i backend
    â”œâ”€â”€ interpreter/        # Test specifici interprete
    â””â”€â”€ compiler/           # Test specifici compilatore
```

---

## Sviluppo Parity-First

**Sia l'interprete che il compilatore devono produrre output identico per lo stesso input.**

### Policy di Sviluppo

Quando aggiungi o modifichi funzionalitÃ  del linguaggio:

1. **Design** - Definisci il cambiamento AST/semantico nel frontend condiviso
2. **Implementa interprete** - Aggiungi valutazione tree-walking
3. **Implementa compilatore** - Aggiungi generazione codice C
4. **Aggiungi test paritÃ ** - Scrivi test in `tests/parity/` con file `.expected`
5. **Verifica** - Esegui `make parity` prima di merge

### Struttura Test ParitÃ 

```
tests/parity/
â”œâ”€â”€ language/       # FunzionalitÃ  core linguaggio (control flow, closure, ecc.)
â”œâ”€â”€ builtins/       # Funzioni integrate (print, typeof, memory, ecc.)
â”œâ”€â”€ methods/        # Metodi stringa e array
â””â”€â”€ modules/        # Import/export, import stdlib
```

Ogni test ha due file:
- `feature.hml` - Il programma di test
- `feature.expected` - Output atteso (deve corrispondere per entrambi i backend)

### Risultati Test ParitÃ 

| Stato | Significato |
|-------|-------------|
| `âœ“ PASSED` | Sia interprete che compilatore corrispondono all'output atteso |
| `â— INTERP_ONLY` | Interprete funziona, compilatore fallisce (necessita fix compilatore) |
| `â—‘ COMPILER_ONLY` | Compilatore funziona, interprete fallisce (raro) |
| `âœ— FAILED` | Entrambi falliscono (bug test o implementazione) |

### Cosa Richiede ParitÃ 

- Tutti i costrutti del linguaggio (if, while, for, switch, defer, try/catch)
- Tutti gli operatori (aritmetici, bit a bit, logici, confronto)
- Tutte le funzioni integrate (print, typeof, alloc, ecc.)
- Tutti i metodi stringa e array
- Regole di coercizione e promozione tipo
- Messaggi di errore per errori runtime

### Cosa PuÃ² Differire

- Caratteristiche di performance
- Dettagli layout memoria
- Formato debug/stack trace
- Errori di compilazione (il compilatore puÃ² catturare di piÃ¹ a compile time)

### Aggiungere un Test ParitÃ 

```bash
# 1. Crea file test
cat > tests/parity/language/my_feature.hml << 'EOF'
// Descrizione test
let x = some_feature();
print(x);
EOF

# 2. Genera output atteso dall'interprete
./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected

# 3. Verifica paritÃ 
make parity
```

---

## Versione

**v1.8.1** - Release corrente con:
- **Pattern matching** (espressioni `match`) - Potente destrutturazione e flusso di controllo:
  - Pattern letterali, wildcard e binding variabile
  - Pattern OR (`1 | 2 | 3`)
  - Espressioni guard (`n if n > 0`)
  - Destrutturazione oggetti (`{ x, y }`)
  - Destrutturazione array con rest (`[first, ...rest]`)
  - Pattern tipo (`n: i32`)
  - ParitÃ  completa tra interprete e compilatore
- **Annotazioni helper compilatore** - 11 annotazioni di ottimizzazione per controllo GCC/Clang:
  - `@inline`, `@noinline` - controllo inlining funzione
  - `@hot`, `@cold` - hint predizione branch
  - `@pure`, `@const` - annotazioni effetti collaterali
  - `@flatten` - inline tutte le chiamate nella funzione
  - `@optimize(level)` - livello ottimizzazione per funzione ("0", "1", "2", "3", "s", "fast")
  - `@warn_unused` - avvisa su valori ritorno ignorati
  - `@section(name)` - posizionamento sezione ELF custom (es. `@section(".text.hot")`)
- **Funzioni con corpo espressione** (`fn double(x): i32 => x * 2;`) - sintassi concisa per funzioni a singola espressione
- **Istruzioni singola riga** - sintassi `if`, `while`, `for` senza parentesi (es. `if (x > 0) print(x);`)
- **Alias di tipo** (`type Name = Type;`) - scorciatoie nominate per tipi complessi
- **Annotazioni tipo funzione** (`fn(i32): i32`) - tipi funzione di prima classe
- **Parametri const** (`fn(const x: array)`) - immutabilitÃ  profonda per parametri
- **Parametri ref** (`fn(ref x: i32)`) - passaggio per riferimento per mutazione diretta chiamante
- **Firme metodo in define** (`fn method(): Type`) - contratti simili a interfacce (delimitati da virgola)
- **Tipo Self** nelle firme metodo - si riferisce al tipo che definisce
- **Keyword loop** (`loop { }`) - cicli infiniti piÃ¹ puliti, sostituisce `while (true)`
- **Etichette ciclo** (`outer: while`) - break/continue mirati per cicli annidati
- **Shorthand oggetti** (`{ name }`) - sintassi proprietÃ  shorthand stile ES6
- **Spread oggetti** (`{ ...obj }`) - copia e unisce campi oggetto
- **Tipi duck composti** (`A & B & C`) - tipi intersezione per typing strutturale
- **Argomenti nominati** per chiamate funzione (`foo(name: "value", age: 30)`)
- **Operatori null coalescing** (`??`, `??=`, `?.`) per gestione null sicura
- **Letterali ottali** (`0o777`, `0O123`)
- **Separatori numerici** (`1_000_000`, `0xFF_FF`, `0b1111_0000`)
- **Commenti blocco** (`/* ... */`)
- **Sequenze escape esadecimali** in stringhe/rune (`\x41` = 'A')
- **Sequenze escape unicode** in stringhe (`\u{1F600}` = ðŸ˜€)
- **Letterali float senza zero iniziale** (`.5`, `.123`, `.5e2`)
- **Type checking compile-time** in hemlockc (abilitato di default)
- **Integrazione LSP** con type checking per diagnostica real-time
- **Operatori assegnazione composta** (`+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`)
- **Operatori incremento/decremento** (`++x`, `x++`, `--x`, `x--`)
- **Fix precisione tipo**: i64/u64 + f32 â†’ f64 per preservare precisione
- Sistema tipi unificato con hint ottimizzazione unboxing
- Sistema tipi completo (i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object, enum, file, task, channel)
- Stringhe UTF-8 con 19 metodi
- Array con 18 metodi inclusi map/filter/reduce
- Gestione memoria manuale con `talloc()` e `sizeof()`
- Async/await con vero parallelismo pthread
- Operazioni atomiche per programmazione concorrente lock-free
- 40 moduli stdlib (+ arena, assert, semver, toml, retry, iter, random, shell)
- FFI per interop C con `export extern fn` per wrapper libreria riutilizzabili
- Supporto struct FFI nel compilatore (passa struct C per valore)
- Helper puntatori FFI (`ptr_null`, `ptr_read_*`, `ptr_write_*`)
- defer, try/catch/finally/throw, panic
- I/O File, gestione segnali, esecuzione comandi
- Gestore pacchetti [hpm](https://github.com/hemlang/hpm) con registry basato su GitHub
- Backend compilatore (generazione codice C) con 100% paritÃ  interprete
- Server LSP con go-to-definition e find-references
- Pass ottimizzazione AST e risoluzione variabili per lookup O(1)
- Builtin apply() per chiamate funzione dinamiche
- Canali unbuffered e supporto many-params
- 159 test paritÃ  (100% pass rate)

---

## Filosofia

> Ti diamo gli strumenti per essere sicuro (`buffer`, annotazioni tipo, controllo limiti) ma non ti obblighiamo a usarli (`ptr`, memoria manuale, operazioni non sicure).

**Se non sei sicuro se una funzionalitÃ  si adatta a Hemlock, chiediti: "Questo dÃ  al programmatore piÃ¹ controllo esplicito, o nasconde qualcosa?"**

Se nasconde, probabilmente non appartiene a Hemlock.



################################################################################
# PRIMI PASSI
################################################################################

--------------------------------------------------------------------------------
## Avvio Rapido
--------------------------------------------------------------------------------

# Avvio Rapido

Inizia a usare Hemlock in pochi minuti!

## Il Tuo Primo Programma

Crea un file chiamato `hello.hml`:

```hemlock
print("Ciao, Hemlock!");
```

Esegui con l'interprete:

```bash
./hemlock hello.hml
```

Oppure compila in un eseguibile nativo:

```bash
./hemlockc hello.hml -o hello
./hello
```

Output:
```
Ciao, Hemlock!
```

### Interprete vs Compilatore

Hemlock fornisce due modi per eseguire i programmi:

| Strumento | Caso d'Uso | Type Checking |
|-----------|------------|---------------|
| `hemlock` | Script veloci, REPL, sviluppo | Solo runtime |
| `hemlockc` | Binari di produzione, prestazioni migliori | Compile-time (default) |

Il compilatore (`hemlockc`) verifica i tipi del tuo codice prima di generare un eseguibile, catturando gli errori in anticipo.

## Sintassi di Base

### Variabili

```hemlock
// Le variabili sono dichiarate con 'let'
let x = 42;
let name = "Alice";
let pi = 3.14159;

// Le annotazioni di tipo sono opzionali
let count: i32 = 100;
let ratio: f64 = 0.618;
```

**Importante**: I punto e virgola sono **obbligatori** in Hemlock!

### Tipi

Hemlock ha un sistema di tipi ricco:

```hemlock
// Interi
let small: i8 = 127;          // 8-bit con segno
let byte: u8 = 255;           // 8-bit senza segno
let num: i32 = 2147483647;    // 32-bit con segno (default)
let big: i64 = 9223372036854775807;  // 64-bit con segno

// Float
let f: f32 = 3.14;            // float 32-bit
let d: f64 = 2.71828;         // float 64-bit (default)

// Stringhe e caratteri
let text: string = "Ciao";    // stringa UTF-8
let emoji: rune = 'ðŸš€';       // codepoint Unicode

// Booleano e null
let flag: bool = true;
let empty = null;
```

### Flusso di Controllo

```hemlock
// Istruzioni if
if (x > 0) {
    print("positivo");
} else if (x < 0) {
    print("negativo");
} else {
    print("zero");
}

// Cicli while
let i = 0;
while (i < 5) {
    print(i);
    i = i + 1;
}

// Cicli for
for (let j = 0; j < 10; j = j + 1) {
    print(j);
}
```

### Funzioni

```hemlock
// Funzione nominata
fn add(a: i32, b: i32): i32 {
    return a + b;
}

let result = add(5, 3);  // 8

// Funzione anonima
let multiply = fn(x, y) {
    return x * y;
};

print(multiply(4, 7));  // 28
```

## Lavorare con le Stringhe

Le stringhe in Hemlock sono **mutabili** e **UTF-8**:

```hemlock
let s = "ciao";
s[0] = 'C';              // Ora "Ciao"
print(s);

// Metodi stringa
let upper = s.to_upper();     // "CIAO"
let words = "a,b,c".split(","); // ["a", "b", "c"]
let sub = s.substr(1, 3);     // "iao"

// Concatenazione
let greeting = "Ciao" + ", " + "Mondo!";
print(greeting);  // "Ciao, Mondo!"
```

## Array

Array dinamici con tipi misti:

```hemlock
let numbers = [1, 2, 3, 4, 5];
print(numbers[0]);      // 1
print(numbers.length);  // 5

// Metodi array
numbers.push(6);        // [1, 2, 3, 4, 5, 6]
let last = numbers.pop();  // 6
let slice = numbers.slice(1, 4);  // [2, 3, 4]

// Tipi misti permessi
let mixed = [1, "due", true, null];
```

## Oggetti

Oggetti in stile JavaScript:

```hemlock
// Letterale oggetto
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};

print(person.name);  // "Alice"
person.age = 31;     // Modifica campo

// Metodi con 'self'
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    }
};

counter.increment();
print(counter.count);  // 1
```

## Gestione della Memoria

Hemlock usa **gestione manuale della memoria**:

```hemlock
// Buffer sicuro (raccomandato)
let buf = buffer(64);   // Alloca 64 byte
buf[0] = 65;            // Imposta primo byte a 'A'
print(buf[0]);          // 65
free(buf);              // Libera memoria

// Puntatore raw (avanzato)
let ptr = alloc(100);
memset(ptr, 0, 100);    // Riempi con zeri
free(ptr);
```

**Importante**: Devi fare `free()` di ciÃ² che `alloc()`!

## Gestione degli Errori

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "divisione per zero";
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    print(result);
} catch (e) {
    print("Errore: " + e);
} finally {
    print("Fatto");
}
```

## Argomenti da Riga di Comando

Accedi agli argomenti del programma tramite l'array `args`:

```hemlock
// script.hml
print("Script:", args[0]);
print(`Argomenti: ${args.length - 1}`);

let i = 1;
while (i < args.length) {
    print(`  arg ${i}: ${args[i]}`);
    i = i + 1;
}
```

Esegui con:
```bash
./hemlock script.hml ciao mondo
```

Output:
```
Script: script.hml
Argomenti: 2
  arg 1: ciao
  arg 2: mondo
```

## I/O su File

```hemlock
// Scrivi su file
let f = open("data.txt", "w");
f.write("Ciao, File!");
f.close();

// Leggi da file
let f2 = open("data.txt", "r");
let content = f2.read();
print(content);  // "Ciao, File!"
f2.close();
```

## Cosa c'Ã¨ Dopo?

Ora che hai visto le basi, esplora di piÃ¹:

- [Tutorial](#getting-started-tutorial) - Guida completa passo dopo passo
- [Guida al Linguaggio](#language-guide-syntax) - Approfondimento su tutte le funzionalitÃ 
- [Esempi](../../examples/) - Programmi esempio reali
- [Riferimento API](#reference-builtins) - Documentazione API completa

## Errori Comuni

### Dimenticare i Punto e Virgola

```hemlock
// âŒ ERRORE: Punto e virgola mancante
let x = 42
let y = 10

// âœ… CORRETTO
let x = 42;
let y = 10;
```

### Dimenticare di Liberare la Memoria

```hemlock
// âŒ MEMORY LEAK
let buf = buffer(100);
// ... usa buf ...
// Dimenticato di chiamare free(buf)!

// âœ… CORRETTO
let buf = buffer(100);
// ... usa buf ...
free(buf);
```

### Le Parentesi Graffe Sono Richieste

```hemlock
// âŒ ERRORE: Parentesi graffe mancanti
if (x > 0)
    print("positivo");

// âœ… CORRETTO
if (x > 0) {
    print("positivo");
}
```

## Ottenere Aiuto

- Leggi la [documentazione completa](../README.md)
- Controlla la [directory degli esempi](../../examples/)
- Guarda i [file di test](../../tests/) per pattern d'uso
- Segnala problemi su GitHub


--------------------------------------------------------------------------------
## Installazione
--------------------------------------------------------------------------------

# Installazione

Questa guida ti aiuterÃ  a compilare e installare Hemlock sul tuo sistema.

## Installazione Rapida (Raccomandata)

Il modo piÃ¹ semplice per installare Hemlock Ã¨ usare lo script di installazione one-line:

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash
```

Questo scarica e installa l'ultimo binario pre-compilato per la tua piattaforma (Linux o macOS, x86_64 o arm64).

### Opzioni di Installazione

```bash
# Installa in un prefisso personalizzato (default: ~/.local)
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local

# Installa una versione specifica
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0

# Installa e aggiorna automaticamente il PATH della shell
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path
```

Dopo l'installazione, verifica che funzioni:

```bash
hemlock --version
```

---

## Compilazione da Sorgente

Se preferisci compilare da sorgente o i binari pre-compilati non funzionano per il tuo sistema, segui le istruzioni qui sotto.

## Prerequisiti

### Dipendenze Richieste

Hemlock richiede le seguenti dipendenze per la compilazione:

- **Compilatore C**: GCC o Clang (standard C11)
- **Make**: GNU Make
- **libffi**: Libreria Foreign Function Interface (per supporto FFI)
- **OpenSSL**: Libreria crittografica (per funzioni hash: md5, sha1, sha256)
- **libwebsockets**: Supporto client/server WebSocket e HTTP
- **zlib**: Libreria di compressione

### Installazione Dipendenze

**macOS:**
```bash
# Installa Homebrew se non giÃ  installato
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Installa Xcode Command Line Tools
xcode-select --install

# Installa dipendenze via Homebrew
brew install libffi openssl@3 libwebsockets
```

**Nota per utenti macOS**: Il Makefile rileva automaticamente le installazioni Homebrew e imposta i path corretti di include/librerie. Hemlock supporta sia architetture Intel (x86_64) che Apple Silicon (arm64).

**Ubuntu/Debian:**
```bash
sudo apt-get update
sudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev
```

**Fedora/RHEL:**
```bash
sudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel
```

**Arch Linux:**
```bash
sudo pacman -S base-devel libffi openssl libwebsockets zlib
```

## Compilazione da Sorgente

### 1. Clona il Repository

```bash
git clone https://github.com/hemlang/hemlock.git
cd hemlock
```

### 2. Compila Hemlock

```bash
make
```

Questo compilerÃ  l'interprete Hemlock e posizionerÃ  l'eseguibile nella directory corrente.

### 3. Verifica l'Installazione

```bash
./hemlock --version
```

Dovresti vedere le informazioni sulla versione di Hemlock.

### 4. Testa la Compilazione

Esegui la suite di test per assicurarti che tutto funzioni correttamente:

```bash
make test
```

Tutti i test dovrebbero passare. Se vedi fallimenti, segnalali come issue.

## Installazione System-Wide (Opzionale)

Per installare Hemlock system-wide (es. in `/usr/local/bin`):

```bash
sudo make install
```

Questo ti permette di eseguire `hemlock` da qualsiasi posizione senza specificare il path completo.

## Esecuzione di Hemlock

### REPL Interattivo

Avvia il Read-Eval-Print Loop:

```bash
./hemlock
```

Vedrai un prompt dove puoi digitare codice Hemlock:

```
Hemlock REPL
> print("Ciao, Mondo!");
Ciao, Mondo!
> let x = 42;
> print(x * 2);
84
>
```

Esci dal REPL con `Ctrl+D` o `Ctrl+C`.

### Esecuzione di Programmi

Esegui uno script Hemlock:

```bash
./hemlock programma.hml
```

Con argomenti da riga di comando:

```bash
./hemlock programma.hml arg1 arg2 "argomento con spazi"
```

## Struttura delle Directory

Dopo la compilazione, la tua directory Hemlock apparirÃ  cosÃ¬:

```
hemlock/
â”œâ”€â”€ hemlock           # Eseguibile interprete compilato
â”œâ”€â”€ src/              # Codice sorgente
â”œâ”€â”€ include/          # File header
â”œâ”€â”€ tests/            # Suite di test
â”œâ”€â”€ examples/         # Programmi esempio
â”œâ”€â”€ docs/             # Documentazione
â”œâ”€â”€ stdlib/           # Libreria standard
â”œâ”€â”€ Makefile          # Configurazione build
â””â”€â”€ README.md         # README del progetto
```

## Opzioni di Build

### Build di Debug

Compila con simboli di debug e senza ottimizzazione:

```bash
make debug
```

### Build Pulita

Rimuovi tutti i file compilati:

```bash
make clean
```

Ricompila da zero:

```bash
make clean && make
```

## Risoluzione Problemi

### macOS: Errori Libreria Non Trovata

Se ottieni errori su librerie mancanti (`-lcrypto`, `-lffi`, ecc.):

1. Assicurati che le dipendenze Homebrew siano installate:
   ```bash
   brew install libffi openssl@3 libwebsockets
   ```

2. Verifica i path Homebrew:
   ```bash
   brew --prefix libffi
   brew --prefix openssl
   ```

3. Il Makefile dovrebbe auto-rilevare questi path. Se non lo fa, verifica che `brew` sia nel tuo PATH:
   ```bash
   which brew
   ```

### macOS: Errori di Tipo BSD (`u_int`, `u_char` non trovati)

Se vedi errori su nomi di tipo sconosciuti come `u_int` o `u_char`:

1. Questo Ã¨ risolto in v1.0.0+ usando `_DARWIN_C_SOURCE` invece di `_POSIX_C_SOURCE`
2. Assicurati di avere l'ultima versione del codice
3. Pulisci e ricompila:
   ```bash
   make clean && make
   ```

### Linux: libffi Non Trovata

Se ottieni errori su `ffi.h` mancante o `-lffi`:

1. Assicurati che `libffi-dev` sia installato (vedi dipendenze sopra)
2. Verifica se `pkg-config` puÃ² trovarla:
   ```bash
   pkg-config --cflags --libs libffi
   ```
3. Se non trovata, potresti dover impostare `PKG_CONFIG_PATH`:
   ```bash
   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH
   ```

### Errori di Compilazione

Se incontri errori di compilazione:

1. Assicurati di avere un compilatore compatibile con C11
2. Su macOS, prova a usare Clang (default):
   ```bash
   make CC=clang
   ```
3. Su Linux, prova a usare GCC:
   ```bash
   make CC=gcc
   ```
4. Verifica che tutte le dipendenze siano installate
5. Prova a ricompilare da zero:
   ```bash
   make clean && make
   ```

### Fallimenti nei Test

Se i test falliscono:

1. Verifica di avere l'ultima versione del codice
2. Prova a ricompilare da zero:
   ```bash
   make clean && make test
   ```
3. Su macOS, assicurati di avere gli ultimi Xcode Command Line Tools:
   ```bash
   xcode-select --install
   ```
4. Segnala il problema su GitHub con:
   - La tua piattaforma (versione macOS / distro Linux)
   - Architettura (x86_64 / arm64)
   - Output dei test
   - Output di `make -v` e `gcc --version` (o `clang --version`)

## Prossimi Passi

- [Guida all'Avvio Rapido](#getting-started-quick-start) - Scrivi il tuo primo programma Hemlock
- [Tutorial](#getting-started-tutorial) - Impara Hemlock passo dopo passo
- [Guida al Linguaggio](#language-guide-syntax) - Esplora le funzionalitÃ  di Hemlock


--------------------------------------------------------------------------------
## Percorsi di Apprendimento
--------------------------------------------------------------------------------

# Percorsi di Apprendimento

Obiettivi diversi richiedono conoscenze diverse. Scegli il percorso che corrisponde a ciÃ² che vuoi costruire.

---

## Percorso 1: Script Veloci e Automazione

**Obiettivo:** Scrivere script per automatizzare attivitÃ , elaborare file e portare a termine il lavoro.

**Tempo per la produttivitÃ :** Veloce - puoi iniziare a scrivere script utili immediatamente.

### Cosa Imparerai

1. **[Avvio Rapido](#getting-started-quick-start)** - Il tuo primo programma, sintassi base
2. **[Stringhe](#language-guide-strings)** - Elaborazione testo, split, ricerca
3. **[Array](#language-guide-arrays)** - Liste, filtraggio, trasformazione dati
4. **[I/O File](#advanced-file-io)** - Lettura e scrittura file
5. **[Argomenti Riga Comando](#advanced-command-line-args)** - Ottenere input dagli utenti

### Salta Per Ora

- Gestione memoria (automatica per gli script)
- Async/concorrenza (eccessivo per script semplici)
- FFI (necessario solo per interop C)

### Progetto Esempio: Rinominatore File

```hemlock
import { list_dir, rename } from "@stdlib/fs";

// Rinomina tutti i file .txt in .md
let files = list_dir(".");
for (file in files) {
    if (file.ends_with(".txt")) {
        let new_name = file.replace(".txt", ".md");
        rename(file, new_name);
        print(`Rinominato: ${file} -> ${new_name}`);
    }
}
```

---

## Percorso 2: Elaborazione e Analisi Dati

**Obiettivo:** Parsare dati, trasformarli, generare report.

**Tempo per la produttivitÃ :** Veloce - I metodi stringa e array di Hemlock rendono questo facile.

### Cosa Imparerai

1. **[Avvio Rapido](#getting-started-quick-start)** - Basi
2. **[Stringhe](#language-guide-strings)** - Parsing, split, formattazione
3. **[Array](#language-guide-arrays)** - map, filter, reduce per trasformazione dati
4. **[Oggetti](#language-guide-objects)** - Dati strutturati
5. **Libreria Standard:**
   - **[@stdlib/json](#stdlib-json)** - Parsing JSON
   - **[@stdlib/csv](#stdlib-csv)** - File CSV
   - **[@stdlib/fs](#stdlib-fs)** - Operazioni file

### Progetto Esempio: Analizzatore CSV

```hemlock
import { read_file } from "@stdlib/fs";
import { parse } from "@stdlib/csv";

let data = parse(read_file("vendite.csv"));

// Calcola vendite totali
let total = 0;
for (row in data) {
    total = total + f64(row.amount);
}

print(`Vendite totali: â‚¬${total}`);

// Trova il top venditore
let top = data[0];
for (row in data) {
    if (f64(row.amount) > f64(top.amount)) {
        top = row;
    }
}

print(`Vendita top: ${top.product} - â‚¬${top.amount}`);
```

---

## Percorso 3: Programmazione Web e Network

**Obiettivo:** Costruire client HTTP, lavorare con API, creare server.

**Tempo per la produttivitÃ :** Medio - richiede comprensione delle basi async.

### Cosa Imparerai

1. **[Avvio Rapido](#getting-started-quick-start)** - Basi
2. **[Funzioni](#language-guide-functions)** - Callback e closure
3. **[Gestione Errori](#language-guide-error-handling)** - try/catch per errori di rete
4. **[Async e Concorrenza](#advanced-async-concurrency)** - spawn, await, canali
5. **Libreria Standard:**
   - **[@stdlib/http](#stdlib-http)** - Richieste HTTP
   - **[@stdlib/json](#stdlib-json)** - JSON per API
   - **[@stdlib/net](#stdlib-net)** - Socket TCP/UDP
   - **[@stdlib/url](#stdlib-url)** - Parsing URL

### Progetto Esempio: Client API

```hemlock
import { http_get, http_post } from "@stdlib/http";
import { parse, stringify } from "@stdlib/json";

// Richiesta GET
let response = http_get("https://api.example.com/users");
let users = parse(response.body);

for (user in users) {
    print(`${user.name}: ${user.email}`);
}

// Richiesta POST
let new_user = { name: "Alice", email: "alice@example.com" };
let result = http_post("https://api.example.com/users", {
    body: stringify(new_user),
    headers: { "Content-Type": "application/json" }
});

print(`Creato utente con ID: ${parse(result.body).id}`);
```

---

## Percorso 4: Programmazione di Sistema

**Obiettivo:** Scrivere codice a basso livello, lavorare con la memoria, interfacciarsi con librerie C.

**Tempo per la produttivitÃ :** PiÃ¹ lungo - richiede comprensione della gestione memoria.

### Cosa Imparerai

1. **[Avvio Rapido](#getting-started-quick-start)** - Basi
2. **[Tipi](#language-guide-types)** - Comprendere i32, u8, ptr, ecc.
3. **[Gestione Memoria](#language-guide-memory)** - alloc, free, buffer
4. **[FFI](#advanced-ffi)** - Chiamare funzioni C
5. **[Segnali](#advanced-signals)** - Gestione segnali

### Concetti Chiave

**Checklist Sicurezza Memoria:**
- [ ] Ogni `alloc()` ha un `free()` corrispondente
- [ ] Usa `buffer()` a meno che tu non abbia bisogno di `ptr` raw
- [ ] Imposta i puntatori a `null` dopo aver liberato
- [ ] Usa `try/finally` per garantire la pulizia

**Mappatura Tipi per FFI:**
| Hemlock | C |
|---------|---|
| `i8` | `char` / `int8_t` |
| `i32` | `int` |
| `i64` | `long` (64-bit) |
| `u8` | `unsigned char` |
| `f64` | `double` |
| `ptr` | `void*` |

### Progetto Esempio: Pool di Memoria Custom

```hemlock
// Semplice allocatore bump
let pool_size = 1024 * 1024;  // 1MB
let pool = alloc(pool_size);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > pool_size) {
        throw "Pool esaurito";
    }
    let p = pool + pool_offset;
    pool_offset = pool_offset + size;
    return p;
}

fn pool_reset() {
    pool_offset = 0;
}

fn pool_destroy() {
    free(pool);
}

// Usalo
let a = pool_alloc(100);
let b = pool_alloc(200);
memset(a, 0, 100);
memset(b, 0, 200);

pool_reset();    // Riusa tutta la memoria
pool_destroy();  // Pulisci
```

---

## Percorso 5: Programmi Paralleli e Concorrenti

**Obiettivo:** Eseguire codice su piÃ¹ core CPU, costruire applicazioni reattive.

**Tempo per la produttivitÃ :** Medio - la sintassi async Ã¨ diretta, ma ragionare sul parallelismo richiede pratica.

### Cosa Imparerai

1. **[Avvio Rapido](#getting-started-quick-start)** - Basi
2. **[Funzioni](#language-guide-functions)** - Closure (importanti per async)
3. **[Async e Concorrenza](#advanced-async-concurrency)** - Approfondimento completo
4. **[Atomiche](#advanced-atomics)** - Programmazione lock-free

### Concetti Chiave

**Modello async di Hemlock:**
- `async fn` - Definisce una funzione che puÃ² girare su un altro thread
- `spawn(fn, args...)` - Inizia l'esecuzione, restituisce un handle task
- `join(task)` o `await task` - Aspetta che finisca, ottieni il risultato
- `channel(size)` - Crea una coda per inviare dati tra task

**Importante:** I task ricevono *copie* dei valori. Se passi un puntatore, sei responsabile di assicurarti che la memoria rimanga valida fino al completamento del task.

### Progetto Esempio: Processore File Parallelo

```hemlock
import { list_dir, read_file } from "@stdlib/fs";

async fn process_file(path: string): i32 {
    let content = read_file(path);
    let lines = content.split("\n");
    return lines.length;
}

// Processa tutti i file in parallelo
let files = list_dir("data/");
let tasks = [];

for (file in files) {
    if (file.ends_with(".txt")) {
        let task = spawn(process_file, "data/" + file);
        tasks.push({ name: file, task: task });
    }
}

// Raccogli risultati
let total_lines = 0;
for (item in tasks) {
    let count = join(item.task);
    print(`${item.name}: ${count} righe`);
    total_lines = total_lines + count;
}

print(`Totale: ${total_lines} righe`);
```

---

## Cosa Imparare Prima (Qualsiasi Percorso)

Indipendentemente dal tuo obiettivo, inizia con questi fondamentali:

### Settimana 1: Basi Fondamentali
1. **[Avvio Rapido](#getting-started-quick-start)** - Scrivi ed esegui il tuo primo programma
2. **[Sintassi](#language-guide-syntax)** - Variabili, operatori, flusso di controllo
3. **[Funzioni](#language-guide-functions)** - Definisci e chiama funzioni

### Settimana 2: Gestione Dati
4. **[Stringhe](#language-guide-strings)** - Manipolazione testo
5. **[Array](#language-guide-arrays)** - Collezioni e iterazione
6. **[Oggetti](#language-guide-objects)** - Dati strutturati

### Settimana 3: Robustezza
7. **[Gestione Errori](#language-guide-error-handling)** - try/catch/throw
8. **[Moduli](#language-guide-modules)** - Import/export, uso stdlib

### Poi: Scegli il Tuo Percorso Sopra

---

## Cheat Sheet: Provenienza da Altri Linguaggi

### Da Python

| Python | Hemlock | Note |
|--------|---------|------|
| `x = 42` | `let x = 42;` | Punto e virgola richiesto |
| `def fn():` | `fn name() { }` | Parentesi graffe richieste |
| `if x:` | `if (x) { }` | Parentesi e graffe richieste |
| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | Cicli for stile C |
| `for item in list:` | `for (item in array) { }` | For-in funziona uguale |
| `list.append(x)` | `array.push(x);` | Nome metodo diverso |
| `len(s)` | `s.length` o `len(s)` | Entrambi funzionano |
| Memoria automatica | Manuale per `ptr` | La maggior parte dei tipi auto-pulizia |

### Da JavaScript

| JavaScript | Hemlock | Note |
|------------|---------|------|
| `let x = 42` | `let x = 42;` | Uguale (punto e virgola richiesto) |
| `const x = 42` | `let x = 42;` | Nessuna keyword const |
| `function fn()` | `fn name() { }` | Keyword diversa |
| `() => x` | `fn() { return x; }` | Nessuna arrow function |
| `async/await` | `async/await` | Stessa sintassi |
| `Promise` | `spawn/join` | Modello diverso |
| GC automatico | Manuale per `ptr` | La maggior parte dei tipi auto-pulizia |

### Da C/C++

| C | Hemlock | Note |
|---|---------|------|
| `int x = 42;` | `let x: i32 = 42;` | Tipo dopo due punti |
| `malloc(n)` | `alloc(n)` | Stesso concetto |
| `free(p)` | `free(p)` | Uguale |
| `char* s = "hi"` | `let s = "hi";` | Le stringhe sono gestite |
| `#include` | `import { } from` | Import moduli |
| Tutto manuale | Auto per la maggior parte dei tipi | Solo `ptr` richiede manuale |

---

## Ottenere Aiuto

- **[Glossario](../glossary.md)** - Definizioni dei termini di programmazione
- **[Esempi](../../examples/)** - Programmi funzionanti completi
- **[Test](../../tests/)** - Vedi come vengono usate le funzionalitÃ 
- **GitHub Issues** - Fai domande, segnala bug

---

## Livelli di DifficoltÃ 

In tutta la documentazione, vedrai questi marcatori:

| Marcatore | Significato |
|-----------|-------------|
| **Principiante** | Nessuna esperienza di programmazione precedente necessaria |
| **Intermedio** | Assume conoscenza base di programmazione |
| **Avanzato** | Richiede comprensione di concetti di sistema |

Se qualcosa marcato "Principiante" ti confonde, controlla il [Glossario](../glossary.md) per le definizioni dei termini.


--------------------------------------------------------------------------------
## Tutorial
--------------------------------------------------------------------------------

# Tutorial Hemlock

Una guida completa passo dopo passo per imparare Hemlock.

## Indice

1. [Hello World](#hello-world)
2. [Variabili e Tipi](#variabili-e-tipi)
3. [Aritmetica e Operazioni](#aritmetica-e-operazioni)
4. [Flusso di Controllo](#flusso-di-controllo)
5. [Funzioni](#funzioni)
6. [Stringhe e Rune](#stringhe-e-rune)
7. [Array](#array)
8. [Oggetti](#oggetti)
9. [Gestione della Memoria](#gestione-della-memoria)
10. [Gestione degli Errori](#gestione-degli-errori)
11. [I/O su File](#io-su-file)
12. [Mettere Tutto Insieme](#mettere-tutto-insieme)

## Hello World

Iniziamo con il tradizionale primo programma:

```hemlock
print("Ciao, Mondo!");
```

Salva questo come `hello.hml` ed esegui:

```bash
./hemlock hello.hml
```

**Punti Chiave:**
- `print()` Ã¨ una funzione integrata che scrive su stdout
- Le stringhe sono racchiuse tra doppi apici
- I punto e virgola sono **obbligatori**

## Variabili e Tipi

### Dichiarare Variabili

```hemlock
// Dichiarazione base di variabile
let x = 42;
let name = "Alice";
let pi = 3.14159;

print(x);      // 42
print(name);   // Alice
print(pi);     // 3.14159
```

### Annotazioni di Tipo

Mentre i tipi sono inferiti di default, puoi essere esplicito:

```hemlock
let age: i32 = 30;
let height: f64 = 5.9;
let initial: rune = 'A';
let active: bool = true;
```

### Inferenza di Tipo

Hemlock inferisce i tipi in base ai valori:

```hemlock
let small = 42;              // i32 (entra in 32-bit)
let large = 5000000000;      // i64 (troppo grande per i32)
let decimal = 3.14;          // f64 (default per float)
let text = "ciao";           // string
let flag = true;             // bool
```

### Controllo dei Tipi

```hemlock
// Controlla i tipi con typeof()
print(typeof(42));        // "i32"
print(typeof(3.14));      // "f64"
print(typeof("ciao"));    // "string"
print(typeof(true));      // "bool"
print(typeof(null));      // "null"
```

## Aritmetica e Operazioni

### Aritmetica di Base

```hemlock
let a = 10;
let b = 3;

print(a + b);   // 13
print(a - b);   // 7
print(a * b);   // 30
print(a / b);   // 3 (divisione intera)
print(a == b);  // false
print(a > b);   // true
```

### Promozione dei Tipi

Quando si mescolano tipi, Hemlock promuove al tipo piÃ¹ grande/preciso:

```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // result Ã¨ f64 (10.0 + 3.5 = 13.5)

print(result);       // 13.5
print(typeof(result)); // "f64"
```

### Operazioni Bit a Bit

```hemlock
let a = 12;  // 1100 in binario
let b = 10;  // 1010 in binario

print(a & b);   // 8  (AND)
print(a | b);   // 14 (OR)
print(a ^ b);   // 6  (XOR)
print(a << 1);  // 24 (shift sinistro)
print(a >> 1);  // 6  (shift destro)
print(~a);      // -13 (NOT)
```

## Flusso di Controllo

### Istruzioni If

```hemlock
let x = 10;

if (x > 0) {
    print("positivo");
} else if (x < 0) {
    print("negativo");
} else {
    print("zero");
}
```

**Nota:** Le parentesi graffe sono **sempre richieste**, anche per singole istruzioni.

### Cicli While

```hemlock
let count = 0;
while (count < 5) {
    print(`Conteggio: ${count}`);
    count = count + 1;
}
```

### Cicli For

```hemlock
// Ciclo for stile C
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}

// Ciclo for-in (array)
let items = [10, 20, 30, 40];
for (let item in items) {
    print(`Elemento: ${item}`);
}
```

### Istruzioni Switch

```hemlock
let day = 3;

switch (day) {
    case 1:
        print("LunedÃ¬");
        break;
    case 2:
        print("MartedÃ¬");
        break;
    case 3:
        print("MercoledÃ¬");
        break;
    default:
        print("Altro giorno");
        break;
}
```

### Break e Continue

```hemlock
// Break: esce dal ciclo in anticipo
let i = 0;
while (i < 10) {
    if (i == 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// Stampa: 0, 1, 2, 3, 4

// Continue: salta alla prossima iterazione
for (let j = 0; j < 5; j = j + 1) {
    if (j == 2) {
        continue;
    }
    print(j);
}
// Stampa: 0, 1, 3, 4
```

## Funzioni

### Funzioni Nominate

```hemlock
fn greet(name: string): string {
    return "Ciao, " + name + "!";
}

let message = greet("Alice");
print(message);  // "Ciao, Alice!"
```

### Funzioni Anonime

```hemlock
let add = fn(a, b) {
    return a + b;
};

print(add(5, 3));  // 8
```

### Ricorsione

```hemlock
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

print(factorial(5));  // 120
```

### Closure

Le funzioni catturano il loro ambiente:

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
print(counter());  // 3
```

### Funzioni di Ordine Superiore

```hemlock
fn apply(f, x) {
    return f(x);
}

fn double(n) {
    return n * 2;
}

let result = apply(double, 21);
print(result);  // 42
```

## Stringhe e Rune

### Basi delle Stringhe

Le stringhe sono **mutabili** e **UTF-8**:

```hemlock
let s = "ciao";
print(s.length);      // 4 (conteggio caratteri)
print(s.byte_length); // 4 (conteggio byte)

// Mutazione
s[0] = 'C';
print(s);  // "Ciao"
```

### Metodi Stringa

```hemlock
let text = "  Ciao, Mondo!  ";

// Conversione maiuscole/minuscole
print(text.to_upper());  // "  CIAO, MONDO!  "
print(text.to_lower());  // "  ciao, mondo!  "

// Trim
print(text.trim());      // "Ciao, Mondo!"

// Estrazione sottostringa
let ciao = text.substr(2, 4);  // "Ciao"
let mondo = text.slice(8, 13); // "Mondo"

// Ricerca
let pos = text.find("Mondo");  // 8
let has = text.contains("o");  // true

// Split
let parts = "a,b,c".split(","); // ["a", "b", "c"]

// Sostituzione
let s = "ciao mondo".replace("mondo", "a tutti");
print(s);  // "ciao a tutti"
```

### Rune (Codepoint Unicode)

```hemlock
let ch: rune = 'A';
let emoji: rune = 'ðŸš€';

print(ch);      // 'A'
print(emoji);   // U+1F680

// Concatenazione Rune + String
let msg = '>' + " Importante";
print(msg);  // "> Importante"

// Conversione tra rune e intero
let code: i32 = ch;     // 65 (codice ASCII)
let r: rune = 128640;   // U+1F680 (ðŸš€)
```

## Array

### Basi degli Array

```hemlock
let numbers = [1, 2, 3, 4, 5];
print(numbers[0]);      // 1
print(numbers.length);  // 5

// Modifica elementi
numbers[2] = 99;
print(numbers[2]);  // 99
```

### Metodi Array

```hemlock
let arr = [10, 20, 30];

// Aggiungi/rimuovi alla fine
arr.push(40);           // [10, 20, 30, 40]
let last = arr.pop();   // 40, arr Ã¨ ora [10, 20, 30]

// Aggiungi/rimuovi all'inizio
arr.unshift(5);         // [5, 10, 20, 30]
let first = arr.shift(); // 5, arr Ã¨ ora [10, 20, 30]

// Inserisci/rimuovi all'indice
arr.insert(1, 15);      // [10, 15, 20, 30]
let removed = arr.remove(2);  // 20

// Ricerca
let index = arr.find(15);     // 1
let has = arr.contains(10);   // true

// Slice
let slice = arr.slice(0, 2);  // [10, 15]

// Join in stringa
let text = arr.join(", ");    // "10, 15, 30"
```

### Iterazione

```hemlock
let items = ["mela", "banana", "ciliegia"];

// Ciclo for-in
for (let item in items) {
    print(item);
}

// Iterazione manuale
let i = 0;
while (i < items.length) {
    print(items[i]);
    i = i + 1;
}
```

## Oggetti

### Letterali Oggetto

```hemlock
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};

print(person.name);  // "Alice"
print(person.age);   // 30

// Aggiungi/modifica campi
person.email = "alice@example.com";
person.age = 31;
```

### Metodi e `self`

```hemlock
let calculator = {
    value: 0,
    add: fn(x) {
        self.value = self.value + x;
    },
    get: fn() {
        return self.value;
    }
};

calculator.add(10);
calculator.add(5);
print(calculator.get());  // 15
```

### Definizioni di Tipo (Duck Typing)

```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,  // Opzionale con default
}

let p = { name: "Bob", age: 25 };
let typed: Person = p;  // Duck typing valida la struttura

print(typeof(typed));   // "Person"
print(typed.active);    // true (default applicato)
```

### Serializzazione JSON

```hemlock
let obj = { x: 10, y: 20, name: "test" };

// Object a JSON
let json = obj.serialize();
print(json);  // {"x":10,"y":20,"name":"test"}

// JSON a Object
let restored = json.deserialize();
print(restored.name);  // "test"
```

## Gestione della Memoria

### Buffer Sicuri (Raccomandato)

```hemlock
// Alloca buffer
let buf = buffer(10);
print(buf.length);    // 10
print(buf.capacity);  // 10

// Imposta valori (controllo limiti)
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

// Accedi valori
print(buf[0]);  // 65

// Deve essere liberato quando finito
free(buf);
```

### Puntatori Raw (Avanzato)

```hemlock
// Alloca memoria raw
let ptr = alloc(100);

// Riempi con zeri
memset(ptr, 0, 100);

// Copia dati
let src = alloc(50);
memcpy(ptr, src, 50);

// Libera entrambi
free(src);
free(ptr);
```

### Funzioni di Memoria

```hemlock
// Rialloca
let p = alloc(64);
p = realloc(p, 128);  // Ridimensiona a 128 byte
free(p);

// Allocazione tipizzata (futuro)
// let arr = talloc(i32, 100);  // Array di 100 i32
```

## Gestione degli Errori

### Try/Catch

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "divisione per zero";
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    print(result);
} catch (e) {
    print("Errore: " + e);
}
// Output: Errore: divisione per zero
```

### Blocco Finally

```hemlock
let file = null;

try {
    file = open("data.txt", "r");
    let content = file.read();
    print(content);
} catch (e) {
    print("Errore: " + e);
} finally {
    // Sempre eseguito
    if (file != null) {
        file.close();
    }
}
```

### Lanciare Oggetti

```hemlock
try {
    throw { code: 404, message: "Non trovato" };
} catch (e) {
    print(`Errore ${e.code}: ${e.message}`);
}
// Output: Errore 404: Non trovato
```

### Panic (Errori Irrecuperabili)

```hemlock
fn validate(x) {
    if (x < 0) {
        panic("x deve essere non-negativo");
    }
    return x * 2;
}

validate(-5);  // Programma esce con: panic: x deve essere non-negativo
```

## I/O su File

### Lettura File

```hemlock
// Leggi intero file
let f = open("data.txt", "r");
let content = f.read();
print(content);
f.close();

// Leggi numero specifico di byte
let f2 = open("data.txt", "r");
let chunk = f2.read(100);  // Leggi 100 byte
f2.close();
```

### Scrittura File

```hemlock
// Scrivi testo
let f = open("output.txt", "w");
f.write("Ciao, File!\n");
f.write("Seconda riga\n");
f.close();

// Aggiungi a file
let f2 = open("output.txt", "a");
f2.write("Riga aggiunta\n");
f2.close();
```

### I/O Binario

```hemlock
// Scrivi dati binari
let buf = buffer(256);
buf[0] = 255;
buf[1] = 128;

let f = open("data.bin", "w");
f.write_bytes(buf);
f.close();

// Leggi dati binari
let f2 = open("data.bin", "r");
let data = f2.read_bytes(256);
print(data[0]);  // 255
f2.close();

free(buf);
free(data);
```

### ProprietÃ  File

```hemlock
let f = open("/path/to/file.txt", "r");

print(f.path);    // "/path/to/file.txt"
print(f.mode);    // "r"
print(f.closed);  // false

f.close();
print(f.closed);  // true
```

## Mettere Tutto Insieme

Costruiamo un semplice programma conta-parole:

```hemlock
// wordcount.hml - Conta le parole in un file

fn count_words(filename: string): i32 {
    let file = null;
    let count = 0;

    try {
        file = open(filename, "r");
        let content = file.read();

        // Dividi per spazi e conta
        let words = content.split(" ");
        count = words.length;

    } catch (e) {
        print("Errore lettura file: " + e);
        return -1;
    } finally {
        if (file != null) {
            file.close();
        }
    }

    return count;
}

// Programma principale
if (args.length < 2) {
    print("Uso: " + args[0] + " <filename>");
} else {
    let filename = args[1];
    let words = count_words(filename);

    if (words >= 0) {
        print(`Conteggio parole: ${words}`);
    }
}
```

Esegui con:
```bash
./hemlock wordcount.hml data.txt
```

## Prossimi Passi

Congratulazioni! Hai imparato le basi di Hemlock. Ecco cosa esplorare dopo:

- [Async e Concorrenza](#advanced-async-concurrency) - Vero multi-threading
- [FFI](#advanced-ffi) - Chiama funzioni C
- [Gestione Segnali](#advanced-signals) - Segnali di processo
- [Riferimento API](#reference-builtins) - Documentazione API completa
- [Esempi](../../examples/) - Altri programmi reali

## Esercizi Pratici

Prova a costruire questi programmi per esercitarti:

1. **Calcolatrice**: Implementa una semplice calcolatrice con +, -, *, /
2. **Copia File**: Copia un file in un altro
3. **Fibonacci**: Genera numeri di Fibonacci
4. **Parser JSON**: Leggi e parsa file JSON
5. **Processore Testo**: Trova e sostituisci testo nei file

Buona programmazione con Hemlock!



################################################################################
# GUIDA AL LINGUAGGIO
################################################################################

--------------------------------------------------------------------------------
## Array
--------------------------------------------------------------------------------

# Array

Hemlock fornisce **array dinamici** con metodi completi per la manipolazione e l'elaborazione dei dati. Gli array possono contenere tipi misti e crescono automaticamente secondo necessita.

## Panoramica

```hemlock
// Letterali array
let arr = [1, 2, 3, 4, 5];
print(arr[0]);         // 1
print(arr.length);     // 5

// Tipi misti consentiti
let mixed = [1, "ciao", true, null];

// Dimensionamento dinamico
arr.push(6);           // Cresce automaticamente
arr.push(7);
print(arr.length);     // 7
```

## Letterali array

### Sintassi di base

```hemlock
let numbers = [1, 2, 3, 4, 5];
let strings = ["mela", "banana", "ciliegia"];
let booleans = [true, false, true];
```

### Array vuoti

```hemlock
let arr = [];  // Array vuoto

// Aggiungere elementi dopo
arr.push(1);
arr.push(2);
arr.push(3);
```

### Tipi misti

Gli array possono contenere tipi diversi:

```hemlock
let mixed = [
    42,
    "ciao",
    true,
    null,
    [1, 2, 3],
    { x: 10, y: 20 }
];

print(mixed[0]);  // 42
print(mixed[1]);  // "ciao"
print(mixed[4]);  // [1, 2, 3] (array annidato)
```

### Array annidati

```hemlock
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

print(matrix[0][0]);  // 1
print(matrix[1][2]);  // 6
print(matrix[2][1]);  // 8
```

### Array tipizzati

Gli array possono avere annotazioni di tipo per imporre i tipi degli elementi:

```hemlock
// Sintassi array tipizzato
let nums: array<i32> = [1, 2, 3, 4, 5];
let names: array<string> = ["Alice", "Bob", "Carol"];
let flags: array<bool> = [true, false, true];

// Verifica del tipo a runtime
let valid: array<i32> = [1, 2, 3];       // OK
let invalid: array<i32> = [1, "due", 3]; // Errore runtime: tipo non corrispondente

// Array tipizzati annidati
let matrix: array<array<i32>> = [
    [1, 2, 3],
    [4, 5, 6]
];
```

**Comportamento dell'annotazione di tipo:**
- Gli elementi vengono verificati quando aggiunti all'array
- Le incompatibilita di tipo causano errori a runtime
- Senza annotazione di tipo, gli array accettano tipi misti

## Indicizzazione

### Lettura degli elementi

Accesso con indice da zero:

```hemlock
let arr = [10, 20, 30, 40, 50];

print(arr[0]);  // 10 (primo elemento)
print(arr[4]);  // 50 (ultimo elemento)

// Fuori dai limiti restituisce null (nessun errore)
print(arr[10]);  // null
```

### Scrittura degli elementi

```hemlock
let arr = [1, 2, 3];

arr[0] = 10;    // Modificare esistente
arr[1] = 20;
print(arr);     // [10, 20, 3]

// Puo assegnare oltre la lunghezza attuale (fa crescere l'array)
arr[5] = 60;    // Crea [10, 20, 3, null, null, 60]
```

### Indici negativi

**Non supportati** - Usa solo indici positivi:

```hemlock
let arr = [1, 2, 3];
print(arr[-1]);  // ERRORE o comportamento indefinito

// Usa length per l'ultimo elemento
print(arr[arr.length - 1]);  // 3
```

## Proprieta

### Proprieta `.length`

Restituisce il numero di elementi:

```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);  // 5

// Array vuoto
let empty = [];
print(empty.length);  // 0

// Dopo le modifiche
arr.push(6);
print(arr.length);  // 6
```

## Metodi array

Hemlock fornisce 18 metodi array per una manipolazione completa.

### Operazioni stack

**`push(value)`** - Aggiunge elemento alla fine:
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]

print(arr.length);     // 5
```

**`pop()`** - Rimuove e restituisce l'ultimo elemento:
```hemlock
let arr = [1, 2, 3, 4, 5];
let last = arr.pop();  // Restituisce 5, arr e ora [1, 2, 3, 4]

print(last);           // 5
print(arr.length);     // 4
```

### Operazioni coda

**`shift()`** - Rimuove e restituisce il primo elemento:
```hemlock
let arr = [1, 2, 3];
let first = arr.shift();   // Restituisce 1, arr e ora [2, 3]

print(first);              // 1
print(arr);                // [2, 3]
```

**`unshift(value)`** - Aggiunge elemento all'inizio:
```hemlock
let arr = [2, 3];
arr.unshift(1);            // [1, 2, 3]
arr.unshift(0);            // [0, 1, 2, 3]
```

### Inserimento e rimozione

**`insert(index, value)`** - Inserisce elemento all'indice:
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // Inserisce 3 all'indice 2: [1, 2, 3, 4, 5]

arr.insert(0, 0);      // Inserisce all'inizio: [0, 1, 2, 3, 4, 5]
```

**`remove(index)`** - Rimuove e restituisce elemento all'indice:
```hemlock
let arr = [1, 2, 3, 4, 5];
let removed = arr.remove(2);  // Restituisce 3, arr e ora [1, 2, 4, 5]

print(removed);               // 3
print(arr);                   // [1, 2, 4, 5]
```

### Operazioni di ricerca

**`find(value)`** - Trova la prima occorrenza:
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2 (indice della prima occorrenza)
let idx2 = arr.find(99);     // -1 (non trovato)

// Funziona con qualsiasi tipo
let words = ["mela", "banana", "ciliegia"];
let idx3 = words.find("banana");  // 1
```

**`contains(value)`** - Verifica se l'array contiene il valore:
```hemlock
let arr = [10, 20, 30, 40];
let has = arr.contains(20);  // true
let has2 = arr.contains(99); // false
```

### Operazioni di estrazione

**`slice(start, end)`** - Estrae sottoarray (end esclusivo):
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);   // [2, 3, 4] (indici 1, 2, 3)
let first = arr.slice(0, 2); // [1, 2]

// Originale invariato
print(arr);                  // [1, 2, 3, 4, 5]
```

**`first()`** - Ottiene il primo elemento (senza rimuovere):
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1 (senza rimuovere)
print(arr);                  // [1, 2, 3] (invariato)
```

**`last()`** - Ottiene l'ultimo elemento (senza rimuovere):
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3 (senza rimuovere)
print(arr);                  // [1, 2, 3] (invariato)
```

### Operazioni di trasformazione

**`reverse()`** - Inverte l'array sul posto:
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]

print(arr);                  // [5, 4, 3, 2, 1] (modificato)
```

**`join(delimiter)`** - Unisce gli elementi in una stringa:
```hemlock
let words = ["ciao", "mondo", "foo"];
let joined = words.join(" ");  // "ciao mondo foo"

let numbers = [1, 2, 3];
let csv = numbers.join(",");   // "1,2,3"

// Funziona con tipi misti
let mixed = [1, "ciao", true, null];
print(mixed.join(" | "));  // "1 | ciao | true | null"
```

**`concat(other)`** - Concatena con un altro array:
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (nuovo array)

// Originali invariati
print(a);                    // [1, 2, 3]
print(b);                    // [4, 5, 6]
```

### Operazioni di utilita

**`clear()`** - Rimuove tutti gli elementi:
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();                 // []

print(arr.length);           // 0
print(arr);                  // []
```

## Concatenamento dei metodi

I metodi che restituiscono array o valori consentono il concatenamento:

```hemlock
let result = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);  // [3, 4, 5]

let text = ["mela", "banana", "ciliegia"]
    .slice(0, 2)
    .join(" e ");  // "mela e banana"

let numbers = [5, 3, 8, 1, 9]
    .slice(1, 4)
    .concat([10, 11]);  // [3, 8, 1, 10, 11]
```

## Riferimento completo dei metodi

| Metodo | Parametri | Restituisce | Muta | Descrizione |
|--------|-----------|-------------|------|-------------|
| `push(value)` | any | void | Si | Aggiunge elemento alla fine |
| `pop()` | - | any | Si | Rimuove e restituisce l'ultimo |
| `shift()` | - | any | Si | Rimuove e restituisce il primo |
| `unshift(value)` | any | void | Si | Aggiunge elemento all'inizio |
| `insert(index, value)` | i32, any | void | Si | Inserisce all'indice |
| `remove(index)` | i32 | any | Si | Rimuove e restituisce all'indice |
| `find(value)` | any | i32 | No | Trova prima occorrenza (-1 se non trovato) |
| `contains(value)` | any | bool | No | Verifica se contiene il valore |
| `slice(start, end)` | i32, i32 | array | No | Estrae sottoarray (nuovo array) |
| `join(delimiter)` | string | string | No | Unisce in stringa |
| `concat(other)` | array | array | No | Concatena (nuovo array) |
| `reverse()` | - | void | Si | Inverte sul posto |
| `first()` | - | any | No | Ottiene primo elemento |
| `last()` | - | any | No | Ottiene ultimo elemento |
| `clear()` | - | void | Si | Rimuove tutti gli elementi |
| `map(callback)` | fn | array | No | Trasforma ogni elemento |
| `filter(predicate)` | fn | array | No | Seleziona elementi corrispondenti |
| `reduce(callback, initial)` | fn, any | any | No | Riduce a singolo valore |

## Dettagli di implementazione

### Modello di memoria

- **Allocato nell'heap** - Capacita dinamica
- **Crescita automatica** - Raddoppia la capacita quando superata
- **Nessun restringimento automatico** - La capacita non diminuisce
- **Nessun controllo dei limiti sull'indicizzazione** - Usa i metodi per la sicurezza

### Gestione della capacita

```hemlock
let arr = [];  // Capacita iniziale: 0

arr.push(1);   // Cresce a capacita 1
arr.push(2);   // Cresce a capacita 2
arr.push(3);   // Cresce a capacita 4 (raddoppia)
arr.push(4);   // Ancora capacita 4
arr.push(5);   // Cresce a capacita 8 (raddoppia)
```

### Confronto dei valori

`find()` e `contains()` usano l'uguaglianza di valore:

```hemlock
// Primitivi: confronto per valore
let arr = [1, 2, 3];
arr.contains(2);  // true

// Stringhe: confronto per valore
let words = ["ciao", "mondo"];
words.contains("ciao");  // true

// Oggetti: confronto per riferimento
let obj1 = { x: 10 };
let obj2 = { x: 10 };
let arr2 = [obj1];
arr2.contains(obj1);  // true (stesso riferimento)
arr2.contains(obj2);  // false (riferimento diverso)
```

## Pattern comuni

### Operazioni funzionali (map/filter/reduce)

Gli array hanno metodi integrati `map`, `filter` e `reduce`:

```hemlock
// map - trasforma ogni elemento
let numbers = [1, 2, 3, 4, 5];
let doubled = numbers.map(fn(x) { return x * 2; });
print(doubled);  // [2, 4, 6, 8, 10]

// filter - seleziona elementi corrispondenti
let evens = numbers.filter(fn(x) { return x % 2 == 0; });
print(evens);  // [2, 4]

// reduce - accumula in singolo valore
let sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);
print(sum);  // 15

// Concatenamento di operazioni funzionali
let result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]
    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]
    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220
```

### Pattern: Array come stack

```hemlock
let stack = [];

// Push sullo stack
stack.push(1);
stack.push(2);
stack.push(3);

// Pop dallo stack
let top = stack.pop();    // 3
let next = stack.pop();   // 2
```

### Pattern: Array come coda

```hemlock
let queue = [];

// Enqueue (aggiungi alla fine)
queue.push(1);
queue.push(2);
queue.push(3);

// Dequeue (rimuovi dalla testa)
let first = queue.shift();   // 1
let second = queue.shift();  // 2
```

## Buone pratiche

1. **Usa i metodi invece dell'indicizzazione diretta** - Controllo dei limiti e chiarezza
2. **Controlla i limiti** - L'indicizzazione diretta non controlla i limiti
3. **Preferisci operazioni immutabili** - Usa `slice()` e `concat()` invece della mutazione
4. **Inizializza con capacita** - Se conosci la dimensione (non attualmente supportato)
5. **Usa `contains()` per l'appartenenza** - Piu chiaro dei cicli manuali
6. **Concatena i metodi** - Piu leggibile delle chiamate annidate

## Trabocchetti comuni

### Trabocchetto: Indice diretto fuori dai limiti

```hemlock
let arr = [1, 2, 3];

// Nessun controllo dei limiti!
arr[10] = 99;  // Crea array sparso con null
print(arr.length);  // 11 (non 3!)

// Meglio: Usa push() o controlla la lunghezza
if (arr.length <= 10) {
    arr.push(99);
}
```

### Trabocchetto: Mutazione vs. Nuovo array

```hemlock
let arr = [1, 2, 3];

// Muta l'originale
arr.reverse();
print(arr);  // [3, 2, 1]

// Restituisce nuovo array
let sub = arr.slice(0, 2);
print(arr);  // [3, 2, 1] (invariato)
print(sub);  // [3, 2]
```

### Trabocchetto: Uguaglianza per riferimento

```hemlock
let obj = { x: 10 };
let arr = [obj];

// Stesso riferimento: true
arr.contains(obj);  // true

// Riferimento diverso: false
arr.contains({ x: 10 });  // false (oggetto diverso)
```

### Trabocchetto: Array a lunga durata

```hemlock
// Gli array nello scope locale vengono liberati automaticamente, ma gli array globali/a lunga durata richiedono attenzione
let global_cache = [];  // Livello modulo, persiste fino alla fine del programma

fn add_to_cache(item) {
    global_cache.push(item);  // Cresce indefinitamente
}

// Per dati a lunga durata, considera:
// - Svuotare l'array periodicamente: global_cache.clear();
// - Liberare anticipatamente quando finito: free(global_cache);
```

## Esempi

### Esempio: Statistiche array

```hemlock
fn mean(arr) {
    let sum = 0;
    let i = 0;
    while (i < arr.length) {
        sum = sum + arr[i];
        i = i + 1;
    }
    return sum / arr.length;
}

fn max(arr) {
    if (arr.length == 0) {
        return null;
    }

    let max_val = arr[0];
    let i = 1;
    while (i < arr.length) {
        if (arr[i] > max_val) {
            max_val = arr[i];
        }
        i = i + 1;
    }
    return max_val;
}

let numbers = [3, 7, 2, 9, 1];
print(mean(numbers));  // 4.4
print(max(numbers));   // 9
```

### Esempio: Deduplicazione array

```hemlock
fn unique(arr) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        if (!result.contains(arr[i])) {
            result.push(arr[i]);
        }
        i = i + 1;
    }
    return result;
}

let numbers = [1, 2, 2, 3, 1, 4, 3, 5];
let uniq = unique(numbers);  // [1, 2, 3, 4, 5]
```

### Esempio: Suddivisione in chunk

```hemlock
fn chunk(arr, size) {
    let result = [];
    let i = 0;

    while (i < arr.length) {
        let chunk = arr.slice(i, i + size);
        result.push(chunk);
        i = i + size;
    }

    return result;
}

let numbers = [1, 2, 3, 4, 5, 6, 7, 8];
let chunks = chunk(numbers, 3);
// [[1, 2, 3], [4, 5, 6], [7, 8]]
```

### Esempio: Appiattimento array

```hemlock
fn flatten(arr) {
    let result = [];
    let i = 0;

    while (i < arr.length) {
        if (typeof(arr[i]) == "array") {
            // Array annidato - appiattiscilo
            let nested = flatten(arr[i]);
            let j = 0;
            while (j < nested.length) {
                result.push(nested[j]);
                j = j + 1;
            }
        } else {
            result.push(arr[i]);
        }
        i = i + 1;
    }

    return result;
}

let nested = [1, [2, 3], [4, [5, 6]], 7];
let flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]
```

### Esempio: Ordinamento (Bubble Sort)

```hemlock
fn sort(arr) {
    let n = arr.length;
    let i = 0;

    while (i < n) {
        let j = 0;
        while (j < n - i - 1) {
            if (arr[j] > arr[j + 1]) {
                // Scambia
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

let numbers = [5, 2, 8, 1, 9];
sort(numbers);  // Modifica sul posto
print(numbers);  // [1, 2, 5, 8, 9]
```

## Limitazioni

Limitazioni attuali:

- **Nessun controllo dei limiti sull'indicizzazione** - L'accesso diretto non e controllato
- **Uguaglianza per riferimento per gli oggetti** - `find()` e `contains()` usano confronto per riferimento
- **Nessuna destrutturazione array** - Nessuna sintassi `let [a, b] = arr`
- **Nessun operatore spread** - Nessuna sintassi `[...arr1, ...arr2]`

**Nota:** Gli array sono conteggiati per riferimento e liberati automaticamente quando lo scope termina. Vedi [Gestione della memoria](memory.md#conteggio-interno-dei-riferimenti) per i dettagli.

## Argomenti correlati

- [Stringhe](#language-guide-strings) - Metodi stringa simili ai metodi array
- [Oggetti](#language-guide-objects) - Gli array sono anche simili agli oggetti
- [Funzioni](#language-guide-functions) - Funzioni di ordine superiore con array
- [Flusso di controllo](#language-guide-control-flow) - Iterazione sugli array

## Vedi anche

- **Dimensionamento dinamico**: Gli array crescono automaticamente con raddoppio della capacita
- **Metodi**: 18 metodi completi per la manipolazione inclusi map/filter/reduce
- **Memoria**: Vedi [Memoria](#language-guide-memory) per i dettagli sull'allocazione degli array


--------------------------------------------------------------------------------
## Flusso di Controllo
--------------------------------------------------------------------------------

# Control Flow

Hemlock provides familiar C-style control flow with mandatory braces and explicit syntax. This guide covers conditionals, loops, switch statements, and operators.

## Overview

Available control flow features:

- `if`/`else`/`else if` - Conditional branches
- `while` loops - Condition-based iteration
- `for` loops - C-style and for-in iteration
- `loop` - Infinite loops (cleaner than `while (true)`)
- `switch` statements - Multi-way branching
- `break`/`continue` - Loop control
- Loop labels - Targeted break/continue for nested loops
- `defer` - Deferred execution (cleanup)
- Boolean operators: `&&`, `||`, `!`
- Comparison operators: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Bitwise operators: `&`, `|`, `^`, `<<`, `>>`, `~`

## If Statements

### Basic If/Else

```hemlock
if (x > 10) {
    print("large");
} else {
    print("small");
}
```

**Rules:**
- Braces are **always required** for all branches
- Conditions must be enclosed in parentheses
- No optional braces (unlike C)

### If Without Else

```hemlock
if (x > 0) {
    print("positive");
}
// No else branch needed
```

### Else-If Chains

```hemlock
if (x > 100) {
    print("very large");
} else if (x > 50) {
    print("large");
} else if (x > 10) {
    print("medium");
} else {
    print("small");
}
```

**Note:** `else if` is syntactic sugar for nested if statements. These are equivalent:

```hemlock
// else if (syntactic sugar)
if (a) {
    foo();
} else if (b) {
    bar();
}

// Equivalent nested if
if (a) {
    foo();
} else {
    if (b) {
        bar();
    }
}
```

### Nested If Statements

```hemlock
if (x > 0) {
    if (x < 10) {
        print("single digit positive");
    } else {
        print("multi-digit positive");
    }
} else {
    print("non-positive");
}
```

## While Loops

Condition-based iteration:

```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

**Infinite loops (old style):**
```hemlock
while (true) {
    // ... do work
    if (should_exit) {
        break;
    }
}
```

**Note:** For infinite loops, prefer the `loop` keyword (see below).

## Loop (Infinite Loop)

The `loop` keyword provides a cleaner syntax for infinite loops:

```hemlock
loop {
    // ... do work
    if (should_exit) {
        break;
    }
}
```

**Equivalent to `while (true)` but more explicit about intent.**

### Basic Loop with Break

```hemlock
let i = 0;
loop {
    if (i >= 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// Prints: 0, 1, 2, 3, 4
```

### Loop with Continue

```hemlock
let i = 0;
loop {
    i = i + 1;
    if (i > 5) {
        break;
    }
    if (i == 3) {
        continue;  // Skip printing 3
    }
    print(i);
}
// Prints: 1, 2, 4, 5
```

### Nested Loops

```hemlock
let x = 0;
loop {
    if (x >= 2) { break; }
    let y = 0;
    loop {
        if (y >= 3) { break; }
        print(x * 10 + y);
        y = y + 1;
    }
    x = x + 1;
}
// Prints: 0, 1, 2, 10, 11, 12
```

### When to Use Loop

- **Use `loop`** for intentionally infinite loops that exit via `break`
- **Use `while`** when there's a natural termination condition
- **Use `for`** when iterating a known number of times or over a collection

## For Loops

### C-Style For

Classic three-part for loop:

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**Components:**
- **Initializer**: `let i = 0` - Runs once before loop
- **Condition**: `i < 10` - Checked before each iteration
- **Update**: `i = i + 1` - Runs after each iteration

**Scope:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
// i not accessible here (loop-scoped)
```

### For-In Loops

Iterate over array elements:

```hemlock
let arr = [1, 2, 3, 4, 5];
for (let item in arr) {
    print(item);  // Prints each element
}
```

**With index and value:**
```hemlock
let arr = ["a", "b", "c"];
for (let i = 0; i < arr.length; i = i + 1) {
    print(`Index: ${i}, Value: ${arr[i]}`);
}
```

## Switch Statements

Multi-way branching based on value:

### Basic Switch

```hemlock
let x = 2;

switch (x) {
    case 1:
        print("one");
        break;
    case 2:
        print("two");
        break;
    case 3:
        print("three");
        break;
}
```

### Switch with Default

```hemlock
let color = "blue";

switch (color) {
    case "red":
        print("stop");
        break;
    case "yellow":
        print("slow");
        break;
    case "green":
        print("go");
        break;
    default:
        print("unknown color");
        break;
}
```

**Rules:**
- `default` matches when no other case matches
- `default` can appear anywhere in the switch body
- Only one default case allowed

### Fall-Through Behavior

Cases without `break` fall through to the next case (C-style behavior). This is **intentional** and can be used to group cases:

```hemlock
let grade = 85;

switch (grade) {
    case 100:
    case 95:
    case 90:
        print("A");
        break;
    case 85:
    case 80:
        print("B");
        break;
    default:
        print("C or below");
        break;
}
```

**Explicit fallthrough example:**
```hemlock
let day = 3;

switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        print("Weekday");
        break;
    case 6:
    case 7:
        print("Weekend");
        break;
}
```

**Important:** Unlike some modern languages, Hemlock does NOT require an explicit `fallthrough` keyword. Cases automatically fall through unless terminated by `break`, `return`, or `throw`. Always use `break` to prevent unintended fallthrough.

### Switch with Return

In functions, `return` exits the switch immediately:

```hemlock
fn get_day_name(day: i32): string {
    switch (day) {
        case 1:
            return "Monday";
        case 2:
            return "Tuesday";
        case 3:
            return "Wednesday";
        default:
            return "Unknown";
    }
}
```

### Switch Value Types

Switch works with any value type:

```hemlock
// Integers
switch (count) {
    case 0: print("zero"); break;
    case 1: print("one"); break;
}

// Strings
switch (name) {
    case "Alice": print("A"); break;
    case "Bob": print("B"); break;
}

// Booleans
switch (flag) {
    case true: print("on"); break;
    case false: print("off"); break;
}
```

**Note:** Cases are compared using value equality.

## Break and Continue

### Break

Exit the innermost loop or switch:

```hemlock
// In loops
let i = 0;
while (true) {
    if (i >= 10) {
        break;  // Exit loop
    }
    print(i);
    i = i + 1;
}

// In switch
switch (x) {
    case 1:
        print("one");
        break;  // Exit switch
    case 2:
        print("two");
        break;
}
```

### Continue

Skip to next iteration of loop:

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;  // Skip iteration when i is 5
    }
    print(i);  // Prints 0,1,2,3,4,6,7,8,9
}
```

**Difference:**
- `break` - Exits loop entirely
- `continue` - Skips to next iteration

## Loop Labels

Loop labels allow `break` and `continue` to target specific outer loops instead of just the innermost loop. This is useful for nested loops where you need to control an outer loop from an inner one.

### Labeled Break

Exit an outer loop from an inner loop:

```hemlock
outer: while (i < 3) {
    let j = 0;
    while (j < 3) {
        if (i == 1 && j == 1) {
            break outer;  // Exit the outer while loop
        }
        print(i * 10 + j);
        j = j + 1;
    }
    i = i + 1;
}
// Prints: 0, 1, 2, 10 (stops at i=1, j=1)
```

### Labeled Continue

Skip to the next iteration of an outer loop:

```hemlock
let i = 0;
outer: while (i < 3) {
    i = i + 1;
    let j = 0;
    while (j < 3) {
        j = j + 1;
        if (i == 2 && j == 1) {
            continue outer;  // Skip rest of inner loop, continue outer
        }
        print(i * 10 + j);
    }
}
// When i=2, j=1: skips to next outer iteration
```

### Labels with For Loops

Labels work with all loop types:

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 3; y = y + 1) {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
    }
}
```

### Labels with For-In Loops

```hemlock
let arr1 = [1, 2, 3];
let arr2 = [10, 20, 30];

outer: for (let a in arr1) {
    for (let b in arr2) {
        if (a == 2 && b == 20) {
            break outer;
        }
        print(a * 100 + b);
    }
}
```

### Labels with Loop Keyword

```hemlock
let x = 0;
outer: loop {
    let y = 0;
    loop {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
        y = y + 1;
        if (y >= 3) { break; }
    }
    x = x + 1;
    if (x >= 3) { break; }
}
```

### Multiple Labels

You can have labels at different nesting levels:

```hemlock
outer: for (let a = 0; a < 2; a = a + 1) {
    inner: for (let b = 0; b < 3; b = b + 1) {
        for (let c = 0; c < 3; c = c + 1) {
            if (c == 1) {
                continue inner;  // Skip to next iteration of middle loop
            }
            if (a == 1 && b == 1) {
                break outer;      // Exit outermost loop
            }
            print(a * 100 + b * 10 + c);
        }
    }
}
```

### Unlabeled Break/Continue with Labeled Loops

Unlabeled `break` and `continue` still work normally (affecting the innermost loop), even when outer loops have labels:

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 5; y = y + 1) {
        if (y == 2) {
            break;  // Only breaks inner loop
        }
        print(x * 10 + y);
    }
}
// Prints: 0, 1, 10, 11, 20, 21
```

### Label Syntax

- Labels are identifiers followed by a colon
- Labels must immediately precede a loop statement (`while`, `for`, `loop`)
- Label names follow identifier rules (letters, digits, underscores)
- Common conventions: `outer`, `inner`, `row`, `col`, descriptive names

## Defer Statement

The `defer` statement schedules code to execute when the current function returns. This is useful for cleanup operations like closing files, freeing resources, or releasing locks.

### Basic Defer

```hemlock
fn example() {
    print("start");
    defer print("cleanup");  // Runs when function returns
    print("end");
}

example();
// Output:
// start
// end
// cleanup
```

**Key behavior:**
- Deferred statements execute **after** the function body completes
- Deferred statements execute **before** the function returns to its caller
- Deferred statements always execute, even if the function throws an exception

### Multiple Defers (LIFO Order)

When multiple `defer` statements are used, they execute in **reverse order** (Last-In-First-Out):

```hemlock
fn example() {
    defer print("first");   // Executes last
    defer print("second");  // Executes second
    defer print("third");   // Executes first
    print("body");
}

example();
// Output:
// body
// third
// second
// first
```

This LIFO order is intentional - it matches the natural order for nested resource cleanup (close inner resources before outer ones).

### Defer with Return

Deferred statements execute before `return` transfers control:

```hemlock
fn get_value(): i32 {
    defer print("cleanup");
    print("before return");
    return 42;
}

let result = get_value();
print("result:", result);
// Output:
// before return
// cleanup
// result: 42
```

### Defer with Exceptions

Deferred statements execute even when an exception is thrown:

```hemlock
fn risky() {
    defer print("cleanup 1");
    defer print("cleanup 2");
    print("before throw");
    throw "error!";
    print("after throw");  // Never reached
}

try {
    risky();
} catch (e) {
    print("Caught:", e);
}
// Output:
// before throw
// cleanup 2
// cleanup 1
// Caught: error!
```

### Resource Cleanup Pattern

The primary use case for `defer` is ensuring resources are cleaned up:

```hemlock
fn process_file(filename: string) {
    let file = open(filename, "r");
    defer file.close();  // Always closes, even on error

    let content = file.read();
    // ... process content ...

    // File automatically closed when function returns
}
```

**Without defer (error-prone):**
```hemlock
fn process_file_bad(filename: string) {
    let file = open(filename, "r");
    let content = file.read();
    // If this throws, file.close() is never called!
    process(content);
    file.close();
}
```

### Defer with Closures

Defer can use closures to capture state:

```hemlock
fn example() {
    let resource = acquire_resource();
    defer fn() {
        print("Releasing resource");
        release(resource);
    }();  // Note: immediately-invoked function expression

    use_resource(resource);
}
```

### When to Use Defer

**Use defer for:**
- Closing files and network connections
- Freeing allocated memory
- Releasing locks and mutexes
- Cleanup in any function that acquires resources

**Defer vs Finally:**
- `defer` is simpler for single-resource cleanup
- `try/finally` is better for complex error handling with recovery

### Best Practices

1. **Place defer immediately after acquiring a resource:**
   ```hemlock
   let file = open("data.txt", "r");
   defer file.close();
   // ... use file ...
   ```

2. **Use multiple defers for multiple resources:**
   ```hemlock
   let file1 = open("input.txt", "r");
   defer file1.close();

   let file2 = open("output.txt", "w");
   defer file2.close();

   // Both files will be closed in reverse order
   ```

3. **Remember LIFO order for dependent resources:**
   ```hemlock
   let outer = acquire_outer();
   defer release_outer(outer);

   let inner = acquire_inner(outer);
   defer release_inner(inner);

   // inner released before outer (correct dependency order)
   ```

## Boolean Operators

### Logical AND (`&&`)

Both conditions must be true:

```hemlock
if (x > 0 && x < 10) {
    print("single digit positive");
}
```

**Short-circuit evaluation:**
```hemlock
if (false && expensive_check()) {
    // expensive_check() never called
}
```

### Logical OR (`||`)

At least one condition must be true:

```hemlock
if (x < 0 || x > 100) {
    print("out of range");
}
```

**Short-circuit evaluation:**
```hemlock
if (true || expensive_check()) {
    // expensive_check() never called
}
```

### Logical NOT (`!`)

Negates boolean value:

```hemlock
if (!is_valid) {
    print("invalid");
}

if (!(x > 10)) {
    // Same as: if (x <= 10)
}
```

## Comparison Operators

### Equality

```hemlock
if (x == 10) { }    // Equal
if (x != 10) { }    // Not equal
```

Works with all types:
```hemlock
"hello" == "hello"  // true
true == false       // false
null == null        // true
```

### Relational

```hemlock
if (x < 10) { }     // Less than
if (x > 10) { }     // Greater than
if (x <= 10) { }    // Less than or equal
if (x >= 10) { }    // Greater than or equal
```

**Type promotion applies:**
```hemlock
let a: i32 = 10;
let b: i64 = 10;
if (a == b) { }     // true (i32 promoted to i64)
```

## Bitwise Operators

Hemlock provides bitwise operators for integer manipulation. These work **only with integer types** (i8-i64, u8-u64).

### Binary Bitwise Operators

**Bitwise AND (`&`)**
```hemlock
let a = 12;  // 1100 in binary
let b = 10;  // 1010 in binary
print(a & b);   // 8 (1000)
```

**Bitwise OR (`|`)**
```hemlock
print(a | b);   // 14 (1110)
```

**Bitwise XOR (`^`)**
```hemlock
print(a ^ b);   // 6 (0110)
```

**Left Shift (`<<`)**
```hemlock
print(a << 2);  // 48 (110000) - shift left by 2
```

**Right Shift (`>>`)**
```hemlock
print(a >> 1);  // 6 (110) - shift right by 1
```

### Unary Bitwise Operator

**Bitwise NOT (`~`)**
```hemlock
let a = 12;
print(~a);      // -13 (two's complement)

let c: u8 = 15;   // 00001111 in binary
print(~c);        // 240 (11110000) in u8
```

### Bitwise Examples

**With unsigned types:**
```hemlock
let c: u8 = 15;   // 00001111 in binary
let d: u8 = 7;    // 00000111 in binary

print(c & d);     // 7  (00000111)
print(c | d);     // 15 (00001111)
print(c ^ d);     // 8  (00001000)
print(~c);        // 240 (11110000) - in u8
```

**Type preservation:**
```hemlock
// Bitwise operations preserve the type of operands
let x: u8 = 255;
let result = ~x;  // result is u8 with value 0

let y: i32 = 100;
let result2 = y << 2;  // result2 is i32 with value 400
```

**Common patterns:**
```hemlock
// Check if bit is set
if (flags & 0x04) {
    print("bit 2 is set");
}

// Set a bit
flags = flags | 0x08;

// Clear a bit
flags = flags & ~0x02;

// Toggle a bit
flags = flags ^ 0x01;
```

### Operator Precedence

Bitwise operators follow C-style precedence:

1. `~` (unary NOT) - highest, same level as `!` and `-`
2. `<<`, `>>` (shifts) - higher than comparisons, lower than `+`/`-`
3. `&` (bitwise AND) - higher than `^` and `|`
4. `^` (bitwise XOR) - between `&` and `|`
5. `|` (bitwise OR) - lower than `&` and `^`, higher than `&&`
6. `&&`, `||` (logical) - lowest precedence

**Examples:**
```hemlock
// & has higher precedence than |
let result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12

// Shift has higher precedence than bitwise operators
let result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12

// Use parentheses for clarity
let result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5
```

**Important notes:**
- Bitwise operators only work with integer types (not floats, strings, etc.)
- Type promotion follows standard rules (smaller types promote to larger)
- Right shift (`>>`) is arithmetic for signed types, logical for unsigned
- Shift amounts are not range-checked (behavior is platform-dependent for large shifts)

## Operator Precedence (Complete)

From highest to lowest precedence:

1. **Unary**: `!`, `-`, `~`
2. **Multiplicative**: `*`, `/`, `%`
3. **Additive**: `+`, `-`
4. **Shift**: `<<`, `>>`
5. **Relational**: `<`, `>`, `<=`, `>=`
6. **Equality**: `==`, `!=`
7. **Bitwise AND**: `&`
8. **Bitwise XOR**: `^`
9. **Bitwise OR**: `|`
10. **Logical AND**: `&&`
11. **Logical OR**: `||`

**Use parentheses for clarity:**
```hemlock
// Unclear
if (a || b && c) { }

// Clear
if (a || (b && c)) { }
if ((a || b) && c) { }
```

## Common Patterns

### Pattern: Input Validation

```hemlock
fn validate_age(age: i32): bool {
    if (age < 0 || age > 150) {
        return false;
    }
    return true;
}
```

### Pattern: Range Checking

```hemlock
fn in_range(value: i32, min: i32, max: i32): bool {
    return value >= min && value <= max;
}

if (in_range(score, 0, 100)) {
    print("valid score");
}
```

### Pattern: State Machine

```hemlock
let state = "start";

while (true) {
    switch (state) {
        case "start":
            print("Starting...");
            state = "running";
            break;

        case "running":
            if (should_pause) {
                state = "paused";
            } else if (should_stop) {
                state = "stopped";
            }
            break;

        case "paused":
            if (should_resume) {
                state = "running";
            }
            break;

        case "stopped":
            print("Stopped");
            break;
    }

    if (state == "stopped") {
        break;
    }
}
```

### Pattern: Iteration with Filtering

```hemlock
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Print only even numbers
for (let i = 0; i < arr.length; i = i + 1) {
    if (arr[i] % 2 != 0) {
        continue;  // Skip odd numbers
    }
    print(arr[i]);
}
```

### Pattern: Early Exit

```hemlock
fn find_first_negative(arr: array): i32 {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // Early exit
        }
    }
    return -1;  // Not found
}
```

## Best Practices

1. **Always use braces** - Even for single-statement blocks (enforced by syntax)
2. **Explicit conditions** - Use `x == 0` instead of `!x` for clarity
3. **Avoid deep nesting** - Extract nested conditions into functions
4. **Use early returns** - Reduce nesting with guard clauses
5. **Break complex conditions** - Split into named boolean variables
6. **Default in switch** - Always include a default case
7. **Comment fall-through** - Make intentional fall-through explicit

## Common Pitfalls

### Pitfall: Assignment in Condition

```hemlock
// This is NOT allowed (no assignment in conditions)
if (x = 10) { }  // ERROR: Syntax error

// Use comparison instead
if (x == 10) { }  // OK
```

### Pitfall: Missing Break in Switch

```hemlock
// Unintentional fall-through
switch (x) {
    case 1:
        print("one");
        // Missing break - falls through!
    case 2:
        print("two");  // Executes for both 1 and 2
        break;
}

// Fix: Add break
switch (x) {
    case 1:
        print("one");
        break;  // Now correct
    case 2:
        print("two");
        break;
}
```

### Pitfall: Loop Variable Scope

```hemlock
// i is scoped to the loop
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
print(i);  // ERROR: i not defined here
```

## Examples

### Example: FizzBuzz

```hemlock
for (let i = 1; i <= 100; i = i + 1) {
    if (i % 15 == 0) {
        print("FizzBuzz");
    } else if (i % 3 == 0) {
        print("Fizz");
    } else if (i % 5 == 0) {
        print("Buzz");
    } else {
        print(i);
    }
}
```

### Example: Prime Checker

```hemlock
fn is_prime(n: i32): bool {
    if (n < 2) {
        return false;
    }

    let i = 2;
    while (i * i <= n) {
        if (n % i == 0) {
            return false;
        }
        i = i + 1;
    }

    return true;
}
```

### Example: Menu System

```hemlock
fn menu() {
    while (true) {
        print("1. Start");
        print("2. Settings");
        print("3. Exit");

        let choice = get_input();

        switch (choice) {
            case 1:
                start_game();
                break;
            case 2:
                show_settings();
                break;
            case 3:
                print("Goodbye!");
                return;
            default:
                print("Invalid choice");
                break;
        }
    }
}
```

## Related Topics

- [Functions](#language-guide-functions) - Control flow with function calls and returns
- [Error Handling](#language-guide-error-handling) - Control flow with exceptions
- [Types](#language-guide-types) - Type conversions in conditions

## See Also

- **Syntax**: See [Syntax](#language-guide-syntax) for statement syntax details
- **Operators**: See [Types](#language-guide-types) for type promotion in operations


--------------------------------------------------------------------------------
## Funzioni
--------------------------------------------------------------------------------

# Funzioni

Le funzioni in Hemlock sono **valori di prima classe** che possono essere assegnate a variabili, passate come argomenti e restituite da altre funzioni. Questa guida copre la sintassi delle funzioni, le closure, la ricorsione e i pattern avanzati.

## Panoramica

```hemlock
// Sintassi funzione con nome
fn add(a: i32, b: i32): i32 {
    return a + b;
}

// Funzione anonima
let multiply = fn(x, y) {
    return x * y;
};

// Closure
fn makeAdder(x) {
    return fn(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
print(add5(3));  // 8
```

## Dichiarazione di funzione

### Funzioni con nome

```hemlock
fn greet(name: string): string {
    return "Ciao, " + name;
}

let msg = greet("Alice");  // "Ciao, Alice"
```

**Componenti:**
- `fn` - Parola chiave funzione
- `greet` - Nome della funzione
- `(name: string)` - Parametri con tipi opzionali
- `: string` - Tipo di ritorno opzionale
- `{ ... }` - Corpo della funzione

### Funzioni anonime

Funzioni senza nome, assegnate a variabili:

```hemlock
let square = fn(x) {
    return x * x;
};

print(square(5));  // 25
```

**Con nome vs. Anonima:**
```hemlock
// Queste due sono equivalenti:
fn add(a, b) { return a + b; }

let add = fn(a, b) { return a + b; };
```

**Nota:** Le funzioni con nome si trasformano in assegnazioni di variabili con funzioni anonime.

## Parametri

### Parametri di base

```hemlock
fn example(a, b, c) {
    return a + b + c;
}

let result = example(1, 2, 3);  // 6
```

### Annotazioni di tipo

Annotazioni di tipo opzionali sui parametri:

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 10);      // OK
add(5, 10.5);    // La verifica dei tipi a runtime promuove a f64
```

**Verifica dei tipi:**
- I tipi dei parametri vengono verificati alla chiamata se annotati
- Le conversioni di tipo implicite seguono le regole di promozione standard
- Le incompatibilita di tipo causano errori a runtime

### Passaggio per valore

Tutti gli argomenti vengono **copiati** (passaggio per valore):

```hemlock
fn modify(x) {
    x = 100;  // Modifica solo la copia locale
}

let a = 10;
modify(a);
print(a);  // Ancora 10 (invariato)
```

**Nota:** Gli oggetti e gli array vengono passati per riferimento (il riferimento viene copiato), quindi il loro contenuto puo essere modificato:

```hemlock
fn modify_array(arr) {
    arr[0] = 99;  // Modifica l'array originale
}

let a = [1, 2, 3];
modify_array(a);
print(a[0]);  // 99 (modificato)
```

## Valori di ritorno

### Istruzione return

```hemlock
fn get_max(a: i32, b: i32): i32 {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}
```

### Annotazioni del tipo di ritorno

Annotazione di tipo opzionale per il valore di ritorno:

```hemlock
fn calculate(): f64 {
    return 3.14159;
}

fn get_name(): string {
    return "Alice";
}
```

**Verifica dei tipi:**
- I tipi di ritorno vengono verificati quando la funzione ritorna (se annotati)
- Le conversioni di tipo seguono le regole di promozione standard

### Ritorno implicito

Le funzioni senza annotazione del tipo di ritorno restituiscono implicitamente `null`:

```hemlock
fn print_message(msg) {
    print(msg);
    // Restituisce implicitamente null
}

let result = print_message("ciao");  // result e null
```

### Ritorno anticipato

```hemlock
fn find_first_negative(arr) {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // Uscita anticipata
        }
    }
    return -1;  // Non trovato
}
```

### Ritorno senza valore

`return;` senza valore restituisce `null`:

```hemlock
fn maybe_process(value) {
    if (value < 0) {
        return;  // Restituisce null
    }
    return value * 2;
}
```

## Funzioni di prima classe

Le funzioni possono essere assegnate, passate e restituite come qualsiasi altro valore.

### Funzioni come variabili

```hemlock
let operation = fn(x, y) { return x + y; };

print(operation(5, 3));  // 8

// Riassegnare
operation = fn(x, y) { return x * y; };
print(operation(5, 3));  // 15
```

### Funzioni come argomenti

```hemlock
fn apply(f, x) {
    return f(x);
}

fn double(n) {
    return n * 2;
}

let result = apply(double, 5);  // 10
```

### Funzioni come valori di ritorno

```hemlock
fn get_operation(op: string) {
    if (op == "add") {
        return fn(a, b) { return a + b; };
    } else if (op == "multiply") {
        return fn(a, b) { return a * b; };
    } else {
        return fn(a, b) { return 0; };
    }
}

let add = get_operation("add");
print(add(5, 3));  // 8
```

## Closure

Le funzioni catturano il loro ambiente di definizione (scope lessicale).

### Closure di base

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
print(counter());  // 3
```

**Come funziona:**
- La funzione interna cattura `count` dallo scope esterno
- `count` persiste attraverso le chiamate alla funzione restituita
- Ogni chiamata a `makeCounter()` crea una nuova closure con il proprio `count`

### Closure con parametri

```hemlock
fn makeAdder(x) {
    return fn(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
let add10 = makeAdder(10);

print(add5(3));   // 8
print(add10(3));  // 13
```

### Closure multiple

```hemlock
fn makeOperations(x) {
    let add = fn(y) { return x + y; };
    let multiply = fn(y) { return x * y; };

    return { add: add, multiply: multiply };
}

let ops = makeOperations(5);
print(ops.add(3));       // 8
print(ops.multiply(3));  // 15
```

### Scope lessicale

Le funzioni possono accedere alle variabili dello scope esterno tramite lo scope lessicale:

```hemlock
let global = 10;

fn outer() {
    let outer_var = 20;

    fn inner() {
        // Puo leggere global e outer_var
        print(global);      // 10
        print(outer_var);   // 20
    }

    inner();
}

outer();
```

Le closure catturano le variabili per riferimento, permettendo la lettura e la modifica delle variabili dello scope esterno (come mostrato nell'esempio `makeCounter` sopra).

## Ricorsione

Le funzioni possono chiamare se stesse.

### Ricorsione di base

```hemlock
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

print(factorial(5));  // 120
```

### Ricorsione mutua

Le funzioni possono chiamarsi a vicenda:

```hemlock
fn is_even(n: i32): bool {
    if (n == 0) {
        return true;
    }
    return is_odd(n - 1);
}

fn is_odd(n: i32): bool {
    if (n == 0) {
        return false;
    }
    return is_even(n - 1);
}

print(is_even(4));  // true
print(is_odd(4));   // false
```

### Elaborazione dati ricorsiva

```hemlock
fn sum_array(arr: array, index: i32): i32 {
    if (index >= arr.length) {
        return 0;
    }
    return arr[index] + sum_array(arr, index + 1);
}

let numbers = [1, 2, 3, 4, 5];
print(sum_array(numbers, 0));  // 15
```

**Nota:** Nessuna ottimizzazione della ricorsione in coda ancora - la ricorsione profonda puo causare overflow dello stack.

## Funzioni di ordine superiore

Funzioni che prendono o restituiscono altre funzioni.

### Pattern Map

```hemlock
fn map(arr, f) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        result.push(f(arr[i]));
        i = i + 1;
    }
    return result;
}

fn double(x) { return x * 2; }

let numbers = [1, 2, 3, 4, 5];
let doubled = map(numbers, double);  // [2, 4, 6, 8, 10]
```

### Pattern Filter

```hemlock
fn filter(arr, predicate) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        if (predicate(arr[i])) {
            result.push(arr[i]);
        }
        i = i + 1;
    }
    return result;
}

fn is_even(x) { return x % 2 == 0; }

let numbers = [1, 2, 3, 4, 5, 6];
let evens = filter(numbers, is_even);  // [2, 4, 6]
```

### Pattern Reduce

```hemlock
fn reduce(arr, f, initial) {
    let accumulator = initial;
    let i = 0;
    while (i < arr.length) {
        accumulator = f(accumulator, arr[i]);
        i = i + 1;
    }
    return accumulator;
}

fn add(a, b) { return a + b; }

let numbers = [1, 2, 3, 4, 5];
let sum = reduce(numbers, add, 0);  // 15
```

### Composizione di funzioni

```hemlock
fn compose(f, g) {
    return fn(x) {
        return f(g(x));
    };
}

fn double(x) { return x * 2; }
fn increment(x) { return x + 1; }

let double_then_increment = compose(increment, double);
print(double_then_increment(5));  // 11 (5*2 + 1)
```

## Pattern comuni

### Pattern: Funzioni factory

```hemlock
fn createPerson(name: string, age: i32) {
    return {
        name: name,
        age: age,
        greet: fn() {
            return "Ciao, sono " + self.name;
        }
    };
}

let person = createPerson("Alice", 30);
print(person.greet());  // "Ciao, sono Alice"
```

### Pattern: Funzioni callback

```hemlock
fn process_async(data, callback) {
    // ... fare l'elaborazione
    callback(data);
}

process_async("test", fn(result) {
    print("Elaborazione completata: " + result);
});
```

### Pattern: Applicazione parziale

```hemlock
fn partial(f, x) {
    return fn(y) {
        return f(x, y);
    };
}

fn multiply(a, b) {
    return a * b;
}

let double = partial(multiply, 2);
let triple = partial(multiply, 3);

print(double(5));  // 10
print(triple(5));  // 15
```

### Pattern: Memoizzazione

```hemlock
fn memoize(f) {
    let cache = {};

    return fn(x) {
        if (cache.has(x)) {
            return cache[x];
        }

        let result = f(x);
        cache[x] = result;
        return result;
    };
}

fn expensive_fibonacci(n) {
    if (n <= 1) { return n; }
    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);
}

let fast_fib = memoize(expensive_fibonacci);
print(fast_fib(10));  // Molto piu veloce con la cache
```

## Semantica delle funzioni

### Requisiti del tipo di ritorno

Le funzioni con annotazione del tipo di ritorno **devono** restituire un valore:

```hemlock
fn get_value(): i32 {
    // ERRORE: Istruzione return mancante
}

fn get_value(): i32 {
    return 42;  // OK
}
```

### Verifica dei tipi

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 10);        // OK
add(5.5, 10.5);    // Promuove a f64, restituisce f64
add("a", "b");     // Errore runtime: tipo non corrispondente
```

### Regole di scope

```hemlock
let global = "global";

fn outer() {
    let outer_var = "outer";

    fn inner() {
        let inner_var = "inner";
        // Puo accedere: inner_var, outer_var, global
    }

    // Puo accedere: outer_var, global
    // Non puo accedere: inner_var
}

// Puo accedere: global
// Non puo accedere: outer_var, inner_var
```

## Buone pratiche

1. **Usa annotazioni di tipo** - Aiuta a catturare errori e documenta l'intenzione
2. **Mantieni le funzioni piccole** - Ogni funzione dovrebbe fare una sola cosa
3. **Preferisci le funzioni pure** - Evita gli effetti collaterali quando possibile
4. **Nomina le funzioni chiaramente** - Usa nomi di verbi descrittivi
5. **Ritorna presto** - Usa clausole di guardia per ridurre l'annidamento
6. **Documenta le closure complesse** - Rendi esplicite le variabili catturate
7. **Evita la ricorsione profonda** - Nessuna ottimizzazione della ricorsione in coda ancora

## Trabocchetti comuni

### Trabocchetto: Profondita della ricorsione

```hemlock
// La ricorsione profonda puo causare overflow dello stack
fn count_down(n) {
    if (n == 0) { return; }
    count_down(n - 1);
}

count_down(100000);  // Potrebbe crashare con overflow dello stack
```

### Trabocchetto: Modifica delle variabili catturate

```hemlock
fn make_counter() {
    let count = 0;
    return fn() {
        count = count + 1;  // Puo leggere e modificare le variabili catturate
        return count;
    };
}
```

**Nota:** Questo funziona, ma sii consapevole che tutte le closure condividono lo stesso ambiente catturato.

## Esempi

### Esempio: Pipeline di funzioni

```hemlock
fn pipeline(value, ...functions) {
    let result = value;
    for (f in functions) {
        result = f(result);
    }
    return result;
}

fn double(x) { return x * 2; }
fn increment(x) { return x + 1; }
fn square(x) { return x * x; }

let result = pipeline(3, double, increment, square);
print(result);  // 49 ((3*2+1)^2)
```

### Esempio: Gestore di eventi

```hemlock
let handlers = [];

fn on_event(name: string, handler) {
    handlers.push({ name: name, handler: handler });
}

fn trigger_event(name: string, data) {
    let i = 0;
    while (i < handlers.length) {
        if (handlers[i].name == name) {
            handlers[i].handler(data);
        }
        i = i + 1;
    }
}

on_event("click", fn(data) {
    print("Clic: " + data);
});

trigger_event("click", "button1");
```

### Esempio: Ordinamento con comparatore personalizzato

```hemlock
fn sort(arr, compare) {
    // Bubble sort con comparatore personalizzato
    let n = arr.length;
    let i = 0;
    while (i < n) {
        let j = 0;
        while (j < n - i - 1) {
            if (compare(arr[j], arr[j + 1]) > 0) {
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

fn ascending(a, b) {
    if (a < b) { return -1; }
    if (a > b) { return 1; }
    return 0;
}

let numbers = [5, 2, 8, 1, 9];
sort(numbers, ascending);
print(numbers);  // [1, 2, 5, 8, 9]
```

## Parametri opzionali (argomenti predefiniti)

Le funzioni possono avere parametri opzionali con valori predefiniti usando la sintassi `?:`:

```hemlock
fn greet(name, greeting?: "Ciao") {
    return greeting + " " + name;
}

print(greet("Alice"));           // "Ciao Alice"
print(greet("Bob", "Salve"));    // "Salve Bob"

fn add(a, b?: 10, c?: 100) {
    return a + b + c;
}

print(add(1));          // 111 (1 + 10 + 100)
print(add(1, 2));       // 103 (1 + 2 + 100)
print(add(1, 2, 3));    // 6   (1 + 2 + 3)
```

**Regole:**
- I parametri opzionali devono venire dopo i parametri richiesti
- I valori predefiniti possono essere qualsiasi espressione
- Gli argomenti omessi usano il valore predefinito

## Funzioni variadiche (parametri rest)

Le funzioni possono accettare un numero variabile di argomenti usando i parametri rest (`...`):

```hemlock
fn sum(...args) {
    let total = 0;
    for (arg in args) {
        total = total + arg;
    }
    return total;
}

print(sum(1, 2, 3));        // 6
print(sum(1, 2, 3, 4, 5));  // 15
print(sum());               // 0

fn log(prefix, ...messages) {
    for (msg in messages) {
        print(prefix + ": " + msg);
    }
}

log("INFO", "Avvio", "Esecuzione", "Terminato");
// INFO: Avvio
// INFO: Esecuzione
// INFO: Terminato
```

**Regole:**
- Il parametro rest deve essere l'ultimo parametro
- Il parametro rest raccoglie tutti gli argomenti rimanenti in un array
- Puo essere combinato con parametri regolari e opzionali

## Annotazioni di tipo funzione

I tipi funzione permettono di specificare la firma esatta attesa per i parametri di funzione e i valori di ritorno:

### Tipi funzione di base

```hemlock
// Sintassi tipo funzione: fn(param_types): return_type
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

let double = fn(n) { return n * 2; };
let result = apply(double, 5);  // 10
```

### Tipi funzione di ordine superiore

```hemlock
// Funzione che restituisce una funzione
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

let add5 = make_adder(5);
print(add5(10));  // 15
```

### Tipi funzione asincrona

```hemlock
// Tipo funzione asincrona
fn run_task(handler: async fn(): void) {
    spawn(handler);
}

run_task(async fn() {
    print("Esecuzione asincrona!");
});
```

### Alias di tipo funzione

```hemlock
// Crea tipi funzione con nome per chiarezza
type Callback = fn(i32): void;
type Predicate = fn(any): bool;
type BinaryOp = fn(i32, i32): i32;

fn filter_with(arr: array, pred: Predicate): array {
    return arr.filter(pred);
}
```

## Parametri const

Il modificatore `const` impedisce che un parametro venga modificato nella funzione:

### Parametri const di base

```hemlock
fn print_all(const items: array) {
    // items.push(4);  // ERRORE: impossibile modificare parametro const
    for (item in items) {
        print(item);   // OK: la lettura e consentita
    }
}

let nums = [1, 2, 3];
print_all(nums);
```

### Immutabilita profonda

I parametri const impongono immutabilita profonda - nessuna modifica attraverso alcun percorso:

```hemlock
fn describe(const person: object) {
    print(person.name);       // OK: la lettura e consentita
    // person.name = "Bob";   // ERRORE: impossibile modificare
    // person.address.city = "Roma";  // ERRORE: const profondo
}
```

### Cosa impedisce const

| Tipo | Bloccato da const | Consentito |
|------|-------------------|------------|
| array | push, pop, shift, unshift, insert, remove, clear, reverse | slice, concat, map, filter, find, contains |
| object | assegnazione campo | lettura campo |
| buffer | assegnazione indice | lettura indice |
| string | assegnazione indice | tutti i metodi (restituiscono nuove stringhe) |

## Argomenti con nome

Le funzioni possono essere chiamate con argomenti con nome per maggiore chiarezza e flessibilita:

### Argomenti con nome di base

```hemlock
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " ha " + age + " anni");
}

// Argomenti posizionali (tradizionale)
create_user("Alice", 25, false);

// Argomenti con nome - possono essere in qualsiasi ordine
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);
```

### Mescolare posizionale e con nome

```hemlock
// Salta i parametri opzionali nominando cio di cui hai bisogno
create_user("David", active: false);  // Usa age predefinito=18

// Gli argomenti con nome devono venire dopo i posizionali
create_user("Eve", age: 21);          // OK
// create_user(name: "Bad", 25);      // ERRORE: posizionale dopo nominato
```

### Regole per gli argomenti con nome

- Usa la sintassi `nome: valore` per gli argomenti con nome
- Gli argomenti con nome possono apparire in qualsiasi ordine dopo gli argomenti posizionali
- Gli argomenti posizionali non possono seguire gli argomenti con nome
- Funziona con i parametri predefiniti/opzionali
- I nomi di parametro sconosciuti causano errori a runtime

## Limitazioni

Limitazioni attuali da conoscere:

- **Nessun passaggio per riferimento** - Parola chiave `ref` analizzata ma non implementata
- **Nessun overloading di funzione** - Una funzione per nome
- **Nessuna ottimizzazione della ricorsione in coda** - Ricorsione profonda limitata dalla dimensione dello stack

## Argomenti correlati

- [Flusso di controllo](#language-guide-control-flow) - Uso delle funzioni con le strutture di controllo
- [Oggetti](#language-guide-objects) - I metodi sono funzioni memorizzate negli oggetti
- [Gestione degli errori](#language-guide-error-handling) - Funzioni e gestione delle eccezioni
- [Tipi](#language-guide-types) - Annotazioni di tipo e conversioni

## Vedi anche

- **Closure**: Vedi la sezione "Functions" di CLAUDE.md per la semantica delle closure
- **Valori di prima classe**: Le funzioni sono valori come qualsiasi altro
- **Scope lessicale**: Le funzioni catturano il loro ambiente di definizione


--------------------------------------------------------------------------------
## Gestione degli Errori
--------------------------------------------------------------------------------

# Error Handling

Hemlock supports exception-based error handling with `try`, `catch`, `finally`, `throw`, and `panic`. This guide covers recoverable errors with exceptions and unrecoverable errors with panic.

## Overview

```hemlock
// Basic error handling
try {
    risky_operation();
} catch (e) {
    print("Error: " + e);
}

// With cleanup
try {
    process_file();
} catch (e) {
    print("Failed: " + e);
} finally {
    cleanup();
}

// Throwing errors
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}
```

## Try-Catch-Finally

### Syntax

**Basic try/catch:**
```hemlock
try {
    // risky code
} catch (e) {
    // handle error, e contains the thrown value
}
```

**Try/finally:**
```hemlock
try {
    // risky code
} finally {
    // always executes, even if exception thrown
}
```

**Try/catch/finally:**
```hemlock
try {
    // risky code
} catch (e) {
    // handle error
} finally {
    // cleanup code
}
```

### Try Block

The try block executes statements sequentially:

```hemlock
try {
    print("Starting...");
    risky_operation();
    print("Success!");  // Only if no exception
}
```

**Behavior:**
- Executes statements in order
- If exception thrown: jumps to `catch` or `finally`
- If no exception: executes `finally` (if present) then continues

### Catch Block

The catch block receives the thrown value:

```hemlock
try {
    throw "oops";
} catch (error) {
    print("Caught: " + error);  // error = "oops"
    // error only accessible here
}
// error not accessible here
```

**Catch parameter:**
- Receives the thrown value (any type)
- Scoped to the catch block
- Can be named anything (conventionally `e`, `err`, or `error`)

**What you can do in catch:**
```hemlock
try {
    risky_operation();
} catch (e) {
    // Log the error
    print("Error: " + e);

    // Re-throw same error
    throw e;

    // Throw different error
    throw "different error";

    // Return a default value
    return null;

    // Handle and continue
    // (no re-throw)
}
```

### Finally Block

The finally block **always executes**:

```hemlock
try {
    print("1: try");
    throw "error";
} catch (e) {
    print("2: catch");
} finally {
    print("3: finally");  // Always runs
}
print("4: after");

// Output: 1: try, 2: catch, 3: finally, 4: after
```

**When finally runs:**
- After try block (if no exception)
- After catch block (if exception caught)
- Even if try/catch contains `return`, `break`, or `continue`
- Before control flow exits the try/catch

**Finally with return:**
```hemlock
fn example() {
    try {
        return 1;  // âœ… Returns 1 after finally runs
    } finally {
        print("cleanup");  // Runs before returning
    }
}

fn example2() {
    try {
        return 1;
    } finally {
        return 2;  // âš ï¸ Finally return overrides - returns 2
    }
}
```

**Finally with control flow:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    try {
        if (i == 5) {
            break;  // âœ… Breaks after finally runs
        }
    } finally {
        print("cleanup " + typeof(i));
    }
}
```

## Throw Statement

### Basic Throw

Throw any value as an exception:

```hemlock
throw "error message";
throw 404;
throw { code: 500, message: "Internal error" };
throw null;
throw ["error", "details"];
```

**Execution:**
1. Evaluates the expression
2. Immediately jumps to nearest enclosing `catch`
3. If no `catch`, propagates up the call stack

### Throwing Errors

```hemlock
fn validate_age(age: i32) {
    if (age < 0) {
        throw "Age cannot be negative";
    }
    if (age > 150) {
        throw "Age is unrealistic";
    }
}

try {
    validate_age(-5);
} catch (e) {
    print("Validation error: " + e);
}
```

### Throwing Error Objects

Create structured error information:

```hemlock
fn read_file(path: string) {
    if (!file_exists(path)) {
        throw {
            type: "FileNotFound",
            path: path,
            message: "File does not exist"
        };
    }
    // ... read file
}

try {
    read_file("missing.txt");
} catch (e) {
    if (e.type == "FileNotFound") {
        print("File not found: " + e.path);
    }
}
```

### Re-throwing

Catch and re-throw errors:

```hemlock
fn wrapper() {
    try {
        risky_operation();
    } catch (e) {
        print("Logging error: " + e);
        throw e;  // Re-throw to caller
    }
}

try {
    wrapper();
} catch (e) {
    print("Caught in main: " + e);
}
```

## Uncaught Exceptions

If an exception propagates to the top of the call stack without being caught:

```hemlock
fn foo() {
    throw "uncaught!";
}

foo();  // Crashes with: Runtime error: uncaught!
```

**Behavior:**
- Program crashes
- Prints error message to stderr
- Exits with non-zero status code
- Stack trace to be added in future versions

## Panic - Unrecoverable Errors

### What is Panic?

`panic()` is for **unrecoverable errors** that should immediately terminate the program:

```hemlock
panic();                    // Default message: "panic!"
panic("custom message");    // Custom message
panic(42);                  // Non-string values are printed
```

**Semantics:**
- **Immediately exits** the program with exit code 1
- Prints error message to stderr: `panic: <message>`
- **NOT catchable** with try/catch
- Use for bugs and unrecoverable errors

### Panic vs Throw

```hemlock
// throw - Recoverable error (can be caught)
try {
    throw "recoverable error";
} catch (e) {
    print("Caught: " + e);  // âœ… Caught successfully
}

// panic - Unrecoverable error (cannot be caught)
try {
    panic("unrecoverable error");  // âŒ Program exits immediately
} catch (e) {
    print("This never runs");       // âŒ Never executes
}
```

### When to Use Panic

**Use panic for:**
- **Bugs**: Unreachable code was reached
- **Invalid state**: Data structure corruption detected
- **Unrecoverable errors**: Critical resource unavailable
- **Assertion failures**: When `assert()` isn't sufficient

**Examples:**
```hemlock
// Unreachable code
fn process_state(state: i32) {
    if (state == 1) {
        return "ready";
    } else if (state == 2) {
        return "running";
    } else if (state == 3) {
        return "stopped";
    } else {
        panic("invalid state: " + typeof(state));  // Should never happen
    }
}

// Critical resource check
fn init_system() {
    let config = read_file("config.json");
    if (config == null) {
        panic("config.json not found - cannot start");
    }
    // ...
}

// Data structure invariant
fn pop_stack(stack) {
    if (stack.length == 0) {
        panic("pop() called on empty stack");
    }
    return stack.pop();
}
```

### When NOT to Use Panic

**Use throw instead for:**
- User input validation
- File not found
- Network errors
- Expected error conditions

```hemlock
// BAD: Panic for expected errors
fn divide(a, b) {
    if (b == 0) {
        panic("division by zero");  // âŒ Too harsh
    }
    return a / b;
}

// GOOD: Throw for expected errors
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";  // âœ… Recoverable
    }
    return a / b;
}
```

## Control Flow Interactions

### Return Inside Try/Catch/Finally

```hemlock
fn example() {
    try {
        return 1;  // âœ… Returns 1 after finally runs
    } finally {
        print("cleanup");
    }
}

fn example2() {
    try {
        return 1;
    } finally {
        return 2;  // âš ï¸ Finally return overrides try return - returns 2
    }
}
```

**Rule:** Finally block return values override try/catch return values.

### Break/Continue Inside Try/Catch/Finally

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    try {
        if (i == 5) { break; }  // âœ… Breaks after finally runs
    } finally {
        print("cleanup " + typeof(i));
    }
}
```

**Rule:** Break/continue execute after finally block.

### Nested Try/Catch

```hemlock
try {
    try {
        throw "inner";
    } catch (e) {
        print("Caught: " + e);  // Prints: Caught: inner
        throw "outer";  // Re-throw different error
    }
} catch (e) {
    print("Caught: " + e);  // Prints: Caught: outer
}
```

**Rule:** Nested try/catch blocks work as expected, inner catches happen first.

## Common Patterns

### Pattern: Resource Cleanup

Always use `finally` for cleanup:

```hemlock
fn process_file(filename) {
    let file = null;
    try {
        file = open(filename);
        let content = file.read();
        process(content);
    } catch (e) {
        print("Error processing file: " + e);
    } finally {
        if (file != null) {
            file.close();  // Always closes, even on error
        }
    }
}
```

### Pattern: Error Wrapping

Wrap lower-level errors with context:

```hemlock
fn load_config(path) {
    try {
        let content = read_file(path);
        return parse_json(content);
    } catch (e) {
        throw "Failed to load config from " + path + ": " + e;
    }
}
```

### Pattern: Error Recovery

Provide fallback on error:

```hemlock
fn safe_divide(a, b) {
    try {
        if (b == 0) {
            throw "division by zero";
        }
        return a / b;
    } catch (e) {
        print("Error: " + e);
        return null;  // Fallback value
    }
}
```

### Pattern: Validation

Use exceptions for validation:

```hemlock
fn validate_user(user) {
    if (user.name == null || user.name == "") {
        throw "Name is required";
    }
    if (user.age < 0 || user.age > 150) {
        throw "Invalid age";
    }
    if (user.email == null || !user.email.contains("@")) {
        throw "Invalid email";
    }
}

try {
    validate_user({ name: "Alice", age: -5, email: "invalid" });
} catch (e) {
    print("Validation failed: " + e);
}
```

### Pattern: Multiple Error Types

Use error objects to distinguish error types:

```hemlock
fn process_data(data) {
    if (data == null) {
        throw { type: "NullData", message: "Data is null" };
    }

    if (typeof(data) != "array") {
        throw { type: "TypeError", message: "Expected array" };
    }

    if (data.length == 0) {
        throw { type: "EmptyData", message: "Array is empty" };
    }

    // ... process
}

try {
    process_data(null);
} catch (e) {
    if (e.type == "NullData") {
        print("No data provided");
    } else if (e.type == "TypeError") {
        print("Wrong data type: " + e.message);
    } else {
        print("Error: " + e.message);
    }
}
```

## Best Practices

1. **Use exceptions for exceptional cases** - Not for normal control flow
2. **Throw meaningful errors** - Use strings or objects with context
3. **Always use finally for cleanup** - Ensures resources are freed
4. **Don't catch and ignore** - At least log the error
5. **Re-throw when appropriate** - Let caller handle if you can't
6. **Panic for bugs** - Use panic for unrecoverable errors
7. **Document exceptions** - Make clear what functions can throw

## Common Pitfalls

### Pitfall: Swallowing Errors

```hemlock
// BAD: Silent failure
try {
    risky_operation();
} catch (e) {
    // Error ignored - silent failure
}

// GOOD: Log or handle
try {
    risky_operation();
} catch (e) {
    print("Operation failed: " + e);
    // Handle appropriately
}
```

### Pitfall: Finally Override

```hemlock
// BAD: Finally overrides return
fn get_value() {
    try {
        return 42;
    } finally {
        return 0;  // âš ï¸ Returns 0, not 42!
    }
}

// GOOD: Don't return in finally
fn get_value() {
    try {
        return 42;
    } finally {
        cleanup();  // Just cleanup, no return
    }
}
```

### Pitfall: Forgetting Cleanup

```hemlock
// BAD: File may not be closed on error
fn process() {
    let file = open("data.txt");
    let content = file.read();  // May throw
    file.close();  // Never reached if error
}

// GOOD: Use finally
fn process() {
    let file = null;
    try {
        file = open("data.txt");
        let content = file.read();
    } finally {
        if (file != null) {
            file.close();
        }
    }
}
```

### Pitfall: Using Panic for Expected Errors

```hemlock
// BAD: Panic for expected error
fn read_config(path) {
    if (!file_exists(path)) {
        panic("Config file not found");  // âŒ Too harsh
    }
    return read_file(path);
}

// GOOD: Throw for expected error
fn read_config(path) {
    if (!file_exists(path)) {
        throw "Config file not found: " + path;  // âœ… Recoverable
    }
    return read_file(path);
}
```

## Examples

### Example: Basic Error Handling

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}

try {
    print(divide(10, 0));
} catch (e) {
    print("Error: " + e);  // Prints: Error: division by zero
}
```

### Example: Resource Management

```hemlock
fn copy_file(src, dst) {
    let src_file = null;
    let dst_file = null;

    try {
        src_file = open(src, "r");
        dst_file = open(dst, "w");

        let content = src_file.read();
        dst_file.write(content);

        print("File copied successfully");
    } catch (e) {
        print("Failed to copy file: " + e);
        throw e;  // Re-throw
    } finally {
        if (src_file != null) { src_file.close(); }
        if (dst_file != null) { dst_file.close(); }
    }
}
```

### Example: Nested Error Handling

```hemlock
fn process_users(users) {
    let success_count = 0;
    let error_count = 0;

    let i = 0;
    while (i < users.length) {
        try {
            validate_user(users[i]);
            save_user(users[i]);
            success_count = success_count + 1;
        } catch (e) {
            print("Failed to process user: " + e);
            error_count = error_count + 1;
        }
        i = i + 1;
    }

    print("Processed: " + typeof(success_count) + " success, " + typeof(error_count) + " errors");
}
```

### Example: Custom Error Types

```hemlock
fn create_error(type, message, details) {
    return {
        type: type,
        message: message,
        details: details,
        toString: fn() {
            return self.type + ": " + self.message;
        }
    };
}

fn divide(a, b) {
    if (typeof(a) != "i32" && typeof(a) != "f64") {
        throw create_error("TypeError", "a must be a number", { value: a });
    }
    if (typeof(b) != "i32" && typeof(b) != "f64") {
        throw create_error("TypeError", "b must be a number", { value: b });
    }
    if (b == 0) {
        throw create_error("DivisionByZero", "Cannot divide by zero", { a: a, b: b });
    }
    return a / b;
}

try {
    divide(10, 0);
} catch (e) {
    print(e.toString());
    if (e.type == "DivisionByZero") {
        print("Details: a=" + typeof(e.details.a) + ", b=" + typeof(e.details.b));
    }
}
```

### Example: Retry Logic

```hemlock
fn retry(operation, max_attempts) {
    let attempt = 0;

    while (attempt < max_attempts) {
        try {
            return operation();  // Success!
        } catch (e) {
            attempt = attempt + 1;
            if (attempt >= max_attempts) {
                throw "Operation failed after " + typeof(max_attempts) + " attempts: " + e;
            }
            print("Attempt " + typeof(attempt) + " failed, retrying...");
        }
    }
}

fn unreliable_operation() {
    // Simulated unreliable operation
    if (random() < 0.7) {
        throw "Operation failed";
    }
    return "Success";
}

try {
    let result = retry(unreliable_operation, 3);
    print(result);
} catch (e) {
    print("All retries failed: " + e);
}
```

## Execution Order

Understanding the execution order:

```hemlock
try {
    print("1: try block start");
    throw "error";
    print("2: never reached");
} catch (e) {
    print("3: catch block");
} finally {
    print("4: finally block");
}
print("5: after try/catch/finally");

// Output:
// 1: try block start
// 3: catch block
// 4: finally block
// 5: after try/catch/finally
```

## Current Limitations

- **No stack trace** - Uncaught exceptions don't show stack trace (planned)
- **Some built-ins exit** - Some built-in functions still `exit()` instead of throwing (to be reviewed)
- **No custom exception types** - Any value can be thrown, but no formal exception hierarchy

## Related Topics

- [Functions](#language-guide-functions) - Exceptions and function returns
- [Control Flow](#language-guide-control-flow) - How exceptions affect control flow
- [Memory](#language-guide-memory) - Using finally for memory cleanup

## See Also

- **Exception Semantics**: See CLAUDE.md section "Error Handling"
- **Panic vs Throw**: Different use cases for different error types
- **Finally Guarantee**: Always executes, even with return/break/continue


--------------------------------------------------------------------------------
## Gestione della Memoria
--------------------------------------------------------------------------------

# Memory Management

Hemlock embraces **manual memory management** with explicit control over allocation and deallocation. This guide covers Hemlock's memory model, the two pointer types, and the complete memory API.

---

## Memory 101: The Basics

**New to programming?** Start here. If you already understand memory management, skip to [Philosophy](#philosophy).

### What is Memory Management?

When your program needs to store data (text, numbers, lists), it needs space to put it. That space comes from your computer's memory (RAM). Memory management is about:

1. **Getting space** - asking for memory when you need it
2. **Using space** - reading and writing your data
3. **Giving it back** - returning memory when you're done

### Why Does It Matter?

Imagine a library with limited books:
- If you keep checking out books and never return them, eventually there are none left
- If you try to read a book you already returned, you'll get confused or cause problems

Memory works the same way. If you forget to return memory, your program slowly uses more and more (a "memory leak"). If you try to use memory after returning it, bad things happen.

### The Good News

**Most of the time, you don't need to think about this!**

Hemlock automatically cleans up most common types:

```hemlock
fn example() {
    let name = "Alice";       // Hemlock manages this
    let numbers = [1, 2, 3];  // And this
    let person = { age: 30 }; // And this too

    // When the function ends, all of this is cleaned up automatically!
}
```

### When You DO Need to Think About It

You only need manual memory management when using:

1. **`alloc()`** - raw memory allocation (returns `ptr`)
2. **`buffer()`** - when you want to free early (optional - it auto-frees at scope end)

```hemlock
// This needs manual cleanup:
let raw = alloc(100);   // Raw memory - YOU must free it
// ... use raw ...
free(raw);              // Required! Or you have a memory leak

// This cleans up automatically (but you CAN free early):
let buf = buffer(100);  // Safe buffer
// ... use buf ...
// free(buf);           // Optional - will auto-free when scope ends
```

### The Simple Rule

> **If you call `alloc()`, you must call `free()`.**
>
> Everything else is handled for you.

### Which Should You Use?

| Situation | Use This | Why |
|-----------|----------|-----|
| **Just starting out** | `buffer()` | Safe, bounds-checked, auto-cleanup |
| **Need byte storage** | `buffer()` | Safe and easy |
| **Working with C libraries (FFI)** | `alloc()` / `ptr` | Required for C interop |
| **Maximum performance** | `alloc()` / `ptr` | No bounds checking overhead |
| **Not sure** | `buffer()` | Always the safer choice |

### Quick Example: Safe vs Raw

```hemlock
// RECOMMENDED: Safe buffer
fn safe_example() {
    let data = buffer(10);
    data[0] = 65;           // OK
    data[5] = 66;           // OK
    // data[100] = 67;      // ERROR - Hemlock stops you (bounds check)
    free(data);             // Clean up
}

// ADVANCED: Raw pointer (only when you need it)
fn raw_example() {
    let data = alloc(10);
    *data = 65;             // OK
    *(data + 5) = 66;       // OK
    *(data + 100) = 67;     // DANGER - No bounds check, corrupts memory!
    free(data);             // Clean up
}
```

**Start with `buffer()`. Only use `alloc()` when you specifically need raw pointers.**

---

## Philosophy

Hemlock follows the principle of explicit memory management with sensible defaults:
- No garbage collection (no unpredictable pauses)
- Internal refcounting for common types (string, array, object, buffer)
- Raw pointers (`ptr`) require manual `free()`

This hybrid approach gives you complete control when needed (raw pointers) while preventing common bugs for typical use cases (refcounted types auto-freed on scope exit).

## Internal Reference Counting

The runtime uses **internal reference counting** to manage object lifetimes. For most local variables of refcounted types, cleanup is automatic and deterministic.

### What Reference Counting Handles

The runtime automatically manages reference counts when:

1. **Variables are reassigned** - the old value is released:
   ```hemlock
   let x = "first";   // ref_count = 1
   x = "second";      // "first" released internally, "second" ref_count = 1
   ```

2. **Scopes exit** - local variables are released:
   ```hemlock
   fn example() {
       let arr = [1, 2, 3];  // ref_count = 1
   }  // arr released when function returns
   ```

3. **Containers are freed** - elements are released:
   ```hemlock
   let arr = [obj1, obj2];
   free(arr);  // obj1 and obj2 get their ref_counts decremented
   ```

### When You Need `free()` vs When It's Automatic

**Automatic (no `free()` needed):** Local variables of refcounted types are freed when scope exits:

```hemlock
fn process_data() {
    let arr = [1, 2, 3];
    let obj = { name: "test" };
    let buf = buffer(64);
    // ... use them ...
}  // All automatically freed when function returns - no free() needed
```

**Manual `free()` required:**

1. **Raw pointers** - `alloc()` has no refcounting:
   ```hemlock
   let p = alloc(64);
   // ... use p ...
   free(p);  // Always required - will leak otherwise
   ```

2. **Early cleanup** - free before scope ends to release memory sooner:
   ```hemlock
   fn long_running() {
       let big = buffer(10000000);  // 10MB
       // ... done with big ...
       free(big);  // Free now, don't wait for function to return
       // ... more work that doesn't need big ...
   }
   ```

3. **Long-lived data** - globals or data stored in persistent structures:
   ```hemlock
   let cache = {};  // Module-level, lives until program exit unless freed

   fn cleanup() {
       free(cache);  // Manual cleanup for long-lived data
   }
   ```

### Refcounting vs Garbage Collection

| Aspect | Hemlock Refcounting | Garbage Collection |
|--------|---------------------|-------------------|
| Cleanup timing | Deterministic (immediate when ref hits 0) | Non-deterministic (GC decides when) |
| User responsibility | Must call `free()` | Fully automatic |
| Runtime pauses | None | "Stop the world" pauses |
| Visibility | Hidden implementation detail | Usually invisible |
| Cycles | Handled with visited-set tracking | Handled by tracing |

### Which Types Have Refcounting

| Type | Refcounted | Notes |
|------|------------|-------|
| `ptr` | âŒ No | Always requires manual `free()` |
| `buffer` | âœ… Yes | Auto-freed on scope exit; manual `free()` for early cleanup |
| `array` | âœ… Yes | Auto-freed on scope exit; manual `free()` for early cleanup |
| `object` | âœ… Yes | Auto-freed on scope exit; manual `free()` for early cleanup |
| `string` | âœ… Yes | Fully automatic, no `free()` needed |
| `function` | âœ… Yes | Fully automatic (closure environments) |
| `task` | âœ… Yes | Thread-safe atomic refcounting |
| `channel` | âœ… Yes | Thread-safe atomic refcounting |
| Primitives | âŒ No | Stack-allocated, no heap allocation |

### Why This Design?

This hybrid approach gives you:
- **Explicit control** - You decide when to deallocate
- **Safety from scope bugs** - Reassignment doesn't leak
- **Predictable performance** - No GC pauses
- **Closure support** - Functions can safely capture variables

The philosophy remains: you're in control, but the runtime helps prevent common bugs like leaking on reassignment or double-freeing in containers.

## The Two Pointer Types

Hemlock provides two distinct pointer types, each with different safety characteristics:

### `ptr` - Raw Pointer (Dangerous)

Raw pointers are **just addresses** with minimal safety guarantees:

```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // You must remember to free
```

**Characteristics:**
- Just an 8-byte address
- No bounds checking
- No length tracking
- User manages lifetime entirely
- For experts and FFI

**Use cases:**
- Low-level system programming
- Foreign Function Interface (FFI)
- Performance-critical code
- When you need complete control

**Dangers:**
```hemlock
let p = alloc(10);
let q = p + 100;  // Way past allocation - allowed but dangerous
free(p);
let x = *p;       // Dangling pointer - undefined behavior
free(p);          // Double-free - will crash
```

### `buffer` - Safe Wrapper (Recommended)

Buffers provide **bounds-checked access** while still requiring manual deallocation:

```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // bounds checked
print(b.length);        // 64
free(b);                // still manual
```

**Characteristics:**
- Pointer + length + capacity
- Bounds checked on access
- Still requires manual `free()`
- Better default for most code

**Properties:**
```hemlock
let buf = buffer(100);
print(buf.length);      // 100 (current size)
print(buf.capacity);    // 100 (allocated capacity)
```

**Bounds checking:**
```hemlock
let buf = buffer(10);
buf[5] = 42;      // OK
buf[100] = 42;    // ERROR: Index out of bounds
```

## Memory API

### Core Allocation

**`alloc(bytes)` - Allocate raw memory**
```hemlock
let p = alloc(1024);  // Allocate 1KB, returns ptr
// ... use memory
free(p);
```

**`buffer(size)` - Allocate safe buffer**
```hemlock
let buf = buffer(256);  // Allocate 256-byte buffer
buf[0] = 65;            // 'A'
buf[1] = 66;            // 'B'
free(buf);
```

**`free(ptr)` - Free memory**
```hemlock
let p = alloc(100);
free(p);  // Must free to avoid memory leak

let buf = buffer(100);
free(buf);  // Works on both ptr and buffer
```

**Important:** `free()` works on both `ptr` and `buffer` types.

### Memory Operations

**`memset(ptr, byte, size)` - Fill memory**
```hemlock
let p = alloc(100);
memset(p, 0, 100);     // Zero out 100 bytes
memset(p, 65, 10);     // Fill first 10 bytes with 'A'
free(p);
```

**`memcpy(dest, src, size)` - Copy memory**
```hemlock
let src = alloc(50);
let dst = alloc(50);
memset(src, 42, 50);
memcpy(dst, src, 50);  // Copy 50 bytes from src to dst
free(src);
free(dst);
```

**`realloc(ptr, size)` - Resize allocation**
```hemlock
let p = alloc(100);
// ... use 100 bytes
p = realloc(p, 200);   // Resize to 200 bytes
// ... use 200 bytes
free(p);
```

**Note:** After `realloc()`, the old pointer may be invalid. Always use the returned pointer.

### Typed Allocation

Hemlock provides typed allocation helpers for convenience:

```hemlock
let arr = talloc(i32, 100);  // Allocate 100 i32 values (400 bytes)
let size = sizeof(i32);      // Returns 4 (bytes)
```

**`sizeof(type)`** returns the size in bytes of a type:
- `sizeof(i8)` / `sizeof(u8)` â†’ 1
- `sizeof(i16)` / `sizeof(u16)` â†’ 2
- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` â†’ 4
- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` â†’ 8
- `sizeof(ptr)` â†’ 8 (on 64-bit systems)

**`talloc(type, count)`** allocates `count` elements of `type`:

```hemlock
let ints = talloc(i32, 10);   // 40 bytes for 10 i32 values
let floats = talloc(f64, 5);  // 40 bytes for 5 f64 values
free(ints);
free(floats);
```

## Common Patterns

### Pattern: Allocate, Use, Free

The basic pattern for memory management:

```hemlock
// 1. Allocate
let data = alloc(1024);

// 2. Use
memset(data, 0, 1024);
// ... do work

// 3. Free
free(data);
```

### Pattern: Safe Buffer Usage

Prefer buffers for bounds-checked access:

```hemlock
let buf = buffer(256);

// Safe iteration
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

free(buf);
```

### Pattern: Resource Management with try/finally

Ensure cleanup even on errors:

```hemlock
let data = alloc(1024);
try {
    // ... risky operations
    process(data);
} finally {
    free(data);  // Always freed, even on error
}
```

## Memory Safety Considerations

### Double-Free

**Allowed but will crash:**
```hemlock
let p = alloc(100);
free(p);
free(p);  // CRASH: Double-free detected
```

**Prevention:**
```hemlock
let p = alloc(100);
free(p);
p = null;  // Set to null after freeing

if (p != null) {
    free(p);  // Won't execute
}
```

### Dangling Pointers

**Allowed but undefined behavior:**
```hemlock
let p = alloc(100);
*p = 42;      // OK
free(p);
let x = *p;   // UNDEFINED: Reading freed memory
```

**Prevention:** Don't access memory after freeing.

### Memory Leaks

**Easy to create, hard to debug:**
```hemlock
fn leak_memory() {
    let p = alloc(1000);
    // Forgot to free!
    return;  // Memory leaked
}
```

**Prevention:** Always pair `alloc()` with `free()`:
```hemlock
fn safe_function() {
    let p = alloc(1000);
    try {
        // ... use p
    } finally {
        free(p);  // Always freed
    }
}
```

### Pointer Arithmetic

**Allowed but dangerous:**
```hemlock
let p = alloc(10);
let q = p + 100;  // Way past allocation boundary
*q = 42;          // UNDEFINED: Out of bounds write
free(p);
```

**Use buffers for bounds checking:**
```hemlock
let buf = buffer(10);
buf[100] = 42;  // ERROR: Bounds check prevents overflow
```

## Best Practices

1. **Default to `buffer`** - Use `buffer` unless you specifically need raw `ptr`
2. **Match alloc/free** - Every `alloc()` should have exactly one `free()`
3. **Use try/finally** - Ensure cleanup with exception handling
4. **Null after free** - Set pointers to `null` after freeing to catch use-after-free
5. **Bounds check** - Use buffer indexing for automatic bounds checking
6. **Document ownership** - Make clear which code owns and frees each allocation

## Examples

### Example: Dynamic String Builder

```hemlock
fn build_message(count: i32): ptr {
    let size = count * 10;
    let buf = alloc(size);

    let i = 0;
    while (i < count) {
        memset(buf + (i * 10), 65 + i, 10);
        i = i + 1;
    }

    return buf;  // Caller must free
}

let msg = build_message(5);
// ... use msg
free(msg);
```

### Example: Safe Array Operations

```hemlock
fn process_array(size: i32) {
    let arr = buffer(size);

    try {
        // Fill array
        let i = 0;
        while (i < arr.length) {
            arr[i] = i * 2;
            i = i + 1;
        }

        // Process
        i = 0;
        while (i < arr.length) {
            print(arr[i]);
            i = i + 1;
        }
    } finally {
        free(arr);  // Always cleanup
    }
}
```

### Example: Memory Pool Pattern

```hemlock
// Simple memory pool (simplified)
let pool = alloc(10000);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > 10000) {
        throw "Pool exhausted";
    }

    let ptr = pool + pool_offset;
    pool_offset = pool_offset + size;
    return ptr;
}

// Use pool
let p1 = pool_alloc(100);
let p2 = pool_alloc(200);

// Free entire pool at once
free(pool);
```

## Limitations

Current limitations to be aware of:

- **Raw pointers require manual free** - `alloc()` returns `ptr` with no refcounting
- **No custom allocators** - Only system malloc/free

**Note:** Refcounted types (string, array, object, buffer) ARE automatically freed when scope exits. Only raw `ptr` from `alloc()` requires explicit `free()`.

## Related Topics

- [Strings](#language-guide-strings) - String memory management and UTF-8 encoding
- [Arrays](#language-guide-arrays) - Dynamic arrays and their memory characteristics
- [Objects](#language-guide-objects) - Object allocation and lifetime
- [Error Handling](#language-guide-error-handling) - Using try/finally for cleanup

## See Also

- **Design Philosophy**: See CLAUDE.md section "Memory Management"
- **Type System**: See [Types](#language-guide-types) for `ptr` and `buffer` type details
- **FFI**: Raw pointers are essential for Foreign Function Interface


--------------------------------------------------------------------------------
## Moduli
--------------------------------------------------------------------------------

# Hemlock Module System

This document describes the ES6-style import/export module system implemented for Hemlock.

## Overview

Hemlock supports a file-based module system with ES6-style import/export syntax. Modules are:
- **Singletons**: Each module is loaded once and cached
- **File-based**: Modules correspond to .hml files on disk
- **Explicitly imported**: Dependencies are declared with import statements
- **Topologically executed**: Dependencies are executed before dependents

For package management and third-party dependencies, see [hpm (Hemlock Package Manager)](https://github.com/hemlang/hpm).

## Syntax

### Export Statements

**Inline Named Exports:**
```hemlock
export fn add(a, b) {
    return a + b;
}

export const PI = 3.14159;
export let counter = 0;
```

**Export List:**
```hemlock
fn add(a, b) { return a + b; }
fn subtract(a, b) { return a - b; }

export { add, subtract };
```

**Export Extern (FFI Functions):**
```hemlock
import "libc.so.6";

// Export FFI functions for use in other modules
export extern fn strlen(s: string): i32;
export extern fn getpid(): i32;
```

See [FFI Documentation](../advanced/ffi.md#exporting-ffi-functions) for more details on exporting FFI functions.

**Export Define (Struct Types):**
```hemlock
// Export struct type definitions
export define Vector2 {
    x: f32,
    y: f32,
}

export define Rectangle {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
}
```

**Important:** Exported struct types are registered globally when the module is loaded. They become available automatically when you import anything from the module - you do NOT need to (and cannot) explicitly import them by name:

```hemlock
// GOOD - struct types are auto-available after any import
import { some_function } from "./my_module.hml";
let v: Vector2 = { x: 1.0, y: 2.0 };  // Works!

// BAD - cannot explicitly import struct types
import { Vector2 } from "./my_module.hml";  // Error: Undefined variable 'Vector2'
```

See [FFI Documentation](../advanced/ffi.md#exporting-struct-types) for more details on exporting struct types.

**Re-exports:**
```hemlock
// Re-export from another module
export { add, subtract } from "./math.hml";
```

### Import Statements

**Named Imports:**
```hemlock
import { add, subtract } from "./math.hml";
print(add(1, 2));  // 3
```

**Namespace Import:**
```hemlock
import * as math from "./math.hml";
print(math.add(1, 2));  // 3
print(math.PI);  // 3.14159
```

**Aliasing:**
```hemlock
import { add as sum, subtract as diff } from "./math.hml";
print(sum(1, 2));  // 3
```

## Module Resolution

### Path Types

**Relative Paths:**
```hemlock
import { foo } from "./module.hml";       // Same directory
import { bar } from "../parent.hml";      // Parent directory
import { baz } from "./sub/nested.hml";   // Subdirectory
```

**Absolute Paths:**
```hemlock
import { foo } from "/absolute/path/to/module.hml";
```

**Extension Handling:**
- `.hml` extension can be omitted - it will be added automatically
- `./math` resolves to `./math.hml`

## Features

### Circular Dependency Detection

The module system detects circular dependencies and reports an error:

```
Error: Circular dependency detected when loading '/path/to/a.hml'
```

### Module Caching

Modules are loaded once and cached. Multiple imports of the same module return the same instance:

```hemlock
// counter.hml
export let count = 0;
export fn increment() {
    count = count + 1;
}

// a.hml
import { count, increment } from "./counter.hml";
increment();
print(count);  // 1

// b.hml
import { count } from "./counter.hml";  // Same instance!
print(count);  // Still 1 (shared state)
```

### Import Immutability

Imported bindings cannot be reassigned:

```hemlock
import { add } from "./math.hml";
add = fn() { };  // ERROR: cannot reassign imported binding
```

## Implementation Details

### Architecture

**Files:**
- `include/module.h` - Module system API
- `src/module.c` - Module loading, caching, and execution
- Parser support in `src/parser.c`
- Runtime support in `src/interpreter/runtime.c`

**Key Components:**
1. **ModuleCache**: Maintains loaded modules indexed by absolute path
2. **Module**: Represents a loaded module with its AST and exports
3. **Path Resolution**: Resolves relative/absolute paths to canonical paths
4. **Topological Execution**: Executes modules in dependency order

### Module Loading Process

1. **Parse Phase**: Tokenize and parse the module file
2. **Dependency Resolution**: Recursively load imported modules
3. **Cycle Detection**: Check if module is already being loaded
4. **Caching**: Store module in cache by absolute path
5. **Execution Phase**: Execute in topological order (dependencies first)

### API

```c
// High-level API
int execute_file_with_modules(const char *file_path,
                               int argc, char **argv,
                               ExecutionContext *ctx);

// Low-level API
ModuleCache* module_cache_new(const char *initial_dir);
void module_cache_free(ModuleCache *cache);
Module* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);
void execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);
```

## Testing

Test modules are located in `tests/modules/` and `tests/parity/modules/`:

- `math.hml` - Basic module with exports
- `test_import_named.hml` - Named import test
- `test_import_namespace.hml` - Namespace import test
- `test_import_alias.hml` - Import aliasing test
- `export_extern.hml` - Export extern FFI function test (Linux)

## Package Imports (hpm)

With [hpm](https://github.com/hemlang/hpm) installed, you can import third-party packages from GitHub:

```hemlock
// Import from package root (uses "main" from package.json)
import { app, router } from "hemlang/sprout";

// Import from subpath
import { middleware } from "hemlang/sprout/middleware";

// Standard library (built into Hemlock)
import { HashMap } from "@stdlib/collections";
```

Packages are installed to `hem_modules/` and resolved using GitHub `owner/repo` syntax.

```bash
# Install a package
hpm install hemlang/sprout

# Install with version constraint
hpm install hemlang/sprout@^1.0.0
```

See the [hpm documentation](https://github.com/hemlang/hpm) for full details.

## Current Limitations

1. **No Dynamic Imports**: `import()` as a runtime function is not supported
2. **No Conditional Exports**: Exports must be at top level
3. **Static Library Paths**: FFI library imports use static paths (platform-specific)

## Future Work

- Dynamic imports with `import()` function
- Conditional exports
- Module metadata (`import.meta`)
- Tree shaking and dead code elimination

## Examples

See `tests/modules/` for working examples of the module system.

Example module structure:
```
project/
â”œâ”€â”€ main.hml
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ math.hml
â”‚   â”œâ”€â”€ string.hml
â”‚   â””â”€â”€ index.hml (barrel module)
â””â”€â”€ utils/
    â””â”€â”€ helpers.hml
```

Example usage:
```hemlock
// lib/math.hml
export fn add(a, b) { return a + b; }
export fn multiply(a, b) { return a * b; }

// lib/index.hml (barrel)
export { add, multiply } from "./math.hml";

// main.hml
import { add } from "./lib/index.hml";
print(add(2, 3));  // 5
```


--------------------------------------------------------------------------------
## Oggetti
--------------------------------------------------------------------------------

# Oggetti

Hemlock implementa oggetti in stile JavaScript con allocazione nell'heap, campi dinamici, metodi e duck typing. Gli oggetti sono strutture dati flessibili che combinano dati e comportamento.

## Panoramica

```hemlock
// Oggetto anonimo
let person = { name: "Alice", age: 30, city: "Roma" };
print(person.name);  // "Alice"

// Oggetto con metodi
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    }
};

counter.increment();
print(counter.count);  // 1
```

## Letterali oggetto

### Sintassi di base

```hemlock
let person = {
    name: "Alice",
    age: 30,
    city: "Roma"
};
```

**Sintassi:**
- Le parentesi graffe `{}` racchiudono l'oggetto
- Coppie chiave-valore separate da virgole
- Le chiavi sono identificatori (non servono virgolette)
- I valori possono essere di qualsiasi tipo

### Oggetti vuoti

```hemlock
let obj = {};  // Oggetto vuoto

// Aggiungi campi dopo
obj.name = "Alice";
obj.age = 30;
```

### Oggetti annidati

```hemlock
let user = {
    info: {
        name: "Bob",
        age: 25
    },
    active: true,
    settings: {
        theme: "dark",
        notifications: true
    }
};

print(user.info.name);           // "Bob"
print(user.settings.theme);      // "dark"
```

### Tipi di valore misti

```hemlock
let mixed = {
    number: 42,
    text: "ciao",
    flag: true,
    data: null,
    items: [1, 2, 3],
    config: { x: 10, y: 20 }
};
```

### Sintassi abbreviata delle proprieta

Quando il nome di una variabile corrisponde al nome della proprieta, usa la sintassi abbreviata:

```hemlock
let name = "Alice";
let age = 30;
let active = true;

// Abbreviazione: { name } e equivalente a { name: name }
let person = { name, age, active };

print(person.name);   // "Alice"
print(person.age);    // 30
print(person.active); // true
```

**Mescola abbreviazione con proprieta normali:**
```hemlock
let city = "Roma";
let obj = { name, age, city, role: "admin" };
```

### Operatore spread

L'operatore spread (`...`) copia tutti i campi da un oggetto in un altro:

```hemlock
let base = { x: 1, y: 2 };
let extended = { ...base, z: 3 };

print(extended.x);  // 1
print(extended.y);  // 2
print(extended.z);  // 3
```

**Sovrascrivere valori con spread:**
```hemlock
let defaults = { theme: "light", size: "medium", debug: false };
let custom = { ...defaults, theme: "dark" };

print(custom.theme);  // "dark" (sovrascritto)
print(custom.size);   // "medium" (dai defaults)
print(custom.debug);  // false (dai defaults)
```

**Spread multipli (gli spread successivi sovrascrivono i precedenti):**
```hemlock
let a = { x: 1 };
let b = { y: 2 };
let merged = { ...a, ...b, z: 3 };

print(merged.x);  // 1
print(merged.y);  // 2
print(merged.z);  // 3

// Lo spread successivo sovrascrive il precedente
let first = { val: "primo" };
let second = { val: "secondo" };
let combined = { ...first, ...second };
print(combined.val);  // "secondo"
```

**Combina abbreviazione e spread:**
```hemlock
let status = "active";
let data = { id: 1, name: "Elemento" };
let full = { ...data, status };

print(full.id);      // 1
print(full.name);    // "Elemento"
print(full.status);  // "active"
```

**Pattern di override della configurazione:**
```hemlock
let defaultConfig = {
    debug: false,
    timeout: 30,
    retries: 3
};

let prodConfig = { ...defaultConfig, timeout: 60 };
let devConfig = { ...defaultConfig, debug: true };

print(prodConfig.timeout);  // 60
print(devConfig.debug);     // true
```

**Nota:** Lo spread esegue una copia superficiale. Gli oggetti annidati condividono i riferimenti:
```hemlock
let nested = { inner: { val: 42 } };
let copied = { ...nested };
print(copied.inner.val);  // 42 (stesso riferimento di nested.inner)
```

## Accesso ai campi

### Notazione punto

```hemlock
let person = { name: "Alice", age: 30 };

// Leggi campo
let name = person.name;      // "Alice"
let age = person.age;        // 30

// Modifica campo
person.age = 31;
print(person.age);           // 31
```

### Aggiunta dinamica di campi

Aggiungi nuovi campi a runtime:

```hemlock
let person = { name: "Alice" };

// Aggiungi nuovo campo
person.email = "alice@example.com";
person.phone = "555-1234";

print(person.email);  // "alice@example.com"
```

### Eliminazione dei campi

**Nota:** L'eliminazione dei campi non e attualmente supportata. Imposta a `null` invece:

```hemlock
let obj = { x: 10, y: 20 };

// Non puoi eliminare campi (non supportato)
// obj.x = undefined;  // Nessun 'undefined' in Hemlock

// Workaround: Imposta a null
obj.x = null;
```

## Metodi e `self`

### Definire metodi

I metodi sono funzioni memorizzate nei campi dell'oggetto:

```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    },
    decrement: fn() {
        self.count = self.count - 1;
    },
    get: fn() {
        return self.count;
    }
};
```

### La parola chiave `self`

Quando una funzione viene chiamata come metodo, `self` viene automaticamente associato all'oggetto:

```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;  // self si riferisce a counter
    }
};

counter.increment();  // self e associato a counter
print(counter.count);  // 1
```

**Come funziona:**
- Le chiamate di metodo vengono rilevate verificando se l'espressione funzione e un accesso a proprieta
- `self` viene automaticamente associato all'oggetto al momento della chiamata
- `self` e di sola lettura (non puoi riassegnare `self` stesso)

### Rilevamento della chiamata di metodo

```hemlock
let obj = {
    value: 10,
    method: fn() {
        return self.value;
    }
};

// Chiamato come metodo - self e associato
print(obj.method());  // 10

// Chiamato come funzione - self e null (errore)
let f = obj.method;
print(f());  // ERRORE: self non e definito
```

### Metodi con parametri

```hemlock
let calculator = {
    result: 0,
    add: fn(x) {
        self.result = self.result + x;
    },
    multiply: fn(x) {
        self.result = self.result * x;
    },
    get: fn() {
        return self.result;
    }
};

calculator.add(5);
calculator.multiply(2);
print(calculator.get());  // 10
```

## Definizioni di tipo con `define`

### Definizione di tipo di base

Definisci le forme degli oggetti con `define`:

```hemlock
define Person {
    name: string,
    age: i32,
    active: bool,
}

// Crea oggetto e assegna a variabile tipizzata
let p = { name: "Alice", age: 30, active: true };
let typed_p: Person = p;  // Il duck typing valida la struttura

print(typeof(typed_p));  // "Person"
```

**Cosa fa `define`:**
- Dichiara un tipo con campi richiesti
- Abilita la validazione duck typing
- Imposta il nome del tipo dell'oggetto per `typeof()`

### Duck Typing

Gli oggetti vengono validati contro `define` usando la **compatibilita strutturale**:

```hemlock
define Person {
    name: string,
    age: i32,
}

// OK: Ha tutti i campi richiesti
let p1: Person = { name: "Alice", age: 30 };

// OK: Campi extra consentiti
let p2: Person = {
    name: "Bob",
    age: 25,
    city: "Roma",
    active: true
};

// ERRORE: Campo richiesto 'age' mancante
let p3: Person = { name: "Carol" };

// ERRORE: Tipo sbagliato per 'age'
let p4: Person = { name: "Dave", age: "trenta" };
```

**Regole del duck typing:**
- Tutti i campi richiesti devono essere presenti
- I tipi dei campi devono corrispondere
- I campi extra sono consentiti e preservati
- La validazione avviene al momento dell'assegnazione

### Campi opzionali

I campi possono essere opzionali con valori predefiniti:

```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,       // Opzionale con valore predefinito
    nickname?: string,   // Opzionale, predefinito a null
}

// Oggetto con solo campi richiesti
let p = { name: "Alice", age: 30 };
let typed_p: Person = p;

print(typed_p.active);    // true (predefinito applicato)
print(typed_p.nickname);  // null (nessun predefinito)

// Puo sovrascrivere i campi opzionali
let p2: Person = { name: "Bob", age: 25, active: false };
print(p2.active);  // false (sovrascritto)
```

**Sintassi dei campi opzionali:**
- `campo?: valore_predefinito` - Opzionale con predefinito
- `campo?: tipo` - Opzionale con annotazione di tipo, predefinito a null
- I campi opzionali vengono aggiunti durante il duck typing se mancanti

### Verifica del tipo

```hemlock
define Point {
    x: i32,
    y: i32,
}

let p = { x: 10, y: 20 };
let point: Point = p;  // La verifica del tipo avviene qui

print(typeof(point));  // "Point"
print(typeof(p));      // "object" (l'originale e ancora anonimo)
```

**Quando avviene la verifica del tipo:**
- Al momento dell'assegnazione alla variabile tipizzata
- Valida che tutti i campi richiesti siano presenti
- Valida che i tipi dei campi corrispondano (con conversioni implicite)
- Imposta il nome del tipo dell'oggetto

## Firme di metodo in Define

I blocchi define possono specificare firme di metodo, creando contratti simili alle interfacce:

### Metodi richiesti

```hemlock
define Comparable {
    value: i32,
    fn compare(other: Self): i32;  // Firma di metodo richiesta
}

// Gli oggetti devono fornire il metodo richiesto
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};
```

### Metodi opzionali

```hemlock
define Serializable {
    fn serialize(): string;       // Richiesto
    fn pretty?(): string;         // Metodo opzionale (puo essere assente)
}
```

### Il tipo `Self`

`Self` si riferisce al tipo che viene definito, consentendo definizioni di tipo ricorsive:

```hemlock
define Cloneable {
    fn clone(): Self;  // Restituisce lo stesso tipo dell'oggetto
}

define Comparable {
    fn compare(other: Self): i32;  // Prende lo stesso tipo come parametro
    fn equals(other: Self): bool;
}

let item: Cloneable = {
    value: 42,
    clone: fn() {
        return { value: self.value, clone: self.clone };
    }
};
```

### Campi e metodi misti

```hemlock
define Entity {
    id: i32,
    name: string,
    fn validate(): bool;
    fn serialize(): string;
}

let user: Entity = {
    id: 1,
    name: "Alice",
    validate: fn() { return self.id > 0 && self.name != ""; },
    serialize: fn() { return '{"id":' + self.id + ',"name":"' + self.name + '"}'; }
};
```

## Tipi composti (Tipi intersezione)

I tipi composti usano `&` per richiedere che un oggetto soddisfi piu definizioni di tipo:

### Tipi composti di base

```hemlock
define HasName { name: string }
define HasAge { age: i32 }

// Tipo composto: l'oggetto deve soddisfare TUTTI i tipi
let person: HasName & HasAge = { name: "Alice", age: 30 };
```

### Parametri di funzione con tipi composti

```hemlock
fn greet(p: HasName & HasAge) {
    print(p.name + " ha " + p.age + " anni");
}

greet({ name: "Bob", age: 25, city: "Roma" });  // Campi extra OK
```

### Tre o piu tipi

```hemlock
define HasEmail { email: string }

fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}
```

### Alias di tipo per tipi composti

```hemlock
// Crea un alias con nome per un tipo composto
type Person = HasName & HasAge;
type Employee = HasName & HasAge & HasEmail;

let emp: Employee = {
    name: "Charlie",
    age: 35,
    email: "charlie@example.com"
};
```

**Duck typing con composti:** I campi extra sono sempre consentiti - l'oggetto deve solo avere almeno i campi richiesti da tutti i tipi componenti.

## Serializzazione JSON

### Serializzare in JSON

Converti oggetti in stringhe JSON:

```hemlock
// obj.serialize() - Converti oggetto in stringa JSON
let obj = { x: 10, y: 20, name: "test" };
let json = obj.serialize();
print(json);  // {"x":10,"y":20,"name":"test"}

// Oggetti annidati
let nested = { inner: { a: 1, b: 2 }, outer: 3 };
print(nested.serialize());  // {"inner":{"a":1,"b":2},"outer":3}
```

### Deserializzare da JSON

Analizza stringhe JSON in oggetti:

```hemlock
// json.deserialize() - Analizza stringa JSON in oggetto
let json_str = '{"x":10,"y":20,"name":"test"}';
let obj = json_str.deserialize();

print(obj.name);   // "test"
print(obj.x);      // 10
```

### Rilevamento dei cicli

I riferimenti circolari vengono rilevati e causano errori:

```hemlock
let obj = { x: 10 };
obj.me = obj;  // Crea riferimento circolare

obj.serialize();  // ERRORE: serialize() ha rilevato riferimento circolare
```

### Tipi supportati

La serializzazione JSON supporta:

- **Numeri**: i8-i32, u8-u32, f32, f64
- **Booleani**: true, false
- **Stringhe**: Con sequenze di escape
- **Null**: valore null
- **Oggetti**: Oggetti annidati
- **Array**: Array annidati

**Non supportati:**
- Funzioni (omesse silenziosamente)
- Puntatori (errore)
- Buffer (errore)

### Gestione degli errori

La serializzazione e deserializzazione possono generare errori:

```hemlock
// JSON non valido genera un errore
try {
    let bad = "json non valido".deserialize();
} catch (e) {
    print("Errore di parsing:", e);
}

// I puntatori non possono essere serializzati
let obj = { ptr: alloc(10) };
try {
    obj.serialize();
} catch (e) {
    print("Errore di serializzazione:", e);
}
```

### Esempio round-trip

Esempio completo di serializzazione e deserializzazione:

```hemlock
define Config {
    host: string,
    port: i32,
    debug: bool
}

// Crea e serializza
let config: Config = {
    host: "localhost",
    port: 8080,
    debug: true
};
let json = config.serialize();
print(json);  // {"host":"localhost","port":8080,"debug":true}

// Deserializza
let restored = json.deserialize();
print(restored.host);  // "localhost"
print(restored.port);  // 8080
```

## Funzioni integrate

### `typeof(value)`

Restituisce il nome del tipo come stringa:

```hemlock
let obj = { x: 10 };
print(typeof(obj));  // "object"

define Person { name: string, age: i32 }
let p: Person = { name: "Alice", age: 30 };
print(typeof(p));    // "Person"
```

**Valori restituiti:**
- Oggetti anonimi: `"object"`
- Oggetti tipizzati: Nome del tipo personalizzato (es. `"Person"`)

## Dettagli di implementazione

### Modello di memoria

- **Allocato nell'heap** - Tutti gli oggetti sono allocati nell'heap
- **Copia superficiale** - L'assegnazione copia il riferimento, non l'oggetto
- **Campi dinamici** - Memorizzati come array dinamici di coppie nome/valore
- **Conteggiati per riferimento** - Gli oggetti vengono liberati automaticamente quando lo scope termina

### Semantica dei riferimenti

```hemlock
let obj1 = { x: 10 };
let obj2 = obj1;  // Copia superficiale (stesso riferimento)

obj2.x = 20;
print(obj1.x);  // 20 (entrambi si riferiscono allo stesso oggetto)
```

### Memorizzazione dei metodi

I metodi sono semplicemente funzioni memorizzate nei campi:

```hemlock
let obj = {
    value: 10,
    method: fn() { return self.value; }
};

// method e una funzione memorizzata in obj.method
print(typeof(obj.method));  // "function"
```

## Pattern comuni

### Pattern: Funzione costruttore

```hemlock
fn createPerson(name: string, age: i32) {
    return {
        name: name,
        age: age,
        greet: fn() {
            return "Ciao, sono " + self.name;
        }
    };
}

let person = createPerson("Alice", 30);
print(person.greet());  // "Ciao, sono Alice"
```

### Pattern: Object builder

```hemlock
fn PersonBuilder() {
    return {
        name: null,
        age: null,

        setName: fn(n) {
            self.name = n;
            return self;  // Abilita il concatenamento
        },

        setAge: fn(a) {
            self.age = a;
            return self;
        },

        build: fn() {
            return { name: self.name, age: self.age };
        }
    };
}

let person = PersonBuilder()
    .setName("Alice")
    .setAge(30)
    .build();
```

### Pattern: Oggetto stato

```hemlock
let state = {
    status: "idle",
    data: null,
    error: null,

    setState: fn(new_status) {
        self.status = new_status;
    },

    setData: fn(new_data) {
        self.data = new_data;
        self.status = "success";
    },

    setError: fn(err) {
        self.error = err;
        self.status = "error";
    }
};
```

### Pattern: Oggetto configurazione

```hemlock
let config = {
    defaults: {
        timeout: 30,
        retries: 3,
        debug: false
    },

    get: fn(key) {
        if (self.defaults[key] != null) {
            return self.defaults[key];
        }
        return null;
    },

    set: fn(key, value) {
        self.defaults[key] = value;
    }
};
```

## Buone pratiche

1. **Usa `define` per la struttura** - Documenta le forme degli oggetti attese
2. **Preferisci le funzioni factory** - Crea oggetti con costruttori
3. **Mantieni gli oggetti semplici** - Non annidare troppo profondamente
4. **Documenta l'uso di `self`** - Rendi chiaro il comportamento dei metodi
5. **Valida all'assegnazione** - Usa il duck typing per catturare gli errori presto
6. **Evita i riferimenti circolari** - Causeranno errori di serializzazione
7. **Usa i campi opzionali** - Fornisci valori predefiniti sensati

## Trabocchetti comuni

### Trabocchetto: Riferimento vs. Valore

```hemlock
let obj1 = { x: 10 };
let obj2 = obj1;  // Copia superficiale

obj2.x = 20;
print(obj1.x);  // 20 (sorpresa! entrambi sono cambiati)

// Per evitare: Crea nuovo oggetto
let obj3 = { x: obj1.x };  // Copia profonda (manuale)
```

### Trabocchetto: `self` in chiamate non-metodo

```hemlock
let obj = {
    value: 10,
    method: fn() { return self.value; }
};

// Funziona: Chiamato come metodo
print(obj.method());  // 10

// ERRORE: Chiamato come funzione
let f = obj.method;
print(f());  // ERRORE: self non e definito
```

### Trabocchetto: Puntatori raw negli oggetti

```hemlock
// Gli oggetti vengono liberati automaticamente, ma i puntatori raw dentro NON lo sono
fn create_objects() {
    let obj = { data: alloc(1000) };  // ptr raw richiede free manuale
    // obj viene liberato automaticamente quando lo scope termina, ma obj.data perde memoria!
}

// Soluzione: Libera i puntatori raw prima che lo scope termini
fn safe_create() {
    let obj = { data: alloc(1000) };
    // ... usa obj.data ...
    free(obj.data);  // Libera esplicitamente il puntatore raw
}  // obj stesso viene liberato automaticamente
```

### Trabocchetto: Confusione di tipo

```hemlock
let obj = { x: 10 };

define Point { x: i32, y: i32 }

// ERRORE: Campo richiesto 'y' mancante
let p: Point = obj;
```

## Esempi

### Esempio: Matematica vettoriale

```hemlock
fn createVector(x, y) {
    return {
        x: x,
        y: y,

        add: fn(other) {
            return createVector(
                self.x + other.x,
                self.y + other.y
            );
        },

        length: fn() {
            return sqrt(self.x * self.x + self.y * self.y);
        },

        toString: fn() {
            return "(" + typeof(self.x) + ", " + typeof(self.y) + ")";
        }
    };
}

let v1 = createVector(3, 4);
let v2 = createVector(1, 2);
let v3 = v1.add(v2);

print(v3.toString());  // "(4, 6)"
```

### Esempio: Database semplice

```hemlock
fn createDatabase() {
    let records = [];
    let next_id = 1;

    return {
        insert: fn(data) {
            let record = { id: next_id, data: data };
            records.push(record);
            next_id = next_id + 1;
            return record.id;
        },

        find: fn(id) {
            let i = 0;
            while (i < records.length) {
                if (records[i].id == id) {
                    return records[i];
                }
                i = i + 1;
            }
            return null;
        },

        count: fn() {
            return records.length;
        }
    };
}

let db = createDatabase();
let id = db.insert({ name: "Alice", age: 30 });
let record = db.find(id);
print(record.data.name);  // "Alice"
```

### Esempio: Emettitore di eventi

```hemlock
fn createEventEmitter() {
    let listeners = {};

    return {
        on: fn(event, handler) {
            if (listeners[event] == null) {
                listeners[event] = [];
            }
            listeners[event].push(handler);
        },

        emit: fn(event, data) {
            if (listeners[event] != null) {
                let i = 0;
                while (i < listeners[event].length) {
                    listeners[event][i](data);
                    i = i + 1;
                }
            }
        }
    };
}

let emitter = createEventEmitter();

emitter.on("message", fn(data) {
    print("Ricevuto: " + data);
});

emitter.emit("message", "Ciao!");
```

## Limitazioni

Limitazioni attuali:

- **Nessuna copia profonda** - Devi copiare manualmente gli oggetti annidati (spread e superficiale)
- **Nessun passaggio per valore** - Gli oggetti vengono sempre passati per riferimento
- **Nessuna proprieta calcolata** - Nessuna sintassi `{[key]: value}`
- **`self` e di sola lettura** - Non puoi riassegnare `self` nei metodi
- **Nessuna eliminazione di proprieta** - Non puoi rimuovere i campi una volta aggiunti

**Nota:** Gli oggetti sono conteggiati per riferimento e liberati automaticamente quando lo scope termina. Vedi [Gestione della memoria](memory.md#conteggio-interno-dei-riferimenti) per i dettagli.

## Argomenti correlati

- [Funzioni](#language-guide-functions) - I metodi sono funzioni memorizzate negli oggetti
- [Array](#language-guide-arrays) - Gli array sono anche simili agli oggetti
- [Tipi](#language-guide-types) - Duck typing e definizioni di tipo
- [Gestione degli errori](#language-guide-error-handling) - Lanciare oggetti errore

## Vedi anche

- **Duck Typing**: Vedi sezione "Objects" di CLAUDE.md per i dettagli sul duck typing
- **JSON**: Vedi CLAUDE.md per i dettagli sulla serializzazione JSON
- **Memoria**: Vedi [Memoria](#language-guide-memory) per l'allocazione degli oggetti


--------------------------------------------------------------------------------
## Pattern Matching
--------------------------------------------------------------------------------

# Pattern Matching

Hemlock provides powerful pattern matching through `match` expressions, offering a concise way to destructure values, check types, and handle multiple cases.

## Basic Syntax

```hemlock
let result = match (value) {
    pattern1 => expression1,
    pattern2 => expression2,
    _ => default_expression
};
```

Match expressions evaluate `value` against each pattern in order, returning the result of the first matching arm's expression.

## Pattern Types

### Literal Patterns

Match against exact values:

```hemlock
let x = 42;
let msg = match (x) {
    0 => "zero",
    1 => "one",
    42 => "the answer",
    _ => "other"
};
print(msg);  // "the answer"
```

Supported literals:
- **Integers**: `0`, `42`, `-5`
- **Floats**: `3.14`, `-0.5`
- **Strings**: `"hello"`, `"world"`
- **Booleans**: `true`, `false`
- **Null**: `null`

### Wildcard Pattern (`_`)

Matches any value without binding:

```hemlock
let x = "anything";
let result = match (x) {
    "specific" => "found it",
    _ => "wildcard matched"
};
```

### Variable Binding Patterns

Bind the matched value to a variable:

```hemlock
let x = 100;
let result = match (x) {
    0 => "zero",
    n => "value is " + n  // n binds to 100
};
print(result);  // "value is 100"
```

### OR Patterns (`|`)

Match multiple alternatives:

```hemlock
let x = 2;
let size = match (x) {
    1 | 2 | 3 => "small",
    4 | 5 | 6 => "medium",
    _ => "large"
};

// Works with strings too
let cmd = "quit";
let action = match (cmd) {
    "exit" | "quit" | "q" => "exiting",
    "help" | "h" | "?" => "showing help",
    _ => "unknown"
};
```

### Guard Expressions (`if`)

Add conditions to patterns:

```hemlock
let x = 15;
let category = match (x) {
    n if n < 0 => "negative",
    n if n == 0 => "zero",
    n if n < 10 => "small",
    n if n < 100 => "medium",
    n => "large: " + n
};
print(category);  // "medium"

// Complex guards
let y = 12;
let result = match (y) {
    n if n % 2 == 0 && n > 10 => "even and greater than 10",
    n if n % 2 == 0 => "even",
    n => "odd"
};
```

### Type Patterns

Check and bind based on type:

```hemlock
let val = 42;
let desc = match (val) {
    num: i32 => "integer: " + num,
    str: string => "string: " + str,
    flag: bool => "boolean: " + flag,
    _ => "other type"
};
print(desc);  // "integer: 42"
```

Supported types: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`, `bool`, `string`, `array`, `object`

## Destructuring Patterns

### Object Destructuring

Extract fields from objects:

```hemlock
let point = { x: 10, y: 20 };
let result = match (point) {
    { x, y } => "point at " + x + "," + y
};
print(result);  // "point at 10,20"

// With literal field values
let origin = { x: 0, y: 0 };
let name = match (origin) {
    { x: 0, y: 0 } => "origin",
    { x: 0, y } => "on y-axis at " + y,
    { x, y: 0 } => "on x-axis at " + x,
    { x, y } => "point at " + x + "," + y
};
print(name);  // "origin"
```

### Array Destructuring

Match array structure and elements:

```hemlock
let arr = [1, 2, 3];
let desc = match (arr) {
    [] => "empty",
    [x] => "single: " + x,
    [x, y] => "pair: " + x + "," + y,
    [x, y, z] => "triple: " + x + "," + y + "," + z,
    _ => "many elements"
};
print(desc);  // "triple: 1,2,3"

// With literal values
let pair = [1, 2];
let result = match (pair) {
    [0, 0] => "both zero",
    [1, x] => "starts with 1, second is " + x,
    [x, 1] => "ends with 1",
    _ => "other"
};
print(result);  // "starts with 1, second is 2"
```

### Array Rest Patterns (`...`)

Capture remaining elements:

```hemlock
let nums = [1, 2, 3, 4, 5];

// Head and tail
let result = match (nums) {
    [first, ...rest] => "first: " + first,
    [] => "empty"
};
print(result);  // "first: 1"

// First two elements
let result2 = match (nums) {
    [a, b, ...rest] => "first two: " + a + "," + b,
    _ => "too short"
};
print(result2);  // "first two: 1,2"
```

### Nested Destructuring

Combine patterns for complex data:

```hemlock
let user = {
    name: "Alice",
    address: { city: "NYC", zip: 10001 }
};

let result = match (user) {
    { name, address: { city, zip } } => name + " lives in " + city,
    _ => "unknown"
};
print(result);  // "Alice lives in NYC"

// Object containing array
let data = { items: [1, 2, 3], count: 3 };
let result2 = match (data) {
    { items: [first, ...rest], count } => "first: " + first + ", total: " + count,
    _ => "no items"
};
print(result2);  // "first: 1, total: 3"
```

## Match as Expression

Match is an expression that returns a value:

```hemlock
// Direct assignment
let grade = 85;
let letter = match (grade) {
    n if n >= 90 => "A",
    n if n >= 80 => "B",
    n if n >= 70 => "C",
    n if n >= 60 => "D",
    _ => "F"
};

// In string concatenation
let msg = "Grade: " + match (grade) {
    n if n >= 70 => "passing",
    _ => "failing"
};

// In function return
fn classify(n: i32): string {
    return match (n) {
        0 => "zero",
        n if n > 0 => "positive",
        _ => "negative"
    };
}
```

## Pattern Matching Best Practices

1. **Order matters**: Patterns are checked top-to-bottom; put specific patterns before general ones
2. **Use wildcards for exhaustiveness**: Always include a `_` fallback unless you're certain all cases are covered
3. **Prefer guards over nested conditions**: Guards make intent clearer
4. **Use destructuring over manual field access**: More concise and safer

```hemlock
// Good: Guards for range checking
match (score) {
    n if n >= 90 => "A",
    n if n >= 80 => "B",
    _ => "below B"
}

// Good: Destructure instead of accessing fields
match (point) {
    { x: 0, y: 0 } => "origin",
    { x, y } => "at " + x + "," + y
}

// Avoid: Overly complex nested patterns
// Instead, consider breaking into multiple matches or using guards
```

## Comparison with Other Languages

| Feature | Hemlock | Rust | JavaScript |
|---------|---------|------|------------|
| Basic matching | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |
| Destructuring | Yes | Yes | Partial (switch doesn't destructure) |
| Guards | `n if n > 0 =>` | `n if n > 0 =>` | N/A |
| OR patterns | `1 \| 2 \| 3 =>` | `1 \| 2 \| 3 =>` | `case 1: case 2: case 3:` |
| Rest patterns | `[a, ...rest]` | `[a, rest @ ..]` | N/A |
| Type patterns | `n: i32` | Type via `match` arm | N/A |
| Returns value | Yes | Yes | No (statement) |

## Implementation Notes

Pattern matching is implemented in both the interpreter and compiler backends with full parity - both produce identical results for the same input. The feature is available in Hemlock v1.8.0+.


--------------------------------------------------------------------------------
## Rune
--------------------------------------------------------------------------------

# Runes

Runes represent **Unicode codepoints** (U+0000 to U+10FFFF) as a distinct type for character manipulation in Hemlock. Unlike bytes (u8), runes are full Unicode characters that can represent any character in any language or emoji.

## Overview

```hemlock
let ch = 'A';           // Rune literal
let emoji = 'ðŸš€';       // Multi-byte character as single rune
print(ch);              // 'A'
print(emoji);           // U+1F680

let s = "Hello " + '!'; // String + rune concatenation
let r = '>' + " msg";   // Rune + string concatenation
```

## What is a Rune?

A rune is a **32-bit value** representing a Unicode codepoint:

- **Range:** 0 to 0x10FFFF (1,114,111 valid codepoints)
- **Not a numeric type** - Used for character representation
- **Distinct from u8/char** - Runes are full Unicode, u8 is just bytes
- **Returned by string indexing** - `str[0]` returns a rune, not a byte

**Why runes?**
- Hemlock strings are UTF-8 encoded
- A single Unicode character can be 1-4 bytes in UTF-8
- Runes allow working with complete characters, not partial bytes

## Rune Literals

### Basic Syntax

Single quotes denote rune literals:

```hemlock
let a = 'A';            // ASCII character
let b = '0';            // Digit character
let c = '!';            // Punctuation
let d = ' ';            // Space
```

### Multi-byte UTF-8 Characters

Runes can represent any Unicode character:

```hemlock
// Emoji
let rocket = 'ðŸš€';      // Emoji (U+1F680)
let heart = 'â¤';        // Heart (U+2764)
let smile = 'ðŸ˜€';       // Grinning face (U+1F600)

// CJK characters
let chinese = 'ä¸­';     // Chinese (U+4E2D)
let japanese = 'ã‚';    // Hiragana (U+3042)
let korean = 'í•œ';      // Hangul (U+D55C)

// Symbols
let check = 'âœ“';        // Checkmark (U+2713)
let arrow = 'â†’';        // Rightwards arrow (U+2192)
```

### Escape Sequences

Common escape sequences for special characters:

```hemlock
let newline = '\n';     // Newline (U+000A)
let tab = '\t';         // Tab (U+0009)
let backslash = '\\';   // Backslash (U+005C)
let quote = '\'';       // Single quote (U+0027)
let dquote = '"';       // Double quote (U+0022)
let null_char = '\0';   // Null character (U+0000)
let cr = '\r';          // Carriage return (U+000D)
```

**Available escape sequences:**
- `\n` - Newline (line feed)
- `\t` - Horizontal tab
- `\r` - Carriage return
- `\0` - Null character
- `\\` - Backslash
- `\'` - Single quote
- `\"` - Double quote

### Unicode Escapes

Use `\u{XXXXXX}` syntax for Unicode codepoints (up to 6 hex digits):

```hemlock
let rocket = '\u{1F680}';   // ðŸš€ Emoji via Unicode escape
let heart = '\u{2764}';     // â¤ Heart
let ascii = '\u{41}';       // 'A' via escape
let max = '\u{10FFFF}';     // Maximum Unicode codepoint

// Leading zeros optional
let a = '\u{41}';           // Same as '\u{0041}'
let b = '\u{0041}';
```

**Rules:**
- Range: `\u{0}` to `\u{10FFFF}`
- Hex digits: 1 to 6 digits
- Case insensitive: `\u{1F680}` or `\u{1f680}`
- Values outside valid Unicode range cause error

## String + Rune Concatenation

Runes can be concatenated with strings:

```hemlock
// String + rune
let greeting = "Hello" + '!';       // "Hello!"
let decorated = "Text" + 'âœ“';       // "Textâœ“"

// Rune + string
let prefix = '>' + " Message";      // "> Message"
let bullet = 'â€¢' + " Item";         // "â€¢ Item"

// Multiple concatenations
let msg = "Hi " + 'ðŸ‘‹' + " World " + 'ðŸŒ';  // "Hi ðŸ‘‹ World ðŸŒ"

// Method chaining works
let result = ('>' + " Important").to_upper();  // "> IMPORTANT"
```

**How it works:**
- Runes are automatically encoded to UTF-8
- Converted to strings during concatenation
- The string concatenation operator handles this transparently

## Type Conversions

Runes can convert to/from other types.

### Integer â†” Rune

Convert between integers and runes to work with codepoint values:

```hemlock
// Integer to rune (codepoint value)
let code: rune = 65;            // 'A' (ASCII 65)
let emoji_code: rune = 128640;  // U+1F680 (ðŸš€)

// Rune to integer (get codepoint value)
let r = 'Z';
let value: i32 = r;             // 90 (ASCII value)

let rocket = 'ðŸš€';
let code: i32 = rocket;         // 128640 (U+1F680)
```

**Range checking:**
- Integer to rune: Must be in [0, 0x10FFFF]
- Out of range values cause runtime error
- Rune to integer: Always succeeds (returns codepoint)

### Rune â†’ String

Runes can be explicitly converted to strings:

```hemlock
// Explicit conversion
let ch: string = 'H';           // "H"
let emoji: string = 'ðŸš€';       // "ðŸš€"

// Automatic during concatenation
let s = "" + 'A';               // "A"
let s2 = "x" + 'y' + "z";       // "xyz"
```

### u8 (Byte) â†’ Rune

Any u8 value (0-255) can convert to rune:

```hemlock
// ASCII range (0-127)
let byte: u8 = 65;
let rune_val: rune = byte;      // 'A'

// Extended ASCII / Latin-1 (128-255)
let extended: u8 = 200;
let r: rune = extended;         // U+00C8 (Ãˆ)

// Note: Values 0-127 are ASCII, 128-255 are Latin-1
```

### Chained Conversions

Type conversions can be chained:

```hemlock
// i32 â†’ rune â†’ string
let code: i32 = 128512;         // Grinning face codepoint
let r: rune = code;             // ðŸ˜€
let s: string = r;              // "ðŸ˜€"

// All in one expression
let emoji: string = 128640;     // Implicit i32 â†’ rune â†’ string (ðŸš€)
```

## Rune Operations

### Printing

How runes are displayed depends on the codepoint:

```hemlock
let ascii = 'A';
print(ascii);                   // 'A' (quoted, printable ASCII)

let emoji = 'ðŸš€';
print(emoji);                   // U+1F680 (Unicode notation for non-ASCII)

let tab = '\t';
print(tab);                     // U+0009 (non-printable as hex)

let space = ' ';
print(space);                   // ' ' (printable)
```

**Print format:**
- Printable ASCII (32-126): Quoted character `'A'`
- Non-printable or Unicode: Hex notation `U+XXXX`

### Type Checking

Use `typeof()` to check if a value is a rune:

```hemlock
let r = 'ðŸš€';
print(typeof(r));               // "rune"

let s = "text";
let ch = s[0];
print(typeof(ch));              // "rune" (indexing returns runes)

let num = 65;
print(typeof(num));             // "i32"
```

### Comparison

Runes can be compared for equality:

```hemlock
let a = 'A';
let b = 'B';
print(a == a);                  // true
print(a == b);                  // false

// Case sensitive
let upper = 'A';
let lower = 'a';
print(upper == lower);          // false

// Runes can be compared with integers (codepoint values)
print(a == 65);                 // true (implicit conversion)
print('ðŸš€' == 128640);          // true
```

**Comparison operators:**
- `==` - Equal
- `!=` - Not equal
- `<`, `>`, `<=`, `>=` - Codepoint order

```hemlock
print('A' < 'B');               // true (65 < 66)
print('a' > 'Z');               // true (97 > 90)
```

## Working with String Indexing

String indexing returns runes, not bytes:

```hemlock
let s = "HelloðŸš€";
let h = s[0];                   // 'H' (rune)
let rocket = s[5];              // 'ðŸš€' (rune)

print(typeof(h));               // "rune"
print(typeof(rocket));          // "rune"

// Convert to string if needed
let h_str: string = h;          // "H"
let rocket_str: string = rocket; // "ðŸš€"
```

**Important:** String indexing uses codepoint positions, not byte offsets:

```hemlock
let text = "HiðŸš€!";
// Codepoint positions: 0='H', 1='i', 2='ðŸš€', 3='!'
// Byte positions:      0='H', 1='i', 2-5='ðŸš€', 6='!'

let r = text[2];                // 'ðŸš€' (codepoint 2)
print(typeof(r));               // "rune"
```

## Examples

### Example: Character Classification

```hemlock
fn is_digit(r: rune): bool {
    return r >= '0' && r <= '9';
}

fn is_upper(r: rune): bool {
    return r >= 'A' && r <= 'Z';
}

fn is_lower(r: rune): bool {
    return r >= 'a' && r <= 'z';
}

print(is_digit('5'));           // true
print(is_upper('A'));           // true
print(is_lower('z'));           // true
```

### Example: Case Conversion

```hemlock
fn to_upper_rune(r: rune): rune {
    if (r >= 'a' && r <= 'z') {
        // Convert to uppercase (subtract 32)
        let code: i32 = r;
        code = code - 32;
        return code;
    }
    return r;
}

fn to_lower_rune(r: rune): rune {
    if (r >= 'A' && r <= 'Z') {
        // Convert to lowercase (add 32)
        let code: i32 = r;
        code = code + 32;
        return code;
    }
    return r;
}

print(to_upper_rune('a'));      // 'A'
print(to_lower_rune('Z'));      // 'z'
```

### Example: Character Iteration

```hemlock
fn print_chars(s: string) {
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        print("Position " + typeof(i) + ": " + typeof(ch));
        i = i + 1;
    }
}

print_chars("HiðŸš€");
// Position 0: 'H'
// Position 1: 'i'
// Position 2: U+1F680
```

### Example: Building Strings from Runes

```hemlock
fn repeat_char(ch: rune, count: i32): string {
    let result = "";
    let i = 0;
    while (i < count) {
        result = result + ch;
        i = i + 1;
    }
    return result;
}

let line = repeat_char('=', 40);  // "========================================"
let stars = repeat_char('â­', 5);  // "â­â­â­â­â­"
```

## Common Patterns

### Pattern: Character Filter

```hemlock
fn filter_digits(s: string): string {
    let result = "";
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        if (ch >= '0' && ch <= '9') {
            result = result + ch;
        }
        i = i + 1;
    }
    return result;
}

let text = "abc123def456";
let digits = filter_digits(text);  // "123456"
```

### Pattern: Character Counting

```hemlock
fn count_char(s: string, target: rune): i32 {
    let count = 0;
    let i = 0;
    while (i < s.length) {
        if (s[i] == target) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

let text = "hello world";
let l_count = count_char(text, 'l');  // 3
let o_count = count_char(text, 'o');  // 2
```

## Best Practices

1. **Use runes for character operations** - Don't try to work with bytes for text
2. **String indexing returns runes** - Remember that `str[i]` gives you a rune
3. **Unicode-aware comparisons** - Runes handle any Unicode character
4. **Convert when needed** - Runes convert easily to strings and integers
5. **Test with emoji** - Always test character operations with multi-byte characters

## Common Pitfalls

### Pitfall: Rune vs. Byte Confusion

```hemlock
// DON'T: Treat runes as bytes
let r: rune = 'ðŸš€';
let b: u8 = r;              // ERROR: Rune codepoint 128640 doesn't fit in u8

// DO: Use appropriate conversions
let r: rune = 'ðŸš€';
let code: i32 = r;          // OK: 128640
```

### Pitfall: String Byte Indexing

```hemlock
// DON'T: Assume byte indexing
let s = "ðŸš€";
let byte = s.byte_at(0);    // 240 (first UTF-8 byte, not complete char)

// DO: Use codepoint indexing
let s = "ðŸš€";
let rune = s[0];            // 'ðŸš€' (complete character)
let rune2 = s.char_at(0);   // 'ðŸš€' (explicit method)
```

## Related Topics

- [Strings](#language-guide-strings) - String operations and UTF-8 handling
- [Types](#language-guide-types) - Type system and conversions
- [Control Flow](#language-guide-control-flow) - Using runes in comparisons

## See Also

- **Unicode Standard**: Unicode codepoints are defined by the Unicode Consortium
- **UTF-8 Encoding**: See [Strings](#language-guide-strings) for UTF-8 details
- **Type Conversions**: See [Types](#language-guide-types) for conversion rules


--------------------------------------------------------------------------------
## Sintassi
--------------------------------------------------------------------------------

# Panoramica della sintassi

Questo documento illustra le regole fondamentali della sintassi e la struttura dei programmi Hemlock.

## Regole di sintassi di base

### I punti e virgola sono obbligatori

A differenza di JavaScript o Python, i punti e virgola sono **sempre richiesti** alla fine delle istruzioni:

```hemlock
let x = 42;
let y = 10;
print(x + y);
```

**Questo causera un errore:**
```hemlock
let x = 42  // ERRORE: Punto e virgola mancante
let y = 10  // ERRORE: Punto e virgola mancante
```

### Le parentesi graffe sono sempre richieste

Tutti i blocchi di flusso di controllo devono utilizzare le parentesi graffe, anche per le istruzioni singole:

```hemlock
// CORRETTO
if (x > 0) {
    print("positivo");
}

// ERRORE: Parentesi graffe mancanti
if (x > 0)
    print("positivo");
```

### Commenti

```hemlock
// Questo e un commento su una singola riga

/*
   Questo e un
   commento multi-riga
*/

let x = 42;  // Commento in linea
```

## Variabili

### Dichiarazione

Le variabili vengono dichiarate con `let`:

```hemlock
let count = 0;
let name = "Alice";
let pi = 3.14159;
```

### Annotazioni di tipo (opzionali)

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let flag: bool = true;
let text: string = "ciao";
```

### Costanti

Usare `const` per i valori immutabili:

```hemlock
const MAX_SIZE: i32 = 1000;
const PI: f64 = 3.14159;
```

Tentare di riassegnare una costante causera un errore di esecuzione: "Cannot assign to const variable".

## Espressioni

### Operatori aritmetici

```hemlock
let a = 10;
let b = 3;

print(a + b);   // 13 - Addizione
print(a - b);   // 7  - Sottrazione
print(a * b);   // 30 - Moltiplicazione
print(a / b);   // 3  - Divisione (intera)
```

### Operatori di confronto

```hemlock
print(a == b);  // false - Uguale
print(a != b);  // true  - Diverso
print(a > b);   // true  - Maggiore di
print(a < b);   // false - Minore di
print(a >= b);  // true  - Maggiore o uguale
print(a <= b);  // false - Minore o uguale
```

### Operatori logici

```hemlock
let x = true;
let y = false;

print(x && y);  // false - AND
print(x || y);  // true  - OR
print(!x);      // false - NOT
```

### Operatori bitwise

```hemlock
let a = 12;  // 1100
let b = 10;  // 1010

print(a & b);   // 8  - AND bit a bit
print(a | b);   // 14 - OR bit a bit
print(a ^ b);   // 6  - XOR bit a bit
print(a << 2);  // 48 - Shift a sinistra
print(a >> 1);  // 6  - Shift a destra
print(~a);      // -13 - NOT bit a bit
```

### Precedenza degli operatori

Dalla piu alta alla piu bassa:

1. `()` - Raggruppamento
2. `!`, `~`, `-` (unario) - Operatori unari
3. `*`, `/` - Moltiplicazione, Divisione
4. `+`, `-` - Addizione, Sottrazione
5. `<<`, `>>` - Shift bit a bit
6. `<`, `<=`, `>`, `>=` - Confronti
7. `==`, `!=` - Uguaglianza
8. `&` - AND bit a bit
9. `^` - XOR bit a bit
10. `|` - OR bit a bit
11. `&&` - AND logico
12. `||` - OR logico

**Esempi:**
```hemlock
let x = 2 + 3 * 4;      // 14 (non 20)
let y = (2 + 3) * 4;    // 20
let z = 5 << 2 + 1;     // 40 (5 << 3)
```

## Flusso di controllo

### Istruzioni If

```hemlock
if (condizione) {
    // corpo
}

if (condizione) {
    // ramo then
} else {
    // ramo else
}

if (condizione1) {
    // ramo 1
} else if (condizione2) {
    // ramo 2
} else {
    // ramo predefinito
}
```

### Cicli While

```hemlock
while (condizione) {
    // corpo
}
```

**Esempio:**
```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

### Cicli For

**Stile C:**
```hemlock
for (inizializzatore; condizione; incremento) {
    // corpo
}
```

**Esempio:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**For-in (array):**
```hemlock
for (let item in array) {
    // corpo
}
```

**Esempio:**
```hemlock
let items = [10, 20, 30];
for (let x in items) {
    print(x);
}
```

### Istruzioni Switch

```hemlock
switch (espressione) {
    case valore1:
        // corpo
        break;
    case valore2:
        // corpo
        break;
    default:
        // corpo predefinito
        break;
}
```

**Esempio:**
```hemlock
let day = 3;
switch (day) {
    case 1:
        print("Lunedi");
        break;
    case 2:
        print("Martedi");
        break;
    case 3:
        print("Mercoledi");
        break;
    default:
        print("Altro");
        break;
}
```

### Break e Continue

```hemlock
// Break: uscire dal ciclo
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        break;
    }
    print(i);
}

// Continue: passare all'iterazione successiva
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;
    }
    print(i);
}
```

## Funzioni

### Funzioni con nome

```hemlock
fn function_name(param1: type1, param2: type2): return_type {
    // corpo
    return value;
}
```

**Esempio:**
```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Funzioni anonime

```hemlock
let func = fn(params) {
    // corpo
};
```

**Esempio:**
```hemlock
let multiply = fn(x, y) {
    return x * y;
};
```

### Annotazioni di tipo (opzionali)

```hemlock
// Senza annotazioni (tipi inferiti)
fn greet(name) {
    return "Ciao, " + name;
}

// Con annotazioni (verificate a runtime)
fn divide(a: i32, b: i32): f64 {
    return a / b;
}
```

## Oggetti

### Letterali oggetto

```hemlock
let obj = {
    field1: value1,
    field2: value2,
};
```

**Esempio:**
```hemlock
let person = {
    name: "Alice",
    age: 30,
    active: true,
};
```

### Metodi

```hemlock
let obj = {
    method: fn() {
        self.field = value;
    },
};
```

**Esempio:**
```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    },
};
```

### Definizioni di tipo

```hemlock
define TypeName {
    field1: type1,
    field2: type2,
    optional_field?: default_value,
}
```

**Esempio:**
```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,
}
```

## Array

### Letterali array

```hemlock
let arr = [elemento1, elemento2, elemento3];
```

**Esempio:**
```hemlock
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, "due", true, null];
let empty = [];
```

### Indicizzazione array

```hemlock
let arr = [10, 20, 30];
print(arr[0]);   // 10
arr[1] = 99;     // Modificare un elemento
```

## Gestione degli errori

### Try/Catch

```hemlock
try {
    // codice rischioso
} catch (e) {
    // gestire l'errore
}
```

### Try/Finally

```hemlock
try {
    // codice rischioso
} finally {
    // viene sempre eseguito
}
```

### Try/Catch/Finally

```hemlock
try {
    // codice rischioso
} catch (e) {
    // gestire l'errore
} finally {
    // pulizia
}
```

### Throw

```hemlock
throw espressione;
```

**Esempio:**
```hemlock
if (x < 0) {
    throw "x deve essere positivo";
}
```

### Panic

```hemlock
panic(messaggio);
```

**Esempio:**
```hemlock
panic("errore irreversibile");
```

## Moduli (sperimentale)

### Istruzioni di export

```hemlock
export fn function_name() { }
export const CONSTANT = value;
export let variable = value;
export { name1, name2 };
```

### Istruzioni di import

```hemlock
import { name1, name2 } from "./module.hml";
import * as namespace from "./module.hml";
import { name as alias } from "./module.hml";
```

## Async (sperimentale)

### Funzioni asincrone

```hemlock
async fn function_name(params): return_type {
    // corpo
}
```

### Spawn/Join

```hemlock
let task = spawn(async_function, arg1, arg2);
let result = join(task);
```

### Canali (Channels)

```hemlock
let ch = channel(capacity);
ch.send(value);
let value = ch.recv();
ch.close();
```

## FFI (Interfaccia di funzione esterna)

### Importare una libreria condivisa

```hemlock
import "library_name.so";
```

### Dichiarare una funzione esterna

```hemlock
extern fn function_name(param: type): return_type;
```

**Esempio:**
```hemlock
import "libc.so.6";
extern fn strlen(s: string): i32;
```

## Letterali

### Letterali interi

```hemlock
let decimal = 42;
let negative = -100;
let large = 5000000000;  // Automaticamente i64

// Esadecimale (prefisso 0x)
let hex = 0xDEADBEEF;
let hex2 = 0xFF;

// Binario (prefisso 0b)
let bin = 0b1010;
let bin2 = 0b11110000;

// Ottale (prefisso 0o)
let oct = 0o777;
let oct2 = 0O123;

// Separatori numerici per la leggibilita
let million = 1_000_000;
let hex_sep = 0xFF_FF_FF;
let bin_sep = 0b1111_0000_1010_0101;
let oct_sep = 0o77_77;
```

### Letterali in virgola mobile

```hemlock
let f = 3.14;
let e = 2.71828;
let sci = 1.5e-10;       // Notazione scientifica
let sci2 = 2.5E+3;       // La E maiuscola funziona
let no_lead = .5;        // Senza zero iniziale (0.5)
let sep = 3.14_159_265;  // Separatori numerici
```

### Letterali stringa

```hemlock
let s = "ciao";
let escaped = "riga1\nriga2\ttabulazione";
let quote = "Ha detto \"ciao\"";

// Sequenze di escape esadecimali
let hex_esc = "\x48\x65\x6c\x6c\x6f";  // "Hello"

// Sequenze di escape Unicode
let emoji = "\u{1F600}";               // faccina sorridente
let heart = "\u{2764}";                // cuore
let mixed = "Ciao \u{1F30D}!";         // Ciao mondo!
```

**Sequenze di escape:**
- `\n` - nuova riga
- `\t` - tabulazione
- `\r` - ritorno a capo
- `\\` - barra rovesciata
- `\"` - virgolette doppie
- `\'` - virgolette singole
- `\0` - carattere nullo
- `\xNN` - escape esadecimale (2 cifre)
- `\u{XXXX}` - escape unicode (1-6 cifre)

### Letterali rune

```hemlock
let ch = 'A';
let emoji = 'rocket';
let escaped = '\n';
let unicode = '\u{1F680}';
let hex_rune = '\x41';      // 'A'
```

### Letterali booleani

```hemlock
let t = true;
let f = false;
```

### Letterale null

```hemlock
let nothing = null;
```

## Regole di scope

### Scope di blocco

Le variabili sono limitate al blocco contenitore piu vicino:

```hemlock
let x = 1;  // Scope esterno

if (true) {
    let x = 2;  // Scope interno (nasconde quello esterno)
    print(x);   // 2
}

print(x);  // 1
```

### Scope di funzione

Le funzioni creano il proprio scope:

```hemlock
let global = "global";

fn foo() {
    let local = "local";
    print(global);  // Puo leggere lo scope esterno
}

foo();
// print(local);  // ERRORE: 'local' non definito qui
```

### Scope delle closure

Le closure catturano le variabili dallo scope contenitore:

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;  // Cattura 'count'
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
```

## Spazi bianchi e formattazione

### Indentazione

Hemlock non impone un'indentazione specifica, ma sono raccomandati 4 spazi:

```hemlock
fn example() {
    if (true) {
        print("indentato");
    }
}
```

### Interruzioni di riga

Le istruzioni possono estendersi su piu righe:

```hemlock
let result =
    very_long_function_name(
        arg1,
        arg2,
        arg3
    );
```

## Istruzione Loop

La parola chiave `loop` fornisce una sintassi piu chiara per i cicli infiniti:

```hemlock
loop {
    // ... eseguire il lavoro
    if (done) {
        break;
    }
}
```

Questo e equivalente a `while (true)` ma rende l'intenzione piu chiara.

## Parole chiave riservate

Le seguenti parole chiave sono riservate in Hemlock:

```
let, const, fn, if, else, while, for, in, loop, break, continue,
return, true, false, null, typeof, import, export, from,
try, catch, finally, throw, panic, async, await, spawn, join,
detach, channel, define, switch, case, default, extern, self,
type, defer, enum, ref, buffer, Self
```

## Prossimi passi

- [Sistema dei tipi](#language-guide-types) - Scopri il sistema dei tipi di Hemlock
- [Flusso di controllo](#language-guide-control-flow) - Approfondisci le strutture di controllo
- [Funzioni](#language-guide-functions) - Padroneggia le funzioni e le closure
- [Gestione della memoria](#language-guide-memory) - Comprendi i puntatori e i buffer


--------------------------------------------------------------------------------
## Stringhe
--------------------------------------------------------------------------------

# Stringhe

Le stringhe Hemlock sono **sequenze mutabili di prima classe UTF-8** con supporto completo Unicode e un ricco set di metodi per l'elaborazione del testo. A differenza di molti linguaggi, le stringhe Hemlock sono mutabili e lavorano nativamente con i codepoint Unicode.

## Panoramica

```hemlock
let s = "ciao";
s[0] = 'C';             // muta con rune (ora "Ciao")
print(s.length);        // 4 (conteggio codepoint)
let c = s[0];           // restituisce rune (codepoint Unicode)
let msg = s + " mondo"; // concatenazione
let emoji = "ðŸš€";
print(emoji.length);    // 1 (un codepoint)
print(emoji.byte_length); // 4 (quattro byte UTF-8)
```

## Proprieta

Le stringhe Hemlock hanno queste caratteristiche chiave:

- **Codifica UTF-8** - Supporto completo Unicode (da U+0000 a U+10FFFF)
- **Mutabili** - A differenza delle stringhe Python, JavaScript e Java
- **Indicizzazione basata su codepoint** - Restituisce `rune` (codepoint Unicode), non byte
- **Allocate nell'heap** - Con tracciamento interno della capacita
- **Due proprieta di lunghezza**:
  - `.length` - Conteggio codepoint (numero di caratteri)
  - `.byte_length` - Conteggio byte (dimensione codifica UTF-8)

## Comportamento UTF-8

Tutte le operazioni sulle stringhe lavorano con i **codepoint** (caratteri), non con i byte:

```hemlock
let text = "CiaoðŸš€Mondo";
print(text.length);        // 10 (codepoint)
print(text.byte_length);   // 14 (byte, emoji e 4 byte)

// L'indicizzazione usa i codepoint
let c = text[0];           // 'C' (rune)
let rocket = text[4];      // 'ðŸš€' (rune)
```

**I caratteri multi-byte contano come uno:**
```hemlock
"Ciao".length;       // 4
"ðŸš€".length;         // 1 (una emoji)
"ä½ å¥½".length;       // 2 (due caratteri cinesi)
"cafe".length;       // 4 (e e un codepoint)
```

## Letterali stringa

```hemlock
// Stringhe di base
let s1 = "ciao";
let s2 = "mondo";

// Con sequenze di escape
let s3 = "Riga 1\nRiga 2\ttabulata";
let s4 = "Virgolette: \"Ciao\"";
let s5 = "Barra rovesciata: \\";

// Caratteri Unicode
let s6 = "ðŸš€ Emoji";
let s7 = "ä¸­æ–‡å­—ç¬¦";
```

## Stringhe template (Interpolazione di stringhe)

Usa i backtick per le stringhe template con espressioni incorporate:

```hemlock
let name = "Alice";
let age = 30;

// Interpolazione di base
let greeting = `Ciao, ${name}!`;           // "Ciao, Alice!"
let info = `${name} ha ${age} anni`;       // "Alice ha 30 anni"

// Espressioni nell'interpolazione
let x = 5;
let y = 10;
let sum = `${x} + ${y} = ${x + y}`;        // "5 + 10 = 15"

// Chiamate di metodo
let upper = `Nome: ${name.to_upper()}`;    // "Nome: ALICE"

// Oggetti annidati
let person = { name: "Bob", city: "Roma" };
let desc = `${person.name} vive a ${person.city}`;  // "Bob vive a Roma"

// Multi-riga (preserva le nuove righe)
let multi = `Riga 1
Riga 2
Riga 3`;
```

**Caratteristiche delle stringhe template:**
- Le espressioni dentro `${...}` vengono valutate e convertite in stringhe
- Qualsiasi espressione valida puo essere usata (variabili, chiamate di funzione, aritmetica)
- Le stringhe con backtick supportano le stesse sequenze di escape delle stringhe normali
- Utili per costruire stringhe dinamiche senza concatenazione

### Escape nelle stringhe template

Per includere un letterale `${` in una stringa template, esegui l'escape del simbolo del dollaro:

```hemlock
let price = 100;
let text = `Prezzo: \${price} o ${price}`;
// "Prezzo: ${price} o 100"

// Backtick letterale
let code = `Usa \` per le stringhe template`;
// "Usa ` per le stringhe template"
```

### Espressioni complesse

Le stringhe template possono contenere qualsiasi espressione valida:

```hemlock
// Espressioni tipo ternario
let age = 25;
let status = `Stato: ${age >= 18 ? "adulto" : "minore"}`;

// Accesso array
let items = ["mela", "banana", "ciliegia"];
let first = `Primo elemento: ${items[0]}`;

// Chiamate di funzione con argomenti
fn format_price(p) { return p + " euro"; }
let msg = `Totale: ${format_price(99.99)}`;  // "Totale: 99.99 euro"

// Chiamate di metodo concatenate
let name = "alice";
let formatted = `Ciao, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;
// "Ciao, Alice!"
```

### Stringhe template vs Concatenazione

Le stringhe template sono spesso piu pulite della concatenazione:

```hemlock
// Concatenazione (piu difficile da leggere)
let msg1 = "Ciao, " + name + "! Hai " + count + " messaggi.";

// Stringa template (piu facile da leggere)
let msg2 = `Ciao, ${name}! Hai ${count} messaggi.`;
```

## Indicizzazione e mutazione

### Lettura dei caratteri

L'indicizzazione restituisce una `rune` (codepoint Unicode):

```hemlock
let s = "Ciao";
let first = s[0];      // 'C' (rune)
let last = s[3];       // 'o' (rune)

// Esempio UTF-8
let emoji = "HiðŸš€!";
let rocket = emoji[2];  // 'ðŸš€' (rune all'indice codepoint 2)
```

### Scrittura dei caratteri

Le stringhe sono mutabili - puoi modificare i singoli caratteri:

```hemlock
let s = "ciao";
s[0] = 'C';            // Ora "Ciao"
s[3] = '!';            // Ora "Cia!"

// Con Unicode
let msg = "Vai!";
msg[0] = 'ðŸš€';         // Ora "ðŸš€ai!"
```

## Concatenazione

Usa `+` per concatenare le stringhe:

```hemlock
let greeting = "Ciao" + " " + "Mondo";  // "Ciao Mondo"

// Con variabili
let name = "Alice";
let msg = "Ciao, " + name + "!";  // "Ciao, Alice!"

// Con rune (vedi documentazione Rune)
let s = "Ciao" + '!';              // "Ciao!"
```

## Metodi stringa

Hemlock fornisce 19 metodi stringa per una manipolazione completa del testo.

### Sottostringa e Slicing

**`substr(start, length)`** - Estrae sottostringa per posizione e lunghezza:
```hemlock
let s = "ciao mondo";
let sub = s.substr(5, 5);       // "mondo" (inizia a 5, lunghezza 5)
let first = s.substr(0, 4);     // "ciao"

// Esempio UTF-8
let text = "HiðŸš€!";
let emoji = text.substr(2, 1);  // "ðŸš€" (posizione 2, lunghezza 1)
```

**`slice(start, end)`** - Estrae sottostringa per intervallo (end esclusivo):
```hemlock
let s = "ciao mondo";
let slice = s.slice(0, 4);      // "ciao" (indice da 0 a 3)
let slice2 = s.slice(5, 10);    // "mondo"
```

**Differenza:**
- `substr(start, length)` - Usa parametro lunghezza
- `slice(start, end)` - Usa indice finale (esclusivo)

### Ricerca e Trova

**`find(needle)`** - Trova la prima occorrenza:
```hemlock
let s = "ciao mondo";
let pos = s.find("mondo");      // 5 (indice della prima occorrenza)
let pos2 = s.find("foo");       // -1 (non trovato)
let pos3 = s.find("o");         // 3 (primo 'o')
```

**`contains(needle)`** - Verifica se la stringa contiene la sottostringa:
```hemlock
let s = "ciao mondo";
let has = s.contains("mondo");  // true
let has2 = s.contains("foo");   // false
```

### Split e Trim

**`split(delimiter)`** - Divide in array di stringhe:
```hemlock
let csv = "mela,banana,ciliegia";
let parts = csv.split(",");     // ["mela", "banana", "ciliegia"]

let words = "uno due tre".split(" ");  // ["uno", "due", "tre"]

// Delimitatore vuoto divide per carattere
let chars = "abc".split("");    // ["a", "b", "c"]
```

**`trim()`** - Rimuove spazi bianchi iniziali/finali:
```hemlock
let s = "  ciao  ";
let clean = s.trim();           // "ciao"

let s2 = "\t\ntesto\n\t";
let clean2 = s2.trim();         // "testo"
```

### Conversione maiuscole/minuscole

**`to_upper()`** - Converte in maiuscolo:
```hemlock
let s = "ciao mondo";
let upper = s.to_upper();       // "CIAO MONDO"

// Preserva non-ASCII
let s2 = "cafe";
let upper2 = s2.to_upper();     // "CAFE"
```

**`to_lower()`** - Converte in minuscolo:
```hemlock
let s = "CIAO MONDO";
let lower = s.to_lower();       // "ciao mondo"
```

### Controllo prefisso/suffisso

**`starts_with(prefix)`** - Verifica se inizia con il prefisso:
```hemlock
let s = "ciao mondo";
let starts = s.starts_with("ciao");  // true
let starts2 = s.starts_with("mondo"); // false
```

**`ends_with(suffix)`** - Verifica se finisce con il suffisso:
```hemlock
let s = "ciao mondo";
let ends = s.ends_with("mondo");      // true
let ends2 = s.ends_with("ciao");      // false
```

### Sostituzione

**`replace(old, new)`** - Sostituisce la prima occorrenza:
```hemlock
let s = "ciao mondo";
let s2 = s.replace("mondo", "amico");      // "ciao amico"

let s3 = "foo foo foo";
let s4 = s3.replace("foo", "bar");         // "bar foo foo" (solo il primo)
```

**`replace_all(old, new)`** - Sostituisce tutte le occorrenze:
```hemlock
let s = "foo foo foo";
let s2 = s.replace_all("foo", "bar");      // "bar bar bar"

let s3 = "ciao mondo, mondo!";
let s4 = s3.replace_all("mondo", "hemlock"); // "ciao hemlock, hemlock!"
```

### Ripetizione

**`repeat(count)`** - Ripete la stringa n volte:
```hemlock
let s = "ah";
let laugh = s.repeat(3);        // "ahahah"

let line = "=".repeat(40);      // "========================================"
```

### Accesso a caratteri e byte

**`char_at(index)`** - Ottiene il codepoint Unicode all'indice (restituisce rune):
```hemlock
let s = "ciao";
let char = s.char_at(0);        // 'c' (rune)

// Esempio UTF-8
let emoji = "ðŸš€";
let rocket = emoji.char_at(0);  // Restituisce rune U+1F680
```

**`chars()`** - Converte in array di rune (codepoint):
```hemlock
let s = "ciao";
let chars = s.chars();          // ['c', 'i', 'a', 'o'] (array di rune)

// Esempio UTF-8
let text = "HiðŸš€";
let chars2 = text.chars();      // ['H', 'i', 'ðŸš€']
```

**`byte_at(index)`** - Ottiene il valore byte all'indice (restituisce u8):
```hemlock
let s = "ciao";
let byte = s.byte_at(0);        // 99 (valore ASCII di 'c')

// Esempio UTF-8
let emoji = "ðŸš€";
let first_byte = emoji.byte_at(0);  // 240 (primo byte UTF-8)
```

**`bytes()`** - Converte in array di byte (valori u8):
```hemlock
let s = "ciao";
let bytes = s.bytes();          // [99, 105, 97, 111] (array di u8)

// Esempio UTF-8
let emoji = "ðŸš€";
let bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 byte UTF-8)
```

**`to_bytes()`** - Converte in buffer per accesso a basso livello:
```hemlock
let s = "ciao";
let buf = s.to_bytes();         // Restituisce buffer con byte UTF-8
print(buf.length);              // 4
free(buf);                      // Ricorda di liberare
```

## Concatenamento dei metodi

Tutti i metodi stringa restituiscono nuove stringhe, consentendo il concatenamento:

```hemlock
let result = "  Ciao Mondo  "
    .trim()
    .to_lower()
    .replace("mondo", "hemlock");  // "ciao hemlock"

let processed = "foo,bar,baz"
    .split(",")
    .join(" | ")
    .to_upper();                    // "FOO | BAR | BAZ"
```

## Riferimento completo dei metodi

| Metodo | Parametri | Restituisce | Descrizione |
|--------|-----------|-------------|-------------|
| `substr(start, length)` | i32, i32 | string | Estrae sottostringa per posizione e lunghezza |
| `slice(start, end)` | i32, i32 | string | Estrae sottostringa per intervallo (end esclusivo) |
| `find(needle)` | string | i32 | Trova prima occorrenza (-1 se non trovato) |
| `contains(needle)` | string | bool | Verifica se contiene sottostringa |
| `split(delimiter)` | string | array | Divide in array di stringhe |
| `trim()` | - | string | Rimuove spazi bianchi iniziali/finali |
| `to_upper()` | - | string | Converte in maiuscolo |
| `to_lower()` | - | string | Converte in minuscolo |
| `starts_with(prefix)` | string | bool | Verifica se inizia con prefisso |
| `ends_with(suffix)` | string | bool | Verifica se finisce con suffisso |
| `replace(old, new)` | string, string | string | Sostituisce prima occorrenza |
| `replace_all(old, new)` | string, string | string | Sostituisce tutte le occorrenze |
| `repeat(count)` | i32 | string | Ripete stringa n volte |
| `char_at(index)` | i32 | rune | Ottiene codepoint all'indice |
| `byte_at(index)` | i32 | u8 | Ottiene valore byte all'indice |
| `chars()` | - | array | Converte in array di rune |
| `bytes()` | - | array | Converte in array di byte u8 |
| `to_bytes()` | - | buffer | Converte in buffer (deve essere liberato) |

## Esempi

### Esempio: Elaborazione del testo

```hemlock
fn process_input(text: string): string {
    return text
        .trim()
        .to_lower()
        .replace_all("  ", " ");  // Normalizza gli spazi bianchi
}

let input = "  CIAO   MONDO  ";
let clean = process_input(input);  // "ciao mondo"
```

### Esempio: Parser CSV

```hemlock
fn parse_csv_line(line: string): array {
    let trimmed = line.trim();
    let fields = trimmed.split(",");

    let result = [];
    let i = 0;
    while (i < fields.length) {
        result.push(fields[i].trim());
        i = i + 1;
    }

    return result;
}

let csv = "mela, banana , ciliegia";
let fields = parse_csv_line(csv);  // ["mela", "banana", "ciliegia"]
```

### Esempio: Contatore di parole

```hemlock
fn count_words(text: string): i32 {
    let words = text.trim().split(" ");
    return words.length;
}

let sentence = "La volpe veloce e marrone";
let count = count_words(sentence);  // 5
```

### Esempio: Validazione stringa

```hemlock
fn is_valid_email(email: string): bool {
    if (!email.contains("@")) {
        return false;
    }

    if (!email.contains(".")) {
        return false;
    }

    if (email.starts_with("@") || email.ends_with("@")) {
        return false;
    }

    return true;
}

print(is_valid_email("user@example.com"));  // true
print(is_valid_email("invalid"));            // false
```

## Gestione della memoria

Le stringhe sono allocate nell'heap con conteggio interno dei riferimenti:

- **Creazione**: Allocate nell'heap con tracciamento della capacita
- **Concatenazione**: Crea nuova stringa (stringhe vecchie invariate)
- **Metodi**: La maggior parte dei metodi restituisce nuove stringhe
- **Ciclo di vita**: Le stringhe sono conteggiate per riferimento e liberate automaticamente quando lo scope termina

**Pulizia automatica:**
```hemlock
fn create_strings() {
    let s = "ciao";
    let s2 = s + " mondo";  // Nuova allocazione
}  // Sia s che s2 vengono liberati automaticamente quando la funzione ritorna
```

**Nota:** Le variabili stringa locali vengono pulite automaticamente quando escono dallo scope. Usa `free()` solo per la pulizia anticipata prima della fine dello scope o per dati globali/a lunga durata. Vedi [Gestione della memoria](memory.md#conteggio-interno-dei-riferimenti) per i dettagli.

## Buone pratiche

1. **Usa l'indicizzazione per codepoint** - Le stringhe usano posizioni codepoint, non offset di byte
2. **Testa con Unicode** - Testa sempre le operazioni sulle stringhe con caratteri multi-byte
3. **Preferisci operazioni immutabili** - Usa metodi che restituiscono nuove stringhe piuttosto che la mutazione
4. **Controlla i limiti** - L'indicizzazione delle stringhe non controlla i limiti (restituisce null/errore su indice non valido)
5. **Normalizza l'input** - Usa `trim()` e `to_lower()` per l'input utente

## Trabocchetti comuni

### Trabocchetto: Confusione byte vs. codepoint

```hemlock
let emoji = "ðŸš€";
print(emoji.length);        // 1 (codepoint)
print(emoji.byte_length);   // 4 (byte)

// Non mescolare operazioni su byte e codepoint
let byte = emoji.byte_at(0);  // 240 (primo byte)
let char = emoji.char_at(0);  // 'ðŸš€' (codepoint completo)
```

### Trabocchetto: Sorprese nella mutazione

```hemlock
let s1 = "ciao";
let s2 = s1;       // Copia superficiale
s1[0] = 'C';       // Muta s1
print(s2);         // Ancora "ciao" (le stringhe sono tipi valore)
```

## Argomenti correlati

- [Rune](#language-guide-runes) - Tipo codepoint Unicode usato nell'indicizzazione delle stringhe
- [Array](#language-guide-arrays) - I metodi stringa spesso restituiscono o lavorano con array
- [Tipi](#language-guide-types) - Dettagli sul tipo stringa e conversioni

## Vedi anche

- **Codifica UTF-8**: Vedi sezione "Strings" di CLAUDE.md
- **Conversioni di tipo**: Vedi [Tipi](#language-guide-types) per le conversioni di stringa
- **Memoria**: Vedi [Memoria](#language-guide-memory) per i dettagli sull'allocazione delle stringhe


--------------------------------------------------------------------------------
## Tipi
--------------------------------------------------------------------------------

# Sistema dei tipi

Hemlock presenta un **sistema di tipi dinamico** con annotazioni di tipo opzionali e verifica dei tipi a runtime.

---

## Guida alla selezione dei tipi: Quale tipo devo usare?

**Nuovo ai tipi?** Inizia qui. Se hai familiarita con i sistemi di tipi, vai a [Filosofia](#filosofia).

### La risposta breve

**Lascia che Hemlock lo capisca da solo:**

```hemlock
let count = 42;        // Hemlock sa che questo e un intero
let price = 19.99;     // Hemlock sa che questo e un decimale
let name = "Alice";    // Hemlock sa che questo e testo
let active = true;     // Hemlock sa che questo e si/no
```

Hemlock sceglie automaticamente il tipo giusto per i tuoi valori. Non *devi* specificare i tipi.

### Quando aggiungere annotazioni di tipo

Aggiungi i tipi quando vuoi:

1. **Essere specifico sulla dimensione** - `i8` vs `i64` conta per la memoria o FFI
2. **Documentare il codice** - I tipi mostrano cosa si aspetta una funzione
3. **Catturare errori presto** - Hemlock verifica i tipi a runtime

```hemlock
// Senza tipi (funziona bene):
fn add(a, b) {
    return a + b;
}

// Con tipi (piu esplicito):
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Riferimento rapido: Scelta dei tipi numerici

| Cosa stai memorizzando | Tipo suggerito | Esempio |
|------------------------|----------------|---------|
| Numeri interi normali | `i32` (predefinito) | `let count = 42;` |
| Numeri molto grandi | `i64` | `let population = 8000000000;` |
| Conteggi mai negativi | `u32` | `let items: u32 = 100;` |
| Byte (0-255) | `u8` | `let pixel: u8 = 255;` |
| Decimali/frazioni | `f64` (predefinito) | `let price = 19.99;` |
| Decimali critici per le prestazioni | `f32` | `let x: f32 = 1.5;` |

### Riferimento rapido: Tutti i tipi

| Categoria | Tipi | Quando usare |
|-----------|------|--------------|
| **Numeri interi** | `i8`, `i16`, `i32`, `i64` | Conteggi, ID, eta, ecc. |
| **Numeri solo positivi** | `u8`, `u16`, `u32`, `u64` | Byte, dimensioni, lunghezze di array |
| **Decimali** | `f32`, `f64` | Denaro, misurazioni, matematica |
| **Si/No** | `bool` | Flag, condizioni |
| **Testo** | `string` | Nomi, messaggi, qualsiasi testo |
| **Singolo carattere** | `rune` | Singole lettere, emoji |
| **Liste** | `array` | Collezioni di valori |
| **Campi con nome** | `object` | Raggruppamento di dati correlati |
| **Memoria raw** | `ptr`, `buffer` | Programmazione a basso livello |
| **Nulla** | `null` | Assenza di un valore |

### Scenari comuni

**"Ho solo bisogno di un numero"**
```hemlock
let x = 42;  // Fatto! Hemlock sceglie i32
```

**"Ho bisogno di decimali"**
```hemlock
let price = 19.99;  // Fatto! Hemlock sceglie f64
```

**"Sto lavorando con byte (file, rete)"**
```hemlock
let byte: u8 = 255;  // Intervallo 0-255
```

**"Ho bisogno di numeri veramente grandi"**
```hemlock
let big = 9000000000000;  // Hemlock sceglie automaticamente i64 (> max i32)
// Oppure sii esplicito:
let big: i64 = 9000000000000;
```

**"Sto memorizzando denaro"**
```hemlock
// Opzione 1: Float (semplice, ma ha limiti di precisione)
let price: f64 = 19.99;

// Opzione 2: Memorizza come centesimi (piu preciso)
let price_cents: i32 = 1999;  // 19.99 euro come centesimi interi
```

**"Sto passando dati al codice C (FFI)"**
```hemlock
// Fai corrispondere esattamente i tipi C
let c_int: i32 = 100;      // C 'int'
let c_long: i64 = 100;     // C 'long' (su 64-bit)
let c_char: u8 = 65;       // C 'char'
let c_double: f64 = 3.14;  // C 'double'
```

### Cosa succede quando i tipi si mescolano?

Quando combini tipi diversi, Hemlock promuove al tipo "piu grande":

```hemlock
let a: i32 = 10;
let b: f64 = 2.5;
let result = a + b;  // result e f64 (12.5)
// L'intero e diventato automaticamente un decimale
```

**Regola generale:** I float "vincono" sempre - mescolare qualsiasi intero con un float ti da un float.

### Errori di tipo

Se provi a usare il tipo sbagliato, Hemlock te lo dice a runtime:

```hemlock
let age: i32 = "trenta";  // ERRORE: tipo non corrispondente - atteso i32, ottenuto string
```

Per convertire i tipi, usa le funzioni costruttore di tipo:

```hemlock
let text = "42";
let number = i32(text);   // Analizza stringa in intero: 42
let back = text + "";     // Gia una stringa
```

---

## Filosofia

- **Dinamico per impostazione predefinita** - Ogni valore ha un tag di tipo a runtime
- **Tipizzato per scelta** - Le annotazioni di tipo opzionali impongono controlli a runtime
- **Conversioni esplicite** - Le conversioni implicite seguono regole di promozione chiare
- **Onesto sui tipi** - `typeof()` dice sempre la verita

## Tipi primitivi

### Tipi interi

**Interi con segno:**
```hemlock
let tiny: i8 = 127;              // 8-bit  (-128 a 127)
let small: i16 = 32767;          // 16-bit (-32768 a 32767)
let normal: i32 = 2147483647;    // 32-bit (predefinito)
let large: i64 = 9223372036854775807;  // 64-bit
```

**Interi senza segno:**
```hemlock
let byte: u8 = 255;              // 8-bit  (0 a 255)
let word: u16 = 65535;           // 16-bit (0 a 65535)
let dword: u32 = 4294967295;     // 32-bit (0 a 4294967295)
let qword: u64 = 18446744073709551615;  // 64-bit
```

**Alias di tipo:**
```hemlock
let i: integer = 42;   // Alias per i32
let b: byte = 255;     // Alias per u8
```

### Tipi in virgola mobile

```hemlock
let f: f32 = 3.14159;        // float 32-bit
let d: f64 = 2.718281828;    // float 64-bit (predefinito)
let n: number = 1.618;       // Alias per f64
```

### Tipo booleano

```hemlock
let flag: bool = true;
let active: bool = false;
```

### Tipo stringa

```hemlock
let text: string = "Ciao, Mondo!";
let empty: string = "";
```

Le stringhe sono **mutabili**, **codificate UTF-8** e **allocate nell'heap**.

Vedi [Stringhe](#language-guide-strings) per i dettagli completi.

### Tipo rune

```hemlock
let ch: rune = 'A';
let emoji: rune = 'ðŸš€';
let newline: rune = '\n';
let unicode: rune = '\u{1F680}';
```

Le rune rappresentano **codepoint Unicode** (da U+0000 a U+10FFFF).

Vedi [Rune](#language-guide-runes) per i dettagli completi.

### Tipo null

```hemlock
let nothing = null;
let uninitialized: string = null;
```

`null` e un tipo proprio con un singolo valore.

## Tipi composti

### Tipo array

```hemlock
let numbers: array = [1, 2, 3, 4, 5];
let mixed = [1, "due", true, null];  // Tipi misti consentiti
let empty: array = [];
```

Vedi [Array](#language-guide-arrays) per i dettagli completi.

### Tipo oggetto

```hemlock
let obj: object = { x: 10, y: 20 };
let person = { name: "Alice", age: 30 };
```

Vedi [Oggetti](#language-guide-objects) per i dettagli completi.

### Tipi puntatore

**Puntatore raw:**
```hemlock
let p: ptr = alloc(64);
// Nessun controllo dei limiti, gestione manuale del ciclo di vita
free(p);
```

**Buffer sicuro:**
```hemlock
let buf: buffer = buffer(64);
// Controllo dei limiti, tiene traccia di lunghezza e capacita
free(buf);
```

Vedi [Gestione della memoria](#language-guide-memory) per i dettagli completi.

## Tipi enum

Gli enum definiscono un insieme di costanti con nome:

### Enum di base

```hemlock
enum Color {
    RED,
    GREEN,
    BLUE
}

let c = Color.RED;
print(c);              // 0
print(typeof(c));      // "Color"

// Confronto
if (c == Color.RED) {
    print("E rosso!");
}

// Switch su enum
switch (c) {
    case Color.RED:
        print("Stop");
        break;
    case Color.GREEN:
        print("Vai");
        break;
    case Color.BLUE:
        print("Blu?");
        break;
}
```

### Enum con valori

Gli enum possono avere valori interi espliciti:

```hemlock
enum Status {
    OK = 0,
    ERROR = 1,
    PENDING = 2
}

print(Status.OK);      // 0
print(Status.ERROR);   // 1

enum HttpCode {
    OK = 200,
    NOT_FOUND = 404,
    SERVER_ERROR = 500
}

let code = HttpCode.NOT_FOUND;
print(code);           // 404
```

### Valori auto-incrementanti

Senza valori espliciti, gli enum auto-incrementano da 0:

```hemlock
enum Priority {
    LOW,       // 0
    MEDIUM,    // 1
    HIGH,      // 2
    CRITICAL   // 3
}

// Puoi mescolare valori espliciti e automatici
enum Level {
    DEBUG = 10,
    INFO,      // 11
    WARN,      // 12
    ERROR = 50,
    FATAL      // 51
}
```

### Pattern di utilizzo degli enum

```hemlock
// Come parametri di funzione
fn set_priority(p: Priority) {
    if (p == Priority.CRITICAL) {
        print("Urgente!");
    }
}

set_priority(Priority.HIGH);

// Negli oggetti
define Task {
    name: string,
    priority: Priority
}

let task: Task = {
    name: "Correggere bug",
    priority: Priority.HIGH
};
```

## Tipi speciali

### Tipo file

```hemlock
let f: file = open("data.txt", "r");
f.close();
```

Rappresenta un handle di file aperto.

### Tipo task

```hemlock
async fn compute(): i32 { return 42; }
let task = spawn(compute);
let result: i32 = join(task);
```

Rappresenta un handle di task asincrono.

### Tipo channel

```hemlock
let ch: channel = channel(10);
ch.send(42);
let value = ch.recv();
```

Rappresenta un canale di comunicazione tra task.

### Tipo void

```hemlock
extern fn exit(code: i32): void;
```

Usato per funzioni che non restituiscono un valore (solo FFI).

## Inferenza di tipo

### Inferenza dei letterali interi

Hemlock inferisce i tipi interi in base all'intervallo di valori:

```hemlock
let a = 42;              // i32 (entra in 32-bit)
let b = 5000000000;      // i64 (> max i32)
let c = 128;             // i32
let d: u8 = 128;         // u8 (annotazione esplicita)
```

**Regole:**
- Valori nell'intervallo i32 (da -2147483648 a 2147483647): inferiti come `i32`
- Valori fuori dall'intervallo i32 ma dentro i64: inferiti come `i64`
- Usa annotazioni esplicite per altri tipi (i8, i16, u8, u16, u32, u64)

### Inferenza dei letterali float

```hemlock
let x = 3.14;        // f64 (predefinito)
let y: f32 = 3.14;   // f32 (esplicito)
```

### Notazione scientifica

Hemlock supporta la notazione scientifica per i letterali numerici:

```hemlock
let a = 1e10;        // 10000000000.0 (f64)
let b = 1e-12;       // 0.000000000001 (f64)
let c = 3.14e2;      // 314.0 (f64)
let d = 2.5e-3;      // 0.0025 (f64)
let e = 1E10;        // Maiuscolo/minuscolo irrilevante
let f = 1e+5;        // Esponente positivo esplicito
```

**Nota:** Qualsiasi letterale che usa la notazione scientifica e sempre inferito come `f64`.

### Altra inferenza di tipo

```hemlock
let s = "ciao";      // string
let ch = 'A';        // rune
let flag = true;     // bool
let arr = [1, 2, 3]; // array
let obj = { x: 10 }; // object
let nothing = null;  // null
```

## Annotazioni di tipo

### Annotazioni di variabile

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let name: string = "Alice";
```

### Annotazioni dei parametri di funzione

```hemlock
fn greet(name: string, age: i32) {
    print("Ciao, " + name + "!");
}
```

### Annotazioni del tipo di ritorno delle funzioni

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Annotazioni di tipo oggetto (Duck Typing)

```hemlock
define Person {
    name: string,
    age: i32,
}

let p: Person = { name: "Bob", age: 25 };
```

## Verifica dei tipi

### Verifica dei tipi a runtime

Le annotazioni di tipo vengono verificate a **runtime**, non a tempo di compilazione:

```hemlock
let x: i32 = 42;     // OK
let y: i32 = 3.14;   // Errore runtime: tipo non corrispondente

fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 3);           // OK
add(5, "ciao");      // Errore runtime: tipo non corrispondente
```

### Query di tipo

Usa `typeof()` per verificare i tipi dei valori:

```hemlock
print(typeof(42));         // "i32"
print(typeof(3.14));       // "f64"
print(typeof("ciao"));     // "string"
print(typeof(true));       // "bool"
print(typeof(null));       // "null"
print(typeof([1, 2, 3]));  // "array"
print(typeof({ x: 10 }));  // "object"
```

## Conversioni di tipo

### Promozione di tipo implicita

Quando si mescolano tipi nelle operazioni, Hemlock promuove al tipo "superiore":

**Gerarchia di promozione (dal piu basso al piu alto):**
```
i8 â†’ i16 â†’ i32 â†’ u32 â†’ i64 â†’ u64 â†’ f32 â†’ f64
      â†‘     â†‘     â†‘
     u8    u16
```

**Il float vince sempre:**
```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // result e f64 (13.5)
```

**La dimensione maggiore vince:**
```hemlock
let a: i32 = 100;
let b: i64 = 200;
let sum = a + b;     // sum e i64 (300)
```

**Preservazione della precisione:** Quando si mescolano interi a 64-bit con f32, Hemlock promuove
a f64 per evitare perdita di precisione (f32 ha solo mantissa a 24-bit, insufficiente per i64/u64):
```hemlock
let big: i64 = 9007199254740993;
let small: f32 = 1.0;
let result = big + small;  // result e f64, non f32!
```

**Esempi:**
```hemlock
u8 + i32  â†’ i32
i32 + i64 â†’ i64
u32 + u64 â†’ u64
i32 + f32 â†’ f32    // f32 sufficiente per i32
i64 + f32 â†’ f64    // f64 necessario per preservare precisione i64
i64 + f64 â†’ f64
i8 + f64  â†’ f64
```

### Conversione di tipo esplicita

**Intero â†” Float:**
```hemlock
let i: i32 = 42;
let f: f64 = i;      // i32 â†’ f64 (42.0)

let x: f64 = 3.14;
let n: i32 = x;      // f64 â†’ i32 (3, troncato)
```

**Intero â†” Rune:**
```hemlock
let code: i32 = 65;
let ch: rune = code;  // i32 â†’ rune ('A')

let r: rune = 'Z';
let value: i32 = r;   // rune â†’ i32 (90)
```

**Rune â†’ Stringa:**
```hemlock
let ch: rune = 'ðŸš€';
let s: string = ch;   // rune â†’ string ("ðŸš€")
```

**u8 â†’ Rune:**
```hemlock
let b: u8 = 65;
let r: rune = b;      // u8 â†’ rune ('A')
```

### Funzioni costruttore di tipo

I nomi dei tipi possono essere usati come funzioni per convertire o analizzare valori:

**Analisi di stringhe in numeri:**
```hemlock
let n = i32("42");       // Analizza stringa in i32: 42
let f = f64("3.14159");  // Analizza stringa in f64: 3.14159
let b = bool("true");    // Analizza stringa in bool: true

// Tutti i tipi numerici supportati
let a = i8("-128");      // Analizza in i8
let c = u8("255");       // Analizza in u8
let d = i16("1000");     // Analizza in i16
let e = u16("50000");    // Analizza in u16
let g = i64("9000000000000"); // Analizza in i64
let h = u64("18000000000000"); // Analizza in u64
let j = f32("1.5");      // Analizza in f32
```

**Numeri esadecimali e negativi:**
```hemlock
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42
let bin = i32("0b1010"); // 10 (binario)
```

**Funzionano anche gli alias di tipo:**
```hemlock
let x = integer("100");  // Uguale a i32("100")
let y = number("1.5");   // Uguale a f64("1.5")
let z = byte("200");     // Uguale a u8("200")
```

**Conversione tra tipi numerici:**
```hemlock
let big = i64(42);           // i32 a i64
let truncated = i32(3.99);   // f64 a i32 (tronca a 3)
let promoted = f64(100);     // i32 a f64 (100.0)
let narrowed = i8(127);      // i32 a i8
```

**Le annotazioni di tipo eseguono coercizione numerica (ma NON analisi di stringhe):**
```hemlock
let f: f64 = 100;        // i32 a f64 via annotazione (OK)
let s: string = 'A';     // Rune a string via annotazione (OK)
let code: i32 = 'A';     // Rune a i32 via annotazione (ottiene codepoint, OK)

// L'analisi di stringhe richiede costruttori di tipo espliciti:
let n = i32("42");       // Usa costruttore di tipo per analisi stringa
// let x: i32 = "42";    // ERRORE - le annotazioni di tipo non analizzano stringhe
```

**Gestione degli errori:**
```hemlock
// Stringhe non valide generano errori quando si usano costruttori di tipo
let bad = i32("ciao");   // Errore runtime: impossibile analizzare "ciao" come i32
let overflow = u8("256"); // Errore runtime: 256 fuori intervallo per u8
```

**Analisi booleana:**
```hemlock
let t = bool("true");    // true
let f = bool("false");   // false
let bad = bool("si");    // Errore runtime: deve essere "true" o "false"
```

## Verifica degli intervalli

Le annotazioni di tipo impongono controlli di intervallo all'assegnazione:

```hemlock
let x: u8 = 255;    // OK
let y: u8 = 256;    // ERRORE: fuori intervallo per u8

let a: i8 = 127;    // OK
let b: i8 = 128;    // ERRORE: fuori intervallo per i8

let c: i64 = 2147483647;   // OK
let d: u64 = 4294967295;   // OK
let e: u64 = -1;           // ERRORE: u64 non puo essere negativo
```

## Esempi di promozione di tipo

### Tipi interi misti

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let sum = a + b;     // i32 (30)

let c: u8 = 100;
let d: u32 = 200;
let total = c + d;   // u32 (300)
```

### Intero + Float

```hemlock
let i: i32 = 5;
let f: f32 = 2.5;
let result = i * f;  // f32 (12.5)
```

### Espressioni complesse

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let c: f64 = 3.0;

let result = a + b * c;  // f64 (70.0)
// Valutazione: b * c â†’ f64(60.0)
//              a + f64(60.0) â†’ f64(70.0)
```

## Duck Typing (Oggetti)

Gli oggetti usano il **typing strutturale** (duck typing):

```hemlock
define Person {
    name: string,
    age: i32,
}

// OK: Ha tutti i campi richiesti
let p1: Person = { name: "Alice", age: 30 };

// OK: Campi extra consentiti
let p2: Person = { name: "Bob", age: 25, city: "Milano" };

// ERRORE: Campo 'age' mancante
let p3: Person = { name: "Carol" };

// ERRORE: Tipo sbagliato per 'age'
let p4: Person = { name: "Dave", age: "trenta" };
```

**La verifica del tipo avviene all'assegnazione:**
- Verifica che tutti i campi richiesti siano presenti
- Verifica che i tipi dei campi corrispondano
- I campi extra sono consentiti e preservati
- Imposta il nome del tipo dell'oggetto per `typeof()`

## Campi opzionali

```hemlock
define Config {
    host: string,
    port: i32,
    debug?: false,     // Opzionale con default
    timeout?: i32,     // Opzionale, predefinito a null
}

let cfg1: Config = { host: "localhost", port: 8080 };
print(cfg1.debug);    // false (predefinito)
print(cfg1.timeout);  // null

let cfg2: Config = { host: "0.0.0.0", port: 80, debug: true };
print(cfg2.debug);    // true (sovrascritto)
```

## Alias di tipo

Hemlock supporta alias di tipo personalizzati usando la parola chiave `type`:

### Alias di tipo di base

```hemlock
// Alias di tipo semplice
type Integer = i32;
type Text = string;

// Uso dell'alias
let x: Integer = 42;
let msg: Text = "ciao";
```

### Alias di tipo funzione

```hemlock
// Alias di tipo funzione
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// Uso degli alias di tipo funzione
let cb: Callback = fn(n) { print(n); };
let isEven: Predicate = fn(n) { return n % 2 == 0; };
```

### Alias di tipo composto

```hemlock
// Combina piu define in un tipo
define HasName { name: string }
define HasAge { age: i32 }

type Person = HasName & HasAge;

let p: Person = { name: "Alice", age: 30 };
```

### Alias di tipo generico

```hemlock
// Alias di tipo generico
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };

// Uso degli alias generici
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
```

**Nota:** Gli alias di tipo sono trasparenti - `typeof()` restituisce il nome del tipo sottostante, non l'alias.

## Limitazioni del sistema dei tipi

Limitazioni attuali:

- **Nessun generico sulle funzioni** - Parametri di tipo delle funzioni non ancora supportati
- **Nessun tipo union** - Impossibile esprimere "A o B"
- **Nessun tipo nullable** - Tutti i tipi possono essere null (usa suffisso `?` per nullabilita esplicita)

**Nota:** Il compilatore (`hemlockc`) fornisce verifica dei tipi a tempo di compilazione. L'interprete esegue solo verifica dei tipi a runtime. Vedi la [documentazione del compilatore](#design-implementation) per i dettagli.

## Buone pratiche

### Quando usare le annotazioni di tipo

**USA le annotazioni quando:**
- Il tipo preciso conta (es. `u8` per valori byte)
- Documenti interfacce di funzione
- Imponi vincoli (es. controlli di intervallo)

```hemlock
fn hash(data: buffer, length: u32): u64 {
    // Implementazione
}
```

**NON usare le annotazioni quando:**
- Il tipo e ovvio dal letterale
- Dettagli di implementazione interni
- Cerimonia non necessaria

```hemlock
// Non necessario
let x: i32 = 42;

// Meglio
let x = 42;
```

### Pattern di sicurezza dei tipi

**Verifica prima dell'uso:**
```hemlock
if (typeof(value) == "i32") {
    // Sicuro usare come i32
}
```

**Valida gli argomenti delle funzioni:**
```hemlock
fn divide(a, b) {
    if (typeof(a) != "i32" || typeof(b) != "i32") {
        throw "gli argomenti devono essere interi";
    }
    if (b == 0) {
        throw "divisione per zero";
    }
    return a / b;
}
```

**Usa il duck typing per flessibilita:**
```hemlock
define Printable {
    toString: fn,
}

fn print_item(item: Printable) {
    print(item.toString());
}
```

## Prossimi passi

- [Stringhe](#language-guide-strings) - Tipo stringa UTF-8 e operazioni
- [Rune](#language-guide-runes) - Tipo codepoint Unicode
- [Array](#language-guide-arrays) - Tipo array dinamico
- [Oggetti](#language-guide-objects) - Letterali oggetto e duck typing
- [Memoria](#language-guide-memory) - Tipi puntatore e buffer



################################################################################
# ARGOMENTI AVANZATI
################################################################################

--------------------------------------------------------------------------------
## Argomenti da Riga di Comando
--------------------------------------------------------------------------------

# Argomenti da Riga di Comando in Hemlock

I programmi Hemlock possono accedere agli argomenti da riga di comando tramite un **array `args` built-in** che viene automaticamente popolato all'avvio del programma.

## Indice

- [Panoramica](#panoramica)
- [L'Array args](#larray-args)
- [Proprieta](#proprieta)
- [Pattern di Iterazione](#pattern-di-iterazione)
- [Casi d'Uso Comuni](#casi-duso-comuni)
- [Pattern di Parsing degli Argomenti](#pattern-di-parsing-degli-argomenti)
- [Migliori Pratiche](#migliori-pratiche)
- [Esempi Completi](#esempi-completi)

## Panoramica

L'array `args` fornisce accesso agli argomenti da riga di comando passati al tuo programma Hemlock:

- **Sempre disponibile** - Variabile globale built-in in tutti i programmi Hemlock
- **Nome script incluso** - `args[0]` contiene sempre il percorso/nome dello script
- **Array di stringhe** - Tutti gli argomenti sono stringhe
- **Indicizzato da zero** - Indicizzazione standard degli array (0, 1, 2, ...)

## L'Array args

### Struttura Base

```hemlock
// args[0] e sempre il nome del file script
// args[1] fino a args[n-1] sono gli argomenti effettivi
print(args[0]);        // "script.hml"
print(args.length);    // Numero totale di argomenti (incluso nome script)
```

### Esempio di Utilizzo

**Comando:**
```bash
./hemlock script.hml ciao mondo "test 123"
```

**In script.hml:**
```hemlock
print("Nome script: " + args[0]);     // "script.hml"
print("Totale args: " + typeof(args.length));  // "4"
print("Primo arg: " + args[1]);       // "ciao"
print("Secondo arg: " + args[2]);     // "mondo"
print("Terzo arg: " + args[3]);       // "test 123"
```

### Riferimento Indici

| Indice | Contiene | Valore Esempio |
|--------|----------|----------------|
| `args[0]` | Percorso/nome script | `"script.hml"` o `"./script.hml"` |
| `args[1]` | Primo argomento | `"ciao"` |
| `args[2]` | Secondo argomento | `"mondo"` |
| `args[3]` | Terzo argomento | `"test 123"` |
| ... | ... | ... |
| `args[n-1]` | Ultimo argomento | (varia) |

## Proprieta

### Sempre Presente

`args` e un array globale disponibile in **tutti** i programmi Hemlock:

```hemlock
// Nessun bisogno di dichiarare o importare
print(args.length);  // Funziona immediatamente
```

### Nome Script Incluso

`args[0]` contiene sempre il percorso/nome dello script:

```hemlock
print("In esecuzione: " + args[0]);
```

**Possibili valori per args[0]:**
- `"script.hml"` - Solo il nome del file
- `"./script.hml"` - Percorso relativo
- `"/home/utente/script.hml"` - Percorso assoluto
- Dipende da come lo script e stato invocato

### Tipo: Array di Stringhe

Tutti gli argomenti sono memorizzati come stringhe:

```hemlock
// Argomenti: ./hemlock script.hml 42 3.14 true

print(args[1]);  // "42" (stringa, non numero)
print(args[2]);  // "3.14" (stringa, non numero)
print(args[3]);  // "true" (stringa, non booleano)

// Converti se necessario:
let num = 42;  // Parsa manualmente se necessario
```

### Lunghezza Minima

Sempre almeno 1 (il nome dello script):

```hemlock
print(args.length);  // Minimo: 1
```

**Anche senza argomenti:**
```bash
./hemlock script.hml
```

```hemlock
// In script.hml:
print(args.length);  // 1 (solo nome script)
```

### Comportamento REPL

Nel REPL, `args.length` e 0 (array vuoto):

```hemlock
# Sessione REPL
> print(args.length);
0
```

## Pattern di Iterazione

### Iterazione Base

Salta `args[0]` (nome script) ed elabora gli argomenti effettivi:

```hemlock
let i = 1;
while (i < args.length) {
    print("Argomento " + typeof(i) + ": " + args[i]);
    i = i + 1;
}
```

**Output per: `./hemlock script.hml pippo pluto paperino`**
```
Argomento 1: pippo
Argomento 2: pluto
Argomento 3: paperino
```

### Iterazione For-In (Incluso Nome Script)

```hemlock
for (let arg in args) {
    print(arg);
}
```

**Output:**
```
script.hml
pippo
pluto
paperino
```

### Controllo del Conteggio Argomenti

```hemlock
if (args.length < 2) {
    print("Uso: " + args[0] + " <argomento>");
    // exit o return
} else {
    let arg = args[1];
    // elabora arg
}
```

### Elaborazione di Tutti gli Argomenti Tranne il Nome Script

```hemlock
let args_effettivi = args.slice(1, args.length);

for (let arg in args_effettivi) {
    print("Elaborazione: " + arg);
}
```

## Casi d'Uso Comuni

### 1. Elaborazione Semplice di Argomenti

Controllo per argomento richiesto:

```hemlock
if (args.length < 2) {
    print("Uso: " + args[0] + " <nomefile>");
} else {
    let nomefile = args[1];
    print("Elaborazione file: " + nomefile);
    // ... elabora file
}
```

**Utilizzo:**
```bash
./hemlock script.hml dati.txt
# Output: Elaborazione file: dati.txt
```

### 2. Argomenti Multipli

```hemlock
if (args.length < 3) {
    print("Uso: " + args[0] + " <input> <output>");
} else {
    let file_input = args[1];
    let file_output = args[2];

    print("Input: " + file_input);
    print("Output: " + file_output);

    // Elabora file...
}
```

**Utilizzo:**
```bash
./hemlock converti.hml input.txt output.txt
```

### 3. Numero Variabile di Argomenti

Elabora tutti gli argomenti forniti:

```hemlock
if (args.length < 2) {
    print("Uso: " + args[0] + " <file1> [file2] [file3] ...");
} else {
    print("Elaborazione " + typeof(args.length - 1) + " file:");

    let i = 1;
    while (i < args.length) {
        print("  " + args[i]);
        elabora_file(args[i]);
        i = i + 1;
    }
}
```

**Utilizzo:**
```bash
./hemlock batch.hml file1.txt file2.txt file3.txt
```

### 4. Messaggio di Aiuto

```hemlock
if (args.length < 2 || args[1] == "--help" || args[1] == "-h") {
    print("Uso: " + args[0] + " [OPZIONI] <file>");
    print("Opzioni:");
    print("  -h, --help     Mostra questo messaggio di aiuto");
    print("  -v, --verbose  Abilita output verboso");
} else {
    // Elabora normalmente
}
```

### 5. Validazione degli Argomenti

```hemlock
fn valida_file(nomefile: string): bool {
    // Controlla se il file esiste (esempio)
    return nomefile != "";
}

if (args.length < 2) {
    print("Errore: Nessun nome file fornito");
} else if (!valida_file(args[1])) {
    print("Errore: File non valido: " + args[1]);
} else {
    print("Elaborazione: " + args[1]);
}
```

## Pattern di Parsing degli Argomenti

### Argomenti con Nome (Flag)

Pattern semplice per argomenti con nome:

```hemlock
let verboso = false;
let file_output = "";
let file_input = "";

let i = 1;
while (i < args.length) {
    if (args[i] == "--verbose" || args[i] == "-v") {
        verboso = true;
    } else if (args[i] == "--output" || args[i] == "-o") {
        i = i + 1;
        if (i < args.length) {
            file_output = args[i];
        }
    } else {
        file_input = args[i];
    }
    i = i + 1;
}

if (verboso) {
    print("Modalita verbosa abilitata");
}
print("Input: " + file_input);
print("Output: " + file_output);
```

**Utilizzo:**
```bash
./hemlock script.hml --verbose --output out.txt input.txt
./hemlock script.hml -v -o out.txt input.txt
```

### Flag Booleani

```hemlock
let debug = false;
let verboso = false;
let forza = false;

let i = 1;
while (i < args.length) {
    if (args[i] == "--debug") {
        debug = true;
    } else if (args[i] == "--verbose") {
        verboso = true;
    } else if (args[i] == "--force") {
        forza = true;
    }
    i = i + 1;
}
```

### Argomenti con Valore

```hemlock
let file_config = "default.conf";
let porta = 8080;

let i = 1;
while (i < args.length) {
    if (args[i] == "--config") {
        i = i + 1;
        if (i < args.length) {
            file_config = args[i];
        }
    } else if (args[i] == "--port") {
        i = i + 1;
        if (i < args.length) {
            porta = 8080;  // Dovrebbe parsare la stringa in int
        }
    }
    i = i + 1;
}
```

### Argomenti Posizionali e con Nome Misti

```hemlock
let file_input = "";
let file_output = "";
let verboso = false;

let i = 1;
let posizionali = [];

while (i < args.length) {
    if (args[i] == "--verbose") {
        verboso = true;
    } else {
        // Tratta come argomento posizionale
        posizionali.push(args[i]);
    }
    i = i + 1;
}

// Assegna argomenti posizionali
if (posizionali.length > 0) {
    file_input = posizionali[0];
}
if (posizionali.length > 1) {
    file_output = posizionali[1];
}
```

### Funzione Helper per Parser di Argomenti

```hemlock
fn parsa_args() {
    let opzioni = {
        verboso: false,
        output: "",
        files: []
    };

    let i = 1;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--verbose" || arg == "-v") {
            opzioni.verboso = true;
        } else if (arg == "--output" || arg == "-o") {
            i = i + 1;
            if (i < args.length) {
                opzioni.output = args[i];
            }
        } else {
            // Argomento posizionale
            opzioni.files.push(arg);
        }

        i = i + 1;
    }

    return opzioni;
}

let opts = parsa_args();
print("Verboso: " + typeof(opts.verboso));
print("Output: " + opts.output);
print("File: " + typeof(opts.files.length));
```

## Migliori Pratiche

### 1. Controllare Sempre il Conteggio degli Argomenti

```hemlock
// Bene
if (args.length < 2) {
    print("Uso: " + args[0] + " <file>");
} else {
    elabora_file(args[1]);
}

// Male - potrebbe crashare se nessun argomento
elabora_file(args[1]);  // Errore se args.length == 1
```

### 2. Fornire Informazioni di Utilizzo

```hemlock
fn mostra_uso() {
    print("Uso: " + args[0] + " [OPZIONI] <file>");
    print("Opzioni:");
    print("  -h, --help     Mostra aiuto");
    print("  -v, --verbose  Output verboso");
}

if (args.length < 2) {
    mostra_uso();
}
```

### 3. Validare gli Argomenti

```hemlock
fn valida_args() {
    if (args.length < 2) {
        print("Errore: Argomento richiesto mancante");
        return false;
    }

    if (args[1] == "") {
        print("Errore: Argomento vuoto");
        return false;
    }

    return true;
}

if (!valida_args()) {
    // exit o mostra uso
}
```

### 4. Usare Nomi di Variabili Descrittivi

```hemlock
// Bene
let nome_file_input = args[1];
let nome_file_output = args[2];
let max_iterazioni = args[3];

// Male
let a = args[1];
let b = args[2];
let c = args[3];
```

### 5. Gestire Argomenti tra Virgolette con Spazi

La shell gestisce questo automaticamente:

```bash
./hemlock script.hml "file con spazi.txt"
```

```hemlock
print(args[1]);  // "file con spazi.txt"
```

### 6. Creare Oggetti Argomento

```hemlock
fn ottieni_args() {
    return {
        script: args[0],
        input: args[1],
        output: args[2]
    };
}

let argomenti = ottieni_args();
print("Input: " + argomenti.input);
```

## Esempi Completi

### Esempio 1: Elaboratore di File

```hemlock
// Uso: ./hemlock elabora.hml <input> <output>

fn mostra_uso() {
    print("Uso: " + args[0] + " <file_input> <file_output>");
}

if (args.length < 3) {
    mostra_uso();
} else {
    let input = args[1];
    let output = args[2];

    print("Elaborazione " + input + " -> " + output);

    // Elabora file
    let f_in = open(input, "r");
    let f_out = open(output, "w");

    try {
        let contenuto = f_in.read();
        let elaborato = contenuto.to_upper();  // Elaborazione di esempio
        f_out.write(elaborato);

        print("Fatto!");
    } finally {
        f_in.close();
        f_out.close();
    }
}
```

### Esempio 2: Elaboratore Batch di File

```hemlock
// Uso: ./hemlock batch.hml <file1> <file2> <file3> ...

if (args.length < 2) {
    print("Uso: " + args[0] + " <file1> [file2] [file3] ...");
} else {
    print("Elaborazione " + typeof(args.length - 1) + " file:");

    let i = 1;
    while (i < args.length) {
        let nomefile = args[i];
        print("  Elaborazione: " + nomefile);

        try {
            let f = open(nomefile, "r");
            let contenuto = f.read();
            f.close();

            // Elabora contenuto...
            print("    " + typeof(contenuto.length) + " byte");
        } catch (e) {
            print("    Errore: " + e);
        }

        i = i + 1;
    }

    print("Fatto!");
}
```

### Esempio 3: Parser di Argomenti Avanzato

```hemlock
// Uso: ./hemlock app.hml [OPZIONI] <files...>
// Opzioni:
//   --verbose, -v     Abilita output verboso
//   --output, -o FILE Imposta file di output
//   --help, -h        Mostra aiuto

fn parsa_argomenti() {
    let config = {
        verboso: false,
        output: "output.txt",
        aiuto: false,
        files: []
    };

    let i = 1;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--verbose" || arg == "-v") {
            config.verboso = true;
        } else if (arg == "--output" || arg == "-o") {
            i = i + 1;
            if (i < args.length) {
                config.output = args[i];
            } else {
                print("Errore: --output richiede un valore");
            }
        } else if (arg == "--help" || arg == "-h") {
            config.aiuto = true;
        } else if (arg.starts_with("--")) {
            print("Errore: Opzione sconosciuta: " + arg);
        } else {
            config.files.push(arg);
        }

        i = i + 1;
    }

    return config;
}

fn mostra_aiuto() {
    print("Uso: " + args[0] + " [OPZIONI] <files...>");
    print("Opzioni:");
    print("  --verbose, -v     Abilita output verboso");
    print("  --output, -o FILE Imposta file di output");
    print("  --help, -h        Mostra questo aiuto");
}

let config = parsa_argomenti();

if (config.aiuto) {
    mostra_aiuto();
} else if (config.files.length == 0) {
    print("Errore: Nessun file di input specificato");
    mostra_aiuto();
} else {
    if (config.verboso) {
        print("Modalita verbosa abilitata");
        print("File di output: " + config.output);
        print("File di input: " + typeof(config.files.length));
    }

    // Elabora file
    for (let file in config.files) {
        if (config.verboso) {
            print("Elaborazione: " + file);
        }
        // ... elabora file
    }
}
```

### Esempio 4: Strumento di Configurazione

```hemlock
// Uso: ./hemlock config.hml <azione> [argomenti]
// Azioni:
//   get <chiave>
//   set <chiave> <valore>
//   list

fn mostra_uso() {
    print("Uso: " + args[0] + " <azione> [argomenti]");
    print("Azioni:");
    print("  get <chiave>         Ottieni valore di configurazione");
    print("  set <chiave> <valore> Imposta valore di configurazione");
    print("  list                 Lista tutta la configurazione");
}

if (args.length < 2) {
    mostra_uso();
} else {
    let azione = args[1];

    if (azione == "get") {
        if (args.length < 3) {
            print("Errore: 'get' richiede una chiave");
        } else {
            let chiave = args[2];
            print("Ottenimento: " + chiave);
            // ... ottieni da config
        }
    } else if (azione == "set") {
        if (args.length < 4) {
            print("Errore: 'set' richiede chiave e valore");
        } else {
            let chiave = args[2];
            let valore = args[3];
            print("Impostazione " + chiave + " = " + valore);
            // ... imposta in config
        }
    } else if (azione == "list") {
        print("Lista di tutta la configurazione:");
        // ... lista config
    } else {
        print("Errore: Azione sconosciuta: " + azione);
        mostra_uso();
    }
}
```

## Riepilogo

Il supporto agli argomenti da riga di comando di Hemlock fornisce:

- Array `args` built-in disponibile globalmente
- Semplice accesso basato su array agli argomenti
- Nome script in `args[0]`
- Tutti gli argomenti come stringhe
- Metodi array disponibili (.length, .slice, ecc.)

Ricorda:
- Controllare sempre `args.length` prima di accedere agli elementi
- `args[0]` e il nome dello script
- Gli argomenti effettivi iniziano da `args[1]`
- Tutti gli argomenti sono stringhe - converti se necessario
- Fornire informazioni di utilizzo per strumenti user-friendly
- Validare gli argomenti prima dell'elaborazione

Pattern comuni:
- Argomenti posizionali semplici
- Argomenti con nome/flag (--flag)
- Argomenti con valore (--opzione valore)
- Messaggi di aiuto (--help)
- Validazione degli argomenti


--------------------------------------------------------------------------------
## Async e Concorrenza
--------------------------------------------------------------------------------

# Async e Concorrenza in Hemlock

Hemlock fornisce **concorrenza strutturata** con sintassi async/await, creazione di task e canali per la comunicazione. L'implementazione utilizza thread POSIX (pthread) per **VERO parallelismo multi-thread**.

## Indice

- [Panoramica](#panoramica)
- [Modello di Threading](#modello-di-threading)
- [Funzioni Async](#funzioni-async)
- [Creazione di Task](#creazione-di-task)
- [Canali](#canali)
- [Propagazione delle Eccezioni](#propagazione-delle-eccezioni)
- [Dettagli di Implementazione](#dettagli-di-implementazione)
- [Migliori Pratiche](#migliori-pratiche)
- [Caratteristiche di Prestazione](#caratteristiche-di-prestazione)
- [Limitazioni Attuali](#limitazioni-attuali)

## Panoramica

**Cosa significa:**
- **Thread del sistema operativo reali** - Ogni task creato viene eseguito su un pthread separato (thread POSIX)
- **Vero parallelismo** - I task vengono eseguiti simultaneamente su piu core della CPU
- **Schedulato dal kernel** - Lo scheduler del sistema operativo distribuisce i task sui core disponibili
- **Canali thread-safe** - Utilizza mutex pthread e variabili di condizione per la sincronizzazione

**Cosa NON e:**
- **NON green thread** - Non e multitasking cooperativo in spazio utente
- **NON coroutine async/await** - Non e un event loop single-thread come JavaScript/Python asyncio
- **NON concorrenza emulata** - Non e parallelismo simulato

Questo e lo **stesso modello di threading di C, C++ e Rust** quando si usano thread del sistema operativo. Si ottiene vera esecuzione parallela su piu core.

## Modello di Threading

### Threading 1:1

Hemlock utilizza un **modello di threading 1:1**, dove:
- Ogni task creato crea un thread dedicato del sistema operativo tramite `pthread_create()`
- Il kernel del sistema operativo schedula i thread sui core CPU disponibili
- Multitasking preemptivo - il sistema operativo puo interrompere e passare tra i thread
- **Nessun GIL** - A differenza di Python, non c'e un Global Interpreter Lock che limita il parallelismo

### Meccanismi di Sincronizzazione

- **Mutex** - I canali usano `pthread_mutex_t` per accesso thread-safe
- **Variabili di condizione** - send/recv bloccanti usano `pthread_cond_t` per attesa efficiente
- **Operazioni lock-free** - Le transizioni di stato dei task sono atomiche

## Funzioni Async

Le funzioni possono essere dichiarate come `async` per indicare che sono progettate per l'esecuzione concorrente:

```hemlock
async fn calcola(n: i32): i32 {
    let somma = 0;
    let i = 0;
    while (i < n) {
        somma = somma + i;
        i = i + 1;
    }
    return somma;
}
```

### Punti Chiave

- `async fn` dichiara una funzione asincrona
- Le funzioni async possono essere create come task concorrenti usando `spawn()`
- Le funzioni async possono anche essere chiamate direttamente (eseguite sincronamente nel thread corrente)
- Quando create con spawn, ogni task viene eseguito sul **proprio thread del sistema operativo** (non una coroutine!)
- La parola chiave `await` e riservata per uso futuro

### Esempio: Chiamata Diretta vs Spawn

```hemlock
async fn fattoriale(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * fattoriale(n - 1);
}

// Chiamata diretta - eseguita sincronamente
let risultato1 = fattoriale(5);  // 120

// Task creato - eseguito su thread separato
let task = spawn(fattoriale, 5);
let risultato2 = join(task);  // 120
```

## Creazione di Task

Usa `spawn()` per eseguire funzioni async **in parallelo su thread separati del sistema operativo**:

```hemlock
async fn fattoriale(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * fattoriale(n - 1);
}

// Crea piu task - questi vengono eseguiti IN PARALLELO su diversi core della CPU!
let t1 = spawn(fattoriale, 5);  // Thread 1
let t2 = spawn(fattoriale, 6);  // Thread 2
let t3 = spawn(fattoriale, 7);  // Thread 3

// Tutti e tre stanno calcolando simultaneamente in questo momento!

// Attendi i risultati
let f5 = join(t1);  // 120
let f6 = join(t2);  // 720
let f7 = join(t3);  // 5040
```

### Funzioni Built-in

#### spawn(funzione_async, arg1, arg2, ...)

Crea un nuovo task su un nuovo pthread, restituisce un handle del task.

**Parametri:**
- `funzione_async` - La funzione async da eseguire
- `arg1, arg2, ...` - Argomenti da passare alla funzione

**Restituisce:** Handle del task (valore opaco usato con `join()` o `detach()`)

**Esempio:**
```hemlock
async fn elabora(dati: string, conteggio: i32): i32 {
    // ... logica di elaborazione
    return conteggio * 2;
}

let task = spawn(elabora, "test", 42);
```

#### join(task)

Attende il completamento del task (blocca fino al termine del thread), restituisce il risultato.

**Parametri:**
- `task` - Handle del task restituito da `spawn()`

**Restituisce:** Il valore restituito dalla funzione async

**Esempio:**
```hemlock
let task = spawn(calcola, 1000);
let risultato = join(task);  // Blocca fino al completamento di calcola()
print(risultato);
```

**Importante:** Ogni task puo essere joinato solo una volta. Join successivi daranno errore.

#### detach(task)

Esecuzione fire-and-forget (il thread viene eseguito indipendentemente, join non consentito).

**Parametri:**
- `task` - Handle del task restituito da `spawn()`

**Restituisce:** `null`

**Esempio:**
```hemlock
async fn lavoro_in_background() {
    // Task in background a lunga esecuzione
    // ...
}

let task = spawn(lavoro_in_background);
detach(task);  // Il task viene eseguito indipendentemente, non si puo fare join
```

**Importante:** I task detached non possono essere joinati. Sia il pthread che la struttura Task vengono automaticamente puliti quando il task viene completato.

## Canali

I canali forniscono comunicazione thread-safe tra task usando un buffer limitato con semantica bloccante.

### Creazione di Canali

```hemlock
let ch = channel(10);  // Crea canale con dimensione buffer di 10
```

**Parametri:**
- `capacita` (i32) - Numero massimo di valori che il canale puo contenere

**Restituisce:** Oggetto canale

### Metodi del Canale

#### send(valore)

Invia valore al canale (blocca se pieno).

```hemlock
async fn produttore(ch, conteggio: i32) {
    let i = 0;
    while (i < conteggio) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

let ch = channel(10);
let task = spawn(produttore, ch, 5);
```

**Comportamento:**
- Se il canale ha spazio, il valore viene aggiunto immediatamente
- Se il canale e pieno, il mittente si blocca fino a quando lo spazio diventa disponibile
- Se il canale e chiuso, lancia un'eccezione

#### recv()

Riceve valore dal canale (blocca se vuoto).

```hemlock
async fn consumatore(ch, conteggio: i32): i32 {
    let somma = 0;
    let i = 0;
    while (i < conteggio) {
        let val = ch.recv();
        somma = somma + val;
        i = i + 1;
    }
    return somma;
}

let ch = channel(10);
let task = spawn(consumatore, ch, 5);
```

**Comportamento:**
- Se il canale ha valori, restituisce immediatamente il prossimo valore
- Se il canale e vuoto, il ricevitore si blocca fino a quando un valore e disponibile
- Se il canale e chiuso e vuoto, restituisce `null`

#### close()

Chiude il canale (recv su canale chiuso restituisce null).

```hemlock
ch.close();
```

**Comportamento:**
- Impedisce ulteriori operazioni `send()` (lanceranno eccezione)
- Permette alle operazioni `recv()` in sospeso di completarsi
- Una volta vuoto, `recv()` restituisce `null`

### Multiplexing con select()

La funzione `select()` permette di attendere su piu canali simultaneamente, restituendo quando qualsiasi canale ha dati disponibili.

**Firma:**
```hemlock
select(canali: array, timeout_ms?: i32): object | null
```

**Parametri:**
- `canali` - Array di valori canale
- `timeout_ms` (opzionale) - Timeout in millisecondi (-1 o omettere per attesa infinita)

**Restituisce:**
- `{ channel, value }` - Oggetto con il canale che aveva dati e il valore ricevuto
- `null` - Su timeout (se il timeout e stato specificato)

**Esempio:**
```hemlock
let ch1 = channel(1);
let ch2 = channel(1);

// Task produttori
spawn(fn() {
    sleep(100);
    ch1.send("dal canale 1");
});

spawn(fn() {
    sleep(50);
    ch2.send("dal canale 2");
});

// Attende il primo risultato (ch2 dovrebbe essere piu veloce)
let risultato = select([ch1, ch2]);
print(risultato.value);  // "dal canale 2"

// Attende il secondo risultato
let risultato2 = select([ch1, ch2]);
print(risultato2.value);  // "dal canale 1"
```

**Con timeout:**
```hemlock
let ch = channel(1);

// Nessun mittente, andra in timeout
let risultato = select([ch], 100);  // timeout 100ms
if (risultato == null) {
    print("Timeout scaduto!");
}
```

**Casi d'uso:**
- Attendere il piu veloce tra piu sorgenti di dati
- Implementare timeout sulle operazioni del canale
- Pattern di event loop con piu sorgenti di eventi
- Fan-in: unire piu canali in uno

**Pattern fan-in:**
```hemlock
fn fan_in(canali: array, output: channel) {
    while (true) {
        let risultato = select(canali);
        if (risultato == null) {
            break;  // Tutti i canali chiusi
        }
        output.send(risultato.value);
    }
    output.close();
}
```

### Esempio Completo Produttore-Consumatore

```hemlock
async fn produttore(ch, conteggio: i32) {
    let i = 0;
    while (i < conteggio) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

async fn consumatore(ch, conteggio: i32): i32 {
    let somma = 0;
    let i = 0;
    while (i < conteggio) {
        let val = ch.recv();
        somma = somma + val;
        i = i + 1;
    }
    return somma;
}

// Crea canale con dimensione buffer
let ch = channel(10);

// Crea produttore e consumatore
let p = spawn(produttore, ch, 5);
let c = spawn(consumatore, ch, 5);

// Attende il completamento
join(p);
let totale = join(c);  // 100 (0+10+20+30+40)
print(totale);
```

### Multi-Produttore, Multi-Consumatore

I canali possono essere condivisi in sicurezza tra piu produttori e consumatori:

```hemlock
async fn produttore(id: i32, ch, conteggio: i32) {
    let i = 0;
    while (i < conteggio) {
        ch.send(id * 100 + i);
        i = i + 1;
    }
}

async fn consumatore(id: i32, ch, conteggio: i32): i32 {
    let somma = 0;
    let i = 0;
    while (i < conteggio) {
        let val = ch.recv();
        somma = somma + val;
        i = i + 1;
    }
    return somma;
}

let ch = channel(20);

// Piu produttori
let p1 = spawn(produttore, 1, ch, 5);
let p2 = spawn(produttore, 2, ch, 5);

// Piu consumatori
let c1 = spawn(consumatore, 1, ch, 5);
let c2 = spawn(consumatore, 2, ch, 5);

// Attende tutti
join(p1);
join(p2);
let somma1 = join(c1);
let somma2 = join(c2);
print(somma1 + somma2);
```

## Propagazione delle Eccezioni

Le eccezioni lanciate nei task creati vengono propagate quando si fa join:

```hemlock
async fn operazione_rischiosa(deve_fallire: i32): i32 {
    if (deve_fallire == 1) {
        throw "Task fallito!";
    }
    return 42;
}

let t = spawn(operazione_rischiosa, 1);
try {
    let risultato = join(t);
} catch (e) {
    print("Catturato: " + e);  // "Catturato: Task fallito!"
}
```

### Pattern di Gestione delle Eccezioni

**Pattern 1: Gestire nel task**
```hemlock
async fn task_sicuro() {
    try {
        // operazione rischiosa
    } catch (e) {
        print("Errore nel task: " + e);
        return null;
    }
}

let task = spawn(task_sicuro);
join(task);  // Nessuna eccezione propagata
```

**Pattern 2: Propagare al chiamante**
```hemlock
async fn task_che_lancia() {
    throw "errore";
}

let task = spawn(task_che_lancia);
try {
    join(task);
} catch (e) {
    print("Catturato dal task: " + e);
}
```

**Pattern 3: Task detached con eccezioni**
```hemlock
async fn task_detached() {
    try {
        // lavoro
    } catch (e) {
        // Deve gestire internamente - non puo propagare
        print("Errore: " + e);
    }
}

let task = spawn(task_detached);
detach(task);  // Non si possono catturare eccezioni da task detached
```

## Dettagli di Implementazione

### Architettura di Threading

- **Threading 1:1** - Ogni task creato crea un thread dedicato del sistema operativo tramite `pthread_create()`
- **Schedulato dal kernel** - Il kernel del sistema operativo schedula i thread sui core CPU disponibili
- **Multitasking preemptivo** - Il sistema operativo puo interrompere e passare tra i thread
- **Nessun GIL** - A differenza di Python, non c'e un Global Interpreter Lock che limita il parallelismo

### Implementazione dei Canali

I canali usano un buffer circolare con sincronizzazione pthread:

```
Struttura Canale:
- buffer[] - Array di dimensione fissa di valori
- capacita - Numero massimo di elementi
- dimensione - Numero attuale di elementi
- testa - Posizione di lettura
- coda - Posizione di scrittura
- mutex - pthread_mutex_t per accesso thread-safe
- non_vuoto - pthread_cond_t per recv bloccante
- non_pieno - pthread_cond_t per send bloccante
- chiuso - Flag booleano
- refcount - Conteggio riferimenti per pulizia
```

**Comportamento bloccante:**
- `send()` su canale pieno: attende sulla variabile di condizione `non_pieno`
- `recv()` su canale vuoto: attende sulla variabile di condizione `non_vuoto`
- Entrambi sono segnalati quando appropriato dall'operazione opposta

### Memoria e Pulizia

- **Task joinati:** Automaticamente puliti dopo che `join()` restituisce
- **Task detached:** Automaticamente puliti quando il task viene completato
- **Canali:** Conteggio riferimenti e liberati quando non piu usati

## Migliori Pratiche

### 1. Chiudere Sempre i Canali

```hemlock
async fn produttore(ch) {
    // ... invia valori
    ch.close();  // Importante: segnala che non ci sono piu valori
}
```

### 2. Usare Concorrenza Strutturata

Creare task e fare join nello stesso scope:

```hemlock
fn elabora_dati(dati) {
    // Crea task
    let t1 = spawn(worker, dati);
    let t2 = spawn(worker, dati);

    // Sempre fare join prima di ritornare
    let r1 = join(t1);
    let r2 = join(t2);

    return r1 + r2;
}
```

### 3. Gestire le Eccezioni Appropriatamente

```hemlock
async fn task() {
    try {
        // operazione rischiosa
    } catch (e) {
        // Log errore
        throw e;  // Rilancia se il chiamante deve sapere
    }
}
```

### 4. Usare Capacita del Canale Appropriata

- **Piccola capacita (1-10):** Per coordinazione/segnalazione
- **Media capacita (10-100):** Per produttore-consumatore generale
- **Grande capacita (100+):** Per scenari ad alto throughput

```hemlock
let canale_segnale = channel(1);      // Coordinazione
let canale_lavoro = channel(50);      // Coda di lavoro
let canale_buffer = channel(1000);    // Alto throughput
```

### 5. Detach Solo Quando Necessario

Preferire `join()` rispetto a `detach()` per una migliore gestione delle risorse:

```hemlock
// Buono: Join e ottieni risultato
let task = spawn(lavoro);
let risultato = join(task);

// Usare detach solo per vero fire-and-forget
let task_bg = spawn(logging_in_background);
detach(task_bg);  // Verra eseguito indipendentemente
```

## Caratteristiche di Prestazione

### Vero Parallelismo

- **N task creati possono utilizzare N core CPU simultaneamente**
- Speedup provato - test di stress mostrano 8-9x tempo CPU vs tempo wall (piu core lavorano)
- Scalabilita lineare con il numero di core (fino al conteggio thread)

### Overhead dei Thread

- Ogni task ha ~8KB di stack + overhead pthread
- Costo di creazione thread: ~10-20us
- Costo di context switch: ~1-5us

### Quando Usare Async

**Buoni casi d'uso:**
- Calcoli CPU-intensivi che possono essere parallelizzati
- Operazioni I/O-bound (anche se l'I/O e ancora bloccante)
- Elaborazione concorrente di dati indipendenti
- Architetture pipeline con canali

**Non ideale per:**
- Task molto brevi (l'overhead del thread domina)
- Task con sincronizzazione pesante (overhead di contesa)
- Sistemi single-core (nessun beneficio dal parallelismo)

### I/O Bloccante e Sicuro

Le operazioni bloccanti in un task non bloccano gli altri:

```hemlock
async fn lettore(nomefile: string) {
    let f = open(nomefile, "r");  // Blocca solo questo thread
    let contenuto = f.read();     // Blocca solo questo thread
    f.close();
    return contenuto;
}

// Entrambi leggono concorrentemente (su thread diversi)
let t1 = spawn(lettore, "file1.txt");
let t2 = spawn(lettore, "file2.txt");

let c1 = join(t1);
let c2 = join(t2);
```

## Modello di Thread Safety

Hemlock usa un modello di concorrenza **message-passing** dove i task comunicano tramite canali piuttosto che stato mutabile condiviso.

### Isolamento degli Argomenti

Quando crei un task con spawn, **gli argomenti vengono copiati in profondita** per prevenire data race:

```hemlock
async fn modifica_array(arr: array): array {
    arr.push(999);    // Modifica la COPIA, non l'originale
    arr[0] = -1;
    return arr;
}

let originale = [1, 2, 3];
let task = spawn(modifica_array, originale);
let modificato = join(task);

print(originale.length);  // 3 - invariato!
print(modificato.length);  // 4 - ha nuovo elemento
```

**Cosa viene copiato in profondita:**
- Array (e tutti gli elementi ricorsivamente)
- Oggetti (e tutti i campi ricorsivamente)
- Stringhe
- Buffer

**Cosa viene condiviso (riferimento mantenuto):**
- Canali (il meccanismo di comunicazione - intenzionalmente condiviso)
- Handle dei task (per coordinazione)
- Funzioni (il codice e immutabile)
- Handle dei file (il sistema operativo gestisce l'accesso concorrente)
- Handle dei socket (il sistema operativo gestisce l'accesso concorrente)

**Cosa non puo essere passato:**
- Puntatori raw (`ptr`) - usare `buffer` invece

### Perche Message-Passing?

Questo segue la filosofia "esplicito piuttosto che implicito" di Hemlock:

```hemlock
// MALE: Stato mutabile condiviso (causerebbe data race)
let contatore = { valore: 0 };
let t1 = spawn(fn() { contatore.valore = contatore.valore + 1; });  // Race!
let t2 = spawn(fn() { contatore.valore = contatore.valore + 1; });  // Race!

// BENE: Message-passing tramite canali
async fn incrementa(ch) {
    let val = ch.recv();
    ch.send(val + 1);
}

let ch = channel(1);
ch.send(0);
let t1 = spawn(incrementa, ch);
join(t1);
let risultato = ch.recv();  // 1 - nessuna race condition
```

### Thread Safety del Conteggio Riferimenti

Tutte le operazioni di conteggio riferimenti usano **operazioni atomiche** per prevenire bug use-after-free:
- `string_retain/release` - atomico
- `array_retain/release` - atomico
- `object_retain/release` - atomico
- `buffer_retain/release` - atomico
- `function_retain/release` - atomico
- `channel_retain/release` - atomico
- `task_retain/release` - atomico

Questo garantisce gestione sicura della memoria anche quando i valori sono condivisi tra thread.

### Accesso all'Ambiente Closure

I task hanno accesso all'ambiente closure per:
- Funzioni built-in (`print`, `len`, ecc.)
- Definizioni di funzioni globali
- Costanti e variabili

L'ambiente closure e protetto da un mutex per-ambiente, rendendo
letture e scritture concorrenti thread-safe:

```hemlock
let x = 10;

async fn leggi_closure(): i32 {
    return x;  // OK: lettura variabile closure (thread-safe)
}

async fn modifica_closure() {
    x = 20;  // OK: scrittura variabile closure (sincronizzata con mutex)
}
```

**Nota:** Mentre l'accesso concorrente e sincronizzato, modificare stato condiviso da
piu task puo ancora portare a race condition logiche (ordinamento non deterministico).
Per comportamento prevedibile, usare canali per comunicazione tra task o
valori di ritorno dai task.

Se hai bisogno di restituire dati da un task, usa il valore di ritorno o i canali.

## Limitazioni Attuali

### 1. Nessuno Scheduler Work-Stealing

Usa 1 thread per task, che puo essere inefficiente per molti task brevi.

**Attuale:** 1000 task = 1000 thread (overhead pesante)

**Pianificato:** Thread pool con work stealing per migliore efficienza

### 3. Nessuna Integrazione I/O Asincrono

Le operazioni su file/rete bloccano ancora il thread:

```hemlock
async fn leggi_file(percorso: string) {
    let f = open(percorso, "r");
    let contenuto = f.read();  // Blocca il thread
    f.close();
    return contenuto;
}
```

**Workaround:** Usare piu thread per operazioni I/O concorrenti

### 4. Capacita del Canale Fissa

La capacita del canale e impostata alla creazione e non puo essere ridimensionata:

```hemlock
let ch = channel(10);
// Non si puo ridimensionare dinamicamente a 20
```

### 5. Dimensione del Canale e Fissa

La dimensione del buffer del canale non puo essere cambiata dopo la creazione.

## Pattern Comuni

### Map Parallelo

```hemlock
async fn map_worker(ch_in, ch_out, fn_trasforma) {
    while (true) {
        let val = ch_in.recv();
        if (val == null) { break; }

        let risultato = fn_trasforma(val);
        ch_out.send(risultato);
    }
    ch_out.close();
}

fn parallel_map(dati, fn_trasforma, workers: i32) {
    let ch_in = channel(100);
    let ch_out = channel(100);

    // Crea workers
    let tasks = [];
    let i = 0;
    while (i < workers) {
        tasks.push(spawn(map_worker, ch_in, ch_out, fn_trasforma));
        i = i + 1;
    }

    // Invia dati
    let i = 0;
    while (i < dati.length) {
        ch_in.send(dati[i]);
        i = i + 1;
    }
    ch_in.close();

    // Raccogli risultati
    let risultati = [];
    let i = 0;
    while (i < dati.length) {
        risultati.push(ch_out.recv());
        i = i + 1;
    }

    // Attendi i workers
    let i = 0;
    while (i < tasks.length) {
        join(tasks[i]);
        i = i + 1;
    }

    return risultati;
}
```

### Architettura Pipeline

```hemlock
async fn fase1(input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }
        output_ch.send(val * 2);
    }
    output_ch.close();
}

async fn fase2(input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }
        output_ch.send(val + 10);
    }
    output_ch.close();
}

// Crea pipeline
let ch1 = channel(10);
let ch2 = channel(10);
let ch3 = channel(10);

let s1 = spawn(fase1, ch1, ch2);
let s2 = spawn(fase2, ch2, ch3);

// Alimenta input
ch1.send(1);
ch1.send(2);
ch1.send(3);
ch1.close();

// Raccogli output
print(ch3.recv());  // 12 (1 * 2 + 10)
print(ch3.recv());  // 14 (2 * 2 + 10)
print(ch3.recv());  // 16 (3 * 2 + 10)

join(s1);
join(s2);
```

### Fan-Out, Fan-In

```hemlock
async fn worker(id: i32, input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }

        // Elabora valore
        let risultato = val * id;
        output_ch.send(risultato);
    }
}

let input = channel(10);
let output = channel(10);

// Fan-out: Piu workers
let workers = 4;
let tasks = [];
let i = 0;
while (i < workers) {
    tasks.push(spawn(worker, i, input, output));
    i = i + 1;
}

// Invia lavoro
let i = 0;
while (i < 10) {
    input.send(i);
    i = i + 1;
}
input.close();

// Fan-in: Raccogli tutti i risultati
let risultati = [];
let i = 0;
while (i < 10) {
    risultati.push(output.recv());
    i = i + 1;
}

// Attendi tutti i workers
let i = 0;
while (i < tasks.length) {
    join(tasks[i]);
    i = i + 1;
}
```

## Riepilogo

Il modello async/concorrenza di Hemlock fornisce:

- Vero parallelismo multi-thread usando thread del sistema operativo
- Primitive di concorrenza semplici e strutturate
- Canali thread-safe per la comunicazione
- Propagazione delle eccezioni tra task
- Prestazioni provate su sistemi multi-core
- **Isolamento degli argomenti** - copia profonda previene data race
- **Conteggio riferimenti atomico** - gestione sicura della memoria tra thread

Questo rende Hemlock adatto per:
- Calcoli paralleli
- Operazioni I/O concorrenti
- Architetture pipeline
- Pattern produttore-consumatore

Evitando la complessita di:
- Gestione manuale dei thread
- Primitive di sincronizzazione di basso livello
- Design basati su lock soggetti a deadlock
- Bug di stato mutabile condiviso


--------------------------------------------------------------------------------
## Esecuzione di Comandi
--------------------------------------------------------------------------------

# Esecuzione di Comandi in Hemlock

Hemlock fornisce la **funzione built-in `exec()`** per eseguire comandi shell e catturare il loro output.

## Indice

- [Panoramica](#panoramica)
- [La Funzione exec()](#la-funzione-exec)
- [Oggetto Risultato](#oggetto-risultato)
- [Uso Base](#uso-base)
- [Esempi Avanzati](#esempi-avanzati)
- [Gestione degli Errori](#gestione-degli-errori)
- [Dettagli di Implementazione](#dettagli-di-implementazione)
- [Considerazioni sulla Sicurezza](#considerazioni-sulla-sicurezza)
- [Limitazioni](#limitazioni)
- [Casi d'Uso](#casi-duso)
- [Migliori Pratiche](#migliori-pratiche)
- [Esempi Completi](#esempi-completi)

## Panoramica

La funzione `exec()` permette ai programmi Hemlock di:
- Eseguire comandi shell
- Catturare lo standard output (stdout)
- Controllare i codici di stato di uscita
- Usare funzionalita della shell (pipe, redirect, ecc.)
- Integrarsi con utilita di sistema

**Importante:** I comandi vengono eseguiti tramite `/bin/sh`, fornendo capacita complete della shell ma introducendo anche considerazioni sulla sicurezza.

## La Funzione exec()

### Firma

```hemlock
exec(comando: string): object
```

**Parametri:**
- `comando` (string) - Comando shell da eseguire

**Restituisce:** Un oggetto con due campi:
- `output` (string) - L'output stdout del comando
- `exit_code` (i32) - Il codice di stato di uscita del comando

### Esempio Base

```hemlock
let risultato = exec("echo ciao");
print(risultato.output);      // "ciao\n"
print(risultato.exit_code);   // 0
```

## Oggetto Risultato

L'oggetto restituito da `exec()` ha la seguente struttura:

```hemlock
{
    output: string,      // Stdout del comando (output catturato)
    exit_code: i32       // Stato di uscita del processo (0 = successo)
}
```

### Campo output

Contiene tutto il testo scritto su stdout dal comando.

**Proprieta:**
- Stringa vuota se il comando non produce output
- Include newline e spazi cosi come sono
- Output multi-linea preservato
- Nessun limite di dimensione (allocato dinamicamente)

**Esempi:**
```hemlock
let r1 = exec("echo test");
print(r1.output);  // "test\n"

let r2 = exec("ls");
print(r2.output);  // Lista directory con newline

let r3 = exec("true");
print(r3.output);  // "" (stringa vuota)
```

### Campo exit_code

Il codice di stato di uscita del comando.

**Valori:**
- `0` tipicamente indica successo
- `1-255` indicano errori (la convenzione varia per comando)
- `-1` se il comando non ha potuto essere eseguito o e terminato in modo anomalo

**Esempi:**
```hemlock
let r1 = exec("true");
print(r1.exit_code);  // 0 (successo)

let r2 = exec("false");
print(r2.exit_code);  // 1 (fallimento)

let r3 = exec("ls /inesistente");
print(r3.exit_code);  // 2 (file non trovato, varia per comando)
```

## Uso Base

### Comando Semplice

```hemlock
let r = exec("ls -la");
print(r.output);
print("Codice di uscita: " + typeof(r.exit_code));
```

### Controllo Stato di Uscita

```hemlock
let r = exec("grep pattern file.txt");
if (r.exit_code == 0) {
    print("Trovato: " + r.output);
} else {
    print("Pattern non trovato");
}
```

### Comandi con Pipe

```hemlock
let r = exec("ps aux | grep hemlock");
print(r.output);
```

### Comandi Multipli

```hemlock
let r = exec("cd /tmp && ls -la");
print(r.output);
```

### Sostituzione di Comando

```hemlock
let r = exec("echo $(date)");
print(r.output);  // Data corrente
```

## Esempi Avanzati

### Gestione dei Fallimenti

```hemlock
let r = exec("ls /inesistente");
if (r.exit_code != 0) {
    print("Comando fallito con codice: " + typeof(r.exit_code));
    print("Output errore: " + r.output);  // Nota: stderr non catturato
}
```

### Elaborazione di Output Multi-Linea

```hemlock
let r = exec("cat file.txt");
let righe = r.output.split("\n");
let i = 0;
while (i < righe.length) {
    print("Riga " + typeof(i) + ": " + righe[i]);
    i = i + 1;
}
```

### Concatenamento di Comandi

**Con && (AND):**
```hemlock
let r1 = exec("mkdir -p /tmp/test && touch /tmp/test/file.txt");
if (r1.exit_code == 0) {
    print("Setup completato");
}
```

**Con || (OR):**
```hemlock
let r = exec("comando1 || comando2");
// Esegue comando2 solo se comando1 fallisce
```

**Con ; (sequenza):**
```hemlock
let r = exec("comando1; comando2");
// Esegue entrambi indipendentemente da successo/fallimento
```

### Uso di Pipe

```hemlock
let r = exec("echo 'dati' | base64");
print("Base64: " + r.output);
```

**Pipeline complesse:**
```hemlock
let r = exec("cat /etc/passwd | grep root | cut -d: -f1");
print(r.output);
```

### Pattern di Codici di Uscita

Diversi codici di uscita indicano condizioni diverse:

```hemlock
let r = exec("test -f miofile.txt");
if (r.exit_code == 0) {
    print("Il file esiste");
} else if (r.exit_code == 1) {
    print("Il file non esiste");
} else {
    print("Comando test fallito: " + typeof(r.exit_code));
}
```

### Redirect dell'Output

```hemlock
// Redirect stdout su file (all'interno della shell)
let r1 = exec("echo 'test' > /tmp/output.txt");

// Redirect stderr su stdout (Nota: stderr comunque non catturato da Hemlock)
let r2 = exec("comando 2>&1");
```

### Variabili d'Ambiente

```hemlock
let r = exec("export VAR=valore && echo $VAR");
print(r.output);  // "valore\n"
```

### Cambi di Directory di Lavoro

```hemlock
let r = exec("cd /tmp && pwd");
print(r.output);  // "/tmp\n"
```

## Gestione degli Errori

### Quando exec() Lancia Eccezioni

La funzione `exec()` lancia un'eccezione se il comando non puo essere eseguito:

```hemlock
try {
    let r = exec("comando_inesistente_xyz");
} catch (e) {
    print("Esecuzione fallita: " + e);
}
```

**Eccezioni lanciate quando:**
- `popen()` fallisce (es. impossibile creare pipe)
- Limiti delle risorse di sistema superati
- Fallimenti nell'allocazione di memoria

### Quando exec() NON Lancia

```hemlock
// Il comando viene eseguito ma restituisce codice di uscita non zero
let r1 = exec("false");
print(r1.exit_code);  // 1 (non un'eccezione)

// Il comando non produce output
let r2 = exec("true");
print(r2.output);  // "" (non un'eccezione)

// Comando non trovato dalla shell
let r3 = exec("cmd_inesistente");
print(r3.exit_code);  // 127 (non un'eccezione)
```

### Pattern di Esecuzione Sicura

```hemlock
fn esecuzione_sicura(comando: string) {
    try {
        let r = exec(comando);
        if (r.exit_code != 0) {
            print("Attenzione: Comando fallito con codice " + typeof(r.exit_code));
            return "";
        }
        return r.output;
    } catch (e) {
        print("Errore nell'esecuzione del comando: " + e);
        return "";
    }
}

let output = esecuzione_sicura("ls -la");
```

## Dettagli di Implementazione

### Come Funziona

**Internamente:**
- Usa `popen()` per eseguire comandi tramite `/bin/sh`
- Cattura solo stdout (stderr non viene catturato)
- Output bufferizzato dinamicamente (inizia a 4KB, cresce se necessario)
- Stato di uscita estratto usando macro `WIFEXITED()` e `WEXITSTATUS()`
- Stringa output correttamente terminata con null

**Flusso del processo:**
1. `popen(comando, "r")` crea pipe e fa fork del processo
2. Il processo figlio esegue `/bin/sh -c "comando"`
3. Il processo padre legge stdout tramite pipe in un buffer che cresce
4. `pclose()` attende il figlio e restituisce lo stato di uscita
5. Lo stato di uscita viene estratto e memorizzato nell'oggetto risultato

### Considerazioni sulle Prestazioni

**Costi:**
- Crea un nuovo processo shell per ogni chiamata (~1-5ms di overhead)
- Output memorizzato interamente in memoria (non in streaming)
- Nessun supporto streaming (attende il completamento del comando)
- Adatto per comandi con dimensioni di output ragionevoli

**Ottimizzazioni:**
- Il buffer inizia a 4KB e raddoppia quando pieno (uso efficiente della memoria)
- Singolo ciclo di lettura minimizza le chiamate di sistema
- Nessuna copia aggiuntiva di stringhe

**Quando usare:**
- Comandi di breve durata (< 1 secondo)
- Dimensione output moderata (< 10MB)
- Operazioni batch con intervalli ragionevoli

**Quando NON usare:**
- Daemon o servizi a lunga esecuzione
- Comandi che producono gigabyte di output
- Elaborazione dati in streaming in tempo reale
- Esecuzione ad alta frequenza (> 100 chiamate/secondo)

## Considerazioni sulla Sicurezza

### Rischio di Shell Injection

**CRITICO:** I comandi vengono eseguiti dalla shell (`/bin/sh`), il che significa che **l'iniezione shell e possibile**.

**Codice vulnerabile:**
```hemlock
// PERICOLOSO - NON FARLO
let nomefile = args[1];  // Input utente
let r = exec("cat " + nomefile);  // Shell injection!
```

**Attacco:**
```bash
./hemlock script.hml "; rm -rf /; echo pwned"
# Esegue: cat ; rm -rf /; echo pwned
```

### Pratiche Sicure

**1. Mai usare input utente non sanitizzato:**
```hemlock
// Male
let input_utente = args[1];
let r = exec("elabora " + input_utente);  // PERICOLOSO

// Bene - valida prima
fn e_nomefile_sicuro(nome: string): bool {
    // Permetti solo alfanumerici, trattino, underscore, punto
    let i = 0;
    while (i < nome.length) {
        let c = nome[i];
        if (!(c >= 'a' && c <= 'z') &&
            !(c >= 'A' && c <= 'Z') &&
            !(c >= '0' && c <= '9') &&
            c != '-' && c != '_' && c != '.') {
            return false;
        }
        i = i + 1;
    }
    return true;
}

let nomefile = args[1];
if (e_nomefile_sicuro(nomefile)) {
    let r = exec("cat " + nomefile);
} else {
    print("Nome file non valido");
}
```

**2. Usare allowlist, non denylist:**
```hemlock
// Bene - allowlist rigorosa
let comandi_permessi = ["status", "start", "stop", "restart"];
let cmd = args[1];

let trovato = false;
for (let permesso in comandi_permessi) {
    if (cmd == permesso) {
        trovato = true;
        break;
    }
}

if (trovato) {
    exec("service miaapp " + cmd);
} else {
    print("Comando non valido");
}
```

**3. Eseguire escape dei caratteri speciali:**
```hemlock
fn shell_escape(s: string): string {
    // Escape semplice - racchiudi in apici singoli ed esegui escape degli apici singoli
    let escaped = s.replace_all("'", "'\\''");
    return "'" + escaped + "'";
}

let file_utente = args[1];
let sicuro = shell_escape(file_utente);
let r = exec("cat " + sicuro);
```

**4. Evitare exec() per operazioni sui file:**
```hemlock
// Male - usa exec per operazioni sui file
let r = exec("cat file.txt");

// Bene - usa l'API file di Hemlock
let f = open("file.txt", "r");
let contenuto = f.read();
f.close();
```

### Considerazioni sui Permessi

I comandi vengono eseguiti con gli stessi permessi del processo Hemlock:

```hemlock
// Se Hemlock viene eseguito come root, i comandi exec() vengono eseguiti come root!
let r = exec("rm -rf /importante");  // PERICOLOSO se eseguito come root
```

**Migliore pratica:** Eseguire Hemlock con il minimo privilegio necessario.

## Limitazioni

### 1. Nessuna Cattura di stderr

Viene catturato solo stdout, stderr va al terminale:

```hemlock
let r = exec("ls /inesistente");
// r.output e vuoto
// Messaggio di errore appare sul terminale, non catturato
```

**Workaround - redirect stderr su stdout:**
```hemlock
let r = exec("ls /inesistente 2>&1");
// Ora i messaggi di errore sono in r.output
```

### 2. Nessuno Streaming

Deve attendere il completamento del comando:

```hemlock
let r = exec("comando_lungo");
// Blocca fino al termine del comando
// Impossibile elaborare output in modo incrementale
```

### 3. Nessun Timeout

I comandi possono essere eseguiti indefinitamente:

```hemlock
let r = exec("sleep 1000");
// Blocca per 1000 secondi
// Nessun modo per fare timeout o annullare
```

**Workaround - usa comando timeout:**
```hemlock
let r = exec("timeout 5 comando_lungo");
// Fara timeout dopo 5 secondi
```

### 4. Nessuna Gestione Segnali

Impossibile inviare segnali ai comandi in esecuzione:

```hemlock
let r = exec("comando_lungo");
// Impossibile inviare SIGINT, SIGTERM, ecc. al comando
```

### 5. Nessun Controllo del Processo

Impossibile interagire con il comando dopo l'avvio:

```hemlock
let r = exec("programma_interattivo");
// Impossibile inviare input al programma
// Impossibile controllare l'esecuzione
```

## Casi d'Uso

### Buoni Casi d'Uso

**1. Esecuzione di utilita di sistema:**
```hemlock
let r = exec("ls -la");
let r = exec("grep pattern file.txt");
let r = exec("find /percorso -name '*.txt'");
```

**2. Elaborazione rapida di dati con strumenti Unix:**
```hemlock
let r = exec("cat dati.txt | sort | uniq | wc -l");
print("Righe uniche: " + r.output);
```

**3. Controllo stato del sistema:**
```hemlock
let r = exec("df -h");
print("Uso disco:\n" + r.output);
```

**4. Controlli esistenza file:**
```hemlock
let r = exec("test -f miofile.txt");
if (r.exit_code == 0) {
    print("Il file esiste");
}
```

**5. Generazione di report:**
```hemlock
let r = exec("ps aux | grep miaapp | wc -l");
let conteggio = r.output.trim();
print("Istanze in esecuzione: " + conteggio);
```

**6. Script di automazione:**
```hemlock
exec("git add .");
exec("git commit -m 'Commit automatico'");
let r = exec("git push");
if (r.exit_code != 0) {
    print("Push fallito");
}
```

### Non Raccomandato Per

**1. Servizi a lunga esecuzione:**
```hemlock
// Male
let r = exec("nginx");  // Blocca per sempre
```

**2. Comandi interattivi:**
```hemlock
// Male - impossibile fornire input
let r = exec("ssh utente@host");
```

**3. Comandi che producono output enorme:**
```hemlock
// Male - carica intero output in memoria
let r = exec("cat file_10GB.log");
```

**4. Streaming in tempo reale:**
```hemlock
// Male - impossibile elaborare output in modo incrementale
let r = exec("tail -f /var/log/app.log");
```

**5. Gestione errori mission-critical:**
```hemlock
// Male - stderr non catturato
let r = exec("operazione_critica");
// Impossibile vedere messaggi di errore dettagliati
```

## Migliori Pratiche

### 1. Controllare Sempre i Codici di Uscita

```hemlock
let r = exec("comando_importante");
if (r.exit_code != 0) {
    print("Comando fallito!");
    // Gestisci errore
}
```

### 2. Rimuovere Spazi dall'Output Quando Necessario

```hemlock
let r = exec("echo test");
let pulito = r.output.trim();  // Rimuove newline finale
print(pulito);  // "test" (senza newline)
```

### 3. Validare Prima di Eseguire

```hemlock
fn e_comando_valido(cmd: string): bool {
    // Valida che il comando sia sicuro
    return true;  // La tua logica di validazione
}

if (e_comando_valido(cmd_utente)) {
    exec(cmd_utente);
}
```

### 4. Usare try/catch per Operazioni Critiche

```hemlock
try {
    let r = exec("comando_critico");
    if (r.exit_code != 0) {
        throw "Comando fallito";
    }
} catch (e) {
    print("Errore: " + e);
    // Pulizia o recovery
}
```

### 5. Preferire API Hemlock a exec()

```hemlock
// Male - usa exec per operazioni sui file
let r = exec("cat file.txt");

// Bene - usa l'API File di Hemlock
let f = open("file.txt", "r");
let contenuto = f.read();
f.close();
```

### 6. Catturare stderr Quando Necessario

```hemlock
// Redirect stderr su stdout
let r = exec("comando 2>&1");
// Ora r.output contiene sia stdout che stderr
```

### 7. Usare Funzionalita Shell con Saggezza

```hemlock
// Usa pipe per efficienza
let r = exec("cat grande.txt | grep pattern | head -n 10");

// Usa sostituzione di comando
let r = exec("echo Utente corrente: $(whoami)");

// Usa esecuzione condizionale
let r = exec("test -f file.txt && cat file.txt");
```

## Esempi Completi

### Esempio 1: Raccoglitore di Informazioni di Sistema

```hemlock
fn ottieni_info_sistema() {
    print("=== Informazioni Sistema ===");

    // Hostname
    let r1 = exec("hostname");
    print("Hostname: " + r1.output.trim());

    // Uptime
    let r2 = exec("uptime");
    print("Uptime: " + r2.output.trim());

    // Uso disco
    let r3 = exec("df -h /");
    print("\nUso Disco:");
    print(r3.output);

    // Uso memoria
    let r4 = exec("free -h");
    print("Uso Memoria:");
    print(r4.output);
}

ottieni_info_sistema();
```

### Esempio 2: Analizzatore di Log

```hemlock
fn analizza_log(file_log: string) {
    print("Analisi log: " + file_log);

    // Conta righe totali
    let r1 = exec("wc -l " + file_log);
    print("Righe totali: " + r1.output.trim());

    // Conta errori
    let r2 = exec("grep -c ERROR " + file_log + " 2>/dev/null");
    let errori = r2.output.trim();
    if (r2.exit_code == 0) {
        print("Errori: " + errori);
    } else {
        print("Errori: 0");
    }

    // Conta avvisi
    let r3 = exec("grep -c WARN " + file_log + " 2>/dev/null");
    let avvisi = r3.output.trim();
    if (r3.exit_code == 0) {
        print("Avvisi: " + avvisi);
    } else {
        print("Avvisi: 0");
    }

    // Errori recenti
    print("\nErrori recenti:");
    let r4 = exec("grep ERROR " + file_log + " | tail -n 5");
    print(r4.output);
}

if (args.length < 2) {
    print("Uso: " + args[0] + " <file_log>");
} else {
    analizza_log(args[1]);
}
```

### Esempio 3: Helper Git

```hemlock
fn stato_git() {
    let r = exec("git status --short");
    if (r.exit_code != 0) {
        print("Errore: Non e un repository git");
        return;
    }

    if (r.output == "") {
        print("Directory di lavoro pulita");
    } else {
        print("Modifiche:");
        print(r.output);
    }
}

fn commit_veloce_git(messaggio: string) {
    print("Aggiunta di tutte le modifiche...");
    let r1 = exec("git add -A");
    if (r1.exit_code != 0) {
        print("Errore nell'aggiunta dei file");
        return;
    }

    print("Commit in corso...");
    let msg_sicuro = messaggio.replace_all("'", "'\\''");
    let r2 = exec("git commit -m '" + msg_sicuro + "'");
    if (r2.exit_code != 0) {
        print("Errore nel commit");
        return;
    }

    print("Commit eseguito con successo");
    print(r2.output);
}

// Utilizzo
stato_git();
if (args.length > 1) {
    commit_veloce_git(args[1]);
}
```

### Esempio 4: Script di Backup

```hemlock
fn backup_directory(sorgente: string, destinazione: string) {
    print("Backup di " + sorgente + " in " + destinazione);

    // Crea directory di backup
    let r1 = exec("mkdir -p " + destinazione);
    if (r1.exit_code != 0) {
        print("Errore nella creazione della directory di backup");
        return false;
    }

    // Crea tarball con timestamp
    let r2 = exec("date +%Y%m%d_%H%M%S");
    let timestamp = r2.output.trim();
    let file_backup = destinazione + "/backup_" + timestamp + ".tar.gz";

    print("Creazione archivio: " + file_backup);
    let r3 = exec("tar -czf " + file_backup + " " + sorgente + " 2>&1");
    if (r3.exit_code != 0) {
        print("Errore nella creazione del backup:");
        print(r3.output);
        return false;
    }

    print("Backup completato con successo");

    // Mostra dimensione backup
    let r4 = exec("du -h " + file_backup);
    print("Dimensione backup: " + r4.output.trim());

    return true;
}

if (args.length < 3) {
    print("Uso: " + args[0] + " <sorgente> <destinazione>");
} else {
    backup_directory(args[1], args[2]);
}
```

## Riepilogo

La funzione `exec()` di Hemlock fornisce:

- Semplice esecuzione di comandi shell
- Cattura dell'output (stdout)
- Controllo dei codici di uscita
- Accesso completo alle funzionalita della shell (pipe, redirect, ecc.)
- Integrazione con utilita di sistema

Ricorda:
- Controllare sempre i codici di uscita
- Essere consapevoli delle implicazioni di sicurezza (shell injection)
- Validare l'input utente prima di usarlo nei comandi
- Preferire le API Hemlock a exec() quando disponibili
- stderr non viene catturato (usa `2>&1` per il redirect)
- I comandi bloccano fino al completamento
- Usare per utilita di breve durata, non per servizi a lunga esecuzione

**Checklist di sicurezza:**
- Mai usare input utente non sanitizzato
- Validare tutto l'input
- Usare allowlist per i comandi
- Eseguire escape dei caratteri speciali quando necessario
- Eseguire con il minimo privilegio
- Preferire le API Hemlock ai comandi shell


--------------------------------------------------------------------------------
## FFI
--------------------------------------------------------------------------------

# FFI (Interfaccia Funzioni Esterne) in Hemlock

Hemlock fornisce **FFI (Foreign Function Interface)** per chiamare funzioni C da librerie condivise usando libffi, consentendo l'integrazione con librerie C esistenti e API di sistema.

## Indice

- [Panoramica](#panoramica)
- [Stato Attuale](#stato-attuale)
- [Tipi Supportati](#tipi-supportati)
- [Concetti Base](#concetti-base)
- [Esportazione di Funzioni FFI](#esportazione-di-funzioni-ffi)
- [Casi d'Uso](#casi-duso)
- [Sviluppi Futuri](#sviluppi-futuri)
- [Callback FFI](#callback-ffi)
- [Struct FFI](#struct-ffi)
- [Esportazione di Tipi Struct](#esportazione-di-tipi-struct)
- [Limitazioni Attuali](#limitazioni-attuali)
- [Migliori Pratiche](#migliori-pratiche)

## Panoramica

L'Interfaccia Funzioni Esterne (FFI) permette ai programmi Hemlock di:
- Chiamare funzioni C da librerie condivise (.so, .dylib, .dll)
- Usare librerie C esistenti senza scrivere codice wrapper
- Accedere direttamente alle API di sistema
- Integrarsi con librerie native di terze parti
- Collegare Hemlock con funzionalita di sistema a basso livello

**Capacita principali:**
- Caricamento dinamico di librerie
- Binding di funzioni C
- Conversione automatica dei tipi tra Hemlock e tipi C
- Supporto per tutti i tipi primitivi
- Implementazione basata su libffi per portabilita

## Stato Attuale

Il supporto FFI e disponibile in Hemlock con le seguenti funzionalita:

**Implementato:**
- Chiamare funzioni C da librerie condivise
- Supporto per tutti i tipi primitivi (interi, float, puntatori)
- Conversione automatica dei tipi
- Implementazione basata su libffi
- Caricamento dinamico di librerie
- **Callback con puntatori a funzione** - Passare funzioni Hemlock a C
- **Esportazione di funzioni extern** - Condividere binding FFI tra moduli
- **Passaggio e restituzione di struct** - Passare struct compatibili con C per valore
- **Helper per puntatori completi** - Lettura/scrittura di tutti i tipi (i8-i64, u8-u64, f32, f64, ptr)
- **Conversione buffer/puntatore** - `buffer_ptr()`, `ptr_to_buffer()`
- **Dimensioni tipi FFI** - `ffi_sizeof()` per dimensioni tipi consapevoli della piattaforma
- **Tipi di piattaforma** - Supporto `size_t`, `usize`, `isize`, `intptr_t`

**In Sviluppo:**
- Helper per marshaling di stringhe
- Miglioramenti nella gestione degli errori

**Copertura Test:**
- Test FFI passati inclusi test callback
- Chiamata funzioni base verificata
- Conversione tipi testata
- Integrazione callback qsort testata

## Tipi Supportati

### Tipi Primitivi

I seguenti tipi Hemlock possono essere passati a/da funzioni C:

| Tipo Hemlock | Tipo C | Dimensione | Note |
|--------------|--------|------------|------|
| `i8` | `int8_t` | 1 byte | Intero con segno a 8 bit |
| `i16` | `int16_t` | 2 byte | Intero con segno a 16 bit |
| `i32` | `int32_t` | 4 byte | Intero con segno a 32 bit |
| `i64` | `int64_t` | 8 byte | Intero con segno a 64 bit |
| `u8` | `uint8_t` | 1 byte | Intero senza segno a 8 bit |
| `u16` | `uint16_t` | 2 byte | Intero senza segno a 16 bit |
| `u32` | `uint32_t` | 4 byte | Intero senza segno a 32 bit |
| `u64` | `uint64_t` | 8 byte | Intero senza segno a 64 bit |
| `f32` | `float` | 4 byte | Virgola mobile a 32 bit |
| `f64` | `double` | 8 byte | Virgola mobile a 64 bit |
| `ptr` | `void*` | 8 byte | Puntatore raw |

### Conversione dei Tipi

**Conversioni automatiche:**
- Interi Hemlock -> Interi C (con controllo range)
- Float Hemlock -> Float C
- Puntatori Hemlock -> Puntatori C
- Valori di ritorno C -> Valori Hemlock

**Esempio di mappatura tipi:**
```hemlock
// Hemlock -> C
let i: i32 = 42;         // -> int32_t (4 byte)
let f: f64 = 3.14;       // -> double (8 byte)
let p: ptr = alloc(64);  // -> void* (8 byte)

// C -> Hemlock (valori di ritorno)
// int32_t foo() -> i32
// double bar() -> f64
// void* baz() -> ptr
```

## Concetti Base

### Librerie Condivise

FFI funziona con librerie condivise compilate:

**Linux:** file `.so`
```
libexample.so
/usr/lib/libm.so
```

**macOS:** file `.dylib`
```
libexample.dylib
/usr/lib/libSystem.dylib
```

**Windows:** file `.dll`
```
example.dll
kernel32.dll
```

### Firme delle Funzioni

Le funzioni C devono avere firme note perche FFI funzioni correttamente:

```c
// Esempi di firme funzioni C
int add(int a, int b);
double sqrt(double x);
void* malloc(size_t size);
void free(void* ptr);
```

Queste possono essere chiamate da Hemlock una volta che la libreria e caricata e le funzioni sono legate.

### Compatibilita di Piattaforma

FFI usa **libffi** per la portabilita:
- Funziona su x86, x86-64, ARM, ARM64
- Gestisce automaticamente le convenzioni di chiamata
- Astrae i dettagli ABI specifici della piattaforma
- Supporta Linux, macOS, Windows (con libffi appropriato)

## Esportazione di Funzioni FFI

Le funzioni FFI dichiarate con `extern fn` possono essere esportate dai moduli, permettendo di creare wrapper di librerie riutilizzabili che possono essere condivisi tra piu file.

### Sintassi di Esportazione Base

```hemlock
// string_utils.hml - Un modulo libreria che wrappa funzioni stringa C
import "libc.so.6";

// Esporta direttamente la funzione extern
export extern fn strlen(s: string): i32;
export extern fn strcmp(s1: string, s2: string): i32;

// Puoi anche esportare funzioni wrapper insieme a funzioni extern
export fn lunghezza_stringa(s: string): i32 {
    return strlen(s);
}

export fn stringhe_uguali(a: string, b: string): bool {
    return strcmp(a, b) == 0;
}
```

### Importazione di Funzioni FFI Esportate

```hemlock
// main.hml - Uso delle funzioni FFI esportate
import { strlen, lunghezza_stringa, stringhe_uguali } from "./string_utils.hml";

let msg = "Ciao, Mondo!";
print(strlen(msg));              // 12 - chiamata extern diretta
print(lunghezza_stringa(msg));   // 12 - funzione wrapper

print(stringhe_uguali("pippo", "pippo"));  // true
print(stringhe_uguali("pippo", "pluto"));  // false
```

### Casi d'Uso per Export Extern

**1. Astrazione di Piattaforma**
```hemlock
// platform.hml - Astrae differenze di piattaforma
import "libc.so.6";  // Linux

export extern fn getpid(): i32;
export extern fn getuid(): i32;
export extern fn geteuid(): i32;
```

**2. Wrapper di Librerie**
```hemlock
// crypto_lib.hml - Wrappa funzioni libreria crypto
import "libcrypto.so";

export extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;
export extern fn MD5(data: ptr, len: u64, out: ptr): ptr;

// Aggiungi wrapper Hemlock-friendly
export fn sha256_stringa(s: string): string {
    // Implementazione usando la funzione extern
}
```

**3. Dichiarazioni FFI Centralizzate**
```hemlock
// libc.hml - Modulo centrale per binding libc
import "libc.so.6";

// Funzioni stringa
export extern fn strlen(s: string): i32;
export extern fn strcpy(dest: ptr, src: string): ptr;
export extern fn strcat(dest: ptr, src: string): ptr;

// Funzioni memoria
export extern fn malloc(size: u64): ptr;
export extern fn realloc(p: ptr, size: u64): ptr;
export extern fn calloc(nmemb: u64, size: u64): ptr;

// Funzioni processo
export extern fn getpid(): i32;
export extern fn getppid(): i32;
export extern fn getenv(name: string): ptr;
```

Poi usalo in tutto il progetto:
```hemlock
import { strlen, malloc, getpid } from "./libc.hml";
```

### Combinare con Esportazioni Regolari

Puoi mischiare funzioni extern esportate con esportazioni di funzioni regolari:

```hemlock
// math_extended.hml
import "libm.so.6";

// Esporta funzioni C raw
export extern fn sin(x: f64): f64;
export extern fn cos(x: f64): f64;
export extern fn tan(x: f64): f64;

// Esporta funzioni Hemlock che le usano
export fn gradi_a_radianti(gradi: f64): f64 {
    return gradi * 3.14159265359 / 180.0;
}

export fn sin_gradi(gradi: f64): f64 {
    return sin(gradi_a_radianti(gradi));
}
```

### Librerie Specifiche per Piattaforma

Quando esporti funzioni extern, ricorda che i nomi delle librerie differiscono per piattaforma:

```hemlock
// Per Linux
import "libc.so.6";

// Per macOS (approccio diverso necessario)
import "libSystem.B.dylib";
```

Attualmente, la sintassi `import "libreria"` di Hemlock usa percorsi di libreria statici, quindi potrebbero essere necessari moduli specifici per piattaforma per codice FFI cross-platform.

## Casi d'Uso

### 1. Librerie di Sistema

Accedi alle funzioni della libreria C standard:

**Funzioni matematiche:**
```hemlock
// Chiama sqrt da libm
let risultato = sqrt(16.0);  // 4.0
```

**Allocazione memoria:**
```hemlock
// Chiama malloc/free da libc
let ptr = malloc(1024);
free(ptr);
```

### 2. Librerie di Terze Parti

Usa librerie C esistenti:

**Esempio: Elaborazione immagini**
```hemlock
// Carica libpng o libjpeg
// Elabora immagini usando funzioni libreria C
```

**Esempio: Crittografia**
```hemlock
// Usa OpenSSL o libsodium
// Crittografia/decrittografia tramite FFI
```

### 3. API di Sistema

Chiamate di sistema dirette:

**Esempio: API POSIX**
```hemlock
// Chiama getpid, getuid, ecc.
// Accedi a funzionalita di sistema a basso livello
```

### 4. Codice Critico per le Prestazioni

Chiama implementazioni C ottimizzate:

```hemlock
// Usa librerie C altamente ottimizzate
// Operazioni SIMD, codice vettorizzato
// Funzioni accelerate hardware
```

### 5. Accesso Hardware

Interfaccia con librerie hardware:

```hemlock
// Controllo GPIO su sistemi embedded
// Comunicazione dispositivi USB
// Accesso porta seriale
```

### 6. Integrazione Codice Legacy

Riusa codebase C esistenti:

```hemlock
// Chiama funzioni da applicazioni C legacy
// Migra gradualmente a Hemlock
// Preserva codice C funzionante
```

## Sviluppi Futuri

### Funzionalita Pianificate

**1. Supporto Struct**
```hemlock
// Futuro: Passa/restituisci struct C
define Punto {
    x: f64,
    y: f64,
}

let p = Punto { x: 1.0, y: 2.0 };
funzione_c_con_struct(p);
```

**2. Gestione Array/Buffer**
```hemlock
// Futuro: Migliore passaggio array
let arr = [1, 2, 3, 4, 5];
elabora_array(arr);  // Passa a funzione C
```

**3. Callback con Puntatori a Funzione** (Implementato!)
```hemlock
// Passa funzioni Hemlock a C come callback
fn mio_confronto(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    return va - vb;
}

// Crea un puntatore a funzione chiamabile da C
let cmp = callback(mio_confronto, ["ptr", "ptr"], "i32");

// Usa con qsort o qualsiasi funzione C che si aspetta un callback
qsort(arr, conteggio, dim_elem, cmp);

// Pulisci quando finito
callback_free(cmp);
```

**4. Marshaling Stringhe**
```hemlock
// Futuro: Conversione automatica stringhe
let s = "ciao";
funzione_stringa_c(s);  // Auto-converti in stringa C
```

**5. Gestione Errori**
```hemlock
// Futuro: Migliore reporting errori
try {
    let risultato = funzione_c_rischiosa();
} catch (e) {
    print("Errore FFI: " + e);
}
```

**6. Type Safety**
```hemlock
// Futuro: Annotazioni di tipo per FFI
@ffi("libm.so")
fn sqrt(x: f64): f64;

let risultato = sqrt(16.0);  // Type-checked
```

### Funzionalita

**v1.0:**
- FFI base con tipi primitivi
- Caricamento dinamico librerie
- Chiamata funzioni
- Supporto callback tramite closure libffi

**Futuro:**
- Supporto struct
- Miglioramenti gestione array
- Generazione automatica binding

## Callback FFI

Hemlock supporta il passaggio di funzioni a codice C come callback usando closure libffi. Questo abilita l'integrazione con API C che si aspettano puntatori a funzione, come `qsort`, event loop e librerie basate su callback.

### Creazione di Callback

Usa `callback()` per creare un puntatore a funzione chiamabile da C da una funzione Hemlock:

```hemlock
// callback(funzione, tipi_param, tipo_ritorno) -> ptr
let cb = callback(mia_funzione, ["ptr", "ptr"], "i32");
```

**Parametri:**
- `funzione`: Una funzione Hemlock da wrappare
- `tipi_param`: Array di stringhe nomi tipo (es. `["ptr", "i32"]`)
- `tipo_ritorno`: Stringa tipo ritorno (es. `"i32"`, `"void"`)

**Tipi callback supportati:**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - Interi con segno
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - Interi senza segno
- `"f32"`, `"f64"` - Virgola mobile
- `"ptr"` - Puntatore
- `"void"` - Nessun valore di ritorno
- `"bool"` - Booleano

### Esempio: qsort

```hemlock
import "libc.so.6";
extern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;

// Funzione di confronto per interi (ordine crescente)
fn confronta_interi(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    if (va < vb) { return -1; }
    if (va > vb) { return 1; }
    return 0;
}

// Alloca array di 5 interi
let arr = alloc(20);  // 5 * 4 byte
ptr_write_i32(arr, 5);
ptr_write_i32(ptr_offset(arr, 1, 4), 2);
ptr_write_i32(ptr_offset(arr, 2, 4), 8);
ptr_write_i32(ptr_offset(arr, 3, 4), 1);
ptr_write_i32(ptr_offset(arr, 4, 4), 9);

// Crea callback e ordina
let cmp = callback(confronta_interi, ["ptr", "ptr"], "i32");
qsort(arr, 5, 4, cmp);

// L'array e ora ordinato: [1, 2, 5, 8, 9]

// Pulisci
callback_free(cmp);
free(arr);
```

### Funzioni Helper per Puntatori

Hemlock fornisce funzioni helper complete per lavorare con puntatori raw. Queste sono essenziali per callback FFI e manipolazione diretta della memoria.

#### Helper per Tipi Interi

| Funzione | Descrizione |
|----------|-------------|
| `ptr_deref_i8(ptr)` | Dereferenzia puntatore, leggi i8 |
| `ptr_deref_i16(ptr)` | Dereferenzia puntatore, leggi i16 |
| `ptr_deref_i32(ptr)` | Dereferenzia puntatore, leggi i32 |
| `ptr_deref_i64(ptr)` | Dereferenzia puntatore, leggi i64 |
| `ptr_deref_u8(ptr)` | Dereferenzia puntatore, leggi u8 |
| `ptr_deref_u16(ptr)` | Dereferenzia puntatore, leggi u16 |
| `ptr_deref_u32(ptr)` | Dereferenzia puntatore, leggi u32 |
| `ptr_deref_u64(ptr)` | Dereferenzia puntatore, leggi u64 |
| `ptr_write_i8(ptr, valore)` | Scrivi i8 nella locazione puntatore |
| `ptr_write_i16(ptr, valore)` | Scrivi i16 nella locazione puntatore |
| `ptr_write_i32(ptr, valore)` | Scrivi i32 nella locazione puntatore |
| `ptr_write_i64(ptr, valore)` | Scrivi i64 nella locazione puntatore |
| `ptr_write_u8(ptr, valore)` | Scrivi u8 nella locazione puntatore |
| `ptr_write_u16(ptr, valore)` | Scrivi u16 nella locazione puntatore |
| `ptr_write_u32(ptr, valore)` | Scrivi u32 nella locazione puntatore |
| `ptr_write_u64(ptr, valore)` | Scrivi u64 nella locazione puntatore |

#### Helper per Tipi Float

| Funzione | Descrizione |
|----------|-------------|
| `ptr_deref_f32(ptr)` | Dereferenzia puntatore, leggi f32 (float) |
| `ptr_deref_f64(ptr)` | Dereferenzia puntatore, leggi f64 (double) |
| `ptr_write_f32(ptr, valore)` | Scrivi f32 nella locazione puntatore |
| `ptr_write_f64(ptr, valore)` | Scrivi f64 nella locazione puntatore |

#### Helper per Tipi Puntatore

| Funzione | Descrizione |
|----------|-------------|
| `ptr_deref_ptr(ptr)` | Dereferenzia puntatore-a-puntatore |
| `ptr_write_ptr(ptr, valore)` | Scrivi puntatore nella locazione puntatore |
| `ptr_offset(ptr, indice, dimensione)` | Calcola offset: `ptr + indice * dimensione` |
| `ptr_read_i32(ptr)` | Leggi i32 attraverso puntatore-a-puntatore (per callback qsort) |
| `ptr_null()` | Ottieni costante puntatore null |

#### Helper Conversione Buffer

| Funzione | Descrizione |
|----------|-------------|
| `buffer_ptr(buffer)` | Ottieni puntatore raw da un buffer |
| `ptr_to_buffer(ptr, dimensione)` | Copia dati da puntatore in un nuovo buffer |

#### Funzioni Utilita FFI

| Funzione | Descrizione |
|----------|-------------|
| `ffi_sizeof(nome_tipo)` | Ottieni dimensione in byte di un tipo FFI |

**Nomi tipo supportati per `ffi_sizeof`:**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - Interi con segno (1, 2, 4, 8 byte)
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - Interi senza segno (1, 2, 4, 8 byte)
- `"f32"`, `"f64"` - Float (4, 8 byte)
- `"ptr"` - Puntatore (8 byte su 64 bit)
- `"size_t"`, `"usize"` - Tipo dimensione dipendente dalla piattaforma
- `"intptr_t"`, `"isize"` - Tipo puntatore con segno dipendente dalla piattaforma

#### Esempio: Lavorare con Tipi Diversi

```hemlock
let p = alloc(64);

// Scrivi e leggi interi
ptr_write_i8(p, 42);
print(ptr_deref_i8(p));  // 42

ptr_write_i64(ptr_offset(p, 1, 8), 9000000000);
print(ptr_deref_i64(ptr_offset(p, 1, 8)));  // 9000000000

// Scrivi e leggi float
ptr_write_f64(p, 3.14159);
print(ptr_deref_f64(p));  // 3.14159

// Puntatore-a-puntatore
let interno = alloc(4);
ptr_write_i32(interno, 999);
ptr_write_ptr(p, interno);
let recuperato = ptr_deref_ptr(p);
print(ptr_deref_i32(recuperato));  // 999

// Ottieni dimensioni tipi
print(ffi_sizeof("i64"));  // 8
print(ffi_sizeof("ptr"));  // 8 (su 64 bit)

// Conversione buffer
let buf = buffer(64);
ptr_write_i32(buffer_ptr(buf), 12345);
print(ptr_deref_i32(buffer_ptr(buf)));  // 12345

free(interno);
free(p);
```

### Liberazione dei Callback

**Importante:** Liberare sempre i callback quando finito per prevenire memory leak:

```hemlock
let cb = callback(mia_fn, ["ptr"], "void");
// ... usa callback ...
callback_free(cb);  // Libera quando finito
```

I callback vengono anche automaticamente liberati quando il programma termina.

### Closure nei Callback

I callback catturano il loro ambiente closure, quindi possono accedere a variabili dello scope esterno:

```hemlock
let moltiplicatore = 10;

fn scala(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    // Puo accedere a 'moltiplicatore' dallo scope esterno
    return (va * moltiplicatore) - (vb * moltiplicatore);
}

let cmp = callback(scala, ["ptr", "ptr"], "i32");
```

### Thread Safety

Le invocazioni callback sono serializzate con un mutex per garantire thread safety, poiche l'interprete Hemlock non e completamente thread-safe. Questo significa:
- Solo un callback puo essere eseguito alla volta
- Sicuro da usare con librerie C multi-thread
- Potrebbe impattare le prestazioni se i callback vengono chiamati molto frequentemente da piu thread

### Gestione Errori nei Callback

Le eccezioni lanciate nei callback non possono propagarsi al codice C. Invece:
- Un avviso viene stampato su stderr
- Il callback restituisce un valore predefinito (0 o NULL)
- L'eccezione viene loggata ma non propagata

```hemlock
fn callback_rischioso(a: ptr): i32 {
    throw "Qualcosa e andato storto";  // Avviso stampato, restituisce 0
}
```

Per gestione errori robusta, valida gli input ed evita di lanciare eccezioni nei callback.

## Struct FFI

Hemlock supporta il passaggio di struct per valore a funzioni C. I tipi struct vengono automaticamente registrati per FFI quando li definisci con annotazioni di tipo.

### Definizione di Struct Compatibili con FFI

Una struct e compatibile con FFI quando tutti i campi hanno annotazioni di tipo esplicite usando tipi compatibili con FFI:

```hemlock
// Struct compatibile con FFI
define Punto {
    x: f64,
    y: f64,
}

// Struct compatibile con FFI con piu tipi di campo
define Rettangolo {
    in_alto_sinistra: Punto,      // Struct annidata
    larghezza: f64,
    altezza: f64,
}

// NON compatibile con FFI (campo senza annotazione di tipo)
define OggettoDinamico {
    nome,                 // Nessun tipo - non usabile in FFI
    valore,
}
```

### Uso di Struct in FFI

Dichiara funzioni extern che usano tipi struct:

```hemlock
// Definisci il tipo struct
define Vettore2D {
    x: f64,
    y: f64,
}

// Importa la libreria C
import "libmath.so";

// Dichiara funzione extern che prende/restituisce struct
extern fn vettore_somma(a: Vettore2D, b: Vettore2D): Vettore2D;
extern fn vettore_lunghezza(v: Vettore2D): f64;

// Usala naturalmente
let a: Vettore2D = { x: 3.0, y: 0.0 };
let b: Vettore2D = { x: 0.0, y: 4.0 };
let risultato = vettore_somma(a, b);
print(risultato.x);  // 3.0
print(risultato.y);  // 4.0

let lun = vettore_lunghezza(risultato);
print(lun);          // 5.0
```

### Tipi di Campo Supportati

I campi struct devono usare questi tipi compatibili con FFI:

| Tipo Hemlock | Tipo C | Dimensione |
|--------------|--------|------------|
| `i8` | `int8_t` | 1 byte |
| `i16` | `int16_t` | 2 byte |
| `i32` | `int32_t` | 4 byte |
| `i64` | `int64_t` | 8 byte |
| `u8` | `uint8_t` | 1 byte |
| `u16` | `uint16_t` | 2 byte |
| `u32` | `uint32_t` | 4 byte |
| `u64` | `uint64_t` | 8 byte |
| `f32` | `float` | 4 byte |
| `f64` | `double` | 8 byte |
| `ptr` | `void*` | 8 byte |
| `string` | `char*` | 8 byte |
| `bool` | `int` | varia |
| Struct annidata | struct | varia |

### Layout Struct

Hemlock usa le regole di layout struct native della piattaforma (corrispondente all'ABI C):
- I campi sono allineati secondo il loro tipo
- Padding inserito se necessario
- Dimensione totale con padding per allineare il membro piu grande

```hemlock
// Esempio: layout compatibile con C
define Misto {
    a: i8,    // offset 0, dimensione 1
              // 3 byte padding
    b: i32,   // offset 4, dimensione 4
}
// Dimensione totale: 8 byte (con padding)

define Punto3D {
    x: f64,   // offset 0, dimensione 8
    y: f64,   // offset 8, dimensione 8
    z: f64,   // offset 16, dimensione 8
}
// Dimensione totale: 24 byte (nessun padding necessario)
```

### Struct Annidate

Le struct possono contenere altre struct:

```hemlock
define Interno {
    x: i32,
    y: i32,
}

define Esterno {
    interno: Interno,
    z: i32,
}

import "mialibrary.so";
extern fn elabora_annidata(data: Esterno): i32;

let obj: Esterno = {
    interno: { x: 1, y: 2 },
    z: 3,
};
let risultato = elabora_annidata(obj);
```

### Valori di Ritorno Struct

Le funzioni C possono restituire struct:

```hemlock
define Punto {
    x: f64,
    y: f64,
}

import "libmath.so";
extern fn ottieni_origine(): Punto;

let p = ottieni_origine();
print(p.x);  // 0.0
print(p.y);  // 0.0
```

### Limitazioni

- **I campi struct devono avere annotazioni di tipo** - campi senza tipo non sono compatibili con FFI
- **Nessun array nelle struct** - usa puntatori invece
- **Nessuna union** - solo tipi struct sono supportati
- **I callback non possono restituire struct** - usa puntatori per valori di ritorno callback

### Esportazione di Tipi Struct

Puoi esportare definizioni di tipi struct da un modulo usando `export define`:

```hemlock
// geometria.hml
export define Vettore2 {
    x: f32,
    y: f32,
}

export define Rettangolo {
    x: f32,
    y: f32,
    larghezza: f32,
    altezza: f32,
}

export fn crea_rett(x: f32, y: f32, l: f32, a: f32): Rettangolo {
    return { x: x, y: y, larghezza: l, altezza: a };
}
```

**Importante:** I tipi struct esportati sono registrati **globalmente** quando il modulo viene caricato. Diventano disponibili automaticamente quando importi qualcosa dal modulo. NON devi (e non puoi) importarli esplicitamente per nome:

```hemlock
// main.hml

// BENE - i tipi struct sono auto-disponibili dopo qualsiasi import dal modulo
import { crea_rett } from "./geometria.hml";
let v: Vettore2 = { x: 1.0, y: 2.0 };      // Funziona - Vettore2 e globalmente disponibile
let r: Rettangolo = crea_rett(0.0, 0.0, 100.0, 50.0);  // Funziona

// MALE - non puoi importare esplicitamente tipi struct per nome
import { Vettore2 } from "./geometria.hml";  // Errore: Variabile 'Vettore2' non definita
```

Questo comportamento esiste perche i tipi struct sono registrati nel registro tipi globale quando il modulo viene caricato, piuttosto che essere memorizzati come valori nell'ambiente export del modulo. Il tipo diventa disponibile a tutto il codice che importa dal modulo.

## Limitazioni Attuali

FFI ha le seguenti limitazioni:

**1. Conversione Tipi Manuale**
- Devi gestire manualmente le conversioni stringa
- Nessuna conversione automatica stringa Hemlock <-> stringa C

**2. Gestione Errori Limitata**
- Reporting errori base
- Le eccezioni nei callback non possono propagarsi a C

**3. Caricamento Librerie Manuale**
- Devi caricare manualmente le librerie
- Nessuna generazione automatica di binding

**4. Codice Specifico per Piattaforma**
- I percorsi delle librerie differiscono per piattaforma
- Devi gestire .so vs .dylib vs .dll

## Migliori Pratiche

Mentre la documentazione FFI completa e ancora in sviluppo, ecco le migliori pratiche generali:

### 1. Type Safety

```hemlock
// Sii esplicito sui tipi
let x: i32 = 42;
let risultato: f64 = funzione_c(x);
```

### 2. Gestione Memoria

```hemlock
// Ricorda di liberare la memoria allocata
let ptr = c_malloc(1024);
// ... usa ptr
c_free(ptr);
```

### 3. Controllo Errori

```hemlock
// Controlla i valori di ritorno
let risultato = funzione_c();
if (risultato == null) {
    print("Funzione C fallita");
}
```

### 4. Compatibilita di Piattaforma

```hemlock
// Gestisci differenze di piattaforma
// Usa estensioni libreria appropriate (.so, .dylib, .dll)
```

## Esempi

Per esempi funzionanti, riferisciti a:
- Test callback: `/tests/ffi_callbacks/` - esempi callback qsort
- Uso FFI stdlib: `/stdlib/hash.hml`, `/stdlib/regex.hml`, `/stdlib/crypto.hml`
- Programmi esempio: `/examples/` (se disponibili)

## Ottenere Aiuto

FFI e una funzionalita piu recente in Hemlock. Per domande o problemi:

1. Controlla la suite di test per esempi funzionanti
2. Riferisciti alla documentazione libffi per dettagli di basso livello
3. Segnala bug o richiedi funzionalita tramite le issue del progetto

## Riepilogo

L'FFI di Hemlock fornisce:

- Chiamata funzioni C da librerie condivise
- Supporto tipi primitivi (i8-i64, u8-u64, f32, f64, ptr)
- Conversione automatica dei tipi
- Portabilita basata su libffi
- Base per integrazione librerie native
- **Callback con puntatori a funzione** - passa funzioni Hemlock a C
- **Esportazione funzioni extern** - condividi binding FFI tra moduli
- **Passaggio e ritorno struct** - passa struct compatibili C per valore
- **Export define** - condividi definizioni tipi struct tra moduli (auto-importati globalmente)
- **Helper puntatori completi** - lettura/scrittura tutti i tipi (i8-i64, u8-u64, f32, f64, ptr)
- **Conversione buffer/puntatore** - `buffer_ptr()`, `ptr_to_buffer()` per marshaling dati
- **Dimensioni tipi FFI** - `ffi_sizeof()` per dimensioni tipi consapevoli della piattaforma
- **Tipi piattaforma** - supporto `size_t`, `usize`, `isize`, `intptr_t`, `uintptr_t`

**Stato attuale:** FFI completamente funzionale con tipi primitivi, struct, callback, esportazioni modulo e funzioni helper puntatori complete

**Futuro:** Helper marshaling stringhe

**Casi d'uso:** Librerie di sistema, librerie terze parti, qsort, event loop, API basate su callback, wrapper librerie riutilizzabili

## Contribuire

La documentazione FFI e in espansione. Se lavori con FFI:
- Documenta i tuoi casi d'uso
- Condividi codice esempio
- Segnala problemi o limitazioni
- Suggerisci miglioramenti

Il sistema FFI e progettato per essere pratico e sicuro fornendo accesso a basso livello quando necessario, seguendo la filosofia di Hemlock di "esplicito piuttosto che implicito" e "unsafe e una funzionalita, non un bug."


--------------------------------------------------------------------------------
## File IO
--------------------------------------------------------------------------------

# I/O su File in Hemlock

Hemlock fornisce un'**API oggetto File** per operazioni sui file con gestione appropriata degli errori e gestione delle risorse.

## Indice

- [Panoramica](#panoramica)
- [Apertura di File](#apertura-di-file)
- [Metodi File](#metodi-file)
- [Proprieta File](#proprieta-file)
- [Gestione degli Errori](#gestione-degli-errori)
- [Gestione delle Risorse](#gestione-delle-risorse)
- [Riferimento API Completo](#riferimento-api-completo)
- [Pattern Comuni](#pattern-comuni)
- [Migliori Pratiche](#migliori-pratiche)

## Panoramica

L'API oggetto File fornisce:

- **Gestione esplicita delle risorse** - I file devono essere chiusi manualmente
- **Modalita di apertura multiple** - Lettura, scrittura, append, lettura/scrittura
- **Operazioni testo e binarie** - Lettura/scrittura sia di dati testo che binari
- **Supporto seeking** - Accesso casuale all'interno dei file
- **Messaggi di errore completi** - Reporting errori consapevole del contesto

**Importante:** I file non vengono chiusi automaticamente. Devi chiamare `f.close()` per evitare leak di file descriptor.

## Apertura di File

Usa `open(percorso, modalita?)` per aprire un file:

```hemlock
let f = open("dati.txt", "r");     // Modalita lettura (predefinita)
let f2 = open("output.txt", "w");  // Modalita scrittura (tronca)
let f3 = open("log.txt", "a");     // Modalita append
let f4 = open("dati.bin", "r+");   // Modalita lettura/scrittura
```

### Modalita di Apertura

| Modalita | Descrizione | File Deve Esistere | Tronca | Posizione |
|----------|-------------|-------------------|--------|-----------|
| `"r"` | Lettura (predefinita) | Si | No | Inizio |
| `"w"` | Scrittura | No (crea) | Si | Inizio |
| `"a"` | Append | No (crea) | No | Fine |
| `"r+"` | Lettura e scrittura | Si | No | Inizio |
| `"w+"` | Lettura e scrittura | No (crea) | Si | Inizio |
| `"a+"` | Lettura e append | No (crea) | No | Fine |

### Esempi

**Lettura di un file esistente:**
```hemlock
let f = open("config.json", "r");
// o semplicemente:
let f = open("config.json");  // "r" e predefinito
```

**Creazione di un nuovo file per scrittura:**
```hemlock
let f = open("output.txt", "w");  // Crea o tronca
```

**Append a un file:**
```hemlock
let f = open("log.txt", "a");  // Crea se non esiste
```

**Modalita lettura e scrittura:**
```hemlock
let f = open("dati.bin", "r+");  // File esistente, puo leggere/scrivere
```

## Metodi File

### Lettura

#### read(dimensione?: i32): string

Legge testo dal file (parametro dimensione opzionale).

**Senza dimensione (leggi tutto):**
```hemlock
let f = open("dati.txt", "r");
let tutto = f.read();  // Legge dalla posizione corrente a EOF
f.close();
```

**Con dimensione (leggi byte specifici):**
```hemlock
let f = open("dati.txt", "r");
let chunk = f.read(1024);  // Legge fino a 1024 byte
let successivo = f.read(1024);   // Legge i successivi 1024 byte
f.close();
```

**Restituisce:** Stringa contenente i dati letti, o stringa vuota se a EOF

**Esempio - Lettura file intero:**
```hemlock
let f = open("poesia.txt", "r");
let contenuto = f.read();
print(contenuto);
f.close();
```

**Esempio - Lettura a chunk:**
```hemlock
let f = open("grande.txt", "r");
while (true) {
    let chunk = f.read(4096);  // Chunk da 4KB
    if (chunk == "") { break; }  // EOF raggiunto
    elabora(chunk);
}
f.close();
```

#### read_bytes(dimensione: i32): buffer

Legge dati binari (restituisce buffer).

**Parametri:**
- `dimensione` (i32) - Numero di byte da leggere

**Restituisce:** Buffer contenente i byte letti

```hemlock
let f = open("immagine.png", "r");
let binario = f.read_bytes(256);  // Legge 256 byte
print(binario.length);  // 256 (o meno se EOF)

// Accedi a byte individuali
let primo_byte = binario[0];
print(primo_byte);

f.close();
```

**Esempio - Lettura file binario intero:**
```hemlock
let f = open("dati.bin", "r");
let dimensione = 10240;  // Dimensione attesa
let dati = f.read_bytes(dimensione);
f.close();

// Elabora dati binari
let i = 0;
while (i < dati.length) {
    let byte = dati[i];
    // ... elabora byte
    i = i + 1;
}
```

### Scrittura

#### write(dati: string): i32

Scrive testo nel file (restituisce byte scritti).

**Parametri:**
- `dati` (string) - Testo da scrivere

**Restituisce:** Numero di byte scritti (i32)

```hemlock
let f = open("output.txt", "w");
let scritti = f.write("Ciao, Mondo!\n");
print("Scritti " + typeof(scritti) + " byte");  // "Scritti 14 byte"
f.close();
```

**Esempio - Scrittura righe multiple:**
```hemlock
let f = open("output.txt", "w");
f.write("Riga 1\n");
f.write("Riga 2\n");
f.write("Riga 3\n");
f.close();
```

**Esempio - Append a file di log:**
```hemlock
let f = open("app.log", "a");
f.write("[INFO] Applicazione avviata\n");
f.write("[INFO] Utente connesso\n");
f.close();
```

#### write_bytes(dati: buffer): i32

Scrive dati binari (restituisce byte scritti).

**Parametri:**
- `dati` (buffer) - Dati binari da scrivere

**Restituisce:** Numero di byte scritti (i32)

```hemlock
let f = open("output.bin", "w");

// Crea dati binari
let buf = buffer(10);
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

let byte = f.write_bytes(buf);
print("Scritti " + typeof(byte) + " byte");

f.close();
```

**Esempio - Copia file binario:**
```hemlock
let src = open("input.bin", "r");
let dst = open("output.bin", "w");

let dati = src.read_bytes(1024);
while (dati.length > 0) {
    dst.write_bytes(dati);
    dati = src.read_bytes(1024);
}

src.close();
dst.close();
```

### Seeking

#### seek(posizione: i32): i32

Sposta a posizione specifica (restituisce nuova posizione).

**Parametri:**
- `posizione` (i32) - Offset in byte dall'inizio del file

**Restituisce:** Nuova posizione (i32)

```hemlock
let f = open("dati.txt", "r");

// Sposta al byte 100
f.seek(100);

// Leggi dalla posizione 100
let dati = f.read(50);

// Resetta all'inizio
f.seek(0);

f.close();
```

**Esempio - Accesso casuale:**
```hemlock
let f = open("records.dat", "r");

// Leggi record all'offset 1000
f.seek(1000);
let record1 = f.read_bytes(100);

// Leggi record all'offset 2000
f.seek(2000);
let record2 = f.read_bytes(100);

f.close();
```

#### tell(): i32

Ottiene posizione corrente nel file.

**Restituisce:** Offset byte corrente (i32)

```hemlock
let f = open("dati.txt", "r");

let pos1 = f.tell();  // 0 (all'inizio)

f.read(100);
let pos2 = f.tell();  // 100 (dopo aver letto 100 byte)

f.seek(500);
let pos3 = f.tell();  // 500 (dopo seeking)

f.close();
```

**Esempio - Misurazione quantita letta:**
```hemlock
let f = open("dati.txt", "r");

let inizio = f.tell();
let contenuto = f.read();
let fine = f.tell();

let byte_letti = fine - inizio;
print("Letti " + typeof(byte_letti) + " byte");

f.close();
```

### Chiusura

#### close()

Chiude file (idempotente, puo essere chiamato piu volte).

```hemlock
let f = open("dati.txt", "r");
// ... usa file
f.close();
f.close();  // Sicuro - nessun errore alla seconda chiusura
```

**Note importanti:**
- Chiudere sempre i file quando finito per evitare leak di file descriptor
- La chiusura e idempotente - puo essere chiamata piu volte in sicurezza
- Dopo la chiusura, tutte le altre operazioni daranno errore
- Usare blocchi `finally` per assicurarsi che i file siano chiusi anche in caso di errori

## Proprieta File

Gli oggetti file hanno tre proprieta di sola lettura:

### path: string

Il percorso del file usato per aprirlo.

```hemlock
let f = open("/percorso/al/file.txt", "r");
print(f.path);  // "/percorso/al/file.txt"
f.close();
```

### mode: string

La modalita con cui il file e stato aperto.

```hemlock
let f = open("dati.txt", "r");
print(f.mode);  // "r"
f.close();

let f2 = open("output.txt", "w");
print(f2.mode);  // "w"
f2.close();
```

### closed: bool

Se il file e chiuso.

```hemlock
let f = open("dati.txt", "r");
print(f.closed);  // false

f.close();
print(f.closed);  // true
```

**Esempio - Controllo se file e aperto:**
```hemlock
let f = open("dati.txt", "r");

if (!f.closed) {
    let contenuto = f.read();
    // ... elabora contenuto
}

f.close();

if (f.closed) {
    print("Il file e ora chiuso");
}
```

## Gestione degli Errori

Tutte le operazioni sui file includono messaggi di errore appropriati con contesto.

### Errori Comuni

**File non trovato:**
```hemlock
let f = open("mancante.txt", "r");
// Errore: Impossibile aprire 'mancante.txt': File o directory non esistente
```

**Lettura da file chiuso:**
```hemlock
let f = open("dati.txt", "r");
f.close();
f.read();
// Errore: Impossibile leggere da file chiuso 'dati.txt'
```

**Scrittura su file di sola lettura:**
```hemlock
let f = open("sololettura.txt", "r");
f.write("dati");
// Errore: Impossibile scrivere su file 'sololettura.txt' aperto in modalita sola lettura
```

**Lettura da file di sola scrittura:**
```hemlock
let f = open("output.txt", "w");
f.read();
// Errore: Impossibile leggere da file 'output.txt' aperto in modalita sola scrittura
```

### Uso di try/catch

```hemlock
try {
    let f = open("dati.txt", "r");
    let contenuto = f.read();
    f.close();
    elabora(contenuto);
} catch (e) {
    print("Errore lettura file: " + e);
}
```

## Gestione delle Risorse

### Pattern Base

Chiudere sempre i file esplicitamente:

```hemlock
let f = open("dati.txt", "r");
let contenuto = f.read();
f.close();
```

### Con Gestione Errori (Raccomandato)

Usare `finally` per assicurarsi che i file siano chiusi anche in caso di errori:

```hemlock
let f = open("dati.txt", "r");
try {
    let contenuto = f.read();
    elabora(contenuto);
} finally {
    f.close();  // Chiude sempre, anche in caso di errore
}
```

### File Multipli

```hemlock
let src = null;
let dst = null;

try {
    src = open("input.txt", "r");
    dst = open("output.txt", "w");

    let contenuto = src.read();
    dst.write(contenuto);
} finally {
    if (src != null) { src.close(); }
    if (dst != null) { dst.close(); }
}
```

### Pattern Funzione Helper

```hemlock
fn con_file(percorso: string, modalita: string, callback) {
    let f = open(percorso, modalita);
    try {
        return callback(f);
    } finally {
        f.close();
    }
}

// Utilizzo:
con_file("dati.txt", "r", fn(f) {
    return f.read();
});
```

## Riferimento API Completo

### Funzioni

| Funzione | Parametri | Restituisce | Descrizione |
|----------|-----------|-------------|-------------|
| `open(percorso, modalita?)` | percorso: string, modalita?: string | File | Apre file (modalita predefinita "r") |

### Metodi

| Metodo | Parametri | Restituisce | Descrizione |
|--------|-----------|-------------|-------------|
| `read(dimensione?)` | dimensione?: i32 | string | Legge testo (tutto o byte specifici) |
| `read_bytes(dimensione)` | dimensione: i32 | buffer | Legge dati binari |
| `write(dati)` | dati: string | i32 | Scrive testo, restituisce byte scritti |
| `write_bytes(dati)` | dati: buffer | i32 | Scrive dati binari, restituisce byte scritti |
| `seek(posizione)` | posizione: i32 | i32 | Vai a posizione, restituisce nuova posizione |
| `tell()` | - | i32 | Ottieni posizione corrente |
| `close()` | - | null | Chiudi file (idempotente) |

### Proprieta (sola lettura)

| Proprieta | Tipo | Descrizione |
|-----------|------|-------------|
| `path` | string | Percorso file |
| `mode` | string | Modalita apertura |
| `closed` | bool | Se il file e chiuso |

## Pattern Comuni

### Lettura File Intero

```hemlock
fn leggi_file(percorso: string): string {
    let f = open(percorso, "r");
    try {
        return f.read();
    } finally {
        f.close();
    }
}

let contenuto = leggi_file("config.json");
```

### Scrittura File Intero

```hemlock
fn scrivi_file(percorso: string, contenuto: string) {
    let f = open(percorso, "w");
    try {
        f.write(contenuto);
    } finally {
        f.close();
    }
}

scrivi_file("output.txt", "Ciao, Mondo!");
```

### Append a File

```hemlock
fn appendi_file(percorso: string, contenuto: string) {
    let f = open(percorso, "a");
    try {
        f.write(contenuto);
    } finally {
        f.close();
    }
}

appendi_file("log.txt", "[INFO] Evento verificato\n");
```

### Lettura Righe

```hemlock
fn leggi_righe(percorso: string) {
    let f = open(percorso, "r");
    try {
        let contenuto = f.read();
        return contenuto.split("\n");
    } finally {
        f.close();
    }
}

let righe = leggi_righe("dati.txt");
let i = 0;
while (i < righe.length) {
    print("Riga " + typeof(i) + ": " + righe[i]);
    i = i + 1;
}
```

### Elaborazione File Grandi a Chunk

```hemlock
fn elabora_file_grande(percorso: string) {
    let f = open(percorso, "r");
    try {
        while (true) {
            let chunk = f.read(4096);  // Chunk da 4KB
            if (chunk == "") { break; }

            // Elabora chunk
            elabora_chunk(chunk);
        }
    } finally {
        f.close();
    }
}
```

### Copia File Binario

```hemlock
fn copia_file(percorso_src: string, percorso_dst: string) {
    let src = null;
    let dst = null;

    try {
        src = open(percorso_src, "r");
        dst = open(percorso_dst, "w");

        while (true) {
            let chunk = src.read_bytes(4096);
            if (chunk.length == 0) { break; }

            dst.write_bytes(chunk);
        }
    } finally {
        if (src != null) { src.close(); }
        if (dst != null) { dst.close(); }
    }
}

copia_file("input.dat", "output.dat");
```

### Troncamento File

```hemlock
fn tronca_file(percorso: string) {
    let f = open(percorso, "w");  // modalita "w" tronca
    f.close();
}

tronca_file("svuotami.txt");
```

### Lettura ad Accesso Casuale

```hemlock
fn leggi_a_offset(percorso: string, offset: i32, dimensione: i32): string {
    let f = open(percorso, "r");
    try {
        f.seek(offset);
        return f.read(dimensione);
    } finally {
        f.close();
    }
}

let dati = leggi_a_offset("records.dat", 1000, 100);
```

### Dimensione File

```hemlock
fn dimensione_file(percorso: string): i32 {
    let f = open(percorso, "r");
    try {
        // Vai alla fine
        let fine = f.seek(999999999);  // Numero grande
        f.seek(0);  // Resetta
        return fine;
    } finally {
        f.close();
    }
}

let dimensione = dimensione_file("dati.txt");
print("Dimensione file: " + typeof(dimensione) + " byte");
```

### Lettura/Scrittura Condizionale

```hemlock
fn aggiorna_file(percorso: string, condizione, nuovo_contenuto: string) {
    let f = open(percorso, "r+");
    try {
        let contenuto = f.read();

        if (condizione(contenuto)) {
            f.seek(0);  // Resetta all'inizio
            f.write(nuovo_contenuto);
        }
    } finally {
        f.close();
    }
}
```

## Migliori Pratiche

### 1. Usare Sempre try/finally

```hemlock
// Bene
let f = open("dati.txt", "r");
try {
    let contenuto = f.read();
    elabora(contenuto);
} finally {
    f.close();
}

// Male - il file potrebbe non chiudersi in caso di errore
let f = open("dati.txt", "r");
let contenuto = f.read();
elabora(contenuto);  // Se questo lancia, il file ha leak
f.close();
```

### 2. Controllare Stato del File Prima delle Operazioni

```hemlock
let f = open("dati.txt", "r");

if (!f.closed) {
    let contenuto = f.read();
    // ... usa contenuto
}

f.close();
```

### 3. Usare Modalita Appropriate

```hemlock
// Solo lettura? Usa "r"
let f = open("config.json", "r");

// Sostituzione completa? Usa "w"
let f = open("output.txt", "w");

// Aggiunta alla fine? Usa "a"
let f = open("log.txt", "a");
```

### 4. Gestire gli Errori con Grazia

```hemlock
fn leggi_file_sicuro(percorso: string): string {
    try {
        let f = open(percorso, "r");
        try {
            return f.read();
        } finally {
            f.close();
        }
    } catch (e) {
        print("Attenzione: Impossibile leggere " + percorso + ": " + e);
        return "";
    }
}
```

### 5. Chiudere File in Ordine Inverso di Apertura

```hemlock
let f1 = null;
let f2 = null;
let f3 = null;

try {
    f1 = open("file1.txt", "r");
    f2 = open("file2.txt", "r");
    f3 = open("file3.txt", "r");

    // ... usa file
} finally {
    // Chiudi in ordine inverso
    if (f3 != null) { f3.close(); }
    if (f2 != null) { f2.close(); }
    if (f1 != null) { f1.close(); }
}
```

### 6. Evitare di Leggere File Grandi Interamente

```hemlock
// Male per file grandi
let f = open("enorme.log", "r");
let contenuto = f.read();  // Carica intero file in memoria
f.close();

// Bene - elabora a chunk
let f = open("enorme.log", "r");
try {
    while (true) {
        let chunk = f.read(4096);
        if (chunk == "") { break; }
        elabora_chunk(chunk);
    }
} finally {
    f.close();
}
```

## Riepilogo

L'API I/O su File di Hemlock fornisce:

- Operazioni sui file semplici ed esplicite
- Supporto testo e binario
- Accesso casuale con seek/tell
- Messaggi di errore chiari con contesto
- Operazione close idempotente

Ricorda:
- Chiudere sempre i file manualmente
- Usare try/finally per sicurezza delle risorse
- Scegliere modalita di apertura appropriate
- Gestire gli errori con grazia
- Elaborare file grandi a chunk


--------------------------------------------------------------------------------
## Impacchettamento e Distribuzione
--------------------------------------------------------------------------------

# Impacchettamento e Distribuzione

Hemlock fornisce strumenti integrati per impacchettare progetti multi-file in singoli file distribuibili e creare eseguibili autonomi.

## Panoramica

| Comando | Output | Caso d'Uso |
|---------|--------|------------|
| `--bundle` | `.hmlc` o `.hmlb` | Distribuire bytecode (richiede Hemlock per l'esecuzione) |
| `--package` | Eseguibile | Binario standalone (nessuna dipendenza) |
| `--compile` | `.hmlc` | Compila singolo file (nessuna risoluzione import) |

## Bundling

Il bundler risolve tutte le istruzioni `import` da un punto di ingresso e le appiattisce in un singolo file.

### Uso Base

```bash
# Impacchetta app.hml e tutti i suoi import in app.hmlc
hemlock --bundle app.hml

# Specifica percorso di output
hemlock --bundle app.hml -o dist/app.hmlc

# Crea bundle compresso (.hmlb) - dimensione file piu piccola
hemlock --bundle app.hml --compress -o app.hmlb

# Output verboso (mostra i moduli risolti)
hemlock --bundle app.hml --verbose
```

### Formati di Output

**`.hmlc` (Non Compresso)**
- Formato AST serializzato
- Veloce da caricare ed eseguire
- Formato di output predefinito

**`.hmlb` (Compresso)**
- `.hmlc` compresso con zlib
- Dimensione file piu piccola (tipicamente riduzione del 50-70%)
- Avvio leggermente piu lento a causa della decompressione

### Esecuzione di File Impacchettati

```bash
# Esegui bundle non compresso
hemlock app.hmlc

# Esegui bundle compresso
hemlock app.hmlb

# Passa argomenti
hemlock app.hmlc arg1 arg2
```

### Esempio: Progetto Multi-Modulo

```
miaapp/
â”œâ”€â”€ main.hml
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ math.hml
â”‚   â””â”€â”€ utils.hml
â””â”€â”€ config.hml
```

```hemlock
// main.hml
import { somma, moltiplica } from "./lib/math.hml";
import { log } from "./lib/utils.hml";
import { VERSIONE } from "./config.hml";

log(`App v${VERSIONE}`);
print(somma(2, 3));
```

```bash
hemlock --bundle miaapp/main.hml -o miaapp.hmlc
hemlock miaapp.hmlc  # Esegue con tutte le dipendenze impacchettate
```

### Import della stdlib

Il bundler risolve automaticamente gli import `@stdlib/`:

```hemlock
import { HashMap } from "@stdlib/collections";
import { now } from "@stdlib/time";
```

Quando impacchettato, i moduli della stdlib sono inclusi nell'output.

## Packaging

Il packaging crea un eseguibile autonomo incorporando il bytecode impacchettato in una copia dell'interprete Hemlock.

### Uso Base

```bash
# Crea eseguibile da app.hml
hemlock --package app.hml

# Specifica nome output
hemlock --package app.hml -o miaapp

# Salta compressione (avvio piu veloce, file piu grande)
hemlock --package app.hml --no-compress

# Output verboso
hemlock --package app.hml --verbose
```

### Esecuzione di Eseguibili Impacchettati

```bash
# L'eseguibile impacchettato viene eseguito direttamente
./miaapp

# Gli argomenti vengono passati allo script
./miaapp arg1 arg2
```

### Formato del Package

Gli eseguibili impacchettati usano il formato HMLP:

```
[binario hemlock][payload HMLB/HMLC][dimensione_payload:u64][magic HMLP:u32]
```

Quando un eseguibile impacchettato viene eseguito:
1. Controlla la presenza di un payload incorporato alla fine del file
2. Se trovato, decomprime ed esegue il payload
3. Se non trovato, si comporta come un normale interprete Hemlock

### Opzioni di Compressione

| Flag | Formato | Avvio | Dimensione |
|------|---------|-------|------------|
| (predefinito) | HMLB | Normale | Piu piccola |
| `--no-compress` | HMLC | Piu veloce | Piu grande |

Per strumenti CLI dove il tempo di avvio e importante, usare `--no-compress`.

## Ispezione dei Bundle

Usa `--info` per ispezionare file impacchettati o compilati:

```bash
hemlock --info app.hmlc
```

Output:
```
=== Info File: app.hmlc ===
Dimensione: 12847 byte
Formato: HMLC (AST compilato)
Versione: 1
Flag: 0x0001 [DEBUG]
Stringhe: 42
Istruzioni: 156
```

```bash
hemlock --info app.hmlb
```

Output:
```
=== Info File: app.hmlb ===
Dimensione: 5234 byte
Formato: HMLB (bundle compresso)
Versione: 1
Non compresso: 12847 byte
Compresso: 5224 byte
Rapporto: riduzione del 59.3%
```

## Compilazione Nativa

Per veri eseguibili nativi (senza interprete), usare il compilatore Hemlock:

```bash
# Compila in eseguibile nativo tramite C
hemlockc app.hml -o app

# Mantieni codice C generato
hemlockc app.hml -o app --keep-c

# Emetti solo C (non compilare)
hemlockc app.hml -c -o app.c

# Livello di ottimizzazione
hemlockc app.hml -o app -O2
```

Il compilatore genera codice C e invoca GCC per produrre un binario nativo. Questo richiede:
- La libreria runtime di Hemlock (`libhemlock_runtime`)
- Un compilatore C (GCC per impostazione predefinita)

### Opzioni del Compilatore

| Opzione | Descrizione |
|---------|-------------|
| `-o <file>` | Nome eseguibile di output |
| `-c` | Emetti solo codice C |
| `--emit-c <file>` | Scrivi C nel file specificato |
| `-k, --keep-c` | Mantieni C generato dopo la compilazione |
| `-O<livello>` | Livello di ottimizzazione (0-3) |
| `--cc <percorso>` | Compilatore C da usare |
| `--runtime <percorso>` | Percorso alla libreria runtime |
| `-v, --verbose` | Output verboso |

## Confronto

| Approccio | Portabilita | Avvio | Dimensione | Dipendenze |
|-----------|-------------|-------|------------|------------|
| `.hml` | Solo sorgente | Tempo di parsing | Piu piccola | Hemlock |
| `.hmlc` | Solo Hemlock | Veloce | Piccola | Hemlock |
| `.hmlb` | Solo Hemlock | Veloce | Piu piccola | Hemlock |
| `--package` | Standalone | Veloce | Piu grande | Nessuna |
| `hemlockc` | Nativo | Piu veloce | Variabile | Librerie runtime |

## Migliori Pratiche

1. **Sviluppo**: Esegui file `.hml` direttamente per iterazione rapida
2. **Distribuzione (con Hemlock)**: Impacchetta con `--compress` per file piu piccoli
3. **Distribuzione (standalone)**: Usa package per deployment senza dipendenze
4. **Prestazioni critiche**: Usa `hemlockc` per compilazione nativa

## Risoluzione Problemi

### "Impossibile trovare stdlib"

Il bundler cerca la stdlib in:
1. `./stdlib` (relativo all'eseguibile)
2. `../stdlib` (relativo all'eseguibile)
3. `/usr/local/lib/hemlock/stdlib`

Assicurati che Hemlock sia installato correttamente o esegui dalla directory sorgente.

### Dipendenze Circolari

```
Errore: Dipendenza circolare rilevata durante il caricamento di 'percorso/al/modulo.hml'
```

Rifattorizza i tuoi import per rompere il ciclo. Considera l'uso di un modulo condiviso per tipi comuni.

### Dimensione Package Grande

- Usa la compressione predefinita (non usare `--no-compress`)
- La dimensione del package include l'intero interprete (~500KB-1MB base)
- Per dimensione minima, usa `hemlockc` per compilazione nativa


--------------------------------------------------------------------------------
## Memory Ownership
--------------------------------------------------------------------------------

# ProprietÃ  della Memoria in Hemlock

> "Ti diamo gli strumenti per essere sicuro, ma non ti obblighiamo a usarli."

Questo documento descrive la semantica della proprietÃ  della memoria in Hemlock, coprendo sia la memoria gestita dal programmatore che i valori gestiti dal runtime.

## Indice

1. [Il Contratto](#il-contratto)
2. [Memoria Gestita dal Programmatore](#memoria-gestita-dal-programmatore)
3. [Valori Gestiti dal Runtime](#valori-gestiti-dal-runtime)
4. [Punti di Trasferimento della ProprietÃ ](#punti-di-trasferimento-della-proprietÃ )
5. [Async e Concorrenza](#async-e-concorrenza)
6. [Regole di Memoria FFI](#regole-di-memoria-ffi)
7. [Sicurezza delle Eccezioni](#sicurezza-delle-eccezioni)
8. [Best Practice](#best-practice)

---

## Il Contratto

Hemlock ha una chiara divisione delle responsabilitÃ  di gestione della memoria:

| Tipo di Memoria | Gestito Da | Metodo di Pulizia |
|-----------------|------------|-------------------|
| Puntatori grezzi (`ptr`) | **Programmatore** | `free(ptr)` |
| Buffer (`buffer`) | **Programmatore** | `free(buf)` |
| String, Array, Oggetti | **Runtime** | Automatico (conteggio riferimenti) |
| Funzioni, Closure | **Runtime** | Automatico (conteggio riferimenti) |
| Task, Channel | **Runtime** | Automatico (conteggio riferimenti) |

**Il principio fondamentale:** Se lo allochi esplicitamente, lo liberi esplicitamente. Tutto il resto viene gestito automaticamente.

---

## Memoria Gestita dal Programmatore

### Puntatori Grezzi

```hemlock
let p = alloc(64);       // Allocare 64 byte
memset(p, 0, 64);        // Inizializzare
// ... usare la memoria ...
free(p);                 // ResponsabilitÃ  tua!
```

**Regole:**
- `alloc()` restituisce memoria che possiedi tu
- Devi chiamare `free()` quando hai finito
- Il double-free causerÃ  un crash (intenzionalmente)
- L'use-after-free Ã¨ comportamento indefinito
- L'aritmetica dei puntatori Ã¨ permessa ma non verificata

### Allocazione Tipizzata

```hemlock
let arr = talloc("i32", 100);  // Allocare 100 i32 (400 byte)
ptr_write_i32(arr, 0, 42);     // Scrivere all'indice 0
let val = ptr_read_i32(arr, 0); // Leggere dall'indice 0
free(arr);                      // Sempre responsabilitÃ  tua
```

### Buffer (Alternativa Sicura)

```hemlock
let buf = buffer(64);    // Buffer con controllo dei limiti
buf[0] = 42;             // Indicizzazione sicura
// buf[100] = 1;         // Errore runtime: fuori dai limiti
free(buf);               // Richiede ancora free esplicito
```

**Differenza chiave:** I buffer forniscono controllo dei limiti, i puntatori grezzi no.

---

## Valori Gestiti dal Runtime

### Conteggio dei Riferimenti

I valori allocati sull'heap usano conteggio dei riferimenti atomico:

```hemlock
let s1 = "hello";        // String allocata, refcount = 1
let s2 = s1;             // s2 condivide s1, refcount = 2
// Quando entrambi escono dallo scope, refcount â†’ 0, memoria liberata
```

**Tipi con conteggio dei riferimenti:**
- `string` - Testo UTF-8
- `array` - Array dinamici
- `object` - Oggetti chiave-valore
- `function` - Closure
- `task` - Handle di task async
- `channel` - Canali di comunicazione

### Rilevamento dei Cicli

Il runtime gestisce i cicli nei grafi di oggetti:

```hemlock
let a = { ref: null };
let b = { ref: a };
a.ref = b;               // Ciclo: a â†’ b â†’ a
// Il runtime usa insiemi visitati per rilevare e spezzare i cicli durante la pulizia
```

---

## Punti di Trasferimento della ProprietÃ 

### Binding di Variabili

```hemlock
let x = [1, 2, 3];       // Array creato con refcount 1
                         // x possiede il riferimento
```

### Ritorni di Funzioni

```hemlock
fn make_array() {
    return [1, 2, 3];    // La proprietÃ  dell'array si trasferisce al chiamante
}
let arr = make_array();  // arr ora possiede il riferimento
```

### Assegnazione

```hemlock
let a = "hello";
let b = a;               // Riferimento condiviso (refcount incrementato)
b = "world";             // a ha ancora "hello", b ha "world"
```

### Operazioni sui Channel

```hemlock
let ch = channel(10);
ch.send("message");      // Valore copiato nel buffer del channel
                         // L'originale rimane valido

let msg = ch.recv();     // Riceve la proprietÃ  dal channel
```

### Spawning di Task

```hemlock
let data = { x: 1 };
let task = spawn(worker, data);  // data viene COPIATO IN PROFONDITÃ€ per isolamento
data.x = 2;                       // Sicuro - il task ha la sua copia
let result = join(task);          // La proprietÃ  del result si trasferisce al chiamante
```

---

## Async e Concorrenza

### Isolamento dei Thread

I task spawnati ricevono **copie profonde** degli argomenti mutabili:

```hemlock
async fn worker(data) {
    data.x = 100;        // Modifica solo la copia del task
    return data;
}

let obj = { x: 1 };
let task = spawn(worker, obj);
obj.x = 2;               // Sicuro - non influenza il task
let result = join(task);
print(obj.x);            // 2 (invariato dal task)
print(result.x);         // 100 (copia modificata del task)
```

### Oggetti di Coordinazione Condivisi

Alcuni tipi sono condivisi per riferimento (non copiati):
- **Channel** - Per la comunicazione tra task
- **Task** - Per la coordinazione (join/detach)

```hemlock
let ch = channel(1);
spawn(producer, ch);     // Stesso channel, non una copia
spawn(consumer, ch);     // Entrambi i task condividono il channel
```

### Risultati dei Task

```hemlock
let task = spawn(compute);
let result = join(task);  // Il chiamante possiede il risultato
                          // Il riferimento del task viene rilasciato quando il task viene liberato
```

### Task Staccati

```hemlock
detach(spawn(background_work));
// Il task gira indipendentemente
// Il risultato viene rilasciato automaticamente quando il task completa
// Nessun leak anche se nessuno chiama join()
```

---

## Regole di Memoria FFI

### Passaggio a Funzioni C

```hemlock
extern fn strlen(s: string): i32;

let s = "hello";
let len = strlen(s);     // Hemlock mantiene la proprietÃ 
                         // La string Ã¨ valida durante la chiamata
                         // La funzione C NON deve liberarla
```

### Ricezione da Funzioni C

```hemlock
extern fn strdup(s: string): ptr;

let copy = strdup("hello");  // C ha allocato questa memoria
free(copy);                   // ResponsabilitÃ  tua liberarla
```

### Passaggio di Struct (Solo Compilatore)

```hemlock
// Definire il layout della struct C
ffi_struct Point { x: f64, y: f64 }

extern fn make_point(x: f64, y: f64): Point;

let p = make_point(1.0, 2.0);  // Restituito per valore, copiato
                                // Nessuna pulizia necessaria per struct sullo stack
```

### Memoria dei Callback

```hemlock
// Quando C richiama Hemlock:
// - Gli argomenti appartengono a C (non liberare)
// - La proprietÃ  del valore di ritorno si trasferisce a C
```

---

## Sicurezza delle Eccezioni

### Garanzie

Il runtime fornisce queste garanzie:

1. **Nessun leak in uscita normale** - Tutti i valori gestiti dal runtime vengono puliti
2. **Nessun leak in eccezione** - I temporanei vengono rilasciati durante lo stack unwinding
3. **Defer esegue in eccezione** - Il codice di pulizia viene eseguito

### Valutazione delle Espressioni

```hemlock
// Se questo lancia durante la creazione dell'array:
let arr = [f(), g(), h()];  // L'array parziale viene rilasciato

// Se questo lancia durante la chiamata di funzione:
foo(a(), b(), c());         // Gli arg precedentemente valutati vengono rilasciati
```

### Defer per la Pulizia

```hemlock
fn process_file() {
    let f = open("data.txt", "r");
    defer f.close();         // Esegue al return O all'eccezione

    let data = f.read();
    if (data == "") {
        throw "Empty file";  // f.close() esegue comunque!
    }
    return data;
}
```

---

## Best Practice

### 1. Preferisci i Tipi Gestiti dal Runtime

```hemlock
// Preferisci questo:
let data = [1, 2, 3, 4, 5];

// A questo (a meno che tu non abbia bisogno di controllo a basso livello):
let data = talloc("i32", 5);
// ... devi ricordarti di liberare ...
```

### 2. Usa Defer per la Memoria Manuale

```hemlock
fn process() {
    let buf = alloc(1024);
    defer free(buf);        // Pulizia garantita

    // ... usare buf ...
    // Non serve liberare ad ogni punto di ritorno
}
```

### 3. Evita i Puntatori Grezzi in Async

```hemlock
// SBAGLIATO - il puntatore potrebbe essere liberato prima che il task completi
let p = alloc(64);
spawn(worker, p);          // Il task ottiene il valore del puntatore
free(p);                   // Ops! Il task lo sta ancora usando

// CORRETTO - usa channel o copia i dati
let ch = channel(1);
let data = buffer(64);
// ... riempire data ...
ch.send(data);             // Copia profonda
spawn(worker, ch);
free(data);                // Sicuro - il task ha la sua copia
```

### 4. Chiudi i Channel Quando Hai Finito

```hemlock
let ch = channel(10);
// ... usare il channel ...
ch.close();                // Svuota e rilascia i valori nel buffer
```

### 5. Join o Detach i Task

```hemlock
let task = spawn(work);

// Opzione 1: Aspettare il risultato
let result = join(task);

// Opzione 2: Fire and forget
// detach(task);

// NON: Lasciare che l'handle del task esca dallo scope senza join o detach
// (VerrÃ  pulito, ma il risultato potrebbe avere leak)
```

---

## Debug dei Problemi di Memoria

### Abilitare ASAN

```bash
make asan
ASAN_OPTIONS=detect_leaks=1 ./hemlock script.hml
```

### Eseguire i Test di Regressione dei Leak

```bash
make leak-regression       # Suite completa
make leak-regression-quick # Salta il test esaustivo
```

### Valgrind

```bash
make valgrind-check FILE=script.hml
```

---

## Riepilogo

| Operazione | Comportamento Memoria |
|------------|----------------------|
| `alloc(n)` | Alloca, tu liberi |
| `buffer(n)` | Alloca con controllo limiti, tu liberi |
| `"string"` | Il runtime gestisce |
| `[array]` | Il runtime gestisce |
| `{object}` | Il runtime gestisce |
| `spawn(fn)` | Copia profonda degli arg, il runtime gestisce il task |
| `join(task)` | Il chiamante possiede il risultato |
| `detach(task)` | Il runtime rilascia il risultato quando finito |
| `ch.send(v)` | Copia il valore nel channel |
| `ch.recv()` | Il chiamante possiede il valore ricevuto |
| `ch.close()` | Svuota e rilascia i valori nel buffer |


--------------------------------------------------------------------------------
## Operazioni Atomiche
--------------------------------------------------------------------------------

# Operazioni Atomiche

Hemlock fornisce operazioni atomiche per la **programmazione concorrente lock-free**. Queste operazioni consentono la manipolazione sicura della memoria condivisa tra piu thread senza l'uso di lock o mutex tradizionali.

## Indice

- [Panoramica](#panoramica)
- [Quando Usare le Atomiche](#quando-usare-le-atomiche)
- [Modello di Memoria](#modello-di-memoria)
- [Load e Store Atomici](#load-e-store-atomici)
- [Operazioni Fetch-and-Modify](#operazioni-fetch-and-modify)
- [Compare-and-Swap (CAS)](#compare-and-swap-cas)
- [Exchange Atomico](#exchange-atomico)
- [Memory Fence](#memory-fence)
- [Riferimento Funzioni](#riferimento-funzioni)
- [Pattern Comuni](#pattern-comuni)
- [Migliori Pratiche](#migliori-pratiche)
- [Limitazioni](#limitazioni)

---

## Panoramica

Le operazioni atomiche sono operazioni **indivisibili** che si completano senza la possibilita di interruzione. Quando un thread esegue un'operazione atomica, nessun altro thread puo osservare l'operazione in uno stato parzialmente completato.

**Caratteristiche principali:**
- Tutte le operazioni usano **consistenza sequenziale** (`memory_order_seq_cst`)
- Tipi supportati: **i32** e **i64**
- Le operazioni lavorano su puntatori raw allocati con `alloc()`
- Thread-safe senza lock espliciti

**Operazioni disponibili:**
- Load/Store - Leggere e scrivere valori atomicamente
- Add/Sub - Operazioni aritmetiche che restituiscono il vecchio valore
- And/Or/Xor - Operazioni bitwise che restituiscono il vecchio valore
- CAS - Compare-and-swap per aggiornamenti condizionali
- Exchange - Scambiare valori atomicamente
- Fence - Barriera di memoria completa

---

## Quando Usare le Atomiche

**Usare le atomiche per:**
- Contatori condivisi tra task (es. conteggio richieste, tracciamento progresso)
- Flag e indicatori di stato
- Strutture dati lock-free
- Primitive di sincronizzazione semplici
- Codice concorrente critico per le prestazioni

**Usare i canali invece quando:**
- Si passano dati complessi tra task
- Si implementano pattern produttore-consumatore
- Si ha bisogno di semantica message-passing

**Esempio di caso d'uso - Contatore condiviso:**
```hemlock
// Alloca contatore condiviso
let contatore = alloc(4);
ptr_write_i32(contatore, 0);

async fn worker(contatore: ptr, id: i32) {
    let i = 0;
    while (i < 1000) {
        atomic_add_i32(contatore, 1);
        i = i + 1;
    }
}

// Crea piu workers
let t1 = spawn(worker, contatore, 1);
let t2 = spawn(worker, contatore, 2);
let t3 = spawn(worker, contatore, 3);

join(t1);
join(t2);
join(t3);

// Il contatore sara esattamente 3000 (nessuna data race)
print(atomic_load_i32(contatore));

free(contatore);
```

---

## Modello di Memoria

Tutte le operazioni atomiche di Hemlock usano **consistenza sequenziale** (`memory_order_seq_cst`), che fornisce le garanzie di ordinamento di memoria piu forti:

1. **Atomicita**: Ogni operazione e indivisibile
2. **Ordinamento totale**: Tutti i thread vedono lo stesso ordine delle operazioni
3. **Nessun riordinamento**: Le operazioni non vengono riordinate dal compilatore o dalla CPU

Questo rende piu semplice il ragionamento sul codice concorrente, a costo di alcune potenziali prestazioni rispetto a ordinamenti di memoria piu deboli.

---

## Load e Store Atomici

### atomic_load_i32 / atomic_load_i64

Legge atomicamente un valore dalla memoria.

**Firma:**
```hemlock
atomic_load_i32(ptr: ptr): i32
atomic_load_i64(ptr: ptr): i64
```

**Parametri:**
- `ptr` - Puntatore alla locazione di memoria (deve essere allineato correttamente)

**Restituisce:** Il valore nella locazione di memoria

**Esempio:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);

let valore = atomic_load_i32(p);
print(valore);  // 42

free(p);
```

---

### atomic_store_i32 / atomic_store_i64

Scrive atomicamente un valore in memoria.

**Firma:**
```hemlock
atomic_store_i32(ptr: ptr, valore: i32): null
atomic_store_i64(ptr: ptr, valore: i64): null
```

**Parametri:**
- `ptr` - Puntatore alla locazione di memoria
- `valore` - Valore da memorizzare

**Restituisce:** `null`

**Esempio:**
```hemlock
let p = alloc(8);

atomic_store_i64(p, 5000000000);
print(atomic_load_i64(p));  // 5000000000

free(p);
```

---

## Operazioni Fetch-and-Modify

Queste operazioni modificano atomicamente un valore e restituiscono il valore **precedente** (vecchio).

### atomic_add_i32 / atomic_add_i64

Aggiunge atomicamente a un valore.

**Firma:**
```hemlock
atomic_add_i32(ptr: ptr, valore: i32): i32
atomic_add_i64(ptr: ptr, valore: i64): i64
```

**Restituisce:** Il valore **precedente** (prima dell'addizione)

**Esempio:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let vecchio = atomic_add_i32(p, 10);
print(vecchio);                    // 100 (valore precedente)
print(atomic_load_i32(p));         // 110 (nuovo valore)

free(p);
```

---

### atomic_sub_i32 / atomic_sub_i64

Sottrae atomicamente da un valore.

**Firma:**
```hemlock
atomic_sub_i32(ptr: ptr, valore: i32): i32
atomic_sub_i64(ptr: ptr, valore: i64): i64
```

**Restituisce:** Il valore **precedente** (prima della sottrazione)

**Esempio:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let vecchio = atomic_sub_i32(p, 25);
print(vecchio);                    // 100 (valore precedente)
print(atomic_load_i32(p));         // 75 (nuovo valore)

free(p);
```

---

### atomic_and_i32 / atomic_and_i64

Esegue atomicamente AND bitwise.

**Firma:**
```hemlock
atomic_and_i32(ptr: ptr, valore: i32): i32
atomic_and_i64(ptr: ptr, valore: i64): i64
```

**Restituisce:** Il valore **precedente** (prima dell'AND)

**Esempio:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xFF);  // 255 in binario: 11111111

let vecchio = atomic_and_i32(p, 0x0F);  // AND con 00001111
print(vecchio);                    // 255 (valore precedente)
print(atomic_load_i32(p));         // 15 (0xFF & 0x0F = 0x0F)

free(p);
```

---

### atomic_or_i32 / atomic_or_i64

Esegue atomicamente OR bitwise.

**Firma:**
```hemlock
atomic_or_i32(ptr: ptr, valore: i32): i32
atomic_or_i64(ptr: ptr, valore: i64): i64
```

**Restituisce:** Il valore **precedente** (prima dell'OR)

**Esempio:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0x0F);  // 15 in binario: 00001111

let vecchio = atomic_or_i32(p, 0xF0);  // OR con 11110000
print(vecchio);                    // 15 (valore precedente)
print(atomic_load_i32(p));         // 255 (0x0F | 0xF0 = 0xFF)

free(p);
```

---

### atomic_xor_i32 / atomic_xor_i64

Esegue atomicamente XOR bitwise.

**Firma:**
```hemlock
atomic_xor_i32(ptr: ptr, valore: i32): i32
atomic_xor_i64(ptr: ptr, valore: i64): i64
```

**Restituisce:** Il valore **precedente** (prima dello XOR)

**Esempio:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xAA);  // 170 in binario: 10101010

let vecchio = atomic_xor_i32(p, 0xFF);  // XOR con 11111111
print(vecchio);                    // 170 (valore precedente)
print(atomic_load_i32(p));         // 85 (0xAA ^ 0xFF = 0x55)

free(p);
```

---

## Compare-and-Swap (CAS)

L'operazione atomica piu potente. Confronta atomicamente il valore attuale con un valore atteso e, se corrispondono, lo sostituisce con un nuovo valore.

### atomic_cas_i32 / atomic_cas_i64

**Firma:**
```hemlock
atomic_cas_i32(ptr: ptr, atteso: i32, desiderato: i32): bool
atomic_cas_i64(ptr: ptr, atteso: i64, desiderato: i64): bool
```

**Parametri:**
- `ptr` - Puntatore alla locazione di memoria
- `atteso` - Valore che ci aspettiamo di trovare
- `desiderato` - Valore da memorizzare se l'aspettativa corrisponde

**Restituisce:**
- `true` - Scambio riuscito (il valore era `atteso`, ora e `desiderato`)
- `false` - Scambio fallito (il valore non era `atteso`, invariato)

**Esempio:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

// CAS riuscito: il valore e 100, scambia a 999
let successo1 = atomic_cas_i32(p, 100, 999);
print(successo1);                  // true
print(atomic_load_i32(p));         // 999

// CAS fallito: il valore e 999, non 100
let successo2 = atomic_cas_i32(p, 100, 888);
print(successo2);                  // false
print(atomic_load_i32(p));         // 999 (invariato)

free(p);
```

**Casi d'uso:**
- Implementazione di lock e semafori
- Strutture dati lock-free
- Controllo di concorrenza ottimistico
- Aggiornamenti condizionali atomici

---

## Exchange Atomico

Scambia atomicamente un valore, restituendo il vecchio valore.

### atomic_exchange_i32 / atomic_exchange_i64

**Firma:**
```hemlock
atomic_exchange_i32(ptr: ptr, valore: i32): i32
atomic_exchange_i64(ptr: ptr, valore: i64): i64
```

**Parametri:**
- `ptr` - Puntatore alla locazione di memoria
- `valore` - Nuovo valore da memorizzare

**Restituisce:** Il valore **precedente** (prima dello scambio)

**Esempio:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let vecchio = atomic_exchange_i32(p, 200);
print(vecchio);                    // 100 (valore precedente)
print(atomic_load_i32(p));         // 200 (nuovo valore)

free(p);
```

---

## Memory Fence

Una barriera di memoria completa che assicura che tutte le operazioni di memoria prima della fence siano visibili a tutti i thread prima di qualsiasi operazione dopo la fence.

### atomic_fence

**Firma:**
```hemlock
atomic_fence(): null
```

**Restituisce:** `null`

**Esempio:**
```hemlock
// Assicura che tutte le scritture precedenti siano visibili
atomic_fence();
```

**Nota:** Nella maggior parte dei casi, non hai bisogno di fence esplicite perche tutte le operazioni atomiche gia usano consistenza sequenziale. Le fence sono utili quando hai bisogno di sincronizzare operazioni di memoria non atomiche.

---

## Riferimento Funzioni

### Operazioni i32

| Funzione | Firma | Restituisce | Descrizione |
|----------|-------|-------------|-------------|
| `atomic_load_i32` | `(ptr)` | `i32` | Carica valore atomicamente |
| `atomic_store_i32` | `(ptr, valore)` | `null` | Memorizza valore atomicamente |
| `atomic_add_i32` | `(ptr, valore)` | `i32` | Aggiunge e restituisce vecchio valore |
| `atomic_sub_i32` | `(ptr, valore)` | `i32` | Sottrae e restituisce vecchio valore |
| `atomic_and_i32` | `(ptr, valore)` | `i32` | AND bitwise e restituisce vecchio valore |
| `atomic_or_i32` | `(ptr, valore)` | `i32` | OR bitwise e restituisce vecchio valore |
| `atomic_xor_i32` | `(ptr, valore)` | `i32` | XOR bitwise e restituisce vecchio valore |
| `atomic_cas_i32` | `(ptr, atteso, desiderato)` | `bool` | Compare-and-swap |
| `atomic_exchange_i32` | `(ptr, valore)` | `i32` | Scambia e restituisce vecchio valore |

### Operazioni i64

| Funzione | Firma | Restituisce | Descrizione |
|----------|-------|-------------|-------------|
| `atomic_load_i64` | `(ptr)` | `i64` | Carica valore atomicamente |
| `atomic_store_i64` | `(ptr, valore)` | `null` | Memorizza valore atomicamente |
| `atomic_add_i64` | `(ptr, valore)` | `i64` | Aggiunge e restituisce vecchio valore |
| `atomic_sub_i64` | `(ptr, valore)` | `i64` | Sottrae e restituisce vecchio valore |
| `atomic_and_i64` | `(ptr, valore)` | `i64` | AND bitwise e restituisce vecchio valore |
| `atomic_or_i64` | `(ptr, valore)` | `i64` | OR bitwise e restituisce vecchio valore |
| `atomic_xor_i64` | `(ptr, valore)` | `i64` | XOR bitwise e restituisce vecchio valore |
| `atomic_cas_i64` | `(ptr, atteso, desiderato)` | `bool` | Compare-and-swap |
| `atomic_exchange_i64` | `(ptr, valore)` | `i64` | Scambia e restituisce vecchio valore |

### Barriera di Memoria

| Funzione | Firma | Restituisce | Descrizione |
|----------|-------|-------------|-------------|
| `atomic_fence` | `()` | `null` | Barriera di memoria completa |

---

## Pattern Comuni

### Pattern: Contatore Atomico

```hemlock
// Contatore thread-safe
let contatore = alloc(4);
ptr_write_i32(contatore, 0);

fn incrementa(): i32 {
    return atomic_add_i32(contatore, 1);
}

fn decrementa(): i32 {
    return atomic_sub_i32(contatore, 1);
}

fn ottieni_conteggio(): i32 {
    return atomic_load_i32(contatore);
}

// Utilizzo
incrementa();  // Restituisce 0 (vecchio valore)
incrementa();  // Restituisce 1
incrementa();  // Restituisce 2
print(ottieni_conteggio());  // 3

free(contatore);
```

### Pattern: Spinlock

```hemlock
// Implementazione semplice di spinlock
let lock = alloc(4);
ptr_write_i32(lock, 0);  // 0 = sbloccato, 1 = bloccato

fn acquisisci() {
    // Gira finche non riesce a impostare il lock da 0 a 1
    while (!atomic_cas_i32(lock, 0, 1)) {
        // Attesa attiva
    }
}

fn rilascia() {
    atomic_store_i32(lock, 0);
}

// Utilizzo
acquisisci();
// ... sezione critica ...
rilascia();

free(lock);
```

### Pattern: Inizializzazione Una Tantum

```hemlock
let inizializzato = alloc(4);
ptr_write_i32(inizializzato, 0);  // 0 = non inizializzato, 1 = inizializzato

fn assicura_inizializzato() {
    // Prova a essere quello che inizializza
    if (atomic_cas_i32(inizializzato, 0, 1)) {
        // Abbiamo vinto la gara, esegui l'inizializzazione
        esegui_inizializzazione_costosa();
    }
    // Altrimenti, gia inizializzato
}
```

### Pattern: Flag Atomico

```hemlock
let flag = alloc(4);
ptr_write_i32(flag, 0);

fn imposta_flag() {
    atomic_store_i32(flag, 1);
}

fn resetta_flag() {
    atomic_store_i32(flag, 0);
}

fn test_and_set(): bool {
    // Restituisce true se il flag era gia impostato
    return atomic_exchange_i32(flag, 1) == 1;
}

fn controlla_flag(): bool {
    return atomic_load_i32(flag) == 1;
}
```

### Pattern: Contatore Limitato

```hemlock
let contatore = alloc(4);
ptr_write_i32(contatore, 0);
let valore_massimo = 100;

fn prova_incrementa(): bool {
    while (true) {
        let corrente = atomic_load_i32(contatore);
        if (corrente >= valore_massimo) {
            return false;  // Al massimo
        }
        if (atomic_cas_i32(contatore, corrente, corrente + 1)) {
            return true;  // Incrementato con successo
        }
        // CAS fallito, un altro thread ha modificato - riprova
    }
}
```

---

## Migliori Pratiche

### 1. Usare Allineamento Corretto

I puntatori devono essere allineati correttamente per il tipo di dato:
- i32: allineamento 4 byte
- i64: allineamento 8 byte

La memoria da `alloc()` e tipicamente allineata correttamente.

### 2. Preferire Astrazioni di Alto Livello

Quando possibile, usare i canali per la comunicazione inter-task. Le atomiche sono di livello piu basso e richiedono ragionamento attento.

```hemlock
// Preferire questo:
let ch = channel(10);
spawn(fn() { ch.send(risultato); });
let valore = ch.recv();

// Invece di coordinazione atomica manuale quando appropriato
```

### 3. Essere Consapevoli del Problema ABA

CAS puo soffrire del problema ABA: un valore cambia da A a B e torna ad A. Il tuo CAS ha successo, ma lo stato potrebbe essere cambiato nel frattempo.

### 4. Inizializzare Prima di Condividere

Inizializzare sempre le variabili atomiche prima di creare task che le accedono:

```hemlock
let contatore = alloc(4);
ptr_write_i32(contatore, 0);  // Inizializza PRIMA di fare spawn

let task = spawn(worker, contatore);
```

### 5. Liberare Dopo il Completamento di Tutti i Task

Non liberare memoria atomica mentre i task potrebbero ancora accedervi:

```hemlock
let contatore = alloc(4);
ptr_write_i32(contatore, 0);

let t1 = spawn(worker, contatore);
let t2 = spawn(worker, contatore);

join(t1);
join(t2);

// Ora e sicuro liberare
free(contatore);
```

---

## Limitazioni

### Limitazioni Attuali

1. **Solo i32 e i64 supportati** - Nessuna operazione atomica per altri tipi
2. **Nessuna atomica per puntatori** - Non si possono caricare/memorizzare puntatori atomicamente
3. **Solo consistenza sequenziale** - Nessun ordinamento di memoria piu debole disponibile
4. **Nessuna atomica in virgola mobile** - Usare rappresentazione intera se necessario

### Note sulla Piattaforma

- Le operazioni atomiche usano C11 `<stdatomic.h>` internamente
- Disponibile su tutte le piattaforme che supportano thread POSIX
- Garantito essere lock-free su moderni sistemi a 64 bit

---

## Vedi Anche

- [Async/Concorrenza](#advanced-async-concurrency) - Creazione di task e canali
- [Gestione della Memoria](#language-guide-memory) - Allocazione di puntatori e buffer
- [API Memoria](#reference-memory-api) - Funzioni di allocazione


--------------------------------------------------------------------------------
## Profilazione
--------------------------------------------------------------------------------

# Profilazione

Hemlock include un profiler integrato per **analisi del tempo CPU**, **tracciamento della memoria** e **rilevamento leak**. Il profiler aiuta a identificare colli di bottiglia delle prestazioni e problemi di memoria nei tuoi programmi.

## Indice

- [Panoramica](#panoramica)
- [Avvio Rapido](#avvio-rapido)
- [Modalita di Profilazione](#modalita-di-profilazione)
- [Formati di Output](#formati-di-output)
- [Rilevamento Leak](#rilevamento-leak)
- [Comprensione dei Report](#comprensione-dei-report)
- [Generazione Flamegraph](#generazione-flamegraph)
- [Migliori Pratiche](#migliori-pratiche)

---

## Panoramica

Il profiler e accessibile tramite il sottocomando `profile`:

```bash
hemlock profile [OPZIONI] <FILE>
```

**Funzionalita principali:**
- **Profilazione CPU** - Misura il tempo speso in ogni funzione (self-time e total-time)
- **Profilazione memoria** - Traccia tutte le allocazioni con locazioni sorgente
- **Rilevamento leak** - Identifica memoria mai liberata
- **Formati output multipli** - Testo, JSON e output compatibile flamegraph
- **Statistiche memoria per-funzione** - Vedi quali funzioni allocano piu memoria

---

## Avvio Rapido

### Profila tempo CPU (predefinito)

```bash
hemlock profile script.hml
```

### Profila allocazioni memoria

```bash
hemlock profile --memory script.hml
```

### Rileva memory leak

```bash
hemlock profile --leaks script.hml
```

### Genera dati flamegraph

```bash
hemlock profile --flamegraph script.hml > profile.folded
flamegraph.pl profile.folded > profile.svg
```

---

## Modalita di Profilazione

### Profilazione CPU (predefinita)

Misura il tempo speso in ogni funzione, distinguendo tra:
- **Self time** - Tempo speso nell'esecuzione del codice proprio della funzione
- **Total time** - Self time piu tempo speso nelle funzioni chiamate

```bash
hemlock profile script.hml
hemlock profile --cpu script.hml  # Esplicito
```

**Esempio output:**
```
=== Report Profiler Hemlock ===

Tempo totale: 1.234ms
Funzioni chiamate: 5 uniche

--- Top 5 per Self Time ---

Funzione                        Self      Total   Chiamate
--------                        ----      -----   --------
calcolo_costoso             0.892ms    0.892ms     100  (72.3%)
elabora_dati                0.234ms    1.126ms      10  (19.0%)
helper                      0.067ms    0.067ms     500  (5.4%)
main                        0.041ms    1.234ms       1  (3.3%)
```

---

### Profilazione Memoria

Traccia tutte le allocazioni di memoria (`alloc`, `buffer`, `talloc`, `realloc`) con locazioni sorgente.

```bash
hemlock profile --memory script.hml
```

**Esempio output:**
```
=== Report Profiler Hemlock ===

Tempo totale: 0.543ms
Funzioni chiamate: 3 uniche
Allocazioni totali: 15 (4.2KB)

--- Top 3 per Self Time ---

Funzione                        Self      Total   Chiamate      Alloc      Conteggio
--------                        ----      -----   --------      -----      ---------
allocatore                  0.312ms    0.312ms      10      3.2KB         10  (57.5%)
operazioni_buffer           0.156ms    0.156ms       5       1KB          5  (28.7%)
main                        0.075ms    0.543ms       1        0B          0  (13.8%)

--- Top 10 Siti di Allocazione ---

Locazione                                     Totale    Conteggio
---------                                     ------    ---------
src/data.hml:42                               1.5KB        5
src/data.hml:67                               1.0KB       10
src/main.hml:15                               512B         1
```

---

### Modalita Conteggio Chiamate

Modalita a overhead minimo che conta solo le chiamate a funzione (nessun timing).

```bash
hemlock profile --calls script.hml
```

---

## Formati di Output

### Testo (predefinito)

Riepilogo leggibile con tabelle.

```bash
hemlock profile script.hml
```

---

### JSON

Formato leggibile dalla macchina per integrazione con altri strumenti.

```bash
hemlock profile --json script.hml
```

**Esempio output:**
```json
{
  "total_time_ns": 1234567,
  "function_count": 5,
  "total_alloc_bytes": 4096,
  "total_alloc_count": 15,
  "functions": [
    {
      "name": "calcolo_costoso",
      "source_file": "script.hml",
      "line": 10,
      "self_time_ns": 892000,
      "total_time_ns": 892000,
      "call_count": 100,
      "alloc_bytes": 0,
      "alloc_count": 0
    }
  ],
  "alloc_sites": [
    {
      "source_file": "script.hml",
      "line": 42,
      "total_bytes": 1536,
      "alloc_count": 5,
      "current_bytes": 0
    }
  ]
}
```

---

### Flamegraph

Genera formato stack collapsed compatibile con [flamegraph.pl](https://github.com/brendangregg/FlameGraph).

```bash
hemlock profile --flamegraph script.hml > profile.folded

# Genera SVG con flamegraph.pl
flamegraph.pl profile.folded > profile.svg
```

**Esempio output folded:**
```
main;elabora_dati;calcolo_costoso 892
main;elabora_dati;helper 67
main;elabora_dati 234
main 41
```

---

## Rilevamento Leak

Il flag `--leaks` mostra solo allocazioni mai liberate, rendendo facile identificare memory leak.

```bash
hemlock profile --leaks script.hml
```

**Esempio programma con leak:**
```hemlock
fn leaky() {
    let p1 = alloc(100);    // Leak - mai liberato
    let p2 = alloc(200);    // OK - liberato sotto
    free(p2);
}

fn pulito() {
    let b = buffer(64);
    free(b);                // Liberato correttamente
}

leaky();
pulito();
```

**Output con --leaks:**
```
=== Report Profiler Hemlock ===

Tempo totale: 0.034ms
Funzioni chiamate: 2 uniche
Allocazioni totali: 3 (388B)

--- Top 2 per Self Time ---

Funzione                        Self      Total   Chiamate      Alloc      Conteggio
--------                        ----      -----   --------      -----      ---------
leaky                       0.021ms    0.021ms       1       300B          2  (61.8%)
pulito                      0.013ms    0.013ms       1        88B          1  (38.2%)

--- Memory Leak (1 sito) ---

Locazione                                    Leaked      Totale    Conteggio
---------                                    ------      ------    ---------
script.hml:2                                   100B       100B        1
```

Il report leak mostra:
- **Leaked** - Byte attualmente non liberati all'uscita del programma
- **Totale** - Byte totali mai allocati in questo sito
- **Conteggio** - Numero di allocazioni in questo sito

---

## Comprensione dei Report

### Statistiche Funzioni

| Colonna | Descrizione |
|---------|-------------|
| Funzione | Nome funzione |
| Self | Tempo nella funzione escludendo funzioni chiamate |
| Total | Tempo includendo tutte le funzioni chiamate |
| Chiamate | Numero di volte che la funzione e stata chiamata |
| Alloc | Byte totali allocati da questa funzione |
| Conteggio | Numero di allocazioni da questa funzione |
| (%) | Percentuale del tempo totale del programma |

### Siti di Allocazione

| Colonna | Descrizione |
|---------|-------------|
| Locazione | File sorgente e numero riga |
| Totale | Byte totali allocati in questa locazione |
| Conteggio | Numero di allocazioni |
| Leaked | Byte ancora allocati all'uscita del programma (solo --leaks) |

### Unita di Tempo

Il profiler seleziona automaticamente le unita appropriate:
- `ns` - Nanosecondi (< 1us)
- `us` - Microsecondi (< 1ms)
- `ms` - Millisecondi (< 1s)
- `s` - Secondi

---

## Riferimento Comandi

```
hemlock profile [OPZIONI] <FILE>

OPZIONI:
    --cpu           Profilazione CPU/tempo (predefinito)
    --memory        Profilazione allocazione memoria
    --calls         Solo conteggio chiamate (overhead minimo)
    --leaks         Mostra solo allocazioni non liberate (implica --memory)
    --json          Output in formato JSON
    --flamegraph    Output in formato compatibile flamegraph
    --top N         Mostra top N voci (predefinito: 20)
```

---

## Generazione Flamegraph

I flamegraph visualizzano dove il tuo programma spende tempo, con barre piu larghe che indicano piu tempo speso.

### Genera un Flamegraph

1. Installa flamegraph.pl:
   ```bash
   git clone https://github.com/brendangregg/FlameGraph
   ```

2. Profila il tuo programma:
   ```bash
   hemlock profile --flamegraph script.hml > profile.folded
   ```

3. Genera SVG:
   ```bash
   ./FlameGraph/flamegraph.pl profile.folded > profile.svg
   ```

4. Apri `profile.svg` in un browser per una visualizzazione interattiva.

### Lettura dei Flamegraph

- **Asse X**: Percentuale del tempo totale (larghezza = proporzione tempo)
- **Asse Y**: Profondita stack chiamate (basso = punto di ingresso, alto = funzioni foglia)
- **Colore**: Casuale, solo per distinzione visiva
- **Click**: Zoom in una funzione per vedere le sue funzioni chiamate

---

## Migliori Pratiche

### 1. Profilare Carichi di Lavoro Rappresentativi

Profila con dati e pattern di utilizzo realistici. Casi di test piccoli potrebbero non rivelare veri colli di bottiglia.

```bash
# Bene: Profila con dati simili alla produzione
hemlock profile --memory elabora_file_grande.hml grande_input.txt

# Meno utile: Caso di test piccolo
hemlock profile test_veloce.hml
```

### 2. Usare --leaks Durante lo Sviluppo

Esegui rilevamento leak regolarmente per catturare memory leak presto:

```bash
hemlock profile --leaks mio_programma.hml
```

### 3. Confrontare Prima e Dopo

Profila prima e dopo le ottimizzazioni per misurare l'impatto:

```bash
# Prima dell'ottimizzazione
hemlock profile --json script.hml > prima.json

# Dopo l'ottimizzazione
hemlock profile --json script.hml > dopo.json

# Confronta risultati
```

### 4. Usare --top per Programmi Grandi

Limita l'output per concentrarti sulle funzioni piu significative:

```bash
hemlock profile --top 10 programma_grande.hml
```

### 5. Combinare con Flamegraph

Per pattern di chiamata complessi, i flamegraph forniscono migliore visualizzazione rispetto all'output testuale:

```bash
hemlock profile --flamegraph app_complessa.hml > app.folded
flamegraph.pl app.folded > app.svg
```

---

## Overhead del Profiler

Il profiler aggiunge un po' di overhead all'esecuzione del programma:

| Modalita | Overhead | Caso d'Uso |
|----------|----------|------------|
| `--calls` | Minimo | Solo conteggio chiamate funzione |
| `--cpu` | Basso | Profilazione prestazioni generale |
| `--memory` | Moderato | Analisi memoria e rilevamento leak |

Per risultati piu accurati, profila piu volte e cerca pattern consistenti.

---

## Vedi Anche

- [Gestione Memoria](#language-guide-memory) - Puntatori e buffer
- [API Memoria](#reference-memory-api) - Funzioni alloc, free, buffer
- [Async/Concorrenza](#advanced-async-concurrency) - Profilazione codice async


--------------------------------------------------------------------------------
## Segnali
--------------------------------------------------------------------------------

# Gestione dei Segnali in Hemlock

Hemlock fornisce **gestione dei segnali POSIX** per gestire segnali di sistema come SIGINT (Ctrl+C), SIGTERM e segnali personalizzati. Questo abilita il controllo di processo a basso livello e la comunicazione inter-processo.

## Indice

- [Panoramica](#panoramica)
- [API Segnali](#api-segnali)
- [Costanti dei Segnali](#costanti-dei-segnali)
- [Gestione Base dei Segnali](#gestione-base-dei-segnali)
- [Pattern Avanzati](#pattern-avanzati)
- [Comportamento del Gestore di Segnali](#comportamento-del-gestore-di-segnali)
- [Considerazioni sulla Sicurezza](#considerazioni-sulla-sicurezza)
- [Casi d'Uso Comuni](#casi-duso-comuni)
- [Esempi Completi](#esempi-completi)

## Panoramica

La gestione dei segnali permette ai programmi di:
- Rispondere a interruzioni dell'utente (Ctrl+C, Ctrl+Z)
- Implementare shutdown graceful
- Gestire richieste di terminazione
- Usare segnali personalizzati per comunicazione inter-processo
- Creare meccanismi di alarm/timer

**Importante:** La gestione dei segnali e **intrinsecamente unsafe** nella filosofia di Hemlock. I gestori possono essere chiamati in qualsiasi momento, interrompendo l'esecuzione normale. L'utente e responsabile della corretta sincronizzazione.

## API Segnali

### signal(signum, funzione_gestore)

Registra una funzione gestore di segnali.

**Parametri:**
- `signum` (i32) - Numero del segnale (costante come SIGINT, SIGTERM)
- `funzione_gestore` (funzione o null) - Funzione da chiamare quando il segnale viene ricevuto, o `null` per ripristinare il predefinito

**Restituisce:** La precedente funzione gestore (o `null` se nessuna)

**Esempio:**
```hemlock
fn mio_gestore(sig) {
    print("Catturato segnale: " + typeof(sig));
}

let vecchio_gestore = signal(SIGINT, mio_gestore);
```

**Ripristino al predefinito:**
```hemlock
signal(SIGINT, null);  // Ripristina SIGINT al comportamento predefinito
```

### raise(signum)

Invia un segnale al processo corrente.

**Parametri:**
- `signum` (i32) - Numero del segnale da inviare

**Restituisce:** `null`

**Esempio:**
```hemlock
raise(SIGUSR1);  // Attiva il gestore SIGUSR1
```

## Costanti dei Segnali

Hemlock fornisce costanti di segnali POSIX standard come valori i32.

### Interruzione e Terminazione

| Costante | Valore | Descrizione | Trigger Comune |
|----------|--------|-------------|----------------|
| `SIGINT` | 2 | Interrupt da tastiera | Ctrl+C |
| `SIGTERM` | 15 | Richiesta di terminazione | Comando `kill` |
| `SIGQUIT` | 3 | Quit da tastiera | Ctrl+\ |
| `SIGHUP` | 1 | Hangup rilevato | Terminale chiuso |
| `SIGABRT` | 6 | Segnale abort | Funzione `abort()` |

**Esempi:**
```hemlock
signal(SIGINT, gestisci_interrupt);   // Ctrl+C
signal(SIGTERM, gestisci_termina);    // Comando kill
signal(SIGHUP, gestisci_hangup);      // Terminale si chiude
```

### Segnali Definiti dall'Utente

| Costante | Valore | Descrizione | Caso d'Uso |
|----------|--------|-------------|------------|
| `SIGUSR1` | 10 | Segnale definito dall'utente 1 | IPC personalizzato |
| `SIGUSR2` | 12 | Segnale definito dall'utente 2 | IPC personalizzato |

**Esempi:**
```hemlock
// Usa per comunicazione personalizzata
signal(SIGUSR1, ricarica_config);
signal(SIGUSR2, ruota_log);
```

### Controllo Processo

| Costante | Valore | Descrizione | Note |
|----------|--------|-------------|------|
| `SIGALRM` | 14 | Timer alarm | Dopo `alarm()` |
| `SIGCHLD` | 17 | Cambio stato processo figlio | Gestione processi |
| `SIGCONT` | 18 | Continua se fermato | Riprendi dopo SIGSTOP |
| `SIGSTOP` | 19 | Ferma processo | **Non puo essere catturato** |
| `SIGTSTP` | 20 | Stop da terminale | Ctrl+Z |

**Esempi:**
```hemlock
signal(SIGALRM, gestisci_timeout);
signal(SIGCHLD, gestisci_uscita_figlio);
```

### Segnali I/O

| Costante | Valore | Descrizione | Quando Inviato |
|----------|--------|-------------|----------------|
| `SIGPIPE` | 13 | Pipe rotta | Scrittura su pipe chiusa |
| `SIGTTIN` | 21 | Lettura background da terminale | Processo BG legge TTY |
| `SIGTTOU` | 22 | Scrittura background a terminale | Processo BG scrive TTY |

**Esempi:**
```hemlock
signal(SIGPIPE, gestisci_pipe_rotta);
```

## Gestione Base dei Segnali

### Catturare Ctrl+C

```hemlock
let interrotto = false;

fn gestisci_interrupt(sig) {
    print("Catturato SIGINT!");
    interrotto = true;
}

signal(SIGINT, gestisci_interrupt);

// Il programma continua l'esecuzione...
// L'utente preme Ctrl+C -> gestisci_interrupt() viene chiamato

while (!interrotto) {
    // Fai lavoro...
}

print("Uscita per interrupt");
```

### Firma della Funzione Gestore

I gestori di segnali ricevono un argomento: il numero del segnale (i32)

```hemlock
fn mio_gestore(signum) {
    print("Ricevuto segnale: " + typeof(signum));
    // signum contiene il numero del segnale (es. 2 per SIGINT)

    if (signum == SIGINT) {
        print("Questo e SIGINT");
    }
}

signal(SIGINT, mio_gestore);
signal(SIGTERM, mio_gestore);  // Stesso gestore per segnali multipli
```

### Gestori di Segnali Multipli

Gestori diversi per segnali diversi:

```hemlock
fn gestisci_int(sig) {
    print("SIGINT ricevuto");
}

fn gestisci_term(sig) {
    print("SIGTERM ricevuto");
}

fn gestisci_usr1(sig) {
    print("SIGUSR1 ricevuto");
}

signal(SIGINT, gestisci_int);
signal(SIGTERM, gestisci_term);
signal(SIGUSR1, gestisci_usr1);
```

### Ripristino al Comportamento Predefinito

Passa `null` come gestore per ripristinare il comportamento predefinito:

```hemlock
// Registra gestore personalizzato
signal(SIGINT, mio_gestore);

// Dopo, ripristina al predefinito (termina su SIGINT)
signal(SIGINT, null);
```

### Invio Manuale di Segnali

Invia segnali al tuo stesso processo:

```hemlock
let conteggio = 0;

fn incrementa(sig) {
    conteggio = conteggio + 1;
}

signal(SIGUSR1, incrementa);

// Attiva gestore manualmente
raise(SIGUSR1);
raise(SIGUSR1);

print(conteggio);  // 2
```

## Pattern Avanzati

### Pattern Shutdown Graceful

Pattern comune per pulizia alla terminazione:

```hemlock
let deve_uscire = false;

fn gestisci_shutdown(sig) {
    print("Shutdown graceful in corso...");
    deve_uscire = true;
}

signal(SIGINT, gestisci_shutdown);
signal(SIGTERM, gestisci_shutdown);

// Loop principale
while (!deve_uscire) {
    // Fai lavoro...
    // Controlla flag deve_uscire periodicamente
}

print("Pulizia completata");
```

### Contatore di Segnali

Traccia numero di segnali ricevuti:

```hemlock
let conteggio_segnali = 0;

fn conta_segnali(sig) {
    conteggio_segnali = conteggio_segnali + 1;
    print("Ricevuti " + typeof(conteggio_segnali) + " segnali");
}

signal(SIGUSR1, conta_segnali);

// Dopo...
print("Segnali totali: " + typeof(conteggio_segnali));
```

### Ricarica Configurazione su Segnale

```hemlock
let config = carica_config();

fn ricarica_config(sig) {
    print("Ricarica configurazione in corso...");
    config = carica_config();
    print("Configurazione ricaricata");
}

signal(SIGHUP, ricarica_config);  // Ricarica su SIGHUP

// Invia SIGHUP al processo per ricaricare config
// Da shell: kill -HUP <pid>
```

### Timeout Usando SIGALRM

```hemlock
let scaduto = false;

fn gestisci_alarm(sig) {
    print("Timeout!");
    scaduto = true;
}

signal(SIGALRM, gestisci_alarm);

// Imposta alarm (non ancora implementato in Hemlock, solo esempio)
// alarm(5);  // timeout 5 secondi

while (!scaduto) {
    // Fai lavoro con timeout
}
```

### Macchina a Stati Basata su Segnali

```hemlock
let stato = 0;

fn stato_successivo(sig) {
    stato = (stato + 1) % 3;
    print("Stato: " + typeof(stato));
}

fn stato_precedente(sig) {
    stato = (stato - 1 + 3) % 3;
    print("Stato: " + typeof(stato));
}

signal(SIGUSR1, stato_successivo);  // Avanza stato
signal(SIGUSR2, stato_precedente);  // Torna indietro

// Controlla macchina a stati:
// kill -USR1 <pid>  # Stato successivo
// kill -USR2 <pid>  # Stato precedente
```

## Comportamento del Gestore di Segnali

### Note Importanti

**Esecuzione del Gestore:**
- I gestori sono chiamati **sincronamente** quando il segnale viene ricevuto
- I gestori vengono eseguiti nel contesto del processo corrente
- I gestori di segnali condividono l'ambiente closure della funzione in cui sono definiti
- I gestori possono accedere e modificare variabili dello scope esterno (come globali o variabili catturate)

**Migliori Pratiche:**
- Mantieni i gestori semplici e veloci - evita operazioni a lunga esecuzione
- Imposta flag piuttosto che eseguire logica complessa
- Evita di chiamare funzioni che potrebbero prendere lock
- Sii consapevole che i gestori possono interrompere qualsiasi operazione

### Quali Segnali Possono Essere Catturati

**Possono essere catturati e gestiti:**
- SIGINT, SIGTERM, SIGUSR1, SIGUSR2, SIGHUP, SIGQUIT
- SIGALRM, SIGCHLD, SIGCONT, SIGTSTP
- SIGPIPE, SIGTTIN, SIGTTOU
- SIGABRT (ma il programma abortira dopo che il gestore ritorna)

**Non possono essere catturati:**
- `SIGKILL` (9) - Termina sempre il processo
- `SIGSTOP` (19) - Ferma sempre il processo

**Dipendenti dal sistema:**
- Alcuni segnali hanno comportamenti predefiniti che possono differire per sistema
- Controlla la documentazione dei segnali della tua piattaforma per specifiche

### Limitazioni dei Gestori

```hemlock
fn gestore_complesso(sig) {
    // Evita questi nei gestori di segnali:

    // âŒ Operazioni a lunga esecuzione
    // elabora_file_grande();

    // âŒ I/O bloccante
    // let f = open("log.txt", "a");
    // f.write("Segnale ricevuto\n");

    // âŒ Cambiamenti di stato complessi
    // ricostruisci_intera_struttura_dati();

    // âœ“ Semplice impostazione flag e sicura
    let deve_fermarsi = true;

    // âœ“ Semplici aggiornamenti contatore sono generalmente sicuri
    let conteggio_segnali = conteggio_segnali + 1;
}
```

## Considerazioni sulla Sicurezza

La gestione dei segnali e **intrinsecamente unsafe** nella filosofia di Hemlock.

### Race Condition

I gestori possono essere chiamati in qualsiasi momento, interrompendo l'esecuzione normale:

```hemlock
let contatore = 0;

fn incrementa(sig) {
    contatore = contatore + 1;  // Race condition se chiamato durante aggiornamento contatore
}

signal(SIGUSR1, incrementa);

// Il codice principale modifica anche il contatore
contatore = contatore + 1;  // Potrebbe essere interrotto dal gestore di segnali
```

**Problema:** Se il segnale arriva mentre il codice principale sta aggiornando `contatore`, il risultato e imprevedibile.

### Async-Signal-Safety

Hemlock **non** garantisce async-signal-safety:
- I gestori possono chiamare qualsiasi codice Hemlock (a differenza delle funzioni C async-signal-safe limitate)
- Questo fornisce flessibilita ma richiede cautela dell'utente
- Race condition sono possibili se il gestore modifica stato condiviso

### Migliori Pratiche per Gestione Segnali Sicura

**1. Usa Flag Atomici**

Semplici assegnazioni booleane sono generalmente sicure:

```hemlock
let deve_uscire = false;

fn gestore(sig) {
    deve_uscire = true;  // Semplice assegnazione e sicura
}

signal(SIGINT, gestore);

while (!deve_uscire) {
    // lavoro...
}
```

**2. Minimizza Stato Condiviso**

```hemlock
let conteggio_interrupt = 0;

fn gestore(sig) {
    // Modifica solo questa variabile
    conteggio_interrupt = conteggio_interrupt + 1;
}
```

**3. Rinvia Operazioni Complesse**

```hemlock
let ricarica_pendente = false;

fn segnala_ricarica(sig) {
    ricarica_pendente = true;  // Solo imposta flag
}

signal(SIGHUP, segnala_ricarica);

// Nel loop principale:
while (true) {
    if (ricarica_pendente) {
        ricarica_config();  // Fai lavoro complesso qui
        ricarica_pendente = false;
    }

    // Lavoro normale...
}
```

**4. Evita Problemi di Rientranza**

```hemlock
let in_sezione_critica = false;
let dati = [];

fn gestore_attento(sig) {
    if (in_sezione_critica) {
        // Non modificare dati mentre il codice principale li sta usando
        return;
    }
    // Sicuro procedere
}
```

## Casi d'Uso Comuni

### 1. Shutdown Graceful del Server

```hemlock
let in_esecuzione = true;

fn shutdown(sig) {
    print("Segnale shutdown ricevuto");
    in_esecuzione = false;
}

signal(SIGINT, shutdown);
signal(SIGTERM, shutdown);

// Loop principale server
while (in_esecuzione) {
    gestisci_richiesta_client();
}

pulisci_risorse();
print("Server fermato");
```

### 2. Ricarica Configurazione (Senza Riavvio)

```hemlock
let config = carica_config("app.conf");
let ricarica_necessaria = false;

fn attiva_ricarica(sig) {
    ricarica_necessaria = true;
}

signal(SIGHUP, attiva_ricarica);

while (true) {
    if (ricarica_necessaria) {
        print("Ricarica configurazione in corso...");
        config = carica_config("app.conf");
        ricarica_necessaria = false;
    }

    // Usa config...
}
```

### 3. Rotazione Log

```hemlock
let file_log = open("app.log", "a");
let rotazione_necessaria = false;

fn attiva_rotazione(sig) {
    rotazione_necessaria = true;
}

signal(SIGUSR1, attiva_rotazione);

while (true) {
    if (rotazione_necessaria) {
        file_log.close();
        // Rinomina vecchio log, apri nuovo
        exec("mv app.log app.log.old");
        file_log = open("app.log", "a");
        rotazione_necessaria = false;
    }

    // Logging normale...
    file_log.write("Voce log\n");
}
```

### 4. Report di Stato

```hemlock
let richieste_gestite = 0;

fn riporta_stato(sig) {
    print("Stato: " + typeof(richieste_gestite) + " richieste gestite");
}

signal(SIGUSR1, riporta_stato);

while (true) {
    gestisci_richiesta();
    richieste_gestite = richieste_gestite + 1;
}

// Da shell: kill -USR1 <pid>
```

### 5. Toggle Modalita Debug

```hemlock
let modalita_debug = false;

fn toggle_debug(sig) {
    modalita_debug = !modalita_debug;
    if (modalita_debug) {
        print("Modalita debug: ON");
    } else {
        print("Modalita debug: OFF");
    }
}

signal(SIGUSR2, toggle_debug);

// Da shell: kill -USR2 <pid> per toggle
```

## Esempi Completi

### Esempio 1: Gestore Interrupt con Pulizia

```hemlock
let in_esecuzione = true;
let conteggio_segnali = 0;

fn gestisci_segnale(signum) {
    conteggio_segnali = conteggio_segnali + 1;

    if (signum == SIGINT) {
        print("Interrupt rilevato (Ctrl+C)");
        in_esecuzione = false;
    }

    if (signum == SIGUSR1) {
        print("Segnale utente 1 ricevuto");
    }
}

// Registra gestori
signal(SIGINT, gestisci_segnale);
signal(SIGUSR1, gestisci_segnale);

// Simula del lavoro
let i = 0;
while (in_esecuzione && i < 100) {
    print("Lavoro in corso... " + typeof(i));

    // Attiva SIGUSR1 ogni 10 iterazioni
    if (i == 10 || i == 20) {
        raise(SIGUSR1);
    }

    i = i + 1;
}

print("Segnali totali ricevuti: " + typeof(conteggio_segnali));
```

### Esempio 2: Macchina a Stati Multi-Segnale

```hemlock
let stato = "idle";
let conteggio_richieste = 0;

fn inizia_elaborazione(sig) {
    stato = "elaborazione";
    print("Stato: " + stato);
}

fn ferma_elaborazione(sig) {
    stato = "idle";
    print("Stato: " + stato);
}

fn riporta_statistiche(sig) {
    print("Stato: " + stato);
    print("Richieste: " + typeof(conteggio_richieste));
}

signal(SIGUSR1, inizia_elaborazione);
signal(SIGUSR2, ferma_elaborazione);
signal(SIGHUP, riporta_statistiche);

while (true) {
    if (stato == "elaborazione") {
        // Fai lavoro
        conteggio_richieste = conteggio_richieste + 1;
    }

    // Controlla ogni iterazione...
}
```

### Esempio 3: Controller Pool di Worker

```hemlock
let conteggio_worker = 4;
let deve_uscire = false;

fn aumenta_worker(sig) {
    conteggio_worker = conteggio_worker + 1;
    print("Worker: " + typeof(conteggio_worker));
}

fn diminuisci_worker(sig) {
    if (conteggio_worker > 1) {
        conteggio_worker = conteggio_worker - 1;
    }
    print("Worker: " + typeof(conteggio_worker));
}

fn shutdown(sig) {
    print("Shutdown in corso...");
    deve_uscire = true;
}

signal(SIGUSR1, aumenta_worker);
signal(SIGUSR2, diminuisci_worker);
signal(SIGINT, shutdown);
signal(SIGTERM, shutdown);

// Il loop principale regola il pool worker basandosi su conteggio_worker
while (!deve_uscire) {
    // Gestisci worker basandoti su conteggio_worker
    // ...
}
```

### Esempio 4: Pattern Timeout

```hemlock
let operazione_completata = false;
let scaduto = false;

fn gestore_timeout(sig) {
    scaduto = true;
}

signal(SIGALRM, gestore_timeout);

// Avvia operazione lunga
async fn operazione_lunga() {
    // ... lavoro
    operazione_completata = true;
}

let task = spawn(operazione_lunga);

// Attendi con timeout (controllo manuale)
let trascorso = 0;
while (!operazione_completata && trascorso < 1000) {
    // Sleep o controlla
    trascorso = trascorso + 1;
}

if (!operazione_completata) {
    print("Operazione scaduta");
    detach(task);  // Rinuncia ad aspettare
} else {
    join(task);
    print("Operazione completata");
}
```

## Debug dei Gestori di Segnali

### Aggiungi Print Diagnostici

```hemlock
fn gestore_debug(sig) {
    print("Gestore chiamato per segnale: " + typeof(sig));
    print("Stack: (non ancora disponibile)");

    // La tua logica del gestore...
}

signal(SIGINT, gestore_debug);
```

### Conta Chiamate al Gestore

```hemlock
let chiamate_gestore = 0;

fn gestore_contatore(sig) {
    chiamate_gestore = chiamate_gestore + 1;
    print("Chiamata gestore #" + typeof(chiamate_gestore));

    // La tua logica del gestore...
}
```

### Testa con raise()

```hemlock
fn gestore_test(sig) {
    print("Segnale test ricevuto: " + typeof(sig));
}

signal(SIGUSR1, gestore_test);

// Testa invocando manualmente
raise(SIGUSR1);
print("Il gestore avrebbe dovuto essere chiamato");
```

## Riepilogo

La gestione dei segnali di Hemlock fornisce:

- Gestione segnali POSIX per controllo processo a basso livello
- 15 costanti segnali standard
- Semplice API signal() e raise()
- Funzioni gestore flessibili con supporto closure
- Segnali multipli possono condividere gestori

Ricorda:
- La gestione dei segnali e intrinsecamente unsafe - usare con cautela
- Mantieni i gestori semplici e veloci
- Usa flag per cambiamenti di stato, non operazioni complesse
- I gestori possono interrompere l'esecuzione in qualsiasi momento
- Non si possono catturare SIGKILL o SIGSTOP
- Testa i gestori accuratamente con raise()

Pattern comuni:
- Shutdown graceful (SIGINT, SIGTERM)
- Ricarica configurazione (SIGHUP)
- Rotazione log (SIGUSR1)
- Report di stato (SIGUSR1/SIGUSR2)
- Toggle modalita debug (SIGUSR2)



################################################################################
# RIFERIMENTO API
################################################################################

--------------------------------------------------------------------------------
## API degli Array
--------------------------------------------------------------------------------

# Riferimento API degli Array

Riferimento completo per il tipo array di Hemlock e tutti i suoi 18 metodi.

---

## Panoramica

Gli array in Hemlock sono sequenze **dinamiche, allocate nell'heap** che possono contenere tipi misti. Forniscono metodi completi per la manipolazione e l'elaborazione dei dati.

**Caratteristiche Principali:**
- Dimensionamento dinamico (crescita automatica)
- Indicizzazione a base zero
- Tipi misti consentiti
- 18 metodi integrati
- Allocati nell'heap con tracciamento della capacitÃ 

---

## Tipo Array

**Tipo:** `array`

**ProprietÃ :**
- `.length` - Numero di elementi (i32)

**Sintassi Letterale:** Parentesi quadre `[elem1, elem2, ...]`

**Esempi:**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);     // 5

// Tipi misti
let misto = [1, "ciao", true, null];
print(misto.length);   // 4

// Array vuoto
let vuoto = [];
print(vuoto.length);   // 0
```

---

## Indicizzazione

Gli array supportano l'indicizzazione a base zero usando `[]`:

**Accesso in Lettura:**
```hemlock
let arr = [10, 20, 30];
print(arr[0]);         // 10
print(arr[1]);         // 20
print(arr[2]);         // 30
```

**Accesso in Scrittura:**
```hemlock
let arr = [10, 20, 30];
arr[0] = 99;
arr[1] = 88;
print(arr);            // [99, 88, 30]
```

**Nota:** L'indicizzazione diretta non ha controllo dei limiti. Usa i metodi per maggiore sicurezza.

---

## ProprietÃ  degli Array

### .length

Ottiene il numero di elementi nell'array.

**Tipo:** `i32`

**Esempi:**
```hemlock
let arr = [1, 2, 3];
print(arr.length);     // 3

let vuoto = [];
print(vuoto.length);   // 0

// La lunghezza cambia dinamicamente
arr.push(4);
print(arr.length);     // 4

arr.pop();
print(arr.length);     // 3
```

---

## Metodi degli Array

### Operazioni di Stack

#### push

Aggiunge un elemento alla fine dell'array.

**Firma:**
```hemlock
array.push(valore: any): null
```

**Parametri:**
- `valore` - Elemento da aggiungere

**Restituisce:** `null`

**Modifica:** SÃ¬ (modifica l'array in loco)

**Esempi:**
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]
arr.push("ciao");      // [1, 2, 3, 4, 5, "ciao"]
```

---

#### pop

Rimuove e restituisce l'ultimo elemento.

**Firma:**
```hemlock
array.pop(): any
```

**Restituisce:** Ultimo elemento (rimosso dall'array)

**Modifica:** SÃ¬ (modifica l'array in loco)

**Esempi:**
```hemlock
let arr = [1, 2, 3];
let ultimo = arr.pop();  // 3
print(arr);              // [1, 2]

let ultimo2 = arr.pop(); // 2
print(arr);              // [1]
```

**Errore:** Errore a runtime se l'array Ã¨ vuoto.

---

### Operazioni di Coda

#### shift

Rimuove e restituisce il primo elemento.

**Firma:**
```hemlock
array.shift(): any
```

**Restituisce:** Primo elemento (rimosso dall'array)

**Modifica:** SÃ¬ (modifica l'array in loco)

**Esempi:**
```hemlock
let arr = [1, 2, 3];
let primo = arr.shift();   // 1
print(arr);                // [2, 3]

let primo2 = arr.shift();  // 2
print(arr);                // [3]
```

**Errore:** Errore a runtime se l'array Ã¨ vuoto.

---

#### unshift

Aggiunge un elemento all'inizio dell'array.

**Firma:**
```hemlock
array.unshift(valore: any): null
```

**Parametri:**
- `valore` - Elemento da aggiungere

**Restituisce:** `null`

**Modifica:** SÃ¬ (modifica l'array in loco)

**Esempi:**
```hemlock
let arr = [2, 3];
arr.unshift(1);        // [1, 2, 3]
arr.unshift(0);        // [0, 1, 2, 3]
```

---

### Inserimento e Rimozione

#### insert

Inserisce un elemento a un indice specifico.

**Firma:**
```hemlock
array.insert(indice: i32, valore: any): null
```

**Parametri:**
- `indice` - Posizione di inserimento (base 0)
- `valore` - Elemento da inserire

**Restituisce:** `null`

**Modifica:** SÃ¬ (modifica l'array in loco)

**Esempi:**
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // [1, 2, 3, 4, 5]

let arr2 = [1, 3];
arr2.insert(1, 2);     // [1, 2, 3]

// Inserisci alla fine
arr2.insert(arr2.length, 4);  // [1, 2, 3, 4]
```

**Comportamento:** Sposta gli elementi dall'indice in poi verso destra.

---

#### remove

Rimuove e restituisce l'elemento all'indice specificato.

**Firma:**
```hemlock
array.remove(indice: i32): any
```

**Parametri:**
- `indice` - Posizione da cui rimuovere (base 0)

**Restituisce:** Elemento rimosso

**Modifica:** SÃ¬ (modifica l'array in loco)

**Esempi:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let rimosso = arr.remove(0);  // 1
print(arr);                   // [2, 3, 4, 5]

let rimosso2 = arr.remove(2); // 4
print(arr);                   // [2, 3, 5]
```

**Comportamento:** Sposta gli elementi dopo l'indice verso sinistra.

**Errore:** Errore a runtime se l'indice Ã¨ fuori dai limiti.

---

### Ricerca e Trova

#### find

Trova la prima occorrenza di un valore.

**Firma:**
```hemlock
array.find(valore: any): i32
```

**Parametri:**
- `valore` - Valore da cercare

**Restituisce:** Indice della prima occorrenza, o `-1` se non trovato

**Esempi:**
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2
let idx2 = arr.find(99);     // -1 (non trovato)

// Trova il primo duplicato
let arr2 = [1, 2, 3, 2, 4];
let idx3 = arr2.find(2);     // 1 (prima occorrenza)
```

**Confronto:** Usa l'uguaglianza di valore per i primitivi e le stringhe.

---

#### contains

Verifica se l'array contiene un valore.

**Firma:**
```hemlock
array.contains(valore: any): bool
```

**Parametri:**
- `valore` - Valore da cercare

**Restituisce:** `true` se trovato, `false` altrimenti

**Esempi:**
```hemlock
let arr = [10, 20, 30, 40];
let ha = arr.contains(20);   // true
let ha2 = arr.contains(99);  // false

// Funziona con le stringhe
let parole = ["ciao", "mondo"];
let ha3 = parole.contains("ciao");  // true
```

---

### Slicing ed Estrazione

#### slice

Estrae un sottoarray per intervallo (fine esclusiva).

**Firma:**
```hemlock
array.slice(inizio: i32, fine: i32): array
```

**Parametri:**
- `inizio` - Indice iniziale (base 0, inclusivo)
- `fine` - Indice finale (esclusivo)

**Restituisce:** Nuovo array con elementi da [inizio, fine)

**Modifica:** No (restituisce un nuovo array)

**Esempi:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);       // [2, 3, 4]
let primi_tre = arr.slice(0, 3); // [1, 2, 3]
let ultimi_due = arr.slice(3, 5);// [4, 5]

// Slice vuoto
let vuoto = arr.slice(2, 2);     // []
```

---

#### first

Ottiene il primo elemento senza rimuoverlo.

**Firma:**
```hemlock
array.first(): any
```

**Restituisce:** Primo elemento

**Modifica:** No

**Esempi:**
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1
print(arr);                  // [1, 2, 3] (invariato)
```

**Errore:** Errore a runtime se l'array Ã¨ vuoto.

---

#### last

Ottiene l'ultimo elemento senza rimuoverlo.

**Firma:**
```hemlock
array.last(): any
```

**Restituisce:** Ultimo elemento

**Modifica:** No

**Esempi:**
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3
print(arr);                  // [1, 2, 3] (invariato)
```

**Errore:** Errore a runtime se l'array Ã¨ vuoto.

---

### Manipolazione degli Array

#### reverse

Inverte l'array in loco.

**Firma:**
```hemlock
array.reverse(): null
```

**Restituisce:** `null`

**Modifica:** SÃ¬ (modifica l'array in loco)

**Esempi:**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]
print(arr);                  // [5, 4, 3, 2, 1]

let parole = ["ciao", "mondo"];
parole.reverse();            // ["mondo", "ciao"]
```

---

#### clear

Rimuove tutti gli elementi dall'array.

**Firma:**
```hemlock
array.clear(): null
```

**Restituisce:** `null`

**Modifica:** SÃ¬ (modifica l'array in loco)

**Esempi:**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();
print(arr);                  // []
print(arr.length);           // 0
```

---

### Combinazione di Array

#### concat

Concatena con un altro array.

**Firma:**
```hemlock
array.concat(altro: array): array
```

**Parametri:**
- `altro` - Array da concatenare

**Restituisce:** Nuovo array con elementi da entrambi gli array

**Modifica:** No (restituisce un nuovo array)

**Esempi:**
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combinato = a.concat(b);  // [1, 2, 3, 4, 5, 6]
print(a);                     // [1, 2, 3] (invariato)
print(b);                     // [4, 5, 6] (invariato)

// Concatenazione a catena
let c = [7, 8];
let tutti = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]
```

---

### Operazioni Funzionali

#### map

Trasforma ogni elemento usando una funzione callback.

**Firma:**
```hemlock
array.map(callback: fn): array
```

**Parametri:**
- `callback` - Funzione che prende un elemento e restituisce il valore trasformato

**Restituisce:** Nuovo array con elementi trasformati

**Modifica:** No (restituisce un nuovo array)

**Esempi:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let raddoppiato = arr.map(fn(x) { return x * 2; });
print(raddoppiato);  // [2, 4, 6, 8, 10]

let nomi = ["alice", "bob"];
let maiuscolo = nomi.map(fn(s) { return s.to_upper(); });
print(maiuscolo);  // ["ALICE", "BOB"]
```

---

#### filter

Seleziona gli elementi che corrispondono a un predicato.

**Firma:**
```hemlock
array.filter(predicato: fn): array
```

**Parametri:**
- `predicato` - Funzione che prende un elemento e restituisce bool

**Restituisce:** Nuovo array con elementi per cui il predicato ha restituito true

**Modifica:** No (restituisce un nuovo array)

**Esempi:**
```hemlock
let arr = [1, 2, 3, 4, 5, 6];
let pari = arr.filter(fn(x) { return x % 2 == 0; });
print(pari);  // [2, 4, 6]

let parole = ["ciao", "io", "hey", "arrivederci"];
let corte = parole.filter(fn(s) { return s.length < 4; });
print(corte);  // ["io", "hey"]
```

---

#### reduce

Riduce l'array a un singolo valore usando un accumulatore.

**Firma:**
```hemlock
array.reduce(callback: fn, iniziale: any): any
```

**Parametri:**
- `callback` - Funzione che prende (accumulatore, elemento) e restituisce il nuovo accumulatore
- `iniziale` - Valore iniziale per l'accumulatore

**Restituisce:** Valore finale accumulato

**Modifica:** No

**Esempi:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let somma = arr.reduce(fn(acc, x) { return acc + x; }, 0);
print(somma);  // 15

let prodotto = arr.reduce(fn(acc, x) { return acc * x; }, 1);
print(prodotto);  // 120

// Trova il valore massimo
let max = arr.reduce(fn(acc, x) {
    if (x > acc) { return x; }
    return acc;
}, arr[0]);
print(max);  // 5
```

---

### Conversione a Stringa

#### join

Unisce gli elementi in una stringa con un delimitatore.

**Firma:**
```hemlock
array.join(delimitatore: string): string
```

**Parametri:**
- `delimitatore` - Stringa da inserire tra gli elementi

**Restituisce:** Stringa con tutti gli elementi uniti

**Esempi:**
```hemlock
let parole = ["ciao", "mondo", "foo"];
let unito = parole.join(" ");  // "ciao mondo foo"

let numeri = [1, 2, 3];
let csv = numeri.join(",");    // "1,2,3"

// Funziona con tipi misti
let misto = [1, "ciao", true, null];
print(misto.join(" | "));  // "1 | ciao | true | null"

// Delimitatore vuoto
let arr = ["a", "b", "c"];
let s = arr.join("");          // "abc"
```

**Comportamento:** Converte automaticamente tutti gli elementi in stringhe.

---

## Concatenamento di Metodi

I metodi degli array possono essere concatenati per operazioni concise:

**Esempi:**
```hemlock
// Concatena slice e join
let risultato = ["mela", "banana", "ciliegia", "dattero"]
    .slice(0, 2)
    .join(" e ");  // "mela e banana"

// Concatena concat e slice
let combinato = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);    // [3, 4, 5]

// Concatenamento complesso
let parole = ["ciao", "mondo", "foo", "bar"];
let risultato2 = parole
    .slice(0, 3)
    .concat(["baz"])
    .join("-");      // "ciao-mondo-foo-baz"
```

---

## Riepilogo Completo dei Metodi

### Metodi Modificanti

Metodi che modificano l'array in loco:

| Metodo     | Firma                      | Restituisce | Descrizione                    |
|------------|----------------------------|-------------|--------------------------------|
| `push`     | `(valore: any)`            | `null`      | Aggiunge alla fine             |
| `pop`      | `()`                       | `any`       | Rimuove dalla fine             |
| `shift`    | `()`                       | `any`       | Rimuove dall'inizio            |
| `unshift`  | `(valore: any)`            | `null`      | Aggiunge all'inizio            |
| `insert`   | `(indice: i32, valore: any)` | `null`    | Inserisce all'indice           |
| `remove`   | `(indice: i32)`            | `any`       | Rimuove all'indice             |
| `reverse`  | `()`                       | `null`      | Inverte in loco                |
| `clear`    | `()`                       | `null`      | Rimuove tutti gli elementi     |

### Metodi Non Modificanti

Metodi che restituiscono nuovi valori senza modificare l'originale:

| Metodo     | Firma                      | Restituisce | Descrizione                    |
|------------|----------------------------|-------------|--------------------------------|
| `find`     | `(valore: any)`            | `i32`       | Trova la prima occorrenza      |
| `contains` | `(valore: any)`            | `bool`      | Verifica se contiene il valore |
| `slice`    | `(inizio: i32, fine: i32)` | `array`     | Estrae sottoarray              |
| `first`    | `()`                       | `any`       | Ottiene il primo elemento      |
| `last`     | `()`                       | `any`       | Ottiene l'ultimo elemento      |
| `concat`   | `(altro: array)`           | `array`     | Concatena array                |
| `join`     | `(delimitatore: string)`   | `string`    | Unisce elementi in stringa     |
| `map`      | `(callback: fn)`           | `array`     | Trasforma ogni elemento        |
| `filter`   | `(predicato: fn)`          | `array`     | Seleziona elementi corrispondenti |
| `reduce`   | `(callback: fn, iniziale: any)` | `any`  | Riduce a un singolo valore     |

---

## Pattern di Utilizzo

### Uso come Stack

```hemlock
let stack = [];

// Push degli elementi
stack.push(1);
stack.push(2);
stack.push(3);

// Pop degli elementi
while (stack.length > 0) {
    let elemento = stack.pop();
    print(elemento);  // 3, 2, 1
}
```

### Uso come Coda

```hemlock
let coda = [];

// Accodamento
coda.push(1);
coda.push(2);
coda.push(3);

// Decodifica
while (coda.length > 0) {
    let elemento = coda.shift();
    print(elemento);  // 1, 2, 3
}
```

### Trasformazione di Array

```hemlock
// Filtro (manuale)
let numeri = [1, 2, 3, 4, 5, 6];
let pari = [];
let i = 0;
while (i < numeri.length) {
    if (numeri[i] % 2 == 0) {
        pari.push(numeri[i]);
    }
    i = i + 1;
}

// Map (manuale)
let numeri2 = [1, 2, 3, 4, 5];
let raddoppiato = [];
let j = 0;
while (j < numeri2.length) {
    raddoppiato.push(numeri2[j] * 2);
    j = j + 1;
}
```

### Costruzione di Array

```hemlock
let arr = [];

// Costruisci array con ciclo
let i = 0;
while (i < 10) {
    arr.push(i * 10);
    i = i + 1;
}

print(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
```

---

## Dettagli di Implementazione

**Gestione della CapacitÃ :**
- Gli array crescono automaticamente quando necessario
- La capacitÃ  raddoppia quando viene superata
- Nessun controllo manuale della capacitÃ 

**Confronto dei Valori:**
- `find()` e `contains()` usano l'uguaglianza di valore
- Funziona correttamente per primitivi e stringhe
- Oggetti/array confrontati per riferimento

**Memoria:**
- Allocati nell'heap
- Nessuna liberazione automatica (gestione manuale della memoria)
- Nessun controllo dei limiti sull'accesso diretto all'indice

---

## Vedi Anche

- [Sistema di Tipi](#reference-type-system) - Dettagli sul tipo array
- [API delle Stringhe](#reference-string-api) - Risultati di string join()
- [Operatori](#reference-operators) - Operatore di indicizzazione degli array


--------------------------------------------------------------------------------
## API dei File
--------------------------------------------------------------------------------

# Riferimento API dei File

Riferimento completo per il sistema di I/O su file di Hemlock.

---

## Panoramica

Hemlock fornisce un'**API a oggetti File** per le operazioni sui file con gestione appropriata degli errori e gestione delle risorse. I file devono essere aperti e chiusi manualmente.

**Caratteristiche Principali:**
- Oggetto file con metodi
- Lettura/scrittura di dati testuali e binari
- Ricerca e posizionamento
- Messaggi di errore appropriati
- Gestione manuale delle risorse (no RAII)

---

## Tipo File

**Tipo:** `file`

**Descrizione:** Handle di file per operazioni di I/O

**ProprietÃ  (Sola Lettura):**
- `.path` - Percorso del file (string)
- `.mode` - ModalitÃ  di apertura (string)
- `.closed` - Se il file Ã¨ chiuso (bool)

---

## Apertura dei File

### open

Apre un file per lettura, scrittura o entrambe.

**Firma:**
```hemlock
open(percorso: string, modalita?: string): file
```

**Parametri:**
- `percorso` - Percorso del file (relativo o assoluto)
- `modalita` (opzionale) - ModalitÃ  di apertura (predefinito: `"r"`)

**Restituisce:** Oggetto file

**ModalitÃ :**
- `"r"` - Lettura (predefinita)
- `"w"` - Scrittura (tronca file esistente)
- `"a"` - Append
- `"r+"` - Lettura e scrittura
- `"w+"` - Lettura e scrittura (tronca)
- `"a+"` - Lettura e append

**Esempi:**
```hemlock
// ModalitÃ  lettura (predefinita)
let f = open("dati.txt");
let f_lettura = open("dati.txt", "r");

// ModalitÃ  scrittura (tronca)
let f_scrittura = open("output.txt", "w");

// ModalitÃ  append
let f_append = open("log.txt", "a");

// ModalitÃ  lettura/scrittura
let f_rw = open("dati.bin", "r+");

// Lettura/scrittura (tronca)
let f_rw_trunc = open("output.bin", "w+");

// Lettura/append
let f_ra = open("log.txt", "a+");
```

**Gestione degli Errori:**
```hemlock
try {
    let f = open("mancante.txt", "r");
} catch (e) {
    print("Apertura fallita:", e);
    // Errore: Impossibile aprire 'mancante.txt': File o directory inesistente
}
```

**Importante:** I file devono essere chiusi manualmente con `f.close()` per evitare perdite di descrittori di file.

---

## Metodi dei File

### Lettura

#### read

Legge testo dal file.

**Firma:**
```hemlock
file.read(dimensione?: i32): string
```

**Parametri:**
- `dimensione` (opzionale) - Numero di byte da leggere (se omesso, legge fino a EOF)

**Restituisce:** Stringa con il contenuto del file

**Esempi:**
```hemlock
let f = open("dati.txt", "r");

// Leggi intero file
let tutto = f.read();
print(tutto);

// Leggi numero specifico di byte
let blocco = f.read(1024);

f.close();
```

**Comportamento:**
- Legge dalla posizione corrente del file
- Restituisce stringa vuota a EOF
- Avanza la posizione del file

**Errori:**
- Lettura da file chiuso
- Lettura da file di sola scrittura

---

#### read_bytes

Legge dati binari dal file.

**Firma:**
```hemlock
file.read_bytes(dimensione: i32): buffer
```

**Parametri:**
- `dimensione` - Numero di byte da leggere

**Restituisce:** Buffer con dati binari

**Esempi:**
```hemlock
let f = open("dati.bin", "r");

// Leggi 256 byte
let binario = f.read_bytes(256);
print(binario.length);       // 256

// Elabora dati binari
let i = 0;
while (i < binario.length) {
    print(binario[i]);
    i = i + 1;
}

f.close();
```

**Comportamento:**
- Legge numero esatto di byte
- Restituisce buffer (non stringa)
- Avanza la posizione del file

---

### Scrittura

#### write

Scrive testo nel file.

**Firma:**
```hemlock
file.write(dati: string): i32
```

**Parametri:**
- `dati` - Stringa da scrivere

**Restituisce:** Numero di byte scritti (i32)

**Esempi:**
```hemlock
let f = open("output.txt", "w");

// Scrivi testo
let scritti = f.write("Ciao, Mondo!\n");
print("Scritti", scritti, "byte");

// Scritture multiple
f.write("Riga 1\n");
f.write("Riga 2\n");
f.write("Riga 3\n");

f.close();
```

**Comportamento:**
- Scrive alla posizione corrente del file
- Restituisce numero di byte scritti
- Avanza la posizione del file

**Errori:**
- Scrittura su file chiuso
- Scrittura su file di sola lettura

---

#### write_bytes

Scrive dati binari nel file.

**Firma:**
```hemlock
file.write_bytes(dati: buffer): i32
```

**Parametri:**
- `dati` - Buffer da scrivere

**Restituisce:** Numero di byte scritti (i32)

**Esempi:**
```hemlock
let f = open("output.bin", "w");

// Crea buffer
let buf = buffer(10);
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

// Scrivi buffer
let scritti = f.write_bytes(buf);
print("Scritti", scritti, "byte");

f.close();
```

**Comportamento:**
- Scrive il contenuto del buffer nel file
- Restituisce numero di byte scritti
- Avanza la posizione del file

---

### Posizionamento

#### seek

Sposta la posizione del file a un offset di byte specifico.

**Firma:**
```hemlock
file.seek(posizione: i32): i32
```

**Parametri:**
- `posizione` - Offset in byte dall'inizio del file

**Restituisce:** Nuova posizione nel file (i32)

**Esempi:**
```hemlock
let f = open("dati.txt", "r");

// Salta al byte 100
f.seek(100);

// Leggi da quella posizione
let blocco = f.read(50);

// Torna all'inizio
f.seek(0);

// Leggi dall'inizio
let tutto = f.read();

f.close();
```

**Comportamento:**
- Imposta la posizione del file all'offset assoluto
- Restituisce la nuova posizione
- Posizionarsi oltre EOF Ã¨ permesso (crea buco nel file durante la scrittura)

---

#### tell

Ottiene la posizione corrente nel file.

**Firma:**
```hemlock
file.tell(): i32
```

**Restituisce:** Offset corrente in byte dall'inizio del file (i32)

**Esempi:**
```hemlock
let f = open("dati.txt", "r");

print(f.tell());        // 0 (all'inizio)

f.read(100);
print(f.tell());        // 100 (dopo la lettura)

f.seek(50);
print(f.tell());        // 50 (dopo il seek)

f.close();
```

---

### Chiusura

#### close

Chiude il file (idempotente).

**Firma:**
```hemlock
file.close(): null
```

**Restituisce:** `null`

**Esempi:**
```hemlock
let f = open("dati.txt", "r");
let contenuto = f.read();
f.close();

// Sicuro chiamarlo piÃ¹ volte
f.close();  // Nessun errore
f.close();  // Nessun errore
```

**Comportamento:**
- Chiude l'handle del file
- Svuota qualsiasi scrittura in sospeso
- Idempotente (sicuro chiamarlo piÃ¹ volte)
- Imposta la proprietÃ  `.closed` a `true`

**Importante:** Chiudi sempre i file quando hai finito per evitare perdite di descrittori.

---

## ProprietÃ  dei File

### .path

Ottiene il percorso del file.

**Tipo:** `string`

**Accesso:** Sola lettura

**Esempi:**
```hemlock
let f = open("/percorso/al/file.txt", "r");
print(f.path);          // "/percorso/al/file.txt"
f.close();
```

---

### .mode

Ottiene la modalitÃ  di apertura.

**Tipo:** `string`

**Accesso:** Sola lettura

**Esempi:**
```hemlock
let f = open("dati.txt", "r");
print(f.mode);          // "r"
f.close();

let f2 = open("output.txt", "w");
print(f2.mode);         // "w"
f2.close();
```

---

### .closed

Verifica se il file Ã¨ chiuso.

**Tipo:** `bool`

**Accesso:** Sola lettura

**Esempi:**
```hemlock
let f = open("dati.txt", "r");
print(f.closed);        // false

f.close();
print(f.closed);        // true
```

---

## Gestione degli Errori

Tutte le operazioni sui file includono messaggi di errore appropriati con contesto:

### File Non Trovato
```hemlock
let f = open("mancante.txt", "r");
// Errore: Impossibile aprire 'mancante.txt': File o directory inesistente
```

### Lettura da File Chiuso
```hemlock
let f = open("dati.txt", "r");
f.close();
f.read();
// Errore: Impossibile leggere da file chiuso 'dati.txt'
```

### Scrittura su File di Sola Lettura
```hemlock
let f = open("sola_lettura.txt", "r");
f.write("dati");
// Errore: Impossibile scrivere su file 'sola_lettura.txt' aperto in modalitÃ  sola lettura
```

### Uso di try/catch
```hemlock
let f = null;
try {
    f = open("dati.txt", "r");
    let contenuto = f.read();
    print(contenuto);
} catch (e) {
    print("Errore file:", e);
} finally {
    if (f != null && !f.closed) {
        f.close();
    }
}
```

---

## Pattern di Gestione delle Risorse

### Pattern Base

```hemlock
let f = open("dati.txt", "r");
let contenuto = f.read();
f.close();
```

### Con Gestione degli Errori

```hemlock
let f = open("dati.txt", "r");
try {
    let contenuto = f.read();
    elabora(contenuto);
} finally {
    f.close();  // Chiudi sempre, anche in caso di errore
}
```

### Pattern Sicuro

```hemlock
let f = null;
try {
    f = open("dati.txt", "r");
    let contenuto = f.read();
    // ... elabora contenuto ...
} catch (e) {
    print("Errore:", e);
} finally {
    if (f != null && !f.closed) {
        f.close();
    }
}
```

---

## Esempi di Utilizzo

### Leggi Intero File

```hemlock
fn leggi_file(nome_file: string): string {
    let f = open(nome_file, "r");
    let contenuto = f.read();
    f.close();
    return contenuto;
}

let testo = leggi_file("dati.txt");
print(testo);
```

### Scrivi File di Testo

```hemlock
fn scrivi_file(nome_file: string, contenuto: string) {
    let f = open(nome_file, "w");
    f.write(contenuto);
    f.close();
}

scrivi_file("output.txt", "Ciao, Mondo!\n");
```

### Append a File

```hemlock
fn aggiungi_a_file(nome_file: string, riga: string) {
    let f = open(nome_file, "a");
    f.write(riga + "\n");
    f.close();
}

aggiungi_a_file("log.txt", "Voce log 1");
aggiungi_a_file("log.txt", "Voce log 2");
```

### Leggi File Binario

```hemlock
fn leggi_binario(nome_file: string, dimensione: i32): buffer {
    let f = open(nome_file, "r");
    let dati = f.read_bytes(dimensione);
    f.close();
    return dati;
}

let binario = leggi_binario("dati.bin", 256);
print("Letti", binario.length, "byte");
```

### Scrivi File Binario

```hemlock
fn scrivi_binario(nome_file: string, dati: buffer) {
    let f = open(nome_file, "w");
    f.write_bytes(dati);
    f.close();
}

let buf = buffer(10);
buf[0] = 65;
scrivi_binario("output.bin", buf);
```

### Leggi File Riga per Riga

```hemlock
fn leggi_righe(nome_file: string): array {
    let f = open(nome_file, "r");
    let contenuto = f.read();
    f.close();
    return contenuto.split("\n");
}

let righe = leggi_righe("dati.txt");
let i = 0;
while (i < righe.length) {
    print("Riga", i, ":", righe[i]);
    i = i + 1;
}
```

### Copia File

```hemlock
fn copia_file(sorgente: string, dest: string) {
    let f_in = open(sorgente, "r");
    let f_out = open(dest, "w");

    let contenuto = f_in.read();
    f_out.write(contenuto);

    f_in.close();
    f_out.close();
}

copia_file("input.txt", "output.txt");
```

### Leggi File a Blocchi

```hemlock
fn elabora_blocchi(nome_file: string) {
    let f = open(nome_file, "r");

    while (true) {
        let blocco = f.read(1024);  // Leggi 1KB alla volta
        if (blocco.length == 0) {
            break;  // EOF
        }

        // Elabora blocco
        print("Elaborando", blocco.length, "byte");
    }

    f.close();
}

elabora_blocchi("file_grande.txt");
```

---

## Riepilogo Completo dei Metodi

| Metodo        | Firma                  | Restituisce | Descrizione                  |
|---------------|------------------------|-------------|------------------------------|
| `read`        | `(dimensione?: i32)`   | `string`    | Legge testo                  |
| `read_bytes`  | `(dimensione: i32)`    | `buffer`    | Legge dati binari            |
| `write`       | `(dati: string)`       | `i32`       | Scrive testo                 |
| `write_bytes` | `(dati: buffer)`       | `i32`       | Scrive dati binari           |
| `seek`        | `(posizione: i32)`     | `i32`       | Imposta posizione file       |
| `tell`        | `()`                   | `i32`       | Ottiene posizione file       |
| `close`       | `()`                   | `null`      | Chiude file (idempotente)    |

---

## Riepilogo Completo delle ProprietÃ 

| ProprietÃ  | Tipo     | Accesso     | Descrizione              |
|-----------|----------|-------------|--------------------------|
| `.path`   | `string` | Sola lettura| Percorso del file        |
| `.mode`   | `string` | Sola lettura| ModalitÃ  di apertura     |
| `.closed` | `bool`   | Sola lettura| Se il file Ã¨ chiuso      |

---

## Migrazione dalla Vecchia API

**Vecchia API (Rimossa):**
- `read_file(percorso)` - Usa `open(percorso, "r").read()`
- `write_file(percorso, dati)` - Usa `open(percorso, "w").write(dati)`
- `append_file(percorso, dati)` - Usa `open(percorso, "a").write(dati)`
- `file_exists(percorso)` - Nessuna sostituzione ancora

**Esempio di Migrazione:**
```hemlock
// Vecchio (v0.0)
let contenuto = read_file("dati.txt");
write_file("output.txt", contenuto);

// Nuovo (v0.1)
let f = open("dati.txt", "r");
let contenuto = f.read();
f.close();

let f2 = open("output.txt", "w");
f2.write(contenuto);
f2.close();
```

---

## Vedi Anche

- [Funzioni Integrate](#reference-builtins) - Funzione `open()`
- [API della Memoria](#reference-memory-api) - Tipo buffer
- [API delle Stringhe](#reference-string-api) - Metodi delle stringhe per elaborazione del testo


--------------------------------------------------------------------------------
## API della Memoria
--------------------------------------------------------------------------------

# Riferimento API della Memoria

Riferimento completo per le funzioni di gestione della memoria e i tipi di puntatore di Hemlock.

---

## Panoramica

Hemlock fornisce **gestione manuale della memoria** con allocazione e deallocazione esplicite. La memoria Ã¨ gestita attraverso due tipi di puntatore: puntatori grezzi (`ptr`) e buffer sicuri (`buffer`).

**Principi Chiave:**
- Allocazione e deallocazione esplicite
- Nessun garbage collection
- L'utente Ã¨ responsabile di chiamare `free()`
- Conteggio dei riferimenti interno per sicurezza di scope/riassegnazione (vedi sotto)

### Conteggio dei Riferimenti Interno

Il runtime usa il conteggio dei riferimenti internamente per gestire i tempi di vita degli oggetti attraverso gli scope. Per la maggior parte delle variabili locali, la pulizia Ã¨ automatica.

**Automatico (nessun `free()` necessario):**
- Le variabili locali di tipi con conteggio riferimenti (buffer, array, oggetto, stringa) vengono liberate all'uscita dallo scope
- I vecchi valori vengono rilasciati quando le variabili vengono riassegnate
- Gli elementi dei contenitori vengono rilasciati quando i contenitori vengono liberati

**`free()` manuale richiesto:**
- Puntatori grezzi da `alloc()` - sempre
- Pulizia anticipata prima dell'uscita dallo scope
- Dati a lunga vita/globali

Vedi [Guida alla Gestione della Memoria](../language-guide/memory.md#internal-reference-counting) per dettagli.

---

## Tipi di Puntatore

### ptr (Puntatore Grezzo)

**Tipo:** `ptr`

**Descrizione:** Indirizzo di memoria grezzo senza controllo dei limiti o tracciamento.

**Dimensione:** 8 byte

**Casi d'Uso:**
- Operazioni di memoria a basso livello
- FFI (Foreign Function Interface)
- Massime prestazioni (nessun overhead)

**Sicurezza:** Non sicuro - nessun controllo dei limiti, l'utente deve tracciare il tempo di vita

**Esempi:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

---

### buffer (Buffer Sicuro)

**Tipo:** `buffer`

**Descrizione:** Wrapper sicuro del puntatore con controllo dei limiti.

**Struttura:** Puntatore + lunghezza + capacitÃ  + ref_count

**ProprietÃ :**
- `.length` - Dimensione del buffer (i32)
- `.capacity` - CapacitÃ  allocata (i32)

**Casi d'Uso:**
- La maggior parte delle allocazioni di memoria
- Quando la sicurezza Ã¨ importante
- Array dinamici

**Sicurezza:** Controllo dei limiti nell'accesso all'indice

**Conteggio Riferimenti:** I buffer hanno conteggio riferimenti interno. Automaticamente liberati all'uscita dallo scope o quando la variabile viene riassegnata. Usa `free()` per pulizia anticipata o dati a lunga vita.

**Esempi:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // Controllo limiti
print(b.length);        // 64
free(b);
```

---

## Funzioni di Allocazione della Memoria

### alloc

Alloca memoria grezza.

**Firma:**
```hemlock
alloc(dimensione: i32): ptr
```

**Parametri:**
- `dimensione` - Numero di byte da allocare

**Restituisce:** Puntatore alla memoria allocata (`ptr`)

**Esempi:**
```hemlock
let p = alloc(1024);        // Alloca 1KB
memset(p, 0, 1024);         // Inizializza a zero
free(p);                    // Libera quando finito

// Alloca per struttura
let dim_struct = 16;
let p2 = alloc(dim_struct);
```

**Comportamento:**
- Restituisce memoria non inizializzata
- La memoria deve essere liberata manualmente
- Restituisce `null` in caso di fallimento dell'allocazione (il chiamante deve verificare)

**Vedi Anche:** `buffer()` per alternativa piÃ¹ sicura

---

### buffer

Alloca buffer sicuro con controllo dei limiti.

**Firma:**
```hemlock
buffer(dimensione: i32): buffer
```

**Parametri:**
- `dimensione` - Dimensione del buffer in byte

**Restituisce:** Oggetto buffer

**Esempi:**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256
print(buf.capacity);        // 256

// Accesso con controllo limiti
buf[0] = 65;                // 'A'
buf[255] = 90;              // 'Z'
// buf[256] = 0;            // ERRORE: fuori limiti

free(buf);
```

**ProprietÃ :**
- `.length` - Dimensione corrente (i32)
- `.capacity` - CapacitÃ  allocata (i32)

**Comportamento:**
- Inizializza la memoria a zero
- Fornisce controllo limiti nell'accesso all'indice
- Restituisce `null` in caso di fallimento dell'allocazione (il chiamante deve verificare)
- Deve essere liberato manualmente

---

### free

Libera memoria allocata.

**Firma:**
```hemlock
free(ptr: ptr | buffer): null
```

**Parametri:**
- `ptr` - Puntatore o buffer da liberare

**Restituisce:** `null`

**Esempi:**
```hemlock
// Libera puntatore grezzo
let p = alloc(1024);
free(p);

// Libera buffer
let buf = buffer(256);
free(buf);
```

**Comportamento:**
- Libera memoria allocata da `alloc()` o `buffer()`
- Double-free causa crash (responsabilitÃ  dell'utente evitarlo)
- Liberare puntatori non validi causa comportamento indefinito

**Importante:** Tu allochi, tu liberi. Nessuna pulizia automatica.

---

### realloc

Ridimensiona memoria allocata.

**Firma:**
```hemlock
realloc(ptr: ptr, nuova_dimensione: i32): ptr
```

**Parametri:**
- `ptr` - Puntatore da ridimensionare
- `nuova_dimensione` - Nuova dimensione in byte

**Restituisce:** Puntatore alla memoria ridimensionata (potrebbe essere indirizzo diverso)

**Esempi:**
```hemlock
let p = alloc(100);
// ... usa memoria ...

// Serve piÃ¹ spazio
p = realloc(p, 200);        // Ora 200 byte
// ... usa memoria espansa ...

free(p);
```

**Comportamento:**
- Potrebbe spostare la memoria in nuova posizione
- Preserva dati esistenti (fino al minimo tra vecchia/nuova dimensione)
- Il vecchio puntatore non Ã¨ valido dopo realloc riuscito (usa il puntatore restituito)
- Se nuova_dimensione Ã¨ piÃ¹ piccola, i dati vengono troncati
- Restituisce `null` in caso di fallimento (il puntatore originale rimane valido)

**Importante:** Verifica sempre `null` e aggiorna la tua variabile puntatore con il risultato.

---

## Operazioni sulla Memoria

### memset

Riempie la memoria con un valore byte.

**Firma:**
```hemlock
memset(ptr: ptr, byte: i32, dimensione: i32): null
```

**Parametri:**
- `ptr` - Puntatore alla memoria
- `byte` - Valore byte da riempire (0-255)
- `dimensione` - Numero di byte da riempire

**Restituisce:** `null`

**Esempi:**
```hemlock
let p = alloc(100);

// Azzera la memoria
memset(p, 0, 100);

// Riempi con valore specifico
memset(p, 0xFF, 100);

// Inizializza buffer
let buf = alloc(256);
memset(buf, 65, 256);       // Riempi con 'A'

free(p);
free(buf);
```

**Comportamento:**
- Scrive il valore byte su ogni byte nell'intervallo
- Il valore byte Ã¨ troncato a 8 bit (0-255)
- Nessun controllo limiti (non sicuro)

---

### memcpy

Copia memoria da sorgente a destinazione.

**Firma:**
```hemlock
memcpy(dest: ptr, src: ptr, dimensione: i32): null
```

**Parametri:**
- `dest` - Puntatore destinazione
- `src` - Puntatore sorgente
- `dimensione` - Numero di byte da copiare

**Restituisce:** `null`

**Esempi:**
```hemlock
let src = alloc(100);
let dest = alloc(100);

// Inizializza sorgente
memset(src, 65, 100);

// Copia a destinazione
memcpy(dest, src, 100);

// dest ora contiene gli stessi dati di src

free(src);
free(dest);
```

**Comportamento:**
- Copia byte per byte da src a dest
- Nessun controllo limiti (non sicuro)
- Regioni sovrapposte hanno comportamento indefinito (usa con cautela)

---

## Operazioni sulla Memoria Tipizzate

### sizeof

Ottiene la dimensione di un tipo in byte.

**Firma:**
```hemlock
sizeof(tipo): i32
```

**Parametri:**
- `tipo` - Identificatore di tipo (es. `i32`, `f64`, `ptr`)

**Restituisce:** Dimensione in byte (i32)

**Dimensioni dei Tipi:**

| Tipo | Dimensione (byte) |
|------|-------------------|
| `i8` | 1 |
| `i16` | 2 |
| `i32`, `integer` | 4 |
| `i64` | 8 |
| `u8`, `byte` | 1 |
| `u16` | 2 |
| `u32` | 4 |
| `u64` | 8 |
| `f32` | 4 |
| `f64`, `number` | 8 |
| `bool` | 1 |
| `ptr` | 8 |
| `rune` | 4 |

**Esempi:**
```hemlock
let dim_int = sizeof(i32);      // 4
let dim_ptr = sizeof(ptr);      // 8
let dim_float = sizeof(f64);    // 8
let dim_byte = sizeof(u8);      // 1
let dim_rune = sizeof(rune);    // 4

// Calcola dimensione allocazione array
let conteggio = 100;
let totale = sizeof(i32) * conteggio; // 400 byte
```

**Comportamento:**
- Restituisce 0 per tipi sconosciuti
- Accetta sia identificatori di tipo che stringhe di tipo

---

### talloc

Alloca array di valori tipizzati.

**Firma:**
```hemlock
talloc(tipo, conteggio: i32): ptr
```

**Parametri:**
- `tipo` - Tipo da allocare (es. `i32`, `f64`, `ptr`)
- `conteggio` - Numero di elementi (deve essere positivo)

**Restituisce:** Puntatore all'array allocato, o `null` in caso di fallimento

**Esempi:**
```hemlock
let arr = talloc(i32, 100);      // Array di 100 i32 (400 byte)
let floats = talloc(f64, 50);    // Array di 50 f64 (400 byte)
let bytes = talloc(u8, 1024);    // Array di 1024 byte

// Verifica sempre il fallimento dell'allocazione
if (arr == null) {
    panic("allocazione fallita");
}

// Usa la memoria allocata
// ...

free(arr);
free(floats);
free(bytes);
```

**Comportamento:**
- Alloca `sizeof(tipo) * conteggio` byte
- Restituisce memoria non inizializzata
- La memoria deve essere liberata manualmente con `free()`
- Restituisce `null` in caso di fallimento dell'allocazione (il chiamante deve verificare)
- Va in panic se il conteggio non Ã¨ positivo

---

## ProprietÃ  del Buffer

### .length

Ottiene la dimensione del buffer.

**Tipo:** `i32`

**Accesso:** Sola lettura

**Esempi:**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256

let buf2 = buffer(1024);
print(buf2.length);         // 1024
```

---

### .capacity

Ottiene la capacitÃ  del buffer.

**Tipo:** `i32`

**Accesso:** Sola lettura

**Esempi:**
```hemlock
let buf = buffer(256);
print(buf.capacity);        // 256
```

**Nota:** Attualmente, `.length` e `.capacity` sono uguali per i buffer creati con `buffer()`.

---

## Pattern di Utilizzo

### Pattern di Allocazione Base

```hemlock
// Alloca
let p = alloc(1024);
if (p == null) {
    panic("allocazione fallita");
}

// Usa
memset(p, 0, 1024);

// Libera
free(p);
```

### Pattern Buffer Sicuro

```hemlock
// Alloca buffer
let buf = buffer(256);
if (buf == null) {
    panic("allocazione buffer fallita");
}

// Usa con controllo limiti
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

// Libera
free(buf);
```

### Pattern di Crescita Dinamica

```hemlock
let dimensione = 100;
let p = alloc(dimensione);
if (p == null) {
    panic("allocazione fallita");
}

// ... usa memoria ...

// Serve piÃ¹ spazio - verifica fallimento
let nuovo_p = realloc(p, 200);
if (nuovo_p == null) {
    // Il puntatore originale Ã¨ ancora valido, pulisci
    free(p);
    panic("realloc fallito");
}
p = nuovo_p;
dimensione = 200;

// ... usa memoria espansa ...

free(p);
```

### Pattern di Copia Memoria

```hemlock
let originale = alloc(100);
memset(originale, 65, 100);

// Crea copia
let copia = alloc(100);
memcpy(copia, originale, 100);

free(originale);
free(copia);
```

---

## Considerazioni sulla Sicurezza

**La gestione della memoria di Hemlock Ã¨ NON SICURA per design:**

### Trappole Comuni

**1. Memory Leak**
```hemlock
// MALE: Memory leak
fn crea_buffer() {
    let p = alloc(1024);
    return null;  // Memoria persa!
}

// BENE: Pulizia appropriata
fn crea_buffer() {
    let p = alloc(1024);
    // ... usa memoria ...
    free(p);
    return null;
}
```

**2. Use After Free**
```hemlock
// MALE: Use after free
let p = alloc(100);
free(p);
memset(p, 0, 100);  // CRASH: uso di memoria liberata

// BENE: Non usare dopo free
let p2 = alloc(100);
memset(p2, 0, 100);
free(p2);
// Non toccare p2 dopo questo
```

**3. Double Free**
```hemlock
// MALE: Double free
let p = alloc(100);
free(p);
free(p);  // CRASH: double free

// BENE: Libera una volta sola
let p2 = alloc(100);
free(p2);
```

**4. Buffer Overflow (ptr)**
```hemlock
// MALE: Buffer overflow con ptr
let p = alloc(10);
memset(p, 65, 100);  // CRASH: scrittura oltre allocazione

// BENE: Usa buffer per controllo limiti
let buf = buffer(10);
// buf[100] = 65;  // ERRORE: controllo limiti fallisce
```

**5. Dangling Pointers**
```hemlock
// MALE: Dangling pointer
let p1 = alloc(100);
let p2 = p1;
free(p1);
memset(p2, 0, 100);  // CRASH: p2 Ã¨ dangling

// BENE: Traccia ownership attentamente
let p = alloc(100);
// ... usa p ...
free(p);
// Non mantenere altri riferimenti a p
```

**6. Fallimento Allocazione Non Verificato**
```hemlock
// MALE: Non verificare null
let p = alloc(1000000000);  // Potrebbe fallire con poca memoria
memset(p, 0, 1000000000);   // CRASH: p Ã¨ null

// BENE: Verifica sempre il risultato dell'allocazione
let p2 = alloc(1000000000);
if (p2 == null) {
    panic("memoria esaurita");
}
memset(p2, 0, 1000000000);
free(p2);
```

---

## Quando Usare Cosa

### Usa `buffer()` quando:
- Hai bisogno di controllo limiti
- Lavori con dati dinamici
- La sicurezza Ã¨ importante
- Stai imparando Hemlock

### Usa `alloc()` quando:
- Servono prestazioni massime
- FFI/interfacciamento con C
- Conosci esattamente il layout della memoria
- Sei un esperto

### Usa `realloc()` quando:
- Devi crescere/ridurre allocazioni
- Array dinamici
- Devi preservare i dati

---

## Riepilogo Completo delle Funzioni

| Funzione  | Firma                              | Restituisce | Descrizione                |
|-----------|------------------------------------|-------------|----------------------------|
| `alloc`   | `(dimensione: i32)`                | `ptr`       | Alloca memoria grezza      |
| `buffer`  | `(dimensione: i32)`                | `buffer`    | Alloca buffer sicuro       |
| `free`    | `(ptr: ptr \| buffer)`             | `null`      | Libera memoria             |
| `realloc` | `(ptr: ptr, nuova_dim: i32)`       | `ptr`       | Ridimensiona allocazione   |
| `memset`  | `(ptr: ptr, byte: i32, dim: i32)`  | `null`      | Riempie memoria            |
| `memcpy`  | `(dest: ptr, src: ptr, dim: i32)`  | `null`      | Copia memoria              |
| `sizeof`  | `(tipo)`                           | `i32`       | Ottiene dimensione tipo in byte |
| `talloc`  | `(tipo, conteggio: i32)`           | `ptr`       | Alloca array tipizzato     |

---

## Vedi Anche

- [Sistema di Tipi](#reference-type-system) - Tipi puntatore e buffer
- [Funzioni Integrate](#reference-builtins) - Tutte le funzioni integrate
- [API delle Stringhe](#reference-string-api) - Metodo `.to_bytes()` delle stringhe


--------------------------------------------------------------------------------
## API delle Stringhe
--------------------------------------------------------------------------------

# Riferimento API delle Stringhe

Riferimento completo per il tipo stringa di Hemlock e tutti i suoi 19 metodi.

---

## Panoramica

Le stringhe in Hemlock sono sequenze **codificate in UTF-8, mutabili, allocate nell'heap** con supporto completo Unicode. Tutte le operazioni lavorano con **codepoint** (caratteri), non byte.

**Caratteristiche Principali:**
- Codifica UTF-8 (U+0000 a U+10FFFF)
- Mutabili (possono modificare i caratteri in loco)
- Indicizzazione basata sui codepoint
- 19 metodi integrati
- Concatenazione automatica con operatore `+`

---

## Tipo Stringa

**Tipo:** `string`

**ProprietÃ :**
- `.length` - Numero di codepoint (caratteri)
- `.byte_length` - Numero di byte UTF-8

**Sintassi Letterale:** Virgolette doppie `"testo"`

**Esempi:**
```hemlock
let s = "ciao";
print(s.length);        // 5 (codepoint)
print(s.byte_length);   // 5 (byte)

let emoji = "ðŸš€";
print(emoji.length);        // 1 (un codepoint)
print(emoji.byte_length);   // 4 (quattro byte UTF-8)
```

---

## Indicizzazione

Le stringhe supportano l'indicizzazione basata sui codepoint usando `[]`:

**Accesso in Lettura:**
```hemlock
let s = "ciao";
let ch = s[0];          // Restituisce rune 'c'
```

**Accesso in Scrittura:**
```hemlock
let s = "ciao";
s[0] = 'C';             // Muta con rune (ora "Ciao")
```

**Esempio UTF-8:**
```hemlock
let testo = "HiðŸš€!";
print(testo[0]);         // 'H'
print(testo[1]);         // 'i'
print(testo[2]);         // 'ðŸš€' (un codepoint)
print(testo[3]);         // '!'
```

---

## Concatenazione

Usa l'operatore `+` per concatenare stringhe e rune:

**Stringa + Stringa:**
```hemlock
let s = "ciao" + " " + "mondo";  // "ciao mondo"
let msg = "Conteggio: " + typeof(42); // "Conteggio: 42"
```

**Stringa + Rune:**
```hemlock
let saluto = "Ciao" + '!';       // "Ciao!"
let decorato = "Testo" + 'âœ“';    // "Testoâœ“"
```

**Rune + Stringa:**
```hemlock
let prefisso = '>' + " Messaggio";   // "> Messaggio"
let punto = 'â€¢' + " Elemento";       // "â€¢ Elemento"
```

**Concatenazioni Multiple:**
```hemlock
let msg = "Ciao " + 'ðŸ‘‹' + " Mondo " + 'ðŸŒ';  // "Ciao ðŸ‘‹ Mondo ðŸŒ"
```

---

## ProprietÃ  delle Stringhe

### .length

Ottiene il numero di codepoint Unicode (caratteri).

**Tipo:** `i32`

**Esempi:**
```hemlock
let s = "ciao";
print(s.length);        // 5

let emoji = "ðŸš€";
print(emoji.length);    // 1 (un codepoint)

let testo = "Ciao ðŸŒ!";
print(testo.length);    // 7 (6 ASCII + 1 emoji)
```

---

### .byte_length

Ottiene il numero di byte UTF-8.

**Tipo:** `i32`

**Esempi:**
```hemlock
let s = "ciao";
print(s.byte_length);   // 5 (1 byte per carattere ASCII)

let emoji = "ðŸš€";
print(emoji.byte_length); // 4 (emoji Ã¨ 4 byte UTF-8)

let testo = "Ciao ðŸŒ!";
print(testo.byte_length);  // 11 (7 ASCII + 4 per emoji)
```

---

## Metodi delle Stringhe

### Sottostringa e Slicing

#### substr

Estrae una sottostringa per posizione e lunghezza.

**Firma:**
```hemlock
string.substr(inizio: i32, lunghezza: i32): string
```

**Parametri:**
- `inizio` - Indice del codepoint iniziale (base 0)
- `lunghezza` - Numero di codepoint da estrarre

**Restituisce:** Nuova stringa

**Esempi:**
```hemlock
let s = "ciao mondo";
let sub = s.substr(5, 5);       // "mondo"
let primo = s.substr(0, 4);     // "ciao"

// Esempio UTF-8
let testo = "HiðŸš€!";
let emoji = testo.substr(2, 1);  // "ðŸš€"
```

---

#### slice

Estrae una sottostringa per intervallo (fine esclusiva).

**Firma:**
```hemlock
string.slice(inizio: i32, fine: i32): string
```

**Parametri:**
- `inizio` - Indice del codepoint iniziale (base 0)
- `fine` - Indice del codepoint finale (esclusivo)

**Restituisce:** Nuova stringa

**Esempi:**
```hemlock
let s = "ciao mondo";
let sub = s.slice(0, 4);        // "ciao"
let mondo = s.slice(5, 10);     // "mondo"

// Esempio UTF-8
let testo = "HiðŸš€!";
let primi_tre = testo.slice(0, 3);  // "HiðŸš€"
```

---

### Ricerca e Trova

#### find

Trova la prima occorrenza di una sottostringa.

**Firma:**
```hemlock
string.find(ago: string): i32
```

**Parametri:**
- `ago` - Sottostringa da cercare

**Restituisce:** Indice del codepoint della prima occorrenza, o `-1` se non trovata

**Esempi:**
```hemlock
let s = "ciao mondo";
let pos = s.find("mondo");      // 5
let pos2 = s.find("foo");       // -1 (non trovato)
let pos3 = s.find("o");         // 3 (primo 'o')
```

---

#### contains

Verifica se la stringa contiene una sottostringa.

**Firma:**
```hemlock
string.contains(ago: string): bool
```

**Parametri:**
- `ago` - Sottostringa da cercare

**Restituisce:** `true` se trovata, `false` altrimenti

**Esempi:**
```hemlock
let s = "ciao mondo";
let ha = s.contains("mondo");   // true
let ha2 = s.contains("foo");    // false
```

---

### Split e Join

#### split

Divide la stringa in array per delimitatore.

**Firma:**
```hemlock
string.split(delimitatore: string): array
```

**Parametri:**
- `delimitatore` - Stringa su cui dividere

**Restituisce:** Array di stringhe

**Esempi:**
```hemlock
let csv = "a,b,c";
let parti = csv.split(",");     // ["a", "b", "c"]

let percorso = "/usr/local/bin";
let dir = percorso.split("/");  // ["", "usr", "local", "bin"]

let testo = "ciao mondo foo";
let parole = testo.split(" ");  // ["ciao", "mondo", "foo"]
```

---

#### trim

Rimuove gli spazi bianchi iniziali e finali.

**Firma:**
```hemlock
string.trim(): string
```

**Restituisce:** Nuova stringa con spazi bianchi rimossi

**Esempi:**
```hemlock
let s = "  ciao  ";
let pulito = s.trim();           // "ciao"

let testo = "\n\t  mondo  \n";
let pulito2 = testo.trim();      // "mondo"
```

---

### Conversione Maiuscole/Minuscole

#### to_upper

Converte la stringa in maiuscolo.

**Firma:**
```hemlock
string.to_upper(): string
```

**Restituisce:** Nuova stringa in maiuscolo

**Esempi:**
```hemlock
let s = "ciao mondo";
let maiuscolo = s.to_upper();    // "CIAO MONDO"

let misto = "CiAo";
let maiuscolo2 = misto.to_upper();  // "CIAO"
```

---

#### to_lower

Converte la stringa in minuscolo.

**Firma:**
```hemlock
string.to_lower(): string
```

**Restituisce:** Nuova stringa in minuscolo

**Esempi:**
```hemlock
let s = "CIAO MONDO";
let minuscolo = s.to_lower();    // "ciao mondo"

let misto = "CiAo";
let minuscolo2 = misto.to_lower();  // "ciao"
```

---

### Prefisso e Suffisso

#### starts_with

Verifica se la stringa inizia con un prefisso.

**Firma:**
```hemlock
string.starts_with(prefisso: string): bool
```

**Parametri:**
- `prefisso` - Prefisso da verificare

**Restituisce:** `true` se la stringa inizia con il prefisso, `false` altrimenti

**Esempi:**
```hemlock
let s = "ciao mondo";
let inizia = s.starts_with("ciao");   // true
let inizia2 = s.starts_with("mondo"); // false
```

---

#### ends_with

Verifica se la stringa termina con un suffisso.

**Firma:**
```hemlock
string.ends_with(suffisso: string): bool
```

**Parametri:**
- `suffisso` - Suffisso da verificare

**Restituisce:** `true` se la stringa termina con il suffisso, `false` altrimenti

**Esempi:**
```hemlock
let s = "ciao mondo";
let termina = s.ends_with("mondo");  // true
let termina2 = s.ends_with("ciao");  // false
```

---

### Sostituzione

#### replace

Sostituisce la prima occorrenza di una sottostringa.

**Firma:**
```hemlock
string.replace(vecchio: string, nuovo: string): string
```

**Parametri:**
- `vecchio` - Sottostringa da sostituire
- `nuovo` - Stringa di sostituzione

**Restituisce:** Nuova stringa con la prima occorrenza sostituita

**Esempi:**
```hemlock
let s = "ciao mondo";
let s2 = s.replace("mondo", "italia");  // "ciao italia"

let testo = "foo foo foo";
let testo2 = testo.replace("foo", "bar"); // "bar foo foo" (solo la prima)
```

---

#### replace_all

Sostituisce tutte le occorrenze di una sottostringa.

**Firma:**
```hemlock
string.replace_all(vecchio: string, nuovo: string): string
```

**Parametri:**
- `vecchio` - Sottostringa da sostituire
- `nuovo` - Stringa di sostituzione

**Restituisce:** Nuova stringa con tutte le occorrenze sostituite

**Esempi:**
```hemlock
let testo = "foo foo foo";
let testo2 = testo.replace_all("foo", "bar"); // "bar bar bar"

let s = "ciao mondo ciao";
let s2 = s.replace_all("ciao", "salve");      // "salve mondo salve"
```

---

### Ripetizione

#### repeat

Ripete la stringa n volte.

**Firma:**
```hemlock
string.repeat(conteggio: i32): string
```

**Parametri:**
- `conteggio` - Numero di ripetizioni

**Restituisce:** Nuova stringa ripetuta conteggio volte

**Esempi:**
```hemlock
let s = "ah";
let ripetuto = s.repeat(3);     // "ahahah"

let linea = "-";
let separatore = linea.repeat(40); // "----------------------------------------"
```

---

### Accesso ai Caratteri

#### char_at

Ottiene il codepoint Unicode all'indice.

**Firma:**
```hemlock
string.char_at(indice: i32): rune
```

**Parametri:**
- `indice` - Indice del codepoint (base 0)

**Restituisce:** Rune (codepoint Unicode)

**Esempi:**
```hemlock
let s = "ciao";
let ch = s.char_at(0);          // 'c'
let ch2 = s.char_at(1);         // 'i'

// Esempio UTF-8
let emoji = "ðŸš€";
let ch3 = emoji.char_at(0);     // U+1F680 (razzo)
```

---

#### chars

Converte la stringa in array di rune.

**Firma:**
```hemlock
string.chars(): array
```

**Restituisce:** Array di rune (codepoint)

**Esempi:**
```hemlock
let s = "ciao";
let caratteri = s.chars();          // ['c', 'i', 'a', 'o']

// Esempio UTF-8
let testo = "HiðŸš€!";
let caratteri2 = testo.chars();     // ['H', 'i', 'ðŸš€', '!']
```

---

### Accesso ai Byte

#### byte_at

Ottiene il valore del byte all'indice.

**Firma:**
```hemlock
string.byte_at(indice: i32): u8
```

**Parametri:**
- `indice` - Indice del byte (base 0, NON indice del codepoint)

**Restituisce:** Valore del byte (u8)

**Esempi:**
```hemlock
let s = "ciao";
let byte = s.byte_at(0);        // 99 (ASCII 'c')
let byte2 = s.byte_at(1);       // 105 (ASCII 'i')

// Esempio UTF-8
let emoji = "ðŸš€";
let byte3 = emoji.byte_at(0);   // 240 (primo byte UTF-8)
```

---

#### bytes

Converte la stringa in array di byte.

**Firma:**
```hemlock
string.bytes(): array
```

**Restituisce:** Array di byte u8

**Esempi:**
```hemlock
let s = "ciao";
let bytes = s.bytes();          // [99, 105, 97, 111]

// Esempio UTF-8
let emoji = "ðŸš€";
let bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 byte UTF-8)
```

---

#### to_bytes

Converte la stringa in buffer.

**Firma:**
```hemlock
string.to_bytes(): buffer
```

**Restituisce:** Buffer contenente i byte UTF-8

**Esempi:**
```hemlock
let s = "ciao";
let buf = s.to_bytes();
print(buf.length);              // 5

// Esempio UTF-8
let emoji = "ðŸš€";
let buf2 = emoji.to_bytes();
print(buf2.length);             // 4
```

**Nota:** Questo Ã¨ un metodo legacy. Preferisci `.bytes()` per la maggior parte dei casi d'uso.

---

### Deserializzazione JSON

#### deserialize

Analizza una stringa JSON in un valore.

**Firma:**
```hemlock
string.deserialize(): any
```

**Restituisce:** Valore analizzato (oggetto, array, numero, stringa, bool o null)

**Esempi:**
```hemlock
let json = '{"x":10,"y":20}';
let obj = json.deserialize();
print(obj.x);                   // 10
print(obj.y);                   // 20

let arr_json = '[1,2,3]';
let arr = arr_json.deserialize();
print(arr[0]);                  // 1

let num_json = '42';
let num = num_json.deserialize();
print(num);                     // 42
```

**Tipi Supportati:**
- Oggetti: `{"chiave": valore}`
- Array: `[1, 2, 3]`
- Numeri: `42`, `3.14`
- Stringhe: `"testo"`
- Booleani: `true`, `false`
- Null: `null`

**Vedi Anche:** Metodo `.serialize()` degli oggetti

---

## Concatenamento di Metodi

I metodi delle stringhe possono essere concatenati per operazioni concise:

**Esempi:**
```hemlock
let risultato = "  Ciao Mondo  "
    .trim()
    .to_lower()
    .replace("mondo", "hemlock");  // "ciao hemlock"

let elaborato = "foo,bar,baz"
    .split(",")
    .join(" | ");                  // "foo | bar | baz"

let pulito = "  CIAO  "
    .trim()
    .to_lower();                   // "ciao"
```

---

## Riepilogo Completo dei Metodi

| Metodo         | Firma                                    | Restituisce | Descrizione                           |
|----------------|------------------------------------------|-------------|---------------------------------------|
| `substr`       | `(inizio: i32, lunghezza: i32)`          | `string`    | Estrae sottostringa per posizione/lunghezza |
| `slice`        | `(inizio: i32, fine: i32)`               | `string`    | Estrae sottostringa per intervallo    |
| `find`         | `(ago: string)`                          | `i32`       | Trova prima occorrenza (-1 se non trovata) |
| `contains`     | `(ago: string)`                          | `bool`      | Verifica se contiene sottostringa     |
| `split`        | `(delimitatore: string)`                 | `array`     | Divide in array                       |
| `trim`         | `()`                                     | `string`    | Rimuove spazi bianchi                 |
| `to_upper`     | `()`                                     | `string`    | Converte in maiuscolo                 |
| `to_lower`     | `()`                                     | `string`    | Converte in minuscolo                 |
| `starts_with`  | `(prefisso: string)`                     | `bool`      | Verifica se inizia con prefisso       |
| `ends_with`    | `(suffisso: string)`                     | `bool`      | Verifica se termina con suffisso      |
| `replace`      | `(vecchio: string, nuovo: string)`       | `string`    | Sostituisce prima occorrenza          |
| `replace_all`  | `(vecchio: string, nuovo: string)`       | `string`    | Sostituisce tutte le occorrenze       |
| `repeat`       | `(conteggio: i32)`                       | `string`    | Ripete la stringa n volte             |
| `char_at`      | `(indice: i32)`                          | `rune`      | Ottiene codepoint all'indice          |
| `byte_at`      | `(indice: i32)`                          | `u8`        | Ottiene byte all'indice               |
| `chars`        | `()`                                     | `array`     | Converte in array di rune             |
| `bytes`        | `()`                                     | `array`     | Converte in array di byte             |
| `to_bytes`     | `()`                                     | `buffer`    | Converte in buffer (legacy)           |
| `deserialize`  | `()`                                     | `any`       | Analizza stringa JSON                 |

---

## Vedi Anche

- [Sistema di Tipi](#reference-type-system) - Dettagli sul tipo stringa
- [API degli Array](#reference-array-api) - Metodi degli array per risultati di split()
- [Operatori](#reference-operators) - Operatore di concatenazione stringhe


--------------------------------------------------------------------------------
## API di Concorrenza
--------------------------------------------------------------------------------

# Riferimento API di Concorrenza

Riferimento completo per le funzionalitÃ  di concorrenza e parallelismo di Hemlock.

---

## Panoramica

Hemlock fornisce **concorrenza strutturata** basata su POSIX threads (pthreads) con task, canali e funzioni asincrone. Ogni task esegue su un thread del sistema operativo per un vero parallelismo su piÃ¹ core CPU.

**Caratteristiche Principali:**
- Vero parallelismo multi-thread (non event loop o green threads)
- Scheduling preemptive da parte del kernel
- Canali per comunicazione sicura tra thread
- async/await per funzioni asincrone
- Propagazione delle eccezioni dai task

---

## Modello di Threading

### Architettura

Hemlock usa threading **1:1** (un task = un pthread):

```
Task Utente          Thread OS          Core CPU
---------            ---------          --------
spawn(f1) ------->   pthread_create --> Core 0
spawn(f2) ------->   pthread_create --> Core 1
spawn(f3) ------->   pthread_create --> Core 2
```

**Caratteristiche:**
- Ogni `spawn()` crea un nuovo pthread
- Il kernel pianifica i thread sui core
- Vera esecuzione parallela (nessun GIL)
- Multitasking preemptive

---

## Tipo Task

**Tipo:** `task`

**Descrizione:** Handle per un task concorrente in esecuzione

**ProprietÃ :**
- Handle opaco al thread sottostante
- Contiene il risultato quando completato
- Memorizza l'eccezione se lanciata

---

## Tipo Channel

**Tipo:** `channel`

**Descrizione:** Canale di comunicazione thread-safe con buffer

**ProprietÃ :**
- `.length` - Numero di elementi attualmente nel buffer (i32)
- `.capacity` - Dimensione massima del buffer (i32)
- `.closed` - Se il canale Ã¨ chiuso (bool)

---

## Funzioni di Gestione dei Task

### spawn

Crea un nuovo task per eseguire una funzione.

**Firma:**
```hemlock
spawn(func: function, ...args): task
```

**Parametri:**
- `func` - Funzione da eseguire
- `args` - Argomenti da passare alla funzione

**Restituisce:** Handle del task

**Esempi:**
```hemlock
// Funzione semplice
fn calcola(n: i32): i32 {
    return n * n;
}

let t = spawn(calcola, 42);
let risultato = join(t);       // 1764

// Funzione con piÃ¹ argomenti
fn somma(a: i32, b: i32): i32 {
    return a + b;
}

let t2 = spawn(somma, 10, 20);
let risultato2 = join(t2);     // 30

// Spawn multipli per parallelismo
let t1 = spawn(calcola, 10);
let t2 = spawn(calcola, 20);
let t3 = spawn(calcola, 30);

let r1 = join(t1);  // 100
let r2 = join(t2);  // 400
let r3 = join(t3);  // 900
```

**Comportamento:**
- Crea nuovo pthread
- Inizia l'esecuzione immediatamente
- Il task esegue concorrentemente con il chiamante
- Gestisci il task con `join()` o `detach()`

**Importante:** I task devono essere joinati o detachati per evitare leak di risorse.

---

### join

Attende il completamento del task e ottiene il risultato.

**Firma:**
```hemlock
join(t: task): any
```

**Parametri:**
- `t` - Handle del task da attendere

**Restituisce:** Valore di ritorno della funzione del task

**Esempi:**
```hemlock
fn lavoro(): i32 {
    // Calcolo lungo...
    return 42;
}

let t = spawn(lavoro);
// ... fai altro lavoro ...
let risultato = join(t);       // Attende, restituisce 42
```

**Comportamento:**
- Si blocca finchÃ© il task non completa
- Restituisce il valore di ritorno della funzione del task
- Se il task ha lanciato un'eccezione, la rilancia nel chiamante
- PuÃ² essere chiamato una sola volta per task

**Gestione Eccezioni:**
```hemlock
fn rischioso(): i32 {
    throw "fallimento";
}

let t = spawn(rischioso);
try {
    let risultato = join(t);
} catch (e) {
    print("Task fallito:", e);  // "Task fallito: fallimento"
}
```

---

### detach

Detach un task per permettergli di eseguire indipendentemente.

**Firma:**
```hemlock
detach(t: task): null
```

**Parametri:**
- `t` - Handle del task da detachare

**Restituisce:** `null`

**Esempi:**
```hemlock
fn lavoro_sfondo() {
    // Lavoro di lunga durata...
    print("Sfondo completato");
}

let t = spawn(lavoro_sfondo);
detach(t);  // Esegue indipendentemente

// Il chiamante continua senza attendere
print("Continua...");
```

**Comportamento:**
- Il task esegue indipendentemente
- Le risorse vengono pulite automaticamente quando completa
- Non puÃ² joinare dopo il detach
- Il task potrebbe ancora essere in esecuzione quando il programma esce

**Casi d'Uso:**
- Operazioni fire-and-forget
- Lavoro in background
- Servizi di lunga durata

---

## Operazioni sui Canali

### channel

Crea un nuovo canale con buffer.

**Firma:**
```hemlock
channel(capacita?: i32): channel
```

**Parametri:**
- `capacita` (opzionale) - Dimensione del buffer (predefinito: 0 per canale non bufferizzato)

**Restituisce:** Nuovo canale

**Esempi:**
```hemlock
// Canale non bufferizzato (capacitÃ  0)
let ch_sync = channel();
let ch_sync2 = channel(0);

// Canale bufferizzato
let ch_buf = channel(10);      // PuÃ² contenere 10 elementi

print(ch_buf.capacity);        // 10
print(ch_buf.length);          // 0 (vuoto)
```

**Comportamento:**
- Buffer circolare per elementi
- Thread-safe (protetto da mutex)
- Supporta piÃ¹ mittenti e ricevitori

---

### send

Invia un valore su un canale.

**Firma:**
```hemlock
channel.send(valore: any): null
```

**Parametri:**
- `valore` - Valore da inviare

**Restituisce:** `null`

**Esempi:**
```hemlock
let ch = channel(10);

// Invia valori
ch.send(42);
ch.send("ciao");
ch.send([1, 2, 3]);

print(ch.length);              // 3
```

**Comportamento:**
- Aggiunge il valore al buffer del canale
- Si blocca se il buffer Ã¨ pieno (attende spazio)
- Thread-safe

**Pattern Produttore:**
```hemlock
fn produttore(ch: channel) {
    let i = 0;
    while (i < 10) {
        ch.send(i);
        i = i + 1;
    }
    ch.close();
}

let ch = channel(5);
let t = spawn(produttore, ch);

// Consuma...
```

---

### recv

Riceve un valore da un canale.

**Firma:**
```hemlock
channel.recv(): any
```

**Restituisce:** Valore ricevuto dal canale

**Esempi:**
```hemlock
let ch = channel(10);

ch.send(42);
ch.send("ciao");

let val1 = ch.recv();          // 42
let val2 = ch.recv();          // "ciao"
```

**Comportamento:**
- Rimuove e restituisce il valore piÃ¹ vecchio dal buffer
- Si blocca se il buffer Ã¨ vuoto (attende dati)
- Thread-safe
- Restituisce `null` se il canale Ã¨ chiuso e vuoto

**Pattern Consumatore:**
```hemlock
fn consumatore(ch: channel) {
    while (true) {
        let val = ch.recv();
        if (val == null && ch.closed) {
            break;
        }
        print("Ricevuto:", val);
    }
}
```

---

### close

Chiude un canale.

**Firma:**
```hemlock
channel.close(): null
```

**Restituisce:** `null`

**Esempi:**
```hemlock
let ch = channel(10);
ch.send(1);
ch.send(2);
ch.close();

print(ch.closed);              // true

// PuÃ² ancora ricevere valori esistenti
let val = ch.recv();           // 1
let val2 = ch.recv();          // 2
let val3 = ch.recv();          // null (canale chiuso e vuoto)

// L'invio al canale chiuso genera errore
// ch.send(3);                 // ERRORE
```

**Comportamento:**
- Segna il canale come chiuso
- Gli invii al canale chiuso generano errore
- Le ricezioni possono ancora ottenere i valori esistenti
- Le ricezioni restituiscono `null` quando chiuso e vuoto

---

## ProprietÃ  dei Canali

### .length

Numero di elementi attualmente nel buffer.

**Tipo:** `i32`

**Esempi:**
```hemlock
let ch = channel(10);
print(ch.length);              // 0

ch.send(1);
ch.send(2);
print(ch.length);              // 2

ch.recv();
print(ch.length);              // 1
```

---

### .capacity

Dimensione massima del buffer.

**Tipo:** `i32`

**Esempi:**
```hemlock
let ch = channel(10);
print(ch.capacity);            // 10

let ch2 = channel();
print(ch2.capacity);           // 0
```

---

### .closed

Se il canale Ã¨ chiuso.

**Tipo:** `bool`

**Esempi:**
```hemlock
let ch = channel(10);
print(ch.closed);              // false

ch.close();
print(ch.closed);              // true
```

---

## Funzioni Async

### async fn

Dichiara una funzione asincrona.

**Sintassi:**
```hemlock
async fn nome(params): tipo_ritorno {
    // corpo
}
```

**Esempi:**
```hemlock
async fn carica_dati(url: string): string {
    // Operazione I/O simulata
    let dati = http_get(url);
    return dati;
}

async fn calcola(n: i32): i32 {
    // Calcolo CPU-bound
    let risultato = 0;
    let i = 0;
    while (i < n) {
        risultato = risultato + i;
        i = i + 1;
    }
    return risultato;
}
```

**Comportamento:**
- Le funzioni async possono essere spawned come task
- Restituiscono i loro valori normalmente
- Le eccezioni si propagano al joiner

---

### await

Attende il risultato di un task.

**Firma:**
```hemlock
await task: any
```

**Esempi:**
```hemlock
async fn calcola(n: i32): i32 {
    return n * n;
}

let t = spawn(calcola, 42);
let risultato = await t;       // 1764

// Equivalente a join()
let t2 = spawn(calcola, 10);
let risultato2 = join(t2);     // 100
```

**Comportamento:**
- Identico a `join()`
- Attende il completamento del task
- Restituisce il risultato
- Propaga le eccezioni

---

## Pattern di Utilizzo

### Parallelismo Semplice

```hemlock
fn elabora(dati: array): array {
    // Elaborazione pesante
    return dati.map(fn(x) { return x * 2; });
}

// Elabora dataset in parallelo
let t1 = spawn(elabora, dati1);
let t2 = spawn(elabora, dati2);
let t3 = spawn(elabora, dati3);

let r1 = join(t1);
let r2 = join(t2);
let r3 = join(t3);
```

### Pattern Produttore-Consumatore

```hemlock
fn produttore(ch: channel, conteggio: i32) {
    let i = 0;
    while (i < conteggio) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
}

fn consumatore(ch: channel) {
    while (true) {
        let val = ch.recv();
        if (val == null && ch.closed) {
            break;
        }
        print("Elaborato:", val);
    }
}

let ch = channel(5);
let prod = spawn(produttore, ch, 10);
let cons = spawn(consumatore, ch);

join(prod);
join(cons);
```

### Pattern Worker Pool

```hemlock
fn worker(id: i32, lavori: channel, risultati: channel) {
    while (true) {
        let lavoro = lavori.recv();
        if (lavoro == null && lavori.closed) {
            break;
        }

        // Elabora lavoro
        let risultato = lavoro * lavoro;
        risultati.send({ worker_id: id, risultato: risultato });
    }
}

// Crea canali
let lavori = channel(100);
let risultati = channel(100);

// Crea worker
let worker1 = spawn(worker, 1, lavori, risultati);
let worker2 = spawn(worker, 2, lavori, risultati);
let worker3 = spawn(worker, 3, lavori, risultati);

// Invia lavori
let i = 0;
while (i < 10) {
    lavori.send(i);
    i = i + 1;
}
lavori.close();

// Raccogli risultati
let conteggio = 0;
while (conteggio < 10) {
    let r = risultati.recv();
    print("Worker", r.worker_id, ":", r.risultato);
    conteggio = conteggio + 1;
}

// Pulisci
join(worker1);
join(worker2);
join(worker3);
```

### Pattern Fan-Out/Fan-In

```hemlock
fn worker(lavoro: i32): i32 {
    return lavoro * lavoro;
}

// Fan-out: spawna piÃ¹ task
let task = [];
let i = 0;
while (i < 10) {
    task.push(spawn(worker, i));
    i = i + 1;
}

// Fan-in: raccogli risultati
let risultati = [];
i = 0;
while (i < task.length) {
    risultati.push(join(task[i]));
    i = i + 1;
}

print(risultati);  // [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

### Gestione delle Eccezioni nei Task

```hemlock
fn lavoro_rischioso(): i32 {
    if (random() < 0.5) {
        throw "operazione fallita";
    }
    return 42;
}

let t = spawn(lavoro_rischioso);

try {
    let risultato = join(t);
    print("Successo:", risultato);
} catch (e) {
    print("Task fallito:", e);
}
```

### Modello di Timeout

```hemlock
// Nota: Questo Ã¨ un pattern concettuale
// L'implementazione effettiva puÃ² variare

fn lavoro_lungo(): i32 {
    sleep(5000);  // 5 secondi
    return 42;
}

fn timeout_wrapper(func: function, timeout_ms: i32): any {
    let ch = channel(1);

    let worker = spawn(fn() {
        let risultato = func();
        ch.send(risultato);
    });

    // Attendi con timeout (concettuale)
    sleep(timeout_ms);
    if (ch.length == 0) {
        throw "operazione in timeout";
    }

    return ch.recv();
}
```

---

## Considerazioni sulla Sicurezza dei Thread

### Condivisione Dati

**Primitivi:** Passati per valore (sicuro)
```hemlock
let x = 42;
let t = spawn(fn() {
    print(x);  // Copia di x
});
```

**Oggetti/Array:** Passati per riferimento (usare cautela)
```hemlock
let arr = [1, 2, 3];
let t = spawn(fn() {
    // Condivide lo stesso array!
    arr.push(4);  // Potenziale race condition
});
```

**Canali:** Comunicazione thread-safe
```hemlock
// Passa dati tramite canali invece della memoria condivisa
let ch = channel(10);

let t = spawn(fn() {
    while (true) {
        let dati = ch.recv();
        if (dati == null) { break; }
        elabora(dati);
    }
});

ch.send({ x: 10, y: 20 });
```

### Best Practice

**1. Preferisci i Canali**
```hemlock
// BENE: Comunica tramite canali
let ch = channel(10);
let t = spawn(worker, ch);
ch.send(dati);
```

**2. Evita la Memoria Condivisa**
```hemlock
// MALE: Accesso condiviso all'array
let risultati = [];
let t1 = spawn(fn() { risultati.push(1); });
let t2 = spawn(fn() { risultati.push(2); });

// BENE: Ogni task ha il proprio spazio, merge dopo
let t1 = spawn(fn() { return [1]; });
let t2 = spawn(fn() { return [2]; });
let risultati = join(t1).concat(join(t2));
```

**3. Joina Sempre i Task**
```hemlock
// BENE: Pulizia appropriata
let t = spawn(lavoro);
let risultato = join(t);

// O detach se Ã¨ fire-and-forget
let t2 = spawn(sfondo);
detach(t2);
```

---

## Riepilogo Completo delle Funzioni

### Funzioni

| Funzione  | Firma                          | Restituisce | Descrizione              |
|-----------|--------------------------------|-------------|--------------------------|
| `spawn`   | `(func, ...args)`              | `task`      | Crea nuovo task          |
| `join`    | `(t: task)`                    | `any`       | Attende risultato task   |
| `detach`  | `(t: task)`                    | `null`      | Detach task              |
| `channel` | `(capacita?: i32)`             | `channel`   | Crea canale              |

### Metodi dei Canali

| Metodo    | Firma                | Restituisce | Descrizione              |
|-----------|----------------------|-------------|--------------------------|
| `send`    | `(valore: any)`      | `null`      | Invia valore             |
| `recv`    | `()`                 | `any`       | Riceve valore            |
| `close`   | `()`                 | `null`      | Chiude canale            |

### ProprietÃ  dei Canali

| ProprietÃ    | Tipo   | Descrizione                |
|-------------|--------|----------------------------|
| `.length`   | `i32`  | Elementi nel buffer        |
| `.capacity` | `i32`  | Dimensione massima buffer  |
| `.closed`   | `bool` | Se chiuso                  |

---

## Vedi Anche

- [Sistema di Tipi](#reference-type-system) - Tipi task e channel
- [Funzioni Integrate](#reference-builtins) - Funzioni spawn, join, detach
- [Gestione delle Eccezioni](#language-guide-exceptions) - Propagazione eccezioni


--------------------------------------------------------------------------------
## Funzioni Integrate
--------------------------------------------------------------------------------

# Riferimento delle Funzioni Integrate

Riferimento completo per le funzioni e costanti integrate di Hemlock.

---

## Panoramica

Hemlock fornisce un insieme di funzioni integrate sempre disponibili nel scope globale. Queste funzioni coprono I/O, gestione della memoria, introspezione dei tipi, concorrenza e utilitÃ  di sistema.

---

## Funzioni di I/O

### print

Stampa valori sullo standard output.

**Firma:**
```hemlock
print(...valori: any): null
```

**Parametri:**
- `valori` - Uno o piÃ¹ valori da stampare

**Restituisce:** `null`

**Esempi:**
```hemlock
print("Ciao, Mondo!");
print(42);
print("x =", 10, "y =", 20);
print([1, 2, 3]);
print({ nome: "Alice" });
```

**Comportamento:**
- Converte tutti i valori in stringhe
- Separa piÃ¹ valori con spazi
- Aggiunge newline alla fine

---

### eprint

Stampa valori sullo standard error.

**Firma:**
```hemlock
eprint(...valori: any): null
```

**Parametri:**
- `valori` - Uno o piÃ¹ valori da stampare

**Restituisce:** `null`

**Esempi:**
```hemlock
eprint("Errore: qualcosa non va");
eprint("Attenzione:", errore_msg);
```

**Comportamento:**
- Identico a `print()` ma scrive su stderr
- Utile per messaggi di errore e diagnostica

---

### read_line

Legge una riga dallo standard input.

**Firma:**
```hemlock
read_line(): string?
```

**Restituisce:** Stringa con la riga di input, o `null` a EOF

**Esempi:**
```hemlock
print("Inserisci il tuo nome:");
let nome = read_line();
print("Ciao,", nome);

// Gestisci EOF
while (true) {
    let riga = read_line();
    if (riga == null) { break; }
    print("Ricevuto:", riga);
}
```

**Comportamento:**
- Si blocca finchÃ© non Ã¨ disponibile input
- Rimuove il newline finale
- Restituisce `null` a fine file

---

### open

Apre un file per lettura/scrittura.

**Firma:**
```hemlock
open(percorso: string, modalita?: string): file
```

**Parametri:**
- `percorso` - Percorso del file
- `modalita` (opzionale) - ModalitÃ  di apertura (predefinito: `"r"`)

**ModalitÃ :**
- `"r"` - Lettura
- `"w"` - Scrittura (tronca)
- `"a"` - Append
- `"r+"` - Lettura e scrittura
- `"w+"` - Lettura e scrittura (tronca)
- `"a+"` - Lettura e append

**Restituisce:** Oggetto file

**Esempi:**
```hemlock
let f = open("dati.txt", "r");
let contenuto = f.read();
f.close();

let f2 = open("output.txt", "w");
f2.write("Ciao!");
f2.close();
```

**Vedi Anche:** [API dei File](#reference-file-api)

---

## Funzioni di Memoria

### alloc

Alloca memoria grezza.

**Firma:**
```hemlock
alloc(dimensione: i32): ptr
```

**Parametri:**
- `dimensione` - Numero di byte da allocare

**Restituisce:** Puntatore alla memoria allocata

**Esempi:**
```hemlock
let p = alloc(1024);
memset(p, 0, 1024);
free(p);
```

**Vedi Anche:** [API della Memoria](#reference-memory-api)

---

### buffer

Alloca buffer sicuro con controllo dei limiti.

**Firma:**
```hemlock
buffer(dimensione: i32): buffer
```

**Parametri:**
- `dimensione` - Dimensione del buffer in byte

**Restituisce:** Oggetto buffer

**Esempi:**
```hemlock
let buf = buffer(256);
buf[0] = 65;
print(buf.length);
free(buf);
```

**Vedi Anche:** [API della Memoria](#reference-memory-api)

---

### free

Libera memoria allocata.

**Firma:**
```hemlock
free(ptr: ptr | buffer): null
```

**Parametri:**
- `ptr` - Puntatore o buffer da liberare

**Restituisce:** `null`

**Vedi Anche:** [API della Memoria](#reference-memory-api)

---

### realloc

Ridimensiona memoria allocata.

**Firma:**
```hemlock
realloc(ptr: ptr, nuova_dimensione: i32): ptr
```

**Parametri:**
- `ptr` - Puntatore da ridimensionare
- `nuova_dimensione` - Nuova dimensione in byte

**Restituisce:** Puntatore alla memoria ridimensionata

**Vedi Anche:** [API della Memoria](#reference-memory-api)

---

### memset

Riempie la memoria con un valore byte.

**Firma:**
```hemlock
memset(ptr: ptr, byte: i32, dimensione: i32): null
```

**Parametri:**
- `ptr` - Puntatore alla memoria
- `byte` - Valore byte (0-255)
- `dimensione` - Numero di byte

**Vedi Anche:** [API della Memoria](#reference-memory-api)

---

### memcpy

Copia memoria.

**Firma:**
```hemlock
memcpy(dest: ptr, src: ptr, dimensione: i32): null
```

**Parametri:**
- `dest` - Puntatore destinazione
- `src` - Puntatore sorgente
- `dimensione` - Numero di byte da copiare

**Vedi Anche:** [API della Memoria](#reference-memory-api)

---

### sizeof

Ottiene la dimensione di un tipo in byte.

**Firma:**
```hemlock
sizeof(tipo): i32
```

**Parametri:**
- `tipo` - Identificatore di tipo

**Restituisce:** Dimensione in byte

**Esempi:**
```hemlock
print(sizeof(i32));         // 4
print(sizeof(f64));         // 8
print(sizeof(ptr));         // 8
```

**Vedi Anche:** [API della Memoria](#reference-memory-api)

---

### talloc

Alloca array tipizzato.

**Firma:**
```hemlock
talloc(tipo, conteggio: i32): ptr
```

**Parametri:**
- `tipo` - Tipo di elemento
- `conteggio` - Numero di elementi

**Restituisce:** Puntatore all'array allocato

**Esempi:**
```hemlock
let arr = talloc(i32, 100);    // 400 byte
free(arr);
```

**Vedi Anche:** [API della Memoria](#reference-memory-api)

---

## Funzioni di Introspezione dei Tipi

### typeof

Ottiene il nome del tipo come stringa.

**Firma:**
```hemlock
typeof(valore: any): string
```

**Parametri:**
- `valore` - Qualsiasi valore

**Restituisce:** Stringa del nome del tipo

**Esempi:**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("ciao"));          // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"
print(typeof(null));            // "null"

define Persona { nome: string }
let p: Persona = { nome: "Alice" };
print(typeof(p));               // "Persona"
```

**Valori Restituiti:**
- Tipi primitivi: `"i8"`, `"i16"`, `"i32"`, `"i64"`, `"u8"`, `"u16"`, `"u32"`, `"u64"`, `"f32"`, `"f64"`, `"bool"`, `"string"`, `"rune"`, `"null"`
- Tipi composti: `"array"`, `"object"`, `"ptr"`, `"buffer"`, `"function"`
- Tipi speciali: `"file"`, `"task"`, `"channel"`
- Oggetti tipizzati: Nome del tipo personalizzato

---

### len

Ottiene la lunghezza di una stringa o array.

**Firma:**
```hemlock
len(valore: string | array): i32
```

**Parametri:**
- `valore` - Stringa o array

**Restituisce:** Numero di elementi/caratteri

**Esempi:**
```hemlock
print(len("ciao"));             // 5
print(len([1, 2, 3]));          // 3
print(len([]));                 // 0
```

---

## Funzioni di Asserzione

### assert

Asserisce che una condizione Ã¨ vera.

**Firma:**
```hemlock
assert(condizione: bool, messaggio?: string): null
```

**Parametri:**
- `condizione` - Condizione da verificare
- `messaggio` (opzionale) - Messaggio di errore se fallisce

**Restituisce:** `null`

**Esempi:**
```hemlock
assert(x > 0);
assert(x > 0, "x deve essere positivo");
assert(utente != null, "utente non trovato");
```

**Comportamento:**
- Non fa nulla se la condizione Ã¨ vera
- Esce con errore se la condizione Ã¨ falsa

---

### panic

Termina il programma con messaggio di errore.

**Firma:**
```hemlock
panic(messaggio: string): never
```

**Parametri:**
- `messaggio` - Messaggio di errore

**Restituisce:** Non ritorna mai (termina il programma)

**Esempi:**
```hemlock
if (ptr == null) {
    panic("allocazione fallita");
}

panic("errore irrecuperabile");
```

**Comportamento:**
- Stampa messaggio su stderr
- Esce con codice di stato non-zero
- Non puÃ² essere catturato da try/catch

---

## Funzioni di Concorrenza

### spawn

Crea un nuovo task concorrente.

**Firma:**
```hemlock
spawn(func: function, ...args): task
```

**Parametri:**
- `func` - Funzione da eseguire
- `args` - Argomenti per la funzione

**Restituisce:** Handle del task

**Vedi Anche:** [API di Concorrenza](#reference-concurrency-api)

---

### join

Attende il completamento del task.

**Firma:**
```hemlock
join(t: task): any
```

**Parametri:**
- `t` - Handle del task

**Restituisce:** Risultato del task

**Vedi Anche:** [API di Concorrenza](#reference-concurrency-api)

---

### detach

Esegue il task in modo indipendente.

**Firma:**
```hemlock
detach(t: task): null
```

**Parametri:**
- `t` - Handle del task

**Restituisce:** `null`

**Vedi Anche:** [API di Concorrenza](#reference-concurrency-api)

---

### channel

Crea un canale di comunicazione.

**Firma:**
```hemlock
channel(capacita?: i32): channel
```

**Parametri:**
- `capacita` (opzionale) - Dimensione del buffer (predefinito: 0)

**Restituisce:** Nuovo canale

**Vedi Anche:** [API di Concorrenza](#reference-concurrency-api)

---

## Funzioni di Sistema

### exec

Esegue un comando shell.

**Firma:**
```hemlock
exec(comando: string): { stdout: string, stderr: string, code: i32 }
```

**Parametri:**
- `comando` - Comando da eseguire

**Restituisce:** Oggetto con stdout, stderr e codice di uscita

**Esempi:**
```hemlock
let risultato = exec("ls -la");
print(risultato.stdout);
print(risultato.code);           // 0 se successo

let risultato2 = exec("comando_inesistente");
print(risultato2.stderr);
print(risultato2.code);          // Non-zero se fallimento
```

---

### sleep

Mette in pausa l'esecuzione.

**Firma:**
```hemlock
sleep(ms: i32): null
```

**Parametri:**
- `ms` - Millisecondi di pausa

**Restituisce:** `null`

**Esempi:**
```hemlock
print("Aspetta...");
sleep(1000);                     // 1 secondo
print("Fatto!");
```

---

### exit

Termina il programma con codice di stato.

**Firma:**
```hemlock
exit(codice?: i32): never
```

**Parametri:**
- `codice` (opzionale) - Codice di uscita (predefinito: 0)

**Restituisce:** Non ritorna mai

**Esempi:**
```hemlock
if (errore) {
    exit(1);
}
exit(0);  // Successo
```

---

### time_ms

Ottiene il tempo corrente in millisecondi.

**Firma:**
```hemlock
time_ms(): i64
```

**Restituisce:** Timestamp Unix in millisecondi

**Esempi:**
```hemlock
let inizio = time_ms();
// ... fai lavoro ...
let fine = time_ms();
print("Tempo impiegato:", fine - inizio, "ms");
```

---

## Funzioni per i Segnali

### signal

Registra un handler per un segnale.

**Firma:**
```hemlock
signal(sig: i32, handler: function): null
```

**Parametri:**
- `sig` - Numero del segnale
- `handler` - Funzione da chiamare al segnale

**Restituisce:** `null`

**Esempi:**
```hemlock
signal(SIGINT, fn(sig) {
    print("Interrotto!");
    exit(0);
});
```

**Segnali Comuni:**
- `SIGINT` (2) - Interrupt
- `SIGTERM` (15) - Terminazione
- `SIGUSR1` (10) - User-defined 1
- `SIGUSR2` (12) - User-defined 2

---

### raise

Invia un segnale al processo corrente.

**Firma:**
```hemlock
raise(sig: i32): null
```

**Parametri:**
- `sig` - Numero del segnale

**Restituisce:** `null`

**Esempi:**
```hemlock
raise(SIGUSR1);
```

---

## Funzioni FFI

### dlopen

Apre una libreria condivisa.

**Firma:**
```hemlock
dlopen(percorso: string): ptr
```

**Parametri:**
- `percorso` - Percorso alla libreria condivisa

**Restituisce:** Handle alla libreria

---

### dlsym

Ottiene un simbolo da una libreria.

**Firma:**
```hemlock
dlsym(lib: ptr, nome: string): ptr
```

**Parametri:**
- `lib` - Handle alla libreria
- `nome` - Nome del simbolo

**Restituisce:** Puntatore al simbolo

---

### dlcall

Chiama una funzione esterna.

**Firma:**
```hemlock
dlcall(func: ptr, ...args): any
```

**Parametri:**
- `func` - Puntatore alla funzione
- `args` - Argomenti per la funzione

**Restituisce:** Valore di ritorno della funzione

---

### dlclose

Chiude una libreria condivisa.

**Firma:**
```hemlock
dlclose(lib: ptr): null
```

**Parametri:**
- `lib` - Handle alla libreria

**Restituisce:** `null`

---

## Funzioni di Conversione dei Tipi

### i32, i64, f64, bool, ecc.

Converte valori o analizza stringhe.

**Firma:**
```hemlock
i32(valore: any): i32
i64(valore: any): i64
f64(valore: any): f64
bool(valore: any): bool
// ... altri tipi
```

**Parametri:**
- `valore` - Valore da convertire o stringa da analizzare

**Restituisce:** Valore convertito

**Esempi:**
```hemlock
let n = i32("42");              // 42
let f = f64("3.14");            // 3.14
let b = bool("true");           // true

let hex = i32("0xFF");          // 255
let neg = i32("-42");           // -42

// Conversioni tra tipi
let grande = i64(42);           // i32 a i64
let troncato = i32(3.99);       // f64 a i32 (tronca a 3)
```

---

## Costanti

### Costanti Booleane

| Costante | Tipo   | Valore |
|----------|--------|--------|
| `true`   | `bool` | Vero   |
| `false`  | `bool` | Falso  |
| `null`   | `null` | Nessun valore |

### Costanti dei Segnali

| Costante   | Valore | Descrizione     |
|------------|--------|-----------------|
| `SIGINT`   | 2      | Interrupt       |
| `SIGTERM`  | 15     | Terminazione    |
| `SIGUSR1`  | 10     | User-defined 1  |
| `SIGUSR2`  | 12     | User-defined 2  |

---

## Riepilogo Completo delle Funzioni

### I/O

| Funzione    | Descrizione                    |
|-------------|--------------------------------|
| `print`     | Stampa su stdout               |
| `eprint`    | Stampa su stderr               |
| `read_line` | Legge riga da stdin            |
| `open`      | Apre file                      |

### Memoria

| Funzione  | Descrizione                    |
|-----------|--------------------------------|
| `alloc`   | Alloca memoria grezza          |
| `buffer`  | Alloca buffer sicuro           |
| `free`    | Libera memoria                 |
| `realloc` | Ridimensiona memoria           |
| `memset`  | Riempie memoria                |
| `memcpy`  | Copia memoria                  |
| `sizeof`  | Dimensione tipo                |
| `talloc`  | Alloca array tipizzato         |

### Tipi

| Funzione | Descrizione                    |
|----------|--------------------------------|
| `typeof` | Ottiene nome tipo              |
| `len`    | Ottiene lunghezza              |

### Asserzione

| Funzione | Descrizione                    |
|----------|--------------------------------|
| `assert` | Verifica condizione            |
| `panic`  | Termina con errore             |

### Concorrenza

| Funzione  | Descrizione                    |
|-----------|--------------------------------|
| `spawn`   | Crea task                      |
| `join`    | Attende task                   |
| `detach`  | Detach task                    |
| `channel` | Crea canale                    |

### Sistema

| Funzione  | Descrizione                    |
|-----------|--------------------------------|
| `exec`    | Esegue comando                 |
| `sleep`   | Pausa esecuzione               |
| `exit`    | Termina programma              |
| `time_ms` | Ottiene tempo                  |

### Segnali

| Funzione | Descrizione                    |
|----------|--------------------------------|
| `signal` | Registra handler               |
| `raise`  | Invia segnale                  |

### FFI

| Funzione  | Descrizione                    |
|-----------|--------------------------------|
| `dlopen`  | Apre libreria                  |
| `dlsym`   | Ottiene simbolo                |
| `dlcall`  | Chiama funzione                |
| `dlclose` | Chiude libreria                |

---

## Vedi Anche

- [API della Memoria](#reference-memory-api) - Dettagli gestione memoria
- [API dei File](#reference-file-api) - Dettagli I/O su file
- [API di Concorrenza](#reference-concurrency-api) - Dettagli threading
- [Sistema di Tipi](#reference-type-system) - Informazioni sui tipi


--------------------------------------------------------------------------------
## Operatori
--------------------------------------------------------------------------------

# Riferimento degli Operatori

Riferimento completo per gli operatori di Hemlock, la precedenza e il comportamento dei tipi.

---

## Panoramica

Hemlock fornisce un insieme completo di operatori per aritmetica, confronto, logica e manipolazione bit a bit. Gli operatori seguono la sintassi in stile C con regole di precedenza chiare.

**Caratteristiche Principali:**
- Sintassi familiare in stile C
- Promozione automatica dei tipi nelle operazioni miste
- Operatori bit a bit per manipolazione interi
- Controllo preciso della precedenza

---

## Operatori Aritmetici

### Aritmetica Base

| Operatore | Nome | Esempio | Risultato |
|-----------|------|---------|-----------|
| `+` | Addizione | `5 + 3` | `8` |
| `-` | Sottrazione | `5 - 3` | `2` |
| `*` | Moltiplicazione | `5 * 3` | `15` |
| `/` | Divisione | `5 / 2` | `2.5` |
| `%` | Modulo | `5 % 3` | `2` |

**Esempi:**
```hemlock
// Aritmetica intera
let a = 10 + 5;     // 15
let b = 10 - 5;     // 5
let c = 10 * 5;     // 50
let d = 10 / 3;     // 3.333... (sempre float)
let e = 10 % 3;     // 1

// Aritmetica float
let f = 3.14 + 2.0; // 5.14
let g = 10.0 / 4.0; // 2.5

// Aritmetica mista
let h = 10 + 2.5;   // 12.5 (promosso a float)
```

### Divisione Intera

L'operatore `/` restituisce sempre un float. Per la divisione intera, usa `divi()`:

```hemlock
let a = 10 / 3;         // 3.333...
let b = divi(10, 3);    // 3 (troncato)

// Oppure usa conversione esplicita
let c: i32 = 10 / 3;    // 3 (troncato via annotazione di tipo)
```

### Negazione Unaria

| Operatore | Nome | Esempio | Risultato |
|-----------|------|---------|-----------|
| `-` | Negazione | `-5` | `-5` |

```hemlock
let x = 5;
let y = -x;         // -5
let z = --x;        // 5 (doppia negazione)
```

---

## Operatori di Incremento/Decremento

| Operatore | Nome | Esempio | Descrizione |
|-----------|------|---------|-------------|
| `++` | Pre-incremento | `++x` | Incrementa x, restituisce nuovo valore |
| `++` | Post-incremento | `x++` | Restituisce valore corrente, poi incrementa |
| `--` | Pre-decremento | `--x` | Decrementa x, restituisce nuovo valore |
| `--` | Post-decremento | `x--` | Restituisce valore corrente, poi decrementa |

**Esempi:**
```hemlock
let x = 5;

// Pre-incremento
let a = ++x;        // x = 6, a = 6

// Post-incremento
let b = x++;        // b = 6, x = 7

// Pre-decremento
let c = --x;        // x = 6, c = 6

// Post-decremento
let d = x--;        // d = 6, x = 5
```

---

## Operatori di Confronto

| Operatore | Nome | Esempio | Risultato |
|-----------|------|---------|-----------|
| `==` | Uguale a | `5 == 5` | `true` |
| `!=` | Diverso da | `5 != 3` | `true` |
| `<` | Minore di | `3 < 5` | `true` |
| `>` | Maggiore di | `5 > 3` | `true` |
| `<=` | Minore o uguale | `3 <= 3` | `true` |
| `>=` | Maggiore o uguale | `5 >= 5` | `true` |

**Esempi:**
```hemlock
// Confronto numeri
print(5 == 5);      // true
print(5 != 3);      // true
print(3 < 5);       // true
print(5 > 3);       // true
print(3 <= 3);      // true
print(5 >= 5);      // true

// Confronto stringhe
print("abc" == "abc");  // true
print("abc" < "abd");   // true (lessicografico)

// Confronto tipi misti
print(5 == 5.0);    // true (promosso a float)
print(5 != "5");    // true (tipi diversi)
```

---

## Operatori Logici

| Operatore | Nome | Esempio | Risultato |
|-----------|------|---------|-----------|
| `&&` | AND logico | `true && false` | `false` |
| `\|\|` | OR logico | `true \|\| false` | `true` |
| `!` | NOT logico | `!true` | `false` |

**Esempi:**
```hemlock
// Operazioni booleane
print(true && true);    // true
print(true && false);   // false
print(true || false);   // true
print(false || false);  // false
print(!true);           // false
print(!false);          // true

// Valutazione cortocircuito
let x = false && costoso();  // costoso() non viene chiamata
let y = true || costoso();   // costoso() non viene chiamata
```

### Valutazione Cortocircuito

`&&` e `||` usano la valutazione cortocircuito:

```hemlock
// AND: si ferma al primo false
let risultato = a() && b() && c();
// Se a() restituisce false, b() e c() non sono valutate

// OR: si ferma al primo true
let risultato = a() || b() || c();
// Se a() restituisce true, b() e c() non sono valutate
```

---

## Operatori Bit a Bit

| Operatore | Nome | Esempio | Risultato |
|-----------|------|---------|-----------|
| `&` | AND bit a bit | `5 & 3` | `1` |
| `\|` | OR bit a bit | `5 \| 3` | `7` |
| `^` | XOR bit a bit | `5 ^ 3` | `6` |
| `~` | NOT bit a bit | `~5` | `-6` |
| `<<` | Shift sinistra | `5 << 2` | `20` |
| `>>` | Shift destra | `20 >> 2` | `5` |

**Esempi:**
```hemlock
// AND: 0101 & 0011 = 0001
print(5 & 3);           // 1

// OR: 0101 | 0011 = 0111
print(5 | 3);           // 7

// XOR: 0101 ^ 0011 = 0110
print(5 ^ 3);           // 6

// NOT: ~0101 = ...1010 (complemento a due)
print(~5);              // -6

// Shift sinistra: 0101 << 2 = 10100
print(5 << 2);          // 20

// Shift destra: 10100 >> 2 = 00101
print(20 >> 2);         // 5
```

### Tecniche Bit a Bit

```hemlock
// Impostare un bit
let flag = 1 << 3;          // Bit 3: 0b1000 = 8

// Verificare un bit
let ha_bit = (valore & flag) != 0;

// Pulire un bit
let pulito = valore & ~flag;

// Attivare/disattivare un bit
let attivato = valore ^ flag;

// Verifica potenza di 2
let e_pot2 = n != 0 && (n & (n - 1)) == 0;
```

---

## Operatori di Assegnazione

### Assegnazione Semplice

| Operatore | Nome | Esempio | Equivalente |
|-----------|------|---------|-------------|
| `=` | Assegnazione | `x = 5` | - |

### Assegnazione Composta

| Operatore | Nome | Esempio | Equivalente |
|-----------|------|---------|-------------|
| `+=` | Addizione assegnazione | `x += 5` | `x = x + 5` |
| `-=` | Sottrazione assegnazione | `x -= 5` | `x = x - 5` |
| `*=` | Moltiplicazione assegnazione | `x *= 5` | `x = x * 5` |
| `/=` | Divisione assegnazione | `x /= 5` | `x = x / 5` |
| `%=` | Modulo assegnazione | `x %= 5` | `x = x % 5` |
| `&=` | AND assegnazione | `x &= 5` | `x = x & 5` |
| `\|=` | OR assegnazione | `x \|= 5` | `x = x \| 5` |
| `^=` | XOR assegnazione | `x ^= 5` | `x = x ^ 5` |
| `<<=` | Shift sinistra assegnazione | `x <<= 2` | `x = x << 2` |
| `>>=` | Shift destra assegnazione | `x >>= 2` | `x = x >> 2` |

**Esempi:**
```hemlock
let x = 10;
x += 5;         // x = 15
x -= 3;         // x = 12
x *= 2;         // x = 24
x /= 4;         // x = 6.0
x %= 4;         // x = 2

let flags = 0;
flags |= 0b0100;    // Imposta bit 2
flags &= ~0b0010;   // Pulisci bit 1
flags ^= 0b1000;    // Attiva bit 3
```

---

## Operatore Ternario

| Operatore | Nome | Esempio | Risultato |
|-----------|------|---------|-----------|
| `? :` | Condizionale | `x > 0 ? "pos" : "non-pos"` | Dipende da x |

**Esempi:**
```hemlock
let x = 5;
let segno = x > 0 ? "positivo" : "non-positivo";
print(segno);       // "positivo"

// Ternario annidato
let categoria = x > 10 ? "grande" :
                x > 5 ? "medio" : "piccolo";

// Come espressione
print(x % 2 == 0 ? "pari" : "dispari");
```

---

## Concatenazione di Stringhe

| Operatore | Nome | Esempio | Risultato |
|-----------|------|---------|-----------|
| `+` | Concatenazione | `"ciao" + " mondo"` | `"ciao mondo"` |

**Esempi:**
```hemlock
let saluto = "Ciao" + " " + "Mondo";
print(saluto);      // "Ciao Mondo"

// Stringa + Rune
let msg = "Fatto" + '!';
print(msg);         // "Fatto!"

// Stringa + altri tipi (conversione automatica)
let conteggio = "Totale: " + 42;
print(conteggio);   // "Totale: 42"
```

---

## Operatori di Accesso

### Accesso ad Array

| Operatore | Nome | Esempio | Descrizione |
|-----------|------|---------|-------------|
| `[]` | Indicizzazione | `arr[0]` | Ottiene elemento all'indice |

**Esempi:**
```hemlock
let arr = [10, 20, 30];
print(arr[0]);      // 10
arr[1] = 25;        // Modifica elemento
print(arr[1]);      // 25
```

### Accesso a Campi

| Operatore | Nome | Esempio | Descrizione |
|-----------|------|---------|-------------|
| `.` | Accesso campo | `obj.campo` | Ottiene proprietÃ  dell'oggetto |

**Esempi:**
```hemlock
let persona = { nome: "Alice", eta: 30 };
print(persona.nome);    // "Alice"
persona.eta = 31;       // Modifica campo
```

### Chiamata di Funzione

| Operatore | Nome | Esempio | Descrizione |
|-----------|------|---------|-------------|
| `()` | Chiamata | `func(a, b)` | Chiama funzione con argomenti |

**Esempi:**
```hemlock
fn somma(a, b) {
    return a + b;
}
print(somma(3, 4));     // 7

// Chiamata di metodo
let s = "ciao";
print(s.to_upper());    // "CIAO"
```

---

## Operatori Null-Coalescing

| Operatore | Nome | Esempio | Descrizione |
|-----------|------|---------|-------------|
| `??` | Null coalescing | `a ?? b` | Restituisce a se non-null, altrimenti b |
| `??=` | Null assegnazione | `a ??= b` | Assegna b ad a solo se a Ã¨ null |
| `?.` | Navigazione sicura | `obj?.campo` | Restituisce null se obj Ã¨ null |

**Esempi:**
```hemlock
// Null coalescing
let nome = utente.nome ?? "Anonimo";
let primo = a ?? b ?? c ?? "predefinito";

// Assegnazione null coalescing
let config = null;
config ??= { timeout: 30 };     // config ora Ã¨ { timeout: 30 }
config ??= { timeout: 60 };     // config invariato (non null)

// Navigazione sicura
let citta = utente?.indirizzo?.citta;  // null se qualsiasi parte Ã¨ null
let maiusc = nome?.to_upper();          // chiamata metodo sicura
let elem = arr?.[0];                    // indicizzazione sicura
```

---

## Precedenza degli Operatori

Dalla precedenza piÃ¹ bassa a quella piÃ¹ alta:

| Livello | Operatori | AssociativitÃ  | Descrizione |
|---------|-----------|---------------|-------------|
| 1 | `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `\|=`, `^=`, `<<=`, `>>=`, `??=` | Destra | Assegnazione |
| 2 | `??` | Sinistra | Null coalescing |
| 3 | `? :` | Destra | Condizionale |
| 4 | `\|\|` | Sinistra | OR logico |
| 5 | `&&` | Sinistra | AND logico |
| 6 | `\|` | Sinistra | OR bit a bit |
| 7 | `^` | Sinistra | XOR bit a bit |
| 8 | `&` | Sinistra | AND bit a bit |
| 9 | `==`, `!=` | Sinistra | Uguaglianza |
| 10 | `<`, `>`, `<=`, `>=` | Sinistra | Confronto |
| 11 | `<<`, `>>` | Sinistra | Shift |
| 12 | `+`, `-` | Sinistra | Addizione/Sottrazione |
| 13 | `*`, `/`, `%` | Sinistra | Moltiplicazione/Divisione |
| 14 | `!`, `-`, `~`, `++`, `--` | Destra | Unario |
| 15 | `()`, `[]`, `.`, `?.` | Sinistra | Chiamata/Accesso |

**Esempi:**
```hemlock
// La moltiplicazione lega piÃ¹ stretto dell'addizione
let x = 2 + 3 * 4;      // 14, non 20

// AND logico lega piÃ¹ stretto di OR
let y = true || false && false;  // true

// Usa parentesi per chiarezza
let z = (2 + 3) * 4;    // 20
let w = (a || b) && c;  // (a || b) valutato prima

// Accesso a campo lega piÃ¹ stretto di operatori aritmetici
let lunghezza = arr.length * 2;  // (arr.length) * 2
```

---

## Promozione dei Tipi

Quando si mescolano tipi nelle operazioni, Hemlock promuove al tipo "superiore":

**Gerarchia di Promozione:**
```
f64 (precisione massima)
 â†‘
f32
 â†‘
u64
 â†‘
i64
 â†‘
u32
 â†‘
i32
 â†‘
u16
 â†‘
i16
 â†‘
u8
 â†‘
i8 (minima)
```

**Regole:**
1. Il float vince sempre sull'intero
2. Dimensione maggiore vince nella stessa categoria
3. Entrambi gli operandi sono promossi al tipo risultato
4. **Preservazione precisione:** i64/u64 + f32 promuove a f64 (non f32)

**Esempi:**
```hemlock
// Promozione dimensione
u8 + i32    â†’ i32    // Dimensione maggiore vince
i32 + i64   â†’ i64    // Dimensione maggiore vince
u32 + u64   â†’ u64    // Dimensione maggiore vince

// Promozione float
i32 + f32   â†’ f32    // Float vince, f32 sufficiente per i32
i64 + f32   â†’ f64    // Promuove a f64 per preservare precisione i64
i64 + f64   â†’ f64    // Float vince sempre
i8 + f64    â†’ f64    // Float + piÃ¹ grande vince
```

---

## Riepilogo Completo degli Operatori

### Operatori Aritmetici
| Operatore | Descrizione |
|-----------|-------------|
| `+` | Addizione |
| `-` | Sottrazione |
| `*` | Moltiplicazione |
| `/` | Divisione (restituisce float) |
| `%` | Modulo |
| `-` (unario) | Negazione |
| `++` | Incremento |
| `--` | Decremento |

### Operatori di Confronto
| Operatore | Descrizione |
|-----------|-------------|
| `==` | Uguale a |
| `!=` | Diverso da |
| `<` | Minore di |
| `>` | Maggiore di |
| `<=` | Minore o uguale |
| `>=` | Maggiore o uguale |

### Operatori Logici
| Operatore | Descrizione |
|-----------|-------------|
| `&&` | AND logico |
| `\|\|` | OR logico |
| `!` | NOT logico |

### Operatori Bit a Bit
| Operatore | Descrizione |
|-----------|-------------|
| `&` | AND bit a bit |
| `\|` | OR bit a bit |
| `^` | XOR bit a bit |
| `~` | NOT bit a bit |
| `<<` | Shift sinistra |
| `>>` | Shift destra |

### Operatori di Assegnazione
| Operatore | Descrizione |
|-----------|-------------|
| `=` | Assegnazione |
| `+=`, `-=`, `*=`, `/=`, `%=` | Aritmetica composta |
| `&=`, `\|=`, `^=`, `<<=`, `>>=` | Bit a bit composta |
| `??=` | Null assegnazione |

### Altri Operatori
| Operatore | Descrizione |
|-----------|-------------|
| `? :` | Condizionale |
| `??` | Null coalescing |
| `?.` | Navigazione sicura |
| `[]` | Indicizzazione |
| `.` | Accesso campo |
| `()` | Chiamata funzione |

---

## Vedi Anche

- [Sistema di Tipi](#reference-type-system) - Regole di promozione dei tipi
- [Funzioni Integrate](#reference-builtins) - Funzioni come `divi()`
- [API delle Stringhe](#reference-string-api) - Concatenazione stringhe
- [API degli Array](#reference-array-api) - Indicizzazione array


--------------------------------------------------------------------------------
## Sistema di Tipi
--------------------------------------------------------------------------------

# Riferimento del Sistema di Tipi

Riferimento completo per il sistema di tipi di Hemlock, inclusi tutti i tipi primitivi e composti.

---

## Panoramica

Hemlock usa un **sistema di tipi dinamico** con tag di tipo a runtime e annotazioni di tipo opzionali. Ogni valore ha un tipo a runtime, e le conversioni di tipo seguono regole di promozione esplicite.

**Caratteristiche Principali:**
- Controllo dei tipi a runtime (interprete)
- Controllo dei tipi a compile-time (hemlockc - abilitato di default)
- Annotazioni di tipo opzionali
- Inferenza di tipo automatica per i letterali
- Regole di promozione dei tipi esplicite
- Nessuna conversione implicita che perde precisione

---

## Controllo dei Tipi a Compile-Time (hemlockc)

Il compilatore Hemlock (`hemlockc`) include un controllo dei tipi a compile-time che valida il codice prima di generare eseguibili. Questo cattura gli errori di tipo in anticipo senza bisogno di eseguire il programma.

### Comportamento Predefinito

Il controllo dei tipi Ã¨ **abilitato di default** in hemlockc:

```bash
# Il controllo dei tipi avviene automaticamente
hemlockc programma.hml -o programma

# Gli errori sono riportati prima della compilazione
hemlockc tipi_errati.hml
# Output: 1 errore di tipo trovato
```

### Flag del Compilatore

| Flag | Descrizione |
|------|-------------|
| `--check` | Solo controllo tipi, non compila (esce dopo validazione) |
| `--no-type-check` | Disabilita controllo tipi (non raccomandato) |
| `--strict-types` | Abilita avvisi piÃ¹ rigidi sui tipi |

**Esempi:**

```bash
# Solo validare i tipi senza compilare
hemlockc --check programma.hml
# Output: programma.hml: nessun errore di tipo

# Disabilitare controllo tipi (usare con cautela)
hemlockc --no-type-check codice_dinamico.hml -o programma

# Abilitare avvisi rigidi per tipi any impliciti
hemlockc --strict-types programma.hml -o programma
```

### Cosa Valida il Controllo dei Tipi

1. **Annotazioni di tipo** - Assicura che i valori assegnati corrispondano ai tipi dichiarati
2. **Chiamate di funzione** - Valida i tipi degli argomenti rispetto ai tipi dei parametri
3. **Tipi di ritorno** - Verifica che le istruzioni return corrispondano al tipo di ritorno dichiarato
4. **Uso degli operatori** - Verifica che gli operandi siano compatibili
5. **Accesso alle proprietÃ ** - Valida i tipi dei campi degli oggetti per oggetti tipizzati

### Conversioni Numeriche Permissive

Il controllo dei tipi permette conversioni di tipo numerico a compile-time, con validazione dell'intervallo a runtime:

```hemlock
let x: i8 = 100;      // OK - 100 sta in i8 (validato a runtime)
let y: u8 = 255;      // OK - nell'intervallo u8
let z: f64 = 42;      // OK - i32 a f64 Ã¨ sicuro
```

### Supporto per Codice Dinamico

Il codice senza annotazioni di tipo Ã¨ trattato come dinamico (tipo `any`) e passa sempre il controllo dei tipi:

```hemlock
let x = get_value();  // Dinamico - nessuna annotazione
process(x);           // OK - valori dinamici accettati ovunque
```

---

## Tipi Primitivi

### Tipi Numerici

#### Interi con Segno

| Tipo   | Dimensione | Intervallo                                   | Alias     |
|--------|------------|----------------------------------------------|-----------|
| `i8`   | 1 byte     | -128 a 127                                   | -         |
| `i16`  | 2 byte     | -32.768 a 32.767                             | -         |
| `i32`  | 4 byte     | -2.147.483.648 a 2.147.483.647               | `integer` |
| `i64`  | 8 byte     | -9.223.372.036.854.775.808 a 9.223.372.036.854.775.807 | - |

**Esempi:**
```hemlock
let a: i8 = 127;
let b: i16 = 32000;
let c: i32 = 1000000;
let d: i64 = 9223372036854775807;

// Alias di tipo
let x: integer = 42;  // Uguale a i32
```

#### Interi senza Segno

| Tipo   | Dimensione | Intervallo                  | Alias  |
|--------|------------|-----------------------------|--------|
| `u8`   | 1 byte     | 0 a 255                     | `byte` |
| `u16`  | 2 byte     | 0 a 65.535                  | -      |
| `u32`  | 4 byte     | 0 a 4.294.967.295           | -      |
| `u64`  | 8 byte     | 0 a 18.446.744.073.709.551.615 | -   |

**Esempi:**
```hemlock
let a: u8 = 255;
let b: u16 = 65535;
let c: u32 = 4294967295;
let d: u64 = 18446744073709551615;

// Alias di tipo
let val_byte: byte = 65;  // Uguale a u8
```

#### Virgola Mobile

| Tipo   | Dimensione | Precisione   | Alias    |
|--------|------------|--------------|----------|
| `f32`  | 4 byte     | ~7 cifre     | -        |
| `f64`  | 8 byte     | ~15 cifre    | `number` |

**Esempi:**
```hemlock
let pi: f32 = 3.14159;
let preciso: f64 = 3.14159265359;

// Alias di tipo
let x: number = 2.718;  // Uguale a f64
```

---

### Inferenza dei Letterali Interi

I letterali interi sono tipizzati automaticamente in base al loro valore:

**Regole:**
- Valori nell'intervallo i32 (-2.147.483.648 a 2.147.483.647): inferiti come `i32`
- Valori fuori dall'intervallo i32 ma nell'intervallo i64: inferiti come `i64`
- Usa annotazioni di tipo esplicite per altri tipi (i8, i16, u8, u16, u32, u64)

**Esempi:**
```hemlock
let piccolo = 42;                    // i32 (sta in i32)
let grande = 5000000000;             // i64 (> max i32)
let max_i64 = 9223372036854775807;   // i64 (INT64_MAX)
let esplicito: u32 = 100;            // u32 (annotazione sovrascrive)
```

---

### Tipo Booleano

**Tipo:** `bool`

**Valori:** `true`, `false`

**Dimensione:** 1 byte (internamente)

**Esempi:**
```hemlock
let attivo: bool = true;
let fatto = false;

if (attivo && !fatto) {
    print("lavorando");
}
```

---

### Tipi Carattere

#### Rune

**Tipo:** `rune`

**Descrizione:** Codepoint Unicode (U+0000 a U+10FFFF)

**Dimensione:** 4 byte (valore 32-bit)

**Intervallo:** 0 a 0x10FFFF (1.114.111)

**Sintassi Letterale:** Apici singoli `'x'`

**Esempi:**
```hemlock
// ASCII
let a = 'A';
let cifra = '0';

// UTF-8 multi-byte
let razzo = 'ðŸš€';      // U+1F680
let cuore = 'â¤';       // U+2764
let cinese = 'ä¸­';     // U+4E2D

// Sequenze di escape
let newline = '\n';
let tab = '\t';
let backslash = '\\';
let apice = '\'';
let null_char = '\0';

// Escape Unicode
let emoji = '\u{1F680}';   // Fino a 6 cifre hex
let max = '\u{10FFFF}';    // Codepoint massimo
```

**Conversioni di Tipo:**
```hemlock
// Intero a rune
let codice: rune = 65;        // 'A'
let r: rune = 128640;         // ðŸš€

// Rune a intero
let valore: i32 = 'Z';        // 90

// Rune a stringa
let s: string = 'H';          // "H"

// u8 a rune
let byte_val: u8 = 65;
let rune_val: rune = byte_val;  // 'A'
```

**Vedi Anche:** [API delle Stringhe](#reference-string-api) per concatenazione stringa + rune

---

### Tipo Stringa

**Tipo:** `string`

**Descrizione:** Testo codificato UTF-8, mutabile, allocato nell'heap

**Codifica:** UTF-8 (U+0000 a U+10FFFF)

**MutabilitÃ :** Mutabile (diversamente dalla maggior parte dei linguaggi)

**ProprietÃ :**
- `.length` - Conteggio codepoint (numero di caratteri)
- `.byte_length` - Conteggio byte (dimensione codifica UTF-8)

**Sintassi Letterale:** Virgolette doppie `"testo"`

**Esempi:**
```hemlock
let s = "ciao";
s[0] = 'C';             // Muta (ora "Ciao")
print(s.length);        // 5 (conteggio codepoint)
print(s.byte_length);   // 5 (byte UTF-8)

let emoji = "ðŸš€";
print(emoji.length);        // 1 (un codepoint)
print(emoji.byte_length);   // 4 (quattro byte UTF-8)
```

**Indicizzazione:**
```hemlock
let s = "ciao";
let ch = s[0];          // Restituisce rune 'c'
s[0] = 'C';             // Imposta con rune
```

**Vedi Anche:** [API delle Stringhe](#reference-string-api) per riferimento completo dei metodi

---

### Tipo Null

**Tipo:** `null`

**Descrizione:** Il valore null (assenza di valore)

**Dimensione:** 8 byte (internamente)

**Valore:** `null`

**Esempi:**
```hemlock
let x = null;
let y: i32 = null;  // ERRORE: mismatch di tipo

if (x == null) {
    print("x Ã¨ null");
}
```

---

## Tipi Composti

### Tipo Array

**Tipo:** `array`

**Descrizione:** Array dinamico, allocato nell'heap, a tipi misti

**ProprietÃ :**
- `.length` - Numero di elementi

**Indicizzazione a base zero:** SÃ¬

**Sintassi Letterale:** `[elem1, elem2, ...]`

**Esempi:**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr[0]);         // 1
print(arr.length);     // 5

// Tipi misti
let misto = [1, "ciao", true, null];
```

**Vedi Anche:** [API degli Array](#reference-array-api) per riferimento completo dei metodi

---

### Tipo Oggetto

**Tipo:** `object`

**Descrizione:** Oggetto stile JavaScript con campi dinamici

**Sintassi Letterale:** `{ campo: valore, ... }`

**Esempi:**
```hemlock
let persona = { nome: "Alice", eta: 30 };
print(persona.nome);  // "Alice"

// Aggiunge campo dinamicamente
persona.email = "alice@esempio.com";
```

**Definizioni di Tipo:**
```hemlock
define Persona {
    nome: string,
    eta: i32,
    attivo?: bool,  // Campo opzionale
}

let p: Persona = { nome: "Bob", eta: 25 };
print(typeof(p));  // "Persona"
```

---

### Tipi Puntatore

#### Puntatore Grezzo (ptr)

**Tipo:** `ptr`

**Descrizione:** Indirizzo di memoria grezzo (non sicuro)

**Dimensione:** 8 byte

**Controllo Limiti:** Nessuno

**Esempi:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

#### Buffer (buffer)

**Tipo:** `buffer`

**Descrizione:** Wrapper sicuro del puntatore con controllo limiti

**Struttura:** Puntatore + lunghezza + capacitÃ 

**ProprietÃ :**
- `.length` - Dimensione buffer
- `.capacity` - CapacitÃ  allocata

**Esempi:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // Con controllo limiti
print(b.length);        // 64
free(b);
```

**Vedi Anche:** [API della Memoria](#reference-memory-api) per funzioni di allocazione

---

## Tipi Speciali

### Tipo File

**Tipo:** `file`

**Descrizione:** Handle di file per operazioni di I/O

**ProprietÃ :**
- `.path` - Percorso del file (string)
- `.mode` - ModalitÃ  di apertura (string)
- `.closed` - Se il file Ã¨ chiuso (bool)

**Vedi Anche:** [API dei File](#reference-file-api)

---

### Tipo Task

**Tipo:** `task`

**Descrizione:** Handle per task concorrente

**Vedi Anche:** [API di Concorrenza](#reference-concurrency-api)

---

### Tipo Channel

**Tipo:** `channel`

**Descrizione:** Canale di comunicazione thread-safe

**Vedi Anche:** [API di Concorrenza](#reference-concurrency-api)

---

### Tipo Funzione

**Tipo:** `function`

**Descrizione:** Valore funzione di prima classe

**Esempi:**
```hemlock
fn somma(a, b) {
    return a + b;
}

let moltiplica = fn(x, y) {
    return x * y;
};

print(typeof(somma));      // "function"
print(typeof(moltiplica)); // "function"
```

---

### Tipo Void

**Tipo:** `void`

**Descrizione:** Assenza di valore di ritorno (uso interno)

---

## Regole di Promozione dei Tipi

Quando si mescolano tipi nelle operazioni, Hemlock promuove al tipo "superiore":

**Gerarchia di Promozione:**
```
f64 (precisione massima)
 â†‘
f32
 â†‘
u64
 â†‘
i64
 â†‘
u32
 â†‘
i32
 â†‘
u16
 â†‘
i16
 â†‘
u8
 â†‘
i8 (minima)
```

**Regole:**
1. Il float vince sempre sull'intero
2. Dimensione maggiore vince nella stessa categoria (int/uint/float)
3. Entrambi gli operandi sono promossi al tipo risultato
4. **Preservazione precisione:** i64/u64 + f32 promuove a f64 (non f32)

**Esempi:**
```hemlock
// Promozione dimensione
u8 + i32    â†’ i32    // Dimensione maggiore vince
i32 + i64   â†’ i64    // Dimensione maggiore vince
u32 + u64   â†’ u64    // Dimensione maggiore vince

// Promozione float
i32 + f32   â†’ f32    // Float vince, f32 sufficiente per i32
i64 + f32   â†’ f64    // Promuove a f64 per preservare precisione i64
i64 + f64   â†’ f64    // Float vince sempre
i8 + f64    â†’ f64    // Float + piÃ¹ grande vince
```

**PerchÃ© i64 + f32 â†’ f64?**

f32 ha solo una mantissa di 24 bit, che non puÃ² rappresentare precisamente interi
piÃ¹ grandi di 2^24 (16.777.216). PoichÃ© i64 puÃ² contenere valori fino a 2^63,
mescolare i64 con f32 causerebbe grave perdita di precisione. Hemlock promuove
a f64 (mantissa 53 bit) invece.

---

## Controllo dell'Intervallo

Le annotazioni di tipo impongono controlli dell'intervallo all'assegnazione:

**Assegnazioni Valide:**
```hemlock
let x: u8 = 255;             // OK
let y: i8 = 127;             // OK
let a: i64 = 2147483647;     // OK
let b: u64 = 4294967295;     // OK
```

**Assegnazioni Non Valide (Errore a Runtime):**
```hemlock
let x: u8 = 256;             // ERRORE: fuori intervallo
let y: i8 = 128;             // ERRORE: max Ã¨ 127
let z: u64 = -1;             // ERRORE: u64 non puÃ² essere negativo
```

---

## Introspezione dei Tipi

### typeof(valore)

Restituisce il nome del tipo come stringa.

**Firma:**
```hemlock
typeof(valore: any): string
```

**Restituisce:**
- Tipi primitivi: `"i8"`, `"i16"`, `"i32"`, `"i64"`, `"u8"`, `"u16"`, `"u32"`, `"u64"`, `"f32"`, `"f64"`, `"bool"`, `"string"`, `"rune"`, `"null"`
- Tipi composti: `"array"`, `"object"`, `"ptr"`, `"buffer"`, `"function"`
- Tipi speciali: `"file"`, `"task"`, `"channel"`
- Oggetti tipizzati: Nome del tipo personalizzato (es. `"Persona"`)

**Esempi:**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("ciao"));          // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"

define Persona { nome: string }
let p: Persona = { nome: "Alice" };
print(typeof(p));               // "Persona"
```

**Vedi Anche:** [Funzioni Integrate](builtins.md#typeof)

---

## Conversioni di Tipo

### Conversioni Implicite

Hemlock esegue conversioni di tipo implicite nelle operazioni aritmetiche seguendo le regole di promozione dei tipi.

**Esempi:**
```hemlock
let a: u8 = 10;
let b: i32 = 20;
let risultato = a + b;     // risultato Ã¨ i32 (promosso)
```

### Conversioni Esplicite

Usa le annotazioni di tipo per conversioni esplicite:

**Esempi:**
```hemlock
// Intero a float
let i: i32 = 42;
let f: f64 = i;         // 42.0

// Float a intero (tronca)
let x: f64 = 3.14;
let y: i32 = x;         // 3

// Intero a rune
let codice: rune = 65;  // 'A'

// Rune a intero
let valore: i32 = 'Z';  // 90

// Rune a stringa
let s: string = 'H';    // "H"
```

---

## Alias di Tipo

### Alias Integrati

Hemlock fornisce alias di tipo integrati per tipi comuni:

| Alias     | Tipo Effettivo | Uso                      |
|-----------|----------------|--------------------------|
| `integer` | `i32`          | Interi generici          |
| `number`  | `f64`          | Float generici           |
| `byte`    | `u8`           | Valori byte              |

**Esempi:**
```hemlock
let conteggio: integer = 100;       // Uguale a i32
let prezzo: number = 19.99;         // Uguale a f64
let b: byte = 255;                  // Uguale a u8
```

### Alias di Tipo Personalizzati

Definisci alias di tipo personalizzati usando la parola chiave `type`:

```hemlock
// Alias semplici
type Intero = i32;
type Testo = string;

// Alias di tipo funzione
type Callback = fn(i32): void;
type Predicato = fn(any): bool;
type OpBinaria = fn(i32, i32): i32;

// Alias di tipo composto
define HaNome { nome: string }
define HaEta { eta: i32 }
type Persona = HaNome & HaEta;

// Alias di tipo generico
type Coppia<T> = { primo: T, secondo: T };
type Risultato<T, E> = { valore: T?, errore: E? };
```

**Usando alias personalizzati:**
```hemlock
let cb: Callback = fn(n) { print(n); };
let p: Persona = { nome: "Alice", eta: 30 };
let coord: Coppia<f64> = { primo: 3.14, secondo: 2.71 };
```

**Nota:** Gli alias di tipo sono trasparenti - `typeof()` restituisce il nome del tipo sottostante.

---

## Tipi Funzione

I tipi funzione specificano la firma dei valori funzione:

### Sintassi

```hemlock
fn(tipi_parametri): tipo_ritorno
```

### Esempi

```hemlock
// Tipo funzione base
let somma: fn(i32, i32): i32 = fn(a, b) { return a + b; };

// Parametro funzione
fn applica(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Funzione di ordine superiore che restituisce funzione
fn crea_sommatore(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Tipo funzione async
fn esegui_async(handler: async fn(): void) {
    spawn(handler);
}
```

---

## Tipi Composti (Intersezione)

I tipi composti usano `&` per richiedere vincoli di tipo multipli:

```hemlock
define HaNome { nome: string }
define HaEta { eta: i32 }
define HaEmail { email: string }

// L'oggetto deve soddisfare tutti i tipi
let persona: HaNome & HaEta = { nome: "Alice", eta: 30 };

// Tre o piÃ¹ tipi
fn descrivi(p: HaNome & HaEta & HaEmail) {
    print(p.nome + " <" + p.email + ">");
}
```

---

## Tabella Riassuntiva

| Tipo       | Dim.     | Mutabile | Heap   | Descrizione                    |
|------------|----------|----------|--------|--------------------------------|
| `i8`-`i64` | 1-8 byte | No       | No     | Interi con segno               |
| `u8`-`u64` | 1-8 byte | No       | No     | Interi senza segno             |
| `f32`      | 4 byte   | No       | No     | Float singola precisione       |
| `f64`      | 8 byte   | No       | No     | Float doppia precisione        |
| `bool`     | 1 byte   | No       | No     | Booleano                       |
| `rune`     | 4 byte   | No       | No     | Codepoint Unicode              |
| `string`   | Variabile| SÃ¬       | SÃ¬     | Testo UTF-8                    |
| `array`    | Variabile| SÃ¬       | SÃ¬     | Array dinamico                 |
| `object`   | Variabile| SÃ¬       | SÃ¬     | Oggetto dinamico               |
| `ptr`      | 8 byte   | No       | No     | Puntatore grezzo               |
| `buffer`   | Variabile| SÃ¬       | SÃ¬     | Wrapper puntatore sicuro       |
| `file`     | Opaco    | SÃ¬       | SÃ¬     | Handle file                    |
| `task`     | Opaco    | No       | SÃ¬     | Handle task concorrente        |
| `channel`  | Opaco    | SÃ¬       | SÃ¬     | Canale thread-safe             |
| `function` | Opaco    | No       | SÃ¬     | Valore funzione                |
| `null`     | 8 byte   | No       | No     | Valore null                    |

---

## Vedi Anche

- [Riferimento Operatori](#reference-operators) - Comportamento dei tipi nelle operazioni
- [Funzioni Integrate](#reference-builtins) - Introspezione e conversione tipi
- [API delle Stringhe](#reference-string-api) - Metodi del tipo stringa
- [API degli Array](#reference-array-api) - Metodi del tipo array
- [API della Memoria](#reference-memory-api) - Operazioni su puntatori e buffer



################################################################################
# DESIGN E FILOSOFIA
################################################################################

--------------------------------------------------------------------------------
## Filosofia
--------------------------------------------------------------------------------

# Filosofia di Progettazione del Linguaggio Hemlock

> "Un linguaggio piccolo e non sicuro per scrivere cose non sicure in modo sicuro."

Questo documento cattura i principi fondamentali di progettazione e la filosofia di Hemlock. Leggi questo prima di apportare modifiche o aggiunte al linguaggio.

---

## Sommario

- [IdentitÃ  Fondamentale](#identitÃ -fondamentale)
- [Principi di Progettazione](#principi-di-progettazione)
- [Filosofia sulla Sicurezza](#filosofia-sulla-sicurezza)
- [Cosa NON Aggiungere](#cosa-non-aggiungere)
- [Considerazioni Future](#considerazioni-future)
- [Riflessioni Finali](#riflessioni-finali)

---

## IdentitÃ  Fondamentale

Hemlock Ã¨ un **linguaggio di scripting per sistemi** che abbraccia la gestione manuale della memoria e il controllo esplicito. Ãˆ progettato per programmatori che vogliono:

- La potenza del C
- L'ergonomia dei moderni linguaggi di scripting
- Concorrenza asincrona strutturata integrata
- Nessun comportamento nascosto o magia

### Cosa Hemlock NON Ãˆ

- **Memory-safe** (i puntatori dangling sono responsabilitÃ  tua)
- **Un sostituto di Rust, Go o Lua**
- **Un linguaggio che nasconde la complessitÃ **

### Cosa Hemlock Ãˆ

- **Esplicito su implicito, sempre**
- **Educativo e sperimentale**
- **Un "livello di scripting C" per lavoro sui sistemi**
- **Onesto sui compromessi**

---

## Principi di Progettazione

### 1. Esplicito su Implicito

Hemlock favorisce l'esplicitezza in tutti i costrutti del linguaggio. Non dovrebbero esserci sorprese, magie o comportamenti nascosti.

**Male (implicito):**
```hemlock
let x = 5  // Punto e virgola mancante - dovrebbe dare errore
```

**Bene (esplicito):**
```hemlock
let x = 5;
free(ptr);  // Lo hai allocato tu, lo liberi tu
```

**Aspetti chiave:**
- I punti e virgola sono obbligatori (nessuna inserzione automatica)
- Nessun garbage collection
- Gestione manuale della memoria (alloc/free)
- Le annotazioni di tipo sono opzionali ma verificate a runtime
- Nessuna pulizia automatica delle risorse (no RAII), ma `defer` fornisce pulizia esplicita

### 2. Dinamico di Default, Tipizzato per Scelta

Ogni valore ha un tag di tipo a runtime, ma il sistema Ã¨ progettato per essere flessibile pur catturando gli errori.

**Inferenza dei tipi:**
- Interi piccoli (stanno in i32): `42` â†’ `i32`
- Interi grandi (> intervallo i32): `9223372036854775807` â†’ `i64`
- Float: `3.14` â†’ `f64`

**Tipizzazione esplicita quando necessaria:**
```hemlock
let x = 42;              // i32 inferito (valore piccolo)
let y: u8 = 255;         // u8 esplicito
let z = x + y;           // promuove a i32
let grande = 5000000000; // i64 inferito (> max i32)
```

**Le regole di promozione dei tipi** seguono una gerarchia chiara dal piÃ¹ piccolo al piÃ¹ grande, con i float che vincono sempre sugli interi.

### 3. Non Sicuro Ã¨ una Caratteristica, Non un Bug

Hemlock non cerca di prevenire tutti gli errori. Invece, ti dÃ  gli strumenti per essere sicuro permettendoti di optare per comportamenti non sicuri quando necessario.

**Esempi di non sicurezza intenzionale:**
- L'aritmetica dei puntatori puÃ² causare overflow (responsabilitÃ  dell'utente)
- Nessun controllo dei limiti sui `ptr` grezzi (usa `buffer` se vuoi sicurezza)
- I double-free causano crash (gestione manuale della memoria)
- Il sistema dei tipi previene gli incidenti ma permette operazioni rischiose quando necessario

```hemlock
let p = alloc(10);
let q = p + 100;  // Molto oltre l'allocazione - permesso ma pericoloso
```

**La filosofia:** Il sistema dei tipi dovrebbe prevenire gli *incidenti* ma permettere operazioni non sicure *intenzionali*.

### 4. Concorrenza Strutturata di Prima Classe

La concorrenza non Ã¨ un ripensamento in Hemlock. Ãˆ integrata nel linguaggio dalle fondamenta.

**Caratteristiche chiave:**
- `async`/`await` integrati nel linguaggio
- Canali per la comunicazione
- `spawn`/`join`/`detach` per la gestione dei task
- Nessun thread grezzo, nessun lock - solo strutturato
- Vero parallelismo multi-thread usando thread POSIX

**Non un event loop o green thread** - Hemlock usa veri thread del sistema operativo per un vero parallelismo su piÃ¹ core CPU.

### 5. Sintassi Simile al C, Poca Cerimonia

Hemlock dovrebbe risultare familiare ai programmatori di sistemi riducendo il boilerplate.

**Scelte di progettazione:**
- Blocchi `{}` sempre, nessuna parentesi opzionale
- Gli operatori corrispondono al C: `+`, `-`, `*`, `/`, `&&`, `||`, `!`
- La sintassi dei tipi corrisponde a Rust/TypeScript: `let x: tipo = valore;`
- Le funzioni sono valori di prima classe
- Parole chiave e forme speciali minimali

---

## Filosofia sulla Sicurezza

**La posizione di Hemlock sulla sicurezza:**

> "Ti diamo gli strumenti per essere sicuro (`buffer`, annotazioni di tipo, controllo dei limiti) ma non ti obblighiamo a usarli (`ptr`, memoria manuale, operazioni non sicure).
>
> Il default dovrebbe guidare verso la sicurezza, ma la via d'uscita dovrebbe essere sempre disponibile."

### Strumenti di Sicurezza Forniti

**1. Tipo buffer sicuro:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // controllo dei limiti
print(b.length);        // 64
free(b);                // ancora manuale
```

**2. Puntatori grezzi non sicuri:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // Devi ricordarti di liberare
```

**3. Annotazioni di tipo:**
```hemlock
let x: u8 = 255;   // OK
let y: u8 = 256;   // ERRORE: fuori intervallo
```

**4. Controllo dei tipi a runtime:**
```hemlock
let val = qualche_funzione();
if (typeof(val) == "i32") {
    // Sicuro da usare come intero
}
```

### Principi Guida

1. **Default a pattern sicuri nella documentazione** - Mostra `buffer` prima di `ptr`, incoraggia le annotazioni di tipo
2. **Rendi ovvie le operazioni non sicure** - L'aritmetica dei puntatori grezzi dovrebbe sembrare intenzionale
3. **Fornisci vie d'uscita** - Non impedire agli utenti esperti di fare lavoro a basso livello
4. **Sii onesto sui compromessi** - Documenta cosa puÃ² andare storto

### Esempi di Sicurezza vs. Non Sicurezza

| Pattern Sicuro | Pattern Non Sicuro | Quando Usare Non Sicuro |
|----------------|-------------------|------------------------|
| tipo `buffer` | tipo `ptr` | FFI, codice critico per le prestazioni |
| Annotazioni di tipo | Nessuna annotazione | Interfacce esterne, validazione |
| Accesso con controllo limiti | Aritmetica puntatori | Operazioni memoria a basso livello |
| Gestione eccezioni | Restituzione null/codici errore | Quando le eccezioni sono troppo pesanti |

---

## Cosa NON Aggiungere

Capire cosa **non** aggiungere Ã¨ importante quanto sapere cosa aggiungere.

### Non Aggiungere Comportamento Implicito

**Esempi negativi:**

```hemlock
// MALE: Inserzione automatica punto e virgola
let x = 5
let y = 10

// MALE: Conversioni di tipo implicite che perdono precisione
let x: i32 = 3.14  // Dovrebbe troncare o dare errore?
```

**PerchÃ©:** Il comportamento implicito crea sorprese e rende il codice piÃ¹ difficile da ragionare.

### Non Nascondere la ComplessitÃ 

**Esempi negativi:**

```hemlock
// MALE: Ottimizzazione magica dietro le quinte
let arr = [1, 2, 3]  // Ãˆ sullo stack o nell'heap? L'utente dovrebbe saperlo! (Heap, refcounted)

// MALE: Puntatore grezzo liberato automaticamente
let p = alloc(100)  // Si libera automaticamente? NO! I ptr grezzi richiedono sempre free()
```

**Nota sul refcounting:** Hemlock usa il refcounting interno per stringhe, array, oggetti e buffer - questi SONO liberati automaticamente quando lo scope esce. Questo Ã¨ esplicito e prevedibile (pulizia deterministica quando ref raggiunge 0, nessuna pausa GC). I puntatori grezzi (`ptr` da `alloc()`) NON sono refcounted e richiedono sempre `free()` manuale.

**PerchÃ©:** La complessitÃ  nascosta rende impossibile prevedere le prestazioni e debuggare i problemi.

### Non Rompere la Semantica Esistente

**Non cambiare mai queste decisioni fondamentali:**
- I punti e virgola sono obbligatori - non renderli opzionali
- Gestione manuale della memoria - non aggiungere GC
- Stringhe mutabili - non renderle immutabili
- Controllo dei tipi a runtime - non rimuoverlo

**PerchÃ©:** Consistenza e stabilitÃ  sono piÃ¹ importanti delle funzionalitÃ  alla moda.

### Non Aggiungere FunzionalitÃ  "Comode" Che Riducono l'Esplicitezza

**Esempi di funzionalitÃ  da evitare:**
- Overloading degli operatori (forse per tipi utente, ma con attenzione)
- Coercizione di tipo implicita che perde informazioni
- Pulizia automatica delle risorse (RAII)
- Concatenamento di metodi che nasconde complessitÃ 
- DSL e sintassi magica

**Eccezione:** Le funzionalitÃ  comode vanno bene se sono **zucchero sintattico esplicito** su operazioni semplici:
- `else if` va bene (sono solo istruzioni if annidate)
- L'interpolazione di stringhe potrebbe andare bene se Ã¨ chiaramente zucchero sintattico
- La sintassi dei metodi per gli oggetti va bene (Ã¨ esplicito cosa fa)

---

## Considerazioni Future

### Forse Aggiungere (In Discussione)

Queste funzionalitÃ  si allineano con la filosofia di Hemlock ma necessitano di progettazione attenta:

**1. Pattern matching**
```hemlock
match (valore) {
    case i32: print("intero");
    case string: print("testo");
    case _: print("altro");
}
```
- Controllo dei tipi esplicito
- Nessun costo nascosto
- Possibile controllo esaustivitÃ  a compile-time

**2. Tipi errore (`Result<T, E>`)**
```hemlock
fn dividi(a: i32, b: i32): Result<i32, string> {
    if (b == 0) {
        return Err("divisione per zero");
    }
    return Ok(a / b);
}
```
- Gestione errori esplicita
- Forza gli utenti a pensare agli errori
- Alternativa alle eccezioni

**3. Tipi array/slice**
- Abbiamo giÃ  array dinamici
- Potremmo aggiungere array di dimensione fissa per allocazione sullo stack
- Dovrebbe essere esplicito su stack vs. heap

**4. Strumenti di sicurezza memoria migliorati**
- Flag opzionale per controllo limiti
- Rilevamento memory leak nelle build di debug
- Integrazione sanitizer

### Probabilmente Mai Aggiungere

Queste funzionalitÃ  violano i principi fondamentali:

**1. Garbage collection**
- Nasconde la complessitÃ  della gestione memoria
- Prestazioni imprevedibili
- Contro il principio del controllo esplicito

**2. Gestione automatica della memoria**
- Stesse ragioni del GC
- Il reference counting potrebbe andare bene se esplicito

**3. Conversioni di tipo implicite che perdono dati**
- Va contro "esplicito su implicito"
- Fonte di bug sottili

**4. Macro (complesse)**
- Troppa potenza, troppa complessitÃ 
- Un sistema macro semplice potrebbe andare bene
- Preferisci generazione di codice o funzioni

**5. OOP basata su classi con ereditarietÃ **
- Troppo comportamento implicito
- Duck typing e oggetti sono sufficienti
- Composizione su ereditarietÃ 

**6. Sistema di moduli con risoluzione complessa**
- Mantieni gli import semplici ed espliciti
- Nessun percorso di ricerca magico
- Nessuna risoluzione versioni (usa il package manager del sistema operativo)

---

## Riflessioni Finali

### Fiducia e ResponsabilitÃ 

Hemlock riguarda **fiducia e responsabilitÃ **. Ci fidiamo del programmatore per:

- Gestire la memoria correttamente
- Usare i tipi appropriatamente
- Gestire gli errori propriamente
- Capire i compromessi

In cambio, Hemlock fornisce:

- Nessun costo nascosto
- Nessun comportamento sorprendente
- Controllo completo quando necessario
- Strumenti di sicurezza quando voluti

### La Domanda Guida

**Quando si considera una nuova funzionalitÃ , chiedi:**

> "Questo dÃ  al programmatore piÃ¹ controllo esplicito, o nasconde qualcosa?"

- Se **aggiunge controllo esplicito** â†’ probabilmente adatto a Hemlock
- Se **nasconde complessitÃ ** â†’ probabilmente non appartiene
- Se Ã¨ **zucchero opzionale** chiaramente documentato â†’ potrebbe andare bene

### Esempi di Buone Aggiunte

- **Istruzioni switch** - Flusso di controllo esplicito, nessuna magia, semantica chiara

- **Async/await con pthread** - Concorrenza esplicita, vero parallelismo, l'utente controlla lo spawning

- **Tipo buffer insieme a ptr** - DÃ  scelta tra sicuro e non sicuro

- **Annotazioni di tipo opzionali** - Aiuta a catturare bug senza forzare rigiditÃ 

- **Try/catch/finally** - Gestione errori esplicita con flusso di controllo chiaro

### Esempi di Cattive Aggiunte

- **Inserzione automatica punto e virgola** - Nasconde errori di sintassi, rende il codice ambiguo

- **RAII/distruttori** - Pulizia automatica nasconde quando le risorse vengono rilasciate

- **Null coalescing implicito** - Nasconde i controlli null, rende il codice piÃ¹ difficile da ragionare

- **Stringhe che crescono automaticamente** - Nasconde allocazione memoria, prestazioni imprevedibili

---

## Conclusione

Hemlock non cerca di essere il linguaggio piÃ¹ sicuro, il piÃ¹ veloce, o il piÃ¹ ricco di funzionalitÃ .

**Hemlock cerca di essere il linguaggio piÃ¹ *onesto*.**

Ti dice esattamente cosa sta facendo, ti dÃ  controllo quando ne hai bisogno, e non nasconde gli spigoli affilati. Ãˆ un linguaggio per persone che vogliono capire il loro codice a basso livello godendo comunque di ergonomia moderna.

Se non sei sicuro se una funzionalitÃ  appartiene a Hemlock, ricorda:

> **Esplicito su implicito, sempre.**
> **Non sicuro Ã¨ una caratteristica, non un bug.**
> **L'utente Ã¨ responsabile, e va bene cosÃ¬.**


--------------------------------------------------------------------------------
## Implementazione
--------------------------------------------------------------------------------

# Dettagli di Implementazione di Hemlock

Questo documento descrive l'implementazione tecnica del linguaggio Hemlock, inclusa la struttura del progetto, la pipeline di compilazione, l'architettura del runtime e le decisioni di progettazione.

---

## Sommario

- [Struttura del Progetto](#struttura-del-progetto)
- [Pipeline di Compilazione](#pipeline-di-compilazione)
- [Design Modulare dell'Interprete](#design-modulare-dellinterprete)
- [Architettura del Runtime](#architettura-del-runtime)
- [Rappresentazione dei Valori](#rappresentazione-dei-valori)
- [Implementazione del Sistema di Tipi](#implementazione-del-sistema-di-tipi)
- [Gestione della Memoria](#gestione-della-memoria)
- [Modello di Concorrenza](#modello-di-concorrenza)
- [Piani Futuri](#piani-futuri)

---

## Struttura del Progetto

```
hemlock/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ frontend/              # Condiviso: lexer, parser, AST
â”‚   â”‚   â”œâ”€â”€ lexer.c            # Tokenizzazione
â”‚   â”‚   â”œâ”€â”€ parser/            # Parser a discesa ricorsiva
â”‚   â”‚   â”œâ”€â”€ ast.c              # Gestione nodi AST
â”‚   â”‚   â””â”€â”€ module.c           # Risoluzione moduli
â”‚   â”œâ”€â”€ backends/
â”‚   â”‚   â”œâ”€â”€ interpreter/       # hemlock: interprete tree-walking
â”‚   â”‚   â”‚   â”œâ”€â”€ main.c         # Entry point CLI
â”‚   â”‚   â”‚   â”œâ”€â”€ runtime.c      # Valutazione espressioni/istruzioni
â”‚   â”‚   â”‚   â”œâ”€â”€ builtins.c     # Funzioni integrate
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â””â”€â”€ compiler/          # hemlockc: generatore codice C
â”‚   â”‚       â”œâ”€â”€ main.c         # CLI, orchestrazione
â”‚   â”‚       â”œâ”€â”€ type_check.c   # Controllo tipi compile-time
â”‚   â”‚       â”œâ”€â”€ codegen.c      # Contesto generazione codice
â”‚   â”‚       â”œâ”€â”€ codegen_expr.c # Generazione espressioni
â”‚   â”‚       â”œâ”€â”€ codegen_stmt.c # Generazione istruzioni
â”‚   â”‚       â””â”€â”€ ...
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ lsp/               # Language Server Protocol
â”‚   â”‚   â””â”€â”€ bundler/           # Strumenti bundle/package
â”œâ”€â”€ runtime/                   # libhemlock_runtime.a (per programmi compilati)
â”œâ”€â”€ stdlib/                    # Libreria standard (39 moduli)
â”‚   â””â”€â”€ docs/                  # Documentazione moduli
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ parity/                # Test che devono passare entrambi i backend
â”‚   â”œâ”€â”€ interpreter/           # Test specifici interprete
â”‚   â””â”€â”€ compiler/              # Test specifici compilatore
â”œâ”€â”€ examples/                  # Programmi di esempio
â””â”€â”€ docs/                      # Documentazione
```

### Organizzazione delle Directory

**`include/`** - Header API pubblici che definiscono l'interfaccia tra i componenti:
- Separazione pulita tra lexer, parser, AST e interprete
- Dichiarazioni forward per minimizzare le dipendenze
- API pubblica per incorporare Hemlock in altri programmi

**`src/`** - File di implementazione:
- I file di livello superiore gestiscono lexing, parsing, gestione AST
- `main.c` fornisce CLI e REPL
- L'interprete Ã¨ modularizzato in sottosistemi separati

**`src/interpreter/`** - Implementazione modulare dell'interprete:
- Ogni modulo ha una singola, chiara responsabilitÃ 
- API interna definita in `internal.h` per comunicazione inter-modulo
- I moduli possono essere compilati indipendentemente per build piÃ¹ veloci

**`tests/`** - Suite di test completa:
- Organizzata per area funzionale
- Ogni directory contiene casi di test focalizzati
- `run_tests.sh` orchestra l'esecuzione dei test

---

## Pipeline di Compilazione

Hemlock usa una pipeline di compilazione tradizionale con fasi distinte:

### Fase 1: Analisi Lessicale (Lexer)

**Input:** Testo del codice sorgente
**Output:** Stream di token
**Implementazione:** `src/lexer.c`

```
Sorgente: "let x = 42;"
   â†“
Token: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
```

**Caratteristiche principali:**
- Riconosce parole chiave, identificatori, letterali, operatori, punteggiatura
- Gestisce letterali stringa UTF-8 e letterali rune
- Riporta numeri di riga per messaggi di errore
- Passata singola, nessun backtracking

### Fase 2: Analisi Sintattica (Parser)

**Input:** Stream di token
**Output:** Abstract Syntax Tree (AST)
**Implementazione:** `src/parser.c`

```
Token: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
   â†“
AST: LetStmt {
    name: "x",
    type: null,
    value: IntLiteral(42)
}
```

**Caratteristiche principali:**
- Parser a discesa ricorsiva
- Costruisce rappresentazione ad albero della struttura del programma
- Gestisce la precedenza degli operatori
- Valida la sintassi (parentesi, punti e virgola, ecc.)
- Nessuna analisi semantica ancora (fatta a runtime)

**Precedenza Operatori (dalla piÃ¹ bassa alla piÃ¹ alta):**
1. Assegnazione: `=`
2. OR logico: `||`
3. AND logico: `&&`
4. OR bit a bit: `|`
5. XOR bit a bit: `^`
6. AND bit a bit: `&`
7. Uguaglianza: `==`, `!=`
8. Confronto: `<`, `>`, `<=`, `>=`
9. Shift bit a bit: `<<`, `>>`
10. Addizione/Sottrazione: `+`, `-`
11. Moltiplicazione/Divisione/Modulo: `*`, `/`, `%`
12. Unario: `!`, `-`, `~`
13. Chiamata/Indice/Membro: `()`, `[]`, `.`

### Fase 3a: Interpretazione (Tree-Walking)

**Input:** AST
**Output:** Esecuzione del programma
**Implementazione:** `src/backends/interpreter/runtime.c`

```
AST: LetStmt { ... }
   â†“
Esecuzione: Valuta nodi AST ricorsivamente
   â†“
Risultato: Variabile x creata con valore 42
```

**Caratteristiche principali:**
- Attraversamento diretto dell'AST (interprete tree-walking)
- Controllo dinamico dei tipi a runtime
- Storage delle variabili basato su environment

### Fase 3b: Compilazione (hemlockc)

**Input:** AST
**Output:** Eseguibile nativo via generazione codice C
**Implementazione:** `src/backends/compiler/`

```
AST: LetStmt { ... }
   â†“
Controllo Tipi: Valida tipi a compile-time
   â†“
Codegen C: Genera codice C equivalente
   â†“
GCC: Compila C in binario nativo
   â†“
Risultato: Eseguibile standalone
```

**Caratteristiche principali:**
- Controllo tipi a compile-time (abilitato di default)
- Generazione codice C per portabilitÃ 
- Linka contro `libhemlock_runtime.a`
- Esecuzione significativamente piÃ¹ veloce dell'interprete

---

## Backend Compilatore (hemlockc)

Il compilatore Hemlock genera codice C dall'AST, che viene poi compilato in un eseguibile nativo usando GCC.

### Architettura del Compilatore

```
src/backends/compiler/
â”œâ”€â”€ main.c              # CLI, parsing argomenti, orchestrazione
â”œâ”€â”€ codegen.c           # Contesto core generazione codice
â”œâ”€â”€ codegen_expr.c      # Generazione codice espressioni
â”œâ”€â”€ codegen_stmt.c      # Generazione codice istruzioni
â”œâ”€â”€ codegen_call.c      # Generazione chiamate funzione
â”œâ”€â”€ codegen_closure.c   # Implementazione closure
â”œâ”€â”€ codegen_program.c   # Generazione programma top-level
â”œâ”€â”€ codegen_module.c    # Gestione moduli/import
â”œâ”€â”€ type_check.c        # Controllo tipi compile-time
â””â”€â”€ type_check.h        # API controllo tipi
```

### Controllo dei Tipi

Il compilatore include un sistema unificato di controllo dei tipi che:

1. **Valida i tipi a compile-time** - Cattura errori di tipo prima dell'esecuzione
2. **Supporta codice dinamico** - Codice non tipizzato trattato come `any` (sempre valido)
3. **Fornisce hint di ottimizzazione** - Identifica variabili che possono essere unboxed

**Flag Controllo Tipi:**

| Flag | Descrizione |
|------|-------------|
| (default) | Controllo tipi abilitato |
| `--check` | Solo controllo tipi, non compila |
| `--no-type-check` | Disabilita controllo tipi |
| `--strict-types` | Avvisa su tipi `any` impliciti |

**Implementazione Controllo Tipi:**

```c
// type_check.h - Strutture chiave
typedef struct TypeCheckContext {
    const char *filename;
    int error_count;
    int warning_count;
    UnboxableVar *unboxable_vars;  // Hint ottimizzazione
    // ... type environment, definizioni, ecc.
} TypeCheckContext;

// Entry point principale
int type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);
```

### Generazione del Codice

La fase di codegen traduce i nodi AST in codice C:

**Mapping Espressioni:**
```
Hemlock                 â†’  C Generato
----------------------------------------
let x = 42;            â†’  HmlValue x = hml_val_i32(42);
x + y                  â†’  hml_add(x, y)
arr[i]                 â†’  hml_array_get(arr, i)
obj.field              â†’  hml_object_get_field(obj, "field")
fn(a, b) { ... }       â†’  Closure con cattura environment
```

**Integrazione Runtime:**

Il codice C generato linka contro `libhemlock_runtime.a` che fornisce:
- Tipo union taggata `HmlValue`
- Gestione memoria (reference counting)
- Funzioni integrate (print, typeof, ecc.)
- Primitive di concorrenza (task, canali)
- Supporto FFI

### Ottimizzazione Unboxing

Il controllo tipi identifica variabili che possono usare tipi C nativi invece di `HmlValue` boxed:

**Pattern Unboxable:**
- Contatori di loop con tipo intero noto
- Variabili accumulatore nei loop
- Variabili con annotazioni di tipo esplicite (i32, i64, f64, bool)

```hemlock
// Il contatore loop 'i' puÃ² essere unboxed a int32_t nativo
for (let i: i32 = 0; i < 1000000; i = i + 1) {
    somma = somma + i;
}
```

---

## Design Modulare dell'Interprete

L'interprete Ã¨ diviso in moduli focalizzati per manutenibilitÃ  e scalabilitÃ .

### ResponsabilitÃ  dei Moduli

#### 1. Environment (`environment.c`) - 121 righe

**Scopo:** Scoping delle variabili e risoluzione dei nomi

**Funzioni chiave:**
- `env_create()` - Crea nuovo environment con parent opzionale
- `env_define()` - Definisce nuova variabile nello scope corrente
- `env_get()` - Cerca variabile nello scope corrente o parent
- `env_set()` - Aggiorna valore variabile esistente
- `env_free()` - Libera environment e tutte le variabili

**Design:**
- Scope collegati (ogni environment ha puntatore al parent)
- HashMap per lookup veloce delle variabili
- Supporta scoping lessicale per le closure

#### 2. Values (`values.c`) - 394 righe

**Scopo:** Costruttori di valori e gestione strutture dati

**Funzioni chiave:**
- `value_create_*()` - Costruttori per ogni tipo di valore
- `value_copy()` - Logica di copia deep/shallow
- `value_free()` - Pulizia e deallocazione memoria
- `value_to_string()` - Rappresentazione stringa per stampa

**Strutture dati:**
- Oggetti (array campi dinamici)
- Array (ridimensionamento dinamico)
- Buffer (ptr + length + capacity)
- Closure (funzione + environment catturato)
- Task e Channel (primitive di concorrenza)

#### 3. Types (`types.c`) - 440 righe

**Scopo:** Sistema tipi, conversioni e duck typing

**Funzioni chiave:**
- `type_check()` - Validazione tipi runtime
- `type_convert()` - Conversioni/promozioni implicite
- `duck_type_check()` - Controllo tipi strutturale per oggetti
- `type_name()` - Ottiene nome tipo stampabile

**Caratteristiche:**
- Gerarchia promozione tipi (i8 â†’ i16 â†’ i32 â†’ i64 â†’ f32 â†’ f64, con i64/u64 + f32 â†’ f64)
- Controllo intervallo per tipi numerici
- Duck typing per definizioni tipo oggetto
- Default campi opzionali

#### 4. Builtins (`builtins.c`) - 955 righe

**Scopo:** Funzioni integrate e registrazione globale

**Funzioni chiave:**
- `register_builtins()` - Registra tutte le funzioni e costanti integrate
- Implementazioni funzioni integrate (print, typeof, alloc, free, ecc.)
- Funzioni gestione segnali
- Esecuzione comandi (exec)

**Categorie di builtin:**
- I/O: print, open, read_file, write_file
- Memoria: alloc, free, memset, memcpy, realloc
- Tipi: typeof, assert
- Concorrenza: spawn, join, detach, channel
- Sistema: exec, signal, raise, panic
- FFI: dlopen, dlsym, dlcall, dlclose

#### 5. I/O (`io.c`) - 449 righe

**Scopo:** I/O su file e serializzazione JSON

**Funzioni chiave:**
- Metodi oggetto file (read, write, seek, tell, close)
- Serializzazione/deserializzazione JSON
- Rilevamento riferimenti circolari

**Caratteristiche:**
- Oggetto file con proprietÃ  (path, mode, closed)
- I/O testo consapevole UTF-8
- Supporto I/O binario
- Round-tripping JSON per oggetti e array

#### 6. FFI (`ffi.c`) - Foreign Function Interface

**Scopo:** Chiamare funzioni C da librerie condivise

**Funzioni chiave:**
- `dlopen()` - Carica libreria condivisa
- `dlsym()` - Ottiene puntatore funzione per nome
- `dlcall()` - Chiama funzione C con conversione tipi
- `dlclose()` - Scarica libreria

**Caratteristiche:**
- Integrazione con libffi per chiamate funzione dinamiche
- Conversione tipi automatica (Hemlock â†” tipi C)
- Supporto per tutti i tipi primitivi
- Supporto puntatori e buffer

#### 7. Runtime (`runtime.c`) - 865 righe

**Scopo:** Valutazione espressioni ed esecuzione istruzioni

**Funzioni chiave:**
- `eval_expr()` - Valuta espressioni (ricorsivo)
- `eval_stmt()` - Esegue istruzioni
- Gestione flusso di controllo (if, while, for, switch, ecc.)
- Gestione eccezioni (try/catch/finally/throw)

**Caratteristiche:**
- Valutazione espressioni ricorsiva
- Valutazione booleana cortocircuito
- Rilevamento chiamate metodo e binding `self`
- Propagazione eccezioni
- Gestione break/continue/return

### Benefici del Design Modulare

**1. Separazione delle ResponsabilitÃ **
- Ogni modulo ha una chiara responsabilitÃ 
- Facile trovare dove sono implementate le funzionalitÃ 
- Riduce il carico cognitivo quando si fanno modifiche

**2. Build Incrementali PiÃ¹ Veloci**
- Solo i moduli modificati necessitano ricompilazione
- Compilazione parallela possibile
- Tempi di iterazione piÃ¹ brevi durante lo sviluppo

**3. Testing e Debug PiÃ¹ Facili**
- I moduli possono essere testati in isolamento
- I bug sono localizzati in sottosistemi specifici
- Implementazioni mock possibili per testing

**4. ScalabilitÃ **
- Nuove funzionalitÃ  possono essere aggiunte ai moduli appropriati
- I moduli possono essere refactorizzati indipendentemente
- La dimensione del codice per file rimane gestibile

**5. Organizzazione del Codice**
- Raggruppamento logico di funzionalitÃ  correlate
- Grafo delle dipendenze chiaro
- Onboarding piÃ¹ facile per nuovi contributori

---

## Architettura del Runtime

### Rappresentazione dei Valori

Tutti i valori in Hemlock sono rappresentati dalla struct `Value` usando una union taggata:

```c
typedef struct Value {
    ValueType type;  // Tag tipo runtime
    union {
        int32_t i32_value;
        int64_t i64_value;
        uint8_t u8_value;
        uint32_t u32_value;
        uint64_t u64_value;
        float f32_value;
        double f64_value;
        bool bool_value;
        char *string_value;
        uint32_t rune_value;
        void *ptr_value;
        Buffer *buffer_value;
        Array *array_value;
        Object *object_value;
        Function *function_value;
        File *file_value;
        Task *task_value;
        Channel *channel_value;
    };
} Value;
```

**Decisioni di design:**
- **Union taggata** per type safety mantenendo flessibilitÃ 
- **Tag tipo runtime** abilitano tipizzazione dinamica con controllo tipi
- **Storage valore diretto** per primitivi (no boxing)
- **Storage puntatore** per tipi allocati nell'heap (stringhe, oggetti, array)

### Esempi Layout Memoria

**Intero (i32):**
```
Value {
    type: TYPE_I32,
    i32_value: 42
}
```
- Dimensione totale: ~16 byte (8-byte tag + 8-byte union)
- Allocato sullo stack
- Nessuna allocazione heap necessaria

**Stringa:**
```
Value {
    type: TYPE_STRING,
    string_value: 0x7f8a4c000000  // Puntatore a heap
}

Heap: "ciao\0" (6 byte, null-terminated UTF-8)
```
- Value Ã¨ 16 byte sullo stack
- Dati stringa allocati nell'heap
- Deve essere liberata manualmente

**Oggetto:**
```
Value {
    type: TYPE_OBJECT,
    object_value: 0x7f8a4c001000  // Puntatore a heap
}

Heap: Object {
    type_name: "Persona",
    fields: [
        { name: "nome", value: Value{TYPE_STRING, "Alice"} },
        { name: "eta", value: Value{TYPE_I32, 30} }
    ],
    field_count: 2,
    capacity: 4
}
```
- Struttura oggetto nell'heap
- Campi memorizzati in array dinamico
- Valori campi sono struct Value embedded

### Implementazione Environment

Le variabili sono memorizzate in catene di environment:

```c
typedef struct Environment {
    HashMap *bindings;           // nome â†’ Value
    struct Environment *parent;  // Scope parent lessicale
} Environment;
```

**Esempio catena scope:**
```
Scope Globale: { print: <builtin>, args: <array> }
    â†‘
Scope Funzione: { x: 10, y: 20 }
    â†‘
Scope Blocco: { i: 0 }
```

**Algoritmo di lookup:**
1. Controlla hashmap dell'environment corrente
2. Se non trovato, controlla environment parent
3. Ripeti finchÃ© trovato o raggiunto scope globale
4. Errore se non trovato in nessuno scope

---

## Implementazione del Sistema di Tipi

### Strategia Controllo Tipi

Hemlock usa **controllo tipi runtime** con **annotazioni tipo opzionali**:

```hemlock
let x = 42;           // Nessun controllo tipo, inferisce i32
let y: u8 = 255;      // Controllo runtime: valore deve stare in u8
let z: i32 = x + y;   // Controllo runtime + promozione tipo
```

**Flusso implementazione:**
1. **Inferenza letterali** - Lexer/parser determinano tipo iniziale dal letterale
2. **Controllo annotazione tipo** - Se annotazione presente, valida all'assegnazione
3. **Promozione** - Operazioni binarie promuovono a tipo comune
4. **Conversione** - Conversioni esplicite avvengono su richiesta

### Implementazione Promozione Tipi

La promozione tipi segue una gerarchia fissa con preservazione precisione:

```c
// Logica promozione semplificata
ValueType promote_types(ValueType a, ValueType b) {
    // f64 vince sempre
    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;

    // f32 con i64/u64 promuove a f64 (preservazione precisione)
    if (a == TYPE_F32 || b == TYPE_F32) {
        ValueType other = (a == TYPE_F32) ? b : a;
        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;
        return TYPE_F32;
    }

    // Tipi interi piÃ¹ grandi vincono
    int rank_a = get_type_rank(a);
    int rank_b = get_type_rank(b);
    return (rank_a > rank_b) ? a : b;
}
```

**Rank dei tipi:**
- i8: 0
- u8: 1
- i16: 2
- u16: 3
- i32: 4
- u32: 5
- i64: 6
- u64: 7
- f32: 8
- f64: 9

### Implementazione Duck Typing

Il controllo tipo degli oggetti usa confronto strutturale:

```c
bool duck_type_check(Object *obj, TypeDef *type_def) {
    // Controlla tutti i campi richiesti
    for (each field in type_def) {
        if (!object_has_field(obj, field.name)) {
            return false;  // Campo mancante
        }

        Value *field_value = object_get_field(obj, field.name);
        if (!type_matches(field_value, field.type)) {
            return false;  // Tipo sbagliato
        }
    }

    return true;  // Tutti i campi richiesti presenti e tipo corretto
}
```

**Il duck typing permette:**
- Campi extra negli oggetti (ignorati)
- Tipizzazione sub-strutturale (oggetto puÃ² avere piÃ¹ del richiesto)
- Assegnazione nome tipo dopo validazione

---

## Gestione della Memoria

### Strategia di Allocazione

Hemlock usa **gestione manuale della memoria** con due primitive di allocazione:

**1. Puntatori grezzi (`ptr`):**
```c
void *alloc(size_t bytes) {
    void *ptr = malloc(bytes);
    if (!ptr) {
        fprintf(stderr, "Memoria esaurita\n");
        exit(1);
    }
    return ptr;
}
```
- malloc/free diretti
- Nessun tracking
- ResponsabilitÃ  utente liberare

**2. Buffer (`buffer`):**
```c
typedef struct Buffer {
    void *data;
    size_t length;
    size_t capacity;
} Buffer;

Buffer *create_buffer(size_t size) {
    Buffer *buf = malloc(sizeof(Buffer));
    buf->data = malloc(size);
    buf->length = size;
    buf->capacity = size;
    return buf;
}
```
- Traccia dimensione e capacitÃ 
- Controllo limiti sull'accesso
- Richiede comunque free manuale

### Tipi Allocati nell'Heap

**Stringhe:**
- Array byte UTF-8 nell'heap
- Null-terminated per interop C
- Mutabili (possono modificare in loco)
- Refcounted (auto-liberate quando scope esce)

**Oggetti:**
- Array campi dinamico
- Nomi e valori campi nell'heap
- Refcounted (auto-liberati quando scope esce)
- Riferimenti circolari possibili (gestiti con tracking visited-set)

**Array:**
- Crescita capacitÃ  dinamica (raddoppio)
- Elementi sono struct Value embedded
- Riallocazione automatica alla crescita
- Refcounted (auto-liberati quando scope esce)

**Closure:**
- Cattura environment per riferimento
- Environment allocato nell'heap
- Environment closure liberati propriamente quando non piÃ¹ referenziati

---

## Modello di Concorrenza

### Architettura Threading

Hemlock usa **threading 1:1** con POSIX threads (pthreads):

```
Task Utente          Thread OS          Core CPU
---------            ---------          --------
spawn(f1) ------->   pthread_create --> Core 0
spawn(f2) ------->   pthread_create --> Core 1
spawn(f3) ------->   pthread_create --> Core 2
```

**Caratteristiche chiave:**
- Ogni `spawn()` crea un nuovo pthread
- Kernel schedula thread sui core
- Vera esecuzione parallela (nessun GIL)
- Multitasking preemptive

### Implementazione Task

```c
typedef struct Task {
    pthread_t thread;        // Handle thread OS
    Value result;            // Valore ritorno
    char *error;             // Messaggio eccezione (se lanciata)
    pthread_mutex_t lock;    // Protegge lo stato
    TaskState state;         // RUNNING, FINISHED, ERROR
} Task;
```

**Ciclo vita task:**
1. `spawn(func, args)` â†’ Crea Task, avvia pthread
2. Thread esegue funzione con argomenti
3. Al ritorno: Memorizza risultato, imposta stato a FINISHED
4. All'eccezione: Memorizza messaggio errore, imposta stato a ERROR
5. `join(task)` â†’ Attende thread, restituisce risultato o lancia eccezione

### Implementazione Channel

```c
typedef struct Channel {
    void **buffer;           // Buffer circolare di Value*
    size_t capacity;         // Elementi massimi bufferizzati
    size_t count;            // Elementi correnti nel buffer
    size_t read_index;       // Prossima posizione lettura
    size_t write_index;      // Prossima posizione scrittura
    bool closed;             // Flag canale chiuso
    pthread_mutex_t lock;    // Protegge buffer
    pthread_cond_t not_full; // Segnala quando spazio disponibile
    pthread_cond_t not_empty;// Segnala quando dati disponibili
} Channel;
```

**Operazione send:**
1. Lock mutex
2. Attendi se buffer pieno (cond_wait su not_full)
3. Scrivi valore a buffer[write_index]
4. Incrementa write_index (circolare)
5. Segnala not_empty
6. Unlock mutex

**Operazione receive:**
1. Lock mutex
2. Attendi se buffer vuoto (cond_wait su not_empty)
3. Leggi valore da buffer[read_index]
4. Incrementa read_index (circolare)
5. Segnala not_full
6. Unlock mutex

**Garanzie di sincronizzazione:**
- send/recv thread-safe (protetti da mutex)
- Semantica bloccante (produttore attende se pieno, consumatore attende se vuoto)
- Consegna ordinata (FIFO all'interno di un canale)

---

## Piani Futuri

### Completato: Backend Compilatore

Il backend compilatore (`hemlockc`) Ã¨ stato implementato con:
- Generazione codice C da AST
- Controllo tipi compile-time (abilitato di default)
- Libreria runtime (`libhemlock_runtime.a`)
- ParitÃ  completa con interprete (98% test pass rate)
- Framework ottimizzazione unboxing

### Focus Corrente: Miglioramenti Sistema Tipi

**Miglioramenti recenti:**
- Sistemi unificati controllo tipi e inferenza tipi
- Controllo tipi compile-time abilitato di default
- Flag `--check` per validazione solo tipi
- Contesto tipi passato a codegen per hint ottimizzazione

### Miglioramenti Futuri

**Potenziali aggiunte:**
- Generics/template
- Pattern matching
- Integrazione LSP per supporto IDE type-aware
- Ottimizzazioni unboxing piÃ¹ aggressive
- Escape analysis per allocazione stack

### Ottimizzazioni a Lungo Termine

**Possibili miglioramenti:**
- Inline caching per chiamate metodo
- Compilazione JIT per hot path
- Scheduler work-stealing per migliore concorrenza
- Ottimizzazione profile-guided

---

## Linee Guida Implementazione

### Aggiungere Nuove FunzionalitÃ 

Quando si implementano nuove funzionalitÃ , seguire queste linee guida:

**1. Scegliere il modulo giusto:**
- Nuovi tipi valore â†’ `values.c`
- Conversioni tipo â†’ `types.c`
- Funzioni integrate â†’ `builtins.c`
- Operazioni I/O â†’ `io.c`
- Flusso controllo â†’ `runtime.c`

**2. Aggiornare tutti i layer:**
- Aggiungere tipi nodo AST se necessario (`ast.h`, `ast.c`)
- Aggiungere token lexer se necessario (`lexer.c`)
- Aggiungere regole parser (`parser.c`)
- Implementare comportamento runtime (`runtime.c` o modulo appropriato)
- Aggiungere test (`tests/`)

**3. Mantenere consistenza:**
- Seguire stile codice esistente
- Usare convenzioni naming consistenti
- Documentare API pubblica negli header
- Mantenere messaggi errore chiari e consistenti

**4. Testare approfonditamente:**
- Aggiungere casi test prima di implementare
- Testare percorsi successo ed errore
- Testare casi limite
- Verificare nessun memory leak (valgrind)

### Considerazioni Prestazioni

**Colli di bottiglia attuali:**
- Lookup HashMap per accesso variabili
- Chiamate funzione ricorsive (no TCO)
- Concatenazione stringhe (alloca nuova stringa ogni volta)
- Overhead controllo tipi su ogni operazione

**OpportunitÃ  ottimizzazione:**
- Cache posizioni variabili (inline caching)
- Ottimizzazione tail call
- String builder per concatenazione
- Inferenza tipi per saltare controlli runtime

### Suggerimenti Debug

**Strumenti utili:**
- `valgrind` - Rilevamento memory leak
- `gdb` - Debug crash
- Flag `-g` - Simboli debug
- Debug con `printf` - Semplice ma efficace

**Problemi comuni:**
- Segfault â†’ Dereferenziazione puntatore null (controlla valori ritorno)
- Memory leak â†’ Chiamata free() mancante (controlla percorsi value_free)
- Errore tipo â†’ Controlla logica type_convert() e type_check()
- Crash nei thread â†’ Race condition (controlla uso mutex)

---

## Conclusione

L'implementazione di Hemlock priorizza:
- **ModularitÃ ** - Chiara separazione responsabilitÃ 
- **SemplicitÃ ** - Implementazione diretta
- **Esplicitezza** - Nessuna magia nascosta
- **ManutenibilitÃ ** - Facile da capire e modificare

L'attuale interprete tree-walking Ã¨ intenzionalmente semplice per facilitare lo sviluppo rapido di funzionalitÃ  e la sperimentazione. Il futuro backend compilatore migliorerÃ  le prestazioni mantenendo la stessa semantica.


--------------------------------------------------------------------------------
## Sintassi delle Firme
--------------------------------------------------------------------------------

# Design della Sintassi delle Firme

> Estensione del sistema di tipi di Hemlock con tipi funzione, modificatori nullable, alias di tipo, parametri const e firme di metodo.

**Stato:** Implementato (v1.7.0)
**Versione:** 1.0
**Autore:** Claude

---

## Panoramica

Questo documento propone cinque estensioni interconnesse del sistema di tipi che si basano sull'infrastruttura esistente di Hemlock:

1. **Annotazioni Tipo Funzione** - Tipi funzione di prima classe
2. **Modificatori Tipo Nullable** - Gestione esplicita del null (estende flag `nullable` esistente)
3. **Alias di Tipo** - Abbreviazioni di tipo con nome
4. **Parametri Const** - Contratti di immutabilitÃ 
5. **Firme di Metodo in Define** - Comportamento simile a interfacce

Queste funzionalitÃ  condividono la filosofia: **esplicito su implicito, opzionale ma applicato quando usato**.

---

## 1. Annotazioni Tipo Funzione

### Motivazione

Attualmente, non c'Ã¨ modo di esprimere la firma di una funzione come tipo:

```hemlock
// Attuale: callback non ha informazioni di tipo
fn map(arr: array, callback) { ... }

// Proposto: tipo funzione esplicito
fn map(arr: array, callback: fn(any, i32): any): array { ... }
```

### Sintassi

```hemlock
// Tipo funzione base
fn(i32, i32): i32

// Con nomi parametri (solo documentazione, non applicati)
fn(a: i32, b: i32): i32

// Nessun valore ritorno (void)
fn(string): void
fn(string)              // Abbreviazione: ometti `: void`

// Ritorno nullable
fn(i32): string?

// Parametri opzionali
fn(nome: string, eta?: i32): void

// Parametri rest
fn(...args: array): i32

// Nessun parametro
fn(): bool

// Ordine superiore: funzione che restituisce funzione
fn(i32): fn(i32): i32

// Tipo funzione async
async fn(i32): i32
```

### Esempi d'Uso

```hemlock
// Variabile con tipo funzione
let somma: fn(i32, i32): i32 = fn(a, b) { return a + b; };

// Parametro funzione
fn applica(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Tipo ritorno Ã¨ funzione
fn crea_sommatore(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Array di funzioni
let ops: array<fn(i32, i32): i32> = [somma, sottrai, moltiplica];

// Campo oggetto
define EventHandler {
    nome: string;
    callback: fn(Event): void;
}
```

### Modifiche AST

```c
// In enum TypeKind (include/ast.h)
typedef enum {
    // ... tipi esistenti ...
    TYPE_FUNCTION,      // NUOVO: Tipo funzione
} TypeKind;

// In struct Type (include/ast.h)
struct Type {
    TypeKind kind;
    // ... campi esistenti ...

    // Per TYPE_FUNCTION:
    struct Type **param_types;      // Tipi parametri
    char **param_names;             // Nomi parametri opzionali (docs)
    int *param_optional;            // Quali param sono opzionali
    int num_params;
    char *rest_param_name;          // Nome parametro rest o NULL
    struct Type *rest_param_type;   // Tipo parametro rest
    struct Type *return_type;       // Tipo ritorno (NULL = void)
    int is_async;                   // tipo fn async
};
```

### Parsing

I tipi funzione iniziano con `fn` (o `async fn`) seguito dalla lista parametri:

```
function_type := ["async"] "fn" "(" [param_type_list] ")" [":" type]
param_type_list := param_type ("," param_type)*
param_type := [identifier ":"] ["?"] type | "..." [identifier] [":" type]
```

**Disambiguazione:** Quando si parsa un tipo e si incontra `fn`:
- Se seguito da `(`, Ã¨ un tipo funzione
- Altrimenti, errore di sintassi (`fn` da solo non Ã¨ un tipo valido)

### CompatibilitÃ  Tipi

```hemlock
// Match esatto richiesto per tipi funzione
let f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // OK

// Controvarianza parametri (accettare tipi piÃ¹ ampi Ã¨ OK)
let g: fn(any): i32 = fn(x: i32): i32 { return x; };  // OK: i32 <: any

// Covarianza ritorno (restituire tipi piÃ¹ ristretti Ã¨ OK)
let h: fn(i32): any = fn(x: i32): i32 { return x; };  // OK: i32 <: any

// AritÃ  deve corrispondere
let bad: fn(i32): i32 = fn(a, b) { return a; };       // ERRORE: mismatch aritÃ 

// Parametri opzionali compatibili con richiesti
let opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // OK
```

---

## 2. Modificatori Tipo Nullable

### Motivazione

Il suffisso `?` rende esplicita l'accettazione del null nelle firme:

```hemlock
// Attuale: non chiaro se null Ã¨ valido
fn trova(arr: array, val: any): i32 { ... }

// Proposto: ritorno nullable esplicito
fn trova(arr: array, val: any): i32? { ... }
```

### Sintassi

```hemlock
// Tipi nullable con suffisso ?
string?           // stringa o null
i32?              // i32 o null
Utente?           // Utente o null
array<i32>?       // array o null
fn(i32): i32?     // funzione che restituisce i32 o null

// Composizione con tipi funzione
fn(string?): i32          // Accetta stringa o null
fn(string): i32?          // Restituisce i32 o null
fn(string?): i32?         // Entrambi nullable

// In define
define Risultato {
    valore: any?;
    errore: string?;
}
```

### Note Implementazione

**GiÃ  esiste:** Il flag `Type.nullable` Ã¨ giÃ  nell'AST. Questa funzionalitÃ  necessita principalmente:
1. Supporto parser per suffisso `?` su qualsiasi tipo (verificare/estendere)
2. Composizione corretta con tipi funzione
3. Applicazione runtime

### CompatibilitÃ  Tipi

```hemlock
// Non-nullable assegnabile a nullable
let x: i32? = 42;           // OK
let y: i32? = null;         // OK

// Nullable NON assegnabile a non-nullable
let z: i32 = x;             // ERRORE: x potrebbe essere null

// Null coalescing per unwrap
let z: i32 = x ?? 0;        // OK: ?? fornisce default

// Optional chaining restituisce nullable
let nome: string? = utente?.nome;
```

---

## 3. Alias di Tipo

### Motivazione

Tipi complessi beneficiano di abbreviazioni con nome:

```hemlock
// Attuale: tipi composti ripetitivi
fn elabora(entita: HaNome & HaId & HaTimestamp) { ... }
fn valida(entita: HaNome & HaId & HaTimestamp) { ... }

// Proposto: alias con nome
type Entita = HaNome & HaId & HaTimestamp;
fn elabora(entita: Entita) { ... }
fn valida(entita: Entita) { ... }
```

### Sintassi

```hemlock
// Alias base
type Intero = i32;
type Testo = string;

// Alias tipo composto
type Entita = HaNome & HaId;
type Auditabile = HaCreatoIl & HaModificatoIl & HaCreadaDa;

// Alias tipo funzione
type Callback = fn(Evento): void;
type Predicato = fn(any): bool;
type Reducer = fn(acc: any, val: any): any;
type TaskAsync = async fn(): any;

// Alias nullable
type StringaOpzionale = string?;

// Alias generico (se supportiamo alias tipo generici)
type Coppia<T> = { primo: T, secondo: T };
type Risultato<T, E> = { valore: T?, errore: E? };

// Alias tipo array
type ArrayInt = array<i32>;
type Matrice = array<array<f64>>;
```

### Scope e VisibilitÃ 

```hemlock
// Scope modulo di default
type Callback = fn(Evento): void;

// Esportabile
export type Handler = fn(Request): Response;

// In altro file
import { Handler } from "./handlers.hml";
fn registra(h: Handler) { ... }
```

### Modifiche AST

```c
// Nuovo tipo istruzione
typedef enum {
    // ... istruzioni esistenti ...
    STMT_TYPE_ALIAS,    // NUOVO
} StmtKind;

// In union Stmt
struct {
    char *name;                 // Nome alias
    char **type_params;         // Param generici: <T, U>
    int num_type_params;
    Type *aliased_type;         // Il tipo effettivo
} type_alias;
```

### Parsing

```
type_alias := "type" identifier ["<" type_params ">"] "=" type ";"
```

**Nota:** `type` Ã¨ una nuova parola chiave. Verifica conflitti con identificatori esistenti.

### Risoluzione

Gli alias di tipo sono risolti a:
- **Tempo di parse:** Alias registrato in type environment
- **Tempo di controllo:** Alias espanso a tipo sottostante
- **Runtime:** Alias Ã¨ trasparente (stesso del tipo sottostante)

```hemlock
type MioInt = i32;
let x: MioInt = 42;
typeof(x);           // "i32" (non "MioInt")
```

---

## 4. Parametri Const

### Motivazione

Segnala l'intento di immutabilitÃ  nelle firme di funzione:

```hemlock
// Attuale: non chiaro se array sarÃ  modificato
fn stampa_tutti(elementi: array) { ... }

// Proposto: contratto di immutabilitÃ  esplicito
fn stampa_tutti(const elementi: array) { ... }
```

### Sintassi

```hemlock
// Parametro const
fn elabora(const dati: buffer) {
    // dati[0] = 0;        // ERRORE: non puÃ² mutare const
    let x = dati[0];       // OK: lettura permessa
    return x;
}

// PiÃ¹ parametri const
fn confronta(const a: array, const b: array): bool { ... }

// Const e mutabile misti
fn aggiorna(const sorgente: array, destinazione: array) {
    for (elem in sorgente) {
        destinazione.push(elem);   // OK: destinazione Ã¨ mutabile
    }
}

// Const con inferenza tipo
fn log(const msg) {
    print(msg);
}

// Const in tipi funzione
type Lettore = fn(const buffer): i32;
```

### Cosa Previene Const

```hemlock
fn cattivo(const arr: array) {
    arr.push(1);         // ERRORE: metodo mutante
    arr.pop();           // ERRORE: metodo mutante
    arr[0] = 5;          // ERRORE: assegnazione indice
    arr.clear();         // ERRORE: metodo mutante
}

fn buono(const arr: array) {
    let x = arr[0];      // OK: lettura
    let lun = len(arr);  // OK: controllo lunghezza
    let copia = arr.slice(0, 10);  // OK: crea nuovo array
    for (elem in arr) {  // OK: iterazione
        print(elem);
    }
}
```

### Metodi Mutanti vs Non-Mutanti

| Tipo | Mutanti (bloccati da const) | Non-Mutanti (permessi) |
|------|----------------------------|------------------------|
| array | push, pop, shift, unshift, insert, remove, clear, reverse (in-place) | slice, concat, map, filter, find, contains, first, last, join |
| string | assegnazione indice (`s[0] = 'x'`) | tutti i metodi (restituiscono nuove stringhe) |
| buffer | assegnazione indice, memset, memcpy (verso) | lettura indice, slice |
| object | assegnazione campo | lettura campo |

### Modifiche AST

```c
// In espressione funzione (include/ast.h)
struct {
    // ... campi esistenti ...
    int *param_is_const;    // NUOVO: 1 se const, 0 altrimenti
} function;

// In struct Type per tipi funzione
struct Type {
    // ... campi esistenti ...
    int *param_is_const;    // Per TYPE_FUNCTION
};
```

### Applicazione

**Interprete:**
- Traccia const-ness nei binding variabili
- Verifica prima delle operazioni di mutazione
- Errore runtime su violazione const

**Compilatore:**
- Emetti variabili C const-qualified dove benefico
- Analisi statica per violazioni const
- Warning/errore a compile-time

---

## 5. Firme di Metodo in Define

### Motivazione

Permette ai blocchi `define` di specificare metodi attesi, non solo campi dati:

```hemlock
// Attuale: solo campi dati
define Utente {
    nome: string;
    eta: i32;
}

// Proposto: firme metodo
define Comparabile {
    fn confronta(altro: Self): i32;
}

define Serializzabile {
    fn serializza(): string;
    fn deserializza(dati: string): Self;  // Metodo statico
}
```

### Sintassi

```hemlock
// Firma metodo (nessun corpo)
define Hashable {
    fn hash(): i32;
}

// Metodi multipli
define Collezione {
    fn dimensione(): i32;
    fn e_vuota(): bool;
    fn contiene(elemento: any): bool;
}

// Campi e metodi misti
define Entita {
    id: i32;
    nome: string;
    fn valida(): bool;
    fn serializza(): string;
}

// Usando tipo Self
define Clonabile {
    fn clona(): Self;
}

define Comparabile {
    fn confronta(altro: Self): i32;
    fn uguale(altro: Self): bool;
}

// Metodi opzionali
define Stampabile {
    fn to_string(): string;
    fn debug_string?(): string;  // Metodo opzionale (puÃ² essere assente)
}

// Metodi con implementazione default
define Ordinato {
    fn confronta(altro: Self): i32;  // Richiesto

    // Implementazioni default (ereditate se non sovrascritte)
    fn minore_di(altro: Self): bool {
        return self.confronta(altro) < 0;
    }
    fn maggiore_di(altro: Self): bool {
        return self.confronta(altro) > 0;
    }
    fn uguale(altro: Self): bool {
        return self.confronta(altro) == 0;
    }
}
```

### Il Tipo `Self`

`Self` si riferisce al tipo concreto che implementa l'interfaccia:

```hemlock
define Sommabile {
    fn somma(altro: Self): Self;
}

// Quando usato:
let a: Sommabile = {
    valore: 10,
    somma: fn(altro) {
        return { valore: self.valore + altro.valore, somma: self.somma };
    }
};
```

### Tipizzazione Strutturale (Duck Typing)

Le firme metodo usano lo stesso duck typing dei campi:

```hemlock
define Stringificabile {
    fn to_string(): string;
}

// Qualsiasi oggetto con metodo to_string() soddisfa Stringificabile
let x: Stringificabile = {
    nome: "test",
    to_string: fn() { return self.nome; }
};

// Tipi composti con metodi
define Nominato { nome: string; }
define Stampabile { fn to_string(): string; }

type NominatoStampabile = Nominato & Stampabile;

let y: NominatoStampabile = {
    nome: "Alice",
    to_string: fn() { return "Nome: " + self.nome; }
};
```

### Modifiche AST

```c
// Estendi define_object in union Stmt
struct {
    char *name;
    char **type_params;
    int num_type_params;

    // Campi (esistenti)
    char **field_names;
    Type **field_types;
    int *field_optional;
    Expr **field_defaults;
    int num_fields;

    // Metodi (NUOVO)
    char **method_names;
    Type **method_types;        // TYPE_FUNCTION
    int *method_optional;       // Metodi opzionali (fn nome?(): tipo)
    Expr **method_defaults;     // Implementazioni default (NULL se solo firma)
    int num_methods;
} define_object;
```

### Controllo Tipi

Quando si controlla `valore: TipoInterfaccia`:
1. Verifica tutti i campi richiesti esistano con tipi compatibili
2. Verifica tutti i metodi richiesti esistano con firme compatibili
3. Campi/metodi opzionali possono essere assenti

```hemlock
define Ordinabile {
    fn confronta(altro: Self): i32;
}

// Valido: ha metodo confronta
let valido: Ordinabile = {
    valore: 10,
    confronta: fn(altro) { return self.valore - altro.valore; }
};

// Non valido: manca confronta
let invalido: Ordinabile = { valore: 10 };  // ERRORE: metodo 'confronta' mancante

// Non valido: firma sbagliata
let sbagliato: Ordinabile = {
    confronta: fn() { return 0; }  // ERRORE: atteso (Self): i32
};
```

---

## Esempi di Interazione

### Combinare Tutte le FunzionalitÃ 

```hemlock
// Alias tipo per tipo funzione complesso
type CallbackEvento = fn(evento: Evento, contesto: Contesto?): bool;

// Alias tipo per interfaccia composta
type Entita = HaId & HaNome & Serializzabile;

// Define con firme metodo
define Repository<T> {
    fn trova(id: i32): T?;
    fn salva(const entita: T): bool;
    fn elimina(id: i32): bool;
    fn trova_tutti(predicato: fn(T): bool): array<T>;
}

// Usare tutto insieme
fn crea_repo_utente(): Repository<Utente> {
    let utenti: array<Utente> = [];

    return {
        trova: fn(id) {
            for (u in utenti) {
                if (u.id == id) { return u; }
            }
            return null;
        },
        salva: fn(const entita) {
            utenti.push(entita);
            return true;
        },
        elimina: fn(id) {
            // ...
            return true;
        },
        trova_tutti: fn(predicato) {
            return utenti.filter(predicato);
        }
    };
}
```

### Callback con Tipi Espliciti

```hemlock
type ClickHandler = fn(evento: MouseEvent): void;
type KeyHandler = fn(evento: KeyEvent, modificatori: i32): bool;

define Widget {
    x: i32;
    y: i32;
    on_click: ClickHandler?;
    on_key: KeyHandler?;
}

fn crea_pulsante(etichetta: string, handler: ClickHandler): Widget {
    return {
        x: 0, y: 0,
        on_click: handler,
        on_key: null
    };
}
```

### Tipi Funzione Nullable

```hemlock
// Callback opzionale
fn fetch(url: string, on_completo: fn(Response): void?): void {
    let risposta = http_get(url);
    if (on_completo != null) {
        on_completo(risposta);
    }
}

// Ritorno nullable da tipo funzione
type Parser = fn(input: string): AST?;

fn prova_parse(parsers: array<Parser>, input: string): AST? {
    for (p in parsers) {
        let risultato = p(input);
        if (risultato != null) {
            return risultato;
        }
    }
    return null;
}
```

---

## Roadmap Implementazione

### Fase 1: Infrastruttura Core
1. Aggiungere `TYPE_FUNCTION` a enum TypeKind
2. Estendere struct Type con campi tipo funzione
3. Aggiungere `CHECKED_FUNCTION` al type checker del compilatore
4. Aggiungere supporto tipo `Self` (TYPE_SELF)

### Fase 2: Parsing
1. Implementare `parse_function_type()` nel parser
2. Gestire `fn(...)` in posizione tipo
3. Aggiungere parola chiave `type` e parsing `STMT_TYPE_ALIAS`
4. Aggiungere parsing modificatore parametro `const`
5. Estendere parsing define per firme metodo

### Fase 3: Controllo Tipi
1. Regole compatibilitÃ  tipi funzione
2. Risoluzione ed espansione alias tipo
3. Controllo mutazione parametri const
4. Validazione firme metodo in tipi define
5. Risoluzione tipo Self

### Fase 4: Runtime
1. Validazione tipo funzione ai call site
2. Rilevamento violazione const
3. Trasparenza alias tipo

### Fase 5: Test ParitÃ 
1. Test annotazione tipo funzione
2. Test composizione nullable
3. Test alias tipo
4. Test parametri const
5. Test firme metodo

---

## Decisioni di Design

### 1. Alias Tipo Generici: **SÃŒ**

Gli alias tipo supportano parametri generici:

```hemlock
// Alias tipo generici
type Coppia<T> = { primo: T, secondo: T };
type Risultato<T, E> = { valore: T?, errore: E? };
type Mapper<T, U> = fn(T): U;
type AsyncResult<T> = async fn(): T?;

// Uso
let coord: Coppia<f64> = { primo: 3.14, secondo: 2.71 };
let risultato: Risultato<Utente, string> = { valore: utente, errore: null };
let trasforma: Mapper<i32, string> = fn(n) { return n.to_string(); };
```

### 2. Propagazione Const: **PROFONDA**

I parametri const sono completamente immutabili - nessuna mutazione attraverso nessun percorso:

```hemlock
fn elabora(const arr: array<object>) {
    arr.push({});        // ERRORE: non puÃ² mutare array const
    arr[0] = {};         // ERRORE: non puÃ² mutare array const
    arr[0].x = 5;        // ERRORE: non puÃ² mutare attraverso const (PROFONDO)

    let x = arr[0].x;    // OK: lettura Ã¨ permessa
    let copia = arr[0];  // OK: crea una copia
    copia.x = 5;         // OK: copia non Ã¨ const
}

fn annidato(const obj: object) {
    obj.utente.nome = "x"; // ERRORE: const profondo previene mutazione annidata
    obj.elementi[0] = 1;   // ERRORE: const profondo previene mutazione annidata
}
```

**Motivazione:** Const profondo fornisce garanzie piÃ¹ forti ed Ã¨ piÃ¹ utile per
assicurare l'integritÃ  dei dati. Se devi mutare dati annidati, fai prima una copia.

### 3. Self in Alias Tipo Standalone: **NO**

`Self` Ã¨ valido solo dentro blocchi `define` dove ha significato chiaro:

```hemlock
// Valido: Self si riferisce al tipo definito
define Comparabile {
    fn confronta(altro: Self): i32;
}

// Non valido: Self non ha significato qui
type Clonatore = fn(Self): Self;  // ERRORE: Self fuori contesto define

// Invece, usa generici:
type Clonatore<T> = fn(T): T;
```

### 4. Implementazioni Metodo Default: **SÃŒ (Solo Semplici)**

Permetti implementazioni default per metodi semplici/utility:

```hemlock
define Comparabile {
    // Richiesto: deve essere implementato
    fn confronta(altro: Self): i32;

    // Implementazioni default (metodi convenience semplici)
    fn uguale(altro: Self): bool {
        return self.confronta(altro) == 0;
    }
    fn minore_di(altro: Self): bool {
        return self.confronta(altro) < 0;
    }
    fn maggiore_di(altro: Self): bool {
        return self.confronta(altro) > 0;
    }
}

define Stampabile {
    fn to_string(): string;

    // Default: delega a metodo richiesto
    fn stampa() {
        print(self.to_string());
    }
    fn stampa_ln() {
        print(self.to_string() + "\n");
    }
}

// L'oggetto deve solo implementare i metodi richiesti
let elemento: Comparabile = {
    valore: 42,
    confronta: fn(altro) { return self.valore - altro.valore; }
    // uguale, minore_di, maggiore_di sono ereditati dai default
};

elemento.minore_di({ valore: 50, confronta: elemento.confronta });  // true
```

**Linee guida per i default:**
- Mantienili semplici (1-3 righe)
- Dovrebbero delegare a metodi richiesti
- Nessuna logica complessa o effetti collaterali
- Solo primitive e composizioni dirette

### 5. Varianza: **INFERITA (Nessuna Annotazione Esplicita)**

La varianza Ã¨ inferita da come sono usati i parametri tipo:

```hemlock
// La varianza Ã¨ automatica in base alla posizione
type Produttore<T> = fn(): T;           // T in ritorno = covariante
type Consumatore<T> = fn(T): void;      // T in parametro = controvariante
type Trasformatore<T> = fn(T): T;       // T in entrambi = invariante

// Esempio: Cane <: Animale (Cane Ã¨ sottotipo di Animale)
let produttore_cane: Produttore<Cane> = fn() { return nuovo_cane(); };
let produttore_animale: Produttore<Animale> = produttore_cane;  // OK: covariante

let consumatore_animale: Consumatore<Animale> = fn(a) { print(a); };
let consumatore_cane: Consumatore<Cane> = consumatore_animale;  // OK: controvariante
```

**PerchÃ© inferire?**
- Meno boilerplate (`<out T>` / `<in T>` aggiunge rumore)
- Segue "esplicito su implicito" - la posizione Ãˆ esplicita
- Corrisponde a come la maggior parte dei linguaggi gestisce la varianza dei tipi funzione
- Gli errori sono chiari quando le regole di varianza sono violate

---

## Appendice: Modifiche Grammatica

```ebnf
(* Tipi *)
type := simple_type | compound_type | function_type
simple_type := base_type ["?"] | identifier ["<" type_args ">"] ["?"]
compound_type := simple_type ("&" simple_type)+
function_type := ["async"] "fn" "(" [param_types] ")" [":" type]

base_type := "i8" | "i16" | "i32" | "i64"
           | "u8" | "u16" | "u32" | "u64"
           | "f32" | "f64" | "bool" | "string" | "rune"
           | "ptr" | "buffer" | "void" | "null"
           | "array" ["<" type ">"]
           | "object"
           | "Self"

param_types := param_type ("," param_type)*
param_type := ["const"] [identifier ":"] ["?"] type
            | "..." [identifier] [":" type]

type_args := type ("," type)*

(* Istruzioni *)
type_alias := "type" identifier ["<" type_params ">"] "=" type ";"

define_stmt := "define" identifier ["<" type_params ">"] "{" define_members "}"
define_members := (field_def | method_def)*
field_def := identifier (":" type ["=" expr] | "?:" (type | expr)) ";"?
method_def := "fn" identifier ["?"] "(" [param_types] ")" [":" type] (block | ";")
            (* "?" marca metodo opzionale, block fornisce implementazione default *)

(* Parametri *)
param := ["const"] ["ref"] identifier [":" type] ["?:" expr]
       | "..." identifier [":" type]
```



################################################################################
# CONTRIBUIRE
################################################################################

--------------------------------------------------------------------------------
## Linee Guida
--------------------------------------------------------------------------------

# Contributing to Hemlock

Thank you for your interest in contributing to Hemlock! This guide will help you understand how to contribute effectively while maintaining the language's design philosophy and code quality.

---

## Table of Contents

- [Before You Start](#before-you-start)
- [Contribution Workflow](#contribution-workflow)
- [Code Style Guidelines](#code-style-guidelines)
- [What to Contribute](#what-to-contribute)
- [What NOT to Contribute](#what-not-to-contribute)
- [Common Patterns](#common-patterns)
- [Adding New Features](#adding-new-features)
- [Code Review Process](#code-review-process)

---

## Before You Start

### Required Reading

Before contributing, please read these documents in order:

1. **`/home/user/hemlock/docs/design/philosophy.md`** - Understand Hemlock's core principles
2. **`/home/user/hemlock/docs/design/implementation.md`** - Learn the codebase structure
3. **`/home/user/hemlock/docs/contributing/testing.md`** - Understand testing requirements
4. **This document** - Learn contribution guidelines

### Prerequisites

**Required knowledge:**
- C programming (pointers, memory management, structs)
- Compiler/interpreter basics (lexing, parsing, AST)
- Git and GitHub workflow
- Unix/Linux command line

**Required tools:**
- GCC or Clang compiler
- Make build system
- Git version control
- Valgrind (for memory leak detection)
- Basic text editor or IDE

### Communication Channels

**Where to ask questions:**
- GitHub Issues - Bug reports and feature requests
- GitHub Discussions - General questions and design discussions
- Pull Request comments - Specific code feedback

---

## Contribution Workflow

### 1. Find or Create an Issue

**Before writing code:**
- Check if an issue exists for your contribution
- If not, create one describing what you want to do
- Wait for maintainer feedback before starting large changes
- Small bug fixes can skip this step

**Good issue descriptions include:**
- Problem statement (what's broken or missing)
- Proposed solution (how you plan to fix it)
- Examples (code snippets showing the issue)
- Rationale (why this change aligns with Hemlock's philosophy)

### 2. Fork and Clone

```bash
# Fork the repository on GitHub first, then:
git clone https://github.com/YOUR_USERNAME/hemlock.git
cd hemlock
git checkout -b feature/your-feature-name
```

### 3. Make Your Changes

Follow these guidelines:
- Write tests first (TDD approach)
- Implement the feature
- Ensure all tests pass
- Check for memory leaks
- Update documentation

### 4. Test Your Changes

```bash
# Run the full test suite
make test

# Run specific test category
./tests/run_tests.sh tests/category/

# Check for memory leaks
valgrind ./hemlock tests/your_test.hml

# Build and test
make clean && make && make test
```

### 5. Commit Your Changes

**Good commit messages:**
```
Add bitwise operators for integer types

- Implement &, |, ^, <<, >>, ~ operators
- Add type checking to ensure integer-only operations
- Update operator precedence table
- Add comprehensive tests for all operators

Closes #42
```

**Commit message format:**
- First line: Brief summary (50 chars max)
- Blank line
- Detailed explanation (wrap at 72 chars)
- Reference issue numbers

### 6. Submit a Pull Request

**Before submitting:**
- Rebase on latest main branch
- Ensure all tests pass
- Run valgrind to check for leaks
- Update CLAUDE.md if adding user-facing features

**Pull request description should include:**
- What problem this solves
- How it solves it
- Breaking changes (if any)
- Examples of new syntax or behavior
- Test coverage summary

---

## Code Style Guidelines

### C Code Style

**Formatting:**
```c
// Indent with 4 spaces (no tabs)
// K&R brace style for functions
void function_name(int arg1, char *arg2)
{
    if (condition) {
        // Brace on same line for control structures
        do_something();
    }
}

// Line length: 100 characters max
// Use spaces around operators
int result = (a + b) * c;

// Pointer asterisk with type
char *string;   // Good
char* string;   // Avoid
char * string;  // Avoid
```

**Naming conventions:**
```c
// Functions: lowercase_with_underscores
void eval_expression(ASTNode *node);

// Types: PascalCase
typedef struct Value Value;
typedef enum ValueType ValueType;

// Constants: UPPERCASE_WITH_UNDERSCORES
#define MAX_BUFFER_SIZE 4096

// Variables: lowercase_with_underscores
int item_count;
Value *current_value;

// Enums: TYPE_PREFIX_NAME
typedef enum {
    TYPE_I32,
    TYPE_STRING,
    TYPE_OBJECT
} ValueType;
```

**Comments:**
```c
// Single-line comments for brief explanations
// Use complete sentences with proper capitalization

/*
 * Multi-line comments for longer explanations
 * Align asterisks for readability
 */

/**
 * Function documentation comment
 * @param node - AST node to evaluate
 * @return Evaluated value
 */
Value eval_expr(ASTNode *node);
```

**Error handling:**
```c
// Check all malloc calls
char *buffer = malloc(size);
if (!buffer) {
    fprintf(stderr, "Error: Out of memory\n");
    exit(1);
}

// Provide context in error messages
if (file == NULL) {
    fprintf(stderr, "Error: Failed to open '%s': %s\n",
            filename, strerror(errno));
    exit(1);
}

// Use meaningful error messages
// Bad: "Error: Invalid value"
// Good: "Error: Expected integer, got string"
```

**Memory management:**
```c
// Always free what you allocate
Value *val = value_create_i32(42);
// ... use val
value_free(val);

// Set pointers to NULL after freeing (prevents double-free)
free(ptr);
ptr = NULL;

// Document ownership in comments
// This function takes ownership of 'value' and will free it
void store_value(Value *value);

// This function does NOT take ownership (caller must free)
Value *get_value(void);
```

### Code Organization

**File structure:**
```c
// 1. Includes (system headers first, then local)
#include <stdio.h>
#include <stdlib.h>
#include "internal.h"
#include "values.h"

// 2. Constants and macros
#define INITIAL_CAPACITY 16

// 3. Type definitions
typedef struct Foo Foo;

// 4. Static function declarations (internal helpers)
static void helper_function(void);

// 5. Public function implementations
void public_api_function(void)
{
    // Implementation
}

// 6. Static function implementations
static void helper_function(void)
{
    // Implementation
}
```

**Header files:**
```c
// Use header guards
#ifndef HEMLOCK_MODULE_H
#define HEMLOCK_MODULE_H

// Forward declarations
typedef struct Value Value;

// Public API only in headers
void public_function(Value *val);

// Document parameters and return values
/**
 * Evaluates an expression AST node
 * @param node - The AST node to evaluate
 * @param env - The current environment
 * @return The result value
 */
Value *eval_expr(ASTNode *node, Environment *env);

#endif // HEMLOCK_MODULE_H
```

---

## What to Contribute

### âœ… Encouraged Contributions

**Bug fixes:**
- Memory leaks
- Segmentation faults
- Incorrect behavior
- Error message improvements

**Documentation:**
- Code comments
- API documentation
- User guides and tutorials
- Example programs
- Test case documentation

**Tests:**
- Additional test cases for existing features
- Edge case coverage
- Regression tests for fixed bugs
- Performance benchmarks

**Small feature additions:**
- New built-in functions (if they fit the philosophy)
- String/array methods
- Utility functions
- Error handling improvements

**Performance improvements:**
- Faster algorithms (without changing semantics)
- Memory usage reduction
- Benchmark suite
- Profiling tools

**Tooling:**
- Editor syntax highlighting
- Language server protocol (LSP)
- Debugger integration
- Build system improvements

### ðŸ¤” Discuss First

**Major features:**
- New language constructs
- Type system changes
- Syntax additions
- Concurrency primitives

**How to discuss:**
1. Open a GitHub issue or discussion
2. Describe the feature and rationale
3. Show example code
4. Explain how it fits Hemlock's philosophy
5. Wait for maintainer feedback
6. Iterate on design before implementing

---

## What NOT to Contribute

### âŒ Discouraged Contributions

**Don't add features that:**
- Hide complexity from the user
- Make behavior implicit or magical
- Break existing semantics or syntax
- Add garbage collection or automatic memory management
- Violate the "explicit over implicit" principle

**Examples of rejected contributions:**

**1. Automatic semicolon insertion**
```hemlock
// BAD: This would be rejected
let x = 5  // No semicolon
let y = 10 // No semicolon
```
Why: Makes syntax ambiguous, hides errors

**2. RAII/destructors**
```hemlock
// BAD: This would be rejected
let f = open("file.txt");
// File automatically closed at end of scope
```
Why: Hides when resources are released, not explicit

**3. Implicit type coercion that loses data**
```hemlock
// BAD: This would be rejected
let x: i32 = 3.14;  // Silently truncates to 3
```
Why: Data loss should be explicit, not silent

**4. Garbage collection**
```c
// BAD: This would be rejected
void *gc_malloc(size_t size) {
    // Track allocation for automatic cleanup
}
```
Why: Hides memory management, unpredictable performance

**5. Complex macro system**
```hemlock
// BAD: This would be rejected
macro repeat($n, $block) {
    for (let i = 0; i < $n; i++) $block
}
```
Why: Too much magic, makes code hard to reason about

### Common Rejection Reasons

**"This is too implicit"**
- Solution: Make the behavior explicit and document it

**"This hides complexity"**
- Solution: Expose the complexity but make it ergonomic

**"This breaks existing code"**
- Solution: Find a non-breaking alternative or discuss versioning

**"This doesn't fit Hemlock's philosophy"**
- Solution: Re-read philosophy.md and reconsider the approach

---

## Common Patterns

### Error Handling Pattern

```c
// Use this pattern for recoverable errors in Hemlock code
Value *divide(Value *a, Value *b)
{
    // Check preconditions
    if (b->type != TYPE_I32) {
        // Return error value or throw exception
        return create_error("Expected integer divisor");
    }

    if (b->i32_value == 0) {
        return create_error("Division by zero");
    }

    // Perform operation
    return value_create_i32(a->i32_value / b->i32_value);
}
```

### Memory Management Pattern

```c
// Pattern: Allocate, use, free
void process_data(void)
{
    // Allocate
    Buffer *buf = create_buffer(1024);
    char *str = malloc(256);

    // Use
    if (buf && str) {
        // ... do work
    }

    // Free (in reverse order of allocation)
    free(str);
    free_buffer(buf);
}
```

### Value Creation Pattern

```c
// Create values using constructors
Value *create_integer(int32_t n)
{
    Value *val = malloc(sizeof(Value));
    if (!val) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }

    val->type = TYPE_I32;
    val->i32_value = n;
    return val;
}
```

### Type Checking Pattern

```c
// Check types before operations
Value *add_values(Value *a, Value *b)
{
    // Type checking
    if (a->type != TYPE_I32 || b->type != TYPE_I32) {
        return create_error("Type mismatch");
    }

    // Safe to proceed
    return value_create_i32(a->i32_value + b->i32_value);
}
```

### String Building Pattern

```c
// Build strings efficiently
void build_error_message(char *buffer, size_t size, const char *detail)
{
    snprintf(buffer, size, "Error: %s (line %d)", detail, line_number);
}
```

---

## Adding New Features

### Feature Addition Checklist

When adding a new feature, follow these steps:

#### 1. Design Phase

- [ ] Read philosophy.md to ensure alignment
- [ ] Create GitHub issue describing the feature
- [ ] Get maintainer approval for design
- [ ] Write specification (syntax, semantics, examples)
- [ ] Consider edge cases and error conditions

#### 2. Implementation Phase

**If adding a language construct:**

- [ ] Add token type to `lexer.h` (if needed)
- [ ] Add lexer rule in `lexer.c` (if needed)
- [ ] Add AST node type in `ast.h`
- [ ] Add AST constructor in `ast.c`
- [ ] Add parser rule in `parser.c`
- [ ] Add runtime behavior in `runtime.c` or appropriate module
- [ ] Handle cleanup in AST free functions

**If adding a built-in function:**

- [ ] Add function implementation in `builtins.c`
- [ ] Register function in `register_builtins()`
- [ ] Handle all parameter type combinations
- [ ] Return appropriate error values
- [ ] Document parameters and return type

**If adding a value type:**

- [ ] Add type enum in `values.h`
- [ ] Add field to Value union
- [ ] Add constructor in `values.c`
- [ ] Add to `value_free()` for cleanup
- [ ] Add to `value_copy()` for copying
- [ ] Add to `value_to_string()` for printing
- [ ] Add type promotion rules if numeric

#### 3. Testing Phase

- [ ] Write test cases (see testing.md)
- [ ] Test success cases
- [ ] Test error cases
- [ ] Test edge cases
- [ ] Run full test suite (`make test`)
- [ ] Check for memory leaks with valgrind
- [ ] Test on multiple platforms (if possible)

#### 4. Documentation Phase

- [ ] Update CLAUDE.md with user-facing documentation
- [ ] Add code comments explaining implementation
- [ ] Create examples in `examples/`
- [ ] Update relevant docs/ files
- [ ] Document any breaking changes

#### 5. Submission Phase

- [ ] Clean up debug code and comments
- [ ] Verify code style compliance
- [ ] Rebase on latest main
- [ ] Create pull request with detailed description
- [ ] Respond to code review feedback

### Example: Adding a New Operator

Let's walk through adding the modulo operator `%` as an example:

**1. Lexer (lexer.c):**
```c
// Add to switch statement in get_next_token()
case '%':
    return create_token(TOKEN_PERCENT, "%", line);
```

**2. Lexer header (lexer.h):**
```c
typedef enum {
    // ... existing tokens
    TOKEN_PERCENT,
    // ...
} TokenType;
```

**3. AST (ast.h):**
```c
typedef enum {
    // ... existing operators
    OP_MOD,
    // ...
} BinaryOp;
```

**4. Parser (parser.c):**
```c
// Add to parse_multiplicative() or appropriate precedence level
if (match(TOKEN_PERCENT)) {
    BinaryOp op = OP_MOD;
    ASTNode *right = parse_unary();
    left = create_binary_op_node(op, left, right);
}
```

**5. Runtime (runtime.c):**
```c
// Add to eval_binary_op()
case OP_MOD:
    // Type checking
    if (left->type == TYPE_I32 && right->type == TYPE_I32) {
        if (right->i32_value == 0) {
            fprintf(stderr, "Error: Modulo by zero\n");
            exit(1);
        }
        return value_create_i32(left->i32_value % right->i32_value);
    }
    // ... handle other type combinations
    break;
```

**6. Tests (tests/operators/modulo.hml):**
```hemlock
// Basic modulo
print(10 % 3);  // Expect: 2

// Negative modulo
print(-10 % 3); // Expect: -1

// Error case (should fail)
// print(10 % 0);  // Division by zero
```

**7. Documentation (CLAUDE.md):**
```markdown
### Arithmetic Operators
- `+` - Addition
- `-` - Subtraction
- `*` - Multiplication
- `/` - Division
- `%` - Modulo (remainder)
```

---

## Code Review Process

### What Reviewers Look For

**1. Correctness**
- Does the code do what it claims?
- Are edge cases handled?
- Are there memory leaks?
- Are errors handled properly?

**2. Philosophy Alignment**
- Does this fit Hemlock's design principles?
- Is it explicit or implicit?
- Does it hide complexity?

**3. Code Quality**
- Is the code readable and maintainable?
- Are variable names descriptive?
- Are functions reasonably sized?
- Is there adequate documentation?

**4. Testing**
- Are there sufficient test cases?
- Do tests cover success and failure paths?
- Are edge cases tested?

**5. Documentation**
- Is user-facing documentation updated?
- Are code comments clear?
- Are examples provided?

### Responding to Feedback

**Do:**
- Thank reviewers for their time
- Ask clarifying questions if you don't understand
- Explain your reasoning if you disagree
- Make requested changes promptly
- Update the PR description if scope changes

**Don't:**
- Take criticism personally
- Argue defensively
- Ignore feedback
- Force-push over review comments (unless rebasing)
- Add unrelated changes to the PR

### Getting Your PR Merged

**Requirements for merge:**
- [ ] All tests pass
- [ ] No memory leaks (valgrind clean)
- [ ] Code review approval from maintainer
- [ ] Documentation updated
- [ ] Follows code style guidelines
- [ ] Aligns with Hemlock's philosophy

**Timeline:**
- Small PRs (bug fixes): Usually reviewed within a few days
- Medium PRs (new features): May take 1-2 weeks
- Large PRs (major changes): Requires extensive discussion

---

## Additional Resources

### Learning Resources

**Understanding interpreters:**
- "Crafting Interpreters" by Robert Nystrom
- "Writing An Interpreter In Go" by Thorsten Ball
- "Modern Compiler Implementation in C" by Andrew Appel

**C programming:**
- "The C Programming Language" by K&R
- "Expert C Programming" by Peter van der Linden
- "C Interfaces and Implementations" by David Hanson

**Memory management:**
- Valgrind documentation
- "Understanding and Using C Pointers" by Richard Reese

### Useful Commands

```bash
# Build with debug symbols
make clean && make CFLAGS="-g -O0"

# Run with valgrind
valgrind --leak-check=full ./hemlock script.hml

# Run specific test category
./tests/run_tests.sh tests/strings/

# Generate tags file for code navigation
ctags -R .

# Find all TODOs and FIXMEs
grep -rn "TODO\|FIXME" src/ include/
```

---

## Questions?

If you have questions about contributing:

1. Check the documentation in `docs/`
2. Search existing GitHub issues
3. Ask in GitHub Discussions
4. Open a new issue with your question

**Thank you for contributing to Hemlock!**


--------------------------------------------------------------------------------
## Test
--------------------------------------------------------------------------------

# Testing Guide for Hemlock

This guide explains Hemlock's testing philosophy, how to write tests, and how to run the test suite.

---

## Table of Contents

- [Testing Philosophy](#testing-philosophy)
- [Test Suite Structure](#test-suite-structure)
- [Running Tests](#running-tests)
- [Writing Tests](#writing-tests)
- [Test Categories](#test-categories)
- [Memory Leak Testing](#memory-leak-testing)
- [Continuous Integration](#continuous-integration)
- [Best Practices](#best-practices)

---

## Testing Philosophy

### Core Principles

**1. Test-Driven Development (TDD)**

Write tests **before** implementing features:

```
1. Write a failing test
2. Implement the feature
3. Run the test (should pass)
4. Refactor if needed
5. Repeat
```

**Benefits:**
- Ensures features actually work
- Prevents regressions
- Documents expected behavior
- Makes refactoring safer

**2. Comprehensive Coverage**

Test both success and failure cases:

```hemlock
// Success case
let x: u8 = 255;  // Should work

// Failure case
let y: u8 = 256;  // Should error
```

**3. Test Early and Often**

Run tests:
- Before committing code
- After making changes
- Before submitting pull requests
- During code review

**Rule:** All tests must pass before merging.

### What to Test

**Always test:**
- âœ… Basic functionality (happy path)
- âœ… Error conditions (sad path)
- âœ… Edge cases (boundary conditions)
- âœ… Type checking and conversions
- âœ… Memory management (no leaks)
- âœ… Concurrency and race conditions

**Example test coverage:**
```hemlock
// Feature: String.substr(start, length)

// Happy path
print("hello".substr(0, 5));  // "hello"

// Edge cases
print("hello".substr(0, 0));  // "" (empty)
print("hello".substr(5, 0));  // "" (at end)
print("hello".substr(2, 100)); // "llo" (past end)

// Error cases
// "hello".substr(-1, 5);  // Error: negative index
// "hello".substr(0, -1);  // Error: negative length
```

---

## Test Suite Structure

### Directory Organization

```
tests/
â”œâ”€â”€ run_tests.sh          # Main test runner script
â”œâ”€â”€ primitives/           # Type system tests
â”‚   â”œâ”€â”€ integers.hml
â”‚   â”œâ”€â”€ floats.hml
â”‚   â”œâ”€â”€ booleans.hml
â”‚   â”œâ”€â”€ i64.hml
â”‚   â””â”€â”€ u64.hml
â”œâ”€â”€ conversions/          # Type conversion tests
â”‚   â”œâ”€â”€ int_to_float.hml
â”‚   â”œâ”€â”€ promotion.hml
â”‚   â””â”€â”€ rune_conversions.hml
â”œâ”€â”€ memory/               # Pointer/buffer tests
â”‚   â”œâ”€â”€ alloc.hml
â”‚   â”œâ”€â”€ buffer.hml
â”‚   â””â”€â”€ memcpy.hml
â”œâ”€â”€ strings/              # String operation tests
â”‚   â”œâ”€â”€ concat.hml
â”‚   â”œâ”€â”€ methods.hml
â”‚   â”œâ”€â”€ utf8.hml
â”‚   â””â”€â”€ runes.hml
â”œâ”€â”€ control/              # Control flow tests
â”‚   â”œâ”€â”€ if.hml
â”‚   â”œâ”€â”€ switch.hml
â”‚   â””â”€â”€ while.hml
â”œâ”€â”€ functions/            # Function and closure tests
â”‚   â”œâ”€â”€ basics.hml
â”‚   â”œâ”€â”€ closures.hml
â”‚   â””â”€â”€ recursion.hml
â”œâ”€â”€ objects/              # Object tests
â”‚   â”œâ”€â”€ literals.hml
â”‚   â”œâ”€â”€ methods.hml
â”‚   â”œâ”€â”€ duck_typing.hml
â”‚   â””â”€â”€ serialization.hml
â”œâ”€â”€ arrays/               # Array operation tests
â”‚   â”œâ”€â”€ basics.hml
â”‚   â”œâ”€â”€ methods.hml
â”‚   â””â”€â”€ slicing.hml
â”œâ”€â”€ loops/                # Loop tests
â”‚   â”œâ”€â”€ for.hml
â”‚   â”œâ”€â”€ while.hml
â”‚   â”œâ”€â”€ break.hml
â”‚   â””â”€â”€ continue.hml
â”œâ”€â”€ exceptions/           # Error handling tests
â”‚   â”œâ”€â”€ try_catch.hml
â”‚   â”œâ”€â”€ finally.hml
â”‚   â””â”€â”€ throw.hml
â”œâ”€â”€ io/                   # File I/O tests
â”‚   â”œâ”€â”€ file_object.hml
â”‚   â”œâ”€â”€ read_write.hml
â”‚   â””â”€â”€ seek.hml
â”œâ”€â”€ async/                # Concurrency tests
â”‚   â”œâ”€â”€ spawn_join.hml
â”‚   â”œâ”€â”€ channels.hml
â”‚   â””â”€â”€ exceptions.hml
â”œâ”€â”€ ffi/                  # FFI tests
â”‚   â”œâ”€â”€ basic_call.hml
â”‚   â”œâ”€â”€ types.hml
â”‚   â””â”€â”€ dlopen.hml
â”œâ”€â”€ signals/              # Signal handling tests
â”‚   â”œâ”€â”€ basic.hml
â”‚   â”œâ”€â”€ handlers.hml
â”‚   â””â”€â”€ raise.hml
â””â”€â”€ args/                 # Command-line args tests
    â””â”€â”€ basic.hml
```

### Test File Naming

**Conventions:**
- Use descriptive names: `method_chaining.hml` not `test1.hml`
- Group related tests: `string_substr.hml`, `string_slice.hml`
- One feature area per file
- Keep files focused and small

---

## Running Tests

### Run All Tests

```bash
# From hemlock root directory
make test

# Or directly
./tests/run_tests.sh
```

**Output:**
```
Running tests in tests/primitives/...
  âœ“ integers.hml
  âœ“ floats.hml
  âœ“ booleans.hml

Running tests in tests/strings/...
  âœ“ concat.hml
  âœ“ methods.hml

...

Total: 251 tests
Passed: 251
Failed: 0
```

### Run Specific Category

```bash
# Run only string tests
./tests/run_tests.sh tests/strings/

# Run only one test file
./tests/run_tests.sh tests/strings/concat.hml

# Run multiple categories
./tests/run_tests.sh tests/strings/ tests/arrays/
```

### Run with Valgrind (Memory Leak Check)

```bash
# Check single test for leaks
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml

# Check all tests (slow!)
for test in tests/**/*.hml; do
    echo "Testing $test"
    valgrind --leak-check=full --error-exitcode=1 ./hemlock "$test"
done
```

### Debug Failed Tests

```bash
# Run with verbose output
./hemlock tests/failing_test.hml

# Run with gdb
gdb --args ./hemlock tests/failing_test.hml
(gdb) run
(gdb) backtrace  # if it crashes
```

---

## Writing Tests

### Test File Format

Test files are just Hemlock programs with expected output:

**Example: tests/primitives/integers.hml**
```hemlock
// Test basic integer literals
let x = 42;
print(x);  // Expect: 42

let y: i32 = 100;
print(y);  // Expect: 100

// Test arithmetic
let sum = x + y;
print(sum);  // Expect: 142

// Test type inference
let small = 10;
print(typeof(small));  // Expect: i32

let large = 5000000000;
print(typeof(large));  // Expect: i64
```

**How tests work:**
1. Test runner executes the .hml file
2. Captures stdout output
3. Compares with expected output (from comments or separate .out file)
4. Reports pass/fail

### Expected Output Methods

**Method 1: Inline comments (recommended for simple tests)**

```hemlock
print("hello");  // Expect: hello
print(42);       // Expect: 42
```

The test runner parses `// Expect: ...` comments.

**Method 2: Separate .out file**

Create `test_name.hml.out` with expected output:

**test_name.hml:**
```hemlock
print("line 1");
print("line 2");
print("line 3");
```

**test_name.hml.out:**
```
line 1
line 2
line 3
```

### Testing Error Cases

Error tests should cause the program to exit with non-zero status:

**Example: tests/primitives/range_error.hml**
```hemlock
// This should fail with a type error
let x: u8 = 256;  // Out of range for u8
```

**Expected behavior:**
- Program exits with non-zero status
- Prints error message to stderr

**Test runner handling:**
- Tests expecting errors should be in separate files
- Use naming convention: `*_error.hml` or `*_fail.hml`
- Document expected error in comments

### Testing Success Cases

**Example: tests/strings/methods.hml**
```hemlock
// Test substr
let s = "hello world";
let sub = s.substr(6, 5);
print(sub);  // Expect: world

// Test find
let pos = s.find("world");
print(pos);  // Expect: 6

// Test contains
let has = s.contains("lo");
print(has);  // Expect: true

// Test trim
let padded = "  hello  ";
let trimmed = padded.trim();
print(trimmed);  // Expect: hello
```

### Testing Edge Cases

**Example: tests/arrays/edge_cases.hml**
```hemlock
// Empty array
let empty = [];
print(empty.length);  // Expect: 0

// Single element
let single = [42];
print(single[0]);  // Expect: 42

// Negative index (should error in separate test file)
// print(single[-1]);  // Error

// Past-end index (should error)
// print(single[100]);  // Error

// Boundary conditions
let arr = [1, 2, 3];
print(arr.slice(0, 0));  // Expect: [] (empty)
print(arr.slice(3, 3));  // Expect: [] (empty)
print(arr.slice(1, 2));  // Expect: [2]
```

### Testing Type System

**Example: tests/conversions/promotion.hml**
```hemlock
// Test type promotion in binary operations

// i32 + i64 -> i64
let a: i32 = 10;
let b: i64 = 20;
let c = a + b;
print(typeof(c));  // Expect: i64

// i32 + f32 -> f32
let d: i32 = 10;
let e: f32 = 3.14;
let f = d + e;
print(typeof(f));  // Expect: f32

// u8 + i32 -> i32
let g: u8 = 5;
let h: i32 = 10;
let i = g + h;
print(typeof(i));  // Expect: i32
```

### Testing Concurrency

**Example: tests/async/basic.hml**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Spawn tasks
let t1 = spawn(compute, 10);
let t2 = spawn(compute, 20);

// Join and print results
let r1 = join(t1);
let r2 = join(t2);
print(r1);  // Expect: 45
print(r2);  // Expect: 190
```

### Testing Exceptions

**Example: tests/exceptions/try_catch.hml**
```hemlock
// Test basic try/catch
try {
    throw "error message";
} catch (e) {
    print("Caught: " + e);  // Expect: Caught: error message
}

// Test finally
let executed = false;
try {
    print("try");  // Expect: try
} finally {
    executed = true;
    print("finally");  // Expect: finally
}

// Test exception propagation
fn risky(): i32 {
    throw "failure";
}

try {
    risky();
} catch (e) {
    print(e);  // Expect: failure
}
```

---

## Test Categories

### Primitives Tests

**What to test:**
- Integer types (i8, i16, i32, i64, u8, u16, u32, u64)
- Float types (f32, f64)
- Boolean type
- String type
- Rune type
- Null type

**Example areas:**
- Literal syntax
- Type inference
- Range checking
- Overflow behavior
- Type annotations

### Conversion Tests

**What to test:**
- Implicit type promotion
- Explicit type conversion
- Lossy conversions (should error)
- Type promotion in operations
- Cross-type comparisons

### Memory Tests

**What to test:**
- alloc/free correctness
- Buffer creation and access
- Bounds checking on buffers
- memset, memcpy, realloc
- Memory leak detection (valgrind)

### String Tests

**What to test:**
- Concatenation
- All 18 string methods
- UTF-8 handling
- Rune indexing
- String + rune concatenation
- Edge cases (empty strings, single char, etc.)

### Control Flow Tests

**What to test:**
- if/else/else if
- while loops
- for loops
- switch statements
- break/continue
- return statements

### Function Tests

**What to test:**
- Function definition and calling
- Parameter passing
- Return values
- Recursion
- Closures and capture
- First-class functions
- Anonymous functions

### Object Tests

**What to test:**
- Object literals
- Field access and assignment
- Methods and self binding
- Duck typing
- Optional fields
- JSON serialization/deserialization
- Circular reference detection

### Array Tests

**What to test:**
- Array creation
- Indexing and assignment
- All 15 array methods
- Mixed types
- Dynamic resizing
- Edge cases (empty, single element)

### Exception Tests

**What to test:**
- try/catch/finally
- throw statement
- Exception propagation
- Nested try/catch
- Return in try/catch/finally
- Uncaught exceptions

### I/O Tests

**What to test:**
- File opening modes
- Read/write operations
- Seek/tell
- File properties
- Error handling (missing files, etc.)
- Resource cleanup

### Async Tests

**What to test:**
- spawn/join/detach
- Channel send/recv
- Exception propagation in tasks
- Multiple concurrent tasks
- Channel blocking behavior

### FFI Tests

**What to test:**
- dlopen/dlclose
- dlsym
- dlcall with various types
- Type conversion
- Error handling

---

## Memory Leak Testing

### Using Valgrind

**Basic usage:**
```bash
valgrind --leak-check=full ./hemlock test.hml
```

**Example output (no leaks):**
```
==12345== HEAP SUMMARY:
==12345==     in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated
==12345==
==12345== All heap blocks were freed -- no leaks are possible
```

**Example output (with leak):**
```
==12345== LEAK SUMMARY:
==12345==    definitely lost: 64 bytes in 1 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==      possibly lost: 0 bytes in 0 blocks
==12345==    still reachable: 0 bytes in 0 blocks
==12345==         suppressed: 0 bytes in 0 blocks
```

### Common Leak Sources

**1. Missing free() calls:**
```c
// BAD
char *str = malloc(100);
// ... use str
// Forgot to free!

// GOOD
char *str = malloc(100);
// ... use str
free(str);
```

**2. Lost pointers:**
```c
// BAD
char *ptr = malloc(100);
ptr = malloc(200);  // Lost reference to first allocation!

// GOOD
char *ptr = malloc(100);
free(ptr);
ptr = malloc(200);
```

**3. Exception paths:**
```c
// BAD
void func() {
    char *data = malloc(100);
    if (error_condition) {
        return;  // Leak!
    }
    free(data);
}

// GOOD
void func() {
    char *data = malloc(100);
    if (error_condition) {
        free(data);
        return;
    }
    free(data);
}
```

### Known Acceptable Leaks

Some small "leaks" are intentional startup allocations:

**Global built-ins:**
```hemlock
// Built-in functions, FFI types, and constants are allocated at startup
// and not freed at exit (typically ~200 bytes)
```

These are not true leaks - they're one-time allocations that persist for the program lifetime and are cleaned up by the OS on exit.

---

## Continuous Integration

### GitHub Actions (Future)

Once CI is set up, all tests will run automatically on:
- Push to main branch
- Pull request creation/update
- Scheduled daily runs

**CI workflow:**
1. Build Hemlock
2. Run test suite
3. Check for memory leaks (valgrind)
4. Report results on PR

### Pre-Commit Checks

Before committing, run:

```bash
# Build fresh
make clean && make

# Run all tests
make test

# Check a few tests for leaks
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml
valgrind --leak-check=full ./hemlock tests/strings/concat.hml
```

---

## Best Practices

### Do's

âœ… **Write tests first (TDD)**
```bash
1. Create tests/feature/new_feature.hml
2. Implement feature in src/
3. Run tests until they pass
```

âœ… **Test both success and failure**
```hemlock
// Success: tests/feature/success.hml
let result = do_thing();
print(result);  // Expect: expected value

// Failure: tests/feature/failure.hml
do_invalid_thing();  // Should error
```

âœ… **Use descriptive test names**
```
Good: tests/strings/substr_utf8_boundary.hml
Bad:  tests/test1.hml
```

âœ… **Keep tests focused**
- One feature area per file
- Clear setup and assertions
- Minimal code

âœ… **Add comments explaining tricky tests**
```hemlock
// Test that closure captures outer variable by reference
fn outer() {
    let x = 10;
    let f = fn() { return x; };
    x = 20;  // Modify after closure creation
    return f();  // Should return 20, not 10
}
```

âœ… **Test edge cases**
- Empty inputs
- Null values
- Boundary values (min/max)
- Large inputs
- Negative values

### Don'ts

âŒ **Don't skip tests**
- All tests must pass before merging
- Don't comment out failing tests
- Fix the bug or remove the feature

âŒ **Don't write tests that depend on each other**
```hemlock
// BAD: test2.hml depends on test1.hml output
// Tests should be independent
```

âŒ **Don't use random values in tests**
```hemlock
// BAD: Non-deterministic
let x = random();
print(x);  // Can't predict output

// GOOD: Deterministic
let x = 42;
print(x);  // Expect: 42
```

âŒ **Don't test implementation details**
```hemlock
// BAD: Testing internal structure
let obj = { x: 10 };
// Don't check internal field order, capacity, etc.

// GOOD: Testing behavior
print(obj.x);  // Expect: 10
```

âŒ **Don't ignore memory leaks**
- All tests should be valgrind-clean
- Document known/acceptable leaks
- Fix leaks before merging

### Test Maintenance

**When to update tests:**
- Feature behavior changes
- Bug fixes require new test cases
- Edge cases discovered
- Performance improvements

**When to remove tests:**
- Feature removed from language
- Test duplicates existing coverage
- Test was incorrect

**Refactoring tests:**
- Group related tests together
- Extract common setup code
- Use consistent naming
- Keep tests simple and readable

---

## Example Test Session

Here's a complete example of adding a feature with tests:

### Feature: Add `array.first()` method

**1. Write the test first:**

```bash
# Create test file
cat > tests/arrays/first_method.hml << 'EOF'
// Test array.first() method

// Basic case
let arr = [1, 2, 3];
print(arr.first());  // Expect: 1

// Single element
let single = [42];
print(single.first());  // Expect: 42

// Empty array (should error - separate test file)
// let empty = [];
// print(empty.first());  // Error
EOF
```

**2. Run the test (should fail):**

```bash
./hemlock tests/arrays/first_method.hml
# Error: Method 'first' not found on array
```

**3. Implement the feature:**

Edit `src/interpreter/builtins.c`:

```c
// Add array_first method
Value *array_first(Value *self, Value **args, int arg_count)
{
    if (self->array_value->length == 0) {
        fprintf(stderr, "Error: Cannot get first element of empty array\n");
        exit(1);
    }

    return value_copy(&self->array_value->elements[0]);
}

// Register in array method table
// ... add to array method registration
```

**4. Run the test (should pass):**

```bash
./hemlock tests/arrays/first_method.hml
1
42
# Success!
```

**5. Check for memory leaks:**

```bash
valgrind --leak-check=full ./hemlock tests/arrays/first_method.hml
# All heap blocks were freed -- no leaks are possible
```

**6. Run full test suite:**

```bash
make test
# Total: 252 tests (251 + new one)
# Passed: 252
# Failed: 0
```

**7. Commit:**

```bash
git add tests/arrays/first_method.hml src/interpreter/builtins.c
git commit -m "Add array.first() method with tests"
```

---

## Summary

**Remember:**
- Write tests first (TDD)
- Test success and failure cases
- Run all tests before committing
- Check for memory leaks
- Document known issues
- Keep tests simple and focused

**Test quality is just as important as code quality!**



################################################################################
# HPM: PRIMI PASSI
################################################################################

--------------------------------------------------------------------------------
## Avvio Rapido
--------------------------------------------------------------------------------

# Avvio Rapido

Inizia a usare hpm in 5 minuti.

## Installa hpm

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh
```

Per ulteriori opzioni di installazione, consulta la [Guida all'Installazione](#hpm-quick-start-installation).

## Crea un Nuovo Progetto

Inizia creando una nuova directory e inizializzando un pacchetto:

```bash
mkdir mio-progetto
cd mio-progetto
hpm init
```

Ti verranno richiesti i dettagli del progetto:

```
Nome pacchetto (proprietario/repo): mionome/mio-progetto
Versione (1.0.0):
Descrizione: Il mio fantastico progetto Hemlock
Autore: Il Tuo Nome <tu@esempio.com>
Licenza (MIT):
File principale (src/index.hml):

Creato package.json
```

Usa `--yes` per accettare tutti i valori predefiniti:

```bash
hpm init --yes
```

## Struttura del Progetto

Crea la struttura di base del progetto:

```
mio-progetto/
â”œâ”€â”€ package.json        # Manifesto del progetto
â”œâ”€â”€ src/
â”‚   â””â”€â”€ index.hml      # Punto di ingresso principale
â””â”€â”€ test/
    â””â”€â”€ test.hml       # Test
```

Crea il tuo file principale:

```bash
mkdir -p src test
```

**src/index.hml:**
```hemlock
// Punto di ingresso principale
export fn saluta(nome: string): string {
    return "Ciao, " + nome + "!";
}

export fn main() {
    print(saluta("Mondo"));
}
```

## Installa le Dipendenze

Cerca pacchetti su GitHub (i pacchetti usano il formato `proprietario/repo`):

```bash
# Installa un pacchetto
hpm install hemlang/sprout

# Installa con vincolo di versione
hpm install hemlang/json@^1.0.0

# Installa come dipendenza di sviluppo
hpm install hemlang/test-utils --dev
```

Dopo l'installazione, la struttura del tuo progetto include `hem_modules/`:

```
mio-progetto/
â”œâ”€â”€ package.json
â”œâ”€â”€ package-lock.json   # File di lock (generato automaticamente)
â”œâ”€â”€ hem_modules/        # Pacchetti installati
â”‚   â””â”€â”€ hemlang/
â”‚       â””â”€â”€ sprout/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ index.hml
â””â”€â”€ test/
    â””â”€â”€ test.hml
```

## Usa i Pacchetti Installati

Importa i pacchetti usando il loro percorso GitHub:

```hemlock
// Importa dal pacchetto installato
import { app, router } from "hemlang/sprout";
import { parse, stringify } from "hemlang/json";

// Importa da un sottopercorso
import { middleware } from "hemlang/sprout/middleware";

// Libreria standard (integrata)
import { HashMap } from "@stdlib/collections";
import { readFile } from "@stdlib/fs";
```

## Aggiungi Script

Aggiungi script al tuo `package.json`:

```json
{
  "name": "mionome/mio-progetto",
  "version": "1.0.0",
  "scripts": {
    "start": "hemlock src/index.hml",
    "test": "hemlock test/test.hml",
    "build": "hemlock --bundle src/index.hml -o dist/app.hmlc"
  }
}
```

Esegui gli script con `hpm run`:

```bash
hpm run start
hpm run build

# Abbreviazione per test
hpm test
```

## Flussi di Lavoro Comuni

### Installazione di Tutte le Dipendenze

Quando cloni un progetto con un `package.json`:

```bash
git clone https://github.com/qualcuno/progetto.git
cd progetto
hpm install
```

### Aggiornamento delle Dipendenze

Aggiorna tutti i pacchetti alle ultime versioni entro i vincoli:

```bash
hpm update
```

Aggiorna un pacchetto specifico:

```bash
hpm update hemlang/sprout
```

### Visualizzazione dei Pacchetti Installati

Elenca tutti i pacchetti installati:

```bash
hpm list
```

L'output mostra l'albero delle dipendenze:

```
mio-progetto@1.0.0
â”œâ”€â”€ hemlang/sprout@2.1.0
â”‚   â””â”€â”€ hemlang/router@1.5.0
â””â”€â”€ hemlang/json@1.2.3
```

### Verifica degli Aggiornamenti

Vedi quali pacchetti hanno versioni piu recenti:

```bash
hpm outdated
```

### Rimozione di un Pacchetto

```bash
hpm uninstall hemlang/sprout
```

## Esempio: Applicazione Web

Ecco un esempio completo usando un framework web:

**package.json:**
```json
{
  "name": "mionome/mia-app-web",
  "version": "1.0.0",
  "description": "Un'applicazione web",
  "main": "src/index.hml",
  "dependencies": {
    "hemlang/sprout": "^2.0.0"
  },
  "scripts": {
    "start": "hemlock src/index.hml",
    "dev": "hemlock --watch src/index.hml"
  }
}
```

**src/index.hml:**
```hemlock
import { App, Router } from "hemlang/sprout";

fn main() {
    let app = App.new();
    let router = Router.new();

    router.get("/", fn(req, res) {
        res.send("Ciao, Mondo!");
    });

    router.get("/api/stato", fn(req, res) {
        res.json({ stato: "ok" });
    });

    app.use(router);
    app.listen(3000);

    print("Server in esecuzione su http://localhost:3000");
}
```

Esegui l'applicazione:

```bash
hpm install
hpm run start
```

## Prossimi Passi

- [Riferimento Comandi](#hpm-quick-start-commands) - Impara tutti i comandi hpm
- [Creazione di Pacchetti](#hpm-quick-start-creating-packages) - Pubblica i tuoi pacchetti
- [Configurazione](#hpm-quick-start-configuration) - Configura hpm e i token GitHub
- [Configurazione del Progetto](#hpm-quick-start-project-setup) - Configurazione dettagliata del progetto


--------------------------------------------------------------------------------
## Configurazione del Progetto
--------------------------------------------------------------------------------

# Configurazione del Progetto

Guida completa per configurare progetti Hemlock con hpm.

## Iniziare un Nuovo Progetto

### Configurazione di Base

Crea un nuovo progetto da zero:

```bash
# Crea la directory del progetto
mkdir mio-progetto
cd mio-progetto

# Inizializza package.json
hpm init

# Crea la struttura delle directory
mkdir -p src test
```

### Modelli di Progetto

Ecco strutture di progetto comuni per diversi casi d'uso:

#### Pacchetto Libreria

Per librerie riutilizzabili:

```
mia-libreria/
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ LICENSE
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.hml          # Ingresso principale, esporta API pubblica
â”‚   â”œâ”€â”€ core.hml           # Funzionalita core
â”‚   â”œâ”€â”€ utils.hml          # Funzioni di utilita
â”‚   â””â”€â”€ types.hml          # Definizioni dei tipi
â””â”€â”€ test/
    â”œâ”€â”€ framework.hml      # Framework di test
    â”œâ”€â”€ run.hml            # Esecutore dei test
    â””â”€â”€ test_core.hml      # Test
```

**package.json:**

```json
{
  "name": "tuonome/mia-libreria",
  "version": "1.0.0",
  "description": "Una libreria Hemlock riutilizzabile",
  "main": "src/index.hml",
  "scripts": {
    "test": "hemlock test/run.hml"
  },
  "dependencies": {},
  "devDependencies": {}
}
```

#### Applicazione

Per applicazioni standalone:

```
mia-app/
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.hml           # Punto di ingresso dell'applicazione
â”‚   â”œâ”€â”€ config.hml         # Configurazione
â”‚   â”œâ”€â”€ commands/          # Comandi CLI
â”‚   â”‚   â”œâ”€â”€ index.hml
â”‚   â”‚   â””â”€â”€ run.hml
â”‚   â””â”€â”€ lib/               # Librerie interne
â”‚       â””â”€â”€ utils.hml
â”œâ”€â”€ test/
â”‚   â””â”€â”€ run.hml
â””â”€â”€ data/                  # File di dati
```

**package.json:**

```json
{
  "name": "tuonome/mia-app",
  "version": "1.0.0",
  "description": "Un'applicazione Hemlock",
  "main": "src/main.hml",
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc"
  },
  "dependencies": {
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {}
}
```

#### Applicazione Web

Per server web:

```
mia-app-web/
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.hml           # Punto di ingresso del server
â”‚   â”œâ”€â”€ routes/            # Gestori delle route
â”‚   â”‚   â”œâ”€â”€ index.hml
â”‚   â”‚   â”œâ”€â”€ api.hml
â”‚   â”‚   â””â”€â”€ auth.hml
â”‚   â”œâ”€â”€ middleware/        # Middleware
â”‚   â”‚   â”œâ”€â”€ index.hml
â”‚   â”‚   â””â”€â”€ auth.hml
â”‚   â”œâ”€â”€ models/            # Modelli dati
â”‚   â”‚   â””â”€â”€ user.hml
â”‚   â””â”€â”€ services/          # Logica di business
â”‚       â””â”€â”€ user.hml
â”œâ”€â”€ test/
â”‚   â””â”€â”€ run.hml
â”œâ”€â”€ static/                # File statici
â”‚   â”œâ”€â”€ css/
â”‚   â””â”€â”€ js/
â””â”€â”€ views/                 # Template
    â””â”€â”€ index.hml
```

**package.json:**

```json
{
  "name": "tuonome/mia-app-web",
  "version": "1.0.0",
  "description": "Un'applicazione web Hemlock",
  "main": "src/main.hml",
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml"
  },
  "dependencies": {
    "hemlang/sprout": "^2.0.0",
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  }
}
```

## Il File package.json

### Campi Obbligatori

```json
{
  "name": "proprietario/repo",
  "version": "1.0.0"
}
```

### Tutti i Campi

```json
{
  "name": "tuonome/mio-pacchetto",
  "version": "1.0.0",
  "description": "Descrizione del pacchetto",
  "author": "Il Tuo Nome <tu@esempio.com>",
  "license": "MIT",
  "repository": "https://github.com/tuonome/mio-pacchetto",
  "homepage": "https://tuonome.github.io/mio-pacchetto",
  "bugs": "https://github.com/tuonome/mio-pacchetto/issues",
  "main": "src/index.hml",
  "keywords": ["utilita", "parser"],
  "dependencies": {
    "proprietario/pacchetto": "^1.0.0"
  },
  "devDependencies": {
    "proprietario/lib-test": "^1.0.0"
  },
  "scripts": {
    "start": "hemlock src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc"
  },
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ],
  "native": {
    "requires": ["libcurl", "openssl"]
  }
}
```

### Riferimento Campi

| Campo | Tipo | Descrizione |
|-------|------|-------------|
| `name` | stringa | Nome del pacchetto in formato proprietario/repo (obbligatorio) |
| `version` | stringa | Versione semantica (obbligatorio) |
| `description` | stringa | Breve descrizione |
| `author` | stringa | Nome e email dell'autore |
| `license` | stringa | Identificatore della licenza (MIT, Apache-2.0, ecc.) |
| `repository` | stringa | URL del repository |
| `homepage` | stringa | Homepage del progetto |
| `bugs` | stringa | URL del tracker dei problemi |
| `main` | stringa | File punto di ingresso (default: src/index.hml) |
| `keywords` | array | Parole chiave per la ricerca |
| `dependencies` | oggetto | Dipendenze runtime |
| `devDependencies` | oggetto | Dipendenze di sviluppo |
| `scripts` | oggetto | Script denominati |
| `files` | array | File da includere nella pubblicazione |
| `native` | oggetto | Requisiti librerie native |

## Il File package-lock.json

Il file di lock viene generato automaticamente e dovrebbe essere committato nel controllo versione. Garantisce installazioni riproducibili.

```json
{
  "lockVersion": 1,
  "hemlock": "1.0.0",
  "dependencies": {
    "hemlang/sprout": {
      "version": "2.1.0",
      "resolved": "https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz",
      "integrity": "sha256-abc123...",
      "dependencies": {
        "hemlang/router": "^1.5.0"
      }
    },
    "hemlang/router": {
      "version": "1.5.0",
      "resolved": "https://github.com/hemlang/router/archive/v1.5.0.tar.gz",
      "integrity": "sha256-def456...",
      "dependencies": {}
    }
  }
}
```

### Best Practice per il File di Lock

- **Committa** package-lock.json nel controllo versione
- **Non modificare** manualmente - viene generato automaticamente
- **Esegui `hpm install`** dopo aver scaricato le modifiche
- **Elimina e rigenera** se corrotto:
  ```bash
  rm package-lock.json
  hpm install
  ```

## La Directory hem_modules

I pacchetti installati sono memorizzati in `hem_modules/`:

```
hem_modules/
â”œâ”€â”€ hemlang/
â”‚   â”œâ”€â”€ sprout/
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â””â”€â”€ src/
â”‚   â””â”€â”€ router/
â”‚       â”œâ”€â”€ package.json
â”‚       â””â”€â”€ src/
â””â”€â”€ alice/
    â””â”€â”€ http-client/
        â”œâ”€â”€ package.json
        â””â”€â”€ src/
```

### Best Practice per hem_modules

- **Aggiungi a .gitignore** - non committare le dipendenze
- **Non modificare** - le modifiche verranno sovrascritte
- **Elimina per reinstallare da zero**:
  ```bash
  rm -rf hem_modules
  hpm install
  ```

## .gitignore

File .gitignore consigliato per progetti Hemlock:

```gitignore
# Dipendenze
hem_modules/

# Output di build
dist/
*.hmlc

# File IDE
.idea/
.vscode/
*.swp
*.swo

# File del sistema operativo
.DS_Store
Thumbs.db

# Log
*.log
logs/

# Ambiente
.env
.env.local

# Copertura dei test
coverage/
```

## Lavorare con le Dipendenze

### Aggiungere Dipendenze

```bash
# Aggiungi dipendenza runtime
hpm install hemlang/json

# Aggiungi con vincolo di versione
hpm install hemlang/sprout@^2.0.0

# Aggiungi dipendenza di sviluppo
hpm install hemlang/test-utils --dev
```

### Importare Dipendenze

```hemlock
// Importa dal pacchetto (usa la voce "main")
import { parse, stringify } from "hemlang/json";

// Importa da sottopercorso
import { Router } from "hemlang/sprout/router";

// Importa libreria standard
import { HashMap } from "@stdlib/collections";
import { readFile, writeFile } from "@stdlib/fs";
```

### Risoluzione delle Import

hpm risolve le import in questo ordine:

1. **Libreria standard**: import `@stdlib/*` per moduli integrati
2. **Root del pacchetto**: `proprietario/repo` usa il campo `main`
3. **Sottopercorso**: `proprietario/repo/percorso` controlla:
   - `hem_modules/proprietario/repo/percorso.hml`
   - `hem_modules/proprietario/repo/percorso/index.hml`
   - `hem_modules/proprietario/repo/src/percorso.hml`
   - `hem_modules/proprietario/repo/src/percorso/index.hml`

## Script

### Definire Script

Aggiungi script a package.json:

```json
{
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "test:unit": "hemlock test/unit/run.hml",
    "test:integration": "hemlock test/integration/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc",
    "clean": "rm -rf dist hem_modules",
    "lint": "hemlock-lint src/",
    "format": "hemlock-fmt src/"
  }
}
```

### Eseguire Script

```bash
hpm run start
hpm run dev
hpm run build

# Abbreviazione per test
hpm test

# Passare argomenti
hpm run test -- --verbose --filter=unit
```

### Convenzioni di Denominazione degli Script

| Script | Scopo |
|--------|-------|
| `start` | Esegui l'applicazione |
| `dev` | Esegui in modalita sviluppo |
| `test` | Esegui tutti i test |
| `build` | Compila per la produzione |
| `clean` | Rimuovi i file generati |
| `lint` | Controlla lo stile del codice |
| `format` | Formatta il codice |

## Flusso di Lavoro di Sviluppo

### Configurazione Iniziale

```bash
# Clona il progetto
git clone https://github.com/tuonome/mio-progetto.git
cd mio-progetto

# Installa le dipendenze
hpm install

# Esegui i test
hpm test

# Inizia lo sviluppo
hpm run dev
```

### Flusso di Lavoro Giornaliero

```bash
# Scarica le ultime modifiche
git pull

# Installa eventuali nuove dipendenze
hpm install

# Apporta modifiche...

# Esegui i test
hpm test

# Committa
git add .
git commit -m "Aggiungi funzionalita"
git push
```

### Aggiungere una Nuova Funzionalita

```bash
# Crea branch per la funzionalita
git checkout -b feature/nuova-funzionalita

# Aggiungi nuova dipendenza se necessario
hpm install hemlang/nuova-lib

# Implementa la funzionalita...

# Testa
hpm test

# Committa e pusha
git add .
git commit -m "Aggiungi nuova funzionalita"
git push -u origin feature/nuova-funzionalita
```

## Configurazione Specifica per Ambiente

### Usare Variabili d'Ambiente

```hemlock
import { getenv } from "@stdlib/env";

let db_host = getenv("DATABASE_HOST") ?? "localhost";
let api_key = getenv("API_KEY") ?? "";

if api_key == "" {
    print("Attenzione: API_KEY non impostata");
}
```

### File di Configurazione

**config.hml:**

```hemlock
import { getenv } from "@stdlib/env";

export let config = {
    environment: getenv("HEMLOCK_ENV") ?? "development",
    database: {
        host: getenv("DB_HOST") ?? "localhost",
        port: int(getenv("DB_PORT") ?? "5432"),
        name: getenv("DB_NAME") ?? "miaapp"
    },
    server: {
        port: int(getenv("PORT") ?? "3000"),
        host: getenv("HOST") ?? "0.0.0.0"
    }
};

export fn is_production(): bool {
    return config.environment == "production";
}
```

## Vedi Anche

- [Avvio Rapido](#hpm-project-setup-quick-start) - Inizia velocemente
- [Comandi](#hpm-project-setup-commands) - Riferimento comandi
- [Creazione di Pacchetti](#hpm-project-setup-creating-packages) - Pubblicare pacchetti
- [Configurazione](#hpm-project-setup-configuration) - Configurazione di hpm


--------------------------------------------------------------------------------
## Installazione
--------------------------------------------------------------------------------

# Installazione

Questa guida spiega come installare hpm sul tuo sistema.

## Installazione Rapida (Consigliata)

Installa l'ultima versione con un singolo comando:

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh
```

Questo esegue automaticamente:
- Rileva il tuo sistema operativo (Linux, macOS)
- Rileva la tua architettura (x86_64, arm64)
- Scarica il binario precompilato appropriato
- Installa in `/usr/local/bin` (o usa sudo se necessario)

### Opzioni di Installazione

```bash
# Installa in una posizione personalizzata (sudo non richiesto)
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local

# Installa una versione specifica
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5

# Combina le opzioni
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5
```

### Piattaforme Supportate

| Piattaforma | Architettura | Stato |
|-------------|--------------|-------|
| Linux    | x86_64       | Supportato |
| macOS    | x86_64       | Supportato |
| macOS    | arm64 (M1/M2/M3) | Supportato |
| Linux    | arm64        | Compilare dal sorgente |

## Compilazione dal Sorgente

Se preferisci compilare dal sorgente o hai bisogno di una piattaforma non coperta dai binari precompilati, segui queste istruzioni.

### Prerequisiti

hpm richiede che [Hemlock](https://github.com/hemlang/hemlock) sia installato prima. Segui le istruzioni di installazione di Hemlock prima di procedere.

Verifica che Hemlock sia installato:

```bash
hemlock --version
```

## Metodi di Installazione

### Metodo 1: Make Install

Compila dal sorgente e installa.

```bash
# Clona il repository
git clone https://github.com/hemlang/hpm.git
cd hpm

# Installa in /usr/local/bin (richiede sudo)
sudo make install
```

Dopo l'installazione, verifica che funzioni:

```bash
hpm --version
```

### Metodo 2: Posizione Personalizzata

Installa in una directory personalizzata (sudo non richiesto):

```bash
# Clona il repository
git clone https://github.com/hemlang/hpm.git
cd hpm

# Installa in ~/.local/bin
make install PREFIX=$HOME/.local

# Oppure qualsiasi posizione personalizzata
make install PREFIX=/opt/hemlock
```

Assicurati che la tua directory bin personalizzata sia nel tuo PATH:

```bash
# Aggiungi a ~/.bashrc o ~/.zshrc
export PATH="$HOME/.local/bin:$PATH"
```

### Metodo 3: Esegui Senza Installare

Puoi eseguire hpm direttamente senza installare:

```bash
# Clona il repository
git clone https://github.com/hemlang/hpm.git
cd hpm

# Crea lo script wrapper locale
make

# Esegui dalla directory hpm
./hpm --help

# Oppure esegui tramite hemlock direttamente
hemlock src/main.hml --help
```

### Metodo 4: Installazione Manuale

Crea il tuo script wrapper:

```bash
# Clona in una posizione permanente
git clone https://github.com/hemlang/hpm.git ~/.hpm-source

# Crea lo script wrapper
cat > ~/.local/bin/hpm << 'EOF'
#!/bin/sh
exec hemlock "$HOME/.hpm-source/src/main.hml" "$@"
EOF

chmod +x ~/.local/bin/hpm
```

## Variabili di Installazione

Il Makefile supporta queste variabili:

| Variabile | Predefinito | Descrizione |
|-----------|-------------|-------------|
| `PREFIX` | `/usr/local` | Prefisso di installazione |
| `BINDIR` | `$(PREFIX)/bin` | Directory dei binari |
| `HEMLOCK` | `hemlock` | Percorso dell'interprete hemlock |

Esempio con variabili personalizzate:

```bash
make install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock
```

## Come Funziona

L'installer crea uno script shell wrapper che invoca l'interprete Hemlock con il codice sorgente di hpm:

```bash
#!/bin/sh
exec hemlock "/percorso/a/hpm/src/main.hml" "$@"
```

Questo approccio:
- Non richiede compilazione
- Esegue sempre il codice sorgente piu recente
- Funziona in modo affidabile su tutte le piattaforme

## Aggiornamento di hpm

Per aggiornare hpm all'ultima versione:

```bash
cd /percorso/a/hpm
git pull origin main

# Reinstalla se il percorso e cambiato
sudo make install
```

## Disinstallazione

Rimuovi hpm dal tuo sistema:

```bash
cd /percorso/a/hpm
sudo make uninstall
```

Oppure rimuovi manualmente:

```bash
sudo rm /usr/local/bin/hpm
```

## Verifica dell'Installazione

Dopo l'installazione, verifica che tutto funzioni:

```bash
# Controlla la versione
hpm --version

# Visualizza l'aiuto
hpm --help

# Testa l'inizializzazione (in una directory vuota)
mkdir progetto-test && cd progetto-test
hpm init --yes
cat package.json
```

## Risoluzione dei Problemi

### "hemlock: comando non trovato"

Hemlock non e installato o non e nel tuo PATH. Installa prima Hemlock:

```bash
# Controlla se hemlock esiste
which hemlock

# Se non trovato, installa Hemlock da https://github.com/hemlang/hemlock
```

### "Permesso negato"

Usa sudo per l'installazione a livello di sistema, oppure installa in una directory utente:

```bash
# Opzione 1: Usa sudo
sudo make install

# Opzione 2: Installa nella directory utente
make install PREFIX=$HOME/.local
```

### "hpm: comando non trovato" dopo l'installazione

Il tuo PATH potrebbe non includere la directory di installazione:

```bash
# Controlla dove e stato installato hpm
ls -la /usr/local/bin/hpm

# Aggiungi al PATH se usi una posizione personalizzata
export PATH="$HOME/.local/bin:$PATH"
```

## Note Specifiche per Piattaforma

### Linux

L'installazione standard funziona su tutte le distribuzioni Linux. Alcune distribuzioni potrebbero richiedere:

```bash
# Debian/Ubuntu: Assicurati di avere gli strumenti di compilazione
sudo apt-get install build-essential git

# Fedora/RHEL
sudo dnf install make git
```

### macOS

L'installazione standard funziona. Se usi Homebrew:

```bash
# Assicurati di avere gli strumenti da riga di comando Xcode
xcode-select --install
```

### Windows (WSL)

hpm funziona nel Windows Subsystem for Linux:

```bash
# Nel terminale WSL
git clone https://github.com/hemlang/hpm.git
cd hpm
make install PREFIX=$HOME/.local
```

## Prossimi Passi

Dopo l'installazione:

1. [Avvio Rapido](#hpm-installation-quick-start) - Crea il tuo primo progetto
2. [Riferimento Comandi](#hpm-installation-commands) - Impara tutti i comandi
3. [Configurazione](#hpm-installation-configuration) - Configura hpm



################################################################################
# HPM: GUIDA UTENTE
################################################################################

--------------------------------------------------------------------------------
## Comandi
--------------------------------------------------------------------------------

# Riferimento Comandi

Riferimento completo per tutti i comandi hpm.

## Opzioni Globali

Queste opzioni funzionano con qualsiasi comando:

| Opzione | Descrizione |
|---------|-------------|
| `--help`, `-h` | Mostra messaggio di aiuto |
| `--version`, `-v` | Mostra versione di hpm |
| `--verbose` | Mostra output dettagliato |

## Comandi

### hpm init

Crea un nuovo file `package.json`.

```bash
hpm init        # Modalita interattiva
hpm init --yes  # Accetta tutti i valori predefiniti
hpm init -y     # Forma breve
```

**Opzioni:**

| Opzione | Descrizione |
|---------|-------------|
| `--yes`, `-y` | Accetta valori predefiniti per tutti i prompt |

**Prompt interattivi:**
- Nome pacchetto (formato proprietario/repo)
- Versione (default: 1.0.0)
- Descrizione
- Autore
- Licenza (default: MIT)
- File principale (default: src/index.hml)

**Esempio:**

```bash
$ hpm init
Nome pacchetto (proprietario/repo): alice/mia-lib
Versione (1.0.0):
Descrizione: Una libreria di utilita
Autore: Alice <alice@esempio.com>
Licenza (MIT):
File principale (src/index.hml):

Creato package.json
```

---

### hpm install

Installa dipendenze o aggiungi nuovi pacchetti.

```bash
hpm install                           # Installa tutto da package.json
hpm install proprietario/repo         # Aggiungi e installa pacchetto
hpm install proprietario/repo@^1.0.0  # Con vincolo di versione
hpm install proprietario/repo --dev   # Come dipendenza di sviluppo
hpm i proprietario/repo               # Forma breve
```

**Opzioni:**

| Opzione | Descrizione |
|---------|-------------|
| `--dev`, `-D` | Aggiungi a devDependencies |
| `--verbose` | Mostra progresso dettagliato |
| `--dry-run` | Anteprima senza installare |
| `--offline` | Installa solo dalla cache (nessuna rete) |
| `--parallel` | Abilita download paralleli (sperimentale) |

**Sintassi vincoli di versione:**

| Sintassi | Esempio | Significato |
|----------|---------|-------------|
| (nessuno) | `proprietario/repo` | Ultima versione |
| Esatta | `proprietario/repo@1.2.3` | Esattamente 1.2.3 |
| Caret | `proprietario/repo@^1.2.3` | >=1.2.3 <2.0.0 |
| Tilde | `proprietario/repo@~1.2.3` | >=1.2.3 <1.3.0 |
| Range | `proprietario/repo@>=1.0.0` | Almeno 1.0.0 |

**Esempi:**

```bash
# Installa tutte le dipendenze
hpm install

# Installa pacchetto specifico
hpm install hemlang/json

# Installa con vincolo di versione
hpm install hemlang/sprout@^2.0.0

# Installa come dipendenza di sviluppo
hpm install hemlang/test-utils --dev

# Anteprima di cio che verrebbe installato
hpm install hemlang/sprout --dry-run

# Output verboso
hpm install --verbose

# Installa solo dalla cache (offline)
hpm install --offline
```

**Output:**

```
Installazione dipendenze...
  + hemlang/sprout@2.1.0
  + hemlang/router@1.5.0 (dipendenza di hemlang/sprout)

Installati 2 pacchetti in 1.2s
```

---

### hpm uninstall

Rimuovi un pacchetto.

```bash
hpm uninstall proprietario/repo
hpm rm proprietario/repo          # Forma breve
hpm remove proprietario/repo      # Alternativa
```

**Esempi:**

```bash
hpm uninstall hemlang/sprout
```

**Output:**

```
Rimosso hemlang/sprout@2.1.0
Aggiornato package.json
Aggiornato package-lock.json
```

---

### hpm update

Aggiorna i pacchetti alle ultime versioni entro i vincoli.

```bash
hpm update              # Aggiorna tutti i pacchetti
hpm update proprietario/repo   # Aggiorna pacchetto specifico
hpm up proprietario/repo       # Forma breve
```

**Opzioni:**

| Opzione | Descrizione |
|---------|-------------|
| `--verbose` | Mostra progresso dettagliato |
| `--dry-run` | Anteprima senza aggiornare |

**Esempi:**

```bash
# Aggiorna tutti i pacchetti
hpm update

# Aggiorna pacchetto specifico
hpm update hemlang/sprout

# Anteprima aggiornamenti
hpm update --dry-run
```

**Output:**

```
Aggiornamento dipendenze...
  hemlang/sprout: 2.0.0 â†’ 2.1.0
  hemlang/router: 1.4.0 â†’ 1.5.0

Aggiornati 2 pacchetti
```

---

### hpm list

Mostra i pacchetti installati.

```bash
hpm list              # Mostra albero completo delle dipendenze
hpm list --depth=0    # Solo dipendenze dirette
hpm list --depth=1    # Un livello di dipendenze transitive
hpm ls                # Forma breve
```

**Opzioni:**

| Opzione | Descrizione |
|---------|-------------|
| `--depth=N` | Limita profondita albero (default: tutto) |

**Esempi:**

```bash
$ hpm list
mio-progetto@1.0.0
â”œâ”€â”€ hemlang/sprout@2.1.0
â”‚   â”œâ”€â”€ hemlang/router@1.5.0
â”‚   â””â”€â”€ hemlang/middleware@1.2.0
â”œâ”€â”€ hemlang/json@1.2.3
â””â”€â”€ hemlang/test-utils@1.0.0 (dev)

$ hpm list --depth=0
mio-progetto@1.0.0
â”œâ”€â”€ hemlang/sprout@2.1.0
â”œâ”€â”€ hemlang/json@1.2.3
â””â”€â”€ hemlang/test-utils@1.0.0 (dev)
```

---

### hpm outdated

Mostra i pacchetti con versioni piu recenti disponibili.

```bash
hpm outdated
```

**Output:**

```
Pacchetto          Corrente Desiderata Ultima
hemlang/sprout     2.0.0    2.0.5      2.1.0
hemlang/router     1.4.0    1.4.2      1.5.0
```

- **Corrente**: Versione installata
- **Desiderata**: Versione piu alta che soddisfa il vincolo
- **Ultima**: Ultima versione disponibile

---

### hpm run

Esegui uno script da package.json.

```bash
hpm run <script>
hpm run <script> -- <argomenti>
```

**Esempi:**

Dato questo package.json:

```json
{
  "scripts": {
    "start": "hemlock src/index.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/index.hml -o dist/app.hmlc"
  }
}
```

Esegui gli script:

```bash
hpm run start
hpm run test
hpm run build

# Passa argomenti allo script
hpm run test -- --verbose
```

---

### hpm test

Abbreviazione per `hpm run test`.

```bash
hpm test
hpm test -- --verbose
```

Equivalente a:

```bash
hpm run test
```

---

### hpm why

Spiega perche un pacchetto e installato (mostra la catena delle dipendenze).

```bash
hpm why proprietario/repo
```

**Esempio:**

```bash
$ hpm why hemlang/router

hemlang/router@1.5.0 e installato perche:

mio-progetto@1.0.0
â””â”€â”€ hemlang/sprout@2.1.0
    â””â”€â”€ hemlang/router@1.5.0
```

---

### hpm cache

Gestisci la cache globale dei pacchetti.

```bash
hpm cache list    # Elenca pacchetti in cache
hpm cache clean   # Pulisci tutti i pacchetti in cache
```

**Sottocomandi:**

| Sottocomando | Descrizione |
|--------------|-------------|
| `list` | Mostra tutti i pacchetti in cache e le dimensioni |
| `clean` | Rimuovi tutti i pacchetti in cache |

**Esempi:**

```bash
$ hpm cache list
Pacchetti in cache in ~/.hpm/cache:

hemlang/sprout
  2.0.0 (1.2 MB)
  2.1.0 (1.3 MB)
hemlang/router
  1.5.0 (450 KB)

Totale: 2.95 MB

$ hpm cache clean
Cache pulita (2.95 MB liberati)
```

---

## Scorciatoie dei Comandi

Per comodita, diversi comandi hanno alias brevi:

| Comando | Scorciatoie |
|---------|-------------|
| `install` | `i` |
| `uninstall` | `rm`, `remove` |
| `list` | `ls` |
| `update` | `up` |

**Esempi:**

```bash
hpm i hemlang/sprout        # hpm install hemlang/sprout
hpm rm hemlang/sprout       # hpm uninstall hemlang/sprout
hpm ls                      # hpm list
hpm up                      # hpm update
```

---

## Codici di Uscita

hpm usa codici di uscita specifici per indicare diverse condizioni di errore:

| Codice | Significato |
|--------|-------------|
| 0 | Successo |
| 1 | Conflitto di dipendenze |
| 2 | Pacchetto non trovato |
| 3 | Versione non trovata |
| 4 | Errore di rete |
| 5 | package.json non valido |
| 6 | Verifica integrita fallita |
| 7 | Limite di frequenza GitHub superato |
| 8 | Dipendenza circolare |

Usa i codici di uscita negli script:

```bash
hpm install
if [ $? -ne 0 ]; then
    echo "Installazione fallita"
    exit 1
fi
```

---

## Variabili d'Ambiente

hpm rispetta queste variabili d'ambiente:

| Variabile | Descrizione |
|-----------|-------------|
| `GITHUB_TOKEN` | Token API GitHub per autenticazione |
| `HPM_CACHE_DIR` | Sovrascrive la posizione della directory cache |
| `HOME` | Directory home utente (per config/cache) |

**Esempi:**

```bash
# Usa token GitHub per limiti di frequenza piu alti
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Usa directory cache personalizzata
export HPM_CACHE_DIR=/tmp/hpm-cache
hpm install
```

---

## Vedi Anche

- [Configurazione](#hpm-commands-configuration) - File di configurazione
- [Specifiche dei Pacchetti](#hpm-commands-package-spec) - Formato package.json
- [Risoluzione dei Problemi](#hpm-commands-troubleshooting) - Problemi comuni


--------------------------------------------------------------------------------
## Configurazione
--------------------------------------------------------------------------------

# Configurazione

Questa guida copre tutte le opzioni di configurazione per hpm.

## Panoramica

hpm puo essere configurato attraverso:

1. **Variabili d'ambiente** - Per impostazioni runtime
2. **File di configurazione globale** - `~/.hpm/config.json`
3. **File di progetto** - `package.json` e `package-lock.json`

## Variabili d'Ambiente

### GITHUB_TOKEN

Token API GitHub per l'autenticazione.

```bash
export GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx
```

**Vantaggi dell'autenticazione:**
- Limiti di frequenza API piu alti (5000 vs 60 richieste/ora)
- Accesso a repository privati
- Risoluzione delle dipendenze piu veloce

**Creazione di un token:**

1. Vai su GitHub -> Impostazioni -> Impostazioni sviluppatore -> Token di accesso personali
2. Clicca "Genera nuovo token (classico)"
3. Seleziona gli ambiti:
   - `repo` - Per accesso a repository privati
   - `read:packages` - Per GitHub Packages (se usato)
4. Genera e copia il token

### HPM_CACHE_DIR

Sovrascrive la directory cache predefinita.

```bash
export HPM_CACHE_DIR=/percorso/cache/personalizzato
```

Predefinito: `~/.hpm/cache`

**Casi d'uso:**
- Sistemi CI/CD con posizioni cache personalizzate
- Cache condivisa tra progetti
- Cache temporanea per build isolate

### HOME

Directory home dell'utente. Usata per localizzare:
- Directory config: `$HOME/.hpm/`
- Directory cache: `$HOME/.hpm/cache/`

Solitamente impostata dal sistema; sovrascrivere solo se necessario.

### Esempio .bashrc / .zshrc

```bash
# Autenticazione GitHub (consigliata)
export GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx

# Posizione cache personalizzata (opzionale)
# export HPM_CACHE_DIR=/percorso/a/cache

# Aggiungi hpm al PATH (se usi posizione di installazione personalizzata)
export PATH="$HOME/.local/bin:$PATH"
```

## File di Configurazione Globale

### Posizione

`~/.hpm/config.json`

### Formato

```json
{
  "github_token": "ghp_xxxxxxxxxxxxxxxxxxxx"
}
```

### Creazione del File di Configurazione

```bash
# Crea directory di configurazione
mkdir -p ~/.hpm

# Crea file di configurazione
cat > ~/.hpm/config.json << 'EOF'
{
  "github_token": "ghp_il_tuo_token_qui"
}
EOF

# Proteggi il file (consigliato)
chmod 600 ~/.hpm/config.json
```

### Priorita del Token

Se entrambi sono impostati, la variabile d'ambiente ha la precedenza:

1. Variabile d'ambiente `GITHUB_TOKEN` (piu alta)
2. Campo `github_token` in `~/.hpm/config.json`
3. Nessuna autenticazione (default)

## Struttura delle Directory

### Directory Globali

```
~/.hpm/
â”œâ”€â”€ config.json          # Configurazione globale
â””â”€â”€ cache/               # Cache dei pacchetti
    â””â”€â”€ proprietario/
        â””â”€â”€ repo/
            â””â”€â”€ 1.0.0.tar.gz
```

### Directory di Progetto

```
mio-progetto/
â”œâ”€â”€ package.json         # Manifesto del progetto
â”œâ”€â”€ package-lock.json    # File di lock delle dipendenze
â”œâ”€â”€ hem_modules/         # Pacchetti installati
â”‚   â””â”€â”€ proprietario/
â”‚       â””â”€â”€ repo/
â”‚           â”œâ”€â”€ package.json
â”‚           â””â”€â”€ src/
â”œâ”€â”€ src/                 # Codice sorgente
â””â”€â”€ test/                # Test
```

## Cache dei Pacchetti

### Posizione

Predefinita: `~/.hpm/cache/`

Sovrascrivere con: variabile d'ambiente `HPM_CACHE_DIR`

### Struttura

```
~/.hpm/cache/
â”œâ”€â”€ hemlang/
â”‚   â”œâ”€â”€ sprout/
â”‚   â”‚   â”œâ”€â”€ 2.0.0.tar.gz
â”‚   â”‚   â””â”€â”€ 2.1.0.tar.gz
â”‚   â””â”€â”€ router/
â”‚       â””â”€â”€ 1.5.0.tar.gz
â””â”€â”€ alice/
    â””â”€â”€ http-client/
        â””â”€â”€ 1.0.0.tar.gz
```

### Gestione della Cache

```bash
# Visualizza pacchetti in cache
hpm cache list

# Pulisci l'intera cache
hpm cache clean
```

### Comportamento della Cache

- I pacchetti vengono messi in cache dopo il primo download
- Le installazioni successive usano le versioni in cache
- Usa `--offline` per installare solo dalla cache
- La cache e condivisa tra tutti i progetti

## Limiti di Frequenza API GitHub

### Senza Autenticazione

- **60 richieste per ora** per indirizzo IP
- Condiviso tra tutti gli utenti non autenticati sullo stesso IP
- Esaurito rapidamente in CI/CD o con molte dipendenze

### Con Autenticazione

- **5000 richieste per ora** per utente autenticato
- Limite di frequenza personale, non condiviso

### Gestione dei Limiti di Frequenza

hpm automaticamente:
- Riprova con backoff esponenziale (1s, 2s, 4s, 8s)
- Riporta errori di limite di frequenza con codice di uscita 7
- Suggerisce l'autenticazione se viene raggiunto il limite

**Soluzioni quando si raggiunge il limite:**

```bash
# Opzione 1: Autenticarsi con token GitHub
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Opzione 2: Aspettare il reset del limite di frequenza
# (I limiti si resettano ogni ora)

# Opzione 3: Usare la modalita offline (se i pacchetti sono in cache)
hpm install --offline
```

## Modalita Offline

Installa pacchetti senza accesso alla rete:

```bash
hpm install --offline
```

**Requisiti:**
- Tutti i pacchetti devono essere in cache
- Il file di lock deve esistere con versioni esatte

**Casi d'uso:**
- Ambienti air-gapped
- Build CI/CD piu veloci (con cache calda)
- Evitare limiti di frequenza

## Configurazione CI/CD

### GitHub Actions

```yaml
name: CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Configura Hemlock
      run: |
        # Installa Hemlock (adatta in base alla tua configurazione)
        curl -sSL https://hemlock.dev/install.sh | sh

    - name: Cache pacchetti hpm
      uses: actions/cache@v3
      with:
        path: ~/.hpm/cache
        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-hpm-

    - name: Installa dipendenze
      run: hpm install
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Esegui test
      run: hpm test
```

### GitLab CI

```yaml
stages:
  - build
  - test

variables:
  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache

cache:
  paths:
    - .hpm-cache/
  key: $CI_COMMIT_REF_SLUG

build:
  stage: build
  script:
    - hpm install
  artifacts:
    paths:
      - hem_modules/

test:
  stage: test
  script:
    - hpm test
```

### Docker

**Dockerfile:**

```dockerfile
FROM hemlock:latest

WORKDIR /app

# Copia prima i file del pacchetto (per il caching dei layer)
COPY package.json package-lock.json ./

# Installa le dipendenze
RUN hpm install

# Copia il codice sorgente
COPY . .

# Esegui l'applicazione
CMD ["hemlock", "src/main.hml"]
```

**docker-compose.yml:**

```yaml
version: '3.8'

services:
  app:
    build: .
    environment:
      - GITHUB_TOKEN=${GITHUB_TOKEN}
    volumes:
      - hpm-cache:/root/.hpm/cache

volumes:
  hpm-cache:
```

## Configurazione Proxy

Per ambienti dietro un proxy, configura a livello di sistema:

```bash
export HTTP_PROXY=http://proxy.esempio.com:8080
export HTTPS_PROXY=http://proxy.esempio.com:8080
export NO_PROXY=localhost,127.0.0.1

hpm install
```

## Best Practice di Sicurezza

### Sicurezza del Token

1. **Non committare mai token** nel controllo versione
2. **Usa variabili d'ambiente** in CI/CD
3. **Limita gli ambiti del token** al minimo necessario
4. **Ruota i token** regolarmente
5. **Proteggi il file di configurazione**:
   ```bash
   chmod 600 ~/.hpm/config.json
   ```

### Repository Privati

Per accedere a pacchetti privati:

1. Crea token con ambito `repo`
2. Configura l'autenticazione (variabile d'ambiente o file di configurazione)
3. Assicurati che il token abbia accesso al repository

```bash
# Testa l'accesso
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install tuaorg/pacchetto-privato
```

## Risoluzione Problemi di Configurazione

### Verifica Configurazione

```bash
# Controlla se il token e impostato
echo $GITHUB_TOKEN | head -c 10

# Controlla il file di configurazione
cat ~/.hpm/config.json

# Controlla la directory cache
ls -la ~/.hpm/cache/

# Testa con output verboso
hpm install --verbose
```

### Problemi Comuni

**"Limite di frequenza GitHub superato"**
- Configura l'autenticazione con `GITHUB_TOKEN`
- Aspetta il reset del limite di frequenza
- Usa `--offline` se i pacchetti sono in cache

**"Permesso negato" sulla cache**
```bash
# Correggi i permessi della cache
chmod -R u+rw ~/.hpm/cache
```

**"File di configurazione non trovato"**
```bash
# Crea la directory di configurazione
mkdir -p ~/.hpm
touch ~/.hpm/config.json
```

## Vedi Anche

- [Installazione](#hpm-configuration-installation) - Installare hpm
- [Risoluzione dei Problemi](#hpm-configuration-troubleshooting) - Problemi comuni
- [Comandi](#hpm-configuration-commands) - Riferimento comandi


--------------------------------------------------------------------------------
## Risoluzione dei Problemi
--------------------------------------------------------------------------------

# Risoluzione dei Problemi

Soluzioni ai problemi comuni di hpm.

## Problemi di Installazione

### "hemlock: comando non trovato"

**Causa:** Hemlock non e installato o non e nel PATH.

**Soluzione:**

```bash
# Controlla se hemlock esiste
which hemlock

# Se non trovato, installa prima Hemlock
# Visita: https://github.com/hemlang/hemlock

# Dopo l'installazione, verifica
hemlock --version
```

### "hpm: comando non trovato"

**Causa:** hpm non e installato o non e nel PATH.

**Soluzione:**

```bash
# Controlla dove e installato hpm
ls -la /usr/local/bin/hpm
ls -la ~/.local/bin/hpm

# Se usi una posizione personalizzata, aggiungi al PATH
export PATH="$HOME/.local/bin:$PATH"

# Aggiungi a ~/.bashrc o ~/.zshrc per renderlo permanente
echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc

# Reinstalla se necessario
cd /percorso/a/hpm
sudo make install
```

### "Permesso negato" durante l'installazione

**Causa:** Nessun permesso di scrittura nella directory di installazione.

**Soluzione:**

```bash
# Opzione 1: Usa sudo per installazione a livello di sistema
sudo make install

# Opzione 2: Installa nella directory utente (senza sudo)
make install PREFIX=$HOME/.local
```

## Problemi di Dipendenze

### "Pacchetto non trovato" (codice di uscita 2)

**Causa:** Il pacchetto non esiste su GitHub.

**Soluzione:**

```bash
# Verifica che il pacchetto esista
# Controlla: https://github.com/proprietario/repo

# Verifica l'ortografia
hpm install hemlang/sprout  # Corretto
hpm install hemlan/sprout   # Proprietario sbagliato
hpm install hemlang/spout   # Repo sbagliato

# Controlla errori di battitura in package.json
cat package.json | grep -A 5 dependencies
```

### "Versione non trovata" (codice di uscita 3)

**Causa:** Nessuna release corrisponde al vincolo di versione.

**Soluzione:**

```bash
# Elenca le versioni disponibili (controlla release/tag su GitHub)
# I tag devono iniziare con 'v' (es. v1.0.0)

# Usa un vincolo di versione valido
hpm install proprietario/repo@^1.0.0

# Prova l'ultima versione
hpm install proprietario/repo

# Controlla i tag disponibili su GitHub
# https://github.com/proprietario/repo/tags
```

### "Conflitto di dipendenze" (codice di uscita 1)

**Causa:** Due pacchetti richiedono versioni incompatibili di una dipendenza.

**Soluzione:**

```bash
# Vedi il conflitto
hpm install --verbose

# Controlla cosa richiede la dipendenza
hpm why pacchetto/in-conflitto

# Soluzioni:
# 1. Aggiorna il pacchetto in conflitto
hpm update pacchetto/problema

# 2. Cambia i vincoli di versione in package.json
# Modifica per permettere versioni compatibili

# 3. Rimuovi uno dei pacchetti in conflitto
hpm uninstall un/pacchetto
```

### "Dipendenza circolare" (codice di uscita 8)

**Causa:** Il pacchetto A dipende da B, che dipende da A.

**Soluzione:**

```bash
# Identifica il ciclo
hpm install --verbose

# Questo e solitamente un bug nei pacchetti
# Contatta i manutentori dei pacchetti

# Workaround: evita uno dei pacchetti
```

## Problemi di Rete

### "Errore di rete" (codice di uscita 4)

**Causa:** Impossibile connettersi all'API GitHub.

**Soluzione:**

```bash
# Controlla la connessione internet
ping github.com

# Controlla se l'API GitHub e accessibile
curl -I https://api.github.com

# Riprova (hpm riprova automaticamente)
hpm install

# Usa la modalita offline se i pacchetti sono in cache
hpm install --offline

# Controlla le impostazioni proxy se sei dietro un firewall
export HTTPS_PROXY=http://proxy:8080
hpm install
```

### "Limite di frequenza GitHub superato" (codice di uscita 7)

**Causa:** Troppe richieste API senza autenticazione.

**Soluzione:**

```bash
# Opzione 1: Autenticati con token GitHub (consigliato)
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Crea token: GitHub -> Impostazioni -> Impostazioni sviluppatore -> Token di accesso personali

# Opzione 2: Salva il token nel file di configurazione
mkdir -p ~/.hpm
echo '{"github_token": "ghp_xxxxxxxxxxxx"}' > ~/.hpm/config.json

# Opzione 3: Aspetta il reset del limite di frequenza (si resetta ogni ora)

# Opzione 4: Usa la modalita offline
hpm install --offline
```

### Timeout della connessione

**Causa:** Rete lenta o problemi API GitHub.

**Soluzione:**

```bash
# hpm riprova automaticamente con backoff esponenziale

# Controlla se GitHub ha problemi
# Visita: https://www.githubstatus.com

# Riprova piu tardi
hpm install

# Usa i pacchetti in cache
hpm install --offline
```

## Problemi di Package.json

### "package.json non valido" (codice di uscita 5)

**Causa:** Malformato o campi obbligatori mancanti.

**Soluzione:**

```bash
# Valida la sintassi JSON
cat package.json | python -m json.tool

# Controlla i campi obbligatori
cat package.json

# Campi obbligatori:
# - "name": formato proprietario/repo
# - "version": formato X.Y.Z

# Rigenera se necessario
rm package.json
hpm init
```

### Errore formato "name"

**Causa:** Nome pacchetto non nel formato `proprietario/repo`.

**Soluzione:**

```json
// Sbagliato
{
  "name": "mio-pacchetto"
}

// Corretto
{
  "name": "tuonome/mio-pacchetto"
}
```

### Errore formato "version"

**Causa:** Versione non nel formato semver.

**Soluzione:**

```json
// Sbagliato
{
  "version": "1.0"
}

// Corretto
{
  "version": "1.0.0"
}
```

## Problemi del File di Lock

### File di lock non sincronizzato

**Causa:** package.json modificato senza eseguire install.

**Soluzione:**

```bash
# Rigenera il file di lock
rm package-lock.json
hpm install
```

### File di lock corrotto

**Causa:** JSON non valido o modifiche manuali.

**Soluzione:**

```bash
# Controlla validita JSON
cat package-lock.json | python -m json.tool

# Rigenera
rm package-lock.json
hpm install
```

## Problemi di hem_modules

### I pacchetti non si installano

**Causa:** Vari possibili problemi.

**Soluzione:**

```bash
# Pulisci e reinstalla
rm -rf hem_modules
hpm install

# Controlla output verboso
hpm install --verbose
```

### L'import non funziona

**Causa:** Pacchetto non installato correttamente o percorso import sbagliato.

**Soluzione:**

```bash
# Verifica che il pacchetto sia installato
ls hem_modules/proprietario/repo/

# Controlla il campo main di package.json
cat hem_modules/proprietario/repo/package.json

# Formato import corretto
import { x } from "proprietario/repo";          # Usa la voce main
import { y } from "proprietario/repo/sottopercorso";  # Import sottopercorso
```

### Errore "Modulo non trovato"

**Causa:** Il percorso import non si risolve a un file.

**Soluzione:**

```bash
# Controlla il percorso import
ls hem_modules/proprietario/repo/src/

# Controlla index.hml
ls hem_modules/proprietario/repo/src/index.hml

# Verifica il campo main in package.json
cat hem_modules/proprietario/repo/package.json | grep main
```

## Problemi di Cache

### La cache occupa troppo spazio

**Soluzione:**

```bash
# Visualizza dimensione cache
hpm cache list

# Pulisci cache
hpm cache clean
```

### Permessi cache

**Soluzione:**

```bash
# Correggi permessi
chmod -R u+rw ~/.hpm/cache

# Oppure rimuovi e reinstalla
rm -rf ~/.hpm/cache
hpm install
```

### Usa cache sbagliata

**Soluzione:**

```bash
# Controlla posizione cache
echo $HPM_CACHE_DIR
ls ~/.hpm/cache

# Pulisci variabile d'ambiente se non corretta
unset HPM_CACHE_DIR
```

## Problemi di Script

### "Script non trovato"

**Causa:** Il nome dello script non esiste in package.json.

**Soluzione:**

```bash
# Elenca script disponibili
cat package.json | grep -A 20 scripts

# Controlla l'ortografia
hpm run test    # Corretto
hpm run tests   # Sbagliato se lo script si chiama "test"
```

### Lo script fallisce

**Causa:** Errore nel comando dello script.

**Soluzione:**

```bash
# Esegui il comando direttamente per vedere l'errore
hemlock test/run.hml

# Controlla la definizione dello script
cat package.json | grep test
```

## Debug

### Abilita output verboso

```bash
hpm install --verbose
```

### Controlla versione hpm

```bash
hpm --version
```

### Controlla versione hemlock

```bash
hemlock --version
```

### Dry run

Anteprima senza apportare modifiche:

```bash
hpm install --dry-run
```

### Ripartire da zero

Ricomincia da capo:

```bash
rm -rf hem_modules package-lock.json
hpm install
```

## Ottenere Aiuto

### Aiuto comandi

```bash
hpm --help
hpm install --help
```

### Segnalare problemi

Se incontri un bug:

1. Controlla i problemi esistenti: https://github.com/hemlang/hpm/issues
2. Crea un nuovo problema con:
   - Versione hpm (`hpm --version`)
   - Versione Hemlock (`hemlock --version`)
   - Sistema operativo
   - Passi per riprodurre
   - Messaggio di errore (usa `--verbose`)

## Riferimento Codici di Uscita

| Codice | Significato | Soluzione Comune |
|--------|-------------|------------------|
| 0 | Successo | - |
| 1 | Conflitto di dipendenze | Aggiorna o cambia i vincoli |
| 2 | Pacchetto non trovato | Controlla ortografia, verifica che il repo esista |
| 3 | Versione non trovata | Controlla versioni disponibili su GitHub |
| 4 | Errore di rete | Controlla connessione, riprova |
| 5 | package.json non valido | Correggi sintassi JSON e campi obbligatori |
| 6 | Verifica integrita fallita | Pulisci cache, reinstalla |
| 7 | Limite frequenza GitHub | Aggiungi GITHUB_TOKEN |
| 8 | Dipendenza circolare | Contatta i manutentori dei pacchetti |

## Vedi Anche

- [Installazione](#hpm-troubleshooting-installation) - Guida all'installazione
- [Configurazione](#hpm-troubleshooting-configuration) - Opzioni di configurazione
- [Comandi](#hpm-troubleshooting-commands) - Riferimento comandi



################################################################################
# HPM: SVILUPPO PACCHETTI
################################################################################

--------------------------------------------------------------------------------
## Creazione di Pacchetti
--------------------------------------------------------------------------------

# Creazione di Pacchetti

Questa guida spiega come creare, strutturare e pubblicare pacchetti Hemlock.

## Panoramica

hpm usa GitHub come suo registro di pacchetti. I pacchetti sono identificati dal loro percorso GitHub `proprietario/repo`, e le versioni sono tag Git. Pubblicare significa semplicemente pushare una release taggata.

## Creazione di un Nuovo Pacchetto

### 1. Inizializza il Pacchetto

Crea una nuova directory e inizializza:

```bash
mkdir mio-pacchetto
cd mio-pacchetto
hpm init
```

Rispondi ai prompt:

```
Nome pacchetto (proprietario/repo): tuonome/mio-pacchetto
Versione (1.0.0):
Descrizione: Un utile pacchetto Hemlock
Autore: Il Tuo Nome <tu@esempio.com>
Licenza (MIT):
File principale (src/index.hml):

Creato package.json
```

### 2. Crea la Struttura del Progetto

Struttura consigliata per i pacchetti:

```
mio-pacchetto/
â”œâ”€â”€ package.json          # Manifesto del pacchetto
â”œâ”€â”€ README.md             # Documentazione
â”œâ”€â”€ LICENSE               # File di licenza
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.hml         # Punto di ingresso principale (esporta API pubblica)
â”‚   â”œâ”€â”€ utils.hml         # Utilita interne
â”‚   â””â”€â”€ types.hml         # Definizioni dei tipi
â””â”€â”€ test/
    â”œâ”€â”€ framework.hml     # Framework di test
    â””â”€â”€ test_utils.hml    # Test
```

### 3. Definisci la Tua API Pubblica

**src/index.hml** - Punto di ingresso principale:

```hemlock
// Riesporta API pubblica
export { parse, stringify } from "./parser.hml";
export { Config, Options } from "./types.hml";
export { process } from "./processor.hml";

// Export diretti
export fn create(options: Options): Config {
    // Implementazione
}

export fn validate(config: Config): bool {
    // Implementazione
}
```

### 4. Scrivi il Tuo package.json

Esempio completo di package.json:

```json
{
  "name": "tuonome/mio-pacchetto",
  "version": "1.0.0",
  "description": "Un utile pacchetto Hemlock",
  "author": "Il Tuo Nome <tu@esempio.com>",
  "license": "MIT",
  "repository": "https://github.com/tuonome/mio-pacchetto",
  "main": "src/index.hml",
  "dependencies": {
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  },
  "scripts": {
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/index.hml -o dist/bundle.hmlc"
  },
  "keywords": ["utilita", "parser", "config"],
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ]
}
```

## Denominazione dei Pacchetti

### Requisiti

- Deve essere nel formato `proprietario/repo`
- `proprietario` dovrebbe essere il tuo username o organizzazione GitHub
- `repo` dovrebbe essere il nome del repository
- Usa minuscole con trattini per nomi composti

### Nomi Validi

```
hemlang/sprout
alice/http-client
miaorg/json-utils
bob/date-formatter
```

### Da Evitare

```
mio-pacchetto          # Manca il proprietario
alice/MioPacchetto     # PascalCase
alice/mio_pacchetto    # Underscore
```

## Best Practice per la Struttura del Pacchetto

### Punto di Ingresso

Il campo `main` in package.json specifica il punto di ingresso:

```json
{
  "main": "src/index.hml"
}
```

Questo file dovrebbe esportare la tua API pubblica:

```hemlock
// Esporta tutto cio di cui gli utenti hanno bisogno
export { Parser, parse } from "./parser.hml";
export { Formatter, format } from "./formatter.hml";

// Tipi
export type { Config, Options } from "./types.hml";
```

### Interno vs Pubblico

Mantieni i dettagli di implementazione interni privati:

```
src/
â”œâ”€â”€ index.hml          # Pubblico: API esportata
â”œâ”€â”€ parser.hml         # Pubblico: usato da index.hml
â”œâ”€â”€ formatter.hml      # Pubblico: usato da index.hml
â””â”€â”€ internal/
    â”œâ”€â”€ helpers.hml    # Privato: solo uso interno
    â””â”€â”€ constants.hml  # Privato: solo uso interno
```

Gli utenti importano dalla root del tuo pacchetto:

```hemlock
// Buono - importa dall'API pubblica
import { parse, Parser } from "tuonome/mio-pacchetto";

// Funziona anche - import da sottopercorso
import { validate } from "tuonome/mio-pacchetto/validator";

// Sconsigliato - accesso agli interni
import { helper } from "tuonome/mio-pacchetto/internal/helpers";
```

### Export da Sottopercorso

Supporta l'import da sottopercorsi:

```
src/
â”œâ”€â”€ index.hml              # Ingresso principale
â”œâ”€â”€ parser/
â”‚   â””â”€â”€ index.hml          # tuonome/pkg/parser
â”œâ”€â”€ formatter/
â”‚   â””â”€â”€ index.hml          # tuonome/pkg/formatter
â””â”€â”€ utils/
    â””â”€â”€ index.hml          # tuonome/pkg/utils
```

Gli utenti possono importare:

```hemlock
import { parse } from "tuonome/mio-pacchetto";           # Principale
import { Parser } from "tuonome/mio-pacchetto/parser";   # Sottopercorso
import { format } from "tuonome/mio-pacchetto/formatter";
```

## Dipendenze

### Aggiungere Dipendenze

```bash
# Dipendenza runtime
hpm install hemlang/json

# Dipendenza di sviluppo
hpm install hemlang/test-utils --dev
```

### Best Practice per le Dipendenze

1. **Usa range caret** per la maggior parte delle dipendenze:
   ```json
   {
     "dependencies": {
       "hemlang/json": "^1.0.0"
     }
   }
   ```

2. **Fissa le versioni** solo quando necessario (instabilita API):
   ```json
   {
     "dependencies": {
       "instabile/lib": "1.2.3"
     }
   }
   ```

3. **Evita range troppo restrittivi**:
   ```json
   // Male: troppo restrittivo
   "hemlang/json": ">=1.2.3 <1.2.5"

   // Bene: permette aggiornamenti compatibili
   "hemlang/json": "^1.2.3"
   ```

4. **Separa le dipendenze di sviluppo**:
   ```json
   {
     "dependencies": {
       "hemlang/json": "^1.0.0"
     },
     "devDependencies": {
       "hemlang/test-utils": "^1.0.0"
     }
   }
   ```

## Test del Pacchetto

### Scrivi i Test

**test/run.hml:**

```hemlock
import { suite, test, assert_eq } from "./framework.hml";
import { parse, stringify } from "../src/index.hml";

fn esegui_test() {
    suite("Parser", fn() {
        test("analizza input valido", fn() {
            let risultato = parse("ciao");
            assert_eq(risultato.value, "ciao");
        });

        test("gestisce input vuoto", fn() {
            let risultato = parse("");
            assert_eq(risultato.value, "");
        });
    });

    suite("Stringify", fn() {
        test("converte oggetto in stringa", fn() {
            let obj = { nome: "test" };
            let risultato = stringify(obj);
            assert_eq(risultato, '{"nome":"test"}');
        });
    });
}

esegui_test();
```

### Esegui i Test

Aggiungi uno script di test:

```json
{
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
```

Esegui con:

```bash
hpm test
```

## Pubblicazione

### Prerequisiti

1. Crea un repository GitHub corrispondente al nome del tuo pacchetto
2. Assicurati che `package.json` sia completo e valido
3. Tutti i test passano

### Processo di Pubblicazione

Pubblicare significa semplicemente pushare un tag Git:

```bash
# 1. Assicurati che tutto sia committato
git add .
git commit -m "Prepara release v1.0.0"

# 2. Crea un tag versione (deve iniziare con 'v')
git tag v1.0.0

# 3. Pusha codice e tag
git push origin main
git push origin v1.0.0
# Oppure pusha tutti i tag insieme
git push origin main --tags
```

### Tag di Versione

I tag devono seguire il formato `vX.Y.Z`:

```bash
git tag v1.0.0      # Release
git tag v1.0.1      # Patch
git tag v1.1.0      # Minor
git tag v2.0.0      # Major
git tag v1.0.0-beta.1  # Pre-release
```

### Checklist per la Release

Prima di pubblicare una nuova versione:

1. **Aggiorna la versione** in package.json
2. **Esegui i test**: `hpm test`
3. **Aggiorna il CHANGELOG** (se ne hai uno)
4. **Aggiorna il README** se l'API e cambiata
5. **Committa le modifiche**
6. **Crea il tag**
7. **Pusha su GitHub**

### Esempio Automatizzato

Crea uno script di release:

```bash
#!/bin/bash
# release.sh - Rilascia una nuova versione

VERSION=$1

if [ -z "$VERSION" ]; then
    echo "Uso: ./release.sh 1.0.0"
    exit 1
fi

# Esegui i test
hpm test || exit 1

# Aggiorna la versione in package.json
sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json

# Committa e tagga
git add package.json
git commit -m "Release v$VERSION"
git tag "v$VERSION"

# Pusha
git push origin main --tags

echo "Rilasciata v$VERSION"
```

## Utenti che Installano il Tuo Pacchetto

Dopo la pubblicazione, gli utenti possono installare:

```bash
# Ultima versione
hpm install tuonome/mio-pacchetto

# Versione specifica
hpm install tuonome/mio-pacchetto@1.0.0

# Vincolo di versione
hpm install tuonome/mio-pacchetto@^1.0.0
```

E importare:

```hemlock
import { parse, stringify } from "tuonome/mio-pacchetto";
```

## Documentazione

### README.md

Ogni pacchetto dovrebbe avere un README:

```markdown
# mio-pacchetto

Una breve descrizione di cosa fa questo pacchetto.

## Installazione

\`\`\`bash
hpm install tuonome/mio-pacchetto
\`\`\`

## Utilizzo

\`\`\`hemlock
import { parse } from "tuonome/mio-pacchetto";

let risultato = parse("input");
\`\`\`

## API

### parse(input: string): Result

Analizza la stringa di input.

### stringify(obj: any): string

Converte l'oggetto in stringa.

## Licenza

MIT
```

### Documentazione API

Documenta tutti gli export pubblici:

```hemlock
/// Analizza la stringa di input in un Result strutturato.
///
/// # Argomenti
/// * `input` - La stringa da analizzare
///
/// # Ritorna
/// Un Result contenente i dati analizzati o un errore
///
/// # Esempio
/// ```
/// let risultato = parse("ciao mondo");
/// print(risultato.value);
/// ```
export fn parse(input: string): Result {
    // Implementazione
}
```

## Linee Guida per il Versionamento

Segui il [Versionamento Semantico](https://semver.org/):

- **MAJOR** (1.0.0 -> 2.0.0): Modifiche incompatibili
- **MINOR** (1.0.0 -> 1.1.0): Nuove funzionalita, retrocompatibili
- **PATCH** (1.0.0 -> 1.0.1): Correzioni bug, retrocompatibili

### Quando Incrementare

| Tipo di Modifica | Incremento Versione |
|------------------|---------------------|
| Modifica API incompatibile | MAJOR |
| Rimozione funzione/tipo | MAJOR |
| Cambio firma funzione | MAJOR |
| Aggiunta nuova funzione | MINOR |
| Aggiunta nuova funzionalita | MINOR |
| Correzione bug | PATCH |
| Aggiornamento documentazione | PATCH |
| Refactoring interno | PATCH |

## Vedi Anche

- [Specifiche dei Pacchetti](#hpm-creating-packages-package-spec) - Riferimento completo package.json
- [Versionamento](#hpm-creating-packages-versioning) - Dettagli versionamento semantico
- [Configurazione](#hpm-creating-packages-configuration) - Autenticazione GitHub


--------------------------------------------------------------------------------
## Specifiche dei Pacchetti
--------------------------------------------------------------------------------

# Specifiche dei Pacchetti

Riferimento completo per il formato del file `package.json`.

## Panoramica

Ogni pacchetto hpm richiede un file `package.json` nella root del progetto. Questo file definisce i metadati del pacchetto, le dipendenze e gli script.

## Esempio Minimo

```json
{
  "name": "proprietario/repo",
  "version": "1.0.0"
}
```

## Esempio Completo

```json
{
  "name": "hemlang/pacchetto-esempio",
  "version": "1.2.3",
  "description": "Un pacchetto Hemlock di esempio",
  "author": "Team Hemlock <team@hemlock.dev>",
  "license": "MIT",
  "repository": "https://github.com/hemlang/pacchetto-esempio",
  "homepage": "https://hemlang.github.io/pacchetto-esempio",
  "bugs": "https://github.com/hemlang/pacchetto-esempio/issues",
  "main": "src/index.hml",
  "keywords": ["esempio", "utilita", "hemlock"],
  "dependencies": {
    "hemlang/json": "^1.0.0",
    "hemlang/http": "^2.1.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  },
  "scripts": {
    "start": "hemlock src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/bundle.hmlc"
  },
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ],
  "native": {
    "requires": ["libcurl", "openssl"]
  }
}
```

## Riferimento Campi

### name (obbligatorio)

Il nome del pacchetto nel formato `proprietario/repo`.

```json
{
  "name": "hemlang/sprout"
}
```

**Requisiti:**
- Deve essere nel formato `proprietario/repo`
- `proprietario` dovrebbe essere il tuo username o organizzazione GitHub
- `repo` dovrebbe essere il nome del repository
- Usa lettere minuscole, numeri e trattini
- Massimo 214 caratteri totali

**Nomi validi:**
```
hemlang/sprout
alice/http-client
miaorg/json-utils
bob123/mia-lib
```

**Nomi non validi:**
```
mio-pacchetto          # Manca il proprietario
hemlang/Mio_Pacchetto  # Maiuscole e underscore
hemlang                # Manca il repo
```

### version (obbligatorio)

La versione del pacchetto seguendo il [Versionamento Semantico](https://semver.org/).

```json
{
  "version": "1.2.3"
}
```

**Formato:** `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`

**Versioni valide:**
```
1.0.0
2.1.3
1.0.0-alpha
1.0.0-beta.1
1.0.0-rc.1+build.123
0.1.0
```

### description

Breve descrizione del pacchetto.

```json
{
  "description": "Un parser JSON veloce per Hemlock"
}
```

- Mantienila sotto i 200 caratteri
- Descrivi cosa fa il pacchetto, non come

### author

Informazioni sull'autore del pacchetto.

```json
{
  "author": "Il Tuo Nome <email@esempio.com>"
}
```

**Formati accettati:**
```json
"author": "Il Tuo Nome"
"author": "Il Tuo Nome <email@esempio.com>"
"author": "Il Tuo Nome <email@esempio.com> (https://sitoweb.com)"
```

### license

L'identificatore della licenza.

```json
{
  "license": "MIT"
}
```

**Licenze comuni:**
- `MIT` - Licenza MIT
- `Apache-2.0` - Licenza Apache 2.0
- `GPL-3.0` - GNU General Public License v3.0
- `BSD-3-Clause` - Licenza BSD 3-Clause
- `ISC` - Licenza ISC
- `UNLICENSED` - Proprietario/privato

Usa gli [identificatori SPDX](https://spdx.org/licenses/) quando possibile.

### repository

Link al repository sorgente.

```json
{
  "repository": "https://github.com/hemlang/sprout"
}
```

### homepage

URL della homepage del progetto.

```json
{
  "homepage": "https://sprout.hemlock.dev"
}
```

### bugs

URL del tracker dei problemi.

```json
{
  "bugs": "https://github.com/hemlang/sprout/issues"
}
```

### main

File punto di ingresso per il pacchetto.

```json
{
  "main": "src/index.hml"
}
```

**Predefinito:** `src/index.hml`

Quando gli utenti importano il tuo pacchetto:
```hemlock
import { x } from "proprietario/repo";
```

hpm carica il file specificato in `main`.

**Ordine di risoluzione per le import:**
1. Percorso esatto: `src/index.hml`
2. Con estensione .hml: `src/index` -> `src/index.hml`
3. File index: `src/index/` -> `src/index/index.hml`

### keywords

Array di parole chiave per la scoperta.

```json
{
  "keywords": ["json", "parser", "utilita", "hemlock"]
}
```

- Usa minuscole
- Sii specifico e rilevante
- Includi il linguaggio ("hemlock") se appropriato

### dependencies

Dipendenze runtime richieste per il funzionamento del pacchetto.

```json
{
  "dependencies": {
    "hemlang/json": "^1.0.0",
    "hemlang/http": "~2.1.0",
    "alice/logger": ">=1.0.0 <2.0.0"
  }
}
```

**Chiave:** Nome del pacchetto (`proprietario/repo`)
**Valore:** Vincolo di versione

**Sintassi vincoli di versione:**

| Vincolo | Significato |
|---------|-------------|
| `1.2.3` | Versione esatta |
| `^1.2.3` | >=1.2.3 <2.0.0 |
| `~1.2.3` | >=1.2.3 <1.3.0 |
| `>=1.0.0` | Almeno 1.0.0 |
| `>=1.0.0 <2.0.0` | Range |
| `*` | Qualsiasi versione |

### devDependencies

Dipendenze solo per lo sviluppo (test, build, ecc.).

```json
{
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0",
    "hemlang/linter": "^2.0.0"
  }
}
```

Le dipendenze di sviluppo sono:
- Installate durante lo sviluppo
- Non installate quando il pacchetto e usato come dipendenza
- Usate per test, build, linting, ecc.

### scripts

Comandi denominati che possono essere eseguiti con `hpm run`.

```json
{
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "test:unit": "hemlock test/unit/run.hml",
    "test:integration": "hemlock test/integration/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc",
    "clean": "rm -rf dist hem_modules",
    "lint": "hemlock-lint src/",
    "format": "hemlock-fmt src/"
  }
}
```

**Esecuzione degli script:**
```bash
hpm run start
hpm run build
hpm test        # Abbreviazione per 'hpm run test'
```

**Passare argomenti:**
```bash
hpm run test -- --verbose --filter=unit
```

**Script comuni:**

| Script | Scopo |
|--------|-------|
| `start` | Avvia l'applicazione |
| `dev` | Modalita sviluppo con hot reload |
| `test` | Esegui i test |
| `build` | Build per produzione |
| `clean` | Rimuovi artefatti di build |
| `lint` | Controlla stile codice |
| `format` | Formatta il codice |

### files

File e directory da includere quando il pacchetto viene installato.

```json
{
  "files": [
    "src/",
    "lib/",
    "LICENSE",
    "README.md"
  ]
}
```

**Comportamento predefinito:** Se non specificato, include:
- Tutti i file nel repository
- Esclude `.git/`, `node_modules/`, `hem_modules/`

**Usa per:**
- Ridurre la dimensione del pacchetto
- Escludere file di test dalla distribuzione
- Includere solo i file necessari

### native

Requisiti di librerie native.

```json
{
  "native": {
    "requires": ["libcurl", "openssl", "sqlite3"]
  }
}
```

Documenta le dipendenze native che devono essere installate sul sistema.

## Validazione

hpm valida package.json in varie operazioni. Errori di validazione comuni:

### Campi obbligatori mancanti

```
Errore: package.json manca del campo obbligatorio: name
```

**Soluzione:** Aggiungi il campo obbligatorio.

### Formato nome non valido

```
Errore: Nome pacchetto non valido. Deve essere nel formato proprietario/repo.
```

**Soluzione:** Usa il formato `proprietario/repo`.

### Versione non valida

```
Errore: Versione non valida "1.0". Deve essere in formato semver (X.Y.Z).
```

**Soluzione:** Usa il formato semver completo (`1.0.0`).

### JSON non valido

```
Errore: package.json non e un JSON valido
```

**Soluzione:** Controlla la sintassi JSON (virgole, virgolette, parentesi).

## Creazione di package.json

### Interattivo

```bash
hpm init
```

Richiede ogni campo interattivamente.

### Con Valori Predefiniti

```bash
hpm init --yes
```

Crea con valori predefiniti:
```json
{
  "name": "nome-directory/nome-directory",
  "version": "1.0.0",
  "description": "",
  "author": "",
  "license": "MIT",
  "main": "src/index.hml",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
```

### Manuale

Crea il file manualmente:

```bash
cat > package.json << 'EOF'
{
  "name": "tuonome/tuo-pacchetto",
  "version": "1.0.0",
  "description": "Descrizione del tuo pacchetto",
  "main": "src/index.hml",
  "dependencies": {},
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
EOF
```

## Best Practice

1. **Specifica sempre main** - Non affidarti al default
2. **Usa range caret** - `^1.0.0` per la maggior parte delle dipendenze
3. **Separa le dipendenze di sviluppo** - Mantieni le dipendenze test/build in devDependencies
4. **Includi keywords** - Aiuta gli utenti a trovare il tuo pacchetto
5. **Documenta gli script** - Dai nomi chiari agli script
6. **Specifica la licenza** - Obbligatorio per open source
7. **Aggiungi descrizione** - Aiuta gli utenti a capire lo scopo

## Vedi Anche

- [Creazione di Pacchetti](#hpm-package-spec-creating-packages) - Guida alla pubblicazione
- [Versionamento](#hpm-package-spec-versioning) - Vincoli di versione
- [Configurazione del Progetto](#hpm-package-spec-project-setup) - Struttura del progetto


--------------------------------------------------------------------------------
## Versionamento
--------------------------------------------------------------------------------

# Versionamento

Guida completa al versionamento semantico in hpm.

## Versionamento Semantico

hpm usa il [Versionamento Semantico 2.0.0](https://semver.org/) (semver) per le versioni dei pacchetti.

### Formato della Versione

```
MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]
```

**Esempi:**
```
1.0.0           # Versione di release
2.1.3           # Versione di release
1.0.0-alpha     # Pre-release
1.0.0-beta.1    # Pre-release con numero
1.0.0-rc.1      # Release candidate
1.0.0+20231201  # Con metadati di build
1.0.0-beta+exp  # Pre-release con metadati di build
```

### Componenti della Versione

| Componente | Descrizione | Esempio |
|------------|-------------|---------|
| MAJOR | Modifiche incompatibili | `1.0.0` -> `2.0.0` |
| MINOR | Nuove funzionalita (retrocompatibili) | `1.0.0` -> `1.1.0` |
| PATCH | Correzioni bug (retrocompatibili) | `1.0.0` -> `1.0.1` |
| PRERELEASE | Identificatore pre-release | `1.0.0-alpha` |
| BUILD | Metadati di build (ignorati nel confronto) | `1.0.0+build123` |

### Quando Incrementare

| Tipo di Modifica | Incremento | Esempio |
|------------------|------------|---------|
| Modifica API incompatibile | MAJOR | Rimuovere una funzione |
| Rinominare funzione pubblica | MAJOR | `parse()` -> `decode()` |
| Cambiare firma funzione | MAJOR | Aggiungere parametro obbligatorio |
| Aggiungere nuova funzione | MINOR | Aggiungere `validate()` |
| Aggiungere parametro opzionale | MINOR | Nuovo argomento `options` opzionale |
| Correzione bug | PATCH | Correggere puntatore nullo |
| Miglioramento prestazioni | PATCH | Algoritmo piu veloce |
| Refactoring interno | PATCH | Nessun cambio API |

## Vincoli di Versione

### Sintassi dei Vincoli

| Sintassi | Significato | Si risolve in |
|----------|-------------|---------------|
| `1.2.3` | Versione esatta | Solo 1.2.3 |
| `^1.2.3` | Caret (compatibile) | >=1.2.3 e <2.0.0 |
| `~1.2.3` | Tilde (aggiornamenti patch) | >=1.2.3 e <1.3.0 |
| `>=1.0.0` | Almeno | 1.0.0 o superiore |
| `>1.0.0` | Maggiore di | Superiore a 1.0.0 |
| `<2.0.0` | Minore di | Inferiore a 2.0.0 |
| `<=2.0.0` | Al massimo | 2.0.0 o inferiore |
| `>=1.0.0 <2.0.0` | Range | Tra 1.0.0 e 2.0.0 |
| `*` | Qualsiasi | Qualsiasi versione |

### Range Caret (^)

Il caret (`^`) permette modifiche che non alterano la cifra non-zero piu a sinistra:

```
^1.2.3  ->  >=1.2.3 <2.0.0   # Permette 1.x.x
^0.2.3  ->  >=0.2.3 <0.3.0   # Permette 0.2.x
^0.0.3  ->  >=0.0.3 <0.0.4   # Permette solo 0.0.3
```

**Usa quando:** Vuoi aggiornamenti compatibili entro una versione major.

**Vincolo piu comune** - consigliato per la maggior parte delle dipendenze.

### Range Tilde (~)

Il tilde (`~`) permette solo modifiche a livello patch:

```
~1.2.3  ->  >=1.2.3 <1.3.0   # Permette 1.2.x
~1.2    ->  >=1.2.0 <1.3.0   # Permette 1.2.x
~1      ->  >=1.0.0 <2.0.0   # Permette 1.x.x
```

**Usa quando:** Vuoi solo correzioni bug, nessuna nuova funzionalita.

### Range di Confronto

Combina operatori di confronto per un controllo preciso:

```json
{
  "dependencies": {
    "proprietario/pkg": ">=1.0.0 <2.0.0",
    "proprietario/altro": ">1.5.0 <=2.1.0"
  }
}
```

### Qualsiasi Versione (*)

Corrisponde a qualsiasi versione:

```json
{
  "dependencies": {
    "proprietario/pkg": "*"
  }
}
```

**Attenzione:** Non consigliato per produzione. Prendera sempre l'ultima versione.

## Versioni Pre-release

### Identificatori Pre-release

Le pre-release hanno precedenza inferiore rispetto alle release:

```
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0
```

### Tag Pre-release Comuni

| Tag | Significato | Fase |
|-----|-------------|------|
| `alpha` | Sviluppo iniziale | Molto instabile |
| `beta` | Funzionalita complete | Test |
| `rc` | Release candidate | Test finali |
| `dev` | Snapshot di sviluppo | Instabile |

### Pre-release nei Vincoli

I vincoli non corrispondono alle pre-release per default:

```
^1.0.0    # NON corrisponde a 1.1.0-beta
>=1.0.0   # NON corrisponde a 2.0.0-alpha
```

Per includere le pre-release, referenziale esplicitamente:

```
>=1.0.0-alpha <2.0.0   # Include tutte le pre-release 1.x
```

## Confronto delle Versioni

### Regole di Confronto

1. Confronta MAJOR, MINOR, PATCH numericamente
2. Release > pre-release con stessa versione
3. Pre-release confrontate alfanumericamente
4. Metadati di build ignorati

### Esempi

```
1.0.0 < 1.0.1 < 1.1.0 < 2.0.0

1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0

1.0.0 = 1.0.0+build123  # Metadati di build ignorati
```

### Ordinamento

Le versioni si ordinano in modo ascendente:

```
1.0.0
1.0.1
1.1.0
1.1.1
2.0.0-alpha
2.0.0-beta
2.0.0
```

## Risoluzione delle Versioni

### Algoritmo di Risoluzione

Quando piu pacchetti richiedono la stessa dipendenza:

1. Raccogli tutti i vincoli
2. Trova l'intersezione di tutti i range
3. Seleziona la versione piu alta nell'intersezione
4. Errore se nessuna versione soddisfa tutti

### Esempio di Risoluzione

```
pacchetto-a richiede hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)
pacchetto-b richiede hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)

Intersezione: >=1.2.0 <1.3.0
Disponibili: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]
Risolto: 1.2.5 (piu alta nell'intersezione)
```

### Rilevamento Conflitti

Il conflitto si verifica quando nessuna versione soddisfa tutti i vincoli:

```
pacchetto-a richiede hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)
pacchetto-b richiede hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)

Intersezione: (vuota)
Risultato: CONFLITTO - nessuna versione soddisfa entrambi
```

## Best Practice

### Per i Consumatori di Pacchetti

1. **Usa range caret** per la maggior parte delle dipendenze:
   ```json
   "hemlang/json": "^1.2.0"
   ```

2. **Usa range tilde** per dipendenze critiche:
   ```json
   "critico/lib": "~1.2.0"
   ```

3. **Fissa le versioni** solo quando necessario:
   ```json
   "instabile/pkg": "1.2.3"
   ```

4. **Committa il tuo file di lock** per build riproducibili

5. **Aggiorna regolarmente** per ottenere correzioni di sicurezza:
   ```bash
   hpm update
   hpm outdated
   ```

### Per gli Autori di Pacchetti

1. **Inizia da 0.1.0** per lo sviluppo iniziale:
   - L'API puo cambiare frequentemente
   - Gli utenti si aspettano instabilita

2. **Vai a 1.0.0** quando l'API e stabile:
   - Impegno pubblico alla stabilita
   - Le modifiche incompatibili richiedono bump major

3. **Segui rigorosamente semver**:
   - Modifica incompatibile = MAJOR
   - Nuova funzionalita = MINOR
   - Correzione bug = PATCH

4. **Usa pre-release** per i test:
   ```bash
   git tag v2.0.0-beta.1
   git push --tags
   ```

5. **Documenta le modifiche incompatibili** nel CHANGELOG

## Pubblicazione delle Versioni

### Creazione delle Release

```bash
# Aggiorna la versione in package.json
# Modifica package.json: "version": "1.1.0"

# Committa la modifica della versione
git add package.json
git commit -m "Bump versione a 1.1.0"

# Crea e pusha il tag
git tag v1.1.0
git push origin main --tags
```

### Formato del Tag

I tag **devono** iniziare con `v`:

```
v1.0.0      Corretto
v1.0.0-beta Corretto
1.0.0       Non verra riconosciuto
```

### Flusso di Lavoro per la Release

```bash
# 1. Assicurati che i test passino
hpm test

# 2. Aggiorna la versione in package.json
# 3. Aggiorna CHANGELOG.md
# 4. Committa le modifiche
git add -A
git commit -m "Release v1.2.0"

# 5. Crea il tag
git tag v1.2.0

# 6. Pusha tutto
git push origin main --tags
```

## Verifica delle Versioni

### Elenca le Versioni Installate

```bash
hpm list
```

### Controlla gli Aggiornamenti

```bash
hpm outdated
```

Output:
```
Pacchetto       Corrente Desiderata Ultima
hemlang/json    1.0.0    1.0.5      1.2.0
hemlang/sprout  2.0.0    2.0.3      2.1.0
```

- **Corrente**: Versione installata
- **Desiderata**: Piu alta che corrisponde al vincolo
- **Ultima**: Ultima disponibile

### Aggiorna i Pacchetti

```bash
# Aggiorna tutti
hpm update

# Aggiorna pacchetto specifico
hpm update hemlang/json
```

## Vedi Anche

- [Creazione di Pacchetti](#hpm-versioning-creating-packages) - Guida alla pubblicazione
- [Specifiche dei Pacchetti](#hpm-versioning-package-spec) - Formato package.json
- [Comandi](#hpm-versioning-commands) - Riferimento CLI



################################################################################
# HPM: RIFERIMENTO
################################################################################

--------------------------------------------------------------------------------
## Architettura
--------------------------------------------------------------------------------

# Architettura

Architettura interna e design di hpm. Questo documento e per i contributori e per chi e interessato a capire come funziona hpm.

## Panoramica

hpm e scritto in Hemlock e consiste di diversi moduli che gestiscono diversi aspetti della gestione dei pacchetti:

```
src/
â”œâ”€â”€ main.hml        # Punto di ingresso CLI e routing dei comandi
â”œâ”€â”€ manifest.hml    # Gestione package.json
â”œâ”€â”€ lockfile.hml    # Gestione package-lock.json
â”œâ”€â”€ semver.hml      # Versionamento semantico
â”œâ”€â”€ resolver.hml    # Risoluzione delle dipendenze
â”œâ”€â”€ github.hml      # Client API GitHub
â”œâ”€â”€ installer.hml   # Download ed estrazione dei pacchetti
â””â”€â”€ cache.hml       # Gestione cache globale
```

## Responsabilita dei Moduli

### main.hml

Il punto di ingresso per l'applicazione CLI.

**Responsabilita:**
- Analizzare gli argomenti da riga di comando
- Instradare i comandi ai gestori appropriati
- Visualizzare aiuto e informazioni sulla versione
- Gestire flag globali (--verbose, --dry-run, ecc.)
- Uscire con codici appropriati

**Funzioni principali:**
- `main()` - Punto di ingresso, analizza args e smista comandi
- `cmd_init()` - Gestisce `hpm init`
- `cmd_install()` - Gestisce `hpm install`
- `cmd_uninstall()` - Gestisce `hpm uninstall`
- `cmd_update()` - Gestisce `hpm update`
- `cmd_list()` - Gestisce `hpm list`
- `cmd_outdated()` - Gestisce `hpm outdated`
- `cmd_run()` - Gestisce `hpm run`
- `cmd_why()` - Gestisce `hpm why`
- `cmd_cache()` - Gestisce `hpm cache`

**Scorciatoie dei comandi:**
```hemlock
let scorciatoie = {
    "i": "install",
    "rm": "uninstall",
    "remove": "uninstall",
    "ls": "list",
    "up": "update"
};
```

### manifest.hml

Gestisce la lettura e scrittura dei file `package.json`.

**Responsabilita:**
- Leggere/scrivere package.json
- Validare la struttura del pacchetto
- Gestire le dipendenze
- Analizzare gli specificatori dei pacchetti (proprietario/repo@versione)

**Funzioni principali:**
```hemlock
create_default(): Manifest           // Crea manifesto vuoto
read_manifest(): Manifest            // Leggi da file
write_manifest(m: Manifest)          // Scrivi su file
validate(m: Manifest): bool          // Valida struttura
get_all_dependencies(m): Map         // Ottieni deps + devDeps
add_dependency(m, pkg, ver, dev)     // Aggiungi dipendenza
remove_dependency(m, pkg)            // Rimuovi dipendenza
parse_specifier(spec): (name, ver)   // Analizza "proprietario/repo@^1.0.0"
split_name(name): (owner, repo)      // Analizza "proprietario/repo"
```

**Struttura Manifest:**
```hemlock
type Manifest = {
    name: string,
    version: string,
    description: string?,
    author: string?,
    license: string?,
    repository: string?,
    main: string?,
    dependencies: Map<string, string>,
    devDependencies: Map<string, string>,
    scripts: Map<string, string>
};
```

### lockfile.hml

Gestisce il file `package-lock.json` per installazioni riproducibili.

**Responsabilita:**
- Creare/leggere/scrivere file di lock
- Tracciare le versioni esatte risolte
- Memorizzare URL di download e hash di integrita
- Eliminare dipendenze orfane

**Funzioni principali:**
```hemlock
create_empty(): Lockfile              // Crea lockfile vuoto
read_lockfile(): Lockfile             // Leggi da file
write_lockfile(l: Lockfile)           // Scrivi su file
create_entry(ver, url, hash, deps)    // Crea voce lock
get_locked(l, pkg): LockEntry?        // Ottieni versione bloccata
set_locked(l, pkg, entry)             // Imposta versione bloccata
remove_locked(l, pkg)                 // Rimuovi voce
prune(l, keep: Set)                   // Rimuovi orfani
needs_update(l, m): bool              // Controlla se non sincronizzato
```

**Struttura Lockfile:**
```hemlock
type Lockfile = {
    lockVersion: int,
    hemlock: string,
    dependencies: Map<string, LockEntry>
};

type LockEntry = {
    version: string,
    resolved: string,     // URL di download
    integrity: string,    // Hash SHA256
    dependencies: Map<string, string>
};
```

### semver.hml

Implementazione completa del Versionamento Semantico 2.0.0.

**Responsabilita:**
- Analizzare stringhe di versione
- Confrontare versioni
- Analizzare e valutare vincoli di versione
- Trovare versioni che soddisfano i vincoli

**Funzioni principali:**
```hemlock
// Analisi
parse(s: string): Version             // "1.2.3-beta+build" -> Version
stringify(v: Version): string         // Version -> "1.2.3-beta+build"

// Confronto
compare(a, b: Version): int           // -1, 0, o 1
gt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool

// Vincoli
parse_constraint(s: string): Constraint    // "^1.2.3" -> Constraint
satisfies(v: Version, c: Constraint): bool // Controlla se v corrisponde a c
max_satisfying(versions, c): Version?      // Trova la corrispondenza piu alta
sort(versions): [Version]                  // Ordina ascendente

// Utilita
constraints_overlap(a, b: Constraint): bool  // Controlla compatibilita
```

**Struttura Version:**
```hemlock
type Version = {
    major: int,
    minor: int,
    patch: int,
    prerelease: [string]?,  // es. ["beta", "1"]
    build: string?          // es. "20230101"
};
```

**Tipi di Vincolo:**
```hemlock
type Constraint =
    | Exact(Version)           // "1.2.3"
    | Caret(Version)           // "^1.2.3" -> >=1.2.3 <2.0.0
    | Tilde(Version)           // "~1.2.3" -> >=1.2.3 <1.3.0
    | Range(op, Version)       // ">=1.0.0", "<2.0.0"
    | And(Constraint, Constraint)  // Range combinati
    | Any;                     // "*"
```

### resolver.hml

Implementa la risoluzione delle dipendenze in stile npm.

**Responsabilita:**
- Risolvere alberi di dipendenze
- Rilevare conflitti di versione
- Rilevare dipendenze circolari
- Costruire alberi di visualizzazione

**Funzioni principali:**
```hemlock
resolve(manifest, lockfile): ResolveResult
    // Risolutore principale: ritorna mappa piatta di tutte le dipendenze con versioni risolte

resolve_version(pkg, constraints: [string]): ResolvedPackage?
    // Trova versione che soddisfa tutti i vincoli

detect_cycles(deps: Map): [Cycle]?
    // Trova dipendenze circolari usando DFS

build_tree(lockfile): Tree
    // Crea struttura ad albero per la visualizzazione

find_why(pkg, lockfile): [Chain]
    // Trova catene di dipendenze che spiegano perche pkg e installato
```

**Algoritmo di risoluzione:**

1. **Raccogli vincoli**: Percorri manifesto e dipendenze transitive
2. **Risolvi ogni pacchetto**: Per ogni pacchetto:
   - Ottieni tutti i vincoli di versione dai dipendenti
   - Recupera versioni disponibili da GitHub
   - Trova la versione piu alta che soddisfa TUTTI i vincoli
   - Errore se nessuna versione soddisfa tutti (conflitto)
3. **Rileva cicli**: Esegui DFS per trovare dipendenze circolari
4. **Ritorna mappa piatta**: Nome pacchetto -> info versione risolta

**Struttura ResolveResult:**
```hemlock
type ResolveResult = {
    packages: Map<string, ResolvedPackage>,
    conflicts: [Conflict]?,
    cycles: [Cycle]?
};

type ResolvedPackage = {
    name: string,
    version: Version,
    url: string,
    dependencies: Map<string, string>
};
```

### github.hml

Client API GitHub per la scoperta e il download dei pacchetti.

**Responsabilita:**
- Recuperare versioni disponibili (tag)
- Scaricare package.json dai repository
- Scaricare tarball delle release
- Gestire autenticazione e limiti di frequenza

**Funzioni principali:**
```hemlock
get_token(): string?
    // Ottieni token da env o config

github_request(url, headers?): Response
    // Effettua richiesta API con retry

get_tags(owner, repo): [string]
    // Ottieni tag di versione (v1.0.0, v1.1.0, ecc.)

get_package_json(owner, repo, ref): Manifest
    // Recupera package.json a un tag/commit specifico

download_tarball(owner, repo, tag): bytes
    // Scarica archivio release

repo_exists(owner, repo): bool
    // Controlla se il repository esiste

get_repo_info(owner, repo): RepoInfo
    // Ottieni metadati del repository
```

**Logica di retry:**
- Backoff esponenziale: 1s, 2s, 4s, 8s
- Retry su: 403 (limite frequenza), 5xx (errore server), errori di rete
- Massimo 4 retry
- Riporta errori di limite di frequenza chiaramente

**Endpoint API usati:**
```
GET /repos/{owner}/{repo}/tags
GET /repos/{owner}/{repo}/contents/package.json?ref={tag}
GET /repos/{owner}/{repo}/tarball/{tag}
GET /repos/{owner}/{repo}
```

### installer.hml

Gestisce il download e l'estrazione dei pacchetti.

**Responsabilita:**
- Scaricare pacchetti da GitHub
- Estrarre tarball in hem_modules
- Controllare/usare pacchetti in cache
- Installare/disinstallare pacchetti

**Funzioni principali:**
```hemlock
install_package(pkg: ResolvedPackage): bool
    // Scarica e installa singolo pacchetto

install_all(packages: Map, options): InstallResult
    // Installa tutti i pacchetti risolti

uninstall_package(name: string): bool
    // Rimuovi pacchetto da hem_modules

get_installed(): Map<string, string>
    // Elenca pacchetti attualmente installati

verify_integrity(pkg): bool
    // Verifica integrita del pacchetto

prefetch_packages(packages: Map): void
    // Download parallelo in cache (sperimentale)
```

**Processo di installazione:**

1. Controlla se gia installato alla versione corretta
2. Controlla cache per tarball
3. Se non in cache, scarica da GitHub
4. Memorizza in cache per uso futuro
5. Estrai in `hem_modules/proprietario/repo/`
6. Verifica installazione

**Struttura directory creata:**
```
hem_modules/
â””â”€â”€ proprietario/
    â””â”€â”€ repo/
        â”œâ”€â”€ package.json
        â”œâ”€â”€ src/
        â””â”€â”€ ...
```

### cache.hml

Gestisce la cache globale dei pacchetti.

**Responsabilita:**
- Memorizzare tarball scaricati
- Recuperare pacchetti in cache
- Elencare pacchetti in cache
- Pulire cache
- Gestire configurazione

**Funzioni principali:**
```hemlock
get_cache_dir(): string
    // Ottieni directory cache (rispetta HPM_CACHE_DIR)

get_config_dir(): string
    // Ottieni directory config (~/.hpm)

is_cached(owner, repo, version): bool
    // Controlla se tarball e in cache

get_cached_path(owner, repo, version): string
    // Ottieni percorso a tarball in cache

store_tarball_file(owner, repo, version, data): void
    // Salva tarball in cache

list_cached(): [CachedPackage]
    // Elenca tutti i pacchetti in cache

clear_cache(): int
    // Rimuovi tutti i pacchetti in cache, ritorna byte liberati

get_cache_size(): int
    // Calcola dimensione totale cache

read_config(): Config
    // Leggi ~/.hpm/config.json

write_config(c: Config): void
    // Scrivi file config
```

**Struttura cache:**
```
~/.hpm/
â”œâ”€â”€ config.json
â””â”€â”€ cache/
    â””â”€â”€ proprietario/
        â””â”€â”€ repo/
            â”œâ”€â”€ 1.0.0.tar.gz
            â””â”€â”€ 1.1.0.tar.gz
```

## Flusso dei Dati

### Flusso del Comando Install

```
hpm install proprietario/repo@^1.0.0
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ main.hml â”‚ Analizza args, chiama cmd_install
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚manifest.hmlâ”‚ Leggi package.json, aggiungi dipendenza
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚resolver.hmlâ”‚ Risolvi tutte le dipendenze
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ github.hmlâ”‚    â”‚ semver.hmlâ”‚ Ottieni versioni, trova soddisfacente
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚installer.hmlâ”‚ Scarica ed estrai pacchetti
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ github.hmlâ”‚    â”‚ cache.hmlâ”‚ Scarica o usa cache
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚lockfile.hmlâ”‚ Aggiorna package-lock.json
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Dettaglio Algoritmo di Risoluzione

```
Input: manifest.dependencies, manifest.devDependencies, lockfile esistente

1. Inizializza:
   - constraints = {} // Map<string, [Constraint]>
   - resolved = {}    // Map<string, ResolvedPackage>
   - queue = [dipendenze dirette]

2. Mentre queue non e vuota:
   a. pkg = queue.pop()
   b. Se pkg gia risolto, salta
   c. Ottieni tutti i vincoli per pkg dai dipendenti
   d. Recupera versioni disponibili da GitHub (in cache)
   e. Trova versione max che soddisfa tutti i vincoli
   f. Se nessuna trovata: CONFLITTO
   g. resolved[pkg] = {version, url, deps}
   h. Aggiungi dipendenze di pkg alla queue

3. Rileva cicli nel grafo risolto
   - Se ciclo trovato: ERRORE

4. Ritorna mappa risolta
```

## Gestione degli Errori

### Codici di Uscita

Definiti in main.hml:

```hemlock
let EXIT_SUCCESS = 0;
let EXIT_CONFLICT = 1;
let EXIT_NOT_FOUND = 2;
let EXIT_VERSION_NOT_FOUND = 3;
let EXIT_NETWORK = 4;
let EXIT_INVALID_MANIFEST = 5;
let EXIT_INTEGRITY = 6;
let EXIT_RATE_LIMIT = 7;
let EXIT_CIRCULAR = 8;
```

### Propagazione degli Errori

Gli errori risalgono attraverso i valori di ritorno:

```hemlock
fn resolve_version(pkg): Result<Version, ResolveError> {
    let versions = github.get_tags(owner, repo)?;  // ? propaga
    // ...
}
```

## Test

### Framework di Test

Framework di test personalizzato in `test/framework.hml`:

```hemlock
fn suite(name: string, tests: fn()) {
    print("Suite: " + name);
    tests();
}

fn test(name: string, body: fn()) {
    try {
        body();
        print("  âœ“ " + name);
    } catch e {
        print("  âœ— " + name + ": " + e);
        failed += 1;
    }
}

fn assert_eq<T>(actual: T, expected: T) {
    if actual != expected {
        throw "Atteso " + expected + ", ottenuto " + actual;
    }
}
```

### File di Test

- `test/test_semver.hml` - Parsing versioni, confronto, vincoli
- `test/test_manifest.hml` - Lettura/scrittura manifesto, validazione
- `test/test_lockfile.hml` - Operazioni lockfile
- `test/test_cache.hml` - Gestione cache

### Esecuzione dei Test

```bash
# Tutti i test
make test

# Test specifici
make test-semver
make test-manifest
make test-lockfile
make test-cache
```

## Miglioramenti Futuri

### Funzionalita Pianificate

1. **Verifica integrita** - Controllo hash SHA256 completo
2. **Workspace** - Supporto monorepo
3. **Sistema plugin** - Comandi estensibili
4. **Audit** - Controllo vulnerabilita di sicurezza
5. **Registro privato** - Hosting pacchetti self-hosted

### Limitazioni Note

1. **Bug bundler** - Non puo creare eseguibile standalone
2. **Download paralleli** - Sperimentale, potrebbe avere race condition
3. **Integrita** - SHA256 non completamente implementato

## Contribuire

### Stile del Codice

- Usa indentazione di 4 spazi
- Le funzioni dovrebbero fare una cosa sola
- Commenta la logica complessa
- Scrivi test per le nuove funzionalita

### Aggiungere un Comando

1. Aggiungi handler in `main.hml`:
   ```hemlock
   fn cmd_nuovocmd(args: [string]) {
       // Implementazione
   }
   ```

2. Aggiungi al dispatch dei comandi:
   ```hemlock
   match command {
       "nuovocmd" => cmd_nuovocmd(args),
       // ...
   }
   ```

3. Aggiorna il testo di aiuto

### Aggiungere un Modulo

1. Crea `src/nuovomodulo.hml`
2. Esporta l'interfaccia pubblica
3. Importa nei moduli che ne hanno bisogno
4. Aggiungi test in `test/test_nuovomodulo.hml`

## Vedi Anche

- [Comandi](#hpm-architecture-commands) - Riferimento CLI
- [Creazione di Pacchetti](#hpm-architecture-creating-packages) - Sviluppo pacchetti
- [Versionamento](#hpm-architecture-versioning) - Versionamento semantico


--------------------------------------------------------------------------------
## Codici di Uscita
--------------------------------------------------------------------------------

# Codici di Uscita

Riferimento per i codici di uscita di hpm e i loro significati.

## Tabella dei Codici di Uscita

| Codice | Nome | Descrizione |
|--------|------|-------------|
| 0 | SUCCESS | Comando completato con successo |
| 1 | CONFLICT | Conflitto di versione delle dipendenze |
| 2 | NOT_FOUND | Pacchetto non trovato |
| 3 | VERSION_NOT_FOUND | Versione richiesta non trovata |
| 4 | NETWORK | Errore di rete |
| 5 | INVALID_MANIFEST | package.json non valido |
| 6 | INTEGRITY | Verifica integrita fallita |
| 7 | RATE_LIMIT | Limite di frequenza API GitHub superato |
| 8 | CIRCULAR | Dipendenza circolare rilevata |

## Descrizioni Dettagliate

### Codice di Uscita 0: SUCCESS

Il comando e stato completato con successo.

```bash
$ hpm install
Installati 5 pacchetti
$ echo $?
0
```

### Codice di Uscita 1: CONFLICT

Due o piu pacchetti richiedono versioni incompatibili di una dipendenza.

**Esempio:**
```
Errore: Conflitto di dipendenze per hemlang/json

  pacchetto-a richiede hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)
  pacchetto-b richiede hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)

Nessuna versione soddisfa tutti i vincoli.
```

**Soluzioni:**
1. Controlla quali pacchetti hanno il conflitto:
   ```bash
   hpm why hemlang/json
   ```
2. Aggiorna il pacchetto in conflitto:
   ```bash
   hpm update pacchetto-a
   ```
3. Rilassa i vincoli di versione in package.json
4. Rimuovi uno dei pacchetti in conflitto

### Codice di Uscita 2: NOT_FOUND

Il pacchetto specificato non esiste su GitHub.

**Esempio:**
```
Errore: Pacchetto non trovato: hemlang/inesistente

Il repository hemlang/inesistente non esiste su GitHub.
```

**Soluzioni:**
1. Verifica l'ortografia del nome del pacchetto
2. Controlla se il repository esiste: `https://github.com/proprietario/repo`
3. Verifica di avere accesso (per repo privati, imposta GITHUB_TOKEN)

### Codice di Uscita 3: VERSION_NOT_FOUND

Nessuna versione corrisponde al vincolo specificato.

**Esempio:**
```
Errore: Nessuna versione di hemlang/json corrisponde al vincolo ^5.0.0

Versioni disponibili: 1.0.0, 1.1.0, 1.2.0, 2.0.0
```

**Soluzioni:**
1. Controlla le versioni disponibili su GitHub releases/tags
2. Usa un vincolo di versione valido
3. I tag di versione devono iniziare con 'v' (es. `v1.0.0`)

### Codice di Uscita 4: NETWORK

Si e verificato un errore relativo alla rete.

**Esempio:**
```
Errore: Errore di rete: impossibile connettersi a api.github.com

Per favore controlla la tua connessione internet e riprova.
```

**Soluzioni:**
1. Controlla la connessione internet
2. Controlla se GitHub e accessibile
3. Verifica le impostazioni proxy se sei dietro un firewall
4. Usa `--offline` se i pacchetti sono in cache:
   ```bash
   hpm install --offline
   ```
5. Aspetta e riprova (hpm riprova automaticamente)

### Codice di Uscita 5: INVALID_MANIFEST

Il file package.json e invalido o malformato.

**Esempio:**
```
Errore: package.json non valido

  - Campo obbligatorio mancante: name
  - Formato versione non valido: "1.0"
```

**Soluzioni:**
1. Controlla la sintassi JSON (usa un validatore JSON)
2. Assicurati che i campi obbligatori esistano (`name`, `version`)
3. Verifica i formati dei campi:
   - name: formato `proprietario/repo`
   - version: formato semver `X.Y.Z`
4. Rigenera:
   ```bash
   rm package.json
   hpm init
   ```

### Codice di Uscita 6: INTEGRITY

La verifica dell'integrita del pacchetto e fallita.

**Esempio:**
```
Errore: Verifica integrita fallita per hemlang/json@1.0.0

Atteso: sha256-abc123...
Attuale: sha256-def456...

Il pacchetto scaricato potrebbe essere corrotto.
```

**Soluzioni:**
1. Pulisci la cache e reinstalla:
   ```bash
   hpm cache clean
   hpm install
   ```
2. Controlla problemi di rete (download parziali)
3. Verifica che il pacchetto non sia stato manomesso

### Codice di Uscita 7: RATE_LIMIT

Il limite di frequenza dell'API GitHub e stato superato.

**Esempio:**
```
Errore: Limite di frequenza API GitHub superato

Limite di frequenza non autenticato: 60 richieste/ora
Utilizzo attuale: 60/60

Il limite di frequenza si resetta alle: 2024-01-15 10:30:00 UTC
```

**Soluzioni:**
1. **Autenticati con GitHub** (consigliato):
   ```bash
   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
   hpm install
   ```
2. Aspetta che il limite di frequenza si resetti (si resetta ogni ora)
3. Usa la modalita offline se i pacchetti sono in cache:
   ```bash
   hpm install --offline
   ```

### Codice di Uscita 8: CIRCULAR

Rilevata dipendenza circolare nel grafo delle dipendenze.

**Esempio:**
```
Errore: Dipendenza circolare rilevata

  pacchetto-a@1.0.0
  â””â”€â”€ pacchetto-b@1.0.0
      â””â”€â”€ pacchetto-a@1.0.0  (circolare!)

Impossibile risolvere l'albero delle dipendenze.
```

**Soluzioni:**
1. Questo e solitamente un bug nei pacchetti stessi
2. Contatta i manutentori dei pacchetti
3. Evita di usare uno dei pacchetti circolari

## Uso dei Codici di Uscita negli Script

### Bash

```bash
#!/bin/bash

hpm install
codice_uscita=$?

case $codice_uscita in
  0)
    echo "Installazione riuscita"
    ;;
  1)
    echo "Conflitto di dipendenze - controlla i vincoli di versione"
    exit 1
    ;;
  2)
    echo "Pacchetto non trovato - controlla il nome del pacchetto"
    exit 1
    ;;
  4)
    echo "Errore di rete - controlla la connessione"
    exit 1
    ;;
  7)
    echo "Limite di frequenza - imposta GITHUB_TOKEN"
    exit 1
    ;;
  *)
    echo "Errore sconosciuto: $codice_uscita"
    exit 1
    ;;
esac
```

### CI/CD

```yaml
# GitHub Actions
- name: Installa dipendenze
  run: |
    hpm install
    if [ $? -eq 7 ]; then
      echo "::error::Limite di frequenza GitHub superato. Aggiungi GITHUB_TOKEN."
      exit 1
    fi
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### Make

```makefile
install:
	@hpm install || (echo "Installazione fallita con codice $$?"; exit 1)

test: install
	@hpm test
```

## Risoluzione dei Problemi per Codice di Uscita

### Riferimento Rapido

| Codice | Prima Cosa da Controllare |
|--------|---------------------------|
| 1 | Esegui `hpm why <pacchetto>` per vedere il conflitto |
| 2 | Verifica il nome del pacchetto su GitHub |
| 3 | Controlla i tag versione disponibili su GitHub |
| 4 | Controlla la connessione internet |
| 5 | Valida la sintassi di package.json |
| 6 | Esegui `hpm cache clean && hpm install` |
| 7 | Imposta la variabile d'ambiente `GITHUB_TOKEN` |
| 8 | Contatta i manutentori dei pacchetti |

## Vedi Anche

- [Risoluzione dei Problemi](#hpm-exit-codes-troubleshooting) - Soluzioni dettagliate
- [Comandi](#hpm-exit-codes-commands) - Riferimento comandi
- [Configurazione](#hpm-exit-codes-configuration) - Configurazione del token GitHub



================================================================================
END OF DOCUMENTATION
================================================================================