================================================================================
HEMLOCK PROGRAMMING LANGUAGE - COMPLETE DOCUMENTATION (FranÃ§ais)
================================================================================

This file contains the complete documentation for the Hemlock programming
language and the hpm package manager in FranÃ§ais.
It is optimized for LLM consumption.

Source: https://github.com/hemlang/hem-doc

--------------------------------------------------------------------------------
TABLE OF CONTENTS
--------------------------------------------------------------------------------

  1. Bienvenue
  2. RÃ©fÃ©rence du Langage

[Prise en Main]
  3. DÃ©marrage Rapide
  4. Installation
  5. Parcours d'Apprentissage
  6. Tutoriel

[Guide du Langage]
  7. ChaÃ®nes de CaractÃ¨res
  8. Filtrage par Motif
  9. Flux de ContrÃ´le
  10. Fonctions
  11. Gestion de la MÃ©moire
  12. Gestion des Erreurs
  13. Modules
  14. Objets
  15. Runes
  16. Syntaxe
  17. Tableaux
  18. Types

[Sujets AvancÃ©s]
  19. Arguments en Ligne de Commande
  20. Asynchronisme et Concurrence
  21. Empaquetage et Distribution
  22. ExÃ©cution de Commandes
  23. FFI
  24. File IO
  25. Memory Ownership
  26. OpÃ©rations Atomiques
  27. Profilage
  28. Signaux

[RÃ©fÃ©rence API]
  29. API MÃ©moire
  30. API de Concurrence
  31. API des ChaÃ®nes
  32. API des Fichiers
  33. API des Tableaux
  34. Fonctions IntÃ©grÃ©es
  35. OpÃ©rateurs
  36. SystÃ¨me de Types

[Conception et Philosophie]
  37. ImplÃ©mentation
  38. Philosophie
  39. Syntaxe des Signatures

[Contribuer]
  40. Directives
  41. Tests

[hpm : Prise en Main]
  42. Configuration du Projet
  43. DÃ©marrage Rapide
  44. Installation

[hpm : Guide Utilisateur]
  45. Commandes
  46. Configuration
  47. DÃ©pannage

[hpm : DÃ©veloppement de Paquets]
  48. CrÃ©ation de Paquets
  49. Gestion des Versions
  50. SpÃ©cification des Paquets

[hpm : RÃ©fÃ©rence]
  51. Architecture
  52. Codes de Sortie


================================================================================
DOCUMENTATION
================================================================================

--------------------------------------------------------------------------------
## Bienvenue
--------------------------------------------------------------------------------

# Bienvenue dans Hemlock

> "Un petit langage non sÃ©curisÃ© pour Ã©crire des choses non sÃ©curisÃ©es en toute sÃ©curitÃ©."

**Hemlock** est un langage de script systÃ¨me qui combine la puissance du C avec l'ergonomie des langages de script modernes. Il propose une gestion manuelle de la mÃ©moire, un contrÃ´le explicite et une concurrence asynchrone structurÃ©e intÃ©grÃ©e.

## Qu'est-ce que Hemlock ?

Hemlock est conÃ§u pour les programmeurs qui veulent :

- **Un contrÃ´le explicite** sur la mÃ©moire et l'exÃ©cution
- **Une syntaxe similaire au C** avec des commoditÃ©s modernes
- **Aucun comportement cachÃ©** ni magie
- **Une vraie concurrence asynchrone parallÃ¨le** avec une concurrence basÃ©e sur pthread

Hemlock N'EST PAS un langage Ã  mÃ©moire sÃ©curisÃ©e avec ramasse-miettes. Au lieu de cela, il vous donne les outils pour Ãªtre en sÃ©curitÃ© (`buffer`, annotations de type, vÃ©rification des limites) sans vous forcer Ã  les utiliser (`ptr`, mÃ©moire manuelle, opÃ©rations non sÃ©curisÃ©es).

## Exemple Rapide

```hemlock
// Bonjour, Hemlock !
fn greet(name: string): string {
    return `Bonjour, ${name} !`;
}

let message = greet("Monde");
print(message);

// Gestion manuelle de la mÃ©moire
let buf = buffer(64);
buf[0] = 72;  // 'H'
buf[1] = 105; // 'i'
print(buf);
free(buf);
```

## FonctionnalitÃ©s en un Coup d'Å’il

| FonctionnalitÃ© | Description |
|----------------|-------------|
| **SystÃ¨me de Types** | i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object |
| **MÃ©moire** | Gestion manuelle avec `alloc()`, `buffer()`, `free()` |
| **Async** | `async`/`await` intÃ©grÃ© avec vrai parallÃ©lisme pthread |
| **FFI** | Appeler des fonctions C directement depuis des bibliothÃ¨ques partagÃ©es |
| **BibliothÃ¨que Standard** | 40 modules incluant crypto, http, sqlite, json, et plus |

## Prise en Main

PrÃªt Ã  vous lancer ? Voici comment commencer :

1. **[Installation](#getting-started-installation)** - TÃ©lÃ©charger et configurer Hemlock
2. **[DÃ©marrage Rapide](#getting-started-quick-start)** - Ã‰crire votre premier programme en quelques minutes
3. **[Tutoriel](#getting-started-tutorial)** - Apprendre Hemlock Ã©tape par Ã©tape

## Sections de la Documentation

- **Prise en Main** - Installation, guide de dÃ©marrage rapide et tutoriels
- **Guide du Langage** - PlongÃ©e approfondie dans la syntaxe, les types, les fonctions, et plus
- **Sujets AvancÃ©s** - Programmation asynchrone, FFI, signaux et atomiques
- **RÃ©fÃ©rence API** - RÃ©fÃ©rence complÃ¨te pour les fonctions intÃ©grÃ©es et la bibliothÃ¨que standard
- **Conception et Philosophie** - Comprendre pourquoi Hemlock est ce qu'il est

## Gestionnaire de Paquets

Hemlock est livrÃ© avec **hpm**, un gestionnaire de paquets pour gÃ©rer les dÃ©pendances :

```bash
hpm init mon-projet
hpm add un-paquet
hpm run
```

Consultez les sections de documentation hpm pour plus de dÃ©tails.

---

Utilisez la navigation Ã  gauche pour explorer la documentation, ou utilisez la barre de recherche pour trouver des sujets spÃ©cifiques.


--------------------------------------------------------------------------------
## RÃ©fÃ©rence du Langage
--------------------------------------------------------------------------------

# Philosophie de conception du langage Hemlock

> "Un petit langage non securise pour ecrire des choses non securisees en toute securite."

Ce document fournit un apercu de la philosophie de conception de Hemlock et une reference rapide du langage.
Explorez les autres sections de documentation pour des guides detailles et des references API.

---

## Identite fondamentale

Hemlock est un **langage de script systeme** avec gestion manuelle de la memoire et controle explicite :
- La puissance du C avec l'ergonomie des langages de script modernes
- Concurrence asynchrone structuree integree
- Aucun comportement cache ni magie

**Hemlock N'EST PAS :** Un langage securise en memoire, un langage avec ramasse-miettes (GC), ni un langage qui cache la complexite.
**Hemlock EST :** Explicite plutot qu'implicite, educatif, une "couche de script C" pour le travail systeme.

---

## Principes de conception

### 1. Explicite plutot qu'implicite
- Points-virgules obligatoires (pas d'ASI)
- Gestion manuelle de la memoire (alloc/free)
- Annotations de type optionnelles mais verifiees a l'execution

### 2. Dynamique par defaut, type par choix
- Chaque valeur possede une etiquette de type a l'execution
- Les litteraux inferent les types : `42` -> i32, `5000000000` -> i64, `3.14` -> f64
- Les annotations de type optionnelles imposent des verifications a l'execution

### 3. Non securise est une fonctionnalite
- Arithmetique de pointeurs autorisee (responsabilite de l'utilisateur)
- Pas de verification des limites sur les `ptr` bruts (utilisez `buffer` pour la securite)
- Les double-free peuvent provoquer des plantages

### 4. Concurrence structuree de premiere classe
- `async`/`await` integres avec parallelisme base sur pthread
- Canaux (channels) pour la communication
- `spawn`/`join`/`detach` pour la gestion des taches

### 5. Syntaxe proche du C
- Blocs `{}` toujours requis
- Commentaires : `// ligne` et `/* bloc */`
- Operateurs identiques au C : `+`, `-`, `*`, `%`, `&&`, `||`, `!`, `&`, `|`, `^`, `<<`, `>>`
- Increment/decrement : `++x`, `x++`, `--x`, `x--` (prefixe et postfixe)
- Affectation composee : `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`
- `/` retourne toujours un flottant (utilisez `divi()` pour la division entiere)
- Syntaxe de type : `let x: type = valeur;`

---

## Reference rapide

### Types
```
Signes:     i8, i16, i32, i64
Non signes: u8, u16, u32, u64
Flottants:  f32, f64
Autres:     bool, string, rune, array, ptr, buffer, null, object, file, task, channel
Alias:      integer (i32), number (f64), byte (u8)
```

**Promotion de type :** i8 -> i16 -> i32 -> i64 -> f32 -> f64 (les flottants gagnent toujours, mais i64/u64 + f32 -> f64 pour preserver la precision)

### Litteraux
```hemlock
let x = 42;              // i32
let big = 5000000000;    // i64 (> max i32)
let hex = 0xDEADBEEF;    // litteral hexadecimal
let bin = 0b1010;        // litteral binaire
let oct = 0o777;         // litteral octal
let sep = 1_000_000;     // separateurs numeriques autorises
let pi = 3.14;           // f64
let half = .5;           // f64 (sans zero initial)
let s = "hello";         // string (chaine)
let esc = "\x41\u{1F600}"; // echappements hex et unicode
let ch = 'A';            // rune
let emoji = 'ðŸš€';        // rune (Unicode)
let arr = [1, 2, 3];     // array (tableau)
let obj = { x: 10 };     // object (objet)
```

### Conversion de type
```hemlock
// Fonctions constructeurs de type - analysent les chaines vers les types
let n = i32("42");       // Analyse une chaine vers i32
let f = f64("3.14");     // Analyse une chaine vers f64
let b = bool("true");    // Analyse une chaine vers bool ("true" ou "false")

// Tous les types numeriques sont supportes
let a = i8("-128");      // i8, i16, i32, i64
let c = u8("255");       // u8, u16, u32, u64
let d = f32("1.5");      // f32, f64

// Nombres hexadecimaux et negatifs
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42

// Les alias de type fonctionnent aussi
let x = integer("100");  // Equivalent a i32("100")
let y = number("1.5");   // Equivalent a f64("1.5")
let z = byte("200");     // Equivalent a u8("200")

// Convertir entre types numeriques
let big = i64(42);       // i32 vers i64
let truncated = i32(3.99); // f64 vers i32 (tronque a 3)

// Les annotations de type valident les types (mais n'analysent pas les chaines)
let f: f64 = 100;        // i32 vers f64 via annotation (coercition numerique OK)
// let n: i32 = "42";    // ERREUR - utilisez i32("42") pour l'analyse de chaine
```

### Introspection
```hemlock
typeof(42);              // "i32"
typeof("hello");         // "string"
typeof([1, 2, 3]);       // "array"
typeof(null);            // "null"
len("hello");            // 5 (longueur de la chaine en octets)
len([1, 2, 3]);          // 3 (longueur du tableau)
```

### Memoire
```hemlock
let p = alloc(64);       // pointeur brut
let b = buffer(64);      // tampon securise (verification des limites)
memset(p, 0, 64);
memcpy(dest, src, 64);
free(p);                 // nettoyage manuel requis
```

### Flux de controle
```hemlock
if (x > 0) { } else if (x < 0) { } else { }
while (cond) { break; continue; }
for (let i = 0; i < 10; i++) { }
for (item in array) { }
loop { if (done) { break; } }   // boucle infinie (plus propre que while(true))
switch (x) { case 1: break; default: break; }  // style C avec fall-through
defer cleanup();         // s'execute quand la fonction retourne

// Etiquettes de boucle pour break/continue cibles dans les boucles imbriquees
outer: while (cond) {
    inner: for (let i = 0; i < 10; i++) {
        if (i == 5) { break outer; }     // sort de la boucle externe
        if (i == 3) { continue outer; }  // continue la boucle externe
    }
}
```

### Pattern matching (Filtrage par motif)
```hemlock
// Expression match - retourne une valeur
let result = match (value) {
    0 => "zero",                    // Motif litteral
    1 | 2 | 3 => "petit",           // Motif OU
    n if n < 10 => "moyen",         // Expression de garde
    n => "grand: " + n              // Liaison de variable
};

// Motifs de type
match (val) {
    n: i32 => "entier",
    s: string => "chaine",
    _ => "autre"                    // Joker (Wildcard)
}

// Destructuration d'objet
match (point) {
    { x: 0, y: 0 } => "origine",
    { x, y } => "a " + x + "," + y
}

// Destructuration de tableau avec reste
match (arr) {
    [] => "vide",
    [first, ...rest] => "tete: " + first,
    _ => "autre"
}

// Motifs imbriques
match (user) {
    { name, address: { city } } => name + " a " + city
}
```

Voir `docs/language-guide/pattern-matching.md` pour la documentation complete.

### Operateurs de coalescence null
```hemlock
// Coalescence null (??) - retourne gauche si non-null, sinon droite
let name = user.name ?? "Anonyme";
let first = a ?? b ?? c ?? "defaut";

// Affectation avec coalescence null (??=) - affecte seulement si null
let config = null;
config ??= { timeout: 30 };    // config est maintenant { timeout: 30 }
config ??= { timeout: 60 };    // config inchange (non null)

// Fonctionne avec les proprietes et indices
obj.field ??= "defaut";
arr[0] ??= "premier";

// Navigation securisee (?.) - retourne null si l'objet est null
let city = user?.address?.city;  // null si une partie est null
let upper = name?.to_upper();    // appel de methode securise
let item = arr?.[0];             // indexation securisee
```

### Fonctions
```hemlock
fn add(a: i32, b: i32): i32 { return a + b; }
fn greet(name: string, msg?: "Bonjour") { print(msg + " " + name); }
let f = fn(x) { return x * 2; };  // anonyme/closure

// Fonctions a corps d'expression (syntaxe fleche)
fn double(x: i32): i32 => x * 2;
fn max(a: i32, b: i32): i32 => a > b ? a : b;
let square = fn(x: i32): i32 => x * x;  // anonyme avec corps d'expression

// Modificateurs de parametres
fn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // passage par reference
fn print_all(const items: array) { for (i in items) { print(i); } }  // immuable
```

### Arguments nommes
```hemlock
// Les fonctions peuvent etre appelees avec des arguments nommes
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " a " + age + " ans");
}

// Arguments positionnels (traditionnel)
create_user("Alice", 25, false);

// Arguments nommes - peuvent etre dans n'importe quel ordre
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);

// Sauter les parametres optionnels en nommant ce dont vous avez besoin
create_user("David", active: false);  // Utilise age=18 par defaut

// Les arguments nommes doivent venir apres les arguments positionnels
create_user("Eve", age: 21);          // OK : positionnel puis nomme
// create_user(name: "Bad", 25);      // ERREUR : positionnel apres nomme
```

**Regles :**
- Les arguments nommes utilisent la syntaxe `nom: valeur`
- Peuvent apparaitre dans n'importe quel ordre apres les arguments positionnels
- Les arguments positionnels ne peuvent pas suivre les arguments nommes
- Fonctionne avec les parametres par defaut/optionnels
- Les noms de parametres inconnus causent des erreurs a l'execution

### Objets et enumerations
```hemlock
define Person { name: string, age: i32, active?: true }
let p: Person = { name: "Alice", age: 30 };
let json = p.serialize();
let restored = json.deserialize();

// Syntaxe raccourcie pour les objets (style ES6)
let name = "Alice";
let age = 30;
let person = { name, age };         // equivalent a { name: name, age: age }

// Operateur de propagation d'objet (spread)
let defaults = { theme: "dark", size: "medium" };
let config = { ...defaults, size: "large" };  // copie defaults, remplace size

enum Color { RED, GREEN, BLUE }
enum Status { OK = 0, ERROR = 1 }
```

### Types composes (Intersection/Duck Types)
```hemlock
// Definir des types structurels
define HasName { name: string }
define HasAge { age: i32 }
define HasEmail { email: string }

// Type compose : l'objet doit satisfaire TOUS les types
let person: HasName & HasAge = { name: "Alice", age: 30 };

// Parametres de fonction avec types composes
fn greet(p: HasName & HasAge) {
    print(p.name + " a " + p.age + " ans");
}

// Trois types ou plus
fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}

// Champs supplementaires autorises (duck typing)
let employee: HasName & HasAge = {
    name: "Bob",
    age: 25,
    department: "Ingenierie"  // OK - champs supplementaires ignores
};
```

Les types composes fournissent un comportement similaire aux interfaces sans mot-cle `interface` separe,
en s'appuyant sur les paradigmes existants de `define` et de duck typing.

### Alias de type
```hemlock
// Alias de type simple
type Integer = i32;
type Text = string;

// Alias de type fonction
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// Alias de type compose (excellent pour les interfaces reutilisables)
define HasName { name: string }
define HasAge { age: i32 }
type Person = HasName & HasAge;

// Alias de type generique
type Pair<T> = { first: T, second: T };

// Utilisation des alias de type
let x: Integer = 42;
let cb: Callback = fn(n) { print(n); };
let p: Person = { name: "Alice", age: 30 };
```

Les alias de type creent des raccourcis nommes pour les types complexes, ameliorant la lisibilite et la maintenabilite.

### Types de fonction
```hemlock
// Annotations de type fonction pour les parametres
fn apply_fn(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Fonction d'ordre superieur retournant une fonction
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Types de fonction asynchrone
fn run_async(handler: async fn(): void) {
    spawn(handler);
}

// Types de fonction avec plusieurs parametres
type BinaryOp = fn(i32, i32): i32;
let add: BinaryOp = fn(a, b) { return a + b; };
```

### Parametres const
```hemlock
// Parametre const - immutabilite profonde
fn print_all(const items: array) {
    // items.push(4);  // ERREUR : impossible de modifier un parametre const
    for (item in items) {
        print(item);
    }
}

// Const avec objets - aucune mutation par aucun chemin
fn describe(const person: object) {
    print(person.name);       // OK : la lecture est autorisee
    // person.name = "Bob";   // ERREUR : impossible de modifier
}

// L'acces imbrique est autorise pour la lecture
fn get_city(const user: object) {
    return user.address.city;  // OK : lecture des proprietes imbriquees
}
```

Le modificateur `const` empeche toute mutation du parametre, y compris les proprietes imbriquees.
Cela fournit une securite a la compilation pour les fonctions qui ne doivent pas modifier leurs entrees.

### Parametres ref (passage par reference)
```hemlock
// Parametre ref - la variable de l'appelant est modifiee directement
fn increment(ref x: i32) {
    x = x + 1;  // Modifie la variable originale
}

let count = 10;
increment(count);
print(count);  // 11 - l'original a ete modifie

// Fonction swap classique
fn swap(ref a: i32, ref b: i32) {
    let temp = a;
    a = b;
    b = temp;
}

let x = 1;
let y = 2;
swap(x, y);
print(x, y);  // 2 1

// Melanger parametres ref et reguliers
fn add_to(ref target: i32, amount: i32) {
    target = target + amount;
}

let total = 100;
add_to(total, 50);
print(total);  // 150
```

Le modificateur `ref` passe une reference a la variable de l'appelant, permettant a la fonction de
la modifier directement. Sans `ref`, les primitives sont passees par valeur (copiees). Utilisez `ref` quand
vous devez modifier l'etat de l'appelant sans retourner de valeur.

**Regles :**
- Les parametres `ref` doivent recevoir des variables, pas des litteraux ou expressions
- Fonctionne avec tous les types (primitives, tableaux, objets)
- Combiner avec les annotations de type : `ref x: i32`
- Ne peut pas etre combine avec `const` (ils sont opposes)

### Signatures de methode dans define
```hemlock
// Define avec signatures de methode (patron interface)
define Comparable {
    value: i32,
    fn compare(other: Self): i32   // Signature de methode requise
}

// Les objets doivent fournir la methode requise
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};

// Methodes optionnelles avec ?
define Serializable {
    fn serialize(): string,        // Requise
    fn pretty?(): string           // Methode optionnelle
}

// Le type Self fait reference au type definissant
define Cloneable {
    fn clone(): Self   // Retourne le meme type que l'objet
}
```

Les signatures de methode dans les blocs `define` utilisent des delimiteurs virgule (comme les interfaces TypeScript),
etablissant des contrats que les objets doivent respecter et permettant des patrons de programmation
de type interface avec le systeme de duck typing de Hemlock.

### Gestion des erreurs
```hemlock
try { throw "erreur"; } catch (e) { print(e); } finally { cleanup(); }
panic("irrecuperable");  // quitte immediatement, non capturable
```

### Async/Concurrence
```hemlock
async fn compute(n: i32): i32 { return n * n; }
let task = spawn(compute, 42);
let result = await task;     // ou join(task)
detach(spawn(background_work));

let ch = channel(10);
ch.send(value);
let val = ch.recv();
ch.close();
```

**Propriete de la memoire :** Les taches recoivent des copies des valeurs primitives mais partagent les pointeurs. Si vous passez un `ptr` a une tache lancee, vous devez vous assurer que la memoire reste valide jusqu'a ce que la tache se termine. Utilisez `join()` avant `free()`, ou utilisez des canaux pour signaler la completion.

### Entree utilisateur
```hemlock
let name = read_line();          // Lit une ligne depuis stdin (bloquant)
print("Bonjour, " + name);
eprint("Message d'erreur");      // Affiche sur stderr

// read_line() retourne null en fin de fichier (EOF)
while (true) {
    let line = read_line();
    if (line == null) { break; }
    print("Recu:", line);
}
```

### E/S fichier
```hemlock
let f = open("fichier.txt", "r");  // modes: r, w, a, r+, w+, a+
let content = f.read();
f.write("donnees");
f.seek(0);
f.close();
```

### Signaux
```hemlock
signal(SIGINT, fn(sig) { print("Interrompu"); });
raise(SIGUSR1);
```

---

## Methodes de chaine (19)

`substr`, `slice`, `find`, `contains`, `split`, `trim`, `to_upper`, `to_lower`,
`starts_with`, `ends_with`, `replace`, `replace_all`, `repeat`, `char_at`,
`byte_at`, `chars`, `bytes`, `to_bytes`, `deserialize`

Chaines de modele : `` `Bonjour ${name}!` ``

**Mutabilite des chaines :** Les chaines sont mutables via l'affectation par index (`s[0] = 'H'`), mais toutes les methodes de chaine retournent de nouvelles chaines sans modifier l'originale. Cela permet la mutation sur place quand necessaire tout en gardant le chainage de methodes fonctionnel.

**Proprietes de longueur de chaine :**
```hemlock
let s = "hello ðŸš€";
print(s.length);       // 7 (nombre de caracteres/runes)
print(s.byte_length);  // 10 (nombre d'octets - l'emoji fait 4 octets UTF-8)
```

## Methodes de tableau (18)

`push`, `pop`, `shift`, `unshift`, `insert`, `remove`, `find`, `contains`,
`slice`, `join`, `concat`, `reverse`, `first`, `last`, `clear`, `map`, `filter`, `reduce`

Tableaux types : `let nums: array<i32> = [1, 2, 3];`

---

## Bibliotheque standard (40 modules)

Importer avec le prefixe `@stdlib/` :
```hemlock
import { sin, cos, PI } from "@stdlib/math";
import { HashMap, Queue, Set } from "@stdlib/collections";
import { read_file, write_file } from "@stdlib/fs";
import { TcpStream, UdpSocket } from "@stdlib/net";
```

| Module | Description |
|--------|-------------|
| `arena` | Allocateur memoire arena (allocation par bump) |
| `args` | Analyse des arguments de ligne de commande |
| `assert` | Utilitaires d'assertion |
| `async` | ThreadPool, parallel_map |
| `async_fs` | Operations d'E/S fichier asynchrones |
| `collections` | HashMap, Queue, Stack, Set, LinkedList, LRUCache |
| `compression` | gzip, gunzip, deflate |
| `crypto` | aes_encrypt, rsa_sign, random_bytes |
| `csv` | Analyse et generation CSV |
| `datetime` | Classe DateTime, formatage, analyse |
| `encoding` | base64_encode, hex_encode, url_encode |
| `env` | getenv, setenv, exit, get_pid |
| `fmt` | Utilitaires de formatage de chaine |
| `fs` | read_file, write_file, list_dir, exists |
| `glob` | Correspondance de motifs de fichier |
| `hash` | sha256, sha512, md5, djb2 |
| `http` | http_get, http_post, http_request |
| `ipc` | Communication inter-processus |
| `iter` | Utilitaires d'iterateur |
| `json` | parse, stringify, pretty, get, set |
| `logging` | Logger avec niveaux |
| `math` | sin, cos, sqrt, pow, rand, PI, E |
| `net` | TcpListener, TcpStream, UdpSocket |
| `os` | platform, arch, cpu_count, hostname |
| `path` | Manipulation de chemins de fichier |
| `process` | fork, exec, wait, kill |
| `random` | Generation de nombres aleatoires |
| `regex` | compile, test (POSIX ERE) |
| `retry` | Logique de reessai avec backoff |
| `semver` | Versionnage semantique |
| `shell` | Utilitaires de commandes shell |
| `sqlite` | Base de donnees SQLite, query, exec, transactions |
| `strings` | pad_left, is_alpha, reverse, lines |
| `terminal` | Couleurs et styles ANSI |
| `testing` | describe, test, expect |
| `time` | now, time_ms, sleep, clock |
| `toml` | Analyse et generation TOML |
| `url` | Analyse et manipulation d'URL |
| `uuid` | Generation d'UUID |
| `websocket` | Client WebSocket |

Voir `stdlib/docs/` pour la documentation detaillee des modules.

---

## FFI (Interface de fonction etrangere)

Declarer et appeler des fonctions C depuis des bibliotheques partagees :
```hemlock
import "libc.so.6";

extern fn strlen(s: string): i32;
extern fn getpid(): i32;

let len = strlen("Hello!");  // 6
let pid = getpid();
```

Exporter des fonctions FFI depuis des modules :
```hemlock
// string_utils.hml
import "libc.so.6";

export extern fn strlen(s: string): i32;
export fn string_length(s: string): i32 {
    return strlen(s);
}
```

FFI dynamique (liaison a l'execution) :
```hemlock
let lib = ffi_open("libc.so.6");
let puts = ffi_bind(lib, "puts", [FFI_POINTER], FFI_INT);
puts("Hello from C!");
ffi_close(lib);
```

Types : `FFI_INT`, `FFI_DOUBLE`, `FFI_POINTER`, `FFI_STRING`, `FFI_VOID`, etc.

---

## Operations atomiques

Programmation concurrente sans verrou avec des operations atomiques :

```hemlock
// Allouer de la memoire pour un i32 atomique
let p = alloc(4);
ptr_write_i32(p, 0);

// Chargement/stockage atomique
let val = atomic_load_i32(p);        // Lecture atomique
atomic_store_i32(p, 42);             // Ecriture atomique

// Operations fetch-and-modify (retournent l'ANCIENNE valeur)
let old = atomic_add_i32(p, 10);     // Ajoute, retourne l'ancienne valeur
old = atomic_sub_i32(p, 5);          // Soustrait, retourne l'ancienne valeur
old = atomic_and_i32(p, 0xFF);       // ET bit a bit
old = atomic_or_i32(p, 0x10);        // OU bit a bit
old = atomic_xor_i32(p, 0x0F);       // XOR bit a bit

// Compare-and-swap (CAS)
let success = atomic_cas_i32(p, 42, 100);  // Si *p == 42, mettre a 100
// Retourne true si l'echange a reussi, false sinon

// Echange atomique
old = atomic_exchange_i32(p, 999);   // Echange, retourne l'ancienne valeur

free(p);

// Variantes i64 disponibles (atomic_load_i64, atomic_add_i64, etc.)

// Barriere memoire (barriere complete)
atomic_fence();
```

Toutes les operations utilisent la coherence sequentielle (`memory_order_seq_cst`).

---

## Structure du projet

```
hemlock/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ frontend/         # Partage : lexer, parser, AST, modules
â”‚   â”œâ”€â”€ backends/
â”‚   â”‚   â”œâ”€â”€ interpreter/  # hemlock : interpreteur par parcours d'arbre
â”‚   â”‚   â””â”€â”€ compiler/     # hemlockc : generateur de code C
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ lsp/          # Language Server Protocol
â”‚   â”‚   â””â”€â”€ bundler/      # Outils de bundle/package
â”œâ”€â”€ runtime/              # Runtime du programme compile (libhemlock_runtime.a)
â”œâ”€â”€ stdlib/               # Bibliotheque standard (40 modules)
â”‚   â””â”€â”€ docs/             # Documentation des modules
â”œâ”€â”€ docs/                 # Documentation complete
â”‚   â”œâ”€â”€ language-guide/   # Types, chaines, tableaux, etc.
â”‚   â”œâ”€â”€ reference/        # References API
â”‚   â””â”€â”€ advanced/         # Async, FFI, signaux, etc.
â”œâ”€â”€ tests/                # 625+ tests
â””â”€â”€ examples/             # Programmes d'exemple
```

---

## Directives de style de code

### Constantes et nombres magiques

Lors de l'ajout de constantes numeriques a la base de code C, suivez ces directives :

1. **Definir les constantes dans `include/hemlock_limits.h`** - Ce fichier est l'emplacement central pour toutes les limites de compilation et d'execution, capacites et constantes nommees.

2. **Utiliser des noms descriptifs avec le prefixe `HML_`** - Toutes les constantes doivent etre prefixees avec `HML_` pour la clarte de l'espace de noms.

3. **Eviter les nombres magiques** - Remplacer les valeurs numeriques codees en dur par des constantes nommees. Exemples :
   - Limites de plage de type : `HML_I8_MIN`, `HML_I8_MAX`, `HML_U32_MAX`
   - Capacites de tampon : `HML_INITIAL_ARRAY_CAPACITY`, `HML_INITIAL_LEXER_BUFFER_CAPACITY`
   - Conversions de temps : `HML_NANOSECONDS_PER_SECOND`, `HML_MILLISECONDS_PER_SECOND`
   - Graines de hachage : `HML_DJB2_HASH_SEED`
   - Valeurs ASCII : `HML_ASCII_CASE_OFFSET`, `HML_ASCII_PRINTABLE_START`

4. **Inclure `hemlock_limits.h`** - Les fichiers sources doivent inclure cet en-tete (souvent via `internal.h`) pour acceder aux constantes.

5. **Documenter l'objectif** - Ajouter un commentaire expliquant ce que chaque constante represente.

---

## Ce qu'il ne faut PAS faire

- Ne pas ajouter de comportement implicite (ASI, GC, nettoyage automatique)
- Ne pas cacher la complexite (optimisations magiques, compteurs de references caches)
- Ne pas casser la semantique existante (points-virgules, memoire manuelle, chaines mutables)
- Ne pas perdre de precision dans les conversions implicites
- Ne pas utiliser de nombres magiques - definir des constantes nommees dans `hemlock_limits.h` a la place

---

## Tests

```bash
make test              # Executer les tests de l'interpreteur
make test-compiler     # Executer les tests du compilateur
make parity            # Executer les tests de parite (les deux doivent correspondre)
make test-all          # Executer toutes les suites de tests
```

**Important :** Les tests peuvent se bloquer a cause de problemes async/concurrence. Toujours utiliser un timeout lors de l'execution des tests :
```bash
timeout 60 make test   # timeout de 60 secondes
timeout 120 make parity
```

Categories de tests : primitives, memory, strings, arrays, functions, objects, async, ffi, defer, signals, switch, bitwise, typed_arrays, modules, stdlib_*

---

## Architecture compilateur/interpreteur

Hemlock a deux backends d'execution qui partagent un frontend commun :

```
Source (.hml)
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FRONTEND PARTAGE           â”‚
â”‚  - Lexer (src/frontend/)    â”‚
â”‚  - Parser (src/frontend/)   â”‚
â”‚  - AST (src/frontend/)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ INTERPRETEURâ”‚   â”‚ COMPILATEURâ”‚
â”‚ (hemlock)  â”‚    â”‚ (hemlockc) â”‚
â”‚            â”‚    â”‚            â”‚
â”‚ Evaluation â”‚    â”‚ Verif type â”‚
â”‚ par arbre  â”‚    â”‚ AST â†’ C    â”‚
â”‚            â”‚    â”‚ liaison gccâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Verification de type du compilateur

Le compilateur (`hemlockc`) inclut une verification de type a la compilation, **activee par defaut** :

```bash
hemlockc program.hml -o program    # Verifie les types, puis compile
hemlockc --check program.hml       # Verification de type seulement, pas de compilation
hemlockc --no-type-check prog.hml  # Desactiver la verification de type
hemlockc --strict-types prog.hml   # Avertir sur les types 'any' implicites
```

Le verificateur de type :
- Valide les annotations de type a la compilation
- Traite le code non type comme dynamique (type `any`) - toujours valide
- Fournit des indications d'optimisation pour le deballage (unboxing)
- Utilise des conversions numeriques permissives (plage validee a l'execution)

### Structure des repertoires

```
hemlock/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ frontend/           # Partage : lexer, parser, AST, modules
â”‚   â”‚   â”œâ”€â”€ lexer.c
â”‚   â”‚   â”œâ”€â”€ parser/
â”‚   â”‚   â”œâ”€â”€ ast.c
â”‚   â”‚   â””â”€â”€ module.c
â”‚   â”œâ”€â”€ backends/
â”‚   â”‚   â”œâ”€â”€ interpreter/    # hemlock : interpreteur par parcours d'arbre
â”‚   â”‚   â”‚   â”œâ”€â”€ main.c
â”‚   â”‚   â”‚   â”œâ”€â”€ runtime/
â”‚   â”‚   â”‚   â””â”€â”€ builtins/
â”‚   â”‚   â””â”€â”€ compiler/       # hemlockc : generateur de code C
â”‚   â”‚       â”œâ”€â”€ main.c
â”‚   â”‚       â””â”€â”€ codegen/
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ lsp/            # Serveur de langage
â”‚   â”‚   â””â”€â”€ bundler/        # Outils de bundle/package
â”œâ”€â”€ runtime/                # libhemlock_runtime.a pour les programmes compiles
â”œâ”€â”€ stdlib/                 # Bibliotheque standard partagee
â””â”€â”€ tests/
    â”œâ”€â”€ parity/             # Tests qui DOIVENT passer les deux backends
    â”œâ”€â”€ interpreter/        # Tests specifiques a l'interpreteur
    â””â”€â”€ compiler/           # Tests specifiques au compilateur
```

---

## Developpement parite-en-premier

**L'interpreteur et le compilateur doivent produire une sortie identique pour la meme entree.**

### Politique de developpement

Lors de l'ajout ou de la modification de fonctionnalites du langage :

1. **Concevoir** - Definir le changement AST/semantique dans le frontend partage
2. **Implementer l'interpreteur** - Ajouter l'evaluation par parcours d'arbre
3. **Implementer le compilateur** - Ajouter la generation de code C
4. **Ajouter un test de parite** - Ecrire le test dans `tests/parity/` avec un fichier `.expected`
5. **Verifier** - Executer `make parity` avant de fusionner

### Structure des tests de parite

```
tests/parity/
â”œâ”€â”€ language/       # Fonctionnalites du langage de base (flux de controle, closures, etc.)
â”œâ”€â”€ builtins/       # Fonctions integrees (print, typeof, memory, etc.)
â”œâ”€â”€ methods/        # Methodes de chaine et de tableau
â””â”€â”€ modules/        # Import/export, imports stdlib
```

Chaque test a deux fichiers :
- `feature.hml` - Le programme de test
- `feature.expected` - Sortie attendue (doit correspondre pour les deux backends)

### Resultats des tests de parite

| Statut | Signification |
|--------|---------------|
| `âœ“ PASSED` | L'interpreteur et le compilateur correspondent a la sortie attendue |
| `â— INTERP_ONLY` | L'interpreteur fonctionne, le compilateur echoue (correction du compilateur necessaire) |
| `â—‘ COMPILER_ONLY` | Le compilateur fonctionne, l'interpreteur echoue (rare) |
| `âœ— FAILED` | Les deux echouent (bug de test ou d'implementation) |

### Ce qui requiert la parite

- Toutes les constructions du langage (if, while, for, switch, defer, try/catch)
- Tous les operateurs (arithmetiques, bit a bit, logiques, comparaison)
- Toutes les fonctions integrees (print, typeof, alloc, etc.)
- Toutes les methodes de chaine et de tableau
- Regles de coercition et promotion de type
- Messages d'erreur pour les erreurs d'execution

### Ce qui peut differer

- Caracteristiques de performance
- Details de disposition memoire
- Format de debogage/trace de pile
- Erreurs de compilation (le compilateur peut en detecter plus a la compilation)

### Ajouter un test de parite

```bash
# 1. Creer le fichier de test
cat > tests/parity/language/my_feature.hml << 'EOF'
// Description du test
let x = some_feature();
print(x);
EOF

# 2. Generer la sortie attendue depuis l'interpreteur
./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected

# 3. Verifier la parite
make parity
```

---

## Version

**v1.8.1** - Version actuelle avec :
- **Pattern matching** (expressions `match`) - Destructuration et flux de controle puissants :
  - Motifs litteral, joker et liaison de variable
  - Motifs OU (`1 | 2 | 3`)
  - Expressions de garde (`n if n > 0`)
  - Destructuration d'objet (`{ x, y }`)
  - Destructuration de tableau avec reste (`[first, ...rest]`)
  - Motifs de type (`n: i32`)
  - Parite complete entre interpreteur et compilateur
- **Annotations d'aide au compilateur** - 11 annotations d'optimisation pour le controle GCC/Clang :
  - `@inline`, `@noinline` - controle de l'inlining de fonction
  - `@hot`, `@cold` - indications de prediction de branche
  - `@pure`, `@const` - annotations d'effets de bord
  - `@flatten` - inliner tous les appels dans la fonction
  - `@optimize(level)` - niveau d'optimisation par fonction ("0", "1", "2", "3", "s", "fast")
  - `@warn_unused` - avertir sur les valeurs de retour ignorees
  - `@section(name)` - placement de section ELF personnalise (ex: `@section(".text.hot")`)
- **Fonctions a corps d'expression** (`fn double(x): i32 => x * 2;`) - syntaxe concise pour les fonctions a expression unique
- **Instructions sur une ligne** - syntaxe sans accolades pour `if`, `while`, `for` (ex: `if (x > 0) print(x);`)
- **Alias de type** (`type Name = Type;`) - raccourcis nommes pour les types complexes
- **Annotations de type fonction** (`fn(i32): i32`) - types de fonction de premiere classe
- **Parametres const** (`fn(const x: array)`) - immutabilite profonde pour les parametres
- **Parametres ref** (`fn(ref x: i32)`) - passage par reference pour la mutation directe de l'appelant
- **Signatures de methode dans define** (`fn method(): Type`) - contrats de type interface (delimites par virgule)
- **Type Self** dans les signatures de methode - fait reference au type definissant
- **Mot-cle loop** (`loop { }`) - boucles infinies plus propres, remplace `while (true)`
- **Etiquettes de boucle** (`outer: while`) - break/continue cibles pour les boucles imbriquees
- **Raccourci objet** (`{ name }`) - syntaxe de propriete raccourcie style ES6
- **Propagation d'objet** (`{ ...obj }`) - copier et fusionner les champs d'objet
- **Types duck composes** (`A & B & C`) - types d'intersection pour le typage structurel
- **Arguments nommes** pour les appels de fonction (`foo(name: "value", age: 30)`)
- **Operateurs de coalescence null** (`??`, `??=`, `?.`) pour la gestion securisee des null
- **Litteraux octaux** (`0o777`, `0O123`)
- **Separateurs numeriques** (`1_000_000`, `0xFF_FF`, `0b1111_0000`)
- **Commentaires bloc** (`/* ... */`)
- **Sequences d'echappement hexadecimales** dans les chaines/runes (`\x41` = 'A')
- **Sequences d'echappement Unicode** dans les chaines (`\u{1F600}` = ðŸ˜€)
- **Litteraux flottants sans zero initial** (`.5`, `.123`, `.5e2`)
- **Verification de type a la compilation** dans hemlockc (activee par defaut)
- **Integration LSP** avec verification de type pour les diagnostics en temps reel
- **Operateurs d'affectation composee** (`+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`)
- **Operateurs d'increment/decrement** (`++x`, `x++`, `--x`, `x--`)
- **Correction de precision de type** : i64/u64 + f32 -> f64 pour preserver la precision
- Systeme de type unifie avec indications d'optimisation de deballage
- Systeme de type complet (i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object, enum, file, task, channel)
- Chaines UTF-8 avec 19 methodes
- Tableaux avec 18 methodes incluant map/filter/reduce
- Gestion manuelle de la memoire avec `talloc()` et `sizeof()`
- Async/await avec vrai parallelisme pthread
- Operations atomiques pour la programmation concurrente sans verrou
- 40 modules stdlib (+ arena, assert, semver, toml, retry, iter, random, shell)
- FFI pour l'interoperabilite C avec `export extern fn` pour les wrappers de bibliotheque reutilisables
- Support des structures FFI dans le compilateur (passer des structures C par valeur)
- Helpers de pointeur FFI (`ptr_null`, `ptr_read_*`, `ptr_write_*`)
- defer, try/catch/finally/throw, panic
- E/S fichier, gestion des signaux, execution de commandes
- Gestionnaire de paquets [hpm](https://github.com/hemlang/hpm) avec registre base sur GitHub
- Backend compilateur (generation de code C) avec 100% de parite interpreteur
- Serveur LSP avec go-to-definition et find-references
- Passe d'optimisation AST et resolution de variable pour recherche O(1)
- Fonction integree apply() pour les appels de fonction dynamiques
- Canaux non bufferises et support de nombreux parametres
- 159 tests de parite (100% de taux de reussite)

---

## Philosophie

> Nous vous donnons les outils pour etre en securite (`buffer`, annotations de type, verification des limites) mais nous ne vous forcons pas a les utiliser (`ptr`, memoire manuelle, operations non securisees).

**Si vous n'etes pas sur qu'une fonctionnalite convient a Hemlock, demandez-vous : "Est-ce que cela donne au programmeur plus de controle explicite, ou est-ce que cela cache quelque chose ?"**

Si cela cache, cela n'a probablement pas sa place dans Hemlock.



################################################################################
# PRISE EN MAIN
################################################################################

--------------------------------------------------------------------------------
## DÃ©marrage Rapide
--------------------------------------------------------------------------------

# Demarrage rapide

Soyez operationnel avec Hemlock en quelques minutes !

## Votre premier programme

Creez un fichier appele `hello.hml` :

```hemlock
print("Hello, Hemlock!");
```

Executez-le avec l'interpreteur :

```bash
./hemlock hello.hml
```

Ou compilez-le en executable natif :

```bash
./hemlockc hello.hml -o hello
./hello
```

Sortie :
```
Hello, Hemlock!
```

### Interpreteur vs Compilateur

Hemlock offre deux manieres d'executer des programmes :

| Outil | Cas d'utilisation | Verification des types |
|-------|-------------------|------------------------|
| `hemlock` | Scripts rapides, REPL, developpement | A l'execution uniquement |
| `hemlockc` | Binaires de production, meilleures performances | A la compilation (par defaut) |

Le compilateur (`hemlockc`) verifie les types de votre code avant de generer un executable, detectant les erreurs plus tot.

## Syntaxe de base

### Variables

```hemlock
// Les variables sont declarees avec 'let'
let x = 42;
let name = "Alice";
let pi = 3.14159;

// Les annotations de type sont optionnelles
let count: i32 = 100;
let ratio: f64 = 0.618;
```

**Important** : Les points-virgules sont **obligatoires** en Hemlock !

### Types

Hemlock possede un systeme de types riche :

```hemlock
// Entiers
let small: i8 = 127;          // 8 bits signe
let byte: u8 = 255;           // 8 bits non signe
let num: i32 = 2147483647;    // 32 bits signe (par defaut)
let big: i64 = 9223372036854775807;  // 64 bits signe

// Flottants
let f: f32 = 3.14;            // flottant 32 bits
let d: f64 = 2.71828;         // flottant 64 bits (par defaut)

// Chaines et caracteres
let text: string = "Hello";   // chaine UTF-8
let emoji: rune = 'ðŸš€';       // point de code Unicode

// Booleen et null
let flag: bool = true;
let empty = null;
```

### Flux de controle

```hemlock
// Instructions if
if (x > 0) {
    print("positif");
} else if (x < 0) {
    print("negatif");
} else {
    print("zero");
}

// Boucles while
let i = 0;
while (i < 5) {
    print(i);
    i = i + 1;
}

// Boucles for
for (let j = 0; j < 10; j = j + 1) {
    print(j);
}
```

### Fonctions

```hemlock
// Fonction nommee
fn add(a: i32, b: i32): i32 {
    return a + b;
}

let result = add(5, 3);  // 8

// Fonction anonyme
let multiply = fn(x, y) {
    return x * y;
};

print(multiply(4, 7));  // 28
```

## Travailler avec les chaines

Les chaines en Hemlock sont **mutables** et **UTF-8** :

```hemlock
let s = "hello";
s[0] = 'H';              // Maintenant "Hello"
print(s);

// Methodes de chaines
let upper = s.to_upper();     // "HELLO"
let words = "a,b,c".split(","); // ["a", "b", "c"]
let sub = s.substr(1, 3);     // "ell"

// Concatenation
let greeting = "Hello" + ", " + "World!";
print(greeting);  // "Hello, World!"
```

## Tableaux

Tableaux dynamiques avec types mixtes :

```hemlock
let numbers = [1, 2, 3, 4, 5];
print(numbers[0]);      // 1
print(numbers.length);  // 5

// Methodes de tableaux
numbers.push(6);        // [1, 2, 3, 4, 5, 6]
let last = numbers.pop();  // 6
let slice = numbers.slice(1, 4);  // [2, 3, 4]

// Types mixtes autorises
let mixed = [1, "two", true, null];
```

## Objets

Objets de style JavaScript :

```hemlock
// Litteral d'objet
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};

print(person.name);  // "Alice"
person.age = 31;     // Modifier un champ

// Methodes avec 'self'
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    }
};

counter.increment();
print(counter.count);  // 1
```

## Gestion de la memoire

Hemlock utilise la **gestion manuelle de la memoire** :

```hemlock
// Buffer securise (recommande)
let buf = buffer(64);   // Allouer 64 octets
buf[0] = 65;            // Definir le premier octet a 'A'
print(buf[0]);          // 65
free(buf);              // Liberer la memoire

// Pointeur brut (avance)
let ptr = alloc(100);
memset(ptr, 0, 100);    // Remplir avec des zeros
free(ptr);
```

**Important** : Vous devez appeler `free()` pour ce que vous avez alloue avec `alloc()` !

## Gestion des erreurs

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "division par zero";
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    print(result);
} catch (e) {
    print("Erreur : " + e);
} finally {
    print("Termine");
}
```

## Arguments en ligne de commande

Accedez aux arguments du programme via le tableau `args` :

```hemlock
// script.hml
print("Script:", args[0]);
print(`Arguments : ${args.length - 1}`);

let i = 1;
while (i < args.length) {
    print(`  arg ${i}: ${args[i]}`);
    i = i + 1;
}
```

Executez avec :
```bash
./hemlock script.hml hello world
```

Sortie :
```
Script: script.hml
Arguments : 2
  arg 1: hello
  arg 2: world
```

## Entrees/Sorties fichier

```hemlock
// Ecrire dans un fichier
let f = open("data.txt", "w");
f.write("Hello, File!");
f.close();

// Lire depuis un fichier
let f2 = open("data.txt", "r");
let content = f2.read();
print(content);  // "Hello, File!"
f2.close();
```

## Et ensuite ?

Maintenant que vous avez vu les bases, explorez davantage :

- [Tutoriel](#getting-started-tutorial) - Guide complet etape par etape
- [Guide du langage](#language-guide-syntax) - Plongee approfondie dans toutes les fonctionnalites
- [Exemples](../../examples/) - Programmes d'exemple concrets
- [Reference API](#reference-builtins) - Documentation complete de l'API

## Pieges courants

### Oublier les points-virgules

```hemlock
// ERREUR : Point-virgule manquant
let x = 42
let y = 10

// CORRECT
let x = 42;
let y = 10;
```

### Oublier de liberer la memoire

```hemlock
// FUITE DE MEMOIRE
let buf = buffer(100);
// ... utiliser buf ...
// Oublie d'appeler free(buf) !

// CORRECT
let buf = buffer(100);
// ... utiliser buf ...
free(buf);
```

### Les accolades sont obligatoires

```hemlock
// ERREUR : Accolades manquantes
if (x > 0)
    print("positif");

// CORRECT
if (x > 0) {
    print("positif");
}
```

## Obtenir de l'aide

- Lisez la [documentation complete](../README.md)
- Consultez le [repertoire d'exemples](../../examples/)
- Regardez les [fichiers de test](../../tests/) pour des exemples d'utilisation
- Signalez les problemes sur GitHub


--------------------------------------------------------------------------------
## Installation
--------------------------------------------------------------------------------

# Installation

Ce guide vous aidera a compiler et installer Hemlock sur votre systeme.

## Installation rapide (Recommandee)

La maniere la plus simple d'installer Hemlock est d'utiliser le script d'installation en une ligne :

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash
```

Cela telecharge et installe le dernier binaire pre-compile pour votre plateforme (Linux ou macOS, x86_64 ou arm64).

### Options d'installation

```bash
# Installer vers un prefixe personnalise (par defaut : ~/.local)
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local

# Installer une version specifique
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0

# Installer et mettre a jour automatiquement le PATH du shell
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path
```

Apres l'installation, verifiez qu'elle fonctionne :

```bash
hemlock --version
```

---

## Compilation depuis les sources

Si vous preferez compiler depuis les sources ou si les binaires pre-compiles ne fonctionnent pas pour votre systeme, suivez les instructions ci-dessous.

## Prerequis

### Dependances requises

Hemlock necessite les dependances suivantes pour la compilation :

- **Compilateur C** : GCC ou Clang (standard C11)
- **Make** : GNU Make
- **libffi** : Bibliotheque d'interface de fonction etrangere (FFI - Foreign Function Interface) (pour le support FFI)
- **OpenSSL** : Bibliotheque cryptographique (pour les fonctions de hachage : md5, sha1, sha256)
- **libwebsockets** : Support client/serveur WebSocket et HTTP
- **zlib** : Bibliotheque de compression

### Installation des dependances

**macOS :**
```bash
# Installer Homebrew s'il n'est pas deja installe
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Installer les outils en ligne de commande Xcode
xcode-select --install

# Installer les dependances via Homebrew
brew install libffi openssl@3 libwebsockets
```

**Remarque pour les utilisateurs macOS** : Le Makefile detecte automatiquement les installations Homebrew et configure les chemins d'inclusion/bibliotheque corrects. Hemlock prend en charge les architectures Intel (x86_64) et Apple Silicon (arm64).

**Ubuntu/Debian :**
```bash
sudo apt-get update
sudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev
```

**Fedora/RHEL :**
```bash
sudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel
```

**Arch Linux :**
```bash
sudo pacman -S base-devel libffi openssl libwebsockets zlib
```

## Compilation depuis les sources

### 1. Cloner le depot

```bash
git clone https://github.com/hemlang/hemlock.git
cd hemlock
```

### 2. Compiler Hemlock

```bash
make
```

Cela compilera l'interpreteur Hemlock et placera l'executable dans le repertoire courant.

### 3. Verifier l'installation

```bash
./hemlock --version
```

Vous devriez voir les informations de version de Hemlock.

### 4. Tester la compilation

Executez la suite de tests pour vous assurer que tout fonctionne correctement :

```bash
make test
```

Tous les tests devraient reussir. Si vous constatez des echecs, veuillez les signaler en creant une issue.

## Installation systeme (Optionnel)

Pour installer Hemlock a l'echelle du systeme (par exemple, dans `/usr/local/bin`) :

```bash
sudo make install
```

Cela vous permet d'executer `hemlock` de n'importe ou sans specifier le chemin complet.

## Executer Hemlock

### REPL interactif

Demarrez la boucle lecture-evaluation-affichage (REPL - Read-Eval-Print Loop) :

```bash
./hemlock
```

Vous verrez une invite ou vous pouvez taper du code Hemlock :

```
Hemlock REPL
> print("Hello, World!");
Hello, World!
> let x = 42;
> print(x * 2);
84
>
```

Quittez le REPL avec `Ctrl+D` ou `Ctrl+C`.

### Executer des programmes

Executez un script Hemlock :

```bash
./hemlock program.hml
```

Avec des arguments en ligne de commande :

```bash
./hemlock program.hml arg1 arg2 "argument avec des espaces"
```

## Structure des repertoires

Apres la compilation, votre repertoire Hemlock ressemblera a ceci :

```
hemlock/
â”œâ”€â”€ hemlock           # Executable de l'interpreteur compile
â”œâ”€â”€ src/              # Code source
â”œâ”€â”€ include/          # Fichiers d'en-tete
â”œâ”€â”€ tests/            # Suite de tests
â”œâ”€â”€ examples/         # Programmes d'exemple
â”œâ”€â”€ docs/             # Documentation
â”œâ”€â”€ stdlib/           # Bibliotheque standard
â”œâ”€â”€ Makefile          # Configuration de compilation
â””â”€â”€ README.md         # README du projet
```

## Options de compilation

### Compilation de debogage

Compiler avec les symboles de debogage et sans optimisation :

```bash
make debug
```

### Nettoyage de la compilation

Supprimer tous les fichiers compiles :

```bash
make clean
```

Recompiler depuis zero :

```bash
make clean && make
```

## Depannage

### macOS : Erreurs de bibliotheque introuvable

Si vous obtenez des erreurs concernant des bibliotheques manquantes (`-lcrypto`, `-lffi`, etc.) :

1. Assurez-vous que les dependances Homebrew sont installees :
   ```bash
   brew install libffi openssl@3 libwebsockets
   ```

2. Verifiez les chemins Homebrew :
   ```bash
   brew --prefix libffi
   brew --prefix openssl
   ```

3. Le Makefile devrait detecter automatiquement ces chemins. Si ce n'est pas le cas, verifiez que `brew` est dans votre PATH :
   ```bash
   which brew
   ```

### macOS : Erreurs de types BSD (`u_int`, `u_char` non trouves)

Si vous voyez des erreurs concernant des noms de types inconnus comme `u_int` ou `u_char` :

1. Cela a ete corrige dans v1.0.0+ en utilisant `_DARWIN_C_SOURCE` au lieu de `_POSIX_C_SOURCE`
2. Assurez-vous d'avoir la derniere version du code
3. Nettoyez et recompilez :
   ```bash
   make clean && make
   ```

### Linux : libffi non trouve

Si vous obtenez des erreurs concernant `ffi.h` manquant ou `-lffi` :

1. Assurez-vous que `libffi-dev` est installe (voir les dependances ci-dessus)
2. Verifiez si `pkg-config` peut le trouver :
   ```bash
   pkg-config --cflags --libs libffi
   ```
3. S'il n'est pas trouve, vous devrez peut-etre definir `PKG_CONFIG_PATH` :
   ```bash
   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH
   ```

### Erreurs de compilation

Si vous rencontrez des erreurs de compilation :

1. Assurez-vous d'avoir un compilateur compatible C11
2. Sur macOS, essayez d'utiliser Clang (par defaut) :
   ```bash
   make CC=clang
   ```
3. Sur Linux, essayez d'utiliser GCC :
   ```bash
   make CC=gcc
   ```
4. Verifiez que toutes les dependances sont installees
5. Essayez de recompiler depuis zero :
   ```bash
   make clean && make
   ```

### Echecs de tests

Si les tests echouent :

1. Verifiez que vous avez la derniere version du code
2. Essayez de recompiler depuis zero :
   ```bash
   make clean && make test
   ```
3. Sur macOS, assurez-vous d'avoir les derniers outils en ligne de commande Xcode :
   ```bash
   xcode-select --install
   ```
4. Signalez le probleme sur GitHub avec :
   - Votre plateforme (version macOS / distribution Linux)
   - Architecture (x86_64 / arm64)
   - Sortie des tests
   - Sortie de `make -v` et `gcc --version` (ou `clang --version`)

## Prochaines etapes

- [Guide de demarrage rapide](#getting-started-quick-start) - Ecrivez votre premier programme Hemlock
- [Tutoriel](#getting-started-tutorial) - Apprenez Hemlock etape par etape
- [Guide du langage](#language-guide-syntax) - Explorez les fonctionnalites de Hemlock


--------------------------------------------------------------------------------
## Parcours d'Apprentissage
--------------------------------------------------------------------------------

# Parcours d'apprentissage

Differents objectifs necessitent differentes connaissances. Choisissez le parcours qui correspond a ce que vous voulez construire.

---

## Parcours 1 : Scripts rapides et automatisation

**Objectif :** Ecrire des scripts pour automatiser des taches, traiter des fichiers et accomplir des choses.

**Temps jusqu'a la productivite :** Rapide - vous pouvez commencer a ecrire des scripts utiles immediatement.

### Ce que vous apprendrez

1. **[Demarrage rapide](#getting-started-quick-start)** - Votre premier programme, syntaxe de base
2. **[Chaines](#language-guide-strings)** - Traitement de texte, division, recherche
3. **[Tableaux](#language-guide-arrays)** - Listes, filtrage, transformation de donnees
4. **[E/S fichier](#advanced-file-io)** - Lecture et ecriture de fichiers
5. **[Arguments en ligne de commande](#advanced-command-line-args)** - Obtenir des entrees des utilisateurs

### A ignorer pour l'instant

- Gestion de la memoire (automatique pour les scripts)
- Async/concurrence (excessif pour les scripts simples)
- FFI (necessaire uniquement pour l'interoperabilite C)

### Projet d'exemple : Renommeur de fichiers

```hemlock
import { list_dir, rename } from "@stdlib/fs";

// Renommer tous les fichiers .txt en .md
let files = list_dir(".");
for (file in files) {
    if (file.ends_with(".txt")) {
        let new_name = file.replace(".txt", ".md");
        rename(file, new_name);
        print(`Renomme : ${file} -> ${new_name}`);
    }
}
```

---

## Parcours 2 : Traitement et analyse de donnees

**Objectif :** Analyser des donnees, les transformer, generer des rapports.

**Temps jusqu'a la productivite :** Rapide - les methodes de chaines et de tableaux de Hemlock rendent cela facile.

### Ce que vous apprendrez

1. **[Demarrage rapide](#getting-started-quick-start)** - Bases
2. **[Chaines](#language-guide-strings)** - Analyse, division, formatage
3. **[Tableaux](#language-guide-arrays)** - map, filter, reduce pour la transformation de donnees
4. **[Objets](#language-guide-objects)** - Donnees structurees
5. **Bibliotheque standard :**
   - **[@stdlib/json](#stdlib-json)** - Analyse JSON
   - **[@stdlib/csv](#stdlib-csv)** - Fichiers CSV
   - **[@stdlib/fs](#stdlib-fs)** - Operations sur fichiers

### Projet d'exemple : Analyseur CSV

```hemlock
import { read_file } from "@stdlib/fs";
import { parse } from "@stdlib/csv";

let data = parse(read_file("sales.csv"));

// Calculer le total des ventes
let total = 0;
for (row in data) {
    total = total + f64(row.amount);
}

print(`Total des ventes : ${total} euros`);

// Trouver le meilleur vendeur
let top = data[0];
for (row in data) {
    if (f64(row.amount) > f64(top.amount)) {
        top = row;
    }
}

print(`Meilleure vente : ${top.product} - ${top.amount} euros`);
```

---

## Parcours 3 : Programmation web et reseau

**Objectif :** Construire des clients HTTP, travailler avec des API, creer des serveurs.

**Temps jusqu'a la productivite :** Moyen - necessite de comprendre les bases de l'asynchrone.

### Ce que vous apprendrez

1. **[Demarrage rapide](#getting-started-quick-start)** - Bases
2. **[Fonctions](#language-guide-functions)** - Callbacks et fermetures (closures)
3. **[Gestion des erreurs](#language-guide-error-handling)** - try/catch pour les erreurs reseau
4. **[Async et concurrence](#advanced-async-concurrency)** - spawn, await, channels
5. **Bibliotheque standard :**
   - **[@stdlib/http](#stdlib-http)** - Requetes HTTP
   - **[@stdlib/json](#stdlib-json)** - JSON pour les API
   - **[@stdlib/net](#stdlib-net)** - Sockets TCP/UDP
   - **[@stdlib/url](#stdlib-url)** - Analyse d'URL

### Projet d'exemple : Client API

```hemlock
import { http_get, http_post } from "@stdlib/http";
import { parse, stringify } from "@stdlib/json";

// Requete GET
let response = http_get("https://api.example.com/users");
let users = parse(response.body);

for (user in users) {
    print(`${user.name} : ${user.email}`);
}

// Requete POST
let new_user = { name: "Alice", email: "alice@example.com" };
let result = http_post("https://api.example.com/users", {
    body: stringify(new_user),
    headers: { "Content-Type": "application/json" }
});

print(`Utilisateur cree avec l'ID : ${parse(result.body).id}`);
```

---

## Parcours 4 : Programmation systeme

**Objectif :** Ecrire du code bas niveau, travailler avec la memoire, interfacer avec des bibliotheques C.

**Temps jusqu'a la productivite :** Plus long - necessite de comprendre la gestion de la memoire.

### Ce que vous apprendrez

1. **[Demarrage rapide](#getting-started-quick-start)** - Bases
2. **[Types](#language-guide-types)** - Comprendre i32, u8, ptr, etc.
3. **[Gestion de la memoire](#language-guide-memory)** - alloc, free, buffers
4. **[FFI](#advanced-ffi)** - Appeler des fonctions C
5. **[Signaux](#advanced-signals)** - Gestion des signaux

### Concepts cles

**Liste de verification de la securite memoire :**
- [ ] Chaque `alloc()` a un `free()` correspondant
- [ ] Utiliser `buffer()` sauf si vous avez besoin d'un `ptr` brut
- [ ] Mettre les pointeurs a `null` apres liberation
- [ ] Utiliser `try/finally` pour garantir le nettoyage

**Correspondance des types pour FFI :**
| Hemlock | C |
|---------|---|
| `i8` | `char` / `int8_t` |
| `i32` | `int` |
| `i64` | `long` (64 bits) |
| `u8` | `unsigned char` |
| `f64` | `double` |
| `ptr` | `void*` |

### Projet d'exemple : Pool de memoire personnalise

```hemlock
// Allocateur simple par incrementations (bump allocator)
let pool_size = 1024 * 1024;  // 1 Mo
let pool = alloc(pool_size);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > pool_size) {
        throw "Pool epuise";
    }
    let p = pool + pool_offset;
    pool_offset = pool_offset + size;
    return p;
}

fn pool_reset() {
    pool_offset = 0;
}

fn pool_destroy() {
    free(pool);
}

// Utilisation
let a = pool_alloc(100);
let b = pool_alloc(200);
memset(a, 0, 100);
memset(b, 0, 200);

pool_reset();  // Reutiliser toute la memoire
pool_destroy();  // Nettoyer
```

---

## Parcours 5 : Programmes paralleles et concurrents

**Objectif :** Executer du code sur plusieurs coeurs CPU, construire des applications reactives.

**Temps jusqu'a la productivite :** Moyen - la syntaxe async est simple, mais raisonner sur le parallelisme demande de la pratique.

### Ce que vous apprendrez

1. **[Demarrage rapide](#getting-started-quick-start)** - Bases
2. **[Fonctions](#language-guide-functions)** - Fermetures (closures) (important pour l'async)
3. **[Async et concurrence](#advanced-async-concurrency)** - Plongee complete
4. **[Atomiques](#advanced-atomics)** - Programmation sans verrous (lock-free)

### Concepts cles

**Modele async de Hemlock :**
- `async fn` - Definir une fonction qui peut s'executer sur un autre thread
- `spawn(fn, args...)` - Commencer l'execution, retourne un handle de tache
- `join(task)` ou `await task` - Attendre la fin, obtenir le resultat
- `channel(size)` - Creer une file pour envoyer des donnees entre les taches

**Important :** Les taches recoivent des *copies* des valeurs. Si vous passez un pointeur, vous etes responsable de vous assurer que la memoire reste valide jusqu'a ce que la tache se termine.

### Projet d'exemple : Processeur de fichiers parallele

```hemlock
import { list_dir, read_file } from "@stdlib/fs";

async fn process_file(path: string): i32 {
    let content = read_file(path);
    let lines = content.split("\n");
    return lines.length;
}

// Traiter tous les fichiers en parallele
let files = list_dir("data/");
let tasks = [];

for (file in files) {
    if (file.ends_with(".txt")) {
        let task = spawn(process_file, "data/" + file);
        tasks.push({ name: file, task: task });
    }
}

// Collecter les resultats
let total_lines = 0;
for (item in tasks) {
    let count = join(item.task);
    print(`${item.name} : ${count} lignes`);
    total_lines = total_lines + count;
}

print(`Total : ${total_lines} lignes`);
```

---

## Ce qu'il faut apprendre en premier (Tous les parcours)

Quel que soit votre objectif, commencez par ces fondamentaux :

### Semaine 1 : Bases essentielles
1. **[Demarrage rapide](#getting-started-quick-start)** - Ecrire et executer votre premier programme
2. **[Syntaxe](#language-guide-syntax)** - Variables, operateurs, flux de controle
3. **[Fonctions](#language-guide-functions)** - Definir et appeler des fonctions

### Semaine 2 : Manipulation des donnees
4. **[Chaines](#language-guide-strings)** - Manipulation de texte
5. **[Tableaux](#language-guide-arrays)** - Collections et iteration
6. **[Objets](#language-guide-objects)** - Donnees structurees

### Semaine 3 : Robustesse
7. **[Gestion des erreurs](#language-guide-error-handling)** - try/catch/throw
8. **[Modules](#language-guide-modules)** - Import/export, utilisation de la stdlib

### Ensuite : Choisissez votre parcours ci-dessus

---

## Aide-memoire : Venant d'autres langages

### Depuis Python

| Python | Hemlock | Notes |
|--------|---------|-------|
| `x = 42` | `let x = 42;` | Points-virgules obligatoires |
| `def fn():` | `fn name() { }` | Accolades obligatoires |
| `if x:` | `if (x) { }` | Parentheses et accolades obligatoires |
| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | Boucles for de style C |
| `for item in list:` | `for (item in array) { }` | For-in fonctionne pareil |
| `list.append(x)` | `array.push(x);` | Nom de methode different |
| `len(s)` | `s.length` ou `len(s)` | Les deux fonctionnent |
| Memoire automatique | Manuelle pour `ptr` | La plupart des types se nettoient automatiquement |

### Depuis JavaScript

| JavaScript | Hemlock | Notes |
|------------|---------|-------|
| `let x = 42` | `let x = 42;` | Pareil (points-virgules obligatoires) |
| `const x = 42` | `let x = 42;` | Pas de mot-cle const |
| `function fn()` | `fn name() { }` | Mot-cle different |
| `() => x` | `fn() { return x; }` | Pas de fonctions flechees |
| `async/await` | `async/await` | Meme syntaxe |
| `Promise` | `spawn/join` | Modele different |
| GC automatique | Manuel pour `ptr` | La plupart des types se nettoient automatiquement |

### Depuis C/C++

| C | Hemlock | Notes |
|---|---------|-------|
| `int x = 42;` | `let x: i32 = 42;` | Type apres les deux-points |
| `malloc(n)` | `alloc(n)` | Meme concept |
| `free(p)` | `free(p)` | Pareil |
| `char* s = "hi"` | `let s = "hi";` | Les chaines sont gerees |
| `#include` | `import { } from` | Imports de modules |
| Tout manuel | Auto pour la plupart des types | Seul `ptr` necessite une gestion manuelle |

---

## Obtenir de l'aide

- **[Glossaire](../glossary.md)** - Definitions des termes de programmation
- **[Exemples](../../examples/)** - Programmes complets fonctionnels
- **[Tests](../../tests/)** - Voir comment les fonctionnalites sont utilisees
- **GitHub Issues** - Poser des questions, signaler des bugs

---

## Niveaux de difficulte

Dans toute la documentation, vous verrez ces marqueurs :

| Marqueur | Signification |
|----------|---------------|
| **Debutant** | Aucune experience de programmation prealable necessaire |
| **Intermediaire** | Suppose des connaissances de base en programmation |
| **Avance** | Necessite une comprehension des concepts systeme |

Si quelque chose marque "Debutant" vous deroute, consultez le [Glossaire](../glossary.md) pour les definitions des termes.


--------------------------------------------------------------------------------
## Tutoriel
--------------------------------------------------------------------------------

# Tutoriel Hemlock

Un guide complet etape par etape pour apprendre Hemlock.

## Table des matieres

1. [Hello World](#hello-world)
2. [Variables et types](#variables-et-types)
3. [Arithmetique et operations](#arithmetique-et-operations)
4. [Flux de controle](#flux-de-controle)
5. [Fonctions](#fonctions)
6. [Chaines et runes](#chaines-et-runes)
7. [Tableaux](#tableaux)
8. [Objets](#objets)
9. [Gestion de la memoire](#gestion-de-la-memoire)
10. [Gestion des erreurs](#gestion-des-erreurs)
11. [Entrees/Sorties fichier](#entreessorties-fichier)
12. [Mettre tout ensemble](#mettre-tout-ensemble)

## Hello World

Commencons par le traditionnel premier programme :

```hemlock
print("Hello, World!");
```

Enregistrez ceci sous `hello.hml` et executez :

```bash
./hemlock hello.hml
```

**Points cles :**
- `print()` est une fonction integree qui affiche sur stdout
- Les chaines sont entourees de guillemets doubles
- Les points-virgules sont **obligatoires**

## Variables et types

### Declaration de variables

```hemlock
// Declaration de variable simple
let x = 42;
let name = "Alice";
let pi = 3.14159;

print(x);      // 42
print(name);   // Alice
print(pi);     // 3.14159
```

### Annotations de type

Bien que les types soient inferes par defaut, vous pouvez etre explicite :

```hemlock
let age: i32 = 30;
let height: f64 = 5.9;
let initial: rune = 'A';
let active: bool = true;
```

### Inference de type

Hemlock infere les types en fonction des valeurs :

```hemlock
let small = 42;              // i32 (tient dans 32 bits)
let large = 5000000000;      // i64 (trop grand pour i32)
let decimal = 3.14;          // f64 (par defaut pour les flottants)
let text = "hello";          // string
let flag = true;             // bool
```

### Verification de type

```hemlock
// Verifier les types avec typeof()
print(typeof(42));        // "i32"
print(typeof(3.14));      // "f64"
print(typeof("hello"));   // "string"
print(typeof(true));      // "bool"
print(typeof(null));      // "null"
```

## Arithmetique et operations

### Arithmetique de base

```hemlock
let a = 10;
let b = 3;

print(a + b);   // 13
print(a - b);   // 7
print(a * b);   // 30
print(a / b);   // 3 (division entiere)
print(a == b);  // false
print(a > b);   // true
```

### Promotion de type

Lors du melange de types, Hemlock promeut vers le type plus grand/plus precis :

```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // result est f64 (10.0 + 3.5 = 13.5)

print(result);       // 13.5
print(typeof(result)); // "f64"
```

### Operations bit a bit

```hemlock
let a = 12;  // 1100 en binaire
let b = 10;  // 1010 en binaire

print(a & b);   // 8  (ET)
print(a | b);   // 14 (OU)
print(a ^ b);   // 6  (OU exclusif)
print(a << 1);  // 24 (decalage a gauche)
print(a >> 1);  // 6  (decalage a droite)
print(~a);      // -13 (NON)
```

## Flux de controle

### Instructions if

```hemlock
let x = 10;

if (x > 0) {
    print("positif");
} else if (x < 0) {
    print("negatif");
} else {
    print("zero");
}
```

**Remarque :** Les accolades sont **toujours obligatoires**, meme pour les instructions simples.

### Boucles while

```hemlock
let count = 0;
while (count < 5) {
    print(`Compteur : ${count}`);
    count = count + 1;
}
```

### Boucles for

```hemlock
// Boucle for de style C
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}

// Boucle for-in (tableaux)
let items = [10, 20, 30, 40];
for (let item in items) {
    print(`Element : ${item}`);
}
```

### Instructions switch

```hemlock
let day = 3;

switch (day) {
    case 1:
        print("Lundi");
        break;
    case 2:
        print("Mardi");
        break;
    case 3:
        print("Mercredi");
        break;
    default:
        print("Autre jour");
        break;
}
```

### Break et continue

```hemlock
// Break : sortir de la boucle prematurement
let i = 0;
while (i < 10) {
    if (i == 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// Affiche : 0, 1, 2, 3, 4

// Continue : passer a l'iteration suivante
for (let j = 0; j < 5; j = j + 1) {
    if (j == 2) {
        continue;
    }
    print(j);
}
// Affiche : 0, 1, 3, 4
```

## Fonctions

### Fonctions nommees

```hemlock
fn greet(name: string): string {
    return "Bonjour, " + name + " !";
}

let message = greet("Alice");
print(message);  // "Bonjour, Alice !"
```

### Fonctions anonymes

```hemlock
let add = fn(a, b) {
    return a + b;
};

print(add(5, 3));  // 8
```

### Recursivite

```hemlock
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

print(factorial(5));  // 120
```

### Fermetures (Closures)

Les fonctions capturent leur environnement :

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
print(counter());  // 3
```

### Fonctions d'ordre superieur

```hemlock
fn apply(f, x) {
    return f(x);
}

fn double(n) {
    return n * 2;
}

let result = apply(double, 21);
print(result);  // 42
```

## Chaines et runes

### Bases des chaines

Les chaines sont **mutables** et **UTF-8** :

```hemlock
let s = "hello";
print(s.length);      // 5 (nombre de caracteres)
print(s.byte_length); // 5 (nombre d'octets)

// Mutation
s[0] = 'H';
print(s);  // "Hello"
```

### Methodes de chaines

```hemlock
let text = "  Hello, World!  ";

// Conversion de casse
print(text.to_upper());  // "  HELLO, WORLD!  "
print(text.to_lower());  // "  hello, world!  "

// Suppression des espaces
print(text.trim());      // "Hello, World!"

// Extraction de sous-chaines
let hello = text.substr(2, 5);  // "Hello"
let world = text.slice(9, 14);  // "World"

// Recherche
let pos = text.find("World");   // 9
let has = text.contains("o");   // true

// Division
let parts = "a,b,c".split(","); // ["a", "b", "c"]

// Remplacement
let s = "hello world".replace("world", "there");
print(s);  // "hello there"
```

### Runes (points de code Unicode)

```hemlock
let ch: rune = 'A';
let emoji: rune = 'ðŸš€';

print(ch);      // 'A'
print(emoji);   // U+1F680

// Concatenation rune + chaine
let msg = '>' + " Important";
print(msg);  // "> Important"

// Convertir entre rune et entier
let code: i32 = ch;     // 65 (code ASCII)
let r: rune = 128640;   // U+1F680 (ðŸš€)
```

## Tableaux

### Bases des tableaux

```hemlock
let numbers = [1, 2, 3, 4, 5];
print(numbers[0]);      // 1
print(numbers.length);  // 5

// Modifier les elements
numbers[2] = 99;
print(numbers[2]);  // 99
```

### Methodes de tableaux

```hemlock
let arr = [10, 20, 30];

// Ajouter/supprimer a la fin
arr.push(40);           // [10, 20, 30, 40]
let last = arr.pop();   // 40, arr est maintenant [10, 20, 30]

// Ajouter/supprimer au debut
arr.unshift(5);         // [5, 10, 20, 30]
let first = arr.shift(); // 5, arr est maintenant [10, 20, 30]

// Inserer/supprimer a un index
arr.insert(1, 15);      // [10, 15, 20, 30]
let removed = arr.remove(2);  // 20

// Recherche
let index = arr.find(15);     // 1
let has = arr.contains(10);   // true

// Tranche
let slice = arr.slice(0, 2);  // [10, 15]

// Joindre en chaine
let text = arr.join(", ");    // "10, 15, 30"
```

### Iteration

```hemlock
let items = ["pomme", "banane", "cerise"];

// Boucle for-in
for (let item in items) {
    print(item);
}

// Iteration manuelle
let i = 0;
while (i < items.length) {
    print(items[i]);
    i = i + 1;
}
```

## Objets

### Litteraux d'objets

```hemlock
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};

print(person.name);  // "Alice"
print(person.age);   // 30

// Ajouter/modifier des champs
person.email = "alice@example.com";
person.age = 31;
```

### Methodes et `self`

```hemlock
let calculator = {
    value: 0,
    add: fn(x) {
        self.value = self.value + x;
    },
    get: fn() {
        return self.value;
    }
};

calculator.add(10);
calculator.add(5);
print(calculator.get());  // 15
```

### Definitions de types (Duck Typing)

```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,  // Optionnel avec valeur par defaut
}

let p = { name: "Bob", age: 25 };
let typed: Person = p;  // Le duck typing valide la structure

print(typeof(typed));   // "Person"
print(typed.active);    // true (valeur par defaut appliquee)
```

### Serialisation JSON

```hemlock
let obj = { x: 10, y: 20, name: "test" };

// Objet vers JSON
let json = obj.serialize();
print(json);  // {"x":10,"y":20,"name":"test"}

// JSON vers objet
let restored = json.deserialize();
print(restored.name);  // "test"
```

## Gestion de la memoire

### Buffers securises (Recommande)

```hemlock
// Allouer un buffer
let buf = buffer(10);
print(buf.length);    // 10
print(buf.capacity);  // 10

// Definir des valeurs (verification des limites)
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

// Acceder aux valeurs
print(buf[0]);  // 65

// Doit etre libere a la fin
free(buf);
```

### Pointeurs bruts (Avance)

```hemlock
// Allouer de la memoire brute
let ptr = alloc(100);

// Remplir avec des zeros
memset(ptr, 0, 100);

// Copier des donnees
let src = alloc(50);
memcpy(ptr, src, 50);

// Liberer les deux
free(src);
free(ptr);
```

### Fonctions de memoire

```hemlock
// Reallouer
let p = alloc(64);
p = realloc(p, 128);  // Redimensionner a 128 octets
free(p);

// Allocation typee (futur)
// let arr = talloc(i32, 100);  // Tableau de 100 i32
```

## Gestion des erreurs

### Try/Catch

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "division par zero";
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    print(result);
} catch (e) {
    print("Erreur : " + e);
}
// Sortie : Erreur : division par zero
```

### Bloc finally

```hemlock
let file = null;

try {
    file = open("data.txt", "r");
    let content = file.read();
    print(content);
} catch (e) {
    print("Erreur : " + e);
} finally {
    // S'execute toujours
    if (file != null) {
        file.close();
    }
}
```

### Lancer des objets

```hemlock
try {
    throw { code: 404, message: "Non trouve" };
} catch (e) {
    print(`Erreur ${e.code} : ${e.message}`);
}
// Sortie : Erreur 404 : Non trouve
```

### Panic (Erreurs irrecuperables)

```hemlock
fn validate(x) {
    if (x < 0) {
        panic("x doit etre non negatif");
    }
    return x * 2;
}

validate(-5);  // Le programme se termine avec : panic: x doit etre non negatif
```

## Entrees/Sorties fichier

### Lecture de fichiers

```hemlock
// Lire le fichier entier
let f = open("data.txt", "r");
let content = f.read();
print(content);
f.close();

// Lire un nombre specifique d'octets
let f2 = open("data.txt", "r");
let chunk = f2.read(100);  // Lire 100 octets
f2.close();
```

### Ecriture de fichiers

```hemlock
// Ecrire du texte
let f = open("output.txt", "w");
f.write("Bonjour, Fichier !\n");
f.write("Deuxieme ligne\n");
f.close();

// Ajouter au fichier
let f2 = open("output.txt", "a");
f2.write("Ligne ajoutee\n");
f2.close();
```

### E/S binaires

```hemlock
// Ecrire des donnees binaires
let buf = buffer(256);
buf[0] = 255;
buf[1] = 128;

let f = open("data.bin", "w");
f.write_bytes(buf);
f.close();

// Lire des donnees binaires
let f2 = open("data.bin", "r");
let data = f2.read_bytes(256);
print(data[0]);  // 255
f2.close();

free(buf);
free(data);
```

### Proprietes de fichier

```hemlock
let f = open("/chemin/vers/fichier.txt", "r");

print(f.path);    // "/chemin/vers/fichier.txt"
print(f.mode);    // "r"
print(f.closed);  // false

f.close();
print(f.closed);  // true
```

## Mettre tout ensemble

Construisons un simple programme de comptage de mots :

```hemlock
// wordcount.hml - Compter les mots dans un fichier

fn count_words(filename: string): i32 {
    let file = null;
    let count = 0;

    try {
        file = open(filename, "r");
        let content = file.read();

        // Diviser par les espaces et compter
        let words = content.split(" ");
        count = words.length;

    } catch (e) {
        print("Erreur de lecture du fichier : " + e);
        return -1;
    } finally {
        if (file != null) {
            file.close();
        }
    }

    return count;
}

// Programme principal
if (args.length < 2) {
    print("Usage : " + args[0] + " <nom_fichier>");
} else {
    let filename = args[1];
    let words = count_words(filename);

    if (words >= 0) {
        print(`Nombre de mots : ${words}`);
    }
}
```

Executez avec :
```bash
./hemlock wordcount.hml data.txt
```

## Prochaines etapes

Felicitations ! Vous avez appris les bases de Hemlock. Voici ce que vous pouvez explorer ensuite :

- [Async et concurrence](#advanced-async-concurrency) - Veritable multithreading
- [FFI](#advanced-ffi) - Appeler des fonctions C
- [Gestion des signaux](#advanced-signals) - Signaux de processus
- [Reference API](#reference-builtins) - Documentation complete de l'API
- [Exemples](../../examples/) - Plus de programmes concrets

## Exercices pratiques

Essayez de construire ces programmes pour vous entrainer :

1. **Calculatrice** : Implementez une calculatrice simple avec +, -, *, /
2. **Copie de fichier** : Copiez un fichier vers un autre
3. **Fibonacci** : Generez les nombres de Fibonacci
4. **Analyseur JSON** : Lisez et analysez des fichiers JSON
5. **Processeur de texte** : Trouvez et remplacez du texte dans des fichiers

Bon codage avec Hemlock !



################################################################################
# GUIDE DU LANGAGE
################################################################################

--------------------------------------------------------------------------------
## ChaÃ®nes de CaractÃ¨res
--------------------------------------------------------------------------------

# Chaines

Les chaines Hemlock sont des **sequences mutables UTF-8 de premiere classe** avec un support Unicode complet et un ensemble riche de methodes pour le traitement de texte. Contrairement a de nombreux langages, les chaines Hemlock sont mutables et fonctionnent nativement avec les points de code Unicode.

## Apercu

```hemlock
let s = "hello";
s[0] = 'H';             // muter avec rune (maintenant "Hello")
print(s.length);        // 5 (compte de points de code)
let c = s[0];           // retourne rune (point de code Unicode)
let msg = s + " world"; // concatenation
let emoji = "rocket";
print(emoji.length);    // 1 (un point de code)
print(emoji.byte_length); // 4 (quatre octets UTF-8)
```

## Proprietes

Les chaines Hemlock ont ces caracteristiques cles :

- **Encodage UTF-8** - Support Unicode complet (U+0000 a U+10FFFF)
- **Mutable** - Contrairement aux chaines Python, JavaScript et Java
- **Indexation basee sur les points de code** - Retourne `rune` (point de code Unicode), pas un octet
- **Allouee sur le tas** - Avec suivi de capacite interne
- **Deux proprietes de longueur** :
  - `.length` - Compte de points de code (nombre de caracteres)
  - `.byte_length` - Compte d'octets (taille d'encodage UTF-8)

## Comportement UTF-8

Toutes les operations sur les chaines fonctionnent avec les **points de code** (caracteres), pas les octets :

```hemlock
let text = "Helloworld";
print(text.length);        // 11 (points de code)
print(text.byte_length);   // 15 (octets, emoji fait 4 octets)

// L'indexation utilise les points de code
let h = text[0];           // 'H' (rune)
let rocket = text[5];      // 'rocket' (rune)
```

**Les caracteres multi-octets comptent comme un :**
```hemlock
"Hello".length;      // 5
"rocket".length;     // 1 (un emoji)
"ni hao".length;     // 2 (deux caracteres chinois)
"cafe".length;       // 4 (e est un point de code)
```

## Litteraux de chaine

```hemlock
// Chaines basiques
let s1 = "hello";
let s2 = "world";

// Avec sequences d'echappement
let s3 = "Ligne 1\nLigne 2\ttabulation";
let s4 = "Citation: \"Bonjour\"";
let s5 = "Antislash: \\";

// Caracteres Unicode
let s6 = "rocket Emoji";
let s7 = "zhongwen zifu";
```

## Chaines de modele (interpolation de chaine)

Utilisez les backticks pour les chaines de modele avec des expressions embarquees :

```hemlock
let name = "Alice";
let age = 30;

// Interpolation basique
let greeting = `Bonjour, ${name}!`;           // "Bonjour, Alice!"
let info = `${name} a ${age} ans`;            // "Alice a 30 ans"

// Expressions dans l'interpolation
let x = 5;
let y = 10;
let sum = `${x} + ${y} = ${x + y}`;           // "5 + 10 = 15"

// Appels de methode
let upper = `Nom: ${name.to_upper()}`;        // "Nom: ALICE"

// Objets imbriques
let person = { name: "Bob", city: "NYC" };
let desc = `${person.name} vit a ${person.city}`;  // "Bob vit a NYC"

// Multi-lignes (preserve les sauts de ligne)
let multi = `Ligne 1
Ligne 2
Ligne 3`;
```

**Fonctionnalites des chaines de modele :**
- Les expressions dans `${...}` sont evaluees et converties en chaines
- Toute expression valide peut etre utilisee (variables, appels de fonction, arithmetique)
- Les chaines backtick supportent les memes sequences d'echappement que les chaines regulieres
- Utile pour construire des chaines dynamiques sans concatenation

### Echappement dans les chaines de modele

Pour inclure un litteral `${` dans une chaine de modele, echappez le signe dollar :

```hemlock
let price = 100;
let text = `Prix: \${price} ou ${price}`;
// "Prix: ${price} ou 100"

// Backtick litteral
let code = `Utilisez \` pour les chaines de modele`;
// "Utilisez ` pour les chaines de modele"
```

### Expressions complexes

Les chaines de modele peuvent contenir n'importe quelle expression valide :

```hemlock
// Expressions ternaires
let age = 25;
let status = `Statut: ${age >= 18 ? "adulte" : "mineur"}`;

// Acces tableau
let items = ["pomme", "banane", "cerise"];
let first = `Premier element: ${items[0]}`;

// Appels de fonction avec arguments
fn format_price(p) { return p + " EUR"; }
let msg = `Total: ${format_price(99.99)}`;  // "Total: 99.99 EUR"

// Appels de methode chaines
let name = "alice";
let formatted = `Bonjour, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;
// "Bonjour, Alice!"
```

### Chaines de modele vs concatenation

Les chaines de modele sont souvent plus claires que la concatenation :

```hemlock
// Concatenation (plus difficile a lire)
let msg1 = "Bonjour, " + name + "! Vous avez " + count + " messages.";

// Chaine de modele (plus facile a lire)
let msg2 = `Bonjour, ${name}! Vous avez ${count} messages.`;
```

## Indexation et mutation

### Lecture de caracteres

L'indexation retourne une `rune` (point de code Unicode) :

```hemlock
let s = "Hello";
let first = s[0];      // 'H' (rune)
let last = s[4];       // 'o' (rune)

// Exemple UTF-8
let emoji = "Hi!";
let rocket = emoji[2];  // 'rocket' (rune a l'index de point de code 2)
```

### Ecriture de caracteres

Les chaines sont mutables - vous pouvez modifier des caracteres individuels :

```hemlock
let s = "hello";
s[0] = 'H';            // Maintenant "Hello"
s[4] = '!';            // Maintenant "Hell!"

// Avec Unicode
let msg = "Go!";
msg[0] = 'rocket';     // Maintenant "rocketo!"
```

## Concatenation

Utilisez `+` pour concatener les chaines :

```hemlock
let greeting = "Hello" + " " + "World";  // "Hello World"

// Avec variables
let name = "Alice";
let msg = "Salut, " + name + "!";  // "Salut, Alice!"

// Avec runes (voir documentation Runes)
let s = "Hello" + '!';          // "Hello!"
```

## Methodes de chaine

Hemlock fournit 19 methodes de chaine pour une manipulation de texte complete.

### Sous-chaine et decoupage

**`substr(start, length)`** - Extraire une sous-chaine par position et longueur :
```hemlock
let s = "hello world";
let sub = s.substr(6, 5);       // "world" (commence a 6, longueur 5)
let first = s.substr(0, 5);     // "hello"

// Exemple UTF-8
let text = "Hirocket!";
let emoji = text.substr(2, 1);  // "rocket" (position 2, longueur 1)
```

**`slice(start, end)`** - Extraire une sous-chaine par plage (fin exclusive) :
```hemlock
let s = "hello world";
let slice = s.slice(0, 5);      // "hello" (index 0 a 4)
let slice2 = s.slice(6, 11);    // "world"
```

**Difference :**
- `substr(start, length)` - Utilise le parametre longueur
- `slice(start, end)` - Utilise l'index de fin (exclusive)

### Recherche

**`find(needle)`** - Trouver la premiere occurrence :
```hemlock
let s = "hello world";
let pos = s.find("world");      // 6 (index de premiere occurrence)
let pos2 = s.find("foo");       // -1 (non trouve)
let pos3 = s.find("l");         // 2 (premier 'l')
```

**`contains(needle)`** - Verifier si la chaine contient une sous-chaine :
```hemlock
let s = "hello world";
let has = s.contains("world");  // true
let has2 = s.contains("foo");   // false
```

### Decoupage et nettoyage

**`split(delimiter)`** - Decouper en tableau de chaines :
```hemlock
let csv = "pomme,banane,cerise";
let parts = csv.split(",");     // ["pomme", "banane", "cerise"]

let words = "un deux trois".split(" ");  // ["un", "deux", "trois"]

// Delimiteur vide decoupe par caractere
let chars = "abc".split("");    // ["a", "b", "c"]
```

**`trim()`** - Supprimer les espaces de debut et fin :
```hemlock
let s = "  hello  ";
let clean = s.trim();           // "hello"

let s2 = "\t\ntexte\n\t";
let clean2 = s2.trim();         // "texte"
```

### Conversion de casse

**`to_upper()`** - Convertir en majuscules :
```hemlock
let s = "hello world";
let upper = s.to_upper();       // "HELLO WORLD"

// Preserve les non-ASCII
let s2 = "cafe";
let upper2 = s2.to_upper();     // "CAFE"
```

**`to_lower()`** - Convertir en minuscules :
```hemlock
let s = "HELLO WORLD";
let lower = s.to_lower();       // "hello world"
```

### Verification de prefixe/suffixe

**`starts_with(prefix)`** - Verifier si commence par le prefixe :
```hemlock
let s = "hello world";
let starts = s.starts_with("hello");  // true
let starts2 = s.starts_with("world"); // false
```

**`ends_with(suffix)`** - Verifier si finit par le suffixe :
```hemlock
let s = "hello world";
let ends = s.ends_with("world");      // true
let ends2 = s.ends_with("hello");     // false
```

### Remplacement

**`replace(old, new)`** - Remplacer la premiere occurrence :
```hemlock
let s = "hello world";
let s2 = s.replace("world", "there");      // "hello there"

let s3 = "foo foo foo";
let s4 = s3.replace("foo", "bar");         // "bar foo foo" (premier seulement)
```

**`replace_all(old, new)`** - Remplacer toutes les occurrences :
```hemlock
let s = "foo foo foo";
let s2 = s.replace_all("foo", "bar");      // "bar bar bar"

let s3 = "hello world, world!";
let s4 = s3.replace_all("world", "hemlock"); // "hello hemlock, hemlock!"
```

### Repetition

**`repeat(count)`** - Repeter la chaine n fois :
```hemlock
let s = "ha";
let laugh = s.repeat(3);        // "hahaha"

let line = "=".repeat(40);      // "========================================"
```

### Acces caractere et octet

**`char_at(index)`** - Obtenir le point de code Unicode a l'index (retourne rune) :
```hemlock
let s = "hello";
let char = s.char_at(0);        // 'h' (rune)

// Exemple UTF-8
let emoji = "rocket";
let rocket = emoji.char_at(0);  // Retourne rune U+1F680
```

**`chars()`** - Convertir en tableau de runes (points de code) :
```hemlock
let s = "hello";
let chars = s.chars();          // ['h', 'e', 'l', 'l', 'o'] (tableau de runes)

// Exemple UTF-8
let text = "Hirocket";
let chars2 = text.chars();      // ['H', 'i', 'rocket']
```

**`byte_at(index)`** - Obtenir la valeur d'octet a l'index (retourne u8) :
```hemlock
let s = "hello";
let byte = s.byte_at(0);        // 104 (valeur ASCII de 'h')

// Exemple UTF-8
let emoji = "rocket";
let first_byte = emoji.byte_at(0);  // 240 (premier octet UTF-8)
```

**`bytes()`** - Convertir en tableau d'octets (valeurs u8) :
```hemlock
let s = "hello";
let bytes = s.bytes();          // [104, 101, 108, 108, 111] (tableau de u8)

// Exemple UTF-8
let emoji = "rocket";
let bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 octets UTF-8)
```

**`to_bytes()`** - Convertir en buffer pour acces bas niveau :
```hemlock
let s = "hello";
let buf = s.to_bytes();         // Retourne buffer avec octets UTF-8
print(buf.length);              // 5
free(buf);                      // N'oubliez pas de liberer
```

## Chainage de methodes

Toutes les methodes de chaine retournent de nouvelles chaines, permettant le chainage :

```hemlock
let result = "  Hello World  "
    .trim()
    .to_lower()
    .replace("world", "hemlock");  // "hello hemlock"

let processed = "foo,bar,baz"
    .split(",")
    .join(" | ")
    .to_upper();                    // "FOO | BAR | BAZ"
```

## Reference complete des methodes

| Methode | Parametres | Retourne | Description |
|---------|------------|----------|-------------|
| `substr(start, length)` | i32, i32 | string | Extraire sous-chaine par position et longueur |
| `slice(start, end)` | i32, i32 | string | Extraire sous-chaine par plage (fin exclusive) |
| `find(needle)` | string | i32 | Trouver premiere occurrence (-1 si non trouve) |
| `contains(needle)` | string | bool | Verifier si contient sous-chaine |
| `split(delimiter)` | string | array | Decouper en tableau de chaines |
| `trim()` | - | string | Supprimer espaces debut/fin |
| `to_upper()` | - | string | Convertir en majuscules |
| `to_lower()` | - | string | Convertir en minuscules |
| `starts_with(prefix)` | string | bool | Verifier si commence par prefixe |
| `ends_with(suffix)` | string | bool | Verifier si finit par suffixe |
| `replace(old, new)` | string, string | string | Remplacer premiere occurrence |
| `replace_all(old, new)` | string, string | string | Remplacer toutes occurrences |
| `repeat(count)` | i32 | string | Repeter chaine n fois |
| `char_at(index)` | i32 | rune | Obtenir point de code a l'index |
| `byte_at(index)` | i32 | u8 | Obtenir valeur d'octet a l'index |
| `chars()` | - | array | Convertir en tableau de runes |
| `bytes()` | - | array | Convertir en tableau d'octets u8 |
| `to_bytes()` | - | buffer | Convertir en buffer (doit liberer) |

## Exemples

### Exemple : Traitement de texte

```hemlock
fn process_input(text: string): string {
    return text
        .trim()
        .to_lower()
        .replace_all("  ", " ");  // Normaliser les espaces
}

let input = "  HELLO   WORLD  ";
let clean = process_input(input);  // "hello world"
```

### Exemple : Analyseur CSV

```hemlock
fn parse_csv_line(line: string): array {
    let trimmed = line.trim();
    let fields = trimmed.split(",");

    let result = [];
    let i = 0;
    while (i < fields.length) {
        result.push(fields[i].trim());
        i = i + 1;
    }

    return result;
}

let csv = "pomme, banane , cerise";
let fields = parse_csv_line(csv);  // ["pomme", "banane", "cerise"]
```

### Exemple : Compteur de mots

```hemlock
fn count_words(text: string): i32 {
    let words = text.trim().split(" ");
    return words.length;
}

let sentence = "Le rapide renard brun";
let count = count_words(sentence);  // 4
```

### Exemple : Validation de chaine

```hemlock
fn is_valid_email(email: string): bool {
    if (!email.contains("@")) {
        return false;
    }

    if (!email.contains(".")) {
        return false;
    }

    if (email.starts_with("@") || email.ends_with("@")) {
        return false;
    }

    return true;
}

print(is_valid_email("user@example.com"));  // true
print(is_valid_email("invalid"));            // false
```

## Gestion de la memoire

Les chaines sont allouees sur le tas avec comptage de reference interne :

- **Creation** : Allouee sur le tas avec suivi de capacite
- **Concatenation** : Cree une nouvelle chaine (anciennes chaines inchangees)
- **Methodes** : La plupart des methodes retournent de nouvelles chaines
- **Duree de vie** : Les chaines sont comptees par reference et automatiquement liberees quand la portee se termine

**Nettoyage automatique :**
```hemlock
fn create_strings() {
    let s = "hello";
    let s2 = s + " world";  // Nouvelle allocation
}  // s et s2 sont automatiquement liberes quand la fonction retourne
```

**Note :** Les variables de chaine locales sont automatiquement nettoyees quand elles sortent de la portee. Utilisez `free()` uniquement pour le nettoyage anticipe avant la fin de portee ou pour les donnees globales/longue duree. Voir [Gestion de la memoire](memory.md#internal-reference-counting) pour les details.

## Bonnes pratiques

1. **Utilisez l'indexation par point de code** - Les chaines utilisent les positions de point de code, pas les decalages d'octets
2. **Testez avec Unicode** - Testez toujours les operations sur chaines avec des caracteres multi-octets
3. **Preferez les operations immuables** - Utilisez les methodes qui retournent de nouvelles chaines plutot que la mutation
4. **Verifiez les limites** - L'indexation de chaine ne verifie pas les limites (retourne null/erreur si invalide)
5. **Normalisez l'entree** - Utilisez `trim()` et `to_lower()` pour l'entree utilisateur

## Pieges courants

### Piege : Confusion octet vs. point de code

```hemlock
let emoji = "rocket";
print(emoji.length);        // 1 (point de code)
print(emoji.byte_length);   // 4 (octets)

// Ne melangez pas les operations octet et point de code
let byte = emoji.byte_at(0);  // 240 (premier octet)
let char = emoji.char_at(0);  // 'rocket' (point de code complet)
```

### Piege : Surprises de mutation

```hemlock
let s1 = "hello";
let s2 = s1;       // Copie superficielle
s1[0] = 'H';       // Mute s1
print(s2);         // Toujours "hello" (les chaines sont des types valeur)
```

## Sujets connexes

- [Runes](#language-guide-runes) - Type point de code Unicode utilise dans l'indexation de chaine
- [Tableaux](#language-guide-arrays) - Les methodes de chaine retournent ou travaillent souvent avec des tableaux
- [Types](#language-guide-types) - Details du type chaine et conversions

## Voir aussi

- **Encodage UTF-8** : Voir section "Strings" de CLAUDE.md
- **Conversions de type** : Voir [Types](#language-guide-types) pour les conversions de chaine
- **Memoire** : Voir [Memoire](#language-guide-memory) pour les details d'allocation de chaine


--------------------------------------------------------------------------------
## Filtrage par Motif
--------------------------------------------------------------------------------

# Filtrage par motif (Pattern Matching)

Hemlock fournit un filtrage par motif puissant grace aux expressions `match`, offrant un moyen concis de destructurer les valeurs, verifier les types et gerer plusieurs cas.

## Syntaxe de base

```hemlock
let result = match (value) {
    pattern1 => expression1,
    pattern2 => expression2,
    _ => expression_par_defaut
};
```

Les expressions match evaluent `value` contre chaque motif dans l'ordre, retournant le resultat de l'expression de la premiere branche correspondante.

## Types de motifs

### Motifs litteraux

Correspondre a des valeurs exactes :

```hemlock
let x = 42;
let msg = match (x) {
    0 => "zero",
    1 => "un",
    42 => "la reponse",
    _ => "autre"
};
print(msg);  // "la reponse"
```

Litteraux supportes :
- **Entiers** : `0`, `42`, `-5`
- **Flottants** : `3.14`, `-0.5`
- **Chaines** : `"hello"`, `"world"`
- **Booleens** : `true`, `false`
- **Null** : `null`

### Motif joker (`_`)

Correspond a n'importe quelle valeur sans liaison :

```hemlock
let x = "n'importe quoi";
let result = match (x) {
    "specifique" => "trouve",
    _ => "joker correspond"
};
```

### Motifs de liaison de variable

Lier la valeur correspondante a une variable :

```hemlock
let x = 100;
let result = match (x) {
    0 => "zero",
    n => "la valeur est " + n  // n lie a 100
};
print(result);  // "la valeur est 100"
```

### Motifs OU (`|`)

Correspondre a plusieurs alternatives :

```hemlock
let x = 2;
let size = match (x) {
    1 | 2 | 3 => "petit",
    4 | 5 | 6 => "moyen",
    _ => "grand"
};

// Fonctionne avec les chaines aussi
let cmd = "quit";
let action = match (cmd) {
    "exit" | "quit" | "q" => "sortie",
    "help" | "h" | "?" => "afficher aide",
    _ => "inconnu"
};
```

### Expressions de garde (`if`)

Ajouter des conditions aux motifs :

```hemlock
let x = 15;
let category = match (x) {
    n if n < 0 => "negatif",
    n if n == 0 => "zero",
    n if n < 10 => "petit",
    n if n < 100 => "moyen",
    n => "grand: " + n
};
print(category);  // "moyen"

// Gardes complexes
let y = 12;
let result = match (y) {
    n if n % 2 == 0 && n > 10 => "pair et superieur a 10",
    n if n % 2 == 0 => "pair",
    n => "impair"
};
```

### Motifs de type

Verifier et lier en fonction du type :

```hemlock
let val = 42;
let desc = match (val) {
    num: i32 => "entier: " + num,
    str: string => "chaine: " + str,
    flag: bool => "booleen: " + flag,
    _ => "autre type"
};
print(desc);  // "entier: 42"
```

Types supportes : `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`, `bool`, `string`, `array`, `object`

## Motifs de destructuration

### Destructuration d'objet

Extraire des champs des objets :

```hemlock
let point = { x: 10, y: 20 };
let result = match (point) {
    { x, y } => "point a " + x + "," + y
};
print(result);  // "point a 10,20"

// Avec valeurs de champ litterales
let origin = { x: 0, y: 0 };
let name = match (origin) {
    { x: 0, y: 0 } => "origine",
    { x: 0, y } => "sur axe y a " + y,
    { x, y: 0 } => "sur axe x a " + x,
    { x, y } => "point a " + x + "," + y
};
print(name);  // "origine"
```

### Destructuration de tableau

Correspondre a la structure et aux elements du tableau :

```hemlock
let arr = [1, 2, 3];
let desc = match (arr) {
    [] => "vide",
    [x] => "unique: " + x,
    [x, y] => "paire: " + x + "," + y,
    [x, y, z] => "triple: " + x + "," + y + "," + z,
    _ => "beaucoup d'elements"
};
print(desc);  // "triple: 1,2,3"

// Avec valeurs litterales
let pair = [1, 2];
let result = match (pair) {
    [0, 0] => "les deux zero",
    [1, x] => "commence par 1, second est " + x,
    [x, 1] => "finit par 1",
    _ => "autre"
};
print(result);  // "commence par 1, second est 2"
```

### Motifs rest de tableau (`...`)

Capturer les elements restants :

```hemlock
let nums = [1, 2, 3, 4, 5];

// Tete et queue
let result = match (nums) {
    [first, ...rest] => "premier: " + first,
    [] => "vide"
};
print(result);  // "premier: 1"

// Deux premiers elements
let result2 = match (nums) {
    [a, b, ...rest] => "deux premiers: " + a + "," + b,
    _ => "trop court"
};
print(result2);  // "deux premiers: 1,2"
```

### Destructuration imbriquee

Combiner les motifs pour des donnees complexes :

```hemlock
let user = {
    name: "Alice",
    address: { city: "NYC", zip: 10001 }
};

let result = match (user) {
    { name, address: { city, zip } } => name + " vit a " + city,
    _ => "inconnu"
};
print(result);  // "Alice vit a NYC"

// Objet contenant un tableau
let data = { items: [1, 2, 3], count: 3 };
let result2 = match (data) {
    { items: [first, ...rest], count } => "premier: " + first + ", total: " + count,
    _ => "pas d'elements"
};
print(result2);  // "premier: 1, total: 3"
```

## Match comme expression

Match est une expression qui retourne une valeur :

```hemlock
// Assignation directe
let grade = 85;
let letter = match (grade) {
    n if n >= 90 => "A",
    n if n >= 80 => "B",
    n if n >= 70 => "C",
    n if n >= 60 => "D",
    _ => "F"
};

// Dans une concatenation de chaines
let msg = "Note: " + match (grade) {
    n if n >= 70 => "reussite",
    _ => "echec"
};

// Dans un retour de fonction
fn classify(n: i32): string {
    return match (n) {
        0 => "zero",
        n if n > 0 => "positif",
        _ => "negatif"
    };
}
```

## Bonnes pratiques du filtrage par motif

1. **L'ordre compte** : Les motifs sont verifies de haut en bas ; mettez les motifs specifiques avant les generaux
2. **Utilisez les jokers pour l'exhaustivite** : Incluez toujours un repli `_` sauf si vous etes certain que tous les cas sont couverts
3. **Preferez les gardes aux conditions imbriquees** : Les gardes rendent l'intention plus claire
4. **Utilisez la destructuration plutot que l'acces manuel aux champs** : Plus concis et plus sur

```hemlock
// Bon : Gardes pour verification de plage
match (score) {
    n if n >= 90 => "A",
    n if n >= 80 => "B",
    _ => "en dessous de B"
}

// Bon : Destructurer au lieu d'acceder aux champs
match (point) {
    { x: 0, y: 0 } => "origine",
    { x, y } => "a " + x + "," + y
}

// Eviter : Motifs imbriques trop complexes
// A la place, considerez diviser en plusieurs match ou utiliser des gardes
```

## Comparaison avec d'autres langages

| Fonctionnalite | Hemlock | Rust | JavaScript |
|----------------|---------|------|------------|
| Match basique | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |
| Destructuration | Oui | Oui | Partiel (switch ne destructure pas) |
| Gardes | `n if n > 0 =>` | `n if n > 0 =>` | N/A |
| Motifs OU | `1 \| 2 \| 3 =>` | `1 \| 2 \| 3 =>` | `case 1: case 2: case 3:` |
| Motifs rest | `[a, ...rest]` | `[a, rest @ ..]` | N/A |
| Motifs de type | `n: i32` | Type via branche `match` | N/A |
| Retourne valeur | Oui | Oui | Non (instruction) |

## Notes d'implementation

Le filtrage par motif est implemente dans les backends interpreteur et compilateur avec parite complete - les deux produisent des resultats identiques pour la meme entree. Cette fonctionnalite est disponible dans Hemlock v1.8.0+.


--------------------------------------------------------------------------------
## Flux de ContrÃ´le
--------------------------------------------------------------------------------

# Flux de controle

Hemlock fournit un flux de controle familier de style C avec des accolades obligatoires et une syntaxe explicite. Ce guide couvre les conditionnelles, les boucles, les instructions switch et les operateurs.

## Apercu

Fonctionnalites de flux de controle disponibles :

- `if`/`else`/`else if` - Branches conditionnelles
- Boucles `while` - Iteration basee sur condition
- Boucles `for` - Style C et iteration for-in
- `loop` - Boucles infinies (plus propre que `while (true)`)
- Instructions `switch` - Branchement multi-voies
- `break`/`continue` - Controle de boucle
- Labels de boucle - break/continue cible pour les boucles imbriquees
- `defer` - Execution differee (nettoyage)
- Operateurs booleens : `&&`, `||`, `!`
- Operateurs de comparaison : `==`, `!=`, `<`, `>`, `<=`, `>=`
- Operateurs binaires : `&`, `|`, `^`, `<<`, `>>`, `~`

## Instructions If

### If/Else basique

```hemlock
if (x > 10) {
    print("grand");
} else {
    print("petit");
}
```

**Regles :**
- Les accolades sont **toujours requises** pour toutes les branches
- Les conditions doivent etre entre parentheses
- Pas d'accolades optionnelles (contrairement au C)

### If sans Else

```hemlock
if (x > 0) {
    print("positif");
}
// Pas de branche else necessaire
```

### Chaines Else-If

```hemlock
if (x > 100) {
    print("tres grand");
} else if (x > 50) {
    print("grand");
} else if (x > 10) {
    print("moyen");
} else {
    print("petit");
}
```

**Note :** `else if` est du sucre syntaxique pour des instructions if imbriquees. Ces deux sont equivalents :

```hemlock
// else if (sucre syntaxique)
if (a) {
    foo();
} else if (b) {
    bar();
}

// If imbrique equivalent
if (a) {
    foo();
} else {
    if (b) {
        bar();
    }
}
```

### Instructions If imbriquees

```hemlock
if (x > 0) {
    if (x < 10) {
        print("chiffre positif");
    } else {
        print("positif multi-chiffres");
    }
} else {
    print("non-positif");
}
```

## Boucles While

Iteration basee sur condition :

```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

**Boucles infinies (ancien style) :**
```hemlock
while (true) {
    // ... faire le travail
    if (should_exit) {
        break;
    }
}
```

**Note :** Pour les boucles infinies, preferez le mot-cle `loop` (voir ci-dessous).

## Loop (boucle infinie)

Le mot-cle `loop` fournit une syntaxe plus propre pour les boucles infinies :

```hemlock
loop {
    // ... faire le travail
    if (should_exit) {
        break;
    }
}
```

**Equivalent a `while (true)` mais plus explicite sur l'intention.**

### Loop basique avec Break

```hemlock
let i = 0;
loop {
    if (i >= 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// Affiche : 0, 1, 2, 3, 4
```

### Loop avec Continue

```hemlock
let i = 0;
loop {
    i = i + 1;
    if (i > 5) {
        break;
    }
    if (i == 3) {
        continue;  // Sauter l'affichage de 3
    }
    print(i);
}
// Affiche : 1, 2, 4, 5
```

### Boucles imbriquees

```hemlock
let x = 0;
loop {
    if (x >= 2) { break; }
    let y = 0;
    loop {
        if (y >= 3) { break; }
        print(x * 10 + y);
        y = y + 1;
    }
    x = x + 1;
}
// Affiche : 0, 1, 2, 10, 11, 12
```

### Quand utiliser Loop

- **Utilisez `loop`** pour les boucles intentionnellement infinies qui sortent via `break`
- **Utilisez `while`** quand il y a une condition de terminaison naturelle
- **Utilisez `for`** pour iterer un nombre connu de fois ou sur une collection

## Boucles For

### For style C

Boucle for classique en trois parties :

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**Composants :**
- **Initialiseur** : `let i = 0` - S'execute une fois avant la boucle
- **Condition** : `i < 10` - Verifiee avant chaque iteration
- **Mise a jour** : `i = i + 1` - S'execute apres chaque iteration

**Portee :**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
// i non accessible ici (portee de boucle)
```

### Boucles For-In

Iterer sur les elements d'un tableau :

```hemlock
let arr = [1, 2, 3, 4, 5];
for (let item in arr) {
    print(item);  // Affiche chaque element
}
```

**Avec index et valeur :**
```hemlock
let arr = ["a", "b", "c"];
for (let i = 0; i < arr.length; i = i + 1) {
    print(`Index: ${i}, Valeur: ${arr[i]}`);
}
```

## Instructions Switch

Branchement multi-voies base sur une valeur :

### Switch basique

```hemlock
let x = 2;

switch (x) {
    case 1:
        print("un");
        break;
    case 2:
        print("deux");
        break;
    case 3:
        print("trois");
        break;
}
```

### Switch avec Default

```hemlock
let color = "blue";

switch (color) {
    case "red":
        print("stop");
        break;
    case "yellow":
        print("ralentir");
        break;
    case "green":
        print("passer");
        break;
    default:
        print("couleur inconnue");
        break;
}
```

**Regles :**
- `default` correspond quand aucun autre case ne correspond
- `default` peut apparaitre n'importe ou dans le corps du switch
- Un seul case default autorise

### Comportement de fall-through

Les cases sans `break` passent au case suivant (comportement style C). C'est **intentionnel** et peut etre utilise pour grouper les cases :

```hemlock
let grade = 85;

switch (grade) {
    case 100:
    case 95:
    case 90:
        print("A");
        break;
    case 85:
    case 80:
        print("B");
        break;
    default:
        print("C ou moins");
        break;
}
```

**Exemple de fallthrough explicite :**
```hemlock
let day = 3;

switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        print("Jour de semaine");
        break;
    case 6:
    case 7:
        print("Week-end");
        break;
}
```

**Important :** Contrairement a certains langages modernes, Hemlock ne necessite PAS de mot-cle `fallthrough` explicite. Les cases passent automatiquement au suivant sauf s'ils sont termines par `break`, `return` ou `throw`. Utilisez toujours `break` pour eviter le fallthrough involontaire.

### Switch avec Return

Dans les fonctions, `return` quitte immediatement le switch :

```hemlock
fn get_day_name(day: i32): string {
    switch (day) {
        case 1:
            return "Lundi";
        case 2:
            return "Mardi";
        case 3:
            return "Mercredi";
        default:
            return "Inconnu";
    }
}
```

### Types de valeur Switch

Switch fonctionne avec n'importe quel type de valeur :

```hemlock
// Entiers
switch (count) {
    case 0: print("zero"); break;
    case 1: print("un"); break;
}

// Chaines
switch (name) {
    case "Alice": print("A"); break;
    case "Bob": print("B"); break;
}

// Booleens
switch (flag) {
    case true: print("actif"); break;
    case false: print("inactif"); break;
}
```

**Note :** Les cases sont compares par egalite de valeur.

## Break et Continue

### Break

Quitter la boucle ou le switch le plus interne :

```hemlock
// Dans les boucles
let i = 0;
while (true) {
    if (i >= 10) {
        break;  // Quitter la boucle
    }
    print(i);
    i = i + 1;
}

// Dans switch
switch (x) {
    case 1:
        print("un");
        break;  // Quitter le switch
    case 2:
        print("deux");
        break;
}
```

### Continue

Passer a l'iteration suivante de la boucle :

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;  // Sauter l'iteration quand i est 5
    }
    print(i);  // Affiche 0,1,2,3,4,6,7,8,9
}
```

**Difference :**
- `break` - Quitte entierement la boucle
- `continue` - Passe a l'iteration suivante

## Labels de boucle

Les labels de boucle permettent a `break` et `continue` de cibler des boucles externes specifiques au lieu de la boucle la plus interne. C'est utile pour les boucles imbriquees ou vous devez controler une boucle externe depuis une boucle interne.

### Break labele

Quitter une boucle externe depuis une boucle interne :

```hemlock
outer: while (i < 3) {
    let j = 0;
    while (j < 3) {
        if (i == 1 && j == 1) {
            break outer;  // Quitter la boucle while externe
        }
        print(i * 10 + j);
        j = j + 1;
    }
    i = i + 1;
}
// Affiche : 0, 1, 2, 10 (s'arrete a i=1, j=1)
```

### Continue labele

Passer a l'iteration suivante d'une boucle externe :

```hemlock
let i = 0;
outer: while (i < 3) {
    i = i + 1;
    let j = 0;
    while (j < 3) {
        j = j + 1;
        if (i == 2 && j == 1) {
            continue outer;  // Sauter le reste de la boucle interne, continuer externe
        }
        print(i * 10 + j);
    }
}
// Quand i=2, j=1 : saute a l'iteration externe suivante
```

### Labels avec boucles For

Les labels fonctionnent avec tous les types de boucle :

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 3; y = y + 1) {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
    }
}
```

### Labels avec boucles For-In

```hemlock
let arr1 = [1, 2, 3];
let arr2 = [10, 20, 30];

outer: for (let a in arr1) {
    for (let b in arr2) {
        if (a == 2 && b == 20) {
            break outer;
        }
        print(a * 100 + b);
    }
}
```

### Labels avec mot-cle Loop

```hemlock
let x = 0;
outer: loop {
    let y = 0;
    loop {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
        y = y + 1;
        if (y >= 3) { break; }
    }
    x = x + 1;
    if (x >= 3) { break; }
}
```

### Labels multiples

Vous pouvez avoir des labels a differents niveaux d'imbrication :

```hemlock
outer: for (let a = 0; a < 2; a = a + 1) {
    inner: for (let b = 0; b < 3; b = b + 1) {
        for (let c = 0; c < 3; c = c + 1) {
            if (c == 1) {
                continue inner;  // Passer a l'iteration suivante de la boucle du milieu
            }
            if (a == 1 && b == 1) {
                break outer;      // Quitter la boucle la plus externe
            }
            print(a * 100 + b * 10 + c);
        }
    }
}
```

### Break/Continue non labeles avec boucles labelees

Les `break` et `continue` non labeles fonctionnent toujours normalement (affectant la boucle la plus interne), meme quand les boucles externes ont des labels :

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 5; y = y + 1) {
        if (y == 2) {
            break;  // Ne sort que de la boucle interne
        }
        print(x * 10 + y);
    }
}
// Affiche : 0, 1, 10, 11, 20, 21
```

### Syntaxe des labels

- Les labels sont des identifiants suivis de deux-points
- Les labels doivent immediatement preceder une instruction de boucle (`while`, `for`, `loop`)
- Les noms de label suivent les regles d'identifiant (lettres, chiffres, underscores)
- Conventions courantes : `outer`, `inner`, `row`, `col`, noms descriptifs

## Instruction Defer

L'instruction `defer` planifie du code pour s'executer quand la fonction courante retourne. C'est utile pour les operations de nettoyage comme fermer des fichiers, liberer des ressources ou relacher des verrous.

### Defer basique

```hemlock
fn example() {
    print("debut");
    defer print("nettoyage");  // S'execute quand la fonction retourne
    print("fin");
}

example();
// Sortie :
// debut
// fin
// nettoyage
```

**Comportement cle :**
- Les instructions differees s'executent **apres** que le corps de la fonction soit termine
- Les instructions differees s'executent **avant** que la fonction ne retourne a son appelant
- Les instructions differees s'executent toujours, meme si la fonction leve une exception

### Defers multiples (ordre LIFO)

Quand plusieurs instructions `defer` sont utilisees, elles s'executent dans l'**ordre inverse** (Dernier-Entre-Premier-Sorti) :

```hemlock
fn example() {
    defer print("premier");   // S'execute en dernier
    defer print("second");    // S'execute en second
    defer print("troisieme"); // S'execute en premier
    print("corps");
}

example();
// Sortie :
// corps
// troisieme
// second
// premier
```

Cet ordre LIFO est intentionnel - il correspond a l'ordre naturel pour le nettoyage de ressources imbriquees (fermer les ressources internes avant les externes).

### Defer avec Return

Les instructions differees s'executent avant que `return` ne transfere le controle :

```hemlock
fn get_value(): i32 {
    defer print("nettoyage");
    print("avant return");
    return 42;
}

let result = get_value();
print("resultat:", result);
// Sortie :
// avant return
// nettoyage
// resultat: 42
```

### Defer avec exceptions

Les instructions differees s'executent meme quand une exception est levee :

```hemlock
fn risky() {
    defer print("nettoyage 1");
    defer print("nettoyage 2");
    print("avant throw");
    throw "erreur!";
    print("apres throw");  // Jamais atteint
}

try {
    risky();
} catch (e) {
    print("Attrape:", e);
}
// Sortie :
// avant throw
// nettoyage 2
// nettoyage 1
// Attrape: erreur!
```

### Modele de nettoyage de ressource

Le cas d'utilisation principal de `defer` est d'assurer que les ressources sont nettoyees :

```hemlock
fn process_file(filename: string) {
    let file = open(filename, "r");
    defer file.close();  // Ferme toujours, meme en cas d'erreur

    let content = file.read();
    // ... traiter le contenu ...

    // Fichier automatiquement ferme quand la fonction retourne
}
```

**Sans defer (propice aux erreurs) :**
```hemlock
fn process_file_bad(filename: string) {
    let file = open(filename, "r");
    let content = file.read();
    // Si cela leve une exception, file.close() n'est jamais appele !
    process(content);
    file.close();
}
```

### Defer avec fermetures

Defer peut utiliser des fermetures pour capturer l'etat :

```hemlock
fn example() {
    let resource = acquire_resource();
    defer fn() {
        print("Liberation de la ressource");
        release(resource);
    }();  // Note : expression de fonction immediatement invoquee

    use_resource(resource);
}
```

### Quand utiliser Defer

**Utilisez defer pour :**
- Fermer des fichiers et connexions reseau
- Liberer la memoire allouee
- Relacher des verrous et mutex
- Nettoyage dans toute fonction qui acquiert des ressources

**Defer vs Finally :**
- `defer` est plus simple pour le nettoyage de ressource unique
- `try/finally` est mieux pour la gestion d'erreur complexe avec recuperation

### Bonnes pratiques

1. **Placez defer immediatement apres l'acquisition d'une ressource :**
   ```hemlock
   let file = open("data.txt", "r");
   defer file.close();
   // ... utiliser file ...
   ```

2. **Utilisez plusieurs defers pour plusieurs ressources :**
   ```hemlock
   let file1 = open("input.txt", "r");
   defer file1.close();

   let file2 = open("output.txt", "w");
   defer file2.close();

   // Les deux fichiers seront fermes dans l'ordre inverse
   ```

3. **Rappelez-vous l'ordre LIFO pour les ressources dependantes :**
   ```hemlock
   let outer = acquire_outer();
   defer release_outer(outer);

   let inner = acquire_inner(outer);
   defer release_inner(inner);

   // inner libere avant outer (ordre de dependance correct)
   ```

## Operateurs booleens

### ET logique (`&&`)

Les deux conditions doivent etre vraies :

```hemlock
if (x > 0 && x < 10) {
    print("chiffre positif");
}
```

**Evaluation court-circuit :**
```hemlock
if (false && expensive_check()) {
    // expensive_check() jamais appelee
}
```

### OU logique (`||`)

Au moins une condition doit etre vraie :

```hemlock
if (x < 0 || x > 100) {
    print("hors plage");
}
```

**Evaluation court-circuit :**
```hemlock
if (true || expensive_check()) {
    // expensive_check() jamais appelee
}
```

### NON logique (`!`)

Inverse la valeur booleenne :

```hemlock
if (!is_valid) {
    print("invalide");
}

if (!(x > 10)) {
    // Equivalent a : if (x <= 10)
}
```

## Operateurs de comparaison

### Egalite

```hemlock
if (x == 10) { }    // Egal
if (x != 10) { }    // Different
```

Fonctionne avec tous les types :
```hemlock
"hello" == "hello"  // true
true == false       // false
null == null        // true
```

### Relationnel

```hemlock
if (x < 10) { }     // Inferieur a
if (x > 10) { }     // Superieur a
if (x <= 10) { }    // Inferieur ou egal
if (x >= 10) { }    // Superieur ou egal
```

**La promotion de type s'applique :**
```hemlock
let a: i32 = 10;
let b: i64 = 10;
if (a == b) { }     // true (i32 promu vers i64)
```

## Operateurs binaires (bitwise)

Hemlock fournit des operateurs binaires pour la manipulation d'entiers. Ceux-ci fonctionnent **uniquement avec les types entiers** (i8-i64, u8-u64).

### Operateurs binaires binaires

**ET binaire (`&`)**
```hemlock
let a = 12;  // 1100 en binaire
let b = 10;  // 1010 en binaire
print(a & b);   // 8 (1000)
```

**OU binaire (`|`)**
```hemlock
print(a | b);   // 14 (1110)
```

**XOR binaire (`^`)**
```hemlock
print(a ^ b);   // 6 (0110)
```

**Decalage a gauche (`<<`)**
```hemlock
print(a << 2);  // 48 (110000) - decaler a gauche de 2
```

**Decalage a droite (`>>`)**
```hemlock
print(a >> 1);  // 6 (110) - decaler a droite de 1
```

### Operateur binaire unaire

**NON binaire (`~`)**
```hemlock
let a = 12;
print(~a);      // -13 (complement a deux)

let c: u8 = 15;   // 00001111 en binaire
print(~c);        // 240 (11110000) en u8
```

### Exemples binaires

**Avec types non signes :**
```hemlock
let c: u8 = 15;   // 00001111 en binaire
let d: u8 = 7;    // 00000111 en binaire

print(c & d);     // 7  (00000111)
print(c | d);     // 15 (00001111)
print(c ^ d);     // 8  (00001000)
print(~c);        // 240 (11110000) - en u8
```

**Preservation du type :**
```hemlock
// Les operations binaires preservent le type des operandes
let x: u8 = 255;
let result = ~x;  // result est u8 avec valeur 0

let y: i32 = 100;
let result2 = y << 2;  // result2 est i32 avec valeur 400
```

**Modeles courants :**
```hemlock
// Verifier si un bit est defini
if (flags & 0x04) {
    print("bit 2 est defini");
}

// Definir un bit
flags = flags | 0x08;

// Effacer un bit
flags = flags & ~0x02;

// Inverser un bit
flags = flags ^ 0x01;
```

### Priorite des operateurs

Les operateurs binaires suivent la priorite style C :

1. `~` (NON unaire) - plus haute, meme niveau que `!` et `-`
2. `<<`, `>>` (decalages) - plus haute que comparaisons, plus basse que `+`/`-`
3. `&` (ET binaire) - plus haute que `^` et `|`
4. `^` (XOR binaire) - entre `&` et `|`
5. `|` (OU binaire) - plus basse que `&` et `^`, plus haute que `&&`
6. `&&`, `||` (logiques) - priorite la plus basse

**Exemples :**
```hemlock
// & a une priorite plus haute que |
let result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12

// Decalage a une priorite plus haute que les operateurs binaires
let result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12

// Utilisez des parentheses pour la clarte
let result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5
```

**Notes importantes :**
- Les operateurs binaires fonctionnent uniquement avec les types entiers (pas les flottants, chaines, etc.)
- La promotion de type suit les regles standard (les types plus petits sont promus vers les plus grands)
- Le decalage a droite (`>>`) est arithmetique pour les types signes, logique pour les non signes
- Les quantites de decalage ne sont pas verifiees (comportement dependant de la plateforme pour les grands decalages)

## Priorite des operateurs (complete)

De la priorite la plus haute a la plus basse :

1. **Unaire** : `!`, `-`, `~`
2. **Multiplicatif** : `*`, `/`, `%`
3. **Additif** : `+`, `-`
4. **Decalage** : `<<`, `>>`
5. **Relationnel** : `<`, `>`, `<=`, `>=`
6. **Egalite** : `==`, `!=`
7. **ET binaire** : `&`
8. **XOR binaire** : `^`
9. **OU binaire** : `|`
10. **ET logique** : `&&`
11. **OU logique** : `||`

**Utilisez des parentheses pour la clarte :**
```hemlock
// Pas clair
if (a || b && c) { }

// Clair
if (a || (b && c)) { }
if ((a || b) && c) { }
```

## Modeles courants

### Modele : Validation d'entree

```hemlock
fn validate_age(age: i32): bool {
    if (age < 0 || age > 150) {
        return false;
    }
    return true;
}
```

### Modele : Verification de plage

```hemlock
fn in_range(value: i32, min: i32, max: i32): bool {
    return value >= min && value <= max;
}

if (in_range(score, 0, 100)) {
    print("score valide");
}
```

### Modele : Machine a etats

```hemlock
let state = "start";

while (true) {
    switch (state) {
        case "start":
            print("Demarrage...");
            state = "running";
            break;

        case "running":
            if (should_pause) {
                state = "paused";
            } else if (should_stop) {
                state = "stopped";
            }
            break;

        case "paused":
            if (should_resume) {
                state = "running";
            }
            break;

        case "stopped":
            print("Arrete");
            break;
    }

    if (state == "stopped") {
        break;
    }
}
```

### Modele : Iteration avec filtrage

```hemlock
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Afficher uniquement les nombres pairs
for (let i = 0; i < arr.length; i = i + 1) {
    if (arr[i] % 2 != 0) {
        continue;  // Sauter les nombres impairs
    }
    print(arr[i]);
}
```

### Modele : Sortie anticipee

```hemlock
fn find_first_negative(arr: array): i32 {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // Sortie anticipee
        }
    }
    return -1;  // Non trouve
}
```

## Bonnes pratiques

1. **Utilisez toujours des accolades** - Meme pour les blocs a instruction unique (impose par la syntaxe)
2. **Conditions explicites** - Utilisez `x == 0` au lieu de `!x` pour la clarte
3. **Evitez l'imbrication profonde** - Extrayez les conditions imbriquees en fonctions
4. **Utilisez les retours anticipes** - Reduisez l'imbrication avec des clauses de garde
5. **Divisez les conditions complexes** - Divisez en variables booleennes nommees
6. **Default dans switch** - Incluez toujours un case default
7. **Commentez le fall-through** - Rendez le fall-through intentionnel explicite

## Pieges courants

### Piege : Assignation dans la condition

```hemlock
// Ceci n'est PAS autorise (pas d'assignation dans les conditions)
if (x = 10) { }  // ERREUR : Erreur de syntaxe

// Utilisez la comparaison a la place
if (x == 10) { }  // OK
```

### Piege : Break manquant dans Switch

```hemlock
// Fall-through involontaire
switch (x) {
    case 1:
        print("un");
        // Break manquant - fall-through !
    case 2:
        print("deux");  // S'execute pour 1 et 2
        break;
}

// Correction : Ajouter break
switch (x) {
    case 1:
        print("un");
        break;  // Maintenant correct
    case 2:
        print("deux");
        break;
}
```

### Piege : Portee de variable de boucle

```hemlock
// i a une portee limitee a la boucle
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
print(i);  // ERREUR : i non defini ici
```

## Exemples

### Exemple : FizzBuzz

```hemlock
for (let i = 1; i <= 100; i = i + 1) {
    if (i % 15 == 0) {
        print("FizzBuzz");
    } else if (i % 3 == 0) {
        print("Fizz");
    } else if (i % 5 == 0) {
        print("Buzz");
    } else {
        print(i);
    }
}
```

### Exemple : Verificateur de nombre premier

```hemlock
fn is_prime(n: i32): bool {
    if (n < 2) {
        return false;
    }

    let i = 2;
    while (i * i <= n) {
        if (n % i == 0) {
            return false;
        }
        i = i + 1;
    }

    return true;
}
```

### Exemple : Systeme de menu

```hemlock
fn menu() {
    while (true) {
        print("1. Demarrer");
        print("2. Parametres");
        print("3. Quitter");

        let choice = get_input();

        switch (choice) {
            case 1:
                start_game();
                break;
            case 2:
                show_settings();
                break;
            case 3:
                print("Au revoir !");
                return;
            default:
                print("Choix invalide");
                break;
        }
    }
}
```

## Sujets connexes

- [Fonctions](#language-guide-functions) - Flux de controle avec appels de fonction et retours
- [Gestion des erreurs](#language-guide-error-handling) - Flux de controle avec exceptions
- [Types](#language-guide-types) - Conversions de type dans les conditions

## Voir aussi

- **Syntaxe** : Voir [Syntaxe](#language-guide-syntax) pour les details de syntaxe des instructions
- **Operateurs** : Voir [Types](#language-guide-types) pour la promotion de type dans les operations


--------------------------------------------------------------------------------
## Fonctions
--------------------------------------------------------------------------------

# Fonctions

Les fonctions en Hemlock sont des **valeurs de premiere classe** qui peuvent etre assignees a des variables, passees en arguments et retournees par d'autres fonctions. Ce guide couvre la syntaxe des fonctions, les fermetures, la recursivite et les modeles avances.

## Apercu

```hemlock
// Syntaxe de fonction nommee
fn add(a: i32, b: i32): i32 {
    return a + b;
}

// Fonction anonyme
let multiply = fn(x, y) {
    return x * y;
};

// Fermetures
fn makeAdder(x) {
    return fn(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
print(add5(3));  // 8
```

## Declaration de fonction

### Fonctions nommees

```hemlock
fn greet(name: string): string {
    return "Bonjour, " + name;
}

let msg = greet("Alice");  // "Bonjour, Alice"
```

**Composants :**
- `fn` - Mot-cle fonction
- `greet` - Nom de la fonction
- `(name: string)` - Parametres avec types optionnels
- `: string` - Type de retour optionnel
- `{ ... }` - Corps de la fonction

### Fonctions anonymes

Fonctions sans nom, assignees a des variables :

```hemlock
let square = fn(x) {
    return x * x;
};

print(square(5));  // 25
```

**Nommee vs. Anonyme :**
```hemlock
// Ces deux sont equivalentes :
fn add(a, b) { return a + b; }

let add = fn(a, b) { return a + b; };
```

**Note :** Les fonctions nommees se transforment en assignations de variables avec des fonctions anonymes.

## Parametres

### Parametres basiques

```hemlock
fn example(a, b, c) {
    return a + b + c;
}

let result = example(1, 2, 3);  // 6
```

### Annotations de type

Annotations de type optionnelles sur les parametres :

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 10);      // OK
add(5, 10.5);    // La verification de type a l'execution promeut vers f64
```

**Verification de type :**
- Les types de parametre sont verifies a l'appel si annotes
- Les conversions de type implicites suivent les regles de promotion standard
- Les incompatibilites de type causent des erreurs a l'execution

### Passage par valeur

Tous les arguments sont **copies** (passage par valeur) :

```hemlock
fn modify(x) {
    x = 100;  // Modifie uniquement la copie locale
}

let a = 10;
modify(a);
print(a);  // Toujours 10 (inchange)
```

**Note :** Les objets et tableaux sont passes par reference (la reference est copiee), donc leur contenu peut etre modifie :

```hemlock
fn modify_array(arr) {
    arr[0] = 99;  // Modifie le tableau original
}

let a = [1, 2, 3];
modify_array(a);
print(a[0]);  // 99 (modifie)
```

## Valeurs de retour

### Instruction return

```hemlock
fn get_max(a: i32, b: i32): i32 {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}
```

### Annotations de type de retour

Annotation de type optionnelle pour la valeur de retour :

```hemlock
fn calculate(): f64 {
    return 3.14159;
}

fn get_name(): string {
    return "Alice";
}
```

**Verification de type :**
- Les types de retour sont verifies quand la fonction retourne (si annotes)
- Les conversions de type suivent les regles de promotion standard

### Retour implicite

Les fonctions sans annotation de type de retour retournent implicitement `null` :

```hemlock
fn print_message(msg) {
    print(msg);
    // Retourne implicitement null
}

let result = print_message("bonjour");  // result est null
```

### Retour anticipe

```hemlock
fn find_first_negative(arr) {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // Sortie anticipee
        }
    }
    return -1;  // Non trouve
}
```

### Retour sans valeur

`return;` sans valeur retourne `null` :

```hemlock
fn maybe_process(value) {
    if (value < 0) {
        return;  // Retourne null
    }
    return value * 2;
}
```

## Fonctions de premiere classe

Les fonctions peuvent etre assignees, passees et retournees comme n'importe quelle autre valeur.

### Fonctions comme variables

```hemlock
let operation = fn(x, y) { return x + y; };

print(operation(5, 3));  // 8

// Reassigner
operation = fn(x, y) { return x * y; };
print(operation(5, 3));  // 15
```

### Fonctions comme arguments

```hemlock
fn apply(f, x) {
    return f(x);
}

fn double(n) {
    return n * 2;
}

let result = apply(double, 5);  // 10
```

### Fonctions comme valeurs de retour

```hemlock
fn get_operation(op: string) {
    if (op == "add") {
        return fn(a, b) { return a + b; };
    } else if (op == "multiply") {
        return fn(a, b) { return a * b; };
    } else {
        return fn(a, b) { return 0; };
    }
}

let add = get_operation("add");
print(add(5, 3));  // 8
```

## Fermetures (Closures)

Les fonctions capturent leur environnement de definition (portee lexicale).

### Fermetures basiques

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
print(counter());  // 3
```

**Comment ca marche :**
- La fonction interne capture `count` de la portee externe
- `count` persiste a travers les appels a la fonction retournee
- Chaque appel a `makeCounter()` cree une nouvelle fermeture avec son propre `count`

### Fermeture avec parametres

```hemlock
fn makeAdder(x) {
    return fn(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
let add10 = makeAdder(10);

print(add5(3));   // 8
print(add10(3));  // 13
```

### Fermetures multiples

```hemlock
fn makeOperations(x) {
    let add = fn(y) { return x + y; };
    let multiply = fn(y) { return x * y; };

    return { add: add, multiply: multiply };
}

let ops = makeOperations(5);
print(ops.add(3));       // 8
print(ops.multiply(3));  // 15
```

### Portee lexicale

Les fonctions peuvent acceder aux variables de la portee externe via la portee lexicale :

```hemlock
let global = 10;

fn outer() {
    let outer_var = 20;

    fn inner() {
        // Peut lire global et outer_var
        print(global);      // 10
        print(outer_var);   // 20
    }

    inner();
}

outer();
```

Les fermetures capturent les variables par reference, permettant la lecture et la modification des variables de la portee externe (comme montre dans l'exemple `makeCounter` ci-dessus).

## Recursivite

Les fonctions peuvent s'appeler elles-memes.

### Recursivite basique

```hemlock
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

print(factorial(5));  // 120
```

### Recursivite mutuelle

Les fonctions peuvent s'appeler mutuellement :

```hemlock
fn is_even(n: i32): bool {
    if (n == 0) {
        return true;
    }
    return is_odd(n - 1);
}

fn is_odd(n: i32): bool {
    if (n == 0) {
        return false;
    }
    return is_even(n - 1);
}

print(is_even(4));  // true
print(is_odd(4));   // false
```

### Traitement de donnees recursif

```hemlock
fn sum_array(arr: array, index: i32): i32 {
    if (index >= arr.length) {
        return 0;
    }
    return arr[index] + sum_array(arr, index + 1);
}

let numbers = [1, 2, 3, 4, 5];
print(sum_array(numbers, 0));  // 15
```

**Note :** Pas encore d'optimisation de la recursivite terminale - une recursivite profonde peut causer un debordement de pile.

## Fonctions d'ordre superieur

Fonctions qui prennent ou retournent d'autres fonctions.

### Modele Map

```hemlock
fn map(arr, f) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        result.push(f(arr[i]));
        i = i + 1;
    }
    return result;
}

fn double(x) { return x * 2; }

let numbers = [1, 2, 3, 4, 5];
let doubled = map(numbers, double);  // [2, 4, 6, 8, 10]
```

### Modele Filter

```hemlock
fn filter(arr, predicate) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        if (predicate(arr[i])) {
            result.push(arr[i]);
        }
        i = i + 1;
    }
    return result;
}

fn is_even(x) { return x % 2 == 0; }

let numbers = [1, 2, 3, 4, 5, 6];
let evens = filter(numbers, is_even);  // [2, 4, 6]
```

### Modele Reduce

```hemlock
fn reduce(arr, f, initial) {
    let accumulator = initial;
    let i = 0;
    while (i < arr.length) {
        accumulator = f(accumulator, arr[i]);
        i = i + 1;
    }
    return accumulator;
}

fn add(a, b) { return a + b; }

let numbers = [1, 2, 3, 4, 5];
let sum = reduce(numbers, add, 0);  // 15
```

### Composition de fonctions

```hemlock
fn compose(f, g) {
    return fn(x) {
        return f(g(x));
    };
}

fn double(x) { return x * 2; }
fn increment(x) { return x + 1; }

let double_then_increment = compose(increment, double);
print(double_then_increment(5));  // 11 (5*2 + 1)
```

## Modeles courants

### Modele : Fonctions usine (Factory)

```hemlock
fn createPerson(name: string, age: i32) {
    return {
        name: name,
        age: age,
        greet: fn() {
            return "Salut, je suis " + self.name;
        }
    };
}

let person = createPerson("Alice", 30);
print(person.greet());  // "Salut, je suis Alice"
```

### Modele : Fonctions de rappel (Callback)

```hemlock
fn process_async(data, callback) {
    // ... faire le traitement
    callback(data);
}

process_async("test", fn(result) {
    print("Traitement termine : " + result);
});
```

### Modele : Application partielle

```hemlock
fn partial(f, x) {
    return fn(y) {
        return f(x, y);
    };
}

fn multiply(a, b) {
    return a * b;
}

let double = partial(multiply, 2);
let triple = partial(multiply, 3);

print(double(5));  // 10
print(triple(5));  // 15
```

### Modele : Memoisation

```hemlock
fn memoize(f) {
    let cache = {};

    return fn(x) {
        if (cache.has(x)) {
            return cache[x];
        }

        let result = f(x);
        cache[x] = result;
        return result;
    };
}

fn expensive_fibonacci(n) {
    if (n <= 1) { return n; }
    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);
}

let fast_fib = memoize(expensive_fibonacci);
print(fast_fib(10));  // Beaucoup plus rapide avec le cache
```

## Semantique des fonctions

### Exigences de type de retour

Les fonctions avec annotation de type de retour **doivent** retourner une valeur :

```hemlock
fn get_value(): i32 {
    // ERREUR : Instruction return manquante
}

fn get_value(): i32 {
    return 42;  // OK
}
```

### Verification de type

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 10);        // OK
add(5.5, 10.5);    // Promeut vers f64, retourne f64
add("a", "b");     // Erreur d'execution : type mismatch
```

### Regles de portee

```hemlock
let global = "global";

fn outer() {
    let outer_var = "outer";

    fn inner() {
        let inner_var = "inner";
        // Peut acceder : inner_var, outer_var, global
    }

    // Peut acceder : outer_var, global
    // Ne peut pas acceder : inner_var
}

// Peut acceder : global
// Ne peut pas acceder : outer_var, inner_var
```

## Bonnes pratiques

1. **Utilisez des annotations de type** - Aide a detecter les erreurs et documente l'intention
2. **Gardez les fonctions petites** - Chaque fonction devrait faire une seule chose
3. **Preferez les fonctions pures** - Evitez les effets de bord quand possible
4. **Nommez les fonctions clairement** - Utilisez des noms de verbes descriptifs
5. **Retournez tot** - Utilisez des clauses de garde pour reduire l'imbrication
6. **Documentez les fermetures complexes** - Rendez les variables capturees explicites
7. **Evitez la recursivite profonde** - Pas encore d'optimisation de la recursivite terminale

## Pieges courants

### Piege : Profondeur de recursivite

```hemlock
// La recursivite profonde peut causer un debordement de pile
fn count_down(n) {
    if (n == 0) { return; }
    count_down(n - 1);
}

count_down(100000);  // Peut planter avec un debordement de pile
```

### Piege : Modification des variables capturees

```hemlock
fn make_counter() {
    let count = 0;
    return fn() {
        count = count + 1;  // Peut lire et modifier les variables capturees
        return count;
    };
}
```

**Note :** Cela fonctionne, mais soyez conscient que toutes les fermetures partagent le meme environnement capture.

## Exemples

### Exemple : Pipeline de fonctions

```hemlock
fn pipeline(value, ...functions) {
    let result = value;
    for (f in functions) {
        result = f(result);
    }
    return result;
}

fn double(x) { return x * 2; }
fn increment(x) { return x + 1; }
fn square(x) { return x * x; }

let result = pipeline(3, double, increment, square);
print(result);  // 49 ((3*2+1)^2)
```

### Exemple : Gestionnaire d'evenements

```hemlock
let handlers = [];

fn on_event(name: string, handler) {
    handlers.push({ name: name, handler: handler });
}

fn trigger_event(name: string, data) {
    let i = 0;
    while (i < handlers.length) {
        if (handlers[i].name == name) {
            handlers[i].handler(data);
        }
        i = i + 1;
    }
}

on_event("click", fn(data) {
    print("Clique : " + data);
});

trigger_event("click", "button1");
```

### Exemple : Tri avec comparateur personnalise

```hemlock
fn sort(arr, compare) {
    // Tri a bulles avec comparateur personnalise
    let n = arr.length;
    let i = 0;
    while (i < n) {
        let j = 0;
        while (j < n - i - 1) {
            if (compare(arr[j], arr[j + 1]) > 0) {
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

fn ascending(a, b) {
    if (a < b) { return -1; }
    if (a > b) { return 1; }
    return 0;
}

let numbers = [5, 2, 8, 1, 9];
sort(numbers, ascending);
print(numbers);  // [1, 2, 5, 8, 9]
```

## Parametres optionnels (arguments par defaut)

Les fonctions peuvent avoir des parametres optionnels avec des valeurs par defaut en utilisant la syntaxe `?:` :

```hemlock
fn greet(name, greeting?: "Bonjour") {
    return greeting + " " + name;
}

print(greet("Alice"));           // "Bonjour Alice"
print(greet("Bob", "Salut"));    // "Salut Bob"

fn add(a, b?: 10, c?: 100) {
    return a + b + c;
}

print(add(1));          // 111 (1 + 10 + 100)
print(add(1, 2));       // 103 (1 + 2 + 100)
print(add(1, 2, 3));    // 6   (1 + 2 + 3)
```

**Regles :**
- Les parametres optionnels doivent venir apres les parametres requis
- Les valeurs par defaut peuvent etre n'importe quelle expression
- Les arguments omis utilisent la valeur par defaut

## Fonctions variadiques (parametres rest)

Les fonctions peuvent accepter un nombre variable d'arguments en utilisant les parametres rest (`...`) :

```hemlock
fn sum(...args) {
    let total = 0;
    for (arg in args) {
        total = total + arg;
    }
    return total;
}

print(sum(1, 2, 3));        // 6
print(sum(1, 2, 3, 4, 5));  // 15
print(sum());               // 0

fn log(prefix, ...messages) {
    for (msg in messages) {
        print(prefix + ": " + msg);
    }
}

log("INFO", "Demarrage", "Execution", "Termine");
// INFO: Demarrage
// INFO: Execution
// INFO: Termine
```

**Regles :**
- Le parametre rest doit etre le dernier parametre
- Le parametre rest collecte tous les arguments restants dans un tableau
- Peut etre combine avec des parametres reguliers et optionnels

## Annotations de type de fonction

Les types de fonction permettent de specifier la signature exacte attendue pour les parametres de fonction et les valeurs de retour :

### Types de fonction basiques

```hemlock
// Syntaxe de type de fonction : fn(param_types): return_type
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

let double = fn(n) { return n * 2; };
let result = apply(double, 5);  // 10
```

### Types de fonction d'ordre superieur

```hemlock
// Fonction retournant une fonction
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

let add5 = make_adder(5);
print(add5(10));  // 15
```

### Types de fonction asynchrone

```hemlock
// Type de fonction asynchrone
fn run_task(handler: async fn(): void) {
    spawn(handler);
}

run_task(async fn() {
    print("Execution asynchrone !");
});
```

### Alias de type de fonction

```hemlock
// Creer des types de fonction nommes pour la clarte
type Callback = fn(i32): void;
type Predicate = fn(any): bool;
type BinaryOp = fn(i32, i32): i32;

fn filter_with(arr: array, pred: Predicate): array {
    return arr.filter(pred);
}
```

## Parametres const

Le modificateur `const` empeche un parametre d'etre modifie dans la fonction :

### Parametres const basiques

```hemlock
fn print_all(const items: array) {
    // items.push(4);  // ERREUR : cannot mutate const parameter
    for (item in items) {
        print(item);   // OK : la lecture est autorisee
    }
}

let nums = [1, 2, 3];
print_all(nums);
```

### Immutabilite profonde

Les parametres const appliquent une immutabilite profonde - pas de modification via aucun chemin :

```hemlock
fn describe(const person: object) {
    print(person.name);       // OK : la lecture est autorisee
    // person.name = "Bob";   // ERREUR : cannot mutate
    // person.address.city = "NYC";  // ERREUR : const profond
}
```

### Ce que const empeche

| Type | Bloque par const | Autorise |
|------|------------------|----------|
| array | push, pop, shift, unshift, insert, remove, clear, reverse | slice, concat, map, filter, find, contains |
| object | assignation de champ | lecture de champ |
| buffer | assignation d'index | lecture d'index |
| string | assignation d'index | toutes les methodes (retournent de nouvelles chaines) |

## Arguments nommes

Les fonctions peuvent etre appelees avec des arguments nommes pour plus de clarte et de flexibilite :

### Arguments nommes basiques

```hemlock
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " a " + age + " ans");
}

// Arguments positionnels (traditionnel)
create_user("Alice", 25, false);

// Arguments nommes - peuvent etre dans n'importe quel ordre
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);
```

### Melanger positionnel et nomme

```hemlock
// Sauter les parametres optionnels en nommant ce dont vous avez besoin
create_user("David", active: false);  // Utilise l'age par defaut=18

// Les arguments nommes doivent venir apres les positionnels
create_user("Eve", age: 21);          // OK
// create_user(name: "Bad", 25);      // ERREUR : positionnel apres nomme
```

### Regles pour les arguments nommes

- Utilisez la syntaxe `name: value` pour les arguments nommes
- Les arguments nommes peuvent apparaitre dans n'importe quel ordre apres les arguments positionnels
- Les arguments positionnels ne peuvent pas suivre les arguments nommes
- Fonctionne avec les parametres par defaut/optionnels
- Les noms de parametre inconnus causent des erreurs a l'execution

## Limitations

Limitations actuelles a connaitre :

- **Pas de passage par reference** - Mot-cle `ref` parse mais pas implemente
- **Pas de surcharge de fonction** - Une fonction par nom
- **Pas d'optimisation de la recursivite terminale** - Recursivite profonde limitee par la taille de la pile

## Sujets connexes

- [Flux de controle](#language-guide-control-flow) - Utilisation des fonctions avec les structures de controle
- [Objets](#language-guide-objects) - Les methodes sont des fonctions stockees dans les objets
- [Gestion des erreurs](#language-guide-error-handling) - Fonctions et gestion des exceptions
- [Types](#language-guide-types) - Annotations de type et conversions

## Voir aussi

- **Fermetures** : Voir la section "Functions" de CLAUDE.md pour la semantique des fermetures
- **Valeurs de premiere classe** : Les fonctions sont des valeurs comme n'importe quelle autre
- **Portee lexicale** : Les fonctions capturent leur environnement de definition


--------------------------------------------------------------------------------
## Gestion de la MÃ©moire
--------------------------------------------------------------------------------

# Gestion de la memoire

Hemlock adopte la **gestion manuelle de la memoire** avec un controle explicite sur l'allocation et la desallocation. Ce guide couvre le modele memoire de Hemlock, les deux types de pointeur et l'API memoire complete.

---

## Memoire 101 : Les bases

**Nouveau en programmation ?** Commencez ici. Si vous comprenez deja la gestion de la memoire, passez a [Philosophie](#philosophie).

### Qu'est-ce que la gestion de la memoire ?

Quand votre programme a besoin de stocker des donnees (texte, nombres, listes), il a besoin d'espace pour les placer. Cet espace vient de la memoire de votre ordinateur (RAM). La gestion de la memoire concerne :

1. **Obtenir de l'espace** - demander de la memoire quand vous en avez besoin
2. **Utiliser l'espace** - lire et ecrire vos donnees
3. **Le rendre** - retourner la memoire quand vous avez fini

### Pourquoi est-ce important ?

Imaginez une bibliotheque avec des livres limites :
- Si vous continuez a emprunter des livres et ne les rendez jamais, il n'y en a plus
- Si vous essayez de lire un livre que vous avez deja rendu, vous serez confus ou causerez des problemes

La memoire fonctionne de la meme facon. Si vous oubliez de retourner la memoire, votre programme utilise de plus en plus (une "fuite memoire"). Si vous essayez d'utiliser la memoire apres l'avoir rendue, de mauvaises choses arrivent.

### La bonne nouvelle

**La plupart du temps, vous n'avez pas besoin d'y penser !**

Hemlock nettoie automatiquement la plupart des types courants :

```hemlock
fn example() {
    let name = "Alice";       // Hemlock gere ceci
    let numbers = [1, 2, 3];  // Et ceci
    let person = { age: 30 }; // Et cela aussi

    // Quand la fonction se termine, tout ceci est nettoye automatiquement !
}
```

### Quand vous DEVEZ y penser

Vous avez besoin de gestion manuelle de la memoire uniquement quand vous utilisez :

1. **`alloc()`** - allocation de memoire brute (retourne `ptr`)
2. **`buffer()`** - quand vous voulez liberer tot (optionnel - il s'auto-libere a la fin de portee)

```hemlock
// Ceci necessite un nettoyage manuel :
let raw = alloc(100);   // Memoire brute - VOUS devez la liberer
// ... utiliser raw ...
free(raw);              // Requis ! Sinon vous avez une fuite memoire

// Ceci se nettoie automatiquement (mais vous POUVEZ liberer tot) :
let buf = buffer(100);  // Buffer securise
// ... utiliser buf ...
// free(buf);           // Optionnel - s'auto-libere quand la portee se termine
```

### La regle simple

> **Si vous appelez `alloc()`, vous devez appeler `free()`.**
>
> Tout le reste est gere pour vous.

### Lequel utiliser ?

| Situation | Utilisez | Pourquoi |
|-----------|----------|----------|
| **Debutant** | `buffer()` | Securise, verifie les limites, auto-nettoyage |
| **Besoin de stockage d'octets** | `buffer()` | Securise et facile |
| **Travailler avec des bibliotheques C (FFI)** | `alloc()` / `ptr` | Requis pour l'interop C |
| **Performance maximale** | `alloc()` / `ptr` | Pas de surcharge de verification des limites |
| **Pas sur** | `buffer()` | Toujours le choix plus sur |

### Exemple rapide : Securise vs Brut

```hemlock
// RECOMMANDE : Buffer securise
fn safe_example() {
    let data = buffer(10);
    data[0] = 65;           // OK
    data[5] = 66;           // OK
    // data[100] = 67;      // ERREUR - Hemlock vous arrete (verification des limites)
    free(data);             // Nettoyage
}

// AVANCE : Pointeur brut (seulement quand necessaire)
fn raw_example() {
    let data = alloc(10);
    *data = 65;             // OK
    *(data + 5) = 66;       // OK
    *(data + 100) = 67;     // DANGER - Pas de verification des limites, corrompt la memoire !
    free(data);             // Nettoyage
}
```

**Commencez avec `buffer()`. Utilisez `alloc()` seulement quand vous avez specifiquement besoin de pointeurs bruts.**

---

## Philosophie

Hemlock suit le principe de gestion explicite de la memoire avec des valeurs par defaut sensees :
- Pas de garbage collection (pas de pauses imprevisibles)
- Comptage de reference interne pour les types courants (string, array, object, buffer)
- Les pointeurs bruts (`ptr`) necessitent un `free()` manuel

Cette approche hybride vous donne un controle complet quand necessaire (pointeurs bruts) tout en evitant les bugs courants pour les cas d'utilisation typiques (types comptes par reference auto-liberes a la sortie de portee).

## Comptage de reference interne

Le runtime utilise le **comptage de reference interne** pour gerer les durees de vie des objets. Pour la plupart des variables locales de types comptes par reference, le nettoyage est automatique et deterministe.

### Ce que gere le comptage de reference

Le runtime gere automatiquement les comptes de reference quand :

1. **Les variables sont reassignees** - l'ancienne valeur est liberee :
   ```hemlock
   let x = "first";   // ref_count = 1
   x = "second";      // "first" libere en interne, "second" ref_count = 1
   ```

2. **Les portees se terminent** - les variables locales sont liberees :
   ```hemlock
   fn example() {
       let arr = [1, 2, 3];  // ref_count = 1
   }  // arr libere quand la fonction retourne
   ```

3. **Les conteneurs sont liberes** - les elements sont liberes :
   ```hemlock
   let arr = [obj1, obj2];
   free(arr);  // obj1 et obj2 voient leur ref_count decremente
   ```

### Quand vous avez besoin de `free()` vs quand c'est automatique

**Automatique (pas de `free()` necessaire) :** Les variables locales de types comptes par reference sont liberees quand la portee se termine :

```hemlock
fn process_data() {
    let arr = [1, 2, 3];
    let obj = { name: "test" };
    let buf = buffer(64);
    // ... les utiliser ...
}  // Tout automatiquement libere quand la fonction retourne - pas de free() necessaire
```

**`free()` manuel requis :**

1. **Pointeurs bruts** - `alloc()` n'a pas de comptage de reference :
   ```hemlock
   let p = alloc(64);
   // ... utiliser p ...
   free(p);  // Toujours requis - fuira sinon
   ```

2. **Nettoyage anticipe** - liberer avant la fin de portee pour liberer la memoire plus tot :
   ```hemlock
   fn long_running() {
       let big = buffer(10000000);  // 10Mo
       // ... termine avec big ...
       free(big);  // Liberer maintenant, ne pas attendre que la fonction retourne
       // ... plus de travail qui n'a pas besoin de big ...
   }
   ```

3. **Donnees longue duree** - globales ou donnees stockees dans des structures persistantes :
   ```hemlock
   let cache = {};  // Niveau module, vit jusqu'a la fin du programme sauf si libere

   fn cleanup() {
       free(cache);  // Nettoyage manuel pour donnees longue duree
   }
   ```

### Comptage de reference vs Garbage Collection

| Aspect | Comptage ref Hemlock | Garbage Collection |
|--------|---------------------|-------------------|
| Moment du nettoyage | Deterministe (immediat quand ref atteint 0) | Non-deterministe (GC decide quand) |
| Responsabilite utilisateur | Doit appeler `free()` | Entierement automatique |
| Pauses runtime | Aucune | Pauses "stop the world" |
| Visibilite | Detail d'implementation cache | Generalement invisible |
| Cycles | Geres avec suivi de visited-set | Geres par tracage |

### Quels types ont le comptage de reference

| Type | Compte par ref | Notes |
|------|------------|-------|
| `ptr` | Non | Necessite toujours `free()` manuel |
| `buffer` | Oui | Auto-libere a la sortie de portee ; `free()` manuel pour nettoyage anticipe |
| `array` | Oui | Auto-libere a la sortie de portee ; `free()` manuel pour nettoyage anticipe |
| `object` | Oui | Auto-libere a la sortie de portee ; `free()` manuel pour nettoyage anticipe |
| `string` | Oui | Entierement automatique, pas de `free()` necessaire |
| `function` | Oui | Entierement automatique (environnements de fermeture) |
| `task` | Oui | Comptage de reference atomique thread-safe |
| `channel` | Oui | Comptage de reference atomique thread-safe |
| Primitives | Non | Allouees sur la pile, pas d'allocation tas |

### Pourquoi cette conception ?

Cette approche hybride vous donne :
- **Controle explicite** - Vous decidez quand desallouer
- **Securite des bugs de portee** - La reassignation ne fuit pas
- **Performance previsible** - Pas de pauses GC
- **Support des fermetures** - Les fonctions peuvent capturer les variables en securite

La philosophie reste : vous etes en controle, mais le runtime aide a prevenir les bugs courants comme les fuites a la reassignation ou les double-free dans les conteneurs.

## Les deux types de pointeur

Hemlock fournit deux types de pointeur distincts, chacun avec des caracteristiques de securite differentes :

### `ptr` - Pointeur brut (dangereux)

Les pointeurs bruts sont **juste des adresses** avec des garanties de securite minimales :

```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // Vous devez vous souvenir de liberer
```

**Caracteristiques :**
- Juste une adresse de 8 octets
- Pas de verification des limites
- Pas de suivi de longueur
- L'utilisateur gere entierement la duree de vie
- Pour experts et FFI

**Cas d'utilisation :**
- Programmation systeme bas niveau
- Interface de fonction etrangere (FFI)
- Code critique en performance
- Quand vous avez besoin d'un controle complet

**Dangers :**
```hemlock
let p = alloc(10);
let q = p + 100;  // Bien au-dela de l'allocation - autorise mais dangereux
free(p);
let x = *p;       // Pointeur pendant - comportement indefini
free(p);          // Double-free - va planter
```

### `buffer` - Enveloppe securisee (recommande)

Les buffers fournissent un **acces verifie en limites** tout en necessitant une desallocation manuelle :

```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // verifie en limites
print(b.length);        // 64
free(b);                // toujours manuel
```

**Caracteristiques :**
- Pointeur + longueur + capacite
- Verification des limites a l'acces
- Necessite toujours `free()` manuel
- Meilleur defaut pour la plupart du code

**Proprietes :**
```hemlock
let buf = buffer(100);
print(buf.length);      // 100 (taille actuelle)
print(buf.capacity);    // 100 (capacite allouee)
```

**Verification des limites :**
```hemlock
let buf = buffer(10);
buf[5] = 42;      // OK
buf[100] = 42;    // ERREUR : Index out of bounds
```

## API memoire

### Allocation de base

**`alloc(bytes)` - Allouer de la memoire brute**
```hemlock
let p = alloc(1024);  // Allouer 1Ko, retourne ptr
// ... utiliser la memoire
free(p);
```

**`buffer(size)` - Allouer un buffer securise**
```hemlock
let buf = buffer(256);  // Allouer un buffer de 256 octets
buf[0] = 65;            // 'A'
buf[1] = 66;            // 'B'
free(buf);
```

**`free(ptr)` - Liberer la memoire**
```hemlock
let p = alloc(100);
free(p);  // Doit liberer pour eviter la fuite memoire

let buf = buffer(100);
free(buf);  // Fonctionne sur ptr et buffer
```

**Important :** `free()` fonctionne sur les types `ptr` et `buffer`.

### Operations memoire

**`memset(ptr, byte, size)` - Remplir la memoire**
```hemlock
let p = alloc(100);
memset(p, 0, 100);     // Mettre a zero 100 octets
memset(p, 65, 10);     // Remplir les 10 premiers octets avec 'A'
free(p);
```

**`memcpy(dest, src, size)` - Copier la memoire**
```hemlock
let src = alloc(50);
let dst = alloc(50);
memset(src, 42, 50);
memcpy(dst, src, 50);  // Copier 50 octets de src vers dst
free(src);
free(dst);
```

**`realloc(ptr, size)` - Redimensionner l'allocation**
```hemlock
let p = alloc(100);
// ... utiliser 100 octets
p = realloc(p, 200);   // Redimensionner a 200 octets
// ... utiliser 200 octets
free(p);
```

**Note :** Apres `realloc()`, l'ancien pointeur peut etre invalide. Utilisez toujours le pointeur retourne.

### Allocation typee

Hemlock fournit des aides d'allocation typee pour la commodite :

```hemlock
let arr = talloc(i32, 100);  // Allouer 100 valeurs i32 (400 octets)
let size = sizeof(i32);      // Retourne 4 (octets)
```

**`sizeof(type)`** retourne la taille en octets d'un type :
- `sizeof(i8)` / `sizeof(u8)` -> 1
- `sizeof(i16)` / `sizeof(u16)` -> 2
- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` -> 4
- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` -> 8
- `sizeof(ptr)` -> 8 (sur systemes 64-bit)

**`talloc(type, count)`** alloue `count` elements de `type` :

```hemlock
let ints = talloc(i32, 10);   // 40 octets pour 10 valeurs i32
let floats = talloc(f64, 5);  // 40 octets pour 5 valeurs f64
free(ints);
free(floats);
```

## Modeles courants

### Modele : Allouer, utiliser, liberer

Le modele basique pour la gestion memoire :

```hemlock
// 1. Allouer
let data = alloc(1024);

// 2. Utiliser
memset(data, 0, 1024);
// ... faire le travail

// 3. Liberer
free(data);
```

### Modele : Utilisation de buffer securise

Preferez les buffers pour l'acces verifie en limites :

```hemlock
let buf = buffer(256);

// Iteration securisee
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

free(buf);
```

### Modele : Gestion de ressource avec try/finally

Assurer le nettoyage meme en cas d'erreur :

```hemlock
let data = alloc(1024);
try {
    // ... operations risquees
    process(data);
} finally {
    free(data);  // Toujours libere, meme en cas d'erreur
}
```

## Considerations de securite memoire

### Double-Free

**Autorise mais va planter :**
```hemlock
let p = alloc(100);
free(p);
free(p);  // CRASH : Double-free detected
```

**Prevention :**
```hemlock
let p = alloc(100);
free(p);
p = null;  // Mettre a null apres liberation

if (p != null) {
    free(p);  // Ne s'executera pas
}
```

### Pointeurs pendants

**Autorise mais comportement indefini :**
```hemlock
let p = alloc(100);
*p = 42;      // OK
free(p);
let x = *p;   // INDEFINI : Lecture de memoire liberee
```

**Prevention :** N'accedez pas a la memoire apres l'avoir liberee.

### Fuites memoire

**Facile a creer, difficile a debugger :**
```hemlock
fn leak_memory() {
    let p = alloc(1000);
    // Oublie de liberer !
    return;  // Memoire fuite
}
```

**Prevention :** Toujours associer `alloc()` avec `free()` :
```hemlock
fn safe_function() {
    let p = alloc(1000);
    try {
        // ... utiliser p
    } finally {
        free(p);  // Toujours libere
    }
}
```

### Arithmetique de pointeur

**Autorise mais dangereux :**
```hemlock
let p = alloc(10);
let q = p + 100;  // Bien au-dela de la limite d'allocation
*q = 42;          // INDEFINI : Ecriture hors limites
free(p);
```

**Utilisez les buffers pour la verification des limites :**
```hemlock
let buf = buffer(10);
buf[100] = 42;  // ERREUR : La verification des limites empeche le debordement
```

## Bonnes pratiques

1. **Defaut sur `buffer`** - Utilisez `buffer` sauf si vous avez specifiquement besoin de `ptr` brut
2. **Associer alloc/free** - Chaque `alloc()` devrait avoir exactement un `free()`
3. **Utiliser try/finally** - Assurer le nettoyage avec la gestion des exceptions
4. **Null apres free** - Mettre les pointeurs a `null` apres liberation pour attraper l'utilisation apres liberation
5. **Verifier les limites** - Utiliser l'indexation de buffer pour la verification automatique des limites
6. **Documenter la propriete** - Rendre clair quel code possede et libere chaque allocation

## Exemples

### Exemple : Constructeur de chaine dynamique

```hemlock
fn build_message(count: i32): ptr {
    let size = count * 10;
    let buf = alloc(size);

    let i = 0;
    while (i < count) {
        memset(buf + (i * 10), 65 + i, 10);
        i = i + 1;
    }

    return buf;  // L'appelant doit liberer
}

let msg = build_message(5);
// ... utiliser msg
free(msg);
```

### Exemple : Operations de tableau securisees

```hemlock
fn process_array(size: i32) {
    let arr = buffer(size);

    try {
        // Remplir le tableau
        let i = 0;
        while (i < arr.length) {
            arr[i] = i * 2;
            i = i + 1;
        }

        // Traiter
        i = 0;
        while (i < arr.length) {
            print(arr[i]);
            i = i + 1;
        }
    } finally {
        free(arr);  // Toujours nettoyer
    }
}
```

### Exemple : Modele de pool memoire

```hemlock
// Pool memoire simple (simplifie)
let pool = alloc(10000);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > 10000) {
        throw "Pool epuise";
    }

    let ptr = pool + pool_offset;
    pool_offset = pool_offset + size;
    return ptr;
}

// Utiliser le pool
let p1 = pool_alloc(100);
let p2 = pool_alloc(200);

// Liberer tout le pool d'un coup
free(pool);
```

## Limitations

Limitations actuelles a connaitre :

- **Les pointeurs bruts necessitent un free manuel** - `alloc()` retourne `ptr` sans comptage de reference
- **Pas d'allocateurs personnalises** - Seulement malloc/free systeme

**Note :** Les types comptes par reference (string, array, object, buffer) SONT automatiquement liberes quand la portee se termine. Seul le `ptr` brut de `alloc()` necessite un `free()` explicite.

## Sujets connexes

- [Chaines](#language-guide-strings) - Gestion memoire des chaines et encodage UTF-8
- [Tableaux](#language-guide-arrays) - Tableaux dynamiques et leurs caracteristiques memoire
- [Objets](#language-guide-objects) - Allocation et duree de vie des objets
- [Gestion des erreurs](#language-guide-error-handling) - Utiliser try/finally pour le nettoyage

## Voir aussi

- **Philosophie de conception** : Voir section "Memory Management" de CLAUDE.md
- **Systeme de types** : Voir [Types](#language-guide-types) pour les details des types `ptr` et `buffer`
- **FFI** : Les pointeurs bruts sont essentiels pour l'Interface de Fonction Etrangere


--------------------------------------------------------------------------------
## Gestion des Erreurs
--------------------------------------------------------------------------------

# Gestion des erreurs

Hemlock supporte la gestion des erreurs basee sur les exceptions avec `try`, `catch`, `finally`, `throw` et `panic`. Ce guide couvre les erreurs recuperables avec les exceptions et les erreurs irrecuperables avec panic.

## Apercu

```hemlock
// Gestion d'erreur basique
try {
    risky_operation();
} catch (e) {
    print("Erreur: " + e);
}

// Avec nettoyage
try {
    process_file();
} catch (e) {
    print("Echec: " + e);
} finally {
    cleanup();
}

// Lever des erreurs
fn divide(a, b) {
    if (b == 0) {
        throw "division par zero";
    }
    return a / b;
}
```

## Try-Catch-Finally

### Syntaxe

**Try/catch basique :**
```hemlock
try {
    // code risque
} catch (e) {
    // gerer l'erreur, e contient la valeur levee
}
```

**Try/finally :**
```hemlock
try {
    // code risque
} finally {
    // s'execute toujours, meme si une exception est levee
}
```

**Try/catch/finally :**
```hemlock
try {
    // code risque
} catch (e) {
    // gerer l'erreur
} finally {
    // code de nettoyage
}
```

### Bloc Try

Le bloc try execute les instructions sequentiellement :

```hemlock
try {
    print("Demarrage...");
    risky_operation();
    print("Succes!");  // Seulement si pas d'exception
}
```

**Comportement :**
- Execute les instructions dans l'ordre
- Si une exception est levee : saute au `catch` ou `finally`
- Si pas d'exception : execute `finally` (si present) puis continue

### Bloc Catch

Le bloc catch recoit la valeur levee :

```hemlock
try {
    throw "oups";
} catch (error) {
    print("Attrape: " + error);  // error = "oups"
    // error seulement accessible ici
}
// error non accessible ici
```

**Parametre catch :**
- Recoit la valeur levee (n'importe quel type)
- Portee limitee au bloc catch
- Peut etre nomme n'importe comment (conventionnellement `e`, `err` ou `error`)

**Ce que vous pouvez faire dans catch :**
```hemlock
try {
    risky_operation();
} catch (e) {
    // Logger l'erreur
    print("Erreur: " + e);

    // Relever la meme erreur
    throw e;

    // Lever une erreur differente
    throw "erreur differente";

    // Retourner une valeur par defaut
    return null;

    // Gerer et continuer
    // (pas de throw)
}
```

### Bloc Finally

Le bloc finally **s'execute toujours** :

```hemlock
try {
    print("1: bloc try");
    throw "erreur";
} catch (e) {
    print("2: bloc catch");
} finally {
    print("3: bloc finally");  // S'execute toujours
}
print("4: apres try/catch/finally");

// Sortie : 1: bloc try, 2: bloc catch, 3: bloc finally, 4: apres try/catch/finally
```

**Quand finally s'execute :**
- Apres le bloc try (si pas d'exception)
- Apres le bloc catch (si exception attrapee)
- Meme si try/catch contient `return`, `break` ou `continue`
- Avant que le flux de controle ne quitte le try/catch

**Finally avec return :**
```hemlock
fn example() {
    try {
        return 1;  // Retourne 1 apres que finally s'execute
    } finally {
        print("nettoyage");  // S'execute avant de retourner
    }
}

fn example2() {
    try {
        return 1;
    } finally {
        return 2;  // Le return de finally remplace - retourne 2
    }
}
```

**Finally avec flux de controle :**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    try {
        if (i == 5) {
            break;  // Break apres que finally s'execute
        }
    } finally {
        print("nettoyage " + typeof(i));
    }
}
```

## Instruction Throw

### Throw basique

Lever n'importe quelle valeur comme exception :

```hemlock
throw "message d'erreur";
throw 404;
throw { code: 500, message: "Erreur interne" };
throw null;
throw ["erreur", "details"];
```

**Execution :**
1. Evalue l'expression
2. Saute immediatement au `catch` englobant le plus proche
3. Si pas de `catch`, propage dans la pile d'appels

### Lever des erreurs

```hemlock
fn validate_age(age: i32) {
    if (age < 0) {
        throw "L'age ne peut pas etre negatif";
    }
    if (age > 150) {
        throw "L'age est irrealiste";
    }
}

try {
    validate_age(-5);
} catch (e) {
    print("Erreur de validation: " + e);
}
```

### Lever des objets d'erreur

Creer des informations d'erreur structurees :

```hemlock
fn read_file(path: string) {
    if (!file_exists(path)) {
        throw {
            type: "FileNotFound",
            path: path,
            message: "Le fichier n'existe pas"
        };
    }
    // ... lire le fichier
}

try {
    read_file("missing.txt");
} catch (e) {
    if (e.type == "FileNotFound") {
        print("Fichier non trouve: " + e.path);
    }
}
```

### Relever (re-throwing)

Attraper et relever des erreurs :

```hemlock
fn wrapper() {
    try {
        risky_operation();
    } catch (e) {
        print("Logger erreur: " + e);
        throw e;  // Relever a l'appelant
    }
}

try {
    wrapper();
} catch (e) {
    print("Attrape dans main: " + e);
}
```

## Exceptions non attrapees

Si une exception se propage au sommet de la pile d'appels sans etre attrapee :

```hemlock
fn foo() {
    throw "non attrapee!";
}

foo();  // Plante avec : Runtime error: non attrapee!
```

**Comportement :**
- Le programme plante
- Affiche le message d'erreur sur stderr
- Quitte avec un code de statut non nul
- Trace de pile a ajouter dans les versions futures

## Panic - Erreurs irrecuperables

### Qu'est-ce que Panic ?

`panic()` est pour les **erreurs irrecuperables** qui devraient immediatement terminer le programme :

```hemlock
panic();                    // Message par defaut : "panic!"
panic("message personnalise");    // Message personnalise
panic(42);                  // Les valeurs non-chaine sont affichees
```

**Semantique :**
- **Quitte immediatement** le programme avec code de sortie 1
- Affiche le message d'erreur sur stderr : `panic: <message>`
- **NON attrapable** avec try/catch
- Utiliser pour les bugs et erreurs irrecuperables

### Panic vs Throw

```hemlock
// throw - Erreur recuperable (peut etre attrapee)
try {
    throw "erreur recuperable";
} catch (e) {
    print("Attrape: " + e);  // Attrape avec succes
}

// panic - Erreur irrecuperable (ne peut pas etre attrapee)
try {
    panic("erreur irrecuperable");  // Le programme quitte immediatement
} catch (e) {
    print("Ceci ne s'execute jamais");       // Ne s'execute jamais
}
```

### Quand utiliser Panic

**Utilisez panic pour :**
- **Bugs** : Du code inatteignable a ete atteint
- **Etat invalide** : Corruption de structure de donnees detectee
- **Erreurs irrecuperables** : Ressource critique indisponible
- **Echecs d'assertion** : Quand `assert()` n'est pas suffisant

**Exemples :**
```hemlock
// Code inatteignable
fn process_state(state: i32) {
    if (state == 1) {
        return "pret";
    } else if (state == 2) {
        return "en cours";
    } else if (state == 3) {
        return "arrete";
    } else {
        panic("etat invalide: " + typeof(state));  // Ne devrait jamais arriver
    }
}

// Verification de ressource critique
fn init_system() {
    let config = read_file("config.json");
    if (config == null) {
        panic("config.json non trouve - impossible de demarrer");
    }
    // ...
}

// Invariant de structure de donnees
fn pop_stack(stack) {
    if (stack.length == 0) {
        panic("pop() appele sur pile vide");
    }
    return stack.pop();
}
```

### Quand NE PAS utiliser Panic

**Utilisez throw a la place pour :**
- Validation d'entree utilisateur
- Fichier non trouve
- Erreurs reseau
- Conditions d'erreur attendues

```hemlock
// MAUVAIS : Panic pour erreurs attendues
fn divide(a, b) {
    if (b == 0) {
        panic("division par zero");  // Trop severe
    }
    return a / b;
}

// BON : Throw pour erreurs attendues
fn divide(a, b) {
    if (b == 0) {
        throw "division par zero";  // Recuperable
    }
    return a / b;
}
```

## Interactions avec le flux de controle

### Return dans Try/Catch/Finally

```hemlock
fn example() {
    try {
        return 1;  // Retourne 1 apres que finally s'execute
    } finally {
        print("nettoyage");
    }
}

fn example2() {
    try {
        return 1;
    } finally {
        return 2;  // Le return de finally remplace celui de try - retourne 2
    }
}
```

**Regle :** Les valeurs de retour du bloc finally remplacent les valeurs de retour try/catch.

### Break/Continue dans Try/Catch/Finally

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    try {
        if (i == 5) { break; }  // Break apres que finally s'execute
    } finally {
        print("nettoyage " + typeof(i));
    }
}
```

**Regle :** Break/continue s'executent apres le bloc finally.

### Try/Catch imbrique

```hemlock
try {
    try {
        throw "inner";
    } catch (e) {
        print("Attrape: " + e);  // Affiche : Attrape: inner
        throw "outer";  // Releve une erreur differente
    }
} catch (e) {
    print("Attrape: " + e);  // Affiche : Attrape: outer
}
```

**Regle :** Les blocs try/catch imbriques fonctionnent comme attendu, les catches internes arrivent en premier.

## Modeles courants

### Modele : Nettoyage de ressource

Utilisez toujours `finally` pour le nettoyage :

```hemlock
fn process_file(filename) {
    let file = null;
    try {
        file = open(filename);
        let content = file.read();
        process(content);
    } catch (e) {
        print("Erreur lors du traitement du fichier: " + e);
    } finally {
        if (file != null) {
            file.close();  // Ferme toujours, meme en cas d'erreur
        }
    }
}
```

### Modele : Enveloppe d'erreur

Envelopper les erreurs de bas niveau avec du contexte :

```hemlock
fn load_config(path) {
    try {
        let content = read_file(path);
        return parse_json(content);
    } catch (e) {
        throw "Echec du chargement de config depuis " + path + ": " + e;
    }
}
```

### Modele : Recuperation d'erreur

Fournir une valeur de repli en cas d'erreur :

```hemlock
fn safe_divide(a, b) {
    try {
        if (b == 0) {
            throw "division par zero";
        }
        return a / b;
    } catch (e) {
        print("Erreur: " + e);
        return null;  // Valeur de repli
    }
}
```

### Modele : Validation

Utiliser les exceptions pour la validation :

```hemlock
fn validate_user(user) {
    if (user.name == null || user.name == "") {
        throw "Le nom est requis";
    }
    if (user.age < 0 || user.age > 150) {
        throw "Age invalide";
    }
    if (user.email == null || !user.email.contains("@")) {
        throw "Email invalide";
    }
}

try {
    validate_user({ name: "Alice", age: -5, email: "invalide" });
} catch (e) {
    print("Validation echouee: " + e);
}
```

### Modele : Types d'erreur multiples

Utiliser des objets d'erreur pour distinguer les types d'erreur :

```hemlock
fn process_data(data) {
    if (data == null) {
        throw { type: "NullData", message: "Les donnees sont null" };
    }

    if (typeof(data) != "array") {
        throw { type: "TypeError", message: "Tableau attendu" };
    }

    if (data.length == 0) {
        throw { type: "EmptyData", message: "Le tableau est vide" };
    }

    // ... traitement
}

try {
    process_data(null);
} catch (e) {
    if (e.type == "NullData") {
        print("Pas de donnees fournies");
    } else if (e.type == "TypeError") {
        print("Mauvais type de donnees: " + e.message);
    } else {
        print("Erreur: " + e.message);
    }
}
```

## Bonnes pratiques

1. **Utilisez les exceptions pour les cas exceptionnels** - Pas pour le flux de controle normal
2. **Levez des erreurs significatives** - Utilisez des chaines ou objets avec contexte
3. **Utilisez toujours finally pour le nettoyage** - Assure que les ressources sont liberees
4. **N'attrapez pas pour ignorer** - Au minimum loggez l'erreur
5. **Relevez quand approprie** - Laissez l'appelant gerer si vous ne pouvez pas
6. **Panic pour les bugs** - Utilisez panic pour les erreurs irrecuperables
7. **Documentez les exceptions** - Rendez clair quelles fonctions peuvent lever

## Pieges courants

### Piege : Avaler les erreurs

```hemlock
// MAUVAIS : Echec silencieux
try {
    risky_operation();
} catch (e) {
    // Erreur ignoree - echec silencieux
}

// BON : Logger ou gerer
try {
    risky_operation();
} catch (e) {
    print("Operation echouee: " + e);
    // Gerer de maniere appropriee
}
```

### Piege : Remplacement par Finally

```hemlock
// MAUVAIS : Finally remplace le return
fn get_value() {
    try {
        return 42;
    } finally {
        return 0;  // Retourne 0, pas 42 !
    }
}

// BON : Ne pas retourner dans finally
fn get_value() {
    try {
        return 42;
    } finally {
        cleanup();  // Juste nettoyage, pas de return
    }
}
```

### Piege : Oublier le nettoyage

```hemlock
// MAUVAIS : Le fichier peut ne pas etre ferme en cas d'erreur
fn process() {
    let file = open("data.txt");
    let content = file.read();  // Peut lever
    file.close();  // Jamais atteint si erreur
}

// BON : Utiliser finally
fn process() {
    let file = null;
    try {
        file = open("data.txt");
        let content = file.read();
    } finally {
        if (file != null) {
            file.close();
        }
    }
}
```

### Piege : Utiliser Panic pour erreurs attendues

```hemlock
// MAUVAIS : Panic pour erreur attendue
fn read_config(path) {
    if (!file_exists(path)) {
        panic("Fichier de config non trouve");  // Trop severe
    }
    return read_file(path);
}

// BON : Throw pour erreur attendue
fn read_config(path) {
    if (!file_exists(path)) {
        throw "Fichier de config non trouve: " + path;  // Recuperable
    }
    return read_file(path);
}
```

## Exemples

### Exemple : Gestion d'erreur basique

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "division par zero";
    }
    return a / b;
}

try {
    print(divide(10, 0));
} catch (e) {
    print("Erreur: " + e);  // Affiche : Erreur: division par zero
}
```

### Exemple : Gestion de ressource

```hemlock
fn copy_file(src, dst) {
    let src_file = null;
    let dst_file = null;

    try {
        src_file = open(src, "r");
        dst_file = open(dst, "w");

        let content = src_file.read();
        dst_file.write(content);

        print("Fichier copie avec succes");
    } catch (e) {
        print("Echec de la copie du fichier: " + e);
        throw e;  // Relever
    } finally {
        if (src_file != null) { src_file.close(); }
        if (dst_file != null) { dst_file.close(); }
    }
}
```

### Exemple : Gestion d'erreur imbriquee

```hemlock
fn process_users(users) {
    let success_count = 0;
    let error_count = 0;

    let i = 0;
    while (i < users.length) {
        try {
            validate_user(users[i]);
            save_user(users[i]);
            success_count = success_count + 1;
        } catch (e) {
            print("Echec du traitement de l'utilisateur: " + e);
            error_count = error_count + 1;
        }
        i = i + 1;
    }

    print("Traites: " + typeof(success_count) + " succes, " + typeof(error_count) + " erreurs");
}
```

### Exemple : Types d'erreur personnalises

```hemlock
fn create_error(type, message, details) {
    return {
        type: type,
        message: message,
        details: details,
        toString: fn() {
            return self.type + ": " + self.message;
        }
    };
}

fn divide(a, b) {
    if (typeof(a) != "i32" && typeof(a) != "f64") {
        throw create_error("TypeError", "a doit etre un nombre", { value: a });
    }
    if (typeof(b) != "i32" && typeof(b) != "f64") {
        throw create_error("TypeError", "b doit etre un nombre", { value: b });
    }
    if (b == 0) {
        throw create_error("DivisionByZero", "Impossible de diviser par zero", { a: a, b: b });
    }
    return a / b;
}

try {
    divide(10, 0);
} catch (e) {
    print(e.toString());
    if (e.type == "DivisionByZero") {
        print("Details: a=" + typeof(e.details.a) + ", b=" + typeof(e.details.b));
    }
}
```

### Exemple : Logique de reessai

```hemlock
fn retry(operation, max_attempts) {
    let attempt = 0;

    while (attempt < max_attempts) {
        try {
            return operation();  // Succes !
        } catch (e) {
            attempt = attempt + 1;
            if (attempt >= max_attempts) {
                throw "Operation echouee apres " + typeof(max_attempts) + " tentatives: " + e;
            }
            print("Tentative " + typeof(attempt) + " echouee, nouvel essai...");
        }
    }
}

fn unreliable_operation() {
    // Operation peu fiable simulee
    if (random() < 0.7) {
        throw "Operation echouee";
    }
    return "Succes";
}

try {
    let result = retry(unreliable_operation, 3);
    print(result);
} catch (e) {
    print("Tous les reessais ont echoue: " + e);
}
```

## Ordre d'execution

Comprendre l'ordre d'execution :

```hemlock
try {
    print("1: debut bloc try");
    throw "erreur";
    print("2: jamais atteint");
} catch (e) {
    print("3: bloc catch");
} finally {
    print("4: bloc finally");
}
print("5: apres try/catch/finally");

// Sortie :
// 1: debut bloc try
// 3: bloc catch
// 4: bloc finally
// 5: apres try/catch/finally
```

## Limitations actuelles

- **Pas de trace de pile** - Les exceptions non attrapees n'affichent pas la trace de pile (prevu)
- **Certaines fonctions integrees quittent** - Certaines fonctions integrees font `exit()` au lieu de lever (a revoir)
- **Pas de types d'exception personnalises** - N'importe quelle valeur peut etre levee, mais pas de hierarchie d'exception formelle

## Sujets connexes

- [Fonctions](#language-guide-functions) - Exceptions et retours de fonction
- [Flux de controle](#language-guide-control-flow) - Comment les exceptions affectent le flux de controle
- [Memoire](#language-guide-memory) - Utiliser finally pour le nettoyage memoire

## Voir aussi

- **Semantique des exceptions** : Voir section "Error Handling" de CLAUDE.md
- **Panic vs Throw** : Cas d'utilisation differents pour types d'erreur differents
- **Garantie Finally** : S'execute toujours, meme avec return/break/continue


--------------------------------------------------------------------------------
## Modules
--------------------------------------------------------------------------------

# Systeme de modules Hemlock

Ce document decrit le systeme de modules import/export de style ES6 implemente pour Hemlock.

## Apercu

Hemlock supporte un systeme de modules base sur les fichiers avec une syntaxe import/export de style ES6. Les modules sont :
- **Singletons** : Chaque module est charge une fois et mis en cache
- **Bases sur les fichiers** : Les modules correspondent a des fichiers .hml sur disque
- **Explicitement importes** : Les dependances sont declarees avec des instructions import
- **Executes topologiquement** : Les dependances sont executees avant les dependants

Pour la gestion des paquets et les dependances tierces, voir [hpm (Hemlock Package Manager)](https://github.com/hemlang/hpm).

## Syntaxe

### Instructions d'export

**Exports nommes en ligne :**
```hemlock
export fn add(a, b) {
    return a + b;
}

export const PI = 3.14159;
export let counter = 0;
```

**Liste d'export :**
```hemlock
fn add(a, b) { return a + b; }
fn subtract(a, b) { return a - b; }

export { add, subtract };
```

**Export Extern (fonctions FFI) :**
```hemlock
import "libc.so.6";

// Exporter des fonctions FFI pour utilisation dans d'autres modules
export extern fn strlen(s: string): i32;
export extern fn getpid(): i32;
```

Voir [Documentation FFI](../advanced/ffi.md#exporting-ffi-functions) pour plus de details sur l'export des fonctions FFI.

**Export Define (types struct) :**
```hemlock
// Exporter des definitions de type struct
export define Vector2 {
    x: f32,
    y: f32,
}

export define Rectangle {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
}
```

**Important :** Les types struct exportes sont enregistres globalement quand le module est charge. Ils deviennent disponibles automatiquement quand vous importez quoi que ce soit du module - vous n'avez PAS besoin de (et ne pouvez pas) les importer explicitement par nom :

```hemlock
// BON - les types struct sont auto-disponibles apres tout import
import { some_function } from "./my_module.hml";
let v: Vector2 = { x: 1.0, y: 2.0 };  // Fonctionne !

// MAUVAIS - impossible d'importer explicitement les types struct
import { Vector2 } from "./my_module.hml";  // Erreur : Undefined variable 'Vector2'
```

Voir [Documentation FFI](../advanced/ffi.md#exporting-struct-types) pour plus de details sur l'export des types struct.

**Re-exports :**
```hemlock
// Re-exporter depuis un autre module
export { add, subtract } from "./math.hml";
```

### Instructions d'import

**Imports nommes :**
```hemlock
import { add, subtract } from "./math.hml";
print(add(1, 2));  // 3
```

**Import d'espace de noms :**
```hemlock
import * as math from "./math.hml";
print(math.add(1, 2));  // 3
print(math.PI);  // 3.14159
```

**Alias :**
```hemlock
import { add as sum, subtract as diff } from "./math.hml";
print(sum(1, 2));  // 3
```

## Resolution de module

### Types de chemin

**Chemins relatifs :**
```hemlock
import { foo } from "./module.hml";       // Meme repertoire
import { bar } from "../parent.hml";      // Repertoire parent
import { baz } from "./sub/nested.hml";   // Sous-repertoire
```

**Chemins absolus :**
```hemlock
import { foo } from "/absolute/path/to/module.hml";
```

**Gestion des extensions :**
- L'extension `.hml` peut etre omise - elle sera ajoutee automatiquement
- `./math` se resout en `./math.hml`

## Fonctionnalites

### Detection de dependance circulaire

Le systeme de modules detecte les dependances circulaires et signale une erreur :

```
Error: Circular dependency detected when loading '/path/to/a.hml'
```

### Mise en cache des modules

Les modules sont charges une fois et mis en cache. Plusieurs imports du meme module retournent la meme instance :

```hemlock
// counter.hml
export let count = 0;
export fn increment() {
    count = count + 1;
}

// a.hml
import { count, increment } from "./counter.hml";
increment();
print(count);  // 1

// b.hml
import { count } from "./counter.hml";  // Meme instance !
print(count);  // Toujours 1 (etat partage)
```

### Immutabilite des imports

Les liaisons importees ne peuvent pas etre reassignees :

```hemlock
import { add } from "./math.hml";
add = fn() { };  // ERREUR : cannot reassign imported binding
```

## Details d'implementation

### Architecture

**Fichiers :**
- `include/module.h` - API du systeme de modules
- `src/module.c` - Chargement, mise en cache et execution des modules
- Support parser dans `src/parser.c`
- Support runtime dans `src/interpreter/runtime.c`

**Composants cles :**
1. **ModuleCache** : Maintient les modules charges indexes par chemin absolu
2. **Module** : Represente un module charge avec son AST et exports
3. **Resolution de chemin** : Resout les chemins relatifs/absolus en chemins canoniques
4. **Execution topologique** : Execute les modules dans l'ordre des dependances

### Processus de chargement des modules

1. **Phase d'analyse** : Tokeniser et analyser le fichier module
2. **Resolution des dependances** : Charger recursivement les modules importes
3. **Detection de cycle** : Verifier si le module est deja en cours de chargement
4. **Mise en cache** : Stocker le module dans le cache par chemin absolu
5. **Phase d'execution** : Executer dans l'ordre topologique (dependances d'abord)

### API

```c
// API haut niveau
int execute_file_with_modules(const char *file_path,
                               int argc, char **argv,
                               ExecutionContext *ctx);

// API bas niveau
ModuleCache* module_cache_new(const char *initial_dir);
void module_cache_free(ModuleCache *cache);
Module* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);
void execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);
```

## Tests

Les modules de test sont situes dans `tests/modules/` et `tests/parity/modules/` :

- `math.hml` - Module basique avec exports
- `test_import_named.hml` - Test d'import nomme
- `test_import_namespace.hml` - Test d'import d'espace de noms
- `test_import_alias.hml` - Test d'alias d'import
- `export_extern.hml` - Test d'export extern de fonction FFI (Linux)

## Imports de paquets (hpm)

Avec [hpm](https://github.com/hemlang/hpm) installe, vous pouvez importer des paquets tiers depuis GitHub :

```hemlock
// Importer depuis la racine du paquet (utilise "main" de package.json)
import { app, router } from "hemlang/sprout";

// Importer depuis un sous-chemin
import { middleware } from "hemlang/sprout/middleware";

// Bibliotheque standard (integree a Hemlock)
import { HashMap } from "@stdlib/collections";
```

Les paquets sont installes dans `hem_modules/` et resolus en utilisant la syntaxe GitHub `owner/repo`.

```bash
# Installer un paquet
hpm install hemlang/sprout

# Installer avec contrainte de version
hpm install hemlang/sprout@^1.0.0
```

Voir la [documentation hpm](https://github.com/hemlang/hpm) pour tous les details.

## Limitations actuelles

1. **Pas d'imports dynamiques** : `import()` comme fonction runtime n'est pas supporte
2. **Pas d'exports conditionnels** : Les exports doivent etre au niveau superieur
3. **Chemins de bibliotheque statiques** : Les imports de bibliotheque FFI utilisent des chemins statiques (specifiques a la plateforme)

## Travaux futurs

- Imports dynamiques avec fonction `import()`
- Exports conditionnels
- Metadonnees de module (`import.meta`)
- Tree shaking et elimination de code mort

## Exemples

Voir `tests/modules/` pour des exemples fonctionnels du systeme de modules.

Exemple de structure de module :
```
project/
|-- main.hml
|-- lib/
|   |-- math.hml
|   |-- string.hml
|   |-- index.hml (module barrel)
|-- utils/
    |-- helpers.hml
```

Exemple d'utilisation :
```hemlock
// lib/math.hml
export fn add(a, b) { return a + b; }
export fn multiply(a, b) { return a * b; }

// lib/index.hml (barrel)
export { add, multiply } from "./math.hml";

// main.hml
import { add } from "./lib/index.hml";
print(add(2, 3));  // 5
```


--------------------------------------------------------------------------------
## Objets
--------------------------------------------------------------------------------

# Objets

Hemlock implemente des objets de style JavaScript avec allocation sur le tas, champs dynamiques, methodes et typage canard. Les objets sont des structures de donnees flexibles qui combinent donnees et comportement.

## Apercu

```hemlock
// Objet anonyme
let person = { name: "Alice", age: 30, city: "NYC" };
print(person.name);  // "Alice"

// Objet avec methodes
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    }
};

counter.increment();
print(counter.count);  // 1
```

## Litteraux d'objet

### Syntaxe basique

```hemlock
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};
```

**Syntaxe :**
- Les accolades `{}` enclosent l'objet
- Paires cle-valeur separees par des virgules
- Les cles sont des identifiants (pas de guillemets necessaires)
- Les valeurs peuvent etre de n'importe quel type

### Objets vides

```hemlock
let obj = {};  // Objet vide

// Ajouter des champs plus tard
obj.name = "Alice";
obj.age = 30;
```

### Objets imbriques

```hemlock
let user = {
    info: {
        name: "Bob",
        age: 25
    },
    active: true,
    settings: {
        theme: "dark",
        notifications: true
    }
};

print(user.info.name);           // "Bob"
print(user.settings.theme);      // "dark"
```

### Types de valeur mixtes

```hemlock
let mixed = {
    number: 42,
    text: "hello",
    flag: true,
    data: null,
    items: [1, 2, 3],
    config: { x: 10, y: 20 }
};
```

### Syntaxe de propriete abregee

Quand un nom de variable correspond au nom de propriete, utilisez la syntaxe abregee :

```hemlock
let name = "Alice";
let age = 30;
let active = true;

// Abrege : { name } est equivalent a { name: name }
let person = { name, age, active };

print(person.name);   // "Alice"
print(person.age);    // 30
print(person.active); // true
```

**Melanger abrege avec proprietes regulieres :**
```hemlock
let city = "NYC";
let obj = { name, age, city, role: "admin" };
```

### Operateur spread

L'operateur spread (`...`) copie tous les champs d'un objet dans un autre :

```hemlock
let base = { x: 1, y: 2 };
let extended = { ...base, z: 3 };

print(extended.x);  // 1
print(extended.y);  // 2
print(extended.z);  // 3
```

**Remplacer des valeurs avec spread :**
```hemlock
let defaults = { theme: "light", size: "medium", debug: false };
let custom = { ...defaults, theme: "dark" };

print(custom.theme);  // "dark" (remplace)
print(custom.size);   // "medium" (depuis defaults)
print(custom.debug);  // false (depuis defaults)
```

**Spreads multiples (les spreads ulterieurs remplacent les precedents) :**
```hemlock
let a = { x: 1 };
let b = { y: 2 };
let merged = { ...a, ...b, z: 3 };

print(merged.x);  // 1
print(merged.y);  // 2
print(merged.z);  // 3

// Le spread ulterieur remplace le precedent
let first = { val: "first" };
let second = { val: "second" };
let combined = { ...first, ...second };
print(combined.val);  // "second"
```

**Combiner abrege et spread :**
```hemlock
let status = "active";
let data = { id: 1, name: "Item" };
let full = { ...data, status };

print(full.id);      // 1
print(full.name);    // "Item"
print(full.status);  // "active"
```

**Modele de remplacement de configuration :**
```hemlock
let defaultConfig = {
    debug: false,
    timeout: 30,
    retries: 3
};

let prodConfig = { ...defaultConfig, timeout: 60 };
let devConfig = { ...defaultConfig, debug: true };

print(prodConfig.timeout);  // 60
print(devConfig.debug);     // true
```

**Note :** Le spread effectue une copie superficielle. Les objets imbriques partagent les references :
```hemlock
let nested = { inner: { val: 42 } };
let copied = { ...nested };
print(copied.inner.val);  // 42 (meme reference que nested.inner)
```

## Acces aux champs

### Notation point

```hemlock
let person = { name: "Alice", age: 30 };

// Lire le champ
let name = person.name;      // "Alice"
let age = person.age;        // 30

// Modifier le champ
person.age = 31;
print(person.age);           // 31
```

### Ajout dynamique de champs

Ajouter de nouveaux champs a l'execution :

```hemlock
let person = { name: "Alice" };

// Ajouter un nouveau champ
person.email = "alice@example.com";
person.phone = "555-1234";

print(person.email);  // "alice@example.com"
```

### Suppression de champs

**Note :** La suppression de champs n'est pas actuellement supportee. Definissez a `null` a la place :

```hemlock
let obj = { x: 10, y: 20 };

// Impossible de supprimer des champs (non supporte)
// obj.x = undefined;  // Pas de 'undefined' en Hemlock

// Solution : Definir a null
obj.x = null;
```

## Methodes et `self`

### Definir des methodes

Les methodes sont des fonctions stockees dans les champs d'objet :

```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    },
    decrement: fn() {
        self.count = self.count - 1;
    },
    get: fn() {
        return self.count;
    }
};
```

### Le mot-cle `self`

Quand une fonction est appelee comme methode, `self` est automatiquement lie a l'objet :

```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;  // self fait reference a counter
    }
};

counter.increment();  // self est lie a counter
print(counter.count);  // 1
```

**Fonctionnement :**
- Les appels de methode sont detectes en verifiant si l'expression de fonction est un acces de propriete
- `self` est automatiquement lie a l'objet au moment de l'appel
- `self` est en lecture seule (impossible de reassigner `self` lui-meme)

### Detection d'appel de methode

```hemlock
let obj = {
    value: 10,
    method: fn() {
        return self.value;
    }
};

// Appele comme methode - self est lie
print(obj.method());  // 10

// Appele comme fonction - self est null (erreur)
let f = obj.method;
print(f());  // ERREUR : self is not defined
```

### Methodes avec parametres

```hemlock
let calculator = {
    result: 0,
    add: fn(x) {
        self.result = self.result + x;
    },
    multiply: fn(x) {
        self.result = self.result * x;
    },
    get: fn() {
        return self.result;
    }
};

calculator.add(5);
calculator.multiply(2);
print(calculator.get());  // 10
```

## Definitions de type avec `define`

### Definition de type basique

Definir les formes d'objet avec `define` :

```hemlock
define Person {
    name: string,
    age: i32,
    active: bool,
}

// Creer un objet et assigner a une variable typee
let p = { name: "Alice", age: 30, active: true };
let typed_p: Person = p;  // Le typage canard valide la structure

print(typeof(typed_p));  // "Person"
```

**Ce que fait `define` :**
- Declare un type avec des champs requis
- Active la validation par typage canard
- Definit le nom de type de l'objet pour `typeof()`

### Typage canard

Les objets sont valides contre `define` en utilisant la **compatibilite structurelle** :

```hemlock
define Person {
    name: string,
    age: i32,
}

// OK : A tous les champs requis
let p1: Person = { name: "Alice", age: 30 };

// OK : Les champs supplementaires sont autorises
let p2: Person = {
    name: "Bob",
    age: 25,
    city: "NYC",
    active: true
};

// ERREUR : Champ requis 'age' manquant
let p3: Person = { name: "Carol" };

// ERREUR : Mauvais type pour 'age'
let p4: Person = { name: "Dave", age: "trente" };
```

**Regles du typage canard :**
- Tous les champs requis doivent etre presents
- Les types de champs doivent correspondre
- Les champs supplementaires sont autorises et preserves
- La validation a lieu au moment de l'assignation

### Champs optionnels

Les champs peuvent etre optionnels avec des valeurs par defaut :

```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,       // Optionnel avec valeur par defaut
    nickname?: string,   // Optionnel, par defaut null
}

// Objet avec seulement les champs requis
let p = { name: "Alice", age: 30 };
let typed_p: Person = p;

print(typed_p.active);    // true (defaut applique)
print(typed_p.nickname);  // null (pas de defaut)

// Peut remplacer les champs optionnels
let p2: Person = { name: "Bob", age: 25, active: false };
print(p2.active);  // false (remplace)
```

**Syntaxe des champs optionnels :**
- `field?: default_value` - Optionnel avec defaut
- `field?: type` - Optionnel avec annotation de type, par defaut null
- Les champs optionnels sont ajoutes lors du typage canard si absents

### Verification de type

```hemlock
define Point {
    x: i32,
    y: i32,
}

let p = { x: 10, y: 20 };
let point: Point = p;  // La verification de type a lieu ici

print(typeof(point));  // "Point"
print(typeof(p));      // "object" (l'original est toujours anonyme)
```

**Quand la verification de type a lieu :**
- Au moment de l'assignation a une variable typee
- Valide que tous les champs requis sont presents
- Valide que les types de champs correspondent (avec conversions implicites)
- Definit le nom de type de l'objet

## Signatures de methode dans Define

Les blocs define peuvent specifier des signatures de methode, creant des contrats de type interface :

### Methodes requises

```hemlock
define Comparable {
    value: i32,
    fn compare(other: Self): i32;  // Signature de methode requise
}

// Les objets doivent fournir la methode requise
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};
```

### Methodes optionnelles

```hemlock
define Serializable {
    fn serialize(): string;       // Requise
    fn pretty?(): string;         // Methode optionnelle (peut etre absente)
}
```

### Le type `Self`

`Self` fait reference au type en cours de definition, permettant les definitions de type recursives :

```hemlock
define Cloneable {
    fn clone(): Self;  // Retourne le meme type que l'objet
}

define Comparable {
    fn compare(other: Self): i32;  // Prend le meme type en parametre
    fn equals(other: Self): bool;
}

let item: Cloneable = {
    value: 42,
    clone: fn() {
        return { value: self.value, clone: self.clone };
    }
};
```

### Melange de champs et methodes

```hemlock
define Entity {
    id: i32,
    name: string,
    fn validate(): bool;
    fn serialize(): string;
}

let user: Entity = {
    id: 1,
    name: "Alice",
    validate: fn() { return self.id > 0 && self.name != ""; },
    serialize: fn() { return '{"id":' + self.id + ',"name":"' + self.name + '"}'; }
};
```

## Types composes (types d'intersection)

Les types composes utilisent `&` pour exiger qu'un objet satisfasse plusieurs definitions de type :

### Types composes basiques

```hemlock
define HasName { name: string }
define HasAge { age: i32 }

// Type compose : l'objet doit satisfaire TOUS les types
let person: HasName & HasAge = { name: "Alice", age: 30 };
```

### Parametres de fonction avec types composes

```hemlock
fn greet(p: HasName & HasAge) {
    print(p.name + " a " + p.age + " ans");
}

greet({ name: "Bob", age: 25, city: "NYC" });  // Champs supplementaires OK
```

### Trois types ou plus

```hemlock
define HasEmail { email: string }

fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}
```

### Alias de type pour types composes

```hemlock
// Creer un alias nomme pour un type compose
type Person = HasName & HasAge;
type Employee = HasName & HasAge & HasEmail;

let emp: Employee = {
    name: "Charlie",
    age: 35,
    email: "charlie@example.com"
};
```

**Typage canard avec composes :** Les champs supplementaires sont toujours autorises - l'objet doit juste avoir au moins les champs requis par tous les types composants.

## Serialisation JSON

### Serialiser en JSON

Convertir des objets en chaines JSON :

```hemlock
// obj.serialize() - Convertir l'objet en chaine JSON
let obj = { x: 10, y: 20, name: "test" };
let json = obj.serialize();
print(json);  // {"x":10,"y":20,"name":"test"}

// Objets imbriques
let nested = { inner: { a: 1, b: 2 }, outer: 3 };
print(nested.serialize());  // {"inner":{"a":1,"b":2},"outer":3}
```

### Deserialiser depuis JSON

Analyser des chaines JSON vers des objets :

```hemlock
// json.deserialize() - Analyser chaine JSON vers objet
let json_str = '{"x":10,"y":20,"name":"test"}';
let obj = json_str.deserialize();

print(obj.name);   // "test"
print(obj.x);      // 10
```

### Detection de cycle

Les references circulaires sont detectees et causent des erreurs :

```hemlock
let obj = { x: 10 };
obj.me = obj;  // Creer une reference circulaire

obj.serialize();  // ERREUR : serialize() detected circular reference
```

### Types supportes

La serialisation JSON supporte :

- **Nombres** : i8-i32, u8-u32, f32, f64
- **Booleens** : true, false
- **Chaines** : Avec sequences d'echappement
- **Null** : valeur null
- **Objets** : Objets imbriques
- **Tableaux** : Tableaux imbriques

**Non supporte :**
- Fonctions (omises silencieusement)
- Pointeurs (erreur)
- Buffers (erreur)

### Gestion des erreurs

La serialisation et deserialisation peuvent lever des erreurs :

```hemlock
// JSON invalide leve une erreur
try {
    let bad = "pas du json valide".deserialize();
} catch (e) {
    print("Erreur d'analyse :", e);
}

// Les pointeurs ne peuvent pas etre serialises
let obj = { ptr: alloc(10) };
try {
    obj.serialize();
} catch (e) {
    print("Erreur de serialisation :", e);
}
```

### Exemple aller-retour

Exemple complet de serialisation et deserialisation :

```hemlock
define Config {
    host: string,
    port: i32,
    debug: bool
}

// Creer et serialiser
let config: Config = {
    host: "localhost",
    port: 8080,
    debug: true
};
let json = config.serialize();
print(json);  // {"host":"localhost","port":8080,"debug":true}

// Deserialiser
let restored = json.deserialize();
print(restored.host);  // "localhost"
print(restored.port);  // 8080
```

## Fonctions integrees

### `typeof(value)`

Retourne le nom du type sous forme de chaine :

```hemlock
let obj = { x: 10 };
print(typeof(obj));  // "object"

define Person { name: string, age: i32 }
let p: Person = { name: "Alice", age: 30 };
print(typeof(p));    // "Person"
```

**Valeurs de retour :**
- Objets anonymes : `"object"`
- Objets types : Nom de type personnalise (ex. `"Person"`)

## Details d'implementation

### Modele memoire

- **Alloue sur le tas** - Tous les objets sont alloues sur le tas
- **Copie superficielle** - L'assignation copie la reference, pas l'objet
- **Champs dynamiques** - Stockes comme tableaux dynamiques de paires nom/valeur
- **Compte par reference** - Les objets sont automatiquement liberes quand la portee se termine

### Semantique de reference

```hemlock
let obj1 = { x: 10 };
let obj2 = obj1;  // Copie superficielle (meme reference)

obj2.x = 20;
print(obj1.x);  // 20 (les deux font reference au meme objet)
```

### Stockage des methodes

Les methodes sont simplement des fonctions stockees dans des champs :

```hemlock
let obj = {
    value: 10,
    method: fn() { return self.value; }
};

// method est une fonction stockee dans obj.method
print(typeof(obj.method));  // "function"
```

## Modeles courants

### Modele : Fonction constructeur

```hemlock
fn createPerson(name: string, age: i32) {
    return {
        name: name,
        age: age,
        greet: fn() {
            return "Salut, je suis " + self.name;
        }
    };
}

let person = createPerson("Alice", 30);
print(person.greet());  // "Salut, je suis Alice"
```

### Modele : Constructeur d'objet (Builder)

```hemlock
fn PersonBuilder() {
    return {
        name: null,
        age: null,

        setName: fn(n) {
            self.name = n;
            return self;  // Permettre le chainage
        },

        setAge: fn(a) {
            self.age = a;
            return self;
        },

        build: fn() {
            return { name: self.name, age: self.age };
        }
    };
}

let person = PersonBuilder()
    .setName("Alice")
    .setAge(30)
    .build();
```

### Modele : Objet d'etat

```hemlock
let state = {
    status: "idle",
    data: null,
    error: null,

    setState: fn(new_status) {
        self.status = new_status;
    },

    setData: fn(new_data) {
        self.data = new_data;
        self.status = "success";
    },

    setError: fn(err) {
        self.error = err;
        self.status = "error";
    }
};
```

### Modele : Objet de configuration

```hemlock
let config = {
    defaults: {
        timeout: 30,
        retries: 3,
        debug: false
    },

    get: fn(key) {
        if (self.defaults[key] != null) {
            return self.defaults[key];
        }
        return null;
    },

    set: fn(key, value) {
        self.defaults[key] = value;
    }
};
```

## Bonnes pratiques

1. **Utilisez `define` pour la structure** - Documentez les formes d'objet attendues
2. **Preferez les fonctions usine** - Creez des objets avec des constructeurs
3. **Gardez les objets simples** - N'imbriquez pas trop profondement
4. **Documentez l'utilisation de `self`** - Rendez le comportement des methodes clair
5. **Validez a l'assignation** - Utilisez le typage canard pour detecter les erreurs tot
6. **Evitez les references circulaires** - Causera des erreurs de serialisation
7. **Utilisez les champs optionnels** - Fournissez des defauts raisonnables

## Pieges courants

### Piege : Reference vs. valeur

```hemlock
let obj1 = { x: 10 };
let obj2 = obj1;  // Copie superficielle

obj2.x = 20;
print(obj1.x);  // 20 (surprise ! les deux ont change)

// Pour eviter : Creer un nouvel objet
let obj3 = { x: obj1.x };  // Copie profonde (manuelle)
```

### Piege : `self` dans les appels non-methode

```hemlock
let obj = {
    value: 10,
    method: fn() { return self.value; }
};

// Fonctionne : Appele comme methode
print(obj.method());  // 10

// ERREUR : Appele comme fonction
let f = obj.method;
print(f());  // ERREUR : self is not defined
```

### Piege : Pointeurs bruts dans les objets

```hemlock
// Les objets sont auto-liberes, mais les pointeurs bruts a l'interieur NE le sont PAS
fn create_objects() {
    let obj = { data: alloc(1000) };  // ptr brut necessite free manuel
    // obj est auto-libere quand la portee se termine, mais obj.data fuit !
}

// Solution : Liberer les pointeurs bruts avant la sortie de portee
fn safe_create() {
    let obj = { data: alloc(1000) };
    // ... utiliser obj.data ...
    free(obj.data);  // Liberer le pointeur brut explicitement
}  // obj lui-meme est auto-libere
```

### Piege : Confusion de type

```hemlock
let obj = { x: 10 };

define Point { x: i32, y: i32 }

// ERREUR : Champ requis 'y' manquant
let p: Point = obj;
```

## Exemples

### Exemple : Mathematiques vectorielles

```hemlock
fn createVector(x, y) {
    return {
        x: x,
        y: y,

        add: fn(other) {
            return createVector(
                self.x + other.x,
                self.y + other.y
            );
        },

        length: fn() {
            return sqrt(self.x * self.x + self.y * self.y);
        },

        toString: fn() {
            return "(" + typeof(self.x) + ", " + typeof(self.y) + ")";
        }
    };
}

let v1 = createVector(3, 4);
let v2 = createVector(1, 2);
let v3 = v1.add(v2);

print(v3.toString());  // "(4, 6)"
```

### Exemple : Base de donnees simple

```hemlock
fn createDatabase() {
    let records = [];
    let next_id = 1;

    return {
        insert: fn(data) {
            let record = { id: next_id, data: data };
            records.push(record);
            next_id = next_id + 1;
            return record.id;
        },

        find: fn(id) {
            let i = 0;
            while (i < records.length) {
                if (records[i].id == id) {
                    return records[i];
                }
                i = i + 1;
            }
            return null;
        },

        count: fn() {
            return records.length;
        }
    };
}

let db = createDatabase();
let id = db.insert({ name: "Alice", age: 30 });
let record = db.find(id);
print(record.data.name);  // "Alice"
```

### Exemple : Emetteur d'evenements

```hemlock
fn createEventEmitter() {
    let listeners = {};

    return {
        on: fn(event, handler) {
            if (listeners[event] == null) {
                listeners[event] = [];
            }
            listeners[event].push(handler);
        },

        emit: fn(event, data) {
            if (listeners[event] != null) {
                let i = 0;
                while (i < listeners[event].length) {
                    listeners[event][i](data);
                    i = i + 1;
                }
            }
        }
    };
}

let emitter = createEventEmitter();

emitter.on("message", fn(data) {
    print("Recu : " + data);
});

emitter.emit("message", "Bonjour !");
```

## Limitations

Limitations actuelles :

- **Pas de copie profonde** - Doit copier manuellement les objets imbriques (spread est superficiel)
- **Pas de passage par valeur** - Les objets sont toujours passes par reference
- **Pas de proprietes calculees** - Pas de syntaxe `{[key]: value}`
- **`self` est en lecture seule** - Impossible de reassigner `self` dans les methodes
- **Pas de suppression de propriete** - Impossible de supprimer des champs une fois ajoutes

**Note :** Les objets sont comptes par reference et automatiquement liberes quand la portee se termine. Voir [Gestion de la memoire](memory.md#internal-reference-counting) pour les details.

## Sujets connexes

- [Fonctions](#language-guide-functions) - Les methodes sont des fonctions stockees dans les objets
- [Tableaux](#language-guide-arrays) - Les tableaux sont aussi similaires a des objets
- [Types](#language-guide-types) - Typage canard et definitions de type
- [Gestion des erreurs](#language-guide-error-handling) - Lever des objets d'erreur

## Voir aussi

- **Typage canard** : Voir section "Objects" de CLAUDE.md pour les details du typage canard
- **JSON** : Voir CLAUDE.md pour les details de serialisation JSON
- **Memoire** : Voir [Memoire](#language-guide-memory) pour l'allocation d'objet


--------------------------------------------------------------------------------
## Runes
--------------------------------------------------------------------------------

# Runes

Les runes representent des **points de code Unicode** (U+0000 a U+10FFFF) comme un type distinct pour la manipulation de caracteres en Hemlock. Contrairement aux octets (u8), les runes sont des caracteres Unicode complets qui peuvent representer n'importe quel caractere dans n'importe quelle langue ou emoji.

## Apercu

```hemlock
let ch = 'A';           // Litteral de rune
let emoji = 'rocket';   // Caractere multi-octet comme rune unique
print(ch);              // 'A'
print(emoji);           // U+1F680

let s = "Hello " + '!'; // Concatenation chaine + rune
let r = '>' + " msg";   // Concatenation rune + chaine
```

## Qu'est-ce qu'une rune ?

Une rune est une **valeur de 32 bits** representant un point de code Unicode :

- **Plage :** 0 a 0x10FFFF (1 114 111 points de code valides)
- **Pas un type numerique** - Utilisee pour la representation de caracteres
- **Distincte de u8/char** - Les runes sont du plein Unicode, u8 est juste des octets
- **Retournee par l'indexation de chaine** - `str[0]` retourne une rune, pas un octet

**Pourquoi les runes ?**
- Les chaines Hemlock sont encodees en UTF-8
- Un seul caractere Unicode peut faire de 1 a 4 octets en UTF-8
- Les runes permettent de travailler avec des caracteres complets, pas des octets partiels

## Litteraux de rune

### Syntaxe de base

Les guillemets simples denotent les litteraux de rune :

```hemlock
let a = 'A';            // Caractere ASCII
let b = '0';            // Caractere chiffre
let c = '!';            // Ponctuation
let d = ' ';            // Espace
```

### Caracteres UTF-8 multi-octets

Les runes peuvent representer n'importe quel caractere Unicode :

```hemlock
// Emoji
let rocket = 'rocket';  // Emoji (U+1F680)
let heart = 'coeur';    // Coeur (U+2764)
let smile = 'sourire';  // Visage souriant (U+1F600)

// Caracteres CJK
let chinese = 'zhong';  // Chinois (U+4E2D)
let japanese = 'a';     // Hiragana (U+3042)
let korean = 'han';     // Hangul (U+D55C)

// Symboles
let check = 'coche';    // Coche (U+2713)
let arrow = 'fleche';   // Fleche droite (U+2192)
```

### Sequences d'echappement

Sequences d'echappement communes pour les caracteres speciaux :

```hemlock
let newline = '\n';     // Nouvelle ligne (U+000A)
let tab = '\t';         // Tabulation (U+0009)
let backslash = '\\';   // Antislash (U+005C)
let quote = '\'';       // Guillemet simple (U+0027)
let dquote = '"';       // Guillemet double (U+0022)
let null_char = '\0';   // Caractere nul (U+0000)
let cr = '\r';          // Retour chariot (U+000D)
```

**Sequences d'echappement disponibles :**
- `\n` - Nouvelle ligne (saut de ligne)
- `\t` - Tabulation horizontale
- `\r` - Retour chariot
- `\0` - Caractere nul
- `\\` - Antislash
- `\'` - Guillemet simple
- `\"` - Guillemet double

### Echappements Unicode

Utilisez la syntaxe `\u{XXXXXX}` pour les points de code Unicode (jusqu'a 6 chiffres hexadecimaux) :

```hemlock
let rocket = '\u{1F680}';   // Emoji fusee via echappement Unicode
let heart = '\u{2764}';     // Coeur
let ascii = '\u{41}';       // 'A' via echappement
let max = '\u{10FFFF}';     // Point de code Unicode maximum

// Zeros initiaux optionnels
let a = '\u{41}';           // Identique a '\u{0041}'
let b = '\u{0041}';
```

**Regles :**
- Plage : `\u{0}` a `\u{10FFFF}`
- Chiffres hex : 1 a 6 chiffres
- Insensible a la casse : `\u{1F680}` ou `\u{1f680}`
- Les valeurs hors de la plage Unicode valide causent une erreur

## Concatenation chaine + rune

Les runes peuvent etre concatenees avec des chaines :

```hemlock
// Chaine + rune
let greeting = "Hello" + '!';       // "Hello!"
let decorated = "Text" + 'coche';   // "Textcoche"

// Rune + chaine
let prefix = '>' + " Message";      // "> Message"
let bullet = 'puce' + " Element";   // "puce Element"

// Concatenations multiples
let msg = "Hi " + 'salut' + " World " + 'terre';  // "Hi salut World terre"

// Le chainage de methodes fonctionne
let result = ('>' + " Important").to_upper();  // "> IMPORTANT"
```

**Fonctionnement :**
- Les runes sont automatiquement encodees en UTF-8
- Converties en chaines pendant la concatenation
- L'operateur de concatenation de chaine gere cela de maniere transparente

## Conversions de type

Les runes peuvent se convertir vers/depuis d'autres types.

### Entier <-> Rune

Convertir entre entiers et runes pour travailler avec les valeurs de point de code :

```hemlock
// Entier vers rune (valeur de point de code)
let code: rune = 65;            // 'A' (ASCII 65)
let emoji_code: rune = 128640;  // U+1F680 (fusee)

// Rune vers entier (obtenir la valeur du point de code)
let r = 'Z';
let value: i32 = r;             // 90 (valeur ASCII)

let rocket = 'fusee';
let code: i32 = rocket;         // 128640 (U+1F680)
```

**Verification de plage :**
- Entier vers rune : Doit etre dans [0, 0x10FFFF]
- Les valeurs hors plage causent une erreur d'execution
- Rune vers entier : Reussit toujours (retourne le point de code)

### Rune -> Chaine

Les runes peuvent etre explicitement converties en chaines :

```hemlock
// Conversion explicite
let ch: string = 'H';           // "H"
let emoji: string = 'fusee';    // "fusee"

// Automatique pendant la concatenation
let s = "" + 'A';               // "A"
let s2 = "x" + 'y' + "z";       // "xyz"
```

### u8 (octet) -> Rune

Toute valeur u8 (0-255) peut se convertir en rune :

```hemlock
// Plage ASCII (0-127)
let byte: u8 = 65;
let rune_val: rune = byte;      // 'A'

// ASCII etendu / Latin-1 (128-255)
let extended: u8 = 200;
let r: rune = extended;         // U+00C8 (E accent grave)

// Note : Les valeurs 0-127 sont ASCII, 128-255 sont Latin-1
```

### Conversions chainees

Les conversions de type peuvent etre chainees :

```hemlock
// i32 -> rune -> string
let code: i32 = 128512;         // Point de code visage souriant
let r: rune = code;             // sourire
let s: string = r;              // "sourire"

// Tout en une expression
let emoji: string = 128640;     // Implicite i32 -> rune -> string (fusee)
```

## Operations sur les runes

### Affichage

La facon dont les runes sont affichees depend du point de code :

```hemlock
let ascii = 'A';
print(ascii);                   // 'A' (entre guillemets, ASCII imprimable)

let emoji = 'fusee';
print(emoji);                   // U+1F680 (notation Unicode pour non-ASCII)

let tab = '\t';
print(tab);                     // U+0009 (non-imprimable en hex)

let space = ' ';
print(space);                   // ' ' (imprimable)
```

**Format d'affichage :**
- ASCII imprimable (32-126) : Caractere entre guillemets `'A'`
- Non-imprimable ou Unicode : Notation hex `U+XXXX`

### Verification de type

Utilisez `typeof()` pour verifier si une valeur est une rune :

```hemlock
let r = 'fusee';
print(typeof(r));               // "rune"

let s = "text";
let ch = s[0];
print(typeof(ch));              // "rune" (l'indexation retourne des runes)

let num = 65;
print(typeof(num));             // "i32"
```

### Comparaison

Les runes peuvent etre comparees pour l'egalite :

```hemlock
let a = 'A';
let b = 'B';
print(a == a);                  // true
print(a == b);                  // false

// Sensible a la casse
let upper = 'A';
let lower = 'a';
print(upper == lower);          // false

// Les runes peuvent etre comparees avec des entiers (valeurs de point de code)
print(a == 65);                 // true (conversion implicite)
print('fusee' == 128640);       // true
```

**Operateurs de comparaison :**
- `==` - Egal
- `!=` - Different
- `<`, `>`, `<=`, `>=` - Ordre des points de code

```hemlock
print('A' < 'B');               // true (65 < 66)
print('a' > 'Z');               // true (97 > 90)
```

## Travailler avec l'indexation de chaine

L'indexation de chaine retourne des runes, pas des octets :

```hemlock
let s = "Hellofusee";
let h = s[0];                   // 'H' (rune)
let rocket = s[5];              // 'fusee' (rune)

print(typeof(h));               // "rune"
print(typeof(rocket));          // "rune"

// Convertir en chaine si necessaire
let h_str: string = h;          // "H"
let rocket_str: string = rocket; // "fusee"
```

**Important :** L'indexation de chaine utilise les positions de point de code, pas les decalages d'octets :

```hemlock
let text = "Hifusee!";
// Positions de point de code : 0='H', 1='i', 2='fusee', 3='!'
// Positions d'octet :          0='H', 1='i', 2-5='fusee', 6='!'

let r = text[2];                // 'fusee' (point de code 2)
print(typeof(r));               // "rune"
```

## Exemples

### Exemple : Classification de caracteres

```hemlock
fn is_digit(r: rune): bool {
    return r >= '0' && r <= '9';
}

fn is_upper(r: rune): bool {
    return r >= 'A' && r <= 'Z';
}

fn is_lower(r: rune): bool {
    return r >= 'a' && r <= 'z';
}

print(is_digit('5'));           // true
print(is_upper('A'));           // true
print(is_lower('z'));           // true
```

### Exemple : Conversion de casse

```hemlock
fn to_upper_rune(r: rune): rune {
    if (r >= 'a' && r <= 'z') {
        // Convertir en majuscule (soustraire 32)
        let code: i32 = r;
        code = code - 32;
        return code;
    }
    return r;
}

fn to_lower_rune(r: rune): rune {
    if (r >= 'A' && r <= 'Z') {
        // Convertir en minuscule (ajouter 32)
        let code: i32 = r;
        code = code + 32;
        return code;
    }
    return r;
}

print(to_upper_rune('a'));      // 'A'
print(to_lower_rune('Z'));      // 'z'
```

### Exemple : Iteration sur les caracteres

```hemlock
fn print_chars(s: string) {
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        print("Position " + typeof(i) + ": " + typeof(ch));
        i = i + 1;
    }
}

print_chars("Hifusee");
// Position 0: 'H'
// Position 1: 'i'
// Position 2: U+1F680
```

### Exemple : Construire des chaines a partir de runes

```hemlock
fn repeat_char(ch: rune, count: i32): string {
    let result = "";
    let i = 0;
    while (i < count) {
        result = result + ch;
        i = i + 1;
    }
    return result;
}

let line = repeat_char('=', 40);  // "========================================"
let stars = repeat_char('etoile', 5);  // "etoileetoileetoileetoileetoile"
```

## Modeles courants

### Modele : Filtre de caracteres

```hemlock
fn filter_digits(s: string): string {
    let result = "";
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        if (ch >= '0' && ch <= '9') {
            result = result + ch;
        }
        i = i + 1;
    }
    return result;
}

let text = "abc123def456";
let digits = filter_digits(text);  // "123456"
```

### Modele : Comptage de caracteres

```hemlock
fn count_char(s: string, target: rune): i32 {
    let count = 0;
    let i = 0;
    while (i < s.length) {
        if (s[i] == target) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

let text = "hello world";
let l_count = count_char(text, 'l');  // 3
let o_count = count_char(text, 'o');  // 2
```

## Bonnes pratiques

1. **Utilisez les runes pour les operations sur les caracteres** - N'essayez pas de travailler avec des octets pour le texte
2. **L'indexation de chaine retourne des runes** - Rappelez-vous que `str[i]` vous donne une rune
3. **Comparaisons compatibles Unicode** - Les runes gerent n'importe quel caractere Unicode
4. **Convertissez quand necessaire** - Les runes se convertissent facilement en chaines et entiers
5. **Testez avec des emoji** - Testez toujours les operations sur les caracteres avec des caracteres multi-octets

## Pieges courants

### Piege : Confusion rune vs. octet

```hemlock
// NE PAS : Traiter les runes comme des octets
let r: rune = 'fusee';
let b: u8 = r;              // ERREUR : Le point de code 128640 ne tient pas dans u8

// FAIRE : Utiliser les conversions appropriees
let r: rune = 'fusee';
let code: i32 = r;          // OK : 128640
```

### Piege : Indexation d'octet de chaine

```hemlock
// NE PAS : Supposer l'indexation par octet
let s = "fusee";
let byte = s.byte_at(0);    // 240 (premier octet UTF-8, pas le caractere complet)

// FAIRE : Utiliser l'indexation par point de code
let s = "fusee";
let rune = s[0];            // 'fusee' (caractere complet)
let rune2 = s.char_at(0);   // 'fusee' (methode explicite)
```

## Sujets connexes

- [Chaines](#language-guide-strings) - Operations sur les chaines et gestion UTF-8
- [Types](#language-guide-types) - Systeme de types et conversions
- [Flux de controle](#language-guide-control-flow) - Utiliser les runes dans les comparaisons

## Voir aussi

- **Standard Unicode** : Les points de code Unicode sont definis par le Consortium Unicode
- **Encodage UTF-8** : Voir [Chaines](#language-guide-strings) pour les details UTF-8
- **Conversions de type** : Voir [Types](#language-guide-types) pour les regles de conversion


--------------------------------------------------------------------------------
## Syntaxe
--------------------------------------------------------------------------------

# Apercu de la syntaxe

Ce document couvre les regles de syntaxe fondamentales et la structure des programmes Hemlock.

## Regles de syntaxe de base

### Les points-virgules sont obligatoires

Contrairement a JavaScript ou Python, les points-virgules sont **toujours requis** a la fin des instructions :

```hemlock
let x = 42;
let y = 10;
print(x + y);
```

**Ceci provoquera une erreur :**
```hemlock
let x = 42  // ERREUR : Point-virgule manquant
let y = 10  // ERREUR : Point-virgule manquant
```

### Les accolades sont toujours requises

Tous les blocs de flux de controle doivent utiliser des accolades, meme pour les instructions simples :

```hemlock
// CORRECT
if (x > 0) {
    print("positif");
}

// ERREUR : Accolades manquantes
if (x > 0)
    print("positif");
```

### Commentaires

```hemlock
// Ceci est un commentaire sur une seule ligne

/*
   Ceci est un
   commentaire multi-lignes
*/

let x = 42;  // Commentaire en ligne
```

## Variables

### Declaration

Les variables sont declarees avec `let` :

```hemlock
let count = 0;
let name = "Alice";
let pi = 3.14159;
```

### Annotations de type (optionnelles)

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let flag: bool = true;
let text: string = "bonjour";
```

### Constantes

Utilisez `const` pour les valeurs immuables :

```hemlock
const MAX_SIZE: i32 = 1000;
const PI: f64 = 3.14159;
```

Tenter de reassigner une constante entrainera une erreur d'execution : "Cannot assign to const variable".

## Expressions

### Operateurs arithmetiques

```hemlock
let a = 10;
let b = 3;

print(a + b);   // 13 - Addition
print(a - b);   // 7  - Soustraction
print(a * b);   // 30 - Multiplication
print(a / b);   // 3  - Division (entiere)
```

### Operateurs de comparaison

```hemlock
print(a == b);  // false - Egal
print(a != b);  // true  - Different
print(a > b);   // true  - Superieur a
print(a < b);   // false - Inferieur a
print(a >= b);  // true  - Superieur ou egal
print(a <= b);  // false - Inferieur ou egal
```

### Operateurs logiques

```hemlock
let x = true;
let y = false;

print(x && y);  // false - ET
print(x || y);  // true  - OU
print(!x);      // false - NON
```

### Operateurs binaires (bitwise)

```hemlock
let a = 12;  // 1100
let b = 10;  // 1010

print(a & b);   // 8  - ET binaire
print(a | b);   // 14 - OU binaire
print(a ^ b);   // 6  - XOR binaire
print(a << 2);  // 48 - Decalage a gauche
print(a >> 1);  // 6  - Decalage a droite
print(~a);      // -13 - NON binaire
```

### Priorite des operateurs

De la plus haute a la plus basse :

1. `()` - Groupement
2. `!`, `~`, `-` (unaire) - Operateurs unaires
3. `*`, `/` - Multiplication, Division
4. `+`, `-` - Addition, Soustraction
5. `<<`, `>>` - Decalages binaires
6. `<`, `<=`, `>`, `>=` - Comparaisons
7. `==`, `!=` - Egalite
8. `&` - ET binaire
9. `^` - XOR binaire
10. `|` - OU binaire
11. `&&` - ET logique
12. `||` - OU logique

**Exemples :**
```hemlock
let x = 2 + 3 * 4;      // 14 (pas 20)
let y = (2 + 3) * 4;    // 20
let z = 5 << 2 + 1;     // 40 (5 << 3)
```

## Flux de controle

### Instructions If

```hemlock
if (condition) {
    // corps
}

if (condition) {
    // branche then
} else {
    // branche else
}

if (condition1) {
    // branche 1
} else if (condition2) {
    // branche 2
} else {
    // branche par defaut
}
```

### Boucles While

```hemlock
while (condition) {
    // corps
}
```

**Exemple :**
```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

### Boucles For

**Style C :**
```hemlock
for (initialiseur; condition; increment) {
    // corps
}
```

**Exemple :**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**For-in (tableaux) :**
```hemlock
for (let item in array) {
    // corps
}
```

**Exemple :**
```hemlock
let items = [10, 20, 30];
for (let x in items) {
    print(x);
}
```

### Instructions Switch

```hemlock
switch (expression) {
    case valeur1:
        // corps
        break;
    case valeur2:
        // corps
        break;
    default:
        // corps par defaut
        break;
}
```

**Exemple :**
```hemlock
let day = 3;
switch (day) {
    case 1:
        print("Lundi");
        break;
    case 2:
        print("Mardi");
        break;
    case 3:
        print("Mercredi");
        break;
    default:
        print("Autre");
        break;
}
```

### Break et Continue

```hemlock
// Break : sortir de la boucle
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        break;
    }
    print(i);
}

// Continue : passer a l'iteration suivante
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;
    }
    print(i);
}
```

## Fonctions

### Fonctions nommees

```hemlock
fn function_name(param1: type1, param2: type2): return_type {
    // corps
    return value;
}
```

**Exemple :**
```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Fonctions anonymes

```hemlock
let func = fn(params) {
    // corps
};
```

**Exemple :**
```hemlock
let multiply = fn(x, y) {
    return x * y;
};
```

### Annotations de type (optionnelles)

```hemlock
// Sans annotations (types inferes)
fn greet(name) {
    return "Bonjour, " + name;
}

// Avec annotations (verifiees a l'execution)
fn divide(a: i32, b: i32): f64 {
    return a / b;
}
```

## Objets

### Litteraux d'objet

```hemlock
let obj = {
    field1: value1,
    field2: value2,
};
```

**Exemple :**
```hemlock
let person = {
    name: "Alice",
    age: 30,
    active: true,
};
```

### Methodes

```hemlock
let obj = {
    method: fn() {
        self.field = value;
    },
};
```

**Exemple :**
```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    },
};
```

### Definitions de type

```hemlock
define TypeName {
    field1: type1,
    field2: type2,
    optional_field?: default_value,
}
```

**Exemple :**
```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,
}
```

## Tableaux

### Litteraux de tableau

```hemlock
let arr = [element1, element2, element3];
```

**Exemple :**
```hemlock
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, "deux", true, null];
let empty = [];
```

### Indexation de tableau

```hemlock
let arr = [10, 20, 30];
print(arr[0]);   // 10
arr[1] = 99;     // Modifier un element
```

## Gestion des erreurs

### Try/Catch

```hemlock
try {
    // code risque
} catch (e) {
    // gerer l'erreur
}
```

### Try/Finally

```hemlock
try {
    // code risque
} finally {
    // s'execute toujours
}
```

### Try/Catch/Finally

```hemlock
try {
    // code risque
} catch (e) {
    // gerer l'erreur
} finally {
    // nettoyage
}
```

### Throw

```hemlock
throw expression;
```

**Exemple :**
```hemlock
if (x < 0) {
    throw "x doit etre positif";
}
```

### Panic

```hemlock
panic(message);
```

**Exemple :**
```hemlock
panic("erreur irrecuperable");
```

## Modules (experimental)

### Instructions d'export

```hemlock
export fn function_name() { }
export const CONSTANT = value;
export let variable = value;
export { name1, name2 };
```

### Instructions d'import

```hemlock
import { name1, name2 } from "./module.hml";
import * as namespace from "./module.hml";
import { name as alias } from "./module.hml";
```

## Async (experimental)

### Fonctions asynchrones

```hemlock
async fn function_name(params): return_type {
    // corps
}
```

### Spawn/Join

```hemlock
let task = spawn(async_function, arg1, arg2);
let result = join(task);
```

### Canaux (Channels)

```hemlock
let ch = channel(capacity);
ch.send(value);
let value = ch.recv();
ch.close();
```

## FFI (Interface de fonction etrangere)

### Importer une bibliotheque partagee

```hemlock
import "library_name.so";
```

### Declarer une fonction externe

```hemlock
extern fn function_name(param: type): return_type;
```

**Exemple :**
```hemlock
import "libc.so.6";
extern fn strlen(s: string): i32;
```

## Litteraux

### Litteraux entiers

```hemlock
let decimal = 42;
let negative = -100;
let large = 5000000000;  // Auto i64

// Hexadecimal (prefixe 0x)
let hex = 0xDEADBEEF;
let hex2 = 0xFF;

// Binaire (prefixe 0b)
let bin = 0b1010;
let bin2 = 0b11110000;

// Octal (prefixe 0o)
let oct = 0o777;
let oct2 = 0O123;

// Separateurs numeriques pour la lisibilite
let million = 1_000_000;
let hex_sep = 0xFF_FF_FF;
let bin_sep = 0b1111_0000_1010_0101;
let oct_sep = 0o77_77;
```

### Litteraux flottants

```hemlock
let f = 3.14;
let e = 2.71828;
let sci = 1.5e-10;       // Notation scientifique
let sci2 = 2.5E+3;       // E majuscule fonctionne aussi
let no_lead = .5;        // Sans zero initial (0.5)
let sep = 3.14_159_265;  // Separateurs numeriques
```

### Litteraux de chaine

```hemlock
let s = "bonjour";
let escaped = "ligne1\nligne2\ttabulation";
let quote = "Elle a dit \"bonjour\"";

// Sequences d'echappement hexadecimales
let hex_esc = "\x48\x65\x6c\x6c\x6f";  // "Hello"

// Sequences d'echappement Unicode
let emoji = "\u{1F600}";               // grinning face
let heart = "\u{2764}";                // coeur
let mixed = "Bonjour \u{1F30D}!";      // Bonjour globe!
```

**Sequences d'echappement :**
- `\n` - nouvelle ligne
- `\t` - tabulation
- `\r` - retour chariot
- `\\` - barre oblique inverse
- `\"` - guillemet double
- `\'` - guillemet simple
- `\0` - caractere nul
- `\xNN` - echappement hexadecimal (2 chiffres)
- `\u{XXXX}` - echappement unicode (1-6 chiffres)

### Litteraux de rune

```hemlock
let ch = 'A';
let emoji = 'rocket';
let escaped = '\n';
let unicode = '\u{1F680}';
let hex_rune = '\x41';      // 'A'
```

### Litteraux booleens

```hemlock
let t = true;
let f = false;
```

### Litteral null

```hemlock
let nothing = null;
```

## Regles de portee

### Portee de bloc

Les variables sont limitees au bloc englobant le plus proche :

```hemlock
let x = 1;  // Portee externe

if (true) {
    let x = 2;  // Portee interne (masque l'externe)
    print(x);   // 2
}

print(x);  // 1
```

### Portee de fonction

Les fonctions creent leur propre portee :

```hemlock
let global = "global";

fn foo() {
    let local = "local";
    print(global);  // Peut lire la portee externe
}

foo();
// print(local);  // ERREUR : 'local' non defini ici
```

### Portee de fermeture (Closure)

Les fermetures capturent les variables de la portee englobante :

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;  // Capture 'count'
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
```

## Espaces et formatage

### Indentation

Hemlock n'impose pas d'indentation specifique, mais 4 espaces sont recommandes :

```hemlock
fn example() {
    if (true) {
        print("indente");
    }
}
```

### Sauts de ligne

Les instructions peuvent s'etendre sur plusieurs lignes :

```hemlock
let result =
    very_long_function_name(
        arg1,
        arg2,
        arg3
    );
```

## Instruction Loop

Le mot-cle `loop` fournit une syntaxe plus claire pour les boucles infinies :

```hemlock
loop {
    // ... faire le travail
    if (done) {
        break;
    }
}
```

Ceci est equivalent a `while (true)` mais rend l'intention plus claire.

## Mots-cles reserves

Les mots-cles suivants sont reserves dans Hemlock :

```
let, const, fn, if, else, while, for, in, loop, break, continue,
return, true, false, null, typeof, import, export, from,
try, catch, finally, throw, panic, async, await, spawn, join,
detach, channel, define, switch, case, default, extern, self,
type, defer, enum, ref, buffer, Self
```

## Prochaines etapes

- [Systeme de types](#language-guide-types) - Decouvrez le systeme de types de Hemlock
- [Flux de controle](#language-guide-control-flow) - Approfondissez les structures de controle
- [Fonctions](#language-guide-functions) - Maitrisez les fonctions et les fermetures
- [Gestion de la memoire](#language-guide-memory) - Comprenez les pointeurs et les tampons


--------------------------------------------------------------------------------
## Tableaux
--------------------------------------------------------------------------------

# Tableaux

Hemlock fournit des **tableaux dynamiques** avec des methodes completes pour la manipulation et le traitement des donnees. Les tableaux peuvent contenir des types mixtes et s'agrandissent automatiquement selon les besoins.

## Apercu

```hemlock
// Litteraux de tableau
let arr = [1, 2, 3, 4, 5];
print(arr[0]);         // 1
print(arr.length);     // 5

// Types mixtes autorises
let mixed = [1, "bonjour", true, null];

// Dimensionnement dynamique
arr.push(6);           // S'agrandit automatiquement
arr.push(7);
print(arr.length);     // 7
```

## Litteraux de tableau

### Syntaxe basique

```hemlock
let numbers = [1, 2, 3, 4, 5];
let strings = ["pomme", "banane", "cerise"];
let booleans = [true, false, true];
```

### Tableaux vides

```hemlock
let arr = [];  // Tableau vide

// Ajouter des elements plus tard
arr.push(1);
arr.push(2);
arr.push(3);
```

### Types mixtes

Les tableaux peuvent contenir differents types :

```hemlock
let mixed = [
    42,
    "bonjour",
    true,
    null,
    [1, 2, 3],
    { x: 10, y: 20 }
];

print(mixed[0]);  // 42
print(mixed[1]);  // "bonjour"
print(mixed[4]);  // [1, 2, 3] (tableau imbrique)
```

### Tableaux imbriques

```hemlock
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

print(matrix[0][0]);  // 1
print(matrix[1][2]);  // 6
print(matrix[2][1]);  // 8
```

### Tableaux types

Les tableaux peuvent avoir des annotations de type pour appliquer les types d'elements :

```hemlock
// Syntaxe de tableau type
let nums: array<i32> = [1, 2, 3, 4, 5];
let names: array<string> = ["Alice", "Bob", "Carol"];
let flags: array<bool> = [true, false, true];

// Verification de type a l'execution
let valid: array<i32> = [1, 2, 3];       // OK
let invalid: array<i32> = [1, "deux", 3]; // Erreur d'execution : type mismatch

// Tableaux types imbriques
let matrix: array<array<i32>> = [
    [1, 2, 3],
    [4, 5, 6]
];
```

**Comportement des annotations de type :**
- Les elements sont verifies quand ils sont ajoutes au tableau
- Les incompatibilites de type causent des erreurs a l'execution
- Sans annotation de type, les tableaux acceptent des types mixtes

## Indexation

### Lecture d'elements

Acces indexe a partir de zero :

```hemlock
let arr = [10, 20, 30, 40, 50];

print(arr[0]);  // 10 (premier element)
print(arr[4]);  // 50 (dernier element)

// Hors limites retourne null (pas d'erreur)
print(arr[10]);  // null
```

### Ecriture d'elements

```hemlock
let arr = [1, 2, 3];

arr[0] = 10;    // Modifier existant
arr[1] = 20;
print(arr);     // [10, 20, 3]

// Peut assigner au-dela de la longueur actuelle (agrandit le tableau)
arr[5] = 60;    // Cree [10, 20, 3, null, null, 60]
```

### Indices negatifs

**Non supportes** - Utilisez uniquement des indices positifs :

```hemlock
let arr = [1, 2, 3];
print(arr[-1]);  // ERREUR ou comportement indefini

// Utilisez length pour le dernier element
print(arr[arr.length - 1]);  // 3
```

## Proprietes

### Propriete `.length`

Retourne le nombre d'elements :

```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);  // 5

// Tableau vide
let empty = [];
print(empty.length);  // 0

// Apres modifications
arr.push(6);
print(arr.length);  // 6
```

## Methodes de tableau

Hemlock fournit 18 methodes de tableau pour une manipulation complete.

### Operations de pile

**`push(value)`** - Ajouter un element a la fin :
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]

print(arr.length);     // 5
```

**`pop()`** - Supprimer et retourner le dernier element :
```hemlock
let arr = [1, 2, 3, 4, 5];
let last = arr.pop();  // Retourne 5, arr est maintenant [1, 2, 3, 4]

print(last);           // 5
print(arr.length);     // 4
```

### Operations de file

**`shift()`** - Supprimer et retourner le premier element :
```hemlock
let arr = [1, 2, 3];
let first = arr.shift();   // Retourne 1, arr est maintenant [2, 3]

print(first);              // 1
print(arr);                // [2, 3]
```

**`unshift(value)`** - Ajouter un element au debut :
```hemlock
let arr = [2, 3];
arr.unshift(1);            // [1, 2, 3]
arr.unshift(0);            // [0, 1, 2, 3]
```

### Insertion et suppression

**`insert(index, value)`** - Inserer un element a l'index :
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // Inserer 3 a l'index 2 : [1, 2, 3, 4, 5]

arr.insert(0, 0);      // Inserer au debut : [0, 1, 2, 3, 4, 5]
```

**`remove(index)`** - Supprimer et retourner l'element a l'index :
```hemlock
let arr = [1, 2, 3, 4, 5];
let removed = arr.remove(2);  // Retourne 3, arr est maintenant [1, 2, 4, 5]

print(removed);               // 3
print(arr);                   // [1, 2, 4, 5]
```

### Operations de recherche

**`find(value)`** - Trouver la premiere occurrence :
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2 (index de la premiere occurrence)
let idx2 = arr.find(99);     // -1 (non trouve)

// Fonctionne avec n'importe quel type
let words = ["pomme", "banane", "cerise"];
let idx3 = words.find("banane");  // 1
```

**`contains(value)`** - Verifier si le tableau contient une valeur :
```hemlock
let arr = [10, 20, 30, 40];
let has = arr.contains(20);  // true
let has2 = arr.contains(99); // false
```

### Operations d'extraction

**`slice(start, end)`** - Extraire un sous-tableau (fin exclusive) :
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);   // [2, 3, 4] (indices 1, 2, 3)
let first = arr.slice(0, 2); // [1, 2]

// Original inchange
print(arr);                  // [1, 2, 3, 4, 5]
```

**`first()`** - Obtenir le premier element (sans le supprimer) :
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1 (sans le supprimer)
print(arr);                  // [1, 2, 3] (inchange)
```

**`last()`** - Obtenir le dernier element (sans le supprimer) :
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3 (sans le supprimer)
print(arr);                  // [1, 2, 3] (inchange)
```

### Operations de transformation

**`reverse()`** - Inverser le tableau sur place :
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]

print(arr);                  // [5, 4, 3, 2, 1] (modifie)
```

**`join(delimiter)`** - Joindre les elements en chaine :
```hemlock
let words = ["bonjour", "monde", "foo"];
let joined = words.join(" ");  // "bonjour monde foo"

let numbers = [1, 2, 3];
let csv = numbers.join(",");   // "1,2,3"

// Fonctionne avec les types mixtes
let mixed = [1, "bonjour", true, null];
print(mixed.join(" | "));  // "1 | bonjour | true | null"
```

**`concat(other)`** - Concatener avec un autre tableau :
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (nouveau tableau)

// Originaux inchanges
print(a);                    // [1, 2, 3]
print(b);                    // [4, 5, 6]
```

### Operations utilitaires

**`clear()`** - Supprimer tous les elements :
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();                 // []

print(arr.length);           // 0
print(arr);                  // []
```

## Chainage de methodes

Les methodes qui retournent des tableaux ou des valeurs permettent le chainage :

```hemlock
let result = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);  // [3, 4, 5]

let text = ["pomme", "banane", "cerise"]
    .slice(0, 2)
    .join(" et ");  // "pomme et banane"

let numbers = [5, 3, 8, 1, 9]
    .slice(1, 4)
    .concat([10, 11]);  // [3, 8, 1, 10, 11]
```

## Reference complete des methodes

| Methode | Parametres | Retourne | Modifie | Description |
|---------|------------|----------|---------|-------------|
| `push(value)` | any | void | Oui | Ajouter un element a la fin |
| `pop()` | - | any | Oui | Supprimer et retourner le dernier |
| `shift()` | - | any | Oui | Supprimer et retourner le premier |
| `unshift(value)` | any | void | Oui | Ajouter un element au debut |
| `insert(index, value)` | i32, any | void | Oui | Inserer a l'index |
| `remove(index)` | i32 | any | Oui | Supprimer et retourner a l'index |
| `find(value)` | any | i32 | Non | Trouver la premiere occurrence (-1 si non trouve) |
| `contains(value)` | any | bool | Non | Verifier si contient la valeur |
| `slice(start, end)` | i32, i32 | array | Non | Extraire un sous-tableau (nouveau tableau) |
| `join(delimiter)` | string | string | Non | Joindre en chaine |
| `concat(other)` | array | array | Non | Concatener (nouveau tableau) |
| `reverse()` | - | void | Oui | Inverser sur place |
| `first()` | - | any | Non | Obtenir le premier element |
| `last()` | - | any | Non | Obtenir le dernier element |
| `clear()` | - | void | Oui | Supprimer tous les elements |
| `map(callback)` | fn | array | Non | Transformer chaque element |
| `filter(predicate)` | fn | array | Non | Selectionner les elements correspondants |
| `reduce(callback, initial)` | fn, any | any | Non | Reduire a une seule valeur |

## Details d'implementation

### Modele memoire

- **Alloue sur le tas** - Capacite dynamique
- **Croissance automatique** - Double la capacite quand depassee
- **Pas de reduction automatique** - La capacite ne diminue pas
- **Pas de verification des limites sur l'indexation** - Utilisez les methodes pour la securite

### Gestion de la capacite

```hemlock
let arr = [];  // Capacite initiale : 0

arr.push(1);   // Croit vers capacite 1
arr.push(2);   // Croit vers capacite 2
arr.push(3);   // Croit vers capacite 4 (double)
arr.push(4);   // Toujours capacite 4
arr.push(5);   // Croit vers capacite 8 (double)
```

### Comparaison de valeurs

`find()` et `contains()` utilisent l'egalite de valeur :

```hemlock
// Primitives : comparaison par valeur
let arr = [1, 2, 3];
arr.contains(2);  // true

// Chaines : comparaison par valeur
let words = ["bonjour", "monde"];
words.contains("bonjour");  // true

// Objets : comparaison par reference
let obj1 = { x: 10 };
let obj2 = { x: 10 };
let arr2 = [obj1];
arr2.contains(obj1);  // true (meme reference)
arr2.contains(obj2);  // false (reference differente)
```

## Modeles courants

### Operations fonctionnelles (map/filter/reduce)

Les tableaux ont des methodes integrees `map`, `filter` et `reduce` :

```hemlock
// map - transformer chaque element
let numbers = [1, 2, 3, 4, 5];
let doubled = numbers.map(fn(x) { return x * 2; });
print(doubled);  // [2, 4, 6, 8, 10]

// filter - selectionner les elements correspondants
let evens = numbers.filter(fn(x) { return x % 2 == 0; });
print(evens);  // [2, 4]

// reduce - accumuler vers une seule valeur
let sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);
print(sum);  // 15

// Chainage des operations fonctionnelles
let result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]
    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]
    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220
```

### Modele : Tableau comme pile

```hemlock
let stack = [];

// Empiler sur la pile
stack.push(1);
stack.push(2);
stack.push(3);

// Depiler de la pile
let top = stack.pop();    // 3
let next = stack.pop();   // 2
```

### Modele : Tableau comme file

```hemlock
let queue = [];

// Enfiler (ajouter a la fin)
queue.push(1);
queue.push(2);
queue.push(3);

// Defiler (supprimer du debut)
let first = queue.shift();   // 1
let second = queue.shift();  // 2
```

## Bonnes pratiques

1. **Utilisez les methodes plutot que l'indexation directe** - Verification des limites et clarte
2. **Verifiez les limites** - L'indexation directe ne verifie pas les limites
3. **Preferez les operations immuables** - Utilisez `slice()` et `concat()` plutot que la mutation
4. **Initialisez avec la capacite** - Si vous connaissez la taille (pas actuellement supporte)
5. **Utilisez `contains()` pour l'appartenance** - Plus clair que les boucles manuelles
6. **Chainez les methodes** - Plus lisible que les appels imbriques

## Pieges courants

### Piege : Index direct hors limites

```hemlock
let arr = [1, 2, 3];

// Pas de verification des limites !
arr[10] = 99;  // Cree un tableau sparse avec des nulls
print(arr.length);  // 11 (pas 3 !)

// Mieux : Utilisez push() ou verifiez la longueur
if (arr.length <= 10) {
    arr.push(99);
}
```

### Piege : Mutation vs. nouveau tableau

```hemlock
let arr = [1, 2, 3];

// Modifie l'original
arr.reverse();
print(arr);  // [3, 2, 1]

// Retourne un nouveau tableau
let sub = arr.slice(0, 2);
print(arr);  // [3, 2, 1] (inchange)
print(sub);  // [3, 2]
```

### Piege : Egalite de reference

```hemlock
let obj = { x: 10 };
let arr = [obj];

// Meme reference : true
arr.contains(obj);  // true

// Reference differente : false
arr.contains({ x: 10 });  // false (objet different)
```

### Piege : Tableaux longue duree

```hemlock
// Les tableaux en portee locale sont auto-liberes, mais les tableaux globaux/longue duree necessitent attention
let global_cache = [];  // Niveau module, persiste jusqu'a la fin du programme

fn add_to_cache(item) {
    global_cache.push(item);  // Croit indefiniment
}

// Pour les donnees longue duree, considerez :
// - Vider le tableau periodiquement : global_cache.clear();
// - Liberer tot quand termine : free(global_cache);
```

## Exemples

### Exemple : Statistiques de tableau

```hemlock
fn mean(arr) {
    let sum = 0;
    let i = 0;
    while (i < arr.length) {
        sum = sum + arr[i];
        i = i + 1;
    }
    return sum / arr.length;
}

fn max(arr) {
    if (arr.length == 0) {
        return null;
    }

    let max_val = arr[0];
    let i = 1;
    while (i < arr.length) {
        if (arr[i] > max_val) {
            max_val = arr[i];
        }
        i = i + 1;
    }
    return max_val;
}

let numbers = [3, 7, 2, 9, 1];
print(mean(numbers));  // 4.4
print(max(numbers));   // 9
```

### Exemple : Deduplication de tableau

```hemlock
fn unique(arr) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        if (!result.contains(arr[i])) {
            result.push(arr[i]);
        }
        i = i + 1;
    }
    return result;
}

let numbers = [1, 2, 2, 3, 1, 4, 3, 5];
let uniq = unique(numbers);  // [1, 2, 3, 4, 5]
```

### Exemple : Decoupage de tableau

```hemlock
fn chunk(arr, size) {
    let result = [];
    let i = 0;

    while (i < arr.length) {
        let chunk = arr.slice(i, i + size);
        result.push(chunk);
        i = i + size;
    }

    return result;
}

let numbers = [1, 2, 3, 4, 5, 6, 7, 8];
let chunks = chunk(numbers, 3);
// [[1, 2, 3], [4, 5, 6], [7, 8]]
```

### Exemple : Aplatissement de tableau

```hemlock
fn flatten(arr) {
    let result = [];
    let i = 0;

    while (i < arr.length) {
        if (typeof(arr[i]) == "array") {
            // Tableau imbrique - l'aplatir
            let nested = flatten(arr[i]);
            let j = 0;
            while (j < nested.length) {
                result.push(nested[j]);
                j = j + 1;
            }
        } else {
            result.push(arr[i]);
        }
        i = i + 1;
    }

    return result;
}

let nested = [1, [2, 3], [4, [5, 6]], 7];
let flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]
```

### Exemple : Tri (tri a bulles)

```hemlock
fn sort(arr) {
    let n = arr.length;
    let i = 0;

    while (i < n) {
        let j = 0;
        while (j < n - i - 1) {
            if (arr[j] > arr[j + 1]) {
                // Echanger
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

let numbers = [5, 2, 8, 1, 9];
sort(numbers);  // Modifie sur place
print(numbers);  // [1, 2, 5, 8, 9]
```

## Limitations

Limitations actuelles :

- **Pas de verification des limites sur l'indexation** - L'acces direct n'est pas verifie
- **Egalite de reference pour les objets** - `find()` et `contains()` utilisent la comparaison de reference
- **Pas de destructuration de tableau** - Pas de syntaxe `let [a, b] = arr`
- **Pas d'operateur spread** - Pas de syntaxe `[...arr1, ...arr2]`

**Note :** Les tableaux sont comptes par reference et automatiquement liberes quand la portee se termine. Voir [Gestion de la memoire](memory.md#internal-reference-counting) pour les details.

## Sujets connexes

- [Chaines](#language-guide-strings) - Methodes de chaine similaires aux methodes de tableau
- [Objets](#language-guide-objects) - Les tableaux sont aussi similaires a des objets
- [Fonctions](#language-guide-functions) - Fonctions d'ordre superieur avec les tableaux
- [Flux de controle](#language-guide-control-flow) - Iterer sur les tableaux

## Voir aussi

- **Dimensionnement dynamique** : Les tableaux croissent automatiquement avec doublement de la capacite
- **Methodes** : 18 methodes completes pour la manipulation incluant map/filter/reduce
- **Memoire** : Voir [Memoire](#language-guide-memory) pour les details d'allocation de tableau


--------------------------------------------------------------------------------
## Types
--------------------------------------------------------------------------------

# Systeme de types

Hemlock dispose d'un **systeme de types dynamique** avec des annotations de type optionnelles et une verification de type a l'execution.

---

## Guide de selection des types : Quel type dois-je utiliser ?

**Nouveau avec les types ?** Commencez ici. Si vous etes familier avec les systemes de types, passez directement a [Philosophie](#philosophie).

### La reponse courte

**Laissez simplement Hemlock determiner le type :**

```hemlock
let count = 42;        // Hemlock sait que c'est un entier
let price = 19.99;     // Hemlock sait que c'est un decimal
let name = "Alice";    // Hemlock sait que c'est du texte
let active = true;     // Hemlock sait que c'est oui/non
```

Hemlock choisit automatiquement le bon type pour vos valeurs. Vous n'avez pas *besoin* de specifier les types.

### Quand ajouter des annotations de type

Ajoutez des types quand vous voulez :

1. **Etre specifique sur la taille** - `i8` vs `i64` est important pour la memoire ou FFI
2. **Documenter votre code** - Les types montrent ce qu'une fonction attend
3. **Detecter les erreurs tot** - Hemlock verifie les types a l'execution

```hemlock
// Sans types (fonctionne bien) :
fn add(a, b) {
    return a + b;
}

// Avec types (plus explicite) :
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Reference rapide : Choisir les types numeriques

| Ce que vous stockez | Type suggere | Exemple |
|---------------------|--------------|---------|
| Nombres entiers reguliers | `i32` (par defaut) | `let count = 42;` |
| Tres grands nombres | `i64` | `let population = 8000000000;` |
| Comptages jamais negatifs | `u32` | `let items: u32 = 100;` |
| Octets (0-255) | `u8` | `let pixel: u8 = 255;` |
| Decimaux/fractions | `f64` (par defaut) | `let price = 19.99;` |
| Decimaux critiques pour la performance | `f32` | `let x: f32 = 1.5;` |

### Reference rapide : Tous les types

| Categorie | Types | Quand utiliser |
|-----------|-------|----------------|
| **Nombres entiers** | `i8`, `i16`, `i32`, `i64` | Comptage, identifiants, ages, etc. |
| **Nombres positifs uniquement** | `u8`, `u16`, `u32`, `u64` | Octets, tailles, longueurs de tableau |
| **Decimaux** | `f32`, `f64` | Argent, mesures, mathematiques |
| **Oui/Non** | `bool` | Drapeaux, conditions |
| **Texte** | `string` | Noms, messages, tout texte |
| **Caractere unique** | `rune` | Lettres individuelles, emoji |
| **Listes** | `array` | Collections de valeurs |
| **Champs nommes** | `object` | Groupement de donnees liees |
| **Memoire brute** | `ptr`, `buffer` | Programmation bas niveau |
| **Rien** | `null` | Absence de valeur |

### Scenarios courants

**"J'ai juste besoin d'un nombre"**
```hemlock
let x = 42;  // Fait ! Hemlock choisit i32
```

**"J'ai besoin de decimaux"**
```hemlock
let price = 19.99;  // Fait ! Hemlock choisit f64
```

**"Je travaille avec des octets (fichiers, reseau)"**
```hemlock
let byte: u8 = 255;  // Plage 0-255
```

**"J'ai besoin de tres grands nombres"**
```hemlock
let big = 9000000000000;  // Hemlock choisit automatiquement i64 (> i32 max)
// Ou soyez explicite :
let big: i64 = 9000000000000;
```

**"Je stocke de l'argent"**
```hemlock
// Option 1 : Float (simple, mais a des limites de precision)
let price: f64 = 19.99;

// Option 2 : Stocker en centimes (plus precis)
let price_cents: i32 = 1999;  // 19.99 EUR en centimes entiers
```

**"Je passe des donnees au code C (FFI)"**
```hemlock
// Correspondre exactement aux types C
let c_int: i32 = 100;      // C 'int'
let c_long: i64 = 100;     // C 'long' (sur 64-bit)
let c_char: u8 = 65;       // C 'char'
let c_double: f64 = 3.14;  // C 'double'
```

### Que se passe-t-il quand les types se melangent ?

Quand vous combinez differents types, Hemlock promeut vers le type "plus grand" :

```hemlock
let a: i32 = 10;
let b: f64 = 2.5;
let result = a + b;  // result est f64 (12.5)
// L'entier est devenu un decimal automatiquement
```

**Regle generale :** Les flottants "gagnent" toujours - melanger un entier avec un flottant donne un flottant.

### Erreurs de type

Si vous essayez d'utiliser le mauvais type, Hemlock vous le dit a l'execution :

```hemlock
let age: i32 = "trente";  // ERREUR : type mismatch - expected i32, got string
```

Pour convertir les types, utilisez les fonctions constructeur de type :

```hemlock
let text = "42";
let number = i32(text);   // Analyser la chaine vers un entier : 42
let back = text + "";     // Deja une chaine
```

---

## Philosophie

- **Dynamique par defaut** - Chaque valeur a une etiquette de type a l'execution
- **Type par choix** - Les annotations de type optionnelles appliquent des verifications a l'execution
- **Conversions explicites** - Les conversions implicites suivent des regles de promotion claires
- **Honnete sur les types** - `typeof()` dit toujours la verite

## Types primitifs

### Types entiers

**Entiers signes :**
```hemlock
let tiny: i8 = 127;              // 8-bit  (-128 a 127)
let small: i16 = 32767;          // 16-bit (-32768 a 32767)
let normal: i32 = 2147483647;    // 32-bit (par defaut)
let large: i64 = 9223372036854775807;  // 64-bit
```

**Entiers non signes :**
```hemlock
let byte: u8 = 255;              // 8-bit  (0 a 255)
let word: u16 = 65535;           // 16-bit (0 a 65535)
let dword: u32 = 4294967295;     // 32-bit (0 a 4294967295)
let qword: u64 = 18446744073709551615;  // 64-bit
```

**Alias de type :**
```hemlock
let i: integer = 42;   // Alias pour i32
let b: byte = 255;     // Alias pour u8
```

### Types a virgule flottante

```hemlock
let f: f32 = 3.14159;        // Flottant 32-bit
let d: f64 = 2.718281828;    // Flottant 64-bit (par defaut)
let n: number = 1.618;       // Alias pour f64
```

### Type booleen

```hemlock
let flag: bool = true;
let active: bool = false;
```

### Type chaine

```hemlock
let text: string = "Bonjour, le monde !";
let empty: string = "";
```

Les chaines sont **mutables**, **encodees en UTF-8**, et **allouees sur le tas**.

Voir [Chaines](#language-guide-strings) pour les details complets.

### Type rune

```hemlock
let ch: rune = 'A';
let emoji: rune = 'rocket';
let newline: rune = '\n';
let unicode: rune = '\u{1F680}';
```

Les runes representent des **points de code Unicode** (U+0000 a U+10FFFF).

Voir [Runes](#language-guide-runes) pour les details complets.

### Type null

```hemlock
let nothing = null;
let uninitialized: string = null;
```

`null` est son propre type avec une seule valeur.

## Types composes

### Type tableau

```hemlock
let numbers: array = [1, 2, 3, 4, 5];
let mixed = [1, "deux", true, null];  // Types mixtes autorises
let empty: array = [];
```

Voir [Tableaux](#language-guide-arrays) pour les details complets.

### Type objet

```hemlock
let obj: object = { x: 10, y: 20 };
let person = { name: "Alice", age: 30 };
```

Voir [Objets](#language-guide-objects) pour les details complets.

### Types pointeur

**Pointeur brut :**
```hemlock
let p: ptr = alloc(64);
// Pas de verification des limites, gestion manuelle de la duree de vie
free(p);
```

**Tampon securise :**
```hemlock
let buf: buffer = buffer(64);
// Verification des limites, suit la longueur et la capacite
free(buf);
```

Voir [Gestion de la memoire](#language-guide-memory) pour les details complets.

## Types enum

Les enums definissent un ensemble de constantes nommees :

### Enums basiques

```hemlock
enum Color {
    RED,
    GREEN,
    BLUE
}

let c = Color.RED;
print(c);              // 0
print(typeof(c));      // "Color"

// Comparaison
if (c == Color.RED) {
    print("C'est rouge !");
}

// Switch sur enum
switch (c) {
    case Color.RED:
        print("Stop");
        break;
    case Color.GREEN:
        print("Allez");
        break;
    case Color.BLUE:
        print("Bleu ?");
        break;
}
```

### Enums avec valeurs

Les enums peuvent avoir des valeurs entieres explicites :

```hemlock
enum Status {
    OK = 0,
    ERROR = 1,
    PENDING = 2
}

print(Status.OK);      // 0
print(Status.ERROR);   // 1

enum HttpCode {
    OK = 200,
    NOT_FOUND = 404,
    SERVER_ERROR = 500
}

let code = HttpCode.NOT_FOUND;
print(code);           // 404
```

### Valeurs auto-incrementees

Sans valeurs explicites, les enums s'auto-incrementent a partir de 0 :

```hemlock
enum Priority {
    LOW,       // 0
    MEDIUM,    // 1
    HIGH,      // 2
    CRITICAL   // 3
}

// Peut melanger valeurs explicites et auto
enum Level {
    DEBUG = 10,
    INFO,      // 11
    WARN,      // 12
    ERROR = 50,
    FATAL      // 51
}
```

### Modeles d'utilisation des enums

```hemlock
// Comme parametres de fonction
fn set_priority(p: Priority) {
    if (p == Priority.CRITICAL) {
        print("Urgent !");
    }
}

set_priority(Priority.HIGH);

// Dans les objets
define Task {
    name: string,
    priority: Priority
}

let task: Task = {
    name: "Corriger le bug",
    priority: Priority.HIGH
};
```

## Types speciaux

### Type fichier

```hemlock
let f: file = open("data.txt", "r");
f.close();
```

Represente un descripteur de fichier ouvert.

### Type tache

```hemlock
async fn compute(): i32 { return 42; }
let task = spawn(compute);
let result: i32 = join(task);
```

Represente un descripteur de tache asynchrone.

### Type canal

```hemlock
let ch: channel = channel(10);
ch.send(42);
let value = ch.recv();
```

Represente un canal de communication entre taches.

### Type void

```hemlock
extern fn exit(code: i32): void;
```

Utilise pour les fonctions qui ne retournent pas de valeur (FFI seulement).

## Inference de type

### Inference de litteraux entiers

Hemlock infere les types entiers en fonction de la plage de valeurs :

```hemlock
let a = 42;              // i32 (tient dans 32-bit)
let b = 5000000000;      // i64 (> i32 max)
let c = 128;             // i32
let d: u8 = 128;         // u8 (annotation explicite)
```

**Regles :**
- Valeurs dans la plage i32 (-2147483648 a 2147483647) : infere comme `i32`
- Valeurs hors plage i32 mais dans i64 : infere comme `i64`
- Utilisez des annotations explicites pour les autres types (i8, i16, u8, u16, u32, u64)

### Inference de litteraux flottants

```hemlock
let x = 3.14;        // f64 (par defaut)
let y: f32 = 3.14;   // f32 (explicite)
```

### Notation scientifique

Hemlock supporte la notation scientifique pour les litteraux numeriques :

```hemlock
let a = 1e10;        // 10000000000.0 (f64)
let b = 1e-12;       // 0.000000000001 (f64)
let c = 3.14e2;      // 314.0 (f64)
let d = 2.5e-3;      // 0.0025 (f64)
let e = 1E10;        // Insensible a la casse
let f = 1e+5;        // Exposant positif explicite
```

**Note :** Tout litteral utilisant la notation scientifique est toujours infere comme `f64`.

### Autre inference de type

```hemlock
let s = "bonjour";   // string
let ch = 'A';        // rune
let flag = true;     // bool
let arr = [1, 2, 3]; // array
let obj = { x: 10 }; // object
let nothing = null;  // null
```

## Annotations de type

### Annotations de variable

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let name: string = "Alice";
```

### Annotations de parametre de fonction

```hemlock
fn greet(name: string, age: i32) {
    print("Bonjour, " + name + " !");
}
```

### Annotations de type de retour de fonction

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Annotations de type objet (typage canard)

```hemlock
define Person {
    name: string,
    age: i32,
}

let p: Person = { name: "Bob", age: 25 };
```

## Verification de type

### Verification de type a l'execution

Les annotations de type sont verifiees a **l'execution**, pas a la compilation :

```hemlock
let x: i32 = 42;     // OK
let y: i32 = 3.14;   // Erreur d'execution : type mismatch

fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 3);           // OK
add(5, "bonjour");   // Erreur d'execution : type mismatch
```

### Requetes de type

Utilisez `typeof()` pour verifier les types de valeur :

```hemlock
print(typeof(42));         // "i32"
print(typeof(3.14));       // "f64"
print(typeof("bonjour"));  // "string"
print(typeof(true));       // "bool"
print(typeof(null));       // "null"
print(typeof([1, 2, 3]));  // "array"
print(typeof({ x: 10 }));  // "object"
```

## Conversions de type

### Promotion de type implicite

Lors du melange de types dans les operations, Hemlock promeut vers le type "superieur" :

**Hierarchie de promotion (du plus bas au plus haut) :**
```
i8 -> i16 -> i32 -> u32 -> i64 -> u64 -> f32 -> f64
      ^      ^      ^
     u8     u16
```

**Le flottant gagne toujours :**
```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // result est f64 (13.5)
```

**La plus grande taille gagne :**
```hemlock
let a: i32 = 100;
let b: i64 = 200;
let sum = a + b;     // sum est i64 (300)
```

**Preservation de la precision :** Lors du melange d'entiers 64-bit avec f32, Hemlock promeut
vers f64 pour eviter la perte de precision (f32 n'a que 24-bit de mantisse, insuffisant pour i64/u64) :
```hemlock
let big: i64 = 9007199254740993;
let small: f32 = 1.0;
let result = big + small;  // result est f64, pas f32 !
```

**Exemples :**
```hemlock
u8 + i32  -> i32
i32 + i64 -> i64
u32 + u64 -> u64
i32 + f32 -> f32    // f32 suffisant pour i32
i64 + f32 -> f64    // f64 necessaire pour preserver la precision i64
i64 + f64 -> f64
i8 + f64  -> f64
```

### Conversion de type explicite

**Entier <-> Flottant :**
```hemlock
let i: i32 = 42;
let f: f64 = i;      // i32 -> f64 (42.0)

let x: f64 = 3.14;
let n: i32 = x;      // f64 -> i32 (3, tronque)
```

**Entier <-> Rune :**
```hemlock
let code: i32 = 65;
let ch: rune = code;  // i32 -> rune ('A')

let r: rune = 'Z';
let value: i32 = r;   // rune -> i32 (90)
```

**Rune -> Chaine :**
```hemlock
let ch: rune = 'rocket';
let s: string = ch;   // rune -> string ("rocket")
```

**u8 -> Rune :**
```hemlock
let b: u8 = 65;
let r: rune = b;      // u8 -> rune ('A')
```

### Fonctions constructeur de type

Les noms de type peuvent etre utilises comme fonctions pour convertir ou analyser des valeurs :

**Analyser des chaines vers des nombres :**
```hemlock
let n = i32("42");       // Analyser chaine vers i32 : 42
let f = f64("3.14159");  // Analyser chaine vers f64 : 3.14159
let b = bool("true");    // Analyser chaine vers bool : true

// Tous les types numeriques supportes
let a = i8("-128");      // Analyser vers i8
let c = u8("255");       // Analyser vers u8
let d = i16("1000");     // Analyser vers i16
let e = u16("50000");    // Analyser vers u16
let g = i64("9000000000000"); // Analyser vers i64
let h = u64("18000000000000"); // Analyser vers u64
let j = f32("1.5");      // Analyser vers f32
```

**Nombres hexadecimaux et negatifs :**
```hemlock
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42
let bin = i32("0b1010"); // 10 (binaire)
```

**Les alias de type fonctionnent aussi :**
```hemlock
let x = integer("100");  // Identique a i32("100")
let y = number("1.5");   // Identique a f64("1.5")
let z = byte("200");     // Identique a u8("200")
```

**Convertir entre types numeriques :**
```hemlock
let big = i64(42);           // i32 vers i64
let truncated = i32(3.99);   // f64 vers i32 (tronque a 3)
let promoted = f64(100);     // i32 vers f64 (100.0)
let narrowed = i8(127);      // i32 vers i8
```

**Les annotations de type effectuent la coercition numerique (mais PAS l'analyse de chaine) :**
```hemlock
let f: f64 = 100;        // i32 vers f64 via annotation (OK)
let s: string = 'A';     // Rune vers string via annotation (OK)
let code: i32 = 'A';     // Rune vers i32 via annotation (obtient le point de code, OK)

// L'analyse de chaine necessite des constructeurs de type explicites :
let n = i32("42");       // Utiliser le constructeur de type pour l'analyse de chaine
// let x: i32 = "42";    // ERREUR - les annotations de type n'analysent pas les chaines
```

**Gestion des erreurs :**
```hemlock
// Les chaines invalides levent des erreurs lors de l'utilisation de constructeurs de type
let bad = i32("bonjour");  // Erreur d'execution : cannot parse "bonjour" as i32
let overflow = u8("256");  // Erreur d'execution : 256 out of range for u8
```

**Analyse de booleen :**
```hemlock
let t = bool("true");    // true
let f = bool("false");   // false
let bad = bool("oui");   // Erreur d'execution : must be "true" or "false"
```

## Verification de plage

Les annotations de type appliquent des verifications de plage a l'assignation :

```hemlock
let x: u8 = 255;    // OK
let y: u8 = 256;    // ERREUR : out of range for u8

let a: i8 = 127;    // OK
let b: i8 = 128;    // ERREUR : out of range for i8

let c: i64 = 2147483647;   // OK
let d: u64 = 4294967295;   // OK
let e: u64 = -1;           // ERREUR : u64 cannot be negative
```

## Exemples de promotion de type

### Types entiers mixtes

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let sum = a + b;     // i32 (30)

let c: u8 = 100;
let d: u32 = 200;
let total = c + d;   // u32 (300)
```

### Entier + Flottant

```hemlock
let i: i32 = 5;
let f: f32 = 2.5;
let result = i * f;  // f32 (12.5)
```

### Expressions complexes

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let c: f64 = 3.0;

let result = a + b * c;  // f64 (70.0)
// Evaluation : b * c -> f64(60.0)
//              a + f64(60.0) -> f64(70.0)
```

## Typage canard (Objets)

Les objets utilisent le **typage structurel** (typage canard) :

```hemlock
define Person {
    name: string,
    age: i32,
}

// OK : A tous les champs requis
let p1: Person = { name: "Alice", age: 30 };

// OK : Champs supplementaires autorises
let p2: Person = { name: "Bob", age: 25, city: "NYC" };

// ERREUR : Champ 'age' manquant
let p3: Person = { name: "Carol" };

// ERREUR : Mauvais type pour 'age'
let p4: Person = { name: "Dave", age: "trente" };
```

**La verification de type se fait a l'assignation :**
- Valide que tous les champs requis sont presents
- Valide que les types de champ correspondent
- Les champs supplementaires sont autorises et preserves
- Definit le nom de type de l'objet pour `typeof()`

## Champs optionnels

```hemlock
define Config {
    host: string,
    port: i32,
    debug?: false,     // Optionnel avec valeur par defaut
    timeout?: i32,     // Optionnel, par defaut null
}

let cfg1: Config = { host: "localhost", port: 8080 };
print(cfg1.debug);    // false (par defaut)
print(cfg1.timeout);  // null

let cfg2: Config = { host: "0.0.0.0", port: 80, debug: true };
print(cfg2.debug);    // true (remplace)
```

## Alias de type

Hemlock supporte les alias de type personnalises avec le mot-cle `type` :

### Alias de type basiques

```hemlock
// Alias de type simple
type Integer = i32;
type Text = string;

// Utiliser l'alias
let x: Integer = 42;
let msg: Text = "bonjour";
```

### Alias de type fonction

```hemlock
// Alias de type fonction
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// Utiliser les alias de type fonction
let cb: Callback = fn(n) { print(n); };
let isEven: Predicate = fn(n) { return n % 2 == 0; };
```

### Alias de type compose

```hemlock
// Combiner plusieurs defines en un seul type
define HasName { name: string }
define HasAge { age: i32 }

type Person = HasName & HasAge;

let p: Person = { name: "Alice", age: 30 };
```

### Alias de type generique

```hemlock
// Alias de type generique
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };

// Utiliser les alias generiques
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
```

**Note :** Les alias de type sont transparents - `typeof()` retourne le nom du type sous-jacent, pas l'alias.

## Limitations du systeme de types

Limitations actuelles :

- **Pas de generiques sur les fonctions** - Les parametres de type de fonction pas encore supportes
- **Pas de types union** - Impossible d'exprimer "A ou B"
- **Pas de types nullables** - Tous les types peuvent etre null (utilisez le suffixe `?` pour la nullabilite explicite)

**Note :** Le compilateur (`hemlockc`) fournit une verification de type a la compilation. L'interpreteur effectue uniquement une verification de type a l'execution. Voir la [documentation du compilateur](#design-implementation) pour plus de details.

## Bonnes pratiques

### Quand utiliser les annotations de type

**UTILISEZ des annotations quand :**
- Le type precis compte (ex. `u8` pour les valeurs d'octet)
- Documenter les interfaces de fonction
- Appliquer des contraintes (ex. verifications de plage)

```hemlock
fn hash(data: buffer, length: u32): u64 {
    // Implementation
}
```

**N'UTILISEZ PAS d'annotations quand :**
- Le type est evident d'apres le litteral
- Details d'implementation internes
- Ceremonie inutile

```hemlock
// Inutile
let x: i32 = 42;

// Mieux
let x = 42;
```

### Modeles de securite de type

**Verifier avant utilisation :**
```hemlock
if (typeof(value) == "i32") {
    // Securise a utiliser comme i32
}
```

**Valider les arguments de fonction :**
```hemlock
fn divide(a, b) {
    if (typeof(a) != "i32" || typeof(b) != "i32") {
        throw "les arguments doivent etre des entiers";
    }
    if (b == 0) {
        throw "division par zero";
    }
    return a / b;
}
```

**Utiliser le typage canard pour la flexibilite :**
```hemlock
define Printable {
    toString: fn,
}

fn print_item(item: Printable) {
    print(item.toString());
}
```

## Prochaines etapes

- [Chaines](#language-guide-strings) - Type chaine UTF-8 et operations
- [Runes](#language-guide-runes) - Type point de code Unicode
- [Tableaux](#language-guide-arrays) - Type tableau dynamique
- [Objets](#language-guide-objects) - Litteraux d'objet et typage canard
- [Memoire](#language-guide-memory) - Types pointeur et buffer



################################################################################
# SUJETS AVANCÃ‰S
################################################################################

--------------------------------------------------------------------------------
## Arguments en Ligne de Commande
--------------------------------------------------------------------------------

# Arguments en ligne de commande dans Hemlock

Les programmes Hemlock peuvent acceder aux arguments en ligne de commande via un **tableau `args` integre** qui est automatiquement rempli au demarrage du programme.

## Table des matieres

- [Vue d'ensemble](#vue-densemble)
- [Le tableau args](#le-tableau-args)
- [Proprietes](#proprietes)
- [Patterns d'iteration](#patterns-diteration)
- [Cas d'utilisation courants](#cas-dutilisation-courants)
- [Patterns d'analyse d'arguments](#patterns-danalyse-darguments)
- [Bonnes pratiques](#bonnes-pratiques)
- [Exemples complets](#exemples-complets)

## Vue d'ensemble

Le tableau `args` fournit un acces aux arguments en ligne de commande passes a votre programme Hemlock :

- **Toujours disponible** - Variable globale integree dans tous les programmes Hemlock
- **Nom du script inclus** - `args[0]` contient toujours le chemin/nom du script
- **Tableau de chaines** - Tous les arguments sont des chaines
- **Indexe a zero** - Indexation standard de tableau (0, 1, 2, ...)

## Le tableau args

### Structure de base

```hemlock
// args[0] est toujours le nom du fichier script
// args[1] a args[n-1] sont les arguments reels
print(args[0]);        // "script.hml"
print(args.length);    // Nombre total d'arguments (incluant le nom du script)
```

### Exemple d'utilisation

**Commande :**
```bash
./hemlock script.hml hello world "test 123"
```

**Dans script.hml :**
```hemlock
print("Nom du script : " + args[0]);     // "script.hml"
print("Total args : " + typeof(args.length));  // "4"
print("Premier arg : " + args[1]);       // "hello"
print("Deuxieme arg : " + args[2]);      // "world"
print("Troisieme arg : " + args[3]);     // "test 123"
```

### Reference des index

| Index | Contient | Valeur d'exemple |
|-------|----------|------------------|
| `args[0]` | Chemin/nom du script | `"script.hml"` ou `"./script.hml"` |
| `args[1]` | Premier argument | `"hello"` |
| `args[2]` | Deuxieme argument | `"world"` |
| `args[3]` | Troisieme argument | `"test 123"` |
| ... | ... | ... |
| `args[n-1]` | Dernier argument | (variable) |

## Proprietes

### Toujours present

`args` est un tableau global disponible dans **tous** les programmes Hemlock :

```hemlock
// Pas besoin de declarer ou d'importer
print(args.length);  // Fonctionne immediatement
```

### Nom du script inclus

`args[0]` contient toujours le chemin/nom du script :

```hemlock
print("Execution de : " + args[0]);
```

**Valeurs possibles pour args[0] :**
- `"script.hml"` - Juste le nom de fichier
- `"./script.hml"` - Chemin relatif
- `"/home/user/script.hml"` - Chemin absolu
- Depend de la facon dont le script a ete invoque

### Type : Tableau de chaines

Tous les arguments sont stockes comme chaines :

```hemlock
// Arguments : ./hemlock script.hml 42 3.14 true

print(args[1]);  // "42" (chaine, pas nombre)
print(args[2]);  // "3.14" (chaine, pas nombre)
print(args[3]);  // "true" (chaine, pas booleen)

// Convertir si necessaire :
let num = 42;  // Parser manuellement si necessaire
```

### Longueur minimale

Toujours au moins 1 (le nom du script) :

```hemlock
print(args.length);  // Minimum : 1
```

**Meme sans arguments :**
```bash
./hemlock script.hml
```

```hemlock
// Dans script.hml :
print(args.length);  // 1 (juste le nom du script)
```

### Comportement du REPL

Dans le REPL, `args.length` est 0 (tableau vide) :

```hemlock
# Session REPL
> print(args.length);
0
```

## Patterns d'iteration

### Iteration de base

Ignorer `args[0]` (nom du script) et traiter les arguments reels :

```hemlock
let i = 1;
while (i < args.length) {
    print("Argument " + typeof(i) + " : " + args[i]);
    i = i + 1;
}
```

**Sortie pour : `./hemlock script.hml foo bar baz`**
```
Argument 1 : foo
Argument 2 : bar
Argument 3 : baz
```

### Iteration for-in (incluant le nom du script)

```hemlock
for (let arg in args) {
    print(arg);
}
```

**Sortie :**
```
script.hml
foo
bar
baz
```

### Verification du nombre d'arguments

```hemlock
if (args.length < 2) {
    print("Usage : " + args[0] + " <argument>");
    // exit ou return
} else {
    let arg = args[1];
    // traiter arg
}
```

### Traitement de tous les arguments sauf le nom du script

```hemlock
let actual_args = args.slice(1, args.length);

for (let arg in actual_args) {
    print("Traitement : " + arg);
}
```

## Cas d'utilisation courants

### 1. Traitement d'argument simple

Verifier un argument requis :

```hemlock
if (args.length < 2) {
    print("Usage : " + args[0] + " <filename>");
} else {
    let filename = args[1];
    print("Traitement du fichier : " + filename);
    // ... traiter le fichier
}
```

**Utilisation :**
```bash
./hemlock script.hml data.txt
# Sortie : Traitement du fichier : data.txt
```

### 2. Arguments multiples

```hemlock
if (args.length < 3) {
    print("Usage : " + args[0] + " <input> <output>");
} else {
    let input_file = args[1];
    let output_file = args[2];

    print("Entree : " + input_file);
    print("Sortie : " + output_file);

    // Traiter les fichiers...
}
```

**Utilisation :**
```bash
./hemlock convert.hml input.txt output.txt
```

### 3. Nombre variable d'arguments

Traiter tous les arguments fournis :

```hemlock
if (args.length < 2) {
    print("Usage : " + args[0] + " <file1> [file2] [file3] ...");
} else {
    print("Traitement de " + typeof(args.length - 1) + " fichiers :");

    let i = 1;
    while (i < args.length) {
        print("  " + args[i]);
        process_file(args[i]);
        i = i + 1;
    }
}
```

**Utilisation :**
```bash
./hemlock batch.hml file1.txt file2.txt file3.txt
```

### 4. Message d'aide

```hemlock
if (args.length < 2 || args[1] == "--help" || args[1] == "-h") {
    print("Usage : " + args[0] + " [OPTIONS] <file>");
    print("Options :");
    print("  -h, --help     Afficher ce message d'aide");
    print("  -v, --verbose  Activer la sortie verbeuse");
} else {
    // Traitement normal
}
```

### 5. Validation d'arguments

```hemlock
fn validate_file(filename: string): bool {
    // Verifier si le fichier existe (exemple)
    return filename != "";
}

if (args.length < 2) {
    print("Erreur : Pas de nom de fichier fourni");
} else if (!validate_file(args[1])) {
    print("Erreur : Fichier invalide : " + args[1]);
} else {
    print("Traitement : " + args[1]);
}
```

## Patterns d'analyse d'arguments

### Arguments nommes (drapeaux)

Pattern simple pour les arguments nommes :

```hemlock
let verbose = false;
let output_file = "";
let input_file = "";

let i = 1;
while (i < args.length) {
    if (args[i] == "--verbose" || args[i] == "-v") {
        verbose = true;
    } else if (args[i] == "--output" || args[i] == "-o") {
        i = i + 1;
        if (i < args.length) {
            output_file = args[i];
        }
    } else {
        input_file = args[i];
    }
    i = i + 1;
}

if (verbose) {
    print("Mode verbeux active");
}
print("Entree : " + input_file);
print("Sortie : " + output_file);
```

**Utilisation :**
```bash
./hemlock script.hml --verbose --output out.txt input.txt
./hemlock script.hml -v -o out.txt input.txt
```

### Drapeaux booleens

```hemlock
let debug = false;
let verbose = false;
let force = false;

let i = 1;
while (i < args.length) {
    if (args[i] == "--debug") {
        debug = true;
    } else if (args[i] == "--verbose") {
        verbose = true;
    } else if (args[i] == "--force") {
        force = true;
    }
    i = i + 1;
}
```

### Arguments avec valeurs

```hemlock
let config_file = "default.conf";
let port = 8080;

let i = 1;
while (i < args.length) {
    if (args[i] == "--config") {
        i = i + 1;
        if (i < args.length) {
            config_file = args[i];
        }
    } else if (args[i] == "--port") {
        i = i + 1;
        if (i < args.length) {
            port = 8080;  // Necessiterait de parser la chaine en int
        }
    }
    i = i + 1;
}
```

### Arguments positionnels et nommes melanges

```hemlock
let input_file = "";
let output_file = "";
let verbose = false;

let i = 1;
let positional = [];

while (i < args.length) {
    if (args[i] == "--verbose") {
        verbose = true;
    } else {
        // Traiter comme argument positionnel
        positional.push(args[i]);
    }
    i = i + 1;
}

// Assigner les arguments positionnels
if (positional.length > 0) {
    input_file = positional[0];
}
if (positional.length > 1) {
    output_file = positional[1];
}
```

### Fonction d'aide a l'analyse d'arguments

```hemlock
fn parse_args() {
    let options = {
        verbose: false,
        output: "",
        files: []
    };

    let i = 1;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--verbose" || arg == "-v") {
            options.verbose = true;
        } else if (arg == "--output" || arg == "-o") {
            i = i + 1;
            if (i < args.length) {
                options.output = args[i];
            }
        } else {
            // Argument positionnel
            options.files.push(arg);
        }

        i = i + 1;
    }

    return options;
}

let opts = parse_args();
print("Verbose : " + typeof(opts.verbose));
print("Output : " + opts.output);
print("Fichiers : " + typeof(opts.files.length));
```

## Bonnes pratiques

### 1. Toujours verifier le nombre d'arguments

```hemlock
// Bien
if (args.length < 2) {
    print("Usage : " + args[0] + " <file>");
} else {
    process_file(args[1]);
}

// Mauvais - peut planter si pas d'arguments
process_file(args[1]);  // Erreur si args.length == 1
```

### 2. Fournir des informations d'utilisation

```hemlock
fn show_usage() {
    print("Usage : " + args[0] + " [OPTIONS] <file>");
    print("Options :");
    print("  -h, --help     Afficher l'aide");
    print("  -v, --verbose  Sortie verbeuse");
}

if (args.length < 2) {
    show_usage();
}
```

### 3. Valider les arguments

```hemlock
fn validate_args() {
    if (args.length < 2) {
        print("Erreur : Argument requis manquant");
        return false;
    }

    if (args[1] == "") {
        print("Erreur : Argument vide");
        return false;
    }

    return true;
}

if (!validate_args()) {
    // exit ou afficher l'utilisation
}
```

### 4. Utiliser des noms de variables descriptifs

```hemlock
// Bien
let input_filename = args[1];
let output_filename = args[2];
let max_iterations = args[3];

// Mauvais
let a = args[1];
let b = args[2];
let c = args[3];
```

### 5. Gerer les arguments avec espaces entre guillemets

Le shell gere cela automatiquement :

```bash
./hemlock script.hml "fichier avec espaces.txt"
```

```hemlock
print(args[1]);  // "fichier avec espaces.txt"
```

### 6. Creer des objets d'arguments

```hemlock
fn get_args() {
    return {
        script: args[0],
        input: args[1],
        output: args[2]
    };
}

let arguments = get_args();
print("Entree : " + arguments.input);
```

## Exemples complets

### Exemple 1 : Processeur de fichiers

```hemlock
// Usage : ./hemlock process.hml <input> <output>

fn show_usage() {
    print("Usage : " + args[0] + " <input_file> <output_file>");
}

if (args.length < 3) {
    show_usage();
} else {
    let input = args[1];
    let output = args[2];

    print("Traitement de " + input + " -> " + output);

    // Traiter les fichiers
    let f_in = open(input, "r");
    let f_out = open(output, "w");

    try {
        let content = f_in.read();
        let processed = content.to_upper();  // Exemple de traitement
        f_out.write(processed);

        print("Termine !");
    } finally {
        f_in.close();
        f_out.close();
    }
}
```

### Exemple 2 : Processeur de fichiers par lots

```hemlock
// Usage : ./hemlock batch.hml <file1> <file2> <file3> ...

if (args.length < 2) {
    print("Usage : " + args[0] + " <file1> [file2] [file3] ...");
} else {
    print("Traitement de " + typeof(args.length - 1) + " fichiers :");

    let i = 1;
    while (i < args.length) {
        let filename = args[i];
        print("  Traitement : " + filename);

        try {
            let f = open(filename, "r");
            let content = f.read();
            f.close();

            // Traiter le contenu...
            print("    " + typeof(content.length) + " octets");
        } catch (e) {
            print("    Erreur : " + e);
        }

        i = i + 1;
    }

    print("Termine !");
}
```

### Exemple 3 : Analyseur d'arguments avance

```hemlock
// Usage : ./hemlock app.hml [OPTIONS] <files...>
// Options :
//   --verbose, -v     Activer la sortie verbeuse
//   --output, -o FILE Definir le fichier de sortie
//   --help, -h        Afficher l'aide

fn parse_arguments() {
    let config = {
        verbose: false,
        output: "output.txt",
        help: false,
        files: []
    };

    let i = 1;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--verbose" || arg == "-v") {
            config.verbose = true;
        } else if (arg == "--output" || arg == "-o") {
            i = i + 1;
            if (i < args.length) {
                config.output = args[i];
            } else {
                print("Erreur : --output necessite une valeur");
            }
        } else if (arg == "--help" || arg == "-h") {
            config.help = true;
        } else if (arg.starts_with("--")) {
            print("Erreur : Option inconnue : " + arg);
        } else {
            config.files.push(arg);
        }

        i = i + 1;
    }

    return config;
}

fn show_help() {
    print("Usage : " + args[0] + " [OPTIONS] <files...>");
    print("Options :");
    print("  --verbose, -v     Activer la sortie verbeuse");
    print("  --output, -o FILE Definir le fichier de sortie");
    print("  --help, -h        Afficher cette aide");
}

let config = parse_arguments();

if (config.help) {
    show_help();
} else if (config.files.length == 0) {
    print("Erreur : Aucun fichier d'entree specifie");
    show_help();
} else {
    if (config.verbose) {
        print("Mode verbeux active");
        print("Fichier de sortie : " + config.output);
        print("Fichiers d'entree : " + typeof(config.files.length));
    }

    // Traiter les fichiers
    for (let file in config.files) {
        if (config.verbose) {
            print("Traitement : " + file);
        }
        // ... traiter le fichier
    }
}
```

### Exemple 4 : Outil de configuration

```hemlock
// Usage : ./hemlock config.hml <action> [arguments]
// Actions :
//   get <key>
//   set <key> <value>
//   list

fn show_usage() {
    print("Usage : " + args[0] + " <action> [arguments]");
    print("Actions :");
    print("  get <key>         Obtenir une valeur de configuration");
    print("  set <key> <value> Definir une valeur de configuration");
    print("  list              Lister toute la configuration");
}

if (args.length < 2) {
    show_usage();
} else {
    let action = args[1];

    if (action == "get") {
        if (args.length < 3) {
            print("Erreur : 'get' necessite une cle");
        } else {
            let key = args[2];
            print("Obtention de : " + key);
            // ... obtenir depuis la config
        }
    } else if (action == "set") {
        if (args.length < 4) {
            print("Erreur : 'set' necessite cle et valeur");
        } else {
            let key = args[2];
            let value = args[3];
            print("Definition de " + key + " = " + value);
            // ... definir dans la config
        }
    } else if (action == "list") {
        print("Liste de toute la configuration :");
        // ... lister la config
    } else {
        print("Erreur : Action inconnue : " + action);
        show_usage();
    }
}
```

## Resume

Le support des arguments en ligne de commande de Hemlock fournit :

- âœ… Tableau `args` integre disponible globalement
- âœ… Acces simple base sur tableau aux arguments
- âœ… Nom du script dans `args[0]`
- âœ… Tous les arguments en tant que chaines
- âœ… Methodes de tableau disponibles (.length, .slice, etc.)

Rappelez-vous :
- Toujours verifier `args.length` avant d'acceder aux elements
- `args[0]` est le nom du script
- Les arguments reels commencent a `args[1]`
- Tous les arguments sont des chaines - convertir si necessaire
- Fournir des informations d'utilisation pour des outils conviviaux
- Valider les arguments avant le traitement

Patterns courants :
- Arguments positionnels simples
- Arguments nommes/drapeaux (--flag)
- Arguments avec valeurs (--option value)
- Messages d'aide (--help)
- Validation d'arguments


--------------------------------------------------------------------------------
## Asynchronisme et Concurrence
--------------------------------------------------------------------------------

# Async/Concurrence dans Hemlock

Hemlock fournit une **concurrence structuree** avec une syntaxe async/await, le lancement de taches et des canaux pour la communication. L'implementation utilise les threads POSIX (pthreads) pour un **VERITABLE parallelisme multi-thread**.

## Table des matieres

- [Vue d'ensemble](#vue-densemble)
- [Modele de threading](#modele-de-threading)
- [Fonctions asynchrones](#fonctions-asynchrones)
- [Lancement de taches](#lancement-de-taches)
- [Canaux](#canaux)
- [Propagation des exceptions](#propagation-des-exceptions)
- [Details d'implementation](#details-dimplementation)
- [Bonnes pratiques](#bonnes-pratiques)
- [Caracteristiques de performance](#caracteristiques-de-performance)
- [Limitations actuelles](#limitations-actuelles)

## Vue d'ensemble

**Ce que cela signifie :**
- âœ… **Vrais threads OS** - Chaque tache lancee s'execute sur un pthread separe (thread POSIX)
- âœ… **Vrai parallelisme** - Les taches s'executent simultanement sur plusieurs coeurs CPU
- âœ… **Ordonnance par le noyau** - L'ordonnanceur du systeme d'exploitation distribue les taches sur les coeurs disponibles
- âœ… **Canaux thread-safe** - Utilise des mutex pthread et des variables de condition pour la synchronisation

**Ce que ce n'est PAS :**
- âŒ **PAS des green threads** - Pas de multitache cooperatif en espace utilisateur
- âŒ **PAS des coroutines async/await** - Pas de boucle d'evenements mono-thread comme JavaScript/Python asyncio
- âŒ **PAS une concurrence emulee** - Pas de parallelisme simule

C'est le **meme modele de threading que C, C++ et Rust** lors de l'utilisation des threads OS. Vous obtenez une execution parallele reelle sur plusieurs coeurs.

## Modele de threading

### Threading 1:1

Hemlock utilise un **modele de threading 1:1**, ou :
- Chaque tache lancee cree un thread OS dedie via `pthread_create()`
- Le noyau du systeme d'exploitation ordonnance les threads sur les coeurs CPU disponibles
- Multitache preemptif - le systeme peut interrompre et basculer entre les threads
- **Pas de GIL** - Contrairement a Python, il n'y a pas de Global Interpreter Lock limitant le parallelisme

### Mecanismes de synchronisation

- **Mutex** - Les canaux utilisent `pthread_mutex_t` pour un acces thread-safe
- **Variables de condition** - Les send/recv bloquants utilisent `pthread_cond_t` pour une attente efficace
- **Operations sans verrou** - Les transitions d'etat des taches sont atomiques

## Fonctions asynchrones

Les fonctions peuvent etre declarees comme `async` pour indiquer qu'elles sont concues pour une execution concurrente :

```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}
```

### Points cles

- `async fn` declare une fonction asynchrone
- Les fonctions async peuvent etre lancees comme taches concurrentes en utilisant `spawn()`
- Les fonctions async peuvent aussi etre appelees directement (s'execute de maniere synchrone dans le thread courant)
- Une fois lancee, chaque tache s'execute sur **son propre thread OS** (pas une coroutine !)
- Le mot-cle `await` est reserve pour une utilisation future

### Exemple : Appel direct vs Spawn

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Appel direct - s'execute de maniere synchrone
let result1 = factorial(5);  // 120

// Tache lancee - s'execute sur un thread separe
let task = spawn(factorial, 5);
let result2 = join(task);  // 120
```

## Lancement de taches

Utilisez `spawn()` pour executer des fonctions async **en parallele sur des threads OS separes** :

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Lancer plusieurs taches - elles s'executent en PARALLELE sur differents coeurs CPU !
let t1 = spawn(factorial, 5);  // Thread 1
let t2 = spawn(factorial, 6);  // Thread 2
let t3 = spawn(factorial, 7);  // Thread 3

// Toutes les trois calculent simultanement en ce moment !

// Attendre les resultats
let f5 = join(t1);  // 120
let f6 = join(t2);  // 720
let f7 = join(t3);  // 5040
```

### Fonctions integrees

#### spawn(async_fn, arg1, arg2, ...)

Cree une nouvelle tache sur un nouveau pthread, retourne un handle de tache.

**Parametres :**
- `async_fn` - La fonction async a executer
- `arg1, arg2, ...` - Arguments a passer a la fonction

**Retourne :** Handle de tache (valeur opaque utilisee avec `join()` ou `detach()`)

**Exemple :**
```hemlock
async fn process(data: string, count: i32): i32 {
    // ... logique de traitement
    return count * 2;
}

let task = spawn(process, "test", 42);
```

#### join(task)

Attend la completion de la tache (bloque jusqu'a ce que le thread se termine), retourne le resultat.

**Parametres :**
- `task` - Handle de tache retourne par `spawn()`

**Retourne :** La valeur retournee par la fonction async

**Exemple :**
```hemlock
let task = spawn(compute, 1000);
let result = join(task);  // Bloque jusqu'a ce que compute() se termine
print(result);
```

**Important :** Chaque tache ne peut etre jointe qu'une seule fois. Les joins subsequents provoqueront une erreur.

#### detach(task)

Execution fire-and-forget (le thread s'execute independamment, join non autorise).

**Parametres :**
- `task` - Handle de tache retourne par `spawn()`

**Retourne :** `null`

**Exemple :**
```hemlock
async fn background_work() {
    // Tache de fond de longue duree
    // ...
}

let task = spawn(background_work);
detach(task);  // La tache s'execute independamment, impossible de joindre
```

**Important :** Les taches detachees ne peuvent pas etre jointes. Le pthread et la structure Task sont automatiquement nettoyes quand la tache se termine.

## Canaux

Les canaux fournissent une communication thread-safe entre les taches en utilisant un tampon borne avec une semantique bloquante.

### Creation de canaux

```hemlock
let ch = channel(10);  // Creer un canal avec une taille de tampon de 10
```

**Parametres :**
- `capacity` (i32) - Nombre maximum de valeurs que le canal peut contenir

**Retourne :** Objet canal

### Methodes de canal

#### send(value)

Envoyer une valeur au canal (bloque si plein).

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

let ch = channel(10);
let task = spawn(producer, ch, 5);
```

**Comportement :**
- Si le canal a de l'espace, la valeur est ajoutee immediatement
- Si le canal est plein, l'expediteur bloque jusqu'a ce que de l'espace devienne disponible
- Si le canal est ferme, lance une exception

#### recv()

Recevoir une valeur du canal (bloque si vide).

```hemlock
async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(10);
let task = spawn(consumer, ch, 5);
```

**Comportement :**
- Si le canal a des valeurs, retourne la prochaine valeur immediatement
- Si le canal est vide, le recepteur bloque jusqu'a ce qu'une valeur soit disponible
- Si le canal est ferme et vide, retourne `null`

#### close()

Fermer le canal (recv sur un canal ferme retourne null).

```hemlock
ch.close();
```

**Comportement :**
- Empeche les operations `send()` ulterieures (lancera une exception)
- Permet aux operations `recv()` en attente de se terminer
- Une fois vide, `recv()` retourne `null`

### Multiplexage avec select()

La fonction `select()` permet d'attendre sur plusieurs canaux simultanement, retournant quand n'importe quel canal a des donnees disponibles.

**Signature :**
```hemlock
select(channels: array, timeout_ms?: i32): object | null
```

**Parametres :**
- `channels` - Tableau de valeurs de canaux
- `timeout_ms` (optionnel) - Delai d'attente en millisecondes (-1 ou omettre pour attente infinie)

**Retourne :**
- `{ channel, value }` - Objet avec le canal qui avait des donnees et la valeur recue
- `null` - En cas de timeout (si un timeout etait specifie)

**Exemple :**
```hemlock
let ch1 = channel(1);
let ch2 = channel(1);

// Taches productrices
spawn(fn() {
    sleep(100);
    ch1.send("from channel 1");
});

spawn(fn() {
    sleep(50);
    ch2.send("from channel 2");
});

// Attendre le premier resultat (ch2 devrait etre plus rapide)
let result = select([ch1, ch2]);
print(result.value);  // "from channel 2"

// Attendre le deuxieme resultat
let result2 = select([ch1, ch2]);
print(result2.value);  // "from channel 1"
```

**Avec timeout :**
```hemlock
let ch = channel(1);

// Pas d'expediteur, va expirer
let result = select([ch], 100);  // timeout de 100ms
if (result == null) {
    print("Delai depasse !");
}
```

**Cas d'utilisation :**
- Attendre le plus rapide parmi plusieurs sources de donnees
- Implementer des timeouts sur les operations de canal
- Patterns de boucle d'evenements avec plusieurs sources d'evenements
- Fan-in : fusionner plusieurs canaux en un seul

**Pattern fan-in :**
```hemlock
fn fan_in(channels: array, output: channel) {
    while (true) {
        let result = select(channels);
        if (result == null) {
            break;  // Tous les canaux fermes
        }
        output.send(result.value);
    }
    output.close();
}
```

### Exemple complet producteur-consommateur

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

// Creer un canal avec une taille de tampon
let ch = channel(10);

// Lancer le producteur et le consommateur
let p = spawn(producer, ch, 5);
let c = spawn(consumer, ch, 5);

// Attendre la completion
join(p);
let total = join(c);  // 100 (0+10+20+30+40)
print(total);
```

### Multi-producteur, multi-consommateur

Les canaux peuvent etre partages en toute securite entre plusieurs producteurs et consommateurs :

```hemlock
async fn producer(id: i32, ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(id * 100 + i);
        i = i + 1;
    }
}

async fn consumer(id: i32, ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(20);

// Plusieurs producteurs
let p1 = spawn(producer, 1, ch, 5);
let p2 = spawn(producer, 2, ch, 5);

// Plusieurs consommateurs
let c1 = spawn(consumer, 1, ch, 5);
let c2 = spawn(consumer, 2, ch, 5);

// Attendre tous
join(p1);
join(p2);
let sum1 = join(c1);
let sum2 = join(c2);
print(sum1 + sum2);
```

## Propagation des exceptions

Les exceptions lancees dans les taches spawn sont propagees lors du join :

```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "La tache a echoue !";
    }
    return 42;
}

let t = spawn(risky_operation, 1);
try {
    let result = join(t);
} catch (e) {
    print("Intercepte : " + e);  // "Intercepte : La tache a echoue !"
}
```

### Patterns de gestion des exceptions

**Pattern 1 : Gerer dans la tache**
```hemlock
async fn safe_task() {
    try {
        // operation risquee
    } catch (e) {
        print("Erreur dans la tache : " + e);
        return null;
    }
}

let task = spawn(safe_task);
join(task);  // Pas d'exception propagee
```

**Pattern 2 : Propager a l'appelant**
```hemlock
async fn task_that_throws() {
    throw "erreur";
}

let task = spawn(task_that_throws);
try {
    join(task);
} catch (e) {
    print("Intercepte depuis la tache : " + e);
}
```

**Pattern 3 : Taches detachees avec exceptions**
```hemlock
async fn detached_task() {
    try {
        // travail
    } catch (e) {
        // Doit gerer en interne - ne peut pas propager
        print("Erreur : " + e);
    }
}

let task = spawn(detached_task);
detach(task);  // Impossible d'intercepter les exceptions des taches detachees
```

## Details d'implementation

### Architecture de threading

- **Threading 1:1** - Chaque tache lancee cree un thread OS dedie via `pthread_create()`
- **Ordonnance par le noyau** - Le noyau du systeme ordonnance les threads sur les coeurs CPU disponibles
- **Multitache preemptif** - Le systeme peut interrompre et basculer entre les threads
- **Pas de GIL** - Contrairement a Python, il n'y a pas de Global Interpreter Lock limitant le parallelisme

### Implementation des canaux

Les canaux utilisent un tampon circulaire avec synchronisation pthread :

```
Structure du canal :
- buffer[] - Tableau de taille fixe de Values
- capacity - Nombre maximum d'elements
- size - Nombre actuel d'elements
- head - Position de lecture
- tail - Position d'ecriture
- mutex - pthread_mutex_t pour un acces thread-safe
- not_empty - pthread_cond_t pour recv bloquant
- not_full - pthread_cond_t pour send bloquant
- closed - Drapeau booleen
- refcount - Compteur de references pour le nettoyage
```

**Comportement bloquant :**
- `send()` sur canal plein : attend sur la variable de condition `not_full`
- `recv()` sur canal vide : attend sur la variable de condition `not_empty`
- Les deux sont signales de maniere appropriee par l'operation opposee

### Memoire et nettoyage

- **Taches jointes :** Automatiquement nettoyees apres que `join()` retourne
- **Taches detachees :** Automatiquement nettoyees quand la tache se termine
- **Canaux :** Comptes par reference et liberes quand plus utilises

## Bonnes pratiques

### 1. Toujours fermer les canaux

```hemlock
async fn producer(ch) {
    // ... envoyer des valeurs
    ch.close();  // Important : signaler qu'il n'y a plus de valeurs
}
```

### 2. Utiliser la concurrence structuree

Lancer des taches et les joindre dans la meme portee :

```hemlock
fn process_data(data) {
    // Lancer des taches
    let t1 = spawn(worker, data);
    let t2 = spawn(worker, data);

    // Toujours joindre avant de retourner
    let r1 = join(t1);
    let r2 = join(t2);

    return r1 + r2;
}
```

### 3. Gerer les exceptions de maniere appropriee

```hemlock
async fn task() {
    try {
        // operation risquee
    } catch (e) {
        // Logger l'erreur
        throw e;  // Relancer si l'appelant doit savoir
    }
}
```

### 4. Utiliser une capacite de canal appropriee

- **Petite capacite (1-10) :** Pour la coordination/signalisation
- **Capacite moyenne (10-100) :** Pour le producteur-consommateur general
- **Grande capacite (100+) :** Pour les scenarios a haut debit

```hemlock
let signal_ch = channel(1);      // Coordination
let work_ch = channel(50);       // File de travail
let buffer_ch = channel(1000);   // Haut debit
```

### 5. Detacher uniquement si necessaire

Preferez `join()` a `detach()` pour une meilleure gestion des ressources :

```hemlock
// Bien : Joindre et obtenir le resultat
let task = spawn(work);
let result = join(task);

// Utiliser detach uniquement pour le vrai fire-and-forget
let bg_task = spawn(background_logging);
detach(bg_task);  // S'executera independamment
```

## Caracteristiques de performance

### Vrai parallelisme

- **N taches lancees peuvent utiliser N coeurs CPU simultanement**
- Acceleration prouvee - les tests de stress montrent 8-9x le temps CPU vs le temps reel (plusieurs coeurs travaillant)
- Mise a l'echelle lineaire avec le nombre de coeurs (jusqu'au nombre de threads)

### Surcharge des threads

- Chaque tache a ~8Ko de pile + surcharge pthread
- Cout de creation de thread : ~10-20us
- Cout de changement de contexte : ~1-5us

### Quand utiliser Async

**Bons cas d'utilisation :**
- Calculs intensifs en CPU qui peuvent etre parallelises
- Operations liees aux E/S (bien que les E/S soient toujours bloquantes)
- Traitement concurrent de donnees independantes
- Architectures en pipeline avec canaux

**Pas ideal pour :**
- Taches tres courtes (la surcharge des threads domine)
- Taches avec beaucoup de synchronisation (surcharge de contention)
- Systemes mono-coeur (pas de benefice de parallelisme)

### E/S bloquantes securisees

Les operations bloquantes dans une tache ne bloquent pas les autres :

```hemlock
async fn reader(filename: string) {
    let f = open(filename, "r");  // Bloque ce thread uniquement
    let content = f.read();       // Bloque ce thread uniquement
    f.close();
    return content;
}

// Les deux lisent de maniere concurrente (sur differents threads)
let t1 = spawn(reader, "file1.txt");
let t2 = spawn(reader, "file2.txt");

let c1 = join(t1);
let c2 = join(t2);
```

## Modele de securite des threads

Hemlock utilise un modele de concurrence par **passage de messages** ou les taches communiquent via des canaux plutot que par un etat mutable partage.

### Isolation des arguments

Quand vous lancez une tache, **les arguments sont copies en profondeur** pour prevenir les courses de donnees :

```hemlock
async fn modify_array(arr: array): array {
    arr.push(999);    // Modifie la COPIE, pas l'original
    arr[0] = -1;
    return arr;
}

let original = [1, 2, 3];
let task = spawn(modify_array, original);
let modified = join(task);

print(original.length);  // 3 - inchange !
print(modified.length);  // 4 - a le nouvel element
```

**Ce qui est copie en profondeur :**
- Tableaux (et tous les elements recursivement)
- Objets (et tous les champs recursivement)
- Chaines de caracteres
- Tampons (buffers)

**Ce qui est partage (reference retenue) :**
- Canaux (le mecanisme de communication - intentionnellement partage)
- Handles de taches (pour la coordination)
- Fonctions (le code est immuable)
- Handles de fichiers (le systeme gere l'acces concurrent)
- Handles de sockets (le systeme gere l'acces concurrent)

**Ce qui ne peut pas etre passe :**
- Pointeurs bruts (`ptr`) - utilisez `buffer` a la place

### Pourquoi le passage de messages ?

Cela suit la philosophie "explicite plutot qu'implicite" de Hemlock :

```hemlock
// MAUVAIS : Etat mutable partage (causerait des courses de donnees)
let counter = { value: 0 };
let t1 = spawn(fn() { counter.value = counter.value + 1; });  // Course !
let t2 = spawn(fn() { counter.value = counter.value + 1; });  // Course !

// BON : Passage de messages via canaux
async fn increment(ch) {
    let val = ch.recv();
    ch.send(val + 1);
}

let ch = channel(1);
ch.send(0);
let t1 = spawn(increment, ch);
join(t1);
let result = ch.recv();  // 1 - pas de condition de course
```

### Securite du comptage de references

Toutes les operations de comptage de references utilisent des **operations atomiques** pour prevenir les bugs use-after-free :
- `string_retain/release` - atomique
- `array_retain/release` - atomique
- `object_retain/release` - atomique
- `buffer_retain/release` - atomique
- `function_retain/release` - atomique
- `channel_retain/release` - atomique
- `task_retain/release` - atomique

Cela assure une gestion memoire securisee meme quand les valeurs sont partagees entre threads.

### Acces a l'environnement de closure

Les taches ont acces a l'environnement de closure pour :
- Les fonctions integrees (`print`, `len`, etc.)
- Les definitions de fonctions globales
- Les constantes et variables

L'environnement de closure est protege par un mutex par environnement, rendant
les lectures et ecritures concurrentes thread-safe :

```hemlock
let x = 10;

async fn read_closure(): i32 {
    return x;  // OK : lecture de variable de closure (thread-safe)
}

async fn modify_closure() {
    x = 20;  // OK : ecriture de variable de closure (synchronise avec mutex)
}
```

**Note :** Bien que l'acces concurrent soit synchronise, modifier un etat partage depuis
plusieurs taches peut toujours mener a des conditions de course logiques (ordonnancement
non deterministe). Pour un comportement previsible, utilisez des canaux pour la communication
entre taches ou des valeurs de retour des taches.

Si vous devez retourner des donnees d'une tache, utilisez la valeur de retour ou les canaux.

## Limitations actuelles

### 1. Pas d'ordonnanceur avec vol de travail

Utilise 1 thread par tache, ce qui peut etre inefficace pour beaucoup de taches courtes.

**Actuel :** 1000 taches = 1000 threads (surcharge importante)

**Prevu :** Pool de threads avec vol de travail pour une meilleure efficacite

### 3. Pas d'integration d'E/S asynchrones

Les operations fichier/reseau bloquent toujours le thread :

```hemlock
async fn read_file(path: string) {
    let f = open(path, "r");
    let content = f.read();  // Bloque le thread
    f.close();
    return content;
}
```

**Solution de contournement :** Utilisez plusieurs threads pour les operations d'E/S concurrentes

### 4. Capacite de canal fixe

La capacite du canal est definie a la creation et ne peut pas etre redimensionnee :

```hemlock
let ch = channel(10);
// Impossible de redimensionner dynamiquement a 20
```

### 5. La taille du canal est fixe

La taille du tampon du canal ne peut pas etre changee apres creation.

## Patterns courants

### Map parallele

```hemlock
async fn map_worker(ch_in, ch_out, fn_transform) {
    while (true) {
        let val = ch_in.recv();
        if (val == null) { break; }

        let result = fn_transform(val);
        ch_out.send(result);
    }
    ch_out.close();
}

fn parallel_map(data, fn_transform, workers: i32) {
    let ch_in = channel(100);
    let ch_out = channel(100);

    // Lancer les workers
    let tasks = [];
    let i = 0;
    while (i < workers) {
        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));
        i = i + 1;
    }

    // Envoyer les donnees
    let i = 0;
    while (i < data.length) {
        ch_in.send(data[i]);
        i = i + 1;
    }
    ch_in.close();

    // Collecter les resultats
    let results = [];
    let i = 0;
    while (i < data.length) {
        results.push(ch_out.recv());
        i = i + 1;
    }

    // Attendre les workers
    let i = 0;
    while (i < tasks.length) {
        join(tasks[i]);
        i = i + 1;
    }

    return results;
}
```

### Architecture en pipeline

```hemlock
async fn stage1(input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }
        output_ch.send(val * 2);
    }
    output_ch.close();
}

async fn stage2(input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }
        output_ch.send(val + 10);
    }
    output_ch.close();
}

// Creer le pipeline
let ch1 = channel(10);
let ch2 = channel(10);
let ch3 = channel(10);

let s1 = spawn(stage1, ch1, ch2);
let s2 = spawn(stage2, ch2, ch3);

// Alimenter l'entree
ch1.send(1);
ch1.send(2);
ch1.send(3);
ch1.close();

// Collecter la sortie
print(ch3.recv());  // 12 (1 * 2 + 10)
print(ch3.recv());  // 14 (2 * 2 + 10)
print(ch3.recv());  // 16 (3 * 2 + 10)

join(s1);
join(s2);
```

### Fan-Out, Fan-In

```hemlock
async fn worker(id: i32, input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }

        // Traiter la valeur
        let result = val * id;
        output_ch.send(result);
    }
}

let input = channel(10);
let output = channel(10);

// Fan-out : Plusieurs workers
let workers = 4;
let tasks = [];
let i = 0;
while (i < workers) {
    tasks.push(spawn(worker, i, input, output));
    i = i + 1;
}

// Envoyer le travail
let i = 0;
while (i < 10) {
    input.send(i);
    i = i + 1;
}
input.close();

// Fan-in : Collecter tous les resultats
let results = [];
let i = 0;
while (i < 10) {
    results.push(output.recv());
    i = i + 1;
}

// Attendre tous les workers
let i = 0;
while (i < tasks.length) {
    join(tasks[i]);
    i = i + 1;
}
```

## Resume

Le modele async/concurrence de Hemlock fournit :

- âœ… Vrai parallelisme multi-thread utilisant les threads OS
- âœ… Primitives de concurrence structuree simples
- âœ… Canaux thread-safe pour la communication
- âœ… Propagation des exceptions entre taches
- âœ… Performance prouvee sur les systemes multi-coeur
- âœ… **Isolation des arguments** - la copie profonde previent les courses de donnees
- âœ… **Comptage de references atomique** - gestion memoire securisee entre threads

Cela rend Hemlock adapte pour :
- Les calculs paralleles
- Les operations d'E/S concurrentes
- Les architectures en pipeline
- Les patterns producteur-consommateur

Tout en evitant la complexite de :
- La gestion manuelle des threads
- Les primitives de synchronisation bas niveau
- Les conceptions basees sur les verrous sujettes aux deadlocks
- Les bugs d'etat mutable partage


--------------------------------------------------------------------------------
## Empaquetage et Distribution
--------------------------------------------------------------------------------

# Empaquetage et distribution

Hemlock fournit des outils integres pour regrouper des projets multi-fichiers en fichiers distribuables uniques et creer des executables autonomes.

## Vue d'ensemble

| Commande | Sortie | Cas d'utilisation |
|----------|--------|-------------------|
| `--bundle` | `.hmlc` ou `.hmlb` | Distribuer du bytecode (necessite Hemlock pour executer) |
| `--package` | Executable | Binaire autonome (sans dependances) |
| `--compile` | `.hmlc` | Compiler un fichier unique (pas de resolution des imports) |

## Regroupement (Bundling)

Le bundler resout toutes les instructions `import` depuis un point d'entree et les aplatit en un seul fichier.

### Utilisation de base

```bash
# Regrouper app.hml et tous ses imports dans app.hmlc
hemlock --bundle app.hml

# Specifier le chemin de sortie
hemlock --bundle app.hml -o dist/app.hmlc

# Creer un bundle compresse (.hmlb) - taille de fichier plus petite
hemlock --bundle app.hml --compress -o app.hmlb

# Sortie verbeuse (montre les modules resolus)
hemlock --bundle app.hml --verbose
```

### Formats de sortie

**`.hmlc` (Non compresse)**
- Format AST serialise
- Rapide a charger et executer
- Format de sortie par defaut

**`.hmlb` (Compresse)**
- `.hmlc` compresse avec zlib
- Taille de fichier plus petite (reduction typique de 50-70%)
- Demarrage legerement plus lent du a la decompression

### Executer des fichiers regroupes

```bash
# Executer un bundle non compresse
hemlock app.hmlc

# Executer un bundle compresse
hemlock app.hmlb

# Passer des arguments
hemlock app.hmlc arg1 arg2
```

### Exemple : Projet multi-modules

```
myapp/
â”œâ”€â”€ main.hml
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ math.hml
â”‚   â””â”€â”€ utils.hml
â””â”€â”€ config.hml
```

```hemlock
// main.hml
import { add, multiply } from "./lib/math.hml";
import { log } from "./lib/utils.hml";
import { VERSION } from "./config.hml";

log(`App v${VERSION}`);
print(add(2, 3));
```

```bash
hemlock --bundle myapp/main.hml -o myapp.hmlc
hemlock myapp.hmlc  # S'execute avec toutes les dependances incluses
```

### Imports stdlib

Le bundler resout automatiquement les imports `@stdlib/` :

```hemlock
import { HashMap } from "@stdlib/collections";
import { now } from "@stdlib/time";
```

Quand ils sont regroupes, les modules stdlib sont inclus dans la sortie.

## Empaquetage (Packaging)

L'empaquetage cree un executable autonome en integrant le bytecode regroupe dans une copie de l'interpreteur Hemlock.

### Utilisation de base

```bash
# Creer un executable depuis app.hml
hemlock --package app.hml

# Specifier le nom de sortie
hemlock --package app.hml -o myapp

# Ignorer la compression (demarrage plus rapide, fichier plus gros)
hemlock --package app.hml --no-compress

# Sortie verbeuse
hemlock --package app.hml --verbose
```

### Executer des executables empaquetes

```bash
# L'executable empaquete s'execute directement
./myapp

# Les arguments sont passes au script
./myapp arg1 arg2
```

### Format de package

Les executables empaquetes utilisent le format HMLP :

```
[binaire hemlock][payload HMLB/HMLC][payload_size:u64][magic HMLP:u32]
```

Quand un executable empaquete s'execute :
1. Il verifie s'il y a un payload integre a la fin du fichier
2. S'il est trouve, il decompresse et execute le payload
3. S'il n'est pas trouve, il se comporte comme un interpreteur Hemlock normal

### Options de compression

| Drapeau | Format | Demarrage | Taille |
|---------|--------|-----------|--------|
| (defaut) | HMLB | Normal | Plus petit |
| `--no-compress` | HMLC | Plus rapide | Plus grand |

Pour les outils CLI ou le temps de demarrage compte, utilisez `--no-compress`.

## Inspecter les bundles

Utilisez `--info` pour inspecter les fichiers regroupes ou compiles :

```bash
hemlock --info app.hmlc
```

Sortie :
```
=== Info fichier : app.hmlc ===
Taille : 12847 octets
Format : HMLC (AST compile)
Version : 1
Drapeaux : 0x0001 [DEBUG]
Chaines : 42
Instructions : 156
```

```bash
hemlock --info app.hmlb
```

Sortie :
```
=== Info fichier : app.hmlb ===
Taille : 5234 octets
Format : HMLB (bundle compresse)
Version : 1
Non compresse : 12847 octets
Compresse : 5224 octets
Ratio : reduction de 59.3%
```

## Compilation native

Pour de vrais executables natifs (pas d'interpreteur), utilisez le compilateur Hemlock :

```bash
# Compiler en executable natif via C
hemlockc app.hml -o app

# Garder le code C genere
hemlockc app.hml -o app --keep-c

# Emettre uniquement le C (ne pas compiler)
hemlockc app.hml -c -o app.c

# Niveau d'optimisation
hemlockc app.hml -o app -O2
```

Le compilateur genere du code C et invoque GCC pour produire un binaire natif. Cela necessite :
- La bibliotheque runtime Hemlock (`libhemlock_runtime`)
- Un compilateur C (GCC par defaut)

### Options du compilateur

| Option | Description |
|--------|-------------|
| `-o <fichier>` | Nom de l'executable de sortie |
| `-c` | Emettre uniquement le code C |
| `--emit-c <fichier>` | Ecrire le C dans le fichier specifie |
| `-k, --keep-c` | Garder le C genere apres compilation |
| `-O<niveau>` | Niveau d'optimisation (0-3) |
| `--cc <chemin>` | Compilateur C a utiliser |
| `--runtime <chemin>` | Chemin vers la bibliotheque runtime |
| `-v, --verbose` | Sortie verbeuse |

## Comparaison

| Approche | Portabilite | Demarrage | Taille | Dependances |
|----------|-------------|-----------|--------|-------------|
| `.hml` | Source uniquement | Temps d'analyse | Plus petit | Hemlock |
| `.hmlc` | Hemlock uniquement | Rapide | Petit | Hemlock |
| `.hmlb` | Hemlock uniquement | Rapide | Plus petit | Hemlock |
| `--package` | Autonome | Rapide | Plus grand | Aucune |
| `hemlockc` | Natif | Plus rapide | Variable | Libs runtime |

## Bonnes pratiques

1. **Developpement** : Executez les fichiers `.hml` directement pour une iteration rapide
2. **Distribution (avec Hemlock)** : Regroupez avec `--compress` pour des fichiers plus petits
3. **Distribution (autonome)** : Empaquetez pour un deploiement sans dependances
4. **Performance critique** : Utilisez `hemlockc` pour la compilation native

## Depannage

### "Cannot find stdlib" (Impossible de trouver la stdlib)

Le bundler cherche la stdlib dans :
1. `./stdlib` (relatif a l'executable)
2. `../stdlib` (relatif a l'executable)
3. `/usr/local/lib/hemlock/stdlib`

Assurez-vous que Hemlock est correctement installe ou executez depuis le repertoire source.

### Dependances circulaires

```
Erreur : Dependance circulaire detectee lors du chargement de 'path/to/module.hml'
```

Refactorisez vos imports pour casser le cycle. Considerez l'utilisation d'un module partage pour les types communs.

### Grande taille de package

- Utilisez la compression par defaut (n'utilisez pas `--no-compress`)
- La taille empaquetee inclut l'interpreteur complet (~500Ko-1Mo de base)
- Pour une taille minimale, utilisez `hemlockc` pour la compilation native


--------------------------------------------------------------------------------
## ExÃ©cution de Commandes
--------------------------------------------------------------------------------

# Execution de commandes dans Hemlock

Hemlock fournit la **fonction integree `exec()`** pour executer des commandes shell et capturer leur sortie.

## Table des matieres

- [Vue d'ensemble](#vue-densemble)
- [La fonction exec()](#la-fonction-exec)
- [Objet resultat](#objet-resultat)
- [Utilisation de base](#utilisation-de-base)
- [Exemples avances](#exemples-avances)
- [Gestion des erreurs](#gestion-des-erreurs)
- [Details d'implementation](#details-dimplementation)
- [Considerations de securite](#considerations-de-securite)
- [Limitations](#limitations)
- [Cas d'utilisation](#cas-dutilisation)
- [Bonnes pratiques](#bonnes-pratiques)
- [Exemples complets](#exemples-complets)

## Vue d'ensemble

La fonction `exec()` permet aux programmes Hemlock de :
- Executer des commandes shell
- Capturer la sortie standard (stdout)
- Verifier les codes de sortie
- Utiliser les fonctionnalites du shell (pipes, redirections, etc.)
- S'integrer avec les utilitaires systeme

**Important :** Les commandes sont executees via `/bin/sh`, donnant un acces complet aux fonctionnalites du shell mais introduisant aussi des considerations de securite.

## La fonction exec()

### Signature

```hemlock
exec(command: string): object
```

**Parametres :**
- `command` (string) - Commande shell a executer

**Retourne :** Un objet avec deux champs :
- `output` (string) - La sortie stdout de la commande
- `exit_code` (i32) - Le code de sortie de la commande

### Exemple de base

```hemlock
let result = exec("echo hello");
print(result.output);      // "hello\n"
print(result.exit_code);   // 0
```

## Objet resultat

L'objet retourne par `exec()` a la structure suivante :

```hemlock
{
    output: string,      // Stdout de la commande (sortie capturee)
    exit_code: i32       // Statut de sortie du processus (0 = succes)
}
```

### Champ output

Contient tout le texte ecrit sur stdout par la commande.

**Proprietes :**
- Chaine vide si la commande ne produit pas de sortie
- Inclut les retours a la ligne et espaces tels quels
- La sortie multi-lignes est preservee
- Pas de limite de taille (allouee dynamiquement)

**Exemples :**
```hemlock
let r1 = exec("echo test");
print(r1.output);  // "test\n"

let r2 = exec("ls");
print(r2.output);  // Listing du repertoire avec retours a la ligne

let r3 = exec("true");
print(r3.output);  // "" (chaine vide)
```

### Champ exit_code

Le code de sortie de la commande.

**Valeurs :**
- `0` indique typiquement le succes
- `1-255` indiquent des erreurs (la convention varie selon la commande)
- `-1` si la commande n'a pas pu etre executee ou s'est terminee anormalement

**Exemples :**
```hemlock
let r1 = exec("true");
print(r1.exit_code);  // 0 (succes)

let r2 = exec("false");
print(r2.exit_code);  // 1 (echec)

let r3 = exec("ls /nonexistent");
print(r3.exit_code);  // 2 (fichier non trouve, varie selon la commande)
```

## Utilisation de base

### Commande simple

```hemlock
let r = exec("ls -la");
print(r.output);
print("Code de sortie : " + typeof(r.exit_code));
```

### Verification du statut de sortie

```hemlock
let r = exec("grep pattern file.txt");
if (r.exit_code == 0) {
    print("Trouve : " + r.output);
} else {
    print("Pattern non trouve");
}
```

### Commandes avec pipes

```hemlock
let r = exec("ps aux | grep hemlock");
print(r.output);
```

### Commandes multiples

```hemlock
let r = exec("cd /tmp && ls -la");
print(r.output);
```

### Substitution de commandes

```hemlock
let r = exec("echo $(date)");
print(r.output);  // Date actuelle
```

## Exemples avances

### Gestion des echecs

```hemlock
let r = exec("ls /nonexistent");
if (r.exit_code != 0) {
    print("Commande echouee avec le code : " + typeof(r.exit_code));
    print("Sortie d'erreur : " + r.output);  // Note : stderr non capture
}
```

### Traitement de sortie multi-lignes

```hemlock
let r = exec("cat file.txt");
let lines = r.output.split("\n");
let i = 0;
while (i < lines.length) {
    print("Ligne " + typeof(i) + " : " + lines[i]);
    i = i + 1;
}
```

### Chainage de commandes

**Avec && (ET) :**
```hemlock
let r1 = exec("mkdir -p /tmp/test && touch /tmp/test/file.txt");
if (r1.exit_code == 0) {
    print("Configuration terminee");
}
```

**Avec || (OU) :**
```hemlock
let r = exec("command1 || command2");
// Execute command2 seulement si command1 echoue
```

**Avec ; (sequence) :**
```hemlock
let r = exec("command1; command2");
// Execute les deux peu importe le succes/echec
```

### Utilisation des pipes

```hemlock
let r = exec("echo 'data' | base64");
print("Base64 : " + r.output);
```

**Pipelines complexes :**
```hemlock
let r = exec("cat /etc/passwd | grep root | cut -d: -f1");
print(r.output);
```

### Patterns de codes de sortie

Differents codes de sortie indiquent differentes conditions :

```hemlock
let r = exec("test -f myfile.txt");
if (r.exit_code == 0) {
    print("Le fichier existe");
} else if (r.exit_code == 1) {
    print("Le fichier n'existe pas");
} else {
    print("Commande test echouee : " + typeof(r.exit_code));
}
```

### Redirections de sortie

```hemlock
// Rediriger stdout vers un fichier (dans le shell)
let r1 = exec("echo 'test' > /tmp/output.txt");

// Rediriger stderr vers stdout (Note : stderr toujours non capture par Hemlock)
let r2 = exec("command 2>&1");
```

### Variables d'environnement

```hemlock
let r = exec("export VAR=value && echo $VAR");
print(r.output);  // "value\n"
```

### Changements de repertoire de travail

```hemlock
let r = exec("cd /tmp && pwd");
print(r.output);  // "/tmp\n"
```

## Gestion des erreurs

### Quand exec() lance des exceptions

La fonction `exec()` lance une exception si la commande ne peut pas etre executee :

```hemlock
try {
    let r = exec("nonexistent_command_xyz");
} catch (e) {
    print("Echec d'execution : " + e);
}
```

**Les exceptions sont lancees quand :**
- `popen()` echoue (ex. impossible de creer un pipe)
- Limites de ressources systeme depassees
- Echecs d'allocation memoire

### Quand exec() NE lance PAS d'exception

```hemlock
// La commande s'execute mais retourne un code de sortie non nul
let r1 = exec("false");
print(r1.exit_code);  // 1 (pas une exception)

// La commande ne produit pas de sortie
let r2 = exec("true");
print(r2.output);  // "" (pas une exception)

// Commande non trouvee par le shell
let r3 = exec("nonexistent_cmd");
print(r3.exit_code);  // 127 (pas une exception)
```

### Pattern d'execution securisee

```hemlock
fn safe_exec(command: string) {
    try {
        let r = exec(command);
        if (r.exit_code != 0) {
            print("Attention : Commande echouee avec le code " + typeof(r.exit_code));
            return "";
        }
        return r.output;
    } catch (e) {
        print("Erreur lors de l'execution de la commande : " + e);
        return "";
    }
}

let output = safe_exec("ls -la");
```

## Details d'implementation

### Comment ca fonctionne

**En interne :**
- Utilise `popen()` pour executer les commandes via `/bin/sh`
- Capture uniquement stdout (stderr n'est pas capture)
- Sortie mise en tampon dynamiquement (commence a 4Ko, augmente si necessaire)
- Statut de sortie extrait avec les macros `WIFEXITED()` et `WEXITSTATUS()`
- La chaine de sortie est correctement terminee par null

**Flux du processus :**
1. `popen(command, "r")` cree un pipe et fork le processus
2. Le processus enfant execute `/bin/sh -c "command"`
3. Le parent lit stdout via le pipe dans un tampon croissant
4. `pclose()` attend l'enfant et retourne le statut de sortie
5. Le statut de sortie est extrait et stocke dans l'objet resultat

### Considerations de performance

**Couts :**
- Cree un nouveau processus shell pour chaque appel (~1-5ms de surcharge)
- Sortie stockee entierement en memoire (pas de streaming)
- Pas de support du streaming (attend la completion de la commande)
- Adapte pour les commandes avec des tailles de sortie raisonnables

**Optimisations :**
- Le tampon commence a 4Ko et double quand il est plein (utilisation memoire efficace)
- Boucle de lecture unique minimise les appels systeme
- Pas de copie de chaine supplementaire

**Quand utiliser :**
- Commandes courtes (< 1 seconde)
- Taille de sortie moderee (< 10Mo)
- Operations batch avec des intervalles raisonnables

**Quand NE PAS utiliser :**
- Daemons ou services de longue duree
- Commandes produisant des gigaoctets de sortie
- Traitement de donnees en streaming temps reel
- Execution haute frequence (> 100 appels/seconde)

## Considerations de securite

### Risque d'injection shell

âš ï¸ **CRITIQUE :** Les commandes sont executees par le shell (`/bin/sh`), ce qui signifie que **l'injection shell est possible**.

**Code vulnerable :**
```hemlock
// DANGEREUX - NE FAITES PAS CELA
let filename = args[1];  // Entree utilisateur
let r = exec("cat " + filename);  // Injection shell !
```

**Attaque :**
```bash
./hemlock script.hml "; rm -rf /; echo pwned"
# Execute : cat ; rm -rf /; echo pwned
```

### Pratiques securisees

**1. Ne jamais utiliser d'entree utilisateur non assainie :**
```hemlock
// Mauvais
let user_input = args[1];
let r = exec("process " + user_input);  // DANGEREUX

// Bon - valider d'abord
fn is_safe_filename(name: string): bool {
    // Autoriser uniquement alphanumerique, tiret, underscore, point
    let i = 0;
    while (i < name.length) {
        let c = name[i];
        if (!(c >= 'a' && c <= 'z') &&
            !(c >= 'A' && c <= 'Z') &&
            !(c >= '0' && c <= '9') &&
            c != '-' && c != '_' && c != '.') {
            return false;
        }
        i = i + 1;
    }
    return true;
}

let filename = args[1];
if (is_safe_filename(filename)) {
    let r = exec("cat " + filename);
} else {
    print("Nom de fichier invalide");
}
```

**2. Utiliser des listes blanches, pas des listes noires :**
```hemlock
// Bon - liste blanche stricte
let allowed_commands = ["status", "start", "stop", "restart"];
let cmd = args[1];

let found = false;
for (let allowed in allowed_commands) {
    if (cmd == allowed) {
        found = true;
        break;
    }
}

if (found) {
    exec("service myapp " + cmd);
} else {
    print("Commande invalide");
}
```

**3. Echapper les caracteres speciaux :**
```hemlock
fn shell_escape(s: string): string {
    // Echappement simple - entourer de guillemets simples et echapper les guillemets simples
    let escaped = s.replace_all("'", "'\\''");
    return "'" + escaped + "'";
}

let user_file = args[1];
let safe = shell_escape(user_file);
let r = exec("cat " + safe);
```

**4. Eviter exec() pour les operations sur fichiers :**
```hemlock
// Mauvais - utiliser exec pour les operations sur fichiers
let r = exec("cat file.txt");

// Bon - utiliser l'API de fichiers Hemlock
let f = open("file.txt", "r");
let content = f.read();
f.close();
```

### Considerations de permissions

Les commandes s'executent avec les memes permissions que le processus Hemlock :

```hemlock
// Si Hemlock s'execute en root, les commandes exec() s'executent aussi en root !
let r = exec("rm -rf /important");  // DANGEREUX si execution en root
```

**Bonne pratique :** Executez Hemlock avec le minimum de privileges necessaires.

## Limitations

### 1. Pas de capture de stderr

Seul stdout est capture, stderr va au terminal :

```hemlock
let r = exec("ls /nonexistent");
// r.output est vide
// Le message d'erreur apparait sur le terminal, non capture
```

**Solution de contournement - rediriger stderr vers stdout :**
```hemlock
let r = exec("ls /nonexistent 2>&1");
// Maintenant les messages d'erreur sont dans r.output
```

### 2. Pas de streaming

Doit attendre la completion de la commande :

```hemlock
let r = exec("long_running_command");
// Bloque jusqu'a ce que la commande finisse
// Impossible de traiter la sortie incrementalement
```

### 3. Pas de timeout

Les commandes peuvent s'executer indefiniment :

```hemlock
let r = exec("sleep 1000");
// Bloque pendant 1000 secondes
// Pas de moyen de timeout ou annuler
```

**Solution de contournement - utiliser la commande timeout :**
```hemlock
let r = exec("timeout 5 long_command");
// Expirera apres 5 secondes
```

### 4. Pas de gestion des signaux

Impossible d'envoyer des signaux aux commandes en cours d'execution :

```hemlock
let r = exec("long_command");
// Impossible d'envoyer SIGINT, SIGTERM, etc. a la commande
```

### 5. Pas de controle de processus

Impossible d'interagir avec la commande apres le demarrage :

```hemlock
let r = exec("interactive_program");
// Impossible d'envoyer de l'entree au programme
// Impossible de controler l'execution
```

## Cas d'utilisation

### Bons cas d'utilisation

**1. Execution d'utilitaires systeme :**
```hemlock
let r = exec("ls -la");
let r = exec("grep pattern file.txt");
let r = exec("find /path -name '*.txt'");
```

**2. Traitement rapide de donnees avec les outils Unix :**
```hemlock
let r = exec("cat data.txt | sort | uniq | wc -l");
print("Lignes uniques : " + r.output);
```

**3. Verification de l'etat systeme :**
```hemlock
let r = exec("df -h");
print("Utilisation disque :\n" + r.output);
```

**4. Verification d'existence de fichier :**
```hemlock
let r = exec("test -f myfile.txt");
if (r.exit_code == 0) {
    print("Le fichier existe");
}
```

**5. Generation de rapports :**
```hemlock
let r = exec("ps aux | grep myapp | wc -l");
let count = r.output.trim();
print("Instances en cours : " + count);
```

**6. Scripts d'automatisation :**
```hemlock
exec("git add .");
exec("git commit -m 'Commit automatique'");
let r = exec("git push");
if (r.exit_code != 0) {
    print("Push echoue");
}
```

### Non recommande pour

**1. Services de longue duree :**
```hemlock
// Mauvais
let r = exec("nginx");  // Bloque indefiniment
```

**2. Commandes interactives :**
```hemlock
// Mauvais - impossible de fournir de l'entree
let r = exec("ssh user@host");
```

**3. Commandes produisant d'enormes sorties :**
```hemlock
// Mauvais - charge toute la sortie en memoire
let r = exec("cat 10GB_file.log");
```

**4. Streaming temps reel :**
```hemlock
// Mauvais - impossible de traiter la sortie incrementalement
let r = exec("tail -f /var/log/app.log");
```

**5. Gestion d'erreurs critique :**
```hemlock
// Mauvais - stderr non capture
let r = exec("critical_operation");
// Impossible de voir les messages d'erreur detailles
```

## Bonnes pratiques

### 1. Toujours verifier les codes de sortie

```hemlock
let r = exec("important_command");
if (r.exit_code != 0) {
    print("Commande echouee !");
    // Gerer l'erreur
}
```

### 2. Nettoyer la sortie si necessaire

```hemlock
let r = exec("echo test");
let clean = r.output.trim();  // Supprimer le retour a la ligne final
print(clean);  // "test" (sans retour a la ligne)
```

### 3. Valider avant d'executer

```hemlock
fn is_valid_command(cmd: string): bool {
    // Valider que la commande est sure
    return true;  // Votre logique de validation
}

if (is_valid_command(user_cmd)) {
    exec(user_cmd);
}
```

### 4. Utiliser try/catch pour les operations critiques

```hemlock
try {
    let r = exec("critical_command");
    if (r.exit_code != 0) {
        throw "Commande echouee";
    }
} catch (e) {
    print("Erreur : " + e);
    // Nettoyage ou recuperation
}
```

### 5. Preferer les APIs Hemlock a exec()

```hemlock
// Mauvais - utiliser exec pour les operations sur fichiers
let r = exec("cat file.txt");

// Bon - utiliser l'API File de Hemlock
let f = open("file.txt", "r");
let content = f.read();
f.close();
```

### 6. Capturer stderr si necessaire

```hemlock
// Rediriger stderr vers stdout
let r = exec("command 2>&1");
// Maintenant r.output contient stdout et stderr
```

### 7. Utiliser les fonctionnalites du shell judicieusement

```hemlock
// Utiliser les pipes pour l'efficacite
let r = exec("cat large.txt | grep pattern | head -n 10");

// Utiliser la substitution de commandes
let r = exec("echo Utilisateur actuel : $(whoami)");

// Utiliser l'execution conditionnelle
let r = exec("test -f file.txt && cat file.txt");
```

## Exemples complets

### Exemple 1 : Collecteur d'informations systeme

```hemlock
fn get_system_info() {
    print("=== Informations systeme ===");

    // Nom d'hote
    let r1 = exec("hostname");
    print("Nom d'hote : " + r1.output.trim());

    // Uptime
    let r2 = exec("uptime");
    print("Uptime : " + r2.output.trim());

    // Utilisation disque
    let r3 = exec("df -h /");
    print("\nUtilisation disque :");
    print(r3.output);

    // Utilisation memoire
    let r4 = exec("free -h");
    print("Utilisation memoire :");
    print(r4.output);
}

get_system_info();
```

### Exemple 2 : Analyseur de logs

```hemlock
fn analyze_log(logfile: string) {
    print("Analyse du log : " + logfile);

    // Compter le nombre total de lignes
    let r1 = exec("wc -l " + logfile);
    print("Lignes totales : " + r1.output.trim());

    // Compter les erreurs
    let r2 = exec("grep -c ERROR " + logfile + " 2>/dev/null");
    let errors = r2.output.trim();
    if (r2.exit_code == 0) {
        print("Erreurs : " + errors);
    } else {
        print("Erreurs : 0");
    }

    // Compter les avertissements
    let r3 = exec("grep -c WARN " + logfile + " 2>/dev/null");
    let warnings = r3.output.trim();
    if (r3.exit_code == 0) {
        print("Avertissements : " + warnings);
    } else {
        print("Avertissements : 0");
    }

    // Erreurs recentes
    print("\nErreurs recentes :");
    let r4 = exec("grep ERROR " + logfile + " | tail -n 5");
    print(r4.output);
}

if (args.length < 2) {
    print("Usage : " + args[0] + " <logfile>");
} else {
    analyze_log(args[1]);
}
```

### Exemple 3 : Assistant Git

```hemlock
fn git_status() {
    let r = exec("git status --short");
    if (r.exit_code != 0) {
        print("Erreur : Pas un depot git");
        return;
    }

    if (r.output == "") {
        print("Repertoire de travail propre");
    } else {
        print("Modifications :");
        print(r.output);
    }
}

fn git_quick_commit(message: string) {
    print("Ajout de toutes les modifications...");
    let r1 = exec("git add -A");
    if (r1.exit_code != 0) {
        print("Erreur lors de l'ajout des fichiers");
        return;
    }

    print("Commit en cours...");
    let safe_msg = message.replace_all("'", "'\\''");
    let r2 = exec("git commit -m '" + safe_msg + "'");
    if (r2.exit_code != 0) {
        print("Erreur lors du commit");
        return;
    }

    print("Commit reussi");
    print(r2.output);
}

// Utilisation
git_status();
if (args.length > 1) {
    git_quick_commit(args[1]);
}
```

### Exemple 4 : Script de sauvegarde

```hemlock
fn backup_directory(source: string, dest: string) {
    print("Sauvegarde de " + source + " vers " + dest);

    // Creer le repertoire de sauvegarde
    let r1 = exec("mkdir -p " + dest);
    if (r1.exit_code != 0) {
        print("Erreur lors de la creation du repertoire de sauvegarde");
        return false;
    }

    // Creer une archive avec horodatage
    let r2 = exec("date +%Y%m%d_%H%M%S");
    let timestamp = r2.output.trim();
    let backup_file = dest + "/backup_" + timestamp + ".tar.gz";

    print("Creation de l'archive : " + backup_file);
    let r3 = exec("tar -czf " + backup_file + " " + source + " 2>&1");
    if (r3.exit_code != 0) {
        print("Erreur lors de la creation de la sauvegarde :");
        print(r3.output);
        return false;
    }

    print("Sauvegarde terminee avec succes");

    // Afficher la taille de la sauvegarde
    let r4 = exec("du -h " + backup_file);
    print("Taille de la sauvegarde : " + r4.output.trim());

    return true;
}

if (args.length < 3) {
    print("Usage : " + args[0] + " <source> <destination>");
} else {
    backup_directory(args[1], args[2]);
}
```

## Resume

La fonction `exec()` de Hemlock fournit :

- âœ… Execution simple de commandes shell
- âœ… Capture de sortie (stdout)
- âœ… Verification du code de sortie
- âœ… Acces complet aux fonctionnalites du shell (pipes, redirections, etc.)
- âœ… Integration avec les utilitaires systeme

Rappelez-vous :
- Toujours verifier les codes de sortie
- Etre conscient des implications de securite (injection shell)
- Valider les entrees utilisateur avant de les utiliser dans les commandes
- Preferer les APIs Hemlock a exec() quand c'est possible
- stderr n'est pas capture (utilisez `2>&1` pour rediriger)
- Les commandes bloquent jusqu'a completion
- Utilisez pour les utilitaires courts, pas les services de longue duree

**Liste de verification de securite :**
- âŒ Ne jamais utiliser d'entree utilisateur non assainie
- âœ… Valider toutes les entrees
- âœ… Utiliser des listes blanches pour les commandes
- âœ… Echapper les caracteres speciaux si necessaire
- âœ… Executer avec le minimum de privileges
- âœ… Preferer les APIs Hemlock aux commandes shell


--------------------------------------------------------------------------------
## FFI
--------------------------------------------------------------------------------

# Interface de fonctions etrangeres (FFI) dans Hemlock

Hemlock fournit une **FFI (Foreign Function Interface)** pour appeler des fonctions C depuis des bibliotheques partagees en utilisant libffi, permettant l'integration avec des bibliotheques C existantes et des APIs systeme.

## Table des matieres

- [Vue d'ensemble](#vue-densemble)
- [Etat actuel](#etat-actuel)
- [Types supportes](#types-supportes)
- [Concepts de base](#concepts-de-base)
- [Exportation de fonctions FFI](#exportation-de-fonctions-ffi)
- [Cas d'utilisation](#cas-dutilisation)
- [Developpement futur](#developpement-futur)
- [Callbacks FFI](#callbacks-ffi)
- [Structures FFI](#structures-ffi)
- [Exportation de types struct](#exportation-de-types-struct)
- [Limitations actuelles](#limitations-actuelles)
- [Bonnes pratiques](#bonnes-pratiques)

## Vue d'ensemble

L'interface de fonctions etrangeres (FFI) permet aux programmes Hemlock de :
- Appeler des fonctions C depuis des bibliotheques partagees (.so, .dylib, .dll)
- Utiliser des bibliotheques C existantes sans ecrire de code wrapper
- Acceder directement aux APIs systeme
- S'integrer avec des bibliotheques natives tierces
- Faire le pont entre Hemlock et les fonctionnalites systeme bas niveau

**Capacites cles :**
- Chargement dynamique de bibliotheques
- Liaison de fonctions C
- Conversion automatique de types entre Hemlock et les types C
- Support de tous les types primitifs
- Implementation basee sur libffi pour la portabilite

## Etat actuel

Le support FFI est disponible dans Hemlock avec les fonctionnalites suivantes :

**Implemente :**
- âœ… Appeler des fonctions C depuis des bibliotheques partagees
- âœ… Support de tous les types primitifs (entiers, flottants, pointeurs)
- âœ… Conversion automatique de types
- âœ… Implementation basee sur libffi
- âœ… Chargement dynamique de bibliotheques
- âœ… **Callbacks avec pointeurs de fonction** - Passer des fonctions Hemlock au C
- âœ… **Exporter des fonctions extern** - Partager des liaisons FFI entre modules
- âœ… **Passage et retour de structures** - Passer des structures compatibles C par valeur
- âœ… **Assistants pointeur complets** - Lecture/ecriture de tous les types (i8-i64, u8-u64, f32, f64, ptr)
- âœ… **Conversion buffer/pointeur** - `buffer_ptr()`, `ptr_to_buffer()`
- âœ… **Tailles de types FFI** - `ffi_sizeof()` pour les tailles de types sensibles a la plateforme
- âœ… **Types de plateforme** - Support de `size_t`, `usize`, `isize`, `intptr_t`

**En developpement :**
- ðŸ”„ Assistants de marshaling de chaines
- ðŸ”„ Ameliorations de la gestion des erreurs

**Couverture de tests :**
- Tests FFI passants incluant les tests de callbacks
- Appels de fonctions basiques verifies
- Conversion de types testee
- Integration callback qsort testee

## Types supportes

### Types primitifs

Les types Hemlock suivants peuvent etre passes depuis/vers les fonctions C :

| Type Hemlock | Type C | Taille | Notes |
|--------------|--------|--------|-------|
| `i8` | `int8_t` | 1 octet | Entier signe 8 bits |
| `i16` | `int16_t` | 2 octets | Entier signe 16 bits |
| `i32` | `int32_t` | 4 octets | Entier signe 32 bits |
| `i64` | `int64_t` | 8 octets | Entier signe 64 bits |
| `u8` | `uint8_t` | 1 octet | Entier non signe 8 bits |
| `u16` | `uint16_t` | 2 octets | Entier non signe 16 bits |
| `u32` | `uint32_t` | 4 octets | Entier non signe 32 bits |
| `u64` | `uint64_t` | 8 octets | Entier non signe 64 bits |
| `f32` | `float` | 4 octets | Virgule flottante 32 bits |
| `f64` | `double` | 8 octets | Virgule flottante 64 bits |
| `ptr` | `void*` | 8 octets | Pointeur brut |

### Conversion de types

**Conversions automatiques :**
- Entiers Hemlock â†’ Entiers C (avec verification de plage)
- Flottants Hemlock â†’ Flottants C
- Pointeurs Hemlock â†’ Pointeurs C
- Valeurs de retour C â†’ Valeurs Hemlock

**Exemples de correspondances de types :**
```hemlock
// Hemlock â†’ C
let i: i32 = 42;         // â†’ int32_t (4 octets)
let f: f64 = 3.14;       // â†’ double (8 octets)
let p: ptr = alloc(64);  // â†’ void* (8 octets)

// C â†’ Hemlock (valeurs de retour)
// int32_t foo() â†’ i32
// double bar() â†’ f64
// void* baz() â†’ ptr
```

## Concepts de base

### Bibliotheques partagees

FFI fonctionne avec des bibliotheques partagees compilees :

**Linux :** Fichiers `.so`
```
libexample.so
/usr/lib/libm.so
```

**macOS :** Fichiers `.dylib`
```
libexample.dylib
/usr/lib/libSystem.dylib
```

**Windows :** Fichiers `.dll`
```
example.dll
kernel32.dll
```

### Signatures de fonctions

Les fonctions C doivent avoir des signatures connues pour que FFI fonctionne correctement :

```c
// Exemples de signatures de fonctions C
int add(int a, int b);
double sqrt(double x);
void* malloc(size_t size);
void free(void* ptr);
```

Celles-ci peuvent etre appelees depuis Hemlock une fois que la bibliotheque est chargee et que les fonctions sont liees.

### Compatibilite des plateformes

FFI utilise **libffi** pour la portabilite :
- Fonctionne sur x86, x86-64, ARM, ARM64
- Gere automatiquement les conventions d'appel
- Abstrait les details ABI specifiques a la plateforme
- Supporte Linux, macOS, Windows (avec libffi approprie)

## Exportation de fonctions FFI

Les fonctions FFI declarees avec `extern fn` peuvent etre exportees depuis les modules, vous permettant de creer des wrappers de bibliotheques reutilisables qui peuvent etre partages entre plusieurs fichiers.

### Syntaxe d'exportation de base

```hemlock
// string_utils.hml - Un module de bibliotheque wrappant les fonctions chaine C
import "libc.so.6";

// Exporter la fonction extern directement
export extern fn strlen(s: string): i32;
export extern fn strcmp(s1: string, s2: string): i32;

// Vous pouvez aussi exporter des fonctions wrapper a cote des fonctions extern
export fn string_length(s: string): i32 {
    return strlen(s);
}

export fn strings_equal(a: string, b: string): bool {
    return strcmp(a, b) == 0;
}
```

### Importation de fonctions FFI exportees

```hemlock
// main.hml - Utilisation des fonctions FFI exportees
import { strlen, string_length, strings_equal } from "./string_utils.hml";

let msg = "Hello, World!";
print(strlen(msg));           // 13 - appel extern direct
print(string_length(msg));    // 13 - fonction wrapper

print(strings_equal("foo", "foo"));  // true
print(strings_equal("foo", "bar"));  // false
```

### Cas d'utilisation pour export extern

**1. Abstraction de plateforme**
```hemlock
// platform.hml - Abstraire les differences de plateforme
import "libc.so.6";  // Linux

export extern fn getpid(): i32;
export extern fn getuid(): i32;
export extern fn geteuid(): i32;
```

**2. Wrappers de bibliotheques**
```hemlock
// crypto_lib.hml - Wrapper de fonctions de bibliotheque crypto
import "libcrypto.so";

export extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;
export extern fn MD5(data: ptr, len: u64, out: ptr): ptr;

// Ajouter des wrappers conviviaux pour Hemlock
export fn sha256_string(s: string): string {
    // Implementation utilisant la fonction extern
}
```

**3. Declarations FFI centralisees**
```hemlock
// libc.hml - Module central pour les liaisons libc
import "libc.so.6";

// Fonctions chaine
export extern fn strlen(s: string): i32;
export extern fn strcpy(dest: ptr, src: string): ptr;
export extern fn strcat(dest: ptr, src: string): ptr;

// Fonctions memoire
export extern fn malloc(size: u64): ptr;
export extern fn realloc(p: ptr, size: u64): ptr;
export extern fn calloc(nmemb: u64, size: u64): ptr;

// Fonctions processus
export extern fn getpid(): i32;
export extern fn getppid(): i32;
export extern fn getenv(name: string): ptr;
```

Puis utiliser dans tout votre projet :
```hemlock
import { strlen, malloc, getpid } from "./libc.hml";
```

### Combinaison avec les exports reguliers

Vous pouvez melanger les fonctions extern exportees avec les exports de fonctions regulieres :

```hemlock
// math_extended.hml
import "libm.so.6";

// Exporter les fonctions C brutes
export extern fn sin(x: f64): f64;
export extern fn cos(x: f64): f64;
export extern fn tan(x: f64): f64;

// Exporter des fonctions Hemlock qui les utilisent
export fn deg_to_rad(degrees: f64): f64 {
    return degrees * 3.14159265359 / 180.0;
}

export fn sin_degrees(degrees: f64): f64 {
    return sin(deg_to_rad(degrees));
}
```

### Bibliotheques specifiques a la plateforme

Lors de l'exportation de fonctions extern, rappelez-vous que les noms de bibliotheques different selon la plateforme :

```hemlock
// Pour Linux
import "libc.so.6";

// Pour macOS (approche differente necessaire)
import "libSystem.B.dylib";
```

Actuellement, la syntaxe `import "library"` de Hemlock utilise des chemins de bibliotheques statiques, donc des modules specifiques a la plateforme peuvent etre necessaires pour le code FFI multiplateforme.

## Cas d'utilisation

### 1. Bibliotheques systeme

Acces aux fonctions de la bibliotheque C standard :

**Fonctions mathematiques :**
```hemlock
// Appeler sqrt depuis libm
let result = sqrt(16.0);  // 4.0
```

**Allocation memoire :**
```hemlock
// Appeler malloc/free depuis libc
let ptr = malloc(1024);
free(ptr);
```

### 2. Bibliotheques tierces

Utiliser des bibliotheques C existantes :

**Exemple : Traitement d'images**
```hemlock
// Charger libpng ou libjpeg
// Traiter des images en utilisant les fonctions de la bibliotheque C
```

**Exemple : Cryptographie**
```hemlock
// Utiliser OpenSSL ou libsodium
// Chiffrement/dechiffrement via FFI
```

### 3. APIs systeme

Appels systeme directs :

**Exemple : APIs POSIX**
```hemlock
// Appeler getpid, getuid, etc.
// Acces aux fonctionnalites systeme bas niveau
```

### 4. Code critique en performance

Appeler des implementations C optimisees :

```hemlock
// Utiliser des bibliotheques C hautement optimisees
// Operations SIMD, code vectorise
// Fonctions accelerees par le materiel
```

### 5. Acces au materiel

Interface avec les bibliotheques materielles :

```hemlock
// Controle GPIO sur systemes embarques
// Communication avec peripheriques USB
// Acces au port serie
```

### 6. Integration de code legacy

Reutiliser des bases de code C existantes :

```hemlock
// Appeler des fonctions depuis des applications C legacy
// Migrer progressivement vers Hemlock
// Preserver le code C fonctionnel
```

## Developpement futur

### Fonctionnalites prevues

**1. Support des structures**
```hemlock
// Futur : Passer/retourner des structures C
define Point {
    x: f64,
    y: f64,
}

let p = Point { x: 1.0, y: 2.0 };
c_function_with_struct(p);
```

**2. Gestion des tableaux/tampons**
```hemlock
// Futur : Meilleur passage de tableaux
let arr = [1, 2, 3, 4, 5];
process_array(arr);  // Passer a une fonction C
```

**3. Callbacks avec pointeurs de fonction** âœ… (Implemente !)
```hemlock
// Passer des fonctions Hemlock au C comme callbacks
fn my_compare(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    return va - vb;
}

// Creer un pointeur de fonction appelable depuis C
let cmp = callback(my_compare, ["ptr", "ptr"], "i32");

// Utiliser avec qsort ou toute fonction C attendant un callback
qsort(arr, count, elem_size, cmp);

// Nettoyer quand termine
callback_free(cmp);
```

**4. Marshaling de chaines**
```hemlock
// Futur : Conversion automatique de chaines
let s = "hello";
c_string_function(s);  // Auto-conversion en chaine C
```

**5. Gestion des erreurs**
```hemlock
// Futur : Meilleur rapport d'erreurs
try {
    let result = risky_c_function();
} catch (e) {
    print("Erreur FFI : " + e);
}
```

**6. Securite des types**
```hemlock
// Futur : Annotations de types pour FFI
@ffi("libm.so")
fn sqrt(x: f64): f64;

let result = sqrt(16.0);  // Verifie au niveau des types
```

### Fonctionnalites

**v1.0 :**
- âœ… FFI basique avec types primitifs
- âœ… Chargement dynamique de bibliotheques
- âœ… Appels de fonctions
- âœ… Support des callbacks via closures libffi

**Futur :**
- Support des structures
- Ameliorations de la gestion des tableaux
- Generation automatique de liaisons

## Callbacks FFI

Hemlock supporte le passage de fonctions au code C comme callbacks en utilisant les closures libffi. Cela permet l'integration avec les APIs C qui attendent des pointeurs de fonction, comme `qsort`, les boucles d'evenements et les bibliotheques basees sur callbacks.

### Creation de callbacks

Utilisez `callback()` pour creer un pointeur de fonction appelable depuis C a partir d'une fonction Hemlock :

```hemlock
// callback(function, param_types, return_type) -> ptr
let cb = callback(my_function, ["ptr", "ptr"], "i32");
```

**Parametres :**
- `function` : Une fonction Hemlock a wrapper
- `param_types` : Tableau de chaines de noms de types (ex. `["ptr", "i32"]`)
- `return_type` : Chaine de type de retour (ex. `"i32"`, `"void"`)

**Types de callback supportes :**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - Entiers signes
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - Entiers non signes
- `"f32"`, `"f64"` - Virgule flottante
- `"ptr"` - Pointeur
- `"void"` - Pas de valeur de retour
- `"bool"` - Booleen

### Exemple : qsort

```hemlock
import "libc.so.6";
extern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;

// Fonction de comparaison pour entiers (ordre croissant)
fn compare_ints(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    if (va < vb) { return -1; }
    if (va > vb) { return 1; }
    return 0;
}

// Allouer un tableau de 5 entiers
let arr = alloc(20);  // 5 * 4 octets
ptr_write_i32(arr, 5);
ptr_write_i32(ptr_offset(arr, 1, 4), 2);
ptr_write_i32(ptr_offset(arr, 2, 4), 8);
ptr_write_i32(ptr_offset(arr, 3, 4), 1);
ptr_write_i32(ptr_offset(arr, 4, 4), 9);

// Creer le callback et trier
let cmp = callback(compare_ints, ["ptr", "ptr"], "i32");
qsort(arr, 5, 4, cmp);

// Le tableau est maintenant trie : [1, 2, 5, 8, 9]

// Nettoyer
callback_free(cmp);
free(arr);
```

### Fonctions d'assistance pour pointeurs

Hemlock fournit des fonctions d'assistance completes pour travailler avec les pointeurs bruts. Celles-ci sont essentielles pour les callbacks FFI et la manipulation directe de memoire.

#### Assistants pour types entiers

| Fonction | Description |
|----------|-------------|
| `ptr_deref_i8(ptr)` | Dereferencer pointeur, lire i8 |
| `ptr_deref_i16(ptr)` | Dereferencer pointeur, lire i16 |
| `ptr_deref_i32(ptr)` | Dereferencer pointeur, lire i32 |
| `ptr_deref_i64(ptr)` | Dereferencer pointeur, lire i64 |
| `ptr_deref_u8(ptr)` | Dereferencer pointeur, lire u8 |
| `ptr_deref_u16(ptr)` | Dereferencer pointeur, lire u16 |
| `ptr_deref_u32(ptr)` | Dereferencer pointeur, lire u32 |
| `ptr_deref_u64(ptr)` | Dereferencer pointeur, lire u64 |
| `ptr_write_i8(ptr, value)` | Ecrire i8 a l'emplacement pointeur |
| `ptr_write_i16(ptr, value)` | Ecrire i16 a l'emplacement pointeur |
| `ptr_write_i32(ptr, value)` | Ecrire i32 a l'emplacement pointeur |
| `ptr_write_i64(ptr, value)` | Ecrire i64 a l'emplacement pointeur |
| `ptr_write_u8(ptr, value)` | Ecrire u8 a l'emplacement pointeur |
| `ptr_write_u16(ptr, value)` | Ecrire u16 a l'emplacement pointeur |
| `ptr_write_u32(ptr, value)` | Ecrire u32 a l'emplacement pointeur |
| `ptr_write_u64(ptr, value)` | Ecrire u64 a l'emplacement pointeur |

#### Assistants pour types flottants

| Fonction | Description |
|----------|-------------|
| `ptr_deref_f32(ptr)` | Dereferencer pointeur, lire f32 (float) |
| `ptr_deref_f64(ptr)` | Dereferencer pointeur, lire f64 (double) |
| `ptr_write_f32(ptr, value)` | Ecrire f32 a l'emplacement pointeur |
| `ptr_write_f64(ptr, value)` | Ecrire f64 a l'emplacement pointeur |

#### Assistants pour types pointeur

| Fonction | Description |
|----------|-------------|
| `ptr_deref_ptr(ptr)` | Dereferencer pointeur-vers-pointeur |
| `ptr_write_ptr(ptr, value)` | Ecrire pointeur a l'emplacement pointeur |
| `ptr_offset(ptr, index, size)` | Calculer offset : `ptr + index * size` |
| `ptr_read_i32(ptr)` | Lire i32 a travers pointeur-vers-pointeur (pour callbacks qsort) |
| `ptr_null()` | Obtenir une constante pointeur null |

#### Assistants de conversion de buffer

| Fonction | Description |
|----------|-------------|
| `buffer_ptr(buffer)` | Obtenir le pointeur brut depuis un buffer |
| `ptr_to_buffer(ptr, size)` | Copier les donnees depuis un pointeur dans un nouveau buffer |

#### Fonctions utilitaires FFI

| Fonction | Description |
|----------|-------------|
| `ffi_sizeof(type_name)` | Obtenir la taille en octets d'un type FFI |

**Noms de types supportes pour `ffi_sizeof` :**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - Entiers signes (1, 2, 4, 8 octets)
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - Entiers non signes (1, 2, 4, 8 octets)
- `"f32"`, `"f64"` - Flottants (4, 8 octets)
- `"ptr"` - Pointeur (8 octets sur 64 bits)
- `"size_t"`, `"usize"` - Type de taille dependant de la plateforme
- `"intptr_t"`, `"isize"` - Type de pointeur signe dependant de la plateforme

#### Exemple : Travailler avec differents types

```hemlock
let p = alloc(64);

// Ecrire et lire des entiers
ptr_write_i8(p, 42);
print(ptr_deref_i8(p));  // 42

ptr_write_i64(ptr_offset(p, 1, 8), 9000000000);
print(ptr_deref_i64(ptr_offset(p, 1, 8)));  // 9000000000

// Ecrire et lire des flottants
ptr_write_f64(p, 3.14159);
print(ptr_deref_f64(p));  // 3.14159

// Pointeur-vers-pointeur
let inner = alloc(4);
ptr_write_i32(inner, 999);
ptr_write_ptr(p, inner);
let retrieved = ptr_deref_ptr(p);
print(ptr_deref_i32(retrieved));  // 999

// Obtenir les tailles de types
print(ffi_sizeof("i64"));  // 8
print(ffi_sizeof("ptr"));  // 8 (sur 64 bits)

// Conversion de buffer
let buf = buffer(64);
ptr_write_i32(buffer_ptr(buf), 12345);
print(ptr_deref_i32(buffer_ptr(buf)));  // 12345

free(inner);
free(p);
```

### Liberation des callbacks

**Important :** Toujours liberer les callbacks quand ils ne sont plus necessaires pour eviter les fuites memoire :

```hemlock
let cb = callback(my_fn, ["ptr"], "void");
// ... utiliser le callback ...
callback_free(cb);  // Liberer quand termine
```

Les callbacks sont aussi automatiquement liberes quand le programme se termine.

### Closures dans les callbacks

Les callbacks capturent leur environnement de closure, donc ils peuvent acceder aux variables de la portee externe :

```hemlock
let multiplier = 10;

fn scale(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    // Peut acceder a 'multiplier' depuis la portee externe
    return (va * multiplier) - (vb * multiplier);
}

let cmp = callback(scale, ["ptr", "ptr"], "i32");
```

### Securite des threads

Les invocations de callbacks sont serialisees avec un mutex pour assurer la securite des threads, car l'interpreteur Hemlock n'est pas entierement thread-safe. Cela signifie :
- Un seul callback peut s'executer a la fois
- Sur pour utiliser avec les bibliotheques C multi-threadees
- Peut impacter les performances si les callbacks sont appeles tres frequemment depuis plusieurs threads

### Gestion des erreurs dans les callbacks

Les exceptions lancees dans les callbacks ne peuvent pas se propager au code C. A la place :
- Un avertissement est affiche sur stderr
- Le callback retourne une valeur par defaut (0 ou NULL)
- L'exception est enregistree mais pas propagee

```hemlock
fn risky_callback(a: ptr): i32 {
    throw "Quelque chose s'est mal passe";  // Avertissement affiche, retourne 0
}
```

Pour une gestion des erreurs robuste, validez les entrees et evitez de lancer dans les callbacks.

## Structures FFI

Hemlock supporte le passage de structures par valeur aux fonctions C. Les types struct sont automatiquement enregistres pour FFI quand vous les definissez avec des annotations de types.

### Definition de structures compatibles FFI

Une structure est compatible FFI quand tous les champs ont des annotations de types explicites utilisant des types compatibles FFI :

```hemlock
// Structure compatible FFI
define Point {
    x: f64,
    y: f64,
}

// Structure compatible FFI avec plusieurs types de champs
define Rectangle {
    top_left: Point,      // Structure imbriquee
    width: f64,
    height: f64,
}

// NON compatible FFI (champ sans annotation de type)
define DynamicObject {
    name,                 // Pas de type - non utilisable en FFI
    value,
}
```

### Utilisation des structures en FFI

Declarez des fonctions extern qui utilisent des types struct :

```hemlock
// Definir le type struct
define Vector2D {
    x: f64,
    y: f64,
}

// Importer la bibliotheque C
import "libmath.so";

// Declarer une fonction extern qui prend/retourne des structures
extern fn vector_add(a: Vector2D, b: Vector2D): Vector2D;
extern fn vector_length(v: Vector2D): f64;

// Utiliser naturellement
let a: Vector2D = { x: 3.0, y: 0.0 };
let b: Vector2D = { x: 0.0, y: 4.0 };
let result = vector_add(a, b);
print(result.x);  // 3.0
print(result.y);  // 4.0

let len = vector_length(result);
print(len);       // 5.0
```

### Types de champs supportes

Les champs de structure doivent utiliser ces types compatibles FFI :

| Type Hemlock | Type C | Taille |
|--------------|--------|--------|
| `i8` | `int8_t` | 1 octet |
| `i16` | `int16_t` | 2 octets |
| `i32` | `int32_t` | 4 octets |
| `i64` | `int64_t` | 8 octets |
| `u8` | `uint8_t` | 1 octet |
| `u16` | `uint16_t` | 2 octets |
| `u32` | `uint32_t` | 4 octets |
| `u64` | `uint64_t` | 8 octets |
| `f32` | `float` | 4 octets |
| `f64` | `double` | 8 octets |
| `ptr` | `void*` | 8 octets |
| `string` | `char*` | 8 octets |
| `bool` | `int` | variable |
| Struct imbriquee | struct | variable |

### Disposition des structures

Hemlock utilise les regles de disposition native de la plateforme (correspondant a l'ABI C) :
- Les champs sont alignes selon leur type
- Du padding est insere si necessaire
- La taille totale est paddee pour aligner le plus grand membre

```hemlock
// Exemple : disposition compatible C
define Mixed {
    a: i8,    // offset 0, taille 1
              // 3 octets de padding
    b: i32,   // offset 4, taille 4
}
// Taille totale : 8 octets (avec padding)

define Point3D {
    x: f64,   // offset 0, taille 8
    y: f64,   // offset 8, taille 8
    z: f64,   // offset 16, taille 8
}
// Taille totale : 24 octets (pas de padding necessaire)
```

### Structures imbriquees

Les structures peuvent contenir d'autres structures :

```hemlock
define Inner {
    x: i32,
    y: i32,
}

define Outer {
    inner: Inner,
    z: i32,
}

import "mylib.so";
extern fn process_nested(data: Outer): i32;

let obj: Outer = {
    inner: { x: 1, y: 2 },
    z: 3,
};
let result = process_nested(obj);
```

### Valeurs de retour struct

Les fonctions C peuvent retourner des structures :

```hemlock
define Point {
    x: f64,
    y: f64,
}

import "libmath.so";
extern fn get_origin(): Point;

let p = get_origin();
print(p.x);  // 0.0
print(p.y);  // 0.0
```

### Limitations

- **Les champs de structure doivent avoir des annotations de types** - les champs sans types ne sont pas compatibles FFI
- **Pas de tableaux dans les structures** - utilisez des pointeurs a la place
- **Pas d'unions** - seuls les types struct sont supportes
- **Les callbacks ne peuvent pas retourner de structures** - utilisez des pointeurs pour les valeurs de retour des callbacks

### Exportation de types struct

Vous pouvez exporter des definitions de types struct depuis un module en utilisant `export define` :

```hemlock
// geometry.hml
export define Vector2 {
    x: f32,
    y: f32,
}

export define Rectangle {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
}

export fn create_rect(x: f32, y: f32, w: f32, h: f32): Rectangle {
    return { x: x, y: y, width: w, height: h };
}
```

**Important :** Les types struct exportes sont enregistres **globalement** quand le module est charge. Ils deviennent automatiquement disponibles quand vous importez quoi que ce soit du module. Vous n'avez PAS besoin de (et ne pouvez pas) les importer explicitement par nom :

```hemlock
// main.hml

// BON - les types struct sont auto-disponibles apres tout import du module
import { create_rect } from "./geometry.hml";
let v: Vector2 = { x: 1.0, y: 2.0 };      // Fonctionne - Vector2 est globalement disponible
let r: Rectangle = create_rect(0.0, 0.0, 100.0, 50.0);  // Fonctionne

// MAUVAIS - impossible d'importer explicitement les types struct par nom
import { Vector2 } from "./geometry.hml";  // Erreur : Variable non definie 'Vector2'
```

Ce comportement existe parce que les types struct sont enregistres dans le registre de types global quand le module charge, plutot que d'etre stockes comme valeurs dans l'environnement d'export du module. Le type devient disponible pour tout le code qui importe depuis le module.

## Limitations actuelles

FFI a les limitations suivantes :

**1. Conversion de types manuelle**
- Doit gerer manuellement les conversions de chaines
- Pas de conversion automatique Hemlock string â†” C string

**2. Gestion des erreurs limitee**
- Rapport d'erreurs basique
- Les exceptions dans les callbacks ne peuvent pas se propager au C

**3. Chargement manuel de bibliotheques**
- Doit charger manuellement les bibliotheques
- Pas de generation automatique de liaisons

**4. Code specifique a la plateforme**
- Les chemins de bibliotheques different selon la plateforme
- Doit gerer .so vs .dylib vs .dll

## Bonnes pratiques

Bien que la documentation FFI complete soit encore en cours de developpement, voici les bonnes pratiques generales :

### 1. Securite des types

```hemlock
// Etre explicite sur les types
let x: i32 = 42;
let result: f64 = c_function(x);
```

### 2. Gestion memoire

```hemlock
// Rappelez-vous de liberer la memoire allouee
let ptr = c_malloc(1024);
// ... utiliser ptr
c_free(ptr);
```

### 3. Verification des erreurs

```hemlock
// Verifier les valeurs de retour
let result = c_function();
if (result == null) {
    print("La fonction C a echoue");
}
```

### 4. Compatibilite des plateformes

```hemlock
// Gerer les differences de plateforme
// Utiliser les extensions de bibliotheque appropriees (.so, .dylib, .dll)
```

## Exemples

Pour des exemples fonctionnels, referez-vous a :
- Tests de callbacks : `/tests/ffi_callbacks/` - exemples de callbacks qsort
- Utilisation FFI de la stdlib : `/stdlib/hash.hml`, `/stdlib/regex.hml`, `/stdlib/crypto.hml`
- Programmes d'exemple : `/examples/` (si disponible)

## Obtenir de l'aide

FFI est une fonctionnalite plus recente dans Hemlock. Pour les questions ou problemes :

1. Consultez la suite de tests pour des exemples fonctionnels
2. Referez-vous a la documentation libffi pour les details bas niveau
3. Signalez les bugs ou demandez des fonctionnalites via les issues du projet

## Resume

La FFI de Hemlock fournit :

- âœ… Appels de fonctions C depuis des bibliotheques partagees
- âœ… Support des types primitifs (i8-i64, u8-u64, f32, f64, ptr)
- âœ… Conversion automatique de types
- âœ… Portabilite basee sur libffi
- âœ… Base pour l'integration de bibliotheques natives
- âœ… **Callbacks avec pointeurs de fonction** - passer des fonctions Hemlock au C
- âœ… **Export de fonctions extern** - partager des liaisons FFI entre modules
- âœ… **Passage et retour de structures** - passer des structures compatibles C par valeur
- âœ… **Export define** - partager des definitions de types struct entre modules (auto-importe globalement)
- âœ… **Assistants pointeur complets** - lecture/ecriture de tous les types (i8-i64, u8-u64, f32, f64, ptr)
- âœ… **Conversion buffer/pointeur** - `buffer_ptr()`, `ptr_to_buffer()` pour le marshaling de donnees
- âœ… **Tailles de types FFI** - `ffi_sizeof()` pour les tailles de types sensibles a la plateforme
- âœ… **Types de plateforme** - support de `size_t`, `usize`, `isize`, `intptr_t`, `uintptr_t`

**Etat actuel :** FFI completement fonctionnel avec types primitifs, structures, callbacks, exports de modules et fonctions d'assistance pointeur completes

**Futur :** Assistants de marshaling de chaines

**Cas d'utilisation :** Bibliotheques systeme, bibliotheques tierces, qsort, boucles d'evenements, APIs basees sur callbacks, wrappers de bibliotheques reutilisables

## Contribuer

La documentation FFI est en cours d'expansion. Si vous travaillez avec FFI :
- Documentez vos cas d'utilisation
- Partagez du code d'exemple
- Signalez les problemes ou limitations
- Suggerez des ameliorations

Le systeme FFI est concu pour etre pratique et sur tout en fournissant un acces bas niveau quand necessaire, suivant la philosophie de Hemlock "explicite plutot qu'implicite" et "unsafe est une fonctionnalite, pas un bug."


--------------------------------------------------------------------------------
## File IO
--------------------------------------------------------------------------------

# E/S de fichiers dans Hemlock

Hemlock fournit une **API objet File** pour les operations sur fichiers avec une gestion des erreurs et des ressources appropriee.

## Table des matieres

- [Vue d'ensemble](#vue-densemble)
- [Ouverture de fichiers](#ouverture-de-fichiers)
- [Methodes de fichier](#methodes-de-fichier)
- [Proprietes de fichier](#proprietes-de-fichier)
- [Gestion des erreurs](#gestion-des-erreurs)
- [Gestion des ressources](#gestion-des-ressources)
- [Reference API complete](#reference-api-complete)
- [Patterns courants](#patterns-courants)
- [Bonnes pratiques](#bonnes-pratiques)

## Vue d'ensemble

L'API objet File fournit :

- **Gestion explicite des ressources** - Les fichiers doivent etre fermes manuellement
- **Plusieurs modes d'ouverture** - Lecture, ecriture, ajout, lecture/ecriture
- **Operations texte et binaires** - Lecture/ecriture de texte et de donnees binaires
- **Support du positionnement** - Acces aleatoire au sein des fichiers
- **Messages d'erreur complets** - Rapport d'erreurs contextuel

**Important :** Les fichiers ne sont pas fermes automatiquement. Vous devez appeler `f.close()` pour eviter les fuites de descripteurs de fichiers.

## Ouverture de fichiers

Utilisez `open(path, mode?)` pour ouvrir un fichier :

```hemlock
let f = open("data.txt", "r");     // Mode lecture (par defaut)
let f2 = open("output.txt", "w");  // Mode ecriture (tronque)
let f3 = open("log.txt", "a");     // Mode ajout
let f4 = open("data.bin", "r+");   // Mode lecture/ecriture
```

### Modes d'ouverture

| Mode | Description | Le fichier doit exister | Tronque | Position |
|------|-------------|-------------------------|---------|----------|
| `"r"` | Lecture (par defaut) | Oui | Non | Debut |
| `"w"` | Ecriture | Non (cree) | Oui | Debut |
| `"a"` | Ajout | Non (cree) | Non | Fin |
| `"r+"` | Lecture et ecriture | Oui | Non | Debut |
| `"w+"` | Lecture et ecriture | Non (cree) | Oui | Debut |
| `"a+"` | Lecture et ajout | Non (cree) | Non | Fin |

### Exemples

**Lecture d'un fichier existant :**
```hemlock
let f = open("config.json", "r");
// ou simplement :
let f = open("config.json");  // "r" est le defaut
```

**Creation d'un nouveau fichier pour ecriture :**
```hemlock
let f = open("output.txt", "w");  // Cree ou tronque
```

**Ajout a un fichier :**
```hemlock
let f = open("log.txt", "a");  // Cree s'il n'existe pas
```

**Mode lecture et ecriture :**
```hemlock
let f = open("data.bin", "r+");  // Fichier existant, peut lire/ecrire
```

## Methodes de fichier

### Lecture

#### read(size?: i32): string

Lire du texte depuis le fichier (parametre size optionnel).

**Sans size (lire tout) :**
```hemlock
let f = open("data.txt", "r");
let all = f.read();  // Lire depuis la position actuelle jusqu'a EOF
f.close();
```

**Avec size (lire des octets specifiques) :**
```hemlock
let f = open("data.txt", "r");
let chunk = f.read(1024);  // Lire jusqu'a 1024 octets
let next = f.read(1024);   // Lire les 1024 octets suivants
f.close();
```

**Retourne :** Chaine contenant les donnees lues, ou chaine vide si a EOF

**Exemple - Lecture du fichier entier :**
```hemlock
let f = open("poem.txt", "r");
let content = f.read();
print(content);
f.close();
```

**Exemple - Lecture par morceaux :**
```hemlock
let f = open("large.txt", "r");
while (true) {
    let chunk = f.read(4096);  // Morceaux de 4Ko
    if (chunk == "") { break; }  // EOF atteint
    process(chunk);
}
f.close();
```

#### read_bytes(size: i32): buffer

Lire des donnees binaires (retourne un buffer).

**Parametres :**
- `size` (i32) - Nombre d'octets a lire

**Retourne :** Buffer contenant les octets lus

```hemlock
let f = open("image.png", "r");
let binary = f.read_bytes(256);  // Lire 256 octets
print(binary.length);  // 256 (ou moins si EOF)

// Acceder aux octets individuels
let first_byte = binary[0];
print(first_byte);

f.close();
```

**Exemple - Lecture du fichier binaire entier :**
```hemlock
let f = open("data.bin", "r");
let size = 10240;  // Taille attendue
let data = f.read_bytes(size);
f.close();

// Traiter les donnees binaires
let i = 0;
while (i < data.length) {
    let byte = data[i];
    // ... traiter l'octet
    i = i + 1;
}
```

### Ecriture

#### write(data: string): i32

Ecrire du texte dans le fichier (retourne les octets ecrits).

**Parametres :**
- `data` (string) - Texte a ecrire

**Retourne :** Nombre d'octets ecrits (i32)

```hemlock
let f = open("output.txt", "w");
let written = f.write("Hello, World!\n");
print("Ecrit " + typeof(written) + " octets");  // "Ecrit 14 octets"
f.close();
```

**Exemple - Ecriture de plusieurs lignes :**
```hemlock
let f = open("output.txt", "w");
f.write("Ligne 1\n");
f.write("Ligne 2\n");
f.write("Ligne 3\n");
f.close();
```

**Exemple - Ajout au fichier de log :**
```hemlock
let f = open("app.log", "a");
f.write("[INFO] Application demarree\n");
f.write("[INFO] Utilisateur connecte\n");
f.close();
```

#### write_bytes(data: buffer): i32

Ecrire des donnees binaires (retourne les octets ecrits).

**Parametres :**
- `data` (buffer) - Donnees binaires a ecrire

**Retourne :** Nombre d'octets ecrits (i32)

```hemlock
let f = open("output.bin", "w");

// Creer des donnees binaires
let buf = buffer(10);
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

let bytes = f.write_bytes(buf);
print("Ecrit " + typeof(bytes) + " octets");

f.close();
```

**Exemple - Copie de fichier binaire :**
```hemlock
let src = open("input.bin", "r");
let dst = open("output.bin", "w");

let data = src.read_bytes(1024);
while (data.length > 0) {
    dst.write_bytes(data);
    data = src.read_bytes(1024);
}

src.close();
dst.close();
```

### Positionnement

#### seek(position: i32): i32

Se deplacer a une position specifique (retourne la nouvelle position).

**Parametres :**
- `position` (i32) - Offset en octets depuis le debut du fichier

**Retourne :** Nouvelle position (i32)

```hemlock
let f = open("data.txt", "r");

// Aller a l'octet 100
f.seek(100);

// Lire depuis la position 100
let data = f.read(50);

// Revenir au debut
f.seek(0);

f.close();
```

**Exemple - Acces aleatoire :**
```hemlock
let f = open("records.dat", "r");

// Lire l'enregistrement a l'offset 1000
f.seek(1000);
let record1 = f.read_bytes(100);

// Lire l'enregistrement a l'offset 2000
f.seek(2000);
let record2 = f.read_bytes(100);

f.close();
```

#### tell(): i32

Obtenir la position actuelle dans le fichier.

**Retourne :** Offset en octets actuel (i32)

```hemlock
let f = open("data.txt", "r");

let pos1 = f.tell();  // 0 (au debut)

f.read(100);
let pos2 = f.tell();  // 100 (apres lecture de 100 octets)

f.seek(500);
let pos3 = f.tell();  // 500 (apres positionnement)

f.close();
```

**Exemple - Mesurer la quantite lue :**
```hemlock
let f = open("data.txt", "r");

let start = f.tell();
let content = f.read();
let end = f.tell();

let bytes_read = end - start;
print("Lu " + typeof(bytes_read) + " octets");

f.close();
```

### Fermeture

#### close()

Fermer le fichier (idempotent, peut etre appele plusieurs fois).

```hemlock
let f = open("data.txt", "r");
// ... utiliser le fichier
f.close();
f.close();  // Sur - pas d'erreur au deuxieme appel
```

**Notes importantes :**
- Toujours fermer les fichiers quand termine pour eviter les fuites de descripteurs
- La fermeture est idempotente - peut etre appelee plusieurs fois en securite
- Apres fermeture, toutes les autres operations provoqueront une erreur
- Utilisez des blocs `finally` pour assurer que les fichiers sont fermes meme en cas d'erreurs

## Proprietes de fichier

Les objets File ont trois proprietes en lecture seule :

### path: string

Le chemin de fichier utilise pour ouvrir le fichier.

```hemlock
let f = open("/path/to/file.txt", "r");
print(f.path);  // "/path/to/file.txt"
f.close();
```

### mode: string

Le mode avec lequel le fichier a ete ouvert.

```hemlock
let f = open("data.txt", "r");
print(f.mode);  // "r"
f.close();

let f2 = open("output.txt", "w");
print(f2.mode);  // "w"
f2.close();
```

### closed: bool

Si le fichier est ferme.

```hemlock
let f = open("data.txt", "r");
print(f.closed);  // false

f.close();
print(f.closed);  // true
```

**Exemple - Verification si le fichier est ouvert :**
```hemlock
let f = open("data.txt", "r");

if (!f.closed) {
    let content = f.read();
    // ... traiter le contenu
}

f.close();

if (f.closed) {
    print("Le fichier est maintenant ferme");
}
```

## Gestion des erreurs

Toutes les operations sur fichiers incluent des messages d'erreur avec contexte.

### Erreurs courantes

**Fichier non trouve :**
```hemlock
let f = open("missing.txt", "r");
// Erreur : Echec de l'ouverture de 'missing.txt' : Fichier ou repertoire inexistant
```

**Lecture depuis un fichier ferme :**
```hemlock
let f = open("data.txt", "r");
f.close();
f.read();
// Erreur : Impossible de lire depuis le fichier ferme 'data.txt'
```

**Ecriture dans un fichier en lecture seule :**
```hemlock
let f = open("readonly.txt", "r");
f.write("data");
// Erreur : Impossible d'ecrire dans le fichier 'readonly.txt' ouvert en mode lecture seule
```

**Lecture depuis un fichier en ecriture seule :**
```hemlock
let f = open("output.txt", "w");
f.read();
// Erreur : Impossible de lire depuis le fichier 'output.txt' ouvert en mode ecriture seule
```

### Utilisation de try/catch

```hemlock
try {
    let f = open("data.txt", "r");
    let content = f.read();
    f.close();
    process(content);
} catch (e) {
    print("Erreur de lecture du fichier : " + e);
}
```

## Gestion des ressources

### Pattern de base

Toujours fermer les fichiers explicitement :

```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();
```

### Avec gestion des erreurs (recommande)

Utilisez `finally` pour assurer que les fichiers sont fermes meme en cas d'erreurs :

```hemlock
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();  // Toujours fermer, meme en cas d'erreur
}
```

### Fichiers multiples

```hemlock
let src = null;
let dst = null;

try {
    src = open("input.txt", "r");
    dst = open("output.txt", "w");

    let content = src.read();
    dst.write(content);
} finally {
    if (src != null) { src.close(); }
    if (dst != null) { dst.close(); }
}
```

### Pattern de fonction d'aide

```hemlock
fn with_file(path: string, mode: string, callback) {
    let f = open(path, mode);
    try {
        return callback(f);
    } finally {
        f.close();
    }
}

// Utilisation :
with_file("data.txt", "r", fn(f) {
    return f.read();
});
```

## Reference API complete

### Fonctions

| Fonction | Parametres | Retourne | Description |
|----------|-----------|----------|-------------|
| `open(path, mode?)` | path: string, mode?: string | File | Ouvrir un fichier (mode par defaut "r") |

### Methodes

| Methode | Parametres | Retourne | Description |
|---------|-----------|----------|-------------|
| `read(size?)` | size?: i32 | string | Lire du texte (tout ou octets specifiques) |
| `read_bytes(size)` | size: i32 | buffer | Lire des donnees binaires |
| `write(data)` | data: string | i32 | Ecrire du texte, retourne les octets ecrits |
| `write_bytes(data)` | data: buffer | i32 | Ecrire des donnees binaires, retourne les octets ecrits |
| `seek(position)` | position: i32 | i32 | Aller a la position, retourne la nouvelle position |
| `tell()` | - | i32 | Obtenir la position actuelle |
| `close()` | - | null | Fermer le fichier (idempotent) |

### Proprietes (lecture seule)

| Propriete | Type | Description |
|-----------|------|-------------|
| `path` | string | Chemin du fichier |
| `mode` | string | Mode d'ouverture |
| `closed` | bool | Si le fichier est ferme |

## Patterns courants

### Lecture du fichier entier

```hemlock
fn read_file(path: string): string {
    let f = open(path, "r");
    try {
        return f.read();
    } finally {
        f.close();
    }
}

let content = read_file("config.json");
```

### Ecriture du fichier entier

```hemlock
fn write_file(path: string, content: string) {
    let f = open(path, "w");
    try {
        f.write(content);
    } finally {
        f.close();
    }
}

write_file("output.txt", "Hello, World!");
```

### Ajout au fichier

```hemlock
fn append_file(path: string, content: string) {
    let f = open(path, "a");
    try {
        f.write(content);
    } finally {
        f.close();
    }
}

append_file("log.txt", "[INFO] Evenement survenu\n");
```

### Lecture de lignes

```hemlock
fn read_lines(path: string) {
    let f = open(path, "r");
    try {
        let content = f.read();
        return content.split("\n");
    } finally {
        f.close();
    }
}

let lines = read_lines("data.txt");
let i = 0;
while (i < lines.length) {
    print("Ligne " + typeof(i) + " : " + lines[i]);
    i = i + 1;
}
```

### Traitement de gros fichiers par morceaux

```hemlock
fn process_large_file(path: string) {
    let f = open(path, "r");
    try {
        while (true) {
            let chunk = f.read(4096);  // Morceaux de 4Ko
            if (chunk == "") { break; }

            // Traiter le morceau
            process_chunk(chunk);
        }
    } finally {
        f.close();
    }
}
```

### Copie de fichier binaire

```hemlock
fn copy_file(src_path: string, dst_path: string) {
    let src = null;
    let dst = null;

    try {
        src = open(src_path, "r");
        dst = open(dst_path, "w");

        while (true) {
            let chunk = src.read_bytes(4096);
            if (chunk.length == 0) { break; }

            dst.write_bytes(chunk);
        }
    } finally {
        if (src != null) { src.close(); }
        if (dst != null) { dst.close(); }
    }
}

copy_file("input.dat", "output.dat");
```

### Troncature de fichier

```hemlock
fn truncate_file(path: string) {
    let f = open(path, "w");  // Le mode "w" tronque
    f.close();
}

truncate_file("empty_me.txt");
```

### Lecture a un offset specifique

```hemlock
fn read_at_offset(path: string, offset: i32, size: i32): string {
    let f = open(path, "r");
    try {
        f.seek(offset);
        return f.read(size);
    } finally {
        f.close();
    }
}

let data = read_at_offset("records.dat", 1000, 100);
```

### Taille de fichier

```hemlock
fn file_size(path: string): i32 {
    let f = open(path, "r");
    try {
        // Aller a la fin
        let end = f.seek(999999999);  // Grand nombre
        f.seek(0);  // Reinitialiser
        return end;
    } finally {
        f.close();
    }
}

let size = file_size("data.txt");
print("Taille du fichier : " + typeof(size) + " octets");
```

### Lecture/ecriture conditionnelle

```hemlock
fn update_file(path: string, condition, new_content: string) {
    let f = open(path, "r+");
    try {
        let content = f.read();

        if (condition(content)) {
            f.seek(0);  // Revenir au debut
            f.write(new_content);
        }
    } finally {
        f.close();
    }
}
```

## Bonnes pratiques

### 1. Toujours utiliser try/finally

```hemlock
// Bien
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();
}

// Mauvais - le fichier pourrait ne pas se fermer en cas d'erreur
let f = open("data.txt", "r");
let content = f.read();
process(content);  // Si cela lance, le fichier fuit
f.close();
```

### 2. Verifier l'etat du fichier avant les operations

```hemlock
let f = open("data.txt", "r");

if (!f.closed) {
    let content = f.read();
    // ... utiliser le contenu
}

f.close();
```

### 3. Utiliser les modes appropries

```hemlock
// Lecture seulement ? Utiliser "r"
let f = open("config.json", "r");

// Remplacement complet ? Utiliser "w"
let f = open("output.txt", "w");

// Ajout a la fin ? Utiliser "a"
let f = open("log.txt", "a");
```

### 4. Gerer les erreurs gracieusement

```hemlock
fn safe_read_file(path: string): string {
    try {
        let f = open(path, "r");
        try {
            return f.read();
        } finally {
            f.close();
        }
    } catch (e) {
        print("Attention : Impossible de lire " + path + " : " + e);
        return "";
    }
}
```

### 5. Fermer les fichiers dans l'ordre inverse de l'ouverture

```hemlock
let f1 = null;
let f2 = null;
let f3 = null;

try {
    f1 = open("file1.txt", "r");
    f2 = open("file2.txt", "r");
    f3 = open("file3.txt", "r");

    // ... utiliser les fichiers
} finally {
    // Fermer dans l'ordre inverse
    if (f3 != null) { f3.close(); }
    if (f2 != null) { f2.close(); }
    if (f1 != null) { f1.close(); }
}
```

### 6. Eviter de lire entierement les gros fichiers

```hemlock
// Mauvais pour les gros fichiers
let f = open("huge.log", "r");
let content = f.read();  // Charge le fichier entier en memoire
f.close();

// Bien - traiter par morceaux
let f = open("huge.log", "r");
try {
    while (true) {
        let chunk = f.read(4096);
        if (chunk == "") { break; }
        process_chunk(chunk);
    }
} finally {
    f.close();
}
```

## Resume

L'API E/S de fichiers de Hemlock fournit :

- âœ… Operations sur fichiers simples et explicites
- âœ… Support texte et binaire
- âœ… Acces aleatoire avec seek/tell
- âœ… Messages d'erreur clairs avec contexte
- âœ… Operation de fermeture idempotente

Rappelez-vous :
- Toujours fermer les fichiers manuellement
- Utiliser try/finally pour la securite des ressources
- Choisir les modes d'ouverture appropries
- Gerer les erreurs gracieusement
- Traiter les gros fichiers par morceaux


--------------------------------------------------------------------------------
## Memory Ownership
--------------------------------------------------------------------------------

# PropriÃ©tÃ© de la MÃ©moire dans Hemlock

> "Nous vous donnons les outils pour Ãªtre en sÃ©curitÃ©, mais nous ne vous obligeons pas Ã  les utiliser."

Ce document dÃ©crit la sÃ©mantique de propriÃ©tÃ© de la mÃ©moire dans Hemlock, couvrant Ã  la fois la mÃ©moire gÃ©rÃ©e par le programmeur et les valeurs gÃ©rÃ©es par le runtime.

## Table des MatiÃ¨res

1. [Le Contrat](#le-contrat)
2. [MÃ©moire GÃ©rÃ©e par le Programmeur](#mÃ©moire-gÃ©rÃ©e-par-le-programmeur)
3. [Valeurs GÃ©rÃ©es par le Runtime](#valeurs-gÃ©rÃ©es-par-le-runtime)
4. [Points de Transfert de PropriÃ©tÃ©](#points-de-transfert-de-propriÃ©tÃ©)
5. [Async et Concurrence](#async-et-concurrence)
6. [RÃ¨gles de MÃ©moire FFI](#rÃ¨gles-de-mÃ©moire-ffi)
7. [SÃ©curitÃ© des Exceptions](#sÃ©curitÃ©-des-exceptions)
8. [Meilleures Pratiques](#meilleures-pratiques)

---

## Le Contrat

Hemlock a une division claire de la responsabilitÃ© de gestion de la mÃ©moire :

| Type de MÃ©moire | GÃ©rÃ© Par | MÃ©thode de Nettoyage |
|-----------------|----------|----------------------|
| Pointeurs bruts (`ptr`) | **Programmeur** | `free(ptr)` |
| Buffers (`buffer`) | **Programmeur** | `free(buf)` |
| Strings, Arrays, Objets | **Runtime** | Automatique (comptage de rÃ©fÃ©rences) |
| Fonctions, Closures | **Runtime** | Automatique (comptage de rÃ©fÃ©rences) |
| Tasks, Channels | **Runtime** | Automatique (comptage de rÃ©fÃ©rences) |

**Le principe fondamental :** Si vous l'allouez explicitement, vous le libÃ©rez explicitement. Tout le reste est gÃ©rÃ© automatiquement.

---

## MÃ©moire GÃ©rÃ©e par le Programmeur

### Pointeurs Bruts

```hemlock
let p = alloc(64);       // Allouer 64 octets
memset(p, 0, 64);        // Initialiser
// ... utiliser la mÃ©moire ...
free(p);                 // Votre responsabilitÃ© !
```

**RÃ¨gles :**
- `alloc()` retourne de la mÃ©moire que vous possÃ©dez
- Vous devez appeler `free()` quand vous avez terminÃ©
- Le double-free plantera (intentionnellement)
- L'use-after-free est un comportement indÃ©fini
- L'arithmÃ©tique des pointeurs est permise mais non vÃ©rifiÃ©e

### Allocation TypÃ©e

```hemlock
let arr = talloc("i32", 100);  // Allouer 100 i32s (400 octets)
ptr_write_i32(arr, 0, 42);     // Ã‰crire Ã  l'index 0
let val = ptr_read_i32(arr, 0); // Lire depuis l'index 0
free(arr);                      // Toujours votre responsabilitÃ©
```

### Buffers (Alternative SÃ»re)

```hemlock
let buf = buffer(64);    // Buffer avec vÃ©rification des limites
buf[0] = 42;             // Indexation sÃ»re
// buf[100] = 1;         // Erreur d'exÃ©cution : hors limites
free(buf);               // NÃ©cessite toujours un free explicite
```

**DiffÃ©rence clÃ© :** Les buffers fournissent une vÃ©rification des limites, pas les pointeurs bruts.

---

## Valeurs GÃ©rÃ©es par le Runtime

### Comptage de RÃ©fÃ©rences

Les valeurs allouÃ©es sur le tas utilisent un comptage de rÃ©fÃ©rences atomique :

```hemlock
let s1 = "hello";        // String allouÃ©, refcount = 1
let s2 = s1;             // s2 partage s1, refcount = 2
// Quand les deux sortent du scope, refcount â†’ 0, mÃ©moire libÃ©rÃ©e
```

**Types avec comptage de rÃ©fÃ©rences :**
- `string` - Texte UTF-8
- `array` - Arrays dynamiques
- `object` - Objets clÃ©-valeur
- `function` - Closures
- `task` - Handles de tÃ¢ches async
- `channel` - Canaux de communication

### DÃ©tection de Cycles

Le runtime gÃ¨re les cycles dans les graphes d'objets :

```hemlock
let a = { ref: null };
let b = { ref: a };
a.ref = b;               // Cycle : a â†’ b â†’ a
// Le runtime utilise des ensembles visitÃ©s pour dÃ©tecter et briser les cycles pendant le nettoyage
```

---

## Points de Transfert de PropriÃ©tÃ©

### Liaison de Variables

```hemlock
let x = [1, 2, 3];       // Array crÃ©Ã© avec refcount 1
                         // x possÃ¨de la rÃ©fÃ©rence
```

### Retours de Fonctions

```hemlock
fn make_array() {
    return [1, 2, 3];    // La propriÃ©tÃ© de l'array est transfÃ©rÃ©e Ã  l'appelant
}
let arr = make_array();  // arr possÃ¨de maintenant la rÃ©fÃ©rence
```

### Assignation

```hemlock
let a = "hello";
let b = a;               // RÃ©fÃ©rence partagÃ©e (refcount incrÃ©mentÃ©)
b = "world";             // a a toujours "hello", b a "world"
```

### OpÃ©rations de Channel

```hemlock
let ch = channel(10);
ch.send("message");      // Valeur copiÃ©e dans le buffer du channel
                         // L'original reste valide

let msg = ch.recv();     // ReÃ§oit la propriÃ©tÃ© du channel
```

### Spawning de Tasks

```hemlock
let data = { x: 1 };
let task = spawn(worker, data);  // data est COPIÃ‰ EN PROFONDEUR pour l'isolation
data.x = 2;                       // SÃ»r - le task a sa propre copie
let result = join(task);          // La propriÃ©tÃ© du result est transfÃ©rÃ©e Ã  l'appelant
```

---

## Async et Concurrence

### Isolation des Threads

Les tasks spawnÃ©s reÃ§oivent des **copies profondes** des arguments mutables :

```hemlock
async fn worker(data) {
    data.x = 100;        // Modifie seulement la copie du task
    return data;
}

let obj = { x: 1 };
let task = spawn(worker, obj);
obj.x = 2;               // SÃ»r - n'affecte pas le task
let result = join(task);
print(obj.x);            // 2 (inchangÃ© par le task)
print(result.x);         // 100 (copie modifiÃ©e du task)
```

### Objets de Coordination PartagÃ©s

Certains types sont partagÃ©s par rÃ©fÃ©rence (non copiÃ©s) :
- **Channels** - Pour la communication inter-tasks
- **Tasks** - Pour la coordination (join/detach)

```hemlock
let ch = channel(1);
spawn(producer, ch);     // MÃªme channel, pas une copie
spawn(consumer, ch);     // Les deux tasks partagent le channel
```

### RÃ©sultats des Tasks

```hemlock
let task = spawn(compute);
let result = join(task);  // L'appelant possÃ¨de le rÃ©sultat
                          // La rÃ©fÃ©rence du task est libÃ©rÃ©e quand le task est libÃ©rÃ©
```

### Tasks DÃ©tachÃ©s

```hemlock
detach(spawn(background_work));
// Le task s'exÃ©cute indÃ©pendamment
// Le rÃ©sultat est automatiquement libÃ©rÃ© quand le task se termine
// Pas de fuite mÃªme si personne n'appelle join()
```

---

## RÃ¨gles de MÃ©moire FFI

### Passer aux Fonctions C

```hemlock
extern fn strlen(s: string): i32;

let s = "hello";
let len = strlen(s);     // Hemlock conserve la propriÃ©tÃ©
                         // Le string est valide pendant l'appel
                         // La fonction C ne doit PAS le libÃ©rer
```

### Recevoir des Fonctions C

```hemlock
extern fn strdup(s: string): ptr;

let copy = strdup("hello");  // C a allouÃ© cette mÃ©moire
free(copy);                   // Votre responsabilitÃ© de libÃ©rer
```

### Passage de Structs (Compilateur Seulement)

```hemlock
// DÃ©finir le layout de struct C
ffi_struct Point { x: f64, y: f64 }

extern fn make_point(x: f64, y: f64): Point;

let p = make_point(1.0, 2.0);  // RetournÃ© par valeur, copiÃ©
                                // Pas de nettoyage nÃ©cessaire pour les structs sur la pile
```

### MÃ©moire des Callbacks

```hemlock
// Quand C rappelle Hemlock :
// - Les arguments appartiennent Ã  C (ne pas libÃ©rer)
// - La propriÃ©tÃ© de la valeur de retour est transfÃ©rÃ©e Ã  C
```

---

## SÃ©curitÃ© des Exceptions

### Garanties

Le runtime fournit ces garanties :

1. **Pas de fuite en sortie normale** - Toutes les valeurs gÃ©rÃ©es par le runtime sont nettoyÃ©es
2. **Pas de fuite en exception** - Les temporaires sont libÃ©rÃ©s pendant le dÃ©roulement de la pile
3. **Defer s'exÃ©cute en exception** - Le code de nettoyage s'exÃ©cute

### Ã‰valuation d'Expressions

```hemlock
// Si cela lance pendant la crÃ©ation de l'array :
let arr = [f(), g(), h()];  // L'array partiel est libÃ©rÃ©

// Si cela lance pendant l'appel de fonction :
foo(a(), b(), c());         // Les args prÃ©cÃ©demment Ã©valuÃ©s sont libÃ©rÃ©s
```

### Defer pour le Nettoyage

```hemlock
fn process_file() {
    let f = open("data.txt", "r");
    defer f.close();         // S'exÃ©cute au return OU Ã  l'exception

    let data = f.read();
    if (data == "") {
        throw "Empty file";  // f.close() s'exÃ©cute quand mÃªme !
    }
    return data;
}
```

---

## Meilleures Pratiques

### 1. PrÃ©fÃ©rez les Types GÃ©rÃ©s par le Runtime

```hemlock
// PrÃ©fÃ©rez ceci :
let data = [1, 2, 3, 4, 5];

// Ã€ ceci (sauf si vous avez besoin de contrÃ´le bas niveau) :
let data = talloc("i32", 5);
// ... doit se souvenir de libÃ©rer ...
```

### 2. Utilisez Defer pour la MÃ©moire Manuelle

```hemlock
fn process() {
    let buf = alloc(1024);
    defer free(buf);        // Nettoyage garanti

    // ... utiliser buf ...
    // Pas besoin de libÃ©rer Ã  chaque point de retour
}
```

### 3. Ã‰vitez les Pointeurs Bruts en Async

```hemlock
// FAUX - le pointeur peut Ãªtre libÃ©rÃ© avant que le task se termine
let p = alloc(64);
spawn(worker, p);          // Le task obtient la valeur du pointeur
free(p);                   // Oups ! Le task l'utilise encore

// CORRECT - utilisez des channels ou copiez les donnÃ©es
let ch = channel(1);
let data = buffer(64);
// ... remplir data ...
ch.send(data);             // Copie profonde
spawn(worker, ch);
free(data);                // SÃ»r - le task a sa propre copie
```

### 4. Fermez les Channels Quand Vous Avez TerminÃ©

```hemlock
let ch = channel(10);
// ... utiliser le channel ...
ch.close();                // Vide et libÃ¨re les valeurs en buffer
```

### 5. Join ou Detach les Tasks

```hemlock
let task = spawn(work);

// Option 1 : Attendre le rÃ©sultat
let result = join(task);

// Option 2 : Fire and forget
// detach(task);

// NE PAS : Laisser le handle du task sortir du scope sans join ou detach
// (Il sera nettoyÃ©, mais le rÃ©sultat peut fuir)
```

---

## DÃ©boguer les ProblÃ¨mes de MÃ©moire

### Activer ASAN

```bash
make asan
ASAN_OPTIONS=detect_leaks=1 ./hemlock script.hml
```

### ExÃ©cuter les Tests de RÃ©gression de Fuites

```bash
make leak-regression       # Suite complÃ¨te
make leak-regression-quick # Sauter le test exhaustif
```

### Valgrind

```bash
make valgrind-check FILE=script.hml
```

---

## RÃ©sumÃ©

| OpÃ©ration | Comportement MÃ©moire |
|-----------|---------------------|
| `alloc(n)` | Alloue, vous libÃ©rez |
| `buffer(n)` | Alloue avec vÃ©rification des limites, vous libÃ©rez |
| `"string"` | Le runtime gÃ¨re |
| `[array]` | Le runtime gÃ¨re |
| `{object}` | Le runtime gÃ¨re |
| `spawn(fn)` | Copie profonde des args, le runtime gÃ¨re le task |
| `join(task)` | L'appelant possÃ¨de le rÃ©sultat |
| `detach(task)` | Le runtime libÃ¨re le rÃ©sultat quand terminÃ© |
| `ch.send(v)` | Copie la valeur dans le channel |
| `ch.recv()` | L'appelant possÃ¨de la valeur reÃ§ue |
| `ch.close()` | Vide et libÃ¨re les valeurs en buffer |


--------------------------------------------------------------------------------
## OpÃ©rations Atomiques
--------------------------------------------------------------------------------

# Operations atomiques

Hemlock fournit des operations atomiques pour la **programmation concurrente sans verrou**. Ces operations permettent une manipulation securisee de la memoire partagee entre plusieurs threads sans verrous ou mutex traditionnels.

## Table des matieres

- [Vue d'ensemble](#vue-densemble)
- [Quand utiliser les atomiques](#quand-utiliser-les-atomiques)
- [Modele memoire](#modele-memoire)
- [Chargement et stockage atomiques](#chargement-et-stockage-atomiques)
- [Operations fetch-and-modify](#operations-fetch-and-modify)
- [Compare-and-Swap (CAS)](#compare-and-swap-cas)
- [Echange atomique](#echange-atomique)
- [Barriere memoire](#barriere-memoire)
- [Reference des fonctions](#reference-des-fonctions)
- [Patterns courants](#patterns-courants)
- [Bonnes pratiques](#bonnes-pratiques)
- [Limitations](#limitations)

---

## Vue d'ensemble

Les operations atomiques sont des operations **indivisibles** qui se terminent sans possibilite d'interruption. Quand un thread effectue une operation atomique, aucun autre thread ne peut observer l'operation dans un etat partiellement termine.

**Caracteristiques cles :**
- Toutes les operations utilisent la **coherence sequentielle** (`memory_order_seq_cst`)
- Types supportes : **i32** et **i64**
- Les operations fonctionnent sur des pointeurs bruts alloues avec `alloc()`
- Thread-safe sans verrous explicites

**Operations disponibles :**
- Load/Store - Lire et ecrire des valeurs de maniere atomique
- Add/Sub - Operations arithmetiques retournant l'ancienne valeur
- And/Or/Xor - Operations bit a bit retournant l'ancienne valeur
- CAS - Compare-and-swap pour les mises a jour conditionnelles
- Exchange - Echanger des valeurs de maniere atomique
- Fence - Barriere memoire complete

---

## Quand utiliser les atomiques

**Utilisez les atomiques pour :**
- Compteurs partages entre taches (ex. comptage de requetes, suivi de progression)
- Drapeaux et indicateurs d'etat
- Structures de donnees sans verrou
- Primitives de synchronisation simples
- Code concurrent critique en performance

**Utilisez les canaux a la place quand :**
- Vous passez des donnees complexes entre taches
- Vous implementez des patterns producteur-consommateur
- Vous avez besoin d'une semantique de passage de messages

**Exemple de cas d'utilisation - Compteur partage :**
```hemlock
// Allouer un compteur partage
let counter = alloc(4);
ptr_write_i32(counter, 0);

async fn worker(counter: ptr, id: i32) {
    let i = 0;
    while (i < 1000) {
        atomic_add_i32(counter, 1);
        i = i + 1;
    }
}

// Lancer plusieurs workers
let t1 = spawn(worker, counter, 1);
let t2 = spawn(worker, counter, 2);
let t3 = spawn(worker, counter, 3);

join(t1);
join(t2);
join(t3);

// Le compteur sera exactement 3000 (pas de courses de donnees)
print(atomic_load_i32(counter));

free(counter);
```

---

## Modele memoire

Toutes les operations atomiques Hemlock utilisent la **coherence sequentielle** (`memory_order_seq_cst`), qui fournit les garanties d'ordonnancement memoire les plus fortes :

1. **Atomicite** : Chaque operation est indivisible
2. **Ordonnancement total** : Tous les threads voient le meme ordre d'operations
3. **Pas de reordonnancement** : Les operations ne sont pas reordonnees par le compilateur ou le CPU

Cela rend le raisonnement sur le code concurrent plus simple, au prix d'une certaine perte de performance par rapport aux ordonnancements memoire plus faibles.

---

## Chargement et stockage atomiques

### atomic_load_i32 / atomic_load_i64

Lire atomiquement une valeur depuis la memoire.

**Signature :**
```hemlock
atomic_load_i32(ptr: ptr): i32
atomic_load_i64(ptr: ptr): i64
```

**Parametres :**
- `ptr` - Pointeur vers l'emplacement memoire (doit etre correctement aligne)

**Retourne :** La valeur a l'emplacement memoire

**Exemple :**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);

let value = atomic_load_i32(p);
print(value);  // 42

free(p);
```

---

### atomic_store_i32 / atomic_store_i64

Ecrire atomiquement une valeur en memoire.

**Signature :**
```hemlock
atomic_store_i32(ptr: ptr, value: i32): null
atomic_store_i64(ptr: ptr, value: i64): null
```

**Parametres :**
- `ptr` - Pointeur vers l'emplacement memoire
- `value` - Valeur a stocker

**Retourne :** `null`

**Exemple :**
```hemlock
let p = alloc(8);

atomic_store_i64(p, 5000000000);
print(atomic_load_i64(p));  // 5000000000

free(p);
```

---

## Operations fetch-and-modify

Ces operations modifient atomiquement une valeur et retournent l'**ancienne** valeur (precedente).

### atomic_add_i32 / atomic_add_i64

Ajouter atomiquement a une valeur.

**Signature :**
```hemlock
atomic_add_i32(ptr: ptr, value: i32): i32
atomic_add_i64(ptr: ptr, value: i64): i64
```

**Retourne :** L'**ancienne** valeur (avant addition)

**Exemple :**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_add_i32(p, 10);
print(old);                    // 100 (ancienne valeur)
print(atomic_load_i32(p));     // 110 (nouvelle valeur)

free(p);
```

---

### atomic_sub_i32 / atomic_sub_i64

Soustraire atomiquement d'une valeur.

**Signature :**
```hemlock
atomic_sub_i32(ptr: ptr, value: i32): i32
atomic_sub_i64(ptr: ptr, value: i64): i64
```

**Retourne :** L'**ancienne** valeur (avant soustraction)

**Exemple :**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_sub_i32(p, 25);
print(old);                    // 100 (ancienne valeur)
print(atomic_load_i32(p));     // 75 (nouvelle valeur)

free(p);
```

---

### atomic_and_i32 / atomic_and_i64

Effectuer atomiquement un ET bit a bit.

**Signature :**
```hemlock
atomic_and_i32(ptr: ptr, value: i32): i32
atomic_and_i64(ptr: ptr, value: i64): i64
```

**Retourne :** L'**ancienne** valeur (avant ET)

**Exemple :**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xFF);  // 255 en binaire : 11111111

let old = atomic_and_i32(p, 0x0F);  // ET avec 00001111
print(old);                    // 255 (ancienne valeur)
print(atomic_load_i32(p));     // 15 (0xFF & 0x0F = 0x0F)

free(p);
```

---

### atomic_or_i32 / atomic_or_i64

Effectuer atomiquement un OU bit a bit.

**Signature :**
```hemlock
atomic_or_i32(ptr: ptr, value: i32): i32
atomic_or_i64(ptr: ptr, value: i64): i64
```

**Retourne :** L'**ancienne** valeur (avant OU)

**Exemple :**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0x0F);  // 15 en binaire : 00001111

let old = atomic_or_i32(p, 0xF0);  // OU avec 11110000
print(old);                    // 15 (ancienne valeur)
print(atomic_load_i32(p));     // 255 (0x0F | 0xF0 = 0xFF)

free(p);
```

---

### atomic_xor_i32 / atomic_xor_i64

Effectuer atomiquement un XOR bit a bit.

**Signature :**
```hemlock
atomic_xor_i32(ptr: ptr, value: i32): i32
atomic_xor_i64(ptr: ptr, value: i64): i64
```

**Retourne :** L'**ancienne** valeur (avant XOR)

**Exemple :**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xAA);  // 170 en binaire : 10101010

let old = atomic_xor_i32(p, 0xFF);  // XOR avec 11111111
print(old);                    // 170 (ancienne valeur)
print(atomic_load_i32(p));     // 85 (0xAA ^ 0xFF = 0x55)

free(p);
```

---

## Compare-and-Swap (CAS)

L'operation atomique la plus puissante. Compare atomiquement la valeur actuelle avec une valeur attendue et, si elles correspondent, la remplace par une nouvelle valeur.

### atomic_cas_i32 / atomic_cas_i64

**Signature :**
```hemlock
atomic_cas_i32(ptr: ptr, expected: i32, desired: i32): bool
atomic_cas_i64(ptr: ptr, expected: i64, desired: i64): bool
```

**Parametres :**
- `ptr` - Pointeur vers l'emplacement memoire
- `expected` - Valeur qu'on s'attend a trouver
- `desired` - Valeur a stocker si l'attente correspond

**Retourne :**
- `true` - L'echange a reussi (la valeur etait `expected`, maintenant c'est `desired`)
- `false` - L'echange a echoue (la valeur n'etait pas `expected`, inchangee)

**Exemple :**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

// CAS reussit : la valeur est 100, echange vers 999
let success1 = atomic_cas_i32(p, 100, 999);
print(success1);               // true
print(atomic_load_i32(p));     // 999

// CAS echoue : la valeur est 999, pas 100
let success2 = atomic_cas_i32(p, 100, 888);
print(success2);               // false
print(atomic_load_i32(p));     // 999 (inchange)

free(p);
```

**Cas d'utilisation :**
- Implementation de verrous et semaphores
- Structures de donnees sans verrou
- Controle de concurrence optimiste
- Mises a jour conditionnelles atomiques

---

## Echange atomique

Echanger atomiquement une valeur, retournant l'ancienne valeur.

### atomic_exchange_i32 / atomic_exchange_i64

**Signature :**
```hemlock
atomic_exchange_i32(ptr: ptr, value: i32): i32
atomic_exchange_i64(ptr: ptr, value: i64): i64
```

**Parametres :**
- `ptr` - Pointeur vers l'emplacement memoire
- `value` - Nouvelle valeur a stocker

**Retourne :** L'**ancienne** valeur (avant echange)

**Exemple :**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_exchange_i32(p, 200);
print(old);                    // 100 (ancienne valeur)
print(atomic_load_i32(p));     // 200 (nouvelle valeur)

free(p);
```

---

## Barriere memoire

Une barriere memoire complete qui assure que toutes les operations memoire avant la barriere sont visibles par tous les threads avant toute operation apres la barriere.

### atomic_fence

**Signature :**
```hemlock
atomic_fence(): null
```

**Retourne :** `null`

**Exemple :**
```hemlock
// S'assurer que toutes les ecritures precedentes sont visibles
atomic_fence();
```

**Note :** Dans la plupart des cas, vous n'avez pas besoin de barrieres explicites car toutes les operations atomiques utilisent deja la coherence sequentielle. Les barrieres sont utiles quand vous devez synchroniser des operations memoire non atomiques.

---

## Reference des fonctions

### Operations i32

| Fonction | Signature | Retourne | Description |
|----------|-----------|----------|-------------|
| `atomic_load_i32` | `(ptr)` | `i32` | Charger une valeur atomiquement |
| `atomic_store_i32` | `(ptr, value)` | `null` | Stocker une valeur atomiquement |
| `atomic_add_i32` | `(ptr, value)` | `i32` | Ajouter et retourner l'ancienne valeur |
| `atomic_sub_i32` | `(ptr, value)` | `i32` | Soustraire et retourner l'ancienne valeur |
| `atomic_and_i32` | `(ptr, value)` | `i32` | ET bit a bit et retourner l'ancienne valeur |
| `atomic_or_i32` | `(ptr, value)` | `i32` | OU bit a bit et retourner l'ancienne valeur |
| `atomic_xor_i32` | `(ptr, value)` | `i32` | XOR bit a bit et retourner l'ancienne valeur |
| `atomic_cas_i32` | `(ptr, expected, desired)` | `bool` | Compare-and-swap |
| `atomic_exchange_i32` | `(ptr, value)` | `i32` | Echanger et retourner l'ancienne valeur |

### Operations i64

| Fonction | Signature | Retourne | Description |
|----------|-----------|----------|-------------|
| `atomic_load_i64` | `(ptr)` | `i64` | Charger une valeur atomiquement |
| `atomic_store_i64` | `(ptr, value)` | `null` | Stocker une valeur atomiquement |
| `atomic_add_i64` | `(ptr, value)` | `i64` | Ajouter et retourner l'ancienne valeur |
| `atomic_sub_i64` | `(ptr, value)` | `i64` | Soustraire et retourner l'ancienne valeur |
| `atomic_and_i64` | `(ptr, value)` | `i64` | ET bit a bit et retourner l'ancienne valeur |
| `atomic_or_i64` | `(ptr, value)` | `i64` | OU bit a bit et retourner l'ancienne valeur |
| `atomic_xor_i64` | `(ptr, value)` | `i64` | XOR bit a bit et retourner l'ancienne valeur |
| `atomic_cas_i64` | `(ptr, expected, desired)` | `bool` | Compare-and-swap |
| `atomic_exchange_i64` | `(ptr, value)` | `i64` | Echanger et retourner l'ancienne valeur |

### Barriere memoire

| Fonction | Signature | Retourne | Description |
|----------|-----------|----------|-------------|
| `atomic_fence` | `()` | `null` | Barriere memoire complete |

---

## Patterns courants

### Pattern : Compteur atomique

```hemlock
// Compteur thread-safe
let counter = alloc(4);
ptr_write_i32(counter, 0);

fn increment(): i32 {
    return atomic_add_i32(counter, 1);
}

fn decrement(): i32 {
    return atomic_sub_i32(counter, 1);
}

fn get_count(): i32 {
    return atomic_load_i32(counter);
}

// Utilisation
increment();  // Retourne 0 (ancienne valeur)
increment();  // Retourne 1
increment();  // Retourne 2
print(get_count());  // 3

free(counter);
```

### Pattern : Spinlock

```hemlock
// Implementation simple de spinlock
let lock = alloc(4);
ptr_write_i32(lock, 0);  // 0 = deverrouille, 1 = verrouille

fn acquire() {
    // Tourner jusqu'a ce qu'on reussisse a mettre le verrou de 0 a 1
    while (!atomic_cas_i32(lock, 0, 1)) {
        // Attente active
    }
}

fn release() {
    atomic_store_i32(lock, 0);
}

// Utilisation
acquire();
// ... section critique ...
release();

free(lock);
```

### Pattern : Initialisation unique

```hemlock
let initialized = alloc(4);
ptr_write_i32(initialized, 0);  // 0 = non initialise, 1 = initialise

fn ensure_initialized() {
    // Essayer d'etre celui qui initialise
    if (atomic_cas_i32(initialized, 0, 1)) {
        // On a gagne la course, faire l'initialisation
        do_expensive_init();
    }
    // Sinon, deja initialise
}
```

### Pattern : Drapeau atomique

```hemlock
let flag = alloc(4);
ptr_write_i32(flag, 0);

fn set_flag() {
    atomic_store_i32(flag, 1);
}

fn clear_flag() {
    atomic_store_i32(flag, 0);
}

fn test_and_set(): bool {
    // Retourne true si le drapeau etait deja mis
    return atomic_exchange_i32(flag, 1) == 1;
}

fn check_flag(): bool {
    return atomic_load_i32(flag) == 1;
}
```

### Pattern : Compteur borne

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);
let max_value = 100;

fn try_increment(): bool {
    while (true) {
        let current = atomic_load_i32(counter);
        if (current >= max_value) {
            return false;  // Au maximum
        }
        if (atomic_cas_i32(counter, current, current + 1)) {
            return true;  // Incremente avec succes
        }
        // CAS echoue, un autre thread a modifie - reessayer
    }
}
```

---

## Bonnes pratiques

### 1. Utiliser un alignement correct

Les pointeurs doivent etre correctement alignes pour le type de donnees :
- i32 : alignement sur 4 octets
- i64 : alignement sur 8 octets

La memoire de `alloc()` est typiquement correctement alignee.

### 2. Preferer les abstractions de plus haut niveau

Quand c'est possible, utilisez les canaux pour la communication inter-taches. Les atomiques sont de plus bas niveau et necessitent un raisonnement attentif.

```hemlock
// Preferez ceci :
let ch = channel(10);
spawn(fn() { ch.send(result); });
let value = ch.recv();

// Plutot que la coordination atomique manuelle quand c'est approprie
```

### 3. Etre conscient du probleme ABA

Le CAS peut souffrir du probleme ABA : une valeur change de A vers B puis revient a A. Votre CAS reussit, mais l'etat peut avoir change entre temps.

### 4. Initialiser avant de partager

Toujours initialiser les variables atomiques avant de lancer des taches qui y accedent :

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);  // Initialiser AVANT de lancer

let task = spawn(worker, counter);
```

### 5. Liberer apres que toutes les taches sont terminees

Ne liberez pas la memoire atomique tant que des taches peuvent encore y acceder :

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);

let t1 = spawn(worker, counter);
let t2 = spawn(worker, counter);

join(t1);
join(t2);

// Maintenant c'est sur de liberer
free(counter);
```

---

## Limitations

### Limitations actuelles

1. **Seuls i32 et i64 supportes** - Pas d'operations atomiques pour d'autres types
2. **Pas d'atomiques de pointeurs** - Impossible de charger/stocker des pointeurs atomiquement
3. **Coherence sequentielle uniquement** - Pas d'ordonnancements memoire plus faibles disponibles
4. **Pas de virgule flottante atomique** - Utilisez une representation entiere si necessaire

### Notes de plateforme

- Les operations atomiques utilisent `<stdatomic.h>` du C11 en interne
- Disponible sur toutes les plateformes qui supportent les threads POSIX
- Garanti sans verrou sur les systemes 64 bits modernes

---

## Voir aussi

- [Async/Concurrence](#advanced-async-concurrency) - Lancement de taches et canaux
- [Gestion memoire](#language-guide-memory) - Allocation de pointeurs et tampons
- [API memoire](#reference-memory-api) - Fonctions d'allocation


--------------------------------------------------------------------------------
## Profilage
--------------------------------------------------------------------------------

# Profilage

Hemlock inclut un profiler integre pour l'**analyse du temps CPU**, le **suivi memoire** et la **detection de fuites**. Le profiler aide a identifier les goulots d'etranglement de performance et les problemes memoire dans vos programmes.

## Table des matieres

- [Vue d'ensemble](#vue-densemble)
- [Demarrage rapide](#demarrage-rapide)
- [Modes de profilage](#modes-de-profilage)
- [Formats de sortie](#formats-de-sortie)
- [Detection de fuites](#detection-de-fuites)
- [Comprendre les rapports](#comprendre-les-rapports)
- [Generation de flamegraph](#generation-de-flamegraph)
- [Bonnes pratiques](#bonnes-pratiques)

---

## Vue d'ensemble

Le profiler est accessible via la sous-commande `profile` :

```bash
hemlock profile [OPTIONS] <FILE>
```

**Fonctionnalites cles :**
- **Profilage CPU** - Mesurer le temps passe dans chaque fonction (temps propre et temps total)
- **Profilage memoire** - Suivre toutes les allocations avec les emplacements source
- **Detection de fuites** - Identifier la memoire qui n'a jamais ete liberee
- **Formats de sortie multiples** - Texte, JSON et sortie compatible flamegraph
- **Statistiques memoire par fonction** - Voir quelles fonctions allouent le plus de memoire

---

## Demarrage rapide

### Profiler le temps CPU (par defaut)

```bash
hemlock profile script.hml
```

### Profiler les allocations memoire

```bash
hemlock profile --memory script.hml
```

### Detecter les fuites memoire

```bash
hemlock profile --leaks script.hml
```

### Generer des donnees flamegraph

```bash
hemlock profile --flamegraph script.hml > profile.folded
flamegraph.pl profile.folded > profile.svg
```

---

## Modes de profilage

### Profilage CPU (par defaut)

Mesure le temps passe dans chaque fonction, distinguant entre :
- **Temps propre (Self)** - Temps passe a executer le propre code de la fonction
- **Temps total (Total)** - Temps propre plus temps passe dans les fonctions appelees

```bash
hemlock profile script.hml
hemlock profile --cpu script.hml  # Explicite
```

**Exemple de sortie :**
```
=== Rapport du profiler Hemlock ===

Temps total : 1.234ms
Fonctions appelees : 5 uniques

--- Top 5 par temps propre ---

Fonction                        Self      Total   Appels
--------                        ----      -----   ------
expensive_calc              0.892ms    0.892ms     100  (72.3%)
process_data                0.234ms    1.126ms      10  (19.0%)
helper                      0.067ms    0.067ms     500  (5.4%)
main                        0.041ms    1.234ms       1  (3.3%)
```

---

### Profilage memoire

Suit toutes les allocations memoire (`alloc`, `buffer`, `talloc`, `realloc`) avec les emplacements source.

```bash
hemlock profile --memory script.hml
```

**Exemple de sortie :**
```
=== Rapport du profiler Hemlock ===

Temps total : 0.543ms
Fonctions appelees : 3 uniques
Allocations totales : 15 (4.2Ko)

--- Top 3 par temps propre ---

Fonction                        Self      Total   Appels      Alloc      Nombre
--------                        ----      -----   ------      -----      ------
allocator                   0.312ms    0.312ms      10      3.2Ko         10  (57.5%)
buffer_ops                  0.156ms    0.156ms       5       1Ko          5  (28.7%)
main                        0.075ms    0.543ms       1        0o          0  (13.8%)

--- Top 10 sites d'allocation ---

Emplacement                                   Total    Nombre
-----------                                   -----    ------
src/data.hml:42                               1.5Ko        5
src/data.hml:67                               1.0Ko       10
src/main.hml:15                               512o         1
```

---

### Mode comptage d'appels

Mode a surcharge minimale qui compte uniquement les appels de fonction (pas de chronometrage).

```bash
hemlock profile --calls script.hml
```

---

## Formats de sortie

### Texte (par defaut)

Resume lisible par l'humain avec des tableaux.

```bash
hemlock profile script.hml
```

---

### JSON

Format lisible par machine pour l'integration avec d'autres outils.

```bash
hemlock profile --json script.hml
```

**Exemple de sortie :**
```json
{
  "total_time_ns": 1234567,
  "function_count": 5,
  "total_alloc_bytes": 4096,
  "total_alloc_count": 15,
  "functions": [
    {
      "name": "expensive_calc",
      "source_file": "script.hml",
      "line": 10,
      "self_time_ns": 892000,
      "total_time_ns": 892000,
      "call_count": 100,
      "alloc_bytes": 0,
      "alloc_count": 0
    }
  ],
  "alloc_sites": [
    {
      "source_file": "script.hml",
      "line": 42,
      "total_bytes": 1536,
      "alloc_count": 5,
      "current_bytes": 0
    }
  ]
}
```

---

### Flamegraph

Genere un format de pile reduit compatible avec [flamegraph.pl](https://github.com/brendangregg/FlameGraph).

```bash
hemlock profile --flamegraph script.hml > profile.folded

# Generer le SVG avec flamegraph.pl
flamegraph.pl profile.folded > profile.svg
```

**Exemple de sortie reduite :**
```
main;process_data;expensive_calc 892
main;process_data;helper 67
main;process_data 234
main 41
```

---

## Detection de fuites

Le drapeau `--leaks` montre uniquement les allocations qui n'ont jamais ete liberees, facilitant l'identification des fuites memoire.

```bash
hemlock profile --leaks script.hml
```

**Exemple de programme avec fuites :**
```hemlock
fn leaky() {
    let p1 = alloc(100);    // Fuite - jamais libere
    let p2 = alloc(200);    // OK - libere ci-dessous
    free(p2);
}

fn clean() {
    let b = buffer(64);
    free(b);                // Correctement libere
}

leaky();
clean();
```

**Sortie avec --leaks :**
```
=== Rapport du profiler Hemlock ===

Temps total : 0.034ms
Fonctions appelees : 2 uniques
Allocations totales : 3 (388o)

--- Top 2 par temps propre ---

Fonction                        Self      Total   Appels      Alloc      Nombre
--------                        ----      -----   ------      -----      ------
leaky                       0.021ms    0.021ms       1       300o          2  (61.8%)
clean                       0.013ms    0.013ms       1        88o          1  (38.2%)

--- Fuites memoire (1 site) ---

Emplacement                                  Fuite      Total    Nombre
-----------                                  -----      -----    ------
script.hml:2                                  100o       100o        1
```

Le rapport de fuites montre :
- **Fuite (Leaked)** - Octets actuellement non liberes a la fin du programme
- **Total** - Octets totaux jamais alloues a ce site
- **Nombre (Count)** - Nombre d'allocations a ce site

---

## Comprendre les rapports

### Statistiques de fonction

| Colonne | Description |
|---------|-------------|
| Fonction | Nom de la fonction |
| Self | Temps dans la fonction excluant les appeles |
| Total | Temps incluant toutes les fonctions appelees |
| Appels (Calls) | Nombre de fois que la fonction a ete appelee |
| Alloc | Octets totaux alloues par cette fonction |
| Nombre (Count) | Nombre d'allocations par cette fonction |
| (%) | Pourcentage du temps total du programme |

### Sites d'allocation

| Colonne | Description |
|---------|-------------|
| Emplacement (Location) | Fichier source et numero de ligne |
| Total | Octets totaux alloues a cet emplacement |
| Nombre (Count) | Nombre d'allocations |
| Fuite (Leaked) | Octets encore alloues a la fin du programme (--leaks uniquement) |

### Unites de temps

Le profiler selectionne automatiquement les unites appropriees :
- `ns` - Nanosecondes (< 1us)
- `us` - Microsecondes (< 1ms)
- `ms` - Millisecondes (< 1s)
- `s` - Secondes

---

## Reference des commandes

```
hemlock profile [OPTIONS] <FILE>

OPTIONS :
    --cpu           Profilage CPU/temps (par defaut)
    --memory        Profilage des allocations memoire
    --calls         Comptage d'appels uniquement (surcharge minimale)
    --leaks         Montrer uniquement les allocations non liberees (implique --memory)
    --json          Sortie en format JSON
    --flamegraph    Sortie en format compatible flamegraph
    --top N         Montrer les top N entrees (defaut : 20)
```

---

## Generation de flamegraph

Les flamegraphs visualisent ou votre programme passe du temps, avec des barres plus larges indiquant plus de temps passe.

### Generer un flamegraph

1. Installer flamegraph.pl :
   ```bash
   git clone https://github.com/brendangregg/FlameGraph
   ```

2. Profiler votre programme :
   ```bash
   hemlock profile --flamegraph script.hml > profile.folded
   ```

3. Generer le SVG :
   ```bash
   ./FlameGraph/flamegraph.pl profile.folded > profile.svg
   ```

4. Ouvrir `profile.svg` dans un navigateur pour une visualisation interactive.

### Lire les flamegraphs

- **Axe X** : Pourcentage du temps total (largeur = proportion du temps)
- **Axe Y** : Profondeur de la pile d'appels (bas = point d'entree, haut = fonctions feuilles)
- **Couleur** : Aleatoire, pour distinction visuelle uniquement
- **Clic** : Zoomer sur une fonction pour voir ses appeles

---

## Bonnes pratiques

### 1. Profiler des charges de travail representatives

Profilez avec des donnees et des patterns d'utilisation realistes. Les petits cas de test peuvent ne pas reveler les vrais goulots d'etranglement.

```bash
# Bien : Profiler avec des donnees type production
hemlock profile --memory process_large_file.hml large_input.txt

# Moins utile : Petit cas de test
hemlock profile quick_test.hml
```

### 2. Utiliser --leaks pendant le developpement

Executez la detection de fuites regulierement pour attraper les fuites memoire tot :

```bash
hemlock profile --leaks my_program.hml
```

### 3. Comparer avant et apres

Profilez avant et apres les optimisations pour mesurer l'impact :

```bash
# Avant optimisation
hemlock profile --json script.hml > before.json

# Apres optimisation
hemlock profile --json script.hml > after.json

# Comparer les resultats
```

### 4. Utiliser --top pour les gros programmes

Limitez la sortie pour vous concentrer sur les fonctions les plus significatives :

```bash
hemlock profile --top 10 large_program.hml
```

### 5. Combiner avec les flamegraphs

Pour des patterns d'appels complexes, les flamegraphs fournissent une meilleure visualisation que la sortie texte :

```bash
hemlock profile --flamegraph complex_app.hml > app.folded
flamegraph.pl app.folded > app.svg
```

---

## Surcharge du profiler

Le profiler ajoute une certaine surcharge a l'execution du programme :

| Mode | Surcharge | Cas d'utilisation |
|------|-----------|-------------------|
| `--calls` | Minimale | Juste compter les appels de fonction |
| `--cpu` | Faible | Profilage de performance general |
| `--memory` | Moderee | Analyse memoire et detection de fuites |

Pour les resultats les plus precis, profilez plusieurs fois et cherchez des patterns coherents.

---

## Voir aussi

- [Gestion memoire](#language-guide-memory) - Pointeurs et tampons
- [API memoire](#reference-memory-api) - Fonctions alloc, free, buffer
- [Async/Concurrence](#advanced-async-concurrency) - Profilage du code async


--------------------------------------------------------------------------------
## Signaux
--------------------------------------------------------------------------------

# Gestion des signaux dans Hemlock

Hemlock fournit une **gestion des signaux POSIX** pour gerer les signaux systeme comme SIGINT (Ctrl+C), SIGTERM et les signaux personnalises. Cela permet le controle de processus bas niveau et la communication inter-processus.

## Table des matieres

- [Vue d'ensemble](#vue-densemble)
- [API des signaux](#api-des-signaux)
- [Constantes de signaux](#constantes-de-signaux)
- [Gestion basique des signaux](#gestion-basique-des-signaux)
- [Patterns avances](#patterns-avances)
- [Comportement des gestionnaires de signaux](#comportement-des-gestionnaires-de-signaux)
- [Considerations de securite](#considerations-de-securite)
- [Cas d'utilisation courants](#cas-dutilisation-courants)
- [Exemples complets](#exemples-complets)

## Vue d'ensemble

La gestion des signaux permet aux programmes de :
- Repondre aux interruptions utilisateur (Ctrl+C, Ctrl+Z)
- Implementer un arret gracieux
- Gerer les demandes de terminaison
- Utiliser des signaux personnalises pour la communication inter-processus
- Creer des mecanismes d'alarme/minuterie

**Important :** La gestion des signaux est **inheremment non securisee** dans la philosophie de Hemlock. Les gestionnaires peuvent etre appeles a tout moment, interrompant l'execution normale. L'utilisateur est responsable de la synchronisation appropriee.

## API des signaux

### signal(signum, handler_fn)

Enregistrer une fonction de gestion de signal.

**Parametres :**
- `signum` (i32) - Numero de signal (constante comme SIGINT, SIGTERM)
- `handler_fn` (fonction ou null) - Fonction a appeler quand le signal est recu, ou `null` pour reinitialiser au comportement par defaut

**Retourne :** La fonction de gestion precedente (ou `null` si aucune)

**Exemple :**
```hemlock
fn my_handler(sig) {
    print("Signal intercepte : " + typeof(sig));
}

let old_handler = signal(SIGINT, my_handler);
```

**Reinitialisation au defaut :**
```hemlock
signal(SIGINT, null);  // Reinitialiser SIGINT au comportement par defaut
```

### raise(signum)

Envoyer un signal au processus courant.

**Parametres :**
- `signum` (i32) - Numero de signal a envoyer

**Retourne :** `null`

**Exemple :**
```hemlock
raise(SIGUSR1);  // Declencher le gestionnaire SIGUSR1
```

## Constantes de signaux

Hemlock fournit les constantes de signaux POSIX standard sous forme de valeurs i32.

### Interruption et terminaison

| Constante | Valeur | Description | Declencheur courant |
|-----------|--------|-------------|---------------------|
| `SIGINT` | 2 | Interruption depuis le clavier | Ctrl+C |
| `SIGTERM` | 15 | Demande de terminaison | Commande `kill` |
| `SIGQUIT` | 3 | Quitter depuis le clavier | Ctrl+\ |
| `SIGHUP` | 1 | Deconnexion detectee | Terminal ferme |
| `SIGABRT` | 6 | Signal d'abandon | Fonction `abort()` |

**Exemples :**
```hemlock
signal(SIGINT, handle_interrupt);   // Ctrl+C
signal(SIGTERM, handle_terminate);  // Commande kill
signal(SIGHUP, handle_hangup);      // Terminal ferme
```

### Signaux definis par l'utilisateur

| Constante | Valeur | Description | Cas d'utilisation |
|-----------|--------|-------------|-------------------|
| `SIGUSR1` | 10 | Signal utilisateur 1 | IPC personnalise |
| `SIGUSR2` | 12 | Signal utilisateur 2 | IPC personnalise |

**Exemples :**
```hemlock
// Utiliser pour communication personnalisee
signal(SIGUSR1, reload_config);
signal(SIGUSR2, rotate_logs);
```

### Controle de processus

| Constante | Valeur | Description | Notes |
|-----------|--------|-------------|-------|
| `SIGALRM` | 14 | Minuterie d'alarme | Apres `alarm()` |
| `SIGCHLD` | 17 | Changement d'etat du processus enfant | Gestion de processus |
| `SIGCONT` | 18 | Continuer si arrete | Reprendre apres SIGSTOP |
| `SIGSTOP` | 19 | Arreter le processus | **Ne peut pas etre intercepte** |
| `SIGTSTP` | 20 | Arret terminal | Ctrl+Z |

**Exemples :**
```hemlock
signal(SIGALRM, handle_timeout);
signal(SIGCHLD, handle_child_exit);
```

### Signaux E/S

| Constante | Valeur | Description | Quand envoye |
|-----------|--------|-------------|--------------|
| `SIGPIPE` | 13 | Pipe casse | Ecriture vers pipe ferme |
| `SIGTTIN` | 21 | Lecture en arriere-plan depuis terminal | Processus BG lit TTY |
| `SIGTTOU` | 22 | Ecriture en arriere-plan vers terminal | Processus BG ecrit TTY |

**Exemples :**
```hemlock
signal(SIGPIPE, handle_broken_pipe);
```

## Gestion basique des signaux

### Intercepter Ctrl+C

```hemlock
let interrupted = false;

fn handle_interrupt(sig) {
    print("SIGINT intercepte !");
    interrupted = true;
}

signal(SIGINT, handle_interrupt);

// Le programme continue de s'executer...
// L'utilisateur appuie sur Ctrl+C -> handle_interrupt() est appele

while (!interrupted) {
    // Faire le travail...
}

print("Sortie due a l'interruption");
```

### Signature de fonction de gestionnaire

Les gestionnaires de signaux recoivent un argument : le numero de signal (i32)

```hemlock
fn my_handler(signum) {
    print("Signal recu : " + typeof(signum));
    // signum contient le numero de signal (ex. 2 pour SIGINT)

    if (signum == SIGINT) {
        print("C'est SIGINT");
    }
}

signal(SIGINT, my_handler);
signal(SIGTERM, my_handler);  // Meme gestionnaire pour plusieurs signaux
```

### Gestionnaires de signaux multiples

Differents gestionnaires pour differents signaux :

```hemlock
fn handle_int(sig) {
    print("SIGINT recu");
}

fn handle_term(sig) {
    print("SIGTERM recu");
}

fn handle_usr1(sig) {
    print("SIGUSR1 recu");
}

signal(SIGINT, handle_int);
signal(SIGTERM, handle_term);
signal(SIGUSR1, handle_usr1);
```

### Reinitialisation au comportement par defaut

Passez `null` comme gestionnaire pour reinitialiser au comportement par defaut :

```hemlock
// Enregistrer un gestionnaire personnalise
signal(SIGINT, my_handler);

// Plus tard, reinitialiser au defaut (terminer sur SIGINT)
signal(SIGINT, null);
```

### Lever des signaux manuellement

Envoyer des signaux a votre propre processus :

```hemlock
let count = 0;

fn increment(sig) {
    count = count + 1;
}

signal(SIGUSR1, increment);

// Declencher le gestionnaire manuellement
raise(SIGUSR1);
raise(SIGUSR1);

print(count);  // 2
```

## Patterns avances

### Pattern d'arret gracieux

Pattern courant pour le nettoyage a la terminaison :

```hemlock
let should_exit = false;

fn handle_shutdown(sig) {
    print("Arret gracieux en cours...");
    should_exit = true;
}

signal(SIGINT, handle_shutdown);
signal(SIGTERM, handle_shutdown);

// Boucle principale
while (!should_exit) {
    // Faire le travail...
    // Verifier le drapeau should_exit periodiquement
}

print("Nettoyage termine");
```

### Compteur de signaux

Suivre le nombre de signaux recus :

```hemlock
let signal_count = 0;

fn count_signals(sig) {
    signal_count = signal_count + 1;
    print("Recu " + typeof(signal_count) + " signaux");
}

signal(SIGUSR1, count_signals);

// Plus tard...
print("Signaux totaux : " + typeof(signal_count));
```

### Rechargement de configuration sur signal

```hemlock
let config = load_config();

fn reload_config(sig) {
    print("Rechargement de la configuration...");
    config = load_config();
    print("Configuration rechargee");
}

signal(SIGHUP, reload_config);  // Recharger sur SIGHUP

// Envoyer SIGHUP au processus pour recharger la config
// Depuis le shell : kill -HUP <pid>
```

### Timeout utilisant SIGALRM

```hemlock
let timed_out = false;

fn handle_alarm(sig) {
    print("Timeout !");
    timed_out = true;
}

signal(SIGALRM, handle_alarm);

// Definir l'alarme (pas encore implemente dans Hemlock, exemple seulement)
// alarm(5);  // timeout de 5 secondes

while (!timed_out) {
    // Faire le travail avec timeout
}
```

### Machine a etats basee sur signaux

```hemlock
let state = 0;

fn next_state(sig) {
    state = (state + 1) % 3;
    print("Etat : " + typeof(state));
}

fn prev_state(sig) {
    state = (state - 1 + 3) % 3;
    print("Etat : " + typeof(state));
}

signal(SIGUSR1, next_state);  // Avancer l'etat
signal(SIGUSR2, prev_state);  // Reculer

// Controler la machine a etats :
// kill -USR1 <pid>  # Etat suivant
// kill -USR2 <pid>  # Etat precedent
```

## Comportement des gestionnaires de signaux

### Notes importantes

**Execution des gestionnaires :**
- Les gestionnaires sont appeles **de maniere synchrone** quand le signal est recu
- Les gestionnaires s'executent dans le contexte du processus courant
- Les gestionnaires de signaux partagent l'environnement de closure de la fonction ou ils sont definis
- Les gestionnaires peuvent acceder et modifier les variables de portee externe (comme les globales ou les variables capturees)

**Bonnes pratiques :**
- Garder les gestionnaires simples et rapides - eviter les operations de longue duree
- Definir des drapeaux plutot que d'effectuer une logique complexe
- Eviter d'appeler des fonctions qui pourraient prendre des verrous
- Etre conscient que les gestionnaires peuvent interrompre n'importe quelle operation

### Quels signaux peuvent etre interceptes

**Peuvent etre interceptes et geres :**
- SIGINT, SIGTERM, SIGUSR1, SIGUSR2, SIGHUP, SIGQUIT
- SIGALRM, SIGCHLD, SIGCONT, SIGTSTP
- SIGPIPE, SIGTTIN, SIGTTOU
- SIGABRT (mais le programme s'arretera apres le retour du gestionnaire)

**Ne peuvent pas etre interceptes :**
- `SIGKILL` (9) - Termine toujours le processus
- `SIGSTOP` (19) - Arrete toujours le processus

**Dependant du systeme :**
- Certains signaux ont des comportements par defaut qui peuvent differer selon le systeme
- Consultez la documentation des signaux de votre plateforme pour les specificites

### Limitations des gestionnaires

```hemlock
fn complex_handler(sig) {
    // Eviter ceci dans les gestionnaires de signaux :

    // âŒ Operations de longue duree
    // process_large_file();

    // âŒ E/S bloquantes
    // let f = open("log.txt", "a");
    // f.write("Signal recu\n");

    // âŒ Changements d'etat complexes
    // rebuild_entire_data_structure();

    // âœ… La definition simple de drapeaux est sure
    let should_stop = true;

    // âœ… Les mises a jour simples de compteurs sont generalement sures
    let signal_count = signal_count + 1;
}
```

## Considerations de securite

La gestion des signaux est **inheremment non securisee** dans la philosophie de Hemlock.

### Conditions de course

Les gestionnaires peuvent etre appeles a tout moment, interrompant l'execution normale :

```hemlock
let counter = 0;

fn increment(sig) {
    counter = counter + 1;  // Condition de course si appele pendant la mise a jour du compteur
}

signal(SIGUSR1, increment);

// Le code principal modifie aussi le compteur
counter = counter + 1;  // Pourrait etre interrompu par le gestionnaire de signal
```

**Probleme :** Si le signal arrive pendant que le code principal met a jour `counter`, le resultat est imprevisible.

### Securite async-signal

Hemlock ne **garantit PAS** la securite async-signal :
- Les gestionnaires peuvent appeler n'importe quel code Hemlock (contrairement aux fonctions async-signal-safe restreintes du C)
- Cela fournit de la flexibilite mais necessite de la prudence de l'utilisateur
- Les conditions de course sont possibles si le gestionnaire modifie un etat partage

### Bonnes pratiques pour une gestion de signaux sure

**1. Utiliser des drapeaux atomiques**

Les assignations booleennes simples sont generalement sures :

```hemlock
let should_exit = false;

fn handler(sig) {
    should_exit = true;  // L'assignation simple est sure
}

signal(SIGINT, handler);

while (!should_exit) {
    // travail...
}
```

**2. Minimiser l'etat partage**

```hemlock
let interrupt_count = 0;

fn handler(sig) {
    // Modifier uniquement cette variable
    interrupt_count = interrupt_count + 1;
}
```

**3. Differer les operations complexes**

```hemlock
let pending_reload = false;

fn signal_reload(sig) {
    pending_reload = true;  // Juste definir le drapeau
}

signal(SIGHUP, signal_reload);

// Dans la boucle principale :
while (true) {
    if (pending_reload) {
        reload_config();  // Faire le travail complexe ici
        pending_reload = false;
    }

    // Travail normal...
}
```

**4. Eviter les problemes de reentrance**

```hemlock
let in_critical_section = false;
let data = [];

fn careful_handler(sig) {
    if (in_critical_section) {
        // Ne pas modifier les donnees pendant que le code principal les utilise
        return;
    }
    // Sur de proceder
}
```

## Cas d'utilisation courants

### 1. Arret gracieux de serveur

```hemlock
let running = true;

fn shutdown(sig) {
    print("Signal d'arret recu");
    running = false;
}

signal(SIGINT, shutdown);
signal(SIGTERM, shutdown);

// Boucle principale du serveur
while (running) {
    handle_client_request();
}

cleanup_resources();
print("Serveur arrete");
```

### 2. Rechargement de configuration (sans redemarrage)

```hemlock
let config = load_config("app.conf");
let reload_needed = false;

fn trigger_reload(sig) {
    reload_needed = true;
}

signal(SIGHUP, trigger_reload);

while (true) {
    if (reload_needed) {
        print("Rechargement de la configuration...");
        config = load_config("app.conf");
        reload_needed = false;
    }

    // Utiliser la config...
}
```

### 3. Rotation des logs

```hemlock
let log_file = open("app.log", "a");
let rotate_needed = false;

fn trigger_rotate(sig) {
    rotate_needed = true;
}

signal(SIGUSR1, trigger_rotate);

while (true) {
    if (rotate_needed) {
        log_file.close();
        // Renommer l'ancien log, ouvrir le nouveau
        exec("mv app.log app.log.old");
        log_file = open("app.log", "a");
        rotate_needed = false;
    }

    // Journalisation normale...
    log_file.write("Entree de log\n");
}
```

### 4. Rapport d'etat

```hemlock
let requests_handled = 0;

fn report_status(sig) {
    print("Etat : " + typeof(requests_handled) + " requetes traitees");
}

signal(SIGUSR1, report_status);

while (true) {
    handle_request();
    requests_handled = requests_handled + 1;
}

// Depuis le shell : kill -USR1 <pid>
```

### 5. Basculement du mode debug

```hemlock
let debug_mode = false;

fn toggle_debug(sig) {
    debug_mode = !debug_mode;
    if (debug_mode) {
        print("Mode debug : ACTIVE");
    } else {
        print("Mode debug : DESACTIVE");
    }
}

signal(SIGUSR2, toggle_debug);

// Depuis le shell : kill -USR2 <pid> pour basculer
```

## Exemples complets

### Exemple 1 : Gestionnaire d'interruption avec nettoyage

```hemlock
let running = true;
let signal_count = 0;

fn handle_signal(signum) {
    signal_count = signal_count + 1;

    if (signum == SIGINT) {
        print("Interruption detectee (Ctrl+C)");
        running = false;
    }

    if (signum == SIGUSR1) {
        print("Signal utilisateur 1 recu");
    }
}

// Enregistrer les gestionnaires
signal(SIGINT, handle_signal);
signal(SIGUSR1, handle_signal);

// Simuler du travail
let i = 0;
while (running && i < 100) {
    print("Travail en cours... " + typeof(i));

    // Declencher SIGUSR1 toutes les 10 iterations
    if (i == 10 || i == 20) {
        raise(SIGUSR1);
    }

    i = i + 1;
}

print("Signaux totaux recus : " + typeof(signal_count));
```

### Exemple 2 : Machine a etats multi-signaux

```hemlock
let state = "idle";
let request_count = 0;

fn start_processing(sig) {
    state = "processing";
    print("Etat : " + state);
}

fn stop_processing(sig) {
    state = "idle";
    print("Etat : " + state);
}

fn report_stats(sig) {
    print("Etat : " + state);
    print("Requetes : " + typeof(request_count));
}

signal(SIGUSR1, start_processing);
signal(SIGUSR2, stop_processing);
signal(SIGHUP, report_stats);

while (true) {
    if (state == "processing") {
        // Faire le travail
        request_count = request_count + 1;
    }

    // Verifier a chaque iteration...
}
```

### Exemple 3 : Controleur de pool de workers

```hemlock
let worker_count = 4;
let should_exit = false;

fn increase_workers(sig) {
    worker_count = worker_count + 1;
    print("Workers : " + typeof(worker_count));
}

fn decrease_workers(sig) {
    if (worker_count > 1) {
        worker_count = worker_count - 1;
    }
    print("Workers : " + typeof(worker_count));
}

fn shutdown(sig) {
    print("Arret en cours...");
    should_exit = true;
}

signal(SIGUSR1, increase_workers);
signal(SIGUSR2, decrease_workers);
signal(SIGINT, shutdown);
signal(SIGTERM, shutdown);

// La boucle principale ajuste le pool de workers selon worker_count
while (!should_exit) {
    // Gerer les workers selon worker_count
    // ...
}
```

### Exemple 4 : Pattern de timeout

```hemlock
let operation_complete = false;
let timed_out = false;

fn timeout_handler(sig) {
    timed_out = true;
}

signal(SIGALRM, timeout_handler);

// Demarrer une operation longue
async fn long_operation() {
    // ... travail
    operation_complete = true;
}

let task = spawn(long_operation);

// Attendre avec timeout (verification manuelle)
let elapsed = 0;
while (!operation_complete && elapsed < 1000) {
    // Sleep ou verifier
    elapsed = elapsed + 1;
}

if (!operation_complete) {
    print("Operation expir");
    detach(task);  // Abandonner l'attente
} else {
    join(task);
    print("Operation terminee");
}
```

## Debogage des gestionnaires de signaux

### Ajouter des prints de diagnostic

```hemlock
fn debug_handler(sig) {
    print("Gestionnaire appele pour le signal : " + typeof(sig));
    print("Pile : (pas encore disponible)");

    // Votre logique de gestionnaire...
}

signal(SIGINT, debug_handler);
```

### Compter les appels de gestionnaire

```hemlock
let handler_calls = 0;

fn counting_handler(sig) {
    handler_calls = handler_calls + 1;
    print("Appel de gestionnaire #" + typeof(handler_calls));

    // Votre logique de gestionnaire...
}
```

### Tester avec raise()

```hemlock
fn test_handler(sig) {
    print("Signal de test recu : " + typeof(sig));
}

signal(SIGUSR1, test_handler);

// Tester en levant manuellement
raise(SIGUSR1);
print("Le gestionnaire devrait avoir ete appele");
```

## Resume

La gestion des signaux de Hemlock fournit :

- âœ… Gestion des signaux POSIX pour le controle de processus bas niveau
- âœ… 15 constantes de signaux standard
- âœ… API simple signal() et raise()
- âœ… Fonctions de gestionnaire flexibles avec support des closures
- âœ… Plusieurs signaux peuvent partager des gestionnaires

Rappelez-vous :
- La gestion des signaux est inheremment non securisee - utilisez avec prudence
- Garder les gestionnaires simples et rapides
- Utiliser des drapeaux pour les changements d'etat, pas des operations complexes
- Les gestionnaires peuvent interrompre l'execution a tout moment
- Impossible d'intercepter SIGKILL ou SIGSTOP
- Tester les gestionnaires minutieusement avec raise()

Patterns courants :
- Arret gracieux (SIGINT, SIGTERM)
- Rechargement de configuration (SIGHUP)
- Rotation des logs (SIGUSR1)
- Rapport d'etat (SIGUSR1/SIGUSR2)
- Basculement du mode debug (SIGUSR2)



################################################################################
# RÃ‰FÃ‰RENCE API
################################################################################

--------------------------------------------------------------------------------
## API MÃ©moire
--------------------------------------------------------------------------------

# RÃ©fÃ©rence de l'API Memory

RÃ©fÃ©rence complÃ¨te pour les fonctions de gestion de la mÃ©moire et les types de pointeurs de Hemlock.

---

## AperÃ§u

Hemlock fournit une **gestion manuelle de la mÃ©moire** avec allocation et dÃ©sallocation explicites. La mÃ©moire est gÃ©rÃ©e Ã  travers deux types de pointeurs : les pointeurs bruts (`ptr`) et les buffers sÃ©curisÃ©s (`buffer`).

**Principes clÃ©s :**
- Allocation et dÃ©sallocation explicites
- Pas de ramasse-miettes (garbage collection)
- L'utilisateur est responsable d'appeler `free()`
- Comptage de rÃ©fÃ©rences interne pour la sÃ©curitÃ© des portÃ©es/rÃ©affectations (voir ci-dessous)

### Comptage de rÃ©fÃ©rences interne

Le runtime utilise le comptage de rÃ©fÃ©rences en interne pour gÃ©rer la durÃ©e de vie des objets Ã  travers les portÃ©es. Pour la plupart des variables locales, le nettoyage est automatique.

**Automatique (pas de `free()` nÃ©cessaire) :**
- Les variables locales de types Ã  comptage de rÃ©fÃ©rences (buffer, array, object, string) sont libÃ©rÃ©es Ã  la sortie de la portÃ©e
- Les anciennes valeurs sont libÃ©rÃ©es lors de la rÃ©affectation des variables
- Les Ã©lÃ©ments des conteneurs sont libÃ©rÃ©s quand les conteneurs sont libÃ©rÃ©s

**`free()` manuel requis :**
- Pointeurs bruts de `alloc()` - toujours
- Nettoyage anticipÃ© avant la fin de la portÃ©e
- DonnÃ©es Ã  longue durÃ©e de vie/globales

Voir le [Guide de gestion de la mÃ©moire](../language-guide/memory.md#internal-reference-counting) pour les dÃ©tails.

---

## Types de pointeurs

### ptr (Pointeur brut)

**Type :** `ptr`

**Description :** Adresse mÃ©moire brute sans vÃ©rification des limites ni suivi.

**Taille :** 8 octets

**Cas d'utilisation :**
- OpÃ©rations mÃ©moire de bas niveau
- FFI (Interface de fonction Ã©trangÃ¨re)
- Performance maximale (pas de surcharge)

**SÃ©curitÃ© :** Non sÃ»r - pas de vÃ©rification des limites, l'utilisateur doit suivre la durÃ©e de vie

**Exemples :**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

---

### buffer (Buffer sÃ©curisÃ©)

**Type :** `buffer`

**Description :** Enveloppe de pointeur sÃ©curisÃ©e avec vÃ©rification des limites.

**Structure :** Pointeur + longueur + capacitÃ© + ref_count

**PropriÃ©tÃ©s :**
- `.length` - Taille du buffer (i32)
- `.capacity` - CapacitÃ© allouÃ©e (i32)

**Cas d'utilisation :**
- La plupart des allocations mÃ©moire
- Quand la sÃ©curitÃ© est importante
- Tableaux dynamiques

**SÃ©curitÃ© :** VÃ©rification des limites sur l'accÃ¨s par index

**Comptage de rÃ©fÃ©rences :** Les buffers sont comptÃ©s par rÃ©fÃ©rences en interne. LibÃ©rÃ©s automatiquement Ã  la sortie de la portÃ©e ou lors de la rÃ©affectation de la variable. Utilisez `free()` pour un nettoyage anticipÃ© ou les donnÃ©es Ã  longue durÃ©e de vie.

**Exemples :**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // VÃ©rifiÃ© aux limites
print(b.length);        // 64
free(b);
```

---

## Fonctions d'allocation mÃ©moire

### alloc

Alloue de la mÃ©moire brute.

**Signature :**
```hemlock
alloc(size: i32): ptr
```

**ParamÃ¨tres :**
- `size` - Nombre d'octets Ã  allouer

**Retourne :** Pointeur vers la mÃ©moire allouÃ©e (`ptr`)

**Exemples :**
```hemlock
let p = alloc(1024);        // Allouer 1 Ko
memset(p, 0, 1024);         // Initialiser Ã  zÃ©ro
free(p);                    // LibÃ©rer une fois terminÃ©

// Allouer pour une structure
let struct_size = 16;
let p2 = alloc(struct_size);
```

**Comportement :**
- Retourne de la mÃ©moire non initialisÃ©e
- La mÃ©moire doit Ãªtre libÃ©rÃ©e manuellement
- Retourne `null` en cas d'Ã©chec d'allocation (l'appelant doit vÃ©rifier)

**Voir aussi :** `buffer()` pour une alternative plus sÃ»re

---

### buffer

Alloue un buffer sÃ©curisÃ© avec vÃ©rification des limites.

**Signature :**
```hemlock
buffer(size: i32): buffer
```

**ParamÃ¨tres :**
- `size` - Taille du buffer en octets

**Retourne :** Objet buffer

**Exemples :**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256
print(buf.capacity);        // 256

// AccÃ¨s avec vÃ©rification des limites
buf[0] = 65;                // 'A'
buf[255] = 90;              // 'Z'
// buf[256] = 0;            // ERREUR: hors limites

free(buf);
```

**PropriÃ©tÃ©s :**
- `.length` - Taille actuelle (i32)
- `.capacity` - CapacitÃ© allouÃ©e (i32)

**Comportement :**
- Initialise la mÃ©moire Ã  zÃ©ro
- Fournit une vÃ©rification des limites sur l'accÃ¨s par index
- Retourne `null` en cas d'Ã©chec d'allocation (l'appelant doit vÃ©rifier)
- Doit Ãªtre libÃ©rÃ© manuellement

---

### free

LibÃ¨re la mÃ©moire allouÃ©e.

**Signature :**
```hemlock
free(ptr: ptr | buffer): null
```

**ParamÃ¨tres :**
- `ptr` - Pointeur ou buffer Ã  libÃ©rer

**Retourne :** `null`

**Exemples :**
```hemlock
// LibÃ©rer un pointeur brut
let p = alloc(1024);
free(p);

// LibÃ©rer un buffer
let buf = buffer(256);
free(buf);
```

**Comportement :**
- LibÃ¨re la mÃ©moire allouÃ©e par `alloc()` ou `buffer()`
- Double-free provoque un crash (responsabilitÃ© de l'utilisateur de l'Ã©viter)
- LibÃ©rer des pointeurs invalides provoque un comportement indÃ©fini

**Important :** Vous allouez, vous libÃ©rez. Pas de nettoyage automatique.

---

### realloc

Redimensionne la mÃ©moire allouÃ©e.

**Signature :**
```hemlock
realloc(ptr: ptr, new_size: i32): ptr
```

**ParamÃ¨tres :**
- `ptr` - Pointeur Ã  redimensionner
- `new_size` - Nouvelle taille en octets

**Retourne :** Pointeur vers la mÃ©moire redimensionnÃ©e (peut Ãªtre une adresse diffÃ©rente)

**Exemples :**
```hemlock
let p = alloc(100);
// ... utiliser la mÃ©moire ...

// Besoin de plus d'espace
p = realloc(p, 200);        // Maintenant 200 octets
// ... utiliser la mÃ©moire Ã©tendue ...

free(p);
```

**Comportement :**
- Peut dÃ©placer la mÃ©moire vers un nouvel emplacement
- PrÃ©serve les donnÃ©es existantes (jusqu'au minimum de l'ancienne/nouvelle taille)
- L'ancien pointeur est invalide aprÃ¨s un realloc rÃ©ussi (utiliser le pointeur retournÃ©)
- Si new_size est plus petit, les donnÃ©es sont tronquÃ©es
- Retourne `null` en cas d'Ã©chec d'allocation (le pointeur original reste valide)

**Important :** VÃ©rifiez toujours `null` et mettez Ã  jour votre variable pointeur avec le rÃ©sultat.

---

## OpÃ©rations mÃ©moire

### memset

Remplit la mÃ©moire avec une valeur d'octet.

**Signature :**
```hemlock
memset(ptr: ptr, byte: i32, size: i32): null
```

**ParamÃ¨tres :**
- `ptr` - Pointeur vers la mÃ©moire
- `byte` - Valeur d'octet Ã  remplir (0-255)
- `size` - Nombre d'octets Ã  remplir

**Retourne :** `null`

**Exemples :**
```hemlock
let p = alloc(100);

// Mettre la mÃ©moire Ã  zÃ©ro
memset(p, 0, 100);

// Remplir avec une valeur spÃ©cifique
memset(p, 0xFF, 100);

// Initialiser un buffer
let buf = alloc(256);
memset(buf, 65, 256);       // Remplir avec 'A'

free(p);
free(buf);
```

**Comportement :**
- Ã‰crit la valeur d'octet dans chaque octet de la plage
- La valeur d'octet est tronquÃ©e Ã  8 bits (0-255)
- Pas de vÃ©rification des limites (non sÃ»r)

---

### memcpy

Copie la mÃ©moire de la source vers la destination.

**Signature :**
```hemlock
memcpy(dest: ptr, src: ptr, size: i32): null
```

**ParamÃ¨tres :**
- `dest` - Pointeur de destination
- `src` - Pointeur source
- `size` - Nombre d'octets Ã  copier

**Retourne :** `null`

**Exemples :**
```hemlock
let src = alloc(100);
let dest = alloc(100);

// Initialiser la source
memset(src, 65, 100);

// Copier vers la destination
memcpy(dest, src, 100);

// dest contient maintenant les mÃªmes donnÃ©es que src

free(src);
free(dest);
```

**Comportement :**
- Copie octet par octet de src vers dest
- Pas de vÃ©rification des limites (non sÃ»r)
- Les rÃ©gions qui se chevauchent ont un comportement indÃ©fini (utiliser avec prÃ©caution)

---

## OpÃ©rations mÃ©moire typÃ©es

### sizeof

Obtient la taille d'un type en octets.

**Signature :**
```hemlock
sizeof(type): i32
```

**ParamÃ¨tres :**
- `type` - Identifiant de type (par ex., `i32`, `f64`, `ptr`)

**Retourne :** Taille en octets (i32)

**Tailles des types :**

| Type | Taille (octets) |
|------|-----------------|
| `i8` | 1 |
| `i16` | 2 |
| `i32`, `integer` | 4 |
| `i64` | 8 |
| `u8`, `byte` | 1 |
| `u16` | 2 |
| `u32` | 4 |
| `u64` | 8 |
| `f32` | 4 |
| `f64`, `number` | 8 |
| `bool` | 1 |
| `ptr` | 8 |
| `rune` | 4 |

**Exemples :**
```hemlock
let int_size = sizeof(i32);      // 4
let ptr_size = sizeof(ptr);      // 8
let float_size = sizeof(f64);    // 8
let byte_size = sizeof(u8);      // 1
let rune_size = sizeof(rune);    // 4

// Calculer la taille d'allocation d'un tableau
let count = 100;
let total = sizeof(i32) * count; // 400 octets
```

**Comportement :**
- Retourne 0 pour les types inconnus
- Accepte Ã  la fois les identifiants de type et les chaÃ®nes de type

---

### talloc

Alloue un tableau de valeurs typÃ©es.

**Signature :**
```hemlock
talloc(type, count: i32): ptr
```

**ParamÃ¨tres :**
- `type` - Type Ã  allouer (par ex., `i32`, `f64`, `ptr`)
- `count` - Nombre d'Ã©lÃ©ments (doit Ãªtre positif)

**Retourne :** Pointeur vers le tableau allouÃ©, ou `null` en cas d'Ã©chec d'allocation

**Exemples :**
```hemlock
let arr = talloc(i32, 100);      // Tableau de 100 i32 (400 octets)
let floats = talloc(f64, 50);    // Tableau de 50 f64 (400 octets)
let bytes = talloc(u8, 1024);    // Tableau de 1024 octets

// Toujours vÃ©rifier l'Ã©chec d'allocation
if (arr == null) {
    panic("Ã©chec d'allocation");
}

// Utiliser la mÃ©moire allouÃ©e
// ...

free(arr);
free(floats);
free(bytes);
```

**Comportement :**
- Alloue `sizeof(type) * count` octets
- Retourne de la mÃ©moire non initialisÃ©e
- La mÃ©moire doit Ãªtre libÃ©rÃ©e manuellement avec `free()`
- Retourne `null` en cas d'Ã©chec d'allocation (l'appelant doit vÃ©rifier)
- Panique si count n'est pas positif

---

## PropriÃ©tÃ©s des buffers

### .length

Obtient la taille du buffer.

**Type :** `i32`

**AccÃ¨s :** Lecture seule

**Exemples :**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256

let buf2 = buffer(1024);
print(buf2.length);         // 1024
```

---

### .capacity

Obtient la capacitÃ© du buffer.

**Type :** `i32`

**AccÃ¨s :** Lecture seule

**Exemples :**
```hemlock
let buf = buffer(256);
print(buf.capacity);        // 256
```

**Note :** Actuellement, `.length` et `.capacity` sont identiques pour les buffers crÃ©Ã©s avec `buffer()`.

---

## ModÃ¨les d'utilisation

### ModÃ¨le d'allocation basique

```hemlock
// Allouer
let p = alloc(1024);
if (p == null) {
    panic("Ã©chec d'allocation");
}

// Utiliser
memset(p, 0, 1024);

// LibÃ©rer
free(p);
```

### ModÃ¨le de buffer sÃ©curisÃ©

```hemlock
// Allouer le buffer
let buf = buffer(256);
if (buf == null) {
    panic("Ã©chec d'allocation du buffer");
}

// Utiliser avec vÃ©rification des limites
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

// LibÃ©rer
free(buf);
```

### ModÃ¨le de croissance dynamique

```hemlock
let size = 100;
let p = alloc(size);
if (p == null) {
    panic("Ã©chec d'allocation");
}

// ... utiliser la mÃ©moire ...

// Besoin de plus d'espace - vÃ©rifier l'Ã©chec
let new_p = realloc(p, 200);
if (new_p == null) {
    // Le pointeur original est toujours valide, nettoyer
    free(p);
    panic("Ã©chec de realloc");
}
p = new_p;
size = 200;

// ... utiliser la mÃ©moire Ã©tendue ...

free(p);
```

### ModÃ¨le de copie mÃ©moire

```hemlock
let original = alloc(100);
memset(original, 65, 100);

// CrÃ©er une copie
let copy = alloc(100);
memcpy(copy, original, 100);

free(original);
free(copy);
```

---

## ConsidÃ©rations de sÃ©curitÃ©

**La gestion de la mÃ©moire de Hemlock est NON SÃ›RE par conception :**

### PiÃ¨ges courants

**1. Fuites de mÃ©moire**
```hemlock
// MAUVAIS: Fuite de mÃ©moire
fn create_buffer() {
    let p = alloc(1024);
    return null;  // MÃ©moire fuitÃ©e !
}

// BON: Nettoyage appropriÃ©
fn create_buffer() {
    let p = alloc(1024);
    // ... utiliser la mÃ©moire ...
    free(p);
    return null;
}
```

**2. Utilisation aprÃ¨s libÃ©ration**
```hemlock
// MAUVAIS: Utilisation aprÃ¨s libÃ©ration
let p = alloc(100);
free(p);
memset(p, 0, 100);  // CRASH: utilisation de mÃ©moire libÃ©rÃ©e

// BON: Ne pas utiliser aprÃ¨s libÃ©ration
let p2 = alloc(100);
memset(p2, 0, 100);
free(p2);
// Ne pas toucher p2 aprÃ¨s cela
```

**3. Double libÃ©ration**
```hemlock
// MAUVAIS: Double libÃ©ration
let p = alloc(100);
free(p);
free(p);  // CRASH: double libÃ©ration

// BON: LibÃ©rer une fois
let p2 = alloc(100);
free(p2);
```

**4. DÃ©passement de buffer (ptr)**
```hemlock
// MAUVAIS: DÃ©passement de buffer avec ptr
let p = alloc(10);
memset(p, 65, 100);  // CRASH: Ã©criture au-delÃ  de l'allocation

// BON: Utiliser buffer pour la vÃ©rification des limites
let buf = buffer(10);
// buf[100] = 65;  // ERREUR: la vÃ©rification des limites Ã©choue
```

**5. Pointeurs pendants**
```hemlock
// MAUVAIS: Pointeur pendant
let p1 = alloc(100);
let p2 = p1;
free(p1);
memset(p2, 0, 100);  // CRASH: p2 est pendant

// BON: Suivre la propriÃ©tÃ© avec soin
let p = alloc(100);
// ... utiliser p ...
free(p);
// Ne pas garder d'autres rÃ©fÃ©rences Ã  p
```

**6. Ã‰chec d'allocation non vÃ©rifiÃ©**
```hemlock
// MAUVAIS: Ne pas vÃ©rifier null
let p = alloc(1000000000);  // Peut Ã©chouer avec peu de mÃ©moire
memset(p, 0, 1000000000);   // CRASH: p est null

// BON: Toujours vÃ©rifier le rÃ©sultat de l'allocation
let p2 = alloc(1000000000);
if (p2 == null) {
    panic("plus de mÃ©moire");
}
memset(p2, 0, 1000000000);
free(p2);
```

---

## Quand utiliser quoi

### Utilisez `buffer()` quand :
- Vous avez besoin de vÃ©rification des limites
- Vous travaillez avec des donnÃ©es dynamiques
- La sÃ©curitÃ© est importante
- Vous apprenez Hemlock

### Utilisez `alloc()` quand :
- Performance maximale nÃ©cessaire
- FFI/interface avec C
- Vous connaissez l'agencement mÃ©moire exact
- Vous Ãªtes un expert

### Utilisez `realloc()` quand :
- Croissance/rÃ©duction des allocations
- Tableaux dynamiques
- Vous devez prÃ©server les donnÃ©es

---

## RÃ©sumÃ© complet des fonctions

| Fonction  | Signature                              | Retourne | Description                    |
|-----------|----------------------------------------|----------|--------------------------------|
| `alloc`   | `(size: i32)`                          | `ptr`    | Allouer de la mÃ©moire brute    |
| `buffer`  | `(size: i32)`                          | `buffer` | Allouer un buffer sÃ©curisÃ©     |
| `free`    | `(ptr: ptr \| buffer)`                 | `null`   | LibÃ©rer la mÃ©moire             |
| `realloc` | `(ptr: ptr, new_size: i32)`            | `ptr`    | Redimensionner l'allocation    |
| `memset`  | `(ptr: ptr, byte: i32, size: i32)`     | `null`   | Remplir la mÃ©moire             |
| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`     | `null`   | Copier la mÃ©moire              |
| `sizeof`  | `(type)`                               | `i32`    | Obtenir la taille du type en octets |
| `talloc`  | `(type, count: i32)`                   | `ptr`    | Allouer un tableau typÃ©        |

---

## Voir aussi

- [SystÃ¨me de types](#reference-type-system) - Types pointeur et buffer
- [Fonctions intÃ©grÃ©es](#reference-builtins) - Toutes les fonctions intÃ©grÃ©es
- [API String](#reference-string-api) - MÃ©thode `.to_bytes()` des chaÃ®nes


--------------------------------------------------------------------------------
## API de Concurrence
--------------------------------------------------------------------------------

# RÃ©fÃ©rence de l'API Concurrency

RÃ©fÃ©rence complÃ¨te pour le systÃ¨me async/concurrence de Hemlock.

---

## AperÃ§u

Hemlock fournit une **concurrence structurÃ©e** avec un vÃ©ritable parallÃ©lisme multi-threadÃ© utilisant les threads POSIX (pthreads). Chaque tÃ¢che lancÃ©e s'exÃ©cute sur un thread OS sÃ©parÃ©, permettant une exÃ©cution vÃ©ritablement parallÃ¨le sur plusieurs cÅ“urs CPU.

**CaractÃ©ristiques principales :**
- VÃ©ritable parallÃ©lisme multi-threadÃ© (pas de green threads)
- Syntaxe de fonction async
- Lancement et jointure de tÃ¢ches
- Canaux thread-safe
- Propagation des exceptions

**ModÃ¨le de threading :**
- âœ… Vrais threads OS (POSIX pthreads)
- âœ… VÃ©ritable parallÃ©lisme (plusieurs cÅ“urs CPU)
- âœ… OrdonnancÃ© par le noyau (multitÃ¢che prÃ©emptif)
- âœ… Synchronisation thread-safe (mutex, variables de condition)

---

## Fonctions async

### DÃ©claration de fonction async

Les fonctions peuvent Ãªtre dÃ©clarÃ©es comme `async` pour indiquer qu'elles sont conÃ§ues pour l'exÃ©cution concurrente.

**Syntaxe :**
```hemlock
async fn nom_fonction(params): type_retour {
    // corps de la fonction
}
```

**Exemples :**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

async fn process_data(data: string) {
    print("Traitement:", data);
    return null;
}
```

**Comportement :**
- `async fn` dÃ©clare une fonction asynchrone
- Peut Ãªtre appelÃ©e de maniÃ¨re synchrone (s'exÃ©cute dans le thread courant)
- Peut Ãªtre lancÃ©e comme tÃ¢che concurrente (s'exÃ©cute sur un nouveau thread)
- Quand lancÃ©e, s'exÃ©cute sur son propre thread OS

**Note :** Le mot-clÃ© `await` est rÃ©servÃ© pour une utilisation future mais n'est pas actuellement implÃ©mentÃ©.

---

## Gestion des tÃ¢ches

### spawn

CrÃ©e et dÃ©marre une nouvelle tÃ¢che concurrente.

**Signature :**
```hemlock
spawn(async_fn: function, ...args): task
```

**ParamÃ¨tres :**
- `async_fn` - Fonction async Ã  exÃ©cuter
- `...args` - Arguments Ã  passer Ã  la fonction

**Retourne :** Handle de tÃ¢che

**Exemples :**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Lancer une seule tÃ¢che
let t = spawn(compute, 1000);
let result = join(t);
print(result);

// Lancer plusieurs tÃ¢ches (s'exÃ©cutent en parallÃ¨le !)
let t1 = spawn(compute, 100);
let t2 = spawn(compute, 200);
let t3 = spawn(compute, 300);

// Les trois s'exÃ©cutent simultanÃ©ment
let r1 = join(t1);
let r2 = join(t2);
let r3 = join(t3);
```

**Comportement :**
- CrÃ©e un nouveau thread OS via `pthread_create()`
- Commence l'exÃ©cution de la fonction immÃ©diatement
- Retourne un handle de tÃ¢che pour une jointure ultÃ©rieure
- Les tÃ¢ches s'exÃ©cutent en parallÃ¨le sur des cÅ“urs CPU sÃ©parÃ©s

---

### join

Attend la fin de la tÃ¢che et rÃ©cupÃ¨re le rÃ©sultat.

**Signature :**
```hemlock
join(task: task): any
```

**ParamÃ¨tres :**
- `task` - Handle de tÃ¢che de `spawn()`

**Retourne :** Valeur de retour de la tÃ¢che

**Exemples :**
```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

let t = spawn(factorial, 10);
let result = join(t);  // Bloque jusqu'Ã  ce que la tÃ¢che se termine
print(result);         // 3628800
```

**Comportement :**
- Bloque le thread courant jusqu'Ã  ce que la tÃ¢che se termine
- Retourne la valeur de retour de la tÃ¢che
- Propage les exceptions levÃ©es par la tÃ¢che
- Nettoie les ressources de la tÃ¢che aprÃ¨s le retour

**Gestion des erreurs :**
```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "La tÃ¢che a Ã©chouÃ© !";
    }
    return 42;
}

let t = spawn(risky_operation, 1);
try {
    let result = join(t);
} catch (e) {
    print("InterceptÃ©:", e);  // "InterceptÃ©: La tÃ¢che a Ã©chouÃ© !"
}
```

---

### detach

DÃ©tache la tÃ¢che (exÃ©cution fire-and-forget).

**Signature :**
```hemlock
detach(task: task): null
```

**ParamÃ¨tres :**
- `task` - Handle de tÃ¢che de `spawn()`

**Retourne :** `null`

**Exemples :**
```hemlock
async fn background_work() {
    print("Travail en arriÃ¨re-plan...");
    return null;
}

let t = spawn(background_work);
detach(t);  // La tÃ¢che continue de s'exÃ©cuter indÃ©pendamment

// Impossible de joindre une tÃ¢che dÃ©tachÃ©e
// join(t);  // ERREUR
```

**Comportement :**
- La tÃ¢che continue de s'exÃ©cuter indÃ©pendamment
- Impossible de faire `join()` sur une tÃ¢che dÃ©tachÃ©e
- La tÃ¢che et le thread sont automatiquement nettoyÃ©s quand la tÃ¢che se termine

**Cas d'utilisation :**
- TÃ¢ches en arriÃ¨re-plan fire-and-forget
- TÃ¢ches de journalisation/surveillance
- TÃ¢ches qui n'ont pas besoin de retourner de valeurs

---

## Canaux

Les canaux fournissent une communication thread-safe entre les tÃ¢ches.

### channel

CrÃ©e un canal avec buffer.

**Signature :**
```hemlock
channel(capacity: i32): channel
```

**ParamÃ¨tres :**
- `capacity` - Taille du buffer (nombre de valeurs)

**Retourne :** Objet channel

**Exemples :**
```hemlock
let ch = channel(10);  // Canal avec buffer de capacitÃ© 10
let ch2 = channel(1);  // Buffer minimal (synchrone)
let ch3 = channel(100); // Grand buffer
```

**Comportement :**
- CrÃ©e un canal thread-safe
- Utilise des mutex pthread pour la synchronisation
- La capacitÃ© est fixÃ©e Ã  la crÃ©ation

---

### MÃ©thodes des canaux

#### send

Envoie une valeur au canal (bloque si plein).

**Signature :**
```hemlock
channel.send(value: any): null
```

**ParamÃ¨tres :**
- `value` - Valeur Ã  envoyer (n'importe quel type)

**Retourne :** `null`

**Exemples :**
```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

let ch = channel(10);
let t = spawn(producer, ch, 5);
```

**Comportement :**
- Envoie la valeur au canal
- Bloque si le canal est plein
- Thread-safe (utilise un mutex)
- Retourne aprÃ¨s que la valeur est envoyÃ©e

---

#### recv

ReÃ§oit une valeur du canal (bloque si vide).

**Signature :**
```hemlock
channel.recv(): any
```

**Retourne :** Valeur du canal, ou `null` si le canal est fermÃ© et vide

**Exemples :**
```hemlock
async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(10);
let t = spawn(consumer, ch, 5);
```

**Comportement :**
- ReÃ§oit une valeur du canal
- Bloque si le canal est vide
- Retourne `null` si le canal est fermÃ© et vide
- Thread-safe (utilise un mutex)

---

#### close

Ferme le canal (plus d'envois autorisÃ©s).

**Signature :**
```hemlock
channel.close(): null
```

**Retourne :** `null`

**Exemples :**
```hemlock
async fn producer(ch) {
    ch.send(1);
    ch.send(2);
    ch.send(3);
    ch.close();  // Signale qu'il n'y a plus de valeurs
    return null;
}

async fn consumer(ch) {
    while (true) {
        let val = ch.recv();
        if (val == null) {
            break;  // Canal fermÃ©
        }
        print(val);
    }
    return null;
}
```

**Comportement :**
- Ferme le canal
- Plus d'envois autorisÃ©s
- `recv()` retourne `null` quand le canal est vide
- Thread-safe

---

## Exemple complet de concurrence

### ModÃ¨le producteur-consommateur

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        print("Production:", i);
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        print("Consommation:", val);
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

// CrÃ©er le canal
let ch = channel(10);

// Lancer producteur et consommateur
let p = spawn(producer, ch, 5);
let c = spawn(consumer, ch, 5);

// Attendre la fin
join(p);
let total = join(c);
print("Total:", total);  // 0+10+20+30+40 = 100
```

---

## Calcul parallÃ¨le

### Exemple de tÃ¢ches multiples

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Lancer plusieurs tÃ¢ches (s'exÃ©cutent en parallÃ¨le !)
let t1 = spawn(factorial, 5);   // Thread 1
let t2 = spawn(factorial, 6);   // Thread 2
let t3 = spawn(factorial, 7);   // Thread 3
let t4 = spawn(factorial, 8);   // Thread 4

// Les quatre calculent simultanÃ©ment !

// Attendre les rÃ©sultats
let f5 = join(t1);  // 120
let f6 = join(t2);  // 720
let f7 = join(t3);  // 5040
let f8 = join(t4);  // 40320

print(f5, f6, f7, f8);
```

---

## Cycle de vie des tÃ¢ches

### Transitions d'Ã©tat

1. **CrÃ©Ã©e** - TÃ¢che lancÃ©e mais pas encore en exÃ©cution
2. **En cours** - TÃ¢che en exÃ©cution sur un thread OS
3. **TerminÃ©e** - TÃ¢che terminÃ©e (rÃ©sultat disponible)
4. **Jointe** - RÃ©sultat rÃ©cupÃ©rÃ©, ressources nettoyÃ©es
5. **DÃ©tachÃ©e** - TÃ¢che continue indÃ©pendamment

### Exemple de cycle de vie

```hemlock
async fn work(n: i32): i32 {
    return n * 2;
}

// 1. CrÃ©er la tÃ¢che
let t = spawn(work, 21);  // Ã‰tat: En cours

// La tÃ¢che s'exÃ©cute sur un thread sÃ©parÃ©...

// 2. Joindre la tÃ¢che
let result = join(t);     // Ã‰tat: TerminÃ©e â†’ Jointe
print(result);            // 42

// Ressources de la tÃ¢che nettoyÃ©es aprÃ¨s join
```

### Cycle de vie dÃ©tachÃ©

```hemlock
async fn background() {
    print("TÃ¢che en arriÃ¨re-plan en cours");
    return null;
}

// 1. CrÃ©er la tÃ¢che
let t = spawn(background);  // Ã‰tat: En cours

// 2. DÃ©tacher la tÃ¢che
detach(t);                  // Ã‰tat: DÃ©tachÃ©e

// La tÃ¢che continue de s'exÃ©cuter indÃ©pendamment
// Ressources nettoyÃ©es par l'OS quand terminÃ©e
```

---

## Gestion des erreurs

### Propagation des exceptions

Les exceptions levÃ©es dans les tÃ¢ches sont propagÃ©es lors de la jointure :

```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "La tÃ¢che a Ã©chouÃ© !";
    }
    return 42;
}

// TÃ¢che qui rÃ©ussit
let t1 = spawn(risky_operation, 0);
let result1 = join(t1);  // 42

// TÃ¢che qui Ã©choue
let t2 = spawn(risky_operation, 1);
try {
    let result2 = join(t2);
} catch (e) {
    print("InterceptÃ©:", e);  // "InterceptÃ©: La tÃ¢che a Ã©chouÃ© !"
}
```

### Gestion de plusieurs tÃ¢ches

```hemlock
async fn work(id: i32, should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "TÃ¢che " + typeof(id) + " a Ã©chouÃ©";
    }
    return id * 10;
}

let t1 = spawn(work, 1, 0);
let t2 = spawn(work, 2, 1);  // Va Ã©chouer
let t3 = spawn(work, 3, 0);

// Joindre avec gestion des erreurs
try {
    let r1 = join(t1);  // OK
    print("TÃ¢che 1:", r1);

    let r2 = join(t2);  // LÃ¨ve une exception
    print("TÃ¢che 2:", r2);  // Jamais atteint
} catch (e) {
    print("Erreur:", e);  // "Erreur: TÃ¢che 2 a Ã©chouÃ©"
}

// Peut toujours joindre la tÃ¢che restante
let r3 = join(t3);
print("TÃ¢che 3:", r3);
```

---

## CaractÃ©ristiques de performance

### VÃ©ritable parallÃ©lisme

```hemlock
async fn cpu_intensive(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// ExÃ©cution sÃ©quentielle
let start = get_time();
let r1 = cpu_intensive(10000000);
let r2 = cpu_intensive(10000000);
let sequential_time = get_time() - start;

// ExÃ©cution parallÃ¨le
let start2 = get_time();
let t1 = spawn(cpu_intensive, 10000000);
let t2 = spawn(cpu_intensive, 10000000);
join(t1);
join(t2);
let parallel_time = get_time() - start2;

// parallel_time devrait Ãªtre ~50% de sequential_time sur les systÃ¨mes multi-cÅ“urs
```

**CaractÃ©ristiques prouvÃ©es :**
- N tÃ¢ches peuvent utiliser N cÅ“urs CPU simultanÃ©ment
- Les tests de stress montrent 8-9x le temps CPU vs temps rÃ©el (preuve de parallÃ©lisme)
- Surcharge de thread : ~8 Ko de pile + surcharge pthread par tÃ¢che
- Les opÃ©rations bloquantes dans une tÃ¢che ne bloquent pas les autres

---

## DÃ©tails d'implÃ©mentation

### ModÃ¨le de threading

- **Threading 1:1** - Chaque tÃ¢che = 1 thread OS (`pthread`)
- **OrdonnancÃ© par le noyau** - Le noyau OS distribue les threads sur les cÅ“urs
- **MultitÃ¢che prÃ©emptif** - L'OS peut interrompre et changer de thread
- **Pas de GIL** - Pas de Global Interpreter Lock (contrairement Ã  Python)

### Synchronisation

- **Mutex** - Les canaux utilisent `pthread_mutex_t`
- **Variables de condition** - send/recv bloquants utilisent `pthread_cond_t`
- **OpÃ©rations lock-free** - Les transitions d'Ã©tat des tÃ¢ches sont atomiques

### MÃ©moire et nettoyage

- **TÃ¢ches jointes** - Automatiquement nettoyÃ©es aprÃ¨s `join()`
- **TÃ¢ches dÃ©tachÃ©es** - Automatiquement nettoyÃ©es quand la tÃ¢che se termine
- **Canaux** - ComptÃ©s par rÃ©fÃ©rences, libÃ©rÃ©s quand plus utilisÃ©s

---

## Limitations

- Pas de `select()` pour le multiplexage de plusieurs canaux
- Pas d'ordonnanceur work-stealing (1 thread par tÃ¢che)
- Pas d'intÃ©gration d'E/S async (les opÃ©rations fichier/rÃ©seau bloquent)
- CapacitÃ© du canal fixÃ©e Ã  la crÃ©ation

---

## RÃ©sumÃ© complet de l'API

### Fonctions

| Fonction  | Signature                         | Retourne  | Description                          |
|-----------|-----------------------------------|-----------|--------------------------------------|
| `spawn`   | `(async_fn: function, ...args)`   | `task`    | CrÃ©er et dÃ©marrer une tÃ¢che concurrente |
| `join`    | `(task: task)`                    | `any`     | Attendre la tÃ¢che, obtenir le rÃ©sultat |
| `detach`  | `(task: task)`                    | `null`    | DÃ©tacher la tÃ¢che (fire-and-forget)  |
| `channel` | `(capacity: i32)`                 | `channel` | CrÃ©er un canal thread-safe           |

### MÃ©thodes des canaux

| MÃ©thode | Signature       | Retourne | Description                           |
|---------|-----------------|----------|---------------------------------------|
| `send`  | `(value: any)`  | `null`   | Envoyer valeur (bloque si plein)      |
| `recv`  | `()`            | `any`    | Recevoir valeur (bloque si vide)      |
| `close` | `()`            | `null`   | Fermer le canal                       |

### Types

| Type      | Description                          |
|-----------|--------------------------------------|
| `task`    | Handle pour tÃ¢che concurrente        |
| `channel` | Canal de communication thread-safe   |

---

## Bonnes pratiques

### Ã€ faire

âœ… Utiliser les canaux pour la communication entre tÃ¢ches
âœ… GÃ©rer les exceptions des tÃ¢ches jointes
âœ… Fermer les canaux quand l'envoi est terminÃ©
âœ… Utiliser `join()` pour obtenir les rÃ©sultats et nettoyer
âœ… Ne lancer que des fonctions async

### Ã€ Ã©viter

âŒ Ne pas partager d'Ã©tat mutable sans synchronisation
âŒ Ne pas joindre la mÃªme tÃ¢che deux fois
âŒ Ne pas envoyer sur des canaux fermÃ©s
âŒ Ne pas lancer de fonctions non-async
âŒ Ne pas oublier de joindre les tÃ¢ches (sauf si dÃ©tachÃ©es)

---

## Voir aussi

- [Fonctions intÃ©grÃ©es](#reference-builtins) - `spawn()`, `join()`, `detach()`, `channel()`
- [SystÃ¨me de types](#reference-type-system) - Types task et channel


--------------------------------------------------------------------------------
## API des ChaÃ®nes
--------------------------------------------------------------------------------

# RÃ©fÃ©rence de l'API String

RÃ©fÃ©rence complÃ¨te pour le type string de Hemlock et ses 19 mÃ©thodes.

---

## AperÃ§u

Les chaÃ®nes de caractÃ¨res (strings) dans Hemlock sont des sÃ©quences **encodÃ©es en UTF-8, mutables, allouÃ©es sur le tas** avec support complet d'Unicode. Toutes les opÃ©rations fonctionnent avec des **points de code** (caractÃ¨res), pas des octets.

**CaractÃ©ristiques principales :**
- Encodage UTF-8 (U+0000 Ã  U+10FFFF)
- Mutables (peuvent modifier les caractÃ¨res sur place)
- Indexation basÃ©e sur les points de code
- 19 mÃ©thodes intÃ©grÃ©es
- ConcatÃ©nation automatique avec l'opÃ©rateur `+`

---

## Type String

**Type :** `string`

**PropriÃ©tÃ©s :**
- `.length` - Nombre de points de code (caractÃ¨res)
- `.byte_length` - Nombre d'octets UTF-8

**Syntaxe littÃ©rale :** Guillemets doubles `"texte"`

**Exemples :**
```hemlock
let s = "hello";
print(s.length);        // 5 (points de code)
print(s.byte_length);   // 5 (octets)

let emoji = "ðŸš€";
print(emoji.length);        // 1 (un point de code)
print(emoji.byte_length);   // 4 (quatre octets UTF-8)
```

---

## Indexation

Les chaÃ®nes supportent l'indexation basÃ©e sur les points de code en utilisant `[]` :

**AccÃ¨s en lecture :**
```hemlock
let s = "hello";
let ch = s[0];          // Retourne le rune 'h'
```

**AccÃ¨s en Ã©criture :**
```hemlock
let s = "hello";
s[0] = 'H';             // Modifie avec un rune (maintenant "Hello")
```

**Exemple UTF-8 :**
```hemlock
let text = "HiðŸš€!";
print(text[0]);         // 'H'
print(text[1]);         // 'i'
print(text[2]);         // 'ðŸš€' (un point de code)
print(text[3]);         // '!'
```

---

## ConcatÃ©nation

Utilisez l'opÃ©rateur `+` pour concatÃ©ner des chaÃ®nes et des runes :

**String + String :**
```hemlock
let s = "hello" + " " + "world";  // "hello world"
let msg = "Count: " + typeof(42); // "Count: 42"
```

**String + Rune :**
```hemlock
let greeting = "Hello" + '!';      // "Hello!"
let decorated = "Text" + 'âœ“';      // "Textâœ“"
```

**Rune + String :**
```hemlock
let prefix = '>' + " Message";     // "> Message"
let bullet = 'â€¢' + " Item";        // "â€¢ Item"
```

**ConcatÃ©nations multiples :**
```hemlock
let msg = "Hi " + 'ðŸ‘‹' + " World " + 'ðŸŒ';  // "Hi ðŸ‘‹ World ðŸŒ"
```

---

## PropriÃ©tÃ©s des chaÃ®nes

### .length

Obtient le nombre de points de code Unicode (caractÃ¨res).

**Type :** `i32`

**Exemples :**
```hemlock
let s = "hello";
print(s.length);        // 5

let emoji = "ðŸš€";
print(emoji.length);    // 1 (un point de code)

let text = "Hello ðŸŒ!";
print(text.length);     // 8 (7 ASCII + 1 emoji)
```

---

### .byte_length

Obtient le nombre d'octets UTF-8.

**Type :** `i32`

**Exemples :**
```hemlock
let s = "hello";
print(s.byte_length);   // 5 (1 octet par caractÃ¨re ASCII)

let emoji = "ðŸš€";
print(emoji.byte_length); // 4 (l'emoji fait 4 octets UTF-8)

let text = "Hello ðŸŒ!";
print(text.byte_length);  // 11 (7 ASCII + 4 pour l'emoji)
```

---

## MÃ©thodes des chaÃ®nes

### Sous-chaÃ®ne et dÃ©coupage

#### substr

Extrait une sous-chaÃ®ne par position et longueur.

**Signature :**
```hemlock
string.substr(start: i32, length: i32): string
```

**ParamÃ¨tres :**
- `start` - Index du point de code de dÃ©part (base 0)
- `length` - Nombre de points de code Ã  extraire

**Retourne :** Nouvelle chaÃ®ne

**Exemples :**
```hemlock
let s = "hello world";
let sub = s.substr(6, 5);       // "world"
let first = s.substr(0, 5);     // "hello"

// Exemple UTF-8
let text = "HiðŸš€!";
let emoji = text.substr(2, 1);  // "ðŸš€"
```

---

#### slice

Extrait une sous-chaÃ®ne par plage (fin exclusive).

**Signature :**
```hemlock
string.slice(start: i32, end: i32): string
```

**ParamÃ¨tres :**
- `start` - Index du point de code de dÃ©part (base 0)
- `end` - Index du point de code de fin (exclusif)

**Retourne :** Nouvelle chaÃ®ne

**Exemples :**
```hemlock
let s = "hello world";
let sub = s.slice(0, 5);        // "hello"
let world = s.slice(6, 11);     // "world"

// Exemple UTF-8
let text = "HiðŸš€!";
let first_three = text.slice(0, 3);  // "HiðŸš€"
```

---

### Recherche

#### find

Trouve la premiÃ¨re occurrence d'une sous-chaÃ®ne.

**Signature :**
```hemlock
string.find(needle: string): i32
```

**ParamÃ¨tres :**
- `needle` - Sous-chaÃ®ne Ã  rechercher

**Retourne :** Index du point de code de la premiÃ¨re occurrence, ou `-1` si non trouvÃ©e

**Exemples :**
```hemlock
let s = "hello world";
let pos = s.find("world");      // 6
let pos2 = s.find("foo");       // -1 (non trouvÃ©e)
let pos3 = s.find("l");         // 2 (premier 'l')
```

---

#### contains

VÃ©rifie si la chaÃ®ne contient une sous-chaÃ®ne.

**Signature :**
```hemlock
string.contains(needle: string): bool
```

**ParamÃ¨tres :**
- `needle` - Sous-chaÃ®ne Ã  rechercher

**Retourne :** `true` si trouvÃ©e, `false` sinon

**Exemples :**
```hemlock
let s = "hello world";
let has = s.contains("world");  // true
let has2 = s.contains("foo");   // false
```

---

### SÃ©paration et jonction

#### split

SÃ©pare la chaÃ®ne en un tableau par dÃ©limiteur.

**Signature :**
```hemlock
string.split(delimiter: string): array
```

**ParamÃ¨tres :**
- `delimiter` - ChaÃ®ne sur laquelle sÃ©parer

**Retourne :** Tableau de chaÃ®nes

**Exemples :**
```hemlock
let csv = "a,b,c";
let parts = csv.split(",");     // ["a", "b", "c"]

let path = "/usr/local/bin";
let dirs = path.split("/");     // ["", "usr", "local", "bin"]

let text = "hello world foo";
let words = text.split(" ");    // ["hello", "world", "foo"]
```

---

#### trim

Supprime les espaces blancs au dÃ©but et Ã  la fin.

**Signature :**
```hemlock
string.trim(): string
```

**Retourne :** Nouvelle chaÃ®ne sans espaces blancs

**Exemples :**
```hemlock
let s = "  hello  ";
let clean = s.trim();           // "hello"

let text = "\n\t  world  \n";
let clean2 = text.trim();       // "world"
```

---

### Conversion de casse

#### to_upper

Convertit la chaÃ®ne en majuscules.

**Signature :**
```hemlock
string.to_upper(): string
```

**Retourne :** Nouvelle chaÃ®ne en majuscules

**Exemples :**
```hemlock
let s = "hello world";
let upper = s.to_upper();       // "HELLO WORLD"

let mixed = "HeLLo";
let upper2 = mixed.to_upper();  // "HELLO"
```

---

#### to_lower

Convertit la chaÃ®ne en minuscules.

**Signature :**
```hemlock
string.to_lower(): string
```

**Retourne :** Nouvelle chaÃ®ne en minuscules

**Exemples :**
```hemlock
let s = "HELLO WORLD";
let lower = s.to_lower();       // "hello world"

let mixed = "HeLLo";
let lower2 = mixed.to_lower();  // "hello"
```

---

### PrÃ©fixe et suffixe

#### starts_with

VÃ©rifie si la chaÃ®ne commence par un prÃ©fixe.

**Signature :**
```hemlock
string.starts_with(prefix: string): bool
```

**ParamÃ¨tres :**
- `prefix` - PrÃ©fixe Ã  vÃ©rifier

**Retourne :** `true` si la chaÃ®ne commence par le prÃ©fixe, `false` sinon

**Exemples :**
```hemlock
let s = "hello world";
let starts = s.starts_with("hello");  // true
let starts2 = s.starts_with("world"); // false
```

---

#### ends_with

VÃ©rifie si la chaÃ®ne se termine par un suffixe.

**Signature :**
```hemlock
string.ends_with(suffix: string): bool
```

**ParamÃ¨tres :**
- `suffix` - Suffixe Ã  vÃ©rifier

**Retourne :** `true` si la chaÃ®ne se termine par le suffixe, `false` sinon

**Exemples :**
```hemlock
let s = "hello world";
let ends = s.ends_with("world");      // true
let ends2 = s.ends_with("hello");     // false
```

---

### Remplacement

#### replace

Remplace la premiÃ¨re occurrence d'une sous-chaÃ®ne.

**Signature :**
```hemlock
string.replace(old: string, new: string): string
```

**ParamÃ¨tres :**
- `old` - Sous-chaÃ®ne Ã  remplacer
- `new` - ChaÃ®ne de remplacement

**Retourne :** Nouvelle chaÃ®ne avec la premiÃ¨re occurrence remplacÃ©e

**Exemples :**
```hemlock
let s = "hello world";
let s2 = s.replace("world", "there");  // "hello there"

let text = "foo foo foo";
let text2 = text.replace("foo", "bar"); // "bar foo foo" (seulement la premiÃ¨re)
```

---

#### replace_all

Remplace toutes les occurrences d'une sous-chaÃ®ne.

**Signature :**
```hemlock
string.replace_all(old: string, new: string): string
```

**ParamÃ¨tres :**
- `old` - Sous-chaÃ®ne Ã  remplacer
- `new` - ChaÃ®ne de remplacement

**Retourne :** Nouvelle chaÃ®ne avec toutes les occurrences remplacÃ©es

**Exemples :**
```hemlock
let text = "foo foo foo";
let text2 = text.replace_all("foo", "bar"); // "bar bar bar"

let s = "hello world hello";
let s2 = s.replace_all("hello", "hi");      // "hi world hi"
```

---

### RÃ©pÃ©tition

#### repeat

RÃ©pÃ¨te la chaÃ®ne n fois.

**Signature :**
```hemlock
string.repeat(count: i32): string
```

**ParamÃ¨tres :**
- `count` - Nombre de rÃ©pÃ©titions

**Retourne :** Nouvelle chaÃ®ne rÃ©pÃ©tÃ©e count fois

**Exemples :**
```hemlock
let s = "ha";
let repeated = s.repeat(3);     // "hahaha"

let line = "-";
let separator = line.repeat(40); // "----------------------------------------"
```

---

### AccÃ¨s aux caractÃ¨res

#### char_at

Obtient le point de code Unicode Ã  l'index.

**Signature :**
```hemlock
string.char_at(index: i32): rune
```

**ParamÃ¨tres :**
- `index` - Index du point de code (base 0)

**Retourne :** Rune (point de code Unicode)

**Exemples :**
```hemlock
let s = "hello";
let ch = s.char_at(0);          // 'h'
let ch2 = s.char_at(1);         // 'e'

// Exemple UTF-8
let emoji = "ðŸš€";
let ch3 = emoji.char_at(0);     // U+1F680 (fusÃ©e)
```

---

#### chars

Convertit la chaÃ®ne en tableau de runes.

**Signature :**
```hemlock
string.chars(): array
```

**Retourne :** Tableau de runes (points de code)

**Exemples :**
```hemlock
let s = "hello";
let chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']

// Exemple UTF-8
let text = "HiðŸš€!";
let chars2 = text.chars();      // ['H', 'i', 'ðŸš€', '!']
```

---

### AccÃ¨s aux octets

#### byte_at

Obtient la valeur de l'octet Ã  l'index.

**Signature :**
```hemlock
string.byte_at(index: i32): u8
```

**ParamÃ¨tres :**
- `index` - Index de l'octet (base 0, PAS l'index du point de code)

**Retourne :** Valeur de l'octet (u8)

**Exemples :**
```hemlock
let s = "hello";
let byte = s.byte_at(0);        // 104 (ASCII 'h')
let byte2 = s.byte_at(1);       // 101 (ASCII 'e')

// Exemple UTF-8
let emoji = "ðŸš€";
let byte3 = emoji.byte_at(0);   // 240 (premier octet UTF-8)
```

---

#### bytes

Convertit la chaÃ®ne en tableau d'octets.

**Signature :**
```hemlock
string.bytes(): array
```

**Retourne :** Tableau d'octets u8

**Exemples :**
```hemlock
let s = "hello";
let bytes = s.bytes();          // [104, 101, 108, 108, 111]

// Exemple UTF-8
let emoji = "ðŸš€";
let bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 octets UTF-8)
```

---

#### to_bytes

Convertit la chaÃ®ne en buffer.

**Signature :**
```hemlock
string.to_bytes(): buffer
```

**Retourne :** Buffer contenant les octets UTF-8

**Exemples :**
```hemlock
let s = "hello";
let buf = s.to_bytes();
print(buf.length);              // 5

// Exemple UTF-8
let emoji = "ðŸš€";
let buf2 = emoji.to_bytes();
print(buf2.length);             // 4
```

**Note :** Ceci est une mÃ©thode hÃ©ritÃ©e. PrÃ©fÃ©rez `.bytes()` pour la plupart des cas d'utilisation.

---

### DÃ©sÃ©rialisation JSON

#### deserialize

Parse une chaÃ®ne JSON en valeur.

**Signature :**
```hemlock
string.deserialize(): any
```

**Retourne :** Valeur parsÃ©e (objet, tableau, nombre, chaÃ®ne, bool ou null)

**Exemples :**
```hemlock
let json = '{"x":10,"y":20}';
let obj = json.deserialize();
print(obj.x);                   // 10
print(obj.y);                   // 20

let arr_json = '[1,2,3]';
let arr = arr_json.deserialize();
print(arr[0]);                  // 1

let num_json = '42';
let num = num_json.deserialize();
print(num);                     // 42
```

**Types supportÃ©s :**
- Objets : `{"key": value}`
- Tableaux : `[1, 2, 3]`
- Nombres : `42`, `3.14`
- ChaÃ®nes : `"text"`
- BoolÃ©ens : `true`, `false`
- Null : `null`

**Voir aussi :** MÃ©thode `.serialize()` des objets

---

## ChaÃ®nage de mÃ©thodes

Les mÃ©thodes de chaÃ®nes peuvent Ãªtre chaÃ®nÃ©es pour des opÃ©rations concises :

**Exemples :**
```hemlock
let result = "  Hello World  "
    .trim()
    .to_lower()
    .replace("world", "hemlock");  // "hello hemlock"

let processed = "foo,bar,baz"
    .split(",")
    .join(" | ");                  // "foo | bar | baz"

let cleaned = "  HELLO  "
    .trim()
    .to_lower();                   // "hello"
```

---

## RÃ©sumÃ© complet des mÃ©thodes

| MÃ©thode        | Signature                                    | Retourne  | Description                                |
|----------------|----------------------------------------------|-----------|-------------------------------------------|
| `substr`       | `(start: i32, length: i32)`                  | `string`  | Extraire sous-chaÃ®ne par position/longueur |
| `slice`        | `(start: i32, end: i32)`                     | `string`  | Extraire sous-chaÃ®ne par plage             |
| `find`         | `(needle: string)`                           | `i32`     | Trouver premiÃ¨re occurrence (-1 si non trouvÃ©e) |
| `contains`     | `(needle: string)`                           | `bool`    | VÃ©rifier si contient sous-chaÃ®ne           |
| `split`        | `(delimiter: string)`                        | `array`   | SÃ©parer en tableau                         |
| `trim`         | `()`                                         | `string`  | Supprimer espaces blancs                   |
| `to_upper`     | `()`                                         | `string`  | Convertir en majuscules                    |
| `to_lower`     | `()`                                         | `string`  | Convertir en minuscules                    |
| `starts_with`  | `(prefix: string)`                           | `bool`    | VÃ©rifier si commence par prÃ©fixe           |
| `ends_with`    | `(suffix: string)`                           | `bool`    | VÃ©rifier si termine par suffixe            |
| `replace`      | `(old: string, new: string)`                 | `string`  | Remplacer premiÃ¨re occurrence              |
| `replace_all`  | `(old: string, new: string)`                 | `string`  | Remplacer toutes les occurrences           |
| `repeat`       | `(count: i32)`                               | `string`  | RÃ©pÃ©ter chaÃ®ne n fois                      |
| `char_at`      | `(index: i32)`                               | `rune`    | Obtenir point de code Ã  l'index            |
| `byte_at`      | `(index: i32)`                               | `u8`      | Obtenir octet Ã  l'index                    |
| `chars`        | `()`                                         | `array`   | Convertir en tableau de runes              |
| `bytes`        | `()`                                         | `array`   | Convertir en tableau d'octets              |
| `to_bytes`     | `()`                                         | `buffer`  | Convertir en buffer (hÃ©ritÃ©)               |
| `deserialize`  | `()`                                         | `any`     | Parser chaÃ®ne JSON                         |

---

## Voir aussi

- [SystÃ¨me de types](#reference-type-system) - DÃ©tails sur le type string
- [API Array](#reference-array-api) - MÃ©thodes de tableau pour les rÃ©sultats de split()
- [OpÃ©rateurs](#reference-operators) - OpÃ©rateur de concatÃ©nation de chaÃ®nes


--------------------------------------------------------------------------------
## API des Fichiers
--------------------------------------------------------------------------------

# RÃ©fÃ©rence de l'API File

RÃ©fÃ©rence complÃ¨te pour le systÃ¨me d'entrÃ©e/sortie de fichiers de Hemlock.

---

## AperÃ§u

Hemlock fournit une **API objet File** pour les opÃ©rations sur les fichiers avec une gestion appropriÃ©e des erreurs et des ressources. Les fichiers doivent Ãªtre ouverts et fermÃ©s manuellement.

**CaractÃ©ristiques principales :**
- Objet file avec mÃ©thodes
- Lecture/Ã©criture de texte et donnÃ©es binaires
- Positionnement et recherche
- Messages d'erreur appropriÃ©s
- Gestion manuelle des ressources (pas de RAII)

---

## Type File

**Type :** `file`

**Description :** Handle de fichier pour les opÃ©rations d'E/S

**PropriÃ©tÃ©s (lecture seule) :**
- `.path` - Chemin du fichier (string)
- `.mode` - Mode d'ouverture (string)
- `.closed` - Si le fichier est fermÃ© (bool)

---

## Ouverture des fichiers

### open

Ouvre un fichier pour lecture, Ã©criture, ou les deux.

**Signature :**
```hemlock
open(path: string, mode?: string): file
```

**ParamÃ¨tres :**
- `path` - Chemin du fichier (relatif ou absolu)
- `mode` (optionnel) - Mode d'ouverture (par dÃ©faut : `"r"`)

**Retourne :** Objet file

**Modes :**
- `"r"` - Lecture (par dÃ©faut)
- `"w"` - Ã‰criture (tronque le fichier existant)
- `"a"` - Ajout
- `"r+"` - Lecture et Ã©criture
- `"w+"` - Lecture et Ã©criture (tronque)
- `"a+"` - Lecture et ajout

**Exemples :**
```hemlock
// Mode lecture (par dÃ©faut)
let f = open("data.txt");
let f_read = open("data.txt", "r");

// Mode Ã©criture (tronque)
let f_write = open("output.txt", "w");

// Mode ajout
let f_append = open("log.txt", "a");

// Mode lecture/Ã©criture
let f_rw = open("data.bin", "r+");

// Lecture/Ã©criture (tronque)
let f_rw_trunc = open("output.bin", "w+");

// Lecture/ajout
let f_ra = open("log.txt", "a+");
```

**Gestion des erreurs :**
```hemlock
try {
    let f = open("missing.txt", "r");
} catch (e) {
    print("Ã‰chec d'ouverture:", e);
    // Erreur: Ã‰chec d'ouverture de 'missing.txt': Fichier ou rÃ©pertoire inexistant
}
```

**Important :** Les fichiers doivent Ãªtre fermÃ©s manuellement avec `f.close()` pour Ã©viter les fuites de descripteurs de fichiers.

---

## MÃ©thodes File

### Lecture

#### read

Lit du texte depuis le fichier.

**Signature :**
```hemlock
file.read(size?: i32): string
```

**ParamÃ¨tres :**
- `size` (optionnel) - Nombre d'octets Ã  lire (si omis, lit jusqu'Ã  la fin du fichier)

**Retourne :** ChaÃ®ne avec le contenu du fichier

**Exemples :**
```hemlock
let f = open("data.txt", "r");

// Lire le fichier entier
let all = f.read();
print(all);

// Lire un nombre spÃ©cifique d'octets
let chunk = f.read(1024);

f.close();
```

**Comportement :**
- Lit depuis la position actuelle du fichier
- Retourne une chaÃ®ne vide Ã  la fin du fichier
- Avance la position du fichier

**Erreurs :**
- Lecture depuis un fichier fermÃ©
- Lecture depuis un fichier en Ã©criture seule

---

#### read_bytes

Lit des donnÃ©es binaires depuis le fichier.

**Signature :**
```hemlock
file.read_bytes(size: i32): buffer
```

**ParamÃ¨tres :**
- `size` - Nombre d'octets Ã  lire

**Retourne :** Buffer avec les donnÃ©es binaires

**Exemples :**
```hemlock
let f = open("data.bin", "r");

// Lire 256 octets
let binary = f.read_bytes(256);
print(binary.length);       // 256

// Traiter les donnÃ©es binaires
let i = 0;
while (i < binary.length) {
    print(binary[i]);
    i = i + 1;
}

f.close();
```

**Comportement :**
- Lit le nombre exact d'octets
- Retourne un buffer (pas une chaÃ®ne)
- Avance la position du fichier

---

### Ã‰criture

#### write

Ã‰crit du texte dans le fichier.

**Signature :**
```hemlock
file.write(data: string): i32
```

**ParamÃ¨tres :**
- `data` - ChaÃ®ne Ã  Ã©crire

**Retourne :** Nombre d'octets Ã©crits (i32)

**Exemples :**
```hemlock
let f = open("output.txt", "w");

// Ã‰crire du texte
let written = f.write("Hello, World!\n");
print("Ã‰crit", written, "octets");

// Ã‰critures multiples
f.write("Ligne 1\n");
f.write("Ligne 2\n");
f.write("Ligne 3\n");

f.close();
```

**Comportement :**
- Ã‰crit Ã  la position actuelle du fichier
- Retourne le nombre d'octets Ã©crits
- Avance la position du fichier

**Erreurs :**
- Ã‰criture dans un fichier fermÃ©
- Ã‰criture dans un fichier en lecture seule

---

#### write_bytes

Ã‰crit des donnÃ©es binaires dans le fichier.

**Signature :**
```hemlock
file.write_bytes(data: buffer): i32
```

**ParamÃ¨tres :**
- `data` - Buffer Ã  Ã©crire

**Retourne :** Nombre d'octets Ã©crits (i32)

**Exemples :**
```hemlock
let f = open("output.bin", "w");

// CrÃ©er un buffer
let buf = buffer(10);
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

// Ã‰crire le buffer
let written = f.write_bytes(buf);
print("Ã‰crit", written, "octets");

f.close();
```

**Comportement :**
- Ã‰crit le contenu du buffer dans le fichier
- Retourne le nombre d'octets Ã©crits
- Avance la position du fichier

---

### Positionnement

#### seek

DÃ©place la position du fichier Ã  un dÃ©calage d'octets spÃ©cifique.

**Signature :**
```hemlock
file.seek(position: i32): i32
```

**ParamÃ¨tres :**
- `position` - DÃ©calage en octets depuis le dÃ©but du fichier

**Retourne :** Nouvelle position du fichier (i32)

**Exemples :**
```hemlock
let f = open("data.txt", "r");

// Aller Ã  l'octet 100
f.seek(100);

// Lire depuis cette position
let chunk = f.read(50);

// Revenir au dÃ©but
f.seek(0);

// Lire depuis le dÃ©but
let all = f.read();

f.close();
```

**Comportement :**
- DÃ©finit la position du fichier au dÃ©calage absolu
- Retourne la nouvelle position
- Se positionner au-delÃ  de la fin du fichier est autorisÃ© (crÃ©e un trou dans le fichier lors de l'Ã©criture)

---

#### tell

Obtient la position actuelle du fichier.

**Signature :**
```hemlock
file.tell(): i32
```

**Retourne :** DÃ©calage actuel en octets depuis le dÃ©but du fichier (i32)

**Exemples :**
```hemlock
let f = open("data.txt", "r");

print(f.tell());        // 0 (au dÃ©but)

f.read(100);
print(f.tell());        // 100 (aprÃ¨s lecture)

f.seek(50);
print(f.tell());        // 50 (aprÃ¨s positionnement)

f.close();
```

---

### Fermeture

#### close

Ferme le fichier (idempotent).

**Signature :**
```hemlock
file.close(): null
```

**Retourne :** `null`

**Exemples :**
```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();

// SÃ»r d'appeler plusieurs fois
f.close();  // Pas d'erreur
f.close();  // Pas d'erreur
```

**Comportement :**
- Ferme le handle du fichier
- Vide les Ã©critures en attente
- Idempotent (sÃ»r d'appeler plusieurs fois)
- Met la propriÃ©tÃ© `.closed` Ã  `true`

**Important :** Fermez toujours les fichiers une fois terminÃ© pour Ã©viter les fuites de descripteurs de fichiers.

---

## PropriÃ©tÃ©s File

### .path

Obtient le chemin du fichier.

**Type :** `string`

**AccÃ¨s :** Lecture seule

**Exemples :**
```hemlock
let f = open("/path/to/file.txt", "r");
print(f.path);          // "/path/to/file.txt"
f.close();
```

---

### .mode

Obtient le mode d'ouverture.

**Type :** `string`

**AccÃ¨s :** Lecture seule

**Exemples :**
```hemlock
let f = open("data.txt", "r");
print(f.mode);          // "r"
f.close();

let f2 = open("output.txt", "w");
print(f2.mode);         // "w"
f2.close();
```

---

### .closed

VÃ©rifie si le fichier est fermÃ©.

**Type :** `bool`

**AccÃ¨s :** Lecture seule

**Exemples :**
```hemlock
let f = open("data.txt", "r");
print(f.closed);        // false

f.close();
print(f.closed);        // true
```

---

## Gestion des erreurs

Toutes les opÃ©rations sur les fichiers incluent des messages d'erreur appropriÃ©s avec contexte :

### Fichier non trouvÃ©
```hemlock
let f = open("missing.txt", "r");
// Erreur: Ã‰chec d'ouverture de 'missing.txt': Fichier ou rÃ©pertoire inexistant
```

### Lecture depuis un fichier fermÃ©
```hemlock
let f = open("data.txt", "r");
f.close();
f.read();
// Erreur: Impossible de lire depuis le fichier fermÃ© 'data.txt'
```

### Ã‰criture dans un fichier en lecture seule
```hemlock
let f = open("readonly.txt", "r");
f.write("data");
// Erreur: Impossible d'Ã©crire dans le fichier 'readonly.txt' ouvert en mode lecture seule
```

### Utilisation de try/catch
```hemlock
let f = null;
try {
    f = open("data.txt", "r");
    let content = f.read();
    print(content);
} catch (e) {
    print("Erreur fichier:", e);
} finally {
    if (f != null && !f.closed) {
        f.close();
    }
}
```

---

## ModÃ¨les de gestion des ressources

### ModÃ¨le basique

```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();
```

### Avec gestion des erreurs

```hemlock
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();  // Toujours fermer, mÃªme en cas d'erreur
}
```

### ModÃ¨le sÃ»r

```hemlock
let f = null;
try {
    f = open("data.txt", "r");
    let content = f.read();
    // ... traiter le contenu ...
} catch (e) {
    print("Erreur:", e);
} finally {
    if (f != null && !f.closed) {
        f.close();
    }
}
```

---

## Exemples d'utilisation

### Lire un fichier entier

```hemlock
fn read_file(filename: string): string {
    let f = open(filename, "r");
    let content = f.read();
    f.close();
    return content;
}

let text = read_file("data.txt");
print(text);
```

### Ã‰crire un fichier texte

```hemlock
fn write_file(filename: string, content: string) {
    let f = open(filename, "w");
    f.write(content);
    f.close();
}

write_file("output.txt", "Hello, World!\n");
```

### Ajouter Ã  un fichier

```hemlock
fn append_file(filename: string, line: string) {
    let f = open(filename, "a");
    f.write(line + "\n");
    f.close();
}

append_file("log.txt", "EntrÃ©e de log 1");
append_file("log.txt", "EntrÃ©e de log 2");
```

### Lire un fichier binaire

```hemlock
fn read_binary(filename: string, size: i32): buffer {
    let f = open(filename, "r");
    let data = f.read_bytes(size);
    f.close();
    return data;
}

let binary = read_binary("data.bin", 256);
print("Lu", binary.length, "octets");
```

### Ã‰crire un fichier binaire

```hemlock
fn write_binary(filename: string, data: buffer) {
    let f = open(filename, "w");
    f.write_bytes(data);
    f.close();
}

let buf = buffer(10);
buf[0] = 65;
write_binary("output.bin", buf);
```

### Lire un fichier ligne par ligne

```hemlock
fn read_lines(filename: string): array {
    let f = open(filename, "r");
    let content = f.read();
    f.close();
    return content.split("\n");
}

let lines = read_lines("data.txt");
let i = 0;
while (i < lines.length) {
    print("Ligne", i, ":", lines[i]);
    i = i + 1;
}
```

### Copier un fichier

```hemlock
fn copy_file(src: string, dest: string) {
    let f_in = open(src, "r");
    let f_out = open(dest, "w");

    let content = f_in.read();
    f_out.write(content);

    f_in.close();
    f_out.close();
}

copy_file("input.txt", "output.txt");
```

### Lire un fichier par morceaux

```hemlock
fn process_chunks(filename: string) {
    let f = open(filename, "r");

    while (true) {
        let chunk = f.read(1024);  // Lire 1 Ko Ã  la fois
        if (chunk.length == 0) {
            break;  // Fin du fichier
        }

        // Traiter le morceau
        print("Traitement de", chunk.length, "octets");
    }

    f.close();
}

process_chunks("large_file.txt");
```

---

## RÃ©sumÃ© complet des mÃ©thodes

| MÃ©thode       | Signature                | Retourne  | Description                    |
|---------------|--------------------------|-----------|--------------------------------|
| `read`        | `(size?: i32)`           | `string`  | Lire du texte                  |
| `read_bytes`  | `(size: i32)`            | `buffer`  | Lire des donnÃ©es binaires      |
| `write`       | `(data: string)`         | `i32`     | Ã‰crire du texte                |
| `write_bytes` | `(data: buffer)`         | `i32`     | Ã‰crire des donnÃ©es binaires    |
| `seek`        | `(position: i32)`        | `i32`     | DÃ©finir la position du fichier |
| `tell`        | `()`                     | `i32`     | Obtenir la position du fichier |
| `close`       | `()`                     | `null`    | Fermer le fichier (idempotent) |

---

## RÃ©sumÃ© complet des propriÃ©tÃ©s

| PropriÃ©tÃ© | Type     | AccÃ¨s          | Description                    |
|-----------|----------|----------------|--------------------------------|
| `.path`   | `string` | Lecture seule  | Chemin du fichier              |
| `.mode`   | `string` | Lecture seule  | Mode d'ouverture               |
| `.closed` | `bool`   | Lecture seule  | Si le fichier est fermÃ©        |

---

## Migration depuis l'ancienne API

**Ancienne API (supprimÃ©e) :**
- `read_file(path)` - Utilisez `open(path, "r").read()`
- `write_file(path, data)` - Utilisez `open(path, "w").write(data)`
- `append_file(path, data)` - Utilisez `open(path, "a").write(data)`
- `file_exists(path)` - Pas encore de remplacement

**Exemple de migration :**
```hemlock
// Ancien (v0.0)
let content = read_file("data.txt");
write_file("output.txt", content);

// Nouveau (v0.1)
let f = open("data.txt", "r");
let content = f.read();
f.close();

let f2 = open("output.txt", "w");
f2.write(content);
f2.close();
```

---

## Voir aussi

- [Fonctions intÃ©grÃ©es](#reference-builtins) - Fonction `open()`
- [API Memory](#reference-memory-api) - Type buffer
- [API String](#reference-string-api) - MÃ©thodes de chaÃ®ne pour le traitement de texte


--------------------------------------------------------------------------------
## API des Tableaux
--------------------------------------------------------------------------------

# RÃ©fÃ©rence de l'API Array

RÃ©fÃ©rence complÃ¨te pour le type array de Hemlock et ses 18 mÃ©thodes.

---

## AperÃ§u

Les tableaux (arrays) dans Hemlock sont des sÃ©quences **dynamiques, allouÃ©es sur le tas** qui peuvent contenir des types mixtes. Ils fournissent des mÃ©thodes complÃ¨tes pour la manipulation et le traitement des donnÃ©es.

**CaractÃ©ristiques principales :**
- Dimensionnement dynamique (croissance automatique)
- Indexation Ã  partir de zÃ©ro
- Types mixtes autorisÃ©s
- 18 mÃ©thodes intÃ©grÃ©es
- AllouÃ©s sur le tas avec suivi de la capacitÃ©

---

## Type Array

**Type :** `array`

**PropriÃ©tÃ©s :**
- `.length` - Nombre d'Ã©lÃ©ments (i32)

**Syntaxe littÃ©rale :** Crochets `[elem1, elem2, ...]`

**Exemples :**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);     // 5

// Types mixtes
let mixed = [1, "hello", true, null];
print(mixed.length);   // 4

// Tableau vide
let empty = [];
print(empty.length);   // 0
```

---

## Indexation

Les tableaux supportent l'indexation Ã  base zÃ©ro en utilisant `[]` :

**AccÃ¨s en lecture :**
```hemlock
let arr = [10, 20, 30];
print(arr[0]);         // 10
print(arr[1]);         // 20
print(arr[2]);         // 30
```

**AccÃ¨s en Ã©criture :**
```hemlock
let arr = [10, 20, 30];
arr[0] = 99;
arr[1] = 88;
print(arr);            // [99, 88, 30]
```

**Note :** L'indexation directe ne vÃ©rifie pas les limites. Utilisez les mÃ©thodes pour plus de sÃ©curitÃ©.

---

## PropriÃ©tÃ©s des tableaux

### .length

Obtient le nombre d'Ã©lÃ©ments dans le tableau.

**Type :** `i32`

**Exemples :**
```hemlock
let arr = [1, 2, 3];
print(arr.length);     // 3

let empty = [];
print(empty.length);   // 0

// La longueur change dynamiquement
arr.push(4);
print(arr.length);     // 4

arr.pop();
print(arr.length);     // 3
```

---

## MÃ©thodes des tableaux

### OpÃ©rations de pile (Stack)

#### push

Ajoute un Ã©lÃ©ment Ã  la fin du tableau.

**Signature :**
```hemlock
array.push(value: any): null
```

**ParamÃ¨tres :**
- `value` - Ã‰lÃ©ment Ã  ajouter

**Retourne :** `null`

**Modifie :** Oui (modifie le tableau sur place)

**Exemples :**
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]
arr.push("hello");     // [1, 2, 3, 4, 5, "hello"]
```

---

#### pop

Retire et retourne le dernier Ã©lÃ©ment.

**Signature :**
```hemlock
array.pop(): any
```

**Retourne :** Dernier Ã©lÃ©ment (retirÃ© du tableau)

**Modifie :** Oui (modifie le tableau sur place)

**Exemples :**
```hemlock
let arr = [1, 2, 3];
let last = arr.pop();  // 3
print(arr);            // [1, 2]

let last2 = arr.pop(); // 2
print(arr);            // [1]
```

**Erreur :** Erreur d'exÃ©cution si le tableau est vide.

---

### OpÃ©rations de file (Queue)

#### shift

Retire et retourne le premier Ã©lÃ©ment.

**Signature :**
```hemlock
array.shift(): any
```

**Retourne :** Premier Ã©lÃ©ment (retirÃ© du tableau)

**Modifie :** Oui (modifie le tableau sur place)

**Exemples :**
```hemlock
let arr = [1, 2, 3];
let first = arr.shift();  // 1
print(arr);               // [2, 3]

let first2 = arr.shift(); // 2
print(arr);               // [3]
```

**Erreur :** Erreur d'exÃ©cution si le tableau est vide.

---

#### unshift

Ajoute un Ã©lÃ©ment au dÃ©but du tableau.

**Signature :**
```hemlock
array.unshift(value: any): null
```

**ParamÃ¨tres :**
- `value` - Ã‰lÃ©ment Ã  ajouter

**Retourne :** `null`

**Modifie :** Oui (modifie le tableau sur place)

**Exemples :**
```hemlock
let arr = [2, 3];
arr.unshift(1);        // [1, 2, 3]
arr.unshift(0);        // [0, 1, 2, 3]
```

---

### Insertion et suppression

#### insert

InsÃ¨re un Ã©lÃ©ment Ã  un index spÃ©cifique.

**Signature :**
```hemlock
array.insert(index: i32, value: any): null
```

**ParamÃ¨tres :**
- `index` - Position d'insertion (base 0)
- `value` - Ã‰lÃ©ment Ã  insÃ©rer

**Retourne :** `null`

**Modifie :** Oui (modifie le tableau sur place)

**Exemples :**
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // [1, 2, 3, 4, 5]

let arr2 = [1, 3];
arr2.insert(1, 2);     // [1, 2, 3]

// Insertion Ã  la fin
arr2.insert(arr2.length, 4);  // [1, 2, 3, 4]
```

**Comportement :** DÃ©cale les Ã©lÃ©ments Ã  partir de l'index vers la droite.

---

#### remove

Retire et retourne l'Ã©lÃ©ment Ã  l'index spÃ©cifiÃ©.

**Signature :**
```hemlock
array.remove(index: i32): any
```

**ParamÃ¨tres :**
- `index` - Position de suppression (base 0)

**Retourne :** Ã‰lÃ©ment supprimÃ©

**Modifie :** Oui (modifie le tableau sur place)

**Exemples :**
```hemlock
let arr = [1, 2, 3, 4, 5];
let removed = arr.remove(0);  // 1
print(arr);                   // [2, 3, 4, 5]

let removed2 = arr.remove(2); // 4
print(arr);                   // [2, 3, 5]
```

**Comportement :** DÃ©cale les Ã©lÃ©ments aprÃ¨s l'index vers la gauche.

**Erreur :** Erreur d'exÃ©cution si l'index est hors limites.

---

### Recherche

#### find

Trouve la premiÃ¨re occurrence d'une valeur.

**Signature :**
```hemlock
array.find(value: any): i32
```

**ParamÃ¨tres :**
- `value` - Valeur Ã  rechercher

**Retourne :** Index de la premiÃ¨re occurrence, ou `-1` si non trouvÃ©e

**Exemples :**
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2
let idx2 = arr.find(99);     // -1 (non trouvÃ©e)

// Trouver le premier doublon
let arr2 = [1, 2, 3, 2, 4];
let idx3 = arr2.find(2);     // 1 (premiÃ¨re occurrence)
```

**Comparaison :** Utilise l'Ã©galitÃ© de valeur pour les primitives et les chaÃ®nes.

---

#### contains

VÃ©rifie si le tableau contient une valeur.

**Signature :**
```hemlock
array.contains(value: any): bool
```

**ParamÃ¨tres :**
- `value` - Valeur Ã  rechercher

**Retourne :** `true` si trouvÃ©e, `false` sinon

**Exemples :**
```hemlock
let arr = [10, 20, 30, 40];
let has = arr.contains(20);  // true
let has2 = arr.contains(99); // false

// Fonctionne avec les chaÃ®nes
let words = ["hello", "world"];
let has3 = words.contains("hello");  // true
```

---

### DÃ©coupage et extraction

#### slice

Extrait un sous-tableau par plage (fin exclusive).

**Signature :**
```hemlock
array.slice(start: i32, end: i32): array
```

**ParamÃ¨tres :**
- `start` - Index de dÃ©part (base 0, inclusif)
- `end` - Index de fin (exclusif)

**Retourne :** Nouveau tableau avec les Ã©lÃ©ments de [start, end)

**Modifie :** Non (retourne un nouveau tableau)

**Exemples :**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);   // [2, 3, 4]
let first_three = arr.slice(0, 3);  // [1, 2, 3]
let last_two = arr.slice(3, 5);     // [4, 5]

// Tranche vide
let empty = arr.slice(2, 2); // []
```

---

#### first

Obtient le premier Ã©lÃ©ment sans le retirer.

**Signature :**
```hemlock
array.first(): any
```

**Retourne :** Premier Ã©lÃ©ment

**Modifie :** Non

**Exemples :**
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1
print(arr);                  // [1, 2, 3] (inchangÃ©)
```

**Erreur :** Erreur d'exÃ©cution si le tableau est vide.

---

#### last

Obtient le dernier Ã©lÃ©ment sans le retirer.

**Signature :**
```hemlock
array.last(): any
```

**Retourne :** Dernier Ã©lÃ©ment

**Modifie :** Non

**Exemples :**
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3
print(arr);                  // [1, 2, 3] (inchangÃ©)
```

**Erreur :** Erreur d'exÃ©cution si le tableau est vide.

---

### Manipulation de tableaux

#### reverse

Inverse le tableau sur place.

**Signature :**
```hemlock
array.reverse(): null
```

**Retourne :** `null`

**Modifie :** Oui (modifie le tableau sur place)

**Exemples :**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]
print(arr);                  // [5, 4, 3, 2, 1]

let words = ["hello", "world"];
words.reverse();             // ["world", "hello"]
```

---

#### clear

Supprime tous les Ã©lÃ©ments du tableau.

**Signature :**
```hemlock
array.clear(): null
```

**Retourne :** `null`

**Modifie :** Oui (modifie le tableau sur place)

**Exemples :**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();
print(arr);                  // []
print(arr.length);           // 0
```

---

### Combinaison de tableaux

#### concat

ConcatÃ¨ne avec un autre tableau.

**Signature :**
```hemlock
array.concat(other: array): array
```

**ParamÃ¨tres :**
- `other` - Tableau Ã  concatÃ©ner

**Retourne :** Nouveau tableau avec les Ã©lÃ©ments des deux tableaux

**Modifie :** Non (retourne un nouveau tableau)

**Exemples :**
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]
print(a);                    // [1, 2, 3] (inchangÃ©)
print(b);                    // [4, 5, 6] (inchangÃ©)

// EnchaÃ®ner les concatÃ©nations
let c = [7, 8];
let all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]
```

---

### OpÃ©rations fonctionnelles

#### map

Transforme chaque Ã©lÃ©ment en utilisant une fonction de rappel (callback).

**Signature :**
```hemlock
array.map(callback: fn): array
```

**ParamÃ¨tres :**
- `callback` - Fonction qui prend un Ã©lÃ©ment et retourne une valeur transformÃ©e

**Retourne :** Nouveau tableau avec les Ã©lÃ©ments transformÃ©s

**Modifie :** Non (retourne un nouveau tableau)

**Exemples :**
```hemlock
let arr = [1, 2, 3, 4, 5];
let doubled = arr.map(fn(x) { return x * 2; });
print(doubled);  // [2, 4, 6, 8, 10]

let names = ["alice", "bob"];
let upper = names.map(fn(s) { return s.to_upper(); });
print(upper);  // ["ALICE", "BOB"]
```

---

#### filter

SÃ©lectionne les Ã©lÃ©ments qui correspondent Ã  un prÃ©dicat.

**Signature :**
```hemlock
array.filter(predicate: fn): array
```

**ParamÃ¨tres :**
- `predicate` - Fonction qui prend un Ã©lÃ©ment et retourne bool

**Retourne :** Nouveau tableau avec les Ã©lÃ©ments oÃ¹ le prÃ©dicat a retournÃ© true

**Modifie :** Non (retourne un nouveau tableau)

**Exemples :**
```hemlock
let arr = [1, 2, 3, 4, 5, 6];
let evens = arr.filter(fn(x) { return x % 2 == 0; });
print(evens);  // [2, 4, 6]

let words = ["hello", "hi", "hey", "goodbye"];
let short = words.filter(fn(s) { return s.length < 4; });
print(short);  // ["hi", "hey"]
```

---

#### reduce

RÃ©duit le tableau Ã  une seule valeur en utilisant un accumulateur.

**Signature :**
```hemlock
array.reduce(callback: fn, initial: any): any
```

**ParamÃ¨tres :**
- `callback` - Fonction qui prend (accumulateur, Ã©lÃ©ment) et retourne le nouvel accumulateur
- `initial` - Valeur de dÃ©part pour l'accumulateur

**Retourne :** Valeur finale accumulÃ©e

**Modifie :** Non

**Exemples :**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sum = arr.reduce(fn(acc, x) { return acc + x; }, 0);
print(sum);  // 15

let product = arr.reduce(fn(acc, x) { return acc * x; }, 1);
print(product);  // 120

// Trouver la valeur maximale
let max = arr.reduce(fn(acc, x) {
    if (x > acc) { return x; }
    return acc;
}, arr[0]);
print(max);  // 5
```

---

### Conversion en chaÃ®ne

#### join

Joint les Ã©lÃ©ments en une chaÃ®ne avec un dÃ©limiteur.

**Signature :**
```hemlock
array.join(delimiter: string): string
```

**ParamÃ¨tres :**
- `delimiter` - ChaÃ®ne Ã  placer entre les Ã©lÃ©ments

**Retourne :** ChaÃ®ne avec tous les Ã©lÃ©ments joints

**Exemples :**
```hemlock
let words = ["hello", "world", "foo"];
let joined = words.join(" ");  // "hello world foo"

let numbers = [1, 2, 3];
let csv = numbers.join(",");   // "1,2,3"

// Fonctionne avec les types mixtes
let mixed = [1, "hello", true, null];
print(mixed.join(" | "));  // "1 | hello | true | null"

// DÃ©limiteur vide
let arr = ["a", "b", "c"];
let s = arr.join("");          // "abc"
```

**Comportement :** Convertit automatiquement tous les Ã©lÃ©ments en chaÃ®nes.

---

## ChaÃ®nage de mÃ©thodes

Les mÃ©thodes de tableaux peuvent Ãªtre chaÃ®nÃ©es pour des opÃ©rations concises :

**Exemples :**
```hemlock
// ChaÃ®ner slice et join
let result = ["apple", "banana", "cherry", "date"]
    .slice(0, 2)
    .join(" and ");  // "apple and banana"

// ChaÃ®ner concat et slice
let combined = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);    // [3, 4, 5]

// ChaÃ®nage complexe
let words = ["hello", "world", "foo", "bar"];
let result2 = words
    .slice(0, 3)
    .concat(["baz"])
    .join("-");      // "hello-world-foo-baz"
```

---

## RÃ©sumÃ© complet des mÃ©thodes

### MÃ©thodes modifiantes

MÃ©thodes qui modifient le tableau sur place :

| MÃ©thode    | Signature                    | Retourne  | Description                         |
|------------|------------------------------|-----------|-------------------------------------|
| `push`     | `(value: any)`               | `null`    | Ajouter Ã  la fin                    |
| `pop`      | `()`                         | `any`     | Retirer de la fin                   |
| `shift`    | `()`                         | `any`     | Retirer du dÃ©but                    |
| `unshift`  | `(value: any)`               | `null`    | Ajouter au dÃ©but                    |
| `insert`   | `(index: i32, value: any)`   | `null`    | InsÃ©rer Ã  l'index                   |
| `remove`   | `(index: i32)`               | `any`     | Retirer Ã  l'index                   |
| `reverse`  | `()`                         | `null`    | Inverser sur place                  |
| `clear`    | `()`                         | `null`    | Supprimer tous les Ã©lÃ©ments         |

### MÃ©thodes non modifiantes

MÃ©thodes qui retournent de nouvelles valeurs sans modifier l'original :

| MÃ©thode    | Signature                        | Retourne  | Description                         |
|------------|----------------------------------|-----------|-------------------------------------|
| `find`     | `(value: any)`                   | `i32`     | Trouver la premiÃ¨re occurrence      |
| `contains` | `(value: any)`                   | `bool`    | VÃ©rifier si contient la valeur      |
| `slice`    | `(start: i32, end: i32)`         | `array`   | Extraire un sous-tableau            |
| `first`    | `()`                             | `any`     | Obtenir le premier Ã©lÃ©ment          |
| `last`     | `()`                             | `any`     | Obtenir le dernier Ã©lÃ©ment          |
| `concat`   | `(other: array)`                 | `array`   | ConcatÃ©ner les tableaux             |
| `join`     | `(delimiter: string)`            | `string`  | Joindre les Ã©lÃ©ments en chaÃ®ne      |
| `map`      | `(callback: fn)`                 | `array`   | Transformer chaque Ã©lÃ©ment          |
| `filter`   | `(predicate: fn)`                | `array`   | SÃ©lectionner les Ã©lÃ©ments correspondants |
| `reduce`   | `(callback: fn, initial: any)`   | `any`     | RÃ©duire Ã  une seule valeur          |

---

## ModÃ¨les d'utilisation

### Utilisation comme pile (Stack)

```hemlock
let stack = [];

// Empiler des Ã©lÃ©ments
stack.push(1);
stack.push(2);
stack.push(3);

// DÃ©piler des Ã©lÃ©ments
while (stack.length > 0) {
    let item = stack.pop();
    print(item);  // 3, 2, 1
}
```

### Utilisation comme file (Queue)

```hemlock
let queue = [];

// Enfiler
queue.push(1);
queue.push(2);
queue.push(3);

// DÃ©filer
while (queue.length > 0) {
    let item = queue.shift();
    print(item);  // 1, 2, 3
}
```

### Transformation de tableau

```hemlock
// Filtrage (manuel)
let numbers = [1, 2, 3, 4, 5, 6];
let evens = [];
let i = 0;
while (i < numbers.length) {
    if (numbers[i] % 2 == 0) {
        evens.push(numbers[i]);
    }
    i = i + 1;
}

// Mapping (manuel)
let numbers2 = [1, 2, 3, 4, 5];
let doubled = [];
let j = 0;
while (j < numbers2.length) {
    doubled.push(numbers2[j] * 2);
    j = j + 1;
}
```

### Construction de tableaux

```hemlock
let arr = [];

// Construire un tableau avec une boucle
let i = 0;
while (i < 10) {
    arr.push(i * 10);
    i = i + 1;
}

print(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
```

---

## DÃ©tails d'implÃ©mentation

**Gestion de la capacitÃ© :**
- Les tableaux grandissent automatiquement selon les besoins
- La capacitÃ© double lorsqu'elle est dÃ©passÃ©e
- Pas de contrÃ´le manuel de la capacitÃ©

**Comparaison de valeurs :**
- `find()` et `contains()` utilisent l'Ã©galitÃ© de valeur
- Fonctionne correctement pour les primitives et les chaÃ®nes
- Les objets/tableaux sont comparÃ©s par rÃ©fÃ©rence

**MÃ©moire :**
- AllouÃ©s sur le tas
- Pas de libÃ©ration automatique (gestion manuelle de la mÃ©moire)
- Pas de vÃ©rification des limites sur l'accÃ¨s direct par index

---

## Voir aussi

- [SystÃ¨me de types](#reference-type-system) - DÃ©tails sur le type array
- [API String](#reference-string-api) - RÃ©sultats de join() sur les chaÃ®nes
- [OpÃ©rateurs](#reference-operators) - OpÃ©rateur d'indexation des tableaux


--------------------------------------------------------------------------------
## Fonctions IntÃ©grÃ©es
--------------------------------------------------------------------------------

# RÃ©fÃ©rence des fonctions intÃ©grÃ©es

RÃ©fÃ©rence complÃ¨te pour toutes les fonctions et constantes intÃ©grÃ©es dans Hemlock.

---

## AperÃ§u

Hemlock fournit un ensemble de fonctions intÃ©grÃ©es pour les E/S, l'introspection de types, la gestion de la mÃ©moire, la concurrence et l'interaction systÃ¨me. Toutes les fonctions intÃ©grÃ©es sont disponibles globalement sans imports.

---

## Fonctions d'E/S

### print

Affiche des valeurs sur stdout avec un saut de ligne.

**Signature :**
```hemlock
print(...values): null
```

**ParamÃ¨tres :**
- `...values` - N'importe quel nombre de valeurs Ã  afficher

**Retourne :** `null`

**Exemples :**
```hemlock
print("Hello, World!");
print(42);
print(3.14);
print(true);
print([1, 2, 3]);
print({ x: 10, y: 20 });

// Plusieurs valeurs
print("x =", 10, "y =", 20);
```

**Comportement :**
- Convertit toutes les valeurs en chaÃ®nes
- SÃ©pare les valeurs multiples par des espaces
- Ajoute un saut de ligne Ã  la fin
- Vide stdout

---

### read_line

Lit une ligne de texte depuis stdin (entrÃ©e utilisateur).

**Signature :**
```hemlock
read_line(): string | null
```

**ParamÃ¨tres :** Aucun

**Retourne :**
- `string` - La ligne lue depuis stdin (saut de ligne supprimÃ©)
- `null` - En fin de fichier/entrÃ©e (EOF)

**Exemples :**
```hemlock
// Invite simple
print("Quel est votre nom ?");
let name = read_line();
print("Bonjour, " + name + "!");

// Lecture de nombres (nÃ©cessite un parsing manuel)
print("Entrez un nombre:");
let input = read_line();
let num = parse_int(input);  // Voir ci-dessous pour parse_int
print("Double:", num * 2);

// GÃ©rer EOF
let line = read_line();
if (line == null) {
    print("Fin de l'entrÃ©e");
}

// Lire plusieurs lignes
print("Entrez des lignes (Ctrl+D pour arrÃªter):");
while (true) {
    let line = read_line();
    if (line == null) {
        break;
    }
    print("Vous avez dit:", line);
}
```

**Comportement :**
- Bloque jusqu'Ã  ce que l'utilisateur appuie sur EntrÃ©e
- Supprime le saut de ligne final (`\n`) et le retour chariot (`\r`)
- Retourne `null` en EOF (Ctrl+D sur Unix, Ctrl+Z sur Windows)
- Lit depuis stdin uniquement (pas depuis les fichiers)

**Parsing de l'entrÃ©e utilisateur :**

Comme `read_line()` retourne toujours une chaÃ®ne, vous devez parser l'entrÃ©e numÃ©rique manuellement :

```hemlock
// Parseur d'entiers simple
fn parse_int(s: string): i32 {
    let result: i32 = 0;
    let negative = false;
    let i = 0;

    if (s.length > 0 && s.char_at(0) == '-') {
        negative = true;
        i = 1;
    }

    while (i < s.length) {
        let c = s.char_at(i);
        let code: i32 = c;
        if (code >= 48 && code <= 57) {
            result = result * 10 + (code - 48);
        } else {
            break;
        }
        i = i + 1;
    }

    if (negative) {
        return -result;
    }
    return result;
}

// Utilisation
print("Entrez votre Ã¢ge:");
let age = parse_int(read_line());
print("Dans 10 ans vous aurez", age + 10);
```

**Voir aussi :** [API File](#reference-file-api) pour la lecture depuis les fichiers

---

### eprint

Affiche une valeur sur stderr avec un saut de ligne.

**Signature :**
```hemlock
eprint(value: any): null
```

**ParamÃ¨tres :**
- `value` - Une seule valeur Ã  afficher sur stderr

**Retourne :** `null`

**Exemples :**
```hemlock
eprint("Erreur: fichier non trouvÃ©");
eprint(404);
eprint("Avertissement: " + message);

// ModÃ¨le typique de gestion d'erreur
fn load_config(path: string) {
    if (!exists(path)) {
        eprint("Erreur: fichier de configuration non trouvÃ©: " + path);
        return null;
    }
    // ...
}
```

**Comportement :**
- Affiche sur stderr (flux d'erreur standard)
- Ajoute un saut de ligne Ã  la fin
- N'accepte qu'un seul argument (contrairement Ã  `print`)
- Utile pour les messages d'erreur qui ne doivent pas se mÃ©langer avec la sortie normale

**DiffÃ©rence avec print :**
- `print()` â†’ stdout (sortie normale, peut Ãªtre redirigÃ©e avec `>`)
- `eprint()` â†’ stderr (sortie d'erreur, peut Ãªtre redirigÃ©e avec `2>`)

```bash
# Exemple shell: sÃ©parer stdout et stderr
./hemlock script.hml > output.txt 2> errors.txt
```

---

## Introspection de types

### typeof

Obtient le nom du type d'une valeur.

**Signature :**
```hemlock
typeof(value: any): string
```

**ParamÃ¨tres :**
- `value` - N'importe quelle valeur

**Retourne :** Nom du type sous forme de chaÃ®ne

**Exemples :**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("hello"));         // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof(null));            // "null"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"

// Objets typÃ©s
define Person { name: string }
let p: Person = { name: "Alice" };
print(typeof(p));               // "Person"

// Autres types
print(typeof(alloc(10)));       // "ptr"
print(typeof(buffer(10)));      // "buffer"
print(typeof(open("file.txt"))); // "file"
```

**Noms de types :**
- Primitifs : `"i8"`, `"i16"`, `"i32"`, `"i64"`, `"u8"`, `"u16"`, `"u32"`, `"u64"`, `"f32"`, `"f64"`, `"bool"`, `"string"`, `"rune"`, `"null"`
- Composites : `"array"`, `"object"`, `"ptr"`, `"buffer"`, `"function"`
- SpÃ©ciaux : `"file"`, `"task"`, `"channel"`
- PersonnalisÃ©s : Noms de types dÃ©finis par l'utilisateur avec `define`

**Voir aussi :** [SystÃ¨me de types](#reference-type-system)

---

## ExÃ©cution de commandes

### exec

ExÃ©cute une commande shell et capture la sortie.

**Signature :**
```hemlock
exec(command: string): object
```

**ParamÃ¨tres :**
- `command` - Commande shell Ã  exÃ©cuter

**Retourne :** Objet avec les champs :
- `output` (string) - stdout de la commande
- `exit_code` (i32) - Code de statut de sortie (0 = succÃ¨s)

**Exemples :**
```hemlock
let result = exec("echo hello");
print(result.output);      // "hello\n"
print(result.exit_code);   // 0

// VÃ©rifier le statut de sortie
let r = exec("grep pattern file.txt");
if (r.exit_code == 0) {
    print("TrouvÃ©:", r.output);
} else {
    print("Motif non trouvÃ©");
}

// Traiter une sortie multi-lignes
let r2 = exec("ls -la");
let lines = r2.output.split("\n");
```

**Comportement :**
- ExÃ©cute la commande via `/bin/sh`
- Capture stdout uniquement (stderr va au terminal)
- Bloque jusqu'Ã  ce que la commande se termine
- Retourne une chaÃ®ne vide s'il n'y a pas de sortie

**Gestion des erreurs :**
```hemlock
try {
    let r = exec("nonexistent_command");
} catch (e) {
    print("Ã‰chec d'exÃ©cution:", e);
}
```

**Avertissement de sÃ©curitÃ© :** âš ï¸ VulnÃ©rable Ã  l'injection shell. Toujours valider/assainir l'entrÃ©e utilisateur.

**Limitations :**
- Pas de capture de stderr
- Pas de streaming
- Pas de timeout
- Pas de gestion des signaux

---

### exec_argv

ExÃ©cute une commande avec un tableau d'arguments explicite (pas d'interprÃ©tation shell).

**Signature :**
```hemlock
exec_argv(argv: array): object
```

**ParamÃ¨tres :**
- `argv` - Tableau de chaÃ®nes : `[commande, arg1, arg2, ...]`

**Retourne :** Objet avec les champs :
- `output` (string) - stdout de la commande
- `exit_code` (i32) - Code de statut de sortie (0 = succÃ¨s)

**Exemples :**
```hemlock
// Commande simple
let result = exec_argv(["ls", "-la"]);
print(result.output);

// Commande avec arguments contenant des espaces (sÃ»r !)
let r = exec_argv(["grep", "hello world", "file.txt"]);

// ExÃ©cuter un script avec arguments
let r2 = exec_argv(["python", "script.py", "--input", "data.json"]);
print(r2.exit_code);
```

**DiffÃ©rence avec exec :**
```hemlock
// exec() utilise le shell - NON SÃ›R avec l'entrÃ©e utilisateur
exec("ls " + user_input);  // Risque d'injection shell !

// exec_argv() contourne le shell - SÃ›R
exec_argv(["ls", user_input]);  // Pas d'injection possible
```

**Quand utiliser :**
- Quand les arguments contiennent des espaces, guillemets ou caractÃ¨res spÃ©ciaux
- Lors du traitement de l'entrÃ©e utilisateur (sÃ©curitÃ©)
- Quand vous avez besoin d'un parsing d'arguments prÃ©visible

**Voir aussi :** `exec()` pour les commandes shell simples

---

## Gestion des erreurs

### throw

LÃ¨ve une exception.

**Signature :**
```hemlock
throw expression
```

**ParamÃ¨tres :**
- `expression` - Valeur Ã  lever (n'importe quel type)

**Retourne :** Ne retourne jamais (transfÃ¨re le contrÃ´le)

**Exemples :**
```hemlock
throw "message d'erreur";
throw 404;
throw { code: 500, message: "Erreur interne" };
throw null;
```

**Voir aussi :** instructions try/catch/finally

---

### panic

Termine immÃ©diatement le programme avec un message d'erreur (irrÃ©cupÃ©rable).

**Signature :**
```hemlock
panic(message?: any): never
```

**ParamÃ¨tres :**
- `message` (optionnel) - Message d'erreur Ã  afficher

**Retourne :** Ne retourne jamais (le programme se termine)

**Exemples :**
```hemlock
panic();                          // Par dÃ©faut: "panic!"
panic("code inaccessible atteint");
panic(42);

// Cas d'utilisation courant
fn process_state(state: i32): string {
    if (state == 1) { return "prÃªt"; }
    if (state == 2) { return "en cours"; }
    panic("Ã©tat invalide: " + typeof(state));
}
```

**Comportement :**
- Affiche l'erreur sur stderr : `panic: <message>`
- Quitte avec le code 1
- **NON rattrapable** avec try/catch
- Utiliser pour les bugs et erreurs irrÃ©cupÃ©rables

**Panic vs Throw :**
- `panic()` - Erreur irrÃ©cupÃ©rable, quitte immÃ©diatement
- `throw` - Erreur rÃ©cupÃ©rable, peut Ãªtre rattrapÃ©e

---

### assert

Affirme qu'une condition est vraie, ou termine avec un message d'erreur.

**Signature :**
```hemlock
assert(condition: any, message?: string): null
```

**ParamÃ¨tres :**
- `condition` - Valeur Ã  vÃ©rifier pour la vÃ©racitÃ©
- `message` (optionnel) - Message d'erreur personnalisÃ© si l'assertion Ã©choue

**Retourne :** `null` (si l'assertion rÃ©ussit)

**Exemples :**
```hemlock
// Assertions basiques
assert(x > 0);
assert(name != null);
assert(arr.length > 0, "Le tableau ne doit pas Ãªtre vide");

// Avec messages personnalisÃ©s
fn divide(a: i32, b: i32): f64 {
    assert(b != 0, "Division par zÃ©ro");
    return a / b;
}

// Valider les arguments de fonction
fn process_data(data: array) {
    assert(data != null, "data ne peut pas Ãªtre null");
    assert(data.length > 0, "data ne peut pas Ãªtre vide");
    // ...
}
```

**Comportement :**
- Si la condition est vraie : retourne `null`, l'exÃ©cution continue
- Si la condition est fausse : affiche l'erreur et quitte avec le code 1
- Valeurs fausses : `false`, `0`, `0.0`, `null`, `""` (chaÃ®ne vide)
- Valeurs vraies : tout le reste

**Sortie en cas d'Ã©chec :**
```
Assertion failed: Le tableau ne doit pas Ãªtre vide
```

**Quand utiliser :**
- Validation des prÃ©conditions de fonction
- VÃ©rification des invariants pendant le dÃ©veloppement
- Attraper les erreurs de programmation tÃ´t

**assert vs panic :**
- `assert(cond, msg)` - VÃ©rifie une condition, Ã©choue si fausse
- `panic(msg)` - Ã‰choue toujours inconditionnellement

---

## Gestion des signaux

### signal

Enregistre ou rÃ©initialise un gestionnaire de signal.

**Signature :**
```hemlock
signal(signum: i32, handler: function | null): function | null
```

**ParamÃ¨tres :**
- `signum` - NumÃ©ro de signal (utiliser des constantes comme `SIGINT`)
- `handler` - Fonction Ã  appeler quand le signal est reÃ§u, ou `null` pour rÃ©initialiser par dÃ©faut

**Retourne :** Fonction gestionnaire prÃ©cÃ©dente, ou `null`

**Exemples :**
```hemlock
fn handle_interrupt(sig) {
    print("SIGINT interceptÃ© !");
}

signal(SIGINT, handle_interrupt);

// RÃ©initialiser par dÃ©faut
signal(SIGINT, null);
```

**Signature du gestionnaire :**
```hemlock
fn handler(signum: i32) {
    // signum contient le numÃ©ro du signal
}
```

**Voir aussi :**
- [Constantes de signal](#constantes-de-signal)
- `raise()`

---

### raise

Envoie un signal au processus courant.

**Signature :**
```hemlock
raise(signum: i32): null
```

**ParamÃ¨tres :**
- `signum` - NumÃ©ro de signal Ã  lever

**Retourne :** `null`

**Exemples :**
```hemlock
let count = 0;

fn increment(sig) {
    count = count + 1;
}

signal(SIGUSR1, increment);

raise(SIGUSR1);
raise(SIGUSR1);
print(count);  // 2
```

---

## Variables globales

### args

Tableau des arguments de ligne de commande.

**Type :** `array` de chaÃ®nes

**Structure :**
- `args[0]` - Nom du fichier script
- `args[1..n]` - Arguments de ligne de commande

**Exemples :**
```bash
# Commande: ./hemlock script.hml hello world
```

```hemlock
print(args[0]);        // "script.hml"
print(args.length);    // 3
print(args[1]);        // "hello"
print(args[2]);        // "world"

// ItÃ©rer sur les arguments
let i = 1;
while (i < args.length) {
    print("Argument", i, ":", args[i]);
    i = i + 1;
}
```

**Comportement REPL :** Dans le REPL, `args.length` est 0 (tableau vide)

---

## Constantes de signal

Constantes de signal POSIX standard (valeurs i32) :

### Interruption et terminaison

| Constante  | Valeur | Description                            |
|------------|--------|----------------------------------------|
| `SIGINT`   | 2      | Interruption depuis le clavier (Ctrl+C)|
| `SIGTERM`  | 15     | Demande de terminaison                 |
| `SIGQUIT`  | 3      | Quitter depuis le clavier (Ctrl+\)     |
| `SIGHUP`   | 1      | DÃ©connexion dÃ©tectÃ©e sur le terminal   |
| `SIGABRT`  | 6      | Signal d'abandon                       |

### DÃ©finis par l'utilisateur

| Constante  | Valeur | Description                |
|------------|--------|----------------------------|
| `SIGUSR1`  | 10     | Signal dÃ©fini par l'utilisateur 1 |
| `SIGUSR2`  | 12     | Signal dÃ©fini par l'utilisateur 2 |

### ContrÃ´le de processus

| Constante  | Valeur | Description                     |
|------------|--------|---------------------------------|
| `SIGALRM`  | 14     | Minuterie d'alarme              |
| `SIGCHLD`  | 17     | Changement de statut du processus enfant |
| `SIGCONT`  | 18     | Continuer si arrÃªtÃ©             |
| `SIGSTOP`  | 19     | ArrÃªter le processus (ne peut pas Ãªtre interceptÃ©) |
| `SIGTSTP`  | 20     | ArrÃªt terminal (Ctrl+Z)         |

### E/S

| Constante  | Valeur | Description                        |
|------------|--------|------------------------------------|
| `SIGPIPE`  | 13     | Pipe cassÃ©                         |
| `SIGTTIN`  | 21     | Lecture en arriÃ¨re-plan depuis le terminal |
| `SIGTTOU`  | 22     | Ã‰criture en arriÃ¨re-plan vers le terminal |

**Exemples :**
```hemlock
fn handle_signal(sig) {
    if (sig == SIGINT) {
        print("Interruption dÃ©tectÃ©e");
    }
    if (sig == SIGTERM) {
        print("Terminaison demandÃ©e");
    }
}

signal(SIGINT, handle_signal);
signal(SIGTERM, handle_signal);
```

**Note :** `SIGKILL` (9) et `SIGSTOP` (19) ne peuvent pas Ãªtre interceptÃ©s ou ignorÃ©s.

---

## Fonctions mathÃ©matiques/arithmÃ©tiques

### div

Division entiÃ¨re (floor) retournant un flottant.

**Signature :**
```hemlock
div(a: number, b: number): f64
```

**ParamÃ¨tres :**
- `a` - Dividende
- `b` - Diviseur

**Retourne :** Partie entiÃ¨re de `a / b` sous forme de flottant (f64)

**Exemples :**
```hemlock
let result = div(7, 2);    // 3.0 (pas 3.5)
let result2 = div(10, 3);  // 3.0
let result3 = div(-7, 2);  // -4.0 (floor arrondit vers l'infini nÃ©gatif)
```

**Note :** Dans Hemlock, l'opÃ©rateur `/` retourne toujours un flottant. Utilisez `div()` pour la division entiÃ¨re quand vous avez besoin de la partie entiÃ¨re sous forme de flottant, ou `divi()` quand vous avez besoin d'un rÃ©sultat entier.

---

### divi

Division entiÃ¨re (floor) retournant un entier.

**Signature :**
```hemlock
divi(a: number, b: number): i64
```

**ParamÃ¨tres :**
- `a` - Dividende
- `b` - Diviseur

**Retourne :** Partie entiÃ¨re de `a / b` sous forme d'entier (i64)

**Exemples :**
```hemlock
let result = divi(7, 2);    // 3
let result2 = divi(10, 3);  // 3
let result3 = divi(-7, 2);  // -4 (floor arrondit vers l'infini nÃ©gatif)
```

**Comparaison :**
```hemlock
print(7 / 2);      // 3.5 (division rÃ©guliÃ¨re, toujours flottant)
print(div(7, 2));  // 3.0 (division entiÃ¨re, rÃ©sultat flottant)
print(divi(7, 2)); // 3   (division entiÃ¨re, rÃ©sultat entier)
```

---

## Fonctions de gestion de la mÃ©moire

Voir [API Memory](#reference-memory-api) pour la rÃ©fÃ©rence complÃ¨te :
- `alloc(size)` - Allouer de la mÃ©moire brute
- `free(ptr)` - LibÃ©rer la mÃ©moire
- `buffer(size)` - Allouer un buffer sÃ©curisÃ©
- `memset(ptr, byte, size)` - Remplir la mÃ©moire
- `memcpy(dest, src, size)` - Copier la mÃ©moire
- `realloc(ptr, new_size)` - Redimensionner l'allocation

### sizeof

Obtient la taille d'un type en octets.

**Signature :**
```hemlock
sizeof(type): i32
```

**ParamÃ¨tres :**
- `type` - Une constante de type (`i32`, `f64`, `ptr`, etc.) ou une chaÃ®ne de nom de type

**Retourne :** Taille en octets sous forme de `i32`

**Exemples :**
```hemlock
print(sizeof(i8));       // 1
print(sizeof(i16));      // 2
print(sizeof(i32));      // 4
print(sizeof(i64));      // 8
print(sizeof(f32));      // 4
print(sizeof(f64));      // 8
print(sizeof(ptr));      // 8
print(sizeof(rune));     // 4

// Utilisation des alias de type
print(sizeof(byte));     // 1 (identique Ã  u8)
print(sizeof(integer));  // 4 (identique Ã  i32)
print(sizeof(number));   // 8 (identique Ã  f64)

// La forme chaÃ®ne fonctionne aussi
print(sizeof("i32"));    // 4
```

**Types supportÃ©s :**
| Type | Taille | Alias |
|------|--------|-------|
| `i8` | 1 | - |
| `i16` | 2 | - |
| `i32` | 4 | `integer` |
| `i64` | 8 | - |
| `u8` | 1 | `byte` |
| `u16` | 2 | - |
| `u32` | 4 | - |
| `u64` | 8 | - |
| `f32` | 4 | - |
| `f64` | 8 | `number` |
| `ptr` | 8 | - |
| `rune` | 4 | - |
| `bool` | 1 | - |

**Voir aussi :** `talloc()` pour l'allocation typÃ©e

---

### talloc

Alloue de la mÃ©moire pour un tableau typÃ© (allocation sensible au type).

**Signature :**
```hemlock
talloc(type, count: i32): ptr
```

**ParamÃ¨tres :**
- `type` - Une constante de type (`i32`, `f64`, `ptr`, etc.)
- `count` - Nombre d'Ã©lÃ©ments Ã  allouer

**Retourne :** `ptr` vers la mÃ©moire allouÃ©e, ou `null` en cas d'Ã©chec

**Exemples :**
```hemlock
// Allouer tableau de 10 i32 (40 octets)
let int_arr = talloc(i32, 10);
ptr_write_i32(int_arr, 42);
ptr_write_i32(ptr_offset(int_arr, 1, 4), 100);

// Allouer tableau de 5 f64 (40 octets)
let float_arr = talloc(f64, 5);

// Allouer tableau de 100 octets
let byte_arr = talloc(u8, 100);

// N'oubliez pas de libÃ©rer !
free(int_arr);
free(float_arr);
free(byte_arr);
```

**Comparaison avec alloc :**
```hemlock
// Ces deux sont Ã©quivalents:
let p1 = talloc(i32, 10);      // Sensible au type: 10 i32
let p2 = alloc(sizeof(i32) * 10);  // Calcul manuel

// talloc est plus clair et moins sujet aux erreurs
```

**Gestion des erreurs :**
- Retourne `null` si l'allocation Ã©choue
- Quitte avec erreur si count n'est pas positif
- VÃ©rifie le dÃ©passement de taille (count * element_size)

**Voir aussi :** `alloc()`, `sizeof()`, `free()`

---

## Helpers de pointeurs FFI

Ces fonctions aident Ã  lire et Ã©crire des valeurs typÃ©es dans la mÃ©moire brute, utiles pour FFI et la manipulation de mÃ©moire de bas niveau.

### ptr_null

CrÃ©e un pointeur null.

**Signature :**
```hemlock
ptr_null(): ptr
```

**Retourne :** Un pointeur null

**Exemple :**
```hemlock
let p = ptr_null();
if (p == null) {
    print("Le pointeur est null");
}
```

---

### ptr_offset

Calcule le dÃ©calage de pointeur (arithmÃ©tique de pointeur).

**Signature :**
```hemlock
ptr_offset(ptr: ptr, index: i32, element_size: i32): ptr
```

**ParamÃ¨tres :**
- `ptr` - Pointeur de base
- `index` - Index de l'Ã©lÃ©ment
- `element_size` - Taille de chaque Ã©lÃ©ment en octets

**Retourne :** Pointeur vers l'Ã©lÃ©ment Ã  l'index donnÃ©

**Exemple :**
```hemlock
let arr = talloc(i32, 10);
ptr_write_i32(arr, 100);                      // arr[0] = 100
ptr_write_i32(ptr_offset(arr, 1, 4), 200);    // arr[1] = 200
ptr_write_i32(ptr_offset(arr, 2, 4), 300);    // arr[2] = 300

print(ptr_read_i32(ptr_offset(arr, 1, 4)));   // 200
free(arr);
```

---

### Fonctions de lecture de pointeur

Lisent des valeurs typÃ©es depuis la mÃ©moire.

| Fonction | Signature | Retourne | Description |
|----------|-----------|----------|-------------|
| `ptr_read_i8` | `(ptr)` | `i8` | Lire entier signÃ© 8 bits |
| `ptr_read_i16` | `(ptr)` | `i16` | Lire entier signÃ© 16 bits |
| `ptr_read_i32` | `(ptr)` | `i32` | Lire entier signÃ© 32 bits |
| `ptr_read_i64` | `(ptr)` | `i64` | Lire entier signÃ© 64 bits |
| `ptr_read_u8` | `(ptr)` | `u8` | Lire entier non signÃ© 8 bits |
| `ptr_read_u16` | `(ptr)` | `u16` | Lire entier non signÃ© 16 bits |
| `ptr_read_u32` | `(ptr)` | `u32` | Lire entier non signÃ© 32 bits |
| `ptr_read_u64` | `(ptr)` | `u64` | Lire entier non signÃ© 64 bits |
| `ptr_read_f32` | `(ptr)` | `f32` | Lire flottant 32 bits |
| `ptr_read_f64` | `(ptr)` | `f64` | Lire flottant 64 bits |
| `ptr_read_ptr` | `(ptr)` | `ptr` | Lire valeur de pointeur |

**Exemple :**
```hemlock
let p = alloc(8);
ptr_write_f64(p, 3.14159);
let value = ptr_read_f64(p);
print(value);  // 3.14159
free(p);
```

---

### Fonctions d'Ã©criture de pointeur

Ã‰crivent des valeurs typÃ©es dans la mÃ©moire.

| Fonction | Signature | Retourne | Description |
|----------|-----------|----------|-------------|
| `ptr_write_i8` | `(ptr, value)` | `null` | Ã‰crire entier signÃ© 8 bits |
| `ptr_write_i16` | `(ptr, value)` | `null` | Ã‰crire entier signÃ© 16 bits |
| `ptr_write_i32` | `(ptr, value)` | `null` | Ã‰crire entier signÃ© 32 bits |
| `ptr_write_i64` | `(ptr, value)` | `null` | Ã‰crire entier signÃ© 64 bits |
| `ptr_write_u8` | `(ptr, value)` | `null` | Ã‰crire entier non signÃ© 8 bits |
| `ptr_write_u16` | `(ptr, value)` | `null` | Ã‰crire entier non signÃ© 16 bits |
| `ptr_write_u32` | `(ptr, value)` | `null` | Ã‰crire entier non signÃ© 32 bits |
| `ptr_write_u64` | `(ptr, value)` | `null` | Ã‰crire entier non signÃ© 64 bits |
| `ptr_write_f32` | `(ptr, value)` | `null` | Ã‰crire flottant 32 bits |
| `ptr_write_f64` | `(ptr, value)` | `null` | Ã‰crire flottant 64 bits |
| `ptr_write_ptr` | `(ptr, value)` | `null` | Ã‰crire valeur de pointeur |

**Exemple :**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);
print(ptr_read_i32(p));  // 42
free(p);
```

---

### Conversion buffer/pointeur

#### buffer_ptr

Obtient le pointeur brut depuis un buffer.

**Signature :**
```hemlock
buffer_ptr(buf: buffer): ptr
```

**Exemple :**
```hemlock
let buf = buffer(64);
let p = buffer_ptr(buf);
// Maintenant p pointe vers la mÃªme mÃ©moire que buf
```

#### ptr_to_buffer

CrÃ©e un wrapper buffer autour d'un pointeur brut.

**Signature :**
```hemlock
ptr_to_buffer(ptr: ptr, size: i32): buffer
```

**Exemple :**
```hemlock
let p = alloc(64);
let buf = ptr_to_buffer(p, 64);
buf[0] = 65;  // Maintenant a une vÃ©rification des limites
// Note: libÃ©rer buf libÃ©rera la mÃ©moire sous-jacente
```

---

## Fonctions d'E/S fichier

Voir [API File](#reference-file-api) pour la rÃ©fÃ©rence complÃ¨te :
- `open(path, mode?)` - Ouvrir un fichier

---

## Fonctions de concurrence

Voir [API Concurrency](#reference-concurrency-api) pour la rÃ©fÃ©rence complÃ¨te :
- `spawn(fn, args...)` - Lancer une tÃ¢che
- `join(task)` - Attendre une tÃ¢che
- `detach(task)` - DÃ©tacher une tÃ¢che
- `channel(capacity)` - CrÃ©er un canal

### apply

Appelle une fonction dynamiquement avec un tableau d'arguments.

**Signature :**
```hemlock
apply(fn: function, args: array): any
```

**ParamÃ¨tres :**
- `fn` - La fonction Ã  appeler
- `args` - Tableau d'arguments Ã  passer Ã  la fonction

**Retourne :** La valeur de retour de la fonction appelÃ©e

**Exemples :**
```hemlock
fn add(a, b) {
    return a + b;
}

// Appeler avec un tableau d'arguments
let result = apply(add, [2, 3]);
print(result);  // 5

// Dispatch dynamique
let operations = {
    add: fn(a, b) { return a + b; },
    mul: fn(a, b) { return a * b; },
    sub: fn(a, b) { return a - b; }
};

fn calculate(op: string, args: array) {
    return apply(operations[op], args);
}

print(calculate("add", [10, 5]));  // 15
print(calculate("mul", [10, 5]));  // 50
print(calculate("sub", [10, 5]));  // 5

// Arguments variables
fn sum(...nums) {
    let total = 0;
    for (n in nums) {
        total = total + n;
    }
    return total;
}

let numbers = [1, 2, 3, 4, 5];
print(apply(sum, numbers));  // 15
```

**Cas d'utilisation :**
- Dispatch dynamique de fonction basÃ© sur des valeurs Ã  l'exÃ©cution
- Appel de fonctions avec des listes d'arguments variables
- ImplÃ©mentation d'utilitaires d'ordre supÃ©rieur (map, filter, etc.)
- SystÃ¨mes de plugins/extensions

---

### select

Attend des donnÃ©es de plusieurs canaux, retourne quand l'un a des donnÃ©es.

**Signature :**
```hemlock
select(channels: array, timeout_ms?: i32): object | null
```

**ParamÃ¨tres :**
- `channels` - Tableau de valeurs de canal
- `timeout_ms` (optionnel) - Timeout en millisecondes (-1 ou omettre pour infini)

**Retourne :**
- `{ channel, value }` - Objet avec le canal qui avait des donnÃ©es et la valeur reÃ§ue
- `null` - En cas de timeout

**Exemples :**
```hemlock
let ch1 = channel(1);
let ch2 = channel(1);

// TÃ¢ches productrices
spawn(fn() {
    sleep(100);
    ch1.send("du canal 1");
});

spawn(fn() {
    sleep(50);
    ch2.send("du canal 2");
});

// Attendre le premier message
let result = select([ch1, ch2]);
print(result.value);  // "du canal 2" (arrivÃ© en premier)

// Avec timeout
let result2 = select([ch1, ch2], 1000);  // Attendre jusqu'Ã  1 seconde
if (result2 == null) {
    print("Timeout - pas de donnÃ©es reÃ§ues");
} else {
    print("ReÃ§u:", result2.value);
}

// Boucle de select continue
while (true) {
    let msg = select([ch1, ch2], 5000);
    if (msg == null) {
        print("Pas d'activitÃ© depuis 5 secondes");
        break;
    }
    print("Message reÃ§u:", msg.value);
}
```

**Comportement :**
- Bloque jusqu'Ã  ce qu'un canal ait des donnÃ©es ou que le timeout expire
- Retourne immÃ©diatement si un canal a dÃ©jÃ  des donnÃ©es
- Si le canal est fermÃ© et vide, retourne `{ channel, value: null }`
- Interroge les canaux dans l'ordre (le premier canal prÃªt gagne)

**Cas d'utilisation :**
- Multiplexage de plusieurs producteurs
- ImplÃ©mentation de timeouts sur les opÃ©rations de canal
- Construction de boucles d'Ã©vÃ©nements avec plusieurs sources

---

## Tableau rÃ©capitulatif

### Fonctions

| Fonction   | CatÃ©gorie        | Retourne     | Description                          |
|------------|------------------|--------------|--------------------------------------|
| `print`    | E/S              | `null`       | Afficher sur stdout                  |
| `read_line`| E/S              | `string?`    | Lire une ligne depuis stdin          |
| `eprint`   | E/S              | `null`       | Afficher sur stderr                  |
| `typeof`   | Type             | `string`     | Obtenir le nom du type               |
| `exec`     | Commande         | `object`     | ExÃ©cuter une commande shell          |
| `exec_argv`| Commande         | `object`     | ExÃ©cuter avec tableau d'arguments    |
| `assert`   | Erreur           | `null`       | Affirmer une condition ou quitter    |
| `panic`    | Erreur           | `never`      | Erreur irrÃ©cupÃ©rable (quitte)        |
| `signal`   | Signal           | `function?`  | Enregistrer un gestionnaire de signal|
| `raise`    | Signal           | `null`       | Envoyer un signal au processus       |
| `alloc`    | MÃ©moire          | `ptr`        | Allouer de la mÃ©moire brute          |
| `talloc`   | MÃ©moire          | `ptr`        | Allocation typÃ©e                     |
| `sizeof`   | MÃ©moire          | `i32`        | Obtenir la taille du type en octets  |
| `free`     | MÃ©moire          | `null`       | LibÃ©rer la mÃ©moire                   |
| `buffer`   | MÃ©moire          | `buffer`     | Allouer un buffer sÃ©curisÃ©           |
| `memset`   | MÃ©moire          | `null`       | Remplir la mÃ©moire                   |
| `memcpy`   | MÃ©moire          | `null`       | Copier la mÃ©moire                    |
| `realloc`  | MÃ©moire          | `ptr`        | Redimensionner l'allocation          |
| `open`     | E/S fichier      | `file`       | Ouvrir un fichier                    |
| `spawn`    | Concurrence      | `task`       | Lancer une tÃ¢che concurrente         |
| `join`     | Concurrence      | `any`        | Attendre le rÃ©sultat de la tÃ¢che     |
| `detach`   | Concurrence      | `null`       | DÃ©tacher la tÃ¢che                    |
| `channel`  | Concurrence      | `channel`    | CrÃ©er un canal de communication      |
| `select`   | Concurrence      | `object?`    | Attendre sur plusieurs canaux        |
| `apply`    | Fonctions        | `any`        | Appeler fonction avec tableau d'args |

### Variables globales

| Variable   | Type     | Description                       |
|------------|----------|-----------------------------------|
| `args`     | `array`  | Arguments de ligne de commande    |

### Constantes

| Constante  | Type  | CatÃ©gorie | Valeur | Description               |
|------------|-------|-----------|--------|---------------------------|
| `SIGINT`   | `i32` | Signal    | 2      | Interruption clavier      |
| `SIGTERM`  | `i32` | Signal    | 15     | Demande de terminaison    |
| `SIGQUIT`  | `i32` | Signal    | 3      | Quitter clavier           |
| `SIGHUP`   | `i32` | Signal    | 1      | DÃ©connexion               |
| `SIGABRT`  | `i32` | Signal    | 6      | Abandon                   |
| `SIGUSR1`  | `i32` | Signal    | 10     | DÃ©fini par l'utilisateur 1|
| `SIGUSR2`  | `i32` | Signal    | 12     | DÃ©fini par l'utilisateur 2|
| `SIGALRM`  | `i32` | Signal    | 14     | Minuterie d'alarme        |
| `SIGCHLD`  | `i32` | Signal    | 17     | Changement statut enfant  |
| `SIGCONT`  | `i32` | Signal    | 18     | Continuer                 |
| `SIGSTOP`  | `i32` | Signal    | 19     | ArrÃªt (non interceptable) |
| `SIGTSTP`  | `i32` | Signal    | 20     | ArrÃªt terminal            |
| `SIGPIPE`  | `i32` | Signal    | 13     | Pipe cassÃ©                |
| `SIGTTIN`  | `i32` | Signal    | 21     | Lecture terminal en arriÃ¨re-plan |
| `SIGTTOU`  | `i32` | Signal    | 22     | Ã‰criture terminal en arriÃ¨re-plan |

---

## Voir aussi

- [SystÃ¨me de types](#reference-type-system) - Types et conversions
- [API Memory](#reference-memory-api) - Fonctions d'allocation mÃ©moire
- [API File](#reference-file-api) - Fonctions d'E/S fichier
- [API Concurrency](#reference-concurrency-api) - Fonctions async/concurrence
- [API String](#reference-string-api) - MÃ©thodes des chaÃ®nes
- [API Array](#reference-array-api) - MÃ©thodes des tableaux


--------------------------------------------------------------------------------
## OpÃ©rateurs
--------------------------------------------------------------------------------

# RÃ©fÃ©rence des opÃ©rateurs

RÃ©fÃ©rence complÃ¨te pour tous les opÃ©rateurs dans Hemlock, y compris la prioritÃ©, l'associativitÃ© et le comportement.

---

## AperÃ§u

Hemlock fournit des opÃ©rateurs de style C avec des rÃ¨gles de prioritÃ© explicites. Tous les opÃ©rateurs suivent des rÃ¨gles de typage strictes avec promotion de type automatique lorsque applicable.

---

## OpÃ©rateurs arithmÃ©tiques

### ArithmÃ©tique binaire

| OpÃ©rateur | Nom            | Exemple    | Description                    |
|-----------|----------------|------------|--------------------------------|
| `+`       | Addition       | `a + b`    | Additionner deux valeurs       |
| `-`       | Soustraction   | `a - b`    | Soustraire b de a              |
| `*`       | Multiplication | `a * b`    | Multiplier deux valeurs        |
| `/`       | Division       | `a / b`    | Diviser a par b                |

**Promotion de type :**
Les rÃ©sultats suivent les rÃ¨gles de promotion de type (voir [SystÃ¨me de types](type-system.md#rÃ¨gles-de-promotion-de-type)).

**Exemples :**
```hemlock
let a = 10 + 5;        // 15 (i32)
let b = 10 - 3;        // 7 (i32)
let c = 4 * 5;         // 20 (i32)
let d = 20 / 4;        // 5 (i32)

// Division flottante
let e = 10.0 / 3.0;    // 3.333... (f64)

// Types mixtes
let f: u8 = 10;
let g: i32 = 20;
let h = f + g;         // 30 (i32, promu)
```

**Division par zÃ©ro :**
- Division entiÃ¨re par zÃ©ro : Erreur d'exÃ©cution
- Division flottante par zÃ©ro : Retourne `inf` ou `-inf`

---

### ArithmÃ©tique unaire

| OpÃ©rateur | Nom      | Exemple | Description          |
|-----------|----------|---------|----------------------|
| `-`       | NÃ©gation | `-a`    | NÃ©gation de la valeur|
| `+`       | Plus     | `+a`    | IdentitÃ© (pas d'effet)|

**Exemples :**
```hemlock
let a = 5;
let b = -a;            // -5
let c = +a;            // 5 (pas de changement)

let x = -3.14;         // -3.14
```

---

## OpÃ©rateurs de comparaison

| OpÃ©rateur | Nom                       | Exemple    | Retourne |
|-----------|---------------------------|------------|----------|
| `==`      | Ã‰gal                      | `a == b`   | `bool`   |
| `!=`      | DiffÃ©rent                 | `a != b`   | `bool`   |
| `<`       | InfÃ©rieur Ã                | `a < b`    | `bool`   |
| `>`       | SupÃ©rieur Ã                | `a > b`    | `bool`   |
| `<=`      | InfÃ©rieur ou Ã©gal Ã        | `a <= b`   | `bool`   |
| `>=`      | SupÃ©rieur ou Ã©gal Ã        | `a >= b`   | `bool`   |

**Promotion de type :**
Les opÃ©randes sont promus avant la comparaison.

**Exemples :**
```hemlock
print(5 == 5);         // true
print(10 != 5);        // true
print(3 < 7);          // true
print(10 > 5);         // true
print(5 <= 5);         // true
print(10 >= 5);        // true

// Comparaison de chaÃ®nes
print("hello" == "hello");  // true
print("abc" < "def");       // true (lexicographique)

// Types mixtes
let a: u8 = 10;
let b: i32 = 10;
print(a == b);         // true (promu en i32)
```

---

## OpÃ©rateurs logiques

| OpÃ©rateur | Nom         | Exemple      | Description                    |
|-----------|-------------|--------------|--------------------------------|
| `&&`      | ET logique  | `a && b`     | Vrai si les deux sont vrais    |
| `||`      | OU logique  | `a || b`     | Vrai si l'un est vrai          |
| `!`       | NON logique | `!a`         | NÃ©gation boolÃ©enne             |

**Ã‰valuation en court-circuit :**
- `&&` - S'arrÃªte Ã  la premiÃ¨re valeur fausse
- `||` - S'arrÃªte Ã  la premiÃ¨re valeur vraie

**Exemples :**
```hemlock
let a = true;
let b = false;

print(a && b);         // false
print(a || b);         // true
print(!a);             // false
print(!b);             // true

// Court-circuit
if (x != 0 && (10 / x) > 2) {
    print("sÃ»r");
}

if (x == 0 || (10 / x) > 2) {
    print("sÃ»r");
}
```

---

## OpÃ©rateurs bit Ã  bit

**Restriction :** Types entiers uniquement (i8-i64, u8-u64)

### Bit Ã  bit binaire

| OpÃ©rateur | Nom              | Exemple    | Description               |
|-----------|------------------|------------|---------------------------|
| `&`       | ET bit Ã  bit     | `a & b`    | ET sur chaque bit         |
| `|`       | OU bit Ã  bit     | `a | b`    | OU sur chaque bit         |
| `^`       | XOR bit Ã  bit    | `a ^ b`    | XOR sur chaque bit        |
| `<<`      | DÃ©calage gauche  | `a << b`   | DÃ©caler Ã  gauche de b bits|
| `>>`      | DÃ©calage droite  | `a >> b`   | DÃ©caler Ã  droite de b bits|

**PrÃ©servation du type :**
Le type du rÃ©sultat correspond aux types des opÃ©randes (avec promotion de type).

**Exemples :**
```hemlock
let a = 12;  // 1100 en binaire
let b = 10;  // 1010 en binaire

print(a & b);          // 8  (1000)
print(a | b);          // 14 (1110)
print(a ^ b);          // 6  (0110)
print(a << 2);         // 48 (110000)
print(a >> 1);         // 6  (110)
```

**Exemple non signÃ© :**
```hemlock
let c: u8 = 15;        // 00001111
let d: u8 = 7;         // 00000111

print(c & d);          // 7  (00000111)
print(c | d);          // 15 (00001111)
print(c ^ d);          // 8  (00001000)
```

**Comportement du dÃ©calage droit :**
- Types signÃ©s : DÃ©calage arithmÃ©tique (Ã©tend le signe)
- Types non signÃ©s : DÃ©calage logique (remplit avec des zÃ©ros)

---

### Bit Ã  bit unaire

| OpÃ©rateur | Nom            | Exemple | Description               |
|-----------|----------------|---------|---------------------------|
| `~`       | NON bit Ã  bit  | `~a`    | Inverse tous les bits     |

**Exemples :**
```hemlock
let a = 12;            // 00001100 (i32)
print(~a);             // -13 (complÃ©ment Ã  deux)

let b: u8 = 15;        // 00001111
print(~b);             // 240 (11110000)
```

---

## OpÃ©rateurs de chaÃ®ne

### ConcatÃ©nation

| OpÃ©rateur | Nom            | Exemple    | Description        |
|-----------|----------------|------------|--------------------|
| `+`       | ConcatÃ©nation  | `a + b`    | Joindre des chaÃ®nes|

**Exemples :**
```hemlock
let s = "hello" + " " + "world";  // "hello world"
let msg = "Count: " + typeof(42); // "Count: 42"

// String + rune
let greeting = "Hello" + '!';      // "Hello!"

// Rune + string
let prefix = '>' + " Message";     // "> Message"
```

---

## OpÃ©rateurs d'affectation

### Affectation basique

| OpÃ©rateur | Nom         | Exemple    | Description                   |
|-----------|-------------|------------|-------------------------------|
| `=`       | Affectation | `a = b`    | Affecter une valeur Ã  une variable |

**Exemples :**
```hemlock
let x = 10;
x = 20;

let arr = [1, 2, 3];
arr[0] = 99;

let obj = { x: 10 };
obj.x = 20;
```

### Affectation composÃ©e

#### Affectation composÃ©e arithmÃ©tique

| OpÃ©rateur | Nom                   | Exemple    | Ã‰quivalent         |
|-----------|-----------------------|------------|--------------------|
| `+=`      | Ajouter et affecter   | `a += b`   | `a = a + b`        |
| `-=`      | Soustraire et affecter| `a -= b`   | `a = a - b`        |
| `*=`      | Multiplier et affecter| `a *= b`   | `a = a * b`        |
| `/=`      | Diviser et affecter   | `a /= b`   | `a = a / b`        |
| `%=`      | Modulo et affecter    | `a %= b`   | `a = a % b`        |

**Exemples :**
```hemlock
let x = 10;
x += 5;      // x vaut maintenant 15
x -= 3;      // x vaut maintenant 12
x *= 2;      // x vaut maintenant 24
x /= 4;      // x vaut maintenant 6

let count = 0;
count += 1;  // IncrÃ©menter de 1
```

#### Affectation composÃ©e bit Ã  bit

| OpÃ©rateur | Nom                        | Exemple     | Ã‰quivalent          |
|-----------|----------------------------|-------------|---------------------|
| `&=`      | ET bit Ã  bit et affecter   | `a &= b`    | `a = a & b`         |
| `\|=`     | OU bit Ã  bit et affecter   | `a \|= b`   | `a = a \| b`        |
| `^=`      | XOR bit Ã  bit et affecter  | `a ^= b`    | `a = a ^ b`         |
| `<<=`     | DÃ©caler gauche et affecter | `a <<= b`   | `a = a << b`        |
| `>>=`     | DÃ©caler droite et affecter | `a >>= b`   | `a = a >> b`        |

**Exemples :**
```hemlock
let flags = 0b1111;
flags &= 0b0011;   // flags vaut maintenant 0b0011 (masquer les bits supÃ©rieurs)
flags |= 0b1000;   // flags vaut maintenant 0b1011 (activer un bit)
flags ^= 0b0001;   // flags vaut maintenant 0b1010 (basculer un bit)

let x = 1;
x <<= 4;           // x vaut maintenant 16 (dÃ©caler Ã  gauche de 4)
x >>= 2;           // x vaut maintenant 4 (dÃ©caler Ã  droite de 2)
```

### IncrÃ©mentation/DÃ©crÃ©mentation

| OpÃ©rateur | Nom           | Exemple | Description                    |
|-----------|---------------|---------|--------------------------------|
| `++`      | IncrÃ©mentation| `a++`   | IncrÃ©menter de 1 (postfixe)    |
| `--`      | DÃ©crÃ©mentation| `a--`   | DÃ©crÃ©menter de 1 (postfixe)    |

**Exemples :**
```hemlock
let i = 0;
i++;         // i vaut maintenant 1
i++;         // i vaut maintenant 2
i--;         // i vaut maintenant 1

// Courant dans les boucles
for (let j = 0; j < 10; j++) {
    print(j);
}
```

**Note :** `++` et `--` sont des opÃ©rateurs postfixes (la valeur est retournÃ©e avant l'incrÃ©mentation/dÃ©crÃ©mentation)

---

## OpÃ©rateurs de sÃ©curitÃ© null

### Coalescence null (`??`)

Retourne l'opÃ©rande gauche s'il n'est pas null, sinon retourne l'opÃ©rande droit.

| OpÃ©rateur | Nom              | Exemple      | Description                      |
|-----------|------------------|--------------|----------------------------------|
| `??`      | Coalescence null | `a ?? b`     | Retourner a si non null, sinon b |

**Exemples :**
```hemlock
let name = null;
let display = name ?? "Anonyme";  // "Anonyme"

let value = 42;
let result = value ?? 0;            // 42

// ChaÃ®nage
let a = null;
let b = null;
let c = "trouvÃ©";
let result2 = a ?? b ?? c;          // "trouvÃ©"

// Avec des appels de fonction
fn get_config() { return null; }
let config = get_config() ?? { default: true };
```

---

### ChaÃ®nage optionnel (`?.`)

AccÃ¨de en toute sÃ©curitÃ© aux propriÃ©tÃ©s ou appelle des mÃ©thodes sur des valeurs potentiellement null.

| OpÃ©rateur | Nom                 | Exemple        | Description                           |
|-----------|---------------------|----------------|---------------------------------------|
| `?.`      | ChaÃ®nage optionnel  | `a?.b`         | Retourner a.b si a non null, sinon null |
| `?.[`     | Index optionnel     | `a?.[0]`       | Retourner a[0] si a non null, sinon null |
| `?.(`     | Appel optionnel     | `a?.()`        | Appeler a() si a non null, sinon null |

**Exemples :**
```hemlock
let user = null;
let name = user?.name;              // null (pas d'erreur)

let person = { name: "Alice", address: null };
let city = person?.address?.city;   // null (navigation sÃ»re)

// Avec des tableaux
let arr = null;
let first = arr?.[0];               // null

let items = [1, 2, 3];
let second = items?.[1];            // 2

// Avec des appels de mÃ©thode
let obj = { greet: fn() { return "Hello"; } };
let greeting = obj?.greet?.();      // "Hello"

let empty = null;
let result = empty?.method?.();     // null
```

**Comportement :**
- Si l'opÃ©rande gauche est null, toute l'expression court-circuite vers null
- Si l'opÃ©rande gauche n'est pas null, l'accÃ¨s se poursuit normalement
- Peut Ãªtre chaÃ®nÃ© pour un accÃ¨s profond aux propriÃ©tÃ©s

---

## OpÃ©rateurs d'accÃ¨s aux membres

### OpÃ©rateur point

| OpÃ©rateur | Nom                | Exemple      | Description              |
|-----------|--------------------|--------------|--------------------------|
| `.`       | AccÃ¨s membre       | `obj.field`  | AccÃ©der au champ objet   |
| `.`       | AccÃ¨s propriÃ©tÃ©    | `arr.length` | AccÃ©der Ã  la propriÃ©tÃ©   |

**Exemples :**
```hemlock
// AccÃ¨s au champ objet
let person = { name: "Alice", age: 30 };
print(person.name);        // "Alice"

// PropriÃ©tÃ© de tableau
let arr = [1, 2, 3];
print(arr.length);         // 3

// PropriÃ©tÃ© de chaÃ®ne
let s = "hello";
print(s.length);           // 5

// Appel de mÃ©thode
let result = s.to_upper(); // "HELLO"
```

---

### OpÃ©rateur d'index

| OpÃ©rateur | Nom    | Exemple   | Description           |
|-----------|--------|-----------|----------------------|
| `[]`      | Index  | `arr[i]`  | AccÃ©der Ã  l'Ã©lÃ©ment  |

**Exemples :**
```hemlock
// Indexation de tableau
let arr = [10, 20, 30];
print(arr[0]);             // 10
arr[1] = 99;

// Indexation de chaÃ®ne (retourne un rune)
let s = "hello";
print(s[0]);               // 'h'
s[0] = 'H';                // "Hello"

// Indexation de buffer
let buf = buffer(10);
buf[0] = 65;
print(buf[0]);             // 65
```

---

## OpÃ©rateur d'appel de fonction

| OpÃ©rateur | Nom              | Exemple      | Description         |
|-----------|------------------|--------------|---------------------|
| `()`      | Appel de fonction| `f(a, b)`    | Appeler la fonction |

**Exemples :**
```hemlock
fn add(a, b) {
    return a + b;
}

let result = add(5, 3);    // 8

// Appel de mÃ©thode
let s = "hello";
let upper = s.to_upper();  // "HELLO"

// Appel de fonction intÃ©grÃ©e
print("message");
```

---

## PrioritÃ© des opÃ©rateurs

Les opÃ©rateurs sont listÃ©s de la plus haute Ã  la plus basse prioritÃ© :

| PrioritÃ© | OpÃ©rateurs                   | Description                         | AssociativitÃ©   |
|----------|------------------------------|-------------------------------------|-----------------|
| 1        | `()` `[]` `.` `?.`           | Appel, index, accÃ¨s membre, chaÃ®nage optionnel | Gauche Ã  droite |
| 2        | `++` `--`                    | IncrÃ©mentation/dÃ©crÃ©mentation postfixe | Gauche Ã  droite |
| 3        | `!` `~` `-` (unaire) `+` (unaire) | NON logique, NON bit Ã  bit, nÃ©gation | Droite Ã  gauche |
| 4        | `*` `/` `%`                  | Multiplication, division, modulo    | Gauche Ã  droite |
| 5        | `+` `-`                      | Addition, soustraction              | Gauche Ã  droite |
| 6        | `<<` `>>`                    | DÃ©calages de bits                   | Gauche Ã  droite |
| 7        | `<` `<=` `>` `>=`            | Relationnel                         | Gauche Ã  droite |
| 8        | `==` `!=`                    | Ã‰galitÃ©                             | Gauche Ã  droite |
| 9        | `&`                          | ET bit Ã  bit                        | Gauche Ã  droite |
| 10       | `^`                          | XOR bit Ã  bit                       | Gauche Ã  droite |
| 11       | `|`                          | OU bit Ã  bit                        | Gauche Ã  droite |
| 12       | `&&`                         | ET logique                          | Gauche Ã  droite |
| 13       | `||`                         | OU logique                          | Gauche Ã  droite |
| 14       | `??`                         | Coalescence null                    | Gauche Ã  droite |
| 15       | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\|=` `^=` `<<=` `>>=` | Affectation | Droite Ã  gauche |

---

## Exemples de prioritÃ©

### Exemple 1 : ArithmÃ©tique et comparaison
```hemlock
let result = 5 + 3 * 2;
// Ã‰valuÃ© comme : 5 + (3 * 2) = 11
// La multiplication a une prioritÃ© plus Ã©levÃ©e que l'addition

let cmp = 10 > 5 + 3;
// Ã‰valuÃ© comme : 10 > (5 + 3) = true
// L'addition a une prioritÃ© plus Ã©levÃ©e que la comparaison
```

### Exemple 2 : OpÃ©rateurs bit Ã  bit
```hemlock
let result1 = 12 | 10 & 8;
// Ã‰valuÃ© comme : 12 | (10 & 8) = 12 | 8 = 12
// & a une prioritÃ© plus Ã©levÃ©e que |

let result2 = 8 | 1 << 2;
// Ã‰valuÃ© comme : 8 | (1 << 2) = 8 | 4 = 12
// Le dÃ©calage a une prioritÃ© plus Ã©levÃ©e que le OU bit Ã  bit

// Utiliser des parenthÃ¨ses pour la clartÃ©
let result3 = (5 & 3) | (2 << 1);
// Ã‰valuÃ© comme : 1 | 4 = 5
```

### Exemple 3 : OpÃ©rateurs logiques
```hemlock
let result = true || false && false;
// Ã‰valuÃ© comme : true || (false && false) = true
// && a une prioritÃ© plus Ã©levÃ©e que ||

let cmp = 5 < 10 && 10 < 20;
// Ã‰valuÃ© comme : (5 < 10) && (10 < 20) = true
// La comparaison a une prioritÃ© plus Ã©levÃ©e que &&
```

### Exemple 4 : Utilisation de parenthÃ¨ses
```hemlock
// Sans parenthÃ¨ses
let a = 2 + 3 * 4;        // 14

// Avec parenthÃ¨ses
let b = (2 + 3) * 4;      // 20

// Expression complexe
let c = (a + b) * (a - b);
```

---

## Comportement des opÃ©rateurs spÃ©cifiques aux types

### Division (toujours flottante)

L'opÃ©rateur `/` **retourne toujours un flottant** (f64), quel que soit le type des opÃ©randes :

```hemlock
print(10 / 3);             // 3.333... (f64)
print(5 / 2);              // 2.5 (f64)
print(10.0 / 4.0);         // 2.5 (f64)
print(-7 / 3);             // -2.333... (f64)
```

Cela Ã©vite le bug courant de troncature entiÃ¨re inattendue.

### Division entiÃ¨re (div / divi)

Pour la division entiÃ¨re (comme la division entiÃ¨re dans d'autres langages), utilisez les fonctions `div()` et `divi()` :

```hemlock
// div(a, b) - division entiÃ¨re retournant un flottant
print(div(5, 2));          // 2 (f64)
print(div(-7, 3));         // -3 (f64)  -- arrondit vers -infini

// divi(a, b) - division entiÃ¨re retournant un entier
print(divi(5, 2));         // 2 (i64)
print(divi(-7, 3));        // -3 (i64)
print(typeof(divi(5, 2))); // i64
```

**Fonctions mathÃ©matiques retournant des entiers :**
Pour d'autres opÃ©rations d'arrondi qui retournent des entiers :

```hemlock
print(floori(3.7));        // 3 (i64)
print(ceili(3.2));         // 4 (i64)
print(roundi(3.5));        // 4 (i64)
print(trunci(3.9));        // 3 (i64)

// Ceux-ci peuvent Ãªtre utilisÃ©s directement comme indices de tableau
let arr = [10, 20, 30, 40];
print(arr[floori(1.9)]);   // 20 (index 1)
```

### Comparaison de chaÃ®nes

Les chaÃ®nes sont comparÃ©es lexicographiquement :

```hemlock
print("abc" < "def");      // true
print("apple" > "banana"); // false
print("hello" == "hello"); // true
```

### Comparaison null

```hemlock
let x = null;

print(x == null);          // true
print(x != null);          // false
```

### Erreurs de type

Certaines opÃ©rations ne sont pas autorisÃ©es entre types incompatibles :

```hemlock
// ERREUR : Impossible d'utiliser les opÃ©rateurs bit Ã  bit sur les flottants
let x = 3.14 & 2.71;

// ERREUR : Impossible d'utiliser les opÃ©rateurs bit Ã  bit sur les chaÃ®nes
let y = "hello" & "world";

// OK : Promotion de type pour l'arithmÃ©tique
let a: u8 = 10;
let b: i32 = 20;
let c = a + b;             // i32 (promu)
```

---

## Voir aussi

- [SystÃ¨me de types](#reference-type-system) - RÃ¨gles de promotion et conversion de types
- [Fonctions intÃ©grÃ©es](#reference-builtins) - OpÃ©rations intÃ©grÃ©es
- [API String](#reference-string-api) - ConcatÃ©nation et mÃ©thodes de chaÃ®nes


--------------------------------------------------------------------------------
## SystÃ¨me de Types
--------------------------------------------------------------------------------

# RÃ©fÃ©rence du systÃ¨me de types

RÃ©fÃ©rence complÃ¨te pour le systÃ¨me de types de Hemlock, y compris tous les types primitifs et composites.

---

## AperÃ§u

Hemlock utilise un **systÃ¨me de types dynamique** avec des Ã©tiquettes de type Ã  l'exÃ©cution et des annotations de type optionnelles. Chaque valeur a un type Ã  l'exÃ©cution, et les conversions de type suivent des rÃ¨gles de promotion explicites.

**CaractÃ©ristiques principales :**
- VÃ©rification de type Ã  l'exÃ©cution (interprÃ©teur)
- VÃ©rification de type Ã  la compilation (hemlockc - activÃ©e par dÃ©faut)
- Annotations de type optionnelles
- InfÃ©rence de type automatique pour les littÃ©raux
- RÃ¨gles de promotion de type explicites
- Pas de conversions implicites qui perdent de la prÃ©cision

---

## VÃ©rification de type Ã  la compilation (hemlockc)

Le compilateur Hemlock (`hemlockc`) inclut un vÃ©rificateur de types Ã  la compilation qui valide votre code avant de gÃ©nÃ©rer les exÃ©cutables. Cela attrape les erreurs de type tÃ´t sans avoir besoin d'exÃ©cuter le programme.

### Comportement par dÃ©faut

La vÃ©rification de type est **activÃ©e par dÃ©faut** dans hemlockc :

```bash
# La vÃ©rification de type se fait automatiquement
hemlockc program.hml -o program

# Les erreurs sont signalÃ©es avant la compilation
hemlockc bad_types.hml
# Sortie: 1 type error found
```

### Options du compilateur

| Option | Description |
|--------|-------------|
| `--check` | VÃ©rifier les types uniquement, ne pas compiler (quitter aprÃ¨s validation) |
| `--no-type-check` | DÃ©sactiver la vÃ©rification de type (non recommandÃ©) |
| `--strict-types` | Activer des avertissements de type plus stricts |

**Exemples :**

```bash
# Juste valider les types sans compiler
hemlockc --check program.hml
# Sortie: program.hml: no type errors

# DÃ©sactiver la vÃ©rification de type (utiliser avec prÃ©caution)
hemlockc --no-type-check dynamic_code.hml -o program

# Activer les avertissements stricts pour les types any implicites
hemlockc --strict-types program.hml -o program
```

### Ce que le vÃ©rificateur de types valide

1. **Annotations de type** - S'assure que les valeurs assignÃ©es correspondent aux types dÃ©clarÃ©s
2. **Appels de fonction** - Valide les types d'arguments contre les types de paramÃ¨tres
3. **Types de retour** - VÃ©rifie que les instructions return correspondent au type de retour dÃ©clarÃ©
4. **Utilisation des opÃ©rateurs** - VÃ©rifie que les opÃ©randes sont compatibles
5. **AccÃ¨s aux propriÃ©tÃ©s** - Valide les types de champs d'objet pour les objets typÃ©s

### Conversions numÃ©riques permissives

Le vÃ©rificateur de types autorise les conversions de types numÃ©riques Ã  la compilation, avec validation de plage Ã  l'exÃ©cution :

```hemlock
let x: i8 = 100;      // OK - 100 tient dans i8 (validÃ© Ã  l'exÃ©cution)
let y: u8 = 255;      // OK - dans la plage u8
let z: f64 = 42;      // OK - i32 vers f64 est sÃ»r
```

### Support du code dynamique

Le code sans annotations de type est traitÃ© comme dynamique (type `any`) et passe toujours le vÃ©rificateur de types :

```hemlock
let x = get_value();  // Dynamique - pas d'annotation
process(x);           // OK - les valeurs dynamiques sont acceptÃ©es partout
```

---

## Types primitifs

### Types numÃ©riques

#### Entiers signÃ©s

| Type   | Taille   | Plage                                      | Alias     |
|--------|----------|-------------------------------------------|-----------|
| `i8`   | 1 octet  | -128 Ã  127                                | -         |
| `i16`  | 2 octets | -32 768 Ã  32 767                          | -         |
| `i32`  | 4 octets | -2 147 483 648 Ã  2 147 483 647            | `integer` |
| `i64`  | 8 octets | -9 223 372 036 854 775 808 Ã  9 223 372 036 854 775 807 | - |

**Exemples :**
```hemlock
let a: i8 = 127;
let b: i16 = 32000;
let c: i32 = 1000000;
let d: i64 = 9223372036854775807;

// Alias de type
let x: integer = 42;  // Identique Ã  i32
```

#### Entiers non signÃ©s

| Type   | Taille   | Plage                        | Alias  |
|--------|----------|------------------------------|--------|
| `u8`   | 1 octet  | 0 Ã  255                      | `byte` |
| `u16`  | 2 octets | 0 Ã  65 535                   | -      |
| `u32`  | 4 octets | 0 Ã  4 294 967 295            | -      |
| `u64`  | 8 octets | 0 Ã  18 446 744 073 709 551 615 | -   |

**Exemples :**
```hemlock
let a: u8 = 255;
let b: u16 = 65535;
let c: u32 = 4294967295;
let d: u64 = 18446744073709551615;

// Alias de type
let byte_val: byte = 65;  // Identique Ã  u8
```

#### Virgule flottante

| Type   | Taille   | PrÃ©cision      | Alias    |
|--------|----------|----------------|----------|
| `f32`  | 4 octets | ~7 chiffres    | -        |
| `f64`  | 8 octets | ~15 chiffres   | `number` |

**Exemples :**
```hemlock
let pi: f32 = 3.14159;
let precise: f64 = 3.14159265359;

// Alias de type
let x: number = 2.718;  // Identique Ã  f64
```

---

### InfÃ©rence de type pour les littÃ©raux entiers

Les littÃ©raux entiers sont automatiquement typÃ©s en fonction de leur valeur :

**RÃ¨gles :**
- Valeurs dans la plage i32 (-2 147 483 648 Ã  2 147 483 647) : infÃ©rer comme `i32`
- Valeurs hors de la plage i32 mais dans la plage i64 : infÃ©rer comme `i64`
- Utiliser des annotations de type explicites pour les autres types (i8, i16, u8, u16, u32, u64)

**Exemples :**
```hemlock
let small = 42;                    // i32 (tient dans i32)
let large = 5000000000;            // i64 (> max i32)
let max_i64 = 9223372036854775807; // i64 (INT64_MAX)
let explicit: u32 = 100;           // u32 (l'annotation de type prÃ©vaut)
```

---

### Type boolÃ©en

**Type :** `bool`

**Valeurs :** `true`, `false`

**Taille :** 1 octet (en interne)

**Exemples :**
```hemlock
let is_active: bool = true;
let done = false;

if (is_active && !done) {
    print("en cours");
}
```

---

### Types de caractÃ¨res

#### Rune

**Type :** `rune`

**Description :** Point de code Unicode (U+0000 Ã  U+10FFFF)

**Taille :** 4 octets (valeur 32 bits)

**Plage :** 0 Ã  0x10FFFF (1 114 111)

**Syntaxe littÃ©rale :** Guillemets simples `'x'`

**Exemples :**
```hemlock
// ASCII
let a = 'A';
let digit = '0';

// UTF-8 multi-octets
let rocket = 'ðŸš€';      // U+1F680
let heart = 'â¤';        // U+2764
let chinese = 'ä¸­';     // U+4E2D

// SÃ©quences d'Ã©chappement
let newline = '\n';
let tab = '\t';
let backslash = '\\';
let quote = '\'';
let null = '\0';

// Ã‰chappements Unicode
let emoji = '\u{1F680}';   // Jusqu'Ã  6 chiffres hexadÃ©cimaux
let max = '\u{10FFFF}';    // Point de code maximum
```

**Conversions de type :**
```hemlock
// Entier vers rune
let code: rune = 65;        // 'A'
let r: rune = 128640;       // ðŸš€

// Rune vers entier
let value: i32 = 'Z';       // 90

// Rune vers chaÃ®ne
let s: string = 'H';        // "H"

// u8 vers rune
let byte: u8 = 65;
let rune_val: rune = byte;  // 'A'
```

**Voir aussi :** [API String](#reference-string-api) pour la concatÃ©nation string + rune

---

### Type chaÃ®ne

**Type :** `string`

**Description :** Texte encodÃ© en UTF-8, mutable, allouÃ© sur le tas

**Encodage :** UTF-8 (U+0000 Ã  U+10FFFF)

**MutabilitÃ© :** Mutable (contrairement Ã  la plupart des langages)

**PropriÃ©tÃ©s :**
- `.length` - Nombre de points de code (nombre de caractÃ¨res)
- `.byte_length` - Nombre d'octets (taille de l'encodage UTF-8)

**Syntaxe littÃ©rale :** Guillemets doubles `"texte"`

**Exemples :**
```hemlock
let s = "hello";
s[0] = 'H';             // Modifier (maintenant "Hello")
print(s.length);        // 5 (nombre de points de code)
print(s.byte_length);   // 5 (octets UTF-8)

let emoji = "ðŸš€";
print(emoji.length);        // 1 (un point de code)
print(emoji.byte_length);   // 4 (quatre octets UTF-8)
```

**Indexation :**
```hemlock
let s = "hello";
let ch = s[0];          // Retourne le rune 'h'
s[0] = 'H';             // DÃ©finir avec un rune
```

**Voir aussi :** [API String](#reference-string-api) pour la rÃ©fÃ©rence complÃ¨te des mÃ©thodes

---

### Type null

**Type :** `null`

**Description :** La valeur null (absence de valeur)

**Taille :** 8 octets (en interne)

**Valeur :** `null`

**Exemples :**
```hemlock
let x = null;
let y: i32 = null;  // ERREUR: incompatibilitÃ© de type

if (x == null) {
    print("x est null");
}
```

---

## Types composites

### Type tableau

**Type :** `array`

**Description :** Tableau dynamique, allouÃ© sur le tas, de types mixtes

**PropriÃ©tÃ©s :**
- `.length` - Nombre d'Ã©lÃ©ments

**Indexation base zÃ©ro :** Oui

**Syntaxe littÃ©rale :** `[elem1, elem2, ...]`

**Exemples :**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr[0]);         // 1
print(arr.length);     // 5

// Types mixtes
let mixed = [1, "hello", true, null];
```

**Voir aussi :** [API Array](#reference-array-api) pour la rÃ©fÃ©rence complÃ¨te des mÃ©thodes

---

### Type objet

**Type :** `object`

**Description :** Objet de style JavaScript avec champs dynamiques

**Syntaxe littÃ©rale :** `{ field: value, ... }`

**Exemples :**
```hemlock
let person = { name: "Alice", age: 30 };
print(person.name);  // "Alice"

// Ajouter un champ dynamiquement
person.email = "alice@example.com";
```

**DÃ©finitions de type :**
```hemlock
define Person {
    name: string,
    age: i32,
    active?: bool,  // Champ optionnel
}

let p: Person = { name: "Bob", age: 25 };
print(typeof(p));  // "Person"
```

---

### Types de pointeur

#### Pointeur brut (ptr)

**Type :** `ptr`

**Description :** Adresse mÃ©moire brute (non sÃ»r)

**Taille :** 8 octets

**VÃ©rification des limites :** Aucune

**Exemples :**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

#### Buffer (buffer)

**Type :** `buffer`

**Description :** Enveloppe de pointeur sÃ©curisÃ©e avec vÃ©rification des limites

**Structure :** Pointeur + longueur + capacitÃ©

**PropriÃ©tÃ©s :**
- `.length` - Taille du buffer
- `.capacity` - CapacitÃ© allouÃ©e

**Exemples :**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // VÃ©rifiÃ© aux limites
print(b.length);        // 64
free(b);
```

**Voir aussi :** [API Memory](#reference-memory-api) pour les fonctions d'allocation

---

## Types spÃ©ciaux

### Type file

**Type :** `file`

**Description :** Handle de fichier pour les opÃ©rations d'E/S

**PropriÃ©tÃ©s :**
- `.path` - Chemin du fichier (string)
- `.mode` - Mode d'ouverture (string)
- `.closed` - Si le fichier est fermÃ© (bool)

**Voir aussi :** [API File](#reference-file-api)

---

### Type task

**Type :** `task`

**Description :** Handle pour une tÃ¢che concurrente

**Voir aussi :** [API Concurrency](#reference-concurrency-api)

---

### Type channel

**Type :** `channel`

**Description :** Canal de communication thread-safe

**Voir aussi :** [API Concurrency](#reference-concurrency-api)

---

### Type function

**Type :** `function`

**Description :** Valeur de fonction de premiÃ¨re classe

**Exemples :**
```hemlock
fn add(a, b) {
    return a + b;
}

let multiply = fn(x, y) {
    return x * y;
};

print(typeof(add));      // "function"
print(typeof(multiply)); // "function"
```

---

### Type void

**Type :** `void`

**Description :** Absence de valeur de retour (usage interne)

---

## RÃ¨gles de promotion de type

Lors du mÃ©lange de types dans les opÃ©rations, Hemlock promeut vers le type "supÃ©rieur" :

**HiÃ©rarchie de promotion :**
```
f64 (plus haute prÃ©cision)
 â†‘
f32
 â†‘
u64
 â†‘
i64
 â†‘
u32
 â†‘
i32
 â†‘
u16
 â†‘
i16
 â†‘
u8
 â†‘
i8 (plus basse)
```

**RÃ¨gles :**
1. Le flottant gagne toujours sur l'entier
2. La plus grande taille gagne dans la mÃªme catÃ©gorie (int/uint/float)
3. Les deux opÃ©randes sont promus vers le type rÃ©sultat
4. **PrÃ©servation de la prÃ©cision :** i64/u64 + f32 promeut vers f64 (pas f32)

**Exemples :**
```hemlock
// Promotion de taille
u8 + i32    â†’ i32    // La plus grande taille gagne
i32 + i64   â†’ i64    // La plus grande taille gagne
u32 + u64   â†’ u64    // La plus grande taille gagne

// Promotion flottante
i32 + f32   â†’ f32    // Le flottant gagne, f32 suffit pour i32
i64 + f32   â†’ f64    // Promeut vers f64 pour prÃ©server la prÃ©cision i64
i64 + f64   â†’ f64    // Le flottant gagne toujours
i8 + f64    â†’ f64    // Flottant + plus grand gagne
```

**Pourquoi i64 + f32 â†’ f64 ?**

f32 n'a qu'une mantisse de 24 bits, qui ne peut pas reprÃ©senter prÃ©cisÃ©ment les entiers plus grands que 2^24 (16 777 216). Puisque i64 peut contenir des valeurs jusqu'Ã  2^63, mÃ©langer i64 avec f32 causerait une perte de prÃ©cision sÃ©vÃ¨re. Hemlock promeut vers f64 (mantisse de 53 bits) Ã  la place.

---

## VÃ©rification de plage

Les annotations de type appliquent des vÃ©rifications de plage Ã  l'affectation :

**Affectations valides :**
```hemlock
let x: u8 = 255;             // OK
let y: i8 = 127;             // OK
let a: i64 = 2147483647;     // OK
let b: u64 = 4294967295;     // OK
```

**Affectations invalides (erreur d'exÃ©cution) :**
```hemlock
let x: u8 = 256;             // ERREUR: hors plage
let y: i8 = 128;             // ERREUR: max est 127
let z: u64 = -1;             // ERREUR: u64 ne peut pas Ãªtre nÃ©gatif
```

---

## Introspection de type

### typeof(value)

Retourne le nom du type sous forme de chaÃ®ne.

**Signature :**
```hemlock
typeof(value: any): string
```

**Retourne :**
- Types primitifs : `"i8"`, `"i16"`, `"i32"`, `"i64"`, `"u8"`, `"u16"`, `"u32"`, `"u64"`, `"f32"`, `"f64"`, `"bool"`, `"string"`, `"rune"`, `"null"`
- Types composites : `"array"`, `"object"`, `"ptr"`, `"buffer"`, `"function"`
- Types spÃ©ciaux : `"file"`, `"task"`, `"channel"`
- Objets typÃ©s : Nom de type personnalisÃ© (ex., `"Person"`)

**Exemples :**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("hello"));         // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"

define Person { name: string }
let p: Person = { name: "Alice" };
print(typeof(p));               // "Person"
```

**Voir aussi :** [Fonctions intÃ©grÃ©es](builtins.md#typeof)

---

## Conversions de type

### Conversions implicites

Hemlock effectue des conversions de type implicites dans les opÃ©rations arithmÃ©tiques suivant les rÃ¨gles de promotion de type.

**Exemples :**
```hemlock
let a: u8 = 10;
let b: i32 = 20;
let result = a + b;     // result est i32 (promu)
```

### Conversions explicites

Utilisez les annotations de type pour les conversions explicites :

**Exemples :**
```hemlock
// Entier vers flottant
let i: i32 = 42;
let f: f64 = i;         // 42.0

// Flottant vers entier (tronque)
let x: f64 = 3.14;
let y: i32 = x;         // 3

// Entier vers rune
let code: rune = 65;    // 'A'

// Rune vers entier
let value: i32 = 'Z';   // 90

// Rune vers chaÃ®ne
let s: string = 'H';    // "H"
```

---

## Alias de type

### Alias intÃ©grÃ©s

Hemlock fournit des alias de type intÃ©grÃ©s pour les types courants :

| Alias     | Type rÃ©el | Usage                        |
|-----------|-----------|------------------------------|
| `integer` | `i32`     | Entiers Ã  usage gÃ©nÃ©ral      |
| `number`  | `f64`     | Flottants Ã  usage gÃ©nÃ©ral    |
| `byte`    | `u8`      | Valeurs d'octets             |

**Exemples :**
```hemlock
let count: integer = 100;       // Identique Ã  i32
let price: number = 19.99;      // Identique Ã  f64
let b: byte = 255;              // Identique Ã  u8
```

### Alias de type personnalisÃ©s

DÃ©finissez des alias de type personnalisÃ©s avec le mot-clÃ© `type` :

```hemlock
// Alias simples
type Integer = i32;
type Text = string;

// Alias de type fonction
type Callback = fn(i32): void;
type Predicate = fn(any): bool;
type BinaryOp = fn(i32, i32): i32;

// Alias de type composÃ©
define HasName { name: string }
define HasAge { age: i32 }
type Person = HasName & HasAge;

// Alias de type gÃ©nÃ©rique
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };
```

**Utilisation des alias personnalisÃ©s :**
```hemlock
let cb: Callback = fn(n) { print(n); };
let p: Person = { name: "Alice", age: 30 };
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
```

**Note :** Les alias de type sont transparents - `typeof()` retourne le nom du type sous-jacent.

---

## Types de fonction

Les types de fonction spÃ©cifient la signature des valeurs de fonction :

### Syntaxe

```hemlock
fn(types_paramÃ¨tres): type_retour
```

### Exemples

```hemlock
// Type de fonction basique
let add: fn(i32, i32): i32 = fn(a, b) { return a + b; };

// ParamÃ¨tre de fonction
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Fonction d'ordre supÃ©rieur retournant une fonction
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Type de fonction async
fn run_async(handler: async fn(): void) {
    spawn(handler);
}
```

---

## Types composÃ©s (intersection)

Les types composÃ©s utilisent `&` pour exiger plusieurs contraintes de type :

```hemlock
define HasName { name: string }
define HasAge { age: i32 }
define HasEmail { email: string }

// L'objet doit satisfaire tous les types
let person: HasName & HasAge = { name: "Alice", age: 30 };

// Trois types ou plus
fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}
```

---

## Tableau rÃ©capitulatif

| Type       | Taille    | Mutable | AllouÃ© sur le tas | Description                    |
|------------|-----------|---------|-------------------|--------------------------------|
| `i8`-`i64` | 1-8 octets| Non     | Non               | Entiers signÃ©s                 |
| `u8`-`u64` | 1-8 octets| Non     | Non               | Entiers non signÃ©s             |
| `f32`      | 4 octets  | Non     | Non               | Flottant simple prÃ©cision      |
| `f64`      | 8 octets  | Non     | Non               | Flottant double prÃ©cision      |
| `bool`     | 1 octet   | Non     | Non               | BoolÃ©en                        |
| `rune`     | 4 octets  | Non     | Non               | Point de code Unicode          |
| `string`   | Variable  | Oui     | Oui               | Texte UTF-8                    |
| `array`    | Variable  | Oui     | Oui               | Tableau dynamique              |
| `object`   | Variable  | Oui     | Oui               | Objet dynamique                |
| `ptr`      | 8 octets  | Non     | Non               | Pointeur brut                  |
| `buffer`   | Variable  | Oui     | Oui               | Enveloppe de pointeur sÃ©curisÃ©e|
| `file`     | Opaque    | Oui     | Oui               | Handle de fichier              |
| `task`     | Opaque    | Non     | Oui               | Handle de tÃ¢che concurrente    |
| `channel`  | Opaque    | Oui     | Oui               | Canal thread-safe              |
| `function` | Opaque    | Non     | Oui               | Valeur de fonction             |
| `null`     | 8 octets  | Non     | Non               | Valeur null                    |

---

## Voir aussi

- [RÃ©fÃ©rence des opÃ©rateurs](#reference-operators) - Comportement des types dans les opÃ©rations
- [Fonctions intÃ©grÃ©es](#reference-builtins) - Introspection et conversion de types
- [API String](#reference-string-api) - MÃ©thodes du type string
- [API Array](#reference-array-api) - MÃ©thodes du type array
- [API Memory](#reference-memory-api) - OpÃ©rations sur les pointeurs et buffers



################################################################################
# CONCEPTION ET PHILOSOPHIE
################################################################################

--------------------------------------------------------------------------------
## ImplÃ©mentation
--------------------------------------------------------------------------------

# DÃ©tails d'implÃ©mentation de Hemlock

Ce document dÃ©crit l'implÃ©mentation technique du langage Hemlock, incluant la structure du projet, le pipeline de compilation, l'architecture d'exÃ©cution et les dÃ©cisions de conception.

---

## Table des matiÃ¨res

- [Structure du projet](#structure-du-projet)
- [Pipeline de compilation](#pipeline-de-compilation)
- [Conception modulaire de l'interprÃ©teur](#conception-modulaire-de-linterprÃ©teur)
- [Architecture d'exÃ©cution](#architecture-dexÃ©cution)
- [ReprÃ©sentation des valeurs](#reprÃ©sentation-des-valeurs)
- [ImplÃ©mentation du systÃ¨me de types](#implÃ©mentation-du-systÃ¨me-de-types)
- [Gestion de la mÃ©moire](#gestion-de-la-mÃ©moire)
- [ModÃ¨le de concurrence](#modÃ¨le-de-concurrence)
- [Plans futurs](#plans-futurs)

---

## Structure du projet

```
hemlock/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ frontend/              # PartagÃ© : lexer, parser, AST
â”‚   â”‚   â”œâ”€â”€ lexer.c            # Tokenisation
â”‚   â”‚   â”œâ”€â”€ parser/            # Parser Ã  descente rÃ©cursive
â”‚   â”‚   â”œâ”€â”€ ast.c              # Gestion des nÅ“uds AST
â”‚   â”‚   â””â”€â”€ module.c           # RÃ©solution des modules
â”‚   â”œâ”€â”€ backends/
â”‚   â”‚   â”œâ”€â”€ interpreter/       # hemlock : interprÃ©teur par parcours d'arbre
â”‚   â”‚   â”‚   â”œâ”€â”€ main.c         # Point d'entrÃ©e CLI
â”‚   â”‚   â”‚   â”œâ”€â”€ runtime.c      # Ã‰valuation des expressions/instructions
â”‚   â”‚   â”‚   â”œâ”€â”€ builtins.c     # Fonctions intÃ©grÃ©es
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â””â”€â”€ compiler/          # hemlockc : gÃ©nÃ©rateur de code C
â”‚   â”‚       â”œâ”€â”€ main.c         # CLI, orchestration
â”‚   â”‚       â”œâ”€â”€ type_check.c   # VÃ©rification de types Ã  la compilation
â”‚   â”‚       â”œâ”€â”€ codegen.c      # Contexte de gÃ©nÃ©ration de code
â”‚   â”‚       â”œâ”€â”€ codegen_expr.c # GÃ©nÃ©ration de code pour les expressions
â”‚   â”‚       â”œâ”€â”€ codegen_stmt.c # GÃ©nÃ©ration de code pour les instructions
â”‚   â”‚       â””â”€â”€ ...
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ lsp/               # Language Server Protocol
â”‚   â”‚   â””â”€â”€ bundler/           # Outils de bundle/package
â”œâ”€â”€ runtime/                   # libhemlock_runtime.a (pour les programmes compilÃ©s)
â”œâ”€â”€ stdlib/                    # BibliothÃ¨que standard (39 modules)
â”‚   â””â”€â”€ docs/                  # Documentation des modules
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ parity/                # Tests devant passer sur les deux backends
â”‚   â”œâ”€â”€ interpreter/           # Tests spÃ©cifiques Ã  l'interprÃ©teur
â”‚   â””â”€â”€ compiler/              # Tests spÃ©cifiques au compilateur
â”œâ”€â”€ examples/                  # Programmes exemples
â””â”€â”€ docs/                      # Documentation
```

### Organisation des rÃ©pertoires

**`include/`** - En-tÃªtes d'API publique qui dÃ©finissent l'interface entre les composants :
- SÃ©paration nette entre lexer, parser, AST et interprÃ©teur
- DÃ©clarations anticipÃ©es pour minimiser les dÃ©pendances
- API publique pour intÃ©grer Hemlock dans d'autres programmes

**`src/`** - Fichiers d'implÃ©mentation :
- Les fichiers de niveau supÃ©rieur gÃ¨rent le lexing, le parsing, la gestion de l'AST
- `main.c` fournit la CLI et le REPL
- L'interprÃ©teur est modularisÃ© en sous-systÃ¨mes sÃ©parÃ©s

**`src/interpreter/`** - ImplÃ©mentation modulaire de l'interprÃ©teur :
- Chaque module a une seule responsabilitÃ© claire
- API interne dÃ©finie dans `internal.h` pour la communication inter-modules
- Les modules peuvent Ãªtre compilÃ©s indÃ©pendamment pour des builds plus rapides

**`tests/`** - Suite de tests complÃ¨te :
- OrganisÃ©e par domaine fonctionnel
- Chaque rÃ©pertoire contient des cas de test ciblÃ©s
- `run_tests.sh` orchestre l'exÃ©cution des tests

---

## Pipeline de compilation

Hemlock utilise un pipeline de compilation traditionnel avec des phases distinctes :

### Phase 1 : Analyse lexicale (Lexer)

**EntrÃ©e :** Texte du code source
**Sortie :** Flux de tokens
**ImplÃ©mentation :** `src/lexer.c`

```
Source : "let x = 42;"
   â†“
Tokens : [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
```

**CaractÃ©ristiques clÃ©s :**
- ReconnaÃ®t les mots-clÃ©s, identifiants, littÃ©raux, opÃ©rateurs, ponctuation
- GÃ¨re les littÃ©raux de chaÃ®ne UTF-8 et les littÃ©raux de rune
- Rapporte les numÃ©ros de ligne pour les messages d'erreur
- Passe unique, pas de retour arriÃ¨re

### Phase 2 : Analyse syntaxique (Parser)

**EntrÃ©e :** Flux de tokens
**Sortie :** Arbre de syntaxe abstraite (AST)
**ImplÃ©mentation :** `src/parser.c`

```
Tokens : [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
   â†“
AST : LetStmt {
    name: "x",
    type: null,
    value: IntLiteral(42)
}
```

**CaractÃ©ristiques clÃ©s :**
- Parser Ã  descente rÃ©cursive
- Construit une reprÃ©sentation arborescente de la structure du programme
- GÃ¨re la prÃ©cÃ©dence des opÃ©rateurs
- Valide la syntaxe (accolades, points-virgules, etc.)
- Pas d'analyse sÃ©mantique encore (faite Ã  l'exÃ©cution)

**PrÃ©cÃ©dence des opÃ©rateurs (du plus bas au plus haut) :**
1. Affectation : `=`
2. OU logique : `||`
3. ET logique : `&&`
4. OU bit Ã  bit : `|`
5. XOR bit Ã  bit : `^`
6. ET bit Ã  bit : `&`
7. Ã‰galitÃ© : `==`, `!=`
8. Comparaison : `<`, `>`, `<=`, `>=`
9. DÃ©calages bit Ã  bit : `<<`, `>>`
10. Addition/Soustraction : `+`, `-`
11. Multiplication/Division/Modulo : `*`, `/`, `%`
12. Unaire : `!`, `-`, `~`
13. Appel/Index/Membre : `()`, `[]`, `.`

### Phase 3a : InterprÃ©tation (parcours d'arbre)

**EntrÃ©e :** AST
**Sortie :** ExÃ©cution du programme
**ImplÃ©mentation :** `src/backends/interpreter/runtime.c`

```
AST : LetStmt { ... }
   â†“
ExÃ©cution : Ã‰value les nÅ“uds AST rÃ©cursivement
   â†“
RÃ©sultat : Variable x crÃ©Ã©e avec la valeur 42
```

**CaractÃ©ristiques clÃ©s :**
- Parcours direct de l'AST (interprÃ©teur par parcours d'arbre)
- VÃ©rification de type dynamique Ã  l'exÃ©cution
- Stockage des variables basÃ© sur l'environnement

### Phase 3b : Compilation (hemlockc)

**EntrÃ©e :** AST
**Sortie :** ExÃ©cutable natif via gÃ©nÃ©ration de code C
**ImplÃ©mentation :** `src/backends/compiler/`

```
AST : LetStmt { ... }
   â†“
VÃ©rification de types : Valide les types Ã  la compilation
   â†“
GÃ©nÃ©ration C : GÃ©nÃ¨re le code C Ã©quivalent
   â†“
GCC : Compile le C en binaire natif
   â†“
RÃ©sultat : ExÃ©cutable autonome
```

**CaractÃ©ristiques clÃ©s :**
- VÃ©rification de types Ã  la compilation (activÃ©e par dÃ©faut)
- GÃ©nÃ©ration de code C pour la portabilitÃ©
- Liaison avec `libhemlock_runtime.a`
- ExÃ©cution significativement plus rapide que l'interprÃ©teur

---

## Backend compilateur (hemlockc)

Le compilateur Hemlock gÃ©nÃ¨re du code C Ã  partir de l'AST, qui est ensuite compilÃ© en exÃ©cutable natif avec GCC.

### Architecture du compilateur

```
src/backends/compiler/
â”œâ”€â”€ main.c              # CLI, analyse des arguments, orchestration
â”œâ”€â”€ codegen.c           # Contexte de gÃ©nÃ©ration de code principal
â”œâ”€â”€ codegen_expr.c      # GÃ©nÃ©ration de code pour les expressions
â”œâ”€â”€ codegen_stmt.c      # GÃ©nÃ©ration de code pour les instructions
â”œâ”€â”€ codegen_call.c      # GÃ©nÃ©ration des appels de fonction
â”œâ”€â”€ codegen_closure.c   # ImplÃ©mentation des closures
â”œâ”€â”€ codegen_program.c   # GÃ©nÃ©ration du programme de niveau supÃ©rieur
â”œâ”€â”€ codegen_module.c    # Gestion des modules/imports
â”œâ”€â”€ type_check.c        # VÃ©rification de types Ã  la compilation
â””â”€â”€ type_check.h        # API du vÃ©rificateur de types
```

### VÃ©rification de types

Le compilateur inclut un systÃ¨me de vÃ©rification de types unifiÃ© qui :

1. **Valide les types Ã  la compilation** - DÃ©tecte les erreurs de type avant l'exÃ©cution
2. **Supporte le code dynamique** - Le code non typÃ© est traitÃ© comme `any` (toujours valide)
3. **Fournit des indices d'optimisation** - Identifie les variables qui peuvent Ãªtre dÃ©ballÃ©es

**Options de vÃ©rification de types :**

| Option | Description |
|--------|-------------|
| (dÃ©faut) | VÃ©rification de types activÃ©e |
| `--check` | VÃ©rifier les types uniquement, ne pas compiler |
| `--no-type-check` | DÃ©sactiver la vÃ©rification de types |
| `--strict-types` | Avertir sur les types `any` implicites |

**ImplÃ©mentation du vÃ©rificateur de types :**

```c
// type_check.h - Structures clÃ©s
typedef struct TypeCheckContext {
    const char *filename;
    int error_count;
    int warning_count;
    UnboxableVar *unboxable_vars;  // Indices d'optimisation
    // ... environnement de types, dÃ©finitions, etc.
} TypeCheckContext;

// Point d'entrÃ©e principal
int type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);
```

### GÃ©nÃ©ration de code

La phase de gÃ©nÃ©ration de code traduit les nÅ“uds AST en code C :

**Correspondance des expressions :**
```
Hemlock                 â†’  C gÃ©nÃ©rÃ©
----------------------------------------
let x = 42;            â†’  HmlValue x = hml_val_i32(42);
x + y                  â†’  hml_add(x, y)
arr[i]                 â†’  hml_array_get(arr, i)
obj.field              â†’  hml_object_get_field(obj, "field")
fn(a, b) { ... }       â†’  Closure avec capture d'environnement
```

**IntÃ©gration du runtime :**

Le code C gÃ©nÃ©rÃ© est liÃ© avec `libhemlock_runtime.a` qui fournit :
- Type union Ã©tiquetÃ© `HmlValue`
- Gestion de la mÃ©moire (comptage de rÃ©fÃ©rences)
- Fonctions intÃ©grÃ©es (print, typeof, etc.)
- Primitives de concurrence (tÃ¢ches, canaux)
- Support FFI

### Optimisation du dÃ©ballage (unboxing)

Le vÃ©rificateur de types identifie les variables qui peuvent utiliser des types C natifs au lieu de `HmlValue` emballÃ©s :

**Motifs dÃ©ballables :**
- Compteurs de boucle avec type entier connu
- Variables d'accumulateur dans les boucles
- Variables avec annotations de type explicites (i32, i64, f64, bool)

```hemlock
// Le compteur de boucle 'i' peut Ãªtre dÃ©ballÃ© en int32_t natif
for (let i: i32 = 0; i < 1000000; i = i + 1) {
    sum = sum + i;
}
```

---

## Conception modulaire de l'interprÃ©teur

L'interprÃ©teur est divisÃ© en modules ciblÃ©s pour la maintenabilitÃ© et l'extensibilitÃ©.

### ResponsabilitÃ©s des modules

#### 1. Environnement (`environment.c`) - 121 lignes

**Objectif :** PortÃ©e des variables et rÃ©solution des noms

**Fonctions clÃ©s :**
- `env_create()` - CrÃ©er un nouvel environnement avec parent optionnel
- `env_define()` - DÃ©finir une nouvelle variable dans la portÃ©e courante
- `env_get()` - Rechercher une variable dans la portÃ©e courante ou parente
- `env_set()` - Mettre Ã  jour la valeur d'une variable existante
- `env_free()` - LibÃ©rer l'environnement et toutes les variables

**Conception :**
- PortÃ©es liÃ©es (chaque environnement a un pointeur vers le parent)
- HashMap pour une recherche rapide des variables
- Supporte la portÃ©e lexicale pour les closures

#### 2. Valeurs (`values.c`) - 394 lignes

**Objectif :** Constructeurs de valeurs et gestion des structures de donnÃ©es

**Fonctions clÃ©s :**
- `value_create_*()` - Constructeurs pour chaque type de valeur
- `value_copy()` - Logique de copie profonde/superficielle
- `value_free()` - Nettoyage et dÃ©sallocation mÃ©moire
- `value_to_string()` - ReprÃ©sentation en chaÃ®ne pour l'affichage

**Structures de donnÃ©es :**
- Objets (tableaux de champs dynamiques)
- Tableaux (redimensionnement dynamique)
- Buffers (ptr + longueur + capacitÃ©)
- Closures (fonction + environnement capturÃ©)
- TÃ¢ches et canaux (primitives de concurrence)

#### 3. Types (`types.c`) - 440 lignes

**Objectif :** SystÃ¨me de types, conversions et duck typing

**Fonctions clÃ©s :**
- `type_check()` - Validation de type Ã  l'exÃ©cution
- `type_convert()` - Conversions/promotions de type implicites
- `duck_type_check()` - VÃ©rification de type structurel pour les objets
- `type_name()` - Obtenir le nom de type affichable

**FonctionnalitÃ©s :**
- HiÃ©rarchie de promotion de type (i8 â†’ i16 â†’ i32 â†’ i64 â†’ f32 â†’ f64, avec i64/u64 + f32 â†’ f64)
- VÃ©rification de plage pour les types numÃ©riques
- Duck typing pour les dÃ©finitions de type objet
- Valeurs par dÃ©faut des champs optionnels

#### 4. Fonctions intÃ©grÃ©es (`builtins.c`) - 955 lignes

**Objectif :** Fonctions intÃ©grÃ©es et enregistrement global

**Fonctions clÃ©s :**
- `register_builtins()` - Enregistrer toutes les fonctions et constantes intÃ©grÃ©es
- ImplÃ©mentations des fonctions intÃ©grÃ©es (print, typeof, alloc, free, etc.)
- Fonctions de gestion des signaux
- ExÃ©cution de commandes (exec)

**CatÃ©gories de fonctions intÃ©grÃ©es :**
- E/S : print, open, read_file, write_file
- MÃ©moire : alloc, free, memset, memcpy, realloc
- Types : typeof, assert
- Concurrence : spawn, join, detach, channel
- SystÃ¨me : exec, signal, raise, panic
- FFI : dlopen, dlsym, dlcall, dlclose

#### 5. E/S (`io.c`) - 449 lignes

**Objectif :** E/S de fichiers et sÃ©rialisation JSON

**Fonctions clÃ©s :**
- MÃ©thodes d'objet fichier (read, write, seek, tell, close)
- SÃ©rialisation/dÃ©sÃ©rialisation JSON
- DÃ©tection des rÃ©fÃ©rences circulaires

**FonctionnalitÃ©s :**
- Objet fichier avec propriÃ©tÃ©s (path, mode, closed)
- E/S texte compatible UTF-8
- Support E/S binaire
- Aller-retour JSON pour objets et tableaux

#### 6. FFI (`ffi.c`) - Interface de fonction Ã©trangÃ¨re

**Objectif :** Appeler des fonctions C depuis des bibliothÃ¨ques partagÃ©es

**Fonctions clÃ©s :**
- `dlopen()` - Charger une bibliothÃ¨que partagÃ©e
- `dlsym()` - Obtenir un pointeur de fonction par nom
- `dlcall()` - Appeler une fonction C avec conversion de type
- `dlclose()` - DÃ©charger la bibliothÃ¨que

**FonctionnalitÃ©s :**
- IntÃ©gration avec libffi pour les appels de fonction dynamiques
- Conversion de type automatique (Hemlock â†” types C)
- Support pour tous les types primitifs
- Support des pointeurs et buffers

#### 7. Runtime (`runtime.c`) - 865 lignes

**Objectif :** Ã‰valuation des expressions et exÃ©cution des instructions

**Fonctions clÃ©s :**
- `eval_expr()` - Ã‰valuer les expressions (rÃ©cursif)
- `eval_stmt()` - ExÃ©cuter les instructions
- Gestion du flux de contrÃ´le (if, while, for, switch, etc.)
- Gestion des exceptions (try/catch/finally/throw)

**FonctionnalitÃ©s :**
- Ã‰valuation rÃ©cursive des expressions
- Ã‰valuation boolÃ©enne en court-circuit
- DÃ©tection d'appel de mÃ©thode et liaison de `self`
- Propagation des exceptions
- Gestion de break/continue/return

### Avantages de la conception modulaire

**1. SÃ©paration des prÃ©occupations**
- Chaque module a une seule responsabilitÃ© claire
- Facile de trouver oÃ¹ les fonctionnalitÃ©s sont implÃ©mentÃ©es
- RÃ©duit la charge cognitive lors des modifications

**2. Builds incrÃ©mentaux plus rapides**
- Seuls les modules modifiÃ©s nÃ©cessitent une recompilation
- Compilation parallÃ¨le possible
- Temps d'itÃ©ration plus courts pendant le dÃ©veloppement

**3. Tests et dÃ©bogage plus faciles**
- Les modules peuvent Ãªtre testÃ©s isolÃ©ment
- Les bugs sont localisÃ©s dans des sous-systÃ¨mes spÃ©cifiques
- ImplÃ©mentations mock possibles pour les tests

**4. ExtensibilitÃ©**
- Les nouvelles fonctionnalitÃ©s peuvent Ãªtre ajoutÃ©es aux modules appropriÃ©s
- Les modules peuvent Ãªtre refactorisÃ©s indÃ©pendamment
- La taille du code par fichier reste gÃ©rable

**5. Organisation du code**
- Regroupement logique des fonctionnalitÃ©s connexes
- Graphe de dÃ©pendances clair
- IntÃ©gration plus facile des nouveaux contributeurs

---

## Architecture d'exÃ©cution

### ReprÃ©sentation des valeurs

Toutes les valeurs dans Hemlock sont reprÃ©sentÃ©es par la structure `Value` utilisant une union Ã©tiquetÃ©e :

```c
typedef struct Value {
    ValueType type;  // Ã‰tiquette de type Ã  l'exÃ©cution
    union {
        int32_t i32_value;
        int64_t i64_value;
        uint8_t u8_value;
        uint32_t u32_value;
        uint64_t u64_value;
        float f32_value;
        double f64_value;
        bool bool_value;
        char *string_value;
        uint32_t rune_value;
        void *ptr_value;
        Buffer *buffer_value;
        Array *array_value;
        Object *object_value;
        Function *function_value;
        File *file_value;
        Task *task_value;
        Channel *channel_value;
    };
} Value;
```

**DÃ©cisions de conception :**
- **Union Ã©tiquetÃ©e** pour la sÃ©curitÃ© de type tout en maintenant la flexibilitÃ©
- **Ã‰tiquettes de type Ã  l'exÃ©cution** permettent le typage dynamique avec vÃ©rification de type
- **Stockage direct des valeurs** pour les primitives (pas de boxing)
- **Stockage de pointeur** pour les types allouÃ©s sur le tas (chaÃ®nes, objets, tableaux)

### Exemples de disposition mÃ©moire

**Entier (i32) :**
```
Value {
    type: TYPE_I32,
    i32_value: 42
}
```
- Taille totale : ~16 octets (Ã©tiquette de 8 octets + union de 8 octets)
- AllouÃ© sur la pile
- Pas d'allocation sur le tas nÃ©cessaire

**ChaÃ®ne :**
```
Value {
    type: TYPE_STRING,
    string_value: 0x7f8a4c000000  // Pointeur vers le tas
}

Tas : "hello\0" (6 octets, UTF-8 terminÃ© par null)
```
- La valeur fait 16 octets sur la pile
- Les donnÃ©es de chaÃ®ne sont allouÃ©es sur le tas
- Doit Ãªtre libÃ©rÃ©e manuellement

**Objet :**
```
Value {
    type: TYPE_OBJECT,
    object_value: 0x7f8a4c001000  // Pointeur vers le tas
}

Tas : Object {
    type_name: "Person",
    fields: [
        { name: "name", value: Value{TYPE_STRING, "Alice"} },
        { name: "age", value: Value{TYPE_I32, 30} }
    ],
    field_count: 2,
    capacity: 4
}
```
- Structure d'objet sur le tas
- Champs stockÃ©s dans un tableau dynamique
- Les valeurs des champs sont des structures Value intÃ©grÃ©es

### ImplÃ©mentation de l'environnement

Les variables sont stockÃ©es dans des chaÃ®nes d'environnement :

```c
typedef struct Environment {
    HashMap *bindings;           // nom â†’ Value
    struct Environment *parent;  // PortÃ©e parente lexicale
} Environment;
```

**Exemple de chaÃ®ne de portÃ©e :**
```
PortÃ©e globale : { print: <builtin>, args: <array> }
    â†‘
PortÃ©e fonction : { x: 10, y: 20 }
    â†‘
PortÃ©e bloc : { i: 0 }
```

**Algorithme de recherche :**
1. VÃ©rifier le hashmap de l'environnement courant
2. Si non trouvÃ©, vÃ©rifier l'environnement parent
3. RÃ©pÃ©ter jusqu'Ã  trouver ou atteindre la portÃ©e globale
4. Erreur si non trouvÃ© dans aucune portÃ©e

---

## ImplÃ©mentation du systÃ¨me de types

### StratÃ©gie de vÃ©rification de types

Hemlock utilise la **vÃ©rification de type Ã  l'exÃ©cution** avec des **annotations de type optionnelles** :

```hemlock
let x = 42;           // Pas de vÃ©rification de type, infÃ¨re i32
let y: u8 = 255;      // VÃ©rification Ã  l'exÃ©cution : la valeur doit tenir dans u8
let z: i32 = x + y;   // VÃ©rification Ã  l'exÃ©cution + promotion de type
```

**Flux d'implÃ©mentation :**
1. **InfÃ©rence de littÃ©ral** - Le lexer/parser dÃ©termine le type initial du littÃ©ral
2. **VÃ©rification d'annotation de type** - Si annotation prÃ©sente, valider Ã  l'affectation
3. **Promotion** - Les opÃ©rations binaires promeuvent vers un type commun
4. **Conversion** - Les conversions explicites se font Ã  la demande

### ImplÃ©mentation de la promotion de type

La promotion de type suit une hiÃ©rarchie fixe avec prÃ©servation de la prÃ©cision :

```c
// Logique de promotion simplifiÃ©e
ValueType promote_types(ValueType a, ValueType b) {
    // f64 gagne toujours
    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;

    // f32 avec i64/u64 promeut vers f64 (prÃ©servation de la prÃ©cision)
    if (a == TYPE_F32 || b == TYPE_F32) {
        ValueType other = (a == TYPE_F32) ? b : a;
        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;
        return TYPE_F32;
    }

    // Les types entiers plus grands gagnent
    int rank_a = get_type_rank(a);
    int rank_b = get_type_rank(b);
    return (rank_a > rank_b) ? a : b;
}
```

**Rangs de types :**
- i8 : 0
- u8 : 1
- i16 : 2
- u16 : 3
- i32 : 4
- u32 : 5
- i64 : 6
- u64 : 7
- f32 : 8
- f64 : 9

### ImplÃ©mentation du duck typing

La vÃ©rification de type d'objet utilise la comparaison structurelle :

```c
bool duck_type_check(Object *obj, TypeDef *type_def) {
    // VÃ©rifier tous les champs requis
    for (each field in type_def) {
        if (!object_has_field(obj, field.name)) {
            return false;  // Champ manquant
        }

        Value *field_value = object_get_field(obj, field.name);
        if (!type_matches(field_value, field.type)) {
            return false;  // Mauvais type
        }
    }

    return true;  // Tous les champs requis prÃ©sents et de type correct
}
```

**Le duck typing permet :**
- Champs supplÃ©mentaires dans les objets (ignorÃ©s)
- Typage substructurel (l'objet peut avoir plus que requis)
- Affectation du nom de type aprÃ¨s validation

---

## Gestion de la mÃ©moire

### StratÃ©gie d'allocation

Hemlock utilise la **gestion manuelle de la mÃ©moire** avec deux primitives d'allocation :

**1. Pointeurs bruts (`ptr`) :**
```c
void *alloc(size_t bytes) {
    void *ptr = malloc(bytes);
    if (!ptr) {
        fprintf(stderr, "MÃ©moire insuffisante\n");
        exit(1);
    }
    return ptr;
}
```
- malloc/free direct
- Pas de suivi
- ResponsabilitÃ© de l'utilisateur de libÃ©rer

**2. Buffers (`buffer`) :**
```c
typedef struct Buffer {
    void *data;
    size_t length;
    size_t capacity;
} Buffer;

Buffer *create_buffer(size_t size) {
    Buffer *buf = malloc(sizeof(Buffer));
    buf->data = malloc(size);
    buf->length = size;
    buf->capacity = size;
    return buf;
}
```
- Suit la taille et la capacitÃ©
- VÃ©rification des limites Ã  l'accÃ¨s
- NÃ©cessite toujours une libÃ©ration manuelle

### Types allouÃ©s sur le tas

**ChaÃ®nes :**
- Tableau d'octets UTF-8 sur le tas
- TerminÃ© par null pour l'interopÃ©rabilitÃ© C
- Mutable (peut modifier sur place)
- Comptage de rÃ©fÃ©rences (auto-libÃ©rÃ© quand la portÃ©e se termine)

**Objets :**
- Tableau de champs dynamique
- Noms et valeurs des champs sur le tas
- Comptage de rÃ©fÃ©rences (auto-libÃ©rÃ© quand la portÃ©e se termine)
- RÃ©fÃ©rences circulaires possibles (gÃ©rÃ© avec suivi d'ensemble visitÃ©)

**Tableaux :**
- Croissance par doublement de capacitÃ© dynamique
- Les Ã©lÃ©ments sont des structures Value intÃ©grÃ©es
- RÃ©allocation automatique lors de la croissance
- Comptage de rÃ©fÃ©rences (auto-libÃ©rÃ© quand la portÃ©e se termine)

**Closures :**
- Capture l'environnement par rÃ©fÃ©rence
- L'environnement est allouÃ© sur le tas
- Les environnements de closure sont correctement libÃ©rÃ©s quand ils ne sont plus rÃ©fÃ©rencÃ©s

---

## ModÃ¨le de concurrence

### Architecture de threading

Hemlock utilise le **threading 1:1** avec les threads POSIX (pthreads) :

```
TÃ¢che utilisateur       Thread OS          CÅ“ur CPU
----------------        ---------          --------
spawn(f1) ------>  pthread_create --> CÅ“ur 0
spawn(f2) ------>  pthread_create --> CÅ“ur 1
spawn(f3) ------>  pthread_create --> CÅ“ur 2
```

**CaractÃ©ristiques clÃ©s :**
- Chaque `spawn()` crÃ©e un nouveau pthread
- Le noyau planifie les threads sur les cÅ“urs
- Vraie exÃ©cution parallÃ¨le (pas de GIL)
- MultitÃ¢che prÃ©emptif

### ImplÃ©mentation des tÃ¢ches

```c
typedef struct Task {
    pthread_t thread;        // Handle de thread OS
    Value result;            // Valeur de retour
    char *error;             // Message d'exception (si levÃ©e)
    pthread_mutex_t lock;    // ProtÃ¨ge l'Ã©tat
    TaskState state;         // RUNNING, FINISHED, ERROR
} Task;
```

**Cycle de vie d'une tÃ¢che :**
1. `spawn(func, args)` â†’ CrÃ©er Task, dÃ©marrer pthread
2. Le thread exÃ©cute la fonction avec les arguments
3. Au retour : Stocker le rÃ©sultat, dÃ©finir l'Ã©tat Ã  FINISHED
4. Sur exception : Stocker le message d'erreur, dÃ©finir l'Ã©tat Ã  ERROR
5. `join(task)` â†’ Attendre le thread, retourner le rÃ©sultat ou lever l'exception

### ImplÃ©mentation des canaux

```c
typedef struct Channel {
    void **buffer;           // Buffer circulaire de Value*
    size_t capacity;         // Maximum d'Ã©lÃ©ments en buffer
    size_t count;            // Ã‰lÃ©ments actuels dans le buffer
    size_t read_index;       // Prochaine position de lecture
    size_t write_index;      // Prochaine position d'Ã©criture
    bool closed;             // Indicateur de canal fermÃ©
    pthread_mutex_t lock;    // ProtÃ¨ge le buffer
    pthread_cond_t not_full; // Signal quand de l'espace est disponible
    pthread_cond_t not_empty;// Signal quand des donnÃ©es sont disponibles
} Channel;
```

**OpÃ©ration d'envoi :**
1. Verrouiller le mutex
2. Attendre si le buffer est plein (cond_wait sur not_full)
3. Ã‰crire la valeur dans buffer[write_index]
4. IncrÃ©menter write_index (circulaire)
5. Signaler not_empty
6. DÃ©verrouiller le mutex

**OpÃ©ration de rÃ©ception :**
1. Verrouiller le mutex
2. Attendre si le buffer est vide (cond_wait sur not_empty)
3. Lire la valeur depuis buffer[read_index]
4. IncrÃ©menter read_index (circulaire)
5. Signaler not_full
6. DÃ©verrouiller le mutex

**Garanties de synchronisation :**
- Envoi/rÃ©ception thread-safe (protÃ©gÃ© par mutex)
- SÃ©mantique bloquante (le producteur attend si plein, le consommateur attend si vide)
- Livraison ordonnÃ©e (FIFO dans un canal)

---

## Plans futurs

### TerminÃ© : Backend compilateur

Le backend compilateur (`hemlockc`) a Ã©tÃ© implÃ©mentÃ© avec :
- GÃ©nÃ©ration de code C depuis l'AST
- VÃ©rification de types Ã  la compilation (activÃ©e par dÃ©faut)
- BibliothÃ¨que runtime (`libhemlock_runtime.a`)
- ParitÃ© complÃ¨te avec l'interprÃ©teur (98% de taux de rÃ©ussite des tests)
- Framework d'optimisation par dÃ©ballage

### Focus actuel : AmÃ©liorations du systÃ¨me de types

**AmÃ©liorations rÃ©centes :**
- SystÃ¨mes de vÃ©rification et d'infÃ©rence de types unifiÃ©s
- VÃ©rification de types Ã  la compilation activÃ©e par dÃ©faut
- Option `--check` pour la validation de types uniquement
- Contexte de type passÃ© au codegen pour les indices d'optimisation

### AmÃ©liorations futures

**Ajouts potentiels :**
- GÃ©nÃ©riques/templates
- Pattern matching
- IntÃ©gration LSP pour le support IDE avec conscience des types
- Optimisations de dÃ©ballage plus agressives
- Analyse d'Ã©chappement pour l'allocation sur la pile

### Optimisations Ã  long terme

**AmÃ©liorations possibles :**
- Cache en ligne pour les appels de mÃ©thode
- Compilation JIT pour les chemins de code chauds
- Planificateur avec vol de travail pour une meilleure concurrence
- Optimisation guidÃ©e par le profilage

---

## Directives d'implÃ©mentation

### Ajouter de nouvelles fonctionnalitÃ©s

Lors de l'implÃ©mentation de nouvelles fonctionnalitÃ©s, suivez ces directives :

**1. Choisir le bon module :**
- Nouveaux types de valeur â†’ `values.c`
- Conversions de type â†’ `types.c`
- Fonctions intÃ©grÃ©es â†’ `builtins.c`
- OpÃ©rations E/S â†’ `io.c`
- Flux de contrÃ´le â†’ `runtime.c`

**2. Mettre Ã  jour toutes les couches :**
- Ajouter les types de nÅ“ud AST si nÃ©cessaire (`ast.h`, `ast.c`)
- Ajouter les tokens du lexer si nÃ©cessaire (`lexer.c`)
- Ajouter les rÃ¨gles du parser (`parser.c`)
- ImplÃ©menter le comportement d'exÃ©cution (`runtime.c` ou module appropriÃ©)
- Ajouter les tests (`tests/`)

**3. Maintenir la cohÃ©rence :**
- Suivre le style de code existant
- Utiliser des conventions de nommage cohÃ©rentes
- Documenter l'API publique dans les en-tÃªtes
- Garder les messages d'erreur clairs et cohÃ©rents

**4. Tester minutieusement :**
- Ajouter les cas de test avant d'implÃ©menter
- Tester les chemins de succÃ¨s et d'erreur
- Tester les cas limites
- VÃ©rifier l'absence de fuites mÃ©moire (valgrind)

### ConsidÃ©rations de performance

**Goulots d'Ã©tranglement actuels :**
- Recherches HashMap pour l'accÃ¨s aux variables
- Appels de fonction rÃ©cursifs (pas d'optimisation des appels terminaux)
- ConcatÃ©nation de chaÃ®nes (alloue une nouvelle chaÃ®ne Ã  chaque fois)
- Surcharge de vÃ©rification de type Ã  chaque opÃ©ration

**OpportunitÃ©s d'optimisation :**
- Mettre en cache les emplacements de variables (cache en ligne)
- Optimisation des appels terminaux
- StringBuilder pour la concatÃ©nation
- InfÃ©rence de type pour Ã©viter les vÃ©rifications Ã  l'exÃ©cution

### Conseils de dÃ©bogage

**Outils utiles :**
- `valgrind` - DÃ©tection des fuites mÃ©moire
- `gdb` - DÃ©bogage des crashs
- Option `-g` - Symboles de dÃ©bogage
- DÃ©bogage avec `printf` - Simple mais efficace

**ProblÃ¨mes courants :**
- Segfault â†’ DÃ©rÃ©fÃ©rencement de pointeur null (vÃ©rifier les valeurs de retour)
- Fuite mÃ©moire â†’ Appel free() manquant (vÃ©rifier les chemins de value_free)
- Erreur de type â†’ VÃ©rifier la logique de type_convert() et type_check()
- Crash dans les threads â†’ Condition de course (vÃ©rifier l'utilisation des mutex)

---

## Conclusion

L'implÃ©mentation de Hemlock priorise :
- **ModularitÃ©** - SÃ©paration nette des prÃ©occupations
- **SimplicitÃ©** - ImplÃ©mentation directe
- **Explicitation** - Pas de magie cachÃ©e
- **MaintenabilitÃ©** - Facile Ã  comprendre et modifier

L'interprÃ©teur actuel par parcours d'arbre est intentionnellement simple pour faciliter le dÃ©veloppement rapide de fonctionnalitÃ©s et l'expÃ©rimentation. Le futur backend compilateur amÃ©liorera les performances tout en maintenant la mÃªme sÃ©mantique.


--------------------------------------------------------------------------------
## Philosophie
--------------------------------------------------------------------------------

# Philosophie de conception du langage Hemlock

> "Un petit langage non sÃ©curisÃ© pour Ã©crire des choses non sÃ©curisÃ©es en toute sÃ©curitÃ©."

Ce document prÃ©sente les principes et la philosophie de conception fondamentaux de Hemlock. Lisez-le avant d'apporter des modifications ou des ajouts au langage.

---

## Table des matiÃ¨res

- [IdentitÃ© fondamentale](#identitÃ©-fondamentale)
- [Principes de conception](#principes-de-conception)
- [Philosophie sur la sÃ©curitÃ©](#philosophie-sur-la-sÃ©curitÃ©)
- [Ce qu'il ne faut PAS ajouter](#ce-quil-ne-faut-pas-ajouter)
- [ConsidÃ©rations futures](#considÃ©rations-futures)
- [RÃ©flexions finales](#rÃ©flexions-finales)

---

## IdentitÃ© fondamentale

Hemlock est un **langage de script systÃ¨me** qui adopte la gestion manuelle de la mÃ©moire et le contrÃ´le explicite. Il est conÃ§u pour les programmeurs qui veulent :

- La puissance du C
- L'ergonomie des langages de script modernes
- La concurrence asynchrone structurÃ©e intÃ©grÃ©e
- Aucun comportement cachÃ© ni magie

### Ce que Hemlock N'EST PAS

- **SÃ©curisÃ© en mÃ©moire** (les pointeurs invalides sont de votre responsabilitÃ©)
- **Un remplacement pour Rust, Go ou Lua**
- **Un langage qui vous cache la complexitÃ©**

### Ce que Hemlock EST

- **Explicite plutÃ´t qu'implicite, toujours**
- **Ã‰ducatif et expÃ©rimental**
- **Une "couche de script C" pour le travail systÃ¨me**
- **HonnÃªte sur les compromis**

---

## Principes de conception

### 1. Explicite plutÃ´t qu'implicite

Hemlock favorise l'explicitation dans toutes les constructions du langage. Il ne devrait y avoir aucune surprise, aucune magie et aucun comportement cachÃ©.

**Mauvais (implicite) :**
```hemlock
let x = 5  // Point-virgule manquant - devrait gÃ©nÃ©rer une erreur
```

**Bon (explicite) :**
```hemlock
let x = 5;
free(ptr);  // Vous l'avez allouÃ©, vous le libÃ©rez
```

**Aspects clÃ©s :**
- Les points-virgules sont obligatoires (pas d'insertion automatique)
- Pas de ramasse-miettes (garbage collection)
- Gestion manuelle de la mÃ©moire (alloc/free)
- Les annotations de type sont optionnelles mais vÃ©rifiÃ©es Ã  l'exÃ©cution
- Pas de nettoyage automatique des ressources (pas de RAII), mais `defer` fournit un nettoyage explicite

### 2. Dynamique par dÃ©faut, typÃ© par choix

Chaque valeur possÃ¨de une Ã©tiquette de type Ã  l'exÃ©cution, mais le systÃ¨me est conÃ§u pour Ãªtre flexible tout en dÃ©tectant les erreurs.

**InfÃ©rence de type :**
- Petits entiers (tient dans i32) : `42` â†’ `i32`
- Grands entiers (> plage i32) : `9223372036854775807` â†’ `i64`
- Flottants : `3.14` â†’ `f64`

**Typage explicite si nÃ©cessaire :**
```hemlock
let x = 42;              // i32 infÃ©rÃ© (petite valeur)
let y: u8 = 255;         // u8 explicite
let z = x + y;           // promu en i32
let big = 5000000000;    // i64 infÃ©rÃ© (> max i32)
```

**Les rÃ¨gles de promotion de type** suivent une hiÃ©rarchie claire du plus petit au plus grand, les flottants l'emportant toujours sur les entiers.

### 3. L'insÃ©curitÃ© est une fonctionnalitÃ©, pas un bug

Hemlock n'essaie pas de prÃ©venir toutes les erreurs. Au lieu de cela, il vous donne les outils pour Ãªtre en sÃ©curitÃ© tout en vous permettant d'opter pour un comportement non sÃ©curisÃ© si nÃ©cessaire.

**Exemples d'insÃ©curitÃ© intentionnelle :**
- L'arithmÃ©tique des pointeurs peut dÃ©border (responsabilitÃ© de l'utilisateur)
- Pas de vÃ©rification des limites sur `ptr` brut (utilisez `buffer` si vous voulez la sÃ©curitÃ©)
- Les crashs de double libÃ©ration sont autorisÃ©s (gestion manuelle de la mÃ©moire)
- Le systÃ¨me de types prÃ©vient les accidents mais permet les piÃ¨ges si nÃ©cessaire

```hemlock
let p = alloc(10);
let q = p + 100;  // Bien au-delÃ  de l'allocation - autorisÃ© mais dangereux
```

**La philosophie :** Le systÃ¨me de types devrait prÃ©venir les *accidents* mais autoriser les opÃ©rations non sÃ©curisÃ©es *intentionnelles*.

### 4. Concurrence structurÃ©e de premiÃ¨re classe

La concurrence n'est pas une rÃ©flexion aprÃ¨s coup dans Hemlock. Elle est intÃ©grÃ©e au langage dÃ¨s le dÃ©part.

**FonctionnalitÃ©s clÃ©s :**
- `async`/`await` intÃ©grÃ©s au langage
- Canaux pour la communication
- `spawn`/`join`/`detach` pour la gestion des tÃ¢ches
- Pas de threads bruts, pas de verrous - structurÃ© uniquement
- Vrai parallÃ©lisme multi-thread utilisant les threads POSIX

**Ce n'est pas une boucle d'Ã©vÃ©nements ni des green threads** - Hemlock utilise de vrais threads du systÃ¨me d'exploitation pour un vrai parallÃ©lisme sur plusieurs cÅ“urs CPU.

### 5. Syntaxe proche du C, peu de cÃ©rÃ©monie

Hemlock devrait sembler familier aux programmeurs systÃ¨me tout en rÃ©duisant le code rÃ©pÃ©titif.

**Choix de conception :**
- Blocs `{}` toujours, pas d'accolades optionnelles
- Les opÃ©rateurs correspondent au C : `+`, `-`, `*`, `/`, `&&`, `||`, `!`
- La syntaxe de type correspond Ã  Rust/TypeScript : `let x: type = value;`
- Les fonctions sont des valeurs de premiÃ¨re classe
- Minimum de mots-clÃ©s et de formes spÃ©ciales

---

## Philosophie sur la sÃ©curitÃ©

**La position de Hemlock sur la sÃ©curitÃ© :**

> "Nous vous donnons les outils pour Ãªtre en sÃ©curitÃ© (`buffer`, annotations de type, vÃ©rification des limites) mais nous ne vous forÃ§ons pas Ã  les utiliser (`ptr`, mÃ©moire manuelle, opÃ©rations non sÃ©curisÃ©es).
>
> Le comportement par dÃ©faut devrait guider vers la sÃ©curitÃ©, mais la porte de sortie devrait toujours Ãªtre disponible."

### Outils de sÃ©curitÃ© fournis

**1. Type buffer sÃ©curisÃ© :**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // vÃ©rifiÃ© aux limites
print(b.length);        // 64
free(b);                // toujours manuel
```

**2. Pointeurs bruts non sÃ©curisÃ©s :**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // Vous devez penser Ã  libÃ©rer
```

**3. Annotations de type :**
```hemlock
let x: u8 = 255;   // OK
let y: u8 = 256;   // ERREUR : hors plage
```

**4. VÃ©rification de type Ã  l'exÃ©cution :**
```hemlock
let val = some_function();
if (typeof(val) == "i32") {
    // SÃ»r de l'utiliser comme entier
}
```

### Principes directeurs

1. **Par dÃ©faut, utiliser des modÃ¨les sÃ»rs dans la documentation** - Montrer `buffer` avant `ptr`, encourager les annotations de type
2. **Rendre les opÃ©rations non sÃ©curisÃ©es Ã©videntes** - L'arithmÃ©tique des pointeurs bruts devrait sembler intentionnelle
3. **Fournir des portes de sortie** - Ne pas empÃªcher les utilisateurs expÃ©rimentÃ©s de faire du travail bas niveau
4. **ÃŠtre honnÃªte sur les compromis** - Documenter ce qui peut mal tourner

### Exemples de sÃ©curitÃ© vs insÃ©curitÃ©

| ModÃ¨le sÃ»r | ModÃ¨le non sÃ»r | Quand utiliser le non sÃ»r |
|------------|----------------|---------------------------|
| Type `buffer` | Type `ptr` | FFI, code critique en performance |
| Annotations de type | Pas d'annotations | Interfaces externes, validation |
| AccÃ¨s vÃ©rifiÃ© aux limites | ArithmÃ©tique de pointeurs | OpÃ©rations mÃ©moire bas niveau |
| Gestion des exceptions | Retour de null/codes d'erreur | Quand les exceptions sont trop lourdes |

---

## Ce qu'il ne faut PAS ajouter

Comprendre ce qu'il **ne faut pas** ajouter est aussi important que savoir quoi ajouter.

### Ne pas ajouter de comportement implicite

**Mauvais exemples :**

```hemlock
// MAUVAIS : Insertion automatique de point-virgule
let x = 5
let y = 10

// MAUVAIS : Conversions de type implicites qui perdent en prÃ©cision
let x: i32 = 3.14  // Devrait tronquer ou gÃ©nÃ©rer une erreur ?
```

**Pourquoi :** Le comportement implicite crÃ©e des surprises et rend le code plus difficile Ã  comprendre.

### Ne pas cacher la complexitÃ©

**Mauvais exemples :**

```hemlock
// MAUVAIS : Optimisation magique en coulisses
let arr = [1, 2, 3]  // Est-ce sur la pile ou le tas ? L'utilisateur devrait savoir ! (Tas, comptage de rÃ©fÃ©rences)

// MAUVAIS : Pointeur brut auto-libÃ©rÃ©
let p = alloc(100)  // Est-ce auto-libÃ©rÃ© ? NON ! Les ptr bruts nÃ©cessitent toujours free()
```

**Note sur le comptage de rÃ©fÃ©rences :** Hemlock utilise le comptage de rÃ©fÃ©rences interne pour les chaÃ®nes, tableaux, objets et buffers - ceux-ci SONT auto-libÃ©rÃ©s quand la portÃ©e se termine. C'est explicite et prÃ©visible (nettoyage dÃ©terministe quand la rÃ©fÃ©rence atteint 0, pas de pauses GC). Les pointeurs bruts (`ptr` de `alloc()`) ne sont PAS comptÃ©s par rÃ©fÃ©rence et nÃ©cessitent toujours `free()` manuel.

**Pourquoi :** La complexitÃ© cachÃ©e rend impossible de prÃ©dire les performances et de dÃ©boguer les problÃ¨mes.

### Ne pas casser les sÃ©mantiques existantes

**Ne jamais changer ces dÃ©cisions fondamentales :**
- Les points-virgules sont obligatoires - ne pas les rendre optionnels
- Gestion manuelle de la mÃ©moire - ne pas ajouter de GC
- ChaÃ®nes mutables - ne pas les rendre immuables
- VÃ©rification de type Ã  l'exÃ©cution - ne pas la supprimer

**Pourquoi :** La cohÃ©rence et la stabilitÃ© sont plus importantes que les fonctionnalitÃ©s Ã  la mode.

### Ne pas ajouter de fonctionnalitÃ©s "pratiques" qui rÃ©duisent l'explicitation

**Exemples de fonctionnalitÃ©s Ã  Ã©viter :**
- Surcharge d'opÃ©rateurs (peut-Ãªtre pour les types utilisateur, mais avec prudence)
- Coercition de type implicite qui perd de l'information
- Nettoyage automatique des ressources (RAII)
- ChaÃ®nage de mÃ©thodes qui cache la complexitÃ©
- DSL et syntaxe magique

**Exception :** Les fonctionnalitÃ©s de commoditÃ© sont OK si elles sont du **sucre syntaxique explicite** sur des opÃ©rations simples :
- `else if` est bien (ce sont juste des instructions if imbriquÃ©es)
- L'interpolation de chaÃ®nes pourrait Ãªtre OK si c'est clairement du sucre syntaxique
- La syntaxe de mÃ©thode pour les objets est bien (c'est explicite ce que Ã§a fait)

---

## ConsidÃ©rations futures

### Peut-Ãªtre ajouter (en discussion)

Ces fonctionnalitÃ©s s'alignent avec la philosophie de Hemlock mais nÃ©cessitent une conception soignÃ©e :

**1. Pattern matching (correspondance de motifs)**
```hemlock
match (value) {
    case i32: print("entier");
    case string: print("texte");
    case _: print("autre");
}
```
- VÃ©rification de type explicite
- Pas de coÃ»ts cachÃ©s
- VÃ©rification d'exhaustivitÃ© Ã  la compilation possible

**2. Types d'erreur (`Result<T, E>`)**
```hemlock
fn divide(a: i32, b: i32): Result<i32, string> {
    if (b == 0) {
        return Err("division par zÃ©ro");
    }
    return Ok(a / b);
}
```
- Gestion d'erreur explicite
- Force les utilisateurs Ã  penser aux erreurs
- Alternative aux exceptions

**3. Types tableau/slice**
- Nous avons dÃ©jÃ  des tableaux dynamiques
- Pourrait ajouter des tableaux de taille fixe pour l'allocation sur la pile
- Devrait Ãªtre explicite sur pile vs tas

**4. Outils de sÃ©curitÃ© mÃ©moire amÃ©liorÃ©s**
- Option de vÃ©rification des limites
- DÃ©tection des fuites mÃ©moire en mode debug
- IntÃ©gration des sanitizers

### Probablement jamais ajouter

Ces fonctionnalitÃ©s violent les principes fondamentaux :

**1. Ramasse-miettes (garbage collection)**
- Cache la complexitÃ© de la gestion mÃ©moire
- Performances imprÃ©visibles
- Contre le principe de contrÃ´le explicite

**2. Gestion automatique de la mÃ©moire**
- MÃªmes raisons que le GC
- Le comptage de rÃ©fÃ©rences pourrait Ãªtre OK s'il est explicite

**3. Conversions de type implicites qui perdent des donnÃ©es**
- Va contre "explicite plutÃ´t qu'implicite"
- Source de bugs subtils

**4. Macros (complexes)**
- Trop de puissance, trop de complexitÃ©
- Un systÃ¨me de macros simple pourrait Ãªtre OK
- PrÃ©fÃ©rer la gÃ©nÃ©ration de code ou les fonctions

**5. POO basÃ©e sur les classes avec hÃ©ritage**
- Trop de comportement implicite
- Le duck typing et les objets sont suffisants
- Composition plutÃ´t qu'hÃ©ritage

**6. SystÃ¨me de modules avec rÃ©solution complexe**
- Garder les imports simples et explicites
- Pas de chemins de recherche magiques
- Pas de rÃ©solution de version (utiliser le gestionnaire de paquets de l'OS)

---

## RÃ©flexions finales

### Confiance et responsabilitÃ©

Hemlock est une question de **confiance et responsabilitÃ©**. Nous faisons confiance au programmeur pour :

- GÃ©rer la mÃ©moire correctement
- Utiliser les types de maniÃ¨re appropriÃ©e
- GÃ©rer les erreurs correctement
- Comprendre les compromis

En retour, Hemlock fournit :

- Pas de coÃ»ts cachÃ©s
- Pas de comportement surprise
- ContrÃ´le total quand nÃ©cessaire
- Outils de sÃ©curitÃ© quand souhaitÃ©

### La question directrice

**Quand vous considÃ©rez une nouvelle fonctionnalitÃ©, demandez-vous :**

> "Est-ce que cela donne au programmeur plus de contrÃ´le explicite, ou est-ce que cela cache quelque chose ?"

- Si cela **ajoute du contrÃ´le explicite** â†’ convient probablement Ã  Hemlock
- Si cela **cache de la complexitÃ©** â†’ n'appartient probablement pas
- Si c'est du **sucre optionnel** clairement documentÃ© â†’ pourrait Ãªtre OK

### Exemples de bons ajouts

Les **instructions switch** - Flux de contrÃ´le explicite, pas de magie, sÃ©mantique claire

L'**async/await avec pthreads** - Concurrence explicite, vrai parallÃ©lisme, l'utilisateur contrÃ´le le lancement

Le **type Buffer Ã  cÃ´tÃ© de ptr** - Donne le choix entre sÃ»r et non sÃ»r

Les **annotations de type optionnelles** - Aide Ã  dÃ©tecter les bugs sans forcer la rigueur

**Try/catch/finally** - Gestion d'erreur explicite avec flux de contrÃ´le clair

### Exemples de mauvais ajouts

L'**insertion automatique de point-virgule** - Cache les erreurs de syntaxe, rend le code ambigu

Le **RAII/destructeurs** - Le nettoyage automatique cache quand les ressources sont libÃ©rÃ©es

La **coalescence null implicite** - Cache les vÃ©rifications de null, rend le code plus difficile Ã  comprendre

Les **chaÃ®nes Ã  croissance automatique** - Cache l'allocation mÃ©moire, performances imprÃ©visibles

---

## Conclusion

Hemlock n'essaie pas d'Ãªtre le langage le plus sÃ»r, le plus rapide ou le plus riche en fonctionnalitÃ©s.

**Hemlock essaie d'Ãªtre le langage le plus *honnÃªte*.**

Il vous dit exactement ce qu'il fait, vous donne le contrÃ´le quand vous en avez besoin, et ne cache pas les bords tranchants. C'est un langage pour les personnes qui veulent comprendre leur code Ã  bas niveau tout en profitant d'une ergonomie moderne.

Si vous n'Ãªtes pas sÃ»r qu'une fonctionnalitÃ© appartient Ã  Hemlock, souvenez-vous :

> **Explicite plutÃ´t qu'implicite, toujours.**
> **L'insÃ©curitÃ© est une fonctionnalitÃ©, pas un bug.**
> **L'utilisateur est responsable, et c'est OK.**


--------------------------------------------------------------------------------
## Syntaxe des Signatures
--------------------------------------------------------------------------------

# Conception de la syntaxe des signatures

> Extension du systÃ¨me de types de Hemlock avec les types fonction, les modificateurs nullable, les alias de type, les paramÃ¨tres const et les signatures de mÃ©thode.

**Statut :** ImplÃ©mentÃ© (v1.7.0)
**Version :** 1.0
**Auteur :** Claude

---

## AperÃ§u

Ce document propose cinq extensions du systÃ¨me de types interconnectÃ©es qui s'appuient sur l'infrastructure existante de Hemlock :

1. **Annotations de type fonction** - Types fonction de premiÃ¨re classe
2. **Modificateurs de type nullable** - Gestion explicite de null (Ã©tend le flag `nullable` existant)
3. **Alias de type** - AbrÃ©viations de type nommÃ©es
4. **ParamÃ¨tres const** - Contrats d'immuabilitÃ©
5. **Signatures de mÃ©thode dans define** - Comportement de type interface

Ces fonctionnalitÃ©s partagent la philosophie : **explicite plutÃ´t qu'implicite, optionnel mais appliquÃ© quand utilisÃ©**.

---

## 1. Annotations de type fonction

### Motivation

Actuellement, il n'y a pas de moyen d'exprimer la signature d'une fonction comme type :

```hemlock
// Actuel : callback n'a pas d'information de type
fn map(arr: array, callback) { ... }

// ProposÃ© : type fonction explicite
fn map(arr: array, callback: fn(any, i32): any): array { ... }
```

### Syntaxe

```hemlock
// Type fonction basique
fn(i32, i32): i32

// Avec noms de paramÃ¨tres (documentation seulement, non appliquÃ©)
fn(a: i32, b: i32): i32

// Pas de valeur de retour (void)
fn(string): void
fn(string)              // Raccourci : omettre `: void`

// Retour nullable
fn(i32): string?

// ParamÃ¨tres optionnels
fn(name: string, age?: i32): void

// ParamÃ¨tres rest
fn(...args: array): i32

// Pas de paramÃ¨tres
fn(): bool

// Ordre supÃ©rieur : fonction retournant une fonction
fn(i32): fn(i32): i32

// Type fonction asynchrone
async fn(i32): i32
```

### Exemples d'utilisation

```hemlock
// Variable avec type fonction
let add: fn(i32, i32): i32 = fn(a, b) { return a + b; };

// ParamÃ¨tre de fonction
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Le type de retour est une fonction
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Tableau de fonctions
let ops: array<fn(i32, i32): i32> = [add, subtract, multiply];

// Champ d'objet
define EventHandler {
    name: string;
    callback: fn(Event): void;
}
```

### Modifications de l'AST

```c
// Dans l'enum TypeKind (include/ast.h)
typedef enum {
    // ... types existants ...
    TYPE_FUNCTION,      // NOUVEAU : Type fonction
} TypeKind;

// Dans la struct Type (include/ast.h)
struct Type {
    TypeKind kind;
    // ... champs existants ...

    // Pour TYPE_FUNCTION :
    struct Type **param_types;      // Types des paramÃ¨tres
    char **param_names;             // Noms des paramÃ¨tres optionnels (docs)
    int *param_optional;            // Quels paramÃ¨tres sont optionnels
    int num_params;
    char *rest_param_name;          // Nom du paramÃ¨tre rest ou NULL
    struct Type *rest_param_type;   // Type du paramÃ¨tre rest
    struct Type *return_type;       // Type de retour (NULL = void)
    int is_async;                   // Type fn async
};
```

### Analyse syntaxique

Les types fonction commencent par `fn` (ou `async fn`) suivi de la liste des paramÃ¨tres :

```
function_type := ["async"] "fn" "(" [param_type_list] ")" [":" type]
param_type_list := param_type ("," param_type)*
param_type := [identifier ":"] ["?"] type | "..." [identifier] [":" type]
```

**DÃ©sambiguÃ¯sation :** Lors de l'analyse d'un type et que `fn` est rencontrÃ© :
- Si suivi de `(`, c'est un type fonction
- Sinon, erreur de syntaxe (`fn` seul n'est pas un type valide)

### CompatibilitÃ© de types

```hemlock
// Correspondance exacte requise pour les types fonction
let f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // OK

// Contravariance des paramÃ¨tres (accepter des types plus larges est OK)
let g: fn(any): i32 = fn(x: i32): i32 { return x; };  // OK : i32 <: any

// Covariance du retour (retourner des types plus Ã©troits est OK)
let h: fn(i32): any = fn(x: i32): i32 { return x; };  // OK : i32 <: any

// L'aritÃ© doit correspondre
let bad: fn(i32): i32 = fn(a, b) { return a; };       // ERREUR : aritÃ© diffÃ©rente

// ParamÃ¨tres optionnels compatibles avec les requis
let opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // OK
```

---

## 2. Modificateurs de type nullable

### Motivation

Le suffixe `?` rend l'acceptation de null explicite dans les signatures :

```hemlock
// Actuel : pas clair si null est valide
fn find(arr: array, val: any): i32 { ... }

// ProposÃ© : retour nullable explicite
fn find(arr: array, val: any): i32? { ... }
```

### Syntaxe

```hemlock
// Types nullable avec suffixe ?
string?           // string ou null
i32?              // i32 ou null
User?             // User ou null
array<i32>?       // array ou null
fn(i32): i32?     // fonction retournant i32 ou null

// Composition avec les types fonction
fn(string?): i32          // Accepte string ou null
fn(string): i32?          // Retourne i32 ou null
fn(string?): i32?         // Les deux nullable

// Dans define
define Result {
    value: any?;
    error: string?;
}
```

### Notes d'implÃ©mentation

**Existe dÃ©jÃ  :** Le flag `Type.nullable` est dÃ©jÃ  dans l'AST. Cette fonctionnalitÃ© nÃ©cessite principalement :
1. Support du parser pour le suffixe `?` sur tout type (vÃ©rifier/Ã©tendre)
2. Composition correcte avec les types fonction
3. Application Ã  l'exÃ©cution

### CompatibilitÃ© de types

```hemlock
// Non-nullable assignable Ã  nullable
let x: i32? = 42;           // OK
let y: i32? = null;         // OK

// Nullable NON assignable Ã  non-nullable
let z: i32 = x;             // ERREUR : x pourrait Ãªtre null

// Coalescence null pour dÃ©baller
let z: i32 = x ?? 0;        // OK : ?? fournit une valeur par dÃ©faut

// Le chaÃ®nage optionnel retourne nullable
let name: string? = user?.name;
```

---

## 3. Alias de type

### Motivation

Les types complexes bÃ©nÃ©ficient d'abrÃ©viations nommÃ©es :

```hemlock
// Actuel : types composÃ©s rÃ©pÃ©titifs
fn process(entity: HasName & HasId & HasTimestamp) { ... }
fn validate(entity: HasName & HasId & HasTimestamp) { ... }

// ProposÃ© : alias nommÃ©
type Entity = HasName & HasId & HasTimestamp;
fn process(entity: Entity) { ... }
fn validate(entity: Entity) { ... }
```

### Syntaxe

```hemlock
// Alias basique
type Integer = i32;
type Text = string;

// Alias de type composÃ©
type Entity = HasName & HasId;
type Auditable = HasCreatedAt & HasUpdatedAt & HasCreatedBy;

// Alias de type fonction
type Callback = fn(Event): void;
type Predicate = fn(any): bool;
type Reducer = fn(acc: any, val: any): any;
type AsyncTask = async fn(): any;

// Alias nullable
type OptionalString = string?;

// Alias gÃ©nÃ©rique (si nous supportons les alias de type gÃ©nÃ©riques)
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };

// Alias de type tableau
type IntArray = array<i32>;
type Matrix = array<array<f64>>;
```

### PortÃ©e et visibilitÃ©

```hemlock
// PortÃ©e module par dÃ©faut
type Callback = fn(Event): void;

// Exportable
export type Handler = fn(Request): Response;

// Dans un autre fichier
import { Handler } from "./handlers.hml";
fn register(h: Handler) { ... }
```

### Modifications de l'AST

```c
// Nouveau type d'instruction
typedef enum {
    // ... instructions existantes ...
    STMT_TYPE_ALIAS,    // NOUVEAU
} StmtKind;

// Dans l'union Stmt
struct {
    char *name;                 // Nom de l'alias
    char **type_params;         // ParamÃ¨tres gÃ©nÃ©riques : <T, U>
    int num_type_params;
    Type *aliased_type;         // Le type rÃ©el
} type_alias;
```

### Analyse syntaxique

```
type_alias := "type" identifier ["<" type_params ">"] "=" type ";"
```

**Note :** `type` est un nouveau mot-clÃ©. VÃ©rifier les conflits avec les identifiants existants.

### RÃ©solution

Les alias de type sont rÃ©solus Ã  :
- **Temps d'analyse :** L'alias est enregistrÃ© dans l'environnement de types
- **Temps de vÃ©rification :** L'alias est dÃ©veloppÃ© vers le type sous-jacent
- **ExÃ©cution :** L'alias est transparent (mÃªme que le type sous-jacent)

```hemlock
type MyInt = i32;
let x: MyInt = 42;
typeof(x);           // "i32" (pas "MyInt")
```

---

## 4. ParamÃ¨tres const

### Motivation

Signaler l'intention d'immuabilitÃ© dans les signatures de fonction :

```hemlock
// Actuel : pas clair si array sera modifiÃ©
fn print_all(items: array) { ... }

// ProposÃ© : contrat d'immuabilitÃ© explicite
fn print_all(const items: array) { ... }
```

### Syntaxe

```hemlock
// ParamÃ¨tre const
fn process(const data: buffer) {
    // data[0] = 0;        // ERREUR : impossible de muter const
    let x = data[0];       // OK : lecture autorisÃ©e
    return x;
}

// Plusieurs paramÃ¨tres const
fn compare(const a: array, const b: array): bool { ... }

// MÃ©lange const et mutable
fn update(const source: array, target: array) {
    for (item in source) {
        target.push(item);   // OK : target est mutable
    }
}

// Const avec infÃ©rence de type
fn log(const msg) {
    print(msg);
}

// Const dans les types fonction
type Reader = fn(const buffer): i32;
```

### Ce que const empÃªche

```hemlock
fn bad(const arr: array) {
    arr.push(1);         // ERREUR : mÃ©thode de mutation
    arr.pop();           // ERREUR : mÃ©thode de mutation
    arr[0] = 5;          // ERREUR : affectation par index
    arr.clear();         // ERREUR : mÃ©thode de mutation
}

fn ok(const arr: array) {
    let x = arr[0];      // OK : lecture
    let len = len(arr);  // OK : vÃ©rification de longueur
    let copy = arr.slice(0, 10);  // OK : crÃ©e un nouveau tableau
    for (item in arr) {  // OK : itÃ©ration
        print(item);
    }
}
```

### MÃ©thodes mutantes vs non-mutantes

| Type | Mutantes (bloquÃ©es par const) | Non-mutantes (autorisÃ©es) |
|------|-------------------------------|---------------------------|
| array | push, pop, shift, unshift, insert, remove, clear, reverse (sur place) | slice, concat, map, filter, find, contains, first, last, join |
| string | affectation par index (`s[0] = 'x'`) | toutes les mÃ©thodes (retournent de nouvelles chaÃ®nes) |
| buffer | affectation par index, memset, memcpy (vers) | lecture par index, slice |
| object | affectation de champ | lecture de champ |

### Modifications de l'AST

```c
// Dans l'expression fonction (include/ast.h)
struct {
    // ... champs existants ...
    int *param_is_const;    // NOUVEAU : 1 si const, 0 sinon
} function;

// Dans la struct Type pour les types fonction
struct Type {
    // ... champs existants ...
    int *param_is_const;    // Pour TYPE_FUNCTION
};
```

### Application

**InterprÃ©teur :**
- Suivre la propriÃ©tÃ© const dans les liaisons de variables
- VÃ©rifier avant les opÃ©rations de mutation
- Erreur Ã  l'exÃ©cution en cas de violation const

**Compilateur :**
- Ã‰mettre des variables C qualifiÃ©es const si bÃ©nÃ©fique
- Analyse statique des violations const
- Avertissement/erreur Ã  la compilation

---

## 5. Signatures de mÃ©thode dans define

### Motivation

Permettre aux blocs `define` de spÃ©cifier les mÃ©thodes attendues, pas seulement les champs de donnÃ©es :

```hemlock
// Actuel : seulement les champs de donnÃ©es
define User {
    name: string;
    age: i32;
}

// ProposÃ© : signatures de mÃ©thode
define Comparable {
    fn compare(other: Self): i32;
}

define Serializable {
    fn serialize(): string;
    fn deserialize(data: string): Self;  // MÃ©thode statique
}
```

### Syntaxe

```hemlock
// Signature de mÃ©thode (pas de corps)
define Hashable {
    fn hash(): i32;
}

// Plusieurs mÃ©thodes
define Collection {
    fn size(): i32;
    fn is_empty(): bool;
    fn contains(item: any): bool;
}

// MÃ©lange de champs et mÃ©thodes
define Entity {
    id: i32;
    name: string;
    fn validate(): bool;
    fn serialize(): string;
}

// Utilisation du type Self
define Cloneable {
    fn clone(): Self;
}

define Comparable {
    fn compare(other: Self): i32;
    fn equals(other: Self): bool;
}

// MÃ©thodes optionnelles
define Printable {
    fn to_string(): string;
    fn debug_string?(): string;  // MÃ©thode optionnelle (peut Ãªtre absente)
}

// MÃ©thodes avec implÃ©mentations par dÃ©faut
define Ordered {
    fn compare(other: Self): i32;  // Requis

    // ImplÃ©mentations par dÃ©faut (hÃ©ritÃ©es si non surchargÃ©es)
    fn less_than(other: Self): bool {
        return self.compare(other) < 0;
    }
    fn greater_than(other: Self): bool {
        return self.compare(other) > 0;
    }
    fn equals(other: Self): bool {
        return self.compare(other) == 0;
    }
}
```

### Le type `Self`

`Self` fait rÃ©fÃ©rence au type concret implÃ©mentant l'interface :

```hemlock
define Addable {
    fn add(other: Self): Self;
}

// Quand utilisÃ© :
let a: Addable = {
    value: 10,
    add: fn(other) {
        return { value: self.value + other.value, add: self.add };
    }
};
```

### Typage structurel (duck typing)

Les signatures de mÃ©thode utilisent le mÃªme duck typing que les champs :

```hemlock
define Stringifiable {
    fn to_string(): string;
}

// Tout objet avec une mÃ©thode to_string() satisfait Stringifiable
let x: Stringifiable = {
    name: "test",
    to_string: fn() { return self.name; }
};

// Types composÃ©s avec mÃ©thodes
define Named { name: string; }
define Printable { fn to_string(): string; }

type NamedPrintable = Named & Printable;

let y: NamedPrintable = {
    name: "Alice",
    to_string: fn() { return "Nom : " + self.name; }
};
```

### Modifications de l'AST

```c
// Ã‰tendre define_object dans l'union Stmt
struct {
    char *name;
    char **type_params;
    int num_type_params;

    // Champs (existants)
    char **field_names;
    Type **field_types;
    int *field_optional;
    Expr **field_defaults;
    int num_fields;

    // MÃ©thodes (NOUVEAU)
    char **method_names;
    Type **method_types;        // TYPE_FUNCTION
    int *method_optional;       // MÃ©thodes optionnelles (fn name?(): type)
    Expr **method_defaults;     // ImplÃ©mentations par dÃ©faut (NULL si signature seulement)
    int num_methods;
} define_object;
```

### VÃ©rification de types

Lors de la vÃ©rification de `value: InterfaceType` :
1. VÃ©rifier que tous les champs requis existent avec des types compatibles
2. VÃ©rifier que toutes les mÃ©thodes requises existent avec des signatures compatibles
3. Les champs/mÃ©thodes optionnels peuvent Ãªtre absents

```hemlock
define Sortable {
    fn compare(other: Self): i32;
}

// Valide : a la mÃ©thode compare
let valid: Sortable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};

// Invalide : compare manquant
let invalid: Sortable = { value: 10 };  // ERREUR : mÃ©thode 'compare' manquante

// Invalide : mauvaise signature
let wrong: Sortable = {
    compare: fn() { return 0; }  // ERREUR : attendu (Self): i32
};
```

---

## Exemples d'interaction

### Combinaison de toutes les fonctionnalitÃ©s

```hemlock
// Alias de type pour type fonction complexe
type EventCallback = fn(event: Event, context: Context?): bool;

// Alias de type pour interface composÃ©e
type Entity = HasId & HasName & Serializable;

// Define avec signatures de mÃ©thode
define Repository<T> {
    fn find(id: i32): T?;
    fn save(const entity: T): bool;
    fn delete(id: i32): bool;
    fn find_all(predicate: fn(T): bool): array<T>;
}

// Utilisation de tout ensemble
fn create_user_repo(): Repository<User> {
    let users: array<User> = [];

    return {
        find: fn(id) {
            for (u in users) {
                if (u.id == id) { return u; }
            }
            return null;
        },
        save: fn(const entity) {
            users.push(entity);
            return true;
        },
        delete: fn(id) {
            // ...
            return true;
        },
        find_all: fn(predicate) {
            return users.filter(predicate);
        }
    };
}
```

### Callbacks avec types explicites

```hemlock
type ClickHandler = fn(event: MouseEvent): void;
type KeyHandler = fn(event: KeyEvent, modifiers: i32): bool;

define Widget {
    x: i32;
    y: i32;
    on_click: ClickHandler?;
    on_key: KeyHandler?;
}

fn create_button(label: string, handler: ClickHandler): Widget {
    return {
        x: 0, y: 0,
        on_click: handler,
        on_key: null
    };
}
```

### Types fonction nullable

```hemlock
// Callback optionnel
fn fetch(url: string, on_complete: fn(Response): void?): void {
    let response = http_get(url);
    if (on_complete != null) {
        on_complete(response);
    }
}

// Retour nullable depuis un type fonction
type Parser = fn(input: string): AST?;

fn try_parse(parsers: array<Parser>, input: string): AST? {
    for (p in parsers) {
        let result = p(input);
        if (result != null) {
            return result;
        }
    }
    return null;
}
```

---

## Feuille de route d'implÃ©mentation

### Phase 1 : Infrastructure de base
1. Ajouter `TYPE_FUNCTION` Ã  l'enum TypeKind
2. Ã‰tendre la struct Type avec les champs de type fonction
3. Ajouter `CHECKED_FUNCTION` au vÃ©rificateur de types du compilateur
4. Ajouter le support du type `Self` (TYPE_SELF)

### Phase 2 : Analyse syntaxique
1. ImplÃ©menter `parse_function_type()` dans le parser
2. GÃ©rer `fn(...)` en position de type
3. Ajouter le mot-clÃ© `type` et l'analyse de `STMT_TYPE_ALIAS`
4. Ajouter l'analyse du modificateur de paramÃ¨tre `const`
5. Ã‰tendre l'analyse de define pour les signatures de mÃ©thode

### Phase 3 : VÃ©rification de types
1. RÃ¨gles de compatibilitÃ© des types fonction
2. RÃ©solution et expansion des alias de type
3. VÃ©rification de mutation des paramÃ¨tres const
4. Validation des signatures de mÃ©thode dans les types define
5. RÃ©solution du type Self

### Phase 4 : ExÃ©cution
1. Validation du type fonction aux sites d'appel
2. DÃ©tection des violations const
3. Transparence des alias de type

### Phase 5 : Tests de paritÃ©
1. Tests d'annotation de type fonction
2. Tests de composition nullable
3. Tests d'alias de type
4. Tests de paramÃ¨tres const
5. Tests de signatures de mÃ©thode

---

## DÃ©cisions de conception

### 1. Alias de type gÃ©nÃ©riques : **OUI**

Les alias de type supportent les paramÃ¨tres gÃ©nÃ©riques :

```hemlock
// Alias de type gÃ©nÃ©riques
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };
type Mapper<T, U> = fn(T): U;
type AsyncResult<T> = async fn(): T?;

// Utilisation
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
let result: Result<User, string> = { value: user, error: null };
let transform: Mapper<i32, string> = fn(n) { return n.to_string(); };
```

### 2. Propagation const : **PROFONDE**

Les paramÃ¨tres const sont totalement immuables - pas de mutation par aucun chemin :

```hemlock
fn process(const arr: array<object>) {
    arr.push({});        // ERREUR : impossible de muter un tableau const
    arr[0] = {};         // ERREUR : impossible de muter un tableau const
    arr[0].x = 5;        // ERREUR : impossible de muter Ã  travers const (PROFOND)

    let x = arr[0].x;    // OK : la lecture est autorisÃ©e
    let copy = arr[0];   // OK : crÃ©e une copie
    copy.x = 5;          // OK : la copie n'est pas const
}

fn nested(const obj: object) {
    obj.user.name = "x"; // ERREUR : const profond empÃªche la mutation imbriquÃ©e
    obj.items[0] = 1;    // ERREUR : const profond empÃªche la mutation imbriquÃ©e
}
```

**Justification :** Le const profond fournit des garanties plus fortes et est plus utile pour
assurer l'intÃ©gritÃ© des donnÃ©es. Si vous devez muter des donnÃ©es imbriquÃ©es, faites d'abord une copie.

### 3. Self dans les alias de type autonomes : **NON**

`Self` n'est valide qu'Ã  l'intÃ©rieur des blocs `define` oÃ¹ il a un sens clair :

```hemlock
// Valide : Self fait rÃ©fÃ©rence au type dÃ©fini
define Comparable {
    fn compare(other: Self): i32;
}

// Invalide : Self n'a pas de sens ici
type Cloner = fn(Self): Self;  // ERREUR : Self en dehors du contexte define

// Ã€ la place, utilisez les gÃ©nÃ©riques :
type Cloner<T> = fn(T): T;
```

### 4. ImplÃ©mentations de mÃ©thode par dÃ©faut : **OUI (simples seulement)**

Autoriser les implÃ©mentations par dÃ©faut pour les mÃ©thodes simples/utilitaires :

```hemlock
define Comparable {
    // Requis : doit Ãªtre implÃ©mentÃ©
    fn compare(other: Self): i32;

    // ImplÃ©mentations par dÃ©faut (mÃ©thodes de commoditÃ© simples)
    fn equals(other: Self): bool {
        return self.compare(other) == 0;
    }
    fn less_than(other: Self): bool {
        return self.compare(other) < 0;
    }
    fn greater_than(other: Self): bool {
        return self.compare(other) > 0;
    }
}

define Printable {
    fn to_string(): string;

    // DÃ©faut : dÃ©lÃ¨gue Ã  la mÃ©thode requise
    fn print() {
        print(self.to_string());
    }
    fn println() {
        print(self.to_string() + "\n");
    }
}

// L'objet doit seulement implÃ©menter les mÃ©thodes requises
let item: Comparable = {
    value: 42,
    compare: fn(other) { return self.value - other.value; }
    // equals, less_than, greater_than sont hÃ©ritÃ©es des valeurs par dÃ©faut
};

item.less_than({ value: 50, compare: item.compare });  // true
```

**Directives pour les valeurs par dÃ©faut :**
- Les garder simples (1-3 lignes)
- Devraient dÃ©lÃ©guer aux mÃ©thodes requises
- Pas de logique complexe ni d'effets de bord
- Primitives et compositions simples uniquement

### 5. Variance : **INFÃ‰RÃ‰E (pas d'annotations explicites)**

La variance est infÃ©rÃ©e de la faÃ§on dont les paramÃ¨tres de type sont utilisÃ©s :

```hemlock
// La variance est automatique basÃ©e sur la position
type Producer<T> = fn(): T;           // T en retour = covariant
type Consumer<T> = fn(T): void;       // T en paramÃ¨tre = contravariant
type Transformer<T> = fn(T): T;       // T dans les deux = invariant

// Exemple : Dog <: Animal (Dog est un sous-type de Animal)
let dog_producer: Producer<Dog> = fn() { return new_dog(); };
let animal_producer: Producer<Animal> = dog_producer;  // OK : covariant

let animal_consumer: Consumer<Animal> = fn(a) { print(a); };
let dog_consumer: Consumer<Dog> = animal_consumer;     // OK : contravariant
```

**Pourquoi infÃ©rer ?**
- Moins de code rÃ©pÃ©titif (`<out T>` / `<in T>` ajoute du bruit)
- Suit "explicite plutÃ´t qu'implicite" - la position EST explicite
- Correspond Ã  la faÃ§on dont la plupart des langages gÃ¨rent la variance des types fonction
- Les erreurs sont claires quand les rÃ¨gles de variance sont violÃ©es

---

## Annexe : Modifications de la grammaire

```ebnf
(* Types *)
type := simple_type | compound_type | function_type
simple_type := base_type ["?"] | identifier ["<" type_args ">"] ["?"]
compound_type := simple_type ("&" simple_type)+
function_type := ["async"] "fn" "(" [param_types] ")" [":" type]

base_type := "i8" | "i16" | "i32" | "i64"
           | "u8" | "u16" | "u32" | "u64"
           | "f32" | "f64" | "bool" | "string" | "rune"
           | "ptr" | "buffer" | "void" | "null"
           | "array" ["<" type ">"]
           | "object"
           | "Self"

param_types := param_type ("," param_type)*
param_type := ["const"] [identifier ":"] ["?"] type
            | "..." [identifier] [":" type]

type_args := type ("," type)*

(* Instructions *)
type_alias := "type" identifier ["<" type_params ">"] "=" type ";"

define_stmt := "define" identifier ["<" type_params ">"] "{" define_members "}"
define_members := (field_def | method_def)*
field_def := identifier (":" type ["=" expr] | "?:" (type | expr)) ";"?
method_def := "fn" identifier ["?"] "(" [param_types] ")" [":" type] (block | ";")
            (* "?" marque une mÃ©thode optionnelle, block fournit l'implÃ©mentation par dÃ©faut *)

(* ParamÃ¨tres *)
param := ["const"] ["ref"] identifier [":" type] ["?:" expr]
       | "..." identifier [":" type]
```



################################################################################
# CONTRIBUER
################################################################################

--------------------------------------------------------------------------------
## Directives
--------------------------------------------------------------------------------

# Contribuer Ã  Hemlock

Merci de votre intÃ©rÃªt pour contribuer Ã  Hemlock ! Ce guide vous aidera Ã  comprendre comment contribuer efficacement tout en maintenant la philosophie de conception et la qualitÃ© du code du langage.

---

## Table des matiÃ¨res

- [Avant de commencer](#avant-de-commencer)
- [Processus de contribution](#processus-de-contribution)
- [Directives de style de code](#directives-de-style-de-code)
- [Quoi contribuer](#quoi-contribuer)
- [Quoi NE PAS contribuer](#quoi-ne-pas-contribuer)
- [ModÃ¨les courants](#modÃ¨les-courants)
- [Ajouter de nouvelles fonctionnalitÃ©s](#ajouter-de-nouvelles-fonctionnalitÃ©s)
- [Processus de revue de code](#processus-de-revue-de-code)

---

## Avant de commencer

### Lectures obligatoires

Avant de contribuer, veuillez lire ces documents dans l'ordre :

1. **`/home/user/hemlock/docs/design/philosophy.md`** - Comprendre les principes fondamentaux de Hemlock
2. **`/home/user/hemlock/docs/design/implementation.md`** - Apprendre la structure du code
3. **`/home/user/hemlock/docs/contributing/testing.md`** - Comprendre les exigences de test
4. **Ce document** - Apprendre les directives de contribution

### PrÃ©requis

**Connaissances requises :**
- Programmation C (pointeurs, gestion de la mÃ©moire, structures)
- Bases des compilateurs/interprÃ©teurs (lexing, parsing, AST)
- Workflow Git et GitHub
- Ligne de commande Unix/Linux

**Outils requis :**
- Compilateur GCC ou Clang
- SystÃ¨me de build Make
- ContrÃ´le de version Git
- Valgrind (pour la dÃ©tection des fuites mÃ©moire)
- Ã‰diteur de texte basique ou IDE

### Canaux de communication

**OÃ¹ poser des questions :**
- GitHub Issues - Rapports de bugs et demandes de fonctionnalitÃ©s
- GitHub Discussions - Questions gÃ©nÃ©rales et discussions de conception
- Commentaires de Pull Request - Retours spÃ©cifiques sur le code

---

## Processus de contribution

### 1. Trouver ou crÃ©er une issue

**Avant d'Ã©crire du code :**
- VÃ©rifiez si une issue existe pour votre contribution
- Sinon, crÃ©ez-en une dÃ©crivant ce que vous voulez faire
- Attendez le retour des mainteneurs avant de commencer des changements importants
- Les petites corrections de bugs peuvent sauter cette Ã©tape

**Les bonnes descriptions d'issues incluent :**
- Ã‰noncÃ© du problÃ¨me (ce qui est cassÃ© ou manquant)
- Solution proposÃ©e (comment vous prÃ©voyez de le corriger)
- Exemples (extraits de code montrant le problÃ¨me)
- Justification (pourquoi ce changement s'aligne avec la philosophie de Hemlock)

### 2. Fork et clone

```bash
# Forkez d'abord le dÃ©pÃ´t sur GitHub, puis :
git clone https://github.com/VOTRE_NOM_UTILISATEUR/hemlock.git
cd hemlock
git checkout -b feature/nom-de-votre-fonctionnalite
```

### 3. Effectuez vos modifications

Suivez ces directives :
- Ã‰crivez les tests d'abord (approche TDD)
- ImplÃ©mentez la fonctionnalitÃ©
- Assurez-vous que tous les tests passent
- VÃ©rifiez les fuites mÃ©moire
- Mettez Ã  jour la documentation

### 4. Testez vos modifications

```bash
# ExÃ©cutez la suite de tests complÃ¨te
make test

# ExÃ©cutez une catÃ©gorie de test spÃ©cifique
./tests/run_tests.sh tests/category/

# VÃ©rifiez les fuites mÃ©moire
valgrind ./hemlock tests/your_test.hml

# Compilez et testez
make clean && make && make test
```

### 5. Committez vos modifications

**Bons messages de commit :**
```
Add bitwise operators for integer types

- Implement &, |, ^, <<, >>, ~ operators
- Add type checking to ensure integer-only operations
- Update operator precedence table
- Add comprehensive tests for all operators

Closes #42
```

**Format du message de commit :**
- PremiÃ¨re ligne : RÃ©sumÃ© bref (50 caractÃ¨res max)
- Ligne vide
- Explication dÃ©taillÃ©e (retour Ã  la ligne Ã  72 caractÃ¨res)
- RÃ©fÃ©rencer les numÃ©ros d'issue

### 6. Soumettez une Pull Request

**Avant de soumettre :**
- Rebasez sur la derniÃ¨re branche main
- Assurez-vous que tous les tests passent
- ExÃ©cutez valgrind pour vÃ©rifier les fuites
- Mettez Ã  jour CLAUDE.md si vous ajoutez des fonctionnalitÃ©s visibles par l'utilisateur

**La description de la pull request doit inclure :**
- Quel problÃ¨me cela rÃ©sout
- Comment cela le rÃ©sout
- Changements cassants (s'il y en a)
- Exemples de nouvelle syntaxe ou comportement
- RÃ©sumÃ© de la couverture des tests

---

## Directives de style de code

### Style de code C

**Formatage :**
```c
// Indentation avec 4 espaces (pas de tabulations)
// Style d'accolade K&R pour les fonctions
void function_name(int arg1, char *arg2)
{
    if (condition) {
        // Accolade sur la mÃªme ligne pour les structures de contrÃ´le
        do_something();
    }
}

// Longueur de ligne : 100 caractÃ¨res max
// Utiliser des espaces autour des opÃ©rateurs
int result = (a + b) * c;

// AstÃ©risque de pointeur avec le type
char *string;   // Bon
char* string;   // Ã€ Ã©viter
char * string;  // Ã€ Ã©viter
```

**Conventions de nommage :**
```c
// Fonctions : minuscules_avec_underscores
void eval_expression(ASTNode *node);

// Types : PascalCase
typedef struct Value Value;
typedef enum ValueType ValueType;

// Constantes : MAJUSCULES_AVEC_UNDERSCORES
#define MAX_BUFFER_SIZE 4096

// Variables : minuscules_avec_underscores
int item_count;
Value *current_value;

// Enums : TYPE_PREFIX_NOM
typedef enum {
    TYPE_I32,
    TYPE_STRING,
    TYPE_OBJECT
} ValueType;
```

**Commentaires :**
```c
// Commentaires sur une ligne pour les explications brÃ¨ves
// Utiliser des phrases complÃ¨tes avec majuscule initiale

/*
 * Commentaires multi-lignes pour les explications plus longues
 * Aligner les astÃ©risques pour la lisibilitÃ©
 */

/**
 * Commentaire de documentation de fonction
 * @param node - NÅ“ud AST Ã  Ã©valuer
 * @return Valeur Ã©valuÃ©e
 */
Value eval_expr(ASTNode *node);
```

**Gestion des erreurs :**
```c
// VÃ©rifier tous les appels malloc
char *buffer = malloc(size);
if (!buffer) {
    fprintf(stderr, "Erreur : MÃ©moire insuffisante\n");
    exit(1);
}

// Fournir du contexte dans les messages d'erreur
if (file == NULL) {
    fprintf(stderr, "Erreur : Impossible d'ouvrir '%s' : %s\n",
            filename, strerror(errno));
    exit(1);
}

// Utiliser des messages d'erreur significatifs
// Mauvais : "Erreur : Valeur invalide"
// Bon : "Erreur : Attendu un entier, obtenu une chaÃ®ne"
```

**Gestion de la mÃ©moire :**
```c
// Toujours libÃ©rer ce que vous allouez
Value *val = value_create_i32(42);
// ... utiliser val
value_free(val);

// Mettre les pointeurs Ã  NULL aprÃ¨s libÃ©ration (Ã©vite le double-free)
free(ptr);
ptr = NULL;

// Documenter la propriÃ©tÃ© dans les commentaires
// Cette fonction prend possession de 'value' et le libÃ©rera
void store_value(Value *value);

// Cette fonction NE prend PAS possession (l'appelant doit libÃ©rer)
Value *get_value(void);
```

### Organisation du code

**Structure des fichiers :**
```c
// 1. Includes (en-tÃªtes systÃ¨me d'abord, puis locaux)
#include <stdio.h>
#include <stdlib.h>
#include "internal.h"
#include "values.h"

// 2. Constantes et macros
#define INITIAL_CAPACITY 16

// 3. DÃ©finitions de types
typedef struct Foo Foo;

// 4. DÃ©clarations de fonctions statiques (helpers internes)
static void helper_function(void);

// 5. ImplÃ©mentations des fonctions publiques
void public_api_function(void)
{
    // ImplÃ©mentation
}

// 6. ImplÃ©mentations des fonctions statiques
static void helper_function(void)
{
    // ImplÃ©mentation
}
```

**Fichiers d'en-tÃªte :**
```c
// Utiliser des gardes d'en-tÃªte
#ifndef HEMLOCK_MODULE_H
#define HEMLOCK_MODULE_H

// DÃ©clarations anticipÃ©es
typedef struct Value Value;

// API publique seulement dans les en-tÃªtes
void public_function(Value *val);

// Documenter les paramÃ¨tres et valeurs de retour
/**
 * Ã‰value un nÅ“ud AST d'expression
 * @param node - Le nÅ“ud AST Ã  Ã©valuer
 * @param env - L'environnement courant
 * @return La valeur rÃ©sultante
 */
Value *eval_expr(ASTNode *node, Environment *env);

#endif // HEMLOCK_MODULE_H
```

---

## Quoi contribuer

### Contributions encouragÃ©es

**Corrections de bugs :**
- Fuites mÃ©moire
- Erreurs de segmentation
- Comportement incorrect
- AmÃ©liorations des messages d'erreur

**Documentation :**
- Commentaires de code
- Documentation d'API
- Guides utilisateur et tutoriels
- Programmes d'exemple
- Documentation des cas de test

**Tests :**
- Cas de test supplÃ©mentaires pour les fonctionnalitÃ©s existantes
- Couverture des cas limites
- Tests de rÃ©gression pour les bugs corrigÃ©s
- Benchmarks de performance

**Petits ajouts de fonctionnalitÃ©s :**
- Nouvelles fonctions intÃ©grÃ©es (si elles correspondent Ã  la philosophie)
- MÃ©thodes de chaÃ®ne/tableau
- Fonctions utilitaires
- AmÃ©liorations de la gestion des erreurs

**AmÃ©liorations de performance :**
- Algorithmes plus rapides (sans changer la sÃ©mantique)
- RÃ©duction de l'utilisation mÃ©moire
- Suite de benchmarks
- Outils de profilage

**Outillage :**
- Coloration syntaxique pour les Ã©diteurs
- Language Server Protocol (LSP)
- IntÃ©gration du dÃ©bogueur
- AmÃ©liorations du systÃ¨me de build

### Discutez d'abord

**FonctionnalitÃ©s majeures :**
- Nouvelles constructions du langage
- Changements du systÃ¨me de types
- Ajouts de syntaxe
- Primitives de concurrence

**Comment discuter :**
1. Ouvrez une issue ou discussion GitHub
2. DÃ©crivez la fonctionnalitÃ© et la justification
3. Montrez du code exemple
4. Expliquez comment cela s'inscrit dans la philosophie de Hemlock
5. Attendez le retour des mainteneurs
6. ItÃ©rez sur la conception avant d'implÃ©menter

---

## Quoi NE PAS contribuer

### Contributions dÃ©conseillÃ©es

**N'ajoutez pas de fonctionnalitÃ©s qui :**
- Cachent la complexitÃ© Ã  l'utilisateur
- Rendent le comportement implicite ou magique
- Cassent la sÃ©mantique ou la syntaxe existante
- Ajoutent le ramasse-miettes ou la gestion automatique de la mÃ©moire
- Violent le principe "explicite plutÃ´t qu'implicite"

**Exemples de contributions rejetÃ©es :**

**1. Insertion automatique de point-virgule**
```hemlock
// MAUVAIS : Cela serait rejetÃ©
let x = 5  // Pas de point-virgule
let y = 10 // Pas de point-virgule
```
Pourquoi : Rend la syntaxe ambiguÃ«, cache les erreurs

**2. RAII/destructeurs**
```hemlock
// MAUVAIS : Cela serait rejetÃ©
let f = open("file.txt");
// Fichier automatiquement fermÃ© Ã  la fin de la portÃ©e
```
Pourquoi : Cache quand les ressources sont libÃ©rÃ©es, pas explicite

**3. Coercition de type implicite qui perd des donnÃ©es**
```hemlock
// MAUVAIS : Cela serait rejetÃ©
let x: i32 = 3.14;  // Tronque silencieusement Ã  3
```
Pourquoi : La perte de donnÃ©es devrait Ãªtre explicite, pas silencieuse

**4. Ramasse-miettes (garbage collection)**
```c
// MAUVAIS : Cela serait rejetÃ©
void *gc_malloc(size_t size) {
    // Suivre l'allocation pour un nettoyage automatique
}
```
Pourquoi : Cache la gestion de la mÃ©moire, performances imprÃ©visibles

**5. SystÃ¨me de macros complexe**
```hemlock
// MAUVAIS : Cela serait rejetÃ©
macro repeat($n, $block) {
    for (let i = 0; i < $n; i++) $block
}
```
Pourquoi : Trop de magie, rend le code difficile Ã  comprendre

### Raisons courantes de rejet

**"C'est trop implicite"**
- Solution : Rendez le comportement explicite et documentez-le

**"Cela cache de la complexitÃ©"**
- Solution : Exposez la complexitÃ© mais rendez-la ergonomique

**"Cela casse le code existant"**
- Solution : Trouvez une alternative non cassante ou discutez du versioning

**"Cela ne correspond pas Ã  la philosophie de Hemlock"**
- Solution : Relisez philosophy.md et reconsidÃ©rez l'approche

---

## ModÃ¨les courants

### ModÃ¨le de gestion des erreurs

```c
// Utilisez ce modÃ¨le pour les erreurs rÃ©cupÃ©rables dans le code Hemlock
Value *divide(Value *a, Value *b)
{
    // VÃ©rifier les prÃ©conditions
    if (b->type != TYPE_I32) {
        // Retourner une valeur d'erreur ou lever une exception
        return create_error("Attendu un diviseur entier");
    }

    if (b->i32_value == 0) {
        return create_error("Division par zÃ©ro");
    }

    // Effectuer l'opÃ©ration
    return value_create_i32(a->i32_value / b->i32_value);
}
```

### ModÃ¨le de gestion de la mÃ©moire

```c
// ModÃ¨le : Allouer, utiliser, libÃ©rer
void process_data(void)
{
    // Allouer
    Buffer *buf = create_buffer(1024);
    char *str = malloc(256);

    // Utiliser
    if (buf && str) {
        // ... faire le travail
    }

    // LibÃ©rer (dans l'ordre inverse de l'allocation)
    free(str);
    free_buffer(buf);
}
```

### ModÃ¨le de crÃ©ation de valeur

```c
// CrÃ©er des valeurs en utilisant des constructeurs
Value *create_integer(int32_t n)
{
    Value *val = malloc(sizeof(Value));
    if (!val) {
        fprintf(stderr, "MÃ©moire insuffisante\n");
        exit(1);
    }

    val->type = TYPE_I32;
    val->i32_value = n;
    return val;
}
```

### ModÃ¨le de vÃ©rification de type

```c
// VÃ©rifier les types avant les opÃ©rations
Value *add_values(Value *a, Value *b)
{
    // VÃ©rification de type
    if (a->type != TYPE_I32 || b->type != TYPE_I32) {
        return create_error("IncompatibilitÃ© de types");
    }

    // SÃ»r de procÃ©der
    return value_create_i32(a->i32_value + b->i32_value);
}
```

### ModÃ¨le de construction de chaÃ®ne

```c
// Construire des chaÃ®nes efficacement
void build_error_message(char *buffer, size_t size, const char *detail)
{
    snprintf(buffer, size, "Erreur : %s (ligne %d)", detail, line_number);
}
```

---

## Ajouter de nouvelles fonctionnalitÃ©s

### Checklist d'ajout de fonctionnalitÃ©

Lors de l'ajout d'une nouvelle fonctionnalitÃ©, suivez ces Ã©tapes :

#### 1. Phase de conception

- [ ] Lire philosophy.md pour assurer l'alignement
- [ ] CrÃ©er une issue GitHub dÃ©crivant la fonctionnalitÃ©
- [ ] Obtenir l'approbation du mainteneur pour la conception
- [ ] Ã‰crire la spÃ©cification (syntaxe, sÃ©mantique, exemples)
- [ ] ConsidÃ©rer les cas limites et les conditions d'erreur

#### 2. Phase d'implÃ©mentation

**Si vous ajoutez une construction du langage :**

- [ ] Ajouter le type de token Ã  `lexer.h` (si nÃ©cessaire)
- [ ] Ajouter la rÃ¨gle du lexer dans `lexer.c` (si nÃ©cessaire)
- [ ] Ajouter le type de nÅ“ud AST dans `ast.h`
- [ ] Ajouter le constructeur AST dans `ast.c`
- [ ] Ajouter la rÃ¨gle du parser dans `parser.c`
- [ ] Ajouter le comportement d'exÃ©cution dans `runtime.c` ou le module appropriÃ©
- [ ] GÃ©rer le nettoyage dans les fonctions de libÃ©ration AST

**Si vous ajoutez une fonction intÃ©grÃ©e :**

- [ ] Ajouter l'implÃ©mentation de la fonction dans `builtins.c`
- [ ] Enregistrer la fonction dans `register_builtins()`
- [ ] GÃ©rer toutes les combinaisons de types de paramÃ¨tres
- [ ] Retourner les valeurs d'erreur appropriÃ©es
- [ ] Documenter les paramÃ¨tres et le type de retour

**Si vous ajoutez un type de valeur :**

- [ ] Ajouter l'enum de type dans `values.h`
- [ ] Ajouter le champ Ã  l'union Value
- [ ] Ajouter le constructeur dans `values.c`
- [ ] Ajouter Ã  `value_free()` pour le nettoyage
- [ ] Ajouter Ã  `value_copy()` pour la copie
- [ ] Ajouter Ã  `value_to_string()` pour l'affichage
- [ ] Ajouter les rÃ¨gles de promotion de type si numÃ©rique

#### 3. Phase de test

- [ ] Ã‰crire les cas de test (voir testing.md)
- [ ] Tester les cas de succÃ¨s
- [ ] Tester les cas d'erreur
- [ ] Tester les cas limites
- [ ] ExÃ©cuter la suite de tests complÃ¨te (`make test`)
- [ ] VÃ©rifier les fuites mÃ©moire avec valgrind
- [ ] Tester sur plusieurs plateformes (si possible)

#### 4. Phase de documentation

- [ ] Mettre Ã  jour CLAUDE.md avec la documentation destinÃ©e Ã  l'utilisateur
- [ ] Ajouter des commentaires de code expliquant l'implÃ©mentation
- [ ] CrÃ©er des exemples dans `examples/`
- [ ] Mettre Ã  jour les fichiers docs/ pertinents
- [ ] Documenter tout changement cassant

#### 5. Phase de soumission

- [ ] Nettoyer le code de dÃ©bogage et les commentaires
- [ ] VÃ©rifier la conformitÃ© au style de code
- [ ] Rebaser sur la derniÃ¨re branche main
- [ ] CrÃ©er la pull request avec une description dÃ©taillÃ©e
- [ ] RÃ©pondre aux retours de la revue de code

### Exemple : Ajouter un nouvel opÃ©rateur

Parcourons l'ajout de l'opÃ©rateur modulo `%` comme exemple :

**1. Lexer (lexer.c) :**
```c
// Ajouter Ã  l'instruction switch dans get_next_token()
case '%':
    return create_token(TOKEN_PERCENT, "%", line);
```

**2. En-tÃªte du lexer (lexer.h) :**
```c
typedef enum {
    // ... tokens existants
    TOKEN_PERCENT,
    // ...
} TokenType;
```

**3. AST (ast.h) :**
```c
typedef enum {
    // ... opÃ©rateurs existants
    OP_MOD,
    // ...
} BinaryOp;
```

**4. Parser (parser.c) :**
```c
// Ajouter Ã  parse_multiplicative() ou au niveau de prÃ©cÃ©dence appropriÃ©
if (match(TOKEN_PERCENT)) {
    BinaryOp op = OP_MOD;
    ASTNode *right = parse_unary();
    left = create_binary_op_node(op, left, right);
}
```

**5. Runtime (runtime.c) :**
```c
// Ajouter Ã  eval_binary_op()
case OP_MOD:
    // VÃ©rification de type
    if (left->type == TYPE_I32 && right->type == TYPE_I32) {
        if (right->i32_value == 0) {
            fprintf(stderr, "Erreur : Modulo par zÃ©ro\n");
            exit(1);
        }
        return value_create_i32(left->i32_value % right->i32_value);
    }
    // ... gÃ©rer les autres combinaisons de types
    break;
```

**6. Tests (tests/operators/modulo.hml) :**
```hemlock
// Modulo basique
print(10 % 3);  // Attendu : 2

// Modulo nÃ©gatif
print(-10 % 3); // Attendu : -1

// Cas d'erreur (devrait Ã©chouer)
// print(10 % 0);  // Division par zÃ©ro
```

**7. Documentation (CLAUDE.md) :**
```markdown
### OpÃ©rateurs arithmÃ©tiques
- `+` - Addition
- `-` - Soustraction
- `*` - Multiplication
- `/` - Division
- `%` - Modulo (reste)
```

---

## Processus de revue de code

### Ce que les reviewers recherchent

**1. Correction**
- Le code fait-il ce qu'il prÃ©tend ?
- Les cas limites sont-ils gÃ©rÃ©s ?
- Y a-t-il des fuites mÃ©moire ?
- Les erreurs sont-elles gÃ©rÃ©es correctement ?

**2. Alignement avec la philosophie**
- Est-ce que cela correspond aux principes de conception de Hemlock ?
- Est-ce explicite ou implicite ?
- Est-ce que cela cache de la complexitÃ© ?

**3. QualitÃ© du code**
- Le code est-il lisible et maintenable ?
- Les noms de variables sont-ils descriptifs ?
- Les fonctions ont-elles une taille raisonnable ?
- Y a-t-il une documentation adÃ©quate ?

**4. Tests**
- Y a-t-il suffisamment de cas de test ?
- Les tests couvrent-ils les chemins de succÃ¨s et d'Ã©chec ?
- Les cas limites sont-ils testÃ©s ?

**5. Documentation**
- La documentation destinÃ©e Ã  l'utilisateur est-elle mise Ã  jour ?
- Les commentaires de code sont-ils clairs ?
- Des exemples sont-ils fournis ?

### RÃ©pondre aux retours

**Ã€ faire :**
- Remercier les reviewers pour leur temps
- Poser des questions de clarification si vous ne comprenez pas
- Expliquer votre raisonnement si vous n'Ãªtes pas d'accord
- Effectuer les changements demandÃ©s rapidement
- Mettre Ã  jour la description de la PR si la portÃ©e change

**Ã€ ne pas faire :**
- Prendre les critiques personnellement
- Argumenter dÃ©fensivement
- Ignorer les retours
- Force-push par-dessus les commentaires de revue (sauf si rebase)
- Ajouter des changements non liÃ©s Ã  la PR

### Faire merger votre PR

**Conditions pour le merge :**
- [ ] Tous les tests passent
- [ ] Pas de fuites mÃ©moire (valgrind clean)
- [ ] Approbation de la revue de code par un mainteneur
- [ ] Documentation mise Ã  jour
- [ ] Suit les directives de style de code
- [ ] S'aligne avec la philosophie de Hemlock

**DÃ©lais :**
- Petites PR (corrections de bugs) : GÃ©nÃ©ralement reviewÃ©es en quelques jours
- PR moyennes (nouvelles fonctionnalitÃ©s) : Peut prendre 1-2 semaines
- Grandes PR (changements majeurs) : NÃ©cessite une discussion approfondie

---

## Ressources supplÃ©mentaires

### Ressources d'apprentissage

**Comprendre les interprÃ©teurs :**
- "Crafting Interpreters" par Robert Nystrom
- "Writing An Interpreter In Go" par Thorsten Ball
- "Modern Compiler Implementation in C" par Andrew Appel

**Programmation C :**
- "The C Programming Language" par K&R
- "Expert C Programming" par Peter van der Linden
- "C Interfaces and Implementations" par David Hanson

**Gestion de la mÃ©moire :**
- Documentation Valgrind
- "Understanding and Using C Pointers" par Richard Reese

### Commandes utiles

```bash
# Compiler avec symboles de dÃ©bogage
make clean && make CFLAGS="-g -O0"

# ExÃ©cuter avec valgrind
valgrind --leak-check=full ./hemlock script.hml

# ExÃ©cuter une catÃ©gorie de test spÃ©cifique
./tests/run_tests.sh tests/strings/

# GÃ©nÃ©rer un fichier de tags pour la navigation de code
ctags -R .

# Trouver tous les TODO et FIXME
grep -rn "TODO\|FIXME" src/ include/
```

---

## Questions ?

Si vous avez des questions sur la contribution :

1. Consultez la documentation dans `docs/`
2. Recherchez dans les issues GitHub existantes
3. Demandez dans GitHub Discussions
4. Ouvrez une nouvelle issue avec votre question

**Merci de contribuer Ã  Hemlock !**


--------------------------------------------------------------------------------
## Tests
--------------------------------------------------------------------------------

# Guide de test pour Hemlock

Ce guide explique la philosophie de test de Hemlock, comment Ã©crire des tests et comment exÃ©cuter la suite de tests.

---

## Table des matiÃ¨res

- [Philosophie de test](#philosophie-de-test)
- [Structure de la suite de tests](#structure-de-la-suite-de-tests)
- [ExÃ©cuter les tests](#exÃ©cuter-les-tests)
- [Ã‰crire des tests](#Ã©crire-des-tests)
- [CatÃ©gories de tests](#catÃ©gories-de-tests)
- [Tests de fuites mÃ©moire](#tests-de-fuites-mÃ©moire)
- [IntÃ©gration continue](#intÃ©gration-continue)
- [Bonnes pratiques](#bonnes-pratiques)

---

## Philosophie de test

### Principes fondamentaux

**1. DÃ©veloppement pilotÃ© par les tests (TDD)**

Ã‰crivez les tests **avant** d'implÃ©menter les fonctionnalitÃ©s :

```
1. Ã‰crire un test qui Ã©choue
2. ImplÃ©menter la fonctionnalitÃ©
3. ExÃ©cuter le test (devrait passer)
4. Refactoriser si nÃ©cessaire
5. RÃ©pÃ©ter
```

**Avantages :**
- Assure que les fonctionnalitÃ©s fonctionnent rÃ©ellement
- PrÃ©vient les rÃ©gressions
- Documente le comportement attendu
- Rend le refactoring plus sÃ»r

**2. Couverture complÃ¨te**

Testez les cas de succÃ¨s et d'Ã©chec :

```hemlock
// Cas de succÃ¨s
let x: u8 = 255;  // Devrait fonctionner

// Cas d'Ã©chec
let y: u8 = 256;  // Devrait gÃ©nÃ©rer une erreur
```

**3. Testez tÃ´t et souvent**

ExÃ©cutez les tests :
- Avant de committer du code
- AprÃ¨s avoir fait des modifications
- Avant de soumettre des pull requests
- Pendant la revue de code

**RÃ¨gle :** Tous les tests doivent passer avant le merge.

### Quoi tester

**Toujours tester :**
- La fonctionnalitÃ© de base (chemin heureux)
- Les conditions d'erreur (chemin malheureux)
- Les cas limites (conditions aux frontiÃ¨res)
- La vÃ©rification et les conversions de types
- La gestion de la mÃ©moire (pas de fuites)
- La concurrence et les conditions de course

**Exemple de couverture de test :**
```hemlock
// FonctionnalitÃ© : String.substr(start, length)

// Chemin heureux
print("hello".substr(0, 5));  // "hello"

// Cas limites
print("hello".substr(0, 0));  // "" (vide)
print("hello".substr(5, 0));  // "" (Ã  la fin)
print("hello".substr(2, 100)); // "llo" (au-delÃ  de la fin)

// Cas d'erreur
// "hello".substr(-1, 5);  // Erreur : index nÃ©gatif
// "hello".substr(0, -1);  // Erreur : longueur nÃ©gative
```

---

## Structure de la suite de tests

### Organisation des rÃ©pertoires

```
tests/
â”œâ”€â”€ run_tests.sh          # Script principal d'exÃ©cution des tests
â”œâ”€â”€ primitives/           # Tests du systÃ¨me de types
â”‚   â”œâ”€â”€ integers.hml
â”‚   â”œâ”€â”€ floats.hml
â”‚   â”œâ”€â”€ booleans.hml
â”‚   â”œâ”€â”€ i64.hml
â”‚   â””â”€â”€ u64.hml
â”œâ”€â”€ conversions/          # Tests de conversion de types
â”‚   â”œâ”€â”€ int_to_float.hml
â”‚   â”œâ”€â”€ promotion.hml
â”‚   â””â”€â”€ rune_conversions.hml
â”œâ”€â”€ memory/               # Tests de pointeur/buffer
â”‚   â”œâ”€â”€ alloc.hml
â”‚   â”œâ”€â”€ buffer.hml
â”‚   â””â”€â”€ memcpy.hml
â”œâ”€â”€ strings/              # Tests d'opÃ©rations sur les chaÃ®nes
â”‚   â”œâ”€â”€ concat.hml
â”‚   â”œâ”€â”€ methods.hml
â”‚   â”œâ”€â”€ utf8.hml
â”‚   â””â”€â”€ runes.hml
â”œâ”€â”€ control/              # Tests de flux de contrÃ´le
â”‚   â”œâ”€â”€ if.hml
â”‚   â”œâ”€â”€ switch.hml
â”‚   â””â”€â”€ while.hml
â”œâ”€â”€ functions/            # Tests de fonctions et closures
â”‚   â”œâ”€â”€ basics.hml
â”‚   â”œâ”€â”€ closures.hml
â”‚   â””â”€â”€ recursion.hml
â”œâ”€â”€ objects/              # Tests d'objets
â”‚   â”œâ”€â”€ literals.hml
â”‚   â”œâ”€â”€ methods.hml
â”‚   â”œâ”€â”€ duck_typing.hml
â”‚   â””â”€â”€ serialization.hml
â”œâ”€â”€ arrays/               # Tests d'opÃ©rations sur les tableaux
â”‚   â”œâ”€â”€ basics.hml
â”‚   â”œâ”€â”€ methods.hml
â”‚   â””â”€â”€ slicing.hml
â”œâ”€â”€ loops/                # Tests de boucles
â”‚   â”œâ”€â”€ for.hml
â”‚   â”œâ”€â”€ while.hml
â”‚   â”œâ”€â”€ break.hml
â”‚   â””â”€â”€ continue.hml
â”œâ”€â”€ exceptions/           # Tests de gestion des erreurs
â”‚   â”œâ”€â”€ try_catch.hml
â”‚   â”œâ”€â”€ finally.hml
â”‚   â””â”€â”€ throw.hml
â”œâ”€â”€ io/                   # Tests d'E/S de fichiers
â”‚   â”œâ”€â”€ file_object.hml
â”‚   â”œâ”€â”€ read_write.hml
â”‚   â””â”€â”€ seek.hml
â”œâ”€â”€ async/                # Tests de concurrence
â”‚   â”œâ”€â”€ spawn_join.hml
â”‚   â”œâ”€â”€ channels.hml
â”‚   â””â”€â”€ exceptions.hml
â”œâ”€â”€ ffi/                  # Tests FFI
â”‚   â”œâ”€â”€ basic_call.hml
â”‚   â”œâ”€â”€ types.hml
â”‚   â””â”€â”€ dlopen.hml
â”œâ”€â”€ signals/              # Tests de gestion des signaux
â”‚   â”œâ”€â”€ basic.hml
â”‚   â”œâ”€â”€ handlers.hml
â”‚   â””â”€â”€ raise.hml
â””â”€â”€ args/                 # Tests d'arguments en ligne de commande
    â””â”€â”€ basic.hml
```

### Nommage des fichiers de test

**Conventions :**
- Utiliser des noms descriptifs : `method_chaining.hml` pas `test1.hml`
- Grouper les tests liÃ©s : `string_substr.hml`, `string_slice.hml`
- Un domaine fonctionnel par fichier
- Garder les fichiers ciblÃ©s et petits

---

## ExÃ©cuter les tests

### ExÃ©cuter tous les tests

```bash
# Depuis le rÃ©pertoire racine de hemlock
make test

# Ou directement
./tests/run_tests.sh
```

**Sortie :**
```
Running tests in tests/primitives/...
  âœ“ integers.hml
  âœ“ floats.hml
  âœ“ booleans.hml

Running tests in tests/strings/...
  âœ“ concat.hml
  âœ“ methods.hml

...

Total: 251 tests
Passed: 251
Failed: 0
```

### ExÃ©cuter une catÃ©gorie spÃ©cifique

```bash
# ExÃ©cuter seulement les tests de chaÃ®nes
./tests/run_tests.sh tests/strings/

# ExÃ©cuter un seul fichier de test
./tests/run_tests.sh tests/strings/concat.hml

# ExÃ©cuter plusieurs catÃ©gories
./tests/run_tests.sh tests/strings/ tests/arrays/
```

### ExÃ©cuter avec Valgrind (vÃ©rification des fuites mÃ©moire)

```bash
# VÃ©rifier un seul test pour les fuites
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml

# VÃ©rifier tous les tests (lent !)
for test in tests/**/*.hml; do
    echo "Test de $test"
    valgrind --leak-check=full --error-exitcode=1 ./hemlock "$test"
done
```

### DÃ©boguer les tests Ã©chouÃ©s

```bash
# ExÃ©cuter avec sortie dÃ©taillÃ©e
./hemlock tests/failing_test.hml

# ExÃ©cuter avec gdb
gdb --args ./hemlock tests/failing_test.hml
(gdb) run
(gdb) backtrace  # si Ã§a plante
```

---

## Ã‰crire des tests

### Format des fichiers de test

Les fichiers de test sont simplement des programmes Hemlock avec une sortie attendue :

**Exemple : tests/primitives/integers.hml**
```hemlock
// Test des littÃ©raux entiers basiques
let x = 42;
print(x);  // Attendu : 42

let y: i32 = 100;
print(y);  // Attendu : 100

// Test de l'arithmÃ©tique
let sum = x + y;
print(sum);  // Attendu : 142

// Test de l'infÃ©rence de type
let small = 10;
print(typeof(small));  // Attendu : i32

let large = 5000000000;
print(typeof(large));  // Attendu : i64
```

**Comment fonctionnent les tests :**
1. Le lanceur de tests exÃ©cute le fichier .hml
2. Capture la sortie stdout
3. Compare avec la sortie attendue (depuis les commentaires ou un fichier .out sÃ©parÃ©)
4. Rapporte succÃ¨s/Ã©chec

### MÃ©thodes pour la sortie attendue

**MÃ©thode 1 : Commentaires en ligne (recommandÃ©e pour les tests simples)**

```hemlock
print("hello");  // Attendu : hello
print(42);       // Attendu : 42
```

Le lanceur de tests analyse les commentaires `// Attendu : ...`.

**MÃ©thode 2 : Fichier .out sÃ©parÃ©**

CrÃ©ez `nom_test.hml.out` avec la sortie attendue :

**nom_test.hml :**
```hemlock
print("ligne 1");
print("ligne 2");
print("ligne 3");
```

**nom_test.hml.out :**
```
ligne 1
ligne 2
ligne 3
```

### Tester les cas d'erreur

Les tests d'erreur devraient faire sortir le programme avec un statut non-zÃ©ro :

**Exemple : tests/primitives/range_error.hml**
```hemlock
// Cela devrait Ã©chouer avec une erreur de type
let x: u8 = 256;  // Hors plage pour u8
```

**Comportement attendu :**
- Le programme sort avec un statut non-zÃ©ro
- Affiche un message d'erreur sur stderr

**Gestion par le lanceur de tests :**
- Les tests attendant des erreurs devraient Ãªtre dans des fichiers sÃ©parÃ©s
- Utiliser la convention de nommage : `*_error.hml` ou `*_fail.hml`
- Documenter l'erreur attendue dans les commentaires

### Tester les cas de succÃ¨s

**Exemple : tests/strings/methods.hml**
```hemlock
// Test de substr
let s = "hello world";
let sub = s.substr(6, 5);
print(sub);  // Attendu : world

// Test de find
let pos = s.find("world");
print(pos);  // Attendu : 6

// Test de contains
let has = s.contains("lo");
print(has);  // Attendu : true

// Test de trim
let padded = "  hello  ";
let trimmed = padded.trim();
print(trimmed);  // Attendu : hello
```

### Tester les cas limites

**Exemple : tests/arrays/edge_cases.hml**
```hemlock
// Tableau vide
let empty = [];
print(empty.length);  // Attendu : 0

// Ã‰lÃ©ment unique
let single = [42];
print(single[0]);  // Attendu : 42

// Index nÃ©gatif (devrait gÃ©nÃ©rer une erreur dans un fichier de test sÃ©parÃ©)
// print(single[-1]);  // Erreur

// Index au-delÃ  de la fin (devrait gÃ©nÃ©rer une erreur)
// print(single[100]);  // Erreur

// Conditions aux frontiÃ¨res
let arr = [1, 2, 3];
print(arr.slice(0, 0));  // Attendu : [] (vide)
print(arr.slice(3, 3));  // Attendu : [] (vide)
print(arr.slice(1, 2));  // Attendu : [2]
```

### Tester le systÃ¨me de types

**Exemple : tests/conversions/promotion.hml**
```hemlock
// Test de la promotion de type dans les opÃ©rations binaires

// i32 + i64 -> i64
let a: i32 = 10;
let b: i64 = 20;
let c = a + b;
print(typeof(c));  // Attendu : i64

// i32 + f32 -> f32
let d: i32 = 10;
let e: f32 = 3.14;
let f = d + e;
print(typeof(f));  // Attendu : f32

// u8 + i32 -> i32
let g: u8 = 5;
let h: i32 = 10;
let i = g + h;
print(typeof(i));  // Attendu : i32
```

### Tester la concurrence

**Exemple : tests/async/basic.hml**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Lancer des tÃ¢ches
let t1 = spawn(compute, 10);
let t2 = spawn(compute, 20);

// Joindre et afficher les rÃ©sultats
let r1 = join(t1);
let r2 = join(t2);
print(r1);  // Attendu : 45
print(r2);  // Attendu : 190
```

### Tester les exceptions

**Exemple : tests/exceptions/try_catch.hml**
```hemlock
// Test du try/catch basique
try {
    throw "message d'erreur";
} catch (e) {
    print("CapturÃ© : " + e);  // Attendu : CapturÃ© : message d'erreur
}

// Test de finally
let executed = false;
try {
    print("try");  // Attendu : try
} finally {
    executed = true;
    print("finally");  // Attendu : finally
}

// Test de la propagation des exceptions
fn risky(): i32 {
    throw "Ã©chec";
}

try {
    risky();
} catch (e) {
    print(e);  // Attendu : Ã©chec
}
```

---

## CatÃ©gories de tests

### Tests des primitives

**Quoi tester :**
- Types entiers (i8, i16, i32, i64, u8, u16, u32, u64)
- Types flottants (f32, f64)
- Type boolÃ©en
- Type chaÃ®ne
- Type rune
- Type null

**Exemples de domaines :**
- Syntaxe des littÃ©raux
- InfÃ©rence de type
- VÃ©rification de plage
- Comportement de dÃ©bordement
- Annotations de type

### Tests de conversion

**Quoi tester :**
- Promotion de type implicite
- Conversion de type explicite
- Conversions avec perte (devraient gÃ©nÃ©rer une erreur)
- Promotion de type dans les opÃ©rations
- Comparaisons inter-types

### Tests mÃ©moire

**Quoi tester :**
- Exactitude de alloc/free
- CrÃ©ation et accÃ¨s aux buffers
- VÃ©rification des limites sur les buffers
- memset, memcpy, realloc
- DÃ©tection des fuites mÃ©moire (valgrind)

### Tests de chaÃ®nes

**Quoi tester :**
- ConcatÃ©nation
- Les 18 mÃ©thodes de chaÃ®ne
- Gestion UTF-8
- Indexation par rune
- ConcatÃ©nation chaÃ®ne + rune
- Cas limites (chaÃ®nes vides, caractÃ¨re unique, etc.)

### Tests de flux de contrÃ´le

**Quoi tester :**
- if/else/else if
- Boucles while
- Boucles for
- Instructions switch
- break/continue
- Instructions return

### Tests de fonctions

**Quoi tester :**
- DÃ©finition et appel de fonctions
- Passage de paramÃ¨tres
- Valeurs de retour
- RÃ©cursion
- Closures et capture
- Fonctions de premiÃ¨re classe
- Fonctions anonymes

### Tests d'objets

**Quoi tester :**
- LittÃ©raux d'objets
- AccÃ¨s et affectation de champs
- MÃ©thodes et liaison de self
- Duck typing
- Champs optionnels
- SÃ©rialisation/dÃ©sÃ©rialisation JSON
- DÃ©tection des rÃ©fÃ©rences circulaires

### Tests de tableaux

**Quoi tester :**
- CrÃ©ation de tableaux
- Indexation et affectation
- Les 15 mÃ©thodes de tableau
- Types mixtes
- Redimensionnement dynamique
- Cas limites (vide, Ã©lÃ©ment unique)

### Tests d'exceptions

**Quoi tester :**
- try/catch/finally
- Instruction throw
- Propagation des exceptions
- try/catch imbriquÃ©s
- Return dans try/catch/finally
- Exceptions non capturÃ©es

### Tests d'E/S

**Quoi tester :**
- Modes d'ouverture de fichiers
- OpÃ©rations de lecture/Ã©criture
- Seek/tell
- PropriÃ©tÃ©s de fichier
- Gestion des erreurs (fichiers manquants, etc.)
- Nettoyage des ressources

### Tests async

**Quoi tester :**
- spawn/join/detach
- Envoi/rÃ©ception sur canal
- Propagation des exceptions dans les tÃ¢ches
- TÃ¢ches concurrentes multiples
- Comportement de blocage des canaux

### Tests FFI

**Quoi tester :**
- dlopen/dlclose
- dlsym
- dlcall avec diffÃ©rents types
- Conversion de types
- Gestion des erreurs

---

## Tests de fuites mÃ©moire

### Utilisation de Valgrind

**Utilisation basique :**
```bash
valgrind --leak-check=full ./hemlock test.hml
```

**Exemple de sortie (pas de fuites) :**
```
==12345== HEAP SUMMARY:
==12345==     in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated
==12345==
==12345== All heap blocks were freed -- no leaks are possible
```

**Exemple de sortie (avec fuite) :**
```
==12345== LEAK SUMMARY:
==12345==    definitely lost: 64 bytes in 1 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==      possibly lost: 0 bytes in 0 blocks
==12345==    still reachable: 0 bytes in 0 blocks
==12345==         suppressed: 0 bytes in 0 blocks
```

### Sources courantes de fuites

**1. Appels free() manquants :**
```c
// MAUVAIS
char *str = malloc(100);
// ... utiliser str
// OubliÃ© de libÃ©rer !

// BON
char *str = malloc(100);
// ... utiliser str
free(str);
```

**2. Pointeurs perdus :**
```c
// MAUVAIS
char *ptr = malloc(100);
ptr = malloc(200);  // RÃ©fÃ©rence Ã  la premiÃ¨re allocation perdue !

// BON
char *ptr = malloc(100);
free(ptr);
ptr = malloc(200);
```

**3. Chemins d'exception :**
```c
// MAUVAIS
void func() {
    char *data = malloc(100);
    if (error_condition) {
        return;  // Fuite !
    }
    free(data);
}

// BON
void func() {
    char *data = malloc(100);
    if (error_condition) {
        free(data);
        return;
    }
    free(data);
}
```

### Fuites acceptables connues

Quelques petites "fuites" sont des allocations de dÃ©marrage intentionnelles :

**Fonctions intÃ©grÃ©es globales :**
```hemlock
// Les fonctions intÃ©grÃ©es, types FFI et constantes sont allouÃ©s au dÃ©marrage
// et non libÃ©rÃ©s Ã  la sortie (typiquement ~200 octets)
```

Ce ne sont pas de vraies fuites - ce sont des allocations uniques qui persistent pendant la durÃ©e de vie du programme et sont nettoyÃ©es par l'OS Ã  la sortie.

---

## IntÃ©gration continue

### GitHub Actions (futur)

Une fois la CI configurÃ©e, tous les tests s'exÃ©cuteront automatiquement sur :
- Push sur la branche main
- CrÃ©ation/mise Ã  jour de pull request
- ExÃ©cutions planifiÃ©es quotidiennes

**Workflow CI :**
1. Compiler Hemlock
2. ExÃ©cuter la suite de tests
3. VÃ©rifier les fuites mÃ©moire (valgrind)
4. Rapporter les rÃ©sultats sur la PR

### VÃ©rifications prÃ©-commit

Avant de committer, exÃ©cutez :

```bash
# Compiler Ã  neuf
make clean && make

# ExÃ©cuter tous les tests
make test

# VÃ©rifier quelques tests pour les fuites
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml
valgrind --leak-check=full ./hemlock tests/strings/concat.hml
```

---

## Bonnes pratiques

### Ã€ faire

**Ã‰crivez les tests d'abord (TDD)**
```bash
1. CrÃ©er tests/feature/new_feature.hml
2. ImplÃ©menter la fonctionnalitÃ© dans src/
3. ExÃ©cuter les tests jusqu'Ã  ce qu'ils passent
```

**Testez les succÃ¨s et les Ã©checs**
```hemlock
// SuccÃ¨s : tests/feature/success.hml
let result = do_thing();
print(result);  // Attendu : valeur attendue

// Ã‰chec : tests/feature/failure.hml
do_invalid_thing();  // Devrait gÃ©nÃ©rer une erreur
```

**Utilisez des noms de tests descriptifs**
```
Bon : tests/strings/substr_utf8_boundary.hml
Mauvais : tests/test1.hml
```

**Gardez les tests ciblÃ©s**
- Un domaine fonctionnel par fichier
- Configuration et assertions claires
- Code minimal

**Ajoutez des commentaires expliquant les tests complexes**
```hemlock
// Test que la closure capture la variable externe par rÃ©fÃ©rence
fn outer() {
    let x = 10;
    let f = fn() { return x; };
    x = 20;  // Modifier aprÃ¨s la crÃ©ation de la closure
    return f();  // Devrait retourner 20, pas 10
}
```

**Testez les cas limites**
- EntrÃ©es vides
- Valeurs null
- Valeurs aux frontiÃ¨res (min/max)
- Grandes entrÃ©es
- Valeurs nÃ©gatives

### Ã€ ne pas faire

**Ne sautez pas les tests**
- Tous les tests doivent passer avant le merge
- Ne commentez pas les tests qui Ã©chouent
- Corrigez le bug ou supprimez la fonctionnalitÃ©

**N'Ã©crivez pas de tests qui dÃ©pendent les uns des autres**
```hemlock
// MAUVAIS : test2.hml dÃ©pend de la sortie de test1.hml
// Les tests devraient Ãªtre indÃ©pendants
```

**N'utilisez pas de valeurs alÃ©atoires dans les tests**
```hemlock
// MAUVAIS : Non-dÃ©terministe
let x = random();
print(x);  // Impossible de prÃ©dire la sortie

// BON : DÃ©terministe
let x = 42;
print(x);  // Attendu : 42
```

**Ne testez pas les dÃ©tails d'implÃ©mentation**
```hemlock
// MAUVAIS : Tester la structure interne
let obj = { x: 10 };
// Ne pas vÃ©rifier l'ordre interne des champs, la capacitÃ©, etc.

// BON : Tester le comportement
print(obj.x);  // Attendu : 10
```

**N'ignorez pas les fuites mÃ©moire**
- Tous les tests devraient Ãªtre propres selon valgrind
- Documentez les fuites connues/acceptables
- Corrigez les fuites avant le merge

### Maintenance des tests

**Quand mettre Ã  jour les tests :**
- Le comportement de la fonctionnalitÃ© change
- Les corrections de bugs nÃ©cessitent de nouveaux cas de test
- Des cas limites sont dÃ©couverts
- AmÃ©liorations de performance

**Quand supprimer des tests :**
- FonctionnalitÃ© supprimÃ©e du langage
- Le test duplique une couverture existante
- Le test Ã©tait incorrect

**Refactorisation des tests :**
- Grouper les tests liÃ©s ensemble
- Extraire le code de configuration commun
- Utiliser un nommage cohÃ©rent
- Garder les tests simples et lisibles

---

## Exemple de session de test

Voici un exemple complet d'ajout d'une fonctionnalitÃ© avec des tests :

### FonctionnalitÃ© : Ajouter la mÃ©thode `array.first()`

**1. Ã‰crire le test d'abord :**

```bash
# CrÃ©er le fichier de test
cat > tests/arrays/first_method.hml << 'EOF'
// Test de la mÃ©thode array.first()

// Cas basique
let arr = [1, 2, 3];
print(arr.first());  // Attendu : 1

// Ã‰lÃ©ment unique
let single = [42];
print(single.first());  // Attendu : 42

// Tableau vide (devrait gÃ©nÃ©rer une erreur - fichier de test sÃ©parÃ©)
// let empty = [];
// print(empty.first());  // Erreur
EOF
```

**2. ExÃ©cuter le test (devrait Ã©chouer) :**

```bash
./hemlock tests/arrays/first_method.hml
# Erreur : MÃ©thode 'first' non trouvÃ©e sur array
```

**3. ImplÃ©menter la fonctionnalitÃ© :**

Modifier `src/interpreter/builtins.c` :

```c
// Ajouter la mÃ©thode array_first
Value *array_first(Value *self, Value **args, int arg_count)
{
    if (self->array_value->length == 0) {
        fprintf(stderr, "Erreur : Impossible d'obtenir le premier Ã©lÃ©ment d'un tableau vide\n");
        exit(1);
    }

    return value_copy(&self->array_value->elements[0]);
}

// Enregistrer dans la table des mÃ©thodes de tableau
// ... ajouter Ã  l'enregistrement des mÃ©thodes de tableau
```

**4. ExÃ©cuter le test (devrait passer) :**

```bash
./hemlock tests/arrays/first_method.hml
1
42
# SuccÃ¨s !
```

**5. VÃ©rifier les fuites mÃ©moire :**

```bash
valgrind --leak-check=full ./hemlock tests/arrays/first_method.hml
# All heap blocks were freed -- no leaks are possible
```

**6. ExÃ©cuter la suite de tests complÃ¨te :**

```bash
make test
# Total : 252 tests (251 + nouveau)
# PassÃ©s : 252
# Ã‰chouÃ©s : 0
```

**7. Committer :**

```bash
git add tests/arrays/first_method.hml src/interpreter/builtins.c
git commit -m "Add array.first() method with tests"
```

---

## RÃ©sumÃ©

**Rappelez-vous :**
- Ã‰crivez les tests d'abord (TDD)
- Testez les cas de succÃ¨s et d'Ã©chec
- ExÃ©cutez tous les tests avant de committer
- VÃ©rifiez les fuites mÃ©moire
- Documentez les problÃ¨mes connus
- Gardez les tests simples et ciblÃ©s

**La qualitÃ© des tests est aussi importante que la qualitÃ© du code !**



################################################################################
# HPM : PRISE EN MAIN
################################################################################

--------------------------------------------------------------------------------
## Configuration du Projet
--------------------------------------------------------------------------------

# Configuration du projet

Guide complet pour configurer des projets Hemlock avec hpm.

## Demarrer un nouveau projet

### Configuration de base

Creer un nouveau projet a partir de zero :

```bash
# Creer le repertoire du projet
mkdir my-project
cd my-project

# Initialiser package.json
hpm init

# Creer la structure des repertoires
mkdir -p src test
```

### Modeles de projets

Voici des structures de projets courantes pour differents cas d'utilisation :

#### Paquet bibliotheque

Pour les bibliotheques reutilisables :

```
my-library/
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ LICENSE
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.hml          # Entree principale, exporte l'API publique
â”‚   â”œâ”€â”€ core.hml           # Fonctionnalites principales
â”‚   â”œâ”€â”€ utils.hml          # Fonctions utilitaires
â”‚   â””â”€â”€ types.hml          # Definitions de types
â””â”€â”€ test/
    â”œâ”€â”€ framework.hml      # Framework de test
    â”œâ”€â”€ run.hml            # Lanceur de tests
    â””â”€â”€ test_core.hml      # Tests
```

**package.json :**

```json
{
  "name": "yourusername/my-library",
  "version": "1.0.0",
  "description": "A reusable Hemlock library",
  "main": "src/index.hml",
  "scripts": {
    "test": "hemlock test/run.hml"
  },
  "dependencies": {},
  "devDependencies": {}
}
```

#### Application

Pour les applications autonomes :

```
my-app/
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.hml           # Point d'entree de l'application
â”‚   â”œâ”€â”€ config.hml         # Configuration
â”‚   â”œâ”€â”€ commands/          # Commandes CLI
â”‚   â”‚   â”œâ”€â”€ index.hml
â”‚   â”‚   â””â”€â”€ run.hml
â”‚   â””â”€â”€ lib/               # Bibliotheques internes
â”‚       â””â”€â”€ utils.hml
â”œâ”€â”€ test/
â”‚   â””â”€â”€ run.hml
â””â”€â”€ data/                  # Fichiers de donnees
```

**package.json :**

```json
{
  "name": "yourusername/my-app",
  "version": "1.0.0",
  "description": "A Hemlock application",
  "main": "src/main.hml",
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc"
  },
  "dependencies": {
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {}
}
```

#### Application web

Pour les serveurs web :

```
my-web-app/
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.hml           # Point d'entree du serveur
â”‚   â”œâ”€â”€ routes/            # Gestionnaires de routes
â”‚   â”‚   â”œâ”€â”€ index.hml
â”‚   â”‚   â”œâ”€â”€ api.hml
â”‚   â”‚   â””â”€â”€ auth.hml
â”‚   â”œâ”€â”€ middleware/        # Middleware
â”‚   â”‚   â”œâ”€â”€ index.hml
â”‚   â”‚   â””â”€â”€ auth.hml
â”‚   â”œâ”€â”€ models/            # Modeles de donnees
â”‚   â”‚   â””â”€â”€ user.hml
â”‚   â””â”€â”€ services/          # Logique metier
â”‚       â””â”€â”€ user.hml
â”œâ”€â”€ test/
â”‚   â””â”€â”€ run.hml
â”œâ”€â”€ static/                # Fichiers statiques
â”‚   â”œâ”€â”€ css/
â”‚   â””â”€â”€ js/
â””â”€â”€ views/                 # Templates
    â””â”€â”€ index.hml
```

**package.json :**

```json
{
  "name": "yourusername/my-web-app",
  "version": "1.0.0",
  "description": "A Hemlock web application",
  "main": "src/main.hml",
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml"
  },
  "dependencies": {
    "hemlang/sprout": "^2.0.0",
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  }
}
```

## Le fichier package.json

### Champs obligatoires

```json
{
  "name": "owner/repo",
  "version": "1.0.0"
}
```

### Tous les champs

```json
{
  "name": "yourusername/my-package",
  "version": "1.0.0",
  "description": "Package description",
  "author": "Your Name <you@example.com>",
  "license": "MIT",
  "repository": "https://github.com/yourusername/my-package",
  "homepage": "https://yourusername.github.io/my-package",
  "bugs": "https://github.com/yourusername/my-package/issues",
  "main": "src/index.hml",
  "keywords": ["utility", "parser"],
  "dependencies": {
    "owner/package": "^1.0.0"
  },
  "devDependencies": {
    "owner/test-lib": "^1.0.0"
  },
  "scripts": {
    "start": "hemlock src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc"
  },
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ],
  "native": {
    "requires": ["libcurl", "openssl"]
  }
}
```

### Reference des champs

| Champ | Type | Description |
|-------|------|-------------|
| `name` | string | Nom du paquet au format owner/repo (obligatoire) |
| `version` | string | Version semantique (obligatoire) |
| `description` | string | Description courte |
| `author` | string | Nom et email de l'auteur |
| `license` | string | Identifiant de licence (MIT, Apache-2.0, etc.) |
| `repository` | string | URL du depot |
| `homepage` | string | Page d'accueil du projet |
| `bugs` | string | URL du gestionnaire de tickets |
| `main` | string | Fichier point d'entree (defaut : src/index.hml) |
| `keywords` | array | Mots-cles de recherche |
| `dependencies` | object | Dependances d'execution |
| `devDependencies` | object | Dependances de developpement |
| `scripts` | object | Scripts nommes |
| `files` | array | Fichiers a inclure lors de la publication |
| `native` | object | Exigences de bibliotheques natives |

## Le fichier package-lock.json

Le fichier de verrouillage est genere automatiquement et doit etre commite dans le controle de version. Il garantit des installations reproductibles.

```json
{
  "lockVersion": 1,
  "hemlock": "1.0.0",
  "dependencies": {
    "hemlang/sprout": {
      "version": "2.1.0",
      "resolved": "https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz",
      "integrity": "sha256-abc123...",
      "dependencies": {
        "hemlang/router": "^1.5.0"
      }
    },
    "hemlang/router": {
      "version": "1.5.0",
      "resolved": "https://github.com/hemlang/router/archive/v1.5.0.tar.gz",
      "integrity": "sha256-def456...",
      "dependencies": {}
    }
  }
}
```

### Bonnes pratiques pour le fichier de verrouillage

- **Commitez** package-lock.json dans le controle de version
- **Ne modifiez pas** manuellement - il est genere automatiquement
- **Executez `hpm install`** apres avoir tire des modifications
- **Supprimez et regenerez** si corrompu :
  ```bash
  rm package-lock.json
  hpm install
  ```

## Le repertoire hem_modules

Les paquets installes sont stockes dans `hem_modules/` :

```
hem_modules/
â”œâ”€â”€ hemlang/
â”‚   â”œâ”€â”€ sprout/
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â””â”€â”€ src/
â”‚   â””â”€â”€ router/
â”‚       â”œâ”€â”€ package.json
â”‚       â””â”€â”€ src/
â””â”€â”€ alice/
    â””â”€â”€ http-client/
        â”œâ”€â”€ package.json
        â””â”€â”€ src/
```

### Bonnes pratiques pour hem_modules

- **Ajoutez a .gitignore** - ne commitez pas les dependances
- **Ne modifiez pas** - les modifications seront ecrasees
- **Supprimez pour reinstaller proprement** :
  ```bash
  rm -rf hem_modules
  hpm install
  ```

## .gitignore

Fichier .gitignore recommande pour les projets Hemlock :

```gitignore
# Dependances
hem_modules/

# Sortie de compilation
dist/
*.hmlc

# Fichiers IDE
.idea/
.vscode/
*.swp
*.swo

# Fichiers OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Environnement
.env
.env.local

# Couverture de tests
coverage/
```

## Travailler avec les dependances

### Ajouter des dependances

```bash
# Ajouter une dependance d'execution
hpm install hemlang/json

# Ajouter avec une contrainte de version
hpm install hemlang/sprout@^2.0.0

# Ajouter une dependance de developpement
hpm install hemlang/test-utils --dev
```

### Importer des dependances

```hemlock
// Importer depuis un paquet (utilise l'entree "main")
import { parse, stringify } from "hemlang/json";

// Importer depuis un sous-chemin
import { Router } from "hemlang/sprout/router";

// Importer la bibliotheque standard
import { HashMap } from "@stdlib/collections";
import { readFile, writeFile } from "@stdlib/fs";
```

### Resolution des imports

hpm resout les imports dans cet ordre :

1. **Bibliotheque standard** : les imports `@stdlib/*` chargent les modules integres
2. **Racine du paquet** : `owner/repo` utilise le champ `main`
3. **Sous-chemin** : `owner/repo/path` verifie :
   - `hem_modules/owner/repo/path.hml`
   - `hem_modules/owner/repo/path/index.hml`
   - `hem_modules/owner/repo/src/path.hml`
   - `hem_modules/owner/repo/src/path/index.hml`

## Scripts

### Definir des scripts

Ajoutez des scripts a package.json :

```json
{
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "test:unit": "hemlock test/unit/run.hml",
    "test:integration": "hemlock test/integration/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc",
    "clean": "rm -rf dist hem_modules",
    "lint": "hemlock-lint src/",
    "format": "hemlock-fmt src/"
  }
}
```

### Executer des scripts

```bash
hpm run start
hpm run dev
hpm run build

# Raccourci pour test
hpm test

# Passer des arguments
hpm run test -- --verbose --filter=unit
```

### Conventions de nommage des scripts

| Script | Objectif |
|--------|----------|
| `start` | Executer l'application |
| `dev` | Executer en mode developpement |
| `test` | Executer tous les tests |
| `build` | Compiler pour la production |
| `clean` | Supprimer les fichiers generes |
| `lint` | Verifier le style du code |
| `format` | Formater le code |

## Flux de travail de developpement

### Configuration initiale

```bash
# Cloner le projet
git clone https://github.com/yourusername/my-project.git
cd my-project

# Installer les dependances
hpm install

# Executer les tests
hpm test

# Demarrer le developpement
hpm run dev
```

### Flux de travail quotidien

```bash
# Tirer les dernieres modifications
git pull

# Installer les nouvelles dependances
hpm install

# Faire des modifications...

# Executer les tests
hpm test

# Commiter
git add .
git commit -m "Add feature"
git push
```

### Ajouter une nouvelle fonctionnalite

```bash
# Creer une branche de fonctionnalite
git checkout -b feature/new-feature

# Ajouter une nouvelle dependance si necessaire
hpm install hemlang/new-lib

# Implementer la fonctionnalite...

# Tester
hpm test

# Commiter et pousser
git add .
git commit -m "Add new feature"
git push -u origin feature/new-feature
```

## Configuration specifique a l'environnement

### Utiliser les variables d'environnement

```hemlock
import { getenv } from "@stdlib/env";

let db_host = getenv("DATABASE_HOST") ?? "localhost";
let api_key = getenv("API_KEY") ?? "";

if api_key == "" {
    print("Warning: API_KEY not set");
}
```

### Fichier de configuration

**config.hml :**

```hemlock
import { getenv } from "@stdlib/env";

export let config = {
    environment: getenv("HEMLOCK_ENV") ?? "development",
    database: {
        host: getenv("DB_HOST") ?? "localhost",
        port: int(getenv("DB_PORT") ?? "5432"),
        name: getenv("DB_NAME") ?? "myapp"
    },
    server: {
        port: int(getenv("PORT") ?? "3000"),
        host: getenv("HOST") ?? "0.0.0.0"
    }
};

export fn is_production(): bool {
    return config.environment == "production";
}
```

## Voir aussi

- [Demarrage rapide](#hpm-project-setup-quick-start) - Commencez rapidement
- [Commandes](#hpm-project-setup-commands) - Reference des commandes
- [Creer des paquets](#hpm-project-setup-creating-packages) - Publication de paquets
- [Configuration](#hpm-project-setup-configuration) - Configuration de hpm


--------------------------------------------------------------------------------
## DÃ©marrage Rapide
--------------------------------------------------------------------------------

# Demarrage rapide

Soyez operationnel avec hpm en 5 minutes.

## Installer hpm

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh
```

Pour plus d'options d'installation, consultez le [Guide d'installation](#hpm-quick-start-installation).

## Creer un nouveau projet

Commencez par creer un nouveau repertoire et initialiser un paquet :

```bash
mkdir my-project
cd my-project
hpm init
```

Vous serez invite a saisir les details du projet :

```
Package name (owner/repo): myname/my-project
Version (1.0.0):
Description: My awesome Hemlock project
Author: Your Name <you@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

Utilisez `--yes` pour accepter toutes les valeurs par defaut :

```bash
hpm init --yes
```

## Structure du projet

Creez la structure de base du projet :

```
my-project/
â”œâ”€â”€ package.json        # Manifeste du projet
â”œâ”€â”€ src/
â”‚   â””â”€â”€ index.hml      # Point d'entree principal
â””â”€â”€ test/
    â””â”€â”€ test.hml       # Tests
```

Creez votre fichier principal :

```bash
mkdir -p src test
```

**src/index.hml :**
```hemlock
// Point d'entree principal
export fn greet(name: string): string {
    return "Hello, " + name + "!";
}

export fn main() {
    print(greet("World"));
}
```

## Installer des dependances

Recherchez des paquets sur GitHub (les paquets utilisent le format `owner/repo`) :

```bash
# Installer un paquet
hpm install hemlang/sprout

# Installer avec une contrainte de version
hpm install hemlang/json@^1.0.0

# Installer comme dependance de developpement
hpm install hemlang/test-utils --dev
```

Apres l'installation, la structure de votre projet inclut `hem_modules/` :

```
my-project/
â”œâ”€â”€ package.json
â”œâ”€â”€ package-lock.json   # Fichier de verrouillage (genere automatiquement)
â”œâ”€â”€ hem_modules/        # Paquets installes
â”‚   â””â”€â”€ hemlang/
â”‚       â””â”€â”€ sprout/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ index.hml
â””â”€â”€ test/
    â””â”€â”€ test.hml
```

## Utiliser les paquets installes

Importez les paquets en utilisant leur chemin GitHub :

```hemlock
// Importer depuis un paquet installe
import { app, router } from "hemlang/sprout";
import { parse, stringify } from "hemlang/json";

// Importer depuis un sous-chemin
import { middleware } from "hemlang/sprout/middleware";

// Bibliotheque standard (integree)
import { HashMap } from "@stdlib/collections";
import { readFile } from "@stdlib/fs";
```

## Ajouter des scripts

Ajoutez des scripts a votre `package.json` :

```json
{
  "name": "myname/my-project",
  "version": "1.0.0",
  "scripts": {
    "start": "hemlock src/index.hml",
    "test": "hemlock test/test.hml",
    "build": "hemlock --bundle src/index.hml -o dist/app.hmlc"
  }
}
```

Executez les scripts avec `hpm run` :

```bash
hpm run start
hpm run build

# Raccourci pour test
hpm test
```

## Flux de travail courants

### Installer toutes les dependances

Lorsque vous clonez un projet avec un `package.json` :

```bash
git clone https://github.com/someone/project.git
cd project
hpm install
```

### Mettre a jour les dependances

Mettre a jour tous les paquets vers les dernieres versions dans les contraintes :

```bash
hpm update
```

Mettre a jour un paquet specifique :

```bash
hpm update hemlang/sprout
```

### Afficher les paquets installes

Lister tous les paquets installes :

```bash
hpm list
```

La sortie affiche l'arbre des dependances :

```
my-project@1.0.0
â”œâ”€â”€ hemlang/sprout@2.1.0
â”‚   â””â”€â”€ hemlang/router@1.5.0
â””â”€â”€ hemlang/json@1.2.3
```

### Verifier les mises a jour disponibles

Voir quels paquets ont des versions plus recentes :

```bash
hpm outdated
```

### Supprimer un paquet

```bash
hpm uninstall hemlang/sprout
```

## Exemple : Application web

Voici un exemple complet utilisant un framework web :

**package.json :**
```json
{
  "name": "myname/my-web-app",
  "version": "1.0.0",
  "description": "A web application",
  "main": "src/index.hml",
  "dependencies": {
    "hemlang/sprout": "^2.0.0"
  },
  "scripts": {
    "start": "hemlock src/index.hml",
    "dev": "hemlock --watch src/index.hml"
  }
}
```

**src/index.hml :**
```hemlock
import { App, Router } from "hemlang/sprout";

fn main() {
    let app = App.new();
    let router = Router.new();

    router.get("/", fn(req, res) {
        res.send("Hello, World!");
    });

    router.get("/api/status", fn(req, res) {
        res.json({ status: "ok" });
    });

    app.use(router);
    app.listen(3000);

    print("Server running on http://localhost:3000");
}
```

Executez l'application :

```bash
hpm install
hpm run start
```

## Prochaines etapes

- [Reference des commandes](#hpm-quick-start-commands) - Apprenez toutes les commandes hpm
- [Creer des paquets](#hpm-quick-start-creating-packages) - Publiez vos propres paquets
- [Configuration](#hpm-quick-start-configuration) - Configurez hpm et les tokens GitHub
- [Configuration du projet](#hpm-quick-start-project-setup) - Configuration detaillee du projet


--------------------------------------------------------------------------------
## Installation
--------------------------------------------------------------------------------

# Installation

Ce guide explique comment installer hpm sur votre systeme.

## Installation rapide (recommandee)

Installez la derniere version avec une seule commande :

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh
```

Cela effectue automatiquement :
- La detection de votre systeme d'exploitation (Linux, macOS)
- La detection de votre architecture (x86_64, arm64)
- Le telechargement du binaire precompile approprie
- L'installation dans `/usr/local/bin` (ou utilise sudo si necessaire)

### Options d'installation

```bash
# Installer dans un emplacement personnalise (sans sudo)
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local

# Installer une version specifique
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5

# Combiner les options
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5
```

### Plateformes supportees

| Plateforme | Architecture | Statut |
|------------|--------------|--------|
| Linux    | x86_64       | Supportee |
| macOS    | x86_64       | Supportee |
| macOS    | arm64 (M1/M2/M3) | Supportee |
| Linux    | arm64        | Compiler depuis les sources |

## Compilation depuis les sources

Si vous preferez compiler depuis les sources ou si vous avez besoin d'une plateforme non couverte par les binaires precompiles, suivez ces instructions.

### Prerequis

hpm necessite que [Hemlock](https://github.com/hemlang/hemlock) soit installe au prealable. Suivez les instructions d'installation de Hemlock avant de continuer.

Verifiez que Hemlock est installe :

```bash
hemlock --version
```

## Methodes d'installation

### Methode 1 : Make Install

Compiler depuis les sources et installer.

```bash
# Cloner le depot
git clone https://github.com/hemlang/hpm.git
cd hpm

# Installer dans /usr/local/bin (necessite sudo)
sudo make install
```

Apres l'installation, verifiez que cela fonctionne :

```bash
hpm --version
```

### Methode 2 : Emplacement personnalise

Installer dans un repertoire personnalise (sans sudo) :

```bash
# Cloner le depot
git clone https://github.com/hemlang/hpm.git
cd hpm

# Installer dans ~/.local/bin
make install PREFIX=$HOME/.local

# Ou tout autre emplacement personnalise
make install PREFIX=/opt/hemlock
```

Assurez-vous que votre repertoire bin personnalise est dans votre PATH :

```bash
# Ajouter a ~/.bashrc ou ~/.zshrc
export PATH="$HOME/.local/bin:$PATH"
```

### Methode 3 : Executer sans installer

Vous pouvez executer hpm directement sans l'installer :

```bash
# Cloner le depot
git clone https://github.com/hemlang/hpm.git
cd hpm

# Creer le script wrapper local
make

# Executer depuis le repertoire hpm
./hpm --help

# Ou executer via hemlock directement
hemlock src/main.hml --help
```

### Methode 4 : Installation manuelle

Creez votre propre script wrapper :

```bash
# Cloner dans un emplacement permanent
git clone https://github.com/hemlang/hpm.git ~/.hpm-source

# Creer le script wrapper
cat > ~/.local/bin/hpm << 'EOF'
#!/bin/sh
exec hemlock "$HOME/.hpm-source/src/main.hml" "$@"
EOF

chmod +x ~/.local/bin/hpm
```

## Variables d'installation

Le Makefile supporte ces variables :

| Variable | Valeur par defaut | Description |
|----------|-------------------|-------------|
| `PREFIX` | `/usr/local` | Prefixe d'installation |
| `BINDIR` | `$(PREFIX)/bin` | Repertoire des binaires |
| `HEMLOCK` | `hemlock` | Chemin vers l'interpreteur hemlock |

Exemple avec des variables personnalisees :

```bash
make install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock
```

## Fonctionnement

L'installateur cree un script shell wrapper qui invoque l'interpreteur Hemlock avec le code source de hpm :

```bash
#!/bin/sh
exec hemlock "/path/to/hpm/src/main.hml" "$@"
```

Cette approche :
- Ne necessite aucune compilation
- Execute toujours le dernier code source
- Fonctionne de maniere fiable sur toutes les plateformes

## Mise a jour de hpm

Pour mettre a jour hpm vers la derniere version :

```bash
cd /path/to/hpm
git pull origin main

# Reinstaller si le chemin a change
sudo make install
```

## Desinstallation

Supprimer hpm de votre systeme :

```bash
cd /path/to/hpm
sudo make uninstall
```

Ou supprimer manuellement :

```bash
sudo rm /usr/local/bin/hpm
```

## Verification de l'installation

Apres l'installation, verifiez que tout fonctionne :

```bash
# Verifier la version
hpm --version

# Afficher l'aide
hpm --help

# Tester l'initialisation (dans un repertoire vide)
mkdir test-project && cd test-project
hpm init --yes
cat package.json
```

## Depannage

### "hemlock: command not found"

Hemlock n'est pas installe ou n'est pas dans votre PATH. Installez d'abord Hemlock :

```bash
# Verifier si hemlock existe
which hemlock

# Si non trouve, installer Hemlock depuis https://github.com/hemlang/hemlock
```

### "Permission denied"

Utilisez sudo pour une installation systeme, ou installez dans un repertoire utilisateur :

```bash
# Option 1 : Utiliser sudo
sudo make install

# Option 2 : Installer dans le repertoire utilisateur
make install PREFIX=$HOME/.local
```

### "hpm: command not found" apres l'installation

Votre PATH peut ne pas inclure le repertoire d'installation :

```bash
# Verifier ou hpm a ete installe
ls -la /usr/local/bin/hpm

# Ajouter au PATH si utilisation d'un emplacement personnalise
export PATH="$HOME/.local/bin:$PATH"
```

## Notes specifiques aux plateformes

### Linux

L'installation standard fonctionne sur toutes les distributions Linux. Certaines distributions peuvent necessiter :

```bash
# Debian/Ubuntu : S'assurer que les outils de compilation sont installes
sudo apt-get install build-essential git

# Fedora/RHEL
sudo dnf install make git
```

### macOS

L'installation standard fonctionne. Si vous utilisez Homebrew :

```bash
# S'assurer que les outils en ligne de commande Xcode sont installes
xcode-select --install
```

### Windows (WSL)

hpm fonctionne dans le Sous-systeme Windows pour Linux :

```bash
# Dans le terminal WSL
git clone https://github.com/hemlang/hpm.git
cd hpm
make install PREFIX=$HOME/.local
```

## Prochaines etapes

Apres l'installation :

1. [Demarrage rapide](#hpm-installation-quick-start) - Creez votre premier projet
2. [Reference des commandes](#hpm-installation-commands) - Apprenez toutes les commandes
3. [Configuration](#hpm-installation-configuration) - Configurez hpm



################################################################################
# HPM : GUIDE UTILISATEUR
################################################################################

--------------------------------------------------------------------------------
## Commandes
--------------------------------------------------------------------------------

# Reference des commandes

Reference complete de toutes les commandes hpm.

## Options globales

Ces options fonctionnent avec toutes les commandes :

| Option | Description |
|--------|-------------|
| `--help`, `-h` | Afficher le message d'aide |
| `--version`, `-v` | Afficher la version de hpm |
| `--verbose` | Afficher une sortie detaillee |

## Commandes

### hpm init

Creer un nouveau fichier `package.json`.

```bash
hpm init        # Mode interactif
hpm init --yes  # Accepter toutes les valeurs par defaut
hpm init -y     # Forme courte
```

**Options :**

| Option | Description |
|--------|-------------|
| `--yes`, `-y` | Accepter les valeurs par defaut pour toutes les invites |

**Invites interactives :**
- Nom du paquet (format owner/repo)
- Version (defaut : 1.0.0)
- Description
- Auteur
- Licence (defaut : MIT)
- Fichier principal (defaut : src/index.hml)

**Exemple :**

```bash
$ hpm init
Package name (owner/repo): alice/my-lib
Version (1.0.0):
Description: A utility library
Author: Alice <alice@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

---

### hpm install

Installer des dependances ou ajouter de nouveaux paquets.

```bash
hpm install                           # Installer tout depuis package.json
hpm install owner/repo                # Ajouter et installer un paquet
hpm install owner/repo@^1.0.0        # Avec contrainte de version
hpm install owner/repo --dev         # Comme dependance de developpement
hpm i owner/repo                      # Forme courte
```

**Options :**

| Option | Description |
|--------|-------------|
| `--dev`, `-D` | Ajouter aux devDependencies |
| `--verbose` | Afficher la progression detaillee |
| `--dry-run` | Apercu sans installer |
| `--offline` | Installer depuis le cache uniquement (sans reseau) |
| `--parallel` | Activer les telechargements paralleles (experimental) |

**Syntaxe des contraintes de version :**

| Syntaxe | Exemple | Signification |
|---------|---------|---------------|
| (aucune) | `owner/repo` | Derniere version |
| Exacte | `owner/repo@1.2.3` | Exactement 1.2.3 |
| Caret | `owner/repo@^1.2.3` | >=1.2.3 <2.0.0 |
| Tilde | `owner/repo@~1.2.3` | >=1.2.3 <1.3.0 |
| Plage | `owner/repo@>=1.0.0` | Au moins 1.0.0 |

**Exemples :**

```bash
# Installer toutes les dependances
hpm install

# Installer un paquet specifique
hpm install hemlang/json

# Installer avec contrainte de version
hpm install hemlang/sprout@^2.0.0

# Installer comme dependance de developpement
hpm install hemlang/test-utils --dev

# Apercu de ce qui serait installe
hpm install hemlang/sprout --dry-run

# Sortie verbeuse
hpm install --verbose

# Installer depuis le cache uniquement (hors ligne)
hpm install --offline
```

**Sortie :**

```
Installing dependencies...
  + hemlang/sprout@2.1.0
  + hemlang/router@1.5.0 (dependency of hemlang/sprout)

Installed 2 packages in 1.2s
```

---

### hpm uninstall

Supprimer un paquet.

```bash
hpm uninstall owner/repo
hpm rm owner/repo          # Forme courte
hpm remove owner/repo      # Alternative
```

**Exemples :**

```bash
hpm uninstall hemlang/sprout
```

**Sortie :**

```
Removed hemlang/sprout@2.1.0
Updated package.json
Updated package-lock.json
```

---

### hpm update

Mettre a jour les paquets vers les dernieres versions dans les contraintes.

```bash
hpm update              # Mettre a jour tous les paquets
hpm update owner/repo   # Mettre a jour un paquet specifique
hpm up owner/repo       # Forme courte
```

**Options :**

| Option | Description |
|--------|-------------|
| `--verbose` | Afficher la progression detaillee |
| `--dry-run` | Apercu sans mettre a jour |

**Exemples :**

```bash
# Mettre a jour tous les paquets
hpm update

# Mettre a jour un paquet specifique
hpm update hemlang/sprout

# Apercu des mises a jour
hpm update --dry-run
```

**Sortie :**

```
Updating dependencies...
  hemlang/sprout: 2.0.0 â†’ 2.1.0
  hemlang/router: 1.4.0 â†’ 1.5.0

Updated 2 packages
```

---

### hpm list

Afficher les paquets installes.

```bash
hpm list              # Afficher l'arbre complet des dependances
hpm list --depth=0    # Dependances directes uniquement
hpm list --depth=1    # Un niveau de dependances transitives
hpm ls                # Forme courte
```

**Options :**

| Option | Description |
|--------|-------------|
| `--depth=N` | Limiter la profondeur de l'arbre (defaut : tout) |

**Exemples :**

```bash
$ hpm list
my-project@1.0.0
â”œâ”€â”€ hemlang/sprout@2.1.0
â”‚   â”œâ”€â”€ hemlang/router@1.5.0
â”‚   â””â”€â”€ hemlang/middleware@1.2.0
â”œâ”€â”€ hemlang/json@1.2.3
â””â”€â”€ hemlang/test-utils@1.0.0 (dev)

$ hpm list --depth=0
my-project@1.0.0
â”œâ”€â”€ hemlang/sprout@2.1.0
â”œâ”€â”€ hemlang/json@1.2.3
â””â”€â”€ hemlang/test-utils@1.0.0 (dev)
```

---

### hpm outdated

Afficher les paquets avec des versions plus recentes disponibles.

```bash
hpm outdated
```

**Sortie :**

```
Package            Current  Wanted  Latest
hemlang/sprout     2.0.0    2.0.5   2.1.0
hemlang/router     1.4.0    1.4.2   1.5.0
```

- **Current** : Version installee
- **Wanted** : Version la plus elevee correspondant a la contrainte
- **Latest** : Derniere version disponible

---

### hpm run

Executer un script depuis package.json.

```bash
hpm run <script>
hpm run <script> -- <args>
```

**Exemples :**

Avec ce package.json :

```json
{
  "scripts": {
    "start": "hemlock src/index.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/index.hml -o dist/app.hmlc"
  }
}
```

Executer des scripts :

```bash
hpm run start
hpm run test
hpm run build

# Passer des arguments au script
hpm run test -- --verbose
```

---

### hpm test

Raccourci pour `hpm run test`.

```bash
hpm test
hpm test -- --verbose
```

Equivalent a :

```bash
hpm run test
```

---

### hpm why

Expliquer pourquoi un paquet est installe (afficher la chaine de dependances).

```bash
hpm why owner/repo
```

**Exemple :**

```bash
$ hpm why hemlang/router

hemlang/router@1.5.0 is installed because:

my-project@1.0.0
â””â”€â”€ hemlang/sprout@2.1.0
    â””â”€â”€ hemlang/router@1.5.0
```

---

### hpm cache

Gerer le cache global des paquets.

```bash
hpm cache list    # Lister les paquets en cache
hpm cache clean   # Vider tous les paquets en cache
```

**Sous-commandes :**

| Sous-commande | Description |
|---------------|-------------|
| `list` | Afficher tous les paquets en cache et leurs tailles |
| `clean` | Supprimer tous les paquets en cache |

**Exemples :**

```bash
$ hpm cache list
Cached packages in ~/.hpm/cache:

hemlang/sprout
  2.0.0 (1.2 MB)
  2.1.0 (1.3 MB)
hemlang/router
  1.5.0 (450 KB)

Total: 2.95 MB

$ hpm cache clean
Cleared cache (2.95 MB freed)
```

---

## Raccourcis de commandes

Pour plus de commodite, plusieurs commandes ont des alias courts :

| Commande | Raccourcis |
|----------|------------|
| `install` | `i` |
| `uninstall` | `rm`, `remove` |
| `list` | `ls` |
| `update` | `up` |

**Exemples :**

```bash
hpm i hemlang/sprout        # hpm install hemlang/sprout
hpm rm hemlang/sprout       # hpm uninstall hemlang/sprout
hpm ls                      # hpm list
hpm up                      # hpm update
```

---

## Codes de sortie

hpm utilise des codes de sortie specifiques pour indiquer differentes conditions d'erreur :

| Code | Signification |
|------|---------------|
| 0 | Succes |
| 1 | Conflit de dependances |
| 2 | Paquet non trouve |
| 3 | Version non trouvee |
| 4 | Erreur reseau |
| 5 | package.json invalide |
| 6 | Echec de la verification d'integrite |
| 7 | Limite de taux GitHub depassee |
| 8 | Dependance circulaire |

Utilisez les codes de sortie dans les scripts :

```bash
hpm install
if [ $? -ne 0 ]; then
    echo "Installation failed"
    exit 1
fi
```

---

## Variables d'environnement

hpm respecte ces variables d'environnement :

| Variable | Description |
|----------|-------------|
| `GITHUB_TOKEN` | Token API GitHub pour l'authentification |
| `HPM_CACHE_DIR` | Remplacer l'emplacement du repertoire de cache |
| `HOME` | Repertoire personnel de l'utilisateur (pour config/cache) |

**Exemples :**

```bash
# Utiliser un token GitHub pour des limites de taux plus elevees
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Utiliser un repertoire de cache personnalise
export HPM_CACHE_DIR=/tmp/hpm-cache
hpm install
```

---

## Voir aussi

- [Configuration](#hpm-commands-configuration) - Fichiers de configuration
- [Specification des paquets](#hpm-commands-package-spec) - Format package.json
- [Depannage](#hpm-commands-troubleshooting) - Problemes courants


--------------------------------------------------------------------------------
## Configuration
--------------------------------------------------------------------------------

# Configuration

Ce guide couvre toutes les options de configuration de hpm.

## Apercu

hpm peut etre configure via :

1. **Variables d'environnement** - Pour les parametres d'execution
2. **Fichier de configuration global** - `~/.hpm/config.json`
3. **Fichiers de projet** - `package.json` et `package-lock.json`

## Variables d'environnement

### GITHUB_TOKEN

Token API GitHub pour l'authentification.

```bash
export GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx
```

**Avantages de l'authentification :**
- Limites de taux API plus elevees (5000 contre 60 requetes/heure)
- Acces aux depots prives
- Resolution des dependances plus rapide

**Creer un token :**

1. Allez dans GitHub > Settings > Developer settings > Personal access tokens
2. Cliquez sur "Generate new token (classic)"
3. Selectionnez les portees :
   - `repo` - Pour l'acces aux depots prives
   - `read:packages` - Pour GitHub Packages (si utilise)
4. Generez et copiez le token

### HPM_CACHE_DIR

Remplacer le repertoire de cache par defaut.

```bash
export HPM_CACHE_DIR=/custom/cache/path
```

Defaut : `~/.hpm/cache`

**Cas d'utilisation :**
- Systemes CI/CD avec des emplacements de cache personnalises
- Cache partage entre plusieurs projets
- Cache temporaire pour des builds isoles

### HOME

Repertoire personnel de l'utilisateur. Utilise pour localiser :
- Repertoire de configuration : `$HOME/.hpm/`
- Repertoire de cache : `$HOME/.hpm/cache/`

Generalement defini par le systeme ; remplacez uniquement si necessaire.

### Exemple .bashrc / .zshrc

```bash
# Authentification GitHub (recommande)
export GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx

# Emplacement de cache personnalise (optionnel)
# export HPM_CACHE_DIR=/path/to/cache

# Ajouter hpm au PATH (si utilisation d'un emplacement d'installation personnalise)
export PATH="$HOME/.local/bin:$PATH"
```

## Fichier de configuration global

### Emplacement

`~/.hpm/config.json`

### Format

```json
{
  "github_token": "ghp_xxxxxxxxxxxxxxxxxxxx"
}
```

### Creer le fichier de configuration

```bash
# Creer le repertoire de configuration
mkdir -p ~/.hpm

# Creer le fichier de configuration
cat > ~/.hpm/config.json << 'EOF'
{
  "github_token": "ghp_your_token_here"
}
EOF

# Securiser le fichier (recommande)
chmod 600 ~/.hpm/config.json
```

### Priorite des tokens

Si les deux sont definis, la variable d'environnement a la priorite :

1. Variable d'environnement `GITHUB_TOKEN` (la plus haute)
2. Champ `github_token` de `~/.hpm/config.json`
3. Pas d'authentification (par defaut)

## Structure des repertoires

### Repertoires globaux

```
~/.hpm/
â”œâ”€â”€ config.json          # Configuration globale
â””â”€â”€ cache/               # Cache des paquets
    â””â”€â”€ owner/
        â””â”€â”€ repo/
            â””â”€â”€ 1.0.0.tar.gz
```

### Repertoires de projet

```
my-project/
â”œâ”€â”€ package.json         # Manifeste du projet
â”œâ”€â”€ package-lock.json    # Fichier de verrouillage des dependances
â”œâ”€â”€ hem_modules/         # Paquets installes
â”‚   â””â”€â”€ owner/
â”‚       â””â”€â”€ repo/
â”‚           â”œâ”€â”€ package.json
â”‚           â””â”€â”€ src/
â”œâ”€â”€ src/                 # Code source
â””â”€â”€ test/                # Tests
```

## Cache des paquets

### Emplacement

Defaut : `~/.hpm/cache/`

Remplacer avec : variable d'environnement `HPM_CACHE_DIR`

### Structure

```
~/.hpm/cache/
â”œâ”€â”€ hemlang/
â”‚   â”œâ”€â”€ sprout/
â”‚   â”‚   â”œâ”€â”€ 2.0.0.tar.gz
â”‚   â”‚   â””â”€â”€ 2.1.0.tar.gz
â”‚   â””â”€â”€ router/
â”‚       â””â”€â”€ 1.5.0.tar.gz
â””â”€â”€ alice/
    â””â”€â”€ http-client/
        â””â”€â”€ 1.0.0.tar.gz
```

### Gestion du cache

```bash
# Voir les paquets en cache
hpm cache list

# Vider tout le cache
hpm cache clean
```

### Comportement du cache

- Les paquets sont mis en cache apres le premier telechargement
- Les installations suivantes utilisent les versions en cache
- Utilisez `--offline` pour installer uniquement depuis le cache
- Le cache est partage entre tous les projets

## Limites de taux de l'API GitHub

### Sans authentification

- **60 requetes par heure** par adresse IP
- Partage entre tous les utilisateurs non authentifies sur la meme IP
- Rapidement epuise en CI/CD ou avec beaucoup de dependances

### Avec authentification

- **5000 requetes par heure** par utilisateur authentifie
- Limite de taux personnelle, non partagee

### Gestion des limites de taux

hpm automatiquement :
- Reessaie avec un backoff exponentiel (1s, 2s, 4s, 8s)
- Signale les erreurs de limite de taux avec le code de sortie 7
- Suggere l'authentification en cas de limitation

**Solutions en cas de limitation :**

```bash
# Option 1 : S'authentifier avec un token GitHub
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Option 2 : Attendre la reinitialisation de la limite de taux
# (Les limites se reinitialisent toutes les heures)

# Option 3 : Utiliser le mode hors ligne (si les paquets sont en cache)
hpm install --offline
```

## Mode hors ligne

Installer des paquets sans acces reseau :

```bash
hpm install --offline
```

**Exigences :**
- Tous les paquets doivent etre dans le cache
- Le fichier de verrouillage doit exister avec les versions exactes

**Cas d'utilisation :**
- Environnements air-gap
- Builds CI/CD plus rapides (avec cache prechauff)
- Eviter les limites de taux

## Configuration CI/CD

### GitHub Actions

```yaml
name: CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Setup Hemlock
      run: |
        # Installer Hemlock (ajuster selon votre configuration)
        curl -sSL https://hemlock.dev/install.sh | sh

    - name: Cache hpm packages
      uses: actions/cache@v3
      with:
        path: ~/.hpm/cache
        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-hpm-

    - name: Install dependencies
      run: hpm install
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Run tests
      run: hpm test
```

### GitLab CI

```yaml
stages:
  - build
  - test

variables:
  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache

cache:
  paths:
    - .hpm-cache/
  key: $CI_COMMIT_REF_SLUG

build:
  stage: build
  script:
    - hpm install
  artifacts:
    paths:
      - hem_modules/

test:
  stage: test
  script:
    - hpm test
```

### Docker

**Dockerfile :**

```dockerfile
FROM hemlock:latest

WORKDIR /app

# Copier d'abord les fichiers de paquet (pour le cache des couches)
COPY package.json package-lock.json ./

# Installer les dependances
RUN hpm install

# Copier le code source
COPY . .

# Executer l'application
CMD ["hemlock", "src/main.hml"]
```

**docker-compose.yml :**

```yaml
version: '3.8'

services:
  app:
    build: .
    environment:
      - GITHUB_TOKEN=${GITHUB_TOKEN}
    volumes:
      - hpm-cache:/root/.hpm/cache

volumes:
  hpm-cache:
```

## Configuration du proxy

Pour les environnements derriere un proxy, configurez au niveau du systeme :

```bash
export HTTP_PROXY=http://proxy.example.com:8080
export HTTPS_PROXY=http://proxy.example.com:8080
export NO_PROXY=localhost,127.0.0.1

hpm install
```

## Bonnes pratiques de securite

### Securite des tokens

1. **Ne commitez jamais les tokens** dans le controle de version
2. **Utilisez des variables d'environnement** en CI/CD
3. **Limitez les portees des tokens** au minimum requis
4. **Faites tourner les tokens** regulierement
5. **Securisez le fichier de configuration** :
   ```bash
   chmod 600 ~/.hpm/config.json
   ```

### Depots prives

Pour acceder aux paquets prives :

1. Creez un token avec la portee `repo`
2. Configurez l'authentification (variable d'environnement ou fichier de configuration)
3. Assurez-vous que le token a acces au depot

```bash
# Tester l'acces
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install yourorg/private-package
```

## Depannage de la configuration

### Verifier la configuration

```bash
# Verifier si le token est defini
echo $GITHUB_TOKEN | head -c 10

# Verifier le fichier de configuration
cat ~/.hpm/config.json

# Verifier le repertoire de cache
ls -la ~/.hpm/cache/

# Tester avec une sortie verbeuse
hpm install --verbose
```

### Problemes courants

**"GitHub rate limit exceeded"**
- Configurez l'authentification avec `GITHUB_TOKEN`
- Attendez la reinitialisation de la limite de taux
- Utilisez `--offline` si les paquets sont en cache

**"Permission denied" sur le cache**
```bash
# Corriger les permissions du cache
chmod -R u+rw ~/.hpm/cache
```

**"Config file not found"**
```bash
# Creer le repertoire de configuration
mkdir -p ~/.hpm
touch ~/.hpm/config.json
```

## Voir aussi

- [Installation](#hpm-configuration-installation) - Installer hpm
- [Depannage](#hpm-configuration-troubleshooting) - Problemes courants
- [Commandes](#hpm-configuration-commands) - Reference des commandes


--------------------------------------------------------------------------------
## DÃ©pannage
--------------------------------------------------------------------------------

# Depannage

Solutions aux problemes courants de hpm.

## Problemes d'installation

### "hemlock: command not found"

**Cause :** Hemlock n'est pas installe ou n'est pas dans le PATH.

**Solution :**

```bash
# Verifier si hemlock existe
which hemlock

# Si non trouve, installer d'abord Hemlock
# Visitez : https://github.com/hemlang/hemlock

# Apres l'installation, verifier
hemlock --version
```

### "hpm: command not found"

**Cause :** hpm n'est pas installe ou n'est pas dans le PATH.

**Solution :**

```bash
# Verifier ou hpm est installe
ls -la /usr/local/bin/hpm
ls -la ~/.local/bin/hpm

# Si utilisation d'un emplacement personnalise, ajouter au PATH
export PATH="$HOME/.local/bin:$PATH"

# Ajouter a ~/.bashrc ou ~/.zshrc pour la persistance
echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc

# Reinstaller si necessaire
cd /path/to/hpm
sudo make install
```

### "Permission denied" pendant l'installation

**Cause :** Pas de permission d'ecriture dans le repertoire d'installation.

**Solution :**

```bash
# Option 1 : Utiliser sudo pour une installation systeme
sudo make install

# Option 2 : Installer dans le repertoire utilisateur (sans sudo)
make install PREFIX=$HOME/.local
```

## Problemes de dependances

### "Package not found" (code de sortie 2)

**Cause :** Le paquet n'existe pas sur GitHub.

**Solution :**

```bash
# Verifier que le paquet existe
# Verifiez : https://github.com/owner/repo

# Verifier l'orthographe
hpm install hemlang/sprout  # Correct
hpm install hemlan/sprout   # Mauvais proprietaire
hpm install hemlang/spout   # Mauvais depot

# Verifier les fautes de frappe dans package.json
cat package.json | grep -A 5 dependencies
```

### "Version not found" (code de sortie 3)

**Cause :** Aucune release ne correspond a la contrainte de version.

**Solution :**

```bash
# Lister les versions disponibles (verifier les releases/tags GitHub)
# Les tags doivent commencer par 'v' (ex: v1.0.0)

# Utiliser une contrainte de version valide
hpm install owner/repo@^1.0.0

# Essayer la derniere version
hpm install owner/repo

# Verifier les tags disponibles sur GitHub
# https://github.com/owner/repo/tags
```

### "Dependency conflict" (code de sortie 1)

**Cause :** Deux paquets necessitent des versions incompatibles d'une dependance.

**Solution :**

```bash
# Voir le conflit
hpm install --verbose

# Verifier ce qui necessite la dependance
hpm why conflicting/package

# Solutions :
# 1. Mettre a jour le paquet en conflit
hpm update problem/package

# 2. Modifier les contraintes de version dans package.json
# Editer pour permettre des versions compatibles

# 3. Supprimer un des paquets en conflit
hpm uninstall one/package
```

### "Circular dependency" (code de sortie 8)

**Cause :** Le paquet A depend de B, qui depend de A.

**Solution :**

```bash
# Identifier le cycle
hpm install --verbose

# C'est generalement un bug dans les paquets
# Contacter les mainteneurs des paquets

# Solution de contournement : eviter un des paquets
```

## Problemes reseau

### "Network error" (code de sortie 4)

**Cause :** Impossible de se connecter a l'API GitHub.

**Solution :**

```bash
# Verifier la connexion internet
ping github.com

# Verifier si l'API GitHub est accessible
curl -I https://api.github.com

# Reessayer (hpm reessaie automatiquement)
hpm install

# Utiliser le mode hors ligne si les paquets sont en cache
hpm install --offline

# Verifier les parametres du proxy si derriere un pare-feu
export HTTPS_PROXY=http://proxy:8080
hpm install
```

### "GitHub rate limit exceeded" (code de sortie 7)

**Cause :** Trop de requetes API sans authentification.

**Solution :**

```bash
# Option 1 : S'authentifier avec un token GitHub (recommande)
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Creer un token : GitHub > Settings > Developer settings > Personal access tokens

# Option 2 : Enregistrer le token dans le fichier de configuration
mkdir -p ~/.hpm
echo '{"github_token": "ghp_xxxxxxxxxxxx"}' > ~/.hpm/config.json

# Option 3 : Attendre la reinitialisation de la limite (reinitialisation horaire)

# Option 4 : Utiliser le mode hors ligne
hpm install --offline
```

### Timeout de connexion

**Cause :** Reseau lent ou problemes de l'API GitHub.

**Solution :**

```bash
# hpm reessaie automatiquement avec un backoff exponentiel

# Verifier si GitHub a des problemes
# Visitez : https://www.githubstatus.com

# Reessayer plus tard
hpm install

# Utiliser les paquets en cache
hpm install --offline
```

## Problemes de package.json

### "Invalid package.json" (code de sortie 5)

**Cause :** Malformation ou champs obligatoires manquants.

**Solution :**

```bash
# Valider la syntaxe JSON
cat package.json | python -m json.tool

# Verifier les champs obligatoires
cat package.json

# Champs obligatoires :
# - "name" : format owner/repo
# - "version" : format X.Y.Z

# Regenerer si necessaire
rm package.json
hpm init
```

### Erreur de format "name"

**Cause :** Le nom du paquet n'est pas au format `owner/repo`.

**Solution :**

```json
// Incorrect
{
  "name": "my-package"
}

// Correct
{
  "name": "yourusername/my-package"
}
```

### Erreur de format "version"

**Cause :** La version n'est pas au format semver.

**Solution :**

```json
// Incorrect
{
  "version": "1.0"
}

// Correct
{
  "version": "1.0.0"
}
```

## Problemes de fichier de verrouillage

### Fichier de verrouillage desynchronise

**Cause :** package.json modifie sans executer install.

**Solution :**

```bash
# Regenerer le fichier de verrouillage
rm package-lock.json
hpm install
```

### Fichier de verrouillage corrompu

**Cause :** JSON invalide ou modifications manuelles.

**Solution :**

```bash
# Verifier la validite JSON
cat package-lock.json | python -m json.tool

# Regenerer
rm package-lock.json
hpm install
```

## Problemes de hem_modules

### Les paquets ne s'installent pas

**Cause :** Divers problemes possibles.

**Solution :**

```bash
# Nettoyer et reinstaller
rm -rf hem_modules
hpm install

# Verifier la sortie verbeuse
hpm install --verbose
```

### L'import ne fonctionne pas

**Cause :** Paquet pas correctement installe ou mauvais chemin d'import.

**Solution :**

```bash
# Verifier que le paquet est installe
ls hem_modules/owner/repo/

# Verifier le champ main de package.json
cat hem_modules/owner/repo/package.json

# Format d'import correct
import { x } from "owner/repo";          # Utilise l'entree main
import { y } from "owner/repo/subpath";  # Import de sous-chemin
```

### Erreur "Module not found"

**Cause :** Le chemin d'import ne correspond pas a un fichier.

**Solution :**

```bash
# Verifier le chemin d'import
ls hem_modules/owner/repo/src/

# Verifier index.hml
ls hem_modules/owner/repo/src/index.hml

# Verifier le champ main dans package.json
cat hem_modules/owner/repo/package.json | grep main
```

## Problemes de cache

### Le cache prend trop d'espace

**Solution :**

```bash
# Voir la taille du cache
hpm cache list

# Vider le cache
hpm cache clean
```

### Permissions du cache

**Solution :**

```bash
# Corriger les permissions
chmod -R u+rw ~/.hpm/cache

# Ou supprimer et reinstaller
rm -rf ~/.hpm/cache
hpm install
```

### Utilisation du mauvais cache

**Solution :**

```bash
# Verifier l'emplacement du cache
echo $HPM_CACHE_DIR
ls ~/.hpm/cache

# Effacer la variable d'environnement si incorrecte
unset HPM_CACHE_DIR
```

## Problemes de scripts

### "Script not found"

**Cause :** Le nom du script n'existe pas dans package.json.

**Solution :**

```bash
# Lister les scripts disponibles
cat package.json | grep -A 20 scripts

# Verifier l'orthographe
hpm run test    # Correct
hpm run tests   # Incorrect si le script s'appelle "test"
```

### Le script echoue

**Cause :** Erreur dans la commande du script.

**Solution :**

```bash
# Executer la commande directement pour voir l'erreur
hemlock test/run.hml

# Verifier la definition du script
cat package.json | grep test
```

## Debogage

### Activer la sortie verbeuse

```bash
hpm install --verbose
```

### Verifier la version de hpm

```bash
hpm --version
```

### Verifier la version de hemlock

```bash
hemlock --version
```

### Simulation (dry run)

Apercu sans effectuer de modifications :

```bash
hpm install --dry-run
```

### Repartir de zero

Commencer proprement :

```bash
rm -rf hem_modules package-lock.json
hpm install
```

## Obtenir de l'aide

### Aide des commandes

```bash
hpm --help
hpm install --help
```

### Signaler des problemes

Si vous rencontrez un bug :

1. Verifiez les issues existantes : https://github.com/hemlang/hpm/issues
2. Creez une nouvelle issue avec :
   - Version de hpm (`hpm --version`)
   - Version de Hemlock (`hemlock --version`)
   - Systeme d'exploitation
   - Etapes pour reproduire
   - Message d'erreur (utilisez `--verbose`)

## Reference des codes de sortie

| Code | Signification | Solution courante |
|------|---------------|-------------------|
| 0 | Succes | - |
| 1 | Conflit de dependances | Mettre a jour ou changer les contraintes |
| 2 | Paquet non trouve | Verifier l'orthographe, verifier que le depot existe |
| 3 | Version non trouvee | Verifier les versions disponibles sur GitHub |
| 4 | Erreur reseau | Verifier la connexion, reessayer |
| 5 | package.json invalide | Corriger la syntaxe JSON et les champs obligatoires |
| 6 | Echec de verification d'integrite | Vider le cache, reinstaller |
| 7 | Limite de taux GitHub | Ajouter GITHUB_TOKEN |
| 8 | Dependance circulaire | Contacter les mainteneurs des paquets |

## Voir aussi

- [Installation](#hpm-troubleshooting-installation) - Guide d'installation
- [Configuration](#hpm-troubleshooting-configuration) - Options de configuration
- [Commandes](#hpm-troubleshooting-commands) - Reference des commandes



################################################################################
# HPM : DÃ‰VELOPPEMENT DE PAQUETS
################################################################################

--------------------------------------------------------------------------------
## CrÃ©ation de Paquets
--------------------------------------------------------------------------------

# Creer des paquets

Ce guide explique comment creer, structurer et publier des paquets Hemlock.

## Apercu

hpm utilise GitHub comme registre de paquets. Les paquets sont identifies par leur chemin GitHub `owner/repo`, et les versions sont des tags Git. Publier consiste simplement a pousser une release taguee.

## Creer un nouveau paquet

### 1. Initialiser le paquet

Creez un nouveau repertoire et initialisez :

```bash
mkdir my-package
cd my-package
hpm init
```

Repondez aux invites :

```
Package name (owner/repo): yourusername/my-package
Version (1.0.0):
Description: A useful Hemlock package
Author: Your Name <you@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

### 2. Creer la structure du projet

Structure recommandee pour les paquets :

```
my-package/
â”œâ”€â”€ package.json          # Manifeste du paquet
â”œâ”€â”€ README.md             # Documentation
â”œâ”€â”€ LICENSE               # Fichier de licence
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.hml         # Point d'entree principal (exporte l'API publique)
â”‚   â”œâ”€â”€ utils.hml         # Utilitaires internes
â”‚   â””â”€â”€ types.hml         # Definitions de types
â””â”€â”€ test/
    â”œâ”€â”€ framework.hml     # Framework de test
    â””â”€â”€ test_utils.hml    # Tests
```

### 3. Definir votre API publique

**src/index.hml** - Point d'entree principal :

```hemlock
// Reexporter l'API publique
export { parse, stringify } from "./parser.hml";
export { Config, Options } from "./types.hml";
export { process } from "./processor.hml";

// Exports directs
export fn create(options: Options): Config {
    // Implementation
}

export fn validate(config: Config): bool {
    // Implementation
}
```

### 4. Ecrire votre package.json

Exemple complet de package.json :

```json
{
  "name": "yourusername/my-package",
  "version": "1.0.0",
  "description": "A useful Hemlock package",
  "author": "Your Name <you@example.com>",
  "license": "MIT",
  "repository": "https://github.com/yourusername/my-package",
  "main": "src/index.hml",
  "dependencies": {
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  },
  "scripts": {
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/index.hml -o dist/bundle.hmlc"
  },
  "keywords": ["utility", "parser", "config"],
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ]
}
```

## Nommage des paquets

### Exigences

- Doit etre au format `owner/repo`
- `owner` doit etre votre nom d'utilisateur GitHub ou organisation
- `repo` doit etre le nom du depot
- Utilisez des minuscules avec des tirets pour les noms composes

### Bons noms

```
hemlang/sprout
alice/http-client
myorg/json-utils
bob/date-formatter
```

### A eviter

```
my-package          # Proprietaire manquant
alice/MyPackage     # PascalCase
alice/my_package    # Underscores
```

## Bonnes pratiques de structure des paquets

### Point d'entree

Le champ `main` dans package.json specifie le point d'entree :

```json
{
  "main": "src/index.hml"
}
```

Ce fichier doit exporter votre API publique :

```hemlock
// Exporter tout ce dont les utilisateurs ont besoin
export { Parser, parse } from "./parser.hml";
export { Formatter, format } from "./formatter.hml";

// Types
export type { Config, Options } from "./types.hml";
```

### Interne vs public

Gardez les details d'implementation internes prives :

```
src/
â”œâ”€â”€ index.hml          # Public : API exportee
â”œâ”€â”€ parser.hml         # Public : utilise par index.hml
â”œâ”€â”€ formatter.hml      # Public : utilise par index.hml
â””â”€â”€ internal/
    â”œâ”€â”€ helpers.hml    # Prive : usage interne uniquement
    â””â”€â”€ constants.hml  # Prive : usage interne uniquement
```

Les utilisateurs importent depuis la racine de votre paquet :

```hemlock
// Bien - importe depuis l'API publique
import { parse, Parser } from "yourusername/my-package";

// Fonctionne aussi - import de sous-chemin
import { validate } from "yourusername/my-package/validator";

// Deconseille - acces aux internes
import { helper } from "yourusername/my-package/internal/helpers";
```

### Exports de sous-chemins

Supportez l'import depuis des sous-chemins :

```
src/
â”œâ”€â”€ index.hml              # Entree principale
â”œâ”€â”€ parser/
â”‚   â””â”€â”€ index.hml          # yourusername/pkg/parser
â”œâ”€â”€ formatter/
â”‚   â””â”€â”€ index.hml          # yourusername/pkg/formatter
â””â”€â”€ utils/
    â””â”€â”€ index.hml          # yourusername/pkg/utils
```

Les utilisateurs peuvent importer :

```hemlock
import { parse } from "yourusername/my-package";           // Principal
import { Parser } from "yourusername/my-package/parser";   // Sous-chemin
import { format } from "yourusername/my-package/formatter";
```

## Dependances

### Ajouter des dependances

```bash
# Dependance d'execution
hpm install hemlang/json

# Dependance de developpement
hpm install hemlang/test-utils --dev
```

### Bonnes pratiques pour les dependances

1. **Utilisez des plages caret** pour la plupart des dependances :
   ```json
   {
     "dependencies": {
       "hemlang/json": "^1.0.0"
     }
   }
   ```

2. **Epinglez les versions** uniquement si necessaire (instabilite de l'API) :
   ```json
   {
     "dependencies": {
       "unstable/lib": "1.2.3"
     }
   }
   ```

3. **Evitez les plages trop restrictives** :
   ```json
   // Mauvais : trop restrictif
   "hemlang/json": ">=1.2.3 <1.2.5"

   // Bon : permet les mises a jour compatibles
   "hemlang/json": "^1.2.3"
   ```

4. **Separez les dependances de developpement** :
   ```json
   {
     "dependencies": {
       "hemlang/json": "^1.0.0"
     },
     "devDependencies": {
       "hemlang/test-utils": "^1.0.0"
     }
   }
   ```

## Tester votre paquet

### Ecrire des tests

**test/run.hml :**

```hemlock
import { suite, test, assert_eq } from "./framework.hml";
import { parse, stringify } from "../src/index.hml";

fn run_tests() {
    suite("Parser", fn() {
        test("parses valid input", fn() {
            let result = parse("hello");
            assert_eq(result.value, "hello");
        });

        test("handles empty input", fn() {
            let result = parse("");
            assert_eq(result.value, "");
        });
    });

    suite("Stringify", fn() {
        test("stringifies object", fn() {
            let obj = { name: "test" };
            let result = stringify(obj);
            assert_eq(result, '{"name":"test"}');
        });
    });
}

run_tests();
```

### Executer les tests

Ajoutez un script de test :

```json
{
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
```

Executez avec :

```bash
hpm test
```

## Publication

### Prerequis

1. Creez un depot GitHub correspondant au nom de votre paquet
2. Assurez-vous que `package.json` est complet et valide
3. Tous les tests passent

### Processus de publication

Publier consiste simplement a pousser un tag Git :

```bash
# 1. S'assurer que tout est commite
git add .
git commit -m "Prepare v1.0.0 release"

# 2. Creer un tag de version (doit commencer par 'v')
git tag v1.0.0

# 3. Pousser le code et les tags
git push origin main
git push origin v1.0.0
# Ou pousser tous les tags d'un coup
git push origin main --tags
```

### Tags de version

Les tags doivent suivre le format `vX.Y.Z` :

```bash
git tag v1.0.0      # Release
git tag v1.0.1      # Patch
git tag v1.1.0      # Mineure
git tag v2.0.0      # Majeure
git tag v1.0.0-beta.1  # Pre-release
```

### Liste de verification avant publication

Avant de publier une nouvelle version :

1. **Mettre a jour la version** dans package.json
2. **Executer les tests** : `hpm test`
3. **Mettre a jour le CHANGELOG** (si vous en avez un)
4. **Mettre a jour le README** si l'API a change
5. **Commiter les modifications**
6. **Creer le tag**
7. **Pousser vers GitHub**

### Exemple automatise

Creez un script de release :

```bash
#!/bin/bash
# release.sh - Publier une nouvelle version

VERSION=$1

if [ -z "$VERSION" ]; then
    echo "Usage: ./release.sh 1.0.0"
    exit 1
fi

# Executer les tests
hpm test || exit 1

# Mettre a jour la version dans package.json
sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json

# Commiter et taguer
git add package.json
git commit -m "Release v$VERSION"
git tag "v$VERSION"

# Pousser
git push origin main --tags

echo "Released v$VERSION"
```

## Les utilisateurs installent votre paquet

Apres publication, les utilisateurs peuvent installer :

```bash
# Derniere version
hpm install yourusername/my-package

# Version specifique
hpm install yourusername/my-package@1.0.0

# Contrainte de version
hpm install yourusername/my-package@^1.0.0
```

Et importer :

```hemlock
import { parse, stringify } from "yourusername/my-package";
```

## Documentation

### README.md

Chaque paquet devrait avoir un README :

```markdown
# my-package

Une breve description de ce que fait ce paquet.

## Installation

\`\`\`bash
hpm install yourusername/my-package
\`\`\`

## Utilisation

\`\`\`hemlock
import { parse } from "yourusername/my-package";

let result = parse("input");
\`\`\`

## API

### parse(input: string): Result

Analyse la chaine d'entree.

### stringify(obj: any): string

Convertit un objet en chaine.

## Licence

MIT
```

### Documentation de l'API

Documentez tous les exports publics :

```hemlock
/// Analyse la chaine d'entree en un Result structure.
///
/// # Arguments
/// * `input` - La chaine a analyser
///
/// # Retourne
/// Un Result contenant les donnees analysees ou une erreur
///
/// # Exemple
/// ```
/// let result = parse("hello world");
/// print(result.value);
/// ```
export fn parse(input: string): Result {
    // Implementation
}
```

## Directives de versionnage

Suivez le [Versionnage semantique](https://semver.org/) :

- **MAJEUR** (1.0.0 -> 2.0.0) : Changements incompatibles
- **MINEUR** (1.0.0 -> 1.1.0) : Nouvelles fonctionnalites, retro-compatibles
- **PATCH** (1.0.0 -> 1.0.1) : Corrections de bugs, retro-compatibles

### Quand incrementer

| Type de changement | Increment de version |
|--------------------|---------------------|
| Changement d'API incompatible | MAJEUR |
| Suppression de fonction/type | MAJEUR |
| Changement de signature de fonction | MAJEUR |
| Ajout d'une nouvelle fonction | MINEUR |
| Ajout d'une nouvelle fonctionnalite | MINEUR |
| Correction de bug | PATCH |
| Mise a jour de documentation | PATCH |
| Refactoring interne | PATCH |

## Voir aussi

- [Specification des paquets](#hpm-creating-packages-package-spec) - Reference complete de package.json
- [Versionnage](#hpm-creating-packages-versioning) - Details du versionnage semantique
- [Configuration](#hpm-creating-packages-configuration) - Authentification GitHub


--------------------------------------------------------------------------------
## Gestion des Versions
--------------------------------------------------------------------------------

# Versionnage

Guide complet du versionnage semantique dans hpm.

## Versionnage semantique

hpm utilise le [Versionnage semantique 2.0.0](https://semver.org/) (semver) pour les versions des paquets.

### Format de version

```
MAJEUR.MINEUR.PATCH[-PRERELEASE][+BUILD]
```

**Exemples :**
```
1.0.0           # Version de release
2.1.3           # Version de release
1.0.0-alpha     # Pre-release
1.0.0-beta.1    # Pre-release avec numero
1.0.0-rc.1      # Release candidate
1.0.0+20231201  # Avec metadonnees de build
1.0.0-beta+exp  # Pre-release avec metadonnees de build
```

### Composants de version

| Composant | Description | Exemple |
|-----------|-------------|---------|
| MAJEUR | Changements incompatibles | `1.0.0` -> `2.0.0` |
| MINEUR | Nouvelles fonctionnalites (retro-compatible) | `1.0.0` -> `1.1.0` |
| PATCH | Corrections de bugs (retro-compatible) | `1.0.0` -> `1.0.1` |
| PRERELEASE | Identifiant de pre-release | `1.0.0-alpha` |
| BUILD | Metadonnees de build (ignorees dans la comparaison) | `1.0.0+build123` |

### Quand incrementer

| Type de changement | Increment | Exemple |
|--------------------|-----------|---------|
| Changement d'API incompatible | MAJEUR | Suppression d'une fonction |
| Renommer une fonction publique | MAJEUR | `parse()` -> `decode()` |
| Changer la signature d'une fonction | MAJEUR | Ajouter un parametre obligatoire |
| Ajouter une nouvelle fonction | MINEUR | Ajouter `validate()` |
| Ajouter un parametre optionnel | MINEUR | Nouveau arg `options` optionnel |
| Correction de bug | PATCH | Corriger un pointeur null |
| Amelioration de performance | PATCH | Algorithme plus rapide |
| Refactoring interne | PATCH | Pas de changement d'API |

## Contraintes de version

### Syntaxe des contraintes

| Syntaxe | Signification | Resout vers |
|---------|---------------|-------------|
| `1.2.3` | Version exacte | 1.2.3 uniquement |
| `^1.2.3` | Caret (compatible) | >=1.2.3 et <2.0.0 |
| `~1.2.3` | Tilde (mises a jour patch) | >=1.2.3 et <1.3.0 |
| `>=1.0.0` | Au moins | 1.0.0 ou superieur |
| `>1.0.0` | Superieur a | Superieur a 1.0.0 |
| `<2.0.0` | Inferieur a | Inferieur a 2.0.0 |
| `<=2.0.0` | Au plus | 2.0.0 ou inferieur |
| `>=1.0.0 <2.0.0` | Plage | Entre 1.0.0 et 2.0.0 |
| `*` | N'importe quelle | N'importe quelle version |

### Plages Caret (^)

Le caret (`^`) permet les changements qui ne modifient pas le chiffre non-nul le plus a gauche :

```
^1.2.3  ->  >=1.2.3 <2.0.0   # Permet 1.x.x
^0.2.3  ->  >=0.2.3 <0.3.0   # Permet 0.2.x
^0.0.3  ->  >=0.0.3 <0.0.4   # Permet 0.0.3 uniquement
```

**Utilisez quand :** Vous voulez des mises a jour compatibles dans une version majeure.

**Contrainte la plus courante** - recommandee pour la plupart des dependances.

### Plages Tilde (~)

Le tilde (`~`) permet uniquement les changements de niveau patch :

```
~1.2.3  ->  >=1.2.3 <1.3.0   # Permet 1.2.x
~1.2    ->  >=1.2.0 <1.3.0   # Permet 1.2.x
~1      ->  >=1.0.0 <2.0.0   # Permet 1.x.x
```

**Utilisez quand :** Vous voulez uniquement les corrections de bugs, pas de nouvelles fonctionnalites.

### Plages de comparaison

Combinez les operateurs de comparaison pour un controle precis :

```json
{
  "dependencies": {
    "owner/pkg": ">=1.0.0 <2.0.0",
    "owner/other": ">1.5.0 <=2.1.0"
  }
}
```

### N'importe quelle version (*)

Correspond a n'importe quelle version :

```json
{
  "dependencies": {
    "owner/pkg": "*"
  }
}
```

**Attention :** Non recommande pour la production. Obtiendra toujours la derniere version.

## Versions pre-release

### Identifiants de pre-release

Les pre-releases ont une precedence inferieure aux releases :

```
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0
```

### Tags de pre-release courants

| Tag | Signification | Etape |
|-----|---------------|-------|
| `alpha` | Developpement initial | Tres instable |
| `beta` | Fonctionnalites completes | Tests |
| `rc` | Release candidate | Tests finaux |
| `dev` | Snapshot de developpement | Instable |

### Pre-release dans les contraintes

Les contraintes ne correspondent pas aux pre-releases par defaut :

```
^1.0.0    # Ne correspond PAS a 1.1.0-beta
>=1.0.0   # Ne correspond PAS a 2.0.0-alpha
```

Pour inclure les pre-releases, referencez-les explicitement :

```
>=1.0.0-alpha <2.0.0   # Inclut toutes les pre-releases 1.x
```

## Comparaison de versions

### Regles de comparaison

1. Comparez MAJEUR, MINEUR, PATCH numeriquement
2. Release > pre-release avec la meme version
3. Pre-releases comparees alphanumeriquement
4. Les metadonnees de build sont ignorees

### Exemples

```
1.0.0 < 1.0.1 < 1.1.0 < 2.0.0

1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0

1.0.0 = 1.0.0+build123  # Metadonnees de build ignorees
```

### Tri

Les versions sont triees par ordre croissant :

```
1.0.0
1.0.1
1.1.0
1.1.1
2.0.0-alpha
2.0.0-beta
2.0.0
```

## Resolution de version

### Algorithme de resolution

Quand plusieurs paquets necessitent la meme dependance :

1. Collecter toutes les contraintes
2. Trouver l'intersection de toutes les plages
3. Selectionner la version la plus elevee dans l'intersection
4. Erreur si aucune version ne satisfait toutes les contraintes

### Exemple de resolution

```
package-a necessite hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)
package-b necessite hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)

Intersection: >=1.2.0 <1.3.0
Disponibles: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]
Resolue: 1.2.5 (la plus elevee dans l'intersection)
```

### Detection de conflits

Un conflit survient quand aucune version ne satisfait toutes les contraintes :

```
package-a necessite hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)
package-b necessite hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)

Intersection: (vide)
Resultat: CONFLIT - aucune version ne satisfait les deux
```

## Bonnes pratiques

### Pour les consommateurs de paquets

1. **Utilisez des plages caret** pour la plupart des dependances :
   ```json
   "hemlang/json": "^1.2.0"
   ```

2. **Utilisez des plages tilde** pour les dependances critiques :
   ```json
   "critical/lib": "~1.2.0"
   ```

3. **Epinglez les versions** uniquement si necessaire :
   ```json
   "unstable/pkg": "1.2.3"
   ```

4. **Commitez votre fichier de verrouillage** pour des builds reproductibles

5. **Mettez a jour regulierement** pour obtenir les correctifs de securite :
   ```bash
   hpm update
   hpm outdated
   ```

### Pour les auteurs de paquets

1. **Commencez a 0.1.0** pour le developpement initial :
   - L'API peut changer frequemment
   - Les utilisateurs s'attendent a de l'instabilite

2. **Passez a 1.0.0** quand l'API est stable :
   - Engagement public envers la stabilite
   - Les changements incompatibles necessitent un increment majeur

3. **Suivez strictement semver** :
   - Changement incompatible = MAJEUR
   - Nouvelle fonctionnalite = MINEUR
   - Correction de bug = PATCH

4. **Utilisez les pre-releases** pour les tests :
   ```bash
   git tag v2.0.0-beta.1
   git push --tags
   ```

5. **Documentez les changements incompatibles** dans le CHANGELOG

## Publication de versions

### Creer des releases

```bash
# Mettre a jour la version dans package.json
# Editez package.json : "version": "1.1.0"

# Commiter le changement de version
git add package.json
git commit -m "Bump version to 1.1.0"

# Creer et pousser le tag
git tag v1.1.0
git push origin main --tags
```

### Format des tags

Les tags **doivent** commencer par `v` :

```
v1.0.0      Correct
v1.0.0-beta Correct
1.0.0       Ne sera pas reconnu
```

### Flux de travail de release

```bash
# 1. S'assurer que les tests passent
hpm test

# 2. Mettre a jour la version dans package.json
# 3. Mettre a jour CHANGELOG.md
# 4. Commiter les changements
git add -A
git commit -m "Release v1.2.0"

# 5. Creer le tag
git tag v1.2.0

# 6. Tout pousser
git push origin main --tags
```

## Verifier les versions

### Lister les versions installees

```bash
hpm list
```

### Verifier les mises a jour disponibles

```bash
hpm outdated
```

Sortie :
```
Package         Current  Wanted  Latest
hemlang/json    1.0.0    1.0.5   1.2.0
hemlang/sprout  2.0.0    2.0.3   2.1.0
```

- **Current** : Version installee
- **Wanted** : Plus haute correspondant a la contrainte
- **Latest** : Derniere disponible

### Mettre a jour les paquets

```bash
# Mettre a jour tout
hpm update

# Mettre a jour un paquet specifique
hpm update hemlang/json
```

## Voir aussi

- [Creer des paquets](#hpm-versioning-creating-packages) - Guide de publication
- [Specification des paquets](#hpm-versioning-package-spec) - Format package.json
- [Commandes](#hpm-versioning-commands) - Reference CLI


--------------------------------------------------------------------------------
## SpÃ©cification des Paquets
--------------------------------------------------------------------------------

# Specification des paquets

Reference complete pour le format du fichier `package.json`.

## Apercu

Chaque paquet hpm necessite un fichier `package.json` a la racine du projet. Ce fichier definit les metadonnees du paquet, les dependances et les scripts.

## Exemple minimal

```json
{
  "name": "owner/repo",
  "version": "1.0.0"
}
```

## Exemple complet

```json
{
  "name": "hemlang/example-package",
  "version": "1.2.3",
  "description": "An example Hemlock package",
  "author": "Hemlock Team <team@hemlock.dev>",
  "license": "MIT",
  "repository": "https://github.com/hemlang/example-package",
  "homepage": "https://hemlang.github.io/example-package",
  "bugs": "https://github.com/hemlang/example-package/issues",
  "main": "src/index.hml",
  "keywords": ["example", "utility", "hemlock"],
  "dependencies": {
    "hemlang/json": "^1.0.0",
    "hemlang/http": "^2.1.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  },
  "scripts": {
    "start": "hemlock src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/bundle.hmlc"
  },
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ],
  "native": {
    "requires": ["libcurl", "openssl"]
  }
}
```

## Reference des champs

### name (obligatoire)

Le nom du paquet au format `owner/repo`.

```json
{
  "name": "hemlang/sprout"
}
```

**Exigences :**
- Doit etre au format `owner/repo`
- `owner` doit etre votre nom d'utilisateur GitHub ou organisation
- `repo` doit etre le nom du depot
- Utilisez des lettres minuscules, des chiffres et des tirets
- Maximum 214 caracteres au total

**Noms valides :**
```
hemlang/sprout
alice/http-client
myorg/json-utils
bob123/my-lib
```

**Noms invalides :**
```
my-package          # Proprietaire manquant
hemlang/My_Package  # Majuscules et underscore
hemlang             # Depot manquant
```

### version (obligatoire)

La version du paquet suivant le [Versionnage semantique](https://semver.org/).

```json
{
  "version": "1.2.3"
}
```

**Format :** `MAJEUR.MINEUR.PATCH[-PRERELEASE][+BUILD]`

**Versions valides :**
```
1.0.0
2.1.3
1.0.0-alpha
1.0.0-beta.1
1.0.0-rc.1+build.123
0.1.0
```

### description

Description courte du paquet.

```json
{
  "description": "A fast JSON parser for Hemlock"
}
```

- Gardez-la sous 200 caracteres
- Decrivez ce que fait le paquet, pas comment

### author

Informations sur l'auteur du paquet.

```json
{
  "author": "Your Name <email@example.com>"
}
```

**Formats acceptes :**
```json
"author": "Your Name"
"author": "Your Name <email@example.com>"
"author": "Your Name <email@example.com> (https://website.com)"
```

### license

L'identifiant de licence.

```json
{
  "license": "MIT"
}
```

**Licences courantes :**
- `MIT` - Licence MIT
- `Apache-2.0` - Licence Apache 2.0
- `GPL-3.0` - Licence publique generale GNU v3.0
- `BSD-3-Clause` - Licence BSD 3 clauses
- `ISC` - Licence ISC
- `UNLICENSED` - Proprietaire/prive

Utilisez les [identifiants SPDX](https://spdx.org/licenses/) quand c'est possible.

### repository

Lien vers le depot source.

```json
{
  "repository": "https://github.com/hemlang/sprout"
}
```

### homepage

URL de la page d'accueil du projet.

```json
{
  "homepage": "https://sprout.hemlock.dev"
}
```

### bugs

URL du gestionnaire de tickets.

```json
{
  "bugs": "https://github.com/hemlang/sprout/issues"
}
```

### main

Fichier point d'entree du paquet.

```json
{
  "main": "src/index.hml"
}
```

**Defaut :** `src/index.hml`

Quand les utilisateurs importent votre paquet :
```hemlock
import { x } from "owner/repo";
```

hpm charge le fichier specifie dans `main`.

**Ordre de resolution pour les imports :**
1. Chemin exact : `src/index.hml`
2. Avec extension .hml : `src/index` -> `src/index.hml`
3. Fichier index : `src/index/` -> `src/index/index.hml`

### keywords

Tableau de mots-cles pour la decouverte.

```json
{
  "keywords": ["json", "parser", "utility", "hemlock"]
}
```

- Utilisez des minuscules
- Soyez specifique et pertinent
- Incluez le langage ("hemlock") si approprie

### dependencies

Dependances d'execution requises pour que le paquet fonctionne.

```json
{
  "dependencies": {
    "hemlang/json": "^1.0.0",
    "hemlang/http": "~2.1.0",
    "alice/logger": ">=1.0.0 <2.0.0"
  }
}
```

**Cle :** Nom du paquet (`owner/repo`)
**Valeur :** Contrainte de version

**Syntaxe des contraintes de version :**

| Contrainte | Signification |
|------------|---------------|
| `1.2.3` | Version exacte |
| `^1.2.3` | >=1.2.3 <2.0.0 |
| `~1.2.3` | >=1.2.3 <1.3.0 |
| `>=1.0.0` | Au moins 1.0.0 |
| `>=1.0.0 <2.0.0` | Plage |
| `*` | N'importe quelle version |

### devDependencies

Dependances uniquement pour le developpement (tests, compilation, etc.).

```json
{
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0",
    "hemlang/linter": "^2.0.0"
  }
}
```

Les dependances de developpement sont :
- Installees pendant le developpement
- Non installees quand le paquet est utilise comme dependance
- Utilisees pour les tests, la compilation, le linting, etc.

### scripts

Commandes nommees qui peuvent etre executees avec `hpm run`.

```json
{
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "test:unit": "hemlock test/unit/run.hml",
    "test:integration": "hemlock test/integration/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc",
    "clean": "rm -rf dist hem_modules",
    "lint": "hemlock-lint src/",
    "format": "hemlock-fmt src/"
  }
}
```

**Executer des scripts :**
```bash
hpm run start
hpm run build
hpm test        # Raccourci pour 'hpm run test'
```

**Passer des arguments :**
```bash
hpm run test -- --verbose --filter=unit
```

**Scripts courants :**

| Script | Objectif |
|--------|----------|
| `start` | Demarrer l'application |
| `dev` | Mode developpement avec rechargement a chaud |
| `test` | Executer les tests |
| `build` | Compiler pour la production |
| `clean` | Supprimer les artefacts de compilation |
| `lint` | Verifier le style du code |
| `format` | Formater le code |

### files

Fichiers et repertoires a inclure quand le paquet est installe.

```json
{
  "files": [
    "src/",
    "lib/",
    "LICENSE",
    "README.md"
  ]
}
```

**Comportement par defaut :** Si non specifie, inclut :
- Tous les fichiers du depot
- Exclut `.git/`, `node_modules/`, `hem_modules/`

**Utilisez pour :**
- Reduire la taille du paquet
- Exclure les fichiers de test de la distribution
- Inclure uniquement les fichiers necessaires

### native

Exigences de bibliotheques natives.

```json
{
  "native": {
    "requires": ["libcurl", "openssl", "sqlite3"]
  }
}
```

Documente les dependances natives qui doivent etre installees sur le systeme.

## Validation

hpm valide package.json lors de diverses operations. Erreurs de validation courantes :

### Champs obligatoires manquants

```
Error: package.json missing required field: name
```

**Correction :** Ajoutez le champ obligatoire.

### Format de nom invalide

```
Error: Invalid package name. Must be in owner/repo format.
```

**Correction :** Utilisez le format `owner/repo`.

### Version invalide

```
Error: Invalid version "1.0". Must be semver format (X.Y.Z).
```

**Correction :** Utilisez le format semver complet (`1.0.0`).

### JSON invalide

```
Error: package.json is not valid JSON
```

**Correction :** Verifiez la syntaxe JSON (virgules, guillemets, crochets).

## Creer package.json

### Interactif

```bash
hpm init
```

Demande chaque champ de maniere interactive.

### Avec les valeurs par defaut

```bash
hpm init --yes
```

Cree avec les valeurs par defaut :
```json
{
  "name": "directory-name/directory-name",
  "version": "1.0.0",
  "description": "",
  "author": "",
  "license": "MIT",
  "main": "src/index.hml",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
```

### Manuel

Creez le fichier manuellement :

```bash
cat > package.json << 'EOF'
{
  "name": "yourname/your-package",
  "version": "1.0.0",
  "description": "Your package description",
  "main": "src/index.hml",
  "dependencies": {},
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
EOF
```

## Bonnes pratiques

1. **Specifiez toujours main** - Ne vous fiez pas a la valeur par defaut
2. **Utilisez des plages caret** - `^1.0.0` pour la plupart des dependances
3. **Separez les dependances de developpement** - Gardez les deps test/build dans devDependencies
4. **Incluez des mots-cles** - Aidez les utilisateurs a trouver votre paquet
5. **Documentez les scripts** - Nommez les scripts clairement
6. **Specifiez la licence** - Obligatoire pour l'open source
7. **Ajoutez une description** - Aidez les utilisateurs a comprendre l'objectif

## Voir aussi

- [Creer des paquets](#hpm-package-spec-creating-packages) - Guide de publication
- [Versionnage](#hpm-package-spec-versioning) - Contraintes de version
- [Configuration du projet](#hpm-package-spec-project-setup) - Structure du projet



################################################################################
# HPM : RÃ‰FÃ‰RENCE
################################################################################

--------------------------------------------------------------------------------
## Architecture
--------------------------------------------------------------------------------

# Architecture

Architecture interne et conception de hpm. Ce document est destine aux contributeurs et a ceux qui souhaitent comprendre comment fonctionne hpm.

## Apercu

hpm est ecrit en Hemlock et se compose de plusieurs modules qui gerent differents aspects de la gestion des paquets :

```
src/
â”œâ”€â”€ main.hml        # Point d'entree CLI et routage des commandes
â”œâ”€â”€ manifest.hml    # Gestion de package.json
â”œâ”€â”€ lockfile.hml    # Gestion de package-lock.json
â”œâ”€â”€ semver.hml      # Versionnage semantique
â”œâ”€â”€ resolver.hml    # Resolution des dependances
â”œâ”€â”€ github.hml      # Client API GitHub
â”œâ”€â”€ installer.hml   # Telechargement et extraction des paquets
â””â”€â”€ cache.hml       # Gestion du cache global
```

## Responsabilites des modules

### main.hml

Le point d'entree de l'application CLI.

**Responsabilites :**
- Analyser les arguments de ligne de commande
- Router les commandes vers les gestionnaires appropries
- Afficher l'aide et les informations de version
- Gerer les options globales (--verbose, --dry-run, etc.)
- Sortir avec les codes appropries

**Fonctions principales :**
- `main()` - Point d'entree, analyse les args et dispatche les commandes
- `cmd_init()` - Gerer `hpm init`
- `cmd_install()` - Gerer `hpm install`
- `cmd_uninstall()` - Gerer `hpm uninstall`
- `cmd_update()` - Gerer `hpm update`
- `cmd_list()` - Gerer `hpm list`
- `cmd_outdated()` - Gerer `hpm outdated`
- `cmd_run()` - Gerer `hpm run`
- `cmd_why()` - Gerer `hpm why`
- `cmd_cache()` - Gerer `hpm cache`

**Raccourcis de commandes :**
```hemlock
let shortcuts = {
    "i": "install",
    "rm": "uninstall",
    "remove": "uninstall",
    "ls": "list",
    "up": "update"
};
```

### manifest.hml

Gere la lecture et l'ecriture des fichiers `package.json`.

**Responsabilites :**
- Lire/ecrire package.json
- Valider la structure du paquet
- Gerer les dependances
- Analyser les specificateurs de paquets (owner/repo@version)

**Fonctions principales :**
```hemlock
create_default(): Manifest           // Creer un manifeste vide
read_manifest(): Manifest            // Lire depuis le fichier
write_manifest(m: Manifest)          // Ecrire dans le fichier
validate(m: Manifest): bool          // Valider la structure
get_all_dependencies(m): Map         // Obtenir deps + devDeps
add_dependency(m, pkg, ver, dev)     // Ajouter une dependance
remove_dependency(m, pkg)            // Supprimer une dependance
parse_specifier(spec): (name, ver)   // Analyser "owner/repo@^1.0.0"
split_name(name): (owner, repo)      // Analyser "owner/repo"
```

**Structure Manifest :**
```hemlock
type Manifest = {
    name: string,
    version: string,
    description: string?,
    author: string?,
    license: string?,
    repository: string?,
    main: string?,
    dependencies: Map<string, string>,
    devDependencies: Map<string, string>,
    scripts: Map<string, string>
};
```

### lockfile.hml

Gere le fichier `package-lock.json` pour des installations reproductibles.

**Responsabilites :**
- Creer/lire/ecrire les fichiers de verrouillage
- Suivre les versions exactes resolues
- Stocker les URLs de telechargement et les hashes d'integrite
- Elaguer les dependances orphelines

**Fonctions principales :**
```hemlock
create_empty(): Lockfile              // Creer un lockfile vide
read_lockfile(): Lockfile             // Lire depuis le fichier
write_lockfile(l: Lockfile)           // Ecrire dans le fichier
create_entry(ver, url, hash, deps)    // Creer une entree de verrouillage
get_locked(l, pkg): LockEntry?        // Obtenir la version verrouillee
set_locked(l, pkg, entry)             // Definir la version verrouillee
remove_locked(l, pkg)                 // Supprimer une entree
prune(l, keep: Set)                   // Supprimer les orphelins
needs_update(l, m): bool              // Verifier si desynchronise
```

**Structure Lockfile :**
```hemlock
type Lockfile = {
    lockVersion: int,
    hemlock: string,
    dependencies: Map<string, LockEntry>
};

type LockEntry = {
    version: string,
    resolved: string,     // URL de telechargement
    integrity: string,    // Hash SHA256
    dependencies: Map<string, string>
};
```

### semver.hml

Implementation complete du Versionnage semantique 2.0.0.

**Responsabilites :**
- Analyser les chaines de version
- Comparer les versions
- Analyser et evaluer les contraintes de version
- Trouver les versions satisfaisant les contraintes

**Fonctions principales :**
```hemlock
// Analyse
parse(s: string): Version             // "1.2.3-beta+build" -> Version
stringify(v: Version): string         // Version -> "1.2.3-beta+build"

// Comparaison
compare(a, b: Version): int           // -1, 0, ou 1
gt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool

// Contraintes
parse_constraint(s: string): Constraint    // "^1.2.3" -> Constraint
satisfies(v: Version, c: Constraint): bool // Verifier si v correspond a c
max_satisfying(versions, c): Version?      // Trouver la plus haute correspondance
sort(versions): [Version]                  // Trier par ordre croissant

// Utilitaires
constraints_overlap(a, b: Constraint): bool  // Verifier la compatibilite
```

**Structure Version :**
```hemlock
type Version = {
    major: int,
    minor: int,
    patch: int,
    prerelease: [string]?,  // ex: ["beta", "1"]
    build: string?          // ex: "20230101"
};
```

**Types de contraintes :**
```hemlock
type Constraint =
    | Exact(Version)           // "1.2.3"
    | Caret(Version)           // "^1.2.3" -> >=1.2.3 <2.0.0
    | Tilde(Version)           // "~1.2.3" -> >=1.2.3 <1.3.0
    | Range(op, Version)       // ">=1.0.0", "<2.0.0"
    | And(Constraint, Constraint)  // Plages combinees
    | Any;                     // "*"
```

### resolver.hml

Implemente la resolution de dependances style npm.

**Responsabilites :**
- Resoudre les arbres de dependances
- Detecter les conflits de version
- Detecter les dependances circulaires
- Construire des arbres de visualisation

**Fonctions principales :**
```hemlock
resolve(manifest, lockfile): ResolveResult
    // Resolveur principal : retourne une map plate de toutes les dependances avec versions resolues

resolve_version(pkg, constraints: [string]): ResolvedPackage?
    // Trouver une version satisfaisant toutes les contraintes

detect_cycles(deps: Map): [Cycle]?
    // Trouver les dependances circulaires en utilisant DFS

build_tree(lockfile): Tree
    // Creer une structure d'arbre pour l'affichage

find_why(pkg, lockfile): [Chain]
    // Trouver les chaines de dependances expliquant pourquoi pkg est installe
```

**Algorithme de resolution :**

1. **Collecter les contraintes** : Parcourir le manifeste et les dependances transitives
2. **Resoudre chaque paquet** : Pour chaque paquet :
   - Obtenir toutes les contraintes de version des dependants
   - Recuperer les versions disponibles depuis GitHub
   - Trouver la version la plus haute satisfaisant TOUTES les contraintes
   - Erreur si aucune version ne satisfait toutes (conflit)
3. **Detecter les cycles** : Executer DFS pour trouver les dependances circulaires
4. **Retourner une map plate** : Nom du paquet -> info de version resolue

**Structure ResolveResult :**
```hemlock
type ResolveResult = {
    packages: Map<string, ResolvedPackage>,
    conflicts: [Conflict]?,
    cycles: [Cycle]?
};

type ResolvedPackage = {
    name: string,
    version: Version,
    url: string,
    dependencies: Map<string, string>
};
```

### github.hml

Client API GitHub pour la decouverte et le telechargement de paquets.

**Responsabilites :**
- Recuperer les versions disponibles (tags)
- Telecharger package.json depuis les depots
- Telecharger les tarballs de release
- Gerer l'authentification et les limites de taux

**Fonctions principales :**
```hemlock
get_token(): string?
    // Obtenir le token depuis env ou config

github_request(url, headers?): Response
    // Faire une requete API avec reessais

get_tags(owner, repo): [string]
    // Obtenir les tags de version (v1.0.0, v1.1.0, etc.)

get_package_json(owner, repo, ref): Manifest
    // Recuperer package.json a un tag/commit specifique

download_tarball(owner, repo, tag): bytes
    // Telecharger l'archive de release

repo_exists(owner, repo): bool
    // Verifier si le depot existe

get_repo_info(owner, repo): RepoInfo
    // Obtenir les metadonnees du depot
```

**Logique de reessai :**
- Backoff exponentiel : 1s, 2s, 4s, 8s
- Reessaie sur : 403 (limite de taux), 5xx (erreur serveur), erreurs reseau
- Maximum 4 reessais
- Signale clairement les erreurs de limite de taux

**Points de terminaison API utilises :**
```
GET /repos/{owner}/{repo}/tags
GET /repos/{owner}/{repo}/contents/package.json?ref={tag}
GET /repos/{owner}/{repo}/tarball/{tag}
GET /repos/{owner}/{repo}
```

### installer.hml

Gere le telechargement et l'extraction des paquets.

**Responsabilites :**
- Telecharger les paquets depuis GitHub
- Extraire les tarballs vers hem_modules
- Verifier/utiliser les paquets en cache
- Installer/desinstaller les paquets

**Fonctions principales :**
```hemlock
install_package(pkg: ResolvedPackage): bool
    // Telecharger et installer un seul paquet

install_all(packages: Map, options): InstallResult
    // Installer tous les paquets resolus

uninstall_package(name: string): bool
    // Supprimer un paquet de hem_modules

get_installed(): Map<string, string>
    // Lister les paquets actuellement installes

verify_integrity(pkg): bool
    // Verifier l'integrite du paquet

prefetch_packages(packages: Map): void
    // Telechargement parallele vers le cache (experimental)
```

**Processus d'installation :**

1. Verifier si deja installe a la bonne version
2. Verifier le cache pour le tarball
3. Si pas en cache, telecharger depuis GitHub
4. Stocker dans le cache pour utilisation future
5. Extraire vers `hem_modules/owner/repo/`
6. Verifier l'installation

**Structure de repertoire creee :**
```
hem_modules/
â””â”€â”€ owner/
    â””â”€â”€ repo/
        â”œâ”€â”€ package.json
        â”œâ”€â”€ src/
        â””â”€â”€ ...
```

### cache.hml

Gere le cache global des paquets.

**Responsabilites :**
- Stocker les tarballs telecharges
- Recuperer les paquets en cache
- Lister les paquets en cache
- Vider le cache
- Gerer la configuration

**Fonctions principales :**
```hemlock
get_cache_dir(): string
    // Obtenir le repertoire de cache (respecte HPM_CACHE_DIR)

get_config_dir(): string
    // Obtenir le repertoire de config (~/.hpm)

is_cached(owner, repo, version): bool
    // Verifier si le tarball est en cache

get_cached_path(owner, repo, version): string
    // Obtenir le chemin vers le tarball en cache

store_tarball_file(owner, repo, version, data): void
    // Sauvegarder le tarball dans le cache

list_cached(): [CachedPackage]
    // Lister tous les paquets en cache

clear_cache(): int
    // Supprimer tous les paquets en cache, retourner les octets liberes

get_cache_size(): int
    // Calculer la taille totale du cache

read_config(): Config
    // Lire ~/.hpm/config.json

write_config(c: Config): void
    // Ecrire le fichier de config
```

**Structure du cache :**
```
~/.hpm/
â”œâ”€â”€ config.json
â””â”€â”€ cache/
    â””â”€â”€ owner/
        â””â”€â”€ repo/
            â”œâ”€â”€ 1.0.0.tar.gz
            â””â”€â”€ 1.1.0.tar.gz
```

## Flux de donnees

### Flux de la commande Install

```
hpm install owner/repo@^1.0.0
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ main.hml â”‚ Analyser les args, appeler cmd_install
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚manifest.hmlâ”‚ Lire package.json, ajouter la dependance
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚resolver.hmlâ”‚ Resoudre toutes les dependances
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ github.hmlâ”‚    â”‚ semver.hmlâ”‚ Obtenir versions, trouver satisfaisante
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚installer.hmlâ”‚ Telecharger et extraire les paquets
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ github.hmlâ”‚    â”‚ cache.hmlâ”‚ Telecharger ou utiliser le cache
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚lockfile.hmlâ”‚ Mettre a jour package-lock.json
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Detail de l'algorithme de resolution

```
Entree: manifest.dependencies, manifest.devDependencies, lockfile existant

1. Initialiser:
   - constraints = {} // Map<string, [Constraint]>
   - resolved = {}    // Map<string, ResolvedPackage>
   - queue = [dependances directes]

2. Tant que queue non vide:
   a. pkg = queue.pop()
   b. Si pkg deja resolu, passer
   c. Obtenir toutes les contraintes pour pkg depuis les dependants
   d. Recuperer les versions disponibles depuis GitHub (en cache)
   e. Trouver la version max satisfaisant toutes les contraintes
   f. Si aucune trouvee: CONFLIT
   g. resolved[pkg] = {version, url, deps}
   h. Ajouter les dependances de pkg a la queue

3. Detecter les cycles dans le graphe resolu
   - Si cycle trouve: ERREUR

4. Retourner la map resolue
```

## Gestion des erreurs

### Codes de sortie

Definis dans main.hml :

```hemlock
let EXIT_SUCCESS = 0;
let EXIT_CONFLICT = 1;
let EXIT_NOT_FOUND = 2;
let EXIT_VERSION_NOT_FOUND = 3;
let EXIT_NETWORK = 4;
let EXIT_INVALID_MANIFEST = 5;
let EXIT_INTEGRITY = 6;
let EXIT_RATE_LIMIT = 7;
let EXIT_CIRCULAR = 8;
```

### Propagation des erreurs

Les erreurs remontent via les valeurs de retour :

```hemlock
fn resolve_version(pkg): Result<Version, ResolveError> {
    let versions = github.get_tags(owner, repo)?;  // ? propage
    // ...
}
```

## Tests

### Framework de test

Framework de test personnalise dans `test/framework.hml` :

```hemlock
fn suite(name: string, tests: fn()) {
    print("Suite: " + name);
    tests();
}

fn test(name: string, body: fn()) {
    try {
        body();
        print("  âœ“ " + name);
    } catch e {
        print("  âœ— " + name + ": " + e);
        failed += 1;
    }
}

fn assert_eq<T>(actual: T, expected: T) {
    if actual != expected {
        throw "Expected " + expected + ", got " + actual;
    }
}
```

### Fichiers de test

- `test/test_semver.hml` - Analyse de version, comparaison, contraintes
- `test/test_manifest.hml` - Lecture/ecriture de manifeste, validation
- `test/test_lockfile.hml` - Operations sur le lockfile
- `test/test_cache.hml` - Gestion du cache

### Executer les tests

```bash
# Tous les tests
make test

# Tests specifiques
make test-semver
make test-manifest
make test-lockfile
make test-cache
```

## Ameliorations futures

### Fonctionnalites prevues

1. **Verification d'integrite** - Verification complete du hash SHA256
2. **Workspaces** - Support des monorepos
3. **Systeme de plugins** - Commandes extensibles
4. **Audit** - Verification des vulnerabilites de securite
5. **Registre prive** - Hebergement de paquets auto-heberge

### Limitations connues

1. **Bug du bundler** - Ne peut pas creer d'executable autonome
2. **Telechargements paralleles** - Experimental, peut avoir des conditions de course
3. **Integrite** - SHA256 pas completement implemente

## Contribuer

### Style de code

- Utilisez une indentation de 4 espaces
- Les fonctions doivent faire une seule chose
- Commentez la logique complexe
- Ecrivez des tests pour les nouvelles fonctionnalites

### Ajouter une commande

1. Ajoutez un gestionnaire dans `main.hml` :
   ```hemlock
   fn cmd_newcmd(args: [string]) {
       // Implementation
   }
   ```

2. Ajoutez au dispatch de commande :
   ```hemlock
   match command {
       "newcmd" => cmd_newcmd(args),
       // ...
   }
   ```

3. Mettez a jour le texte d'aide

### Ajouter un module

1. Creez `src/newmodule.hml`
2. Exportez l'interface publique
3. Importez dans les modules qui en ont besoin
4. Ajoutez des tests dans `test/test_newmodule.hml`

## Voir aussi

- [Commandes](#hpm-architecture-commands) - Reference CLI
- [Creer des paquets](#hpm-architecture-creating-packages) - Developpement de paquets
- [Versionnage](#hpm-architecture-versioning) - Versionnage semantique


--------------------------------------------------------------------------------
## Codes de Sortie
--------------------------------------------------------------------------------

# Codes de sortie

Reference des codes de sortie de hpm et leur signification.

## Tableau des codes de sortie

| Code | Nom | Description |
|------|-----|-------------|
| 0 | SUCCESS | Commande executee avec succes |
| 1 | CONFLICT | Conflit de version de dependance |
| 2 | NOT_FOUND | Paquet non trouve |
| 3 | VERSION_NOT_FOUND | Version demandee non trouvee |
| 4 | NETWORK | Erreur reseau |
| 5 | INVALID_MANIFEST | package.json invalide |
| 6 | INTEGRITY | Echec de la verification d'integrite |
| 7 | RATE_LIMIT | Limite de taux de l'API GitHub depassee |
| 8 | CIRCULAR | Dependance circulaire detectee |

## Descriptions detaillees

### Code de sortie 0 : SUCCESS

La commande s'est executee avec succes.

```bash
$ hpm install
Installed 5 packages
$ echo $?
0
```

### Code de sortie 1 : CONFLICT

Deux paquets ou plus necessitent des versions incompatibles d'une dependance.

**Exemple :**
```
Error: Dependency conflict for hemlang/json

  package-a requires hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)
  package-b requires hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)

No version satisfies all constraints.
```

**Solutions :**
1. Verifiez quels paquets ont le conflit :
   ```bash
   hpm why hemlang/json
   ```
2. Mettez a jour le paquet en conflit :
   ```bash
   hpm update package-a
   ```
3. Assouplissez les contraintes de version dans package.json
4. Supprimez un des paquets en conflit

### Code de sortie 2 : NOT_FOUND

Le paquet specifie n'existe pas sur GitHub.

**Exemple :**
```
Error: Package not found: hemlang/nonexistent

The repository hemlang/nonexistent does not exist on GitHub.
```

**Solutions :**
1. Verifiez l'orthographe du nom du paquet
2. Verifiez si le depot existe : `https://github.com/owner/repo`
3. Verifiez que vous avez acces (pour les depots prives, definissez GITHUB_TOKEN)

### Code de sortie 3 : VERSION_NOT_FOUND

Aucune version ne correspond a la contrainte specifiee.

**Exemple :**
```
Error: No version of hemlang/json matches constraint ^5.0.0

Available versions: 1.0.0, 1.1.0, 1.2.0, 2.0.0
```

**Solutions :**
1. Verifiez les versions disponibles sur les releases/tags GitHub
2. Utilisez une contrainte de version valide
3. Les tags de version doivent commencer par 'v' (ex: `v1.0.0`)

### Code de sortie 4 : NETWORK

Une erreur liee au reseau s'est produite.

**Exemple :**
```
Error: Network error: could not connect to api.github.com

Please check your internet connection and try again.
```

**Solutions :**
1. Verifiez votre connexion internet
2. Verifiez si GitHub est accessible
3. Verifiez les parametres du proxy si vous etes derriere un pare-feu
4. Utilisez `--offline` si les paquets sont en cache :
   ```bash
   hpm install --offline
   ```
5. Attendez et reessayez (hpm reessaie automatiquement)

### Code de sortie 5 : INVALID_MANIFEST

Le fichier package.json est invalide ou malformation.

**Exemple :**
```
Error: Invalid package.json

  - Missing required field: name
  - Invalid version format: "1.0"
```

**Solutions :**
1. Verifiez la syntaxe JSON (utilisez un validateur JSON)
2. Assurez-vous que les champs obligatoires existent (`name`, `version`)
3. Verifiez les formats des champs :
   - name : format `owner/repo`
   - version : format semver `X.Y.Z`
4. Regenerez :
   ```bash
   rm package.json
   hpm init
   ```

### Code de sortie 6 : INTEGRITY

La verification d'integrite du paquet a echoue.

**Exemple :**
```
Error: Integrity check failed for hemlang/json@1.0.0

Expected: sha256-abc123...
Actual:   sha256-def456...

The downloaded package may be corrupted.
```

**Solutions :**
1. Videz le cache et reinstallez :
   ```bash
   hpm cache clean
   hpm install
   ```
2. Verifiez les problemes reseau (telechargements partiels)
3. Verifiez que le paquet n'a pas ete altere

### Code de sortie 7 : RATE_LIMIT

La limite de taux de l'API GitHub a ete depassee.

**Exemple :**
```
Error: GitHub API rate limit exceeded

Unauthenticated rate limit: 60 requests/hour
Current usage: 60/60

Rate limit resets at: 2024-01-15 10:30:00 UTC
```

**Solutions :**
1. **S'authentifier avec GitHub** (recommande) :
   ```bash
   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
   hpm install
   ```
2. Attendre la reinitialisation de la limite de taux (reinitialisation horaire)
3. Utiliser le mode hors ligne si les paquets sont en cache :
   ```bash
   hpm install --offline
   ```

### Code de sortie 8 : CIRCULAR

Dependance circulaire detectee dans le graphe de dependances.

**Exemple :**
```
Error: Circular dependency detected

  package-a@1.0.0
  â””â”€â”€ package-b@1.0.0
      â””â”€â”€ package-a@1.0.0  (circular!)

Cannot resolve dependency tree.
```

**Solutions :**
1. C'est generalement un bug dans les paquets eux-memes
2. Contactez les mainteneurs des paquets
3. Evitez d'utiliser un des paquets circulaires

## Utiliser les codes de sortie dans les scripts

### Bash

```bash
#!/bin/bash

hpm install
exit_code=$?

case $exit_code in
  0)
    echo "Installation reussie"
    ;;
  1)
    echo "Conflit de dependances - verifiez les contraintes de version"
    exit 1
    ;;
  2)
    echo "Paquet non trouve - verifiez le nom du paquet"
    exit 1
    ;;
  4)
    echo "Erreur reseau - verifiez la connexion"
    exit 1
    ;;
  7)
    echo "Limite de taux atteinte - definissez GITHUB_TOKEN"
    exit 1
    ;;
  *)
    echo "Erreur inconnue : $exit_code"
    exit 1
    ;;
esac
```

### CI/CD

```yaml
# GitHub Actions
- name: Install dependencies
  run: |
    hpm install
    if [ $? -eq 7 ]; then
      echo "::error::GitHub rate limit exceeded. Add GITHUB_TOKEN."
      exit 1
    fi
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### Make

```makefile
install:
	@hpm install || (echo "Installation failed with code $$?"; exit 1)

test: install
	@hpm test
```

## Depannage par code de sortie

### Reference rapide

| Code | Premiere chose a verifier |
|------|---------------------------|
| 1 | Executez `hpm why <package>` pour voir le conflit |
| 2 | Verifiez le nom du paquet sur GitHub |
| 3 | Verifiez les versions disponibles sur les tags GitHub |
| 4 | Verifiez la connexion internet |
| 5 | Validez la syntaxe de package.json |
| 6 | Executez `hpm cache clean && hpm install` |
| 7 | Definissez la variable d'environnement `GITHUB_TOKEN` |
| 8 | Contactez les mainteneurs des paquets |

## Voir aussi

- [Depannage](#hpm-exit-codes-troubleshooting) - Solutions detaillees
- [Commandes](#hpm-exit-codes-commands) - Reference des commandes
- [Configuration](#hpm-exit-codes-configuration) - Configuration du token GitHub



================================================================================
END OF DOCUMENTATION
================================================================================