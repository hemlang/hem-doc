================================================================================
HEMLOCK PROGRAMMING LANGUAGE - COMPLETE DOCUMENTATION
================================================================================

This file contains the complete documentation for the Hemlock programming
language and the hpm package manager. It is optimized for LLM consumption.

Source: https://github.com/hemlang/hem-doc

--------------------------------------------------------------------------------
TABLE OF CONTENTS
--------------------------------------------------------------------------------

  1. Language Reference

[Getting Started]
  2. Installation
  3. Learning Paths
  4. Quick Start
  5. Tutorial

[Language Guide]
  6. Arrays
  7. Control Flow
  8. Error Handling
  9. Functions
  10. Memory
  11. Modules
  12. Objects
  13. Pattern Matching
  14. Runes
  15. Strings
  16. Syntax
  17. Types

[Advanced Topics]
  18. Async Concurrency
  19. Atomics
  20. Bundling Packaging
  21. Command Execution
  22. Command Line Args
  23. FFI
  24. File IO
  25. Profiling
  26. Signals

[API Reference]
  27. Array API
  28. Builtins
  29. Concurrency API
  30. File API
  31. Memory API
  32. Operators
  33. String API
  34. Type System

[Design & Philosophy]
  35. Implementation
  36. Philosophy
  37. Signature Syntax

[Contributing]
  38. Guidelines
  39. Testing

[hpm: Getting Started]
  40. Installation
  41. Project Setup
  42. Quick Start

[hpm: User Guide]
  43. Commands
  44. Configuration
  45. Troubleshooting

[hpm: Package Development]
  46. Creating Packages
  47. Package Spec
  48. Versioning

[hpm: Reference]
  49. Architecture
  50. Exit Codes


================================================================================
DOCUMENTATION
================================================================================

--------------------------------------------------------------------------------
## Language Reference
--------------------------------------------------------------------------------

# Hemlock Language Design Philosophy

> "A small, unsafe language for writing unsafe things safely."

This document captures the core design principles for AI assistants working with Hemlock.
For detailed documentation, see `docs/README.md` and the `stdlib/docs/` directory.

---

## Core Identity

Hemlock is a **systems scripting language** with manual memory management and explicit control:
- The power of C with modern scripting ergonomics
- Structured async concurrency built-in
- No hidden behavior or magic

**Hemlock is NOT:** Memory-safe, a GC language, or hiding complexity.
**Hemlock IS:** Explicit over implicit, educational, a "C scripting layer" for systems work.

---

## Design Principles

### 1. Explicit Over Implicit
- Semicolons mandatory (no ASI)
- Manual memory management (alloc/free)
- Type annotations optional but checked at runtime

### 2. Dynamic by Default, Typed by Choice
- Every value has a runtime type tag
- Literals infer types: `42` â†’ i32, `5000000000` â†’ i64, `3.14` â†’ f64
- Optional type annotations enforce runtime checks

### 3. Unsafe is a Feature
- Pointer arithmetic allowed (user's responsibility)
- No bounds checking on raw `ptr` (use `buffer` for safety)
- Double-free crashes allowed

### 4. Structured Concurrency First-Class
- `async`/`await` built-in with pthread-based parallelism
- Channels for communication
- `spawn`/`join`/`detach` for task management

### 5. C-like Syntax
- `{}` blocks always required
- Comments: `// line` and `/* block */`
- Operators match C: `+`, `-`, `*`, `%`, `&&`, `||`, `!`, `&`, `|`, `^`, `<<`, `>>`
- Increment/decrement: `++x`, `x++`, `--x`, `x--` (prefix and postfix)
- Compound assignment: `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`
- `/` always returns float (use `divi()` for integer division)
- Type syntax: `let x: type = value;`

---

## Quick Reference

### Types
```
Signed:   i8, i16, i32, i64
Unsigned: u8, u16, u32, u64
Floats:   f32, f64
Other:    bool, string, rune, array, ptr, buffer, null, object, file, task, channel
Aliases:  integer (i32), number (f64), byte (u8)
```

**Type promotion:** i8 â†’ i16 â†’ i32 â†’ i64 â†’ f32 â†’ f64 (floats always win, but i64/u64 + f32 â†’ f64 to preserve precision)

### Literals
```hemlock
let x = 42;              // i32
let big = 5000000000;    // i64 (> i32 max)
let hex = 0xDEADBEEF;    // hex literal
let bin = 0b1010;        // binary literal
let oct = 0o777;         // octal literal
let sep = 1_000_000;     // numeric separators allowed
let pi = 3.14;           // f64
let half = .5;           // f64 (no leading zero)
let s = "hello";         // string
let esc = "\x41\u{1F600}"; // hex and unicode escapes
let ch = 'A';            // rune
let emoji = 'ðŸš€';        // rune (Unicode)
let arr = [1, 2, 3];     // array
let obj = { x: 10 };     // object
```

### Type Conversion
```hemlock
// Type constructor functions - parse strings to types
let n = i32("42");       // Parse string to i32
let f = f64("3.14");     // Parse string to f64
let b = bool("true");    // Parse string to bool ("true" or "false")

// All numeric types supported
let a = i8("-128");      // i8, i16, i32, i64
let c = u8("255");       // u8, u16, u32, u64
let d = f32("1.5");      // f32, f64

// Hex and negative numbers
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42

// Type aliases work too
let x = integer("100");  // Same as i32("100")
let y = number("1.5");   // Same as f64("1.5")
let z = byte("200");     // Same as u8("200")

// Convert between numeric types
let big = i64(42);       // i32 to i64
let truncated = i32(3.99); // f64 to i32 (truncates to 3)

// Type annotations validate types (but don't parse strings)
let f: f64 = 100;        // i32 to f64 via annotation (numeric coercion OK)
// let n: i32 = "42";    // ERROR - use i32("42") for string parsing
```

### Introspection
```hemlock
typeof(42);              // "i32"
typeof("hello");         // "string"
typeof([1, 2, 3]);       // "array"
typeof(null);            // "null"
len("hello");            // 5 (string length in bytes)
len([1, 2, 3]);          // 3 (array length)
```

### Memory
```hemlock
let p = alloc(64);       // raw pointer
let b = buffer(64);      // safe buffer (bounds checked)
memset(p, 0, 64);
memcpy(dest, src, 64);
free(p);                 // manual cleanup required
```

### Control Flow
```hemlock
if (x > 0) { } else if (x < 0) { } else { }
while (cond) { break; continue; }
for (let i = 0; i < 10; i++) { }
for (item in array) { }
loop { if (done) { break; } }   // infinite loop (cleaner than while(true))
switch (x) { case 1: break; default: break; }  // C-style fall-through
defer cleanup();         // runs when function returns

// Loop labels for targeted break/continue in nested loops
outer: while (cond) {
    inner: for (let i = 0; i < 10; i++) {
        if (i == 5) { break outer; }     // break outer loop
        if (i == 3) { continue outer; }  // continue outer loop
    }
}
```

### Pattern Matching
```hemlock
// Match expression - returns value
let result = match (value) {
    0 => "zero",                    // Literal pattern
    1 | 2 | 3 => "small",           // OR pattern
    n if n < 10 => "medium",        // Guard expression
    n => "large: " + n              // Variable binding
};

// Type patterns
match (val) {
    n: i32 => "integer",
    s: string => "string",
    _ => "other"                    // Wildcard
}

// Object destructuring
match (point) {
    { x: 0, y: 0 } => "origin",
    { x, y } => "at " + x + "," + y
}

// Array destructuring with rest
match (arr) {
    [] => "empty",
    [first, ...rest] => "head: " + first,
    _ => "other"
}

// Nested patterns
match (user) {
    { name, address: { city } } => name + " in " + city
}
```

See `docs/language-guide/pattern-matching.md` for full documentation.

### Null Coalescing Operators
```hemlock
// Null coalescing (??) - returns left if non-null, else right
let name = user.name ?? "Anonymous";
let first = a ?? b ?? c ?? "fallback";

// Null coalescing assignment (??=) - assigns only if null
let config = null;
config ??= { timeout: 30 };    // config is now { timeout: 30 }
config ??= { timeout: 60 };    // config unchanged (not null)

// Works with properties and indices
obj.field ??= "default";
arr[0] ??= "first";

// Safe navigation (?.) - returns null if object is null
let city = user?.address?.city;  // null if any part is null
let upper = name?.to_upper();    // safe method call
let item = arr?.[0];             // safe indexing
```

### Functions
```hemlock
fn add(a: i32, b: i32): i32 { return a + b; }
fn greet(name: string, msg?: "Hello") { print(msg + " " + name); }
let f = fn(x) { return x * 2; };  // anonymous/closure

// Expression-bodied functions (arrow syntax)
fn double(x: i32): i32 => x * 2;
fn max(a: i32, b: i32): i32 => a > b ? a : b;
let square = fn(x: i32): i32 => x * x;  // anonymous expression-bodied

// Parameter modifiers
fn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // pass-by-reference
fn print_all(const items: array) { for (i in items) { print(i); } }  // immutable
```

### Named Arguments
```hemlock
// Functions can be called with named arguments
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " is " + age + " years old");
}

// Positional arguments (traditional)
create_user("Alice", 25, false);

// Named arguments - can be in any order
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);

// Skip optional parameters by naming what you need
create_user("David", active: false);  // Uses default age=18

// Named arguments must come after positional arguments
create_user("Eve", age: 21);          // OK: positional then named
// create_user(name: "Bad", 25);      // ERROR: positional after named
```

**Rules:**
- Named arguments use `name: value` syntax
- Can appear in any order after positional arguments
- Positional arguments cannot follow named arguments
- Works with default/optional parameters
- Unknown parameter names cause runtime errors

### Objects & Enums
```hemlock
define Person { name: string, age: i32, active?: true }
let p: Person = { name: "Alice", age: 30 };
let json = p.serialize();
let restored = json.deserialize();

// Object shorthand syntax (ES6-style)
let name = "Alice";
let age = 30;
let person = { name, age };         // equivalent to { name: name, age: age }

// Object spread operator
let defaults = { theme: "dark", size: "medium" };
let config = { ...defaults, size: "large" };  // copies defaults, overrides size

enum Color { RED, GREEN, BLUE }
enum Status { OK = 0, ERROR = 1 }
```

### Compound Types (Intersection/Duck Types)
```hemlock
// Define structural types
define HasName { name: string }
define HasAge { age: i32 }
define HasEmail { email: string }

// Compound type: object must satisfy ALL types
let person: HasName & HasAge = { name: "Alice", age: 30 };

// Function parameters with compound types
fn greet(p: HasName & HasAge) {
    print(p.name + " is " + p.age);
}

// Three or more types
fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}

// Extra fields allowed (duck typing)
let employee: HasName & HasAge = {
    name: "Bob",
    age: 25,
    department: "Engineering"  // OK - extra fields ignored
};
```

Compound types provide interface-like behavior without a separate `interface` keyword,
building on the existing `define` and duck typing paradigms.

### Type Aliases
```hemlock
// Simple type alias
type Integer = i32;
type Text = string;

// Function type alias
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// Compound type alias (great for reusable interfaces)
define HasName { name: string }
define HasAge { age: i32 }
type Person = HasName & HasAge;

// Generic type alias
type Pair<T> = { first: T, second: T };

// Using type aliases
let x: Integer = 42;
let cb: Callback = fn(n) { print(n); };
let p: Person = { name: "Alice", age: 30 };
```

Type aliases create named shortcuts for complex types, improving readability and maintainability.

### Function Types
```hemlock
// Function type annotations for parameters
fn apply_fn(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Higher-order function returning a function
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Async function types
fn run_async(handler: async fn(): void) {
    spawn(handler);
}

// Function types with multiple parameters
type BinaryOp = fn(i32, i32): i32;
let add: BinaryOp = fn(a, b) { return a + b; };
```

### Const Parameters
```hemlock
// Const parameter - deep immutability
fn print_all(const items: array) {
    // items.push(4);  // ERROR: cannot mutate const parameter
    for (item in items) {
        print(item);
    }
}

// Const with objects - no mutation through any path
fn describe(const person: object) {
    print(person.name);       // OK: reading is allowed
    // person.name = "Bob";   // ERROR: cannot mutate
}

// Nested access is allowed for reading
fn get_city(const user: object) {
    return user.address.city;  // OK: reading nested properties
}
```

The `const` modifier prevents any mutation of the parameter, including nested properties.
This provides compile-time safety for functions that should not modify their inputs.

### Ref Parameters (Pass-by-Reference)
```hemlock
// Ref parameter - caller's variable is modified directly
fn increment(ref x: i32) {
    x = x + 1;  // Modifies the original variable
}

let count = 10;
increment(count);
print(count);  // 11 - original was modified

// Classic swap function
fn swap(ref a: i32, ref b: i32) {
    let temp = a;
    a = b;
    b = temp;
}

let x = 1;
let y = 2;
swap(x, y);
print(x, y);  // 2 1

// Mix ref and regular parameters
fn add_to(ref target: i32, amount: i32) {
    target = target + amount;
}

let total = 100;
add_to(total, 50);
print(total);  // 150
```

The `ref` modifier passes a reference to the caller's variable, allowing the function to
modify it directly. Without `ref`, primitives are passed by value (copied). Use `ref` when
you need to mutate the caller's state without returning a value.

**Rules:**
- `ref` parameters must be passed variables, not literals or expressions
- Works with all types (primitives, arrays, objects)
- Combine with type annotations: `ref x: i32`
- Cannot combine with `const` (they're opposites)

### Method Signatures in Define
```hemlock
// Define with method signatures (interface pattern)
define Comparable {
    value: i32,
    fn compare(other: Self): i32   // Required method signature
}

// Objects must provide the required method
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};

// Optional methods with ?
define Serializable {
    fn serialize(): string,        // Required
    fn pretty?(): string           // Optional method
}

// Self type refers to the defining type
define Cloneable {
    fn clone(): Self   // Returns same type as the object
}
```

Method signatures in `define` blocks use comma delimiters (like TypeScript interfaces),
establishing contracts that objects must fulfill and enabling interface-like programming
patterns with Hemlock's duck typing system.

### Error Handling
```hemlock
try { throw "error"; } catch (e) { print(e); } finally { cleanup(); }
panic("unrecoverable");  // exits immediately, not catchable
```

### Async/Concurrency
```hemlock
async fn compute(n: i32): i32 { return n * n; }
let task = spawn(compute, 42);
let result = await task;     // or join(task)
detach(spawn(background_work));

let ch = channel(10);
ch.send(value);
let val = ch.recv();
ch.close();
```

**Memory ownership:** Tasks receive copies of primitive values but share pointers. If you pass a `ptr` to a spawned task, you must ensure the memory remains valid until the task completes. Use `join()` before `free()`, or use channels to signal completion.

### User Input
```hemlock
let name = read_line();          // Read line from stdin (blocks)
print("Hello, " + name);
eprint("Error message");         // Print to stderr

// read_line() returns null on EOF
while (true) {
    let line = read_line();
    if (line == null) { break; }
    print("Got:", line);
}
```

### File I/O
```hemlock
let f = open("file.txt", "r");  // modes: r, w, a, r+, w+, a+
let content = f.read();
f.write("data");
f.seek(0);
f.close();
```

### Signals
```hemlock
signal(SIGINT, fn(sig) { print("Interrupted"); });
raise(SIGUSR1);
```

---

## String Methods (19)

`substr`, `slice`, `find`, `contains`, `split`, `trim`, `to_upper`, `to_lower`,
`starts_with`, `ends_with`, `replace`, `replace_all`, `repeat`, `char_at`,
`byte_at`, `chars`, `bytes`, `to_bytes`, `deserialize`

Template strings: `` `Hello ${name}!` ``

**String mutability:** Strings are mutable via index assignment (`s[0] = 'H'`), but all string methods return new strings without modifying the original. This allows in-place mutation when needed while keeping method chaining functional.

**String length properties:**
```hemlock
let s = "hello ðŸš€";
print(s.length);       // 7 (character/rune count)
print(s.byte_length);  // 10 (byte count - emoji is 4 bytes UTF-8)
```

## Array Methods (18)

`push`, `pop`, `shift`, `unshift`, `insert`, `remove`, `find`, `contains`,
`slice`, `join`, `concat`, `reverse`, `first`, `last`, `clear`, `map`, `filter`, `reduce`

Typed arrays: `let nums: array<i32> = [1, 2, 3];`

---

## Standard Library (40 modules)

Import with `@stdlib/` prefix:
```hemlock
import { sin, cos, PI } from "@stdlib/math";
import { HashMap, Queue, Set } from "@stdlib/collections";
import { read_file, write_file } from "@stdlib/fs";
import { TcpStream, UdpSocket } from "@stdlib/net";
```

| Module | Description |
|--------|-------------|
| `arena` | Arena memory allocator (bump allocation) |
| `args` | Command-line argument parsing |
| `assert` | Assertion utilities |
| `async` | ThreadPool, parallel_map |
| `async_fs` | Async file I/O operations |
| `collections` | HashMap, Queue, Stack, Set, LinkedList, LRUCache |
| `compression` | gzip, gunzip, deflate |
| `crypto` | aes_encrypt, rsa_sign, random_bytes |
| `csv` | CSV parsing and generation |
| `datetime` | DateTime class, formatting, parsing |
| `encoding` | base64_encode, hex_encode, url_encode |
| `env` | getenv, setenv, exit, get_pid |
| `fmt` | String formatting utilities |
| `fs` | read_file, write_file, list_dir, exists |
| `glob` | File pattern matching |
| `hash` | sha256, sha512, md5, djb2 |
| `http` | http_get, http_post, http_request |
| `ipc` | Inter-process communication |
| `iter` | Iterator utilities |
| `json` | parse, stringify, pretty, get, set |
| `logging` | Logger with levels |
| `math` | sin, cos, sqrt, pow, rand, PI, E |
| `net` | TcpListener, TcpStream, UdpSocket |
| `os` | platform, arch, cpu_count, hostname |
| `path` | File path manipulation |
| `process` | fork, exec, wait, kill |
| `random` | Random number generation |
| `regex` | compile, test (POSIX ERE) |
| `retry` | Retry logic with backoff |
| `semver` | Semantic versioning |
| `shell` | Shell command utilities |
| `sqlite` | SQLite database, query, exec, transactions |
| `strings` | pad_left, is_alpha, reverse, lines |
| `terminal` | ANSI colors and styles |
| `testing` | describe, test, expect |
| `time` | now, time_ms, sleep, clock |
| `toml` | TOML parsing and generation |
| `url` | URL parsing and manipulation |
| `uuid` | UUID generation |
| `websocket` | WebSocket client |

See `stdlib/docs/` for detailed module documentation.

---

## FFI (Foreign Function Interface)

Declare and call C functions from shared libraries:
```hemlock
import "libc.so.6";

extern fn strlen(s: string): i32;
extern fn getpid(): i32;

let len = strlen("Hello!");  // 6
let pid = getpid();
```

Export FFI functions from modules:
```hemlock
// string_utils.hml
import "libc.so.6";

export extern fn strlen(s: string): i32;
export fn string_length(s: string): i32 {
    return strlen(s);
}
```

Dynamic FFI (runtime binding):
```hemlock
let lib = ffi_open("libc.so.6");
let puts = ffi_bind(lib, "puts", [FFI_POINTER], FFI_INT);
puts("Hello from C!");
ffi_close(lib);
```

Types: `FFI_INT`, `FFI_DOUBLE`, `FFI_POINTER`, `FFI_STRING`, `FFI_VOID`, etc.

---

## Atomic Operations

Lock-free concurrent programming with atomic operations:

```hemlock
// Allocate memory for atomic i32
let p = alloc(4);
ptr_write_i32(p, 0);

// Atomic load/store
let val = atomic_load_i32(p);        // Read atomically
atomic_store_i32(p, 42);             // Write atomically

// Fetch-and-modify operations (return OLD value)
let old = atomic_add_i32(p, 10);     // Add, return old
old = atomic_sub_i32(p, 5);          // Subtract, return old
old = atomic_and_i32(p, 0xFF);       // Bitwise AND
old = atomic_or_i32(p, 0x10);        // Bitwise OR
old = atomic_xor_i32(p, 0x0F);       // Bitwise XOR

// Compare-and-swap (CAS)
let success = atomic_cas_i32(p, 42, 100);  // If *p == 42, set to 100
// Returns true if swap succeeded, false otherwise

// Atomic exchange
old = atomic_exchange_i32(p, 999);   // Swap, return old

free(p);

// i64 variants available (atomic_load_i64, atomic_add_i64, etc.)

// Memory fence (full barrier)
atomic_fence();
```

All operations use sequential consistency (`memory_order_seq_cst`).

---

## Project Structure

```
hemlock/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ frontend/         # Shared: lexer, parser, AST, modules
â”‚   â”œâ”€â”€ backends/
â”‚   â”‚   â”œâ”€â”€ interpreter/  # hemlock: tree-walking interpreter
â”‚   â”‚   â””â”€â”€ compiler/     # hemlockc: C code generator
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ lsp/          # Language Server Protocol
â”‚   â”‚   â””â”€â”€ bundler/      # Bundle/package tools
â”œâ”€â”€ runtime/              # Compiled program runtime (libhemlock_runtime.a)
â”œâ”€â”€ stdlib/               # Standard library (40 modules)
â”‚   â””â”€â”€ docs/             # Module documentation
â”œâ”€â”€ docs/                 # Full documentation
â”‚   â”œâ”€â”€ language-guide/   # Types, strings, arrays, etc.
â”‚   â”œâ”€â”€ reference/        # API references
â”‚   â””â”€â”€ advanced/         # Async, FFI, signals, etc.
â”œâ”€â”€ tests/                # 625+ tests
â””â”€â”€ examples/             # Example programs
```

---

## Code Style Guidelines

### Constants and Magic Numbers

When adding numeric constants to the C codebase, follow these guidelines:

1. **Define constants in `include/hemlock_limits.h`** - This file is the central location for all compile-time and runtime limits, capacities, and named constants.

2. **Use descriptive names with `HML_` prefix** - All constants should be prefixed with `HML_` for namespace clarity.

3. **Avoid magic numbers** - Replace hard-coded numeric values with named constants. Examples:
   - Type range limits: `HML_I8_MIN`, `HML_I8_MAX`, `HML_U32_MAX`
   - Buffer capacities: `HML_INITIAL_ARRAY_CAPACITY`, `HML_INITIAL_LEXER_BUFFER_CAPACITY`
   - Time conversions: `HML_NANOSECONDS_PER_SECOND`, `HML_MILLISECONDS_PER_SECOND`
   - Hash seeds: `HML_DJB2_HASH_SEED`
   - ASCII values: `HML_ASCII_CASE_OFFSET`, `HML_ASCII_PRINTABLE_START`

4. **Include `hemlock_limits.h`** - Source files should include this header (often via `internal.h`) to access constants.

5. **Document the purpose** - Add a comment explaining what each constant represents.

---

## What NOT to Do

âŒ Add implicit behavior (ASI, GC, auto-cleanup)
âŒ Hide complexity (magic optimizations, hidden refcounts)
âŒ Break existing semantics (semicolons, manual memory, mutable strings)
âŒ Lose precision in implicit conversions
âŒ Use magic numbers - define named constants in `hemlock_limits.h` instead

---

## Testing

```bash
make test              # Run interpreter tests
make test-compiler     # Run compiler tests
make parity            # Run parity tests (both must match)
make test-all          # Run all test suites
```

**Important:** Tests may hang due to async/concurrency issues. Always use a timeout when running tests:
```bash
timeout 60 make test   # 60 second timeout
timeout 120 make parity
```

Test categories: primitives, memory, strings, arrays, functions, objects, async, ffi, defer, signals, switch, bitwise, typed_arrays, modules, stdlib_*

---

## Compiler/Interpreter Architecture

Hemlock has two execution backends that share a common frontend:

```
Source (.hml)
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SHARED FRONTEND            â”‚
â”‚  - Lexer (src/frontend/)    â”‚
â”‚  - Parser (src/frontend/)   â”‚
â”‚  - AST (src/frontend/)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ INTERPRETERâ”‚    â”‚  COMPILER  â”‚
â”‚ (hemlock)  â”‚    â”‚ (hemlockc) â”‚
â”‚            â”‚    â”‚            â”‚
â”‚ Tree-walk  â”‚    â”‚ Type check â”‚
â”‚ evaluation â”‚    â”‚ AST â†’ C    â”‚
â”‚            â”‚    â”‚ gcc link   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Compiler Type Checking

The compiler (`hemlockc`) includes compile-time type checking, **enabled by default**:

```bash
hemlockc program.hml -o program    # Type checks, then compiles
hemlockc --check program.hml       # Type check only, don't compile
hemlockc --no-type-check prog.hml  # Disable type checking
hemlockc --strict-types prog.hml   # Warn on implicit 'any' types
```

The type checker:
- Validates type annotations at compile time
- Treats untyped code as dynamic (`any` type) - always valid
- Provides optimization hints for unboxing
- Uses permissive numeric conversions (range validated at runtime)

### Directory Structure

```
hemlock/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ frontend/           # Shared: lexer, parser, AST, modules
â”‚   â”‚   â”œâ”€â”€ lexer.c
â”‚   â”‚   â”œâ”€â”€ parser/
â”‚   â”‚   â”œâ”€â”€ ast.c
â”‚   â”‚   â””â”€â”€ module.c
â”‚   â”œâ”€â”€ backends/
â”‚   â”‚   â”œâ”€â”€ interpreter/    # hemlock: tree-walking interpreter
â”‚   â”‚   â”‚   â”œâ”€â”€ main.c
â”‚   â”‚   â”‚   â”œâ”€â”€ runtime/
â”‚   â”‚   â”‚   â””â”€â”€ builtins/
â”‚   â”‚   â””â”€â”€ compiler/       # hemlockc: C code generator
â”‚   â”‚       â”œâ”€â”€ main.c
â”‚   â”‚       â””â”€â”€ codegen/
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ lsp/            # Language server
â”‚   â”‚   â””â”€â”€ bundler/        # Bundle/package tools
â”œâ”€â”€ runtime/                # libhemlock_runtime.a for compiled programs
â”œâ”€â”€ stdlib/                 # Shared standard library
â””â”€â”€ tests/
    â”œâ”€â”€ parity/             # Tests that MUST pass both backends
    â”œâ”€â”€ interpreter/        # Interpreter-specific tests
    â””â”€â”€ compiler/           # Compiler-specific tests
```

---

## Parity-First Development

**Both the interpreter and compiler must produce identical output for the same input.**

### Development Policy

When adding or modifying language features:

1. **Design** - Define the AST/semantic change in the shared frontend
2. **Implement interpreter** - Add tree-walking evaluation
3. **Implement compiler** - Add C code generation
4. **Add parity test** - Write test in `tests/parity/` with `.expected` file
5. **Verify** - Run `make parity` before merging

### Parity Test Structure

```
tests/parity/
â”œâ”€â”€ language/       # Core language features (control flow, closures, etc.)
â”œâ”€â”€ builtins/       # Built-in functions (print, typeof, memory, etc.)
â”œâ”€â”€ methods/        # String and array methods
â””â”€â”€ modules/        # Import/export, stdlib imports
```

Each test has two files:
- `feature.hml` - The test program
- `feature.expected` - Expected output (must match for both backends)

### Parity Test Results

| Status | Meaning |
|--------|---------|
| `âœ“ PASSED` | Both interpreter and compiler match expected output |
| `â— INTERP_ONLY` | Interpreter works, compiler fails (needs compiler fix) |
| `â—‘ COMPILER_ONLY` | Compiler works, interpreter fails (rare) |
| `âœ— FAILED` | Both fail (test or implementation bug) |

### What Requires Parity

- All language constructs (if, while, for, switch, defer, try/catch)
- All operators (arithmetic, bitwise, logical, comparison)
- All built-in functions (print, typeof, alloc, etc.)
- All string and array methods
- Type coercion and promotion rules
- Error messages for runtime errors

### What May Differ

- Performance characteristics
- Memory layout details
- Debug/stack trace format
- Compilation errors (compiler may catch more at compile time)

### Adding a Parity Test

```bash
# 1. Create test file
cat > tests/parity/language/my_feature.hml << 'EOF'
// Test description
let x = some_feature();
print(x);
EOF

# 2. Generate expected output from interpreter
./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected

# 3. Verify parity
make parity
```

---

## Version

**v1.8.1** - Current release with:
- **Pattern matching** (`match` expressions) - Powerful destructuring and control flow:
  - Literal, wildcard, and variable binding patterns
  - OR patterns (`1 | 2 | 3`)
  - Guard expressions (`n if n > 0`)
  - Object destructuring (`{ x, y }`)
  - Array destructuring with rest (`[first, ...rest]`)
  - Type patterns (`n: i32`)
  - Full parity between interpreter and compiler
- **Compiler helper annotations** - 11 optimization annotations for GCC/Clang control:
  - `@inline`, `@noinline` - function inlining control
  - `@hot`, `@cold` - branch prediction hints
  - `@pure`, `@const` - side-effect annotations
  - `@flatten` - inline all calls within function
  - `@optimize(level)` - per-function optimization level ("0", "1", "2", "3", "s", "fast")
  - `@warn_unused` - warn on ignored return values
  - `@section(name)` - custom ELF section placement (e.g., `@section(".text.hot")`)
- **Expression-bodied functions** (`fn double(x): i32 => x * 2;`) - concise single-expression function syntax
- **Single-line statements** - braceless `if`, `while`, `for` syntax (e.g., `if (x > 0) print(x);`)
- **Type aliases** (`type Name = Type;`) - named shortcuts for complex types
- **Function type annotations** (`fn(i32): i32`) - first-class function types
- **Const parameters** (`fn(const x: array)`) - deep immutability for parameters
- **Ref parameters** (`fn(ref x: i32)`) - pass-by-reference for direct caller mutation
- **Method signatures in define** (`fn method(): Type`) - interface-like contracts (comma-delimited)
- **Self type** in method signatures - refers to the defining type
- **Loop keyword** (`loop { }`) - cleaner infinite loops, replaces `while (true)`
- **Loop labels** (`outer: while`) - targeted break/continue for nested loops
- **Object shorthand** (`{ name }`) - ES6-style shorthand property syntax
- **Object spread** (`{ ...obj }`) - copy and merge object fields
- **Compound duck types** (`A & B & C`) - intersection types for structural typing
- **Named arguments** for function calls (`foo(name: "value", age: 30)`)
- **Null coalescing operators** (`??`, `??=`, `?.`) for safe null handling
- **Octal literals** (`0o777`, `0O123`)
- **Numeric separators** (`1_000_000`, `0xFF_FF`, `0b1111_0000`)
- **Block comments** (`/* ... */`)
- **Hex escape sequences** in strings/runes (`\x41` = 'A')
- **Unicode escape sequences** in strings (`\u{1F600}` = ðŸ˜€)
- **Float literals without leading zero** (`.5`, `.123`, `.5e2`)
- **Compile-time type checking** in hemlockc (enabled by default)
- **LSP integration** with type checking for real-time diagnostics
- **Compound assignment operators** (`+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`)
- **Increment/decrement operators** (`++x`, `x++`, `--x`, `x--`)
- **Type precision fix**: i64/u64 + f32 â†’ f64 to preserve precision
- Unified type system with unboxing optimization hints
- Full type system (i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object, enum, file, task, channel)
- UTF-8 strings with 19 methods
- Arrays with 18 methods including map/filter/reduce
- Manual memory management with `talloc()` and `sizeof()`
- Async/await with true pthread parallelism
- Atomic operations for lock-free concurrent programming
- 40 stdlib modules (+ arena, assert, semver, toml, retry, iter, random, shell)
- FFI for C interop with `export extern fn` for reusable library wrappers
- FFI struct support in compiler (pass C structs by value)
- FFI pointer helpers (`ptr_null`, `ptr_read_*`, `ptr_write_*`)
- defer, try/catch/finally/throw, panic
- File I/O, signal handling, command execution
- [hpm](https://github.com/hemlang/hpm) package manager with GitHub-based registry
- Compiler backend (C code generation) with 100% interpreter parity
- LSP server with go-to-definition and find-references
- AST optimization pass and variable resolution for O(1) lookup
- apply() builtin for dynamic function calls
- Unbuffered channels and many-params support
- 159 parity tests (100% pass rate)

---

## Philosophy

> We give you the tools to be safe (`buffer`, type annotations, bounds checking) but we don't force you to use them (`ptr`, manual memory, unsafe operations).

**If you're not sure whether a feature fits Hemlock, ask: "Does this give the programmer more explicit control, or does it hide something?"**

If it hides, it probably doesn't belong in Hemlock.



################################################################################
# GETTING STARTED
################################################################################

--------------------------------------------------------------------------------
## Installation
--------------------------------------------------------------------------------

# Installation

This guide will help you build and install Hemlock on your system.

## Quick Install (Recommended)

The easiest way to install Hemlock is using the one-line install script:

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash
```

This downloads and installs the latest pre-built binary for your platform (Linux or macOS, x86_64 or arm64).

### Install Options

```bash
# Install to a custom prefix (default: ~/.local)
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local

# Install a specific version
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0

# Install and automatically update shell PATH
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path
```

After installation, verify it works:

```bash
hemlock --version
```

---

## Building from Source

If you prefer to build from source or the pre-built binaries don't work for your system, follow the instructions below.

## Prerequisites

### Required Dependencies

Hemlock requires the following dependencies to build:

- **C Compiler**: GCC or Clang (C11 standard)
- **Make**: GNU Make
- **libffi**: Foreign Function Interface library (for FFI support)
- **OpenSSL**: Cryptographic library (for hash functions: md5, sha1, sha256)
- **libwebsockets**: WebSocket and HTTP client/server support
- **zlib**: Compression library

### Installing Dependencies

**macOS:**
```bash
# Install Homebrew if not already installed
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Install Xcode Command Line Tools
xcode-select --install

# Install dependencies via Homebrew
brew install libffi openssl@3 libwebsockets
```

**Note for macOS users**: The Makefile automatically detects Homebrew installations and sets the correct include/library paths. Hemlock supports both Intel (x86_64) and Apple Silicon (arm64) architectures.

**Ubuntu/Debian:**
```bash
sudo apt-get update
sudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev
```

**Fedora/RHEL:**
```bash
sudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel
```

**Arch Linux:**
```bash
sudo pacman -S base-devel libffi openssl libwebsockets zlib
```

## Building from Source

### 1. Clone the Repository

```bash
git clone https://github.com/hemlang/hemlock.git
cd hemlock
```

### 2. Build Hemlock

```bash
make
```

This will compile the Hemlock interpreter and place the executable in the current directory.

### 3. Verify Installation

```bash
./hemlock --version
```

You should see the Hemlock version information.

### 4. Test the Build

Run the test suite to ensure everything works correctly:

```bash
make test
```

All tests should pass. If you see any failures, please report them as an issue.

## Installing System-Wide (Optional)

To install Hemlock system-wide (e.g., to `/usr/local/bin`):

```bash
sudo make install
```

This allows you to run `hemlock` from anywhere without specifying the full path.

## Running Hemlock

### Interactive REPL

Start the Read-Eval-Print Loop:

```bash
./hemlock
```

You'll see a prompt where you can type Hemlock code:

```
Hemlock REPL
> print("Hello, World!");
Hello, World!
> let x = 42;
> print(x * 2);
84
>
```

Exit the REPL with `Ctrl+D` or `Ctrl+C`.

### Running Programs

Execute a Hemlock script:

```bash
./hemlock program.hml
```

With command-line arguments:

```bash
./hemlock program.hml arg1 arg2 "argument with spaces"
```

## Directory Structure

After building, your Hemlock directory will look like this:

```
hemlock/
â”œâ”€â”€ hemlock           # Compiled interpreter executable
â”œâ”€â”€ src/              # Source code
â”œâ”€â”€ include/          # Header files
â”œâ”€â”€ tests/            # Test suite
â”œâ”€â”€ examples/         # Example programs
â”œâ”€â”€ docs/             # Documentation
â”œâ”€â”€ stdlib/           # Standard library
â”œâ”€â”€ Makefile          # Build configuration
â””â”€â”€ README.md         # Project README
```

## Build Options

### Debug Build

Build with debug symbols and no optimization:

```bash
make debug
```

### Clean Build

Remove all compiled files:

```bash
make clean
```

Rebuild from scratch:

```bash
make clean && make
```

## Troubleshooting

### macOS: Library Not Found Errors

If you get errors about missing libraries (`-lcrypto`, `-lffi`, etc.):

1. Ensure Homebrew dependencies are installed:
   ```bash
   brew install libffi openssl@3 libwebsockets
   ```

2. Verify Homebrew paths:
   ```bash
   brew --prefix libffi
   brew --prefix openssl
   ```

3. The Makefile should auto-detect these paths. If it doesn't, check that `brew` is in your PATH:
   ```bash
   which brew
   ```

### macOS: BSD Type Errors (`u_int`, `u_char` not found)

If you see errors about unknown type names like `u_int` or `u_char`:

1. This is fixed in v1.0.0+ by using `_DARWIN_C_SOURCE` instead of `_POSIX_C_SOURCE`
2. Ensure you have the latest version of the code
3. Clean and rebuild:
   ```bash
   make clean && make
   ```

### Linux: libffi Not Found

If you get errors about missing `ffi.h` or `-lffi`:

1. Ensure `libffi-dev` is installed (see dependencies above)
2. Check if `pkg-config` can find it:
   ```bash
   pkg-config --cflags --libs libffi
   ```
3. If not found, you may need to set `PKG_CONFIG_PATH`:
   ```bash
   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH
   ```

### Compilation Errors

If you encounter compilation errors:

1. Ensure you have a C11-compatible compiler
2. On macOS, try using Clang (default):
   ```bash
   make CC=clang
   ```
3. On Linux, try using GCC:
   ```bash
   make CC=gcc
   ```
4. Check that all dependencies are installed
5. Try rebuilding from scratch:
   ```bash
   make clean && make
   ```

### Test Failures

If tests fail:

1. Check that you have the latest version of the code
2. Try rebuilding from scratch:
   ```bash
   make clean && make test
   ```
3. On macOS, ensure you have the latest Xcode Command Line Tools:
   ```bash
   xcode-select --install
   ```
4. Report the issue on GitHub with:
   - Your platform (macOS version / Linux distro)
   - Architecture (x86_64 / arm64)
   - Test output
   - Output of `make -v` and `gcc --version` (or `clang --version`)

## Next Steps

- [Quick Start Guide](#getting-started-quick-start) - Write your first Hemlock program
- [Tutorial](#getting-started-tutorial) - Learn Hemlock step-by-step
- [Language Guide](#language-guide-syntax) - Explore Hemlock features


--------------------------------------------------------------------------------
## Learning Paths
--------------------------------------------------------------------------------

# Learning Paths

Different goals require different knowledge. Pick the path that matches what you want to build.

---

## Path 1: Quick Scripts & Automation

**Goal:** Write scripts to automate tasks, process files, and get things done.

**Time to productivity:** Fast - you can start writing useful scripts immediately.

### What You'll Learn

1. **[Quick Start](#getting-started-quick-start)** - Your first program, basic syntax
2. **[Strings](#language-guide-strings)** - Text processing, splitting, searching
3. **[Arrays](#language-guide-arrays)** - Lists, filtering, transforming data
4. **[File I/O](#advanced-file-io)** - Reading and writing files
5. **[Command-Line Args](#advanced-command-line-args)** - Getting input from users

### Skip For Now

- Memory management (automatic for scripts)
- Async/concurrency (overkill for simple scripts)
- FFI (only needed for C interop)

### Example Project: File Renamer

```hemlock
import { list_dir, rename } from "@stdlib/fs";

// Rename all .txt files to .md
let files = list_dir(".");
for (file in files) {
    if (file.ends_with(".txt")) {
        let new_name = file.replace(".txt", ".md");
        rename(file, new_name);
        print(`Renamed: ${file} -> ${new_name}`);
    }
}
```

---

## Path 2: Data Processing & Analysis

**Goal:** Parse data, transform it, generate reports.

**Time to productivity:** Fast - Hemlock's string and array methods make this easy.

### What You'll Learn

1. **[Quick Start](#getting-started-quick-start)** - Basics
2. **[Strings](#language-guide-strings)** - Parsing, splitting, formatting
3. **[Arrays](#language-guide-arrays)** - map, filter, reduce for data transformation
4. **[Objects](#language-guide-objects)** - Structured data
5. **Standard Library:**
   - **[@stdlib/json](#stdlib-json)** - JSON parsing
   - **[@stdlib/csv](#stdlib-csv)** - CSV files
   - **[@stdlib/fs](#stdlib-fs)** - File operations

### Example Project: CSV Analyzer

```hemlock
import { read_file } from "@stdlib/fs";
import { parse } from "@stdlib/csv";

let data = parse(read_file("sales.csv"));

// Calculate total sales
let total = 0;
for (row in data) {
    total = total + f64(row.amount);
}

print(`Total sales: $${total}`);

// Find top seller
let top = data[0];
for (row in data) {
    if (f64(row.amount) > f64(top.amount)) {
        top = row;
    }
}

print(`Top sale: ${top.product} - $${top.amount}`);
```

---

## Path 3: Web & Network Programming

**Goal:** Build HTTP clients, work with APIs, create servers.

**Time to productivity:** Medium - requires understanding async basics.

### What You'll Learn

1. **[Quick Start](#getting-started-quick-start)** - Basics
2. **[Functions](#language-guide-functions)** - Callbacks and closures
3. **[Error Handling](#language-guide-error-handling)** - try/catch for network errors
4. **[Async & Concurrency](#advanced-async-concurrency)** - spawn, await, channels
5. **Standard Library:**
   - **[@stdlib/http](#stdlib-http)** - HTTP requests
   - **[@stdlib/json](#stdlib-json)** - JSON for APIs
   - **[@stdlib/net](#stdlib-net)** - TCP/UDP sockets
   - **[@stdlib/url](#stdlib-url)** - URL parsing

### Example Project: API Client

```hemlock
import { http_get, http_post } from "@stdlib/http";
import { parse, stringify } from "@stdlib/json";

// GET request
let response = http_get("https://api.example.com/users");
let users = parse(response.body);

for (user in users) {
    print(`${user.name}: ${user.email}`);
}

// POST request
let new_user = { name: "Alice", email: "alice@example.com" };
let result = http_post("https://api.example.com/users", {
    body: stringify(new_user),
    headers: { "Content-Type": "application/json" }
});

print(`Created user with ID: ${parse(result.body).id}`);
```

---

## Path 4: Systems Programming

**Goal:** Write low-level code, work with memory, interface with C libraries.

**Time to productivity:** Longer - requires understanding memory management.

### What You'll Learn

1. **[Quick Start](#getting-started-quick-start)** - Basics
2. **[Types](#language-guide-types)** - Understanding i32, u8, ptr, etc.
3. **[Memory Management](#language-guide-memory)** - alloc, free, buffers
4. **[FFI](#advanced-ffi)** - Calling C functions
5. **[Signals](#advanced-signals)** - Signal handling

### Key Concepts

**Memory Safety Checklist:**
- [ ] Every `alloc()` has a matching `free()`
- [ ] Use `buffer()` unless you need raw `ptr`
- [ ] Set pointers to `null` after freeing
- [ ] Use `try/finally` to guarantee cleanup

**Type Mapping for FFI:**
| Hemlock | C |
|---------|---|
| `i8` | `char` / `int8_t` |
| `i32` | `int` |
| `i64` | `long` (64-bit) |
| `u8` | `unsigned char` |
| `f64` | `double` |
| `ptr` | `void*` |

### Example Project: Custom Memory Pool

```hemlock
// Simple bump allocator
let pool_size = 1024 * 1024;  // 1MB
let pool = alloc(pool_size);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > pool_size) {
        throw "Pool exhausted";
    }
    let p = pool + pool_offset;
    pool_offset = pool_offset + size;
    return p;
}

fn pool_reset() {
    pool_offset = 0;
}

fn pool_destroy() {
    free(pool);
}

// Use it
let a = pool_alloc(100);
let b = pool_alloc(200);
memset(a, 0, 100);
memset(b, 0, 200);

pool_reset();  // Reuse all memory
pool_destroy();  // Clean up
```

---

## Path 5: Parallel & Concurrent Programs

**Goal:** Run code on multiple CPU cores, build responsive applications.

**Time to productivity:** Medium - async syntax is straightforward, but reasoning about parallelism takes practice.

### What You'll Learn

1. **[Quick Start](#getting-started-quick-start)** - Basics
2. **[Functions](#language-guide-functions)** - Closures (important for async)
3. **[Async & Concurrency](#advanced-async-concurrency)** - Full deep dive
4. **[Atomics](#advanced-atomics)** - Lock-free programming

### Key Concepts

**Hemlock's async model:**
- `async fn` - Define a function that can run on another thread
- `spawn(fn, args...)` - Start running it, returns a task handle
- `join(task)` or `await task` - Wait for it to finish, get result
- `channel(size)` - Create a queue for sending data between tasks

**Important:** Tasks receive *copies* of values. If you pass a pointer, you're responsible for ensuring the memory stays valid until the task completes.

### Example Project: Parallel File Processor

```hemlock
import { list_dir, read_file } from "@stdlib/fs";

async fn process_file(path: string): i32 {
    let content = read_file(path);
    let lines = content.split("\n");
    return lines.length;
}

// Process all files in parallel
let files = list_dir("data/");
let tasks = [];

for (file in files) {
    if (file.ends_with(".txt")) {
        let task = spawn(process_file, "data/" + file);
        tasks.push({ name: file, task: task });
    }
}

// Collect results
let total_lines = 0;
for (item in tasks) {
    let count = join(item.task);
    print(`${item.name}: ${count} lines`);
    total_lines = total_lines + count;
}

print(`Total: ${total_lines} lines`);
```

---

## What to Learn First (Any Path)

No matter your goal, start with these fundamentals:

### Week 1: Core Basics
1. **[Quick Start](#getting-started-quick-start)** - Write and run your first program
2. **[Syntax](#language-guide-syntax)** - Variables, operators, control flow
3. **[Functions](#language-guide-functions)** - Define and call functions

### Week 2: Data Handling
4. **[Strings](#language-guide-strings)** - Text manipulation
5. **[Arrays](#language-guide-arrays)** - Collections and iteration
6. **[Objects](#language-guide-objects)** - Structured data

### Week 3: Robustness
7. **[Error Handling](#language-guide-error-handling)** - try/catch/throw
8. **[Modules](#language-guide-modules)** - Import/export, using stdlib

### Then: Pick Your Path Above

---

## Cheat Sheet: Coming From Other Languages

### From Python

| Python | Hemlock | Notes |
|--------|---------|-------|
| `x = 42` | `let x = 42;` | Semicolons required |
| `def fn():` | `fn name() { }` | Braces required |
| `if x:` | `if (x) { }` | Parens and braces required |
| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | C-style for loops |
| `for item in list:` | `for (item in array) { }` | For-in works same |
| `list.append(x)` | `array.push(x);` | Different method name |
| `len(s)` | `s.length` or `len(s)` | Both work |
| Automatic memory | Manual for `ptr` | Most types auto-cleanup |

### From JavaScript

| JavaScript | Hemlock | Notes |
|------------|---------|-------|
| `let x = 42` | `let x = 42;` | Same (semicolons required) |
| `const x = 42` | `let x = 42;` | No const keyword |
| `function fn()` | `fn name() { }` | Different keyword |
| `() => x` | `fn() { return x; }` | No arrow functions |
| `async/await` | `async/await` | Same syntax |
| `Promise` | `spawn/join` | Different model |
| Automatic GC | Manual for `ptr` | Most types auto-cleanup |

### From C/C++

| C | Hemlock | Notes |
|---|---------|-------|
| `int x = 42;` | `let x: i32 = 42;` | Type after colon |
| `malloc(n)` | `alloc(n)` | Same concept |
| `free(p)` | `free(p)` | Same |
| `char* s = "hi"` | `let s = "hi";` | Strings are managed |
| `#include` | `import { } from` | Module imports |
| Manual everything | Auto for most types | Only `ptr` needs manual |

---

## Getting Help

- **[Glossary](../glossary.md)** - Definitions of programming terms
- **[Examples](../../examples/)** - Complete working programs
- **[Tests](../../tests/)** - See how features are used
- **GitHub Issues** - Ask questions, report bugs

---

## Difficulty Levels

Throughout the docs, you'll see these markers:

| Marker | Meaning |
|--------|---------|
| **Beginner** | No prior programming experience needed |
| **Intermediate** | Assumes basic programming knowledge |
| **Advanced** | Requires understanding of systems concepts |

If something marked "Beginner" confuses you, check the [Glossary](../glossary.md) for term definitions.


--------------------------------------------------------------------------------
## Quick Start
--------------------------------------------------------------------------------

# Quick Start

Get up and running with Hemlock in minutes!

## Your First Program

Create a file called `hello.hml`:

```hemlock
print("Hello, Hemlock!");
```

Run with the interpreter:

```bash
./hemlock hello.hml
```

Or compile to a native executable:

```bash
./hemlockc hello.hml -o hello
./hello
```

Output:
```
Hello, Hemlock!
```

### Interpreter vs Compiler

Hemlock provides two ways to run programs:

| Tool | Use Case | Type Checking |
|------|----------|---------------|
| `hemlock` | Quick scripts, REPL, development | Runtime only |
| `hemlockc` | Production binaries, better performance | Compile-time (default) |

The compiler (`hemlockc`) type-checks your code before generating an executable, catching errors early.

## Basic Syntax

### Variables

```hemlock
// Variables are declared with 'let'
let x = 42;
let name = "Alice";
let pi = 3.14159;

// Type annotations are optional
let count: i32 = 100;
let ratio: f64 = 0.618;
```

**Important**: Semicolons are **mandatory** in Hemlock!

### Types

Hemlock has a rich type system:

```hemlock
// Integers
let small: i8 = 127;          // 8-bit signed
let byte: u8 = 255;           // 8-bit unsigned
let num: i32 = 2147483647;    // 32-bit signed (default)
let big: i64 = 9223372036854775807;  // 64-bit signed

// Floats
let f: f32 = 3.14;            // 32-bit float
let d: f64 = 2.71828;         // 64-bit float (default)

// Strings and characters
let text: string = "Hello";   // UTF-8 string
let emoji: rune = 'ðŸš€';       // Unicode codepoint

// Boolean and null
let flag: bool = true;
let empty = null;
```

### Control Flow

```hemlock
// If statements
if (x > 0) {
    print("positive");
} else if (x < 0) {
    print("negative");
} else {
    print("zero");
}

// While loops
let i = 0;
while (i < 5) {
    print(i);
    i = i + 1;
}

// For loops
for (let j = 0; j < 10; j = j + 1) {
    print(j);
}
```

### Functions

```hemlock
// Named function
fn add(a: i32, b: i32): i32 {
    return a + b;
}

let result = add(5, 3);  // 8

// Anonymous function
let multiply = fn(x, y) {
    return x * y;
};

print(multiply(4, 7));  // 28
```

## Working with Strings

Strings in Hemlock are **mutable** and **UTF-8**:

```hemlock
let s = "hello";
s[0] = 'H';              // Now "Hello"
print(s);

// String methods
let upper = s.to_upper();     // "HELLO"
let words = "a,b,c".split(","); // ["a", "b", "c"]
let sub = s.substr(1, 3);     // "ell"

// Concatenation
let greeting = "Hello" + ", " + "World!";
print(greeting);  // "Hello, World!"
```

## Arrays

Dynamic arrays with mixed types:

```hemlock
let numbers = [1, 2, 3, 4, 5];
print(numbers[0]);      // 1
print(numbers.length);  // 5

// Array methods
numbers.push(6);        // [1, 2, 3, 4, 5, 6]
let last = numbers.pop();  // 6
let slice = numbers.slice(1, 4);  // [2, 3, 4]

// Mixed types allowed
let mixed = [1, "two", true, null];
```

## Objects

JavaScript-style objects:

```hemlock
// Object literal
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};

print(person.name);  // "Alice"
person.age = 31;     // Modify field

// Methods with 'self'
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    }
};

counter.increment();
print(counter.count);  // 1
```

## Memory Management

Hemlock uses **manual memory management**:

```hemlock
// Safe buffer (recommended)
let buf = buffer(64);   // Allocate 64 bytes
buf[0] = 65;            // Set first byte to 'A'
print(buf[0]);          // 65
free(buf);              // Free memory

// Raw pointer (advanced)
let ptr = alloc(100);
memset(ptr, 0, 100);    // Fill with zeros
free(ptr);
```

**Important**: You must `free()` what you `alloc()`!

## Error Handling

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    print(result);
} catch (e) {
    print("Error: " + e);
} finally {
    print("Done");
}
```

## Command-Line Arguments

Access program arguments via the `args` array:

```hemlock
// script.hml
print("Script:", args[0]);
print(`Arguments: ${args.length - 1}`);

let i = 1;
while (i < args.length) {
    print(`  arg ${i}: ${args[i]}`);
    i = i + 1;
}
```

Run with:
```bash
./hemlock script.hml hello world
```

Output:
```
Script: script.hml
Arguments: 2
  arg 1: hello
  arg 2: world
```

## File I/O

```hemlock
// Write to file
let f = open("data.txt", "w");
f.write("Hello, File!");
f.close();

// Read from file
let f2 = open("data.txt", "r");
let content = f2.read();
print(content);  // "Hello, File!"
f2.close();
```

## What's Next?

Now that you've seen the basics, explore more:

- [Tutorial](#getting-started-tutorial) - Comprehensive step-by-step guide
- [Language Guide](#language-guide-syntax) - Deep dive into all features
- [Examples](../../examples/) - Real-world example programs
- [API Reference](#reference-builtins) - Complete API documentation

## Common Pitfalls

### Forgetting Semicolons

```hemlock
// âŒ ERROR: Missing semicolon
let x = 42
let y = 10

// âœ… CORRECT
let x = 42;
let y = 10;
```

### Forgetting to Free Memory

```hemlock
// âŒ MEMORY LEAK
let buf = buffer(100);
// ... use buf ...
// Forgot to call free(buf)!

// âœ… CORRECT
let buf = buffer(100);
// ... use buf ...
free(buf);
```

### Braces Are Required

```hemlock
// âŒ ERROR: Missing braces
if (x > 0)
    print("positive");

// âœ… CORRECT
if (x > 0) {
    print("positive");
}
```

## Getting Help

- Read the [full documentation](../README.md)
- Check [examples directory](../../examples/)
- Look at [test files](../../tests/) for usage patterns
- Report issues on GitHub


--------------------------------------------------------------------------------
## Tutorial
--------------------------------------------------------------------------------

# Hemlock Tutorial

A comprehensive step-by-step guide to learning Hemlock.

## Table of Contents

1. [Hello World](#hello-world)
2. [Variables and Types](#variables-and-types)
3. [Arithmetic and Operations](#arithmetic-and-operations)
4. [Control Flow](#control-flow)
5. [Functions](#functions)
6. [Strings and Runes](#strings-and-runes)
7. [Arrays](#arrays)
8. [Objects](#objects)
9. [Memory Management](#memory-management)
10. [Error Handling](#error-handling)
11. [File I/O](#file-io)
12. [Putting It All Together](#putting-it-all-together)

## Hello World

Let's start with the traditional first program:

```hemlock
print("Hello, World!");
```

Save this as `hello.hml` and run:

```bash
./hemlock hello.hml
```

**Key Points:**
- `print()` is a built-in function that outputs to stdout
- Strings are enclosed in double quotes
- Semicolons are **mandatory**

## Variables and Types

### Declaring Variables

```hemlock
// Basic variable declaration
let x = 42;
let name = "Alice";
let pi = 3.14159;

print(x);      // 42
print(name);   // Alice
print(pi);     // 3.14159
```

### Type Annotations

While types are inferred by default, you can be explicit:

```hemlock
let age: i32 = 30;
let height: f64 = 5.9;
let initial: rune = 'A';
let active: bool = true;
```

### Type Inference

Hemlock infers types based on values:

```hemlock
let small = 42;              // i32 (fits in 32-bit)
let large = 5000000000;      // i64 (too big for i32)
let decimal = 3.14;          // f64 (default for floats)
let text = "hello";          // string
let flag = true;             // bool
```

### Type Checking

```hemlock
// Check types with typeof()
print(typeof(42));        // "i32"
print(typeof(3.14));      // "f64"
print(typeof("hello"));   // "string"
print(typeof(true));      // "bool"
print(typeof(null));      // "null"
```

## Arithmetic and Operations

### Basic Arithmetic

```hemlock
let a = 10;
let b = 3;

print(a + b);   // 13
print(a - b);   // 7
print(a * b);   // 30
print(a / b);   // 3 (integer division)
print(a == b);  // false
print(a > b);   // true
```

### Type Promotion

When mixing types, Hemlock promotes to the larger/more precise type:

```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // result is f64 (10.0 + 3.5 = 13.5)

print(result);       // 13.5
print(typeof(result)); // "f64"
```

### Bitwise Operations

```hemlock
let a = 12;  // 1100 in binary
let b = 10;  // 1010 in binary

print(a & b);   // 8  (AND)
print(a | b);   // 14 (OR)
print(a ^ b);   // 6  (XOR)
print(a << 1);  // 24 (left shift)
print(a >> 1);  // 6  (right shift)
print(~a);      // -13 (NOT)
```

## Control Flow

### If Statements

```hemlock
let x = 10;

if (x > 0) {
    print("positive");
} else if (x < 0) {
    print("negative");
} else {
    print("zero");
}
```

**Note:** Braces are **always required**, even for single statements.

### While Loops

```hemlock
let count = 0;
while (count < 5) {
    print(`Count: ${count}`);
    count = count + 1;
}
```

### For Loops

```hemlock
// C-style for loop
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}

// For-in loop (arrays)
let items = [10, 20, 30, 40];
for (let item in items) {
    print(`Item: ${item}`);
}
```

### Switch Statements

```hemlock
let day = 3;

switch (day) {
    case 1:
        print("Monday");
        break;
    case 2:
        print("Tuesday");
        break;
    case 3:
        print("Wednesday");
        break;
    default:
        print("Other day");
        break;
}
```

### Break and Continue

```hemlock
// Break: exit loop early
let i = 0;
while (i < 10) {
    if (i == 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// Prints: 0, 1, 2, 3, 4

// Continue: skip to next iteration
for (let j = 0; j < 5; j = j + 1) {
    if (j == 2) {
        continue;
    }
    print(j);
}
// Prints: 0, 1, 3, 4
```

## Functions

### Named Functions

```hemlock
fn greet(name: string): string {
    return "Hello, " + name + "!";
}

let message = greet("Alice");
print(message);  // "Hello, Alice!"
```

### Anonymous Functions

```hemlock
let add = fn(a, b) {
    return a + b;
};

print(add(5, 3));  // 8
```

### Recursion

```hemlock
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

print(factorial(5));  // 120
```

### Closures

Functions capture their environment:

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
print(counter());  // 3
```

### Higher-Order Functions

```hemlock
fn apply(f, x) {
    return f(x);
}

fn double(n) {
    return n * 2;
}

let result = apply(double, 21);
print(result);  // 42
```

## Strings and Runes

### String Basics

Strings are **mutable** and **UTF-8**:

```hemlock
let s = "hello";
print(s.length);      // 5 (character count)
print(s.byte_length); // 5 (byte count)

// Mutation
s[0] = 'H';
print(s);  // "Hello"
```

### String Methods

```hemlock
let text = "  Hello, World!  ";

// Case conversion
print(text.to_upper());  // "  HELLO, WORLD!  "
print(text.to_lower());  // "  hello, world!  "

// Trimming
print(text.trim());      // "Hello, World!"

// Substring extraction
let hello = text.substr(2, 5);  // "Hello"
let world = text.slice(9, 14);  // "World"

// Searching
let pos = text.find("World");   // 9
let has = text.contains("o");   // true

// Splitting
let parts = "a,b,c".split(","); // ["a", "b", "c"]

// Replacement
let s = "hello world".replace("world", "there");
print(s);  // "hello there"
```

### Runes (Unicode Codepoints)

```hemlock
let ch: rune = 'A';
let emoji: rune = 'ðŸš€';

print(ch);      // 'A'
print(emoji);   // U+1F680

// Rune + String concatenation
let msg = '>' + " Important";
print(msg);  // "> Important"

// Convert between rune and integer
let code: i32 = ch;     // 65 (ASCII code)
let r: rune = 128640;   // U+1F680 (ðŸš€)
```

## Arrays

### Array Basics

```hemlock
let numbers = [1, 2, 3, 4, 5];
print(numbers[0]);      // 1
print(numbers.length);  // 5

// Modify elements
numbers[2] = 99;
print(numbers[2]);  // 99
```

### Array Methods

```hemlock
let arr = [10, 20, 30];

// Add/remove at end
arr.push(40);           // [10, 20, 30, 40]
let last = arr.pop();   // 40, arr is now [10, 20, 30]

// Add/remove at beginning
arr.unshift(5);         // [5, 10, 20, 30]
let first = arr.shift(); // 5, arr is now [10, 20, 30]

// Insert/remove at index
arr.insert(1, 15);      // [10, 15, 20, 30]
let removed = arr.remove(2);  // 20

// Search
let index = arr.find(15);     // 1
let has = arr.contains(10);   // true

// Slice
let slice = arr.slice(0, 2);  // [10, 15]

// Join to string
let text = arr.join(", ");    // "10, 15, 30"
```

### Iteration

```hemlock
let items = ["apple", "banana", "cherry"];

// For-in loop
for (let item in items) {
    print(item);
}

// Manual iteration
let i = 0;
while (i < items.length) {
    print(items[i]);
    i = i + 1;
}
```

## Objects

### Object Literals

```hemlock
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};

print(person.name);  // "Alice"
print(person.age);   // 30

// Add/modify fields
person.email = "alice@example.com";
person.age = 31;
```

### Methods and `self`

```hemlock
let calculator = {
    value: 0,
    add: fn(x) {
        self.value = self.value + x;
    },
    get: fn() {
        return self.value;
    }
};

calculator.add(10);
calculator.add(5);
print(calculator.get());  // 15
```

### Type Definitions (Duck Typing)

```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,  // Optional with default
}

let p = { name: "Bob", age: 25 };
let typed: Person = p;  // Duck typing validates structure

print(typeof(typed));   // "Person"
print(typed.active);    // true (default applied)
```

### JSON Serialization

```hemlock
let obj = { x: 10, y: 20, name: "test" };

// Object to JSON
let json = obj.serialize();
print(json);  // {"x":10,"y":20,"name":"test"}

// JSON to Object
let restored = json.deserialize();
print(restored.name);  // "test"
```

## Memory Management

### Safe Buffers (Recommended)

```hemlock
// Allocate buffer
let buf = buffer(10);
print(buf.length);    // 10
print(buf.capacity);  // 10

// Set values (bounds-checked)
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

// Access values
print(buf[0]);  // 65

// Must free when done
free(buf);
```

### Raw Pointers (Advanced)

```hemlock
// Allocate raw memory
let ptr = alloc(100);

// Fill with zeros
memset(ptr, 0, 100);

// Copy data
let src = alloc(50);
memcpy(ptr, src, 50);

// Free both
free(src);
free(ptr);
```

### Memory Functions

```hemlock
// Reallocate
let p = alloc(64);
p = realloc(p, 128);  // Resize to 128 bytes
free(p);

// Typed allocation (future)
// let arr = talloc(i32, 100);  // Array of 100 i32s
```

## Error Handling

### Try/Catch

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    print(result);
} catch (e) {
    print("Error: " + e);
}
// Output: Error: division by zero
```

### Finally Block

```hemlock
let file = null;

try {
    file = open("data.txt", "r");
    let content = file.read();
    print(content);
} catch (e) {
    print("Error: " + e);
} finally {
    // Always runs
    if (file != null) {
        file.close();
    }
}
```

### Throwing Objects

```hemlock
try {
    throw { code: 404, message: "Not found" };
} catch (e) {
    print(`Error ${e.code}: ${e.message}`);
}
// Output: Error 404: Not found
```

### Panic (Unrecoverable Errors)

```hemlock
fn validate(x) {
    if (x < 0) {
        panic("x must be non-negative");
    }
    return x * 2;
}

validate(-5);  // Program exits with: panic: x must be non-negative
```

## File I/O

### Reading Files

```hemlock
// Read entire file
let f = open("data.txt", "r");
let content = f.read();
print(content);
f.close();

// Read specific number of bytes
let f2 = open("data.txt", "r");
let chunk = f2.read(100);  // Read 100 bytes
f2.close();
```

### Writing Files

```hemlock
// Write text
let f = open("output.txt", "w");
f.write("Hello, File!\n");
f.write("Second line\n");
f.close();

// Append to file
let f2 = open("output.txt", "a");
f2.write("Appended line\n");
f2.close();
```

### Binary I/O

```hemlock
// Write binary data
let buf = buffer(256);
buf[0] = 255;
buf[1] = 128;

let f = open("data.bin", "w");
f.write_bytes(buf);
f.close();

// Read binary data
let f2 = open("data.bin", "r");
let data = f2.read_bytes(256);
print(data[0]);  // 255
f2.close();

free(buf);
free(data);
```

### File Properties

```hemlock
let f = open("/path/to/file.txt", "r");

print(f.path);    // "/path/to/file.txt"
print(f.mode);    // "r"
print(f.closed);  // false

f.close();
print(f.closed);  // true
```

## Putting It All Together

Let's build a simple word counter program:

```hemlock
// wordcount.hml - Count words in a file

fn count_words(filename: string): i32 {
    let file = null;
    let count = 0;

    try {
        file = open(filename, "r");
        let content = file.read();

        // Split by whitespace and count
        let words = content.split(" ");
        count = words.length;

    } catch (e) {
        print("Error reading file: " + e);
        return -1;
    } finally {
        if (file != null) {
            file.close();
        }
    }

    return count;
}

// Main program
if (args.length < 2) {
    print("Usage: " + args[0] + " <filename>");
} else {
    let filename = args[1];
    let words = count_words(filename);

    if (words >= 0) {
        print(`Word count: ${words}`);
    }
}
```

Run with:
```bash
./hemlock wordcount.hml data.txt
```

## Next Steps

Congratulations! You've learned the basics of Hemlock. Here's what to explore next:

- [Async & Concurrency](#advanced-async-concurrency) - True multi-threading
- [FFI](#advanced-ffi) - Call C functions
- [Signal Handling](#advanced-signals) - Process signals
- [API Reference](#reference-builtins) - Complete API docs
- [Examples](../../examples/) - More real-world programs

## Practice Exercises

Try building these programs to practice:

1. **Calculator**: Implement a simple calculator with +, -, *, /
2. **File Copy**: Copy one file to another
3. **Fibonacci**: Generate Fibonacci numbers
4. **JSON Parser**: Read and parse JSON files
5. **Text Processor**: Find and replace text in files

Happy coding with Hemlock! ðŸš€



################################################################################
# LANGUAGE GUIDE
################################################################################

--------------------------------------------------------------------------------
## Arrays
--------------------------------------------------------------------------------

# Arrays

Hemlock provides **dynamic arrays** with comprehensive methods for data manipulation and processing. Arrays can hold mixed types and grow automatically as needed.

## Overview

```hemlock
// Array literals
let arr = [1, 2, 3, 4, 5];
print(arr[0]);         // 1
print(arr.length);     // 5

// Mixed types allowed
let mixed = [1, "hello", true, null];

// Dynamic sizing
arr.push(6);           // Grows automatically
arr.push(7);
print(arr.length);     // 7
```

## Array Literals

### Basic Syntax

```hemlock
let numbers = [1, 2, 3, 4, 5];
let strings = ["apple", "banana", "cherry"];
let booleans = [true, false, true];
```

### Empty Arrays

```hemlock
let arr = [];  // Empty array

// Add elements later
arr.push(1);
arr.push(2);
arr.push(3);
```

### Mixed Types

Arrays can contain different types:

```hemlock
let mixed = [
    42,
    "hello",
    true,
    null,
    [1, 2, 3],
    { x: 10, y: 20 }
];

print(mixed[0]);  // 42
print(mixed[1]);  // "hello"
print(mixed[4]);  // [1, 2, 3] (nested array)
```

### Nested Arrays

```hemlock
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

print(matrix[0][0]);  // 1
print(matrix[1][2]);  // 6
print(matrix[2][1]);  // 8
```

### Typed Arrays

Arrays can have type annotations to enforce element types:

```hemlock
// Typed array syntax
let nums: array<i32> = [1, 2, 3, 4, 5];
let names: array<string> = ["Alice", "Bob", "Carol"];
let flags: array<bool> = [true, false, true];

// Type checking at runtime
let valid: array<i32> = [1, 2, 3];       // OK
let invalid: array<i32> = [1, "two", 3]; // Runtime error: type mismatch

// Nested typed arrays
let matrix: array<array<i32>> = [
    [1, 2, 3],
    [4, 5, 6]
];
```

**Type annotation behavior:**
- Elements are type-checked when added to the array
- Type mismatches cause runtime errors
- Without type annotation, arrays accept mixed types

## Indexing

### Reading Elements

Zero-indexed access:

```hemlock
let arr = [10, 20, 30, 40, 50];

print(arr[0]);  // 10 (first element)
print(arr[4]);  // 50 (last element)

// Out of bounds returns null (no error)
print(arr[10]);  // null
```

### Writing Elements

```hemlock
let arr = [1, 2, 3];

arr[0] = 10;    // Modify existing
arr[1] = 20;
print(arr);     // [10, 20, 3]

// Can assign beyond current length (grows array)
arr[5] = 60;    // Creates [10, 20, 3, null, null, 60]
```

### Negative Indices

**Not supported** - Use positive indices only:

```hemlock
let arr = [1, 2, 3];
print(arr[-1]);  // ERROR or undefined behavior

// Use length for last element
print(arr[arr.length - 1]);  // 3
```

## Properties

### `.length` Property

Returns the number of elements:

```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);  // 5

// Empty array
let empty = [];
print(empty.length);  // 0

// After modifications
arr.push(6);
print(arr.length);  // 6
```

## Array Methods

Hemlock provides 18 array methods for comprehensive manipulation.

### Stack Operations

**`push(value)`** - Add element to end:
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]

print(arr.length);     // 5
```

**`pop()`** - Remove and return last element:
```hemlock
let arr = [1, 2, 3, 4, 5];
let last = arr.pop();  // Returns 5, arr is now [1, 2, 3, 4]

print(last);           // 5
print(arr.length);     // 4
```

### Queue Operations

**`shift()`** - Remove and return first element:
```hemlock
let arr = [1, 2, 3];
let first = arr.shift();   // Returns 1, arr is now [2, 3]

print(first);              // 1
print(arr);                // [2, 3]
```

**`unshift(value)`** - Add element to beginning:
```hemlock
let arr = [2, 3];
arr.unshift(1);            // [1, 2, 3]
arr.unshift(0);            // [0, 1, 2, 3]
```

### Insertion and Removal

**`insert(index, value)`** - Insert element at index:
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // Insert 3 at index 2: [1, 2, 3, 4, 5]

arr.insert(0, 0);      // Insert at beginning: [0, 1, 2, 3, 4, 5]
```

**`remove(index)`** - Remove and return element at index:
```hemlock
let arr = [1, 2, 3, 4, 5];
let removed = arr.remove(2);  // Returns 3, arr is now [1, 2, 4, 5]

print(removed);               // 3
print(arr);                   // [1, 2, 4, 5]
```

### Search Operations

**`find(value)`** - Find first occurrence:
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2 (index of first occurrence)
let idx2 = arr.find(99);     // -1 (not found)

// Works with any type
let words = ["apple", "banana", "cherry"];
let idx3 = words.find("banana");  // 1
```

**`contains(value)`** - Check if array contains value:
```hemlock
let arr = [10, 20, 30, 40];
let has = arr.contains(20);  // true
let has2 = arr.contains(99); // false
```

### Extraction Operations

**`slice(start, end)`** - Extract subarray (end exclusive):
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);   // [2, 3, 4] (indices 1, 2, 3)
let first = arr.slice(0, 2); // [1, 2]

// Original unchanged
print(arr);                  // [1, 2, 3, 4, 5]
```

**`first()`** - Get first element (without removing):
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1 (without removing)
print(arr);                  // [1, 2, 3] (unchanged)
```

**`last()`** - Get last element (without removing):
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3 (without removing)
print(arr);                  // [1, 2, 3] (unchanged)
```

### Transformation Operations

**`reverse()`** - Reverse array in-place:
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]

print(arr);                  // [5, 4, 3, 2, 1] (modified)
```

**`join(delimiter)`** - Join elements into string:
```hemlock
let words = ["hello", "world", "foo"];
let joined = words.join(" ");  // "hello world foo"

let numbers = [1, 2, 3];
let csv = numbers.join(",");   // "1,2,3"

// Works with mixed types
let mixed = [1, "hello", true, null];
print(mixed.join(" | "));  // "1 | hello | true | null"
```

**`concat(other)`** - Concatenate with another array:
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (new array)

// Originals unchanged
print(a);                    // [1, 2, 3]
print(b);                    // [4, 5, 6]
```

### Utility Operations

**`clear()`** - Remove all elements:
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();                 // []

print(arr.length);           // 0
print(arr);                  // []
```

## Method Chaining

Methods that return arrays or values enable chaining:

```hemlock
let result = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);  // [3, 4, 5]

let text = ["apple", "banana", "cherry"]
    .slice(0, 2)
    .join(" and ");  // "apple and banana"

let numbers = [5, 3, 8, 1, 9]
    .slice(1, 4)
    .concat([10, 11]);  // [3, 8, 1, 10, 11]
```

## Complete Method Reference

| Method | Parameters | Returns | Mutates | Description |
|--------|-----------|---------|---------|-------------|
| `push(value)` | any | void | Yes | Add element to end |
| `pop()` | - | any | Yes | Remove and return last |
| `shift()` | - | any | Yes | Remove and return first |
| `unshift(value)` | any | void | Yes | Add element to beginning |
| `insert(index, value)` | i32, any | void | Yes | Insert at index |
| `remove(index)` | i32 | any | Yes | Remove and return at index |
| `find(value)` | any | i32 | No | Find first occurrence (-1 if not found) |
| `contains(value)` | any | bool | No | Check if contains value |
| `slice(start, end)` | i32, i32 | array | No | Extract subarray (new array) |
| `join(delimiter)` | string | string | No | Join into string |
| `concat(other)` | array | array | No | Concatenate (new array) |
| `reverse()` | - | void | Yes | Reverse in-place |
| `first()` | - | any | No | Get first element |
| `last()` | - | any | No | Get last element |
| `clear()` | - | void | Yes | Remove all elements |
| `map(callback)` | fn | array | No | Transform each element |
| `filter(predicate)` | fn | array | No | Select matching elements |
| `reduce(callback, initial)` | fn, any | any | No | Reduce to single value |

## Implementation Details

### Memory Model

- **Heap-allocated** - Dynamic capacity
- **Automatic growth** - Doubles capacity when exceeded
- **No automatic shrinking** - Capacity doesn't decrease
- **No bounds checking on indexing** - Use methods for safety

### Capacity Management

```hemlock
let arr = [];  // Initial capacity: 0

arr.push(1);   // Grows to capacity 1
arr.push(2);   // Grows to capacity 2
arr.push(3);   // Grows to capacity 4 (doubles)
arr.push(4);   // Still capacity 4
arr.push(5);   // Grows to capacity 8 (doubles)
```

### Value Comparison

`find()` and `contains()` use value equality:

```hemlock
// Primitives: compare by value
let arr = [1, 2, 3];
arr.contains(2);  // true

// Strings: compare by value
let words = ["hello", "world"];
words.contains("hello");  // true

// Objects: compare by reference
let obj1 = { x: 10 };
let obj2 = { x: 10 };
let arr2 = [obj1];
arr2.contains(obj1);  // true (same reference)
arr2.contains(obj2);  // false (different reference)
```

## Common Patterns

### Functional Operations (map/filter/reduce)

Arrays have built-in `map`, `filter`, and `reduce` methods:

```hemlock
// map - transform each element
let numbers = [1, 2, 3, 4, 5];
let doubled = numbers.map(fn(x) { return x * 2; });
print(doubled);  // [2, 4, 6, 8, 10]

// filter - select matching elements
let evens = numbers.filter(fn(x) { return x % 2 == 0; });
print(evens);  // [2, 4]

// reduce - accumulate to single value
let sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);
print(sum);  // 15

// Chaining functional operations
let result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]
    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]
    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220
```

### Pattern: Array as Stack

```hemlock
let stack = [];

// Push onto stack
stack.push(1);
stack.push(2);
stack.push(3);

// Pop from stack
let top = stack.pop();    // 3
let next = stack.pop();   // 2
```

### Pattern: Array as Queue

```hemlock
let queue = [];

// Enqueue (add to end)
queue.push(1);
queue.push(2);
queue.push(3);

// Dequeue (remove from front)
let first = queue.shift();   // 1
let second = queue.shift();  // 2
```

## Best Practices

1. **Use methods over direct indexing** - Bounds checking and clarity
2. **Check bounds** - Direct indexing doesn't bounds-check
3. **Prefer immutable operations** - Use `slice()` and `concat()` over mutation
4. **Initialize with capacity** - If you know the size (not currently supported)
5. **Use `contains()` for membership** - Clearer than manual loops
6. **Chain methods** - More readable than nested calls

## Common Pitfalls

### Pitfall: Direct Index Out of Bounds

```hemlock
let arr = [1, 2, 3];

// No bounds checking!
arr[10] = 99;  // Creates sparse array with nulls
print(arr.length);  // 11 (not 3!)

// Better: Use push() or check length
if (arr.length <= 10) {
    arr.push(99);
}
```

### Pitfall: Mutation vs. New Array

```hemlock
let arr = [1, 2, 3];

// Mutates original
arr.reverse();
print(arr);  // [3, 2, 1]

// Returns new array
let sub = arr.slice(0, 2);
print(arr);  // [3, 2, 1] (unchanged)
print(sub);  // [3, 2]
```

### Pitfall: Reference Equality

```hemlock
let obj = { x: 10 };
let arr = [obj];

// Same reference: true
arr.contains(obj);  // true

// Different reference: false
arr.contains({ x: 10 });  // false (different object)
```

### Pitfall: Long-lived Arrays

```hemlock
// Arrays in local scope are auto-freed, but global/long-lived arrays need attention
let global_cache = [];  // Module-level, persists until program exit

fn add_to_cache(item) {
    global_cache.push(item);  // Grows indefinitely
}

// For long-lived data, consider:
// - Clearing the array periodically: global_cache.clear();
// - Freeing early when done: free(global_cache);
```

## Examples

### Example: Array Statistics

```hemlock
fn mean(arr) {
    let sum = 0;
    let i = 0;
    while (i < arr.length) {
        sum = sum + arr[i];
        i = i + 1;
    }
    return sum / arr.length;
}

fn max(arr) {
    if (arr.length == 0) {
        return null;
    }

    let max_val = arr[0];
    let i = 1;
    while (i < arr.length) {
        if (arr[i] > max_val) {
            max_val = arr[i];
        }
        i = i + 1;
    }
    return max_val;
}

let numbers = [3, 7, 2, 9, 1];
print(mean(numbers));  // 4.4
print(max(numbers));   // 9
```

### Example: Array Deduplication

```hemlock
fn unique(arr) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        if (!result.contains(arr[i])) {
            result.push(arr[i]);
        }
        i = i + 1;
    }
    return result;
}

let numbers = [1, 2, 2, 3, 1, 4, 3, 5];
let uniq = unique(numbers);  // [1, 2, 3, 4, 5]
```

### Example: Array Chunking

```hemlock
fn chunk(arr, size) {
    let result = [];
    let i = 0;

    while (i < arr.length) {
        let chunk = arr.slice(i, i + size);
        result.push(chunk);
        i = i + size;
    }

    return result;
}

let numbers = [1, 2, 3, 4, 5, 6, 7, 8];
let chunks = chunk(numbers, 3);
// [[1, 2, 3], [4, 5, 6], [7, 8]]
```

### Example: Array Flattening

```hemlock
fn flatten(arr) {
    let result = [];
    let i = 0;

    while (i < arr.length) {
        if (typeof(arr[i]) == "array") {
            // Nested array - flatten it
            let nested = flatten(arr[i]);
            let j = 0;
            while (j < nested.length) {
                result.push(nested[j]);
                j = j + 1;
            }
        } else {
            result.push(arr[i]);
        }
        i = i + 1;
    }

    return result;
}

let nested = [1, [2, 3], [4, [5, 6]], 7];
let flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]
```

### Example: Sorting (Bubble Sort)

```hemlock
fn sort(arr) {
    let n = arr.length;
    let i = 0;

    while (i < n) {
        let j = 0;
        while (j < n - i - 1) {
            if (arr[j] > arr[j + 1]) {
                // Swap
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

let numbers = [5, 2, 8, 1, 9];
sort(numbers);  // Modifies in-place
print(numbers);  // [1, 2, 5, 8, 9]
```

## Limitations

Current limitations:

- **No bounds checking on indexing** - Direct access is unchecked
- **Reference equality for objects** - `find()` and `contains()` use reference comparison
- **No array destructuring** - No `let [a, b] = arr` syntax
- **No spread operator** - No `[...arr1, ...arr2]` syntax

**Note:** Arrays are refcounted and automatically freed when scope exits. See [Memory Management](memory.md#internal-reference-counting) for details.

## Related Topics

- [Strings](#language-guide-strings) - String methods similar to array methods
- [Objects](#language-guide-objects) - Arrays are also object-like
- [Functions](#language-guide-functions) - Higher-order functions with arrays
- [Control Flow](#language-guide-control-flow) - Iterating over arrays

## See Also

- **Dynamic Sizing**: Arrays grow automatically with capacity doubling
- **Methods**: 18 comprehensive methods for manipulation including map/filter/reduce
- **Memory**: See [Memory](#language-guide-memory) for array allocation details


--------------------------------------------------------------------------------
## Control Flow
--------------------------------------------------------------------------------

# Control Flow

Hemlock provides familiar C-style control flow with mandatory braces and explicit syntax. This guide covers conditionals, loops, switch statements, and operators.

## Overview

Available control flow features:

- `if`/`else`/`else if` - Conditional branches
- `while` loops - Condition-based iteration
- `for` loops - C-style and for-in iteration
- `loop` - Infinite loops (cleaner than `while (true)`)
- `switch` statements - Multi-way branching
- `break`/`continue` - Loop control
- Loop labels - Targeted break/continue for nested loops
- `defer` - Deferred execution (cleanup)
- Boolean operators: `&&`, `||`, `!`
- Comparison operators: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Bitwise operators: `&`, `|`, `^`, `<<`, `>>`, `~`

## If Statements

### Basic If/Else

```hemlock
if (x > 10) {
    print("large");
} else {
    print("small");
}
```

**Rules:**
- Braces are **always required** for all branches
- Conditions must be enclosed in parentheses
- No optional braces (unlike C)

### If Without Else

```hemlock
if (x > 0) {
    print("positive");
}
// No else branch needed
```

### Else-If Chains

```hemlock
if (x > 100) {
    print("very large");
} else if (x > 50) {
    print("large");
} else if (x > 10) {
    print("medium");
} else {
    print("small");
}
```

**Note:** `else if` is syntactic sugar for nested if statements. These are equivalent:

```hemlock
// else if (syntactic sugar)
if (a) {
    foo();
} else if (b) {
    bar();
}

// Equivalent nested if
if (a) {
    foo();
} else {
    if (b) {
        bar();
    }
}
```

### Nested If Statements

```hemlock
if (x > 0) {
    if (x < 10) {
        print("single digit positive");
    } else {
        print("multi-digit positive");
    }
} else {
    print("non-positive");
}
```

## While Loops

Condition-based iteration:

```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

**Infinite loops (old style):**
```hemlock
while (true) {
    // ... do work
    if (should_exit) {
        break;
    }
}
```

**Note:** For infinite loops, prefer the `loop` keyword (see below).

## Loop (Infinite Loop)

The `loop` keyword provides a cleaner syntax for infinite loops:

```hemlock
loop {
    // ... do work
    if (should_exit) {
        break;
    }
}
```

**Equivalent to `while (true)` but more explicit about intent.**

### Basic Loop with Break

```hemlock
let i = 0;
loop {
    if (i >= 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// Prints: 0, 1, 2, 3, 4
```

### Loop with Continue

```hemlock
let i = 0;
loop {
    i = i + 1;
    if (i > 5) {
        break;
    }
    if (i == 3) {
        continue;  // Skip printing 3
    }
    print(i);
}
// Prints: 1, 2, 4, 5
```

### Nested Loops

```hemlock
let x = 0;
loop {
    if (x >= 2) { break; }
    let y = 0;
    loop {
        if (y >= 3) { break; }
        print(x * 10 + y);
        y = y + 1;
    }
    x = x + 1;
}
// Prints: 0, 1, 2, 10, 11, 12
```

### When to Use Loop

- **Use `loop`** for intentionally infinite loops that exit via `break`
- **Use `while`** when there's a natural termination condition
- **Use `for`** when iterating a known number of times or over a collection

## For Loops

### C-Style For

Classic three-part for loop:

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**Components:**
- **Initializer**: `let i = 0` - Runs once before loop
- **Condition**: `i < 10` - Checked before each iteration
- **Update**: `i = i + 1` - Runs after each iteration

**Scope:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
// i not accessible here (loop-scoped)
```

### For-In Loops

Iterate over array elements:

```hemlock
let arr = [1, 2, 3, 4, 5];
for (let item in arr) {
    print(item);  // Prints each element
}
```

**With index and value:**
```hemlock
let arr = ["a", "b", "c"];
for (let i = 0; i < arr.length; i = i + 1) {
    print(`Index: ${i}, Value: ${arr[i]}`);
}
```

## Switch Statements

Multi-way branching based on value:

### Basic Switch

```hemlock
let x = 2;

switch (x) {
    case 1:
        print("one");
        break;
    case 2:
        print("two");
        break;
    case 3:
        print("three");
        break;
}
```

### Switch with Default

```hemlock
let color = "blue";

switch (color) {
    case "red":
        print("stop");
        break;
    case "yellow":
        print("slow");
        break;
    case "green":
        print("go");
        break;
    default:
        print("unknown color");
        break;
}
```

**Rules:**
- `default` matches when no other case matches
- `default` can appear anywhere in the switch body
- Only one default case allowed

### Fall-Through Behavior

Cases without `break` fall through to the next case (C-style behavior). This is **intentional** and can be used to group cases:

```hemlock
let grade = 85;

switch (grade) {
    case 100:
    case 95:
    case 90:
        print("A");
        break;
    case 85:
    case 80:
        print("B");
        break;
    default:
        print("C or below");
        break;
}
```

**Explicit fallthrough example:**
```hemlock
let day = 3;

switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        print("Weekday");
        break;
    case 6:
    case 7:
        print("Weekend");
        break;
}
```

**Important:** Unlike some modern languages, Hemlock does NOT require an explicit `fallthrough` keyword. Cases automatically fall through unless terminated by `break`, `return`, or `throw`. Always use `break` to prevent unintended fallthrough.

### Switch with Return

In functions, `return` exits the switch immediately:

```hemlock
fn get_day_name(day: i32): string {
    switch (day) {
        case 1:
            return "Monday";
        case 2:
            return "Tuesday";
        case 3:
            return "Wednesday";
        default:
            return "Unknown";
    }
}
```

### Switch Value Types

Switch works with any value type:

```hemlock
// Integers
switch (count) {
    case 0: print("zero"); break;
    case 1: print("one"); break;
}

// Strings
switch (name) {
    case "Alice": print("A"); break;
    case "Bob": print("B"); break;
}

// Booleans
switch (flag) {
    case true: print("on"); break;
    case false: print("off"); break;
}
```

**Note:** Cases are compared using value equality.

## Break and Continue

### Break

Exit the innermost loop or switch:

```hemlock
// In loops
let i = 0;
while (true) {
    if (i >= 10) {
        break;  // Exit loop
    }
    print(i);
    i = i + 1;
}

// In switch
switch (x) {
    case 1:
        print("one");
        break;  // Exit switch
    case 2:
        print("two");
        break;
}
```

### Continue

Skip to next iteration of loop:

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;  // Skip iteration when i is 5
    }
    print(i);  // Prints 0,1,2,3,4,6,7,8,9
}
```

**Difference:**
- `break` - Exits loop entirely
- `continue` - Skips to next iteration

## Loop Labels

Loop labels allow `break` and `continue` to target specific outer loops instead of just the innermost loop. This is useful for nested loops where you need to control an outer loop from an inner one.

### Labeled Break

Exit an outer loop from an inner loop:

```hemlock
outer: while (i < 3) {
    let j = 0;
    while (j < 3) {
        if (i == 1 && j == 1) {
            break outer;  // Exit the outer while loop
        }
        print(i * 10 + j);
        j = j + 1;
    }
    i = i + 1;
}
// Prints: 0, 1, 2, 10 (stops at i=1, j=1)
```

### Labeled Continue

Skip to the next iteration of an outer loop:

```hemlock
let i = 0;
outer: while (i < 3) {
    i = i + 1;
    let j = 0;
    while (j < 3) {
        j = j + 1;
        if (i == 2 && j == 1) {
            continue outer;  // Skip rest of inner loop, continue outer
        }
        print(i * 10 + j);
    }
}
// When i=2, j=1: skips to next outer iteration
```

### Labels with For Loops

Labels work with all loop types:

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 3; y = y + 1) {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
    }
}
```

### Labels with For-In Loops

```hemlock
let arr1 = [1, 2, 3];
let arr2 = [10, 20, 30];

outer: for (let a in arr1) {
    for (let b in arr2) {
        if (a == 2 && b == 20) {
            break outer;
        }
        print(a * 100 + b);
    }
}
```

### Labels with Loop Keyword

```hemlock
let x = 0;
outer: loop {
    let y = 0;
    loop {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
        y = y + 1;
        if (y >= 3) { break; }
    }
    x = x + 1;
    if (x >= 3) { break; }
}
```

### Multiple Labels

You can have labels at different nesting levels:

```hemlock
outer: for (let a = 0; a < 2; a = a + 1) {
    inner: for (let b = 0; b < 3; b = b + 1) {
        for (let c = 0; c < 3; c = c + 1) {
            if (c == 1) {
                continue inner;  // Skip to next iteration of middle loop
            }
            if (a == 1 && b == 1) {
                break outer;      // Exit outermost loop
            }
            print(a * 100 + b * 10 + c);
        }
    }
}
```

### Unlabeled Break/Continue with Labeled Loops

Unlabeled `break` and `continue` still work normally (affecting the innermost loop), even when outer loops have labels:

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 5; y = y + 1) {
        if (y == 2) {
            break;  // Only breaks inner loop
        }
        print(x * 10 + y);
    }
}
// Prints: 0, 1, 10, 11, 20, 21
```

### Label Syntax

- Labels are identifiers followed by a colon
- Labels must immediately precede a loop statement (`while`, `for`, `loop`)
- Label names follow identifier rules (letters, digits, underscores)
- Common conventions: `outer`, `inner`, `row`, `col`, descriptive names

## Defer Statement

The `defer` statement schedules code to execute when the current function returns. This is useful for cleanup operations like closing files, freeing resources, or releasing locks.

### Basic Defer

```hemlock
fn example() {
    print("start");
    defer print("cleanup");  // Runs when function returns
    print("end");
}

example();
// Output:
// start
// end
// cleanup
```

**Key behavior:**
- Deferred statements execute **after** the function body completes
- Deferred statements execute **before** the function returns to its caller
- Deferred statements always execute, even if the function throws an exception

### Multiple Defers (LIFO Order)

When multiple `defer` statements are used, they execute in **reverse order** (Last-In-First-Out):

```hemlock
fn example() {
    defer print("first");   // Executes last
    defer print("second");  // Executes second
    defer print("third");   // Executes first
    print("body");
}

example();
// Output:
// body
// third
// second
// first
```

This LIFO order is intentional - it matches the natural order for nested resource cleanup (close inner resources before outer ones).

### Defer with Return

Deferred statements execute before `return` transfers control:

```hemlock
fn get_value(): i32 {
    defer print("cleanup");
    print("before return");
    return 42;
}

let result = get_value();
print("result:", result);
// Output:
// before return
// cleanup
// result: 42
```

### Defer with Exceptions

Deferred statements execute even when an exception is thrown:

```hemlock
fn risky() {
    defer print("cleanup 1");
    defer print("cleanup 2");
    print("before throw");
    throw "error!";
    print("after throw");  // Never reached
}

try {
    risky();
} catch (e) {
    print("Caught:", e);
}
// Output:
// before throw
// cleanup 2
// cleanup 1
// Caught: error!
```

### Resource Cleanup Pattern

The primary use case for `defer` is ensuring resources are cleaned up:

```hemlock
fn process_file(filename: string) {
    let file = open(filename, "r");
    defer file.close();  // Always closes, even on error

    let content = file.read();
    // ... process content ...

    // File automatically closed when function returns
}
```

**Without defer (error-prone):**
```hemlock
fn process_file_bad(filename: string) {
    let file = open(filename, "r");
    let content = file.read();
    // If this throws, file.close() is never called!
    process(content);
    file.close();
}
```

### Defer with Closures

Defer can use closures to capture state:

```hemlock
fn example() {
    let resource = acquire_resource();
    defer fn() {
        print("Releasing resource");
        release(resource);
    }();  // Note: immediately-invoked function expression

    use_resource(resource);
}
```

### When to Use Defer

**Use defer for:**
- Closing files and network connections
- Freeing allocated memory
- Releasing locks and mutexes
- Cleanup in any function that acquires resources

**Defer vs Finally:**
- `defer` is simpler for single-resource cleanup
- `try/finally` is better for complex error handling with recovery

### Best Practices

1. **Place defer immediately after acquiring a resource:**
   ```hemlock
   let file = open("data.txt", "r");
   defer file.close();
   // ... use file ...
   ```

2. **Use multiple defers for multiple resources:**
   ```hemlock
   let file1 = open("input.txt", "r");
   defer file1.close();

   let file2 = open("output.txt", "w");
   defer file2.close();

   // Both files will be closed in reverse order
   ```

3. **Remember LIFO order for dependent resources:**
   ```hemlock
   let outer = acquire_outer();
   defer release_outer(outer);

   let inner = acquire_inner(outer);
   defer release_inner(inner);

   // inner released before outer (correct dependency order)
   ```

## Boolean Operators

### Logical AND (`&&`)

Both conditions must be true:

```hemlock
if (x > 0 && x < 10) {
    print("single digit positive");
}
```

**Short-circuit evaluation:**
```hemlock
if (false && expensive_check()) {
    // expensive_check() never called
}
```

### Logical OR (`||`)

At least one condition must be true:

```hemlock
if (x < 0 || x > 100) {
    print("out of range");
}
```

**Short-circuit evaluation:**
```hemlock
if (true || expensive_check()) {
    // expensive_check() never called
}
```

### Logical NOT (`!`)

Negates boolean value:

```hemlock
if (!is_valid) {
    print("invalid");
}

if (!(x > 10)) {
    // Same as: if (x <= 10)
}
```

## Comparison Operators

### Equality

```hemlock
if (x == 10) { }    // Equal
if (x != 10) { }    // Not equal
```

Works with all types:
```hemlock
"hello" == "hello"  // true
true == false       // false
null == null        // true
```

### Relational

```hemlock
if (x < 10) { }     // Less than
if (x > 10) { }     // Greater than
if (x <= 10) { }    // Less than or equal
if (x >= 10) { }    // Greater than or equal
```

**Type promotion applies:**
```hemlock
let a: i32 = 10;
let b: i64 = 10;
if (a == b) { }     // true (i32 promoted to i64)
```

## Bitwise Operators

Hemlock provides bitwise operators for integer manipulation. These work **only with integer types** (i8-i64, u8-u64).

### Binary Bitwise Operators

**Bitwise AND (`&`)**
```hemlock
let a = 12;  // 1100 in binary
let b = 10;  // 1010 in binary
print(a & b);   // 8 (1000)
```

**Bitwise OR (`|`)**
```hemlock
print(a | b);   // 14 (1110)
```

**Bitwise XOR (`^`)**
```hemlock
print(a ^ b);   // 6 (0110)
```

**Left Shift (`<<`)**
```hemlock
print(a << 2);  // 48 (110000) - shift left by 2
```

**Right Shift (`>>`)**
```hemlock
print(a >> 1);  // 6 (110) - shift right by 1
```

### Unary Bitwise Operator

**Bitwise NOT (`~`)**
```hemlock
let a = 12;
print(~a);      // -13 (two's complement)

let c: u8 = 15;   // 00001111 in binary
print(~c);        // 240 (11110000) in u8
```

### Bitwise Examples

**With unsigned types:**
```hemlock
let c: u8 = 15;   // 00001111 in binary
let d: u8 = 7;    // 00000111 in binary

print(c & d);     // 7  (00000111)
print(c | d);     // 15 (00001111)
print(c ^ d);     // 8  (00001000)
print(~c);        // 240 (11110000) - in u8
```

**Type preservation:**
```hemlock
// Bitwise operations preserve the type of operands
let x: u8 = 255;
let result = ~x;  // result is u8 with value 0

let y: i32 = 100;
let result2 = y << 2;  // result2 is i32 with value 400
```

**Common patterns:**
```hemlock
// Check if bit is set
if (flags & 0x04) {
    print("bit 2 is set");
}

// Set a bit
flags = flags | 0x08;

// Clear a bit
flags = flags & ~0x02;

// Toggle a bit
flags = flags ^ 0x01;
```

### Operator Precedence

Bitwise operators follow C-style precedence:

1. `~` (unary NOT) - highest, same level as `!` and `-`
2. `<<`, `>>` (shifts) - higher than comparisons, lower than `+`/`-`
3. `&` (bitwise AND) - higher than `^` and `|`
4. `^` (bitwise XOR) - between `&` and `|`
5. `|` (bitwise OR) - lower than `&` and `^`, higher than `&&`
6. `&&`, `||` (logical) - lowest precedence

**Examples:**
```hemlock
// & has higher precedence than |
let result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12

// Shift has higher precedence than bitwise operators
let result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12

// Use parentheses for clarity
let result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5
```

**Important notes:**
- Bitwise operators only work with integer types (not floats, strings, etc.)
- Type promotion follows standard rules (smaller types promote to larger)
- Right shift (`>>`) is arithmetic for signed types, logical for unsigned
- Shift amounts are not range-checked (behavior is platform-dependent for large shifts)

## Operator Precedence (Complete)

From highest to lowest precedence:

1. **Unary**: `!`, `-`, `~`
2. **Multiplicative**: `*`, `/`, `%`
3. **Additive**: `+`, `-`
4. **Shift**: `<<`, `>>`
5. **Relational**: `<`, `>`, `<=`, `>=`
6. **Equality**: `==`, `!=`
7. **Bitwise AND**: `&`
8. **Bitwise XOR**: `^`
9. **Bitwise OR**: `|`
10. **Logical AND**: `&&`
11. **Logical OR**: `||`

**Use parentheses for clarity:**
```hemlock
// Unclear
if (a || b && c) { }

// Clear
if (a || (b && c)) { }
if ((a || b) && c) { }
```

## Common Patterns

### Pattern: Input Validation

```hemlock
fn validate_age(age: i32): bool {
    if (age < 0 || age > 150) {
        return false;
    }
    return true;
}
```

### Pattern: Range Checking

```hemlock
fn in_range(value: i32, min: i32, max: i32): bool {
    return value >= min && value <= max;
}

if (in_range(score, 0, 100)) {
    print("valid score");
}
```

### Pattern: State Machine

```hemlock
let state = "start";

while (true) {
    switch (state) {
        case "start":
            print("Starting...");
            state = "running";
            break;

        case "running":
            if (should_pause) {
                state = "paused";
            } else if (should_stop) {
                state = "stopped";
            }
            break;

        case "paused":
            if (should_resume) {
                state = "running";
            }
            break;

        case "stopped":
            print("Stopped");
            break;
    }

    if (state == "stopped") {
        break;
    }
}
```

### Pattern: Iteration with Filtering

```hemlock
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Print only even numbers
for (let i = 0; i < arr.length; i = i + 1) {
    if (arr[i] % 2 != 0) {
        continue;  // Skip odd numbers
    }
    print(arr[i]);
}
```

### Pattern: Early Exit

```hemlock
fn find_first_negative(arr: array): i32 {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // Early exit
        }
    }
    return -1;  // Not found
}
```

## Best Practices

1. **Always use braces** - Even for single-statement blocks (enforced by syntax)
2. **Explicit conditions** - Use `x == 0` instead of `!x` for clarity
3. **Avoid deep nesting** - Extract nested conditions into functions
4. **Use early returns** - Reduce nesting with guard clauses
5. **Break complex conditions** - Split into named boolean variables
6. **Default in switch** - Always include a default case
7. **Comment fall-through** - Make intentional fall-through explicit

## Common Pitfalls

### Pitfall: Assignment in Condition

```hemlock
// This is NOT allowed (no assignment in conditions)
if (x = 10) { }  // ERROR: Syntax error

// Use comparison instead
if (x == 10) { }  // OK
```

### Pitfall: Missing Break in Switch

```hemlock
// Unintentional fall-through
switch (x) {
    case 1:
        print("one");
        // Missing break - falls through!
    case 2:
        print("two");  // Executes for both 1 and 2
        break;
}

// Fix: Add break
switch (x) {
    case 1:
        print("one");
        break;  // Now correct
    case 2:
        print("two");
        break;
}
```

### Pitfall: Loop Variable Scope

```hemlock
// i is scoped to the loop
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
print(i);  // ERROR: i not defined here
```

## Examples

### Example: FizzBuzz

```hemlock
for (let i = 1; i <= 100; i = i + 1) {
    if (i % 15 == 0) {
        print("FizzBuzz");
    } else if (i % 3 == 0) {
        print("Fizz");
    } else if (i % 5 == 0) {
        print("Buzz");
    } else {
        print(i);
    }
}
```

### Example: Prime Checker

```hemlock
fn is_prime(n: i32): bool {
    if (n < 2) {
        return false;
    }

    let i = 2;
    while (i * i <= n) {
        if (n % i == 0) {
            return false;
        }
        i = i + 1;
    }

    return true;
}
```

### Example: Menu System

```hemlock
fn menu() {
    while (true) {
        print("1. Start");
        print("2. Settings");
        print("3. Exit");

        let choice = get_input();

        switch (choice) {
            case 1:
                start_game();
                break;
            case 2:
                show_settings();
                break;
            case 3:
                print("Goodbye!");
                return;
            default:
                print("Invalid choice");
                break;
        }
    }
}
```

## Related Topics

- [Functions](#language-guide-functions) - Control flow with function calls and returns
- [Error Handling](#language-guide-error-handling) - Control flow with exceptions
- [Types](#language-guide-types) - Type conversions in conditions

## See Also

- **Syntax**: See [Syntax](#language-guide-syntax) for statement syntax details
- **Operators**: See [Types](#language-guide-types) for type promotion in operations


--------------------------------------------------------------------------------
## Error Handling
--------------------------------------------------------------------------------

# Error Handling

Hemlock supports exception-based error handling with `try`, `catch`, `finally`, `throw`, and `panic`. This guide covers recoverable errors with exceptions and unrecoverable errors with panic.

## Overview

```hemlock
// Basic error handling
try {
    risky_operation();
} catch (e) {
    print("Error: " + e);
}

// With cleanup
try {
    process_file();
} catch (e) {
    print("Failed: " + e);
} finally {
    cleanup();
}

// Throwing errors
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}
```

## Try-Catch-Finally

### Syntax

**Basic try/catch:**
```hemlock
try {
    // risky code
} catch (e) {
    // handle error, e contains the thrown value
}
```

**Try/finally:**
```hemlock
try {
    // risky code
} finally {
    // always executes, even if exception thrown
}
```

**Try/catch/finally:**
```hemlock
try {
    // risky code
} catch (e) {
    // handle error
} finally {
    // cleanup code
}
```

### Try Block

The try block executes statements sequentially:

```hemlock
try {
    print("Starting...");
    risky_operation();
    print("Success!");  // Only if no exception
}
```

**Behavior:**
- Executes statements in order
- If exception thrown: jumps to `catch` or `finally`
- If no exception: executes `finally` (if present) then continues

### Catch Block

The catch block receives the thrown value:

```hemlock
try {
    throw "oops";
} catch (error) {
    print("Caught: " + error);  // error = "oops"
    // error only accessible here
}
// error not accessible here
```

**Catch parameter:**
- Receives the thrown value (any type)
- Scoped to the catch block
- Can be named anything (conventionally `e`, `err`, or `error`)

**What you can do in catch:**
```hemlock
try {
    risky_operation();
} catch (e) {
    // Log the error
    print("Error: " + e);

    // Re-throw same error
    throw e;

    // Throw different error
    throw "different error";

    // Return a default value
    return null;

    // Handle and continue
    // (no re-throw)
}
```

### Finally Block

The finally block **always executes**:

```hemlock
try {
    print("1: try");
    throw "error";
} catch (e) {
    print("2: catch");
} finally {
    print("3: finally");  // Always runs
}
print("4: after");

// Output: 1: try, 2: catch, 3: finally, 4: after
```

**When finally runs:**
- After try block (if no exception)
- After catch block (if exception caught)
- Even if try/catch contains `return`, `break`, or `continue`
- Before control flow exits the try/catch

**Finally with return:**
```hemlock
fn example() {
    try {
        return 1;  // âœ… Returns 1 after finally runs
    } finally {
        print("cleanup");  // Runs before returning
    }
}

fn example2() {
    try {
        return 1;
    } finally {
        return 2;  // âš ï¸ Finally return overrides - returns 2
    }
}
```

**Finally with control flow:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    try {
        if (i == 5) {
            break;  // âœ… Breaks after finally runs
        }
    } finally {
        print("cleanup " + typeof(i));
    }
}
```

## Throw Statement

### Basic Throw

Throw any value as an exception:

```hemlock
throw "error message";
throw 404;
throw { code: 500, message: "Internal error" };
throw null;
throw ["error", "details"];
```

**Execution:**
1. Evaluates the expression
2. Immediately jumps to nearest enclosing `catch`
3. If no `catch`, propagates up the call stack

### Throwing Errors

```hemlock
fn validate_age(age: i32) {
    if (age < 0) {
        throw "Age cannot be negative";
    }
    if (age > 150) {
        throw "Age is unrealistic";
    }
}

try {
    validate_age(-5);
} catch (e) {
    print("Validation error: " + e);
}
```

### Throwing Error Objects

Create structured error information:

```hemlock
fn read_file(path: string) {
    if (!file_exists(path)) {
        throw {
            type: "FileNotFound",
            path: path,
            message: "File does not exist"
        };
    }
    // ... read file
}

try {
    read_file("missing.txt");
} catch (e) {
    if (e.type == "FileNotFound") {
        print("File not found: " + e.path);
    }
}
```

### Re-throwing

Catch and re-throw errors:

```hemlock
fn wrapper() {
    try {
        risky_operation();
    } catch (e) {
        print("Logging error: " + e);
        throw e;  // Re-throw to caller
    }
}

try {
    wrapper();
} catch (e) {
    print("Caught in main: " + e);
}
```

## Uncaught Exceptions

If an exception propagates to the top of the call stack without being caught:

```hemlock
fn foo() {
    throw "uncaught!";
}

foo();  // Crashes with: Runtime error: uncaught!
```

**Behavior:**
- Program crashes
- Prints error message to stderr
- Exits with non-zero status code
- Stack trace to be added in future versions

## Panic - Unrecoverable Errors

### What is Panic?

`panic()` is for **unrecoverable errors** that should immediately terminate the program:

```hemlock
panic();                    // Default message: "panic!"
panic("custom message");    // Custom message
panic(42);                  // Non-string values are printed
```

**Semantics:**
- **Immediately exits** the program with exit code 1
- Prints error message to stderr: `panic: <message>`
- **NOT catchable** with try/catch
- Use for bugs and unrecoverable errors

### Panic vs Throw

```hemlock
// throw - Recoverable error (can be caught)
try {
    throw "recoverable error";
} catch (e) {
    print("Caught: " + e);  // âœ… Caught successfully
}

// panic - Unrecoverable error (cannot be caught)
try {
    panic("unrecoverable error");  // âŒ Program exits immediately
} catch (e) {
    print("This never runs");       // âŒ Never executes
}
```

### When to Use Panic

**Use panic for:**
- **Bugs**: Unreachable code was reached
- **Invalid state**: Data structure corruption detected
- **Unrecoverable errors**: Critical resource unavailable
- **Assertion failures**: When `assert()` isn't sufficient

**Examples:**
```hemlock
// Unreachable code
fn process_state(state: i32) {
    if (state == 1) {
        return "ready";
    } else if (state == 2) {
        return "running";
    } else if (state == 3) {
        return "stopped";
    } else {
        panic("invalid state: " + typeof(state));  // Should never happen
    }
}

// Critical resource check
fn init_system() {
    let config = read_file("config.json");
    if (config == null) {
        panic("config.json not found - cannot start");
    }
    // ...
}

// Data structure invariant
fn pop_stack(stack) {
    if (stack.length == 0) {
        panic("pop() called on empty stack");
    }
    return stack.pop();
}
```

### When NOT to Use Panic

**Use throw instead for:**
- User input validation
- File not found
- Network errors
- Expected error conditions

```hemlock
// BAD: Panic for expected errors
fn divide(a, b) {
    if (b == 0) {
        panic("division by zero");  // âŒ Too harsh
    }
    return a / b;
}

// GOOD: Throw for expected errors
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";  // âœ… Recoverable
    }
    return a / b;
}
```

## Control Flow Interactions

### Return Inside Try/Catch/Finally

```hemlock
fn example() {
    try {
        return 1;  // âœ… Returns 1 after finally runs
    } finally {
        print("cleanup");
    }
}

fn example2() {
    try {
        return 1;
    } finally {
        return 2;  // âš ï¸ Finally return overrides try return - returns 2
    }
}
```

**Rule:** Finally block return values override try/catch return values.

### Break/Continue Inside Try/Catch/Finally

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    try {
        if (i == 5) { break; }  // âœ… Breaks after finally runs
    } finally {
        print("cleanup " + typeof(i));
    }
}
```

**Rule:** Break/continue execute after finally block.

### Nested Try/Catch

```hemlock
try {
    try {
        throw "inner";
    } catch (e) {
        print("Caught: " + e);  // Prints: Caught: inner
        throw "outer";  // Re-throw different error
    }
} catch (e) {
    print("Caught: " + e);  // Prints: Caught: outer
}
```

**Rule:** Nested try/catch blocks work as expected, inner catches happen first.

## Common Patterns

### Pattern: Resource Cleanup

Always use `finally` for cleanup:

```hemlock
fn process_file(filename) {
    let file = null;
    try {
        file = open(filename);
        let content = file.read();
        process(content);
    } catch (e) {
        print("Error processing file: " + e);
    } finally {
        if (file != null) {
            file.close();  // Always closes, even on error
        }
    }
}
```

### Pattern: Error Wrapping

Wrap lower-level errors with context:

```hemlock
fn load_config(path) {
    try {
        let content = read_file(path);
        return parse_json(content);
    } catch (e) {
        throw "Failed to load config from " + path + ": " + e;
    }
}
```

### Pattern: Error Recovery

Provide fallback on error:

```hemlock
fn safe_divide(a, b) {
    try {
        if (b == 0) {
            throw "division by zero";
        }
        return a / b;
    } catch (e) {
        print("Error: " + e);
        return null;  // Fallback value
    }
}
```

### Pattern: Validation

Use exceptions for validation:

```hemlock
fn validate_user(user) {
    if (user.name == null || user.name == "") {
        throw "Name is required";
    }
    if (user.age < 0 || user.age > 150) {
        throw "Invalid age";
    }
    if (user.email == null || !user.email.contains("@")) {
        throw "Invalid email";
    }
}

try {
    validate_user({ name: "Alice", age: -5, email: "invalid" });
} catch (e) {
    print("Validation failed: " + e);
}
```

### Pattern: Multiple Error Types

Use error objects to distinguish error types:

```hemlock
fn process_data(data) {
    if (data == null) {
        throw { type: "NullData", message: "Data is null" };
    }

    if (typeof(data) != "array") {
        throw { type: "TypeError", message: "Expected array" };
    }

    if (data.length == 0) {
        throw { type: "EmptyData", message: "Array is empty" };
    }

    // ... process
}

try {
    process_data(null);
} catch (e) {
    if (e.type == "NullData") {
        print("No data provided");
    } else if (e.type == "TypeError") {
        print("Wrong data type: " + e.message);
    } else {
        print("Error: " + e.message);
    }
}
```

## Best Practices

1. **Use exceptions for exceptional cases** - Not for normal control flow
2. **Throw meaningful errors** - Use strings or objects with context
3. **Always use finally for cleanup** - Ensures resources are freed
4. **Don't catch and ignore** - At least log the error
5. **Re-throw when appropriate** - Let caller handle if you can't
6. **Panic for bugs** - Use panic for unrecoverable errors
7. **Document exceptions** - Make clear what functions can throw

## Common Pitfalls

### Pitfall: Swallowing Errors

```hemlock
// BAD: Silent failure
try {
    risky_operation();
} catch (e) {
    // Error ignored - silent failure
}

// GOOD: Log or handle
try {
    risky_operation();
} catch (e) {
    print("Operation failed: " + e);
    // Handle appropriately
}
```

### Pitfall: Finally Override

```hemlock
// BAD: Finally overrides return
fn get_value() {
    try {
        return 42;
    } finally {
        return 0;  // âš ï¸ Returns 0, not 42!
    }
}

// GOOD: Don't return in finally
fn get_value() {
    try {
        return 42;
    } finally {
        cleanup();  // Just cleanup, no return
    }
}
```

### Pitfall: Forgetting Cleanup

```hemlock
// BAD: File may not be closed on error
fn process() {
    let file = open("data.txt");
    let content = file.read();  // May throw
    file.close();  // Never reached if error
}

// GOOD: Use finally
fn process() {
    let file = null;
    try {
        file = open("data.txt");
        let content = file.read();
    } finally {
        if (file != null) {
            file.close();
        }
    }
}
```

### Pitfall: Using Panic for Expected Errors

```hemlock
// BAD: Panic for expected error
fn read_config(path) {
    if (!file_exists(path)) {
        panic("Config file not found");  // âŒ Too harsh
    }
    return read_file(path);
}

// GOOD: Throw for expected error
fn read_config(path) {
    if (!file_exists(path)) {
        throw "Config file not found: " + path;  // âœ… Recoverable
    }
    return read_file(path);
}
```

## Examples

### Example: Basic Error Handling

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}

try {
    print(divide(10, 0));
} catch (e) {
    print("Error: " + e);  // Prints: Error: division by zero
}
```

### Example: Resource Management

```hemlock
fn copy_file(src, dst) {
    let src_file = null;
    let dst_file = null;

    try {
        src_file = open(src, "r");
        dst_file = open(dst, "w");

        let content = src_file.read();
        dst_file.write(content);

        print("File copied successfully");
    } catch (e) {
        print("Failed to copy file: " + e);
        throw e;  // Re-throw
    } finally {
        if (src_file != null) { src_file.close(); }
        if (dst_file != null) { dst_file.close(); }
    }
}
```

### Example: Nested Error Handling

```hemlock
fn process_users(users) {
    let success_count = 0;
    let error_count = 0;

    let i = 0;
    while (i < users.length) {
        try {
            validate_user(users[i]);
            save_user(users[i]);
            success_count = success_count + 1;
        } catch (e) {
            print("Failed to process user: " + e);
            error_count = error_count + 1;
        }
        i = i + 1;
    }

    print("Processed: " + typeof(success_count) + " success, " + typeof(error_count) + " errors");
}
```

### Example: Custom Error Types

```hemlock
fn create_error(type, message, details) {
    return {
        type: type,
        message: message,
        details: details,
        toString: fn() {
            return self.type + ": " + self.message;
        }
    };
}

fn divide(a, b) {
    if (typeof(a) != "i32" && typeof(a) != "f64") {
        throw create_error("TypeError", "a must be a number", { value: a });
    }
    if (typeof(b) != "i32" && typeof(b) != "f64") {
        throw create_error("TypeError", "b must be a number", { value: b });
    }
    if (b == 0) {
        throw create_error("DivisionByZero", "Cannot divide by zero", { a: a, b: b });
    }
    return a / b;
}

try {
    divide(10, 0);
} catch (e) {
    print(e.toString());
    if (e.type == "DivisionByZero") {
        print("Details: a=" + typeof(e.details.a) + ", b=" + typeof(e.details.b));
    }
}
```

### Example: Retry Logic

```hemlock
fn retry(operation, max_attempts) {
    let attempt = 0;

    while (attempt < max_attempts) {
        try {
            return operation();  // Success!
        } catch (e) {
            attempt = attempt + 1;
            if (attempt >= max_attempts) {
                throw "Operation failed after " + typeof(max_attempts) + " attempts: " + e;
            }
            print("Attempt " + typeof(attempt) + " failed, retrying...");
        }
    }
}

fn unreliable_operation() {
    // Simulated unreliable operation
    if (random() < 0.7) {
        throw "Operation failed";
    }
    return "Success";
}

try {
    let result = retry(unreliable_operation, 3);
    print(result);
} catch (e) {
    print("All retries failed: " + e);
}
```

## Execution Order

Understanding the execution order:

```hemlock
try {
    print("1: try block start");
    throw "error";
    print("2: never reached");
} catch (e) {
    print("3: catch block");
} finally {
    print("4: finally block");
}
print("5: after try/catch/finally");

// Output:
// 1: try block start
// 3: catch block
// 4: finally block
// 5: after try/catch/finally
```

## Current Limitations

- **No stack trace** - Uncaught exceptions don't show stack trace (planned)
- **Some built-ins exit** - Some built-in functions still `exit()` instead of throwing (to be reviewed)
- **No custom exception types** - Any value can be thrown, but no formal exception hierarchy

## Related Topics

- [Functions](#language-guide-functions) - Exceptions and function returns
- [Control Flow](#language-guide-control-flow) - How exceptions affect control flow
- [Memory](#language-guide-memory) - Using finally for memory cleanup

## See Also

- **Exception Semantics**: See CLAUDE.md section "Error Handling"
- **Panic vs Throw**: Different use cases for different error types
- **Finally Guarantee**: Always executes, even with return/break/continue


--------------------------------------------------------------------------------
## Functions
--------------------------------------------------------------------------------

# Functions

Functions in Hemlock are **first-class values** that can be assigned to variables, passed as arguments, and returned from other functions. This guide covers function syntax, closures, recursion, and advanced patterns.

## Overview

```hemlock
// Named function syntax
fn add(a: i32, b: i32): i32 {
    return a + b;
}

// Anonymous function
let multiply = fn(x, y) {
    return x * y;
};

// Closures
fn makeAdder(x) {
    return fn(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
print(add5(3));  // 8
```

## Function Declaration

### Named Functions

```hemlock
fn greet(name: string): string {
    return "Hello, " + name;
}

let msg = greet("Alice");  // "Hello, Alice"
```

**Components:**
- `fn` - Function keyword
- `greet` - Function name
- `(name: string)` - Parameters with optional types
- `: string` - Optional return type
- `{ ... }` - Function body

### Anonymous Functions

Functions without names, assigned to variables:

```hemlock
let square = fn(x) {
    return x * x;
};

print(square(5));  // 25
```

**Named vs. Anonymous:**
```hemlock
// These are equivalent:
fn add(a, b) { return a + b; }

let add = fn(a, b) { return a + b; };
```

**Note:** Named functions desugar to variable assignments with anonymous functions.

## Parameters

### Basic Parameters

```hemlock
fn example(a, b, c) {
    return a + b + c;
}

let result = example(1, 2, 3);  // 6
```

### Type Annotations

Optional type annotations on parameters:

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 10);      // OK
add(5, 10.5);    // Runtime type check promotes to f64
```

**Type checking:**
- Parameter types are checked at call time if annotated
- Implicit type conversions follow standard promotion rules
- Type mismatches cause runtime errors

### Pass-by-Value

All arguments are **copied** (pass-by-value):

```hemlock
fn modify(x) {
    x = 100;  // Only modifies local copy
}

let a = 10;
modify(a);
print(a);  // Still 10 (unchanged)
```

**Note:** Objects and arrays are passed by reference (the reference is copied), so their contents can be modified:

```hemlock
fn modify_array(arr) {
    arr[0] = 99;  // Modifies original array
}

let a = [1, 2, 3];
modify_array(a);
print(a[0]);  // 99 (modified)
```

## Return Values

### Return Statement

```hemlock
fn get_max(a: i32, b: i32): i32 {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}
```

### Return Type Annotations

Optional type annotation for return value:

```hemlock
fn calculate(): f64 {
    return 3.14159;
}

fn get_name(): string {
    return "Alice";
}
```

**Type checking:**
- Return types are checked when function returns (if annotated)
- Type conversions follow standard promotion rules

### Implicit Return

Functions without return type annotation implicitly return `null`:

```hemlock
fn print_message(msg) {
    print(msg);
    // Implicitly returns null
}

let result = print_message("hello");  // result is null
```

### Early Return

```hemlock
fn find_first_negative(arr) {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // Early exit
        }
    }
    return -1;  // Not found
}
```

### Return Without Value

`return;` without a value returns `null`:

```hemlock
fn maybe_process(value) {
    if (value < 0) {
        return;  // Returns null
    }
    return value * 2;
}
```

## First-Class Functions

Functions can be assigned, passed, and returned like any other value.

### Functions as Variables

```hemlock
let operation = fn(x, y) { return x + y; };

print(operation(5, 3));  // 8

// Reassign
operation = fn(x, y) { return x * y; };
print(operation(5, 3));  // 15
```

### Functions as Arguments

```hemlock
fn apply(f, x) {
    return f(x);
}

fn double(n) {
    return n * 2;
}

let result = apply(double, 5);  // 10
```

### Functions as Return Values

```hemlock
fn get_operation(op: string) {
    if (op == "add") {
        return fn(a, b) { return a + b; };
    } else if (op == "multiply") {
        return fn(a, b) { return a * b; };
    } else {
        return fn(a, b) { return 0; };
    }
}

let add = get_operation("add");
print(add(5, 3));  // 8
```

## Closures

Functions capture their defining environment (lexical scoping).

### Basic Closures

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
print(counter());  // 3
```

**How it works:**
- Inner function captures `count` from outer scope
- `count` persists across calls to the returned function
- Each call to `makeCounter()` creates a new closure with its own `count`

### Closure with Parameters

```hemlock
fn makeAdder(x) {
    return fn(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
let add10 = makeAdder(10);

print(add5(3));   // 8
print(add10(3));  // 13
```

### Multiple Closures

```hemlock
fn makeOperations(x) {
    let add = fn(y) { return x + y; };
    let multiply = fn(y) { return x * y; };

    return { add: add, multiply: multiply };
}

let ops = makeOperations(5);
print(ops.add(3));       // 8
print(ops.multiply(3));  // 15
```

### Lexical Scoping

Functions can access outer scope variables through lexical scoping:

```hemlock
let global = 10;

fn outer() {
    let outer_var = 20;

    fn inner() {
        // Can read global and outer_var
        print(global);      // 10
        print(outer_var);   // 20
    }

    inner();
}

outer();
```

Closures capture variables by reference, allowing both reading and mutation of outer scope variables (as shown in the `makeCounter` example above).

## Recursion

Functions can call themselves.

### Basic Recursion

```hemlock
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

print(factorial(5));  // 120
```

### Mutual Recursion

Functions can call each other:

```hemlock
fn is_even(n: i32): bool {
    if (n == 0) {
        return true;
    }
    return is_odd(n - 1);
}

fn is_odd(n: i32): bool {
    if (n == 0) {
        return false;
    }
    return is_even(n - 1);
}

print(is_even(4));  // true
print(is_odd(4));   // false
```

### Recursive Data Processing

```hemlock
fn sum_array(arr: array, index: i32): i32 {
    if (index >= arr.length) {
        return 0;
    }
    return arr[index] + sum_array(arr, index + 1);
}

let numbers = [1, 2, 3, 4, 5];
print(sum_array(numbers, 0));  // 15
```

**Note:** No tail call optimization yet - deep recursion may cause stack overflow.

## Higher-Order Functions

Functions that take or return other functions.

### Map Pattern

```hemlock
fn map(arr, f) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        result.push(f(arr[i]));
        i = i + 1;
    }
    return result;
}

fn double(x) { return x * 2; }

let numbers = [1, 2, 3, 4, 5];
let doubled = map(numbers, double);  // [2, 4, 6, 8, 10]
```

### Filter Pattern

```hemlock
fn filter(arr, predicate) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        if (predicate(arr[i])) {
            result.push(arr[i]);
        }
        i = i + 1;
    }
    return result;
}

fn is_even(x) { return x % 2 == 0; }

let numbers = [1, 2, 3, 4, 5, 6];
let evens = filter(numbers, is_even);  // [2, 4, 6]
```

### Reduce Pattern

```hemlock
fn reduce(arr, f, initial) {
    let accumulator = initial;
    let i = 0;
    while (i < arr.length) {
        accumulator = f(accumulator, arr[i]);
        i = i + 1;
    }
    return accumulator;
}

fn add(a, b) { return a + b; }

let numbers = [1, 2, 3, 4, 5];
let sum = reduce(numbers, add, 0);  // 15
```

### Function Composition

```hemlock
fn compose(f, g) {
    return fn(x) {
        return f(g(x));
    };
}

fn double(x) { return x * 2; }
fn increment(x) { return x + 1; }

let double_then_increment = compose(increment, double);
print(double_then_increment(5));  // 11 (5*2 + 1)
```

## Common Patterns

### Pattern: Factory Functions

```hemlock
fn createPerson(name: string, age: i32) {
    return {
        name: name,
        age: age,
        greet: fn() {
            return "Hi, I'm " + self.name;
        }
    };
}

let person = createPerson("Alice", 30);
print(person.greet());  // "Hi, I'm Alice"
```

### Pattern: Callback Functions

```hemlock
fn process_async(data, callback) {
    // ... do processing
    callback(data);
}

process_async("test", fn(result) {
    print("Processing complete: " + result);
});
```

### Pattern: Partial Application

```hemlock
fn partial(f, x) {
    return fn(y) {
        return f(x, y);
    };
}

fn multiply(a, b) {
    return a * b;
}

let double = partial(multiply, 2);
let triple = partial(multiply, 3);

print(double(5));  // 10
print(triple(5));  // 15
```

### Pattern: Memoization

```hemlock
fn memoize(f) {
    let cache = {};

    return fn(x) {
        if (cache.has(x)) {
            return cache[x];
        }

        let result = f(x);
        cache[x] = result;
        return result;
    };
}

fn expensive_fibonacci(n) {
    if (n <= 1) { return n; }
    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);
}

let fast_fib = memoize(expensive_fibonacci);
print(fast_fib(10));  // Much faster with caching
```

## Function Semantics

### Return Type Requirements

Functions with return type annotation **must** return a value:

```hemlock
fn get_value(): i32 {
    // ERROR: Missing return statement
}

fn get_value(): i32 {
    return 42;  // OK
}
```

### Type Checking

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 10);        // OK
add(5.5, 10.5);    // Promotes to f64, returns f64
add("a", "b");     // Runtime error: type mismatch
```

### Scope Rules

```hemlock
let global = "global";

fn outer() {
    let outer_var = "outer";

    fn inner() {
        let inner_var = "inner";
        // Can access: inner_var, outer_var, global
    }

    // Can access: outer_var, global
    // Cannot access: inner_var
}

// Can access: global
// Cannot access: outer_var, inner_var
```

## Best Practices

1. **Use type annotations** - Helps catch errors and documents intent
2. **Keep functions small** - Each function should do one thing
3. **Prefer pure functions** - Avoid side effects when possible
4. **Name functions clearly** - Use descriptive verb names
5. **Return early** - Use guard clauses to reduce nesting
6. **Document complex closures** - Make captured variables explicit
7. **Avoid deep recursion** - No tail call optimization yet

## Common Pitfalls

### Pitfall: Recursion Depth

```hemlock
// Deep recursion may cause stack overflow
fn count_down(n) {
    if (n == 0) { return; }
    count_down(n - 1);
}

count_down(100000);  // May crash with stack overflow
```

### Pitfall: Modifying Captured Variables

```hemlock
fn make_counter() {
    let count = 0;
    return fn() {
        count = count + 1;  // Can read and modify captured variables
        return count;
    };
}
```

**Note:** This works, but be aware that all closures share the same captured environment.

## Examples

### Example: Function Pipeline

```hemlock
fn pipeline(value, ...functions) {
    let result = value;
    for (f in functions) {
        result = f(result);
    }
    return result;
}

fn double(x) { return x * 2; }
fn increment(x) { return x + 1; }
fn square(x) { return x * x; }

let result = pipeline(3, double, increment, square);
print(result);  // 49 ((3*2+1)^2)
```

### Example: Event Handler

```hemlock
let handlers = [];

fn on_event(name: string, handler) {
    handlers.push({ name: name, handler: handler });
}

fn trigger_event(name: string, data) {
    let i = 0;
    while (i < handlers.length) {
        if (handlers[i].name == name) {
            handlers[i].handler(data);
        }
        i = i + 1;
    }
}

on_event("click", fn(data) {
    print("Clicked: " + data);
});

trigger_event("click", "button1");
```

### Example: Sorting with Custom Comparator

```hemlock
fn sort(arr, compare) {
    // Bubble sort with custom comparator
    let n = arr.length;
    let i = 0;
    while (i < n) {
        let j = 0;
        while (j < n - i - 1) {
            if (compare(arr[j], arr[j + 1]) > 0) {
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

fn ascending(a, b) {
    if (a < b) { return -1; }
    if (a > b) { return 1; }
    return 0;
}

let numbers = [5, 2, 8, 1, 9];
sort(numbers, ascending);
print(numbers);  // [1, 2, 5, 8, 9]
```

## Optional Parameters (Default Arguments)

Functions can have optional parameters with default values using the `?:` syntax:

```hemlock
fn greet(name, greeting?: "Hello") {
    return greeting + " " + name;
}

print(greet("Alice"));           // "Hello Alice"
print(greet("Bob", "Hi"));       // "Hi Bob"

fn add(a, b?: 10, c?: 100) {
    return a + b + c;
}

print(add(1));          // 111 (1 + 10 + 100)
print(add(1, 2));       // 103 (1 + 2 + 100)
print(add(1, 2, 3));    // 6   (1 + 2 + 3)
```

**Rules:**
- Optional parameters must come after required parameters
- Default values can be any expression
- Omitted arguments use the default value

## Variadic Functions (Rest Parameters)

Functions can accept a variable number of arguments using rest parameters (`...`):

```hemlock
fn sum(...args) {
    let total = 0;
    for (arg in args) {
        total = total + arg;
    }
    return total;
}

print(sum(1, 2, 3));        // 6
print(sum(1, 2, 3, 4, 5));  // 15
print(sum());               // 0

fn log(prefix, ...messages) {
    for (msg in messages) {
        print(prefix + ": " + msg);
    }
}

log("INFO", "Starting", "Running", "Done");
// INFO: Starting
// INFO: Running
// INFO: Done
```

**Rules:**
- Rest parameter must be the last parameter
- Rest parameter collects all remaining arguments into an array
- Can be combined with regular and optional parameters

## Function Type Annotations

Function types allow you to specify the exact signature expected for function parameters and return values:

### Basic Function Types

```hemlock
// Function type syntax: fn(param_types): return_type
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

let double = fn(n) { return n * 2; };
let result = apply(double, 5);  // 10
```

### Higher-Order Function Types

```hemlock
// Function returning a function
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

let add5 = make_adder(5);
print(add5(10));  // 15
```

### Async Function Types

```hemlock
// Async function type
fn run_task(handler: async fn(): void) {
    spawn(handler);
}

run_task(async fn() {
    print("Running async!");
});
```

### Function Type Aliases

```hemlock
// Create named function types for clarity
type Callback = fn(i32): void;
type Predicate = fn(any): bool;
type BinaryOp = fn(i32, i32): i32;

fn filter_with(arr: array, pred: Predicate): array {
    return arr.filter(pred);
}
```

## Const Parameters

The `const` modifier prevents a parameter from being mutated within the function:

### Basic Const Parameters

```hemlock
fn print_all(const items: array) {
    // items.push(4);  // ERROR: cannot mutate const parameter
    for (item in items) {
        print(item);   // OK: reading is allowed
    }
}

let nums = [1, 2, 3];
print_all(nums);
```

### Deep Immutability

Const parameters enforce deep immutability - no mutation through any path:

```hemlock
fn describe(const person: object) {
    print(person.name);       // OK: reading is allowed
    // person.name = "Bob";   // ERROR: cannot mutate
    // person.address.city = "NYC";  // ERROR: deep const
}
```

### What Const Prevents

| Type | Blocked by Const | Allowed |
|------|-----------------|---------|
| array | push, pop, shift, unshift, insert, remove, clear, reverse | slice, concat, map, filter, find, contains |
| object | field assignment | field read |
| buffer | index assignment | index read |
| string | index assignment | all methods (return new strings) |

## Named Arguments

Functions can be called with named arguments for clarity and flexibility:

### Basic Named Arguments

```hemlock
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " is " + age + " years old");
}

// Positional arguments (traditional)
create_user("Alice", 25, false);

// Named arguments - can be in any order
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);
```

### Mixing Positional and Named

```hemlock
// Skip optional parameters by naming what you need
create_user("David", active: false);  // Uses default age=18

// Named arguments must come after positional
create_user("Eve", age: 21);          // OK
// create_user(name: "Bad", 25);      // ERROR: positional after named
```

### Rules for Named Arguments

- Use `name: value` syntax for named arguments
- Named arguments can appear in any order after positional arguments
- Positional arguments cannot follow named arguments
- Works with default/optional parameters
- Unknown parameter names cause runtime errors

## Limitations

Current limitations to be aware of:

- **No pass-by-reference** - `ref` keyword parsed but not implemented
- **No function overloading** - One function per name
- **No tail call optimization** - Deep recursion limited by stack size

## Related Topics

- [Control Flow](#language-guide-control-flow) - Using functions with control structures
- [Objects](#language-guide-objects) - Methods are functions stored in objects
- [Error Handling](#language-guide-error-handling) - Functions and exception handling
- [Types](#language-guide-types) - Type annotations and conversions

## See Also

- **Closures**: See CLAUDE.md section "Functions" for closure semantics
- **First-Class Values**: Functions are values like any other
- **Lexical Scoping**: Functions capture their defining environment


--------------------------------------------------------------------------------
## Memory
--------------------------------------------------------------------------------

# Memory Management

Hemlock embraces **manual memory management** with explicit control over allocation and deallocation. This guide covers Hemlock's memory model, the two pointer types, and the complete memory API.

---

## Memory 101: The Basics

**New to programming?** Start here. If you already understand memory management, skip to [Philosophy](#philosophy).

### What is Memory Management?

When your program needs to store data (text, numbers, lists), it needs space to put it. That space comes from your computer's memory (RAM). Memory management is about:

1. **Getting space** - asking for memory when you need it
2. **Using space** - reading and writing your data
3. **Giving it back** - returning memory when you're done

### Why Does It Matter?

Imagine a library with limited books:
- If you keep checking out books and never return them, eventually there are none left
- If you try to read a book you already returned, you'll get confused or cause problems

Memory works the same way. If you forget to return memory, your program slowly uses more and more (a "memory leak"). If you try to use memory after returning it, bad things happen.

### The Good News

**Most of the time, you don't need to think about this!**

Hemlock automatically cleans up most common types:

```hemlock
fn example() {
    let name = "Alice";       // Hemlock manages this
    let numbers = [1, 2, 3];  // And this
    let person = { age: 30 }; // And this too

    // When the function ends, all of this is cleaned up automatically!
}
```

### When You DO Need to Think About It

You only need manual memory management when using:

1. **`alloc()`** - raw memory allocation (returns `ptr`)
2. **`buffer()`** - when you want to free early (optional - it auto-frees at scope end)

```hemlock
// This needs manual cleanup:
let raw = alloc(100);   // Raw memory - YOU must free it
// ... use raw ...
free(raw);              // Required! Or you have a memory leak

// This cleans up automatically (but you CAN free early):
let buf = buffer(100);  // Safe buffer
// ... use buf ...
// free(buf);           // Optional - will auto-free when scope ends
```

### The Simple Rule

> **If you call `alloc()`, you must call `free()`.**
>
> Everything else is handled for you.

### Which Should You Use?

| Situation | Use This | Why |
|-----------|----------|-----|
| **Just starting out** | `buffer()` | Safe, bounds-checked, auto-cleanup |
| **Need byte storage** | `buffer()` | Safe and easy |
| **Working with C libraries (FFI)** | `alloc()` / `ptr` | Required for C interop |
| **Maximum performance** | `alloc()` / `ptr` | No bounds checking overhead |
| **Not sure** | `buffer()` | Always the safer choice |

### Quick Example: Safe vs Raw

```hemlock
// RECOMMENDED: Safe buffer
fn safe_example() {
    let data = buffer(10);
    data[0] = 65;           // OK
    data[5] = 66;           // OK
    // data[100] = 67;      // ERROR - Hemlock stops you (bounds check)
    free(data);             // Clean up
}

// ADVANCED: Raw pointer (only when you need it)
fn raw_example() {
    let data = alloc(10);
    *data = 65;             // OK
    *(data + 5) = 66;       // OK
    *(data + 100) = 67;     // DANGER - No bounds check, corrupts memory!
    free(data);             // Clean up
}
```

**Start with `buffer()`. Only use `alloc()` when you specifically need raw pointers.**

---

## Philosophy

Hemlock follows the principle of explicit memory management with sensible defaults:
- No garbage collection (no unpredictable pauses)
- Internal refcounting for common types (string, array, object, buffer)
- Raw pointers (`ptr`) require manual `free()`

This hybrid approach gives you complete control when needed (raw pointers) while preventing common bugs for typical use cases (refcounted types auto-freed on scope exit).

## Internal Reference Counting

The runtime uses **internal reference counting** to manage object lifetimes. For most local variables of refcounted types, cleanup is automatic and deterministic.

### What Reference Counting Handles

The runtime automatically manages reference counts when:

1. **Variables are reassigned** - the old value is released:
   ```hemlock
   let x = "first";   // ref_count = 1
   x = "second";      // "first" released internally, "second" ref_count = 1
   ```

2. **Scopes exit** - local variables are released:
   ```hemlock
   fn example() {
       let arr = [1, 2, 3];  // ref_count = 1
   }  // arr released when function returns
   ```

3. **Containers are freed** - elements are released:
   ```hemlock
   let arr = [obj1, obj2];
   free(arr);  // obj1 and obj2 get their ref_counts decremented
   ```

### When You Need `free()` vs When It's Automatic

**Automatic (no `free()` needed):** Local variables of refcounted types are freed when scope exits:

```hemlock
fn process_data() {
    let arr = [1, 2, 3];
    let obj = { name: "test" };
    let buf = buffer(64);
    // ... use them ...
}  // All automatically freed when function returns - no free() needed
```

**Manual `free()` required:**

1. **Raw pointers** - `alloc()` has no refcounting:
   ```hemlock
   let p = alloc(64);
   // ... use p ...
   free(p);  // Always required - will leak otherwise
   ```

2. **Early cleanup** - free before scope ends to release memory sooner:
   ```hemlock
   fn long_running() {
       let big = buffer(10000000);  // 10MB
       // ... done with big ...
       free(big);  // Free now, don't wait for function to return
       // ... more work that doesn't need big ...
   }
   ```

3. **Long-lived data** - globals or data stored in persistent structures:
   ```hemlock
   let cache = {};  // Module-level, lives until program exit unless freed

   fn cleanup() {
       free(cache);  // Manual cleanup for long-lived data
   }
   ```

### Refcounting vs Garbage Collection

| Aspect | Hemlock Refcounting | Garbage Collection |
|--------|---------------------|-------------------|
| Cleanup timing | Deterministic (immediate when ref hits 0) | Non-deterministic (GC decides when) |
| User responsibility | Must call `free()` | Fully automatic |
| Runtime pauses | None | "Stop the world" pauses |
| Visibility | Hidden implementation detail | Usually invisible |
| Cycles | Handled with visited-set tracking | Handled by tracing |

### Which Types Have Refcounting

| Type | Refcounted | Notes |
|------|------------|-------|
| `ptr` | âŒ No | Always requires manual `free()` |
| `buffer` | âœ… Yes | Auto-freed on scope exit; manual `free()` for early cleanup |
| `array` | âœ… Yes | Auto-freed on scope exit; manual `free()` for early cleanup |
| `object` | âœ… Yes | Auto-freed on scope exit; manual `free()` for early cleanup |
| `string` | âœ… Yes | Fully automatic, no `free()` needed |
| `function` | âœ… Yes | Fully automatic (closure environments) |
| `task` | âœ… Yes | Thread-safe atomic refcounting |
| `channel` | âœ… Yes | Thread-safe atomic refcounting |
| Primitives | âŒ No | Stack-allocated, no heap allocation |

### Why This Design?

This hybrid approach gives you:
- **Explicit control** - You decide when to deallocate
- **Safety from scope bugs** - Reassignment doesn't leak
- **Predictable performance** - No GC pauses
- **Closure support** - Functions can safely capture variables

The philosophy remains: you're in control, but the runtime helps prevent common bugs like leaking on reassignment or double-freeing in containers.

## The Two Pointer Types

Hemlock provides two distinct pointer types, each with different safety characteristics:

### `ptr` - Raw Pointer (Dangerous)

Raw pointers are **just addresses** with minimal safety guarantees:

```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // You must remember to free
```

**Characteristics:**
- Just an 8-byte address
- No bounds checking
- No length tracking
- User manages lifetime entirely
- For experts and FFI

**Use cases:**
- Low-level system programming
- Foreign Function Interface (FFI)
- Performance-critical code
- When you need complete control

**Dangers:**
```hemlock
let p = alloc(10);
let q = p + 100;  // Way past allocation - allowed but dangerous
free(p);
let x = *p;       // Dangling pointer - undefined behavior
free(p);          // Double-free - will crash
```

### `buffer` - Safe Wrapper (Recommended)

Buffers provide **bounds-checked access** while still requiring manual deallocation:

```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // bounds checked
print(b.length);        // 64
free(b);                // still manual
```

**Characteristics:**
- Pointer + length + capacity
- Bounds checked on access
- Still requires manual `free()`
- Better default for most code

**Properties:**
```hemlock
let buf = buffer(100);
print(buf.length);      // 100 (current size)
print(buf.capacity);    // 100 (allocated capacity)
```

**Bounds checking:**
```hemlock
let buf = buffer(10);
buf[5] = 42;      // OK
buf[100] = 42;    // ERROR: Index out of bounds
```

## Memory API

### Core Allocation

**`alloc(bytes)` - Allocate raw memory**
```hemlock
let p = alloc(1024);  // Allocate 1KB, returns ptr
// ... use memory
free(p);
```

**`buffer(size)` - Allocate safe buffer**
```hemlock
let buf = buffer(256);  // Allocate 256-byte buffer
buf[0] = 65;            // 'A'
buf[1] = 66;            // 'B'
free(buf);
```

**`free(ptr)` - Free memory**
```hemlock
let p = alloc(100);
free(p);  // Must free to avoid memory leak

let buf = buffer(100);
free(buf);  // Works on both ptr and buffer
```

**Important:** `free()` works on both `ptr` and `buffer` types.

### Memory Operations

**`memset(ptr, byte, size)` - Fill memory**
```hemlock
let p = alloc(100);
memset(p, 0, 100);     // Zero out 100 bytes
memset(p, 65, 10);     // Fill first 10 bytes with 'A'
free(p);
```

**`memcpy(dest, src, size)` - Copy memory**
```hemlock
let src = alloc(50);
let dst = alloc(50);
memset(src, 42, 50);
memcpy(dst, src, 50);  // Copy 50 bytes from src to dst
free(src);
free(dst);
```

**`realloc(ptr, size)` - Resize allocation**
```hemlock
let p = alloc(100);
// ... use 100 bytes
p = realloc(p, 200);   // Resize to 200 bytes
// ... use 200 bytes
free(p);
```

**Note:** After `realloc()`, the old pointer may be invalid. Always use the returned pointer.

### Typed Allocation

Hemlock provides typed allocation helpers for convenience:

```hemlock
let arr = talloc(i32, 100);  // Allocate 100 i32 values (400 bytes)
let size = sizeof(i32);      // Returns 4 (bytes)
```

**`sizeof(type)`** returns the size in bytes of a type:
- `sizeof(i8)` / `sizeof(u8)` â†’ 1
- `sizeof(i16)` / `sizeof(u16)` â†’ 2
- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` â†’ 4
- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` â†’ 8
- `sizeof(ptr)` â†’ 8 (on 64-bit systems)

**`talloc(type, count)`** allocates `count` elements of `type`:

```hemlock
let ints = talloc(i32, 10);   // 40 bytes for 10 i32 values
let floats = talloc(f64, 5);  // 40 bytes for 5 f64 values
free(ints);
free(floats);
```

## Common Patterns

### Pattern: Allocate, Use, Free

The basic pattern for memory management:

```hemlock
// 1. Allocate
let data = alloc(1024);

// 2. Use
memset(data, 0, 1024);
// ... do work

// 3. Free
free(data);
```

### Pattern: Safe Buffer Usage

Prefer buffers for bounds-checked access:

```hemlock
let buf = buffer(256);

// Safe iteration
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

free(buf);
```

### Pattern: Resource Management with try/finally

Ensure cleanup even on errors:

```hemlock
let data = alloc(1024);
try {
    // ... risky operations
    process(data);
} finally {
    free(data);  // Always freed, even on error
}
```

## Memory Safety Considerations

### Double-Free

**Allowed but will crash:**
```hemlock
let p = alloc(100);
free(p);
free(p);  // CRASH: Double-free detected
```

**Prevention:**
```hemlock
let p = alloc(100);
free(p);
p = null;  // Set to null after freeing

if (p != null) {
    free(p);  // Won't execute
}
```

### Dangling Pointers

**Allowed but undefined behavior:**
```hemlock
let p = alloc(100);
*p = 42;      // OK
free(p);
let x = *p;   // UNDEFINED: Reading freed memory
```

**Prevention:** Don't access memory after freeing.

### Memory Leaks

**Easy to create, hard to debug:**
```hemlock
fn leak_memory() {
    let p = alloc(1000);
    // Forgot to free!
    return;  // Memory leaked
}
```

**Prevention:** Always pair `alloc()` with `free()`:
```hemlock
fn safe_function() {
    let p = alloc(1000);
    try {
        // ... use p
    } finally {
        free(p);  // Always freed
    }
}
```

### Pointer Arithmetic

**Allowed but dangerous:**
```hemlock
let p = alloc(10);
let q = p + 100;  // Way past allocation boundary
*q = 42;          // UNDEFINED: Out of bounds write
free(p);
```

**Use buffers for bounds checking:**
```hemlock
let buf = buffer(10);
buf[100] = 42;  // ERROR: Bounds check prevents overflow
```

## Best Practices

1. **Default to `buffer`** - Use `buffer` unless you specifically need raw `ptr`
2. **Match alloc/free** - Every `alloc()` should have exactly one `free()`
3. **Use try/finally** - Ensure cleanup with exception handling
4. **Null after free** - Set pointers to `null` after freeing to catch use-after-free
5. **Bounds check** - Use buffer indexing for automatic bounds checking
6. **Document ownership** - Make clear which code owns and frees each allocation

## Examples

### Example: Dynamic String Builder

```hemlock
fn build_message(count: i32): ptr {
    let size = count * 10;
    let buf = alloc(size);

    let i = 0;
    while (i < count) {
        memset(buf + (i * 10), 65 + i, 10);
        i = i + 1;
    }

    return buf;  // Caller must free
}

let msg = build_message(5);
// ... use msg
free(msg);
```

### Example: Safe Array Operations

```hemlock
fn process_array(size: i32) {
    let arr = buffer(size);

    try {
        // Fill array
        let i = 0;
        while (i < arr.length) {
            arr[i] = i * 2;
            i = i + 1;
        }

        // Process
        i = 0;
        while (i < arr.length) {
            print(arr[i]);
            i = i + 1;
        }
    } finally {
        free(arr);  // Always cleanup
    }
}
```

### Example: Memory Pool Pattern

```hemlock
// Simple memory pool (simplified)
let pool = alloc(10000);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > 10000) {
        throw "Pool exhausted";
    }

    let ptr = pool + pool_offset;
    pool_offset = pool_offset + size;
    return ptr;
}

// Use pool
let p1 = pool_alloc(100);
let p2 = pool_alloc(200);

// Free entire pool at once
free(pool);
```

## Limitations

Current limitations to be aware of:

- **Raw pointers require manual free** - `alloc()` returns `ptr` with no refcounting
- **No custom allocators** - Only system malloc/free

**Note:** Refcounted types (string, array, object, buffer) ARE automatically freed when scope exits. Only raw `ptr` from `alloc()` requires explicit `free()`.

## Related Topics

- [Strings](#language-guide-strings) - String memory management and UTF-8 encoding
- [Arrays](#language-guide-arrays) - Dynamic arrays and their memory characteristics
- [Objects](#language-guide-objects) - Object allocation and lifetime
- [Error Handling](#language-guide-error-handling) - Using try/finally for cleanup

## See Also

- **Design Philosophy**: See CLAUDE.md section "Memory Management"
- **Type System**: See [Types](#language-guide-types) for `ptr` and `buffer` type details
- **FFI**: Raw pointers are essential for Foreign Function Interface


--------------------------------------------------------------------------------
## Modules
--------------------------------------------------------------------------------

# Hemlock Module System

This document describes the ES6-style import/export module system implemented for Hemlock.

## Overview

Hemlock supports a file-based module system with ES6-style import/export syntax. Modules are:
- **Singletons**: Each module is loaded once and cached
- **File-based**: Modules correspond to .hml files on disk
- **Explicitly imported**: Dependencies are declared with import statements
- **Topologically executed**: Dependencies are executed before dependents

For package management and third-party dependencies, see [hpm (Hemlock Package Manager)](https://github.com/hemlang/hpm).

## Syntax

### Export Statements

**Inline Named Exports:**
```hemlock
export fn add(a, b) {
    return a + b;
}

export const PI = 3.14159;
export let counter = 0;
```

**Export List:**
```hemlock
fn add(a, b) { return a + b; }
fn subtract(a, b) { return a - b; }

export { add, subtract };
```

**Export Extern (FFI Functions):**
```hemlock
import "libc.so.6";

// Export FFI functions for use in other modules
export extern fn strlen(s: string): i32;
export extern fn getpid(): i32;
```

See [FFI Documentation](../advanced/ffi.md#exporting-ffi-functions) for more details on exporting FFI functions.

**Export Define (Struct Types):**
```hemlock
// Export struct type definitions
export define Vector2 {
    x: f32,
    y: f32,
}

export define Rectangle {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
}
```

**Important:** Exported struct types are registered globally when the module is loaded. They become available automatically when you import anything from the module - you do NOT need to (and cannot) explicitly import them by name:

```hemlock
// GOOD - struct types are auto-available after any import
import { some_function } from "./my_module.hml";
let v: Vector2 = { x: 1.0, y: 2.0 };  // Works!

// BAD - cannot explicitly import struct types
import { Vector2 } from "./my_module.hml";  // Error: Undefined variable 'Vector2'
```

See [FFI Documentation](../advanced/ffi.md#exporting-struct-types) for more details on exporting struct types.

**Re-exports:**
```hemlock
// Re-export from another module
export { add, subtract } from "./math.hml";
```

### Import Statements

**Named Imports:**
```hemlock
import { add, subtract } from "./math.hml";
print(add(1, 2));  // 3
```

**Namespace Import:**
```hemlock
import * as math from "./math.hml";
print(math.add(1, 2));  // 3
print(math.PI);  // 3.14159
```

**Aliasing:**
```hemlock
import { add as sum, subtract as diff } from "./math.hml";
print(sum(1, 2));  // 3
```

## Module Resolution

### Path Types

**Relative Paths:**
```hemlock
import { foo } from "./module.hml";       // Same directory
import { bar } from "../parent.hml";      // Parent directory
import { baz } from "./sub/nested.hml";   // Subdirectory
```

**Absolute Paths:**
```hemlock
import { foo } from "/absolute/path/to/module.hml";
```

**Extension Handling:**
- `.hml` extension can be omitted - it will be added automatically
- `./math` resolves to `./math.hml`

## Features

### Circular Dependency Detection

The module system detects circular dependencies and reports an error:

```
Error: Circular dependency detected when loading '/path/to/a.hml'
```

### Module Caching

Modules are loaded once and cached. Multiple imports of the same module return the same instance:

```hemlock
// counter.hml
export let count = 0;
export fn increment() {
    count = count + 1;
}

// a.hml
import { count, increment } from "./counter.hml";
increment();
print(count);  // 1

// b.hml
import { count } from "./counter.hml";  // Same instance!
print(count);  // Still 1 (shared state)
```

### Import Immutability

Imported bindings cannot be reassigned:

```hemlock
import { add } from "./math.hml";
add = fn() { };  // ERROR: cannot reassign imported binding
```

## Implementation Details

### Architecture

**Files:**
- `include/module.h` - Module system API
- `src/module.c` - Module loading, caching, and execution
- Parser support in `src/parser.c`
- Runtime support in `src/interpreter/runtime.c`

**Key Components:**
1. **ModuleCache**: Maintains loaded modules indexed by absolute path
2. **Module**: Represents a loaded module with its AST and exports
3. **Path Resolution**: Resolves relative/absolute paths to canonical paths
4. **Topological Execution**: Executes modules in dependency order

### Module Loading Process

1. **Parse Phase**: Tokenize and parse the module file
2. **Dependency Resolution**: Recursively load imported modules
3. **Cycle Detection**: Check if module is already being loaded
4. **Caching**: Store module in cache by absolute path
5. **Execution Phase**: Execute in topological order (dependencies first)

### API

```c
// High-level API
int execute_file_with_modules(const char *file_path,
                               int argc, char **argv,
                               ExecutionContext *ctx);

// Low-level API
ModuleCache* module_cache_new(const char *initial_dir);
void module_cache_free(ModuleCache *cache);
Module* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);
void execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);
```

## Testing

Test modules are located in `tests/modules/` and `tests/parity/modules/`:

- `math.hml` - Basic module with exports
- `test_import_named.hml` - Named import test
- `test_import_namespace.hml` - Namespace import test
- `test_import_alias.hml` - Import aliasing test
- `export_extern.hml` - Export extern FFI function test (Linux)

## Package Imports (hpm)

With [hpm](https://github.com/hemlang/hpm) installed, you can import third-party packages from GitHub:

```hemlock
// Import from package root (uses "main" from package.json)
import { app, router } from "hemlang/sprout";

// Import from subpath
import { middleware } from "hemlang/sprout/middleware";

// Standard library (built into Hemlock)
import { HashMap } from "@stdlib/collections";
```

Packages are installed to `hem_modules/` and resolved using GitHub `owner/repo` syntax.

```bash
# Install a package
hpm install hemlang/sprout

# Install with version constraint
hpm install hemlang/sprout@^1.0.0
```

See the [hpm documentation](https://github.com/hemlang/hpm) for full details.

## Current Limitations

1. **No Dynamic Imports**: `import()` as a runtime function is not supported
2. **No Conditional Exports**: Exports must be at top level
3. **Static Library Paths**: FFI library imports use static paths (platform-specific)

## Future Work

- Dynamic imports with `import()` function
- Conditional exports
- Module metadata (`import.meta`)
- Tree shaking and dead code elimination

## Examples

See `tests/modules/` for working examples of the module system.

Example module structure:
```
project/
â”œâ”€â”€ main.hml
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ math.hml
â”‚   â”œâ”€â”€ string.hml
â”‚   â””â”€â”€ index.hml (barrel module)
â””â”€â”€ utils/
    â””â”€â”€ helpers.hml
```

Example usage:
```hemlock
// lib/math.hml
export fn add(a, b) { return a + b; }
export fn multiply(a, b) { return a * b; }

// lib/index.hml (barrel)
export { add, multiply } from "./math.hml";

// main.hml
import { add } from "./lib/index.hml";
print(add(2, 3));  // 5
```


--------------------------------------------------------------------------------
## Objects
--------------------------------------------------------------------------------

# Objects

Hemlock implements JavaScript-style objects with heap allocation, dynamic fields, methods, and duck typing. Objects are flexible data structures that combine data and behavior.

## Overview

```hemlock
// Anonymous object
let person = { name: "Alice", age: 30, city: "NYC" };
print(person.name);  // "Alice"

// Object with methods
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    }
};

counter.increment();
print(counter.count);  // 1
```

## Object Literals

### Basic Syntax

```hemlock
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};
```

**Syntax:**
- Curly braces `{}` enclose the object
- Key-value pairs separated by commas
- Keys are identifiers (no quotes needed)
- Values can be any type

### Empty Objects

```hemlock
let obj = {};  // Empty object

// Add fields later
obj.name = "Alice";
obj.age = 30;
```

### Nested Objects

```hemlock
let user = {
    info: {
        name: "Bob",
        age: 25
    },
    active: true,
    settings: {
        theme: "dark",
        notifications: true
    }
};

print(user.info.name);           // "Bob"
print(user.settings.theme);      // "dark"
```

### Mixed Value Types

```hemlock
let mixed = {
    number: 42,
    text: "hello",
    flag: true,
    data: null,
    items: [1, 2, 3],
    config: { x: 10, y: 20 }
};
```

### Shorthand Property Syntax

When a variable name matches the property name, use shorthand syntax:

```hemlock
let name = "Alice";
let age = 30;
let active = true;

// Shorthand: { name } is equivalent to { name: name }
let person = { name, age, active };

print(person.name);   // "Alice"
print(person.age);    // 30
print(person.active); // true
```

**Mix shorthand with regular properties:**
```hemlock
let city = "NYC";
let obj = { name, age, city, role: "admin" };
```

### Spread Operator

The spread operator (`...`) copies all fields from one object into another:

```hemlock
let base = { x: 1, y: 2 };
let extended = { ...base, z: 3 };

print(extended.x);  // 1
print(extended.y);  // 2
print(extended.z);  // 3
```

**Override values with spread:**
```hemlock
let defaults = { theme: "light", size: "medium", debug: false };
let custom = { ...defaults, theme: "dark" };

print(custom.theme);  // "dark" (overridden)
print(custom.size);   // "medium" (from defaults)
print(custom.debug);  // false (from defaults)
```

**Multiple spreads (later spreads override earlier):**
```hemlock
let a = { x: 1 };
let b = { y: 2 };
let merged = { ...a, ...b, z: 3 };

print(merged.x);  // 1
print(merged.y);  // 2
print(merged.z);  // 3

// Later spread overrides earlier
let first = { val: "first" };
let second = { val: "second" };
let combined = { ...first, ...second };
print(combined.val);  // "second"
```

**Combine shorthand and spread:**
```hemlock
let status = "active";
let data = { id: 1, name: "Item" };
let full = { ...data, status };

print(full.id);      // 1
print(full.name);    // "Item"
print(full.status);  // "active"
```

**Configuration override pattern:**
```hemlock
let defaultConfig = {
    debug: false,
    timeout: 30,
    retries: 3
};

let prodConfig = { ...defaultConfig, timeout: 60 };
let devConfig = { ...defaultConfig, debug: true };

print(prodConfig.timeout);  // 60
print(devConfig.debug);     // true
```

**Note:** Spread performs a shallow copy. Nested objects share references:
```hemlock
let nested = { inner: { val: 42 } };
let copied = { ...nested };
print(copied.inner.val);  // 42 (same reference as nested.inner)
```

## Field Access

### Dot Notation

```hemlock
let person = { name: "Alice", age: 30 };

// Read field
let name = person.name;      // "Alice"
let age = person.age;        // 30

// Modify field
person.age = 31;
print(person.age);           // 31
```

### Dynamic Field Addition

Add new fields at runtime:

```hemlock
let person = { name: "Alice" };

// Add new field
person.email = "alice@example.com";
person.phone = "555-1234";

print(person.email);  // "alice@example.com"
```

### Field Deletion

**Note:** Field deletion is not currently supported. Set to `null` instead:

```hemlock
let obj = { x: 10, y: 20 };

// Cannot delete fields (not supported)
// obj.x = undefined;  // No 'undefined' in Hemlock

// Workaround: Set to null
obj.x = null;
```

## Methods and `self`

### Defining Methods

Methods are functions stored in object fields:

```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    },
    decrement: fn() {
        self.count = self.count - 1;
    },
    get: fn() {
        return self.count;
    }
};
```

### The `self` Keyword

When a function is called as a method, `self` is automatically bound to the object:

```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;  // self refers to counter
    }
};

counter.increment();  // self is bound to counter
print(counter.count);  // 1
```

**How it works:**
- Method calls are detected by checking if function expression is property access
- `self` is automatically bound to the object at call time
- `self` is read-only (cannot reassign `self` itself)

### Method Call Detection

```hemlock
let obj = {
    value: 10,
    method: fn() {
        return self.value;
    }
};

// Called as method - self is bound
print(obj.method());  // 10

// Called as function - self is null (error)
let f = obj.method;
print(f());  // ERROR: self is not defined
```

### Methods with Parameters

```hemlock
let calculator = {
    result: 0,
    add: fn(x) {
        self.result = self.result + x;
    },
    multiply: fn(x) {
        self.result = self.result * x;
    },
    get: fn() {
        return self.result;
    }
};

calculator.add(5);
calculator.multiply(2);
print(calculator.get());  // 10
```

## Type Definitions with `define`

### Basic Type Definition

Define object shapes with `define`:

```hemlock
define Person {
    name: string,
    age: i32,
    active: bool,
}

// Create object and assign to typed variable
let p = { name: "Alice", age: 30, active: true };
let typed_p: Person = p;  // Duck typing validates structure

print(typeof(typed_p));  // "Person"
```

**What `define` does:**
- Declares a type with required fields
- Enables duck typing validation
- Sets the object's type name for `typeof()`

### Duck Typing

Objects are validated against `define` using **structural compatibility**:

```hemlock
define Person {
    name: string,
    age: i32,
}

// âœ… OK: Has all required fields
let p1: Person = { name: "Alice", age: 30 };

// âœ… OK: Extra fields are allowed
let p2: Person = {
    name: "Bob",
    age: 25,
    city: "NYC",
    active: true
};

// âŒ ERROR: Missing required field 'age'
let p3: Person = { name: "Carol" };

// âŒ ERROR: Wrong type for 'age'
let p4: Person = { name: "Dave", age: "thirty" };
```

**Duck typing rules:**
- All required fields must be present
- Field types must match
- Extra fields are allowed and preserved
- Validation happens at assignment time

### Optional Fields

Fields can be optional with default values:

```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,       // Optional with default value
    nickname?: string,   // Optional, defaults to null
}

// Object with only required fields
let p = { name: "Alice", age: 30 };
let typed_p: Person = p;

print(typed_p.active);    // true (default applied)
print(typed_p.nickname);  // null (no default)

// Can override optional fields
let p2: Person = { name: "Bob", age: 25, active: false };
print(p2.active);  // false (overridden)
```

**Optional field syntax:**
- `field?: default_value` - Optional with default
- `field?: type` - Optional with type annotation, defaults to null
- Optional fields are added during duck typing if missing

### Type Checking

```hemlock
define Point {
    x: i32,
    y: i32,
}

let p = { x: 10, y: 20 };
let point: Point = p;  // Type checking happens here

print(typeof(point));  // "Point"
print(typeof(p));      // "object" (original is still anonymous)
```

**When type checking happens:**
- At assignment time to typed variable
- Validates all required fields are present
- Validates field types match (with implicit conversions)
- Sets the object's type name

## Method Signatures in Define

Define blocks can specify method signatures, creating interface-like contracts:

### Required Methods

```hemlock
define Comparable {
    value: i32,
    fn compare(other: Self): i32;  // Required method signature
}

// Objects must provide the required method
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};
```

### Optional Methods

```hemlock
define Serializable {
    fn serialize(): string;       // Required
    fn pretty?(): string;         // Optional method (may be absent)
}
```

### The `Self` Type

`Self` refers to the type being defined, enabling recursive type definitions:

```hemlock
define Cloneable {
    fn clone(): Self;  // Returns same type as the object
}

define Comparable {
    fn compare(other: Self): i32;  // Takes same type as parameter
    fn equals(other: Self): bool;
}

let item: Cloneable = {
    value: 42,
    clone: fn() {
        return { value: self.value, clone: self.clone };
    }
};
```

### Mixed Fields and Methods

```hemlock
define Entity {
    id: i32,
    name: string,
    fn validate(): bool;
    fn serialize(): string;
}

let user: Entity = {
    id: 1,
    name: "Alice",
    validate: fn() { return self.id > 0 && self.name != ""; },
    serialize: fn() { return '{"id":' + self.id + ',"name":"' + self.name + '"}'; }
};
```

## Compound Types (Intersection Types)

Compound types use `&` to require an object to satisfy multiple type definitions:

### Basic Compound Types

```hemlock
define HasName { name: string }
define HasAge { age: i32 }

// Compound type: object must satisfy ALL types
let person: HasName & HasAge = { name: "Alice", age: 30 };
```

### Function Parameters with Compound Types

```hemlock
fn greet(p: HasName & HasAge) {
    print(p.name + " is " + p.age);
}

greet({ name: "Bob", age: 25, city: "NYC" });  // Extra fields OK
```

### Three or More Types

```hemlock
define HasEmail { email: string }

fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}
```

### Type Aliases for Compound Types

```hemlock
// Create a named alias for a compound type
type Person = HasName & HasAge;
type Employee = HasName & HasAge & HasEmail;

let emp: Employee = {
    name: "Charlie",
    age: 35,
    email: "charlie@example.com"
};
```

**Duck typing with compounds:** Extra fields are always allowed - the object just needs to have at least the fields required by all component types.

## JSON Serialization

### Serialize to JSON

Convert objects to JSON strings:

```hemlock
// obj.serialize() - Convert object to JSON string
let obj = { x: 10, y: 20, name: "test" };
let json = obj.serialize();
print(json);  // {"x":10,"y":20,"name":"test"}

// Nested objects
let nested = { inner: { a: 1, b: 2 }, outer: 3 };
print(nested.serialize());  // {"inner":{"a":1,"b":2},"outer":3}
```

### Deserialize from JSON

Parse JSON strings back to objects:

```hemlock
// json.deserialize() - Parse JSON string to object
let json_str = '{"x":10,"y":20,"name":"test"}';
let obj = json_str.deserialize();

print(obj.name);   // "test"
print(obj.x);      // 10
```

### Cycle Detection

Circular references are detected and cause errors:

```hemlock
let obj = { x: 10 };
obj.me = obj;  // Create circular reference

obj.serialize();  // ERROR: serialize() detected circular reference
```

### Supported Types

JSON serialization supports:

- **Numbers**: i8-i32, u8-u32, f32, f64
- **Booleans**: true, false
- **Strings**: With escape sequences
- **Null**: null value
- **Objects**: Nested objects
- **Arrays**: Nested arrays

**Not supported:**
- Functions (silently omitted)
- Pointers (error)
- Buffers (error)

### Error Handling

Serialization and deserialization can throw errors:

```hemlock
// Invalid JSON throws an error
try {
    let bad = "not valid json".deserialize();
} catch (e) {
    print("Parse error:", e);
}

// Pointers cannot be serialized
let obj = { ptr: alloc(10) };
try {
    obj.serialize();
} catch (e) {
    print("Serialize error:", e);
}
```

### Round-Trip Example

Complete example of serializing and deserializing:

```hemlock
define Config {
    host: string,
    port: i32,
    debug: bool
}

// Create and serialize
let config: Config = {
    host: "localhost",
    port: 8080,
    debug: true
};
let json = config.serialize();
print(json);  // {"host":"localhost","port":8080,"debug":true}

// Deserialize back
let restored = json.deserialize();
print(restored.host);  // "localhost"
print(restored.port);  // 8080
```

## Built-in Functions

### `typeof(value)`

Returns the type name as a string:

```hemlock
let obj = { x: 10 };
print(typeof(obj));  // "object"

define Person { name: string, age: i32 }
let p: Person = { name: "Alice", age: 30 };
print(typeof(p));    // "Person"
```

**Return values:**
- Anonymous objects: `"object"`
- Typed objects: Custom type name (e.g., `"Person"`)

## Implementation Details

### Memory Model

- **Heap-allocated** - All objects are allocated on the heap
- **Shallow copy** - Assignment copies the reference, not the object
- **Dynamic fields** - Stored as dynamic arrays of name/value pairs
- **Refcounted** - Objects are automatically freed when scope exits

### Reference Semantics

```hemlock
let obj1 = { x: 10 };
let obj2 = obj1;  // Shallow copy (same reference)

obj2.x = 20;
print(obj1.x);  // 20 (both refer to same object)
```

### Method Storage

Methods are just functions stored in fields:

```hemlock
let obj = {
    value: 10,
    method: fn() { return self.value; }
};

// method is a function stored in obj.method
print(typeof(obj.method));  // "function"
```

## Common Patterns

### Pattern: Constructor Function

```hemlock
fn createPerson(name: string, age: i32) {
    return {
        name: name,
        age: age,
        greet: fn() {
            return "Hi, I'm " + self.name;
        }
    };
}

let person = createPerson("Alice", 30);
print(person.greet());  // "Hi, I'm Alice"
```

### Pattern: Object Builder

```hemlock
fn PersonBuilder() {
    return {
        name: null,
        age: null,

        setName: fn(n) {
            self.name = n;
            return self;  // Enable chaining
        },

        setAge: fn(a) {
            self.age = a;
            return self;
        },

        build: fn() {
            return { name: self.name, age: self.age };
        }
    };
}

let person = PersonBuilder()
    .setName("Alice")
    .setAge(30)
    .build();
```

### Pattern: State Object

```hemlock
let state = {
    status: "idle",
    data: null,
    error: null,

    setState: fn(new_status) {
        self.status = new_status;
    },

    setData: fn(new_data) {
        self.data = new_data;
        self.status = "success";
    },

    setError: fn(err) {
        self.error = err;
        self.status = "error";
    }
};
```

### Pattern: Configuration Object

```hemlock
let config = {
    defaults: {
        timeout: 30,
        retries: 3,
        debug: false
    },

    get: fn(key) {
        if (self.defaults[key] != null) {
            return self.defaults[key];
        }
        return null;
    },

    set: fn(key, value) {
        self.defaults[key] = value;
    }
};
```

## Best Practices

1. **Use `define` for structure** - Document expected object shapes
2. **Prefer factory functions** - Create objects with constructors
3. **Keep objects simple** - Don't nest too deeply
4. **Document `self` usage** - Make method behavior clear
5. **Validate on assignment** - Use duck typing to catch errors early
6. **Avoid circular references** - Will cause serialization errors
7. **Use optional fields** - Provide sensible defaults

## Common Pitfalls

### Pitfall: Reference vs. Value

```hemlock
let obj1 = { x: 10 };
let obj2 = obj1;  // Shallow copy

obj2.x = 20;
print(obj1.x);  // 20 (surprise! both changed)

// To avoid: Create new object
let obj3 = { x: obj1.x };  // Deep copy (manual)
```

### Pitfall: `self` in Non-Method Calls

```hemlock
let obj = {
    value: 10,
    method: fn() { return self.value; }
};

// Works: Called as method
print(obj.method());  // 10

// ERROR: Called as function
let f = obj.method;
print(f());  // ERROR: self is not defined
```

### Pitfall: Raw Pointers in Objects

```hemlock
// Objects are auto-freed, but raw pointers inside are NOT
fn create_objects() {
    let obj = { data: alloc(1000) };  // raw ptr needs manual free
    // obj is auto-freed when scope exits, but obj.data leaks!
}

// Solution: Free raw pointers before scope exits
fn safe_create() {
    let obj = { data: alloc(1000) };
    // ... use obj.data ...
    free(obj.data);  // Free the raw pointer explicitly
}  // obj itself is auto-freed
```

### Pitfall: Type Confusion

```hemlock
let obj = { x: 10 };

define Point { x: i32, y: i32 }

// ERROR: Missing required field 'y'
let p: Point = obj;
```

## Examples

### Example: Vector Math

```hemlock
fn createVector(x, y) {
    return {
        x: x,
        y: y,

        add: fn(other) {
            return createVector(
                self.x + other.x,
                self.y + other.y
            );
        },

        length: fn() {
            return sqrt(self.x * self.x + self.y * self.y);
        },

        toString: fn() {
            return "(" + typeof(self.x) + ", " + typeof(self.y) + ")";
        }
    };
}

let v1 = createVector(3, 4);
let v2 = createVector(1, 2);
let v3 = v1.add(v2);

print(v3.toString());  // "(4, 6)"
```

### Example: Simple Database

```hemlock
fn createDatabase() {
    let records = [];
    let next_id = 1;

    return {
        insert: fn(data) {
            let record = { id: next_id, data: data };
            records.push(record);
            next_id = next_id + 1;
            return record.id;
        },

        find: fn(id) {
            let i = 0;
            while (i < records.length) {
                if (records[i].id == id) {
                    return records[i];
                }
                i = i + 1;
            }
            return null;
        },

        count: fn() {
            return records.length;
        }
    };
}

let db = createDatabase();
let id = db.insert({ name: "Alice", age: 30 });
let record = db.find(id);
print(record.data.name);  // "Alice"
```

### Example: Event Emitter

```hemlock
fn createEventEmitter() {
    let listeners = {};

    return {
        on: fn(event, handler) {
            if (listeners[event] == null) {
                listeners[event] = [];
            }
            listeners[event].push(handler);
        },

        emit: fn(event, data) {
            if (listeners[event] != null) {
                let i = 0;
                while (i < listeners[event].length) {
                    listeners[event][i](data);
                    i = i + 1;
                }
            }
        }
    };
}

let emitter = createEventEmitter();

emitter.on("message", fn(data) {
    print("Received: " + data);
});

emitter.emit("message", "Hello!");
```

## Limitations

Current limitations:

- **No deep copy** - Must manually copy nested objects (spread is shallow)
- **No pass-by-value** - Objects always passed by reference
- **No computed properties** - No `{[key]: value}` syntax
- **`self` is read-only** - Cannot reassign `self` in methods
- **No property deletion** - Cannot remove fields once added

**Note:** Objects are refcounted and automatically freed when scope exits. See [Memory Management](memory.md#internal-reference-counting) for details.

## Related Topics

- [Functions](#language-guide-functions) - Methods are functions stored in objects
- [Arrays](#language-guide-arrays) - Arrays are also object-like
- [Types](#language-guide-types) - Duck typing and type definitions
- [Error Handling](#language-guide-error-handling) - Throwing error objects

## See Also

- **Duck Typing**: See CLAUDE.md section "Objects" for duck typing details
- **JSON**: See CLAUDE.md for JSON serialization details
- **Memory**: See [Memory](#language-guide-memory) for object allocation


--------------------------------------------------------------------------------
## Pattern Matching
--------------------------------------------------------------------------------

# Pattern Matching

Hemlock provides powerful pattern matching through `match` expressions, offering a concise way to destructure values, check types, and handle multiple cases.

## Basic Syntax

```hemlock
let result = match (value) {
    pattern1 => expression1,
    pattern2 => expression2,
    _ => default_expression
};
```

Match expressions evaluate `value` against each pattern in order, returning the result of the first matching arm's expression.

## Pattern Types

### Literal Patterns

Match against exact values:

```hemlock
let x = 42;
let msg = match (x) {
    0 => "zero",
    1 => "one",
    42 => "the answer",
    _ => "other"
};
print(msg);  // "the answer"
```

Supported literals:
- **Integers**: `0`, `42`, `-5`
- **Floats**: `3.14`, `-0.5`
- **Strings**: `"hello"`, `"world"`
- **Booleans**: `true`, `false`
- **Null**: `null`

### Wildcard Pattern (`_`)

Matches any value without binding:

```hemlock
let x = "anything";
let result = match (x) {
    "specific" => "found it",
    _ => "wildcard matched"
};
```

### Variable Binding Patterns

Bind the matched value to a variable:

```hemlock
let x = 100;
let result = match (x) {
    0 => "zero",
    n => "value is " + n  // n binds to 100
};
print(result);  // "value is 100"
```

### OR Patterns (`|`)

Match multiple alternatives:

```hemlock
let x = 2;
let size = match (x) {
    1 | 2 | 3 => "small",
    4 | 5 | 6 => "medium",
    _ => "large"
};

// Works with strings too
let cmd = "quit";
let action = match (cmd) {
    "exit" | "quit" | "q" => "exiting",
    "help" | "h" | "?" => "showing help",
    _ => "unknown"
};
```

### Guard Expressions (`if`)

Add conditions to patterns:

```hemlock
let x = 15;
let category = match (x) {
    n if n < 0 => "negative",
    n if n == 0 => "zero",
    n if n < 10 => "small",
    n if n < 100 => "medium",
    n => "large: " + n
};
print(category);  // "medium"

// Complex guards
let y = 12;
let result = match (y) {
    n if n % 2 == 0 && n > 10 => "even and greater than 10",
    n if n % 2 == 0 => "even",
    n => "odd"
};
```

### Type Patterns

Check and bind based on type:

```hemlock
let val = 42;
let desc = match (val) {
    num: i32 => "integer: " + num,
    str: string => "string: " + str,
    flag: bool => "boolean: " + flag,
    _ => "other type"
};
print(desc);  // "integer: 42"
```

Supported types: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`, `bool`, `string`, `array`, `object`

## Destructuring Patterns

### Object Destructuring

Extract fields from objects:

```hemlock
let point = { x: 10, y: 20 };
let result = match (point) {
    { x, y } => "point at " + x + "," + y
};
print(result);  // "point at 10,20"

// With literal field values
let origin = { x: 0, y: 0 };
let name = match (origin) {
    { x: 0, y: 0 } => "origin",
    { x: 0, y } => "on y-axis at " + y,
    { x, y: 0 } => "on x-axis at " + x,
    { x, y } => "point at " + x + "," + y
};
print(name);  // "origin"
```

### Array Destructuring

Match array structure and elements:

```hemlock
let arr = [1, 2, 3];
let desc = match (arr) {
    [] => "empty",
    [x] => "single: " + x,
    [x, y] => "pair: " + x + "," + y,
    [x, y, z] => "triple: " + x + "," + y + "," + z,
    _ => "many elements"
};
print(desc);  // "triple: 1,2,3"

// With literal values
let pair = [1, 2];
let result = match (pair) {
    [0, 0] => "both zero",
    [1, x] => "starts with 1, second is " + x,
    [x, 1] => "ends with 1",
    _ => "other"
};
print(result);  // "starts with 1, second is 2"
```

### Array Rest Patterns (`...`)

Capture remaining elements:

```hemlock
let nums = [1, 2, 3, 4, 5];

// Head and tail
let result = match (nums) {
    [first, ...rest] => "first: " + first,
    [] => "empty"
};
print(result);  // "first: 1"

// First two elements
let result2 = match (nums) {
    [a, b, ...rest] => "first two: " + a + "," + b,
    _ => "too short"
};
print(result2);  // "first two: 1,2"
```

### Nested Destructuring

Combine patterns for complex data:

```hemlock
let user = {
    name: "Alice",
    address: { city: "NYC", zip: 10001 }
};

let result = match (user) {
    { name, address: { city, zip } } => name + " lives in " + city,
    _ => "unknown"
};
print(result);  // "Alice lives in NYC"

// Object containing array
let data = { items: [1, 2, 3], count: 3 };
let result2 = match (data) {
    { items: [first, ...rest], count } => "first: " + first + ", total: " + count,
    _ => "no items"
};
print(result2);  // "first: 1, total: 3"
```

## Match as Expression

Match is an expression that returns a value:

```hemlock
// Direct assignment
let grade = 85;
let letter = match (grade) {
    n if n >= 90 => "A",
    n if n >= 80 => "B",
    n if n >= 70 => "C",
    n if n >= 60 => "D",
    _ => "F"
};

// In string concatenation
let msg = "Grade: " + match (grade) {
    n if n >= 70 => "passing",
    _ => "failing"
};

// In function return
fn classify(n: i32): string {
    return match (n) {
        0 => "zero",
        n if n > 0 => "positive",
        _ => "negative"
    };
}
```

## Pattern Matching Best Practices

1. **Order matters**: Patterns are checked top-to-bottom; put specific patterns before general ones
2. **Use wildcards for exhaustiveness**: Always include a `_` fallback unless you're certain all cases are covered
3. **Prefer guards over nested conditions**: Guards make intent clearer
4. **Use destructuring over manual field access**: More concise and safer

```hemlock
// Good: Guards for range checking
match (score) {
    n if n >= 90 => "A",
    n if n >= 80 => "B",
    _ => "below B"
}

// Good: Destructure instead of accessing fields
match (point) {
    { x: 0, y: 0 } => "origin",
    { x, y } => "at " + x + "," + y
}

// Avoid: Overly complex nested patterns
// Instead, consider breaking into multiple matches or using guards
```

## Comparison with Other Languages

| Feature | Hemlock | Rust | JavaScript |
|---------|---------|------|------------|
| Basic matching | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |
| Destructuring | Yes | Yes | Partial (switch doesn't destructure) |
| Guards | `n if n > 0 =>` | `n if n > 0 =>` | N/A |
| OR patterns | `1 \| 2 \| 3 =>` | `1 \| 2 \| 3 =>` | `case 1: case 2: case 3:` |
| Rest patterns | `[a, ...rest]` | `[a, rest @ ..]` | N/A |
| Type patterns | `n: i32` | Type via `match` arm | N/A |
| Returns value | Yes | Yes | No (statement) |

## Implementation Notes

Pattern matching is implemented in both the interpreter and compiler backends with full parity - both produce identical results for the same input. The feature is available in Hemlock v1.8.0+.


--------------------------------------------------------------------------------
## Runes
--------------------------------------------------------------------------------

# Runes

Runes represent **Unicode codepoints** (U+0000 to U+10FFFF) as a distinct type for character manipulation in Hemlock. Unlike bytes (u8), runes are full Unicode characters that can represent any character in any language or emoji.

## Overview

```hemlock
let ch = 'A';           // Rune literal
let emoji = 'ðŸš€';       // Multi-byte character as single rune
print(ch);              // 'A'
print(emoji);           // U+1F680

let s = "Hello " + '!'; // String + rune concatenation
let r = '>' + " msg";   // Rune + string concatenation
```

## What is a Rune?

A rune is a **32-bit value** representing a Unicode codepoint:

- **Range:** 0 to 0x10FFFF (1,114,111 valid codepoints)
- **Not a numeric type** - Used for character representation
- **Distinct from u8/char** - Runes are full Unicode, u8 is just bytes
- **Returned by string indexing** - `str[0]` returns a rune, not a byte

**Why runes?**
- Hemlock strings are UTF-8 encoded
- A single Unicode character can be 1-4 bytes in UTF-8
- Runes allow working with complete characters, not partial bytes

## Rune Literals

### Basic Syntax

Single quotes denote rune literals:

```hemlock
let a = 'A';            // ASCII character
let b = '0';            // Digit character
let c = '!';            // Punctuation
let d = ' ';            // Space
```

### Multi-byte UTF-8 Characters

Runes can represent any Unicode character:

```hemlock
// Emoji
let rocket = 'ðŸš€';      // Emoji (U+1F680)
let heart = 'â¤';        // Heart (U+2764)
let smile = 'ðŸ˜€';       // Grinning face (U+1F600)

// CJK characters
let chinese = 'ä¸­';     // Chinese (U+4E2D)
let japanese = 'ã‚';    // Hiragana (U+3042)
let korean = 'í•œ';      // Hangul (U+D55C)

// Symbols
let check = 'âœ“';        // Checkmark (U+2713)
let arrow = 'â†’';        // Rightwards arrow (U+2192)
```

### Escape Sequences

Common escape sequences for special characters:

```hemlock
let newline = '\n';     // Newline (U+000A)
let tab = '\t';         // Tab (U+0009)
let backslash = '\\';   // Backslash (U+005C)
let quote = '\'';       // Single quote (U+0027)
let dquote = '"';       // Double quote (U+0022)
let null_char = '\0';   // Null character (U+0000)
let cr = '\r';          // Carriage return (U+000D)
```

**Available escape sequences:**
- `\n` - Newline (line feed)
- `\t` - Horizontal tab
- `\r` - Carriage return
- `\0` - Null character
- `\\` - Backslash
- `\'` - Single quote
- `\"` - Double quote

### Unicode Escapes

Use `\u{XXXXXX}` syntax for Unicode codepoints (up to 6 hex digits):

```hemlock
let rocket = '\u{1F680}';   // ðŸš€ Emoji via Unicode escape
let heart = '\u{2764}';     // â¤ Heart
let ascii = '\u{41}';       // 'A' via escape
let max = '\u{10FFFF}';     // Maximum Unicode codepoint

// Leading zeros optional
let a = '\u{41}';           // Same as '\u{0041}'
let b = '\u{0041}';
```

**Rules:**
- Range: `\u{0}` to `\u{10FFFF}`
- Hex digits: 1 to 6 digits
- Case insensitive: `\u{1F680}` or `\u{1f680}`
- Values outside valid Unicode range cause error

## String + Rune Concatenation

Runes can be concatenated with strings:

```hemlock
// String + rune
let greeting = "Hello" + '!';       // "Hello!"
let decorated = "Text" + 'âœ“';       // "Textâœ“"

// Rune + string
let prefix = '>' + " Message";      // "> Message"
let bullet = 'â€¢' + " Item";         // "â€¢ Item"

// Multiple concatenations
let msg = "Hi " + 'ðŸ‘‹' + " World " + 'ðŸŒ';  // "Hi ðŸ‘‹ World ðŸŒ"

// Method chaining works
let result = ('>' + " Important").to_upper();  // "> IMPORTANT"
```

**How it works:**
- Runes are automatically encoded to UTF-8
- Converted to strings during concatenation
- The string concatenation operator handles this transparently

## Type Conversions

Runes can convert to/from other types.

### Integer â†” Rune

Convert between integers and runes to work with codepoint values:

```hemlock
// Integer to rune (codepoint value)
let code: rune = 65;            // 'A' (ASCII 65)
let emoji_code: rune = 128640;  // U+1F680 (ðŸš€)

// Rune to integer (get codepoint value)
let r = 'Z';
let value: i32 = r;             // 90 (ASCII value)

let rocket = 'ðŸš€';
let code: i32 = rocket;         // 128640 (U+1F680)
```

**Range checking:**
- Integer to rune: Must be in [0, 0x10FFFF]
- Out of range values cause runtime error
- Rune to integer: Always succeeds (returns codepoint)

### Rune â†’ String

Runes can be explicitly converted to strings:

```hemlock
// Explicit conversion
let ch: string = 'H';           // "H"
let emoji: string = 'ðŸš€';       // "ðŸš€"

// Automatic during concatenation
let s = "" + 'A';               // "A"
let s2 = "x" + 'y' + "z";       // "xyz"
```

### u8 (Byte) â†’ Rune

Any u8 value (0-255) can convert to rune:

```hemlock
// ASCII range (0-127)
let byte: u8 = 65;
let rune_val: rune = byte;      // 'A'

// Extended ASCII / Latin-1 (128-255)
let extended: u8 = 200;
let r: rune = extended;         // U+00C8 (Ãˆ)

// Note: Values 0-127 are ASCII, 128-255 are Latin-1
```

### Chained Conversions

Type conversions can be chained:

```hemlock
// i32 â†’ rune â†’ string
let code: i32 = 128512;         // Grinning face codepoint
let r: rune = code;             // ðŸ˜€
let s: string = r;              // "ðŸ˜€"

// All in one expression
let emoji: string = 128640;     // Implicit i32 â†’ rune â†’ string (ðŸš€)
```

## Rune Operations

### Printing

How runes are displayed depends on the codepoint:

```hemlock
let ascii = 'A';
print(ascii);                   // 'A' (quoted, printable ASCII)

let emoji = 'ðŸš€';
print(emoji);                   // U+1F680 (Unicode notation for non-ASCII)

let tab = '\t';
print(tab);                     // U+0009 (non-printable as hex)

let space = ' ';
print(space);                   // ' ' (printable)
```

**Print format:**
- Printable ASCII (32-126): Quoted character `'A'`
- Non-printable or Unicode: Hex notation `U+XXXX`

### Type Checking

Use `typeof()` to check if a value is a rune:

```hemlock
let r = 'ðŸš€';
print(typeof(r));               // "rune"

let s = "text";
let ch = s[0];
print(typeof(ch));              // "rune" (indexing returns runes)

let num = 65;
print(typeof(num));             // "i32"
```

### Comparison

Runes can be compared for equality:

```hemlock
let a = 'A';
let b = 'B';
print(a == a);                  // true
print(a == b);                  // false

// Case sensitive
let upper = 'A';
let lower = 'a';
print(upper == lower);          // false

// Runes can be compared with integers (codepoint values)
print(a == 65);                 // true (implicit conversion)
print('ðŸš€' == 128640);          // true
```

**Comparison operators:**
- `==` - Equal
- `!=` - Not equal
- `<`, `>`, `<=`, `>=` - Codepoint order

```hemlock
print('A' < 'B');               // true (65 < 66)
print('a' > 'Z');               // true (97 > 90)
```

## Working with String Indexing

String indexing returns runes, not bytes:

```hemlock
let s = "HelloðŸš€";
let h = s[0];                   // 'H' (rune)
let rocket = s[5];              // 'ðŸš€' (rune)

print(typeof(h));               // "rune"
print(typeof(rocket));          // "rune"

// Convert to string if needed
let h_str: string = h;          // "H"
let rocket_str: string = rocket; // "ðŸš€"
```

**Important:** String indexing uses codepoint positions, not byte offsets:

```hemlock
let text = "HiðŸš€!";
// Codepoint positions: 0='H', 1='i', 2='ðŸš€', 3='!'
// Byte positions:      0='H', 1='i', 2-5='ðŸš€', 6='!'

let r = text[2];                // 'ðŸš€' (codepoint 2)
print(typeof(r));               // "rune"
```

## Examples

### Example: Character Classification

```hemlock
fn is_digit(r: rune): bool {
    return r >= '0' && r <= '9';
}

fn is_upper(r: rune): bool {
    return r >= 'A' && r <= 'Z';
}

fn is_lower(r: rune): bool {
    return r >= 'a' && r <= 'z';
}

print(is_digit('5'));           // true
print(is_upper('A'));           // true
print(is_lower('z'));           // true
```

### Example: Case Conversion

```hemlock
fn to_upper_rune(r: rune): rune {
    if (r >= 'a' && r <= 'z') {
        // Convert to uppercase (subtract 32)
        let code: i32 = r;
        code = code - 32;
        return code;
    }
    return r;
}

fn to_lower_rune(r: rune): rune {
    if (r >= 'A' && r <= 'Z') {
        // Convert to lowercase (add 32)
        let code: i32 = r;
        code = code + 32;
        return code;
    }
    return r;
}

print(to_upper_rune('a'));      // 'A'
print(to_lower_rune('Z'));      // 'z'
```

### Example: Character Iteration

```hemlock
fn print_chars(s: string) {
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        print("Position " + typeof(i) + ": " + typeof(ch));
        i = i + 1;
    }
}

print_chars("HiðŸš€");
// Position 0: 'H'
// Position 1: 'i'
// Position 2: U+1F680
```

### Example: Building Strings from Runes

```hemlock
fn repeat_char(ch: rune, count: i32): string {
    let result = "";
    let i = 0;
    while (i < count) {
        result = result + ch;
        i = i + 1;
    }
    return result;
}

let line = repeat_char('=', 40);  // "========================================"
let stars = repeat_char('â­', 5);  // "â­â­â­â­â­"
```

## Common Patterns

### Pattern: Character Filter

```hemlock
fn filter_digits(s: string): string {
    let result = "";
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        if (ch >= '0' && ch <= '9') {
            result = result + ch;
        }
        i = i + 1;
    }
    return result;
}

let text = "abc123def456";
let digits = filter_digits(text);  // "123456"
```

### Pattern: Character Counting

```hemlock
fn count_char(s: string, target: rune): i32 {
    let count = 0;
    let i = 0;
    while (i < s.length) {
        if (s[i] == target) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

let text = "hello world";
let l_count = count_char(text, 'l');  // 3
let o_count = count_char(text, 'o');  // 2
```

## Best Practices

1. **Use runes for character operations** - Don't try to work with bytes for text
2. **String indexing returns runes** - Remember that `str[i]` gives you a rune
3. **Unicode-aware comparisons** - Runes handle any Unicode character
4. **Convert when needed** - Runes convert easily to strings and integers
5. **Test with emoji** - Always test character operations with multi-byte characters

## Common Pitfalls

### Pitfall: Rune vs. Byte Confusion

```hemlock
// DON'T: Treat runes as bytes
let r: rune = 'ðŸš€';
let b: u8 = r;              // ERROR: Rune codepoint 128640 doesn't fit in u8

// DO: Use appropriate conversions
let r: rune = 'ðŸš€';
let code: i32 = r;          // OK: 128640
```

### Pitfall: String Byte Indexing

```hemlock
// DON'T: Assume byte indexing
let s = "ðŸš€";
let byte = s.byte_at(0);    // 240 (first UTF-8 byte, not complete char)

// DO: Use codepoint indexing
let s = "ðŸš€";
let rune = s[0];            // 'ðŸš€' (complete character)
let rune2 = s.char_at(0);   // 'ðŸš€' (explicit method)
```

## Related Topics

- [Strings](#language-guide-strings) - String operations and UTF-8 handling
- [Types](#language-guide-types) - Type system and conversions
- [Control Flow](#language-guide-control-flow) - Using runes in comparisons

## See Also

- **Unicode Standard**: Unicode codepoints are defined by the Unicode Consortium
- **UTF-8 Encoding**: See [Strings](#language-guide-strings) for UTF-8 details
- **Type Conversions**: See [Types](#language-guide-types) for conversion rules


--------------------------------------------------------------------------------
## Strings
--------------------------------------------------------------------------------

# Strings

Hemlock strings are **UTF-8 first-class mutable sequences** with full Unicode support and a rich set of methods for text processing. Unlike many languages, Hemlock strings are mutable and work natively with Unicode codepoints.

## Overview

```hemlock
let s = "hello";
s[0] = 'H';             // mutate with rune (now "Hello")
print(s.length);        // 5 (codepoint count)
let c = s[0];           // returns rune (Unicode codepoint)
let msg = s + " world"; // concatenation
let emoji = "ðŸš€";
print(emoji.length);    // 1 (one codepoint)
print(emoji.byte_length); // 4 (four UTF-8 bytes)
```

## Properties

Hemlock strings have these key characteristics:

- **UTF-8 encoded** - Full Unicode support (U+0000 to U+10FFFF)
- **Mutable** - Unlike Python, JavaScript, and Java strings
- **Codepoint-based indexing** - Returns `rune` (Unicode codepoint), not byte
- **Heap-allocated** - With internal capacity tracking
- **Two length properties**:
  - `.length` - Codepoint count (number of characters)
  - `.byte_length` - Byte count (UTF-8 encoding size)

## UTF-8 Behavior

All string operations work with **codepoints** (characters), not bytes:

```hemlock
let text = "HelloðŸš€World";
print(text.length);        // 11 (codepoints)
print(text.byte_length);   // 15 (bytes, emoji is 4 bytes)

// Indexing uses codepoints
let h = text[0];           // 'H' (rune)
let rocket = text[5];      // 'ðŸš€' (rune)
```

**Multi-byte characters count as one:**
```hemlock
"Hello".length;      // 5
"ðŸš€".length;         // 1 (one emoji)
"ä½ å¥½".length;       // 2 (two Chinese characters)
"cafÃ©".length;       // 4 (Ã© is one codepoint)
```

## String Literals

```hemlock
// Basic strings
let s1 = "hello";
let s2 = "world";

// With escape sequences
let s3 = "Line 1\nLine 2\ttabbed";
let s4 = "Quote: \"Hello\"";
let s5 = "Backslash: \\";

// Unicode characters
let s6 = "ðŸš€ Emoji";
let s7 = "ä¸­æ–‡å­—ç¬¦";
```

## Template Strings (String Interpolation)

Use backticks for template strings with embedded expressions:

```hemlock
let name = "Alice";
let age = 30;

// Basic interpolation
let greeting = `Hello, ${name}!`;           // "Hello, Alice!"
let info = `${name} is ${age} years old`;   // "Alice is 30 years old"

// Expressions in interpolation
let x = 5;
let y = 10;
let sum = `${x} + ${y} = ${x + y}`;         // "5 + 10 = 15"

// Method calls
let upper = `Name: ${name.to_upper()}`;     // "Name: ALICE"

// Nested objects
let person = { name: "Bob", city: "NYC" };
let desc = `${person.name} lives in ${person.city}`;  // "Bob lives in NYC"

// Multi-line (preserves newlines)
let multi = `Line 1
Line 2
Line 3`;
```

**Template string features:**
- Expressions inside `${...}` are evaluated and converted to strings
- Any valid expression can be used (variables, function calls, arithmetic)
- Backtick strings support the same escape sequences as regular strings
- Useful for building dynamic strings without concatenation

### Escaping in Template Strings

To include a literal `${` in a template string, escape the dollar sign:

```hemlock
let price = 100;
let text = `Price: \${price} or ${price}`;
// "Price: ${price} or 100"

// Literal backtick
let code = `Use \` for template strings`;
// "Use ` for template strings"
```

### Complex Expressions

Template strings can contain any valid expression:

```hemlock
// Ternary-like expressions
let age = 25;
let status = `Status: ${age >= 18 ? "adult" : "minor"}`;

// Array access
let items = ["apple", "banana", "cherry"];
let first = `First item: ${items[0]}`;

// Function calls with arguments
fn format_price(p) { return "$" + p; }
let msg = `Total: ${format_price(99.99)}`;  // "Total: $99.99"

// Chained method calls
let name = "alice";
let formatted = `Hello, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;
// "Hello, Alice!"
```

### Template Strings vs Concatenation

Template strings are often cleaner than concatenation:

```hemlock
// Concatenation (harder to read)
let msg1 = "Hello, " + name + "! You have " + count + " messages.";

// Template string (easier to read)
let msg2 = `Hello, ${name}! You have ${count} messages.`;
```

## Indexing and Mutation

### Reading Characters

Indexing returns a `rune` (Unicode codepoint):

```hemlock
let s = "Hello";
let first = s[0];      // 'H' (rune)
let last = s[4];       // 'o' (rune)

// UTF-8 example
let emoji = "HiðŸš€!";
let rocket = emoji[2];  // 'ðŸš€' (rune at codepoint index 2)
```

### Writing Characters

Strings are mutable - you can modify individual characters:

```hemlock
let s = "hello";
s[0] = 'H';            // Now "Hello"
s[4] = '!';            // Now "Hell!"

// With Unicode
let msg = "Go!";
msg[0] = 'ðŸš€';         // Now "ðŸš€o!"
```

## Concatenation

Use `+` to concatenate strings:

```hemlock
let greeting = "Hello" + " " + "World";  // "Hello World"

// With variables
let name = "Alice";
let msg = "Hi, " + name + "!";  // "Hi, Alice!"

// With runes (see Runes documentation)
let s = "Hello" + '!';          // "Hello!"
```

## String Methods

Hemlock provides 19 string methods for comprehensive text manipulation.

### Substring & Slicing

**`substr(start, length)`** - Extract substring by position and length:
```hemlock
let s = "hello world";
let sub = s.substr(6, 5);       // "world" (start at 6, length 5)
let first = s.substr(0, 5);     // "hello"

// UTF-8 example
let text = "HiðŸš€!";
let emoji = text.substr(2, 1);  // "ðŸš€" (position 2, length 1)
```

**`slice(start, end)`** - Extract substring by range (end exclusive):
```hemlock
let s = "hello world";
let slice = s.slice(0, 5);      // "hello" (index 0 to 4)
let slice2 = s.slice(6, 11);    // "world"
```

**Difference:**
- `substr(start, length)` - Uses length parameter
- `slice(start, end)` - Uses end index (exclusive)

### Search & Find

**`find(needle)`** - Find first occurrence:
```hemlock
let s = "hello world";
let pos = s.find("world");      // 6 (index of first occurrence)
let pos2 = s.find("foo");       // -1 (not found)
let pos3 = s.find("l");         // 2 (first 'l')
```

**`contains(needle)`** - Check if string contains substring:
```hemlock
let s = "hello world";
let has = s.contains("world");  // true
let has2 = s.contains("foo");   // false
```

### Split & Trim

**`split(delimiter)`** - Split into array of strings:
```hemlock
let csv = "apple,banana,cherry";
let parts = csv.split(",");     // ["apple", "banana", "cherry"]

let words = "one two three".split(" ");  // ["one", "two", "three"]

// Empty delimiter splits by character
let chars = "abc".split("");    // ["a", "b", "c"]
```

**`trim()`** - Remove leading/trailing whitespace:
```hemlock
let s = "  hello  ";
let clean = s.trim();           // "hello"

let s2 = "\t\ntext\n\t";
let clean2 = s2.trim();         // "text"
```

### Case Conversion

**`to_upper()`** - Convert to uppercase:
```hemlock
let s = "hello world";
let upper = s.to_upper();       // "HELLO WORLD"

// Preserves non-ASCII
let s2 = "cafÃ©";
let upper2 = s2.to_upper();     // "CAFÃ‰"
```

**`to_lower()`** - Convert to lowercase:
```hemlock
let s = "HELLO WORLD";
let lower = s.to_lower();       // "hello world"
```

### Prefix/Suffix Checking

**`starts_with(prefix)`** - Check if starts with prefix:
```hemlock
let s = "hello world";
let starts = s.starts_with("hello");  // true
let starts2 = s.starts_with("world"); // false
```

**`ends_with(suffix)`** - Check if ends with suffix:
```hemlock
let s = "hello world";
let ends = s.ends_with("world");      // true
let ends2 = s.ends_with("hello");     // false
```

### Replacement

**`replace(old, new)`** - Replace first occurrence:
```hemlock
let s = "hello world";
let s2 = s.replace("world", "there");      // "hello there"

let s3 = "foo foo foo";
let s4 = s3.replace("foo", "bar");         // "bar foo foo" (first only)
```

**`replace_all(old, new)`** - Replace all occurrences:
```hemlock
let s = "foo foo foo";
let s2 = s.replace_all("foo", "bar");      // "bar bar bar"

let s3 = "hello world, world!";
let s4 = s3.replace_all("world", "hemlock"); // "hello hemlock, hemlock!"
```

### Repetition

**`repeat(count)`** - Repeat string n times:
```hemlock
let s = "ha";
let laugh = s.repeat(3);        // "hahaha"

let line = "=".repeat(40);      // "========================================"
```

### Character & Byte Access

**`char_at(index)`** - Get Unicode codepoint at index (returns rune):
```hemlock
let s = "hello";
let char = s.char_at(0);        // 'h' (rune)

// UTF-8 example
let emoji = "ðŸš€";
let rocket = emoji.char_at(0);  // Returns rune U+1F680
```

**`chars()`** - Convert to array of runes (codepoints):
```hemlock
let s = "hello";
let chars = s.chars();          // ['h', 'e', 'l', 'l', 'o'] (array of runes)

// UTF-8 example
let text = "HiðŸš€";
let chars2 = text.chars();      // ['H', 'i', 'ðŸš€']
```

**`byte_at(index)`** - Get byte value at index (returns u8):
```hemlock
let s = "hello";
let byte = s.byte_at(0);        // 104 (ASCII value of 'h')

// UTF-8 example
let emoji = "ðŸš€";
let first_byte = emoji.byte_at(0);  // 240 (first UTF-8 byte)
```

**`bytes()`** - Convert to array of bytes (u8 values):
```hemlock
let s = "hello";
let bytes = s.bytes();          // [104, 101, 108, 108, 111] (array of u8)

// UTF-8 example
let emoji = "ðŸš€";
let bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 UTF-8 bytes)
```

**`to_bytes()`** - Convert to buffer for low-level access:
```hemlock
let s = "hello";
let buf = s.to_bytes();         // Returns buffer with UTF-8 bytes
print(buf.length);              // 5
free(buf);                      // Remember to free
```

## Method Chaining

All string methods return new strings, enabling chaining:

```hemlock
let result = "  Hello World  "
    .trim()
    .to_lower()
    .replace("world", "hemlock");  // "hello hemlock"

let processed = "foo,bar,baz"
    .split(",")
    .join(" | ")
    .to_upper();                    // "FOO | BAR | BAZ"
```

## Complete Method Reference

| Method | Parameters | Returns | Description |
|--------|-----------|---------|-------------|
| `substr(start, length)` | i32, i32 | string | Extract substring by position and length |
| `slice(start, end)` | i32, i32 | string | Extract substring by range (end exclusive) |
| `find(needle)` | string | i32 | Find first occurrence (-1 if not found) |
| `contains(needle)` | string | bool | Check if contains substring |
| `split(delimiter)` | string | array | Split into array of strings |
| `trim()` | - | string | Remove leading/trailing whitespace |
| `to_upper()` | - | string | Convert to uppercase |
| `to_lower()` | - | string | Convert to lowercase |
| `starts_with(prefix)` | string | bool | Check if starts with prefix |
| `ends_with(suffix)` | string | bool | Check if ends with suffix |
| `replace(old, new)` | string, string | string | Replace first occurrence |
| `replace_all(old, new)` | string, string | string | Replace all occurrences |
| `repeat(count)` | i32 | string | Repeat string n times |
| `char_at(index)` | i32 | rune | Get codepoint at index |
| `byte_at(index)` | i32 | u8 | Get byte value at index |
| `chars()` | - | array | Convert to array of runes |
| `bytes()` | - | array | Convert to array of u8 bytes |
| `to_bytes()` | - | buffer | Convert to buffer (must free) |

## Examples

### Example: Text Processing

```hemlock
fn process_input(text: string): string {
    return text
        .trim()
        .to_lower()
        .replace_all("  ", " ");  // Normalize whitespace
}

let input = "  HELLO   WORLD  ";
let clean = process_input(input);  // "hello world"
```

### Example: CSV Parser

```hemlock
fn parse_csv_line(line: string): array {
    let trimmed = line.trim();
    let fields = trimmed.split(",");

    let result = [];
    let i = 0;
    while (i < fields.length) {
        result.push(fields[i].trim());
        i = i + 1;
    }

    return result;
}

let csv = "apple, banana , cherry";
let fields = parse_csv_line(csv);  // ["apple", "banana", "cherry"]
```

### Example: Word Counter

```hemlock
fn count_words(text: string): i32 {
    let words = text.trim().split(" ");
    return words.length;
}

let sentence = "The quick brown fox";
let count = count_words(sentence);  // 4
```

### Example: String Validation

```hemlock
fn is_valid_email(email: string): bool {
    if (!email.contains("@")) {
        return false;
    }

    if (!email.contains(".")) {
        return false;
    }

    if (email.starts_with("@") || email.ends_with("@")) {
        return false;
    }

    return true;
}

print(is_valid_email("user@example.com"));  // true
print(is_valid_email("invalid"));            // false
```

## Memory Management

Strings are heap-allocated with internal reference counting:

- **Creation**: Allocated on heap with capacity tracking
- **Concatenation**: Creates new string (old strings unchanged)
- **Methods**: Most methods return new strings
- **Lifetime**: Strings are refcounted and automatically freed when scope exits

**Automatic cleanup:**
```hemlock
fn create_strings() {
    let s = "hello";
    let s2 = s + " world";  // New allocation
}  // Both s and s2 are automatically freed when function returns
```

**Note:** Local string variables are automatically cleaned up when they go out of scope. Use `free()` only for early cleanup before scope ends or for long-lived/global data. See [Memory Management](memory.md#internal-reference-counting) for details.

## Best Practices

1. **Use codepoint indexing** - Strings use codepoint positions, not byte offsets
2. **Test with Unicode** - Always test string operations with multi-byte characters
3. **Prefer immutable operations** - Use methods that return new strings rather than mutation
4. **Check bounds** - String indexing does not bounds-check (returns null/error on invalid)
5. **Normalize input** - Use `trim()` and `to_lower()` for user input

## Common Pitfalls

### Pitfall: Byte vs. Codepoint Confusion

```hemlock
let emoji = "ðŸš€";
print(emoji.length);        // 1 (codepoint)
print(emoji.byte_length);   // 4 (bytes)

// Don't mix byte and codepoint operations
let byte = emoji.byte_at(0);  // 240 (first byte)
let char = emoji.char_at(0);  // 'ðŸš€' (full codepoint)
```

### Pitfall: Mutation Surprises

```hemlock
let s1 = "hello";
let s2 = s1;       // Shallow copy
s1[0] = 'H';       // Mutates s1
print(s2);         // Still "hello" (strings are value types)
```

## Related Topics

- [Runes](#language-guide-runes) - Unicode codepoint type used in string indexing
- [Arrays](#language-guide-arrays) - String methods often return or work with arrays
- [Types](#language-guide-types) - String type details and conversions

## See Also

- **UTF-8 Encoding**: See CLAUDE.md section "Strings"
- **Type Conversions**: See [Types](#language-guide-types) for string conversions
- **Memory**: See [Memory](#language-guide-memory) for string allocation details


--------------------------------------------------------------------------------
## Syntax
--------------------------------------------------------------------------------

# Syntax Overview

This document covers the fundamental syntax rules and structure of Hemlock programs.

## Core Syntax Rules

### Semicolons Are Mandatory

Unlike JavaScript or Python, semicolons are **always required** at the end of statements:

```hemlock
let x = 42;
let y = 10;
print(x + y);
```

**This will cause an error:**
```hemlock
let x = 42  // ERROR: Missing semicolon
let y = 10  // ERROR: Missing semicolon
```

### Braces Are Always Required

All control flow blocks must use braces, even for single statements:

```hemlock
// âœ… CORRECT
if (x > 0) {
    print("positive");
}

// âŒ ERROR: Missing braces
if (x > 0)
    print("positive");
```

### Comments

```hemlock
// This is a single-line comment

/*
   This is a
   multi-line comment
*/

let x = 42;  // Inline comment
```

## Variables

### Declaration

Variables are declared with `let`:

```hemlock
let count = 0;
let name = "Alice";
let pi = 3.14159;
```

### Type Annotations (Optional)

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let flag: bool = true;
let text: string = "hello";
```

### Constants

Use `const` for immutable values:

```hemlock
const MAX_SIZE: i32 = 1000;
const PI: f64 = 3.14159;
```

Attempting to reassign a const will result in a runtime error: "Cannot assign to const variable".

## Expressions

### Arithmetic Operators

```hemlock
let a = 10;
let b = 3;

print(a + b);   // 13 - Addition
print(a - b);   // 7  - Subtraction
print(a * b);   // 30 - Multiplication
print(a / b);   // 3  - Division (integer)
```

### Comparison Operators

```hemlock
print(a == b);  // false - Equal
print(a != b);  // true  - Not equal
print(a > b);   // true  - Greater than
print(a < b);   // false - Less than
print(a >= b);  // true  - Greater or equal
print(a <= b);  // false - Less or equal
```

### Logical Operators

```hemlock
let x = true;
let y = false;

print(x && y);  // false - AND
print(x || y);  // true  - OR
print(!x);      // false - NOT
```

### Bitwise Operators

```hemlock
let a = 12;  // 1100
let b = 10;  // 1010

print(a & b);   // 8  - Bitwise AND
print(a | b);   // 14 - Bitwise OR
print(a ^ b);   // 6  - Bitwise XOR
print(a << 2);  // 48 - Left shift
print(a >> 1);  // 6  - Right shift
print(~a);      // -13 - Bitwise NOT
```

### Operator Precedence

From highest to lowest:

1. `()` - Grouping
2. `!`, `~`, `-` (unary) - Unary operators
3. `*`, `/` - Multiplication, Division
4. `+`, `-` - Addition, Subtraction
5. `<<`, `>>` - Bit shifts
6. `<`, `<=`, `>`, `>=` - Comparisons
7. `==`, `!=` - Equality
8. `&` - Bitwise AND
9. `^` - Bitwise XOR
10. `|` - Bitwise OR
11. `&&` - Logical AND
12. `||` - Logical OR

**Examples:**
```hemlock
let x = 2 + 3 * 4;      // 14 (not 20)
let y = (2 + 3) * 4;    // 20
let z = 5 << 2 + 1;     // 40 (5 << 3)
```

## Control Flow

### If Statements

```hemlock
if (condition) {
    // body
}

if (condition) {
    // then branch
} else {
    // else branch
}

if (condition1) {
    // branch 1
} else if (condition2) {
    // branch 2
} else {
    // default branch
}
```

### While Loops

```hemlock
while (condition) {
    // body
}
```

**Example:**
```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

### For Loops

**C-style for:**
```hemlock
for (initializer; condition; increment) {
    // body
}
```

**Example:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**For-in (arrays):**
```hemlock
for (let item in array) {
    // body
}
```

**Example:**
```hemlock
let items = [10, 20, 30];
for (let x in items) {
    print(x);
}
```

### Switch Statements

```hemlock
switch (expression) {
    case value1:
        // body
        break;
    case value2:
        // body
        break;
    default:
        // default body
        break;
}
```

**Example:**
```hemlock
let day = 3;
switch (day) {
    case 1:
        print("Monday");
        break;
    case 2:
        print("Tuesday");
        break;
    case 3:
        print("Wednesday");
        break;
    default:
        print("Other");
        break;
}
```

### Break and Continue

```hemlock
// Break: exit loop
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        break;
    }
    print(i);
}

// Continue: skip to next iteration
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;
    }
    print(i);
}
```

## Functions

### Named Functions

```hemlock
fn function_name(param1: type1, param2: type2): return_type {
    // body
    return value;
}
```

**Example:**
```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Anonymous Functions

```hemlock
let func = fn(params) {
    // body
};
```

**Example:**
```hemlock
let multiply = fn(x, y) {
    return x * y;
};
```

### Type Annotations (Optional)

```hemlock
// No annotations (types inferred)
fn greet(name) {
    return "Hello, " + name;
}

// With annotations (checked at runtime)
fn divide(a: i32, b: i32): f64 {
    return a / b;
}
```

## Objects

### Object Literals

```hemlock
let obj = {
    field1: value1,
    field2: value2,
};
```

**Example:**
```hemlock
let person = {
    name: "Alice",
    age: 30,
    active: true,
};
```

### Methods

```hemlock
let obj = {
    method: fn() {
        self.field = value;
    },
};
```

**Example:**
```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    },
};
```

### Type Definitions

```hemlock
define TypeName {
    field1: type1,
    field2: type2,
    optional_field?: default_value,
}
```

**Example:**
```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,
}
```

## Arrays

### Array Literals

```hemlock
let arr = [element1, element2, element3];
```

**Example:**
```hemlock
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, "two", true, null];
let empty = [];
```

### Array Indexing

```hemlock
let arr = [10, 20, 30];
print(arr[0]);   // 10
arr[1] = 99;     // Modify element
```

## Error Handling

### Try/Catch

```hemlock
try {
    // risky code
} catch (e) {
    // handle error
}
```

### Try/Finally

```hemlock
try {
    // risky code
} finally {
    // always runs
}
```

### Try/Catch/Finally

```hemlock
try {
    // risky code
} catch (e) {
    // handle error
} finally {
    // cleanup
}
```

### Throw

```hemlock
throw expression;
```

**Example:**
```hemlock
if (x < 0) {
    throw "x must be positive";
}
```

### Panic

```hemlock
panic(message);
```

**Example:**
```hemlock
panic("unrecoverable error");
```

## Modules (Experimental)

### Export Statements

```hemlock
export fn function_name() { }
export const CONSTANT = value;
export let variable = value;
export { name1, name2 };
```

### Import Statements

```hemlock
import { name1, name2 } from "./module.hml";
import * as namespace from "./module.hml";
import { name as alias } from "./module.hml";
```

## Async (Experimental)

### Async Functions

```hemlock
async fn function_name(params): return_type {
    // body
}
```

### Spawn/Join

```hemlock
let task = spawn(async_function, arg1, arg2);
let result = join(task);
```

### Channels

```hemlock
let ch = channel(capacity);
ch.send(value);
let value = ch.recv();
ch.close();
```

## FFI (Foreign Function Interface)

### Import Shared Library

```hemlock
import "library_name.so";
```

### Declare External Function

```hemlock
extern fn function_name(param: type): return_type;
```

**Example:**
```hemlock
import "libc.so.6";
extern fn strlen(s: string): i32;
```

## Literals

### Integer Literals

```hemlock
let decimal = 42;
let negative = -100;
let large = 5000000000;  // Auto i64

// Hexadecimal (0x prefix)
let hex = 0xDEADBEEF;
let hex2 = 0xFF;

// Binary (0b prefix)
let bin = 0b1010;
let bin2 = 0b11110000;

// Octal (0o prefix)
let oct = 0o777;
let oct2 = 0O123;

// Numeric separators for readability
let million = 1_000_000;
let hex_sep = 0xFF_FF_FF;
let bin_sep = 0b1111_0000_1010_0101;
let oct_sep = 0o77_77;
```

### Float Literals

```hemlock
let f = 3.14;
let e = 2.71828;
let sci = 1.5e-10;       // Scientific notation
let sci2 = 2.5E+3;       // Uppercase E also works
let no_lead = .5;        // No leading zero (0.5)
let sep = 3.14_159_265;  // Numeric separators
```

### String Literals

```hemlock
let s = "hello";
let escaped = "line1\nline2\ttabbed";
let quote = "She said \"hello\"";

// Hex escape sequences
let hex_esc = "\x48\x65\x6c\x6c\x6f";  // "Hello"

// Unicode escape sequences
let emoji = "\u{1F600}";               // ðŸ˜€
let heart = "\u{2764}";                // â¤
let mixed = "Hello \u{1F30D}!";        // Hello ðŸŒ!
```

**Escape sequences:**
- `\n` - newline
- `\t` - tab
- `\r` - carriage return
- `\\` - backslash
- `\"` - double quote
- `\'` - single quote
- `\0` - null character
- `\xNN` - hex escape (2 digits)
- `\u{XXXX}` - unicode escape (1-6 digits)

### Rune Literals

```hemlock
let ch = 'A';
let emoji = 'ðŸš€';
let escaped = '\n';
let unicode = '\u{1F680}';
let hex_rune = '\x41';      // 'A'
```

### Boolean Literals

```hemlock
let t = true;
let f = false;
```

### Null Literal

```hemlock
let nothing = null;
```

## Scoping Rules

### Block Scope

Variables are scoped to the nearest enclosing block:

```hemlock
let x = 1;  // Outer scope

if (true) {
    let x = 2;  // Inner scope (shadows outer)
    print(x);   // 2
}

print(x);  // 1
```

### Function Scope

Functions create their own scope:

```hemlock
let global = "global";

fn foo() {
    let local = "local";
    print(global);  // Can read outer scope
}

foo();
// print(local);  // ERROR: 'local' not defined here
```

### Closure Scope

Closures capture variables from enclosing scope:

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;  // Captures 'count'
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
```

## Whitespace and Formatting

### Indentation

Hemlock doesn't enforce specific indentation, but 4 spaces is recommended:

```hemlock
fn example() {
    if (true) {
        print("indented");
    }
}
```

### Line Breaks

Statements can span multiple lines:

```hemlock
let result =
    very_long_function_name(
        arg1,
        arg2,
        arg3
    );
```

## Loop Statement

The `loop` keyword provides a cleaner syntax for infinite loops:

```hemlock
loop {
    // ... do work
    if (done) {
        break;
    }
}
```

This is equivalent to `while (true)` but makes the intent clearer.

## Reserved Keywords

The following keywords are reserved in Hemlock:

```
let, const, fn, if, else, while, for, in, loop, break, continue,
return, true, false, null, typeof, import, export, from,
try, catch, finally, throw, panic, async, await, spawn, join,
detach, channel, define, switch, case, default, extern, self,
type, defer, enum, ref, buffer, Self
```

## Next Steps

- [Type System](#language-guide-types) - Learn about Hemlock's type system
- [Control Flow](#language-guide-control-flow) - Deep dive into control structures
- [Functions](#language-guide-functions) - Master functions and closures
- [Memory Management](#language-guide-memory) - Understand pointers and buffers


--------------------------------------------------------------------------------
## Types
--------------------------------------------------------------------------------

# Type System

Hemlock features a **dynamic type system** with optional type annotations and runtime type checking.

---

## Type Selection Guide: What Type Should I Use?

**New to types?** Start here. If you're familiar with type systems, skip to [Philosophy](#philosophy).

### The Short Answer

**Just let Hemlock figure it out:**

```hemlock
let count = 42;        // Hemlock knows this is an integer
let price = 19.99;     // Hemlock knows this is a decimal
let name = "Alice";    // Hemlock knows this is text
let active = true;     // Hemlock knows this is yes/no
```

Hemlock automatically picks the right type for your values. You don't *need* to specify types.

### When to Add Type Annotations

Add types when you want to:

1. **Be specific about size** - `i8` vs `i64` matters for memory or FFI
2. **Document your code** - Types show what a function expects
3. **Catch mistakes early** - Hemlock checks types at runtime

```hemlock
// Without types (works fine):
fn add(a, b) {
    return a + b;
}

// With types (more explicit):
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Quick Reference: Choosing Number Types

| What you're storing | Suggested type | Example |
|---------------------|----------------|---------|
| Regular whole numbers | `i32` (default) | `let count = 42;` |
| Very large numbers | `i64` | `let population = 8000000000;` |
| Never-negative counts | `u32` | `let items: u32 = 100;` |
| Bytes (0-255) | `u8` | `let pixel: u8 = 255;` |
| Decimals/fractions | `f64` (default) | `let price = 19.99;` |
| Performance-critical decimals | `f32` | `let x: f32 = 1.5;` |

### Quick Reference: All Types

| Category | Types | When to use |
|----------|-------|-------------|
| **Whole numbers** | `i8`, `i16`, `i32`, `i64` | Counting, IDs, ages, etc. |
| **Positive-only numbers** | `u8`, `u16`, `u32`, `u64` | Bytes, sizes, array lengths |
| **Decimals** | `f32`, `f64` | Money, measurements, math |
| **Yes/No** | `bool` | Flags, conditions |
| **Text** | `string` | Names, messages, any text |
| **Single character** | `rune` | Individual letters, emoji |
| **Lists** | `array` | Collections of values |
| **Named fields** | `object` | Grouping related data |
| **Raw memory** | `ptr`, `buffer` | Low-level programming |
| **Nothing** | `null` | Absence of a value |

### Common Scenarios

**"I just need a number"**
```hemlock
let x = 42;  // Done! Hemlock picks i32
```

**"I need decimals"**
```hemlock
let price = 19.99;  // Done! Hemlock picks f64
```

**"I'm working with bytes (files, network)"**
```hemlock
let byte: u8 = 255;  // 0-255 range
```

**"I need really big numbers"**
```hemlock
let big = 9000000000000;  // Hemlock auto-picks i64 (> i32 max)
// Or be explicit:
let big: i64 = 9000000000000;
```

**"I'm storing money"**
```hemlock
// Option 1: Float (simple, but has precision limits)
let price: f64 = 19.99;

// Option 2: Store as cents (more precise)
let price_cents: i32 = 1999;  // $19.99 as integer cents
```

**"I'm passing data to C code (FFI)"**
```hemlock
// Match C types exactly
let c_int: i32 = 100;      // C 'int'
let c_long: i64 = 100;     // C 'long' (on 64-bit)
let c_char: u8 = 65;       // C 'char'
let c_double: f64 = 3.14;  // C 'double'
```

### What Happens When Types Mix?

When you combine different types, Hemlock promotes to the "bigger" type:

```hemlock
let a: i32 = 10;
let b: f64 = 2.5;
let result = a + b;  // result is f64 (12.5)
// The integer became a decimal automatically
```

**Rule of thumb:** Floats always "win" - mixing any integer with a float gives you a float.

### Type Errors

If you try to use the wrong type, Hemlock tells you at runtime:

```hemlock
let age: i32 = "thirty";  // ERROR: type mismatch - expected i32, got string
```

To convert types, use type constructor functions:

```hemlock
let text = "42";
let number = i32(text);   // Parse string to integer: 42
let back = text + "";     // Already a string
```

---

## Philosophy

- **Dynamic by default** - Every value has a runtime type tag
- **Typed by choice** - Optional type annotations enforce runtime checks
- **Explicit conversions** - Implicit conversions follow clear promotion rules
- **Honest about types** - `typeof()` always tells the truth

## Primitive Types

### Integer Types

**Signed integers:**
```hemlock
let tiny: i8 = 127;              // 8-bit  (-128 to 127)
let small: i16 = 32767;          // 16-bit (-32768 to 32767)
let normal: i32 = 2147483647;    // 32-bit (default)
let large: i64 = 9223372036854775807;  // 64-bit
```

**Unsigned integers:**
```hemlock
let byte: u8 = 255;              // 8-bit  (0 to 255)
let word: u16 = 65535;           // 16-bit (0 to 65535)
let dword: u32 = 4294967295;     // 32-bit (0 to 4294967295)
let qword: u64 = 18446744073709551615;  // 64-bit
```

**Type aliases:**
```hemlock
let i: integer = 42;   // Alias for i32
let b: byte = 255;     // Alias for u8
```

### Floating-Point Types

```hemlock
let f: f32 = 3.14159;        // 32-bit float
let d: f64 = 2.718281828;    // 64-bit float (default)
let n: number = 1.618;       // Alias for f64
```

### Boolean Type

```hemlock
let flag: bool = true;
let active: bool = false;
```

### String Type

```hemlock
let text: string = "Hello, World!";
let empty: string = "";
```

Strings are **mutable**, **UTF-8 encoded**, and **heap-allocated**.

See [Strings](#language-guide-strings) for full details.

### Rune Type

```hemlock
let ch: rune = 'A';
let emoji: rune = 'ðŸš€';
let newline: rune = '\n';
let unicode: rune = '\u{1F680}';
```

Runes represent **Unicode codepoints** (U+0000 to U+10FFFF).

See [Runes](#language-guide-runes) for full details.

### Null Type

```hemlock
let nothing = null;
let uninitialized: string = null;
```

`null` is its own type with a single value.

## Composite Types

### Array Type

```hemlock
let numbers: array = [1, 2, 3, 4, 5];
let mixed = [1, "two", true, null];  // Mixed types allowed
let empty: array = [];
```

See [Arrays](#language-guide-arrays) for full details.

### Object Type

```hemlock
let obj: object = { x: 10, y: 20 };
let person = { name: "Alice", age: 30 };
```

See [Objects](#language-guide-objects) for full details.

### Pointer Types

**Raw pointer:**
```hemlock
let p: ptr = alloc(64);
// No bounds checking, manual lifetime management
free(p);
```

**Safe buffer:**
```hemlock
let buf: buffer = buffer(64);
// Bounds-checked, tracks length and capacity
free(buf);
```

See [Memory Management](#language-guide-memory) for full details.

## Enum Types

Enums define a set of named constants:

### Basic Enums

```hemlock
enum Color {
    RED,
    GREEN,
    BLUE
}

let c = Color.RED;
print(c);              // 0
print(typeof(c));      // "Color"

// Comparison
if (c == Color.RED) {
    print("It's red!");
}

// Switch on enum
switch (c) {
    case Color.RED:
        print("Stop");
        break;
    case Color.GREEN:
        print("Go");
        break;
    case Color.BLUE:
        print("Blue?");
        break;
}
```

### Enums with Values

Enums can have explicit integer values:

```hemlock
enum Status {
    OK = 0,
    ERROR = 1,
    PENDING = 2
}

print(Status.OK);      // 0
print(Status.ERROR);   // 1

enum HttpCode {
    OK = 200,
    NOT_FOUND = 404,
    SERVER_ERROR = 500
}

let code = HttpCode.NOT_FOUND;
print(code);           // 404
```

### Auto-incrementing Values

Without explicit values, enums auto-increment from 0:

```hemlock
enum Priority {
    LOW,       // 0
    MEDIUM,    // 1
    HIGH,      // 2
    CRITICAL   // 3
}

// Can mix explicit and auto values
enum Level {
    DEBUG = 10,
    INFO,      // 11
    WARN,      // 12
    ERROR = 50,
    FATAL      // 51
}
```

### Enum Usage Patterns

```hemlock
// As function parameters
fn set_priority(p: Priority) {
    if (p == Priority.CRITICAL) {
        print("Urgent!");
    }
}

set_priority(Priority.HIGH);

// In objects
define Task {
    name: string,
    priority: Priority
}

let task: Task = {
    name: "Fix bug",
    priority: Priority.HIGH
};
```

## Special Types

### File Type

```hemlock
let f: file = open("data.txt", "r");
f.close();
```

Represents an open file handle.

### Task Type

```hemlock
async fn compute(): i32 { return 42; }
let task = spawn(compute);
let result: i32 = join(task);
```

Represents an async task handle.

### Channel Type

```hemlock
let ch: channel = channel(10);
ch.send(42);
let value = ch.recv();
```

Represents a communication channel between tasks.

### Void Type

```hemlock
extern fn exit(code: i32): void;
```

Used for functions that don't return a value (FFI only).

## Type Inference

### Integer Literal Inference

Hemlock infers integer types based on value range:

```hemlock
let a = 42;              // i32 (fits in 32-bit)
let b = 5000000000;      // i64 (> i32 max)
let c = 128;             // i32
let d: u8 = 128;         // u8 (explicit annotation)
```

**Rules:**
- Values in i32 range (-2147483648 to 2147483647): infer as `i32`
- Values outside i32 range but within i64: infer as `i64`
- Use explicit annotations for other types (i8, i16, u8, u16, u32, u64)

### Float Literal Inference

```hemlock
let x = 3.14;        // f64 (default)
let y: f32 = 3.14;   // f32 (explicit)
```

### Scientific Notation

Hemlock supports scientific notation for numeric literals:

```hemlock
let a = 1e10;        // 10000000000.0 (f64)
let b = 1e-12;       // 0.000000000001 (f64)
let c = 3.14e2;      // 314.0 (f64)
let d = 2.5e-3;      // 0.0025 (f64)
let e = 1E10;        // Case insensitive
let f = 1e+5;        // Explicit positive exponent
```

**Note:** Any literal using scientific notation is always inferred as `f64`.

### Other Type Inference

```hemlock
let s = "hello";     // string
let ch = 'A';        // rune
let flag = true;     // bool
let arr = [1, 2, 3]; // array
let obj = { x: 10 }; // object
let nothing = null;  // null
```

## Type Annotations

### Variable Annotations

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let name: string = "Alice";
```

### Function Parameter Annotations

```hemlock
fn greet(name: string, age: i32) {
    print("Hello, " + name + "!");
}
```

### Function Return Type Annotations

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Object Type Annotations (Duck Typing)

```hemlock
define Person {
    name: string,
    age: i32,
}

let p: Person = { name: "Bob", age: 25 };
```

## Type Checking

### Runtime Type Checking

Type annotations are checked at **runtime**, not compile-time:

```hemlock
let x: i32 = 42;     // OK
let y: i32 = 3.14;   // Runtime error: type mismatch

fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 3);           // OK
add(5, "hello");     // Runtime error: type mismatch
```

### Type Queries

Use `typeof()` to check value types:

```hemlock
print(typeof(42));         // "i32"
print(typeof(3.14));       // "f64"
print(typeof("hello"));    // "string"
print(typeof(true));       // "bool"
print(typeof(null));       // "null"
print(typeof([1, 2, 3]));  // "array"
print(typeof({ x: 10 }));  // "object"
```

## Type Conversions

### Implicit Type Promotion

When mixing types in operations, Hemlock promotes to the "higher" type:

**Promotion Hierarchy (lowest to highest):**
```
i8 â†’ i16 â†’ i32 â†’ u32 â†’ i64 â†’ u64 â†’ f32 â†’ f64
      â†‘     â†‘     â†‘
     u8    u16
```

**Float always wins:**
```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // result is f64 (13.5)
```

**Larger size wins:**
```hemlock
let a: i32 = 100;
let b: i64 = 200;
let sum = a + b;     // sum is i64 (300)
```

**Precision preservation:** When mixing 64-bit integers with f32, Hemlock promotes
to f64 to avoid precision loss (f32 has only 24-bit mantissa, insufficient for i64/u64):
```hemlock
let big: i64 = 9007199254740993;
let small: f32 = 1.0;
let result = big + small;  // result is f64, not f32!
```

**Examples:**
```hemlock
u8 + i32  â†’ i32
i32 + i64 â†’ i64
u32 + u64 â†’ u64
i32 + f32 â†’ f32    // f32 sufficient for i32
i64 + f32 â†’ f64    // f64 needed to preserve i64 precision
i64 + f64 â†’ f64
i8 + f64  â†’ f64
```

### Explicit Type Conversion

**Integer â†” Float:**
```hemlock
let i: i32 = 42;
let f: f64 = i;      // i32 â†’ f64 (42.0)

let x: f64 = 3.14;
let n: i32 = x;      // f64 â†’ i32 (3, truncated)
```

**Integer â†” Rune:**
```hemlock
let code: i32 = 65;
let ch: rune = code;  // i32 â†’ rune ('A')

let r: rune = 'Z';
let value: i32 = r;   // rune â†’ i32 (90)
```

**Rune â†’ String:**
```hemlock
let ch: rune = 'ðŸš€';
let s: string = ch;   // rune â†’ string ("ðŸš€")
```

**u8 â†’ Rune:**
```hemlock
let b: u8 = 65;
let r: rune = b;      // u8 â†’ rune ('A')
```

### Type Constructor Functions

Type names can be used as functions to convert or parse values:

**Parsing strings to numbers:**
```hemlock
let n = i32("42");       // Parse string to i32: 42
let f = f64("3.14159");  // Parse string to f64: 3.14159
let b = bool("true");    // Parse string to bool: true

// All numeric types supported
let a = i8("-128");      // Parse to i8
let c = u8("255");       // Parse to u8
let d = i16("1000");     // Parse to i16
let e = u16("50000");    // Parse to u16
let g = i64("9000000000000"); // Parse to i64
let h = u64("18000000000000"); // Parse to u64
let j = f32("1.5");      // Parse to f32
```

**Hex and negative numbers:**
```hemlock
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42
let bin = i32("0b1010"); // 10 (binary)
```

**Type aliases work too:**
```hemlock
let x = integer("100");  // Same as i32("100")
let y = number("1.5");   // Same as f64("1.5")
let z = byte("200");     // Same as u8("200")
```

**Converting between numeric types:**
```hemlock
let big = i64(42);           // i32 to i64
let truncated = i32(3.99);   // f64 to i32 (truncates to 3)
let promoted = f64(100);     // i32 to f64 (100.0)
let narrowed = i8(127);      // i32 to i8
```

**Type annotations perform numeric coercion (but NOT string parsing):**
```hemlock
let f: f64 = 100;        // i32 to f64 via annotation (OK)
let s: string = 'A';     // Rune to string via annotation (OK)
let code: i32 = 'A';     // Rune to i32 via annotation (gets codepoint, OK)

// String parsing requires explicit type constructors:
let n = i32("42");       // Use type constructor for string parsing
// let x: i32 = "42";    // ERROR - type annotations don't parse strings
```

**Error handling:**
```hemlock
// Invalid strings throw errors when using type constructors
let bad = i32("hello");  // Runtime error: cannot parse "hello" as i32
let overflow = u8("256"); // Runtime error: 256 out of range for u8
```

**Boolean parsing:**
```hemlock
let t = bool("true");    // true
let f = bool("false");   // false
let bad = bool("yes");   // Runtime error: must be "true" or "false"
```

## Range Checking

Type annotations enforce range checks at assignment:

```hemlock
let x: u8 = 255;    // OK
let y: u8 = 256;    // ERROR: out of range for u8

let a: i8 = 127;    // OK
let b: i8 = 128;    // ERROR: out of range for i8

let c: i64 = 2147483647;   // OK
let d: u64 = 4294967295;   // OK
let e: u64 = -1;           // ERROR: u64 cannot be negative
```

## Type Promotion Examples

### Mixed Integer Types

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let sum = a + b;     // i32 (30)

let c: u8 = 100;
let d: u32 = 200;
let total = c + d;   // u32 (300)
```

### Integer + Float

```hemlock
let i: i32 = 5;
let f: f32 = 2.5;
let result = i * f;  // f32 (12.5)
```

### Complex Expressions

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let c: f64 = 3.0;

let result = a + b * c;  // f64 (70.0)
// Evaluation: b * c â†’ f64(60.0)
//             a + f64(60.0) â†’ f64(70.0)
```

## Duck Typing (Objects)

Objects use **structural typing** (duck typing):

```hemlock
define Person {
    name: string,
    age: i32,
}

// OK: Has all required fields
let p1: Person = { name: "Alice", age: 30 };

// OK: Extra fields allowed
let p2: Person = { name: "Bob", age: 25, city: "NYC" };

// ERROR: Missing 'age' field
let p3: Person = { name: "Carol" };

// ERROR: Wrong type for 'age'
let p4: Person = { name: "Dave", age: "thirty" };
```

**Type checking happens at assignment:**
- Validates all required fields present
- Validates field types match
- Extra fields are allowed and preserved
- Sets object's type name for `typeof()`

## Optional Fields

```hemlock
define Config {
    host: string,
    port: i32,
    debug?: false,     // Optional with default
    timeout?: i32,     // Optional, defaults to null
}

let cfg1: Config = { host: "localhost", port: 8080 };
print(cfg1.debug);    // false (default)
print(cfg1.timeout);  // null

let cfg2: Config = { host: "0.0.0.0", port: 80, debug: true };
print(cfg2.debug);    // true (overridden)
```

## Type Aliases

Hemlock supports custom type aliases using the `type` keyword:

### Basic Type Aliases

```hemlock
// Simple type alias
type Integer = i32;
type Text = string;

// Using the alias
let x: Integer = 42;
let msg: Text = "hello";
```

### Function Type Aliases

```hemlock
// Function type alias
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// Using function type aliases
let cb: Callback = fn(n) { print(n); };
let isEven: Predicate = fn(n) { return n % 2 == 0; };
```

### Compound Type Aliases

```hemlock
// Combine multiple defines into one type
define HasName { name: string }
define HasAge { age: i32 }

type Person = HasName & HasAge;

let p: Person = { name: "Alice", age: 30 };
```

### Generic Type Aliases

```hemlock
// Generic type alias
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };

// Using generic aliases
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
```

**Note:** Type aliases are transparent - `typeof()` returns the underlying type name, not the alias.

## Type System Limitations

Current limitations:

- **No generics on functions** - Function type parameters not yet supported
- **No union types** - Cannot express "A or B"
- **No nullable types** - All types can be null (use `?` suffix for explicit nullability)

**Note:** The compiler (`hemlockc`) provides compile-time type checking. The interpreter performs runtime type checking only. See the [compiler documentation](#design-implementation) for details.

## Best Practices

### When to Use Type Annotations

**DO use annotations when:**
- Precise type matters (e.g., `u8` for byte values)
- Documenting function interfaces
- Enforcing constraints (e.g., range checks)

```hemlock
fn hash(data: buffer, length: u32): u64 {
    // Implementation
}
```

**DON'T use annotations when:**
- Type is obvious from literal
- Internal implementation details
- Unnecessary ceremony

```hemlock
// Unnecessary
let x: i32 = 42;

// Better
let x = 42;
```

### Type Safety Patterns

**Check before use:**
```hemlock
if (typeof(value) == "i32") {
    // Safe to use as i32
}
```

**Validate function arguments:**
```hemlock
fn divide(a, b) {
    if (typeof(a) != "i32" || typeof(b) != "i32") {
        throw "arguments must be integers";
    }
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}
```

**Use duck typing for flexibility:**
```hemlock
define Printable {
    toString: fn,
}

fn print_item(item: Printable) {
    print(item.toString());
}
```

## Next Steps

- [Strings](#language-guide-strings) - UTF-8 string type and operations
- [Runes](#language-guide-runes) - Unicode codepoint type
- [Arrays](#language-guide-arrays) - Dynamic array type
- [Objects](#language-guide-objects) - Object literals and duck typing
- [Memory](#language-guide-memory) - Pointer and buffer types



################################################################################
# ADVANCED TOPICS
################################################################################

--------------------------------------------------------------------------------
## Async Concurrency
--------------------------------------------------------------------------------

# Async/Concurrency in Hemlock

Hemlock provides **structured concurrency** with async/await syntax, task spawning, and channels for communication. The implementation uses POSIX threads (pthreads) for **TRUE multi-threaded parallelism**.

## Table of Contents

- [Overview](#overview)
- [Threading Model](#threading-model)
- [Async Functions](#async-functions)
- [Task Spawning](#task-spawning)
- [Channels](#channels)
- [Exception Propagation](#exception-propagation)
- [Implementation Details](#implementation-details)
- [Best Practices](#best-practices)
- [Performance Characteristics](#performance-characteristics)
- [Current Limitations](#current-limitations)

## Overview

**What this means:**
- âœ… **Real OS threads** - Each spawned task runs on a separate pthread (POSIX thread)
- âœ… **True parallelism** - Tasks execute simultaneously on multiple CPU cores
- âœ… **Kernel-scheduled** - The OS scheduler distributes tasks across available cores
- âœ… **Thread-safe channels** - Uses pthread mutexes and condition variables for synchronization

**What this is NOT:**
- âŒ **NOT green threads** - Not user-space cooperative multitasking
- âŒ **NOT async/await coroutines** - Not single-threaded event loop like JavaScript/Python asyncio
- âŒ **NOT emulated concurrency** - Not simulated parallelism

This is the **same threading model as C, C++, and Rust** when using OS threads. You get actual parallel execution across multiple cores.

## Threading Model

### 1:1 Threading

Hemlock uses a **1:1 threading model**, where:
- Each spawned task creates a dedicated OS thread via `pthread_create()`
- The OS kernel schedules threads across available CPU cores
- Pre-emptive multitasking - the OS can interrupt and switch between threads
- **No GIL** - Unlike Python, there's no Global Interpreter Lock limiting parallelism

### Synchronization Mechanisms

- **Mutexes** - Channels use `pthread_mutex_t` for thread-safe access
- **Condition variables** - Blocking send/recv use `pthread_cond_t` for efficient waiting
- **Lock-free operations** - Task state transitions are atomic

## Async Functions

Functions can be declared as `async` to indicate they're designed for concurrent execution:

```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}
```

### Key Points

- `async fn` declares an asynchronous function
- Async functions can be spawned as concurrent tasks using `spawn()`
- Async functions can also be called directly (runs synchronously in current thread)
- When spawned, each task runs on its **own OS thread** (not a coroutine!)
- `await` keyword is reserved for future use

### Example: Direct Call vs Spawn

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Direct call - runs synchronously
let result1 = factorial(5);  // 120

// Spawned task - runs on separate thread
let task = spawn(factorial, 5);
let result2 = join(task);  // 120
```

## Task Spawning

Use `spawn()` to run async functions **in parallel on separate OS threads**:

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Spawn multiple tasks - these run in PARALLEL on different CPU cores!
let t1 = spawn(factorial, 5);  // Thread 1
let t2 = spawn(factorial, 6);  // Thread 2
let t3 = spawn(factorial, 7);  // Thread 3

// All three are computing simultaneously right now!

// Wait for results
let f5 = join(t1);  // 120
let f6 = join(t2);  // 720
let f7 = join(t3);  // 5040
```

### Built-in Functions

#### spawn(async_fn, arg1, arg2, ...)

Creates a new task on a new pthread, returns task handle.

**Parameters:**
- `async_fn` - The async function to execute
- `arg1, arg2, ...` - Arguments to pass to the function

**Returns:** Task handle (opaque value used with `join()` or `detach()`)

**Example:**
```hemlock
async fn process(data: string, count: i32): i32 {
    // ... processing logic
    return count * 2;
}

let task = spawn(process, "test", 42);
```

#### join(task)

Wait for task completion (blocks until thread finishes), returns result.

**Parameters:**
- `task` - Task handle returned from `spawn()`

**Returns:** The value returned by the async function

**Example:**
```hemlock
let task = spawn(compute, 1000);
let result = join(task);  // Blocks until compute() finishes
print(result);
```

**Important:** Each task can only be joined once. Subsequent joins will error.

#### detach(task)

Fire-and-forget execution (thread runs independently, no join allowed).

**Parameters:**
- `task` - Task handle returned from `spawn()`

**Returns:** `null`

**Example:**
```hemlock
async fn background_work() {
    // Long-running background task
    // ...
}

let task = spawn(background_work);
detach(task);  // Task runs independently, cannot join
```

**Important:** Detached tasks cannot be joined. Both the pthread and Task struct are automatically cleaned up when the task completes.

## Channels

Channels provide thread-safe communication between tasks using a bounded buffer with blocking semantics.

### Creating Channels

```hemlock
let ch = channel(10);  // Create channel with buffer size of 10
```

**Parameters:**
- `capacity` (i32) - Maximum number of values the channel can hold

**Returns:** Channel object

### Channel Methods

#### send(value)

Send value to channel (blocks if full).

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

let ch = channel(10);
let task = spawn(producer, ch, 5);
```

**Behavior:**
- If channel has space, value is added immediately
- If channel is full, sender blocks until space becomes available
- If channel is closed, throws exception

#### recv()

Receive value from channel (blocks if empty).

```hemlock
async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(10);
let task = spawn(consumer, ch, 5);
```

**Behavior:**
- If channel has values, returns next value immediately
- If channel is empty, receiver blocks until value available
- If channel is closed and empty, returns `null`

#### close()

Close channel (recv on closed channel returns null).

```hemlock
ch.close();
```

**Behavior:**
- Prevents further `send()` operations (will throw exception)
- Allows pending `recv()` operations to complete
- Once empty, `recv()` returns `null`

### Multiplexing with select()

The `select()` function allows waiting on multiple channels simultaneously, returning when any channel has data available.

**Signature:**
```hemlock
select(channels: array, timeout_ms?: i32): object | null
```

**Parameters:**
- `channels` - Array of channel values
- `timeout_ms` (optional) - Timeout in milliseconds (-1 or omit for infinite wait)

**Returns:**
- `{ channel, value }` - Object with the channel that had data and the received value
- `null` - On timeout (if timeout was specified)

**Example:**
```hemlock
let ch1 = channel(1);
let ch2 = channel(1);

// Producer tasks
spawn(fn() {
    sleep(100);
    ch1.send("from channel 1");
});

spawn(fn() {
    sleep(50);
    ch2.send("from channel 2");
});

// Wait for first result (ch2 should be faster)
let result = select([ch1, ch2]);
print(result.value);  // "from channel 2"

// Wait for second result
let result2 = select([ch1, ch2]);
print(result2.value);  // "from channel 1"
```

**With timeout:**
```hemlock
let ch = channel(1);

// No sender, will timeout
let result = select([ch], 100);  // 100ms timeout
if (result == null) {
    print("Timed out!");
}
```

**Use cases:**
- Waiting for the fastest of multiple data sources
- Implementing timeouts on channel operations
- Event loop patterns with multiple event sources
- Fan-in: merging multiple channels into one

**Fan-in pattern:**
```hemlock
fn fan_in(channels: array, output: channel) {
    while (true) {
        let result = select(channels);
        if (result == null) {
            break;  // All channels closed
        }
        output.send(result.value);
    }
    output.close();
}
```

### Complete Producer-Consumer Example

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

// Create channel with buffer size
let ch = channel(10);

// Spawn producer and consumer
let p = spawn(producer, ch, 5);
let c = spawn(consumer, ch, 5);

// Wait for completion
join(p);
let total = join(c);  // 100 (0+10+20+30+40)
print(total);
```

### Multi-Producer, Multi-Consumer

Channels can be safely shared between multiple producers and consumers:

```hemlock
async fn producer(id: i32, ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(id * 100 + i);
        i = i + 1;
    }
}

async fn consumer(id: i32, ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(20);

// Multiple producers
let p1 = spawn(producer, 1, ch, 5);
let p2 = spawn(producer, 2, ch, 5);

// Multiple consumers
let c1 = spawn(consumer, 1, ch, 5);
let c2 = spawn(consumer, 2, ch, 5);

// Wait for all
join(p1);
join(p2);
let sum1 = join(c1);
let sum2 = join(c2);
print(sum1 + sum2);
```

## Exception Propagation

Exceptions thrown in spawned tasks are propagated when joined:

```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Task failed!";
    }
    return 42;
}

let t = spawn(risky_operation, 1);
try {
    let result = join(t);
} catch (e) {
    print("Caught: " + e);  // "Caught: Task failed!"
}
```

### Exception Handling Patterns

**Pattern 1: Handle in task**
```hemlock
async fn safe_task() {
    try {
        // risky operation
    } catch (e) {
        print("Error in task: " + e);
        return null;
    }
}

let task = spawn(safe_task);
join(task);  // No exception propagated
```

**Pattern 2: Propagate to caller**
```hemlock
async fn task_that_throws() {
    throw "error";
}

let task = spawn(task_that_throws);
try {
    join(task);
} catch (e) {
    print("Caught from task: " + e);
}
```

**Pattern 3: Detached tasks with exceptions**
```hemlock
async fn detached_task() {
    try {
        // work
    } catch (e) {
        // Must handle internally - cannot propagate
        print("Error: " + e);
    }
}

let task = spawn(detached_task);
detach(task);  // Cannot catch exceptions from detached tasks
```

## Implementation Details

### Threading Architecture

- **1:1 threading** - Each spawned task creates a dedicated OS thread via `pthread_create()`
- **Kernel-scheduled** - The OS kernel schedules threads across available CPU cores
- **Pre-emptive multitasking** - The OS can interrupt and switch between threads
- **No GIL** - Unlike Python, there's no Global Interpreter Lock limiting parallelism

### Channel Implementation

Channels use a circular buffer with pthread synchronization:

```
Channel Structure:
- buffer[] - Fixed-size array of Values
- capacity - Maximum number of elements
- size - Current number of elements
- head - Read position
- tail - Write position
- mutex - pthread_mutex_t for thread-safe access
- not_empty - pthread_cond_t for blocking recv
- not_full - pthread_cond_t for blocking send
- closed - Boolean flag
- refcount - Reference count for cleanup
```

**Blocking behavior:**
- `send()` on full channel: waits on `not_full` condition variable
- `recv()` on empty channel: waits on `not_empty` condition variable
- Both are signaled when appropriate by the opposite operation

### Memory & Cleanup

- **Joined tasks:** Automatically cleaned up after `join()` returns
- **Detached tasks:** Automatically cleaned up when the task completes
- **Channels:** Reference-counted and freed when no longer used

## Best Practices

### 1. Always Close Channels

```hemlock
async fn producer(ch) {
    // ... send values
    ch.close();  // Important: signal no more values
}
```

### 2. Use Structured Concurrency

Spawn tasks and join them in the same scope:

```hemlock
fn process_data(data) {
    // Spawn tasks
    let t1 = spawn(worker, data);
    let t2 = spawn(worker, data);

    // Always join before returning
    let r1 = join(t1);
    let r2 = join(t2);

    return r1 + r2;
}
```

### 3. Handle Exceptions Appropriately

```hemlock
async fn task() {
    try {
        // risky operation
    } catch (e) {
        // Log error
        throw e;  // Re-throw if caller should know
    }
}
```

### 4. Use Appropriate Channel Capacity

- **Small capacity (1-10):** For coordination/signaling
- **Medium capacity (10-100):** For general producer-consumer
- **Large capacity (100+):** For high-throughput scenarios

```hemlock
let signal_ch = channel(1);      // Coordination
let work_ch = channel(50);       // Work queue
let buffer_ch = channel(1000);   // High throughput
```

### 5. Detach Only When Necessary

Prefer `join()` over `detach()` for better resource management:

```hemlock
// Good: Join and get result
let task = spawn(work);
let result = join(task);

// Use detach only for true fire-and-forget
let bg_task = spawn(background_logging);
detach(bg_task);  // Will run independently
```

## Performance Characteristics

### True Parallelism

- **N spawned tasks can utilize N CPU cores simultaneously**
- Proven speedup - stress tests show 8-9x CPU time vs wall time (multiple cores working)
- Linear scaling with number of cores (up to thread count)

### Thread Overhead

- Each task has ~8KB stack + pthread overhead
- Thread creation cost: ~10-20Î¼s
- Context switch cost: ~1-5Î¼s

### When to Use Async

**Good use cases:**
- CPU-intensive computations that can be parallelized
- I/O-bound operations (though I/O is still blocking)
- Concurrent processing of independent data
- Pipeline architectures with channels

**Not ideal for:**
- Very short tasks (thread overhead dominates)
- Tasks with heavy synchronization (contention overhead)
- Single-core systems (no parallelism benefit)

### Blocking I/O Safe

Blocking operations in one task don't block others:

```hemlock
async fn reader(filename: string) {
    let f = open(filename, "r");  // Blocks this thread only
    let content = f.read();       // Blocks this thread only
    f.close();
    return content;
}

// Both read concurrently (on different threads)
let t1 = spawn(reader, "file1.txt");
let t2 = spawn(reader, "file2.txt");

let c1 = join(t1);
let c2 = join(t2);
```

## Thread Safety Model

Hemlock uses a **message-passing** concurrency model where tasks communicate via channels rather than shared mutable state.

### Argument Isolation

When you spawn a task, **arguments are deep-copied** to prevent data races:

```hemlock
async fn modify_array(arr: array): array {
    arr.push(999);    // Modifies the COPY, not original
    arr[0] = -1;
    return arr;
}

let original = [1, 2, 3];
let task = spawn(modify_array, original);
let modified = join(task);

print(original.length);  // 3 - unchanged!
print(modified.length);  // 4 - has new element
```

**What gets deep-copied:**
- Arrays (and all elements recursively)
- Objects (and all fields recursively)
- Strings
- Buffers

**What gets shared (reference retained):**
- Channels (the communication mechanism - intentionally shared)
- Task handles (for coordination)
- Functions (code is immutable)
- File handles (OS manages concurrent access)
- Socket handles (OS manages concurrent access)

**What cannot be passed:**
- Raw pointers (`ptr`) - use `buffer` instead

### Why Message-Passing?

This follows Hemlock's "explicit over implicit" philosophy:

```hemlock
// BAD: Shared mutable state (would cause data races)
let counter = { value: 0 };
let t1 = spawn(fn() { counter.value = counter.value + 1; });  // Race!
let t2 = spawn(fn() { counter.value = counter.value + 1; });  // Race!

// GOOD: Message-passing via channels
async fn increment(ch) {
    let val = ch.recv();
    ch.send(val + 1);
}

let ch = channel(1);
ch.send(0);
let t1 = spawn(increment, ch);
join(t1);
let result = ch.recv();  // 1 - no race condition
```

### Reference Counting Thread Safety

All reference counting operations use **atomic operations** to prevent use-after-free bugs:
- `string_retain/release` - atomic
- `array_retain/release` - atomic
- `object_retain/release` - atomic
- `buffer_retain/release` - atomic
- `function_retain/release` - atomic
- `channel_retain/release` - atomic
- `task_retain/release` - atomic

This ensures safe memory management even when values are shared across threads.

### Closure Environment Access

Tasks have access to the closure environment for:
- Built-in functions (`print`, `len`, etc.)
- Global function definitions
- Constants and variables

The closure environment is protected by a per-environment mutex, making
concurrent reads and writes thread-safe:

```hemlock
let x = 10;

async fn read_closure(): i32 {
    return x;  // OK: reading closure variable (thread-safe)
}

async fn modify_closure() {
    x = 20;  // OK: writing closure variable (synchronized with mutex)
}
```

**Note:** While concurrent access is synchronized, modifying shared state from
multiple tasks can still lead to logical race conditions (non-deterministic
ordering). For predictable behavior, use channels for task communication or
return values from tasks.

If you need to return data from a task, use the return value or channels.

## Current Limitations

### 1. No Work-Stealing Scheduler

Uses 1 thread per task, which can be inefficient for many short tasks.

**Current:** 1000 tasks = 1000 threads (heavy overhead)

**Planned:** Thread pool with work stealing for better efficiency

### 3. No Async I/O Integration

File/network operations still block the thread:

```hemlock
async fn read_file(path: string) {
    let f = open(path, "r");
    let content = f.read();  // Blocks the thread
    f.close();
    return content;
}
```

**Workaround:** Use multiple threads for concurrent I/O operations

### 4. Fixed Channel Capacity

Channel capacity is set at creation and cannot be resized:

```hemlock
let ch = channel(10);
// Cannot dynamically resize to 20
```

### 5. Channel Size is Fixed

Channel buffer size cannot be changed after creation.

## Common Patterns

### Parallel Map

```hemlock
async fn map_worker(ch_in, ch_out, fn_transform) {
    while (true) {
        let val = ch_in.recv();
        if (val == null) { break; }

        let result = fn_transform(val);
        ch_out.send(result);
    }
    ch_out.close();
}

fn parallel_map(data, fn_transform, workers: i32) {
    let ch_in = channel(100);
    let ch_out = channel(100);

    // Spawn workers
    let tasks = [];
    let i = 0;
    while (i < workers) {
        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));
        i = i + 1;
    }

    // Send data
    let i = 0;
    while (i < data.length) {
        ch_in.send(data[i]);
        i = i + 1;
    }
    ch_in.close();

    // Collect results
    let results = [];
    let i = 0;
    while (i < data.length) {
        results.push(ch_out.recv());
        i = i + 1;
    }

    // Wait for workers
    let i = 0;
    while (i < tasks.length) {
        join(tasks[i]);
        i = i + 1;
    }

    return results;
}
```

### Pipeline Architecture

```hemlock
async fn stage1(input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }
        output_ch.send(val * 2);
    }
    output_ch.close();
}

async fn stage2(input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }
        output_ch.send(val + 10);
    }
    output_ch.close();
}

// Create pipeline
let ch1 = channel(10);
let ch2 = channel(10);
let ch3 = channel(10);

let s1 = spawn(stage1, ch1, ch2);
let s2 = spawn(stage2, ch2, ch3);

// Feed input
ch1.send(1);
ch1.send(2);
ch1.send(3);
ch1.close();

// Collect output
print(ch3.recv());  // 12 (1 * 2 + 10)
print(ch3.recv());  // 14 (2 * 2 + 10)
print(ch3.recv());  // 16 (3 * 2 + 10)

join(s1);
join(s2);
```

### Fan-Out, Fan-In

```hemlock
async fn worker(id: i32, input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }

        // Process value
        let result = val * id;
        output_ch.send(result);
    }
}

let input = channel(10);
let output = channel(10);

// Fan-out: Multiple workers
let workers = 4;
let tasks = [];
let i = 0;
while (i < workers) {
    tasks.push(spawn(worker, i, input, output));
    i = i + 1;
}

// Send work
let i = 0;
while (i < 10) {
    input.send(i);
    i = i + 1;
}
input.close();

// Fan-in: Collect all results
let results = [];
let i = 0;
while (i < 10) {
    results.push(output.recv());
    i = i + 1;
}

// Wait for all workers
let i = 0;
while (i < tasks.length) {
    join(tasks[i]);
    i = i + 1;
}
```

## Summary

Hemlock's async/concurrency model provides:

- âœ… True multi-threaded parallelism using OS threads
- âœ… Simple, structured concurrency primitives
- âœ… Thread-safe channels for communication
- âœ… Exception propagation across tasks
- âœ… Proven performance on multi-core systems
- âœ… **Argument isolation** - deep copy prevents data races
- âœ… **Atomic reference counting** - safe memory management across threads

This makes Hemlock suitable for:
- Parallel computations
- Concurrent I/O operations
- Pipeline architectures
- Producer-consumer patterns

While avoiding the complexity of:
- Manual thread management
- Low-level synchronization primitives
- Deadlock-prone lock-based designs
- Shared mutable state bugs


--------------------------------------------------------------------------------
## Atomics
--------------------------------------------------------------------------------

# Atomic Operations

Hemlock provides atomic operations for **lock-free concurrent programming**. These operations enable safe manipulation of shared memory across multiple threads without traditional locks or mutexes.

## Table of Contents

- [Overview](#overview)
- [When to Use Atomics](#when-to-use-atomics)
- [Memory Model](#memory-model)
- [Atomic Load and Store](#atomic-load-and-store)
- [Fetch-and-Modify Operations](#fetch-and-modify-operations)
- [Compare-and-Swap (CAS)](#compare-and-swap-cas)
- [Atomic Exchange](#atomic-exchange)
- [Memory Fence](#memory-fence)
- [Function Reference](#function-reference)
- [Common Patterns](#common-patterns)
- [Best Practices](#best-practices)
- [Limitations](#limitations)

---

## Overview

Atomic operations are **indivisible** operations that complete without the possibility of interruption. When one thread performs an atomic operation, no other thread can observe the operation in a partially-completed state.

**Key features:**
- All operations use **sequential consistency** (`memory_order_seq_cst`)
- Supported types: **i32** and **i64**
- Operations work on raw pointers allocated with `alloc()`
- Thread-safe without explicit locks

**Available operations:**
- Load/Store - Read and write values atomically
- Add/Sub - Arithmetic operations returning the old value
- And/Or/Xor - Bitwise operations returning the old value
- CAS - Compare-and-swap for conditional updates
- Exchange - Swap values atomically
- Fence - Full memory barrier

---

## When to Use Atomics

**Use atomics for:**
- Counters shared across tasks (e.g., request counts, progress tracking)
- Flags and status indicators
- Lock-free data structures
- Simple synchronization primitives
- Performance-critical concurrent code

**Use channels instead when:**
- Passing complex data between tasks
- Implementing producer-consumer patterns
- You need message-passing semantics

**Example use case - Shared counter:**
```hemlock
// Allocate shared counter
let counter = alloc(4);
ptr_write_i32(counter, 0);

async fn worker(counter: ptr, id: i32) {
    let i = 0;
    while (i < 1000) {
        atomic_add_i32(counter, 1);
        i = i + 1;
    }
}

// Spawn multiple workers
let t1 = spawn(worker, counter, 1);
let t2 = spawn(worker, counter, 2);
let t3 = spawn(worker, counter, 3);

join(t1);
join(t2);
join(t3);

// Counter will be exactly 3000 (no data races)
print(atomic_load_i32(counter));

free(counter);
```

---

## Memory Model

All Hemlock atomic operations use **sequential consistency** (`memory_order_seq_cst`), which provides the strongest memory ordering guarantees:

1. **Atomicity**: Each operation is indivisible
2. **Total ordering**: All threads see the same order of operations
3. **No reordering**: Operations are not reordered by the compiler or CPU

This makes reasoning about concurrent code simpler, at the cost of some potential performance compared to weaker memory orderings.

---

## Atomic Load and Store

### atomic_load_i32 / atomic_load_i64

Atomically read a value from memory.

**Signature:**
```hemlock
atomic_load_i32(ptr: ptr): i32
atomic_load_i64(ptr: ptr): i64
```

**Parameters:**
- `ptr` - Pointer to the memory location (must be properly aligned)

**Returns:** The value at the memory location

**Example:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);

let value = atomic_load_i32(p);
print(value);  // 42

free(p);
```

---

### atomic_store_i32 / atomic_store_i64

Atomically write a value to memory.

**Signature:**
```hemlock
atomic_store_i32(ptr: ptr, value: i32): null
atomic_store_i64(ptr: ptr, value: i64): null
```

**Parameters:**
- `ptr` - Pointer to the memory location
- `value` - Value to store

**Returns:** `null`

**Example:**
```hemlock
let p = alloc(8);

atomic_store_i64(p, 5000000000);
print(atomic_load_i64(p));  // 5000000000

free(p);
```

---

## Fetch-and-Modify Operations

These operations atomically modify a value and return the **old** (previous) value.

### atomic_add_i32 / atomic_add_i64

Atomically add to a value.

**Signature:**
```hemlock
atomic_add_i32(ptr: ptr, value: i32): i32
atomic_add_i64(ptr: ptr, value: i64): i64
```

**Returns:** The **old** value (before addition)

**Example:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_add_i32(p, 10);
print(old);                    // 100 (old value)
print(atomic_load_i32(p));     // 110 (new value)

free(p);
```

---

### atomic_sub_i32 / atomic_sub_i64

Atomically subtract from a value.

**Signature:**
```hemlock
atomic_sub_i32(ptr: ptr, value: i32): i32
atomic_sub_i64(ptr: ptr, value: i64): i64
```

**Returns:** The **old** value (before subtraction)

**Example:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_sub_i32(p, 25);
print(old);                    // 100 (old value)
print(atomic_load_i32(p));     // 75 (new value)

free(p);
```

---

### atomic_and_i32 / atomic_and_i64

Atomically perform bitwise AND.

**Signature:**
```hemlock
atomic_and_i32(ptr: ptr, value: i32): i32
atomic_and_i64(ptr: ptr, value: i64): i64
```

**Returns:** The **old** value (before AND)

**Example:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xFF);  // 255 in binary: 11111111

let old = atomic_and_i32(p, 0x0F);  // AND with 00001111
print(old);                    // 255 (old value)
print(atomic_load_i32(p));     // 15 (0xFF & 0x0F = 0x0F)

free(p);
```

---

### atomic_or_i32 / atomic_or_i64

Atomically perform bitwise OR.

**Signature:**
```hemlock
atomic_or_i32(ptr: ptr, value: i32): i32
atomic_or_i64(ptr: ptr, value: i64): i64
```

**Returns:** The **old** value (before OR)

**Example:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0x0F);  // 15 in binary: 00001111

let old = atomic_or_i32(p, 0xF0);  // OR with 11110000
print(old);                    // 15 (old value)
print(atomic_load_i32(p));     // 255 (0x0F | 0xF0 = 0xFF)

free(p);
```

---

### atomic_xor_i32 / atomic_xor_i64

Atomically perform bitwise XOR.

**Signature:**
```hemlock
atomic_xor_i32(ptr: ptr, value: i32): i32
atomic_xor_i64(ptr: ptr, value: i64): i64
```

**Returns:** The **old** value (before XOR)

**Example:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xAA);  // 170 in binary: 10101010

let old = atomic_xor_i32(p, 0xFF);  // XOR with 11111111
print(old);                    // 170 (old value)
print(atomic_load_i32(p));     // 85 (0xAA ^ 0xFF = 0x55)

free(p);
```

---

## Compare-and-Swap (CAS)

The most powerful atomic operation. Atomically compares the current value with an expected value and, if they match, replaces it with a new value.

### atomic_cas_i32 / atomic_cas_i64

**Signature:**
```hemlock
atomic_cas_i32(ptr: ptr, expected: i32, desired: i32): bool
atomic_cas_i64(ptr: ptr, expected: i64, desired: i64): bool
```

**Parameters:**
- `ptr` - Pointer to the memory location
- `expected` - Value we expect to find
- `desired` - Value to store if expectation matches

**Returns:**
- `true` - Swap succeeded (value was `expected`, now is `desired`)
- `false` - Swap failed (value was not `expected`, unchanged)

**Example:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

// CAS succeeds: value is 100, swap to 999
let success1 = atomic_cas_i32(p, 100, 999);
print(success1);               // true
print(atomic_load_i32(p));     // 999

// CAS fails: value is 999, not 100
let success2 = atomic_cas_i32(p, 100, 888);
print(success2);               // false
print(atomic_load_i32(p));     // 999 (unchanged)

free(p);
```

**Use cases:**
- Implementing locks and semaphores
- Lock-free data structures
- Optimistic concurrency control
- Atomic conditional updates

---

## Atomic Exchange

Atomically swap a value, returning the old value.

### atomic_exchange_i32 / atomic_exchange_i64

**Signature:**
```hemlock
atomic_exchange_i32(ptr: ptr, value: i32): i32
atomic_exchange_i64(ptr: ptr, value: i64): i64
```

**Parameters:**
- `ptr` - Pointer to the memory location
- `value` - New value to store

**Returns:** The **old** value (before exchange)

**Example:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_exchange_i32(p, 200);
print(old);                    // 100 (old value)
print(atomic_load_i32(p));     // 200 (new value)

free(p);
```

---

## Memory Fence

A full memory barrier that ensures all memory operations before the fence are visible to all threads before any operations after the fence.

### atomic_fence

**Signature:**
```hemlock
atomic_fence(): null
```

**Returns:** `null`

**Example:**
```hemlock
// Ensure all previous writes are visible
atomic_fence();
```

**Note:** In most cases, you don't need explicit fences because all atomic operations already use sequential consistency. Fences are useful when you need to synchronize non-atomic memory operations.

---

## Function Reference

### i32 Operations

| Function | Signature | Returns | Description |
|----------|-----------|---------|-------------|
| `atomic_load_i32` | `(ptr)` | `i32` | Load value atomically |
| `atomic_store_i32` | `(ptr, value)` | `null` | Store value atomically |
| `atomic_add_i32` | `(ptr, value)` | `i32` | Add and return old value |
| `atomic_sub_i32` | `(ptr, value)` | `i32` | Subtract and return old value |
| `atomic_and_i32` | `(ptr, value)` | `i32` | Bitwise AND and return old value |
| `atomic_or_i32` | `(ptr, value)` | `i32` | Bitwise OR and return old value |
| `atomic_xor_i32` | `(ptr, value)` | `i32` | Bitwise XOR and return old value |
| `atomic_cas_i32` | `(ptr, expected, desired)` | `bool` | Compare-and-swap |
| `atomic_exchange_i32` | `(ptr, value)` | `i32` | Exchange and return old value |

### i64 Operations

| Function | Signature | Returns | Description |
|----------|-----------|---------|-------------|
| `atomic_load_i64` | `(ptr)` | `i64` | Load value atomically |
| `atomic_store_i64` | `(ptr, value)` | `null` | Store value atomically |
| `atomic_add_i64` | `(ptr, value)` | `i64` | Add and return old value |
| `atomic_sub_i64` | `(ptr, value)` | `i64` | Subtract and return old value |
| `atomic_and_i64` | `(ptr, value)` | `i64` | Bitwise AND and return old value |
| `atomic_or_i64` | `(ptr, value)` | `i64` | Bitwise OR and return old value |
| `atomic_xor_i64` | `(ptr, value)` | `i64` | Bitwise XOR and return old value |
| `atomic_cas_i64` | `(ptr, expected, desired)` | `bool` | Compare-and-swap |
| `atomic_exchange_i64` | `(ptr, value)` | `i64` | Exchange and return old value |

### Memory Barrier

| Function | Signature | Returns | Description |
|----------|-----------|---------|-------------|
| `atomic_fence` | `()` | `null` | Full memory barrier |

---

## Common Patterns

### Pattern: Atomic Counter

```hemlock
// Thread-safe counter
let counter = alloc(4);
ptr_write_i32(counter, 0);

fn increment(): i32 {
    return atomic_add_i32(counter, 1);
}

fn decrement(): i32 {
    return atomic_sub_i32(counter, 1);
}

fn get_count(): i32 {
    return atomic_load_i32(counter);
}

// Usage
increment();  // Returns 0 (old value)
increment();  // Returns 1
increment();  // Returns 2
print(get_count());  // 3

free(counter);
```

### Pattern: Spinlock

```hemlock
// Simple spinlock implementation
let lock = alloc(4);
ptr_write_i32(lock, 0);  // 0 = unlocked, 1 = locked

fn acquire() {
    // Spin until we successfully set lock from 0 to 1
    while (!atomic_cas_i32(lock, 0, 1)) {
        // Busy wait
    }
}

fn release() {
    atomic_store_i32(lock, 0);
}

// Usage
acquire();
// ... critical section ...
release();

free(lock);
```

### Pattern: One-Time Initialization

```hemlock
let initialized = alloc(4);
ptr_write_i32(initialized, 0);  // 0 = not initialized, 1 = initialized

fn ensure_initialized() {
    // Try to be the one to initialize
    if (atomic_cas_i32(initialized, 0, 1)) {
        // We won the race, do initialization
        do_expensive_init();
    }
    // Otherwise, already initialized
}
```

### Pattern: Atomic Flag

```hemlock
let flag = alloc(4);
ptr_write_i32(flag, 0);

fn set_flag() {
    atomic_store_i32(flag, 1);
}

fn clear_flag() {
    atomic_store_i32(flag, 0);
}

fn test_and_set(): bool {
    // Returns true if flag was already set
    return atomic_exchange_i32(flag, 1) == 1;
}

fn check_flag(): bool {
    return atomic_load_i32(flag) == 1;
}
```

### Pattern: Bounded Counter

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);
let max_value = 100;

fn try_increment(): bool {
    while (true) {
        let current = atomic_load_i32(counter);
        if (current >= max_value) {
            return false;  // At maximum
        }
        if (atomic_cas_i32(counter, current, current + 1)) {
            return true;  // Successfully incremented
        }
        // CAS failed, another thread modified - retry
    }
}
```

---

## Best Practices

### 1. Use Proper Alignment

Pointers must be properly aligned for the data type:
- i32: 4-byte alignment
- i64: 8-byte alignment

Memory from `alloc()` is typically properly aligned.

### 2. Prefer Higher-Level Abstractions

When possible, use channels for inter-task communication. Atomics are lower-level and require careful reasoning.

```hemlock
// Prefer this:
let ch = channel(10);
spawn(fn() { ch.send(result); });
let value = ch.recv();

// Over manual atomic coordination when appropriate
```

### 3. Be Aware of ABA Problem

CAS can suffer from the ABA problem: a value changes from A to B and back to A. Your CAS succeeds, but the state may have changed in between.

### 4. Initialize Before Sharing

Always initialize atomic variables before spawning tasks that access them:

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);  // Initialize BEFORE spawning

let task = spawn(worker, counter);
```

### 5. Free After All Tasks Complete

Don't free atomic memory while tasks might still access it:

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);

let t1 = spawn(worker, counter);
let t2 = spawn(worker, counter);

join(t1);
join(t2);

// Now safe to free
free(counter);
```

---

## Limitations

### Current Limitations

1. **Only i32 and i64 supported** - No atomic operations for other types
2. **No pointer atomics** - Cannot atomically load/store pointers
3. **Sequential consistency only** - No weaker memory orderings available
4. **No atomic floating-point** - Use integer representation if needed

### Platform Notes

- Atomic operations use C11 `<stdatomic.h>` under the hood
- Available on all platforms that support POSIX threads
- Guaranteed to be lock-free on modern 64-bit systems

---

## See Also

- [Async/Concurrency](#advanced-async-concurrency) - Task spawning and channels
- [Memory Management](#language-guide-memory) - Pointer and buffer allocation
- [Memory API](#reference-memory-api) - Allocation functions


--------------------------------------------------------------------------------
## Bundling Packaging
--------------------------------------------------------------------------------

# Bundling & Packaging

Hemlock provides built-in tools to bundle multi-file projects into single distributable files and create self-contained executables.

## Overview

| Command | Output | Use Case |
|---------|--------|----------|
| `--bundle` | `.hmlc` or `.hmlb` | Distribute bytecode (requires Hemlock to run) |
| `--package` | Executable | Standalone binary (no dependencies) |
| `--compile` | `.hmlc` | Compile single file (no import resolution) |

## Bundling

The bundler resolves all `import` statements from an entry point and flattens them into a single file.

### Basic Usage

```bash
# Bundle app.hml and all its imports into app.hmlc
hemlock --bundle app.hml

# Specify output path
hemlock --bundle app.hml -o dist/app.hmlc

# Create compressed bundle (.hmlb) - smaller file size
hemlock --bundle app.hml --compress -o app.hmlb

# Verbose output (shows resolved modules)
hemlock --bundle app.hml --verbose
```

### Output Formats

**`.hmlc` (Uncompressed)**
- Serialized AST format
- Fast to load and execute
- Default output format

**`.hmlb` (Compressed)**
- zlib-compressed `.hmlc`
- Smaller file size (typically 50-70% reduction)
- Slightly slower startup due to decompression

### Running Bundled Files

```bash
# Run uncompressed bundle
hemlock app.hmlc

# Run compressed bundle
hemlock app.hmlb

# Pass arguments
hemlock app.hmlc arg1 arg2
```

### Example: Multi-Module Project

```
myapp/
â”œâ”€â”€ main.hml
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ math.hml
â”‚   â””â”€â”€ utils.hml
â””â”€â”€ config.hml
```

```hemlock
// main.hml
import { add, multiply } from "./lib/math.hml";
import { log } from "./lib/utils.hml";
import { VERSION } from "./config.hml";

log(`App v${VERSION}`);
print(add(2, 3));
```

```bash
hemlock --bundle myapp/main.hml -o myapp.hmlc
hemlock myapp.hmlc  # Runs with all dependencies bundled
```

### stdlib Imports

The bundler automatically resolves `@stdlib/` imports:

```hemlock
import { HashMap } from "@stdlib/collections";
import { now } from "@stdlib/time";
```

When bundled, stdlib modules are included in the output.

## Packaging

Packaging creates a self-contained executable by embedding the bundled bytecode into a copy of the Hemlock interpreter.

### Basic Usage

```bash
# Create executable from app.hml
hemlock --package app.hml

# Specify output name
hemlock --package app.hml -o myapp

# Skip compression (faster startup, larger file)
hemlock --package app.hml --no-compress

# Verbose output
hemlock --package app.hml --verbose
```

### Running Packaged Executables

```bash
# The packaged executable runs directly
./myapp

# Arguments are passed to the script
./myapp arg1 arg2
```

### Package Format

Packaged executables use the HMLP format:

```
[hemlock binary][HMLB/HMLC payload][payload_size:u64][HMLP magic:u32]
```

When a packaged executable runs:
1. It checks for an embedded payload at the end of the file
2. If found, it decompresses and executes the payload
3. If not found, it behaves as a normal Hemlock interpreter

### Compression Options

| Flag | Format | Startup | Size |
|------|--------|---------|------|
| (default) | HMLB | Normal | Smaller |
| `--no-compress` | HMLC | Faster | Larger |

For CLI tools where startup time matters, use `--no-compress`.

## Inspecting Bundles

Use `--info` to inspect bundled or compiled files:

```bash
hemlock --info app.hmlc
```

Output:
```
=== File Info: app.hmlc ===
Size: 12847 bytes
Format: HMLC (compiled AST)
Version: 1
Flags: 0x0001 [DEBUG]
Strings: 42
Statements: 156
```

```bash
hemlock --info app.hmlb
```

Output:
```
=== File Info: app.hmlb ===
Size: 5234 bytes
Format: HMLB (compressed bundle)
Version: 1
Uncompressed: 12847 bytes
Compressed: 5224 bytes
Ratio: 59.3% reduction
```

## Native Compilation

For true native executables (no interpreter), use the Hemlock compiler:

```bash
# Compile to native executable via C
hemlockc app.hml -o app

# Keep generated C code
hemlockc app.hml -o app --keep-c

# Emit C only (don't compile)
hemlockc app.hml -c -o app.c

# Optimization level
hemlockc app.hml -o app -O2
```

The compiler generates C code and invokes GCC to produce a native binary. This requires:
- The Hemlock runtime library (`libhemlock_runtime`)
- A C compiler (GCC by default)

### Compiler Options

| Option | Description |
|--------|-------------|
| `-o <file>` | Output executable name |
| `-c` | Emit C code only |
| `--emit-c <file>` | Write C to specified file |
| `-k, --keep-c` | Keep generated C after compilation |
| `-O<level>` | Optimization level (0-3) |
| `--cc <path>` | C compiler to use |
| `--runtime <path>` | Path to runtime library |
| `-v, --verbose` | Verbose output |

## Comparison

| Approach | Portability | Startup | Size | Dependencies |
|----------|-------------|---------|------|--------------|
| `.hml` | Source only | Parse time | Smallest | Hemlock |
| `.hmlc` | Hemlock-only | Fast | Small | Hemlock |
| `.hmlb` | Hemlock-only | Fast | Smaller | Hemlock |
| `--package` | Standalone | Fast | Larger | None |
| `hemlockc` | Native | Fastest | Varies | Runtime libs |

## Best Practices

1. **Development**: Run `.hml` files directly for fast iteration
2. **Distribution (with Hemlock)**: Bundle with `--compress` for smaller files
3. **Distribution (standalone)**: Package for zero-dependency deployment
4. **Performance-critical**: Use `hemlockc` for native compilation

## Troubleshooting

### "Cannot find stdlib"

The bundler looks for stdlib in:
1. `./stdlib` (relative to executable)
2. `../stdlib` (relative to executable)
3. `/usr/local/lib/hemlock/stdlib`

Ensure Hemlock is properly installed or run from the source directory.

### Circular Dependencies

```
Error: Circular dependency detected when loading 'path/to/module.hml'
```

Refactor your imports to break the cycle. Consider using a shared module for common types.

### Large Package Size

- Use default compression (don't use `--no-compress`)
- The packaged size includes the full interpreter (~500KB-1MB base)
- For minimal size, use `hemlockc` for native compilation


--------------------------------------------------------------------------------
## Command Execution
--------------------------------------------------------------------------------

# Command Execution in Hemlock

Hemlock provides the **`exec()` builtin function** to execute shell commands and capture their output.

## Table of Contents

- [Overview](#overview)
- [The exec() Function](#the-exec-function)
- [Result Object](#result-object)
- [Basic Usage](#basic-usage)
- [Advanced Examples](#advanced-examples)
- [Error Handling](#error-handling)
- [Implementation Details](#implementation-details)
- [Security Considerations](#security-considerations)
- [Limitations](#limitations)
- [Use Cases](#use-cases)
- [Best Practices](#best-practices)
- [Complete Examples](#complete-examples)

## Overview

The `exec()` function allows Hemlock programs to:
- Execute shell commands
- Capture standard output (stdout)
- Check exit status codes
- Use shell features (pipes, redirects, etc.)
- Integrate with system utilities

**Important:** Commands are executed via `/bin/sh`, giving full shell capabilities but also introducing security considerations.

## The exec() Function

### Signature

```hemlock
exec(command: string): object
```

**Parameters:**
- `command` (string) - Shell command to execute

**Returns:** An object with two fields:
- `output` (string) - The command's stdout output
- `exit_code` (i32) - The command's exit status code

### Basic Example

```hemlock
let result = exec("echo hello");
print(result.output);      // "hello\n"
print(result.exit_code);   // 0
```

## Result Object

The object returned by `exec()` has the following structure:

```hemlock
{
    output: string,      // Command stdout (captured output)
    exit_code: i32       // Process exit status (0 = success)
}
```

### output Field

Contains all text written to stdout by the command.

**Properties:**
- Empty string if command produces no output
- Includes newlines and whitespace as-is
- Multi-line output preserved
- Not limited in size (dynamically allocated)

**Examples:**
```hemlock
let r1 = exec("echo test");
print(r1.output);  // "test\n"

let r2 = exec("ls");
print(r2.output);  // Directory listing with newlines

let r3 = exec("true");
print(r3.output);  // "" (empty string)
```

### exit_code Field

The command's exit status code.

**Values:**
- `0` typically indicates success
- `1-255` indicate errors (convention varies by command)
- `-1` if command could not be executed or terminated abnormally

**Examples:**
```hemlock
let r1 = exec("true");
print(r1.exit_code);  // 0 (success)

let r2 = exec("false");
print(r2.exit_code);  // 1 (failure)

let r3 = exec("ls /nonexistent");
print(r3.exit_code);  // 2 (file not found, varies by command)
```

## Basic Usage

### Simple Command

```hemlock
let r = exec("ls -la");
print(r.output);
print("Exit code: " + typeof(r.exit_code));
```

### Checking Exit Status

```hemlock
let r = exec("grep pattern file.txt");
if (r.exit_code == 0) {
    print("Found: " + r.output);
} else {
    print("Pattern not found");
}
```

### Commands with Pipes

```hemlock
let r = exec("ps aux | grep hemlock");
print(r.output);
```

### Multiple Commands

```hemlock
let r = exec("cd /tmp && ls -la");
print(r.output);
```

### Command Substitution

```hemlock
let r = exec("echo $(date)");
print(r.output);  // Current date
```

## Advanced Examples

### Handling Failures

```hemlock
let r = exec("ls /nonexistent");
if (r.exit_code != 0) {
    print("Command failed with code: " + typeof(r.exit_code));
    print("Error output: " + r.output);  // Note: stderr not captured
}
```

### Processing Multi-Line Output

```hemlock
let r = exec("cat file.txt");
let lines = r.output.split("\n");
let i = 0;
while (i < lines.length) {
    print("Line " + typeof(i) + ": " + lines[i]);
    i = i + 1;
}
```

### Command Chaining

**With && (AND):**
```hemlock
let r1 = exec("mkdir -p /tmp/test && touch /tmp/test/file.txt");
if (r1.exit_code == 0) {
    print("Setup complete");
}
```

**With || (OR):**
```hemlock
let r = exec("command1 || command2");
// Runs command2 only if command1 fails
```

**With ; (sequence):**
```hemlock
let r = exec("command1; command2");
// Runs both regardless of success/failure
```

### Using Pipes

```hemlock
let r = exec("echo 'data' | base64");
print("Base64: " + r.output);
```

**Complex pipelines:**
```hemlock
let r = exec("cat /etc/passwd | grep root | cut -d: -f1");
print(r.output);
```

### Exit Code Patterns

Different exit codes indicate different conditions:

```hemlock
let r = exec("test -f myfile.txt");
if (r.exit_code == 0) {
    print("File exists");
} else if (r.exit_code == 1) {
    print("File does not exist");
} else {
    print("Test command failed: " + typeof(r.exit_code));
}
```

### Output Redirects

```hemlock
// Redirect stdout to file (within shell)
let r1 = exec("echo 'test' > /tmp/output.txt");

// Redirect stderr to stdout (Note: stderr still not captured by Hemlock)
let r2 = exec("command 2>&1");
```

### Environment Variables

```hemlock
let r = exec("export VAR=value && echo $VAR");
print(r.output);  // "value\n"
```

### Working Directory Changes

```hemlock
let r = exec("cd /tmp && pwd");
print(r.output);  // "/tmp\n"
```

## Error Handling

### When exec() Throws Exceptions

The `exec()` function throws an exception if the command cannot be executed:

```hemlock
try {
    let r = exec("nonexistent_command_xyz");
} catch (e) {
    print("Failed to execute: " + e);
}
```

**Exceptions are thrown when:**
- `popen()` fails (e.g., cannot create pipe)
- System resource limits exceeded
- Memory allocation failures

### When exec() Does NOT Throw

```hemlock
// Command runs but returns non-zero exit code
let r1 = exec("false");
print(r1.exit_code);  // 1 (not an exception)

// Command produces no output
let r2 = exec("true");
print(r2.output);  // "" (not an exception)

// Command not found by shell
let r3 = exec("nonexistent_cmd");
print(r3.exit_code);  // 127 (not an exception)
```

### Safe Execution Pattern

```hemlock
fn safe_exec(command: string) {
    try {
        let r = exec(command);
        if (r.exit_code != 0) {
            print("Warning: Command failed with code " + typeof(r.exit_code));
            return "";
        }
        return r.output;
    } catch (e) {
        print("Error executing command: " + e);
        return "";
    }
}

let output = safe_exec("ls -la");
```

## Implementation Details

### How It Works

**Under the hood:**
- Uses `popen()` to execute commands via `/bin/sh`
- Captures stdout only (stderr is not captured)
- Output buffered dynamically (starts at 4KB, grows as needed)
- Exit status extracted using `WIFEXITED()` and `WEXITSTATUS()` macros
- Output string is properly null-terminated

**Process flow:**
1. `popen(command, "r")` creates pipe and forks process
2. Child process executes `/bin/sh -c "command"`
3. Parent reads stdout via pipe into growing buffer
4. `pclose()` waits for child and returns exit status
5. Exit status is extracted and stored in result object

### Performance Considerations

**Costs:**
- Creates a new shell process for each call (~1-5ms overhead)
- Output stored entirely in memory (not streamed)
- No streaming support (waits for command completion)
- Suitable for commands with reasonable output sizes

**Optimizations:**
- Buffer starts at 4KB and doubles when full (efficient memory usage)
- Single read loop minimizes system calls
- No additional string copying

**When to use:**
- Short-running commands (< 1 second)
- Moderate output size (< 10MB)
- Batch operations with reasonable intervals

**When NOT to use:**
- Long-running daemons or services
- Commands producing gigabytes of output
- Real-time streaming data processing
- High-frequency execution (> 100 calls/second)

## Security Considerations

### Shell Injection Risk

âš ï¸ **CRITICAL:** Commands are executed by the shell (`/bin/sh`), which means **shell injection is possible**.

**Vulnerable code:**
```hemlock
// DANGEROUS - DO NOT DO THIS
let filename = args[1];  // User input
let r = exec("cat " + filename);  // Shell injection!
```

**Attack:**
```bash
./hemlock script.hml "; rm -rf /; echo pwned"
# Executes: cat ; rm -rf /; echo pwned
```

### Safe Practices

**1. Never use unsanitized user input:**
```hemlock
// Bad
let user_input = args[1];
let r = exec("process " + user_input);  // DANGEROUS

// Good - validate first
fn is_safe_filename(name: string): bool {
    // Only allow alphanumeric, dash, underscore, dot
    let i = 0;
    while (i < name.length) {
        let c = name[i];
        if (!(c >= 'a' && c <= 'z') &&
            !(c >= 'A' && c <= 'Z') &&
            !(c >= '0' && c <= '9') &&
            c != '-' && c != '_' && c != '.') {
            return false;
        }
        i = i + 1;
    }
    return true;
}

let filename = args[1];
if (is_safe_filename(filename)) {
    let r = exec("cat " + filename);
} else {
    print("Invalid filename");
}
```

**2. Use allowlists, not denylists:**
```hemlock
// Good - strict allowlist
let allowed_commands = ["status", "start", "stop", "restart"];
let cmd = args[1];

let found = false;
for (let allowed in allowed_commands) {
    if (cmd == allowed) {
        found = true;
        break;
    }
}

if (found) {
    exec("service myapp " + cmd);
} else {
    print("Invalid command");
}
```

**3. Escape special characters:**
```hemlock
fn shell_escape(s: string): string {
    // Simple escape - wrap in single quotes and escape single quotes
    let escaped = s.replace_all("'", "'\\''");
    return "'" + escaped + "'";
}

let user_file = args[1];
let safe = shell_escape(user_file);
let r = exec("cat " + safe);
```

**4. Avoid exec() for file operations:**
```hemlock
// Bad - use exec for file operations
let r = exec("cat file.txt");

// Good - use Hemlock's file API
let f = open("file.txt", "r");
let content = f.read();
f.close();
```

### Permission Considerations

Commands run with the same permissions as the Hemlock process:

```hemlock
// If Hemlock runs as root, exec() commands also run as root!
let r = exec("rm -rf /important");  // DANGEROUS if running as root
```

**Best practice:** Run Hemlock with least privilege necessary.

## Limitations

### 1. No stderr Capture

Only stdout is captured, stderr goes to terminal:

```hemlock
let r = exec("ls /nonexistent");
// r.output is empty
// Error message appears on terminal, not captured
```

**Workaround - redirect stderr to stdout:**
```hemlock
let r = exec("ls /nonexistent 2>&1");
// Now error messages are in r.output
```

### 2. No Streaming

Must wait for command completion:

```hemlock
let r = exec("long_running_command");
// Blocks until command finishes
// Cannot process output incrementally
```

### 3. No Timeout

Commands can run indefinitely:

```hemlock
let r = exec("sleep 1000");
// Blocks for 1000 seconds
// No way to timeout or cancel
```

**Workaround - use timeout command:**
```hemlock
let r = exec("timeout 5 long_command");
// Will timeout after 5 seconds
```

### 4. No Signal Handling

Cannot send signals to running commands:

```hemlock
let r = exec("long_command");
// Cannot send SIGINT, SIGTERM, etc. to the command
```

### 5. No Process Control

Cannot interact with command after starting:

```hemlock
let r = exec("interactive_program");
// Cannot send input to the program
// Cannot control execution
```

## Use Cases

### Good Use Cases

**1. Running system utilities:**
```hemlock
let r = exec("ls -la");
let r = exec("grep pattern file.txt");
let r = exec("find /path -name '*.txt'");
```

**2. Quick data processing with Unix tools:**
```hemlock
let r = exec("cat data.txt | sort | uniq | wc -l");
print("Unique lines: " + r.output);
```

**3. Checking system state:**
```hemlock
let r = exec("df -h");
print("Disk usage:\n" + r.output);
```

**4. File existence checks:**
```hemlock
let r = exec("test -f myfile.txt");
if (r.exit_code == 0) {
    print("File exists");
}
```

**5. Generating reports:**
```hemlock
let r = exec("ps aux | grep myapp | wc -l");
let count = r.output.trim();
print("Running instances: " + count);
```

**6. Automation scripts:**
```hemlock
exec("git add .");
exec("git commit -m 'Auto commit'");
let r = exec("git push");
if (r.exit_code != 0) {
    print("Push failed");
}
```

### Not Recommended For

**1. Long-running services:**
```hemlock
// Bad
let r = exec("nginx");  // Blocks forever
```

**2. Interactive commands:**
```hemlock
// Bad - cannot provide input
let r = exec("ssh user@host");
```

**3. Commands producing huge output:**
```hemlock
// Bad - loads entire output into memory
let r = exec("cat 10GB_file.log");
```

**4. Real-time streaming:**
```hemlock
// Bad - cannot process output incrementally
let r = exec("tail -f /var/log/app.log");
```

**5. Mission-critical error handling:**
```hemlock
// Bad - stderr not captured
let r = exec("critical_operation");
// Cannot see detailed error messages
```

## Best Practices

### 1. Always Check Exit Codes

```hemlock
let r = exec("important_command");
if (r.exit_code != 0) {
    print("Command failed!");
    // Handle error
}
```

### 2. Trim Output When Needed

```hemlock
let r = exec("echo test");
let clean = r.output.trim();  // Remove trailing newline
print(clean);  // "test" (no newline)
```

### 3. Validate Before Executing

```hemlock
fn is_valid_command(cmd: string): bool {
    // Validate command is safe
    return true;  // Your validation logic
}

if (is_valid_command(user_cmd)) {
    exec(user_cmd);
}
```

### 4. Use try/catch for Critical Operations

```hemlock
try {
    let r = exec("critical_command");
    if (r.exit_code != 0) {
        throw "Command failed";
    }
} catch (e) {
    print("Error: " + e);
    // Cleanup or recovery
}
```

### 5. Prefer Hemlock APIs Over exec()

```hemlock
// Bad - use exec for file operations
let r = exec("cat file.txt");

// Good - use Hemlock's File API
let f = open("file.txt", "r");
let content = f.read();
f.close();
```

### 6. Capture stderr When Needed

```hemlock
// Redirect stderr to stdout
let r = exec("command 2>&1");
// Now r.output contains both stdout and stderr
```

### 7. Use Shell Features Wisely

```hemlock
// Use pipes for efficiency
let r = exec("cat large.txt | grep pattern | head -n 10");

// Use command substitution
let r = exec("echo Current user: $(whoami)");

// Use conditional execution
let r = exec("test -f file.txt && cat file.txt");
```

## Complete Examples

### Example 1: System Information Gatherer

```hemlock
fn get_system_info() {
    print("=== System Information ===");

    // Hostname
    let r1 = exec("hostname");
    print("Hostname: " + r1.output.trim());

    // Uptime
    let r2 = exec("uptime");
    print("Uptime: " + r2.output.trim());

    // Disk usage
    let r3 = exec("df -h /");
    print("\nDisk Usage:");
    print(r3.output);

    // Memory usage
    let r4 = exec("free -h");
    print("Memory Usage:");
    print(r4.output);
}

get_system_info();
```

### Example 2: Log Analyzer

```hemlock
fn analyze_log(logfile: string) {
    print("Analyzing log: " + logfile);

    // Count total lines
    let r1 = exec("wc -l " + logfile);
    print("Total lines: " + r1.output.trim());

    // Count errors
    let r2 = exec("grep -c ERROR " + logfile + " 2>/dev/null");
    let errors = r2.output.trim();
    if (r2.exit_code == 0) {
        print("Errors: " + errors);
    } else {
        print("Errors: 0");
    }

    // Count warnings
    let r3 = exec("grep -c WARN " + logfile + " 2>/dev/null");
    let warnings = r3.output.trim();
    if (r3.exit_code == 0) {
        print("Warnings: " + warnings);
    } else {
        print("Warnings: 0");
    }

    // Recent errors
    print("\nRecent errors:");
    let r4 = exec("grep ERROR " + logfile + " | tail -n 5");
    print(r4.output);
}

if (args.length < 2) {
    print("Usage: " + args[0] + " <logfile>");
} else {
    analyze_log(args[1]);
}
```

### Example 3: Git Helper

```hemlock
fn git_status() {
    let r = exec("git status --short");
    if (r.exit_code != 0) {
        print("Error: Not a git repository");
        return;
    }

    if (r.output == "") {
        print("Working directory clean");
    } else {
        print("Changes:");
        print(r.output);
    }
}

fn git_quick_commit(message: string) {
    print("Adding all changes...");
    let r1 = exec("git add -A");
    if (r1.exit_code != 0) {
        print("Error adding files");
        return;
    }

    print("Committing...");
    let safe_msg = message.replace_all("'", "'\\''");
    let r2 = exec("git commit -m '" + safe_msg + "'");
    if (r2.exit_code != 0) {
        print("Error committing");
        return;
    }

    print("Committed successfully");
    print(r2.output);
}

// Usage
git_status();
if (args.length > 1) {
    git_quick_commit(args[1]);
}
```

### Example 4: Backup Script

```hemlock
fn backup_directory(source: string, dest: string) {
    print("Backing up " + source + " to " + dest);

    // Create backup directory
    let r1 = exec("mkdir -p " + dest);
    if (r1.exit_code != 0) {
        print("Error creating backup directory");
        return false;
    }

    // Create tarball with timestamp
    let r2 = exec("date +%Y%m%d_%H%M%S");
    let timestamp = r2.output.trim();
    let backup_file = dest + "/backup_" + timestamp + ".tar.gz";

    print("Creating archive: " + backup_file);
    let r3 = exec("tar -czf " + backup_file + " " + source + " 2>&1");
    if (r3.exit_code != 0) {
        print("Error creating backup:");
        print(r3.output);
        return false;
    }

    print("Backup completed successfully");

    // Show backup size
    let r4 = exec("du -h " + backup_file);
    print("Backup size: " + r4.output.trim());

    return true;
}

if (args.length < 3) {
    print("Usage: " + args[0] + " <source> <destination>");
} else {
    backup_directory(args[1], args[2]);
}
```

## Summary

Hemlock's `exec()` function provides:

- âœ… Simple shell command execution
- âœ… Output capture (stdout)
- âœ… Exit code checking
- âœ… Full shell feature access (pipes, redirects, etc.)
- âœ… Integration with system utilities

Remember:
- Always check exit codes
- Be aware of security implications (shell injection)
- Validate user input before using in commands
- Prefer Hemlock APIs over exec() when available
- stderr is not captured (use `2>&1` to redirect)
- Commands block until completion
- Use for short-running utilities, not long-running services

**Security checklist:**
- âŒ Never use unsanitized user input
- âœ… Validate all input
- âœ… Use allowlists for commands
- âœ… Escape special characters when necessary
- âœ… Run with least privilege
- âœ… Prefer Hemlock APIs over shell commands


--------------------------------------------------------------------------------
## Command Line Args
--------------------------------------------------------------------------------

# Command-Line Arguments in Hemlock

Hemlock programs can access command-line arguments via a built-in **`args` array** that is automatically populated at program startup.

## Table of Contents

- [Overview](#overview)
- [The args Array](#the-args-array)
- [Properties](#properties)
- [Iteration Patterns](#iteration-patterns)
- [Common Use Cases](#common-use-cases)
- [Argument Parsing Patterns](#argument-parsing-patterns)
- [Best Practices](#best-practices)
- [Complete Examples](#complete-examples)

## Overview

The `args` array provides access to command-line arguments passed to your Hemlock program:

- **Always available** - Built-in global variable in all Hemlock programs
- **Script name included** - `args[0]` always contains the script path/name
- **Array of strings** - All arguments are strings
- **Zero-indexed** - Standard array indexing (0, 1, 2, ...)

## The args Array

### Basic Structure

```hemlock
// args[0] is always the script filename
// args[1] through args[n-1] are the actual arguments
print(args[0]);        // "script.hml"
print(args.length);    // Total number of arguments (including script name)
```

### Example Usage

**Command:**
```bash
./hemlock script.hml hello world "test 123"
```

**In script.hml:**
```hemlock
print("Script name: " + args[0]);     // "script.hml"
print("Total args: " + typeof(args.length));  // "4"
print("First arg: " + args[1]);       // "hello"
print("Second arg: " + args[2]);      // "world"
print("Third arg: " + args[3]);       // "test 123"
```

### Index Reference

| Index | Contains | Example Value |
|-------|----------|---------------|
| `args[0]` | Script path/name | `"script.hml"` or `"./script.hml"` |
| `args[1]` | First argument | `"hello"` |
| `args[2]` | Second argument | `"world"` |
| `args[3]` | Third argument | `"test 123"` |
| ... | ... | ... |
| `args[n-1]` | Last argument | (varies) |

## Properties

### Always Present

`args` is a global array available in **all** Hemlock programs:

```hemlock
// No need to declare or import
print(args.length);  // Works immediately
```

### Script Name Included

`args[0]` always contains the script path/name:

```hemlock
print("Running: " + args[0]);
```

**Possible values for args[0]:**
- `"script.hml"` - Just the filename
- `"./script.hml"` - Relative path
- `"/home/user/script.hml"` - Absolute path
- Depends on how the script was invoked

### Type: Array of Strings

All arguments are stored as strings:

```hemlock
// Arguments: ./hemlock script.hml 42 3.14 true

print(args[1]);  // "42" (string, not number)
print(args[2]);  // "3.14" (string, not number)
print(args[3]);  // "true" (string, not boolean)

// Convert as needed:
let num = 42;  // Parse manually if needed
```

### Minimum Length

Always at least 1 (the script name):

```hemlock
print(args.length);  // Minimum: 1
```

**Even with no arguments:**
```bash
./hemlock script.hml
```

```hemlock
// In script.hml:
print(args.length);  // 1 (just script name)
```

### REPL Behavior

In the REPL, `args.length` is 0 (empty array):

```hemlock
# REPL session
> print(args.length);
0
```

## Iteration Patterns

### Basic Iteration

Skip `args[0]` (script name) and process actual arguments:

```hemlock
let i = 1;
while (i < args.length) {
    print("Argument " + typeof(i) + ": " + args[i]);
    i = i + 1;
}
```

**Output for: `./hemlock script.hml foo bar baz`**
```
Argument 1: foo
Argument 2: bar
Argument 3: baz
```

### For-In Iteration (Including Script Name)

```hemlock
for (let arg in args) {
    print(arg);
}
```

**Output:**
```
script.hml
foo
bar
baz
```

### Checking Argument Count

```hemlock
if (args.length < 2) {
    print("Usage: " + args[0] + " <argument>");
    // exit or return
} else {
    let arg = args[1];
    // process arg
}
```

### Processing All Arguments Except Script Name

```hemlock
let actual_args = args.slice(1, args.length);

for (let arg in actual_args) {
    print("Processing: " + arg);
}
```

## Common Use Cases

### 1. Simple Argument Processing

Check for required argument:

```hemlock
if (args.length < 2) {
    print("Usage: " + args[0] + " <filename>");
} else {
    let filename = args[1];
    print("Processing file: " + filename);
    // ... process file
}
```

**Usage:**
```bash
./hemlock script.hml data.txt
# Output: Processing file: data.txt
```

### 2. Multiple Arguments

```hemlock
if (args.length < 3) {
    print("Usage: " + args[0] + " <input> <output>");
} else {
    let input_file = args[1];
    let output_file = args[2];

    print("Input: " + input_file);
    print("Output: " + output_file);

    // Process files...
}
```

**Usage:**
```bash
./hemlock convert.hml input.txt output.txt
```

### 3. Variable Number of Arguments

Process all provided arguments:

```hemlock
if (args.length < 2) {
    print("Usage: " + args[0] + " <file1> [file2] [file3] ...");
} else {
    print("Processing " + typeof(args.length - 1) + " files:");

    let i = 1;
    while (i < args.length) {
        print("  " + args[i]);
        process_file(args[i]);
        i = i + 1;
    }
}
```

**Usage:**
```bash
./hemlock batch.hml file1.txt file2.txt file3.txt
```

### 4. Help Message

```hemlock
if (args.length < 2 || args[1] == "--help" || args[1] == "-h") {
    print("Usage: " + args[0] + " [OPTIONS] <file>");
    print("Options:");
    print("  -h, --help     Show this help message");
    print("  -v, --verbose  Enable verbose output");
} else {
    // Process normally
}
```

### 5. Argument Validation

```hemlock
fn validate_file(filename: string): bool {
    // Check if file exists (example)
    return filename != "";
}

if (args.length < 2) {
    print("Error: No filename provided");
} else if (!validate_file(args[1])) {
    print("Error: Invalid file: " + args[1]);
} else {
    print("Processing: " + args[1]);
}
```

## Argument Parsing Patterns

### Named Arguments (Flags)

Simple pattern for named arguments:

```hemlock
let verbose = false;
let output_file = "";
let input_file = "";

let i = 1;
while (i < args.length) {
    if (args[i] == "--verbose" || args[i] == "-v") {
        verbose = true;
    } else if (args[i] == "--output" || args[i] == "-o") {
        i = i + 1;
        if (i < args.length) {
            output_file = args[i];
        }
    } else {
        input_file = args[i];
    }
    i = i + 1;
}

if (verbose) {
    print("Verbose mode enabled");
}
print("Input: " + input_file);
print("Output: " + output_file);
```

**Usage:**
```bash
./hemlock script.hml --verbose --output out.txt input.txt
./hemlock script.hml -v -o out.txt input.txt
```

### Boolean Flags

```hemlock
let debug = false;
let verbose = false;
let force = false;

let i = 1;
while (i < args.length) {
    if (args[i] == "--debug") {
        debug = true;
    } else if (args[i] == "--verbose") {
        verbose = true;
    } else if (args[i] == "--force") {
        force = true;
    }
    i = i + 1;
}
```

### Value Arguments

```hemlock
let config_file = "default.conf";
let port = 8080;

let i = 1;
while (i < args.length) {
    if (args[i] == "--config") {
        i = i + 1;
        if (i < args.length) {
            config_file = args[i];
        }
    } else if (args[i] == "--port") {
        i = i + 1;
        if (i < args.length) {
            port = 8080;  // Would need to parse string to int
        }
    }
    i = i + 1;
}
```

### Mixed Positional and Named Arguments

```hemlock
let input_file = "";
let output_file = "";
let verbose = false;

let i = 1;
let positional = [];

while (i < args.length) {
    if (args[i] == "--verbose") {
        verbose = true;
    } else {
        // Treat as positional argument
        positional.push(args[i]);
    }
    i = i + 1;
}

// Assign positional arguments
if (positional.length > 0) {
    input_file = positional[0];
}
if (positional.length > 1) {
    output_file = positional[1];
}
```

### Argument Parser Helper Function

```hemlock
fn parse_args() {
    let options = {
        verbose: false,
        output: "",
        files: []
    };

    let i = 1;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--verbose" || arg == "-v") {
            options.verbose = true;
        } else if (arg == "--output" || arg == "-o") {
            i = i + 1;
            if (i < args.length) {
                options.output = args[i];
            }
        } else {
            // Positional argument
            options.files.push(arg);
        }

        i = i + 1;
    }

    return options;
}

let opts = parse_args();
print("Verbose: " + typeof(opts.verbose));
print("Output: " + opts.output);
print("Files: " + typeof(opts.files.length));
```

## Best Practices

### 1. Always Check Argument Count

```hemlock
// Good
if (args.length < 2) {
    print("Usage: " + args[0] + " <file>");
} else {
    process_file(args[1]);
}

// Bad - may crash if no arguments
process_file(args[1]);  // Error if args.length == 1
```

### 2. Provide Usage Information

```hemlock
fn show_usage() {
    print("Usage: " + args[0] + " [OPTIONS] <file>");
    print("Options:");
    print("  -h, --help     Show help");
    print("  -v, --verbose  Verbose output");
}

if (args.length < 2) {
    show_usage();
}
```

### 3. Validate Arguments

```hemlock
fn validate_args() {
    if (args.length < 2) {
        print("Error: Missing required argument");
        return false;
    }

    if (args[1] == "") {
        print("Error: Empty argument");
        return false;
    }

    return true;
}

if (!validate_args()) {
    // exit or show usage
}
```

### 4. Use Descriptive Variable Names

```hemlock
// Good
let input_filename = args[1];
let output_filename = args[2];
let max_iterations = args[3];

// Bad
let a = args[1];
let b = args[2];
let c = args[3];
```

### 5. Handle Quoted Arguments with Spaces

Shell automatically handles this:

```bash
./hemlock script.hml "file with spaces.txt"
```

```hemlock
print(args[1]);  // "file with spaces.txt"
```

### 6. Create Argument Objects

```hemlock
fn get_args() {
    return {
        script: args[0],
        input: args[1],
        output: args[2]
    };
}

let arguments = get_args();
print("Input: " + arguments.input);
```

## Complete Examples

### Example 1: File Processor

```hemlock
// Usage: ./hemlock process.hml <input> <output>

fn show_usage() {
    print("Usage: " + args[0] + " <input_file> <output_file>");
}

if (args.length < 3) {
    show_usage();
} else {
    let input = args[1];
    let output = args[2];

    print("Processing " + input + " -> " + output);

    // Process files
    let f_in = open(input, "r");
    let f_out = open(output, "w");

    try {
        let content = f_in.read();
        let processed = content.to_upper();  // Example processing
        f_out.write(processed);

        print("Done!");
    } finally {
        f_in.close();
        f_out.close();
    }
}
```

### Example 2: Batch File Processor

```hemlock
// Usage: ./hemlock batch.hml <file1> <file2> <file3> ...

if (args.length < 2) {
    print("Usage: " + args[0] + " <file1> [file2] [file3] ...");
} else {
    print("Processing " + typeof(args.length - 1) + " files:");

    let i = 1;
    while (i < args.length) {
        let filename = args[i];
        print("  Processing: " + filename);

        try {
            let f = open(filename, "r");
            let content = f.read();
            f.close();

            // Process content...
            print("    " + typeof(content.length) + " bytes");
        } catch (e) {
            print("    Error: " + e);
        }

        i = i + 1;
    }

    print("Done!");
}
```

### Example 3: Advanced Argument Parser

```hemlock
// Usage: ./hemlock app.hml [OPTIONS] <files...>
// Options:
//   --verbose, -v     Enable verbose output
//   --output, -o FILE Set output file
//   --help, -h        Show help

fn parse_arguments() {
    let config = {
        verbose: false,
        output: "output.txt",
        help: false,
        files: []
    };

    let i = 1;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--verbose" || arg == "-v") {
            config.verbose = true;
        } else if (arg == "--output" || arg == "-o") {
            i = i + 1;
            if (i < args.length) {
                config.output = args[i];
            } else {
                print("Error: --output requires a value");
            }
        } else if (arg == "--help" || arg == "-h") {
            config.help = true;
        } else if (arg.starts_with("--")) {
            print("Error: Unknown option: " + arg);
        } else {
            config.files.push(arg);
        }

        i = i + 1;
    }

    return config;
}

fn show_help() {
    print("Usage: " + args[0] + " [OPTIONS] <files...>");
    print("Options:");
    print("  --verbose, -v     Enable verbose output");
    print("  --output, -o FILE Set output file");
    print("  --help, -h        Show this help");
}

let config = parse_arguments();

if (config.help) {
    show_help();
} else if (config.files.length == 0) {
    print("Error: No input files specified");
    show_help();
} else {
    if (config.verbose) {
        print("Verbose mode enabled");
        print("Output file: " + config.output);
        print("Input files: " + typeof(config.files.length));
    }

    // Process files
    for (let file in config.files) {
        if (config.verbose) {
            print("Processing: " + file);
        }
        // ... process file
    }
}
```

### Example 4: Configuration Tool

```hemlock
// Usage: ./hemlock config.hml <action> [arguments]
// Actions:
//   get <key>
//   set <key> <value>
//   list

fn show_usage() {
    print("Usage: " + args[0] + " <action> [arguments]");
    print("Actions:");
    print("  get <key>         Get configuration value");
    print("  set <key> <value> Set configuration value");
    print("  list              List all configuration");
}

if (args.length < 2) {
    show_usage();
} else {
    let action = args[1];

    if (action == "get") {
        if (args.length < 3) {
            print("Error: 'get' requires a key");
        } else {
            let key = args[2];
            print("Getting: " + key);
            // ... get from config
        }
    } else if (action == "set") {
        if (args.length < 4) {
            print("Error: 'set' requires key and value");
        } else {
            let key = args[2];
            let value = args[3];
            print("Setting " + key + " = " + value);
            // ... set in config
        }
    } else if (action == "list") {
        print("Listing all configuration:");
        // ... list config
    } else {
        print("Error: Unknown action: " + action);
        show_usage();
    }
}
```

## Summary

Hemlock's command-line argument support provides:

- âœ… Built-in `args` array available globally
- âœ… Simple array-based access to arguments
- âœ… Script name in `args[0]`
- âœ… All arguments as strings
- âœ… Array methods available (.length, .slice, etc.)

Remember:
- Always check `args.length` before accessing elements
- `args[0]` is the script name
- Actual arguments start at `args[1]`
- All arguments are strings - convert as needed
- Provide usage information for user-friendly tools
- Validate arguments before processing

Common patterns:
- Simple positional arguments
- Named/flag arguments (--flag)
- Value arguments (--option value)
- Help messages (--help)
- Argument validation


--------------------------------------------------------------------------------
## FFI
--------------------------------------------------------------------------------

# Foreign Function Interface (FFI) in Hemlock

Hemlock provides **FFI (Foreign Function Interface)** to call C functions from shared libraries using libffi, enabling integration with existing C libraries and system APIs.

## Table of Contents

- [Overview](#overview)
- [Current Status](#current-status)
- [Supported Types](#supported-types)
- [Basic Concepts](#basic-concepts)
- [Exporting FFI Functions](#exporting-ffi-functions)
- [Use Cases](#use-cases)
- [Future Development](#future-development)
- [FFI Callbacks](#ffi-callbacks)
- [FFI Structs](#ffi-structs)
- [Exporting Struct Types](#exporting-struct-types)
- [Current Limitations](#current-limitations)
- [Best Practices](#best-practices)

## Overview

The Foreign Function Interface (FFI) allows Hemlock programs to:
- Call C functions from shared libraries (.so, .dylib, .dll)
- Use existing C libraries without writing wrapper code
- Access system APIs directly
- Integrate with third-party native libraries
- Bridge Hemlock with low-level system functionality

**Key capabilities:**
- Dynamic library loading
- C function binding
- Automatic type conversion between Hemlock and C types
- Support for all primitive types
- libffi-based implementation for portability

## Current Status

FFI support is available in Hemlock with the following features:

**Implemented:**
- âœ… Call C functions from shared libraries
- âœ… Support for all primitive types (integers, floats, pointers)
- âœ… Automatic type conversion
- âœ… libffi-based implementation
- âœ… Dynamic library loading
- âœ… **Function pointer callbacks** - Pass Hemlock functions to C
- âœ… **Export extern functions** - Share FFI bindings across modules
- âœ… **Struct passing and return values** - Pass C-compatible structs by value
- âœ… **Complete pointer helpers** - Read/write all types (i8-i64, u8-u64, f32, f64, ptr)
- âœ… **Buffer/pointer conversion** - `buffer_ptr()`, `ptr_to_buffer()`
- âœ… **FFI type sizes** - `ffi_sizeof()` for platform-aware type sizes
- âœ… **Platform types** - `size_t`, `usize`, `isize`, `intptr_t` support

**In Development:**
- ðŸ”„ String marshaling helpers
- ðŸ”„ Error handling improvements

**Test Coverage:**
- FFI tests passing including callback tests
- Basic function calling verified
- Type conversion tested
- qsort callback integration tested

## Supported Types

### Primitive Types

The following Hemlock types can be passed to/from C functions:

| Hemlock Type | C Type | Size | Notes |
|--------------|--------|------|-------|
| `i8` | `int8_t` | 1 byte | Signed 8-bit integer |
| `i16` | `int16_t` | 2 bytes | Signed 16-bit integer |
| `i32` | `int32_t` | 4 bytes | Signed 32-bit integer |
| `i64` | `int64_t` | 8 bytes | Signed 64-bit integer |
| `u8` | `uint8_t` | 1 byte | Unsigned 8-bit integer |
| `u16` | `uint16_t` | 2 bytes | Unsigned 16-bit integer |
| `u32` | `uint32_t` | 4 bytes | Unsigned 32-bit integer |
| `u64` | `uint64_t` | 8 bytes | Unsigned 64-bit integer |
| `f32` | `float` | 4 bytes | 32-bit floating point |
| `f64` | `double` | 8 bytes | 64-bit floating point |
| `ptr` | `void*` | 8 bytes | Raw pointer |

### Type Conversion

**Automatic conversions:**
- Hemlock integers â†’ C integers (with range checking)
- Hemlock floats â†’ C floats
- Hemlock pointers â†’ C pointers
- C return values â†’ Hemlock values

**Example type mappings:**
```hemlock
// Hemlock â†’ C
let i: i32 = 42;         // â†’ int32_t (4 bytes)
let f: f64 = 3.14;       // â†’ double (8 bytes)
let p: ptr = alloc(64);  // â†’ void* (8 bytes)

// C â†’ Hemlock (return values)
// int32_t foo() â†’ i32
// double bar() â†’ f64
// void* baz() â†’ ptr
```

## Basic Concepts

### Shared Libraries

FFI works with compiled shared libraries:

**Linux:** `.so` files
```
libexample.so
/usr/lib/libm.so
```

**macOS:** `.dylib` files
```
libexample.dylib
/usr/lib/libSystem.dylib
```

**Windows:** `.dll` files
```
example.dll
kernel32.dll
```

### Function Signatures

C functions must have known signatures for FFI to work correctly:

```c
// Example C function signatures
int add(int a, int b);
double sqrt(double x);
void* malloc(size_t size);
void free(void* ptr);
```

These can be called from Hemlock once the library is loaded and functions are bound.

### Platform Compatibility

FFI uses **libffi** for portability:
- Works on x86, x86-64, ARM, ARM64
- Handles calling conventions automatically
- Abstracts platform-specific ABI details
- Supports Linux, macOS, Windows (with appropriate libffi)

## Exporting FFI Functions

FFI functions declared with `extern fn` can be exported from modules, allowing you to create reusable library wrappers that can be shared across multiple files.

### Basic Export Syntax

```hemlock
// string_utils.hml - A library module wrapping C string functions
import "libc.so.6";

// Export the extern function directly
export extern fn strlen(s: string): i32;
export extern fn strcmp(s1: string, s2: string): i32;

// You can also export wrapper functions alongside extern functions
export fn string_length(s: string): i32 {
    return strlen(s);
}

export fn strings_equal(a: string, b: string): bool {
    return strcmp(a, b) == 0;
}
```

### Importing Exported FFI Functions

```hemlock
// main.hml - Using the exported FFI functions
import { strlen, string_length, strings_equal } from "./string_utils.hml";

let msg = "Hello, World!";
print(strlen(msg));           // 13 - direct extern call
print(string_length(msg));    // 13 - wrapper function

print(strings_equal("foo", "foo"));  // true
print(strings_equal("foo", "bar"));  // false
```

### Use Cases for Export Extern

**1. Platform Abstraction**
```hemlock
// platform.hml - Abstract platform differences
import "libc.so.6";  // Linux

export extern fn getpid(): i32;
export extern fn getuid(): i32;
export extern fn geteuid(): i32;
```

**2. Library Wrappers**
```hemlock
// crypto_lib.hml - Wrap crypto library functions
import "libcrypto.so";

export extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;
export extern fn MD5(data: ptr, len: u64, out: ptr): ptr;

// Add Hemlock-friendly wrappers
export fn sha256_string(s: string): string {
    // Implementation using the extern function
}
```

**3. Centralized FFI Declarations**
```hemlock
// libc.hml - Central module for libc bindings
import "libc.so.6";

// String functions
export extern fn strlen(s: string): i32;
export extern fn strcpy(dest: ptr, src: string): ptr;
export extern fn strcat(dest: ptr, src: string): ptr;

// Memory functions
export extern fn malloc(size: u64): ptr;
export extern fn realloc(p: ptr, size: u64): ptr;
export extern fn calloc(nmemb: u64, size: u64): ptr;

// Process functions
export extern fn getpid(): i32;
export extern fn getppid(): i32;
export extern fn getenv(name: string): ptr;
```

Then use throughout your project:
```hemlock
import { strlen, malloc, getpid } from "./libc.hml";
```

### Combining with Regular Exports

You can mix exported extern functions with regular function exports:

```hemlock
// math_extended.hml
import "libm.so.6";

// Export raw C functions
export extern fn sin(x: f64): f64;
export extern fn cos(x: f64): f64;
export extern fn tan(x: f64): f64;

// Export Hemlock functions that use them
export fn deg_to_rad(degrees: f64): f64 {
    return degrees * 3.14159265359 / 180.0;
}

export fn sin_degrees(degrees: f64): f64 {
    return sin(deg_to_rad(degrees));
}
```

### Platform-Specific Libraries

When exporting extern functions, remember that library names differ by platform:

```hemlock
// For Linux
import "libc.so.6";

// For macOS (different approach needed)
import "libSystem.B.dylib";
```

Currently, Hemlock's `import "library"` syntax uses static library paths, so platform-specific modules may be needed for cross-platform FFI code.

## Use Cases

### 1. System Libraries

Access standard C library functions:

**Math functions:**
```hemlock
// Call sqrt from libm
let result = sqrt(16.0);  // 4.0
```

**Memory allocation:**
```hemlock
// Call malloc/free from libc
let ptr = malloc(1024);
free(ptr);
```

### 2. Third-Party Libraries

Use existing C libraries:

**Example: Image processing**
```hemlock
// Load libpng or libjpeg
// Process images using C library functions
```

**Example: Cryptography**
```hemlock
// Use OpenSSL or libsodium
// Encryption/decryption via FFI
```

### 3. System APIs

Direct system calls:

**Example: POSIX APIs**
```hemlock
// Call getpid, getuid, etc.
// Access low-level system functionality
```

### 4. Performance-Critical Code

Call optimized C implementations:

```hemlock
// Use highly-optimized C libraries
// SIMD operations, vectorized code
// Hardware-accelerated functions
```

### 5. Hardware Access

Interface with hardware libraries:

```hemlock
// GPIO control on embedded systems
// USB device communication
// Serial port access
```

### 6. Legacy Code Integration

Reuse existing C codebases:

```hemlock
// Call functions from legacy C applications
// Gradually migrate to Hemlock
// Preserve working C code
```

## Future Development

### Planned Features

**1. Struct Support**
```hemlock
// Future: Pass/return C structs
define Point {
    x: f64,
    y: f64,
}

let p = Point { x: 1.0, y: 2.0 };
c_function_with_struct(p);
```

**2. Array/Buffer Handling**
```hemlock
// Future: Better array passing
let arr = [1, 2, 3, 4, 5];
process_array(arr);  // Pass to C function
```

**3. Function Pointer Callbacks** âœ… (Implemented!)
```hemlock
// Pass Hemlock functions to C as callbacks
fn my_compare(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    return va - vb;
}

// Create a C-callable function pointer
let cmp = callback(my_compare, ["ptr", "ptr"], "i32");

// Use with qsort or any C function expecting a callback
qsort(arr, count, elem_size, cmp);

// Clean up when done
callback_free(cmp);
```

**4. String Marshaling**
```hemlock
// Future: Automatic string conversion
let s = "hello";
c_string_function(s);  // Auto-convert to C string
```

**5. Error Handling**
```hemlock
// Future: Better error reporting
try {
    let result = risky_c_function();
} catch (e) {
    print("FFI error: " + e);
}
```

**6. Type Safety**
```hemlock
// Future: Type annotations for FFI
@ffi("libm.so")
fn sqrt(x: f64): f64;

let result = sqrt(16.0);  // Type-checked
```

### Features

**v1.0:**
- âœ… Basic FFI with primitive types
- âœ… Dynamic library loading
- âœ… Function calling
- âœ… Callback support via libffi closures

**Future:**
- Struct support
- Array handling improvements
- Automatic binding generation

## FFI Callbacks

Hemlock supports passing functions to C code as callbacks using libffi closures. This enables integration with C APIs that expect function pointers, such as `qsort`, event loops, and callback-based libraries.

### Creating Callbacks

Use `callback()` to create a C-callable function pointer from a Hemlock function:

```hemlock
// callback(function, param_types, return_type) -> ptr
let cb = callback(my_function, ["ptr", "ptr"], "i32");
```

**Parameters:**
- `function`: A Hemlock function to wrap
- `param_types`: Array of type name strings (e.g., `["ptr", "i32"]`)
- `return_type`: Return type string (e.g., `"i32"`, `"void"`)

**Supported callback types:**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - Signed integers
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - Unsigned integers
- `"f32"`, `"f64"` - Floating point
- `"ptr"` - Pointer
- `"void"` - No return value
- `"bool"` - Boolean

### Example: qsort

```hemlock
import "libc.so.6";
extern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;

// Comparison function for integers (ascending order)
fn compare_ints(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    if (va < vb) { return -1; }
    if (va > vb) { return 1; }
    return 0;
}

// Allocate array of 5 integers
let arr = alloc(20);  // 5 * 4 bytes
ptr_write_i32(arr, 5);
ptr_write_i32(ptr_offset(arr, 1, 4), 2);
ptr_write_i32(ptr_offset(arr, 2, 4), 8);
ptr_write_i32(ptr_offset(arr, 3, 4), 1);
ptr_write_i32(ptr_offset(arr, 4, 4), 9);

// Create callback and sort
let cmp = callback(compare_ints, ["ptr", "ptr"], "i32");
qsort(arr, 5, 4, cmp);

// Array is now sorted: [1, 2, 5, 8, 9]

// Clean up
callback_free(cmp);
free(arr);
```

### Pointer Helper Functions

Hemlock provides comprehensive helper functions for working with raw pointers. These are essential for FFI callbacks and direct memory manipulation.

#### Integer Type Helpers

| Function | Description |
|----------|-------------|
| `ptr_deref_i8(ptr)` | Dereference pointer, read i8 |
| `ptr_deref_i16(ptr)` | Dereference pointer, read i16 |
| `ptr_deref_i32(ptr)` | Dereference pointer, read i32 |
| `ptr_deref_i64(ptr)` | Dereference pointer, read i64 |
| `ptr_deref_u8(ptr)` | Dereference pointer, read u8 |
| `ptr_deref_u16(ptr)` | Dereference pointer, read u16 |
| `ptr_deref_u32(ptr)` | Dereference pointer, read u32 |
| `ptr_deref_u64(ptr)` | Dereference pointer, read u64 |
| `ptr_write_i8(ptr, value)` | Write i8 to pointer location |
| `ptr_write_i16(ptr, value)` | Write i16 to pointer location |
| `ptr_write_i32(ptr, value)` | Write i32 to pointer location |
| `ptr_write_i64(ptr, value)` | Write i64 to pointer location |
| `ptr_write_u8(ptr, value)` | Write u8 to pointer location |
| `ptr_write_u16(ptr, value)` | Write u16 to pointer location |
| `ptr_write_u32(ptr, value)` | Write u32 to pointer location |
| `ptr_write_u64(ptr, value)` | Write u64 to pointer location |

#### Float Type Helpers

| Function | Description |
|----------|-------------|
| `ptr_deref_f32(ptr)` | Dereference pointer, read f32 (float) |
| `ptr_deref_f64(ptr)` | Dereference pointer, read f64 (double) |
| `ptr_write_f32(ptr, value)` | Write f32 to pointer location |
| `ptr_write_f64(ptr, value)` | Write f64 to pointer location |

#### Pointer Type Helpers

| Function | Description |
|----------|-------------|
| `ptr_deref_ptr(ptr)` | Dereference pointer-to-pointer |
| `ptr_write_ptr(ptr, value)` | Write pointer to pointer location |
| `ptr_offset(ptr, index, size)` | Calculate offset: `ptr + index * size` |
| `ptr_read_i32(ptr)` | Read i32 through pointer-to-pointer (for qsort callbacks) |
| `ptr_null()` | Get a null pointer constant |

#### Buffer Conversion Helpers

| Function | Description |
|----------|-------------|
| `buffer_ptr(buffer)` | Get raw pointer from a buffer |
| `ptr_to_buffer(ptr, size)` | Copy data from pointer into a new buffer |

#### FFI Utility Functions

| Function | Description |
|----------|-------------|
| `ffi_sizeof(type_name)` | Get size in bytes of an FFI type |

**Supported type names for `ffi_sizeof`:**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - Signed integers (1, 2, 4, 8 bytes)
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - Unsigned integers (1, 2, 4, 8 bytes)
- `"f32"`, `"f64"` - Floats (4, 8 bytes)
- `"ptr"` - Pointer (8 bytes on 64-bit)
- `"size_t"`, `"usize"` - Platform-dependent size type
- `"intptr_t"`, `"isize"` - Platform-dependent signed pointer type

#### Example: Working with Different Types

```hemlock
let p = alloc(64);

// Write and read integers
ptr_write_i8(p, 42);
print(ptr_deref_i8(p));  // 42

ptr_write_i64(ptr_offset(p, 1, 8), 9000000000);
print(ptr_deref_i64(ptr_offset(p, 1, 8)));  // 9000000000

// Write and read floats
ptr_write_f64(p, 3.14159);
print(ptr_deref_f64(p));  // 3.14159

// Pointer-to-pointer
let inner = alloc(4);
ptr_write_i32(inner, 999);
ptr_write_ptr(p, inner);
let retrieved = ptr_deref_ptr(p);
print(ptr_deref_i32(retrieved));  // 999

// Get type sizes
print(ffi_sizeof("i64"));  // 8
print(ffi_sizeof("ptr"));  // 8 (on 64-bit)

// Buffer conversion
let buf = buffer(64);
ptr_write_i32(buffer_ptr(buf), 12345);
print(ptr_deref_i32(buffer_ptr(buf)));  // 12345

free(inner);
free(p);
```

### Freeing Callbacks

**Important:** Always free callbacks when done to prevent memory leaks:

```hemlock
let cb = callback(my_fn, ["ptr"], "void");
// ... use callback ...
callback_free(cb);  // Free when done
```

Callbacks are also automatically freed when the program exits.

### Closures in Callbacks

Callbacks capture their closure environment, so they can access outer scope variables:

```hemlock
let multiplier = 10;

fn scale(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    // Can access 'multiplier' from outer scope
    return (va * multiplier) - (vb * multiplier);
}

let cmp = callback(scale, ["ptr", "ptr"], "i32");
```

### Thread Safety

Callback invocations are serialized with a mutex to ensure thread safety, as the Hemlock interpreter is not fully thread-safe. This means:
- Only one callback can execute at a time
- Safe to use with multi-threaded C libraries
- May impact performance if callbacks are called very frequently from multiple threads

### Error Handling in Callbacks

Exceptions thrown in callbacks cannot propagate to C code. Instead:
- A warning is printed to stderr
- The callback returns a default value (0 or NULL)
- The exception is logged but not propagated

```hemlock
fn risky_callback(a: ptr): i32 {
    throw "Something went wrong";  // Warning printed, returns 0
}
```

For robust error handling, validate inputs and avoid throwing in callbacks.

## FFI Structs

Hemlock supports passing structs by value to C functions. Struct types are automatically registered for FFI when you define them with type annotations.

### Defining FFI-Compatible Structs

A struct is FFI-compatible when all fields have explicit type annotations using FFI-compatible types:

```hemlock
// FFI-compatible struct
define Point {
    x: f64,
    y: f64,
}

// FFI-compatible struct with multiple field types
define Rectangle {
    top_left: Point,      // Nested struct
    width: f64,
    height: f64,
}

// NOT FFI-compatible (field without type annotation)
define DynamicObject {
    name,                 // No type - not usable in FFI
    value,
}
```

### Using Structs in FFI

Declare extern functions that use struct types:

```hemlock
// Define the struct type
define Vector2D {
    x: f64,
    y: f64,
}

// Import the C library
import "libmath.so";

// Declare extern function that takes/returns structs
extern fn vector_add(a: Vector2D, b: Vector2D): Vector2D;
extern fn vector_length(v: Vector2D): f64;

// Use it naturally
let a: Vector2D = { x: 3.0, y: 0.0 };
let b: Vector2D = { x: 0.0, y: 4.0 };
let result = vector_add(a, b);
print(result.x);  // 3.0
print(result.y);  // 4.0

let len = vector_length(result);
print(len);       // 5.0
```

### Supported Field Types

Struct fields must use these FFI-compatible types:

| Hemlock Type | C Type | Size |
|--------------|--------|------|
| `i8` | `int8_t` | 1 byte |
| `i16` | `int16_t` | 2 bytes |
| `i32` | `int32_t` | 4 bytes |
| `i64` | `int64_t` | 8 bytes |
| `u8` | `uint8_t` | 1 byte |
| `u16` | `uint16_t` | 2 bytes |
| `u32` | `uint32_t` | 4 bytes |
| `u64` | `uint64_t` | 8 bytes |
| `f32` | `float` | 4 bytes |
| `f64` | `double` | 8 bytes |
| `ptr` | `void*` | 8 bytes |
| `string` | `char*` | 8 bytes |
| `bool` | `int` | varies |
| Nested struct | struct | varies |

### Struct Layout

Hemlock uses the platform's native struct layout rules (matching the C ABI):
- Fields are aligned according to their type
- Padding is inserted as needed
- Total size is padded to align the largest member

```hemlock
// Example: C-compatible layout
define Mixed {
    a: i8,    // offset 0, size 1
              // 3 bytes padding
    b: i32,   // offset 4, size 4
}
// Total size: 8 bytes (with padding)

define Point3D {
    x: f64,   // offset 0, size 8
    y: f64,   // offset 8, size 8
    z: f64,   // offset 16, size 8
}
// Total size: 24 bytes (no padding needed)
```

### Nested Structs

Structs can contain other structs:

```hemlock
define Inner {
    x: i32,
    y: i32,
}

define Outer {
    inner: Inner,
    z: i32,
}

import "mylib.so";
extern fn process_nested(data: Outer): i32;

let obj: Outer = {
    inner: { x: 1, y: 2 },
    z: 3,
};
let result = process_nested(obj);
```

### Struct Return Values

C functions can return structs:

```hemlock
define Point {
    x: f64,
    y: f64,
}

import "libmath.so";
extern fn get_origin(): Point;

let p = get_origin();
print(p.x);  // 0.0
print(p.y);  // 0.0
```

### Limitations

- **Struct fields must have type annotations** - fields without types are not FFI-compatible
- **No arrays in structs** - use pointers instead
- **No unions** - only struct types are supported
- **Callbacks cannot return structs** - use pointers for callback return values

### Exporting Struct Types

You can export struct type definitions from a module using `export define`:

```hemlock
// geometry.hml
export define Vector2 {
    x: f32,
    y: f32,
}

export define Rectangle {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
}

export fn create_rect(x: f32, y: f32, w: f32, h: f32): Rectangle {
    return { x: x, y: y, width: w, height: h };
}
```

**Important:** Exported struct types are registered **globally** when the module is loaded. They become available automatically when you import anything from the module. You do NOT need to (and cannot) explicitly import them by name:

```hemlock
// main.hml

// GOOD - struct types are auto-available after any import from the module
import { create_rect } from "./geometry.hml";
let v: Vector2 = { x: 1.0, y: 2.0 };      // Works - Vector2 is globally available
let r: Rectangle = create_rect(0.0, 0.0, 100.0, 50.0);  // Works

// BAD - cannot explicitly import struct types by name
import { Vector2 } from "./geometry.hml";  // Error: Undefined variable 'Vector2'
```

This behavior exists because struct types are registered in the global type registry when the module loads, rather than being stored as values in the module's export environment. The type becomes available to all code that imports from the module.

## Current Limitations

FFI has the following limitations:

**1. Manual Type Conversion**
- Must manually manage string conversions
- No automatic Hemlock string â†” C string conversion

**2. Limited Error Handling**
- Basic error reporting
- Exceptions in callbacks cannot propagate to C

**3. Manual Library Loading**
- Must manually load libraries
- No automatic binding generation

**4. Platform-Specific Code**
- Library paths differ by platform
- Must handle .so vs .dylib vs .dll

## Best Practices

While comprehensive FFI documentation is still being developed, here are general best practices:

### 1. Type Safety

```hemlock
// Be explicit about types
let x: i32 = 42;
let result: f64 = c_function(x);
```

### 2. Memory Management

```hemlock
// Remember to free allocated memory
let ptr = c_malloc(1024);
// ... use ptr
c_free(ptr);
```

### 3. Error Checking

```hemlock
// Check return values
let result = c_function();
if (result == null) {
    print("C function failed");
}
```

### 4. Platform Compatibility

```hemlock
// Handle platform differences
// Use appropriate library extensions (.so, .dylib, .dll)
```

## Examples

For working examples, refer to:
- Callback tests: `/tests/ffi_callbacks/` - qsort callback examples
- Stdlib FFI usage: `/stdlib/hash.hml`, `/stdlib/regex.hml`, `/stdlib/crypto.hml`
- Example programs: `/examples/` (if available)

## Getting Help

FFI is a newer feature in Hemlock. For questions or issues:

1. Check test suite for working examples
2. Refer to libffi documentation for low-level details
3. Report bugs or request features via project issues

## Summary

Hemlock's FFI provides:

- âœ… C function calling from shared libraries
- âœ… Primitive type support (i8-i64, u8-u64, f32, f64, ptr)
- âœ… Automatic type conversion
- âœ… libffi-based portability
- âœ… Foundation for native library integration
- âœ… **Function pointer callbacks** - pass Hemlock functions to C
- âœ… **Export extern functions** - share FFI bindings across modules
- âœ… **Struct passing and return** - pass C-compatible structs by value
- âœ… **Export define** - share struct type definitions across modules (auto-imported globally)
- âœ… **Complete pointer helpers** - read/write all types (i8-i64, u8-u64, f32, f64, ptr)
- âœ… **Buffer/pointer conversion** - `buffer_ptr()`, `ptr_to_buffer()` for data marshaling
- âœ… **FFI type sizes** - `ffi_sizeof()` for platform-aware type sizes
- âœ… **Platform types** - `size_t`, `usize`, `isize`, `intptr_t`, `uintptr_t` support

**Current status:** FFI fully featured with primitive types, structs, callbacks, module exports, and complete pointer helper functions

**Future:** String marshaling helpers

**Use cases:** System libraries, third-party libraries, qsort, event loops, callback-based APIs, reusable library wrappers

## Contributing

FFI documentation is being expanded. If you're working with FFI:
- Document your use cases
- Share example code
- Report issues or limitations
- Suggest improvements

The FFI system is designed to be practical and safe while providing low-level access when needed, following Hemlock's philosophy of "explicit over implicit" and "unsafe is a feature, not a bug."


--------------------------------------------------------------------------------
## File IO
--------------------------------------------------------------------------------

# File I/O in Hemlock

Hemlock provides a **File object API** for file operations with proper error handling and resource management.

## Table of Contents

- [Overview](#overview)
- [Opening Files](#opening-files)
- [File Methods](#file-methods)
- [File Properties](#file-properties)
- [Error Handling](#error-handling)
- [Resource Management](#resource-management)
- [Complete API Reference](#complete-api-reference)
- [Common Patterns](#common-patterns)
- [Best Practices](#best-practices)

## Overview

The File object API provides:

- **Explicit resource management** - Files must be manually closed
- **Multiple open modes** - Read, write, append, read/write
- **Text and binary operations** - Read/write both text and binary data
- **Seeking support** - Random access within files
- **Comprehensive error messages** - Context-aware error reporting

**Important:** Files are not automatically closed. You must call `f.close()` to avoid file descriptor leaks.

## Opening Files

Use `open(path, mode?)` to open a file:

```hemlock
let f = open("data.txt", "r");     // Read mode (default)
let f2 = open("output.txt", "w");  // Write mode (truncate)
let f3 = open("log.txt", "a");     // Append mode
let f4 = open("data.bin", "r+");   // Read/write mode
```

### Open Modes

| Mode | Description | File Must Exist | Truncates | Position |
|------|-------------|----------------|-----------|----------|
| `"r"` | Read (default) | Yes | No | Start |
| `"w"` | Write | No (creates) | Yes | Start |
| `"a"` | Append | No (creates) | No | End |
| `"r+"` | Read and write | Yes | No | Start |
| `"w+"` | Read and write | No (creates) | Yes | Start |
| `"a+"` | Read and append | No (creates) | No | End |

### Examples

**Reading an existing file:**
```hemlock
let f = open("config.json", "r");
// or simply:
let f = open("config.json");  // "r" is default
```

**Creating a new file for writing:**
```hemlock
let f = open("output.txt", "w");  // Creates or truncates
```

**Appending to a file:**
```hemlock
let f = open("log.txt", "a");  // Creates if doesn't exist
```

**Read and write mode:**
```hemlock
let f = open("data.bin", "r+");  // Existing file, can read/write
```

## File Methods

### Reading

#### read(size?: i32): string

Read text from file (optional size parameter).

**Without size (read all):**
```hemlock
let f = open("data.txt", "r");
let all = f.read();  // Read from current position to EOF
f.close();
```

**With size (read specific bytes):**
```hemlock
let f = open("data.txt", "r");
let chunk = f.read(1024);  // Read up to 1024 bytes
let next = f.read(1024);   // Read next 1024 bytes
f.close();
```

**Returns:** String containing the read data, or empty string if at EOF

**Example - Reading entire file:**
```hemlock
let f = open("poem.txt", "r");
let content = f.read();
print(content);
f.close();
```

**Example - Reading in chunks:**
```hemlock
let f = open("large.txt", "r");
while (true) {
    let chunk = f.read(4096);  // 4KB chunks
    if (chunk == "") { break; }  // EOF reached
    process(chunk);
}
f.close();
```

#### read_bytes(size: i32): buffer

Read binary data (returns buffer).

**Parameters:**
- `size` (i32) - Number of bytes to read

**Returns:** Buffer containing the read bytes

```hemlock
let f = open("image.png", "r");
let binary = f.read_bytes(256);  // Read 256 bytes
print(binary.length);  // 256 (or less if EOF)

// Access individual bytes
let first_byte = binary[0];
print(first_byte);

f.close();
```

**Example - Reading entire binary file:**
```hemlock
let f = open("data.bin", "r");
let size = 10240;  // Expected size
let data = f.read_bytes(size);
f.close();

// Process binary data
let i = 0;
while (i < data.length) {
    let byte = data[i];
    // ... process byte
    i = i + 1;
}
```

### Writing

#### write(data: string): i32

Write text to file (returns bytes written).

**Parameters:**
- `data` (string) - Text to write

**Returns:** Number of bytes written (i32)

```hemlock
let f = open("output.txt", "w");
let written = f.write("Hello, World!\n");
print("Wrote " + typeof(written) + " bytes");  // "Wrote 14 bytes"
f.close();
```

**Example - Writing multiple lines:**
```hemlock
let f = open("output.txt", "w");
f.write("Line 1\n");
f.write("Line 2\n");
f.write("Line 3\n");
f.close();
```

**Example - Appending to log file:**
```hemlock
let f = open("app.log", "a");
f.write("[INFO] Application started\n");
f.write("[INFO] User logged in\n");
f.close();
```

#### write_bytes(data: buffer): i32

Write binary data (returns bytes written).

**Parameters:**
- `data` (buffer) - Binary data to write

**Returns:** Number of bytes written (i32)

```hemlock
let f = open("output.bin", "w");

// Create binary data
let buf = buffer(10);
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

let bytes = f.write_bytes(buf);
print("Wrote " + typeof(bytes) + " bytes");

f.close();
```

**Example - Copying binary file:**
```hemlock
let src = open("input.bin", "r");
let dst = open("output.bin", "w");

let data = src.read_bytes(1024);
while (data.length > 0) {
    dst.write_bytes(data);
    data = src.read_bytes(1024);
}

src.close();
dst.close();
```

### Seeking

#### seek(position: i32): i32

Move to specific position (returns new position).

**Parameters:**
- `position` (i32) - Byte offset from beginning of file

**Returns:** New position (i32)

```hemlock
let f = open("data.txt", "r");

// Move to byte 100
f.seek(100);

// Read from position 100
let data = f.read(50);

// Reset to beginning
f.seek(0);

f.close();
```

**Example - Random access:**
```hemlock
let f = open("records.dat", "r");

// Read record at offset 1000
f.seek(1000);
let record1 = f.read_bytes(100);

// Read record at offset 2000
f.seek(2000);
let record2 = f.read_bytes(100);

f.close();
```

#### tell(): i32

Get current position in file.

**Returns:** Current byte offset (i32)

```hemlock
let f = open("data.txt", "r");

let pos1 = f.tell();  // 0 (at start)

f.read(100);
let pos2 = f.tell();  // 100 (after reading 100 bytes)

f.seek(500);
let pos3 = f.tell();  // 500 (after seeking)

f.close();
```

**Example - Measuring read amount:**
```hemlock
let f = open("data.txt", "r");

let start = f.tell();
let content = f.read();
let end = f.tell();

let bytes_read = end - start;
print("Read " + typeof(bytes_read) + " bytes");

f.close();
```

### Closing

#### close()

Close file (idempotent, can call multiple times).

```hemlock
let f = open("data.txt", "r");
// ... use file
f.close();
f.close();  // Safe - no error on second close
```

**Important notes:**
- Always close files when done to avoid file descriptor leaks
- Closing is idempotent - can call multiple times safely
- After closing, all other operations will error
- Use `finally` blocks to ensure files are closed even on errors

## File Properties

File objects have three read-only properties:

### path: string

The file path used to open the file.

```hemlock
let f = open("/path/to/file.txt", "r");
print(f.path);  // "/path/to/file.txt"
f.close();
```

### mode: string

The mode the file was opened with.

```hemlock
let f = open("data.txt", "r");
print(f.mode);  // "r"
f.close();

let f2 = open("output.txt", "w");
print(f2.mode);  // "w"
f2.close();
```

### closed: bool

Whether the file is closed.

```hemlock
let f = open("data.txt", "r");
print(f.closed);  // false

f.close();
print(f.closed);  // true
```

**Example - Checking if file is open:**
```hemlock
let f = open("data.txt", "r");

if (!f.closed) {
    let content = f.read();
    // ... process content
}

f.close();

if (f.closed) {
    print("File is now closed");
}
```

## Error Handling

All file operations include proper error messages with context.

### Common Errors

**File not found:**
```hemlock
let f = open("missing.txt", "r");
// Error: Failed to open 'missing.txt': No such file or directory
```

**Reading from closed file:**
```hemlock
let f = open("data.txt", "r");
f.close();
f.read();
// Error: Cannot read from closed file 'data.txt'
```

**Writing to read-only file:**
```hemlock
let f = open("readonly.txt", "r");
f.write("data");
// Error: Cannot write to file 'readonly.txt' opened in read-only mode
```

**Reading from write-only file:**
```hemlock
let f = open("output.txt", "w");
f.read();
// Error: Cannot read from file 'output.txt' opened in write-only mode
```

### Using try/catch

```hemlock
try {
    let f = open("data.txt", "r");
    let content = f.read();
    f.close();
    process(content);
} catch (e) {
    print("Error reading file: " + e);
}
```

## Resource Management

### Basic Pattern

Always close files explicitly:

```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();
```

### With Error Handling (Recommended)

Use `finally` to ensure files are closed even on errors:

```hemlock
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();  // Always close, even on error
}
```

### Multiple Files

```hemlock
let src = null;
let dst = null;

try {
    src = open("input.txt", "r");
    dst = open("output.txt", "w");

    let content = src.read();
    dst.write(content);
} finally {
    if (src != null) { src.close(); }
    if (dst != null) { dst.close(); }
}
```

### Helper Function Pattern

```hemlock
fn with_file(path: string, mode: string, callback) {
    let f = open(path, mode);
    try {
        return callback(f);
    } finally {
        f.close();
    }
}

// Usage:
with_file("data.txt", "r", fn(f) {
    return f.read();
});
```

## Complete API Reference

### Functions

| Function | Parameters | Returns | Description |
|----------|-----------|---------|-------------|
| `open(path, mode?)` | path: string, mode?: string | File | Open file (mode defaults to "r") |

### Methods

| Method | Parameters | Returns | Description |
|--------|-----------|---------|-------------|
| `read(size?)` | size?: i32 | string | Read text (all or specific bytes) |
| `read_bytes(size)` | size: i32 | buffer | Read binary data |
| `write(data)` | data: string | i32 | Write text, returns bytes written |
| `write_bytes(data)` | data: buffer | i32 | Write binary data, returns bytes written |
| `seek(position)` | position: i32 | i32 | Seek to position, returns new position |
| `tell()` | - | i32 | Get current position |
| `close()` | - | null | Close file (idempotent) |

### Properties (read-only)

| Property | Type | Description |
|----------|------|-------------|
| `path` | string | File path |
| `mode` | string | Open mode |
| `closed` | bool | Whether file is closed |

## Common Patterns

### Reading Entire File

```hemlock
fn read_file(path: string): string {
    let f = open(path, "r");
    try {
        return f.read();
    } finally {
        f.close();
    }
}

let content = read_file("config.json");
```

### Writing Entire File

```hemlock
fn write_file(path: string, content: string) {
    let f = open(path, "w");
    try {
        f.write(content);
    } finally {
        f.close();
    }
}

write_file("output.txt", "Hello, World!");
```

### Appending to File

```hemlock
fn append_file(path: string, content: string) {
    let f = open(path, "a");
    try {
        f.write(content);
    } finally {
        f.close();
    }
}

append_file("log.txt", "[INFO] Event occurred\n");
```

### Reading Lines

```hemlock
fn read_lines(path: string) {
    let f = open(path, "r");
    try {
        let content = f.read();
        return content.split("\n");
    } finally {
        f.close();
    }
}

let lines = read_lines("data.txt");
let i = 0;
while (i < lines.length) {
    print("Line " + typeof(i) + ": " + lines[i]);
    i = i + 1;
}
```

### Processing Large Files in Chunks

```hemlock
fn process_large_file(path: string) {
    let f = open(path, "r");
    try {
        while (true) {
            let chunk = f.read(4096);  // 4KB chunks
            if (chunk == "") { break; }

            // Process chunk
            process_chunk(chunk);
        }
    } finally {
        f.close();
    }
}
```

### Binary File Copy

```hemlock
fn copy_file(src_path: string, dst_path: string) {
    let src = null;
    let dst = null;

    try {
        src = open(src_path, "r");
        dst = open(dst_path, "w");

        while (true) {
            let chunk = src.read_bytes(4096);
            if (chunk.length == 0) { break; }

            dst.write_bytes(chunk);
        }
    } finally {
        if (src != null) { src.close(); }
        if (dst != null) { dst.close(); }
    }
}

copy_file("input.dat", "output.dat");
```

### File Truncation

```hemlock
fn truncate_file(path: string) {
    let f = open(path, "w");  // "w" mode truncates
    f.close();
}

truncate_file("empty_me.txt");
```

### Random Access Read

```hemlock
fn read_at_offset(path: string, offset: i32, size: i32): string {
    let f = open(path, "r");
    try {
        f.seek(offset);
        return f.read(size);
    } finally {
        f.close();
    }
}

let data = read_at_offset("records.dat", 1000, 100);
```

### File Size

```hemlock
fn file_size(path: string): i32 {
    let f = open(path, "r");
    try {
        // Seek to end
        let end = f.seek(999999999);  // Large number
        f.seek(0);  // Reset
        return end;
    } finally {
        f.close();
    }
}

let size = file_size("data.txt");
print("File size: " + typeof(size) + " bytes");
```

### Conditional Read/Write

```hemlock
fn update_file(path: string, condition, new_content: string) {
    let f = open(path, "r+");
    try {
        let content = f.read();

        if (condition(content)) {
            f.seek(0);  // Reset to beginning
            f.write(new_content);
        }
    } finally {
        f.close();
    }
}
```

## Best Practices

### 1. Always Use try/finally

```hemlock
// Good
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();
}

// Bad - file might not close on error
let f = open("data.txt", "r");
let content = f.read();
process(content);  // If this throws, file leaks
f.close();
```

### 2. Check File State Before Operations

```hemlock
let f = open("data.txt", "r");

if (!f.closed) {
    let content = f.read();
    // ... use content
}

f.close();
```

### 3. Use Appropriate Modes

```hemlock
// Reading only? Use "r"
let f = open("config.json", "r");

// Completely replacing? Use "w"
let f = open("output.txt", "w");

// Adding to end? Use "a"
let f = open("log.txt", "a");
```

### 4. Handle Errors Gracefully

```hemlock
fn safe_read_file(path: string): string {
    try {
        let f = open(path, "r");
        try {
            return f.read();
        } finally {
            f.close();
        }
    } catch (e) {
        print("Warning: Could not read " + path + ": " + e);
        return "";
    }
}
```

### 5. Close Files in Reverse Order of Opening

```hemlock
let f1 = null;
let f2 = null;
let f3 = null;

try {
    f1 = open("file1.txt", "r");
    f2 = open("file2.txt", "r");
    f3 = open("file3.txt", "r");

    // ... use files
} finally {
    // Close in reverse order
    if (f3 != null) { f3.close(); }
    if (f2 != null) { f2.close(); }
    if (f1 != null) { f1.close(); }
}
```

### 6. Avoid Reading Large Files Entirely

```hemlock
// Bad for large files
let f = open("huge.log", "r");
let content = f.read();  // Loads entire file into memory
f.close();

// Good - process in chunks
let f = open("huge.log", "r");
try {
    while (true) {
        let chunk = f.read(4096);
        if (chunk == "") { break; }
        process_chunk(chunk);
    }
} finally {
    f.close();
}
```

## Summary

Hemlock's File I/O API provides:

- âœ… Simple, explicit file operations
- âœ… Text and binary support
- âœ… Random access with seek/tell
- âœ… Clear error messages with context
- âœ… Idempotent close operation

Remember:
- Always close files manually
- Use try/finally for resource safety
- Choose appropriate open modes
- Handle errors gracefully
- Process large files in chunks


--------------------------------------------------------------------------------
## Profiling
--------------------------------------------------------------------------------

# Profiling

Hemlock includes a built-in profiler for **CPU time analysis**, **memory tracking**, and **leak detection**. The profiler helps identify performance bottlenecks and memory issues in your programs.

## Table of Contents

- [Overview](#overview)
- [Quick Start](#quick-start)
- [Profiling Modes](#profiling-modes)
- [Output Formats](#output-formats)
- [Leak Detection](#leak-detection)
- [Understanding Reports](#understanding-reports)
- [Flamegraph Generation](#flamegraph-generation)
- [Best Practices](#best-practices)

---

## Overview

The profiler is accessed via the `profile` subcommand:

```bash
hemlock profile [OPTIONS] <FILE>
```

**Key features:**
- **CPU profiling** - Measure time spent in each function (self-time and total-time)
- **Memory profiling** - Track all allocations with source locations
- **Leak detection** - Identify memory that was never freed
- **Multiple output formats** - Text, JSON, and flamegraph-compatible output
- **Per-function memory stats** - See which functions allocate the most memory

---

## Quick Start

### Profile CPU time (default)

```bash
hemlock profile script.hml
```

### Profile memory allocations

```bash
hemlock profile --memory script.hml
```

### Detect memory leaks

```bash
hemlock profile --leaks script.hml
```

### Generate flamegraph data

```bash
hemlock profile --flamegraph script.hml > profile.folded
flamegraph.pl profile.folded > profile.svg
```

---

## Profiling Modes

### CPU Profiling (default)

Measures time spent in each function, distinguishing between:
- **Self time** - Time spent executing the function's own code
- **Total time** - Self time plus time spent in called functions

```bash
hemlock profile script.hml
hemlock profile --cpu script.hml  # Explicit
```

**Example output:**
```
=== Hemlock Profiler Report ===

Total time: 1.234ms
Functions called: 5 unique

--- Top 5 by Self Time ---

Function                        Self      Total   Calls
--------                        ----      -----   -----
expensive_calc              0.892ms    0.892ms     100  (72.3%)
process_data                0.234ms    1.126ms      10  (19.0%)
helper                      0.067ms    0.067ms     500  (5.4%)
main                        0.041ms    1.234ms       1  (3.3%)
```

---

### Memory Profiling

Tracks all memory allocations (`alloc`, `buffer`, `talloc`, `realloc`) with source locations.

```bash
hemlock profile --memory script.hml
```

**Example output:**
```
=== Hemlock Profiler Report ===

Total time: 0.543ms
Functions called: 3 unique
Total allocations: 15 (4.2KB)

--- Top 3 by Self Time ---

Function                        Self      Total   Calls      Alloc      Count
--------                        ----      -----   -----      -----      -----
allocator                   0.312ms    0.312ms      10      3.2KB         10  (57.5%)
buffer_ops                  0.156ms    0.156ms       5       1KB          5  (28.7%)
main                        0.075ms    0.543ms       1        0B          0  (13.8%)

--- Top 10 Allocation Sites ---

Location                                      Total    Count
--------                                      -----    -----
src/data.hml:42                               1.5KB        5
src/data.hml:67                               1.0KB       10
src/main.hml:15                               512B         1
```

---

### Call Count Mode

Minimal overhead mode that only counts function calls (no timing).

```bash
hemlock profile --calls script.hml
```

---

## Output Formats

### Text (default)

Human-readable summary with tables.

```bash
hemlock profile script.hml
```

---

### JSON

Machine-readable format for integration with other tools.

```bash
hemlock profile --json script.hml
```

**Example output:**
```json
{
  "total_time_ns": 1234567,
  "function_count": 5,
  "total_alloc_bytes": 4096,
  "total_alloc_count": 15,
  "functions": [
    {
      "name": "expensive_calc",
      "source_file": "script.hml",
      "line": 10,
      "self_time_ns": 892000,
      "total_time_ns": 892000,
      "call_count": 100,
      "alloc_bytes": 0,
      "alloc_count": 0
    }
  ],
  "alloc_sites": [
    {
      "source_file": "script.hml",
      "line": 42,
      "total_bytes": 1536,
      "alloc_count": 5,
      "current_bytes": 0
    }
  ]
}
```

---

### Flamegraph

Generates collapsed stack format compatible with [flamegraph.pl](https://github.com/brendangregg/FlameGraph).

```bash
hemlock profile --flamegraph script.hml > profile.folded

# Generate SVG with flamegraph.pl
flamegraph.pl profile.folded > profile.svg
```

**Example folded output:**
```
main;process_data;expensive_calc 892
main;process_data;helper 67
main;process_data 234
main 41
```

---

## Leak Detection

The `--leaks` flag shows only allocations that were never freed, making it easy to identify memory leaks.

```bash
hemlock profile --leaks script.hml
```

**Example program with leaks:**
```hemlock
fn leaky() {
    let p1 = alloc(100);    // Leak - never freed
    let p2 = alloc(200);    // OK - freed below
    free(p2);
}

fn clean() {
    let b = buffer(64);
    free(b);                // Properly freed
}

leaky();
clean();
```

**Output with --leaks:**
```
=== Hemlock Profiler Report ===

Total time: 0.034ms
Functions called: 2 unique
Total allocations: 3 (388B)

--- Top 2 by Self Time ---

Function                        Self      Total   Calls      Alloc      Count
--------                        ----      -----   -----      -----      -----
leaky                       0.021ms    0.021ms       1       300B          2  (61.8%)
clean                       0.013ms    0.013ms       1        88B          1  (38.2%)

--- Memory Leaks (1 site) ---

Location                                     Leaked      Total    Count
--------                                     ------      -----    -----
script.hml:2                                   100B       100B        1
```

The leak report shows:
- **Leaked** - Bytes currently unfreed at program exit
- **Total** - Total bytes ever allocated at this site
- **Count** - Number of allocations at this site

---

## Understanding Reports

### Function Statistics

| Column | Description |
|--------|-------------|
| Function | Function name |
| Self | Time in function excluding callees |
| Total | Time including all called functions |
| Calls | Number of times function was called |
| Alloc | Total bytes allocated by this function |
| Count | Number of allocations by this function |
| (%) | Percentage of total program time |

### Allocation Sites

| Column | Description |
|--------|-------------|
| Location | Source file and line number |
| Total | Total bytes allocated at this location |
| Count | Number of allocations |
| Leaked | Bytes still allocated at program exit (--leaks only) |

### Time Units

The profiler automatically selects appropriate units:
- `ns` - Nanoseconds (< 1us)
- `us` - Microseconds (< 1ms)
- `ms` - Milliseconds (< 1s)
- `s` - Seconds

---

## Command Reference

```
hemlock profile [OPTIONS] <FILE>

OPTIONS:
    --cpu           CPU/time profiling (default)
    --memory        Memory allocation profiling
    --calls         Call count only (minimal overhead)
    --leaks         Show only unfreed allocations (implies --memory)
    --json          Output in JSON format
    --flamegraph    Output in flamegraph-compatible format
    --top N         Show top N entries (default: 20)
```

---

## Flamegraph Generation

Flamegraphs visualize where your program spends time, with wider bars indicating more time spent.

### Generate a Flamegraph

1. Install flamegraph.pl:
   ```bash
   git clone https://github.com/brendangregg/FlameGraph
   ```

2. Profile your program:
   ```bash
   hemlock profile --flamegraph script.hml > profile.folded
   ```

3. Generate SVG:
   ```bash
   ./FlameGraph/flamegraph.pl profile.folded > profile.svg
   ```

4. Open `profile.svg` in a browser for an interactive visualization.

### Reading Flamegraphs

- **X-axis**: Percentage of total time (width = time proportion)
- **Y-axis**: Call stack depth (bottom = entry point, top = leaf functions)
- **Color**: Random, for visual distinction only
- **Click**: Zoom into a function to see its callees

---

## Best Practices

### 1. Profile Representative Workloads

Profile with realistic data and usage patterns. Small test cases may not reveal real bottlenecks.

```bash
# Good: Profile with production-like data
hemlock profile --memory process_large_file.hml large_input.txt

# Less useful: Tiny test case
hemlock profile quick_test.hml
```

### 2. Use --leaks During Development

Run leak detection regularly to catch memory leaks early:

```bash
hemlock profile --leaks my_program.hml
```

### 3. Compare Before and After

Profile before and after optimizations to measure impact:

```bash
# Before optimization
hemlock profile --json script.hml > before.json

# After optimization
hemlock profile --json script.hml > after.json

# Compare results
```

### 4. Use --top for Large Programs

Limit output to focus on the most significant functions:

```bash
hemlock profile --top 10 large_program.hml
```

### 5. Combine with Flamegraphs

For complex call patterns, flamegraphs provide better visualization than text output:

```bash
hemlock profile --flamegraph complex_app.hml > app.folded
flamegraph.pl app.folded > app.svg
```

---

## Profiler Overhead

The profiler adds some overhead to program execution:

| Mode | Overhead | Use Case |
|------|----------|----------|
| `--calls` | Minimal | Just counting function calls |
| `--cpu` | Low | General performance profiling |
| `--memory` | Moderate | Memory analysis and leak detection |

For the most accurate results, profile multiple times and look for consistent patterns.

---

## See Also

- [Memory Management](#language-guide-memory) - Pointers and buffers
- [Memory API](#reference-memory-api) - alloc, free, buffer functions
- [Async/Concurrency](#advanced-async-concurrency) - Profiling async code


--------------------------------------------------------------------------------
## Signals
--------------------------------------------------------------------------------

# Signal Handling in Hemlock

Hemlock provides **POSIX signal handling** for managing system signals like SIGINT (Ctrl+C), SIGTERM, and custom signals. This enables low-level process control and inter-process communication.

## Table of Contents

- [Overview](#overview)
- [Signal API](#signal-api)
- [Signal Constants](#signal-constants)
- [Basic Signal Handling](#basic-signal-handling)
- [Advanced Patterns](#advanced-patterns)
- [Signal Handler Behavior](#signal-handler-behavior)
- [Safety Considerations](#safety-considerations)
- [Common Use Cases](#common-use-cases)
- [Complete Examples](#complete-examples)

## Overview

Signal handling allows programs to:
- Respond to user interrupts (Ctrl+C, Ctrl+Z)
- Implement graceful shutdown
- Handle termination requests
- Use custom signals for inter-process communication
- Create alarm/timer mechanisms

**Important:** Signal handling is **inherently unsafe** in Hemlock's philosophy. Handlers can be called at any time, interrupting normal execution. The user is responsible for proper synchronization.

## Signal API

### signal(signum, handler_fn)

Register a signal handler function.

**Parameters:**
- `signum` (i32) - Signal number (constant like SIGINT, SIGTERM)
- `handler_fn` (function or null) - Function to call when signal is received, or `null` to reset to default

**Returns:** The previous handler function (or `null` if none)

**Example:**
```hemlock
fn my_handler(sig) {
    print("Caught signal: " + typeof(sig));
}

let old_handler = signal(SIGINT, my_handler);
```

**Resetting to default:**
```hemlock
signal(SIGINT, null);  // Reset SIGINT to default behavior
```

### raise(signum)

Send a signal to the current process.

**Parameters:**
- `signum` (i32) - Signal number to send

**Returns:** `null`

**Example:**
```hemlock
raise(SIGUSR1);  // Trigger SIGUSR1 handler
```

## Signal Constants

Hemlock provides standard POSIX signal constants as i32 values.

### Interrupt & Termination

| Constant | Value | Description | Common Trigger |
|----------|-------|-------------|----------------|
| `SIGINT` | 2 | Interrupt from keyboard | Ctrl+C |
| `SIGTERM` | 15 | Termination request | `kill` command |
| `SIGQUIT` | 3 | Quit from keyboard | Ctrl+\ |
| `SIGHUP` | 1 | Hangup detected | Terminal closed |
| `SIGABRT` | 6 | Abort signal | `abort()` function |

**Examples:**
```hemlock
signal(SIGINT, handle_interrupt);   // Ctrl+C
signal(SIGTERM, handle_terminate);  // kill command
signal(SIGHUP, handle_hangup);      // Terminal closes
```

### User-Defined Signals

| Constant | Value | Description | Use Case |
|----------|-------|-------------|----------|
| `SIGUSR1` | 10 | User-defined signal 1 | Custom IPC |
| `SIGUSR2` | 12 | User-defined signal 2 | Custom IPC |

**Examples:**
```hemlock
// Use for custom communication
signal(SIGUSR1, reload_config);
signal(SIGUSR2, rotate_logs);
```

### Process Control

| Constant | Value | Description | Notes |
|----------|-------|-------------|-------|
| `SIGALRM` | 14 | Alarm clock timer | After `alarm()` |
| `SIGCHLD` | 17 | Child process status change | Process management |
| `SIGCONT` | 18 | Continue if stopped | Resume after SIGSTOP |
| `SIGSTOP` | 19 | Stop process | **Cannot be caught** |
| `SIGTSTP` | 20 | Terminal stop | Ctrl+Z |

**Examples:**
```hemlock
signal(SIGALRM, handle_timeout);
signal(SIGCHLD, handle_child_exit);
```

### I/O Signals

| Constant | Value | Description | When Sent |
|----------|-------|-------------|-----------|
| `SIGPIPE` | 13 | Broken pipe | Write to closed pipe |
| `SIGTTIN` | 21 | Background read from terminal | BG process reads TTY |
| `SIGTTOU` | 22 | Background write to terminal | BG process writes TTY |

**Examples:**
```hemlock
signal(SIGPIPE, handle_broken_pipe);
```

## Basic Signal Handling

### Catching Ctrl+C

```hemlock
let interrupted = false;

fn handle_interrupt(sig) {
    print("Caught SIGINT!");
    interrupted = true;
}

signal(SIGINT, handle_interrupt);

// Program continues running...
// User presses Ctrl+C -> handle_interrupt() is called

while (!interrupted) {
    // Do work...
}

print("Exiting due to interrupt");
```

### Handler Function Signature

Signal handlers receive one argument: the signal number (i32)

```hemlock
fn my_handler(signum) {
    print("Received signal: " + typeof(signum));
    // signum contains the signal number (e.g., 2 for SIGINT)

    if (signum == SIGINT) {
        print("This is SIGINT");
    }
}

signal(SIGINT, my_handler);
signal(SIGTERM, my_handler);  // Same handler for multiple signals
```

### Multiple Signal Handlers

Different handlers for different signals:

```hemlock
fn handle_int(sig) {
    print("SIGINT received");
}

fn handle_term(sig) {
    print("SIGTERM received");
}

fn handle_usr1(sig) {
    print("SIGUSR1 received");
}

signal(SIGINT, handle_int);
signal(SIGTERM, handle_term);
signal(SIGUSR1, handle_usr1);
```

### Resetting to Default Behavior

Pass `null` as the handler to reset to default behavior:

```hemlock
// Register custom handler
signal(SIGINT, my_handler);

// Later, reset to default (terminate on SIGINT)
signal(SIGINT, null);
```

### Raising Signals Manually

Send signals to your own process:

```hemlock
let count = 0;

fn increment(sig) {
    count = count + 1;
}

signal(SIGUSR1, increment);

// Trigger handler manually
raise(SIGUSR1);
raise(SIGUSR1);

print(count);  // 2
```

## Advanced Patterns

### Graceful Shutdown Pattern

Common pattern for cleanup on termination:

```hemlock
let should_exit = false;

fn handle_shutdown(sig) {
    print("Shutting down gracefully...");
    should_exit = true;
}

signal(SIGINT, handle_shutdown);
signal(SIGTERM, handle_shutdown);

// Main loop
while (!should_exit) {
    // Do work...
    // Check should_exit flag periodically
}

print("Cleanup complete");
```

### Signal Counter

Track number of signals received:

```hemlock
let signal_count = 0;

fn count_signals(sig) {
    signal_count = signal_count + 1;
    print("Received " + typeof(signal_count) + " signals");
}

signal(SIGUSR1, count_signals);

// Later...
print("Total signals: " + typeof(signal_count));
```

### Configuration Reload on Signal

```hemlock
let config = load_config();

fn reload_config(sig) {
    print("Reloading configuration...");
    config = load_config();
    print("Configuration reloaded");
}

signal(SIGHUP, reload_config);  // Reload on SIGHUP

// Send SIGHUP to process to reload config
// From shell: kill -HUP <pid>
```

### Timeout Using SIGALRM

```hemlock
let timed_out = false;

fn handle_alarm(sig) {
    print("Timeout!");
    timed_out = true;
}

signal(SIGALRM, handle_alarm);

// Set alarm (not yet implemented in Hemlock, example only)
// alarm(5);  // 5 second timeout

while (!timed_out) {
    // Do work with timeout
}
```

### Signal-Based State Machine

```hemlock
let state = 0;

fn next_state(sig) {
    state = (state + 1) % 3;
    print("State: " + typeof(state));
}

fn prev_state(sig) {
    state = (state - 1 + 3) % 3;
    print("State: " + typeof(state));
}

signal(SIGUSR1, next_state);  // Advance state
signal(SIGUSR2, prev_state);  // Go back

// Control state machine:
// kill -USR1 <pid>  # Next state
// kill -USR2 <pid>  # Previous state
```

## Signal Handler Behavior

### Important Notes

**Handler Execution:**
- Handlers are called **synchronously** when the signal is received
- Handlers execute in the current process context
- Signal handlers share the closure environment of the function they're defined in
- Handlers can access and modify outer scope variables (like globals or captured variables)

**Best Practices:**
- Keep handlers simple and quick - avoid long-running operations
- Set flags rather than performing complex logic
- Avoid calling functions that might take locks
- Be aware that handlers can interrupt any operation

### What Signals Can Be Caught

**Can catch and handle:**
- SIGINT, SIGTERM, SIGUSR1, SIGUSR2, SIGHUP, SIGQUIT
- SIGALRM, SIGCHLD, SIGCONT, SIGTSTP
- SIGPIPE, SIGTTIN, SIGTTOU
- SIGABRT (but program will abort after handler returns)

**Cannot catch:**
- `SIGKILL` (9) - Always terminates process
- `SIGSTOP` (19) - Always stops process

**System-dependent:**
- Some signals have default behaviors that may differ by system
- Check your platform's signal documentation for specifics

### Handler Limitations

```hemlock
fn complex_handler(sig) {
    // Avoid these in signal handlers:

    // âŒ Long-running operations
    // process_large_file();

    // âŒ Blocking I/O
    // let f = open("log.txt", "a");
    // f.write("Signal received\n");

    // âŒ Complex state changes
    // rebuild_entire_data_structure();

    // âœ… Simple flag setting is safe
    let should_stop = true;

    // âœ… Simple counter updates are usually safe
    let signal_count = signal_count + 1;
}
```

## Safety Considerations

Signal handling is **inherently unsafe** in Hemlock's philosophy.

### Race Conditions

Handlers can be called at any time, interrupting normal execution:

```hemlock
let counter = 0;

fn increment(sig) {
    counter = counter + 1;  // Race condition if called during counter update
}

signal(SIGUSR1, increment);

// Main code also modifies counter
counter = counter + 1;  // Could be interrupted by signal handler
```

**Problem:** If signal arrives while main code is updating `counter`, the result is unpredictable.

### Async-Signal-Safety

Hemlock does **not** guarantee async-signal-safety:
- Handlers can call any Hemlock code (unlike C's restricted async-signal-safe functions)
- This provides flexibility but requires user caution
- Race conditions are possible if handler modifies shared state

### Best Practices for Safe Signal Handling

**1. Use Atomic Flags**

Simple boolean assignments are generally safe:

```hemlock
let should_exit = false;

fn handler(sig) {
    should_exit = true;  // Simple assignment is safe
}

signal(SIGINT, handler);

while (!should_exit) {
    // work...
}
```

**2. Minimize Shared State**

```hemlock
let interrupt_count = 0;

fn handler(sig) {
    // Only modify this one variable
    interrupt_count = interrupt_count + 1;
}
```

**3. Defer Complex Operations**

```hemlock
let pending_reload = false;

fn signal_reload(sig) {
    pending_reload = true;  // Just set flag
}

signal(SIGHUP, signal_reload);

// In main loop:
while (true) {
    if (pending_reload) {
        reload_config();  // Do complex work here
        pending_reload = false;
    }

    // Normal work...
}
```

**4. Avoid Re-entrancy Issues**

```hemlock
let in_critical_section = false;
let data = [];

fn careful_handler(sig) {
    if (in_critical_section) {
        // Don't modify data while main code is using it
        return;
    }
    // Safe to proceed
}
```

## Common Use Cases

### 1. Graceful Server Shutdown

```hemlock
let running = true;

fn shutdown(sig) {
    print("Shutdown signal received");
    running = false;
}

signal(SIGINT, shutdown);
signal(SIGTERM, shutdown);

// Server main loop
while (running) {
    handle_client_request();
}

cleanup_resources();
print("Server stopped");
```

### 2. Configuration Reload (Without Restart)

```hemlock
let config = load_config("app.conf");
let reload_needed = false;

fn trigger_reload(sig) {
    reload_needed = true;
}

signal(SIGHUP, trigger_reload);

while (true) {
    if (reload_needed) {
        print("Reloading configuration...");
        config = load_config("app.conf");
        reload_needed = false;
    }

    // Use config...
}
```

### 3. Log Rotation

```hemlock
let log_file = open("app.log", "a");
let rotate_needed = false;

fn trigger_rotate(sig) {
    rotate_needed = true;
}

signal(SIGUSR1, trigger_rotate);

while (true) {
    if (rotate_needed) {
        log_file.close();
        // Rename old log, open new one
        exec("mv app.log app.log.old");
        log_file = open("app.log", "a");
        rotate_needed = false;
    }

    // Normal logging...
    log_file.write("Log entry\n");
}
```

### 4. Status Reporting

```hemlock
let requests_handled = 0;

fn report_status(sig) {
    print("Status: " + typeof(requests_handled) + " requests handled");
}

signal(SIGUSR1, report_status);

while (true) {
    handle_request();
    requests_handled = requests_handled + 1;
}

// From shell: kill -USR1 <pid>
```

### 5. Debug Mode Toggle

```hemlock
let debug_mode = false;

fn toggle_debug(sig) {
    debug_mode = !debug_mode;
    if (debug_mode) {
        print("Debug mode: ON");
    } else {
        print("Debug mode: OFF");
    }
}

signal(SIGUSR2, toggle_debug);

// From shell: kill -USR2 <pid> to toggle
```

## Complete Examples

### Example 1: Interrupt Handler with Cleanup

```hemlock
let running = true;
let signal_count = 0;

fn handle_signal(signum) {
    signal_count = signal_count + 1;

    if (signum == SIGINT) {
        print("Interrupt detected (Ctrl+C)");
        running = false;
    }

    if (signum == SIGUSR1) {
        print("User signal 1 received");
    }
}

// Register handlers
signal(SIGINT, handle_signal);
signal(SIGUSR1, handle_signal);

// Simulate some work
let i = 0;
while (running && i < 100) {
    print("Working... " + typeof(i));

    // Trigger SIGUSR1 every 10 iterations
    if (i == 10 || i == 20) {
        raise(SIGUSR1);
    }

    i = i + 1;
}

print("Total signals received: " + typeof(signal_count));
```

### Example 2: Multi-Signal State Machine

```hemlock
let state = "idle";
let request_count = 0;

fn start_processing(sig) {
    state = "processing";
    print("State: " + state);
}

fn stop_processing(sig) {
    state = "idle";
    print("State: " + state);
}

fn report_stats(sig) {
    print("State: " + state);
    print("Requests: " + typeof(request_count));
}

signal(SIGUSR1, start_processing);
signal(SIGUSR2, stop_processing);
signal(SIGHUP, report_stats);

while (true) {
    if (state == "processing") {
        // Do work
        request_count = request_count + 1;
    }

    // Check every iteration...
}
```

### Example 3: Worker Pool Controller

```hemlock
let worker_count = 4;
let should_exit = false;

fn increase_workers(sig) {
    worker_count = worker_count + 1;
    print("Workers: " + typeof(worker_count));
}

fn decrease_workers(sig) {
    if (worker_count > 1) {
        worker_count = worker_count - 1;
    }
    print("Workers: " + typeof(worker_count));
}

fn shutdown(sig) {
    print("Shutting down...");
    should_exit = true;
}

signal(SIGUSR1, increase_workers);
signal(SIGUSR2, decrease_workers);
signal(SIGINT, shutdown);
signal(SIGTERM, shutdown);

// Main loop adjusts worker pool based on worker_count
while (!should_exit) {
    // Manage workers based on worker_count
    // ...
}
```

### Example 4: Timeout Pattern

```hemlock
let operation_complete = false;
let timed_out = false;

fn timeout_handler(sig) {
    timed_out = true;
}

signal(SIGALRM, timeout_handler);

// Start long operation
async fn long_operation() {
    // ... work
    operation_complete = true;
}

let task = spawn(long_operation);

// Wait with timeout (manual check)
let elapsed = 0;
while (!operation_complete && elapsed < 1000) {
    // Sleep or check
    elapsed = elapsed + 1;
}

if (!operation_complete) {
    print("Operation timed out");
    detach(task);  // Give up waiting
} else {
    join(task);
    print("Operation completed");
}
```

## Debugging Signal Handlers

### Add Diagnostic Prints

```hemlock
fn debug_handler(sig) {
    print("Handler called for signal: " + typeof(sig));
    print("Stack: (not yet available)");

    // Your handler logic...
}

signal(SIGINT, debug_handler);
```

### Count Signal Calls

```hemlock
let handler_calls = 0;

fn counting_handler(sig) {
    handler_calls = handler_calls + 1;
    print("Handler call #" + typeof(handler_calls));

    // Your handler logic...
}
```

### Test with raise()

```hemlock
fn test_handler(sig) {
    print("Test signal received: " + typeof(sig));
}

signal(SIGUSR1, test_handler);

// Test by manually raising
raise(SIGUSR1);
print("Handler should have been called");
```

## Summary

Hemlock's signal handling provides:

- âœ… POSIX signal handling for low-level process control
- âœ… 15 standard signal constants
- âœ… Simple signal() and raise() API
- âœ… Flexible handler functions with closure support
- âœ… Multiple signals can share handlers

Remember:
- Signal handling is inherently unsafe - use with caution
- Keep handlers simple and fast
- Use flags for state changes, not complex operations
- Handlers can interrupt execution at any time
- Cannot catch SIGKILL or SIGSTOP
- Test handlers thoroughly with raise()

Common patterns:
- Graceful shutdown (SIGINT, SIGTERM)
- Configuration reload (SIGHUP)
- Log rotation (SIGUSR1)
- Status reporting (SIGUSR1/SIGUSR2)
- Debug mode toggle (SIGUSR2)



################################################################################
# API REFERENCE
################################################################################

--------------------------------------------------------------------------------
## Array API
--------------------------------------------------------------------------------

# Array API Reference

Complete reference for Hemlock's array type and all 18 array methods.

---

## Overview

Arrays in Hemlock are **dynamic, heap-allocated** sequences that can hold mixed types. They provide comprehensive methods for data manipulation and processing.

**Key Features:**
- Dynamic sizing (automatic growth)
- Zero-indexed
- Mixed types allowed
- 18 built-in methods
- Heap-allocated with capacity tracking

---

## Array Type

**Type:** `array`

**Properties:**
- `.length` - Number of elements (i32)

**Literal Syntax:** Square brackets `[elem1, elem2, ...]`

**Examples:**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);     // 5

// Mixed types
let mixed = [1, "hello", true, null];
print(mixed.length);   // 4

// Empty array
let empty = [];
print(empty.length);   // 0
```

---

## Indexing

Arrays support zero-based indexing using `[]`:

**Read Access:**
```hemlock
let arr = [10, 20, 30];
print(arr[0]);         // 10
print(arr[1]);         // 20
print(arr[2]);         // 30
```

**Write Access:**
```hemlock
let arr = [10, 20, 30];
arr[0] = 99;
arr[1] = 88;
print(arr);            // [99, 88, 30]
```

**Note:** Direct indexing has no bounds checking. Use methods for safety.

---

## Array Properties

### .length

Get the number of elements in the array.

**Type:** `i32`

**Examples:**
```hemlock
let arr = [1, 2, 3];
print(arr.length);     // 3

let empty = [];
print(empty.length);   // 0

// Length changes dynamically
arr.push(4);
print(arr.length);     // 4

arr.pop();
print(arr.length);     // 3
```

---

## Array Methods

### Stack Operations

#### push

Add element to end of array.

**Signature:**
```hemlock
array.push(value: any): null
```

**Parameters:**
- `value` - Element to add

**Returns:** `null`

**Mutates:** Yes (modifies array in place)

**Examples:**
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]
arr.push("hello");     // [1, 2, 3, 4, 5, "hello"]
```

---

#### pop

Remove and return last element.

**Signature:**
```hemlock
array.pop(): any
```

**Returns:** Last element (removed from array)

**Mutates:** Yes (modifies array in place)

**Examples:**
```hemlock
let arr = [1, 2, 3];
let last = arr.pop();  // 3
print(arr);            // [1, 2]

let last2 = arr.pop(); // 2
print(arr);            // [1]
```

**Error:** Runtime error if array is empty.

---

### Queue Operations

#### shift

Remove and return first element.

**Signature:**
```hemlock
array.shift(): any
```

**Returns:** First element (removed from array)

**Mutates:** Yes (modifies array in place)

**Examples:**
```hemlock
let arr = [1, 2, 3];
let first = arr.shift();  // 1
print(arr);               // [2, 3]

let first2 = arr.shift(); // 2
print(arr);               // [3]
```

**Error:** Runtime error if array is empty.

---

#### unshift

Add element to beginning of array.

**Signature:**
```hemlock
array.unshift(value: any): null
```

**Parameters:**
- `value` - Element to add

**Returns:** `null`

**Mutates:** Yes (modifies array in place)

**Examples:**
```hemlock
let arr = [2, 3];
arr.unshift(1);        // [1, 2, 3]
arr.unshift(0);        // [0, 1, 2, 3]
```

---

### Insertion & Removal

#### insert

Insert element at specific index.

**Signature:**
```hemlock
array.insert(index: i32, value: any): null
```

**Parameters:**
- `index` - Position to insert at (0-based)
- `value` - Element to insert

**Returns:** `null`

**Mutates:** Yes (modifies array in place)

**Examples:**
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // [1, 2, 3, 4, 5]

let arr2 = [1, 3];
arr2.insert(1, 2);     // [1, 2, 3]

// Insert at end
arr2.insert(arr2.length, 4);  // [1, 2, 3, 4]
```

**Behavior:** Shifts elements at and after index to the right.

---

#### remove

Remove and return element at index.

**Signature:**
```hemlock
array.remove(index: i32): any
```

**Parameters:**
- `index` - Position to remove from (0-based)

**Returns:** Removed element

**Mutates:** Yes (modifies array in place)

**Examples:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let removed = arr.remove(0);  // 1
print(arr);                   // [2, 3, 4, 5]

let removed2 = arr.remove(2); // 4
print(arr);                   // [2, 3, 5]
```

**Behavior:** Shifts elements after index to the left.

**Error:** Runtime error if index out of bounds.

---

### Search & Find

#### find

Find first occurrence of value.

**Signature:**
```hemlock
array.find(value: any): i32
```

**Parameters:**
- `value` - Value to search for

**Returns:** Index of first occurrence, or `-1` if not found

**Examples:**
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2
let idx2 = arr.find(99);     // -1 (not found)

// Find first duplicate
let arr2 = [1, 2, 3, 2, 4];
let idx3 = arr2.find(2);     // 1 (first occurrence)
```

**Comparison:** Uses value equality for primitives and strings.

---

#### contains

Check if array contains value.

**Signature:**
```hemlock
array.contains(value: any): bool
```

**Parameters:**
- `value` - Value to search for

**Returns:** `true` if found, `false` otherwise

**Examples:**
```hemlock
let arr = [10, 20, 30, 40];
let has = arr.contains(20);  // true
let has2 = arr.contains(99); // false

// Works with strings
let words = ["hello", "world"];
let has3 = words.contains("hello");  // true
```

---

### Slicing & Extraction

#### slice

Extract subarray by range (end exclusive).

**Signature:**
```hemlock
array.slice(start: i32, end: i32): array
```

**Parameters:**
- `start` - Starting index (0-based, inclusive)
- `end` - Ending index (exclusive)

**Returns:** New array with elements from [start, end)

**Mutates:** No (returns new array)

**Examples:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);   // [2, 3, 4]
let first_three = arr.slice(0, 3);  // [1, 2, 3]
let last_two = arr.slice(3, 5);     // [4, 5]

// Empty slice
let empty = arr.slice(2, 2); // []
```

---

#### first

Get first element without removing.

**Signature:**
```hemlock
array.first(): any
```

**Returns:** First element

**Mutates:** No

**Examples:**
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1
print(arr);                  // [1, 2, 3] (unchanged)
```

**Error:** Runtime error if array is empty.

---

#### last

Get last element without removing.

**Signature:**
```hemlock
array.last(): any
```

**Returns:** Last element

**Mutates:** No

**Examples:**
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3
print(arr);                  // [1, 2, 3] (unchanged)
```

**Error:** Runtime error if array is empty.

---

### Array Manipulation

#### reverse

Reverse array in place.

**Signature:**
```hemlock
array.reverse(): null
```

**Returns:** `null`

**Mutates:** Yes (modifies array in place)

**Examples:**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]
print(arr);                  // [5, 4, 3, 2, 1]

let words = ["hello", "world"];
words.reverse();             // ["world", "hello"]
```

---

#### clear

Remove all elements from array.

**Signature:**
```hemlock
array.clear(): null
```

**Returns:** `null`

**Mutates:** Yes (modifies array in place)

**Examples:**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();
print(arr);                  // []
print(arr.length);           // 0
```

---

### Array Combination

#### concat

Concatenate with another array.

**Signature:**
```hemlock
array.concat(other: array): array
```

**Parameters:**
- `other` - Array to concatenate

**Returns:** New array with elements from both arrays

**Mutates:** No (returns new array)

**Examples:**
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]
print(a);                    // [1, 2, 3] (unchanged)
print(b);                    // [4, 5, 6] (unchanged)

// Chain concatenations
let c = [7, 8];
let all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]
```

---

### Functional Operations

#### map

Transform each element using a callback function.

**Signature:**
```hemlock
array.map(callback: fn): array
```

**Parameters:**
- `callback` - Function that takes an element and returns transformed value

**Returns:** New array with transformed elements

**Mutates:** No (returns new array)

**Examples:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let doubled = arr.map(fn(x) { return x * 2; });
print(doubled);  // [2, 4, 6, 8, 10]

let names = ["alice", "bob"];
let upper = names.map(fn(s) { return s.to_upper(); });
print(upper);  // ["ALICE", "BOB"]
```

---

#### filter

Select elements that match a predicate.

**Signature:**
```hemlock
array.filter(predicate: fn): array
```

**Parameters:**
- `predicate` - Function that takes an element and returns bool

**Returns:** New array with elements where predicate returned true

**Mutates:** No (returns new array)

**Examples:**
```hemlock
let arr = [1, 2, 3, 4, 5, 6];
let evens = arr.filter(fn(x) { return x % 2 == 0; });
print(evens);  // [2, 4, 6]

let words = ["hello", "hi", "hey", "goodbye"];
let short = words.filter(fn(s) { return s.length < 4; });
print(short);  // ["hi", "hey"]
```

---

#### reduce

Reduce array to single value using accumulator.

**Signature:**
```hemlock
array.reduce(callback: fn, initial: any): any
```

**Parameters:**
- `callback` - Function that takes (accumulator, element) and returns new accumulator
- `initial` - Starting value for the accumulator

**Returns:** Final accumulated value

**Mutates:** No

**Examples:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sum = arr.reduce(fn(acc, x) { return acc + x; }, 0);
print(sum);  // 15

let product = arr.reduce(fn(acc, x) { return acc * x; }, 1);
print(product);  // 120

// Find max value
let max = arr.reduce(fn(acc, x) {
    if (x > acc) { return x; }
    return acc;
}, arr[0]);
print(max);  // 5
```

---

### String Conversion

#### join

Join elements into string with delimiter.

**Signature:**
```hemlock
array.join(delimiter: string): string
```

**Parameters:**
- `delimiter` - String to place between elements

**Returns:** String with all elements joined

**Examples:**
```hemlock
let words = ["hello", "world", "foo"];
let joined = words.join(" ");  // "hello world foo"

let numbers = [1, 2, 3];
let csv = numbers.join(",");   // "1,2,3"

// Works with mixed types
let mixed = [1, "hello", true, null];
print(mixed.join(" | "));  // "1 | hello | true | null"

// Empty delimiter
let arr = ["a", "b", "c"];
let s = arr.join("");          // "abc"
```

**Behavior:** Automatically converts all elements to strings.

---

## Method Chaining

Array methods can be chained for concise operations:

**Examples:**
```hemlock
// Chain slice and join
let result = ["apple", "banana", "cherry", "date"]
    .slice(0, 2)
    .join(" and ");  // "apple and banana"

// Chain concat and slice
let combined = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);    // [3, 4, 5]

// Complex chaining
let words = ["hello", "world", "foo", "bar"];
let result2 = words
    .slice(0, 3)
    .concat(["baz"])
    .join("-");      // "hello-world-foo-baz"
```

---

## Complete Method Summary

### Mutating Methods

Methods that modify the array in place:

| Method     | Signature                  | Returns   | Description                    |
|------------|----------------------------|-----------|--------------------------------|
| `push`     | `(value: any)`             | `null`    | Add to end                     |
| `pop`      | `()`                       | `any`     | Remove from end                |
| `shift`    | `()`                       | `any`     | Remove from start              |
| `unshift`  | `(value: any)`             | `null`    | Add to start                   |
| `insert`   | `(index: i32, value: any)` | `null`    | Insert at index                |
| `remove`   | `(index: i32)`             | `any`     | Remove at index                |
| `reverse`  | `()`                       | `null`    | Reverse in place               |
| `clear`    | `()`                       | `null`    | Remove all elements            |

### Non-Mutating Methods

Methods that return new values without modifying the original:

| Method     | Signature                  | Returns   | Description                    |
|------------|----------------------------|-----------|--------------------------------|
| `find`     | `(value: any)`             | `i32`     | Find first occurrence          |
| `contains` | `(value: any)`             | `bool`    | Check if contains value        |
| `slice`    | `(start: i32, end: i32)`   | `array`   | Extract subarray               |
| `first`    | `()`                       | `any`     | Get first element              |
| `last`     | `()`                       | `any`     | Get last element               |
| `concat`   | `(other: array)`           | `array`   | Concatenate arrays             |
| `join`     | `(delimiter: string)`      | `string`  | Join elements into string      |
| `map`      | `(callback: fn)`           | `array`   | Transform each element         |
| `filter`   | `(predicate: fn)`          | `array`   | Select matching elements       |
| `reduce`   | `(callback: fn, initial: any)` | `any` | Reduce to single value         |

---

## Usage Patterns

### Stack Usage

```hemlock
let stack = [];

// Push elements
stack.push(1);
stack.push(2);
stack.push(3);

// Pop elements
while (stack.length > 0) {
    let item = stack.pop();
    print(item);  // 3, 2, 1
}
```

### Queue Usage

```hemlock
let queue = [];

// Enqueue
queue.push(1);
queue.push(2);
queue.push(3);

// Dequeue
while (queue.length > 0) {
    let item = queue.shift();
    print(item);  // 1, 2, 3
}
```

### Array Transformation

```hemlock
// Filter (manual)
let numbers = [1, 2, 3, 4, 5, 6];
let evens = [];
let i = 0;
while (i < numbers.length) {
    if (numbers[i] % 2 == 0) {
        evens.push(numbers[i]);
    }
    i = i + 1;
}

// Map (manual)
let numbers2 = [1, 2, 3, 4, 5];
let doubled = [];
let j = 0;
while (j < numbers2.length) {
    doubled.push(numbers2[j] * 2);
    j = j + 1;
}
```

### Building Arrays

```hemlock
let arr = [];

// Build array with loop
let i = 0;
while (i < 10) {
    arr.push(i * 10);
    i = i + 1;
}

print(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
```

---

## Implementation Details

**Capacity Management:**
- Arrays automatically grow when needed
- Capacity doubles when exceeded
- No manual capacity control

**Value Comparison:**
- `find()` and `contains()` use value equality
- Works correctly for primitives and strings
- Objects/arrays compared by reference

**Memory:**
- Heap-allocated
- No automatic freeing (manual memory management)
- No bounds checking on direct index access

---

## See Also

- [Type System](#reference-type-system) - Array type details
- [String API](#reference-string-api) - String join() results
- [Operators](#reference-operators) - Array indexing operator


--------------------------------------------------------------------------------
## Builtins
--------------------------------------------------------------------------------

# Built-in Functions Reference

Complete reference for all built-in functions and constants in Hemlock.

---

## Overview

Hemlock provides a set of built-in functions for I/O, type introspection, memory management, concurrency, and system interaction. All built-ins are available globally without imports.

---

## I/O Functions

### print

Print values to stdout with newline.

**Signature:**
```hemlock
print(...values): null
```

**Parameters:**
- `...values` - Any number of values to print

**Returns:** `null`

**Examples:**
```hemlock
print("Hello, World!");
print(42);
print(3.14);
print(true);
print([1, 2, 3]);
print({ x: 10, y: 20 });

// Multiple values
print("x =", 10, "y =", 20);
```

**Behavior:**
- Converts all values to strings
- Separates multiple values with spaces
- Adds newline at end
- Flushes stdout

---

### read_line

Read a line of text from stdin (user input).

**Signature:**
```hemlock
read_line(): string | null
```

**Parameters:** None

**Returns:**
- `string` - The line read from stdin (newline stripped)
- `null` - On EOF (end of file/input)

**Examples:**
```hemlock
// Simple prompt
print("What is your name?");
let name = read_line();
print("Hello, " + name + "!");

// Reading numbers (requires manual parsing)
print("Enter a number:");
let input = read_line();
let num = parse_int(input);  // See below for parse_int
print("Double:", num * 2);

// Handle EOF
let line = read_line();
if (line == null) {
    print("End of input");
}

// Read multiple lines
print("Enter lines (Ctrl+D to stop):");
while (true) {
    let line = read_line();
    if (line == null) {
        break;
    }
    print("You said:", line);
}
```

**Behavior:**
- Blocks until user presses Enter
- Strips trailing newline (`\n`) and carriage return (`\r`)
- Returns `null` on EOF (Ctrl+D on Unix, Ctrl+Z on Windows)
- Reads from stdin only (not from files)

**Parsing User Input:**

Since `read_line()` always returns a string, you need to parse numeric input manually:

```hemlock
// Simple integer parser
fn parse_int(s: string): i32 {
    let result: i32 = 0;
    let negative = false;
    let i = 0;

    if (s.length > 0 && s.char_at(0) == '-') {
        negative = true;
        i = 1;
    }

    while (i < s.length) {
        let c = s.char_at(i);
        let code: i32 = c;
        if (code >= 48 && code <= 57) {
            result = result * 10 + (code - 48);
        } else {
            break;
        }
        i = i + 1;
    }

    if (negative) {
        return -result;
    }
    return result;
}

// Usage
print("Enter your age:");
let age = parse_int(read_line());
print("In 10 years you'll be", age + 10);
```

**See Also:** [File API](#reference-file-api) for reading from files

---

### eprint

Print a value to stderr with newline.

**Signature:**
```hemlock
eprint(value: any): null
```

**Parameters:**
- `value` - Single value to print to stderr

**Returns:** `null`

**Examples:**
```hemlock
eprint("Error: file not found");
eprint(404);
eprint("Warning: " + message);

// Typical error handling pattern
fn load_config(path: string) {
    if (!exists(path)) {
        eprint("Error: config file not found: " + path);
        return null;
    }
    // ...
}
```

**Behavior:**
- Prints to stderr (standard error stream)
- Adds newline at end
- Only accepts one argument (unlike `print`)
- Useful for error messages that shouldn't mix with normal output

**Difference from print:**
- `print()` â†’ stdout (normal output, can be redirected with `>`)
- `eprint()` â†’ stderr (error output, can be redirected with `2>`)

```bash
# Shell example: separate stdout and stderr
./hemlock script.hml > output.txt 2> errors.txt
```

---

## Type Introspection

### typeof

Get the type name of a value.

**Signature:**
```hemlock
typeof(value: any): string
```

**Parameters:**
- `value` - Any value

**Returns:** Type name as string

**Examples:**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("hello"));         // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof(null));            // "null"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"

// Typed objects
define Person { name: string }
let p: Person = { name: "Alice" };
print(typeof(p));               // "Person"

// Other types
print(typeof(alloc(10)));       // "ptr"
print(typeof(buffer(10)));      // "buffer"
print(typeof(open("file.txt"))); // "file"
```

**Type Names:**
- Primitives: `"i8"`, `"i16"`, `"i32"`, `"i64"`, `"u8"`, `"u16"`, `"u32"`, `"u64"`, `"f32"`, `"f64"`, `"bool"`, `"string"`, `"rune"`, `"null"`
- Composites: `"array"`, `"object"`, `"ptr"`, `"buffer"`, `"function"`
- Special: `"file"`, `"task"`, `"channel"`
- Custom: User-defined type names from `define`

**See Also:** [Type System](#reference-type-system)

---

## Command Execution

### exec

Execute shell command and capture output.

**Signature:**
```hemlock
exec(command: string): object
```

**Parameters:**
- `command` - Shell command to execute

**Returns:** Object with fields:
- `output` (string) - Command's stdout
- `exit_code` (i32) - Exit status code (0 = success)

**Examples:**
```hemlock
let result = exec("echo hello");
print(result.output);      // "hello\n"
print(result.exit_code);   // 0

// Check exit status
let r = exec("grep pattern file.txt");
if (r.exit_code == 0) {
    print("Found:", r.output);
} else {
    print("Pattern not found");
}

// Process multi-line output
let r2 = exec("ls -la");
let lines = r2.output.split("\n");
```

**Behavior:**
- Executes command via `/bin/sh`
- Captures stdout only (stderr goes to terminal)
- Blocks until command completes
- Returns empty string if no output

**Error Handling:**
```hemlock
try {
    let r = exec("nonexistent_command");
} catch (e) {
    print("Failed to execute:", e);
}
```

**Security Warning:** âš ï¸ Vulnerable to shell injection. Always validate/sanitize user input.

**Limitations:**
- No stderr capture
- No streaming
- No timeout
- No signal handling

---

### exec_argv

Execute a command with explicit argument array (no shell interpretation).

**Signature:**
```hemlock
exec_argv(argv: array): object
```

**Parameters:**
- `argv` - Array of strings: `[command, arg1, arg2, ...]`

**Returns:** Object with fields:
- `output` (string) - Command's stdout
- `exit_code` (i32) - Exit status code (0 = success)

**Examples:**
```hemlock
// Simple command
let result = exec_argv(["ls", "-la"]);
print(result.output);

// Command with arguments containing spaces (safe!)
let r = exec_argv(["grep", "hello world", "file.txt"]);

// Run a script with arguments
let r2 = exec_argv(["python", "script.py", "--input", "data.json"]);
print(r2.exit_code);
```

**Difference from exec:**
```hemlock
// exec() uses shell - UNSAFE with user input
exec("ls " + user_input);  // Shell injection risk!

// exec_argv() bypasses shell - SAFE
exec_argv(["ls", user_input]);  // No injection possible
```

**When to use:**
- When arguments contain spaces, quotes, or special characters
- When processing user input (security)
- When you need predictable argument parsing

**See Also:** `exec()` for simple shell commands

---

## Error Handling

### throw

Throw an exception.

**Signature:**
```hemlock
throw expression
```

**Parameters:**
- `expression` - Value to throw (any type)

**Returns:** Never returns (transfers control)

**Examples:**
```hemlock
throw "error message";
throw 404;
throw { code: 500, message: "Internal error" };
throw null;
```

**See Also:** try/catch/finally statements

---

### panic

Immediately terminate program with error message (unrecoverable).

**Signature:**
```hemlock
panic(message?: any): never
```

**Parameters:**
- `message` (optional) - Error message to print

**Returns:** Never returns (program exits)

**Examples:**
```hemlock
panic();                          // Default: "panic!"
panic("unreachable code reached");
panic(42);

// Common use case
fn process_state(state: i32): string {
    if (state == 1) { return "ready"; }
    if (state == 2) { return "running"; }
    panic("invalid state: " + typeof(state));
}
```

**Behavior:**
- Prints error to stderr: `panic: <message>`
- Exits with code 1
- **NOT catchable** with try/catch
- Use for bugs and unrecoverable errors

**Panic vs Throw:**
- `panic()` - Unrecoverable error, exits immediately
- `throw` - Recoverable error, can be caught

---

### assert

Assert that a condition is true, or terminate with an error message.

**Signature:**
```hemlock
assert(condition: any, message?: string): null
```

**Parameters:**
- `condition` - Value to check for truthiness
- `message` (optional) - Custom error message if assertion fails

**Returns:** `null` (if assertion passes)

**Examples:**
```hemlock
// Basic assertions
assert(x > 0);
assert(name != null);
assert(arr.length > 0, "Array must not be empty");

// With custom messages
fn divide(a: i32, b: i32): f64 {
    assert(b != 0, "Division by zero");
    return a / b;
}

// Validate function arguments
fn process_data(data: array) {
    assert(data != null, "data cannot be null");
    assert(data.length > 0, "data cannot be empty");
    // ...
}
```

**Behavior:**
- If condition is truthy: returns `null`, execution continues
- If condition is falsy: prints error and exits with code 1
- Falsy values: `false`, `0`, `0.0`, `null`, `""` (empty string)
- Truthy values: everything else

**Output on failure:**
```
Assertion failed: Array must not be empty
```

**When to use:**
- Validating function preconditions
- Checking invariants during development
- Catching programmer errors early

**assert vs panic:**
- `assert(cond, msg)` - Checks a condition, fails if false
- `panic(msg)` - Always fails unconditionally

---

## Signal Handling

### signal

Register or reset signal handler.

**Signature:**
```hemlock
signal(signum: i32, handler: function | null): function | null
```

**Parameters:**
- `signum` - Signal number (use constants like `SIGINT`)
- `handler` - Function to call when signal received, or `null` to reset to default

**Returns:** Previous handler function, or `null`

**Examples:**
```hemlock
fn handle_interrupt(sig) {
    print("Caught SIGINT!");
}

signal(SIGINT, handle_interrupt);

// Reset to default
signal(SIGINT, null);
```

**Handler Signature:**
```hemlock
fn handler(signum: i32) {
    // signum contains the signal number
}
```

**See Also:**
- [Signal constants](#signal-constants)
- `raise()`

---

### raise

Send signal to current process.

**Signature:**
```hemlock
raise(signum: i32): null
```

**Parameters:**
- `signum` - Signal number to raise

**Returns:** `null`

**Examples:**
```hemlock
let count = 0;

fn increment(sig) {
    count = count + 1;
}

signal(SIGUSR1, increment);

raise(SIGUSR1);
raise(SIGUSR1);
print(count);  // 2
```

---

## Global Variables

### args

Command-line arguments array.

**Type:** `array` of strings

**Structure:**
- `args[0]` - Script filename
- `args[1..n]` - Command-line arguments

**Examples:**
```bash
# Command: ./hemlock script.hml hello world
```

```hemlock
print(args[0]);        // "script.hml"
print(args.length);    // 3
print(args[1]);        // "hello"
print(args[2]);        // "world"

// Iterate arguments
let i = 1;
while (i < args.length) {
    print("Argument", i, ":", args[i]);
    i = i + 1;
}
```

**REPL Behavior:** In the REPL, `args.length` is 0 (empty array)

---

## Signal Constants

Standard POSIX signal constants (i32 values):

### Interrupt & Termination

| Constant   | Value | Description                            |
|------------|-------|----------------------------------------|
| `SIGINT`   | 2     | Interrupt from keyboard (Ctrl+C)       |
| `SIGTERM`  | 15    | Termination request                    |
| `SIGQUIT`  | 3     | Quit from keyboard (Ctrl+\)            |
| `SIGHUP`   | 1     | Hangup detected on controlling terminal|
| `SIGABRT`  | 6     | Abort signal                           |

### User-Defined

| Constant   | Value | Description                |
|------------|-------|----------------------------|
| `SIGUSR1`  | 10    | User-defined signal 1      |
| `SIGUSR2`  | 12    | User-defined signal 2      |

### Process Control

| Constant   | Value | Description                     |
|------------|-------|---------------------------------|
| `SIGALRM`  | 14    | Alarm clock timer               |
| `SIGCHLD`  | 17    | Child process status change     |
| `SIGCONT`  | 18    | Continue if stopped             |
| `SIGSTOP`  | 19    | Stop process (cannot be caught) |
| `SIGTSTP`  | 20    | Terminal stop (Ctrl+Z)          |

### I/O

| Constant   | Value | Description                        |
|------------|-------|------------------------------------|
| `SIGPIPE`  | 13    | Broken pipe                        |
| `SIGTTIN`  | 21    | Background read from terminal      |
| `SIGTTOU`  | 22    | Background write to terminal       |

**Examples:**
```hemlock
fn handle_signal(sig) {
    if (sig == SIGINT) {
        print("Interrupt detected");
    }
    if (sig == SIGTERM) {
        print("Termination requested");
    }
}

signal(SIGINT, handle_signal);
signal(SIGTERM, handle_signal);
```

**Note:** `SIGKILL` (9) and `SIGSTOP` (19) cannot be caught or ignored.

---

## Math/Arithmetic Functions

### div

Floor division returning a float.

**Signature:**
```hemlock
div(a: number, b: number): f64
```

**Parameters:**
- `a` - Dividend
- `b` - Divisor

**Returns:** Floor of `a / b` as a float (f64)

**Examples:**
```hemlock
let result = div(7, 2);    // 3.0 (not 3.5)
let result2 = div(10, 3);  // 3.0
let result3 = div(-7, 2);  // -4.0 (floor rounds toward negative infinity)
```

**Note:** In Hemlock, the `/` operator always returns a float. Use `div()` for floor division when you need the integer part as a float, or `divi()` when you need an integer result.

---

### divi

Floor division returning an integer.

**Signature:**
```hemlock
divi(a: number, b: number): i64
```

**Parameters:**
- `a` - Dividend
- `b` - Divisor

**Returns:** Floor of `a / b` as an integer (i64)

**Examples:**
```hemlock
let result = divi(7, 2);    // 3
let result2 = divi(10, 3);  // 3
let result3 = divi(-7, 2);  // -4 (floor rounds toward negative infinity)
```

**Comparison:**
```hemlock
print(7 / 2);      // 3.5 (regular division, always float)
print(div(7, 2));  // 3.0 (floor division, float result)
print(divi(7, 2)); // 3   (floor division, integer result)
```

---

## Memory Management Functions

See [Memory API](#reference-memory-api) for complete reference:
- `alloc(size)` - Allocate raw memory
- `free(ptr)` - Free memory
- `buffer(size)` - Allocate safe buffer
- `memset(ptr, byte, size)` - Fill memory
- `memcpy(dest, src, size)` - Copy memory
- `realloc(ptr, new_size)` - Resize allocation

### sizeof

Get the size of a type in bytes.

**Signature:**
```hemlock
sizeof(type): i32
```

**Parameters:**
- `type` - A type constant (`i32`, `f64`, `ptr`, etc.) or type name string

**Returns:** Size in bytes as `i32`

**Examples:**
```hemlock
print(sizeof(i8));       // 1
print(sizeof(i16));      // 2
print(sizeof(i32));      // 4
print(sizeof(i64));      // 8
print(sizeof(f32));      // 4
print(sizeof(f64));      // 8
print(sizeof(ptr));      // 8
print(sizeof(rune));     // 4

// Using type aliases
print(sizeof(byte));     // 1 (same as u8)
print(sizeof(integer));  // 4 (same as i32)
print(sizeof(number));   // 8 (same as f64)

// String form also works
print(sizeof("i32"));    // 4
```

**Supported Types:**
| Type | Size | Aliases |
|------|------|---------|
| `i8` | 1 | - |
| `i16` | 2 | - |
| `i32` | 4 | `integer` |
| `i64` | 8 | - |
| `u8` | 1 | `byte` |
| `u16` | 2 | - |
| `u32` | 4 | - |
| `u64` | 8 | - |
| `f32` | 4 | - |
| `f64` | 8 | `number` |
| `ptr` | 8 | - |
| `rune` | 4 | - |
| `bool` | 1 | - |

**See Also:** `talloc()` for typed allocation

---

### talloc

Allocate memory for a typed array (type-aware allocation).

**Signature:**
```hemlock
talloc(type, count: i32): ptr
```

**Parameters:**
- `type` - A type constant (`i32`, `f64`, `ptr`, etc.)
- `count` - Number of elements to allocate

**Returns:** `ptr` to allocated memory, or `null` on failure

**Examples:**
```hemlock
// Allocate array of 10 i32s (40 bytes)
let int_arr = talloc(i32, 10);
ptr_write_i32(int_arr, 42);
ptr_write_i32(ptr_offset(int_arr, 1, 4), 100);

// Allocate array of 5 f64s (40 bytes)
let float_arr = talloc(f64, 5);

// Allocate array of 100 bytes
let byte_arr = talloc(u8, 100);

// Don't forget to free!
free(int_arr);
free(float_arr);
free(byte_arr);
```

**Comparison with alloc:**
```hemlock
// These are equivalent:
let p1 = talloc(i32, 10);      // Type-aware: 10 i32s
let p2 = alloc(sizeof(i32) * 10);  // Manual calculation

// talloc is clearer and less error-prone
```

**Error Handling:**
- Returns `null` if allocation fails
- Exits with error if count is not positive
- Checks for size overflow (count * element_size)

**See Also:** `alloc()`, `sizeof()`, `free()`

---

## FFI Pointer Helpers

These functions help read and write typed values to raw memory, useful for FFI and low-level memory manipulation.

### ptr_null

Create a null pointer.

**Signature:**
```hemlock
ptr_null(): ptr
```

**Returns:** A null pointer

**Example:**
```hemlock
let p = ptr_null();
if (p == null) {
    print("Pointer is null");
}
```

---

### ptr_offset

Calculate pointer offset (pointer arithmetic).

**Signature:**
```hemlock
ptr_offset(ptr: ptr, index: i32, element_size: i32): ptr
```

**Parameters:**
- `ptr` - Base pointer
- `index` - Element index
- `element_size` - Size of each element in bytes

**Returns:** Pointer to the element at the given index

**Example:**
```hemlock
let arr = talloc(i32, 10);
ptr_write_i32(arr, 100);                      // arr[0] = 100
ptr_write_i32(ptr_offset(arr, 1, 4), 200);    // arr[1] = 200
ptr_write_i32(ptr_offset(arr, 2, 4), 300);    // arr[2] = 300

print(ptr_read_i32(ptr_offset(arr, 1, 4)));   // 200
free(arr);
```

---

### Pointer Read Functions

Read typed values from memory.

| Function | Signature | Returns | Description |
|----------|-----------|---------|-------------|
| `ptr_read_i8` | `(ptr)` | `i8` | Read signed 8-bit integer |
| `ptr_read_i16` | `(ptr)` | `i16` | Read signed 16-bit integer |
| `ptr_read_i32` | `(ptr)` | `i32` | Read signed 32-bit integer |
| `ptr_read_i64` | `(ptr)` | `i64` | Read signed 64-bit integer |
| `ptr_read_u8` | `(ptr)` | `u8` | Read unsigned 8-bit integer |
| `ptr_read_u16` | `(ptr)` | `u16` | Read unsigned 16-bit integer |
| `ptr_read_u32` | `(ptr)` | `u32` | Read unsigned 32-bit integer |
| `ptr_read_u64` | `(ptr)` | `u64` | Read unsigned 64-bit integer |
| `ptr_read_f32` | `(ptr)` | `f32` | Read 32-bit float |
| `ptr_read_f64` | `(ptr)` | `f64` | Read 64-bit float |
| `ptr_read_ptr` | `(ptr)` | `ptr` | Read pointer value |

**Example:**
```hemlock
let p = alloc(8);
ptr_write_f64(p, 3.14159);
let value = ptr_read_f64(p);
print(value);  // 3.14159
free(p);
```

---

### Pointer Write Functions

Write typed values to memory.

| Function | Signature | Returns | Description |
|----------|-----------|---------|-------------|
| `ptr_write_i8` | `(ptr, value)` | `null` | Write signed 8-bit integer |
| `ptr_write_i16` | `(ptr, value)` | `null` | Write signed 16-bit integer |
| `ptr_write_i32` | `(ptr, value)` | `null` | Write signed 32-bit integer |
| `ptr_write_i64` | `(ptr, value)` | `null` | Write signed 64-bit integer |
| `ptr_write_u8` | `(ptr, value)` | `null` | Write unsigned 8-bit integer |
| `ptr_write_u16` | `(ptr, value)` | `null` | Write unsigned 16-bit integer |
| `ptr_write_u32` | `(ptr, value)` | `null` | Write unsigned 32-bit integer |
| `ptr_write_u64` | `(ptr, value)` | `null` | Write unsigned 64-bit integer |
| `ptr_write_f32` | `(ptr, value)` | `null` | Write 32-bit float |
| `ptr_write_f64` | `(ptr, value)` | `null` | Write 64-bit float |
| `ptr_write_ptr` | `(ptr, value)` | `null` | Write pointer value |

**Example:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);
print(ptr_read_i32(p));  // 42
free(p);
```

---

### Buffer/Pointer Conversion

#### buffer_ptr

Get raw pointer from a buffer.

**Signature:**
```hemlock
buffer_ptr(buf: buffer): ptr
```

**Example:**
```hemlock
let buf = buffer(64);
let p = buffer_ptr(buf);
// Now p points to the same memory as buf
```

#### ptr_to_buffer

Create a buffer wrapper around a raw pointer.

**Signature:**
```hemlock
ptr_to_buffer(ptr: ptr, size: i32): buffer
```

**Example:**
```hemlock
let p = alloc(64);
let buf = ptr_to_buffer(p, 64);
buf[0] = 65;  // Now has bounds checking
// Note: freeing buf will free the underlying memory
```

---

## File I/O Functions

See [File API](#reference-file-api) for complete reference:
- `open(path, mode?)` - Open file

---

## Concurrency Functions

See [Concurrency API](#reference-concurrency-api) for complete reference:
- `spawn(fn, args...)` - Spawn task
- `join(task)` - Wait for task
- `detach(task)` - Detach task
- `channel(capacity)` - Create channel

### apply

Call a function dynamically with an array of arguments.

**Signature:**
```hemlock
apply(fn: function, args: array): any
```

**Parameters:**
- `fn` - The function to call
- `args` - Array of arguments to pass to the function

**Returns:** The return value of the called function

**Examples:**
```hemlock
fn add(a, b) {
    return a + b;
}

// Call with array of arguments
let result = apply(add, [2, 3]);
print(result);  // 5

// Dynamic dispatch
let operations = {
    add: fn(a, b) { return a + b; },
    mul: fn(a, b) { return a * b; },
    sub: fn(a, b) { return a - b; }
};

fn calculate(op: string, args: array) {
    return apply(operations[op], args);
}

print(calculate("add", [10, 5]));  // 15
print(calculate("mul", [10, 5]));  // 50
print(calculate("sub", [10, 5]));  // 5

// Variable arguments
fn sum(...nums) {
    let total = 0;
    for (n in nums) {
        total = total + n;
    }
    return total;
}

let numbers = [1, 2, 3, 4, 5];
print(apply(sum, numbers));  // 15
```

**Use Cases:**
- Dynamic function dispatch based on runtime values
- Calling functions with variable argument lists
- Implementing higher-order utilities (map, filter, etc.)
- Plugin/extension systems

---

### select

Wait for data from multiple channels, returning when any has data.

**Signature:**
```hemlock
select(channels: array, timeout_ms?: i32): object | null
```

**Parameters:**
- `channels` - Array of channel values
- `timeout_ms` (optional) - Timeout in milliseconds (-1 or omit for infinite)

**Returns:**
- `{ channel, value }` - Object with the channel that had data and the received value
- `null` - On timeout

**Examples:**
```hemlock
let ch1 = channel(1);
let ch2 = channel(1);

// Producer tasks
spawn(fn() {
    sleep(100);
    ch1.send("from channel 1");
});

spawn(fn() {
    sleep(50);
    ch2.send("from channel 2");
});

// Wait for first message
let result = select([ch1, ch2]);
print(result.value);  // "from channel 2" (arrived first)

// With timeout
let result2 = select([ch1, ch2], 1000);  // Wait up to 1 second
if (result2 == null) {
    print("Timeout - no data received");
} else {
    print("Received:", result2.value);
}

// Continuous select loop
while (true) {
    let msg = select([ch1, ch2], 5000);
    if (msg == null) {
        print("No activity for 5 seconds");
        break;
    }
    print("Got message:", msg.value);
}
```

**Behavior:**
- Blocks until one channel has data or timeout expires
- Returns immediately if a channel already has data
- If channel is closed and empty, returns `{ channel, value: null }`
- Polls channels in order (first ready channel wins)

**Use Cases:**
- Multiplexing multiple producers
- Implementing timeouts on channel operations
- Building event loops with multiple sources

---

## Summary Table

### Functions

| Function   | Category        | Returns      | Description                     |
|------------|-----------------|--------------|----------------------------------|
| `print`    | I/O             | `null`       | Print to stdout                  |
| `read_line`| I/O             | `string?`    | Read line from stdin             |
| `eprint`   | I/O             | `null`       | Print to stderr                  |
| `typeof`   | Type            | `string`     | Get type name                    |
| `exec`     | Command         | `object`     | Execute shell command            |
| `exec_argv`| Command         | `object`     | Execute with argument array      |
| `assert`   | Error           | `null`       | Assert condition or exit         |
| `panic`    | Error           | `never`      | Unrecoverable error (exits)      |
| `signal`   | Signal          | `function?`  | Register signal handler          |
| `raise`    | Signal          | `null`       | Send signal to process           |
| `alloc`    | Memory          | `ptr`        | Allocate raw memory              |
| `talloc`   | Memory          | `ptr`        | Typed allocation                 |
| `sizeof`   | Memory          | `i32`        | Get type size in bytes           |
| `free`     | Memory          | `null`       | Free memory                      |
| `buffer`   | Memory          | `buffer`     | Allocate safe buffer             |
| `memset`   | Memory          | `null`       | Fill memory                      |
| `memcpy`   | Memory          | `null`       | Copy memory                      |
| `realloc`  | Memory          | `ptr`        | Resize allocation                |
| `open`     | File I/O        | `file`       | Open file                        |
| `spawn`    | Concurrency     | `task`       | Spawn concurrent task            |
| `join`     | Concurrency     | `any`        | Wait for task result             |
| `detach`   | Concurrency     | `null`       | Detach task                      |
| `channel`  | Concurrency     | `channel`    | Create communication channel     |
| `select`   | Concurrency     | `object?`    | Wait on multiple channels        |
| `apply`    | Functions       | `any`        | Call function with args array    |

### Global Variables

| Variable   | Type     | Description                       |
|------------|----------|-----------------------------------|
| `args`     | `array`  | Command-line arguments            |

### Constants

| Constant   | Type  | Category | Value | Description               |
|------------|-------|----------|-------|---------------------------|
| `SIGINT`   | `i32` | Signal   | 2     | Keyboard interrupt        |
| `SIGTERM`  | `i32` | Signal   | 15    | Termination request       |
| `SIGQUIT`  | `i32` | Signal   | 3     | Keyboard quit             |
| `SIGHUP`   | `i32` | Signal   | 1     | Hangup                    |
| `SIGABRT`  | `i32` | Signal   | 6     | Abort                     |
| `SIGUSR1`  | `i32` | Signal   | 10    | User-defined 1            |
| `SIGUSR2`  | `i32` | Signal   | 12    | User-defined 2            |
| `SIGALRM`  | `i32` | Signal   | 14    | Alarm timer               |
| `SIGCHLD`  | `i32` | Signal   | 17    | Child status change       |
| `SIGCONT`  | `i32` | Signal   | 18    | Continue                  |
| `SIGSTOP`  | `i32` | Signal   | 19    | Stop (uncatchable)        |
| `SIGTSTP`  | `i32` | Signal   | 20    | Terminal stop             |
| `SIGPIPE`  | `i32` | Signal   | 13    | Broken pipe               |
| `SIGTTIN`  | `i32` | Signal   | 21    | Background terminal read  |
| `SIGTTOU`  | `i32` | Signal   | 22    | Background terminal write |

---

## See Also

- [Type System](#reference-type-system) - Types and conversions
- [Memory API](#reference-memory-api) - Memory allocation functions
- [File API](#reference-file-api) - File I/O functions
- [Concurrency API](#reference-concurrency-api) - Async/concurrency functions
- [String API](#reference-string-api) - String methods
- [Array API](#reference-array-api) - Array methods


--------------------------------------------------------------------------------
## Concurrency API
--------------------------------------------------------------------------------

# Concurrency API Reference

Complete reference for Hemlock's async/concurrency system.

---

## Overview

Hemlock provides **structured concurrency** with true multi-threaded parallelism using POSIX threads (pthreads). Each spawned task runs on a separate OS thread, enabling actual parallel execution across multiple CPU cores.

**Key Features:**
- True multi-threaded parallelism (not green threads)
- Async function syntax
- Task spawning and joining
- Thread-safe channels
- Exception propagation

**Threading Model:**
- âœ… Real OS threads (POSIX pthreads)
- âœ… True parallelism (multiple CPU cores)
- âœ… Kernel-scheduled (pre-emptive multitasking)
- âœ… Thread-safe synchronization (mutexes, condition variables)

---

## Async Functions

### Async Function Declaration

Functions can be declared as `async` to indicate they're designed for concurrent execution.

**Syntax:**
```hemlock
async fn function_name(params): return_type {
    // function body
}
```

**Examples:**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

async fn process_data(data: string) {
    print("Processing:", data);
    return null;
}
```

**Behavior:**
- `async fn` declares an asynchronous function
- Can be called synchronously (runs in current thread)
- Can be spawned as concurrent task (runs on new thread)
- When spawned, runs on its own OS thread

**Note:** The `await` keyword is reserved for future use but not currently implemented.

---

## Task Management

### spawn

Create and start a new concurrent task.

**Signature:**
```hemlock
spawn(async_fn: function, ...args): task
```

**Parameters:**
- `async_fn` - Async function to execute
- `...args` - Arguments to pass to function

**Returns:** Task handle

**Examples:**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Spawn single task
let t = spawn(compute, 1000);
let result = join(t);
print(result);

// Spawn multiple tasks (run in parallel!)
let t1 = spawn(compute, 100);
let t2 = spawn(compute, 200);
let t3 = spawn(compute, 300);

// All three are running simultaneously
let r1 = join(t1);
let r2 = join(t2);
let r3 = join(t3);
```

**Behavior:**
- Creates new OS thread via `pthread_create()`
- Starts executing function immediately
- Returns task handle for later joining
- Tasks run in parallel on separate CPU cores

---

### join

Wait for task completion and retrieve result.

**Signature:**
```hemlock
join(task: task): any
```

**Parameters:**
- `task` - Task handle from `spawn()`

**Returns:** Task's return value

**Examples:**
```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

let t = spawn(factorial, 10);
let result = join(t);  // Blocks until task completes
print(result);         // 3628800
```

**Behavior:**
- Blocks current thread until task completes
- Returns task's return value
- Propagates exceptions thrown by task
- Cleans up task resources after returning

**Error Handling:**
```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Task failed!";
    }
    return 42;
}

let t = spawn(risky_operation, 1);
try {
    let result = join(t);
} catch (e) {
    print("Caught:", e);  // "Caught: Task failed!"
}
```

---

### detach

Detach task (fire-and-forget execution).

**Signature:**
```hemlock
detach(task: task): null
```

**Parameters:**
- `task` - Task handle from `spawn()`

**Returns:** `null`

**Examples:**
```hemlock
async fn background_work() {
    print("Working in background...");
    return null;
}

let t = spawn(background_work);
detach(t);  // Task continues running independently

// Cannot join detached task
// join(t);  // ERROR
```

**Behavior:**
- Task continues running independently
- Cannot `join()` detached task
- Task and thread are automatically cleaned up when the task completes

**Use Cases:**
- Fire-and-forget background tasks
- Logging/monitoring tasks
- Tasks that don't need to return values

---

## Channels

Channels provide thread-safe communication between tasks.

### channel

Create a buffered channel.

**Signature:**
```hemlock
channel(capacity: i32): channel
```

**Parameters:**
- `capacity` - Buffer size (number of values)

**Returns:** Channel object

**Examples:**
```hemlock
let ch = channel(10);  // Buffered channel with capacity 10
let ch2 = channel(1);  // Minimal buffer (synchronous)
let ch3 = channel(100); // Large buffer
```

**Behavior:**
- Creates thread-safe channel
- Uses pthread mutexes for synchronization
- Capacity is fixed at creation time

---

### Channel Methods

#### send

Send value to channel (blocks if full).

**Signature:**
```hemlock
channel.send(value: any): null
```

**Parameters:**
- `value` - Value to send (any type)

**Returns:** `null`

**Examples:**
```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

let ch = channel(10);
let t = spawn(producer, ch, 5);
```

**Behavior:**
- Sends value to channel
- Blocks if channel is full
- Thread-safe (uses mutex)
- Returns after value is sent

---

#### recv

Receive value from channel (blocks if empty).

**Signature:**
```hemlock
channel.recv(): any
```

**Returns:** Value from channel, or `null` if channel is closed and empty

**Examples:**
```hemlock
async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(10);
let t = spawn(consumer, ch, 5);
```

**Behavior:**
- Receives value from channel
- Blocks if channel is empty
- Returns `null` if channel is closed and empty
- Thread-safe (uses mutex)

---

#### close

Close channel (no more sends allowed).

**Signature:**
```hemlock
channel.close(): null
```

**Returns:** `null`

**Examples:**
```hemlock
async fn producer(ch) {
    ch.send(1);
    ch.send(2);
    ch.send(3);
    ch.close();  // Signal no more values
    return null;
}

async fn consumer(ch) {
    while (true) {
        let val = ch.recv();
        if (val == null) {
            break;  // Channel closed
        }
        print(val);
    }
    return null;
}
```

**Behavior:**
- Closes channel
- No more sends allowed
- `recv()` returns `null` when channel is empty
- Thread-safe

---

## Complete Concurrency Example

### Producer-Consumer Pattern

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        print("Producing:", i);
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        print("Consuming:", val);
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

// Create channel
let ch = channel(10);

// Spawn producer and consumer
let p = spawn(producer, ch, 5);
let c = spawn(consumer, ch, 5);

// Wait for completion
join(p);
let total = join(c);
print("Total:", total);  // 0+10+20+30+40 = 100
```

---

## Parallel Computation

### Multiple Tasks Example

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Spawn multiple tasks (run in parallel!)
let t1 = spawn(factorial, 5);   // Thread 1
let t2 = spawn(factorial, 6);   // Thread 2
let t3 = spawn(factorial, 7);   // Thread 3
let t4 = spawn(factorial, 8);   // Thread 4

// All four are computing simultaneously!

// Wait for results
let f5 = join(t1);  // 120
let f6 = join(t2);  // 720
let f7 = join(t3);  // 5040
let f8 = join(t4);  // 40320

print(f5, f6, f7, f8);
```

---

## Task Lifecycle

### State Transitions

1. **Created** - Task spawned but not yet running
2. **Running** - Task executing on OS thread
3. **Completed** - Task finished (result available)
4. **Joined** - Result retrieved, resources cleaned up
5. **Detached** - Task continues independently

### Lifecycle Example

```hemlock
async fn work(n: i32): i32 {
    return n * 2;
}

// 1. Create task
let t = spawn(work, 21);  // State: Running

// Task executes on separate thread...

// 2. Join task
let result = join(t);     // State: Completed â†’ Joined
print(result);            // 42

// Task resources cleaned up after join
```

### Detached Lifecycle

```hemlock
async fn background() {
    print("Background task running");
    return null;
}

// 1. Create task
let t = spawn(background);  // State: Running

// 2. Detach task
detach(t);                  // State: Detached

// Task continues running independently
// Resources cleaned up by OS when done
```

---

## Error Handling

### Exception Propagation

Exceptions thrown in tasks are propagated when joined:

```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Task failed!";
    }
    return 42;
}

// Task that succeeds
let t1 = spawn(risky_operation, 0);
let result1 = join(t1);  // 42

// Task that fails
let t2 = spawn(risky_operation, 1);
try {
    let result2 = join(t2);
} catch (e) {
    print("Caught:", e);  // "Caught: Task failed!"
}
```

### Handling Multiple Tasks

```hemlock
async fn work(id: i32, should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Task " + typeof(id) + " failed";
    }
    return id * 10;
}

let t1 = spawn(work, 1, 0);
let t2 = spawn(work, 2, 1);  // Will fail
let t3 = spawn(work, 3, 0);

// Join with error handling
try {
    let r1 = join(t1);  // OK
    print("Task 1:", r1);

    let r2 = join(t2);  // Throws
    print("Task 2:", r2);  // Never reached
} catch (e) {
    print("Error:", e);  // "Error: Task 2 failed"
}

// Can still join remaining task
let r3 = join(t3);
print("Task 3:", r3);
```

---

## Performance Characteristics

### True Parallelism

```hemlock
async fn cpu_intensive(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Sequential execution
let start = get_time();
let r1 = cpu_intensive(10000000);
let r2 = cpu_intensive(10000000);
let sequential_time = get_time() - start;

// Parallel execution
let start2 = get_time();
let t1 = spawn(cpu_intensive, 10000000);
let t2 = spawn(cpu_intensive, 10000000);
join(t1);
join(t2);
let parallel_time = get_time() - start2;

// parallel_time should be ~50% of sequential_time on multi-core systems
```

**Proven Characteristics:**
- N tasks can utilize N CPU cores simultaneously
- Stress tests show 8-9x CPU time vs wall time (proof of parallelism)
- Thread overhead: ~8KB stack + pthread overhead per task
- Blocking operations in one task don't block others

---

## Implementation Details

### Threading Model

- **1:1 threading** - Each task = 1 OS thread (`pthread`)
- **Kernel-scheduled** - OS kernel distributes threads across cores
- **Pre-emptive multitasking** - OS can interrupt and switch threads
- **No GIL** - No Global Interpreter Lock (unlike Python)

### Synchronization

- **Mutexes** - Channels use `pthread_mutex_t`
- **Condition variables** - Blocking send/recv use `pthread_cond_t`
- **Lock-free operations** - Task state transitions are atomic

### Memory & Cleanup

- **Joined tasks** - Automatically cleaned up after `join()`
- **Detached tasks** - Automatically cleaned up when the task completes
- **Channels** - Reference-counted, freed when no longer used

---

## Limitations

- No `select()` for multiplexing multiple channels
- No work-stealing scheduler (1 thread per task)
- No async I/O integration (file/network operations block)
- Channel capacity fixed at creation time

---

## Complete API Summary

### Functions

| Function  | Signature                         | Returns   | Description                    |
|-----------|-----------------------------------|-----------|--------------------------------|
| `spawn`   | `(async_fn: function, ...args)`   | `task`    | Create and start concurrent task|
| `join`    | `(task: task)`                    | `any`     | Wait for task, get result      |
| `detach`  | `(task: task)`                    | `null`    | Detach task (fire-and-forget)  |
| `channel` | `(capacity: i32)`                 | `channel` | Create thread-safe channel     |

### Channel Methods

| Method  | Signature       | Returns | Description                      |
|---------|-----------------|---------|----------------------------------|
| `send`  | `(value: any)`  | `null`  | Send value (blocks if full)      |
| `recv`  | `()`            | `any`   | Receive value (blocks if empty)  |
| `close` | `()`            | `null`  | Close channel                    |

### Types

| Type      | Description                          |
|-----------|--------------------------------------|
| `task`    | Handle for concurrent task           |
| `channel` | Thread-safe communication channel    |

---

## Best Practices

### Do's

âœ… Use channels for communication between tasks
âœ… Handle exceptions from joined tasks
âœ… Close channels when done sending
âœ… Use `join()` to get results and clean up
âœ… Spawn async functions only

### Don'ts

âŒ Don't share mutable state without synchronization
âŒ Don't join the same task twice
âŒ Don't send on closed channels
âŒ Don't spawn non-async functions
âŒ Don't forget to join tasks (unless detached)

---

## See Also

- [Built-in Functions](#reference-builtins) - `spawn()`, `join()`, `detach()`, `channel()`
- [Type System](#reference-type-system) - Task and channel types


--------------------------------------------------------------------------------
## File API
--------------------------------------------------------------------------------

# File API Reference

Complete reference for Hemlock's File I/O system.

---

## Overview

Hemlock provides a **File object API** for file operations with proper error handling and resource management. Files must be manually opened and closed.

**Key Features:**
- File object with methods
- Read/write text and binary data
- Seeking and positioning
- Proper error messages
- Manual resource management (no RAII)

---

## File Type

**Type:** `file`

**Description:** File handle for I/O operations

**Properties (Read-Only):**
- `.path` - File path (string)
- `.mode` - Open mode (string)
- `.closed` - Whether file is closed (bool)

---

## Opening Files

### open

Open a file for reading, writing, or both.

**Signature:**
```hemlock
open(path: string, mode?: string): file
```

**Parameters:**
- `path` - File path (relative or absolute)
- `mode` (optional) - Open mode (default: `"r"`)

**Returns:** File object

**Modes:**
- `"r"` - Read (default)
- `"w"` - Write (truncate existing file)
- `"a"` - Append
- `"r+"` - Read and write
- `"w+"` - Read and write (truncate)
- `"a+"` - Read and append

**Examples:**
```hemlock
// Read mode (default)
let f = open("data.txt");
let f_read = open("data.txt", "r");

// Write mode (truncate)
let f_write = open("output.txt", "w");

// Append mode
let f_append = open("log.txt", "a");

// Read/write mode
let f_rw = open("data.bin", "r+");

// Read/write (truncate)
let f_rw_trunc = open("output.bin", "w+");

// Read/append
let f_ra = open("log.txt", "a+");
```

**Error Handling:**
```hemlock
try {
    let f = open("missing.txt", "r");
} catch (e) {
    print("Failed to open:", e);
    // Error: Failed to open 'missing.txt': No such file or directory
}
```

**Important:** Files must be closed manually with `f.close()` to avoid file descriptor leaks.

---

## File Methods

### Reading

#### read

Read text from file.

**Signature:**
```hemlock
file.read(size?: i32): string
```

**Parameters:**
- `size` (optional) - Number of bytes to read (if omitted, reads to EOF)

**Returns:** String with file contents

**Examples:**
```hemlock
let f = open("data.txt", "r");

// Read entire file
let all = f.read();
print(all);

// Read specific number of bytes
let chunk = f.read(1024);

f.close();
```

**Behavior:**
- Reads from current file position
- Returns empty string at EOF
- Advances file position

**Errors:**
- Reading from closed file
- Reading from write-only file

---

#### read_bytes

Read binary data from file.

**Signature:**
```hemlock
file.read_bytes(size: i32): buffer
```

**Parameters:**
- `size` - Number of bytes to read

**Returns:** Buffer with binary data

**Examples:**
```hemlock
let f = open("data.bin", "r");

// Read 256 bytes
let binary = f.read_bytes(256);
print(binary.length);       // 256

// Process binary data
let i = 0;
while (i < binary.length) {
    print(binary[i]);
    i = i + 1;
}

f.close();
```

**Behavior:**
- Reads exact number of bytes
- Returns buffer (not string)
- Advances file position

---

### Writing

#### write

Write text to file.

**Signature:**
```hemlock
file.write(data: string): i32
```

**Parameters:**
- `data` - String to write

**Returns:** Number of bytes written (i32)

**Examples:**
```hemlock
let f = open("output.txt", "w");

// Write text
let written = f.write("Hello, World!\n");
print("Wrote", written, "bytes");

// Multiple writes
f.write("Line 1\n");
f.write("Line 2\n");
f.write("Line 3\n");

f.close();
```

**Behavior:**
- Writes at current file position
- Returns number of bytes written
- Advances file position

**Errors:**
- Writing to closed file
- Writing to read-only file

---

#### write_bytes

Write binary data to file.

**Signature:**
```hemlock
file.write_bytes(data: buffer): i32
```

**Parameters:**
- `data` - Buffer to write

**Returns:** Number of bytes written (i32)

**Examples:**
```hemlock
let f = open("output.bin", "w");

// Create buffer
let buf = buffer(10);
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

// Write buffer
let written = f.write_bytes(buf);
print("Wrote", written, "bytes");

f.close();
```

**Behavior:**
- Writes buffer contents to file
- Returns number of bytes written
- Advances file position

---

### Seeking

#### seek

Move file position to specific byte offset.

**Signature:**
```hemlock
file.seek(position: i32): i32
```

**Parameters:**
- `position` - Byte offset from beginning of file

**Returns:** New file position (i32)

**Examples:**
```hemlock
let f = open("data.txt", "r");

// Jump to byte 100
f.seek(100);

// Read from that position
let chunk = f.read(50);

// Reset to beginning
f.seek(0);

// Read from start
let all = f.read();

f.close();
```

**Behavior:**
- Sets file position to absolute offset
- Returns new position
- Seeking past EOF is allowed (creates hole in file when writing)

---

#### tell

Get current file position.

**Signature:**
```hemlock
file.tell(): i32
```

**Returns:** Current byte offset from beginning of file (i32)

**Examples:**
```hemlock
let f = open("data.txt", "r");

print(f.tell());        // 0 (at start)

f.read(100);
print(f.tell());        // 100 (after reading)

f.seek(50);
print(f.tell());        // 50 (after seeking)

f.close();
```

---

### Closing

#### close

Close file (idempotent).

**Signature:**
```hemlock
file.close(): null
```

**Returns:** `null`

**Examples:**
```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();

// Safe to call multiple times
f.close();  // No error
f.close();  // No error
```

**Behavior:**
- Closes file handle
- Flushes any pending writes
- Idempotent (safe to call multiple times)
- Sets `.closed` property to `true`

**Important:** Always close files when done to avoid file descriptor leaks.

---

## File Properties

### .path

Get file path.

**Type:** `string`

**Access:** Read-only

**Examples:**
```hemlock
let f = open("/path/to/file.txt", "r");
print(f.path);          // "/path/to/file.txt"
f.close();
```

---

### .mode

Get open mode.

**Type:** `string`

**Access:** Read-only

**Examples:**
```hemlock
let f = open("data.txt", "r");
print(f.mode);          // "r"
f.close();

let f2 = open("output.txt", "w");
print(f2.mode);         // "w"
f2.close();
```

---

### .closed

Check if file is closed.

**Type:** `bool`

**Access:** Read-only

**Examples:**
```hemlock
let f = open("data.txt", "r");
print(f.closed);        // false

f.close();
print(f.closed);        // true
```

---

## Error Handling

All file operations include proper error messages with context:

### File Not Found
```hemlock
let f = open("missing.txt", "r");
// Error: Failed to open 'missing.txt': No such file or directory
```

### Reading from Closed File
```hemlock
let f = open("data.txt", "r");
f.close();
f.read();
// Error: Cannot read from closed file 'data.txt'
```

### Writing to Read-Only File
```hemlock
let f = open("readonly.txt", "r");
f.write("data");
// Error: Cannot write to file 'readonly.txt' opened in read-only mode
```

### Using try/catch
```hemlock
let f = null;
try {
    f = open("data.txt", "r");
    let content = f.read();
    print(content);
} catch (e) {
    print("File error:", e);
} finally {
    if (f != null && !f.closed) {
        f.close();
    }
}
```

---

## Resource Management Patterns

### Basic Pattern

```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();
```

### With Error Handling

```hemlock
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();  // Always close, even on error
}
```

### Safe Pattern

```hemlock
let f = null;
try {
    f = open("data.txt", "r");
    let content = f.read();
    // ... process content ...
} catch (e) {
    print("Error:", e);
} finally {
    if (f != null && !f.closed) {
        f.close();
    }
}
```

---

## Usage Examples

### Read Entire File

```hemlock
fn read_file(filename: string): string {
    let f = open(filename, "r");
    let content = f.read();
    f.close();
    return content;
}

let text = read_file("data.txt");
print(text);
```

### Write Text File

```hemlock
fn write_file(filename: string, content: string) {
    let f = open(filename, "w");
    f.write(content);
    f.close();
}

write_file("output.txt", "Hello, World!\n");
```

### Append to File

```hemlock
fn append_file(filename: string, line: string) {
    let f = open(filename, "a");
    f.write(line + "\n");
    f.close();
}

append_file("log.txt", "Log entry 1");
append_file("log.txt", "Log entry 2");
```

### Read Binary File

```hemlock
fn read_binary(filename: string, size: i32): buffer {
    let f = open(filename, "r");
    let data = f.read_bytes(size);
    f.close();
    return data;
}

let binary = read_binary("data.bin", 256);
print("Read", binary.length, "bytes");
```

### Write Binary File

```hemlock
fn write_binary(filename: string, data: buffer) {
    let f = open(filename, "w");
    f.write_bytes(data);
    f.close();
}

let buf = buffer(10);
buf[0] = 65;
write_binary("output.bin", buf);
```

### Read File Line by Line

```hemlock
fn read_lines(filename: string): array {
    let f = open(filename, "r");
    let content = f.read();
    f.close();
    return content.split("\n");
}

let lines = read_lines("data.txt");
let i = 0;
while (i < lines.length) {
    print("Line", i, ":", lines[i]);
    i = i + 1;
}
```

### Copy File

```hemlock
fn copy_file(src: string, dest: string) {
    let f_in = open(src, "r");
    let f_out = open(dest, "w");

    let content = f_in.read();
    f_out.write(content);

    f_in.close();
    f_out.close();
}

copy_file("input.txt", "output.txt");
```

### Read File in Chunks

```hemlock
fn process_chunks(filename: string) {
    let f = open(filename, "r");

    while (true) {
        let chunk = f.read(1024);  // Read 1KB at a time
        if (chunk.length == 0) {
            break;  // EOF
        }

        // Process chunk
        print("Processing", chunk.length, "bytes");
    }

    f.close();
}

process_chunks("large_file.txt");
```

---

## Complete Method Summary

| Method        | Signature                | Returns   | Description                  |
|---------------|--------------------------|-----------|------------------------------|
| `read`        | `(size?: i32)`           | `string`  | Read text                    |
| `read_bytes`  | `(size: i32)`            | `buffer`  | Read binary data             |
| `write`       | `(data: string)`         | `i32`     | Write text                   |
| `write_bytes` | `(data: buffer)`         | `i32`     | Write binary data            |
| `seek`        | `(position: i32)`        | `i32`     | Set file position            |
| `tell`        | `()`                     | `i32`     | Get file position            |
| `close`       | `()`                     | `null`    | Close file (idempotent)      |

---

## Complete Property Summary

| Property  | Type     | Access     | Description              |
|-----------|----------|------------|--------------------------|
| `.path`   | `string` | Read-only  | File path                |
| `.mode`   | `string` | Read-only  | Open mode                |
| `.closed` | `bool`   | Read-only  | Whether file is closed   |

---

## Migration from Old API

**Old API (Removed):**
- `read_file(path)` - Use `open(path, "r").read()`
- `write_file(path, data)` - Use `open(path, "w").write(data)`
- `append_file(path, data)` - Use `open(path, "a").write(data)`
- `file_exists(path)` - No replacement yet

**Migration Example:**
```hemlock
// Old (v0.0)
let content = read_file("data.txt");
write_file("output.txt", content);

// New (v0.1)
let f = open("data.txt", "r");
let content = f.read();
f.close();

let f2 = open("output.txt", "w");
f2.write(content);
f2.close();
```

---

## See Also

- [Built-in Functions](#reference-builtins) - `open()` function
- [Memory API](#reference-memory-api) - Buffer type
- [String API](#reference-string-api) - String methods for text processing


--------------------------------------------------------------------------------
## Memory API
--------------------------------------------------------------------------------

# Memory API Reference

Complete reference for Hemlock's memory management functions and pointer types.

---

## Overview

Hemlock provides **manual memory management** with explicit allocation and deallocation. Memory is managed through two pointer types: raw pointers (`ptr`) and safe buffers (`buffer`).

**Key Principles:**
- Explicit allocation and deallocation
- No garbage collection
- User responsible for calling `free()`
- Internal refcounting for scope/reassignment safety (see below)

### Internal Reference Counting

The runtime uses reference counting internally to manage object lifetimes through scopes. For most local variables, cleanup is automatic.

**Automatic (no `free()` needed):**
- Local variables of refcounted types (buffer, array, object, string) are freed when scope exits
- Old values are released when variables are reassigned
- Container elements are released when containers are freed

**Manual `free()` required:**
- Raw pointers from `alloc()` - always
- Early cleanup before scope ends
- Long-lived/global data

See [Memory Management Guide](../language-guide/memory.md#internal-reference-counting) for details.

---

## Pointer Types

### ptr (Raw Pointer)

**Type:** `ptr`

**Description:** Raw memory address with no bounds checking or tracking.

**Size:** 8 bytes

**Use Cases:**
- Low-level memory operations
- FFI (Foreign Function Interface)
- Maximum performance (no overhead)

**Safety:** Unsafe - no bounds checking, user must track lifetime

**Examples:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

---

### buffer (Safe Buffer)

**Type:** `buffer`

**Description:** Safe pointer wrapper with bounds checking.

**Structure:** Pointer + length + capacity + ref_count

**Properties:**
- `.length` - Buffer size (i32)
- `.capacity` - Allocated capacity (i32)

**Use Cases:**
- Most memory allocations
- When safety is important
- Dynamic arrays

**Safety:** Bounds-checked on index access

**Refcounting:** Buffers are internally refcounted. Automatically freed when scope exits or variable is reassigned. Use `free()` for early cleanup or long-lived data.

**Examples:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // Bounds checked
print(b.length);        // 64
free(b);
```

---

## Memory Allocation Functions

### alloc

Allocate raw memory.

**Signature:**
```hemlock
alloc(size: i32): ptr
```

**Parameters:**
- `size` - Number of bytes to allocate

**Returns:** Pointer to allocated memory (`ptr`)

**Examples:**
```hemlock
let p = alloc(1024);        // Allocate 1KB
memset(p, 0, 1024);         // Initialize to zero
free(p);                    // Free when done

// Allocate for structure
let struct_size = 16;
let p2 = alloc(struct_size);
```

**Behavior:**
- Returns uninitialized memory
- Memory must be manually freed
- Returns `null` on allocation failure (caller must check)

**See Also:** `buffer()` for safer alternative

---

### buffer

Allocate safe buffer with bounds checking.

**Signature:**
```hemlock
buffer(size: i32): buffer
```

**Parameters:**
- `size` - Buffer size in bytes

**Returns:** Buffer object

**Examples:**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256
print(buf.capacity);        // 256

// Access with bounds checking
buf[0] = 65;                // 'A'
buf[255] = 90;              // 'Z'
// buf[256] = 0;            // ERROR: out of bounds

free(buf);
```

**Properties:**
- `.length` - Current size (i32)
- `.capacity` - Allocated capacity (i32)

**Behavior:**
- Initializes memory to zero
- Provides bounds checking on index access
- Returns `null` on allocation failure (caller must check)
- Must be manually freed

---

### free

Free allocated memory.

**Signature:**
```hemlock
free(ptr: ptr | buffer): null
```

**Parameters:**
- `ptr` - Pointer or buffer to free

**Returns:** `null`

**Examples:**
```hemlock
// Free raw pointer
let p = alloc(1024);
free(p);

// Free buffer
let buf = buffer(256);
free(buf);
```

**Behavior:**
- Frees memory allocated by `alloc()` or `buffer()`
- Double-free causes crash (user's responsibility to avoid)
- Freeing invalid pointers causes undefined behavior

**Important:** You allocate, you free. No automatic cleanup.

---

### realloc

Resize allocated memory.

**Signature:**
```hemlock
realloc(ptr: ptr, new_size: i32): ptr
```

**Parameters:**
- `ptr` - Pointer to resize
- `new_size` - New size in bytes

**Returns:** Pointer to resized memory (may be different address)

**Examples:**
```hemlock
let p = alloc(100);
// ... use memory ...

// Need more space
p = realloc(p, 200);        // Now 200 bytes
// ... use expanded memory ...

free(p);
```

**Behavior:**
- May move memory to new location
- Preserves existing data (up to minimum of old/new size)
- Old pointer is invalid after successful realloc (use returned pointer)
- If new_size is smaller, data is truncated
- Returns `null` on allocation failure (original pointer remains valid)

**Important:** Always check for `null` and update your pointer variable with the result.

---

## Memory Operations

### memset

Fill memory with byte value.

**Signature:**
```hemlock
memset(ptr: ptr, byte: i32, size: i32): null
```

**Parameters:**
- `ptr` - Pointer to memory
- `byte` - Byte value to fill (0-255)
- `size` - Number of bytes to fill

**Returns:** `null`

**Examples:**
```hemlock
let p = alloc(100);

// Zero out memory
memset(p, 0, 100);

// Fill with specific value
memset(p, 0xFF, 100);

// Initialize buffer
let buf = alloc(256);
memset(buf, 65, 256);       // Fill with 'A'

free(p);
free(buf);
```

**Behavior:**
- Writes byte value to each byte in range
- Byte value is truncated to 8 bits (0-255)
- No bounds checking (unsafe)

---

### memcpy

Copy memory from source to destination.

**Signature:**
```hemlock
memcpy(dest: ptr, src: ptr, size: i32): null
```

**Parameters:**
- `dest` - Destination pointer
- `src` - Source pointer
- `size` - Number of bytes to copy

**Returns:** `null`

**Examples:**
```hemlock
let src = alloc(100);
let dest = alloc(100);

// Initialize source
memset(src, 65, 100);

// Copy to destination
memcpy(dest, src, 100);

// dest now contains same data as src

free(src);
free(dest);
```

**Behavior:**
- Copies byte-by-byte from src to dest
- No bounds checking (unsafe)
- Overlapping regions have undefined behavior (use carefully)

---

## Typed Memory Operations

### sizeof

Get size of type in bytes.

**Signature:**
```hemlock
sizeof(type): i32
```

**Parameters:**
- `type` - Type identifier (e.g., `i32`, `f64`, `ptr`)

**Returns:** Size in bytes (i32)

**Type Sizes:**

| Type | Size (bytes) |
|------|--------------|
| `i8` | 1 |
| `i16` | 2 |
| `i32`, `integer` | 4 |
| `i64` | 8 |
| `u8`, `byte` | 1 |
| `u16` | 2 |
| `u32` | 4 |
| `u64` | 8 |
| `f32` | 4 |
| `f64`, `number` | 8 |
| `bool` | 1 |
| `ptr` | 8 |
| `rune` | 4 |

**Examples:**
```hemlock
let int_size = sizeof(i32);      // 4
let ptr_size = sizeof(ptr);      // 8
let float_size = sizeof(f64);    // 8
let byte_size = sizeof(u8);      // 1
let rune_size = sizeof(rune);    // 4

// Calculate array allocation size
let count = 100;
let total = sizeof(i32) * count; // 400 bytes
```

**Behavior:**
- Returns 0 for unknown types
- Accepts both type identifiers and type strings

---

### talloc

Allocate array of typed values.

**Signature:**
```hemlock
talloc(type, count: i32): ptr
```

**Parameters:**
- `type` - Type to allocate (e.g., `i32`, `f64`, `ptr`)
- `count` - Number of elements (must be positive)

**Returns:** Pointer to allocated array, or `null` on allocation failure

**Examples:**
```hemlock
let arr = talloc(i32, 100);      // Array of 100 i32s (400 bytes)
let floats = talloc(f64, 50);    // Array of 50 f64s (400 bytes)
let bytes = talloc(u8, 1024);    // Array of 1024 bytes

// Always check for allocation failure
if (arr == null) {
    panic("allocation failed");
}

// Use the allocated memory
// ...

free(arr);
free(floats);
free(bytes);
```

**Behavior:**
- Allocates `sizeof(type) * count` bytes
- Returns uninitialized memory
- Memory must be manually freed with `free()`
- Returns `null` on allocation failure (caller must check)
- Panics if count is not positive

---

## Buffer Properties

### .length

Get buffer size.

**Type:** `i32`

**Access:** Read-only

**Examples:**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256

let buf2 = buffer(1024);
print(buf2.length);         // 1024
```

---

### .capacity

Get buffer capacity.

**Type:** `i32`

**Access:** Read-only

**Examples:**
```hemlock
let buf = buffer(256);
print(buf.capacity);        // 256
```

**Note:** Currently, `.length` and `.capacity` are the same for buffers created with `buffer()`.

---

## Usage Patterns

### Basic Allocation Pattern

```hemlock
// Allocate
let p = alloc(1024);
if (p == null) {
    panic("allocation failed");
}

// Use
memset(p, 0, 1024);

// Free
free(p);
```

### Safe Buffer Pattern

```hemlock
// Allocate buffer
let buf = buffer(256);
if (buf == null) {
    panic("buffer allocation failed");
}

// Use with bounds checking
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

// Free
free(buf);
```

### Dynamic Growth Pattern

```hemlock
let size = 100;
let p = alloc(size);
if (p == null) {
    panic("allocation failed");
}

// ... use memory ...

// Need more space - check for failure
let new_p = realloc(p, 200);
if (new_p == null) {
    // Original pointer still valid, clean up
    free(p);
    panic("realloc failed");
}
p = new_p;
size = 200;

// ... use expanded memory ...

free(p);
```

### Memory Copy Pattern

```hemlock
let original = alloc(100);
memset(original, 65, 100);

// Create copy
let copy = alloc(100);
memcpy(copy, original, 100);

free(original);
free(copy);
```

---

## Safety Considerations

**Hemlock memory management is UNSAFE by design:**

### Common Pitfalls

**1. Memory Leaks**
```hemlock
// BAD: Memory leak
fn create_buffer() {
    let p = alloc(1024);
    return null;  // Memory leaked!
}

// GOOD: Proper cleanup
fn create_buffer() {
    let p = alloc(1024);
    // ... use memory ...
    free(p);
    return null;
}
```

**2. Use After Free**
```hemlock
// BAD: Use after free
let p = alloc(100);
free(p);
memset(p, 0, 100);  // CRASH: using freed memory

// GOOD: Don't use after free
let p2 = alloc(100);
memset(p2, 0, 100);
free(p2);
// Don't touch p2 after this
```

**3. Double Free**
```hemlock
// BAD: Double free
let p = alloc(100);
free(p);
free(p);  // CRASH: double free

// GOOD: Free once
let p2 = alloc(100);
free(p2);
```

**4. Buffer Overflow (ptr)**
```hemlock
// BAD: Buffer overflow with ptr
let p = alloc(10);
memset(p, 65, 100);  // CRASH: writing past allocation

// GOOD: Use buffer for bounds checking
let buf = buffer(10);
// buf[100] = 65;  // ERROR: bounds check fails
```

**5. Dangling Pointers**
```hemlock
// BAD: Dangling pointer
let p1 = alloc(100);
let p2 = p1;
free(p1);
memset(p2, 0, 100);  // CRASH: p2 is dangling

// GOOD: Track ownership carefully
let p = alloc(100);
// ... use p ...
free(p);
// Don't keep other references to p
```

**6. Unchecked Allocation Failure**
```hemlock
// BAD: Not checking for null
let p = alloc(1000000000);  // May fail on low memory
memset(p, 0, 1000000000);   // CRASH: p is null

// GOOD: Always check allocation result
let p2 = alloc(1000000000);
if (p2 == null) {
    panic("out of memory");
}
memset(p2, 0, 1000000000);
free(p2);
```

---

## When to Use What

### Use `buffer()` when:
- You need bounds checking
- Working with dynamic data
- Safety is important
- Learning Hemlock

### Use `alloc()` when:
- Maximum performance needed
- FFI/interfacing with C
- You know exact memory layout
- You're an expert

### Use `realloc()` when:
- Growing/shrinking allocations
- Dynamic arrays
- You need to preserve data

---

## Complete Function Summary

| Function  | Signature                              | Returns  | Description                |
|-----------|----------------------------------------|----------|----------------------------|
| `alloc`   | `(size: i32)`                          | `ptr`    | Allocate raw memory        |
| `buffer`  | `(size: i32)`                          | `buffer` | Allocate safe buffer       |
| `free`    | `(ptr: ptr \| buffer)`                 | `null`   | Free memory                |
| `realloc` | `(ptr: ptr, new_size: i32)`            | `ptr`    | Resize allocation          |
| `memset`  | `(ptr: ptr, byte: i32, size: i32)`     | `null`   | Fill memory                |
| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`     | `null`   | Copy memory                |
| `sizeof`  | `(type)`                               | `i32`    | Get type size in bytes     |
| `talloc`  | `(type, count: i32)`                   | `ptr`    | Allocate typed array       |

---

## See Also

- [Type System](#reference-type-system) - Pointer and buffer types
- [Built-in Functions](#reference-builtins) - All built-in functions
- [String API](#reference-string-api) - String `.to_bytes()` method


--------------------------------------------------------------------------------
## Operators
--------------------------------------------------------------------------------

# Operators Reference

Complete reference for all operators in Hemlock, including precedence, associativity, and behavior.

---

## Overview

Hemlock provides C-style operators with explicit precedence rules. All operators follow strict typing rules with automatic type promotion where applicable.

---

## Arithmetic Operators

### Binary Arithmetic

| Operator | Name           | Example    | Description                  |
|----------|----------------|------------|------------------------------|
| `+`      | Addition       | `a + b`    | Add two values               |
| `-`      | Subtraction    | `a - b`    | Subtract b from a            |
| `*`      | Multiplication | `a * b`    | Multiply two values          |
| `/`      | Division       | `a / b`    | Divide a by b                |

**Type Promotion:**
Results follow type promotion rules (see [Type System](type-system.md#type-promotion-rules)).

**Examples:**
```hemlock
let a = 10 + 5;        // 15 (i32)
let b = 10 - 3;        // 7 (i32)
let c = 4 * 5;         // 20 (i32)
let d = 20 / 4;        // 5 (i32)

// Float division
let e = 10.0 / 3.0;    // 3.333... (f64)

// Mixed types
let f: u8 = 10;
let g: i32 = 20;
let h = f + g;         // 30 (i32, promoted)
```

**Division by Zero:**
- Integer division by zero: Runtime error
- Float division by zero: Returns `inf` or `-inf`

---

### Unary Arithmetic

| Operator | Name     | Example | Description          |
|----------|----------|---------|----------------------|
| `-`      | Negation | `-a`    | Negate value         |
| `+`      | Plus     | `+a`    | Identity (no-op)     |

**Examples:**
```hemlock
let a = 5;
let b = -a;            // -5
let c = +a;            // 5 (no change)

let x = -3.14;         // -3.14
```

---

## Comparison Operators

| Operator | Name                  | Example    | Returns |
|----------|-----------------------|------------|---------|
| `==`     | Equal                 | `a == b`   | `bool`  |
| `!=`     | Not equal             | `a != b`   | `bool`  |
| `<`      | Less than             | `a < b`    | `bool`  |
| `>`      | Greater than          | `a > b`    | `bool`  |
| `<=`     | Less than or equal    | `a <= b`   | `bool`  |
| `>=`     | Greater than or equal | `a >= b`   | `bool`  |

**Type Promotion:**
Operands are promoted before comparison.

**Examples:**
```hemlock
print(5 == 5);         // true
print(10 != 5);        // true
print(3 < 7);          // true
print(10 > 5);         // true
print(5 <= 5);         // true
print(10 >= 5);        // true

// String comparison
print("hello" == "hello");  // true
print("abc" < "def");       // true (lexicographic)

// Mixed types
let a: u8 = 10;
let b: i32 = 10;
print(a == b);         // true (promoted to i32)
```

---

## Logical Operators

| Operator | Name        | Example      | Description              |
|----------|-------------|--------------|--------------------------|
| `&&`     | Logical AND | `a && b`     | True if both are true    |
| `||`     | Logical OR  | `a || b`     | True if either is true   |
| `!`      | Logical NOT | `!a`         | Negate boolean           |

**Short-Circuit Evaluation:**
- `&&` - Stops at first false value
- `||` - Stops at first true value

**Examples:**
```hemlock
let a = true;
let b = false;

print(a && b);         // false
print(a || b);         // true
print(!a);             // false
print(!b);             // true

// Short-circuit
if (x != 0 && (10 / x) > 2) {
    print("safe");
}

if (x == 0 || (10 / x) > 2) {
    print("safe");
}
```

---

## Bitwise Operators

**Restriction:** Integer types only (i8-i64, u8-u64)

### Binary Bitwise

| Operator | Name         | Example    | Description              |
|----------|--------------|------------|--------------------------|
| `&`      | Bitwise AND  | `a & b`    | AND each bit             |
| `|`      | Bitwise OR   | `a | b`    | OR each bit              |
| `^`      | Bitwise XOR  | `a ^ b`    | XOR each bit             |
| `<<`     | Left shift   | `a << b`   | Shift left by b bits     |
| `>>`     | Right shift  | `a >> b`   | Shift right by b bits    |

**Type Preservation:**
Result type matches operand types (with type promotion).

**Examples:**
```hemlock
let a = 12;  // 1100 in binary
let b = 10;  // 1010 in binary

print(a & b);          // 8  (1000)
print(a | b);          // 14 (1110)
print(a ^ b);          // 6  (0110)
print(a << 2);         // 48 (110000)
print(a >> 1);         // 6  (110)
```

**Unsigned Example:**
```hemlock
let c: u8 = 15;        // 00001111
let d: u8 = 7;         // 00000111

print(c & d);          // 7  (00000111)
print(c | d);          // 15 (00001111)
print(c ^ d);          // 8  (00001000)
```

**Right Shift Behavior:**
- Signed types: Arithmetic shift (sign-extends)
- Unsigned types: Logical shift (zero-fills)

---

### Unary Bitwise

| Operator | Name        | Example | Description              |
|----------|-------------|---------|--------------------------|
| `~`      | Bitwise NOT | `~a`    | Flip all bits            |

**Examples:**
```hemlock
let a = 12;            // 00001100 (i32)
print(~a);             // -13 (two's complement)

let b: u8 = 15;        // 00001111
print(~b);             // 240 (11110000)
```

---

## String Operators

### Concatenation

| Operator | Name           | Example    | Description        |
|----------|----------------|------------|--------------------|
| `+`      | Concatenation  | `a + b`    | Join strings       |

**Examples:**
```hemlock
let s = "hello" + " " + "world";  // "hello world"
let msg = "Count: " + typeof(42); // "Count: 42"

// String + rune
let greeting = "Hello" + '!';      // "Hello!"

// Rune + string
let prefix = '>' + " Message";     // "> Message"
```

---

## Assignment Operators

### Basic Assignment

| Operator | Name       | Example    | Description              |
|----------|------------|------------|--------------------------|
| `=`      | Assignment | `a = b`    | Assign value to variable |

**Examples:**
```hemlock
let x = 10;
x = 20;

let arr = [1, 2, 3];
arr[0] = 99;

let obj = { x: 10 };
obj.x = 20;
```

### Compound Assignment

#### Arithmetic Compound Assignment

| Operator | Name            | Example    | Equivalent         |
|----------|-----------------|------------|--------------------|
| `+=`     | Add assign      | `a += b`   | `a = a + b`        |
| `-=`     | Subtract assign | `a -= b`   | `a = a - b`        |
| `*=`     | Multiply assign | `a *= b`   | `a = a * b`        |
| `/=`     | Divide assign   | `a /= b`   | `a = a / b`        |
| `%=`     | Modulo assign   | `a %= b`   | `a = a % b`        |

**Examples:**
```hemlock
let x = 10;
x += 5;      // x is now 15
x -= 3;      // x is now 12
x *= 2;      // x is now 24
x /= 4;      // x is now 6

let count = 0;
count += 1;  // Increment by 1
```

#### Bitwise Compound Assignment

| Operator | Name               | Example     | Equivalent          |
|----------|--------------------|-------------|---------------------|
| `&=`     | Bitwise AND assign | `a &= b`    | `a = a & b`         |
| `\|=`    | Bitwise OR assign  | `a \|= b`   | `a = a \| b`        |
| `^=`     | Bitwise XOR assign | `a ^= b`    | `a = a ^ b`         |
| `<<=`    | Left shift assign  | `a <<= b`   | `a = a << b`        |
| `>>=`    | Right shift assign | `a >>= b`   | `a = a >> b`        |

**Examples:**
```hemlock
let flags = 0b1111;
flags &= 0b0011;   // flags is now 0b0011 (mask off upper bits)
flags |= 0b1000;   // flags is now 0b1011 (set a bit)
flags ^= 0b0001;   // flags is now 0b1010 (toggle a bit)

let x = 1;
x <<= 4;           // x is now 16 (shift left by 4)
x >>= 2;           // x is now 4 (shift right by 2)
```

### Increment/Decrement

| Operator | Name       | Example | Description              |
|----------|------------|---------|--------------------------|
| `++`     | Increment  | `a++`   | Increment by 1 (postfix) |
| `--`     | Decrement  | `a--`   | Decrement by 1 (postfix) |

**Examples:**
```hemlock
let i = 0;
i++;         // i is now 1
i++;         // i is now 2
i--;         // i is now 1

// Common in loops
for (let j = 0; j < 10; j++) {
    print(j);
}
```

**Note:** Both `++` and `--` are postfix operators (value is returned before increment/decrement)

---

## Null Safety Operators

### Null Coalescing (`??`)

Returns the left operand if it's not null, otherwise returns the right operand.

| Operator | Name             | Example      | Description                    |
|----------|------------------|--------------|--------------------------------|
| `??`     | Null coalescing  | `a ?? b`     | Return a if not null, else b   |

**Examples:**
```hemlock
let name = null;
let display = name ?? "Anonymous";  // "Anonymous"

let value = 42;
let result = value ?? 0;            // 42

// Chaining
let a = null;
let b = null;
let c = "found";
let result2 = a ?? b ?? c;          // "found"

// With function calls
fn get_config() { return null; }
let config = get_config() ?? { default: true };
```

---

### Optional Chaining (`?.`)

Safely access properties or call methods on potentially null values.

| Operator | Name              | Example        | Description                      |
|----------|-------------------|----------------|----------------------------------|
| `?.`     | Optional chaining | `a?.b`         | Return a.b if a not null, else null |
| `?.[`    | Optional index    | `a?.[0]`       | Return a[0] if a not null, else null |
| `?.(`    | Optional call     | `a?.()`        | Call a() if a not null, else null |

**Examples:**
```hemlock
let user = null;
let name = user?.name;              // null (no error)

let person = { name: "Alice", address: null };
let city = person?.address?.city;   // null (safe navigation)

// With arrays
let arr = null;
let first = arr?.[0];               // null

let items = [1, 2, 3];
let second = items?.[1];            // 2

// With method calls
let obj = { greet: fn() { return "Hello"; } };
let greeting = obj?.greet?.();      // "Hello"

let empty = null;
let result = empty?.method?.();     // null
```

**Behavior:**
- If the left operand is null, the entire expression short-circuits to null
- If the left operand is not null, the access proceeds normally
- Can be chained for deep property access

---

## Member Access Operators

### Dot Operator

| Operator | Name             | Example      | Description           |
|----------|------------------|--------------|-----------------------|
| `.`      | Member access    | `obj.field`  | Access object field   |
| `.`      | Property access  | `arr.length` | Access property       |

**Examples:**
```hemlock
// Object field access
let person = { name: "Alice", age: 30 };
print(person.name);        // "Alice"

// Array property
let arr = [1, 2, 3];
print(arr.length);         // 3

// String property
let s = "hello";
print(s.length);           // 5

// Method call
let result = s.to_upper(); // "HELLO"
```

---

### Index Operator

| Operator | Name    | Example   | Description          |
|----------|---------|-----------|----------------------|
| `[]`     | Index   | `arr[i]`  | Access element       |

**Examples:**
```hemlock
// Array indexing
let arr = [10, 20, 30];
print(arr[0]);             // 10
arr[1] = 99;

// String indexing (returns rune)
let s = "hello";
print(s[0]);               // 'h'
s[0] = 'H';                // "Hello"

// Buffer indexing
let buf = buffer(10);
buf[0] = 65;
print(buf[0]);             // 65
```

---

## Function Call Operator

| Operator | Name          | Example      | Description        |
|----------|---------------|--------------|--------------------|
| `()`     | Function call | `f(a, b)`    | Call function      |

**Examples:**
```hemlock
fn add(a, b) {
    return a + b;
}

let result = add(5, 3);    // 8

// Method call
let s = "hello";
let upper = s.to_upper();  // "HELLO"

// Builtin call
print("message");
```

---

## Operator Precedence

Operators are listed from highest to lowest precedence:

| Precedence | Operators                  | Description                    | Associativity |
|------------|----------------------------|--------------------------------|---------------|
| 1          | `()` `[]` `.` `?.`         | Call, index, member access, optional chain | Left-to-right |
| 2          | `++` `--`                  | Postfix increment/decrement    | Left-to-right |
| 3          | `!` `~` `-` (unary) `+` (unary) | Logical NOT, bitwise NOT, negation | Right-to-left |
| 4          | `*` `/` `%`                | Multiplication, division, modulo | Left-to-right |
| 5          | `+` `-`                    | Addition, subtraction          | Left-to-right |
| 6          | `<<` `>>`                  | Bit shifts                     | Left-to-right |
| 7          | `<` `<=` `>` `>=`          | Relational                     | Left-to-right |
| 8          | `==` `!=`                  | Equality                       | Left-to-right |
| 9          | `&`                        | Bitwise AND                    | Left-to-right |
| 10         | `^`                        | Bitwise XOR                    | Left-to-right |
| 11         | `|`                        | Bitwise OR                     | Left-to-right |
| 12         | `&&`                       | Logical AND                    | Left-to-right |
| 13         | `||`                       | Logical OR                     | Left-to-right |
| 14         | `??`                       | Null coalescing                | Left-to-right |
| 15         | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\|=` `^=` `<<=` `>>=` | Assignment | Right-to-left |

---

## Precedence Examples

### Example 1: Arithmetic and Comparison
```hemlock
let result = 5 + 3 * 2;
// Evaluated as: 5 + (3 * 2) = 11
// Multiplication has higher precedence than addition

let cmp = 10 > 5 + 3;
// Evaluated as: 10 > (5 + 3) = true
// Addition has higher precedence than comparison
```

### Example 2: Bitwise Operators
```hemlock
let result1 = 12 | 10 & 8;
// Evaluated as: 12 | (10 & 8) = 12 | 8 = 12
// & has higher precedence than |

let result2 = 8 | 1 << 2;
// Evaluated as: 8 | (1 << 2) = 8 | 4 = 12
// Shift has higher precedence than bitwise OR

// Use parentheses for clarity
let result3 = (5 & 3) | (2 << 1);
// Evaluated as: 1 | 4 = 5
```

### Example 3: Logical Operators
```hemlock
let result = true || false && false;
// Evaluated as: true || (false && false) = true
// && has higher precedence than ||

let cmp = 5 < 10 && 10 < 20;
// Evaluated as: (5 < 10) && (10 < 20) = true
// Comparison has higher precedence than &&
```

### Example 4: Using Parentheses
```hemlock
// Without parentheses
let a = 2 + 3 * 4;        // 14

// With parentheses
let b = (2 + 3) * 4;      // 20

// Complex expression
let c = (a + b) * (a - b);
```

---

## Type-Specific Operator Behavior

### Division (Always Float)

The `/` operator **always returns a float** (f64), regardless of operand types:

```hemlock
print(10 / 3);             // 3.333... (f64)
print(5 / 2);              // 2.5 (f64)
print(10.0 / 4.0);         // 2.5 (f64)
print(-7 / 3);             // -2.333... (f64)
```

This prevents the common bug of unexpected integer truncation.

### Floor Division (div / divi)

For floor division (like integer division in other languages), use the `div()` and `divi()` functions:

```hemlock
// div(a, b) - floor division returning float
print(div(5, 2));          // 2 (f64)
print(div(-7, 3));         // -3 (f64)  -- floors toward -infinity

// divi(a, b) - floor division returning integer
print(divi(5, 2));         // 2 (i64)
print(divi(-7, 3));        // -3 (i64)
print(typeof(divi(5, 2))); // i64
```

**Integer-returning math functions:**
For other rounding operations that return integers:

```hemlock
print(floori(3.7));        // 3 (i64)
print(ceili(3.2));         // 4 (i64)
print(roundi(3.5));        // 4 (i64)
print(trunci(3.9));        // 3 (i64)

// These can be used directly as array indices
let arr = [10, 20, 30, 40];
print(arr[floori(1.9)]);   // 20 (index 1)
```

### String Comparison

Strings are compared lexicographically:

```hemlock
print("abc" < "def");      // true
print("apple" > "banana"); // false
print("hello" == "hello"); // true
```

### Null Comparison

```hemlock
let x = null;

print(x == null);          // true
print(x != null);          // false
```

### Type Errors

Some operations are not allowed between incompatible types:

```hemlock
// ERROR: Cannot use bitwise operators on floats
let x = 3.14 & 2.71;

// ERROR: Cannot use bitwise operators on strings
let y = "hello" & "world";

// OK: Type promotion for arithmetic
let a: u8 = 10;
let b: i32 = 20;
let c = a + b;             // i32 (promoted)
```

---

## See Also

- [Type System](#reference-type-system) - Type promotion and conversion rules
- [Built-in Functions](#reference-builtins) - Built-in operations
- [String API](#reference-string-api) - String concatenation and methods


--------------------------------------------------------------------------------
## String API
--------------------------------------------------------------------------------

# String API Reference

Complete reference for Hemlock's string type and all 19 string methods.

---

## Overview

Strings in Hemlock are **UTF-8 encoded, mutable, heap-allocated** sequences with full Unicode support. All operations work with **codepoints** (characters), not bytes.

**Key Features:**
- UTF-8 encoding (U+0000 to U+10FFFF)
- Mutable (can modify characters in place)
- Codepoint-based indexing
- 19 built-in methods
- Automatic concatenation with `+` operator

---

## String Type

**Type:** `string`

**Properties:**
- `.length` - Number of codepoints (characters)
- `.byte_length` - Number of UTF-8 bytes

**Literal Syntax:** Double quotes `"text"`

**Examples:**
```hemlock
let s = "hello";
print(s.length);        // 5 (codepoints)
print(s.byte_length);   // 5 (bytes)

let emoji = "ðŸš€";
print(emoji.length);        // 1 (one codepoint)
print(emoji.byte_length);   // 4 (four UTF-8 bytes)
```

---

## Indexing

Strings support codepoint-based indexing using `[]`:

**Read Access:**
```hemlock
let s = "hello";
let ch = s[0];          // Returns rune 'h'
```

**Write Access:**
```hemlock
let s = "hello";
s[0] = 'H';             // Mutate with rune (now "Hello")
```

**UTF-8 Example:**
```hemlock
let text = "HiðŸš€!";
print(text[0]);         // 'H'
print(text[1]);         // 'i'
print(text[2]);         // 'ðŸš€' (one codepoint)
print(text[3]);         // '!'
```

---

## Concatenation

Use the `+` operator to concatenate strings and runes:

**String + String:**
```hemlock
let s = "hello" + " " + "world";  // "hello world"
let msg = "Count: " + typeof(42); // "Count: 42"
```

**String + Rune:**
```hemlock
let greeting = "Hello" + '!';      // "Hello!"
let decorated = "Text" + 'âœ“';      // "Textâœ“"
```

**Rune + String:**
```hemlock
let prefix = '>' + " Message";     // "> Message"
let bullet = 'â€¢' + " Item";        // "â€¢ Item"
```

**Multiple Concatenations:**
```hemlock
let msg = "Hi " + 'ðŸ‘‹' + " World " + 'ðŸŒ';  // "Hi ðŸ‘‹ World ðŸŒ"
```

---

## String Properties

### .length

Get the number of Unicode codepoints (characters).

**Type:** `i32`

**Examples:**
```hemlock
let s = "hello";
print(s.length);        // 5

let emoji = "ðŸš€";
print(emoji.length);    // 1 (one codepoint)

let text = "Hello ðŸŒ!";
print(text.length);     // 8 (7 ASCII + 1 emoji)
```

---

### .byte_length

Get the number of UTF-8 bytes.

**Type:** `i32`

**Examples:**
```hemlock
let s = "hello";
print(s.byte_length);   // 5 (1 byte per ASCII char)

let emoji = "ðŸš€";
print(emoji.byte_length); // 4 (emoji is 4 UTF-8 bytes)

let text = "Hello ðŸŒ!";
print(text.byte_length);  // 11 (7 ASCII + 4 for emoji)
```

---

## String Methods

### Substring & Slicing

#### substr

Extract substring by position and length.

**Signature:**
```hemlock
string.substr(start: i32, length: i32): string
```

**Parameters:**
- `start` - Starting codepoint index (0-based)
- `length` - Number of codepoints to extract

**Returns:** New string

**Examples:**
```hemlock
let s = "hello world";
let sub = s.substr(6, 5);       // "world"
let first = s.substr(0, 5);     // "hello"

// UTF-8 example
let text = "HiðŸš€!";
let emoji = text.substr(2, 1);  // "ðŸš€"
```

---

#### slice

Extract substring by range (end exclusive).

**Signature:**
```hemlock
string.slice(start: i32, end: i32): string
```

**Parameters:**
- `start` - Starting codepoint index (0-based)
- `end` - Ending codepoint index (exclusive)

**Returns:** New string

**Examples:**
```hemlock
let s = "hello world";
let sub = s.slice(0, 5);        // "hello"
let world = s.slice(6, 11);     // "world"

// UTF-8 example
let text = "HiðŸš€!";
let first_three = text.slice(0, 3);  // "HiðŸš€"
```

---

### Search & Find

#### find

Find first occurrence of substring.

**Signature:**
```hemlock
string.find(needle: string): i32
```

**Parameters:**
- `needle` - Substring to search for

**Returns:** Codepoint index of first occurrence, or `-1` if not found

**Examples:**
```hemlock
let s = "hello world";
let pos = s.find("world");      // 6
let pos2 = s.find("foo");       // -1 (not found)
let pos3 = s.find("l");         // 2 (first 'l')
```

---

#### contains

Check if string contains substring.

**Signature:**
```hemlock
string.contains(needle: string): bool
```

**Parameters:**
- `needle` - Substring to search for

**Returns:** `true` if found, `false` otherwise

**Examples:**
```hemlock
let s = "hello world";
let has = s.contains("world");  // true
let has2 = s.contains("foo");   // false
```

---

### Split & Join

#### split

Split string into array by delimiter.

**Signature:**
```hemlock
string.split(delimiter: string): array
```

**Parameters:**
- `delimiter` - String to split on

**Returns:** Array of strings

**Examples:**
```hemlock
let csv = "a,b,c";
let parts = csv.split(",");     // ["a", "b", "c"]

let path = "/usr/local/bin";
let dirs = path.split("/");     // ["", "usr", "local", "bin"]

let text = "hello world foo";
let words = text.split(" ");    // ["hello", "world", "foo"]
```

---

#### trim

Remove leading and trailing whitespace.

**Signature:**
```hemlock
string.trim(): string
```

**Returns:** New string with whitespace removed

**Examples:**
```hemlock
let s = "  hello  ";
let clean = s.trim();           // "hello"

let text = "\n\t  world  \n";
let clean2 = text.trim();       // "world"
```

---

### Case Conversion

#### to_upper

Convert string to uppercase.

**Signature:**
```hemlock
string.to_upper(): string
```

**Returns:** New string in uppercase

**Examples:**
```hemlock
let s = "hello world";
let upper = s.to_upper();       // "HELLO WORLD"

let mixed = "HeLLo";
let upper2 = mixed.to_upper();  // "HELLO"
```

---

#### to_lower

Convert string to lowercase.

**Signature:**
```hemlock
string.to_lower(): string
```

**Returns:** New string in lowercase

**Examples:**
```hemlock
let s = "HELLO WORLD";
let lower = s.to_lower();       // "hello world"

let mixed = "HeLLo";
let lower2 = mixed.to_lower();  // "hello"
```

---

### Prefix & Suffix

#### starts_with

Check if string starts with prefix.

**Signature:**
```hemlock
string.starts_with(prefix: string): bool
```

**Parameters:**
- `prefix` - Prefix to check

**Returns:** `true` if string starts with prefix, `false` otherwise

**Examples:**
```hemlock
let s = "hello world";
let starts = s.starts_with("hello");  // true
let starts2 = s.starts_with("world"); // false
```

---

#### ends_with

Check if string ends with suffix.

**Signature:**
```hemlock
string.ends_with(suffix: string): bool
```

**Parameters:**
- `suffix` - Suffix to check

**Returns:** `true` if string ends with suffix, `false` otherwise

**Examples:**
```hemlock
let s = "hello world";
let ends = s.ends_with("world");      // true
let ends2 = s.ends_with("hello");     // false
```

---

### Replacement

#### replace

Replace first occurrence of substring.

**Signature:**
```hemlock
string.replace(old: string, new: string): string
```

**Parameters:**
- `old` - Substring to replace
- `new` - Replacement string

**Returns:** New string with first occurrence replaced

**Examples:**
```hemlock
let s = "hello world";
let s2 = s.replace("world", "there");  // "hello there"

let text = "foo foo foo";
let text2 = text.replace("foo", "bar"); // "bar foo foo" (only first)
```

---

#### replace_all

Replace all occurrences of substring.

**Signature:**
```hemlock
string.replace_all(old: string, new: string): string
```

**Parameters:**
- `old` - Substring to replace
- `new` - Replacement string

**Returns:** New string with all occurrences replaced

**Examples:**
```hemlock
let text = "foo foo foo";
let text2 = text.replace_all("foo", "bar"); // "bar bar bar"

let s = "hello world hello";
let s2 = s.replace_all("hello", "hi");      // "hi world hi"
```

---

### Repetition

#### repeat

Repeat string n times.

**Signature:**
```hemlock
string.repeat(count: i32): string
```

**Parameters:**
- `count` - Number of repetitions

**Returns:** New string repeated count times

**Examples:**
```hemlock
let s = "ha";
let repeated = s.repeat(3);     // "hahaha"

let line = "-";
let separator = line.repeat(40); // "----------------------------------------"
```

---

### Character Access

#### char_at

Get Unicode codepoint at index.

**Signature:**
```hemlock
string.char_at(index: i32): rune
```

**Parameters:**
- `index` - Codepoint index (0-based)

**Returns:** Rune (Unicode codepoint)

**Examples:**
```hemlock
let s = "hello";
let ch = s.char_at(0);          // 'h'
let ch2 = s.char_at(1);         // 'e'

// UTF-8 example
let emoji = "ðŸš€";
let ch3 = emoji.char_at(0);     // U+1F680 (rocket)
```

---

#### chars

Convert string to array of runes.

**Signature:**
```hemlock
string.chars(): array
```

**Returns:** Array of runes (codepoints)

**Examples:**
```hemlock
let s = "hello";
let chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']

// UTF-8 example
let text = "HiðŸš€!";
let chars2 = text.chars();      // ['H', 'i', 'ðŸš€', '!']
```

---

### Byte Access

#### byte_at

Get byte value at index.

**Signature:**
```hemlock
string.byte_at(index: i32): u8
```

**Parameters:**
- `index` - Byte index (0-based, NOT codepoint index)

**Returns:** Byte value (u8)

**Examples:**
```hemlock
let s = "hello";
let byte = s.byte_at(0);        // 104 (ASCII 'h')
let byte2 = s.byte_at(1);       // 101 (ASCII 'e')

// UTF-8 example
let emoji = "ðŸš€";
let byte3 = emoji.byte_at(0);   // 240 (first UTF-8 byte)
```

---

#### bytes

Convert string to array of bytes.

**Signature:**
```hemlock
string.bytes(): array
```

**Returns:** Array of u8 bytes

**Examples:**
```hemlock
let s = "hello";
let bytes = s.bytes();          // [104, 101, 108, 108, 111]

// UTF-8 example
let emoji = "ðŸš€";
let bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 UTF-8 bytes)
```

---

#### to_bytes

Convert string to buffer.

**Signature:**
```hemlock
string.to_bytes(): buffer
```

**Returns:** Buffer containing UTF-8 bytes

**Examples:**
```hemlock
let s = "hello";
let buf = s.to_bytes();
print(buf.length);              // 5

// UTF-8 example
let emoji = "ðŸš€";
let buf2 = emoji.to_bytes();
print(buf2.length);             // 4
```

**Note:** This is a legacy method. Prefer `.bytes()` for most use cases.

---

### JSON Deserialization

#### deserialize

Parse JSON string to value.

**Signature:**
```hemlock
string.deserialize(): any
```

**Returns:** Parsed value (object, array, number, string, bool, or null)

**Examples:**
```hemlock
let json = '{"x":10,"y":20}';
let obj = json.deserialize();
print(obj.x);                   // 10
print(obj.y);                   // 20

let arr_json = '[1,2,3]';
let arr = arr_json.deserialize();
print(arr[0]);                  // 1

let num_json = '42';
let num = num_json.deserialize();
print(num);                     // 42
```

**Supported Types:**
- Objects: `{"key": value}`
- Arrays: `[1, 2, 3]`
- Numbers: `42`, `3.14`
- Strings: `"text"`
- Booleans: `true`, `false`
- Null: `null`

**See Also:** Object `.serialize()` method

---

## Method Chaining

String methods can be chained for concise operations:

**Examples:**
```hemlock
let result = "  Hello World  "
    .trim()
    .to_lower()
    .replace("world", "hemlock");  // "hello hemlock"

let processed = "foo,bar,baz"
    .split(",")
    .join(" | ");                  // "foo | bar | baz"

let cleaned = "  HELLO  "
    .trim()
    .to_lower();                   // "hello"
```

---

## Complete Method Summary

| Method         | Signature                                    | Returns   | Description                           |
|----------------|----------------------------------------------|-----------|---------------------------------------|
| `substr`       | `(start: i32, length: i32)`                  | `string`  | Extract substring by position/length  |
| `slice`        | `(start: i32, end: i32)`                     | `string`  | Extract substring by range            |
| `find`         | `(needle: string)`                           | `i32`     | Find first occurrence (-1 if not found)|
| `contains`     | `(needle: string)`                           | `bool`    | Check if contains substring           |
| `split`        | `(delimiter: string)`                        | `array`   | Split into array                      |
| `trim`         | `()`                                         | `string`  | Remove whitespace                     |
| `to_upper`     | `()`                                         | `string`  | Convert to uppercase                  |
| `to_lower`     | `()`                                         | `string`  | Convert to lowercase                  |
| `starts_with`  | `(prefix: string)`                           | `bool`    | Check if starts with prefix           |
| `ends_with`    | `(suffix: string)`                           | `bool`    | Check if ends with suffix             |
| `replace`      | `(old: string, new: string)`                 | `string`  | Replace first occurrence              |
| `replace_all`  | `(old: string, new: string)`                 | `string`  | Replace all occurrences               |
| `repeat`       | `(count: i32)`                               | `string`  | Repeat string n times                 |
| `char_at`      | `(index: i32)`                               | `rune`    | Get codepoint at index                |
| `byte_at`      | `(index: i32)`                               | `u8`      | Get byte at index                     |
| `chars`        | `()`                                         | `array`   | Convert to array of runes             |
| `bytes`        | `()`                                         | `array`   | Convert to array of bytes             |
| `to_bytes`     | `()`                                         | `buffer`  | Convert to buffer (legacy)            |
| `deserialize`  | `()`                                         | `any`     | Parse JSON string                     |

---

## See Also

- [Type System](#reference-type-system) - String type details
- [Array API](#reference-array-api) - Array methods for split() results
- [Operators](#reference-operators) - String concatenation operator


--------------------------------------------------------------------------------
## Type System
--------------------------------------------------------------------------------

# Type System Reference

Complete reference for Hemlock's type system, including all primitive and composite types.

---

## Overview

Hemlock uses a **dynamic type system** with runtime type tags and optional type annotations. Every value has a runtime type, and type conversions follow explicit promotion rules.

**Key Features:**
- Runtime type checking (interpreter)
- Compile-time type checking (hemlockc - enabled by default)
- Optional type annotations
- Automatic type inference for literals
- Explicit type promotion rules
- No implicit conversions that lose precision

---

## Compile-Time Type Checking (hemlockc)

The Hemlock compiler (`hemlockc`) includes a compile-time type checker that validates your code before generating executables. This catches type errors early without needing to run the program.

### Default Behavior

Type checking is **enabled by default** in hemlockc:

```bash
# Type checking happens automatically
hemlockc program.hml -o program

# Errors are reported before compilation
hemlockc bad_types.hml
# Output: 1 type error found
```

### Compiler Flags

| Flag | Description |
|------|-------------|
| `--check` | Check types only, don't compile (exit after validation) |
| `--no-type-check` | Disable type checking (not recommended) |
| `--strict-types` | Enable stricter type warnings |

**Examples:**

```bash
# Just validate types without compiling
hemlockc --check program.hml
# Output: program.hml: no type errors

# Disable type checking (use with caution)
hemlockc --no-type-check dynamic_code.hml -o program

# Enable strict warnings for implicit any types
hemlockc --strict-types program.hml -o program
```

### What the Type Checker Validates

1. **Type annotations** - Ensures assigned values match declared types
2. **Function calls** - Validates argument types against parameter types
3. **Return types** - Checks return statements match declared return type
4. **Operator usage** - Verifies operands are compatible
5. **Property access** - Validates object field types for typed objects

### Permissive Numeric Conversions

The type checker allows numeric type conversions at compile time, with range validation happening at runtime:

```hemlock
let x: i8 = 100;      // OK - 100 fits in i8 (validated at runtime)
let y: u8 = 255;      // OK - within u8 range
let z: f64 = 42;      // OK - i32 to f64 is safe
```

### Dynamic Code Support

Code without type annotations is treated as dynamic (`any` type) and always passes the type checker:

```hemlock
let x = get_value();  // Dynamic - no annotation
process(x);           // OK - dynamic values accepted anywhere
```

---

## Primitive Types

### Numeric Types

#### Signed Integers

| Type   | Size    | Range                                      | Alias     |
|--------|---------|-------------------------------------------|-----------|
| `i8`   | 1 byte  | -128 to 127                               | -         |
| `i16`  | 2 bytes | -32,768 to 32,767                         | -         |
| `i32`  | 4 bytes | -2,147,483,648 to 2,147,483,647           | `integer` |
| `i64`  | 8 bytes | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | - |

**Examples:**
```hemlock
let a: i8 = 127;
let b: i16 = 32000;
let c: i32 = 1000000;
let d: i64 = 9223372036854775807;

// Type alias
let x: integer = 42;  // Same as i32
```

#### Unsigned Integers

| Type   | Size    | Range                     | Alias  |
|--------|---------|---------------------------|--------|
| `u8`   | 1 byte  | 0 to 255                  | `byte` |
| `u16`  | 2 bytes | 0 to 65,535               | -      |
| `u32`  | 4 bytes | 0 to 4,294,967,295        | -      |
| `u64`  | 8 bytes | 0 to 18,446,744,073,709,551,615 | - |

**Examples:**
```hemlock
let a: u8 = 255;
let b: u16 = 65535;
let c: u32 = 4294967295;
let d: u64 = 18446744073709551615;

// Type alias
let byte_val: byte = 65;  // Same as u8
```

#### Floating Point

| Type   | Size    | Precision      | Alias    |
|--------|---------|----------------|----------|
| `f32`  | 4 bytes | ~7 digits      | -        |
| `f64`  | 8 bytes | ~15 digits     | `number` |

**Examples:**
```hemlock
let pi: f32 = 3.14159;
let precise: f64 = 3.14159265359;

// Type alias
let x: number = 2.718;  // Same as f64
```

---

### Integer Literal Inference

Integer literals are automatically typed based on their value:

**Rules:**
- Values in i32 range (-2,147,483,648 to 2,147,483,647): infer as `i32`
- Values outside i32 range but within i64 range: infer as `i64`
- Use explicit type annotations for other types (i8, i16, u8, u16, u32, u64)

**Examples:**
```hemlock
let small = 42;                    // i32 (fits in i32)
let large = 5000000000;            // i64 (> i32 max)
let max_i64 = 9223372036854775807; // i64 (INT64_MAX)
let explicit: u32 = 100;           // u32 (type annotation overrides)
```

---

### Boolean Type

**Type:** `bool`

**Values:** `true`, `false`

**Size:** 1 byte (internally)

**Examples:**
```hemlock
let is_active: bool = true;
let done = false;

if (is_active && !done) {
    print("working");
}
```

---

### Character Types

#### Rune

**Type:** `rune`

**Description:** Unicode codepoint (U+0000 to U+10FFFF)

**Size:** 4 bytes (32-bit value)

**Range:** 0 to 0x10FFFF (1,114,111)

**Literal Syntax:** Single quotes `'x'`

**Examples:**
```hemlock
// ASCII
let a = 'A';
let digit = '0';

// Multi-byte UTF-8
let rocket = 'ðŸš€';      // U+1F680
let heart = 'â¤';        // U+2764
let chinese = 'ä¸­';     // U+4E2D

// Escape sequences
let newline = '\n';
let tab = '\t';
let backslash = '\\';
let quote = '\'';
let null = '\0';

// Unicode escapes
let emoji = '\u{1F680}';   // Up to 6 hex digits
let max = '\u{10FFFF}';    // Maximum codepoint
```

**Type Conversions:**
```hemlock
// Integer to rune
let code: rune = 65;        // 'A'
let r: rune = 128640;       // ðŸš€

// Rune to integer
let value: i32 = 'Z';       // 90

// Rune to string
let s: string = 'H';        // "H"

// u8 to rune
let byte: u8 = 65;
let rune_val: rune = byte;  // 'A'
```

**See Also:** [String API](#reference-string-api) for string + rune concatenation

---

### String Type

**Type:** `string`

**Description:** UTF-8 encoded, mutable, heap-allocated text

**Encoding:** UTF-8 (U+0000 to U+10FFFF)

**Mutability:** Mutable (unlike most languages)

**Properties:**
- `.length` - Codepoint count (number of characters)
- `.byte_length` - Byte count (UTF-8 encoding size)

**Literal Syntax:** Double quotes `"text"`

**Examples:**
```hemlock
let s = "hello";
s[0] = 'H';             // Mutate (now "Hello")
print(s.length);        // 5 (codepoint count)
print(s.byte_length);   // 5 (UTF-8 bytes)

let emoji = "ðŸš€";
print(emoji.length);        // 1 (one codepoint)
print(emoji.byte_length);   // 4 (four UTF-8 bytes)
```

**Indexing:**
```hemlock
let s = "hello";
let ch = s[0];          // Returns rune 'h'
s[0] = 'H';             // Set with rune
```

**See Also:** [String API](#reference-string-api) for complete method reference

---

### Null Type

**Type:** `null`

**Description:** The null value (absence of value)

**Size:** 8 bytes (internally)

**Value:** `null`

**Examples:**
```hemlock
let x = null;
let y: i32 = null;  // ERROR: type mismatch

if (x == null) {
    print("x is null");
}
```

---

## Composite Types

### Array Type

**Type:** `array`

**Description:** Dynamic, heap-allocated, mixed-type array

**Properties:**
- `.length` - Number of elements

**Zero-indexed:** Yes

**Literal Syntax:** `[elem1, elem2, ...]`

**Examples:**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr[0]);         // 1
print(arr.length);     // 5

// Mixed types
let mixed = [1, "hello", true, null];
```

**See Also:** [Array API](#reference-array-api) for complete method reference

---

### Object Type

**Type:** `object`

**Description:** JavaScript-style object with dynamic fields

**Literal Syntax:** `{ field: value, ... }`

**Examples:**
```hemlock
let person = { name: "Alice", age: 30 };
print(person.name);  // "Alice"

// Add field dynamically
person.email = "alice@example.com";
```

**Type Definitions:**
```hemlock
define Person {
    name: string,
    age: i32,
    active?: bool,  // Optional field
}

let p: Person = { name: "Bob", age: 25 };
print(typeof(p));  // "Person"
```

---

### Pointer Types

#### Raw Pointer (ptr)

**Type:** `ptr`

**Description:** Raw memory address (unsafe)

**Size:** 8 bytes

**Bounds Checking:** None

**Examples:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

#### Buffer (buffer)

**Type:** `buffer`

**Description:** Safe pointer wrapper with bounds checking

**Structure:** Pointer + length + capacity

**Properties:**
- `.length` - Buffer size
- `.capacity` - Allocated capacity

**Examples:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // Bounds checked
print(b.length);        // 64
free(b);
```

**See Also:** [Memory API](#reference-memory-api) for allocation functions

---

## Special Types

### File Type

**Type:** `file`

**Description:** File handle for I/O operations

**Properties:**
- `.path` - File path (string)
- `.mode` - Open mode (string)
- `.closed` - Whether file is closed (bool)

**See Also:** [File API](#reference-file-api)

---

### Task Type

**Type:** `task`

**Description:** Handle for concurrent task

**See Also:** [Concurrency API](#reference-concurrency-api)

---

### Channel Type

**Type:** `channel`

**Description:** Thread-safe communication channel

**See Also:** [Concurrency API](#reference-concurrency-api)

---

### Function Type

**Type:** `function`

**Description:** First-class function value

**Examples:**
```hemlock
fn add(a, b) {
    return a + b;
}

let multiply = fn(x, y) {
    return x * y;
};

print(typeof(add));      // "function"
print(typeof(multiply)); // "function"
```

---

### Void Type

**Type:** `void`

**Description:** Absence of return value (internal use)

---

## Type Promotion Rules

When mixing types in operations, Hemlock promotes to the "higher" type:

**Promotion Hierarchy:**
```
f64 (highest precision)
 â†‘
f32
 â†‘
u64
 â†‘
i64
 â†‘
u32
 â†‘
i32
 â†‘
u16
 â†‘
i16
 â†‘
u8
 â†‘
i8 (lowest)
```

**Rules:**
1. Float always wins over integer
2. Larger size wins within same category (int/uint/float)
3. Both operands are promoted to result type
4. **Precision preservation:** i64/u64 + f32 promotes to f64 (not f32)

**Examples:**
```hemlock
// Size promotion
u8 + i32    â†’ i32    // Larger size wins
i32 + i64   â†’ i64    // Larger size wins
u32 + u64   â†’ u64    // Larger size wins

// Float promotion
i32 + f32   â†’ f32    // Float wins, f32 sufficient for i32
i64 + f32   â†’ f64    // Promotes to f64 to preserve i64 precision
i64 + f64   â†’ f64    // Float always wins
i8 + f64    â†’ f64    // Float + largest wins
```

**Why i64 + f32 â†’ f64?**

f32 has only a 24-bit mantissa, which cannot precisely represent integers larger
than 2^24 (16,777,216). Since i64 can hold values up to 2^63, mixing i64 with f32
would cause severe precision loss. Hemlock promotes to f64 (53-bit mantissa) instead.

---

## Range Checking

Type annotations enforce range checks at assignment:

**Valid Assignments:**
```hemlock
let x: u8 = 255;             // OK
let y: i8 = 127;             // OK
let a: i64 = 2147483647;     // OK
let b: u64 = 4294967295;     // OK
```

**Invalid Assignments (Runtime Error):**
```hemlock
let x: u8 = 256;             // ERROR: out of range
let y: i8 = 128;             // ERROR: max is 127
let z: u64 = -1;             // ERROR: u64 cannot be negative
```

---

## Type Introspection

### typeof(value)

Returns the type name as a string.

**Signature:**
```hemlock
typeof(value: any): string
```

**Returns:**
- Primitive types: `"i8"`, `"i16"`, `"i32"`, `"i64"`, `"u8"`, `"u16"`, `"u32"`, `"u64"`, `"f32"`, `"f64"`, `"bool"`, `"string"`, `"rune"`, `"null"`
- Composite types: `"array"`, `"object"`, `"ptr"`, `"buffer"`, `"function"`
- Special types: `"file"`, `"task"`, `"channel"`
- Typed objects: Custom type name (e.g., `"Person"`)

**Examples:**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("hello"));         // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"

define Person { name: string }
let p: Person = { name: "Alice" };
print(typeof(p));               // "Person"
```

**See Also:** [Built-in Functions](builtins.md#typeof)

---

## Type Conversions

### Implicit Conversions

Hemlock performs implicit type conversions in arithmetic operations following the type promotion rules.

**Examples:**
```hemlock
let a: u8 = 10;
let b: i32 = 20;
let result = a + b;     // result is i32 (promoted)
```

### Explicit Conversions

Use type annotations for explicit conversions:

**Examples:**
```hemlock
// Integer to float
let i: i32 = 42;
let f: f64 = i;         // 42.0

// Float to integer (truncates)
let x: f64 = 3.14;
let y: i32 = x;         // 3

// Integer to rune
let code: rune = 65;    // 'A'

// Rune to integer
let value: i32 = 'Z';   // 90

// Rune to string
let s: string = 'H';    // "H"
```

---

## Type Aliases

### Built-in Aliases

Hemlock provides built-in type aliases for common types:

| Alias     | Actual Type | Usage                    |
|-----------|-------------|--------------------------|
| `integer` | `i32`       | General-purpose integers |
| `number`  | `f64`       | General-purpose floats   |
| `byte`    | `u8`        | Byte values              |

**Examples:**
```hemlock
let count: integer = 100;       // Same as i32
let price: number = 19.99;      // Same as f64
let b: byte = 255;              // Same as u8
```

### Custom Type Aliases

Define custom type aliases using the `type` keyword:

```hemlock
// Simple aliases
type Integer = i32;
type Text = string;

// Function type aliases
type Callback = fn(i32): void;
type Predicate = fn(any): bool;
type BinaryOp = fn(i32, i32): i32;

// Compound type aliases
define HasName { name: string }
define HasAge { age: i32 }
type Person = HasName & HasAge;

// Generic type aliases
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };
```

**Using custom aliases:**
```hemlock
let cb: Callback = fn(n) { print(n); };
let p: Person = { name: "Alice", age: 30 };
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
```

**Note:** Type aliases are transparent - `typeof()` returns the underlying type name.

---

## Function Types

Function types specify the signature of function values:

### Syntax

```hemlock
fn(param_types): return_type
```

### Examples

```hemlock
// Basic function type
let add: fn(i32, i32): i32 = fn(a, b) { return a + b; };

// Function parameter
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Higher-order function returning function
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Async function type
fn run_async(handler: async fn(): void) {
    spawn(handler);
}
```

---

## Compound Types (Intersection)

Compound types use `&` to require multiple type constraints:

```hemlock
define HasName { name: string }
define HasAge { age: i32 }
define HasEmail { email: string }

// Object must satisfy all types
let person: HasName & HasAge = { name: "Alice", age: 30 };

// Three or more types
fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}
```

---

## Summary Table

| Type       | Size     | Mutable | Heap-allocated | Description                    |
|------------|----------|---------|----------------|--------------------------------|
| `i8`-`i64` | 1-8 bytes| No      | No             | Signed integers                |
| `u8`-`u64` | 1-8 bytes| No      | No             | Unsigned integers              |
| `f32`      | 4 bytes  | No      | No             | Single-precision float         |
| `f64`      | 8 bytes  | No      | No             | Double-precision float         |
| `bool`     | 1 byte   | No      | No             | Boolean                        |
| `rune`     | 4 bytes  | No      | No             | Unicode codepoint              |
| `string`   | Variable | Yes     | Yes            | UTF-8 text                     |
| `array`    | Variable | Yes     | Yes            | Dynamic array                  |
| `object`   | Variable | Yes     | Yes            | Dynamic object                 |
| `ptr`      | 8 bytes  | No      | No             | Raw pointer                    |
| `buffer`   | Variable | Yes     | Yes            | Safe pointer wrapper           |
| `file`     | Opaque   | Yes     | Yes            | File handle                    |
| `task`     | Opaque   | No      | Yes            | Concurrent task handle         |
| `channel`  | Opaque   | Yes     | Yes            | Thread-safe channel            |
| `function` | Opaque   | No      | Yes            | Function value                 |
| `null`     | 8 bytes  | No      | No             | Null value                     |

---

## See Also

- [Operators Reference](#reference-operators) - Type behavior in operations
- [Built-in Functions](#reference-builtins) - Type introspection and conversion
- [String API](#reference-string-api) - String type methods
- [Array API](#reference-array-api) - Array type methods
- [Memory API](#reference-memory-api) - Pointer and buffer operations



################################################################################
# DESIGN & PHILOSOPHY
################################################################################

--------------------------------------------------------------------------------
## Implementation
--------------------------------------------------------------------------------

# Hemlock Implementation Details

This document describes the technical implementation of the Hemlock language, including project structure, compilation pipeline, runtime architecture, and design decisions.

---

## Table of Contents

- [Project Structure](#project-structure)
- [Compilation Pipeline](#compilation-pipeline)
- [Modular Interpreter Design](#modular-interpreter-design)
- [Runtime Architecture](#runtime-architecture)
- [Value Representation](#value-representation)
- [Type System Implementation](#type-system-implementation)
- [Memory Management](#memory-management)
- [Concurrency Model](#concurrency-model)
- [Future Plans](#future-plans)

---

## Project Structure

```
hemlock/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ frontend/              # Shared: lexer, parser, AST
â”‚   â”‚   â”œâ”€â”€ lexer.c            # Tokenization
â”‚   â”‚   â”œâ”€â”€ parser/            # Recursive descent parser
â”‚   â”‚   â”œâ”€â”€ ast.c              # AST node management
â”‚   â”‚   â””â”€â”€ module.c           # Module resolution
â”‚   â”œâ”€â”€ backends/
â”‚   â”‚   â”œâ”€â”€ interpreter/       # hemlock: tree-walking interpreter
â”‚   â”‚   â”‚   â”œâ”€â”€ main.c         # CLI entry point
â”‚   â”‚   â”‚   â”œâ”€â”€ runtime.c      # Expression/statement evaluation
â”‚   â”‚   â”‚   â”œâ”€â”€ builtins.c     # Built-in functions
â”‚   â”‚   â”‚   â””â”€â”€ ...
â”‚   â”‚   â””â”€â”€ compiler/          # hemlockc: C code generator
â”‚   â”‚       â”œâ”€â”€ main.c         # CLI, orchestration
â”‚   â”‚       â”œâ”€â”€ type_check.c   # Compile-time type checking
â”‚   â”‚       â”œâ”€â”€ codegen.c      # Code generation context
â”‚   â”‚       â”œâ”€â”€ codegen_expr.c # Expression codegen
â”‚   â”‚       â”œâ”€â”€ codegen_stmt.c # Statement codegen
â”‚   â”‚       â””â”€â”€ ...
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ lsp/               # Language Server Protocol
â”‚   â”‚   â””â”€â”€ bundler/           # Bundle/package tools
â”œâ”€â”€ runtime/                   # libhemlock_runtime.a (for compiled programs)
â”œâ”€â”€ stdlib/                    # Standard library (39 modules)
â”‚   â””â”€â”€ docs/                  # Module documentation
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ parity/                # Tests that must pass both backends
â”‚   â”œâ”€â”€ interpreter/           # Interpreter-specific tests
â”‚   â””â”€â”€ compiler/              # Compiler-specific tests
â”œâ”€â”€ examples/                  # Example programs
â””â”€â”€ docs/                      # Documentation
```

### Directory Organization

**`include/`** - Public API headers that define the interface between components:
- Clean separation between lexer, parser, AST, and interpreter
- Forward declarations to minimize dependencies
- Public API for embedding Hemlock in other programs

**`src/`** - Implementation files:
- Top-level files handle lexing, parsing, AST management
- `main.c` provides CLI and REPL
- Interpreter is modularized into separate subsystems

**`src/interpreter/`** - Modular interpreter implementation:
- Each module has a single, clear responsibility
- Internal API defined in `internal.h` for inter-module communication
- Modules can be compiled independently for faster builds

**`tests/`** - Comprehensive test suite:
- Organized by feature area
- Each directory contains focused test cases
- `run_tests.sh` orchestrates test execution

---

## Compilation Pipeline

Hemlock uses a traditional compilation pipeline with distinct phases:

### Phase 1: Lexical Analysis (Lexer)

**Input:** Source code text
**Output:** Token stream
**Implementation:** `src/lexer.c`

```
Source: "let x = 42;"
   â†“
Tokens: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
```

**Key features:**
- Recognizes keywords, identifiers, literals, operators, punctuation
- Handles UTF-8 string literals and rune literals
- Reports line numbers for error messages
- Single-pass, no backtracking

### Phase 2: Syntax Analysis (Parser)

**Input:** Token stream
**Output:** Abstract Syntax Tree (AST)
**Implementation:** `src/parser.c`

```
Tokens: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
   â†“
AST: LetStmt {
    name: "x",
    type: null,
    value: IntLiteral(42)
}
```

**Key features:**
- Recursive descent parser
- Builds tree representation of program structure
- Handles operator precedence
- Validates syntax (braces, semicolons, etc.)
- No semantic analysis yet (done at runtime)

**Operator Precedence (lowest to highest):**
1. Assignment: `=`
2. Logical OR: `||`
3. Logical AND: `&&`
4. Bitwise OR: `|`
5. Bitwise XOR: `^`
6. Bitwise AND: `&`
7. Equality: `==`, `!=`
8. Comparison: `<`, `>`, `<=`, `>=`
9. Bitwise shifts: `<<`, `>>`
10. Addition/Subtraction: `+`, `-`
11. Multiplication/Division/Modulo: `*`, `/`, `%`
12. Unary: `!`, `-`, `~`
13. Call/Index/Member: `()`, `[]`, `.`

### Phase 3a: Interpretation (Tree-Walking)

**Input:** AST
**Output:** Program execution
**Implementation:** `src/backends/interpreter/runtime.c`

```
AST: LetStmt { ... }
   â†“
Execution: Evaluates AST nodes recursively
   â†“
Result: Variable x created with value 42
```

**Key features:**
- Direct AST traversal (tree-walking interpreter)
- Dynamic type checking at runtime
- Environment-based variable storage

### Phase 3b: Compilation (hemlockc)

**Input:** AST
**Output:** Native executable via C code generation
**Implementation:** `src/backends/compiler/`

```
AST: LetStmt { ... }
   â†“
Type Check: Validate types at compile time
   â†“
C Codegen: Generate equivalent C code
   â†“
GCC: Compile C to native binary
   â†“
Result: Standalone executable
```

**Key features:**
- Compile-time type checking (enabled by default)
- C code generation for portability
- Links against `libhemlock_runtime.a`
- Significantly faster execution than interpreter

---

## Compiler Backend (hemlockc)

The Hemlock compiler generates C code from the AST, which is then compiled to a native executable using GCC.

### Compiler Architecture

```
src/backends/compiler/
â”œâ”€â”€ main.c              # CLI, argument parsing, orchestration
â”œâ”€â”€ codegen.c           # Core code generation context
â”œâ”€â”€ codegen_expr.c      # Expression code generation
â”œâ”€â”€ codegen_stmt.c      # Statement code generation
â”œâ”€â”€ codegen_call.c      # Function call generation
â”œâ”€â”€ codegen_closure.c   # Closure implementation
â”œâ”€â”€ codegen_program.c   # Top-level program generation
â”œâ”€â”€ codegen_module.c    # Module/import handling
â”œâ”€â”€ type_check.c        # Compile-time type checking
â””â”€â”€ type_check.h        # Type checker API
```

### Type Checking

The compiler includes a unified type checking system that:

1. **Validates types at compile time** - Catches type errors before execution
2. **Supports dynamic code** - Untyped code treated as `any` (always valid)
3. **Provides optimization hints** - Identifies variables that can be unboxed

**Type Checking Flags:**

| Flag | Description |
|------|-------------|
| (default) | Type checking enabled |
| `--check` | Type check only, don't compile |
| `--no-type-check` | Disable type checking |
| `--strict-types` | Warn on implicit `any` types |

**Type Checker Implementation:**

```c
// type_check.h - Key structures
typedef struct TypeCheckContext {
    const char *filename;
    int error_count;
    int warning_count;
    UnboxableVar *unboxable_vars;  // Optimization hints
    // ... type environment, definitions, etc.
} TypeCheckContext;

// Main entry point
int type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);
```

### Code Generation

The codegen phase translates AST nodes to C code:

**Expression Mapping:**
```
Hemlock                 â†’  Generated C
----------------------------------------
let x = 42;            â†’  HmlValue x = hml_val_i32(42);
x + y                  â†’  hml_add(x, y)
arr[i]                 â†’  hml_array_get(arr, i)
obj.field              â†’  hml_object_get_field(obj, "field")
fn(a, b) { ... }       â†’  Closure with environment capture
```

**Runtime Integration:**

Generated C code links against `libhemlock_runtime.a` which provides:
- `HmlValue` tagged union type
- Memory management (reference counting)
- Built-in functions (print, typeof, etc.)
- Concurrency primitives (tasks, channels)
- FFI support

### Unboxing Optimization

The type checker identifies variables that can use native C types instead of boxed `HmlValue`:

**Unboxable Patterns:**
- Loop counters with known integer type
- Accumulator variables in loops
- Variables with explicit type annotations (i32, i64, f64, bool)

```hemlock
// Loop counter 'i' can be unboxed to native int32_t
for (let i: i32 = 0; i < 1000000; i = i + 1) {
    sum = sum + i;
}
```

---

## Modular Interpreter Design

The interpreter is split into focused modules for maintainability and scalability.

### Module Responsibilities

#### 1. Environment (`environment.c`) - 121 lines

**Purpose:** Variable scoping and name resolution

**Key functions:**
- `env_create()` - Create new environment with optional parent
- `env_define()` - Define new variable in current scope
- `env_get()` - Lookup variable in current or parent scopes
- `env_set()` - Update existing variable value
- `env_free()` - Free environment and all variables

**Design:**
- Linked scopes (each environment has pointer to parent)
- HashMap for fast variable lookup
- Supports lexical scoping for closures

#### 2. Values (`values.c`) - 394 lines

**Purpose:** Value constructors and data structure management

**Key functions:**
- `value_create_*()` - Constructors for each value type
- `value_copy()` - Deep/shallow copying logic
- `value_free()` - Cleanup and memory deallocation
- `value_to_string()` - String representation for printing

**Data structures:**
- Objects (dynamic field arrays)
- Arrays (dynamic resizing)
- Buffers (ptr + length + capacity)
- Closures (function + captured environment)
- Tasks and Channels (concurrency primitives)

#### 3. Types (`types.c`) - 440 lines

**Purpose:** Type system, conversions, and duck typing

**Key functions:**
- `type_check()` - Runtime type validation
- `type_convert()` - Implicit type conversions/promotions
- `duck_type_check()` - Structural type checking for objects
- `type_name()` - Get printable type name

**Features:**
- Type promotion hierarchy (i8 â†’ i16 â†’ i32 â†’ i64 â†’ f32 â†’ f64, with i64/u64 + f32 â†’ f64)
- Range checking for numeric types
- Duck typing for object type definitions
- Optional field defaults

#### 4. Builtins (`builtins.c`) - 955 lines

**Purpose:** Built-in functions and global registration

**Key functions:**
- `register_builtins()` - Register all built-in functions and constants
- Built-in function implementations (print, typeof, alloc, free, etc.)
- Signal handling functions
- Command execution (exec)

**Categories of builtins:**
- I/O: print, open, read_file, write_file
- Memory: alloc, free, memset, memcpy, realloc
- Types: typeof, assert
- Concurrency: spawn, join, detach, channel
- System: exec, signal, raise, panic
- FFI: dlopen, dlsym, dlcall, dlclose

#### 5. I/O (`io.c`) - 449 lines

**Purpose:** File I/O and JSON serialization

**Key functions:**
- File object methods (read, write, seek, tell, close)
- JSON serialization/deserialization
- Circular reference detection

**Features:**
- File object with properties (path, mode, closed)
- UTF-8 aware text I/O
- Binary I/O support
- JSON round-tripping for objects and arrays

#### 6. FFI (`ffi.c`) - Foreign Function Interface

**Purpose:** Calling C functions from shared libraries

**Key functions:**
- `dlopen()` - Load shared library
- `dlsym()` - Get function pointer by name
- `dlcall()` - Call C function with type conversion
- `dlclose()` - Unload library

**Features:**
- Integration with libffi for dynamic function calls
- Automatic type conversion (Hemlock â†” C types)
- Support for all primitive types
- Pointer and buffer support

#### 7. Runtime (`runtime.c`) - 865 lines

**Purpose:** Expression evaluation and statement execution

**Key functions:**
- `eval_expr()` - Evaluate expressions (recursive)
- `eval_stmt()` - Execute statements
- Control flow handling (if, while, for, switch, etc.)
- Exception handling (try/catch/finally/throw)

**Features:**
- Recursive expression evaluation
- Short-circuit boolean evaluation
- Method call detection and `self` binding
- Exception propagation
- Break/continue/return handling

### Benefits of Modular Design

**1. Separation of Concerns**
- Each module has one clear responsibility
- Easy to find where features are implemented
- Reduces cognitive load when making changes

**2. Faster Incremental Builds**
- Only modified modules need recompilation
- Parallel compilation possible
- Shorter iteration times during development

**3. Easier Testing and Debugging**
- Modules can be tested in isolation
- Bugs are localized to specific subsystems
- Mock implementations possible for testing

**4. Scalability**
- New features can be added to appropriate modules
- Modules can be refactored independently
- Code size per file stays manageable

**5. Code Organization**
- Logical grouping of related functionality
- Clear dependency graph
- Easier onboarding for new contributors

---

## Runtime Architecture

### Value Representation

All values in Hemlock are represented by the `Value` struct using a tagged union:

```c
typedef struct Value {
    ValueType type;  // Runtime type tag
    union {
        int32_t i32_value;
        int64_t i64_value;
        uint8_t u8_value;
        uint32_t u32_value;
        uint64_t u64_value;
        float f32_value;
        double f64_value;
        bool bool_value;
        char *string_value;
        uint32_t rune_value;
        void *ptr_value;
        Buffer *buffer_value;
        Array *array_value;
        Object *object_value;
        Function *function_value;
        File *file_value;
        Task *task_value;
        Channel *channel_value;
    };
} Value;
```

**Design decisions:**
- **Tagged union** for type safety while maintaining flexibility
- **Runtime type tags** enable dynamic typing with type checking
- **Direct value storage** for primitives (no boxing)
- **Pointer storage** for heap-allocated types (strings, objects, arrays)

### Memory Layout Examples

**Integer (i32):**
```
Value {
    type: TYPE_I32,
    i32_value: 42
}
```
- Total size: ~16 bytes (8-byte tag + 8-byte union)
- Stack allocated
- No heap allocation needed

**String:**
```
Value {
    type: TYPE_STRING,
    string_value: 0x7f8a4c000000  // Pointer to heap
}

Heap: "hello\0" (6 bytes, null-terminated UTF-8)
```
- Value is 16 bytes on stack
- String data is heap-allocated
- Must be freed manually

**Object:**
```
Value {
    type: TYPE_OBJECT,
    object_value: 0x7f8a4c001000  // Pointer to heap
}

Heap: Object {
    type_name: "Person",
    fields: [
        { name: "name", value: Value{TYPE_STRING, "Alice"} },
        { name: "age", value: Value{TYPE_I32, 30} }
    ],
    field_count: 2,
    capacity: 4
}
```
- Object structure on heap
- Fields stored in dynamic array
- Field values are embedded Value structs

### Environment Implementation

Variables are stored in environment chains:

```c
typedef struct Environment {
    HashMap *bindings;           // name â†’ Value
    struct Environment *parent;  // Lexical parent scope
} Environment;
```

**Scope chain example:**
```
Global Scope: { print: <builtin>, args: <array> }
    â†‘
Function Scope: { x: 10, y: 20 }
    â†‘
Block Scope: { i: 0 }
```

**Lookup algorithm:**
1. Check current environment's hashmap
2. If not found, check parent environment
3. Repeat until found or reach global scope
4. Error if not found in any scope

---

## Type System Implementation

### Type Checking Strategy

Hemlock uses **runtime type checking** with **optional type annotations**:

```hemlock
let x = 42;           // No type check, infers i32
let y: u8 = 255;      // Runtime check: value must fit in u8
let z: i32 = x + y;   // Runtime check + type promotion
```

**Implementation flow:**
1. **Literal inference** - Lexer/parser determine initial type from literal
2. **Type annotation check** - If annotation present, validate at assignment
3. **Promotion** - Binary operations promote to common type
4. **Conversion** - Explicit conversions happen on demand

### Type Promotion Implementation

Type promotion follows a fixed hierarchy with precision preservation:

```c
// Simplified promotion logic
ValueType promote_types(ValueType a, ValueType b) {
    // f64 always wins
    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;

    // f32 with i64/u64 promotes to f64 (precision preservation)
    if (a == TYPE_F32 || b == TYPE_F32) {
        ValueType other = (a == TYPE_F32) ? b : a;
        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;
        return TYPE_F32;
    }

    // Larger integer types win
    int rank_a = get_type_rank(a);
    int rank_b = get_type_rank(b);
    return (rank_a > rank_b) ? a : b;
}
```

**Type ranks:**
- i8: 0
- u8: 1
- i16: 2
- u16: 3
- i32: 4
- u32: 5
- i64: 6
- u64: 7
- f32: 8
- f64: 9

### Duck Typing Implementation

Object type checking uses structural comparison:

```c
bool duck_type_check(Object *obj, TypeDef *type_def) {
    // Check all required fields
    for (each field in type_def) {
        if (!object_has_field(obj, field.name)) {
            return false;  // Missing field
        }

        Value *field_value = object_get_field(obj, field.name);
        if (!type_matches(field_value, field.type)) {
            return false;  // Wrong type
        }
    }

    return true;  // All required fields present and correct type
}
```

**Duck typing allows:**
- Extra fields in objects (ignored)
- Substructural typing (object can have more than required)
- Type name assignment after validation

---

## Memory Management

### Allocation Strategy

Hemlock uses **manual memory management** with two allocation primitives:

**1. Raw pointers (`ptr`):**
```c
void *alloc(size_t bytes) {
    void *ptr = malloc(bytes);
    if (!ptr) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return ptr;
}
```
- Direct malloc/free
- No tracking
- User responsibility to free

**2. Buffers (`buffer`):**
```c
typedef struct Buffer {
    void *data;
    size_t length;
    size_t capacity;
} Buffer;

Buffer *create_buffer(size_t size) {
    Buffer *buf = malloc(sizeof(Buffer));
    buf->data = malloc(size);
    buf->length = size;
    buf->capacity = size;
    return buf;
}
```
- Tracks size and capacity
- Bounds checking on access
- Still requires manual free

### Heap-Allocated Types

**Strings:**
- UTF-8 byte array on heap
- Null-terminated for C interop
- Mutable (can modify in place)
- Refcounted (auto-freed when scope exits)

**Objects:**
- Dynamic field array
- Field names and values on heap
- Refcounted (auto-freed when scope exits)
- Circular references possible (handled with visited-set tracking)

**Arrays:**
- Dynamic capacity doubling growth
- Elements are embedded Value structs
- Automatic reallocation on growth
- Refcounted (auto-freed when scope exits)

**Closures:**
- Captures environment by reference
- Environment is heap-allocated
- Closure environments are properly freed when no longer referenced

---

## Concurrency Model

### Threading Architecture

Hemlock uses **1:1 threading** with POSIX threads (pthreads):

```
User Task          OS Thread          CPU Core
---------          ---------          --------
spawn(f1) ------>  pthread_create --> Core 0
spawn(f2) ------>  pthread_create --> Core 1
spawn(f3) ------>  pthread_create --> Core 2
```

**Key characteristics:**
- Each `spawn()` creates a new pthread
- Kernel schedules threads across cores
- True parallel execution (no GIL)
- Pre-emptive multitasking

### Task Implementation

```c
typedef struct Task {
    pthread_t thread;        // OS thread handle
    Value result;            // Return value
    char *error;             // Exception message (if thrown)
    pthread_mutex_t lock;    // Protects state
    TaskState state;         // RUNNING, FINISHED, ERROR
} Task;
```

**Task lifecycle:**
1. `spawn(func, args)` â†’ Create Task, start pthread
2. Thread runs function with arguments
3. On return: Store result, set state to FINISHED
4. On exception: Store error message, set state to ERROR
5. `join(task)` â†’ Wait for thread, return result or throw exception

### Channel Implementation

```c
typedef struct Channel {
    void **buffer;           // Circular buffer of Value*
    size_t capacity;         // Maximum buffered items
    size_t count;            // Current items in buffer
    size_t read_index;       // Next read position
    size_t write_index;      // Next write position
    bool closed;             // Channel closed flag
    pthread_mutex_t lock;    // Protects buffer
    pthread_cond_t not_full; // Signal when space available
    pthread_cond_t not_empty;// Signal when data available
} Channel;
```

**Send operation:**
1. Lock mutex
2. Wait if buffer full (cond_wait on not_full)
3. Write value to buffer[write_index]
4. Increment write_index (circular)
5. Signal not_empty
6. Unlock mutex

**Receive operation:**
1. Lock mutex
2. Wait if buffer empty (cond_wait on not_empty)
3. Read value from buffer[read_index]
4. Increment read_index (circular)
5. Signal not_full
6. Unlock mutex

**Synchronization guarantees:**
- Thread-safe send/recv (protected by mutex)
- Blocking semantics (producer waits if full, consumer waits if empty)
- Ordered delivery (FIFO within a channel)

---

## Future Plans

### Completed: Compiler Backend âœ“

The compiler backend (`hemlockc`) has been implemented with:
- C code generation from AST
- Compile-time type checking (enabled by default)
- Runtime library (`libhemlock_runtime.a`)
- Full parity with interpreter (98% test pass rate)
- Unboxing optimization framework

### Current Focus: Type System Enhancements

**Recent improvements:**
- Unified type checking and type inference systems
- Compile-time type checking enabled by default
- `--check` flag for type-only validation
- Type context passed to codegen for optimization hints

### Future Enhancements

**Potential additions:**
- Generics/templates
- Pattern matching
- LSP integration for type-aware IDE support
- More aggressive unboxing optimizations
- Escape analysis for stack allocation

### Long-term Optimizations

**Possible improvements:**
- Inline caching for method calls
- JIT compilation for hot code paths
- Work-stealing scheduler for better concurrency
- Profile-guided optimization

---

## Implementation Guidelines

### Adding New Features

When implementing new features, follow these guidelines:

**1. Choose the right module:**
- New value types â†’ `values.c`
- Type conversions â†’ `types.c`
- Built-in functions â†’ `builtins.c`
- I/O operations â†’ `io.c`
- Control flow â†’ `runtime.c`

**2. Update all layers:**
- Add AST node types if needed (`ast.h`, `ast.c`)
- Add lexer tokens if needed (`lexer.c`)
- Add parser rules (`parser.c`)
- Implement runtime behavior (`runtime.c` or appropriate module)
- Add tests (`tests/`)

**3. Maintain consistency:**
- Follow existing code style
- Use consistent naming conventions
- Document public API in headers
- Keep error messages clear and consistent

**4. Test thoroughly:**
- Add test cases before implementing
- Test success and error paths
- Test edge cases
- Verify no memory leaks (valgrind)

### Performance Considerations

**Current bottlenecks:**
- HashMap lookups for variable access
- Recursive function calls (no TCO)
- String concatenation (allocates new string each time)
- Type checking overhead on every operation

**Optimization opportunities:**
- Cache variable locations (inline caching)
- Tail call optimization
- String builder for concatenation
- Type inference to skip runtime checks

### Debugging Tips

**Useful tools:**
- `valgrind` - Memory leak detection
- `gdb` - Debugging crashes
- `-g` flag - Debug symbols
- `printf` debugging - Simple but effective

**Common issues:**
- Segfault â†’ Null pointer dereference (check return values)
- Memory leak â†’ Missing free() call (check value_free paths)
- Type error â†’ Check type_convert() and type_check() logic
- Crash in threads â†’ Race condition (check mutex usage)

---

## Conclusion

Hemlock's implementation prioritizes:
- **Modularity** - Clean separation of concerns
- **Simplicity** - Straightforward implementation
- **Explicitness** - No hidden magic
- **Maintainability** - Easy to understand and modify

The current tree-walking interpreter is intentionally simple to facilitate rapid feature development and experimentation. Future compiler backend will improve performance while maintaining the same semantics.


--------------------------------------------------------------------------------
## Philosophy
--------------------------------------------------------------------------------

# Hemlock Language Design Philosophy

> "A small, unsafe language for writing unsafe things safely."

This document captures the core design principles and philosophy of Hemlock. Read this first before making any changes or additions to the language.

---

## Table of Contents

- [Core Identity](#core-identity)
- [Design Principles](#design-principles)
- [Philosophy on Safety](#philosophy-on-safety)
- [What NOT to Add](#what-not-to-add)
- [Future Considerations](#future-considerations)
- [Final Thoughts](#final-thoughts)

---

## Core Identity

Hemlock is a **systems scripting language** that embraces manual memory management and explicit control. It's designed for programmers who want:

- The power of C
- The ergonomics of modern scripting languages
- Structured async concurrency built-in
- No hidden behavior or magic

### What Hemlock IS NOT

- **Memory-safe** (dangling pointers are your responsibility)
- **A replacement for Rust, Go, or Lua**
- **A language that hides complexity from you**

### What Hemlock IS

- **Explicit over implicit, always**
- **Educational and experimental**
- **A "C scripting layer" for systems work**
- **Honest about tradeoffs**

---

## Design Principles

### 1. Explicit Over Implicit

Hemlock favors explicitness in all language constructs. There should be no surprises, no magic, and no hidden behavior.

**Bad (implicit):**
```hemlock
let x = 5  // Missing semicolon - should error
```

**Good (explicit):**
```hemlock
let x = 5;
free(ptr);  // You allocated it, you free it
```

**Key aspects:**
- Semicolons are mandatory (no automatic semicolon insertion)
- No garbage collection
- Manual memory management (alloc/free)
- Type annotations are optional but checked at runtime
- No automatic resource cleanup (no RAII), but `defer` provides explicit cleanup

### 2. Dynamic by Default, Typed by Choice

Every value has a runtime type tag, but the system is designed to be flexible while still catching errors.

**Type inference:**
- Small integers (fits in i32): `42` â†’ `i32`
- Large integers (> i32 range): `9223372036854775807` â†’ `i64`
- Floats: `3.14` â†’ `f64`

**Explicit typing when needed:**
```hemlock
let x = 42;              // i32 inferred (small value)
let y: u8 = 255;         // explicit u8
let z = x + y;           // promotes to i32
let big = 5000000000;    // i64 inferred (> i32 max)
```

**Type promotion rules** follow a clear hierarchy from smallest to largest, with floats always winning over integers.

### 3. Unsafe is a Feature, Not a Bug

Hemlock doesn't try to prevent all errors. Instead, it gives you the tools to be safe while allowing you to opt into unsafe behavior when needed.

**Examples of intentional unsafety:**
- Pointer arithmetic can overflow (user's responsibility)
- No bounds checking on raw `ptr` (use `buffer` if you want safety)
- Double-free crashes are allowed (manual memory management)
- Type system prevents accidents but allows footguns when needed

```hemlock
let p = alloc(10);
let q = p + 100;  // Way past allocation - allowed but dangerous
```

**The philosophy:** The type system should prevent *accidents* but allow *intentional* unsafe operations.

### 4. Structured Concurrency First-Class

Concurrency is not an afterthought in Hemlock. It's built into the language from the ground up.

**Key features:**
- `async`/`await` built into the language
- Channels for communication
- `spawn`/`join`/`detach` for task management
- No raw threads, no locks - structured only
- True multi-threaded parallelism using POSIX threads

**Not an event loop or green threads** - Hemlock uses real OS threads for true parallelism across multiple CPU cores.

### 5. C-like Syntax, Low Ceremony

Hemlock should feel familiar to systems programmers while reducing boilerplate.

**Design choices:**
- `{}` blocks always, no optional braces
- Operators match C: `+`, `-`, `*`, `/`, `&&`, `||`, `!`
- Type syntax matches Rust/TypeScript: `let x: type = value;`
- Functions are first-class values
- Minimal keywords and special forms

---

## Philosophy on Safety

**Hemlock's take on safety:**

> "We give you the tools to be safe (`buffer`, type annotations, bounds checking) but we don't force you to use them (`ptr`, manual memory, unsafe operations).
>
> The default should guide toward safety, but the escape hatch should always be available."

### Safety Tools Provided

**1. Safe buffer type:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // bounds checked
print(b.length);        // 64
free(b);                // still manual
```

**2. Unsafe raw pointers:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // You must remember to free
```

**3. Type annotations:**
```hemlock
let x: u8 = 255;   // OK
let y: u8 = 256;   // ERROR: out of range
```

**4. Runtime type checking:**
```hemlock
let val = some_function();
if (typeof(val) == "i32") {
    // Safe to use as integer
}
```

### Guiding Principles

1. **Default to safe patterns in documentation** - Show `buffer` before `ptr`, encourage type annotations
2. **Make unsafe operations obvious** - Raw pointer arithmetic should look intentional
3. **Provide escape hatches** - Don't prevent experienced users from doing low-level work
4. **Be honest about tradeoffs** - Document what can go wrong

### Examples of Safety vs. Unsafety

| Safe Pattern | Unsafe Pattern | When to Use Unsafe |
|-------------|----------------|-------------------|
| `buffer` type | `ptr` type | FFI, performance-critical code |
| Type annotations | No annotations | External interfaces, validation |
| Bounds-checked access | Pointer arithmetic | Low-level memory operations |
| Exception handling | Returning null/error codes | When exceptions are too heavyweight |

---

## What NOT to Add

Understanding what **not** to add is as important as knowing what to add.

### âŒ Don't Add Implicit Behavior

**Bad examples:**

```hemlock
// BAD: Automatic semicolon insertion
let x = 5
let y = 10

// BAD: Implicit type conversions that lose precision
let x: i32 = 3.14  // Should truncate or error?
```

**Why:** Implicit behavior creates surprises and makes code harder to reason about.

### âŒ Don't Hide Complexity

**Bad examples:**

```hemlock
// BAD: Magic behind-the-scenes optimization
let arr = [1, 2, 3]  // Is this stack or heap? User should know! (Heap, refcounted)

// BAD: Raw pointer auto-freed
let p = alloc(100)  // Does this auto-free? NO! Raw ptrs always need free()
```

**Note on refcounting:** Hemlock uses internal refcounting for strings, arrays, objects, and buffers - these ARE auto-freed when scope exits. This is explicit and predictable (deterministic cleanup when ref hits 0, no GC pauses). Raw pointers (`ptr` from `alloc()`) are NOT refcounted and always require manual `free()`.

**Why:** Hidden complexity makes it impossible to predict performance and debug issues.

### âŒ Don't Break Existing Semantics

**Never change these core decisions:**
- Semicolons are mandatory - don't make them optional
- Manual memory management - don't add GC
- Mutable strings - don't make them immutable
- Runtime type checking - don't remove it

**Why:** Consistency and stability are more important than trendy features.

### âŒ Don't Add "Convenient" Features That Reduce Explicitness

**Examples of features to avoid:**
- Operator overloading (maybe for user types, but carefully)
- Implicit type coercion that loses information
- Automatic resource cleanup (RAII)
- Method chaining that hides complexity
- DSLs and magic syntax

**Exception:** Convenience features are OK if they're **explicit sugar** over simple operations:
- `else if` is fine (it's just nested if statements)
- String interpolation might be OK if it's clearly syntactic sugar
- Method syntax for objects is fine (it's explicit what it does)

---

## Future Considerations

### Maybe Add (Under Discussion)

These features align with Hemlock's philosophy but need careful design:

**1. Pattern matching**
```hemlock
match (value) {
    case i32: print("integer");
    case string: print("text");
    case _: print("other");
}
```
- Explicit type checking
- No hidden costs
- Compile-time exhaustiveness checking possible

**2. Error types (`Result<T, E>`)**
```hemlock
fn divide(a: i32, b: i32): Result<i32, string> {
    if (b == 0) {
        return Err("division by zero");
    }
    return Ok(a / b);
}
```
- Explicit error handling
- Forces users to think about errors
- Alternative to exceptions

**3. Array/slice types**
- Already have dynamic arrays
- Could add fixed-size arrays for stack allocation
- Would need to be explicit about stack vs. heap

**4. Improved memory safety tools**
- Optional bounds checking flag
- Memory leak detection in debug builds
- Sanitizer integration

### Probably Never Add

These features violate core principles:

**1. Garbage collection**
- Hides memory management complexity
- Unpredictable performance
- Against explicit control principle

**2. Automatic memory management**
- Same reasons as GC
- Reference counting might be OK if explicit

**3. Implicit type conversions that lose data**
- Goes against "explicit over implicit"
- Source of subtle bugs

**4. Macros (complex ones)**
- Too much power, too much complexity
- Simple macro system might be OK
- Prefer code generation or functions

**5. Class-based OOP with inheritance**
- Too much implicit behavior
- Duck typing and objects are sufficient
- Composition over inheritance

**6. Module system with complex resolution**
- Keep imports simple and explicit
- No magic search paths
- No version resolution (use OS package manager)

---

## Final Thoughts

### Trust and Responsibility

Hemlock is about **trust and responsibility**. We trust the programmer to:

- Manage memory correctly
- Use types appropriately
- Handle errors properly
- Understand the tradeoffs

In return, Hemlock provides:

- No hidden costs
- No surprise behavior
- Full control when needed
- Safety tools when wanted

### The Guiding Question

**When considering a new feature, ask:**

> "Does this give the programmer more explicit control, or does it hide something?"

- If it **adds explicit control** â†’ probably fits Hemlock
- If it **hides complexity** â†’ probably doesn't belong
- If it's **optional sugar** that's clearly documented â†’ might be OK

### Examples of Good Additions

âœ… **Switch statements** - Explicit control flow, no magic, clear semantics

âœ… **Async/await with pthreads** - Explicit concurrency, true parallelism, user controls spawning

âœ… **Buffer type alongside ptr** - Gives choice between safe and unsafe

âœ… **Optional type annotations** - Helps catch bugs without forcing strictness

âœ… **Try/catch/finally** - Explicit error handling with clear control flow

### Examples of Bad Additions

âŒ **Automatic semicolon insertion** - Hides syntax errors, makes code ambiguous

âŒ **RAII/destructors** - Automatic cleanup hides when resources are released

âŒ **Implicit null coalescing** - Hides null checks, makes code harder to reason about

âŒ **Auto-growing strings** - Hides memory allocation, unpredictable performance

---

## Conclusion

Hemlock is not trying to be the safest language, the fastest language, or the most feature-rich language.

**Hemlock is trying to be the most *honest* language.**

It tells you exactly what it's doing, gives you control when you need it, and doesn't hide the sharp edges. It's a language for people who want to understand their code at a low level while still enjoying modern ergonomics.

If you're not sure whether a feature belongs in Hemlock, remember:

> **Explicit over implicit, always.**
> **Unsafe is a feature, not a bug.**
> **The user is responsible, and that's OK.**


--------------------------------------------------------------------------------
## Signature Syntax
--------------------------------------------------------------------------------

# Signature Syntax Design

> Extending Hemlock's type system with function types, nullable modifiers, type aliases, const parameters, and method signatures.

**Status:** Implemented (v1.7.0)
**Version:** 1.0
**Author:** Claude

---

## Overview

This document proposes five interconnected type system extensions that build on Hemlock's existing infrastructure:

1. **Function Type Annotations** - First-class function types
2. **Nullable Type Modifiers** - Explicit null handling (extends existing `nullable` flag)
3. **Type Aliases** - Named type abbreviations
4. **Const Parameters** - Immutability contracts
5. **Method Signatures in Define** - Interface-like behavior

These features share the philosophy: **explicit over implicit, optional but enforced when used**.

---

## 1. Function Type Annotations

### Motivation

Currently, there's no way to express a function's signature as a type:

```hemlock
// Current: callback has no type information
fn map(arr: array, callback) { ... }

// Proposed: explicit function type
fn map(arr: array, callback: fn(any, i32): any): array { ... }
```

### Syntax

```hemlock
// Basic function type
fn(i32, i32): i32

// With parameter names (documentation only, not enforced)
fn(a: i32, b: i32): i32

// No return value (void)
fn(string): void
fn(string)              // Shorthand: omit `: void`

// Nullable return
fn(i32): string?

// Optional parameters
fn(name: string, age?: i32): void

// Rest parameters
fn(...args: array): i32

// No parameters
fn(): bool

// Higher-order: function returning function
fn(i32): fn(i32): i32

// Async function type
async fn(i32): i32
```

### Usage Examples

```hemlock
// Variable with function type
let add: fn(i32, i32): i32 = fn(a, b) { return a + b; };

// Function parameter
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Return type is function
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Array of functions
let ops: array<fn(i32, i32): i32> = [add, subtract, multiply];

// Object field
define EventHandler {
    name: string;
    callback: fn(Event): void;
}
```

### AST Changes

```c
// In TypeKind enum (include/ast.h)
typedef enum {
    // ... existing types ...
    TYPE_FUNCTION,      // NEW: Function type
} TypeKind;

// In Type struct (include/ast.h)
struct Type {
    TypeKind kind;
    // ... existing fields ...

    // For TYPE_FUNCTION:
    struct Type **param_types;      // Parameter types
    char **param_names;             // Optional parameter names (docs)
    int *param_optional;            // Which params are optional
    int num_params;
    char *rest_param_name;          // Rest parameter name or NULL
    struct Type *rest_param_type;   // Rest parameter type
    struct Type *return_type;       // Return type (NULL = void)
    int is_async;                   // async fn type
};
```

### Parsing

Function types begin with `fn` (or `async fn`) followed by parameter list:

```
function_type := ["async"] "fn" "(" [param_type_list] ")" [":" type]
param_type_list := param_type ("," param_type)*
param_type := [identifier ":"] ["?"] type | "..." [identifier] [":" type]
```

**Disambiguation:** When parsing a type and `fn` is encountered:
- If followed by `(`, it's a function type
- Otherwise, syntax error (bare `fn` is not a valid type)

### Type Compatibility

```hemlock
// Exact match required for function types
let f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // OK

// Parameter contravariance (accepting broader types is OK)
let g: fn(any): i32 = fn(x: i32): i32 { return x; };  // OK: i32 <: any

// Return covariance (returning narrower types is OK)
let h: fn(i32): any = fn(x: i32): i32 { return x; };  // OK: i32 <: any

// Arity must match
let bad: fn(i32): i32 = fn(a, b) { return a; };       // ERROR: arity mismatch

// Optional parameters compatible with required
let opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // OK
```

---

## 2. Nullable Type Modifiers

### Motivation

The `?` suffix makes null-acceptance explicit in signatures:

```hemlock
// Current: unclear if null is valid
fn find(arr: array, val: any): i32 { ... }

// Proposed: explicit nullable return
fn find(arr: array, val: any): i32? { ... }
```

### Syntax

```hemlock
// Nullable types with ? suffix
string?           // string or null
i32?              // i32 or null
User?             // User or null
array<i32>?       // array or null
fn(i32): i32?     // function returning i32 or null

// Composing with function types
fn(string?): i32          // Accepts string or null
fn(string): i32?          // Returns i32 or null
fn(string?): i32?         // Both nullable

// In define
define Result {
    value: any?;
    error: string?;
}
```

### Implementation Notes

**Already exists:** The `Type.nullable` flag is already in the AST. This feature primarily needs:
1. Parser support for `?` suffix on any type (verify/extend)
2. Proper composition with function types
3. Runtime enforcement

### Type Compatibility

```hemlock
// Non-nullable assignable to nullable
let x: i32? = 42;           // OK
let y: i32? = null;         // OK

// Nullable NOT assignable to non-nullable
let z: i32 = x;             // ERROR: x might be null

// Null coalescing to unwrap
let z: i32 = x ?? 0;        // OK: ?? provides default

// Optional chaining returns nullable
let name: string? = user?.name;
```

---

## 3. Type Aliases

### Motivation

Complex types benefit from named abbreviations:

```hemlock
// Current: repetitive compound types
fn process(entity: HasName & HasId & HasTimestamp) { ... }
fn validate(entity: HasName & HasId & HasTimestamp) { ... }

// Proposed: named alias
type Entity = HasName & HasId & HasTimestamp;
fn process(entity: Entity) { ... }
fn validate(entity: Entity) { ... }
```

### Syntax

```hemlock
// Basic alias
type Integer = i32;
type Text = string;

// Compound type alias
type Entity = HasName & HasId;
type Auditable = HasCreatedAt & HasUpdatedAt & HasCreatedBy;

// Function type alias
type Callback = fn(Event): void;
type Predicate = fn(any): bool;
type Reducer = fn(acc: any, val: any): any;
type AsyncTask = async fn(): any;

// Nullable alias
type OptionalString = string?;

// Generic alias (if we support generic type aliases)
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };

// Array type alias
type IntArray = array<i32>;
type Matrix = array<array<f64>>;
```

### Scope and Visibility

```hemlock
// Module-scoped by default
type Callback = fn(Event): void;

// Exportable
export type Handler = fn(Request): Response;

// In another file
import { Handler } from "./handlers.hml";
fn register(h: Handler) { ... }
```

### AST Changes

```c
// New statement kind
typedef enum {
    // ... existing statements ...
    STMT_TYPE_ALIAS,    // NEW
} StmtKind;

// In Stmt union
struct {
    char *name;                 // Alias name
    char **type_params;         // Generic params: <T, U>
    int num_type_params;
    Type *aliased_type;         // The actual type
} type_alias;
```

### Parsing

```
type_alias := "type" identifier ["<" type_params ">"] "=" type ";"
```

**Note:** `type` is a new keyword. Check for conflicts with existing identifiers.

### Resolution

Type aliases are resolved at:
- **Parse time:** Alias recorded in type environment
- **Check time:** Alias expanded to underlying type
- **Runtime:** Alias is transparent (same as underlying type)

```hemlock
type MyInt = i32;
let x: MyInt = 42;
typeof(x);           // "i32" (not "MyInt")
```

---

## 4. Const Parameters

### Motivation

Signal immutability intent in function signatures:

```hemlock
// Current: unclear if array will be modified
fn print_all(items: array) { ... }

// Proposed: explicit immutability contract
fn print_all(const items: array) { ... }
```

### Syntax

```hemlock
// Const parameter
fn process(const data: buffer) {
    // data[0] = 0;        // ERROR: cannot mutate const
    let x = data[0];       // OK: reading allowed
    return x;
}

// Multiple const params
fn compare(const a: array, const b: array): bool { ... }

// Mixed const and mutable
fn update(const source: array, target: array) {
    for (item in source) {
        target.push(item);   // OK: target is mutable
    }
}

// Const with type inference
fn log(const msg) {
    print(msg);
}

// Const in function types
type Reader = fn(const buffer): i32;
```

### What Const Prevents

```hemlock
fn bad(const arr: array) {
    arr.push(1);         // ERROR: mutating method
    arr.pop();           // ERROR: mutating method
    arr[0] = 5;          // ERROR: index assignment
    arr.clear();         // ERROR: mutating method
}

fn ok(const arr: array) {
    let x = arr[0];      // OK: reading
    let len = len(arr);  // OK: length check
    let copy = arr.slice(0, 10);  // OK: creates new array
    for (item in arr) {  // OK: iteration
        print(item);
    }
}
```

### Mutating vs Non-Mutating Methods

| Type | Mutating (blocked by const) | Non-Mutating (allowed) |
|------|----------------------------|------------------------|
| array | push, pop, shift, unshift, insert, remove, clear, reverse (in-place) | slice, concat, map, filter, find, contains, first, last, join |
| string | index assignment (`s[0] = 'x'`) | all methods (return new strings) |
| buffer | index assignment, memset, memcpy (to) | index read, slice |
| object | field assignment | field read |

### AST Changes

```c
// In function expression (include/ast.h)
struct {
    // ... existing fields ...
    int *param_is_const;    // NEW: 1 if const, 0 otherwise
} function;

// In Type struct for function types
struct Type {
    // ... existing fields ...
    int *param_is_const;    // For TYPE_FUNCTION
};
```

### Enforcement

**Interpreter:**
- Track const-ness in variable bindings
- Check before mutation operations
- Runtime error on const violation

**Compiler:**
- Emit const-qualified C variables where beneficial
- Static analysis for const violations
- Warning/error at compile time

---

## 5. Method Signatures in Define

### Motivation

Allow `define` blocks to specify expected methods, not just data fields:

```hemlock
// Current: only data fields
define User {
    name: string;
    age: i32;
}

// Proposed: method signatures
define Comparable {
    fn compare(other: Self): i32;
}

define Serializable {
    fn serialize(): string;
    fn deserialize(data: string): Self;  // Static method
}
```

### Syntax

```hemlock
// Method signature (no body)
define Hashable {
    fn hash(): i32;
}

// Multiple methods
define Collection {
    fn size(): i32;
    fn is_empty(): bool;
    fn contains(item: any): bool;
}

// Mixed fields and methods
define Entity {
    id: i32;
    name: string;
    fn validate(): bool;
    fn serialize(): string;
}

// Using Self type
define Cloneable {
    fn clone(): Self;
}

define Comparable {
    fn compare(other: Self): i32;
    fn equals(other: Self): bool;
}

// Optional methods
define Printable {
    fn to_string(): string;
    fn debug_string?(): string;  // Optional method (may be absent)
}

// Methods with default implementations
define Ordered {
    fn compare(other: Self): i32;  // Required

    // Default implementations (inherited if not overridden)
    fn less_than(other: Self): bool {
        return self.compare(other) < 0;
    }
    fn greater_than(other: Self): bool {
        return self.compare(other) > 0;
    }
    fn equals(other: Self): bool {
        return self.compare(other) == 0;
    }
}
```

### The `Self` Type

`Self` refers to the concrete type implementing the interface:

```hemlock
define Addable {
    fn add(other: Self): Self;
}

// When used:
let a: Addable = {
    value: 10,
    add: fn(other) {
        return { value: self.value + other.value, add: self.add };
    }
};
```

### Structural Typing (Duck Typing)

Method signatures use the same duck typing as fields:

```hemlock
define Stringifiable {
    fn to_string(): string;
}

// Any object with to_string() method satisfies Stringifiable
let x: Stringifiable = {
    name: "test",
    to_string: fn() { return self.name; }
};

// Compound types with methods
define Named { name: string; }
define Printable { fn to_string(): string; }

type NamedPrintable = Named & Printable;

let y: NamedPrintable = {
    name: "Alice",
    to_string: fn() { return "Name: " + self.name; }
};
```

### AST Changes

```c
// Extend define_object in Stmt union
struct {
    char *name;
    char **type_params;
    int num_type_params;

    // Fields (existing)
    char **field_names;
    Type **field_types;
    int *field_optional;
    Expr **field_defaults;
    int num_fields;

    // Methods (NEW)
    char **method_names;
    Type **method_types;        // TYPE_FUNCTION
    int *method_optional;       // Optional methods (fn name?(): type)
    Expr **method_defaults;     // Default implementations (NULL if signature only)
    int num_methods;
} define_object;
```

### Type Checking

When checking `value: InterfaceType`:
1. Check all required fields exist with compatible types
2. Check all required methods exist with compatible signatures
3. Optional fields/methods may be absent

```hemlock
define Sortable {
    fn compare(other: Self): i32;
}

// Valid: has compare method
let valid: Sortable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};

// Invalid: missing compare
let invalid: Sortable = { value: 10 };  // ERROR: missing method 'compare'

// Invalid: wrong signature
let wrong: Sortable = {
    compare: fn() { return 0; }  // ERROR: expected (Self): i32
};
```

---

## Interaction Examples

### Combining All Features

```hemlock
// Type alias for complex function type
type EventCallback = fn(event: Event, context: Context?): bool;

// Type alias for compound interface
type Entity = HasId & HasName & Serializable;

// Define with method signatures
define Repository<T> {
    fn find(id: i32): T?;
    fn save(const entity: T): bool;
    fn delete(id: i32): bool;
    fn find_all(predicate: fn(T): bool): array<T>;
}

// Using it all together
fn create_user_repo(): Repository<User> {
    let users: array<User> = [];

    return {
        find: fn(id) {
            for (u in users) {
                if (u.id == id) { return u; }
            }
            return null;
        },
        save: fn(const entity) {
            users.push(entity);
            return true;
        },
        delete: fn(id) {
            // ...
            return true;
        },
        find_all: fn(predicate) {
            return users.filter(predicate);
        }
    };
}
```

### Callbacks with Explicit Types

```hemlock
type ClickHandler = fn(event: MouseEvent): void;
type KeyHandler = fn(event: KeyEvent, modifiers: i32): bool;

define Widget {
    x: i32;
    y: i32;
    on_click: ClickHandler?;
    on_key: KeyHandler?;
}

fn create_button(label: string, handler: ClickHandler): Widget {
    return {
        x: 0, y: 0,
        on_click: handler,
        on_key: null
    };
}
```

### Nullable Function Types

```hemlock
// Optional callback
fn fetch(url: string, on_complete: fn(Response): void?): void {
    let response = http_get(url);
    if (on_complete != null) {
        on_complete(response);
    }
}

// Nullable return from function type
type Parser = fn(input: string): AST?;

fn try_parse(parsers: array<Parser>, input: string): AST? {
    for (p in parsers) {
        let result = p(input);
        if (result != null) {
            return result;
        }
    }
    return null;
}
```

---

## Implementation Roadmap

### Phase 1: Core Infrastructure
1. Add `TYPE_FUNCTION` to TypeKind enum
2. Extend Type struct with function type fields
3. Add `CHECKED_FUNCTION` to compiler type checker
4. Add `Self` type support (TYPE_SELF)

### Phase 2: Parsing
1. Implement `parse_function_type()` in parser
2. Handle `fn(...)` in type position
3. Add `type` keyword and `STMT_TYPE_ALIAS` parsing
4. Add `const` parameter modifier parsing
5. Extend define parsing for method signatures

### Phase 3: Type Checking
1. Function type compatibility rules
2. Type alias resolution and expansion
3. Const parameter mutation checking
4. Method signature validation in define types
5. Self type resolution

### Phase 4: Runtime
1. Function type validation at call sites
2. Const violation detection
3. Type alias transparency

### Phase 5: Parity Tests
1. Function type annotation tests
2. Nullable composition tests
3. Type alias tests
4. Const parameter tests
5. Method signature tests

---

## Design Decisions

### 1. Generic Type Aliases: **YES**

Type aliases support generic parameters:

```hemlock
// Generic type aliases
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };
type Mapper<T, U> = fn(T): U;
type AsyncResult<T> = async fn(): T?;

// Usage
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
let result: Result<User, string> = { value: user, error: null };
let transform: Mapper<i32, string> = fn(n) { return n.to_string(); };
```

### 2. Const Propagation: **DEEP**

Const parameters are fully immutable - no mutation through any path:

```hemlock
fn process(const arr: array<object>) {
    arr.push({});        // ERROR: cannot mutate const array
    arr[0] = {};         // ERROR: cannot mutate const array
    arr[0].x = 5;        // ERROR: cannot mutate through const (DEEP)

    let x = arr[0].x;    // OK: reading is fine
    let copy = arr[0];   // OK: creates a copy
    copy.x = 5;          // OK: copy is not const
}

fn nested(const obj: object) {
    obj.user.name = "x"; // ERROR: deep const prevents nested mutation
    obj.items[0] = 1;    // ERROR: deep const prevents nested mutation
}
```

**Rationale:** Deep const provides stronger guarantees and is more useful for
ensuring data integrity. If you need to mutate nested data, make a copy first.

### 3. Self in Standalone Type Aliases: **NO**

`Self` is only valid inside `define` blocks where it has clear meaning:

```hemlock
// Valid: Self refers to the defined type
define Comparable {
    fn compare(other: Self): i32;
}

// Invalid: Self has no meaning here
type Cloner = fn(Self): Self;  // ERROR: Self outside define context

// Instead, use generics:
type Cloner<T> = fn(T): T;
```

### 4. Method Default Implementations: **YES (Simple Only)**

Allow default implementations for simple/utility methods:

```hemlock
define Comparable {
    // Required: must be implemented
    fn compare(other: Self): i32;

    // Default implementations (simple convenience methods)
    fn equals(other: Self): bool {
        return self.compare(other) == 0;
    }
    fn less_than(other: Self): bool {
        return self.compare(other) < 0;
    }
    fn greater_than(other: Self): bool {
        return self.compare(other) > 0;
    }
}

define Printable {
    fn to_string(): string;

    // Default: delegates to required method
    fn print() {
        print(self.to_string());
    }
    fn println() {
        print(self.to_string() + "\n");
    }
}

// Object only needs to implement required methods
let item: Comparable = {
    value: 42,
    compare: fn(other) { return self.value - other.value; }
    // equals, less_than, greater_than are inherited from defaults
};

item.less_than({ value: 50, compare: item.compare });  // true
```

**Guidelines for defaults:**
- Keep them simple (1-3 lines)
- Should delegate to required methods
- No complex logic or side effects
- Primitives and straightforward compositions only

### 5. Variance: **INFERRED (No Explicit Annotations)**

Variance is inferred from how type parameters are used:

```hemlock
// Variance is automatic based on position
type Producer<T> = fn(): T;           // T in return = covariant
type Consumer<T> = fn(T): void;       // T in param = contravariant
type Transformer<T> = fn(T): T;       // T in both = invariant

// Example: Dog <: Animal (Dog is subtype of Animal)
let dog_producer: Producer<Dog> = fn() { return new_dog(); };
let animal_producer: Producer<Animal> = dog_producer;  // OK: covariant

let animal_consumer: Consumer<Animal> = fn(a) { print(a); };
let dog_consumer: Consumer<Dog> = animal_consumer;     // OK: contravariant
```

**Why infer?**
- Less boilerplate (`<out T>` / `<in T>` adds noise)
- Follows "explicit over implicit" - the position IS explicit
- Matches how most languages handle function type variance
- Errors are clear when variance rules are violated

---

## Appendix: Grammar Changes

```ebnf
(* Types *)
type := simple_type | compound_type | function_type
simple_type := base_type ["?"] | identifier ["<" type_args ">"] ["?"]
compound_type := simple_type ("&" simple_type)+
function_type := ["async"] "fn" "(" [param_types] ")" [":" type]

base_type := "i8" | "i16" | "i32" | "i64"
           | "u8" | "u16" | "u32" | "u64"
           | "f32" | "f64" | "bool" | "string" | "rune"
           | "ptr" | "buffer" | "void" | "null"
           | "array" ["<" type ">"]
           | "object"
           | "Self"

param_types := param_type ("," param_type)*
param_type := ["const"] [identifier ":"] ["?"] type
            | "..." [identifier] [":" type]

type_args := type ("," type)*

(* Statements *)
type_alias := "type" identifier ["<" type_params ">"] "=" type ";"

define_stmt := "define" identifier ["<" type_params ">"] "{" define_members "}"
define_members := (field_def | method_def)*
field_def := identifier (":" type ["=" expr] | "?:" (type | expr)) ";"?
method_def := "fn" identifier ["?"] "(" [param_types] ")" [":" type] (block | ";")
            (* "?" marks optional method, block provides default implementation *)

(* Parameters *)
param := ["const"] ["ref"] identifier [":" type] ["?:" expr]
       | "..." identifier [":" type]
```



################################################################################
# CONTRIBUTING
################################################################################

--------------------------------------------------------------------------------
## Guidelines
--------------------------------------------------------------------------------

# Contributing to Hemlock

Thank you for your interest in contributing to Hemlock! This guide will help you understand how to contribute effectively while maintaining the language's design philosophy and code quality.

---

## Table of Contents

- [Before You Start](#before-you-start)
- [Contribution Workflow](#contribution-workflow)
- [Code Style Guidelines](#code-style-guidelines)
- [What to Contribute](#what-to-contribute)
- [What NOT to Contribute](#what-not-to-contribute)
- [Common Patterns](#common-patterns)
- [Adding New Features](#adding-new-features)
- [Code Review Process](#code-review-process)

---

## Before You Start

### Required Reading

Before contributing, please read these documents in order:

1. **`/home/user/hemlock/docs/design/philosophy.md`** - Understand Hemlock's core principles
2. **`/home/user/hemlock/docs/design/implementation.md`** - Learn the codebase structure
3. **`/home/user/hemlock/docs/contributing/testing.md`** - Understand testing requirements
4. **This document** - Learn contribution guidelines

### Prerequisites

**Required knowledge:**
- C programming (pointers, memory management, structs)
- Compiler/interpreter basics (lexing, parsing, AST)
- Git and GitHub workflow
- Unix/Linux command line

**Required tools:**
- GCC or Clang compiler
- Make build system
- Git version control
- Valgrind (for memory leak detection)
- Basic text editor or IDE

### Communication Channels

**Where to ask questions:**
- GitHub Issues - Bug reports and feature requests
- GitHub Discussions - General questions and design discussions
- Pull Request comments - Specific code feedback

---

## Contribution Workflow

### 1. Find or Create an Issue

**Before writing code:**
- Check if an issue exists for your contribution
- If not, create one describing what you want to do
- Wait for maintainer feedback before starting large changes
- Small bug fixes can skip this step

**Good issue descriptions include:**
- Problem statement (what's broken or missing)
- Proposed solution (how you plan to fix it)
- Examples (code snippets showing the issue)
- Rationale (why this change aligns with Hemlock's philosophy)

### 2. Fork and Clone

```bash
# Fork the repository on GitHub first, then:
git clone https://github.com/YOUR_USERNAME/hemlock.git
cd hemlock
git checkout -b feature/your-feature-name
```

### 3. Make Your Changes

Follow these guidelines:
- Write tests first (TDD approach)
- Implement the feature
- Ensure all tests pass
- Check for memory leaks
- Update documentation

### 4. Test Your Changes

```bash
# Run the full test suite
make test

# Run specific test category
./tests/run_tests.sh tests/category/

# Check for memory leaks
valgrind ./hemlock tests/your_test.hml

# Build and test
make clean && make && make test
```

### 5. Commit Your Changes

**Good commit messages:**
```
Add bitwise operators for integer types

- Implement &, |, ^, <<, >>, ~ operators
- Add type checking to ensure integer-only operations
- Update operator precedence table
- Add comprehensive tests for all operators

Closes #42
```

**Commit message format:**
- First line: Brief summary (50 chars max)
- Blank line
- Detailed explanation (wrap at 72 chars)
- Reference issue numbers

### 6. Submit a Pull Request

**Before submitting:**
- Rebase on latest main branch
- Ensure all tests pass
- Run valgrind to check for leaks
- Update CLAUDE.md if adding user-facing features

**Pull request description should include:**
- What problem this solves
- How it solves it
- Breaking changes (if any)
- Examples of new syntax or behavior
- Test coverage summary

---

## Code Style Guidelines

### C Code Style

**Formatting:**
```c
// Indent with 4 spaces (no tabs)
// K&R brace style for functions
void function_name(int arg1, char *arg2)
{
    if (condition) {
        // Brace on same line for control structures
        do_something();
    }
}

// Line length: 100 characters max
// Use spaces around operators
int result = (a + b) * c;

// Pointer asterisk with type
char *string;   // Good
char* string;   // Avoid
char * string;  // Avoid
```

**Naming conventions:**
```c
// Functions: lowercase_with_underscores
void eval_expression(ASTNode *node);

// Types: PascalCase
typedef struct Value Value;
typedef enum ValueType ValueType;

// Constants: UPPERCASE_WITH_UNDERSCORES
#define MAX_BUFFER_SIZE 4096

// Variables: lowercase_with_underscores
int item_count;
Value *current_value;

// Enums: TYPE_PREFIX_NAME
typedef enum {
    TYPE_I32,
    TYPE_STRING,
    TYPE_OBJECT
} ValueType;
```

**Comments:**
```c
// Single-line comments for brief explanations
// Use complete sentences with proper capitalization

/*
 * Multi-line comments for longer explanations
 * Align asterisks for readability
 */

/**
 * Function documentation comment
 * @param node - AST node to evaluate
 * @return Evaluated value
 */
Value eval_expr(ASTNode *node);
```

**Error handling:**
```c
// Check all malloc calls
char *buffer = malloc(size);
if (!buffer) {
    fprintf(stderr, "Error: Out of memory\n");
    exit(1);
}

// Provide context in error messages
if (file == NULL) {
    fprintf(stderr, "Error: Failed to open '%s': %s\n",
            filename, strerror(errno));
    exit(1);
}

// Use meaningful error messages
// Bad: "Error: Invalid value"
// Good: "Error: Expected integer, got string"
```

**Memory management:**
```c
// Always free what you allocate
Value *val = value_create_i32(42);
// ... use val
value_free(val);

// Set pointers to NULL after freeing (prevents double-free)
free(ptr);
ptr = NULL;

// Document ownership in comments
// This function takes ownership of 'value' and will free it
void store_value(Value *value);

// This function does NOT take ownership (caller must free)
Value *get_value(void);
```

### Code Organization

**File structure:**
```c
// 1. Includes (system headers first, then local)
#include <stdio.h>
#include <stdlib.h>
#include "internal.h"
#include "values.h"

// 2. Constants and macros
#define INITIAL_CAPACITY 16

// 3. Type definitions
typedef struct Foo Foo;

// 4. Static function declarations (internal helpers)
static void helper_function(void);

// 5. Public function implementations
void public_api_function(void)
{
    // Implementation
}

// 6. Static function implementations
static void helper_function(void)
{
    // Implementation
}
```

**Header files:**
```c
// Use header guards
#ifndef HEMLOCK_MODULE_H
#define HEMLOCK_MODULE_H

// Forward declarations
typedef struct Value Value;

// Public API only in headers
void public_function(Value *val);

// Document parameters and return values
/**
 * Evaluates an expression AST node
 * @param node - The AST node to evaluate
 * @param env - The current environment
 * @return The result value
 */
Value *eval_expr(ASTNode *node, Environment *env);

#endif // HEMLOCK_MODULE_H
```

---

## What to Contribute

### âœ… Encouraged Contributions

**Bug fixes:**
- Memory leaks
- Segmentation faults
- Incorrect behavior
- Error message improvements

**Documentation:**
- Code comments
- API documentation
- User guides and tutorials
- Example programs
- Test case documentation

**Tests:**
- Additional test cases for existing features
- Edge case coverage
- Regression tests for fixed bugs
- Performance benchmarks

**Small feature additions:**
- New built-in functions (if they fit the philosophy)
- String/array methods
- Utility functions
- Error handling improvements

**Performance improvements:**
- Faster algorithms (without changing semantics)
- Memory usage reduction
- Benchmark suite
- Profiling tools

**Tooling:**
- Editor syntax highlighting
- Language server protocol (LSP)
- Debugger integration
- Build system improvements

### ðŸ¤” Discuss First

**Major features:**
- New language constructs
- Type system changes
- Syntax additions
- Concurrency primitives

**How to discuss:**
1. Open a GitHub issue or discussion
2. Describe the feature and rationale
3. Show example code
4. Explain how it fits Hemlock's philosophy
5. Wait for maintainer feedback
6. Iterate on design before implementing

---

## What NOT to Contribute

### âŒ Discouraged Contributions

**Don't add features that:**
- Hide complexity from the user
- Make behavior implicit or magical
- Break existing semantics or syntax
- Add garbage collection or automatic memory management
- Violate the "explicit over implicit" principle

**Examples of rejected contributions:**

**1. Automatic semicolon insertion**
```hemlock
// BAD: This would be rejected
let x = 5  // No semicolon
let y = 10 // No semicolon
```
Why: Makes syntax ambiguous, hides errors

**2. RAII/destructors**
```hemlock
// BAD: This would be rejected
let f = open("file.txt");
// File automatically closed at end of scope
```
Why: Hides when resources are released, not explicit

**3. Implicit type coercion that loses data**
```hemlock
// BAD: This would be rejected
let x: i32 = 3.14;  // Silently truncates to 3
```
Why: Data loss should be explicit, not silent

**4. Garbage collection**
```c
// BAD: This would be rejected
void *gc_malloc(size_t size) {
    // Track allocation for automatic cleanup
}
```
Why: Hides memory management, unpredictable performance

**5. Complex macro system**
```hemlock
// BAD: This would be rejected
macro repeat($n, $block) {
    for (let i = 0; i < $n; i++) $block
}
```
Why: Too much magic, makes code hard to reason about

### Common Rejection Reasons

**"This is too implicit"**
- Solution: Make the behavior explicit and document it

**"This hides complexity"**
- Solution: Expose the complexity but make it ergonomic

**"This breaks existing code"**
- Solution: Find a non-breaking alternative or discuss versioning

**"This doesn't fit Hemlock's philosophy"**
- Solution: Re-read philosophy.md and reconsider the approach

---

## Common Patterns

### Error Handling Pattern

```c
// Use this pattern for recoverable errors in Hemlock code
Value *divide(Value *a, Value *b)
{
    // Check preconditions
    if (b->type != TYPE_I32) {
        // Return error value or throw exception
        return create_error("Expected integer divisor");
    }

    if (b->i32_value == 0) {
        return create_error("Division by zero");
    }

    // Perform operation
    return value_create_i32(a->i32_value / b->i32_value);
}
```

### Memory Management Pattern

```c
// Pattern: Allocate, use, free
void process_data(void)
{
    // Allocate
    Buffer *buf = create_buffer(1024);
    char *str = malloc(256);

    // Use
    if (buf && str) {
        // ... do work
    }

    // Free (in reverse order of allocation)
    free(str);
    free_buffer(buf);
}
```

### Value Creation Pattern

```c
// Create values using constructors
Value *create_integer(int32_t n)
{
    Value *val = malloc(sizeof(Value));
    if (!val) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }

    val->type = TYPE_I32;
    val->i32_value = n;
    return val;
}
```

### Type Checking Pattern

```c
// Check types before operations
Value *add_values(Value *a, Value *b)
{
    // Type checking
    if (a->type != TYPE_I32 || b->type != TYPE_I32) {
        return create_error("Type mismatch");
    }

    // Safe to proceed
    return value_create_i32(a->i32_value + b->i32_value);
}
```

### String Building Pattern

```c
// Build strings efficiently
void build_error_message(char *buffer, size_t size, const char *detail)
{
    snprintf(buffer, size, "Error: %s (line %d)", detail, line_number);
}
```

---

## Adding New Features

### Feature Addition Checklist

When adding a new feature, follow these steps:

#### 1. Design Phase

- [ ] Read philosophy.md to ensure alignment
- [ ] Create GitHub issue describing the feature
- [ ] Get maintainer approval for design
- [ ] Write specification (syntax, semantics, examples)
- [ ] Consider edge cases and error conditions

#### 2. Implementation Phase

**If adding a language construct:**

- [ ] Add token type to `lexer.h` (if needed)
- [ ] Add lexer rule in `lexer.c` (if needed)
- [ ] Add AST node type in `ast.h`
- [ ] Add AST constructor in `ast.c`
- [ ] Add parser rule in `parser.c`
- [ ] Add runtime behavior in `runtime.c` or appropriate module
- [ ] Handle cleanup in AST free functions

**If adding a built-in function:**

- [ ] Add function implementation in `builtins.c`
- [ ] Register function in `register_builtins()`
- [ ] Handle all parameter type combinations
- [ ] Return appropriate error values
- [ ] Document parameters and return type

**If adding a value type:**

- [ ] Add type enum in `values.h`
- [ ] Add field to Value union
- [ ] Add constructor in `values.c`
- [ ] Add to `value_free()` for cleanup
- [ ] Add to `value_copy()` for copying
- [ ] Add to `value_to_string()` for printing
- [ ] Add type promotion rules if numeric

#### 3. Testing Phase

- [ ] Write test cases (see testing.md)
- [ ] Test success cases
- [ ] Test error cases
- [ ] Test edge cases
- [ ] Run full test suite (`make test`)
- [ ] Check for memory leaks with valgrind
- [ ] Test on multiple platforms (if possible)

#### 4. Documentation Phase

- [ ] Update CLAUDE.md with user-facing documentation
- [ ] Add code comments explaining implementation
- [ ] Create examples in `examples/`
- [ ] Update relevant docs/ files
- [ ] Document any breaking changes

#### 5. Submission Phase

- [ ] Clean up debug code and comments
- [ ] Verify code style compliance
- [ ] Rebase on latest main
- [ ] Create pull request with detailed description
- [ ] Respond to code review feedback

### Example: Adding a New Operator

Let's walk through adding the modulo operator `%` as an example:

**1. Lexer (lexer.c):**
```c
// Add to switch statement in get_next_token()
case '%':
    return create_token(TOKEN_PERCENT, "%", line);
```

**2. Lexer header (lexer.h):**
```c
typedef enum {
    // ... existing tokens
    TOKEN_PERCENT,
    // ...
} TokenType;
```

**3. AST (ast.h):**
```c
typedef enum {
    // ... existing operators
    OP_MOD,
    // ...
} BinaryOp;
```

**4. Parser (parser.c):**
```c
// Add to parse_multiplicative() or appropriate precedence level
if (match(TOKEN_PERCENT)) {
    BinaryOp op = OP_MOD;
    ASTNode *right = parse_unary();
    left = create_binary_op_node(op, left, right);
}
```

**5. Runtime (runtime.c):**
```c
// Add to eval_binary_op()
case OP_MOD:
    // Type checking
    if (left->type == TYPE_I32 && right->type == TYPE_I32) {
        if (right->i32_value == 0) {
            fprintf(stderr, "Error: Modulo by zero\n");
            exit(1);
        }
        return value_create_i32(left->i32_value % right->i32_value);
    }
    // ... handle other type combinations
    break;
```

**6. Tests (tests/operators/modulo.hml):**
```hemlock
// Basic modulo
print(10 % 3);  // Expect: 2

// Negative modulo
print(-10 % 3); // Expect: -1

// Error case (should fail)
// print(10 % 0);  // Division by zero
```

**7. Documentation (CLAUDE.md):**
```markdown
### Arithmetic Operators
- `+` - Addition
- `-` - Subtraction
- `*` - Multiplication
- `/` - Division
- `%` - Modulo (remainder)
```

---

## Code Review Process

### What Reviewers Look For

**1. Correctness**
- Does the code do what it claims?
- Are edge cases handled?
- Are there memory leaks?
- Are errors handled properly?

**2. Philosophy Alignment**
- Does this fit Hemlock's design principles?
- Is it explicit or implicit?
- Does it hide complexity?

**3. Code Quality**
- Is the code readable and maintainable?
- Are variable names descriptive?
- Are functions reasonably sized?
- Is there adequate documentation?

**4. Testing**
- Are there sufficient test cases?
- Do tests cover success and failure paths?
- Are edge cases tested?

**5. Documentation**
- Is user-facing documentation updated?
- Are code comments clear?
- Are examples provided?

### Responding to Feedback

**Do:**
- Thank reviewers for their time
- Ask clarifying questions if you don't understand
- Explain your reasoning if you disagree
- Make requested changes promptly
- Update the PR description if scope changes

**Don't:**
- Take criticism personally
- Argue defensively
- Ignore feedback
- Force-push over review comments (unless rebasing)
- Add unrelated changes to the PR

### Getting Your PR Merged

**Requirements for merge:**
- [ ] All tests pass
- [ ] No memory leaks (valgrind clean)
- [ ] Code review approval from maintainer
- [ ] Documentation updated
- [ ] Follows code style guidelines
- [ ] Aligns with Hemlock's philosophy

**Timeline:**
- Small PRs (bug fixes): Usually reviewed within a few days
- Medium PRs (new features): May take 1-2 weeks
- Large PRs (major changes): Requires extensive discussion

---

## Additional Resources

### Learning Resources

**Understanding interpreters:**
- "Crafting Interpreters" by Robert Nystrom
- "Writing An Interpreter In Go" by Thorsten Ball
- "Modern Compiler Implementation in C" by Andrew Appel

**C programming:**
- "The C Programming Language" by K&R
- "Expert C Programming" by Peter van der Linden
- "C Interfaces and Implementations" by David Hanson

**Memory management:**
- Valgrind documentation
- "Understanding and Using C Pointers" by Richard Reese

### Useful Commands

```bash
# Build with debug symbols
make clean && make CFLAGS="-g -O0"

# Run with valgrind
valgrind --leak-check=full ./hemlock script.hml

# Run specific test category
./tests/run_tests.sh tests/strings/

# Generate tags file for code navigation
ctags -R .

# Find all TODOs and FIXMEs
grep -rn "TODO\|FIXME" src/ include/
```

---

## Questions?

If you have questions about contributing:

1. Check the documentation in `docs/`
2. Search existing GitHub issues
3. Ask in GitHub Discussions
4. Open a new issue with your question

**Thank you for contributing to Hemlock!**


--------------------------------------------------------------------------------
## Testing
--------------------------------------------------------------------------------

# Testing Guide for Hemlock

This guide explains Hemlock's testing philosophy, how to write tests, and how to run the test suite.

---

## Table of Contents

- [Testing Philosophy](#testing-philosophy)
- [Test Suite Structure](#test-suite-structure)
- [Running Tests](#running-tests)
- [Writing Tests](#writing-tests)
- [Test Categories](#test-categories)
- [Memory Leak Testing](#memory-leak-testing)
- [Continuous Integration](#continuous-integration)
- [Best Practices](#best-practices)

---

## Testing Philosophy

### Core Principles

**1. Test-Driven Development (TDD)**

Write tests **before** implementing features:

```
1. Write a failing test
2. Implement the feature
3. Run the test (should pass)
4. Refactor if needed
5. Repeat
```

**Benefits:**
- Ensures features actually work
- Prevents regressions
- Documents expected behavior
- Makes refactoring safer

**2. Comprehensive Coverage**

Test both success and failure cases:

```hemlock
// Success case
let x: u8 = 255;  // Should work

// Failure case
let y: u8 = 256;  // Should error
```

**3. Test Early and Often**

Run tests:
- Before committing code
- After making changes
- Before submitting pull requests
- During code review

**Rule:** All tests must pass before merging.

### What to Test

**Always test:**
- âœ… Basic functionality (happy path)
- âœ… Error conditions (sad path)
- âœ… Edge cases (boundary conditions)
- âœ… Type checking and conversions
- âœ… Memory management (no leaks)
- âœ… Concurrency and race conditions

**Example test coverage:**
```hemlock
// Feature: String.substr(start, length)

// Happy path
print("hello".substr(0, 5));  // "hello"

// Edge cases
print("hello".substr(0, 0));  // "" (empty)
print("hello".substr(5, 0));  // "" (at end)
print("hello".substr(2, 100)); // "llo" (past end)

// Error cases
// "hello".substr(-1, 5);  // Error: negative index
// "hello".substr(0, -1);  // Error: negative length
```

---

## Test Suite Structure

### Directory Organization

```
tests/
â”œâ”€â”€ run_tests.sh          # Main test runner script
â”œâ”€â”€ primitives/           # Type system tests
â”‚   â”œâ”€â”€ integers.hml
â”‚   â”œâ”€â”€ floats.hml
â”‚   â”œâ”€â”€ booleans.hml
â”‚   â”œâ”€â”€ i64.hml
â”‚   â””â”€â”€ u64.hml
â”œâ”€â”€ conversions/          # Type conversion tests
â”‚   â”œâ”€â”€ int_to_float.hml
â”‚   â”œâ”€â”€ promotion.hml
â”‚   â””â”€â”€ rune_conversions.hml
â”œâ”€â”€ memory/               # Pointer/buffer tests
â”‚   â”œâ”€â”€ alloc.hml
â”‚   â”œâ”€â”€ buffer.hml
â”‚   â””â”€â”€ memcpy.hml
â”œâ”€â”€ strings/              # String operation tests
â”‚   â”œâ”€â”€ concat.hml
â”‚   â”œâ”€â”€ methods.hml
â”‚   â”œâ”€â”€ utf8.hml
â”‚   â””â”€â”€ runes.hml
â”œâ”€â”€ control/              # Control flow tests
â”‚   â”œâ”€â”€ if.hml
â”‚   â”œâ”€â”€ switch.hml
â”‚   â””â”€â”€ while.hml
â”œâ”€â”€ functions/            # Function and closure tests
â”‚   â”œâ”€â”€ basics.hml
â”‚   â”œâ”€â”€ closures.hml
â”‚   â””â”€â”€ recursion.hml
â”œâ”€â”€ objects/              # Object tests
â”‚   â”œâ”€â”€ literals.hml
â”‚   â”œâ”€â”€ methods.hml
â”‚   â”œâ”€â”€ duck_typing.hml
â”‚   â””â”€â”€ serialization.hml
â”œâ”€â”€ arrays/               # Array operation tests
â”‚   â”œâ”€â”€ basics.hml
â”‚   â”œâ”€â”€ methods.hml
â”‚   â””â”€â”€ slicing.hml
â”œâ”€â”€ loops/                # Loop tests
â”‚   â”œâ”€â”€ for.hml
â”‚   â”œâ”€â”€ while.hml
â”‚   â”œâ”€â”€ break.hml
â”‚   â””â”€â”€ continue.hml
â”œâ”€â”€ exceptions/           # Error handling tests
â”‚   â”œâ”€â”€ try_catch.hml
â”‚   â”œâ”€â”€ finally.hml
â”‚   â””â”€â”€ throw.hml
â”œâ”€â”€ io/                   # File I/O tests
â”‚   â”œâ”€â”€ file_object.hml
â”‚   â”œâ”€â”€ read_write.hml
â”‚   â””â”€â”€ seek.hml
â”œâ”€â”€ async/                # Concurrency tests
â”‚   â”œâ”€â”€ spawn_join.hml
â”‚   â”œâ”€â”€ channels.hml
â”‚   â””â”€â”€ exceptions.hml
â”œâ”€â”€ ffi/                  # FFI tests
â”‚   â”œâ”€â”€ basic_call.hml
â”‚   â”œâ”€â”€ types.hml
â”‚   â””â”€â”€ dlopen.hml
â”œâ”€â”€ signals/              # Signal handling tests
â”‚   â”œâ”€â”€ basic.hml
â”‚   â”œâ”€â”€ handlers.hml
â”‚   â””â”€â”€ raise.hml
â””â”€â”€ args/                 # Command-line args tests
    â””â”€â”€ basic.hml
```

### Test File Naming

**Conventions:**
- Use descriptive names: `method_chaining.hml` not `test1.hml`
- Group related tests: `string_substr.hml`, `string_slice.hml`
- One feature area per file
- Keep files focused and small

---

## Running Tests

### Run All Tests

```bash
# From hemlock root directory
make test

# Or directly
./tests/run_tests.sh
```

**Output:**
```
Running tests in tests/primitives/...
  âœ“ integers.hml
  âœ“ floats.hml
  âœ“ booleans.hml

Running tests in tests/strings/...
  âœ“ concat.hml
  âœ“ methods.hml

...

Total: 251 tests
Passed: 251
Failed: 0
```

### Run Specific Category

```bash
# Run only string tests
./tests/run_tests.sh tests/strings/

# Run only one test file
./tests/run_tests.sh tests/strings/concat.hml

# Run multiple categories
./tests/run_tests.sh tests/strings/ tests/arrays/
```

### Run with Valgrind (Memory Leak Check)

```bash
# Check single test for leaks
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml

# Check all tests (slow!)
for test in tests/**/*.hml; do
    echo "Testing $test"
    valgrind --leak-check=full --error-exitcode=1 ./hemlock "$test"
done
```

### Debug Failed Tests

```bash
# Run with verbose output
./hemlock tests/failing_test.hml

# Run with gdb
gdb --args ./hemlock tests/failing_test.hml
(gdb) run
(gdb) backtrace  # if it crashes
```

---

## Writing Tests

### Test File Format

Test files are just Hemlock programs with expected output:

**Example: tests/primitives/integers.hml**
```hemlock
// Test basic integer literals
let x = 42;
print(x);  // Expect: 42

let y: i32 = 100;
print(y);  // Expect: 100

// Test arithmetic
let sum = x + y;
print(sum);  // Expect: 142

// Test type inference
let small = 10;
print(typeof(small));  // Expect: i32

let large = 5000000000;
print(typeof(large));  // Expect: i64
```

**How tests work:**
1. Test runner executes the .hml file
2. Captures stdout output
3. Compares with expected output (from comments or separate .out file)
4. Reports pass/fail

### Expected Output Methods

**Method 1: Inline comments (recommended for simple tests)**

```hemlock
print("hello");  // Expect: hello
print(42);       // Expect: 42
```

The test runner parses `// Expect: ...` comments.

**Method 2: Separate .out file**

Create `test_name.hml.out` with expected output:

**test_name.hml:**
```hemlock
print("line 1");
print("line 2");
print("line 3");
```

**test_name.hml.out:**
```
line 1
line 2
line 3
```

### Testing Error Cases

Error tests should cause the program to exit with non-zero status:

**Example: tests/primitives/range_error.hml**
```hemlock
// This should fail with a type error
let x: u8 = 256;  // Out of range for u8
```

**Expected behavior:**
- Program exits with non-zero status
- Prints error message to stderr

**Test runner handling:**
- Tests expecting errors should be in separate files
- Use naming convention: `*_error.hml` or `*_fail.hml`
- Document expected error in comments

### Testing Success Cases

**Example: tests/strings/methods.hml**
```hemlock
// Test substr
let s = "hello world";
let sub = s.substr(6, 5);
print(sub);  // Expect: world

// Test find
let pos = s.find("world");
print(pos);  // Expect: 6

// Test contains
let has = s.contains("lo");
print(has);  // Expect: true

// Test trim
let padded = "  hello  ";
let trimmed = padded.trim();
print(trimmed);  // Expect: hello
```

### Testing Edge Cases

**Example: tests/arrays/edge_cases.hml**
```hemlock
// Empty array
let empty = [];
print(empty.length);  // Expect: 0

// Single element
let single = [42];
print(single[0]);  // Expect: 42

// Negative index (should error in separate test file)
// print(single[-1]);  // Error

// Past-end index (should error)
// print(single[100]);  // Error

// Boundary conditions
let arr = [1, 2, 3];
print(arr.slice(0, 0));  // Expect: [] (empty)
print(arr.slice(3, 3));  // Expect: [] (empty)
print(arr.slice(1, 2));  // Expect: [2]
```

### Testing Type System

**Example: tests/conversions/promotion.hml**
```hemlock
// Test type promotion in binary operations

// i32 + i64 -> i64
let a: i32 = 10;
let b: i64 = 20;
let c = a + b;
print(typeof(c));  // Expect: i64

// i32 + f32 -> f32
let d: i32 = 10;
let e: f32 = 3.14;
let f = d + e;
print(typeof(f));  // Expect: f32

// u8 + i32 -> i32
let g: u8 = 5;
let h: i32 = 10;
let i = g + h;
print(typeof(i));  // Expect: i32
```

### Testing Concurrency

**Example: tests/async/basic.hml**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Spawn tasks
let t1 = spawn(compute, 10);
let t2 = spawn(compute, 20);

// Join and print results
let r1 = join(t1);
let r2 = join(t2);
print(r1);  // Expect: 45
print(r2);  // Expect: 190
```

### Testing Exceptions

**Example: tests/exceptions/try_catch.hml**
```hemlock
// Test basic try/catch
try {
    throw "error message";
} catch (e) {
    print("Caught: " + e);  // Expect: Caught: error message
}

// Test finally
let executed = false;
try {
    print("try");  // Expect: try
} finally {
    executed = true;
    print("finally");  // Expect: finally
}

// Test exception propagation
fn risky(): i32 {
    throw "failure";
}

try {
    risky();
} catch (e) {
    print(e);  // Expect: failure
}
```

---

## Test Categories

### Primitives Tests

**What to test:**
- Integer types (i8, i16, i32, i64, u8, u16, u32, u64)
- Float types (f32, f64)
- Boolean type
- String type
- Rune type
- Null type

**Example areas:**
- Literal syntax
- Type inference
- Range checking
- Overflow behavior
- Type annotations

### Conversion Tests

**What to test:**
- Implicit type promotion
- Explicit type conversion
- Lossy conversions (should error)
- Type promotion in operations
- Cross-type comparisons

### Memory Tests

**What to test:**
- alloc/free correctness
- Buffer creation and access
- Bounds checking on buffers
- memset, memcpy, realloc
- Memory leak detection (valgrind)

### String Tests

**What to test:**
- Concatenation
- All 18 string methods
- UTF-8 handling
- Rune indexing
- String + rune concatenation
- Edge cases (empty strings, single char, etc.)

### Control Flow Tests

**What to test:**
- if/else/else if
- while loops
- for loops
- switch statements
- break/continue
- return statements

### Function Tests

**What to test:**
- Function definition and calling
- Parameter passing
- Return values
- Recursion
- Closures and capture
- First-class functions
- Anonymous functions

### Object Tests

**What to test:**
- Object literals
- Field access and assignment
- Methods and self binding
- Duck typing
- Optional fields
- JSON serialization/deserialization
- Circular reference detection

### Array Tests

**What to test:**
- Array creation
- Indexing and assignment
- All 15 array methods
- Mixed types
- Dynamic resizing
- Edge cases (empty, single element)

### Exception Tests

**What to test:**
- try/catch/finally
- throw statement
- Exception propagation
- Nested try/catch
- Return in try/catch/finally
- Uncaught exceptions

### I/O Tests

**What to test:**
- File opening modes
- Read/write operations
- Seek/tell
- File properties
- Error handling (missing files, etc.)
- Resource cleanup

### Async Tests

**What to test:**
- spawn/join/detach
- Channel send/recv
- Exception propagation in tasks
- Multiple concurrent tasks
- Channel blocking behavior

### FFI Tests

**What to test:**
- dlopen/dlclose
- dlsym
- dlcall with various types
- Type conversion
- Error handling

---

## Memory Leak Testing

### Using Valgrind

**Basic usage:**
```bash
valgrind --leak-check=full ./hemlock test.hml
```

**Example output (no leaks):**
```
==12345== HEAP SUMMARY:
==12345==     in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated
==12345==
==12345== All heap blocks were freed -- no leaks are possible
```

**Example output (with leak):**
```
==12345== LEAK SUMMARY:
==12345==    definitely lost: 64 bytes in 1 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==      possibly lost: 0 bytes in 0 blocks
==12345==    still reachable: 0 bytes in 0 blocks
==12345==         suppressed: 0 bytes in 0 blocks
```

### Common Leak Sources

**1. Missing free() calls:**
```c
// BAD
char *str = malloc(100);
// ... use str
// Forgot to free!

// GOOD
char *str = malloc(100);
// ... use str
free(str);
```

**2. Lost pointers:**
```c
// BAD
char *ptr = malloc(100);
ptr = malloc(200);  // Lost reference to first allocation!

// GOOD
char *ptr = malloc(100);
free(ptr);
ptr = malloc(200);
```

**3. Exception paths:**
```c
// BAD
void func() {
    char *data = malloc(100);
    if (error_condition) {
        return;  // Leak!
    }
    free(data);
}

// GOOD
void func() {
    char *data = malloc(100);
    if (error_condition) {
        free(data);
        return;
    }
    free(data);
}
```

### Known Acceptable Leaks

Some small "leaks" are intentional startup allocations:

**Global built-ins:**
```hemlock
// Built-in functions, FFI types, and constants are allocated at startup
// and not freed at exit (typically ~200 bytes)
```

These are not true leaks - they're one-time allocations that persist for the program lifetime and are cleaned up by the OS on exit.

---

## Continuous Integration

### GitHub Actions (Future)

Once CI is set up, all tests will run automatically on:
- Push to main branch
- Pull request creation/update
- Scheduled daily runs

**CI workflow:**
1. Build Hemlock
2. Run test suite
3. Check for memory leaks (valgrind)
4. Report results on PR

### Pre-Commit Checks

Before committing, run:

```bash
# Build fresh
make clean && make

# Run all tests
make test

# Check a few tests for leaks
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml
valgrind --leak-check=full ./hemlock tests/strings/concat.hml
```

---

## Best Practices

### Do's

âœ… **Write tests first (TDD)**
```bash
1. Create tests/feature/new_feature.hml
2. Implement feature in src/
3. Run tests until they pass
```

âœ… **Test both success and failure**
```hemlock
// Success: tests/feature/success.hml
let result = do_thing();
print(result);  // Expect: expected value

// Failure: tests/feature/failure.hml
do_invalid_thing();  // Should error
```

âœ… **Use descriptive test names**
```
Good: tests/strings/substr_utf8_boundary.hml
Bad:  tests/test1.hml
```

âœ… **Keep tests focused**
- One feature area per file
- Clear setup and assertions
- Minimal code

âœ… **Add comments explaining tricky tests**
```hemlock
// Test that closure captures outer variable by reference
fn outer() {
    let x = 10;
    let f = fn() { return x; };
    x = 20;  // Modify after closure creation
    return f();  // Should return 20, not 10
}
```

âœ… **Test edge cases**
- Empty inputs
- Null values
- Boundary values (min/max)
- Large inputs
- Negative values

### Don'ts

âŒ **Don't skip tests**
- All tests must pass before merging
- Don't comment out failing tests
- Fix the bug or remove the feature

âŒ **Don't write tests that depend on each other**
```hemlock
// BAD: test2.hml depends on test1.hml output
// Tests should be independent
```

âŒ **Don't use random values in tests**
```hemlock
// BAD: Non-deterministic
let x = random();
print(x);  // Can't predict output

// GOOD: Deterministic
let x = 42;
print(x);  // Expect: 42
```

âŒ **Don't test implementation details**
```hemlock
// BAD: Testing internal structure
let obj = { x: 10 };
// Don't check internal field order, capacity, etc.

// GOOD: Testing behavior
print(obj.x);  // Expect: 10
```

âŒ **Don't ignore memory leaks**
- All tests should be valgrind-clean
- Document known/acceptable leaks
- Fix leaks before merging

### Test Maintenance

**When to update tests:**
- Feature behavior changes
- Bug fixes require new test cases
- Edge cases discovered
- Performance improvements

**When to remove tests:**
- Feature removed from language
- Test duplicates existing coverage
- Test was incorrect

**Refactoring tests:**
- Group related tests together
- Extract common setup code
- Use consistent naming
- Keep tests simple and readable

---

## Example Test Session

Here's a complete example of adding a feature with tests:

### Feature: Add `array.first()` method

**1. Write the test first:**

```bash
# Create test file
cat > tests/arrays/first_method.hml << 'EOF'
// Test array.first() method

// Basic case
let arr = [1, 2, 3];
print(arr.first());  // Expect: 1

// Single element
let single = [42];
print(single.first());  // Expect: 42

// Empty array (should error - separate test file)
// let empty = [];
// print(empty.first());  // Error
EOF
```

**2. Run the test (should fail):**

```bash
./hemlock tests/arrays/first_method.hml
# Error: Method 'first' not found on array
```

**3. Implement the feature:**

Edit `src/interpreter/builtins.c`:

```c
// Add array_first method
Value *array_first(Value *self, Value **args, int arg_count)
{
    if (self->array_value->length == 0) {
        fprintf(stderr, "Error: Cannot get first element of empty array\n");
        exit(1);
    }

    return value_copy(&self->array_value->elements[0]);
}

// Register in array method table
// ... add to array method registration
```

**4. Run the test (should pass):**

```bash
./hemlock tests/arrays/first_method.hml
1
42
# Success!
```

**5. Check for memory leaks:**

```bash
valgrind --leak-check=full ./hemlock tests/arrays/first_method.hml
# All heap blocks were freed -- no leaks are possible
```

**6. Run full test suite:**

```bash
make test
# Total: 252 tests (251 + new one)
# Passed: 252
# Failed: 0
```

**7. Commit:**

```bash
git add tests/arrays/first_method.hml src/interpreter/builtins.c
git commit -m "Add array.first() method with tests"
```

---

## Summary

**Remember:**
- Write tests first (TDD)
- Test success and failure cases
- Run all tests before committing
- Check for memory leaks
- Document known issues
- Keep tests simple and focused

**Test quality is just as important as code quality!**



################################################################################
# HPM: GETTING STARTED
################################################################################

--------------------------------------------------------------------------------
## Installation
--------------------------------------------------------------------------------

# Installation

This guide covers how to install hpm on your system.

## Quick Install (Recommended)

Install the latest release with a single command:

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh
```

This automatically:
- Detects your operating system (Linux, macOS)
- Detects your architecture (x86_64, arm64)
- Downloads the appropriate pre-built binary
- Installs to `/usr/local/bin` (or uses sudo if needed)

### Install Options

```bash
# Install to a custom location (no sudo required)
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local

# Install a specific version
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5

# Combine options
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5
```

### Supported Platforms

| Platform | Architecture | Status |
|----------|--------------|--------|
| Linux    | x86_64       | âœ“ Supported |
| macOS    | x86_64       | âœ“ Supported |
| macOS    | arm64 (M1/M2/M3) | âœ“ Supported |
| Linux    | arm64        | Build from source |

## Building from Source

If you prefer to build from source or need a platform not covered by pre-built binaries, follow these instructions.

### Prerequisites

hpm requires [Hemlock](https://github.com/hemlang/hemlock) to be installed first. Follow the Hemlock installation instructions before proceeding.

Verify Hemlock is installed:

```bash
hemlock --version
```

## Installation Methods

### Method 1: Make Install

Build from source and install.

```bash
# Clone the repository
git clone https://github.com/hemlang/hpm.git
cd hpm

# Install to /usr/local/bin (requires sudo)
sudo make install
```

After installation, verify it works:

```bash
hpm --version
```

### Method 2: Custom Location

Install to a custom directory (no sudo required):

```bash
# Clone the repository
git clone https://github.com/hemlang/hpm.git
cd hpm

# Install to ~/.local/bin
make install PREFIX=$HOME/.local

# Or any custom location
make install PREFIX=/opt/hemlock
```

Make sure your custom bin directory is in your PATH:

```bash
# Add to ~/.bashrc or ~/.zshrc
export PATH="$HOME/.local/bin:$PATH"
```

### Method 3: Run Without Installing

You can run hpm directly without installing:

```bash
# Clone the repository
git clone https://github.com/hemlang/hpm.git
cd hpm

# Create local wrapper script
make

# Run from the hpm directory
./hpm --help

# Or run via hemlock directly
hemlock src/main.hml --help
```

### Method 4: Manual Installation

Create your own wrapper script:

```bash
# Clone to a permanent location
git clone https://github.com/hemlang/hpm.git ~/.hpm-source

# Create wrapper script
cat > ~/.local/bin/hpm << 'EOF'
#!/bin/sh
exec hemlock "$HOME/.hpm-source/src/main.hml" "$@"
EOF

chmod +x ~/.local/bin/hpm
```

## Installation Variables

The Makefile supports these variables:

| Variable | Default | Description |
|----------|---------|-------------|
| `PREFIX` | `/usr/local` | Installation prefix |
| `BINDIR` | `$(PREFIX)/bin` | Binary directory |
| `HEMLOCK` | `hemlock` | Path to hemlock interpreter |

Example with custom variables:

```bash
make install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock
```

## How It Works

The installer creates a shell wrapper script that invokes the Hemlock interpreter with the hpm source code:

```bash
#!/bin/sh
exec hemlock "/path/to/hpm/src/main.hml" "$@"
```

This approach:
- Requires no compilation
- Always runs the latest source code
- Works reliably across all platforms

## Updating hpm

To update hpm to the latest version:

```bash
cd /path/to/hpm
git pull origin main

# Re-install if the path changed
sudo make install
```

## Uninstalling

Remove hpm from your system:

```bash
cd /path/to/hpm
sudo make uninstall
```

Or manually remove:

```bash
sudo rm /usr/local/bin/hpm
```

## Verifying Installation

After installation, verify everything works:

```bash
# Check version
hpm --version

# View help
hpm --help

# Test initialization (in an empty directory)
mkdir test-project && cd test-project
hpm init --yes
cat package.json
```

## Troubleshooting

### "hemlock: command not found"

Hemlock is not installed or not in your PATH. Install Hemlock first:

```bash
# Check if hemlock exists
which hemlock

# If not found, install Hemlock from https://github.com/hemlang/hemlock
```

### "Permission denied"

Use sudo for system-wide installation, or install to a user directory:

```bash
# Option 1: Use sudo
sudo make install

# Option 2: Install to user directory
make install PREFIX=$HOME/.local
```

### "hpm: command not found" after installation

Your PATH may not include the installation directory:

```bash
# Check where hpm was installed
ls -la /usr/local/bin/hpm

# Add to PATH if using custom location
export PATH="$HOME/.local/bin:$PATH"
```

## Platform-Specific Notes

### Linux

Standard installation works on all Linux distributions. Some distributions may require:

```bash
# Debian/Ubuntu: Ensure build essentials
sudo apt-get install build-essential git

# Fedora/RHEL
sudo dnf install make git
```

### macOS

Standard installation works. If using Homebrew:

```bash
# Ensure Xcode command line tools
xcode-select --install
```

### Windows (WSL)

hpm works in Windows Subsystem for Linux:

```bash
# In WSL terminal
git clone https://github.com/hemlang/hpm.git
cd hpm
make install PREFIX=$HOME/.local
```

## Next Steps

After installation:

1. [Quick Start](#hpm-installation-quick-start) - Create your first project
2. [Command Reference](#hpm-installation-commands) - Learn all commands
3. [Configuration](#hpm-installation-configuration) - Configure hpm


--------------------------------------------------------------------------------
## Project Setup
--------------------------------------------------------------------------------

# Project Setup

Complete guide for setting up Hemlock projects with hpm.

## Starting a New Project

### Basic Setup

Create a new project from scratch:

```bash
# Create project directory
mkdir my-project
cd my-project

# Initialize package.json
hpm init

# Create directory structure
mkdir -p src test
```

### Project Templates

Here are common project structures for different use cases:

#### Library Package

For reusable libraries:

```
my-library/
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ LICENSE
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.hml          # Main entry, exports public API
â”‚   â”œâ”€â”€ core.hml           # Core functionality
â”‚   â”œâ”€â”€ utils.hml          # Utility functions
â”‚   â””â”€â”€ types.hml          # Type definitions
â””â”€â”€ test/
    â”œâ”€â”€ framework.hml      # Test framework
    â”œâ”€â”€ run.hml            # Test runner
    â””â”€â”€ test_core.hml      # Tests
```

**package.json:**

```json
{
  "name": "yourusername/my-library",
  "version": "1.0.0",
  "description": "A reusable Hemlock library",
  "main": "src/index.hml",
  "scripts": {
    "test": "hemlock test/run.hml"
  },
  "dependencies": {},
  "devDependencies": {}
}
```

#### Application

For standalone applications:

```
my-app/
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.hml           # Application entry point
â”‚   â”œâ”€â”€ config.hml         # Configuration
â”‚   â”œâ”€â”€ commands/          # CLI commands
â”‚   â”‚   â”œâ”€â”€ index.hml
â”‚   â”‚   â””â”€â”€ run.hml
â”‚   â””â”€â”€ lib/               # Internal libraries
â”‚       â””â”€â”€ utils.hml
â”œâ”€â”€ test/
â”‚   â””â”€â”€ run.hml
â””â”€â”€ data/                  # Data files
```

**package.json:**

```json
{
  "name": "yourusername/my-app",
  "version": "1.0.0",
  "description": "A Hemlock application",
  "main": "src/main.hml",
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc"
  },
  "dependencies": {
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {}
}
```

#### Web Application

For web servers:

```
my-web-app/
â”œâ”€â”€ package.json
â”œâ”€â”€ README.md
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.hml           # Server entry point
â”‚   â”œâ”€â”€ routes/            # Route handlers
â”‚   â”‚   â”œâ”€â”€ index.hml
â”‚   â”‚   â”œâ”€â”€ api.hml
â”‚   â”‚   â””â”€â”€ auth.hml
â”‚   â”œâ”€â”€ middleware/        # Middleware
â”‚   â”‚   â”œâ”€â”€ index.hml
â”‚   â”‚   â””â”€â”€ auth.hml
â”‚   â”œâ”€â”€ models/            # Data models
â”‚   â”‚   â””â”€â”€ user.hml
â”‚   â””â”€â”€ services/          # Business logic
â”‚       â””â”€â”€ user.hml
â”œâ”€â”€ test/
â”‚   â””â”€â”€ run.hml
â”œâ”€â”€ static/                # Static files
â”‚   â”œâ”€â”€ css/
â”‚   â””â”€â”€ js/
â””â”€â”€ views/                 # Templates
    â””â”€â”€ index.hml
```

**package.json:**

```json
{
  "name": "yourusername/my-web-app",
  "version": "1.0.0",
  "description": "A Hemlock web application",
  "main": "src/main.hml",
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml"
  },
  "dependencies": {
    "hemlang/sprout": "^2.0.0",
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  }
}
```

## The package.json File

### Required Fields

```json
{
  "name": "owner/repo",
  "version": "1.0.0"
}
```

### All Fields

```json
{
  "name": "yourusername/my-package",
  "version": "1.0.0",
  "description": "Package description",
  "author": "Your Name <you@example.com>",
  "license": "MIT",
  "repository": "https://github.com/yourusername/my-package",
  "homepage": "https://yourusername.github.io/my-package",
  "bugs": "https://github.com/yourusername/my-package/issues",
  "main": "src/index.hml",
  "keywords": ["utility", "parser"],
  "dependencies": {
    "owner/package": "^1.0.0"
  },
  "devDependencies": {
    "owner/test-lib": "^1.0.0"
  },
  "scripts": {
    "start": "hemlock src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc"
  },
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ],
  "native": {
    "requires": ["libcurl", "openssl"]
  }
}
```

### Field Reference

| Field | Type | Description |
|-------|------|-------------|
| `name` | string | Package name in owner/repo format (required) |
| `version` | string | Semantic version (required) |
| `description` | string | Short description |
| `author` | string | Author name and email |
| `license` | string | License identifier (MIT, Apache-2.0, etc.) |
| `repository` | string | Repository URL |
| `homepage` | string | Project homepage |
| `bugs` | string | Issue tracker URL |
| `main` | string | Entry point file (default: src/index.hml) |
| `keywords` | array | Search keywords |
| `dependencies` | object | Runtime dependencies |
| `devDependencies` | object | Development dependencies |
| `scripts` | object | Named scripts |
| `files` | array | Files to include when publishing |
| `native` | object | Native library requirements |

## The package-lock.json File

The lock file is automatically generated and should be committed to version control. It ensures reproducible installs.

```json
{
  "lockVersion": 1,
  "hemlock": "1.0.0",
  "dependencies": {
    "hemlang/sprout": {
      "version": "2.1.0",
      "resolved": "https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz",
      "integrity": "sha256-abc123...",
      "dependencies": {
        "hemlang/router": "^1.5.0"
      }
    },
    "hemlang/router": {
      "version": "1.5.0",
      "resolved": "https://github.com/hemlang/router/archive/v1.5.0.tar.gz",
      "integrity": "sha256-def456...",
      "dependencies": {}
    }
  }
}
```

### Lock File Best Practices

- **Commit** package-lock.json to version control
- **Don't edit** manually - it's auto-generated
- **Run `hpm install`** after pulling changes
- **Delete and regenerate** if corrupted:
  ```bash
  rm package-lock.json
  hpm install
  ```

## The hem_modules Directory

Installed packages are stored in `hem_modules/`:

```
hem_modules/
â”œâ”€â”€ hemlang/
â”‚   â”œâ”€â”€ sprout/
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â””â”€â”€ src/
â”‚   â””â”€â”€ router/
â”‚       â”œâ”€â”€ package.json
â”‚       â””â”€â”€ src/
â””â”€â”€ alice/
    â””â”€â”€ http-client/
        â”œâ”€â”€ package.json
        â””â”€â”€ src/
```

### hem_modules Best Practices

- **Add to .gitignore** - don't commit dependencies
- **Don't modify** - changes will be overwritten
- **Delete to reinstall fresh**:
  ```bash
  rm -rf hem_modules
  hpm install
  ```

## .gitignore

Recommended .gitignore for Hemlock projects:

```gitignore
# Dependencies
hem_modules/

# Build output
dist/
*.hmlc

# IDE files
.idea/
.vscode/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Environment
.env
.env.local

# Test coverage
coverage/
```

## Working with Dependencies

### Adding Dependencies

```bash
# Add runtime dependency
hpm install hemlang/json

# Add with version constraint
hpm install hemlang/sprout@^2.0.0

# Add dev dependency
hpm install hemlang/test-utils --dev
```

### Importing Dependencies

```hemlock
// Import from package (uses "main" entry)
import { parse, stringify } from "hemlang/json";

// Import from subpath
import { Router } from "hemlang/sprout/router";

// Import standard library
import { HashMap } from "@stdlib/collections";
import { readFile, writeFile } from "@stdlib/fs";
```

### Import Resolution

hpm resolves imports in this order:

1. **Standard library**: `@stdlib/*` imports built-in modules
2. **Package root**: `owner/repo` uses the `main` field
3. **Subpath**: `owner/repo/path` checks:
   - `hem_modules/owner/repo/path.hml`
   - `hem_modules/owner/repo/path/index.hml`
   - `hem_modules/owner/repo/src/path.hml`
   - `hem_modules/owner/repo/src/path/index.hml`

## Scripts

### Defining Scripts

Add scripts to package.json:

```json
{
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "test:unit": "hemlock test/unit/run.hml",
    "test:integration": "hemlock test/integration/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc",
    "clean": "rm -rf dist hem_modules",
    "lint": "hemlock-lint src/",
    "format": "hemlock-fmt src/"
  }
}
```

### Running Scripts

```bash
hpm run start
hpm run dev
hpm run build

# Shorthand for test
hpm test

# Pass arguments
hpm run test -- --verbose --filter=unit
```

### Script Naming Conventions

| Script | Purpose |
|--------|---------|
| `start` | Run the application |
| `dev` | Run in development mode |
| `test` | Run all tests |
| `build` | Build for production |
| `clean` | Remove generated files |
| `lint` | Check code style |
| `format` | Format code |

## Development Workflow

### Initial Setup

```bash
# Clone project
git clone https://github.com/yourusername/my-project.git
cd my-project

# Install dependencies
hpm install

# Run tests
hpm test

# Start development
hpm run dev
```

### Daily Workflow

```bash
# Pull latest changes
git pull

# Install any new dependencies
hpm install

# Make changes...

# Run tests
hpm test

# Commit
git add .
git commit -m "Add feature"
git push
```

### Adding a New Feature

```bash
# Create feature branch
git checkout -b feature/new-feature

# Add new dependency if needed
hpm install hemlang/new-lib

# Implement feature...

# Test
hpm test

# Commit and push
git add .
git commit -m "Add new feature"
git push -u origin feature/new-feature
```

## Environment-Specific Configuration

### Using Environment Variables

```hemlock
import { getenv } from "@stdlib/env";

let db_host = getenv("DATABASE_HOST") ?? "localhost";
let api_key = getenv("API_KEY") ?? "";

if api_key == "" {
    print("Warning: API_KEY not set");
}
```

### Configuration File

**config.hml:**

```hemlock
import { getenv } from "@stdlib/env";

export let config = {
    environment: getenv("HEMLOCK_ENV") ?? "development",
    database: {
        host: getenv("DB_HOST") ?? "localhost",
        port: int(getenv("DB_PORT") ?? "5432"),
        name: getenv("DB_NAME") ?? "myapp"
    },
    server: {
        port: int(getenv("PORT") ?? "3000"),
        host: getenv("HOST") ?? "0.0.0.0"
    }
};

export fn is_production(): bool {
    return config.environment == "production";
}
```

## See Also

- [Quick Start](#hpm-project-setup-quick-start) - Get started quickly
- [Commands](#hpm-project-setup-commands) - Command reference
- [Creating Packages](#hpm-project-setup-creating-packages) - Publishing packages
- [Configuration](#hpm-project-setup-configuration) - hpm configuration


--------------------------------------------------------------------------------
## Quick Start
--------------------------------------------------------------------------------

# Quick Start

Get up and running with hpm in 5 minutes.

## Install hpm

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh
```

For more installation options, see the [Installation Guide](#hpm-quick-start-installation).

## Create a New Project

Start by creating a new directory and initializing a package:

```bash
mkdir my-project
cd my-project
hpm init
```

You'll be prompted for project details:

```
Package name (owner/repo): myname/my-project
Version (1.0.0):
Description: My awesome Hemlock project
Author: Your Name <you@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

Use `--yes` to accept all defaults:

```bash
hpm init --yes
```

## Project Structure

Create the basic project structure:

```
my-project/
â”œâ”€â”€ package.json        # Project manifest
â”œâ”€â”€ src/
â”‚   â””â”€â”€ index.hml      # Main entry point
â””â”€â”€ test/
    â””â”€â”€ test.hml       # Tests
```

Create your main file:

```bash
mkdir -p src test
```

**src/index.hml:**
```hemlock
// Main entry point
export fn greet(name: string): string {
    return "Hello, " + name + "!";
}

export fn main() {
    print(greet("World"));
}
```

## Install Dependencies

Search for packages on GitHub (packages use `owner/repo` format):

```bash
# Install a package
hpm install hemlang/sprout

# Install with version constraint
hpm install hemlang/json@^1.0.0

# Install as dev dependency
hpm install hemlang/test-utils --dev
```

After installation, your project structure includes `hem_modules/`:

```
my-project/
â”œâ”€â”€ package.json
â”œâ”€â”€ package-lock.json   # Lock file (auto-generated)
â”œâ”€â”€ hem_modules/        # Installed packages
â”‚   â””â”€â”€ hemlang/
â”‚       â””â”€â”€ sprout/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ index.hml
â””â”€â”€ test/
    â””â”€â”€ test.hml
```

## Use Installed Packages

Import packages using their GitHub path:

```hemlock
// Import from installed package
import { app, router } from "hemlang/sprout";
import { parse, stringify } from "hemlang/json";

// Import from subpath
import { middleware } from "hemlang/sprout/middleware";

// Standard library (built-in)
import { HashMap } from "@stdlib/collections";
import { readFile } from "@stdlib/fs";
```

## Add Scripts

Add scripts to your `package.json`:

```json
{
  "name": "myname/my-project",
  "version": "1.0.0",
  "scripts": {
    "start": "hemlock src/index.hml",
    "test": "hemlock test/test.hml",
    "build": "hemlock --bundle src/index.hml -o dist/app.hmlc"
  }
}
```

Run scripts with `hpm run`:

```bash
hpm run start
hpm run build

# Shorthand for test
hpm test
```

## Common Workflows

### Installing All Dependencies

When you clone a project with a `package.json`:

```bash
git clone https://github.com/someone/project.git
cd project
hpm install
```

### Updating Dependencies

Update all packages to latest versions within constraints:

```bash
hpm update
```

Update a specific package:

```bash
hpm update hemlang/sprout
```

### Viewing Installed Packages

List all installed packages:

```bash
hpm list
```

Output shows the dependency tree:

```
my-project@1.0.0
â”œâ”€â”€ hemlang/sprout@2.1.0
â”‚   â””â”€â”€ hemlang/router@1.5.0
â””â”€â”€ hemlang/json@1.2.3
```

### Checking for Updates

See which packages have newer versions:

```bash
hpm outdated
```

### Removing a Package

```bash
hpm uninstall hemlang/sprout
```

## Example: Web Application

Here's a complete example using a web framework:

**package.json:**
```json
{
  "name": "myname/my-web-app",
  "version": "1.0.0",
  "description": "A web application",
  "main": "src/index.hml",
  "dependencies": {
    "hemlang/sprout": "^2.0.0"
  },
  "scripts": {
    "start": "hemlock src/index.hml",
    "dev": "hemlock --watch src/index.hml"
  }
}
```

**src/index.hml:**
```hemlock
import { App, Router } from "hemlang/sprout";

fn main() {
    let app = App.new();
    let router = Router.new();

    router.get("/", fn(req, res) {
        res.send("Hello, World!");
    });

    router.get("/api/status", fn(req, res) {
        res.json({ status: "ok" });
    });

    app.use(router);
    app.listen(3000);

    print("Server running on http://localhost:3000");
}
```

Run the application:

```bash
hpm install
hpm run start
```

## Next Steps

- [Command Reference](#hpm-quick-start-commands) - Learn all hpm commands
- [Creating Packages](#hpm-quick-start-creating-packages) - Publish your own packages
- [Configuration](#hpm-quick-start-configuration) - Configure hpm and GitHub tokens
- [Project Setup](#hpm-quick-start-project-setup) - Detailed project configuration



################################################################################
# HPM: USER GUIDE
################################################################################

--------------------------------------------------------------------------------
## Commands
--------------------------------------------------------------------------------

# Command Reference

Complete reference for all hpm commands.

## Global Options

These options work with any command:

| Option | Description |
|--------|-------------|
| `--help`, `-h` | Show help message |
| `--version`, `-v` | Show hpm version |
| `--verbose` | Show detailed output |

## Commands

### hpm init

Create a new `package.json` file.

```bash
hpm init        # Interactive mode
hpm init --yes  # Accept all defaults
hpm init -y     # Short form
```

**Options:**

| Option | Description |
|--------|-------------|
| `--yes`, `-y` | Accept default values for all prompts |

**Interactive prompts:**
- Package name (owner/repo format)
- Version (default: 1.0.0)
- Description
- Author
- License (default: MIT)
- Main file (default: src/index.hml)

**Example:**

```bash
$ hpm init
Package name (owner/repo): alice/my-lib
Version (1.0.0):
Description: A utility library
Author: Alice <alice@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

---

### hpm install

Install dependencies or add new packages.

```bash
hpm install                           # Install all from package.json
hpm install owner/repo                # Add and install package
hpm install owner/repo@^1.0.0        # With version constraint
hpm install owner/repo --dev         # As dev dependency
hpm i owner/repo                      # Short form
```

**Options:**

| Option | Description |
|--------|-------------|
| `--dev`, `-D` | Add to devDependencies |
| `--verbose` | Show detailed progress |
| `--dry-run` | Preview without installing |
| `--offline` | Install from cache only (no network) |
| `--parallel` | Enable parallel downloads (experimental) |

**Version constraint syntax:**

| Syntax | Example | Meaning |
|--------|---------|---------|
| (none) | `owner/repo` | Latest version |
| Exact | `owner/repo@1.2.3` | Exactly 1.2.3 |
| Caret | `owner/repo@^1.2.3` | >=1.2.3 <2.0.0 |
| Tilde | `owner/repo@~1.2.3` | >=1.2.3 <1.3.0 |
| Range | `owner/repo@>=1.0.0` | At least 1.0.0 |

**Examples:**

```bash
# Install all dependencies
hpm install

# Install specific package
hpm install hemlang/json

# Install with version constraint
hpm install hemlang/sprout@^2.0.0

# Install as dev dependency
hpm install hemlang/test-utils --dev

# Preview what would be installed
hpm install hemlang/sprout --dry-run

# Verbose output
hpm install --verbose

# Install from cache only (offline)
hpm install --offline
```

**Output:**

```
Installing dependencies...
  + hemlang/sprout@2.1.0
  + hemlang/router@1.5.0 (dependency of hemlang/sprout)

Installed 2 packages in 1.2s
```

---

### hpm uninstall

Remove a package.

```bash
hpm uninstall owner/repo
hpm rm owner/repo          # Short form
hpm remove owner/repo      # Alternative
```

**Examples:**

```bash
hpm uninstall hemlang/sprout
```

**Output:**

```
Removed hemlang/sprout@2.1.0
Updated package.json
Updated package-lock.json
```

---

### hpm update

Update packages to latest versions within constraints.

```bash
hpm update              # Update all packages
hpm update owner/repo   # Update specific package
hpm up owner/repo       # Short form
```

**Options:**

| Option | Description |
|--------|-------------|
| `--verbose` | Show detailed progress |
| `--dry-run` | Preview without updating |

**Examples:**

```bash
# Update all packages
hpm update

# Update specific package
hpm update hemlang/sprout

# Preview updates
hpm update --dry-run
```

**Output:**

```
Updating dependencies...
  hemlang/sprout: 2.0.0 â†’ 2.1.0
  hemlang/router: 1.4.0 â†’ 1.5.0

Updated 2 packages
```

---

### hpm list

Show installed packages.

```bash
hpm list              # Show full dependency tree
hpm list --depth=0    # Direct dependencies only
hpm list --depth=1    # One level of transitive deps
hpm ls                # Short form
```

**Options:**

| Option | Description |
|--------|-------------|
| `--depth=N` | Limit tree depth (default: all) |

**Examples:**

```bash
$ hpm list
my-project@1.0.0
â”œâ”€â”€ hemlang/sprout@2.1.0
â”‚   â”œâ”€â”€ hemlang/router@1.5.0
â”‚   â””â”€â”€ hemlang/middleware@1.2.0
â”œâ”€â”€ hemlang/json@1.2.3
â””â”€â”€ hemlang/test-utils@1.0.0 (dev)

$ hpm list --depth=0
my-project@1.0.0
â”œâ”€â”€ hemlang/sprout@2.1.0
â”œâ”€â”€ hemlang/json@1.2.3
â””â”€â”€ hemlang/test-utils@1.0.0 (dev)
```

---

### hpm outdated

Show packages with newer versions available.

```bash
hpm outdated
```

**Output:**

```
Package            Current  Wanted  Latest
hemlang/sprout     2.0.0    2.0.5   2.1.0
hemlang/router     1.4.0    1.4.2   1.5.0
```

- **Current**: Installed version
- **Wanted**: Highest version matching constraint
- **Latest**: Latest available version

---

### hpm run

Execute a script from package.json.

```bash
hpm run <script>
hpm run <script> -- <args>
```

**Examples:**

Given this package.json:

```json
{
  "scripts": {
    "start": "hemlock src/index.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/index.hml -o dist/app.hmlc"
  }
}
```

Run scripts:

```bash
hpm run start
hpm run test
hpm run build

# Pass arguments to script
hpm run test -- --verbose
```

---

### hpm test

Shorthand for `hpm run test`.

```bash
hpm test
hpm test -- --verbose
```

Equivalent to:

```bash
hpm run test
```

---

### hpm why

Explain why a package is installed (show dependency chain).

```bash
hpm why owner/repo
```

**Example:**

```bash
$ hpm why hemlang/router

hemlang/router@1.5.0 is installed because:

my-project@1.0.0
â””â”€â”€ hemlang/sprout@2.1.0
    â””â”€â”€ hemlang/router@1.5.0
```

---

### hpm cache

Manage the global package cache.

```bash
hpm cache list    # List cached packages
hpm cache clean   # Clear all cached packages
```

**Subcommands:**

| Subcommand | Description |
|------------|-------------|
| `list` | Show all cached packages and sizes |
| `clean` | Remove all cached packages |

**Examples:**

```bash
$ hpm cache list
Cached packages in ~/.hpm/cache:

hemlang/sprout
  2.0.0 (1.2 MB)
  2.1.0 (1.3 MB)
hemlang/router
  1.5.0 (450 KB)

Total: 2.95 MB

$ hpm cache clean
Cleared cache (2.95 MB freed)
```

---

## Command Shortcuts

For convenience, several commands have short aliases:

| Command | Shortcuts |
|---------|-----------|
| `install` | `i` |
| `uninstall` | `rm`, `remove` |
| `list` | `ls` |
| `update` | `up` |

**Examples:**

```bash
hpm i hemlang/sprout        # hpm install hemlang/sprout
hpm rm hemlang/sprout       # hpm uninstall hemlang/sprout
hpm ls                      # hpm list
hpm up                      # hpm update
```

---

## Exit Codes

hpm uses specific exit codes to indicate different error conditions:

| Code | Meaning |
|------|---------|
| 0 | Success |
| 1 | Dependency conflict |
| 2 | Package not found |
| 3 | Version not found |
| 4 | Network error |
| 5 | Invalid package.json |
| 6 | Integrity check failed |
| 7 | GitHub rate limit exceeded |
| 8 | Circular dependency |

Use exit codes in scripts:

```bash
hpm install
if [ $? -ne 0 ]; then
    echo "Installation failed"
    exit 1
fi
```

---

## Environment Variables

hpm respects these environment variables:

| Variable | Description |
|----------|-------------|
| `GITHUB_TOKEN` | GitHub API token for authentication |
| `HPM_CACHE_DIR` | Override cache directory location |
| `HOME` | User home directory (for config/cache) |

**Examples:**

```bash
# Use GitHub token for higher rate limits
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Use custom cache directory
export HPM_CACHE_DIR=/tmp/hpm-cache
hpm install
```

---

## See Also

- [Configuration](#hpm-commands-configuration) - Configuration files
- [Package Specification](#hpm-commands-package-spec) - package.json format
- [Troubleshooting](#hpm-commands-troubleshooting) - Common issues


--------------------------------------------------------------------------------
## Configuration
--------------------------------------------------------------------------------

# Configuration

This guide covers all configuration options for hpm.

## Overview

hpm can be configured through:

1. **Environment variables** - For runtime settings
2. **Global config file** - `~/.hpm/config.json`
3. **Project files** - `package.json` and `package-lock.json`

## Environment Variables

### GITHUB_TOKEN

GitHub API token for authentication.

```bash
export GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx
```

**Benefits of authentication:**
- Higher API rate limits (5000 vs 60 requests/hour)
- Access to private repositories
- Faster dependency resolution

**Creating a token:**

1. Go to GitHub â†’ Settings â†’ Developer settings â†’ Personal access tokens
2. Click "Generate new token (classic)"
3. Select scopes:
   - `repo` - For private repository access
   - `read:packages` - For GitHub Packages (if used)
4. Generate and copy the token

### HPM_CACHE_DIR

Override the default cache directory.

```bash
export HPM_CACHE_DIR=/custom/cache/path
```

Default: `~/.hpm/cache`

**Use cases:**
- CI/CD systems with custom cache locations
- Shared cache across projects
- Temporary cache for isolated builds

### HOME

User home directory. Used to locate:
- Config directory: `$HOME/.hpm/`
- Cache directory: `$HOME/.hpm/cache/`

Usually set by the system; override only if needed.

### Example .bashrc / .zshrc

```bash
# GitHub authentication (recommended)
export GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx

# Custom cache location (optional)
# export HPM_CACHE_DIR=/path/to/cache

# Add hpm to PATH (if using custom install location)
export PATH="$HOME/.local/bin:$PATH"
```

## Global Configuration File

### Location

`~/.hpm/config.json`

### Format

```json
{
  "github_token": "ghp_xxxxxxxxxxxxxxxxxxxx"
}
```

### Creating the Config File

```bash
# Create config directory
mkdir -p ~/.hpm

# Create config file
cat > ~/.hpm/config.json << 'EOF'
{
  "github_token": "ghp_your_token_here"
}
EOF

# Secure the file (recommended)
chmod 600 ~/.hpm/config.json
```

### Token Priority

If both are set, environment variable takes precedence:

1. `GITHUB_TOKEN` environment variable (highest)
2. `~/.hpm/config.json` `github_token` field
3. No authentication (default)

## Directory Structure

### Global Directories

```
~/.hpm/
â”œâ”€â”€ config.json          # Global configuration
â””â”€â”€ cache/               # Package cache
    â””â”€â”€ owner/
        â””â”€â”€ repo/
            â””â”€â”€ 1.0.0.tar.gz
```

### Project Directories

```
my-project/
â”œâ”€â”€ package.json         # Project manifest
â”œâ”€â”€ package-lock.json    # Dependency lock file
â”œâ”€â”€ hem_modules/         # Installed packages
â”‚   â””â”€â”€ owner/
â”‚       â””â”€â”€ repo/
â”‚           â”œâ”€â”€ package.json
â”‚           â””â”€â”€ src/
â”œâ”€â”€ src/                 # Source code
â””â”€â”€ test/                # Tests
```

## Package Cache

### Location

Default: `~/.hpm/cache/`

Override with: `HPM_CACHE_DIR` environment variable

### Structure

```
~/.hpm/cache/
â”œâ”€â”€ hemlang/
â”‚   â”œâ”€â”€ sprout/
â”‚   â”‚   â”œâ”€â”€ 2.0.0.tar.gz
â”‚   â”‚   â””â”€â”€ 2.1.0.tar.gz
â”‚   â””â”€â”€ router/
â”‚       â””â”€â”€ 1.5.0.tar.gz
â””â”€â”€ alice/
    â””â”€â”€ http-client/
        â””â”€â”€ 1.0.0.tar.gz
```

### Managing the Cache

```bash
# View cached packages
hpm cache list

# Clear entire cache
hpm cache clean
```

### Cache Behavior

- Packages are cached after first download
- Subsequent installs use cached versions
- Use `--offline` to install only from cache
- Cache is shared across all projects

## GitHub API Rate Limits

### Without Authentication

- **60 requests per hour** per IP address
- Shared across all unauthenticated users on same IP
- Quickly exhausted in CI/CD or with many dependencies

### With Authentication

- **5000 requests per hour** per authenticated user
- Personal rate limit, not shared

### Handling Rate Limits

hpm automatically:
- Retries with exponential backoff (1s, 2s, 4s, 8s)
- Reports rate limit errors with exit code 7
- Suggests authentication if rate limited

**Solutions when rate limited:**

```bash
# Option 1: Authenticate with GitHub token
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Option 2: Wait for rate limit reset
# (Limits reset hourly)

# Option 3: Use offline mode (if packages are cached)
hpm install --offline
```

## Offline Mode

Install packages without network access:

```bash
hpm install --offline
```

**Requirements:**
- All packages must be in cache
- Lock file must exist with exact versions

**Use cases:**
- Air-gapped environments
- Faster CI/CD builds (with warm cache)
- Avoiding rate limits

## CI/CD Configuration

### GitHub Actions

```yaml
name: CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Setup Hemlock
      run: |
        # Install Hemlock (adjust based on your setup)
        curl -sSL https://hemlock.dev/install.sh | sh

    - name: Cache hpm packages
      uses: actions/cache@v3
      with:
        path: ~/.hpm/cache
        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-hpm-

    - name: Install dependencies
      run: hpm install
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Run tests
      run: hpm test
```

### GitLab CI

```yaml
stages:
  - build
  - test

variables:
  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache

cache:
  paths:
    - .hpm-cache/
  key: $CI_COMMIT_REF_SLUG

build:
  stage: build
  script:
    - hpm install
  artifacts:
    paths:
      - hem_modules/

test:
  stage: test
  script:
    - hpm test
```

### Docker

**Dockerfile:**

```dockerfile
FROM hemlock:latest

WORKDIR /app

# Copy package files first (for layer caching)
COPY package.json package-lock.json ./

# Install dependencies
RUN hpm install

# Copy source code
COPY . .

# Run application
CMD ["hemlock", "src/main.hml"]
```

**docker-compose.yml:**

```yaml
version: '3.8'

services:
  app:
    build: .
    environment:
      - GITHUB_TOKEN=${GITHUB_TOKEN}
    volumes:
      - hpm-cache:/root/.hpm/cache

volumes:
  hpm-cache:
```

## Proxy Configuration

For environments behind a proxy, configure at the system level:

```bash
export HTTP_PROXY=http://proxy.example.com:8080
export HTTPS_PROXY=http://proxy.example.com:8080
export NO_PROXY=localhost,127.0.0.1

hpm install
```

## Security Best Practices

### Token Security

1. **Never commit tokens** to version control
2. **Use environment variables** in CI/CD
3. **Restrict token scopes** to minimum required
4. **Rotate tokens** regularly
5. **Secure config file**:
   ```bash
   chmod 600 ~/.hpm/config.json
   ```

### Private Repositories

To access private packages:

1. Create token with `repo` scope
2. Configure authentication (env var or config file)
3. Ensure token has access to the repository

```bash
# Test access
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install yourorg/private-package
```

## Troubleshooting Configuration

### Verify Configuration

```bash
# Check if token is set
echo $GITHUB_TOKEN | head -c 10

# Check config file
cat ~/.hpm/config.json

# Check cache directory
ls -la ~/.hpm/cache/

# Test with verbose output
hpm install --verbose
```

### Common Issues

**"GitHub rate limit exceeded"**
- Set up authentication with `GITHUB_TOKEN`
- Wait for rate limit reset
- Use `--offline` if packages are cached

**"Permission denied" on cache**
```bash
# Fix cache permissions
chmod -R u+rw ~/.hpm/cache
```

**"Config file not found"**
```bash
# Create config directory
mkdir -p ~/.hpm
touch ~/.hpm/config.json
```

## See Also

- [Installation](#hpm-configuration-installation) - Installing hpm
- [Troubleshooting](#hpm-configuration-troubleshooting) - Common problems
- [Commands](#hpm-configuration-commands) - Command reference


--------------------------------------------------------------------------------
## Troubleshooting
--------------------------------------------------------------------------------

# Troubleshooting

Solutions to common hpm issues.

## Installation Issues

### "hemlock: command not found"

**Cause:** Hemlock is not installed or not in PATH.

**Solution:**

```bash
# Check if hemlock exists
which hemlock

# If not found, install Hemlock first
# Visit: https://github.com/hemlang/hemlock

# After installation, verify
hemlock --version
```

### "hpm: command not found"

**Cause:** hpm is not installed or not in PATH.

**Solution:**

```bash
# Check where hpm is installed
ls -la /usr/local/bin/hpm
ls -la ~/.local/bin/hpm

# If using custom location, add to PATH
export PATH="$HOME/.local/bin:$PATH"

# Add to ~/.bashrc or ~/.zshrc for persistence
echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc

# Reinstall if needed
cd /path/to/hpm
sudo make install
```

### "Permission denied" during install

**Cause:** No write permission to install directory.

**Solution:**

```bash
# Option 1: Use sudo for system-wide install
sudo make install

# Option 2: Install to user directory (no sudo)
make install PREFIX=$HOME/.local
```

## Dependency Issues

### "Package not found" (exit code 2)

**Cause:** The package doesn't exist on GitHub.

**Solution:**

```bash
# Verify package exists
# Check: https://github.com/owner/repo

# Verify spelling
hpm install hemlang/sprout  # Correct
hpm install hemlan/sprout   # Wrong owner
hpm install hemlang/spout   # Wrong repo

# Check for typos in package.json
cat package.json | grep -A 5 dependencies
```

### "Version not found" (exit code 3)

**Cause:** No release matches the version constraint.

**Solution:**

```bash
# List available versions (check GitHub releases/tags)
# Tags must start with 'v' (e.g., v1.0.0)

# Use a valid version constraint
hpm install owner/repo@^1.0.0

# Try latest version
hpm install owner/repo

# Check available tags on GitHub
# https://github.com/owner/repo/tags
```

### "Dependency conflict" (exit code 1)

**Cause:** Two packages require incompatible versions of a dependency.

**Solution:**

```bash
# See the conflict
hpm install --verbose

# Check what requires the dependency
hpm why conflicting/package

# Solutions:
# 1. Update the conflicting package
hpm update problem/package

# 2. Change version constraints in package.json
# Edit to allow compatible versions

# 3. Remove one of the conflicting packages
hpm uninstall one/package
```

### "Circular dependency" (exit code 8)

**Cause:** Package A depends on B, which depends on A.

**Solution:**

```bash
# Identify the cycle
hpm install --verbose

# This is usually a bug in the packages
# Contact package maintainers

# Workaround: avoid one of the packages
```

## Network Issues

### "Network error" (exit code 4)

**Cause:** Cannot connect to GitHub API.

**Solution:**

```bash
# Check internet connection
ping github.com

# Check if GitHub API is accessible
curl -I https://api.github.com

# Try again (hpm retries automatically)
hpm install

# Use offline mode if packages are cached
hpm install --offline

# Check proxy settings if behind firewall
export HTTPS_PROXY=http://proxy:8080
hpm install
```

### "GitHub rate limit exceeded" (exit code 7)

**Cause:** Too many API requests without authentication.

**Solution:**

```bash
# Option 1: Authenticate with GitHub token (recommended)
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Create token: GitHub â†’ Settings â†’ Developer settings â†’ Personal access tokens

# Option 2: Save token in config file
mkdir -p ~/.hpm
echo '{"github_token": "ghp_xxxxxxxxxxxx"}' > ~/.hpm/config.json

# Option 3: Wait for rate limit reset (resets hourly)

# Option 4: Use offline mode
hpm install --offline
```

### Connection timeout

**Cause:** Slow network or GitHub API issues.

**Solution:**

```bash
# hpm retries automatically with exponential backoff

# Check if GitHub is having issues
# Visit: https://www.githubstatus.com

# Try again later
hpm install

# Use cached packages
hpm install --offline
```

## Package.json Issues

### "Invalid package.json" (exit code 5)

**Cause:** Malformed or missing required fields.

**Solution:**

```bash
# Validate JSON syntax
cat package.json | python -m json.tool

# Check required fields
cat package.json

# Required fields:
# - "name": "owner/repo" format
# - "version": "X.Y.Z" format

# Regenerate if needed
rm package.json
hpm init
```

### "name" format error

**Cause:** Package name not in `owner/repo` format.

**Solution:**

```json
// Wrong
{
  "name": "my-package"
}

// Correct
{
  "name": "yourusername/my-package"
}
```

### "version" format error

**Cause:** Version not in semver format.

**Solution:**

```json
// Wrong
{
  "version": "1.0"
}

// Correct
{
  "version": "1.0.0"
}
```

## Lock File Issues

### Lock file out of sync

**Cause:** package.json modified without running install.

**Solution:**

```bash
# Regenerate lock file
rm package-lock.json
hpm install
```

### Corrupted lock file

**Cause:** Invalid JSON or manual edits.

**Solution:**

```bash
# Check JSON validity
cat package-lock.json | python -m json.tool

# Regenerate
rm package-lock.json
hpm install
```

## hem_modules Issues

### Packages not installing

**Cause:** Various possible issues.

**Solution:**

```bash
# Clean and reinstall
rm -rf hem_modules
hpm install

# Check verbose output
hpm install --verbose
```

### Import not working

**Cause:** Package not properly installed or wrong import path.

**Solution:**

```bash
# Verify package is installed
ls hem_modules/owner/repo/

# Check package.json main field
cat hem_modules/owner/repo/package.json

# Correct import format
import { x } from "owner/repo";          # Uses main entry
import { y } from "owner/repo/subpath";  # Subpath import
```

### "Module not found" error

**Cause:** Import path doesn't resolve to a file.

**Solution:**

```bash
# Check import path
ls hem_modules/owner/repo/src/

# Check for index.hml
ls hem_modules/owner/repo/src/index.hml

# Verify main field in package.json
cat hem_modules/owner/repo/package.json | grep main
```

## Cache Issues

### Cache taking too much space

**Solution:**

```bash
# View cache size
hpm cache list

# Clear cache
hpm cache clean
```

### Cache permissions

**Solution:**

```bash
# Fix permissions
chmod -R u+rw ~/.hpm/cache

# Or remove and reinstall
rm -rf ~/.hpm/cache
hpm install
```

### Using wrong cache

**Solution:**

```bash
# Check cache location
echo $HPM_CACHE_DIR
ls ~/.hpm/cache

# Clear environment variable if incorrect
unset HPM_CACHE_DIR
```

## Script Issues

### "Script not found"

**Cause:** Script name doesn't exist in package.json.

**Solution:**

```bash
# List available scripts
cat package.json | grep -A 20 scripts

# Check spelling
hpm run test    # Correct
hpm run tests   # Wrong if script is named "test"
```

### Script fails

**Cause:** Error in the script command.

**Solution:**

```bash
# Run command directly to see error
hemlock test/run.hml

# Check script definition
cat package.json | grep test
```

## Debugging

### Enable verbose output

```bash
hpm install --verbose
```

### Check hpm version

```bash
hpm --version
```

### Check hemlock version

```bash
hemlock --version
```

### Dry run

Preview without making changes:

```bash
hpm install --dry-run
```

### Clean slate

Start fresh:

```bash
rm -rf hem_modules package-lock.json
hpm install
```

## Getting Help

### Command help

```bash
hpm --help
hpm install --help
```

### Report issues

If you encounter a bug:

1. Check existing issues: https://github.com/hemlang/hpm/issues
2. Create a new issue with:
   - hpm version (`hpm --version`)
   - Hemlock version (`hemlock --version`)
   - Operating system
   - Steps to reproduce
   - Error message (use `--verbose`)

## Exit Code Reference

| Code | Meaning | Common Solution |
|------|---------|-----------------|
| 0 | Success | - |
| 1 | Dependency conflict | Update or change constraints |
| 2 | Package not found | Check spelling, verify repo exists |
| 3 | Version not found | Check available versions on GitHub |
| 4 | Network error | Check connection, retry |
| 5 | Invalid package.json | Fix JSON syntax and required fields |
| 6 | Integrity check failed | Clear cache, reinstall |
| 7 | GitHub rate limit | Add GITHUB_TOKEN |
| 8 | Circular dependency | Contact package maintainers |

## See Also

- [Installation](#hpm-troubleshooting-installation) - Installation guide
- [Configuration](#hpm-troubleshooting-configuration) - Configuration options
- [Commands](#hpm-troubleshooting-commands) - Command reference



################################################################################
# HPM: PACKAGE DEVELOPMENT
################################################################################

--------------------------------------------------------------------------------
## Creating Packages
--------------------------------------------------------------------------------

# Creating Packages

This guide covers how to create, structure, and publish Hemlock packages.

## Overview

hpm uses GitHub as its package registry. Packages are identified by their GitHub `owner/repo` path, and versions are Git tags. Publishing is simply pushing a tagged release.

## Creating a New Package

### 1. Initialize the Package

Create a new directory and initialize:

```bash
mkdir my-package
cd my-package
hpm init
```

Answer the prompts:

```
Package name (owner/repo): yourusername/my-package
Version (1.0.0):
Description: A useful Hemlock package
Author: Your Name <you@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

### 2. Create the Project Structure

Recommended structure for packages:

```
my-package/
â”œâ”€â”€ package.json          # Package manifest
â”œâ”€â”€ README.md             # Documentation
â”œâ”€â”€ LICENSE               # License file
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.hml         # Main entry point (exports public API)
â”‚   â”œâ”€â”€ utils.hml         # Internal utilities
â”‚   â””â”€â”€ types.hml         # Type definitions
â””â”€â”€ test/
    â”œâ”€â”€ framework.hml     # Test framework
    â””â”€â”€ test_utils.hml    # Tests
```

### 3. Define Your Public API

**src/index.hml** - Main entry point:

```hemlock
// Re-export public API
export { parse, stringify } from "./parser.hml";
export { Config, Options } from "./types.hml";
export { process } from "./processor.hml";

// Direct exports
export fn create(options: Options): Config {
    // Implementation
}

export fn validate(config: Config): bool {
    // Implementation
}
```

### 4. Write Your package.json

Complete package.json example:

```json
{
  "name": "yourusername/my-package",
  "version": "1.0.0",
  "description": "A useful Hemlock package",
  "author": "Your Name <you@example.com>",
  "license": "MIT",
  "repository": "https://github.com/yourusername/my-package",
  "main": "src/index.hml",
  "dependencies": {
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  },
  "scripts": {
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/index.hml -o dist/bundle.hmlc"
  },
  "keywords": ["utility", "parser", "config"],
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ]
}
```

## Package Naming

### Requirements

- Must be in `owner/repo` format
- `owner` should be your GitHub username or organization
- `repo` should be the repository name
- Use lowercase with hyphens for multi-word names

### Good Names

```
hemlang/sprout
alice/http-client
myorg/json-utils
bob/date-formatter
```

### Avoid

```
my-package          # Missing owner
alice/MyPackage     # PascalCase
alice/my_package    # Underscores
```

## Package Structure Best Practices

### Entry Point

The `main` field in package.json specifies the entry point:

```json
{
  "main": "src/index.hml"
}
```

This file should export your public API:

```hemlock
// Export everything users need
export { Parser, parse } from "./parser.hml";
export { Formatter, format } from "./formatter.hml";

// Types
export type { Config, Options } from "./types.hml";
```

### Internal vs Public

Keep internal implementation details private:

```
src/
â”œâ”€â”€ index.hml          # Public: exported API
â”œâ”€â”€ parser.hml         # Public: used by index.hml
â”œâ”€â”€ formatter.hml      # Public: used by index.hml
â””â”€â”€ internal/
    â”œâ”€â”€ helpers.hml    # Private: internal use only
    â””â”€â”€ constants.hml  # Private: internal use only
```

Users import from your package root:

```hemlock
// Good - imports from public API
import { parse, Parser } from "yourusername/my-package";

// Also works - subpath import
import { validate } from "yourusername/my-package/validator";

// Discouraged - accessing internals
import { helper } from "yourusername/my-package/internal/helpers";
```

### Subpath Exports

Support importing from subpaths:

```
src/
â”œâ”€â”€ index.hml              # Main entry
â”œâ”€â”€ parser/
â”‚   â””â”€â”€ index.hml          # yourusername/pkg/parser
â”œâ”€â”€ formatter/
â”‚   â””â”€â”€ index.hml          # yourusername/pkg/formatter
â””â”€â”€ utils/
    â””â”€â”€ index.hml          # yourusername/pkg/utils
```

Users can import:

```hemlock
import { parse } from "yourusername/my-package";           // Main
import { Parser } from "yourusername/my-package/parser";   // Subpath
import { format } from "yourusername/my-package/formatter";
```

## Dependencies

### Adding Dependencies

```bash
# Runtime dependency
hpm install hemlang/json

# Development dependency
hpm install hemlang/test-utils --dev
```

### Dependency Best Practices

1. **Use caret ranges** for most dependencies:
   ```json
   {
     "dependencies": {
       "hemlang/json": "^1.0.0"
     }
   }
   ```

2. **Pin versions** only when necessary (API instability):
   ```json
   {
     "dependencies": {
       "unstable/lib": "1.2.3"
     }
   }
   ```

3. **Avoid overly restrictive ranges**:
   ```json
   // Bad: too restrictive
   "hemlang/json": ">=1.2.3 <1.2.5"

   // Good: allows compatible updates
   "hemlang/json": "^1.2.3"
   ```

4. **Keep dev dependencies separate**:
   ```json
   {
     "dependencies": {
       "hemlang/json": "^1.0.0"
     },
     "devDependencies": {
       "hemlang/test-utils": "^1.0.0"
     }
   }
   ```

## Testing Your Package

### Write Tests

**test/run.hml:**

```hemlock
import { suite, test, assert_eq } from "./framework.hml";
import { parse, stringify } from "../src/index.hml";

fn run_tests() {
    suite("Parser", fn() {
        test("parses valid input", fn() {
            let result = parse("hello");
            assert_eq(result.value, "hello");
        });

        test("handles empty input", fn() {
            let result = parse("");
            assert_eq(result.value, "");
        });
    });

    suite("Stringify", fn() {
        test("stringifies object", fn() {
            let obj = { name: "test" };
            let result = stringify(obj);
            assert_eq(result, '{"name":"test"}');
        });
    });
}

run_tests();
```

### Run Tests

Add a test script:

```json
{
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
```

Run with:

```bash
hpm test
```

## Publishing

### Prerequisites

1. Create a GitHub repository matching your package name
2. Ensure `package.json` is complete and valid
3. All tests pass

### Publishing Process

Publishing is simply pushing a Git tag:

```bash
# 1. Ensure everything is committed
git add .
git commit -m "Prepare v1.0.0 release"

# 2. Create a version tag (must start with 'v')
git tag v1.0.0

# 3. Push code and tags
git push origin main
git push origin v1.0.0
# Or push all tags at once
git push origin main --tags
```

### Version Tags

Tags must follow the format `vX.Y.Z`:

```bash
git tag v1.0.0      # Release
git tag v1.0.1      # Patch
git tag v1.1.0      # Minor
git tag v2.0.0      # Major
git tag v1.0.0-beta.1  # Pre-release
```

### Release Checklist

Before publishing a new version:

1. **Update version** in package.json
2. **Run tests**: `hpm test`
3. **Update CHANGELOG** (if you have one)
4. **Update README** if API changed
5. **Commit changes**
6. **Create tag**
7. **Push to GitHub**

### Automated Example

Create a release script:

```bash
#!/bin/bash
# release.sh - Release a new version

VERSION=$1

if [ -z "$VERSION" ]; then
    echo "Usage: ./release.sh 1.0.0"
    exit 1
fi

# Run tests
hpm test || exit 1

# Update version in package.json
sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json

# Commit and tag
git add package.json
git commit -m "Release v$VERSION"
git tag "v$VERSION"

# Push
git push origin main --tags

echo "Released v$VERSION"
```

## Users Installing Your Package

After publishing, users can install:

```bash
# Latest version
hpm install yourusername/my-package

# Specific version
hpm install yourusername/my-package@1.0.0

# Version constraint
hpm install yourusername/my-package@^1.0.0
```

And import:

```hemlock
import { parse, stringify } from "yourusername/my-package";
```

## Documentation

### README.md

Every package should have a README:

```markdown
# my-package

A brief description of what this package does.

## Installation

\`\`\`bash
hpm install yourusername/my-package
\`\`\`

## Usage

\`\`\`hemlock
import { parse } from "yourusername/my-package";

let result = parse("input");
\`\`\`

## API

### parse(input: string): Result

Parses the input string.

### stringify(obj: any): string

Converts object to string.

## License

MIT
```

### API Documentation

Document all public exports:

```hemlock
/// Parses the input string into a structured Result.
///
/// # Arguments
/// * `input` - The string to parse
///
/// # Returns
/// A Result containing the parsed data or an error
///
/// # Example
/// ```
/// let result = parse("hello world");
/// print(result.value);
/// ```
export fn parse(input: string): Result {
    // Implementation
}
```

## Versioning Guidelines

Follow [Semantic Versioning](https://semver.org/):

- **MAJOR** (1.0.0 â†’ 2.0.0): Breaking changes
- **MINOR** (1.0.0 â†’ 1.1.0): New features, backward compatible
- **PATCH** (1.0.0 â†’ 1.0.1): Bug fixes, backward compatible

### When to Bump

| Change Type | Version Bump |
|-------------|--------------|
| Breaking API change | MAJOR |
| Remove function/type | MAJOR |
| Change function signature | MAJOR |
| Add new function | MINOR |
| Add new feature | MINOR |
| Bug fix | PATCH |
| Documentation update | PATCH |
| Internal refactor | PATCH |

## See Also

- [Package Specification](#hpm-creating-packages-package-spec) - Full package.json reference
- [Versioning](#hpm-creating-packages-versioning) - Semantic versioning details
- [Configuration](#hpm-creating-packages-configuration) - GitHub authentication


--------------------------------------------------------------------------------
## Package Spec
--------------------------------------------------------------------------------

# Package Specification

Complete reference for the `package.json` file format.

## Overview

Every hpm package requires a `package.json` file in the project root. This file defines package metadata, dependencies, and scripts.

## Minimal Example

```json
{
  "name": "owner/repo",
  "version": "1.0.0"
}
```

## Complete Example

```json
{
  "name": "hemlang/example-package",
  "version": "1.2.3",
  "description": "An example Hemlock package",
  "author": "Hemlock Team <team@hemlock.dev>",
  "license": "MIT",
  "repository": "https://github.com/hemlang/example-package",
  "homepage": "https://hemlang.github.io/example-package",
  "bugs": "https://github.com/hemlang/example-package/issues",
  "main": "src/index.hml",
  "keywords": ["example", "utility", "hemlock"],
  "dependencies": {
    "hemlang/json": "^1.0.0",
    "hemlang/http": "^2.1.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  },
  "scripts": {
    "start": "hemlock src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/bundle.hmlc"
  },
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ],
  "native": {
    "requires": ["libcurl", "openssl"]
  }
}
```

## Field Reference

### name (required)

The package name in `owner/repo` format.

```json
{
  "name": "hemlang/sprout"
}
```

**Requirements:**
- Must be in `owner/repo` format
- `owner` should be your GitHub username or organization
- `repo` should be the repository name
- Use lowercase letters, numbers, and hyphens
- Maximum 214 characters total

**Valid names:**
```
hemlang/sprout
alice/http-client
myorg/json-utils
bob123/my-lib
```

**Invalid names:**
```
my-package          # Missing owner
hemlang/My_Package  # Uppercase and underscore
hemlang             # Missing repo
```

### version (required)

The package version following [Semantic Versioning](https://semver.org/).

```json
{
  "version": "1.2.3"
}
```

**Format:** `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`

**Valid versions:**
```
1.0.0
2.1.3
1.0.0-alpha
1.0.0-beta.1
1.0.0-rc.1+build.123
0.1.0
```

### description

Short description of the package.

```json
{
  "description": "A fast JSON parser for Hemlock"
}
```

- Keep it under 200 characters
- Describe what the package does, not how

### author

Package author information.

```json
{
  "author": "Your Name <email@example.com>"
}
```

**Formats accepted:**
```json
"author": "Your Name"
"author": "Your Name <email@example.com>"
"author": "Your Name <email@example.com> (https://website.com)"
```

### license

The license identifier.

```json
{
  "license": "MIT"
}
```

**Common licenses:**
- `MIT` - MIT License
- `Apache-2.0` - Apache License 2.0
- `GPL-3.0` - GNU General Public License v3.0
- `BSD-3-Clause` - BSD 3-Clause License
- `ISC` - ISC License
- `UNLICENSED` - Proprietary/private

Use [SPDX identifiers](https://spdx.org/licenses/) when possible.

### repository

Link to the source repository.

```json
{
  "repository": "https://github.com/hemlang/sprout"
}
```

### homepage

Project homepage URL.

```json
{
  "homepage": "https://sprout.hemlock.dev"
}
```

### bugs

Issue tracker URL.

```json
{
  "bugs": "https://github.com/hemlang/sprout/issues"
}
```

### main

Entry point file for the package.

```json
{
  "main": "src/index.hml"
}
```

**Default:** `src/index.hml`

When users import your package:
```hemlock
import { x } from "owner/repo";
```

hpm loads the file specified in `main`.

**Resolution order for imports:**
1. Exact path: `src/index.hml`
2. With .hml extension: `src/index` â†’ `src/index.hml`
3. Index file: `src/index/` â†’ `src/index/index.hml`

### keywords

Array of keywords for discoverability.

```json
{
  "keywords": ["json", "parser", "utility", "hemlock"]
}
```

- Use lowercase
- Be specific and relevant
- Include language ("hemlock") if appropriate

### dependencies

Runtime dependencies required for the package to work.

```json
{
  "dependencies": {
    "hemlang/json": "^1.0.0",
    "hemlang/http": "~2.1.0",
    "alice/logger": ">=1.0.0 <2.0.0"
  }
}
```

**Key:** Package name (`owner/repo`)
**Value:** Version constraint

**Version constraint syntax:**

| Constraint | Meaning |
|------------|---------|
| `1.2.3` | Exact version |
| `^1.2.3` | >=1.2.3 <2.0.0 |
| `~1.2.3` | >=1.2.3 <1.3.0 |
| `>=1.0.0` | At least 1.0.0 |
| `>=1.0.0 <2.0.0` | Range |
| `*` | Any version |

### devDependencies

Development-only dependencies (testing, building, etc.).

```json
{
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0",
    "hemlang/linter": "^2.0.0"
  }
}
```

Dev dependencies are:
- Installed during development
- Not installed when package is used as a dependency
- Used for testing, building, linting, etc.

### scripts

Named commands that can be run with `hpm run`.

```json
{
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "test:unit": "hemlock test/unit/run.hml",
    "test:integration": "hemlock test/integration/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc",
    "clean": "rm -rf dist hem_modules",
    "lint": "hemlock-lint src/",
    "format": "hemlock-fmt src/"
  }
}
```

**Running scripts:**
```bash
hpm run start
hpm run build
hpm test        # Shorthand for 'hpm run test'
```

**Passing arguments:**
```bash
hpm run test -- --verbose --filter=unit
```

**Common scripts:**

| Script | Purpose |
|--------|---------|
| `start` | Start the application |
| `dev` | Development mode with hot reload |
| `test` | Run tests |
| `build` | Build for production |
| `clean` | Remove build artifacts |
| `lint` | Check code style |
| `format` | Format code |

### files

Files and directories to include when the package is installed.

```json
{
  "files": [
    "src/",
    "lib/",
    "LICENSE",
    "README.md"
  ]
}
```

**Default behavior:** If not specified, includes:
- All files in the repository
- Excludes `.git/`, `node_modules/`, `hem_modules/`

**Use to:**
- Reduce package size
- Exclude test files from distribution
- Include only necessary files

### native

Native library requirements.

```json
{
  "native": {
    "requires": ["libcurl", "openssl", "sqlite3"]
  }
}
```

Documents native dependencies that must be installed on the system.

## Validation

hpm validates package.json on various operations. Common validation errors:

### Missing required fields

```
Error: package.json missing required field: name
```

**Fix:** Add the required field.

### Invalid name format

```
Error: Invalid package name. Must be in owner/repo format.
```

**Fix:** Use `owner/repo` format.

### Invalid version

```
Error: Invalid version "1.0". Must be semver format (X.Y.Z).
```

**Fix:** Use full semver format (`1.0.0`).

### Invalid JSON

```
Error: package.json is not valid JSON
```

**Fix:** Check JSON syntax (commas, quotes, brackets).

## Creating package.json

### Interactive

```bash
hpm init
```

Prompts for each field interactively.

### With Defaults

```bash
hpm init --yes
```

Creates with default values:
```json
{
  "name": "directory-name/directory-name",
  "version": "1.0.0",
  "description": "",
  "author": "",
  "license": "MIT",
  "main": "src/index.hml",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
```

### Manual

Create the file manually:

```bash
cat > package.json << 'EOF'
{
  "name": "yourname/your-package",
  "version": "1.0.0",
  "description": "Your package description",
  "main": "src/index.hml",
  "dependencies": {},
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
EOF
```

## Best Practices

1. **Always specify main** - Don't rely on default
2. **Use caret ranges** - `^1.0.0` for most dependencies
3. **Separate dev dependencies** - Keep test/build deps in devDependencies
4. **Include keywords** - Help users find your package
5. **Document scripts** - Name scripts clearly
6. **Specify license** - Required for open source
7. **Add description** - Help users understand purpose

## See Also

- [Creating Packages](#hpm-package-spec-creating-packages) - Publishing guide
- [Versioning](#hpm-package-spec-versioning) - Version constraints
- [Project Setup](#hpm-package-spec-project-setup) - Project structure


--------------------------------------------------------------------------------
## Versioning
--------------------------------------------------------------------------------

# Versioning

Complete guide to semantic versioning in hpm.

## Semantic Versioning

hpm uses [Semantic Versioning 2.0.0](https://semver.org/) (semver) for package versions.

### Version Format

```
MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]
```

**Examples:**
```
1.0.0           # Release version
2.1.3           # Release version
1.0.0-alpha     # Pre-release
1.0.0-beta.1    # Pre-release with number
1.0.0-rc.1      # Release candidate
1.0.0+20231201  # With build metadata
1.0.0-beta+exp  # Pre-release with build metadata
```

### Version Components

| Component | Description | Example |
|-----------|-------------|---------|
| MAJOR | Breaking changes | `1.0.0` â†’ `2.0.0` |
| MINOR | New features (backward compatible) | `1.0.0` â†’ `1.1.0` |
| PATCH | Bug fixes (backward compatible) | `1.0.0` â†’ `1.0.1` |
| PRERELEASE | Pre-release identifier | `1.0.0-alpha` |
| BUILD | Build metadata (ignored in comparison) | `1.0.0+build123` |

### When to Increment

| Change Type | Increment | Example |
|-------------|-----------|---------|
| Breaking API change | MAJOR | Removing a function |
| Renaming public function | MAJOR | `parse()` â†’ `decode()` |
| Changing function signature | MAJOR | Adding required parameter |
| Adding new function | MINOR | Adding `validate()` |
| Adding optional parameter | MINOR | New optional `options` arg |
| Bug fix | PATCH | Fix null pointer |
| Performance improvement | PATCH | Faster algorithm |
| Internal refactor | PATCH | No API change |

## Version Constraints

### Constraint Syntax

| Syntax | Meaning | Resolves to |
|--------|---------|-------------|
| `1.2.3` | Exact version | 1.2.3 only |
| `^1.2.3` | Caret (compatible) | â‰¥1.2.3 and <2.0.0 |
| `~1.2.3` | Tilde (patch updates) | â‰¥1.2.3 and <1.3.0 |
| `>=1.0.0` | At least | 1.0.0 or higher |
| `>1.0.0` | Greater than | Higher than 1.0.0 |
| `<2.0.0` | Less than | Lower than 2.0.0 |
| `<=2.0.0` | At most | 2.0.0 or lower |
| `>=1.0.0 <2.0.0` | Range | Between 1.0.0 and 2.0.0 |
| `*` | Any | Any version |

### Caret Ranges (^)

The caret (`^`) allows changes that don't modify the leftmost non-zero digit:

```
^1.2.3  â†’  >=1.2.3 <2.0.0   # Allows 1.x.x
^0.2.3  â†’  >=0.2.3 <0.3.0   # Allows 0.2.x
^0.0.3  â†’  >=0.0.3 <0.0.4   # Allows 0.0.3 only
```

**Use when:** You want compatible updates within a major version.

**Most common constraint** - recommended for most dependencies.

### Tilde Ranges (~)

The tilde (`~`) allows only patch-level changes:

```
~1.2.3  â†’  >=1.2.3 <1.3.0   # Allows 1.2.x
~1.2    â†’  >=1.2.0 <1.3.0   # Allows 1.2.x
~1      â†’  >=1.0.0 <2.0.0   # Allows 1.x.x
```

**Use when:** You want only bug fixes, no new features.

### Comparison Ranges

Combine comparison operators for precise control:

```json
{
  "dependencies": {
    "owner/pkg": ">=1.0.0 <2.0.0",
    "owner/other": ">1.5.0 <=2.1.0"
  }
}
```

### Any Version (*)

Matches any version:

```json
{
  "dependencies": {
    "owner/pkg": "*"
  }
}
```

**Warning:** Not recommended for production. Will always get the latest version.

## Pre-release Versions

### Pre-release Identifiers

Pre-releases have lower precedence than releases:

```
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0
```

### Common Pre-release Tags

| Tag | Meaning | Stage |
|-----|---------|-------|
| `alpha` | Early development | Very unstable |
| `beta` | Feature complete | Testing |
| `rc` | Release candidate | Final testing |
| `dev` | Development snapshot | Unstable |

### Pre-release in Constraints

Constraints don't match pre-releases by default:

```
^1.0.0    # Does NOT match 1.1.0-beta
>=1.0.0   # Does NOT match 2.0.0-alpha
```

To include pre-releases, reference them explicitly:

```
>=1.0.0-alpha <2.0.0   # Includes all 1.x pre-releases
```

## Version Comparison

### Comparison Rules

1. Compare MAJOR, MINOR, PATCH numerically
2. Release > pre-release with same version
3. Pre-releases compared alphanumerically
4. Build metadata is ignored

### Examples

```
1.0.0 < 1.0.1 < 1.1.0 < 2.0.0

1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0

1.0.0 = 1.0.0+build123  # Build metadata ignored
```

### Sorting

Versions sort ascending:

```
1.0.0
1.0.1
1.1.0
1.1.1
2.0.0-alpha
2.0.0-beta
2.0.0
```

## Version Resolution

### Resolution Algorithm

When multiple packages require the same dependency:

1. Collect all constraints
2. Find intersection of all ranges
3. Select highest version in intersection
4. Error if no version satisfies all

### Example Resolution

```
package-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)
package-b requires hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)

Intersection: >=1.2.0 <1.3.0
Available: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]
Resolved: 1.2.5 (highest in intersection)
```

### Conflict Detection

Conflict occurs when no version satisfies all constraints:

```
package-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)
package-b requires hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)

Intersection: (empty)
Result: CONFLICT - no version satisfies both
```

## Best Practices

### For Package Consumers

1. **Use caret ranges** for most dependencies:
   ```json
   "hemlang/json": "^1.2.0"
   ```

2. **Use tilde ranges** for critical dependencies:
   ```json
   "critical/lib": "~1.2.0"
   ```

3. **Pin versions** only when necessary:
   ```json
   "unstable/pkg": "1.2.3"
   ```

4. **Commit your lock file** for reproducible builds

5. **Update regularly** to get security fixes:
   ```bash
   hpm update
   hpm outdated
   ```

### For Package Authors

1. **Start at 0.1.0** for initial development:
   - API may change frequently
   - Users expect instability

2. **Go to 1.0.0** when API is stable:
   - Public commitment to stability
   - Breaking changes require major bump

3. **Follow semver strictly**:
   - Breaking change = MAJOR
   - New feature = MINOR
   - Bug fix = PATCH

4. **Use pre-releases** for testing:
   ```bash
   git tag v2.0.0-beta.1
   git push --tags
   ```

5. **Document breaking changes** in CHANGELOG

## Publishing Versions

### Creating Releases

```bash
# Update version in package.json
# Edit package.json: "version": "1.1.0"

# Commit version change
git add package.json
git commit -m "Bump version to 1.1.0"

# Create and push tag
git tag v1.1.0
git push origin main --tags
```

### Tag Format

Tags **must** start with `v`:

```
v1.0.0      âœ“ Correct
v1.0.0-beta âœ“ Correct
1.0.0       âœ— Won't be recognized
```

### Release Workflow

```bash
# 1. Ensure tests pass
hpm test

# 2. Update version in package.json
# 3. Update CHANGELOG.md
# 4. Commit changes
git add -A
git commit -m "Release v1.2.0"

# 5. Create tag
git tag v1.2.0

# 6. Push everything
git push origin main --tags
```

## Checking Versions

### List Installed Versions

```bash
hpm list
```

### Check for Updates

```bash
hpm outdated
```

Output:
```
Package         Current  Wanted  Latest
hemlang/json    1.0.0    1.0.5   1.2.0
hemlang/sprout  2.0.0    2.0.3   2.1.0
```

- **Current**: Installed version
- **Wanted**: Highest matching constraint
- **Latest**: Latest available

### Update Packages

```bash
# Update all
hpm update

# Update specific package
hpm update hemlang/json
```

## See Also

- [Creating Packages](#hpm-versioning-creating-packages) - Publishing guide
- [Package Specification](#hpm-versioning-package-spec) - package.json format
- [Commands](#hpm-versioning-commands) - CLI reference



################################################################################
# HPM: REFERENCE
################################################################################

--------------------------------------------------------------------------------
## Architecture
--------------------------------------------------------------------------------

# Architecture

Internal architecture and design of hpm. This document is for contributors and those interested in understanding how hpm works.

## Overview

hpm is written in Hemlock and consists of several modules that handle different aspects of package management:

```
src/
â”œâ”€â”€ main.hml        # CLI entry point and command routing
â”œâ”€â”€ manifest.hml    # package.json handling
â”œâ”€â”€ lockfile.hml    # package-lock.json handling
â”œâ”€â”€ semver.hml      # Semantic versioning
â”œâ”€â”€ resolver.hml    # Dependency resolution
â”œâ”€â”€ github.hml      # GitHub API client
â”œâ”€â”€ installer.hml   # Package downloading and extraction
â””â”€â”€ cache.hml       # Global cache management
```

## Module Responsibilities

### main.hml

The entry point for the CLI application.

**Responsibilities:**
- Parse command-line arguments
- Route commands to appropriate handlers
- Display help and version information
- Handle global flags (--verbose, --dry-run, etc.)
- Exit with appropriate codes

**Key functions:**
- `main()` - Entry point, parses args and dispatches commands
- `cmd_init()` - Handle `hpm init`
- `cmd_install()` - Handle `hpm install`
- `cmd_uninstall()` - Handle `hpm uninstall`
- `cmd_update()` - Handle `hpm update`
- `cmd_list()` - Handle `hpm list`
- `cmd_outdated()` - Handle `hpm outdated`
- `cmd_run()` - Handle `hpm run`
- `cmd_why()` - Handle `hpm why`
- `cmd_cache()` - Handle `hpm cache`

**Command shortcuts:**
```hemlock
let shortcuts = {
    "i": "install",
    "rm": "uninstall",
    "remove": "uninstall",
    "ls": "list",
    "up": "update"
};
```

### manifest.hml

Handles reading and writing `package.json` files.

**Responsibilities:**
- Read/write package.json
- Validate package structure
- Manage dependencies
- Parse package specifiers (owner/repo@version)

**Key functions:**
```hemlock
create_default(): Manifest           // Create empty manifest
read_manifest(): Manifest            // Read from file
write_manifest(m: Manifest)          // Write to file
validate(m: Manifest): bool          // Validate structure
get_all_dependencies(m): Map         // Get deps + devDeps
add_dependency(m, pkg, ver, dev)     // Add dependency
remove_dependency(m, pkg)            // Remove dependency
parse_specifier(spec): (name, ver)   // Parse "owner/repo@^1.0.0"
split_name(name): (owner, repo)      // Parse "owner/repo"
```

**Manifest structure:**
```hemlock
type Manifest = {
    name: string,
    version: string,
    description: string?,
    author: string?,
    license: string?,
    repository: string?,
    main: string?,
    dependencies: Map<string, string>,
    devDependencies: Map<string, string>,
    scripts: Map<string, string>
};
```

### lockfile.hml

Manages the `package-lock.json` file for reproducible installs.

**Responsibilities:**
- Create/read/write lock files
- Track exact resolved versions
- Store download URLs and integrity hashes
- Prune orphaned dependencies

**Key functions:**
```hemlock
create_empty(): Lockfile              // Create empty lockfile
read_lockfile(): Lockfile             // Read from file
write_lockfile(l: Lockfile)           // Write to file
create_entry(ver, url, hash, deps)    // Create lock entry
get_locked(l, pkg): LockEntry?        // Get locked version
set_locked(l, pkg, entry)             // Set locked version
remove_locked(l, pkg)                 // Remove entry
prune(l, keep: Set)                   // Remove orphans
needs_update(l, m): bool              // Check if out of sync
```

**Lockfile structure:**
```hemlock
type Lockfile = {
    lockVersion: int,
    hemlock: string,
    dependencies: Map<string, LockEntry>
};

type LockEntry = {
    version: string,
    resolved: string,     // Download URL
    integrity: string,    // SHA256 hash
    dependencies: Map<string, string>
};
```

### semver.hml

Full implementation of Semantic Versioning 2.0.0.

**Responsibilities:**
- Parse version strings
- Compare versions
- Parse and evaluate version constraints
- Find versions satisfying constraints

**Key functions:**
```hemlock
// Parsing
parse(s: string): Version             // "1.2.3-beta+build" â†’ Version
stringify(v: Version): string         // Version â†’ "1.2.3-beta+build"

// Comparison
compare(a, b: Version): int           // -1, 0, or 1
gt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool

// Constraints
parse_constraint(s: string): Constraint    // "^1.2.3" â†’ Constraint
satisfies(v: Version, c: Constraint): bool // Check if v matches c
max_satisfying(versions, c): Version?      // Find highest match
sort(versions): [Version]                  // Sort ascending

// Utilities
constraints_overlap(a, b: Constraint): bool  // Check compatibility
```

**Version structure:**
```hemlock
type Version = {
    major: int,
    minor: int,
    patch: int,
    prerelease: [string]?,  // e.g., ["beta", "1"]
    build: string?          // e.g., "20230101"
};
```

**Constraint types:**
```hemlock
type Constraint =
    | Exact(Version)           // "1.2.3"
    | Caret(Version)           // "^1.2.3" â†’ >=1.2.3 <2.0.0
    | Tilde(Version)           // "~1.2.3" â†’ >=1.2.3 <1.3.0
    | Range(op, Version)       // ">=1.0.0", "<2.0.0"
    | And(Constraint, Constraint)  // Combined ranges
    | Any;                     // "*"
```

### resolver.hml

Implements npm-style dependency resolution.

**Responsibilities:**
- Resolve dependency trees
- Detect version conflicts
- Detect circular dependencies
- Build visualization trees

**Key functions:**
```hemlock
resolve(manifest, lockfile): ResolveResult
    // Main resolver: returns flat map of all dependencies with resolved versions

resolve_version(pkg, constraints: [string]): ResolvedPackage?
    // Find version satisfying all constraints

detect_cycles(deps: Map): [Cycle]?
    // Find circular dependencies using DFS

build_tree(lockfile): Tree
    // Create tree structure for display

find_why(pkg, lockfile): [Chain]
    // Find dependency chains explaining why pkg is installed
```

**Resolution algorithm:**

1. **Collect constraints**: Walk manifest and transitive dependencies
2. **Resolve each package**: For each package:
   - Get all version constraints from dependents
   - Fetch available versions from GitHub
   - Find highest version satisfying ALL constraints
   - Error if no version satisfies all (conflict)
3. **Detect cycles**: Run DFS to find circular dependencies
4. **Return flat map**: Package name â†’ resolved version info

**ResolveResult structure:**
```hemlock
type ResolveResult = {
    packages: Map<string, ResolvedPackage>,
    conflicts: [Conflict]?,
    cycles: [Cycle]?
};

type ResolvedPackage = {
    name: string,
    version: Version,
    url: string,
    dependencies: Map<string, string>
};
```

### github.hml

GitHub API client for package discovery and downloads.

**Responsibilities:**
- Fetch available versions (tags)
- Download package.json from repositories
- Download release tarballs
- Handle authentication and rate limits

**Key functions:**
```hemlock
get_token(): string?
    // Get token from env or config

github_request(url, headers?): Response
    // Make API request with retries

get_tags(owner, repo): [string]
    // Get version tags (v1.0.0, v1.1.0, etc.)

get_package_json(owner, repo, ref): Manifest
    // Fetch package.json at specific tag/commit

download_tarball(owner, repo, tag): bytes
    // Download release archive

repo_exists(owner, repo): bool
    // Check if repository exists

get_repo_info(owner, repo): RepoInfo
    // Get repository metadata
```

**Retry logic:**
- Exponential backoff: 1s, 2s, 4s, 8s
- Retries on: 403 (rate limit), 5xx (server error), network errors
- Max 4 retries
- Reports rate limit errors clearly

**API endpoints used:**
```
GET /repos/{owner}/{repo}/tags
GET /repos/{owner}/{repo}/contents/package.json?ref={tag}
GET /repos/{owner}/{repo}/tarball/{tag}
GET /repos/{owner}/{repo}
```

### installer.hml

Handles downloading and extracting packages.

**Responsibilities:**
- Download packages from GitHub
- Extract tarballs to hem_modules
- Check/use cached packages
- Install/uninstall packages

**Key functions:**
```hemlock
install_package(pkg: ResolvedPackage): bool
    // Download and install single package

install_all(packages: Map, options): InstallResult
    // Install all resolved packages

uninstall_package(name: string): bool
    // Remove package from hem_modules

get_installed(): Map<string, string>
    // List currently installed packages

verify_integrity(pkg): bool
    // Verify package integrity

prefetch_packages(packages: Map): void
    // Parallel download to cache (experimental)
```

**Installation process:**

1. Check if already installed at correct version
2. Check cache for tarball
3. If not cached, download from GitHub
4. Store in cache for future use
5. Extract to `hem_modules/owner/repo/`
6. Verify installation

**Directory structure created:**
```
hem_modules/
â””â”€â”€ owner/
    â””â”€â”€ repo/
        â”œâ”€â”€ package.json
        â”œâ”€â”€ src/
        â””â”€â”€ ...
```

### cache.hml

Manages the global package cache.

**Responsibilities:**
- Store downloaded tarballs
- Retrieve cached packages
- List cached packages
- Clear cache
- Manage configuration

**Key functions:**
```hemlock
get_cache_dir(): string
    // Get cache directory (respects HPM_CACHE_DIR)

get_config_dir(): string
    // Get config directory (~/.hpm)

is_cached(owner, repo, version): bool
    // Check if tarball is cached

get_cached_path(owner, repo, version): string
    // Get path to cached tarball

store_tarball_file(owner, repo, version, data): void
    // Save tarball to cache

list_cached(): [CachedPackage]
    // List all cached packages

clear_cache(): int
    // Remove all cached packages, return bytes freed

get_cache_size(): int
    // Calculate total cache size

read_config(): Config
    // Read ~/.hpm/config.json

write_config(c: Config): void
    // Write config file
```

**Cache structure:**
```
~/.hpm/
â”œâ”€â”€ config.json
â””â”€â”€ cache/
    â””â”€â”€ owner/
        â””â”€â”€ repo/
            â”œâ”€â”€ 1.0.0.tar.gz
            â””â”€â”€ 1.1.0.tar.gz
```

## Data Flow

### Install Command Flow

```
hpm install owner/repo@^1.0.0
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ main.hml â”‚ Parse args, call cmd_install
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚manifest.hmlâ”‚ Read package.json, add dependency
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚resolver.hmlâ”‚ Resolve all dependencies
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ github.hmlâ”‚    â”‚ semver.hmlâ”‚ Get versions, find satisfying
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚installer.hmlâ”‚ Download and extract packages
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ github.hmlâ”‚    â”‚ cache.hmlâ”‚ Download or use cache
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚lockfile.hmlâ”‚ Update package-lock.json
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Resolution Algorithm Detail

```
Input: manifest.dependencies, manifest.devDependencies, existing lockfile

1. Initialize:
   - constraints = {} // Map<string, [Constraint]>
   - resolved = {}    // Map<string, ResolvedPackage>
   - queue = [direct dependencies]

2. While queue not empty:
   a. pkg = queue.pop()
   b. If pkg already resolved, skip
   c. Get all constraints for pkg from dependents
   d. Fetch available versions from GitHub (cached)
   e. Find max version satisfying all constraints
   f. If none found: CONFLICT
   g. resolved[pkg] = {version, url, deps}
   h. Add pkg's dependencies to queue

3. Detect cycles in resolved graph
   - If cycle found: ERROR

4. Return resolved map
```

## Error Handling

### Exit Codes

Defined in main.hml:

```hemlock
let EXIT_SUCCESS = 0;
let EXIT_CONFLICT = 1;
let EXIT_NOT_FOUND = 2;
let EXIT_VERSION_NOT_FOUND = 3;
let EXIT_NETWORK = 4;
let EXIT_INVALID_MANIFEST = 5;
let EXIT_INTEGRITY = 6;
let EXIT_RATE_LIMIT = 7;
let EXIT_CIRCULAR = 8;
```

### Error Propagation

Errors bubble up through return values:

```hemlock
fn resolve_version(pkg): Result<Version, ResolveError> {
    let versions = github.get_tags(owner, repo)?;  // ? propagates
    // ...
}
```

## Testing

### Test Framework

Custom test framework in `test/framework.hml`:

```hemlock
fn suite(name: string, tests: fn()) {
    print("Suite: " + name);
    tests();
}

fn test(name: string, body: fn()) {
    try {
        body();
        print("  âœ“ " + name);
    } catch e {
        print("  âœ— " + name + ": " + e);
        failed += 1;
    }
}

fn assert_eq<T>(actual: T, expected: T) {
    if actual != expected {
        throw "Expected " + expected + ", got " + actual;
    }
}
```

### Test Files

- `test/test_semver.hml` - Version parsing, comparison, constraints
- `test/test_manifest.hml` - Manifest reading/writing, validation
- `test/test_lockfile.hml` - Lockfile operations
- `test/test_cache.hml` - Cache management

### Running Tests

```bash
# All tests
make test

# Specific tests
make test-semver
make test-manifest
make test-lockfile
make test-cache
```

## Future Improvements

### Planned Features

1. **Integrity verification** - Full SHA256 hash checking
2. **Workspaces** - Monorepo support
3. **Plugin system** - Extensible commands
4. **Audit** - Security vulnerability checking
5. **Private registry** - Self-hosted package hosting

### Known Limitations

1. **Bundler bug** - Can't create standalone executable
2. **Parallel downloads** - Experimental, may have race conditions
3. **Integrity** - SHA256 not fully implemented

## Contributing

### Code Style

- Use 4-space indentation
- Functions should do one thing
- Comment complex logic
- Write tests for new features

### Adding a Command

1. Add handler in `main.hml`:
   ```hemlock
   fn cmd_newcmd(args: [string]) {
       // Implementation
   }
   ```

2. Add to command dispatch:
   ```hemlock
   match command {
       "newcmd" => cmd_newcmd(args),
       // ...
   }
   ```

3. Update help text

### Adding a Module

1. Create `src/newmodule.hml`
2. Export public interface
3. Import in modules that need it
4. Add tests in `test/test_newmodule.hml`

## See Also

- [Commands](#hpm-architecture-commands) - CLI reference
- [Creating Packages](#hpm-architecture-creating-packages) - Package development
- [Versioning](#hpm-architecture-versioning) - Semantic versioning


--------------------------------------------------------------------------------
## Exit Codes
--------------------------------------------------------------------------------

# Exit Codes

Reference for hpm exit codes and their meanings.

## Exit Code Table

| Code | Name | Description |
|------|------|-------------|
| 0 | SUCCESS | Command completed successfully |
| 1 | CONFLICT | Dependency version conflict |
| 2 | NOT_FOUND | Package not found |
| 3 | VERSION_NOT_FOUND | Requested version not found |
| 4 | NETWORK | Network error |
| 5 | INVALID_MANIFEST | Invalid package.json |
| 6 | INTEGRITY | Integrity check failed |
| 7 | RATE_LIMIT | GitHub API rate limit exceeded |
| 8 | CIRCULAR | Circular dependency detected |

## Detailed Descriptions

### Exit Code 0: SUCCESS

The command completed successfully.

```bash
$ hpm install
Installed 5 packages
$ echo $?
0
```

### Exit Code 1: CONFLICT

Two or more packages require incompatible versions of a dependency.

**Example:**
```
Error: Dependency conflict for hemlang/json

  package-a requires hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)
  package-b requires hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)

No version satisfies all constraints.
```

**Solutions:**
1. Check which packages have the conflict:
   ```bash
   hpm why hemlang/json
   ```
2. Update the conflicting package:
   ```bash
   hpm update package-a
   ```
3. Relax version constraints in package.json
4. Remove one of the conflicting packages

### Exit Code 2: NOT_FOUND

The specified package does not exist on GitHub.

**Example:**
```
Error: Package not found: hemlang/nonexistent

The repository hemlang/nonexistent does not exist on GitHub.
```

**Solutions:**
1. Verify package name spelling
2. Check if repository exists: `https://github.com/owner/repo`
3. Verify you have access (for private repos, set GITHUB_TOKEN)

### Exit Code 3: VERSION_NOT_FOUND

No version matches the specified constraint.

**Example:**
```
Error: No version of hemlang/json matches constraint ^5.0.0

Available versions: 1.0.0, 1.1.0, 1.2.0, 2.0.0
```

**Solutions:**
1. Check available versions on GitHub releases/tags
2. Use a valid version constraint
3. Version tags must start with 'v' (e.g., `v1.0.0`)

### Exit Code 4: NETWORK

Network-related error occurred.

**Example:**
```
Error: Network error: could not connect to api.github.com

Please check your internet connection and try again.
```

**Solutions:**
1. Check internet connection
2. Check if GitHub is accessible
3. Verify proxy settings if behind firewall
4. Use `--offline` if packages are cached:
   ```bash
   hpm install --offline
   ```
5. Wait and retry (hpm retries automatically)

### Exit Code 5: INVALID_MANIFEST

The package.json file is invalid or malformed.

**Example:**
```
Error: Invalid package.json

  - Missing required field: name
  - Invalid version format: "1.0"
```

**Solutions:**
1. Check JSON syntax (use a JSON validator)
2. Ensure required fields exist (`name`, `version`)
3. Verify field formats:
   - name: `owner/repo` format
   - version: `X.Y.Z` semver format
4. Regenerate:
   ```bash
   rm package.json
   hpm init
   ```

### Exit Code 6: INTEGRITY

Package integrity verification failed.

**Example:**
```
Error: Integrity check failed for hemlang/json@1.0.0

Expected: sha256-abc123...
Actual:   sha256-def456...

The downloaded package may be corrupted.
```

**Solutions:**
1. Clear cache and reinstall:
   ```bash
   hpm cache clean
   hpm install
   ```
2. Check for network issues (partial downloads)
3. Verify package wasn't tampered with

### Exit Code 7: RATE_LIMIT

GitHub API rate limit has been exceeded.

**Example:**
```
Error: GitHub API rate limit exceeded

Unauthenticated rate limit: 60 requests/hour
Current usage: 60/60

Rate limit resets at: 2024-01-15 10:30:00 UTC
```

**Solutions:**
1. **Authenticate with GitHub** (recommended):
   ```bash
   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
   hpm install
   ```
2. Wait for rate limit to reset (resets hourly)
3. Use offline mode if packages are cached:
   ```bash
   hpm install --offline
   ```

### Exit Code 8: CIRCULAR

Circular dependency detected in the dependency graph.

**Example:**
```
Error: Circular dependency detected

  package-a@1.0.0
  â””â”€â”€ package-b@1.0.0
      â””â”€â”€ package-a@1.0.0  (circular!)

Cannot resolve dependency tree.
```

**Solutions:**
1. This is usually a bug in the packages themselves
2. Contact package maintainers
3. Avoid using one of the circular packages

## Using Exit Codes in Scripts

### Bash

```bash
#!/bin/bash

hpm install
exit_code=$?

case $exit_code in
  0)
    echo "Installation successful"
    ;;
  1)
    echo "Dependency conflict - check version constraints"
    exit 1
    ;;
  2)
    echo "Package not found - check package name"
    exit 1
    ;;
  4)
    echo "Network error - check connection"
    exit 1
    ;;
  7)
    echo "Rate limited - set GITHUB_TOKEN"
    exit 1
    ;;
  *)
    echo "Unknown error: $exit_code"
    exit 1
    ;;
esac
```

### CI/CD

```yaml
# GitHub Actions
- name: Install dependencies
  run: |
    hpm install
    if [ $? -eq 7 ]; then
      echo "::error::GitHub rate limit exceeded. Add GITHUB_TOKEN."
      exit 1
    fi
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### Make

```makefile
install:
	@hpm install || (echo "Installation failed with code $$?"; exit 1)

test: install
	@hpm test
```

## Troubleshooting by Exit Code

### Quick Reference

| Code | First Thing to Check |
|------|---------------------|
| 1 | Run `hpm why <package>` to see conflict |
| 2 | Verify package name on GitHub |
| 3 | Check available versions on GitHub tags |
| 4 | Check internet connection |
| 5 | Validate package.json syntax |
| 6 | Run `hpm cache clean && hpm install` |
| 7 | Set `GITHUB_TOKEN` environment variable |
| 8 | Contact package maintainers |

## See Also

- [Troubleshooting](#hpm-exit-codes-troubleshooting) - Detailed solutions
- [Commands](#hpm-exit-codes-commands) - Command reference
- [Configuration](#hpm-exit-codes-configuration) - Setting up GitHub token



================================================================================
END OF DOCUMENTATION
================================================================================