<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manual da Linguagem Hemlock</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sage: #9CAF88;
            --pine: #2F4F4F;
            --dark-pine: #1a2f2f;
            --light-sage: #E8F4E1;
            --cream: #FAF9F6;
            --text: #2C3E2C;
            --text-light: #5A6F5A;
            --border: #D4E4CB;
            --code-bg: #F5F9F3;
            --accent: #6B8E6B;
        }

        [data-theme="dark"] {
            --sage: #6B8E6B;
            --pine: #9CAF88;
            --dark-pine: #0d1a1a;
            --light-sage: #1a2f2f;
            --cream: #0f1a1a;
            --text: #e0e8e0;
            --text-light: #a8b8a8;
            --border: #2a4a4a;
            --code-bg: #162626;
            --accent: #9CAF88;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) {
                --sage: #6B8E6B;
                --pine: #9CAF88;
                --dark-pine: #0d1a1a;
                --light-sage: #1a2f2f;
                --cream: #0f1a1a;
                --text: #e0e8e0;
                --text-light: #a8b8a8;
                --border: #2a4a4a;
                --code-bg: #162626;
                --accent: #9CAF88;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            line-height: 1.7;
            color: var(--text);
            background: var(--cream);
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: #2F4F4F;
            color: white;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .header-logo {
            height: 45px;
            margin-right: 1rem;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            margin-right: auto;
        }

        @media (max-width: 768px) {
            .header h1 {
                display: none;
            }
        }

        /* Layout */
        .container {
            display: flex;
            margin-top: 70px;
            min-height: calc(100vh - 70px);
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 70px;
            width: 280px;
            height: calc(100vh - 70px);
            background: var(--light-sage);
            border-right: 2px solid var(--border);
            overflow-y: auto;
            padding: 2rem 0;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 900;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        @media (min-width: 1024px) {
            .sidebar {
                transform: translateX(0);
            }
        }

        .nav-section {
            margin-bottom: 1.5rem;
        }

        .nav-section-title {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--pine);
            padding: 0 1.5rem;
            margin-bottom: 0.5rem;
        }

        .nav-link {
            display: block;
            padding: 0.5rem 1.5rem;
            color: var(--text);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .nav-link:hover {
            background: rgba(47, 79, 79, 0.05);
            border-left-color: var(--sage);
        }

        .nav-link.active {
            background: rgba(47, 79, 79, 0.1);
            border-left-color: var(--pine);
            font-weight: 600;
            color: var(--pine);
        }

        /* Mobile Menu Toggle */
        .menu-toggle {
            display: none;
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            margin-right: 0.5rem;
        }

        @media (max-width: 1023px) {
            .menu-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }

        /* Main Content */
        .main-content {
            flex: 1;
            margin-left: 0;
            padding: 3rem 2rem;
            max-width: 900px;
        }

        @media (min-width: 1024px) {
            .main-content {
                margin-left: 280px;
            }
        }

        /* Typography */
        .content h1 {
            font-size: 2.5rem;
            color: var(--pine);
            margin: 2rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--sage);
        }

        .content h2 {
            font-size: 2rem;
            color: var(--pine);
            margin: 3rem 0 1rem;
            padding-top: 1rem;
        }

        .content h3 {
            font-size: 1.5rem;
            color: var(--accent);
            margin: 2rem 0 1rem;
        }

        .content h4 {
            font-size: 1.2rem;
            color: var(--accent);
            margin: 1.5rem 0 0.8rem;
        }

        .content p {
            margin: 1rem 0;
            color: var(--text);
        }

        .content ul, .content ol {
            margin: 1rem 0 1rem 2rem;
        }

        .content li {
            margin: 0.5rem 0;
        }

        .content blockquote {
            border-left: 4px solid var(--sage);
            background: var(--light-sage);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: var(--text-light);
        }

        .content hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }

        /* Code Blocks */
        .content code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--pine);
        }

        .code-block {
            margin: 1.5rem 0;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: var(--code-bg);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--pine);
            color: var(--light-sage);
            font-size: 0.8rem;
        }

        .code-lang {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-weight: 600;
            text-transform: lowercase;
        }

        .copy-btn {
            background: transparent;
            border: 1px solid var(--sage);
            color: var(--light-sage);
            padding: 0.3rem 0.7rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .copy-btn:hover {
            background: var(--sage);
            color: var(--pine);
        }

        .copy-btn.copied {
            background: var(--sage);
            color: var(--pine);
            border-color: var(--sage);
        }

        .copy-btn svg {
            width: 14px;
            height: 14px;
        }

        .content pre {
            background: var(--code-bg);
            margin: 0;
            padding: 1.2rem;
            overflow-x: auto;
        }

        .content pre code {
            background: none;
            padding: 0;
            border-radius: 0;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        /* Standalone pre without code-block wrapper (legacy) */
        .content > pre {
            border: 1px solid var(--border);
            border-left: 4px solid var(--pine);
            border-radius: 4px;
            margin: 1.5rem 0;
        }

        /* Tables */
        .content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        .content th,
        .content td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .content th {
            background: var(--light-sage);
            color: var(--pine);
            font-weight: 600;
        }

        /* Links */
        .content a {
            color: var(--accent);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .content a:hover {
            border-bottom-color: var(--accent);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--cream);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--sage);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* Section anchors */
        .section-anchor {
            scroll-margin-top: 90px;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .main-content {
                padding: 2rem 1rem;
            }

            .content h1 {
                font-size: 2rem;
            }

            .content h2 {
                font-size: 1.6rem;
            }

            .content h3 {
                font-size: 1.3rem;
            }
        }

        /* Page switching */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* Search */
        .search-container {
            position: relative;
            margin-right: 1rem;
        }

        .search-input {
            width: 200px;
            padding: 0.5rem 1rem;
            padding-left: 2.2rem;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.25);
            width: 280px;
        }

        .search-icon {
            position: absolute;
            left: 0.8rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
        }

        .search-results {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            right: 0;
            min-width: 320px;
            max-height: 400px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1001;
        }

        .search-results.active {
            display: block;
        }

        .search-result {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s;
        }

        .search-result:last-child {
            border-bottom: none;
        }

        .search-result:hover,
        .search-result.selected {
            background: var(--light-sage);
        }

        .search-result-title {
            font-weight: 600;
            color: var(--pine);
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
        }

        .search-result-section {
            font-size: 0.75rem;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .search-result-preview {
            font-size: 0.85rem;
            color: var(--text-light);
            margin-top: 0.25rem;
            line-height: 1.4;
        }

        .search-result-preview mark {
            background: var(--sage);
            color: var(--pine);
            padding: 0 2px;
            border-radius: 2px;
        }

        .search-no-results {
            padding: 1rem;
            text-align: center;
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .search-shortcut {
            display: none;
            margin-left: 0.5rem;
            padding: 0.15rem 0.4rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.8);
        }

        @media (min-width: 768px) {
            .search-shortcut {
                display: inline-block;
            }
        }

        @media (max-width: 768px) {
            .search-container {
                position: fixed;
                top: 70px;
                left: 0;
                right: 0;
                margin: 0;
                padding: 0.5rem;
                background: #1a2f2f;
                display: none;
                z-index: 999;
            }

            .search-container.active {
                display: block;
            }

            .search-input {
                width: 100%;
            }

            .search-input:focus {
                width: 100%;
            }

            .search-results {
                position: fixed;
                top: 120px;
                left: 0.5rem;
                right: 0.5rem;
                min-width: auto;
                max-height: calc(100vh - 140px);
            }

            .search-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
                background: transparent;
                border: none;
                color: white;
                font-size: 1.2rem;
                cursor: pointer;
                padding: 0.5rem;
                margin-left: auto;
            }
        }

        @media (min-width: 769px) {
            .search-toggle {
                display: none;
            }
        }

        /* Theme Toggle */
        .theme-toggle {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            margin-left: 0.5rem;
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .theme-toggle svg {
            width: 20px;
            height: 20px;
        }

        .theme-toggle .sun-icon {
            display: none;
        }

        .theme-toggle .moon-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .sun-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .moon-icon {
            display: none;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) .theme-toggle .sun-icon {
                display: block;
            }
            :root:not([data-theme="light"]) .theme-toggle .moon-icon {
                display: none;
            }
        }

        /* Language Switcher */
        .lang-switcher {
            margin-left: 0.5rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 8px;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }

        .lang-switcher:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher:focus {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher option {
            background: var(--pine);
            color: white;
        }

        [data-theme="dark"] .lang-switcher option {
            background: var(--bg-primary);
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <button class="menu-toggle" id="menuToggle" aria-label="Toggle navigation menu" aria-expanded="false">&#9776;</button>
        <img src="data:image/png;base64,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" alt="Hemlock Logo" class="header-logo">
        <h1>Manual da Linguagem Hemlock</h1>
        <!-- Search -->
        <div class="search-container" id="searchContainer">
            <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
            <input type="text" class="search-input" id="searchInput" placeholder="Search docs..." autocomplete="off" aria-label="Search documentation">
            <span class="search-shortcut">Ctrl+K</span>
            <div class="search-results" id="searchResults" role="listbox" aria-label="Search results"></div>
        </div>
        <button class="search-toggle" id="searchToggle" aria-label="Toggle search">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
        </button>
        <select class="lang-switcher" id="langSwitcher" onchange="switchLanguage(this.value)" aria-label="Select language">
            <option value="docs.html" >English</option>
<option value="docs-zh.html" ></option>
<option value="docs-de.html" >Deutsch</option>
<option value="docs-es.html" >Espaol</option>
<option value="docs-fr.html" >Franais</option>
<option value="docs-it.html" >Italiano</option>
<option value="docs-ja.html" ></option>
<option value="docs-pt.html" selected>Portugus</option>
<option value="docs-ru.html" ></option>
        </select>
        <button class="theme-toggle" id="themeToggle" title="Toggle dark mode" aria-label="Toggle dark mode">
            <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
            <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
        </button>
    </div>

    <!-- Container -->
    <div class="container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar" id="sidebar" aria-label="Documentation navigation">
            <div class="nav-section">
<a href="#welcome" class="nav-link" data-page="welcome">Bem-vindo</a>
</div>
<a href="#language-reference" class="nav-link" data-page="language-reference">Referncia da Linguagem</a>
<div class="nav-section">
<div class="nav-section-title">Primeiros Passos</div>
<a href="#getting-started-learning-paths" class="nav-link" data-page="getting-started-learning-paths">Caminhos de Aprendizado</a>
<a href="#getting-started-installation" class="nav-link" data-page="getting-started-installation">Instalao</a>
<a href="#getting-started-quick-start" class="nav-link" data-page="getting-started-quick-start">Incio Rpido</a>
<a href="#getting-started-tutorial" class="nav-link" data-page="getting-started-tutorial">Tutorial</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Guia Da Linguagem</div>
<a href="#language-guide-arrays" class="nav-link" data-page="language-guide-arrays">Arrays</a>
<a href="#language-guide-pattern-matching" class="nav-link" data-page="language-guide-pattern-matching">Correspondncia de Padres</a>
<a href="#language-guide-control-flow" class="nav-link" data-page="language-guide-control-flow">Fluxo de Controle</a>
<a href="#language-guide-functions" class="nav-link" data-page="language-guide-functions">Funes</a>
<a href="#language-guide-memory" class="nav-link" data-page="language-guide-memory">Gerenciamento de Memria</a>
<a href="#language-guide-modules" class="nav-link" data-page="language-guide-modules">Mdulos</a>
<a href="#language-guide-objects" class="nav-link" data-page="language-guide-objects">Objetos</a>
<a href="#language-guide-runes" class="nav-link" data-page="language-guide-runes">Runas</a>
<a href="#language-guide-syntax" class="nav-link" data-page="language-guide-syntax">Sintaxe</a>
<a href="#language-guide-strings" class="nav-link" data-page="language-guide-strings">Strings</a>
<a href="#language-guide-types" class="nav-link" data-page="language-guide-types">Tipos</a>
<a href="#language-guide-error-handling" class="nav-link" data-page="language-guide-error-handling">Tratamento de Erros</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Tpicos Avanados</div>
<a href="#advanced-command-line-args" class="nav-link" data-page="advanced-command-line-args">Argumentos de Linha de Comando</a>
<a href="#advanced-async-concurrency" class="nav-link" data-page="advanced-async-concurrency">Assincronismo e Concorrncia</a>
<a href="#advanced-bundling-packaging" class="nav-link" data-page="advanced-bundling-packaging">Empacotamento e Distribuio</a>
<a href="#advanced-command-execution" class="nav-link" data-page="advanced-command-execution">Execuo de Comandos</a>
<a href="#advanced-ffi" class="nav-link" data-page="advanced-ffi">FFI</a>
<a href="#advanced-file-io" class="nav-link" data-page="advanced-file-io">File IO</a>
<a href="#advanced-memory-ownership" class="nav-link" data-page="advanced-memory-ownership">Memory Ownership</a>
<a href="#advanced-atomics" class="nav-link" data-page="advanced-atomics">Operaes Atmicas</a>
<a href="#advanced-profiling" class="nav-link" data-page="advanced-profiling">Perfilamento</a>
<a href="#advanced-signals" class="nav-link" data-page="advanced-signals">Sinais</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Referncia Da API</div>
<a href="#reference-file-api" class="nav-link" data-page="reference-file-api">API de Arquivos</a>
<a href="#reference-array-api" class="nav-link" data-page="reference-array-api">API de Arrays</a>
<a href="#reference-concurrency-api" class="nav-link" data-page="reference-concurrency-api">API de Concorrncia</a>
<a href="#reference-memory-api" class="nav-link" data-page="reference-memory-api">API de Memria</a>
<a href="#reference-string-api" class="nav-link" data-page="reference-string-api">API de Strings</a>
<a href="#reference-builtins" class="nav-link" data-page="reference-builtins">Funes Integradas</a>
<a href="#reference-operators" class="nav-link" data-page="reference-operators">Operadores</a>
<a href="#reference-type-system" class="nav-link" data-page="reference-type-system">Sistema de Tipos</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Design E Filosofia</div>
<a href="#design-philosophy" class="nav-link" data-page="design-philosophy">Filosofia</a>
<a href="#design-implementation" class="nav-link" data-page="design-implementation">Implementao</a>
<a href="#design-signature-syntax" class="nav-link" data-page="design-signature-syntax">Sintaxe de Assinaturas</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Contribuio</div>
<a href="#contributing-guidelines" class="nav-link" data-page="contributing-guidelines">Diretrizes</a>
<a href="#contributing-testing" class="nav-link" data-page="contributing-testing">Testes</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Primeiros Passos</div>
<a href="#hpm-project-setup" class="nav-link" data-page="hpm-project-setup">Configurao do Projeto</a>
<a href="#hpm-installation" class="nav-link" data-page="hpm-installation">Instalao</a>
<a href="#hpm-quick-start" class="nav-link" data-page="hpm-quick-start">Incio Rpido</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Guia Do Usurio</div>
<a href="#hpm-commands" class="nav-link" data-page="hpm-commands">Comandos</a>
<a href="#hpm-configuration" class="nav-link" data-page="hpm-configuration">Configurao</a>
<a href="#hpm-troubleshooting" class="nav-link" data-page="hpm-troubleshooting">Soluo de Problemas</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Desenvolvimento De Pacotes</div>
<a href="#hpm-creating-packages" class="nav-link" data-page="hpm-creating-packages">Criao de Pacotes</a>
<a href="#hpm-package-spec" class="nav-link" data-page="hpm-package-spec">Especificao de Pacotes</a>
<a href="#hpm-versioning" class="nav-link" data-page="hpm-versioning">Versionamento</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Referncia</div>
<a href="#hpm-architecture" class="nav-link" data-page="hpm-architecture">Arquitetura</a>
<a href="#hpm-exit-codes" class="nav-link" data-page="hpm-exit-codes">Cdigos de Sada</a>
</div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <div class="content" id="content"></div>
        </main>
    </div>

    <script>
        // Embedded documentation pages
        const PAGES = {"Bem-vindo": {"id": "welcome", "content": "# Bem-vindo ao Hemlock\n\n> \"Uma pequena linguagem insegura para escrever coisas inseguras com segurana.\"\n\n**Hemlock**  uma linguagem de scripting para sistemas que combina o poder do C com a ergonomia moderna de scripting. Ela oferece gerenciamento manual de memria, controle explcito e concorrncia assncrona estruturada integrada.\n\n## O que  Hemlock?\n\nHemlock  projetada para programadores que desejam:\n\n- **Controle explcito** sobre memria e execuo\n- **Sintaxe similar ao C** com convenincias modernas\n- **Sem comportamento oculto** ou mgica\n- **Async paralelo verdadeiro** com concorrncia baseada em pthread\n\nHemlock NO  uma linguagem com segurana de memria e coleta de lixo. Em vez disso, ela fornece as ferramentas para ser seguro (`buffer`, anotaes de tipo, verificao de limites) sem for-lo a us-las (`ptr`, memria manual, operaes inseguras).\n\n## Exemplo Rpido\n\n```hemlock\n// Ol, Hemlock!\nfn greet(name: string): string {\n    return `Ol, ${name}!`;\n}\n\nlet message = greet(\"Mundo\");\nprint(message);\n\n// Gerenciamento manual de memria\nlet buf = buffer(64);\nbuf[0] = 72;  // 'H'\nbuf[1] = 105; // 'i'\nprint(buf);\nfree(buf);\n```\n\n## Recursos em Resumo\n\n| Recurso | Descrio |\n|---------|-----------|\n| **Sistema de Tipos** | i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object |\n| **Memria** | Gerenciamento manual com `alloc()`, `buffer()`, `free()` |\n| **Async** | `async`/`await` integrado com paralelismo pthread verdadeiro |\n| **FFI** | Chame funes C diretamente de bibliotecas compartilhadas |\n| **Biblioteca Padro** | 40 mdulos incluindo crypto, http, sqlite, json e mais |\n\n## Primeiros Passos\n\nPronto para comear? Veja como iniciar:\n\n1. **[Instalao](#getting-started-installation)** - Baixe e configure o Hemlock\n2. **[Incio Rpido](#getting-started-quick-start)** - Escreva seu primeiro programa em minutos\n3. **[Tutorial](#getting-started-tutorial)** - Aprenda Hemlock passo a passo\n\n## Sees da Documentao\n\n- **Primeiros Passos** - Instalao, guia de incio rpido e tutoriais\n- **Guia da Linguagem** - Aprofunde-se em sintaxe, tipos, funes e mais\n- **Tpicos Avanados** - Programao async, FFI, sinais e operaes atmicas\n- **Referncia da API** - Referncia completa de funes integradas e biblioteca padro\n- **Design e Filosofia** - Entenda por que Hemlock  do jeito que \n\n## Gerenciador de Pacotes\n\nHemlock vem com **hpm**, um gerenciador de pacotes para gerenciar dependncias:\n\n```bash\nhpm init meu-projeto\nhpm add algum-pacote\nhpm run\n```\n\nConsulte as sees da documentao do hpm para mais detalhes.\n\n---\n\nUse a navegao  esquerda para explorar a documentao, ou use a barra de pesquisa para encontrar tpicos especficos.\n"}, "Referncia da Linguagem": {"id": "language-reference", "content": "# Filosofia de Design da Linguagem Hemlock\n\n> \"Uma linguagem pequena e no-segura, para escrever cdigo no-seguro de forma segura.\"\n\nEste documento fornece uma visao geral da filosofia de design do Hemlock e uma referencia rapida da linguagem.\nExplore as outras secoes de documentacao para guias detalhados e referencias de API.\n\n---\n\n## Posicionamento Central\n\nHemlock  uma **linguagem de script de sistemas**, com gerenciamento manual de memria e controle explcito:\n- Poder da linguagem C com convenincia de script moderno\n- Concorrncia assncrona estruturada integrada\n- Sem comportamentos ocultos ou mgica\n\n**Hemlock no :** Segura em memria, com coleta de lixo, nem esconde complexidade.\n**Hemlock :** Explcito  melhor que implcito, educacional, uma \"camada de script C\" para trabalho de sistemas.\n\n---\n\n## Princpios de Design\n\n### 1. Explcito  Melhor que Implcito\n- Ponto e vrgula  obrigatrio (sem insero automtica)\n- Gerenciamento manual de memria (alloc/free)\n- Anotaes de tipo opcionais, mas verificadas em runtime\n\n### 2. Dinmico por Padro, Tipos Opcionais\n- Todo valor tem tag de tipo em runtime\n- Literais inferem tipos: `42`  i32, `5000000000`  i64, `3.14`  f64\n- Anotaes de tipo opcionais foram verificao em runtime\n\n### 3. No-Seguro  um Recurso\n- Aritmtica de ponteiros  permitida (responsabilidade do usurio)\n- `ptr` bruto no tem verificao de limites (use `buffer` para segurana)\n- Double free  permitido causar crash\n\n### 4. Concorrncia Estruturada como Cidad de Primeira Classe\n- `async`/`await` integrados, paralelismo baseado em pthread\n- Channels para comunicao\n- `spawn`/`join`/`detach` para gerenciamento de tasks\n\n### 5. Sintaxe Semelhante a C\n- Blocos `{}` so sempre obrigatrios\n- Comentrios: `// linha` e `/* bloco */`\n- Operadores como C: `+`, `-`, `*`, `%`, `&&`, `||`, `!`, `&`, `|`, `^`, `<<`, `>>`\n- Incremento/decremento: `++x`, `x++`, `--x`, `x--` (prefixo e ps-fixo)\n- Atribuio composta: `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`\n- `/` sempre retorna ponto flutuante (use `divi()` para diviso inteira)\n- Sintaxe de tipos: `let x: type = value;`\n\n---\n\n## Referncia Rpida\n\n### Tipos\n```\nCom sinal:     i8, i16, i32, i64\nSem sinal:    u8, u16, u32, u64\nPonto flut:   f32, f64\nOutros:       bool, string, rune, array, ptr, buffer, null, object, file, task, channel\nAliases:      integer (i32), number (f64), byte (u8)\n```\n\n**Promoo de tipos:** i8  i16  i32  i64  f32  f64 (ponto flutuante sempre vence, mas i64/u64 + f32  f64 para manter preciso)\n\n### Literais\n```hemlock\nlet x = 42;              // i32\nlet big = 5000000000;    // i64 (> mx i32)\nlet hex = 0xDEADBEEF;    // Literal hexadecimal\nlet bin = 0b1010;        // Literal binrio\nlet oct = 0o777;         // Literal octal\nlet sep = 1_000_000;     // Separador de dgitos permitido\nlet pi = 3.14;           // f64\nlet half = .5;           // f64 (sem zero inicial)\nlet s = \"hello\";         // string\nlet esc = \"\\x41\\u{1F600}\"; // Escapes hex e Unicode\nlet ch = 'A';            // rune\nlet emoji = '';        // rune (Unicode)\nlet arr = [1, 2, 3];     // array\nlet obj = { x: 10 };     // object\n```\n\n### Converso de Tipos\n```hemlock\n// Construtores de tipo - parsear strings para tipos\nlet n = i32(\"42\");       // Parsear string para i32\nlet f = f64(\"3.14\");     // Parsear string para f64\nlet b = bool(\"true\");    // Parsear string para bool (\"true\" ou \"false\")\n\n// Todos os tipos numricos suportados\nlet a = i8(\"-128\");      // i8, i16, i32, i64\nlet c = u8(\"255\");       // u8, u16, u32, u64\nlet d = f32(\"1.5\");      // f32, f64\n\n// Hex e negativos\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\n\n// Aliases de tipo tambm funcionam\nlet x = integer(\"100\");  // Igual a i32(\"100\")\nlet y = number(\"1.5\");   // Igual a f64(\"1.5\")\nlet z = byte(\"200\");     // Igual a u8(\"200\")\n\n// Converso entre tipos numricos\nlet big = i64(42);       // i32 para i64\nlet truncated = i32(3.99); // f64 para i32 (trunca para 3)\n\n// Anotaes de tipo validam tipos (mas no parseiam strings)\nlet f: f64 = 100;        // i32 convertido para f64 via anotao (coero numrica funciona)\n// let n: i32 = \"42\";    // Erro - use i32(\"42\") para parsear strings\n```\n\n### Introspeco\n```hemlock\ntypeof(42);              // \"i32\"\ntypeof(\"hello\");         // \"string\"\ntypeof([1, 2, 3]);       // \"array\"\ntypeof(null);            // \"null\"\nlen(\"hello\");            // 5 (comprimento em bytes da string)\nlen([1, 2, 3]);          // 3 (comprimento do array)\n```\n\n### Memria\n```hemlock\nlet p = alloc(64);       // Ponteiro bruto\nlet b = buffer(64);      // Buffer seguro (verificao de limites)\nmemset(p, 0, 64);\nmemcpy(dest, src, 64);\nfree(p);                 // Limpeza manual necessria\n```\n\n### Fluxo de Controle\n```hemlock\nif (x > 0) { } else if (x < 0) { } else { }\nwhile (cond) { break; continue; }\nfor (let i = 0; i < 10; i++) { }\nfor (item in array) { }\nloop { if (done) { break; } }   // Loop infinito (mais claro que while(true))\nswitch (x) { case 1: break; default: break; }  // Fall-through estilo C\ndefer cleanup();         // Executa quando funo retorna\n\n// Labels de loop para break/continue direcionado em loops aninhados\nouter: while (cond) {\n    inner: for (let i = 0; i < 10; i++) {\n        if (i == 5) { break outer; }     // Sai do loop externo\n        if (i == 3) { continue outer; }  // Continua loop externo\n    }\n}\n```\n\n### Pattern Matching\n```hemlock\n// Expresso match - retorna um valor\nlet result = match (value) {\n    0 => \"zero\",                    // Padro literal\n    1 | 2 | 3 => \"small\",           // Padro OR\n    n if n < 10 => \"medium\",        // Expresso guard\n    n => \"large: \" + n              // Binding de varivel\n};\n\n// Padres de tipo\nmatch (val) {\n    n: i32 => \"integer\",\n    s: string => \"string\",\n    _ => \"other\"                    // Wildcard\n}\n\n// Desestruturao de objeto\nmatch (point) {\n    { x: 0, y: 0 } => \"origin\",\n    { x, y } => \"at \" + x + \",\" + y\n}\n\n// Desestruturao de array com rest\nmatch (arr) {\n    [] => \"empty\",\n    [first, ...rest] => \"head: \" + first,\n    _ => \"other\"\n}\n\n// Padres aninhados\nmatch (user) {\n    { name, address: { city } } => name + \" in \" + city\n}\n```\n\nVeja `docs/language-guide/pattern-matching.md` para documentao completa.\n\n### Operadores de Coalescncia Nula\n```hemlock\n// Coalescncia nula (??) - retorna lado esquerdo se no-null, seno lado direito\nlet name = user.name ?? \"Anonymous\";\nlet first = a ?? b ?? c ?? \"fallback\";\n\n// Atribuio de coalescncia nula (??=) - atribui apenas se null\nlet config = null;\nconfig ??= { timeout: 30 };    // config agora  { timeout: 30 }\nconfig ??= { timeout: 60 };    // config no muda (no-null)\n\n// Funciona com propriedades e ndices\nobj.field ??= \"default\";\narr[0] ??= \"first\";\n\n// Navegao segura (?.) - retorna null se objeto  null\nlet city = user?.address?.city;  // null se qualquer parte  null\nlet upper = name?.to_upper();    // Chamada de mtodo segura\nlet item = arr?.[0];             // Indexao segura\n```\n\n### Funes\n```hemlock\nfn add(a: i32, b: i32): i32 { return a + b; }\nfn greet(name: string, msg?: \"Hello\") { print(msg + \" \" + name); }\nlet f = fn(x) { return x * 2; };  // Annima/closure\n\n// Funes com corpo de expresso (sintaxe arrow)\nfn double(x: i32): i32 => x * 2;\nfn max(a: i32, b: i32): i32 => a > b ? a : b;\nlet square = fn(x: i32): i32 => x * x;  // Corpo de expresso annimo\n\n// Modificadores de parmetros\nfn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // Passagem por referncia\nfn print_all(const items: array) { for (i in items) { print(i); } }  // Imutvel\n```\n\n### Parmetros Nomeados\n```hemlock\n// Funes podem ser chamadas com parmetros nomeados\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" is \" + age + \" years old\");\n}\n\n// Parmetros posicionais (tradicional)\ncreate_user(\"Alice\", 25, false);\n\n// Parmetros nomeados - qualquer ordem\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n\n// Pular parmetros opcionais nomeando os desejados\ncreate_user(\"David\", active: false);  // Usa age=18 padro\n\n// Parmetros nomeados devem vir depois dos posicionais\ncreate_user(\"Eve\", age: 21);          // OK: posicional primeiro, nomeado depois\n// create_user(name: \"Bad\", 25);      // Erro: posicional depois de nomeado\n```\n\n**Regras:**\n- Parmetros nomeados usam sintaxe `name: value`\n- Podem aparecer em qualquer ordem aps parmetros posicionais\n- Parmetros posicionais no podem seguir nomeados\n- Funcionam com parmetros padro/opcionais\n- Nomes de parmetros desconhecidos causam erro de runtime\n\n### Objetos e Enums\n```hemlock\ndefine Person { name: string, age: i32, active?: true }\nlet p: Person = { name: \"Alice\", age: 30 };\nlet json = p.serialize();\nlet restored = json.deserialize();\n\n// Sintaxe abreviada de objeto (estilo ES6)\nlet name = \"Alice\";\nlet age = 30;\nlet person = { name, age };         // Igual a { name: name, age: age }\n\n// Operador spread de objeto\nlet defaults = { theme: \"dark\", size: \"medium\" };\nlet config = { ...defaults, size: \"large\" };  // Copia defaults, sobrescreve size\n\nenum Color { RED, GREEN, BLUE }\nenum Status { OK = 0, ERROR = 1 }\n```\n\n### Tipos Compostos (Interseo/Duck Typing)\n```hemlock\n// Definir tipos estruturais\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// Tipo composto: objeto deve satisfazer todos os tipos\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// Parmetros de funo com tipos compostos\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" is \" + p.age);\n}\n\n// Trs ou mais tipos\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n\n// Campos extras permitidos (duck typing)\nlet employee: HasName & HasAge = {\n    name: \"Bob\",\n    age: 25,\n    department: \"Engineering\"  // OK - campos extras ignorados\n};\n```\n\nTipos compostos fornecem comportamento similar a interfaces sem palavra-chave `interface` separada,\nconstruindo sobre os paradigmas existentes de `define` e duck typing.\n\n### Aliases de Tipo\n```hemlock\n// Alias de tipo simples\ntype Integer = i32;\ntype Text = string;\n\n// Aliases de tipo de funo\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// Aliases de tipo composto (bom para interfaces reutilizveis)\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// Aliases de tipo genrico\ntype Pair<T> = { first: T, second: T };\n\n// Usando aliases de tipo\nlet x: Integer = 42;\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\nAliases de tipo criam atalhos nomeados para tipos complexos, melhorando legibilidade e manutenibilidade.\n\n### Tipos de Funo\n```hemlock\n// Anotaes de tipo de funo para parmetros\nfn apply_fn(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Funes de alta ordem que retornam funes\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Tipos de funo async\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n\n// Tipos de funo com mltiplos parmetros\ntype BinaryOp = fn(i32, i32): i32;\nlet add: BinaryOp = fn(a, b) { return a + b; };\n```\n\n### Parmetros Const\n```hemlock\n// Parmetros const - imutabilidade profunda\nfn print_all(const items: array) {\n    // items.push(4);  // Erro: no pode modificar parmetro const\n    for (item in items) {\n        print(item);\n    }\n}\n\n// Const em objetos - no pode modificar por nenhum caminho\nfn describe(const person: object) {\n    print(person.name);       // OK: leitura permitida\n    // person.name = \"Bob\";   // Erro: no pode modificar\n}\n\n// Acesso de leitura aninhado permitido\nfn get_city(const user: object) {\n    return user.address.city;  // OK: leitura de propriedade aninhada\n}\n```\n\nO modificador `const` previne qualquer modificao ao parmetro, incluindo propriedades aninhadas.\nIsso fornece segurana em tempo de compilao para funes que no devem modificar suas entradas.\n\n### Parmetros Ref (Passagem por Referncia)\n```hemlock\n// Parmetros ref - modificar varivel do chamador diretamente\nfn increment(ref x: i32) {\n    x = x + 1;  // Modifica varivel original\n}\n\nlet count = 10;\nincrement(count);\nprint(count);  // 11 - valor original modificado\n\n// Funo swap clssica\nfn swap(ref a: i32, ref b: i32) {\n    let temp = a;\n    a = b;\n    b = temp;\n}\n\nlet x = 1;\nlet y = 2;\nswap(x, y);\nprint(x, y);  // 2 1\n\n// Misturando parmetros ref e normais\nfn add_to(ref target: i32, amount: i32) {\n    target = target + amount;\n}\n\nlet total = 100;\nadd_to(total, 50);\nprint(total);  // 150\n```\n\nO modificador `ref` passa uma referncia  varivel do chamador, permitindo que a funo a modifique diretamente.\nSem `ref`, tipos primitivos so passados por valor (copiados). Use `ref` quando precisar\nmodificar estado do chamador sem retornar um valor.\n\n**Regras:**\n- Parmetros `ref` devem receber variveis, no literais ou expresses\n- Funciona com todos os tipos (primitivos, arrays, objetos)\n- Combina com anotaes de tipo: `ref x: i32`\n- No pode combinar com `const` (so opostos)\n\n### Assinaturas de Mtodo em Define\n```hemlock\n// Define com assinaturas de mtodo (padro interface)\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32   // Assinatura de mtodo requerida\n}\n\n// Objetos devem fornecer mtodos requeridos\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// Use ? para mtodos opcionais\ndefine Serializable {\n    fn serialize(): string,        // Requerido\n    fn pretty?(): string           // Mtodo opcional\n}\n\n// Tipo Self refere-se ao tipo definido\ndefine Cloneable {\n    fn clone(): Self   // Retorna mesmo tipo que o objeto\n}\n```\n\nAssinaturas de mtodo em blocos `define` so separadas por vrgula (similar a interfaces TypeScript),\nestabelecendo contratos que objetos devem satisfazer e habilitando padres de programao tipo-interface\natravs do sistema de duck typing do Hemlock.\n\n### Tratamento de Erros\n```hemlock\ntry { throw \"error\"; } catch (e) { print(e); } finally { cleanup(); }\npanic(\"unrecoverable\");  // Sai imediatamente, no pode ser capturado\n```\n\n### Async/Concorrncia\n```hemlock\nasync fn compute(n: i32): i32 { return n * n; }\nlet task = spawn(compute, 42);\nlet result = await task;     // Ou join(task)\ndetach(spawn(background_work));\n\nlet ch = channel(10);\nch.send(value);\nlet val = ch.recv();\nch.close();\n```\n\n**Ownership de memria:** Tasks recebem cpias de valores primitivos, mas compartilham ponteiros. Se voc passa um `ptr` para uma task gerada,\nvoc deve garantir que a memria permanece vlida at a task completar. Use `join()` antes de `free()`,\nou use channels para sinalizar concluso.\n\n### Entrada de Usurio\n```hemlock\nlet name = read_line();          // L linha de stdin (bloqueante)\nprint(\"Hello, \" + name);\neprint(\"Error message\");         // Sada para stderr\n\n// read_line() retorna null em EOF\nwhile (true) {\n    let line = read_line();\n    if (line == null) { break; }\n    print(\"Got:\", line);\n}\n```\n\n### I/O de Arquivos\n```hemlock\nlet f = open(\"file.txt\", \"r\");  // Modos: r, w, a, r+, w+, a+\nlet content = f.read();\nf.write(\"data\");\nf.seek(0);\nf.close();\n```\n\n### Sinais\n```hemlock\nsignal(SIGINT, fn(sig) { print(\"Interrupted\"); });\nraise(SIGUSR1);\n```\n\n---\n\n## Mtodos de String (19)\n\n`substr`, `slice`, `find`, `contains`, `split`, `trim`, `to_upper`, `to_lower`,\n`starts_with`, `ends_with`, `replace`, `replace_all`, `repeat`, `char_at`,\n`byte_at`, `chars`, `bytes`, `to_bytes`, `deserialize`\n\nTemplate strings: `` `Hello ${name}!` ``\n\n**Mutabilidade de strings:** Strings so mutveis via atribuio por ndice (`s[0] = 'H'`), mas todos os mtodos de string\nretornam novas strings sem modificar a original. Isso permite modificao in-place quando necessrio enquanto mantm\nestilo funcional para encadeamento de mtodos.\n\n**Propriedades de comprimento de string:**\n```hemlock\nlet s = \"hello \";\nprint(s.length);       // 7 (contagem de caracteres/runes)\nprint(s.byte_length);  // 10 (contagem de bytes - emoji  4 bytes UTF-8)\n```\n\n## Mtodos de Array (18)\n\n`push`, `pop`, `shift`, `unshift`, `insert`, `remove`, `find`, `contains`,\n`slice`, `join`, `concat`, `reverse`, `first`, `last`, `clear`, `map`, `filter`, `reduce`\n\nArrays tipados: `let nums: array<i32> = [1, 2, 3];`\n\n---\n\n## Biblioteca Padro (40 mdulos)\n\nImportar com prefixo `@stdlib/`:\n```hemlock\nimport { sin, cos, PI } from \"@stdlib/math\";\nimport { HashMap, Queue, Set } from \"@stdlib/collections\";\nimport { read_file, write_file } from \"@stdlib/fs\";\nimport { TcpStream, UdpSocket } from \"@stdlib/net\";\n```\n\n| Mdulo | Descrio |\n|--------|-----------|\n| `arena` | Alocador de memria arena (alocao bump) |\n| `args` | Parsing de argumentos de linha de comando |\n| `assert` | Utilitrios de assero |\n| `async` | ThreadPool, parallel_map |\n| `async_fs` | Operaes de I/O de arquivos assncronas |\n| `collections` | HashMap, Queue, Stack, Set, LinkedList, LRUCache |\n| `compression` | gzip, gunzip, deflate |\n| `crypto` | aes_encrypt, rsa_sign, random_bytes |\n| `csv` | Parsing e gerao de CSV |\n| `datetime` | Classe DateTime, formatao, parsing |\n| `encoding` | base64_encode, hex_encode, url_encode |\n| `env` | getenv, setenv, exit, get_pid |\n| `fmt` | Utilitrios de formatao de string |\n| `fs` | read_file, write_file, list_dir, exists |\n| `glob` | Matching de padres de arquivo |\n| `hash` | sha256, sha512, md5, djb2 |\n| `http` | http_get, http_post, http_request |\n| `ipc` | Comunicao entre processos |\n| `iter` | Utilitrios de iterador |\n| `json` | parse, stringify, pretty, get, set |\n| `logging` | Logger com nveis |\n| `math` | sin, cos, sqrt, pow, rand, PI, E |\n| `net` | TcpListener, TcpStream, UdpSocket |\n| `os` | platform, arch, cpu_count, hostname |\n| `path` | Manipulao de caminhos de arquivo |\n| `process` | fork, exec, wait, kill |\n| `random` | Gerao de nmeros aleatrios |\n| `regex` | compile, test (POSIX ERE) |\n| `retry` | Lgica de retry com backoff |\n| `semver` | Versionamento semntico |\n| `shell` | Utilitrios de comandos shell |\n| `sqlite` | SQLite database, query, exec, transaes |\n| `strings` | pad_left, is_alpha, reverse, lines |\n| `terminal` | Cores e estilos ANSI |\n| `testing` | describe, test, expect |\n| `time` | now, time_ms, sleep, clock |\n| `toml` | Parsing e gerao de TOML |\n| `url` | Parsing e manipulao de URL |\n| `uuid` | Gerao de UUID |\n| `websocket` | Cliente WebSocket |\n\nVeja `stdlib/docs/` para documentao detalhada dos mdulos.\n\n---\n\n## FFI (Interface de Funo Estrangeira)\n\nDeclarar e chamar funes C de bibliotecas compartilhadas:\n```hemlock\nimport \"libc.so.6\";\n\nextern fn strlen(s: string): i32;\nextern fn getpid(): i32;\n\nlet len = strlen(\"Hello!\");  // 6\nlet pid = getpid();\n```\n\nExportar funes FFI de mdulos:\n```hemlock\n// string_utils.hml\nimport \"libc.so.6\";\n\nexport extern fn strlen(s: string): i32;\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n```\n\nFFI dinmico (binding em runtime):\n```hemlock\nlet lib = ffi_open(\"libc.so.6\");\nlet puts = ffi_bind(lib, \"puts\", [FFI_POINTER], FFI_INT);\nputs(\"Hello from C!\");\nffi_close(lib);\n```\n\nTipos: `FFI_INT`, `FFI_DOUBLE`, `FFI_POINTER`, `FFI_STRING`, `FFI_VOID`, etc.\n\n---\n\n## Operaes Atmicas\n\nUse operaes atmicas para programao concorrente sem locks:\n\n```hemlock\n// Alocar memria para i32 atmico\nlet p = alloc(4);\nptr_write_i32(p, 0);\n\n// Load/store atmico\nlet val = atomic_load_i32(p);        // Leitura atmica\natomic_store_i32(p, 42);             // Escrita atmica\n\n// Operaes fetch-and-modify (retornam valor antigo)\nlet old = atomic_add_i32(p, 10);     // Adiciona, retorna antigo\nold = atomic_sub_i32(p, 5);          // Subtrai, retorna antigo\nold = atomic_and_i32(p, 0xFF);       // AND bit a bit\nold = atomic_or_i32(p, 0x10);        // OR bit a bit\nold = atomic_xor_i32(p, 0x0F);       // XOR bit a bit\n\n// Compare-and-swap (CAS)\nlet success = atomic_cas_i32(p, 42, 100);  // Se *p == 42, seta para 100\n// Retorna true se swap ocorreu, false caso contrrio\n\n// Atomic exchange\nold = atomic_exchange_i32(p, 999);   // Troca, retorna antigo\n\nfree(p);\n\n// Variantes i64 disponveis (atomic_load_i64, atomic_add_i64, etc.)\n\n// Barreira de memria (barreira completa)\natomic_fence();\n```\n\nTodas as operaes usam consistncia sequencial (`memory_order_seq_cst`).\n\n---\n\n## Estrutura do Projeto\n\n```\nhemlock/\n src/\n    frontend/         # Compartilhado: lexer, parser, AST, mdulos\n    backends/\n       interpreter/  # hemlock: interpretador tree-walking\n       compiler/     # hemlockc: gerador de cdigo C\n    tools/\n       lsp/          # Language Server Protocol\n       bundler/      # Ferramenta de bundling/pacotes\n runtime/              # Runtime de programas compilados (libhemlock_runtime.a)\n stdlib/               # Biblioteca padro (40 mdulos)\n    docs/             # Documentao dos mdulos\n docs/                 # Documentao completa\n    language-guide/   # Tipos, strings, arrays, etc.\n    reference/        # Referncia de API\n    advanced/         # Async, FFI, sinais, etc.\n tests/                # 625+ testes\n examples/             # Programas de exemplo\n```\n\n---\n\n## Guia de Estilo de Cdigo\n\n### Constantes e Nmeros Mgicos\n\nAo adicionar constantes numricas ao cdigo C, siga estas diretrizes:\n\n1. **Definir constantes em `include/hemlock_limits.h`** - Este arquivo  o local centralizado para todos os limites de compile-time e runtime, capacidades e constantes nomeadas.\n\n2. **Usar nomes descritivos com prefixo `HML_`** - Todas as constantes devem ser prefixadas com `HML_` para namespace claro.\n\n3. **Evitar nmeros mgicos** - Substituir valores numricos hardcoded com constantes nomeadas. Exemplos:\n   - Limites de intervalo de tipos: `HML_I8_MIN`, `HML_I8_MAX`, `HML_U32_MAX`\n   - Capacidades de buffer: `HML_INITIAL_ARRAY_CAPACITY`, `HML_INITIAL_LEXER_BUFFER_CAPACITY`\n   - Converses de tempo: `HML_NANOSECONDS_PER_SECOND`, `HML_MILLISECONDS_PER_SECOND`\n   - Seeds de hash: `HML_DJB2_HASH_SEED`\n   - Valores ASCII: `HML_ASCII_CASE_OFFSET`, `HML_ASCII_PRINTABLE_START`\n\n4. **Incluir `hemlock_limits.h`** - Arquivos fonte devem incluir este header (tipicamente via `internal.h`) para acessar constantes.\n\n5. **Documentar propsito** - Adicionar comentrios explicando o que cada constante representa.\n\n---\n\n## Proibies\n\n- Adicionar comportamento implcito (ASI, GC, limpeza automtica)\n- Esconder complexidade (otimizaes mgicas, contagem de referncia oculta)\n- Quebrar semntica existente (ponto e vrgula, memria manual, strings mutveis)\n- Perder preciso em converses implcitas\n- Usar nmeros mgicos - em vez disso, defina constantes nomeadas em `hemlock_limits.h`\n\n---\n\n## Testes\n\n```bash\nmake test              # Executar testes do interpretador\nmake test-compiler     # Executar testes do compilador\nmake parity            # Executar testes de paridade (ambos devem coincidir)\nmake test-all          # Executar todas as sutes de teste\n```\n\n**Importante:** Testes podem travar devido a problemas de async/concorrncia. Sempre use timeout ao executar testes:\n```bash\ntimeout 60 make test   # Timeout de 60 segundos\ntimeout 120 make parity\n```\n\nCategorias de testes: primitives, memory, strings, arrays, functions, objects, async, ffi, defer, signals, switch, bitwise, typed_arrays, modules, stdlib_*\n\n---\n\n## Arquitetura Compilador/Interpretador\n\nHemlock tem dois backends de execuo que compartilham um frontend comum:\n\n```\nFonte (.hml)\n    \n\n  Frontend Compartilhado      \n  - Lexer (src/frontend/)     \n  - Parser (src/frontend/)    \n  - AST (src/frontend/)       \n\n                        \n    \n Interpretador    Compilador  \n (hemlock)        (hemlockc)  \n                              \n Tree-walking     Type check  \n Avaliao        AST  C     \n                  gcc link    \n    \n```\n\n### Verificao de Tipos do Compilador\n\nO compilador (`hemlockc`) inclui verificao de tipos em compile-time, **habilitada por padro**:\n\n```bash\nhemlockc program.hml -o program    # Verifica tipos, depois compila\nhemlockc --check program.hml       # Apenas verifica tipos, no compila\nhemlockc --no-type-check prog.hml  # Desabilita verificao de tipos\nhemlockc --strict-types prog.hml   # Avisa sobre tipos 'any' implcitos\n```\n\nO verificador de tipos:\n- Valida anotaes de tipo em compile-time\n- Trata cdigo sem tipos como dinmico (tipo `any`) - sempre vlido\n- Fornece dicas de otimizao para unboxing\n- Usa converso numrica permissiva (intervalos validados em runtime)\n\n### Estrutura de Diretrios\n\n```\nhemlock/\n src/\n    frontend/           # Compartilhado: lexer, parser, AST, mdulos\n       lexer.c\n       parser/\n       ast.c\n       module.c\n    backends/\n       interpreter/    # hemlock: interpretador tree-walking\n          main.c\n          runtime/\n          builtins/\n       compiler/       # hemlockc: gerador de cdigo C\n           main.c\n           codegen/\n    tools/\n       lsp/            # Language server\n       bundler/        # Ferramenta de bundling/pacotes\n runtime/                # libhemlock_runtime.a para programas compilados\n stdlib/                 # Biblioteca padro compartilhada\n tests/\n     parity/             # Testes que devem passar em ambos backends\n     interpreter/        # Testes especficos do interpretador\n     compiler/           # Testes especficos do compilador\n```\n\n---\n\n## Desenvolvimento Parity-First\n\n**Interpretador e compilador devem produzir sada idntica para a mesma entrada.**\n\n### Estratgia de Desenvolvimento\n\nAo adicionar ou modificar recursos da linguagem:\n\n1. **Design** - Definir mudanas de AST/semntica no frontend compartilhado\n2. **Implementar Interpretador** - Adicionar avaliao tree-walking\n3. **Implementar Compilador** - Adicionar gerao de cdigo C\n4. **Adicionar Testes de Paridade** - Escrever testes em `tests/parity/` com arquivos `.expected`\n5. **Verificar** - Executar `make parity` antes de merge\n\n### Estrutura de Testes de Paridade\n\n```\ntests/parity/\n language/       # Recursos core da linguagem (fluxo de controle, closures, etc.)\n builtins/       # Funes builtin (print, typeof, memory, etc.)\n methods/        # Mtodos de string e array\n modules/        # import/export, imports de stdlib\n```\n\nCada teste tem dois arquivos:\n- `feature.hml` - Programa de teste\n- `feature.expected` - Sada esperada (ambos backends devem coincidir)\n\n### Resultados de Testes de Paridade\n\n| Status | Significado |\n|--------|-------------|\n| `PASSED` | Interpretador e compilador coincidem com sada esperada |\n| `INTERP_ONLY` | Interpretador funciona, compilador falha (precisa corrigir compilador) |\n| `COMPILER_ONLY` | Compilador funciona, interpretador falha (raro) |\n| `FAILED` | Ambos falham (erro de teste ou implementao) |\n\n### O que Precisa de Paridade\n\n- Todas as construes de linguagem (if, while, for, switch, defer, try/catch)\n- Todos os operadores (aritmticos, bit a bit, lgicos, comparao)\n- Todas as funes builtin (print, typeof, alloc, etc.)\n- Todos os mtodos de string e array\n- Regras de coero e promoo de tipos\n- Mensagens de erro para erros de runtime\n\n### O que Pode Diferir\n\n- Caractersticas de performance\n- Detalhes de layout de memria\n- Formato de debug/stack trace\n- Erros de compilao (compilador pode capturar mais em compile-time)\n\n### Adicionando Testes de Paridade\n\n```bash\n# 1. Criar arquivo de teste\ncat > tests/parity/language/my_feature.hml << 'EOF'\n// Descrio do teste\nlet x = some_feature();\nprint(x);\nEOF\n\n# 2. Gerar sada esperada do interpretador\n./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected\n\n# 3. Verificar paridade\nmake parity\n```\n\n---\n\n## Verso\n\n**v1.8.0** - Recursos da verso atual:\n- **Pattern Matching** (expresses `match`) - Desestruturao poderosa e fluxo de controle:\n  - Padres literal, wildcard e binding de varivel\n  - Padres OR (`1 | 2 | 3`)\n  - Expresses guard (`n if n > 0`)\n  - Desestruturao de objeto (`{ x, y }`)\n  - Desestruturao de array com rest (`[first, ...rest]`)\n  - Padres de tipo (`n: i32`)\n  - Paridade total entre interpretador e compilador\n- **Anotaes de Assistncia ao Compilador** - 11 anotaes de otimizao para controle de GCC/Clang:\n  - `@inline`, `@noinline` - Controle de inlining de funo\n  - `@hot`, `@cold` - Dicas de predio de branch\n  - `@pure`, `@const` - Anotaes de side-effect\n  - `@flatten` - Inline todas as chamadas dentro da funo\n  - `@optimize(level)` - Nvel de otimizao por funo (\"0\", \"1\", \"2\", \"3\", \"s\", \"fast\")\n  - `@warn_unused` - Aviso quando valor de retorno  ignorado\n  - `@section(name)` - Colocao de seo ELF customizada (ex: `@section(\".text.hot\")`)\n- **Funes com corpo de expresso** (`fn double(x): i32 => x * 2;`) - Sintaxe concisa para funes de expresso nica\n- **Statements de linha nica** - Sintaxe sem chaves para `if`, `while`, `for` (ex: `if (x > 0) print(x);`)\n- **Aliases de tipo** (`type Name = Type;`) - Atalhos nomeados para tipos complexos\n- **Anotaes de tipo de funo** (`fn(i32): i32`) - Tipos de funo de primeira classe\n- **Parmetros const** (`fn(const x: array)`) - Imutabilidade profunda para parmetros\n- **Parmetros ref** (`fn(ref x: i32)`) - Passagem por referncia para modificar chamador diretamente\n- **Assinaturas de mtodo em define** (`fn method(): Type`) - Contratos tipo-interface (separados por vrgula)\n- **Tipo Self** em assinaturas de mtodo - Referncia ao tipo definido\n- **Palavra-chave loop** (`loop { }`) - Loop infinito mais claro, substitui `while (true)`\n- **Labels de loop** (`outer: while`) - Break/continue direcionado para loops aninhados\n- **Abreviao de objeto** (`{ name }`) - Sintaxe de propriedade abreviada estilo ES6\n- **Spread de objeto** (`{ ...obj }`) - Copiar e mesclar campos de objeto\n- **Duck typing composto** (`A & B & C`) - Tipos de interseo para tipos estruturais\n- **Parmetros nomeados** para chamadas de funo (`foo(name: \"value\", age: 30)`)\n- **Operadores de coalescncia nula** (`??`, `??=`, `?.`) para tratamento seguro de null\n- **Literais octais** (`0o777`, `0O123`)\n- **Separadores de dgitos** (`1_000_000`, `0xFF_FF`, `0b1111_0000`)\n- **Comentrios de bloco** (`/* ... */`)\n- **Sequncias de escape hex** em strings/runes (`\\x41` = 'A')\n- **Sequncias de escape Unicode** em strings (`\\u{1F600}` = )\n- **Literais float sem zero inicial** (`.5`, `.123`, `.5e2`)\n- **Verificao de tipos em compile-time** em hemlockc (habilitada por padro)\n- **Integrao LSP** com verificao de tipos com diagnsticos em tempo real\n- **Operadores de atribuio composta** (`+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`)\n- **Operadores de incremento/decremento** (`++x`, `x++`, `--x`, `x--`)\n- **Correo de preciso de tipos**: i64/u64 + f32  f64 para manter preciso\n- Sistema de tipos unificado com dicas de otimizao de unboxing\n- Sistema de tipos completo (i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object, enum, file, task, channel)\n- Strings UTF-8 com 19 mtodos\n- Arrays com 18 mtodos incluindo map/filter/reduce\n- Gerenciamento manual de memria com `talloc()` e `sizeof()`\n- Async/await com paralelismo pthread real\n- Operaes atmicas para programao concorrente sem locks\n- 40 mdulos de stdlib (+ arena, assert, semver, toml, retry, iter, random, shell)\n- FFI para interop com C, com `export extern fn` para wrappers de biblioteca reutilizveis\n- Suporte a struct FFI no compilador (passando structs C por valor)\n- Helpers de ponteiro FFI (`ptr_null`, `ptr_read_*`, `ptr_write_*`)\n- defer, try/catch/finally/throw, panic\n- I/O de arquivos, tratamento de sinais, execuo de comandos\n- Gerenciador de pacotes [hpm](https://github.com/hemlang/hpm) com registry baseado em GitHub\n- Backend de compilador (gerao de cdigo C), 100% paridade com interpretador\n- Servidor LSP com jump-to-definition e find-references\n- Passes de otimizao de AST e resoluo de variveis para lookup O(1)\n- Builtin apply() para chamadas de funo dinmicas\n- Channels sem buffer e suporte a mltiplos argumentos\n- 159 testes de paridade (100% taxa de aprovao)\n\n---\n\n## Filosofia\n\n> Ns fornecemos ferramentas seguras (`buffer`, anotaes de tipo, verificao de limites), mas no foramos voc a us-las (`ptr`, memria manual, operaes no-seguras).\n\n**Se voc no tem certeza se um recurso cabe no Hemlock, pergunte-se: \"Isso d ao programador mais controle explcito, ou esconde algo?\"**\n\nSe esconde, provavelmente no pertence ao Hemlock.\n"}, "Primeiros Passos -> Caminhos de Aprendizado": {"id": "getting-started-learning-paths", "content": "# Caminhos de Aprendizado\n\nObjetivos diferentes requerem conhecimentos diferentes. Escolha o caminho que corresponde ao que voce deseja construir.\n\n---\n\n## Caminho 1: Scripts Rapidos e Automacao\n\n**Objetivo:** Escrever scripts para automatizar tarefas, processar arquivos e fazer o trabalho.\n\n**Tempo para produtividade:** Rapido - voce pode comecar a escrever scripts uteis imediatamente.\n\n### O Que Voce Aprendera\n\n1. **[Inicio Rapido](#getting-started-quick-start)** - Seu primeiro programa, sintaxe basica\n2. **[Strings](#language-guide-strings)** - Processamento de texto, divisao, busca\n3. **[Arrays](#language-guide-arrays)** - Listas, filtragem, transformacao de dados\n4. **[E/S de Arquivos](#advanced-file-io)** - Ler e escrever arquivos\n5. **[Argumentos de Linha de Comando](#advanced-command-line-args)** - Obter entrada do usuario\n\n### Pule Por Enquanto\n\n- Gerenciamento de memoria (scripts lidam automaticamente)\n- Async/concorrencia (muito complexo para scripts simples)\n- FFI (so necessario quando precisar de interoperabilidade com C)\n\n### Projeto de Exemplo: Renomeador de Arquivos\n\n```hemlock\nimport { list_dir, rename } from \"@stdlib/fs\";\n\n// Renomeia todos os arquivos .txt para .md\nlet files = list_dir(\".\");\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let new_name = file.replace(\".txt\", \".md\");\n        rename(file, new_name);\n        print(`Renomeado: ${file} -> ${new_name}`);\n    }\n}\n```\n\n---\n\n## Caminho 2: Processamento e Analise de Dados\n\n**Objetivo:** Analisar dados, transforma-los e gerar relatorios.\n\n**Tempo para produtividade:** Rapido - os metodos de string e array do Hemlock tornam isso facil.\n\n### O Que Voce Aprendera\n\n1. **[Inicio Rapido](#getting-started-quick-start)** - Fundamentos\n2. **[Strings](#language-guide-strings)** - Analise, divisao, formatacao\n3. **[Arrays](#language-guide-arrays)** - map, filter, reduce para transformacao de dados\n4. **[Objetos](#language-guide-objects)** - Dados estruturados\n5. **Biblioteca Padrao:**\n   - **[@stdlib/json](#stdlib-json)** - Analise de JSON\n   - **[@stdlib/csv](#stdlib-csv)** - Arquivos CSV\n   - **[@stdlib/fs](#stdlib-fs)** - Operacoes de arquivo\n\n### Projeto de Exemplo: Analisador de CSV\n\n```hemlock\nimport { read_file } from \"@stdlib/fs\";\nimport { parse } from \"@stdlib/csv\";\n\nlet data = parse(read_file(\"sales.csv\"));\n\n// Calcular vendas totais\nlet total = 0;\nfor (row in data) {\n    total = total + f64(row.amount);\n}\n\nprint(`Vendas totais: R$${total}`);\n\n// Encontrar maior venda\nlet top = data[0];\nfor (row in data) {\n    if (f64(row.amount) > f64(top.amount)) {\n        top = row;\n    }\n}\n\nprint(`Maior venda: ${top.product} - R$${top.amount}`);\n```\n\n---\n\n## Caminho 3: Programacao Web e de Rede\n\n**Objetivo:** Construir clientes HTTP, usar APIs, criar servidores.\n\n**Tempo para produtividade:** Medio - requer entender o basico de async.\n\n### O Que Voce Aprendera\n\n1. **[Inicio Rapido](#getting-started-quick-start)** - Fundamentos\n2. **[Funcoes](#language-guide-functions)** - Callbacks e closures\n3. **[Tratamento de Erros](#language-guide-error-handling)** - try/catch para erros de rede\n4. **[Async e Concorrencia](#advanced-async-concurrency)** - spawn, await, channels\n5. **Biblioteca Padrao:**\n   - **[@stdlib/http](#stdlib-http)** - Requisicoes HTTP\n   - **[@stdlib/json](#stdlib-json)** - JSON para APIs\n   - **[@stdlib/net](#stdlib-net)** - Sockets TCP/UDP\n   - **[@stdlib/url](#stdlib-url)** - Analise de URL\n\n### Projeto de Exemplo: Cliente de API\n\n```hemlock\nimport { http_get, http_post } from \"@stdlib/http\";\nimport { parse, stringify } from \"@stdlib/json\";\n\n// Requisicao GET\nlet response = http_get(\"https://api.example.com/users\");\nlet users = parse(response.body);\n\nfor (user in users) {\n    print(`${user.name}: ${user.email}`);\n}\n\n// Requisicao POST\nlet new_user = { name: \"Alice\", email: \"alice@example.com\" };\nlet result = http_post(\"https://api.example.com/users\", {\n    body: stringify(new_user),\n    headers: { \"Content-Type\": \"application/json\" }\n});\n\nprint(`ID do usuario criado: ${parse(result.body).id}`);\n```\n\n---\n\n## Caminho 4: Programacao de Sistemas\n\n**Objetivo:** Escrever codigo de baixo nivel, manipular memoria, interagir com bibliotecas C.\n\n**Tempo para produtividade:** Mais longo - requer entender gerenciamento de memoria.\n\n### O Que Voce Aprendera\n\n1. **[Inicio Rapido](#getting-started-quick-start)** - Fundamentos\n2. **[Tipos](#language-guide-types)** - Entender i32, u8, ptr, etc.\n3. **[Gerenciamento de Memoria](#language-guide-memory)** - alloc, free, buffers\n4. **[FFI](#advanced-ffi)** - Chamar funcoes C\n5. **[Sinais](#advanced-signals)** - Tratamento de sinais\n\n### Conceitos-Chave\n\n**Lista de Verificacao de Seguranca de Memoria:**\n- [ ] Cada `alloc()` tem um `free()` correspondente\n- [ ] Use `buffer()` a menos que precise de `ptr` bruto\n- [ ] Defina ponteiros para `null` apos liberar\n- [ ] Use `try/finally` para garantir limpeza\n\n**Mapeamento de Tipos FFI:**\n| Hemlock | C |\n|---------|---|\n| `i8` | `char` / `int8_t` |\n| `i32` | `int` |\n| `i64` | `long` (64-bit) |\n| `u8` | `unsigned char` |\n| `f64` | `double` |\n| `ptr` | `void*` |\n\n### Projeto de Exemplo: Pool de Memoria Personalizado\n\n```hemlock\n// Alocador bump simples\nlet pool_size = 1024 * 1024;  // 1MB\nlet pool = alloc(pool_size);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > pool_size) {\n        throw \"Pool de memoria esgotado\";\n    }\n    let p = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return p;\n}\n\nfn pool_reset() {\n    pool_offset = 0;\n}\n\nfn pool_destroy() {\n    free(pool);\n}\n\n// Usando\nlet a = pool_alloc(100);\nlet b = pool_alloc(200);\nmemset(a, 0, 100);\nmemset(b, 0, 200);\n\npool_reset();  // Reutilizar toda a memoria\npool_destroy();  // Limpar\n```\n\n---\n\n## Caminho 5: Programas Paralelos e Concorrentes\n\n**Objetivo:** Executar codigo em multiplos nucleos de CPU, construir aplicacoes responsivas.\n\n**Tempo para produtividade:** Medio - a sintaxe async e simples, mas o pensamento paralelo requer pratica.\n\n### O Que Voce Aprendera\n\n1. **[Inicio Rapido](#getting-started-quick-start)** - Fundamentos\n2. **[Funcoes](#language-guide-functions)** - Closures (importantes para async)\n3. **[Async e Concorrencia](#advanced-async-concurrency)** - Aprofundamento completo\n4. **[Operacoes Atomicas](#advanced-atomics)** - Programacao lock-free\n\n### Conceitos-Chave\n\n**Modelo Async do Hemlock:**\n- `async fn` - Define uma funcao que pode executar em outra thread\n- `spawn(fn, args...)` - Inicia a execucao, retorna um handle de tarefa\n- `join(task)` ou `await task` - Espera completar, obtem o resultado\n- `channel(size)` - Cria uma fila para enviar dados entre tarefas\n\n**Importante:** Tarefas recebem *copias* dos valores. Se voce passar um ponteiro, e responsavel por garantir que a memoria permaneca valida ate a tarefa terminar.\n\n### Projeto de Exemplo: Processador de Arquivos Paralelo\n\n```hemlock\nimport { list_dir, read_file } from \"@stdlib/fs\";\n\nasync fn process_file(path: string): i32 {\n    let content = read_file(path);\n    let lines = content.split(\"\\n\");\n    return lines.length;\n}\n\n// Processar todos os arquivos em paralelo\nlet files = list_dir(\"data/\");\nlet tasks = [];\n\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let task = spawn(process_file, \"data/\" + file);\n        tasks.push({ name: file, task: task });\n    }\n}\n\n// Coletar resultados\nlet total_lines = 0;\nfor (item in tasks) {\n    let count = join(item.task);\n    print(`${item.name}: ${count} linhas`);\n    total_lines = total_lines + count;\n}\n\nprint(`Total: ${total_lines} linhas`);\n```\n\n---\n\n## O Que Aprender Primeiro em Qualquer Caminho\n\nIndependente do seu objetivo, comece com estes fundamentos:\n\n### Semana 1: Fundamentos Essenciais\n1. **[Inicio Rapido](#getting-started-quick-start)** - Escreva e execute seu primeiro programa\n2. **[Sintaxe](#language-guide-syntax)** - Variaveis, operadores, fluxo de controle\n3. **[Funcoes](#language-guide-functions)** - Definir e chamar funcoes\n\n### Semana 2: Processamento de Dados\n4. **[Strings](#language-guide-strings)** - Manipulacao de texto\n5. **[Arrays](#language-guide-arrays)** - Colecoes e iteracao\n6. **[Objetos](#language-guide-objects)** - Dados estruturados\n\n### Semana 3: Robustez\n7. **[Tratamento de Erros](#language-guide-error-handling)** - try/catch/throw\n8. **[Modulos](#language-guide-modules)** - import/export, usando a biblioteca padrao\n\n### Depois: Escolha seu Caminho Acima\n\n---\n\n## Guia Rapido: Vindo de Outras Linguagens\n\n### Vindo do Python\n\n| Python | Hemlock | Notas |\n|--------|---------|-------|\n| `x = 42` | `let x = 42;` | Ponto e virgula obrigatorio |\n| `def fn():` | `fn name() { }` | Chaves obrigatorias |\n| `if x:` | `if (x) { }` | Parenteses e chaves obrigatorios |\n| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | Laco for estilo C |\n| `for item in list:` | `for (item in array) { }` | for-in igual |\n| `list.append(x)` | `array.push(x);` | Nomes de metodos diferentes |\n| `len(s)` | `s.length` ou `len(s)` | Ambos funcionam |\n| Memoria automatica | `ptr` requer gerenciamento manual | A maioria dos tipos e limpa automaticamente |\n\n### Vindo do JavaScript\n\n| JavaScript | Hemlock | Notas |\n|------------|---------|-------|\n| `let x = 42` | `let x = 42;` | Igual (ponto e virgula obrigatorio) |\n| `const x = 42` | `let x = 42;` | Sem palavra-chave const |\n| `function fn()` | `fn name() { }` | Palavra-chave diferente |\n| `() => x` | `fn() { return x; }` | Sem arrow functions |\n| `async/await` | `async/await` | Mesma sintaxe |\n| `Promise` | `spawn/join` | Modelo diferente |\n| GC automatico | `ptr` requer gerenciamento manual | A maioria dos tipos e limpa automaticamente |\n\n### Vindo do C/C++\n\n| C | Hemlock | Notas |\n|---|---------|-------|\n| `int x = 42;` | `let x: i32 = 42;` | Tipo apos dois-pontos |\n| `malloc(n)` | `alloc(n)` | Mesmo conceito |\n| `free(p)` | `free(p)` | Igual |\n| `char* s = \"hi\"` | `let s = \"hi\";` | Strings sao gerenciadas |\n| `#include` | `import { } from` | Importacao de modulos |\n| Tudo manual | A maioria automatica | Apenas `ptr` requer gerenciamento manual |\n\n---\n\n## Obtendo Ajuda\n\n- **[Glossario](../glossary.md)** - Definicoes de termos de programacao\n- **[Exemplos](../../examples/)** - Programas funcionais completos\n- **[Testes](../../tests/)** - Veja como os recursos sao usados\n- **Issues no GitHub** - Faca perguntas, reporte bugs\n\n---\n\n## Niveis de Dificuldade\n\nAo longo da documentacao, voce vera estas marcacoes:\n\n| Marcacao | Significado |\n|----------|-------------|\n| **Iniciante** | Nao requer experiencia previa em programacao |\n| **Intermediario** | Assume conhecimento basico de programacao |\n| **Avancado** | Requer entendimento de conceitos de sistemas |\n\nSe algo marcado como \"Iniciante\" estiver confuso, consulte o [Glossario](../glossary.md) para definicoes de termos.\n"}, "Primeiros Passos -> Instalao": {"id": "getting-started-installation", "content": "# Guia de Instalacao\n\nEste guia ira ajuda-lo a compilar e instalar o Hemlock em seu sistema.\n\n## Instalacao Rapida (Recomendado)\n\nA maneira mais simples de instalar o Hemlock e usando o script de instalacao de uma linha:\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash\n```\n\nIsso ira baixar e instalar o binario pre-compilado mais recente para sua plataforma (Linux ou macOS, x86_64 ou arm64).\n\n### Opcoes de Instalacao\n\n```bash\n# Instalar em um prefixo personalizado (padrao: ~/.local)\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local\n\n# Instalar uma versao especifica\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0\n\n# Instalar e atualizar automaticamente o PATH do shell\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path\n```\n\nApos a instalacao, verifique se esta funcionando corretamente:\n\n```bash\nhemlock --version\n```\n\n---\n\n## Compilar a Partir do Codigo-Fonte\n\nSe voce preferir compilar a partir do codigo-fonte, ou se os binarios pre-compilados nao estao disponiveis para seu sistema, siga as instrucoes abaixo.\n\n## Pre-requisitos\n\n### Dependencias Necessarias\n\nA compilacao do Hemlock requer as seguintes dependencias:\n\n- **Compilador C**: GCC ou Clang (padrao C11)\n- **Make**: GNU Make\n- **libffi**: Biblioteca de interface de funcoes externas (para suporte FFI)\n- **OpenSSL**: Biblioteca de criptografia (para funcoes hash: md5, sha1, sha256)\n- **libwebsockets**: Suporte a WebSocket e cliente/servidor HTTP\n- **zlib**: Biblioteca de compressao\n\n### Instalando Dependencias\n\n**macOS:**\n```bash\n# Se ainda nao estiver instalado, instale o Homebrew primeiro\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Instale as ferramentas de linha de comando do Xcode\nxcode-select --install\n\n# Instale as dependencias via Homebrew\nbrew install libffi openssl@3 libwebsockets\n```\n\n**Nota para usuarios macOS**: O Makefile detecta automaticamente a instalacao do Homebrew e configura os caminhos corretos de include/library. O Hemlock suporta arquiteturas Intel (x86_64) e Apple Silicon (arm64).\n\n**Ubuntu/Debian:**\n```bash\nsudo apt-get update\nsudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev\n```\n\n**Fedora/RHEL:**\n```bash\nsudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel\n```\n\n**Arch Linux:**\n```bash\nsudo pacman -S base-devel libffi openssl libwebsockets zlib\n```\n\n## Compilar a Partir do Codigo-Fonte\n\n### 1. Clonar o Repositorio\n\n```bash\ngit clone https://github.com/hemlang/hemlock.git\ncd hemlock\n```\n\n### 2. Compilar o Hemlock\n\n```bash\nmake\n```\n\nIsso ira compilar o interpretador Hemlock e colocar o executavel no diretorio atual.\n\n### 3. Verificar a Instalacao\n\n```bash\n./hemlock --version\n```\n\nVoce devera ver as informacoes de versao do Hemlock.\n\n### 4. Testar a Compilacao\n\nExecute a suite de testes para garantir que tudo esta funcionando corretamente:\n\n```bash\nmake test\n```\n\nTodos os testes devem passar. Se voce encontrar alguma falha, por favor reporte como uma issue.\n\n## Instalacao em Nivel de Sistema (Opcional)\n\nPara instalar o Hemlock em nivel de sistema (por exemplo, em `/usr/local/bin`):\n\n```bash\nsudo make install\n```\n\nIsso permite executar `hemlock` de qualquer local sem especificar o caminho completo.\n\n## Executar o Hemlock\n\n### REPL Interativo\n\nInicie o laco de leitura-avaliacao-impressao (REPL):\n\n```bash\n./hemlock\n```\n\nVoce vera um prompt onde pode digitar codigo Hemlock:\n\n```\nHemlock REPL\n> print(\"Hello, World!\");\nHello, World!\n> let x = 42;\n> print(x * 2);\n84\n>\n```\n\nUse `Ctrl+D` ou `Ctrl+C` para sair do REPL.\n\n### Executar Programas\n\nExecute um script Hemlock:\n\n```bash\n./hemlock program.hml\n```\n\nCom argumentos de linha de comando:\n\n```bash\n./hemlock program.hml arg1 arg2 \"argumento com espacos\"\n```\n\n## Estrutura de Diretorios\n\nApos a compilacao, seu diretorio Hemlock tera esta aparencia:\n\n```\nhemlock/\n hemlock           # Executavel do interpretador compilado\n src/              # Codigo-fonte\n include/          # Arquivos de cabecalho\n tests/            # Suite de testes\n examples/         # Programas de exemplo\n docs/             # Documentacao\n stdlib/           # Biblioteca padrao\n Makefile          # Configuracao de compilacao\n README.md         # Descricao do projeto\n```\n\n## Opcoes de Compilacao\n\n### Compilacao de Depuracao\n\nCompilar com simbolos de depuracao e sem otimizacao:\n\n```bash\nmake debug\n```\n\n### Limpar Compilacao\n\nRemover todos os arquivos compilados:\n\n```bash\nmake clean\n```\n\nRecompilar do zero:\n\n```bash\nmake clean && make\n```\n\n## Solucao de Problemas\n\n### macOS: Erro de Biblioteca Nao Encontrada\n\nSe voce receber erros sobre bibliotecas ausentes (`-lcrypto`, `-lffi`, etc.):\n\n1. Certifique-se de que as dependencias do Homebrew estao instaladas:\n   ```bash\n   brew install libffi openssl@3 libwebsockets\n   ```\n\n2. Verifique os caminhos do Homebrew:\n   ```bash\n   brew --prefix libffi\n   brew --prefix openssl\n   ```\n\n3. O Makefile deve detectar esses caminhos automaticamente. Se nao detectar, verifique se `brew` esta no seu PATH:\n   ```bash\n   which brew\n   ```\n\n### macOS: Erros de Tipo BSD (`u_int`, `u_char` nao encontrados)\n\nSe voce ver erros sobre nomes de tipo desconhecidos como `u_int` ou `u_char`:\n\n1. Isso foi corrigido na versao v1.0.0+ usando `_DARWIN_C_SOURCE` em vez de `_POSIX_C_SOURCE`\n2. Certifique-se de ter a versao mais recente do codigo\n3. Limpe e recompile:\n   ```bash\n   make clean && make\n   ```\n\n### Linux: libffi Nao Encontrada\n\nSe voce receber erros sobre `ffi.h` ou `-lffi` ausentes:\n\n1. Certifique-se de que `libffi-dev` esta instalado (veja as dependencias acima)\n2. Verifique se `pkg-config` consegue encontra-la:\n   ```bash\n   pkg-config --cflags --libs libffi\n   ```\n3. Se nao for encontrada, voce pode precisar definir `PKG_CONFIG_PATH`:\n   ```bash\n   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH\n   ```\n\n### Erros de Compilacao\n\nSe voce encontrar erros de compilacao:\n\n1. Certifique-se de ter um compilador compativel com C11\n2. No macOS, tente usar Clang (padrao):\n   ```bash\n   make CC=clang\n   ```\n3. No Linux, tente usar GCC:\n   ```bash\n   make CC=gcc\n   ```\n4. Verifique se todas as dependencias estao instaladas\n5. Tente recompilar do zero:\n   ```bash\n   make clean && make\n   ```\n\n### Falha nos Testes\n\nSe os testes falharem:\n\n1. Verifique se voce tem a versao mais recente do codigo\n2. Tente recompilar do zero:\n   ```bash\n   make clean && make test\n   ```\n3. No macOS, certifique-se de ter as ferramentas de linha de comando do Xcode mais recentes:\n   ```bash\n   xcode-select --install\n   ```\n4. Reporte a issue no GitHub, incluindo:\n   - Sua plataforma (versao do macOS / distribuicao Linux)\n   - Arquitetura (x86_64 / arm64)\n   - Saida do teste\n   - Saida de `make -v` e `gcc --version` (ou `clang --version`)\n\n## Proximos Passos\n\n- [Guia de Inicio Rapido](#getting-started-quick-start) - Escreva seu primeiro programa Hemlock\n- [Tutorial](#getting-started-tutorial) - Aprenda Hemlock passo a passo\n- [Guia da Linguagem](#language-guide-syntax) - Explore os recursos do Hemlock\n"}, "Primeiros Passos -> Incio Rpido": {"id": "getting-started-quick-start", "content": "# Inicio Rapido\n\nComece a usar o Hemlock em poucos minutos!\n\n## Seu Primeiro Programa\n\nCrie um arquivo chamado `hello.hml`:\n\n```hemlock\nprint(\"Hello, Hemlock!\");\n```\n\nExecute com o interpretador:\n\n```bash\n./hemlock hello.hml\n```\n\nOu compile para um executavel nativo:\n\n```bash\n./hemlockc hello.hml -o hello\n./hello\n```\n\nSaida:\n```\nHello, Hemlock!\n```\n\n### Interpretador vs Compilador\n\nO Hemlock oferece duas maneiras de executar programas:\n\n| Ferramenta | Caso de Uso | Verificacao de Tipos |\n|------------|-------------|----------------------|\n| `hemlock` | Scripts rapidos, REPL, desenvolvimento | Apenas em tempo de execucao |\n| `hemlockc` | Binarios de producao, melhor desempenho | Em tempo de compilacao (padrao) |\n\nO compilador (`hemlockc`) verifica os tipos do seu codigo antes de gerar o executavel, capturando erros antecipadamente.\n\n## Sintaxe Basica\n\n### Variaveis\n\n```hemlock\n// Use 'let' para declarar variaveis\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\n// Anotacoes de tipo sao opcionais\nlet count: i32 = 100;\nlet ratio: f64 = 0.618;\n```\n\n**Importante**: Ponto e virgula e **obrigatorio** no Hemlock!\n\n### Tipos\n\nO Hemlock possui um sistema de tipos rico:\n\n```hemlock\n// Inteiros\nlet small: i8 = 127;          // 8 bits com sinal\nlet byte: u8 = 255;           // 8 bits sem sinal\nlet num: i32 = 2147483647;    // 32 bits com sinal (padrao)\nlet big: i64 = 9223372036854775807;  // 64 bits com sinal\n\n// Ponto flutuante\nlet f: f32 = 3.14;            // 32 bits ponto flutuante\nlet d: f64 = 2.71828;         // 64 bits ponto flutuante (padrao)\n\n// Strings e caracteres\nlet text: string = \"Hello\";   // String UTF-8\nlet emoji: rune = '';       // Ponto de codigo Unicode\n\n// Booleano e nulo\nlet flag: bool = true;\nlet empty = null;\n```\n\n### Fluxo de Controle\n\n```hemlock\n// Instrucao if\nif (x > 0) {\n    print(\"Positivo\");\n} else if (x < 0) {\n    print(\"Negativo\");\n} else {\n    print(\"Zero\");\n}\n\n// Laco while\nlet i = 0;\nwhile (i < 5) {\n    print(i);\n    i = i + 1;\n}\n\n// Laco for\nfor (let j = 0; j < 10; j = j + 1) {\n    print(j);\n}\n```\n\n### Funcoes\n\n```hemlock\n// Funcao nomeada\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nlet result = add(5, 3);  // 8\n\n// Funcao anonima\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(multiply(4, 7));  // 28\n```\n\n## Operacoes com Strings\n\nStrings no Hemlock sao **mutaveis** e codificadas em **UTF-8**:\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';              // Agora e \"Hello\"\nprint(s);\n\n// Metodos de string\nlet upper = s.to_upper();     // \"HELLO\"\nlet words = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\nlet sub = s.substr(1, 3);     // \"ell\"\n\n// Concatenacao\nlet greeting = \"Hello\" + \", \" + \"World!\";\nprint(greeting);  // \"Hello, World!\"\n```\n\n## Arrays\n\nArrays dinamicos com suporte a tipos mistos:\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Metodos de array\nnumbers.push(6);        // [1, 2, 3, 4, 5, 6]\nlet last = numbers.pop();  // 6\nlet slice = numbers.slice(1, 4);  // [2, 3, 4]\n\n// Tipos mistos permitidos\nlet mixed = [1, \"two\", true, null];\n```\n\n## Objetos\n\nObjetos no estilo JavaScript:\n\n```hemlock\n// Literal de objeto\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nperson.age = 31;     // Modificar campo\n\n// Metodos com 'self'\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## Gerenciamento de Memoria\n\nO Hemlock usa **gerenciamento de memoria manual**:\n\n```hemlock\n// Buffer seguro (recomendado)\nlet buf = buffer(64);   // Alocar 64 bytes\nbuf[0] = 65;            // Definir primeiro byte como 'A'\nprint(buf[0]);          // 65\nfree(buf);              // Liberar memoria\n\n// Ponteiros brutos (avancado)\nlet ptr = alloc(100);\nmemset(ptr, 0, 100);    // Preencher com zeros\nfree(ptr);\n```\n\n**Importante**: Voce deve usar `free()` na memoria que voce alocou com `alloc()`!\n\n## Tratamento de Erros\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"Erro de divisao por zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Erro: \" + e);\n} finally {\n    print(\"Concluido\");\n}\n```\n\n## Argumentos de Linha de Comando\n\nAcesse os argumentos do programa atraves do array `args`:\n\n```hemlock\n// script.hml\nprint(\"Script:\", args[0]);\nprint(`Numero de argumentos: ${args.length - 1}`);\n\nlet i = 1;\nwhile (i < args.length) {\n    print(`  Argumento ${i}: ${args[i]}`);\n    i = i + 1;\n}\n```\n\nExecutar:\n```bash\n./hemlock script.hml hello world\n```\n\nSaida:\n```\nScript: script.hml\nNumero de argumentos: 2\n  Argumento 1: hello\n  Argumento 2: world\n```\n\n## E/S de Arquivos\n\n```hemlock\n// Escrever em arquivo\nlet f = open(\"data.txt\", \"w\");\nf.write(\"Hello, File!\");\nf.close();\n\n// Ler arquivo\nlet f2 = open(\"data.txt\", \"r\");\nlet content = f2.read();\nprint(content);  // \"Hello, File!\"\nf2.close();\n```\n\n## O Que Aprender a Seguir?\n\nAgora que voce conhece o basico, pode explorar mais:\n\n- [Tutorial](#getting-started-tutorial) - Guia completo passo a passo\n- [Guia da Linguagem](#language-guide-syntax) - Aprofunde-se em todos os recursos\n- [Exemplos](../../examples/) - Programas de exemplo do mundo real\n- [Referencia da API](#reference-builtins) - Documentacao completa da API\n\n## Armadilhas Comuns\n\n### Esquecer o Ponto e Virgula\n\n```hemlock\n//  Errado: falta ponto e virgula\nlet x = 42\nlet y = 10\n\n//  Correto\nlet x = 42;\nlet y = 10;\n```\n\n### Esquecer de Liberar Memoria\n\n```hemlock\n//  Vazamento de memoria\nlet buf = buffer(100);\n// ... usar buf ...\n// Esqueceu de chamar free(buf)!\n\n//  Correto\nlet buf = buffer(100);\n// ... usar buf ...\nfree(buf);\n```\n\n### Chaves Sao Obrigatorias\n\n```hemlock\n//  Errado: faltam chaves\nif (x > 0)\n    print(\"Positivo\");\n\n//  Correto\nif (x > 0) {\n    print(\"Positivo\");\n}\n```\n\n## Obtendo Ajuda\n\n- Leia a [documentacao completa](../README.md)\n- Confira o [diretorio de exemplos](../../examples/)\n- Veja os [arquivos de teste](../../tests/) para padroes de uso\n- Reporte problemas no GitHub\n"}, "Primeiros Passos -> Tutorial": {"id": "getting-started-tutorial", "content": "# Tutorial do Hemlock\n\nUm guia completo passo a passo para aprender Hemlock.\n\n## Sumario\n\n1. [Hello World](#hello-world)\n2. [Variaveis e Tipos](#variaveis-e-tipos)\n3. [Aritmetica e Operacoes](#aritmetica-e-operacoes)\n4. [Fluxo de Controle](#fluxo-de-controle)\n5. [Funcoes](#funcoes)\n6. [Strings e Caracteres](#strings-e-caracteres)\n7. [Arrays](#arrays)\n8. [Objetos](#objetos)\n9. [Gerenciamento de Memoria](#gerenciamento-de-memoria)\n10. [Tratamento de Erros](#tratamento-de-erros)\n11. [E/S de Arquivos](#es-de-arquivos)\n12. [Exemplo Completo](#exemplo-completo)\n\n## Hello World\n\nVamos comecar com o tradicional primeiro programa:\n\n```hemlock\nprint(\"Hello, World!\");\n```\n\nSalve como `hello.hml` e execute:\n\n```bash\n./hemlock hello.hml\n```\n\n**Pontos-chave:**\n- `print()` e uma funcao embutida que imprime na saida padrao\n- Strings sao delimitadas por aspas duplas\n- Ponto e virgula e **obrigatorio**\n\n## Variaveis e Tipos\n\n### Declarando Variaveis\n\n```hemlock\n// Declaracao basica de variaveis\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\nprint(x);      // 42\nprint(name);   // Alice\nprint(pi);     // 3.14159\n```\n\n### Anotacoes de Tipo\n\nEmbora os tipos sejam inferidos por padrao, voce pode especifica-los explicitamente:\n\n```hemlock\nlet age: i32 = 30;\nlet height: f64 = 5.9;\nlet initial: rune = 'A';\nlet active: bool = true;\n```\n\n### Inferencia de Tipos\n\nO Hemlock infere os tipos com base nos valores:\n\n```hemlock\nlet small = 42;              // i32 (cabe em 32 bits)\nlet large = 5000000000;      // i64 (muito grande para i32)\nlet decimal = 3.14;          // f64 (padrao para ponto flutuante)\nlet text = \"hello\";          // string\nlet flag = true;             // bool\n```\n\n### Verificacao de Tipos\n\n```hemlock\n// Use typeof() para verificar tipos\nprint(typeof(42));        // \"i32\"\nprint(typeof(3.14));      // \"f64\"\nprint(typeof(\"hello\"));   // \"string\"\nprint(typeof(true));      // \"bool\"\nprint(typeof(null));      // \"null\"\n```\n\n## Aritmetica e Operacoes\n\n### Aritmetica Basica\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13\nprint(a - b);   // 7\nprint(a * b);   // 30\nprint(a / b);   // 3 (divisao inteira)\nprint(a == b);  // false\nprint(a > b);   // true\n```\n\n### Promocao de Tipos\n\nAo misturar tipos, o Hemlock promove para o tipo maior/mais preciso:\n\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result e f64 (10.0 + 3.5 = 13.5)\n\nprint(result);       // 13.5\nprint(typeof(result)); // \"f64\"\n```\n\n### Operacoes Bit a Bit\n\n```hemlock\nlet a = 12;  // Binario 1100\nlet b = 10;  // Binario 1010\n\nprint(a & b);   // 8  (AND)\nprint(a | b);   // 14 (OR)\nprint(a ^ b);   // 6  (XOR)\nprint(a << 1);  // 24 (deslocamento a esquerda)\nprint(a >> 1);  // 6  (deslocamento a direita)\nprint(~a);      // -13 (NOT)\n```\n\n## Fluxo de Controle\n\n### Instrucao If\n\n```hemlock\nlet x = 10;\n\nif (x > 0) {\n    print(\"Positivo\");\n} else if (x < 0) {\n    print(\"Negativo\");\n} else {\n    print(\"Zero\");\n}\n```\n\n**Nota:** Chaves sao **sempre obrigatorias**, mesmo para instrucoes unicas.\n\n### Laco While\n\n```hemlock\nlet count = 0;\nwhile (count < 5) {\n    print(`Contagem: ${count}`);\n    count = count + 1;\n}\n```\n\n### Laco For\n\n```hemlock\n// Laco for estilo C\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n\n// Laco for-in (arrays)\nlet items = [10, 20, 30, 40];\nfor (let item in items) {\n    print(`Item: ${item}`);\n}\n```\n\n### Instrucao Switch\n\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n        print(\"Segunda-feira\");\n        break;\n    case 2:\n        print(\"Terca-feira\");\n        break;\n    case 3:\n        print(\"Quarta-feira\");\n        break;\n    default:\n        print(\"Outro dia\");\n        break;\n}\n```\n\n### Break e Continue\n\n```hemlock\n// Break: sai do laco antecipadamente\nlet i = 0;\nwhile (i < 10) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// Saida: 0, 1, 2, 3, 4\n\n// Continue: pula para a proxima iteracao\nfor (let j = 0; j < 5; j = j + 1) {\n    if (j == 2) {\n        continue;\n    }\n    print(j);\n}\n// Saida: 0, 1, 3, 4\n```\n\n## Funcoes\n\n### Funcoes Nomeadas\n\n```hemlock\nfn greet(name: string): string {\n    return \"Ola, \" + name + \"!\";\n}\n\nlet message = greet(\"Alice\");\nprint(message);  // \"Ola, Alice!\"\n```\n\n### Funcoes Anonimas\n\n```hemlock\nlet add = fn(a, b) {\n    return a + b;\n};\n\nprint(add(5, 3));  // 8\n```\n\n### Recursao\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### Closures\n\nFuncoes capturam seu ambiente:\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n### Funcoes de Ordem Superior\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 21);\nprint(result);  // 42\n```\n\n## Strings e Caracteres\n\n### Basico de Strings\n\nStrings sao **mutaveis** e codificadas em **UTF-8**:\n\n```hemlock\nlet s = \"hello\";\nprint(s.length);      // 5 (contagem de caracteres)\nprint(s.byte_length); // 5 (contagem de bytes)\n\n// Modificacao\ns[0] = 'H';\nprint(s);  // \"Hello\"\n```\n\n### Metodos de String\n\n```hemlock\nlet text = \"  Hello, World!  \";\n\n// Conversao de maiusculas/minusculas\nprint(text.to_upper());  // \"  HELLO, WORLD!  \"\nprint(text.to_lower());  // \"  hello, world!  \"\n\n// Remover espacos em branco\nprint(text.trim());      // \"Hello, World!\"\n\n// Extracao de substring\nlet hello = text.substr(2, 5);  // \"Hello\"\nlet world = text.slice(9, 14);  // \"World\"\n\n// Busca\nlet pos = text.find(\"World\");   // 9\nlet has = text.contains(\"o\");   // true\n\n// Divisao\nlet parts = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\n\n// Substituicao\nlet s = \"hello world\".replace(\"world\", \"there\");\nprint(s);  // \"hello there\"\n```\n\n### Caracteres (Pontos de Codigo Unicode)\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '';\n\nprint(ch);      // 'A'\nprint(emoji);   // U+1F680\n\n// Concatenacao de caractere + string\nlet msg = '>' + \" Importante\";\nprint(msg);  // \"> Importante\"\n\n// Conversao entre caracteres e inteiros\nlet code: i32 = ch;     // 65 (codigo ASCII)\nlet r: rune = 128640;   // U+1F680 ()\n```\n\n## Arrays\n\n### Basico de Arrays\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Modificar elementos\nnumbers[2] = 99;\nprint(numbers[2]);  // 99\n```\n\n### Metodos de Array\n\n```hemlock\nlet arr = [10, 20, 30];\n\n// Adicionar/remover no final\narr.push(40);           // [10, 20, 30, 40]\nlet last = arr.pop();   // 40, arr agora e [10, 20, 30]\n\n// Adicionar/remover no inicio\narr.unshift(5);         // [5, 10, 20, 30]\nlet first = arr.shift(); // 5, arr agora e [10, 20, 30]\n\n// Inserir/remover em indice\narr.insert(1, 15);      // [10, 15, 20, 30]\nlet removed = arr.remove(2);  // 20\n\n// Busca\nlet index = arr.find(15);     // 1\nlet has = arr.contains(10);   // true\n\n// Fatiamento\nlet slice = arr.slice(0, 2);  // [10, 15]\n\n// Juntar em string\nlet text = arr.join(\", \");    // \"10, 15, 30\"\n```\n\n### Iteracao\n\n```hemlock\nlet items = [\"maca\", \"banana\", \"cereja\"];\n\n// Laco for-in\nfor (let item in items) {\n    print(item);\n}\n\n// Iteracao manual\nlet i = 0;\nwhile (i < items.length) {\n    print(items[i]);\n    i = i + 1;\n}\n```\n\n## Objetos\n\n### Literais de Objeto\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nprint(person.age);   // 30\n\n// Adicionar/modificar campos\nperson.email = \"alice@example.com\";\nperson.age = 31;\n```\n\n### Metodos e `self`\n\n```hemlock\nlet calculator = {\n    value: 0,\n    add: fn(x) {\n        self.value = self.value + x;\n    },\n    get: fn() {\n        return self.value;\n    }\n};\n\ncalculator.add(10);\ncalculator.add(5);\nprint(calculator.get());  // 15\n```\n\n### Definicoes de Tipo (Duck Typing)\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,  // Campo opcional com valor padrao\n}\n\nlet p = { name: \"Bob\", age: 25 };\nlet typed: Person = p;  // Duck typing valida a estrutura\n\nprint(typeof(typed));   // \"Person\"\nprint(typed.active);    // true (valor padrao aplicado)\n```\n\n### Serializacao JSON\n\n```hemlock\nlet obj = { x: 10, y: 20, name: \"test\" };\n\n// Objeto para JSON\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// JSON para objeto\nlet restored = json.deserialize();\nprint(restored.name);  // \"test\"\n```\n\n## Gerenciamento de Memoria\n\n### Buffers Seguros (Recomendado)\n\n```hemlock\n// Alocar buffer\nlet buf = buffer(10);\nprint(buf.length);    // 10\nprint(buf.capacity);  // 10\n\n// Definir valores (com verificacao de limites)\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Acessar valores\nprint(buf[0]);  // 65\n\n// Deve liberar quando terminar\nfree(buf);\n```\n\n### Ponteiros Brutos (Avancado)\n\n```hemlock\n// Alocar memoria bruta\nlet ptr = alloc(100);\n\n// Preencher com zeros\nmemset(ptr, 0, 100);\n\n// Copiar dados\nlet src = alloc(50);\nmemcpy(ptr, src, 50);\n\n// Liberar ambos\nfree(src);\nfree(ptr);\n```\n\n### Funcoes de Memoria\n\n```hemlock\n// Realocar\nlet p = alloc(64);\np = realloc(p, 128);  // Redimensionar para 128 bytes\nfree(p);\n\n// Alocacao tipada (recurso futuro)\n// let arr = talloc(i32, 100);  // Array de 100 i32s\n```\n\n## Tratamento de Erros\n\n### Try/Catch\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"Erro de divisao por zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Erro: \" + e);\n}\n// Saida: Erro: Erro de divisao por zero\n```\n\n### Bloco Finally\n\n```hemlock\nlet file = null;\n\ntry {\n    file = open(\"data.txt\", \"r\");\n    let content = file.read();\n    print(content);\n} catch (e) {\n    print(\"Erro: \" + e);\n} finally {\n    // Sempre executa\n    if (file != null) {\n        file.close();\n    }\n}\n```\n\n### Lancando Objetos\n\n```hemlock\ntry {\n    throw { code: 404, message: \"Nao encontrado\" };\n} catch (e) {\n    print(`Erro ${e.code}: ${e.message}`);\n}\n// Saida: Erro 404: Nao encontrado\n```\n\n### Panic (Erro Irrecuperavel)\n\n```hemlock\nfn validate(x) {\n    if (x < 0) {\n        panic(\"x deve ser nao negativo\");\n    }\n    return x * 2;\n}\n\nvalidate(-5);  // Programa sai com: panic: x deve ser nao negativo\n```\n\n## E/S de Arquivos\n\n### Lendo Arquivos\n\n```hemlock\n// Ler arquivo inteiro\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n\n// Ler numero especifico de bytes\nlet f2 = open(\"data.txt\", \"r\");\nlet chunk = f2.read(100);  // Ler 100 bytes\nf2.close();\n```\n\n### Escrevendo Arquivos\n\n```hemlock\n// Escrever texto\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Hello, File!\\n\");\nf.write(\"Segunda linha\\n\");\nf.close();\n\n// Anexar ao arquivo\nlet f2 = open(\"output.txt\", \"a\");\nf2.write(\"Linha anexada\\n\");\nf2.close();\n```\n\n### E/S Binaria\n\n```hemlock\n// Escrever dados binarios\nlet buf = buffer(256);\nbuf[0] = 255;\nbuf[1] = 128;\n\nlet f = open(\"data.bin\", \"w\");\nf.write_bytes(buf);\nf.close();\n\n// Ler dados binarios\nlet f2 = open(\"data.bin\", \"r\");\nlet data = f2.read_bytes(256);\nprint(data[0]);  // 255\nf2.close();\n\nfree(buf);\nfree(data);\n```\n\n### Propriedades de Arquivo\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\n\nprint(f.path);    // \"/path/to/file.txt\"\nprint(f.mode);    // \"r\"\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n## Exemplo Completo\n\nVamos construir um programa simples de contagem de palavras:\n\n```hemlock\n// wordcount.hml - Conta palavras em um arquivo\n\nfn count_words(filename: string): i32 {\n    let file = null;\n    let count = 0;\n\n    try {\n        file = open(filename, \"r\");\n        let content = file.read();\n\n        // Dividir por espacos e contar\n        let words = content.split(\" \");\n        count = words.length;\n\n    } catch (e) {\n        print(\"Erro ao ler arquivo: \" + e);\n        return -1;\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n\n    return count;\n}\n\n// Programa principal\nif (args.length < 2) {\n    print(\"Uso: \" + args[0] + \" <nome_do_arquivo>\");\n} else {\n    let filename = args[1];\n    let words = count_words(filename);\n\n    if (words >= 0) {\n        print(`Contagem de palavras: ${words}`);\n    }\n}\n```\n\nExecutar:\n```bash\n./hemlock wordcount.hml data.txt\n```\n\n## Proximos Passos\n\nParabens! Voce aprendeu o basico do Hemlock. A seguir, voce pode explorar:\n\n- [Async e Concorrencia](#advanced-async-concurrency) - Multithreading real\n- [FFI](#advanced-ffi) - Chamar funcoes C\n- [Tratamento de Sinais](#advanced-signals) - Sinais de processo\n- [Referencia da API](#reference-builtins) - Documentacao completa da API\n- [Exemplos](../../examples/) - Mais programas do mundo real\n\n## Exercicios\n\nTente construir estes programas para praticar:\n\n1. **Calculadora**: Implemente uma calculadora simples que suporte +, -, *, /\n2. **Copiador de Arquivos**: Copie um arquivo para outro\n3. **Fibonacci**: Gere a sequencia de Fibonacci\n4. **Analisador JSON**: Leia e analise um arquivo JSON\n5. **Processador de Texto**: Encontre e substitua texto em um arquivo\n\nDivirta-se programando com Hemlock!\n"}, "Guia da Linguagem -> Arrays": {"id": "language-guide-arrays", "content": "# Arrays\n\nHemlock fornece **arrays dinmicos** com mtodos abrangentes para manipulao e processamento de dados. Arrays podem armazenar tipos mistos e crescem automaticamente conforme necessrio.\n\n## Viso Geral\n\n```hemlock\n// Literal de array\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Tipos mistos permitidos\nlet mixed = [1, \"hello\", true, null];\n\n// Redimensionamento dinmico\narr.push(6);           // Cresce automaticamente\narr.push(7);\nprint(arr.length);     // 7\n```\n\n## Literais de Array\n\n### Sintaxe Bsica\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet strings = [\"apple\", \"banana\", \"cherry\"];\nlet booleans = [true, false, true];\n```\n\n### Array Vazio\n\n```hemlock\nlet arr = [];  // Array vazio\n\n// Adicionar elementos depois\narr.push(1);\narr.push(2);\narr.push(3);\n```\n\n### Tipos Mistos\n\nArrays podem conter tipos diferentes:\n\n```hemlock\nlet mixed = [\n    42,\n    \"hello\",\n    true,\n    null,\n    [1, 2, 3],\n    { x: 10, y: 20 }\n];\n\nprint(mixed[0]);  // 42\nprint(mixed[1]);  // \"hello\"\nprint(mixed[4]);  // [1, 2, 3] (array aninhado)\n```\n\n### Arrays Aninhados\n\n```hemlock\nlet matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\nprint(matrix[0][0]);  // 1\nprint(matrix[1][2]);  // 6\nprint(matrix[2][1]);  // 8\n```\n\n### Arrays Tipados\n\nArrays podem usar anotaes de tipo para forar tipo de elemento:\n\n```hemlock\n// Sintaxe de array tipado\nlet nums: array<i32> = [1, 2, 3, 4, 5];\nlet names: array<string> = [\"Alice\", \"Bob\", \"Carol\"];\nlet flags: array<bool> = [true, false, true];\n\n// Verificao de tipo em tempo de execuo\nlet valid: array<i32> = [1, 2, 3];       // Correto\nlet invalid: array<i32> = [1, \"two\", 3]; // Erro em execuo: incompatibilidade de tipo\n\n// Arrays tipados aninhados\nlet matrix: array<array<i32>> = [\n    [1, 2, 3],\n    [4, 5, 6]\n];\n```\n\n**Comportamento de anotao de tipo:**\n- Elementos so verificados quando adicionados ao array\n- Incompatibilidade de tipo causa erro em tempo de execuo\n- Sem anotao de tipo, arrays aceitam tipos mistos\n\n## Indexao\n\n### Lendo Elementos\n\nAcesso com ndice baseado em zero:\n\n```hemlock\nlet arr = [10, 20, 30, 40, 50];\n\nprint(arr[0]);  // 10 (primeiro elemento)\nprint(arr[4]);  // 50 (ltimo elemento)\n\n// Acesso fora dos limites retorna null (sem erro)\nprint(arr[10]);  // null\n```\n\n### Escrevendo Elementos\n\n```hemlock\nlet arr = [1, 2, 3];\n\narr[0] = 10;    // Modifica elemento existente\narr[1] = 20;\nprint(arr);     // [10, 20, 3]\n\n// Pode atribuir alm do comprimento atual (array cresce)\narr[5] = 60;    // Cria [10, 20, 3, null, null, 60]\n```\n\n### ndices Negativos\n\n**No suportados** - use apenas ndices positivos:\n\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr[-1]);  // Erro ou comportamento indefinido\n\n// Use length para obter ltimo elemento\nprint(arr[arr.length - 1]);  // 3\n```\n\n## Propriedades\n\n### Propriedade `.length`\n\nRetorna o nmero de elementos:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);  // 5\n\n// Array vazio\nlet empty = [];\nprint(empty.length);  // 0\n\n// Aps modificao\narr.push(6);\nprint(arr.length);  // 6\n```\n\n## Mtodos de Array\n\nHemlock fornece 18 mtodos de array para operaes abrangentes.\n\n### Operaes de Pilha\n\n**`push(value)`** - Adiciona elemento no final:\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\n\nprint(arr.length);     // 5\n```\n\n**`pop()`** - Remove e retorna o ltimo elemento:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet last = arr.pop();  // Retorna 5, arr agora  [1, 2, 3, 4]\n\nprint(last);           // 5\nprint(arr.length);     // 4\n```\n\n### Operaes de Fila\n\n**`shift()`** - Remove e retorna o primeiro elemento:\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();   // Retorna 1, arr agora  [2, 3]\n\nprint(first);              // 1\nprint(arr);                // [2, 3]\n```\n\n**`unshift(value)`** - Adiciona elemento no incio:\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);            // [1, 2, 3]\narr.unshift(0);            // [0, 1, 2, 3]\n```\n\n### Insero e Remoo\n\n**`insert(index, value)`** - Insere elemento no ndice especificado:\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // Insere 3 no ndice 2: [1, 2, 3, 4, 5]\n\narr.insert(0, 0);      // Insere no incio: [0, 1, 2, 3, 4, 5]\n```\n\n**`remove(index)`** - Remove e retorna elemento no ndice especificado:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(2);  // Retorna 3, arr agora  [1, 2, 4, 5]\n\nprint(removed);               // 3\nprint(arr);                   // [1, 2, 4, 5]\n```\n\n### Operaes de Busca\n\n**`find(value)`** - Encontra a primeira ocorrncia:\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2 (ndice da primeira ocorrncia)\nlet idx2 = arr.find(99);     // -1 (no encontrado)\n\n// Funciona com qualquer tipo\nlet words = [\"apple\", \"banana\", \"cherry\"];\nlet idx3 = words.find(\"banana\");  // 1\n```\n\n**`contains(value)`** - Verifica se array contm valor:\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n```\n\n### Operaes de Extrao\n\n**`slice(start, end)`** - Extrai subarray (end no includo):\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4] (ndices 1, 2, 3)\nlet first = arr.slice(0, 2); // [1, 2]\n\n// Array original no muda\nprint(arr);                  // [1, 2, 3, 4, 5]\n```\n\n**`first()`** - Obtm o primeiro elemento (sem remover):\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1 (sem remover)\nprint(arr);                  // [1, 2, 3] (inalterado)\n```\n\n**`last()`** - Obtm o ltimo elemento (sem remover):\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3 (sem remover)\nprint(arr);                  // [1, 2, 3] (inalterado)\n```\n\n### Operaes de Transformao\n\n**`reverse()`** - Inverte o array no local:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\n\nprint(arr);                  // [5, 4, 3, 2, 1] (modificado)\n```\n\n**`join(delimiter)`** - Une elementos em uma string:\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Funciona com tipos mistos\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n```\n\n**`concat(other)`** - Concatena com outro array:\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (novo array)\n\n// Arrays originais no mudam\nprint(a);                    // [1, 2, 3]\nprint(b);                    // [4, 5, 6]\n```\n\n### Operaes Utilitrias\n\n**`clear()`** - Remove todos os elementos:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();                 // []\n\nprint(arr.length);           // 0\nprint(arr);                  // []\n```\n\n## Encadeamento de Mtodos\n\nMtodos que retornam arrays ou valores podem ser encadeados:\n\n```hemlock\nlet result = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);  // [3, 4, 5]\n\nlet text = [\"apple\", \"banana\", \"cherry\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\nlet numbers = [5, 3, 8, 1, 9]\n    .slice(1, 4)\n    .concat([10, 11]);  // [3, 8, 1, 10, 11]\n```\n\n## Referncia Completa de Mtodos\n\n| Mtodo | Parmetros | Retorno | Modifica Original | Descrio |\n|--------|-----------|---------|---------|-------------|\n| `push(value)` | any | void | Sim | Adiciona elemento no final |\n| `pop()` | - | any | Sim | Remove e retorna ltimo elemento |\n| `shift()` | - | any | Sim | Remove e retorna primeiro elemento |\n| `unshift(value)` | any | void | Sim | Adiciona elemento no incio |\n| `insert(index, value)` | i32, any | void | Sim | Insere no ndice especificado |\n| `remove(index)` | i32 | any | Sim | Remove e retorna elemento no ndice |\n| `find(value)` | any | i32 | No | Encontra primeira ocorrncia (retorna -1 se no encontrado) |\n| `contains(value)` | any | bool | No | Verifica se contm valor |\n| `slice(start, end)` | i32, i32 | array | No | Extrai subarray (novo array) |\n| `join(delimiter)` | string | string | No | Une em string |\n| `concat(other)` | array | array | No | Concatena arrays (novo array) |\n| `reverse()` | - | void | Sim | Inverte no local |\n| `first()` | - | any | No | Obtm primeiro elemento |\n| `last()` | - | any | No | Obtm ltimo elemento |\n| `clear()` | - | void | Sim | Remove todos os elementos |\n| `map(callback)` | fn | array | No | Transforma cada elemento |\n| `filter(predicate)` | fn | array | No | Seleciona elementos correspondentes |\n| `reduce(callback, initial)` | fn, any | any | No | Reduz a um nico valor |\n\n## Detalhes de Implementao\n\n### Modelo de Memria\n\n- **Alocao no heap** - Capacidade dinmica\n- **Crescimento automtico** - Dobra quando excede capacidade\n- **Sem encolhimento automtico** - Capacidade no diminui\n- **Sem verificao de limites no ndice** - Use mtodos para segurana\n\n### Gerenciamento de Capacidade\n\n```hemlock\nlet arr = [];  // Capacidade inicial: 0\n\narr.push(1);   // Cresce para capacidade 1\narr.push(2);   // Cresce para capacidade 2\narr.push(3);   // Cresce para capacidade 4 (dobra)\narr.push(4);   // Ainda capacidade 4\narr.push(5);   // Cresce para capacidade 8 (dobra)\n```\n\n### Comparao de Valores\n\n`find()` e `contains()` usam comparao de igualdade de valor:\n\n```hemlock\n// Tipos primitivos: compara por valor\nlet arr = [1, 2, 3];\narr.contains(2);  // true\n\n// Strings: compara por valor\nlet words = [\"hello\", \"world\"];\nwords.contains(\"hello\");  // true\n\n// Objetos: compara por referncia\nlet obj1 = { x: 10 };\nlet obj2 = { x: 10 };\nlet arr2 = [obj1];\narr2.contains(obj1);  // true (mesma referncia)\narr2.contains(obj2);  // false (referncia diferente)\n```\n\n## Padres Comuns\n\n### Operaes Funcionais (map/filter/reduce)\n\nArrays tm mtodos `map`, `filter` e `reduce` embutidos:\n\n```hemlock\n// map - transforma cada elemento\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = numbers.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\n// filter - seleciona elementos correspondentes\nlet evens = numbers.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4]\n\n// reduce - reduz a um nico valor\nlet sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\n// Encadeando operaes funcionais\nlet result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]\n    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]\n    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220\n```\n\n### Padro: Array como Pilha\n\n```hemlock\nlet stack = [];\n\n// Empilhar\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Desempilhar\nlet top = stack.pop();    // 3\nlet next = stack.pop();   // 2\n```\n\n### Padro: Array como Fila\n\n```hemlock\nlet queue = [];\n\n// Enfileirar (adicionar no final)\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Desenfileirar (remover do incio)\nlet first = queue.shift();   // 1\nlet second = queue.shift();  // 2\n```\n\n## Melhores Prticas\n\n1. **Use mtodos em vez de ndice direto** - Verificao de limites e clareza de cdigo\n2. **Verifique limites** - Indexao direta no verifica limites\n3. **Prefira operaes imutveis** - Use `slice()` e `concat()` em vez de modificar original\n4. **Pr-inicialize capacidade** - Se souber o tamanho (no suportado atualmente)\n5. **Use `contains()` para verificar pertinncia** - Mais claro que loop manual\n6. **Encadeie mtodos** - Mais legvel que chamadas aninhadas\n\n## Armadilhas Comuns\n\n### Armadilha: ndice Direto Fora dos Limites\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// Sem verificao de limites!\narr[10] = 99;  // Cria array esparso com null\nprint(arr.length);  // 11 (no 3!)\n\n// Melhor: use push() ou verifique length\nif (arr.length <= 10) {\n    arr.push(99);\n}\n```\n\n### Armadilha: Modificao vs Novo Array\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// Modifica original\narr.reverse();\nprint(arr);  // [3, 2, 1]\n\n// Retorna novo array\nlet sub = arr.slice(0, 2);\nprint(arr);  // [3, 2, 1] (inalterado)\nprint(sub);  // [3, 2]\n```\n\n### Armadilha: Igualdade de Referncia\n\n```hemlock\nlet obj = { x: 10 };\nlet arr = [obj];\n\n// Mesma referncia: true\narr.contains(obj);  // true\n\n// Referncia diferente: false\narr.contains({ x: 10 });  // false (objeto diferente)\n```\n\n### Armadilha: Arrays de Longa Durao\n\n```hemlock\n// Arrays em escopo local so liberados automaticamente, mas arrays globais/de longa durao precisam ateno\nlet global_cache = [];  // Nvel de mdulo, persiste at fim do programa\n\nfn add_to_cache(item) {\n    global_cache.push(item);  // Cresce infinitamente\n}\n\n// Para dados de longa durao, considere:\n// - Limpar o array periodicamente: global_cache.clear();\n// - Liberar antecipadamente: free(global_cache);\n```\n\n## Exemplos\n\n### Exemplo: Estatsticas de Array\n\n```hemlock\nfn mean(arr) {\n    let sum = 0;\n    let i = 0;\n    while (i < arr.length) {\n        sum = sum + arr[i];\n        i = i + 1;\n    }\n    return sum / arr.length;\n}\n\nfn max(arr) {\n    if (arr.length == 0) {\n        return null;\n    }\n\n    let max_val = arr[0];\n    let i = 1;\n    while (i < arr.length) {\n        if (arr[i] > max_val) {\n            max_val = arr[i];\n        }\n        i = i + 1;\n    }\n    return max_val;\n}\n\nlet numbers = [3, 7, 2, 9, 1];\nprint(mean(numbers));  // 4.4\nprint(max(numbers));   // 9\n```\n\n### Exemplo: Remoo de Duplicados\n\n```hemlock\nfn unique(arr) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (!result.contains(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet numbers = [1, 2, 2, 3, 1, 4, 3, 5];\nlet uniq = unique(numbers);  // [1, 2, 3, 4, 5]\n```\n\n### Exemplo: Dividir em Blocos\n\n```hemlock\nfn chunk(arr, size) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        let chunk = arr.slice(i, i + size);\n        result.push(chunk);\n        i = i + size;\n    }\n\n    return result;\n}\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8];\nlet chunks = chunk(numbers, 3);\n// [[1, 2, 3], [4, 5, 6], [7, 8]]\n```\n\n### Exemplo: Achatar Array\n\n```hemlock\nfn flatten(arr) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        if (typeof(arr[i]) == \"array\") {\n            // Array aninhado - achatar\n            let nested = flatten(arr[i]);\n            let j = 0;\n            while (j < nested.length) {\n                result.push(nested[j]);\n                j = j + 1;\n            }\n        } else {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet nested = [1, [2, 3], [4, [5, 6]], 7];\nlet flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]\n```\n\n### Exemplo: Ordenao (Bubble Sort)\n\n```hemlock\nfn sort(arr) {\n    let n = arr.length;\n    let i = 0;\n\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (arr[j] > arr[j + 1]) {\n                // Troca\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers);  // Modifica no local\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## Limitaes\n\nLimitaes atuais:\n\n- **Sem verificao de limites no ndice** - Acesso direto no verifica limites\n- **Objetos usam igualdade de referncia** - `find()` e `contains()` usam comparao de referncia\n- **Sem desestruturao de array** - Sintaxe `let [a, b] = arr` no suportada\n- **Sem operador spread** - Sintaxe `[...arr1, ...arr2]` no suportada\n\n**Nota:** Arrays usam contagem de referncia, sendo liberados automaticamente ao sair do escopo. Veja [Gerenciamento de Memria](memory.md#internal-reference-counting) para detalhes.\n\n## Tpicos Relacionados\n\n- [Strings](#language-guide-strings) - Mtodos de string so similares aos de array\n- [Objetos](#language-guide-objects) - Arrays tambm so tipo objeto\n- [Funes](#language-guide-functions) - Arrays e funes de ordem superior\n- [Fluxo de Controle](#language-guide-control-flow) - Iterao sobre arrays\n\n## Veja Tambm\n\n- **Tamanho dinmico**: Arrays crescem automaticamente dobrando capacidade\n- **Mtodos**: 18 mtodos abrangentes de operao, incluindo map/filter/reduce\n- **Memria**: Veja [Memria](#language-guide-memory) para detalhes de alocao de arrays\n"}, "Guia da Linguagem -> Correspondncia de Padres": {"id": "language-guide-pattern-matching", "content": "# Correspondencia de Padroes\n\nHemlock fornece correspondencia de padroes poderosa atraves de expressoes `match`, oferecendo uma forma concisa de desestruturar valores, verificar tipos e tratar multiplos casos.\n\n## Sintaxe Basica\n\n```hemlock\nlet resultado = match (valor) {\n    padrao1 => expressao1,\n    padrao2 => expressao2,\n    _ => expressao_padrao\n};\n```\n\nA expressao match compara `valor` com cada padrao em ordem, retornando o resultado da expressao do primeiro branch que corresponder.\n\n## Tipos de Padroes\n\n### Padroes Literais\n\nCorresponde a valores exatos:\n\n```hemlock\nlet x = 42;\nlet msg = match (x) {\n    0 => \"zero\",\n    1 => \"um\",\n    42 => \"a resposta\",\n    _ => \"outro\"\n};\nprint(msg);  // \"a resposta\"\n```\n\nLiterais suportados:\n- **Inteiros**: `0`, `42`, `-5`\n- **Ponto flutuante**: `3.14`, `-0.5`\n- **Strings**: `\"hello\"`, `\"world\"`\n- **Booleanos**: `true`, `false`\n- **Nulo**: `null`\n\n### Padrao Curinga (`_`)\n\nCorresponde a qualquer valor mas nao vincula:\n\n```hemlock\nlet x = \"qualquer coisa\";\nlet resultado = match (x) {\n    \"especifico\" => \"encontrei\",\n    _ => \"curinga correspondeu\"\n};\n```\n\n### Padrao de Vinculacao de Variavel\n\nVincula o valor correspondido a uma variavel:\n\n```hemlock\nlet x = 100;\nlet resultado = match (x) {\n    0 => \"zero\",\n    n => \"valor e \" + n  // n vinculado a 100\n};\nprint(resultado);  // \"valor e 100\"\n```\n\n### Padroes OR (`|`)\n\nCorresponde a multiplas alternativas:\n\n```hemlock\nlet x = 2;\nlet tamanho = match (x) {\n    1 | 2 | 3 => \"pequeno\",\n    4 | 5 | 6 => \"medio\",\n    _ => \"grande\"\n};\n\n// Tambem funciona com strings\nlet cmd = \"quit\";\nlet acao = match (cmd) {\n    \"exit\" | \"quit\" | \"q\" => \"saindo\",\n    \"help\" | \"h\" | \"?\" => \"mostrando ajuda\",\n    _ => \"desconhecido\"\n};\n```\n\n### Expressoes de Guarda (`if`)\n\nAdiciona condicoes aos padroes:\n\n```hemlock\nlet x = 15;\nlet categoria = match (x) {\n    n if n < 0 => \"negativo\",\n    n if n == 0 => \"zero\",\n    n if n < 10 => \"pequeno\",\n    n if n < 100 => \"medio\",\n    n => \"grande: \" + n\n};\nprint(categoria);  // \"medio\"\n\n// Guardas complexas\nlet y = 12;\nlet resultado = match (y) {\n    n if n % 2 == 0 && n > 10 => \"par e maior que 10\",\n    n if n % 2 == 0 => \"par\",\n    n => \"impar\"\n};\n```\n\n### Padroes de Tipo\n\nVerifica e vincula baseado em tipo:\n\n```hemlock\nlet val = 42;\nlet desc = match (val) {\n    num: i32 => \"inteiro: \" + num,\n    str: string => \"string: \" + str,\n    flag: bool => \"booleano: \" + flag,\n    _ => \"outro tipo\"\n};\nprint(desc);  // \"inteiro: 42\"\n```\n\nTipos suportados: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`, `bool`, `string`, `array`, `object`\n\n## Padroes de Desestruturacao\n\n### Desestruturacao de Objetos\n\nExtrai campos de objetos:\n\n```hemlock\nlet ponto = { x: 10, y: 20 };\nlet resultado = match (ponto) {\n    { x, y } => \"ponto em \" + x + \",\" + y\n};\nprint(resultado);  // \"ponto em 10,20\"\n\n// Com valores literais de campos\nlet origem = { x: 0, y: 0 };\nlet nome = match (origem) {\n    { x: 0, y: 0 } => \"origem\",\n    { x: 0, y } => \"no eixo y em \" + y,\n    { x, y: 0 } => \"no eixo x em \" + x,\n    { x, y } => \"ponto em \" + x + \",\" + y\n};\nprint(nome);  // \"origem\"\n```\n\n### Desestruturacao de Arrays\n\nCorresponde a estrutura e elementos de arrays:\n\n```hemlock\nlet arr = [1, 2, 3];\nlet desc = match (arr) {\n    [] => \"vazio\",\n    [x] => \"unico: \" + x,\n    [x, y] => \"par: \" + x + \",\" + y,\n    [x, y, z] => \"tripla: \" + x + \",\" + y + \",\" + z,\n    _ => \"muitos elementos\"\n};\nprint(desc);  // \"tripla: 1,2,3\"\n\n// Com valores literais\nlet par = [1, 2];\nlet resultado = match (par) {\n    [0, 0] => \"ambos zero\",\n    [1, x] => \"comeca com 1, segundo e \" + x,\n    [x, 1] => \"termina com 1\",\n    _ => \"outro\"\n};\nprint(resultado);  // \"comeca com 1, segundo e 2\"\n```\n\n### Padrao Rest de Array (`...`)\n\nCaptura elementos restantes:\n\n```hemlock\nlet nums = [1, 2, 3, 4, 5];\n\n// Cabeca e cauda\nlet resultado = match (nums) {\n    [primeiro, ...resto] => \"primeiro: \" + primeiro,\n    [] => \"vazio\"\n};\nprint(resultado);  // \"primeiro: 1\"\n\n// Dois primeiros elementos\nlet resultado2 = match (nums) {\n    [a, b, ...resto] => \"dois primeiros: \" + a + \",\" + b,\n    _ => \"muito curto\"\n};\nprint(resultado2);  // \"dois primeiros: 1,2\"\n```\n\n### Desestruturacao Aninhada\n\nCombina padroes para dados complexos:\n\n```hemlock\nlet usuario = {\n    name: \"Alice\",\n    address: { city: \"NYC\", zip: 10001 }\n};\n\nlet resultado = match (usuario) {\n    { name, address: { city, zip } } => name + \" mora em \" + city,\n    _ => \"desconhecido\"\n};\nprint(resultado);  // \"Alice mora em NYC\"\n\n// Objeto contendo array\nlet dados = { items: [1, 2, 3], count: 3 };\nlet resultado2 = match (dados) {\n    { items: [primeiro, ...resto], count } => \"primeiro: \" + primeiro + \", total: \" + count,\n    _ => \"sem items\"\n};\nprint(resultado2);  // \"primeiro: 1, total: 3\"\n```\n\n## Match como Expressao\n\nMatch e uma expressao que retorna um valor:\n\n```hemlock\n// Atribuicao direta\nlet nota = 85;\nlet letra = match (nota) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    n if n >= 70 => \"C\",\n    n if n >= 60 => \"D\",\n    _ => \"F\"\n};\n\n// Em concatenacao de string\nlet msg = \"Nota: \" + match (nota) {\n    n if n >= 70 => \"aprovado\",\n    _ => \"reprovado\"\n};\n\n// Em retorno de funcao\nfn classificar(n: i32): string {\n    return match (n) {\n        0 => \"zero\",\n        n if n > 0 => \"positivo\",\n        _ => \"negativo\"\n    };\n}\n```\n\n## Melhores Praticas de Correspondencia de Padroes\n\n1. **Ordem importa**: Padroes sao verificados de cima para baixo; coloque padroes especificos antes dos genericos\n2. **Use curinga para completude**: Sempre inclua fallback `_` a menos que tenha certeza de que todos os casos estao cobertos\n3. **Prefira guardas a condicoes aninhadas**: Guardas tornam a intencao mais clara\n4. **Use desestruturacao em vez de acesso manual a campos**: Mais conciso e seguro\n\n```hemlock\n// Bom: use guardas para verificacao de intervalos\nmatch (pontuacao) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    _ => \"abaixo de B\"\n}\n\n// Bom: desestruturacao em vez de acessar campos\nmatch (ponto) {\n    { x: 0, y: 0 } => \"origem\",\n    { x, y } => \"em \" + x + \",\" + y\n}\n\n// Evite: padroes aninhados muito complexos\n// Considere dividir em multiplos match ou usar guardas\n```\n\n## Comparacao com Outras Linguagens\n\n| Recurso | Hemlock | Rust | JavaScript |\n|---------|---------|------|------------|\n| Match basico | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |\n| Desestruturacao | Sim | Sim | Parcial (switch nao desestrutura) |\n| Guardas | `n if n > 0 =>` | `n if n > 0 =>` | N/A |\n| Padroes OR | `1 \\| 2 \\| 3 =>` | `1 \\| 2 \\| 3 =>` | `case 1: case 2: case 3:` |\n| Padroes rest | `[a, ...resto]` | `[a, resto @ ..]` | N/A |\n| Padroes de tipo | `n: i32` | Via tipos em branches `match` | N/A |\n| Retorna valor | Sim | Sim | Nao (declaracao) |\n\n## Notas de Implementacao\n\nCorrespondencia de padroes e implementada tanto no interpretador quanto no backend do compilador com paridade completa - ambos produzem resultados identicos para a mesma entrada. O recurso esta disponivel no Hemlock v1.8.0+.\n"}, "Guia da Linguagem -> Fluxo de Controle": {"id": "language-guide-control-flow", "content": "# Fluxo de Controle\n\nHemlock fornece fluxo de controle familiar no estilo C, exigindo o uso obrigatrio de chaves e sintaxe explcita. Este guia abrange declaraes condicionais, loops, declaraes switch e operadores.\n\n## Visao Geral\n\nRecursos de fluxo de controle disponveis:\n\n- `if`/`else`/`else if` - Ramificao condicional\n- `while` loops - Iterao baseada em condio\n- `for` loops - Estilo C e iterao for-in\n- `loop` - Loop infinito (mais claro que `while (true)`)\n- Declaraes `switch` - Ramificao mltipla\n- `break`/`continue` - Controle de loop\n- Rtulos de loop - break/continue direcionado para loops aninhados\n- `defer` - Execuo adiada (limpeza)\n- Operadores booleanos: `&&`, `||`, `!`\n- Operadores de comparao: `==`, `!=`, `<`, `>`, `<=`, `>=`\n- Operadores bit a bit: `&`, `|`, `^`, `<<`, `>>`, `~`\n\n## Declaraes If\n\n### If/Else Bsico\n\n```hemlock\nif (x > 10) {\n    print(\"grande\");\n} else {\n    print(\"pequeno\");\n}\n```\n\n**Regras:**\n- Todas as ramificaes **devem** usar chaves\n- Condies devem estar entre parnteses\n- Chaves opcionais no so suportadas (diferente de C)\n\n### If Sem Else\n\n```hemlock\nif (x > 0) {\n    print(\"positivo\");\n}\n// Ramificao else no  necessria\n```\n\n### Cadeia Else-If\n\n```hemlock\nif (x > 100) {\n    print(\"muito grande\");\n} else if (x > 50) {\n    print(\"grande\");\n} else if (x > 10) {\n    print(\"mdio\");\n} else {\n    print(\"pequeno\");\n}\n```\n\n**Nota:** `else if`  acar sinttico para declaraes if aninhadas. As duas formas a seguir so equivalentes:\n\n```hemlock\n// else if (acar sinttico)\nif (a) {\n    foo();\n} else if (b) {\n    bar();\n}\n\n// if aninhado equivalente\nif (a) {\n    foo();\n} else {\n    if (b) {\n        bar();\n    }\n}\n```\n\n### Declaraes If Aninhadas\n\n```hemlock\nif (x > 0) {\n    if (x < 10) {\n        print(\"dgito nico positivo\");\n    } else {\n        print(\"mltiplos dgitos positivos\");\n    }\n} else {\n    print(\"no positivo\");\n}\n```\n\n## Loops While\n\nIterao baseada em condio:\n\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n**Loop infinito (estilo antigo):**\n```hemlock\nwhile (true) {\n    // ... executar trabalho\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**Nota:** Para loops infinitos, recomenda-se usar a palavra-chave `loop` (veja abaixo).\n\n## Loop (Loop Infinito)\n\nA palavra-chave `loop` fornece uma sintaxe mais clara para loops infinitos:\n\n```hemlock\nloop {\n    // ... executar trabalho\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**Equivalente a `while (true)`, mas com inteno mais clara.**\n\n### Loop Bsico com Break\n\n```hemlock\nlet i = 0;\nloop {\n    if (i >= 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// Sada: 0, 1, 2, 3, 4\n```\n\n### Loop com Continue\n\n```hemlock\nlet i = 0;\nloop {\n    i = i + 1;\n    if (i > 5) {\n        break;\n    }\n    if (i == 3) {\n        continue;  // Pula a impresso de 3\n    }\n    print(i);\n}\n// Sada: 1, 2, 4, 5\n```\n\n### Loops Aninhados\n\n```hemlock\nlet x = 0;\nloop {\n    if (x >= 2) { break; }\n    let y = 0;\n    loop {\n        if (y >= 3) { break; }\n        print(x * 10 + y);\n        y = y + 1;\n    }\n    x = x + 1;\n}\n// Sada: 0, 1, 2, 10, 11, 12\n```\n\n### Quando Usar Loop\n\n- **Use `loop`** - Para loops infinitos intencionais, saindo com `break`\n- **Use `while`** - Quando h uma condio natural de trmino\n- **Use `for`** - Ao iterar um nmero conhecido de vezes ou sobre colees\n\n## Loops For\n\n### For Estilo C\n\nLoop for clssico de trs partes:\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**Componentes:**\n- **Inicializador**: `let i = 0` - Executa uma vez antes do loop\n- **Condio**: `i < 10` - Verificada antes de cada iterao\n- **Atualizao**: `i = i + 1` - Executa aps cada iterao\n\n**Escopo:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n// i no  acessvel aqui (escopo do loop)\n```\n\n### Loops For-In\n\nItera sobre elementos de array:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nfor (let item in arr) {\n    print(item);  // Imprime cada elemento\n}\n```\n\n**Com ndice e valor:**\n```hemlock\nlet arr = [\"a\", \"b\", \"c\"];\nfor (let i = 0; i < arr.length; i = i + 1) {\n    print(`ndice: ${i}, Valor: ${arr[i]}`);\n}\n```\n\n## Declaraes Switch\n\nRamificao mltipla baseada em valor:\n\n### Switch Bsico\n\n```hemlock\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"um\");\n        break;\n    case 2:\n        print(\"dois\");\n        break;\n    case 3:\n        print(\"trs\");\n        break;\n}\n```\n\n### Switch com Default\n\n```hemlock\nlet color = \"azul\";\n\nswitch (color) {\n    case \"vermelho\":\n        print(\"parar\");\n        break;\n    case \"amarelo\":\n        print(\"desacelerar\");\n        break;\n    case \"verde\":\n        print(\"seguir\");\n        break;\n    default:\n        print(\"cor desconhecida\");\n        break;\n}\n```\n\n**Regras:**\n- `default` executa quando nenhum outro case corresponde\n- `default` pode aparecer em qualquer posio no corpo do switch\n- Apenas um case default  permitido\n\n### Comportamento de Fall-through\n\nCases sem `break` passam para o prximo case (comportamento estilo C). Isso  **intencional** e pode ser usado para agrupar cases:\n\n```hemlock\nlet nota = 85;\n\nswitch (nota) {\n    case 100:\n    case 95:\n    case 90:\n        print(\"A\");\n        break;\n    case 85:\n    case 80:\n        print(\"B\");\n        break;\n    default:\n        print(\"C ou abaixo\");\n        break;\n}\n```\n\n**Exemplo de fall-through explcito:**\n```hemlock\nlet dia = 3;\n\nswitch (dia) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n        print(\"Dia de semana\");\n        break;\n    case 6:\n    case 7:\n        print(\"Fim de semana\");\n        break;\n}\n```\n\n**Importante:** Diferente de algumas linguagens modernas, Hemlock no requer uma palavra-chave `fallthrough` explcita. A menos que terminados com `break`, `return` ou `throw`, cases passam automaticamente para o prximo. Sempre use `break` para evitar fall-through acidental.\n\n### Switch com Return\n\nEm funes, `return` sai imediatamente do switch:\n\n```hemlock\nfn get_day_name(dia: i32): string {\n    switch (dia) {\n        case 1:\n            return \"Segunda\";\n        case 2:\n            return \"Tera\";\n        case 3:\n            return \"Quarta\";\n        default:\n            return \"Desconhecido\";\n    }\n}\n```\n\n### Tipos de Valor em Switch\n\nSwitch funciona com qualquer tipo de valor:\n\n```hemlock\n// Inteiros\nswitch (contador) {\n    case 0: print(\"zero\"); break;\n    case 1: print(\"um\"); break;\n}\n\n// Strings\nswitch (nome) {\n    case \"Alice\": print(\"A\"); break;\n    case \"Bob\": print(\"B\"); break;\n}\n\n// Booleanos\nswitch (flag) {\n    case true: print(\"ligado\"); break;\n    case false: print(\"desligado\"); break;\n}\n```\n\n**Nota:** Cases usam igualdade de valor para comparao.\n\n## Break e Continue\n\n### Break\n\nSai do loop ou switch mais interno:\n\n```hemlock\n// Em loop\nlet i = 0;\nwhile (true) {\n    if (i >= 10) {\n        break;  // Sai do loop\n    }\n    print(i);\n    i = i + 1;\n}\n\n// Em switch\nswitch (x) {\n    case 1:\n        print(\"um\");\n        break;  // Sai do switch\n    case 2:\n        print(\"dois\");\n        break;\n}\n```\n\n### Continue\n\nPula para a prxima iterao do loop:\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;  // Pula quando i  5\n    }\n    print(i);  // Imprime 0,1,2,3,4,6,7,8,9\n}\n```\n\n**Diferena:**\n- `break` - Sai completamente do loop\n- `continue` - Pula para a prxima iterao\n\n## Rtulos de Loop\n\nRtulos de loop permitem que `break` e `continue` direcionem loops externos especficos, no apenas o loop mais interno. Isso  til em loops aninhados onde voc precisa controlar o loop externo a partir do loop interno.\n\n### Break com Rtulo\n\nSai do loop externo a partir do loop interno:\n\n```hemlock\nouter: while (i < 3) {\n    let j = 0;\n    while (j < 3) {\n        if (i == 1 && j == 1) {\n            break outer;  // Sai do while externo\n        }\n        print(i * 10 + j);\n        j = j + 1;\n    }\n    i = i + 1;\n}\n// Sada: 0, 1, 2, 10 (para em i=1, j=1)\n```\n\n### Continue com Rtulo\n\nPula para a prxima iterao do loop externo:\n\n```hemlock\nlet i = 0;\nouter: while (i < 3) {\n    i = i + 1;\n    let j = 0;\n    while (j < 3) {\n        j = j + 1;\n        if (i == 2 && j == 1) {\n            continue outer;  // Pula o resto do loop interno, continua o externo\n        }\n        print(i * 10 + j);\n    }\n}\n// Quando i=2, j=1: pula para a prxima iterao do loop externo\n```\n\n### Rtulos em Loops For\n\nRtulos funcionam com todos os tipos de loop:\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 3; y = y + 1) {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n    }\n}\n```\n\n### Rtulos em Loops For-In\n\n```hemlock\nlet arr1 = [1, 2, 3];\nlet arr2 = [10, 20, 30];\n\nouter: for (let a in arr1) {\n    for (let b in arr2) {\n        if (a == 2 && b == 20) {\n            break outer;\n        }\n        print(a * 100 + b);\n    }\n}\n```\n\n### Rtulos com Palavra-chave Loop\n\n```hemlock\nlet x = 0;\nouter: loop {\n    let y = 0;\n    loop {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n        y = y + 1;\n        if (y >= 3) { break; }\n    }\n    x = x + 1;\n    if (x >= 3) { break; }\n}\n```\n\n### Mltiplos Rtulos\n\nVoc pode usar rtulos em diferentes nveis de aninhamento:\n\n```hemlock\nouter: for (let a = 0; a < 2; a = a + 1) {\n    inner: for (let b = 0; b < 3; b = b + 1) {\n        for (let c = 0; c < 3; c = c + 1) {\n            if (c == 1) {\n                continue inner;  // Pula para a prxima iterao do loop do meio\n            }\n            if (a == 1 && b == 1) {\n                break outer;      // Sai do loop mais externo\n            }\n            print(a * 100 + b * 10 + c);\n        }\n    }\n}\n```\n\n### Break/Continue Sem Rtulo em Loops com Rtulo\n\n`break` e `continue` sem rtulo ainda funcionam normalmente (afetam o loop mais interno), mesmo quando loops externos tm rtulos:\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 5; y = y + 1) {\n        if (y == 2) {\n            break;  // Sai apenas do loop interno\n        }\n        print(x * 10 + y);\n    }\n}\n// Sada: 0, 1, 10, 11, 20, 21\n```\n\n### Sintaxe de Rtulos\n\n- Rtulos so identificadores seguidos de dois-pontos\n- Rtulos devem preceder imediatamente a declarao do loop (`while`, `for`, `loop`)\n- Nomes de rtulos seguem regras de identificadores (letras, nmeros, sublinhados)\n- Convenes comuns: `outer`, `inner`, `row`, `col`, nomes descritivos\n\n## Declarao Defer\n\nA declarao `defer` agenda cdigo para ser executado quando a funo atual retorna. Isso  til para operaes de limpeza como fechar arquivos, liberar recursos ou desbloquear.\n\n### Defer Bsico\n\n```hemlock\nfn example() {\n    print(\"incio\");\n    defer print(\"limpeza\");  // Executa quando a funo retorna\n    print(\"fim\");\n}\n\nexample();\n// Sada:\n// incio\n// fim\n// limpeza\n```\n\n**Comportamento chave:**\n- Declaraes defer executam **aps** o corpo da funo completar\n- Declaraes defer executam **antes** da funo retornar ao chamador\n- Declaraes defer sempre executam mesmo se a funo lanar uma exceo\n\n### Mltiplos Defer (Ordem LIFO)\n\nQuando usando mltiplas declaraes `defer`, elas executam em **ordem reversa** (ltimo a entrar, primeiro a sair):\n\n```hemlock\nfn example() {\n    defer print(\"primeiro\");   // Executa por ltimo\n    defer print(\"segundo\");    // Executa em segundo\n    defer print(\"terceiro\");   // Executa primeiro\n    print(\"corpo\");\n}\n\nexample();\n// Sada:\n// corpo\n// terceiro\n// segundo\n// primeiro\n```\n\nEsta ordem LIFO  intencional - corresponde  ordem natural de limpeza de recursos aninhados (fechar recursos internos antes dos externos).\n\n### Defer com Return\n\nDeclaraes defer executam antes de `return` transferir controle:\n\n```hemlock\nfn get_value(): i32 {\n    defer print(\"limpeza\");\n    print(\"antes do return\");\n    return 42;\n}\n\nlet resultado = get_value();\nprint(\"resultado:\", resultado);\n// Sada:\n// antes do return\n// limpeza\n// resultado: 42\n```\n\n### Defer com Excees\n\nDeclaraes defer executam mesmo se uma exceo for lanada:\n\n```hemlock\nfn arriscado() {\n    defer print(\"limpeza 1\");\n    defer print(\"limpeza 2\");\n    print(\"antes do throw\");\n    throw \"erro!\";\n    print(\"depois do throw\");  // Nunca executa\n}\n\ntry {\n    arriscado();\n} catch (e) {\n    print(\"Capturado:\", e);\n}\n// Sada:\n// antes do throw\n// limpeza 2\n// limpeza 1\n// Capturado: erro!\n```\n\n### Padro de Limpeza de Recursos\n\nO principal caso de uso para `defer`  garantir que recursos sejam limpos:\n\n```hemlock\nfn process_file(filename: string) {\n    let file = open(filename, \"r\");\n    defer file.close();  // Sempre fecha, mesmo em erro\n\n    let content = file.read();\n    // ... processar contedo ...\n\n    // Arquivo fecha automaticamente quando a funo retorna\n}\n```\n\n**Sem defer (propenso a erros):**\n```hemlock\nfn process_file_bad(filename: string) {\n    let file = open(filename, \"r\");\n    let content = file.read();\n    // Se lanar aqui, file.close() nunca  chamado!\n    process(content);\n    file.close();\n}\n```\n\n### Defer com Closures\n\nDefer pode usar closures para capturar estado:\n\n```hemlock\nfn example() {\n    let resource = acquire_resource();\n    defer fn() {\n        print(\"Liberando recurso\");\n        release(resource);\n    }();  // Nota: expresso de funo imediatamente invocada\n\n    use_resource(resource);\n}\n```\n\n### Quando Usar Defer\n\n**Use defer para:**\n- Fechar arquivos e conexes de rede\n- Liberar memria alocada\n- Liberar locks e mutexes\n- Limpeza em qualquer funo que adquire recursos\n\n**Defer vs Finally:**\n- `defer`  mais simples para limpeza de nico recurso\n- `try/finally`  melhor para tratamento de erros complexo com recuperao\n\n### Melhores Prticas\n\n1. **Use defer imediatamente aps adquirir o recurso:**\n   ```hemlock\n   let file = open(\"data.txt\", \"r\");\n   defer file.close();\n   // ... usar arquivo ...\n   ```\n\n2. **Use mltiplos defer para mltiplos recursos:**\n   ```hemlock\n   let file1 = open(\"input.txt\", \"r\");\n   defer file1.close();\n\n   let file2 = open(\"output.txt\", \"w\");\n   defer file2.close();\n\n   // Ambos os arquivos fecharo em ordem reversa\n   ```\n\n3. **Lembre da ordem LIFO para recursos dependentes:**\n   ```hemlock\n   let outer = acquire_outer();\n   defer release_outer(outer);\n\n   let inner = acquire_inner(outer);\n   defer release_inner(inner);\n\n   // inner  liberado antes de outer (ordem de dependncia correta)\n   ```\n\n## Operadores Booleanos\n\n### E Lgico (`&&`)\n\nAmbas as condies devem ser verdadeiras:\n\n```hemlock\nif (x > 0 && x < 10) {\n    print(\"dgito nico positivo\");\n}\n```\n\n**Avaliao de curto-circuito:**\n```hemlock\nif (false && expensive_check()) {\n    // expensive_check() nunca  chamada\n}\n```\n\n### OU Lgico (`||`)\n\nPelo menos uma condio deve ser verdadeira:\n\n```hemlock\nif (x < 0 || x > 100) {\n    print(\"fora do intervalo\");\n}\n```\n\n**Avaliao de curto-circuito:**\n```hemlock\nif (true || expensive_check()) {\n    // expensive_check() nunca  chamada\n}\n```\n\n### NAO Lgico (`!`)\n\nNega valor booleano:\n\n```hemlock\nif (!is_valid) {\n    print(\"invlido\");\n}\n\nif (!(x > 10)) {\n    // Equivalente a: if (x <= 10)\n}\n```\n\n## Operadores de Comparao\n\n### Igualdade\n\n```hemlock\nif (x == 10) { }    // Igual a\nif (x != 10) { }    // Diferente de\n```\n\nFunciona com todos os tipos:\n```hemlock\n\"hello\" == \"hello\"  // true\ntrue == false       // false\nnull == null        // true\n```\n\n### Operadores Relacionais\n\n```hemlock\nif (x < 10) { }     // Menor que\nif (x > 10) { }     // Maior que\nif (x <= 10) { }    // Menor ou igual\nif (x >= 10) { }    // Maior ou igual\n```\n\n**Promoo de tipo se aplica:**\n```hemlock\nlet a: i32 = 10;\nlet b: i64 = 10;\nif (a == b) { }     // true (i32 promovido para i64)\n```\n\n## Operadores Bit a Bit\n\nHemlock fornece operadores bit a bit para manipulao de inteiros. Estes **s podem ser usados com tipos inteiros** (i8-i64, u8-u64).\n\n### Operadores Bit a Bit Binrios\n\n**E bit a bit (`&`)**\n```hemlock\nlet a = 12;  // Binrio 1100\nlet b = 10;  // Binrio 1010\nprint(a & b);   // 8 (1000)\n```\n\n**OU bit a bit (`|`)**\n```hemlock\nprint(a | b);   // 14 (1110)\n```\n\n**XOR bit a bit (`^`)**\n```hemlock\nprint(a ^ b);   // 6 (0110)\n```\n\n**Deslocamento  esquerda (`<<`)**\n```hemlock\nprint(a << 2);  // 48 (110000) - desloca 2 bits  esquerda\n```\n\n**Deslocamento  direita (`>>`)**\n```hemlock\nprint(a >> 1);  // 6 (110) - desloca 1 bit  direita\n```\n\n### Operador Bit a Bit Unrio\n\n**Complemento bit a bit (`~`)**\n```hemlock\nlet a = 12;\nprint(~a);      // -13 (complemento de dois)\n\nlet c: u8 = 15;   // Binrio 00001111\nprint(~c);        // 240 (11110000), tipo u8\n```\n\n### Exemplos de Operaes Bit a Bit\n\n**Usando tipos sem sinal:**\n```hemlock\nlet c: u8 = 15;   // Binrio 00001111\nlet d: u8 = 7;    // Binrio 00000111\n\nprint(c & d);     // 7  (00000111)\nprint(c | d);     // 15 (00001111)\nprint(c ^ d);     // 8  (00001000)\nprint(~c);        // 240 (11110000) - tipo u8\n```\n\n**Preservao de tipo:**\n```hemlock\n// Operaes bit a bit preservam o tipo dos operandos\nlet x: u8 = 255;\nlet resultado = ~x;  // resultado  u8, valor 0\n\nlet y: i32 = 100;\nlet resultado2 = y << 2;  // resultado2  i32, valor 400\n```\n\n**Padres comuns:**\n```hemlock\n// Verificar se bit est definido\nif (flags & 0x04) {\n    print(\"bit 2 est definido\");\n}\n\n// Definir bit\nflags = flags | 0x08;\n\n// Limpar bit\nflags = flags & ~0x02;\n\n// Alternar bit\nflags = flags ^ 0x01;\n```\n\n### Precedncia de Operadores\n\nOperadores bit a bit seguem precedncia estilo C:\n\n1. `~` (negao unria) - Mais alta, mesmo nvel que `!` e `-`\n2. `<<`, `>>` (deslocamento) - Acima de comparao, abaixo de `+`/`-`\n3. `&` (E bit a bit) - Acima de `^` e `|`\n4. `^` (XOR bit a bit) - Entre `&` e `|`\n5. `|` (OU bit a bit) - Abaixo de `&` e `^`, acima de `&&`\n6. `&&`, `||` (lgicos) - Precedncia mais baixa\n\n**Exemplos:**\n```hemlock\n// & tem precedncia maior que |\nlet resultado1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12\n\n// Deslocamento tem precedncia maior que operadores bit a bit\nlet resultado2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12\n\n// Use parnteses para clareza\nlet resultado3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5\n```\n\n**Notas importantes:**\n- Operadores bit a bit s funcionam com tipos inteiros (no float, string, etc.)\n- Promoo de tipo segue regras padro (tipos menores promovidos para maiores)\n- Deslocamento  direita (`>>`)  aritmtico para tipos com sinal, lgico para sem sinal\n- Quantidade de deslocamento no  verificada por intervalo (comportamento depende da plataforma)\n\n## Precedncia de Operadores (Completa)\n\nDa maior para a menor precedncia:\n\n1. **Unrio**: `!`, `-`, `~`\n2. **Multiplicativo**: `*`, `/`, `%`\n3. **Aditivo**: `+`, `-`\n4. **Deslocamento**: `<<`, `>>`\n5. **Relacional**: `<`, `>`, `<=`, `>=`\n6. **Igualdade**: `==`, `!=`\n7. **E bit a bit**: `&`\n8. **XOR bit a bit**: `^`\n9. **OU bit a bit**: `|`\n10. **E lgico**: `&&`\n11. **OU lgico**: `||`\n\n**Use parnteses para clareza:**\n```hemlock\n// No claro\nif (a || b && c) { }\n\n// Claro\nif (a || (b && c)) { }\nif ((a || b) && c) { }\n```\n\n## Padres Comuns\n\n### Padro: Validao de Entrada\n\n```hemlock\nfn validate_age(idade: i32): bool {\n    if (idade < 0 || idade > 150) {\n        return false;\n    }\n    return true;\n}\n```\n\n### Padro: Verificao de Intervalo\n\n```hemlock\nfn in_range(valor: i32, min: i32, max: i32): bool {\n    return valor >= min && valor <= max;\n}\n\nif (in_range(pontuacao, 0, 100)) {\n    print(\"pontuao vlida\");\n}\n```\n\n### Padro: Mquina de Estados\n\n```hemlock\nlet estado = \"inicio\";\n\nwhile (true) {\n    switch (estado) {\n        case \"inicio\":\n            print(\"Iniciando...\");\n            estado = \"executando\";\n            break;\n\n        case \"executando\":\n            if (should_pause) {\n                estado = \"pausado\";\n            } else if (should_stop) {\n                estado = \"parado\";\n            }\n            break;\n\n        case \"pausado\":\n            if (should_resume) {\n                estado = \"executando\";\n            }\n            break;\n\n        case \"parado\":\n            print(\"Parado\");\n            break;\n    }\n\n    if (estado == \"parado\") {\n        break;\n    }\n}\n```\n\n### Padro: Iterao com Filtro\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// Imprime apenas nmeros pares\nfor (let i = 0; i < arr.length; i = i + 1) {\n    if (arr[i] % 2 != 0) {\n        continue;  // Pula mpares\n    }\n    print(arr[i]);\n}\n```\n\n### Padro: Sada Antecipada\n\n```hemlock\nfn find_first_negative(arr: array): i32 {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Sada antecipada\n        }\n    }\n    return -1;  // No encontrado\n}\n```\n\n## Melhores Prticas\n\n1. **Sempre use chaves** - Mesmo para blocos de nica declarao (sintaxe fora)\n2. **Condies explcitas** - Use `x == 0` em vez de `!x` para clareza\n3. **Evite aninhamento profundo** - Extraia condies aninhadas para funes\n4. **Use retorno antecipado** - Use clusulas de guarda para reduzir aninhamento\n5. **Decomponha condies complexas** - Divida em variveis booleanas nomeadas\n6. **Use default em switch** - Sempre inclua case default\n7. **Comente fall-through** - Torne fall-through intencional explcito\n\n## Armadilhas Comuns\n\n### Armadilha: Atribuio em Condio\n\n```hemlock\n// Isso no  permitido (no pode atribuir em condio)\nif (x = 10) { }  // Erro: erro de sintaxe\n\n// Use comparao em vez disso\nif (x == 10) { }  // OK\n```\n\n### Armadilha: Break Faltando em Switch\n\n```hemlock\n// Fall-through acidental\nswitch (x) {\n    case 1:\n        print(\"um\");\n        // Break faltando - vai passar para o prximo!\n    case 2:\n        print(\"dois\");  // Executa para 1 e 2\n        break;\n}\n\n// Corrigido: adicione break\nswitch (x) {\n    case 1:\n        print(\"um\");\n        break;  // Agora correto\n    case 2:\n        print(\"dois\");\n        break;\n}\n```\n\n### Armadilha: Escopo de Varivel de Loop\n\n```hemlock\n// i tem escopo limitado ao loop\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\nprint(i);  // Erro: i no est definido aqui\n```\n\n## Exemplos\n\n### Exemplo: FizzBuzz\n\n```hemlock\nfor (let i = 1; i <= 100; i = i + 1) {\n    if (i % 15 == 0) {\n        print(\"FizzBuzz\");\n    } else if (i % 3 == 0) {\n        print(\"Fizz\");\n    } else if (i % 5 == 0) {\n        print(\"Buzz\");\n    } else {\n        print(i);\n    }\n}\n```\n\n### Exemplo: Verificao de Nmero Primo\n\n```hemlock\nfn is_prime(n: i32): bool {\n    if (n < 2) {\n        return false;\n    }\n\n    let i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            return false;\n        }\n        i = i + 1;\n    }\n\n    return true;\n}\n```\n\n### Exemplo: Sistema de Menu\n\n```hemlock\nfn menu() {\n    while (true) {\n        print(\"1. Iniciar\");\n        print(\"2. Configuraes\");\n        print(\"3. Sair\");\n\n        let escolha = get_input();\n\n        switch (escolha) {\n            case 1:\n                start_game();\n                break;\n            case 2:\n                show_settings();\n                break;\n            case 3:\n                print(\"At logo!\");\n                return;\n            default:\n                print(\"Escolha invlida\");\n                break;\n        }\n    }\n}\n```\n\n## Tpicos Relacionados\n\n- [Funes](#language-guide-functions) - Fluxo de controle de chamadas e retornos de funo\n- [Tratamento de Erros](#language-guide-error-handling) - Fluxo de controle de excees\n- [Tipos](#language-guide-types) - Converso de tipos em condies\n\n## Veja Tambm\n\n- **Sintaxe**: Veja [Sintaxe](#language-guide-syntax) para detalhes de sintaxe de declaraes\n- **Operadores**: Veja [Tipos](#language-guide-types) para promoo de tipos em operaes\n"}, "Guia da Linguagem -> Funes": {"id": "language-guide-functions", "content": "# Funes\n\nEm Hemlock, funes so **cidados de primeira classe**, podendo ser atribudas a variveis, passadas como argumentos e retornadas de outras funes. Este guia cobre sintaxe de funes, closures, recurso e padres avanados.\n\n## Viso Geral\n\n```hemlock\n// Sintaxe de funo nomeada\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\n// Funo annima\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\n// Closure\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nprint(add5(3));  // 8\n```\n\n## Declarao de Funes\n\n### Funes Nomeadas\n\n```hemlock\nfn greet(name: string): string {\n    return \"Hello, \" + name;\n}\n\nlet msg = greet(\"Alice\");  // \"Hello, Alice\"\n```\n\n**Componentes:**\n- `fn` - palavra-chave de funo\n- `greet` - nome da funo\n- `(name: string)` - parmetros com tipos opcionais\n- `: string` - tipo de retorno opcional\n- `{ ... }` - corpo da funo\n\n### Funes Annimas\n\nFunes sem nome, atribudas a variveis:\n\n```hemlock\nlet square = fn(x) {\n    return x * x;\n};\n\nprint(square(5));  // 25\n```\n\n**Funo nomeada vs annima:**\n```hemlock\n// Estas duas formas so equivalentes:\nfn add(a, b) { return a + b; }\n\nlet add = fn(a, b) { return a + b; };\n```\n\n**Nota:** Funes nomeadas so desaucarizadas para atribuio de varivel com funo annima.\n\n## Parmetros\n\n### Parmetros Bsicos\n\n```hemlock\nfn example(a, b, c) {\n    return a + b + c;\n}\n\nlet result = example(1, 2, 3);  // 6\n```\n\n### Anotaes de Tipo\n\nAnotaes de tipo opcionais para parmetros:\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);      // OK\nadd(5, 10.5);    // Verificao de tipo em execuo promove para f64\n```\n\n**Verificao de tipo:**\n- Se anotado, tipos de parmetros so verificados na chamada\n- Converses implcitas seguem regras de promoo padro\n- Incompatibilidade de tipo causa erro em tempo de execuo\n\n### Passagem por Valor\n\nTodos os parmetros so **copiados** (passagem por valor):\n\n```hemlock\nfn modify(x) {\n    x = 100;  // Modifica apenas a cpia local\n}\n\nlet a = 10;\nmodify(a);\nprint(a);  // Ainda  10 (no alterado)\n```\n\n**Nota:** Objetos e arrays so passados por referncia (a referncia  copiada), ento seu contedo pode ser modificado:\n\n```hemlock\nfn modify_array(arr) {\n    arr[0] = 99;  // Modifica o array original\n}\n\nlet a = [1, 2, 3];\nmodify_array(a);\nprint(a[0]);  // 99 (modificado)\n```\n\n## Valores de Retorno\n\n### Instruo Return\n\n```hemlock\nfn get_max(a: i32, b: i32): i32 {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n```\n\n### Anotao de Tipo de Retorno\n\nAnotao de tipo opcional para valor de retorno:\n\n```hemlock\nfn calculate(): f64 {\n    return 3.14159;\n}\n\nfn get_name(): string {\n    return \"Alice\";\n}\n```\n\n**Verificao de tipo:**\n- Se anotado, tipo de retorno  verificado quando a funo retorna\n- Converses de tipo seguem regras de promoo padro\n\n### Retorno Implcito\n\nFunes sem anotao de tipo de retorno implicitamente retornam `null`:\n\n```hemlock\nfn print_message(msg) {\n    print(msg);\n    // Retorna null implicitamente\n}\n\nlet result = print_message(\"hello\");  // result  null\n```\n\n### Retorno Antecipado\n\n```hemlock\nfn find_first_negative(arr) {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Sada antecipada\n        }\n    }\n    return -1;  // No encontrado\n}\n```\n\n### Retorno sem Valor\n\n`return;` sem valor retorna `null`:\n\n```hemlock\nfn maybe_process(value) {\n    if (value < 0) {\n        return;  // Retorna null\n    }\n    return value * 2;\n}\n```\n\n## Funes de Primeira Classe\n\nFunes podem ser atribudas, passadas e retornadas como qualquer outro valor.\n\n### Funes como Variveis\n\n```hemlock\nlet operation = fn(x, y) { return x + y; };\n\nprint(operation(5, 3));  // 8\n\n// Reatribuir\noperation = fn(x, y) { return x * y; };\nprint(operation(5, 3));  // 15\n```\n\n### Funes como Argumentos\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 5);  // 10\n```\n\n### Funes como Valores de Retorno\n\n```hemlock\nfn get_operation(op: string) {\n    if (op == \"add\") {\n        return fn(a, b) { return a + b; };\n    } else if (op == \"multiply\") {\n        return fn(a, b) { return a * b; };\n    } else {\n        return fn(a, b) { return 0; };\n    }\n}\n\nlet add = get_operation(\"add\");\nprint(add(5, 3));  // 8\n```\n\n## Closures\n\nFunes capturam seu ambiente de definio (escopo lxico).\n\n### Closure Bsico\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n**Como funciona:**\n- A funo interna captura `count` do escopo externo\n- `count` persiste entre mltiplas chamadas da funo retornada\n- Cada chamada a `makeCounter()` cria um novo closure com seu prprio `count`\n\n### Closure com Parmetros\n\n```hemlock\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\n\nprint(add5(3));   // 8\nprint(add10(3));  // 13\n```\n\n### Mltiplos Closures\n\n```hemlock\nfn makeOperations(x) {\n    let add = fn(y) { return x + y; };\n    let multiply = fn(y) { return x * y; };\n\n    return { add: add, multiply: multiply };\n}\n\nlet ops = makeOperations(5);\nprint(ops.add(3));       // 8\nprint(ops.multiply(3));  // 15\n```\n\n### Escopo Lxico\n\nFunes podem acessar variveis de escopos externos atravs de escopo lxico:\n\n```hemlock\nlet global = 10;\n\nfn outer() {\n    let outer_var = 20;\n\n    fn inner() {\n        // Pode ler global e outer_var\n        print(global);      // 10\n        print(outer_var);   // 20\n    }\n\n    inner();\n}\n\nouter();\n```\n\nClosures capturam variveis por referncia, permitindo leitura e modificao de variveis de escopo externo (como mostrado no exemplo `makeCounter` acima).\n\n## Recurso\n\nFunes podem chamar a si mesmas.\n\n### Recurso Bsica\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### Recurso Mtua\n\nFunes podem chamar umas s outras:\n\n```hemlock\nfn is_even(n: i32): bool {\n    if (n == 0) {\n        return true;\n    }\n    return is_odd(n - 1);\n}\n\nfn is_odd(n: i32): bool {\n    if (n == 0) {\n        return false;\n    }\n    return is_even(n - 1);\n}\n\nprint(is_even(4));  // true\nprint(is_odd(4));   // false\n```\n\n### Processamento de Dados Recursivo\n\n```hemlock\nfn sum_array(arr: array, index: i32): i32 {\n    if (index >= arr.length) {\n        return 0;\n    }\n    return arr[index] + sum_array(arr, index + 1);\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(sum_array(numbers, 0));  // 15\n```\n\n**Nota:** No h otimizao de chamada de cauda ainda - recurso profunda pode causar estouro de pilha.\n\n## Funes de Ordem Superior\n\nFunes que aceitam ou retornam outras funes.\n\n### Padro Map\n\n```hemlock\nfn map(arr, f) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        result.push(f(arr[i]));\n        i = i + 1;\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = map(numbers, double);  // [2, 4, 6, 8, 10]\n```\n\n### Padro Filter\n\n```hemlock\nfn filter(arr, predicate) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (predicate(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nfn is_even(x) { return x % 2 == 0; }\n\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = filter(numbers, is_even);  // [2, 4, 6]\n```\n\n### Padro Reduce\n\n```hemlock\nfn reduce(arr, f, initial) {\n    let accumulator = initial;\n    let i = 0;\n    while (i < arr.length) {\n        accumulator = f(accumulator, arr[i]);\n        i = i + 1;\n    }\n    return accumulator;\n}\n\nfn add(a, b) { return a + b; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = reduce(numbers, add, 0);  // 15\n```\n\n### Composio de Funes\n\n```hemlock\nfn compose(f, g) {\n    return fn(x) {\n        return f(g(x));\n    };\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\n\nlet double_then_increment = compose(increment, double);\nprint(double_then_increment(5));  // 11 (5*2 + 1)\n```\n\n## Padres Comuns\n\n### Padro: Funo de Fbrica\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```\n\n### Padro: Funo de Callback\n\n```hemlock\nfn process_async(data, callback) {\n    // ... processar\n    callback(data);\n}\n\nprocess_async(\"test\", fn(result) {\n    print(\"Processing complete: \" + result);\n});\n```\n\n### Padro: Aplicao Parcial\n\n```hemlock\nfn partial(f, x) {\n    return fn(y) {\n        return f(x, y);\n    };\n}\n\nfn multiply(a, b) {\n    return a * b;\n}\n\nlet double = partial(multiply, 2);\nlet triple = partial(multiply, 3);\n\nprint(double(5));  // 10\nprint(triple(5));  // 15\n```\n\n### Padro: Memoizao\n\n```hemlock\nfn memoize(f) {\n    let cache = {};\n\n    return fn(x) {\n        if (cache.has(x)) {\n            return cache[x];\n        }\n\n        let result = f(x);\n        cache[x] = result;\n        return result;\n    };\n}\n\nfn expensive_fibonacci(n) {\n    if (n <= 1) { return n; }\n    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);\n}\n\nlet fast_fib = memoize(expensive_fibonacci);\nprint(fast_fib(10));  // Muito mais rpido com cache\n```\n\n## Semntica de Funes\n\n### Requisito de Tipo de Retorno\n\nFunes com anotao de tipo de retorno **devem** retornar um valor:\n\n```hemlock\nfn get_value(): i32 {\n    // Erro: falta instruo return\n}\n\nfn get_value(): i32 {\n    return 42;  // OK\n}\n```\n\n### Verificao de Tipo\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);        // OK\nadd(5.5, 10.5);    // Promove para f64, retorna f64\nadd(\"a\", \"b\");     // Erro em tempo de execuo: incompatibilidade de tipo\n```\n\n### Regras de Escopo\n\n```hemlock\nlet global = \"global\";\n\nfn outer() {\n    let outer_var = \"outer\";\n\n    fn inner() {\n        let inner_var = \"inner\";\n        // Pode acessar: inner_var, outer_var, global\n    }\n\n    // Pode acessar: outer_var, global\n    // No pode acessar: inner_var\n}\n\n// Pode acessar: global\n// No pode acessar: outer_var, inner_var\n```\n\n## Melhores Prticas\n\n1. **Use anotaes de tipo** - Ajuda a detectar erros e documentar inteno\n2. **Mantenha funes pequenas** - Cada funo deve fazer apenas uma coisa\n3. **Prefira funes puras** - Evite efeitos colaterais quando possvel\n4. **Nomeie claramente** - Use nomes de verbos descritivos\n5. **Retorno antecipado** - Use clusulas de guarda para reduzir aninhamento\n6. **Documente closures complexos** - Deixe claro quais variveis so capturadas\n7. **Evite recurso profunda** - Sem otimizao de chamada de cauda ainda\n\n## Armadilhas Comuns\n\n### Armadilha: Profundidade de Recurso\n\n```hemlock\n// Recurso profunda pode causar estouro de pilha\nfn count_down(n) {\n    if (n == 0) { return; }\n    count_down(n - 1);\n}\n\ncount_down(100000);  // Pode falhar com estouro de pilha\n```\n\n### Armadilha: Modificao de Variveis Capturadas\n\n```hemlock\nfn make_counter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Pode ler e modificar variveis capturadas\n        return count;\n    };\n}\n```\n\n**Nota:** Isso funciona, mas esteja ciente de que todos os closures compartilham o mesmo ambiente capturado.\n\n## Exemplos\n\n### Exemplo: Pipeline de Funes\n\n```hemlock\nfn pipeline(value, ...functions) {\n    let result = value;\n    for (f in functions) {\n        result = f(result);\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\nfn square(x) { return x * x; }\n\nlet result = pipeline(3, double, increment, square);\nprint(result);  // 49 ((3*2+1)^2)\n```\n\n### Exemplo: Manipulador de Eventos\n\n```hemlock\nlet handlers = [];\n\nfn on_event(name: string, handler) {\n    handlers.push({ name: name, handler: handler });\n}\n\nfn trigger_event(name: string, data) {\n    let i = 0;\n    while (i < handlers.length) {\n        if (handlers[i].name == name) {\n            handlers[i].handler(data);\n        }\n        i = i + 1;\n    }\n}\n\non_event(\"click\", fn(data) {\n    print(\"Clicked: \" + data);\n});\n\ntrigger_event(\"click\", \"button1\");\n```\n\n### Exemplo: Ordenao com Comparador Personalizado\n\n```hemlock\nfn sort(arr, compare) {\n    // Bubble sort com comparador personalizado\n    let n = arr.length;\n    let i = 0;\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (compare(arr[j], arr[j + 1]) > 0) {\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nfn ascending(a, b) {\n    if (a < b) { return -1; }\n    if (a > b) { return 1; }\n    return 0;\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers, ascending);\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## Parmetros Opcionais (Parmetros Padro)\n\nFunes podem definir parmetros opcionais com valores padro usando a sintaxe `?:`:\n\n```hemlock\nfn greet(name, greeting?: \"Hello\") {\n    return greeting + \" \" + name;\n}\n\nprint(greet(\"Alice\"));           // \"Hello Alice\"\nprint(greet(\"Bob\", \"Hi\"));       // \"Hi Bob\"\n\nfn add(a, b?: 10, c?: 100) {\n    return a + b + c;\n}\n\nprint(add(1));          // 111 (1 + 10 + 100)\nprint(add(1, 2));       // 103 (1 + 2 + 100)\nprint(add(1, 2, 3));    // 6   (1 + 2 + 3)\n```\n\n**Regras:**\n- Parmetros opcionais devem vir aps parmetros obrigatrios\n- Valores padro podem ser qualquer expresso\n- Parmetros omitidos usam valores padro\n\n## Funes Varidicas (Parmetros Rest)\n\nFunes podem aceitar nmero varivel de argumentos usando parmetros rest (`...`):\n\n```hemlock\nfn sum(...args) {\n    let total = 0;\n    for (arg in args) {\n        total = total + arg;\n    }\n    return total;\n}\n\nprint(sum(1, 2, 3));        // 6\nprint(sum(1, 2, 3, 4, 5));  // 15\nprint(sum());               // 0\n\nfn log(prefix, ...messages) {\n    for (msg in messages) {\n        print(prefix + \": \" + msg);\n    }\n}\n\nlog(\"INFO\", \"Starting\", \"Running\", \"Done\");\n// INFO: Starting\n// INFO: Running\n// INFO: Done\n```\n\n**Regras:**\n- Parmetro rest deve ser o ltimo parmetro\n- Parmetro rest coleta todos os argumentos restantes em um array\n- Pode ser combinado com parmetros normais e opcionais\n\n## Anotaes de Tipo de Funo\n\nTipos de funo permitem especificar assinaturas precisas para parmetros e valores de retorno:\n\n### Tipo de Funo Bsico\n\n```hemlock\n// Sintaxe de tipo de funo: fn(param_types): return_type\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\nlet double = fn(n) { return n * 2; };\nlet result = apply(double, 5);  // 10\n```\n\n### Tipos de Funo de Ordem Superior\n\n```hemlock\n// Funo que retorna funo\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\nlet add5 = make_adder(5);\nprint(add5(10));  // 15\n```\n\n### Tipos de Funo Assncrona\n\n```hemlock\n// Tipo de funo assncrona\nfn run_task(handler: async fn(): void) {\n    spawn(handler);\n}\n\nrun_task(async fn() {\n    print(\"Running async!\");\n});\n```\n\n### Aliases de Tipo de Funo\n\n```hemlock\n// Criar tipos de funo nomeados para clareza\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\nfn filter_with(arr: array, pred: Predicate): array {\n    return arr.filter(pred);\n}\n```\n\n## Parmetros Const\n\nO modificador `const` impede modificao de parmetros dentro da funo:\n\n### Parmetro Const Bsico\n\n```hemlock\nfn print_all(const items: array) {\n    // items.push(4);  // Erro: no pode modificar parmetro const\n    for (item in items) {\n        print(item);   // OK: leitura permitida\n    }\n}\n\nlet nums = [1, 2, 3];\nprint_all(nums);\n```\n\n### Imutabilidade Profunda\n\nParmetros const foram imutabilidade profunda - no pode modificar atravs de nenhum caminho:\n\n```hemlock\nfn describe(const person: object) {\n    print(person.name);       // OK: leitura permitida\n    // person.name = \"Bob\";   // Erro: no pode modificar\n    // person.address.city = \"NYC\";  // Erro: const profundo\n}\n```\n\n### Operaes Bloqueadas por Const\n\n| Tipo | Bloqueado por Const | Permitido |\n|------|--------------|-------|\n| array | push, pop, shift, unshift, insert, remove, clear, reverse | slice, concat, map, filter, find, contains |\n| object | atribuio de campo | leitura de campo |\n| buffer | atribuio de ndice | leitura de ndice |\n| string | atribuio de ndice | todos os mtodos (retornam novas strings) |\n\n## Parmetros Nomeados\n\nFunes podem ser chamadas com parmetros nomeados para maior clareza e flexibilidade:\n\n### Parmetros Nomeados Bsicos\n\n```hemlock\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" is \" + age + \" years old\");\n}\n\n// Argumentos posicionais (tradicional)\ncreate_user(\"Alice\", 25, false);\n\n// Argumentos nomeados - podem estar em qualquer ordem\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n```\n\n### Misturando Argumentos Posicionais e Nomeados\n\n```hemlock\n// Pular parmetros opcionais nomeando\ncreate_user(\"David\", active: false);  // Usa age=18 padro\n\n// Argumentos nomeados devem vir aps posicionais\ncreate_user(\"Eve\", age: 21);          // OK\n// create_user(name: \"Bad\", 25);      // Erro: argumento posicional aps nomeado\n```\n\n### Regras de Parmetros Nomeados\n\n- Use sintaxe `name: value` para argumentos nomeados\n- Argumentos nomeados podem aparecer em qualquer ordem aps argumentos posicionais\n- Argumentos posicionais no podem seguir argumentos nomeados\n- Funciona com parmetros padro/opcionais\n- Nomes de parmetro desconhecidos causam erro em tempo de execuo\n\n## Limitaes\n\nLimitaes atuais a observar:\n\n- **Sem passagem por referncia** - Palavra-chave `ref`  analisada mas no implementada\n- **Sem sobrecarga de funo** - Apenas uma funo por nome\n- **Sem otimizao de chamada de cauda** - Recurso profunda limitada pelo tamanho da pilha\n\n## Tpicos Relacionados\n\n- [Fluxo de Controle](#language-guide-control-flow) - Funes trabalham com estruturas de controle\n- [Objetos](#language-guide-objects) - Mtodos so funes armazenadas em objetos\n- [Tratamento de Erros](#language-guide-error-handling) - Funes e tratamento de excees\n- [Tipos](#language-guide-types) - Anotaes de tipo e converses\n\n## Veja Tambm\n\n- **Closures**: Veja a seo \"Functions\" em CLAUDE.md para semntica de closures\n- **Primeira classe**: Funes so valores como qualquer outro\n- **Escopo lxico**: Funes capturam seu ambiente de definio\n"}, "Guia da Linguagem -> Gerenciamento de Memria": {"id": "language-guide-memory", "content": "# Gerenciamento de Memoria\n\nHemlock adota **gerenciamento manual de memoria**, com controle explicito sobre alocacao e liberacao. Este guia abrange o modelo de memoria do Hemlock, os dois tipos de ponteiros e a API completa de memoria.\n\n---\n\n## Fundamentos de Memoria 101\n\n**Novo em programacao?** Comece aqui. Se voce ja entende gerenciamento de memoria, pode pular para [Filosofia de Design](#filosofia-de-design).\n\n### O que e Gerenciamento de Memoria?\n\nQuando seu programa precisa armazenar dados (texto, numeros, listas), ele precisa de espaco para colocar esses dados. Este espaco vem da memoria do computador (RAM). Gerenciamento de memoria envolve:\n\n1. **Obter espaco** - Solicitar memoria quando necessario\n2. **Usar espaco** - Ler e escrever dados\n3. **Devolver espaco** - Retornar memoria quando terminar\n\n### Por que Isso Importa?\n\nImagine uma biblioteca com livros limitados:\n- Se voce continua emprestando livros e nunca devolve, eventualmente nao havera livros disponiveis\n- Se voce tentar ler um livro que ja devolveu, havera confusao ou problemas\n\nMemoria funciona da mesma forma. Se voce esquecer de devolver memoria, seu programa usara cada vez mais memoria (\"vazamento de memoria\"). Se voce tentar usar memoria apos devolve-la, coisas ruins acontecerao.\n\n### A Boa Noticia\n\n**Na maior parte do tempo, voce nao precisa pensar nisso!**\n\nHemlock limpa automaticamente a maioria dos tipos comuns:\n\n```hemlock\nfn example() {\n    let nome = \"Alice\";       // Hemlock gerencia isso\n    let numeros = [1, 2, 3];  // E isso tambem\n    let pessoa = { age: 30 }; // E isso tambem\n\n    // Quando a funcao termina, tudo e limpo automaticamente!\n}\n```\n\n### Quando Voce Precisa Pensar Nisso\n\nVoce so precisa de gerenciamento manual de memoria ao usar:\n\n1. **`alloc()`** - Alocacao de memoria bruta (retorna `ptr`)\n2. **`buffer()`** - Quando voce quer liberar antecipadamente (opcional - libera automaticamente no fim do escopo)\n\n```hemlock\n// Isso requer limpeza manual:\nlet raw = alloc(100);   // Memoria bruta - voce deve liberar\n// ... usar raw ...\nfree(raw);              // Obrigatorio! Caso contrario, vazamento de memoria\n\n// Isso limpa automaticamente (mas voce pode liberar antes):\nlet buf = buffer(100);  // Buffer seguro\n// ... usar buf ...\n// free(buf);           // Opcional - libera automaticamente no fim do escopo\n```\n\n### Regra Simples\n\n> **Se voce chamar `alloc()`, voce deve chamar `free()`.**\n>\n> Todo o resto e tratado para voce.\n\n### Qual Devo Usar?\n\n| Cenario | Use Isso | Por Que |\n|---------|----------|---------|\n| **Comecando a aprender** | `buffer()` | Seguro, com verificacao de limites, limpeza automatica |\n| **Precisa de armazenamento de bytes** | `buffer()` | Seguro e simples |\n| **Interagindo com bibliotecas C (FFI)** | `alloc()` / `ptr` | Necessario para interoperabilidade C |\n| **Performance maxima** | `alloc()` / `ptr` | Sem overhead de verificacao de limites |\n| **Nao tem certeza** | `buffer()` | Sempre a escolha mais segura |\n\n### Exemplo Rapido: Seguro vs Bruto\n\n```hemlock\n// Recomendado: buffer seguro\nfn exemplo_seguro() {\n    let data = buffer(10);\n    data[0] = 65;           // OK\n    data[5] = 66;           // OK\n    // data[100] = 67;      // Erro - Hemlock impede (verificacao de limites)\n    free(data);             // Limpeza\n}\n\n// Avancado: ponteiro bruto (use apenas quando necessario)\nfn exemplo_bruto() {\n    let data = alloc(10);\n    *data = 65;             // OK\n    *(data + 5) = 66;       // OK\n    *(data + 100) = 67;     // Perigoso - sem verificacao de limites, corrompe memoria!\n    free(data);             // Limpeza\n}\n```\n\n**Comece com `buffer()`. So use `alloc()` quando precisar especificamente de ponteiros brutos.**\n\n---\n\n## Filosofia de Design\n\nHemlock segue gerenciamento explicito de memoria com padroes sensiveis:\n- Sem coleta de lixo (sem pausas imprevisiveis)\n- Contagem de referencias interna para tipos comuns (string, array, object, buffer)\n- Ponteiros brutos (`ptr`) requerem `free()` manual\n\nEsta abordagem hibrida oferece controle total quando necessario (ponteiros brutos), enquanto previne erros comuns em casos de uso tipicos (tipos com contagem de referencias liberam automaticamente ao sair do escopo).\n\n## Contagem de Referencias Interna\n\nO runtime usa **contagem de referencias interna** para gerenciar ciclos de vida de objetos. Para a maioria das variaveis locais de tipos com contagem de referencias, a limpeza e automatica e deterministica.\n\n### O que a Contagem de Referencias Trata\n\nO runtime gerencia automaticamente contagem de referencias quando:\n\n1. **Reatribuicao de variavel** - Valor antigo e liberado:\n   ```hemlock\n   let x = \"primeiro\";   // ref_count = 1\n   x = \"segundo\";        // \"primeiro\" liberado internamente, \"segundo\" ref_count = 1\n   ```\n\n2. **Saida de escopo** - Variaveis locais sao liberadas:\n   ```hemlock\n   fn example() {\n       let arr = [1, 2, 3];  // ref_count = 1\n   }  // arr liberado quando funcao retorna\n   ```\n\n3. **Container liberado** - Elementos sao liberados:\n   ```hemlock\n   let arr = [obj1, obj2];\n   free(arr);  // ref_count de obj1 e obj2 decrementado\n   ```\n\n### Quando `free()` e Necessario vs Automatico\n\n**Automatico (nao precisa de `free()`):** Variaveis locais de tipos com contagem de referencias sao liberadas ao sair do escopo:\n\n```hemlock\nfn process_data() {\n    let arr = [1, 2, 3];\n    let obj = { name: \"test\" };\n    let buf = buffer(64);\n    // ... usar eles ...\n}  // Todos liberados automaticamente quando funcao retorna - nao precisa de free()\n```\n\n**Requer `free()` manual:**\n\n1. **Ponteiros brutos** - `alloc()` nao tem contagem de referencias:\n   ```hemlock\n   let p = alloc(64);\n   // ... usar p ...\n   free(p);  // Sempre necessario - caso contrario vaza\n   ```\n\n2. **Limpeza antecipada** - Libera antes do fim do escopo para liberar memoria mais cedo:\n   ```hemlock\n   fn long_running() {\n       let big = buffer(10000000);  // 10MB\n       // ... terminou com big ...\n       free(big);  // Libera agora, nao espera funcao retornar\n       // ... mais trabalho que nao precisa de big ...\n   }\n   ```\n\n3. **Dados de longa duracao** - Dados globais ou armazenados em estruturas persistentes:\n   ```hemlock\n   let cache = {};  // Nivel de modulo, vive ate o programa terminar a menos que liberado\n\n   fn cleanup() {\n       free(cache);  // Limpeza manual para dados de longa duracao\n   }\n   ```\n\n### Contagem de Referencias vs Coleta de Lixo\n\n| Aspecto | Contagem de Referencias Hemlock | Coleta de Lixo |\n|---------|--------------------------------|----------------|\n| Quando limpa | Deterministico (imediatamente quando ref chega a 0) | Nao-deterministico (GC decide quando) |\n| Responsabilidade do usuario | Deve chamar `free()` | Totalmente automatico |\n| Pausas de runtime | Nenhuma | Pausas \"stop-the-world\" |\n| Visibilidade | Detalhe de implementacao oculto | Geralmente invisivel |\n| Referencias circulares | Tratadas via rastreamento de conjunto visitado | Tratadas via rastreamento |\n\n### Quais Tipos Tem Contagem de Referencias\n\n| Tipo | Contagem de Referencias | Notas |\n|------|------------------------|-------|\n| `ptr` | Nao | Sempre requer `free()` manual |\n| `buffer` | Sim | Liberado automaticamente ao sair do escopo; `free()` manual para limpeza antecipada |\n| `array` | Sim | Liberado automaticamente ao sair do escopo; `free()` manual para limpeza antecipada |\n| `object` | Sim | Liberado automaticamente ao sair do escopo; `free()` manual para limpeza antecipada |\n| `string` | Sim | Totalmente automatico, nao precisa de `free()` |\n| `function` | Sim | Totalmente automatico (ambiente de closure) |\n| `task` | Sim | Contagem de referencias atomica thread-safe |\n| `channel` | Sim | Contagem de referencias atomica thread-safe |\n| Primitivos | Nao | Alocados na stack, sem alocacao heap |\n\n### Por Que Este Design?\n\nEsta abordagem hibrida oferece:\n- **Controle explicito** - Voce decide quando liberar\n- **Seguranca de escopo** - Reatribuicao nao vaza\n- **Performance previsivel** - Sem pausas de GC\n- **Suporte a closures** - Funcoes podem capturar variaveis com seguranca\n\nA filosofia permanece: voce esta no controle, mas o runtime ajuda a prevenir erros comuns como vazamentos em reatribuicao ou double-free em containers.\n\n## Dois Tipos de Ponteiros\n\nHemlock fornece dois tipos distintos de ponteiros com diferentes caracteristicas de seguranca:\n\n### `ptr` - Ponteiro Bruto (Perigoso)\n\nPonteiros brutos sao **apenas enderecos**, com garantias minimas de seguranca:\n\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // Voce deve lembrar de liberar\n```\n\n**Caracteristicas:**\n- Apenas um endereco de 8 bytes\n- Sem verificacao de limites\n- Sem rastreamento de tamanho\n- Ciclo de vida totalmente gerenciado pelo usuario\n- Adequado para especialistas e FFI\n\n**Casos de uso:**\n- Programacao de sistemas de baixo nivel\n- Interface de Funcao Estrangeira (FFI)\n- Codigo critico de performance\n- Quando controle total e necessario\n\n**Perigos:**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Muito alem da alocacao - permitido mas perigoso\nfree(p);\nlet x = *p;       // Ponteiro dangling - comportamento indefinido\nfree(p);          // Double free - vai crashar\n```\n\n### `buffer` - Wrapper Seguro (Recomendado)\n\nBuffer fornece **acesso com verificacao de limites** enquanto ainda requer liberacao manual:\n\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Verificacao de limites\nprint(b.length);        // 64\nfree(b);                // Ainda e manual\n```\n\n**Caracteristicas:**\n- Ponteiro + tamanho + capacidade\n- Verificacao de limites no acesso\n- Ainda requer `free()` manual\n- Padrao melhor para a maioria do codigo\n\n**Propriedades:**\n```hemlock\nlet buf = buffer(100);\nprint(buf.length);      // 100 (tamanho atual)\nprint(buf.capacity);    // 100 (capacidade alocada)\n```\n\n**Verificacao de limites:**\n```hemlock\nlet buf = buffer(10);\nbuf[5] = 42;      // OK\nbuf[100] = 42;    // Erro: indice fora dos limites\n```\n\n## API de Memoria\n\n### Alocacao Principal\n\n**`alloc(bytes)` - Aloca memoria bruta**\n```hemlock\nlet p = alloc(1024);  // Aloca 1KB, retorna ptr\n// ... usar memoria\nfree(p);\n```\n\n**`buffer(size)` - Aloca buffer seguro**\n```hemlock\nlet buf = buffer(256);  // Aloca buffer de 256 bytes\nbuf[0] = 65;            // 'A'\nbuf[1] = 66;            // 'B'\nfree(buf);\n```\n\n**`free(ptr)` - Libera memoria**\n```hemlock\nlet p = alloc(100);\nfree(p);  // Deve liberar para evitar vazamento de memoria\n\nlet buf = buffer(100);\nfree(buf);  // Funciona para ptr e buffer\n```\n\n**Importante:** `free()` funciona para tipos `ptr` e `buffer`.\n\n### Operacoes de Memoria\n\n**`memset(ptr, byte, size)` - Preenche memoria**\n```hemlock\nlet p = alloc(100);\nmemset(p, 0, 100);     // Zera 100 bytes\nmemset(p, 65, 10);     // Preenche primeiros 10 bytes com 'A'\nfree(p);\n```\n\n**`memcpy(dest, src, size)` - Copia memoria**\n```hemlock\nlet src = alloc(50);\nlet dst = alloc(50);\nmemset(src, 42, 50);\nmemcpy(dst, src, 50);  // Copia 50 bytes de src para dst\nfree(src);\nfree(dst);\n```\n\n**`realloc(ptr, size)` - Redimensiona alocacao**\n```hemlock\nlet p = alloc(100);\n// ... usar 100 bytes\np = realloc(p, 200);   // Redimensiona para 200 bytes\n// ... usar 200 bytes\nfree(p);\n```\n\n**Nota:** Apos `realloc()`, o ponteiro antigo pode ser invalido. Sempre use o ponteiro retornado.\n\n### Alocacao Tipada\n\nHemlock fornece helpers de alocacao tipada para conveniencia:\n\n```hemlock\nlet arr = talloc(i32, 100);  // Aloca 100 valores i32 (400 bytes)\nlet size = sizeof(i32);      // Retorna 4 (bytes)\n```\n\n**`sizeof(type)`** retorna o tamanho em bytes de um tipo:\n- `sizeof(i8)` / `sizeof(u8)` -> 1\n- `sizeof(i16)` / `sizeof(u16)` -> 2\n- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` -> 4\n- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` -> 8\n- `sizeof(ptr)` -> 8 (sistemas 64-bit)\n\n**`talloc(type, count)`** aloca `count` elementos do `type`:\n\n```hemlock\nlet ints = talloc(i32, 10);   // 40 bytes para 10 valores i32\nlet floats = talloc(f64, 5);  // 40 bytes para 5 valores f64\nfree(ints);\nfree(floats);\n```\n\n## Padroes Comuns\n\n### Padrao: Alocar, Usar, Liberar\n\nO padrao basico de gerenciamento de memoria:\n\n```hemlock\n// 1. Alocar\nlet data = alloc(1024);\n\n// 2. Usar\nmemset(data, 0, 1024);\n// ... fazer trabalho\n\n// 3. Liberar\nfree(data);\n```\n\n### Padrao: Uso Seguro de Buffer\n\nPrefira buffer para acesso com verificacao de limites:\n\n```hemlock\nlet buf = buffer(256);\n\n// Iteracao segura\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\nfree(buf);\n```\n\n### Padrao: Gerenciamento de Recursos com try/finally\n\nGarante limpeza mesmo em erros:\n\n```hemlock\nlet data = alloc(1024);\ntry {\n    // ... operacoes arriscadas\n    process(data);\n} finally {\n    free(data);  // Libera mesmo em erro\n}\n```\n\n## Consideracoes de Seguranca de Memoria\n\n### Double Free\n\n**Permitido mas vai crashar:**\n```hemlock\nlet p = alloc(100);\nfree(p);\nfree(p);  // Crash: double free detectado\n```\n\n**Prevencao:**\n```hemlock\nlet p = alloc(100);\nfree(p);\np = null;  // Define como null apos liberar\n\nif (p != null) {\n    free(p);  // Nao vai executar\n}\n```\n\n### Ponteiro Dangling\n\n**Permitido mas comportamento indefinido:**\n```hemlock\nlet p = alloc(100);\n*p = 42;      // OK\nfree(p);\nlet x = *p;   // Indefinido: lendo memoria liberada\n```\n\n**Prevencao:** Nao acesse memoria apos liberar.\n\n### Vazamento de Memoria\n\n**Facil de criar, dificil de debugar:**\n```hemlock\nfn leak_memory() {\n    let p = alloc(1000);\n    // Esqueceu de liberar!\n    return;  // Vazamento de memoria\n}\n```\n\n**Prevencao:** Sempre pareie `alloc()` com `free()`:\n```hemlock\nfn safe_function() {\n    let p = alloc(1000);\n    try {\n        // ... usar p\n    } finally {\n        free(p);  // Sempre libera\n    }\n}\n```\n\n### Aritmetica de Ponteiros\n\n**Permitida mas perigosa:**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Muito alem dos limites da alocacao\n*q = 42;          // Indefinido: escrita fora dos limites\nfree(p);\n```\n\n**Use buffer para verificacao de limites:**\n```hemlock\nlet buf = buffer(10);\nbuf[100] = 42;  // Erro: verificacao de limites previne overflow\n```\n\n## Melhores Praticas\n\n1. **Use `buffer` por padrao** - Use `buffer` a menos que precise especificamente de `ptr` bruto\n2. **Pareie alloc/free** - Cada `alloc()` deve ter exatamente um `free()`\n3. **Use try/finally** - Use tratamento de excecoes para garantir limpeza\n4. **Null apos free** - Defina ponteiros como `null` apos liberar para capturar uso-apos-liberar\n5. **Verificacao de limites** - Use indexacao de buffer para verificacao automatica de limites\n6. **Documente propriedade** - Deixe claro qual codigo possui e libera cada alocacao\n\n## Exemplos\n\n### Exemplo: Construtor de String Dinamico\n\n```hemlock\nfn build_message(count: i32): ptr {\n    let size = count * 10;\n    let buf = alloc(size);\n\n    let i = 0;\n    while (i < count) {\n        memset(buf + (i * 10), 65 + i, 10);\n        i = i + 1;\n    }\n\n    return buf;  // Chamador deve liberar\n}\n\nlet msg = build_message(5);\n// ... usar msg\nfree(msg);\n```\n\n### Exemplo: Operacoes Seguras de Array\n\n```hemlock\nfn process_array(size: i32) {\n    let arr = buffer(size);\n\n    try {\n        // Preencher array\n        let i = 0;\n        while (i < arr.length) {\n            arr[i] = i * 2;\n            i = i + 1;\n        }\n\n        // Processar\n        i = 0;\n        while (i < arr.length) {\n            print(arr[i]);\n            i = i + 1;\n        }\n    } finally {\n        free(arr);  // Sempre limpa\n    }\n}\n```\n\n### Exemplo: Padrao de Pool de Memoria\n\n```hemlock\n// Pool de memoria simples (simplificado)\nlet pool = alloc(10000);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > 10000) {\n        throw \"Pool esgotado\";\n    }\n\n    let ptr = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return ptr;\n}\n\n// Usar pool\nlet p1 = pool_alloc(100);\nlet p2 = pool_alloc(200);\n\n// Liberar pool inteiro de uma vez\nfree(pool);\n```\n\n## Limitacoes\n\nLimitacoes atuais a serem observadas:\n\n- **Ponteiros brutos requerem liberacao manual** - `alloc()` retorna `ptr` sem contagem de referencias\n- **Sem alocadores customizados** - Apenas malloc/free do sistema\n\n**Nota:** Tipos com contagem de referencias (string, array, object, buffer) liberam automaticamente ao sair do escopo. Apenas `ptr` bruto de `alloc()` requer `free()` explicito.\n\n## Topicos Relacionados\n\n- [Strings](#language-guide-strings) - Gerenciamento de memoria de strings e codificacao UTF-8\n- [Arrays](#language-guide-arrays) - Arrays dinamicos e suas caracteristicas de memoria\n- [Objetos](#language-guide-objects) - Alocacao e ciclo de vida de objetos\n- [Tratamento de Erros](#language-guide-error-handling) - Limpeza com try/finally\n\n## Veja Tambem\n\n- **Filosofia de Design**: Veja secao \"Memory Management\" em CLAUDE.md\n- **Sistema de Tipos**: Veja [Tipos](#language-guide-types) para detalhes dos tipos `ptr` e `buffer`\n- **FFI**: Ponteiros brutos sao essenciais para Interface de Funcao Estrangeira\n"}, "Guia da Linguagem -> Mdulos": {"id": "language-guide-modules", "content": "# Sistema de Mdulos do Hemlock\n\nEste documento descreve o sistema de mdulos import/export no estilo ES6 implementado para Hemlock.\n\n## Visao Geral\n\nHemlock suporta um sistema de mdulos baseado em arquivos usando sintaxe de import/export no estilo ES6. Mdulos tm as seguintes caractersticas:\n- **Singleton**: Cada mdulo  carregado apenas uma vez e armazenado em cache\n- **Baseado em arquivo**: Mdulos correspondem a arquivos .hml no disco\n- **Imports explcitos**: Dependncias so declaradas atravs de declaraes import\n- **Execuo topolgica**: Dependncias executam antes dos dependentes\n\nPara gerenciamento de pacotes e dependncias de terceiros, veja [hpm (Hemlock Package Manager)](https://github.com/hemlang/hpm).\n\n## Sintaxe\n\n### Declaraes Export\n\n**Exports nomeados inline:**\n```hemlock\nexport fn add(a, b) {\n    return a + b;\n}\n\nexport const PI = 3.14159;\nexport let contador = 0;\n```\n\n**Lista de exports:**\n```hemlock\nfn add(a, b) { return a + b; }\nfn subtract(a, b) { return a - b; }\n\nexport { add, subtract };\n```\n\n**Exportando Extern (funes FFI):**\n```hemlock\nimport \"libc.so.6\";\n\n// Exporta funes FFI para uso de outros mdulos\nexport extern fn strlen(s: string): i32;\nexport extern fn getpid(): i32;\n```\n\nPara mais detalhes sobre exportar funes FFI, veja a [documentao FFI](../advanced/ffi.md#exporting-ffi-functions).\n\n**Exportando Define (tipos struct):**\n```hemlock\n// Exporta definies de tipo struct\nexport define Vector2 {\n    x: f32,\n    y: f32,\n}\n\nexport define Rectangle {\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n}\n```\n\n**Nota importante:** Tipos struct exportados so registrados globalmente quando o mdulo  carregado. Eles ficam automaticamente disponveis quando voc importa qualquer coisa do mdulo - voc no precisa (e no pode) import-los explicitamente por nome:\n\n```hemlock\n// Correto - tipos struct ficam disponveis automaticamente aps qualquer import\nimport { some_function } from \"./my_module.hml\";\nlet v: Vector2 = { x: 1.0, y: 2.0 };  // Funciona!\n\n// Errado - no pode importar tipos struct explicitamente\nimport { Vector2 } from \"./my_module.hml\";  // Erro: varivel 'Vector2' indefinida\n```\n\nPara mais detalhes sobre exportar tipos struct, veja a [documentao FFI](../advanced/ffi.md#exporting-struct-types).\n\n**Re-exports:**\n```hemlock\n// Re-exporta de outro mdulo\nexport { add, subtract } from \"./math.hml\";\n```\n\n### Declaraes Import\n\n**Imports nomeados:**\n```hemlock\nimport { add, subtract } from \"./math.hml\";\nprint(add(1, 2));  // 3\n```\n\n**Import de namespace:**\n```hemlock\nimport * as math from \"./math.hml\";\nprint(math.add(1, 2));  // 3\nprint(math.PI);  // 3.14159\n```\n\n**Aliases:**\n```hemlock\nimport { add as soma, subtract as subtrair } from \"./math.hml\";\nprint(soma(1, 2));  // 3\n```\n\n## Resoluo de Mdulos\n\n### Tipos de Caminho\n\n**Caminhos relativos:**\n```hemlock\nimport { foo } from \"./module.hml\";       // Mesmo diretrio\nimport { bar } from \"../parent.hml\";      // Diretrio pai\nimport { baz } from \"./sub/nested.hml\";   // Subdiretrio\n```\n\n**Caminhos absolutos:**\n```hemlock\nimport { foo } from \"/absolute/path/to/module.hml\";\n```\n\n**Tratamento de extenso:**\n- Extenso `.hml` pode ser omitida - ser adicionada automaticamente\n- `./math` resolve para `./math.hml`\n\n## Recursos\n\n### Deteco de Dependncia Circular\n\nO sistema de mdulos detecta dependncias circulares e reporta erros:\n\n```\nError: Circular dependency detected when loading '/path/to/a.hml'\n```\n\n### Cache de Mdulos\n\nMdulos so carregados apenas uma vez e armazenados em cache. Mltiplos imports do mesmo mdulo retornam a mesma instncia:\n\n```hemlock\n// counter.hml\nexport let count = 0;\nexport fn increment() {\n    count = count + 1;\n}\n\n// a.hml\nimport { count, increment } from \"./counter.hml\";\nincrement();\nprint(count);  // 1\n\n// b.hml\nimport { count } from \"./counter.hml\";  // Mesma instncia!\nprint(count);  // Ainda 1 (estado compartilhado)\n```\n\n### Imutabilidade de Imports\n\nBindings importados no podem ser reatribudos:\n\n```hemlock\nimport { add } from \"./math.hml\";\nadd = fn() { };  // Erro: no pode reatribuir binding importado\n```\n\n## Detalhes de Implementao\n\n### Arquitetura\n\n**Arquivos:**\n- `include/module.h` - API do sistema de mdulos\n- `src/module.c` - Carregamento, cache e execuo de mdulos\n- Suporte de parser em `src/parser.c`\n- Suporte de runtime em `src/interpreter/runtime.c`\n\n**Componentes principais:**\n1. **ModuleCache**: Mantm mdulos carregados indexados por caminho absoluto\n2. **Module**: Representa um mdulo carregado com AST e exports\n3. **Resoluo de caminho**: Resolve caminhos relativos/absolutos para caminhos cannicos\n4. **Execuo topolgica**: Executa mdulos em ordem de dependncia\n\n### Processo de Carregamento de Mdulos\n\n1. **Fase de parse**: Anlise lxica e sinttica do arquivo de mdulo\n2. **Resoluo de dependncias**: Carrega recursivamente mdulos importados\n3. **Deteco de ciclos**: Verifica se mdulo j est sendo carregado\n4. **Caching**: Armazena mdulo no cache por caminho absoluto\n5. **Fase de execuo**: Executa em ordem topolgica (dependncias primeiro)\n\n### API\n\n```c\n// API de alto nvel\nint execute_file_with_modules(const char *file_path,\n                               int argc, char **argv,\n                               ExecutionContext *ctx);\n\n// API de baixo nvel\nModuleCache* module_cache_new(const char *initial_dir);\nvoid module_cache_free(ModuleCache *cache);\nModule* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);\nvoid execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);\n```\n\n## Testes\n\nMdulos de teste esto localizados em `tests/modules/` e `tests/parity/modules/`:\n\n- `math.hml` - Mdulo bsico com exports\n- `test_import_named.hml` - Teste de imports nomeados\n- `test_import_namespace.hml` - Teste de import de namespace\n- `test_import_alias.hml` - Teste de alias de import\n- `export_extern.hml` - Teste de export de funes FFI extern (Linux)\n\n## Imports de Pacotes (hpm)\n\nCom [hpm](https://github.com/hemlang/hpm) instalado, voc pode importar pacotes de terceiros do GitHub:\n\n```hemlock\n// Importa da raiz do pacote (usando \"main\" do package.json)\nimport { app, router } from \"hemlang/sprout\";\n\n// Importa de subcaminho\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// Biblioteca padro (embutida no Hemlock)\nimport { HashMap } from \"@stdlib/collections\";\n```\n\nPacotes so instalados em `hem_modules/` e resolvidos usando sintaxe `owner/repo` do GitHub.\n\n```bash\n# Instalar pacote\nhpm install hemlang/sprout\n\n# Instalar com restrio de verso\nhpm install hemlang/sprout@^1.0.0\n```\n\nPara detalhes completos, veja a [documentao do hpm](https://github.com/hemlang/hpm).\n\n## Limitaes Atuais\n\n1. **Sem imports dinmicos**: `import()` como funo de runtime no  suportado\n2. **Sem exports condicionais**: Exports devem estar no nvel superior\n3. **Caminhos de biblioteca estticos**: Imports de biblioteca FFI usam caminhos estticos (especficos de plataforma)\n\n## Trabalho Futuro\n\n- Imports dinmicos usando funo `import()`\n- Exports condicionais\n- Metadados de mdulo (`import.meta`)\n- Tree shaking e eliminao de cdigo morto\n\n## Exemplos\n\nPara exemplos funcionais do sistema de mdulos, veja `tests/modules/`.\n\nEstrutura de mdulo de exemplo:\n```\nproject/\n main.hml\n lib/\n    math.hml\n    string.hml\n    index.hml (mdulo barrel)\n utils/\n     helpers.hml\n```\n\nUso de exemplo:\n```hemlock\n// lib/math.hml\nexport fn add(a, b) { return a + b; }\nexport fn multiply(a, b) { return a * b; }\n\n// lib/index.hml (barrel)\nexport { add, multiply } from \"./math.hml\";\n\n// main.hml\nimport { add } from \"./lib/index.hml\";\nprint(add(2, 3));  // 5\n```\n"}, "Guia da Linguagem -> Objetos": {"id": "language-guide-objects", "content": "# Objetos\n\nHemlock implementa objetos estilo JavaScript com alocao no heap, campos dinmicos, mtodos e duck typing. Objetos so estruturas de dados flexveis que combinam dados e comportamento.\n\n## Viso Geral\n\n```hemlock\n// Objeto annimo\nlet person = { name: \"Alice\", age: 30, city: \"NYC\" };\nprint(person.name);  // \"Alice\"\n\n// Objeto com mtodos\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## Literais de Objeto\n\n### Sintaxe Bsica\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n```\n\n**Sintaxe:**\n- Chaves `{}` envolvem o objeto\n- Pares chave-valor separados por vrgulas\n- Chaves so identificadores (no precisam de aspas)\n- Valores podem ser qualquer tipo\n\n### Objeto Vazio\n\n```hemlock\nlet obj = {};  // Objeto vazio\n\n// Adicionar campos depois\nobj.name = \"Alice\";\nobj.age = 30;\n```\n\n### Objetos Aninhados\n\n```hemlock\nlet user = {\n    info: {\n        name: \"Bob\",\n        age: 25\n    },\n    active: true,\n    settings: {\n        theme: \"dark\",\n        notifications: true\n    }\n};\n\nprint(user.info.name);           // \"Bob\"\nprint(user.settings.theme);      // \"dark\"\n```\n\n### Valores de Tipos Mistos\n\n```hemlock\nlet mixed = {\n    number: 42,\n    text: \"hello\",\n    flag: true,\n    data: null,\n    items: [1, 2, 3],\n    config: { x: 10, y: 20 }\n};\n```\n\n### Sintaxe de Propriedade Abreviada\n\nQuando o nome da varivel corresponde ao nome da propriedade, use sintaxe abreviada:\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\nlet active = true;\n\n// Abreviado: { name } equivale a { name: name }\nlet person = { name, age, active };\n\nprint(person.name);   // \"Alice\"\nprint(person.age);    // 30\nprint(person.active); // true\n```\n\n**Misturando abreviado e propriedades regulares:**\n```hemlock\nlet city = \"NYC\";\nlet obj = { name, age, city, role: \"admin\" };\n```\n\n### Operador Spread\n\nO operador spread (`...`) copia todos os campos de um objeto para outro:\n\n```hemlock\nlet base = { x: 1, y: 2 };\nlet extended = { ...base, z: 3 };\n\nprint(extended.x);  // 1\nprint(extended.y);  // 2\nprint(extended.z);  // 3\n```\n\n**Sobrescrevendo valores com spread:**\n```hemlock\nlet defaults = { theme: \"light\", size: \"medium\", debug: false };\nlet custom = { ...defaults, theme: \"dark\" };\n\nprint(custom.theme);  // \"dark\" (sobrescrito)\nprint(custom.size);   // \"medium\" (de defaults)\nprint(custom.debug);  // false (de defaults)\n```\n\n**Mltiplos spreads (ltimos sobrescrevem anteriores):**\n```hemlock\nlet a = { x: 1 };\nlet b = { y: 2 };\nlet merged = { ...a, ...b, z: 3 };\n\nprint(merged.x);  // 1\nprint(merged.y);  // 2\nprint(merged.z);  // 3\n\n// Spreads posteriores sobrescrevem anteriores\nlet first = { val: \"first\" };\nlet second = { val: \"second\" };\nlet combined = { ...first, ...second };\nprint(combined.val);  // \"second\"\n```\n\n**Combinando abreviado e spread:**\n```hemlock\nlet status = \"active\";\nlet data = { id: 1, name: \"Item\" };\nlet full = { ...data, status };\n\nprint(full.id);      // 1\nprint(full.name);    // \"Item\"\nprint(full.status);  // \"active\"\n```\n\n**Padro de sobrescrita de configurao:**\n```hemlock\nlet defaultConfig = {\n    debug: false,\n    timeout: 30,\n    retries: 3\n};\n\nlet prodConfig = { ...defaultConfig, timeout: 60 };\nlet devConfig = { ...defaultConfig, debug: true };\n\nprint(prodConfig.timeout);  // 60\nprint(devConfig.debug);     // true\n```\n\n**Nota:** Spread executa cpia rasa. Objetos aninhados compartilham referncia:\n```hemlock\nlet nested = { inner: { val: 42 } };\nlet copied = { ...nested };\nprint(copied.inner.val);  // 42 (mesma referncia que nested.inner)\n```\n\n## Acesso a Campos\n\n### Sintaxe de Ponto\n\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\n\n// Lendo campos\nlet name = person.name;      // \"Alice\"\nlet age = person.age;        // 30\n\n// Modificando campos\nperson.age = 31;\nprint(person.age);           // 31\n```\n\n### Adio Dinmica de Campos\n\nAdicione novos campos em tempo de execuo:\n\n```hemlock\nlet person = { name: \"Alice\" };\n\n// Adicionar novos campos\nperson.email = \"alice@example.com\";\nperson.phone = \"555-1234\";\n\nprint(person.email);  // \"alice@example.com\"\n```\n\n### Remoo de Campos\n\n**Nota:** Remoo de campos no  suportada atualmente. Defina como `null` em vez disso:\n\n```hemlock\nlet obj = { x: 10, y: 20 };\n\n// No pode remover campos (no suportado)\n// obj.x = undefined;  // No existe 'undefined' em Hemlock\n\n// Alternativa: definir como null\nobj.x = null;\n```\n\n## Mtodos e `self`\n\n### Definindo Mtodos\n\nMtodos so funes armazenadas em campos de objeto:\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    decrement: fn() {\n        self.count = self.count - 1;\n    },\n    get: fn() {\n        return self.count;\n    }\n};\n```\n\n### Palavra-chave `self`\n\nQuando uma funo  chamada como mtodo, `self`  automaticamente vinculado ao objeto:\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;  // self aponta para counter\n    }\n};\n\ncounter.increment();  // self vinculado a counter\nprint(counter.count);  // 1\n```\n\n**Como funciona:**\n- Deteco de chamada de mtodo verifica se a expresso de funo  acesso a propriedade\n- `self`  automaticamente vinculado ao objeto no momento da chamada\n- `self`  somente leitura (no pode reatribuir `self` em si)\n\n### Deteco de Chamada de Mtodo\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() {\n        return self.value;\n    }\n};\n\n// Chamado como mtodo - self  vinculado\nprint(obj.method());  // 10\n\n// Chamado como funo - self  null (erro)\nlet f = obj.method;\nprint(f());  // Erro: self no definido\n```\n\n### Mtodos com Parmetros\n\n```hemlock\nlet calculator = {\n    result: 0,\n    add: fn(x) {\n        self.result = self.result + x;\n    },\n    multiply: fn(x) {\n        self.result = self.result * x;\n    },\n    get: fn() {\n        return self.result;\n    }\n};\n\ncalculator.add(5);\ncalculator.multiply(2);\nprint(calculator.get());  // 10\n```\n\n## Definies de Tipo com `define`\n\n### Definio de Tipo Bsica\n\nUse `define` para definir estrutura de objeto:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active: bool,\n}\n\n// Criar objeto e atribuir a varivel tipada\nlet p = { name: \"Alice\", age: 30, active: true };\nlet typed_p: Person = p;  // Duck typing valida estrutura\n\nprint(typeof(typed_p));  // \"Person\"\n```\n\n**O que `define` faz:**\n- Declara tipo com campos obrigatrios\n- Habilita validao de duck typing\n- Define nome do tipo do objeto para `typeof()`\n\n### Duck Typing\n\nObjetos so validados contra `define` usando **compatibilidade estrutural**:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// Correto: tem todos os campos obrigatrios\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// Correto: campos extras permitidos\nlet p2: Person = {\n    name: \"Bob\",\n    age: 25,\n    city: \"NYC\",\n    active: true\n};\n\n// Erro: falta campo obrigatrio 'age'\nlet p3: Person = { name: \"Carol\" };\n\n// Erro: tipo errado para 'age'\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```\n\n**Regras de duck typing:**\n- Todos os campos obrigatrios devem estar presentes\n- Tipos de campo devem corresponder\n- Campos extras so permitidos e preservados\n- Validao ocorre na atribuio\n\n### Campos Opcionais\n\nCampos podem ser opcionais com valores padro:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,       // Opcional com valor padro\n    nickname?: string,   // Opcional, padro null\n}\n\n// Objeto apenas com campos obrigatrios\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.active);    // true (padro aplicado)\nprint(typed_p.nickname);  // null (sem padro)\n\n// Pode sobrescrever campos opcionais\nlet p2: Person = { name: \"Bob\", age: 25, active: false };\nprint(p2.active);  // false (sobrescrito)\n```\n\n**Sintaxe de campos opcionais:**\n- `field?: default_value` - Opcional com valor padro\n- `field?: type` - Opcional com anotao de tipo, padro null\n- Se campo opcional estiver faltando,  adicionado durante verificao de duck typing\n\n### Verificao de Tipo\n\n```hemlock\ndefine Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = { x: 10, y: 20 };\nlet point: Point = p;  // Verificao de tipo ocorre aqui\n\nprint(typeof(point));  // \"Point\"\nprint(typeof(p));      // \"object\" (objeto original ainda  annimo)\n```\n\n**Quando verificao de tipo ocorre:**\n- Na atribuio a varivel tipada\n- Verifica se todos os campos obrigatrios existem\n- Verifica se tipos de campo correspondem (com converso implcita)\n- Define nome do tipo do objeto\n\n## Assinaturas de Mtodo em Define\n\nBlocos define podem especificar assinaturas de mtodo, criando contratos tipo interface:\n\n### Mtodos Obrigatrios\n\n```hemlock\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32;  // Assinatura de mtodo obrigatria\n}\n\n// Objeto deve fornecer mtodos obrigatrios\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n```\n\n### Mtodos Opcionais\n\n```hemlock\ndefine Serializable {\n    fn serialize(): string;       // Obrigatrio\n    fn pretty?(): string;         // Mtodo opcional (pode no existir)\n}\n```\n\n### Tipo `Self`\n\n`Self` refere-se ao tipo sendo definido, suportando definies de tipo recursivas:\n\n```hemlock\ndefine Cloneable {\n    fn clone(): Self;  // Retorna mesmo tipo que o objeto\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;  // Aceita mesmo tipo como parmetro\n    fn equals(other: Self): bool;\n}\n\nlet item: Cloneable = {\n    value: 42,\n    clone: fn() {\n        return { value: self.value, clone: self.clone };\n    }\n};\n```\n\n### Misturando Campos e Mtodos\n\n```hemlock\ndefine Entity {\n    id: i32,\n    name: string,\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\nlet user: Entity = {\n    id: 1,\n    name: \"Alice\",\n    validate: fn() { return self.id > 0 && self.name != \"\"; },\n    serialize: fn() { return '{\"id\":' + self.id + ',\"name\":\"' + self.name + '\"}'; }\n};\n```\n\n## Tipos Compostos (Tipos de Interseo)\n\nTipos compostos usam `&` para exigir que objetos satisfaam mltiplas definies de tipo:\n\n### Tipo Composto Bsico\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\n// Tipo composto: objeto deve satisfazer todos os tipos\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n```\n\n### Parmetros de Funo com Tipos Compostos\n\n```hemlock\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" is \" + p.age);\n}\n\ngreet({ name: \"Bob\", age: 25, city: \"NYC\" });  // Campos extras permitidos\n```\n\n### Trs ou Mais Tipos\n\n```hemlock\ndefine HasEmail { email: string }\n\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n### Aliases de Tipo para Tipos Compostos\n\n```hemlock\n// Criar alias nomeado para tipo composto\ntype Person = HasName & HasAge;\ntype Employee = HasName & HasAge & HasEmail;\n\nlet emp: Employee = {\n    name: \"Charlie\",\n    age: 35,\n    email: \"charlie@example.com\"\n};\n```\n\n**Duck typing de tipos compostos:** Campos extras so sempre permitidos - objetos s precisam ter pelo menos todos os campos requeridos por todos os tipos componentes.\n\n## Serializao JSON\n\n### Serializando para JSON\n\nConverta objetos para string JSON:\n\n```hemlock\n// obj.serialize() - converte objeto para string JSON\nlet obj = { x: 10, y: 20, name: \"test\" };\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// Objetos aninhados\nlet nested = { inner: { a: 1, b: 2 }, outer: 3 };\nprint(nested.serialize());  // {\"inner\":{\"a\":1,\"b\":2},\"outer\":3}\n```\n\n### Desserializando de JSON\n\nParse string JSON de volta para objeto:\n\n```hemlock\n// json.deserialize() - parse string JSON para objeto\nlet json_str = '{\"x\":10,\"y\":20,\"name\":\"test\"}';\nlet obj = json_str.deserialize();\n\nprint(obj.name);   // \"test\"\nprint(obj.x);      // 10\n```\n\n### Deteco de Referncia Circular\n\nReferncias circulares so detectadas e causam erro:\n\n```hemlock\nlet obj = { x: 10 };\nobj.me = obj;  // Cria referncia circular\n\nobj.serialize();  // Erro: serialize() detectou referncia circular\n```\n\n### Tipos Suportados\n\nSerializao JSON suporta:\n\n- **Nmeros**: i8-i32, u8-u32, f32, f64\n- **Booleanos**: true, false\n- **Strings**: com sequncias de escape\n- **Null**: valor null\n- **Objetos**: objetos aninhados\n- **Arrays**: arrays aninhados\n\n**No suportados:**\n- Funes (omitidas silenciosamente)\n- Ponteiros (erro)\n- Buffer (erro)\n\n### Tratamento de Erros\n\nSerializao e desserializao podem lanar erros:\n\n```hemlock\n// JSON invlido lana erro\ntry {\n    let bad = \"not valid json\".deserialize();\n} catch (e) {\n    print(\"Parse error:\", e);\n}\n\n// Ponteiros no podem ser serializados\nlet obj = { ptr: alloc(10) };\ntry {\n    obj.serialize();\n} catch (e) {\n    print(\"Serialize error:\", e);\n}\n```\n\n### Exemplo de Ida e Volta\n\nExemplo completo de serializao e desserializao:\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug: bool\n}\n\n// Criar e serializar\nlet config: Config = {\n    host: \"localhost\",\n    port: 8080,\n    debug: true\n};\nlet json = config.serialize();\nprint(json);  // {\"host\":\"localhost\",\"port\":8080,\"debug\":true}\n\n// Desserializar\nlet restored = json.deserialize();\nprint(restored.host);  // \"localhost\"\nprint(restored.port);  // 8080\n```\n\n## Funes Embutidas\n\n### `typeof(value)`\n\nRetorna nome do tipo como string:\n\n```hemlock\nlet obj = { x: 10 };\nprint(typeof(obj));  // \"object\"\n\ndefine Person { name: string, age: i32 }\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(typeof(p));    // \"Person\"\n```\n\n**Valores de retorno:**\n- Objeto annimo: `\"object\"`\n- Objeto tipado: nome do tipo personalizado (ex: `\"Person\"`)\n\n## Detalhes de Implementao\n\n### Modelo de Memria\n\n- **Alocao no heap** - Todos os objetos so alocados no heap\n- **Cpia rasa** - Atribuio copia referncia, no objeto\n- **Campos dinmicos** - Armazenados como array dinmico de pares nome/valor\n- **Contagem de referncia** - Objetos so liberados automaticamente ao sair do escopo\n\n### Semntica de Referncia\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Cpia rasa (mesma referncia)\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (ambos apontam para mesmo objeto)\n```\n\n### Armazenamento de Mtodos\n\nMtodos so apenas funes armazenadas em campos:\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// method  uma funo armazenada em obj.method\nprint(typeof(obj.method));  // \"function\"\n```\n\n## Padres Comuns\n\n### Padro: Construtor\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```\n\n### Padro: Builder de Objeto\n\n```hemlock\nfn PersonBuilder() {\n    return {\n        name: null,\n        age: null,\n\n        setName: fn(n) {\n            self.name = n;\n            return self;  // Suporta encadeamento\n        },\n\n        setAge: fn(a) {\n            self.age = a;\n            return self;\n        },\n\n        build: fn() {\n            return { name: self.name, age: self.age };\n        }\n    };\n}\n\nlet person = PersonBuilder()\n    .setName(\"Alice\")\n    .setAge(30)\n    .build();\n```\n\n### Padro: Objeto de Estado\n\n```hemlock\nlet state = {\n    status: \"idle\",\n    data: null,\n    error: null,\n\n    setState: fn(new_status) {\n        self.status = new_status;\n    },\n\n    setData: fn(new_data) {\n        self.data = new_data;\n        self.status = \"success\";\n    },\n\n    setError: fn(err) {\n        self.error = err;\n        self.status = \"error\";\n    }\n};\n```\n\n### Padro: Objeto de Configurao\n\n```hemlock\nlet config = {\n    defaults: {\n        timeout: 30,\n        retries: 3,\n        debug: false\n    },\n\n    get: fn(key) {\n        if (self.defaults[key] != null) {\n            return self.defaults[key];\n        }\n        return null;\n    },\n\n    set: fn(key, value) {\n        self.defaults[key] = value;\n    }\n};\n```\n\n## Melhores Prticas\n\n1. **Use `define` para estruturas** - Documente formas de objeto esperadas\n2. **Prefira funes de fbrica** - Use construtores para criar objetos\n3. **Mantenha objetos simples** - No aninhe muito profundamente\n4. **Documente uso de `self`** - Deixe comportamento de mtodo claro\n5. **Valide na atribuio** - Use duck typing para detectar erros cedo\n6. **Evite referncias circulares** - Causam erros de serializao\n7. **Use campos opcionais** - Fornea padres razoveis\n\n## Armadilhas Comuns\n\n### Armadilha: Referncia vs Valor\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Cpia rasa\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (inesperado! ambos mudaram)\n\n// Evitar: criar novo objeto\nlet obj3 = { x: obj1.x };  // Cpia profunda (manual)\n```\n\n### Armadilha: `self` em Chamadas No-mtodo\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// Vlido: chamado como mtodo\nprint(obj.method());  // 10\n\n// Erro: chamado como funo\nlet f = obj.method;\nprint(f());  // Erro: self no definido\n```\n\n### Armadilha: Ponteiros Brutos em Objetos\n\n```hemlock\n// Objetos so liberados automaticamente, mas ponteiros brutos neles no\nfn create_objects() {\n    let obj = { data: alloc(1000) };  // Ponteiro bruto precisa de free manual\n    // obj liberado automaticamente ao sair do escopo, mas obj.data vaza!\n}\n\n// Soluo: libere ponteiros brutos antes de sair do escopo\nfn safe_create() {\n    let obj = { data: alloc(1000) };\n    // ... use obj.data ...\n    free(obj.data);  // Libere ponteiro bruto explicitamente\n}  // obj em si  liberado automaticamente\n```\n\n### Armadilha: Confuso de Tipo\n\n```hemlock\nlet obj = { x: 10 };\n\ndefine Point { x: i32, y: i32 }\n\n// Erro: falta campo obrigatrio 'y'\nlet p: Point = obj;\n```\n\n## Exemplos\n\n### Exemplo: Matemtica Vetorial\n\n```hemlock\nfn createVector(x, y) {\n    return {\n        x: x,\n        y: y,\n\n        add: fn(other) {\n            return createVector(\n                self.x + other.x,\n                self.y + other.y\n            );\n        },\n\n        length: fn() {\n            return sqrt(self.x * self.x + self.y * self.y);\n        },\n\n        toString: fn() {\n            return \"(\" + typeof(self.x) + \", \" + typeof(self.y) + \")\";\n        }\n    };\n}\n\nlet v1 = createVector(3, 4);\nlet v2 = createVector(1, 2);\nlet v3 = v1.add(v2);\n\nprint(v3.toString());  // \"(4, 6)\"\n```\n\n### Exemplo: Banco de Dados Simples\n\n```hemlock\nfn createDatabase() {\n    let records = [];\n    let next_id = 1;\n\n    return {\n        insert: fn(data) {\n            let record = { id: next_id, data: data };\n            records.push(record);\n            next_id = next_id + 1;\n            return record.id;\n        },\n\n        find: fn(id) {\n            let i = 0;\n            while (i < records.length) {\n                if (records[i].id == id) {\n                    return records[i];\n                }\n                i = i + 1;\n            }\n            return null;\n        },\n\n        count: fn() {\n            return records.length;\n        }\n    };\n}\n\nlet db = createDatabase();\nlet id = db.insert({ name: \"Alice\", age: 30 });\nlet record = db.find(id);\nprint(record.data.name);  // \"Alice\"\n```\n\n### Exemplo: Emissor de Eventos\n\n```hemlock\nfn createEventEmitter() {\n    let listeners = {};\n\n    return {\n        on: fn(event, handler) {\n            if (listeners[event] == null) {\n                listeners[event] = [];\n            }\n            listeners[event].push(handler);\n        },\n\n        emit: fn(event, data) {\n            if (listeners[event] != null) {\n                let i = 0;\n                while (i < listeners[event].length) {\n                    listeners[event][i](data);\n                    i = i + 1;\n                }\n            }\n        }\n    };\n}\n\nlet emitter = createEventEmitter();\n\nemitter.on(\"message\", fn(data) {\n    print(\"Received: \" + data);\n});\n\nemitter.emit(\"message\", \"Hello!\");\n```\n\n## Limitaes\n\nLimitaes atuais:\n\n- **Sem cpia profunda** - Deve copiar objetos aninhados manualmente (spread  cpia rasa)\n- **Sem passagem por valor** - Objetos so sempre passados por referncia\n- **Sem propriedades computadas** - Sintaxe `{[key]: value}` no suportada\n- **`self`  somente leitura** - No pode reatribuir `self` em mtodos\n- **Sem remoo de propriedade** - Campos no podem ser removidos depois de adicionados\n\n**Nota:** Objetos usam contagem de referncia, sendo liberados automaticamente ao sair do escopo. Veja [Gerenciamento de Memria](memory.md#internal-reference-counting) para detalhes.\n\n## Tpicos Relacionados\n\n- [Funes](#language-guide-functions) - Mtodos so funes armazenadas em objetos\n- [Arrays](#language-guide-arrays) - Arrays tambm so tipo objeto\n- [Tipos](#language-guide-types) - Duck typing e definies de tipo\n- [Tratamento de Erros](#language-guide-error-handling) - Lanando objetos de erro\n\n## Veja Tambm\n\n- **Duck typing**: Veja seo \"Objects\" em CLAUDE.md para detalhes de duck typing\n- **JSON**: Veja CLAUDE.md para detalhes de serializao JSON\n- **Memria**: Veja [Memria](#language-guide-memory) para alocao de objetos\n"}, "Guia da Linguagem -> Runas": {"id": "language-guide-runes", "content": "# Caracteres Rune\n\nRune representa **pontos de codigo Unicode** (U+0000 a U+10FFFF), como um tipo distinto para operacoes de caracteres em Hemlock. Diferente de bytes (u8), runes sao caracteres Unicode completos que podem representar caracteres de qualquer idioma ou emojis.\n\n## Visao Geral\n\n```hemlock\nlet ch = 'A';           // Literal rune\nlet emoji = '';       // Caractere multi-byte como um unico rune\nprint(ch);              // 'A'\nprint(emoji);           // U+1F680\n\nlet s = \"Hello \" + '!'; // Concatenacao string + rune\nlet r = '>' + \" msg\";   // Concatenacao rune + string\n```\n\n## O que e um Rune?\n\nRune e um **valor de 32 bits** que representa um ponto de codigo Unicode:\n\n- **Intervalo:** 0 a 0x10FFFF (1.114.111 pontos de codigo validos)\n- **Nao e um tipo numerico** - Usado para representacao de caracteres\n- **Diferente de u8/char** - Rune e Unicode completo, u8 e apenas um byte\n- **Indexacao de string retorna** - `str[0]` retorna rune, nao byte\n\n**Por que usar rune?**\n- Strings Hemlock sao codificadas em UTF-8\n- Um unico caractere Unicode pode ter 1-4 bytes em UTF-8\n- Rune permite trabalhar com caracteres completos, nao bytes parciais\n\n## Literais Rune\n\n### Sintaxe Basica\n\nAspas simples denotam literais rune:\n\n```hemlock\nlet a = 'A';            // Caractere ASCII\nlet b = '0';            // Caractere digito\nlet c = '!';            // Pontuacao\nlet d = ' ';            // Espaco\n```\n\n### Caracteres UTF-8 Multi-byte\n\nRune pode representar qualquer caractere Unicode:\n\n```hemlock\n// Emojis\nlet foguete = '';     // Emoji (U+1F680)\nlet coracao = '';      // Coracao (U+2764)\nlet sorriso = '';     // Rosto sorridente (U+1F600)\n\n// Caracteres CJK\nlet chines = '';      // Chines (U+4E2D)\nlet japones = '';     // Hiragana (U+3042)\nlet coreano = '';     // Hangul (U+D55C)\n\n// Simbolos\nlet check = '';        // Marca de verificacao (U+2713)\nlet seta = '';         // Seta direita (U+2192)\n```\n\n### Sequencias de Escape\n\nSequencias de escape comuns para caracteres especiais:\n\n```hemlock\nlet newline = '\\n';     // Quebra de linha (U+000A)\nlet tab = '\\t';         // Tabulacao (U+0009)\nlet backslash = '\\\\';   // Barra invertida (U+005C)\nlet quote = '\\'';       // Aspas simples (U+0027)\nlet dquote = '\"';       // Aspas duplas (U+0022)\nlet null_char = '\\0';   // Caractere nulo (U+0000)\nlet cr = '\\r';          // Retorno de carro (U+000D)\n```\n\n**Sequencias de escape disponiveis:**\n- `\\n` - Quebra de linha\n- `\\t` - Tabulacao horizontal\n- `\\r` - Retorno de carro\n- `\\0` - Caractere nulo\n- `\\\\` - Barra invertida\n- `\\'` - Aspas simples\n- `\\\"` - Aspas duplas\n\n### Escapes Unicode\n\nUse sintaxe `\\u{XXXXXX}` para pontos de codigo Unicode (ate 6 digitos hexadecimais):\n\n```hemlock\nlet foguete = '\\u{1F680}';   //  emoji via escape Unicode\nlet coracao = '\\u{2764}';    //  coracao\nlet ascii = '\\u{41}';        // 'A' via escape\nlet max = '\\u{10FFFF}';      // Ponto de codigo Unicode maximo\n\n// Zeros a esquerda sao opcionais\nlet a = '\\u{41}';            // Mesmo que '\\u{0041}'\nlet b = '\\u{0041}';\n```\n\n**Regras:**\n- Intervalo: `\\u{0}` a `\\u{10FFFF}`\n- Digitos hexadecimais: 1 a 6 digitos\n- Case-insensitive: `\\u{1F680}` ou `\\u{1f680}`\n- Valores fora do intervalo Unicode valido causam erro\n\n## Concatenacao String + Rune\n\nRunes podem ser concatenados com strings:\n\n```hemlock\n// String + rune\nlet saudacao = \"Ola\" + '!';         // \"Ola!\"\nlet decorado = \"Texto\" + '';       // \"Texto\"\n\n// Rune + string\nlet prefixo = '>' + \" Mensagem\";    // \"> Mensagem\"\nlet marcador = '' + \" Item\";       // \" Item\"\n\n// Concatenacao multipla\nlet msg = \"Oi \" + '' + \" Mundo \" + '';  // \"Oi  Mundo \"\n\n// Encadeamento de metodos funciona\nlet resultado = ('>' + \" Importante\").to_upper();  // \"> IMPORTANTE\"\n```\n\n**Como funciona:**\n- Rune e automaticamente codificado em UTF-8\n- Convertido para string durante concatenacao\n- Operador de concatenacao de string trata isso transparentemente\n\n## Conversao de Tipos\n\nRunes podem ser convertidos de/para outros tipos.\n\n### Inteiro <-> Rune\n\nConverte entre inteiros e runes para trabalhar com valores de pontos de codigo:\n\n```hemlock\n// Inteiro para rune (valor do ponto de codigo)\nlet codigo: rune = 65;            // 'A' (ASCII 65)\nlet emoji_code: rune = 128640;    // U+1F680 ()\n\n// Rune para inteiro (obter valor do ponto de codigo)\nlet r = 'Z';\nlet valor: i32 = r;               // 90 (valor ASCII)\n\nlet foguete = '';\nlet codigo: i32 = foguete;        // 128640 (U+1F680)\n```\n\n**Verificacao de intervalo:**\n- Inteiro para rune: deve estar no intervalo [0, 0x10FFFF]\n- Valores fora do intervalo causam erro de runtime\n- Rune para inteiro: sempre sucede (retorna ponto de codigo)\n\n### Rune -> String\n\nRunes podem ser explicitamente convertidos para strings:\n\n```hemlock\n// Conversao explicita\nlet ch: string = 'H';           // \"H\"\nlet emoji: string = '';       // \"\"\n\n// Conversao automatica em concatenacao\nlet s = \"\" + 'A';               // \"A\"\nlet s2 = \"x\" + 'y' + \"z\";       // \"xyz\"\n```\n\n### u8 (Byte) -> Rune\n\nQualquer valor u8 (0-255) pode ser convertido para rune:\n\n```hemlock\n// Intervalo ASCII (0-127)\nlet byte: u8 = 65;\nlet valor_rune: rune = byte;    // 'A'\n\n// ASCII estendido / Latin-1 (128-255)\nlet estendido: u8 = 200;\nlet r: rune = estendido;        // U+00C8 (E)\n\n// Nota: 0-127 e ASCII, 128-255 e Latin-1\n```\n\n### Conversoes Encadeadas\n\nConversoes de tipo podem ser encadeadas:\n\n```hemlock\n// i32 -> rune -> string\nlet codigo: i32 = 128512;       // Ponto de codigo sorriso\nlet r: rune = codigo;           // \nlet s: string = r;              // \"\"\n\n// Em uma expressao\nlet emoji: string = 128640;     // Implicito i32 -> rune -> string ()\n```\n\n## Operacoes com Runes\n\n### Impressao\n\nRunes sao exibidos de forma diferente dependendo do ponto de codigo:\n\n```hemlock\nlet ascii = 'A';\nprint(ascii);                   // 'A' (com aspas, ASCII imprimivel)\n\nlet emoji = '';\nprint(emoji);                   // U+1F680 (notacao Unicode para nao-ASCII)\n\nlet tab = '\\t';\nprint(tab);                     // U+0009 (hex para nao-imprimiveis)\n\nlet espaco = ' ';\nprint(espaco);                  // ' ' (imprimivel)\n```\n\n**Formato de impressao:**\n- ASCII imprimivel (32-126): Caractere com aspas `'A'`\n- Nao-imprimivel ou Unicode: Notacao hexadecimal `U+XXXX`\n\n### Verificacao de Tipo\n\nUse `typeof()` para verificar se um valor e rune:\n\n```hemlock\nlet r = '';\nprint(typeof(r));               // \"rune\"\n\nlet s = \"texto\";\nlet ch = s[0];\nprint(typeof(ch));              // \"rune\" (indexacao retorna rune)\n\nlet num = 65;\nprint(typeof(num));             // \"i32\"\n```\n\n### Comparacao\n\nRunes podem ser comparados por igualdade:\n\n```hemlock\nlet a = 'A';\nlet b = 'B';\nprint(a == a);                  // true\nprint(a == b);                  // false\n\n// Case-sensitive\nlet maiuscula = 'A';\nlet minuscula = 'a';\nprint(maiuscula == minuscula);  // false\n\n// Runes podem ser comparados com inteiros (valor do ponto de codigo)\nprint(a == 65);                 // true (conversao implicita)\nprint('' == 128640);          // true\n```\n\n**Operadores de comparacao:**\n- `==` - Igual a\n- `!=` - Diferente de\n- `<`, `>`, `<=`, `>=` - Ordem de ponto de codigo\n\n```hemlock\nprint('A' < 'B');               // true (65 < 66)\nprint('a' > 'Z');               // true (97 > 90)\n```\n\n## Trabalhando com Indexacao de Strings\n\nIndexacao de strings retorna runes, nao bytes:\n\n```hemlock\nlet s = \"Hello\";\nlet h = s[0];                   // 'H' (rune)\nlet foguete = s[5];             // '' (rune)\n\nprint(typeof(h));               // \"rune\"\nprint(typeof(foguete));         // \"rune\"\n\n// Pode converter para string se necessario\nlet h_str: string = h;          // \"H\"\nlet foguete_str: string = foguete; // \"\"\n```\n\n**Importante:** Indexacao de strings usa posicao de ponto de codigo, nao offset de byte:\n\n```hemlock\nlet texto = \"Oi!\";\n// Posicoes de ponto de codigo: 0='O', 1='i', 2='', 3='!'\n// Posicoes de byte: 0='O', 1='i', 2-5='', 6='!'\n\nlet r = texto[2];               // '' (ponto de codigo 2)\nprint(typeof(r));               // \"rune\"\n```\n\n## Exemplos\n\n### Exemplo: Classificacao de Caracteres\n\n```hemlock\nfn is_digit(r: rune): bool {\n    return r >= '0' && r <= '9';\n}\n\nfn is_upper(r: rune): bool {\n    return r >= 'A' && r <= 'Z';\n}\n\nfn is_lower(r: rune): bool {\n    return r >= 'a' && r <= 'z';\n}\n\nprint(is_digit('5'));           // true\nprint(is_upper('A'));           // true\nprint(is_lower('z'));           // true\n```\n\n### Exemplo: Conversao de Caso\n\n```hemlock\nfn to_upper_rune(r: rune): rune {\n    if (r >= 'a' && r <= 'z') {\n        // Converte para maiuscula (subtrai 32)\n        let codigo: i32 = r;\n        codigo = codigo - 32;\n        return codigo;\n    }\n    return r;\n}\n\nfn to_lower_rune(r: rune): rune {\n    if (r >= 'A' && r <= 'Z') {\n        // Converte para minuscula (adiciona 32)\n        let codigo: i32 = r;\n        codigo = codigo + 32;\n        return codigo;\n    }\n    return r;\n}\n\nprint(to_upper_rune('a'));      // 'A'\nprint(to_lower_rune('Z'));      // 'z'\n```\n\n### Exemplo: Iteracao de Caracteres\n\n```hemlock\nfn print_chars(s: string) {\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        print(\"Posicao \" + typeof(i) + \": \" + typeof(ch));\n        i = i + 1;\n    }\n}\n\nprint_chars(\"Oi\");\n// Posicao 0: 'O'\n// Posicao 1: 'i'\n// Posicao 2: U+1F680\n```\n\n### Exemplo: Construindo Strings a partir de Runes\n\n```hemlock\nfn repeat_char(ch: rune, count: i32): string {\n    let resultado = \"\";\n    let i = 0;\n    while (i < count) {\n        resultado = resultado + ch;\n        i = i + 1;\n    }\n    return resultado;\n}\n\nlet linha = repeat_char('=', 40);   // \"========================================\"\nlet estrelas = repeat_char('', 5); // \"\"\n```\n\n## Padroes Comuns\n\n### Padrao: Filtragem de Caracteres\n\n```hemlock\nfn filter_digits(s: string): string {\n    let resultado = \"\";\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        if (ch >= '0' && ch <= '9') {\n            resultado = resultado + ch;\n        }\n        i = i + 1;\n    }\n    return resultado;\n}\n\nlet texto = \"abc123def456\";\nlet digitos = filter_digits(texto);  // \"123456\"\n```\n\n### Padrao: Contagem de Caracteres\n\n```hemlock\nfn count_char(s: string, alvo: rune): i32 {\n    let count = 0;\n    let i = 0;\n    while (i < s.length) {\n        if (s[i] == alvo) {\n            count = count + 1;\n        }\n        i = i + 1;\n    }\n    return count;\n}\n\nlet texto = \"hello world\";\nlet count_l = count_char(texto, 'l');  // 3\nlet count_o = count_char(texto, 'o');  // 2\n```\n\n## Melhores Praticas\n\n1. **Use rune para operacoes de caracteres** - Nao tente processar texto com bytes\n2. **Indexacao de string retorna rune** - Lembre que `str[i]` retorna um rune\n3. **Comparacoes conscientes de Unicode** - Runes tratam qualquer caractere Unicode\n4. **Converta quando necessario** - Runes podem ser facilmente convertidos para strings e inteiros\n5. **Teste com emojis** - Sempre teste operacoes de caracteres com caracteres multi-byte\n\n## Armadilhas Comuns\n\n### Armadilha: Confundir Rune com Byte\n\n```hemlock\n// Nao faca: tratar rune como byte\nlet r: rune = '';\nlet b: u8 = r;              // Erro: ponto de codigo rune 128640 nao cabe em u8\n\n// Faca: use conversao apropriada\nlet r: rune = '';\nlet codigo: i32 = r;        // OK: 128640\n```\n\n### Armadilha: Indexacao de Bytes em String\n\n```hemlock\n// Nao faca: assumir indexacao por byte\nlet s = \"\";\nlet byte = s.byte_at(0);    // 240 (primeiro byte UTF-8, nao caractere completo)\n\n// Faca: use indexacao por ponto de codigo\nlet s = \"\";\nlet rune = s[0];            // '' (caractere completo)\nlet rune2 = s.char_at(0);   // '' (metodo explicito)\n```\n\n## Topicos Relacionados\n\n- [Strings](#language-guide-strings) - Operacoes de string e tratamento UTF-8\n- [Tipos](#language-guide-types) - Sistema de tipos e conversoes\n- [Fluxo de Controle](#language-guide-control-flow) - Usando runes em comparacoes\n\n## Veja Tambem\n\n- **Padrao Unicode**: Pontos de codigo Unicode sao definidos pelo Consorcio Unicode\n- **Codificacao UTF-8**: Veja [Strings](#language-guide-strings) para detalhes de UTF-8\n- **Conversao de Tipos**: Veja [Tipos](#language-guide-types) para regras de conversao\n"}, "Guia da Linguagem -> Sintaxe": {"id": "language-guide-syntax", "content": "# Viso Geral da Sintaxe\n\nEste documento apresenta as regras bsicas de sintaxe e estrutura dos programas Hemlock.\n\n## Regras Bsicas de Sintaxe\n\n### Ponto e Vrgula  Obrigatrio\n\nDiferente do JavaScript ou Python, o ponto e vrgula **deve** ser usado no final das instrues:\n\n```hemlock\nlet x = 42;\nlet y = 10;\nprint(x + y);\n```\n\n**O cdigo a seguir causar erro:**\n```hemlock\nlet x = 42  // Erro: falta ponto e vrgula\nlet y = 10  // Erro: falta ponto e vrgula\n```\n\n### Chaves so Obrigatrias\n\nTodos os blocos de fluxo de controle devem usar chaves, mesmo para instrues nicas:\n\n```hemlock\n// Correto\nif (x > 0) {\n    print(\"positive\");\n}\n\n// Erro: faltam chaves\nif (x > 0)\n    print(\"positive\");\n```\n\n### Comentrios\n\n```hemlock\n// Este  um comentrio de linha nica\n\n/*\n   Este  um\n   comentrio de mltiplas linhas\n*/\n\nlet x = 42;  // Comentrio inline\n```\n\n## Variveis\n\n### Declarao\n\nUse `let` para declarar variveis:\n\n```hemlock\nlet count = 0;\nlet name = \"Alice\";\nlet pi = 3.14159;\n```\n\n### Anotaes de Tipo (Opcionais)\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet flag: bool = true;\nlet text: string = \"hello\";\n```\n\n### Constantes\n\nUse `const` para declarar valores imutveis:\n\n```hemlock\nconst MAX_SIZE: i32 = 1000;\nconst PI: f64 = 3.14159;\n```\n\nTentar reatribuir uma constante causar um erro em tempo de execuo: \"Cannot assign to const variable\".\n\n## Expresses\n\n### Operadores Aritmticos\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13 - adio\nprint(a - b);   // 7  - subtrao\nprint(a * b);   // 30 - multiplicao\nprint(a / b);   // 3  - diviso (inteira)\n```\n\n### Operadores de Comparao\n\n```hemlock\nprint(a == b);  // false - igual\nprint(a != b);  // true  - diferente\nprint(a > b);   // true  - maior que\nprint(a < b);   // false - menor que\nprint(a >= b);  // true  - maior ou igual\nprint(a <= b);  // false - menor ou igual\n```\n\n### Operadores Lgicos\n\n```hemlock\nlet x = true;\nlet y = false;\n\nprint(x && y);  // false - e\nprint(x || y);  // true  - ou\nprint(!x);      // false - no\n```\n\n### Operadores Bit a Bit\n\n```hemlock\nlet a = 12;  // 1100\nlet b = 10;  // 1010\n\nprint(a & b);   // 8  - e bit a bit\nprint(a | b);   // 14 - ou bit a bit\nprint(a ^ b);   // 6  - ou exclusivo bit a bit\nprint(a << 2);  // 48 - deslocamento  esquerda\nprint(a >> 1);  // 6  - deslocamento  direita\nprint(~a);      // -13 - inverso bit a bit\n```\n\n### Precedncia de Operadores\n\nDa maior para a menor:\n\n1. `()` - agrupamento\n2. `!`, `~`, `-` (unrio) - operadores unrios\n3. `*`, `/` - multiplicao, diviso\n4. `+`, `-` - adio, subtrao\n5. `<<`, `>>` - deslocamento de bits\n6. `<`, `<=`, `>`, `>=` - comparao\n7. `==`, `!=` - igualdade\n8. `&` - e bit a bit\n9. `^` - ou exclusivo bit a bit\n10. `|` - ou bit a bit\n11. `&&` - e lgico\n12. `||` - ou lgico\n\n**Exemplo:**\n```hemlock\nlet x = 2 + 3 * 4;      // 14 (no 20)\nlet y = (2 + 3) * 4;    // 20\nlet z = 5 << 2 + 1;     // 40 (5 << 3)\n```\n\n## Fluxo de Controle\n\n### Instruo If\n\n```hemlock\nif (condition) {\n    // corpo\n}\n\nif (condition) {\n    // bloco then\n} else {\n    // bloco else\n}\n\nif (condition1) {\n    // bloco 1\n} else if (condition2) {\n    // bloco 2\n} else {\n    // bloco padro\n}\n```\n\n### Lao While\n\n```hemlock\nwhile (condition) {\n    // corpo\n}\n```\n\n**Exemplo:**\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n### Lao For\n\n**For estilo C:**\n```hemlock\nfor (initializer; condition; increment) {\n    // corpo\n}\n```\n\n**Exemplo:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**For-in (arrays):**\n```hemlock\nfor (let item in array) {\n    // corpo\n}\n```\n\n**Exemplo:**\n```hemlock\nlet items = [10, 20, 30];\nfor (let x in items) {\n    print(x);\n}\n```\n\n### Instruo Switch\n\n```hemlock\nswitch (expression) {\n    case value1:\n        // corpo\n        break;\n    case value2:\n        // corpo\n        break;\n    default:\n        // corpo padro\n        break;\n}\n```\n\n**Exemplo:**\n```hemlock\nlet day = 3;\nswitch (day) {\n    case 1:\n        print(\"Monday\");\n        break;\n    case 2:\n        print(\"Tuesday\");\n        break;\n    case 3:\n        print(\"Wednesday\");\n        break;\n    default:\n        print(\"Other\");\n        break;\n}\n```\n\n### Break e Continue\n\n```hemlock\n// Break: sai do lao\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n}\n\n// Continue: pula para a prxima iterao\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;\n    }\n    print(i);\n}\n```\n\n## Funes\n\n### Funes Nomeadas\n\n```hemlock\nfn function_name(param1: type1, param2: type2): return_type {\n    // corpo\n    return value;\n}\n```\n\n**Exemplo:**\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Funes Annimas\n\n```hemlock\nlet func = fn(params) {\n    // corpo\n};\n```\n\n**Exemplo:**\n```hemlock\nlet multiply = fn(x, y) {\n    return x * y;\n};\n```\n\n### Anotaes de Tipo (Opcionais)\n\n```hemlock\n// Sem anotaes (inferncia de tipo)\nfn greet(name) {\n    return \"Hello, \" + name;\n}\n\n// Com anotaes (verificao em tempo de execuo)\nfn divide(a: i32, b: i32): f64 {\n    return a / b;\n}\n```\n\n## Objetos\n\n### Literais de Objeto\n\n```hemlock\nlet obj = {\n    field1: value1,\n    field2: value2,\n};\n```\n\n**Exemplo:**\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    active: true,\n};\n```\n\n### Mtodos\n\n```hemlock\nlet obj = {\n    method: fn() {\n        self.field = value;\n    },\n};\n```\n\n**Exemplo:**\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n};\n```\n\n### Definies de Tipo\n\n```hemlock\ndefine TypeName {\n    field1: type1,\n    field2: type2,\n    optional_field?: default_value,\n}\n```\n\n**Exemplo:**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,\n}\n```\n\n## Arrays\n\n### Literais de Array\n\n```hemlock\nlet arr = [element1, element2, element3];\n```\n\n**Exemplo:**\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];\nlet empty = [];\n```\n\n### Indexao de Array\n\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);   // 10\narr[1] = 99;     // modificar elemento\n```\n\n## Tratamento de Erros\n\n### Try/Catch\n\n```hemlock\ntry {\n    // cdigo que pode falhar\n} catch (e) {\n    // tratar erro\n}\n```\n\n### Try/Finally\n\n```hemlock\ntry {\n    // cdigo que pode falhar\n} finally {\n    // sempre executa\n}\n```\n\n### Try/Catch/Finally\n\n```hemlock\ntry {\n    // cdigo que pode falhar\n} catch (e) {\n    // tratar erro\n} finally {\n    // limpeza\n}\n```\n\n### Throw\n\n```hemlock\nthrow expression;\n```\n\n**Exemplo:**\n```hemlock\nif (x < 0) {\n    throw \"x must be positive\";\n}\n```\n\n### Panic\n\n```hemlock\npanic(message);\n```\n\n**Exemplo:**\n```hemlock\npanic(\"unrecoverable error\");\n```\n\n## Mdulos (Experimental)\n\n### Instrues de Exportao\n\n```hemlock\nexport fn function_name() { }\nexport const CONSTANT = value;\nexport let variable = value;\nexport { name1, name2 };\n```\n\n### Instrues de Importao\n\n```hemlock\nimport { name1, name2 } from \"./module.hml\";\nimport * as namespace from \"./module.hml\";\nimport { name as alias } from \"./module.hml\";\n```\n\n## Assncrono (Experimental)\n\n### Funes Assncronas\n\n```hemlock\nasync fn function_name(params): return_type {\n    // corpo\n}\n```\n\n### Spawn/Join\n\n```hemlock\nlet task = spawn(async_function, arg1, arg2);\nlet result = join(task);\n```\n\n### Canais\n\n```hemlock\nlet ch = channel(capacity);\nch.send(value);\nlet value = ch.recv();\nch.close();\n```\n\n## FFI (Interface de Funo Estrangeira)\n\n### Importar Bibliotecas Compartilhadas\n\n```hemlock\nimport \"library_name.so\";\n```\n\n### Declarar Funes Externas\n\n```hemlock\nextern fn function_name(param: type): return_type;\n```\n\n**Exemplo:**\n```hemlock\nimport \"libc.so.6\";\nextern fn strlen(s: string): i32;\n```\n\n## Literais\n\n### Literais Inteiros\n\n```hemlock\nlet decimal = 42;\nlet negative = -100;\nlet large = 5000000000;  // i64 automtico\n\n// Hexadecimal (prefixo 0x)\nlet hex = 0xDEADBEEF;\nlet hex2 = 0xFF;\n\n// Binrio (prefixo 0b)\nlet bin = 0b1010;\nlet bin2 = 0b11110000;\n\n// Octal (prefixo 0o)\nlet oct = 0o777;\nlet oct2 = 0O123;\n\n// Separadores numricos para legibilidade\nlet million = 1_000_000;\nlet hex_sep = 0xFF_FF_FF;\nlet bin_sep = 0b1111_0000_1010_0101;\nlet oct_sep = 0o77_77;\n```\n\n### Literais de Ponto Flutuante\n\n```hemlock\nlet f = 3.14;\nlet e = 2.71828;\nlet sci = 1.5e-10;       // notao cientfica\nlet sci2 = 2.5E+3;       // E maisculo tambm funciona\nlet no_lead = .5;        // sem zero inicial (0.5)\nlet sep = 3.14_159_265;  // separadores numricos\n```\n\n### Literais de String\n\n```hemlock\nlet s = \"hello\";\nlet escaped = \"line1\\nline2\\ttabbed\";\nlet quote = \"She said \\\"hello\\\"\";\n\n// Sequncias de escape hexadecimal\nlet hex_esc = \"\\x48\\x65\\x6c\\x6c\\x6f\";  // \"Hello\"\n\n// Sequncias de escape Unicode\nlet emoji = \"\\u{1F600}\";               // \nlet heart = \"\\u{2764}\";                // \nlet mixed = \"Hello \\u{1F30D}!\";        // Hello !\n```\n\n**Sequncias de Escape:**\n- `\\n` - nova linha\n- `\\t` - tabulao\n- `\\r` - retorno de carro\n- `\\\\` - barra invertida\n- `\\\"` - aspas duplas\n- `\\'` - aspas simples\n- `\\0` - caractere nulo\n- `\\xNN` - escape hexadecimal (2 dgitos)\n- `\\u{XXXX}` - escape Unicode (1-6 dgitos)\n\n### Literais Rune\n\n```hemlock\nlet ch = 'A';\nlet emoji = '';\nlet escaped = '\\n';\nlet unicode = '\\u{1F680}';\nlet hex_rune = '\\x41';      // 'A'\n```\n\n### Literais Booleanos\n\n```hemlock\nlet t = true;\nlet f = false;\n```\n\n### Literal Null\n\n```hemlock\nlet nothing = null;\n```\n\n## Regras de Escopo\n\n### Escopo de Bloco\n\nO escopo de uma varivel  o bloco mais prximo que a contm:\n\n```hemlock\nlet x = 1;  // escopo externo\n\nif (true) {\n    let x = 2;  // escopo interno (oculta o externo)\n    print(x);   // 2\n}\n\nprint(x);  // 1\n```\n\n### Escopo de Funo\n\nFunes criam seu prprio escopo:\n\n```hemlock\nlet global = \"global\";\n\nfn foo() {\n    let local = \"local\";\n    print(global);  // pode ler escopo externo\n}\n\nfoo();\n// print(local);  // Erro: 'local' no est definido aqui\n```\n\n### Escopo de Closure\n\nClosures capturam variveis do escopo envolvente:\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // captura 'count'\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\n```\n\n## Espaos em Branco e Formatao\n\n### Indentao\n\nHemlock no impe indentao especfica, mas 4 espaos so recomendados:\n\n```hemlock\nfn example() {\n    if (true) {\n        print(\"indented\");\n    }\n}\n```\n\n### Quebras de Linha\n\nInstrues podem abranger mltiplas linhas:\n\n```hemlock\nlet result =\n    very_long_function_name(\n        arg1,\n        arg2,\n        arg3\n    );\n```\n\n## Instruo Loop\n\nA palavra-chave `loop` fornece sintaxe mais clara para laos infinitos:\n\n```hemlock\nloop {\n    // ... executar trabalho\n    if (done) {\n        break;\n    }\n}\n```\n\nIsso  equivalente a `while (true)`, mas a inteno  mais clara.\n\n## Palavras-chave Reservadas\n\nAs seguintes palavras-chave so reservadas em Hemlock:\n\n```\nlet, const, fn, if, else, while, for, in, loop, break, continue,\nreturn, true, false, null, typeof, import, export, from,\ntry, catch, finally, throw, panic, async, await, spawn, join,\ndetach, channel, define, switch, case, default, extern, self,\ntype, defer, enum, ref, buffer, Self\n```\n\n## Prximos Passos\n\n- [Sistema de Tipos](#language-guide-types) - Aprenda sobre o sistema de tipos do Hemlock\n- [Fluxo de Controle](#language-guide-control-flow) - Aprofunde-se nas estruturas de controle\n- [Funes](#language-guide-functions) - Domine funes e closures\n- [Gerenciamento de Memria](#language-guide-memory) - Entenda ponteiros e buffers\n"}, "Guia da Linguagem -> Strings": {"id": "language-guide-strings", "content": "# Strings\n\nStrings em Hemlock so **sequncias mutveis com prioridade UTF-8**, com suporte completo a Unicode e mtodos ricos para processamento de texto. Diferente de muitas linguagens, strings em Hemlock so mutveis e suportam nativamente operaes com pontos de cdigo Unicode.\n\n## Viso Geral\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Modifica usando rune (agora  \"Hello\")\nprint(s.length);        // 5 (contagem de codepoints)\nlet c = s[0];           // Retorna rune (ponto de cdigo Unicode)\nlet msg = s + \" world\"; // Concatenao\nlet emoji = \"\";\nprint(emoji.length);    // 1 (um codepoint)\nprint(emoji.byte_length); // 4 (quatro bytes UTF-8)\n```\n\n## Propriedades\n\nStrings em Hemlock tm as seguintes caractersticas principais:\n\n- **Codificao UTF-8** - Suporte completo a Unicode (U+0000 a U+10FFFF)\n- **Mutveis** - Diferente de Python, JavaScript e Java\n- **Indexao baseada em codepoint** - Retorna `rune` (ponto de cdigo Unicode), no bytes\n- **Alocao no heap** - Com rastreamento interno de capacidade\n- **Duas propriedades de comprimento**:\n  - `.length` - Contagem de codepoints (caracteres)\n  - `.byte_length` - Contagem de bytes (tamanho da codificao UTF-8)\n\n## Comportamento UTF-8\n\nTodas as operaes de string usam **codepoints** (caracteres), no bytes:\n\n```hemlock\nlet text = \"HelloWorld\";\nprint(text.length);        // 11 (codepoints)\nprint(text.byte_length);   // 15 (bytes, emoji so 4 bytes)\n\n// Indexao usa codepoints\nlet h = text[0];           // 'H' (rune)\nlet rocket = text[5];      // '' (rune)\n```\n\n**Caracteres multibyte contam como um:**\n```hemlock\n\"Hello\".length;      // 5\n\"\".length;         // 1 (um emoji)\n\"\".length;       // 2 (dois caracteres chineses)\n\"caf\".length;       // 4 (  um codepoint)\n```\n\n## Literais de String\n\n```hemlock\n// Strings bsicas\nlet s1 = \"hello\";\nlet s2 = \"world\";\n\n// Com sequncias de escape\nlet s3 = \"Line 1\\nLine 2\\ttabbed\";\nlet s4 = \"Quote: \\\"Hello\\\"\";\nlet s5 = \"Backslash: \\\\\";\n\n// Caracteres Unicode\nlet s6 = \" Emoji\";\nlet s7 = \"\";\n```\n\n## Template Strings (Interpolao de Strings)\n\nUse crases para criar template strings com expresses embutidas:\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\n\n// Interpolao bsica\nlet greeting = `Hello, ${name}!`;           // \"Hello, Alice!\"\nlet info = `${name} is ${age} years old`;   // \"Alice is 30 years old\"\n\n// Expresses na interpolao\nlet x = 5;\nlet y = 10;\nlet sum = `${x} + ${y} = ${x + y}`;         // \"5 + 10 = 15\"\n\n// Chamadas de mtodo\nlet upper = `Name: ${name.to_upper()}`;     // \"Name: ALICE\"\n\n// Objetos aninhados\nlet person = { name: \"Bob\", city: \"NYC\" };\nlet desc = `${person.name} lives in ${person.city}`;  // \"Bob lives in NYC\"\n\n// Mltiplas linhas (preserva quebras)\nlet multi = `Line 1\nLine 2\nLine 3`;\n```\n\n**Caractersticas de template strings:**\n- Expresses dentro de `${...}` so avaliadas e convertidas para string\n- Pode usar qualquer expresso vlida (variveis, chamadas de funo, aritmtica)\n- Strings com crases suportam as mesmas sequncias de escape que strings normais\n- Usa-se para construir strings dinmicas sem concatenao\n\n### Escape em Template Strings\n\nPara incluir `${` literal em uma template string, escape o cifro:\n\n```hemlock\nlet price = 100;\nlet text = `Price: \\${price} or ${price}`;\n// \"Price: ${price} or 100\"\n\n// Crase literal\nlet code = `Use \\` for template strings`;\n// \"Use ` for template strings\"\n```\n\n### Expresses Complexas\n\nTemplate strings podem conter qualquer expresso vlida:\n\n```hemlock\n// Tipo ternrio\nlet age = 25;\nlet status = `Status: ${age >= 18 ? \"adult\" : \"minor\"}`;\n\n// Acesso a array\nlet items = [\"apple\", \"banana\", \"cherry\"];\nlet first = `First item: ${items[0]}`;\n\n// Chamada de funo com parmetros\nfn format_price(p) { return \"$\" + p; }\nlet msg = `Total: ${format_price(99.99)}`;  // \"Total: $99.99\"\n\n// Mtodos encadeados\nlet name = \"alice\";\nlet formatted = `Hello, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;\n// \"Hello, Alice!\"\n```\n\n### Template Strings vs Concatenao\n\nTemplate strings geralmente so mais claras que concatenao:\n\n```hemlock\n// Concatenao (mais difcil de ler)\nlet msg1 = \"Hello, \" + name + \"! You have \" + count + \" messages.\";\n\n// Template string (mais fcil de ler)\nlet msg2 = `Hello, ${name}! You have ${count} messages.`;\n```\n\n## Indexao e Modificao\n\n### Lendo Caracteres\n\nIndexao retorna `rune` (ponto de cdigo Unicode):\n\n```hemlock\nlet s = \"Hello\";\nlet first = s[0];      // 'H' (rune)\nlet last = s[4];       // 'o' (rune)\n\n// Exemplo UTF-8\nlet emoji = \"Hi!\";\nlet rocket = emoji[2];  // '' (rune no ndice de codepoint 2)\n```\n\n### Escrevendo Caracteres\n\nStrings so mutveis - pode modificar caracteres individuais:\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';            // Agora  \"Hello\"\ns[4] = '!';            // Agora  \"Hell!\"\n\n// Exemplo Unicode\nlet msg = \"Go!\";\nmsg[0] = '';         // Agora  \"o!\"\n```\n\n## Concatenao\n\nUse `+` para concatenar strings:\n\n```hemlock\nlet greeting = \"Hello\" + \" \" + \"World\";  // \"Hello World\"\n\n// Com variveis\nlet name = \"Alice\";\nlet msg = \"Hi, \" + name + \"!\";  // \"Hi, Alice!\"\n\n// Com rune (veja documentao de Runas)\nlet s = \"Hello\" + '!';          // \"Hello!\"\n```\n\n## Mtodos de String\n\nHemlock fornece 19 mtodos de string para manipulao abrangente de texto.\n\n### Substrings e Fatiamento\n\n**`substr(start, length)`** - Extrai substring por posio e comprimento:\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\" (de 6, comprimento 5)\nlet first = s.substr(0, 5);     // \"hello\"\n\n// Exemplo UTF-8\nlet text = \"Hi!\";\nlet emoji = text.substr(2, 1);  // \"\" (posio 2, comprimento 1)\n```\n\n**`slice(start, end)`** - Extrai substring por intervalo (end no includo):\n```hemlock\nlet s = \"hello world\";\nlet slice = s.slice(0, 5);      // \"hello\" (ndice 0 a 4)\nlet slice2 = s.slice(6, 11);    // \"world\"\n```\n\n**Diferena:**\n- `substr(start, length)` - Usa parmetro de comprimento\n- `slice(start, end)` - Usa ndice final (no includo)\n\n### Busca e Localizao\n\n**`find(needle)`** - Encontra primeira ocorrncia:\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6 (ndice da primeira ocorrncia)\nlet pos2 = s.find(\"foo\");       // -1 (no encontrado)\nlet pos3 = s.find(\"l\");         // 2 (primeiro 'l')\n```\n\n**`contains(needle)`** - Verifica se string contm substring:\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n### Diviso e Aparagem\n\n**`split(delimiter)`** - Divide em array de strings:\n```hemlock\nlet csv = \"apple,banana,cherry\";\nlet parts = csv.split(\",\");     // [\"apple\", \"banana\", \"cherry\"]\n\nlet words = \"one two three\".split(\" \");  // [\"one\", \"two\", \"three\"]\n\n// Delimitador vazio divide por caractere\nlet chars = \"abc\".split(\"\");    // [\"a\", \"b\", \"c\"]\n```\n\n**`trim()`** - Remove espaos em branco do incio e fim:\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet s2 = \"\\t\\ntext\\n\\t\";\nlet clean2 = s2.trim();         // \"text\"\n```\n\n### Converso de Caso\n\n**`to_upper()`** - Converte para maisculas:\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\n// Preserva caracteres no-ASCII\nlet s2 = \"caf\";\nlet upper2 = s2.to_upper();     // \"CAF\"\n```\n\n**`to_lower()`** - Converte para minsculas:\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n```\n\n### Verificao de Prefixo/Sufixo\n\n**`starts_with(prefix)`** - Verifica se comea com prefixo:\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n**`ends_with(suffix)`** - Verifica se termina com sufixo:\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n### Substituio\n\n**`replace(old, new)`** - Substitui primeira ocorrncia:\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");      // \"hello there\"\n\nlet s3 = \"foo foo foo\";\nlet s4 = s3.replace(\"foo\", \"bar\");         // \"bar foo foo\" (apenas primeiro)\n```\n\n**`replace_all(old, new)`** - Substitui todas as ocorrncias:\n```hemlock\nlet s = \"foo foo foo\";\nlet s2 = s.replace_all(\"foo\", \"bar\");      // \"bar bar bar\"\n\nlet s3 = \"hello world, world!\";\nlet s4 = s3.replace_all(\"world\", \"hemlock\"); // \"hello hemlock, hemlock!\"\n```\n\n### Repetio\n\n**`repeat(count)`** - Repete string n vezes:\n```hemlock\nlet s = \"ha\";\nlet laugh = s.repeat(3);        // \"hahaha\"\n\nlet line = \"=\".repeat(40);      // \"========================================\"\n```\n\n### Acesso a Caracteres e Bytes\n\n**`char_at(index)`** - Obtm ponto de cdigo Unicode no ndice (retorna rune):\n```hemlock\nlet s = \"hello\";\nlet char = s.char_at(0);        // 'h' (rune)\n\n// Exemplo UTF-8\nlet emoji = \"\";\nlet rocket = emoji.char_at(0);  // Retorna rune U+1F680\n```\n\n**`chars()`** - Converte para array de runes (codepoints):\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o'] (array de runes)\n\n// Exemplo UTF-8\nlet text = \"Hi\";\nlet chars2 = text.chars();      // ['H', 'i', '']\n```\n\n**`byte_at(index)`** - Obtm valor de byte no ndice (retorna u8):\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (valor ASCII de 'h')\n\n// Exemplo UTF-8\nlet emoji = \"\";\nlet first_byte = emoji.byte_at(0);  // 240 (primeiro byte UTF-8)\n```\n\n**`bytes()`** - Converte para array de bytes (valores u8):\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111] (array u8)\n\n// Exemplo UTF-8\nlet emoji = \"\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 bytes UTF-8)\n```\n\n**`to_bytes()`** - Converte para buffer para acesso de baixo nvel:\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();         // Retorna buffer contendo bytes UTF-8\nprint(buf.length);              // 5\nfree(buf);                      // Lembre-se de liberar\n```\n\n## Encadeamento de Mtodos\n\nTodos os mtodos de string retornam novas strings, suportando encadeamento:\n\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \")\n    .to_upper();                    // \"FOO | BAR | BAZ\"\n```\n\n## Referncia Completa de Mtodos\n\n| Mtodo | Parmetros | Retorno | Descrio |\n|--------|-----------|---------|-------------|\n| `substr(start, length)` | i32, i32 | string | Extrai substring por posio e comprimento |\n| `slice(start, end)` | i32, i32 | string | Extrai substring por intervalo (end no includo) |\n| `find(needle)` | string | i32 | Encontra primeira ocorrncia (retorna -1 se no encontrado) |\n| `contains(needle)` | string | bool | Verifica se contm substring |\n| `split(delimiter)` | string | array | Divide em array de strings |\n| `trim()` | - | string | Remove espaos em branco do incio e fim |\n| `to_upper()` | - | string | Converte para maisculas |\n| `to_lower()` | - | string | Converte para minsculas |\n| `starts_with(prefix)` | string | bool | Verifica se comea com prefixo |\n| `ends_with(suffix)` | string | bool | Verifica se termina com sufixo |\n| `replace(old, new)` | string, string | string | Substitui primeira ocorrncia |\n| `replace_all(old, new)` | string, string | string | Substitui todas as ocorrncias |\n| `repeat(count)` | i32 | string | Repete string n vezes |\n| `char_at(index)` | i32 | rune | Obtm codepoint no ndice |\n| `byte_at(index)` | i32 | u8 | Obtm valor de byte no ndice |\n| `chars()` | - | array | Converte para array de runes |\n| `bytes()` | - | array | Converte para array de bytes u8 |\n| `to_bytes()` | - | buffer | Converte para buffer (precisa liberar) |\n\n## Exemplos\n\n### Exemplo: Processamento de Texto\n\n```hemlock\nfn process_input(text: string): string {\n    return text\n        .trim()\n        .to_lower()\n        .replace_all(\"  \", \" \");  // Normaliza espaos em branco\n}\n\nlet input = \"  HELLO   WORLD  \";\nlet clean = process_input(input);  // \"hello world\"\n```\n\n### Exemplo: Parser CSV\n\n```hemlock\nfn parse_csv_line(line: string): array {\n    let trimmed = line.trim();\n    let fields = trimmed.split(\",\");\n\n    let result = [];\n    let i = 0;\n    while (i < fields.length) {\n        result.push(fields[i].trim());\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet csv = \"apple, banana , cherry\";\nlet fields = parse_csv_line(csv);  // [\"apple\", \"banana\", \"cherry\"]\n```\n\n### Exemplo: Contador de Palavras\n\n```hemlock\nfn count_words(text: string): i32 {\n    let words = text.trim().split(\" \");\n    return words.length;\n}\n\nlet sentence = \"The quick brown fox\";\nlet count = count_words(sentence);  // 4\n```\n\n### Exemplo: Validao de String\n\n```hemlock\nfn is_valid_email(email: string): bool {\n    if (!email.contains(\"@\")) {\n        return false;\n    }\n\n    if (!email.contains(\".\")) {\n        return false;\n    }\n\n    if (email.starts_with(\"@\") || email.ends_with(\"@\")) {\n        return false;\n    }\n\n    return true;\n}\n\nprint(is_valid_email(\"user@example.com\"));  // true\nprint(is_valid_email(\"invalid\"));            // false\n```\n\n## Gerenciamento de Memria\n\nStrings so alocadas no heap com contagem de referncia interna:\n\n- **Criao**: Aloca no heap com rastreamento de capacidade\n- **Concatenao**: Cria nova string (strings antigas inalteradas)\n- **Mtodos**: A maioria dos mtodos retorna novas strings\n- **Ciclo de vida**: Strings usam contagem de referncia, liberadas automaticamente ao sair do escopo\n\n**Limpeza automtica:**\n```hemlock\nfn create_strings() {\n    let s = \"hello\";\n    let s2 = s + \" world\";  // Nova alocao\n}  // s e s2 liberadas automaticamente quando funo retorna\n```\n\n**Nota:** Variveis de string locais so limpas automaticamente ao sair do escopo. Use `free()` apenas quando precisar de limpeza antecipada (antes do fim do escopo) ou ao lidar com dados de longa durao/globais. Veja [Gerenciamento de Memria](memory.md#internal-reference-counting) para detalhes.\n\n## Melhores Prticas\n\n1. **Use indexao por codepoint** - Strings usam posies de codepoint, no offsets de byte\n2. **Teste com Unicode** - Sempre teste operaes de string com caracteres multibyte\n3. **Prefira operaes imutveis** - Use mtodos que retornam novas strings em vez de modificar diretamente\n4. **Verifique limites** - Indexao de string no verifica limites (retorna null/erro se invlido)\n5. **Normalize entrada** - Use `trim()` e `to_lower()` para entrada de usurio\n\n## Armadilhas Comuns\n\n### Armadilha: Confuso entre Bytes e Codepoints\n\n```hemlock\nlet emoji = \"\";\nprint(emoji.length);        // 1 (codepoints)\nprint(emoji.byte_length);   // 4 (bytes)\n\n// No misture operaes de byte e codepoint\nlet byte = emoji.byte_at(0);  // 240 (primeiro byte)\nlet char = emoji.char_at(0);  // '' (codepoint completo)\n```\n\n### Armadilha: Surpresas de Modificao\n\n```hemlock\nlet s1 = \"hello\";\nlet s2 = s1;       // Cpia rasa\ns1[0] = 'H';       // Modifica s1\nprint(s2);         // Ainda  \"hello\" (strings so tipo valor)\n```\n\n## Tpicos Relacionados\n\n- [Runas](#language-guide-runes) - Tipo de ponto de cdigo Unicode usado em indexao de string\n- [Arrays](#language-guide-arrays) - Mtodos de string frequentemente retornam ou usam arrays\n- [Tipos](#language-guide-types) - Detalhes e converses do tipo string\n\n## Veja Tambm\n\n- **Codificao UTF-8**: Veja seo \"Strings\" em CLAUDE.md\n- **Converso de tipos**: Veja [Tipos](#language-guide-types) para converso de strings\n- **Memria**: Veja [Memria](#language-guide-memory) para detalhes de alocao de strings\n"}, "Guia da Linguagem -> Tipos": {"id": "language-guide-types", "content": "# Sistema de Tipos\n\nHemlock possui um **sistema de tipos dinmico** com anotaes de tipo opcionais e verificao de tipo em tempo de execuo.\n\n---\n\n## Guia de Escolha de Tipos: Qual tipo devo usar?\n\n**Novo em tipos?** Comece aqui. Se voc est familiarizado com sistemas de tipos, pule para [Filosofia de Design](#filosofia-de-design).\n\n### Resposta Curta\n\n**Deixe o Hemlock decidir automaticamente:**\n\n```hemlock\nlet count = 42;        // Hemlock sabe que  um inteiro\nlet price = 19.99;     // Hemlock sabe que  um decimal\nlet name = \"Alice\";    // Hemlock sabe que  texto\nlet active = true;     // Hemlock sabe que  booleano\n```\n\nHemlock escolher automaticamente o tipo correto para seus valores. Voc *no precisa* especificar tipos.\n\n### Quando Adicionar Anotaes de Tipo\n\nAdicione tipos quando:\n\n1. **Precisa especificar tamanho** - `i8` vs `i64`  importante para memria ou FFI\n2. **Documentar cdigo** - Tipos mostram o que a funo espera\n3. **Detectar erros cedo** - Hemlock verifica tipos em tempo de execuo\n\n```hemlock\n// Sem tipos (funciona normalmente):\nfn add(a, b) {\n    return a + b;\n}\n\n// Com tipos (mais explcito):\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Referncia Rpida: Escolhendo Tipos Numricos\n\n| O que armazenar | Tipo recomendado | Exemplo |\n|---------|---------|------|\n| Inteiros comuns | `i32` (padro) | `let count = 42;` |\n| Nmeros muito grandes | `i64` | `let population = 8000000000;` |\n| Contagens nunca negativas | `u32` | `let items: u32 = 100;` |\n| Bytes (0-255) | `u8` | `let pixel: u8 = 255;` |\n| Decimais/fraes | `f64` (padro) | `let price = 19.99;` |\n| Decimais crticos para performance | `f32` | `let x: f32 = 1.5;` |\n\n### Referncia Rpida: Todos os Tipos\n\n| Categoria | Tipo | Quando usar |\n|-----|------|---------|\n| **Inteiros** | `i8`, `i16`, `i32`, `i64` | Contagens, IDs, idades etc. |\n| **Apenas positivos** | `u8`, `u16`, `u32`, `u64` | Bytes, tamanhos, comprimentos de array |\n| **Decimais** | `f32`, `f64` | Valores monetrios, medidas, clculos matemticos |\n| **Sim/No** | `bool` | Flags, condies |\n| **Texto** | `string` | Nomes, mensagens, qualquer texto |\n| **Caractere nico** | `rune` | Letras individuais, emojis |\n| **Listas** | `array` | Colees de valores |\n| **Campos nomeados** | `object` | Agrupar dados relacionados |\n| **Memria bruta** | `ptr`, `buffer` | Programao de baixo nvel |\n| **Valor vazio** | `null` | Representar ausncia de valor |\n\n### Cenrios Comuns\n\n**\"S preciso de um nmero\"**\n```hemlock\nlet x = 42;  // Pronto! Hemlock escolhe i32\n```\n\n**\"Preciso de decimais\"**\n```hemlock\nlet price = 19.99;  // Pronto! Hemlock escolhe f64\n```\n\n**\"Estou trabalhando com bytes (arquivos, rede)\"**\n```hemlock\nlet byte: u8 = 255;  // Faixa 0-255\n```\n\n**\"Preciso de nmeros muito grandes\"**\n```hemlock\nlet big = 9000000000000;  // Hemlock escolhe i64 automaticamente (> mx i32)\n// Ou explicitamente:\nlet big: i64 = 9000000000000;\n```\n\n**\"Estou armazenando valores monetrios\"**\n```hemlock\n// Opo 1: Ponto flutuante (simples, mas com limitaes de preciso)\nlet price: f64 = 19.99;\n\n// Opo 2: Armazenar em centavos (mais preciso)\nlet price_cents: i32 = 1999;  // R$19,99 como centavos inteiros\n```\n\n**\"Estou passando dados para cdigo C (FFI)\"**\n```hemlock\n// Corresponder tipos C exatamente\nlet c_int: i32 = 100;      // C 'int'\nlet c_long: i64 = 100;     // C 'long' (sistemas 64-bit)\nlet c_char: u8 = 65;       // C 'char'\nlet c_double: f64 = 3.14;  // C 'double'\n```\n\n### O que Acontece Quando Tipos se Misturam?\n\nQuando voc combina tipos diferentes, Hemlock promove para o tipo \"maior\":\n\n```hemlock\nlet a: i32 = 10;\nlet b: f64 = 2.5;\nlet result = a + b;  // result  f64 (12.5)\n// O inteiro se tornou decimal automaticamente\n```\n\n**Regra geral:** Ponto flutuante sempre \"vence\" - qualquer inteiro misturado com ponto flutuante resulta em ponto flutuante.\n\n### Erros de Tipo\n\nSe voc tentar usar o tipo errado, Hemlock informar em tempo de execuo:\n\n```hemlock\nlet age: i32 = \"thirty\";  // Erro: incompatibilidade de tipo - esperava i32, recebeu string\n```\n\nPara converter tipos, use construtores de tipo:\n\n```hemlock\nlet text = \"42\";\nlet number = i32(text);   // Analisa string para inteiro: 42\nlet back = text + \"\";     // J  string\n```\n\n---\n\n## Filosofia de Design\n\n- **Dinmico por padro** - Todo valor tem uma tag de tipo em tempo de execuo\n- **Tipos opcionais** - Anotaes de tipo opcionais foram verificaes em tempo de execuo\n- **Converso explcita** - Converses implcitas seguem regras de promoo claras\n- **Honestidade de tipo** - `typeof()` sempre diz a verdade\n\n## Tipos Primitivos\n\n### Tipos Inteiros\n\n**Inteiros com sinal:**\n```hemlock\nlet tiny: i8 = 127;              // 8 bits (-128 a 127)\nlet small: i16 = 32767;          // 16 bits (-32768 a 32767)\nlet normal: i32 = 2147483647;    // 32 bits (padro)\nlet large: i64 = 9223372036854775807;  // 64 bits\n```\n\n**Inteiros sem sinal:**\n```hemlock\nlet byte: u8 = 255;              // 8 bits (0 a 255)\nlet word: u16 = 65535;           // 16 bits (0 a 65535)\nlet dword: u32 = 4294967295;     // 32 bits (0 a 4294967295)\nlet qword: u64 = 18446744073709551615;  // 64 bits\n```\n\n**Aliases de tipo:**\n```hemlock\nlet i: integer = 42;   // Alias para i32\nlet b: byte = 255;     // Alias para u8\n```\n\n### Tipos de Ponto Flutuante\n\n```hemlock\nlet f: f32 = 3.14159;        // Ponto flutuante 32 bits\nlet d: f64 = 2.718281828;    // Ponto flutuante 64 bits (padro)\nlet n: number = 1.618;       // Alias para f64\n```\n\n### Tipo Booleano\n\n```hemlock\nlet flag: bool = true;\nlet active: bool = false;\n```\n\n### Tipo String\n\n```hemlock\nlet text: string = \"Hello, World!\";\nlet empty: string = \"\";\n```\n\nStrings so **mutveis**, **codificadas em UTF-8** e **alocadas no heap**.\n\nVeja [Strings](#language-guide-strings) para detalhes.\n\n### Tipo Rune\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '';\nlet newline: rune = '\\n';\nlet unicode: rune = '\\u{1F680}';\n```\n\nRunes representam **pontos de cdigo Unicode** (U+0000 a U+10FFFF).\n\nVeja [Runas](#language-guide-runes) para detalhes.\n\n### Tipo Null\n\n```hemlock\nlet nothing = null;\nlet uninitialized: string = null;\n```\n\n`null`  um tipo distinto com um nico valor.\n\n## Tipos Compostos\n\n### Tipo Array\n\n```hemlock\nlet numbers: array = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];  // Tipos mistos permitidos\nlet empty: array = [];\n```\n\nVeja [Arrays](#language-guide-arrays) para detalhes.\n\n### Tipo Object\n\n```hemlock\nlet obj: object = { x: 10, y: 20 };\nlet person = { name: \"Alice\", age: 30 };\n```\n\nVeja [Objetos](#language-guide-objects) para detalhes.\n\n### Tipos de Ponteiro\n\n**Ponteiros brutos:**\n```hemlock\nlet p: ptr = alloc(64);\n// Sem verificao de limites, gerenciamento de ciclo de vida manual\nfree(p);\n```\n\n**Buffers seguros:**\n```hemlock\nlet buf: buffer = buffer(64);\n// Com verificao de limites, rastreia comprimento e capacidade\nfree(buf);\n```\n\nVeja [Gerenciamento de Memria](#language-guide-memory) para detalhes.\n\n## Tipos Enum\n\nEnums definem um conjunto de constantes nomeadas:\n\n### Enum Bsico\n\n```hemlock\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nlet c = Color.RED;\nprint(c);              // 0\nprint(typeof(c));      // \"Color\"\n\n// Comparao\nif (c == Color.RED) {\n    print(\"It's red!\");\n}\n\n// Usando switch com enum\nswitch (c) {\n    case Color.RED:\n        print(\"Stop\");\n        break;\n    case Color.GREEN:\n        print(\"Go\");\n        break;\n    case Color.BLUE:\n        print(\"Blue?\");\n        break;\n}\n```\n\n### Enum com Valores\n\nEnums podem ter valores inteiros explcitos:\n\n```hemlock\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 2\n}\n\nprint(Status.OK);      // 0\nprint(Status.ERROR);   // 1\n\nenum HttpCode {\n    OK = 200,\n    NOT_FOUND = 404,\n    SERVER_ERROR = 500\n}\n\nlet code = HttpCode.NOT_FOUND;\nprint(code);           // 404\n```\n\n### Valores Auto-incrementados\n\nSem valores explcitos, enums auto-incrementam a partir de 0:\n\n```hemlock\nenum Priority {\n    LOW,       // 0\n    MEDIUM,    // 1\n    HIGH,      // 2\n    CRITICAL   // 3\n}\n\n// Pode misturar valores explcitos e automticos\nenum Level {\n    DEBUG = 10,\n    INFO,      // 11\n    WARN,      // 12\n    ERROR = 50,\n    FATAL      // 51\n}\n```\n\n### Padres de Uso de Enum\n\n```hemlock\n// Como parmetro de funo\nfn set_priority(p: Priority) {\n    if (p == Priority.CRITICAL) {\n        print(\"Urgent!\");\n    }\n}\n\nset_priority(Priority.HIGH);\n\n// Em objetos\ndefine Task {\n    name: string,\n    priority: Priority\n}\n\nlet task: Task = {\n    name: \"Fix bug\",\n    priority: Priority.HIGH\n};\n```\n\n## Tipos Especiais\n\n### Tipo File\n\n```hemlock\nlet f: file = open(\"data.txt\", \"r\");\nf.close();\n```\n\nRepresenta um handle de arquivo aberto.\n\n### Tipo Task\n\n```hemlock\nasync fn compute(): i32 { return 42; }\nlet task = spawn(compute);\nlet result: i32 = join(task);\n```\n\nRepresenta um handle de tarefa assncrona.\n\n### Tipo Channel\n\n```hemlock\nlet ch: channel = channel(10);\nch.send(42);\nlet value = ch.recv();\n```\n\nRepresenta um canal de comunicao entre tarefas.\n\n### Tipo Void\n\n```hemlock\nextern fn exit(code: i32): void;\n```\n\nUsado para funes que no retornam valores (apenas FFI).\n\n## Inferncia de Tipos\n\n### Inferncia de Literais Inteiros\n\nHemlock infere o tipo inteiro baseado na faixa de valores:\n\n```hemlock\nlet a = 42;              // i32 (cabe em 32 bits)\nlet b = 5000000000;      // i64 (> mx i32)\nlet c = 128;             // i32\nlet d: u8 = 128;         // u8 (anotao explcita)\n```\n\n**Regras:**\n- Valores na faixa i32 (-2147483648 a 2147483647): inferido como `i32`\n- Valores fora da faixa i32 mas dentro da faixa i64: inferido como `i64`\n- Outros tipos (i8, i16, u8, u16, u32, u64) usam anotao explcita\n\n### Inferncia de Literais de Ponto Flutuante\n\n```hemlock\nlet x = 3.14;        // f64 (padro)\nlet y: f32 = 3.14;   // f32 (explcito)\n```\n\n### Notao Cientfica\n\nHemlock suporta notao cientfica para literais numricos:\n\n```hemlock\nlet a = 1e10;        // 10000000000.0 (f64)\nlet b = 1e-12;       // 0.000000000001 (f64)\nlet c = 3.14e2;      // 314.0 (f64)\nlet d = 2.5e-3;      // 0.0025 (f64)\nlet e = 1E10;        // No diferencia maisculas/minsculas\nlet f = 1e+5;        // Expoente positivo explcito\n```\n\n**Nota:** Qualquer literal usando notao cientfica  sempre inferido como `f64`.\n\n### Outras Inferncias de Tipo\n\n```hemlock\nlet s = \"hello\";     // string\nlet ch = 'A';        // rune\nlet flag = true;     // bool\nlet arr = [1, 2, 3]; // array\nlet obj = { x: 10 }; // object\nlet nothing = null;  // null\n```\n\n## Anotaes de Tipo\n\n### Anotaes de Varivel\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet name: string = \"Alice\";\n```\n\n### Anotaes de Parmetros de Funo\n\n```hemlock\nfn greet(name: string, age: i32) {\n    print(\"Hello, \" + name + \"!\");\n}\n```\n\n### Anotaes de Tipo de Retorno de Funo\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Anotaes de Tipo de Objeto (Duck Typing)\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\n```\n\n## Verificao de Tipos\n\n### Verificao de Tipo em Tempo de Execuo\n\nAnotaes de tipo so verificadas em **tempo de execuo**, no em tempo de compilao:\n\n```hemlock\nlet x: i32 = 42;     // OK\nlet y: i32 = 3.14;   // Erro em tempo de execuo: incompatibilidade de tipo\n\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 3);           // OK\nadd(5, \"hello\");     // Erro em tempo de execuo: incompatibilidade de tipo\n```\n\n### Consulta de Tipo\n\nUse `typeof()` para verificar o tipo de um valor:\n\n```hemlock\nprint(typeof(42));         // \"i32\"\nprint(typeof(3.14));       // \"f64\"\nprint(typeof(\"hello\"));    // \"string\"\nprint(typeof(true));       // \"bool\"\nprint(typeof(null));       // \"null\"\nprint(typeof([1, 2, 3]));  // \"array\"\nprint(typeof({ x: 10 }));  // \"object\"\n```\n\n## Converso de Tipos\n\n### Promoo Implcita de Tipos\n\nQuando tipos so misturados em operaes, Hemlock promove para o tipo \"maior\":\n\n**Hierarquia de promoo (do menor para o maior):**\n```\ni8  i16  i32  u32  i64  u64  f32  f64\n                \n     u8    u16\n```\n\n**Ponto flutuante sempre vence:**\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result  f64 (13.5)\n```\n\n**Tamanho maior vence:**\n```hemlock\nlet a: i32 = 100;\nlet b: i64 = 200;\nlet sum = a + b;     // sum  i64 (300)\n```\n\n**Preservao de preciso:** Quando inteiros de 64 bits so misturados com f32, Hemlock promove para f64 para evitar perda de preciso (f32 tem apenas 24 bits de mantissa, insuficiente para representar i64/u64):\n```hemlock\nlet big: i64 = 9007199254740993;\nlet small: f32 = 1.0;\nlet result = big + small;  // result  f64, no f32!\n```\n\n**Exemplos:**\n```hemlock\nu8 + i32   i32\ni32 + i64  i64\nu32 + u64  u64\ni32 + f32  f32    // f32  suficiente para representar i32\ni64 + f32  f64    // Precisa de f64 para manter preciso de i64\ni64 + f64  f64\ni8 + f64   f64\n```\n\n### Converso Explcita de Tipos\n\n**Converso inteiro/ponto flutuante:**\n```hemlock\nlet i: i32 = 42;\nlet f: f64 = i;      // i32  f64 (42.0)\n\nlet x: f64 = 3.14;\nlet n: i32 = x;      // f64  i32 (3, truncado)\n```\n\n**Converso inteiro/rune:**\n```hemlock\nlet code: i32 = 65;\nlet ch: rune = code;  // i32  rune ('A')\n\nlet r: rune = 'Z';\nlet value: i32 = r;   // rune  i32 (90)\n```\n\n**Rune para string:**\n```hemlock\nlet ch: rune = '';\nlet s: string = ch;   // rune  string (\"\")\n```\n\n**u8 para rune:**\n```hemlock\nlet b: u8 = 65;\nlet r: rune = b;      // u8  rune ('A')\n```\n\n### Construtores de Tipo\n\nNomes de tipo podem ser usados como funes para converter ou analisar valores:\n\n**Analisar strings para nmeros:**\n```hemlock\nlet n = i32(\"42\");       // Analisa string para i32: 42\nlet f = f64(\"3.14159\");  // Analisa string para f64: 3.14159\nlet b = bool(\"true\");    // Analisa string para bool: true\n\n// Suporta todos os tipos numricos\nlet a = i8(\"-128\");      // Analisa para i8\nlet c = u8(\"255\");       // Analisa para u8\nlet d = i16(\"1000\");     // Analisa para i16\nlet e = u16(\"50000\");    // Analisa para u16\nlet g = i64(\"9000000000000\"); // Analisa para i64\nlet h = u64(\"18000000000000\"); // Analisa para u64\nlet j = f32(\"1.5\");      // Analisa para f32\n```\n\n**Hexadecimal e negativos:**\n```hemlock\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\nlet bin = i32(\"0b1010\"); // 10 (binrio)\n```\n\n**Aliases de tipo tambm funcionam:**\n```hemlock\nlet x = integer(\"100\");  // Equivalente a i32(\"100\")\nlet y = number(\"1.5\");   // Equivalente a f64(\"1.5\")\nlet z = byte(\"200\");     // Equivalente a u8(\"200\")\n```\n\n**Converso entre tipos numricos:**\n```hemlock\nlet big = i64(42);           // i32 para i64\nlet truncated = i32(3.99);   // f64 para i32 (trunca para 3)\nlet promoted = f64(100);     // i32 para f64 (100.0)\nlet narrowed = i8(127);      // i32 para i8\n```\n\n**Anotaes de tipo executam coero numrica (mas no analisam strings):**\n```hemlock\nlet f: f64 = 100;        // i32 para f64 via anotao (OK)\nlet s: string = 'A';     // Rune para string via anotao (OK)\nlet code: i32 = 'A';     // Rune para i32 via anotao (obtm codepoint, OK)\n\n// Anlise de string requer construtor de tipo explcito:\nlet n = i32(\"42\");       // Use construtor de tipo para analisar string\n// let x: i32 = \"42\";    // Erro - anotao de tipo no analisa strings\n```\n\n**Tratamento de erros:**\n```hemlock\n// Ao usar construtores de tipo, strings invlidas lanam erro\nlet bad = i32(\"hello\");  // Erro em tempo de execuo: no  possvel analisar \"hello\" como i32\nlet overflow = u8(\"256\"); // Erro em tempo de execuo: 256 est fora da faixa de u8\n```\n\n**Anlise de booleano:**\n```hemlock\nlet t = bool(\"true\");    // true\nlet f = bool(\"false\");   // false\nlet bad = bool(\"yes\");   // Erro em tempo de execuo: deve ser \"true\" ou \"false\"\n```\n\n## Verificao de Faixa\n\nAnotaes de tipo foram verificao de faixa na atribuio:\n\n```hemlock\nlet x: u8 = 255;    // OK\nlet y: u8 = 256;    // Erro: fora da faixa de u8\n\nlet a: i8 = 127;    // OK\nlet b: i8 = 128;    // Erro: fora da faixa de i8\n\nlet c: i64 = 2147483647;   // OK\nlet d: u64 = 4294967295;   // OK\nlet e: u64 = -1;           // Erro: u64 no pode ser negativo\n```\n\n## Exemplos de Promoo de Tipos\n\n### Misturando Tipos Inteiros\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet sum = a + b;     // i32 (30)\n\nlet c: u8 = 100;\nlet d: u32 = 200;\nlet total = c + d;   // u32 (300)\n```\n\n### Inteiro + Ponto Flutuante\n\n```hemlock\nlet i: i32 = 5;\nlet f: f32 = 2.5;\nlet result = i * f;  // f32 (12.5)\n```\n\n### Expresses Complexas\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet c: f64 = 3.0;\n\nlet result = a + b * c;  // f64 (70.0)\n// Clculo: b * c  f64(60.0)\n//          a + f64(60.0)  f64(70.0)\n```\n\n## Duck Typing (Objetos)\n\nObjetos usam **tipagem estrutural** (duck typing):\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK: tem todos os campos obrigatrios\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK: campos extras permitidos\nlet p2: Person = { name: \"Bob\", age: 25, city: \"NYC\" };\n\n// Erro: falta campo 'age'\nlet p3: Person = { name: \"Carol\" };\n\n// Erro: tipo errado para 'age'\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```\n\n**Verificao de tipo ocorre na atribuio:**\n- Verifica se todos os campos obrigatrios existem\n- Verifica se tipos dos campos correspondem\n- Permite e preserva campos extras\n- Define o nome do tipo do objeto para `typeof()`\n\n## Campos Opcionais\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug?: false,     // Campo opcional com valor padro\n    timeout?: i32,     // Opcional, padro null\n}\n\nlet cfg1: Config = { host: \"localhost\", port: 8080 };\nprint(cfg1.debug);    // false (padro)\nprint(cfg1.timeout);  // null\n\nlet cfg2: Config = { host: \"0.0.0.0\", port: 80, debug: true };\nprint(cfg2.debug);    // true (sobrescrito)\n```\n\n## Aliases de Tipo\n\nHemlock suporta aliases de tipo personalizados usando a palavra-chave `type`:\n\n### Aliases de Tipo Bsicos\n\n```hemlock\n// Aliases de tipo simples\ntype Integer = i32;\ntype Text = string;\n\n// Usando aliases\nlet x: Integer = 42;\nlet msg: Text = \"hello\";\n```\n\n### Aliases de Tipo de Funo\n\n```hemlock\n// Aliases de tipo de funo\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// Usando aliases de tipo de funo\nlet cb: Callback = fn(n) { print(n); };\nlet isEven: Predicate = fn(n) { return n % 2 == 0; };\n```\n\n### Aliases de Tipo Composto\n\n```hemlock\n// Combinar mltiplos defines em um tipo\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\ntype Person = HasName & HasAge;\n\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\n### Aliases de Tipo Genrico\n\n```hemlock\n// Aliases de tipo genrico\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// Usando aliases genricos\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**Nota:** Aliases de tipo so transparentes - `typeof()` retorna o nome do tipo subjacente, no o alias.\n\n## Limitaes do Sistema de Tipos\n\nLimitaes atuais:\n\n- **Sem genricos para funes** - Parmetros de tipo de funo ainda no suportados\n- **Sem tipos unio** - No  possvel expressar \"A ou B\"\n- **Sem tipos anulveis** - Todos os tipos podem ser null (use sufixo `?` para nullable explcito)\n\n**Nota:** O compilador (`hemlockc`) fornece verificao de tipos em tempo de compilao. O interpretador apenas realiza verificao de tipos em tempo de execuo. Veja a [documentao do compilador](#design-implementation) para detalhes.\n\n## Melhores Prticas\n\n### Quando Usar Anotaes de Tipo\n\n**Deve usar anotaes quando:**\n- O tipo preciso importa (ex: `u8` para valores de byte)\n- Documentar interfaces de funo\n- Forar restries (ex: verificao de faixa)\n\n```hemlock\nfn hash(data: buffer, length: u32): u64 {\n    // implementao\n}\n```\n\n**No precisa usar anotaes quando:**\n- O tipo  bvio pelo literal\n- Detalhes de implementao interna\n- Formalidade desnecessria\n\n```hemlock\n// Desnecessrio\nlet x: i32 = 42;\n\n// Melhor\nlet x = 42;\n```\n\n### Padres de Segurana de Tipos\n\n**Verificar antes de usar:**\n```hemlock\nif (typeof(value) == \"i32\") {\n    // Pode usar com segurana como i32\n}\n```\n\n**Validar argumentos de funo:**\n```hemlock\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" || typeof(b) != \"i32\") {\n        throw \"arguments must be integers\";\n    }\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n```\n\n**Usar duck typing para flexibilidade:**\n```hemlock\ndefine Printable {\n    toString: fn,\n}\n\nfn print_item(item: Printable) {\n    print(item.toString());\n}\n```\n\n## Prximos Passos\n\n- [Strings](#language-guide-strings) - Tipo string UTF-8 e operaes\n- [Runas](#language-guide-runes) - Tipo de ponto de cdigo Unicode\n- [Arrays](#language-guide-arrays) - Tipo de array dinmico\n- [Objetos](#language-guide-objects) - Literais de objeto e duck typing\n- [Memria](#language-guide-memory) - Tipos ponteiro e buffer\n"}, "Guia da Linguagem -> Tratamento de Erros": {"id": "language-guide-error-handling", "content": "# Tratamento de Erros\n\nHemlock suporta tratamento de erros baseado em excees atravs de `try`, `catch`, `finally`, `throw` e `panic`. Este guia abrange o uso de excees para erros recuperveis e panic para erros irrecuperveis.\n\n## Visao Geral\n\n```hemlock\n// Tratamento bsico de erros\ntry {\n    operacao_arriscada();\n} catch (e) {\n    print(\"Erro: \" + e);\n}\n\n// Com operao de limpeza\ntry {\n    process_file();\n} catch (e) {\n    print(\"Falhou: \" + e);\n} finally {\n    cleanup();\n}\n\n// Lanando erros\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"diviso por zero\";\n    }\n    return a / b;\n}\n```\n\n## Try-Catch-Finally\n\n### Sintaxe\n\n**Try/catch bsico:**\n```hemlock\ntry {\n    // Cdigo arriscado\n} catch (e) {\n    // Trata erro, e contm o valor lanado\n}\n```\n\n**Try/finally:**\n```hemlock\ntry {\n    // Cdigo arriscado\n} finally {\n    // Sempre executa, mesmo se exceo for lanada\n}\n```\n\n**Try/catch/finally:**\n```hemlock\ntry {\n    // Cdigo arriscado\n} catch (e) {\n    // Trata erro\n} finally {\n    // Cdigo de limpeza\n}\n```\n\n### Bloco Try\n\nO bloco try executa declaraes em sequncia:\n\n```hemlock\ntry {\n    print(\"Iniciando...\");\n    operacao_arriscada();\n    print(\"Sucesso!\");  // S executa se no houver exceo\n}\n```\n\n**Comportamento:**\n- Executa declaraes em sequncia\n- Se exceo for lanada: pula para `catch` ou `finally`\n- Se no houver exceo: executa `finally` (se presente) e continua\n\n### Bloco Catch\n\nO bloco catch recebe o valor lanado:\n\n```hemlock\ntry {\n    throw \"ops\";\n} catch (erro) {\n    print(\"Capturado: \" + erro);  // erro = \"ops\"\n    // erro s  acessvel aqui\n}\n// erro no  acessvel aqui\n```\n\n**Parmetro catch:**\n- Recebe o valor lanado (qualquer tipo)\n- Escopo limitado ao bloco catch\n- Pode ter qualquer nome (comumente `e`, `err` ou `error`)\n\n**O que voc pode fazer no catch:**\n```hemlock\ntry {\n    operacao_arriscada();\n} catch (e) {\n    // Registrar erro\n    print(\"Erro: \" + e);\n\n    // Relanar mesmo erro\n    throw e;\n\n    // Lanar erro diferente\n    throw \"erro diferente\";\n\n    // Retornar valor padro\n    return null;\n\n    // Tratar e continuar\n    // (sem relanar)\n}\n```\n\n### Bloco Finally\n\nO bloco finally **sempre executa**:\n\n```hemlock\ntry {\n    print(\"1: try\");\n    throw \"erro\";\n} catch (e) {\n    print(\"2: catch\");\n} finally {\n    print(\"3: finally\");  // Sempre executa\n}\nprint(\"4: depois\");\n\n// Sada: 1: try, 2: catch, 3: finally, 4: depois\n```\n\n**Quando finally executa:**\n- Aps bloco try (se no houver exceo)\n- Aps bloco catch (se exceo foi capturada)\n- Mesmo se try/catch contiver `return`, `break` ou `continue`\n- Antes do fluxo de controle sair do try/catch\n\n**Finally com return:**\n```hemlock\nfn example() {\n    try {\n        return 1;  // Retorna 1 aps finally executar\n    } finally {\n        print(\"limpeza\");  // Executa antes de retornar\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // return do finally sobrescreve - retorna 2\n    }\n}\n```\n\n**Finally com fluxo de controle:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) {\n            break;  // Break aps finally executar\n        }\n    } finally {\n        print(\"limpeza \" + typeof(i));\n    }\n}\n```\n\n## Declarao Throw\n\n### Throw Bsico\n\nLana qualquer valor como exceo:\n\n```hemlock\nthrow \"mensagem de erro\";\nthrow 404;\nthrow { code: 500, message: \"Erro interno\" };\nthrow null;\nthrow [\"erro\", \"detalhes\"];\n```\n\n**Processo de execuo:**\n1. Avalia a expresso\n2. Pula imediatamente para o `catch` mais prximo\n3. Se no houver `catch`, propaga pela pilha de chamadas\n\n### Lanando Erros\n\n```hemlock\nfn validate_age(idade: i32) {\n    if (idade < 0) {\n        throw \"Idade no pode ser negativa\";\n    }\n    if (idade > 150) {\n        throw \"Idade no  realista\";\n    }\n}\n\ntry {\n    validate_age(-5);\n} catch (e) {\n    print(\"Erro de validao: \" + e);\n}\n```\n\n### Lanando Objetos de Erro\n\nCrie informaes de erro estruturadas:\n\n```hemlock\nfn read_file(caminho: string) {\n    if (!file_exists(caminho)) {\n        throw {\n            type: \"FileNotFound\",\n            path: caminho,\n            message: \"Arquivo no existe\"\n        };\n    }\n    // ... ler arquivo\n}\n\ntry {\n    read_file(\"faltando.txt\");\n} catch (e) {\n    if (e.type == \"FileNotFound\") {\n        print(\"Arquivo no encontrado: \" + e.path);\n    }\n}\n```\n\n### Relanando\n\nCaptura e relana erros:\n\n```hemlock\nfn wrapper() {\n    try {\n        operacao_arriscada();\n    } catch (e) {\n        print(\"Registrando erro: \" + e);\n        throw e;  // Relana para o chamador\n    }\n}\n\ntry {\n    wrapper();\n} catch (e) {\n    print(\"Capturado no main: \" + e);\n}\n```\n\n## Excees No Capturadas\n\nSe uma exceo propaga at o topo da pilha de chamadas sem ser capturada:\n\n```hemlock\nfn foo() {\n    throw \"no capturada!\";\n}\n\nfoo();  // Crash com: Runtime error: no capturada!\n```\n\n**Comportamento:**\n- Programa termina\n- Imprime mensagem de erro no stderr\n- Sai com cdigo de status no-zero\n- Stack trace ser adicionado em verses futuras\n\n## Panic - Erros Irrecuperveis\n\n### O que  Panic?\n\n`panic()`  usado para **erros irrecuperveis** que devem terminar o programa imediatamente:\n\n```hemlock\npanic();                    // Mensagem padro: \"panic!\"\npanic(\"mensagem custom\");   // Mensagem personalizada\npanic(42);                  // Valores no-string sero impressos\n```\n\n**Semntica:**\n- **Sai imediatamente** do programa com cdigo de sada 1\n- Imprime mensagem de erro no stderr: `panic: <mensagem>`\n- **No pode** ser capturado por try/catch\n- Usado para bugs e erros irrecuperveis\n\n### Panic vs Throw\n\n```hemlock\n// throw - erro recupervel (pode ser capturado)\ntry {\n    throw \"erro recupervel\";\n} catch (e) {\n    print(\"Capturado: \" + e);  // Captura com sucesso\n}\n\n// panic - erro irrecupervel (no pode ser capturado)\ntry {\n    panic(\"erro irrecupervel\");  // Programa sai imediatamente\n} catch (e) {\n    print(\"Isso nunca executa\");   // Nunca executa\n}\n```\n\n### Quando Usar Panic\n\n**Use panic para:**\n- **Bugs**: Cdigo alcanado que no deveria ser\n- **Estado invlido**: Estrutura de dados corrompida detectada\n- **Erros irrecuperveis**: Recurso crtico indisponvel\n- **Falhas de assero**: Quando `assert()` no  suficiente\n\n**Exemplos:**\n```hemlock\n// Cdigo inalcanvel\nfn process_state(estado: i32) {\n    if (estado == 1) {\n        return \"pronto\";\n    } else if (estado == 2) {\n        return \"executando\";\n    } else if (estado == 3) {\n        return \"parado\";\n    } else {\n        panic(\"estado invlido: \" + typeof(estado));  // No deveria acontecer\n    }\n}\n\n// Verificao de recurso crtico\nfn init_system() {\n    let config = read_file(\"config.json\");\n    if (config == null) {\n        panic(\"config.json no encontrado - no pode iniciar\");\n    }\n    // ...\n}\n\n// Invariante de estrutura de dados\nfn pop_stack(pilha) {\n    if (pilha.length == 0) {\n        panic(\"pop() chamado em pilha vazia\");\n    }\n    return pilha.pop();\n}\n```\n\n### Quando No Usar Panic\n\n**Use throw para:**\n- Validao de entrada do usurio\n- Arquivo no encontrado\n- Erros de rede\n- Condies de erro esperadas\n\n```hemlock\n// Ruim: usar panic para erros esperados\nfn divide(a, b) {\n    if (b == 0) {\n        panic(\"diviso por zero\");  // Muito severo\n    }\n    return a / b;\n}\n\n// Bom: usar throw para erros esperados\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"diviso por zero\";  // Recupervel\n    }\n    return a / b;\n}\n```\n\n## Interao com Fluxo de Controle\n\n### Return em Try/Catch/Finally\n\n```hemlock\nfn example() {\n    try {\n        return 1;  // Retorna 1 aps finally executar\n    } finally {\n        print(\"limpeza\");\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // return do finally sobrescreve - retorna 2\n    }\n}\n```\n\n**Regra:** O valor de retorno do bloco finally sobrescreve o retorno do try/catch.\n\n### Break/Continue em Try/Catch/Finally\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) { break; }  // Break aps finally executar\n    } finally {\n        print(\"limpeza \" + typeof(i));\n    }\n}\n```\n\n**Regra:** break/continue executa aps o bloco finally.\n\n### Try/Catch Aninhado\n\n```hemlock\ntry {\n    try {\n        throw \"interno\";\n    } catch (e) {\n        print(\"Capturado: \" + e);  // Imprime: Capturado: interno\n        throw \"externo\";  // Relana erro diferente\n    }\n} catch (e) {\n    print(\"Capturado: \" + e);  // Imprime: Capturado: externo\n}\n```\n\n**Regra:** Blocos try/catch aninhados funcionam como esperado, catch interno executa primeiro.\n\n## Padres Comuns\n\n### Padro: Limpeza de Recursos\n\nSempre use `finally` para limpeza:\n\n```hemlock\nfn process_file(filename) {\n    let file = null;\n    try {\n        file = open(filename);\n        let content = file.read();\n        process(content);\n    } catch (e) {\n        print(\"Erro processando arquivo: \" + e);\n    } finally {\n        if (file != null) {\n            file.close();  // Fecha mesmo em erro\n        }\n    }\n}\n```\n\n### Padro: Encapsulamento de Erro\n\nEncapsula erros de baixo nvel com contexto:\n\n```hemlock\nfn load_config(caminho) {\n    try {\n        let content = read_file(caminho);\n        return parse_json(content);\n    } catch (e) {\n        throw \"Falha ao carregar config de \" + caminho + \": \" + e;\n    }\n}\n```\n\n### Padro: Recuperao de Erro\n\nFornece valor de fallback em caso de erro:\n\n```hemlock\nfn safe_divide(a, b) {\n    try {\n        if (b == 0) {\n            throw \"diviso por zero\";\n        }\n        return a / b;\n    } catch (e) {\n        print(\"Erro: \" + e);\n        return null;  // Valor de fallback\n    }\n}\n```\n\n### Padro: Validao\n\nUse excees para validao:\n\n```hemlock\nfn validate_user(usuario) {\n    if (usuario.name == null || usuario.name == \"\") {\n        throw \"Nome  obrigatrio\";\n    }\n    if (usuario.age < 0 || usuario.age > 150) {\n        throw \"Idade invlida\";\n    }\n    if (usuario.email == null || !usuario.email.contains(\"@\")) {\n        throw \"Email invlido\";\n    }\n}\n\ntry {\n    validate_user({ name: \"Alice\", age: -5, email: \"invlido\" });\n} catch (e) {\n    print(\"Validao falhou: \" + e);\n}\n```\n\n### Padro: Mltiplos Tipos de Erro\n\nUse objetos de erro para distinguir tipos de erro:\n\n```hemlock\nfn process_data(dados) {\n    if (dados == null) {\n        throw { type: \"NullData\", message: \"Dados so nulos\" };\n    }\n\n    if (typeof(dados) != \"array\") {\n        throw { type: \"TypeError\", message: \"Esperado array\" };\n    }\n\n    if (dados.length == 0) {\n        throw { type: \"EmptyData\", message: \"Array est vazio\" };\n    }\n\n    // ... processar\n}\n\ntry {\n    process_data(null);\n} catch (e) {\n    if (e.type == \"NullData\") {\n        print(\"Nenhum dado fornecido\");\n    } else if (e.type == \"TypeError\") {\n        print(\"Tipo de dados errado: \" + e.message);\n    } else {\n        print(\"Erro: \" + e.message);\n    }\n}\n```\n\n## Melhores Prticas\n\n1. **Use excees para situaes excepcionais** - No use para fluxo de controle normal\n2. **Lance erros significativos** - Use strings ou objetos com contexto\n3. **Sempre use finally para limpeza** - Garanta que recursos sejam liberados\n4. **No capture e ignore** - Pelo menos registre o erro\n5. **Relance quando apropriado** - Se voc no pode tratar, deixe o chamador tratar\n6. **Use panic para bugs** - Use panic para erros irrecuperveis\n7. **Documente excees** - Deixe claro quais funes podem lanar excees\n\n## Armadilhas Comuns\n\n### Armadilha: Engolir Erros\n\n```hemlock\n// Ruim: falha silenciosa\ntry {\n    operacao_arriscada();\n} catch (e) {\n    // Erro ignorado - falha silenciosa\n}\n\n// Bom: registrar ou tratar\ntry {\n    operacao_arriscada();\n} catch (e) {\n    print(\"Operao falhou: \" + e);\n    // Tratar apropriadamente\n}\n```\n\n### Armadilha: Sobrescrita do Finally\n\n```hemlock\n// Ruim: finally sobrescreve valor de retorno\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        return 0;  // Retorna 0, no 42!\n    }\n}\n\n// Bom: no retorne no finally\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        cleanup();  // Apenas limpeza, sem retorno\n    }\n}\n```\n\n### Armadilha: Esquecer Limpeza\n\n```hemlock\n// Ruim: arquivo pode no fechar em erro\nfn process() {\n    let file = open(\"data.txt\");\n    let content = file.read();  // Pode lanar\n    file.close();  // Nunca alcanado se erro\n}\n\n// Bom: usar finally\nfn process() {\n    let file = null;\n    try {\n        file = open(\"data.txt\");\n        let content = file.read();\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n}\n```\n\n### Armadilha: Usar Panic para Erros Esperados\n\n```hemlock\n// Ruim: usar panic para erros esperados\nfn read_config(caminho) {\n    if (!file_exists(caminho)) {\n        panic(\"Arquivo de config no encontrado\");  // Muito severo\n    }\n    return read_file(caminho);\n}\n\n// Bom: usar throw para erros esperados\nfn read_config(caminho) {\n    if (!file_exists(caminho)) {\n        throw \"Arquivo de config no encontrado: \" + caminho;  // Recupervel\n    }\n    return read_file(caminho);\n}\n```\n\n## Exemplos\n\n### Exemplo: Tratamento Bsico de Erros\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"diviso por zero\";\n    }\n    return a / b;\n}\n\ntry {\n    print(divide(10, 0));\n} catch (e) {\n    print(\"Erro: \" + e);  // Imprime: Erro: diviso por zero\n}\n```\n\n### Exemplo: Gerenciamento de Recursos\n\n```hemlock\nfn copy_file(src, dst) {\n    let src_file = null;\n    let dst_file = null;\n\n    try {\n        src_file = open(src, \"r\");\n        dst_file = open(dst, \"w\");\n\n        let content = src_file.read();\n        dst_file.write(content);\n\n        print(\"Arquivo copiado com sucesso\");\n    } catch (e) {\n        print(\"Falha ao copiar arquivo: \" + e);\n        throw e;  // Relana\n    } finally {\n        if (src_file != null) { src_file.close(); }\n        if (dst_file != null) { dst_file.close(); }\n    }\n}\n```\n\n### Exemplo: Tratamento de Erros Aninhado\n\n```hemlock\nfn process_users(usuarios) {\n    let success_count = 0;\n    let error_count = 0;\n\n    let i = 0;\n    while (i < usuarios.length) {\n        try {\n            validate_user(usuarios[i]);\n            save_user(usuarios[i]);\n            success_count = success_count + 1;\n        } catch (e) {\n            print(\"Falha ao processar usurio: \" + e);\n            error_count = error_count + 1;\n        }\n        i = i + 1;\n    }\n\n    print(\"Processados: \" + typeof(success_count) + \" sucesso, \" + typeof(error_count) + \" erros\");\n}\n```\n\n### Exemplo: Tipos de Erro Personalizados\n\n```hemlock\nfn create_error(tipo, mensagem, detalhes) {\n    return {\n        type: tipo,\n        message: mensagem,\n        details: detalhes,\n        toString: fn() {\n            return self.type + \": \" + self.message;\n        }\n    };\n}\n\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" && typeof(a) != \"f64\") {\n        throw create_error(\"TypeError\", \"a deve ser um nmero\", { value: a });\n    }\n    if (typeof(b) != \"i32\" && typeof(b) != \"f64\") {\n        throw create_error(\"TypeError\", \"b deve ser um nmero\", { value: b });\n    }\n    if (b == 0) {\n        throw create_error(\"DivisionByZero\", \"No pode dividir por zero\", { a: a, b: b });\n    }\n    return a / b;\n}\n\ntry {\n    divide(10, 0);\n} catch (e) {\n    print(e.toString());\n    if (e.type == \"DivisionByZero\") {\n        print(\"Detalhes: a=\" + typeof(e.details.a) + \", b=\" + typeof(e.details.b));\n    }\n}\n```\n\n### Exemplo: Lgica de Retry\n\n```hemlock\nfn retry(operacao, max_tentativas) {\n    let tentativa = 0;\n\n    while (tentativa < max_tentativas) {\n        try {\n            return operacao();  // Sucesso!\n        } catch (e) {\n            tentativa = tentativa + 1;\n            if (tentativa >= max_tentativas) {\n                throw \"Operao falhou aps \" + typeof(max_tentativas) + \" tentativas: \" + e;\n            }\n            print(\"Tentativa \" + typeof(tentativa) + \" falhou, tentando novamente...\");\n        }\n    }\n}\n\nfn operacao_instavel() {\n    // Simula operao instvel\n    if (random() < 0.7) {\n        throw \"Operao falhou\";\n    }\n    return \"Sucesso\";\n}\n\ntry {\n    let resultado = retry(operacao_instavel, 3);\n    print(resultado);\n} catch (e) {\n    print(\"Todas as tentativas falharam: \" + e);\n}\n```\n\n## Ordem de Execuo\n\nEntenda a ordem de execuo:\n\n```hemlock\ntry {\n    print(\"1: incio do bloco try\");\n    throw \"erro\";\n    print(\"2: nunca alcanado\");\n} catch (e) {\n    print(\"3: bloco catch\");\n} finally {\n    print(\"4: bloco finally\");\n}\nprint(\"5: depois do try/catch/finally\");\n\n// Sada:\n// 1: incio do bloco try\n// 3: bloco catch\n// 4: bloco finally\n// 5: depois do try/catch/finally\n```\n\n## Limitaes Atuais\n\n- **Sem stack trace** - Excees no capturadas no mostram stack trace (planejado)\n- **Algumas funes built-in usam exit** - Algumas funes built-in ainda usam `exit()` em vez de lanar (a ser revisado)\n- **Sem tipos de exceo customizados** - Qualquer valor pode ser lanado, mas no h hierarquia formal de excees\n\n## Tpicos Relacionados\n\n- [Funes](#language-guide-functions) - Excees e retorno de funes\n- [Fluxo de Controle](#language-guide-control-flow) - Como excees afetam fluxo de controle\n- [Memria](#language-guide-memory) - Limpeza de memria com finally\n\n## Veja Tambm\n\n- **Semntica de Excees**: Veja seo \"Tratamento de Erros\" em CLAUDE.md\n- **Panic vs Throw**: Diferentes casos de uso para diferentes tipos de erro\n- **Garantias do Finally**: Sempre executa, mesmo com return/break/continue\n"}, "Tpicos Avanados -> Argumentos de Linha de Comando": {"id": "advanced-command-line-args", "content": "# Hemlock Argumentos de Linha de Comando\n\nProgramas Hemlock podem acessar argumentos de linha de comando atravs do **array `args` integrado**, que  automaticamente preenchido na inicializao do programa.\n\n## ndice\n\n- [Viso Geral](#viso-geral)\n- [Array args](#array-args)\n- [Propriedades](#propriedades)\n- [Padres de Iterao](#padres-de-iterao)\n- [Casos de Uso Comuns](#casos-de-uso-comuns)\n- [Padres de Parse de Argumentos](#padres-de-parse-de-argumentos)\n- [Melhores Prticas](#melhores-prticas)\n- [Exemplos Completos](#exemplos-completos)\n\n## Viso Geral\n\nO array `args` fornece acesso aos argumentos de linha de comando passados para um programa Hemlock:\n\n- **Sempre disponvel** - varivel global integrada em todos os programas Hemlock\n- **Inclui nome do script** - `args[0]` sempre contm o caminho/nome do script\n- **Array de strings** - todos os argumentos so strings\n- **Indexao base zero** - indexao de array padro (0, 1, 2, ...)\n\n## Array args\n\n### Estrutura Bsica\n\n```hemlock\n// args[0]  sempre o nome do arquivo do script\n// args[1] at args[n-1] so os argumentos reais\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // Nmero total de argumentos (incluindo nome do script)\n```\n\n### Exemplo de Uso\n\n**Comando:**\n```bash\n./hemlock script.hml hello world \"test 123\"\n```\n\n**Em script.hml:**\n```hemlock\nprint(\"Script name: \" + args[0]);     // \"script.hml\"\nprint(\"Total args: \" + typeof(args.length));  // \"4\"\nprint(\"First arg: \" + args[1]);       // \"hello\"\nprint(\"Second arg: \" + args[2]);      // \"world\"\nprint(\"Third arg: \" + args[3]);       // \"test 123\"\n```\n\n### Referncia de ndices\n\n| ndice | Contm | Valor de Exemplo |\n|--------|--------|------------------|\n| `args[0]` | Caminho/nome do script | `\"script.hml\"` ou `\"./script.hml\"` |\n| `args[1]` | Primeiro argumento | `\"hello\"` |\n| `args[2]` | Segundo argumento | `\"world\"` |\n| `args[3]` | Terceiro argumento | `\"test 123\"` |\n| ... | ... | ... |\n| `args[n-1]` | ltimo argumento | (varia) |\n\n## Propriedades\n\n### Sempre Presente\n\n`args`  um array global disponvel em **todos** os programas Hemlock:\n\n```hemlock\n// No precisa declarar ou importar\nprint(args.length);  // Disponvel imediatamente\n```\n\n### Inclui Nome do Script\n\n`args[0]` sempre contm o caminho/nome do script:\n\n```hemlock\nprint(\"Running: \" + args[0]);\n```\n\n**Valores possveis para args[0]:**\n- `\"script.hml\"` - apenas nome do arquivo\n- `\"./script.hml\"` - caminho relativo\n- `\"/home/user/script.hml\"` - caminho absoluto\n- Depende de como o script foi invocado\n\n### Tipo: Array de Strings\n\nTodos os argumentos so armazenados como strings:\n\n```hemlock\n// Argumentos: ./hemlock script.hml 42 3.14 true\n\nprint(args[1]);  // \"42\" (string, no nmero)\nprint(args[2]);  // \"3.14\" (string, no nmero)\nprint(args[3]);  // \"true\" (string, no booleano)\n\n// Converter conforme necessrio:\nlet num = 42;  // Parsear manualmente se necessrio\n```\n\n### Comprimento Mnimo\n\nSempre pelo menos 1 (o nome do script):\n\n```hemlock\nprint(args.length);  // Mnimo: 1\n```\n\n**Mesmo sem argumentos:**\n```bash\n./hemlock script.hml\n```\n\n```hemlock\n// Em script.hml:\nprint(args.length);  // 1 (apenas nome do script)\n```\n\n### Comportamento no REPL\n\nNo REPL, `args.length`  0 (array vazio):\n\n```hemlock\n# Sesso REPL\n> print(args.length);\n0\n```\n\n## Padres de Iterao\n\n### Iterao Bsica\n\nPular `args[0]` (nome do script) e processar argumentos reais:\n\n```hemlock\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument \" + typeof(i) + \": \" + args[i]);\n    i = i + 1;\n}\n```\n\n**Sada para `./hemlock script.hml foo bar baz`:**\n```\nArgument 1: foo\nArgument 2: bar\nArgument 3: baz\n```\n\n### Iterao For-In (Inclui Nome do Script)\n\n```hemlock\nfor (let arg in args) {\n    print(arg);\n}\n```\n\n**Sada:**\n```\nscript.hml\nfoo\nbar\nbaz\n```\n\n### Verificar Nmero de Argumentos\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <argument>\");\n    // Sair ou retornar\n} else {\n    let arg = args[1];\n    // Processar arg\n}\n```\n\n### Processar Todos Exceto Nome do Script\n\n```hemlock\nlet actual_args = args.slice(1, args.length);\n\nfor (let arg in actual_args) {\n    print(\"Processing: \" + arg);\n}\n```\n\n## Casos de Uso Comuns\n\n### 1. Processamento Simples de Argumentos\n\nVerificar argumento obrigatrio:\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    print(\"Processing file: \" + filename);\n    // ... processar arquivo\n}\n```\n\n**Uso:**\n```bash\n./hemlock script.hml data.txt\n# Sada: Processing file: data.txt\n```\n\n### 2. Mltiplos Argumentos\n\n```hemlock\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <input> <output>\");\n} else {\n    let input_file = args[1];\n    let output_file = args[2];\n\n    print(\"Input: \" + input_file);\n    print(\"Output: \" + output_file);\n\n    // Processar arquivos...\n}\n```\n\n**Uso:**\n```bash\n./hemlock convert.hml input.txt output.txt\n```\n\n### 3. Nmero Varivel de Argumentos\n\nProcessar todos os argumentos fornecidos:\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        print(\"  \" + args[i]);\n        process_file(args[i]);\n        i = i + 1;\n    }\n}\n```\n\n**Uso:**\n```bash\n./hemlock batch.hml file1.txt file2.txt file3.txt\n```\n\n### 4. Mensagem de Ajuda\n\n```hemlock\nif (args.length < 2 || args[1] == \"--help\" || args[1] == \"-h\") {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show this help message\");\n    print(\"  -v, --verbose  Enable verbose output\");\n} else {\n    // Processamento normal\n}\n```\n\n### 5. Validao de Argumentos\n\n```hemlock\nfn validate_file(filename: string): bool {\n    // Verificar se arquivo existe (exemplo)\n    return filename != \"\";\n}\n\nif (args.length < 2) {\n    print(\"Error: No filename provided\");\n} else if (!validate_file(args[1])) {\n    print(\"Error: Invalid file: \" + args[1]);\n} else {\n    print(\"Processing: \" + args[1]);\n}\n```\n\n## Padres de Parse de Argumentos\n\n### Argumentos Nomeados (Flags)\n\nPadro simples para argumentos nomeados:\n\n```hemlock\nlet verbose = false;\nlet output_file = \"\";\nlet input_file = \"\";\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\" || args[i] == \"-v\") {\n        verbose = true;\n    } else if (args[i] == \"--output\" || args[i] == \"-o\") {\n        i = i + 1;\n        if (i < args.length) {\n            output_file = args[i];\n        }\n    } else {\n        input_file = args[i];\n    }\n    i = i + 1;\n}\n\nif (verbose) {\n    print(\"Verbose mode enabled\");\n}\nprint(\"Input: \" + input_file);\nprint(\"Output: \" + output_file);\n```\n\n**Uso:**\n```bash\n./hemlock script.hml --verbose --output out.txt input.txt\n./hemlock script.hml -v -o out.txt input.txt\n```\n\n### Flags Booleanas\n\n```hemlock\nlet debug = false;\nlet verbose = false;\nlet force = false;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--debug\") {\n        debug = true;\n    } else if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else if (args[i] == \"--force\") {\n        force = true;\n    }\n    i = i + 1;\n}\n```\n\n### Argumentos com Valor\n\n```hemlock\nlet config_file = \"default.conf\";\nlet port = 8080;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--config\") {\n        i = i + 1;\n        if (i < args.length) {\n            config_file = args[i];\n        }\n    } else if (args[i] == \"--port\") {\n        i = i + 1;\n        if (i < args.length) {\n            port = 8080;  // Precisa parsear string para inteiro\n        }\n    }\n    i = i + 1;\n}\n```\n\n### Misturando Posicionais e Nomeados\n\n```hemlock\nlet input_file = \"\";\nlet output_file = \"\";\nlet verbose = false;\n\nlet i = 1;\nlet positional = [];\n\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else {\n        // Tratar como argumento posicional\n        positional.push(args[i]);\n    }\n    i = i + 1;\n}\n\n// Atribuir argumentos posicionais\nif (positional.length > 0) {\n    input_file = positional[0];\n}\nif (positional.length > 1) {\n    output_file = positional[1];\n}\n```\n\n### Funo Auxiliar de Parser de Argumentos\n\n```hemlock\nfn parse_args() {\n    let options = {\n        verbose: false,\n        output: \"\",\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            options.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                options.output = args[i];\n            }\n        } else {\n            // Argumento posicional\n            options.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return options;\n}\n\nlet opts = parse_args();\nprint(\"Verbose: \" + typeof(opts.verbose));\nprint(\"Output: \" + opts.output);\nprint(\"Files: \" + typeof(opts.files.length));\n```\n\n## Melhores Prticas\n\n### 1. Sempre Verifique Nmero de Argumentos\n\n```hemlock\n// Boa prtica\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file>\");\n} else {\n    process_file(args[1]);\n}\n\n// M prtica - pode crashar se no houver argumentos\nprocess_file(args[1]);  // Erro se args.length == 1\n```\n\n### 2. Fornea Informao de Uso\n\n```hemlock\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show help\");\n    print(\"  -v, --verbose  Verbose output\");\n}\n\nif (args.length < 2) {\n    show_usage();\n}\n```\n\n### 3. Valide Argumentos\n\n```hemlock\nfn validate_args() {\n    if (args.length < 2) {\n        print(\"Error: Missing required argument\");\n        return false;\n    }\n\n    if (args[1] == \"\") {\n        print(\"Error: Empty argument\");\n        return false;\n    }\n\n    return true;\n}\n\nif (!validate_args()) {\n    // Sair ou mostrar uso\n}\n```\n\n### 4. Use Nomes de Variveis Descritivos\n\n```hemlock\n// Bom\nlet input_filename = args[1];\nlet output_filename = args[2];\nlet max_iterations = args[3];\n\n// Ruim\nlet a = args[1];\nlet b = args[2];\nlet c = args[3];\n```\n\n### 5. Trate Argumentos com Aspas e Espaos\n\nO shell trata isso automaticamente:\n\n```bash\n./hemlock script.hml \"file with spaces.txt\"\n```\n\n```hemlock\nprint(args[1]);  // \"file with spaces.txt\"\n```\n\n### 6. Crie Objeto de Argumentos\n\n```hemlock\nfn get_args() {\n    return {\n        script: args[0],\n        input: args[1],\n        output: args[2]\n    };\n}\n\nlet arguments = get_args();\nprint(\"Input: \" + arguments.input);\n```\n\n## Exemplos Completos\n\n### Exemplo 1: Processador de Arquivos\n\n```hemlock\n// Uso: ./hemlock process.hml <input> <output>\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <input_file> <output_file>\");\n}\n\nif (args.length < 3) {\n    show_usage();\n} else {\n    let input = args[1];\n    let output = args[2];\n\n    print(\"Processing \" + input + \" -> \" + output);\n\n    // Processar arquivo\n    let f_in = open(input, \"r\");\n    let f_out = open(output, \"w\");\n\n    try {\n        let content = f_in.read();\n        let processed = content.to_upper();  // Processamento de exemplo\n        f_out.write(processed);\n\n        print(\"Done!\");\n    } finally {\n        f_in.close();\n        f_out.close();\n    }\n}\n```\n\n### Exemplo 2: Processador de Arquivos em Lote\n\n```hemlock\n// Uso: ./hemlock batch.hml <file1> <file2> <file3> ...\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        let filename = args[i];\n        print(\"  Processing: \" + filename);\n\n        try {\n            let f = open(filename, \"r\");\n            let content = f.read();\n            f.close();\n\n            // Processar contedo...\n            print(\"    \" + typeof(content.length) + \" bytes\");\n        } catch (e) {\n            print(\"    Error: \" + e);\n        }\n\n        i = i + 1;\n    }\n\n    print(\"Done!\");\n}\n```\n\n### Exemplo 3: Parser de Argumentos Avanado\n\n```hemlock\n// Uso: ./hemlock app.hml [OPTIONS] <files...>\n// Opes:\n//   --verbose, -v     Habilitar sada detalhada\n//   --output, -o FILE Definir arquivo de sada\n//   --help, -h        Mostrar ajuda\n\nfn parse_arguments() {\n    let config = {\n        verbose: false,\n        output: \"output.txt\",\n        help: false,\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            config.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                config.output = args[i];\n            } else {\n                print(\"Error: --output requires a value\");\n            }\n        } else if (arg == \"--help\" || arg == \"-h\") {\n            config.help = true;\n        } else if (arg.starts_with(\"--\")) {\n            print(\"Error: Unknown option: \" + arg);\n        } else {\n            config.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return config;\n}\n\nfn show_help() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <files...>\");\n    print(\"Options:\");\n    print(\"  --verbose, -v     Enable verbose output\");\n    print(\"  --output, -o FILE Set output file\");\n    print(\"  --help, -h        Show this help\");\n}\n\nlet config = parse_arguments();\n\nif (config.help) {\n    show_help();\n} else if (config.files.length == 0) {\n    print(\"Error: No input files specified\");\n    show_help();\n} else {\n    if (config.verbose) {\n        print(\"Verbose mode enabled\");\n        print(\"Output file: \" + config.output);\n        print(\"Input files: \" + typeof(config.files.length));\n    }\n\n    // Processar arquivos\n    for (let file in config.files) {\n        if (config.verbose) {\n            print(\"Processing: \" + file);\n        }\n        // ... processar arquivo\n    }\n}\n```\n\n### Exemplo 4: Ferramenta de Configurao\n\n```hemlock\n// Uso: ./hemlock config.hml <action> [arguments]\n// Aes:\n//   get <key>\n//   set <key> <value>\n//   list\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <action> [arguments]\");\n    print(\"Actions:\");\n    print(\"  get <key>         Get configuration value\");\n    print(\"  set <key> <value> Set configuration value\");\n    print(\"  list              List all configuration\");\n}\n\nif (args.length < 2) {\n    show_usage();\n} else {\n    let action = args[1];\n\n    if (action == \"get\") {\n        if (args.length < 3) {\n            print(\"Error: 'get' requires a key\");\n        } else {\n            let key = args[2];\n            print(\"Getting: \" + key);\n            // ... obter da configurao\n        }\n    } else if (action == \"set\") {\n        if (args.length < 4) {\n            print(\"Error: 'set' requires key and value\");\n        } else {\n            let key = args[2];\n            let value = args[3];\n            print(\"Setting \" + key + \" = \" + value);\n            // ... definir configurao\n        }\n    } else if (action == \"list\") {\n        print(\"Listing all configuration:\");\n        // ... listar configurao\n    } else {\n        print(\"Error: Unknown action: \" + action);\n        show_usage();\n    }\n}\n```\n\n## Resumo\n\nO suporte a argumentos de linha de comando do Hemlock oferece:\n\n- Array `args` integrado globalmente disponvel\n- Acesso simples baseado em array\n- Nome do script em `args[0]`\n- Todos os argumentos so strings\n- Mtodos de array disponveis (.length, .slice, etc.)\n\nLembre-se:\n- Sempre verifique `args.length` antes de acessar elementos\n- `args[0]`  o nome do script\n- Argumentos reais comeam em `args[1]`\n- Todos os argumentos so strings - converta conforme necessrio\n- Fornea informao de uso para ferramentas amigveis ao usurio\n- Valide argumentos antes de processar\n\nPadres comuns:\n- Argumentos posicionais simples\n- Argumentos nomeados/flags (--flag)\n- Argumentos com valor (--option value)\n- Informao de ajuda (--help)\n- Validao de argumentos\n"}, "Tpicos Avanados -> Assincronismo e Concorrncia": {"id": "advanced-async-concurrency", "content": "# Hemlock Assincronismo e Concorrncia\n\nHemlock oferece **concorrncia estruturada**, com suporte a sintaxe async/await, criao de tarefas e comunicao por canais. A implementao  baseada em threads POSIX (pthreads), proporcionando **verdadeiro paralelismo multi-thread**.\n\n## ndice\n\n- [Viso Geral](#viso-geral)\n- [Modelo de Threads](#modelo-de-threads)\n- [Funes Assncronas](#funes-assncronas)\n- [Criao de Tarefas](#criao-de-tarefas)\n- [Canais](#canais)\n- [Propagao de Excees](#propagao-de-excees)\n- [Detalhes de Implementao](#detalhes-de-implementao)\n- [Melhores Prticas](#melhores-prticas)\n- [Caractersticas de Desempenho](#caractersticas-de-desempenho)\n- [Limitaes Atuais](#limitaes-atuais)\n\n## Viso Geral\n\n**Isso significa:**\n- Threads reais do sistema operacional - cada tarefa criada executa em seu prprio pthread (thread POSIX)\n- Paralelismo real - tarefas executam simultaneamente em mltiplos ncleos de CPU\n- Escalonamento do kernel - o escalonador do SO distribui tarefas entre os ncleos disponveis\n- Canais thread-safe - sincronizao usando mutexes e variveis de condio pthread\n\n**Isso no :**\n- No so green threads - no  multitarefa cooperativa em espao de usurio\n- No so coroutines async/await - no  um event loop single-thread como JavaScript/Python asyncio\n- No  concorrncia simulada - no  paralelismo simulado\n\nIsso  o **mesmo modelo de threads** que **C, C++ e Rust** usam com threads do SO. Voc obtm execuo paralela real em mltiplos ncleos.\n\n## Modelo de Threads\n\n### Modelo de Threads 1:1\n\nHemlock usa um **modelo de threads 1:1**, onde:\n- Cada tarefa criada gera uma thread dedicada do SO via `pthread_create()`\n- O kernel do SO escalona threads entre os ncleos de CPU disponveis\n- Multitarefa preemptiva - o SO pode interromper e alternar entre threads\n- **Sem GIL** - diferente de Python, no h Global Interpreter Lock limitando o paralelismo\n\n### Mecanismos de Sincronizao\n\n- **Mutexes** - canais usam `pthread_mutex_t` para acesso thread-safe\n- **Variveis de Condio** - send/recv bloqueantes usam `pthread_cond_t` para espera eficiente\n- **Operaes Lock-free** - transies de estado de tarefas so atmicas\n\n## Funes Assncronas\n\nFunes podem ser declaradas como `async`, indicando que foram projetadas para execuo concorrente:\n\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n```\n\n### Pontos Importantes\n\n- `async fn` declara uma funo assncrona\n- Funes assncronas podem ser criadas como tarefas concorrentes usando `spawn()`\n- Funes assncronas tambm podem ser chamadas diretamente (executando sincronamente na thread atual)\n- Quando criadas, cada tarefa executa em **sua prpria thread do SO** (no so coroutines!)\n- A palavra-chave `await` est reservada para uso futuro\n\n### Exemplo: Chamada Direta vs Criao de Tarefa\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Chamada direta - executa sincronamente\nlet result1 = factorial(5);  // 120\n\n// Criar tarefa - executa em thread separada\nlet task = spawn(factorial, 5);\nlet result2 = join(task);  // 120\n```\n\n## Criao de Tarefas\n\nUse `spawn()` para executar funes assncronas **em paralelo em threads separadas do SO**:\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Criar mltiplas tarefas - estas executam em paralelo em diferentes ncleos de CPU!\nlet t1 = spawn(factorial, 5);  // Thread 1\nlet t2 = spawn(factorial, 6);  // Thread 2\nlet t3 = spawn(factorial, 7);  // Thread 3\n\n// As trs tarefas esto computando simultaneamente agora!\n\n// Aguardar resultados\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\n```\n\n### Funes Integradas\n\n#### spawn(async_fn, arg1, arg2, ...)\n\nCria uma nova tarefa em um novo pthread, retorna um handle de tarefa.\n\n**Parmetros:**\n- `async_fn` - a funo assncrona a executar\n- `arg1, arg2, ...` - argumentos a passar para a funo\n\n**Retorna:** Handle de tarefa (valor opaco para uso com `join()` ou `detach()`)\n\n**Exemplo:**\n```hemlock\nasync fn process(data: string, count: i32): i32 {\n    // ... lgica de processamento\n    return count * 2;\n}\n\nlet task = spawn(process, \"test\", 42);\n```\n\n#### join(task)\n\nAguarda a tarefa completar (bloqueia at a thread terminar), retorna o resultado.\n\n**Parmetros:**\n- `task` - handle de tarefa retornado por `spawn()`\n\n**Retorna:** O valor retornado pela funo assncrona\n\n**Exemplo:**\n```hemlock\nlet task = spawn(compute, 1000);\nlet result = join(task);  // Bloqueia at compute() terminar\nprint(result);\n```\n\n**Importante:** Cada tarefa s pode ser joined uma vez. Joins subsequentes resultaro em erro.\n\n#### detach(task)\n\nExecuo fire-and-forget (a thread executa independentemente, join no  permitido).\n\n**Parmetros:**\n- `task` - handle de tarefa retornado por `spawn()`\n\n**Retorna:** `null`\n\n**Exemplo:**\n```hemlock\nasync fn background_work() {\n    // Tarefa de longa durao em background\n    // ...\n}\n\nlet task = spawn(background_work);\ndetach(task);  // Tarefa executa independentemente, no pode ser joined\n```\n\n**Importante:** Tarefas detached no podem ser joined. Quando a tarefa completa, tanto o pthread quanto a estrutura Task so automaticamente limpos.\n\n## Canais\n\nCanais fornecem comunicao thread-safe entre tarefas usando buffers limitados e semntica bloqueante.\n\n### Criando Canais\n\n```hemlock\nlet ch = channel(10);  // Cria canal com buffer de tamanho 10\n```\n\n**Parmetros:**\n- `capacity` (i32) - nmero mximo de valores que o canal pode armazenar\n\n**Retorna:** Objeto canal\n\n### Mtodos de Canal\n\n#### send(value)\n\nEnvia valor para o canal (bloqueia se estiver cheio).\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet task = spawn(producer, ch, 5);\n```\n\n**Comportamento:**\n- Se o canal tem espao, o valor  adicionado imediatamente\n- Se o canal est cheio, o emissor bloqueia at haver espao disponvel\n- Se o canal est fechado, lana uma exceo\n\n#### recv()\n\nRecebe valor do canal (bloqueia se estiver vazio).\n\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet task = spawn(consumer, ch, 5);\n```\n\n**Comportamento:**\n- Se o canal tem valores, retorna o prximo valor imediatamente\n- Se o canal est vazio, o receptor bloqueia at um valor estar disponvel\n- Se o canal est fechado e vazio, retorna `null`\n\n#### close()\n\nFecha o canal (recv em canal fechado retorna null).\n\n```hemlock\nch.close();\n```\n\n**Comportamento:**\n- Impede operaes `send()` futuras (lanar exceo)\n- Permite operaes `recv()` pendentes completarem\n- Uma vez vazio, `recv()` retorna `null`\n\n### Multiplexao com select()\n\nA funo `select()` permite esperar em mltiplos canais simultaneamente, retornando quando qualquer canal tiver dados disponveis.\n\n**Assinatura:**\n```hemlock\nselect(channels: array, timeout_ms?: i32): object | null\n```\n\n**Parmetros:**\n- `channels` - array de valores de canal\n- `timeout_ms` (opcional) - timeout em milissegundos (-1 ou omitido para espera infinita)\n\n**Retorna:**\n- `{ channel, value }` - objeto contendo o canal que tinha dados e o valor recebido\n- `null` - em timeout (se timeout foi especificado)\n\n**Exemplo:**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// Tarefas produtoras\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"from channel 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"from channel 2\");\n});\n\n// Espera pelo primeiro resultado (ch2 deve ser mais rpido)\nlet result = select([ch1, ch2]);\nprint(result.value);  // \"from channel 2\"\n\n// Espera pelo segundo resultado\nlet result2 = select([ch1, ch2]);\nprint(result2.value);  // \"from channel 1\"\n```\n\n**Com Timeout:**\n```hemlock\nlet ch = channel(1);\n\n// Sem emissor, vai ter timeout\nlet result = select([ch], 100);  // timeout de 100ms\nif (result == null) {\n    print(\"Timed out!\");\n}\n```\n\n**Casos de Uso:**\n- Esperar pelo mais rpido entre mltiplas fontes de dados\n- Implementar timeouts em operaes de canal\n- Padres de event loop com mltiplas fontes de eventos\n- Fan-in: combinar mltiplos canais em um\n\n**Padro Fan-in:**\n```hemlock\nfn fan_in(channels: array, output: channel) {\n    while (true) {\n        let result = select(channels);\n        if (result == null) {\n            break;  // Todos os canais fechados\n        }\n        output.send(result.value);\n    }\n    output.close();\n}\n```\n\n### Exemplo Completo Produtor-Consumidor\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Criar canal com tamanho de buffer\nlet ch = channel(10);\n\n// Criar produtor e consumidor\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Esperar completar\njoin(p);\nlet total = join(c);  // 100 (0+10+20+30+40)\nprint(total);\n```\n\n### Mltiplos Produtores, Mltiplos Consumidores\n\nCanais podem ser compartilhados com segurana entre mltiplos produtores e consumidores:\n\n```hemlock\nasync fn producer(id: i32, ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(id * 100 + i);\n        i = i + 1;\n    }\n}\n\nasync fn consumer(id: i32, ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(20);\n\n// Mltiplos produtores\nlet p1 = spawn(producer, 1, ch, 5);\nlet p2 = spawn(producer, 2, ch, 5);\n\n// Mltiplos consumidores\nlet c1 = spawn(consumer, 1, ch, 5);\nlet c2 = spawn(consumer, 2, ch, 5);\n\n// Esperar todos\njoin(p1);\njoin(p2);\nlet sum1 = join(c1);\nlet sum2 = join(c2);\nprint(sum1 + sum2);\n```\n\n## Propagao de Excees\n\nExcees lanadas em tarefas criadas so propagadas no join:\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Caught: \" + e);  // \"Caught: Task failed!\"\n}\n```\n\n### Padres de Tratamento de Excees\n\n**Padro 1: Tratar na Tarefa**\n```hemlock\nasync fn safe_task() {\n    try {\n        // Operao arriscada\n    } catch (e) {\n        print(\"Error in task: \" + e);\n        return null;\n    }\n}\n\nlet task = spawn(safe_task);\njoin(task);  // Sem propagao de exceo\n```\n\n**Padro 2: Propagar ao Chamador**\n```hemlock\nasync fn task_that_throws() {\n    throw \"error\";\n}\n\nlet task = spawn(task_that_throws);\ntry {\n    join(task);\n} catch (e) {\n    print(\"Caught from task: \" + e);\n}\n```\n\n**Padro 3: Tarefas Detached com Excees**\n```hemlock\nasync fn detached_task() {\n    try {\n        // Trabalho\n    } catch (e) {\n        // Deve tratar internamente - no pode propagar\n        print(\"Error: \" + e);\n    }\n}\n\nlet task = spawn(detached_task);\ndetach(task);  // No  possvel capturar excees de tarefas detached\n```\n\n## Detalhes de Implementao\n\n### Arquitetura de Threads\n\n- **Threads 1:1** - cada tarefa criada gera uma thread dedicada do SO via `pthread_create()`\n- **Escalonamento do Kernel** - o kernel do SO escalona threads entre os ncleos de CPU disponveis\n- **Multitarefa Preemptiva** - o SO pode interromper e alternar entre threads\n- **Sem GIL** - diferente de Python, no h Global Interpreter Lock limitando o paralelismo\n\n### Implementao de Canais\n\nCanais usam um buffer circular com sincronizao pthread:\n\n```\nEstrutura do Canal:\n- buffer[] - array de Values de tamanho fixo\n- capacity - nmero mximo de elementos\n- size - nmero atual de elementos\n- head - posio de leitura\n- tail - posio de escrita\n- mutex - pthread_mutex_t para acesso thread-safe\n- not_empty - pthread_cond_t para recv bloqueante\n- not_full - pthread_cond_t para send bloqueante\n- closed - flag booleana\n- refcount - contagem de referncias para limpeza\n```\n\n**Comportamento Bloqueante:**\n- `send()` em canal cheio: espera na varivel de condio `not_full`\n- `recv()` em canal vazio: espera na varivel de condio `not_empty`\n- Ambas so sinalizadas pela operao oposta quando apropriado\n\n### Memria e Limpeza\n\n- **Tarefas Joined:** Limpas automaticamente aps `join()` retornar\n- **Tarefas Detached:** Limpas automaticamente quando a tarefa completa\n- **Canais:** Contagem de referncias, liberados quando no mais em uso\n\n## Melhores Prticas\n\n### 1. Sempre Feche Canais\n\n```hemlock\nasync fn producer(ch) {\n    // ... enviar valores\n    ch.close();  // Importante: sinaliza que no h mais valores\n}\n```\n\n### 2. Use Concorrncia Estruturada\n\nCrie tarefas e as faa join no mesmo escopo:\n\n```hemlock\nfn process_data(data) {\n    // Criar tarefas\n    let t1 = spawn(worker, data);\n    let t2 = spawn(worker, data);\n\n    // Sempre join antes de retornar\n    let r1 = join(t1);\n    let r2 = join(t2);\n\n    return r1 + r2;\n}\n```\n\n### 3. Trate Excees Apropriadamente\n\n```hemlock\nasync fn task() {\n    try {\n        // Operao arriscada\n    } catch (e) {\n        // Registrar erro\n        throw e;  // Re-lanar se o chamador precisa saber\n    }\n}\n```\n\n### 4. Use Capacidade de Canal Apropriada\n\n- **Capacidade pequena (1-10):** Para coordenao/sinalizao\n- **Capacidade mdia (10-100):** Para produtor-consumidor geral\n- **Capacidade grande (100+):** Para cenrios de alto throughput\n\n```hemlock\nlet signal_ch = channel(1);      // Coordenao\nlet work_ch = channel(50);       // Fila de trabalho\nlet buffer_ch = channel(1000);   // Alto throughput\n```\n\n### 5. Detach Apenas Quando Necessrio\n\nPrefira `join()` sobre `detach()` para melhor gerenciamento de recursos:\n\n```hemlock\n// Bom: Join e obter resultado\nlet task = spawn(work);\nlet result = join(task);\n\n// Use detach apenas para fire-and-forget real\nlet bg_task = spawn(background_logging);\ndetach(bg_task);  // Executar independentemente\n```\n\n## Caractersticas de Desempenho\n\n### Paralelismo Real\n\n- **N tarefas criadas podem utilizar N ncleos de CPU simultaneamente**\n- Speedup comprovado - testes de stress mostram tempo de CPU vs tempo de relgio de 8-9x (trabalho multi-core)\n- Escala linearmente com nmero de ncleos (at o nmero de threads)\n\n### Overhead de Threads\n\n- Cada tarefa tem ~8KB de stack + overhead de pthread\n- Custo de criao de thread: ~10-20 microssegundos\n- Custo de troca de contexto: ~1-5 microssegundos\n\n### Quando Usar Async\n\n**Bons casos de uso:**\n- Computaes CPU-intensivas paralelizveis\n- Operaes I/O-bound (embora I/O ainda seja bloqueante)\n- Processamento concorrente de dados independentes\n- Arquitetura de pipeline usando canais\n\n**No ideal para:**\n- Tarefas muito curtas (overhead de thread domina)\n- Tarefas com muita sincronizao (overhead de conteno)\n- Sistemas single-core (sem ganho de paralelismo)\n\n### I/O Bloqueante Seguro\n\nOperaes bloqueantes em uma tarefa no bloqueiam outras tarefas:\n\n```hemlock\nasync fn reader(filename: string) {\n    let f = open(filename, \"r\");  // Bloqueia apenas esta thread\n    let content = f.read();       // Bloqueia apenas esta thread\n    f.close();\n    return content;\n}\n\n// Ambas leem concorrentemente (em threads diferentes)\nlet t1 = spawn(reader, \"file1.txt\");\nlet t2 = spawn(reader, \"file2.txt\");\n\nlet c1 = join(t1);\nlet c2 = join(t2);\n```\n\n## Modelo de Segurana de Threads\n\nHemlock usa um modelo de concorrncia **passagem de mensagens**, onde tarefas se comunicam atravs de canais ao invs de estado mutvel compartilhado.\n\n### Isolamento de Argumentos\n\nQuando voc cria uma tarefa, **argumentos so copiados profundamente** para prevenir condies de corrida:\n\n```hemlock\nasync fn modify_array(arr: array): array {\n    arr.push(999);    // Modifica a cpia, no o original\n    arr[0] = -1;\n    return arr;\n}\n\nlet original = [1, 2, 3];\nlet task = spawn(modify_array, original);\nlet modified = join(task);\n\nprint(original.length);  // 3 - no modificado!\nprint(modified.length);  // 4 - tem novo elemento\n```\n\n**O que  copiado profundamente:**\n- Arrays (e todos os elementos recursivamente)\n- Objetos (e todos os campos recursivamente)\n- Strings\n- Buffers\n\n**O que  compartilhado (mantm referncia):**\n- Canais (mecanismo de comunicao - compartilhado intencionalmente)\n- Handles de tarefa (para coordenao)\n- Funes (cdigo  imutvel)\n- Handles de arquivo (SO gerencia acesso concorrente)\n- Handles de socket (SO gerencia acesso concorrente)\n\n**O que no pode ser passado:**\n- Ponteiros brutos (`ptr`) - use `buffer` em vez disso\n\n### Por Que Passagem de Mensagens?\n\nIsso segue a filosofia do Hemlock de \"explcito  melhor que implcito\":\n\n```hemlock\n// Ruim: Estado mutvel compartilhado (causaria corrida de dados)\nlet counter = { value: 0 };\nlet t1 = spawn(fn() { counter.value = counter.value + 1; });  // Corrida!\nlet t2 = spawn(fn() { counter.value = counter.value + 1; });  // Corrida!\n\n// Bom: Passagem de mensagens atravs de canais\nasync fn increment(ch) {\n    let val = ch.recv();\n    ch.send(val + 1);\n}\n\nlet ch = channel(1);\nch.send(0);\nlet t1 = spawn(increment, ch);\njoin(t1);\nlet result = ch.recv();  // 1 - sem condio de corrida\n```\n\n### Segurana de Thread na Contagem de Referncias\n\nTodas as operaes de contagem de referncias usam **operaes atmicas** para prevenir erros use-after-free:\n- `string_retain/release` - atmico\n- `array_retain/release` - atmico\n- `object_retain/release` - atmico\n- `buffer_retain/release` - atmico\n- `function_retain/release` - atmico\n- `channel_retain/release` - atmico\n- `task_retain/release` - atmico\n\nIsso garante gerenciamento de memria seguro mesmo quando valores so compartilhados entre threads.\n\n### Acesso ao Ambiente de Closure\n\nTarefas podem acessar o ambiente de closure:\n- Funes integradas (`print`, `len`, etc.)\n- Definies de funes globais\n- Constantes e variveis\n\nO ambiente de closure  protegido por um mutex por ambiente, tornando leituras e escritas concorrentes thread-safe:\n\n```hemlock\nlet x = 10;\n\nasync fn read_closure(): i32 {\n    return x;  // OK: lendo varivel de closure (thread-safe)\n}\n\nasync fn modify_closure() {\n    x = 20;  // OK: escrevendo varivel de closure (sincronizado com mutex)\n}\n```\n\n**Nota:** Embora o acesso concorrente seja sincronizado, modificar estado compartilhado de mltiplas tarefas ainda pode levar a condies de corrida lgicas (ordem no-determinstica). Para comportamento previsvel, use canais para comunicao entre tarefas ou use valores de retorno de tarefas.\n\nSe voc precisa retornar dados de tarefas, use valores de retorno ou canais.\n\n## Limitaes Atuais\n\n### 1. Sem Escalonador Work-Stealing\n\nCada tarefa usa 1 thread, o que pode ser ineficiente para muitas tarefas curtas.\n\n**Atual:** 1000 tarefas = 1000 threads (muito overhead)\n\n**Planejado:** Pool de threads com work-stealing para eficincia\n\n### 3. Sem Integrao de I/O Assncrono\n\nOperaes de arquivo/rede ainda bloqueiam a thread:\n\n```hemlock\nasync fn read_file(path: string) {\n    let f = open(path, \"r\");\n    let content = f.read();  // Bloqueia a thread\n    f.close();\n    return content;\n}\n```\n\n**Workaround:** Use mltiplas threads para operaes I/O concorrentes\n\n### 4. Capacidade de Canal Fixa\n\nA capacidade do canal  definida na criao e no pode ser redimensionada:\n\n```hemlock\nlet ch = channel(10);\n// No  possvel redimensionar dinamicamente para 20\n```\n\n### 5. Tamanho de Canal Fixo\n\nO tamanho do buffer do canal no pode ser alterado aps a criao.\n\n## Padres Comuns\n\n### Map Paralelo\n\n```hemlock\nasync fn map_worker(ch_in, ch_out, fn_transform) {\n    while (true) {\n        let val = ch_in.recv();\n        if (val == null) { break; }\n\n        let result = fn_transform(val);\n        ch_out.send(result);\n    }\n    ch_out.close();\n}\n\nfn parallel_map(data, fn_transform, workers: i32) {\n    let ch_in = channel(100);\n    let ch_out = channel(100);\n\n    // Criar workers\n    let tasks = [];\n    let i = 0;\n    while (i < workers) {\n        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));\n        i = i + 1;\n    }\n\n    // Enviar dados\n    let i = 0;\n    while (i < data.length) {\n        ch_in.send(data[i]);\n        i = i + 1;\n    }\n    ch_in.close();\n\n    // Coletar resultados\n    let results = [];\n    let i = 0;\n    while (i < data.length) {\n        results.push(ch_out.recv());\n        i = i + 1;\n    }\n\n    // Esperar workers\n    let i = 0;\n    while (i < tasks.length) {\n        join(tasks[i]);\n        i = i + 1;\n    }\n\n    return results;\n}\n```\n\n### Arquitetura de Pipeline\n\n```hemlock\nasync fn stage1(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val * 2);\n    }\n    output_ch.close();\n}\n\nasync fn stage2(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val + 10);\n    }\n    output_ch.close();\n}\n\n// Criar pipeline\nlet ch1 = channel(10);\nlet ch2 = channel(10);\nlet ch3 = channel(10);\n\nlet s1 = spawn(stage1, ch1, ch2);\nlet s2 = spawn(stage2, ch2, ch3);\n\n// Entrada de dados\nch1.send(1);\nch1.send(2);\nch1.send(3);\nch1.close();\n\n// Coletar sada\nprint(ch3.recv());  // 12 (1 * 2 + 10)\nprint(ch3.recv());  // 14 (2 * 2 + 10)\nprint(ch3.recv());  // 16 (3 * 2 + 10)\n\njoin(s1);\njoin(s2);\n```\n\n### Fan-out, Fan-in\n\n```hemlock\nasync fn worker(id: i32, input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n\n        // Processar valor\n        let result = val * id;\n        output_ch.send(result);\n    }\n}\n\nlet input = channel(10);\nlet output = channel(10);\n\n// Fan-out: mltiplos workers\nlet workers = 4;\nlet tasks = [];\nlet i = 0;\nwhile (i < workers) {\n    tasks.push(spawn(worker, i, input, output));\n    i = i + 1;\n}\n\n// Enviar trabalho\nlet i = 0;\nwhile (i < 10) {\n    input.send(i);\n    i = i + 1;\n}\ninput.close();\n\n// Fan-in: coletar todos os resultados\nlet results = [];\nlet i = 0;\nwhile (i < 10) {\n    results.push(output.recv());\n    i = i + 1;\n}\n\n// Esperar todos os workers\nlet i = 0;\nwhile (i < tasks.length) {\n    join(tasks[i]);\n    i = i + 1;\n}\n```\n\n## Resumo\n\nO modelo de assincronismo/concorrncia do Hemlock oferece:\n\n- Paralelismo multi-thread real usando threads do SO\n- Primitivas simples de concorrncia estruturada\n- Comunicao thread-safe via canais\n- Propagao de excees entre tarefas\n- Desempenho comprovado em sistemas multi-core\n- **Isolamento de argumentos** - cpia profunda previne corridas de dados\n- **Contagem de referncias atmica** - gerenciamento de memria seguro entre threads\n\nIsso torna Hemlock adequado para:\n- Computao paralela\n- Operaes I/O concorrentes\n- Arquiteturas de pipeline\n- Padres produtor-consumidor\n\nEnquanto evita as complexidades de:\n- Gerenciamento manual de threads\n- Primitivas de sincronizao de baixo nvel\n- Designs baseados em locks propensos a deadlock\n- Erros de estado mutvel compartilhado\n"}, "Tpicos Avanados -> Empacotamento e Distribuio": {"id": "advanced-bundling-packaging", "content": "# Empacotamento e Distribuio\n\nHemlock oferece ferramentas integradas para empacotar projetos multi-arquivo em um nico arquivo distribuvel e criar executveis independentes.\n\n## Viso Geral\n\n| Comando | Sada | Caso de Uso |\n|---------|-------|-------------|\n| `--bundle` | `.hmlc` ou `.hmlb` | Distribuir bytecode (requer Hemlock instalado) |\n| `--package` | executvel | Binrio independente (sem dependncias) |\n| `--compile` | `.hmlc` | Compilar arquivo nico (sem resoluo de imports) |\n\n## Empacotamento (Bundle)\n\nO empacotador resolve todas as declaraes `import` a partir do ponto de entrada e as achata em um nico arquivo.\n\n### Uso Bsico\n\n```bash\n# Empacotar app.hml e todos seus imports em app.hmlc\nhemlock --bundle app.hml\n\n# Especificar caminho de sada\nhemlock --bundle app.hml -o dist/app.hmlc\n\n# Criar pacote comprimido (.hmlb) - tamanho de arquivo menor\nhemlock --bundle app.hml --compress -o app.hmlb\n\n# Sada detalhada (mostra mdulos resolvidos)\nhemlock --bundle app.hml --verbose\n```\n\n### Formatos de Sada\n\n**`.hmlc` (no comprimido)**\n- Formato AST serializado\n- Rpido para carregar e executar\n- Formato de sada padro\n\n**`.hmlb` (comprimido)**\n- `.hmlc` comprimido com zlib\n- Tamanho de arquivo menor (tipicamente 50-70% de reduo)\n- Incio ligeiramente mais lento devido  descompresso\n\n### Executando Arquivos Empacotados\n\n```bash\n# Executar pacote no comprimido\nhemlock app.hmlc\n\n# Executar pacote comprimido\nhemlock app.hmlb\n\n# Passar argumentos\nhemlock app.hmlc arg1 arg2\n```\n\n### Exemplo: Projeto Multi-mdulo\n\n```\nmyapp/\n main.hml\n lib/\n    math.hml\n    utils.hml\n config.hml\n```\n\n```hemlock\n// main.hml\nimport { add, multiply } from \"./lib/math.hml\";\nimport { log } from \"./lib/utils.hml\";\nimport { VERSION } from \"./config.hml\";\n\nlog(`App v${VERSION}`);\nprint(add(2, 3));\n```\n\n```bash\nhemlock --bundle myapp/main.hml -o myapp.hmlc\nhemlock myapp.hmlc  # Executa com todas as dependncias empacotadas\n```\n\n### Imports de stdlib\n\nO empacotador resolve automaticamente imports `@stdlib/`:\n\n```hemlock\nimport { HashMap } from \"@stdlib/collections\";\nimport { now } from \"@stdlib/time\";\n```\n\nDurante o empacotamento, mdulos stdlib so includos na sada.\n\n## Encapsulamento (Package)\n\nO encapsulamento cria executveis independentes incorporando o bytecode empacotado em uma cpia do interpretador Hemlock.\n\n### Uso Bsico\n\n```bash\n# Criar executvel a partir de app.hml\nhemlock --package app.hml\n\n# Especificar nome de sada\nhemlock --package app.hml -o myapp\n\n# Pular compresso (incio mais rpido, arquivo maior)\nhemlock --package app.hml --no-compress\n\n# Sada detalhada\nhemlock --package app.hml --verbose\n```\n\n### Executando Executveis Encapsulados\n\n```bash\n# Executveis encapsulados rodam diretamente\n./myapp\n\n# Argumentos so passados para o script\n./myapp arg1 arg2\n```\n\n### Formato do Pacote\n\nExecutveis encapsulados usam o formato HMLP:\n\n```\n[binrio hemlock][payload HMLB/HMLC][payload_size:u64][magic HMLP:u32]\n```\n\nQuando um executvel encapsulado roda:\n1. Verifica o final do arquivo para payload incorporado\n2. Se encontrado, descomprime e executa o payload\n3. Se no encontrado, executa como interpretador Hemlock normal\n\n### Opes de Compresso\n\n| Flag | Formato | Incio | Tamanho |\n|------|---------|--------|---------|\n| (padro) | HMLB | Normal | Menor |\n| `--no-compress` | HMLC | Mais rpido | Maior |\n\nPara ferramentas CLI onde tempo de incio  importante, use `--no-compress`.\n\n## Inspecionando Pacotes\n\nUse `--info` para inspecionar arquivos compilados ou empacotados:\n\n```bash\nhemlock --info app.hmlc\n```\n\nSada:\n```\n=== File Info: app.hmlc ===\nSize: 12847 bytes\nFormat: HMLC (compiled AST)\nVersion: 1\nFlags: 0x0001 [DEBUG]\nStrings: 42\nStatements: 156\n```\n\n```bash\nhemlock --info app.hmlb\n```\n\nSada:\n```\n=== File Info: app.hmlb ===\nSize: 5234 bytes\nFormat: HMLB (compressed bundle)\nVersion: 1\nUncompressed: 12847 bytes\nCompressed: 5224 bytes\nRatio: 59.3% reduction\n```\n\n## Compilao Nativa\n\nPara executveis verdadeiramente nativos (sem interpretador), use o compilador Hemlock:\n\n```bash\n# Compilar para executvel nativo via C\nhemlockc app.hml -o app\n\n# Manter cdigo C gerado\nhemlockc app.hml -o app --keep-c\n\n# Apenas gerar C (no compilar)\nhemlockc app.hml -c -o app.c\n\n# Nveis de otimizao\nhemlockc app.hml -o app -O2\n```\n\nO compilador gera cdigo C e chama GCC para produzir um binrio nativo. Isso requer:\n- Biblioteca runtime Hemlock (`libhemlock_runtime`)\n- Compilador C (GCC por padro)\n\n### Opes do Compilador\n\n| Opo | Descrio |\n|-------|-----------|\n| `-o <file>` | Nome do arquivo executvel de sada |\n| `-c` | Apenas gerar cdigo C |\n| `--emit-c <file>` | Escrever C para arquivo especificado |\n| `-k, --keep-c` | Manter C gerado aps compilao |\n| `-O<level>` | Nvel de otimizao (0-3) |\n| `--cc <path>` | Compilador C a usar |\n| `--runtime <path>` | Caminho para biblioteca runtime |\n| `-v, --verbose` | Sada detalhada |\n\n## Comparao\n\n| Mtodo | Portabilidade | Incio | Tamanho | Dependncias |\n|--------|---------------|--------|---------|--------------|\n| `.hml` | Apenas fonte | Tempo de parse | Mnimo | Hemlock |\n| `.hmlc` | Apenas Hemlock | Rpido | Pequeno | Hemlock |\n| `.hmlb` | Apenas Hemlock | Rpido | Menor | Hemlock |\n| `--package` | Independente | Rpido | Maior | Nenhuma |\n| `hemlockc` | Nativo | Mais rpido | Varivel | Lib runtime |\n\n## Melhores Prticas\n\n1. **Desenvolvimento**: Executar arquivos `.hml` diretamente para iterao rpida\n2. **Distribuio (com Hemlock)**: Empacotar com `--compress` para arquivos menores\n3. **Distribuio (independente)**: Encapsular para deploy sem dependncias\n4. **Crtico para desempenho**: Usar `hemlockc` para compilao nativa\n\n## Soluo de Problemas\n\n### \"Cannot find stdlib\"\n\nO empacotador procura stdlib em:\n1. `./stdlib` (relativo ao executvel)\n2. `../stdlib` (relativo ao executvel)\n3. `/usr/local/lib/hemlock/stdlib`\n\nCertifique-se de que Hemlock est instalado corretamente ou execute do diretrio fonte.\n\n### Dependncias Circulares\n\n```\nError: Circular dependency detected when loading 'path/to/module.hml'\n```\n\nRefatore seus imports para quebrar o ciclo. Considere usar um mdulo compartilhado para tipos comuns.\n\n### Tamanho Grande do Pacote\n\n- Use compresso padro (no use `--no-compress`)\n- Tamanho do pacote inclui interpretador completo (base ~500KB-1MB)\n- Para tamanho mnimo, use `hemlockc` para compilao nativa\n"}, "Tpicos Avanados -> Execuo de Comandos": {"id": "advanced-command-execution", "content": "# Hemlock Execuo de Comandos\n\nHemlock oferece a **funo integrada `exec()`** para executar comandos shell e capturar a sada.\n\n## ndice\n\n- [Viso Geral](#viso-geral)\n- [Funo exec()](#funo-exec)\n- [Objeto de Resultado](#objeto-de-resultado)\n- [Uso Bsico](#uso-bsico)\n- [Exemplos Avanados](#exemplos-avanados)\n- [Tratamento de Erros](#tratamento-de-erros)\n- [Detalhes de Implementao](#detalhes-de-implementao)\n- [Consideraes de Segurana](#consideraes-de-segurana)\n- [Limitaes](#limitaes)\n- [Casos de Uso](#casos-de-uso)\n- [Melhores Prticas](#melhores-prticas)\n- [Exemplos Completos](#exemplos-completos)\n\n## Viso Geral\n\nA funo `exec()` permite que programas Hemlock:\n- Executem comandos shell\n- Capturem a sada padro (stdout)\n- Verifiquem cdigos de sada\n- Usem recursos do shell (pipes, redirecionamento, etc.)\n- Integrem com ferramentas do sistema\n\n**Importante:** Comandos so executados via `/bin/sh`, fornecendo funcionalidade completa de shell, mas tambm introduzindo consideraes de segurana.\n\n## Funo exec()\n\n### Assinatura\n\n```hemlock\nexec(command: string): object\n```\n\n**Parmetros:**\n- `command` (string) - o comando shell a executar\n\n**Retorna:** Um objeto com dois campos:\n- `output` (string) - sada stdout do comando\n- `exit_code` (i32) - cdigo de status de sada do comando\n\n### Exemplo Bsico\n\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n```\n\n## Objeto de Resultado\n\nO objeto retornado por `exec()` tem a seguinte estrutura:\n\n```hemlock\n{\n    output: string,      // stdout do comando (sada capturada)\n    exit_code: i32       // status de sada do processo (0 = sucesso)\n}\n```\n\n### Campo output\n\nContm todo o texto que o comando escreveu no stdout.\n\n**Propriedades:**\n- String vazia se o comando no produziu sada\n- Inclui newlines e espaos em branco como esto\n- Sada multi-linha  preservada\n- Sem limite de tamanho (alocao dinmica)\n\n**Exemplos:**\n```hemlock\nlet r1 = exec(\"echo test\");\nprint(r1.output);  // \"test\\n\"\n\nlet r2 = exec(\"ls\");\nprint(r2.output);  // Listagem de diretrio com newlines\n\nlet r3 = exec(\"true\");\nprint(r3.output);  // \"\" (string vazia)\n```\n\n### Campo exit_code\n\nO cdigo de status de sada do comando.\n\n**Valores:**\n- `0` tipicamente indica sucesso\n- `1-255` indicam erro (conveno varia por comando)\n- `-1` se o comando no pde ser executado ou terminou anormalmente\n\n**Exemplos:**\n```hemlock\nlet r1 = exec(\"true\");\nprint(r1.exit_code);  // 0 (sucesso)\n\nlet r2 = exec(\"false\");\nprint(r2.exit_code);  // 1 (falha)\n\nlet r3 = exec(\"ls /nonexistent\");\nprint(r3.exit_code);  // 2 (arquivo no encontrado, varia por comando)\n```\n\n## Uso Bsico\n\n### Comandos Simples\n\n```hemlock\nlet r = exec(\"ls -la\");\nprint(r.output);\nprint(\"Exit code: \" + typeof(r.exit_code));\n```\n\n### Verificando Status de Sada\n\n```hemlock\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Found: \" + r.output);\n} else {\n    print(\"Pattern not found\");\n}\n```\n\n### Comandos com Pipes\n\n```hemlock\nlet r = exec(\"ps aux | grep hemlock\");\nprint(r.output);\n```\n\n### Mltiplos Comandos\n\n```hemlock\nlet r = exec(\"cd /tmp && ls -la\");\nprint(r.output);\n```\n\n### Substituio de Comando\n\n```hemlock\nlet r = exec(\"echo $(date)\");\nprint(r.output);  // Data atual\n```\n\n## Exemplos Avanados\n\n### Tratando Falhas\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\nif (r.exit_code != 0) {\n    print(\"Command failed with code: \" + typeof(r.exit_code));\n    print(\"Error output: \" + r.output);  // Nota: stderr no  capturado\n}\n```\n\n### Processando Sada Multi-linha\n\n```hemlock\nlet r = exec(\"cat file.txt\");\nlet lines = r.output.split(\"\\n\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### Encadeamento de Comandos\n\n**Usando && (E):**\n```hemlock\nlet r1 = exec(\"mkdir -p /tmp/test && touch /tmp/test/file.txt\");\nif (r1.exit_code == 0) {\n    print(\"Setup complete\");\n}\n```\n\n**Usando || (OU):**\n```hemlock\nlet r = exec(\"command1 || command2\");\n// Executa command2 apenas se command1 falhar\n```\n\n**Usando ; (sequencial):**\n```hemlock\nlet r = exec(\"command1; command2\");\n// Executa ambos independentemente de sucesso/falha\n```\n\n### Usando Pipes\n\n```hemlock\nlet r = exec(\"echo 'data' | base64\");\nprint(\"Base64: \" + r.output);\n```\n\n**Pipes Complexos:**\n```hemlock\nlet r = exec(\"cat /etc/passwd | grep root | cut -d: -f1\");\nprint(r.output);\n```\n\n### Padres de Cdigo de Sada\n\nDiferentes cdigos de sada indicam diferentes condies:\n\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n} else if (r.exit_code == 1) {\n    print(\"File does not exist\");\n} else {\n    print(\"Test command failed: \" + typeof(r.exit_code));\n}\n```\n\n### Redirecionamento de Sada\n\n```hemlock\n// Redirecionar stdout para arquivo (dentro do shell)\nlet r1 = exec(\"echo 'test' > /tmp/output.txt\");\n\n// Redirecionar stderr para stdout (nota: Hemlock ainda no captura stderr)\nlet r2 = exec(\"command 2>&1\");\n```\n\n### Variveis de Ambiente\n\n```hemlock\nlet r = exec(\"export VAR=value && echo $VAR\");\nprint(r.output);  // \"value\\n\"\n```\n\n### Mudana de Diretrio de Trabalho\n\n```hemlock\nlet r = exec(\"cd /tmp && pwd\");\nprint(r.output);  // \"/tmp\\n\"\n```\n\n## Tratamento de Erros\n\n### Quando exec() Lana Exceo\n\nA funo `exec()` lanar uma exceo se o comando no puder ser executado:\n\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command_xyz\");\n} catch (e) {\n    print(\"Failed to execute: \" + e);\n}\n```\n\n**Condies que lanam:**\n- `popen()` falha (ex: no pode criar pipe)\n- Limites de recursos do sistema excedidos\n- Falha na alocao de memria\n\n### Quando exec() No Lana Exceo\n\n```hemlock\n// Comando executa mas retorna cdigo de sada no-zero\nlet r1 = exec(\"false\");\nprint(r1.exit_code);  // 1 (no  exceo)\n\n// Comando no tem sada\nlet r2 = exec(\"true\");\nprint(r2.output);  // \"\" (no  exceo)\n\n// Shell no pode encontrar comando\nlet r3 = exec(\"nonexistent_cmd\");\nprint(r3.exit_code);  // 127 (no  exceo)\n```\n\n### Padro de Execuo Segura\n\n```hemlock\nfn safe_exec(command: string) {\n    try {\n        let r = exec(command);\n        if (r.exit_code != 0) {\n            print(\"Warning: Command failed with code \" + typeof(r.exit_code));\n            return \"\";\n        }\n        return r.output;\n    } catch (e) {\n        print(\"Error executing command: \" + e);\n        return \"\";\n    }\n}\n\nlet output = safe_exec(\"ls -la\");\n```\n\n## Detalhes de Implementao\n\n### Como Funciona\n\n**Implementao subjacente:**\n- Usa `popen()` para executar comandos via `/bin/sh`\n- Apenas stdout  capturado (stderr no  capturado)\n- Sada  bufferizada dinamicamente (comea com 4KB, cresce conforme necessrio)\n- Status de sada  extrado usando macros `WIFEXITED()` e `WEXITSTATUS()`\n- String de sada  corretamente terminada em null\n\n**Fluxo do processo:**\n1. `popen(command, \"r\")` cria pipe e faz fork do processo\n2. Processo filho executa `/bin/sh -c \"command\"`\n3. Processo pai l stdout via pipe para buffer crescente\n4. `pclose()` espera o filho e retorna status de sada\n5. Status de sada  extrado e armazenado no objeto resultado\n\n### Consideraes de Desempenho\n\n**Overhead:**\n- Cada chamada cria um novo processo shell (~1-5ms de overhead)\n- Sada  completamente armazenada em memria (no streaming)\n- Streaming no  suportado (espera comando completar)\n- Adequado para comandos com tamanho de sada razovel\n\n**Otimizaes:**\n- Buffer comea com 4KB, dobra quando cheio (uso eficiente de memria)\n- Loop de leitura nico minimiza chamadas de sistema\n- Sem cpias extras de string\n\n**Quando usar:**\n- Comandos de curta durao (< 1 segundo)\n- Tamanho de sada moderado (< 10MB)\n- Operaes em lote com intervalos razoveis\n\n**Quando no usar:**\n- Daemons ou servios de longa durao\n- Comandos que produzem sada em GB\n- Processamento de dados streaming em tempo real\n- Execuo de alta frequncia (> 100 vezes/segundo)\n\n## Consideraes de Segurana\n\n### Risco de Injeo de Shell\n\n**Crtico:** Comandos so executados pelo shell (`/bin/sh`), o que significa que **injeo de shell  possvel**.\n\n**Cdigo Vulnervel:**\n```hemlock\n// PERIGO - NO FAA ISSO\nlet filename = args[1];  // Entrada do usurio\nlet r = exec(\"cat \" + filename);  // Injeo de shell!\n```\n\n**Ataque:**\n```bash\n./hemlock script.hml \"; rm -rf /; echo pwned\"\n# Executa: cat ; rm -rf /; echo pwned\n```\n\n### Prticas Seguras\n\n**1. Nunca use entrada de usurio no sanitizada:**\n```hemlock\n// Ruim\nlet user_input = args[1];\nlet r = exec(\"process \" + user_input);  // Perigoso\n\n// Bom - validar primeiro\nfn is_safe_filename(name: string): bool {\n    // Apenas permitir alfanumricos, hfen, sublinhado, ponto\n    let i = 0;\n    while (i < name.length) {\n        let c = name[i];\n        if (!(c >= 'a' && c <= 'z') &&\n            !(c >= 'A' && c <= 'Z') &&\n            !(c >= '0' && c <= '9') &&\n            c != '-' && c != '_' && c != '.') {\n            return false;\n        }\n        i = i + 1;\n    }\n    return true;\n}\n\nlet filename = args[1];\nif (is_safe_filename(filename)) {\n    let r = exec(\"cat \" + filename);\n} else {\n    print(\"Invalid filename\");\n}\n```\n\n**2. Use whitelist, no blacklist:**\n```hemlock\n// Bom - whitelist estrita\nlet allowed_commands = [\"status\", \"start\", \"stop\", \"restart\"];\nlet cmd = args[1];\n\nlet found = false;\nfor (let allowed in allowed_commands) {\n    if (cmd == allowed) {\n        found = true;\n        break;\n    }\n}\n\nif (found) {\n    exec(\"service myapp \" + cmd);\n} else {\n    print(\"Invalid command\");\n}\n```\n\n**3. Escape caracteres especiais:**\n```hemlock\nfn shell_escape(s: string): string {\n    // Escape simples - envolver em aspas simples e escapar aspas simples\n    let escaped = s.replace_all(\"'\", \"'\\\\''\");\n    return \"'\" + escaped + \"'\";\n}\n\nlet user_file = args[1];\nlet safe = shell_escape(user_file);\nlet r = exec(\"cat \" + safe);\n```\n\n**4. Evite exec() para operaes de arquivo:**\n```hemlock\n// Ruim - usando exec para operaes de arquivo\nlet r = exec(\"cat file.txt\");\n\n// Bom - usar API de arquivo do Hemlock\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### Consideraes de Permisso\n\nComandos executam com as mesmas permisses que o processo Hemlock:\n\n```hemlock\n// Se Hemlock est rodando como root, comandos exec() tambm rodam como root!\nlet r = exec(\"rm -rf /important\");  // Perigoso se rodando como root\n```\n\n**Melhor prtica:** Execute Hemlock com privilgios mnimos necessrios.\n\n## Limitaes\n\n### 1. Sem Captura de stderr\n\nApenas stdout  capturado, stderr vai para o terminal:\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\n// r.output est vazio\n// Mensagem de erro aparece no terminal, no capturada\n```\n\n**Workaround - redirecionar stderr para stdout:**\n```hemlock\nlet r = exec(\"ls /nonexistent 2>&1\");\n// Agora a mensagem de erro est em r.output\n```\n\n### 2. Sem Streaming\n\nDeve esperar o comando completar:\n\n```hemlock\nlet r = exec(\"long_running_command\");\n// Bloqueia at o comando terminar\n// No pode processar sada incrementalmente\n```\n\n### 3. Sem Timeout\n\nComandos podem rodar indefinidamente:\n\n```hemlock\nlet r = exec(\"sleep 1000\");\n// Bloqueia por 1000 segundos\n// No pode timeout ou cancelar\n```\n\n**Workaround - usar comando timeout:**\n```hemlock\nlet r = exec(\"timeout 5 long_command\");\n// Timeout aps 5 segundos\n```\n\n### 4. Sem Tratamento de Sinais\n\nNo pode enviar sinais para comandos em execuo:\n\n```hemlock\nlet r = exec(\"long_command\");\n// No pode enviar SIGINT, SIGTERM, etc para o comando\n```\n\n### 5. Sem Controle de Processo\n\nNo pode interagir com o comando aps iniciar:\n\n```hemlock\nlet r = exec(\"interactive_program\");\n// No pode enviar entrada para o programa\n// No pode controlar a execuo\n```\n\n## Casos de Uso\n\n### Bons Casos de Uso\n\n**1. Executar ferramentas do sistema:**\n```hemlock\nlet r = exec(\"ls -la\");\nlet r = exec(\"grep pattern file.txt\");\nlet r = exec(\"find /path -name '*.txt'\");\n```\n\n**2. Processamento rpido de dados com ferramentas Unix:**\n```hemlock\nlet r = exec(\"cat data.txt | sort | uniq | wc -l\");\nprint(\"Unique lines: \" + r.output);\n```\n\n**3. Verificar status do sistema:**\n```hemlock\nlet r = exec(\"df -h\");\nprint(\"Disk usage:\\n\" + r.output);\n```\n\n**4. Verificao de existncia de arquivo:**\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n}\n```\n\n**5. Gerar relatrios:**\n```hemlock\nlet r = exec(\"ps aux | grep myapp | wc -l\");\nlet count = r.output.trim();\nprint(\"Running instances: \" + count);\n```\n\n**6. Scripts de automao:**\n```hemlock\nexec(\"git add .\");\nexec(\"git commit -m 'Auto commit'\");\nlet r = exec(\"git push\");\nif (r.exit_code != 0) {\n    print(\"Push failed\");\n}\n```\n\n### Casos de Uso No Recomendados\n\n**1. Servios de longa durao:**\n```hemlock\n// Ruim\nlet r = exec(\"nginx\");  // Bloqueia para sempre\n```\n\n**2. Comandos interativos:**\n```hemlock\n// Ruim - no pode fornecer entrada\nlet r = exec(\"ssh user@host\");\n```\n\n**3. Comandos com sada enorme:**\n```hemlock\n// Ruim - carrega sada inteira na memria\nlet r = exec(\"cat 10GB_file.log\");\n```\n\n**4. Streaming em tempo real:**\n```hemlock\n// Ruim - no pode processar sada incrementalmente\nlet r = exec(\"tail -f /var/log/app.log\");\n```\n\n**5. Tratamento de erros de misso crtica:**\n```hemlock\n// Ruim - stderr no  capturado\nlet r = exec(\"critical_operation\");\n// No pode ver mensagens de erro detalhadas\n```\n\n## Melhores Prticas\n\n### 1. Sempre Verifique Cdigo de Sada\n\n```hemlock\nlet r = exec(\"important_command\");\nif (r.exit_code != 0) {\n    print(\"Command failed!\");\n    // Tratar erro\n}\n```\n\n### 2. Trim Sada Quando Necessrio\n\n```hemlock\nlet r = exec(\"echo test\");\nlet clean = r.output.trim();  // Remove newline final\nprint(clean);  // \"test\" (sem newline)\n```\n\n### 3. Valide Antes de Executar\n\n```hemlock\nfn is_valid_command(cmd: string): bool {\n    // Validar se comando  seguro\n    return true;  // Sua lgica de validao\n}\n\nif (is_valid_command(user_cmd)) {\n    exec(user_cmd);\n}\n```\n\n### 4. Use try/catch para Operaes Crticas\n\n```hemlock\ntry {\n    let r = exec(\"critical_command\");\n    if (r.exit_code != 0) {\n        throw \"Command failed\";\n    }\n} catch (e) {\n    print(\"Error: \" + e);\n    // Limpeza ou recuperao\n}\n```\n\n### 5. Prefira APIs Hemlock sobre exec()\n\n```hemlock\n// Ruim - usar exec para operaes de arquivo\nlet r = exec(\"cat file.txt\");\n\n// Bom - usar API de arquivo do Hemlock\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### 6. Capture stderr Quando Necessrio\n\n```hemlock\n// Redirecionar stderr para stdout\nlet r = exec(\"command 2>&1\");\n// Agora r.output contm tanto stdout quanto stderr\n```\n\n### 7. Use Recursos do Shell com Sabedoria\n\n```hemlock\n// Usar pipes para eficincia\nlet r = exec(\"cat large.txt | grep pattern | head -n 10\");\n\n// Usar substituio de comando\nlet r = exec(\"echo Current user: $(whoami)\");\n\n// Usar execuo condicional\nlet r = exec(\"test -f file.txt && cat file.txt\");\n```\n\n## Exemplos Completos\n\n### Exemplo 1: Coletor de Informaes do Sistema\n\n```hemlock\nfn get_system_info() {\n    print(\"=== System Information ===\");\n\n    // Hostname\n    let r1 = exec(\"hostname\");\n    print(\"Hostname: \" + r1.output.trim());\n\n    // Uptime\n    let r2 = exec(\"uptime\");\n    print(\"Uptime: \" + r2.output.trim());\n\n    // Uso de disco\n    let r3 = exec(\"df -h /\");\n    print(\"\\nDisk Usage:\");\n    print(r3.output);\n\n    // Uso de memria\n    let r4 = exec(\"free -h\");\n    print(\"Memory Usage:\");\n    print(r4.output);\n}\n\nget_system_info();\n```\n\n### Exemplo 2: Analisador de Logs\n\n```hemlock\nfn analyze_log(logfile: string) {\n    print(\"Analyzing log: \" + logfile);\n\n    // Contar linhas totais\n    let r1 = exec(\"wc -l \" + logfile);\n    print(\"Total lines: \" + r1.output.trim());\n\n    // Contar erros\n    let r2 = exec(\"grep -c ERROR \" + logfile + \" 2>/dev/null\");\n    let errors = r2.output.trim();\n    if (r2.exit_code == 0) {\n        print(\"Errors: \" + errors);\n    } else {\n        print(\"Errors: 0\");\n    }\n\n    // Contar avisos\n    let r3 = exec(\"grep -c WARN \" + logfile + \" 2>/dev/null\");\n    let warnings = r3.output.trim();\n    if (r3.exit_code == 0) {\n        print(\"Warnings: \" + warnings);\n    } else {\n        print(\"Warnings: 0\");\n    }\n\n    // Erros recentes\n    print(\"\\nRecent errors:\");\n    let r4 = exec(\"grep ERROR \" + logfile + \" | tail -n 5\");\n    print(r4.output);\n}\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <logfile>\");\n} else {\n    analyze_log(args[1]);\n}\n```\n\n### Exemplo 3: Auxiliar Git\n\n```hemlock\nfn git_status() {\n    let r = exec(\"git status --short\");\n    if (r.exit_code != 0) {\n        print(\"Error: Not a git repository\");\n        return;\n    }\n\n    if (r.output == \"\") {\n        print(\"Working directory clean\");\n    } else {\n        print(\"Changes:\");\n        print(r.output);\n    }\n}\n\nfn git_quick_commit(message: string) {\n    print(\"Adding all changes...\");\n    let r1 = exec(\"git add -A\");\n    if (r1.exit_code != 0) {\n        print(\"Error adding files\");\n        return;\n    }\n\n    print(\"Committing...\");\n    let safe_msg = message.replace_all(\"'\", \"'\\\\''\");\n    let r2 = exec(\"git commit -m '\" + safe_msg + \"'\");\n    if (r2.exit_code != 0) {\n        print(\"Error committing\");\n        return;\n    }\n\n    print(\"Committed successfully\");\n    print(r2.output);\n}\n\n// Uso\ngit_status();\nif (args.length > 1) {\n    git_quick_commit(args[1]);\n}\n```\n\n### Exemplo 4: Script de Backup\n\n```hemlock\nfn backup_directory(source: string, dest: string) {\n    print(\"Backing up \" + source + \" to \" + dest);\n\n    // Criar diretrio de backup\n    let r1 = exec(\"mkdir -p \" + dest);\n    if (r1.exit_code != 0) {\n        print(\"Error creating backup directory\");\n        return false;\n    }\n\n    // Criar arquivo com timestamp\n    let r2 = exec(\"date +%Y%m%d_%H%M%S\");\n    let timestamp = r2.output.trim();\n    let backup_file = dest + \"/backup_\" + timestamp + \".tar.gz\";\n\n    print(\"Creating archive: \" + backup_file);\n    let r3 = exec(\"tar -czf \" + backup_file + \" \" + source + \" 2>&1\");\n    if (r3.exit_code != 0) {\n        print(\"Error creating backup:\");\n        print(r3.output);\n        return false;\n    }\n\n    print(\"Backup completed successfully\");\n\n    // Mostrar tamanho do backup\n    let r4 = exec(\"du -h \" + backup_file);\n    print(\"Backup size: \" + r4.output.trim());\n\n    return true;\n}\n\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <source> <destination>\");\n} else {\n    backup_directory(args[1], args[2]);\n}\n```\n\n## Resumo\n\nA funo `exec()` do Hemlock oferece:\n\n- Execuo simples de comandos shell\n- Captura de sada (stdout)\n- Verificao de cdigo de sada\n- Acesso completo a recursos do shell (pipes, redirecionamento, etc.)\n- Integrao com ferramentas do sistema\n\nLembre-se:\n- Sempre verifique cdigos de sada\n- Esteja ciente das implicaes de segurana (injeo de shell)\n- Valide entrada do usurio antes de usar em comandos\n- Prefira APIs Hemlock sobre exec() quando disponveis\n- stderr no  capturado (use `2>&1` para redirecionar)\n- Comandos bloqueiam at completar\n- Use para ferramentas de curta durao, no servios de longa durao\n\n**Checklist de Segurana:**\n- Nunca use entrada de usurio no sanitizada\n- Valide toda entrada\n- Use whitelist para comandos\n- Escape caracteres especiais quando necessrio\n- Execute com privilgios mnimos\n- Prefira APIs Hemlock sobre comandos shell\n"}, "Tpicos Avanados -> FFI": {"id": "advanced-ffi", "content": "# Hemlock FFI (Interface de Funes Estrangeiras)\n\nHemlock oferece **FFI (Interface de Funes Estrangeiras)**, permitindo chamar funes C de bibliotecas compartilhadas usando libffi, possibilitando integrao com bibliotecas C existentes e APIs do sistema.\n\n## ndice\n\n- [Viso Geral](#viso-geral)\n- [Estado Atual](#estado-atual)\n- [Tipos Suportados](#tipos-suportados)\n- [Conceitos Bsicos](#conceitos-bsicos)\n- [Exportando Funes FFI](#exportando-funes-ffi)\n- [Casos de Uso](#casos-de-uso)\n- [Desenvolvimento Futuro](#desenvolvimento-futuro)\n- [Callbacks FFI](#callbacks-ffi)\n- [Structs FFI](#structs-ffi)\n- [Limitaes Atuais](#limitaes-atuais)\n- [Melhores Prticas](#melhores-prticas)\n\n## Viso Geral\n\nA Interface de Funes Estrangeiras (FFI) permite que programas Hemlock:\n- Chamem funes C de bibliotecas compartilhadas (.so, .dylib, .dll)\n- Usem bibliotecas C existentes sem escrever cdigo wrapper\n- Acessem APIs do sistema diretamente\n- Integrem com bibliotecas nativas de terceiros\n- Faam ponte entre Hemlock e funcionalidade de baixo nvel do sistema\n\n**Capacidades Principais:**\n- Carregamento dinmico de bibliotecas\n- Binding de funes C\n- Converso automtica de tipos entre Hemlock e C\n- Suporte a todos os tipos primitivos\n- Implementao baseada em libffi para portabilidade\n\n## Estado Atual\n\nO suporte FFI em Hemlock possui as seguintes caractersticas:\n\n**Implementado:**\n- Chamar funes C de bibliotecas compartilhadas\n- Suporte a todos os tipos primitivos (inteiros, floats, ponteiros)\n- Converso automtica de tipos\n- Implementao baseada em libffi\n- Carregamento dinmico de bibliotecas\n- **Callbacks de ponteiro de funo** - passar funes Hemlock para C\n- **Exportar funes extern** - compartilhar bindings FFI entre mdulos\n- **Passagem e retorno de structs** - passar structs compatveis com C por valor\n- **Funes auxiliares de ponteiro completas** - ler/escrever todos os tipos (i8-i64, u8-u64, f32, f64, ptr)\n- **Converso buffer/ponteiro** - `buffer_ptr()`, `ptr_to_buffer()`\n- **Tamanhos de tipo FFI** - `ffi_sizeof()` para tamanhos de tipo conscientes da plataforma\n- **Tipos de plataforma** - suporte para `size_t`, `usize`, `isize`, `intptr_t`\n\n**Em Desenvolvimento:**\n- Helpers de marshaling de strings\n- Melhorias no tratamento de erros\n\n## Tipos Suportados\n\n### Tipos Primitivos\n\nOs seguintes tipos Hemlock podem ser passados para ou retornados de funes C:\n\n| Tipo Hemlock | Tipo C | Tamanho | Descrio |\n|--------------|--------|---------|-----------|\n| `i8` | `int8_t` | 1 byte | Inteiro com sinal de 8 bits |\n| `i16` | `int16_t` | 2 bytes | Inteiro com sinal de 16 bits |\n| `i32` | `int32_t` | 4 bytes | Inteiro com sinal de 32 bits |\n| `i64` | `int64_t` | 8 bytes | Inteiro com sinal de 64 bits |\n| `u8` | `uint8_t` | 1 byte | Inteiro sem sinal de 8 bits |\n| `u16` | `uint16_t` | 2 bytes | Inteiro sem sinal de 16 bits |\n| `u32` | `uint32_t` | 4 bytes | Inteiro sem sinal de 32 bits |\n| `u64` | `uint64_t` | 8 bytes | Inteiro sem sinal de 64 bits |\n| `f32` | `float` | 4 bytes | Ponto flutuante de 32 bits |\n| `f64` | `double` | 8 bytes | Ponto flutuante de 64 bits |\n| `ptr` | `void*` | 8 bytes | Ponteiro bruto |\n\n### Converso de Tipos\n\n**Converso Automtica:**\n- Inteiros Hemlock -> Inteiros C (com verificao de range)\n- Floats Hemlock -> Floats C\n- Ponteiros Hemlock -> Ponteiros C\n- Valores de retorno C -> Valores Hemlock\n\n**Exemplos de Mapeamento de Tipos:**\n```hemlock\n// Hemlock -> C\nlet i: i32 = 42;         // -> int32_t (4 bytes)\nlet f: f64 = 3.14;       // -> double (8 bytes)\nlet p: ptr = alloc(64);  // -> void* (8 bytes)\n\n// C -> Hemlock (valores de retorno)\n// int32_t foo() -> i32\n// double bar() -> f64\n// void* baz() -> ptr\n```\n\n## Conceitos Bsicos\n\n### Bibliotecas Compartilhadas\n\nFFI trabalha com bibliotecas compartilhadas compiladas:\n\n**Linux:** arquivos `.so`\n```\nlibexample.so\n/usr/lib/libm.so\n```\n\n**macOS:** arquivos `.dylib`\n```\nlibexample.dylib\n/usr/lib/libSystem.dylib\n```\n\n**Windows:** arquivos `.dll`\n```\nexample.dll\nkernel32.dll\n```\n\n### Assinaturas de Funo\n\nFunes C devem ter assinaturas conhecidas para que FFI funcione:\n\n```c\n// Exemplos de assinaturas de funes C\nint add(int a, int b);\ndouble sqrt(double x);\nvoid* malloc(size_t size);\nvoid free(void* ptr);\n```\n\nUma vez que a biblioteca  carregada e funes so vinculadas, elas podem ser chamadas do Hemlock.\n\n### Compatibilidade de Plataforma\n\nFFI usa **libffi** para portabilidade:\n- Funciona em x86, x86-64, ARM, ARM64\n- Trata convenes de chamada automaticamente\n- Abstrai detalhes de ABI especficos da plataforma\n- Suporta Linux, macOS, Windows (com libffi apropriada)\n\n## Exportando Funes FFI\n\nFunes FFI declaradas com `extern fn` podem ser exportadas de mdulos, permitindo criar wrappers de biblioteca reutilizveis que podem ser compartilhados entre mltiplos arquivos.\n\n### Sintaxe Bsica de Exportao\n\n```hemlock\n// string_utils.hml - mdulo de biblioteca wrapping funes de string C\nimport \"libc.so.6\";\n\n// Exportar funes extern diretamente\nexport extern fn strlen(s: string): i32;\nexport extern fn strcmp(s1: string, s2: string): i32;\n\n// Voc tambm pode exportar funes wrapper junto com funes extern\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n\nexport fn strings_equal(a: string, b: string): bool {\n    return strcmp(a, b) == 0;\n}\n```\n\n### Importando Funes FFI Exportadas\n\n```hemlock\n// main.hml - usando funes FFI exportadas\nimport { strlen, string_length, strings_equal } from \"./string_utils.hml\";\n\nlet msg = \"Hello, World!\";\nprint(strlen(msg));           // 13 - chamada extern direta\nprint(string_length(msg));    // 13 - funo wrapper\n\nprint(strings_equal(\"foo\", \"foo\"));  // true\nprint(strings_equal(\"foo\", \"bar\"));  // false\n```\n\n### Casos de Uso para Export Extern\n\n**1. Abstrao de Plataforma**\n```hemlock\n// platform.hml - abstrair diferenas de plataforma\nimport \"libc.so.6\";  // Linux\n\nexport extern fn getpid(): i32;\nexport extern fn getuid(): i32;\nexport extern fn geteuid(): i32;\n```\n\n**2. Wrappers de Biblioteca**\n```hemlock\n// crypto_lib.hml - wrapping funes de biblioteca de criptografia\nimport \"libcrypto.so\";\n\nexport extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;\nexport extern fn MD5(data: ptr, len: u64, out: ptr): ptr;\n\n// Adicionar wrappers amigveis ao Hemlock\nexport fn sha256_string(s: string): string {\n    // Implementao usando funes extern\n}\n```\n\n**3. Declaraes FFI Centralizadas**\n```hemlock\n// libc.hml - mdulo central para bindings libc\nimport \"libc.so.6\";\n\n// Funes de string\nexport extern fn strlen(s: string): i32;\nexport extern fn strcpy(dest: ptr, src: string): ptr;\nexport extern fn strcat(dest: ptr, src: string): ptr;\n\n// Funes de memria\nexport extern fn malloc(size: u64): ptr;\nexport extern fn realloc(p: ptr, size: u64): ptr;\nexport extern fn calloc(nmemb: u64, size: u64): ptr;\n\n// Funes de processo\nexport extern fn getpid(): i32;\nexport extern fn getppid(): i32;\nexport extern fn getenv(name: string): ptr;\n```\n\nEnto use em todo o seu projeto:\n```hemlock\nimport { strlen, malloc, getpid } from \"./libc.hml\";\n```\n\n## Casos de Uso\n\n### 1. Bibliotecas do Sistema\n\nAcessar funes da biblioteca C padro:\n\n**Funes Matemticas:**\n```hemlock\n// Chamar sqrt de libm\nlet result = sqrt(16.0);  // 4.0\n```\n\n**Alocao de Memria:**\n```hemlock\n// Chamar malloc/free de libc\nlet ptr = malloc(1024);\nfree(ptr);\n```\n\n### 2. Bibliotecas de Terceiros\n\nUsar bibliotecas C existentes:\n\n**Exemplo: Processamento de Imagem**\n```hemlock\n// Carregar libpng ou libjpeg\n// Processar imagens usando funes de biblioteca C\n```\n\n**Exemplo: Criptografia**\n```hemlock\n// Usar OpenSSL ou libsodium\n// Criptografia/descriptografia via FFI\n```\n\n### 3. APIs do Sistema\n\nChamadas diretas ao sistema:\n\n**Exemplo: API POSIX**\n```hemlock\n// Chamar getpid, getuid, etc.\n// Acessar funcionalidade de baixo nvel do sistema\n```\n\n### 4. Cdigo Crtico para Desempenho\n\nChamar implementaes C otimizadas:\n\n```hemlock\n// Usar bibliotecas C altamente otimizadas\n// Operaes SIMD, cdigo vetorizado\n// Funes aceleradas por hardware\n```\n\n## Callbacks FFI\n\nHemlock suporta passar funes como callbacks para cdigo C usando closures libffi. Isso permite integrao com APIs C que esperam ponteiros de funo, como `qsort`, event loops e bibliotecas baseadas em callback.\n\n### Criando Callbacks\n\nUse `callback()` para criar um ponteiro de funo chamvel por C a partir de uma funo Hemlock:\n\n```hemlock\n// callback(function, param_types, return_type) -> ptr\nlet cb = callback(my_function, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n**Parmetros:**\n- `function`: A funo Hemlock a ser wrapped\n- `param_types`: Array de strings de nomes de tipo (como `[\"ptr\", \"i32\"]`)\n- `return_type`: String de tipo de retorno (como `\"i32\"`, `\"void\"`)\n\n**Tipos de Callback Suportados:**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - Inteiros com sinal\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - Inteiros sem sinal\n- `\"f32\"`, `\"f64\"` - Floats\n- `\"ptr\"` - Ponteiros\n- `\"void\"` - Sem retorno\n- `\"bool\"` - Booleano\n\n### Exemplo: qsort\n\n```hemlock\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// Funo de comparao de inteiros (ordem crescente)\nfn compare_ints(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va < vb) { return -1; }\n    if (va > vb) { return 1; }\n    return 0;\n}\n\n// Alocar array de 5 inteiros\nlet arr = alloc(20);  // 5 * 4 bytes\nptr_write_i32(arr, 5);\nptr_write_i32(ptr_offset(arr, 1, 4), 2);\nptr_write_i32(ptr_offset(arr, 2, 4), 8);\nptr_write_i32(ptr_offset(arr, 3, 4), 1);\nptr_write_i32(ptr_offset(arr, 4, 4), 9);\n\n// Criar callback e ordenar\nlet cmp = callback(compare_ints, [\"ptr\", \"ptr\"], \"i32\");\nqsort(arr, 5, 4, cmp);\n\n// Array agora ordenado: [1, 2, 5, 8, 9]\n\n// Limpar\ncallback_free(cmp);\nfree(arr);\n```\n\n### Funes Auxiliares de Ponteiro\n\nHemlock fornece funes auxiliares abrangentes para trabalhar com ponteiros brutos. Estas so essenciais para callbacks FFI e manipulao direta de memria.\n\n#### Auxiliares de Tipo Inteiro\n\n| Funo | Descrio |\n|--------|-----------|\n| `ptr_deref_i8(ptr)` | Desreferenciar ponteiro, ler i8 |\n| `ptr_deref_i16(ptr)` | Desreferenciar ponteiro, ler i16 |\n| `ptr_deref_i32(ptr)` | Desreferenciar ponteiro, ler i32 |\n| `ptr_deref_i64(ptr)` | Desreferenciar ponteiro, ler i64 |\n| `ptr_deref_u8(ptr)` | Desreferenciar ponteiro, ler u8 |\n| `ptr_deref_u16(ptr)` | Desreferenciar ponteiro, ler u16 |\n| `ptr_deref_u32(ptr)` | Desreferenciar ponteiro, ler u32 |\n| `ptr_deref_u64(ptr)` | Desreferenciar ponteiro, ler u64 |\n| `ptr_write_i8(ptr, value)` | Escrever i8 na localizao do ponteiro |\n| `ptr_write_i16(ptr, value)` | Escrever i16 na localizao do ponteiro |\n| `ptr_write_i32(ptr, value)` | Escrever i32 na localizao do ponteiro |\n| `ptr_write_i64(ptr, value)` | Escrever i64 na localizao do ponteiro |\n| `ptr_write_u8(ptr, value)` | Escrever u8 na localizao do ponteiro |\n| `ptr_write_u16(ptr, value)` | Escrever u16 na localizao do ponteiro |\n| `ptr_write_u32(ptr, value)` | Escrever u32 na localizao do ponteiro |\n| `ptr_write_u64(ptr, value)` | Escrever u64 na localizao do ponteiro |\n\n#### Auxiliares de Tipo Float\n\n| Funo | Descrio |\n|--------|-----------|\n| `ptr_deref_f32(ptr)` | Desreferenciar ponteiro, ler f32 (float) |\n| `ptr_deref_f64(ptr)` | Desreferenciar ponteiro, ler f64 (double) |\n| `ptr_write_f32(ptr, value)` | Escrever f32 na localizao do ponteiro |\n| `ptr_write_f64(ptr, value)` | Escrever f64 na localizao do ponteiro |\n\n#### Auxiliares de Tipo Ponteiro\n\n| Funo | Descrio |\n|--------|-----------|\n| `ptr_deref_ptr(ptr)` | Desreferenciar ponteiro para ponteiro |\n| `ptr_write_ptr(ptr, value)` | Escrever ponteiro na localizao do ponteiro |\n| `ptr_offset(ptr, index, size)` | Calcular offset: `ptr + index * size` |\n| `ptr_read_i32(ptr)` | Ler i32 via ponteiro para ponteiro (para callbacks qsort) |\n| `ptr_null()` | Obter constante ponteiro nulo |\n\n#### Auxiliares de Converso Buffer\n\n| Funo | Descrio |\n|--------|-----------|\n| `buffer_ptr(buffer)` | Obter ponteiro bruto de buffer |\n| `ptr_to_buffer(ptr, size)` | Copiar dados de ponteiro para novo buffer |\n\n#### Utilitrios FFI\n\n| Funo | Descrio |\n|--------|-----------|\n| `ffi_sizeof(type_name)` | Obter tamanho em bytes de tipo FFI |\n\n**Nomes de tipo suportados por `ffi_sizeof`:**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - Inteiros com sinal (1, 2, 4, 8 bytes)\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - Inteiros sem sinal (1, 2, 4, 8 bytes)\n- `\"f32\"`, `\"f64\"` - Floats (4, 8 bytes)\n- `\"ptr\"` - Ponteiro (8 bytes em sistemas 64-bit)\n- `\"size_t\"`, `\"usize\"` - Tipo de tamanho dependente da plataforma\n- `\"intptr_t\"`, `\"isize\"` - Tipo de ponteiro com sinal dependente da plataforma\n\n### Liberando Callbacks\n\n**Importante:** Sempre libere callbacks aps o uso para prevenir vazamentos de memria:\n\n```hemlock\nlet cb = callback(my_fn, [\"ptr\"], \"void\");\n// ... usar callback ...\ncallback_free(cb);  // Liberar quando terminar de usar\n```\n\nCallbacks tambm so liberados automaticamente na sada do programa.\n\n### Closures em Callbacks\n\nCallbacks capturam seu ambiente de closure, ento podem acessar variveis do escopo externo:\n\n```hemlock\nlet multiplier = 10;\n\nfn scale(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    // Pode acessar 'multiplier' do escopo externo\n    return (va * multiplier) - (vb * multiplier);\n}\n\nlet cmp = callback(scale, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n### Segurana de Thread\n\nInvocaes de callback so serializadas via mutex para garantir segurana de thread, pois o interpretador Hemlock no  completamente thread-safe. Isso significa:\n- Apenas um callback pode executar por vez\n- Seguro para usar com bibliotecas C multi-threaded\n- Pode impactar desempenho se callbacks so chamados frequentemente de mltiplas threads\n\n### Tratamento de Erros em Callbacks\n\nExcees lanadas em callbacks no podem propagar para cdigo C. Em vez disso:\n- Um aviso  impresso em stderr\n- O callback retorna um valor padro (0 ou NULL)\n- A exceo  registrada mas no propagada\n\n```hemlock\nfn risky_callback(a: ptr): i32 {\n    throw \"Something went wrong\";  // Imprime aviso, retorna 0\n}\n```\n\nPara tratamento de erros robusto, valide entradas e evite lanar em callbacks.\n\n## Structs FFI\n\nHemlock suporta passar structs por valor para funes C. Tipos de struct so automaticamente registrados para FFI quando voc os define com anotaes de tipo.\n\n### Definindo Structs Compatveis com FFI\n\nUma struct  compatvel com FFI quando todos os campos tm anotaes de tipo explcitas usando tipos compatveis com FFI:\n\n```hemlock\n// Struct compatvel com FFI\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\n// Struct compatvel com FFI com mltiplos tipos de campo\ndefine Rectangle {\n    top_left: Point,      // Struct aninhada\n    width: f64,\n    height: f64,\n}\n\n// NO  compatvel com FFI (campos sem anotaes de tipo)\ndefine DynamicObject {\n    name,                 // Sem tipo - no pode usar para FFI\n    value,\n}\n```\n\n### Usando Structs com FFI\n\nDeclare funes extern que usam tipos de struct:\n\n```hemlock\n// Definir tipo de struct\ndefine Vector2D {\n    x: f64,\n    y: f64,\n}\n\n// Importar biblioteca C\nimport \"libmath.so\";\n\n// Declarar funes extern que aceitam/retornam structs\nextern fn vector_add(a: Vector2D, b: Vector2D): Vector2D;\nextern fn vector_length(v: Vector2D): f64;\n\n// Usar naturalmente\nlet a: Vector2D = { x: 3.0, y: 0.0 };\nlet b: Vector2D = { x: 0.0, y: 4.0 };\nlet result = vector_add(a, b);\nprint(result.x);  // 3.0\nprint(result.y);  // 4.0\n\nlet len = vector_length(result);\nprint(len);       // 5.0\n```\n\n### Tipos de Campo Suportados\n\nCampos de struct devem usar estes tipos compatveis com FFI:\n\n| Tipo Hemlock | Tipo C | Tamanho |\n|--------------|--------|---------|\n| `i8` | `int8_t` | 1 byte |\n| `i16` | `int16_t` | 2 bytes |\n| `i32` | `int32_t` | 4 bytes |\n| `i64` | `int64_t` | 8 bytes |\n| `u8` | `uint8_t` | 1 byte |\n| `u16` | `uint16_t` | 2 bytes |\n| `u32` | `uint32_t` | 4 bytes |\n| `u64` | `uint64_t` | 8 bytes |\n| `f32` | `float` | 4 bytes |\n| `f64` | `double` | 8 bytes |\n| `ptr` | `void*` | 8 bytes |\n| `string` | `char*` | 8 bytes |\n| `bool` | `int` | Varivel |\n| Struct aninhada | struct | Varivel |\n\n### Layout de Struct\n\nHemlock usa as regras de layout de struct nativo da plataforma (correspondendo ao ABI C):\n- Campos so alinhados pelo seu tipo\n- Padding  inserido conforme necessrio\n- Tamanho total  padded para alinhar com o maior membro\n\n```hemlock\n// Exemplo: Layout compatvel com C\ndefine Mixed {\n    a: i8,    // Offset 0, tamanho 1\n              // 3 bytes de padding\n    b: i32,   // Offset 4, tamanho 4\n}\n// Tamanho total: 8 bytes (incluindo padding)\n\ndefine Point3D {\n    x: f64,   // Offset 0, tamanho 8\n    y: f64,   // Offset 8, tamanho 8\n    z: f64,   // Offset 16, tamanho 8\n}\n// Tamanho total: 24 bytes (sem padding necessrio)\n```\n\n### Structs Aninhadas\n\nStructs podem conter outras structs:\n\n```hemlock\ndefine Inner {\n    x: i32,\n    y: i32,\n}\n\ndefine Outer {\n    inner: Inner,\n    z: i32,\n}\n\nimport \"mylib.so\";\nextern fn process_nested(data: Outer): i32;\n\nlet obj: Outer = {\n    inner: { x: 1, y: 2 },\n    z: 3,\n};\nlet result = process_nested(obj);\n```\n\n### Retorno de Struct\n\nFunes C podem retornar structs:\n\n```hemlock\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\nimport \"libmath.so\";\nextern fn get_origin(): Point;\n\nlet p = get_origin();\nprint(p.x);  // 0.0\nprint(p.y);  // 0.0\n```\n\n### Limitaes\n\n- **Campos de struct devem ter anotaes de tipo** - Campos sem tipo no so compatveis com FFI\n- **Sem arrays em structs** - Use ponteiros em vez disso\n- **Sem unions** - Apenas tipos de struct so suportados\n- **Callbacks no podem retornar structs** - Use ponteiros para valores de retorno de callback\n\n## Limitaes Atuais\n\nFFI tem as seguintes limitaes:\n\n**1. Converso de Tipo Manual**\n- Converso de string deve ser gerenciada manualmente\n- Sem converso automtica Hemlock string <-> C string\n\n**2. Tratamento de Erros Limitado**\n- Relatrio de erros bsico\n- Excees em callbacks no podem propagar para C\n\n**3. Carregamento Manual de Biblioteca**\n- Bibliotecas devem ser carregadas manualmente\n- Sem gerao automtica de bindings\n\n**4. Cdigo Especfico de Plataforma**\n- Caminhos de biblioteca variam por plataforma\n- Deve tratar .so vs .dylib vs .dll\n\n## Melhores Prticas\n\nEmbora documentao abrangente de FFI ainda esteja em desenvolvimento, aqui esto melhores prticas gerais:\n\n### 1. Segurana de Tipos\n\n```hemlock\n// Seja explcito sobre tipos\nlet x: i32 = 42;\nlet result: f64 = c_function(x);\n```\n\n### 2. Gerenciamento de Memria\n\n```hemlock\n// Lembre de liberar memria alocada\nlet ptr = c_malloc(1024);\n// ... usar ptr\nc_free(ptr);\n```\n\n### 3. Verificao de Erros\n\n```hemlock\n// Verifique valores de retorno\nlet result = c_function();\nif (result == null) {\n    print(\"C function failed\");\n}\n```\n\n### 4. Compatibilidade de Plataforma\n\n```hemlock\n// Trate diferenas de plataforma\n// Use extenses de biblioteca apropriadas (.so, .dylib, .dll)\n```\n\n## Resumo\n\nO FFI do Hemlock oferece:\n\n- Chamar funes C de bibliotecas compartilhadas\n- Suporte a tipos primitivos (i8-i64, u8-u64, f32, f64, ptr)\n- Converso automtica de tipos\n- Portabilidade baseada em libffi\n- Base para integrao com bibliotecas nativas\n- **Callbacks de ponteiro de funo** - passar funes Hemlock para C\n- **Exportar funes extern** - compartilhar bindings FFI entre mdulos\n- **Passagem e retorno de struct** - passar structs compatveis com C por valor\n- **Exportar define** - compartilhar definies de tipo struct entre mdulos (importados globalmente automaticamente)\n- **Funes auxiliares de ponteiro completas** - ler/escrever todos os tipos (i8-i64, u8-u64, f32, f64, ptr)\n- **Converso buffer/ponteiro** - `buffer_ptr()`, `ptr_to_buffer()` para marshaling de dados\n- **Tamanhos de tipo FFI** - `ffi_sizeof()` para tamanhos de tipo conscientes da plataforma\n- **Tipos de plataforma** - suporte para `size_t`, `usize`, `isize`, `intptr_t`, `uintptr_t`\n\n**Estado Atual:** FFI  funcionalmente completo com suporte a tipos primitivos, structs, callbacks, exportaes de mdulo e funes auxiliares de ponteiro completas\n\n**Futuro:** Helpers de marshaling de strings\n\n**Casos de Uso:** Bibliotecas de sistema, bibliotecas de terceiros, qsort, event loops, APIs baseadas em callback, wrappers de biblioteca reutilizveis\n"}, "Tpicos Avanados -> File IO": {"id": "advanced-file-io", "content": "# Hemlock E/S de Arquivos\n\nHemlock oferece uma **API de objetos de arquivo** para operaes com arquivos, com tratamento de erros apropriado e gerenciamento de recursos.\n\n## ndice\n\n- [Viso Geral](#viso-geral)\n- [Abrindo Arquivos](#abrindo-arquivos)\n- [Mtodos de Arquivo](#mtodos-de-arquivo)\n- [Propriedades de Arquivo](#propriedades-de-arquivo)\n- [Tratamento de Erros](#tratamento-de-erros)\n- [Gerenciamento de Recursos](#gerenciamento-de-recursos)\n- [Referncia Completa da API](#referncia-completa-da-api)\n- [Padres Comuns](#padres-comuns)\n- [Melhores Prticas](#melhores-prticas)\n\n## Viso Geral\n\nA API de objetos de arquivo oferece:\n\n- **Gerenciamento explcito de recursos** - arquivos devem ser fechados manualmente\n- **Mltiplos modos de abertura** - leitura, escrita, append, leitura+escrita\n- **Operaes de texto e binrio** - ler e escrever dados de texto e binrios\n- **Suporte a posicionamento** - acesso aleatrio dentro de arquivos\n- **Mensagens de erro abrangentes** - relatrio de erros com contexto\n\n**Importante:** Arquivos no so fechados automaticamente. Voc deve chamar `f.close()` para evitar vazamentos de descritores de arquivo.\n\n## Abrindo Arquivos\n\nUse `open(path, mode?)` para abrir um arquivo:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");     // Modo leitura (padro)\nlet f2 = open(\"output.txt\", \"w\");  // Modo escrita (trunca)\nlet f3 = open(\"log.txt\", \"a\");     // Modo append\nlet f4 = open(\"data.bin\", \"r+\");   // Modo leitura+escrita\n```\n\n### Modos de Abertura\n\n| Modo | Descrio | Arquivo Deve Existir | Trunca | Posio |\n|------|-----------|---------------------|--------|---------|\n| `\"r\"` | Leitura (padro) | Sim | No | Incio |\n| `\"w\"` | Escrita | No (cria) | Sim | Incio |\n| `\"a\"` | Append | No (cria) | No | Final |\n| `\"r+\"` | Leitura+Escrita | Sim | No | Incio |\n| `\"w+\"` | Leitura+Escrita | No (cria) | Sim | Incio |\n| `\"a+\"` | Leitura e Append | No (cria) | No | Final |\n\n### Exemplos\n\n**Ler arquivo existente:**\n```hemlock\nlet f = open(\"config.json\", \"r\");\n// Ou simplesmente:\nlet f = open(\"config.json\");  // \"r\"  o padro\n```\n\n**Criar novo arquivo para escrita:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");  // Cria ou trunca\n```\n\n**Adicionar ao arquivo:**\n```hemlock\nlet f = open(\"log.txt\", \"a\");  // Cria se no existir\n```\n\n**Modo leitura+escrita:**\n```hemlock\nlet f = open(\"data.bin\", \"r+\");  // Arquivo existente, pode ler e escrever\n```\n\n## Mtodos de Arquivo\n\n### Leitura\n\n#### read(size?: i32): string\n\nL texto do arquivo (parmetro size opcional).\n\n**Sem size (l tudo):**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet all = f.read();  // L da posio atual at EOF\nf.close();\n```\n\n**Com size (l bytes especificados):**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet chunk = f.read(1024);  // L at 1024 bytes\nlet next = f.read(1024);   // L prximos 1024 bytes\nf.close();\n```\n\n**Retorna:** String contendo os dados lidos, ou string vazia se no EOF\n\n**Exemplo - Ler arquivo inteiro:**\n```hemlock\nlet f = open(\"poem.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n```\n\n**Exemplo - Ler em chunks:**\n```hemlock\nlet f = open(\"large.txt\", \"r\");\nwhile (true) {\n    let chunk = f.read(4096);  // Chunks de 4KB\n    if (chunk == \"\") { break; }  // Chegou ao EOF\n    process(chunk);\n}\nf.close();\n```\n\n#### read_bytes(size: i32): buffer\n\nL dados binrios (retorna buffer).\n\n**Parmetros:**\n- `size` (i32) - nmero de bytes a ler\n\n**Retorna:** Buffer contendo os bytes lidos\n\n```hemlock\nlet f = open(\"image.png\", \"r\");\nlet binary = f.read_bytes(256);  // L 256 bytes\nprint(binary.length);  // 256 (ou menos se EOF)\n\n// Acessar bytes individuais\nlet first_byte = binary[0];\nprint(first_byte);\n\nf.close();\n```\n\n### Escrita\n\n#### write(data: string): i32\n\nEscreve texto no arquivo (retorna bytes escritos).\n\n**Parmetros:**\n- `data` (string) - texto a escrever\n\n**Retorna:** Nmero de bytes escritos (i32)\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Wrote \" + typeof(written) + \" bytes\");  // \"Wrote 14 bytes\"\nf.close();\n```\n\n**Exemplo - Escrever mltiplas linhas:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Line 1\\n\");\nf.write(\"Line 2\\n\");\nf.write(\"Line 3\\n\");\nf.close();\n```\n\n**Exemplo - Adicionar ao arquivo de log:**\n```hemlock\nlet f = open(\"app.log\", \"a\");\nf.write(\"[INFO] Application started\\n\");\nf.write(\"[INFO] User logged in\\n\");\nf.close();\n```\n\n#### write_bytes(data: buffer): i32\n\nEscreve dados binrios (retorna bytes escritos).\n\n**Parmetros:**\n- `data` (buffer) - dados binrios a escrever\n\n**Retorna:** Nmero de bytes escritos (i32)\n\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Criar dados binrios\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\nlet bytes = f.write_bytes(buf);\nprint(\"Wrote \" + typeof(bytes) + \" bytes\");\n\nf.close();\n```\n\n### Posicionamento\n\n#### seek(position: i32): i32\n\nMove para posio especificada (retorna nova posio).\n\n**Parmetros:**\n- `position` (i32) - offset em bytes desde o incio do arquivo\n\n**Retorna:** Nova posio (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Mover para byte 100\nf.seek(100);\n\n// Ler da posio 100\nlet data = f.read(50);\n\n// Resetar para o incio\nf.seek(0);\n\nf.close();\n```\n\n**Exemplo - Acesso aleatrio:**\n```hemlock\nlet f = open(\"records.dat\", \"r\");\n\n// Ler registro no offset 1000\nf.seek(1000);\nlet record1 = f.read_bytes(100);\n\n// Ler registro no offset 2000\nf.seek(2000);\nlet record2 = f.read_bytes(100);\n\nf.close();\n```\n\n#### tell(): i32\n\nObtm posio atual no arquivo.\n\n**Retorna:** Offset atual em bytes (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet pos1 = f.tell();  // 0 (no incio)\n\nf.read(100);\nlet pos2 = f.tell();  // 100 (aps ler 100 bytes)\n\nf.seek(500);\nlet pos3 = f.tell();  // 500 (aps seek)\n\nf.close();\n```\n\n### Fechamento\n\n#### close()\n\nFecha o arquivo (idempotente, pode ser chamado mltiplas vezes).\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n// ... usar arquivo\nf.close();\nf.close();  // Seguro - segundo close no causa erro\n```\n\n**Notas importantes:**\n- Sempre feche arquivos aps o uso para evitar vazamentos de descritores\n- Close  idempotente - pode ser chamado mltiplas vezes com segurana\n- Aps fechar, todas as outras operaes causaro erro\n- Use blocos `finally` para garantir que arquivos sejam fechados mesmo em caso de erro\n\n## Propriedades de Arquivo\n\nObjetos de arquivo tm trs propriedades somente-leitura:\n\n### path: string\n\nO caminho do arquivo usado para abrir o arquivo.\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);  // \"/path/to/file.txt\"\nf.close();\n```\n\n### mode: string\n\nO modo com que o arquivo foi aberto.\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);  // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);  // \"w\"\nf2.close();\n```\n\n### closed: bool\n\nSe o arquivo est fechado.\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n**Exemplo - Verificar se arquivo est aberto:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... usar contedo\n}\n\nf.close();\n\nif (f.closed) {\n    print(\"File is now closed\");\n}\n```\n\n## Tratamento de Erros\n\nTodas as operaes de arquivo incluem mensagens de erro apropriadas com contexto.\n\n### Erros Comuns\n\n**Arquivo no encontrado:**\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Erro: Failed to open 'missing.txt': No such file or directory\n```\n\n**Ler de arquivo fechado:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Erro: Cannot read from closed file 'data.txt'\n```\n\n**Escrever em arquivo somente-leitura:**\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Erro: Cannot write to file 'readonly.txt' opened in read-only mode\n```\n\n**Ler de arquivo somente-escrita:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.read();\n// Erro: Cannot read from file 'output.txt' opened in write-only mode\n```\n\n### Usando try/catch\n\n```hemlock\ntry {\n    let f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    f.close();\n    process(content);\n} catch (e) {\n    print(\"Error reading file: \" + e);\n}\n```\n\n## Gerenciamento de Recursos\n\n### Padro Bsico\n\nSempre feche arquivos explicitamente:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### Com Tratamento de Erros (Recomendado)\n\nUse `finally` para garantir que arquivos sejam fechados mesmo em caso de erro:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Sempre fecha, mesmo em caso de erro\n}\n```\n\n### Mltiplos Arquivos\n\n```hemlock\nlet src = null;\nlet dst = null;\n\ntry {\n    src = open(\"input.txt\", \"r\");\n    dst = open(\"output.txt\", \"w\");\n\n    let content = src.read();\n    dst.write(content);\n} finally {\n    if (src != null) { src.close(); }\n    if (dst != null) { dst.close(); }\n}\n```\n\n### Padro com Funo Auxiliar\n\n```hemlock\nfn with_file(path: string, mode: string, callback) {\n    let f = open(path, mode);\n    try {\n        return callback(f);\n    } finally {\n        f.close();\n    }\n}\n\n// Uso:\nwith_file(\"data.txt\", \"r\", fn(f) {\n    return f.read();\n});\n```\n\n## Referncia Completa da API\n\n### Funes\n\n| Funo | Parmetros | Retorno | Descrio |\n|--------|------------|---------|-----------|\n| `open(path, mode?)` | path: string, mode?: string | File | Abre arquivo (modo padro \"r\") |\n\n### Mtodos\n\n| Mtodo | Parmetros | Retorno | Descrio |\n|--------|------------|---------|-----------|\n| `read(size?)` | size?: i32 | string | L texto (tudo ou bytes especificados) |\n| `read_bytes(size)` | size: i32 | buffer | L dados binrios |\n| `write(data)` | data: string | i32 | Escreve texto, retorna bytes escritos |\n| `write_bytes(data)` | data: buffer | i32 | Escreve dados binrios, retorna bytes escritos |\n| `seek(position)` | position: i32 | i32 | Posiciona na posio, retorna nova posio |\n| `tell()` | - | i32 | Obtm posio atual |\n| `close()` | - | null | Fecha arquivo (idempotente) |\n\n### Propriedades (Somente Leitura)\n\n| Propriedade | Tipo | Descrio |\n|-------------|------|-----------|\n| `path` | string | Caminho do arquivo |\n| `mode` | string | Modo de abertura |\n| `closed` | bool | Se o arquivo est fechado |\n\n## Padres Comuns\n\n### Ler Arquivo Inteiro\n\n```hemlock\nfn read_file(path: string): string {\n    let f = open(path, \"r\");\n    try {\n        return f.read();\n    } finally {\n        f.close();\n    }\n}\n\nlet content = read_file(\"config.json\");\n```\n\n### Escrever Arquivo Inteiro\n\n```hemlock\nfn write_file(path: string, content: string) {\n    let f = open(path, \"w\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\");\n```\n\n### Adicionar ao Arquivo\n\n```hemlock\nfn append_file(path: string, content: string) {\n    let f = open(path, \"a\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nappend_file(\"log.txt\", \"[INFO] Event occurred\\n\");\n```\n\n### Ler Linhas\n\n```hemlock\nfn read_lines(path: string) {\n    let f = open(path, \"r\");\n    try {\n        let content = f.read();\n        return content.split(\"\\n\");\n    } finally {\n        f.close();\n    }\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### Processar Arquivo Grande em Chunks\n\n```hemlock\nfn process_large_file(path: string) {\n    let f = open(path, \"r\");\n    try {\n        while (true) {\n            let chunk = f.read(4096);  // Chunks de 4KB\n            if (chunk == \"\") { break; }\n\n            // Processar chunk\n            process_chunk(chunk);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n### Copiar Arquivo Binrio\n\n```hemlock\nfn copy_file(src_path: string, dst_path: string) {\n    let src = null;\n    let dst = null;\n\n    try {\n        src = open(src_path, \"r\");\n        dst = open(dst_path, \"w\");\n\n        while (true) {\n            let chunk = src.read_bytes(4096);\n            if (chunk.length == 0) { break; }\n\n            dst.write_bytes(chunk);\n        }\n    } finally {\n        if (src != null) { src.close(); }\n        if (dst != null) { dst.close(); }\n    }\n}\n\ncopy_file(\"input.dat\", \"output.dat\");\n```\n\n### Truncar Arquivo\n\n```hemlock\nfn truncate_file(path: string) {\n    let f = open(path, \"w\");  // Modo \"w\" trunca\n    f.close();\n}\n\ntruncate_file(\"empty_me.txt\");\n```\n\n### Leitura com Acesso Aleatrio\n\n```hemlock\nfn read_at_offset(path: string, offset: i32, size: i32): string {\n    let f = open(path, \"r\");\n    try {\n        f.seek(offset);\n        return f.read(size);\n    } finally {\n        f.close();\n    }\n}\n\nlet data = read_at_offset(\"records.dat\", 1000, 100);\n```\n\n## Melhores Prticas\n\n### 1. Sempre Use try/finally\n\n```hemlock\n// Bom\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();\n}\n\n// Ruim - arquivo pode no fechar em caso de erro\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprocess(content);  // Se isso lanar, arquivo vaza\nf.close();\n```\n\n### 2. Verifique Estado do Arquivo Antes de Operaes\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... usar contedo\n}\n\nf.close();\n```\n\n### 3. Use o Modo Apropriado\n\n```hemlock\n// Apenas leitura? Use \"r\"\nlet f = open(\"config.json\", \"r\");\n\n// Substituir completamente? Use \"w\"\nlet f = open(\"output.txt\", \"w\");\n\n// Adicionar ao final? Use \"a\"\nlet f = open(\"log.txt\", \"a\");\n```\n\n### 4. Trate Erros Graciosamente\n\n```hemlock\nfn safe_read_file(path: string): string {\n    try {\n        let f = open(path, \"r\");\n        try {\n            return f.read();\n        } finally {\n            f.close();\n        }\n    } catch (e) {\n        print(\"Warning: Could not read \" + path + \": \" + e);\n        return \"\";\n    }\n}\n```\n\n### 5. Feche Arquivos na Ordem Inversa de Abertura\n\n```hemlock\nlet f1 = null;\nlet f2 = null;\nlet f3 = null;\n\ntry {\n    f1 = open(\"file1.txt\", \"r\");\n    f2 = open(\"file2.txt\", \"r\");\n    f3 = open(\"file3.txt\", \"r\");\n\n    // ... usar arquivos\n} finally {\n    // Fechar na ordem inversa\n    if (f3 != null) { f3.close(); }\n    if (f2 != null) { f2.close(); }\n    if (f1 != null) { f1.close(); }\n}\n```\n\n### 6. Evite Ler Arquivos Grandes Completamente\n\n```hemlock\n// Ruim para arquivos grandes\nlet f = open(\"huge.log\", \"r\");\nlet content = f.read();  // Carrega arquivo inteiro na memria\nf.close();\n\n// Bom - processar em chunks\nlet f = open(\"huge.log\", \"r\");\ntry {\n    while (true) {\n        let chunk = f.read(4096);\n        if (chunk == \"\") { break; }\n        process_chunk(chunk);\n    }\n} finally {\n    f.close();\n}\n```\n\n## Resumo\n\nA API de E/S de arquivos do Hemlock oferece:\n\n- Operaes de arquivo simples e explcitas\n- Suporte a texto e binrio\n- Acesso aleatrio com seek/tell\n- Mensagens de erro claras com contexto\n- Operao close idempotente\n\nLembre-se:\n- Sempre feche arquivos manualmente\n- Use try/finally para garantir segurana de recursos\n- Escolha o modo de abertura apropriado\n- Trate erros graciosamente\n- Processe arquivos grandes em chunks\n"}, "Tpicos Avanados -> Memory Ownership": {"id": "advanced-memory-ownership", "content": "# Propriedade de Memria no Hemlock\n\n> \"Ns te damos as ferramentas para ser seguro, mas no te foramos a us-las.\"\n\nEste documento descreve a semntica de propriedade de memria no Hemlock, cobrindo tanto a memria gerenciada pelo programador quanto os valores gerenciados pelo runtime.\n\n## ndice\n\n1. [O Contrato](#o-contrato)\n2. [Memria Gerenciada pelo Programador](#memria-gerenciada-pelo-programador)\n3. [Valores Gerenciados pelo Runtime](#valores-gerenciados-pelo-runtime)\n4. [Pontos de Transferncia de Propriedade](#pontos-de-transferncia-de-propriedade)\n5. [Async e Concorrncia](#async-e-concorrncia)\n6. [Regras de Memria FFI](#regras-de-memria-ffi)\n7. [Segurana de Excees](#segurana-de-excees)\n8. [Melhores Prticas](#melhores-prticas)\n\n---\n\n## O Contrato\n\nHemlock tem uma diviso clara de responsabilidade no gerenciamento de memria:\n\n| Tipo de Memria | Gerenciado Por | Mtodo de Limpeza |\n|-----------------|----------------|-------------------|\n| Ponteiros brutos (`ptr`) | **Programador** | `free(ptr)` |\n| Buffers (`buffer`) | **Programador** | `free(buf)` |\n| Strings, Arrays, Objetos | **Runtime** | Automtico (contagem de referncias) |\n| Funes, Closures | **Runtime** | Automtico (contagem de referncias) |\n| Tasks, Channels | **Runtime** | Automtico (contagem de referncias) |\n\n**O princpio central:** Se voc aloca explicitamente, voc libera explicitamente. Todo o resto  tratado automaticamente.\n\n---\n\n## Memria Gerenciada pelo Programador\n\n### Ponteiros Brutos\n\n```hemlock\nlet p = alloc(64);       // Alocar 64 bytes\nmemset(p, 0, 64);        // Inicializar\n// ... usar a memria ...\nfree(p);                 // Sua responsabilidade!\n```\n\n**Regras:**\n- `alloc()` retorna memria que voc possui\n- Voc deve chamar `free()` quando terminar\n- Double-free causar crash (por design)\n- Use-after-free  comportamento indefinido\n- Aritmtica de ponteiros  permitida mas no verificada\n\n### Alocao Tipada\n\n```hemlock\nlet arr = talloc(\"i32\", 100);  // Alocar 100 i32s (400 bytes)\nptr_write_i32(arr, 0, 42);     // Escrever no ndice 0\nlet val = ptr_read_i32(arr, 0); // Ler do ndice 0\nfree(arr);                      // Ainda  sua responsabilidade\n```\n\n### Buffers (Alternativa Segura)\n\n```hemlock\nlet buf = buffer(64);    // Buffer com verificao de limites\nbuf[0] = 42;             // Indexao segura\n// buf[100] = 1;         // Erro em tempo de execuo: fora dos limites\nfree(buf);               // Ainda precisa de free explcito\n```\n\n**Diferena chave:** Buffers fornecem verificao de limites, ponteiros brutos no.\n\n---\n\n## Valores Gerenciados pelo Runtime\n\n### Contagem de Referncias\n\nValores alocados no heap usam contagem de referncias atmica:\n\n```hemlock\nlet s1 = \"hello\";        // String alocada, refcount = 1\nlet s2 = s1;             // s2 compartilha s1, refcount = 2\n// Quando ambos saem do escopo, refcount  0, memria liberada\n```\n\n**Tipos com contagem de referncias:**\n- `string` - Texto UTF-8\n- `array` - Arrays dinmicos\n- `object` - Objetos chave-valor\n- `function` - Closures\n- `task` - Handles de tasks async\n- `channel` - Canais de comunicao\n\n### Deteco de Ciclos\n\nO runtime trata ciclos em grafos de objetos:\n\n```hemlock\nlet a = { ref: null };\nlet b = { ref: a };\na.ref = b;               // Ciclo: a  b  a\n// O runtime usa conjuntos visitados para detectar e quebrar ciclos durante a limpeza\n```\n\n---\n\n## Pontos de Transferncia de Propriedade\n\n### Binding de Variveis\n\n```hemlock\nlet x = [1, 2, 3];       // Array criado com refcount 1\n                         // x possui a referncia\n```\n\n### Retornos de Funes\n\n```hemlock\nfn make_array() {\n    return [1, 2, 3];    // Propriedade do array transferida para o chamador\n}\nlet arr = make_array();  // arr agora possui a referncia\n```\n\n### Atribuio\n\n```hemlock\nlet a = \"hello\";\nlet b = a;               // Referncia compartilhada (refcount incrementado)\nb = \"world\";             // a ainda tem \"hello\", b tem \"world\"\n```\n\n### Operaes de Channel\n\n```hemlock\nlet ch = channel(10);\nch.send(\"message\");      // Valor copiado para o buffer do channel\n                         // Original ainda vlido\n\nlet msg = ch.recv();     // Recebe propriedade do channel\n```\n\n### Spawning de Tasks\n\n```hemlock\nlet data = { x: 1 };\nlet task = spawn(worker, data);  // data  COPIADO PROFUNDAMENTE para isolamento\ndata.x = 2;                       // Seguro - task tem sua prpria cpia\nlet result = join(task);          // Propriedade do result transferida para o chamador\n```\n\n---\n\n## Async e Concorrncia\n\n### Isolamento de Threads\n\nTasks spawnadas recebem **cpias profundas** de argumentos mutveis:\n\n```hemlock\nasync fn worker(data) {\n    data.x = 100;        // Modifica apenas a cpia do task\n    return data;\n}\n\nlet obj = { x: 1 };\nlet task = spawn(worker, obj);\nobj.x = 2;               // Seguro - no afeta o task\nlet result = join(task);\nprint(obj.x);            // 2 (no alterado pelo task)\nprint(result.x);         // 100 (cpia modificada do task)\n```\n\n### Objetos de Coordenao Compartilhados\n\nAlguns tipos so compartilhados por referncia (no copiados):\n- **Channels** - Para comunicao entre tasks\n- **Tasks** - Para coordenao (join/detach)\n\n```hemlock\nlet ch = channel(1);\nspawn(producer, ch);     // Mesmo channel, no uma cpia\nspawn(consumer, ch);     // Ambos os tasks compartilham o channel\n```\n\n### Resultados de Tasks\n\n```hemlock\nlet task = spawn(compute);\nlet result = join(task);  // Chamador possui o resultado\n                          // Referncia do task  liberada quando o task  liberado\n```\n\n### Tasks Desacopladas\n\n```hemlock\ndetach(spawn(background_work));\n// Task roda independentemente\n// Resultado  liberado automaticamente quando o task completa\n// Sem leak mesmo que ningum chame join()\n```\n\n---\n\n## Regras de Memria FFI\n\n### Passando para Funes C\n\n```hemlock\nextern fn strlen(s: string): i32;\n\nlet s = \"hello\";\nlet len = strlen(s);     // Hemlock retm a propriedade\n                         // String  vlida durante a chamada\n                         // Funo C NO deve liber-la\n```\n\n### Recebendo de Funes C\n\n```hemlock\nextern fn strdup(s: string): ptr;\n\nlet copy = strdup(\"hello\");  // C alocou esta memria\nfree(copy);                   // Sua responsabilidade liberar\n```\n\n### Passagem de Structs (Apenas Compilador)\n\n```hemlock\n// Definir layout de struct C\nffi_struct Point { x: f64, y: f64 }\n\nextern fn make_point(x: f64, y: f64): Point;\n\nlet p = make_point(1.0, 2.0);  // Retornado por valor, copiado\n                                // No precisa de limpeza para structs na stack\n```\n\n### Memria de Callbacks\n\n```hemlock\n// Quando C chama de volta para Hemlock:\n// - Argumentos pertencem a C (no liberar)\n// - Propriedade do valor de retorno transferida para C\n```\n\n---\n\n## Segurana de Excees\n\n### Garantias\n\nO runtime fornece estas garantias:\n\n1. **Sem leak em sada normal** - Todos os valores gerenciados pelo runtime so limpos\n2. **Sem leak em exceo** - Temporrios so liberados durante o stack unwinding\n3. **Defer executa em exceo** - Cdigo de limpeza  executado\n\n### Avaliao de Expresses\n\n```hemlock\n// Se isso lanar durante a criao do array:\nlet arr = [f(), g(), h()];  // Array parcial  liberado\n\n// Se isso lanar durante a chamada de funo:\nfoo(a(), b(), c());         // Args previamente avaliados so liberados\n```\n\n### Defer para Limpeza\n\n```hemlock\nfn process_file() {\n    let f = open(\"data.txt\", \"r\");\n    defer f.close();         // Executa no return OU exceo\n\n    let data = f.read();\n    if (data == \"\") {\n        throw \"Empty file\";  // f.close() ainda executa!\n    }\n    return data;\n}\n```\n\n---\n\n## Melhores Prticas\n\n### 1. Prefira Tipos Gerenciados pelo Runtime\n\n```hemlock\n// Prefira isto:\nlet data = [1, 2, 3, 4, 5];\n\n// A isto (a menos que precise de controle de baixo nvel):\nlet data = talloc(\"i32\", 5);\n// ... deve lembrar de liberar ...\n```\n\n### 2. Use Defer para Memria Manual\n\n```hemlock\nfn process() {\n    let buf = alloc(1024);\n    defer free(buf);        // Limpeza garantida\n\n    // ... usar buf ...\n    // No precisa liberar em cada ponto de retorno\n}\n```\n\n### 3. Evite Ponteiros Brutos em Async\n\n```hemlock\n// ERRADO - ponteiro pode ser liberado antes do task completar\nlet p = alloc(64);\nspawn(worker, p);          // Task obtm o valor do ponteiro\nfree(p);                   // Ops! Task ainda est usando\n\n// CERTO - use channels ou copie os dados\nlet ch = channel(1);\nlet data = buffer(64);\n// ... preencher data ...\nch.send(data);             // Cpia profunda\nspawn(worker, ch);\nfree(data);                // Seguro - task tem sua prpria cpia\n```\n\n### 4. Feche Channels Quando Terminar\n\n```hemlock\nlet ch = channel(10);\n// ... usar channel ...\nch.close();                // Drena e libera valores no buffer\n```\n\n### 5. Join ou Detach Tasks\n\n```hemlock\nlet task = spawn(work);\n\n// Opo 1: Esperar o resultado\nlet result = join(task);\n\n// Opo 2: Fire and forget\n// detach(task);\n\n// NO: Deixar o handle do task sair do escopo sem join ou detach\n// (Ser limpo, mas o resultado pode ter leak)\n```\n\n---\n\n## Depurao de Problemas de Memria\n\n### Habilitar ASAN\n\n```bash\nmake asan\nASAN_OPTIONS=detect_leaks=1 ./hemlock script.hml\n```\n\n### Executar Testes de Regresso de Leaks\n\n```bash\nmake leak-regression       # Suite completa\nmake leak-regression-quick # Pular teste exaustivo\n```\n\n### Valgrind\n\n```bash\nmake valgrind-check FILE=script.hml\n```\n\n---\n\n## Resumo\n\n| Operao | Comportamento de Memria |\n|----------|-------------------------|\n| `alloc(n)` | Aloca, voc libera |\n| `buffer(n)` | Aloca com verificao de limites, voc libera |\n| `\"string\"` | Runtime gerencia |\n| `[array]` | Runtime gerencia |\n| `{object}` | Runtime gerencia |\n| `spawn(fn)` | Copia profundamente args, runtime gerencia task |\n| `join(task)` | Chamador possui resultado |\n| `detach(task)` | Runtime libera resultado quando terminado |\n| `ch.send(v)` | Copia valor para o channel |\n| `ch.recv()` | Chamador possui valor recebido |\n| `ch.close()` | Drena e libera valores no buffer |\n"}, "Tpicos Avanados -> Operaes Atmicas": {"id": "advanced-atomics", "content": "# Operaes Atmicas\n\nHemlock oferece operaes atmicas para **programao concorrente lock-free**. Essas operaes permitem manipular memria compartilhada com segurana entre mltiplas threads, sem necessidade de locks ou mutexes tradicionais.\n\n## ndice\n\n- [Viso Geral](#viso-geral)\n- [Quando Usar Operaes Atmicas](#quando-usar-operaes-atmicas)\n- [Modelo de Memria](#modelo-de-memria)\n- [Load e Store Atmicos](#load-e-store-atmicos)\n- [Operaes Fetch-and-Modify](#operaes-fetch-and-modify)\n- [Compare-and-Swap (CAS)](#compare-and-swap-cas)\n- [Exchange Atmico](#exchange-atmico)\n- [Barreiras de Memria](#barreiras-de-memria)\n- [Referncia de Funes](#referncia-de-funes)\n- [Padres Comuns](#padres-comuns)\n- [Melhores Prticas](#melhores-prticas)\n- [Limitaes](#limitaes)\n\n---\n\n## Viso Geral\n\nOperaes atmicas so operaes **indivisveis** que completam sem possibilidade de interrupo. Quando uma thread executa uma operao atmica, outras threads no podem observar um estado parcialmente completado da operao.\n\n**Caractersticas Principais:**\n- Todas as operaes usam **consistncia sequencial** (`memory_order_seq_cst`)\n- Tipos suportados: **i32** e **i64**\n- Operaes funcionam em ponteiros brutos alocados via `alloc()`\n- Garantia de thread-safety sem locks explcitos\n\n**Operaes Disponveis:**\n- Load/Store - leitura e escrita atmica de valores\n- Add/Sub - operaes aritmticas que retornam o valor antigo\n- And/Or/Xor - operaes bitwise que retornam o valor antigo\n- CAS - compare-and-swap para atualizaes condicionais\n- Exchange - troca atmica de valores\n- Fence - barreira de memria completa\n\n---\n\n## Quando Usar Operaes Atmicas\n\n**Use operaes atmicas para:**\n- Contadores compartilhados entre tarefas (ex: contagem de requisies, rastreamento de progresso)\n- Flags e indicadores de estado\n- Estruturas de dados lock-free\n- Primitivas de sincronizao simples\n- Cdigo concorrente crtico para desempenho\n\n**Use canais em vez disso para:**\n- Passar dados complexos entre tarefas\n- Implementar padres produtor-consumidor\n- Quando semntica de passagem de mensagens  necessria\n\n**Exemplo de Uso - Contador Compartilhado:**\n```hemlock\n// Alocar contador compartilhado\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nasync fn worker(counter: ptr, id: i32) {\n    let i = 0;\n    while (i < 1000) {\n        atomic_add_i32(counter, 1);\n        i = i + 1;\n    }\n}\n\n// Criar mltiplos workers\nlet t1 = spawn(worker, counter, 1);\nlet t2 = spawn(worker, counter, 2);\nlet t3 = spawn(worker, counter, 3);\n\njoin(t1);\njoin(t2);\njoin(t3);\n\n// Contador ser exatamente 3000 (sem corrida de dados)\nprint(atomic_load_i32(counter));\n\nfree(counter);\n```\n\n---\n\n## Modelo de Memria\n\nTodas as operaes atmicas do Hemlock usam **consistncia sequencial** (`memory_order_seq_cst`), fornecendo as garantias mais fortes de ordenao de memria:\n\n1. **Atomicidade**: Cada operao  indivisvel\n2. **Ordenao Global**: Todas as threads veem a mesma ordem de operaes\n3. **Sem Reordenao**: Operaes no so reordenadas pelo compilador ou CPU\n\nIsso torna o raciocnio sobre cdigo concorrente mais simples, mas pode ter algum custo de desempenho comparado a ordenaes de memria mais fracas.\n\n---\n\n## Load e Store Atmicos\n\n### atomic_load_i32 / atomic_load_i64\n\nL atomicamente um valor da memria.\n\n**Assinatura:**\n```hemlock\natomic_load_i32(ptr: ptr): i32\natomic_load_i64(ptr: ptr): i64\n```\n\n**Parmetros:**\n- `ptr` - ponteiro para a localizao de memria (deve estar corretamente alinhado)\n\n**Retorna:** O valor na localizao de memria\n\n**Exemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\n\nlet value = atomic_load_i32(p);\nprint(value);  // 42\n\nfree(p);\n```\n\n---\n\n### atomic_store_i32 / atomic_store_i64\n\nEscreve atomicamente um valor na memria.\n\n**Assinatura:**\n```hemlock\natomic_store_i32(ptr: ptr, value: i32): null\natomic_store_i64(ptr: ptr, value: i64): null\n```\n\n**Parmetros:**\n- `ptr` - ponteiro para a localizao de memria\n- `value` - valor a armazenar\n\n**Retorna:** `null`\n\n**Exemplo:**\n```hemlock\nlet p = alloc(8);\n\natomic_store_i64(p, 5000000000);\nprint(atomic_load_i64(p));  // 5000000000\n\nfree(p);\n```\n\n---\n\n## Operaes Fetch-and-Modify\n\nEssas operaes modificam atomicamente um valor e retornam o valor **antigo** (anterior).\n\n### atomic_add_i32 / atomic_add_i64\n\nAdio atmica.\n\n**Assinatura:**\n```hemlock\natomic_add_i32(ptr: ptr, value: i32): i32\natomic_add_i64(ptr: ptr, value: i64): i64\n```\n\n**Retorna:** Valor **antigo** (antes da adio)\n\n**Exemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_add_i32(p, 10);\nprint(old);                    // 100 (valor antigo)\nprint(atomic_load_i32(p));     // 110 (valor novo)\n\nfree(p);\n```\n\n---\n\n### atomic_sub_i32 / atomic_sub_i64\n\nSubtrao atmica.\n\n**Assinatura:**\n```hemlock\natomic_sub_i32(ptr: ptr, value: i32): i32\natomic_sub_i64(ptr: ptr, value: i64): i64\n```\n\n**Retorna:** Valor **antigo** (antes da subtrao)\n\n**Exemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_sub_i32(p, 25);\nprint(old);                    // 100 (valor antigo)\nprint(atomic_load_i32(p));     // 75 (valor novo)\n\nfree(p);\n```\n\n---\n\n### atomic_and_i32 / atomic_and_i64\n\nAND bitwise atmico.\n\n**Assinatura:**\n```hemlock\natomic_and_i32(ptr: ptr, value: i32): i32\natomic_and_i64(ptr: ptr, value: i64): i64\n```\n\n**Retorna:** Valor **antigo** (antes da operao AND)\n\n**Exemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xFF);  // Binrio 255: 11111111\n\nlet old = atomic_and_i32(p, 0x0F);  // AND com 00001111\nprint(old);                    // 255 (valor antigo)\nprint(atomic_load_i32(p));     // 15 (0xFF & 0x0F = 0x0F)\n\nfree(p);\n```\n\n---\n\n### atomic_or_i32 / atomic_or_i64\n\nOR bitwise atmico.\n\n**Assinatura:**\n```hemlock\natomic_or_i32(ptr: ptr, value: i32): i32\natomic_or_i64(ptr: ptr, value: i64): i64\n```\n\n**Retorna:** Valor **antigo** (antes da operao OR)\n\n**Exemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0x0F);  // Binrio 15: 00001111\n\nlet old = atomic_or_i32(p, 0xF0);  // OR com 11110000\nprint(old);                    // 15 (valor antigo)\nprint(atomic_load_i32(p));     // 255 (0x0F | 0xF0 = 0xFF)\n\nfree(p);\n```\n\n---\n\n### atomic_xor_i32 / atomic_xor_i64\n\nXOR bitwise atmico.\n\n**Assinatura:**\n```hemlock\natomic_xor_i32(ptr: ptr, value: i32): i32\natomic_xor_i64(ptr: ptr, value: i64): i64\n```\n\n**Retorna:** Valor **antigo** (antes da operao XOR)\n\n**Exemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xAA);  // Binrio 170: 10101010\n\nlet old = atomic_xor_i32(p, 0xFF);  // XOR com 11111111\nprint(old);                    // 170 (valor antigo)\nprint(atomic_load_i32(p));     // 85 (0xAA ^ 0xFF = 0x55)\n\nfree(p);\n```\n\n---\n\n## Compare-and-Swap (CAS)\n\nA operao atmica mais poderosa. Compara atomicamente o valor atual com um valor esperado e, se coincidirem, substitui pelo novo valor.\n\n### atomic_cas_i32 / atomic_cas_i64\n\n**Assinatura:**\n```hemlock\natomic_cas_i32(ptr: ptr, expected: i32, desired: i32): bool\natomic_cas_i64(ptr: ptr, expected: i64, desired: i64): bool\n```\n\n**Parmetros:**\n- `ptr` - ponteiro para a localizao de memria\n- `expected` - valor que esperamos encontrar\n- `desired` - valor a armazenar se expected coincidir\n\n**Retorna:**\n- `true` - troca bem-sucedida (valor era `expected`, agora  `desired`)\n- `false` - troca falhou (valor no era `expected`, permanece inalterado)\n\n**Exemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\n// CAS bem-sucedido: valor  100, troca para 999\nlet success1 = atomic_cas_i32(p, 100, 999);\nprint(success1);               // true\nprint(atomic_load_i32(p));     // 999\n\n// CAS falhou: valor  999, no 100\nlet success2 = atomic_cas_i32(p, 100, 888);\nprint(success2);               // false\nprint(atomic_load_i32(p));     // 999 (inalterado)\n\nfree(p);\n```\n\n**Casos de Uso:**\n- Implementar locks e semforos\n- Estruturas de dados lock-free\n- Controle de concorrncia otimista\n- Atualizaes condicionais atmicas\n\n---\n\n## Exchange Atmico\n\nTroca atomicamente valores, retornando o valor antigo.\n\n### atomic_exchange_i32 / atomic_exchange_i64\n\n**Assinatura:**\n```hemlock\natomic_exchange_i32(ptr: ptr, value: i32): i32\natomic_exchange_i64(ptr: ptr, value: i64): i64\n```\n\n**Parmetros:**\n- `ptr` - ponteiro para a localizao de memria\n- `value` - novo valor a armazenar\n\n**Retorna:** Valor **antigo** (antes da troca)\n\n**Exemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_exchange_i32(p, 200);\nprint(old);                    // 100 (valor antigo)\nprint(atomic_load_i32(p));     // 200 (valor novo)\n\nfree(p);\n```\n\n---\n\n## Barreiras de Memria\n\nBarreira de memria completa, garantindo que todas as operaes de memria antes da barreira sejam visveis para todas as threads antes de qualquer operao aps a barreira ser executada.\n\n### atomic_fence\n\n**Assinatura:**\n```hemlock\natomic_fence(): null\n```\n\n**Retorna:** `null`\n\n**Exemplo:**\n```hemlock\n// Garantir que todas as escritas anteriores so visveis para outras threads\natomic_fence();\n```\n\n**Nota:** Na maioria dos casos, voc no precisa de fences explcitos pois todas as operaes atmicas j usam consistncia sequencial. Fences so teis quando voc precisa sincronizar operaes de memria no-atmicas.\n\n---\n\n## Referncia de Funes\n\n### Operaes i32\n\n| Funo | Assinatura | Retorno | Descrio |\n|--------|------------|---------|-----------|\n| `atomic_load_i32` | `(ptr)` | `i32` | Carrega valor atomicamente |\n| `atomic_store_i32` | `(ptr, value)` | `null` | Armazena valor atomicamente |\n| `atomic_add_i32` | `(ptr, value)` | `i32` | Adiciona e retorna valor antigo |\n| `atomic_sub_i32` | `(ptr, value)` | `i32` | Subtrai e retorna valor antigo |\n| `atomic_and_i32` | `(ptr, value)` | `i32` | AND bitwise e retorna valor antigo |\n| `atomic_or_i32` | `(ptr, value)` | `i32` | OR bitwise e retorna valor antigo |\n| `atomic_xor_i32` | `(ptr, value)` | `i32` | XOR bitwise e retorna valor antigo |\n| `atomic_cas_i32` | `(ptr, expected, desired)` | `bool` | Compare-and-swap |\n| `atomic_exchange_i32` | `(ptr, value)` | `i32` | Troca e retorna valor antigo |\n\n### Operaes i64\n\n| Funo | Assinatura | Retorno | Descrio |\n|--------|------------|---------|-----------|\n| `atomic_load_i64` | `(ptr)` | `i64` | Carrega valor atomicamente |\n| `atomic_store_i64` | `(ptr, value)` | `null` | Armazena valor atomicamente |\n| `atomic_add_i64` | `(ptr, value)` | `i64` | Adiciona e retorna valor antigo |\n| `atomic_sub_i64` | `(ptr, value)` | `i64` | Subtrai e retorna valor antigo |\n| `atomic_and_i64` | `(ptr, value)` | `i64` | AND bitwise e retorna valor antigo |\n| `atomic_or_i64` | `(ptr, value)` | `i64` | OR bitwise e retorna valor antigo |\n| `atomic_xor_i64` | `(ptr, value)` | `i64` | XOR bitwise e retorna valor antigo |\n| `atomic_cas_i64` | `(ptr, expected, desired)` | `bool` | Compare-and-swap |\n| `atomic_exchange_i64` | `(ptr, value)` | `i64` | Troca e retorna valor antigo |\n\n### Barreira de Memria\n\n| Funo | Assinatura | Retorno | Descrio |\n|--------|------------|---------|-----------|\n| `atomic_fence` | `()` | `null` | Barreira de memria completa |\n\n---\n\n## Padres Comuns\n\n### Padro: Contador Atmico\n\n```hemlock\n// Contador thread-safe\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nfn increment(): i32 {\n    return atomic_add_i32(counter, 1);\n}\n\nfn decrement(): i32 {\n    return atomic_sub_i32(counter, 1);\n}\n\nfn get_count(): i32 {\n    return atomic_load_i32(counter);\n}\n\n// Uso\nincrement();  // Retorna 0 (valor antigo)\nincrement();  // Retorna 1\nincrement();  // Retorna 2\nprint(get_count());  // 3\n\nfree(counter);\n```\n\n### Padro: Spinlock\n\n```hemlock\n// Implementao simples de spinlock\nlet lock = alloc(4);\nptr_write_i32(lock, 0);  // 0 = desbloqueado, 1 = bloqueado\n\nfn acquire() {\n    // Gira at conseguir definir lock de 0 para 1\n    while (!atomic_cas_i32(lock, 0, 1)) {\n        // Espera ocupada\n    }\n}\n\nfn release() {\n    atomic_store_i32(lock, 0);\n}\n\n// Uso\nacquire();\n// ... seo crtica ...\nrelease();\n\nfree(lock);\n```\n\n### Padro: Inicializao nica\n\n```hemlock\nlet initialized = alloc(4);\nptr_write_i32(initialized, 0);  // 0 = no inicializado, 1 = inicializado\n\nfn ensure_initialized() {\n    // Tenta ser o inicializador\n    if (atomic_cas_i32(initialized, 0, 1)) {\n        // Vencemos a corrida, executar inicializao\n        do_expensive_init();\n    }\n    // Caso contrrio, j foi inicializado\n}\n```\n\n### Padro: Flag Atmica\n\n```hemlock\nlet flag = alloc(4);\nptr_write_i32(flag, 0);\n\nfn set_flag() {\n    atomic_store_i32(flag, 1);\n}\n\nfn clear_flag() {\n    atomic_store_i32(flag, 0);\n}\n\nfn test_and_set(): bool {\n    // Retorna true se flag j estava definida\n    return atomic_exchange_i32(flag, 1) == 1;\n}\n\nfn check_flag(): bool {\n    return atomic_load_i32(flag) == 1;\n}\n```\n\n### Padro: Contador Limitado\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\nlet max_value = 100;\n\nfn try_increment(): bool {\n    while (true) {\n        let current = atomic_load_i32(counter);\n        if (current >= max_value) {\n            return false;  // Mximo atingido\n        }\n        if (atomic_cas_i32(counter, current, current + 1)) {\n            return true;  // Incrementado com sucesso\n        }\n        // CAS falhou, outra thread modificou o valor - tentar novamente\n    }\n}\n```\n\n---\n\n## Melhores Prticas\n\n### 1. Use Alinhamento Correto\n\nPonteiros devem estar corretamente alinhados para o tipo de dados:\n- i32: alinhamento de 4 bytes\n- i64: alinhamento de 8 bytes\n\nMemria de `alloc()` geralmente est corretamente alinhada.\n\n### 2. Prefira Abstraes de Nvel Superior\n\nSe possvel, use canais para comunicao entre tarefas. Operaes atmicas so de nvel mais baixo e requerem raciocnio cuidadoso.\n\n```hemlock\n// Prefira isto:\nlet ch = channel(10);\nspawn(fn() { ch.send(result); });\nlet value = ch.recv();\n\n// Em vez de coordenao manual atmica quando apropriado\n```\n\n### 3. Cuidado com o Problema ABA\n\nCAS pode sofrer do problema ABA: o valor muda de A para B e depois volta para A. Seu CAS tem sucesso, mas o estado pode ter mudado no meio.\n\n### 4. Inicialize Antes de Compartilhar\n\nSempre inicialize variveis atmicas antes de criar tarefas que as acessam:\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);  // Inicializar antes de criar tarefa\n\nlet task = spawn(worker, counter);\n```\n\n### 5. Libere Aps Todas as Tarefas Terminarem\n\nNo libere memria atmica enquanto tarefas ainda podem estar acessando-a:\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nlet t1 = spawn(worker, counter);\nlet t2 = spawn(worker, counter);\n\njoin(t1);\njoin(t2);\n\n// Agora seguro para liberar\nfree(counter);\n```\n\n---\n\n## Limitaes\n\n### Limitaes Atuais\n\n1. **Apenas i32 e i64** - Sem operaes atmicas para outros tipos\n2. **Sem atmicos de ponteiro** - No  possvel carregar/armazenar ponteiros atomicamente\n3. **Apenas consistncia sequencial** - Ordenaes de memria mais fracas no disponveis\n4. **Sem floats atmicos** - Use representao inteira se necessrio\n\n### Notas de Plataforma\n\n- Operaes atmicas usam `<stdatomic.h>` do C11 internamente\n- Disponvel em todas as plataformas que suportam POSIX threads\n- Garantidamente lock-free em sistemas modernos de 64 bits\n\n---\n\n## Veja Tambm\n\n- [Assincronismo/Concorrncia](#advanced-async-concurrency) - Criao de tarefas e canais\n- [Gerenciamento de Memria](#language-guide-memory) - Ponteiros e alocao de buffers\n- [API de Memria](#reference-memory-api) - Funes de alocao\n"}, "Tpicos Avanados -> Perfilamento": {"id": "advanced-profiling", "content": "# Perfilamento\n\nHemlock inclui um profiler integrado para **anlise de tempo de CPU**, **rastreamento de memria** e **deteco de vazamentos**. O profiler ajuda a identificar gargalos de desempenho e problemas de memria em seus programas.\n\n## ndice\n\n- [Viso Geral](#viso-geral)\n- [Incio Rpido](#incio-rpido)\n- [Modos de Perfilamento](#modos-de-perfilamento)\n- [Formatos de Sada](#formatos-de-sada)\n- [Deteco de Vazamentos](#deteco-de-vazamentos)\n- [Entendendo os Relatrios](#entendendo-os-relatrios)\n- [Gerao de Flamegraph](#gerao-de-flamegraph)\n- [Melhores Prticas](#melhores-prticas)\n\n---\n\n## Viso Geral\n\nO profiler  acessado atravs do subcomando `profile`:\n\n```bash\nhemlock profile [OPTIONS] <FILE>\n```\n\n**Recursos Principais:**\n- **Perfilamento de CPU** - mede tempo gasto em cada funo (self time e total time)\n- **Perfilamento de Memria** - rastreia todas as alocaes e suas localizaes de origem\n- **Deteco de Vazamentos** - identifica memria que nunca foi liberada\n- **Mltiplos Formatos de Sada** - texto, JSON e sada compatvel com flamegraph\n- **Estatsticas de Memria por Funo** - veja quais funes alocam mais memria\n\n---\n\n## Incio Rpido\n\n### Perfilar Tempo de CPU (Padro)\n\n```bash\nhemlock profile script.hml\n```\n\n### Perfilar Alocaes de Memria\n\n```bash\nhemlock profile --memory script.hml\n```\n\n### Detectar Vazamentos de Memria\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n### Gerar Dados de Flamegraph\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\nflamegraph.pl profile.folded > profile.svg\n```\n\n---\n\n## Modos de Perfilamento\n\n### Perfilamento de CPU (Padro)\n\nMede tempo gasto em cada funo, distinguindo:\n- **Self time** - tempo gasto executando o cdigo da prpria funo\n- **Total time** - self time mais tempo gasto em funes chamadas\n\n```bash\nhemlock profile script.hml\nhemlock profile --cpu script.hml  # Explcito\n```\n\n**Sada de Exemplo:**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 1.234ms\nFunctions called: 5 unique\n\n--- Top 5 by Self Time ---\n\nFunction                        Self      Total   Calls\n--------                        ----      -----   -----\nexpensive_calc              0.892ms    0.892ms     100  (72.3%)\nprocess_data                0.234ms    1.126ms      10  (19.0%)\nhelper                      0.067ms    0.067ms     500  (5.4%)\nmain                        0.041ms    1.234ms       1  (3.3%)\n```\n\n---\n\n### Perfilamento de Memria\n\nRastreia todas as alocaes de memria (`alloc`, `buffer`, `talloc`, `realloc`) e suas localizaes de origem.\n\n```bash\nhemlock profile --memory script.hml\n```\n\n**Sada de Exemplo:**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 0.543ms\nFunctions called: 3 unique\nTotal allocations: 15 (4.2KB)\n\n--- Top 3 by Self Time ---\n\nFunction                        Self      Total   Calls      Alloc      Count\n--------                        ----      -----   -----      -----      -----\nallocator                   0.312ms    0.312ms      10      3.2KB         10  (57.5%)\nbuffer_ops                  0.156ms    0.156ms       5       1KB          5  (28.7%)\nmain                        0.075ms    0.543ms       1        0B          0  (13.8%)\n\n--- Top 10 Allocation Sites ---\n\nLocation                                      Total    Count\n--------                                      -----    -----\nsrc/data.hml:42                               1.5KB        5\nsrc/data.hml:67                               1.0KB       10\nsrc/main.hml:15                               512B         1\n```\n\n---\n\n### Modo de Contagem de Chamadas\n\nModo de overhead mnimo que apenas conta chamadas de funo (sem cronometragem).\n\n```bash\nhemlock profile --calls script.hml\n```\n\n---\n\n## Formatos de Sada\n\n### Texto (Padro)\n\nResumo legvel por humanos com tabelas.\n\n```bash\nhemlock profile script.hml\n```\n\n---\n\n### JSON\n\nFormato legvel por mquina para integrao com outras ferramentas.\n\n```bash\nhemlock profile --json script.hml\n```\n\n**Sada de Exemplo:**\n```json\n{\n  \"total_time_ns\": 1234567,\n  \"function_count\": 5,\n  \"total_alloc_bytes\": 4096,\n  \"total_alloc_count\": 15,\n  \"functions\": [\n    {\n      \"name\": \"expensive_calc\",\n      \"source_file\": \"script.hml\",\n      \"line\": 10,\n      \"self_time_ns\": 892000,\n      \"total_time_ns\": 892000,\n      \"call_count\": 100,\n      \"alloc_bytes\": 0,\n      \"alloc_count\": 0\n    }\n  ],\n  \"alloc_sites\": [\n    {\n      \"source_file\": \"script.hml\",\n      \"line\": 42,\n      \"total_bytes\": 1536,\n      \"alloc_count\": 5,\n      \"current_bytes\": 0\n    }\n  ]\n}\n```\n\n---\n\n### Flamegraph\n\nGera formato de stack colapsado compatvel com [flamegraph.pl](https://github.com/brendangregg/FlameGraph).\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\n\n# Gerar SVG usando flamegraph.pl\nflamegraph.pl profile.folded > profile.svg\n```\n\n**Sada Colapsada de Exemplo:**\n```\nmain;process_data;expensive_calc 892\nmain;process_data;helper 67\nmain;process_data 234\nmain 41\n```\n\n---\n\n## Deteco de Vazamentos\n\nA flag `--leaks` mostra apenas alocaes que nunca foram liberadas, facilitando a identificao de vazamentos de memria.\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n**Programa de Exemplo com Vazamentos:**\n```hemlock\nfn leaky() {\n    let p1 = alloc(100);    // Vazamento - nunca liberado\n    let p2 = alloc(200);    // OK - liberado abaixo\n    free(p2);\n}\n\nfn clean() {\n    let b = buffer(64);\n    free(b);                // Liberado corretamente\n}\n\nleaky();\nclean();\n```\n\n**Sada com --leaks:**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 0.034ms\nFunctions called: 2 unique\nTotal allocations: 3 (388B)\n\n--- Top 2 by Self Time ---\n\nFunction                        Self      Total   Calls      Alloc      Count\n--------                        ----      -----   -----      -----      -----\nleaky                       0.021ms    0.021ms       1       300B          2  (61.8%)\nclean                       0.013ms    0.013ms       1        88B          1  (38.2%)\n\n--- Memory Leaks (1 site) ---\n\nLocation                                     Leaked      Total    Count\n--------                                     ------      -----    -----\nscript.hml:2                                   100B       100B        1\n```\n\nO relatrio de vazamentos mostra:\n- **Leaked** - bytes atualmente no liberados na sada do programa\n- **Total** - total de bytes alocados nesta localizao\n- **Count** - nmero de alocaes nesta localizao\n\n---\n\n## Entendendo os Relatrios\n\n### Estatsticas de Funo\n\n| Coluna | Descrio |\n|--------|-----------|\n| Function | Nome da funo |\n| Self | Tempo gasto na funo (excluindo chamadas) |\n| Total | Tempo incluindo todas as funes chamadas |\n| Calls | Nmero de vezes que a funo foi chamada |\n| Alloc | Total de bytes alocados por esta funo |\n| Count | Nmero de alocaes por esta funo |\n| (%) | Porcentagem do tempo total do programa |\n\n### Sites de Alocao\n\n| Coluna | Descrio |\n|--------|-----------|\n| Location | Arquivo fonte e nmero da linha |\n| Total | Total de bytes alocados nesta localizao |\n| Count | Nmero de alocaes |\n| Leaked | Bytes ainda alocados na sada do programa (apenas --leaks) |\n\n### Unidades de Tempo\n\nO profiler escolhe automaticamente unidades apropriadas:\n- `ns` - nanosegundos (< 1 microssegundo)\n- `us` - microssegundos (< 1 milissegundo)\n- `ms` - milissegundos (< 1 segundo)\n- `s` - segundos\n\n---\n\n## Referncia de Comandos\n\n```\nhemlock profile [OPTIONS] <FILE>\n\nOPTIONS:\n    --cpu           Perfilamento de CPU/tempo (padro)\n    --memory        Perfilamento de alocao de memria\n    --calls         Apenas contagem de chamadas (overhead mnimo)\n    --leaks         Mostrar apenas alocaes no liberadas (implica --memory)\n    --json          Sada em formato JSON\n    --flamegraph    Sada em formato compatvel com flamegraph\n    --top N         Mostrar top N entradas (padro: 20)\n```\n\n---\n\n## Gerao de Flamegraph\n\nFlamegraphs visualizam onde seu programa gasta tempo, com barras mais largas representando mais tempo.\n\n### Gerando um Flamegraph\n\n1. Instalar flamegraph.pl:\n   ```bash\n   git clone https://github.com/brendangregg/FlameGraph\n   ```\n\n2. Perfilar seu programa:\n   ```bash\n   hemlock profile --flamegraph script.hml > profile.folded\n   ```\n\n3. Gerar SVG:\n   ```bash\n   ./FlameGraph/flamegraph.pl profile.folded > profile.svg\n   ```\n\n4. Abrir `profile.svg` em um navegador para visualizao interativa.\n\n### Lendo Flamegraphs\n\n- **Eixo X**: Porcentagem do tempo total (largura = proporo do tempo)\n- **Eixo Y**: Profundidade da call stack (fundo = ponto de entrada, topo = funes folha)\n- **Cores**: Aleatrias, apenas para distino visual\n- **Clique**: Zoom em uma funo para ver suas chamadas\n\n---\n\n## Melhores Prticas\n\n### 1. Perfile Cargas de Trabalho Representativas\n\nUse dados e padres de uso reais para perfilar. Casos de teste pequenos podem no revelar os verdadeiros gargalos.\n\n```bash\n# Bom: perfilar com dados semelhantes a produo\nhemlock profile --memory process_large_file.hml large_input.txt\n\n# Menos til: casos de teste minsculos\nhemlock profile quick_test.hml\n```\n\n### 2. Use --leaks Durante o Desenvolvimento\n\nExecute deteco de vazamentos regularmente para encontrar vazamentos de memria cedo:\n\n```bash\nhemlock profile --leaks my_program.hml\n```\n\n### 3. Compare Antes e Depois das Otimizaes\n\nPerfile antes e depois de otimizaes para medir o impacto:\n\n```bash\n# Antes\nhemlock profile --json script.hml > before.json\n\n# Depois\nhemlock profile --json script.hml > after.json\n\n# Comparar resultados\n```\n\n### 4. Use --top para Programas Grandes\n\nLimite a sada para focar nas funes mais importantes:\n\n```bash\nhemlock profile --top 10 large_program.hml\n```\n\n### 5. Combine com Flamegraphs\n\nPara padres de chamada complexos, flamegraphs fornecem melhor visualizao do que sada de texto:\n\n```bash\nhemlock profile --flamegraph complex_app.hml > app.folded\nflamegraph.pl app.folded > app.svg\n```\n\n---\n\n## Overhead do Profiler\n\nO profiler adiciona algum overhead  execuo do programa:\n\n| Modo | Overhead | Caso de Uso |\n|------|----------|-------------|\n| `--calls` | Mnimo | Apenas contagem de chamadas de funo |\n| `--cpu` | Baixo | Perfilamento de desempenho geral |\n| `--memory` | Moderado | Anlise de memria e deteco de vazamentos |\n\nPara resultados mais precisos, perfile mltiplas vezes e procure padres consistentes.\n\n---\n\n## Veja Tambm\n\n- [Gerenciamento de Memria](#language-guide-memory) - Ponteiros e buffers\n- [API de Memria](#reference-memory-api) - Funes alloc, free, buffer\n- [Assincronismo/Concorrncia](#advanced-async-concurrency) - Perfilando cdigo assncrono\n"}, "Tpicos Avanados -> Sinais": {"id": "advanced-signals", "content": "# Hemlock Tratamento de Sinais\n\nHemlock oferece **tratamento de sinais POSIX** para gerenciar sinais do sistema como SIGINT (Ctrl+C), SIGTERM e sinais personalizados. Isso permite controle de processo de baixo nvel e comunicao entre processos.\n\n## ndice\n\n- [Viso Geral](#viso-geral)\n- [API de Sinais](#api-de-sinais)\n- [Constantes de Sinais](#constantes-de-sinais)\n- [Tratamento Bsico de Sinais](#tratamento-bsico-de-sinais)\n- [Padres Avanados](#padres-avanados)\n- [Comportamento de Handlers de Sinais](#comportamento-de-handlers-de-sinais)\n- [Consideraes de Segurana](#consideraes-de-segurana)\n- [Casos de Uso Comuns](#casos-de-uso-comuns)\n- [Exemplos Completos](#exemplos-completos)\n\n## Viso Geral\n\nO tratamento de sinais permite que programas:\n- Respondam a interrupes do usurio (Ctrl+C, Ctrl+Z)\n- Implementem shutdown gracioso\n- Tratem requisies de terminao\n- Usem sinais personalizados para comunicao entre processos\n- Criem mecanismos de alarme/timer\n\n**Importante:** Seguindo a filosofia do Hemlock, o tratamento de sinais  **inerentemente inseguro**. Handlers podem ser chamados a qualquer momento, interrompendo a execuo normal. O usurio  responsvel pela sincronizao apropriada.\n\n## API de Sinais\n\n### signal(signum, handler_fn)\n\nRegistra uma funo de tratamento de sinal.\n\n**Parmetros:**\n- `signum` (i32) - nmero do sinal (ex: constantes SIGINT, SIGTERM)\n- `handler_fn` (function ou null) - funo a chamar quando o sinal  recebido, ou `null` para resetar ao padro\n\n**Retorna:** Funo handler anterior (ou `null` se nenhuma)\n\n**Exemplo:**\n```hemlock\nfn my_handler(sig) {\n    print(\"Caught signal: \" + typeof(sig));\n}\n\nlet old_handler = signal(SIGINT, my_handler);\n```\n\n**Resetar para padro:**\n```hemlock\nsignal(SIGINT, null);  // Reseta SIGINT para comportamento padro\n```\n\n### raise(signum)\n\nEnvia um sinal para o processo atual.\n\n**Parmetros:**\n- `signum` (i32) - nmero do sinal a enviar\n\n**Retorna:** `null`\n\n**Exemplo:**\n```hemlock\nraise(SIGUSR1);  // Dispara handler SIGUSR1\n```\n\n## Constantes de Sinais\n\nHemlock fornece constantes de sinais POSIX padro como valores i32.\n\n### Interrupo e Terminao\n\n| Constante | Valor | Descrio | Gatilho Comum |\n|-----------|-------|-----------|---------------|\n| `SIGINT` | 2 | Interrupo do teclado | Ctrl+C |\n| `SIGTERM` | 15 | Requisio de terminao | Comando `kill` |\n| `SIGQUIT` | 3 | Quit do teclado | Ctrl+\\ |\n| `SIGHUP` | 1 | Hangup detectado | Terminal fechado |\n| `SIGABRT` | 6 | Sinal de abort | Funo `abort()` |\n\n**Exemplo:**\n```hemlock\nsignal(SIGINT, handle_interrupt);   // Ctrl+C\nsignal(SIGTERM, handle_terminate);  // Comando kill\nsignal(SIGHUP, handle_hangup);      // Terminal fechado\n```\n\n### Sinais Definidos pelo Usurio\n\n| Constante | Valor | Descrio | Caso de Uso |\n|-----------|-------|-----------|-------------|\n| `SIGUSR1` | 10 | Sinal definido pelo usurio 1 | IPC personalizado |\n| `SIGUSR2` | 12 | Sinal definido pelo usurio 2 | IPC personalizado |\n\n**Exemplo:**\n```hemlock\n// Para comunicao personalizada\nsignal(SIGUSR1, reload_config);\nsignal(SIGUSR2, rotate_logs);\n```\n\n### Controle de Processo\n\n| Constante | Valor | Descrio | Nota |\n|-----------|-------|-----------|------|\n| `SIGALRM` | 14 | Timer de alarme | Aps `alarm()` |\n| `SIGCHLD` | 17 | Mudana de estado do filho | Gerenciamento de processo |\n| `SIGCONT` | 18 | Continuar se parado | Retomar aps SIGSTOP |\n| `SIGSTOP` | 19 | Parar processo | **No pode ser capturado** |\n| `SIGTSTP` | 20 | Stop do terminal | Ctrl+Z |\n\n**Exemplo:**\n```hemlock\nsignal(SIGALRM, handle_timeout);\nsignal(SIGCHLD, handle_child_exit);\n```\n\n### Sinais de I/O\n\n| Constante | Valor | Descrio | Quando Enviado |\n|-----------|-------|-----------|----------------|\n| `SIGPIPE` | 13 | Pipe quebrado | Escrita em pipe fechado |\n| `SIGTTIN` | 21 | Leitura de background do terminal | Processo em background l TTY |\n| `SIGTTOU` | 22 | Escrita de background no terminal | Processo em background escreve TTY |\n\n**Exemplo:**\n```hemlock\nsignal(SIGPIPE, handle_broken_pipe);\n```\n\n## Tratamento Bsico de Sinais\n\n### Capturando Ctrl+C\n\n```hemlock\nlet interrupted = false;\n\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n    interrupted = true;\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Programa continua executando...\n// Usurio pressiona Ctrl+C -> handle_interrupt()  chamado\n\nwhile (!interrupted) {\n    // Fazer trabalho...\n}\n\nprint(\"Exiting due to interrupt\");\n```\n\n### Assinatura da Funo Handler\n\nHandlers de sinal recebem um argumento: o nmero do sinal (i32)\n\n```hemlock\nfn my_handler(signum) {\n    print(\"Received signal: \" + typeof(signum));\n    // signum contm o nmero do sinal (ex: 2 para SIGINT)\n\n    if (signum == SIGINT) {\n        print(\"This is SIGINT\");\n    }\n}\n\nsignal(SIGINT, my_handler);\nsignal(SIGTERM, my_handler);  // Mesmo handler para mltiplos sinais\n```\n\n### Mltiplos Handlers de Sinal\n\nDiferentes handlers para diferentes sinais:\n\n```hemlock\nfn handle_int(sig) {\n    print(\"SIGINT received\");\n}\n\nfn handle_term(sig) {\n    print(\"SIGTERM received\");\n}\n\nfn handle_usr1(sig) {\n    print(\"SIGUSR1 received\");\n}\n\nsignal(SIGINT, handle_int);\nsignal(SIGTERM, handle_term);\nsignal(SIGUSR1, handle_usr1);\n```\n\n### Resetar para Comportamento Padro\n\nPasse `null` como handler para resetar para comportamento padro:\n\n```hemlock\n// Registrar handler personalizado\nsignal(SIGINT, my_handler);\n\n// Depois, resetar para padro (terminar em SIGINT)\nsignal(SIGINT, null);\n```\n\n### Disparar Sinal Manualmente\n\nEnvie um sinal para seu prprio processo:\n\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\n// Disparar handler manualmente\nraise(SIGUSR1);\nraise(SIGUSR1);\n\nprint(count);  // 2\n```\n\n## Padres Avanados\n\n### Padro de Shutdown Gracioso\n\nPadro comum para limpeza na terminao:\n\n```hemlock\nlet should_exit = false;\n\nfn handle_shutdown(sig) {\n    print(\"Shutting down gracefully...\");\n    should_exit = true;\n}\n\nsignal(SIGINT, handle_shutdown);\nsignal(SIGTERM, handle_shutdown);\n\n// Loop principal\nwhile (!should_exit) {\n    // Fazer trabalho...\n    // Verificar flag should_exit periodicamente\n}\n\nprint(\"Cleanup complete\");\n```\n\n### Contador de Sinais\n\nRastrear nmero de sinais recebidos:\n\n```hemlock\nlet signal_count = 0;\n\nfn count_signals(sig) {\n    signal_count = signal_count + 1;\n    print(\"Received \" + typeof(signal_count) + \" signals\");\n}\n\nsignal(SIGUSR1, count_signals);\n\n// Depois...\nprint(\"Total signals: \" + typeof(signal_count));\n```\n\n### Recarregar Configurao por Sinal\n\n```hemlock\nlet config = load_config();\n\nfn reload_config(sig) {\n    print(\"Reloading configuration...\");\n    config = load_config();\n    print(\"Configuration reloaded\");\n}\n\nsignal(SIGHUP, reload_config);  // Recarregar ao receber SIGHUP\n\n// Do shell, envie SIGHUP para o processo para recarregar config\n// kill -HUP <pid>\n```\n\n### Timeout com SIGALRM\n\n```hemlock\nlet timed_out = false;\n\nfn handle_alarm(sig) {\n    print(\"Timeout!\");\n    timed_out = true;\n}\n\nsignal(SIGALRM, handle_alarm);\n\n// Definir alarme (ainda no implementado em Hemlock, apenas exemplo)\n// alarm(5);  // timeout de 5 segundos\n\nwhile (!timed_out) {\n    // Trabalho com timeout\n}\n```\n\n### Mquina de Estados Baseada em Sinais\n\n```hemlock\nlet state = 0;\n\nfn next_state(sig) {\n    state = (state + 1) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nfn prev_state(sig) {\n    state = (state - 1 + 3) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nsignal(SIGUSR1, next_state);  // Avanar estado\nsignal(SIGUSR2, prev_state);  // Retroceder estado\n\n// Controlar mquina de estados:\n// kill -USR1 <pid>  # prximo estado\n// kill -USR2 <pid>  # estado anterior\n```\n\n## Comportamento de Handlers de Sinais\n\n### Notas Importantes\n\n**Execuo de Handler:**\n- Handlers so chamados **sincronamente** quando o sinal  recebido\n- Handlers executam no contexto do processo atual\n- Handlers de sinal compartilham o ambiente de closure da funo que os definiu\n- Handlers podem acessar e modificar variveis do escopo externo (como globais ou variveis capturadas)\n\n**Melhores Prticas:**\n- Mantenha handlers simples e rpidos - evite operaes de longa durao\n- Defina flags em vez de executar lgica complexa\n- Evite chamar funes que podem adquirir locks\n- Esteja ciente de que handlers podem interromper qualquer operao\n\n### Quais Sinais Podem Ser Capturados\n\n**Podem ser capturados e tratados:**\n- SIGINT, SIGTERM, SIGUSR1, SIGUSR2, SIGHUP, SIGQUIT\n- SIGALRM, SIGCHLD, SIGCONT, SIGTSTP\n- SIGPIPE, SIGTTIN, SIGTTOU\n- SIGABRT (mas o programa abortar aps o handler retornar)\n\n**No podem ser capturados:**\n- `SIGKILL` (9) - sempre termina o processo\n- `SIGSTOP` (19) - sempre para o processo\n\n**Dependentes do Sistema:**\n- Comportamento padro de alguns sinais pode variar entre sistemas\n- Consulte a documentao de sinais da sua plataforma para detalhes\n\n### Limitaes de Handlers\n\n```hemlock\nfn complex_handler(sig) {\n    // Evite isso em handlers de sinal:\n\n    //  Operaes de longa durao\n    // process_large_file();\n\n    //  I/O bloqueante\n    // let f = open(\"log.txt\", \"a\");\n    // f.write(\"Signal received\\n\");\n\n    //  Mudanas complexas de estado\n    // rebuild_entire_data_structure();\n\n    //  Definir flag simples  seguro\n    let should_stop = true;\n\n    //  Atualizao simples de contador geralmente  seguro\n    let signal_count = signal_count + 1;\n}\n```\n\n## Consideraes de Segurana\n\nSeguindo a filosofia do Hemlock, o tratamento de sinais  **inerentemente inseguro**.\n\n### Condies de Corrida\n\nHandlers podem ser chamados a qualquer momento, interrompendo a execuo normal:\n\n```hemlock\nlet counter = 0;\n\nfn increment(sig) {\n    counter = counter + 1;  // Condio de corrida se chamado durante atualizao de counter\n}\n\nsignal(SIGUSR1, increment);\n\n// Cdigo principal tambm modifica counter\ncounter = counter + 1;  // Pode ser interrompido pelo handler de sinal\n```\n\n**Problema:** Se o sinal chega enquanto o cdigo principal est atualizando `counter`, o resultado  imprevisvel.\n\n### Segurana de Sinal Assncrono\n\nHemlock **no** garante segurana de sinal assncrono:\n- Handlers podem chamar qualquer cdigo Hemlock (diferente de funes C restritas async-signal-safe)\n- Isso fornece flexibilidade mas requer cuidado do usurio\n- Condies de corrida podem ocorrer se handlers modificam estado compartilhado\n\n### Melhores Prticas para Tratamento Seguro de Sinais\n\n**1. Use Flags Atmicas**\n\nAtribuies booleanas simples geralmente so seguras:\n\n```hemlock\nlet should_exit = false;\n\nfn handler(sig) {\n    should_exit = true;  // Atribuio simples  segura\n}\n\nsignal(SIGINT, handler);\n\nwhile (!should_exit) {\n    // Trabalho...\n}\n```\n\n**2. Minimize Estado Compartilhado**\n\n```hemlock\nlet interrupt_count = 0;\n\nfn handler(sig) {\n    // Modifique apenas esta varivel\n    interrupt_count = interrupt_count + 1;\n}\n```\n\n**3. Adie Operaes Complexas**\n\n```hemlock\nlet pending_reload = false;\n\nfn signal_reload(sig) {\n    pending_reload = true;  // Apenas define flag\n}\n\nsignal(SIGHUP, signal_reload);\n\n// No loop principal:\nwhile (true) {\n    if (pending_reload) {\n        reload_config();  // Faz trabalho complexo aqui\n        pending_reload = false;\n    }\n\n    // Trabalho normal...\n}\n```\n\n**4. Evite Problemas de Reentrncia**\n\n```hemlock\nlet in_critical_section = false;\nlet data = [];\n\nfn careful_handler(sig) {\n    if (in_critical_section) {\n        // No modifique dados enquanto cdigo principal os usa\n        return;\n    }\n    // Pode continuar com segurana\n}\n```\n\n## Casos de Uso Comuns\n\n### 1. Shutdown Gracioso de Servidor\n\n```hemlock\nlet running = true;\n\nfn shutdown(sig) {\n    print(\"Shutdown signal received\");\n    running = false;\n}\n\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// Loop principal do servidor\nwhile (running) {\n    handle_client_request();\n}\n\ncleanup_resources();\nprint(\"Server stopped\");\n```\n\n### 2. Recarregar Configurao (Sem Reiniciar)\n\n```hemlock\nlet config = load_config(\"app.conf\");\nlet reload_needed = false;\n\nfn trigger_reload(sig) {\n    reload_needed = true;\n}\n\nsignal(SIGHUP, trigger_reload);\n\nwhile (true) {\n    if (reload_needed) {\n        print(\"Reloading configuration...\");\n        config = load_config(\"app.conf\");\n        reload_needed = false;\n    }\n\n    // Usar configurao...\n}\n```\n\n### 3. Rotao de Logs\n\n```hemlock\nlet log_file = open(\"app.log\", \"a\");\nlet rotate_needed = false;\n\nfn trigger_rotate(sig) {\n    rotate_needed = true;\n}\n\nsignal(SIGUSR1, trigger_rotate);\n\nwhile (true) {\n    if (rotate_needed) {\n        log_file.close();\n        // Renomear log antigo, abrir novo\n        exec(\"mv app.log app.log.old\");\n        log_file = open(\"app.log\", \"a\");\n        rotate_needed = false;\n    }\n\n    // Logging normal...\n    log_file.write(\"Log entry\\n\");\n}\n```\n\n### 4. Relatrio de Status\n\n```hemlock\nlet requests_handled = 0;\n\nfn report_status(sig) {\n    print(\"Status: \" + typeof(requests_handled) + \" requests handled\");\n}\n\nsignal(SIGUSR1, report_status);\n\nwhile (true) {\n    handle_request();\n    requests_handled = requests_handled + 1;\n}\n\n// Do shell: kill -USR1 <pid>\n```\n\n### 5. Alternar Modo Debug\n\n```hemlock\nlet debug_mode = false;\n\nfn toggle_debug(sig) {\n    debug_mode = !debug_mode;\n    if (debug_mode) {\n        print(\"Debug mode: ON\");\n    } else {\n        print(\"Debug mode: OFF\");\n    }\n}\n\nsignal(SIGUSR2, toggle_debug);\n\n// Do shell: kill -USR2 <pid> para alternar\n```\n\n## Exemplos Completos\n\n### Exemplo 1: Handler de Interrupo com Limpeza\n\n```hemlock\nlet running = true;\nlet signal_count = 0;\n\nfn handle_signal(signum) {\n    signal_count = signal_count + 1;\n\n    if (signum == SIGINT) {\n        print(\"Interrupt detected (Ctrl+C)\");\n        running = false;\n    }\n\n    if (signum == SIGUSR1) {\n        print(\"User signal 1 received\");\n    }\n}\n\n// Registrar handlers\nsignal(SIGINT, handle_signal);\nsignal(SIGUSR1, handle_signal);\n\n// Simular algum trabalho\nlet i = 0;\nwhile (running && i < 100) {\n    print(\"Working... \" + typeof(i));\n\n    // Disparar SIGUSR1 a cada 10 iteraes\n    if (i == 10 || i == 20) {\n        raise(SIGUSR1);\n    }\n\n    i = i + 1;\n}\n\nprint(\"Total signals received: \" + typeof(signal_count));\n```\n\n### Exemplo 2: Mquina de Estados Multi-sinal\n\n```hemlock\nlet state = \"idle\";\nlet request_count = 0;\n\nfn start_processing(sig) {\n    state = \"processing\";\n    print(\"State: \" + state);\n}\n\nfn stop_processing(sig) {\n    state = \"idle\";\n    print(\"State: \" + state);\n}\n\nfn report_stats(sig) {\n    print(\"State: \" + state);\n    print(\"Requests: \" + typeof(request_count));\n}\n\nsignal(SIGUSR1, start_processing);\nsignal(SIGUSR2, stop_processing);\nsignal(SIGHUP, report_stats);\n\nwhile (true) {\n    if (state == \"processing\") {\n        // Fazer trabalho\n        request_count = request_count + 1;\n    }\n\n    // Verificar a cada iterao...\n}\n```\n\n### Exemplo 3: Controlador de Pool de Workers\n\n```hemlock\nlet worker_count = 4;\nlet should_exit = false;\n\nfn increase_workers(sig) {\n    worker_count = worker_count + 1;\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn decrease_workers(sig) {\n    if (worker_count > 1) {\n        worker_count = worker_count - 1;\n    }\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn shutdown(sig) {\n    print(\"Shutting down...\");\n    should_exit = true;\n}\n\nsignal(SIGUSR1, increase_workers);\nsignal(SIGUSR2, decrease_workers);\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// Loop principal ajusta pool de workers baseado em worker_count\nwhile (!should_exit) {\n    // Gerenciar workers baseado em worker_count\n    // ...\n}\n```\n\n## Depurando Handlers de Sinal\n\n### Adicionar Prints de Diagnstico\n\n```hemlock\nfn debug_handler(sig) {\n    print(\"Handler called for signal: \" + typeof(sig));\n    print(\"Stack: (not yet available)\");\n\n    // Sua lgica de handler...\n}\n\nsignal(SIGINT, debug_handler);\n```\n\n### Contar Chamadas de Handler\n\n```hemlock\nlet handler_calls = 0;\n\nfn counting_handler(sig) {\n    handler_calls = handler_calls + 1;\n    print(\"Handler call #\" + typeof(handler_calls));\n\n    // Sua lgica de handler...\n}\n```\n\n### Testar Usando raise()\n\n```hemlock\nfn test_handler(sig) {\n    print(\"Test signal received: \" + typeof(sig));\n}\n\nsignal(SIGUSR1, test_handler);\n\n// Testar disparando manualmente\nraise(SIGUSR1);\nprint(\"Handler should have been called\");\n```\n\n## Resumo\n\nO tratamento de sinais do Hemlock oferece:\n\n- Tratamento de sinais POSIX para controle de processo de baixo nvel\n- 15 constantes de sinais padro\n- API simples signal() e raise()\n- Funes handler flexveis com suporte a closures\n- Mltiplos sinais podem compartilhar um handler\n\nLembre-se:\n- O tratamento de sinais  inerentemente inseguro - use com cuidado\n- Mantenha handlers simples e rpidos\n- Use flags para mudanas de estado, no operaes complexas\n- Handlers podem interromper a execuo a qualquer momento\n- SIGKILL ou SIGSTOP no podem ser capturados\n- Use raise() para testar handlers completamente\n\nPadres comuns:\n- Shutdown gracioso (SIGINT, SIGTERM)\n- Recarregar configurao (SIGHUP)\n- Rotao de logs (SIGUSR1)\n- Relatrio de status (SIGUSR1/SIGUSR2)\n- Alternar modo debug (SIGUSR2)\n"}, "Referncia da API -> API de Arquivos": {"id": "reference-file-api", "content": "# Referencia da API de Arquivos\n\nDocumentacao completa do sistema de I/O de arquivos do Hemlock.\n\n---\n\n## Visao Geral\n\nHemlock fornece uma **API de objeto de arquivo** para operacoes de arquivo com tratamento de erros e gerenciamento de recursos adequados. Arquivos devem ser abertos e fechados manualmente.\n\n**Caracteristicas Principais:**\n- Objetos de arquivo com metodos\n- Leitura e escrita de texto e dados binarios\n- Operacoes de posicionamento\n- Mensagens de erro adequadas\n- Gerenciamento manual de recursos (sem RAII)\n\n---\n\n## Tipo File\n\n**Tipo:** `file`\n\n**Descricao:** Handle de arquivo para operacoes de I/O\n\n**Propriedades (somente leitura):**\n- `.path` - Caminho do arquivo (string)\n- `.mode` - Modo de abertura (string)\n- `.closed` - Se o arquivo esta fechado (bool)\n\n---\n\n## Abrindo Arquivos\n\n### open\n\nAbre um arquivo para leitura, escrita ou ambos.\n\n**Assinatura:**\n```hemlock\nopen(path: string, mode?: string): file\n```\n\n**Parametros:**\n- `path` - Caminho do arquivo (relativo ou absoluto)\n- `mode` (opcional) - Modo de abertura (padrao: `\"r\"`)\n\n**Retorna:** Objeto de arquivo\n\n**Modos:**\n- `\"r\"` - Leitura (padrao)\n- `\"w\"` - Escrita (trunca arquivo existente)\n- `\"a\"` - Acrescentar\n- `\"r+\"` - Leitura e escrita\n- `\"w+\"` - Leitura e escrita (trunca)\n- `\"a+\"` - Leitura e acrescentar\n\n**Exemplo:**\n```hemlock\n// Modo de leitura (padrao)\nlet f = open(\"data.txt\");\nlet f_read = open(\"data.txt\", \"r\");\n\n// Modo de escrita (trunca)\nlet f_write = open(\"output.txt\", \"w\");\n\n// Modo de acrescentar\nlet f_append = open(\"log.txt\", \"a\");\n\n// Modo de leitura e escrita\nlet f_rw = open(\"data.bin\", \"r+\");\n\n// Leitura e escrita (trunca)\nlet f_rw_trunc = open(\"output.bin\", \"w+\");\n\n// Leitura e acrescentar\nlet f_ra = open(\"log.txt\", \"a+\");\n```\n\n**Tratamento de Erros:**\n```hemlock\ntry {\n    let f = open(\"missing.txt\", \"r\");\n} catch (e) {\n    print(\"Falha ao abrir:\", e);\n    // Erro: Failed to open 'missing.txt': No such file or directory\n}\n```\n\n**Importante:** Arquivos devem ser fechados manualmente usando `f.close()` para evitar vazamento de descritores de arquivo.\n\n---\n\n## Metodos de Arquivo\n\n### Leitura\n\n#### read\n\nLe texto de um arquivo.\n\n**Assinatura:**\n```hemlock\nfile.read(size?: i32): string\n```\n\n**Parametros:**\n- `size` (opcional) - Numero de bytes a ler (se omitido, le ate o fim do arquivo)\n\n**Retorna:** String contendo o conteudo do arquivo\n\n**Exemplo:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Le o arquivo inteiro\nlet all = f.read();\nprint(all);\n\n// Le quantidade especificada de bytes\nlet chunk = f.read(1024);\n\nf.close();\n```\n\n**Comportamento:**\n- Le a partir da posicao atual do arquivo\n- Retorna string vazia no fim do arquivo\n- Avanca a posicao do arquivo\n\n**Erros:**\n- Ler de arquivo fechado\n- Ler de arquivo somente escrita\n\n---\n\n#### read_bytes\n\nLe dados binarios de um arquivo.\n\n**Assinatura:**\n```hemlock\nfile.read_bytes(size: i32): buffer\n```\n\n**Parametros:**\n- `size` - Numero de bytes a ler\n\n**Retorna:** Buffer contendo dados binarios\n\n**Exemplo:**\n```hemlock\nlet f = open(\"data.bin\", \"r\");\n\n// Le 256 bytes\nlet binary = f.read_bytes(256);\nprint(binary.length);       // 256\n\n// Processa dados binarios\nlet i = 0;\nwhile (i < binary.length) {\n    print(binary[i]);\n    i = i + 1;\n}\n\nf.close();\n```\n\n**Comportamento:**\n- Le quantidade exata de bytes\n- Retorna buffer (nao string)\n- Avanca a posicao do arquivo\n\n---\n\n### Escrita\n\n#### write\n\nEscreve texto em um arquivo.\n\n**Assinatura:**\n```hemlock\nfile.write(data: string): i32\n```\n\n**Parametros:**\n- `data` - String a ser escrita\n\n**Retorna:** Numero de bytes escritos (i32)\n\n**Exemplo:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\n\n// Escreve texto\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Escreveu\", written, \"bytes\");\n\n// Multiplas escritas\nf.write(\"Linha 1\\n\");\nf.write(\"Linha 2\\n\");\nf.write(\"Linha 3\\n\");\n\nf.close();\n```\n\n**Comportamento:**\n- Escreve na posicao atual do arquivo\n- Retorna numero de bytes escritos\n- Avanca a posicao do arquivo\n\n**Erros:**\n- Escrever em arquivo fechado\n- Escrever em arquivo somente leitura\n\n---\n\n#### write_bytes\n\nEscreve dados binarios em um arquivo.\n\n**Assinatura:**\n```hemlock\nfile.write_bytes(data: buffer): i32\n```\n\n**Parametros:**\n- `data` - Buffer a ser escrito\n\n**Retorna:** Numero de bytes escritos (i32)\n\n**Exemplo:**\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Cria buffer\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Escreve buffer\nlet written = f.write_bytes(buf);\nprint(\"Escreveu\", written, \"bytes\");\n\nf.close();\n```\n\n**Comportamento:**\n- Escreve conteudo do buffer no arquivo\n- Retorna numero de bytes escritos\n- Avanca a posicao do arquivo\n\n---\n\n### Posicionamento\n\n#### seek\n\nMove a posicao do arquivo para um deslocamento de byte especificado.\n\n**Assinatura:**\n```hemlock\nfile.seek(position: i32): i32\n```\n\n**Parametros:**\n- `position` - Deslocamento em bytes a partir do inicio do arquivo\n\n**Retorna:** Nova posicao do arquivo (i32)\n\n**Exemplo:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Pula para o byte 100\nf.seek(100);\n\n// Le a partir dessa posicao\nlet chunk = f.read(50);\n\n// Volta ao inicio\nf.seek(0);\n\n// Le a partir do inicio\nlet all = f.read();\n\nf.close();\n```\n\n**Comportamento:**\n- Define a posicao do arquivo como deslocamento absoluto\n- Retorna a nova posicao\n- Permite posicionar alem do fim do arquivo (criar buracos ao escrever)\n\n---\n\n#### tell\n\nObtem a posicao atual do arquivo.\n\n**Assinatura:**\n```hemlock\nfile.tell(): i32\n```\n\n**Retorna:** Deslocamento atual em bytes a partir do inicio do arquivo (i32)\n\n**Exemplo:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nprint(f.tell());        // 0 (no inicio)\n\nf.read(100);\nprint(f.tell());        // 100 (apos ler)\n\nf.seek(50);\nprint(f.tell());        // 50 (apos seek)\n\nf.close();\n```\n\n---\n\n### Fechamento\n\n#### close\n\nFecha o arquivo (idempotente).\n\n**Assinatura:**\n```hemlock\nfile.close(): null\n```\n\n**Retorna:** `null`\n\n**Exemplo:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\n// Pode ser chamado multiplas vezes com seguranca\nf.close();  // Sem erro\nf.close();  // Sem erro\n```\n\n**Comportamento:**\n- Fecha o handle do arquivo\n- Libera qualquer escrita pendente\n- Idempotente (pode ser chamado multiplas vezes com seguranca)\n- Define a propriedade `.closed` como `true`\n\n**Importante:** Sempre feche arquivos quando terminar para evitar vazamento de descritores de arquivo.\n\n---\n\n## Propriedades de Arquivo\n\n### .path\n\nObtem o caminho do arquivo.\n\n**Tipo:** `string`\n\n**Acesso:** Somente leitura\n\n**Exemplo:**\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);          // \"/path/to/file.txt\"\nf.close();\n```\n\n---\n\n### .mode\n\nObtem o modo de abertura.\n\n**Tipo:** `string`\n\n**Acesso:** Somente leitura\n\n**Exemplo:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);          // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);         // \"w\"\nf2.close();\n```\n\n---\n\n### .closed\n\nVerifica se o arquivo esta fechado.\n\n**Tipo:** `bool`\n\n**Acesso:** Somente leitura\n\n**Exemplo:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);        // false\n\nf.close();\nprint(f.closed);        // true\n```\n\n---\n\n## Tratamento de Erros\n\nTodas as operacoes de arquivo incluem mensagens de erro adequadas com contexto:\n\n### Arquivo Nao Encontrado\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Erro: Failed to open 'missing.txt': No such file or directory\n```\n\n### Ler de Arquivo Fechado\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Erro: Cannot read from closed file 'data.txt'\n```\n\n### Escrever em Arquivo Somente Leitura\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Erro: Cannot write to file 'readonly.txt' opened in read-only mode\n```\n\n### Usando try/catch\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    print(content);\n} catch (e) {\n    print(\"Erro de arquivo:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## Padroes de Gerenciamento de Recursos\n\n### Padrao Basico\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### Com Tratamento de Erros\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Sempre fecha, mesmo com erro\n}\n```\n\n### Padrao Seguro\n\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    // ... processa conteudo ...\n} catch (e) {\n    print(\"Erro:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## Exemplos de Uso\n\n### Ler Arquivo Inteiro\n\n```hemlock\nfn read_file(filename: string): string {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content;\n}\n\nlet text = read_file(\"data.txt\");\nprint(text);\n```\n\n### Escrever Arquivo de Texto\n\n```hemlock\nfn write_file(filename: string, content: string) {\n    let f = open(filename, \"w\");\n    f.write(content);\n    f.close();\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\\n\");\n```\n\n### Acrescentar a Arquivo\n\n```hemlock\nfn append_file(filename: string, line: string) {\n    let f = open(filename, \"a\");\n    f.write(line + \"\\n\");\n    f.close();\n}\n\nappend_file(\"log.txt\", \"Entrada de log 1\");\nappend_file(\"log.txt\", \"Entrada de log 2\");\n```\n\n### Ler Arquivo Binario\n\n```hemlock\nfn read_binary(filename: string, size: i32): buffer {\n    let f = open(filename, \"r\");\n    let data = f.read_bytes(size);\n    f.close();\n    return data;\n}\n\nlet binary = read_binary(\"data.bin\", 256);\nprint(\"Leu\", binary.length, \"bytes\");\n```\n\n### Escrever Arquivo Binario\n\n```hemlock\nfn write_binary(filename: string, data: buffer) {\n    let f = open(filename, \"w\");\n    f.write_bytes(data);\n    f.close();\n}\n\nlet buf = buffer(10);\nbuf[0] = 65;\nwrite_binary(\"output.bin\", buf);\n```\n\n### Ler Arquivo Linha por Linha\n\n```hemlock\nfn read_lines(filename: string): array {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content.split(\"\\n\");\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Linha\", i, \":\", lines[i]);\n    i = i + 1;\n}\n```\n\n### Copiar Arquivo\n\n```hemlock\nfn copy_file(src: string, dest: string) {\n    let f_in = open(src, \"r\");\n    let f_out = open(dest, \"w\");\n\n    let content = f_in.read();\n    f_out.write(content);\n\n    f_in.close();\n    f_out.close();\n}\n\ncopy_file(\"input.txt\", \"output.txt\");\n```\n\n### Ler Arquivo em Pedacos\n\n```hemlock\nfn process_chunks(filename: string) {\n    let f = open(filename, \"r\");\n\n    while (true) {\n        let chunk = f.read(1024);  // Le 1KB por vez\n        if (chunk.length == 0) {\n            break;  // Fim do arquivo\n        }\n\n        // Processa pedaco\n        print(\"Processando\", chunk.length, \"bytes\");\n    }\n\n    f.close();\n}\n\nprocess_chunks(\"large_file.txt\");\n```\n\n---\n\n## Resumo Completo dos Metodos\n\n| Metodo        | Assinatura               | Retorna   | Descricao                        |\n|---------------|--------------------------|-----------|----------------------------------|\n| `read`        | `(size?: i32)`           | `string`  | Le texto                         |\n| `read_bytes`  | `(size: i32)`            | `buffer`  | Le dados binarios                |\n| `write`       | `(data: string)`         | `i32`     | Escreve texto                    |\n| `write_bytes` | `(data: buffer)`         | `i32`     | Escreve dados binarios           |\n| `seek`        | `(position: i32)`        | `i32`     | Define posicao do arquivo        |\n| `tell`        | `()`                     | `i32`     | Obtem posicao do arquivo         |\n| `close`       | `()`                     | `null`    | Fecha arquivo (idempotente)      |\n\n---\n\n## Resumo Completo das Propriedades\n\n| Propriedade | Tipo     | Acesso        | Descricao              |\n|-------------|----------|---------------|------------------------|\n| `.path`     | `string` | Somente leitura | Caminho do arquivo   |\n| `.mode`     | `string` | Somente leitura | Modo de abertura     |\n| `.closed`   | `bool`   | Somente leitura | Se o arquivo esta fechado |\n\n---\n\n## Migrando da API Antiga\n\n**API Antiga (removida):**\n- `read_file(path)` - Use `open(path, \"r\").read()`\n- `write_file(path, data)` - Use `open(path, \"w\").write(data)`\n- `append_file(path, data)` - Use `open(path, \"a\").write(data)`\n- `file_exists(path)` - Sem substituto por enquanto\n\n**Exemplo de Migracao:**\n```hemlock\n// Antigo (v0.0)\nlet content = read_file(\"data.txt\");\nwrite_file(\"output.txt\", content);\n\n// Novo (v0.1)\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nf2.write(content);\nf2.close();\n```\n\n---\n\n## Veja Tambem\n\n- [Funcoes Integradas](#reference-builtins) - Funcao `open()`\n- [API de Memoria](#reference-memory-api) - Tipo buffer\n- [API de Strings](#reference-string-api) - Metodos de string para processamento de texto\n"}, "Referncia da API -> API de Arrays": {"id": "reference-array-api", "content": "# Referencia da API de Arrays\n\nDocumentacao completa do tipo array do Hemlock e todos os seus 18 metodos de array.\n\n---\n\n## Visao Geral\n\nArrays em Hemlock sao sequencias **dinamicas, alocadas no heap** que podem armazenar tipos mistos. Eles fornecem metodos abrangentes para manipulacao e processamento de dados.\n\n**Caracteristicas Principais:**\n- Tamanho dinamico (cresce automaticamente)\n- Indexacao comecando em zero\n- Permite tipos mistos\n- 18 metodos integrados\n- Alocado no heap e rastreia capacidade\n\n---\n\n## Tipo Array\n\n**Tipo:** `array`\n\n**Propriedades:**\n- `.length` - Numero de elementos (i32)\n\n**Sintaxe Literal:** Colchetes `[elem1, elem2, ...]`\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);     // 5\n\n// Tipos mistos\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.length);   // 4\n\n// Array vazio\nlet empty = [];\nprint(empty.length);   // 0\n```\n\n---\n\n## Indexacao\n\nArrays suportam indexacao baseada em zero usando `[]`:\n\n**Acesso de Leitura:**\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);         // 10\nprint(arr[1]);         // 20\nprint(arr[2]);         // 30\n```\n\n**Acesso de Escrita:**\n```hemlock\nlet arr = [10, 20, 30];\narr[0] = 99;\narr[1] = 88;\nprint(arr);            // [99, 88, 30]\n```\n\n**Nota:** A indexacao direta nao verifica limites. Use metodos para seguranca.\n\n---\n\n## Propriedades do Array\n\n### .length\n\nObtem o numero de elementos no array.\n\n**Tipo:** `i32`\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr.length);     // 3\n\nlet empty = [];\nprint(empty.length);   // 0\n\n// O comprimento muda dinamicamente\narr.push(4);\nprint(arr.length);     // 4\n\narr.pop();\nprint(arr.length);     // 3\n```\n\n---\n\n## Metodos do Array\n\n### Operacoes de Pilha\n\n#### push\n\nAdiciona um elemento ao final do array.\n\n**Assinatura:**\n```hemlock\narray.push(value: any): null\n```\n\n**Parametros:**\n- `value` - O elemento a ser adicionado\n\n**Retorna:** `null`\n\n**Modifica o Original:** Sim (modifica o array no local)\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\narr.push(\"hello\");     // [1, 2, 3, 4, 5, \"hello\"]\n```\n\n---\n\n#### pop\n\nRemove e retorna o ultimo elemento.\n\n**Assinatura:**\n```hemlock\narray.pop(): any\n```\n\n**Retorna:** O ultimo elemento (removido do array)\n\n**Modifica o Original:** Sim (modifica o array no local)\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3];\nlet last = arr.pop();  // 3\nprint(arr);            // [1, 2]\n\nlet last2 = arr.pop(); // 2\nprint(arr);            // [1]\n```\n\n**Erro:** Lanca erro de tempo de execucao se o array estiver vazio.\n\n---\n\n### Operacoes de Fila\n\n#### shift\n\nRemove e retorna o primeiro elemento.\n\n**Assinatura:**\n```hemlock\narray.shift(): any\n```\n\n**Retorna:** O primeiro elemento (removido do array)\n\n**Modifica o Original:** Sim (modifica o array no local)\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();  // 1\nprint(arr);               // [2, 3]\n\nlet first2 = arr.shift(); // 2\nprint(arr);               // [3]\n```\n\n**Erro:** Lanca erro de tempo de execucao se o array estiver vazio.\n\n---\n\n#### unshift\n\nAdiciona um elemento ao inicio do array.\n\n**Assinatura:**\n```hemlock\narray.unshift(value: any): null\n```\n\n**Parametros:**\n- `value` - O elemento a ser adicionado\n\n**Retorna:** `null`\n\n**Modifica o Original:** Sim (modifica o array no local)\n\n**Exemplo:**\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);        // [1, 2, 3]\narr.unshift(0);        // [0, 1, 2, 3]\n```\n\n---\n\n### Insercao e Remocao\n\n#### insert\n\nInsere um elemento em um indice especificado.\n\n**Assinatura:**\n```hemlock\narray.insert(index: i32, value: any): null\n```\n\n**Parametros:**\n- `index` - Posicao de insercao (baseada em 0)\n- `value` - Elemento a ser inserido\n\n**Retorna:** `null`\n\n**Modifica o Original:** Sim (modifica o array no local)\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // [1, 2, 3, 4, 5]\n\nlet arr2 = [1, 3];\narr2.insert(1, 2);     // [1, 2, 3]\n\n// Insere no final\narr2.insert(arr2.length, 4);  // [1, 2, 3, 4]\n```\n\n**Comportamento:** Desloca elementos no indice e apos para a direita.\n\n---\n\n#### remove\n\nRemove e retorna o elemento em um indice especificado.\n\n**Assinatura:**\n```hemlock\narray.remove(index: i32): any\n```\n\n**Parametros:**\n- `index` - Posicao a ser removida (baseada em 0)\n\n**Retorna:** O elemento removido\n\n**Modifica o Original:** Sim (modifica o array no local)\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(0);  // 1\nprint(arr);                   // [2, 3, 4, 5]\n\nlet removed2 = arr.remove(2); // 4\nprint(arr);                   // [2, 3, 5]\n```\n\n**Comportamento:** Desloca elementos apos o indice para a esquerda.\n\n**Erro:** Lanca erro de tempo de execucao se o indice estiver fora dos limites.\n\n---\n\n### Busca e Localizacao\n\n#### find\n\nEncontra a primeira ocorrencia de um valor.\n\n**Assinatura:**\n```hemlock\narray.find(value: any): i32\n```\n\n**Parametros:**\n- `value` - O valor a ser buscado\n\n**Retorna:** Indice da primeira ocorrencia, ou `-1` se nao encontrado\n\n**Exemplo:**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2\nlet idx2 = arr.find(99);     // -1 (nao encontrado)\n\n// Encontra primeira duplicata\nlet arr2 = [1, 2, 3, 2, 4];\nlet idx3 = arr2.find(2);     // 1 (primeira ocorrencia)\n```\n\n**Comparacao:** Usa igualdade de valor para tipos primitivos e strings.\n\n---\n\n#### contains\n\nVerifica se o array contem um valor.\n\n**Assinatura:**\n```hemlock\narray.contains(value: any): bool\n```\n\n**Parametros:**\n- `value` - O valor a ser buscado\n\n**Retorna:** `true` se encontrado, caso contrario `false`\n\n**Exemplo:**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n\n// Funciona com strings tambem\nlet words = [\"hello\", \"world\"];\nlet has3 = words.contains(\"hello\");  // true\n```\n\n---\n\n### Fatiamento e Extracao\n\n#### slice\n\nExtrai um sub-array por intervalo (final exclusivo).\n\n**Assinatura:**\n```hemlock\narray.slice(start: i32, end: i32): array\n```\n\n**Parametros:**\n- `start` - Indice inicial (baseado em 0, inclusivo)\n- `end` - Indice final (exclusivo)\n\n**Retorna:** Novo array contendo elementos no intervalo [start, end)\n\n**Modifica o Original:** Nao (retorna novo array)\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4]\nlet first_three = arr.slice(0, 3);  // [1, 2, 3]\nlet last_two = arr.slice(3, 5);     // [4, 5]\n\n// Fatia vazia\nlet empty = arr.slice(2, 2); // []\n```\n\n---\n\n#### first\n\nObtem o primeiro elemento sem remover.\n\n**Assinatura:**\n```hemlock\narray.first(): any\n```\n\n**Retorna:** O primeiro elemento\n\n**Modifica o Original:** Nao\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1\nprint(arr);                  // [1, 2, 3] (inalterado)\n```\n\n**Erro:** Lanca erro de tempo de execucao se o array estiver vazio.\n\n---\n\n#### last\n\nObtem o ultimo elemento sem remover.\n\n**Assinatura:**\n```hemlock\narray.last(): any\n```\n\n**Retorna:** O ultimo elemento\n\n**Modifica o Original:** Nao\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3\nprint(arr);                  // [1, 2, 3] (inalterado)\n```\n\n**Erro:** Lanca erro de tempo de execucao se o array estiver vazio.\n\n---\n\n### Operacoes com Arrays\n\n#### reverse\n\nInverte o array no local.\n\n**Assinatura:**\n```hemlock\narray.reverse(): null\n```\n\n**Retorna:** `null`\n\n**Modifica o Original:** Sim (modifica o array no local)\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\nprint(arr);                  // [5, 4, 3, 2, 1]\n\nlet words = [\"hello\", \"world\"];\nwords.reverse();             // [\"world\", \"hello\"]\n```\n\n---\n\n#### clear\n\nRemove todos os elementos do array.\n\n**Assinatura:**\n```hemlock\narray.clear(): null\n```\n\n**Retorna:** `null`\n\n**Modifica o Original:** Sim (modifica o array no local)\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();\nprint(arr);                  // []\nprint(arr.length);           // 0\n```\n\n---\n\n### Combinacao de Arrays\n\n#### concat\n\nConcatena com outro array.\n\n**Assinatura:**\n```hemlock\narray.concat(other: array): array\n```\n\n**Parametros:**\n- `other` - O array a ser concatenado\n\n**Retorna:** Novo array contendo elementos de ambos os arrays\n\n**Modifica o Original:** Nao (retorna novo array)\n\n**Exemplo:**\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]\nprint(a);                    // [1, 2, 3] (inalterado)\nprint(b);                    // [4, 5, 6] (inalterado)\n\n// Concatenacao em cadeia\nlet c = [7, 8];\nlet all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n---\n\n### Operacoes Funcionais\n\n#### map\n\nTransforma cada elemento usando uma funcao callback.\n\n**Assinatura:**\n```hemlock\narray.map(callback: fn): array\n```\n\n**Parametros:**\n- `callback` - Funcao que recebe um elemento e retorna o valor transformado\n\n**Retorna:** Novo array contendo elementos transformados\n\n**Modifica o Original:** Nao (retorna novo array)\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet doubled = arr.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\nlet names = [\"alice\", \"bob\"];\nlet upper = names.map(fn(s) { return s.to_upper(); });\nprint(upper);  // [\"ALICE\", \"BOB\"]\n```\n\n---\n\n#### filter\n\nSeleciona elementos que correspondem a um predicado.\n\n**Assinatura:**\n```hemlock\narray.filter(predicate: fn): array\n```\n\n**Parametros:**\n- `predicate` - Funcao que recebe um elemento e retorna bool\n\n**Retorna:** Novo array contendo elementos para os quais o predicado retorna true\n\n**Modifica o Original:** Nao (retorna novo array)\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6];\nlet evens = arr.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4, 6]\n\nlet words = [\"hello\", \"hi\", \"hey\", \"goodbye\"];\nlet short = words.filter(fn(s) { return s.length < 4; });\nprint(short);  // [\"hi\", \"hey\"]\n```\n\n---\n\n#### reduce\n\nReduz o array a um unico valor usando um acumulador.\n\n**Assinatura:**\n```hemlock\narray.reduce(callback: fn, initial: any): any\n```\n\n**Parametros:**\n- `callback` - Funcao que recebe (acumulador, elemento) e retorna novo acumulador\n- `initial` - Valor inicial do acumulador\n\n**Retorna:** Valor acumulado final\n\n**Modifica o Original:** Nao\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sum = arr.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\nlet product = arr.reduce(fn(acc, x) { return acc * x; }, 1);\nprint(product);  // 120\n\n// Encontra o maximo\nlet max = arr.reduce(fn(acc, x) {\n    if (x > acc) { return x; }\n    return acc;\n}, arr[0]);\nprint(max);  // 5\n```\n\n---\n\n### Conversao para String\n\n#### join\n\nJunta elementos em uma string usando um delimitador.\n\n**Assinatura:**\n```hemlock\narray.join(delimiter: string): string\n```\n\n**Parametros:**\n- `delimiter` - String a ser colocada entre os elementos\n\n**Retorna:** String concatenando todos os elementos\n\n**Exemplo:**\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Funciona com tipos mistos tambem\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n\n// Delimitador vazio\nlet arr = [\"a\", \"b\", \"c\"];\nlet s = arr.join(\"\");          // \"abc\"\n```\n\n**Comportamento:** Converte automaticamente todos os elementos para strings.\n\n---\n\n## Encadeamento de Metodos\n\nMetodos de array podem ser encadeados para operacoes concisas:\n\n**Exemplo:**\n```hemlock\n// Encadeando slice e join\nlet result = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\n// Encadeando concat e slice\nlet combined = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);    // [3, 4, 5]\n\n// Encadeamento complexo\nlet words = [\"hello\", \"world\", \"foo\", \"bar\"];\nlet result2 = words\n    .slice(0, 3)\n    .concat([\"baz\"])\n    .join(\"-\");      // \"hello-world-foo-baz\"\n```\n\n---\n\n## Resumo Completo dos Metodos\n\n### Metodos que Modificam\n\nMetodos que modificam o array no local:\n\n| Metodo     | Assinatura                   | Retorna   | Descricao                      |\n|------------|------------------------------|-----------|--------------------------------|\n| `push`     | `(value: any)`               | `null`    | Adiciona ao final              |\n| `pop`      | `()`                         | `any`     | Remove do final                |\n| `shift`    | `()`                         | `any`     | Remove do inicio               |\n| `unshift`  | `(value: any)`               | `null`    | Adiciona ao inicio             |\n| `insert`   | `(index: i32, value: any)`   | `null`    | Insere no indice               |\n| `remove`   | `(index: i32)`               | `any`     | Remove no indice               |\n| `reverse`  | `()`                         | `null`    | Inverte no local               |\n| `clear`    | `()`                         | `null`    | Remove todos os elementos      |\n\n### Metodos que Nao Modificam\n\nMetodos que retornam novos valores sem modificar o original:\n\n| Metodo     | Assinatura                       | Retorna   | Descricao                      |\n|------------|----------------------------------|-----------|--------------------------------|\n| `find`     | `(value: any)`                   | `i32`     | Encontra primeira ocorrencia   |\n| `contains` | `(value: any)`                   | `bool`    | Verifica se contem valor       |\n| `slice`    | `(start: i32, end: i32)`         | `array`   | Extrai sub-array               |\n| `first`    | `()`                             | `any`     | Obtem primeiro elemento        |\n| `last`     | `()`                             | `any`     | Obtem ultimo elemento          |\n| `concat`   | `(other: array)`                 | `array`   | Concatena arrays               |\n| `join`     | `(delimiter: string)`            | `string`  | Junta elementos em string      |\n| `map`      | `(callback: fn)`                 | `array`   | Transforma cada elemento       |\n| `filter`   | `(predicate: fn)`                | `array`   | Seleciona elementos            |\n| `reduce`   | `(callback: fn, initial: any)`   | `any`     | Reduz a um unico valor         |\n\n---\n\n## Padroes de Uso\n\n### Uso como Pilha\n\n```hemlock\nlet stack = [];\n\n// Empilhar\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Desempilhar\nwhile (stack.length > 0) {\n    let item = stack.pop();\n    print(item);  // 3, 2, 1\n}\n```\n\n### Uso como Fila\n\n```hemlock\nlet queue = [];\n\n// Enfileirar\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Desenfileirar\nwhile (queue.length > 0) {\n    let item = queue.shift();\n    print(item);  // 1, 2, 3\n}\n```\n\n### Transformacao de Array\n\n```hemlock\n// Filtragem (modo manual)\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = [];\nlet i = 0;\nwhile (i < numbers.length) {\n    if (numbers[i] % 2 == 0) {\n        evens.push(numbers[i]);\n    }\n    i = i + 1;\n}\n\n// Mapeamento (modo manual)\nlet numbers2 = [1, 2, 3, 4, 5];\nlet doubled = [];\nlet j = 0;\nwhile (j < numbers2.length) {\n    doubled.push(numbers2[j] * 2);\n    j = j + 1;\n}\n```\n\n### Construindo Arrays\n\n```hemlock\nlet arr = [];\n\n// Construir array com loop\nlet i = 0;\nwhile (i < 10) {\n    arr.push(i * 10);\n    i = i + 1;\n}\n\nprint(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n```\n\n---\n\n## Detalhes de Implementacao\n\n**Gerenciamento de Capacidade:**\n- Arrays crescem automaticamente conforme necessario\n- Capacidade dobra quando excedida\n- Sem controle manual de capacidade\n\n**Comparacao de Valores:**\n- `find()` e `contains()` usam igualdade de valor\n- Funciona corretamente para tipos primitivos e strings\n- Objetos/arrays sao comparados por referencia\n\n**Memoria:**\n- Alocado no heap\n- Sem liberacao automatica (gerenciamento manual de memoria)\n- Acesso direto por indice nao verifica limites\n\n---\n\n## Veja Tambem\n\n- [Sistema de Tipos](#reference-type-system) - Detalhes do tipo array\n- [API de Strings](#reference-string-api) - Resultado do join() em strings\n- [Operadores](#reference-operators) - Operador de indexacao de array\n"}, "Referncia da API -> API de Concorrncia": {"id": "reference-concurrency-api", "content": "# Referencia da API de Concorrencia\n\nDocumentacao completa do sistema assincrono/concorrente do Hemlock.\n\n---\n\n## Visao Geral\n\nHemlock fornece **concorrencia estruturada** e verdadeiro paralelismo multithreaded usando threads POSIX (pthreads). Cada tarefa criada executa em uma thread de sistema operacional separada, permitindo execucao paralela real atraves de multiplos nucleos de CPU.\n\n**Caracteristicas Principais:**\n- Verdadeiro paralelismo multithreaded (nao green threads)\n- Sintaxe de funcoes assincronas\n- Criacao e uniao de tarefas\n- Canais thread-safe\n- Propagacao de excecoes\n\n**Modelo de Threading:**\n- Threads de SO reais (POSIX pthreads)\n- Verdadeiro paralelismo (multiplos nucleos de CPU)\n- Escalonamento do kernel (multitarefa preemptiva)\n- Sincronizacao thread-safe (mutexes, variaveis de condicao)\n\n---\n\n## Funcoes Assincronas\n\n### Declaracao de Funcao Assincrona\n\nFuncoes podem ser declaradas como `async` para indicar que sao projetadas para execucao concorrente.\n\n**Sintaxe:**\n```hemlock\nasync fn nome_funcao(params): tipo_retorno {\n    // corpo da funcao\n}\n```\n\n**Exemplo:**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nasync fn process_data(data: string) {\n    print(\"Processando:\", data);\n    return null;\n}\n```\n\n**Comportamento:**\n- `async fn` declara uma funcao assincrona\n- Pode ser chamada sincronamente (executa na thread atual)\n- Pode ser criada como tarefa concorrente (executa em nova thread)\n- Quando criada, executa em sua propria thread de SO\n\n**Nota:** A palavra-chave `await` esta reservada para uso futuro, mas nao esta implementada atualmente.\n\n---\n\n## Gerenciamento de Tarefas\n\n### spawn\n\nCria e inicia uma nova tarefa concorrente.\n\n**Assinatura:**\n```hemlock\nspawn(async_fn: function, ...args): task\n```\n\n**Parametros:**\n- `async_fn` - A funcao assincrona a executar\n- `...args` - Argumentos a passar para a funcao\n\n**Retorna:** Handle de tarefa\n\n**Exemplo:**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Cria uma unica tarefa\nlet t = spawn(compute, 1000);\nlet result = join(t);\nprint(result);\n\n// Cria multiplas tarefas (executam em paralelo!)\nlet t1 = spawn(compute, 100);\nlet t2 = spawn(compute, 200);\nlet t3 = spawn(compute, 300);\n\n// Tres tarefas executando simultaneamente!\n\n// Aguarda resultados\nlet r1 = join(t1);\nlet r2 = join(t2);\nlet r3 = join(t3);\n```\n\n**Comportamento:**\n- Cria nova thread de SO via `pthread_create()`\n- Comeca a executar a funcao imediatamente\n- Retorna handle de tarefa para uniao posterior\n- Tarefas executam em paralelo em nucleos de CPU separados\n\n---\n\n### join\n\nAguarda a conclusao de uma tarefa e obtem seu resultado.\n\n**Assinatura:**\n```hemlock\njoin(task: task): any\n```\n\n**Parametros:**\n- `task` - Handle de tarefa de `spawn()`\n\n**Retorna:** O valor de retorno da tarefa\n\n**Exemplo:**\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nlet t = spawn(factorial, 10);\nlet result = join(t);  // Bloqueia ate a tarefa completar\nprint(result);         // 3628800\n```\n\n**Comportamento:**\n- Bloqueia a thread atual ate a tarefa completar\n- Retorna o valor de retorno da tarefa\n- Propaga excecoes lancadas na tarefa\n- Limpa recursos da tarefa apos retornar\n\n**Tratamento de Erros:**\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Tarefa falhou!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Capturado:\", e);  // \"Capturado: Tarefa falhou!\"\n}\n```\n\n---\n\n### detach\n\nDesanexa uma tarefa (execucao fire-and-forget).\n\n**Assinatura:**\n```hemlock\ndetach(task: task): null\n```\n\n**Parametros:**\n- `task` - Handle de tarefa de `spawn()`\n\n**Retorna:** `null`\n\n**Exemplo:**\n```hemlock\nasync fn background_work() {\n    print(\"Trabalhando em segundo plano...\");\n    return null;\n}\n\nlet t = spawn(background_work);\ndetach(t);  // Tarefa continua executando independentemente\n\n// Nao pode unir tarefa desanexada\n// join(t);  // Erro\n```\n\n**Comportamento:**\n- Tarefa continua executando independentemente\n- Nao pode fazer `join()` em tarefa desanexada\n- Tarefa e thread sao limpos automaticamente quando completa\n\n**Casos de Uso:**\n- Tarefas de segundo plano fire-and-forget\n- Tarefas de log/monitoramento\n- Tarefas onde o valor de retorno nao e necessario\n\n---\n\n## Canais\n\nCanais fornecem comunicacao thread-safe entre tarefas.\n\n### channel\n\nCria um canal com buffer.\n\n**Assinatura:**\n```hemlock\nchannel(capacity: i32): channel\n```\n\n**Parametros:**\n- `capacity` - Tamanho do buffer (numero de valores)\n\n**Retorna:** Objeto de canal\n\n**Exemplo:**\n```hemlock\nlet ch = channel(10);  // Canal com buffer de capacidade 10\nlet ch2 = channel(1);  // Buffer minimo (sincrono)\nlet ch3 = channel(100); // Buffer grande\n```\n\n**Comportamento:**\n- Cria canal thread-safe\n- Usa pthread mutex para sincronizacao\n- Capacidade e fixa na criacao\n\n---\n\n### Metodos de Canal\n\n#### send\n\nEnvia um valor para o canal (bloqueia se cheio).\n\n**Assinatura:**\n```hemlock\nchannel.send(value: any): null\n```\n\n**Parametros:**\n- `value` - Valor a enviar (qualquer tipo)\n\n**Retorna:** `null`\n\n**Exemplo:**\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet t = spawn(producer, ch, 5);\n```\n\n**Comportamento:**\n- Envia valor para o canal\n- Bloqueia se o canal estiver cheio\n- Thread-safe (usa mutex)\n- Retorna apos o valor ser enviado\n\n---\n\n#### recv\n\nRecebe um valor do canal (bloqueia se vazio).\n\n**Assinatura:**\n```hemlock\nchannel.recv(): any\n```\n\n**Retorna:** Valor do canal, ou `null` se o canal estiver fechado e vazio\n\n**Exemplo:**\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet t = spawn(consumer, ch, 5);\n```\n\n**Comportamento:**\n- Recebe valor do canal\n- Bloqueia se o canal estiver vazio\n- Retorna `null` se o canal estiver fechado e vazio\n- Thread-safe (usa mutex)\n\n---\n\n#### close\n\nFecha o canal (nao permite mais envios).\n\n**Assinatura:**\n```hemlock\nchannel.close(): null\n```\n\n**Retorna:** `null`\n\n**Exemplo:**\n```hemlock\nasync fn producer(ch) {\n    ch.send(1);\n    ch.send(2);\n    ch.send(3);\n    ch.close();  // Sinaliza que nao ha mais valores\n    return null;\n}\n\nasync fn consumer(ch) {\n    while (true) {\n        let val = ch.recv();\n        if (val == null) {\n            break;  // Canal fechado\n        }\n        print(val);\n    }\n    return null;\n}\n```\n\n**Comportamento:**\n- Fecha o canal\n- Nao permite mais envios\n- `recv()` retorna `null` quando o canal estiver vazio\n- Thread-safe\n\n---\n\n## Exemplo Completo de Concorrencia\n\n### Padrao Produtor-Consumidor\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        print(\"Produzindo:\", i);\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        print(\"Consumindo:\", val);\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Cria canal\nlet ch = channel(10);\n\n// Cria produtor e consumidor\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Aguarda conclusao\njoin(p);\nlet total = join(c);\nprint(\"Total:\", total);  // 0+10+20+30+40 = 100\n```\n\n---\n\n## Computacao Paralela\n\n### Exemplo Multi-Tarefa\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Cria multiplas tarefas (executam em paralelo!)\nlet t1 = spawn(factorial, 5);   // Thread 1\nlet t2 = spawn(factorial, 6);   // Thread 2\nlet t3 = spawn(factorial, 7);   // Thread 3\nlet t4 = spawn(factorial, 8);   // Thread 4\n\n// Quatro tarefas computando simultaneamente!\n\n// Aguarda resultados\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\nlet f8 = join(t4);  // 40320\n\nprint(f5, f6, f7, f8);\n```\n\n---\n\n## Ciclo de Vida de Tarefas\n\n### Transicoes de Estado\n\n1. **Criada** - Tarefa foi criada mas ainda nao esta executando\n2. **Executando** - Tarefa esta executando em thread de SO\n3. **Completada** - Tarefa terminou (resultado disponivel)\n4. **Unida** - Resultado foi obtido, recursos limpos\n5. **Desanexada** - Tarefa continua executando independentemente\n\n### Exemplo de Ciclo de Vida\n\n```hemlock\nasync fn work(n: i32): i32 {\n    return n * 2;\n}\n\n// 1. Cria tarefa\nlet t = spawn(work, 21);  // Estado: Executando\n\n// Tarefa executa em thread separada...\n\n// 2. Une tarefa\nlet result = join(t);     // Estado: Completada -> Unida\nprint(result);            // 42\n\n// Recursos da tarefa sao limpos apos uniao\n```\n\n### Ciclo de Vida Desanexado\n\n```hemlock\nasync fn background() {\n    print(\"Tarefa de segundo plano executando\");\n    return null;\n}\n\n// 1. Cria tarefa\nlet t = spawn(background);  // Estado: Executando\n\n// 2. Desanexa tarefa\ndetach(t);                  // Estado: Desanexada\n\n// Tarefa continua executando independentemente\n// Recursos limpos pelo SO quando completa\n```\n\n---\n\n## Tratamento de Erros\n\n### Propagacao de Excecoes\n\nExcecoes lancadas em tarefas sao propagadas ao unir:\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Tarefa falhou!\";\n    }\n    return 42;\n}\n\n// Tarefa bem-sucedida\nlet t1 = spawn(risky_operation, 0);\nlet result1 = join(t1);  // 42\n\n// Tarefa que falha\nlet t2 = spawn(risky_operation, 1);\ntry {\n    let result2 = join(t2);\n} catch (e) {\n    print(\"Capturado:\", e);  // \"Capturado: Tarefa falhou!\"\n}\n```\n\n### Tratando Multiplas Tarefas\n\n```hemlock\nasync fn work(id: i32, should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Tarefa \" + typeof(id) + \" falhou\";\n    }\n    return id * 10;\n}\n\nlet t1 = spawn(work, 1, 0);\nlet t2 = spawn(work, 2, 1);  // Vai falhar\nlet t3 = spawn(work, 3, 0);\n\n// Une com tratamento de erros\ntry {\n    let r1 = join(t1);  // OK\n    print(\"Tarefa 1:\", r1);\n\n    let r2 = join(t2);  // Lanca excecao\n    print(\"Tarefa 2:\", r2);  // Nunca alcancado\n} catch (e) {\n    print(\"Erro:\", e);  // \"Erro: Tarefa 2 falhou\"\n}\n\n// Ainda pode unir tarefas restantes\nlet r3 = join(t3);\nprint(\"Tarefa 3:\", r3);\n```\n\n---\n\n## Caracteristicas de Performance\n\n### Verdadeiro Paralelismo\n\n```hemlock\nasync fn cpu_intensive(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Execucao sequencial\nlet start = get_time();\nlet r1 = cpu_intensive(10000000);\nlet r2 = cpu_intensive(10000000);\nlet sequential_time = get_time() - start;\n\n// Execucao paralela\nlet start2 = get_time();\nlet t1 = spawn(cpu_intensive, 10000000);\nlet t2 = spawn(cpu_intensive, 10000000);\njoin(t1);\njoin(t2);\nlet parallel_time = get_time() - start2;\n\n// parallel_time deve ser ~50% de sequential_time em sistema multi-core\n```\n\n**Caracteristicas Comprovadas:**\n- N tarefas podem utilizar N nucleos de CPU simultaneamente\n- Testes de estresse mostram razao de tempo CPU/wall de 8-9x (prova de paralelismo)\n- Overhead de thread: ~8KB de pilha + overhead de pthread por tarefa\n- Operacao bloqueante em uma tarefa nao bloqueia outras tarefas\n\n---\n\n## Detalhes de Implementacao\n\n### Modelo de Threading\n\n- **Threading 1:1** - Cada tarefa = 1 thread de SO (`pthread`)\n- **Escalonamento do Kernel** - Kernel do SO distribui threads entre nucleos\n- **Multitarefa Preemptiva** - SO pode interromper e alternar threads\n- **Sem GIL** - Sem lock de interpretador global (diferente de Python)\n\n### Sincronizacao\n\n- **Mutexes** - Canais usam `pthread_mutex_t`\n- **Variaveis de Condicao** - send/recv bloqueantes usam `pthread_cond_t`\n- **Operacoes Lock-Free** - Transicoes de estado de tarefa sao atomicas\n\n### Memoria e Limpeza\n\n- **Tarefas Unidas** - Limpas automaticamente apos `join()`\n- **Tarefas Desanexadas** - Limpas automaticamente quando tarefa completa\n- **Canais** - Contados por referencia, liberados quando nao mais em uso\n\n---\n\n## Limitacoes\n\n- Sem `select()` para multiplexar multiplos canais\n- Sem escalonador work-stealing (1 thread por tarefa)\n- Sem integracao de I/O assincrono (operacoes de arquivo/rede bloqueiam)\n- Capacidade de canal e fixa na criacao\n\n---\n\n## Resumo Completo da API\n\n### Funcoes\n\n| Funcao    | Assinatura                            | Retorna   | Descricao                           |\n|-----------|---------------------------------------|-----------|-------------------------------------|\n| `spawn`   | `(async_fn: function, ...args)`       | `task`    | Cria e inicia tarefa concorrente    |\n| `join`    | `(task: task)`                        | `any`     | Aguarda tarefa, obtem resultado     |\n| `detach`  | `(task: task)`                        | `null`    | Desanexa tarefa (fire-and-forget)   |\n| `channel` | `(capacity: i32)`                     | `channel` | Cria canal thread-safe              |\n\n### Metodos de Canal\n\n| Metodo  | Assinatura        | Retorna | Descricao                           |\n|---------|-------------------|---------|-------------------------------------|\n| `send`  | `(value: any)`    | `null`  | Envia valor (bloqueia se cheio)     |\n| `recv`  | `()`              | `any`   | Recebe valor (bloqueia se vazio)    |\n| `close` | `()`              | `null`  | Fecha canal                         |\n\n### Tipos\n\n| Tipo      | Descricao                              |\n|-----------|----------------------------------------|\n| `task`    | Handle para uma tarefa concorrente     |\n| `channel` | Canal de comunicacao thread-safe       |\n\n---\n\n## Melhores Praticas\n\n### O Que Fazer\n\n- Use canais para comunicacao entre tarefas\n- Trate excecoes de tarefas unidas\n- Feche canais apos enviar\n- Use `join()` para obter resultados e limpar\n- Apenas crie funcoes async\n\n### O Que Nao Fazer\n\n- Nao compartilhe estado mutavel sem sincronizacao\n- Nao una a mesma tarefa duas vezes\n- Nao envie para canal fechado\n- Nao crie funcoes nao-async\n- Nao esqueca de unir tarefas (a menos que desanexadas)\n\n---\n\n## Veja Tambem\n\n- [Funcoes Integradas](#reference-builtins) - `spawn()`, `join()`, `detach()`, `channel()`\n- [Sistema de Tipos](#reference-type-system) - Tipos task e channel\n"}, "Referncia da API -> API de Memria": {"id": "reference-memory-api", "content": "# Referencia da API de Memoria\n\nDocumentacao completa das funcoes de gerenciamento de memoria e tipos de ponteiro do Hemlock.\n\n---\n\n## Visao Geral\n\nHemlock fornece **gerenciamento manual de memoria** com alocacao e liberacao explicitas. A memoria e gerenciada atraves de dois tipos de ponteiro: ponteiros brutos (`ptr`) e buffers seguros (`buffer`).\n\n**Principios Fundamentais:**\n- Alocacao e liberacao explicitas\n- Sem coleta de lixo\n- Usuario responsavel por chamar `free()`\n- Contagem de referencias interna para seguranca de escopo/reatribuicao (veja abaixo)\n\n### Contagem de Referencias Interna\n\nO runtime usa contagem de referencias internamente para gerenciar tempos de vida de objetos dentro de escopos. Para a maioria das variaveis locais, a limpeza e automatica.\n\n**Automatico (sem `free()` necessario):**\n- Variaveis locais de tipos com contagem de referencias (buffer, array, object, string) sao liberadas ao sair do escopo\n- Reatribuicao de variavel libera o valor antigo\n- Elementos de container sao liberados quando o container e liberado\n\n**Requer `free()` manual:**\n- Ponteiros brutos de `alloc()` - sempre requerem\n- Limpeza antecipada antes do fim do escopo\n- Dados de longa duracao/globais\n\nVeja o [Guia de Gerenciamento de Memoria](../language-guide/memory.md#internal-reference-counting) para detalhes.\n\n---\n\n## Tipos de Ponteiro\n\n### ptr (Ponteiro Bruto)\n\n**Tipo:** `ptr`\n\n**Descricao:** Endereco de memoria bruto sem verificacao de limites ou rastreamento.\n\n**Tamanho:** 8 bytes\n\n**Casos de Uso:**\n- Operacoes de memoria de baixo nivel\n- FFI (Interface de Funcao Estrangeira)\n- Performance maxima (sem overhead)\n\n**Seguranca:** Inseguro - sem verificacao de limites, usuario deve rastrear tempo de vida\n\n**Exemplo:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n---\n\n### buffer (Buffer Seguro)\n\n**Tipo:** `buffer`\n\n**Descricao:** Wrapper de ponteiro seguro com verificacao de limites.\n\n**Estrutura:** Ponteiro + comprimento + capacidade + contagem de referencias\n\n**Propriedades:**\n- `.length` - Tamanho do buffer (i32)\n- `.capacity` - Capacidade alocada (i32)\n\n**Casos de Uso:**\n- Maioria das alocacoes de memoria\n- Quando seguranca e importante\n- Arrays dinamicos\n\n**Seguranca:** Verificacao de limites em acesso indexado\n\n**Contagem de Referencias:** Buffers sao contados por referencia internamente. Liberacao automatica ao sair do escopo ou reatribuir variavel. Use `free()` para limpeza antecipada ou dados de longa duracao.\n\n**Exemplo:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Verificacao de limites\nprint(b.length);        // 64\nfree(b);\n```\n\n---\n\n## Funcoes de Alocacao de Memoria\n\n### alloc\n\nAloca memoria bruta.\n\n**Assinatura:**\n```hemlock\nalloc(size: i32): ptr\n```\n\n**Parametros:**\n- `size` - Numero de bytes a alocar\n\n**Retorna:** Ponteiro para memoria alocada (`ptr`)\n\n**Exemplo:**\n```hemlock\nlet p = alloc(1024);        // Aloca 1KB\nmemset(p, 0, 1024);         // Inicializa com zeros\nfree(p);                    // Libera quando terminar\n\n// Aloca para estrutura\nlet struct_size = 16;\nlet p2 = alloc(struct_size);\n```\n\n**Comportamento:**\n- Retorna memoria nao inicializada\n- Memoria deve ser liberada manualmente\n- Retorna `null` em falha de alocacao (chamador deve verificar)\n\n**Veja Tambem:** `buffer()` para alternativa mais segura\n\n---\n\n### buffer\n\nAloca buffer seguro com verificacao de limites.\n\n**Assinatura:**\n```hemlock\nbuffer(size: i32): buffer\n```\n\n**Parametros:**\n- `size` - Tamanho do buffer (bytes)\n\n**Retorna:** Objeto buffer\n\n**Exemplo:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\nprint(buf.capacity);        // 256\n\n// Acesso com verificacao de limites\nbuf[0] = 65;                // 'A'\nbuf[255] = 90;              // 'Z'\n// buf[256] = 0;            // Erro: fora dos limites\n\nfree(buf);\n```\n\n**Propriedades:**\n- `.length` - Tamanho atual (i32)\n- `.capacity` - Capacidade alocada (i32)\n\n**Comportamento:**\n- Inicializa memoria com zeros\n- Fornece verificacao de limites em acesso indexado\n- Retorna `null` em falha de alocacao (chamador deve verificar)\n- Deve ser liberado manualmente\n\n---\n\n### free\n\nLibera memoria alocada.\n\n**Assinatura:**\n```hemlock\nfree(ptr: ptr | buffer): null\n```\n\n**Parametros:**\n- `ptr` - Ponteiro ou buffer a liberar\n\n**Retorna:** `null`\n\n**Exemplo:**\n```hemlock\n// Libera ponteiro bruto\nlet p = alloc(1024);\nfree(p);\n\n// Libera buffer\nlet buf = buffer(256);\nfree(buf);\n```\n\n**Comportamento:**\n- Libera memoria alocada por `alloc()` ou `buffer()`\n- Liberacao dupla causa crash (responsabilidade do usuario evitar)\n- Liberar ponteiro invalido causa comportamento indefinido\n\n**Importante:** Voce aloca, voce libera. Sem limpeza automatica.\n\n---\n\n### realloc\n\nRedimensiona memoria alocada.\n\n**Assinatura:**\n```hemlock\nrealloc(ptr: ptr, new_size: i32): ptr\n```\n\n**Parametros:**\n- `ptr` - Ponteiro a redimensionar\n- `new_size` - Novo tamanho (bytes)\n\n**Retorna:** Ponteiro para memoria redimensionada (pode ser endereco diferente)\n\n**Exemplo:**\n```hemlock\nlet p = alloc(100);\n// ... usa memoria ...\n\n// Precisa de mais espaco\np = realloc(p, 200);        // Agora 200 bytes\n// ... usa memoria expandida ...\n\nfree(p);\n```\n\n**Comportamento:**\n- Pode mover memoria para novo local\n- Preserva dados existentes (ate o minimo do tamanho antigo/novo)\n- Ponteiro antigo invalido apos realloc bem-sucedido (use o ponteiro retornado)\n- Se new_size for menor, dados sao truncados\n- Retorna `null` em falha de alocacao (ponteiro original ainda valido)\n\n**Importante:** Sempre verifique `null` e atualize variavel de ponteiro com o resultado.\n\n---\n\n## Operacoes de Memoria\n\n### memset\n\nPreenche memoria com um valor de byte.\n\n**Assinatura:**\n```hemlock\nmemset(ptr: ptr, byte: i32, size: i32): null\n```\n\n**Parametros:**\n- `ptr` - Ponteiro para memoria\n- `byte` - Valor de byte a preencher (0-255)\n- `size` - Numero de bytes a preencher\n\n**Retorna:** `null`\n\n**Exemplo:**\n```hemlock\nlet p = alloc(100);\n\n// Zera memoria\nmemset(p, 0, 100);\n\n// Preenche com valor especifico\nmemset(p, 0xFF, 100);\n\n// Inicializa buffer\nlet buf = alloc(256);\nmemset(buf, 65, 256);       // Preenche com 'A'\n\nfree(p);\nfree(buf);\n```\n\n**Comportamento:**\n- Escreve valor de byte em cada byte no intervalo\n- Valor de byte truncado para 8 bits (0-255)\n- Sem verificacao de limites (inseguro)\n\n---\n\n### memcpy\n\nCopia memoria da origem para o destino.\n\n**Assinatura:**\n```hemlock\nmemcpy(dest: ptr, src: ptr, size: i32): null\n```\n\n**Parametros:**\n- `dest` - Ponteiro de destino\n- `src` - Ponteiro de origem\n- `size` - Numero de bytes a copiar\n\n**Retorna:** `null`\n\n**Exemplo:**\n```hemlock\nlet src = alloc(100);\nlet dest = alloc(100);\n\n// Inicializa origem\nmemset(src, 65, 100);\n\n// Copia para destino\nmemcpy(dest, src, 100);\n\n// dest agora contem os mesmos dados que src\n\nfree(src);\nfree(dest);\n```\n\n**Comportamento:**\n- Copia byte a byte de src para dest\n- Sem verificacao de limites (inseguro)\n- Comportamento indefinido para regioes sobrepostas (use com cuidado)\n\n---\n\n## Operacoes de Memoria Tipadas\n\n### sizeof\n\nObtem o tamanho em bytes de um tipo.\n\n**Assinatura:**\n```hemlock\nsizeof(type): i32\n```\n\n**Parametros:**\n- `type` - Identificador de tipo (ex: `i32`, `f64`, `ptr`)\n\n**Retorna:** Tamanho em bytes (i32)\n\n**Tamanhos de Tipos:**\n\n| Tipo | Tamanho (bytes) |\n|------|-----------------|\n| `i8` | 1 |\n| `i16` | 2 |\n| `i32`, `integer` | 4 |\n| `i64` | 8 |\n| `u8`, `byte` | 1 |\n| `u16` | 2 |\n| `u32` | 4 |\n| `u64` | 8 |\n| `f32` | 4 |\n| `f64`, `number` | 8 |\n| `bool` | 1 |\n| `ptr` | 8 |\n| `rune` | 4 |\n\n**Exemplo:**\n```hemlock\nlet int_size = sizeof(i32);      // 4\nlet ptr_size = sizeof(ptr);      // 8\nlet float_size = sizeof(f64);    // 8\nlet byte_size = sizeof(u8);      // 1\nlet rune_size = sizeof(rune);    // 4\n\n// Calcula tamanho de alocacao de array\nlet count = 100;\nlet total = sizeof(i32) * count; // 400 bytes\n```\n\n**Comportamento:**\n- Retorna 0 para tipo desconhecido\n- Aceita identificadores de tipo e strings de tipo\n\n---\n\n### talloc\n\nAloca array de valores tipados.\n\n**Assinatura:**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**Parametros:**\n- `type` - Tipo a alocar (ex: `i32`, `f64`, `ptr`)\n- `count` - Numero de elementos (deve ser positivo)\n\n**Retorna:** Ponteiro para array alocado, ou `null` em falha de alocacao\n\n**Exemplo:**\n```hemlock\nlet arr = talloc(i32, 100);      // Array de 100 i32 (400 bytes)\nlet floats = talloc(f64, 50);    // Array de 50 f64 (400 bytes)\nlet bytes = talloc(u8, 1024);    // Array de 1024 bytes\n\n// Sempre verifique falha de alocacao\nif (arr == null) {\n    panic(\"alocacao falhou\");\n}\n\n// Usa memoria alocada\n// ...\n\nfree(arr);\nfree(floats);\nfree(bytes);\n```\n\n**Comportamento:**\n- Aloca `sizeof(type) * count` bytes\n- Retorna memoria nao inicializada\n- Memoria deve ser liberada manualmente com `free()`\n- Retorna `null` em falha de alocacao (chamador deve verificar)\n- Panic se count nao for positivo\n\n---\n\n## Propriedades de Buffer\n\n### .length\n\nObtem o tamanho do buffer.\n\n**Tipo:** `i32`\n\n**Acesso:** Somente leitura\n\n**Exemplo:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\n\nlet buf2 = buffer(1024);\nprint(buf2.length);         // 1024\n```\n\n---\n\n### .capacity\n\nObtem a capacidade do buffer.\n\n**Tipo:** `i32`\n\n**Acesso:** Somente leitura\n\n**Exemplo:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.capacity);        // 256\n```\n\n**Nota:** Atualmente, `.length` e `.capacity` sao iguais para buffers criados com `buffer()`.\n\n---\n\n## Padroes de Uso\n\n### Padrao de Alocacao Basica\n\n```hemlock\n// Aloca\nlet p = alloc(1024);\nif (p == null) {\n    panic(\"alocacao falhou\");\n}\n\n// Usa\nmemset(p, 0, 1024);\n\n// Libera\nfree(p);\n```\n\n### Padrao de Buffer Seguro\n\n```hemlock\n// Aloca buffer\nlet buf = buffer(256);\nif (buf == null) {\n    panic(\"alocacao de buffer falhou\");\n}\n\n// Usa com verificacao de limites\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\n// Libera\nfree(buf);\n```\n\n### Padrao de Crescimento Dinamico\n\n```hemlock\nlet size = 100;\nlet p = alloc(size);\nif (p == null) {\n    panic(\"alocacao falhou\");\n}\n\n// ... usa memoria ...\n\n// Precisa de mais espaco - verifica falha\nlet new_p = realloc(p, 200);\nif (new_p == null) {\n    // Ponteiro original ainda valido, limpa\n    free(p);\n    panic(\"realloc falhou\");\n}\np = new_p;\nsize = 200;\n\n// ... usa memoria expandida ...\n\nfree(p);\n```\n\n### Padrao de Copia de Memoria\n\n```hemlock\nlet original = alloc(100);\nmemset(original, 65, 100);\n\n// Cria copia\nlet copy = alloc(100);\nmemcpy(copy, original, 100);\n\nfree(original);\nfree(copy);\n```\n\n---\n\n## Consideracoes de Seguranca\n\n**Gerenciamento de memoria Hemlock e inseguro por design:**\n\n### Armadilhas Comuns\n\n**1. Vazamento de Memoria**\n```hemlock\n// Errado: vazamento de memoria\nfn create_buffer() {\n    let p = alloc(1024);\n    return null;  // Memoria vazou!\n}\n\n// Correto: limpeza adequada\nfn create_buffer() {\n    let p = alloc(1024);\n    // ... usa memoria ...\n    free(p);\n    return null;\n}\n```\n\n**2. Uso Apos Liberacao**\n```hemlock\n// Errado: uso apos liberacao\nlet p = alloc(100);\nfree(p);\nmemset(p, 0, 100);  // Crash: usando memoria liberada\n\n// Correto: nao usa apos liberar\nlet p2 = alloc(100);\nmemset(p2, 0, 100);\nfree(p2);\n// Nao usa p2 depois disso\n```\n\n**3. Liberacao Dupla**\n```hemlock\n// Errado: liberacao dupla\nlet p = alloc(100);\nfree(p);\nfree(p);  // Crash: liberacao dupla\n\n// Correto: libera apenas uma vez\nlet p2 = alloc(100);\nfree(p2);\n```\n\n**4. Estouro de Buffer (ptr)**\n```hemlock\n// Errado: estouro de buffer para ptr\nlet p = alloc(10);\nmemset(p, 65, 100);  // Crash: escrevendo alem da alocacao\n\n// Correto: usa buffer para verificacao de limites\nlet buf = buffer(10);\n// buf[100] = 65;  // Erro: verificacao de limites falha\n```\n\n**5. Ponteiro Pendurado**\n```hemlock\n// Errado: ponteiro pendurado\nlet p1 = alloc(100);\nlet p2 = p1;\nfree(p1);\nmemset(p2, 0, 100);  // Crash: p2 esta pendurado\n\n// Correto: rastreia propriedade cuidadosamente\nlet p = alloc(100);\n// ... usa p ...\nfree(p);\n// Nao mantem outras referencias para p\n```\n\n**6. Falha de Alocacao Nao Verificada**\n```hemlock\n// Errado: nao verifica null\nlet p = alloc(1000000000);  // Pode falhar em pouca memoria\nmemset(p, 0, 1000000000);   // Crash: p e null\n\n// Correto: sempre verifica resultado de alocacao\nlet p2 = alloc(1000000000);\nif (p2 == null) {\n    panic(\"sem memoria\");\n}\nmemset(p2, 0, 1000000000);\nfree(p2);\n```\n\n---\n\n## Quando Usar O Que\n\n### Use `buffer()` quando:\n- Verificacao de limites e necessaria\n- Trabalhando com dados dinamicos\n- Seguranca e importante\n- Aprendendo Hemlock\n\n### Use `alloc()` quando:\n- Performance maxima e necessaria\n- FFI/interfaceando com C\n- Voce sabe o layout exato de memoria\n- Voce e um especialista\n\n### Use `realloc()` quando:\n- Crescendo/diminuindo alocacoes\n- Arrays dinamicos\n- Dados precisam ser preservados\n\n---\n\n## Resumo Completo das Funcoes\n\n| Funcao    | Assinatura                                 | Retorna  | Descricao                  |\n|-----------|--------------------------------------------|----------|----------------------------|\n| `alloc`   | `(size: i32)`                              | `ptr`    | Aloca memoria bruta        |\n| `buffer`  | `(size: i32)`                              | `buffer` | Aloca buffer seguro        |\n| `free`    | `(ptr: ptr \\| buffer)`                     | `null`   | Libera memoria             |\n| `realloc` | `(ptr: ptr, new_size: i32)`                | `ptr`    | Redimensiona alocacao      |\n| `memset`  | `(ptr: ptr, byte: i32, size: i32)`         | `null`   | Preenche memoria           |\n| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`         | `null`   | Copia memoria              |\n| `sizeof`  | `(type)`                                   | `i32`    | Obtem tamanho do tipo      |\n| `talloc`  | `(type, count: i32)`                       | `ptr`    | Aloca array tipado         |\n\n---\n\n## Veja Tambem\n\n- [Sistema de Tipos](#reference-type-system) - Tipos de ponteiro e buffer\n- [Funcoes Integradas](#reference-builtins) - Todas as funcoes integradas\n- [API de Strings](#reference-string-api) - Metodo `.to_bytes()` de strings\n"}, "Referncia da API -> API de Strings": {"id": "reference-string-api", "content": "# Referencia da API de Strings\n\nReferencia completa do tipo string do Hemlock e todos os seus 19 metodos de string.\n\n---\n\n## Visao Geral\n\nStrings em Hemlock sao sequencias **codificadas em UTF-8, mutaveis e alocadas no heap** com suporte completo a Unicode. Todas as operacoes sao baseadas em **pontos de codigo** (caracteres), nao em bytes.\n\n**Caracteristicas Principais:**\n- Codificacao UTF-8 (U+0000 a U+10FFFF)\n- Mutavel (pode modificar caracteres no local)\n- Indexacao baseada em pontos de codigo\n- 19 metodos integrados\n- Concatenacao automatica com operador `+`\n\n---\n\n## Tipo String\n\n**Tipo:** `string`\n\n**Propriedades:**\n- `.length` - Numero de pontos de codigo (caracteres)\n- `.byte_length` - Numero de bytes UTF-8\n\n**Sintaxe Literal:** Aspas duplas `\"texto\"`\n\n**Exemplo:**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5 (pontos de codigo)\nprint(s.byte_length);   // 5 (bytes)\n\nlet emoji = \"\";\nprint(emoji.length);        // 1 (um ponto de codigo)\nprint(emoji.byte_length);   // 4 (quatro bytes UTF-8)\n```\n\n---\n\n## Indexacao\n\nStrings suportam indexacao baseada em pontos de codigo usando `[]`:\n\n**Acesso de Leitura:**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Retorna rune 'h'\n```\n\n**Acesso de Escrita:**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Muta com rune (agora \"Hello\")\n```\n\n**Exemplo UTF-8:**\n```hemlock\nlet text = \"Hi!\";\nprint(text[0]);         // 'H'\nprint(text[1]);         // 'i'\nprint(text[2]);         // '' (um ponto de codigo)\nprint(text[3]);         // '!'\n```\n\n---\n\n## Concatenacao\n\nUse o operador `+` para concatenar strings e runes:\n\n**String + String:**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n```\n\n**String + Rune:**\n```hemlock\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\nlet decorated = \"Text\" + '';      // \"Text\"\n```\n\n**Rune + String:**\n```hemlock\nlet prefix = '>' + \" Message\";     // \"> Message\"\nlet bullet = '' + \" Item\";        // \" Item\"\n```\n\n**Concatenacao Multipla:**\n```hemlock\nlet msg = \"Hi \" + '' + \" World \" + '';  // \"Hi  World \"\n```\n\n---\n\n## Propriedades de String\n\n### .length\n\nObtem o numero de pontos de codigo Unicode (caracteres).\n\n**Tipo:** `i32`\n\n**Exemplo:**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5\n\nlet emoji = \"\";\nprint(emoji.length);    // 1 (um ponto de codigo)\n\nlet text = \"Hello !\";\nprint(text.length);     // 8 (7 ASCII + 1 emoji)\n```\n\n---\n\n### .byte_length\n\nObtem o numero de bytes UTF-8.\n\n**Tipo:** `i32`\n\n**Exemplo:**\n```hemlock\nlet s = \"hello\";\nprint(s.byte_length);   // 5 (1 byte por caractere ASCII)\n\nlet emoji = \"\";\nprint(emoji.byte_length); // 4 (emoji sao 4 bytes UTF-8)\n\nlet text = \"Hello !\";\nprint(text.byte_length);  // 11 (7 ASCII + 4 para emoji)\n```\n\n---\n\n## Metodos de String\n\n### Substrings e Fatiamento\n\n#### substr\n\nExtrai substring por posicao e comprimento.\n\n**Assinatura:**\n```hemlock\nstring.substr(start: i32, length: i32): string\n```\n\n**Parametros:**\n- `start` - Indice do ponto de codigo inicial (baseado em 0)\n- `length` - Numero de pontos de codigo a extrair\n\n**Retorna:** Nova string\n\n**Exemplo:**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\"\nlet first = s.substr(0, 5);     // \"hello\"\n\n// Exemplo UTF-8\nlet text = \"Hi!\";\nlet emoji = text.substr(2, 1);  // \"\"\n```\n\n---\n\n#### slice\n\nExtrai substring por intervalo (final exclusivo).\n\n**Assinatura:**\n```hemlock\nstring.slice(start: i32, end: i32): string\n```\n\n**Parametros:**\n- `start` - Indice do ponto de codigo inicial (baseado em 0)\n- `end` - Indice do ponto de codigo final (exclusivo)\n\n**Retorna:** Nova string\n\n**Exemplo:**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.slice(0, 5);        // \"hello\"\nlet world = s.slice(6, 11);     // \"world\"\n\n// Exemplo UTF-8\nlet text = \"Hi!\";\nlet first_three = text.slice(0, 3);  // \"Hi\"\n```\n\n---\n\n### Busca e Localizacao\n\n#### find\n\nEncontra a primeira ocorrencia de uma substring.\n\n**Assinatura:**\n```hemlock\nstring.find(needle: string): i32\n```\n\n**Parametros:**\n- `needle` - A substring a ser buscada\n\n**Retorna:** Indice do ponto de codigo da primeira ocorrencia, ou `-1` se nao encontrada\n\n**Exemplo:**\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6\nlet pos2 = s.find(\"foo\");       // -1 (nao encontrado)\nlet pos3 = s.find(\"l\");         // 2 (primeiro 'l')\n```\n\n---\n\n#### contains\n\nVerifica se a string contem uma substring.\n\n**Assinatura:**\n```hemlock\nstring.contains(needle: string): bool\n```\n\n**Parametros:**\n- `needle` - A substring a ser buscada\n\n**Retorna:** `true` se encontrada, caso contrario `false`\n\n**Exemplo:**\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n---\n\n### Divisao e Uniao\n\n#### split\n\nDivide a string em um array por delimitador.\n\n**Assinatura:**\n```hemlock\nstring.split(delimiter: string): array\n```\n\n**Parametros:**\n- `delimiter` - A string pela qual dividir\n\n**Retorna:** Array de strings\n\n**Exemplo:**\n```hemlock\nlet csv = \"a,b,c\";\nlet parts = csv.split(\",\");     // [\"a\", \"b\", \"c\"]\n\nlet path = \"/usr/local/bin\";\nlet dirs = path.split(\"/\");     // [\"\", \"usr\", \"local\", \"bin\"]\n\nlet text = \"hello world foo\";\nlet words = text.split(\" \");    // [\"hello\", \"world\", \"foo\"]\n```\n\n---\n\n#### trim\n\nRemove espacos em branco do inicio e fim.\n\n**Assinatura:**\n```hemlock\nstring.trim(): string\n```\n\n**Retorna:** Nova string com espacos removidos\n\n**Exemplo:**\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet text = \"\\n\\t  world  \\n\";\nlet clean2 = text.trim();       // \"world\"\n```\n\n---\n\n### Conversao de Maiusculas/Minusculas\n\n#### to_upper\n\nConverte a string para maiusculas.\n\n**Assinatura:**\n```hemlock\nstring.to_upper(): string\n```\n\n**Retorna:** Nova string em maiusculas\n\n**Exemplo:**\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\nlet mixed = \"HeLLo\";\nlet upper2 = mixed.to_upper();  // \"HELLO\"\n```\n\n---\n\n#### to_lower\n\nConverte a string para minusculas.\n\n**Assinatura:**\n```hemlock\nstring.to_lower(): string\n```\n\n**Retorna:** Nova string em minusculas\n\n**Exemplo:**\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n\nlet mixed = \"HeLLo\";\nlet lower2 = mixed.to_lower();  // \"hello\"\n```\n\n---\n\n### Prefixo e Sufixo\n\n#### starts_with\n\nVerifica se a string comeca com o prefixo especificado.\n\n**Assinatura:**\n```hemlock\nstring.starts_with(prefix: string): bool\n```\n\n**Parametros:**\n- `prefix` - O prefixo a verificar\n\n**Retorna:** `true` se a string comecar com o prefixo, caso contrario `false`\n\n**Exemplo:**\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n---\n\n#### ends_with\n\nVerifica se a string termina com o sufixo especificado.\n\n**Assinatura:**\n```hemlock\nstring.ends_with(suffix: string): bool\n```\n\n**Parametros:**\n- `suffix` - O sufixo a verificar\n\n**Retorna:** `true` se a string terminar com o sufixo, caso contrario `false`\n\n**Exemplo:**\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n---\n\n### Substituicao\n\n#### replace\n\nSubstitui a primeira ocorrencia de uma substring.\n\n**Assinatura:**\n```hemlock\nstring.replace(old: string, new: string): string\n```\n\n**Parametros:**\n- `old` - A substring a ser substituida\n- `new` - A string de substituicao\n\n**Retorna:** Nova string com a primeira ocorrencia substituida\n\n**Exemplo:**\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");  // \"hello there\"\n\nlet text = \"foo foo foo\";\nlet text2 = text.replace(\"foo\", \"bar\"); // \"bar foo foo\" (apenas a primeira)\n```\n\n---\n\n#### replace_all\n\nSubstitui todas as ocorrencias de uma substring.\n\n**Assinatura:**\n```hemlock\nstring.replace_all(old: string, new: string): string\n```\n\n**Parametros:**\n- `old` - A substring a ser substituida\n- `new` - A string de substituicao\n\n**Retorna:** Nova string com todas as ocorrencias substituidas\n\n**Exemplo:**\n```hemlock\nlet text = \"foo foo foo\";\nlet text2 = text.replace_all(\"foo\", \"bar\"); // \"bar bar bar\"\n\nlet s = \"hello world hello\";\nlet s2 = s.replace_all(\"hello\", \"hi\");      // \"hi world hi\"\n```\n\n---\n\n### Repeticao\n\n#### repeat\n\nRepete a string n vezes.\n\n**Assinatura:**\n```hemlock\nstring.repeat(count: i32): string\n```\n\n**Parametros:**\n- `count` - Numero de repeticoes\n\n**Retorna:** Nova string repetida count vezes\n\n**Exemplo:**\n```hemlock\nlet s = \"ha\";\nlet repeated = s.repeat(3);     // \"hahaha\"\n\nlet line = \"-\";\nlet separator = line.repeat(40); // \"----------------------------------------\"\n```\n\n---\n\n### Acesso a Caracteres\n\n#### char_at\n\nObtem o ponto de codigo Unicode em um indice especificado.\n\n**Assinatura:**\n```hemlock\nstring.char_at(index: i32): rune\n```\n\n**Parametros:**\n- `index` - Indice do ponto de codigo (baseado em 0)\n\n**Retorna:** Rune (ponto de codigo Unicode)\n\n**Exemplo:**\n```hemlock\nlet s = \"hello\";\nlet ch = s.char_at(0);          // 'h'\nlet ch2 = s.char_at(1);         // 'e'\n\n// Exemplo UTF-8\nlet emoji = \"\";\nlet ch3 = emoji.char_at(0);     // U+1F680 (foguete)\n```\n\n---\n\n#### chars\n\nConverte a string em um array de runes.\n\n**Assinatura:**\n```hemlock\nstring.chars(): array\n```\n\n**Retorna:** Array de runes (pontos de codigo)\n\n**Exemplo:**\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']\n\n// Exemplo UTF-8\nlet text = \"Hi!\";\nlet chars2 = text.chars();      // ['H', 'i', '', '!']\n```\n\n---\n\n### Acesso a Bytes\n\n#### byte_at\n\nObtem o valor do byte em um indice especificado.\n\n**Assinatura:**\n```hemlock\nstring.byte_at(index: i32): u8\n```\n\n**Parametros:**\n- `index` - Indice do byte (baseado em 0, nao indice de ponto de codigo)\n\n**Retorna:** Valor do byte (u8)\n\n**Exemplo:**\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (ASCII 'h')\nlet byte2 = s.byte_at(1);       // 101 (ASCII 'e')\n\n// Exemplo UTF-8\nlet emoji = \"\";\nlet byte3 = emoji.byte_at(0);   // 240 (primeiro byte UTF-8)\n```\n\n---\n\n#### bytes\n\nConverte a string em um array de bytes.\n\n**Assinatura:**\n```hemlock\nstring.bytes(): array\n```\n\n**Retorna:** Array de bytes u8\n\n**Exemplo:**\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111]\n\n// Exemplo UTF-8\nlet emoji = \"\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 bytes UTF-8)\n```\n\n---\n\n#### to_bytes\n\nConverte a string em um buffer.\n\n**Assinatura:**\n```hemlock\nstring.to_bytes(): buffer\n```\n\n**Retorna:** Buffer contendo bytes UTF-8\n\n**Exemplo:**\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();\nprint(buf.length);              // 5\n\n// Exemplo UTF-8\nlet emoji = \"\";\nlet buf2 = emoji.to_bytes();\nprint(buf2.length);             // 4\n```\n\n**Nota:** Este e um metodo legado. Prefira `.bytes()` na maioria dos casos.\n\n---\n\n### Desserializacao JSON\n\n#### deserialize\n\nAnalisa uma string JSON em um valor.\n\n**Assinatura:**\n```hemlock\nstring.deserialize(): any\n```\n\n**Retorna:** Valor analisado (objeto, array, numero, string, booleano ou null)\n\n**Exemplo:**\n```hemlock\nlet json = '{\"x\":10,\"y\":20}';\nlet obj = json.deserialize();\nprint(obj.x);                   // 10\nprint(obj.y);                   // 20\n\nlet arr_json = '[1,2,3]';\nlet arr = arr_json.deserialize();\nprint(arr[0]);                  // 1\n\nlet num_json = '42';\nlet num = num_json.deserialize();\nprint(num);                     // 42\n```\n\n**Tipos Suportados:**\n- Objetos: `{\"key\": value}`\n- Arrays: `[1, 2, 3]`\n- Numeros: `42`, `3.14`\n- Strings: `\"texto\"`\n- Booleanos: `true`, `false`\n- Nulo: `null`\n\n**Veja Tambem:** Metodo `.serialize()` de objetos\n\n---\n\n## Encadeamento de Metodos\n\nMetodos de string podem ser encadeados para operacoes concisas:\n\n**Exemplo:**\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \");                  // \"foo | bar | baz\"\n\nlet cleaned = \"  HELLO  \"\n    .trim()\n    .to_lower();                   // \"hello\"\n```\n\n---\n\n## Resumo Completo dos Metodos\n\n| Metodo         | Assinatura                                       | Retorna   | Descricao                         |\n|----------------|--------------------------------------------------|-----------|-----------------------------------|\n| `substr`       | `(start: i32, length: i32)`                      | `string`  | Extrai substring por posicao/comprimento |\n| `slice`        | `(start: i32, end: i32)`                         | `string`  | Extrai substring por intervalo    |\n| `find`         | `(needle: string)`                               | `i32`     | Encontra primeira ocorrencia (-1 se nao encontrada) |\n| `contains`     | `(needle: string)`                               | `bool`    | Verifica se contem substring      |\n| `split`        | `(delimiter: string)`                            | `array`   | Divide em array                   |\n| `trim`         | `()`                                             | `string`  | Remove espacos em branco          |\n| `to_upper`     | `()`                                             | `string`  | Converte para maiusculas          |\n| `to_lower`     | `()`                                             | `string`  | Converte para minusculas          |\n| `starts_with`  | `(prefix: string)`                               | `bool`    | Verifica se comeca com prefixo    |\n| `ends_with`    | `(suffix: string)`                               | `bool`    | Verifica se termina com sufixo    |\n| `replace`      | `(old: string, new: string)`                     | `string`  | Substitui primeira ocorrencia     |\n| `replace_all`  | `(old: string, new: string)`                     | `string`  | Substitui todas as ocorrencias    |\n| `repeat`       | `(count: i32)`                                   | `string`  | Repete a string n vezes           |\n| `char_at`      | `(index: i32)`                                   | `rune`    | Obtem ponto de codigo no indice   |\n| `byte_at`      | `(index: i32)`                                   | `u8`      | Obtem byte no indice              |\n| `chars`        | `()`                                             | `array`   | Converte para array de runes      |\n| `bytes`        | `()`                                             | `array`   | Converte para array de bytes      |\n| `to_bytes`     | `()`                                             | `buffer`  | Converte para buffer (legado)     |\n| `deserialize`  | `()`                                             | `any`     | Analisa string JSON               |\n\n---\n\n## Veja Tambem\n\n- [Sistema de Tipos](#reference-type-system) - Detalhes do tipo string\n- [API de Arrays](#reference-array-api) - Metodos de array para resultados de split()\n- [Operadores](#reference-operators) - Operador de concatenacao de strings\n"}, "Referncia da API -> Funes Integradas": {"id": "reference-builtins", "content": "# Referencia de Funcoes Integradas\n\nDocumentacao completa de todas as funcoes integradas e constantes do Hemlock.\n\n---\n\n## Visao Geral\n\nHemlock fornece um conjunto de funcoes integradas para I/O, introspeccao de tipos, gerenciamento de memoria, concorrencia e interacao com o sistema. Todas as funcoes integradas estao disponiveis globalmente sem necessidade de importacao.\n\n---\n\n## Funcoes de I/O\n\n### print\n\nImprime valores na saida padrao com nova linha.\n\n**Assinatura:**\n```hemlock\nprint(...values): null\n```\n\n**Parametros:**\n- `...values` - Qualquer numero de valores para imprimir\n\n**Retorna:** `null`\n\n**Exemplo:**\n```hemlock\nprint(\"Hello, World!\");\nprint(42);\nprint(3.14);\nprint(true);\nprint([1, 2, 3]);\nprint({ x: 10, y: 20 });\n\n// Multiplos valores\nprint(\"x =\", 10, \"y =\", 20);\n```\n\n**Comportamento:**\n- Converte todos os valores para strings\n- Multiplos valores separados por espacos\n- Adiciona nova linha no final\n- Libera a saida padrao\n\n---\n\n### read_line\n\nLe uma linha de texto da entrada padrao (entrada do usuario).\n\n**Assinatura:**\n```hemlock\nread_line(): string | null\n```\n\n**Parametros:** Nenhum\n\n**Retorna:**\n- `string` - A linha lida da entrada padrao (sem nova linha)\n- `null` - Em EOF (fim de arquivo/entrada)\n\n**Exemplo:**\n```hemlock\n// Prompt simples\nprint(\"Qual e o seu nome?\");\nlet name = read_line();\nprint(\"Ola, \" + name + \"!\");\n\n// Lendo numero (requer parsing manual)\nprint(\"Digite um numero:\");\nlet input = read_line();\nlet num = parse_int(input);  // Veja parse_int abaixo\nprint(\"Dobro:\", num * 2);\n\n// Tratando EOF\nlet line = read_line();\nif (line == null) {\n    print(\"Fim da entrada\");\n}\n\n// Lendo multiplas linhas\nprint(\"Digite linhas (Ctrl+D para parar):\");\nwhile (true) {\n    let line = read_line();\n    if (line == null) {\n        break;\n    }\n    print(\"Voce disse:\", line);\n}\n```\n\n**Comportamento:**\n- Bloqueia ate o usuario pressionar Enter\n- Remove nova linha final (`\\n`) e retorno de carro (`\\r`)\n- Retorna `null` em EOF (Ctrl+D no Unix, Ctrl+Z no Windows)\n- Le apenas da entrada padrao (nao de arquivo)\n\n**Parseando Entrada do Usuario:**\n\nComo `read_line()` sempre retorna string, voce precisa parsear entrada numerica manualmente:\n\n```hemlock\n// Parser de inteiro simples\nfn parse_int(s: string): i32 {\n    let result: i32 = 0;\n    let negative = false;\n    let i = 0;\n\n    if (s.length > 0 && s.char_at(0) == '-') {\n        negative = true;\n        i = 1;\n    }\n\n    while (i < s.length) {\n        let c = s.char_at(i);\n        let code: i32 = c;\n        if (code >= 48 && code <= 57) {\n            result = result * 10 + (code - 48);\n        } else {\n            break;\n        }\n        i = i + 1;\n    }\n\n    if (negative) {\n        return -result;\n    }\n    return result;\n}\n\n// Uso\nprint(\"Digite sua idade:\");\nlet age = parse_int(read_line());\nprint(\"Em 10 anos voce tera\", age + 10);\n```\n\n**Veja Tambem:** [API de Arquivos](#reference-file-api) para ler de arquivos\n\n---\n\n### eprint\n\nImprime valores na saida de erro padrao com nova linha.\n\n**Assinatura:**\n```hemlock\neprint(value: any): null\n```\n\n**Parametros:**\n- `value` - Valor unico para imprimir na saida de erro padrao\n\n**Retorna:** `null`\n\n**Exemplo:**\n```hemlock\neprint(\"Erro: arquivo nao encontrado\");\neprint(404);\neprint(\"Aviso: \" + message);\n\n// Padrao tipico de tratamento de erros\nfn load_config(path: string) {\n    if (!exists(path)) {\n        eprint(\"Erro: arquivo de configuracao nao encontrado: \" + path);\n        return null;\n    }\n    // ...\n}\n```\n\n**Comportamento:**\n- Imprime na saida de erro padrao (stderr)\n- Adiciona nova linha no final\n- Aceita apenas um argumento (diferente de `print`)\n- Util para mensagens de erro que nao devem misturar com saida normal\n\n**Diferenca de print:**\n- `print()` -> stdout (saida normal, redirecionada com `>`)\n- `eprint()` -> stderr (saida de erro, redirecionada com `2>`)\n\n```bash\n# Exemplo no shell: separando stdout e stderr\n./hemlock script.hml > output.txt 2> errors.txt\n```\n\n---\n\n## Introspeccao de Tipos\n\n### typeof\n\nObtem o nome do tipo de um valor.\n\n**Assinatura:**\n```hemlock\ntypeof(value: any): string\n```\n\n**Parametros:**\n- `value` - Qualquer valor\n\n**Retorna:** String com o nome do tipo\n\n**Exemplo:**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof(null));            // \"null\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\n// Objetos tipados\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n\n// Outros tipos\nprint(typeof(alloc(10)));       // \"ptr\"\nprint(typeof(buffer(10)));      // \"buffer\"\nprint(typeof(open(\"file.txt\"))); // \"file\"\n```\n\n**Nomes de Tipos:**\n- Tipos primitivos: `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- Tipos compostos: `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- Tipos especiais: `\"file\"`, `\"task\"`, `\"channel\"`\n- Tipos personalizados: Nomes de tipo definidos pelo usuario de `define`\n\n**Veja Tambem:** [Sistema de Tipos](#reference-type-system)\n\n---\n\n## Execucao de Comandos\n\n### exec\n\nExecuta um comando shell e captura a saida.\n\n**Assinatura:**\n```hemlock\nexec(command: string): object\n```\n\n**Parametros:**\n- `command` - O comando shell a executar\n\n**Retorna:** Objeto contendo:\n- `output` (string) - Saida padrao do comando\n- `exit_code` (i32) - Codigo de saida (0 = sucesso)\n\n**Exemplo:**\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n\n// Verifica status de saida\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Encontrado:\", r.output);\n} else {\n    print(\"Padrao nao encontrado\");\n}\n\n// Tratando saida multi-linha\nlet r2 = exec(\"ls -la\");\nlet lines = r2.output.split(\"\\n\");\n```\n\n**Comportamento:**\n- Executa comando via `/bin/sh`\n- Captura apenas stdout (stderr vai para o terminal)\n- Bloqueia ate o comando completar\n- Retorna string vazia se nao houver saida\n\n**Tratamento de Erros:**\n```hemlock\ntry {\n    let r = exec(\"comando_inexistente\");\n} catch (e) {\n    print(\"Falha ao executar:\", e);\n}\n```\n\n**Aviso de Seguranca:** Risco de injecao de shell. Sempre valide/sanitize entrada do usuario.\n\n**Limitacoes:**\n- Sem captura de stderr\n- Sem streaming\n- Sem timeout\n- Sem tratamento de sinais\n\n---\n\n### exec_argv\n\nExecuta um comando com array explicito de argumentos (sem interpretacao de shell).\n\n**Assinatura:**\n```hemlock\nexec_argv(argv: array): object\n```\n\n**Parametros:**\n- `argv` - Array de strings: `[comando, arg1, arg2, ...]`\n\n**Retorna:** Objeto contendo:\n- `output` (string) - Saida padrao do comando\n- `exit_code` (i32) - Codigo de saida (0 = sucesso)\n\n**Exemplo:**\n```hemlock\n// Comando simples\nlet result = exec_argv([\"ls\", \"-la\"]);\nprint(result.output);\n\n// Argumentos com espacos (seguro!)\nlet r = exec_argv([\"grep\", \"hello world\", \"file.txt\"]);\n\n// Executar script com argumentos\nlet r2 = exec_argv([\"python\", \"script.py\", \"--input\", \"data.json\"]);\nprint(r2.exit_code);\n```\n\n**Diferenca de exec:**\n```hemlock\n// exec() usa shell - inseguro para entrada do usuario\nexec(\"ls \" + user_input);  // Risco de injecao de shell!\n\n// exec_argv() ignora shell - seguro\nexec_argv([\"ls\", user_input]);  // Injecao impossivel\n```\n\n**Quando usar:**\n- Quando argumentos contem espacos, aspas ou caracteres especiais\n- Ao tratar entrada do usuario (seguranca)\n- Quando voce precisa de parsing previsivel de argumentos\n\n**Veja Tambem:** `exec()` para comandos de shell simples\n\n---\n\n## Tratamento de Erros\n\n### throw\n\nLanca uma excecao.\n\n**Assinatura:**\n```hemlock\nthrow expression\n```\n\n**Parametros:**\n- `expression` - Valor a ser lancado (qualquer tipo)\n\n**Retorna:** Nunca retorna (transfere controle)\n\n**Exemplo:**\n```hemlock\nthrow \"mensagem de erro\";\nthrow 404;\nthrow { code: 500, message: \"Erro interno\" };\nthrow null;\n```\n\n**Veja Tambem:** Instrucao try/catch/finally\n\n---\n\n### panic\n\nEncerra o programa imediatamente com mensagem de erro (irrecuperavel).\n\n**Assinatura:**\n```hemlock\npanic(message?: any): never\n```\n\n**Parametros:**\n- `message` (opcional) - Mensagem de erro a imprimir\n\n**Retorna:** Nunca retorna (programa termina)\n\n**Exemplo:**\n```hemlock\npanic();                          // Padrao: \"panic!\"\npanic(\"codigo inalcancavel atingido\");\npanic(42);\n\n// Caso de uso comum\nfn process_state(state: i32): string {\n    if (state == 1) { return \"pronto\"; }\n    if (state == 2) { return \"executando\"; }\n    panic(\"estado invalido: \" + typeof(state));\n}\n```\n\n**Comportamento:**\n- Imprime erro na saida de erro padrao: `panic: <mensagem>`\n- Termina com codigo 1\n- **Nao pode** ser capturado com try/catch\n- Use para bugs e erros irrecuperaveis\n\n**panic vs throw:**\n- `panic()` - Erro irrecuperavel, termina imediatamente\n- `throw` - Erro recuperavel, pode ser capturado\n\n---\n\n### assert\n\nAsserta que uma condicao e verdadeira, caso contrario termina com mensagem de erro.\n\n**Assinatura:**\n```hemlock\nassert(condition: any, message?: string): null\n```\n\n**Parametros:**\n- `condition` - Valor a verificar como verdadeiro\n- `message` (opcional) - Mensagem de erro personalizada se assert falhar\n\n**Retorna:** `null` (se assert passar)\n\n**Exemplo:**\n```hemlock\n// Assert basico\nassert(x > 0);\nassert(name != null);\nassert(arr.length > 0, \"Array nao pode estar vazio\");\n\n// Com mensagem personalizada\nfn divide(a: i32, b: i32): f64 {\n    assert(b != 0, \"Divisao por zero\");\n    return a / b;\n}\n\n// Validando argumentos de funcao\nfn process_data(data: array) {\n    assert(data != null, \"data nao pode ser null\");\n    assert(data.length > 0, \"data nao pode estar vazio\");\n    // ...\n}\n```\n\n**Comportamento:**\n- Se condicao for verdadeira: retorna `null`, continua execucao\n- Se condicao for falsa: imprime erro e termina com codigo 1\n- Valores falsos: `false`, `0`, `0.0`, `null`, `\"\"` (string vazia)\n- Valores verdadeiros: todo o resto\n\n**Saida em Falha:**\n```\nAssertion failed: Array nao pode estar vazio\n```\n\n**Quando usar:**\n- Validando pre-condicoes de funcoes\n- Verificando invariantes durante desenvolvimento\n- Capturando erros de programador cedo\n\n**assert vs panic:**\n- `assert(cond, msg)` - Verifica condicao, falha se falso\n- `panic(msg)` - Falha incondicionalmente\n\n---\n\n## Tratamento de Sinais\n\n### signal\n\nRegistra ou reseta um handler de sinal.\n\n**Assinatura:**\n```hemlock\nsignal(signum: i32, handler: function | null): function | null\n```\n\n**Parametros:**\n- `signum` - Numero do sinal (use constantes como `SIGINT`)\n- `handler` - Funcao a chamar quando sinal for recebido, ou `null` para resetar ao padrao\n\n**Retorna:** Funcao handler anterior, ou `null`\n\n**Exemplo:**\n```hemlock\nfn handle_interrupt(sig) {\n    print(\"Capturado SIGINT!\");\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Reseta ao padrao\nsignal(SIGINT, null);\n```\n\n**Assinatura do Handler:**\n```hemlock\nfn handler(signum: i32) {\n    // signum contem o numero do sinal\n}\n```\n\n**Veja Tambem:**\n- [Constantes de Sinal](#constantes-de-sinal)\n- `raise()`\n\n---\n\n### raise\n\nEnvia um sinal para o processo atual.\n\n**Assinatura:**\n```hemlock\nraise(signum: i32): null\n```\n\n**Parametros:**\n- `signum` - Numero do sinal a enviar\n\n**Retorna:** `null`\n\n**Exemplo:**\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\nraise(SIGUSR1);\nraise(SIGUSR1);\nprint(count);  // 2\n```\n\n---\n\n## Variaveis Globais\n\n### args\n\nArray de argumentos de linha de comando.\n\n**Tipo:** `array` de strings\n\n**Estrutura:**\n- `args[0]` - Nome do arquivo do script\n- `args[1..n]` - Argumentos de linha de comando\n\n**Exemplo:**\n```bash\n# Comando: ./hemlock script.hml hello world\n```\n\n```hemlock\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // 3\nprint(args[1]);        // \"hello\"\nprint(args[2]);        // \"world\"\n\n// Itera sobre argumentos\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argumento\", i, \":\", args[i]);\n    i = i + 1;\n}\n```\n\n**Comportamento no REPL:** No REPL, `args.length` e 0 (array vazio)\n\n---\n\n## Constantes de Sinal\n\nConstantes de sinal POSIX padrao (valores i32):\n\n### Interrupcao e Terminacao\n\n| Constante  | Valor | Descricao                              |\n|------------|-------|----------------------------------------|\n| `SIGINT`   | 2     | Interrupcao do teclado (Ctrl+C)        |\n| `SIGTERM`  | 15    | Requisicao de terminacao               |\n| `SIGQUIT`  | 3     | Quit do teclado (Ctrl+\\)               |\n| `SIGHUP`   | 1     | Hangup detectado no terminal de controle |\n| `SIGABRT`  | 6     | Sinal de abort                         |\n\n### Definidos pelo Usuario\n\n| Constante  | Valor | Descricao                   |\n|------------|-------|-----------------------------|\n| `SIGUSR1`  | 10    | Sinal definido pelo usuario 1 |\n| `SIGUSR2`  | 12    | Sinal definido pelo usuario 2 |\n\n### Controle de Processo\n\n| Constante  | Valor | Descricao                        |\n|------------|-------|----------------------------------|\n| `SIGALRM`  | 14    | Timer de alarme                  |\n| `SIGCHLD`  | 17    | Mudanca de status do filho       |\n| `SIGCONT`  | 18    | Continua se parado               |\n| `SIGSTOP`  | 19    | Para processo (nao pode ser capturado) |\n| `SIGTSTP`  | 20    | Stop do terminal (Ctrl+Z)        |\n\n### I/O\n\n| Constante  | Valor | Descricao                       |\n|------------|-------|---------------------------------|\n| `SIGPIPE`  | 13    | Pipe quebrado                   |\n| `SIGTTIN`  | 21    | Leitura de terminal em segundo plano |\n| `SIGTTOU`  | 22    | Escrita em terminal em segundo plano |\n\n**Exemplo:**\n```hemlock\nfn handle_signal(sig) {\n    if (sig == SIGINT) {\n        print(\"Interrupcao detectada\");\n    }\n    if (sig == SIGTERM) {\n        print(\"Terminacao solicitada\");\n    }\n}\n\nsignal(SIGINT, handle_signal);\nsignal(SIGTERM, handle_signal);\n```\n\n**Nota:** `SIGKILL` (9) e `SIGSTOP` (19) nao podem ser capturados ou ignorados.\n\n---\n\n## Funcoes Matematicas/Aritmeticas\n\n### div\n\nRetorna divisao inteira (floor) como ponto flutuante.\n\n**Assinatura:**\n```hemlock\ndiv(a: number, b: number): f64\n```\n\n**Parametros:**\n- `a` - Dividendo\n- `b` - Divisor\n\n**Retorna:** Floor de `a / b`, como ponto flutuante (f64)\n\n**Exemplo:**\n```hemlock\nlet result = div(7, 2);    // 3.0 (nao 3.5)\nlet result2 = div(10, 3);  // 3.0\nlet result3 = div(-7, 2);  // -4.0 (floor em direcao a -infinito)\n```\n\n**Nota:** Em Hemlock, o operador `/` sempre retorna ponto flutuante. Use `div()` quando precisar da parte inteira como float, ou `divi()` quando precisar de resultado inteiro.\n\n---\n\n### divi\n\nRetorna divisao inteira (floor) como inteiro.\n\n**Assinatura:**\n```hemlock\ndivi(a: number, b: number): i64\n```\n\n**Parametros:**\n- `a` - Dividendo\n- `b` - Divisor\n\n**Retorna:** Floor de `a / b`, como inteiro (i64)\n\n**Exemplo:**\n```hemlock\nlet result = divi(7, 2);    // 3\nlet result2 = divi(10, 3);  // 3\nlet result3 = divi(-7, 2);  // -4 (floor em direcao a -infinito)\n```\n\n**Comparacao:**\n```hemlock\nprint(7 / 2);      // 3.5 (divisao regular, sempre float)\nprint(div(7, 2));  // 3.0 (divisao floor, resultado float)\nprint(divi(7, 2)); // 3   (divisao floor, resultado inteiro)\n```\n\n---\n\n## Funcoes de Gerenciamento de Memoria\n\nVeja [API de Memoria](#reference-memory-api) para referencia completa:\n- `alloc(size)` - Aloca memoria bruta\n- `free(ptr)` - Libera memoria\n- `buffer(size)` - Aloca buffer seguro\n- `memset(ptr, byte, size)` - Preenche memoria\n- `memcpy(dest, src, size)` - Copia memoria\n- `realloc(ptr, new_size)` - Redimensiona alocacao\n\n### sizeof\n\nObtem o tamanho em bytes de um tipo.\n\n**Assinatura:**\n```hemlock\nsizeof(type): i32\n```\n\n**Parametros:**\n- `type` - Constante de tipo (`i32`, `f64`, `ptr`, etc.) ou nome de tipo como string\n\n**Retorna:** Tamanho em bytes, como `i32`\n\n**Exemplo:**\n```hemlock\nprint(sizeof(i8));       // 1\nprint(sizeof(i16));      // 2\nprint(sizeof(i32));      // 4\nprint(sizeof(i64));      // 8\nprint(sizeof(f32));      // 4\nprint(sizeof(f64));      // 8\nprint(sizeof(ptr));      // 8\nprint(sizeof(rune));     // 4\n\n// Usando alias de tipo\nprint(sizeof(byte));     // 1 (mesmo que u8)\nprint(sizeof(integer));  // 4 (mesmo que i32)\nprint(sizeof(number));   // 8 (mesmo que f64)\n\n// Forma de string tambem funciona\nprint(sizeof(\"i32\"));    // 4\n```\n\n**Tipos Suportados:**\n| Tipo | Tamanho | Alias |\n|------|---------|-------|\n| `i8` | 1 | - |\n| `i16` | 2 | - |\n| `i32` | 4 | `integer` |\n| `i64` | 8 | - |\n| `u8` | 1 | `byte` |\n| `u16` | 2 | - |\n| `u32` | 4 | - |\n| `u64` | 8 | - |\n| `f32` | 4 | - |\n| `f64` | 8 | `number` |\n| `ptr` | 8 | - |\n| `rune` | 4 | - |\n| `bool` | 1 | - |\n\n**Veja Tambem:** `talloc()` para alocacao tipada\n\n---\n\n### talloc\n\nAloca memoria para array tipado (alocacao type-aware).\n\n**Assinatura:**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**Parametros:**\n- `type` - Constante de tipo (`i32`, `f64`, `ptr`, etc.)\n- `count` - Numero de elementos a alocar\n\n**Retorna:** `ptr` para memoria alocada, ou `null` em falha\n\n**Exemplo:**\n```hemlock\n// Aloca array de 10 i32 (40 bytes)\nlet int_arr = talloc(i32, 10);\nptr_write_i32(int_arr, 42);\nptr_write_i32(ptr_offset(int_arr, 1, 4), 100);\n\n// Aloca array de 5 f64 (40 bytes)\nlet float_arr = talloc(f64, 5);\n\n// Aloca array de 100 bytes\nlet byte_arr = talloc(u8, 100);\n\n// Nao esqueca de liberar!\nfree(int_arr);\nfree(float_arr);\nfree(byte_arr);\n```\n\n**Comparacao com alloc:**\n```hemlock\n// Estes sao equivalentes:\nlet p1 = talloc(i32, 10);      // Type-aware: 10 i32\nlet p2 = alloc(sizeof(i32) * 10);  // Calculo manual\n\n// talloc e mais claro e menos propenso a erros\n```\n\n**Tratamento de Erros:**\n- Retorna `null` em falha de alocacao\n- Termina com erro se count nao for positivo\n- Verifica overflow de tamanho (count * element_size)\n\n**Veja Tambem:** `alloc()`, `sizeof()`, `free()`\n\n---\n\n## Helpers de Ponteiro FFI\n\nEstas funcoes ajudam a ler e escrever valores tipados em memoria bruta, uteis para FFI e operacoes de memoria de baixo nivel.\n\n### ptr_null\n\nCria um ponteiro nulo.\n\n**Assinatura:**\n```hemlock\nptr_null(): ptr\n```\n\n**Retorna:** Ponteiro nulo\n\n**Exemplo:**\n```hemlock\nlet p = ptr_null();\nif (p == null) {\n    print(\"Ponteiro e nulo\");\n}\n```\n\n---\n\n### ptr_offset\n\nCalcula deslocamento de ponteiro (aritmetica de ponteiros).\n\n**Assinatura:**\n```hemlock\nptr_offset(ptr: ptr, index: i32, element_size: i32): ptr\n```\n\n**Parametros:**\n- `ptr` - Ponteiro base\n- `index` - Indice do elemento\n- `element_size` - Tamanho de cada elemento em bytes\n\n**Retorna:** Ponteiro para elemento no indice dado\n\n**Exemplo:**\n```hemlock\nlet arr = talloc(i32, 10);\nptr_write_i32(arr, 100);                      // arr[0] = 100\nptr_write_i32(ptr_offset(arr, 1, 4), 200);    // arr[1] = 200\nptr_write_i32(ptr_offset(arr, 2, 4), 300);    // arr[2] = 300\n\nprint(ptr_read_i32(ptr_offset(arr, 1, 4)));   // 200\nfree(arr);\n```\n\n---\n\n### Funcoes de Leitura de Ponteiro\n\nLe valores tipados da memoria.\n\n| Funcao | Assinatura | Retorna | Descricao |\n|--------|------------|---------|-----------|\n| `ptr_read_i8` | `(ptr)` | `i8` | Le inteiro 8-bit com sinal |\n| `ptr_read_i16` | `(ptr)` | `i16` | Le inteiro 16-bit com sinal |\n| `ptr_read_i32` | `(ptr)` | `i32` | Le inteiro 32-bit com sinal |\n| `ptr_read_i64` | `(ptr)` | `i64` | Le inteiro 64-bit com sinal |\n| `ptr_read_u8` | `(ptr)` | `u8` | Le inteiro 8-bit sem sinal |\n| `ptr_read_u16` | `(ptr)` | `u16` | Le inteiro 16-bit sem sinal |\n| `ptr_read_u32` | `(ptr)` | `u32` | Le inteiro 32-bit sem sinal |\n| `ptr_read_u64` | `(ptr)` | `u64` | Le inteiro 64-bit sem sinal |\n| `ptr_read_f32` | `(ptr)` | `f32` | Le float 32-bit |\n| `ptr_read_f64` | `(ptr)` | `f64` | Le float 64-bit |\n| `ptr_read_ptr` | `(ptr)` | `ptr` | Le valor de ponteiro |\n\n**Exemplo:**\n```hemlock\nlet p = alloc(8);\nptr_write_f64(p, 3.14159);\nlet value = ptr_read_f64(p);\nprint(value);  // 3.14159\nfree(p);\n```\n\n---\n\n### Funcoes de Escrita de Ponteiro\n\nEscreve valores tipados na memoria.\n\n| Funcao | Assinatura | Retorna | Descricao |\n|--------|------------|---------|-----------|\n| `ptr_write_i8` | `(ptr, value)` | `null` | Escreve inteiro 8-bit com sinal |\n| `ptr_write_i16` | `(ptr, value)` | `null` | Escreve inteiro 16-bit com sinal |\n| `ptr_write_i32` | `(ptr, value)` | `null` | Escreve inteiro 32-bit com sinal |\n| `ptr_write_i64` | `(ptr, value)` | `null` | Escreve inteiro 64-bit com sinal |\n| `ptr_write_u8` | `(ptr, value)` | `null` | Escreve inteiro 8-bit sem sinal |\n| `ptr_write_u16` | `(ptr, value)` | `null` | Escreve inteiro 16-bit sem sinal |\n| `ptr_write_u32` | `(ptr, value)` | `null` | Escreve inteiro 32-bit sem sinal |\n| `ptr_write_u64` | `(ptr, value)` | `null` | Escreve inteiro 64-bit sem sinal |\n| `ptr_write_f32` | `(ptr, value)` | `null` | Escreve float 32-bit |\n| `ptr_write_f64` | `(ptr, value)` | `null` | Escreve float 64-bit |\n| `ptr_write_ptr` | `(ptr, value)` | `null` | Escreve valor de ponteiro |\n\n**Exemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\nprint(ptr_read_i32(p));  // 42\nfree(p);\n```\n\n---\n\n### Conversao Buffer/Ponteiro\n\n#### buffer_ptr\n\nObtem ponteiro bruto de um buffer.\n\n**Assinatura:**\n```hemlock\nbuffer_ptr(buf: buffer): ptr\n```\n\n**Exemplo:**\n```hemlock\nlet buf = buffer(64);\nlet p = buffer_ptr(buf);\n// Agora p aponta para a mesma memoria que buf\n```\n\n#### ptr_to_buffer\n\nCria wrapper de buffer em torno de ponteiro bruto.\n\n**Assinatura:**\n```hemlock\nptr_to_buffer(ptr: ptr, size: i32): buffer\n```\n\n**Exemplo:**\n```hemlock\nlet p = alloc(64);\nlet buf = ptr_to_buffer(p, 64);\nbuf[0] = 65;  // Agora tem verificacao de limites\n// Nota: liberar buf liberara a memoria subjacente\n```\n\n---\n\n## Funcoes de I/O de Arquivo\n\nVeja [API de Arquivos](#reference-file-api) para referencia completa:\n- `open(path, mode?)` - Abre arquivo\n\n---\n\n## Funcoes de Concorrencia\n\nVeja [API de Concorrencia](#reference-concurrency-api) para referencia completa:\n- `spawn(fn, args...)` - Cria tarefa\n- `join(task)` - Aguarda tarefa\n- `detach(task)` - Desanexa tarefa\n- `channel(capacity)` - Cria canal\n\n### apply\n\nChama uma funcao dinamicamente com array de argumentos.\n\n**Assinatura:**\n```hemlock\napply(fn: function, args: array): any\n```\n\n**Parametros:**\n- `fn` - A funcao a chamar\n- `args` - Array de argumentos a passar para a funcao\n\n**Retorna:** Valor de retorno da funcao chamada\n\n**Exemplo:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\n// Chama com array de argumentos\nlet result = apply(add, [2, 3]);\nprint(result);  // 5\n\n// Despacho dinamico\nlet operations = {\n    add: fn(a, b) { return a + b; },\n    mul: fn(a, b) { return a * b; },\n    sub: fn(a, b) { return a - b; }\n};\n\nfn calculate(op: string, args: array) {\n    return apply(operations[op], args);\n}\n\nprint(calculate(\"add\", [10, 5]));  // 15\nprint(calculate(\"mul\", [10, 5]));  // 50\nprint(calculate(\"sub\", [10, 5]));  // 5\n\n// Argumentos variaveis\nfn sum(...nums) {\n    let total = 0;\n    for (n in nums) {\n        total = total + n;\n    }\n    return total;\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(apply(sum, numbers));  // 15\n```\n\n**Casos de Uso:**\n- Despacho dinamico de funcoes baseado em valores de runtime\n- Chamando funcoes com listas de argumentos variaveis\n- Implementando utilitarios de ordem superior (map, filter, etc.)\n- Sistemas de plugins/extensoes\n\n---\n\n### select\n\nAguarda dados em multiplos canais, retorna quando qualquer canal tem dados.\n\n**Assinatura:**\n```hemlock\nselect(channels: array, timeout_ms?: i32): object | null\n```\n\n**Parametros:**\n- `channels` - Array de valores de canal\n- `timeout_ms` (opcional) - Timeout em milissegundos (-1 ou omitido para esperar infinitamente)\n\n**Retorna:**\n- `{ channel, value }` - Objeto contendo o canal que tinha dados e o valor recebido\n- `null` - Em timeout\n\n**Exemplo:**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// Tarefas produtoras\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"do canal 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"do canal 2\");\n});\n\n// Aguarda primeira mensagem\nlet result = select([ch1, ch2]);\nprint(result.value);  // \"do canal 2\" (chegou primeiro)\n\n// Com timeout\nlet result2 = select([ch1, ch2], 1000);  // Aguarda no maximo 1 segundo\nif (result2 == null) {\n    print(\"Timeout - nenhum dado recebido\");\n} else {\n    print(\"Recebido:\", result2.value);\n}\n\n// Loop de select continuo\nwhile (true) {\n    let msg = select([ch1, ch2], 5000);\n    if (msg == null) {\n        print(\"Sem atividade por 5 segundos\");\n        break;\n    }\n    print(\"Recebeu mensagem:\", msg.value);\n}\n```\n\n**Comportamento:**\n- Bloqueia ate um canal ter dados ou timeout expirar\n- Retorna imediatamente se canal ja tiver dados\n- Se canal estiver fechado e vazio, retorna `{ channel, value: null }`\n- Faz polling de canais em ordem (primeiro pronto vence)\n\n**Casos de Uso:**\n- Multiplexando multiplos produtores\n- Implementando timeouts em operacoes de canal\n- Construindo loops de eventos com multiplas fontes\n\n---\n\n## Tabela de Resumo\n\n### Funcoes\n\n| Funcao     | Categoria        | Retorna      | Descricao                         |\n|------------|------------------|--------------|-----------------------------------|\n| `print`    | I/O              | `null`       | Imprime na saida padrao           |\n| `read_line`| I/O              | `string?`    | Le linha da entrada padrao        |\n| `eprint`   | I/O              | `null`       | Imprime na saida de erro padrao   |\n| `typeof`   | Tipo             | `string`     | Obtem nome do tipo                |\n| `exec`     | Comando          | `object`     | Executa comando shell             |\n| `exec_argv`| Comando          | `object`     | Executa com array de argumentos   |\n| `assert`   | Erro             | `null`       | Asserta condicao ou termina       |\n| `panic`    | Erro             | `never`      | Erro irrecuperavel (termina)      |\n| `signal`   | Sinal            | `function?`  | Registra handler de sinal         |\n| `raise`    | Sinal            | `null`       | Envia sinal para processo         |\n| `alloc`    | Memoria          | `ptr`        | Aloca memoria bruta               |\n| `talloc`   | Memoria          | `ptr`        | Alocacao tipada                   |\n| `sizeof`   | Memoria          | `i32`        | Obtem tamanho do tipo             |\n| `free`     | Memoria          | `null`       | Libera memoria                    |\n| `buffer`   | Memoria          | `buffer`     | Aloca buffer seguro               |\n| `memset`   | Memoria          | `null`       | Preenche memoria                  |\n| `memcpy`   | Memoria          | `null`       | Copia memoria                     |\n| `realloc`  | Memoria          | `ptr`        | Redimensiona alocacao             |\n| `open`     | I/O de Arquivo   | `file`       | Abre arquivo                      |\n| `spawn`    | Concorrencia     | `task`       | Cria tarefa concorrente           |\n| `join`     | Concorrencia     | `any`        | Aguarda resultado da tarefa       |\n| `detach`   | Concorrencia     | `null`       | Desanexa tarefa                   |\n| `channel`  | Concorrencia     | `channel`    | Cria canal de comunicacao         |\n| `select`   | Concorrencia     | `object?`    | Aguarda multiplos canais          |\n| `apply`    | Funcao           | `any`        | Chama funcao com array de args    |\n\n### Variaveis Globais\n\n| Variavel   | Tipo     | Descricao                         |\n|------------|----------|-----------------------------------|\n| `args`     | `array`  | Argumentos de linha de comando    |\n\n### Constantes\n\n| Constante  | Tipo  | Categoria | Valor | Descricao                |\n|------------|-------|-----------|-------|--------------------------|\n| `SIGINT`   | `i32` | Sinal     | 2     | Interrupcao do teclado   |\n| `SIGTERM`  | `i32` | Sinal     | 15    | Requisicao de terminacao |\n| `SIGQUIT`  | `i32` | Sinal     | 3     | Quit do teclado          |\n| `SIGHUP`   | `i32` | Sinal     | 1     | Hangup                   |\n| `SIGABRT`  | `i32` | Sinal     | 6     | Abort                    |\n| `SIGUSR1`  | `i32` | Sinal     | 10    | Definido pelo usuario 1  |\n| `SIGUSR2`  | `i32` | Sinal     | 12    | Definido pelo usuario 2  |\n| `SIGALRM`  | `i32` | Sinal     | 14    | Timer de alarme          |\n| `SIGCHLD`  | `i32` | Sinal     | 17    | Mudanca de status do filho |\n| `SIGCONT`  | `i32` | Sinal     | 18    | Continua                 |\n| `SIGSTOP`  | `i32` | Sinal     | 19    | Para (nao pode capturar) |\n| `SIGTSTP`  | `i32` | Sinal     | 20    | Stop do terminal         |\n| `SIGPIPE`  | `i32` | Sinal     | 13    | Pipe quebrado            |\n| `SIGTTIN`  | `i32` | Sinal     | 21    | Leitura de terminal bg   |\n| `SIGTTOU`  | `i32` | Sinal     | 22    | Escrita em terminal bg   |\n\n---\n\n## Veja Tambem\n\n- [Sistema de Tipos](#reference-type-system) - Tipos e conversoes\n- [API de Memoria](#reference-memory-api) - Funcoes de alocacao de memoria\n- [API de Arquivos](#reference-file-api) - Funcoes de I/O de arquivo\n- [API de Concorrencia](#reference-concurrency-api) - Funcoes async/concorrencia\n- [API de Strings](#reference-string-api) - Metodos de string\n- [API de Arrays](#reference-array-api) - Metodos de array\n"}, "Referncia da API -> Operadores": {"id": "reference-operators", "content": "# Referencia de Operadores\n\nReferencia completa de todos os operadores em Hemlock, incluindo precedencia, associatividade e comportamento.\n\n---\n\n## Visao Geral\n\nHemlock fornece operadores estilo C com regras de precedencia claras. Todos os operadores seguem regras de tipo estritas com promocao automatica de tipo quando aplicavel.\n\n---\n\n## Operadores Aritmeticos\n\n### Aritmetica Binaria\n\n| Operador | Nome       | Exemplo    | Descricao         |\n|----------|------------|------------|-------------------|\n| `+`      | Adicao     | `a + b`    | Soma dois valores |\n| `-`      | Subtracao  | `a - b`    | Subtrai b de a    |\n| `*`      | Multiplicacao | `a * b` | Multiplica dois valores |\n| `/`      | Divisao    | `a / b`    | Divide a por b    |\n\n**Promocao de Tipo:**\nO resultado segue as regras de promocao de tipo (veja [Sistema de Tipos](type-system.md#type-promotion-rules)).\n\n**Exemplo:**\n```hemlock\nlet a = 10 + 5;        // 15 (i32)\nlet b = 10 - 3;        // 7 (i32)\nlet c = 4 * 5;         // 20 (i32)\nlet d = 20 / 4;        // 5 (i32)\n\n// Divisao float\nlet e = 10.0 / 3.0;    // 3.333... (f64)\n\n// Tipos mistos\nlet f: u8 = 10;\nlet g: i32 = 20;\nlet h = f + g;         // 30 (i32, promovido)\n```\n\n**Divisao por Zero:**\n- Inteiro dividido por zero: erro de runtime\n- Float dividido por zero: retorna `inf` ou `-inf`\n\n---\n\n### Aritmetica Unaria\n\n| Operador | Nome     | Exemplo | Descricao       |\n|----------|----------|---------|-----------------|\n| `-`      | Negacao  | `-a`    | Nega valor      |\n| `+`      | Positivo | `+a`    | Identidade (noop) |\n\n**Exemplo:**\n```hemlock\nlet a = 5;\nlet b = -a;            // -5\nlet c = +a;            // 5 (sem mudanca)\n\nlet x = -3.14;         // -3.14\n```\n\n---\n\n## Operadores de Comparacao\n\n| Operador | Nome            | Exemplo    | Retorna  |\n|----------|-----------------|------------|----------|\n| `==`     | Igual           | `a == b`   | `bool`   |\n| `!=`     | Diferente       | `a != b`   | `bool`   |\n| `<`      | Menor que       | `a < b`    | `bool`   |\n| `>`      | Maior que       | `a > b`    | `bool`   |\n| `<=`     | Menor ou igual  | `a <= b`   | `bool`   |\n| `>=`     | Maior ou igual  | `a >= b`   | `bool`   |\n\n**Promocao de Tipo:**\nOperandos sao promovidos antes da comparacao.\n\n**Exemplo:**\n```hemlock\nprint(5 == 5);         // true\nprint(10 != 5);        // true\nprint(3 < 7);          // true\nprint(10 > 5);         // true\nprint(5 <= 5);         // true\nprint(10 >= 5);        // true\n\n// Comparacao de string\nprint(\"hello\" == \"hello\");  // true\nprint(\"abc\" < \"def\");       // true (lexicografica)\n\n// Tipos mistos\nlet a: u8 = 10;\nlet b: i32 = 10;\nprint(a == b);         // true (promovido para i32)\n```\n\n---\n\n## Operadores Logicos\n\n| Operador | Nome      | Exemplo      | Descricao                  |\n|----------|-----------|--------------|----------------------------|\n| `&&`     | E logico  | `a && b`     | True se ambos forem true   |\n| `||`     | Ou logico | `a || b`     | True se qualquer for true  |\n| `!`      | Nao logico| `!a`         | Inverte booleano           |\n\n**Avaliacao Curto-Circuito:**\n- `&&` - Para no primeiro valor falso\n- `||` - Para no primeiro valor verdadeiro\n\n**Exemplo:**\n```hemlock\nlet a = true;\nlet b = false;\n\nprint(a && b);         // false\nprint(a || b);         // true\nprint(!a);             // false\nprint(!b);             // true\n\n// Curto-circuito\nif (x != 0 && (10 / x) > 2) {\n    print(\"seguro\");\n}\n\nif (x == 0 || (10 / x) > 2) {\n    print(\"seguro\");\n}\n```\n\n---\n\n## Operadores Bit a Bit\n\n**Restricao:** Apenas para tipos inteiros (i8-i64, u8-u64)\n\n### Bit a Bit Binarios\n\n| Operador | Nome         | Exemplo    | Descricao               |\n|----------|--------------|------------|-------------------------|\n| `&`      | E bit a bit  | `a & b`    | E em cada bit           |\n| `|`      | Ou bit a bit | `a | b`    | Ou em cada bit          |\n| `^`      | Xor bit a bit| `a ^ b`    | Ou exclusivo em cada bit|\n| `<<`     | Shift esquerda | `a << b` | Desloca bits a esquerda |\n| `>>`     | Shift direita | `a >> b`  | Desloca bits a direita  |\n\n**Preservacao de Tipo:**\nO tipo do resultado corresponde ao tipo do operando (apos promocao).\n\n**Exemplo:**\n```hemlock\nlet a = 12;  // 1100 em binario\nlet b = 10;  // 1010 em binario\n\nprint(a & b);          // 8  (1000)\nprint(a | b);          // 14 (1110)\nprint(a ^ b);          // 6  (0110)\nprint(a << 2);         // 48 (110000)\nprint(a >> 1);         // 6  (110)\n```\n\n**Exemplo Sem Sinal:**\n```hemlock\nlet c: u8 = 15;        // 00001111\nlet d: u8 = 7;         // 00000111\n\nprint(c & d);          // 7  (00000111)\nprint(c | d);          // 15 (00001111)\nprint(c ^ d);          // 8  (00001000)\n```\n\n**Comportamento de Shift Direita:**\n- Tipos com sinal: shift aritmetico (extensao de sinal)\n- Tipos sem sinal: shift logico (preenche com zeros)\n\n---\n\n### Bit a Bit Unario\n\n| Operador | Nome             | Exemplo | Descricao          |\n|----------|------------------|---------|---------------------|\n| `~`      | Complemento bit a bit | `~a` | Inverte todos os bits |\n\n**Exemplo:**\n```hemlock\nlet a = 12;            // 00001100 (i32)\nprint(~a);             // -13 (complemento de dois)\n\nlet b: u8 = 15;        // 00001111\nprint(~b);             // 240 (11110000)\n```\n\n---\n\n## Operadores de String\n\n### Concatenacao\n\n| Operador | Nome         | Exemplo    | Descricao        |\n|----------|--------------|------------|------------------|\n| `+`      | Concatenacao | `a + b`    | Concatena strings|\n\n**Exemplo:**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Contagem: \" + typeof(42); // \"Contagem: 42\"\n\n// String + rune\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\n\n// Rune + string\nlet prefix = '>' + \" Mensagem\";    // \"> Mensagem\"\n```\n\n---\n\n## Operadores de Atribuicao\n\n### Atribuicao Basica\n\n| Operador | Nome       | Exemplo    | Descricao              |\n|----------|------------|------------|------------------------|\n| `=`      | Atribuicao | `a = b`    | Atribui valor a variavel |\n\n**Exemplo:**\n```hemlock\nlet x = 10;\nx = 20;\n\nlet arr = [1, 2, 3];\narr[0] = 99;\n\nlet obj = { x: 10 };\nobj.x = 20;\n```\n\n### Atribuicao Composta\n\n#### Atribuicao Composta Aritmetica\n\n| Operador | Nome             | Exemplo    | Equivalente        |\n|----------|------------------|------------|--------------------|\n| `+=`     | Adicao atribuicao | `a += b`  | `a = a + b`        |\n| `-=`     | Subtracao atribuicao | `a -= b` | `a = a - b`       |\n| `*=`     | Multiplicacao atribuicao | `a *= b` | `a = a * b`   |\n| `/=`     | Divisao atribuicao | `a /= b` | `a = a / b`       |\n| `%=`     | Modulo atribuicao | `a %= b`  | `a = a % b`        |\n\n**Exemplo:**\n```hemlock\nlet x = 10;\nx += 5;      // x agora e 15\nx -= 3;      // x agora e 12\nx *= 2;      // x agora e 24\nx /= 4;      // x agora e 6\n\nlet count = 0;\ncount += 1;  // Incrementa por 1\n```\n\n#### Atribuicao Composta Bit a Bit\n\n| Operador | Nome              | Exemplo     | Equivalente         |\n|----------|-------------------|-------------|---------------------|\n| `&=`     | E atribuicao      | `a &= b`    | `a = a & b`         |\n| `\\|=`    | Ou atribuicao     | `a \\|= b`   | `a = a \\| b`        |\n| `^=`     | Xor atribuicao    | `a ^= b`    | `a = a ^ b`         |\n| `<<=`    | Shift esq atribuicao | `a <<= b` | `a = a << b`      |\n| `>>=`    | Shift dir atribuicao | `a >>= b` | `a = a >> b`      |\n\n**Exemplo:**\n```hemlock\nlet flags = 0b1111;\nflags &= 0b0011;   // flags agora e 0b0011 (mascara bits superiores)\nflags |= 0b1000;   // flags agora e 0b1011 (define um bit)\nflags ^= 0b0001;   // flags agora e 0b1010 (alterna um bit)\n\nlet x = 1;\nx <<= 4;           // x agora e 16 (shift esquerda por 4)\nx >>= 2;           // x agora e 4 (shift direita por 2)\n```\n\n### Incremento/Decremento\n\n| Operador | Nome       | Exemplo | Descricao        |\n|----------|------------|---------|------------------|\n| `++`     | Incremento | `a++`   | Adiciona 1 (sufixo) |\n| `--`     | Decremento | `a--`   | Subtrai 1 (sufixo) |\n\n**Exemplo:**\n```hemlock\nlet i = 0;\ni++;         // i agora e 1\ni++;         // i agora e 2\ni--;         // i agora e 1\n\n// Comum em loops\nfor (let j = 0; j < 10; j++) {\n    print(j);\n}\n```\n\n**Nota:** `++` e `--` sao ambos operadores sufixo (retornam valor antes de incrementar/decrementar)\n\n---\n\n## Operadores Null-Safe\n\n### Coalescencia Nula (`??`)\n\nRetorna operando esquerdo se nao for null, caso contrario retorna direito.\n\n| Operador | Nome               | Exemplo      | Descricao                          |\n|----------|--------------------|--------------|------------------------------------|\n| `??`     | Coalescencia nula  | `a ?? b`     | Retorna a se nao-null, senao b    |\n\n**Exemplo:**\n```hemlock\nlet name = null;\nlet display = name ?? \"Anonimo\";  // \"Anonimo\"\n\nlet value = 42;\nlet result = value ?? 0;            // 42\n\n// Encadeamento\nlet a = null;\nlet b = null;\nlet c = \"encontrado\";\nlet result2 = a ?? b ?? c;          // \"encontrado\"\n\n// Com chamadas de funcao\nfn get_config() { return null; }\nlet config = get_config() ?? { default: true };\n```\n\n---\n\n### Encadeamento Opcional (`?.`)\n\nAcessa propriedades ou chama metodos com seguranca em valores potencialmente nulos.\n\n| Operador | Nome                | Exemplo        | Descricao                                |\n|----------|---------------------|----------------|------------------------------------------|\n| `?.`     | Encadeamento opcional | `a?.b`       | Retorna a.b se a nao-null, senao null   |\n| `?.[`    | Indice opcional     | `a?.[0]`       | Retorna a[0] se a nao-null, senao null  |\n| `?.(`    | Chamada opcional    | `a?.()`        | Chama a() se a nao-null, senao null     |\n\n**Exemplo:**\n```hemlock\nlet user = null;\nlet name = user?.name;              // null (sem erro)\n\nlet person = { name: \"Alice\", address: null };\nlet city = person?.address?.city;   // null (navegacao segura)\n\n// Com arrays\nlet arr = null;\nlet first = arr?.[0];               // null\n\nlet items = [1, 2, 3];\nlet second = items?.[1];            // 2\n\n// Com chamadas de metodo\nlet obj = { greet: fn() { return \"Ola\"; } };\nlet greeting = obj?.greet?.();      // \"Ola\"\n\nlet empty = null;\nlet result = empty?.method?.();     // null\n```\n\n**Comportamento:**\n- Se operando esquerdo for null, toda a expressao curto-circuita para null\n- Se operando esquerdo nao for null, procede com acesso normalmente\n- Pode ser encadeado para acesso profundo de propriedades\n\n---\n\n## Operadores de Acesso a Membros\n\n### Operador Ponto\n\n| Operador | Nome             | Exemplo      | Descricao            |\n|----------|------------------|--------------|----------------------|\n| `.`      | Acesso a membro  | `obj.field`  | Acessa campo do objeto |\n| `.`      | Acesso a propriedade | `arr.length` | Acessa propriedade |\n\n**Exemplo:**\n```hemlock\n// Acesso a campo de objeto\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);        // \"Alice\"\n\n// Propriedade de array\nlet arr = [1, 2, 3];\nprint(arr.length);         // 3\n\n// Propriedade de string\nlet s = \"hello\";\nprint(s.length);           // 5\n\n// Chamada de metodo\nlet result = s.to_upper(); // \"HELLO\"\n```\n\n---\n\n### Operador de Indice\n\n| Operador | Nome   | Exemplo   | Descricao      |\n|----------|--------|-----------|----------------|\n| `[]`     | Indice | `arr[i]`  | Acessa elemento |\n\n**Exemplo:**\n```hemlock\n// Indexacao de array\nlet arr = [10, 20, 30];\nprint(arr[0]);             // 10\narr[1] = 99;\n\n// Indexacao de string (retorna rune)\nlet s = \"hello\";\nprint(s[0]);               // 'h'\ns[0] = 'H';                // \"Hello\"\n\n// Indexacao de buffer\nlet buf = buffer(10);\nbuf[0] = 65;\nprint(buf[0]);             // 65\n```\n\n---\n\n## Operador de Chamada de Funcao\n\n| Operador | Nome            | Exemplo      | Descricao      |\n|----------|-----------------|--------------|----------------|\n| `()`     | Chamada de funcao | `f(a, b)`  | Chama funcao   |\n\n**Exemplo:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet result = add(5, 3);    // 8\n\n// Chamada de metodo\nlet s = \"hello\";\nlet upper = s.to_upper();  // \"HELLO\"\n\n// Chamada de funcao integrada\nprint(\"mensagem\");\n```\n\n---\n\n## Precedencia de Operadores\n\nOperadores listados da maior para a menor precedencia:\n\n| Precedencia | Operadores                     | Descricao                            | Associatividade |\n|-------------|--------------------------------|--------------------------------------|-----------------|\n| 1           | `()` `[]` `.` `?.`             | Chamada, indice, membro, opcional    | Esquerda para direita |\n| 2           | `++` `--`                      | Incremento/decremento sufixo         | Esquerda para direita |\n| 3           | `!` `~` `-` (unario) `+` (unario) | Nao logico, complemento, negacao  | Direita para esquerda |\n| 4           | `*` `/` `%`                    | Multiplicacao, divisao, modulo       | Esquerda para direita |\n| 5           | `+` `-`                        | Adicao, subtracao                    | Esquerda para direita |\n| 6           | `<<` `>>`                      | Shifts bit a bit                     | Esquerda para direita |\n| 7           | `<` `<=` `>` `>=`              | Relacional                           | Esquerda para direita |\n| 8           | `==` `!=`                      | Igualdade                            | Esquerda para direita |\n| 9           | `&`                            | E bit a bit                          | Esquerda para direita |\n| 10          | `^`                            | Xor bit a bit                        | Esquerda para direita |\n| 11          | `|`                            | Ou bit a bit                         | Esquerda para direita |\n| 12          | `&&`                           | E logico                             | Esquerda para direita |\n| 13          | `||`                           | Ou logico                            | Esquerda para direita |\n| 14          | `??`                           | Coalescencia nula                    | Esquerda para direita |\n| 15          | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\\|=` `^=` `<<=` `>>=` | Atribuicao | Direita para esquerda |\n\n---\n\n## Exemplos de Precedencia\n\n### Exemplo 1: Aritmetica e Comparacao\n```hemlock\nlet result = 5 + 3 * 2;\n// Avaliado como: 5 + (3 * 2) = 11\n// Multiplicacao tem maior precedencia que adicao\n\nlet cmp = 10 > 5 + 3;\n// Avaliado como: 10 > (5 + 3) = true\n// Adicao tem maior precedencia que comparacao\n```\n\n### Exemplo 2: Operadores Bit a Bit\n```hemlock\nlet result1 = 12 | 10 & 8;\n// Avaliado como: 12 | (10 & 8) = 12 | 8 = 12\n// & tem maior precedencia que |\n\nlet result2 = 8 | 1 << 2;\n// Avaliado como: 8 | (1 << 2) = 8 | 4 = 12\n// Shift tem maior precedencia que ou bit a bit\n\n// Use parenteses para clareza\nlet result3 = (5 & 3) | (2 << 1);\n// Avaliado como: 1 | 4 = 5\n```\n\n### Exemplo 3: Operadores Logicos\n```hemlock\nlet result = true || false && false;\n// Avaliado como: true || (false && false) = true\n// && tem maior precedencia que ||\n\nlet cmp = 5 < 10 && 10 < 20;\n// Avaliado como: (5 < 10) && (10 < 20) = true\n// Comparacao tem maior precedencia que &&\n```\n\n### Exemplo 4: Usando Parenteses\n```hemlock\n// Sem parenteses\nlet a = 2 + 3 * 4;        // 14\n\n// Com parenteses\nlet b = (2 + 3) * 4;      // 20\n\n// Expressao complexa\nlet c = (a + b) * (a - b);\n```\n\n---\n\n## Comportamento de Operadores Especificos por Tipo\n\n### Divisao (Sempre Retorna Float)\n\nO operador `/` **sempre retorna ponto flutuante** (f64), independente dos tipos dos operandos:\n\n```hemlock\nprint(10 / 3);             // 3.333... (f64)\nprint(5 / 2);              // 2.5 (f64)\nprint(10.0 / 4.0);         // 2.5 (f64)\nprint(-7 / 3);             // -2.333... (f64)\n```\n\nIsso previne erros comuns de truncamento inteiro inesperado.\n\n### Divisao Floor (div / divi)\n\nPara divisao floor (similar a divisao inteira em outras linguagens), use as funcoes `div()` e `divi()`:\n\n```hemlock\n// div(a, b) - divisao floor retornando float\nprint(div(5, 2));          // 2 (f64)\nprint(div(-7, 3));         // -3 (f64)  -- floor em direcao a -infinito\n\n// divi(a, b) - divisao floor retornando inteiro\nprint(divi(5, 2));         // 2 (i64)\nprint(divi(-7, 3));        // -3 (i64)\nprint(typeof(divi(5, 2))); // i64\n```\n\n**Funcoes matematicas que retornam inteiro:**\nPara outras operacoes de arredondamento que retornam inteiro:\n\n```hemlock\nprint(floori(3.7));        // 3 (i64)\nprint(ceili(3.2));         // 4 (i64)\nprint(roundi(3.5));        // 4 (i64)\nprint(trunci(3.9));        // 3 (i64)\n\n// Podem ser usados diretamente como indices de array\nlet arr = [10, 20, 30, 40];\nprint(arr[floori(1.9)]);   // 20 (indice 1)\n```\n\n### Comparacao de Strings\n\nStrings sao comparadas lexicograficamente:\n\n```hemlock\nprint(\"abc\" < \"def\");      // true\nprint(\"apple\" > \"banana\"); // false\nprint(\"hello\" == \"hello\"); // true\n```\n\n### Comparacao com Null\n\n```hemlock\nlet x = null;\n\nprint(x == null);          // true\nprint(x != null);          // false\n```\n\n### Erros de Tipo\n\nCertas operacoes nao sao permitidas entre tipos incompativeis:\n\n```hemlock\n// ERRO: Nao pode usar operadores bit a bit em floats\nlet x = 3.14 & 2.71;\n\n// ERRO: Nao pode usar operadores bit a bit em strings\nlet y = \"hello\" & \"world\";\n\n// OK: Promocao de tipo para aritmetica\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet c = a + b;             // i32 (promovido)\n```\n\n---\n\n## Veja Tambem\n\n- [Sistema de Tipos](#reference-type-system) - Regras de promocao e conversao de tipos\n- [Funcoes Integradas](#reference-builtins) - Operacoes integradas\n- [API de Strings](#reference-string-api) - Concatenacao e metodos de string\n"}, "Referncia da API -> Sistema de Tipos": {"id": "reference-type-system", "content": "# Referencia do Sistema de Tipos\n\nReferencia completa do sistema de tipos do Hemlock, incluindo todos os tipos primitivos e compostos.\n\n---\n\n## Visao Geral\n\nHemlock usa um **sistema de tipos dinamico** com tags de tipo em tempo de execucao e anotacoes de tipo opcionais. Todo valor tem um tipo em tempo de execucao, e conversoes de tipo seguem regras de promocao claras.\n\n**Caracteristicas Principais:**\n- Verificacao de tipo em tempo de execucao (interpretador)\n- Verificacao de tipo em tempo de compilacao (hemlockc - habilitada por padrao)\n- Anotacoes de tipo opcionais\n- Inferencia de tipo automatica para literais\n- Regras de promocao de tipo claras\n- Sem conversoes implicitas que percam precisao\n\n---\n\n## Verificacao de Tipo em Tempo de Compilacao (hemlockc)\n\nO compilador Hemlock (`hemlockc`) inclui um verificador de tipo em tempo de compilacao que valida seu codigo antes de gerar o executavel. Isso detecta erros de tipo cedo sem executar o programa.\n\n### Comportamento Padrao\n\nVerificacao de tipo e **habilitada por padrao** no hemlockc:\n\n```bash\n# Verificacao de tipo acontece automaticamente\nhemlockc program.hml -o program\n\n# Erros sao reportados antes da compilacao\nhemlockc bad_types.hml\n# Saida: 1 type error found\n```\n\n### Flags do Compilador\n\n| Flag | Descricao |\n|------|-----------|\n| `--check` | Apenas verifica tipos, nao compila (termina apos validacao) |\n| `--no-type-check` | Desabilita verificacao de tipo (nao recomendado) |\n| `--strict-types` | Habilita avisos mais rigorosos de tipo |\n\n**Exemplo:**\n\n```bash\n# Apenas valida tipos sem compilar\nhemlockc --check program.hml\n# Saida: program.hml: no type errors\n\n# Desabilita verificacao de tipo (use com cautela)\nhemlockc --no-type-check dynamic_code.hml -o program\n\n# Habilita avisos rigorosos para tipos 'any' implicitos\nhemlockc --strict-types program.hml -o program\n```\n\n### O Que o Verificador de Tipo Valida\n\n1. **Anotacoes de Tipo** - Garante que valores atribuidos correspondam aos tipos declarados\n2. **Chamadas de Funcao** - Verifica que tipos de argumentos correspondam aos tipos de parametros\n3. **Tipos de Retorno** - Verifica que instrucoes return correspondam ao tipo de retorno declarado\n4. **Uso de Operadores** - Valida que operandos sao compativeis\n5. **Acesso a Propriedades** - Verifica tipos de campo de objeto para objetos tipados\n\n### Coercao Numerica Relaxada\n\nO verificador de tipo permite coercoes de tipo numerico em tempo de compilacao, com validacao de faixa em tempo de execucao:\n\n```hemlock\nlet x: i8 = 100;      // OK - 100 cabe em i8 (validado em tempo de execucao)\nlet y: u8 = 255;      // OK - dentro da faixa de u8\nlet z: f64 = 42;      // OK - i32 para f64 e seguro\n```\n\n### Suporte a Codigo Dinamico\n\nCodigo sem anotacoes de tipo e tratado como dinamico (tipo `any`), e sempre passa no verificador de tipo:\n\n```hemlock\nlet x = get_value();  // Dinamico - sem anotacao\nprocess(x);           // OK - valores dinamicos aceitos em qualquer lugar\n```\n\n---\n\n## Tipos Primitivos\n\n### Tipos Numericos\n\n#### Inteiros com Sinal\n\n| Tipo   | Tamanho | Faixa                                      | Alias     |\n|--------|---------|-------------------------------------------|-----------|\n| `i8`   | 1 byte  | -128 a 127                                | -         |\n| `i16`  | 2 bytes | -32.768 a 32.767                          | -         |\n| `i32`  | 4 bytes | -2.147.483.648 a 2.147.483.647            | `integer` |\n| `i64`  | 8 bytes | -9.223.372.036.854.775.808 a 9.223.372.036.854.775.807 | - |\n\n**Exemplo:**\n```hemlock\nlet a: i8 = 127;\nlet b: i16 = 32000;\nlet c: i32 = 1000000;\nlet d: i64 = 9223372036854775807;\n\n// Alias de tipo\nlet x: integer = 42;  // Mesmo que i32\n```\n\n#### Inteiros sem Sinal\n\n| Tipo   | Tamanho | Faixa                         | Alias  |\n|--------|---------|-------------------------------|--------|\n| `u8`   | 1 byte  | 0 a 255                       | `byte` |\n| `u16`  | 2 bytes | 0 a 65.535                    | -      |\n| `u32`  | 4 bytes | 0 a 4.294.967.295             | -      |\n| `u64`  | 8 bytes | 0 a 18.446.744.073.709.551.615| -      |\n\n**Exemplo:**\n```hemlock\nlet a: u8 = 255;\nlet b: u16 = 65535;\nlet c: u32 = 4294967295;\nlet d: u64 = 18446744073709551615;\n\n// Alias de tipo\nlet byte_val: byte = 65;  // Mesmo que u8\n```\n\n#### Ponto Flutuante\n\n| Tipo   | Tamanho | Precisao              | Alias    |\n|--------|---------|----------------------|----------|\n| `f32`  | 4 bytes | ~7 digitos           | -        |\n| `f64`  | 8 bytes | ~15 digitos          | `number` |\n\n**Exemplo:**\n```hemlock\nlet pi: f32 = 3.14159;\nlet precise: f64 = 3.14159265359;\n\n// Alias de tipo\nlet x: number = 2.718;  // Mesmo que f64\n```\n\n---\n\n### Inferencia de Literais Inteiros\n\nLiterais inteiros determinam seu tipo automaticamente baseado no valor:\n\n**Regras:**\n- Valores na faixa de i32 (-2.147.483.648 a 2.147.483.647): inferidos como `i32`\n- Valores fora da faixa de i32 mas na faixa de i64: inferidos como `i64`\n- Outros tipos (i8, i16, u8, u16, u32, u64) usam anotacoes de tipo explicitas\n\n**Exemplo:**\n```hemlock\nlet small = 42;                    // i32 (cabe em i32)\nlet large = 5000000000;            // i64 (> i32 max)\nlet max_i64 = 9223372036854775807; // i64 (INT64_MAX)\nlet explicit: u32 = 100;           // u32 (anotacao de tipo sobrescreve)\n```\n\n---\n\n### Tipo Booleano\n\n**Tipo:** `bool`\n\n**Valores:** `true`, `false`\n\n**Tamanho:** 1 byte (internamente)\n\n**Exemplo:**\n```hemlock\nlet is_active: bool = true;\nlet done = false;\n\nif (is_active && !done) {\n    print(\"trabalhando\");\n}\n```\n\n---\n\n### Tipos de Caractere\n\n#### Rune\n\n**Tipo:** `rune`\n\n**Descricao:** Ponto de codigo Unicode (U+0000 a U+10FFFF)\n\n**Tamanho:** 4 bytes (valor de 32 bits)\n\n**Faixa:** 0 a 0x10FFFF (1.114.111)\n\n**Sintaxe Literal:** Aspas simples `'x'`\n\n**Exemplo:**\n```hemlock\n// ASCII\nlet a = 'A';\nlet digit = '0';\n\n// UTF-8 multi-byte\nlet rocket = '';      // U+1F680\nlet heart = '';        // U+2764\nlet chinese = '';     // U+4E2D\n\n// Sequencias de escape\nlet newline = '\\n';\nlet tab = '\\t';\nlet backslash = '\\\\';\nlet quote = '\\'';\nlet null = '\\0';\n\n// Escapes Unicode\nlet emoji = '\\u{1F680}';   // Ate 6 digitos hex\nlet max = '\\u{10FFFF}';    // Ponto de codigo maximo\n```\n\n**Conversoes de Tipo:**\n```hemlock\n// Inteiro para rune\nlet code: rune = 65;        // 'A'\nlet r: rune = 128640;       // \n\n// Rune para inteiro\nlet value: i32 = 'Z';       // 90\n\n// Rune para string\nlet s: string = 'H';        // \"H\"\n\n// u8 para rune\nlet byte: u8 = 65;\nlet rune_val: rune = byte;  // 'A'\n```\n\n**Veja Tambem:** [API de Strings](#reference-string-api) para concatenacao string + rune\n\n---\n\n### Tipo String\n\n**Tipo:** `string`\n\n**Descricao:** Texto codificado em UTF-8, mutavel, alocado no heap\n\n**Codificacao:** UTF-8 (U+0000 a U+10FFFF)\n\n**Mutabilidade:** Mutavel (diferente da maioria das linguagens)\n\n**Propriedades:**\n- `.length` - Contagem de pontos de codigo (caracteres)\n- `.byte_length` - Contagem de bytes (tamanho de codificacao UTF-8)\n\n**Sintaxe Literal:** Aspas duplas `\"texto\"`\n\n**Exemplo:**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Muta (agora \"Hello\")\nprint(s.length);        // 5 (contagem de pontos de codigo)\nprint(s.byte_length);   // 5 (bytes UTF-8)\n\nlet emoji = \"\";\nprint(emoji.length);        // 1 (um ponto de codigo)\nprint(emoji.byte_length);   // 4 (quatro bytes UTF-8)\n```\n\n**Indexacao:**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Retorna rune 'h'\ns[0] = 'H';             // Define com rune\n```\n\n**Veja Tambem:** [API de Strings](#reference-string-api) para referencia completa de metodos\n\n---\n\n### Tipo Null\n\n**Tipo:** `null`\n\n**Descricao:** Valor nulo (representa ausencia de valor)\n\n**Tamanho:** 8 bytes (internamente)\n\n**Valor:** `null`\n\n**Exemplo:**\n```hemlock\nlet x = null;\nlet y: i32 = null;  // ERRO: tipo incompativel\n\nif (x == null) {\n    print(\"x e nulo\");\n}\n```\n\n---\n\n## Tipos Compostos\n\n### Tipo Array\n\n**Tipo:** `array`\n\n**Descricao:** Array dinamico, alocado no heap, de tipo misto\n\n**Propriedades:**\n- `.length` - Numero de elementos\n\n**Baseado em Zero:** Sim\n\n**Sintaxe Literal:** `[elem1, elem2, ...]`\n\n**Exemplo:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Tipos mistos\nlet mixed = [1, \"hello\", true, null];\n```\n\n**Veja Tambem:** [API de Arrays](#reference-array-api) para referencia completa de metodos\n\n---\n\n### Tipo Objeto\n\n**Tipo:** `object`\n\n**Descricao:** Objeto de campos dinamicos estilo JavaScript\n\n**Sintaxe Literal:** `{ campo: valor, ... }`\n\n**Exemplo:**\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);  // \"Alice\"\n\n// Adiciona campo dinamicamente\nperson.email = \"alice@example.com\";\n```\n\n**Definicoes de Tipo:**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: bool,  // Campo opcional\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\nprint(typeof(p));  // \"Person\"\n```\n\n---\n\n### Tipos de Ponteiro\n\n#### Ponteiro Bruto (ptr)\n\n**Tipo:** `ptr`\n\n**Descricao:** Endereco de memoria bruto (inseguro)\n\n**Tamanho:** 8 bytes\n\n**Verificacao de Limites:** Nenhuma\n\n**Exemplo:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n#### Buffer\n\n**Tipo:** `buffer`\n\n**Descricao:** Wrapper de ponteiro seguro com verificacao de limites\n\n**Estrutura:** Ponteiro + comprimento + capacidade\n\n**Propriedades:**\n- `.length` - Tamanho do buffer\n- `.capacity` - Capacidade alocada\n\n**Exemplo:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Verificacao de limites\nprint(b.length);        // 64\nfree(b);\n```\n\n**Veja Tambem:** [API de Memoria](#reference-memory-api) para funcoes de alocacao\n\n---\n\n## Tipos Especiais\n\n### Tipo File\n\n**Tipo:** `file`\n\n**Descricao:** Handle de arquivo para operacoes de I/O\n\n**Propriedades:**\n- `.path` - Caminho do arquivo (string)\n- `.mode` - Modo de abertura (string)\n- `.closed` - Se o arquivo esta fechado (bool)\n\n**Veja Tambem:** [API de Arquivos](#reference-file-api)\n\n---\n\n### Tipo Task\n\n**Tipo:** `task`\n\n**Descricao:** Handle para uma tarefa concorrente\n\n**Veja Tambem:** [API de Concorrencia](#reference-concurrency-api)\n\n---\n\n### Tipo Channel\n\n**Tipo:** `channel`\n\n**Descricao:** Canal de comunicacao thread-safe\n\n**Veja Tambem:** [API de Concorrencia](#reference-concurrency-api)\n\n---\n\n### Tipo Function\n\n**Tipo:** `function`\n\n**Descricao:** Valor de funcao de primeira classe\n\n**Exemplo:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(typeof(add));      // \"function\"\nprint(typeof(multiply)); // \"function\"\n```\n\n---\n\n### Tipo Void\n\n**Tipo:** `void`\n\n**Descricao:** Representa nenhum valor de retorno (uso interno)\n\n---\n\n## Regras de Promocao de Tipo\n\nQuando tipos sao misturados em operacoes, Hemlock promove para o tipo \"maior\":\n\n**Hierarquia de Promocao:**\n```\nf64 (maior precisao)\n \nf32\n \nu64\n \ni64\n \nu32\n \ni32\n \nu16\n \ni16\n \nu8\n \ni8 (menor)\n```\n\n**Regras:**\n1. Floats sempre tem precedencia sobre inteiros\n2. Dentro da mesma categoria (int/uint/float) tamanho maior tem precedencia\n3. Ambos operandos sao promovidos para o tipo resultado\n4. **Preservacao de Precisao:** i64/u64 + f32 promove para f64 (nao f32)\n\n**Exemplo:**\n```hemlock\n// Promocao de tamanho\nu8 + i32     i32    // Tamanho maior vence\ni32 + i64    i64    // Tamanho maior vence\nu32 + u64    u64    // Tamanho maior vence\n\n// Promocao de float\ni32 + f32    f32    // Float vence, f32 suficiente para i32\ni64 + f32    f64    // Promove para f64 para preservar precisao de i64\ni64 + f64    f64    // Float sempre vence\ni8 + f64     f64    // Float + maior vence\n```\n\n**Por que i64 + f32  f64?**\n\nf32 tem apenas 24 bits de mantissa, nao pode representar precisamente inteiros maiores que 2^24 (16.777.216). Como i64 pode armazenar valores ate 2^63, misturar i64 com f32 causaria perda severa de precisao. Hemlock promove para f64 (53 bits de mantissa) em vez disso.\n\n---\n\n## Verificacao de Faixa\n\nAnotacoes de tipo aplicam verificacao de faixa na atribuicao:\n\n**Atribuicoes Validas:**\n```hemlock\nlet x: u8 = 255;             // OK\nlet y: i8 = 127;             // OK\nlet a: i64 = 2147483647;     // OK\nlet b: u64 = 4294967295;     // OK\n```\n\n**Atribuicoes Invalidas (erro de runtime):**\n```hemlock\nlet x: u8 = 256;             // ERRO: fora da faixa\nlet y: i8 = 128;             // ERRO: max e 127\nlet z: u64 = -1;             // ERRO: u64 nao pode ser negativo\n```\n\n---\n\n## Introspeccao de Tipo\n\n### typeof(value)\n\nRetorna o nome do tipo como string.\n\n**Assinatura:**\n```hemlock\ntypeof(value: any): string\n```\n\n**Retorna:**\n- Tipos primitivos: `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- Tipos compostos: `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- Tipos especiais: `\"file\"`, `\"task\"`, `\"channel\"`\n- Objetos tipados: Nome de tipo personalizado (ex: `\"Person\"`)\n\n**Exemplo:**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n```\n\n**Veja Tambem:** [Funcoes Integradas](builtins.md#typeof)\n\n---\n\n## Conversao de Tipo\n\n### Conversao Implicita\n\nHemlock realiza conversao implicita de tipo em operacoes aritmeticas seguindo regras de promocao de tipo.\n\n**Exemplo:**\n```hemlock\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet result = a + b;     // result e i32 (promovido)\n```\n\n### Conversao Explicita\n\nUse anotacoes de tipo para conversao explicita:\n\n**Exemplo:**\n```hemlock\n// Inteiro para float\nlet i: i32 = 42;\nlet f: f64 = i;         // 42.0\n\n// Float para inteiro (trunca)\nlet x: f64 = 3.14;\nlet y: i32 = x;         // 3\n\n// Inteiro para rune\nlet code: rune = 65;    // 'A'\n\n// Rune para inteiro\nlet value: i32 = 'Z';   // 90\n\n// Rune para string\nlet s: string = 'H';    // \"H\"\n```\n\n---\n\n## Alias de Tipo\n\n### Alias Integrados\n\nHemlock fornece alias de tipo integrados para tipos comuns:\n\n| Alias     | Tipo Real | Uso           |\n|-----------|----------|---------------|\n| `integer` | `i32`    | Inteiro geral |\n| `number`  | `f64`    | Float geral   |\n| `byte`    | `u8`     | Valores de byte |\n\n**Exemplo:**\n```hemlock\nlet count: integer = 100;       // Mesmo que i32\nlet price: number = 19.99;      // Mesmo que f64\nlet b: byte = 255;              // Mesmo que u8\n```\n\n### Alias de Tipo Personalizados\n\nUse a palavra-chave `type` para definir alias de tipo personalizados:\n\n```hemlock\n// Alias simples\ntype Integer = i32;\ntype Text = string;\n\n// Alias de tipo de funcao\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\n// Alias de tipo composto\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// Alias de tipo generico\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n```\n\n**Usando alias personalizados:**\n```hemlock\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**Nota:** Alias de tipo sao transparentes - `typeof()` retorna o nome do tipo subjacente.\n\n---\n\n## Tipos de Funcao\n\nTipos de funcao especificam a assinatura de valores de funcao:\n\n### Sintaxe\n\n```hemlock\nfn(tipos_parametros): tipo_retorno\n```\n\n### Exemplos\n\n```hemlock\n// Tipo de funcao basico\nlet add: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// Parametro de funcao\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Funcao de ordem superior retornando funcao\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Tipo de funcao assincrona\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n```\n\n---\n\n## Tipos Compostos (Tipos de Intersecao)\n\nTipos compostos usam `&` para requerer multiplas restricoes de tipo:\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// Objeto deve satisfazer todos os tipos\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// Tres ou mais tipos\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n---\n\n## Tabela de Resumo\n\n| Tipo       | Tamanho  | Mutavel | Heap | Descricao                |\n|------------|----------|---------|------|--------------------------|\n| `i8`-`i64` | 1-8 bytes | Nao    | Nao  | Inteiros com sinal       |\n| `u8`-`u64` | 1-8 bytes | Nao    | Nao  | Inteiros sem sinal       |\n| `f32`      | 4 bytes  | Nao    | Nao  | Float precisao simples   |\n| `f64`      | 8 bytes  | Nao    | Nao  | Float precisao dupla     |\n| `bool`     | 1 byte   | Nao    | Nao  | Booleano                 |\n| `rune`     | 4 bytes  | Nao    | Nao  | Ponto de codigo Unicode  |\n| `string`   | Variavel | Sim    | Sim  | Texto UTF-8              |\n| `array`    | Variavel | Sim    | Sim  | Array dinamico           |\n| `object`   | Variavel | Sim    | Sim  | Objeto dinamico          |\n| `ptr`      | 8 bytes  | Nao    | Nao  | Ponteiro bruto           |\n| `buffer`   | Variavel | Sim    | Sim  | Wrapper de ponteiro seguro |\n| `file`     | Opaco    | Sim    | Sim  | Handle de arquivo        |\n| `task`     | Opaco    | Nao    | Sim  | Handle de tarefa concorrente |\n| `channel`  | Opaco    | Sim    | Sim  | Canal thread-safe        |\n| `function` | Opaco    | Nao    | Sim  | Valor de funcao          |\n| `null`     | 8 bytes  | Nao    | Nao  | Valor nulo               |\n\n---\n\n## Veja Tambem\n\n- [Referencia de Operadores](#reference-operators) - Comportamento de tipo em operacoes\n- [Funcoes Integradas](#reference-builtins) - Introspeccao e conversao de tipo\n- [API de Strings](#reference-string-api) - Metodos do tipo string\n- [API de Arrays](#reference-array-api) - Metodos do tipo array\n- [API de Memoria](#reference-memory-api) - Operacoes com ponteiro e buffer\n"}, "Design e Filosofia -> Filosofia": {"id": "design-philosophy", "content": "# Filosofia de Design da Linguagem Hemlock\n\n> \"Uma linguagem pequena e no-segura, para escrever cdigo no-seguro de forma segura.\"\n\nEste documento registra os princpios e filosofia de design centrais do Hemlock. Por favor, leia este documento antes de fazer qualquer alterao ou adio  linguagem.\n\n---\n\n## Sumrio\n\n- [Posicionamento Central](#posicionamento-central)\n- [Princpios de Design](#princpios-de-design)\n- [Filosofia de Segurana](#filosofia-de-segurana)\n- [Recursos que No Devem Ser Adicionados](#recursos-que-no-devem-ser-adicionados)\n- [Consideraes Futuras](#consideraes-futuras)\n- [Concluso](#concluso)\n\n---\n\n## Posicionamento Central\n\nHemlock  uma **linguagem de script de sistemas**, com gerenciamento manual de memria e controle explcito. Foi projetada para programadores que precisam de:\n\n- O poder da linguagem C\n- A facilidade de uso de linguagens de script modernas\n- Concorrncia assncrona estruturada integrada\n- Sem comportamentos ocultos ou mgica\n\n### O que Hemlock No \n\n- **Segura em relao  memria** (ponteiros pendurados so sua responsabilidade)\n- **Substituta de Rust, Go ou Lua**\n- **Uma linguagem que esconde complexidade de voc**\n\n### O que Hemlock \n\n- **Sempre explcito  melhor que implcito**\n- **Educacional e experimental**\n- **Uma \"camada de script C\" para trabalho de sistemas**\n- **Honesta sobre os trade-offs**\n\n---\n\n## Princpios de Design\n\n### 1. Explcito  Melhor que Implcito\n\nHemlock favorece o explcito em todas as construes da linguagem. No deve haver surpresas, mgica ou comportamentos ocultos.\n\n**Prtica ruim (implcita):**\n```hemlock\nlet x = 5  // Ponto e vrgula faltando - deveria dar erro\n```\n\n**Boa prtica (explcita):**\n```hemlock\nlet x = 5;\nfree(ptr);  // Voc alocou, voc libera\n```\n\n**Pontos-chave:**\n- Ponto e vrgula  obrigatrio (sem insero automtica de ponto e vrgula)\n- Sem coleta de lixo\n- Gerenciamento manual de memria (alloc/free)\n- Anotaes de tipo so opcionais, mas so verificadas em tempo de execuo\n- Sem limpeza automtica de recursos (sem RAII), mas `defer` oferece limpeza explcita\n\n### 2. Dinmico por Padro, Tipos Opcionais\n\nCada valor tem uma tag de tipo em tempo de execuo, mas o sistema foi projetado para ser flexvel enquanto ainda captura erros.\n\n**Inferncia de tipos:**\n- Inteiros pequenos (cabem em i32): `42`  `i32`\n- Inteiros grandes (excedem o intervalo de i32): `9223372036854775807`  `i64`\n- Ponto flutuante: `3.14`  `f64`\n\n**Tipos explcitos quando necessrio:**\n```hemlock\nlet x = 42;              // Inferido como i32 (valor pequeno)\nlet y: u8 = 255;         // u8 explcito\nlet z = x + y;           // Promovido para i32\nlet big = 5000000000;    // Inferido como i64 (excede mximo de i32)\n```\n\n**Regras de promoo de tipos** seguem uma hierarquia clara do menor para o maior, com ponto flutuante sempre tendo prioridade sobre inteiros.\n\n### 3. No-Seguro  um Recurso, No um Defeito\n\nHemlock no tenta prevenir todos os erros. Em vez disso, oferece ferramentas seguras enquanto permite que voc opte por comportamento no-seguro quando necessrio.\n\n**Exemplos de no-segurana intencional:**\n- Aritmtica de ponteiros pode estourar (responsabilidade do usurio)\n- `ptr` bruto no tem verificao de limites (use `buffer` se precisar de segurana)\n- Double free  permitido causar crash (gerenciamento manual de memria)\n- Sistema de tipos previne acidentes mas permite operaes perigosas quando necessrio\n\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Muito alm da alocao - permitido mas perigoso\n```\n\n**Filosofia:** O sistema de tipos deve prevenir *acidentes*, mas permitir operaes no-seguras *intencionais*.\n\n### 4. Concorrncia Estruturada como Cidad de Primeira Classe\n\nConcorrncia no  uma reflexo tardia em Hemlock. Est integrada na linguagem desde o incio.\n\n**Recursos principais:**\n- `async`/`await` integrados na linguagem\n- Channels para comunicao\n- `spawn`/`join`/`detach` para gerenciamento de tarefas\n- Sem threads brutas, sem locks - apenas estruturado\n- Usa threads POSIX para paralelismo real multi-thread\n\n**No  um event loop ou green threads** - Hemlock usa threads reais do sistema operacional para paralelismo verdadeiro em mltiplos ncleos de CPU.\n\n### 5. Sintaxe Semelhante a C, Baixa Cerimnia\n\nHemlock deve parecer familiar para programadores de sistemas, enquanto reduz cdigo boilerplate.\n\n**Escolhas de design:**\n- Sempre usa blocos `{}`, sem chaves opcionais\n- Operadores correspondem a C: `+`, `-`, `*`, `/`, `&&`, `||`, `!`\n- Sintaxe de tipos corresponde a Rust/TypeScript: `let x: type = value;`\n- Funes so valores de primeira classe\n- Mnimo de palavras-chave e formas especiais\n\n---\n\n## Filosofia de Segurana\n\n**A viso do Hemlock sobre segurana:**\n\n> \"Ns damos a voc ferramentas seguras (`buffer`, anotaes de tipo, verificao de limites), mas no foramos voc a us-las (`ptr`, memria manual, operaes no-seguras).\n>\n> O padro deve guiar para segurana, mas escotilhas de escape devem estar sempre disponveis.\"\n\n### Ferramentas de Segurana Oferecidas\n\n**1. Tipo buffer seguro:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Verificao de limites\nprint(b.length);        // 64\nfree(b);                // Ainda  manual\n```\n\n**2. Ponteiros brutos no-seguros:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // Voc deve lembrar de liberar\n```\n\n**3. Anotaes de tipo:**\n```hemlock\nlet x: u8 = 255;   // Correto\nlet y: u8 = 256;   // Erro: fora do intervalo\n```\n\n**4. Verificao de tipos em tempo de execuo:**\n```hemlock\nlet val = some_function();\nif (typeof(val) == \"i32\") {\n    // Pode usar com segurana como inteiro\n}\n```\n\n### Princpios Orientadores\n\n1. **Usar modo seguro por padro na documentao** - Mostrar `buffer` antes de `ptr`, encorajar anotaes de tipo\n2. **Tornar operaes no-seguras visveis** - Aritmtica de ponteiros brutos deve parecer intencional\n3. **Oferecer escotilhas de escape** - No impedir usurios experientes de fazer trabalho de baixo nvel\n4. **Ser honesto sobre trade-offs** - Documentar o que pode dar errado\n\n### Exemplos de Seguro vs No-Seguro\n\n| Modo Seguro | Modo No-Seguro | Quando Usar No-Seguro |\n|-------------|-----------------|------------------------|\n| Tipo `buffer` | Tipo `ptr` | FFI, cdigo crtico para performance |\n| Anotaes de tipo | Sem anotaes | Interfaces externas, validao |\n| Acesso com verificao de limites | Aritmtica de ponteiros | Operaes de memria de baixo nvel |\n| Tratamento de excees | Retornar null/cdigo de erro | Quando excees so muito pesadas |\n\n---\n\n## Recursos que No Devem Ser Adicionados\n\nEntender o que **no** deve ser adicionado  to importante quanto saber o que deve ser adicionado.\n\n### No Adicione Comportamentos Implcitos\n\n**Exemplos ruins:**\n\n```hemlock\n// Ruim: insero automtica de ponto e vrgula\nlet x = 5\nlet y = 10\n\n// Ruim: converso de tipo implcita com perda de preciso\nlet x: i32 = 3.14  // Deveria truncar ou dar erro?\n```\n\n**Motivo:** Comportamentos implcitos causam surpresas e tornam o cdigo mais difcil de entender.\n\n### No Esconda Complexidade\n\n**Exemplos ruins:**\n\n```hemlock\n// Ruim: otimizaes mgicas por trs dos panos\nlet arr = [1, 2, 3]  // Isso  stack ou heap? O usurio deveria saber! (heap, contagem de referncia)\n\n// Ruim: liberao automtica de ponteiros brutos\nlet p = alloc(100)  // Isso ser liberado automaticamente? No! Ponteiros brutos sempre precisam de free()\n```\n\n**Nota sobre contagem de referncia:** Hemlock usa contagem de referncia interna para strings, arrays, objetos e buffers - estes so liberados automaticamente quando saem do escopo. Isso  explcito e previsvel (limpeza determinstica quando a contagem chega a 0, sem pausas de GC). Ponteiros brutos (`ptr` de `alloc()`) no so contados por referncia e sempre precisam de `free()` manual.\n\n**Motivo:** Complexidade oculta torna impossvel prever performance e depurar problemas.\n\n### No Quebre Semnticas Existentes\n\n**Nunca mude estas decises centrais:**\n- Ponto e vrgula  obrigatrio - no torn-lo opcional\n- Gerenciamento manual de memria - no adicionar GC\n- Strings mutveis - no torn-las imutveis\n- Verificao de tipos em tempo de execuo - no remov-la\n\n**Motivo:** Consistncia e estabilidade so mais importantes que recursos da moda.\n\n### No Adicione Recursos de \"Convenincia\" que Reduzam Explicitude\n\n**Exemplos de recursos a evitar:**\n- Sobrecarga de operadores (tipos de usurio talvez ok, mas com cuidado)\n- Coero de tipo implcita que perde informao\n- Limpeza automtica de recursos (RAII)\n- Encadeamento de mtodos que esconde complexidade\n- DSLs e sintaxe mgica\n\n**Exceo:** Se um recurso de convenincia  **acar sinttico explcito** para operaes simples, pode ser ok:\n- `else if`  ok ( apenas if aninhado)\n- Interpolao de strings pode ser ok, se for obviamente acar sinttico\n- Sintaxe de mtodos para objetos  ok ( explcito o que faz)\n\n---\n\n## Consideraes Futuras\n\n### Pode Ser Adicionado (Em Discusso)\n\nEstes recursos se alinham com a filosofia do Hemlock, mas precisam de design cuidadoso:\n\n**1. Pattern Matching**\n```hemlock\nmatch (value) {\n    case i32: print(\"inteiro\");\n    case string: print(\"texto\");\n    case _: print(\"outro\");\n}\n```\n- Verificao de tipos explcita\n- Sem custos ocultos\n- Possvel verificao de exaustividade em tempo de compilao\n\n**2. Tipos de Erro (`Result<T, E>`)**\n```hemlock\nfn divide(a: i32, b: i32): Result<i32, string> {\n    if (b == 0) {\n        return Err(\"diviso por zero\");\n    }\n    return Ok(a / b);\n}\n```\n- Tratamento de erros explcito\n- Fora o usurio a considerar erros\n- Alternativa a excees\n\n**3. Tipos de Array/Slice**\n- J tem arrays dinmicos\n- Pode adicionar arrays de tamanho fixo para alocao em stack\n- Precisa ser explcito sobre stack vs heap\n\n**4. Ferramentas de Segurana de Memria Melhoradas**\n- Flag opcional de verificao de limites\n- Deteco de vazamento de memria em builds de debug\n- Integrao com sanitizers\n\n### Provavelmente Nunca Ser Adicionado\n\nEstes recursos violam princpios centrais:\n\n**1. Coleta de Lixo**\n- Esconde complexidade de gerenciamento de memria\n- Performance imprevisvel\n- Viola princpio de controle explcito\n\n**2. Gerenciamento Automtico de Memria**\n- Mesmas razes que GC\n- Contagem de referncia pode ser ok se explcita\n\n**3. Converses de Tipo Implcitas que Perdem Dados**\n- Viola \"explcito  melhor que implcito\"\n- Fonte de erros sutis\n\n**4. Macros (Complexas)**\n- Muito poder, muita complexidade\n- Sistema de macros simples pode ser ok\n- Prefira gerao de cdigo ou funes\n\n**5. Orientao a Objetos Baseada em Classes com Herana**\n- Muitos comportamentos implcitos\n- Duck typing e objetos so suficientes\n- Composio sobre herana\n\n**6. Sistema de Mdulos com Resoluo Complexa**\n- Manter imports simples e explcitos\n- Sem caminhos de busca mgicos\n- Sem resoluo de verses (use gerenciador de pacotes do SO)\n\n---\n\n## Concluso\n\n### Confiana e Responsabilidade\n\nHemlock  sobre **confiana e responsabilidade**. Ns confiamos que os programadores podem:\n\n- Gerenciar memria corretamente\n- Usar tipos apropriadamente\n- Tratar erros corretamente\n- Entender trade-offs\n\nEm troca, Hemlock oferece:\n\n- Sem custos ocultos\n- Sem comportamentos inesperados\n- Controle total quando necessrio\n- Ferramentas seguras quando necessrio\n\n### Perguntas Orientadoras\n\n**Ao considerar um novo recurso, pergunte:**\n\n> \"Isso d ao programador mais controle explcito, ou esconde algo?\"\n\n- Se **aumenta controle explcito**  Provavelmente cabe no Hemlock\n- Se **esconde complexidade**  Provavelmente no pertence aqui\n- Se  **acar sinttico opcional** com documentao clara  Talvez ok\n\n### Bons Exemplos de Adies\n\n- **Switch statement** - Fluxo de controle explcito, sem mgica, semntica clara\n\n- **Async/await com pthreads** - Concorrncia explcita, paralelismo real, usurio controla spawn\n\n- **Tipo Buffer junto com ptr** - Oferece escolha entre seguro e no-seguro\n\n- **Anotaes de tipo opcionais** - Ajuda a capturar erros sem forar rigidez\n\n- **Try/catch/finally** - Tratamento de erros explcito com fluxo de controle claro\n\n### Maus Exemplos de Adies\n\n- **Insero automtica de ponto e vrgula** - Esconde erros de sintaxe, torna cdigo obscuro\n\n- **RAII/Destrutores** - Limpeza automtica esconde quando recursos so liberados\n\n- **Coalescncia de null implcita** - Esconde verificaes de null, torna cdigo mais difcil de entender\n\n- **Strings com crescimento automtico** - Esconde alocao de memria, performance imprevisvel\n\n---\n\n## Resumo\n\nHemlock no tenta ser a linguagem mais segura, a mais rpida ou a mais rica em recursos.\n\n**Hemlock tenta ser a linguagem mais *honesta*.**\n\nEla diz exatamente o que est fazendo, d controle quando voc precisa, e no esconde arestas cortantes.  uma linguagem para quem quer entender cdigo em nvel baixo enquanto ainda aproveita convenincias modernas.\n\nSe voc no tem certeza se um recurso pertence ao Hemlock, lembre-se:\n\n> **Sempre explcito  melhor que implcito.**\n> **No-seguro  um recurso, no um defeito.**\n> **O usurio  responsvel, e isso est ok.**\n"}, "Design e Filosofia -> Implementao": {"id": "design-implementation", "content": "# Detalhes de Implementao do Hemlock\n\nEste documento descreve a implementao tcnica da linguagem Hemlock, incluindo estrutura do projeto, pipeline de compilao, arquitetura de runtime e decises de design.\n\n---\n\n## Sumrio\n\n- [Estrutura do Projeto](#estrutura-do-projeto)\n- [Pipeline de Compilao](#pipeline-de-compilao)\n- [Design Modular do Interpretador](#design-modular-do-interpretador)\n- [Arquitetura de Runtime](#arquitetura-de-runtime)\n- [Representao de Valores](#representao-de-valores)\n- [Implementao do Sistema de Tipos](#implementao-do-sistema-de-tipos)\n- [Gerenciamento de Memria](#gerenciamento-de-memria)\n- [Modelo de Concorrncia](#modelo-de-concorrncia)\n- [Planos Futuros](#planos-futuros)\n\n---\n\n## Estrutura do Projeto\n\n```\nhemlock/\n src/\n    frontend/              # Compartilhado: lexer, parser, AST\n       lexer.c            # Anlise lxica\n       parser/            # Parser descendente recursivo\n       ast.c              # Gerenciamento de ns AST\n       module.c           # Resoluo de mdulos\n    backends/\n       interpreter/       # hemlock: interpretador tree-walking\n          main.c         # Ponto de entrada CLI\n          runtime.c      # Avaliao de expresses/statements\n          builtins.c     # Funes builtin\n          ...\n       compiler/          # hemlockc: gerador de cdigo C\n           main.c         # CLI, orquestrao\n           type_check.c   # Verificao de tipos em compile-time\n           codegen.c      # Contexto de gerao de cdigo\n           codegen_expr.c # Gerao de cdigo para expresses\n           codegen_stmt.c # Gerao de cdigo para statements\n           ...\n    tools/\n       lsp/               # Protocolo Language Server\n       bundler/           # Ferramenta de bundling/pacotes\n runtime/                   # libhemlock_runtime.a (para programas compilados)\n stdlib/                    # Biblioteca padro (39 mdulos)\n    docs/                  # Documentao dos mdulos\n tests/\n    parity/                # Testes que devem passar em ambos backends\n    interpreter/           # Testes especficos do interpretador\n    compiler/              # Testes especficos do compilador\n examples/                  # Programas de exemplo\n docs/                      # Documentao\n```\n\n### Organizao de Diretrios\n\n**`include/`** - Headers de API pblica que definem interfaces entre componentes:\n- Separao clara entre lexer, parser, AST e interpretador\n- Declaraes forward para minimizar dependncias\n- API pblica para incorporar Hemlock em outros programas\n\n**`src/`** - Arquivos de implementao:\n- Arquivos de nvel superior tratam lexing, parsing, gerenciamento de AST\n- `main.c` fornece CLI e REPL\n- Interpretador modularizado em subsistemas independentes\n\n**`src/interpreter/`** - Implementao modular do interpretador:\n- Cada mdulo tem uma nica responsabilidade clara\n- APIs internas definidas em `internal.h` para comunicao entre mdulos\n- Mdulos podem ser compilados independentemente para builds mais rpidos\n\n**`tests/`** - Sute de testes abrangente:\n- Organizada por rea funcional\n- Cada diretrio contm casos de teste focados\n- `run_tests.sh` orquestra execuo de testes\n\n---\n\n## Pipeline de Compilao\n\nHemlock usa um pipeline de compilao tradicional com fases distintas:\n\n### Fase 1: Anlise Lxica (Lexer)\n\n**Entrada:** Texto do cdigo fonte\n**Sada:** Stream de tokens\n**Implementao:** `src/lexer.c`\n\n```\nFonte: \"let x = 42;\"\n   \nTokens: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n```\n\n**Recursos principais:**\n- Reconhece palavras-chave, identificadores, literais, operadores, pontuao\n- Trata literais de string UTF-8 e literais de rune\n- Reporta nmeros de linha para mensagens de erro\n- Passagem nica, sem backtracking\n\n### Fase 2: Anlise Sinttica (Parser)\n\n**Entrada:** Stream de tokens\n**Sada:** rvore Sinttica Abstrata (AST)\n**Implementao:** `src/parser.c`\n\n```\nTokens: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n   \nAST: LetStmt {\n    name: \"x\",\n    type: null,\n    value: IntLiteral(42)\n}\n```\n\n**Recursos principais:**\n- Parser descendente recursivo\n- Constri representao em rvore da estrutura do programa\n- Trata precedncia de operadores\n- Valida sintaxe (chaves, ponto e vrgula, etc.)\n- Sem anlise semntica ainda (feita em tempo de execuo)\n\n**Precedncia de Operadores (da mais baixa para a mais alta):**\n1. Atribuio: `=`\n2. Ou lgico: `||`\n3. E lgico: `&&`\n4. Ou bit a bit: `|`\n5. Xor bit a bit: `^`\n6. E bit a bit: `&`\n7. Igualdade: `==`, `!=`\n8. Comparao: `<`, `>`, `<=`, `>=`\n9. Shift: `<<`, `>>`\n10. Adio/Subtrao: `+`, `-`\n11. Multiplicao/Diviso/Mdulo: `*`, `/`, `%`\n12. Unrio: `!`, `-`, `~`\n13. Chamada/ndice/Membro: `()`, `[]`, `.`\n\n### Fase 3a: Execuo Interpretada (Tree-Walking)\n\n**Entrada:** AST\n**Sada:** Execuo do programa\n**Implementao:** `src/backends/interpreter/runtime.c`\n\n```\nAST: LetStmt { ... }\n   \nExecuo: Avaliar ns AST recursivamente\n   \nResultado: Criar varivel x com valor 42\n```\n\n**Recursos principais:**\n- Travessia direta de AST (interpretador tree-walking)\n- Verificao de tipos dinmica em tempo de execuo\n- Armazenamento de variveis baseado em ambiente\n\n### Fase 3b: Compilao (hemlockc)\n\n**Entrada:** AST\n**Sada:** Executvel nativo via gerao de cdigo C\n**Implementao:** `src/backends/compiler/`\n\n```\nAST: LetStmt { ... }\n   \nVerificao de Tipos: Validar tipos em compile-time\n   \nGerao de Cdigo C: Gerar cdigo C equivalente\n   \nGCC: Compilar C para binrio nativo\n   \nResultado: Executvel standalone\n```\n\n**Recursos principais:**\n- Verificao de tipos em compile-time (habilitada por padro)\n- Gerao de cdigo C para portabilidade\n- Linka com `libhemlock_runtime.a`\n- Execuo significativamente mais rpida que interpretador\n\n---\n\n## Backend do Compilador (hemlockc)\n\nO compilador Hemlock gera cdigo C a partir do AST, que  ento compilado para executvel nativo usando GCC.\n\n### Arquitetura do Compilador\n\n```\nsrc/backends/compiler/\n main.c              # CLI, parsing de argumentos, orquestrao\n codegen.c           # Contexto core de gerao de cdigo\n codegen_expr.c      # Gerao de cdigo para expresses\n codegen_stmt.c      # Gerao de cdigo para statements\n codegen_call.c      # Gerao de chamadas de funo\n codegen_closure.c   # Implementao de closures\n codegen_program.c   # Gerao de programa de nvel superior\n codegen_module.c    # Tratamento de mdulos/imports\n type_check.c        # Verificao de tipos em compile-time\n type_check.h        # API do type checker\n```\n\n### Verificao de Tipos\n\nO compilador inclui um sistema unificado de verificao de tipos que pode:\n\n1. **Validar tipos em compile-time** - Capturar erros de tipo antes da execuo\n2. **Suportar cdigo dinmico** - Cdigo sem tipos  tratado como `any` (sempre vlido)\n3. **Fornecer dicas de otimizao** - Identificar variveis que podem ser unboxed\n\n**Flags de verificao de tipos:**\n\n| Flag | Descrio |\n|------|-----------|\n| (padro) | Verificao de tipos habilitada |\n| `--check` | Apenas verificar tipos, no compilar |\n| `--no-type-check` | Desabilitar verificao de tipos |\n| `--strict-types` | Avisar sobre tipos `any` implcitos |\n\n**Implementao do Type Checker:**\n\n```c\n// type_check.h - Estruturas principais\ntypedef struct TypeCheckContext {\n    const char *filename;\n    int error_count;\n    int warning_count;\n    UnboxableVar *unboxable_vars;  // Dicas de otimizao\n    // ... ambiente de tipos, definies, etc\n} TypeCheckContext;\n\n// Ponto de entrada principal\nint type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);\n```\n\n### Gerao de Cdigo\n\nA fase de gerao de cdigo transforma ns AST em cdigo C:\n\n**Mapeamento de Expresses:**\n```\nHemlock                   C Gerado\n----------------------------------------\nlet x = 42;              HmlValue x = hml_val_i32(42);\nx + y                    hml_add(x, y)\narr[i]                   hml_array_get(arr, i)\nobj.field                hml_object_get_field(obj, \"field\")\nfn(a, b) { ... }         closure com captura de ambiente\n```\n\n**Integrao com Runtime:**\n\nO cdigo C gerado linka com `libhemlock_runtime.a`, que fornece:\n- Tipo `HmlValue` tagged union\n- Gerenciamento de memria (contagem de referncia)\n- Funes builtin (print, typeof, etc.)\n- Primitivas de concorrncia (tasks, channels)\n- Suporte FFI\n\n### Otimizao de Unboxing\n\nO type checker identifica variveis que podem usar tipos C nativos ao invs de `HmlValue` boxed:\n\n**Padres unboxveis:**\n- Contadores de loop com tipo inteiro conhecido\n- Variveis acumuladoras em loops\n- Variveis com anotaes de tipo explcitas (i32, i64, f64, bool)\n\n```hemlock\n// Contador de loop 'i' pode ser unboxed para int32_t nativo\nfor (let i: i32 = 0; i < 1000000; i = i + 1) {\n    sum = sum + i;\n}\n```\n\n---\n\n## Design Modular do Interpretador\n\nO interpretador  dividido em mdulos focados para melhor manutenibilidade e extensibilidade.\n\n### Responsabilidades dos Mdulos\n\n#### 1. Ambiente (`environment.c`) - 121 linhas\n\n**Propsito:** Escopo de variveis e resoluo de nomes\n\n**Funes principais:**\n- `env_create()` - Criar novo ambiente com pai opcional\n- `env_define()` - Definir nova varivel no escopo atual\n- `env_get()` - Buscar varivel no escopo atual ou pai\n- `env_set()` - Atualizar valor de varivel existente\n- `env_free()` - Liberar ambiente e todas as variveis\n\n**Design:**\n- Escopos encadeados (cada ambiente tem ponteiro para pai)\n- HashMap para busca rpida de variveis\n- Suporta escopo lxico para closures\n\n#### 2. Valores (`values.c`) - 394 linhas\n\n**Propsito:** Construtores de valores e gerenciamento de estruturas de dados\n\n**Funes principais:**\n- `value_create_*()` - Construtores para cada tipo de valor\n- `value_copy()` - Lgica de cpia profunda/rasa\n- `value_free()` - Limpeza e liberao de memria\n- `value_to_string()` - Representao em string para impresso\n\n**Estruturas de dados:**\n- Objetos (array dinmico de campos)\n- Arrays (redimensionamento dinmico)\n- Buffers (ptr + length + capacity)\n- Closures (funo + ambiente capturado)\n- Tasks e Channels (primitivas de concorrncia)\n\n#### 3. Tipos (`types.c`) - 440 linhas\n\n**Propsito:** Sistema de tipos, converses e duck typing\n\n**Funes principais:**\n- `type_check()` - Validao de tipos em tempo de execuo\n- `type_convert()` - Converso/promoo de tipos implcita\n- `duck_type_check()` - Verificao de tipos estruturais para objetos\n- `type_name()` - Obter nome do tipo para impresso\n\n**Recursos:**\n- Hierarquia de promoo de tipos (i8  i16  i32  i64  f32  f64, i64/u64 + f32  f64)\n- Verificao de intervalo para tipos numricos\n- Duck typing para definies de tipo de objeto\n- Valores padro para campos opcionais\n\n#### 4. Builtins (`builtins.c`) - 955 linhas\n\n**Propsito:** Funes builtin e registro global\n\n**Funes principais:**\n- `register_builtins()` - Registrar todas as funes e constantes builtin\n- Implementaes de funes builtin (print, typeof, alloc, free, etc.)\n- Funes de tratamento de sinais\n- Execuo de comandos (exec)\n\n**Categorias de builtins:**\n- I/O: print, open, read_file, write_file\n- Memria: alloc, free, memset, memcpy, realloc\n- Tipos: typeof, assert\n- Concorrncia: spawn, join, detach, channel\n- Sistema: exec, signal, raise, panic\n- FFI: dlopen, dlsym, dlcall, dlclose\n\n#### 5. I/O (`io.c`) - 449 linhas\n\n**Propsito:** I/O de arquivos e serializao JSON\n\n**Funes principais:**\n- Mtodos de objeto File (read, write, seek, tell, close)\n- Serializao/deserializao JSON\n- Deteco de referncia circular\n\n**Recursos:**\n- Objetos file com atributos (path, mode, closed)\n- I/O de texto com awareness de UTF-8\n- Suporte a I/O binrio\n- Roundtrip JSON para objetos e arrays\n\n#### 6. FFI (`ffi.c`) - Interface de Funo Estrangeira\n\n**Propsito:** Chamar funes C de bibliotecas compartilhadas\n\n**Funes principais:**\n- `dlopen()` - Carregar biblioteca compartilhada\n- `dlsym()` - Obter ponteiro de funo por nome\n- `dlcall()` - Chamar funo C com converso de tipos\n- `dlclose()` - Descarregar biblioteca\n\n**Recursos:**\n- Integrao com libffi para chamadas de funo dinmicas\n- Converso automtica de tipos (Hemlock  tipos C)\n- Suporte para todos os tipos primitivos\n- Suporte para ponteiros e buffers\n\n#### 7. Runtime (`runtime.c`) - 865 linhas\n\n**Propsito:** Avaliao de expresses e execuo de statements\n\n**Funes principais:**\n- `eval_expr()` - Avaliar expresses (recursivo)\n- `eval_stmt()` - Executar statements\n- Tratamento de fluxo de controle (if, while, for, switch, etc.)\n- Tratamento de excees (try/catch/finally/throw)\n\n**Recursos:**\n- Avaliao recursiva de expresses\n- Avaliao short-circuit de booleanos\n- Deteco de chamada de mtodo e binding de `self`\n- Propagao de excees\n- Tratamento de break/continue/return\n\n### Benefcios do Design Modular\n\n**1. Separao de Concerns**\n- Cada mdulo tem uma responsabilidade clara\n- Fcil encontrar onde um recurso est implementado\n- Reduz carga cognitiva ao fazer mudanas\n\n**2. Builds Incrementais Mais Rpidos**\n- Apenas mdulos modificados precisam ser recompilados\n- Compilao paralela possvel\n- Tempo de iterao mais curto durante desenvolvimento\n\n**3. Testes e Debug Mais Fceis**\n- Mdulos podem ser testados independentemente\n- Erros localizados em subsistemas especficos\n- Implementaes mock possveis para testes\n\n**4. Extensibilidade**\n- Novos recursos podem ser adicionados aos mdulos apropriados\n- Mdulos podem ser refatorados independentemente\n- Quantidade de cdigo por arquivo permanece gerencivel\n\n**5. Organizao de Cdigo**\n- Agrupamento lgico de funcionalidades relacionadas\n- Grafo de dependncias claro\n- Mais fcil de onboarding para novos contribuidores\n\n---\n\n## Arquitetura de Runtime\n\n### Representao de Valores\n\nTodos os valores em Hemlock so representados pela struct `Value` usando tagged union:\n\n```c\ntypedef struct Value {\n    ValueType type;  // Tag de tipo em runtime\n    union {\n        int32_t i32_value;\n        int64_t i64_value;\n        uint8_t u8_value;\n        uint32_t u32_value;\n        uint64_t u64_value;\n        float f32_value;\n        double f64_value;\n        bool bool_value;\n        char *string_value;\n        uint32_t rune_value;\n        void *ptr_value;\n        Buffer *buffer_value;\n        Array *array_value;\n        Object *object_value;\n        Function *function_value;\n        File *file_value;\n        Task *task_value;\n        Channel *channel_value;\n    };\n} Value;\n```\n\n**Decises de design:**\n- **Tagged union** para type safety mantendo flexibilidade\n- **Tag de tipo em runtime** habilita tipagem dinmica com verificao de tipos\n- **Armazenamento direto de valores** para tipos primitivos (sem boxing)\n- **Armazenamento de ponteiros** para tipos alocados em heap (strings, objetos, arrays)\n\n### Exemplos de Layout de Memria\n\n**Inteiro (i32):**\n```\nValue {\n    type: TYPE_I32,\n    i32_value: 42\n}\n```\n- Tamanho total: ~16 bytes (8 bytes tag + 8 bytes union)\n- Alocado em stack\n- No requer alocao em heap\n\n**String:**\n```\nValue {\n    type: TYPE_STRING,\n    string_value: 0x7f8a4c000000  // Ponteiro para heap\n}\n\nHeap: \"hello\\0\" (6 bytes, UTF-8 terminado em null)\n```\n- Value ocupa 16 bytes em stack\n- Dados da string so alocados em heap\n- Deve ser liberado manualmente\n\n**Objeto:**\n```\nValue {\n    type: TYPE_OBJECT,\n    object_value: 0x7f8a4c001000  // Ponteiro para heap\n}\n\nHeap: Object {\n    type_name: \"Person\",\n    fields: [\n        { name: \"name\", value: Value{TYPE_STRING, \"Alice\"} },\n        { name: \"age\", value: Value{TYPE_I32, 30} }\n    ],\n    field_count: 2,\n    capacity: 4\n}\n```\n- Estrutura Object em heap\n- Campos armazenados em array dinmico\n- Valores de campos so structs Value embutidas\n\n### Implementao de Ambiente\n\nVariveis so armazenadas em cadeia de ambientes:\n\n```c\ntypedef struct Environment {\n    HashMap *bindings;           // nome  Value\n    struct Environment *parent;  // Escopo pai lxico\n} Environment;\n```\n\n**Exemplo de cadeia de escopo:**\n```\nEscopo Global: { print: <builtin>, args: <array> }\n    \nEscopo de Funo: { x: 10, y: 20 }\n    \nEscopo de Bloco: { i: 0 }\n```\n\n**Algoritmo de busca:**\n1. Verificar hashmap do ambiente atual\n2. Se no encontrado, verificar ambiente pai\n3. Repetir at encontrar ou alcanar escopo global\n4. Erro se no encontrado em nenhum escopo\n\n---\n\n## Implementao do Sistema de Tipos\n\n### Estratgia de Verificao de Tipos\n\nHemlock usa **verificao de tipos em runtime** com **anotaes de tipo opcionais**:\n\n```hemlock\nlet x = 42;           // Sem verificao de tipo, inferido como i32\nlet y: u8 = 255;      // Verificao runtime: valor deve caber em u8\nlet z: i32 = x + y;   // Verificao runtime + promoo de tipo\n```\n\n**Fluxo de implementao:**\n1. **Inferncia de literal** - Lexer/parser determina tipo inicial do literal\n2. **Verificao de anotao** - Se anotao presente, validar na atribuio\n3. **Promoo** - Operaes binrias promovem para tipo comum\n4. **Converso** - Converses explcitas acontecem conforme necessrio\n\n### Implementao de Promoo de Tipos\n\nA promoo de tipos segue hierarquia fixa e preserva preciso:\n\n```c\n// Lgica simplificada de promoo\nValueType promote_types(ValueType a, ValueType b) {\n    // f64 sempre vence\n    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;\n\n    // f32 com i64/u64 promove para f64 (preservao de preciso)\n    if (a == TYPE_F32 || b == TYPE_F32) {\n        ValueType other = (a == TYPE_F32) ? b : a;\n        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;\n        return TYPE_F32;\n    }\n\n    // Tipo inteiro maior vence\n    int rank_a = get_type_rank(a);\n    int rank_b = get_type_rank(b);\n    return (rank_a > rank_b) ? a : b;\n}\n```\n\n**Ranks de tipo:**\n- i8: 0\n- u8: 1\n- i16: 2\n- u16: 3\n- i32: 4\n- u32: 5\n- i64: 6\n- u64: 7\n- f32: 8\n- f64: 9\n\n### Implementao de Duck Typing\n\nVerificao de tipos de objeto usa comparao estrutural:\n\n```c\nbool duck_type_check(Object *obj, TypeDef *type_def) {\n    // Verificar todos os campos requeridos\n    for (each field in type_def) {\n        if (!object_has_field(obj, field.name)) {\n            return false;  // Campo faltando\n        }\n\n        Value *field_value = object_get_field(obj, field.name);\n        if (!type_matches(field_value, field.type)) {\n            return false;  // Tipo errado\n        }\n    }\n\n    return true;  // Todos os campos requeridos presentes e tipados corretamente\n}\n```\n\n**Duck typing permite:**\n- Campos extras em objetos (ignorados)\n- Tipos de subestrutura (objetos podem ter mais do que requerido)\n- Atribuio de nome de tipo aps validao\n\n---\n\n## Gerenciamento de Memria\n\n### Estratgia de Alocao\n\nHemlock usa **gerenciamento manual de memria** com duas primitivas de alocao:\n\n**1. Ponteiros Brutos (`ptr`):**\n```c\nvoid *alloc(size_t bytes) {\n    void *ptr = malloc(bytes);\n    if (!ptr) {\n        fprintf(stderr, \"Out of memory\\n\");\n        exit(1);\n    }\n    return ptr;\n}\n```\n- malloc/free direto\n- Sem rastreamento\n- Usurio responsvel pela liberao\n\n**2. Buffers (`buffer`):**\n```c\ntypedef struct Buffer {\n    void *data;\n    size_t length;\n    size_t capacity;\n} Buffer;\n\nBuffer *create_buffer(size_t size) {\n    Buffer *buf = malloc(sizeof(Buffer));\n    buf->data = malloc(size);\n    buf->length = size;\n    buf->capacity = size;\n    return buf;\n}\n```\n- Rastreia tamanho e capacidade\n- Verificao de limites em acesso\n- Ainda requer free manual\n\n### Tipos Alocados em Heap\n\n**Strings:**\n- Array de bytes UTF-8 em heap\n- Terminada em null para interop com C\n- Mutveis (podem ser modificadas in-place)\n- Contagem de referncia (liberadas automaticamente ao sair do escopo)\n\n**Objetos:**\n- Array dinmico de campos\n- Nomes e valores de campos em heap\n- Contagem de referncia (liberados automaticamente ao sair do escopo)\n- Referncias circulares possveis (tratadas com visited-set tracking)\n\n**Arrays:**\n- Capacidade dinmica com crescimento por dobra\n- Elementos so structs Value embutidas\n- Realocao automtica em crescimento\n- Contagem de referncia (liberados automaticamente ao sair do escopo)\n\n**Closures:**\n- Capturam ambiente por referncia\n- Ambiente  alocado em heap\n- Ambiente de closure liberado corretamente quando no mais referenciado\n\n---\n\n## Modelo de Concorrncia\n\n### Arquitetura de Threads\n\nHemlock usa modelo de **threads 1:1** com threads POSIX (pthreads):\n\n```\nTasks de Usurio       Threads SO           Ncleos CPU\n--------------         ----------           -----------\nspawn(f1) ------>  pthread_create --> Core 0\nspawn(f2) ------>  pthread_create --> Core 1\nspawn(f3) ------>  pthread_create --> Core 2\n```\n\n**Caractersticas principais:**\n- Cada `spawn()` cria um novo pthread\n- Kernel agenda threads entre cores\n- Execuo paralela real (sem GIL)\n- Multitarefa preemptiva\n\n### Implementao de Tasks\n\n```c\ntypedef struct Task {\n    pthread_t thread;        // Handle da thread SO\n    Value result;            // Valor de retorno\n    char *error;             // Mensagem de exceo (se lanada)\n    pthread_mutex_t lock;    // Protege estado\n    TaskState state;         // RUNNING, FINISHED, ERROR\n} Task;\n```\n\n**Ciclo de vida da task:**\n1. `spawn(func, args)`  Cria Task, inicia pthread\n2. Thread executa funo com argumentos\n3. No retorno: armazena resultado, define estado para FINISHED\n4. Na exceo: armazena mensagem de erro, define estado para ERROR\n5. `join(task)`  Espera thread, retorna resultado ou lana exceo\n\n### Implementao de Channels\n\n```c\ntypedef struct Channel {\n    void **buffer;           // Buffer circular de Value*\n    size_t capacity;         // Mximo de itens no buffer\n    size_t count;            // Itens atuais no buffer\n    size_t read_index;       // Prxima posio de leitura\n    size_t write_index;      // Prxima posio de escrita\n    bool closed;             // Flag de channel fechado\n    pthread_mutex_t lock;    // Protege buffer\n    pthread_cond_t not_full; // Sinaliza quando h espao\n    pthread_cond_t not_empty;// Sinaliza quando h dados\n} Channel;\n```\n\n**Operao de envio:**\n1. Trava mutex\n2. Se buffer cheio espera (cond_wait em not_full)\n3. Escreve valor em buffer[write_index]\n4. Incrementa write_index (circular)\n5. Sinaliza not_empty\n6. Destrava mutex\n\n**Operao de recebimento:**\n1. Trava mutex\n2. Se buffer vazio espera (cond_wait em not_empty)\n3. L valor de buffer[read_index]\n4. Incrementa read_index (circular)\n5. Sinaliza not_full\n6. Destrava mutex\n\n**Garantias de sincronizao:**\n- Send/recv thread-safe (protegidos por mutex)\n- Semntica bloqueante (produtor espera quando cheio, consumidor espera quando vazio)\n- Entrega ordenada (FIFO dentro do channel)\n\n---\n\n## Planos Futuros\n\n### Concludo: Backend do Compilador\n\nO backend do compilador (`hemlockc`) est implementado:\n- Gerao de cdigo C a partir do AST\n- Verificao de tipos em compile-time (habilitada por padro)\n- Biblioteca de runtime (`libhemlock_runtime.a`)\n- Paridade total com interpretador (98% taxa de aprovao em testes)\n- Framework de otimizao de unboxing\n\n### Foco Atual: Melhorias no Sistema de Tipos\n\n**Melhorias recentes:**\n- Sistema unificado de verificao e inferncia de tipos\n- Verificao de tipos em compile-time habilitada por padro\n- Flag `--check` para validao apenas de tipos\n- Contexto de tipos passado para gerao de cdigo para dicas de otimizao\n\n### Melhorias Futuras\n\n**Possveis adies:**\n- Generics/templates\n- Pattern matching\n- Integrao LSP para suporte de IDE com awareness de tipos\n- Otimizaes de unboxing mais agressivas\n- Anlise de escape para alocao em stack\n\n### Otimizaes de Longo Prazo\n\n**Possveis melhorias:**\n- Cache inline para chamadas de mtodo\n- Compilao JIT para caminhos de cdigo quentes\n- Scheduler work-stealing para melhor concorrncia\n- Otimizao guiada por profile\n\n---\n\n## Diretrizes de Implementao\n\n### Adicionando Novos Recursos\n\nAo implementar novos recursos, siga estas diretrizes:\n\n**1. Escolha o mdulo correto:**\n- Novos tipos de valor  `values.c`\n- Converses de tipo  `types.c`\n- Funes builtin  `builtins.c`\n- Operaes I/O  `io.c`\n- Fluxo de controle  `runtime.c`\n\n**2. Atualize todas as camadas:**\n- Adicione tipo de n AST se necessrio (`ast.h`, `ast.c`)\n- Adicione token do lexer se necessrio (`lexer.c`)\n- Adicione regras do parser (`parser.c`)\n- Implemente comportamento runtime (`runtime.c` ou mdulo apropriado)\n- Adicione testes (`tests/`)\n\n**3. Mantenha consistncia:**\n- Siga estilo de cdigo existente\n- Use convenes de nomenclatura consistentes\n- Documente APIs pblicas em headers\n- Mantenha mensagens de erro claras e consistentes\n\n**4. Teste completamente:**\n- Adicione casos de teste antes de implementar\n- Teste caminhos de sucesso e erro\n- Teste casos de borda\n- Verifique que no h vazamentos de memria (valgrind)\n\n### Consideraes de Performance\n\n**Gargalos atuais:**\n- Busca em HashMap para acesso a variveis\n- Chamadas de funo recursivas (sem TCO)\n- Concatenao de strings (aloca nova string cada vez)\n- Overhead de verificao de tipo por operao\n\n**Oportunidades de otimizao:**\n- Cache de localizao de variveis (cache inline)\n- Otimizao de tail call\n- String builder para concatenao\n- Inferncia de tipos para pular verificaes runtime\n\n### Dicas de Debug\n\n**Ferramentas teis:**\n- `valgrind` - Deteco de vazamento de memria\n- `gdb` - Debug de crashes\n- Flag `-g` - Smbolos de debug\n- Debug com `printf` - Simples mas efetivo\n\n**Problemas comuns:**\n- Segfault  Desreferncia de ponteiro nulo (verifique valores de retorno)\n- Vazamento de memria  Chamada free() faltando (verifique caminhos de value_free)\n- Erros de tipo  Verifique lgica de type_convert() e type_check()\n- Crash em thread  Condio de corrida (verifique uso de mutex)\n\n---\n\n## Resumo\n\nA implementao do Hemlock prioriza:\n- **Modularidade** - Separao clara de concerns\n- **Simplicidade** - Implementao direta\n- **Explicitude** - Sem mgica oculta\n- **Manutenibilidade** - Fcil de entender e modificar\n\nO interpretador tree-walking atual  intencionalmente simples para facilitar desenvolvimento rpido de recursos e experimentao. O backend do compilador futuro melhorar performance mantendo a mesma semntica.\n"}, "Design e Filosofia -> Sintaxe de Assinaturas": {"id": "design-signature-syntax", "content": "# Design de Sintaxe de Assinaturas\n\n> Estendendo o sistema de tipos do Hemlock com tipos de funo, modificadores nullable, aliases de tipo, parmetros const e assinaturas de mtodo.\n\n**Status:** Implementado (v1.7.0)\n**Verso:** 1.0\n**Autor:** Claude\n\n---\n\n## Viso Geral\n\nEste documento prope cinco extenses inter-relacionadas do sistema de tipos que se baseiam na infraestrutura existente do Hemlock:\n\n1. **Anotaes de Tipo de Funo** - Tipos de funo de primeira classe\n2. **Modificador de Tipo Nullable** - Tratamento explcito de null (estendendo flag `nullable` existente)\n3. **Aliases de Tipo** - Abreviaes de tipo nomeadas\n4. **Parmetros Const** - Contratos de imutabilidade\n5. **Assinaturas de Mtodo em Define** - Comportamento de interface\n\nEstes recursos compartilham a mesma filosofia: **explcito  melhor que implcito, opcional mas aplicado quando usado**.\n\n---\n\n## 1. Anotaes de Tipo de Funo\n\n### Motivao\n\nAtualmente, no h como expressar a assinatura de uma funo como um tipo:\n\n```hemlock\n// Atual: callback no tem informao de tipo\nfn map(arr: array, callback) { ... }\n\n// Proposto: tipo de funo explcito\nfn map(arr: array, callback: fn(any, i32): any): array { ... }\n```\n\n### Sintaxe\n\n```hemlock\n// Tipo de funo bsico\nfn(i32, i32): i32\n\n// Com nomes de parmetros (apenas documentao, no aplicado)\nfn(a: i32, b: i32): i32\n\n// Sem retorno (void)\nfn(string): void\nfn(string)              // Abreviao: omitir `: void`\n\n// Retorno nullable\nfn(i32): string?\n\n// Parmetros opcionais\nfn(name: string, age?: i32): void\n\n// Parmetros rest\nfn(...args: array): i32\n\n// Sem parmetros\nfn(): bool\n\n// Alta ordem: funo que retorna funo\nfn(i32): fn(i32): i32\n\n// Tipo de funo async\nasync fn(i32): i32\n```\n\n### Exemplos de Uso\n\n```hemlock\n// Varivel com tipo de funo\nlet add: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// Parmetro de funo\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Tipo de retorno  uma funo\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Array de funes\nlet ops: array<fn(i32, i32): i32> = [add, subtract, multiply];\n\n// Campo de objeto\ndefine EventHandler {\n    name: string;\n    callback: fn(Event): void;\n}\n```\n\n### Mudanas no AST\n\n```c\n// No enum TypeKind (include/ast.h)\ntypedef enum {\n    // ... tipos existentes ...\n    TYPE_FUNCTION,      // Novo: tipo de funo\n} TypeKind;\n\n// Na struct Type (include/ast.h)\nstruct Type {\n    TypeKind kind;\n    // ... campos existentes ...\n\n    // Para TYPE_FUNCTION:\n    struct Type **param_types;      // Tipos de parmetros\n    char **param_names;             // Nomes de parmetros opcionais (documentao)\n    int *param_optional;            // Quais parmetros so opcionais\n    int num_params;\n    char *rest_param_name;          // Nome do parmetro rest ou NULL\n    struct Type *rest_param_type;   // Tipo do parmetro rest\n    struct Type *return_type;       // Tipo de retorno (NULL = void)\n    int is_async;                   // Tipo fn async\n};\n```\n\n### Parsing\n\nTipos de funo comeam com `fn` (ou `async fn`) seguido por lista de parmetros:\n\n```\nfunction_type := [\"async\"] \"fn\" \"(\" [param_type_list] \")\" [\":\" type]\nparam_type_list := param_type (\",\" param_type)*\nparam_type := [identifier \":\"] [\"?\"] type | \"...\" [identifier] [\":\" type]\n```\n\n**Desambiguao:** Ao fazer parse de tipo e encontrar `fn`:\n- Se seguido por `(`,  um tipo de funo\n- Caso contrrio, erro de sintaxe (`fn` isolado no  tipo vlido)\n\n### Compatibilidade de Tipos\n\n```hemlock\n// Tipos de funo requerem correspondncia exata\nlet f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // OK\n\n// Contravarincia de parmetros (aceitar tipo mais amplo  ok)\nlet g: fn(any): i32 = fn(x: i32): i32 { return x; };  // OK: i32 <: any\n\n// Covarincia de retorno (retornar tipo mais estreito  ok)\nlet h: fn(i32): any = fn(x: i32): i32 { return x; };  // OK: i32 <: any\n\n// Nmero de parmetros deve corresponder\nlet bad: fn(i32): i32 = fn(a, b) { return a; };       // Erro: nmero de parmetros no corresponde\n\n// Parmetros opcionais compatveis com requeridos\nlet opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // OK\n```\n\n---\n\n## 2. Modificador de Tipo Nullable\n\n### Motivao\n\nO sufixo `?` torna a aceitao de null explcita nas assinaturas:\n\n```hemlock\n// Atual: no est claro se null  vlido\nfn find(arr: array, val: any): i32 { ... }\n\n// Proposto: retorno nullable explcito\nfn find(arr: array, val: any): i32? { ... }\n```\n\n### Sintaxe\n\n```hemlock\n// Tipo nullable com sufixo ?\nstring?           // string ou null\ni32?              // i32 ou null\nUser?             // User ou null\narray<i32>?       // array ou null\nfn(i32): i32?     // Funo que retorna i32 ou null\n\n// Combinao com tipos de funo\nfn(string?): i32          // Aceita string ou null\nfn(string): i32?          // Retorna i32 ou null\nfn(string?): i32?         // Ambos nullable\n\n// Em define\ndefine Result {\n    value: any?;\n    error: string?;\n}\n```\n\n### Notas de Implementao\n\n**J existe:** Flag `Type.nullable` j existe no AST. Este recurso principalmente requer:\n1. Suporte do parser para sufixo `?` em qualquer tipo (validar/estender)\n2. Combinao adequada com tipos de funo\n3. Aplicao em runtime\n\n### Compatibilidade de Tipos\n\n```hemlock\n// No-null pode ser atribudo a nullable\nlet x: i32? = 42;           // OK\nlet y: i32? = null;         // OK\n\n// Nullable no pode ser atribudo a no-null\nlet z: i32 = x;             // Erro: x pode ser null\n\n// Coalescncia de null para desempacotar\nlet z: i32 = x ?? 0;        // OK: ?? fornece valor padro\n\n// Encadeamento opcional retorna nullable\nlet name: string? = user?.name;\n```\n\n---\n\n## 3. Aliases de Tipo\n\n### Motivao\n\nTipos complexos se beneficiam de abreviaes nomeadas:\n\n```hemlock\n// Atual: tipos compostos repetidos\nfn process(entity: HasName & HasId & HasTimestamp) { ... }\nfn validate(entity: HasName & HasId & HasTimestamp) { ... }\n\n// Proposto: alias nomeado\ntype Entity = HasName & HasId & HasTimestamp;\nfn process(entity: Entity) { ... }\nfn validate(entity: Entity) { ... }\n```\n\n### Sintaxe\n\n```hemlock\n// Alias bsico\ntype Integer = i32;\ntype Text = string;\n\n// Alias de tipo composto\ntype Entity = HasName & HasId;\ntype Auditable = HasCreatedAt & HasUpdatedAt & HasCreatedBy;\n\n// Alias de tipo de funo\ntype Callback = fn(Event): void;\ntype Predicate = fn(any): bool;\ntype Reducer = fn(acc: any, val: any): any;\ntype AsyncTask = async fn(): any;\n\n// Alias nullable\ntype OptionalString = string?;\n\n// Alias genrico (se suportarmos aliases de tipo genricos)\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// Alias de tipo array\ntype IntArray = array<i32>;\ntype Matrix = array<array<f64>>;\n```\n\n### Escopo e Visibilidade\n\n```hemlock\n// Escopo de mdulo por padro\ntype Callback = fn(Event): void;\n\n// Exportvel\nexport type Handler = fn(Request): Response;\n\n// Em outro arquivo\nimport { Handler } from \"./handlers.hml\";\nfn register(h: Handler) { ... }\n```\n\n### Mudanas no AST\n\n```c\n// Novo tipo de statement\ntypedef enum {\n    // ... statements existentes ...\n    STMT_TYPE_ALIAS,    // Novo\n} StmtKind;\n\n// Na union Stmt\nstruct {\n    char *name;                 // Nome do alias\n    char **type_params;         // Parmetros genricos: <T, U>\n    int num_type_params;\n    Type *aliased_type;         // Tipo real\n} type_alias;\n```\n\n### Parsing\n\n```\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n```\n\n**Nota:** `type`  uma nova palavra-chave. Verificar conflitos com identificadores existentes.\n\n### Resoluo\n\nAliases de tipo so resolvidos em:\n- **Tempo de parse:** Alias  registrado no ambiente de tipos\n- **Tempo de verificao:** Alias  expandido para tipo subjacente\n- **Runtime:** Alias  transparente (mesmo que tipo subjacente)\n\n```hemlock\ntype MyInt = i32;\nlet x: MyInt = 42;\ntypeof(x);           // \"i32\" (no \"MyInt\")\n```\n\n---\n\n## 4. Parmetros Const\n\n### Motivao\n\nExpressar inteno de imutabilidade nas assinaturas de funo:\n\n```hemlock\n// Atual: no est claro se array ser modificado\nfn print_all(items: array) { ... }\n\n// Proposto: contrato de imutabilidade explcito\nfn print_all(const items: array) { ... }\n```\n\n### Sintaxe\n\n```hemlock\n// Parmetro const\nfn process(const data: buffer) {\n    // data[0] = 0;        // Erro: no pode modificar const\n    let x = data[0];       // OK: leitura permitida\n    return x;\n}\n\n// Mltiplos parmetros const\nfn compare(const a: array, const b: array): bool { ... }\n\n// Misturando const e mutvel\nfn update(const source: array, target: array) {\n    for (item in source) {\n        target.push(item);   // OK: target  mutvel\n    }\n}\n\n// Const com inferncia de tipo\nfn log(const msg) {\n    print(msg);\n}\n\n// Const em tipo de funo\ntype Reader = fn(const buffer): i32;\n```\n\n### Operaes que Const Impede\n\n```hemlock\nfn bad(const arr: array) {\n    arr.push(1);         // Erro: mtodo modificador\n    arr.pop();           // Erro: mtodo modificador\n    arr[0] = 5;          // Erro: atribuio por ndice\n    arr.clear();         // Erro: mtodo modificador\n}\n\nfn ok(const arr: array) {\n    let x = arr[0];      // OK: leitura\n    let len = len(arr);  // OK: verificar comprimento\n    let copy = arr.slice(0, 10);  // OK: cria novo array\n    for (item in arr) {  // OK: iterao\n        print(item);\n    }\n}\n```\n\n### Mtodos Modificadores vs No-Modificadores\n\n| Tipo | Modificadores (bloqueados por const) | No-Modificadores (permitidos) |\n|------|--------------------------------------|--------------------------------|\n| array | push, pop, shift, unshift, insert, remove, clear, reverse (in-place) | slice, concat, map, filter, find, contains, first, last, join |\n| string | Atribuio por ndice (`s[0] = 'x'`) | Todos os mtodos (retornam nova string) |\n| buffer | Atribuio por ndice, memset, memcpy (destino) | Leitura por ndice, slice |\n| object | Atribuio de campo | Leitura de campo |\n\n### Mudanas no AST\n\n```c\n// Na expresso de funo (include/ast.h)\nstruct {\n    // ... campos existentes ...\n    int *param_is_const;    // Novo: 1 para const, 0 caso contrrio\n} function;\n\n// Na struct Type para tipo de funo\nstruct Type {\n    // ... campos existentes ...\n    int *param_is_const;    // Para TYPE_FUNCTION\n};\n```\n\n### Aplicao\n\n**Interpretador:**\n- Rastrear const-ness em binding de variveis\n- Verificar antes de operaes modificadoras\n- Erro runtime em violao de const\n\n**Compilador:**\n- Gerar variveis C qualificadas com const quando benfico\n- Anlise esttica para violaes de const\n- Avisos/erros em tempo de compilao\n\n---\n\n## 5. Assinaturas de Mtodo em Define\n\n### Motivao\n\nPermitir que blocos `define` especifiquem mtodos esperados, no apenas campos de dados:\n\n```hemlock\n// Atual: apenas campos de dados\ndefine User {\n    name: string;\n    age: i32;\n}\n\n// Proposto: assinaturas de mtodo\ndefine Comparable {\n    fn compare(other: Self): i32;\n}\n\ndefine Serializable {\n    fn serialize(): string;\n    fn deserialize(data: string): Self;  // Mtodo esttico\n}\n```\n\n### Sintaxe\n\n```hemlock\n// Assinatura de mtodo (sem corpo)\ndefine Hashable {\n    fn hash(): i32;\n}\n\n// Mltiplos mtodos\ndefine Collection {\n    fn size(): i32;\n    fn is_empty(): bool;\n    fn contains(item: any): bool;\n}\n\n// Misturando campos e mtodos\ndefine Entity {\n    id: i32;\n    name: string;\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\n// Usando tipo Self\ndefine Cloneable {\n    fn clone(): Self;\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;\n    fn equals(other: Self): bool;\n}\n\n// Mtodo opcional\ndefine Printable {\n    fn to_string(): string;\n    fn debug_string?(): string;  // Mtodo opcional (pode no existir)\n}\n\n// Mtodo com implementao padro\ndefine Ordered {\n    fn compare(other: Self): i32;  // Requerido\n\n    // Implementao padro (herdada se no sobrescrita)\n    fn less_than(other: Self): bool {\n        return self.compare(other) < 0;\n    }\n    fn greater_than(other: Self): bool {\n        return self.compare(other) > 0;\n    }\n    fn equals(other: Self): bool {\n        return self.compare(other) == 0;\n    }\n}\n```\n\n### Tipo `Self`\n\n`Self` refere-se ao tipo concreto que implementa a interface:\n\n```hemlock\ndefine Addable {\n    fn add(other: Self): Self;\n}\n\n// Ao usar:\nlet a: Addable = {\n    value: 10,\n    add: fn(other) {\n        return { value: self.value + other.value, add: self.add };\n    }\n};\n```\n\n### Tipagem Estrutural (Duck Typing)\n\nAssinaturas de mtodo usam o mesmo duck typing que campos:\n\n```hemlock\ndefine Stringifiable {\n    fn to_string(): string;\n}\n\n// Qualquer objeto com mtodo to_string() satisfaz Stringifiable\nlet x: Stringifiable = {\n    name: \"test\",\n    to_string: fn() { return self.name; }\n};\n\n// Tipos compostos com mtodos\ndefine Named { name: string; }\ndefine Printable { fn to_string(): string; }\n\ntype NamedPrintable = Named & Printable;\n\nlet y: NamedPrintable = {\n    name: \"Alice\",\n    to_string: fn() { return \"Name: \" + self.name; }\n};\n```\n\n### Mudanas no AST\n\n```c\n// Estendendo define_object na union Stmt\nstruct {\n    char *name;\n    char **type_params;\n    int num_type_params;\n\n    // Campos (existentes)\n    char **field_names;\n    Type **field_types;\n    int *field_optional;\n    Expr **field_defaults;\n    int num_fields;\n\n    // Mtodos (novos)\n    char **method_names;\n    Type **method_types;        // TYPE_FUNCTION\n    int *method_optional;       // Mtodos opcionais (fn name?(): type)\n    Expr **method_defaults;     // Implementao padro (NULL se apenas assinatura)\n    int num_methods;\n} define_object;\n```\n\n### Verificao de Tipos\n\nAo verificar `value: InterfaceType`:\n1. Verificar que todos os campos requeridos existem e tipos so compatveis\n2. Verificar que todos os mtodos requeridos existem e assinaturas so compatveis\n3. Campos/mtodos opcionais podem estar ausentes\n\n```hemlock\ndefine Sortable {\n    fn compare(other: Self): i32;\n}\n\n// Vlido: tem mtodo compare\nlet valid: Sortable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// Invlido: falta compare\nlet invalid: Sortable = { value: 10 };  // Erro: falta mtodo 'compare'\n\n// Invlido: assinatura errada\nlet wrong: Sortable = {\n    compare: fn() { return 0; }  // Erro: esperava (Self): i32\n};\n```\n\n---\n\n## Exemplos de Interao\n\n### Combinando Todos os Recursos\n\n```hemlock\n// Alias de tipo para tipo de funo complexo\ntype EventCallback = fn(event: Event, context: Context?): bool;\n\n// Alias de tipo para interface composta\ntype Entity = HasId & HasName & Serializable;\n\n// Define com assinaturas de mtodo\ndefine Repository<T> {\n    fn find(id: i32): T?;\n    fn save(const entity: T): bool;\n    fn delete(id: i32): bool;\n    fn find_all(predicate: fn(T): bool): array<T>;\n}\n\n// Usando tudo junto\nfn create_user_repo(): Repository<User> {\n    let users: array<User> = [];\n\n    return {\n        find: fn(id) {\n            for (u in users) {\n                if (u.id == id) { return u; }\n            }\n            return null;\n        },\n        save: fn(const entity) {\n            users.push(entity);\n            return true;\n        },\n        delete: fn(id) {\n            // ...\n            return true;\n        },\n        find_all: fn(predicate) {\n            return users.filter(predicate);\n        }\n    };\n}\n```\n\n### Callbacks com Tipos Explcitos\n\n```hemlock\ntype ClickHandler = fn(event: MouseEvent): void;\ntype KeyHandler = fn(event: KeyEvent, modifiers: i32): bool;\n\ndefine Widget {\n    x: i32;\n    y: i32;\n    on_click: ClickHandler?;\n    on_key: KeyHandler?;\n}\n\nfn create_button(label: string, handler: ClickHandler): Widget {\n    return {\n        x: 0, y: 0,\n        on_click: handler,\n        on_key: null\n    };\n}\n```\n\n### Tipos de Funo Nullable\n\n```hemlock\n// Callback opcional\nfn fetch(url: string, on_complete: fn(Response): void?): void {\n    let response = http_get(url);\n    if (on_complete != null) {\n        on_complete(response);\n    }\n}\n\n// Retorno nullable de tipo de funo\ntype Parser = fn(input: string): AST?;\n\nfn try_parse(parsers: array<Parser>, input: string): AST? {\n    for (p in parsers) {\n        let result = p(input);\n        if (result != null) {\n            return result;\n        }\n    }\n    return null;\n}\n```\n\n---\n\n## Roteiro de Implementao\n\n### Fase 1: Infraestrutura Core\n1. Adicionar `TYPE_FUNCTION` ao enum TypeKind\n2. Estender struct Type com campos de tipo de funo\n3. Adicionar `CHECKED_FUNCTION` ao type checker do compilador\n4. Adicionar suporte a tipo `Self` (TYPE_SELF)\n\n### Fase 2: Parsing\n1. Implementar `parse_function_type()` no parser\n2. Tratar `fn(...)` em posio de tipo\n3. Adicionar palavra-chave `type` e parsing de `STMT_TYPE_ALIAS`\n4. Adicionar parsing de modificador de parmetro `const`\n5. Estender parsing de define para suportar assinaturas de mtodo\n\n### Fase 3: Verificao de Tipos\n1. Regras de compatibilidade de tipos de funo\n2. Resoluo e expanso de aliases de tipo\n3. Verificao de modificao de parmetros const\n4. Validao de assinatura de mtodo em tipos define\n5. Resoluo de tipo Self\n\n### Fase 4: Runtime\n1. Validao de tipo de funo em ponto de chamada\n2. Deteco de violao de const\n3. Transparncia de alias de tipo\n\n### Fase 5: Testes de Paridade\n1. Testes de anotao de tipo de funo\n2. Testes de combinao nullable\n3. Testes de alias de tipo\n4. Testes de parmetros const\n5. Testes de assinatura de mtodo\n\n---\n\n## Decises de Design\n\n### 1. Aliases de Tipo Genricos: **Sim**\n\nAliases de tipo suportam parmetros genricos:\n\n```hemlock\n// Aliases de tipo genricos\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\ntype Mapper<T, U> = fn(T): U;\ntype AsyncResult<T> = async fn(): T?;\n\n// Uso\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\nlet result: Result<User, string> = { value: user, error: null };\nlet transform: Mapper<i32, string> = fn(n) { return n.to_string(); };\n```\n\n### 2. Propagao de Const: **Profunda**\n\nParmetros const so totalmente imutveis - no podem ser modificados por nenhum caminho:\n\n```hemlock\nfn process(const arr: array<object>) {\n    arr.push({});        // Erro: no pode modificar array const\n    arr[0] = {};         // Erro: no pode modificar array const\n    arr[0].x = 5;        // Erro: no pode modificar atravs de const (profundo)\n\n    let x = arr[0].x;    // OK: leitura  permitida\n    let copy = arr[0];   // OK: criar cpia\n    copy.x = 5;          // OK: cpia no  const\n}\n\nfn nested(const obj: object) {\n    obj.user.name = \"x\"; // Erro: const profundo impede modificao aninhada\n    obj.items[0] = 1;    // Erro: const profundo impede modificao aninhada\n}\n```\n\n**Justificativa:** Const profundo fornece garantias mais fortes e  mais til para garantir integridade de dados. Se voc precisa modificar dados aninhados, faa uma cpia primeiro.\n\n### 3. Self em Aliases de Tipo Standalone: **No**\n\n`Self` s  vlido dentro de blocos `define` onde tem significado claro:\n\n```hemlock\n// Vlido: Self refere-se ao tipo definido\ndefine Comparable {\n    fn compare(other: Self): i32;\n}\n\n// Invlido: Self no tem significado aqui\ntype Cloner = fn(Self): Self;  // Erro: Self fora de contexto define\n\n// Use genrico em vez disso:\ntype Cloner<T> = fn(T): T;\n```\n\n### 4. Implementaes Padro de Mtodo: **Sim (apenas simples)**\n\nPermitir implementao padro para mtodos simples/utilitrios:\n\n```hemlock\ndefine Comparable {\n    // Requerido: deve ser implementado\n    fn compare(other: Self): i32;\n\n    // Implementao padro (mtodos de convenincia simples)\n    fn equals(other: Self): bool {\n        return self.compare(other) == 0;\n    }\n    fn less_than(other: Self): bool {\n        return self.compare(other) < 0;\n    }\n    fn greater_than(other: Self): bool {\n        return self.compare(other) > 0;\n    }\n}\n\ndefine Printable {\n    fn to_string(): string;\n\n    // Padro: delegar para mtodo requerido\n    fn print() {\n        print(self.to_string());\n    }\n    fn println() {\n        print(self.to_string() + \"\\n\");\n    }\n}\n\n// Objetos s precisam implementar mtodos requeridos\nlet item: Comparable = {\n    value: 42,\n    compare: fn(other) { return self.value - other.value; }\n    // equals, less_than, greater_than herdados dos padres\n};\n\nitem.less_than({ value: 50, compare: item.compare });  // true\n```\n\n**Diretrizes para implementaes padro:**\n- Manter simples (1-3 linhas)\n- Devem delegar para mtodos requeridos\n- Sem lgica complexa ou efeitos colaterais\n- Apenas tipos primitivos e composio direta\n\n### 5. Varincia: **Inferida (sem anotaes explcitas)**\n\nVarincia  inferida com base em como parmetros de tipo so usados:\n\n```hemlock\n// Varincia determinada automaticamente pela posio\ntype Producer<T> = fn(): T;           // T em posio de retorno = covariante\ntype Consumer<T> = fn(T): void;       // T em posio de parmetro = contravariante\ntype Transformer<T> = fn(T): T;       // T em ambas posies = invariante\n\n// Exemplo: Dog <: Animal (Dog  subtipo de Animal)\nlet dog_producer: Producer<Dog> = fn() { return new_dog(); };\nlet animal_producer: Producer<Animal> = dog_producer;  // OK: covariante\n\nlet animal_consumer: Consumer<Animal> = fn(a) { print(a); };\nlet dog_consumer: Consumer<Dog> = animal_consumer;     // OK: contravariante\n```\n\n**Por que inferida?**\n- Menos boilerplate (`<out T>` / `<in T>` adiciona rudo)\n- Segue \"explcito  melhor que implcito\" - a posio em si  explcita\n- Consistente com como a maioria das linguagens trata varincia de tipo de funo\n- Erros claros quando regras de varincia so violadas\n\n---\n\n## Apndice: Mudanas de Sintaxe\n\n```ebnf\n(* Tipos *)\ntype := simple_type | compound_type | function_type\nsimple_type := base_type [\"?\"] | identifier [\"<\" type_args \">\"] [\"?\"]\ncompound_type := simple_type (\"&\" simple_type)+\nfunction_type := [\"async\"] \"fn\" \"(\" [param_types] \")\" [\":\" type]\n\nbase_type := \"i8\" | \"i16\" | \"i32\" | \"i64\"\n           | \"u8\" | \"u16\" | \"u32\" | \"u64\"\n           | \"f32\" | \"f64\" | \"bool\" | \"string\" | \"rune\"\n           | \"ptr\" | \"buffer\" | \"void\" | \"null\"\n           | \"array\" [\"<\" type \">\"]\n           | \"object\"\n           | \"Self\"\n\nparam_types := param_type (\",\" param_type)*\nparam_type := [\"const\"] [identifier \":\"] [\"?\"] type\n            | \"...\" [identifier] [\":\" type]\n\ntype_args := type (\",\" type)*\n\n(* Statements *)\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n\ndefine_stmt := \"define\" identifier [\"<\" type_params \">\"] \"{\" define_members \"}\"\ndefine_members := (field_def | method_def)*\nfield_def := identifier (\":\" type [\"=\" expr] | \"?:\" (type | expr)) \";\"?\nmethod_def := \"fn\" identifier [\"?\"] \"(\" [param_types] \")\" [\":\" type] (block | \";\")\n            (* \"?\" marca mtodo opcional, block fornece implementao padro *)\n\n(* Parmetros *)\nparam := [\"const\"] [\"ref\"] identifier [\":\" type] [\"?:\" expr]\n       | \"...\" identifier [\":\" type]\n```\n"}, "Contribuio -> Diretrizes": {"id": "contributing-guidelines", "content": "# Diretrizes de Contribuio do Hemlock\n\nObrigado pelo seu interesse em contribuir para o Hemlock! Este guia ajudar voc a entender como contribuir cdigo de forma efetiva, mantendo a filosofia de design e qualidade de cdigo da linguagem.\n\n---\n\n## Sumrio\n\n- [Antes de Comear](#antes-de-comear)\n- [Fluxo de Trabalho de Contribuio](#fluxo-de-trabalho-de-contribuio)\n- [Guia de Estilo de Cdigo](#guia-de-estilo-de-cdigo)\n- [O que Contribuir](#o-que-contribuir)\n- [O que No Contribuir](#o-que-no-contribuir)\n- [Padres Comuns](#padres-comuns)\n- [Adicionando Novos Recursos](#adicionando-novos-recursos)\n- [Processo de Code Review](#processo-de-code-review)\n\n---\n\n## Antes de Comear\n\n### Documentao Obrigatria\n\nAntes de contribuir, por favor leia os seguintes documentos na ordem:\n\n1. **`/home/user/hemlock/docs/design/philosophy.md`** - Entender os princpios centrais do Hemlock\n2. **`/home/user/hemlock/docs/design/implementation.md`** - Aprender a estrutura do cdigo\n3. **`/home/user/hemlock/docs/contributing/testing.md`** - Entender os requisitos de teste\n4. **Este documento** - Aprender as diretrizes de contribuio\n\n### Pr-requisitos\n\n**Conhecimento necessrio:**\n- Programao C (ponteiros, gerenciamento de memria, structs)\n- Fundamentos de compiladores/interpretadores (anlise lxica, sinttica, AST)\n- Fluxo de trabalho Git e GitHub\n- Linha de comando Unix/Linux\n\n**Ferramentas necessrias:**\n- Compilador GCC ou Clang\n- Sistema de build Make\n- Controle de verso Git\n- Valgrind (para deteco de vazamento de memria)\n- Editor de texto ou IDE bsico\n\n### Canais de Comunicao\n\n**Onde perguntar:**\n- GitHub Issues - Relatrios de bug e solicitaes de recursos\n- GitHub Discussions - Perguntas gerais e discusses de design\n- Comentrios em Pull Request - Feedback especfico de cdigo\n\n---\n\n## Fluxo de Trabalho de Contribuio\n\n### 1. Encontrar ou Criar uma Issue\n\n**Antes de escrever cdigo:**\n- Verificar se j existe uma issue relacionada  sua contribuio\n- Se no existir, criar uma issue descrevendo o que voc quer fazer\n- Esperar feedback dos mantenedores antes de comear grandes mudanas\n- Pequenas correes de bugs podem pular esta etapa\n\n**Uma boa descrio de issue inclui:**\n- Declarao do problema (o que est quebrado ou faltando)\n- Soluo proposta (como voc planeja corrigir)\n- Exemplos (trechos de cdigo mostrando o problema)\n- Justificativa (por que esta mudana est alinhada com a filosofia do Hemlock)\n\n### 2. Fork e Clone\n\n```bash\n# Primeiro faa fork do repositrio no GitHub, ento:\ngit clone https://github.com/SEU_USUARIO/hemlock.git\ncd hemlock\ngit checkout -b feature/nome-do-seu-recurso\n```\n\n### 3. Fazer Mudanas\n\nSiga estas diretrizes:\n- Escrever testes primeiro (abordagem TDD)\n- Implementar o recurso\n- Garantir que todos os testes passem\n- Verificar vazamentos de memria\n- Atualizar documentao\n\n### 4. Testar Suas Mudanas\n\n```bash\n# Executar sute de testes completa\nmake test\n\n# Executar categoria especfica de testes\n./tests/run_tests.sh tests/category/\n\n# Verificar vazamentos de memria\nvalgrind ./hemlock tests/your_test.hml\n\n# Build e teste\nmake clean && make && make test\n```\n\n### 5. Commitar Suas Mudanas\n\n**Boas mensagens de commit:**\n```\nAdd bitwise operators for integer types\n\n- Implement &, |, ^, <<, >>, ~ operators\n- Add type checking to ensure integer-only operations\n- Update operator precedence table\n- Add comprehensive tests for all operators\n\nCloses #42\n```\n\n**Formato da mensagem de commit:**\n- Primeira linha: resumo curto (mximo 50 caracteres)\n- Linha em branco\n- Descrio detalhada (quebra de linha em 72 caracteres)\n- Referenciar nmero da issue\n\n### 6. Submeter Pull Request\n\n**Antes de submeter:**\n- Rebase no main mais recente\n- Garantir que todos os testes passam\n- Executar valgrind para verificar vazamentos\n- Atualizar CLAUDE.md se adicionar recursos voltados ao usurio\n\n**A descrio do pull request deve incluir:**\n- Que problema isso resolve\n- Como foi resolvido\n- Breaking changes (se houver)\n- Exemplos de nova sintaxe ou comportamento\n- Resumo da cobertura de testes\n\n---\n\n## Guia de Estilo de Cdigo\n\n### Estilo de Cdigo C\n\n**Formatao:**\n```c\n// Use 4 espaos para indentao (no tabs)\n// Estilo K&R para chaves em funes\nvoid function_name(int arg1, char *arg2)\n{\n    if (condition) {\n        // Chaves de estruturas de controle na mesma linha\n        do_something();\n    }\n}\n\n// Comprimento de linha: mximo 100 caracteres\n// Espaos ao redor de operadores\nint result = (a + b) * c;\n\n// Asterisco de ponteiro junto ao tipo\nchar *string;   // Correto\nchar* string;   // Evitar\nchar * string;  // Evitar\n```\n\n**Convenes de Nomenclatura:**\n```c\n// Funes: minsculas com underscores\nvoid eval_expression(ASTNode *node);\n\n// Tipos: PascalCase\ntypedef struct Value Value;\ntypedef enum ValueType ValueType;\n\n// Constantes: maisculas com underscores\n#define MAX_BUFFER_SIZE 4096\n\n// Variveis: minsculas com underscores\nint item_count;\nValue *current_value;\n\n// Enums: TYPE_PREFIX_NAME\ntypedef enum {\n    TYPE_I32,\n    TYPE_STRING,\n    TYPE_OBJECT\n} ValueType;\n```\n\n**Comentrios:**\n```c\n// Comentrios de linha nica para explicaes breves\n// Use frases completas e capitalizao correta\n\n/*\n * Comentrios de mltiplas linhas para explicaes mais longas\n * Alinhe os asteriscos para melhor legibilidade\n */\n\n/**\n * Comentrio de documentao de funo\n * @param node - N AST a ser avaliado\n * @return Valor avaliado\n */\nValue eval_expr(ASTNode *node);\n```\n\n**Tratamento de Erros:**\n```c\n// Verificar todas as chamadas malloc\nchar *buffer = malloc(size);\nif (!buffer) {\n    fprintf(stderr, \"Error: Out of memory\\n\");\n    exit(1);\n}\n\n// Fornecer contexto nas mensagens de erro\nif (file == NULL) {\n    fprintf(stderr, \"Error: Failed to open '%s': %s\\n\",\n            filename, strerror(errno));\n    exit(1);\n}\n\n// Usar mensagens de erro significativas\n// Ruim: Error: Invalid value\n// Bom: Error: Expected integer, got string\n```\n\n**Gerenciamento de Memria:**\n```c\n// Sempre liberar memria que voc alocou\nValue *val = value_create_i32(42);\n// ... usar val\nvalue_free(val);\n\n// Definir ponteiros como NULL aps liberar (previne double free)\nfree(ptr);\nptr = NULL;\n\n// Documentar ownership em comentrios\n// Esta funo assume ownership de 'value' e ir liber-lo\nvoid store_value(Value *value);\n\n// Esta funo no assume ownership (chamador deve liberar)\nValue *get_value(void);\n```\n\n### Organizao de Cdigo\n\n**Estrutura de Arquivos:**\n```c\n// 1. Includes (headers de sistema primeiro, depois locais)\n#include <stdio.h>\n#include <stdlib.h>\n#include \"internal.h\"\n#include \"values.h\"\n\n// 2. Constantes e macros\n#define INITIAL_CAPACITY 16\n\n// 3. Definies de tipos\ntypedef struct Foo Foo;\n\n// 4. Declaraes de funes estticas (helpers internos)\nstatic void helper_function(void);\n\n// 5. Implementao de funes pblicas\nvoid public_api_function(void)\n{\n    // Implementao\n}\n\n// 6. Implementao de funes estticas\nstatic void helper_function(void)\n{\n    // Implementao\n}\n```\n\n**Arquivos Header:**\n```c\n// Usar include guards\n#ifndef HEMLOCK_MODULE_H\n#define HEMLOCK_MODULE_H\n\n// Declaraes forward\ntypedef struct Value Value;\n\n// Apenas API pblica em headers\nvoid public_function(Value *val);\n\n// Documentar parmetros e valores de retorno\n/**\n * Avalia n AST de expresso\n * @param node - N AST a ser avaliado\n * @param env - Ambiente atual\n * @return Valor resultante\n */\nValue *eval_expr(ASTNode *node, Environment *env);\n\n#endif // HEMLOCK_MODULE_H\n```\n\n---\n\n## O que Contribuir\n\n### Contribuies Encorajadas\n\n**Correes de Bugs:**\n- Vazamentos de memria\n- Segfaults\n- Comportamento incorreto\n- Melhorias em mensagens de erro\n\n**Documentao:**\n- Comentrios de cdigo\n- Documentao de API\n- Guias de usurio e tutoriais\n- Programas de exemplo\n- Documentao de casos de teste\n\n**Testes:**\n- Casos de teste adicionais para recursos existentes\n- Cobertura de casos de borda\n- Testes de regresso para bugs corrigidos\n- Benchmarks de performance\n\n**Pequenas Adies de Recursos:**\n- Novas funes builtin (se alinhadas com a filosofia)\n- Mtodos de string/array\n- Funes utilitrias\n- Melhorias no tratamento de erros\n\n**Melhorias de Performance:**\n- Algoritmos mais rpidos (sem mudar semntica)\n- Reduo de uso de memria\n- Sute de benchmarks\n- Ferramentas de profiling\n\n**Ferramentas:**\n- Syntax highlighting para editores\n- Language Server Protocol (LSP)\n- Integrao com debugger\n- Melhorias no sistema de build\n\n### Discutir Primeiro\n\n**Recursos Maiores:**\n- Novas construes de linguagem\n- Mudanas no sistema de tipos\n- Adies de sintaxe\n- Primitivas de concorrncia\n\n**Como Discutir:**\n1. Abrir issue ou discussion no GitHub\n2. Descrever o recurso e justificativa\n3. Mostrar cdigo de exemplo\n4. Explicar como se alinha com a filosofia do Hemlock\n5. Aguardar feedback dos mantenedores\n6. Iterar no design antes de implementar\n\n---\n\n## O que No Contribuir\n\n### Contribuies Desencorajadas\n\n**No adicione recursos que:**\n- Escondem complexidade do usurio\n- Tornam comportamento implcito ou mgico\n- Quebram semntica ou sintaxe existente\n- Adicionam coleta de lixo ou gerenciamento automtico de memria\n- Violam o princpio \"explcito  melhor que implcito\"\n\n**Exemplos de contribuies que sero rejeitadas:**\n\n**1. Insero Automtica de Ponto e Vrgula**\n```hemlock\n// Ruim: isso ser rejeitado\nlet x = 5  // Sem ponto e vrgula\nlet y = 10 // Sem ponto e vrgula\n```\nMotivo: Torna sintaxe ambgua, esconde erros\n\n**2. RAII/Destrutores**\n```hemlock\n// Ruim: isso ser rejeitado\nlet f = open(\"file.txt\");\n// Arquivo fechado automaticamente ao sair do escopo\n```\nMotivo: Esconde quando recursos so liberados, no  explcito o suficiente\n\n**3. Converses de Tipo Implcitas com Perda de Dados**\n```hemlock\n// Ruim: isso ser rejeitado\nlet x: i32 = 3.14;  // Trunca silenciosamente para 3\n```\nMotivo: Perda de dados deveria ser explcita, no silenciosa\n\n**4. Coleta de Lixo**\n```c\n// Ruim: isso ser rejeitado\nvoid *gc_malloc(size_t size) {\n    // Rastrear alocaes para limpeza automtica\n}\n```\nMotivo: Esconde gerenciamento de memria, performance imprevisvel\n\n**5. Sistema de Macros Complexo**\n```hemlock\n// Ruim: isso ser rejeitado\nmacro repeat($n, $block) {\n    for (let i = 0; i < $n; i++) $block\n}\n```\nMotivo: Muita mgica, torna cdigo difcil de raciocinar\n\n### Motivos Comuns de Rejeio\n\n**\"Isso  muito implcito\"**\n- Soluo: Tornar comportamento explcito e documentar\n\n**\"Isso esconde complexidade\"**\n- Soluo: Expor complexidade mas torn-la ergonmica\n\n**\"Isso quebra cdigo existente\"**\n- Soluo: Encontrar alternativa no-breaking ou discutir versionamento\n\n**\"Isso no se alinha com a filosofia do Hemlock\"**\n- Soluo: Reler philosophy.md e reconsiderar abordagem\n\n---\n\n## Padres Comuns\n\n### Padro de Tratamento de Erros\n\n```c\n// Use este padro para erros recuperveis em cdigo Hemlock\nValue *divide(Value *a, Value *b)\n{\n    // Verificar pr-condies\n    if (b->type != TYPE_I32) {\n        // Retornar valor de erro ou lanar exceo\n        return create_error(\"Expected integer divisor\");\n    }\n\n    if (b->i32_value == 0) {\n        return create_error(\"Division by zero\");\n    }\n\n    // Executar operao\n    return value_create_i32(a->i32_value / b->i32_value);\n}\n```\n\n### Padro de Gerenciamento de Memria\n\n```c\n// Padro: alocar, usar, liberar\nvoid process_data(void)\n{\n    // Alocar\n    Buffer *buf = create_buffer(1024);\n    char *str = malloc(256);\n\n    // Usar\n    if (buf && str) {\n        // ... fazer trabalho\n    }\n\n    // Liberar (na ordem reversa da alocao)\n    free(str);\n    free_buffer(buf);\n}\n```\n\n### Padro de Criao de Valores\n\n```c\n// Usar construtores para criar valores\nValue *create_integer(int32_t n)\n{\n    Value *val = malloc(sizeof(Value));\n    if (!val) {\n        fprintf(stderr, \"Out of memory\\n\");\n        exit(1);\n    }\n\n    val->type = TYPE_I32;\n    val->i32_value = n;\n    return val;\n}\n```\n\n### Padro de Verificao de Tipos\n\n```c\n// Verificar tipos antes de operaes\nValue *add_values(Value *a, Value *b)\n{\n    // Verificao de tipos\n    if (a->type != TYPE_I32 || b->type != TYPE_I32) {\n        return create_error(\"Type mismatch\");\n    }\n\n    // Pode prosseguir com segurana\n    return value_create_i32(a->i32_value + b->i32_value);\n}\n```\n\n### Padro de Construo de Strings\n\n```c\n// Construir strings eficientemente\nvoid build_error_message(char *buffer, size_t size, const char *detail)\n{\n    snprintf(buffer, size, \"Error: %s (line %d)\", detail, line_number);\n}\n```\n\n---\n\n## Adicionando Novos Recursos\n\n### Checklist de Adio de Recursos\n\nAo adicionar um novo recurso, por favor siga estes passos:\n\n#### 1. Fase de Design\n\n- [ ] Ler philosophy.md para garantir alinhamento\n- [ ] Criar issue no GitHub descrevendo o recurso\n- [ ] Obter aprovao dos mantenedores no design\n- [ ] Escrever especificao (sintaxe, semntica, exemplos)\n- [ ] Considerar casos de borda e condies de erro\n\n#### 2. Fase de Implementao\n\n**Se adicionando construo de linguagem:**\n\n- [ ] Adicionar tipo de token em `lexer.h` (se necessrio)\n- [ ] Adicionar regra lxica em `lexer.c` (se necessrio)\n- [ ] Adicionar tipo de n AST em `ast.h`\n- [ ] Adicionar construtor AST em `ast.c`\n- [ ] Adicionar regra de parsing em `parser.c`\n- [ ] Adicionar comportamento runtime em `runtime.c` ou mdulo apropriado\n- [ ] Tratar limpeza em funes de liberao de AST\n\n**Se adicionando funo builtin:**\n\n- [ ] Adicionar implementao da funo em `builtins.c`\n- [ ] Registrar funo em `register_builtins()`\n- [ ] Tratar todas as combinaes de tipos de argumentos\n- [ ] Retornar valores de erro apropriados\n- [ ] Documentar parmetros e tipos de retorno\n\n**Se adicionando tipo de valor:**\n\n- [ ] Adicionar enum de tipo em `values.h`\n- [ ] Adicionar campo  union Value\n- [ ] Adicionar construtor em `values.c`\n- [ ] Adicionar a `value_free()` para limpeza\n- [ ] Adicionar a `value_copy()` para cpia\n- [ ] Adicionar a `value_to_string()` para impresso\n- [ ] Adicionar regras de promoo de tipo se numrico\n\n#### 3. Fase de Testes\n\n- [ ] Escrever casos de teste (veja testing.md)\n- [ ] Testar casos de sucesso\n- [ ] Testar casos de erro\n- [ ] Testar casos de borda\n- [ ] Executar sute de testes completa (`make test`)\n- [ ] Verificar vazamentos de memria com valgrind\n- [ ] Testar em mltiplas plataformas (se possvel)\n\n#### 4. Fase de Documentao\n\n- [ ] Atualizar CLAUDE.md com documentao voltada ao usurio\n- [ ] Adicionar comentrios de cdigo explicando implementao\n- [ ] Criar exemplos em `examples/`\n- [ ] Atualizar arquivos docs/ relevantes\n- [ ] Documentar quaisquer breaking changes\n\n#### 5. Fase de Submisso\n\n- [ ] Limpar cdigo de debug e comentrios\n- [ ] Verificar conformidade com estilo de cdigo\n- [ ] Rebase no main mais recente\n- [ ] Criar pull request com descrio detalhada\n- [ ] Responder ao feedback do code review\n\n### Exemplo: Adicionando Novo Operador\n\nVamos usar o exemplo de adicionar o operador mdulo `%`:\n\n**1. Lexer (lexer.c):**\n```c\n// Adicionar ao switch statement em get_next_token()\ncase '%':\n    return create_token(TOKEN_PERCENT, \"%\", line);\n```\n\n**2. Header do Lexer (lexer.h):**\n```c\ntypedef enum {\n    // ... tokens existentes\n    TOKEN_PERCENT,\n    // ...\n} TokenType;\n```\n\n**3. AST (ast.h):**\n```c\ntypedef enum {\n    // ... operadores existentes\n    OP_MOD,\n    // ...\n} BinaryOp;\n```\n\n**4. Parser (parser.c):**\n```c\n// Adicionar a parse_multiplicative() ou nvel de precedncia apropriado\nif (match(TOKEN_PERCENT)) {\n    BinaryOp op = OP_MOD;\n    ASTNode *right = parse_unary();\n    left = create_binary_op_node(op, left, right);\n}\n```\n\n**5. Runtime (runtime.c):**\n```c\n// Adicionar a eval_binary_op()\ncase OP_MOD:\n    // Verificao de tipos\n    if (left->type == TYPE_I32 && right->type == TYPE_I32) {\n        if (right->i32_value == 0) {\n            fprintf(stderr, \"Error: Modulo by zero\\n\");\n            exit(1);\n        }\n        return value_create_i32(left->i32_value % right->i32_value);\n    }\n    // ... tratar outras combinaes de tipos\n    break;\n```\n\n**6. Teste (tests/operators/modulo.hml):**\n```hemlock\n// Mdulo bsico\nprint(10 % 3);  // Expect: 2\n\n// Mdulo com negativos\nprint(-10 % 3); // Expect: -1\n\n// Caso de erro (deveria falhar)\n// print(10 % 0);  // Diviso por zero\n```\n\n**7. Documentao (CLAUDE.md):**\n```markdown\n### Operadores Aritmticos\n- `+` - Adio\n- `-` - Subtrao\n- `*` - Multiplicao\n- `/` - Diviso\n- `%` - Mdulo (resto)\n```\n\n---\n\n## Processo de Code Review\n\n### O que os Revisores Procuram\n\n**1. Corretude**\n- O cdigo faz o que diz fazer?\n- Casos de borda so tratados?\n- H vazamentos de memria?\n- Erros so tratados corretamente?\n\n**2. Alinhamento com Filosofia**\n- Isso est alinhado com os princpios de design do Hemlock?\n-  explcito ou implcito?\n- Esconde complexidade?\n\n**3. Qualidade de Cdigo**\n- O cdigo  legvel e manutenvel?\n- Nomes de variveis so descritivos?\n- Funes tm tamanho razovel?\n- H documentao suficiente?\n\n**4. Testes**\n- H casos de teste suficientes?\n- Testes cobrem caminhos de sucesso e falha?\n- Casos de borda so testados?\n\n**5. Documentao**\n- Documentao voltada ao usurio est atualizada?\n- Comentrios de cdigo so claros?\n- Exemplos so fornecidos?\n\n### Respondendo ao Feedback\n\n**Faa:**\n- Agradecer o tempo do revisor\n- Fazer perguntas de esclarecimento se no entender\n- Explicar seu raciocnio se discordar\n- Fazer mudanas solicitadas prontamente\n- Atualizar descrio do PR se escopo mudar\n\n**No faa:**\n- Levar crticas para o lado pessoal\n- Argumentar defensivamente\n- Ignorar feedback\n- Fazer force push em comentrios de review (exceto rebase)\n- Adicionar mudanas no relacionadas ao PR\n\n### Fazendo Seu PR Ser Aceito\n\n**Requisitos para merge:**\n- [ ] Todos os testes passam\n- [ ] Sem vazamentos de memria (valgrind limpo)\n- [ ] Aprovao de code review do mantenedor\n- [ ] Documentao atualizada\n- [ ] Guia de estilo de cdigo seguido\n- [ ] Alinhado com a filosofia do Hemlock\n\n**Timeline:**\n- PRs pequenos (correes de bugs): Geralmente revisados em poucos dias\n- PRs mdios (novos recursos): Pode levar 1-2 semanas\n- PRs grandes (mudanas maiores): Requer discusso extensa\n\n---\n\n## Recursos Adicionais\n\n### Recursos de Aprendizado\n\n**Entendendo Interpretadores:**\n- \"Crafting Interpreters\" por Robert Nystrom\n- \"Writing An Interpreter In Go\" por Thorsten Ball\n- \"Modern Compiler Implementation in C\" por Andrew Appel\n\n**Programao C:**\n- \"The C Programming Language\" por K&R\n- \"Expert C Programming\" por Peter van der Linden\n- \"C Interfaces and Implementations\" por David Hanson\n\n**Gerenciamento de Memria:**\n- Documentao do Valgrind\n- \"Understanding and Using C Pointers\" por Richard Reese\n\n### Comandos teis\n\n```bash\n# Build com smbolos de debug\nmake clean && make CFLAGS=\"-g -O0\"\n\n# Executar com valgrind\nvalgrind --leak-check=full ./hemlock script.hml\n\n# Executar categoria especfica de testes\n./tests/run_tests.sh tests/strings/\n\n# Gerar arquivo tags para navegao de cdigo\nctags -R .\n\n# Encontrar todos os TODO e FIXME\ngrep -rn \"TODO\\|FIXME\" src/ include/\n```\n\n---\n\n## Dvidas?\n\nSe voc tem perguntas sobre contribuir:\n\n1. Verificar documentao em `docs/`\n2. Pesquisar issues existentes no GitHub\n3. Perguntar no GitHub Discussions\n4. Abrir uma nova issue com sua pergunta\n\n**Obrigado por contribuir para o Hemlock!**\n"}, "Contribuio -> Testes": {"id": "contributing-testing", "content": "# Guia de Testes do Hemlock\n\nEste guia explica a filosofia de testes do Hemlock, como escrever testes e como executar a sute de testes.\n\n---\n\n## Sumrio\n\n- [Filosofia de Testes](#filosofia-de-testes)\n- [Estrutura da Sute de Testes](#estrutura-da-sute-de-testes)\n- [Executando Testes](#executando-testes)\n- [Escrevendo Testes](#escrevendo-testes)\n- [Categorias de Testes](#categorias-de-testes)\n- [Testes de Vazamento de Memria](#testes-de-vazamento-de-memria)\n- [Integrao Contnua](#integrao-contnua)\n- [Melhores Prticas](#melhores-prticas)\n\n---\n\n## Filosofia de Testes\n\n### Princpios Centrais\n\n**1. Desenvolvimento Orientado a Testes (TDD)**\n\nEscreva testes **antes** de implementar recursos:\n\n```\n1. Escrever um teste que falha\n2. Implementar o recurso\n3. Executar teste (deve passar)\n4. Refatorar se necessrio\n5. Repetir\n```\n\n**Benefcios:**\n- Garante que o recurso realmente funciona\n- Previne regresses\n- Documenta comportamento esperado\n- Torna refatorao mais segura\n\n**2. Cobertura Abrangente**\n\nTestar casos de sucesso e falha:\n\n```hemlock\n// Caso de sucesso\nlet x: u8 = 255;  // Deveria funcionar\n\n// Caso de falha\nlet y: u8 = 256;  // Deveria dar erro\n```\n\n**3. Testar Cedo e Frequentemente**\n\nExecutar testes:\n- Antes de commitar cdigo\n- Depois de fazer mudanas\n- Antes de submeter pull request\n- Durante code review\n\n**Regra:** Todos os testes devem passar antes do merge.\n\n### O que Testar\n\n**Sempre teste:**\n- Funcionalidade bsica (caminho feliz)\n- Condies de erro (caminho de exceo)\n- Casos de borda (condies limite)\n- Verificao e converso de tipos\n- Gerenciamento de memria (sem vazamentos)\n- Concorrncia e condies de corrida\n\n**Exemplo de cobertura de testes:**\n```hemlock\n// Recurso: String.substr(start, length)\n\n// Caminho feliz\nprint(\"hello\".substr(0, 5));  // \"hello\"\n\n// Casos de borda\nprint(\"hello\".substr(0, 0));  // \"\" (vazio)\nprint(\"hello\".substr(5, 0));  // \"\" (no final)\nprint(\"hello\".substr(2, 100)); // \"llo\" (alm do final)\n\n// Casos de erro\n// \"hello\".substr(-1, 5);  // Erro: ndice negativo\n// \"hello\".substr(0, -1);  // Erro: comprimento negativo\n```\n\n---\n\n## Estrutura da Sute de Testes\n\n### Organizao de Diretrios\n\n```\ntests/\n run_tests.sh          # Script principal de execuo de testes\n primitives/           # Testes do sistema de tipos\n    integers.hml\n    floats.hml\n    booleans.hml\n    i64.hml\n    u64.hml\n conversions/          # Testes de converso de tipos\n    int_to_float.hml\n    promotion.hml\n    rune_conversions.hml\n memory/               # Testes de ponteiro/buffer\n    alloc.hml\n    buffer.hml\n    memcpy.hml\n strings/              # Testes de manipulao de strings\n    concat.hml\n    methods.hml\n    utf8.hml\n    runes.hml\n control/              # Testes de fluxo de controle\n    if.hml\n    switch.hml\n    while.hml\n functions/            # Testes de funes e closures\n    basics.hml\n    closures.hml\n    recursion.hml\n objects/              # Testes de objetos\n    literals.hml\n    methods.hml\n    duck_typing.hml\n    serialization.hml\n arrays/               # Testes de operaes de arrays\n    basics.hml\n    methods.hml\n    slicing.hml\n loops/                # Testes de loops\n    for.hml\n    while.hml\n    break.hml\n    continue.hml\n exceptions/           # Testes de tratamento de erros\n    try_catch.hml\n    finally.hml\n    throw.hml\n io/                   # Testes de I/O de arquivos\n    file_object.hml\n    read_write.hml\n    seek.hml\n async/                # Testes de concorrncia\n    spawn_join.hml\n    channels.hml\n    exceptions.hml\n ffi/                  # Testes de FFI\n    basic_call.hml\n    types.hml\n    dlopen.hml\n signals/              # Testes de tratamento de sinais\n    basic.hml\n    handlers.hml\n    raise.hml\n args/                 # Testes de argumentos de linha de comando\n     basic.hml\n```\n\n### Nomenclatura de Arquivos de Teste\n\n**Convenes:**\n- Usar nomes descritivos: `method_chaining.hml` ao invs de `test1.hml`\n- Agrupar testes relacionados: `string_substr.hml`, `string_slice.hml`\n- Uma rea funcional por arquivo\n- Manter arquivos focados e pequenos\n\n---\n\n## Executando Testes\n\n### Executar Todos os Testes\n\n```bash\n# Do diretrio raiz do hemlock\nmake test\n\n# Ou diretamente\n./tests/run_tests.sh\n```\n\n**Sada:**\n```\nRunning tests in tests/primitives/...\n   integers.hml\n   floats.hml\n   booleans.hml\n\nRunning tests in tests/strings/...\n   concat.hml\n   methods.hml\n\n...\n\nTotal: 251 tests\nPassed: 251\nFailed: 0\n```\n\n### Executar Categoria Especfica\n\n```bash\n# Apenas testes de strings\n./tests/run_tests.sh tests/strings/\n\n# Apenas um arquivo de teste\n./tests/run_tests.sh tests/strings/concat.hml\n\n# Mltiplas categorias\n./tests/run_tests.sh tests/strings/ tests/arrays/\n```\n\n### Executar com Valgrind (Verificao de Vazamento de Memria)\n\n```bash\n# Verificar vazamentos em um nico teste\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\n\n# Verificar todos os testes (muito lento!)\nfor test in tests/**/*.hml; do\n    echo \"Testing $test\"\n    valgrind --leak-check=full --error-exitcode=1 ./hemlock \"$test\"\ndone\n```\n\n### Debugando Testes que Falham\n\n```bash\n# Executar com sada verbosa\n./hemlock tests/failing_test.hml\n\n# Executar com gdb\ngdb --args ./hemlock tests/failing_test.hml\n(gdb) run\n(gdb) backtrace  # Se crashar\n```\n\n---\n\n## Escrevendo Testes\n\n### Formato de Arquivo de Teste\n\nArquivos de teste so simplesmente programas Hemlock com sada esperada:\n\n**Exemplo: tests/primitives/integers.hml**\n```hemlock\n// Testar literais inteiros bsicos\nlet x = 42;\nprint(x);  // Expect: 42\n\nlet y: i32 = 100;\nprint(y);  // Expect: 100\n\n// Testar aritmtica\nlet sum = x + y;\nprint(sum);  // Expect: 142\n\n// Testar inferncia de tipos\nlet small = 10;\nprint(typeof(small));  // Expect: i32\n\nlet large = 5000000000;\nprint(typeof(large));  // Expect: i64\n```\n\n**Como os testes funcionam:**\n1. O executor de testes executa o arquivo .hml\n2. Captura sada stdout\n3. Compara com sada esperada (de comentrios ou arquivo .out separado)\n4. Reporta passou/falhou\n\n### Mtodos de Sada Esperada\n\n**Mtodo 1: Comentrios Inline (recomendado para testes simples)**\n\n```hemlock\nprint(\"hello\");  // Expect: hello\nprint(42);       // Expect: 42\n```\n\nO executor de testes faz parse de comentrios `// Expect: ...`.\n\n**Mtodo 2: Arquivo .out Separado**\n\nCriar `test_name.hml.out` com sada esperada:\n\n**test_name.hml:**\n```hemlock\nprint(\"line 1\");\nprint(\"line 2\");\nprint(\"line 3\");\n```\n\n**test_name.hml.out:**\n```\nline 1\nline 2\nline 3\n```\n\n### Testando Casos de Erro\n\nTestes de erro devem fazer o programa sair com status no-zero:\n\n**Exemplo: tests/primitives/range_error.hml**\n```hemlock\n// Isso deveria falhar com erro de tipo\nlet x: u8 = 256;  // Fora do intervalo de u8\n```\n\n**Comportamento esperado:**\n- Programa sai com status no-zero\n- Imprime mensagem de erro em stderr\n\n**Tratamento do executor de testes:**\n- Testes esperados a dar erro devem estar em arquivos separados\n- Usar conveno de nomenclatura: `*_error.hml` ou `*_fail.hml`\n- Documentar erro esperado em comentrio\n\n### Testando Casos de Sucesso\n\n**Exemplo: tests/strings/methods.hml**\n```hemlock\n// Testar substr\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);\nprint(sub);  // Expect: world\n\n// Testar find\nlet pos = s.find(\"world\");\nprint(pos);  // Expect: 6\n\n// Testar contains\nlet has = s.contains(\"lo\");\nprint(has);  // Expect: true\n\n// Testar trim\nlet padded = \"  hello  \";\nlet trimmed = padded.trim();\nprint(trimmed);  // Expect: hello\n```\n\n### Testando Casos de Borda\n\n**Exemplo: tests/arrays/edge_cases.hml**\n```hemlock\n// Array vazio\nlet empty = [];\nprint(empty.length);  // Expect: 0\n\n// nico elemento\nlet single = [42];\nprint(single[0]);  // Expect: 42\n\n// ndice negativo (deveria dar erro em arquivo de teste separado)\n// print(single[-1]);  // Erro\n\n// ndice alm do final (deveria dar erro)\n// print(single[100]);  // Erro\n\n// Condies de borda\nlet arr = [1, 2, 3];\nprint(arr.slice(0, 0));  // Expect: [] (vazio)\nprint(arr.slice(3, 3));  // Expect: [] (vazio)\nprint(arr.slice(1, 2));  // Expect: [2]\n```\n\n### Testando Sistema de Tipos\n\n**Exemplo: tests/conversions/promotion.hml**\n```hemlock\n// Testar promoo de tipos em operaes binrias\n\n// i32 + i64 -> i64\nlet a: i32 = 10;\nlet b: i64 = 20;\nlet c = a + b;\nprint(typeof(c));  // Expect: i64\n\n// i32 + f32 -> f32\nlet d: i32 = 10;\nlet e: f32 = 3.14;\nlet f = d + e;\nprint(typeof(f));  // Expect: f32\n\n// u8 + i32 -> i32\nlet g: u8 = 5;\nlet h: i32 = 10;\nlet i = g + h;\nprint(typeof(i));  // Expect: i32\n```\n\n### Testando Concorrncia\n\n**Exemplo: tests/async/basic.hml**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn tasks\nlet t1 = spawn(compute, 10);\nlet t2 = spawn(compute, 20);\n\n// Esperar e imprimir resultados\nlet r1 = join(t1);\nlet r2 = join(t2);\nprint(r1);  // Expect: 45\nprint(r2);  // Expect: 190\n```\n\n### Testando Excees\n\n**Exemplo: tests/exceptions/try_catch.hml**\n```hemlock\n// Testar try/catch bsico\ntry {\n    throw \"error message\";\n} catch (e) {\n    print(\"Caught: \" + e);  // Expect: Caught: error message\n}\n\n// Testar finally\nlet executed = false;\ntry {\n    print(\"try\");  // Expect: try\n} finally {\n    executed = true;\n    print(\"finally\");  // Expect: finally\n}\n\n// Testar propagao de exceo\nfn risky(): i32 {\n    throw \"failure\";\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(e);  // Expect: failure\n}\n```\n\n---\n\n## Categorias de Testes\n\n### Testes de Tipos Primitivos\n\n**O que testar:**\n- Tipos inteiros (i8, i16, i32, i64, u8, u16, u32, u64)\n- Tipos de ponto flutuante (f32, f64)\n- Tipo booleano\n- Tipo string\n- Tipo rune\n- Tipo null\n\n**reas de exemplo:**\n- Sintaxe de literais\n- Inferncia de tipos\n- Verificao de intervalos\n- Comportamento de overflow\n- Anotaes de tipo\n\n### Testes de Converses\n\n**O que testar:**\n- Promoo de tipos implcita\n- Converso de tipos explcita\n- Converses com perda (deveriam dar erro)\n- Promoo de tipos em operaes\n- Comparaes entre tipos\n\n### Testes de Memria\n\n**O que testar:**\n- Corretude de alloc/free\n- Criao e acesso de Buffer\n- Verificao de limites de buffer\n- memset, memcpy, realloc\n- Deteco de vazamento de memria (valgrind)\n\n### Testes de Strings\n\n**O que testar:**\n- Concatenao\n- Todos os 18 mtodos de string\n- Tratamento de UTF-8\n- Indexao de runes\n- Concatenao string + rune\n- Casos de borda (string vazia, nico caractere, etc.)\n\n### Testes de Fluxo de Controle\n\n**O que testar:**\n- if/else/else if\n- Loops while\n- Loops for\n- Statements switch\n- break/continue\n- Statements return\n\n### Testes de Funes\n\n**O que testar:**\n- Definio e chamada de funes\n- Passagem de parmetros\n- Valores de retorno\n- Recurso\n- Closures e captura\n- Funes de primeira classe\n- Funes annimas\n\n### Testes de Objetos\n\n**O que testar:**\n- Literais de objeto\n- Acesso e atribuio de campos\n- Mtodos e binding de self\n- Duck typing\n- Campos opcionais\n- Serializao/deserializao JSON\n- Deteco de referncia circular\n\n### Testes de Arrays\n\n**O que testar:**\n- Criao de arrays\n- Indexao e atribuio\n- Todos os 15 mtodos de array\n- Tipos misturados\n- Redimensionamento dinmico\n- Casos de borda (vazio, nico elemento)\n\n### Testes de Excees\n\n**O que testar:**\n- try/catch/finally\n- Statement throw\n- Propagao de excees\n- try/catch aninhado\n- return em try/catch/finally\n- Excees no capturadas\n\n### Testes de I/O\n\n**O que testar:**\n- Modos de abertura de arquivo\n- Operaes de leitura/escrita\n- Seek/tell\n- Atributos de arquivo\n- Tratamento de erros (arquivo faltando, etc.)\n- Limpeza de recursos\n\n### Testes de Async\n\n**O que testar:**\n- spawn/join/detach\n- Channel send/recv\n- Propagao de excees em tasks\n- Mltiplas tasks concorrentes\n- Comportamento de bloqueio de channels\n\n### Testes de FFI\n\n**O que testar:**\n- dlopen/dlclose\n- dlsym\n- dlcall com vrios tipos\n- Converso de tipos\n- Tratamento de erros\n\n---\n\n## Testes de Vazamento de Memria\n\n### Usando Valgrind\n\n**Uso bsico:**\n```bash\nvalgrind --leak-check=full ./hemlock test.hml\n```\n\n**Exemplo de sada (sem vazamentos):**\n```\n==12345== HEAP SUMMARY:\n==12345==     in use at exit: 0 bytes in 0 blocks\n==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated\n==12345==\n==12345== All heap blocks were freed -- no leaks are possible\n```\n\n**Exemplo de sada (com vazamentos):**\n```\n==12345== LEAK SUMMARY:\n==12345==    definitely lost: 64 bytes in 1 blocks\n==12345==    indirectly lost: 0 bytes in 0 blocks\n==12345==      possibly lost: 0 bytes in 0 blocks\n==12345==    still reachable: 0 bytes in 0 blocks\n==12345==         suppressed: 0 bytes in 0 blocks\n```\n\n### Fontes Comuns de Vazamentos\n\n**1. Chamadas free() faltando:**\n```c\n// Ruim\nchar *str = malloc(100);\n// ... usar str\n// Esqueceu de liberar!\n\n// Bom\nchar *str = malloc(100);\n// ... usar str\nfree(str);\n```\n\n**2. Ponteiros perdidos:**\n```c\n// Ruim\nchar *ptr = malloc(100);\nptr = malloc(200);  // Perdeu referncia para primeira alocao!\n\n// Bom\nchar *ptr = malloc(100);\nfree(ptr);\nptr = malloc(200);\n```\n\n**3. Caminhos de exceo:**\n```c\n// Ruim\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        return;  // Vazamento!\n    }\n    free(data);\n}\n\n// Bom\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        free(data);\n        return;\n    }\n    free(data);\n}\n```\n\n### Vazamentos Conhecidos e Aceitveis\n\nAlguns pequenos \"vazamentos\" so alocaes de inicializao intencionais:\n\n**Builtins globais:**\n```hemlock\n// Funes builtin, tipos FFI e constantes so alocados na inicializao\n// e no so liberados na sada (geralmente ~200 bytes)\n```\n\nEstes no so vazamentos reais - so alocaes nicas que duram toda a vida do programa e so limpas pelo SO na sada.\n\n---\n\n## Integrao Contnua\n\n### GitHub Actions (Futuro)\n\nUma vez que CI esteja configurado, todos os testes executaro automaticamente em:\n- Push para branch main\n- Criao/atualizao de Pull Request\n- Execuo agendada diria\n\n**Workflow de CI:**\n1. Build do Hemlock\n2. Executar sute de testes\n3. Verificar vazamentos de memria (valgrind)\n4. Reportar resultados no PR\n\n### Verificaes Pr-Commit\n\nAntes de commitar, execute:\n\n```bash\n# Build limpo\nmake clean && make\n\n# Executar todos os testes\nmake test\n\n# Verificar vazamentos em alguns testes\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\nvalgrind --leak-check=full ./hemlock tests/strings/concat.hml\n```\n\n---\n\n## Melhores Prticas\n\n### Faa\n\n**Escreva testes primeiro (TDD)**\n```bash\n1. Criar tests/feature/new_feature.hml\n2. Implementar recurso em src/\n3. Executar testes at passar\n```\n\n**Teste casos de sucesso e falha**\n```hemlock\n// Sucesso: tests/feature/success.hml\nlet result = do_thing();\nprint(result);  // Expect: expected value\n\n// Falha: tests/feature/failure.hml\ndo_invalid_thing();  // Deveria dar erro\n```\n\n**Use nomes de teste descritivos**\n```\nBom: tests/strings/substr_utf8_boundary.hml\nRuim: tests/test1.hml\n```\n\n**Mantenha testes focados**\n- Uma rea funcional por arquivo\n- Setup e assertivas claras\n- Cdigo mnimo\n\n**Adicione comentrios explicando testes complicados**\n```hemlock\n// Testar que closures capturam variveis externas por referncia\nfn outer() {\n    let x = 10;\n    let f = fn() { return x; };\n    x = 20;  // Modificar aps criao da closure\n    return f();  // Deveria retornar 20, no 10\n}\n```\n\n**Teste casos de borda**\n- Entradas vazias\n- Valores null\n- Valores de fronteira (min/max)\n- Entradas grandes\n- Valores negativos\n\n### No Faa\n\n**No pule testes**\n- Todos os testes devem passar antes do merge\n- No comente testes que falham\n- Corrija o bug ou remova o recurso\n\n**No escreva testes que dependem uns dos outros**\n```hemlock\n// Ruim: test2.hml depende da sada de test1.hml\n// Testes devem ser independentes\n```\n\n**No use valores aleatrios em testes**\n```hemlock\n// Ruim: no-determinstico\nlet x = random();\nprint(x);  // No pode prever sada\n\n// Bom: determinstico\nlet x = 42;\nprint(x);  // Expect: 42\n```\n\n**No teste detalhes de implementao**\n```hemlock\n// Ruim: testa estrutura interna\nlet obj = { x: 10 };\n// No verifique ordem interna de campos, capacidade, etc.\n\n// Bom: testa comportamento\nprint(obj.x);  // Expect: 10\n```\n\n**No ignore vazamentos de memria**\n- Todos os testes devem estar limpos no valgrind\n- Documente vazamentos conhecidos/aceitveis\n- Corrija vazamentos antes do merge\n\n### Manuteno de Testes\n\n**Quando atualizar testes:**\n- Comportamento de recurso muda\n- Correo de bug precisa de novo caso de teste\n- Caso de borda  descoberto\n- Melhorias de performance\n\n**Quando remover testes:**\n- Recurso  removido da linguagem\n- Teste duplica cobertura existente\n- Teste est incorreto\n\n**Refatorando testes:**\n- Agrupar testes relacionados juntos\n- Extrair cdigo de setup comum\n- Usar nomenclatura consistente\n- Manter testes simples e legveis\n\n---\n\n## Exemplo de Sesso de Teste\n\nAqui est um exemplo completo de adicionar um recurso com testes:\n\n### Recurso: Adicionar Mtodo `array.first()`\n\n**1. Escrever teste primeiro:**\n\n```bash\n# Criar arquivo de teste\ncat > tests/arrays/first_method.hml << 'EOF'\n// Testar mtodo array.first()\n\n// Caso bsico\nlet arr = [1, 2, 3];\nprint(arr.first());  // Expect: 1\n\n// nico elemento\nlet single = [42];\nprint(single.first());  // Expect: 42\n\n// Array vazio (deveria dar erro - arquivo de teste separado)\n// let empty = [];\n// print(empty.first());  // Erro\nEOF\n```\n\n**2. Executar teste (deveria falhar):**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n# Error: Method 'first' not found on array\n```\n\n**3. Implementar recurso:**\n\nEditar `src/interpreter/builtins.c`:\n\n```c\n// Adicionar mtodo array_first\nValue *array_first(Value *self, Value **args, int arg_count)\n{\n    if (self->array_value->length == 0) {\n        fprintf(stderr, \"Error: Cannot get first element of empty array\\n\");\n        exit(1);\n    }\n\n    return value_copy(&self->array_value->elements[0]);\n}\n\n// Registrar na tabela de mtodos de array\n// ... adicionar ao registro de mtodos de array\n```\n\n**4. Executar teste (deveria passar):**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n1\n42\n# Sucesso!\n```\n\n**5. Verificar vazamentos de memria:**\n\n```bash\nvalgrind --leak-check=full ./hemlock tests/arrays/first_method.hml\n# All heap blocks were freed -- no leaks are possible\n```\n\n**6. Executar sute de testes completa:**\n\n```bash\nmake test\n# Total: 252 tests (251 + novo)\n# Passed: 252\n# Failed: 0\n```\n\n**7. Commitar:**\n\n```bash\ngit add tests/arrays/first_method.hml src/interpreter/builtins.c\ngit commit -m \"Add array.first() method with tests\"\n```\n\n---\n\n## Resumo\n\n**Lembre-se:**\n- Escrever testes primeiro (TDD)\n- Testar casos de sucesso e falha\n- Executar todos os testes antes de commitar\n- Verificar vazamentos de memria\n- Documentar problemas conhecidos\n- Manter testes simples e focados\n\n**Qualidade de testes  to importante quanto qualidade de cdigo!**\n"}, "hpm: Primeiros Passos -> Configurao do Projeto": {"id": "hpm-project-setup", "content": "# Configuracao do Projeto\n\nGuia completo para configurar projetos Hemlock com hpm.\n\n## Criando um Novo Projeto\n\n### Configuracao Basica\n\nCrie um novo projeto do zero:\n\n```bash\n# Criar diretorio do projeto\nmkdir my-project\ncd my-project\n\n# Inicializar package.json\nhpm init\n\n# Criar estrutura de diretorios\nmkdir -p src test\n```\n\n### Templates de Projeto\n\nAqui estao estruturas de projeto comuns para diferentes casos de uso:\n\n#### Biblioteca de Pacotes\n\nPara bibliotecas reutilizaveis:\n\n```\nmy-library/\n package.json\n README.md\n LICENSE\n src/\n    index.hml          # Entrada principal, exporta API publica\n    core.hml           # Funcionalidade principal\n    utils.hml          # Funcoes utilitarias\n    types.hml          # Definicoes de tipos\n test/\n     framework.hml      # Framework de testes\n     run.hml            # Executor de testes\n     test_core.hml      # Testes\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-library\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A reusable Hemlock library\",\n  \"main\": \"src/index.hml\",\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {}\n}\n```\n\n#### Aplicacao\n\nPara aplicacoes standalone:\n\n```\nmy-app/\n package.json\n README.md\n src/\n    main.hml           # Ponto de entrada da aplicacao\n    config.hml         # Configuracao\n    commands/          # Comandos CLI\n       index.hml\n       run.hml\n    lib/               # Bibliotecas internas\n        utils.hml\n test/\n    run.hml\n data/                  # Arquivos de dados\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Hemlock application\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {}\n}\n```\n\n#### Aplicacao Web\n\nPara servidores web:\n\n```\nmy-web-app/\n package.json\n README.md\n src/\n    main.hml           # Ponto de entrada do servidor\n    routes/            # Handlers de rotas\n       index.hml\n       api.hml\n       auth.hml\n    middleware/        # Middleware\n       index.hml\n       auth.hml\n    models/            # Modelos de dados\n       user.hml\n    services/          # Logica de negocios\n        user.hml\n test/\n    run.hml\n static/                # Arquivos estaticos\n    css/\n    js/\n views/                 # Templates\n     index.hml\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-web-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Hemlock web application\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\",\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  }\n}\n```\n\n## Arquivo package.json\n\n### Campos Obrigatorios\n\n```json\n{\n  \"name\": \"owner/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n### Todos os Campos\n\n```json\n{\n  \"name\": \"yourusername/my-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Package description\",\n  \"author\": \"Your Name <you@example.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/yourusername/my-package\",\n  \"homepage\": \"https://yourusername.github.io/my-package\",\n  \"bugs\": \"https://github.com/yourusername/my-package/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"utility\", \"parser\"],\n  \"dependencies\": {\n    \"owner/package\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"owner/test-lib\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n### Referencia de Campos\n\n| Campo | Tipo | Descricao |\n|-------|------|-----------|\n| `name` | string | Nome do pacote no formato owner/repo (obrigatorio) |\n| `version` | string | Versao semantica (obrigatorio) |\n| `description` | string | Descricao curta |\n| `author` | string | Nome e email do autor |\n| `license` | string | Identificador da licenca (MIT, Apache-2.0, etc.) |\n| `repository` | string | URL do repositorio |\n| `homepage` | string | Pagina inicial do projeto |\n| `bugs` | string | URL do rastreador de issues |\n| `main` | string | Arquivo de ponto de entrada (padrao: src/index.hml) |\n| `keywords` | array | Palavras-chave para busca |\n| `dependencies` | object | Dependencias de tempo de execucao |\n| `devDependencies` | object | Dependencias de desenvolvimento |\n| `scripts` | object | Scripts nomeados |\n| `files` | array | Arquivos a incluir na publicacao |\n| `native` | object | Requisitos de bibliotecas nativas |\n\n## Arquivo package-lock.json\n\nO arquivo de lock e gerado automaticamente e deve ser commitado no controle de versao. Ele garante instalacoes reproduziveis.\n\n```json\n{\n  \"lockVersion\": 1,\n  \"hemlock\": \"1.0.0\",\n  \"dependencies\": {\n    \"hemlang/sprout\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz\",\n      \"integrity\": \"sha256-abc123...\",\n      \"dependencies\": {\n        \"hemlang/router\": \"^1.5.0\"\n      }\n    },\n    \"hemlang/router\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://github.com/hemlang/router/archive/v1.5.0.tar.gz\",\n      \"integrity\": \"sha256-def456...\",\n      \"dependencies\": {}\n    }\n  }\n}\n```\n\n### Melhores Praticas do Arquivo de Lock\n\n- **Comite** package-lock.json no controle de versao\n- **Nao edite manualmente** - e gerado automaticamente\n- **Execute `hpm install`** apos puxar alteracoes\n- **Delete e regenere** se corrompido:\n  ```bash\n  rm package-lock.json\n  hpm install\n  ```\n\n## Diretorio hem_modules\n\nPacotes instalados sao armazenados em `hem_modules/`:\n\n```\nhem_modules/\n hemlang/\n    sprout/\n       package.json\n       src/\n    router/\n        package.json\n        src/\n alice/\n     http-client/\n         package.json\n         src/\n```\n\n### Melhores Praticas do hem_modules\n\n- **Adicione ao .gitignore** - Nao comite dependencias\n- **Nao modifique** - Alteracoes serao sobrescritas\n- **Delete para reinstalar**:\n  ```bash\n  rm -rf hem_modules\n  hpm install\n  ```\n\n## .gitignore\n\n.gitignore recomendado para projetos Hemlock:\n\n```gitignore\n# Dependencias\nhem_modules/\n\n# Saida de build\ndist/\n*.hmlc\n\n# Arquivos de IDE\n.idea/\n.vscode/\n*.swp\n*.swo\n\n# Arquivos do OS\n.DS_Store\nThumbs.db\n\n# Logs\n*.log\nlogs/\n\n# Ambiente\n.env\n.env.local\n\n# Cobertura de testes\ncoverage/\n```\n\n## Trabalhando com Dependencias\n\n### Adicionando Dependencias\n\n```bash\n# Adicionar dependencia de tempo de execucao\nhpm install hemlang/json\n\n# Adicionar com restricao de versao\nhpm install hemlang/sprout@^2.0.0\n\n# Adicionar dependencia de desenvolvimento\nhpm install hemlang/test-utils --dev\n```\n\n### Importando Dependencias\n\n```hemlock\n// Importar de pacote (usa entrada \"main\")\nimport { parse, stringify } from \"hemlang/json\";\n\n// Importar de subcaminho\nimport { Router } from \"hemlang/sprout/router\";\n\n// Importar biblioteca padrao\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile, writeFile } from \"@stdlib/fs\";\n```\n\n### Resolucao de Imports\n\nO hpm resolve imports na seguinte ordem:\n\n1. **Biblioteca padrao**: Imports `@stdlib/*` carregam modulos embutidos\n2. **Raiz do pacote**: `owner/repo` usa o campo `main`\n3. **Subcaminho**: `owner/repo/path` verifica:\n   - `hem_modules/owner/repo/path.hml`\n   - `hem_modules/owner/repo/path/index.hml`\n   - `hem_modules/owner/repo/src/path.hml`\n   - `hem_modules/owner/repo/src/path/index.hml`\n\n## Scripts\n\n### Definindo Scripts\n\nAdicione scripts no package.json:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n### Executando Scripts\n\n```bash\nhpm run start\nhpm run dev\nhpm run build\n\n# Atalho para test\nhpm test\n\n# Passar argumentos\nhpm run test -- --verbose --filter=unit\n```\n\n### Convencoes de Nomeacao de Scripts\n\n| Script | Proposito |\n|--------|-----------|\n| `start` | Executar a aplicacao |\n| `dev` | Executar em modo de desenvolvimento |\n| `test` | Executar todos os testes |\n| `build` | Compilar para producao |\n| `clean` | Remover arquivos gerados |\n| `lint` | Verificar estilo de codigo |\n| `format` | Formatar codigo |\n\n## Fluxo de Trabalho de Desenvolvimento\n\n### Configuracao Inicial\n\n```bash\n# Clonar projeto\ngit clone https://github.com/yourusername/my-project.git\ncd my-project\n\n# Instalar dependencias\nhpm install\n\n# Executar testes\nhpm test\n\n# Iniciar desenvolvimento\nhpm run dev\n```\n\n### Fluxo de Trabalho Diario\n\n```bash\n# Puxar ultimas alteracoes\ngit pull\n\n# Instalar quaisquer novas dependencias\nhpm install\n\n# Fazer alteracoes...\n\n# Executar testes\nhpm test\n\n# Commitar\ngit add .\ngit commit -m \"Add feature\"\ngit push\n```\n\n### Adicionando Nova Funcionalidade\n\n```bash\n# Criar branch de feature\ngit checkout -b feature/new-feature\n\n# Adicionar novas dependencias se necessario\nhpm install hemlang/new-lib\n\n# Implementar funcionalidade...\n\n# Testar\nhpm test\n\n# Commitar e enviar\ngit add .\ngit commit -m \"Add new feature\"\ngit push -u origin feature/new-feature\n```\n\n## Configuracao Especifica por Ambiente\n\n### Usando Variaveis de Ambiente\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nlet db_host = getenv(\"DATABASE_HOST\") ?? \"localhost\";\nlet api_key = getenv(\"API_KEY\") ?? \"\";\n\nif api_key == \"\" {\n    print(\"Warning: API_KEY not set\");\n}\n```\n\n### Arquivo de Configuracao\n\n**config.hml:**\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nexport let config = {\n    environment: getenv(\"HEMLOCK_ENV\") ?? \"development\",\n    database: {\n        host: getenv(\"DB_HOST\") ?? \"localhost\",\n        port: int(getenv(\"DB_PORT\") ?? \"5432\"),\n        name: getenv(\"DB_NAME\") ?? \"myapp\"\n    },\n    server: {\n        port: int(getenv(\"PORT\") ?? \"3000\"),\n        host: getenv(\"HOST\") ?? \"0.0.0.0\"\n    }\n};\n\nexport fn is_production(): bool {\n    return config.environment == \"production\";\n}\n```\n\n## Veja Tambem\n\n- [Inicio Rapido](#hpm-project-setup-quick-start) - Introducao rapida\n- [Comandos](#hpm-project-setup-commands) - Referencia de comandos\n- [Criacao de Pacotes](#hpm-project-setup-creating-packages) - Publicar pacotes\n- [Configuracao](#hpm-project-setup-configuration) - Configuracao do hpm\n"}, "hpm: Primeiros Passos -> Instalao": {"id": "hpm-installation", "content": "# Instalacao\n\nEste guia explica como instalar o hpm no seu sistema.\n\n## Instalacao Rapida (Recomendada)\n\nInstale a versao mais recente com um unico comando:\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\nIsso automaticamente:\n- Detecta seu sistema operacional (Linux, macOS)\n- Detecta sua arquitetura (x86_64, arm64)\n- Baixa o binario pre-compilado correspondente\n- Instala em `/usr/local/bin` (usa sudo se necessario)\n\n### Opcoes de Instalacao\n\n```bash\n# Instalar em local personalizado (sem sudo)\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local\n\n# Instalar versao especifica\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5\n\n# Combinar opcoes\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5\n```\n\n### Plataformas Suportadas\n\n| Plataforma | Arquitetura | Status |\n|------------|-------------|--------|\n| Linux      | x86_64      | Suportado |\n| macOS      | x86_64      | Suportado |\n| macOS      | arm64 (M1/M2/M3) | Suportado |\n| Linux      | arm64       | Compilar do codigo-fonte |\n\n## Compilando do Codigo-Fonte\n\nSe voce prefere compilar do codigo-fonte, ou precisa de uma plataforma nao coberta pelos binarios pre-compilados, siga estas instrucoes.\n\n### Pre-requisitos\n\nO hpm requer que o [Hemlock](https://github.com/hemlang/hemlock) esteja instalado. Por favor, siga as instrucoes de instalacao do Hemlock primeiro.\n\nVerifique se o Hemlock esta instalado:\n\n```bash\nhemlock --version\n```\n\n## Metodos de Instalacao\n\n### Metodo 1: Make Install\n\nCompile e instale a partir do codigo-fonte.\n\n```bash\n# Clonar o repositorio\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Instalar em /usr/local/bin (requer sudo)\nsudo make install\n```\n\nApos a instalacao, verifique se esta funcionando:\n\n```bash\nhpm --version\n```\n\n### Metodo 2: Local Personalizado\n\nInstale em um diretorio personalizado (sem sudo):\n\n```bash\n# Clonar o repositorio\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Instalar em ~/.local/bin\nmake install PREFIX=$HOME/.local\n\n# Ou qualquer local personalizado\nmake install PREFIX=/opt/hemlock\n```\n\nCertifique-se de que seu diretorio bin personalizado esta no PATH:\n\n```bash\n# Adicionar ao ~/.bashrc ou ~/.zshrc\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n### Metodo 3: Executar Sem Instalar\n\nVoce pode executar o hpm diretamente sem instalar:\n\n```bash\n# Clonar o repositorio\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Criar script wrapper local\nmake\n\n# Executar do diretorio hpm\n./hpm --help\n\n# Ou executar diretamente via hemlock\nhemlock src/main.hml --help\n```\n\n### Metodo 4: Instalacao Manual\n\nCrie seu proprio script wrapper:\n\n```bash\n# Clonar para um local permanente\ngit clone https://github.com/hemlang/hpm.git ~/.hpm-source\n\n# Criar script wrapper\ncat > ~/.local/bin/hpm << 'EOF'\n#!/bin/sh\nexec hemlock \"$HOME/.hpm-source/src/main.hml\" \"$@\"\nEOF\n\nchmod +x ~/.local/bin/hpm\n```\n\n## Variaveis de Instalacao\n\nO Makefile suporta as seguintes variaveis:\n\n| Variavel | Padrao | Descricao |\n|----------|--------|-----------|\n| `PREFIX` | `/usr/local` | Prefixo de instalacao |\n| `BINDIR` | `$(PREFIX)/bin` | Diretorio de binarios |\n| `HEMLOCK` | `hemlock` | Caminho do interpretador hemlock |\n\nExemplo usando variaveis personalizadas:\n\n```bash\nmake install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock\n```\n\n## Como Funciona\n\nO instalador cria um script shell wrapper que invoca o interpretador Hemlock com o codigo-fonte do hpm:\n\n```bash\n#!/bin/sh\nexec hemlock \"/path/to/hpm/src/main.hml\" \"$@\"\n```\n\nEsta abordagem:\n- Nao requer compilacao\n- Sempre executa o codigo-fonte mais recente\n- Funciona de forma confiavel em todas as plataformas\n\n## Atualizando o hpm\n\nPara atualizar o hpm para a versao mais recente:\n\n```bash\ncd /path/to/hpm\ngit pull origin main\n\n# Reinstalar se o caminho mudou\nsudo make install\n```\n\n## Desinstalacao\n\nPara remover o hpm do sistema:\n\n```bash\ncd /path/to/hpm\nsudo make uninstall\n```\n\nOu remova manualmente:\n\n```bash\nsudo rm /usr/local/bin/hpm\n```\n\n## Verificando a Instalacao\n\nApos a instalacao, verifique se tudo esta funcionando:\n\n```bash\n# Verificar versao\nhpm --version\n\n# Ver ajuda\nhpm --help\n\n# Testar inicializacao (em um diretorio vazio)\nmkdir test-project && cd test-project\nhpm init --yes\ncat package.json\n```\n\n## Solucao de Problemas\n\n### \"hemlock: command not found\"\n\nO Hemlock nao esta instalado ou nao esta no PATH. Instale o Hemlock primeiro:\n\n```bash\n# Verificar se hemlock existe\nwhich hemlock\n\n# Se nao encontrado, instale o Hemlock de https://github.com/hemlang/hemlock\n```\n\n### \"Permission denied\"\n\nUse sudo para instalacao em todo o sistema, ou instale no diretorio do usuario:\n\n```bash\n# Opcao 1: Usar sudo\nsudo make install\n\n# Opcao 2: Instalar no diretorio do usuario\nmake install PREFIX=$HOME/.local\n```\n\n### \"hpm: command not found\" apos instalacao\n\nSeu PATH pode nao incluir o diretorio de instalacao:\n\n```bash\n# Verificar onde o hpm foi instalado\nls -la /usr/local/bin/hpm\n\n# Se usando local personalizado, adicionar ao PATH\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## Notas Especificas por Plataforma\n\n### Linux\n\nA instalacao padrao funciona em todas as distribuicoes Linux. Algumas distribuicoes podem precisar:\n\n```bash\n# Debian/Ubuntu: garantir que ferramentas de compilacao estao instaladas\nsudo apt-get install build-essential git\n\n# Fedora/RHEL\nsudo dnf install make git\n```\n\n### macOS\n\nA instalacao padrao funciona. Se usar Homebrew:\n\n```bash\n# Garantir que as ferramentas de linha de comando do Xcode estao instaladas\nxcode-select --install\n```\n\n### Windows (WSL)\n\nO hpm funciona no Windows Subsystem for Linux:\n\n```bash\n# No terminal WSL\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\nmake install PREFIX=$HOME/.local\n```\n\n## Proximos Passos\n\nApos a instalacao:\n\n1. [Inicio Rapido](#hpm-installation-quick-start) - Crie seu primeiro projeto\n2. [Referencia de Comandos](#hpm-installation-commands) - Aprenda todos os comandos\n3. [Configuracao](#hpm-installation-configuration) - Configure o hpm\n"}, "hpm: Primeiros Passos -> Incio Rpido": {"id": "hpm-quick-start", "content": "# Inicio Rapido\n\nComece a usar o hpm em 5 minutos.\n\n## Instalar o hpm\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\nVeja o [Guia de Instalacao](#hpm-quick-start-installation) para mais opcoes de instalacao.\n\n## Criar um Novo Projeto\n\nPrimeiro, crie um novo diretorio e inicialize o pacote:\n\n```bash\nmkdir my-project\ncd my-project\nhpm init\n```\n\nO sistema solicitara os detalhes do projeto:\n\n```\nPackage name (owner/repo): myname/my-project\nVersion (1.0.0):\nDescription: My awesome Hemlock project\nAuthor: Your Name <you@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\nUse `--yes` para aceitar todos os valores padrao:\n\n```bash\nhpm init --yes\n```\n\n## Estrutura do Projeto\n\nCrie a estrutura basica do projeto:\n\n```\nmy-project/\n package.json        # Manifesto do projeto\n src/\n    index.hml      # Ponto de entrada principal\n test/\n     test.hml       # Arquivo de testes\n```\n\nCrie o arquivo principal:\n\n```bash\nmkdir -p src test\n```\n\n**src/index.hml:**\n```hemlock\n// Ponto de entrada principal\nexport fn greet(name: string): string {\n    return \"Hello, \" + name + \"!\";\n}\n\nexport fn main() {\n    print(greet(\"World\"));\n}\n```\n\n## Instalar Dependencias\n\nPesquise pacotes no GitHub (pacotes usam o formato `owner/repo`):\n\n```bash\n# Instalar um pacote\nhpm install hemlang/sprout\n\n# Instalar com restricao de versao\nhpm install hemlang/json@^1.0.0\n\n# Instalar como dependencia de desenvolvimento\nhpm install hemlang/test-utils --dev\n```\n\nApos a instalacao, a estrutura do seu projeto incluira `hem_modules/`:\n\n```\nmy-project/\n package.json\n package-lock.json   # Arquivo de lock (gerado automaticamente)\n hem_modules/        # Pacotes instalados\n    hemlang/\n        sprout/\n src/\n    index.hml\n test/\n     test.hml\n```\n\n## Usando Pacotes Instalados\n\nImporte pacotes usando o caminho do GitHub:\n\n```hemlock\n// Importar de pacote instalado\nimport { app, router } from \"hemlang/sprout\";\nimport { parse, stringify } from \"hemlang/json\";\n\n// Importar de subcaminho\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// Biblioteca padrao (embutida)\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile } from \"@stdlib/fs\";\n```\n\n## Adicionar Scripts\n\nAdicione scripts no `package.json`:\n\n```json\n{\n  \"name\": \"myname/my-project\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/test.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\nExecute scripts com `hpm run`:\n\n```bash\nhpm run start\nhpm run build\n\n# Atalho para test\nhpm test\n```\n\n## Fluxos de Trabalho Comuns\n\n### Instalar Todas as Dependencias\n\nQuando voce clona um projeto com `package.json`:\n\n```bash\ngit clone https://github.com/someone/project.git\ncd project\nhpm install\n```\n\n### Atualizar Dependencias\n\nAtualize todos os pacotes para as versoes mais recentes dentro das restricoes:\n\n```bash\nhpm update\n```\n\nAtualize pacotes especificos:\n\n```bash\nhpm update hemlang/sprout\n```\n\n### Ver Pacotes Instalados\n\nListe todos os pacotes instalados:\n\n```bash\nhpm list\n```\n\nA saida mostra a arvore de dependencias:\n\n```\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n    hemlang/router@1.5.0\n hemlang/json@1.2.3\n```\n\n### Verificar Atualizacoes\n\nVeja quais pacotes tem versoes mais recentes disponiveis:\n\n```bash\nhpm outdated\n```\n\n### Remover Pacotes\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n## Exemplo: Aplicacao Web\n\nAqui esta um exemplo completo usando um framework web:\n\n**package.json:**\n```json\n{\n  \"name\": \"myname/my-web-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A web application\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"dev\": \"hemlock --watch src/index.hml\"\n  }\n}\n```\n\n**src/index.hml:**\n```hemlock\nimport { App, Router } from \"hemlang/sprout\";\n\nfn main() {\n    let app = App.new();\n    let router = Router.new();\n\n    router.get(\"/\", fn(req, res) {\n        res.send(\"Hello, World!\");\n    });\n\n    router.get(\"/api/status\", fn(req, res) {\n        res.json({ status: \"ok\" });\n    });\n\n    app.use(router);\n    app.listen(3000);\n\n    print(\"Server running on http://localhost:3000\");\n}\n```\n\nExecute a aplicacao:\n\n```bash\nhpm install\nhpm run start\n```\n\n## Proximos Passos\n\n- [Referencia de Comandos](#hpm-quick-start-commands) - Aprenda todos os comandos do hpm\n- [Criacao de Pacotes](#hpm-quick-start-creating-packages) - Publique seus proprios pacotes\n- [Configuracao](#hpm-quick-start-configuration) - Configure o hpm e o token do GitHub\n- [Configuracao do Projeto](#hpm-quick-start-project-setup) - Configuracao detalhada do projeto\n"}, "hpm: Guia do Usurio -> Comandos": {"id": "hpm-commands", "content": "# Referencia de Comandos\n\nReferencia completa de todos os comandos do hpm.\n\n## Opcoes Globais\n\nEstas opcoes se aplicam a qualquer comando:\n\n| Opcao | Descricao |\n|-------|-----------|\n| `--help`, `-h` | Mostrar informacoes de ajuda |\n| `--version`, `-v` | Mostrar versao do hpm |\n| `--verbose` | Mostrar saida detalhada |\n\n## Comandos\n\n### hpm init\n\nCria um novo arquivo `package.json`.\n\n```bash\nhpm init        # Modo interativo\nhpm init --yes  # Aceitar todos os valores padrao\nhpm init -y     # Forma abreviada\n```\n\n**Opcoes:**\n\n| Opcao | Descricao |\n|-------|-----------|\n| `--yes`, `-y` | Aceitar valores padrao para todos os prompts |\n\n**Prompts Interativos:**\n- Nome do pacote (formato owner/repo)\n- Versao (padrao: 1.0.0)\n- Descricao\n- Autor\n- Licenca (padrao: MIT)\n- Arquivo principal (padrao: src/index.hml)\n\n**Exemplo:**\n\n```bash\n$ hpm init\nPackage name (owner/repo): alice/my-lib\nVersion (1.0.0):\nDescription: A utility library\nAuthor: Alice <alice@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n---\n\n### hpm install\n\nInstala dependencias ou adiciona novos pacotes.\n\n```bash\nhpm install                           # Instalar todas as dependencias do package.json\nhpm install owner/repo                # Adicionar e instalar pacote\nhpm install owner/repo@^1.0.0        # Com restricao de versao\nhpm install owner/repo --dev         # Como dependencia de desenvolvimento\nhpm i owner/repo                      # Forma abreviada\n```\n\n**Opcoes:**\n\n| Opcao | Descricao |\n|-------|-----------|\n| `--dev`, `-D` | Adicionar a devDependencies |\n| `--verbose` | Mostrar progresso detalhado |\n| `--dry-run` | Visualizar sem instalar |\n| `--offline` | Instalar apenas do cache (sem rede) |\n| `--parallel` | Habilitar downloads paralelos (experimental) |\n\n**Sintaxe de Restricao de Versao:**\n\n| Sintaxe | Exemplo | Significado |\n|---------|---------|-------------|\n| (nenhuma) | `owner/repo` | Versao mais recente |\n| Exata | `owner/repo@1.2.3` | Exatamente 1.2.3 |\n| Circunflexo | `owner/repo@^1.2.3` | >=1.2.3 <2.0.0 |\n| Til | `owner/repo@~1.2.3` | >=1.2.3 <1.3.0 |\n| Intervalo | `owner/repo@>=1.0.0` | Pelo menos 1.0.0 |\n\n**Exemplos:**\n\n```bash\n# Instalar todas as dependencias\nhpm install\n\n# Instalar pacote especifico\nhpm install hemlang/json\n\n# Instalar com restricao de versao\nhpm install hemlang/sprout@^2.0.0\n\n# Instalar como dependencia de desenvolvimento\nhpm install hemlang/test-utils --dev\n\n# Visualizar o que sera instalado\nhpm install hemlang/sprout --dry-run\n\n# Saida detalhada\nhpm install --verbose\n\n# Instalar apenas do cache (offline)\nhpm install --offline\n```\n\n**Saida:**\n\n```\nInstalling dependencies...\n  + hemlang/sprout@2.1.0\n  + hemlang/router@1.5.0 (dependency of hemlang/sprout)\n\nInstalled 2 packages in 1.2s\n```\n\n---\n\n### hpm uninstall\n\nRemove um pacote.\n\n```bash\nhpm uninstall owner/repo\nhpm rm owner/repo          # Forma abreviada\nhpm remove owner/repo      # Forma alternativa\n```\n\n**Exemplo:**\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n**Saida:**\n\n```\nRemoved hemlang/sprout@2.1.0\nUpdated package.json\nUpdated package-lock.json\n```\n\n---\n\n### hpm update\n\nAtualiza pacotes para as versoes mais recentes dentro das restricoes.\n\n```bash\nhpm update              # Atualizar todos os pacotes\nhpm update owner/repo   # Atualizar pacote especifico\nhpm up owner/repo       # Forma abreviada\n```\n\n**Opcoes:**\n\n| Opcao | Descricao |\n|-------|-----------|\n| `--verbose` | Mostrar progresso detalhado |\n| `--dry-run` | Visualizar sem atualizar |\n\n**Exemplos:**\n\n```bash\n# Atualizar todos os pacotes\nhpm update\n\n# Atualizar pacote especifico\nhpm update hemlang/sprout\n\n# Visualizar atualizacoes\nhpm update --dry-run\n```\n\n**Saida:**\n\n```\nUpdating dependencies...\n  hemlang/sprout: 2.0.0  2.1.0\n  hemlang/router: 1.4.0  1.5.0\n\nUpdated 2 packages\n```\n\n---\n\n### hpm list\n\nMostra pacotes instalados.\n\n```bash\nhpm list              # Mostrar arvore completa de dependencias\nhpm list --depth=0    # Apenas dependencias diretas\nhpm list --depth=1    # Um nivel de dependencias transitivas\nhpm ls                # Forma abreviada\n```\n\n**Opcoes:**\n\n| Opcao | Descricao |\n|-------|-----------|\n| `--depth=N` | Limitar profundidade da arvore (padrao: todas) |\n\n**Exemplo:**\n\n```bash\n$ hpm list\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n    hemlang/router@1.5.0\n    hemlang/middleware@1.2.0\n hemlang/json@1.2.3\n hemlang/test-utils@1.0.0 (dev)\n\n$ hpm list --depth=0\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n hemlang/json@1.2.3\n hemlang/test-utils@1.0.0 (dev)\n```\n\n---\n\n### hpm outdated\n\nMostra pacotes com versoes mais recentes disponiveis.\n\n```bash\nhpm outdated\n```\n\n**Saida:**\n\n```\nPackage            Current  Wanted  Latest\nhemlang/sprout     2.0.0    2.0.5   2.1.0\nhemlang/router     1.4.0    1.4.2   1.5.0\n```\n\n- **Current**: Versao instalada\n- **Wanted**: Versao mais alta que satisfaz a restricao\n- **Latest**: Versao mais recente disponivel\n\n---\n\n### hpm run\n\nExecuta scripts do package.json.\n\n```bash\nhpm run <script>\nhpm run <script> -- <args>\n```\n\n**Exemplo:**\n\nDado o seguinte package.json:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\nExecute scripts:\n\n```bash\nhpm run start\nhpm run test\nhpm run build\n\n# Passar argumentos para o script\nhpm run test -- --verbose\n```\n\n---\n\n### hpm test\n\nAtalho para `hpm run test`.\n\n```bash\nhpm test\nhpm test -- --verbose\n```\n\nEquivalente a:\n\n```bash\nhpm run test\n```\n\n---\n\n### hpm why\n\nExplica por que um pacote foi instalado (mostra cadeia de dependencias).\n\n```bash\nhpm why owner/repo\n```\n\n**Exemplo:**\n\n```bash\n$ hpm why hemlang/router\n\nhemlang/router@1.5.0 is installed because:\n\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n     hemlang/router@1.5.0\n```\n\n---\n\n### hpm cache\n\nGerencia o cache global de pacotes.\n\n```bash\nhpm cache list    # Listar pacotes em cache\nhpm cache clean   # Limpar todos os pacotes em cache\n```\n\n**Subcomandos:**\n\n| Subcomando | Descricao |\n|------------|-----------|\n| `list` | Mostrar todos os pacotes em cache e tamanhos |\n| `clean` | Remover todos os pacotes em cache |\n\n**Exemplo:**\n\n```bash\n$ hpm cache list\nCached packages in ~/.hpm/cache:\n\nhemlang/sprout\n  2.0.0 (1.2 MB)\n  2.1.0 (1.3 MB)\nhemlang/router\n  1.5.0 (450 KB)\n\nTotal: 2.95 MB\n\n$ hpm cache clean\nCleared cache (2.95 MB freed)\n```\n\n---\n\n## Atalhos de Comandos\n\nPara conveniencia, varios comandos tem aliases curtos:\n\n| Comando | Atalhos |\n|---------|---------|\n| `install` | `i` |\n| `uninstall` | `rm`, `remove` |\n| `list` | `ls` |\n| `update` | `up` |\n\n**Exemplos:**\n\n```bash\nhpm i hemlang/sprout        # hpm install hemlang/sprout\nhpm rm hemlang/sprout       # hpm uninstall hemlang/sprout\nhpm ls                      # hpm list\nhpm up                      # hpm update\n```\n\n---\n\n## Codigos de Saida\n\nO hpm usa codigos de saida especificos para indicar diferentes condicoes de erro:\n\n| Codigo | Significado |\n|--------|-------------|\n| 0 | Sucesso |\n| 1 | Conflito de dependencias |\n| 2 | Pacote nao encontrado |\n| 3 | Versao nao encontrada |\n| 4 | Erro de rede |\n| 5 | package.json invalido |\n| 6 | Verificacao de integridade falhou |\n| 7 | Limite de taxa do GitHub excedido |\n| 8 | Dependencia circular |\n\nUsando codigos de saida em scripts:\n\n```bash\nhpm install\nif [ $? -ne 0 ]; then\n    echo \"Installation failed\"\n    exit 1\nfi\n```\n\n---\n\n## Variaveis de Ambiente\n\nO hpm suporta as seguintes variaveis de ambiente:\n\n| Variavel | Descricao |\n|----------|-----------|\n| `GITHUB_TOKEN` | Token de API do GitHub para autenticacao |\n| `HPM_CACHE_DIR` | Substituir localizacao do diretorio de cache |\n| `HOME` | Diretorio home do usuario (usado para config/cache) |\n\n**Exemplos:**\n\n```bash\n# Usar token do GitHub para limites de taxa mais altos\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Usar diretorio de cache personalizado\nexport HPM_CACHE_DIR=/tmp/hpm-cache\nhpm install\n```\n\n---\n\n## Veja Tambem\n\n- [Configuracao](#hpm-commands-configuration) - Arquivos de configuracao\n- [Especificacao de Pacotes](#hpm-commands-package-spec) - Formato do package.json\n- [Solucao de Problemas](#hpm-commands-troubleshooting) - Problemas comuns\n"}, "hpm: Guia do Usurio -> Configurao": {"id": "hpm-configuration", "content": "# Configuracao\n\nEste guia cobre todas as opcoes de configuracao do hpm.\n\n## Visao Geral\n\nO hpm pode ser configurado atraves de:\n\n1. **Variaveis de ambiente** - Para configuracoes em tempo de execucao\n2. **Arquivo de configuracao global** - `~/.hpm/config.json`\n3. **Arquivos do projeto** - `package.json` e `package-lock.json`\n\n## Variaveis de Ambiente\n\n### GITHUB_TOKEN\n\nToken de API do GitHub para autenticacao.\n\n```bash\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n```\n\n**Beneficios da autenticacao:**\n- Limites de taxa de API mais altos (5000 vs 60 requisicoes/hora)\n- Acesso a repositorios privados\n- Resolucao de dependencias mais rapida\n\n**Criando um token:**\n\n1. Va para GitHub  Settings  Developer settings  Personal access tokens\n2. Clique em \"Generate new token (classic)\"\n3. Selecione os escopos:\n   - `repo` - Para acesso a repositorios privados\n   - `read:packages` - Para GitHub Packages (se usado)\n4. Gere e copie o token\n\n### HPM_CACHE_DIR\n\nSubstitui o diretorio de cache padrao.\n\n```bash\nexport HPM_CACHE_DIR=/custom/cache/path\n```\n\nPadrao: `~/.hpm/cache`\n\n**Casos de uso:**\n- Sistemas CI/CD com localizacao de cache personalizada\n- Compartilhamento de cache entre projetos\n- Cache temporario para builds isoladas\n\n### HOME\n\nDiretorio home do usuario. Usado para localizar:\n- Diretorio de configuracao: `$HOME/.hpm/`\n- Diretorio de cache: `$HOME/.hpm/cache/`\n\nNormalmente definido pelo sistema; substitua apenas se necessario.\n\n### Exemplo .bashrc / .zshrc\n\n```bash\n# Autenticacao do GitHub (recomendado)\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n\n# Localizacao de cache personalizada (opcional)\n# export HPM_CACHE_DIR=/path/to/cache\n\n# Adicionar hpm ao PATH (se usando local de instalacao personalizado)\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## Arquivo de Configuracao Global\n\n### Localizacao\n\n`~/.hpm/config.json`\n\n### Formato\n\n```json\n{\n  \"github_token\": \"ghp_xxxxxxxxxxxxxxxxxxxx\"\n}\n```\n\n### Criando o Arquivo de Configuracao\n\n```bash\n# Criar diretorio de configuracao\nmkdir -p ~/.hpm\n\n# Criar arquivo de configuracao\ncat > ~/.hpm/config.json << 'EOF'\n{\n  \"github_token\": \"ghp_your_token_here\"\n}\nEOF\n\n# Proteger o arquivo (recomendado)\nchmod 600 ~/.hpm/config.json\n```\n\n### Prioridade do Token\n\nSe ambos estiverem definidos, a variavel de ambiente tem precedencia:\n\n1. Variavel de ambiente `GITHUB_TOKEN` (mais alta)\n2. Campo `github_token` em `~/.hpm/config.json`\n3. Sem autenticacao (padrao)\n\n## Estrutura de Diretorios\n\n### Diretorio Global\n\n```\n~/.hpm/\n config.json          # Configuracao global\n cache/               # Cache de pacotes\n     owner/\n         repo/\n             1.0.0.tar.gz\n```\n\n### Diretorio do Projeto\n\n```\nmy-project/\n package.json         # Manifesto do projeto\n package-lock.json    # Arquivo de lock de dependencias\n hem_modules/         # Pacotes instalados\n    owner/\n        repo/\n            package.json\n            src/\n src/                 # Codigo-fonte\n test/                # Testes\n```\n\n## Cache de Pacotes\n\n### Localizacao\n\nPadrao: `~/.hpm/cache/`\n\nSubstitua com a variavel de ambiente `HPM_CACHE_DIR`\n\n### Estrutura\n\n```\n~/.hpm/cache/\n hemlang/\n    sprout/\n       2.0.0.tar.gz\n       2.1.0.tar.gz\n    router/\n        1.5.0.tar.gz\n alice/\n     http-client/\n         1.0.0.tar.gz\n```\n\n### Gerenciando o Cache\n\n```bash\n# Ver pacotes em cache\nhpm cache list\n\n# Limpar todo o cache\nhpm cache clean\n```\n\n### Comportamento do Cache\n\n- Pacotes sao armazenados em cache apos o primeiro download\n- Instalacoes subsequentes usam versoes em cache\n- Use `--offline` para instalar apenas do cache\n- O cache e compartilhado entre todos os projetos\n\n## Limites de Taxa da API do GitHub\n\n### Sem Autenticacao\n\n- **60 requisicoes por hora**, por endereco IP\n- Compartilhado entre todos os usuarios nao autenticados no mesmo IP\n- Pode esgotar rapidamente em CI/CD ou com muitas dependencias\n\n### Com Autenticacao\n\n- **5000 requisicoes por hora**, por usuario autenticado\n- Limite de taxa pessoal, nao compartilhado\n\n### Lidando com Limites de Taxa\n\nO hpm automaticamente:\n- Tenta novamente com backoff exponencial (1s, 2s, 4s, 8s)\n- Relata erros de limite de taxa com codigo de saida 7\n- Sugere autenticacao se limitado\n\n**Solucoes quando limitado:**\n\n```bash\n# Opcao 1: Autenticar com token do GitHub\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Opcao 2: Esperar o limite de taxa ser resetado\n# (limite reseta a cada hora)\n\n# Opcao 3: Usar modo offline (se pacotes estao em cache)\nhpm install --offline\n```\n\n## Modo Offline\n\nInstalar pacotes sem acesso a rede:\n\n```bash\nhpm install --offline\n```\n\n**Requisitos:**\n- Todos os pacotes devem estar no cache\n- Arquivo de lock deve existir com versoes exatas\n\n**Casos de uso:**\n- Ambientes com rede isolada\n- Builds CI/CD mais rapidas (com cache quente)\n- Evitar limites de taxa\n\n## Configuracao CI/CD\n\n### GitHub Actions\n\n```yaml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Setup Hemlock\n      run: |\n        # Instalar Hemlock (ajuste conforme sua configuracao)\n        curl -sSL https://hemlock.dev/install.sh | sh\n\n    - name: Cache hpm packages\n      uses: actions/cache@v3\n      with:\n        path: ~/.hpm/cache\n        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}\n        restore-keys: |\n          ${{ runner.os }}-hpm-\n\n    - name: Install dependencies\n      run: hpm install\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Run tests\n      run: hpm test\n```\n\n### GitLab CI\n\n```yaml\nstages:\n  - build\n  - test\n\nvariables:\n  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache\n\ncache:\n  paths:\n    - .hpm-cache/\n  key: $CI_COMMIT_REF_SLUG\n\nbuild:\n  stage: build\n  script:\n    - hpm install\n  artifacts:\n    paths:\n      - hem_modules/\n\ntest:\n  stage: test\n  script:\n    - hpm test\n```\n\n### Docker\n\n**Dockerfile:**\n\n```dockerfile\nFROM hemlock:latest\n\nWORKDIR /app\n\n# Copiar arquivos de pacote primeiro (para cache de camadas)\nCOPY package.json package-lock.json ./\n\n# Instalar dependencias\nRUN hpm install\n\n# Copiar codigo-fonte\nCOPY . .\n\n# Executar aplicacao\nCMD [\"hemlock\", \"src/main.hml\"]\n```\n\n**docker-compose.yml:**\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    environment:\n      - GITHUB_TOKEN=${GITHUB_TOKEN}\n    volumes:\n      - hpm-cache:/root/.hpm/cache\n\nvolumes:\n  hpm-cache:\n```\n\n## Configuracao de Proxy\n\nPara ambientes atras de um proxy, configure no nivel do sistema:\n\n```bash\nexport HTTP_PROXY=http://proxy.example.com:8080\nexport HTTPS_PROXY=http://proxy.example.com:8080\nexport NO_PROXY=localhost,127.0.0.1\n\nhpm install\n```\n\n## Melhores Praticas de Seguranca\n\n### Seguranca do Token\n\n1. **Nunca comite tokens** no controle de versao\n2. **Use variaveis de ambiente** em CI/CD\n3. **Limite escopos do token** ao minimo necessario\n4. **Rotacione tokens regularmente**\n5. **Proteja arquivos de configuracao**:\n   ```bash\n   chmod 600 ~/.hpm/config.json\n   ```\n\n### Repositorios Privados\n\nPara acessar pacotes privados:\n\n1. Crie um token com escopo `repo`\n2. Configure autenticacao (variavel de ambiente ou arquivo de configuracao)\n3. Garanta que o token tem acesso ao repositorio\n\n```bash\n# Testar acesso\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install yourorg/private-package\n```\n\n## Solucao de Problemas de Configuracao\n\n### Verificando Configuracao\n\n```bash\n# Verificar se token esta definido\necho $GITHUB_TOKEN | head -c 10\n\n# Verificar arquivo de configuracao\ncat ~/.hpm/config.json\n\n# Verificar diretorio de cache\nls -la ~/.hpm/cache/\n\n# Testar com saida detalhada\nhpm install --verbose\n```\n\n### Problemas Comuns\n\n**\"GitHub rate limit exceeded\"**\n- Configure autenticacao com `GITHUB_TOKEN`\n- Espere o limite de taxa resetar\n- Use `--offline` se pacotes estao em cache\n\n**\"Permission denied\" no cache**\n```bash\n# Corrigir permissoes do cache\nchmod -R u+rw ~/.hpm/cache\n```\n\n**\"Config file not found\"**\n```bash\n# Criar diretorio de configuracao\nmkdir -p ~/.hpm\ntouch ~/.hpm/config.json\n```\n\n## Veja Tambem\n\n- [Instalacao](#hpm-configuration-installation) - Instalando o hpm\n- [Solucao de Problemas](#hpm-configuration-troubleshooting) - Problemas comuns\n- [Comandos](#hpm-configuration-commands) - Referencia de comandos\n"}, "hpm: Guia do Usurio -> Soluo de Problemas": {"id": "hpm-troubleshooting", "content": "# Solucao de Problemas\n\nSolucoes para problemas comuns do hpm.\n\n## Problemas de Instalacao\n\n### \"hemlock: command not found\"\n\n**Causa:** O Hemlock nao esta instalado ou nao esta no PATH.\n\n**Solucao:**\n\n```bash\n# Verificar se hemlock existe\nwhich hemlock\n\n# Se nao encontrado, instale o Hemlock primeiro\n# Visite: https://github.com/hemlang/hemlock\n\n# Apos a instalacao, verifique\nhemlock --version\n```\n\n### \"hpm: command not found\"\n\n**Causa:** O hpm nao esta instalado ou nao esta no PATH.\n\n**Solucao:**\n\n```bash\n# Verificar localizacao da instalacao do hpm\nls -la /usr/local/bin/hpm\nls -la ~/.local/bin/hpm\n\n# Se usando local personalizado, adicionar ao PATH\nexport PATH=\"$HOME/.local/bin:$PATH\"\n\n# Adicionar ao ~/.bashrc ou ~/.zshrc para persistir\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc\nsource ~/.bashrc\n\n# Se necessario, reinstale\ncd /path/to/hpm\nsudo make install\n```\n\n### \"Permission denied\" durante instalacao\n\n**Causa:** Sem permissao de escrita no diretorio de instalacao.\n\n**Solucao:**\n\n```bash\n# Opcao 1: Usar sudo para instalacao em todo o sistema\nsudo make install\n\n# Opcao 2: Instalar no diretorio do usuario (sem sudo)\nmake install PREFIX=$HOME/.local\n```\n\n## Problemas de Dependencias\n\n### \"Package not found\" (codigo de saida 2)\n\n**Causa:** O pacote nao existe no GitHub.\n\n**Solucao:**\n\n```bash\n# Verificar se o pacote existe\n# Visite: https://github.com/owner/repo\n\n# Verificar ortografia\nhpm install hemlang/sprout  # Correto\nhpm install hemlan/sprout   # Owner errado\nhpm install hemlang/spout   # Repo errado\n\n# Verificar erros de digitacao no package.json\ncat package.json | grep -A 5 dependencies\n```\n\n### \"Version not found\" (codigo de saida 3)\n\n**Causa:** Nenhuma versao publicada corresponde a restricao de versao.\n\n**Solucao:**\n\n```bash\n# Listar versoes disponiveis (verificar releases/tags do GitHub)\n# Tags devem comecar com 'v' (ex: v1.0.0)\n\n# Usar uma restricao de versao valida\nhpm install owner/repo@^1.0.0\n\n# Tentar a versao mais recente\nhpm install owner/repo\n\n# Verificar tags disponiveis no GitHub\n# https://github.com/owner/repo/tags\n```\n\n### \"Dependency conflict\" (codigo de saida 1)\n\n**Causa:** Dois pacotes requerem versoes incompativeis de uma dependencia.\n\n**Solucao:**\n\n```bash\n# Ver conflitos\nhpm install --verbose\n\n# Verificar o que requer a dependencia\nhpm why conflicting/package\n\n# Solucoes:\n# 1. Atualizar pacotes conflitantes\nhpm update problem/package\n\n# 2. Alterar restricoes de versao no package.json\n# Editar para permitir versoes compativeis\n\n# 3. Remover um dos pacotes conflitantes\nhpm uninstall one/package\n```\n\n### \"Circular dependency\" (codigo de saida 8)\n\n**Causa:** Pacote A depende de B, e B depende de A.\n\n**Solucao:**\n\n```bash\n# Identificar o ciclo\nhpm install --verbose\n\n# Isso geralmente e um bug no pacote\n# Contatar o mantenedor do pacote\n\n# Solucao alternativa: evitar usar um dos pacotes\n```\n\n## Problemas de Rede\n\n### \"Network error\" (codigo de saida 4)\n\n**Causa:** Nao foi possivel conectar a API do GitHub.\n\n**Solucao:**\n\n```bash\n# Verificar conexao de rede\nping github.com\n\n# Verificar se API do GitHub esta acessivel\ncurl -I https://api.github.com\n\n# Tentar novamente (hpm tenta automaticamente)\nhpm install\n\n# Se pacotes estao em cache, usar modo offline\nhpm install --offline\n\n# Se atras de firewall, verificar configuracoes de proxy\nexport HTTPS_PROXY=http://proxy:8080\nhpm install\n```\n\n### \"GitHub rate limit exceeded\" (codigo de saida 7)\n\n**Causa:** Muitas requisicoes de API sem autenticacao.\n\n**Solucao:**\n\n```bash\n# Opcao 1: Autenticar com token do GitHub (recomendado)\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Criar token: GitHub  Settings  Developer settings  Personal access tokens\n\n# Opcao 2: Salvar token no arquivo de configuracao\nmkdir -p ~/.hpm\necho '{\"github_token\": \"ghp_xxxxxxxxxxxx\"}' > ~/.hpm/config.json\n\n# Opcao 3: Esperar limite de taxa resetar (reseta a cada hora)\n\n# Opcao 4: Usar modo offline\nhpm install --offline\n```\n\n### Timeout de conexao\n\n**Causa:** Rede lenta ou problemas na API do GitHub.\n\n**Solucao:**\n\n```bash\n# hpm tenta automaticamente com backoff exponencial\n\n# Verificar se GitHub esta com problemas\n# Visite: https://www.githubstatus.com\n\n# Tentar novamente mais tarde\nhpm install\n\n# Usar pacotes em cache\nhpm install --offline\n```\n\n## Problemas do Package.json\n\n### \"Invalid package.json\" (codigo de saida 5)\n\n**Causa:** Formato incorreto ou campos obrigatorios ausentes.\n\n**Solucao:**\n\n```bash\n# Validar sintaxe JSON\ncat package.json | python -m json.tool\n\n# Verificar campos obrigatorios\ncat package.json\n\n# Campos obrigatorios:\n# - \"name\": formato owner/repo\n# - \"version\": formato X.Y.Z\n\n# Se necessario, regenerar\nrm package.json\nhpm init\n```\n\n### Formato incorreto do \"name\"\n\n**Causa:** Nome do pacote nao esta no formato `owner/repo`.\n\n**Solucao:**\n\n```json\n// Errado\n{\n  \"name\": \"my-package\"\n}\n\n// Correto\n{\n  \"name\": \"yourusername/my-package\"\n}\n```\n\n### Formato incorreto da \"version\"\n\n**Causa:** Versao nao esta no formato semver.\n\n**Solucao:**\n\n```json\n// Errado\n{\n  \"version\": \"1.0\"\n}\n\n// Correto\n{\n  \"version\": \"1.0.0\"\n}\n```\n\n## Problemas do Arquivo de Lock\n\n### Arquivo de lock dessincronizado\n\n**Causa:** package.json foi modificado sem executar install.\n\n**Solucao:**\n\n```bash\n# Regenerar arquivo de lock\nrm package-lock.json\nhpm install\n```\n\n### Arquivo de lock corrompido\n\n**Causa:** JSON invalido ou edicao manual.\n\n**Solucao:**\n\n```bash\n# Verificar validade do JSON\ncat package-lock.json | python -m json.tool\n\n# Regenerar\nrm package-lock.json\nhpm install\n```\n\n## Problemas do hem_modules\n\n### Pacote nao instalado\n\n**Causa:** Varios problemas possiveis.\n\n**Solucao:**\n\n```bash\n# Limpar e reinstalar\nrm -rf hem_modules\nhpm install\n\n# Verificar saida detalhada\nhpm install --verbose\n```\n\n### Import nao funciona\n\n**Causa:** Pacote nao instalado corretamente ou caminho de import errado.\n\n**Solucao:**\n\n```bash\n# Verificar se pacote esta instalado\nls hem_modules/owner/repo/\n\n# Verificar campo main do package.json\ncat hem_modules/owner/repo/package.json\n\n# Formato correto de import\nimport { x } from \"owner/repo\";          # Usa entrada main\nimport { y } from \"owner/repo/subpath\";  # Import de subcaminho\n```\n\n### Erro \"Module not found\"\n\n**Causa:** Caminho de import nao resolve para um arquivo.\n\n**Solucao:**\n\n```bash\n# Verificar caminho de import\nls hem_modules/owner/repo/src/\n\n# Verificar index.hml\nls hem_modules/owner/repo/src/index.hml\n\n# Verificar campo main no package.json\ncat hem_modules/owner/repo/package.json | grep main\n```\n\n## Problemas de Cache\n\n### Cache ocupando muito espaco\n\n**Solucao:**\n\n```bash\n# Ver tamanho do cache\nhpm cache list\n\n# Limpar cache\nhpm cache clean\n```\n\n### Permissoes do cache\n\n**Solucao:**\n\n```bash\n# Corrigir permissoes\nchmod -R u+rw ~/.hpm/cache\n\n# Ou remover e reinstalar\nrm -rf ~/.hpm/cache\nhpm install\n```\n\n### Usando cache errado\n\n**Solucao:**\n\n```bash\n# Verificar localizacao do cache\necho $HPM_CACHE_DIR\nls ~/.hpm/cache\n\n# Se incorreto, limpar variavel de ambiente\nunset HPM_CACHE_DIR\n```\n\n## Problemas de Scripts\n\n### \"Script not found\"\n\n**Causa:** Nome do script nao existe no package.json.\n\n**Solucao:**\n\n```bash\n# Listar scripts disponiveis\ncat package.json | grep -A 20 scripts\n\n# Verificar ortografia\nhpm run test    # Correto\nhpm run tests   # Errado se o script e chamado \"test\"\n```\n\n### Script falha\n\n**Causa:** Erro no comando do script.\n\n**Solucao:**\n\n```bash\n# Executar comando diretamente para ver erro\nhemlock test/run.hml\n\n# Verificar definicao do script\ncat package.json | grep test\n```\n\n## Depuracao\n\n### Habilitar saida detalhada\n\n```bash\nhpm install --verbose\n```\n\n### Verificar versao do hpm\n\n```bash\nhpm --version\n```\n\n### Verificar versao do hemlock\n\n```bash\nhemlock --version\n```\n\n### Execucao simulada\n\nVisualizar sem fazer alteracoes:\n\n```bash\nhpm install --dry-run\n```\n\n### Comecar do zero\n\nReiniciar completamente:\n\n```bash\nrm -rf hem_modules package-lock.json\nhpm install\n```\n\n## Obtendo Ajuda\n\n### Ajuda de comandos\n\n```bash\nhpm --help\nhpm install --help\n```\n\n### Reportando problemas\n\nSe encontrar um bug:\n\n1. Verifique issues existentes: https://github.com/hemlang/hpm/issues\n2. Crie um novo issue incluindo:\n   - Versao do hpm (`hpm --version`)\n   - Versao do Hemlock (`hemlock --version`)\n   - Sistema operacional\n   - Passos para reproduzir\n   - Mensagem de erro (use `--verbose`)\n\n## Referencia de Codigos de Saida\n\n| Codigo | Significado | Solucao Comum |\n|--------|-------------|---------------|\n| 0 | Sucesso | - |\n| 1 | Conflito de dependencias | Atualizar ou alterar restricoes |\n| 2 | Pacote nao encontrado | Verificar ortografia, confirmar que repo existe |\n| 3 | Versao nao encontrada | Verificar versoes disponiveis no GitHub |\n| 4 | Erro de rede | Verificar conexao, tentar novamente |\n| 5 | package.json invalido | Corrigir sintaxe JSON e campos obrigatorios |\n| 6 | Verificacao de integridade falhou | Limpar cache, reinstalar |\n| 7 | Limite de taxa do GitHub | Adicionar GITHUB_TOKEN |\n| 8 | Dependencia circular | Contatar mantenedor do pacote |\n\n## Veja Tambem\n\n- [Instalacao](#hpm-troubleshooting-installation) - Guia de instalacao\n- [Configuracao](#hpm-troubleshooting-configuration) - Opcoes de configuracao\n- [Comandos](#hpm-troubleshooting-commands) - Referencia de comandos\n"}, "hpm: Desenvolvimento de Pacotes -> Criao de Pacotes": {"id": "hpm-creating-packages", "content": "# Criacao de Pacotes\n\nEste guia explica como criar, organizar e publicar pacotes Hemlock.\n\n## Visao Geral\n\nO hpm usa o GitHub como seu registro de pacotes. Os pacotes sao identificados pelo caminho `owner/repo` do GitHub, e as versoes sao tags Git. Publicar e simplesmente enviar releases com tags.\n\n## Criando um Novo Pacote\n\n### 1. Inicializar o Pacote\n\nCrie um novo diretorio e inicialize:\n\n```bash\nmkdir my-package\ncd my-package\nhpm init\n```\n\nResponda aos prompts:\n\n```\nPackage name (owner/repo): yourusername/my-package\nVersion (1.0.0):\nDescription: A useful Hemlock package\nAuthor: Your Name <you@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n### 2. Criar Estrutura do Projeto\n\nEstrutura recomendada para um pacote:\n\n```\nmy-package/\n package.json          # Manifesto do pacote\n README.md             # Documentacao\n LICENSE               # Arquivo de licenca\n src/\n    index.hml         # Ponto de entrada principal (exporta API publica)\n    utils.hml         # Utilitarios internos\n    types.hml         # Definicoes de tipos\n test/\n     framework.hml     # Framework de testes\n     test_utils.hml    # Testes\n```\n\n### 3. Definir sua API Publica\n\n**src/index.hml** - Ponto de entrada principal:\n\n```hemlock\n// Re-exportar API publica\nexport { parse, stringify } from \"./parser.hml\";\nexport { Config, Options } from \"./types.hml\";\nexport { process } from \"./processor.hml\";\n\n// Exports diretos\nexport fn create(options: Options): Config {\n    // Implementacao\n}\n\nexport fn validate(config: Config): bool {\n    // Implementacao\n}\n```\n\n### 4. Escrever seu package.json\n\nExemplo completo de package.json:\n\n```json\n{\n  \"name\": \"yourusername/my-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A useful Hemlock package\",\n  \"author\": \"Your Name <you@example.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/yourusername/my-package\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/bundle.hmlc\"\n  },\n  \"keywords\": [\"utility\", \"parser\", \"config\"],\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n## Nomeacao de Pacotes\n\n### Requisitos\n\n- Deve estar no formato `owner/repo`\n- `owner` deve ser seu nome de usuario ou organizacao do GitHub\n- `repo` deve ser o nome do repositorio\n- Use letras minusculas e hifens para nomes com varias palavras\n\n### Bons Nomes\n\n```\nhemlang/sprout\nalice/http-client\nmyorg/json-utils\nbob/date-formatter\n```\n\n### Evite\n\n```\nmy-package          # Falta owner\nalice/MyPackage     # PascalCase\nalice/my_package    # Underscores\n```\n\n## Melhores Praticas de Estrutura de Pacotes\n\n### Ponto de Entrada\n\nO campo `main` no package.json especifica o ponto de entrada:\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\nEste arquivo deve exportar sua API publica:\n\n```hemlock\n// Exportar tudo que os usuarios precisam\nexport { Parser, parse } from \"./parser.hml\";\nexport { Formatter, format } from \"./formatter.hml\";\n\n// Tipos\nexport type { Config, Options } from \"./types.hml\";\n```\n\n### Interno vs Publico\n\nMantenha detalhes de implementacao interna privados:\n\n```\nsrc/\n index.hml          # Publico: API exportada\n parser.hml         # Publico: usado pelo index.hml\n formatter.hml      # Publico: usado pelo index.hml\n internal/\n     helpers.hml    # Privado: apenas para uso interno\n     constants.hml  # Privado: apenas para uso interno\n```\n\nUsuarios importam da raiz do seu pacote:\n\n```hemlock\n// Bom - importa da API publica\nimport { parse, Parser } from \"yourusername/my-package\";\n\n// Tambem funciona - import de subcaminho\nimport { validate } from \"yourusername/my-package/validator\";\n\n// Desencorajado - acessando internos\nimport { helper } from \"yourusername/my-package/internal/helpers\";\n```\n\n### Exports de Subcaminho\n\nSuporte imports de subcaminhos:\n\n```\nsrc/\n index.hml              # Entrada principal\n parser/\n    index.hml          # yourusername/pkg/parser\n formatter/\n    index.hml          # yourusername/pkg/formatter\n utils/\n     index.hml          # yourusername/pkg/utils\n```\n\nUsuarios podem importar:\n\n```hemlock\nimport { parse } from \"yourusername/my-package\";           // Principal\nimport { Parser } from \"yourusername/my-package/parser\";   // Subcaminho\nimport { format } from \"yourusername/my-package/formatter\";\n```\n\n## Dependencias\n\n### Adicionando Dependencias\n\n```bash\n# Dependencias de tempo de execucao\nhpm install hemlang/json\n\n# Dependencias de desenvolvimento\nhpm install hemlang/test-utils --dev\n```\n\n### Melhores Praticas para Dependencias\n\n1. **Use intervalos de circunflexo para a maioria das dependencias**:\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     }\n   }\n   ```\n\n2. **Trave versoes apenas quando necessario** (API instavel):\n   ```json\n   {\n     \"dependencies\": {\n       \"unstable/lib\": \"1.2.3\"\n     }\n   }\n   ```\n\n3. **Evite intervalos muito restritivos**:\n   ```json\n   // Ruim: muito restritivo\n   \"hemlang/json\": \">=1.2.3 <1.2.5\"\n\n   // Bom: permite atualizacoes compativeis\n   \"hemlang/json\": \"^1.2.3\"\n   ```\n\n4. **Separe dependencias de desenvolvimento**:\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     },\n     \"devDependencies\": {\n       \"hemlang/test-utils\": \"^1.0.0\"\n     }\n   }\n   ```\n\n## Testando seu Pacote\n\n### Escrevendo Testes\n\n**test/run.hml:**\n\n```hemlock\nimport { suite, test, assert_eq } from \"./framework.hml\";\nimport { parse, stringify } from \"../src/index.hml\";\n\nfn run_tests() {\n    suite(\"Parser\", fn() {\n        test(\"parses valid input\", fn() {\n            let result = parse(\"hello\");\n            assert_eq(result.value, \"hello\");\n        });\n\n        test(\"handles empty input\", fn() {\n            let result = parse(\"\");\n            assert_eq(result.value, \"\");\n        });\n    });\n\n    suite(\"Stringify\", fn() {\n        test(\"stringifies object\", fn() {\n            let obj = { name: \"test\" };\n            let result = stringify(obj);\n            assert_eq(result, '{\"name\":\"test\"}');\n        });\n    });\n}\n\nrun_tests();\n```\n\n### Executando Testes\n\nAdicione um script de teste:\n\n```json\n{\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\nExecute:\n\n```bash\nhpm test\n```\n\n## Publicacao\n\n### Pre-requisitos\n\n1. Crie um repositorio GitHub que corresponda ao nome do seu pacote\n2. Garanta que `package.json` esta completo e valido\n3. Todos os testes passando\n\n### Processo de Publicacao\n\nPublicar e simplesmente enviar tags Git:\n\n```bash\n# 1. Garanta que tudo esta commitado\ngit add .\ngit commit -m \"Prepare v1.0.0 release\"\n\n# 2. Criar tag de versao (deve comecar com 'v')\ngit tag v1.0.0\n\n# 3. Enviar codigo e tags\ngit push origin main\ngit push origin v1.0.0\n# Ou enviar todas as tags de uma vez\ngit push origin main --tags\n```\n\n### Tags de Versao\n\nTags devem seguir o formato `vX.Y.Z`:\n\n```bash\ngit tag v1.0.0      # Release\ngit tag v1.0.1      # Patch\ngit tag v1.1.0      # Minor\ngit tag v2.0.0      # Major\ngit tag v1.0.0-beta.1  # Pre-release\n```\n\n### Checklist de Publicacao\n\nAntes de publicar uma nova versao:\n\n1. **Atualizar** versao no package.json\n2. **Executar testes**: `hpm test`\n3. **Atualizar CHANGELOG** (se tiver)\n4. **Atualizar README** (se a API mudou)\n5. **Commitar alteracoes**\n6. **Criar tag**\n7. **Enviar para o GitHub**\n\n### Exemplo de Automacao\n\nCriar um script de release:\n\n```bash\n#!/bin/bash\n# release.sh - Publicar uma nova versao\n\nVERSION=$1\n\nif [ -z \"$VERSION\" ]; then\n    echo \"Usage: ./release.sh 1.0.0\"\n    exit 1\nfi\n\n# Executar testes\nhpm test || exit 1\n\n# Atualizar versao no package.json\nsed -i \"s/\\\"version\\\": \\\".*\\\"/\\\"version\\\": \\\"$VERSION\\\"/\" package.json\n\n# Commitar e criar tag\ngit add package.json\ngit commit -m \"Release v$VERSION\"\ngit tag \"v$VERSION\"\n\n# Enviar\ngit push origin main --tags\n\necho \"Released v$VERSION\"\n```\n\n## Usuarios Instalando seu Pacote\n\nApos a publicacao, usuarios podem instalar:\n\n```bash\n# Versao mais recente\nhpm install yourusername/my-package\n\n# Versao especifica\nhpm install yourusername/my-package@1.0.0\n\n# Restricao de versao\nhpm install yourusername/my-package@^1.0.0\n```\n\nE importar:\n\n```hemlock\nimport { parse, stringify } from \"yourusername/my-package\";\n```\n\n## Documentacao\n\n### README.md\n\nTodo pacote deve ter um README:\n\n```markdown\n# my-package\n\nA brief description of what this package does.\n\n## Installation\n\n\\`\\`\\`bash\nhpm install yourusername/my-package\n\\`\\`\\`\n\n## Usage\n\n\\`\\`\\`hemlock\nimport { parse } from \"yourusername/my-package\";\n\nlet result = parse(\"input\");\n\\`\\`\\`\n\n## API\n\n### parse(input: string): Result\n\nParses the input string.\n\n### stringify(obj: any): string\n\nConverts object to string.\n\n## License\n\nMIT\n```\n\n### Documentacao da API\n\nDocumente todos os exports publicos:\n\n```hemlock\n/// Analisa a string de entrada em um Result estruturado.\n///\n/// # Argumentos\n/// * `input` - A string a ser analisada\n///\n/// # Retorna\n/// Um Result contendo os dados analisados ou um erro\n///\n/// # Exemplo\n/// ```\n/// let result = parse(\"hello world\");\n/// print(result.value);\n/// ```\nexport fn parse(input: string): Result {\n    // Implementacao\n}\n```\n\n## Guia de Versionamento\n\nSiga o [Versionamento Semantico](https://semver.org/):\n\n- **MAJOR** (1.0.0  2.0.0): Mudancas incompativeis\n- **MINOR** (1.0.0  1.1.0): Novos recursos, compativel com versoes anteriores\n- **PATCH** (1.0.0  1.0.1): Correcoes de bugs, compativel com versoes anteriores\n\n### Quando Incrementar\n\n| Tipo de Mudanca | Incremento de Versao |\n|-----------------|---------------------|\n| Mudanca incompativel de API | MAJOR |\n| Remocao de funcao/tipo | MAJOR |\n| Alteracao de assinatura de funcao | MAJOR |\n| Adicionar nova funcao | MINOR |\n| Adicionar novo recurso | MINOR |\n| Correcao de bug | PATCH |\n| Atualizacao de documentacao | PATCH |\n| Refatoracao interna | PATCH |\n\n## Veja Tambem\n\n- [Especificacao de Pacotes](#hpm-creating-packages-package-spec) - Referencia completa do package.json\n- [Versionamento](#hpm-creating-packages-versioning) - Detalhes do versionamento semantico\n- [Configuracao](#hpm-creating-packages-configuration) - Autenticacao do GitHub\n"}, "hpm: Desenvolvimento de Pacotes -> Especificao de Pacotes": {"id": "hpm-package-spec", "content": "# Especificacao de Pacotes\n\nReferencia completa do formato do arquivo `package.json`.\n\n## Visao Geral\n\nTodo pacote hpm requer um arquivo `package.json` na raiz do projeto. Este arquivo define metadados do pacote, dependencias e scripts.\n\n## Exemplo Minimo\n\n```json\n{\n  \"name\": \"owner/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n## Exemplo Completo\n\n```json\n{\n  \"name\": \"hemlang/example-package\",\n  \"version\": \"1.2.3\",\n  \"description\": \"An example Hemlock package\",\n  \"author\": \"Hemlock Team <team@hemlock.dev>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/hemlang/example-package\",\n  \"homepage\": \"https://hemlang.github.io/example-package\",\n  \"bugs\": \"https://github.com/hemlang/example-package/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"example\", \"utility\", \"hemlock\"],\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"^2.1.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/bundle.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n## Referencia de Campos\n\n### name (obrigatorio)\n\nNome do pacote no formato `owner/repo`.\n\n```json\n{\n  \"name\": \"hemlang/sprout\"\n}\n```\n\n**Requisitos:**\n- Deve estar no formato `owner/repo`\n- `owner` deve ser seu nome de usuario ou organizacao do GitHub\n- `repo` deve ser o nome do repositorio\n- Use letras minusculas, numeros e hifens\n- Maximo de 214 caracteres no total\n\n**Nomes validos:**\n```\nhemlang/sprout\nalice/http-client\nmyorg/json-utils\nbob123/my-lib\n```\n\n**Nomes invalidos:**\n```\nmy-package          # Falta owner\nhemlang/My_Package  # Maiusculas e underscores\nhemlang             # Falta repo\n```\n\n### version (obrigatorio)\n\nVersao do pacote seguindo [Versionamento Semantico](https://semver.org/).\n\n```json\n{\n  \"version\": \"1.2.3\"\n}\n```\n\n**Formato:** `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`\n\n**Versoes validas:**\n```\n1.0.0\n2.1.3\n1.0.0-alpha\n1.0.0-beta.1\n1.0.0-rc.1+build.123\n0.1.0\n```\n\n### description\n\nDescricao curta do pacote.\n\n```json\n{\n  \"description\": \"A fast JSON parser for Hemlock\"\n}\n```\n\n- Mantenha abaixo de 200 caracteres\n- Descreva o que o pacote faz, nao como\n\n### author\n\nInformacoes do autor do pacote.\n\n```json\n{\n  \"author\": \"Your Name <email@example.com>\"\n}\n```\n\n**Formatos aceitos:**\n```json\n\"author\": \"Your Name\"\n\"author\": \"Your Name <email@example.com>\"\n\"author\": \"Your Name <email@example.com> (https://website.com)\"\n```\n\n### license\n\nIdentificador da licenca.\n\n```json\n{\n  \"license\": \"MIT\"\n}\n```\n\n**Licencas comuns:**\n- `MIT` - Licenca MIT\n- `Apache-2.0` - Licenca Apache 2.0\n- `GPL-3.0` - GNU General Public License v3.0\n- `BSD-3-Clause` - Licenca BSD 3-Clause\n- `ISC` - Licenca ISC\n- `UNLICENSED` - Proprietario/privado\n\nUse [identificadores SPDX](https://spdx.org/licenses/) quando possivel.\n\n### repository\n\nLink para o repositorio fonte.\n\n```json\n{\n  \"repository\": \"https://github.com/hemlang/sprout\"\n}\n```\n\n### homepage\n\nURL da pagina inicial do projeto.\n\n```json\n{\n  \"homepage\": \"https://sprout.hemlock.dev\"\n}\n```\n\n### bugs\n\nURL do rastreador de issues.\n\n```json\n{\n  \"bugs\": \"https://github.com/hemlang/sprout/issues\"\n}\n```\n\n### main\n\nArquivo de ponto de entrada do pacote.\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\n**Padrao:** `src/index.hml`\n\nQuando usuarios importam seu pacote:\n```hemlock\nimport { x } from \"owner/repo\";\n```\n\nO hpm carrega o arquivo especificado em `main`.\n\n**Ordem de resolucao de imports:**\n1. Caminho exato: `src/index.hml`\n2. Com extensao .hml: `src/index`  `src/index.hml`\n3. Arquivo index: `src/index/`  `src/index/index.hml`\n\n### keywords\n\nArray de palavras-chave para descoberta.\n\n```json\n{\n  \"keywords\": [\"json\", \"parser\", \"utility\", \"hemlock\"]\n}\n```\n\n- Use minusculas\n- Seja especifico e relevante\n- Inclua a linguagem (\"hemlock\") se apropriado\n\n### dependencies\n\nDependencias de tempo de execucao necessarias para o pacote funcionar.\n\n```json\n{\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"~2.1.0\",\n    \"alice/logger\": \">=1.0.0 <2.0.0\"\n  }\n}\n```\n\n**Chave:** Nome do pacote (`owner/repo`)\n**Valor:** Restricao de versao\n\n**Sintaxe de restricao de versao:**\n\n| Restricao | Significado |\n|-----------|-------------|\n| `1.2.3` | Versao exata |\n| `^1.2.3` | >=1.2.3 <2.0.0 |\n| `~1.2.3` | >=1.2.3 <1.3.0 |\n| `>=1.0.0` | Pelo menos 1.0.0 |\n| `>=1.0.0 <2.0.0` | Intervalo |\n| `*` | Qualquer versao |\n\n### devDependencies\n\nDependencias apenas para desenvolvimento (testes, build, etc.).\n\n```json\n{\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\",\n    \"hemlang/linter\": \"^2.0.0\"\n  }\n}\n```\n\nDependencias de desenvolvimento sao:\n- Instaladas durante o desenvolvimento\n- Nao instaladas quando o pacote e usado como dependencia\n- Usadas para testes, build, linting, etc.\n\n### scripts\n\nComandos nomeados que podem ser executados com `hpm run`.\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n**Executando scripts:**\n```bash\nhpm run start\nhpm run build\nhpm test        # Atalho para 'hpm run test'\n```\n\n**Passando argumentos:**\n```bash\nhpm run test -- --verbose --filter=unit\n```\n\n**Scripts comuns:**\n\n| Script | Proposito |\n|--------|-----------|\n| `start` | Iniciar a aplicacao |\n| `dev` | Modo de desenvolvimento com hot reload |\n| `test` | Executar testes |\n| `build` | Compilar para producao |\n| `clean` | Remover artefatos de build |\n| `lint` | Verificar estilo de codigo |\n| `format` | Formatar codigo |\n\n### files\n\nArquivos e diretorios a incluir quando o pacote e instalado.\n\n```json\n{\n  \"files\": [\n    \"src/\",\n    \"lib/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n**Comportamento padrao:** Se nao especificado, inclui:\n- Todos os arquivos no repositorio\n- Exclui `.git/`, `node_modules/`, `hem_modules/`\n\n**Usado para:**\n- Reduzir tamanho do pacote\n- Excluir arquivos de teste da distribuicao\n- Incluir apenas arquivos necessarios\n\n### native\n\nRequisitos de bibliotecas nativas.\n\n```json\n{\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\", \"sqlite3\"]\n  }\n}\n```\n\nDocumenta dependencias nativas que devem estar instaladas no sistema.\n\n## Validacao\n\nO hpm valida package.json durante varias operacoes. Erros comuns de validacao:\n\n### Campo obrigatorio ausente\n\n```\nError: package.json missing required field: name\n```\n\n**Correcao:** Adicionar campo obrigatorio.\n\n### Formato de nome invalido\n\n```\nError: Invalid package name. Must be in owner/repo format.\n```\n\n**Correcao:** Usar formato `owner/repo`.\n\n### Versao invalida\n\n```\nError: Invalid version \"1.0\". Must be semver format (X.Y.Z).\n```\n\n**Correcao:** Usar formato semver completo (`1.0.0`).\n\n### JSON invalido\n\n```\nError: package.json is not valid JSON\n```\n\n**Correcao:** Verificar sintaxe JSON (virgulas, aspas, chaves).\n\n## Criando package.json\n\n### Interativo\n\n```bash\nhpm init\n```\n\nSolicita interativamente cada campo.\n\n### Com valores padrao\n\n```bash\nhpm init --yes\n```\n\nCria com valores padrao:\n```json\n{\n  \"name\": \"directory-name/directory-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\n### Manual\n\nCriar arquivo manualmente:\n\n```bash\ncat > package.json << 'EOF'\n{\n  \"name\": \"yourname/your-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Your package description\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\nEOF\n```\n\n## Melhores Praticas\n\n1. **Sempre especifique main** - Nao dependa do padrao\n2. **Use intervalos de circunflexo** - `^1.0.0` para a maioria das dependencias\n3. **Separe dependencias de desenvolvimento** - Coloque dependencias de teste/build em devDependencies\n4. **Inclua palavras-chave** - Ajude usuarios a encontrar seu pacote\n5. **Documente scripts** - Nomeie scripts claramente\n6. **Especifique licenca** - Obrigatorio para projetos open source\n7. **Adicione descricao** - Ajude usuarios a entender o proposito\n\n## Veja Tambem\n\n- [Criacao de Pacotes](#hpm-package-spec-creating-packages) - Guia de publicacao\n- [Versionamento](#hpm-package-spec-versioning) - Restricoes de versao\n- [Configuracao do Projeto](#hpm-package-spec-project-setup) - Estrutura do projeto\n"}, "hpm: Desenvolvimento de Pacotes -> Versionamento": {"id": "hpm-versioning", "content": "# Versionamento\n\nGuia completo de versionamento semantico no hpm.\n\n## Versionamento Semantico\n\nO hpm usa [Versionamento Semantico 2.0.0](https://semver.org/) (semver) para versoes de pacotes.\n\n### Formato de Versao\n\n```\nMAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]\n```\n\n**Exemplos:**\n```\n1.0.0           # Versao de release\n2.1.3           # Versao de release\n1.0.0-alpha     # Pre-release\n1.0.0-beta.1    # Pre-release numerado\n1.0.0-rc.1      # Release candidate\n1.0.0+20231201  # Com metadados de build\n1.0.0-beta+exp  # Pre-release com metadados de build\n```\n\n### Componentes da Versao\n\n| Componente | Descricao | Exemplo |\n|------------|-----------|---------|\n| MAJOR | Mudancas incompativeis | `1.0.0`  `2.0.0` |\n| MINOR | Novos recursos (compativel) | `1.0.0`  `1.1.0` |\n| PATCH | Correcoes de bugs (compativel) | `1.0.0`  `1.0.1` |\n| PRERELEASE | Identificador de pre-release | `1.0.0-alpha` |\n| BUILD | Metadados de build (ignorado na comparacao) | `1.0.0+build123` |\n\n### Quando Incrementar\n\n| Tipo de Mudanca | Incremento | Exemplo |\n|-----------------|------------|---------|\n| Mudanca incompativel de API | MAJOR | Remover funcao |\n| Renomear funcao publica | MAJOR | `parse()`  `decode()` |\n| Mudar assinatura de funcao | MAJOR | Adicionar parametro obrigatorio |\n| Adicionar nova funcao | MINOR | Adicionar `validate()` |\n| Adicionar parametro opcional | MINOR | Novo parametro `options` opcional |\n| Correcao de bug | PATCH | Corrigir null pointer |\n| Melhoria de performance | PATCH | Algoritmo mais rapido |\n| Refatoracao interna | PATCH | Sem mudanca de API |\n\n## Restricoes de Versao\n\n### Sintaxe de Restricoes\n\n| Sintaxe | Significado | Resolve para |\n|---------|-------------|--------------|\n| `1.2.3` | Versao exata | Apenas 1.2.3 |\n| `^1.2.3` | Circunflexo (compativel) | >=1.2.3 e <2.0.0 |\n| `~1.2.3` | Til (atualizacoes de patch) | >=1.2.3 e <1.3.0 |\n| `>=1.0.0` | Pelo menos | 1.0.0 ou superior |\n| `>1.0.0` | Maior que | Superior a 1.0.0 |\n| `<2.0.0` | Menor que | Inferior a 2.0.0 |\n| `<=2.0.0` | No maximo | 2.0.0 ou inferior |\n| `>=1.0.0 <2.0.0` | Intervalo | Entre 1.0.0 e 2.0.0 |\n| `*` | Qualquer | Qualquer versao |\n\n### Intervalo de Circunflexo (^)\n\nO circunflexo (`^`) permite mudancas que nao modificam o digito nao-zero mais a esquerda:\n\n```\n^1.2.3    >=1.2.3 <2.0.0   # Permite 1.x.x\n^0.2.3    >=0.2.3 <0.3.0   # Permite 0.2.x\n^0.0.3    >=0.0.3 <0.0.4   # Permite apenas 0.0.3\n```\n\n**Caso de uso:** Voce quer atualizacoes compativeis dentro da versao major.\n\n**Restricao mais comum** - Recomendada para a maioria das dependencias.\n\n### Intervalo de Til (~)\n\nO til (`~`) permite apenas mudancas de patch:\n\n```\n~1.2.3    >=1.2.3 <1.3.0   # Permite 1.2.x\n~1.2      >=1.2.0 <1.3.0   # Permite 1.2.x\n~1        >=1.0.0 <2.0.0   # Permite 1.x.x\n```\n\n**Caso de uso:** Voce quer apenas correcoes de bugs, sem novos recursos.\n\n### Intervalos de Comparacao\n\nCombine operadores de comparacao para controle preciso:\n\n```json\n{\n  \"dependencies\": {\n    \"owner/pkg\": \">=1.0.0 <2.0.0\",\n    \"owner/other\": \">1.5.0 <=2.1.0\"\n  }\n}\n```\n\n### Qualquer Versao (*)\n\nCorresponde a qualquer versao:\n\n```json\n{\n  \"dependencies\": {\n    \"owner/pkg\": \"*\"\n  }\n}\n```\n\n**Aviso:** Nao recomendado para producao. Sempre obtera a versao mais recente.\n\n## Versoes Pre-release\n\n### Identificadores Pre-release\n\nVersoes pre-release tem menor precedencia que versoes de release:\n\n```\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0\n```\n\n### Tags Pre-release Comuns\n\n| Tag | Significado | Estagio |\n|-----|-------------|---------|\n| `alpha` | Desenvolvimento inicial | Muito instavel |\n| `beta` | Feature-complete | Em testes |\n| `rc` | Release candidate | Testes finais |\n| `dev` | Snapshot de desenvolvimento | Instavel |\n\n### Pre-release em Restricoes\n\nRestricoes nao correspondem a versoes pre-release por padrao:\n\n```\n^1.0.0    # Nao corresponde a 1.1.0-beta\n>=1.0.0   # Nao corresponde a 2.0.0-alpha\n```\n\nPara incluir versoes pre-release, referencie-as explicitamente:\n\n```\n>=1.0.0-alpha <2.0.0   # Inclui todos os pre-releases 1.x\n```\n\n## Comparacao de Versoes\n\n### Regras de Comparacao\n\n1. Compare MAJOR, MINOR, PATCH numericamente\n2. Release > pre-release com mesmo numero de versao\n3. Pre-releases sao comparados alfanumericamente\n4. Metadados de build sao ignorados\n\n### Exemplos\n\n```\n1.0.0 < 1.0.1 < 1.1.0 < 2.0.0\n\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0\n\n1.0.0 = 1.0.0+build123  # Metadados de build ignorados\n```\n\n### Ordenacao\n\nVersoes sao ordenadas em ordem crescente:\n\n```\n1.0.0\n1.0.1\n1.1.0\n1.1.1\n2.0.0-alpha\n2.0.0-beta\n2.0.0\n```\n\n## Resolucao de Versoes\n\n### Algoritmo de Resolucao\n\nQuando multiplos pacotes requerem a mesma dependencia:\n\n1. Coletar todas as restricoes\n2. Encontrar intersecao de todos os intervalos\n3. Selecionar a versao mais alta na intersecao\n4. Erro se nenhuma versao satisfizer todas as restricoes\n\n### Exemplo de Resolucao\n\n```\npackage-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npackage-b requires hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)\n\nIntersecao: >=1.2.0 <1.3.0\nDisponiveis: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]\nResolvido: 1.2.5 (mais alta na intersecao)\n```\n\n### Deteccao de Conflitos\n\nConflitos ocorrem quando nenhuma versao satisfaz todas as restricoes:\n\n```\npackage-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npackage-b requires hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)\n\nIntersecao: (vazia)\nResultado: CONFLITO - nenhuma versao satisfaz ambas\n```\n\n## Melhores Praticas\n\n### Para Consumidores de Pacotes\n\n1. **Use intervalos de circunflexo para a maioria das dependencias**:\n   ```json\n   \"hemlang/json\": \"^1.2.0\"\n   ```\n\n2. **Use intervalos de til para dependencias criticas**:\n   ```json\n   \"critical/lib\": \"~1.2.0\"\n   ```\n\n3. **Trave versoes apenas quando necessario**:\n   ```json\n   \"unstable/pkg\": \"1.2.3\"\n   ```\n\n4. **Comite arquivo de lock** para builds reproduziveis\n\n5. **Atualize regularmente** para obter correcoes de seguranca:\n   ```bash\n   hpm update\n   hpm outdated\n   ```\n\n### Para Autores de Pacotes\n\n1. **Comece com 0.1.0 para desenvolvimento inicial**:\n   - API pode mudar frequentemente\n   - Usuarios esperam instabilidade\n\n2. **Avance para 1.0.0 quando a API estiver estavel**:\n   - Compromisso publico com estabilidade\n   - Mudancas incompativeis requerem incremento de major\n\n3. **Siga semver estritamente**:\n   - Mudancas incompativeis = MAJOR\n   - Novos recursos = MINOR\n   - Correcoes de bugs = PATCH\n\n4. **Use versoes pre-release para testes**:\n   ```bash\n   git tag v2.0.0-beta.1\n   git push --tags\n   ```\n\n5. **Documente mudancas incompativeis** no CHANGELOG\n\n## Publicando Versoes\n\n### Criando uma Release\n\n```bash\n# Atualizar versao no package.json\n# Editar package.json: \"version\": \"1.1.0\"\n\n# Commitar mudanca de versao\ngit add package.json\ngit commit -m \"Bump version to 1.1.0\"\n\n# Criar e enviar tag\ngit tag v1.1.0\ngit push origin main --tags\n```\n\n### Formato de Tag\n\nTags **devem** comecar com `v`:\n\n```\nv1.0.0      Correto\nv1.0.0-beta Correto\n1.0.0       Nao sera reconhecido\n```\n\n### Fluxo de Trabalho de Release\n\n```bash\n# 1. Garantir que testes passam\nhpm test\n\n# 2. Atualizar versao no package.json\n# 3. Atualizar CHANGELOG.md\n# 4. Commitar mudancas\ngit add -A\ngit commit -m \"Release v1.2.0\"\n\n# 5. Criar tag\ngit tag v1.2.0\n\n# 6. Enviar tudo\ngit push origin main --tags\n```\n\n## Verificando Versoes\n\n### Listar Versoes Instaladas\n\n```bash\nhpm list\n```\n\n### Verificar Atualizacoes\n\n```bash\nhpm outdated\n```\n\nSaida:\n```\nPackage         Current  Wanted  Latest\nhemlang/json    1.0.0    1.0.5   1.2.0\nhemlang/sprout  2.0.0    2.0.3   2.1.0\n```\n\n- **Current**: Versao instalada\n- **Wanted**: Versao mais alta que satisfaz a restricao\n- **Latest**: Versao mais recente disponivel\n\n### Atualizar Pacotes\n\n```bash\n# Atualizar todos\nhpm update\n\n# Atualizar pacote especifico\nhpm update hemlang/json\n```\n\n## Veja Tambem\n\n- [Criacao de Pacotes](#hpm-versioning-creating-packages) - Guia de publicacao\n- [Especificacao de Pacotes](#hpm-versioning-package-spec) - Formato do package.json\n- [Comandos](#hpm-versioning-commands) - Referencia da CLI\n"}, "hpm: Referncia -> Arquitetura": {"id": "hpm-architecture", "content": "# Arquitetura\n\nArquitetura interna e design do hpm. Este documento e destinado a contribuidores e pessoas interessadas em entender como o hpm funciona.\n\n## Visao Geral\n\nO hpm e escrito em Hemlock e consiste em varios modulos que lidam com diferentes aspectos do gerenciamento de pacotes:\n\n```\nsrc/\n main.hml        # Ponto de entrada da CLI e roteamento de comandos\n manifest.hml    # Processamento do package.json\n lockfile.hml    # Processamento do package-lock.json\n semver.hml      # Versionamento semantico\n resolver.hml    # Resolucao de dependencias\n github.hml      # Cliente da API do GitHub\n installer.hml   # Download e extracao de pacotes\n cache.hml       # Gerenciamento de cache global\n```\n\n## Responsabilidades dos Modulos\n\n### main.hml\n\nPonto de entrada para a aplicacao CLI.\n\n**Responsabilidades:**\n- Analisar argumentos de linha de comando\n- Rotear comandos para handlers apropriados\n- Exibir ajuda e informacoes de versao\n- Lidar com flags globais (--verbose, --dry-run, etc.)\n- Sair com codigos apropriados\n\n**Funcoes principais:**\n- `main()` - Ponto de entrada, analisa args e despacha comandos\n- `cmd_init()` - Trata `hpm init`\n- `cmd_install()` - Trata `hpm install`\n- `cmd_uninstall()` - Trata `hpm uninstall`\n- `cmd_update()` - Trata `hpm update`\n- `cmd_list()` - Trata `hpm list`\n- `cmd_outdated()` - Trata `hpm outdated`\n- `cmd_run()` - Trata `hpm run`\n- `cmd_why()` - Trata `hpm why`\n- `cmd_cache()` - Trata `hpm cache`\n\n**Atalhos de comandos:**\n```hemlock\nlet shortcuts = {\n    \"i\": \"install\",\n    \"rm\": \"uninstall\",\n    \"remove\": \"uninstall\",\n    \"ls\": \"list\",\n    \"up\": \"update\"\n};\n```\n\n### manifest.hml\n\nLida com leitura e escrita de arquivos `package.json`.\n\n**Responsabilidades:**\n- Ler e escrever package.json\n- Validar estrutura do pacote\n- Gerenciar dependencias\n- Analisar especificadores de pacotes (owner/repo@version)\n\n**Funcoes principais:**\n```hemlock\ncreate_default(): Manifest           // Criar manifesto vazio\nread_manifest(): Manifest            // Ler do arquivo\nwrite_manifest(m: Manifest)          // Escrever no arquivo\nvalidate(m: Manifest): bool          // Validar estrutura\nget_all_dependencies(m): Map         // Obter deps + devDeps\nadd_dependency(m, pkg, ver, dev)     // Adicionar dependencia\nremove_dependency(m, pkg)            // Remover dependencia\nparse_specifier(spec): (name, ver)   // Analisar \"owner/repo@^1.0.0\"\nsplit_name(name): (owner, repo)      // Analisar \"owner/repo\"\n```\n\n**Estrutura do Manifest:**\n```hemlock\ntype Manifest = {\n    name: string,\n    version: string,\n    description: string?,\n    author: string?,\n    license: string?,\n    repository: string?,\n    main: string?,\n    dependencies: Map<string, string>,\n    devDependencies: Map<string, string>,\n    scripts: Map<string, string>\n};\n```\n\n### lockfile.hml\n\nGerencia o arquivo `package-lock.json` para instalacoes reproduziveis.\n\n**Responsabilidades:**\n- Criar/ler/escrever arquivo de lock\n- Rastrear versoes resolvidas exatas\n- Armazenar URLs de download e hashes de integridade\n- Limpar dependencias orfas\n\n**Funcoes principais:**\n```hemlock\ncreate_empty(): Lockfile              // Criar lockfile vazio\nread_lockfile(): Lockfile             // Ler do arquivo\nwrite_lockfile(l: Lockfile)           // Escrever no arquivo\ncreate_entry(ver, url, hash, deps)    // Criar entrada de lock\nget_locked(l, pkg): LockEntry?        // Obter versao travada\nset_locked(l, pkg, entry)             // Definir versao travada\nremove_locked(l, pkg)                 // Remover entrada\nprune(l, keep: Set)                   // Remover orfaos\nneeds_update(l, m): bool              // Verificar se esta dessincronizado\n```\n\n**Estrutura do Lockfile:**\n```hemlock\ntype Lockfile = {\n    lockVersion: int,\n    hemlock: string,\n    dependencies: Map<string, LockEntry>\n};\n\ntype LockEntry = {\n    version: string,\n    resolved: string,     // URL de download\n    integrity: string,    // Hash SHA256\n    dependencies: Map<string, string>\n};\n```\n\n### semver.hml\n\nImplementacao completa do Versionamento Semantico 2.0.0.\n\n**Responsabilidades:**\n- Analisar strings de versao\n- Comparar versoes\n- Analisar e avaliar restricoes de versao\n- Encontrar versoes que satisfazem restricoes\n\n**Funcoes principais:**\n```hemlock\n// Analise\nparse(s: string): Version             // \"1.2.3-beta+build\"  Version\nstringify(v: Version): string         // Version  \"1.2.3-beta+build\"\n\n// Comparacao\ncompare(a, b: Version): int           // -1, 0, ou 1\ngt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool\n\n// Restricoes\nparse_constraint(s: string): Constraint    // \"^1.2.3\"  Constraint\nsatisfies(v: Version, c: Constraint): bool // Verificar se v corresponde a c\nmax_satisfying(versions, c): Version?      // Encontrar mais alta que corresponde\nsort(versions): [Version]                  // Ordenar em ordem crescente\n\n// Utilitarios\nconstraints_overlap(a, b: Constraint): bool  // Verificar compatibilidade\n```\n\n**Estrutura de Version:**\n```hemlock\ntype Version = {\n    major: int,\n    minor: int,\n    patch: int,\n    prerelease: [string]?,  // Ex: [\"beta\", \"1\"]\n    build: string?          // Ex: \"20230101\"\n};\n```\n\n**Tipos de Constraint:**\n```hemlock\ntype Constraint =\n    | Exact(Version)           // \"1.2.3\"\n    | Caret(Version)           // \"^1.2.3\"  >=1.2.3 <2.0.0\n    | Tilde(Version)           // \"~1.2.3\"  >=1.2.3 <1.3.0\n    | Range(op, Version)       // \">=1.0.0\", \"<2.0.0\"\n    | And(Constraint, Constraint)  // Intervalos combinados\n    | Any;                     // \"*\"\n```\n\n### resolver.hml\n\nImplementa resolucao de dependencias estilo npm.\n\n**Responsabilidades:**\n- Resolver arvore de dependencias\n- Detectar conflitos de versao\n- Detectar dependencias circulares\n- Construir arvore de visualizacao\n\n**Funcoes principais:**\n```hemlock\nresolve(manifest, lockfile): ResolveResult\n    // Resolvedor principal: retorna mapa plano de todas as dependencias\n    // com suas versoes resolvidas\n\nresolve_version(pkg, constraints: [string]): ResolvedPackage?\n    // Encontrar versao que satisfaz todas as restricoes\n\ndetect_cycles(deps: Map): [Cycle]?\n    // Usar DFS para encontrar dependencias circulares\n\nbuild_tree(lockfile): Tree\n    // Criar estrutura de arvore para exibicao\n\nfind_why(pkg, lockfile): [Chain]\n    // Encontrar cadeias de dependencia explicando por que pkg esta instalado\n```\n\n**Algoritmo de Resolucao:**\n\n1. **Coletar restricoes**: Percorrer manifesto e dependencias transitivas\n2. **Resolver cada pacote**: Para cada pacote:\n   - Obter todas as restricoes de versao dos dependentes\n   - Buscar versoes disponiveis do GitHub\n   - Encontrar versao mais alta que satisfaz todas as restricoes\n   - Erro se nenhuma versao satisfaz todas (conflito)\n3. **Detectar ciclos**: Executar DFS para encontrar dependencias circulares\n4. **Retornar mapa plano**: Nome do pacote  informacao de versao resolvida\n\n**Estrutura de ResolveResult:**\n```hemlock\ntype ResolveResult = {\n    packages: Map<string, ResolvedPackage>,\n    conflicts: [Conflict]?,\n    cycles: [Cycle]?\n};\n\ntype ResolvedPackage = {\n    name: string,\n    version: Version,\n    url: string,\n    dependencies: Map<string, string>\n};\n```\n\n### github.hml\n\nCliente da API do GitHub para descoberta e download de pacotes.\n\n**Responsabilidades:**\n- Buscar versoes disponiveis (tags)\n- Baixar package.json dos repositorios\n- Baixar tarballs de release\n- Lidar com autenticacao e limites de taxa\n\n**Funcoes principais:**\n```hemlock\nget_token(): string?\n    // Obter token do ambiente ou configuracao\n\ngithub_request(url, headers?): Response\n    // Requisicao de API com retentativas\n\nget_tags(owner, repo): [string]\n    // Obter tags de versao (v1.0.0, v1.1.0, etc.)\n\nget_package_json(owner, repo, ref): Manifest\n    // Obter package.json em uma tag/commit especifica\n\ndownload_tarball(owner, repo, tag): bytes\n    // Baixar arquivo de release\n\nrepo_exists(owner, repo): bool\n    // Verificar se repositorio existe\n\nget_repo_info(owner, repo): RepoInfo\n    // Obter metadados do repositorio\n```\n\n**Logica de retentativa:**\n- Backoff exponencial: 1s, 2s, 4s, 8s\n- Condicoes de retentativa: 403 (limite de taxa), 5xx (erros de servidor), erros de rede\n- Maximo de 4 tentativas\n- Relata claramente erros de limite de taxa\n\n**Endpoints de API usados:**\n```\nGET /repos/{owner}/{repo}/tags\nGET /repos/{owner}/{repo}/contents/package.json?ref={tag}\nGET /repos/{owner}/{repo}/tarball/{tag}\nGET /repos/{owner}/{repo}\n```\n\n### installer.hml\n\nLida com download e extracao de pacotes.\n\n**Responsabilidades:**\n- Baixar pacotes do GitHub\n- Extrair tarballs para hem_modules\n- Verificar/usar pacotes em cache\n- Instalar/desinstalar pacotes\n\n**Funcoes principais:**\n```hemlock\ninstall_package(pkg: ResolvedPackage): bool\n    // Baixar e instalar um unico pacote\n\ninstall_all(packages: Map, options): InstallResult\n    // Instalar todos os pacotes resolvidos\n\nuninstall_package(name: string): bool\n    // Remover pacote do hem_modules\n\nget_installed(): Map<string, string>\n    // Listar pacotes atualmente instalados\n\nverify_integrity(pkg): bool\n    // Verificar integridade do pacote\n\nprefetch_packages(packages: Map): void\n    // Baixar para cache em paralelo (experimental)\n```\n\n**Processo de instalacao:**\n\n1. Verificar se a versao correta ja esta instalada\n2. Verificar tarball no cache\n3. Se nao estiver em cache, baixar do GitHub\n4. Armazenar no cache para uso futuro\n5. Extrair para `hem_modules/owner/repo/`\n6. Verificar instalacao\n\n**Estrutura de diretorio criada:**\n```\nhem_modules/\n owner/\n     repo/\n         package.json\n         src/\n         ...\n```\n\n### cache.hml\n\nGerencia o cache global de pacotes.\n\n**Responsabilidades:**\n- Armazenar tarballs baixados\n- Recuperar pacotes em cache\n- Listar pacotes em cache\n- Limpar cache\n- Gerenciar configuracao\n\n**Funcoes principais:**\n```hemlock\nget_cache_dir(): string\n    // Obter diretorio de cache (respeita HPM_CACHE_DIR)\n\nget_config_dir(): string\n    // Obter diretorio de configuracao (~/.hpm)\n\nis_cached(owner, repo, version): bool\n    // Verificar se tarball esta em cache\n\nget_cached_path(owner, repo, version): string\n    // Obter caminho para tarball em cache\n\nstore_tarball_file(owner, repo, version, data): void\n    // Salvar tarball no cache\n\nlist_cached(): [CachedPackage]\n    // Listar todos os pacotes em cache\n\nclear_cache(): int\n    // Remover todos os pacotes em cache, retorna bytes liberados\n\nget_cache_size(): int\n    // Calcular tamanho total do cache\n\nread_config(): Config\n    // Ler ~/.hpm/config.json\n\nwrite_config(c: Config): void\n    // Escrever arquivo de configuracao\n```\n\n**Estrutura do cache:**\n```\n~/.hpm/\n config.json\n cache/\n     owner/\n         repo/\n             1.0.0.tar.gz\n             1.1.0.tar.gz\n```\n\n## Fluxo de Dados\n\n### Fluxo do Comando Install\n\n```\nhpm install owner/repo@^1.0.0\n         \n         \n    \n     main.hml  Analisa args, chama cmd_install\n    \n         \n         \n    \n    manifest.hml Le package.json, adiciona dependencia\n    \n         \n         \n    \n    resolver.hml Resolve todas as dependencias\n    \n         \n         \n                        \n        \n     github.hml     semver.hml Busca versoes, encontra satisfazendo\n        \n         \n         \n    \n    installer.hml Baixa e extrai pacotes\n    \n         \n         \n                        \n        \n     github.hml     cache.hml Baixa ou usa cache\n        \n         \n         \n    \n    lockfile.hml Atualiza package-lock.json\n    \n```\n\n### Detalhes do Algoritmo de Resolucao\n\n```\nEntrada: manifest.dependencies, manifest.devDependencies, lockfile existente\n\n1. Inicializar:\n   - constraints = {} // Map<string, [Constraint]>\n   - resolved = {}    // Map<string, ResolvedPackage>\n   - queue = [dependencias diretas]\n\n2. Enquanto queue nao estiver vazia:\n   a. pkg = queue.pop()\n   b. Se pkg ja esta resolvido, pular\n   c. Obter todas as restricoes para pkg dos dependentes\n   d. Buscar versoes disponiveis do GitHub (em cache)\n   e. Encontrar versao mais alta que satisfaz todas as restricoes\n   f. Se nao encontrada: conflito\n   g. resolved[pkg] = {version, url, deps}\n   h. Adicionar dependencias de pkg a queue\n\n3. Detectar ciclos no grafo resolvido\n   - Se ciclos encontrados: erro\n\n4. Retornar mapa resolvido\n```\n\n## Tratamento de Erros\n\n### Codigos de Saida\n\nDefinidos em main.hml:\n\n```hemlock\nlet EXIT_SUCCESS = 0;\nlet EXIT_CONFLICT = 1;\nlet EXIT_NOT_FOUND = 2;\nlet EXIT_VERSION_NOT_FOUND = 3;\nlet EXIT_NETWORK = 4;\nlet EXIT_INVALID_MANIFEST = 5;\nlet EXIT_INTEGRITY = 6;\nlet EXIT_RATE_LIMIT = 7;\nlet EXIT_CIRCULAR = 8;\n```\n\n### Propagacao de Erros\n\nErros borbulham atraves de valores de retorno:\n\n```hemlock\nfn resolve_version(pkg): Result<Version, ResolveError> {\n    let versions = github.get_tags(owner, repo)?;  // ? propaga erros\n    // ...\n}\n```\n\n## Testes\n\n### Framework de Testes\n\nFramework de testes personalizado em `test/framework.hml`:\n\n```hemlock\nfn suite(name: string, tests: fn()) {\n    print(\"Suite: \" + name);\n    tests();\n}\n\nfn test(name: string, body: fn()) {\n    try {\n        body();\n        print(\"   \" + name);\n    } catch e {\n        print(\"   \" + name + \": \" + e);\n        failed += 1;\n    }\n}\n\nfn assert_eq<T>(actual: T, expected: T) {\n    if actual != expected {\n        throw \"Expected \" + expected + \", got \" + actual;\n    }\n}\n```\n\n### Arquivos de Teste\n\n- `test/test_semver.hml` - Analise de versao, comparacao, restricoes\n- `test/test_manifest.hml` - Leitura/escrita de manifesto, validacao\n- `test/test_lockfile.hml` - Operacoes de lockfile\n- `test/test_cache.hml` - Gerenciamento de cache\n\n### Executando Testes\n\n```bash\n# Todos os testes\nmake test\n\n# Testes especificos\nmake test-semver\nmake test-manifest\nmake test-lockfile\nmake test-cache\n```\n\n## Melhorias Futuras\n\n### Recursos Planejados\n\n1. **Verificacao de integridade** - Verificacao completa de hash SHA256\n2. **Workspaces** - Suporte a monorepo\n3. **Sistema de plugins** - Comandos extensiveis\n4. **Auditoria** - Verificacao de vulnerabilidades de seguranca\n5. **Registro privado** - Hospedagem de pacotes auto-hospedada\n\n### Limitacoes Conhecidas\n\n1. **Bug do bundler** - Nao consegue criar executaveis standalone\n2. **Downloads paralelos** - Experimental, pode ter condicoes de corrida\n3. **Integridade** - SHA256 nao totalmente implementado\n\n## Contribuindo\n\n### Estilo de Codigo\n\n- Use indentacao de 4 espacos\n- Funcoes devem fazer apenas uma coisa\n- Comente logica complexa\n- Escreva testes para novos recursos\n\n### Adicionando Comandos\n\n1. Adicionar handler em `main.hml`:\n   ```hemlock\n   fn cmd_newcmd(args: [string]) {\n       // Implementacao\n   }\n   ```\n\n2. Adicionar ao despacho de comandos:\n   ```hemlock\n   match command {\n       \"newcmd\" => cmd_newcmd(args),\n       // ...\n   }\n   ```\n\n3. Atualizar texto de ajuda\n\n### Adicionando Modulos\n\n1. Criar `src/newmodule.hml`\n2. Exportar interface publica\n3. Importar nos modulos que precisam\n4. Adicionar testes em `test/test_newmodule.hml`\n\n## Veja Tambem\n\n- [Comandos](#hpm-architecture-commands) - Referencia da CLI\n- [Criacao de Pacotes](#hpm-architecture-creating-packages) - Desenvolvimento de pacotes\n- [Versionamento](#hpm-architecture-versioning) - Versionamento semantico\n"}, "hpm: Referncia -> Cdigos de Sada": {"id": "hpm-exit-codes", "content": "# Codigos de Saida\n\nReferencia dos codigos de saida do hpm e seus significados.\n\n## Tabela de Codigos de Saida\n\n| Codigo | Nome | Descricao |\n|--------|------|-----------|\n| 0 | SUCCESS | Comando completado com sucesso |\n| 1 | CONFLICT | Conflito de versao de dependencias |\n| 2 | NOT_FOUND | Pacote nao encontrado |\n| 3 | VERSION_NOT_FOUND | Versao solicitada nao encontrada |\n| 4 | NETWORK | Erro de rede |\n| 5 | INVALID_MANIFEST | package.json invalido |\n| 6 | INTEGRITY | Verificacao de integridade falhou |\n| 7 | RATE_LIMIT | Limite de taxa da API do GitHub excedido |\n| 8 | CIRCULAR | Dependencia circular detectada |\n\n## Descricoes Detalhadas\n\n### Codigo de Saida 0: SUCCESS\n\nComando completado com sucesso.\n\n```bash\n$ hpm install\nInstalled 5 packages\n$ echo $?\n0\n```\n\n### Codigo de Saida 1: CONFLICT\n\nDois ou mais pacotes requerem versoes incompativeis de uma dependencia.\n\n**Exemplo:**\n```\nError: Dependency conflict for hemlang/json\n\n  package-a requires hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)\n  package-b requires hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)\n\nNo version satisfies all constraints.\n```\n\n**Solucao:**\n1. Verificar quais pacotes estao em conflito:\n   ```bash\n   hpm why hemlang/json\n   ```\n2. Atualizar os pacotes conflitantes:\n   ```bash\n   hpm update package-a\n   ```\n3. Relaxar restricoes de versao no package.json\n4. Remover um dos pacotes conflitantes\n\n### Codigo de Saida 2: NOT_FOUND\n\nO pacote especificado nao existe no GitHub.\n\n**Exemplo:**\n```\nError: Package not found: hemlang/nonexistent\n\nThe repository hemlang/nonexistent does not exist on GitHub.\n```\n\n**Solucao:**\n1. Verificar ortografia do nome do pacote\n2. Verificar se o repositorio existe: `https://github.com/owner/repo`\n3. Verificar se voce tem acesso (para repositorios privados, configurar GITHUB_TOKEN)\n\n### Codigo de Saida 3: VERSION_NOT_FOUND\n\nNenhuma versao corresponde a restricao especificada.\n\n**Exemplo:**\n```\nError: No version of hemlang/json matches constraint ^5.0.0\n\nAvailable versions: 1.0.0, 1.1.0, 1.2.0, 2.0.0\n```\n\n**Solucao:**\n1. Verificar versoes disponiveis em releases/tags do GitHub\n2. Usar uma restricao de versao valida\n3. Tags de versao devem comecar com 'v' (ex: `v1.0.0`)\n\n### Codigo de Saida 4: NETWORK\n\nOcorreu um erro relacionado a rede.\n\n**Exemplo:**\n```\nError: Network error: could not connect to api.github.com\n\nPlease check your internet connection and try again.\n```\n\n**Solucao:**\n1. Verificar conexao de rede\n2. Verificar se o GitHub esta acessivel\n3. Se atras de firewall, verificar configuracoes de proxy\n4. Se pacotes estao em cache, usar `--offline`:\n   ```bash\n   hpm install --offline\n   ```\n5. Esperar e tentar novamente (hpm tenta automaticamente)\n\n### Codigo de Saida 5: INVALID_MANIFEST\n\nArquivo package.json e invalido ou malformado.\n\n**Exemplo:**\n```\nError: Invalid package.json\n\n  - Missing required field: name\n  - Invalid version format: \"1.0\"\n```\n\n**Solucao:**\n1. Verificar sintaxe JSON (usar validador JSON)\n2. Garantir que campos obrigatorios existem (`name`, `version`)\n3. Verificar formatos dos campos:\n   - name: formato `owner/repo`\n   - version: formato semver `X.Y.Z`\n4. Regenerar:\n   ```bash\n   rm package.json\n   hpm init\n   ```\n\n### Codigo de Saida 6: INTEGRITY\n\nVerificacao de integridade do pacote falhou.\n\n**Exemplo:**\n```\nError: Integrity check failed for hemlang/json@1.0.0\n\nExpected: sha256-abc123...\nActual:   sha256-def456...\n\nThe downloaded package may be corrupted.\n```\n\n**Solucao:**\n1. Limpar cache e reinstalar:\n   ```bash\n   hpm cache clean\n   hpm install\n   ```\n2. Verificar problemas de rede (download parcial)\n3. Verificar se o pacote nao foi adulterado\n\n### Codigo de Saida 7: RATE_LIMIT\n\nLimite de taxa da API do GitHub excedido.\n\n**Exemplo:**\n```\nError: GitHub API rate limit exceeded\n\nUnauthenticated rate limit: 60 requests/hour\nCurrent usage: 60/60\n\nRate limit resets at: 2024-01-15 10:30:00 UTC\n```\n\n**Solucao:**\n1. **Usar autenticacao do GitHub** (recomendado):\n   ```bash\n   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx\n   hpm install\n   ```\n2. Esperar limite de taxa resetar (reseta a cada hora)\n3. Se pacotes estao em cache, usar modo offline:\n   ```bash\n   hpm install --offline\n   ```\n\n### Codigo de Saida 8: CIRCULAR\n\nDependencia circular detectada no grafo de dependencias.\n\n**Exemplo:**\n```\nError: Circular dependency detected\n\n  package-a@1.0.0\n   package-b@1.0.0\n       package-a@1.0.0  (circular!)\n\nCannot resolve dependency tree.\n```\n\n**Solucao:**\n1. Isso geralmente e um bug no proprio pacote\n2. Contatar o mantenedor do pacote\n3. Evitar usar um dos pacotes circulares\n\n## Usando Codigos de Saida em Scripts\n\n### Bash\n\n```bash\n#!/bin/bash\n\nhpm install\nexit_code=$?\n\ncase $exit_code in\n  0)\n    echo \"Installation successful\"\n    ;;\n  1)\n    echo \"Dependency conflict - check version constraints\"\n    exit 1\n    ;;\n  2)\n    echo \"Package not found - check package name\"\n    exit 1\n    ;;\n  4)\n    echo \"Network error - check connection\"\n    exit 1\n    ;;\n  7)\n    echo \"Rate limited - set GITHUB_TOKEN\"\n    exit 1\n    ;;\n  *)\n    echo \"Unknown error: $exit_code\"\n    exit 1\n    ;;\nesac\n```\n\n### CI/CD\n\n```yaml\n# GitHub Actions\n- name: Install dependencies\n  run: |\n    hpm install\n    if [ $? -eq 7 ]; then\n      echo \"::error::GitHub rate limit exceeded. Add GITHUB_TOKEN.\"\n      exit 1\n    fi\n  env:\n    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n### Make\n\n```makefile\ninstall:\n\t@hpm install || (echo \"Installation failed with code $$?\"; exit 1)\n\ntest: install\n\t@hpm test\n```\n\n## Solucao de Problemas por Codigo de Saida\n\n### Referencia Rapida\n\n| Codigo | Verificar Primeiro |\n|--------|-------------------|\n| 1 | Executar `hpm why <package>` para ver conflitos |\n| 2 | Verificar nome do pacote no GitHub |\n| 3 | Verificar versoes disponiveis nas tags do GitHub |\n| 4 | Verificar conexao de rede |\n| 5 | Validar sintaxe do package.json |\n| 6 | Executar `hpm cache clean && hpm install` |\n| 7 | Definir variavel de ambiente `GITHUB_TOKEN` |\n| 8 | Contatar mantenedor do pacote |\n\n## Veja Tambem\n\n- [Solucao de Problemas](#hpm-exit-codes-troubleshooting) - Solucoes detalhadas\n- [Comandos](#hpm-exit-codes-commands) - Referencia de comandos\n- [Configuracao](#hpm-exit-codes-configuration) - Configurar token do GitHub\n"}};

        // Mobile menu toggle
        const menuToggle = document.getElementById('menuToggle');
        const sidebar = document.getElementById('sidebar');

        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
            const isOpen = sidebar.classList.contains('open');
            menuToggle.textContent = isOpen ? '\u00d7' : '\u2630';
            menuToggle.setAttribute('aria-expanded', isOpen);
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth < 1024) {
                if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                    menuToggle.setAttribute('aria-expanded', 'false');
                }
            }
        });

        // Theme toggle functionality
        const themeToggle = document.getElementById('themeToggle');
        const root = document.documentElement;

        // Get saved theme or detect system preference
        function getPreferredTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                return savedTheme;
            }
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        // Apply theme
        function setTheme(theme) {
            root.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        }

        // Initialize theme
        const initialTheme = getPreferredTheme();
        if (localStorage.getItem('theme')) {
            setTheme(initialTheme);
        }

        // Toggle theme on button click
        themeToggle.addEventListener('click', () => {
            const currentTheme = root.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            // Determine current effective theme
            let effectiveTheme;
            if (currentTheme) {
                effectiveTheme = currentTheme;
            } else {
                effectiveTheme = prefersDark ? 'dark' : 'light';
            }

            // Toggle to opposite theme
            const newTheme = effectiveTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        });

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!localStorage.getItem('theme')) {
                // Only auto-switch if user hasn't manually set a preference
                root.removeAttribute('data-theme');
            }
        });

        // Markdown parser
        function parseMarkdown(md) {
            let lines = md.split('\n');
            let html = '';
            let inCodeBlock = false;
            let codeBlockContent = '';
            let codeBlockLang = '';
            let inList = false;
            let listContent = '';
            let inBlockquote = false;
            let blockquoteContent = '';
            let inTable = false;
            let tableRows = [];
            let tableHasHeader = false;

            function processInlineMarkdown(text) {
                text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
                text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
                return text;
            }

            function makeId(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/^-+|-+$/g, '');
            }

            function flushList() {
                if (inList && listContent) {
                    html += '<ul>\n' + listContent + '</ul>\n';
                    listContent = '';
                    inList = false;
                }
            }

            function flushBlockquote() {
                if (inBlockquote && blockquoteContent) {
                    html += '<blockquote>' + processInlineMarkdown(blockquoteContent.trim()) + '</blockquote>\n';
                    blockquoteContent = '';
                    inBlockquote = false;
                }
            }

            function flushTable() {
                if (inTable && tableRows.length > 0) {
                    html += '<table>\n';
                    for (let r = 0; r < tableRows.length; r++) {
                        const row = tableRows[r];
                        const isHeader = tableHasHeader && r === 0;
                        const tag = isHeader ? 'th' : 'td';
                        html += '<tr>\n';
                        for (const cell of row) {
                            html += '<' + tag + '>' + processInlineMarkdown(cell.trim()) + '</' + tag + '>\n';
                        }
                        html += '</tr>\n';
                    }
                    html += '</table>\n';
                    tableRows = [];
                    inTable = false;
                    tableHasHeader = false;
                }
            }

            function isTableSeparator(line) {
                return /^\|?[\s-:|]+\|[\s-:|]+\|?$/.test(line) && line.includes('-');
            }

            function parseTableRow(line) {
                let cells = line.split('|');
                // Remove empty first/last cells from leading/trailing |
                if (cells.length > 0 && cells[0].trim() === '') cells.shift();
                if (cells.length > 0 && cells[cells.length - 1].trim() === '') cells.pop();
                return cells;
            }

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                const trimmedLine = line.trim();

                // Handle code blocks (including indented ones in lists)
                if (trimmedLine.startsWith('```')) {
                    if (inCodeBlock) {
                        const codeId = 'code-' + Math.random().toString(36).substr(2, 9);
                        const langDisplay = codeBlockLang || 'code';
                        const copyIcon = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>';
                        html += `<div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">${langDisplay}</span>
                                <button class="copy-btn" onclick="copyCode('${codeId}')" aria-label="Copy code">${copyIcon}<span>Copy</span></button>
                            </div>
                            <pre><code id="${codeId}">` + escapeHtml(codeBlockContent) + '</code></pre></div>\n';
                        codeBlockContent = '';
                        codeBlockLang = '';
                        inCodeBlock = false;
                    } else {
                        flushList();
                        flushBlockquote();
                        inCodeBlock = true;
                        codeBlockLang = trimmedLine.substring(3).trim();
                    }
                    continue;
                }

                if (inCodeBlock) {
                    codeBlockContent += line + '\n';
                    continue;
                }

                // Table handling
                if (trimmedLine.includes('|')) {
                    if (trimmedLine.startsWith('|') || trimmedLine.endsWith('|')) {
                        flushList();
                        flushBlockquote();
                        if (isTableSeparator(trimmedLine)) {
                            // This is the separator row (|---|---|), mark header
                            if (tableRows.length === 1) {
                                tableHasHeader = true;
                            }
                        } else {
                            // Regular table row
                            tableRows.push(parseTableRow(trimmedLine));
                            inTable = true;
                        }
                        continue;
                    }
                }
                // Flush table if we hit a non-table line
                if (inTable) {
                    flushTable();
                }

                if (line.startsWith('# ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    const id = makeId(text);
                    html += `<h1 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h1>\n`;
                    continue;
                }
                if (line.startsWith('## ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(3).trim();
                    const id = makeId(text);
                    html += `<h2 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h2>\n`;
                    continue;
                }
                if (line.startsWith('### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(4).trim();
                    const id = makeId(text);
                    html += `<h3 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h3>\n`;
                    continue;
                }
                if (line.startsWith('#### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(5).trim();
                    const id = makeId(text);
                    html += `<h4 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h4>\n`;
                    continue;
                }

                if (line.trim() === '---') {
                    flushList();
                    flushBlockquote();
                    html += '<hr>\n';
                    continue;
                }

                if (line.startsWith('> ')) {
                    flushList();
                    blockquoteContent += line.substring(2) + ' ';
                    inBlockquote = true;
                    continue;
                } else if (inBlockquote && line.trim() === '') {
                    flushBlockquote();
                    continue;
                }

                if (line.startsWith('- ') || line.startsWith('* ')) {
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    listContent += '<li>' + processInlineMarkdown(text) + '</li>\n';
                    inList = true;
                    continue;
                } else if (inList && line.trim() !== '' && !line.startsWith('#')) {
                    listContent = listContent.trimEnd();
                    if (listContent.endsWith('</li>')) {
                        listContent = listContent.substring(0, listContent.length - 5);
                        listContent += ' ' + processInlineMarkdown(line.trim()) + '</li>\n';
                    }
                    continue;
                } else if (inList && line.trim() === '') {
                    flushList();
                    continue;
                }

                if (line.trim() === '') {
                    flushList();
                    flushBlockquote();
                    continue;
                }

                flushList();
                flushBlockquote();
                if (line.trim() !== '') {
                    html += '<p>' + processInlineMarkdown(line) + '</p>\n';
                }
            }

            flushList();
            flushBlockquote();
            flushTable();

            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Copy code to clipboard
        function copyCode(codeId) {
            const codeElement = document.getElementById(codeId);
            if (!codeElement) return;

            const text = codeElement.textContent;
            navigator.clipboard.writeText(text).then(() => {
                // Find the button that triggered this
                const btn = codeElement.closest('.code-block').querySelector('.copy-btn');
                if (btn) {
                    const originalText = btn.querySelector('span').textContent;
                    btn.classList.add('copied');
                    btn.querySelector('span').textContent = 'Copied!';

                    setTimeout(() => {
                        btn.classList.remove('copied');
                        btn.querySelector('span').textContent = originalText;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Load a page
        function loadPage(pageId) {
            const pageData = Object.values(PAGES).find(p => p.id === pageId);
            if (!pageData) {
                console.error('Page not found:', pageId);
                return;
            }

            const content = parseMarkdown(pageData.content);
            document.getElementById('content').innerHTML = content;

            // Update active nav link
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.dataset.page === pageId) {
                    link.classList.add('active');
                }
            });

            // Scroll to top
            window.scrollTo(0, 0);

            // Update URL hash
            window.location.hash = pageId;
        }

        // Setup navigation
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const pageId = link.dataset.page;
                loadPage(pageId);

                // Close mobile menu
                if (window.innerWidth < 1024) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                }
            });
        });

        // Handle browser back/forward
        window.addEventListener('hashchange', () => {
            const hash = window.location.hash.substring(1);
            if (hash) {
                loadPage(hash);
            }
        });

        // Search functionality
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const searchContainer = document.getElementById('searchContainer');
        const searchToggle = document.getElementById('searchToggle');
        let selectedIndex = -1;
        let currentResults = [];

        // Build search index from PAGES
        function buildSearchIndex() {
            const index = [];
            for (const [title, page] of Object.entries(PAGES)) {
                // Extract section from page ID
                const parts = page.id.split('-');
                let section = '';
                if (parts.length > 1) {
                    section = parts.slice(0, -1).join(' ');
                }

                // Extract headings from content
                const headings = [];
                const headingRegex = /^#+\s+(.+)$/gm;
                let match;
                while ((match = headingRegex.exec(page.content)) !== null) {
                    headings.push(match[1]);
                }

                // Get preview text (first 200 chars, stripped of markdown)
                let preview = page.content
                    .replace(/^#+\s+.+$/gm, '')  // Remove headings
                    .replace(/```[\s\S]*?```/g, '')  // Remove code blocks
                    .replace(/`[^`]+`/g, '')  // Remove inline code
                    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')  // Convert links to text
                    .replace(/\*\*([^*]+)\*\*/g, '$1')  // Remove bold
                    .replace(/\*([^*]+)\*/g, '$1')  // Remove italic
                    .replace(/\n+/g, ' ')  // Normalize whitespace
                    .trim()
                    .substring(0, 200);

                index.push({
                    title: title,
                    pageId: page.id,
                    section: section,
                    headings: headings,
                    content: page.content.toLowerCase(),
                    preview: preview
                });
            }
            return index;
        }

        const searchIndex = buildSearchIndex();

        // Search function
        function search(query) {
            if (!query || query.length < 2) return [];

            const q = query.toLowerCase().trim();
            const results = [];

            for (const item of searchIndex) {
                let score = 0;
                let matchedHeading = null;
                let matchContext = '';

                // Check title (highest priority)
                const titleLower = item.title.toLowerCase();
                if (titleLower === q) {
                    score = 100;
                } else if (titleLower.startsWith(q)) {
                    score = 80;
                } else if (titleLower.includes(q)) {
                    score = 60;
                }

                // Check headings
                for (const heading of item.headings) {
                    const headingLower = heading.toLowerCase();
                    if (headingLower === q) {
                        score = Math.max(score, 50);
                        matchedHeading = heading;
                    } else if (headingLower.includes(q)) {
                        score = Math.max(score, 40);
                        if (!matchedHeading) matchedHeading = heading;
                    }
                }

                // Check content
                if (item.content.includes(q)) {
                    score = Math.max(score, 20);

                    // Find context around the match
                    const idx = item.content.indexOf(q);
                    const start = Math.max(0, idx - 40);
                    const end = Math.min(item.content.length, idx + q.length + 60);
                    matchContext = item.content.substring(start, end);
                    if (start > 0) matchContext = '...' + matchContext;
                    if (end < item.content.length) matchContext = matchContext + '...';
                }

                if (score > 0) {
                    results.push({
                        title: item.title,
                        pageId: item.pageId,
                        section: item.section,
                        score: score,
                        matchedHeading: matchedHeading,
                        preview: matchContext || item.preview,
                        query: q
                    });
                }
            }

            // Sort by score descending
            results.sort((a, b) => b.score - a.score);

            return results.slice(0, 10);  // Limit to 10 results
        }

        // Highlight query in text
        function highlightText(text, query) {
            if (!query) return text;
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }

        // Render search results
        function renderResults(results, query) {
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-no-results">No results found</div>';
                return;
            }

            const html = results.map((result, index) => {
                const titleHtml = highlightText(result.title, query);
                const previewHtml = highlightText(result.preview, query);
                const selectedClass = index === selectedIndex ? ' selected' : '';

                return `
                    <div class="search-result${selectedClass}" data-index="${index}" data-page="${result.pageId}">
                        ${result.section ? `<div class="search-result-section">${result.section}</div>` : ''}
                        <div class="search-result-title">${titleHtml}</div>
                        ${result.matchedHeading ? `<div class="search-result-preview">${highlightText(result.matchedHeading, query)}</div>` : ''}
                        <div class="search-result-preview">${previewHtml}</div>
                    </div>
                `;
            }).join('');

            searchResults.innerHTML = html;

            // Add click handlers
            searchResults.querySelectorAll('.search-result').forEach(el => {
                el.addEventListener('click', () => {
                    const pageId = el.dataset.page;
                    loadPage(pageId);
                    closeSearch();
                });
            });
        }

        // Show search results
        function showResults() {
            searchResults.classList.add('active');
        }

        // Hide search results
        function hideResults() {
            searchResults.classList.remove('active');
            selectedIndex = -1;
        }

        // Close search (mobile)
        function closeSearch() {
            hideResults();
            searchInput.value = '';
            searchInput.blur();
            if (window.innerWidth < 769) {
                searchContainer.classList.remove('active');
            }
        }

        // Debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Handle search input
        const handleSearch = debounce((query) => {
            currentResults = search(query);
            if (query.length >= 2) {
                renderResults(currentResults, query);
                showResults();
            } else {
                hideResults();
            }
        }, 150);

        searchInput.addEventListener('input', (e) => {
            handleSearch(e.target.value);
        });

        // Handle keyboard navigation
        searchInput.addEventListener('keydown', (e) => {
            if (!searchResults.classList.contains('active')) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, currentResults.length - 1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIndex >= 0 && currentResults[selectedIndex]) {
                    loadPage(currentResults[selectedIndex].pageId);
                    closeSearch();
                } else if (currentResults.length > 0) {
                    loadPage(currentResults[0].pageId);
                    closeSearch();
                }
            } else if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Close results when clicking outside
        document.addEventListener('click', (e) => {
            if (!searchContainer.contains(e.target)) {
                hideResults();
            }
        });

        // Focus search on input click
        searchInput.addEventListener('focus', () => {
            if (searchInput.value.length >= 2) {
                handleSearch(searchInput.value);
            }
        });

        // Global keyboard shortcut (Ctrl+K or Cmd+K)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                if (window.innerWidth < 769) {
                    searchContainer.classList.add('active');
                }
                searchInput.focus();
            }
            if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Mobile search toggle
        if (searchToggle) {
            searchToggle.addEventListener('click', () => {
                searchContainer.classList.toggle('active');
                if (searchContainer.classList.contains('active')) {
                    searchInput.focus();
                }
            });
        }

        // Language switcher
        function switchLanguage(filename) {
            const currentHash = window.location.hash;
            window.location.href = filename + currentHash;
        }

        // Load initial page
        const initialHash = window.location.hash.substring(1);
        const firstPageId = Object.values(PAGES)[0].id;
        loadPage(initialHash || firstPageId);
    </script>
</body>
</html>