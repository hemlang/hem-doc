# Интерфейс внешних функций (FFI) в Hemlock

Hemlock предоставляет **FFI (Foreign Function Interface)** для вызова функций C из разделяемых библиотек с использованием libffi, что позволяет интегрироваться с существующими библиотеками C и системными API.

## Содержание

- [Обзор](#обзор)
- [Текущий статус](#текущий-статус)
- [Поддерживаемые типы](#поддерживаемые-типы)
- [Базовые концепции](#базовые-концепции)
- [Экспорт FFI-функций](#экспорт-ffi-функций)
- [Случаи использования](#случаи-использования)
- [Будущее развитие](#будущее-развитие)
- [FFI-коллбэки](#ffi-коллбэки)
- [FFI-структуры](#ffi-структуры)
- [Экспорт типов структур](#экспорт-типов-структур)
- [Текущие ограничения](#текущие-ограничения)
- [Лучшие практики](#лучшие-практики)

## Обзор

Интерфейс внешних функций (FFI) позволяет программам Hemlock:
- Вызывать функции C из разделяемых библиотек (.so, .dylib, .dll)
- Использовать существующие библиотеки C без написания обёрточного кода
- Обращаться к системным API напрямую
- Интегрироваться со сторонними нативными библиотеками
- Связывать Hemlock с низкоуровневой системной функциональностью

**Ключевые возможности:**
- Динамическая загрузка библиотек
- Связывание функций C
- Автоматическое преобразование типов между Hemlock и C
- Поддержка всех примитивных типов
- Реализация на основе libffi для переносимости

## Текущий статус

Поддержка FFI доступна в Hemlock со следующими возможностями:

**Реализовано:**
- Вызов функций C из разделяемых библиотек
- Поддержка всех примитивных типов (целые числа, числа с плавающей точкой, указатели)
- Автоматическое преобразование типов
- Реализация на основе libffi
- Динамическая загрузка библиотек
- **Коллбэки с указателями на функции** - Передача функций Hemlock в C
- **Экспорт extern-функций** - Совместное использование FFI-связей между модулями
- **Передача и возврат структур** - Передача C-совместимых структур по значению
- **Полные вспомогательные функции указателей** - Чтение/запись всех типов (i8-i64, u8-u64, f32, f64, ptr)
- **Преобразование буфер/указатель** - `buffer_ptr()`, `ptr_to_buffer()`
- **Размеры FFI-типов** - `ffi_sizeof()` для платформо-зависимых размеров типов
- **Платформенные типы** - поддержка `size_t`, `usize`, `isize`, `intptr_t`

**В разработке:**
- Вспомогательные функции маршалинга строк
- Улучшения обработки ошибок

**Покрытие тестами:**
- Тесты FFI проходят, включая тесты коллбэков
- Базовый вызов функций проверен
- Преобразование типов протестировано
- Интеграция коллбэков qsort протестирована

## Поддерживаемые типы

### Примитивные типы

Следующие типы Hemlock могут передаваться в/из функций C:

| Тип Hemlock | Тип C | Размер | Примечания |
|-------------|-------|--------|------------|
| `i8` | `int8_t` | 1 байт | Знаковое 8-битное целое |
| `i16` | `int16_t` | 2 байта | Знаковое 16-битное целое |
| `i32` | `int32_t` | 4 байта | Знаковое 32-битное целое |
| `i64` | `int64_t` | 8 байт | Знаковое 64-битное целое |
| `u8` | `uint8_t` | 1 байт | Беззнаковое 8-битное целое |
| `u16` | `uint16_t` | 2 байта | Беззнаковое 16-битное целое |
| `u32` | `uint32_t` | 4 байта | Беззнаковое 32-битное целое |
| `u64` | `uint64_t` | 8 байт | Беззнаковое 64-битное целое |
| `f32` | `float` | 4 байта | 32-битное число с плавающей точкой |
| `f64` | `double` | 8 байт | 64-битное число с плавающей точкой |
| `ptr` | `void*` | 8 байт | Сырой указатель |

### Преобразование типов

**Автоматические преобразования:**
- Целые числа Hemlock → целые числа C (с проверкой диапазона)
- Числа с плавающей точкой Hemlock → числа с плавающей точкой C
- Указатели Hemlock → указатели C
- Возвращаемые значения C → значения Hemlock

**Примеры соответствия типов:**
```hemlock
// Hemlock → C
let i: i32 = 42;         // → int32_t (4 байта)
let f: f64 = 3.14;       // → double (8 байт)
let p: ptr = alloc(64);  // → void* (8 байт)

// C → Hemlock (возвращаемые значения)
// int32_t foo() → i32
// double bar() → f64
// void* baz() → ptr
```

## Базовые концепции

### Разделяемые библиотеки

FFI работает со скомпилированными разделяемыми библиотеками:

**Linux:** файлы `.so`
```
libexample.so
/usr/lib/libm.so
```

**macOS:** файлы `.dylib`
```
libexample.dylib
/usr/lib/libSystem.dylib
```

**Windows:** файлы `.dll`
```
example.dll
kernel32.dll
```

### Сигнатуры функций

Функции C должны иметь известные сигнатуры для корректной работы FFI:

```c
// Примеры сигнатур функций C
int add(int a, int b);
double sqrt(double x);
void* malloc(size_t size);
void free(void* ptr);
```

Эти функции можно вызывать из Hemlock после загрузки библиотеки и связывания функций.

### Кроссплатформенная совместимость

FFI использует **libffi** для переносимости:
- Работает на x86, x86-64, ARM, ARM64
- Автоматически обрабатывает соглашения о вызовах
- Абстрагирует платформо-специфичные детали ABI
- Поддерживает Linux, macOS, Windows (с соответствующей libffi)

## Экспорт FFI-функций

FFI-функции, объявленные с `extern fn`, могут экспортироваться из модулей, позволяя создавать переиспользуемые обёртки библиотек для совместного использования между несколькими файлами.

### Базовый синтаксис экспорта

```hemlock
// string_utils.hml - Модуль библиотеки, оборачивающий строковые функции C
import "libc.so.6";

// Экспорт extern-функции напрямую
export extern fn strlen(s: string): i32;
export extern fn strcmp(s1: string, s2: string): i32;

// Можно также экспортировать функции-обёртки вместе с extern-функциями
export fn string_length(s: string): i32 {
    return strlen(s);
}

export fn strings_equal(a: string, b: string): bool {
    return strcmp(a, b) == 0;
}
```

### Импорт экспортированных FFI-функций

```hemlock
// main.hml - Использование экспортированных FFI-функций
import { strlen, string_length, strings_equal } from "./string_utils.hml";

let msg = "Hello, World!";
print(strlen(msg));           // 13 - прямой вызов extern
print(string_length(msg));    // 13 - функция-обёртка

print(strings_equal("foo", "foo"));  // true
print(strings_equal("foo", "bar"));  // false
```

### Случаи использования export extern

**1. Абстракция платформы**
```hemlock
// platform.hml - Абстрагирование различий платформ
import "libc.so.6";  // Linux

export extern fn getpid(): i32;
export extern fn getuid(): i32;
export extern fn geteuid(): i32;
```

**2. Обёртки библиотек**
```hemlock
// crypto_lib.hml - Обёртка функций криптобиблиотеки
import "libcrypto.so";

export extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;
export extern fn MD5(data: ptr, len: u64, out: ptr): ptr;

// Добавление Hemlock-дружественных обёрток
export fn sha256_string(s: string): string {
    // Реализация с использованием extern-функции
}
```

**3. Централизованные FFI-объявления**
```hemlock
// libc.hml - Центральный модуль для связей libc
import "libc.so.6";

// Строковые функции
export extern fn strlen(s: string): i32;
export extern fn strcpy(dest: ptr, src: string): ptr;
export extern fn strcat(dest: ptr, src: string): ptr;

// Функции памяти
export extern fn malloc(size: u64): ptr;
export extern fn realloc(p: ptr, size: u64): ptr;
export extern fn calloc(nmemb: u64, size: u64): ptr;

// Функции процессов
export extern fn getpid(): i32;
export extern fn getppid(): i32;
export extern fn getenv(name: string): ptr;
```

Затем используйте по всему проекту:
```hemlock
import { strlen, malloc, getpid } from "./libc.hml";
```

### Комбинирование с обычными экспортами

Вы можете смешивать экспортированные extern-функции с обычными экспортами функций:

```hemlock
// math_extended.hml
import "libm.so.6";

// Экспорт сырых функций C
export extern fn sin(x: f64): f64;
export extern fn cos(x: f64): f64;
export extern fn tan(x: f64): f64;

// Экспорт функций Hemlock, которые их используют
export fn deg_to_rad(degrees: f64): f64 {
    return degrees * 3.14159265359 / 180.0;
}

export fn sin_degrees(degrees: f64): f64 {
    return sin(deg_to_rad(degrees));
}
```

### Платформо-специфичные библиотеки

При экспорте extern-функций помните, что имена библиотек различаются по платформам:

```hemlock
// Для Linux
import "libc.so.6";

// Для macOS (нужен другой подход)
import "libSystem.B.dylib";
```

В настоящее время синтаксис `import "library"` в Hemlock использует статические пути библиотек, поэтому для кроссплатформенного FFI-кода могут потребоваться платформо-специфичные модули.

## Случаи использования

### 1. Системные библиотеки

Доступ к функциям стандартной библиотеки C:

**Математические функции:**
```hemlock
// Вызов sqrt из libm
let result = sqrt(16.0);  // 4.0
```

**Выделение памяти:**
```hemlock
// Вызов malloc/free из libc
let ptr = malloc(1024);
free(ptr);
```

### 2. Сторонние библиотеки

Использование существующих библиотек C:

**Пример: Обработка изображений**
```hemlock
// Загрузка libpng или libjpeg
// Обработка изображений с помощью функций библиотеки C
```

**Пример: Криптография**
```hemlock
// Использование OpenSSL или libsodium
// Шифрование/дешифрование через FFI
```

### 3. Системные API

Прямые системные вызовы:

**Пример: POSIX API**
```hemlock
// Вызов getpid, getuid и т.д.
// Доступ к низкоуровневой системной функциональности
```

### 4. Критичный к производительности код

Вызов оптимизированных реализаций C:

```hemlock
// Использование высокооптимизированных библиотек C
// SIMD-операции, векторизованный код
// Аппаратно-ускоренные функции
```

### 5. Доступ к оборудованию

Интерфейс с библиотеками оборудования:

```hemlock
// Управление GPIO на встроенных системах
// Коммуникация с USB-устройствами
// Доступ к последовательному порту
```

### 6. Интеграция с унаследованным кодом

Переиспользование существующих кодовых баз C:

```hemlock
// Вызов функций из унаследованных приложений C
// Постепенная миграция на Hemlock
// Сохранение работающего кода C
```

## Будущее развитие

### Планируемые возможности

**1. Поддержка структур**
```hemlock
// Будущее: Передача/возврат структур C
define Point {
    x: f64,
    y: f64,
}

let p = Point { x: 1.0, y: 2.0 };
c_function_with_struct(p);
```

**2. Обработка массивов/буферов**
```hemlock
// Будущее: Улучшенная передача массивов
let arr = [1, 2, 3, 4, 5];
process_array(arr);  // Передача в функцию C
```

**3. Коллбэки с указателями на функции** (Реализовано!)
```hemlock
// Передача функций Hemlock в C как коллбэки
fn my_compare(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    return va - vb;
}

// Создание C-вызываемого указателя на функцию
let cmp = callback(my_compare, ["ptr", "ptr"], "i32");

// Использование с qsort или любой функцией C, ожидающей коллбэк
qsort(arr, count, elem_size, cmp);

// Очистка по завершении
callback_free(cmp);
```

**4. Маршалинг строк**
```hemlock
// Будущее: Автоматическое преобразование строк
let s = "hello";
c_string_function(s);  // Авто-преобразование в строку C
```

**5. Обработка ошибок**
```hemlock
// Будущее: Улучшенное сообщение об ошибках
try {
    let result = risky_c_function();
} catch (e) {
    print("Ошибка FFI: " + e);
}
```

**6. Типобезопасность**
```hemlock
// Будущее: Аннотации типов для FFI
@ffi("libm.so")
fn sqrt(x: f64): f64;

let result = sqrt(16.0);  // Проверка типов
```

### Возможности

**v1.0:**
- Базовый FFI с примитивными типами
- Динамическая загрузка библиотек
- Вызов функций
- Поддержка коллбэков через замыкания libffi

**Будущее:**
- Поддержка структур
- Улучшения обработки массивов
- Автоматическая генерация связей

## FFI-коллбэки

Hemlock поддерживает передачу функций в код C как коллбэки с использованием замыканий libffi. Это позволяет интегрироваться с C API, ожидающими указатели на функции, такими как `qsort`, циклы событий и библиотеки на основе коллбэков.

### Создание коллбэков

Используйте `callback()` для создания C-вызываемого указателя на функцию из функции Hemlock:

```hemlock
// callback(функция, типы_параметров, тип_возврата) -> ptr
let cb = callback(my_function, ["ptr", "ptr"], "i32");
```

**Параметры:**
- `function`: Функция Hemlock для обёртки
- `param_types`: Массив строк имён типов (например, `["ptr", "i32"]`)
- `return_type`: Строка типа возврата (например, `"i32"`, `"void"`)

**Поддерживаемые типы коллбэков:**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - Знаковые целые
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - Беззнаковые целые
- `"f32"`, `"f64"` - Числа с плавающей точкой
- `"ptr"` - Указатель
- `"void"` - Нет возвращаемого значения
- `"bool"` - Булево значение

### Пример: qsort

```hemlock
import "libc.so.6";
extern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;

// Функция сравнения для целых чисел (по возрастанию)
fn compare_ints(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    if (va < vb) { return -1; }
    if (va > vb) { return 1; }
    return 0;
}

// Выделение массива из 5 целых чисел
let arr = alloc(20);  // 5 * 4 байта
ptr_write_i32(arr, 5);
ptr_write_i32(ptr_offset(arr, 1, 4), 2);
ptr_write_i32(ptr_offset(arr, 2, 4), 8);
ptr_write_i32(ptr_offset(arr, 3, 4), 1);
ptr_write_i32(ptr_offset(arr, 4, 4), 9);

// Создание коллбэка и сортировка
let cmp = callback(compare_ints, ["ptr", "ptr"], "i32");
qsort(arr, 5, 4, cmp);

// Массив теперь отсортирован: [1, 2, 5, 8, 9]

// Очистка
callback_free(cmp);
free(arr);
```

### Вспомогательные функции указателей

Hemlock предоставляет всеобъемлющие вспомогательные функции для работы с сырыми указателями. Они необходимы для FFI-коллбэков и прямой манипуляции памятью.

#### Вспомогательные функции для целочисленных типов

| Функция | Описание |
|---------|----------|
| `ptr_deref_i8(ptr)` | Разыменование указателя, чтение i8 |
| `ptr_deref_i16(ptr)` | Разыменование указателя, чтение i16 |
| `ptr_deref_i32(ptr)` | Разыменование указателя, чтение i32 |
| `ptr_deref_i64(ptr)` | Разыменование указателя, чтение i64 |
| `ptr_deref_u8(ptr)` | Разыменование указателя, чтение u8 |
| `ptr_deref_u16(ptr)` | Разыменование указателя, чтение u16 |
| `ptr_deref_u32(ptr)` | Разыменование указателя, чтение u32 |
| `ptr_deref_u64(ptr)` | Разыменование указателя, чтение u64 |
| `ptr_write_i8(ptr, value)` | Запись i8 по адресу указателя |
| `ptr_write_i16(ptr, value)` | Запись i16 по адресу указателя |
| `ptr_write_i32(ptr, value)` | Запись i32 по адресу указателя |
| `ptr_write_i64(ptr, value)` | Запись i64 по адресу указателя |
| `ptr_write_u8(ptr, value)` | Запись u8 по адресу указателя |
| `ptr_write_u16(ptr, value)` | Запись u16 по адресу указателя |
| `ptr_write_u32(ptr, value)` | Запись u32 по адресу указателя |
| `ptr_write_u64(ptr, value)` | Запись u64 по адресу указателя |

#### Вспомогательные функции для типов с плавающей точкой

| Функция | Описание |
|---------|----------|
| `ptr_deref_f32(ptr)` | Разыменование указателя, чтение f32 (float) |
| `ptr_deref_f64(ptr)` | Разыменование указателя, чтение f64 (double) |
| `ptr_write_f32(ptr, value)` | Запись f32 по адресу указателя |
| `ptr_write_f64(ptr, value)` | Запись f64 по адресу указателя |

#### Вспомогательные функции для типов указателей

| Функция | Описание |
|---------|----------|
| `ptr_deref_ptr(ptr)` | Разыменование указателя на указатель |
| `ptr_write_ptr(ptr, value)` | Запись указателя по адресу указателя |
| `ptr_offset(ptr, index, size)` | Вычисление смещения: `ptr + index * size` |
| `ptr_read_i32(ptr)` | Чтение i32 через указатель на указатель (для коллбэков qsort) |
| `ptr_null()` | Получение константы нулевого указателя |

#### Вспомогательные функции преобразования буферов

| Функция | Описание |
|---------|----------|
| `buffer_ptr(buffer)` | Получение сырого указателя из буфера |
| `ptr_to_buffer(ptr, size)` | Копирование данных из указателя в новый буфер |

#### Утилитарные функции FFI

| Функция | Описание |
|---------|----------|
| `ffi_sizeof(type_name)` | Получение размера в байтах FFI-типа |

**Поддерживаемые имена типов для `ffi_sizeof`:**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - Знаковые целые (1, 2, 4, 8 байт)
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - Беззнаковые целые (1, 2, 4, 8 байт)
- `"f32"`, `"f64"` - Числа с плавающей точкой (4, 8 байт)
- `"ptr"` - Указатель (8 байт на 64-бит)
- `"size_t"`, `"usize"` - Платформо-зависимый тип размера
- `"intptr_t"`, `"isize"` - Платформо-зависимый знаковый тип указателя

#### Пример: Работа с разными типами

```hemlock
let p = alloc(64);

// Запись и чтение целых чисел
ptr_write_i8(p, 42);
print(ptr_deref_i8(p));  // 42

ptr_write_i64(ptr_offset(p, 1, 8), 9000000000);
print(ptr_deref_i64(ptr_offset(p, 1, 8)));  // 9000000000

// Запись и чтение чисел с плавающей точкой
ptr_write_f64(p, 3.14159);
print(ptr_deref_f64(p));  // 3.14159

// Указатель на указатель
let inner = alloc(4);
ptr_write_i32(inner, 999);
ptr_write_ptr(p, inner);
let retrieved = ptr_deref_ptr(p);
print(ptr_deref_i32(retrieved));  // 999

// Получение размеров типов
print(ffi_sizeof("i64"));  // 8
print(ffi_sizeof("ptr"));  // 8 (на 64-бит)

// Преобразование буфера
let buf = buffer(64);
ptr_write_i32(buffer_ptr(buf), 12345);
print(ptr_deref_i32(buffer_ptr(buf)));  // 12345

free(inner);
free(p);
```

### Освобождение коллбэков

**Важно:** Всегда освобождайте коллбэки по завершении для предотвращения утечек памяти:

```hemlock
let cb = callback(my_fn, ["ptr"], "void");
// ... использование коллбэка ...
callback_free(cb);  // Освобождение по завершении
```

Коллбэки также автоматически освобождаются при завершении программы.

### Замыкания в коллбэках

Коллбэки захватывают окружение замыкания, поэтому они могут обращаться к переменным внешней области видимости:

```hemlock
let multiplier = 10;

fn scale(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    // Можно обращаться к 'multiplier' из внешней области видимости
    return (va * multiplier) - (vb * multiplier);
}

let cmp = callback(scale, ["ptr", "ptr"], "i32");
```

### Потокобезопасность

Вызовы коллбэков сериализуются мьютексом для обеспечения потокобезопасности, поскольку интерпретатор Hemlock не полностью потокобезопасен. Это означает:
- Только один коллбэк может выполняться одновременно
- Безопасно использовать с многопоточными библиотеками C
- Может влиять на производительность, если коллбэки вызываются очень часто из нескольких потоков

### Обработка ошибок в коллбэках

Исключения, выброшенные в коллбэках, не могут распространяться в код C. Вместо этого:
- Выводится предупреждение в stderr
- Коллбэк возвращает значение по умолчанию (0 или NULL)
- Исключение логируется, но не распространяется

```hemlock
fn risky_callback(a: ptr): i32 {
    throw "Что-то пошло не так";  // Выводится предупреждение, возвращается 0
}
```

Для надёжной обработки ошибок валидируйте входные данные и избегайте выбрасывания в коллбэках.

## FFI-структуры

Hemlock поддерживает передачу структур по значению в функции C. Типы структур автоматически регистрируются для FFI, когда вы определяете их с аннотациями типов.

### Определение FFI-совместимых структур

Структура FFI-совместима, когда все поля имеют явные аннотации типов с использованием FFI-совместимых типов:

```hemlock
// FFI-совместимая структура
define Point {
    x: f64,
    y: f64,
}

// FFI-совместимая структура с несколькими типами полей
define Rectangle {
    top_left: Point,      // Вложенная структура
    width: f64,
    height: f64,
}

// НЕ FFI-совместима (поле без аннотации типа)
define DynamicObject {
    name,                 // Нет типа - нельзя использовать в FFI
    value,
}
```

### Использование структур в FFI

Объявление extern-функций, использующих типы структур:

```hemlock
// Определение типа структуры
define Vector2D {
    x: f64,
    y: f64,
}

// Импорт библиотеки C
import "libmath.so";

// Объявление extern-функции, принимающей/возвращающей структуры
extern fn vector_add(a: Vector2D, b: Vector2D): Vector2D;
extern fn vector_length(v: Vector2D): f64;

// Естественное использование
let a: Vector2D = { x: 3.0, y: 0.0 };
let b: Vector2D = { x: 0.0, y: 4.0 };
let result = vector_add(a, b);
print(result.x);  // 3.0
print(result.y);  // 4.0

let len = vector_length(result);
print(len);       // 5.0
```

### Поддерживаемые типы полей

Поля структур должны использовать эти FFI-совместимые типы:

| Тип Hemlock | Тип C | Размер |
|-------------|-------|--------|
| `i8` | `int8_t` | 1 байт |
| `i16` | `int16_t` | 2 байта |
| `i32` | `int32_t` | 4 байта |
| `i64` | `int64_t` | 8 байт |
| `u8` | `uint8_t` | 1 байт |
| `u16` | `uint16_t` | 2 байта |
| `u32` | `uint32_t` | 4 байта |
| `u64` | `uint64_t` | 8 байт |
| `f32` | `float` | 4 байта |
| `f64` | `double` | 8 байт |
| `ptr` | `void*` | 8 байт |
| `string` | `char*` | 8 байт |
| `bool` | `int` | варьируется |
| Вложенная структура | struct | варьируется |

### Расположение структур

Hemlock использует нативные правила расположения структур платформы (соответствие C ABI):
- Поля выравниваются в соответствии с их типом
- Вставляется заполнение по необходимости
- Общий размер дополняется для выравнивания наибольшего члена

```hemlock
// Пример: C-совместимое расположение
define Mixed {
    a: i8,    // смещение 0, размер 1
              // 3 байта заполнения
    b: i32,   // смещение 4, размер 4
}
// Общий размер: 8 байт (с заполнением)

define Point3D {
    x: f64,   // смещение 0, размер 8
    y: f64,   // смещение 8, размер 8
    z: f64,   // смещение 16, размер 8
}
// Общий размер: 24 байта (заполнение не требуется)
```

### Вложенные структуры

Структуры могут содержать другие структуры:

```hemlock
define Inner {
    x: i32,
    y: i32,
}

define Outer {
    inner: Inner,
    z: i32,
}

import "mylib.so";
extern fn process_nested(data: Outer): i32;

let obj: Outer = {
    inner: { x: 1, y: 2 },
    z: 3,
};
let result = process_nested(obj);
```

### Возвращаемые значения структур

Функции C могут возвращать структуры:

```hemlock
define Point {
    x: f64,
    y: f64,
}

import "libmath.so";
extern fn get_origin(): Point;

let p = get_origin();
print(p.x);  // 0.0
print(p.y);  // 0.0
```

### Ограничения

- **Поля структур должны иметь аннотации типов** - поля без типов не FFI-совместимы
- **Нет массивов в структурах** - используйте указатели вместо них
- **Нет объединений (union)** - поддерживаются только типы структур
- **Коллбэки не могут возвращать структуры** - используйте указатели для возвращаемых значений коллбэков

### Экспорт типов структур

Вы можете экспортировать определения типов структур из модуля с помощью `export define`:

```hemlock
// geometry.hml
export define Vector2 {
    x: f32,
    y: f32,
}

export define Rectangle {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
}

export fn create_rect(x: f32, y: f32, w: f32, h: f32): Rectangle {
    return { x: x, y: y, width: w, height: h };
}
```

**Важно:** Экспортированные типы структур регистрируются **глобально** при загрузке модуля. Они становятся доступны автоматически, когда вы импортируете что-либо из модуля. Вам НЕ нужно (и невозможно) явно импортировать их по имени:

```hemlock
// main.hml

// ХОРОШО - типы структур авто-доступны после любого импорта из модуля
import { create_rect } from "./geometry.hml";
let v: Vector2 = { x: 1.0, y: 2.0 };      // Работает - Vector2 глобально доступен
let r: Rectangle = create_rect(0.0, 0.0, 100.0, 50.0);  // Работает

// ПЛОХО - нельзя явно импортировать типы структур по имени
import { Vector2 } from "./geometry.hml";  // Ошибка: Undefined variable 'Vector2'
```

Это поведение существует потому, что типы структур регистрируются в глобальном реестре типов при загрузке модуля, а не хранятся как значения в экспортном окружении модуля. Тип становится доступным для всего кода, который импортирует из модуля.

## Текущие ограничения

FFI имеет следующие ограничения:

**1. Ручное преобразование типов**
- Необходимо вручную управлять преобразованием строк
- Нет автоматического преобразования строка Hemlock <-> строка C

**2. Ограниченная обработка ошибок**
- Базовое сообщение об ошибках
- Исключения в коллбэках не могут распространяться в C

**3. Ручная загрузка библиотек**
- Необходимо вручную загружать библиотеки
- Нет автоматической генерации связей

**4. Платформо-специфичный код**
- Пути библиотек различаются по платформам
- Необходимо обрабатывать .so vs .dylib vs .dll

## Лучшие практики

Пока полная документация FFI ещё разрабатывается, вот общие лучшие практики:

### 1. Типобезопасность

```hemlock
// Будьте явны с типами
let x: i32 = 42;
let result: f64 = c_function(x);
```

### 2. Управление памятью

```hemlock
// Помните об освобождении выделенной памяти
let ptr = c_malloc(1024);
// ... использование ptr
c_free(ptr);
```

### 3. Проверка ошибок

```hemlock
// Проверяйте возвращаемые значения
let result = c_function();
if (result == null) {
    print("Функция C завершилась с ошибкой");
}
```

### 4. Кроссплатформенная совместимость

```hemlock
// Обрабатывайте различия платформ
// Используйте соответствующие расширения библиотек (.so, .dylib, .dll)
```

## Примеры

Для рабочих примеров обращайтесь к:
- Тесты коллбэков: `/tests/ffi_callbacks/` - примеры коллбэков qsort
- Использование FFI в stdlib: `/stdlib/hash.hml`, `/stdlib/regex.hml`, `/stdlib/crypto.hml`
- Примеры программ: `/examples/` (если доступны)

## Получение помощи

FFI - относительно новая функция в Hemlock. По вопросам или проблемам:

1. Проверьте набор тестов для рабочих примеров
2. Обратитесь к документации libffi для низкоуровневых деталей
3. Сообщайте об ошибках или запрашивайте функции через issues проекта

## Итог

FFI Hemlock предоставляет:

- Вызов функций C из разделяемых библиотек
- Поддержка примитивных типов (i8-i64, u8-u64, f32, f64, ptr)
- Автоматическое преобразование типов
- Переносимость на основе libffi
- Основа для интеграции с нативными библиотеками
- **Коллбэки с указателями на функции** - передача функций Hemlock в C
- **Экспорт extern-функций** - совместное использование FFI-связей между модулями
- **Передача и возврат структур** - передача C-совместимых структур по значению
- **Export define** - совместное использование определений типов структур между модулями (авто-импорт глобально)
- **Полные вспомогательные функции указателей** - чтение/запись всех типов (i8-i64, u8-u64, f32, f64, ptr)
- **Преобразование буфер/указатель** - `buffer_ptr()`, `ptr_to_buffer()` для маршалинга данных
- **Размеры FFI-типов** - `ffi_sizeof()` для платформо-зависимых размеров типов
- **Платформенные типы** - поддержка `size_t`, `usize`, `isize`, `intptr_t`, `uintptr_t`

**Текущий статус:** FFI полнофункционален с примитивными типами, структурами, коллбэками, экспортами модулей и полными вспомогательными функциями указателей

**Будущее:** Вспомогательные функции маршалинга строк

**Случаи использования:** Системные библиотеки, сторонние библиотеки, qsort, циклы событий, API на основе коллбэков, переиспользуемые обёртки библиотек

## Участие

Документация FFI расширяется. Если вы работаете с FFI:
- Документируйте свои случаи использования
- Делитесь примерами кода
- Сообщайте о проблемах или ограничениях
- Предлагайте улучшения

Система FFI разработана для практичности и безопасности при предоставлении низкоуровневого доступа при необходимости, следуя философии Hemlock "явное важнее неявного" и "unsafe - это функция, а не баг".
