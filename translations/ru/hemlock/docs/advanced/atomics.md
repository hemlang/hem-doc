# Атомарные операции

Hemlock предоставляет атомарные операции для **неблокирующего конкурентного программирования**. Эти операции позволяют безопасно манипулировать общей памятью между несколькими потоками без традиционных блокировок или мьютексов.

## Содержание

- [Обзор](#обзор)
- [Когда использовать атомарные операции](#когда-использовать-атомарные-операции)
- [Модель памяти](#модель-памяти)
- [Атомарная загрузка и сохранение](#атомарная-загрузка-и-сохранение)
- [Операции получения и модификации](#операции-получения-и-модификации)
- [Сравнение и обмен (CAS)](#сравнение-и-обмен-cas)
- [Атомарный обмен](#атомарный-обмен)
- [Барьер памяти](#барьер-памяти)
- [Справочник функций](#справочник-функций)
- [Распространённые паттерны](#распространённые-паттерны)
- [Лучшие практики](#лучшие-практики)
- [Ограничения](#ограничения)

---

## Обзор

Атомарные операции - это **неделимые** операции, которые завершаются без возможности прерывания. Когда один поток выполняет атомарную операцию, никакой другой поток не может наблюдать операцию в частично завершённом состоянии.

**Ключевые особенности:**
- Все операции используют **последовательную согласованность** (`memory_order_seq_cst`)
- Поддерживаемые типы: **i32** и **i64**
- Операции работают с сырыми указателями, выделенными через `alloc()`
- Потокобезопасность без явных блокировок

**Доступные операции:**
- Load/Store - Атомарное чтение и запись значений
- Add/Sub - Арифметические операции, возвращающие старое значение
- And/Or/Xor - Побитовые операции, возвращающие старое значение
- CAS - Сравнение и обмен для условных обновлений
- Exchange - Атомарный обмен значениями
- Fence - Полный барьер памяти

---

## Когда использовать атомарные операции

**Используйте атомарные операции для:**
- Счётчиков, разделяемых между задачами (например, подсчёт запросов, отслеживание прогресса)
- Флагов и индикаторов состояния
- Неблокирующих структур данных
- Простых примитивов синхронизации
- Критичного к производительности конкурентного кода

**Используйте каналы вместо них когда:**
- Передача сложных данных между задачами
- Реализация паттернов производитель-потребитель
- Вам нужна семантика передачи сообщений

**Пример использования - Общий счётчик:**
```hemlock
// Выделение общего счётчика
let counter = alloc(4);
ptr_write_i32(counter, 0);

async fn worker(counter: ptr, id: i32) {
    let i = 0;
    while (i < 1000) {
        atomic_add_i32(counter, 1);
        i = i + 1;
    }
}

// Порождение нескольких воркеров
let t1 = spawn(worker, counter, 1);
let t2 = spawn(worker, counter, 2);
let t3 = spawn(worker, counter, 3);

join(t1);
join(t2);
join(t3);

// Счётчик будет ровно 3000 (без гонок данных)
print(atomic_load_i32(counter));

free(counter);
```

---

## Модель памяти

Все атомарные операции Hemlock используют **последовательную согласованность** (`memory_order_seq_cst`), которая предоставляет самые сильные гарантии упорядочивания памяти:

1. **Атомарность**: Каждая операция неделима
2. **Полное упорядочивание**: Все потоки видят одинаковый порядок операций
3. **Нет переупорядочивания**: Операции не переупорядочиваются компилятором или CPU

Это упрощает рассуждения о конкурентном коде, ценой некоторой потенциальной производительности по сравнению с более слабыми упорядочиваниями памяти.

---

## Атомарная загрузка и сохранение

### atomic_load_i32 / atomic_load_i64

Атомарное чтение значения из памяти.

**Сигнатура:**
```hemlock
atomic_load_i32(ptr: ptr): i32
atomic_load_i64(ptr: ptr): i64
```

**Параметры:**
- `ptr` - Указатель на ячейку памяти (должен быть правильно выровнен)

**Возвращает:** Значение в ячейке памяти

**Пример:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);

let value = atomic_load_i32(p);
print(value);  // 42

free(p);
```

---

### atomic_store_i32 / atomic_store_i64

Атомарная запись значения в память.

**Сигнатура:**
```hemlock
atomic_store_i32(ptr: ptr, value: i32): null
atomic_store_i64(ptr: ptr, value: i64): null
```

**Параметры:**
- `ptr` - Указатель на ячейку памяти
- `value` - Значение для сохранения

**Возвращает:** `null`

**Пример:**
```hemlock
let p = alloc(8);

atomic_store_i64(p, 5000000000);
print(atomic_load_i64(p));  // 5000000000

free(p);
```

---

## Операции получения и модификации

Эти операции атомарно модифицируют значение и возвращают **старое** (предыдущее) значение.

### atomic_add_i32 / atomic_add_i64

Атомарное добавление к значению.

**Сигнатура:**
```hemlock
atomic_add_i32(ptr: ptr, value: i32): i32
atomic_add_i64(ptr: ptr, value: i64): i64
```

**Возвращает:** **Старое** значение (до добавления)

**Пример:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_add_i32(p, 10);
print(old);                    // 100 (старое значение)
print(atomic_load_i32(p));     // 110 (новое значение)

free(p);
```

---

### atomic_sub_i32 / atomic_sub_i64

Атомарное вычитание из значения.

**Сигнатура:**
```hemlock
atomic_sub_i32(ptr: ptr, value: i32): i32
atomic_sub_i64(ptr: ptr, value: i64): i64
```

**Возвращает:** **Старое** значение (до вычитания)

**Пример:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_sub_i32(p, 25);
print(old);                    // 100 (старое значение)
print(atomic_load_i32(p));     // 75 (новое значение)

free(p);
```

---

### atomic_and_i32 / atomic_and_i64

Атомарное выполнение побитового И.

**Сигнатура:**
```hemlock
atomic_and_i32(ptr: ptr, value: i32): i32
atomic_and_i64(ptr: ptr, value: i64): i64
```

**Возвращает:** **Старое** значение (до И)

**Пример:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xFF);  // 255 в двоичном: 11111111

let old = atomic_and_i32(p, 0x0F);  // И с 00001111
print(old);                    // 255 (старое значение)
print(atomic_load_i32(p));     // 15 (0xFF & 0x0F = 0x0F)

free(p);
```

---

### atomic_or_i32 / atomic_or_i64

Атомарное выполнение побитового ИЛИ.

**Сигнатура:**
```hemlock
atomic_or_i32(ptr: ptr, value: i32): i32
atomic_or_i64(ptr: ptr, value: i64): i64
```

**Возвращает:** **Старое** значение (до ИЛИ)

**Пример:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0x0F);  // 15 в двоичном: 00001111

let old = atomic_or_i32(p, 0xF0);  // ИЛИ с 11110000
print(old);                    // 15 (старое значение)
print(atomic_load_i32(p));     // 255 (0x0F | 0xF0 = 0xFF)

free(p);
```

---

### atomic_xor_i32 / atomic_xor_i64

Атомарное выполнение побитового исключающего ИЛИ.

**Сигнатура:**
```hemlock
atomic_xor_i32(ptr: ptr, value: i32): i32
atomic_xor_i64(ptr: ptr, value: i64): i64
```

**Возвращает:** **Старое** значение (до XOR)

**Пример:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xAA);  // 170 в двоичном: 10101010

let old = atomic_xor_i32(p, 0xFF);  // XOR с 11111111
print(old);                    // 170 (старое значение)
print(atomic_load_i32(p));     // 85 (0xAA ^ 0xFF = 0x55)

free(p);
```

---

## Сравнение и обмен (CAS)

Самая мощная атомарная операция. Атомарно сравнивает текущее значение с ожидаемым и, если они совпадают, заменяет его новым значением.

### atomic_cas_i32 / atomic_cas_i64

**Сигнатура:**
```hemlock
atomic_cas_i32(ptr: ptr, expected: i32, desired: i32): bool
atomic_cas_i64(ptr: ptr, expected: i64, desired: i64): bool
```

**Параметры:**
- `ptr` - Указатель на ячейку памяти
- `expected` - Значение, которое мы ожидаем найти
- `desired` - Значение для сохранения, если ожидание совпало

**Возвращает:**
- `true` - Обмен успешен (значение было `expected`, теперь `desired`)
- `false` - Обмен не удался (значение не было `expected`, без изменений)

**Пример:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

// CAS успешен: значение 100, меняем на 999
let success1 = atomic_cas_i32(p, 100, 999);
print(success1);               // true
print(atomic_load_i32(p));     // 999

// CAS неуспешен: значение 999, не 100
let success2 = atomic_cas_i32(p, 100, 888);
print(success2);               // false
print(atomic_load_i32(p));     // 999 (без изменений)

free(p);
```

**Случаи использования:**
- Реализация блокировок и семафоров
- Неблокирующие структуры данных
- Оптимистичный контроль конкурентности
- Атомарные условные обновления

---

## Атомарный обмен

Атомарный обмен значениями, возвращающий старое значение.

### atomic_exchange_i32 / atomic_exchange_i64

**Сигнатура:**
```hemlock
atomic_exchange_i32(ptr: ptr, value: i32): i32
atomic_exchange_i64(ptr: ptr, value: i64): i64
```

**Параметры:**
- `ptr` - Указатель на ячейку памяти
- `value` - Новое значение для сохранения

**Возвращает:** **Старое** значение (до обмена)

**Пример:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_exchange_i32(p, 200);
print(old);                    // 100 (старое значение)
print(atomic_load_i32(p));     // 200 (новое значение)

free(p);
```

---

## Барьер памяти

Полный барьер памяти, гарантирующий, что все операции с памятью до барьера видимы всем потокам до любых операций после барьера.

### atomic_fence

**Сигнатура:**
```hemlock
atomic_fence(): null
```

**Возвращает:** `null`

**Пример:**
```hemlock
// Гарантирует, что все предыдущие записи видимы
atomic_fence();
```

**Примечание:** В большинстве случаев вам не нужны явные барьеры, потому что все атомарные операции уже используют последовательную согласованность. Барьеры полезны, когда нужно синхронизировать неатомарные операции с памятью.

---

## Справочник функций

### Операции i32

| Функция | Сигнатура | Возвращает | Описание |
|---------|-----------|------------|----------|
| `atomic_load_i32` | `(ptr)` | `i32` | Атомарная загрузка значения |
| `atomic_store_i32` | `(ptr, value)` | `null` | Атомарное сохранение значения |
| `atomic_add_i32` | `(ptr, value)` | `i32` | Сложение и возврат старого значения |
| `atomic_sub_i32` | `(ptr, value)` | `i32` | Вычитание и возврат старого значения |
| `atomic_and_i32` | `(ptr, value)` | `i32` | Побитовое И и возврат старого значения |
| `atomic_or_i32` | `(ptr, value)` | `i32` | Побитовое ИЛИ и возврат старого значения |
| `atomic_xor_i32` | `(ptr, value)` | `i32` | Побитовое XOR и возврат старого значения |
| `atomic_cas_i32` | `(ptr, expected, desired)` | `bool` | Сравнение и обмен |
| `atomic_exchange_i32` | `(ptr, value)` | `i32` | Обмен и возврат старого значения |

### Операции i64

| Функция | Сигнатура | Возвращает | Описание |
|---------|-----------|------------|----------|
| `atomic_load_i64` | `(ptr)` | `i64` | Атомарная загрузка значения |
| `atomic_store_i64` | `(ptr, value)` | `null` | Атомарное сохранение значения |
| `atomic_add_i64` | `(ptr, value)` | `i64` | Сложение и возврат старого значения |
| `atomic_sub_i64` | `(ptr, value)` | `i64` | Вычитание и возврат старого значения |
| `atomic_and_i64` | `(ptr, value)` | `i64` | Побитовое И и возврат старого значения |
| `atomic_or_i64` | `(ptr, value)` | `i64` | Побитовое ИЛИ и возврат старого значения |
| `atomic_xor_i64` | `(ptr, value)` | `i64` | Побитовое XOR и возврат старого значения |
| `atomic_cas_i64` | `(ptr, expected, desired)` | `bool` | Сравнение и обмен |
| `atomic_exchange_i64` | `(ptr, value)` | `i64` | Обмен и возврат старого значения |

### Барьер памяти

| Функция | Сигнатура | Возвращает | Описание |
|---------|-----------|------------|----------|
| `atomic_fence` | `()` | `null` | Полный барьер памяти |

---

## Распространённые паттерны

### Паттерн: Атомарный счётчик

```hemlock
// Потокобезопасный счётчик
let counter = alloc(4);
ptr_write_i32(counter, 0);

fn increment(): i32 {
    return atomic_add_i32(counter, 1);
}

fn decrement(): i32 {
    return atomic_sub_i32(counter, 1);
}

fn get_count(): i32 {
    return atomic_load_i32(counter);
}

// Использование
increment();  // Возвращает 0 (старое значение)
increment();  // Возвращает 1
increment();  // Возвращает 2
print(get_count());  // 3

free(counter);
```

### Паттерн: Спинлок

```hemlock
// Простая реализация спинлока
let lock = alloc(4);
ptr_write_i32(lock, 0);  // 0 = разблокирован, 1 = заблокирован

fn acquire() {
    // Крутимся пока не установим блокировку с 0 на 1
    while (!atomic_cas_i32(lock, 0, 1)) {
        // Активное ожидание
    }
}

fn release() {
    atomic_store_i32(lock, 0);
}

// Использование
acquire();
// ... критическая секция ...
release();

free(lock);
```

### Паттерн: Однократная инициализация

```hemlock
let initialized = alloc(4);
ptr_write_i32(initialized, 0);  // 0 = не инициализирован, 1 = инициализирован

fn ensure_initialized() {
    // Пытаемся быть тем, кто инициализирует
    if (atomic_cas_i32(initialized, 0, 1)) {
        // Мы выиграли гонку, выполняем инициализацию
        do_expensive_init();
    }
    // Иначе уже инициализировано
}
```

### Паттерн: Атомарный флаг

```hemlock
let flag = alloc(4);
ptr_write_i32(flag, 0);

fn set_flag() {
    atomic_store_i32(flag, 1);
}

fn clear_flag() {
    atomic_store_i32(flag, 0);
}

fn test_and_set(): bool {
    // Возвращает true если флаг уже был установлен
    return atomic_exchange_i32(flag, 1) == 1;
}

fn check_flag(): bool {
    return atomic_load_i32(flag) == 1;
}
```

### Паттерн: Ограниченный счётчик

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);
let max_value = 100;

fn try_increment(): bool {
    while (true) {
        let current = atomic_load_i32(counter);
        if (current >= max_value) {
            return false;  // Достигнут максимум
        }
        if (atomic_cas_i32(counter, current, current + 1)) {
            return true;  // Успешно увеличено
        }
        // CAS не удался, другой поток модифицировал - повторяем
    }
}
```

---

## Лучшие практики

### 1. Используйте правильное выравнивание

Указатели должны быть правильно выровнены для типа данных:
- i32: выравнивание по 4 байтам
- i64: выравнивание по 8 байтам

Память из `alloc()` обычно правильно выровнена.

### 2. Предпочитайте абстракции более высокого уровня

Когда возможно, используйте каналы для межзадачной коммуникации. Атомарные операции более низкоуровневые и требуют тщательного продумывания.

```hemlock
// Предпочтительно:
let ch = channel(10);
spawn(fn() { ch.send(result); });
let value = ch.recv();

// Вместо ручной атомарной координации когда это уместно
```

### 3. Помните о проблеме ABA

CAS может страдать от проблемы ABA: значение меняется с A на B и обратно на A. Ваш CAS успешен, но состояние могло измениться между проверками.

### 4. Инициализируйте перед разделением

Всегда инициализируйте атомарные переменные перед порождением задач, которые к ним обращаются:

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);  // Инициализируем ДО порождения

let task = spawn(worker, counter);
```

### 5. Освобождайте после завершения всех задач

Не освобождайте атомарную память пока задачи ещё могут к ней обращаться:

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);

let t1 = spawn(worker, counter);
let t2 = spawn(worker, counter);

join(t1);
join(t2);

// Теперь безопасно освободить
free(counter);
```

---

## Ограничения

### Текущие ограничения

1. **Поддерживаются только i32 и i64** - Нет атомарных операций для других типов
2. **Нет атомарных операций с указателями** - Невозможно атомарно загружать/сохранять указатели
3. **Только последовательная согласованность** - Нет более слабых упорядочиваний памяти
4. **Нет атомарной плавающей точки** - Используйте целочисленное представление при необходимости

### Примечания по платформам

- Атомарные операции используют C11 `<stdatomic.h>` внутренне
- Доступны на всех платформах, поддерживающих POSIX-потоки
- Гарантированно неблокирующие на современных 64-битных системах

---

## Смотрите также

- [Асинхронность/Конкурентность](async-concurrency.md) - Порождение задач и каналы
- [Управление памятью](../language-guide/memory.md) - Указатели и выделение буферов
- [API памяти](../reference/memory-api.md) - Функции выделения памяти
