# Владение памятью в Hemlock

> "Мы даём вам инструменты для безопасности, но не заставляем их использовать."

Этот документ описывает семантику владения памятью в Hemlock, охватывая как память, управляемую программистом, так и значения, управляемые средой выполнения.

## Содержание

1. [Контракт](#контракт)
2. [Память, управляемая программистом](#память-управляемая-программистом)
3. [Значения, управляемые средой выполнения](#значения-управляемые-средой-выполнения)
4. [Точки передачи владения](#точки-передачи-владения)
5. [Async и параллелизм](#async-и-параллелизм)
6. [Правила памяти FFI](#правила-памяти-ffi)
7. [Безопасность исключений](#безопасность-исключений)
8. [Лучшие практики](#лучшие-практики)

---

## Контракт

Hemlock имеет чёткое разделение ответственности за управление памятью:

| Тип памяти | Управляется | Метод очистки |
|------------|-------------|---------------|
| Сырые указатели (`ptr`) | **Программист** | `free(ptr)` |
| Буферы (`buffer`) | **Программист** | `free(buf)` |
| Строки, массивы, объекты | **Среда выполнения** | Автоматически (подсчёт ссылок) |
| Функции, замыкания | **Среда выполнения** | Автоматически (подсчёт ссылок) |
| Задачи, каналы | **Среда выполнения** | Автоматически (подсчёт ссылок) |

**Основной принцип:** Если вы выделяете явно, вы освобождаете явно. Всё остальное обрабатывается автоматически.

---

## Память, управляемая программистом

### Сырые указатели

```hemlock
let p = alloc(64);       // Выделить 64 байта
memset(p, 0, 64);        // Инициализировать
// ... использовать память ...
free(p);                 // Ваша ответственность!
```

**Правила:**
- `alloc()` возвращает память, которой владеете вы
- Вы должны вызвать `free()` по завершении
- Двойное освобождение приведёт к краху (намеренно)
- Использование после освобождения — неопределённое поведение
- Арифметика указателей разрешена, но не проверяется

### Типизированное выделение

```hemlock
let arr = talloc("i32", 100);  // Выделить 100 i32 (400 байт)
ptr_write_i32(arr, 0, 42);     // Записать в индекс 0
let val = ptr_read_i32(arr, 0); // Прочитать из индекса 0
free(arr);                      // Всё ещё ваша ответственность
```

### Буферы (безопасная альтернатива)

```hemlock
let buf = buffer(64);    // Буфер с проверкой границ
buf[0] = 42;             // Безопасная индексация
// buf[100] = 1;         // Ошибка времени выполнения: выход за границы
free(buf);               // Всё ещё требует явного free
```

**Ключевое отличие:** Буферы обеспечивают проверку границ, сырые указатели — нет.

---

## Значения, управляемые средой выполнения

### Подсчёт ссылок

Значения, выделенные в куче, используют атомарный подсчёт ссылок:

```hemlock
let s1 = "hello";        // Строка выделена, refcount = 1
let s2 = s1;             // s2 разделяет s1, refcount = 2
// Когда оба выходят из области видимости, refcount → 0, память освобождена
```

**Типы с подсчётом ссылок:**
- `string` — текст UTF-8
- `array` — динамические массивы
- `object` — объекты ключ-значение
- `function` — замыкания
- `task` — дескрипторы асинхронных задач
- `channel` — каналы связи

### Обнаружение циклов

Среда выполнения обрабатывает циклы в графах объектов:

```hemlock
let a = { ref: null };
let b = { ref: a };
a.ref = b;               // Цикл: a → b → a
// Среда выполнения использует множества посещённых для обнаружения и разрыва циклов при очистке
```

---

## Точки передачи владения

### Привязка переменных

```hemlock
let x = [1, 2, 3];       // Массив создан с refcount 1
                         // x владеет ссылкой
```

### Возврат из функций

```hemlock
fn make_array() {
    return [1, 2, 3];    // Владение массивом передаётся вызывающему
}
let arr = make_array();  // arr теперь владеет ссылкой
```

### Присваивание

```hemlock
let a = "hello";
let b = a;               // Разделяемая ссылка (refcount увеличен)
b = "world";             // a всё ещё имеет "hello", b имеет "world"
```

### Операции с каналами

```hemlock
let ch = channel(10);
ch.send("message");      // Значение копируется в буфер канала
                         // Оригинал остаётся действительным

let msg = ch.recv();     // Получает владение от канала
```

### Запуск задач

```hemlock
let data = { x: 1 };
let task = spawn(worker, data);  // data ГЛУБОКО КОПИРУЕТСЯ для изоляции
data.x = 2;                       // Безопасно — задача имеет свою копию
let result = join(task);          // Владение result передаётся вызывающему
```

---

## Async и параллелизм

### Изоляция потоков

Запущенные задачи получают **глубокие копии** изменяемых аргументов:

```hemlock
async fn worker(data) {
    data.x = 100;        // Изменяет только копию задачи
    return data;
}

let obj = { x: 1 };
let task = spawn(worker, obj);
obj.x = 2;               // Безопасно — не влияет на задачу
let result = join(task);
print(obj.x);            // 2 (не изменено задачей)
print(result.x);         // 100 (изменённая копия задачи)
```

### Разделяемые объекты координации

Некоторые типы разделяются по ссылке (не копируются):
- **Каналы** — для межзадачной связи
- **Задачи** — для координации (join/detach)

```hemlock
let ch = channel(1);
spawn(producer, ch);     // Тот же канал, не копия
spawn(consumer, ch);     // Обе задачи разделяют канал
```

### Результаты задач

```hemlock
let task = spawn(compute);
let result = join(task);  // Вызывающий владеет результатом
                          // Ссылка задачи освобождается при освобождении задачи
```

### Отсоединённые задачи

```hemlock
detach(spawn(background_work));
// Задача выполняется независимо
// Результат автоматически освобождается при завершении задачи
// Нет утечки, даже если никто не вызывает join()
```

---

## Правила памяти FFI

### Передача в функции C

```hemlock
extern fn strlen(s: string): i32;

let s = "hello";
let len = strlen(s);     // Hemlock сохраняет владение
                         // Строка действительна во время вызова
                         // Функция C НЕ должна её освобождать
```

### Получение от функций C

```hemlock
extern fn strdup(s: string): ptr;

let copy = strdup("hello");  // C выделил эту память
free(copy);                   // Ваша ответственность освободить
```

### Передача структур (только компилятор)

```hemlock
// Определить layout структуры C
ffi_struct Point { x: f64, y: f64 }

extern fn make_point(x: f64, y: f64): Point;

let p = make_point(1.0, 2.0);  // Возвращено по значению, скопировано
                                // Не нужна очистка для стековых структур
```

### Память обратных вызовов

```hemlock
// Когда C вызывает обратно в Hemlock:
// - Аргументы принадлежат C (не освобождать)
// - Владение возвращаемым значением передаётся C
```

---

## Безопасность исключений

### Гарантии

Среда выполнения предоставляет эти гарантии:

1. **Нет утечки при нормальном выходе** — все значения, управляемые средой выполнения, очищаются
2. **Нет утечки при исключении** — временные значения освобождаются при раскрутке стека
3. **Defer выполняется при исключении** — код очистки выполняется

### Вычисление выражений

```hemlock
// Если это бросает исключение при создании массива:
let arr = [f(), g(), h()];  // Частичный массив освобождается

// Если это бросает при вызове функции:
foo(a(), b(), c());         // Ранее вычисленные аргументы освобождаются
```

### Defer для очистки

```hemlock
fn process_file() {
    let f = open("data.txt", "r");
    defer f.close();         // Выполняется при return ИЛИ исключении

    let data = f.read();
    if (data == "") {
        throw "Empty file";  // f.close() всё равно выполнится!
    }
    return data;
}
```

---

## Лучшие практики

### 1. Предпочитайте типы, управляемые средой выполнения

```hemlock
// Предпочитайте это:
let data = [1, 2, 3, 4, 5];

// Вместо этого (если не нужен низкоуровневый контроль):
let data = talloc("i32", 5);
// ... нужно помнить об освобождении ...
```

### 2. Используйте Defer для ручной памяти

```hemlock
fn process() {
    let buf = alloc(1024);
    defer free(buf);        // Гарантированная очистка

    // ... использовать buf ...
    // Не нужно освобождать в каждой точке возврата
}
```

### 3. Избегайте сырых указателей в async

```hemlock
// НЕПРАВИЛЬНО — указатель может быть освобождён до завершения задачи
let p = alloc(64);
spawn(worker, p);          // Задача получает значение указателя
free(p);                   // Упс! Задача всё ещё использует его

// ПРАВИЛЬНО — используйте каналы или копируйте данные
let ch = channel(1);
let data = buffer(64);
// ... заполнить data ...
ch.send(data);             // Глубокое копирование
spawn(worker, ch);
free(data);                // Безопасно — задача имеет свою копию
```

### 4. Закрывайте каналы по завершении

```hemlock
let ch = channel(10);
// ... использовать канал ...
ch.close();                // Очищает и освобождает буферизованные значения
```

### 5. Join или Detach задачи

```hemlock
let task = spawn(work);

// Вариант 1: Ждать результат
let result = join(task);

// Вариант 2: Fire and forget
// detach(task);

// НЕ ДЕЛАЙТЕ: Позволять дескриптору задачи выйти из области видимости без join или detach
// (Он будет очищен, но результат может утечь)
```

---

## Отладка проблем с памятью

### Включить ASAN

```bash
make asan
ASAN_OPTIONS=detect_leaks=1 ./hemlock script.hml
```

### Запустить регрессионные тесты утечек

```bash
make leak-regression       # Полный набор
make leak-regression-quick # Пропустить исчерпывающий тест
```

### Valgrind

```bash
make valgrind-check FILE=script.hml
```

---

## Сводка

| Операция | Поведение памяти |
|----------|-----------------|
| `alloc(n)` | Выделяет, вы освобождаете |
| `buffer(n)` | Выделяет с проверкой границ, вы освобождаете |
| `"string"` | Управляет среда выполнения |
| `[array]` | Управляет среда выполнения |
| `{object}` | Управляет среда выполнения |
| `spawn(fn)` | Глубоко копирует аргументы, среда выполнения управляет задачей |
| `join(task)` | Вызывающий владеет результатом |
| `detach(task)` | Среда выполнения освобождает результат по завершении |
| `ch.send(v)` | Копирует значение в канал |
| `ch.recv()` | Вызывающий владеет полученным значением |
| `ch.close()` | Очищает и освобождает буферизованные значения |
