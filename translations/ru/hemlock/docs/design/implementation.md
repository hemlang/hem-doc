# Детали реализации Hemlock

Этот документ описывает техническую реализацию языка Hemlock, включая структуру проекта, конвейер компиляции, архитектуру среды выполнения и проектные решения.

---

## Содержание

- [Структура проекта](#структура-проекта)
- [Конвейер компиляции](#конвейер-компиляции)
- [Модульный дизайн интерпретатора](#модульный-дизайн-интерпретатора)
- [Архитектура среды выполнения](#архитектура-среды-выполнения)
- [Представление значений](#представление-значений)
- [Реализация системы типов](#реализация-системы-типов)
- [Управление памятью](#управление-памятью)
- [Модель конкурентности](#модель-конкурентности)
- [Планы на будущее](#планы-на-будущее)

---

## Структура проекта

```
hemlock/
├── src/
│   ├── frontend/              # Общее: лексер, парсер, AST
│   │   ├── lexer.c            # Токенизация
│   │   ├── parser/            # Рекурсивный нисходящий парсер
│   │   ├── ast.c              # Управление узлами AST
│   │   └── module.c           # Разрешение модулей
│   ├── backends/
│   │   ├── interpreter/       # hemlock: обходящий дерево интерпретатор
│   │   │   ├── main.c         # Точка входа CLI
│   │   │   ├── runtime.c      # Вычисление выражений/операторов
│   │   │   ├── builtins.c     # Встроенные функции
│   │   │   └── ...
│   │   └── compiler/          # hemlockc: генератор C-кода
│   │       ├── main.c         # CLI, оркестрация
│   │       ├── type_check.c   # Проверка типов на этапе компиляции
│   │       ├── codegen.c      # Контекст генерации кода
│   │       ├── codegen_expr.c # Генерация кода для выражений
│   │       ├── codegen_stmt.c # Генерация кода для операторов
│   │       └── ...
│   ├── tools/
│   │   ├── lsp/               # Language Server Protocol
│   │   └── bundler/           # Инструменты сборки/упаковки
├── runtime/                   # libhemlock_runtime.a (для скомпилированных программ)
├── stdlib/                    # Стандартная библиотека (39 модулей)
│   └── docs/                  # Документация модулей
├── tests/
│   ├── parity/                # Тесты, которые должны проходить на обоих бэкендах
│   ├── interpreter/           # Тесты, специфичные для интерпретатора
│   └── compiler/              # Тесты, специфичные для компилятора
├── examples/                  # Примеры программ
└── docs/                      # Документация
```

### Организация директорий

**`include/`** — Заголовочные файлы публичного API, определяющие интерфейс между компонентами:
- Чёткое разделение между лексером, парсером, AST и интерпретатором
- Предварительные объявления для минимизации зависимостей
- Публичный API для встраивания Hemlock в другие программы

**`src/`** — Файлы реализации:
- Файлы верхнего уровня обрабатывают лексический анализ, парсинг, управление AST
- `main.c` предоставляет CLI и REPL
- Интерпретатор разбит на модули по отдельным подсистемам

**`src/interpreter/`** — Модульная реализация интерпретатора:
- Каждый модуль имеет единственную, чёткую ответственность
- Внутренний API определён в `internal.h` для межмодульного взаимодействия
- Модули можно компилировать независимо для более быстрой сборки

**`tests/`** — Комплексный набор тестов:
- Организован по функциональным областям
- Каждая директория содержит фокусированные тестовые случаи
- `run_tests.sh` оркестрирует выполнение тестов

---

## Конвейер компиляции

Hemlock использует традиционный конвейер компиляции с отдельными фазами:

### Фаза 1: Лексический анализ (Лексер)

**Вход:** Текст исходного кода
**Выход:** Поток токенов
**Реализация:** `src/lexer.c`

```
Исходный код: "let x = 42;"
   ↓
Токены: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
```

**Ключевые возможности:**
- Распознаёт ключевые слова, идентификаторы, литералы, операторы, пунктуацию
- Обрабатывает строковые литералы UTF-8 и руны
- Сообщает номера строк для сообщений об ошибках
- Однопроходный, без возвратов

### Фаза 2: Синтаксический анализ (Парсер)

**Вход:** Поток токенов
**Выход:** Абстрактное синтаксическое дерево (AST)
**Реализация:** `src/parser.c`

```
Токены: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
   ↓
AST: LetStmt {
    name: "x",
    type: null,
    value: IntLiteral(42)
}
```

**Ключевые возможности:**
- Рекурсивный нисходящий парсер
- Строит древовидное представление структуры программы
- Обрабатывает приоритет операторов
- Проверяет синтаксис (фигурные скобки, точки с запятой и т.д.)
- Пока без семантического анализа (выполняется во время работы)

**Приоритет операторов (от низшего к высшему):**
1. Присваивание: `=`
2. Логическое ИЛИ: `||`
3. Логическое И: `&&`
4. Побитовое ИЛИ: `|`
5. Побитовое исключающее ИЛИ: `^`
6. Побитовое И: `&`
7. Равенство: `==`, `!=`
8. Сравнение: `<`, `>`, `<=`, `>=`
9. Побитовые сдвиги: `<<`, `>>`
10. Сложение/Вычитание: `+`, `-`
11. Умножение/Деление/Остаток: `*`, `/`, `%`
12. Унарные: `!`, `-`, `~`
13. Вызов/Индекс/Член: `()`, `[]`, `.`

### Фаза 3a: Интерпретация (Обход дерева)

**Вход:** AST
**Выход:** Выполнение программы
**Реализация:** `src/backends/interpreter/runtime.c`

```
AST: LetStmt { ... }
   ↓
Выполнение: Рекурсивно вычисляет узлы AST
   ↓
Результат: Создана переменная x со значением 42
```

**Ключевые возможности:**
- Прямой обход AST (интерпретатор с обходом дерева)
- Динамическая проверка типов во время выполнения
- Хранение переменных на основе окружений

### Фаза 3b: Компиляция (hemlockc)

**Вход:** AST
**Выход:** Нативный исполняемый файл через генерацию C-кода
**Реализация:** `src/backends/compiler/`

```
AST: LetStmt { ... }
   ↓
Проверка типов: Валидация типов на этапе компиляции
   ↓
Генерация C: Генерация эквивалентного C-кода
   ↓
GCC: Компиляция C в нативный бинарный файл
   ↓
Результат: Автономный исполняемый файл
```

**Ключевые возможности:**
- Проверка типов на этапе компиляции (включена по умолчанию)
- Генерация C-кода для переносимости
- Компоновка с `libhemlock_runtime.a`
- Значительно более быстрое выполнение, чем интерпретатор

---

## Бэкенд компилятора (hemlockc)

Компилятор Hemlock генерирует C-код из AST, который затем компилируется в нативный исполняемый файл с помощью GCC.

### Архитектура компилятора

```
src/backends/compiler/
├── main.c              # CLI, разбор аргументов, оркестрация
├── codegen.c           # Основной контекст генерации кода
├── codegen_expr.c      # Генерация кода для выражений
├── codegen_stmt.c      # Генерация кода для операторов
├── codegen_call.c      # Генерация вызовов функций
├── codegen_closure.c   # Реализация замыканий
├── codegen_program.c   # Генерация программы верхнего уровня
├── codegen_module.c    # Обработка модулей/импортов
├── type_check.c        # Проверка типов на этапе компиляции
└── type_check.h        # API проверки типов
```

### Проверка типов

Компилятор включает унифицированную систему проверки типов, которая:

1. **Валидирует типы на этапе компиляции** — Обнаруживает ошибки типов до выполнения
2. **Поддерживает динамический код** — Нетипизированный код трактуется как `any` (всегда валиден)
3. **Предоставляет подсказки для оптимизации** — Определяет переменные, которые можно распаковать

**Флаги проверки типов:**

| Флаг | Описание |
|------|----------|
| (по умолчанию) | Проверка типов включена |
| `--check` | Только проверка типов, без компиляции |
| `--no-type-check` | Отключить проверку типов |
| `--strict-types` | Предупреждать о неявных типах `any` |

**Реализация проверки типов:**

```c
// type_check.h — Ключевые структуры
typedef struct TypeCheckContext {
    const char *filename;
    int error_count;
    int warning_count;
    UnboxableVar *unboxable_vars;  // Подсказки для оптимизации
    // ... окружение типов, определения и т.д.
} TypeCheckContext;

// Главная точка входа
int type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);
```

### Генерация кода

Фаза генерации кода преобразует узлы AST в C-код:

**Отображение выражений:**
```
Hemlock                 →  Сгенерированный C
----------------------------------------
let x = 42;            →  HmlValue x = hml_val_i32(42);
x + y                  →  hml_add(x, y)
arr[i]                 →  hml_array_get(arr, i)
obj.field              →  hml_object_get_field(obj, "field")
fn(a, b) { ... }       →  Замыкание с захватом окружения
```

**Интеграция со средой выполнения:**

Сгенерированный C-код компонуется с `libhemlock_runtime.a`, которая предоставляет:
- Тегированное объединение `HmlValue`
- Управление памятью (подсчёт ссылок)
- Встроенные функции (print, typeof и т.д.)
- Примитивы конкурентности (задачи, каналы)
- Поддержка FFI

### Оптимизация распаковки

Проверка типов определяет переменные, которые могут использовать нативные типы C вместо упакованных `HmlValue`:

**Паттерны для распаковки:**
- Счётчики циклов с известным целочисленным типом
- Переменные-аккумуляторы в циклах
- Переменные с явными аннотациями типов (i32, i64, f64, bool)

```hemlock
// Счётчик цикла 'i' может быть распакован в нативный int32_t
for (let i: i32 = 0; i < 1000000; i = i + 1) {
    sum = sum + i;
}
```

---

## Модульный дизайн интерпретатора

Интерпретатор разделён на фокусированные модули для поддерживаемости и масштабируемости.

### Ответственности модулей

#### 1. Окружение (`environment.c`) — 121 строка

**Назначение:** Области видимости переменных и разрешение имён

**Ключевые функции:**
- `env_create()` — Создать новое окружение с опциональным родителем
- `env_define()` — Определить новую переменную в текущей области
- `env_get()` — Поиск переменной в текущей или родительских областях
- `env_set()` — Обновить значение существующей переменной
- `env_free()` — Освободить окружение и все переменные

**Дизайн:**
- Связанные области (каждое окружение имеет указатель на родителя)
- HashMap для быстрого поиска переменных
- Поддержка лексических областей для замыканий

#### 2. Значения (`values.c`) — 394 строки

**Назначение:** Конструкторы значений и управление структурами данных

**Ключевые функции:**
- `value_create_*()` — Конструкторы для каждого типа значения
- `value_copy()` — Логика глубокого/поверхностного копирования
- `value_free()` — Очистка и освобождение памяти
- `value_to_string()` — Строковое представление для печати

**Структуры данных:**
- Объекты (динамические массивы полей)
- Массивы (динамическое изменение размера)
- Буферы (ptr + length + capacity)
- Замыкания (функция + захваченное окружение)
- Задачи и каналы (примитивы конкурентности)

#### 3. Типы (`types.c`) — 440 строк

**Назначение:** Система типов, преобразования и утиная типизация

**Ключевые функции:**
- `type_check()` — Валидация типов во время выполнения
- `type_convert()` — Неявные преобразования/повышения типов
- `duck_type_check()` — Структурная проверка типов для объектов
- `type_name()` — Получить печатаемое имя типа

**Возможности:**
- Иерархия повышения типов (i8 → i16 → i32 → i64 → f32 → f64, при этом i64/u64 + f32 → f64)
- Проверка диапазонов для числовых типов
- Утиная типизация для определений типов объектов
- Значения по умолчанию для опциональных полей

#### 4. Встроенные функции (`builtins.c`) — 955 строк

**Назначение:** Встроенные функции и глобальная регистрация

**Ключевые функции:**
- `register_builtins()` — Регистрация всех встроенных функций и констант
- Реализации встроенных функций (print, typeof, alloc, free и т.д.)
- Функции обработки сигналов
- Выполнение команд (exec)

**Категории встроенных:**
- Ввод/вывод: print, open, read_file, write_file
- Память: alloc, free, memset, memcpy, realloc
- Типы: typeof, assert
- Конкурентность: spawn, join, detach, channel
- Система: exec, signal, raise, panic
- FFI: dlopen, dlsym, dlcall, dlclose

#### 5. Ввод/вывод (`io.c`) — 449 строк

**Назначение:** Файловый ввод/вывод и сериализация JSON

**Ключевые функции:**
- Методы файлового объекта (read, write, seek, tell, close)
- Сериализация/десериализация JSON
- Обнаружение циклических ссылок

**Возможности:**
- Файловый объект со свойствами (path, mode, closed)
- Текстовый ввод/вывод с учётом UTF-8
- Поддержка бинарного ввода/вывода
- Двусторонняя конвертация JSON для объектов и массивов

#### 6. FFI (`ffi.c`) — Интерфейс внешних функций

**Назначение:** Вызов C-функций из разделяемых библиотек

**Ключевые функции:**
- `dlopen()` — Загрузить разделяемую библиотеку
- `dlsym()` — Получить указатель на функцию по имени
- `dlcall()` — Вызвать C-функцию с преобразованием типов
- `dlclose()` — Выгрузить библиотеку

**Возможности:**
- Интеграция с libffi для динамических вызовов функций
- Автоматическое преобразование типов (Hemlock ↔ типы C)
- Поддержка всех примитивных типов
- Поддержка указателей и буферов

#### 7. Среда выполнения (`runtime.c`) — 865 строк

**Назначение:** Вычисление выражений и выполнение операторов

**Ключевые функции:**
- `eval_expr()` — Вычисление выражений (рекурсивно)
- `eval_stmt()` — Выполнение операторов
- Обработка потока управления (if, while, for, switch и т.д.)
- Обработка исключений (try/catch/finally/throw)

**Возможности:**
- Рекурсивное вычисление выражений
- Вычисление булевых выражений с коротким замыканием
- Обнаружение вызовов методов и привязка `self`
- Распространение исключений
- Обработка break/continue/return

### Преимущества модульного дизайна

**1. Разделение ответственности**
- Каждый модуль имеет одну чёткую ответственность
- Легко найти, где реализованы возможности
- Снижает когнитивную нагрузку при внесении изменений

**2. Более быстрые инкрементальные сборки**
- Нужно перекомпилировать только изменённые модули
- Возможна параллельная компиляция
- Более короткое время итерации при разработке

**3. Более простое тестирование и отладка**
- Модули можно тестировать изолированно
- Ошибки локализованы в конкретных подсистемах
- Возможны mock-реализации для тестирования

**4. Масштабируемость**
- Новые возможности можно добавлять в соответствующие модули
- Модули можно рефакторить независимо
- Размер кода на файл остаётся управляемым

**5. Организация кода**
- Логическая группировка связанной функциональности
- Чёткий граф зависимостей
- Более простое введение в курс дела для новых участников

---

## Архитектура среды выполнения

### Представление значений

Все значения в Hemlock представлены структурой `Value` с использованием тегированного объединения:

```c
typedef struct Value {
    ValueType type;  // Тег типа во время выполнения
    union {
        int32_t i32_value;
        int64_t i64_value;
        uint8_t u8_value;
        uint32_t u32_value;
        uint64_t u64_value;
        float f32_value;
        double f64_value;
        bool bool_value;
        char *string_value;
        uint32_t rune_value;
        void *ptr_value;
        Buffer *buffer_value;
        Array *array_value;
        Object *object_value;
        Function *function_value;
        File *file_value;
        Task *task_value;
        Channel *channel_value;
    };
} Value;
```

**Проектные решения:**
- **Тегированное объединение** для безопасности типов при сохранении гибкости
- **Теги типов во время выполнения** позволяют динамическую типизацию с проверкой типов
- **Прямое хранение значений** для примитивов (без упаковки)
- **Хранение указателей** для типов, выделенных в куче (строки, объекты, массивы)

### Примеры расположения в памяти

**Целое число (i32):**
```
Value {
    type: TYPE_I32,
    i32_value: 42
}
```
- Общий размер: ~16 байт (8-байтный тег + 8-байтное объединение)
- Выделено в стеке
- Не требуется выделение в куче

**Строка:**
```
Value {
    type: TYPE_STRING,
    string_value: 0x7f8a4c000000  // Указатель на кучу
}

Куча: "hello\0" (6 байт, null-terminated UTF-8)
```
- Value занимает 16 байт в стеке
- Данные строки выделены в куче
- Должна освобождаться вручную

**Объект:**
```
Value {
    type: TYPE_OBJECT,
    object_value: 0x7f8a4c001000  // Указатель на кучу
}

Куча: Object {
    type_name: "Person",
    fields: [
        { name: "name", value: Value{TYPE_STRING, "Alice"} },
        { name: "age", value: Value{TYPE_I32, 30} }
    ],
    field_count: 2,
    capacity: 4
}
```
- Структура объекта в куче
- Поля хранятся в динамическом массиве
- Значения полей — встроенные структуры Value

### Реализация окружения

Переменные хранятся в цепочках окружений:

```c
typedef struct Environment {
    HashMap *bindings;           // имя → Value
    struct Environment *parent;  // Лексическая родительская область
} Environment;
```

**Пример цепочки областей:**
```
Глобальная область: { print: <builtin>, args: <array> }
    ↑
Область функции: { x: 10, y: 20 }
    ↑
Область блока: { i: 0 }
```

**Алгоритм поиска:**
1. Проверить hashmap текущего окружения
2. Если не найдено, проверить родительское окружение
3. Повторять, пока не найдено или не достигнута глобальная область
4. Ошибка, если не найдено ни в одной области

---

## Реализация системы типов

### Стратегия проверки типов

Hemlock использует **проверку типов во время выполнения** с **опциональными аннотациями типов**:

```hemlock
let x = 42;           // Без проверки типа, выводится i32
let y: u8 = 255;      // Проверка во время выполнения: значение должно помещаться в u8
let z: i32 = x + y;   // Проверка во время выполнения + повышение типа
```

**Поток реализации:**
1. **Вывод литералов** — Лексер/парсер определяют начальный тип по литералу
2. **Проверка аннотации типа** — Если аннотация присутствует, валидация при присваивании
3. **Повышение** — Бинарные операции повышают до общего типа
4. **Преобразование** — Явные преобразования происходят по требованию

### Реализация повышения типов

Повышение типов следует фиксированной иерархии с сохранением точности:

```c
// Упрощённая логика повышения
ValueType promote_types(ValueType a, ValueType b) {
    // f64 всегда выигрывает
    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;

    // f32 с i64/u64 повышается до f64 (сохранение точности)
    if (a == TYPE_F32 || b == TYPE_F32) {
        ValueType other = (a == TYPE_F32) ? b : a;
        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;
        return TYPE_F32;
    }

    // Большие целочисленные типы выигрывают
    int rank_a = get_type_rank(a);
    int rank_b = get_type_rank(b);
    return (rank_a > rank_b) ? a : b;
}
```

**Ранги типов:**
- i8: 0
- u8: 1
- i16: 2
- u16: 3
- i32: 4
- u32: 5
- i64: 6
- u64: 7
- f32: 8
- f64: 9

### Реализация утиной типизации

Проверка типов объектов использует структурное сравнение:

```c
bool duck_type_check(Object *obj, TypeDef *type_def) {
    // Проверить все обязательные поля
    for (each field in type_def) {
        if (!object_has_field(obj, field.name)) {
            return false;  // Отсутствует поле
        }

        Value *field_value = object_get_field(obj, field.name);
        if (!type_matches(field_value, field.type)) {
            return false;  // Неправильный тип
        }
    }

    return true;  // Все обязательные поля присутствуют и имеют правильный тип
}
```

**Утиная типизация позволяет:**
- Дополнительные поля в объектах (игнорируются)
- Субструктурную типизацию (объект может иметь больше, чем требуется)
- Присвоение имени типа после валидации

---

## Управление памятью

### Стратегия выделения

Hemlock использует **ручное управление памятью** с двумя примитивами выделения:

**1. Сырые указатели (`ptr`):**
```c
void *alloc(size_t bytes) {
    void *ptr = malloc(bytes);
    if (!ptr) {
        fprintf(stderr, "Недостаточно памяти\n");
        exit(1);
    }
    return ptr;
}
```
- Прямой malloc/free
- Без отслеживания
- Ответственность пользователя за освобождение

**2. Буферы (`buffer`):**
```c
typedef struct Buffer {
    void *data;
    size_t length;
    size_t capacity;
} Buffer;

Buffer *create_buffer(size_t size) {
    Buffer *buf = malloc(sizeof(Buffer));
    buf->data = malloc(size);
    buf->length = size;
    buf->capacity = size;
    return buf;
}
```
- Отслеживает размер и ёмкость
- Проверка границ при доступе
- Всё ещё требует ручного free

### Типы, выделяемые в куче

**Строки:**
- Массив байтов UTF-8 в куче
- Null-terminated для взаимодействия с C
- Изменяемые (можно модифицировать на месте)
- С подсчётом ссылок (автоматически освобождаются при выходе из области)

**Объекты:**
- Динамический массив полей
- Имена и значения полей в куче
- С подсчётом ссылок (автоматически освобождаются при выходе из области)
- Возможны циклические ссылки (обрабатываются отслеживанием посещённых)

**Массивы:**
- Динамическое удвоение ёмкости при росте
- Элементы — встроенные структуры Value
- Автоматическое перевыделение при росте
- С подсчётом ссылок (автоматически освобождаются при выходе из области)

**Замыкания:**
- Захватывают окружение по ссылке
- Окружение выделяется в куче
- Окружения замыканий корректно освобождаются, когда больше не нужны

---

## Модель конкурентности

### Архитектура потоков

Hemlock использует **потоки 1:1** с POSIX-потоками (pthreads):

```
Задача пользователя    Поток ОС          Ядро CPU
--------------         ---------          --------
spawn(f1) ------>      pthread_create --> Ядро 0
spawn(f2) ------>      pthread_create --> Ядро 1
spawn(f3) ------>      pthread_create --> Ядро 2
```

**Ключевые характеристики:**
- Каждый `spawn()` создаёт новый pthread
- Ядро планирует потоки по ядрам
- Настоящее параллельное выполнение (без GIL)
- Вытесняющая многозадачность

### Реализация задач

```c
typedef struct Task {
    pthread_t thread;        // Дескриптор потока ОС
    Value result;            // Возвращаемое значение
    char *error;             // Сообщение об исключении (если выброшено)
    pthread_mutex_t lock;    // Защищает состояние
    TaskState state;         // RUNNING, FINISHED, ERROR
} Task;
```

**Жизненный цикл задачи:**
1. `spawn(func, args)` → Создать Task, запустить pthread
2. Поток выполняет функцию с аргументами
3. При возврате: Сохранить результат, установить состояние FINISHED
4. При исключении: Сохранить сообщение об ошибке, установить состояние ERROR
5. `join(task)` → Ждать завершения потока, вернуть результат или выбросить исключение

### Реализация каналов

```c
typedef struct Channel {
    void **buffer;           // Кольцевой буфер Value*
    size_t capacity;         // Максимум буферизованных элементов
    size_t count;            // Текущее количество элементов в буфере
    size_t read_index;       // Следующая позиция чтения
    size_t write_index;      // Следующая позиция записи
    bool closed;             // Флаг закрытия канала
    pthread_mutex_t lock;    // Защищает буфер
    pthread_cond_t not_full; // Сигнал о появлении места
    pthread_cond_t not_empty;// Сигнал о появлении данных
} Channel;
```

**Операция отправки:**
1. Захватить мьютекс
2. Ждать, если буфер полон (cond_wait на not_full)
3. Записать значение в buffer[write_index]
4. Увеличить write_index (кольцевой)
5. Сигнализировать not_empty
6. Освободить мьютекс

**Операция получения:**
1. Захватить мьютекс
2. Ждать, если буфер пуст (cond_wait на not_empty)
3. Прочитать значение из buffer[read_index]
4. Увеличить read_index (кольцевой)
5. Сигнализировать not_full
6. Освободить мьютекс

**Гарантии синхронизации:**
- Потокобезопасные send/recv (защищены мьютексом)
- Блокирующая семантика (производитель ждёт, если полон, потребитель ждёт, если пуст)
- Упорядоченная доставка (FIFO в пределах канала)

---

## Планы на будущее

### Завершено: Бэкенд компилятора

Бэкенд компилятора (`hemlockc`) реализован с:
- Генерацией C-кода из AST
- Проверкой типов на этапе компиляции (включена по умолчанию)
- Библиотекой времени выполнения (`libhemlock_runtime.a`)
- Полным паритетом с интерпретатором (98% тестов проходят)
- Фреймворком оптимизации распаковки

### Текущий фокус: Улучшения системы типов

**Недавние улучшения:**
- Унификация систем проверки типов и вывода типов
- Проверка типов на этапе компиляции включена по умолчанию
- Флаг `--check` для валидации только типов
- Контекст типов передаётся в codegen для подсказок оптимизации

### Будущие улучшения

**Потенциальные дополнения:**
- Дженерики/шаблоны
- Сопоставление с образцом
- Интеграция LSP для поддержки IDE с учётом типов
- Более агрессивная оптимизация распаковки
- Анализ убегания для выделения в стеке

### Долгосрочные оптимизации

**Возможные улучшения:**
- Инлайн-кэширование для вызовов методов
- JIT-компиляция для горячих путей кода
- Планировщик с перехватом работы для лучшей конкурентности
- Оптимизация на основе профилирования

---

## Руководства по реализации

### Добавление новых возможностей

При реализации новых возможностей следуйте этим руководствам:

**1. Выбрать правильный модуль:**
- Новые типы значений → `values.c`
- Преобразования типов → `types.c`
- Встроенные функции → `builtins.c`
- Операции ввода/вывода → `io.c`
- Поток управления → `runtime.c`

**2. Обновить все слои:**
- Добавить типы узлов AST при необходимости (`ast.h`, `ast.c`)
- Добавить токены лексера при необходимости (`lexer.c`)
- Добавить правила парсера (`parser.c`)
- Реализовать поведение во время выполнения (`runtime.c` или соответствующий модуль)
- Добавить тесты (`tests/`)

**3. Поддерживать согласованность:**
- Следовать существующему стилю кода
- Использовать согласованные соглашения об именовании
- Документировать публичный API в заголовках
- Поддерживать ясные и согласованные сообщения об ошибках

**4. Тщательно тестировать:**
- Добавить тестовые случаи перед реализацией
- Тестировать успешные и ошибочные пути
- Тестировать граничные случаи
- Проверить отсутствие утечек памяти (valgrind)

### Соображения о производительности

**Текущие узкие места:**
- Поиск в HashMap для доступа к переменным
- Рекурсивные вызовы функций (нет оптимизации хвостовых вызовов)
- Конкатенация строк (выделяет новую строку каждый раз)
- Накладные расходы проверки типов на каждой операции

**Возможности для оптимизации:**
- Кэширование расположения переменных (инлайн-кэширование)
- Оптимизация хвостовых вызовов
- StringBuilder для конкатенации
- Вывод типов для пропуска проверок во время выполнения

### Советы по отладке

**Полезные инструменты:**
- `valgrind` — Обнаружение утечек памяти
- `gdb` — Отладка сбоев
- Флаг `-g` — Отладочные символы
- `printf`-отладка — Просто, но эффективно

**Частые проблемы:**
- Segfault → Разыменование нулевого указателя (проверьте возвращаемые значения)
- Утечка памяти → Отсутствует вызов free() (проверьте пути value_free)
- Ошибка типа → Проверьте логику type_convert() и type_check()
- Сбой в потоках → Состояние гонки (проверьте использование мьютексов)

---

## Заключение

Реализация Hemlock приоритизирует:
- **Модульность** — Чёткое разделение ответственности
- **Простота** — Прямолинейная реализация
- **Явность** — Никакой скрытой магии
- **Поддерживаемость** — Легко понимать и модифицировать

Текущий интерпретатор с обходом дерева намеренно прост для облегчения быстрой разработки возможностей и экспериментирования. Будущий бэкенд компилятора улучшит производительность, сохраняя ту же семантику.
