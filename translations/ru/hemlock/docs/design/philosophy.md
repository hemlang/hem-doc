# Философия дизайна языка Hemlock

> "Маленький, небезопасный язык для безопасного написания небезопасного кода."

Этот документ описывает основные принципы проектирования и философию Hemlock. Прочитайте его в первую очередь, прежде чем вносить какие-либо изменения или дополнения в язык.

---

## Содержание

- [Основная идентичность](#основная-идентичность)
- [Принципы проектирования](#принципы-проектирования)
- [Философия безопасности](#философия-безопасности)
- [Что НЕ добавлять](#что-не-добавлять)
- [Планы на будущее](#планы-на-будущее)
- [Заключительные мысли](#заключительные-мысли)

---

## Основная идентичность

Hemlock — это **системный скриптовый язык**, который использует ручное управление памятью и явный контроль. Он разработан для программистов, которым нужны:

- Мощь языка C
- Эргономика современных скриптовых языков
- Встроенная структурированная асинхронная конкурентность
- Отсутствие скрытого поведения или магии

### Чем Hemlock НЕ является

- **Безопасным для памяти** (висячие указатели — ваша ответственность)
- **Заменой Rust, Go или Lua**
- **Языком, который скрывает от вас сложность**

### Чем Hemlock ЯВЛЯЕТСЯ

- **Явным, а не неявным — всегда**
- **Образовательным и экспериментальным**
- **"Скриптовым слоем C" для системной работы**
- **Честным в отношении компромиссов**

---

## Принципы проектирования

### 1. Явное важнее неявного

Hemlock отдает предпочтение явности во всех языковых конструкциях. Не должно быть сюрпризов, магии и скрытого поведения.

**Плохо (неявно):**
```hemlock
let x = 5  // Отсутствует точка с запятой — должна быть ошибка
```

**Хорошо (явно):**
```hemlock
let x = 5;
free(ptr);  // Вы выделили память — вы её освобождаете
```

**Ключевые аспекты:**
- Точки с запятой обязательны (нет автоматической вставки точек с запятой)
- Нет сборки мусора
- Ручное управление памятью (alloc/free)
- Аннотации типов опциональны, но проверяются во время выполнения
- Нет автоматической очистки ресурсов (нет RAII), но `defer` обеспечивает явную очистку

### 2. Динамический по умолчанию, типизированный по выбору

Каждое значение имеет тег типа во время выполнения, но система разработана так, чтобы быть гибкой и при этом отлавливать ошибки.

**Вывод типов:**
- Малые целые числа (помещаются в i32): `42` → `i32`
- Большие целые числа (> диапазона i32): `9223372036854775807` → `i64`
- Числа с плавающей точкой: `3.14` → `f64`

**Явная типизация при необходимости:**
```hemlock
let x = 42;              // выводится i32 (малое значение)
let y: u8 = 255;         // явно u8
let z = x + y;           // повышается до i32
let big = 5000000000;    // выводится i64 (> максимума i32)
```

**Правила повышения типов** следуют чёткой иерархии от меньшего к большему, при этом числа с плавающей точкой всегда имеют приоритет над целыми.

### 3. Небезопасность — это возможность, а не ошибка

Hemlock не пытается предотвратить все ошибки. Вместо этого он даёт вам инструменты для безопасной работы, позволяя при необходимости включать небезопасное поведение.

**Примеры намеренной небезопасности:**
- Арифметика указателей может переполняться (ответственность пользователя)
- Нет проверки границ для сырых `ptr` (используйте `buffer`, если хотите безопасности)
- Двойное освобождение памяти приводит к сбою (ручное управление памятью)
- Система типов предотвращает случайности, но позволяет намеренные опасные операции

```hemlock
let p = alloc(10);
let q = p + 100;  // Далеко за пределами выделенной памяти — разрешено, но опасно
```

**Философия:** Система типов должна предотвращать *случайности*, но позволять *намеренные* небезопасные операции.

### 4. Структурированная конкурентность как первоклассная возможность

Конкурентность в Hemlock — не второстепенная мысль. Она встроена в язык с самого начала.

**Ключевые возможности:**
- `async`/`await` встроены в язык
- Каналы для коммуникации
- `spawn`/`join`/`detach` для управления задачами
- Никаких сырых потоков, никаких блокировок — только структурированная конкурентность
- Настоящий многопоточный параллелизм с использованием POSIX-потоков

**Не событийный цикл и не зелёные потоки** — Hemlock использует настоящие потоки ОС для истинного параллелизма на нескольких ядрах процессора.

### 5. C-подобный синтаксис, минимум церемоний

Hemlock должен быть знаком системным программистам, при этом уменьшая шаблонный код.

**Дизайнерские решения:**
- Блоки `{}` всегда обязательны, никаких опциональных скобок
- Операторы как в C: `+`, `-`, `*`, `/`, `&&`, `||`, `!`
- Синтаксис типов как в Rust/TypeScript: `let x: type = value;`
- Функции — первоклассные значения
- Минимум ключевых слов и специальных форм

---

## Философия безопасности

**Позиция Hemlock по безопасности:**

> "Мы даём вам инструменты для безопасности (`buffer`, аннотации типов, проверка границ), но не заставляем их использовать (`ptr`, ручная работа с памятью, небезопасные операции).
>
> По умолчанию следует направлять к безопасности, но аварийный выход должен быть всегда доступен."

### Предоставляемые инструменты безопасности

**1. Безопасный тип buffer:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // проверка границ
print(b.length);        // 64
free(b);                // всё ещё ручное освобождение
```

**2. Небезопасные сырые указатели:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // Вы должны помнить об освобождении
```

**3. Аннотации типов:**
```hemlock
let x: u8 = 255;   // OK
let y: u8 = 256;   // ОШИБКА: выход за пределы диапазона
```

**4. Проверка типов во время выполнения:**
```hemlock
let val = some_function();
if (typeof(val) == "i32") {
    // Безопасно использовать как целое число
}
```

### Руководящие принципы

1. **По умолчанию использовать безопасные паттерны в документации** — Показывать `buffer` перед `ptr`, поощрять аннотации типов
2. **Делать небезопасные операции очевидными** — Арифметика сырых указателей должна выглядеть намеренной
3. **Предоставлять аварийные выходы** — Не мешать опытным пользователям делать низкоуровневую работу
4. **Быть честным о компромиссах** — Документировать, что может пойти не так

### Примеры безопасности vs небезопасности

| Безопасный паттерн | Небезопасный паттерн | Когда использовать небезопасный |
|-------------------|----------------------|--------------------------------|
| тип `buffer` | тип `ptr` | FFI, критичный для производительности код |
| Аннотации типов | Без аннотаций | Внешние интерфейсы, валидация |
| Доступ с проверкой границ | Арифметика указателей | Низкоуровневые операции с памятью |
| Обработка исключений | Возврат null/кодов ошибок | Когда исключения слишком тяжеловесны |

---

## Что НЕ добавлять

Понимание того, что **не** добавлять, так же важно, как знание того, что добавлять.

### Не добавлять неявное поведение

**Плохие примеры:**

```hemlock
// ПЛОХО: Автоматическая вставка точки с запятой
let x = 5
let y = 10

// ПЛОХО: Неявные преобразования типов с потерей точности
let x: i32 = 3.14  // Должно усекать или выдавать ошибку?
```

**Почему:** Неявное поведение создаёт сюрпризы и усложняет понимание кода.

### Не скрывать сложность

**Плохие примеры:**

```hemlock
// ПЛОХО: Магическая закулисная оптимизация
let arr = [1, 2, 3]  // Это в стеке или в куче? Пользователь должен знать! (В куче, с подсчётом ссылок)

// ПЛОХО: Автоматическое освобождение сырого указателя
let p = alloc(100)  // Это освобождается автоматически? НЕТ! Сырые ptr всегда требуют free()
```

**Примечание о подсчёте ссылок:** Hemlock использует внутренний подсчёт ссылок для строк, массивов, объектов и буферов — они АВТОМАТИЧЕСКИ освобождаются при выходе из области видимости. Это явно и предсказуемо (детерминированная очистка при достижении 0 ссылок, без пауз GC). Сырые указатели (`ptr` от `alloc()`) НЕ используют подсчёт ссылок и всегда требуют ручного `free()`.

**Почему:** Скрытая сложность делает невозможным предсказание производительности и отладку проблем.

### Не ломать существующую семантику

**Никогда не меняйте эти основные решения:**
- Точки с запятой обязательны — не делайте их опциональными
- Ручное управление памятью — не добавляйте GC
- Изменяемые строки — не делайте их неизменяемыми
- Проверка типов во время выполнения — не удаляйте её

**Почему:** Согласованность и стабильность важнее модных возможностей.

### Не добавлять "удобные" возможности, которые уменьшают явность

**Примеры возможностей, которых следует избегать:**
- Перегрузка операторов (возможно, для пользовательских типов, но осторожно)
- Неявное приведение типов с потерей информации
- Автоматическая очистка ресурсов (RAII)
- Цепочки методов, которые скрывают сложность
- DSL и магический синтаксис

**Исключение:** Удобные возможности допустимы, если они являются **явным синтаксическим сахаром** над простыми операциями:
- `else if` допустим (это просто вложенные операторы if)
- Интерполяция строк может быть допустима, если это явно синтаксический сахар
- Синтаксис методов для объектов допустим (явно, что он делает)

---

## Планы на будущее

### Возможно добавить (обсуждается)

Эти возможности соответствуют философии Hemlock, но требуют тщательного проектирования:

**1. Сопоставление с образцом**
```hemlock
match (value) {
    case i32: print("целое число");
    case string: print("текст");
    case _: print("другое");
}
```
- Явная проверка типов
- Нет скрытых затрат
- Возможна проверка полноты на этапе компиляции

**2. Типы ошибок (`Result<T, E>`)**
```hemlock
fn divide(a: i32, b: i32): Result<i32, string> {
    if (b == 0) {
        return Err("деление на ноль");
    }
    return Ok(a / b);
}
```
- Явная обработка ошибок
- Заставляет пользователей думать об ошибках
- Альтернатива исключениям

**3. Типы массивов/срезов**
- Уже есть динамические массивы
- Можно добавить массивы фиксированного размера для выделения в стеке
- Нужно быть явным о стеке vs куче

**4. Улучшенные инструменты безопасности памяти**
- Опциональный флаг проверки границ
- Обнаружение утечек памяти в отладочных сборках
- Интеграция санитайзеров

### Вероятно, никогда не добавлять

Эти возможности нарушают основные принципы:

**1. Сборка мусора**
- Скрывает сложность управления памятью
- Непредсказуемая производительность
- Против принципа явного контроля

**2. Автоматическое управление памятью**
- Те же причины, что и у GC
- Подсчёт ссылок может быть допустим, если явный

**3. Неявные преобразования типов с потерей данных**
- Против принципа "явное важнее неявного"
- Источник тонких ошибок

**4. Макросы (сложные)**
- Слишком много мощи, слишком много сложности
- Простая система макросов может быть допустима
- Предпочитать генерацию кода или функции

**5. Классовое ООП с наследованием**
- Слишком много неявного поведения
- Утиной типизации и объектов достаточно
- Композиция важнее наследования

**6. Система модулей со сложным разрешением**
- Импорты должны быть простыми и явными
- Никаких магических путей поиска
- Никакого разрешения версий (используйте пакетный менеджер ОС)

---

## Заключительные мысли

### Доверие и ответственность

Hemlock — это **доверие и ответственность**. Мы доверяем программисту:

- Правильно управлять памятью
- Использовать типы надлежащим образом
- Правильно обрабатывать ошибки
- Понимать компромиссы

Взамен Hemlock предоставляет:

- Никаких скрытых затрат
- Никакого неожиданного поведения
- Полный контроль, когда это нужно
- Инструменты безопасности, когда это желательно

### Главный вопрос

**При рассмотрении новой возможности спросите:**

> "Это даёт программисту больше явного контроля или это что-то скрывает?"

- Если **добавляет явный контроль** → вероятно, подходит Hemlock
- Если **скрывает сложность** → вероятно, не подходит
- Если это **опциональный сахар**, который чётко задокументирован → может быть допустим

### Примеры хороших дополнений

**Операторы switch** — Явный поток управления, без магии, ясная семантика

**Async/await с pthreads** — Явная конкурентность, настоящий параллелизм, пользователь контролирует создание задач

**Тип buffer рядом с ptr** — Даёт выбор между безопасным и небезопасным

**Опциональные аннотации типов** — Помогают отлавливать ошибки без принудительной строгости

**Try/catch/finally** — Явная обработка ошибок с ясным потоком управления

### Примеры плохих дополнений

**Автоматическая вставка точки с запятой** — Скрывает синтаксические ошибки, делает код неоднозначным

**RAII/деструкторы** — Автоматическая очистка скрывает, когда ресурсы освобождаются

**Неявное слияние с null** — Скрывает проверки на null, усложняет понимание кода

**Автоматически растущие строки** — Скрывает выделение памяти, непредсказуемая производительность

---

## Заключение

Hemlock не пытается быть самым безопасным языком, самым быстрым языком или языком с наибольшим количеством возможностей.

**Hemlock пытается быть самым *честным* языком.**

Он говорит вам точно, что делает, даёт контроль, когда это нужно, и не скрывает острые углы. Это язык для людей, которые хотят понимать свой код на низком уровне, наслаждаясь при этом современной эргономикой.

Если вы не уверены, подходит ли возможность для Hemlock, помните:

> **Явное важнее неявного — всегда.**
> **Небезопасность — это возможность, а не ошибка.**
> **Пользователь несёт ответственность, и это нормально.**
