# Пути обучения

Разные цели требуют разных знаний. Выберите путь, который соответствует тому, что вы хотите создать.

---

## Путь 1: Быстрые скрипты и автоматизация

**Цель:** Писать скрипты для автоматизации задач, обработки файлов и выполнения работы.

**Время до продуктивности:** Быстро - вы можете начать писать полезные скрипты немедленно.

### Что вы изучите

1. **[Быстрый старт](quick-start.md)** - Ваша первая программа, базовый синтаксис
2. **[Строки](../language-guide/strings.md)** - Обработка текста, разделение, поиск
3. **[Массивы](../language-guide/arrays.md)** - Списки, фильтрация, преобразование данных
4. **[Файловый ввод/вывод](../advanced/file-io.md)** - Чтение и запись файлов
5. **[Аргументы командной строки](../advanced/command-line-args.md)** - Получение ввода от пользователей

### Пропустите пока

- Управление памятью (автоматическое для скриптов)
- Асинхронность/параллелизм (избыточно для простых скриптов)
- FFI (нужен только для взаимодействия с C)

### Пример проекта: Переименование файлов

```hemlock
import { list_dir, rename } from "@stdlib/fs";

// Переименование всех файлов .txt в .md
let files = list_dir(".");
for (file in files) {
    if (file.ends_with(".txt")) {
        let new_name = file.replace(".txt", ".md");
        rename(file, new_name);
        print(`Переименован: ${file} -> ${new_name}`);
    }
}
```

---

## Путь 2: Обработка и анализ данных

**Цель:** Парсить данные, преобразовывать их, генерировать отчёты.

**Время до продуктивности:** Быстро - методы работы со строками и массивами Hemlock делают это простым.

### Что вы изучите

1. **[Быстрый старт](quick-start.md)** - Основы
2. **[Строки](../language-guide/strings.md)** - Парсинг, разделение, форматирование
3. **[Массивы](../language-guide/arrays.md)** - map, filter, reduce для преобразования данных
4. **[Объекты](../language-guide/objects.md)** - Структурированные данные
5. **Стандартная библиотека:**
   - **[@stdlib/json](../../stdlib/docs/json.md)** - Парсинг JSON
   - **[@stdlib/csv](../../stdlib/docs/csv.md)** - CSV файлы
   - **[@stdlib/fs](../../stdlib/docs/fs.md)** - Файловые операции

### Пример проекта: Анализатор CSV

```hemlock
import { read_file } from "@stdlib/fs";
import { parse } from "@stdlib/csv";

let data = parse(read_file("sales.csv"));

// Вычисление общих продаж
let total = 0;
for (row in data) {
    total = total + f64(row.amount);
}

print(`Общие продажи: $${total}`);

// Поиск лучшей продажи
let top = data[0];
for (row in data) {
    if (f64(row.amount) > f64(top.amount)) {
        top = row;
    }
}

print(`Лучшая продажа: ${top.product} - $${top.amount}`);
```

---

## Путь 3: Веб и сетевое программирование

**Цель:** Создавать HTTP-клиенты, работать с API, создавать серверы.

**Время до продуктивности:** Среднее - требуется понимание основ асинхронности.

### Что вы изучите

1. **[Быстрый старт](quick-start.md)** - Основы
2. **[Функции](../language-guide/functions.md)** - Колбэки и замыкания
3. **[Обработка ошибок](../language-guide/error-handling.md)** - try/catch для сетевых ошибок
4. **[Асинхронность и параллелизм](../advanced/async-concurrency.md)** - spawn, await, каналы
5. **Стандартная библиотека:**
   - **[@stdlib/http](../../stdlib/docs/http.md)** - HTTP-запросы
   - **[@stdlib/json](../../stdlib/docs/json.md)** - JSON для API
   - **[@stdlib/net](../../stdlib/docs/net.md)** - TCP/UDP сокеты
   - **[@stdlib/url](../../stdlib/docs/url.md)** - Парсинг URL

### Пример проекта: API-клиент

```hemlock
import { http_get, http_post } from "@stdlib/http";
import { parse, stringify } from "@stdlib/json";

// GET-запрос
let response = http_get("https://api.example.com/users");
let users = parse(response.body);

for (user in users) {
    print(`${user.name}: ${user.email}`);
}

// POST-запрос
let new_user = { name: "Alice", email: "alice@example.com" };
let result = http_post("https://api.example.com/users", {
    body: stringify(new_user),
    headers: { "Content-Type": "application/json" }
});

print(`Создан пользователь с ID: ${parse(result.body).id}`);
```

---

## Путь 4: Системное программирование

**Цель:** Писать низкоуровневый код, работать с памятью, взаимодействовать с библиотеками C.

**Время до продуктивности:** Дольше - требуется понимание управления памятью.

### Что вы изучите

1. **[Быстрый старт](quick-start.md)** - Основы
2. **[Типы](../language-guide/types.md)** - Понимание i32, u8, ptr и т.д.
3. **[Управление памятью](../language-guide/memory.md)** - alloc, free, буферы
4. **[FFI](../advanced/ffi.md)** - Вызов функций C
5. **[Сигналы](../advanced/signals.md)** - Обработка сигналов

### Ключевые концепции

**Контрольный список безопасности памяти:**
- [ ] Каждому `alloc()` соответствует `free()`
- [ ] Используйте `buffer()`, если не нужен сырой `ptr`
- [ ] Устанавливайте указатели в `null` после освобождения
- [ ] Используйте `try/finally` для гарантированной очистки

**Соответствие типов для FFI:**
| Hemlock | C |
|---------|---|
| `i8` | `char` / `int8_t` |
| `i32` | `int` |
| `i64` | `long` (64-бит) |
| `u8` | `unsigned char` |
| `f64` | `double` |
| `ptr` | `void*` |

### Пример проекта: Собственный пул памяти

```hemlock
// Простой аллокатор с продвижением указателя
let pool_size = 1024 * 1024;  // 1МБ
let pool = alloc(pool_size);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > pool_size) {
        throw "Пул исчерпан";
    }
    let p = pool + pool_offset;
    pool_offset = pool_offset + size;
    return p;
}

fn pool_reset() {
    pool_offset = 0;
}

fn pool_destroy() {
    free(pool);
}

// Использование
let a = pool_alloc(100);
let b = pool_alloc(200);
memset(a, 0, 100);
memset(b, 0, 200);

pool_reset();  // Повторное использование всей памяти
pool_destroy();  // Очистка
```

---

## Путь 5: Параллельные и конкурентные программы

**Цель:** Запускать код на нескольких ядрах CPU, создавать отзывчивые приложения.

**Время до продуктивности:** Среднее - синтаксис async прост, но рассуждения о параллелизме требуют практики.

### Что вы изучите

1. **[Быстрый старт](quick-start.md)** - Основы
2. **[Функции](../language-guide/functions.md)** - Замыкания (важны для async)
3. **[Асинхронность и параллелизм](../advanced/async-concurrency.md)** - Полное погружение
4. **[Атомарные операции](../advanced/atomics.md)** - Программирование без блокировок

### Ключевые концепции

**Асинхронная модель Hemlock:**
- `async fn` - Определение функции, которая может выполняться в другом потоке
- `spawn(fn, args...)` - Запуск выполнения, возвращает дескриптор задачи
- `join(task)` или `await task` - Ожидание завершения, получение результата
- `channel(size)` - Создание очереди для передачи данных между задачами

**Важно:** Задачи получают *копии* значений. Если вы передаёте указатель, вы несёте ответственность за то, чтобы память оставалась действительной до завершения задачи.

### Пример проекта: Параллельная обработка файлов

```hemlock
import { list_dir, read_file } from "@stdlib/fs";

async fn process_file(path: string): i32 {
    let content = read_file(path);
    let lines = content.split("\n");
    return lines.length;
}

// Обработка всех файлов параллельно
let files = list_dir("data/");
let tasks = [];

for (file in files) {
    if (file.ends_with(".txt")) {
        let task = spawn(process_file, "data/" + file);
        tasks.push({ name: file, task: task });
    }
}

// Сбор результатов
let total_lines = 0;
for (item in tasks) {
    let count = join(item.task);
    print(`${item.name}: ${count} строк`);
    total_lines = total_lines + count;
}

print(`Всего: ${total_lines} строк`);
```

---

## С чего начать (для любого пути)

Независимо от вашей цели, начните с этих основ:

### Неделя 1: Базовые основы
1. **[Быстрый старт](quick-start.md)** - Напишите и запустите первую программу
2. **[Синтаксис](../language-guide/syntax.md)** - Переменные, операторы, управление потоком
3. **[Функции](../language-guide/functions.md)** - Определение и вызов функций

### Неделя 2: Работа с данными
4. **[Строки](../language-guide/strings.md)** - Манипуляции с текстом
5. **[Массивы](../language-guide/arrays.md)** - Коллекции и итерация
6. **[Объекты](../language-guide/objects.md)** - Структурированные данные

### Неделя 3: Надёжность
7. **[Обработка ошибок](../language-guide/error-handling.md)** - try/catch/throw
8. **[Модули](../language-guide/modules.md)** - Импорт/экспорт, использование stdlib

### Затем: Выберите свой путь выше

---

## Шпаргалка: Переход с других языков

### С Python

| Python | Hemlock | Примечания |
|--------|---------|------------|
| `x = 42` | `let x = 42;` | Точки с запятой обязательны |
| `def fn():` | `fn name() { }` | Фигурные скобки обязательны |
| `if x:` | `if (x) { }` | Круглые и фигурные скобки обязательны |
| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | Циклы for в стиле C |
| `for item in list:` | `for (item in array) { }` | For-in работает так же |
| `list.append(x)` | `array.push(x);` | Другое имя метода |
| `len(s)` | `s.length` или `len(s)` | Оба работают |
| Автоматическая память | Ручная для `ptr` | Большинство типов очищаются автоматически |

### С JavaScript

| JavaScript | Hemlock | Примечания |
|------------|---------|------------|
| `let x = 42` | `let x = 42;` | То же (точки с запятой обязательны) |
| `const x = 42` | `let x = 42;` | Нет ключевого слова const |
| `function fn()` | `fn name() { }` | Другое ключевое слово |
| `() => x` | `fn() { return x; }` | Нет стрелочных функций |
| `async/await` | `async/await` | Тот же синтаксис |
| `Promise` | `spawn/join` | Другая модель |
| Автоматический GC | Ручной для `ptr` | Большинство типов очищаются автоматически |

### С C/C++

| C | Hemlock | Примечания |
|---|---------|------------|
| `int x = 42;` | `let x: i32 = 42;` | Тип после двоеточия |
| `malloc(n)` | `alloc(n)` | Та же концепция |
| `free(p)` | `free(p)` | То же |
| `char* s = "hi"` | `let s = "hi";` | Строки управляемые |
| `#include` | `import { } from` | Импорт модулей |
| Ручное всё | Авто для большинства типов | Только `ptr` требует ручного управления |

---

## Получение помощи

- **[Глоссарий](../glossary.md)** - Определения терминов программирования
- **[Примеры](../../examples/)** - Полные работающие программы
- **[Тесты](../../tests/)** - Смотрите, как используются возможности
- **GitHub Issues** - Задавайте вопросы, сообщайте об ошибках

---

## Уровни сложности

В документации вы увидите такие маркеры:

| Маркер | Значение |
|--------|----------|
| **Начинающий** | Опыт программирования не требуется |
| **Средний** | Предполагаются базовые знания программирования |
| **Продвинутый** | Требуется понимание системных концепций |

Если что-то с пометкой "Начинающий" вызывает затруднения, проверьте [Глоссарий](../glossary.md) для определений терминов.
