# Справочник по встроенным функциям

Полный справочник по всем встроенным функциям и константам Hemlock.

---

## Обзор

Hemlock предоставляет набор встроенных функций для ввода-вывода, интроспекции типов, управления памятью, параллелизма и взаимодействия с системой. Все встроенные функции доступны глобально без импорта.

---

## Функции ввода-вывода

### print

Вывести значения в stdout с переводом строки.

**Сигнатура:**
```hemlock
print(...values): null
```

**Параметры:**
- `...values` - Любое количество значений для вывода

**Возвращает:** `null`

**Примеры:**
```hemlock
print("Hello, World!");
print(42);
print(3.14);
print(true);
print([1, 2, 3]);
print({ x: 10, y: 20 });

// Несколько значений
print("x =", 10, "y =", 20);
```

**Поведение:**
- Преобразует все значения в строки
- Разделяет несколько значений пробелами
- Добавляет перевод строки в конце
- Сбрасывает буфер stdout

---

### read_line

Прочитать строку текста из stdin (пользовательский ввод).

**Сигнатура:**
```hemlock
read_line(): string | null
```

**Параметры:** Нет

**Возвращает:**
- `string` - Прочитанная строка из stdin (перевод строки удалён)
- `null` - При EOF (конец файла/ввода)

**Примеры:**
```hemlock
// Простой запрос
print("Как вас зовут?");
let name = read_line();
print("Привет, " + name + "!");

// Чтение чисел (требуется ручной разбор)
print("Введите число:");
let input = read_line();
let num = parse_int(input);  // См. ниже parse_int
print("Удвоенное:", num * 2);

// Обработка EOF
let line = read_line();
if (line == null) {
    print("Конец ввода");
}

// Чтение нескольких строк
print("Введите строки (Ctrl+D для остановки):");
while (true) {
    let line = read_line();
    if (line == null) {
        break;
    }
    print("Вы сказали:", line);
}
```

**Поведение:**
- Блокирует до нажатия Enter пользователем
- Удаляет завершающие переводы строки (`\n`) и возвраты каретки (`\r`)
- Возвращает `null` при EOF (Ctrl+D на Unix, Ctrl+Z на Windows)
- Читает только из stdin (не из файлов)

**Разбор пользовательского ввода:**

Поскольку `read_line()` всегда возвращает строку, числовой ввод нужно разбирать вручную:

```hemlock
// Простой парсер целых чисел
fn parse_int(s: string): i32 {
    let result: i32 = 0;
    let negative = false;
    let i = 0;

    if (s.length > 0 && s.char_at(0) == '-') {
        negative = true;
        i = 1;
    }

    while (i < s.length) {
        let c = s.char_at(i);
        let code: i32 = c;
        if (code >= 48 && code <= 57) {
            result = result * 10 + (code - 48);
        } else {
            break;
        }
        i = i + 1;
    }

    if (negative) {
        return -result;
    }
    return result;
}

// Использование
print("Введите ваш возраст:");
let age = parse_int(read_line());
print("Через 10 лет вам будет", age + 10);
```

**См. также:** [API файлов](file-api.md) для чтения из файлов

---

### eprint

Вывести значение в stderr с переводом строки.

**Сигнатура:**
```hemlock
eprint(value: any): null
```

**Параметры:**
- `value` - Одно значение для вывода в stderr

**Возвращает:** `null`

**Примеры:**
```hemlock
eprint("Ошибка: файл не найден");
eprint(404);
eprint("Предупреждение: " + message);

// Типичный паттерн обработки ошибок
fn load_config(path: string) {
    if (!exists(path)) {
        eprint("Ошибка: файл конфигурации не найден: " + path);
        return null;
    }
    // ...
}
```

**Поведение:**
- Выводит в stderr (стандартный поток ошибок)
- Добавляет перевод строки в конце
- Принимает только один аргумент (в отличие от `print`)
- Полезно для сообщений об ошибках, которые не должны смешиваться с обычным выводом

**Отличие от print:**
- `print()` → stdout (обычный вывод, можно перенаправить с помощью `>`)
- `eprint()` → stderr (вывод ошибок, можно перенаправить с помощью `2>`)

```bash
# Пример shell: разделение stdout и stderr
./hemlock script.hml > output.txt 2> errors.txt
```

---

## Интроспекция типов

### typeof

Получить имя типа значения.

**Сигнатура:**
```hemlock
typeof(value: any): string
```

**Параметры:**
- `value` - Любое значение

**Возвращает:** Имя типа как строку

**Примеры:**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("hello"));         // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof(null));            // "null"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"

// Типизированные объекты
define Person { name: string }
let p: Person = { name: "Alice" };
print(typeof(p));               // "Person"

// Другие типы
print(typeof(alloc(10)));       // "ptr"
print(typeof(buffer(10)));      // "buffer"
print(typeof(open("file.txt"))); // "file"
```

**Имена типов:**
- Примитивы: `"i8"`, `"i16"`, `"i32"`, `"i64"`, `"u8"`, `"u16"`, `"u32"`, `"u64"`, `"f32"`, `"f64"`, `"bool"`, `"string"`, `"rune"`, `"null"`
- Составные: `"array"`, `"object"`, `"ptr"`, `"buffer"`, `"function"`
- Специальные: `"file"`, `"task"`, `"channel"`
- Пользовательские: Имена типов от `define`

**См. также:** [Система типов](type-system.md)

---

## Выполнение команд

### exec

Выполнить команду shell и захватить вывод.

**Сигнатура:**
```hemlock
exec(command: string): object
```

**Параметры:**
- `command` - Команда shell для выполнения

**Возвращает:** Объект с полями:
- `output` (string) - Вывод команды в stdout
- `exit_code` (i32) - Код завершения (0 = успех)

**Примеры:**
```hemlock
let result = exec("echo hello");
print(result.output);      // "hello\n"
print(result.exit_code);   // 0

// Проверка кода завершения
let r = exec("grep pattern file.txt");
if (r.exit_code == 0) {
    print("Найдено:", r.output);
} else {
    print("Паттерн не найден");
}

// Обработка многострочного вывода
let r2 = exec("ls -la");
let lines = r2.output.split("\n");
```

**Поведение:**
- Выполняет команду через `/bin/sh`
- Захватывает только stdout (stderr выводится в терминал)
- Блокирует до завершения команды
- Возвращает пустую строку, если нет вывода

**Обработка ошибок:**
```hemlock
try {
    let r = exec("nonexistent_command");
} catch (e) {
    print("Не удалось выполнить:", e);
}
```

**Предупреждение безопасности:** ⚠️ Уязвимо к инъекции shell. Всегда проверяйте/очищайте пользовательский ввод.

**Ограничения:**
- Нет захвата stderr
- Нет потоковой передачи
- Нет таймаута
- Нет обработки сигналов

---

### exec_argv

Выполнить команду с явным массивом аргументов (без интерпретации shell).

**Сигнатура:**
```hemlock
exec_argv(argv: array): object
```

**Параметры:**
- `argv` - Массив строк: `[команда, арг1, арг2, ...]`

**Возвращает:** Объект с полями:
- `output` (string) - Вывод команды в stdout
- `exit_code` (i32) - Код завершения (0 = успех)

**Примеры:**
```hemlock
// Простая команда
let result = exec_argv(["ls", "-la"]);
print(result.output);

// Команда с аргументами, содержащими пробелы (безопасно!)
let r = exec_argv(["grep", "hello world", "file.txt"]);

// Запуск скрипта с аргументами
let r2 = exec_argv(["python", "script.py", "--input", "data.json"]);
print(r2.exit_code);
```

**Отличие от exec:**
```hemlock
// exec() использует shell - НЕБЕЗОПАСНО с пользовательским вводом
exec("ls " + user_input);  // Риск инъекции shell!

// exec_argv() обходит shell - БЕЗОПАСНО
exec_argv(["ls", user_input]);  // Инъекция невозможна
```

**Когда использовать:**
- Когда аргументы содержат пробелы, кавычки или специальные символы
- При обработке пользовательского ввода (безопасность)
- Когда нужен предсказуемый разбор аргументов

**См. также:** `exec()` для простых команд shell

---

## Обработка ошибок

### throw

Выбросить исключение.

**Сигнатура:**
```hemlock
throw expression
```

**Параметры:**
- `expression` - Значение для выбрасывания (любой тип)

**Возвращает:** Никогда не возвращает (передаёт управление)

**Примеры:**
```hemlock
throw "сообщение об ошибке";
throw 404;
throw { code: 500, message: "Внутренняя ошибка" };
throw null;
```

**См. также:** Операторы try/catch/finally

---

### panic

Немедленно завершить программу с сообщением об ошибке (невосстановимо).

**Сигнатура:**
```hemlock
panic(message?: any): never
```

**Параметры:**
- `message` (необязательно) - Сообщение об ошибке для вывода

**Возвращает:** Никогда не возвращает (программа завершается)

**Примеры:**
```hemlock
panic();                          // По умолчанию: "panic!"
panic("достигнут недостижимый код");
panic(42);

// Типичный случай использования
fn process_state(state: i32): string {
    if (state == 1) { return "ready"; }
    if (state == 2) { return "running"; }
    panic("недопустимое состояние: " + typeof(state));
}
```

**Поведение:**
- Выводит ошибку в stderr: `panic: <сообщение>`
- Завершается с кодом 1
- **НЕ перехватывается** с помощью try/catch
- Используется для багов и невосстановимых ошибок

**Panic vs Throw:**
- `panic()` - Невосстановимая ошибка, немедленное завершение
- `throw` - Восстановимая ошибка, может быть перехвачена

---

### assert

Утверждать, что условие истинно, или завершить с сообщением об ошибке.

**Сигнатура:**
```hemlock
assert(condition: any, message?: string): null
```

**Параметры:**
- `condition` - Значение для проверки на истинность
- `message` (необязательно) - Пользовательское сообщение при неудаче утверждения

**Возвращает:** `null` (если утверждение прошло)

**Примеры:**
```hemlock
// Базовые утверждения
assert(x > 0);
assert(name != null);
assert(arr.length > 0, "Массив не должен быть пустым");

// С пользовательскими сообщениями
fn divide(a: i32, b: i32): f64 {
    assert(b != 0, "Деление на ноль");
    return a / b;
}

// Проверка аргументов функции
fn process_data(data: array) {
    assert(data != null, "data не может быть null");
    assert(data.length > 0, "data не может быть пустым");
    // ...
}
```

**Поведение:**
- Если условие истинно: возвращает `null`, выполнение продолжается
- Если условие ложно: выводит ошибку и завершается с кодом 1
- Ложные значения: `false`, `0`, `0.0`, `null`, `""` (пустая строка)
- Истинные значения: всё остальное

**Вывод при неудаче:**
```
Assertion failed: Массив не должен быть пустым
```

**Когда использовать:**
- Проверка предусловий функций
- Проверка инвариантов при разработке
- Раннее обнаружение ошибок программиста

**assert vs panic:**
- `assert(cond, msg)` - Проверяет условие, завершается если ложно
- `panic(msg)` - Всегда завершается безусловно

---

## Обработка сигналов

### signal

Зарегистрировать или сбросить обработчик сигнала.

**Сигнатура:**
```hemlock
signal(signum: i32, handler: function | null): function | null
```

**Параметры:**
- `signum` - Номер сигнала (используйте константы типа `SIGINT`)
- `handler` - Функция для вызова при получении сигнала, или `null` для сброса к умолчанию

**Возвращает:** Предыдущую функцию-обработчик или `null`

**Примеры:**
```hemlock
fn handle_interrupt(sig) {
    print("Перехвачен SIGINT!");
}

signal(SIGINT, handle_interrupt);

// Сброс к умолчанию
signal(SIGINT, null);
```

**Сигнатура обработчика:**
```hemlock
fn handler(signum: i32) {
    // signum содержит номер сигнала
}
```

**См. также:**
- [Константы сигналов](#константы-сигналов)
- `raise()`

---

### raise

Отправить сигнал текущему процессу.

**Сигнатура:**
```hemlock
raise(signum: i32): null
```

**Параметры:**
- `signum` - Номер сигнала для отправки

**Возвращает:** `null`

**Примеры:**
```hemlock
let count = 0;

fn increment(sig) {
    count = count + 1;
}

signal(SIGUSR1, increment);

raise(SIGUSR1);
raise(SIGUSR1);
print(count);  // 2
```

---

## Глобальные переменные

### args

Массив аргументов командной строки.

**Тип:** `array` строк

**Структура:**
- `args[0]` - Имя файла скрипта
- `args[1..n]` - Аргументы командной строки

**Примеры:**
```bash
# Команда: ./hemlock script.hml hello world
```

```hemlock
print(args[0]);        // "script.hml"
print(args.length);    // 3
print(args[1]);        // "hello"
print(args[2]);        // "world"

// Перебор аргументов
let i = 1;
while (i < args.length) {
    print("Аргумент", i, ":", args[i]);
    i = i + 1;
}
```

**Поведение в REPL:** В REPL `args.length` равно 0 (пустой массив)

---

## Константы сигналов

Стандартные константы сигналов POSIX (значения i32):

### Прерывание и завершение

| Константа  | Значение | Описание                               |
|------------|----------|----------------------------------------|
| `SIGINT`   | 2        | Прерывание с клавиатуры (Ctrl+C)       |
| `SIGTERM`  | 15       | Запрос на завершение                   |
| `SIGQUIT`  | 3        | Выход с клавиатуры (Ctrl+\)            |
| `SIGHUP`   | 1        | Разрыв связи с управляющим терминалом  |
| `SIGABRT`  | 6        | Сигнал прерывания                      |

### Пользовательские

| Константа  | Значение | Описание                   |
|------------|----------|----------------------------|
| `SIGUSR1`  | 10       | Пользовательский сигнал 1  |
| `SIGUSR2`  | 12       | Пользовательский сигнал 2  |

### Управление процессами

| Константа  | Значение | Описание                        |
|------------|----------|---------------------------------|
| `SIGALRM`  | 14       | Таймер будильника               |
| `SIGCHLD`  | 17       | Изменение статуса дочернего процесса |
| `SIGCONT`  | 18       | Продолжить если остановлен      |
| `SIGSTOP`  | 19       | Остановить процесс (нельзя перехватить) |
| `SIGTSTP`  | 20       | Остановка терминала (Ctrl+Z)    |

### Ввод-вывод

| Константа  | Значение | Описание                           |
|------------|----------|------------------------------------|
| `SIGPIPE`  | 13       | Разорванный канал                  |
| `SIGTTIN`  | 21       | Фоновое чтение с терминала         |
| `SIGTTOU`  | 22       | Фоновая запись на терминал         |

**Примеры:**
```hemlock
fn handle_signal(sig) {
    if (sig == SIGINT) {
        print("Обнаружено прерывание");
    }
    if (sig == SIGTERM) {
        print("Запрошено завершение");
    }
}

signal(SIGINT, handle_signal);
signal(SIGTERM, handle_signal);
```

**Примечание:** `SIGKILL` (9) и `SIGSTOP` (19) нельзя перехватить или игнорировать.

---

## Математические/арифметические функции

### div

Целочисленное деление с округлением вниз, возвращающее float.

**Сигнатура:**
```hemlock
div(a: number, b: number): f64
```

**Параметры:**
- `a` - Делимое
- `b` - Делитель

**Возвращает:** Целую часть от `a / b` как float (f64)

**Примеры:**
```hemlock
let result = div(7, 2);    // 3.0 (не 3.5)
let result2 = div(10, 3);  // 3.0
let result3 = div(-7, 2);  // -4.0 (округление к минус бесконечности)
```

**Примечание:** В Hemlock оператор `/` всегда возвращает float. Используйте `div()` для целочисленного деления с округлением вниз, когда нужен результат как float, или `divi()` когда нужен целочисленный результат.

---

### divi

Целочисленное деление с округлением вниз, возвращающее целое.

**Сигнатура:**
```hemlock
divi(a: number, b: number): i64
```

**Параметры:**
- `a` - Делимое
- `b` - Делитель

**Возвращает:** Целую часть от `a / b` как целое (i64)

**Примеры:**
```hemlock
let result = divi(7, 2);    // 3
let result2 = divi(10, 3);  // 3
let result3 = divi(-7, 2);  // -4 (округление к минус бесконечности)
```

**Сравнение:**
```hemlock
print(7 / 2);      // 3.5 (обычное деление, всегда float)
print(div(7, 2));  // 3.0 (целочисленное деление, результат float)
print(divi(7, 2)); // 3   (целочисленное деление, результат integer)
```

---

## Функции управления памятью

См. [API памяти](memory-api.md) для полного справочника:
- `alloc(size)` - Выделить сырую память
- `free(ptr)` - Освободить память
- `buffer(size)` - Выделить безопасный буфер
- `memset(ptr, byte, size)` - Заполнить память
- `memcpy(dest, src, size)` - Копировать память
- `realloc(ptr, new_size)` - Изменить размер выделения

### sizeof

Получить размер типа в байтах.

**Сигнатура:**
```hemlock
sizeof(type): i32
```

**Параметры:**
- `type` - Константа типа (`i32`, `f64`, `ptr` и т.д.) или строка имени типа

**Возвращает:** Размер в байтах как `i32`

**Примеры:**
```hemlock
print(sizeof(i8));       // 1
print(sizeof(i16));      // 2
print(sizeof(i32));      // 4
print(sizeof(i64));      // 8
print(sizeof(f32));      // 4
print(sizeof(f64));      // 8
print(sizeof(ptr));      // 8
print(sizeof(rune));     // 4

// Использование псевдонимов типов
print(sizeof(byte));     // 1 (то же что u8)
print(sizeof(integer));  // 4 (то же что i32)
print(sizeof(number));   // 8 (то же что f64)

// Строковая форма тоже работает
print(sizeof("i32"));    // 4
```

**Поддерживаемые типы:**
| Тип | Размер | Псевдонимы |
|-----|--------|------------|
| `i8` | 1 | - |
| `i16` | 2 | - |
| `i32` | 4 | `integer` |
| `i64` | 8 | - |
| `u8` | 1 | `byte` |
| `u16` | 2 | - |
| `u32` | 4 | - |
| `u64` | 8 | - |
| `f32` | 4 | - |
| `f64` | 8 | `number` |
| `ptr` | 8 | - |
| `rune` | 4 | - |
| `bool` | 1 | - |

**См. также:** `talloc()` для типизированного выделения

---

### talloc

Выделить память для типизированного массива (выделение с учётом типа).

**Сигнатура:**
```hemlock
talloc(type, count: i32): ptr
```

**Параметры:**
- `type` - Константа типа (`i32`, `f64`, `ptr` и т.д.)
- `count` - Количество элементов для выделения

**Возвращает:** `ptr` на выделенную память или `null` при неудаче

**Примеры:**
```hemlock
// Выделить массив из 10 i32 (40 байтов)
let int_arr = talloc(i32, 10);
ptr_write_i32(int_arr, 42);
ptr_write_i32(ptr_offset(int_arr, 1, 4), 100);

// Выделить массив из 5 f64 (40 байтов)
let float_arr = talloc(f64, 5);

// Выделить массив из 100 байтов
let byte_arr = talloc(u8, 100);

// Не забудьте освободить!
free(int_arr);
free(float_arr);
free(byte_arr);
```

**Сравнение с alloc:**
```hemlock
// Эти эквивалентны:
let p1 = talloc(i32, 10);      // С учётом типа: 10 i32
let p2 = alloc(sizeof(i32) * 10);  // Ручной расчёт

// talloc понятнее и менее подвержен ошибкам
```

**Обработка ошибок:**
- Возвращает `null` при неудаче выделения
- Завершается с ошибкой, если count не положительный
- Проверяет переполнение размера (count * размер_элемента)

**См. также:** `alloc()`, `sizeof()`, `free()`

---

## Вспомогательные функции FFI для указателей

Эти функции помогают читать и записывать типизированные значения в сырую память, полезны для FFI и низкоуровневой работы с памятью.

### ptr_null

Создать нулевой указатель.

**Сигнатура:**
```hemlock
ptr_null(): ptr
```

**Возвращает:** Нулевой указатель

**Пример:**
```hemlock
let p = ptr_null();
if (p == null) {
    print("Указатель нулевой");
}
```

---

### ptr_offset

Вычислить смещение указателя (арифметика указателей).

**Сигнатура:**
```hemlock
ptr_offset(ptr: ptr, index: i32, element_size: i32): ptr
```

**Параметры:**
- `ptr` - Базовый указатель
- `index` - Индекс элемента
- `element_size` - Размер каждого элемента в байтах

**Возвращает:** Указатель на элемент по указанному индексу

**Пример:**
```hemlock
let arr = talloc(i32, 10);
ptr_write_i32(arr, 100);                      // arr[0] = 100
ptr_write_i32(ptr_offset(arr, 1, 4), 200);    // arr[1] = 200
ptr_write_i32(ptr_offset(arr, 2, 4), 300);    // arr[2] = 300

print(ptr_read_i32(ptr_offset(arr, 1, 4)));   // 200
free(arr);
```

---

### Функции чтения указателей

Чтение типизированных значений из памяти.

| Функция | Сигнатура | Возвращает | Описание |
|---------|-----------|------------|----------|
| `ptr_read_i8` | `(ptr)` | `i8` | Чтение знакового 8-битного целого |
| `ptr_read_i16` | `(ptr)` | `i16` | Чтение знакового 16-битного целого |
| `ptr_read_i32` | `(ptr)` | `i32` | Чтение знакового 32-битного целого |
| `ptr_read_i64` | `(ptr)` | `i64` | Чтение знакового 64-битного целого |
| `ptr_read_u8` | `(ptr)` | `u8` | Чтение беззнакового 8-битного целого |
| `ptr_read_u16` | `(ptr)` | `u16` | Чтение беззнакового 16-битного целого |
| `ptr_read_u32` | `(ptr)` | `u32` | Чтение беззнакового 32-битного целого |
| `ptr_read_u64` | `(ptr)` | `u64` | Чтение беззнакового 64-битного целого |
| `ptr_read_f32` | `(ptr)` | `f32` | Чтение 32-битного float |
| `ptr_read_f64` | `(ptr)` | `f64` | Чтение 64-битного float |
| `ptr_read_ptr` | `(ptr)` | `ptr` | Чтение значения указателя |

**Пример:**
```hemlock
let p = alloc(8);
ptr_write_f64(p, 3.14159);
let value = ptr_read_f64(p);
print(value);  // 3.14159
free(p);
```

---

### Функции записи указателей

Запись типизированных значений в память.

| Функция | Сигнатура | Возвращает | Описание |
|---------|-----------|------------|----------|
| `ptr_write_i8` | `(ptr, value)` | `null` | Запись знакового 8-битного целого |
| `ptr_write_i16` | `(ptr, value)` | `null` | Запись знакового 16-битного целого |
| `ptr_write_i32` | `(ptr, value)` | `null` | Запись знакового 32-битного целого |
| `ptr_write_i64` | `(ptr, value)` | `null` | Запись знакового 64-битного целого |
| `ptr_write_u8` | `(ptr, value)` | `null` | Запись беззнакового 8-битного целого |
| `ptr_write_u16` | `(ptr, value)` | `null` | Запись беззнакового 16-битного целого |
| `ptr_write_u32` | `(ptr, value)` | `null` | Запись беззнакового 32-битного целого |
| `ptr_write_u64` | `(ptr, value)` | `null` | Запись беззнакового 64-битного целого |
| `ptr_write_f32` | `(ptr, value)` | `null` | Запись 32-битного float |
| `ptr_write_f64` | `(ptr, value)` | `null` | Запись 64-битного float |
| `ptr_write_ptr` | `(ptr, value)` | `null` | Запись значения указателя |

**Пример:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);
print(ptr_read_i32(p));  // 42
free(p);
```

---

### Преобразование буфер/указатель

#### buffer_ptr

Получить сырой указатель из буфера.

**Сигнатура:**
```hemlock
buffer_ptr(buf: buffer): ptr
```

**Пример:**
```hemlock
let buf = buffer(64);
let p = buffer_ptr(buf);
// Теперь p указывает на ту же память, что и buf
```

#### ptr_to_buffer

Создать обёртку буфера вокруг сырого указателя.

**Сигнатура:**
```hemlock
ptr_to_buffer(ptr: ptr, size: i32): buffer
```

**Пример:**
```hemlock
let p = alloc(64);
let buf = ptr_to_buffer(p, 64);
buf[0] = 65;  // Теперь есть проверка границ
// Примечание: освобождение buf освободит базовую память
```

---

## Функции файлового ввода-вывода

См. [API файлов](file-api.md) для полного справочника:
- `open(path, mode?)` - Открыть файл

---

## Функции параллелизма

См. [API параллелизма](concurrency-api.md) для полного справочника:
- `spawn(fn, args...)` - Запустить задачу
- `join(task)` - Дождаться задачи
- `detach(task)` - Отсоединить задачу
- `channel(capacity)` - Создать канал

### apply

Вызвать функцию динамически с массивом аргументов.

**Сигнатура:**
```hemlock
apply(fn: function, args: array): any
```

**Параметры:**
- `fn` - Вызываемая функция
- `args` - Массив аргументов для передачи функции

**Возвращает:** Возвращаемое значение вызванной функции

**Примеры:**
```hemlock
fn add(a, b) {
    return a + b;
}

// Вызов с массивом аргументов
let result = apply(add, [2, 3]);
print(result);  // 5

// Динамическая диспетчеризация
let operations = {
    add: fn(a, b) { return a + b; },
    mul: fn(a, b) { return a * b; },
    sub: fn(a, b) { return a - b; }
};

fn calculate(op: string, args: array) {
    return apply(operations[op], args);
}

print(calculate("add", [10, 5]));  // 15
print(calculate("mul", [10, 5]));  // 50
print(calculate("sub", [10, 5]));  // 5

// Переменное число аргументов
fn sum(...nums) {
    let total = 0;
    for (n in nums) {
        total = total + n;
    }
    return total;
}

let numbers = [1, 2, 3, 4, 5];
print(apply(sum, numbers));  // 15
```

**Случаи использования:**
- Динамическая диспетчеризация функций на основе значений времени выполнения
- Вызов функций с переменными списками аргументов
- Реализация утилит высшего порядка (map, filter и т.д.)
- Системы плагинов/расширений

---

### select

Ожидать данные из нескольких каналов, возвращая когда любой имеет данные.

**Сигнатура:**
```hemlock
select(channels: array, timeout_ms?: i32): object | null
```

**Параметры:**
- `channels` - Массив значений каналов
- `timeout_ms` (необязательно) - Таймаут в миллисекундах (-1 или пропустить для бесконечного)

**Возвращает:**
- `{ channel, value }` - Объект с каналом, имеющим данные, и полученным значением
- `null` - По таймауту

**Примеры:**
```hemlock
let ch1 = channel(1);
let ch2 = channel(1);

// Задачи-производители
spawn(fn() {
    sleep(100);
    ch1.send("из канала 1");
});

spawn(fn() {
    sleep(50);
    ch2.send("из канала 2");
});

// Ожидание первого сообщения
let result = select([ch1, ch2]);
print(result.value);  // "из канала 2" (пришло первым)

// С таймаутом
let result2 = select([ch1, ch2], 1000);  // Ждать до 1 секунды
if (result2 == null) {
    print("Таймаут - данные не получены");
} else {
    print("Получено:", result2.value);
}

// Непрерывный цикл select
while (true) {
    let msg = select([ch1, ch2], 5000);
    if (msg == null) {
        print("Нет активности 5 секунд");
        break;
    }
    print("Получено сообщение:", msg.value);
}
```

**Поведение:**
- Блокирует пока один канал не получит данные или не истечёт таймаут
- Возвращает немедленно, если канал уже имеет данные
- Если канал закрыт и пуст, возвращает `{ channel, value: null }`
- Опрашивает каналы по порядку (первый готовый канал выигрывает)

**Случаи использования:**
- Мультиплексирование нескольких производителей
- Реализация таймаутов на операциях с каналами
- Построение циклов событий с несколькими источниками

---

## Сводная таблица

### Функции

| Функция    | Категория       | Возвращает   | Описание                        |
|------------|-----------------|--------------|----------------------------------|
| `print`    | Ввод-вывод      | `null`       | Вывод в stdout                   |
| `read_line`| Ввод-вывод      | `string?`    | Чтение строки из stdin           |
| `eprint`   | Ввод-вывод      | `null`       | Вывод в stderr                   |
| `typeof`   | Тип             | `string`     | Получить имя типа                |
| `exec`     | Команда         | `object`     | Выполнить команду shell          |
| `exec_argv`| Команда         | `object`     | Выполнить с массивом аргументов  |
| `assert`   | Ошибка          | `null`       | Утверждать условие или завершить |
| `panic`    | Ошибка          | `never`      | Невосстановимая ошибка (завершение) |
| `signal`   | Сигнал          | `function?`  | Зарегистрировать обработчик      |
| `raise`    | Сигнал          | `null`       | Отправить сигнал процессу        |
| `alloc`    | Память          | `ptr`        | Выделить сырую память            |
| `talloc`   | Память          | `ptr`        | Типизированное выделение         |
| `sizeof`   | Память          | `i32`        | Получить размер типа в байтах    |
| `free`     | Память          | `null`       | Освободить память                |
| `buffer`   | Память          | `buffer`     | Выделить безопасный буфер        |
| `memset`   | Память          | `null`       | Заполнить память                 |
| `memcpy`   | Память          | `null`       | Копировать память                |
| `realloc`  | Память          | `ptr`        | Изменить размер выделения        |
| `open`     | Файловый ввод-вывод | `file`   | Открыть файл                     |
| `spawn`    | Параллелизм     | `task`       | Запустить параллельную задачу    |
| `join`     | Параллелизм     | `any`        | Дождаться результата задачи      |
| `detach`   | Параллелизм     | `null`       | Отсоединить задачу               |
| `channel`  | Параллелизм     | `channel`    | Создать канал коммуникации       |
| `select`   | Параллелизм     | `object?`    | Ожидать на нескольких каналах    |
| `apply`    | Функции         | `any`        | Вызвать функцию с массивом args  |

### Глобальные переменные

| Переменная | Тип      | Описание                          |
|------------|----------|-----------------------------------|
| `args`     | `array`  | Аргументы командной строки        |

### Константы

| Константа  | Тип   | Категория | Значение | Описание                  |
|------------|-------|-----------|----------|---------------------------|
| `SIGINT`   | `i32` | Сигнал    | 2        | Прерывание с клавиатуры   |
| `SIGTERM`  | `i32` | Сигнал    | 15       | Запрос на завершение      |
| `SIGQUIT`  | `i32` | Сигнал    | 3        | Выход с клавиатуры        |
| `SIGHUP`   | `i32` | Сигнал    | 1        | Разрыв связи              |
| `SIGABRT`  | `i32` | Сигнал    | 6        | Прерывание                |
| `SIGUSR1`  | `i32` | Сигнал    | 10       | Пользовательский 1        |
| `SIGUSR2`  | `i32` | Сигнал    | 12       | Пользовательский 2        |
| `SIGALRM`  | `i32` | Сигнал    | 14       | Таймер будильника         |
| `SIGCHLD`  | `i32` | Сигнал    | 17       | Изменение статуса дочернего |
| `SIGCONT`  | `i32` | Сигнал    | 18       | Продолжить                |
| `SIGSTOP`  | `i32` | Сигнал    | 19       | Остановить (неперехватываемый) |
| `SIGTSTP`  | `i32` | Сигнал    | 20       | Остановка терминала       |
| `SIGPIPE`  | `i32` | Сигнал    | 13       | Разорванный канал         |
| `SIGTTIN`  | `i32` | Сигнал    | 21       | Фоновое чтение терминала  |
| `SIGTTOU`  | `i32` | Сигнал    | 22       | Фоновая запись терминала  |

---

## См. также

- [Система типов](type-system.md) - Типы и преобразования
- [API памяти](memory-api.md) - Функции выделения памяти
- [API файлов](file-api.md) - Функции файлового ввода-вывода
- [API параллелизма](concurrency-api.md) - Функции async/параллелизма
- [API строк](string-api.md) - Методы строк
- [API массивов](array-api.md) - Методы массивов
