# Справочник по API параллелизма

Полный справочник по системе async/параллелизма Hemlock.

---

## Обзор

Hemlock предоставляет **структурированный параллелизм** с истинным многопоточным параллелизмом на основе потоков POSIX (pthreads). Каждая запущенная задача выполняется в отдельном потоке ОС, обеспечивая реальное параллельное выполнение на нескольких ядрах процессора.

**Ключевые особенности:**
- Истинный многопоточный параллелизм (не зелёные потоки)
- Синтаксис асинхронных функций
- Запуск и ожидание задач
- Потокобезопасные каналы
- Распространение исключений

**Модель потоков:**
- ✅ Реальные потоки ОС (POSIX pthreads)
- ✅ Истинный параллелизм (несколько ядер CPU)
- ✅ Планирование ядром (вытесняющая многозадачность)
- ✅ Потокобезопасная синхронизация (мьютексы, условные переменные)

---

## Асинхронные функции

### Объявление асинхронной функции

Функции могут быть объявлены как `async`, чтобы указать, что они предназначены для параллельного выполнения.

**Синтаксис:**
```hemlock
async fn function_name(params): return_type {
    // тело функции
}
```

**Примеры:**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

async fn process_data(data: string) {
    print("Обработка:", data);
    return null;
}
```

**Поведение:**
- `async fn` объявляет асинхронную функцию
- Может вызываться синхронно (выполняется в текущем потоке)
- Может быть запущена как параллельная задача (выполняется в новом потоке)
- При запуске выполняется в собственном потоке ОС

**Примечание:** Ключевое слово `await` зарезервировано для будущего использования, но пока не реализовано.

---

## Управление задачами

### spawn

Создать и запустить новую параллельную задачу.

**Сигнатура:**
```hemlock
spawn(async_fn: function, ...args): task
```

**Параметры:**
- `async_fn` - Асинхронная функция для выполнения
- `...args` - Аргументы для передачи функции

**Возвращает:** Дескриптор задачи

**Примеры:**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Запуск одной задачи
let t = spawn(compute, 1000);
let result = join(t);
print(result);

// Запуск нескольких задач (выполняются параллельно!)
let t1 = spawn(compute, 100);
let t2 = spawn(compute, 200);
let t3 = spawn(compute, 300);

// Все три выполняются одновременно
let r1 = join(t1);
let r2 = join(t2);
let r3 = join(t3);
```

**Поведение:**
- Создаёт новый поток ОС через `pthread_create()`
- Немедленно начинает выполнение функции
- Возвращает дескриптор задачи для последующего ожидания
- Задачи выполняются параллельно на разных ядрах CPU

---

### join

Дождаться завершения задачи и получить результат.

**Сигнатура:**
```hemlock
join(task: task): any
```

**Параметры:**
- `task` - Дескриптор задачи от `spawn()`

**Возвращает:** Возвращаемое значение задачи

**Примеры:**
```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

let t = spawn(factorial, 10);
let result = join(t);  // Блокирует до завершения задачи
print(result);         // 3628800
```

**Поведение:**
- Блокирует текущий поток до завершения задачи
- Возвращает значение, возвращённое задачей
- Распространяет исключения, выброшенные задачей
- Очищает ресурсы задачи после возврата

**Обработка ошибок:**
```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Задача провалилась!";
    }
    return 42;
}

let t = spawn(risky_operation, 1);
try {
    let result = join(t);
} catch (e) {
    print("Перехвачено:", e);  // "Перехвачено: Задача провалилась!"
}
```

---

### detach

Отсоединить задачу (выполнение по принципу "запустил и забыл").

**Сигнатура:**
```hemlock
detach(task: task): null
```

**Параметры:**
- `task` - Дескриптор задачи от `spawn()`

**Возвращает:** `null`

**Примеры:**
```hemlock
async fn background_work() {
    print("Работа в фоне...");
    return null;
}

let t = spawn(background_work);
detach(t);  // Задача продолжает выполняться независимо

// Нельзя ждать отсоединённую задачу
// join(t);  // ОШИБКА
```

**Поведение:**
- Задача продолжает выполняться независимо
- Нельзя использовать `join()` для отсоединённой задачи
- Задача и поток автоматически очищаются при завершении

**Случаи использования:**
- Фоновые задачи по принципу "запустил и забыл"
- Задачи логирования/мониторинга
- Задачи, которым не нужно возвращать значения

---

## Каналы

Каналы обеспечивают потокобезопасную коммуникацию между задачами.

### channel

Создать буферизованный канал.

**Сигнатура:**
```hemlock
channel(capacity: i32): channel
```

**Параметры:**
- `capacity` - Размер буфера (количество значений)

**Возвращает:** Объект канала

**Примеры:**
```hemlock
let ch = channel(10);  // Буферизованный канал с ёмкостью 10
let ch2 = channel(1);  // Минимальный буфер (синхронный)
let ch3 = channel(100); // Большой буфер
```

**Поведение:**
- Создаёт потокобезопасный канал
- Использует мьютексы pthread для синхронизации
- Ёмкость фиксируется при создании

---

### Методы канала

#### send

Отправить значение в канал (блокирует, если полон).

**Сигнатура:**
```hemlock
channel.send(value: any): null
```

**Параметры:**
- `value` - Значение для отправки (любой тип)

**Возвращает:** `null`

**Примеры:**
```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

let ch = channel(10);
let t = spawn(producer, ch, 5);
```

**Поведение:**
- Отправляет значение в канал
- Блокирует, если канал полон
- Потокобезопасно (использует мьютекс)
- Возвращает после отправки значения

---

#### recv

Получить значение из канала (блокирует, если пуст).

**Сигнатура:**
```hemlock
channel.recv(): any
```

**Возвращает:** Значение из канала или `null`, если канал закрыт и пуст

**Примеры:**
```hemlock
async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(10);
let t = spawn(consumer, ch, 5);
```

**Поведение:**
- Получает значение из канала
- Блокирует, если канал пуст
- Возвращает `null`, если канал закрыт и пуст
- Потокобезопасно (использует мьютекс)

---

#### close

Закрыть канал (отправка больше не разрешена).

**Сигнатура:**
```hemlock
channel.close(): null
```

**Возвращает:** `null`

**Примеры:**
```hemlock
async fn producer(ch) {
    ch.send(1);
    ch.send(2);
    ch.send(3);
    ch.close();  // Сигнал о том, что больше значений нет
    return null;
}

async fn consumer(ch) {
    while (true) {
        let val = ch.recv();
        if (val == null) {
            break;  // Канал закрыт
        }
        print(val);
    }
    return null;
}
```

**Поведение:**
- Закрывает канал
- Отправка больше не разрешена
- `recv()` возвращает `null`, когда канал пуст
- Потокобезопасно

---

## Полный пример параллелизма

### Паттерн производитель-потребитель

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        print("Производство:", i);
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        print("Потребление:", val);
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

// Создать канал
let ch = channel(10);

// Запустить производителя и потребителя
let p = spawn(producer, ch, 5);
let c = spawn(consumer, ch, 5);

// Дождаться завершения
join(p);
let total = join(c);
print("Итого:", total);  // 0+10+20+30+40 = 100
```

---

## Параллельные вычисления

### Пример нескольких задач

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Запуск нескольких задач (выполняются параллельно!)
let t1 = spawn(factorial, 5);   // Поток 1
let t2 = spawn(factorial, 6);   // Поток 2
let t3 = spawn(factorial, 7);   // Поток 3
let t4 = spawn(factorial, 8);   // Поток 4

// Все четыре вычисляют одновременно!

// Ожидание результатов
let f5 = join(t1);  // 120
let f6 = join(t2);  // 720
let f7 = join(t3);  // 5040
let f8 = join(t4);  // 40320

print(f5, f6, f7, f8);
```

---

## Жизненный цикл задачи

### Переходы состояний

1. **Создана** - Задача запущена, но ещё не выполняется
2. **Выполняется** - Задача выполняется в потоке ОС
3. **Завершена** - Задача закончена (результат доступен)
4. **Присоединена** - Результат получен, ресурсы очищены
5. **Отсоединена** - Задача продолжает независимо

### Пример жизненного цикла

```hemlock
async fn work(n: i32): i32 {
    return n * 2;
}

// 1. Создать задачу
let t = spawn(work, 21);  // Состояние: Выполняется

// Задача выполняется в отдельном потоке...

// 2. Присоединить задачу
let result = join(t);     // Состояние: Завершена → Присоединена
print(result);            // 42

// Ресурсы задачи очищаются после join
```

### Жизненный цикл отсоединённой задачи

```hemlock
async fn background() {
    print("Фоновая задача выполняется");
    return null;
}

// 1. Создать задачу
let t = spawn(background);  // Состояние: Выполняется

// 2. Отсоединить задачу
detach(t);                  // Состояние: Отсоединена

// Задача продолжает выполняться независимо
// Ресурсы очищаются ОС по завершении
```

---

## Обработка ошибок

### Распространение исключений

Исключения, выброшенные в задачах, распространяются при присоединении:

```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Задача провалилась!";
    }
    return 42;
}

// Задача, которая успешно завершается
let t1 = spawn(risky_operation, 0);
let result1 = join(t1);  // 42

// Задача, которая терпит неудачу
let t2 = spawn(risky_operation, 1);
try {
    let result2 = join(t2);
} catch (e) {
    print("Перехвачено:", e);  // "Перехвачено: Задача провалилась!"
}
```

### Обработка нескольких задач

```hemlock
async fn work(id: i32, should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Задача " + typeof(id) + " провалилась";
    }
    return id * 10;
}

let t1 = spawn(work, 1, 0);
let t2 = spawn(work, 2, 1);  // Провалится
let t3 = spawn(work, 3, 0);

// Присоединение с обработкой ошибок
try {
    let r1 = join(t1);  // OK
    print("Задача 1:", r1);

    let r2 = join(t2);  // Выбрасывает
    print("Задача 2:", r2);  // Не достигается
} catch (e) {
    print("Ошибка:", e);  // "Ошибка: Задача 2 провалилась"
}

// Можно присоединить оставшуюся задачу
let r3 = join(t3);
print("Задача 3:", r3);
```

---

## Характеристики производительности

### Истинный параллелизм

```hemlock
async fn cpu_intensive(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Последовательное выполнение
let start = get_time();
let r1 = cpu_intensive(10000000);
let r2 = cpu_intensive(10000000);
let sequential_time = get_time() - start;

// Параллельное выполнение
let start2 = get_time();
let t1 = spawn(cpu_intensive, 10000000);
let t2 = spawn(cpu_intensive, 10000000);
join(t1);
join(t2);
let parallel_time = get_time() - start2;

// parallel_time должно быть ~50% от sequential_time на многоядерных системах
```

**Подтверждённые характеристики:**
- N задач могут использовать N ядер CPU одновременно
- Стресс-тесты показывают 8-9x CPU-время против реального времени (доказательство параллелизма)
- Накладные расходы на поток: ~8КБ стек + накладные расходы pthread на задачу
- Блокирующие операции в одной задаче не блокируют другие

---

## Детали реализации

### Модель потоков

- **Потоки 1:1** - Каждая задача = 1 поток ОС (`pthread`)
- **Планирование ядром** - Ядро ОС распределяет потоки по ядрам
- **Вытесняющая многозадачность** - ОС может прерывать и переключать потоки
- **Нет GIL** - Нет глобальной блокировки интерпретатора (в отличие от Python)

### Синхронизация

- **Мьютексы** - Каналы используют `pthread_mutex_t`
- **Условные переменные** - Блокирующие send/recv используют `pthread_cond_t`
- **Безблокировочные операции** - Переходы состояний задачи атомарные

### Память и очистка

- **Присоединённые задачи** - Автоматически очищаются после `join()`
- **Отсоединённые задачи** - Автоматически очищаются при завершении
- **Каналы** - Подсчёт ссылок, освобождаются когда больше не используются

---

## Ограничения

- Нет `select()` для мультиплексирования нескольких каналов
- Нет планировщика с перехватом работы (1 поток на задачу)
- Нет интеграции с асинхронным вводом-выводом (файловые/сетевые операции блокируют)
- Ёмкость канала фиксируется при создании

---

## Полная сводка API

### Функции

| Функция   | Сигнатура                         | Возвращает | Описание                       |
|-----------|-----------------------------------|------------|--------------------------------|
| `spawn`   | `(async_fn: function, ...args)`   | `task`     | Создать и запустить задачу     |
| `join`    | `(task: task)`                    | `any`      | Дождаться задачи, получить результат |
| `detach`  | `(task: task)`                    | `null`     | Отсоединить задачу             |
| `channel` | `(capacity: i32)`                 | `channel`  | Создать потокобезопасный канал |

### Методы канала

| Метод   | Сигнатура       | Возвращает | Описание                         |
|---------|-----------------|------------|----------------------------------|
| `send`  | `(value: any)`  | `null`     | Отправить значение (блокирует если полон) |
| `recv`  | `()`            | `any`      | Получить значение (блокирует если пуст) |
| `close` | `()`            | `null`     | Закрыть канал                    |

### Типы

| Тип       | Описание                             |
|-----------|--------------------------------------|
| `task`    | Дескриптор параллельной задачи       |
| `channel` | Потокобезопасный канал коммуникации  |

---

## Лучшие практики

### Рекомендуется

✅ Использовать каналы для коммуникации между задачами
✅ Обрабатывать исключения от присоединённых задач
✅ Закрывать каналы после завершения отправки
✅ Использовать `join()` для получения результатов и очистки
✅ Запускать только async функции

### Не рекомендуется

❌ Не разделять изменяемое состояние без синхронизации
❌ Не присоединять одну и ту же задачу дважды
❌ Не отправлять в закрытые каналы
❌ Не запускать не-async функции
❌ Не забывать присоединять задачи (если не отсоединены)

---

## См. также

- [Встроенные функции](builtins.md) - `spawn()`, `join()`, `detach()`, `channel()`
- [Система типов](type-system.md) - Типы task и channel
