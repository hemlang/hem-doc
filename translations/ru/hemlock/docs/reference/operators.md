# Справочник по операторам

Полный справочник по всем операторам Hemlock, включая приоритет, ассоциативность и поведение.

---

## Обзор

Hemlock предоставляет операторы в стиле C с явными правилами приоритета. Все операторы следуют строгим правилам типизации с автоматическим продвижением типов, где это применимо.

---

## Арифметические операторы

### Бинарные арифметические

| Оператор | Название       | Пример     | Описание                     |
|----------|----------------|------------|------------------------------|
| `+`      | Сложение       | `a + b`    | Сложить два значения         |
| `-`      | Вычитание      | `a - b`    | Вычесть b из a               |
| `*`      | Умножение      | `a * b`    | Умножить два значения        |
| `/`      | Деление        | `a / b`    | Разделить a на b             |

**Продвижение типов:**
Результаты следуют правилам продвижения типов (см. [Система типов](type-system.md#правила-продвижения-типов)).

**Примеры:**
```hemlock
let a = 10 + 5;        // 15 (i32)
let b = 10 - 3;        // 7 (i32)
let c = 4 * 5;         // 20 (i32)
let d = 20 / 4;        // 5 (i32)

// Деление с плавающей точкой
let e = 10.0 / 3.0;    // 3.333... (f64)

// Смешанные типы
let f: u8 = 10;
let g: i32 = 20;
let h = f + g;         // 30 (i32, продвинуто)
```

**Деление на ноль:**
- Целочисленное деление на ноль: Ошибка времени выполнения
- Деление с плавающей точкой на ноль: Возвращает `inf` или `-inf`

---

### Унарные арифметические

| Оператор | Название | Пример | Описание             |
|----------|----------|--------|----------------------|
| `-`      | Отрицание| `-a`   | Изменить знак        |
| `+`      | Плюс     | `+a`   | Тождество (no-op)    |

**Примеры:**
```hemlock
let a = 5;
let b = -a;            // -5
let c = +a;            // 5 (без изменения)

let x = -3.14;         // -3.14
```

---

## Операторы сравнения

| Оператор | Название              | Пример     | Возвращает |
|----------|-----------------------|------------|------------|
| `==`     | Равно                 | `a == b`   | `bool`     |
| `!=`     | Не равно              | `a != b`   | `bool`     |
| `<`      | Меньше                | `a < b`    | `bool`     |
| `>`      | Больше                | `a > b`    | `bool`     |
| `<=`     | Меньше или равно      | `a <= b`   | `bool`     |
| `>=`     | Больше или равно      | `a >= b`   | `bool`     |

**Продвижение типов:**
Операнды продвигаются перед сравнением.

**Примеры:**
```hemlock
print(5 == 5);         // true
print(10 != 5);        // true
print(3 < 7);          // true
print(10 > 5);         // true
print(5 <= 5);         // true
print(10 >= 5);        // true

// Сравнение строк
print("hello" == "hello");  // true
print("abc" < "def");       // true (лексикографически)

// Смешанные типы
let a: u8 = 10;
let b: i32 = 10;
print(a == b);         // true (продвинуто до i32)
```

---

## Логические операторы

| Оператор | Название        | Пример       | Описание                 |
|----------|-----------------|--------------|--------------------------|
| `&&`     | Логическое И    | `a && b`     | True если оба true       |
| `||`     | Логическое ИЛИ  | `a || b`     | True если любой true     |
| `!`      | Логическое НЕ   | `!a`         | Отрицание булевого       |

**Сокращённое вычисление:**
- `&&` - Останавливается на первом false значении
- `||` - Останавливается на первом true значении

**Примеры:**
```hemlock
let a = true;
let b = false;

print(a && b);         // false
print(a || b);         // true
print(!a);             // false
print(!b);             // true

// Сокращённое вычисление
if (x != 0 && (10 / x) > 2) {
    print("безопасно");
}

if (x == 0 || (10 / x) > 2) {
    print("безопасно");
}
```

---

## Побитовые операторы

**Ограничение:** Только целочисленные типы (i8-i64, u8-u64)

### Бинарные побитовые

| Оператор | Название          | Пример     | Описание                 |
|----------|-------------------|------------|--------------------------|
| `&`      | Побитовое И       | `a & b`    | И для каждого бита       |
| `|`      | Побитовое ИЛИ     | `a | b`    | ИЛИ для каждого бита     |
| `^`      | Побитовое XOR     | `a ^ b`    | XOR для каждого бита     |
| `<<`     | Сдвиг влево       | `a << b`   | Сдвиг влево на b бит     |
| `>>`     | Сдвиг вправо      | `a >> b`   | Сдвиг вправо на b бит    |

**Сохранение типа:**
Тип результата соответствует типам операндов (с продвижением типа).

**Примеры:**
```hemlock
let a = 12;  // 1100 в двоичном
let b = 10;  // 1010 в двоичном

print(a & b);          // 8  (1000)
print(a | b);          // 14 (1110)
print(a ^ b);          // 6  (0110)
print(a << 2);         // 48 (110000)
print(a >> 1);         // 6  (110)
```

**Пример с беззнаковыми:**
```hemlock
let c: u8 = 15;        // 00001111
let d: u8 = 7;         // 00000111

print(c & d);          // 7  (00000111)
print(c | d);          // 15 (00001111)
print(c ^ d);          // 8  (00001000)
```

**Поведение сдвига вправо:**
- Знаковые типы: Арифметический сдвиг (расширение знака)
- Беззнаковые типы: Логический сдвиг (заполнение нулями)

---

### Унарные побитовые

| Оператор | Название       | Пример | Описание                 |
|----------|----------------|--------|--------------------------|
| `~`      | Побитовое НЕ   | `~a`   | Инвертировать все биты   |

**Примеры:**
```hemlock
let a = 12;            // 00001100 (i32)
print(~a);             // -13 (дополнительный код)

let b: u8 = 15;        // 00001111
print(~b);             // 240 (11110000)
```

---

## Строковые операторы

### Конкатенация

| Оператор | Название       | Пример     | Описание           |
|----------|----------------|------------|--------------------|
| `+`      | Конкатенация   | `a + b`    | Объединить строки  |

**Примеры:**
```hemlock
let s = "hello" + " " + "world";  // "hello world"
let msg = "Count: " + typeof(42); // "Count: 42"

// Строка + руна
let greeting = "Hello" + '!';      // "Hello!"

// Руна + строка
let prefix = '>' + " Message";     // "> Message"
```

---

## Операторы присваивания

### Базовое присваивание

| Оператор | Название      | Пример     | Описание                     |
|----------|---------------|------------|------------------------------|
| `=`      | Присваивание  | `a = b`    | Присвоить значение переменной |

**Примеры:**
```hemlock
let x = 10;
x = 20;

let arr = [1, 2, 3];
arr[0] = 99;

let obj = { x: 10 };
obj.x = 20;
```

### Составное присваивание

#### Арифметическое составное присваивание

| Оператор | Название            | Пример     | Эквивалент         |
|----------|---------------------|------------|--------------------|
| `+=`     | Сложение с присв.   | `a += b`   | `a = a + b`        |
| `-=`     | Вычитание с присв.  | `a -= b`   | `a = a - b`        |
| `*=`     | Умножение с присв.  | `a *= b`   | `a = a * b`        |
| `/=`     | Деление с присв.    | `a /= b`   | `a = a / b`        |
| `%=`     | Остаток с присв.    | `a %= b`   | `a = a % b`        |

**Примеры:**
```hemlock
let x = 10;
x += 5;      // x теперь 15
x -= 3;      // x теперь 12
x *= 2;      // x теперь 24
x /= 4;      // x теперь 6

let count = 0;
count += 1;  // Увеличить на 1
```

#### Побитовое составное присваивание

| Оператор | Название                | Пример      | Эквивалент          |
|----------|-------------------------|-------------|---------------------|
| `&=`     | Побитовое И с присв.    | `a &= b`    | `a = a & b`         |
| `\|=`    | Побитовое ИЛИ с присв.  | `a \|= b`   | `a = a \| b`        |
| `^=`     | Побитовое XOR с присв.  | `a ^= b`    | `a = a ^ b`         |
| `<<=`    | Сдвиг влево с присв.    | `a <<= b`   | `a = a << b`        |
| `>>=`    | Сдвиг вправо с присв.   | `a >>= b`   | `a = a >> b`        |

**Примеры:**
```hemlock
let flags = 0b1111;
flags &= 0b0011;   // flags теперь 0b0011 (маскировать верхние биты)
flags |= 0b1000;   // flags теперь 0b1011 (установить бит)
flags ^= 0b0001;   // flags теперь 0b1010 (переключить бит)

let x = 1;
x <<= 4;           // x теперь 16 (сдвиг влево на 4)
x >>= 2;           // x теперь 4 (сдвиг вправо на 2)
```

### Инкремент/Декремент

| Оператор | Название   | Пример | Описание                     |
|----------|------------|--------|------------------------------|
| `++`     | Инкремент  | `a++`  | Увеличить на 1 (постфикс)    |
| `--`     | Декремент  | `a--`  | Уменьшить на 1 (постфикс)    |

**Примеры:**
```hemlock
let i = 0;
i++;         // i теперь 1
i++;         // i теперь 2
i--;         // i теперь 1

// Часто в циклах
for (let j = 0; j < 10; j++) {
    print(j);
}
```

**Примечание:** И `++`, и `--` — постфиксные операторы (значение возвращается до инкремента/декремента)

---

## Операторы безопасности null

### Null-объединение (`??`)

Возвращает левый операнд, если он не null, иначе возвращает правый операнд.

| Оператор | Название          | Пример       | Описание                       |
|----------|-------------------|--------------|--------------------------------|
| `??`     | Null-объединение  | `a ?? b`     | Вернуть a если не null, иначе b |

**Примеры:**
```hemlock
let name = null;
let display = name ?? "Аноним";  // "Аноним"

let value = 42;
let result = value ?? 0;            // 42

// Цепочка
let a = null;
let b = null;
let c = "найдено";
let result2 = a ?? b ?? c;          // "найдено"

// С вызовами функций
fn get_config() { return null; }
let config = get_config() ?? { default: true };
```

---

### Опциональная цепочка (`?.`)

Безопасный доступ к свойствам или вызов методов на потенциально null значениях.

| Оператор | Название            | Пример         | Описание                         |
|----------|---------------------|----------------|----------------------------------|
| `?.`     | Опциональная цепочка| `a?.b`         | Вернуть a.b если a не null, иначе null |
| `?.[`    | Опциональный индекс | `a?.[0]`       | Вернуть a[0] если a не null, иначе null |
| `?.(`    | Опциональный вызов  | `a?.()`        | Вызвать a() если a не null, иначе null |

**Примеры:**
```hemlock
let user = null;
let name = user?.name;              // null (без ошибки)

let person = { name: "Alice", address: null };
let city = person?.address?.city;   // null (безопасная навигация)

// С массивами
let arr = null;
let first = arr?.[0];               // null

let items = [1, 2, 3];
let second = items?.[1];            // 2

// С вызовами методов
let obj = { greet: fn() { return "Привет"; } };
let greeting = obj?.greet?.();      // "Привет"

let empty = null;
let result = empty?.method?.();     // null
```

**Поведение:**
- Если левый операнд null, всё выражение сокращённо вычисляется до null
- Если левый операнд не null, доступ выполняется нормально
- Можно объединять в цепочки для глубокого доступа к свойствам

---

## Операторы доступа к членам

### Оператор точка

| Оператор | Название           | Пример       | Описание              |
|----------|--------------------|--------------|-----------------------|
| `.`      | Доступ к члену     | `obj.field`  | Доступ к полю объекта |
| `.`      | Доступ к свойству  | `arr.length` | Доступ к свойству     |

**Примеры:**
```hemlock
// Доступ к полю объекта
let person = { name: "Alice", age: 30 };
print(person.name);        // "Alice"

// Свойство массива
let arr = [1, 2, 3];
print(arr.length);         // 3

// Свойство строки
let s = "hello";
print(s.length);           // 5

// Вызов метода
let result = s.to_upper(); // "HELLO"
```

---

### Оператор индекса

| Оператор | Название | Пример    | Описание             |
|----------|----------|-----------|----------------------|
| `[]`     | Индекс   | `arr[i]`  | Доступ к элементу    |

**Примеры:**
```hemlock
// Индексация массива
let arr = [10, 20, 30];
print(arr[0]);             // 10
arr[1] = 99;

// Индексация строки (возвращает руну)
let s = "hello";
print(s[0]);               // 'h'
s[0] = 'H';                // "Hello"

// Индексация буфера
let buf = buffer(10);
buf[0] = 65;
print(buf[0]);             // 65
```

---

## Оператор вызова функции

| Оператор | Название       | Пример       | Описание           |
|----------|----------------|--------------|--------------------|
| `()`     | Вызов функции  | `f(a, b)`    | Вызвать функцию    |

**Примеры:**
```hemlock
fn add(a, b) {
    return a + b;
}

let result = add(5, 3);    // 8

// Вызов метода
let s = "hello";
let upper = s.to_upper();  // "HELLO"

// Вызов встроенной функции
print("сообщение");
```

---

## Приоритет операторов

Операторы перечислены от высшего к низшему приоритету:

| Приоритет | Операторы                  | Описание                           | Ассоциативность |
|-----------|----------------------------|------------------------------------|-----------------|
| 1         | `()` `[]` `.` `?.`         | Вызов, индекс, доступ к члену, опц. цепочка | Слева направо |
| 2         | `++` `--`                  | Постфиксный инкремент/декремент    | Слева направо |
| 3         | `!` `~` `-` (унарный) `+` (унарный) | Лог. НЕ, побит. НЕ, отрицание | Справа налево |
| 4         | `*` `/` `%`                | Умножение, деление, остаток        | Слева направо |
| 5         | `+` `-`                    | Сложение, вычитание                | Слева направо |
| 6         | `<<` `>>`                  | Побитовые сдвиги                   | Слева направо |
| 7         | `<` `<=` `>` `>=`          | Сравнения                          | Слева направо |
| 8         | `==` `!=`                  | Равенство                          | Слева направо |
| 9         | `&`                        | Побитовое И                        | Слева направо |
| 10        | `^`                        | Побитовое XOR                      | Слева направо |
| 11        | `|`                        | Побитовое ИЛИ                      | Слева направо |
| 12        | `&&`                       | Логическое И                       | Слева направо |
| 13        | `||`                       | Логическое ИЛИ                     | Слева направо |
| 14        | `??`                       | Null-объединение                   | Слева направо |
| 15        | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\|=` `^=` `<<=` `>>=` | Присваивание | Справа налево |

---

## Примеры приоритета

### Пример 1: Арифметика и сравнение
```hemlock
let result = 5 + 3 * 2;
// Вычисляется как: 5 + (3 * 2) = 11
// Умножение имеет более высокий приоритет, чем сложение

let cmp = 10 > 5 + 3;
// Вычисляется как: 10 > (5 + 3) = true
// Сложение имеет более высокий приоритет, чем сравнение
```

### Пример 2: Побитовые операторы
```hemlock
let result1 = 12 | 10 & 8;
// Вычисляется как: 12 | (10 & 8) = 12 | 8 = 12
// & имеет более высокий приоритет, чем |

let result2 = 8 | 1 << 2;
// Вычисляется как: 8 | (1 << 2) = 8 | 4 = 12
// Сдвиг имеет более высокий приоритет, чем побитовое ИЛИ

// Используйте скобки для ясности
let result3 = (5 & 3) | (2 << 1);
// Вычисляется как: 1 | 4 = 5
```

### Пример 3: Логические операторы
```hemlock
let result = true || false && false;
// Вычисляется как: true || (false && false) = true
// && имеет более высокий приоритет, чем ||

let cmp = 5 < 10 && 10 < 20;
// Вычисляется как: (5 < 10) && (10 < 20) = true
// Сравнение имеет более высокий приоритет, чем &&
```

### Пример 4: Использование скобок
```hemlock
// Без скобок
let a = 2 + 3 * 4;        // 14

// Со скобками
let b = (2 + 3) * 4;      // 20

// Сложное выражение
let c = (a + b) * (a - b);
```

---

## Поведение операторов для конкретных типов

### Деление (всегда Float)

Оператор `/` **всегда возвращает float** (f64), независимо от типов операндов:

```hemlock
print(10 / 3);             // 3.333... (f64)
print(5 / 2);              // 2.5 (f64)
print(10.0 / 4.0);         // 2.5 (f64)
print(-7 / 3);             // -2.333... (f64)
```

Это предотвращает распространённую ошибку неожиданного целочисленного усечения.

### Целочисленное деление (div / divi)

Для целочисленного деления с округлением вниз (как целочисленное деление в других языках) используйте функции `div()` и `divi()`:

```hemlock
// div(a, b) - целочисленное деление, возвращающее float
print(div(5, 2));          // 2 (f64)
print(div(-7, 3));         // -3 (f64)  -- округление к -бесконечности

// divi(a, b) - целочисленное деление, возвращающее integer
print(divi(5, 2));         // 2 (i64)
print(divi(-7, 3));        // -3 (i64)
print(typeof(divi(5, 2))); // i64
```

**Математические функции, возвращающие целые:**
Для других операций округления, возвращающих целые числа:

```hemlock
print(floori(3.7));        // 3 (i64)
print(ceili(3.2));         // 4 (i64)
print(roundi(3.5));        // 4 (i64)
print(trunci(3.9));        // 3 (i64)

// Их можно использовать напрямую как индексы массива
let arr = [10, 20, 30, 40];
print(arr[floori(1.9)]);   // 20 (индекс 1)
```

### Сравнение строк

Строки сравниваются лексикографически:

```hemlock
print("abc" < "def");      // true
print("apple" > "banana"); // false
print("hello" == "hello"); // true
```

### Сравнение с Null

```hemlock
let x = null;

print(x == null);          // true
print(x != null);          // false
```

### Ошибки типов

Некоторые операции не допускаются между несовместимыми типами:

```hemlock
// ОШИБКА: Нельзя использовать побитовые операторы с float
let x = 3.14 & 2.71;

// ОШИБКА: Нельзя использовать побитовые операторы со строками
let y = "hello" & "world";

// OK: Продвижение типов для арифметики
let a: u8 = 10;
let b: i32 = 20;
let c = a + b;             // i32 (продвинуто)
```

---

## См. также

- [Система типов](type-system.md) - Правила продвижения и преобразования типов
- [Встроенные функции](builtins.md) - Встроенные операции
- [API строк](string-api.md) - Конкатенация строк и методы
