# Справочник по API памяти

Полный справочник по функциям управления памятью и типам указателей Hemlock.

---

## Обзор

Hemlock предоставляет **ручное управление памятью** с явным выделением и освобождением. Память управляется через два типа указателей: сырые указатели (`ptr`) и безопасные буферы (`buffer`).

**Ключевые принципы:**
- Явное выделение и освобождение
- Нет сборки мусора
- Пользователь отвечает за вызов `free()`
- Внутренний подсчёт ссылок для безопасности областей видимости/переприсваивания (см. ниже)

### Внутренний подсчёт ссылок

Среда выполнения использует подсчёт ссылок внутренне для управления временем жизни объектов в областях видимости. Для большинства локальных переменных очистка происходит автоматически.

**Автоматически (не нужен `free()`):**
- Локальные переменные типов с подсчётом ссылок (buffer, array, object, string) освобождаются при выходе из области видимости
- Старые значения освобождаются при переприсваивании переменных
- Элементы контейнеров освобождаются при освобождении контейнеров

**Требуется ручной `free()`:**
- Сырые указатели от `alloc()` - всегда
- Ранняя очистка до выхода из области видимости
- Долгоживущие/глобальные данные

См. [Руководство по управлению памятью](../language-guide/memory.md#internal-reference-counting) для подробностей.

---

## Типы указателей

### ptr (Сырой указатель)

**Тип:** `ptr`

**Описание:** Сырой адрес памяти без проверки границ или отслеживания.

**Размер:** 8 байтов

**Случаи использования:**
- Низкоуровневые операции с памятью
- FFI (интерфейс внешних функций)
- Максимальная производительность (без накладных расходов)

**Безопасность:** Небезопасен - нет проверки границ, пользователь должен отслеживать время жизни

**Примеры:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

---

### buffer (Безопасный буфер)

**Тип:** `buffer`

**Описание:** Безопасная обёртка указателя с проверкой границ.

**Структура:** Указатель + длина + ёмкость + счётчик_ссылок

**Свойства:**
- `.length` - Размер буфера (i32)
- `.capacity` - Выделенная ёмкость (i32)

**Случаи использования:**
- Большинство выделений памяти
- Когда важна безопасность
- Динамические массивы

**Безопасность:** Проверка границ при доступе по индексу

**Подсчёт ссылок:** Буферы внутренне подсчитываются. Автоматически освобождаются при выходе из области видимости или переприсваивании переменной. Используйте `free()` для ранней очистки или долгоживущих данных.

**Примеры:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // С проверкой границ
print(b.length);        // 64
free(b);
```

---

## Функции выделения памяти

### alloc

Выделить сырую память.

**Сигнатура:**
```hemlock
alloc(size: i32): ptr
```

**Параметры:**
- `size` - Количество байтов для выделения

**Возвращает:** Указатель на выделенную память (`ptr`)

**Примеры:**
```hemlock
let p = alloc(1024);        // Выделить 1КБ
memset(p, 0, 1024);         // Инициализировать нулями
free(p);                    // Освободить по завершении

// Выделение для структуры
let struct_size = 16;
let p2 = alloc(struct_size);
```

**Поведение:**
- Возвращает неинициализированную память
- Память должна быть освобождена вручную
- Возвращает `null` при неудаче выделения (вызывающий должен проверить)

**См. также:** `buffer()` для более безопасной альтернативы

---

### buffer

Выделить безопасный буфер с проверкой границ.

**Сигнатура:**
```hemlock
buffer(size: i32): buffer
```

**Параметры:**
- `size` - Размер буфера в байтах

**Возвращает:** Объект буфера

**Примеры:**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256
print(buf.capacity);        // 256

// Доступ с проверкой границ
buf[0] = 65;                // 'A'
buf[255] = 90;              // 'Z'
// buf[256] = 0;            // ОШИБКА: выход за границы

free(buf);
```

**Свойства:**
- `.length` - Текущий размер (i32)
- `.capacity` - Выделенная ёмкость (i32)

**Поведение:**
- Инициализирует память нулями
- Предоставляет проверку границ при доступе по индексу
- Возвращает `null` при неудаче выделения (вызывающий должен проверить)
- Должен быть освобождён вручную

---

### free

Освободить выделенную память.

**Сигнатура:**
```hemlock
free(ptr: ptr | buffer): null
```

**Параметры:**
- `ptr` - Указатель или буфер для освобождения

**Возвращает:** `null`

**Примеры:**
```hemlock
// Освободить сырой указатель
let p = alloc(1024);
free(p);

// Освободить буфер
let buf = buffer(256);
free(buf);
```

**Поведение:**
- Освобождает память, выделенную `alloc()` или `buffer()`
- Двойное освобождение вызывает крах (ответственность пользователя избегать)
- Освобождение недействительных указателей вызывает неопределённое поведение

**Важно:** Вы выделяете - вы освобождаете. Нет автоматической очистки.

---

### realloc

Изменить размер выделенной памяти.

**Сигнатура:**
```hemlock
realloc(ptr: ptr, new_size: i32): ptr
```

**Параметры:**
- `ptr` - Указатель для изменения размера
- `new_size` - Новый размер в байтах

**Возвращает:** Указатель на память с изменённым размером (может быть другой адрес)

**Примеры:**
```hemlock
let p = alloc(100);
// ... использование памяти ...

// Нужно больше места
p = realloc(p, 200);        // Теперь 200 байтов
// ... использование расширенной памяти ...

free(p);
```

**Поведение:**
- Может переместить память на новое место
- Сохраняет существующие данные (до минимума из старого/нового размера)
- Старый указатель недействителен после успешного realloc (используйте возвращённый указатель)
- Если new_size меньше, данные усекаются
- Возвращает `null` при неудаче выделения (оригинальный указатель остаётся действительным)

**Важно:** Всегда проверяйте на `null` и обновляйте переменную указателя результатом.

---

## Операции с памятью

### memset

Заполнить память байтовым значением.

**Сигнатура:**
```hemlock
memset(ptr: ptr, byte: i32, size: i32): null
```

**Параметры:**
- `ptr` - Указатель на память
- `byte` - Байтовое значение для заполнения (0-255)
- `size` - Количество байтов для заполнения

**Возвращает:** `null`

**Примеры:**
```hemlock
let p = alloc(100);

// Обнулить память
memset(p, 0, 100);

// Заполнить конкретным значением
memset(p, 0xFF, 100);

// Инициализировать буфер
let buf = alloc(256);
memset(buf, 65, 256);       // Заполнить 'A'

free(p);
free(buf);
```

**Поведение:**
- Записывает байтовое значение в каждый байт диапазона
- Байтовое значение усекается до 8 бит (0-255)
- Нет проверки границ (небезопасно)

---

### memcpy

Копировать память из источника в место назначения.

**Сигнатура:**
```hemlock
memcpy(dest: ptr, src: ptr, size: i32): null
```

**Параметры:**
- `dest` - Указатель назначения
- `src` - Указатель источника
- `size` - Количество байтов для копирования

**Возвращает:** `null`

**Примеры:**
```hemlock
let src = alloc(100);
let dest = alloc(100);

// Инициализировать источник
memset(src, 65, 100);

// Копировать в место назначения
memcpy(dest, src, 100);

// dest теперь содержит те же данные, что и src

free(src);
free(dest);
```

**Поведение:**
- Копирует побайтово из src в dest
- Нет проверки границ (небезопасно)
- Перекрывающиеся области имеют неопределённое поведение (используйте осторожно)

---

## Типизированные операции с памятью

### sizeof

Получить размер типа в байтах.

**Сигнатура:**
```hemlock
sizeof(type): i32
```

**Параметры:**
- `type` - Идентификатор типа (напр., `i32`, `f64`, `ptr`)

**Возвращает:** Размер в байтах (i32)

**Размеры типов:**

| Тип | Размер (байты) |
|-----|----------------|
| `i8` | 1 |
| `i16` | 2 |
| `i32`, `integer` | 4 |
| `i64` | 8 |
| `u8`, `byte` | 1 |
| `u16` | 2 |
| `u32` | 4 |
| `u64` | 8 |
| `f32` | 4 |
| `f64`, `number` | 8 |
| `bool` | 1 |
| `ptr` | 8 |
| `rune` | 4 |

**Примеры:**
```hemlock
let int_size = sizeof(i32);      // 4
let ptr_size = sizeof(ptr);      // 8
let float_size = sizeof(f64);    // 8
let byte_size = sizeof(u8);      // 1
let rune_size = sizeof(rune);    // 4

// Вычисление размера выделения массива
let count = 100;
let total = sizeof(i32) * count; // 400 байтов
```

**Поведение:**
- Возвращает 0 для неизвестных типов
- Принимает как идентификаторы типов, так и строки типов

---

### talloc

Выделить массив типизированных значений.

**Сигнатура:**
```hemlock
talloc(type, count: i32): ptr
```

**Параметры:**
- `type` - Тип для выделения (напр., `i32`, `f64`, `ptr`)
- `count` - Количество элементов (должно быть положительным)

**Возвращает:** Указатель на выделенный массив, или `null` при неудаче выделения

**Примеры:**
```hemlock
let arr = talloc(i32, 100);      // Массив из 100 i32 (400 байтов)
let floats = talloc(f64, 50);    // Массив из 50 f64 (400 байтов)
let bytes = talloc(u8, 1024);    // Массив из 1024 байтов

// Всегда проверяйте на неудачу выделения
if (arr == null) {
    panic("выделение не удалось");
}

// Использование выделенной памяти
// ...

free(arr);
free(floats);
free(bytes);
```

**Поведение:**
- Выделяет `sizeof(type) * count` байтов
- Возвращает неинициализированную память
- Память должна быть освобождена вручную с помощью `free()`
- Возвращает `null` при неудаче выделения (вызывающий должен проверить)
- Паникует, если count не положительный

---

## Свойства буфера

### .length

Получить размер буфера.

**Тип:** `i32`

**Доступ:** Только для чтения

**Примеры:**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256

let buf2 = buffer(1024);
print(buf2.length);         // 1024
```

---

### .capacity

Получить ёмкость буфера.

**Тип:** `i32`

**Доступ:** Только для чтения

**Примеры:**
```hemlock
let buf = buffer(256);
print(buf.capacity);        // 256
```

**Примечание:** В настоящее время `.length` и `.capacity` одинаковы для буферов, созданных с помощью `buffer()`.

---

## Паттерны использования

### Базовый паттерн выделения

```hemlock
// Выделить
let p = alloc(1024);
if (p == null) {
    panic("выделение не удалось");
}

// Использовать
memset(p, 0, 1024);

// Освободить
free(p);
```

### Паттерн безопасного буфера

```hemlock
// Выделить буфер
let buf = buffer(256);
if (buf == null) {
    panic("выделение буфера не удалось");
}

// Использовать с проверкой границ
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

// Освободить
free(buf);
```

### Паттерн динамического роста

```hemlock
let size = 100;
let p = alloc(size);
if (p == null) {
    panic("выделение не удалось");
}

// ... использование памяти ...

// Нужно больше места - проверить на неудачу
let new_p = realloc(p, 200);
if (new_p == null) {
    // Оригинальный указатель всё ещё действителен, очистить
    free(p);
    panic("realloc не удался");
}
p = new_p;
size = 200;

// ... использование расширенной памяти ...

free(p);
```

### Паттерн копирования памяти

```hemlock
let original = alloc(100);
memset(original, 65, 100);

// Создать копию
let copy = alloc(100);
memcpy(copy, original, 100);

free(original);
free(copy);
```

---

## Соображения безопасности

**Управление памятью в Hemlock НЕБЕЗОПАСНО по замыслу:**

### Распространённые ошибки

**1. Утечки памяти**
```hemlock
// ПЛОХО: Утечка памяти
fn create_buffer() {
    let p = alloc(1024);
    return null;  // Память утекла!
}

// ХОРОШО: Правильная очистка
fn create_buffer() {
    let p = alloc(1024);
    // ... использование памяти ...
    free(p);
    return null;
}
```

**2. Использование после освобождения**
```hemlock
// ПЛОХО: Использование после освобождения
let p = alloc(100);
free(p);
memset(p, 0, 100);  // КРАХ: использование освобождённой памяти

// ХОРОШО: Не использовать после освобождения
let p2 = alloc(100);
memset(p2, 0, 100);
free(p2);
// Не трогать p2 после этого
```

**3. Двойное освобождение**
```hemlock
// ПЛОХО: Двойное освобождение
let p = alloc(100);
free(p);
free(p);  // КРАХ: двойное освобождение

// ХОРОШО: Освободить один раз
let p2 = alloc(100);
free(p2);
```

**4. Переполнение буфера (ptr)**
```hemlock
// ПЛОХО: Переполнение буфера с ptr
let p = alloc(10);
memset(p, 65, 100);  // КРАХ: запись за пределы выделения

// ХОРОШО: Использовать buffer для проверки границ
let buf = buffer(10);
// buf[100] = 65;  // ОШИБКА: проверка границ не пройдена
```

**5. Висячие указатели**
```hemlock
// ПЛОХО: Висячий указатель
let p1 = alloc(100);
let p2 = p1;
free(p1);
memset(p2, 0, 100);  // КРАХ: p2 висячий

// ХОРОШО: Тщательно отслеживать владение
let p = alloc(100);
// ... использование p ...
free(p);
// Не хранить другие ссылки на p
```

**6. Непроверенная неудача выделения**
```hemlock
// ПЛОХО: Без проверки на null
let p = alloc(1000000000);  // Может не удаться при малой памяти
memset(p, 0, 1000000000);   // КРАХ: p равен null

// ХОРОШО: Всегда проверять результат выделения
let p2 = alloc(1000000000);
if (p2 == null) {
    panic("недостаточно памяти");
}
memset(p2, 0, 1000000000);
free(p2);
```

---

## Когда что использовать

### Используйте `buffer()` когда:
- Нужна проверка границ
- Работа с динамическими данными
- Важна безопасность
- Изучаете Hemlock

### Используйте `alloc()` когда:
- Нужна максимальная производительность
- FFI/взаимодействие с C
- Знаете точную раскладку памяти
- Вы эксперт

### Используйте `realloc()` когда:
- Увеличение/уменьшение выделений
- Динамические массивы
- Нужно сохранить данные

---

## Полная сводка функций

| Функция   | Сигнатура                              | Возвращает | Описание                   |
|-----------|----------------------------------------|------------|----------------------------|
| `alloc`   | `(size: i32)`                          | `ptr`      | Выделить сырую память      |
| `buffer`  | `(size: i32)`                          | `buffer`   | Выделить безопасный буфер  |
| `free`    | `(ptr: ptr \| buffer)`                 | `null`     | Освободить память          |
| `realloc` | `(ptr: ptr, new_size: i32)`            | `ptr`      | Изменить размер выделения  |
| `memset`  | `(ptr: ptr, byte: i32, size: i32)`     | `null`     | Заполнить память           |
| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`     | `null`     | Копировать память          |
| `sizeof`  | `(type)`                               | `i32`      | Получить размер типа       |
| `talloc`  | `(type, count: i32)`                   | `ptr`      | Выделить типизированный массив |

---

## См. также

- [Система типов](type-system.md) - Типы указателей и буферов
- [Встроенные функции](builtins.md) - Все встроенные функции
- [API строк](string-api.md) - Метод строк `.to_bytes()`
