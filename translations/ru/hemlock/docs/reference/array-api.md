# Справочник по API массивов

Полный справочник по типу массивов Hemlock и всем 18 методам массивов.

---

## Обзор

Массивы в Hemlock — это **динамические последовательности, размещаемые в куче**, которые могут содержать элементы смешанных типов. Они предоставляют комплексные методы для манипуляции и обработки данных.

**Ключевые особенности:**
- Динамический размер (автоматическое увеличение)
- Индексация с нуля
- Допускаются смешанные типы
- 18 встроенных методов
- Размещение в куче с отслеживанием ёмкости

---

## Тип массива

**Тип:** `array`

**Свойства:**
- `.length` - Количество элементов (i32)

**Синтаксис литерала:** Квадратные скобки `[элем1, элем2, ...]`

**Примеры:**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);     // 5

// Смешанные типы
let mixed = [1, "hello", true, null];
print(mixed.length);   // 4

// Пустой массив
let empty = [];
print(empty.length);   // 0
```

---

## Индексация

Массивы поддерживают индексацию с нуля с использованием `[]`:

**Чтение:**
```hemlock
let arr = [10, 20, 30];
print(arr[0]);         // 10
print(arr[1]);         // 20
print(arr[2]);         // 30
```

**Запись:**
```hemlock
let arr = [10, 20, 30];
arr[0] = 99;
arr[1] = 88;
print(arr);            // [99, 88, 30]
```

**Примечание:** Прямая индексация не выполняет проверку границ. Используйте методы для безопасности.

---

## Свойства массива

### .length

Получить количество элементов в массиве.

**Тип:** `i32`

**Примеры:**
```hemlock
let arr = [1, 2, 3];
print(arr.length);     // 3

let empty = [];
print(empty.length);   // 0

// Длина изменяется динамически
arr.push(4);
print(arr.length);     // 4

arr.pop();
print(arr.length);     // 3
```

---

## Методы массивов

### Стековые операции

#### push

Добавить элемент в конец массива.

**Сигнатура:**
```hemlock
array.push(value: any): null
```

**Параметры:**
- `value` - Элемент для добавления

**Возвращает:** `null`

**Изменяет:** Да (модифицирует массив на месте)

**Примеры:**
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]
arr.push("hello");     // [1, 2, 3, 4, 5, "hello"]
```

---

#### pop

Удалить и вернуть последний элемент.

**Сигнатура:**
```hemlock
array.pop(): any
```

**Возвращает:** Последний элемент (удалённый из массива)

**Изменяет:** Да (модифицирует массив на месте)

**Примеры:**
```hemlock
let arr = [1, 2, 3];
let last = arr.pop();  // 3
print(arr);            // [1, 2]

let last2 = arr.pop(); // 2
print(arr);            // [1]
```

**Ошибка:** Ошибка времени выполнения, если массив пуст.

---

### Операции очереди

#### shift

Удалить и вернуть первый элемент.

**Сигнатура:**
```hemlock
array.shift(): any
```

**Возвращает:** Первый элемент (удалённый из массива)

**Изменяет:** Да (модифицирует массив на месте)

**Примеры:**
```hemlock
let arr = [1, 2, 3];
let first = arr.shift();  // 1
print(arr);               // [2, 3]

let first2 = arr.shift(); // 2
print(arr);               // [3]
```

**Ошибка:** Ошибка времени выполнения, если массив пуст.

---

#### unshift

Добавить элемент в начало массива.

**Сигнатура:**
```hemlock
array.unshift(value: any): null
```

**Параметры:**
- `value` - Элемент для добавления

**Возвращает:** `null`

**Изменяет:** Да (модифицирует массив на месте)

**Примеры:**
```hemlock
let arr = [2, 3];
arr.unshift(1);        // [1, 2, 3]
arr.unshift(0);        // [0, 1, 2, 3]
```

---

### Вставка и удаление

#### insert

Вставить элемент по указанному индексу.

**Сигнатура:**
```hemlock
array.insert(index: i32, value: any): null
```

**Параметры:**
- `index` - Позиция для вставки (с 0)
- `value` - Элемент для вставки

**Возвращает:** `null`

**Изменяет:** Да (модифицирует массив на месте)

**Примеры:**
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // [1, 2, 3, 4, 5]

let arr2 = [1, 3];
arr2.insert(1, 2);     // [1, 2, 3]

// Вставка в конец
arr2.insert(arr2.length, 4);  // [1, 2, 3, 4]
```

**Поведение:** Сдвигает элементы начиная с указанного индекса вправо.

---

#### remove

Удалить и вернуть элемент по индексу.

**Сигнатура:**
```hemlock
array.remove(index: i32): any
```

**Параметры:**
- `index` - Позиция для удаления (с 0)

**Возвращает:** Удалённый элемент

**Изменяет:** Да (модифицирует массив на месте)

**Примеры:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let removed = arr.remove(0);  // 1
print(arr);                   // [2, 3, 4, 5]

let removed2 = arr.remove(2); // 4
print(arr);                   // [2, 3, 5]
```

**Поведение:** Сдвигает элементы после указанного индекса влево.

**Ошибка:** Ошибка времени выполнения, если индекс выходит за границы.

---

### Поиск

#### find

Найти первое вхождение значения.

**Сигнатура:**
```hemlock
array.find(value: any): i32
```

**Параметры:**
- `value` - Искомое значение

**Возвращает:** Индекс первого вхождения или `-1`, если не найдено

**Примеры:**
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2
let idx2 = arr.find(99);     // -1 (не найдено)

// Найти первый дубликат
let arr2 = [1, 2, 3, 2, 4];
let idx3 = arr2.find(2);     // 1 (первое вхождение)
```

**Сравнение:** Использует равенство значений для примитивов и строк.

---

#### contains

Проверить, содержит ли массив значение.

**Сигнатура:**
```hemlock
array.contains(value: any): bool
```

**Параметры:**
- `value` - Искомое значение

**Возвращает:** `true`, если найдено, `false` в противном случае

**Примеры:**
```hemlock
let arr = [10, 20, 30, 40];
let has = arr.contains(20);  // true
let has2 = arr.contains(99); // false

// Работает со строками
let words = ["hello", "world"];
let has3 = words.contains("hello");  // true
```

---

### Срезы и извлечение

#### slice

Извлечь подмассив по диапазону (конец не включается).

**Сигнатура:**
```hemlock
array.slice(start: i32, end: i32): array
```

**Параметры:**
- `start` - Начальный индекс (с 0, включительно)
- `end` - Конечный индекс (не включается)

**Возвращает:** Новый массив с элементами из [start, end)

**Изменяет:** Нет (возвращает новый массив)

**Примеры:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);   // [2, 3, 4]
let first_three = arr.slice(0, 3);  // [1, 2, 3]
let last_two = arr.slice(3, 5);     // [4, 5]

// Пустой срез
let empty = arr.slice(2, 2); // []
```

---

#### first

Получить первый элемент без удаления.

**Сигнатура:**
```hemlock
array.first(): any
```

**Возвращает:** Первый элемент

**Изменяет:** Нет

**Примеры:**
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1
print(arr);                  // [1, 2, 3] (без изменений)
```

**Ошибка:** Ошибка времени выполнения, если массив пуст.

---

#### last

Получить последний элемент без удаления.

**Сигнатура:**
```hemlock
array.last(): any
```

**Возвращает:** Последний элемент

**Изменяет:** Нет

**Примеры:**
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3
print(arr);                  // [1, 2, 3] (без изменений)
```

**Ошибка:** Ошибка времени выполнения, если массив пуст.

---

### Манипуляции с массивом

#### reverse

Развернуть массив на месте.

**Сигнатура:**
```hemlock
array.reverse(): null
```

**Возвращает:** `null`

**Изменяет:** Да (модифицирует массив на месте)

**Примеры:**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]
print(arr);                  // [5, 4, 3, 2, 1]

let words = ["hello", "world"];
words.reverse();             // ["world", "hello"]
```

---

#### clear

Удалить все элементы из массива.

**Сигнатура:**
```hemlock
array.clear(): null
```

**Возвращает:** `null`

**Изменяет:** Да (модифицирует массив на месте)

**Примеры:**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();
print(arr);                  // []
print(arr.length);           // 0
```

---

### Объединение массивов

#### concat

Объединить с другим массивом.

**Сигнатура:**
```hemlock
array.concat(other: array): array
```

**Параметры:**
- `other` - Массив для объединения

**Возвращает:** Новый массив с элементами из обоих массивов

**Изменяет:** Нет (возвращает новый массив)

**Примеры:**
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]
print(a);                    // [1, 2, 3] (без изменений)
print(b);                    // [4, 5, 6] (без изменений)

// Цепочка объединений
let c = [7, 8];
let all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]
```

---

### Функциональные операции

#### map

Преобразовать каждый элемент с помощью callback-функции.

**Сигнатура:**
```hemlock
array.map(callback: fn): array
```

**Параметры:**
- `callback` - Функция, принимающая элемент и возвращающая преобразованное значение

**Возвращает:** Новый массив с преобразованными элементами

**Изменяет:** Нет (возвращает новый массив)

**Примеры:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let doubled = arr.map(fn(x) { return x * 2; });
print(doubled);  // [2, 4, 6, 8, 10]

let names = ["alice", "bob"];
let upper = names.map(fn(s) { return s.to_upper(); });
print(upper);  // ["ALICE", "BOB"]
```

---

#### filter

Выбрать элементы, соответствующие предикату.

**Сигнатура:**
```hemlock
array.filter(predicate: fn): array
```

**Параметры:**
- `predicate` - Функция, принимающая элемент и возвращающая bool

**Возвращает:** Новый массив с элементами, для которых предикат вернул true

**Изменяет:** Нет (возвращает новый массив)

**Примеры:**
```hemlock
let arr = [1, 2, 3, 4, 5, 6];
let evens = arr.filter(fn(x) { return x % 2 == 0; });
print(evens);  // [2, 4, 6]

let words = ["hello", "hi", "hey", "goodbye"];
let short = words.filter(fn(s) { return s.length < 4; });
print(short);  // ["hi", "hey"]
```

---

#### reduce

Свести массив к одному значению с помощью аккумулятора.

**Сигнатура:**
```hemlock
array.reduce(callback: fn, initial: any): any
```

**Параметры:**
- `callback` - Функция, принимающая (аккумулятор, элемент) и возвращающая новый аккумулятор
- `initial` - Начальное значение аккумулятора

**Возвращает:** Итоговое накопленное значение

**Изменяет:** Нет

**Примеры:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sum = arr.reduce(fn(acc, x) { return acc + x; }, 0);
print(sum);  // 15

let product = arr.reduce(fn(acc, x) { return acc * x; }, 1);
print(product);  // 120

// Найти максимальное значение
let max = arr.reduce(fn(acc, x) {
    if (x > acc) { return x; }
    return acc;
}, arr[0]);
print(max);  // 5
```

---

### Преобразование в строку

#### join

Объединить элементы в строку с разделителем.

**Сигнатура:**
```hemlock
array.join(delimiter: string): string
```

**Параметры:**
- `delimiter` - Строка-разделитель между элементами

**Возвращает:** Строка со всеми объединёнными элементами

**Примеры:**
```hemlock
let words = ["hello", "world", "foo"];
let joined = words.join(" ");  // "hello world foo"

let numbers = [1, 2, 3];
let csv = numbers.join(",");   // "1,2,3"

// Работает со смешанными типами
let mixed = [1, "hello", true, null];
print(mixed.join(" | "));  // "1 | hello | true | null"

// Пустой разделитель
let arr = ["a", "b", "c"];
let s = arr.join("");          // "abc"
```

**Поведение:** Автоматически преобразует все элементы в строки.

---

## Цепочки методов

Методы массивов можно объединять в цепочки для краткости:

**Примеры:**
```hemlock
// Цепочка slice и join
let result = ["apple", "banana", "cherry", "date"]
    .slice(0, 2)
    .join(" and ");  // "apple and banana"

// Цепочка concat и slice
let combined = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);    // [3, 4, 5]

// Сложная цепочка
let words = ["hello", "world", "foo", "bar"];
let result2 = words
    .slice(0, 3)
    .concat(["baz"])
    .join("-");      // "hello-world-foo-baz"
```

---

## Полная сводка методов

### Изменяющие методы

Методы, которые модифицируют массив на месте:

| Метод      | Сигнатура                  | Возвращает | Описание                       |
|------------|----------------------------|------------|--------------------------------|
| `push`     | `(value: any)`             | `null`     | Добавить в конец               |
| `pop`      | `()`                       | `any`      | Удалить с конца                |
| `shift`    | `()`                       | `any`      | Удалить с начала               |
| `unshift`  | `(value: any)`             | `null`     | Добавить в начало              |
| `insert`   | `(index: i32, value: any)` | `null`     | Вставить по индексу            |
| `remove`   | `(index: i32)`             | `any`      | Удалить по индексу             |
| `reverse`  | `()`                       | `null`     | Развернуть на месте            |
| `clear`    | `()`                       | `null`     | Удалить все элементы           |

### Неизменяющие методы

Методы, которые возвращают новые значения без изменения оригинала:

| Метод      | Сигнатура                  | Возвращает | Описание                       |
|------------|----------------------------|------------|--------------------------------|
| `find`     | `(value: any)`             | `i32`      | Найти первое вхождение         |
| `contains` | `(value: any)`             | `bool`     | Проверить наличие значения     |
| `slice`    | `(start: i32, end: i32)`   | `array`    | Извлечь подмассив              |
| `first`    | `()`                       | `any`      | Получить первый элемент        |
| `last`     | `()`                       | `any`      | Получить последний элемент     |
| `concat`   | `(other: array)`           | `array`    | Объединить массивы             |
| `join`     | `(delimiter: string)`      | `string`   | Объединить элементы в строку   |
| `map`      | `(callback: fn)`           | `array`    | Преобразовать каждый элемент   |
| `filter`   | `(predicate: fn)`          | `array`    | Выбрать подходящие элементы    |
| `reduce`   | `(callback: fn, initial: any)` | `any`  | Свести к одному значению       |

---

## Паттерны использования

### Использование как стек

```hemlock
let stack = [];

// Добавление элементов
stack.push(1);
stack.push(2);
stack.push(3);

// Извлечение элементов
while (stack.length > 0) {
    let item = stack.pop();
    print(item);  // 3, 2, 1
}
```

### Использование как очередь

```hemlock
let queue = [];

// Добавление в очередь
queue.push(1);
queue.push(2);
queue.push(3);

// Извлечение из очереди
while (queue.length > 0) {
    let item = queue.shift();
    print(item);  // 1, 2, 3
}
```

### Преобразование массива

```hemlock
// Фильтрация (вручную)
let numbers = [1, 2, 3, 4, 5, 6];
let evens = [];
let i = 0;
while (i < numbers.length) {
    if (numbers[i] % 2 == 0) {
        evens.push(numbers[i]);
    }
    i = i + 1;
}

// Отображение (вручную)
let numbers2 = [1, 2, 3, 4, 5];
let doubled = [];
let j = 0;
while (j < numbers2.length) {
    doubled.push(numbers2[j] * 2);
    j = j + 1;
}
```

### Построение массивов

```hemlock
let arr = [];

// Построение массива в цикле
let i = 0;
while (i < 10) {
    arr.push(i * 10);
    i = i + 1;
}

print(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
```

---

## Детали реализации

**Управление ёмкостью:**
- Массивы автоматически увеличиваются при необходимости
- Ёмкость удваивается при превышении
- Нет ручного управления ёмкостью

**Сравнение значений:**
- `find()` и `contains()` используют равенство значений
- Корректно работает для примитивов и строк
- Объекты/массивы сравниваются по ссылке

**Память:**
- Размещается в куче
- Нет автоматического освобождения (ручное управление памятью)
- Нет проверки границ при прямом доступе по индексу

---

## См. также

- [Система типов](type-system.md) - Детали типа массива
- [API строк](string-api.md) - Результаты метода join()
- [Операторы](operators.md) - Оператор индексации массива
