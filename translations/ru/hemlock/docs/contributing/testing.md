# Руководство по тестированию Hemlock

Это руководство объясняет философию тестирования Hemlock, как писать тесты и как запускать набор тестов.

---

## Содержание

- [Философия тестирования](#философия-тестирования)
- [Структура набора тестов](#структура-набора-тестов)
- [Запуск тестов](#запуск-тестов)
- [Написание тестов](#написание-тестов)
- [Категории тестов](#категории-тестов)
- [Тестирование на утечки памяти](#тестирование-на-утечки-памяти)
- [Непрерывная интеграция](#непрерывная-интеграция)
- [Лучшие практики](#лучшие-практики)

---

## Философия тестирования

### Основные принципы

**1. Разработка через тестирование (TDD)**

Пишите тесты **до** реализации функций:

```
1. Напишите падающий тест
2. Реализуйте функцию
3. Запустите тест (должен пройти)
4. Рефакторинг при необходимости
5. Повторите
```

**Преимущества:**
- Гарантирует, что функции действительно работают
- Предотвращает регрессии
- Документирует ожидаемое поведение
- Делает рефакторинг безопаснее

**2. Всестороннее покрытие**

Тестируйте как успешные, так и неуспешные случаи:

```hemlock
// Успешный случай
let x: u8 = 255;  // Должно работать

// Неуспешный случай
let y: u8 = 256;  // Должно вызвать ошибку
```

**3. Тестируйте рано и часто**

Запускайте тесты:
- Перед фиксацией кода
- После внесения изменений
- Перед отправкой pull request
- Во время код-ревью

**Правило:** Все тесты должны проходить перед слиянием.

### Что тестировать

**Всегда тестируйте:**
- Базовую функциональность (успешный путь)
- Условия ошибок (неуспешный путь)
- Граничные случаи (пограничные условия)
- Проверку типов и преобразования
- Управление памятью (без утечек)
- Параллелизм и состояния гонки

**Пример покрытия тестами:**
```hemlock
// Функция: String.substr(start, length)

// Успешный путь
print("hello".substr(0, 5));  // "hello"

// Граничные случаи
print("hello".substr(0, 0));  // "" (пусто)
print("hello".substr(5, 0));  // "" (в конце)
print("hello".substr(2, 100)); // "llo" (за пределами)

// Случаи ошибок
// "hello".substr(-1, 5);  // Ошибка: отрицательный индекс
// "hello".substr(0, -1);  // Ошибка: отрицательная длина
```

---

## Структура набора тестов

### Организация директорий

```
tests/
├── run_tests.sh          # Основной скрипт запуска тестов
├── primitives/           # Тесты системы типов
│   ├── integers.hml
│   ├── floats.hml
│   ├── booleans.hml
│   ├── i64.hml
│   └── u64.hml
├── conversions/          # Тесты преобразования типов
│   ├── int_to_float.hml
│   ├── promotion.hml
│   └── rune_conversions.hml
├── memory/               # Тесты указателей/буферов
│   ├── alloc.hml
│   ├── buffer.hml
│   └── memcpy.hml
├── strings/              # Тесты строковых операций
│   ├── concat.hml
│   ├── methods.hml
│   ├── utf8.hml
│   └── runes.hml
├── control/              # Тесты потока управления
│   ├── if.hml
│   ├── switch.hml
│   └── while.hml
├── functions/            # Тесты функций и замыканий
│   ├── basics.hml
│   ├── closures.hml
│   └── recursion.hml
├── objects/              # Тесты объектов
│   ├── literals.hml
│   ├── methods.hml
│   ├── duck_typing.hml
│   └── serialization.hml
├── arrays/               # Тесты операций с массивами
│   ├── basics.hml
│   ├── methods.hml
│   └── slicing.hml
├── loops/                # Тесты циклов
│   ├── for.hml
│   ├── while.hml
│   ├── break.hml
│   └── continue.hml
├── exceptions/           # Тесты обработки ошибок
│   ├── try_catch.hml
│   ├── finally.hml
│   └── throw.hml
├── io/                   # Тесты файлового ввода-вывода
│   ├── file_object.hml
│   ├── read_write.hml
│   └── seek.hml
├── async/                # Тесты параллелизма
│   ├── spawn_join.hml
│   ├── channels.hml
│   └── exceptions.hml
├── ffi/                  # Тесты FFI
│   ├── basic_call.hml
│   ├── types.hml
│   └── dlopen.hml
├── signals/              # Тесты обработки сигналов
│   ├── basic.hml
│   ├── handlers.hml
│   └── raise.hml
└── args/                 # Тесты аргументов командной строки
    └── basic.hml
```

### Именование тестовых файлов

**Соглашения:**
- Используйте описательные имена: `method_chaining.hml`, а не `test1.hml`
- Группируйте связанные тесты: `string_substr.hml`, `string_slice.hml`
- Одна функциональная область на файл
- Файлы должны быть сфокусированными и небольшими

---

## Запуск тестов

### Запуск всех тестов

```bash
# Из корневой директории hemlock
make test

# Или напрямую
./tests/run_tests.sh
```

**Вывод:**
```
Running tests in tests/primitives/...
  ✓ integers.hml
  ✓ floats.hml
  ✓ booleans.hml

Running tests in tests/strings/...
  ✓ concat.hml
  ✓ methods.hml

...

Total: 251 tests
Passed: 251
Failed: 0
```

### Запуск определённой категории

```bash
# Запуск только тестов строк
./tests/run_tests.sh tests/strings/

# Запуск только одного тестового файла
./tests/run_tests.sh tests/strings/concat.hml

# Запуск нескольких категорий
./tests/run_tests.sh tests/strings/ tests/arrays/
```

### Запуск с Valgrind (проверка утечек памяти)

```bash
# Проверка одного теста на утечки
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml

# Проверка всех тестов (медленно!)
for test in tests/**/*.hml; do
    echo "Testing $test"
    valgrind --leak-check=full --error-exitcode=1 ./hemlock "$test"
done
```

### Отладка упавших тестов

```bash
# Запуск с подробным выводом
./hemlock tests/failing_test.hml

# Запуск с gdb
gdb --args ./hemlock tests/failing_test.hml
(gdb) run
(gdb) backtrace  # если произошёл сбой
```

---

## Написание тестов

### Формат тестового файла

Тестовые файлы - это просто программы Hemlock с ожидаемым выводом:

**Пример: tests/primitives/integers.hml**
```hemlock
// Тест базовых целочисленных литералов
let x = 42;
print(x);  // Ожидается: 42

let y: i32 = 100;
print(y);  // Ожидается: 100

// Тест арифметики
let sum = x + y;
print(sum);  // Ожидается: 142

// Тест вывода типа
let small = 10;
print(typeof(small));  // Ожидается: i32

let large = 5000000000;
print(typeof(large));  // Ожидается: i64
```

**Как работают тесты:**
1. Запускающий тесты выполняет файл .hml
2. Захватывает вывод stdout
3. Сравнивает с ожидаемым выводом (из комментариев или отдельного файла .out)
4. Сообщает о прохождении/падении

### Методы указания ожидаемого вывода

**Метод 1: Встроенные комментарии (рекомендуется для простых тестов)**

```hemlock
print("hello");  // Ожидается: hello
print(42);       // Ожидается: 42
```

Запускающий тесты разбирает комментарии `// Ожидается: ...`.

**Метод 2: Отдельный файл .out**

Создайте `test_name.hml.out` с ожидаемым выводом:

**test_name.hml:**
```hemlock
print("line 1");
print("line 2");
print("line 3");
```

**test_name.hml.out:**
```
line 1
line 2
line 3
```

### Тестирование случаев ошибок

Тесты ошибок должны завершать программу с ненулевым статусом:

**Пример: tests/primitives/range_error.hml**
```hemlock
// Это должно завершиться с ошибкой типа
let x: u8 = 256;  // Выходит за диапазон для u8
```

**Ожидаемое поведение:**
- Программа завершается с ненулевым статусом
- Выводит сообщение об ошибке в stderr

**Обработка запускающим тесты:**
- Тесты, ожидающие ошибки, должны быть в отдельных файлах
- Используйте соглашение об именовании: `*_error.hml` или `*_fail.hml`
- Документируйте ожидаемую ошибку в комментариях

### Тестирование успешных случаев

**Пример: tests/strings/methods.hml**
```hemlock
// Тест substr
let s = "hello world";
let sub = s.substr(6, 5);
print(sub);  // Ожидается: world

// Тест find
let pos = s.find("world");
print(pos);  // Ожидается: 6

// Тест contains
let has = s.contains("lo");
print(has);  // Ожидается: true

// Тест trim
let padded = "  hello  ";
let trimmed = padded.trim();
print(trimmed);  // Ожидается: hello
```

### Тестирование граничных случаев

**Пример: tests/arrays/edge_cases.hml**
```hemlock
// Пустой массив
let empty = [];
print(empty.length);  // Ожидается: 0

// Один элемент
let single = [42];
print(single[0]);  // Ожидается: 42

// Отрицательный индекс (должен вызвать ошибку в отдельном тестовом файле)
// print(single[-1]);  // Ошибка

// Индекс за пределами (должен вызвать ошибку)
// print(single[100]);  // Ошибка

// Пограничные условия
let arr = [1, 2, 3];
print(arr.slice(0, 0));  // Ожидается: [] (пусто)
print(arr.slice(3, 3));  // Ожидается: [] (пусто)
print(arr.slice(1, 2));  // Ожидается: [2]
```

### Тестирование системы типов

**Пример: tests/conversions/promotion.hml**
```hemlock
// Тест продвижения типов в бинарных операциях

// i32 + i64 -> i64
let a: i32 = 10;
let b: i64 = 20;
let c = a + b;
print(typeof(c));  // Ожидается: i64

// i32 + f32 -> f32
let d: i32 = 10;
let e: f32 = 3.14;
let f = d + e;
print(typeof(f));  // Ожидается: f32

// u8 + i32 -> i32
let g: u8 = 5;
let h: i32 = 10;
let i = g + h;
print(typeof(i));  // Ожидается: i32
```

### Тестирование параллелизма

**Пример: tests/async/basic.hml**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Запуск задач
let t1 = spawn(compute, 10);
let t2 = spawn(compute, 20);

// Ожидание и вывод результатов
let r1 = join(t1);
let r2 = join(t2);
print(r1);  // Ожидается: 45
print(r2);  // Ожидается: 190
```

### Тестирование исключений

**Пример: tests/exceptions/try_catch.hml**
```hemlock
// Тест базового try/catch
try {
    throw "error message";
} catch (e) {
    print("Caught: " + e);  // Ожидается: Caught: error message
}

// Тест finally
let executed = false;
try {
    print("try");  // Ожидается: try
} finally {
    executed = true;
    print("finally");  // Ожидается: finally
}

// Тест распространения исключений
fn risky(): i32 {
    throw "failure";
}

try {
    risky();
} catch (e) {
    print(e);  // Ожидается: failure
}
```

---

## Категории тестов

### Тесты примитивов

**Что тестировать:**
- Целочисленные типы (i8, i16, i32, i64, u8, u16, u32, u64)
- Типы с плавающей точкой (f32, f64)
- Булев тип
- Строковый тип
- Тип rune
- Тип null

**Примеры областей:**
- Синтаксис литералов
- Вывод типа
- Проверка диапазона
- Поведение при переполнении
- Аннотации типов

### Тесты преобразований

**Что тестировать:**
- Неявное продвижение типов
- Явное преобразование типов
- Преобразования с потерей данных (должны вызывать ошибку)
- Продвижение типов в операциях
- Сравнения между типами

### Тесты памяти

**Что тестировать:**
- Корректность alloc/free
- Создание и доступ к буферу
- Проверка границ буферов
- memset, memcpy, realloc
- Обнаружение утечек памяти (valgrind)

### Тесты строк

**Что тестировать:**
- Конкатенация
- Все 18 строковых методов
- Обработка UTF-8
- Индексация по rune
- Конкатенация строки + rune
- Граничные случаи (пустые строки, один символ и т.д.)

### Тесты потока управления

**Что тестировать:**
- if/else/else if
- Циклы while
- Циклы for
- Операторы switch
- break/continue
- Операторы return

### Тесты функций

**Что тестировать:**
- Определение и вызов функций
- Передача параметров
- Возвращаемые значения
- Рекурсия
- Замыкания и захват
- Функции первого класса
- Анонимные функции

### Тесты объектов

**Что тестировать:**
- Литералы объектов
- Доступ к полям и присваивание
- Методы и привязка self
- Утиная типизация
- Необязательные поля
- Сериализация/десериализация JSON
- Обнаружение циклических ссылок

### Тесты массивов

**Что тестировать:**
- Создание массивов
- Индексация и присваивание
- Все 15 методов массивов
- Смешанные типы
- Динамическое изменение размера
- Граничные случаи (пустой, один элемент)

### Тесты исключений

**Что тестировать:**
- try/catch/finally
- Оператор throw
- Распространение исключений
- Вложенный try/catch
- Return в try/catch/finally
- Неперехваченные исключения

### Тесты ввода-вывода

**Что тестировать:**
- Режимы открытия файлов
- Операции чтения/записи
- Seek/tell
- Свойства файлов
- Обработка ошибок (отсутствующие файлы и т.д.)
- Очистка ресурсов

### Тесты async

**Что тестировать:**
- spawn/join/detach
- Каналы send/recv
- Распространение исключений в задачах
- Несколько параллельных задач
- Блокирующее поведение каналов

### Тесты FFI

**Что тестировать:**
- dlopen/dlclose
- dlsym
- dlcall с различными типами
- Преобразование типов
- Обработка ошибок

---

## Тестирование на утечки памяти

### Использование Valgrind

**Базовое использование:**
```bash
valgrind --leak-check=full ./hemlock test.hml
```

**Пример вывода (без утечек):**
```
==12345== HEAP SUMMARY:
==12345==     in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated
==12345==
==12345== All heap blocks were freed -- no leaks are possible
```

**Пример вывода (с утечкой):**
```
==12345== LEAK SUMMARY:
==12345==    definitely lost: 64 bytes in 1 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==      possibly lost: 0 bytes in 0 blocks
==12345==    still reachable: 0 bytes in 0 blocks
==12345==         suppressed: 0 bytes in 0 blocks
```

### Распространённые источники утечек

**1. Отсутствующие вызовы free():**
```c
// ПЛОХО
char *str = malloc(100);
// ... используем str
// Забыли освободить!

// ХОРОШО
char *str = malloc(100);
// ... используем str
free(str);
```

**2. Потерянные указатели:**
```c
// ПЛОХО
char *ptr = malloc(100);
ptr = malloc(200);  // Потеряли ссылку на первое выделение!

// ХОРОШО
char *ptr = malloc(100);
free(ptr);
ptr = malloc(200);
```

**3. Пути исключений:**
```c
// ПЛОХО
void func() {
    char *data = malloc(100);
    if (error_condition) {
        return;  // Утечка!
    }
    free(data);
}

// ХОРОШО
void func() {
    char *data = malloc(100);
    if (error_condition) {
        free(data);
        return;
    }
    free(data);
}
```

### Известные допустимые утечки

Некоторые небольшие "утечки" являются намеренными выделениями при запуске:

**Глобальные встроенные функции:**
```hemlock
// Встроенные функции, типы FFI и константы выделяются при запуске
// и не освобождаются при выходе (обычно ~200 байт)
```

Это не настоящие утечки - это одноразовые выделения, которые сохраняются на всё время работы программы и очищаются ОС при выходе.

---

## Непрерывная интеграция

### GitHub Actions (в будущем)

После настройки CI все тесты будут запускаться автоматически при:
- Push в ветку main
- Создании/обновлении pull request
- Запланированных ежедневных запусках

**Рабочий процесс CI:**
1. Сборка Hemlock
2. Запуск набора тестов
3. Проверка на утечки памяти (valgrind)
4. Отчёт о результатах в PR

### Проверки перед коммитом

Перед фиксацией запустите:

```bash
# Свежая сборка
make clean && make

# Запуск всех тестов
make test

# Проверка нескольких тестов на утечки
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml
valgrind --leak-check=full ./hemlock tests/strings/concat.hml
```

---

## Лучшие практики

### Что делать

**Пишите тесты первыми (TDD)**
```bash
1. Создайте tests/feature/new_feature.hml
2. Реализуйте функцию в src/
3. Запускайте тесты до прохождения
```

**Тестируйте и успех, и неудачу**
```hemlock
// Успех: tests/feature/success.hml
let result = do_thing();
print(result);  // Ожидается: ожидаемое значение

// Неудача: tests/feature/failure.hml
do_invalid_thing();  // Должно вызвать ошибку
```

**Используйте описательные имена тестов**
```
Хорошо: tests/strings/substr_utf8_boundary.hml
Плохо:  tests/test1.hml
```

**Делайте тесты сфокусированными**
- Одна функциональная область на файл
- Чёткая подготовка и утверждения
- Минимум кода

**Добавляйте комментарии, объясняющие сложные тесты**
```hemlock
// Тест, что замыкание захватывает внешнюю переменную по ссылке
fn outer() {
    let x = 10;
    let f = fn() { return x; };
    x = 20;  // Изменение после создания замыкания
    return f();  // Должно вернуть 20, а не 10
}
```

**Тестируйте граничные случаи**
- Пустые входные данные
- Значения null
- Граничные значения (min/max)
- Большие входные данные
- Отрицательные значения

### Чего не делать

**Не пропускайте тесты**
- Все тесты должны проходить перед слиянием
- Не комментируйте падающие тесты
- Исправьте ошибку или удалите функцию

**Не пишите тесты, зависящие друг от друга**
```hemlock
// ПЛОХО: test2.hml зависит от вывода test1.hml
// Тесты должны быть независимыми
```

**Не используйте случайные значения в тестах**
```hemlock
// ПЛОХО: Недетерминированно
let x = random();
print(x);  // Невозможно предсказать вывод

// ХОРОШО: Детерминированно
let x = 42;
print(x);  // Ожидается: 42
```

**Не тестируйте детали реализации**
```hemlock
// ПЛОХО: Тестирование внутренней структуры
let obj = { x: 10 };
// Не проверяйте внутренний порядок полей, ёмкость и т.д.

// ХОРОШО: Тестирование поведения
print(obj.x);  // Ожидается: 10
```

**Не игнорируйте утечки памяти**
- Все тесты должны проходить valgrind чисто
- Документируйте известные/допустимые утечки
- Исправляйте утечки перед слиянием

### Поддержка тестов

**Когда обновлять тесты:**
- Изменяется поведение функции
- Исправления ошибок требуют новых тестовых случаев
- Обнаружены граничные случаи
- Улучшения производительности

**Когда удалять тесты:**
- Функция удалена из языка
- Тест дублирует существующее покрытие
- Тест был некорректным

**Рефакторинг тестов:**
- Группируйте связанные тесты вместе
- Выделяйте общий код подготовки
- Используйте единообразное именование
- Держите тесты простыми и читаемыми

---

## Пример тестовой сессии

Вот полный пример добавления функции с тестами:

### Функция: Добавить метод `array.first()`

**1. Сначала напишите тест:**

```bash
# Создание тестового файла
cat > tests/arrays/first_method.hml << 'EOF'
// Тест метода array.first()

// Базовый случай
let arr = [1, 2, 3];
print(arr.first());  // Ожидается: 1

// Один элемент
let single = [42];
print(single.first());  // Ожидается: 42

// Пустой массив (должен вызвать ошибку - отдельный тестовый файл)
// let empty = [];
// print(empty.first());  // Ошибка
EOF
```

**2. Запустите тест (должен упасть):**

```bash
./hemlock tests/arrays/first_method.hml
# Error: Method 'first' not found on array
```

**3. Реализуйте функцию:**

Отредактируйте `src/interpreter/builtins.c`:

```c
// Добавьте метод array_first
Value *array_first(Value *self, Value **args, int arg_count)
{
    if (self->array_value->length == 0) {
        fprintf(stderr, "Error: Cannot get first element of empty array\n");
        exit(1);
    }

    return value_copy(&self->array_value->elements[0]);
}

// Зарегистрируйте в таблице методов массива
// ... добавьте регистрацию метода массива
```

**4. Запустите тест (должен пройти):**

```bash
./hemlock tests/arrays/first_method.hml
1
42
# Успех!
```

**5. Проверьте на утечки памяти:**

```bash
valgrind --leak-check=full ./hemlock tests/arrays/first_method.hml
# All heap blocks were freed -- no leaks are possible
```

**6. Запустите полный набор тестов:**

```bash
make test
# Total: 252 tests (251 + новый)
# Passed: 252
# Failed: 0
```

**7. Зафиксируйте:**

```bash
git add tests/arrays/first_method.hml src/interpreter/builtins.c
git commit -m "Add array.first() method with tests"
```

---

## Резюме

**Помните:**
- Сначала пишите тесты (TDD)
- Тестируйте успешные и неуспешные случаи
- Запускайте все тесты перед фиксацией
- Проверяйте на утечки памяти
- Документируйте известные проблемы
- Держите тесты простыми и сфокусированными

**Качество тестов так же важно, как и качество кода!**
