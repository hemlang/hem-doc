# Вклад в развитие Hemlock

Благодарим вас за интерес к участию в развитии Hemlock! Это руководство поможет вам понять, как эффективно вносить вклад, сохраняя философию проектирования языка и качество кода.

---

## Содержание

- [Перед началом работы](#перед-началом-работы)
- [Рабочий процесс участия](#рабочий-процесс-участия)
- [Рекомендации по стилю кода](#рекомендации-по-стилю-кода)
- [Что можно добавлять](#что-можно-добавлять)
- [Чего НЕ следует добавлять](#чего-не-следует-добавлять)
- [Типичные паттерны](#типичные-паттерны)
- [Добавление новых функций](#добавление-новых-функций)
- [Процесс код-ревью](#процесс-код-ревью)

---

## Перед началом работы

### Обязательное чтение

Перед началом участия, пожалуйста, прочитайте эти документы в указанном порядке:

1. **`/home/user/hemlock/docs/design/philosophy.md`** - Поймите основные принципы Hemlock
2. **`/home/user/hemlock/docs/design/implementation.md`** - Изучите структуру кодовой базы
3. **`/home/user/hemlock/docs/contributing/testing.md`** - Разберитесь с требованиями к тестированию
4. **Этот документ** - Изучите рекомендации по участию

### Необходимые требования

**Необходимые знания:**
- Программирование на C (указатели, управление памятью, структуры)
- Основы компиляторов/интерпретаторов (лексический анализ, парсинг, AST)
- Git и рабочий процесс GitHub
- Командная строка Unix/Linux

**Необходимые инструменты:**
- Компилятор GCC или Clang
- Система сборки Make
- Система контроля версий Git
- Valgrind (для обнаружения утечек памяти)
- Текстовый редактор или IDE

### Каналы связи

**Где задавать вопросы:**
- GitHub Issues - Сообщения об ошибках и запросы функций
- GitHub Discussions - Общие вопросы и обсуждения дизайна
- Комментарии к Pull Request - Конкретные отзывы о коде

---

## Рабочий процесс участия

### 1. Найдите или создайте Issue

**Перед написанием кода:**
- Проверьте, существует ли Issue для вашего вклада
- Если нет, создайте его с описанием того, что вы хотите сделать
- Дождитесь обратной связи от мейнтейнеров перед началом крупных изменений
- Небольшие исправления ошибок могут пропустить этот шаг

**Хорошее описание Issue включает:**
- Постановку проблемы (что сломано или отсутствует)
- Предлагаемое решение (как вы планируете это исправить)
- Примеры (фрагменты кода, показывающие проблему)
- Обоснование (почему это изменение соответствует философии Hemlock)

### 2. Форк и клонирование

```bash
# Сначала сделайте форк репозитория на GitHub, затем:
git clone https://github.com/YOUR_USERNAME/hemlock.git
cd hemlock
git checkout -b feature/your-feature-name
```

### 3. Внесите изменения

Следуйте этим рекомендациям:
- Сначала напишите тесты (подход TDD)
- Реализуйте функцию
- Убедитесь, что все тесты проходят
- Проверьте на утечки памяти
- Обновите документацию

### 4. Протестируйте изменения

```bash
# Запустите полный набор тестов
make test

# Запустите конкретную категорию тестов
./tests/run_tests.sh tests/category/

# Проверьте на утечки памяти
valgrind ./hemlock tests/your_test.hml

# Соберите и протестируйте
make clean && make && make test
```

### 5. Зафиксируйте изменения

**Хорошие сообщения коммитов:**
```
Add bitwise operators for integer types

- Implement &, |, ^, <<, >>, ~ operators
- Add type checking to ensure integer-only operations
- Update operator precedence table
- Add comprehensive tests for all operators

Closes #42
```

**Формат сообщения коммита:**
- Первая строка: Краткое резюме (максимум 50 символов)
- Пустая строка
- Подробное объяснение (перенос на 72 символах)
- Ссылки на номера Issue

### 6. Отправьте Pull Request

**Перед отправкой:**
- Сделайте rebase на последнюю ветку main
- Убедитесь, что все тесты проходят
- Запустите valgrind для проверки на утечки
- Обновите CLAUDE.md, если добавляете пользовательские функции

**Описание Pull Request должно включать:**
- Какую проблему это решает
- Как это решает её
- Несовместимые изменения (если есть)
- Примеры нового синтаксиса или поведения
- Сводку по покрытию тестами

---

## Рекомендации по стилю кода

### Стиль кода на C

**Форматирование:**
```c
// Отступ в 4 пробела (без табуляции)
// Стиль K&R для фигурных скобок в функциях
void function_name(int arg1, char *arg2)
{
    if (condition) {
        // Скобка на той же строке для управляющих структур
        do_something();
    }
}

// Длина строки: максимум 100 символов
// Используйте пробелы вокруг операторов
int result = (a + b) * c;

// Звёздочка указателя рядом с типом
char *string;   // Правильно
char* string;   // Избегайте
char * string;  // Избегайте
```

**Соглашения об именовании:**
```c
// Функции: строчные_с_подчёркиваниями
void eval_expression(ASTNode *node);

// Типы: PascalCase
typedef struct Value Value;
typedef enum ValueType ValueType;

// Константы: ЗАГЛАВНЫЕ_С_ПОДЧЁРКИВАНИЯМИ
#define MAX_BUFFER_SIZE 4096

// Переменные: строчные_с_подчёркиваниями
int item_count;
Value *current_value;

// Перечисления: ПРЕФИКС_ТИПА_ИМЯ
typedef enum {
    TYPE_I32,
    TYPE_STRING,
    TYPE_OBJECT
} ValueType;
```

**Комментарии:**
```c
// Однострочные комментарии для кратких пояснений
// Используйте полные предложения с правильной пунктуацией

/*
 * Многострочные комментарии для более длинных объяснений
 * Выравнивайте звёздочки для читаемости
 */

/**
 * Документационный комментарий функции
 * @param node - узел AST для вычисления
 * @return Вычисленное значение
 */
Value eval_expr(ASTNode *node);
```

**Обработка ошибок:**
```c
// Проверяйте все вызовы malloc
char *buffer = malloc(size);
if (!buffer) {
    fprintf(stderr, "Error: Out of memory\n");
    exit(1);
}

// Предоставляйте контекст в сообщениях об ошибках
if (file == NULL) {
    fprintf(stderr, "Error: Failed to open '%s': %s\n",
            filename, strerror(errno));
    exit(1);
}

// Используйте информативные сообщения об ошибках
// Плохо: "Error: Invalid value"
// Хорошо: "Error: Expected integer, got string"
```

**Управление памятью:**
```c
// Всегда освобождайте то, что выделили
Value *val = value_create_i32(42);
// ... используйте val
value_free(val);

// Устанавливайте указатели в NULL после освобождения (предотвращает двойное освобождение)
free(ptr);
ptr = NULL;

// Документируйте владение в комментариях
// Эта функция забирает владение 'value' и освободит его
void store_value(Value *value);

// Эта функция НЕ забирает владение (вызывающий должен освободить)
Value *get_value(void);
```

### Организация кода

**Структура файла:**
```c
// 1. Включения (сначала системные заголовки, затем локальные)
#include <stdio.h>
#include <stdlib.h>
#include "internal.h"
#include "values.h"

// 2. Константы и макросы
#define INITIAL_CAPACITY 16

// 3. Определения типов
typedef struct Foo Foo;

// 4. Объявления статических функций (внутренние помощники)
static void helper_function(void);

// 5. Реализации публичных функций
void public_api_function(void)
{
    // Реализация
}

// 6. Реализации статических функций
static void helper_function(void)
{
    // Реализация
}
```

**Заголовочные файлы:**
```c
// Используйте защиту заголовков
#ifndef HEMLOCK_MODULE_H
#define HEMLOCK_MODULE_H

// Предварительные объявления
typedef struct Value Value;

// Только публичный API в заголовках
void public_function(Value *val);

// Документируйте параметры и возвращаемые значения
/**
 * Вычисляет узел AST выражения
 * @param node - узел AST для вычисления
 * @param env - текущее окружение
 * @return Результирующее значение
 */
Value *eval_expr(ASTNode *node, Environment *env);

#endif // HEMLOCK_MODULE_H
```

---

## Что можно добавлять

### Приветствуемые вклады

**Исправления ошибок:**
- Утечки памяти
- Ошибки сегментации
- Некорректное поведение
- Улучшения сообщений об ошибках

**Документация:**
- Комментарии к коду
- Документация API
- Руководства пользователя и учебники
- Примеры программ
- Документация тестовых случаев

**Тесты:**
- Дополнительные тестовые случаи для существующих функций
- Покрытие граничных случаев
- Регрессионные тесты для исправленных ошибок
- Бенчмарки производительности

**Небольшие дополнения функций:**
- Новые встроенные функции (если они соответствуют философии)
- Методы строк/массивов
- Вспомогательные функции
- Улучшения обработки ошибок

**Улучшения производительности:**
- Более быстрые алгоритмы (без изменения семантики)
- Уменьшение использования памяти
- Набор бенчмарков
- Инструменты профилирования

**Инструменты:**
- Подсветка синтаксиса в редакторах
- Протокол языкового сервера (LSP)
- Интеграция с отладчиком
- Улучшения системы сборки

### Сначала обсудите

**Крупные функции:**
- Новые языковые конструкции
- Изменения системы типов
- Дополнения синтаксиса
- Примитивы параллелизма

**Как обсуждать:**
1. Откройте GitHub issue или discussion
2. Опишите функцию и её обоснование
3. Покажите пример кода
4. Объясните, как это соответствует философии Hemlock
5. Дождитесь обратной связи от мейнтейнеров
6. Итерируйте над дизайном перед реализацией

---

## Чего НЕ следует добавлять

### Нежелательные вклады

**Не добавляйте функции, которые:**
- Скрывают сложность от пользователя
- Делают поведение неявным или магическим
- Нарушают существующую семантику или синтаксис
- Добавляют сборку мусора или автоматическое управление памятью
- Нарушают принцип "явное важнее неявного"

**Примеры отклонённых вкладов:**

**1. Автоматическая вставка точек с запятой**
```hemlock
// ПЛОХО: Это будет отклонено
let x = 5  // Нет точки с запятой
let y = 10 // Нет точки с запятой
```
Почему: Делает синтаксис неоднозначным, скрывает ошибки

**2. RAII/деструкторы**
```hemlock
// ПЛОХО: Это будет отклонено
let f = open("file.txt");
// Файл автоматически закрывается в конце области видимости
```
Почему: Скрывает, когда ресурсы освобождаются, неявно

**3. Неявное приведение типов с потерей данных**
```hemlock
// ПЛОХО: Это будет отклонено
let x: i32 = 3.14;  // Молча обрезает до 3
```
Почему: Потеря данных должна быть явной, а не скрытой

**4. Сборка мусора**
```c
// ПЛОХО: Это будет отклонено
void *gc_malloc(size_t size) {
    // Отслеживание выделений для автоматической очистки
}
```
Почему: Скрывает управление памятью, непредсказуемая производительность

**5. Сложная система макросов**
```hemlock
// ПЛОХО: Это будет отклонено
macro repeat($n, $block) {
    for (let i = 0; i < $n; i++) $block
}
```
Почему: Слишком много магии, затрудняет понимание кода

### Частые причины отклонения

**"Это слишком неявно"**
- Решение: Сделайте поведение явным и задокументируйте его

**"Это скрывает сложность"**
- Решение: Раскройте сложность, но сделайте её эргономичной

**"Это ломает существующий код"**
- Решение: Найдите неразрушающую альтернативу или обсудите версионирование

**"Это не соответствует философии Hemlock"**
- Решение: Перечитайте philosophy.md и пересмотрите подход

---

## Типичные паттерны

### Паттерн обработки ошибок

```c
// Используйте этот паттерн для восстанавливаемых ошибок в коде Hemlock
Value *divide(Value *a, Value *b)
{
    // Проверка предусловий
    if (b->type != TYPE_I32) {
        // Возврат значения ошибки или выброс исключения
        return create_error("Expected integer divisor");
    }

    if (b->i32_value == 0) {
        return create_error("Division by zero");
    }

    // Выполнение операции
    return value_create_i32(a->i32_value / b->i32_value);
}
```

### Паттерн управления памятью

```c
// Паттерн: Выделить, использовать, освободить
void process_data(void)
{
    // Выделение
    Buffer *buf = create_buffer(1024);
    char *str = malloc(256);

    // Использование
    if (buf && str) {
        // ... выполнение работы
    }

    // Освобождение (в обратном порядке выделения)
    free(str);
    free_buffer(buf);
}
```

### Паттерн создания значений

```c
// Создание значений с помощью конструкторов
Value *create_integer(int32_t n)
{
    Value *val = malloc(sizeof(Value));
    if (!val) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }

    val->type = TYPE_I32;
    val->i32_value = n;
    return val;
}
```

### Паттерн проверки типов

```c
// Проверка типов перед операциями
Value *add_values(Value *a, Value *b)
{
    // Проверка типов
    if (a->type != TYPE_I32 || b->type != TYPE_I32) {
        return create_error("Type mismatch");
    }

    // Безопасно продолжить
    return value_create_i32(a->i32_value + b->i32_value);
}
```

### Паттерн построения строк

```c
// Эффективное построение строк
void build_error_message(char *buffer, size_t size, const char *detail)
{
    snprintf(buffer, size, "Error: %s (line %d)", detail, line_number);
}
```

---

## Добавление новых функций

### Чеклист добавления функции

При добавлении новой функции следуйте этим шагам:

#### 1. Фаза проектирования

- [ ] Прочитайте philosophy.md для обеспечения соответствия
- [ ] Создайте GitHub issue с описанием функции
- [ ] Получите одобрение мейнтейнеров на дизайн
- [ ] Напишите спецификацию (синтаксис, семантика, примеры)
- [ ] Рассмотрите граничные случаи и условия ошибок

#### 2. Фаза реализации

**При добавлении языковой конструкции:**

- [ ] Добавьте тип токена в `lexer.h` (если нужно)
- [ ] Добавьте правило лексера в `lexer.c` (если нужно)
- [ ] Добавьте тип узла AST в `ast.h`
- [ ] Добавьте конструктор AST в `ast.c`
- [ ] Добавьте правило парсера в `parser.c`
- [ ] Добавьте поведение во время выполнения в `runtime.c` или соответствующий модуль
- [ ] Обработайте очистку в функциях освобождения AST

**При добавлении встроенной функции:**

- [ ] Добавьте реализацию функции в `builtins.c`
- [ ] Зарегистрируйте функцию в `register_builtins()`
- [ ] Обработайте все комбинации типов параметров
- [ ] Возвращайте соответствующие значения ошибок
- [ ] Задокументируйте параметры и тип возврата

**При добавлении типа значения:**

- [ ] Добавьте перечисление типа в `values.h`
- [ ] Добавьте поле в объединение Value
- [ ] Добавьте конструктор в `values.c`
- [ ] Добавьте в `value_free()` для очистки
- [ ] Добавьте в `value_copy()` для копирования
- [ ] Добавьте в `value_to_string()` для вывода
- [ ] Добавьте правила продвижения типов, если числовой

#### 3. Фаза тестирования

- [ ] Напишите тестовые случаи (см. testing.md)
- [ ] Протестируйте успешные случаи
- [ ] Протестируйте случаи ошибок
- [ ] Протестируйте граничные случаи
- [ ] Запустите полный набор тестов (`make test`)
- [ ] Проверьте на утечки памяти с помощью valgrind
- [ ] Протестируйте на нескольких платформах (если возможно)

#### 4. Фаза документации

- [ ] Обновите CLAUDE.md с пользовательской документацией
- [ ] Добавьте комментарии к коду, объясняющие реализацию
- [ ] Создайте примеры в `examples/`
- [ ] Обновите соответствующие файлы docs/
- [ ] Задокументируйте любые несовместимые изменения

#### 5. Фаза отправки

- [ ] Очистите отладочный код и комментарии
- [ ] Проверьте соответствие стилю кода
- [ ] Сделайте rebase на последний main
- [ ] Создайте pull request с подробным описанием
- [ ] Отвечайте на замечания код-ревью

### Пример: Добавление нового оператора

Рассмотрим добавление оператора остатка от деления `%` в качестве примера:

**1. Лексер (lexer.c):**
```c
// Добавьте в оператор switch в get_next_token()
case '%':
    return create_token(TOKEN_PERCENT, "%", line);
```

**2. Заголовок лексера (lexer.h):**
```c
typedef enum {
    // ... существующие токены
    TOKEN_PERCENT,
    // ...
} TokenType;
```

**3. AST (ast.h):**
```c
typedef enum {
    // ... существующие операторы
    OP_MOD,
    // ...
} BinaryOp;
```

**4. Парсер (parser.c):**
```c
// Добавьте в parse_multiplicative() или соответствующий уровень приоритета
if (match(TOKEN_PERCENT)) {
    BinaryOp op = OP_MOD;
    ASTNode *right = parse_unary();
    left = create_binary_op_node(op, left, right);
}
```

**5. Среда выполнения (runtime.c):**
```c
// Добавьте в eval_binary_op()
case OP_MOD:
    // Проверка типов
    if (left->type == TYPE_I32 && right->type == TYPE_I32) {
        if (right->i32_value == 0) {
            fprintf(stderr, "Error: Modulo by zero\n");
            exit(1);
        }
        return value_create_i32(left->i32_value % right->i32_value);
    }
    // ... обработка других комбинаций типов
    break;
```

**6. Тесты (tests/operators/modulo.hml):**
```hemlock
// Базовый остаток от деления
print(10 % 3);  // Ожидается: 2

// Отрицательный остаток от деления
print(-10 % 3); // Ожидается: -1

// Случай ошибки (должен завершиться с ошибкой)
// print(10 % 0);  // Деление на ноль
```

**7. Документация (CLAUDE.md):**
```markdown
### Арифметические операторы
- `+` - Сложение
- `-` - Вычитание
- `*` - Умножение
- `/` - Деление
- `%` - Остаток от деления
```

---

## Процесс код-ревью

### На что обращают внимание ревьюеры

**1. Корректность**
- Делает ли код то, что заявлено?
- Обрабатываются ли граничные случаи?
- Есть ли утечки памяти?
- Правильно ли обрабатываются ошибки?

**2. Соответствие философии**
- Соответствует ли это принципам проектирования Hemlock?
- Является ли это явным или неявным?
- Скрывает ли это сложность?

**3. Качество кода**
- Читаем ли код и легко ли его поддерживать?
- Описательны ли имена переменных?
- Разумного ли размера функции?
- Достаточно ли документации?

**4. Тестирование**
- Достаточно ли тестовых случаев?
- Покрывают ли тесты пути успеха и неудачи?
- Протестированы ли граничные случаи?

**5. Документация**
- Обновлена ли пользовательская документация?
- Понятны ли комментарии к коду?
- Предоставлены ли примеры?

### Реагирование на обратную связь

**Делайте:**
- Благодарите ревьюеров за их время
- Задавайте уточняющие вопросы, если что-то непонятно
- Объясняйте свои рассуждения, если не согласны
- Оперативно вносите запрошенные изменения
- Обновляйте описание PR, если область изменилась

**Не делайте:**
- Не принимайте критику лично
- Не защищайтесь агрессивно
- Не игнорируйте обратную связь
- Не делайте force-push поверх комментариев ревью (кроме случаев rebase)
- Не добавляйте несвязанные изменения в PR

### Получение одобрения на слияние PR

**Требования для слияния:**
- [ ] Все тесты проходят
- [ ] Нет утечек памяти (valgrind чистый)
- [ ] Одобрение код-ревью от мейнтейнера
- [ ] Документация обновлена
- [ ] Соответствует рекомендациям по стилю кода
- [ ] Соответствует философии Hemlock

**Сроки:**
- Небольшие PR (исправления ошибок): Обычно ревью в течение нескольких дней
- Средние PR (новые функции): Может занять 1-2 недели
- Большие PR (крупные изменения): Требуют обширного обсуждения

---

## Дополнительные ресурсы

### Учебные ресурсы

**Понимание интерпретаторов:**
- "Crafting Interpreters" Роберта Нистрома
- "Writing An Interpreter In Go" Торстена Балла
- "Modern Compiler Implementation in C" Эндрю Аппеля

**Программирование на C:**
- "The C Programming Language" Кернигана и Ритчи
- "Expert C Programming" Питера ван дер Линдена
- "C Interfaces and Implementations" Дэвида Хэнсона

**Управление памятью:**
- Документация Valgrind
- "Understanding and Using C Pointers" Ричарда Риза

### Полезные команды

```bash
# Сборка с отладочными символами
make clean && make CFLAGS="-g -O0"

# Запуск с valgrind
valgrind --leak-check=full ./hemlock script.hml

# Запуск конкретной категории тестов
./tests/run_tests.sh tests/strings/

# Генерация файла tags для навигации по коду
ctags -R .

# Поиск всех TODO и FIXME
grep -rn "TODO\|FIXME" src/ include/
```

---

## Вопросы?

Если у вас есть вопросы об участии:

1. Проверьте документацию в `docs/`
2. Поищите в существующих GitHub issues
3. Спросите в GitHub Discussions
4. Откройте новый issue с вашим вопросом

**Благодарим вас за участие в развитии Hemlock!**
