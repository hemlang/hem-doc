# Руны

Руны представляют **кодовые точки Unicode** (U+0000 до U+10FFFF) как отдельный тип для манипуляции символами в Hemlock. В отличие от байтов (u8), руны являются полными Unicode-символами, которые могут представлять любой символ любого языка или эмодзи.

## Обзор

```hemlock
let ch = 'A';           // Литерал руны
let emoji = '(ракета)'; // Многобайтовый символ как одна руна
print(ch);              // 'A'
print(emoji);           // U+1F680

let s = "Hello " + '!'; // Конкатенация строки + руны
let r = '>' + " msg";   // Конкатенация руны + строки
```

## Что такое руна?

Руна - это **32-битное значение**, представляющее кодовую точку Unicode:

- **Диапазон:** 0 до 0x10FFFF (1,114,111 допустимых кодовых точек)
- **Не числовой тип** - Используется для представления символов
- **Отличается от u8/char** - Руны это полный Unicode, u8 просто байты
- **Возвращается индексацией строк** - `str[0]` возвращает руну, не байт

**Зачем руны?**
- Строки Hemlock кодируются в UTF-8
- Один символ Unicode может быть 1-4 байта в UTF-8
- Руны позволяют работать с полными символами, не частичными байтами

## Литералы рун

### Базовый синтаксис

Одинарные кавычки обозначают литералы рун:

```hemlock
let a = 'A';            // ASCII символ
let b = '0';            // Символ цифры
let c = '!';            // Пунктуация
let d = ' ';            // Пробел
```

### Многобайтовые UTF-8 символы

Руны могут представлять любой символ Unicode:

```hemlock
// Эмодзи
let rocket = '(ракета)';// Эмодзи (U+1F680)
let heart = '(сердце)'; // Сердце (U+2764)
let smile = '(улыбка)'; // Улыбающееся лицо (U+1F600)

// CJK символы
let chinese = '(кит)';  // Китайский (U+4E2D)
let japanese = '(яп)';  // Хирагана (U+3042)
let korean = '(кор)';   // Хангыль (U+D55C)

// Символы
let check = '(галочка)';// Галочка (U+2713)
let arrow = '(стрелка)';// Стрелка вправо (U+2192)
```

### Escape-последовательности

Распространенные escape-последовательности для специальных символов:

```hemlock
let newline = '\n';     // Новая строка (U+000A)
let tab = '\t';         // Табуляция (U+0009)
let backslash = '\\';   // Обратный слеш (U+005C)
let quote = '\'';       // Одинарная кавычка (U+0027)
let dquote = '"';       // Двойная кавычка (U+0022)
let null_char = '\0';   // Нулевой символ (U+0000)
let cr = '\r';          // Возврат каретки (U+000D)
```

**Доступные escape-последовательности:**
- `\n` - Новая строка (перевод строки)
- `\t` - Горизонтальная табуляция
- `\r` - Возврат каретки
- `\0` - Нулевой символ
- `\\` - Обратный слеш
- `\'` - Одинарная кавычка
- `\"` - Двойная кавычка

### Unicode escape-последовательности

Используйте синтаксис `\u{XXXXXX}` для кодовых точек Unicode (до 6 hex цифр):

```hemlock
let rocket = '\u{1F680}';   // (ракета) Эмодзи через Unicode escape
let heart = '\u{2764}';     // (сердце) Сердце
let ascii = '\u{41}';       // 'A' через escape
let max = '\u{10FFFF}';     // Максимальная кодовая точка Unicode

// Ведущие нули необязательны
let a = '\u{41}';           // То же что '\u{0041}'
let b = '\u{0041}';
```

**Правила:**
- Диапазон: `\u{0}` до `\u{10FFFF}`
- Hex цифры: от 1 до 6 цифр
- Регистр не важен: `\u{1F680}` или `\u{1f680}`
- Значения вне допустимого диапазона Unicode вызывают ошибку

## Конкатенация строк + рун

Руны можно конкатенировать со строками:

```hemlock
// Строка + руна
let greeting = "Hello" + '!';       // "Hello!"
let decorated = "Text" + '(галочка)'; // "Text(галочка)"

// Руна + строка
let prefix = '>' + " Message";      // "> Message"
let bullet = '(точка)' + " Item";   // "(точка) Item"

// Множественные конкатенации
let msg = "Hi " + '(рука)' + " World " + '(земля)';  // "Hi (рука) World (земля)"

// Цепочки методов работают
let result = ('>' + " Important").to_upper();  // "> IMPORTANT"
```

**Как это работает:**
- Руны автоматически кодируются в UTF-8
- Преобразуются в строки во время конкатенации
- Оператор конкатенации строк обрабатывает это прозрачно

## Преобразования типов

Руны могут преобразовываться в/из других типов.

### Целое <-> Руна

Преобразование между целыми и рунами для работы со значениями кодовых точек:

```hemlock
// Целое в руну (значение кодовой точки)
let code: rune = 65;            // 'A' (ASCII 65)
let emoji_code: rune = 128640;  // U+1F680 ((ракета))

// Руна в целое (получить значение кодовой точки)
let r = 'Z';
let value: i32 = r;             // 90 (ASCII значение)

let rocket = '(ракета)';
let code: i32 = rocket;         // 128640 (U+1F680)
```

**Проверка диапазона:**
- Целое в руну: Должно быть в [0, 0x10FFFF]
- Значения вне диапазона вызывают ошибку времени выполнения
- Руна в целое: Всегда успешно (возвращает кодовую точку)

### Руна -> Строка

Руны можно явно преобразовывать в строки:

```hemlock
// Явное преобразование
let ch: string = 'H';           // "H"
let emoji: string = '(ракета)'; // "(ракета)"

// Автоматически при конкатенации
let s = "" + 'A';               // "A"
let s2 = "x" + 'y' + "z";       // "xyz"
```

### u8 (Байт) -> Руна

Любое значение u8 (0-255) может преобразовываться в руну:

```hemlock
// Диапазон ASCII (0-127)
let byte: u8 = 65;
let rune_val: rune = byte;      // 'A'

// Расширенный ASCII / Latin-1 (128-255)
let extended: u8 = 200;
let r: rune = extended;         // U+00C8 (E с грависом)

// Примечание: Значения 0-127 это ASCII, 128-255 это Latin-1
```

### Цепочки преобразований

Преобразования типов можно объединять в цепочки:

```hemlock
// i32 -> руна -> строка
let code: i32 = 128512;         // Кодовая точка улыбающегося лица
let r: rune = code;             // (улыбка)
let s: string = r;              // "(улыбка)"

// Все в одном выражении
let emoji: string = 128640;     // Неявное i32 -> руна -> строка ((ракета))
```

## Операции с рунами

### Вывод

Как отображаются руны зависит от кодовой точки:

```hemlock
let ascii = 'A';
print(ascii);                   // 'A' (в кавычках, печатный ASCII)

let emoji = '(ракета)';
print(emoji);                   // U+1F680 (Unicode нотация для не-ASCII)

let tab = '\t';
print(tab);                     // U+0009 (непечатный как hex)

let space = ' ';
print(space);                   // ' ' (печатный)
```

**Формат вывода:**
- Печатный ASCII (32-126): Символ в кавычках `'A'`
- Непечатный или Unicode: Hex нотация `U+XXXX`

### Проверка типа

Используйте `typeof()` для проверки является ли значение руной:

```hemlock
let r = '(ракета)';
print(typeof(r));               // "rune"

let s = "text";
let ch = s[0];
print(typeof(ch));              // "rune" (индексация возвращает руны)

let num = 65;
print(typeof(num));             // "i32"
```

### Сравнение

Руны можно сравнивать на равенство:

```hemlock
let a = 'A';
let b = 'B';
print(a == a);                  // true
print(a == b);                  // false

// Чувствительно к регистру
let upper = 'A';
let lower = 'a';
print(upper == lower);          // false

// Руны можно сравнивать с целыми (значения кодовых точек)
print(a == 65);                 // true (неявное преобразование)
print('(ракета)' == 128640);    // true
```

**Операторы сравнения:**
- `==` - Равно
- `!=` - Не равно
- `<`, `>`, `<=`, `>=` - Порядок кодовых точек

```hemlock
print('A' < 'B');               // true (65 < 66)
print('a' > 'Z');               // true (97 > 90)
```

## Работа с индексацией строк

Индексация строк возвращает руны, не байты:

```hemlock
let s = "Hello(ракета)";
let h = s[0];                   // 'H' (руна)
let rocket = s[5];              // '(ракета)' (руна)

print(typeof(h));               // "rune"
print(typeof(rocket));          // "rune"

// Преобразовать в строку если нужно
let h_str: string = h;          // "H"
let rocket_str: string = rocket; // "(ракета)"
```

**Важно:** Индексация строк использует позиции кодовых точек, не байтовые смещения:

```hemlock
let text = "Hi(ракета)!";
// Позиции кодовых точек: 0='H', 1='i', 2='(ракета)', 3='!'
// Позиции байт:          0='H', 1='i', 2-5='(ракета)', 6='!'

let r = text[2];                // '(ракета)' (кодовая точка 2)
print(typeof(r));               // "rune"
```

## Примеры

### Пример: Классификация символов

```hemlock
fn is_digit(r: rune): bool {
    return r >= '0' && r <= '9';
}

fn is_upper(r: rune): bool {
    return r >= 'A' && r <= 'Z';
}

fn is_lower(r: rune): bool {
    return r >= 'a' && r <= 'z';
}

print(is_digit('5'));           // true
print(is_upper('A'));           // true
print(is_lower('z'));           // true
```

### Пример: Преобразование регистра

```hemlock
fn to_upper_rune(r: rune): rune {
    if (r >= 'a' && r <= 'z') {
        // Преобразовать в верхний регистр (вычесть 32)
        let code: i32 = r;
        code = code - 32;
        return code;
    }
    return r;
}

fn to_lower_rune(r: rune): rune {
    if (r >= 'A' && r <= 'Z') {
        // Преобразовать в нижний регистр (добавить 32)
        let code: i32 = r;
        code = code + 32;
        return code;
    }
    return r;
}

print(to_upper_rune('a'));      // 'A'
print(to_lower_rune('Z'));      // 'z'
```

### Пример: Итерация по символам

```hemlock
fn print_chars(s: string) {
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        print("Position " + typeof(i) + ": " + typeof(ch));
        i = i + 1;
    }
}

print_chars("Hi(ракета)");
// Position 0: 'H'
// Position 1: 'i'
// Position 2: U+1F680
```

### Пример: Построение строк из рун

```hemlock
fn repeat_char(ch: rune, count: i32): string {
    let result = "";
    let i = 0;
    while (i < count) {
        result = result + ch;
        i = i + 1;
    }
    return result;
}

let line = repeat_char('=', 40);     // "========================================"
let stars = repeat_char('(звезда)', 5); // "(звезда)(звезда)(звезда)(звезда)(звезда)"
```

## Распространенные паттерны

### Паттерн: Фильтр символов

```hemlock
fn filter_digits(s: string): string {
    let result = "";
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        if (ch >= '0' && ch <= '9') {
            result = result + ch;
        }
        i = i + 1;
    }
    return result;
}

let text = "abc123def456";
let digits = filter_digits(text);  // "123456"
```

### Паттерн: Подсчет символов

```hemlock
fn count_char(s: string, target: rune): i32 {
    let count = 0;
    let i = 0;
    while (i < s.length) {
        if (s[i] == target) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

let text = "hello world";
let l_count = count_char(text, 'l');  // 3
let o_count = count_char(text, 'o');  // 2
```

## Лучшие практики

1. **Используйте руны для операций с символами** - Не пытайтесь работать с байтами для текста
2. **Индексация строк возвращает руны** - Помните что `str[i]` дает вам руну
3. **Unicode-aware сравнения** - Руны обрабатывают любой символ Unicode
4. **Преобразуйте когда нужно** - Руны легко преобразуются в строки и целые
5. **Тестируйте с эмодзи** - Всегда тестируйте операции с символами с многобайтовыми символами

## Распространенные ловушки

### Ловушка: Путаница руна vs байт

```hemlock
// НЕЛЬЗЯ: Обращаться с рунами как с байтами
let r: rune = '(ракета)';
let b: u8 = r;              // ОШИБКА: Кодовая точка руны 128640 не помещается в u8

// НУЖНО: Использовать соответствующие преобразования
let r: rune = '(ракета)';
let code: i32 = r;          // OK: 128640
```

### Ловушка: Байтовая индексация строк

```hemlock
// НЕЛЬЗЯ: Предполагать байтовую индексацию
let s = "(ракета)";
let byte = s.byte_at(0);    // 240 (первый байт UTF-8, не полный символ)

// НУЖНО: Использовать индексацию по кодовым точкам
let s = "(ракета)";
let rune = s[0];            // '(ракета)' (полный символ)
let rune2 = s.char_at(0);   // '(ракета)' (явный метод)
```

## Связанные темы

- [Строки](strings.md) - Операции со строками и обработка UTF-8
- [Типы](types.md) - Система типов и преобразования
- [Управление потоком](control-flow.md) - Использование рун в сравнениях

## См. также

- **Стандарт Unicode**: Кодовые точки Unicode определяются Консорциумом Unicode
- **Кодировка UTF-8**: См. [Строки](strings.md) для деталей UTF-8
- **Преобразования типов**: См. [Типы](types.md) для правил преобразования
