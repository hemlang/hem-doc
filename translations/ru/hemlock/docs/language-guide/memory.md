# Управление памятью

Hemlock принимает **ручное управление памятью** с явным контролем над выделением и освобождением. Это руководство охватывает модель памяти Hemlock, два типа указателей и полный API памяти.

---

## Память 101: Основы

**Новичок в программировании?** Начните здесь. Если вы уже понимаете управление памятью, перейдите к разделу [Философия](#философия).

### Что такое управление памятью?

Когда вашей программе нужно хранить данные (текст, числа, списки), ей нужно место для этого. Это место берется из памяти вашего компьютера (RAM). Управление памятью это:

1. **Получение места** - запрос памяти когда она нужна
2. **Использование места** - чтение и запись ваших данных
3. **Возврат** - возврат памяти когда вы закончили

### Почему это важно?

Представьте библиотеку с ограниченным количеством книг:
- Если вы продолжаете брать книги и никогда не возвращаете их, в конце концов их не останется
- Если вы пытаетесь читать книгу, которую уже вернули, вы запутаетесь или вызовете проблемы

Память работает так же. Если вы забываете возвращать память, ваша программа медленно использует все больше и больше ("утечка памяти"). Если вы пытаетесь использовать память после возврата, происходят плохие вещи.

### Хорошие новости

**В большинстве случаев вам не нужно об этом думать!**

Hemlock автоматически очищает большинство распространенных типов:

```hemlock
fn example() {
    let name = "Alice";       // Hemlock управляет этим
    let numbers = [1, 2, 3];  // И этим
    let person = { age: 30 }; // И этим тоже

    // Когда функция завершается, все это автоматически очищается!
}
```

### Когда НУЖНО думать об этом

Вам нужно ручное управление памятью только при использовании:

1. **`alloc()`** - сырое выделение памяти (возвращает `ptr`)
2. **`buffer()`** - когда хотите освободить раньше (опционально - авто-освобождается при выходе из области)

```hemlock
// Это требует ручной очистки:
let raw = alloc(100);   // Сырая память - ВЫ должны освободить её
// ... использование raw ...
free(raw);              // Обязательно! Иначе утечка памяти

// Это очищается автоматически (но МОЖНО освободить раньше):
let buf = buffer(100);  // Безопасный буфер
// ... использование buf ...
// free(buf);           // Опционально - авто-освобождается при выходе из области
```

### Простое правило

> **Если вы вызвали `alloc()`, вы должны вызвать `free()`.**
>
> Все остальное обрабатывается за вас.

### Что использовать?

| Ситуация | Используйте это | Почему |
|----------|-----------------|--------|
| **Только начинаете** | `buffer()` | Безопасный, с проверкой границ, авто-очистка |
| **Нужно хранить байты** | `buffer()` | Безопасно и просто |
| **Работа с C библиотеками (FFI)** | `alloc()` / `ptr` | Требуется для C interop |
| **Максимальная производительность** | `alloc()` / `ptr` | Нет накладных расходов на проверку границ |
| **Не уверены** | `buffer()` | Всегда безопаснее |

### Быстрый пример: Безопасный vs Сырой

```hemlock
// РЕКОМЕНДУЕТСЯ: Безопасный буфер
fn safe_example() {
    let data = buffer(10);
    data[0] = 65;           // OK
    data[5] = 66;           // OK
    // data[100] = 67;      // ОШИБКА - Hemlock останавливает вас (проверка границ)
    free(data);             // Очистка
}

// ПРОДВИНУТО: Сырой указатель (только когда нужен)
fn raw_example() {
    let data = alloc(10);
    *data = 65;             // OK
    *(data + 5) = 66;       // OK
    *(data + 100) = 67;     // ОПАСНОСТЬ - Нет проверки границ, повреждение памяти!
    free(data);             // Очистка
}
```

**Начинайте с `buffer()`. Используйте `alloc()` только когда конкретно нужны сырые указатели.**

---

## Философия

Hemlock следует принципу явного управления памятью с разумными значениями по умолчанию:
- Нет сборки мусора (нет непредсказуемых пауз)
- Внутренний подсчет ссылок для распространенных типов (string, array, object, buffer)
- Сырые указатели (`ptr`) требуют ручного `free()`

Этот гибридный подход дает вам полный контроль когда нужно (сырые указатели) при предотвращении распространенных ошибок для типичных случаев использования (refcounted типы авто-освобождаются при выходе из области).

## Внутренний подсчет ссылок

Среда выполнения использует **внутренний подсчет ссылок** для управления временем жизни объектов. Для большинства локальных переменных refcounted типов очистка автоматическая и детерминированная.

### Что обрабатывает подсчет ссылок

Среда выполнения автоматически управляет счетчиками ссылок когда:

1. **Переменные переназначаются** - старое значение освобождается:
   ```hemlock
   let x = "first";   // ref_count = 1
   x = "second";      // "first" освобождается внутренне, "second" ref_count = 1
   ```

2. **Области заканчиваются** - локальные переменные освобождаются:
   ```hemlock
   fn example() {
       let arr = [1, 2, 3];  // ref_count = 1
   }  // arr освобождается при возврате функции
   ```

3. **Контейнеры освобождаются** - элементы освобождаются:
   ```hemlock
   let arr = [obj1, obj2];
   free(arr);  // ref_count obj1 и obj2 уменьшаются
   ```

### Когда нужен `free()` vs когда автоматически

**Автоматически (не нужен `free()`):** Локальные переменные refcounted типов освобождаются при выходе из области:

```hemlock
fn process_data() {
    let arr = [1, 2, 3];
    let obj = { name: "test" };
    let buf = buffer(64);
    // ... используем их ...
}  // Все автоматически освобождается при возврате функции - free() не нужен
```

**Ручной `free()` требуется:**

1. **Сырые указатели** - `alloc()` не имеет подсчета ссылок:
   ```hemlock
   let p = alloc(64);
   // ... использование p ...
   free(p);  // Всегда требуется - иначе утечка
   ```

2. **Ранняя очистка** - освобождение до конца области для более раннего освобождения памяти:
   ```hemlock
   fn long_running() {
       let big = buffer(10000000);  // 10MB
       // ... закончили с big ...
       free(big);  // Освободить сейчас, не ждать возврата функции
       // ... ещё работа, которой не нужен big ...
   }
   ```

3. **Долгоживущие данные** - глобальные или данные в постоянных структурах:
   ```hemlock
   let cache = {};  // На уровне модуля, живет до конца программы пока не освободить

   fn cleanup() {
       free(cache);  // Ручная очистка для долгоживущих данных
   }
   ```

### Подсчет ссылок vs Сборка мусора

| Аспект | Подсчет ссылок Hemlock | Сборка мусора |
|--------|------------------------|---------------|
| Время очистки | Детерминированное (немедленно при ref = 0) | Недетерминированное (GC решает когда) |
| Ответственность пользователя | Нужно вызывать `free()` | Полностью автоматически |
| Паузы среды выполнения | Нет | "Stop the world" паузы |
| Видимость | Скрытая деталь реализации | Обычно невидима |
| Циклы | Обрабатываются с отслеживанием visited-set | Обрабатываются трассировкой |

### Какие типы имеют подсчет ссылок

| Тип | Refcounted | Примечания |
|-----|------------|------------|
| `ptr` | Нет | Всегда требует ручного `free()` |
| `buffer` | Да | Авто-освобождается при выходе из области; ручной `free()` для ранней очистки |
| `array` | Да | Авто-освобождается при выходе из области; ручной `free()` для ранней очистки |
| `object` | Да | Авто-освобождается при выходе из области; ручной `free()` для ранней очистки |
| `string` | Да | Полностью автоматически, `free()` не нужен |
| `function` | Да | Полностью автоматически (окружения замыканий) |
| `task` | Да | Потокобезопасный атомарный подсчет ссылок |
| `channel` | Да | Потокобезопасный атомарный подсчет ссылок |
| Примитивы | Нет | Размещаются на стеке, нет выделения в куче |

### Почему такой дизайн?

Этот гибридный подход дает вам:
- **Явный контроль** - Вы решаете когда освобождать
- **Безопасность от ошибок области** - Переназначение не утекает
- **Предсказуемая производительность** - Нет пауз GC
- **Поддержка замыканий** - Функции могут безопасно захватывать переменные

Философия остается: вы контролируете, но среда выполнения помогает предотвращать распространенные ошибки типа утечек при переназначении или двойного освобождения в контейнерах.

## Два типа указателей

Hemlock предоставляет два различных типа указателей, каждый с разными характеристиками безопасности:

### `ptr` - Сырой указатель (опасный)

Сырые указатели - это **просто адреса** с минимальными гарантиями безопасности:

```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // Вы должны помнить освободить
```

**Характеристики:**
- Просто 8-байтовый адрес
- Нет проверки границ
- Нет отслеживания длины
- Пользователь полностью управляет временем жизни
- Для экспертов и FFI

**Случаи использования:**
- Низкоуровневое системное программирование
- Интерфейс внешних функций (FFI)
- Критичный к производительности код
- Когда нужен полный контроль

**Опасности:**
```hemlock
let p = alloc(10);
let q = p + 100;  // Далеко за пределами выделения - разрешено но опасно
free(p);
let x = *p;       // Висячий указатель - неопределенное поведение
free(p);          // Двойное освобождение - упадет
```

### `buffer` - Безопасная обертка (рекомендуется)

Буферы предоставляют **доступ с проверкой границ** при все еще требуемом ручном освобождении:

```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // проверка границ
print(b.length);        // 64
free(b);                // все еще ручной
```

**Характеристики:**
- Указатель + длина + емкость
- Проверка границ при доступе
- Все еще требует ручного `free()`
- Лучший вариант по умолчанию для большинства кода

**Свойства:**
```hemlock
let buf = buffer(100);
print(buf.length);      // 100 (текущий размер)
print(buf.capacity);    // 100 (выделенная емкость)
```

**Проверка границ:**
```hemlock
let buf = buffer(10);
buf[5] = 42;      // OK
buf[100] = 42;    // ОШИБКА: Index out of bounds
```

## API памяти

### Базовое выделение

**`alloc(bytes)` - Выделить сырую память**
```hemlock
let p = alloc(1024);  // Выделить 1KB, возвращает ptr
// ... использование памяти
free(p);
```

**`buffer(size)` - Выделить безопасный буфер**
```hemlock
let buf = buffer(256);  // Выделить 256-байтный буфер
buf[0] = 65;            // 'A'
buf[1] = 66;            // 'B'
free(buf);
```

**`free(ptr)` - Освободить память**
```hemlock
let p = alloc(100);
free(p);  // Нужно освободить чтобы избежать утечки памяти

let buf = buffer(100);
free(buf);  // Работает и на ptr и на buffer
```

**Важно:** `free()` работает и на `ptr` и на `buffer` типах.

### Операции с памятью

**`memset(ptr, byte, size)` - Заполнить память**
```hemlock
let p = alloc(100);
memset(p, 0, 100);     // Обнулить 100 байт
memset(p, 65, 10);     // Заполнить первые 10 байт 'A'
free(p);
```

**`memcpy(dest, src, size)` - Копировать память**
```hemlock
let src = alloc(50);
let dst = alloc(50);
memset(src, 42, 50);
memcpy(dst, src, 50);  // Копировать 50 байт из src в dst
free(src);
free(dst);
```

**`realloc(ptr, size)` - Изменить размер выделения**
```hemlock
let p = alloc(100);
// ... использование 100 байт
p = realloc(p, 200);   // Изменить размер до 200 байт
// ... использование 200 байт
free(p);
```

**Примечание:** После `realloc()` старый указатель может быть недействительным. Всегда используйте возвращенный указатель.

### Типизированное выделение

Hemlock предоставляет помощники типизированного выделения для удобства:

```hemlock
let arr = talloc(i32, 100);  // Выделить 100 значений i32 (400 байт)
let size = sizeof(i32);      // Возвращает 4 (байта)
```

**`sizeof(type)`** возвращает размер в байтах типа:
- `sizeof(i8)` / `sizeof(u8)` -> 1
- `sizeof(i16)` / `sizeof(u16)` -> 2
- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` -> 4
- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` -> 8
- `sizeof(ptr)` -> 8 (на 64-битных системах)

**`talloc(type, count)`** выделяет `count` элементов типа `type`:

```hemlock
let ints = talloc(i32, 10);   // 40 байт для 10 значений i32
let floats = talloc(f64, 5);  // 40 байт для 5 значений f64
free(ints);
free(floats);
```

## Распространенные паттерны

### Паттерн: Выделить, использовать, освободить

Базовый паттерн управления памятью:

```hemlock
// 1. Выделить
let data = alloc(1024);

// 2. Использовать
memset(data, 0, 1024);
// ... выполнение работы

// 3. Освободить
free(data);
```

### Паттерн: Использование безопасного буфера

Предпочитайте буферы для доступа с проверкой границ:

```hemlock
let buf = buffer(256);

// Безопасная итерация
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

free(buf);
```

### Паттерн: Управление ресурсами с try/finally

Обеспечение очистки даже при ошибках:

```hemlock
let data = alloc(1024);
try {
    // ... рискованные операции
    process(data);
} finally {
    free(data);  // Всегда освобождается, даже при ошибке
}
```

## Соображения безопасности памяти

### Двойное освобождение

**Разрешено но упадет:**
```hemlock
let p = alloc(100);
free(p);
free(p);  // ПАДЕНИЕ: Double-free detected
```

**Предотвращение:**
```hemlock
let p = alloc(100);
free(p);
p = null;  // Установить в null после освобождения

if (p != null) {
    free(p);  // Не выполнится
}
```

### Висячие указатели

**Разрешено но неопределенное поведение:**
```hemlock
let p = alloc(100);
*p = 42;      // OK
free(p);
let x = *p;   // НЕОПРЕДЕЛЕНО: Чтение освобожденной памяти
```

**Предотвращение:** Не обращайтесь к памяти после освобождения.

### Утечки памяти

**Легко создать, трудно отладить:**
```hemlock
fn leak_memory() {
    let p = alloc(1000);
    // Забыли освободить!
    return;  // Утечка памяти
}
```

**Предотвращение:** Всегда сопоставляйте `alloc()` с `free()`:
```hemlock
fn safe_function() {
    let p = alloc(1000);
    try {
        // ... использование p
    } finally {
        free(p);  // Всегда освобождается
    }
}
```

### Арифметика указателей

**Разрешена но опасна:**
```hemlock
let p = alloc(10);
let q = p + 100;  // Далеко за границей выделения
*q = 42;          // НЕОПРЕДЕЛЕНО: Запись за границы
free(p);
```

**Используйте буферы для проверки границ:**
```hemlock
let buf = buffer(10);
buf[100] = 42;  // ОШИБКА: Проверка границ предотвращает переполнение
```

## Лучшие практики

1. **По умолчанию `buffer`** - Используйте `buffer` если конкретно не нужен сырой `ptr`
2. **Сопоставляйте alloc/free** - Каждый `alloc()` должен иметь ровно один `free()`
3. **Используйте try/finally** - Обеспечивайте очистку с обработкой исключений
4. **Null после free** - Устанавливайте указатели в `null` после освобождения чтобы ловить use-after-free
5. **Проверка границ** - Используйте индексирование буфера для автоматической проверки границ
6. **Документируйте владение** - Делайте ясным какой код владеет и освобождает каждое выделение

## Примеры

### Пример: Динамический строитель строк

```hemlock
fn build_message(count: i32): ptr {
    let size = count * 10;
    let buf = alloc(size);

    let i = 0;
    while (i < count) {
        memset(buf + (i * 10), 65 + i, 10);
        i = i + 1;
    }

    return buf;  // Вызывающий должен освободить
}

let msg = build_message(5);
// ... использование msg
free(msg);
```

### Пример: Безопасные операции с массивом

```hemlock
fn process_array(size: i32) {
    let arr = buffer(size);

    try {
        // Заполнение массива
        let i = 0;
        while (i < arr.length) {
            arr[i] = i * 2;
            i = i + 1;
        }

        // Обработка
        i = 0;
        while (i < arr.length) {
            print(arr[i]);
            i = i + 1;
        }
    } finally {
        free(arr);  // Всегда очищает
    }
}
```

### Пример: Паттерн пула памяти

```hemlock
// Простой пул памяти (упрощенный)
let pool = alloc(10000);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > 10000) {
        throw "Pool exhausted";
    }

    let ptr = pool + pool_offset;
    pool_offset = pool_offset + size;
    return ptr;
}

// Использование пула
let p1 = pool_alloc(100);
let p2 = pool_alloc(200);

// Освобождение всего пула сразу
free(pool);
```

## Ограничения

Текущие ограничения о которых нужно знать:

- **Сырые указатели требуют ручного free** - `alloc()` возвращает `ptr` без подсчета ссылок
- **Нет пользовательских аллокаторов** - Только системный malloc/free

**Примечание:** Refcounted типы (string, array, object, buffer) АВТОМАТИЧЕСКИ освобождаются при выходе из области. Только сырой `ptr` от `alloc()` требует явного `free()`.

## Связанные темы

- [Строки](strings.md) - Управление памятью строк и кодировка UTF-8
- [Массивы](arrays.md) - Динамические массивы и их характеристики памяти
- [Объекты](objects.md) - Размещение объектов и время жизни
- [Обработка ошибок](error-handling.md) - Использование try/finally для очистки

## См. также

- **Философия дизайна**: См. раздел "Управление памятью" в CLAUDE.md
- **Система типов**: См. [Типы](types.md) для деталей типов `ptr` и `buffer`
- **FFI**: Сырые указатели необходимы для интерфейса внешних функций
