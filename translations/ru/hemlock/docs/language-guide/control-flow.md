# Управление потоком

Hemlock предоставляет знакомое управление потоком в стиле C с обязательными фигурными скобками и явным синтаксисом. Это руководство охватывает условные операторы, циклы, операторы switch и операторы.

## Обзор

Доступные возможности управления потоком:

- `if`/`else`/`else if` - Условные ветвления
- Циклы `while` - Итерация на основе условия
- Циклы `for` - Итерация в стиле C и for-in
- `loop` - Бесконечные циклы (чище чем `while (true)`)
- Операторы `switch` - Многовариантное ветвление
- `break`/`continue` - Управление циклом
- Метки циклов - Целевые break/continue для вложенных циклов
- `defer` - Отложенное выполнение (очистка)
- Логические операторы: `&&`, `||`, `!`
- Операторы сравнения: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Побитовые операторы: `&`, `|`, `^`, `<<`, `>>`, `~`

## Операторы If

### Базовый If/Else

```hemlock
if (x > 10) {
    print("large");
} else {
    print("small");
}
```

**Правила:**
- Фигурные скобки **всегда обязательны** для всех веток
- Условия должны быть заключены в скобки
- Нет необязательных скобок (в отличие от C)

### If без Else

```hemlock
if (x > 0) {
    print("positive");
}
// Ветка else не нужна
```

### Цепочки Else-If

```hemlock
if (x > 100) {
    print("very large");
} else if (x > 50) {
    print("large");
} else if (x > 10) {
    print("medium");
} else {
    print("small");
}
```

**Примечание:** `else if` - это синтаксический сахар для вложенных операторов if. Это эквивалентно:

```hemlock
// else if (синтаксический сахар)
if (a) {
    foo();
} else if (b) {
    bar();
}

// Эквивалентный вложенный if
if (a) {
    foo();
} else {
    if (b) {
        bar();
    }
}
```

### Вложенные операторы If

```hemlock
if (x > 0) {
    if (x < 10) {
        print("single digit positive");
    } else {
        print("multi-digit positive");
    }
} else {
    print("non-positive");
}
```

## Циклы While

Итерация на основе условия:

```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

**Бесконечные циклы (старый стиль):**
```hemlock
while (true) {
    // ... выполнение работы
    if (should_exit) {
        break;
    }
}
```

**Примечание:** Для бесконечных циклов предпочтительнее ключевое слово `loop` (см. ниже).

## Loop (бесконечный цикл)

Ключевое слово `loop` предоставляет более чистый синтаксис для бесконечных циклов:

```hemlock
loop {
    // ... выполнение работы
    if (should_exit) {
        break;
    }
}
```

**Эквивалентно `while (true)`, но более явно выражает намерение.**

### Базовый Loop с Break

```hemlock
let i = 0;
loop {
    if (i >= 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// Выводит: 0, 1, 2, 3, 4
```

### Loop с Continue

```hemlock
let i = 0;
loop {
    i = i + 1;
    if (i > 5) {
        break;
    }
    if (i == 3) {
        continue;  // Пропускает вывод 3
    }
    print(i);
}
// Выводит: 1, 2, 4, 5
```

### Вложенные циклы

```hemlock
let x = 0;
loop {
    if (x >= 2) { break; }
    let y = 0;
    loop {
        if (y >= 3) { break; }
        print(x * 10 + y);
        y = y + 1;
    }
    x = x + 1;
}
// Выводит: 0, 1, 2, 10, 11, 12
```

### Когда использовать Loop

- **Используйте `loop`** для намеренно бесконечных циклов с выходом через `break`
- **Используйте `while`** когда есть естественное условие завершения
- **Используйте `for`** когда итерируете известное количество раз или по коллекции

## Циклы For

### For в стиле C

Классический трехчастный цикл for:

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**Компоненты:**
- **Инициализатор**: `let i = 0` - Выполняется один раз перед циклом
- **Условие**: `i < 10` - Проверяется перед каждой итерацией
- **Обновление**: `i = i + 1` - Выполняется после каждой итерации

**Область видимости:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
// i здесь недоступна (область цикла)
```

### Циклы For-In

Итерация по элементам массива:

```hemlock
let arr = [1, 2, 3, 4, 5];
for (let item in arr) {
    print(item);  // Выводит каждый элемент
}
```

**С индексом и значением:**
```hemlock
let arr = ["a", "b", "c"];
for (let i = 0; i < arr.length; i = i + 1) {
    print(`Index: ${i}, Value: ${arr[i]}`);
}
```

## Операторы Switch

Многовариантное ветвление на основе значения:

### Базовый Switch

```hemlock
let x = 2;

switch (x) {
    case 1:
        print("one");
        break;
    case 2:
        print("two");
        break;
    case 3:
        print("three");
        break;
}
```

### Switch с Default

```hemlock
let color = "blue";

switch (color) {
    case "red":
        print("stop");
        break;
    case "yellow":
        print("slow");
        break;
    case "green":
        print("go");
        break;
    default:
        print("unknown color");
        break;
}
```

**Правила:**
- `default` срабатывает когда ни один другой case не совпадает
- `default` может появляться в любом месте тела switch
- Только один default разрешен

### Поведение Fall-Through

Случаи без `break` проваливаются в следующий case (поведение в стиле C). Это **намеренно** и может использоваться для группировки случаев:

```hemlock
let grade = 85;

switch (grade) {
    case 100:
    case 95:
    case 90:
        print("A");
        break;
    case 85:
    case 80:
        print("B");
        break;
    default:
        print("C or below");
        break;
}
```

**Пример явного провала:**
```hemlock
let day = 3;

switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        print("Weekday");
        break;
    case 6:
    case 7:
        print("Weekend");
        break;
}
```

**Важно:** В отличие от некоторых современных языков, Hemlock НЕ требует явного ключевого слова `fallthrough`. Случаи автоматически проваливаются если не завершены `break`, `return` или `throw`. Всегда используйте `break` для предотвращения непреднамеренного провала.

### Switch с Return

В функциях `return` немедленно выходит из switch:

```hemlock
fn get_day_name(day: i32): string {
    switch (day) {
        case 1:
            return "Monday";
        case 2:
            return "Tuesday";
        case 3:
            return "Wednesday";
        default:
            return "Unknown";
    }
}
```

### Типы значений в Switch

Switch работает с любым типом значений:

```hemlock
// Целые
switch (count) {
    case 0: print("zero"); break;
    case 1: print("one"); break;
}

// Строки
switch (name) {
    case "Alice": print("A"); break;
    case "Bob": print("B"); break;
}

// Булевы
switch (flag) {
    case true: print("on"); break;
    case false: print("off"); break;
}
```

**Примечание:** Случаи сравниваются используя равенство значений.

## Break и Continue

### Break

Выход из ближайшего цикла или switch:

```hemlock
// В циклах
let i = 0;
while (true) {
    if (i >= 10) {
        break;  // Выход из цикла
    }
    print(i);
    i = i + 1;
}

// В switch
switch (x) {
    case 1:
        print("one");
        break;  // Выход из switch
    case 2:
        print("two");
        break;
}
```

### Continue

Переход к следующей итерации цикла:

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;  // Пропуск итерации когда i равно 5
    }
    print(i);  // Выводит 0,1,2,3,4,6,7,8,9
}
```

**Разница:**
- `break` - Полный выход из цикла
- `continue` - Переход к следующей итерации

## Метки циклов

Метки циклов позволяют `break` и `continue` нацеливаться на конкретные внешние циклы вместо только ближайшего цикла. Это полезно для вложенных циклов, когда нужно управлять внешним циклом из внутреннего.

### Break с меткой

Выход из внешнего цикла из внутреннего:

```hemlock
outer: while (i < 3) {
    let j = 0;
    while (j < 3) {
        if (i == 1 && j == 1) {
            break outer;  // Выход из внешнего цикла while
        }
        print(i * 10 + j);
        j = j + 1;
    }
    i = i + 1;
}
// Выводит: 0, 1, 2, 10 (останавливается при i=1, j=1)
```

### Continue с меткой

Переход к следующей итерации внешнего цикла:

```hemlock
let i = 0;
outer: while (i < 3) {
    i = i + 1;
    let j = 0;
    while (j < 3) {
        j = j + 1;
        if (i == 2 && j == 1) {
            continue outer;  // Пропуск остатка внутреннего цикла, продолжение внешнего
        }
        print(i * 10 + j);
    }
}
// При i=2, j=1: пропуск к следующей итерации внешнего цикла
```

### Метки с циклами For

Метки работают со всеми типами циклов:

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 3; y = y + 1) {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
    }
}
```

### Метки с циклами For-In

```hemlock
let arr1 = [1, 2, 3];
let arr2 = [10, 20, 30];

outer: for (let a in arr1) {
    for (let b in arr2) {
        if (a == 2 && b == 20) {
            break outer;
        }
        print(a * 100 + b);
    }
}
```

### Метки с ключевым словом Loop

```hemlock
let x = 0;
outer: loop {
    let y = 0;
    loop {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
        y = y + 1;
        if (y >= 3) { break; }
    }
    x = x + 1;
    if (x >= 3) { break; }
}
```

### Множественные метки

Можно иметь метки на разных уровнях вложенности:

```hemlock
outer: for (let a = 0; a < 2; a = a + 1) {
    inner: for (let b = 0; b < 3; b = b + 1) {
        for (let c = 0; c < 3; c = c + 1) {
            if (c == 1) {
                continue inner;  // Переход к следующей итерации среднего цикла
            }
            if (a == 1 && b == 1) {
                break outer;      // Выход из внешнего цикла
            }
            print(a * 100 + b * 10 + c);
        }
    }
}
```

### Break/Continue без метки с помеченными циклами

Break и continue без метки все еще работают нормально (влияя на ближайший цикл), даже когда внешние циклы имеют метки:

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 5; y = y + 1) {
        if (y == 2) {
            break;  // Прерывает только внутренний цикл
        }
        print(x * 10 + y);
    }
}
// Выводит: 0, 1, 10, 11, 20, 21
```

### Синтаксис меток

- Метки - это идентификаторы, за которыми следует двоеточие
- Метки должны непосредственно предшествовать оператору цикла (`while`, `for`, `loop`)
- Имена меток следуют правилам идентификаторов (буквы, цифры, подчеркивания)
- Общепринятые соглашения: `outer`, `inner`, `row`, `col`, описательные имена

## Оператор Defer

Оператор `defer` планирует выполнение кода при возврате из текущей функции. Это полезно для операций очистки, таких как закрытие файлов, освобождение ресурсов или снятие блокировок.

### Базовый Defer

```hemlock
fn example() {
    print("start");
    defer print("cleanup");  // Выполняется при возврате функции
    print("end");
}

example();
// Вывод:
// start
// end
// cleanup
```

**Ключевое поведение:**
- Отложенные операторы выполняются **после** завершения тела функции
- Отложенные операторы выполняются **до** возврата функции вызывающему
- Отложенные операторы выполняются всегда, даже если функция бросает исключение

### Множественные Defer (порядок LIFO)

Когда используется несколько операторов `defer`, они выполняются в **обратном порядке** (последний вошел - первый вышел):

```hemlock
fn example() {
    defer print("first");   // Выполняется последним
    defer print("second");  // Выполняется вторым
    defer print("third");   // Выполняется первым
    print("body");
}

example();
// Вывод:
// body
// third
// second
// first
```

Этот порядок LIFO намеренный - он соответствует естественному порядку очистки вложенных ресурсов (закрыть внутренние ресурсы до внешних).

### Defer с Return

Отложенные операторы выполняются до того, как `return` передает управление:

```hemlock
fn get_value(): i32 {
    defer print("cleanup");
    print("before return");
    return 42;
}

let result = get_value();
print("result:", result);
// Вывод:
// before return
// cleanup
// result: 42
```

### Defer с исключениями

Отложенные операторы выполняются даже когда бросается исключение:

```hemlock
fn risky() {
    defer print("cleanup 1");
    defer print("cleanup 2");
    print("before throw");
    throw "error!";
    print("after throw");  // Никогда не выполняется
}

try {
    risky();
} catch (e) {
    print("Caught:", e);
}
// Вывод:
// before throw
// cleanup 2
// cleanup 1
// Caught: error!
```

### Паттерн очистки ресурсов

Основной случай использования `defer` - обеспечение очистки ресурсов:

```hemlock
fn process_file(filename: string) {
    let file = open(filename, "r");
    defer file.close();  // Всегда закрывает, даже при ошибке

    let content = file.read();
    // ... обработка содержимого ...

    // Файл автоматически закрывается при возврате функции
}
```

**Без defer (подверженный ошибкам):**
```hemlock
fn process_file_bad(filename: string) {
    let file = open(filename, "r");
    let content = file.read();
    // Если это бросит исключение, file.close() никогда не вызовется!
    process(content);
    file.close();
}
```

### Defer с замыканиями

Defer может использовать замыкания для захвата состояния:

```hemlock
fn example() {
    let resource = acquire_resource();
    defer fn() {
        print("Releasing resource");
        release(resource);
    }();  // Примечание: немедленно вызываемое функциональное выражение

    use_resource(resource);
}
```

### Когда использовать Defer

**Используйте defer для:**
- Закрытия файлов и сетевых соединений
- Освобождения выделенной памяти
- Снятия блокировок и мьютексов
- Очистки в любой функции, которая получает ресурсы

**Defer vs Finally:**
- `defer` проще для очистки одного ресурса
- `try/finally` лучше для сложной обработки ошибок с восстановлением

### Лучшие практики

1. **Размещайте defer сразу после получения ресурса:**
   ```hemlock
   let file = open("data.txt", "r");
   defer file.close();
   // ... использование file ...
   ```

2. **Используйте несколько defer для нескольких ресурсов:**
   ```hemlock
   let file1 = open("input.txt", "r");
   defer file1.close();

   let file2 = open("output.txt", "w");
   defer file2.close();

   // Оба файла будут закрыты в обратном порядке
   ```

3. **Помните порядок LIFO для зависимых ресурсов:**
   ```hemlock
   let outer = acquire_outer();
   defer release_outer(outer);

   let inner = acquire_inner(outer);
   defer release_inner(inner);

   // inner освобождается до outer (правильный порядок зависимости)
   ```

## Логические операторы

### Логическое И (`&&`)

Оба условия должны быть истинны:

```hemlock
if (x > 0 && x < 10) {
    print("single digit positive");
}
```

**Короткое замыкание:**
```hemlock
if (false && expensive_check()) {
    // expensive_check() никогда не вызывается
}
```

### Логическое ИЛИ (`||`)

Хотя бы одно условие должно быть истинно:

```hemlock
if (x < 0 || x > 100) {
    print("out of range");
}
```

**Короткое замыкание:**
```hemlock
if (true || expensive_check()) {
    // expensive_check() никогда не вызывается
}
```

### Логическое НЕ (`!`)

Отрицает логическое значение:

```hemlock
if (!is_valid) {
    print("invalid");
}

if (!(x > 10)) {
    // То же что: if (x <= 10)
}
```

## Операторы сравнения

### Равенство

```hemlock
if (x == 10) { }    // Равно
if (x != 10) { }    // Не равно
```

Работает со всеми типами:
```hemlock
"hello" == "hello"  // true
true == false       // false
null == null        // true
```

### Отношения

```hemlock
if (x < 10) { }     // Меньше
if (x > 10) { }     // Больше
if (x <= 10) { }    // Меньше или равно
if (x >= 10) { }    // Больше или равно
```

**Применяется продвижение типов:**
```hemlock
let a: i32 = 10;
let b: i64 = 10;
if (a == b) { }     // true (i32 продвигается к i64)
```

## Побитовые операторы

Hemlock предоставляет побитовые операторы для манипуляции целыми числами. Они работают **только с целочисленными типами** (i8-i64, u8-u64).

### Бинарные побитовые операторы

**Побитовое И (`&`)**
```hemlock
let a = 12;  // 1100 в двоичном
let b = 10;  // 1010 в двоичном
print(a & b);   // 8 (1000)
```

**Побитовое ИЛИ (`|`)**
```hemlock
print(a | b);   // 14 (1110)
```

**Побитовое исключающее ИЛИ (`^`)**
```hemlock
print(a ^ b);   // 6 (0110)
```

**Сдвиг влево (`<<`)**
```hemlock
print(a << 2);  // 48 (110000) - сдвиг влево на 2
```

**Сдвиг вправо (`>>`)**
```hemlock
print(a >> 1);  // 6 (110) - сдвиг вправо на 1
```

### Унарный побитовый оператор

**Побитовое НЕ (`~`)**
```hemlock
let a = 12;
print(~a);      // -13 (дополнительный код)

let c: u8 = 15;   // 00001111 в двоичном
print(~c);        // 240 (11110000) в u8
```

### Примеры побитовых операций

**С беззнаковыми типами:**
```hemlock
let c: u8 = 15;   // 00001111 в двоичном
let d: u8 = 7;    // 00000111 в двоичном

print(c & d);     // 7  (00000111)
print(c | d);     // 15 (00001111)
print(c ^ d);     // 8  (00001000)
print(~c);        // 240 (11110000) - в u8
```

**Сохранение типа:**
```hemlock
// Побитовые операции сохраняют тип операндов
let x: u8 = 255;
let result = ~x;  // result это u8 со значением 0

let y: i32 = 100;
let result2 = y << 2;  // result2 это i32 со значением 400
```

**Распространенные паттерны:**
```hemlock
// Проверить установлен ли бит
if (flags & 0x04) {
    print("bit 2 is set");
}

// Установить бит
flags = flags | 0x08;

// Сбросить бит
flags = flags & ~0x02;

// Переключить бит
flags = flags ^ 0x01;
```

### Приоритет операторов

Побитовые операторы следуют приоритету в стиле C:

1. `~` (унарное НЕ) - высший, на одном уровне с `!` и `-`
2. `<<`, `>>` (сдвиги) - выше сравнений, ниже `+`/`-`
3. `&` (побитовое И) - выше `^` и `|`
4. `^` (побитовое исключающее ИЛИ) - между `&` и `|`
5. `|` (побитовое ИЛИ) - ниже `&` и `^`, выше `&&`
6. `&&`, `||` (логические) - низший приоритет

**Примеры:**
```hemlock
// & имеет больший приоритет чем |
let result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12

// Сдвиг имеет больший приоритет чем побитовые операторы
let result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12

// Используйте скобки для ясности
let result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5
```

**Важные замечания:**
- Побитовые операторы работают только с целочисленными типами (не с float, строками и т.д.)
- Продвижение типов следует стандартным правилам (меньшие типы продвигаются к большим)
- Сдвиг вправо (`>>`) арифметический для знаковых типов, логический для беззнаковых
- Величины сдвига не проверяются на диапазон (поведение зависит от платформы для больших сдвигов)

## Приоритет операторов (полный)

От высшего к низшему приоритету:

1. **Унарные**: `!`, `-`, `~`
2. **Мультипликативные**: `*`, `/`, `%`
3. **Аддитивные**: `+`, `-`
4. **Сдвиги**: `<<`, `>>`
5. **Отношения**: `<`, `>`, `<=`, `>=`
6. **Равенство**: `==`, `!=`
7. **Побитовое И**: `&`
8. **Побитовое исключающее ИЛИ**: `^`
9. **Побитовое ИЛИ**: `|`
10. **Логическое И**: `&&`
11. **Логическое ИЛИ**: `||`

**Используйте скобки для ясности:**
```hemlock
// Неясно
if (a || b && c) { }

// Ясно
if (a || (b && c)) { }
if ((a || b) && c) { }
```

## Распространенные паттерны

### Паттерн: Валидация ввода

```hemlock
fn validate_age(age: i32): bool {
    if (age < 0 || age > 150) {
        return false;
    }
    return true;
}
```

### Паттерн: Проверка диапазона

```hemlock
fn in_range(value: i32, min: i32, max: i32): bool {
    return value >= min && value <= max;
}

if (in_range(score, 0, 100)) {
    print("valid score");
}
```

### Паттерн: Автомат состояний

```hemlock
let state = "start";

while (true) {
    switch (state) {
        case "start":
            print("Starting...");
            state = "running";
            break;

        case "running":
            if (should_pause) {
                state = "paused";
            } else if (should_stop) {
                state = "stopped";
            }
            break;

        case "paused":
            if (should_resume) {
                state = "running";
            }
            break;

        case "stopped":
            print("Stopped");
            break;
    }

    if (state == "stopped") {
        break;
    }
}
```

### Паттерн: Итерация с фильтрацией

```hemlock
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Вывести только четные числа
for (let i = 0; i < arr.length; i = i + 1) {
    if (arr[i] % 2 != 0) {
        continue;  // Пропустить нечетные числа
    }
    print(arr[i]);
}
```

### Паттерн: Ранний выход

```hemlock
fn find_first_negative(arr: array): i32 {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // Ранний выход
        }
    }
    return -1;  // Не найдено
}
```

## Лучшие практики

1. **Всегда используйте фигурные скобки** - Даже для однострочных блоков (обязательно по синтаксису)
2. **Явные условия** - Используйте `x == 0` вместо `!x` для ясности
3. **Избегайте глубокой вложенности** - Выносите вложенные условия в функции
4. **Используйте ранние возвраты** - Уменьшайте вложенность с помощью guard clauses
5. **Разбивайте сложные условия** - Разделяйте на именованные логические переменные
6. **Default в switch** - Всегда включайте случай default
7. **Комментируйте fall-through** - Делайте намеренный провал явным

## Распространенные ловушки

### Ловушка: Присваивание в условии

```hemlock
// Это НЕ разрешено (нет присваивания в условиях)
if (x = 10) { }  // ОШИБКА: Синтаксическая ошибка

// Используйте сравнение вместо этого
if (x == 10) { }  // OK
```

### Ловушка: Отсутствующий Break в Switch

```hemlock
// Непреднамеренный провал
switch (x) {
    case 1:
        print("one");
        // Отсутствует break - проваливается!
    case 2:
        print("two");  // Выполняется для обоих 1 и 2
        break;
}

// Исправление: Добавить break
switch (x) {
    case 1:
        print("one");
        break;  // Теперь правильно
    case 2:
        print("two");
        break;
}
```

### Ловушка: Область видимости переменной цикла

```hemlock
// i ограничена циклом
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
print(i);  // ОШИБКА: i не определена здесь
```

## Примеры

### Пример: FizzBuzz

```hemlock
for (let i = 1; i <= 100; i = i + 1) {
    if (i % 15 == 0) {
        print("FizzBuzz");
    } else if (i % 3 == 0) {
        print("Fizz");
    } else if (i % 5 == 0) {
        print("Buzz");
    } else {
        print(i);
    }
}
```

### Пример: Проверка простоты

```hemlock
fn is_prime(n: i32): bool {
    if (n < 2) {
        return false;
    }

    let i = 2;
    while (i * i <= n) {
        if (n % i == 0) {
            return false;
        }
        i = i + 1;
    }

    return true;
}
```

### Пример: Система меню

```hemlock
fn menu() {
    while (true) {
        print("1. Start");
        print("2. Settings");
        print("3. Exit");

        let choice = get_input();

        switch (choice) {
            case 1:
                start_game();
                break;
            case 2:
                show_settings();
                break;
            case 3:
                print("Goodbye!");
                return;
            default:
                print("Invalid choice");
                break;
        }
    }
}
```

## Связанные темы

- [Функции](functions.md) - Управление потоком с вызовами и возвратами функций
- [Обработка ошибок](error-handling.md) - Управление потоком с исключениями
- [Типы](types.md) - Преобразования типов в условиях

## См. также

- **Синтаксис**: См. [Синтаксис](syntax.md) для деталей синтаксиса операторов
- **Операторы**: См. [Типы](types.md) для продвижения типов в операциях
