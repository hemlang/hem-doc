# Система типов

Hemlock имеет **динамическую систему типов** с необязательными аннотациями типов и проверкой типов во время выполнения.

---

## Руководство по выбору типов: Какой тип использовать?

**Новичок в типах?** Начните здесь. Если вы знакомы с системами типов, перейдите к разделу [Философия](#философия).

### Краткий ответ

**Просто позвольте Hemlock разобраться:**

```hemlock
let count = 42;        // Hemlock знает, что это целое число
let price = 19.99;     // Hemlock знает, что это десятичное
let name = "Alice";    // Hemlock знает, что это текст
let active = true;     // Hemlock знает, что это да/нет
```

Hemlock автоматически выбирает правильный тип для ваших значений. Вам *не нужно* указывать типы.

### Когда добавлять аннотации типов

Добавляйте типы, когда хотите:

1. **Быть точным в размере** - `i8` vs `i64` имеет значение для памяти или FFI
2. **Документировать код** - Типы показывают, что ожидает функция
3. **Ловить ошибки раньше** - Hemlock проверяет типы во время выполнения

```hemlock
// Без типов (работает нормально):
fn add(a, b) {
    return a + b;
}

// С типами (более явно):
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Краткий справочник: Выбор числовых типов

| Что вы храните | Рекомендуемый тип | Пример |
|----------------|-------------------|--------|
| Обычные целые числа | `i32` (по умолчанию) | `let count = 42;` |
| Очень большие числа | `i64` | `let population = 8000000000;` |
| Неотрицательные счетчики | `u32` | `let items: u32 = 100;` |
| Байты (0-255) | `u8` | `let pixel: u8 = 255;` |
| Десятичные/дробные | `f64` (по умолчанию) | `let price = 19.99;` |
| Критичные к производительности десятичные | `f32` | `let x: f32 = 1.5;` |

### Краткий справочник: Все типы

| Категория | Типы | Когда использовать |
|-----------|------|-------------------|
| **Целые числа** | `i8`, `i16`, `i32`, `i64` | Счетчики, ID, возраст и т.д. |
| **Только положительные числа** | `u8`, `u16`, `u32`, `u64` | Байты, размеры, длины массивов |
| **Десятичные** | `f32`, `f64` | Деньги, измерения, математика |
| **Да/Нет** | `bool` | Флаги, условия |
| **Текст** | `string` | Имена, сообщения, любой текст |
| **Один символ** | `rune` | Отдельные буквы, эмодзи |
| **Списки** | `array` | Коллекции значений |
| **Именованные поля** | `object` | Группировка связанных данных |
| **Сырая память** | `ptr`, `buffer` | Низкоуровневое программирование |
| **Ничего** | `null` | Отсутствие значения |

### Типичные сценарии

**"Мне просто нужно число"**
```hemlock
let x = 42;  // Готово! Hemlock выбирает i32
```

**"Мне нужны десятичные"**
```hemlock
let price = 19.99;  // Готово! Hemlock выбирает f64
```

**"Я работаю с байтами (файлы, сеть)"**
```hemlock
let byte: u8 = 255;  // Диапазон 0-255
```

**"Мне нужны очень большие числа"**
```hemlock
let big = 9000000000000;  // Hemlock автоматически выбирает i64 (> i32 max)
// Или явно:
let big: i64 = 9000000000000;
```

**"Я храню деньги"**
```hemlock
// Вариант 1: Float (просто, но имеет ограничения точности)
let price: f64 = 19.99;

// Вариант 2: Хранить как центы (более точно)
let price_cents: i32 = 1999;  // $19.99 как целые центы
```

**"Я передаю данные в C-код (FFI)"**
```hemlock
// Точно соответствуйте типам C
let c_int: i32 = 100;      // C 'int'
let c_long: i64 = 100;     // C 'long' (на 64-бит)
let c_char: u8 = 65;       // C 'char'
let c_double: f64 = 3.14;  // C 'double'
```

### Что происходит при смешивании типов?

Когда вы комбинируете разные типы, Hemlock продвигает к "большему" типу:

```hemlock
let a: i32 = 10;
let b: f64 = 2.5;
let result = a + b;  // result это f64 (12.5)
// Целое автоматически стало десятичным
```

**Правило большого пальца:** Числа с плавающей точкой всегда "побеждают" - смешивание любого целого с float дает float.

### Ошибки типов

Если вы попытаетесь использовать неправильный тип, Hemlock сообщит во время выполнения:

```hemlock
let age: i32 = "thirty";  // ОШИБКА: несоответствие типов - ожидался i32, получен string
```

Для преобразования типов используйте функции-конструкторы типов:

```hemlock
let text = "42";
let number = i32(text);   // Разбор строки в целое: 42
let back = text + "";     // Уже строка
```

---

## Философия

- **Динамический по умолчанию** - Каждое значение имеет тег типа времени выполнения
- **Типизированный по выбору** - Необязательные аннотации типов обеспечивают проверки времени выполнения
- **Явные преобразования** - Неявные преобразования следуют четким правилам продвижения
- **Честный в отношении типов** - `typeof()` всегда говорит правду

## Примитивные типы

### Целочисленные типы

**Знаковые целые:**
```hemlock
let tiny: i8 = 127;              // 8-бит  (-128 до 127)
let small: i16 = 32767;          // 16-бит (-32768 до 32767)
let normal: i32 = 2147483647;    // 32-бит (по умолчанию)
let large: i64 = 9223372036854775807;  // 64-бит
```

**Беззнаковые целые:**
```hemlock
let byte: u8 = 255;              // 8-бит  (0 до 255)
let word: u16 = 65535;           // 16-бит (0 до 65535)
let dword: u32 = 4294967295;     // 32-бит (0 до 4294967295)
let qword: u64 = 18446744073709551615;  // 64-бит
```

**Псевдонимы типов:**
```hemlock
let i: integer = 42;   // Псевдоним для i32
let b: byte = 255;     // Псевдоним для u8
```

### Типы с плавающей точкой

```hemlock
let f: f32 = 3.14159;        // 32-бит float
let d: f64 = 2.718281828;    // 64-бит float (по умолчанию)
let n: number = 1.618;       // Псевдоним для f64
```

### Булев тип

```hemlock
let flag: bool = true;
let active: bool = false;
```

### Строковый тип

```hemlock
let text: string = "Hello, World!";
let empty: string = "";
```

Строки являются **изменяемыми**, **кодируются в UTF-8** и **размещаются в куче**.

См. [Строки](strings.md) для полной информации.

### Тип Rune

```hemlock
let ch: rune = 'A';
let emoji: rune = '(ракета)';
let newline: rune = '\n';
let unicode: rune = '\u{1F680}';
```

Руны представляют **кодовые точки Unicode** (U+0000 до U+10FFFF).

См. [Руны](runes.md) для полной информации.

### Тип Null

```hemlock
let nothing = null;
let uninitialized: string = null;
```

`null` - это свой собственный тип с единственным значением.

## Составные типы

### Тип Array

```hemlock
let numbers: array = [1, 2, 3, 4, 5];
let mixed = [1, "two", true, null];  // Смешанные типы разрешены
let empty: array = [];
```

См. [Массивы](arrays.md) для полной информации.

### Тип Object

```hemlock
let obj: object = { x: 10, y: 20 };
let person = { name: "Alice", age: 30 };
```

См. [Объекты](objects.md) для полной информации.

### Типы указателей

**Сырой указатель:**
```hemlock
let p: ptr = alloc(64);
// Без проверки границ, ручное управление временем жизни
free(p);
```

**Безопасный буфер:**
```hemlock
let buf: buffer = buffer(64);
// С проверкой границ, отслеживает длину и емкость
free(buf);
```

См. [Управление памятью](memory.md) для полной информации.

## Типы Enum

Перечисления определяют набор именованных констант:

### Базовые перечисления

```hemlock
enum Color {
    RED,
    GREEN,
    BLUE
}

let c = Color.RED;
print(c);              // 0
print(typeof(c));      // "Color"

// Сравнение
if (c == Color.RED) {
    print("It's red!");
}

// Switch по enum
switch (c) {
    case Color.RED:
        print("Stop");
        break;
    case Color.GREEN:
        print("Go");
        break;
    case Color.BLUE:
        print("Blue?");
        break;
}
```

### Перечисления со значениями

Перечисления могут иметь явные целочисленные значения:

```hemlock
enum Status {
    OK = 0,
    ERROR = 1,
    PENDING = 2
}

print(Status.OK);      // 0
print(Status.ERROR);   // 1

enum HttpCode {
    OK = 200,
    NOT_FOUND = 404,
    SERVER_ERROR = 500
}

let code = HttpCode.NOT_FOUND;
print(code);           // 404
```

### Автоинкрементные значения

Без явных значений перечисления автоматически увеличиваются от 0:

```hemlock
enum Priority {
    LOW,       // 0
    MEDIUM,    // 1
    HIGH,      // 2
    CRITICAL   // 3
}

// Можно смешивать явные и автоматические значения
enum Level {
    DEBUG = 10,
    INFO,      // 11
    WARN,      // 12
    ERROR = 50,
    FATAL      // 51
}
```

### Паттерны использования Enum

```hemlock
// Как параметры функций
fn set_priority(p: Priority) {
    if (p == Priority.CRITICAL) {
        print("Urgent!");
    }
}

set_priority(Priority.HIGH);

// В объектах
define Task {
    name: string,
    priority: Priority
}

let task: Task = {
    name: "Fix bug",
    priority: Priority.HIGH
};
```

## Специальные типы

### Тип File

```hemlock
let f: file = open("data.txt", "r");
f.close();
```

Представляет открытый дескриптор файла.

### Тип Task

```hemlock
async fn compute(): i32 { return 42; }
let task = spawn(compute);
let result: i32 = join(task);
```

Представляет дескриптор асинхронной задачи.

### Тип Channel

```hemlock
let ch: channel = channel(10);
ch.send(42);
let value = ch.recv();
```

Представляет канал связи между задачами.

### Тип Void

```hemlock
extern fn exit(code: i32): void;
```

Используется для функций, которые не возвращают значение (только FFI).

## Вывод типов

### Вывод целочисленных литералов

Hemlock выводит целочисленные типы на основе диапазона значений:

```hemlock
let a = 42;              // i32 (помещается в 32-бит)
let b = 5000000000;      // i64 (> i32 max)
let c = 128;             // i32
let d: u8 = 128;         // u8 (явная аннотация)
```

**Правила:**
- Значения в диапазоне i32 (-2147483648 до 2147483647): выводятся как `i32`
- Значения вне диапазона i32, но в пределах i64: выводятся как `i64`
- Используйте явные аннотации для других типов (i8, i16, u8, u16, u32, u64)

### Вывод литералов с плавающей точкой

```hemlock
let x = 3.14;        // f64 (по умолчанию)
let y: f32 = 3.14;   // f32 (явно)
```

### Научная нотация

Hemlock поддерживает научную нотацию для числовых литералов:

```hemlock
let a = 1e10;        // 10000000000.0 (f64)
let b = 1e-12;       // 0.000000000001 (f64)
let c = 3.14e2;      // 314.0 (f64)
let d = 2.5e-3;      // 0.0025 (f64)
let e = 1E10;        // Регистр не важен
let f = 1e+5;        // Явная положительная экспонента
```

**Примечание:** Любой литерал с научной нотацией всегда выводится как `f64`.

### Вывод других типов

```hemlock
let s = "hello";     // string
let ch = 'A';        // rune
let flag = true;     // bool
let arr = [1, 2, 3]; // array
let obj = { x: 10 }; // object
let nothing = null;  // null
```

## Аннотации типов

### Аннотации переменных

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let name: string = "Alice";
```

### Аннотации параметров функций

```hemlock
fn greet(name: string, age: i32) {
    print("Hello, " + name + "!");
}
```

### Аннотации возвращаемого типа функций

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Аннотации типов объектов (утиная типизация)

```hemlock
define Person {
    name: string,
    age: i32,
}

let p: Person = { name: "Bob", age: 25 };
```

## Проверка типов

### Проверка типов во время выполнения

Аннотации типов проверяются во **время выполнения**, а не во время компиляции:

```hemlock
let x: i32 = 42;     // OK
let y: i32 = 3.14;   // Ошибка времени выполнения: несоответствие типов

fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 3);           // OK
add(5, "hello");     // Ошибка времени выполнения: несоответствие типов
```

### Запросы типов

Используйте `typeof()` для проверки типов значений:

```hemlock
print(typeof(42));         // "i32"
print(typeof(3.14));       // "f64"
print(typeof("hello"));    // "string"
print(typeof(true));       // "bool"
print(typeof(null));       // "null"
print(typeof([1, 2, 3]));  // "array"
print(typeof({ x: 10 }));  // "object"
```

## Преобразования типов

### Неявное продвижение типов

При смешивании типов в операциях Hemlock продвигает к "высшему" типу:

**Иерархия продвижения (от низшего к высшему):**
```
i8 -> i16 -> i32 -> u32 -> i64 -> u64 -> f32 -> f64
      ^      ^      ^
     u8     u16
```

**Float всегда побеждает:**
```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // result это f64 (13.5)
```

**Больший размер побеждает:**
```hemlock
let a: i32 = 100;
let b: i64 = 200;
let sum = a + b;     // sum это i64 (300)
```

**Сохранение точности:** При смешивании 64-битных целых с f32, Hemlock продвигает
к f64 для избежания потери точности (f32 имеет только 24-битную мантиссу, недостаточно для i64/u64):
```hemlock
let big: i64 = 9007199254740993;
let small: f32 = 1.0;
let result = big + small;  // result это f64, не f32!
```

**Примеры:**
```hemlock
u8 + i32  -> i32
i32 + i64 -> i64
u32 + u64 -> u64
i32 + f32 -> f32    // f32 достаточно для i32
i64 + f32 -> f64    // f64 нужен для сохранения точности i64
i64 + f64 -> f64
i8 + f64  -> f64
```

### Явное преобразование типов

**Целое <-> Float:**
```hemlock
let i: i32 = 42;
let f: f64 = i;      // i32 -> f64 (42.0)

let x: f64 = 3.14;
let n: i32 = x;      // f64 -> i32 (3, усечено)
```

**Целое <-> Rune:**
```hemlock
let code: i32 = 65;
let ch: rune = code;  // i32 -> rune ('A')

let r: rune = 'Z';
let value: i32 = r;   // rune -> i32 (90)
```

**Rune -> String:**
```hemlock
let ch: rune = '(ракета)';
let s: string = ch;   // rune -> string ("(ракета)")
```

**u8 -> Rune:**
```hemlock
let b: u8 = 65;
let r: rune = b;      // u8 -> rune ('A')
```

### Функции-конструкторы типов

Имена типов можно использовать как функции для преобразования или разбора значений:

**Разбор строк в числа:**
```hemlock
let n = i32("42");       // Разбор строки в i32: 42
let f = f64("3.14159");  // Разбор строки в f64: 3.14159
let b = bool("true");    // Разбор строки в bool: true

// Все числовые типы поддерживаются
let a = i8("-128");      // Разбор в i8
let c = u8("255");       // Разбор в u8
let d = i16("1000");     // Разбор в i16
let e = u16("50000");    // Разбор в u16
let g = i64("9000000000000"); // Разбор в i64
let h = u64("18000000000000"); // Разбор в u64
let j = f32("1.5");      // Разбор в f32
```

**Шестнадцатеричные и отрицательные числа:**
```hemlock
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42
let bin = i32("0b1010"); // 10 (двоичное)
```

**Псевдонимы типов тоже работают:**
```hemlock
let x = integer("100");  // То же что i32("100")
let y = number("1.5");   // То же что f64("1.5")
let z = byte("200");     // То же что u8("200")
```

**Преобразование между числовыми типами:**
```hemlock
let big = i64(42);           // i32 в i64
let truncated = i32(3.99);   // f64 в i32 (усекается до 3)
let promoted = f64(100);     // i32 в f64 (100.0)
let narrowed = i8(127);      // i32 в i8
```

**Аннотации типов выполняют числовое приведение (но НЕ разбор строк):**
```hemlock
let f: f64 = 100;        // i32 в f64 через аннотацию (OK)
let s: string = 'A';     // Rune в string через аннотацию (OK)
let code: i32 = 'A';     // Rune в i32 через аннотацию (получает кодовую точку, OK)

// Разбор строк требует явных конструкторов типов:
let n = i32("42");       // Используйте конструктор типа для разбора строк
// let x: i32 = "42";    // ОШИБКА - аннотации типов не разбирают строки
```

**Обработка ошибок:**
```hemlock
// Недопустимые строки вызывают ошибки при использовании конструкторов типов
let bad = i32("hello");  // Ошибка времени выполнения: не могу разобрать "hello" как i32
let overflow = u8("256"); // Ошибка времени выполнения: 256 вне диапазона для u8
```

**Разбор булевых:**
```hemlock
let t = bool("true");    // true
let f = bool("false");   // false
let bad = bool("yes");   // Ошибка времени выполнения: должно быть "true" или "false"
```

## Проверка диапазона

Аннотации типов обеспечивают проверки диапазона при присваивании:

```hemlock
let x: u8 = 255;    // OK
let y: u8 = 256;    // ОШИБКА: вне диапазона для u8

let a: i8 = 127;    // OK
let b: i8 = 128;    // ОШИБКА: вне диапазона для i8

let c: i64 = 2147483647;   // OK
let d: u64 = 4294967295;   // OK
let e: u64 = -1;           // ОШИБКА: u64 не может быть отрицательным
```

## Примеры продвижения типов

### Смешанные целочисленные типы

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let sum = a + b;     // i32 (30)

let c: u8 = 100;
let d: u32 = 200;
let total = c + d;   // u32 (300)
```

### Целое + Float

```hemlock
let i: i32 = 5;
let f: f32 = 2.5;
let result = i * f;  // f32 (12.5)
```

### Сложные выражения

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let c: f64 = 3.0;

let result = a + b * c;  // f64 (70.0)
// Вычисление: b * c -> f64(60.0)
//             a + f64(60.0) -> f64(70.0)
```

## Утиная типизация (объекты)

Объекты используют **структурную типизацию** (утиная типизация):

```hemlock
define Person {
    name: string,
    age: i32,
}

// OK: Имеет все обязательные поля
let p1: Person = { name: "Alice", age: 30 };

// OK: Дополнительные поля разрешены
let p2: Person = { name: "Bob", age: 25, city: "NYC" };

// ОШИБКА: Отсутствует поле 'age'
let p3: Person = { name: "Carol" };

// ОШИБКА: Неправильный тип для 'age'
let p4: Person = { name: "Dave", age: "thirty" };
```

**Проверка типов происходит при присваивании:**
- Проверяет, что все обязательные поля присутствуют
- Проверяет, что типы полей совпадают
- Дополнительные поля разрешены и сохраняются
- Устанавливает имя типа объекта для `typeof()`

## Необязательные поля

```hemlock
define Config {
    host: string,
    port: i32,
    debug?: false,     // Необязательное со значением по умолчанию
    timeout?: i32,     // Необязательное, по умолчанию null
}

let cfg1: Config = { host: "localhost", port: 8080 };
print(cfg1.debug);    // false (по умолчанию)
print(cfg1.timeout);  // null

let cfg2: Config = { host: "0.0.0.0", port: 80, debug: true };
print(cfg2.debug);    // true (переопределено)
```

## Псевдонимы типов

Hemlock поддерживает пользовательские псевдонимы типов с помощью ключевого слова `type`:

### Базовые псевдонимы типов

```hemlock
// Простой псевдоним типа
type Integer = i32;
type Text = string;

// Использование псевдонима
let x: Integer = 42;
let msg: Text = "hello";
```

### Псевдонимы функциональных типов

```hemlock
// Псевдоним функционального типа
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// Использование псевдонимов функциональных типов
let cb: Callback = fn(n) { print(n); };
let isEven: Predicate = fn(n) { return n % 2 == 0; };
```

### Составные псевдонимы типов

```hemlock
// Комбинирование нескольких define в один тип
define HasName { name: string }
define HasAge { age: i32 }

type Person = HasName & HasAge;

let p: Person = { name: "Alice", age: 30 };
```

### Обобщенные псевдонимы типов

```hemlock
// Обобщенный псевдоним типа
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };

// Использование обобщенных псевдонимов
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
```

**Примечание:** Псевдонимы типов прозрачны - `typeof()` возвращает имя базового типа, а не псевдонима.

## Ограничения системы типов

Текущие ограничения:

- **Нет обобщений для функций** - Параметры типов функций пока не поддерживаются
- **Нет типов объединения** - Нельзя выразить "A или B"
- **Нет nullable типов** - Все типы могут быть null (используйте суффикс `?` для явной nullable)

**Примечание:** Компилятор (`hemlockc`) предоставляет проверку типов во время компиляции. Интерпретатор выполняет только проверку типов во время выполнения. См. [документацию компилятора](../design/implementation.md) для деталей.

## Лучшие практики

### Когда использовать аннотации типов

**ИСПОЛЬЗУЙТЕ аннотации когда:**
- Точный тип имеет значение (например, `u8` для байтовых значений)
- Документирование интерфейсов функций
- Обеспечение ограничений (например, проверки диапазона)

```hemlock
fn hash(data: buffer, length: u32): u64 {
    // Реализация
}
```

**НЕ ИСПОЛЬЗУЙТЕ аннотации когда:**
- Тип очевиден из литерала
- Внутренние детали реализации
- Излишняя церемония

```hemlock
// Излишне
let x: i32 = 42;

// Лучше
let x = 42;
```

### Паттерны безопасности типов

**Проверяйте перед использованием:**
```hemlock
if (typeof(value) == "i32") {
    // Безопасно использовать как i32
}
```

**Валидируйте аргументы функций:**
```hemlock
fn divide(a, b) {
    if (typeof(a) != "i32" || typeof(b) != "i32") {
        throw "arguments must be integers";
    }
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}
```

**Используйте утиную типизацию для гибкости:**
```hemlock
define Printable {
    toString: fn,
}

fn print_item(item: Printable) {
    print(item.toString());
}
```

## Следующие шаги

- [Строки](strings.md) - Тип строк UTF-8 и операции
- [Руны](runes.md) - Тип кодовых точек Unicode
- [Массивы](arrays.md) - Тип динамических массивов
- [Объекты](objects.md) - Литералы объектов и утиная типизация
- [Память](memory.md) - Типы указателей и буферов
