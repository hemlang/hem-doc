# メモリ管理

Hemlockは、割り当てと解放の明示的な制御を持つ**手動メモリ管理**を採用しています。このガイドでは、Hemlockのメモリモデル、2つのポインタ型、および完全なメモリAPIについて説明します。

---

## メモリ入門：基礎

**プログラミング初心者の方**はここから始めてください。すでにメモリ管理を理解している場合は、[設計思想](#設計思想)にスキップしてください。

### メモリ管理とは？

プログラムがデータ（テキスト、数値、リスト）を保存する必要がある場合、それを置く場所が必要です。その場所はコンピュータのメモリ（RAM）から来ます。メモリ管理とは：

1. **スペースを取得する** - 必要なときにメモリを要求する
2. **スペースを使用する** - データの読み書き
3. **返却する** - 終わったらメモリを返す

### なぜ重要なのか？

限られた本がある図書館を想像してください：
- 本を借り続けて返さなければ、最終的に本がなくなる
- すでに返した本を読もうとすると、混乱したり問題が発生する

メモリも同じように動作します。メモリを返すのを忘れると、プログラムは徐々にメモリを多く使用していきます（「メモリリーク」）。解放後のメモリを使用しようとすると、悪いことが起こります。

### 良いニュース

**ほとんどの場合、これについて考える必要はありません！**

Hemlockはほとんどの一般的な型を自動的にクリーンアップします：

```hemlock
fn example() {
    let name = "Alice";       // Hemlockがこれを管理
    let numbers = [1, 2, 3];  // これも
    let person = { age: 30 }; // これも

    // 関数が終了すると、これらはすべて自動的にクリーンアップされる！
}
```

### 考える必要があるとき

手動メモリ管理が必要なのは以下を使用する場合のみ：

1. **`alloc()`** - 生のメモリ割り当て（`ptr`を返す）
2. **`buffer()`** - 早期解放が必要な場合（オプション - スコープ終了時に自動解放）

```hemlock
// これは手動クリーンアップが必要：
let raw = alloc(100);   // 生のメモリ - あなたが解放する必要がある
// ... rawを使用 ...
free(raw);              // 必須！さもなければメモリリーク

// これは自動的にクリーンアップされる（ただし早期解放は可能）：
let buf = buffer(100);  // 安全なバッファ
// ... bufを使用 ...
// free(buf);           // オプション - スコープ終了時に自動解放
```

### シンプルなルール

> **`alloc()`を呼び出したら、`free()`を呼び出す必要がある。**
>
> それ以外はすべて自動的に処理される。

### どちらを使うべき？

| 状況 | 使用するもの | 理由 |
|-----------|----------|-----|
| **始めたばかり** | `buffer()` | 安全、境界チェック、自動クリーンアップ |
| **バイトストレージが必要** | `buffer()` | 安全で簡単 |
| **Cライブラリ（FFI）と連携** | `alloc()` / `ptr` | C相互運用に必須 |
| **最大パフォーマンス** | `alloc()` / `ptr` | 境界チェックのオーバーヘッドなし |
| **分からない** | `buffer()` | 常により安全な選択 |

### クイック例：安全 vs 生

```hemlock
// 推奨：安全なバッファ
fn safe_example() {
    let data = buffer(10);
    data[0] = 65;           // OK
    data[5] = 66;           // OK
    // data[100] = 67;      // エラー - Hemlockが停止（境界チェック）
    free(data);             // クリーンアップ
}

// 上級者向け：生のポインタ（必要な場合のみ）
fn raw_example() {
    let data = alloc(10);
    *data = 65;             // OK
    *(data + 5) = 66;       // OK
    *(data + 100) = 67;     // 危険 - 境界チェックなし、メモリ破壊！
    free(data);             // クリーンアップ
}
```

**`buffer()`から始めましょう。生のポインタが特に必要な場合のみ`alloc()`を使用してください。**

---

## 設計思想

Hemlockは、合理的なデフォルトを持つ明示的なメモリ管理の原則に従います：
- ガベージコレクションなし（予測不可能な一時停止なし）
- 一般的な型（string、array、object、buffer）の内部参照カウント
- 生のポインタ（`ptr`）は手動の`free()`が必要

このハイブリッドアプローチにより、必要なときは完全な制御（生のポインタ）を提供しつつ、一般的な使用例（スコープ終了時に自動解放される参照カウント型）での一般的なバグを防ぎます。

## 内部参照カウント

ランタイムは**内部参照カウント**を使用してオブジェクトの寿命を管理します。参照カウント型のほとんどのローカル変数では、クリーンアップは自動的かつ決定論的です。

### 参照カウントが処理するもの

ランタイムは以下の場合に参照カウントを自動的に管理します：

1. **変数が再代入される** - 古い値が解放される：
   ```hemlock
   let x = "first";   // ref_count = 1
   x = "second";      // "first"は内部的に解放、"second"のref_count = 1
   ```

2. **スコープを抜ける** - ローカル変数が解放される：
   ```hemlock
   fn example() {
       let arr = [1, 2, 3];  // ref_count = 1
   }  // 関数が戻るとarrが解放される
   ```

3. **コンテナが解放される** - 要素が解放される：
   ```hemlock
   let arr = [obj1, obj2];
   free(arr);  // obj1とobj2の参照カウントがデクリメントされる
   ```

### `free()`が必要な場合 vs 自動の場合

**自動（`free()`不要）：** 参照カウント型のローカル変数はスコープを抜けると解放される：

```hemlock
fn process_data() {
    let arr = [1, 2, 3];
    let obj = { name: "test" };
    let buf = buffer(64);
    // ... 使用する ...
}  // 関数が戻るとすべて自動的に解放 - free()不要
```

**手動の`free()`が必要：**

1. **生のポインタ** - `alloc()`には参照カウントがない：
   ```hemlock
   let p = alloc(64);
   // ... pを使用 ...
   free(p);  // 常に必須 - そうでなければリーク
   ```

2. **早期クリーンアップ** - スコープ終了前に解放してメモリを早く解放：
   ```hemlock
   fn long_running() {
       let big = buffer(10000000);  // 10MB
       // ... bigの使用終了 ...
       free(big);  // 今すぐ解放、関数の戻りを待たない
       // ... bigを必要としない追加の処理 ...
   }
   ```

3. **長期間存続するデータ** - グローバルまたは永続構造体に格納されたデータ：
   ```hemlock
   let cache = {};  // モジュールレベル、解放されない限りプログラム終了まで存続

   fn cleanup() {
       free(cache);  // 長期間存続するデータの手動クリーンアップ
   }
   ```

### 参照カウント vs ガベージコレクション

| 側面 | Hemlock参照カウント | ガベージコレクション |
|--------|---------------------|-------------------|
| クリーンアップのタイミング | 決定論的（refが0になると即座） | 非決定論的（GCが決定） |
| ユーザーの責任 | `free()`を呼ぶ必要がある | 完全自動 |
| ランタイムの一時停止 | なし | 「世界を止める」一時停止 |
| 可視性 | 隠れた実装の詳細 | 通常不可視 |
| 循環 | 訪問済みセットの追跡で処理 | トレースで処理 |

### 参照カウントを持つ型

| 型 | 参照カウント | 備考 |
|------|------------|-------|
| `ptr` | いいえ | 常に手動の`free()`が必要 |
| `buffer` | はい | スコープ終了時に自動解放；早期クリーンアップには手動の`free()` |
| `array` | はい | スコープ終了時に自動解放；早期クリーンアップには手動の`free()` |
| `object` | はい | スコープ終了時に自動解放；早期クリーンアップには手動の`free()` |
| `string` | はい | 完全自動、`free()`不要 |
| `function` | はい | 完全自動（クロージャ環境） |
| `task` | はい | スレッドセーフなアトミック参照カウント |
| `channel` | はい | スレッドセーフなアトミック参照カウント |
| プリミティブ | いいえ | スタック割り当て、ヒープ割り当てなし |

### なぜこの設計か？

このハイブリッドアプローチにより：
- **明示的な制御** - いつ解放するかを決定できる
- **スコープバグからの安全性** - 再代入でリークしない
- **予測可能なパフォーマンス** - GCの一時停止なし
- **クロージャのサポート** - 関数が安全に変数をキャプチャできる

設計思想は変わりません：あなたが制御しますが、ランタイムが再代入時のリークやコンテナでの二重解放などの一般的なバグを防ぐのを助けます。

## 2つのポインタ型

Hemlockは、異なる安全特性を持つ2つの異なるポインタ型を提供します：

### `ptr` - 生のポインタ（危険）

生のポインタは**ただのアドレス**で、最小限の安全保証しかありません：

```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // 解放を覚えておく必要がある
```

**特徴：**
- ただの8バイトのアドレス
- 境界チェックなし
- 長さの追跡なし
- ユーザーが完全に寿命を管理
- エキスパートとFFI向け

**使用例：**
- 低レベルシステムプログラミング
- 外部関数インターフェース（FFI）
- パフォーマンスクリティカルなコード
- 完全な制御が必要な場合

**危険：**
```hemlock
let p = alloc(10);
let q = p + 100;  // 割り当て範囲をはるかに超えている - 許可されるが危険
free(p);
let x = *p;       // ダングリングポインタ - 未定義動作
free(p);          // 二重解放 - クラッシュする
```

### `buffer` - 安全なラッパー（推奨）

バッファは**境界チェックされたアクセス**を提供しつつ、手動解放が必要です：

```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // 境界チェックあり
print(b.length);        // 64
free(b);                // まだ手動
```

**特徴：**
- ポインタ + 長さ + 容量
- アクセス時に境界チェック
- まだ手動の`free()`が必要
- ほとんどのコードでより良いデフォルト

**プロパティ：**
```hemlock
let buf = buffer(100);
print(buf.length);      // 100（現在のサイズ）
print(buf.capacity);    // 100（割り当て容量）
```

**境界チェック：**
```hemlock
let buf = buffer(10);
buf[5] = 42;      // OK
buf[100] = 42;    // エラー：インデックスが範囲外
```

## メモリAPI

### コア割り当て

**`alloc(bytes)` - 生のメモリを割り当て**
```hemlock
let p = alloc(1024);  // 1KBを割り当て、ptrを返す
// ... メモリを使用
free(p);
```

**`buffer(size)` - 安全なバッファを割り当て**
```hemlock
let buf = buffer(256);  // 256バイトのバッファを割り当て
buf[0] = 65;            // 'A'
buf[1] = 66;            // 'B'
free(buf);
```

**`free(ptr)` - メモリを解放**
```hemlock
let p = alloc(100);
free(p);  // メモリリークを避けるために解放必須

let buf = buffer(100);
free(buf);  // ptrとbufferの両方で動作
```

**重要：** `free()`は`ptr`と`buffer`型の両方で動作します。

### メモリ操作

**`memset(ptr, byte, size)` - メモリを埋める**
```hemlock
let p = alloc(100);
memset(p, 0, 100);     // 100バイトをゼロクリア
memset(p, 65, 10);     // 最初の10バイトを'A'で埋める
free(p);
```

**`memcpy(dest, src, size)` - メモリをコピー**
```hemlock
let src = alloc(50);
let dst = alloc(50);
memset(src, 42, 50);
memcpy(dst, src, 50);  // srcからdstに50バイトをコピー
free(src);
free(dst);
```

**`realloc(ptr, size)` - 割り当てをリサイズ**
```hemlock
let p = alloc(100);
// ... 100バイトを使用
p = realloc(p, 200);   // 200バイトにリサイズ
// ... 200バイトを使用
free(p);
```

**注意：** `realloc()`後、古いポインタは無効になる可能性があります。常に返されたポインタを使用してください。

### 型付き割り当て

Hemlockは便利のために型付き割り当てヘルパーを提供します：

```hemlock
let arr = talloc(i32, 100);  // 100個のi32値を割り当て（400バイト）
let size = sizeof(i32);      // 4を返す（バイト）
```

**`sizeof(type)`**は型のバイトサイズを返します：
- `sizeof(i8)` / `sizeof(u8)` → 1
- `sizeof(i16)` / `sizeof(u16)` → 2
- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` → 4
- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` → 8
- `sizeof(ptr)` → 8（64ビットシステム）

**`talloc(type, count)`**は`type`の`count`要素を割り当てます：

```hemlock
let ints = talloc(i32, 10);   // 10個のi32値に40バイト
let floats = talloc(f64, 5);  // 5個のf64値に40バイト
free(ints);
free(floats);
```

## よくあるパターン

### パターン：割り当て、使用、解放

メモリ管理の基本パターン：

```hemlock
// 1. 割り当て
let data = alloc(1024);

// 2. 使用
memset(data, 0, 1024);
// ... 処理を行う

// 3. 解放
free(data);
```

### パターン：安全なバッファの使用

境界チェックされたアクセスにはバッファを優先：

```hemlock
let buf = buffer(256);

// 安全な反復
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

free(buf);
```

### パターン：try/finallyによるリソース管理

エラー時もクリーンアップを確実に：

```hemlock
let data = alloc(1024);
try {
    // ... 危険な操作
    process(data);
} finally {
    free(data);  // エラー時も常に解放
}
```

## メモリ安全性の考慮事項

### 二重解放

**許可されるがクラッシュする：**
```hemlock
let p = alloc(100);
free(p);
free(p);  // クラッシュ：二重解放を検出
```

**防止策：**
```hemlock
let p = alloc(100);
free(p);
p = null;  // 解放後にnullを設定

if (p != null) {
    free(p);  // 実行されない
}
```

### ダングリングポインタ

**許可されるが未定義動作：**
```hemlock
let p = alloc(100);
*p = 42;      // OK
free(p);
let x = *p;   // 未定義：解放されたメモリを読み取り
```

**防止策：** 解放後のメモリにアクセスしない。

### メモリリーク

**作成しやすく、デバッグしにくい：**
```hemlock
fn leak_memory() {
    let p = alloc(1000);
    // 解放を忘れた！
    return;  // メモリがリーク
}
```

**防止策：** 常に`alloc()`と`free()`をペアにする：
```hemlock
fn safe_function() {
    let p = alloc(1000);
    try {
        // ... pを使用
    } finally {
        free(p);  // 常に解放
    }
}
```

### ポインタ演算

**許可されるが危険：**
```hemlock
let p = alloc(10);
let q = p + 100;  // 割り当て境界をはるかに超えている
*q = 42;          // 未定義：範囲外の書き込み
free(p);
```

**境界チェックにはバッファを使用：**
```hemlock
let buf = buffer(10);
buf[100] = 42;  // エラー：境界チェックがオーバーフローを防止
```

## ベストプラクティス

1. **デフォルトで`buffer`** - 特に生の`ptr`が必要でない限り`buffer`を使用
2. **alloc/freeをマッチ** - すべての`alloc()`には正確に1つの`free()`
3. **try/finallyを使用** - 例外処理でクリーンアップを確実に
4. **解放後にnull** - use-after-freeをキャッチするために解放後にポインタをnullに設定
5. **境界チェック** - 自動境界チェックにはバッファのインデックスを使用
6. **所有権を文書化** - どのコードが各割り当てを所有し解放するかを明確に

## 例

### 例：動的文字列ビルダー

```hemlock
fn build_message(count: i32): ptr {
    let size = count * 10;
    let buf = alloc(size);

    let i = 0;
    while (i < count) {
        memset(buf + (i * 10), 65 + i, 10);
        i = i + 1;
    }

    return buf;  // 呼び出し元が解放する必要がある
}

let msg = build_message(5);
// ... msgを使用
free(msg);
```

### 例：安全な配列操作

```hemlock
fn process_array(size: i32) {
    let arr = buffer(size);

    try {
        // 配列を埋める
        let i = 0;
        while (i < arr.length) {
            arr[i] = i * 2;
            i = i + 1;
        }

        // 処理
        i = 0;
        while (i < arr.length) {
            print(arr[i]);
            i = i + 1;
        }
    } finally {
        free(arr);  // 常にクリーンアップ
    }
}
```

### 例：メモリプールパターン

```hemlock
// シンプルなメモリプール（簡略化）
let pool = alloc(10000);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > 10000) {
        throw "Pool exhausted";
    }

    let ptr = pool + pool_offset;
    pool_offset = pool_offset + size;
    return ptr;
}

// プールを使用
let p1 = pool_alloc(100);
let p2 = pool_alloc(200);

// プール全体を一度に解放
free(pool);
```

## 制限事項

注意すべき現在の制限事項：

- **生のポインタは手動解放が必要** - `alloc()`は参照カウントのない`ptr`を返す
- **カスタムアロケータなし** - システムのmalloc/freeのみ

**注意：** 参照カウント型（string、array、object、buffer）はスコープを抜けると自動的に解放されます。`alloc()`からの生の`ptr`のみ明示的な`free()`が必要です。

## 関連トピック

- [文字列](strings.md) - 文字列のメモリ管理とUTF-8エンコーディング
- [配列](arrays.md) - 動的配列とそのメモリ特性
- [オブジェクト](objects.md) - オブジェクトの割り当てと寿命
- [エラーハンドリング](error-handling.md) - クリーンアップにtry/finallyを使用

## 参照

- **設計思想**: CLAUDE.mdの「Memory Management」セクションを参照
- **型システム**: `ptr`と`buffer`型の詳細は[型](types.md)を参照
- **FFI**: 生のポインタは外部関数インターフェースに不可欠
