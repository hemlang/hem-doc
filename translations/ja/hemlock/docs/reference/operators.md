# 演算子リファレンス

Hemlockのすべての演算子の完全なリファレンスです。優先順位、結合性、動作を含みます。

---

## 概要

HemlockはCスタイルの演算子と明示的な優先順位規則を提供します。すべての演算子は厳密な型付け規則に従い、適用可能な場合は自動型昇格が行われます。

---

## 算術演算子

### 二項算術

| 演算子 | 名前 | 例 | 説明 |
|----------|----------------|------------|------------------------------|
| `+`      | 加算 | `a + b`    | 2つの値を加算 |
| `-`      | 減算 | `a - b`    | aからbを減算 |
| `*`      | 乗算 | `a * b`    | 2つの値を乗算 |
| `/`      | 除算 | `a / b`    | aをbで除算 |

**型昇格：**
結果は型昇格規則に従います（[型システム](type-system.md#型昇格規則)を参照）。

**例：**
```hemlock
let a = 10 + 5;        // 15 (i32)
let b = 10 - 3;        // 7 (i32)
let c = 4 * 5;         // 20 (i32)
let d = 20 / 4;        // 5 (i32)

// 浮動小数点除算
let e = 10.0 / 3.0;    // 3.333... (f64)

// 混合型
let f: u8 = 10;
let g: i32 = 20;
let h = f + g;         // 30 (i32, 昇格される)
```

**ゼロ除算：**
- 整数のゼロ除算：実行時エラー
- 浮動小数点のゼロ除算：`inf`または`-inf`を返す

---

### 単項算術

| 演算子 | 名前 | 例 | 説明 |
|----------|----------|---------|----------------------|
| `-`      | 否定 | `-a`    | 値を否定 |
| `+`      | プラス | `+a`    | 恒等（何もしない） |

**例：**
```hemlock
let a = 5;
let b = -a;            // -5
let c = +a;            // 5（変更なし）

let x = -3.14;         // -3.14
```

---

## 比較演算子

| 演算子 | 名前 | 例 | 戻り値 |
|----------|-----------------------|------------|---------|
| `==`     | 等しい | `a == b`   | `bool`  |
| `!=`     | 等しくない | `a != b`   | `bool`  |
| `<`      | より小さい | `a < b`    | `bool`  |
| `>`      | より大きい | `a > b`    | `bool`  |
| `<=`     | 以下 | `a <= b`   | `bool`  |
| `>=`     | 以上 | `a >= b`   | `bool`  |

**型昇格：**
比較前にオペランドが昇格されます。

**例：**
```hemlock
print(5 == 5);         // true
print(10 != 5);        // true
print(3 < 7);          // true
print(10 > 5);         // true
print(5 <= 5);         // true
print(10 >= 5);        // true

// 文字列比較
print("hello" == "hello");  // true
print("abc" < "def");       // true（辞書順）

// 混合型
let a: u8 = 10;
let b: i32 = 10;
print(a == b);         // true（i32に昇格）
```

---

## 論理演算子

| 演算子 | 名前 | 例 | 説明 |
|----------|-------------|--------------|--------------------------|
| `&&`     | 論理AND | `a && b`     | 両方がtrueならtrue |
| `\|\|`   | 論理OR | `a \|\| b`   | どちらかがtrueならtrue |
| `!`      | 論理NOT | `!a`         | ブーリアンを否定 |

**短絡評価：**
- `&&` - 最初のfalse値で停止
- `||` - 最初のtrue値で停止

**例：**
```hemlock
let a = true;
let b = false;

print(a && b);         // false
print(a || b);         // true
print(!a);             // false
print(!b);             // true

// 短絡
if (x != 0 && (10 / x) > 2) {
    print("safe");
}

if (x == 0 || (10 / x) > 2) {
    print("safe");
}
```

---

## ビット演算子

**制限：** 整数型のみ（i8-i64、u8-u64）

### 二項ビット演算

| 演算子 | 名前 | 例 | 説明 |
|----------|--------------|------------|--------------------------|
| `&`      | ビットAND | `a & b`    | 各ビットをAND |
| `\|`     | ビットOR | `a \| b`   | 各ビットをOR |
| `^`      | ビットXOR | `a ^ b`    | 各ビットをXOR |
| `<<`     | 左シフト | `a << b`   | bビット左にシフト |
| `>>`     | 右シフト | `a >> b`   | bビット右にシフト |

**型保持：**
結果の型はオペランドの型に一致（型昇格あり）。

**例：**
```hemlock
let a = 12;  // 2進数で1100
let b = 10;  // 2進数で1010

print(a & b);          // 8  (1000)
print(a | b);          // 14 (1110)
print(a ^ b);          // 6  (0110)
print(a << 2);         // 48 (110000)
print(a >> 1);         // 6  (110)
```

**符号なしの例：**
```hemlock
let c: u8 = 15;        // 00001111
let d: u8 = 7;         // 00000111

print(c & d);          // 7  (00000111)
print(c | d);          // 15 (00001111)
print(c ^ d);          // 8  (00001000)
```

**右シフトの動作：**
- 符号付き型：算術シフト（符号拡張）
- 符号なし型：論理シフト（ゼロ埋め）

---

### 単項ビット演算

| 演算子 | 名前 | 例 | 説明 |
|----------|-------------|---------|--------------------------|
| `~`      | ビットNOT | `~a`    | すべてのビットを反転 |

**例：**
```hemlock
let a = 12;            // 00001100 (i32)
print(~a);             // -13（2の補数）

let b: u8 = 15;        // 00001111
print(~b);             // 240 (11110000)
```

---

## 文字列演算子

### 連結

| 演算子 | 名前 | 例 | 説明 |
|----------|----------------|------------|--------------------|
| `+`      | 連結 | `a + b`    | 文字列を結合 |

**例：**
```hemlock
let s = "hello" + " " + "world";  // "hello world"
let msg = "Count: " + typeof(42); // "Count: 42"

// 文字列 + rune
let greeting = "Hello" + '!';      // "Hello!"

// rune + 文字列
let prefix = '>' + " Message";     // "> Message"
```

---

## 代入演算子

### 基本代入

| 演算子 | 名前 | 例 | 説明 |
|----------|------------|------------|--------------------------|
| `=`      | 代入 | `a = b`    | 変数に値を代入 |

**例：**
```hemlock
let x = 10;
x = 20;

let arr = [1, 2, 3];
arr[0] = 99;

let obj = { x: 10 };
obj.x = 20;
```

### 複合代入

#### 算術複合代入

| 演算子 | 名前 | 例 | 等価 |
|----------|-----------------|------------|--------------------|
| `+=`     | 加算代入 | `a += b`   | `a = a + b`        |
| `-=`     | 減算代入 | `a -= b`   | `a = a - b`        |
| `*=`     | 乗算代入 | `a *= b`   | `a = a * b`        |
| `/=`     | 除算代入 | `a /= b`   | `a = a / b`        |
| `%=`     | 剰余代入 | `a %= b`   | `a = a % b`        |

**例：**
```hemlock
let x = 10;
x += 5;      // xは15になる
x -= 3;      // xは12になる
x *= 2;      // xは24になる
x /= 4;      // xは6になる

let count = 0;
count += 1;  // 1ずつインクリメント
```

#### ビット複合代入

| 演算子 | 名前 | 例 | 等価 |
|----------|--------------------|-------------|---------------------|
| `&=`     | ビットAND代入 | `a &= b`    | `a = a & b`         |
| `\|=`    | ビットOR代入 | `a \|= b`   | `a = a \| b`        |
| `^=`     | ビットXOR代入 | `a ^= b`    | `a = a ^ b`         |
| `<<=`    | 左シフト代入 | `a <<= b`   | `a = a << b`        |
| `>>=`    | 右シフト代入 | `a >>= b`   | `a = a >> b`        |

**例：**
```hemlock
let flags = 0b1111;
flags &= 0b0011;   // flagsは0b0011になる（上位ビットをマスク）
flags |= 0b1000;   // flagsは0b1011になる（ビットをセット）
flags ^= 0b0001;   // flagsは0b1010になる（ビットをトグル）

let x = 1;
x <<= 4;           // xは16になる（4ビット左シフト）
x >>= 2;           // xは4になる（2ビット右シフト）
```

### インクリメント/デクリメント

| 演算子 | 名前 | 例 | 説明 |
|----------|------------|---------|--------------------------|
| `++`     | インクリメント | `a++`   | 1ずつインクリメント（後置） |
| `--`     | デクリメント | `a--`   | 1ずつデクリメント（後置） |

**例：**
```hemlock
let i = 0;
i++;         // iは1になる
i++;         // iは2になる
i--;         // iは1になる

// ループでよく使用
for (let j = 0; j < 10; j++) {
    print(j);
}
```

**注意：** `++`と`--`は両方とも後置演算子です（値はインクリメント/デクリメント前に返される）

---

## Null安全演算子

### Null合体（`??`）

左オペランドがnullでなければそれを返し、そうでなければ右オペランドを返します。

| 演算子 | 名前 | 例 | 説明 |
|----------|------------------|--------------|--------------------------------|
| `??`     | Null合体 | `a ?? b`     | aがnullでなければa、そうでなければb |

**例：**
```hemlock
let name = null;
let display = name ?? "Anonymous";  // "Anonymous"

let value = 42;
let result = value ?? 0;            // 42

// チェーン
let a = null;
let b = null;
let c = "found";
let result2 = a ?? b ?? c;          // "found"

// 関数呼び出しとともに
fn get_config() { return null; }
let config = get_config() ?? { default: true };
```

---

### オプショナルチェーン（`?.`）

潜在的にnullの値のプロパティやメソッドに安全にアクセスします。

| 演算子 | 名前 | 例 | 説明 |
|----------|-------------------|----------------|----------------------------------|
| `?.`     | オプショナルチェーン | `a?.b`         | aがnullでなければa.b、そうでなければnull |
| `?.[`    | オプショナルインデックス | `a?.[0]`       | aがnullでなければa[0]、そうでなければnull |
| `?.(`    | オプショナル呼び出し | `a?.()`        | aがnullでなければa()を呼び出し、そうでなければnull |

**例：**
```hemlock
let user = null;
let name = user?.name;              // null（エラーなし）

let person = { name: "Alice", address: null };
let city = person?.address?.city;   // null（安全なナビゲーション）

// 配列とともに
let arr = null;
let first = arr?.[0];               // null

let items = [1, 2, 3];
let second = items?.[1];            // 2

// メソッド呼び出しとともに
let obj = { greet: fn() { return "Hello"; } };
let greeting = obj?.greet?.();      // "Hello"

let empty = null;
let result = empty?.method?.();     // null
```

**動作：**
- 左オペランドがnullの場合、式全体がnullに短絡
- 左オペランドがnullでない場合、通常通りアクセス
- 深いプロパティアクセスのためにチェーン可能

---

## メンバーアクセス演算子

### ドット演算子

| 演算子 | 名前 | 例 | 説明 |
|----------|------------------|--------------|-----------------------|
| `.`      | メンバーアクセス | `obj.field`  | オブジェクトフィールドにアクセス |
| `.`      | プロパティアクセス | `arr.length` | プロパティにアクセス |

**例：**
```hemlock
// オブジェクトフィールドアクセス
let person = { name: "Alice", age: 30 };
print(person.name);        // "Alice"

// 配列プロパティ
let arr = [1, 2, 3];
print(arr.length);         // 3

// 文字列プロパティ
let s = "hello";
print(s.length);           // 5

// メソッド呼び出し
let result = s.to_upper(); // "HELLO"
```

---

### インデックス演算子

| 演算子 | 名前 | 例 | 説明 |
|----------|---------|-----------|----------------------|
| `[]`     | インデックス | `arr[i]`  | 要素にアクセス |

**例：**
```hemlock
// 配列インデックス
let arr = [10, 20, 30];
print(arr[0]);             // 10
arr[1] = 99;

// 文字列インデックス（runeを返す）
let s = "hello";
print(s[0]);               // 'h'
s[0] = 'H';                // "Hello"

// バッファインデックス
let buf = buffer(10);
buf[0] = 65;
print(buf[0]);             // 65
```

---

## 関数呼び出し演算子

| 演算子 | 名前 | 例 | 説明 |
|----------|---------------|--------------|--------------------|
| `()`     | 関数呼び出し | `f(a, b)`    | 関数を呼び出し |

**例：**
```hemlock
fn add(a, b) {
    return a + b;
}

let result = add(5, 3);    // 8

// メソッド呼び出し
let s = "hello";
let upper = s.to_upper();  // "HELLO"

// ビルトイン呼び出し
print("message");
```

---

## 演算子優先順位

演算子は高い優先順位から低い優先順位の順にリストされています：

| 優先順位 | 演算子 | 説明 | 結合性 |
|------------|----------------------------|--------------------------------|---------------|
| 1          | `()` `[]` `.` `?.`         | 呼び出し、インデックス、メンバーアクセス、オプショナルチェーン | 左から右 |
| 2          | `++` `--`                  | 後置インクリメント/デクリメント | 左から右 |
| 3          | `!` `~` `-`（単項）`+`（単項） | 論理NOT、ビットNOT、否定 | 右から左 |
| 4          | `*` `/` `%`                | 乗算、除算、剰余 | 左から右 |
| 5          | `+` `-`                    | 加算、減算 | 左から右 |
| 6          | `<<` `>>`                  | ビットシフト | 左から右 |
| 7          | `<` `<=` `>` `>=`          | 関係 | 左から右 |
| 8          | `==` `!=`                  | 等価 | 左から右 |
| 9          | `&`                        | ビットAND | 左から右 |
| 10         | `^`                        | ビットXOR | 左から右 |
| 11         | `\|`                       | ビットOR | 左から右 |
| 12         | `&&`                       | 論理AND | 左から右 |
| 13         | `\|\|`                     | 論理OR | 左から右 |
| 14         | `??`                       | Null合体 | 左から右 |
| 15         | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\|=` `^=` `<<=` `>>=` | 代入 | 右から左 |

---

## 優先順位の例

### 例1：算術と比較
```hemlock
let result = 5 + 3 * 2;
// 評価：5 + (3 * 2) = 11
// 乗算は加算より優先順位が高い

let cmp = 10 > 5 + 3;
// 評価：10 > (5 + 3) = true
// 加算は比較より優先順位が高い
```

### 例2：ビット演算子
```hemlock
let result1 = 12 | 10 & 8;
// 評価：12 | (10 & 8) = 12 | 8 = 12
// &は|より優先順位が高い

let result2 = 8 | 1 << 2;
// 評価：8 | (1 << 2) = 8 | 4 = 12
// シフトはビットORより優先順位が高い

// 明確にするために括弧を使用
let result3 = (5 & 3) | (2 << 1);
// 評価：1 | 4 = 5
```

### 例3：論理演算子
```hemlock
let result = true || false && false;
// 評価：true || (false && false) = true
// &&は||より優先順位が高い

let cmp = 5 < 10 && 10 < 20;
// 評価：(5 < 10) && (10 < 20) = true
// 比較は&&より優先順位が高い
```

### 例4：括弧の使用
```hemlock
// 括弧なし
let a = 2 + 3 * 4;        // 14

// 括弧あり
let b = (2 + 3) * 4;      // 20

// 複雑な式
let c = (a + b) * (a - b);
```

---

## 型固有の演算子動作

### 除算（常にFloat）

`/`演算子はオペランドの型に関係なく**常にfloat**（f64）を返します：

```hemlock
print(10 / 3);             // 3.333... (f64)
print(5 / 2);              // 2.5 (f64)
print(10.0 / 4.0);         // 2.5 (f64)
print(-7 / 3);             // -2.333... (f64)
```

これは予期しない整数切り詰めの一般的なバグを防ぎます。

### フロア除算（div / divi）

フロア除算（他の言語の整数除算のような）には、`div()`と`divi()`関数を使用します：

```hemlock
// div(a, b) - floatを返すフロア除算
print(div(5, 2));          // 2 (f64)
print(div(-7, 3));         // -3 (f64)  -- -無限大に向かって切り捨て

// divi(a, b) - 整数を返すフロア除算
print(divi(5, 2));         // 2 (i64)
print(divi(-7, 3));        // -3 (i64)
print(typeof(divi(5, 2))); // i64
```

**整数を返す数学関数：**
整数を返す他の丸め操作：

```hemlock
print(floori(3.7));        // 3 (i64)
print(ceili(3.2));         // 4 (i64)
print(roundi(3.5));        // 4 (i64)
print(trunci(3.9));        // 3 (i64)

// 配列インデックスとして直接使用可能
let arr = [10, 20, 30, 40];
print(arr[floori(1.9)]);   // 20（インデックス1）
```

### 文字列比較

文字列は辞書順で比較されます：

```hemlock
print("abc" < "def");      // true
print("apple" > "banana"); // false
print("hello" == "hello"); // true
```

### Null比較

```hemlock
let x = null;

print(x == null);          // true
print(x != null);          // false
```

### 型エラー

互換性のない型間の一部の操作は許可されません：

```hemlock
// エラー：floatにビット演算子は使用不可
let x = 3.14 & 2.71;

// エラー：文字列にビット演算子は使用不可
let y = "hello" & "world";

// OK：算術の型昇格
let a: u8 = 10;
let b: i32 = 20;
let c = a + b;             // i32（昇格される）
```

---

## 関連項目

- [型システム](type-system.md) - 型昇格と変換規則
- [組み込み関数](builtins.md) - 組み込み操作
- [文字列API](string-api.md) - 文字列連結とメソッド
