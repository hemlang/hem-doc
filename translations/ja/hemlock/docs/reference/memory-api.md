# メモリAPIリファレンス

Hemlockのメモリ管理関数とポインタ型の完全なリファレンスです。

---

## 概要

Hemlockは明示的な割り当てと解放による**手動メモリ管理**を提供します。メモリは2つのポインタ型で管理されます：生ポインタ（`ptr`）と安全なバッファ（`buffer`）。

**主な原則：**
- 明示的な割り当てと解放
- ガベージコレクションなし
- ユーザーが`free()`を呼び出す責任がある
- スコープ/再代入の安全性のための内部参照カウント（下記参照）

### 内部参照カウント

ランタイムはスコープを通じてオブジェクトのライフタイムを管理するために、内部的に参照カウントを使用します。ほとんどのローカル変数では、クリーンアップは自動的です。

**自動（`free()`不要）：**
- 参照カウント型（buffer、array、object、string）のローカル変数はスコープ終了時に解放される
- 変数が再代入されると古い値が解放される
- コンテナが解放されるとコンテナ要素が解放される

**手動`free()`が必要：**
- `alloc()`からの生ポインタ - 常に
- スコープ終了前の早期クリーンアップ
- 長寿命/グローバルデータ

詳細は[メモリ管理ガイド](../language-guide/memory.md#内部参照カウント)を参照してください。

---

## ポインタ型

### ptr（生ポインタ）

**型：** `ptr`

**説明：** 境界チェックや追跡なしの生メモリアドレス。

**サイズ：** 8バイト

**使用ケース：**
- 低レベルメモリ操作
- FFI（外部関数インターフェース）
- 最大パフォーマンス（オーバーヘッドなし）

**安全性：** 安全でない - 境界チェックなし、ユーザーがライフタイムを追跡する必要がある

**例：**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

---

### buffer（安全なバッファ）

**型：** `buffer`

**説明：** 境界チェック付きの安全なポインタラッパー。

**構造：** ポインタ + 長さ + 容量 + 参照カウント

**プロパティ：**
- `.length` - バッファサイズ（i32）
- `.capacity` - 割り当て容量（i32）

**使用ケース：**
- ほとんどのメモリ割り当て
- 安全性が重要な場合
- 動的配列

**安全性：** インデックスアクセス時に境界チェック

**参照カウント：** バッファは内部的に参照カウントされます。スコープ終了時または変数再代入時に自動的に解放されます。早期クリーンアップや長寿命データには`free()`を使用してください。

**例：**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // 境界チェックあり
print(b.length);        // 64
free(b);
```

---

## メモリ割り当て関数

### alloc

生メモリを割り当てます。

**シグネチャ：**
```hemlock
alloc(size: i32): ptr
```

**パラメータ：**
- `size` - 割り当てるバイト数

**戻り値：** 割り当てられたメモリへのポインタ（`ptr`）

**例：**
```hemlock
let p = alloc(1024);        // 1KBを割り当て
memset(p, 0, 1024);         // ゼロで初期化
free(p);                    // 終了時に解放

// 構造体用に割り当て
let struct_size = 16;
let p2 = alloc(struct_size);
```

**動作：**
- 初期化されていないメモリを返す
- メモリは手動で解放する必要がある
- 割り当て失敗時は`null`を返す（呼び出し側でチェックが必要）

**関連項目：** より安全な代替として`buffer()`

---

### buffer

境界チェック付きの安全なバッファを割り当てます。

**シグネチャ：**
```hemlock
buffer(size: i32): buffer
```

**パラメータ：**
- `size` - バイト単位のバッファサイズ

**戻り値：** バッファオブジェクト

**例：**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256
print(buf.capacity);        // 256

// 境界チェック付きアクセス
buf[0] = 65;                // 'A'
buf[255] = 90;              // 'Z'
// buf[256] = 0;            // エラー：範囲外

free(buf);
```

**プロパティ：**
- `.length` - 現在のサイズ（i32）
- `.capacity` - 割り当て容量（i32）

**動作：**
- メモリをゼロで初期化
- インデックスアクセス時に境界チェックを提供
- 割り当て失敗時は`null`を返す（呼び出し側でチェックが必要）
- 手動で解放する必要がある

---

### free

割り当てられたメモリを解放します。

**シグネチャ：**
```hemlock
free(ptr: ptr | buffer): null
```

**パラメータ：**
- `ptr` - 解放するポインタまたはバッファ

**戻り値：** `null`

**例：**
```hemlock
// 生ポインタを解放
let p = alloc(1024);
free(p);

// バッファを解放
let buf = buffer(256);
free(buf);
```

**動作：**
- `alloc()`または`buffer()`で割り当てられたメモリを解放
- 二重解放はクラッシュを引き起こす（ユーザーの責任で回避）
- 無効なポインタの解放は未定義動作

**重要：** 割り当てたら、解放する。自動クリーンアップなし。

---

### realloc

割り当てられたメモリのサイズを変更します。

**シグネチャ：**
```hemlock
realloc(ptr: ptr, new_size: i32): ptr
```

**パラメータ：**
- `ptr` - サイズ変更するポインタ
- `new_size` - バイト単位の新しいサイズ

**戻り値：** サイズ変更されたメモリへのポインタ（アドレスが異なる場合がある）

**例：**
```hemlock
let p = alloc(100);
// ... メモリを使用 ...

// より多くの領域が必要
p = realloc(p, 200);        // 200バイトになった
// ... 拡張されたメモリを使用 ...

free(p);
```

**動作：**
- メモリを新しい場所に移動する場合がある
- 既存データを保持（古い/新しいサイズの最小まで）
- 成功したreallocの後は古いポインタは無効（返されたポインタを使用）
- new_sizeが小さい場合、データは切り詰められる
- 割り当て失敗時は`null`を返す（元のポインタは有効なまま）

**重要：** 常に`null`をチェックし、結果でポインタ変数を更新してください。

---

## メモリ操作

### memset

メモリをバイト値で埋めます。

**シグネチャ：**
```hemlock
memset(ptr: ptr, byte: i32, size: i32): null
```

**パラメータ：**
- `ptr` - メモリへのポインタ
- `byte` - 埋めるバイト値（0-255）
- `size` - 埋めるバイト数

**戻り値：** `null`

**例：**
```hemlock
let p = alloc(100);

// メモリをゼロクリア
memset(p, 0, 100);

// 特定の値で埋める
memset(p, 0xFF, 100);

// バッファを初期化
let buf = alloc(256);
memset(buf, 65, 256);       // 'A'で埋める

free(p);
free(buf);
```

**動作：**
- 範囲内の各バイトにバイト値を書き込む
- バイト値は8ビット（0-255）に切り詰められる
- 境界チェックなし（安全でない）

---

### memcpy

ソースからデスティネーションにメモリをコピーします。

**シグネチャ：**
```hemlock
memcpy(dest: ptr, src: ptr, size: i32): null
```

**パラメータ：**
- `dest` - デスティネーションポインタ
- `src` - ソースポインタ
- `size` - コピーするバイト数

**戻り値：** `null`

**例：**
```hemlock
let src = alloc(100);
let dest = alloc(100);

// ソースを初期化
memset(src, 65, 100);

// デスティネーションにコピー
memcpy(dest, src, 100);

// destはsrcと同じデータを含む

free(src);
free(dest);
```

**動作：**
- srcからdestへバイト単位でコピー
- 境界チェックなし（安全でない）
- オーバーラップする領域は未定義動作（慎重に使用）

---

## 型付きメモリ操作

### sizeof

型のバイト数を取得します。

**シグネチャ：**
```hemlock
sizeof(type): i32
```

**パラメータ：**
- `type` - 型識別子（例：`i32`、`f64`、`ptr`）

**戻り値：** バイト数（i32）

**型サイズ：**

| 型 | サイズ（バイト） |
|------|--------------|
| `i8` | 1 |
| `i16` | 2 |
| `i32`, `integer` | 4 |
| `i64` | 8 |
| `u8`, `byte` | 1 |
| `u16` | 2 |
| `u32` | 4 |
| `u64` | 8 |
| `f32` | 4 |
| `f64`, `number` | 8 |
| `bool` | 1 |
| `ptr` | 8 |
| `rune` | 4 |

**例：**
```hemlock
let int_size = sizeof(i32);      // 4
let ptr_size = sizeof(ptr);      // 8
let float_size = sizeof(f64);    // 8
let byte_size = sizeof(u8);      // 1
let rune_size = sizeof(rune);    // 4

// 配列割り当てサイズを計算
let count = 100;
let total = sizeof(i32) * count; // 400バイト
```

**動作：**
- 不明な型には0を返す
- 型識別子と型文字列の両方を受け付ける

---

### talloc

型付き値の配列を割り当てます。

**シグネチャ：**
```hemlock
talloc(type, count: i32): ptr
```

**パラメータ：**
- `type` - 割り当てる型（例：`i32`、`f64`、`ptr`）
- `count` - 要素数（正の数である必要がある）

**戻り値：** 割り当てられた配列へのポインタ、割り当て失敗時は`null`

**例：**
```hemlock
let arr = talloc(i32, 100);      // 100個のi32の配列（400バイト）
let floats = talloc(f64, 50);    // 50個のf64の配列（400バイト）
let bytes = talloc(u8, 1024);    // 1024バイトの配列

// 常に割り当て失敗をチェック
if (arr == null) {
    panic("allocation failed");
}

// 割り当てられたメモリを使用
// ...

free(arr);
free(floats);
free(bytes);
```

**動作：**
- `sizeof(type) * count`バイトを割り当て
- 初期化されていないメモリを返す
- `free()`で手動解放が必要
- 割り当て失敗時は`null`を返す（呼び出し側でチェックが必要）
- countが正でない場合はパニック

---

## バッファプロパティ

### .length

バッファサイズを取得します。

**型：** `i32`

**アクセス：** 読み取り専用

**例：**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256

let buf2 = buffer(1024);
print(buf2.length);         // 1024
```

---

### .capacity

バッファ容量を取得します。

**型：** `i32`

**アクセス：** 読み取り専用

**例：**
```hemlock
let buf = buffer(256);
print(buf.capacity);        // 256
```

**注意：** 現在、`buffer()`で作成されたバッファでは`.length`と`.capacity`は同じです。

---

## 使用パターン

### 基本的な割り当てパターン

```hemlock
// 割り当て
let p = alloc(1024);
if (p == null) {
    panic("allocation failed");
}

// 使用
memset(p, 0, 1024);

// 解放
free(p);
```

### 安全なバッファパターン

```hemlock
// バッファを割り当て
let buf = buffer(256);
if (buf == null) {
    panic("buffer allocation failed");
}

// 境界チェック付きで使用
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

// 解放
free(buf);
```

### 動的拡張パターン

```hemlock
let size = 100;
let p = alloc(size);
if (p == null) {
    panic("allocation failed");
}

// ... メモリを使用 ...

// より多くの領域が必要 - 失敗をチェック
let new_p = realloc(p, 200);
if (new_p == null) {
    // 元のポインタはまだ有効、クリーンアップ
    free(p);
    panic("realloc failed");
}
p = new_p;
size = 200;

// ... 拡張されたメモリを使用 ...

free(p);
```

### メモリコピーパターン

```hemlock
let original = alloc(100);
memset(original, 65, 100);

// コピーを作成
let copy = alloc(100);
memcpy(copy, original, 100);

free(original);
free(copy);
```

---

## 安全性に関する考慮事項

**Hemlockのメモリ管理は設計上安全ではありません：**

### よくある落とし穴

**1. メモリリーク**
```hemlock
// 悪い例：メモリリーク
fn create_buffer() {
    let p = alloc(1024);
    return null;  // メモリがリーク！
}

// 良い例：適切なクリーンアップ
fn create_buffer() {
    let p = alloc(1024);
    // ... メモリを使用 ...
    free(p);
    return null;
}
```

**2. 解放後使用**
```hemlock
// 悪い例：解放後使用
let p = alloc(100);
free(p);
memset(p, 0, 100);  // クラッシュ：解放済みメモリを使用

// 良い例：解放後は使用しない
let p2 = alloc(100);
memset(p2, 0, 100);
free(p2);
// この後p2に触れない
```

**3. 二重解放**
```hemlock
// 悪い例：二重解放
let p = alloc(100);
free(p);
free(p);  // クラッシュ：二重解放

// 良い例：一度だけ解放
let p2 = alloc(100);
free(p2);
```

**4. バッファオーバーフロー（ptr）**
```hemlock
// 悪い例：ptrでのバッファオーバーフロー
let p = alloc(10);
memset(p, 65, 100);  // クラッシュ：割り当てを超えて書き込み

// 良い例：境界チェックにはbufferを使用
let buf = buffer(10);
// buf[100] = 65;  // エラー：境界チェックが失敗
```

**5. ダングリングポインタ**
```hemlock
// 悪い例：ダングリングポインタ
let p1 = alloc(100);
let p2 = p1;
free(p1);
memset(p2, 0, 100);  // クラッシュ：p2はダングリング

// 良い例：所有権を慎重に追跡
let p = alloc(100);
// ... pを使用 ...
free(p);
// pへの他の参照を保持しない
```

**6. 割り当て失敗のチェック漏れ**
```hemlock
// 悪い例：nullをチェックしない
let p = alloc(1000000000);  // メモリ不足で失敗する可能性
memset(p, 0, 1000000000);   // クラッシュ：pがnull

// 良い例：常に割り当て結果をチェック
let p2 = alloc(1000000000);
if (p2 == null) {
    panic("out of memory");
}
memset(p2, 0, 1000000000);
free(p2);
```

---

## 何をいつ使うか

### `buffer()`を使用する場合：
- 境界チェックが必要な場合
- 動的データを扱う場合
- 安全性が重要な場合
- Hemlockを学習中の場合

### `alloc()`を使用する場合：
- 最大パフォーマンスが必要な場合
- FFI/Cとのインターフェース
- 正確なメモリレイアウトを知っている場合
- エキスパートの場合

### `realloc()`を使用する場合：
- 割り当てを拡大/縮小する場合
- 動的配列
- データを保持する必要がある場合

---

## 完全な関数要約

| 関数 | シグネチャ | 戻り値 | 説明 |
|-----------|----------------------------------------|----------|----------------------------|
| `alloc`   | `(size: i32)`                          | `ptr`    | 生メモリを割り当て |
| `buffer`  | `(size: i32)`                          | `buffer` | 安全なバッファを割り当て |
| `free`    | `(ptr: ptr \| buffer)`                 | `null`   | メモリを解放 |
| `realloc` | `(ptr: ptr, new_size: i32)`            | `ptr`    | 割り当てサイズを変更 |
| `memset`  | `(ptr: ptr, byte: i32, size: i32)`     | `null`   | メモリを埋める |
| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`     | `null`   | メモリをコピー |
| `sizeof`  | `(type)`                               | `i32`    | 型のバイトサイズを取得 |
| `talloc`  | `(type, count: i32)`                   | `ptr`    | 型付き配列を割り当て |

---

## 関連項目

- [型システム](type-system.md) - ポインタとバッファ型
- [組み込み関数](builtins.md) - すべての組み込み関数
- [文字列API](string-api.md) - 文字列の`.to_bytes()`メソッド
