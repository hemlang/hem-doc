# Hemlock言語設計哲学

> 「安全でないものを安全に書くための、小さな安全でない言語。」

このドキュメントは、Hemlockの核となる設計原則と哲学を説明します。言語に変更や追加を行う前に、まずこれをお読みください。

---

## 目次

- [コアアイデンティティ](#コアアイデンティティ)
- [設計原則](#設計原則)
- [安全性に関する哲学](#安全性に関する哲学)
- [追加すべきでないもの](#追加すべきでないもの)
- [将来の検討事項](#将来の検討事項)
- [最終的な考え](#最終的な考え)

---

## コアアイデンティティ

Hemlockは、手動メモリ管理と明示的な制御を採用した**システムスクリプト言語**です。以下を求めるプログラマー向けに設計されています:

- Cの力
- 現代的なスクリプト言語の人間工学
- 組み込みの構造化非同期並行処理
- 隠された動作や魔法なし

### HemlockでないもNOT

- **メモリセーフ**（ダングリングポインタはあなたの責任）
- **Rust、Go、Luaの代替**
- **複雑さを隠す言語**

### Hemlockであるもの

- **常に暗黙より明示**
- **教育的かつ実験的**
- **システム作業のための「Cスクリプト層」**
- **トレードオフについて正直**

---

## 設計原則

### 1. 暗黙より明示

Hemlockはすべての言語構文で明示性を重視します。驚き、魔法、隠された動作があってはなりません。

**悪い例（暗黙）:**
```hemlock
let x = 5  // セミコロンがない - エラーになるべき
```

**良い例（明示）:**
```hemlock
let x = 5;
free(ptr);  // あなたが割り当てたなら、あなたが解放する
```

**重要な側面:**
- セミコロンは必須（自動セミコロン挿入なし）
- ガベージコレクションなし
- 手動メモリ管理（alloc/free）
- 型注釈はオプションだが、実行時にチェックされる
- 自動リソースクリーンアップなし（RAIIなし）、ただし`defer`が明示的なクリーンアップを提供

### 2. デフォルトで動的、選択で型付き

すべての値はランタイム型タグを持ちますが、システムは柔軟でありながらエラーをキャッチするように設計されています。

**型推論:**
- 小さい整数（i32に収まる）: `42` → `i32`
- 大きい整数（> i32範囲）: `9223372036854775807` → `i64`
- 浮動小数点: `3.14` → `f64`

**必要に応じた明示的な型付け:**
```hemlock
let x = 42;              // i32推論（小さい値）
let y: u8 = 255;         // 明示的なu8
let z = x + y;           // i32にプロモート
let big = 5000000000;    // i64推論（> i32最大値）
```

**型プロモーション規則**は、最小から最大への明確な階層に従い、浮動小数点は常に整数に勝ちます。

### 3. 安全でないことは機能であり、バグではない

Hemlockはすべてのエラーを防ごうとはしません。代わりに、安全であるためのツールを提供しながら、必要に応じて安全でない動作を選択できるようにします。

**意図的な安全でなさの例:**
- ポインタ算術はオーバーフローする可能性がある（ユーザーの責任）
- 生の`ptr`に境界チェックなし（安全性が必要なら`buffer`を使用）
- ダブルフリーによるクラッシュは許可（手動メモリ管理）
- 型システムは事故を防ぐが、必要に応じて危険な操作も許可

```hemlock
let p = alloc(10);
let q = p + 100;  // 割り当てを大きく超えている - 許可されるが危険
```

**哲学:** 型システムは*事故*を防ぐべきだが、*意図的な*安全でない操作は許可すべき。

### 4. 構造化並行処理がファーストクラス

並行処理はHemlockにおいて後付けではありません。最初から言語に組み込まれています。

**主な機能:**
- `async`/`await`が言語に組み込み
- 通信用チャネル
- タスク管理のための`spawn`/`join`/`detach`
- 生スレッドなし、ロックなし - 構造化のみ
- POSIXスレッドを使用した真のマルチスレッド並列処理

**イベントループやグリーンスレッドではない** - Hemlockは複数のCPUコアにわたる真の並列処理のために実際のOSスレッドを使用します。

### 5. C風の構文、低セレモニー

Hemlockはシステムプログラマーにとって馴染みやすく、ボイラープレートを減らします。

**設計上の選択:**
- 常に`{}`ブロック、オプションの括弧なし
- 演算子はCと一致: `+`, `-`, `*`, `/`, `&&`, `||`, `!`
- 型構文はRust/TypeScriptと一致: `let x: type = value;`
- 関数はファーストクラスの値
- 最小限のキーワードと特殊形式

---

## 安全性に関する哲学

**Hemlockの安全性に対する見解:**

> 「安全であるためのツール（`buffer`、型注釈、境界チェック）を提供しますが、それらを使うことを強制しません（`ptr`、手動メモリ、安全でない操作）。
>
> デフォルトは安全に導くべきですが、エスケープハッチは常に利用可能であるべきです。」

### 提供される安全ツール

**1. 安全なbuffer型:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // 境界チェック付き
print(b.length);        // 64
free(b);                // それでも手動
```

**2. 安全でない生ポインタ:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // 解放を覚えておく必要がある
```

**3. 型注釈:**
```hemlock
let x: u8 = 255;   // OK
let y: u8 = 256;   // エラー: 範囲外
```

**4. ランタイム型チェック:**
```hemlock
let val = some_function();
if (typeof(val) == "i32") {
    // 整数として安全に使用できる
}
```

### 指針

1. **ドキュメントでは安全なパターンをデフォルトに** - `ptr`より先に`buffer`を示し、型注釈を推奨
2. **安全でない操作を明確に** - 生ポインタ算術は意図的に見えるべき
3. **エスケープハッチを提供** - 経験豊富なユーザーが低レベルの作業をすることを妨げない
4. **トレードオフについて正直に** - 何が問題になる可能性があるかをドキュメント化

### 安全 vs 安全でないの例

| 安全なパターン | 安全でないパターン | 安全でないを使うとき |
|-------------|----------------|-------------------|
| `buffer`型 | `ptr`型 | FFI、パフォーマンス重視のコード |
| 型注釈 | 注釈なし | 外部インターフェース、検証 |
| 境界チェック付きアクセス | ポインタ算術 | 低レベルメモリ操作 |
| 例外処理 | null/エラーコードを返す | 例外が重すぎる場合 |

---

## 追加すべきでないもの

何を追加し**ない**かを理解することは、何を追加するかを知ることと同じくらい重要です。

### ❌ 暗黙の動作を追加しない

**悪い例:**

```hemlock
// 悪い: 自動セミコロン挿入
let x = 5
let y = 10

// 悪い: 精度を失う暗黙の型変換
let x: i32 = 3.14  // 切り捨てるべき？エラーにすべき？
```

**理由:** 暗黙の動作は驚きを生み、コードの推論を難しくします。

### ❌ 複雑さを隠さない

**悪い例:**

```hemlock
// 悪い: 裏での魔法の最適化
let arr = [1, 2, 3]  // これはスタック？ヒープ？ユーザーは知るべき！（ヒープ、参照カウント）

// 悪い: 生ポインタの自動解放
let p = alloc(100)  // これは自動解放される？いいえ！生ptrは常にfree()が必要
```

**参照カウントについての注記:** Hemlockは文字列、配列、オブジェクト、バッファに内部参照カウントを使用しています - これらはスコープ終了時に自動解放されます。これは明示的で予測可能です（参照が0になると決定論的クリーンアップ、GCポーズなし）。生ポインタ（`alloc()`からの`ptr`）は参照カウントされず、常に手動`free()`が必要です。

**理由:** 隠された複雑さはパフォーマンスの予測と問題のデバッグを不可能にします。

### ❌ 既存のセマンティクスを壊さない

**これらの核となる決定を変更しない:**
- セミコロンは必須 - オプションにしない
- 手動メモリ管理 - GCを追加しない
- 変更可能な文字列 - 不変にしない
- ランタイム型チェック - 削除しない

**理由:** 一貫性と安定性は流行の機能より重要です。

### ❌ 明示性を減らす「便利な」機能を追加しない

**避けるべき機能の例:**
- 演算子オーバーロード（ユーザー型には可能かもしれないが、慎重に）
- 情報を失う暗黙の型強制
- 自動リソースクリーンアップ（RAII）
- 複雑さを隠すメソッドチェーン
- DSLと魔法の構文

**例外:** 便利な機能は、単純な操作の**明示的なシンタックスシュガー**であればOK:
- `else if`は問題ない（ネストされたif文にすぎない）
- 文字列補間は明確にシンタックスシュガーならOKかもしれない
- オブジェクトのメソッド構文は問題ない（何をするか明示的）

---

## 将来の検討事項

### 追加するかもしれない（検討中）

これらの機能はHemlockの哲学に沿っていますが、慎重な設計が必要です:

**1. パターンマッチング**
```hemlock
match (value) {
    case i32: print("integer");
    case string: print("text");
    case _: print("other");
}
```
- 明示的な型チェック
- 隠れたコストなし
- コンパイル時の網羅性チェックが可能

**2. エラー型（`Result<T, E>`）**
```hemlock
fn divide(a: i32, b: i32): Result<i32, string> {
    if (b == 0) {
        return Err("division by zero");
    }
    return Ok(a / b);
}
```
- 明示的なエラー処理
- ユーザーにエラーについて考えさせる
- 例外の代替

**3. 配列/スライス型**
- 動的配列は既にある
- スタック割り当て用の固定サイズ配列を追加できる
- スタック vs ヒープについて明示的である必要がある

**4. 改善されたメモリ安全ツール**
- オプションの境界チェックフラグ
- デバッグビルドでのメモリリーク検出
- サニタイザ統合

### おそらく追加しない

これらの機能は核となる原則に違反します:

**1. ガベージコレクション**
- メモリ管理の複雑さを隠す
- 予測不可能なパフォーマンス
- 明示的制御の原則に反する

**2. 自動メモリ管理**
- GCと同じ理由
- 参照カウントは明示的ならOKかもしれない

**3. データを失う暗黙の型変換**
- 「暗黙より明示」に反する
- 微妙なバグの原因

**4. マクロ（複雑なもの）**
- 力が強すぎ、複雑すぎ
- シンプルなマクロシステムならOKかもしれない
- コード生成や関数を推奨

**5. 継承を持つクラスベースOOP**
- 暗黙の動作が多すぎる
- ダックタイピングとオブジェクトで十分
- 継承より合成

**6. 複雑な解決を持つモジュールシステム**
- インポートはシンプルで明示的に
- 魔法の検索パスなし
- バージョン解決なし（OSパッケージマネージャを使用）

---

## 最終的な考え

### 信頼と責任

Hemlockは**信頼と責任**についてです。プログラマーが以下を行うことを信頼します:

- メモリを正しく管理する
- 型を適切に使用する
- エラーを適切に処理する
- トレードオフを理解する

見返りに、Hemlockは以下を提供します:

- 隠れたコストなし
- 驚きの動作なし
- 必要な時の完全な制御
- 望むときの安全ツール

### 指針となる質問

**新機能を検討するとき、尋ねてください:**

> 「これはプログラマーにより明示的な制御を与えるか、それとも何かを隠すか？」

- **明示的な制御を追加する**なら → おそらくHemlockに適している
- **複雑さを隠す**なら → おそらく属さない
- 明確にドキュメント化された**オプショナルシュガー**なら → OKかもしれない

### 良い追加の例

✅ **Switch文** - 明示的な制御フロー、魔法なし、明確なセマンティクス

✅ **pthreadsを使ったAsync/await** - 明示的な並行処理、真の並列処理、ユーザーがスポーンを制御

✅ **ptrと並ぶBuffer型** - 安全と安全でないの選択を与える

✅ **オプションの型注釈** - 厳密さを強制せずにバグをキャッチ

✅ **Try/catch/finally** - 明確な制御フローを持つ明示的なエラー処理

### 悪い追加の例

❌ **自動セミコロン挿入** - 構文エラーを隠し、コードを曖昧にする

❌ **RAII/デストラクタ** - 自動クリーンアップはリソースがいつ解放されるか隠す

❌ **暗黙のnull合体** - nullチェックを隠し、コードの推論を難しくする

❌ **自動成長文字列** - メモリ割り当てを隠し、予測不可能なパフォーマンス

---

## 結論

Hemlockは最も安全な言語、最速の言語、最も機能豊富な言語になろうとしていません。

**Hemlockは最も*正直な*言語になろうとしています。**

正確に何をしているかを伝え、必要なときに制御を与え、鋭い角を隠しません。低レベルでコードを理解したいが、現代的な人間工学も楽しみたい人のための言語です。

機能がHemlockに属するかどうかわからない場合は、覚えておいてください:

> **常に暗黙より明示。**
> **安全でないことは機能であり、バグではない。**
> **ユーザーに責任がある、それでOK。**
