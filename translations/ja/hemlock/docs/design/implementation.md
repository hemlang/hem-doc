# Hemlock 実装詳細

このドキュメントでは、Hemlock言語の技術的な実装について説明します。プロジェクト構造、コンパイルパイプライン、ランタイムアーキテクチャ、および設計上の決定事項を含みます。

---

## 目次

- [プロジェクト構造](#プロジェクト構造)
- [コンパイルパイプライン](#コンパイルパイプライン)
- [モジュラーインタプリタ設計](#モジュラーインタプリタ設計)
- [ランタイムアーキテクチャ](#ランタイムアーキテクチャ)
- [値の表現](#値の表現)
- [型システムの実装](#型システムの実装)
- [メモリ管理](#メモリ管理)
- [並行処理モデル](#並行処理モデル)
- [将来の計画](#将来の計画)

---

## プロジェクト構造

```
hemlock/
├── src/
│   ├── frontend/              # 共有: 字句解析器、構文解析器、AST
│   │   ├── lexer.c            # トークン化
│   │   ├── parser/            # 再帰下降パーサー
│   │   ├── ast.c              # ASTノード管理
│   │   └── module.c           # モジュール解決
│   ├── backends/
│   │   ├── interpreter/       # hemlock: ツリーウォーキングインタプリタ
│   │   │   ├── main.c         # CLIエントリポイント
│   │   │   ├── runtime.c      # 式/文の評価
│   │   │   ├── builtins.c     # 組み込み関数
│   │   │   └── ...
│   │   └── compiler/          # hemlockc: Cコードジェネレータ
│   │       ├── main.c         # CLI、オーケストレーション
│   │       ├── type_check.c   # コンパイル時型チェック
│   │       ├── codegen.c      # コード生成コンテキスト
│   │       ├── codegen_expr.c # 式のコード生成
│   │       ├── codegen_stmt.c # 文のコード生成
│   │       └── ...
│   ├── tools/
│   │   ├── lsp/               # 言語サーバープロトコル
│   │   └── bundler/           # バンドル/パッケージツール
├── runtime/                   # libhemlock_runtime.a（コンパイル済みプログラム用）
├── stdlib/                    # 標準ライブラリ（39モジュール）
│   └── docs/                  # モジュールドキュメント
├── tests/
│   ├── parity/                # 両バックエンドで合格必須のテスト
│   ├── interpreter/           # インタプリタ固有のテスト
│   └── compiler/              # コンパイラ固有のテスト
├── examples/                  # サンプルプログラム
└── docs/                      # ドキュメント
```

### ディレクトリ構成

**`include/`** - コンポーネント間のインターフェースを定義するパブリックAPIヘッダー:
- 字句解析器、構文解析器、AST、インタプリタ間の明確な分離
- 依存関係を最小化するための前方宣言
- 他のプログラムにHemlockを埋め込むためのパブリックAPI

**`src/`** - 実装ファイル:
- トップレベルファイルは字句解析、構文解析、AST管理を処理
- `main.c`はCLIとREPLを提供
- インタプリタは別々のサブシステムにモジュール化

**`src/interpreter/`** - モジュラーインタプリタ実装:
- 各モジュールは単一の明確な責務を持つ
- モジュール間通信用の内部APIは`internal.h`で定義
- モジュールは独立してコンパイル可能で、より高速なビルドを実現

**`tests/`** - 包括的なテストスイート:
- 機能領域ごとに整理
- 各ディレクトリには焦点を絞ったテストケースを含む
- `run_tests.sh`がテスト実行を調整

---

## コンパイルパイプライン

Hemlockは、明確なフェーズを持つ従来のコンパイルパイプラインを使用します:

### フェーズ1: 字句解析（レキサー）

**入力:** ソースコードテキスト
**出力:** トークンストリーム
**実装:** `src/lexer.c`

```
ソース: "let x = 42;"
   ↓
トークン: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
```

**主な特徴:**
- キーワード、識別子、リテラル、演算子、句読点を認識
- UTF-8文字列リテラルとルーンリテラルを処理
- エラーメッセージ用に行番号を報告
- シングルパス、バックトラックなし

### フェーズ2: 構文解析（パーサー）

**入力:** トークンストリーム
**出力:** 抽象構文木（AST）
**実装:** `src/parser.c`

```
トークン: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
   ↓
AST: LetStmt {
    name: "x",
    type: null,
    value: IntLiteral(42)
}
```

**主な特徴:**
- 再帰下降パーサー
- プログラム構造のツリー表現を構築
- 演算子の優先順位を処理
- 構文を検証（括弧、セミコロンなど）
- 意味解析はまだ行わない（実行時に行う）

**演算子の優先順位（低い順）:**
1. 代入: `=`
2. 論理OR: `||`
3. 論理AND: `&&`
4. ビット単位OR: `|`
5. ビット単位XOR: `^`
6. ビット単位AND: `&`
7. 等価: `==`, `!=`
8. 比較: `<`, `>`, `<=`, `>=`
9. ビットシフト: `<<`, `>>`
10. 加算/減算: `+`, `-`
11. 乗算/除算/剰余: `*`, `/`, `%`
12. 単項: `!`, `-`, `~`
13. 呼び出し/インデックス/メンバー: `()`, `[]`, `.`

### フェーズ3a: インタープリテーション（ツリーウォーキング）

**入力:** AST
**出力:** プログラム実行
**実装:** `src/backends/interpreter/runtime.c`

```
AST: LetStmt { ... }
   ↓
実行: ASTノードを再帰的に評価
   ↓
結果: 変数xが値42で作成される
```

**主な特徴:**
- 直接的なAST走査（ツリーウォーキングインタプリタ）
- 実行時の動的型チェック
- 環境ベースの変数ストレージ

### フェーズ3b: コンパイル（hemlockc）

**入力:** AST
**出力:** Cコード生成によるネイティブ実行可能ファイル
**実装:** `src/backends/compiler/`

```
AST: LetStmt { ... }
   ↓
型チェック: コンパイル時に型を検証
   ↓
Cコード生成: 同等のCコードを生成
   ↓
GCC: Cをネイティブバイナリにコンパイル
   ↓
結果: スタンドアロン実行可能ファイル
```

**主な特徴:**
- コンパイル時型チェック（デフォルトで有効）
- 移植性のためのCコード生成
- `libhemlock_runtime.a`にリンク
- インタプリタよりも大幅に高速な実行

---

## コンパイラバックエンド（hemlockc）

HemlockコンパイラはASTからCコードを生成し、GCCを使用してネイティブ実行可能ファイルにコンパイルします。

### コンパイラアーキテクチャ

```
src/backends/compiler/
├── main.c              # CLI、引数解析、オーケストレーション
├── codegen.c           # コアコード生成コンテキスト
├── codegen_expr.c      # 式のコード生成
├── codegen_stmt.c      # 文のコード生成
├── codegen_call.c      # 関数呼び出し生成
├── codegen_closure.c   # クロージャ実装
├── codegen_program.c   # トップレベルプログラム生成
├── codegen_module.c    # モジュール/インポート処理
├── type_check.c        # コンパイル時型チェック
└── type_check.h        # 型チェッカーAPI
```

### 型チェック

コンパイラには統一された型チェックシステムが含まれており、以下を行います:

1. **コンパイル時に型を検証** - 実行前に型エラーをキャッチ
2. **動的コードをサポート** - 型なしコードは`any`として扱われる（常に有効）
3. **最適化ヒントを提供** - アンボックス可能な変数を識別

**型チェックフラグ:**

| フラグ | 説明 |
|------|-------------|
| (デフォルト) | 型チェック有効 |
| `--check` | 型チェックのみ、コンパイルしない |
| `--no-type-check` | 型チェックを無効化 |
| `--strict-types` | 暗黙の`any`型で警告 |

**型チェッカー実装:**

```c
// type_check.h - 主要な構造体
typedef struct TypeCheckContext {
    const char *filename;
    int error_count;
    int warning_count;
    UnboxableVar *unboxable_vars;  // 最適化ヒント
    // ... 型環境、定義など
} TypeCheckContext;

// メインエントリポイント
int type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);
```

### コード生成

codegen フェーズはASTノードをCコードに変換します:

**式のマッピング:**
```
Hemlock                 →  生成されるC
----------------------------------------
let x = 42;            →  HmlValue x = hml_val_i32(42);
x + y                  →  hml_add(x, y)
arr[i]                 →  hml_array_get(arr, i)
obj.field              →  hml_object_get_field(obj, "field")
fn(a, b) { ... }       →  環境キャプチャ付きクロージャ
```

**ランタイム統合:**

生成されたCコードは`libhemlock_runtime.a`にリンクし、以下を提供します:
- `HmlValue`タグ付きユニオン型
- メモリ管理（参照カウント）
- 組み込み関数（print、typeofなど）
- 並行処理プリミティブ（タスク、チャネル）
- FFIサポート

### アンボックス最適化

型チェッカーは、ボックス化された`HmlValue`の代わりにネイティブC型を使用できる変数を識別します:

**アンボックス可能なパターン:**
- 既知の整数型を持つループカウンター
- ループ内のアキュムレータ変数
- 明示的な型注釈を持つ変数（i32、i64、f64、bool）

```hemlock
// ループカウンター 'i' はネイティブint32_tにアンボックス可能
for (let i: i32 = 0; i < 1000000; i = i + 1) {
    sum = sum + i;
}
```

---

## モジュラーインタプリタ設計

インタプリタは、保守性とスケーラビリティのために、焦点を絞ったモジュールに分割されています。

### モジュールの責務

#### 1. 環境（`environment.c`）- 121行

**目的:** 変数スコープと名前解決

**主要関数:**
- `env_create()` - オプションの親を持つ新しい環境を作成
- `env_define()` - 現在のスコープに新しい変数を定義
- `env_get()` - 現在または親スコープで変数を検索
- `env_set()` - 既存の変数値を更新
- `env_free()` - 環境とすべての変数を解放

**設計:**
- リンクされたスコープ（各環境は親へのポインタを持つ）
- 高速な変数検索のためのHashMap
- クロージャのレキシカルスコープをサポート

#### 2. 値（`values.c`）- 394行

**目的:** 値コンストラクタとデータ構造管理

**主要関数:**
- `value_create_*()` - 各値型のコンストラクタ
- `value_copy()` - ディープ/シャローコピーロジック
- `value_free()` - クリーンアップとメモリ解放
- `value_to_string()` - 印刷用の文字列表現

**データ構造:**
- オブジェクト（動的フィールド配列）
- 配列（動的リサイズ）
- バッファ（ptr + length + capacity）
- クロージャ（関数 + キャプチャされた環境）
- タスクとチャネル（並行処理プリミティブ）

#### 3. 型（`types.c`）- 440行

**目的:** 型システム、変換、ダックタイピング

**主要関数:**
- `type_check()` - ランタイム型検証
- `type_convert()` - 暗黙の型変換/プロモーション
- `duck_type_check()` - オブジェクトの構造的型チェック
- `type_name()` - 印刷可能な型名を取得

**機能:**
- 型プロモーション階層（i8 → i16 → i32 → i64 → f32 → f64、i64/u64 + f32 → f64）
- 数値型の範囲チェック
- オブジェクト型定義のダックタイピング
- オプションフィールドのデフォルト値

#### 4. 組み込み関数（`builtins.c`）- 955行

**目的:** 組み込み関数とグローバル登録

**主要関数:**
- `register_builtins()` - すべての組み込み関数と定数を登録
- 組み込み関数の実装（print、typeof、alloc、freeなど）
- シグナル処理関数
- コマンド実行（exec）

**組み込み関数のカテゴリ:**
- I/O: print、open、read_file、write_file
- メモリ: alloc、free、memset、memcpy、realloc
- 型: typeof、assert
- 並行処理: spawn、join、detach、channel
- システム: exec、signal、raise、panic
- FFI: dlopen、dlsym、dlcall、dlclose

#### 5. I/O（`io.c`）- 449行

**目的:** ファイルI/OとJSONシリアライゼーション

**主要関数:**
- ファイルオブジェクトメソッド（read、write、seek、tell、close）
- JSONシリアライゼーション/デシリアライゼーション
- 循環参照検出

**機能:**
- プロパティを持つファイルオブジェクト（path、mode、closed）
- UTF-8対応テキストI/O
- バイナリI/Oサポート
- オブジェクトと配列のJSONラウンドトリップ

#### 6. FFI（`ffi.c`）- 外部関数インターフェース

**目的:** 共有ライブラリからC関数を呼び出す

**主要関数:**
- `dlopen()` - 共有ライブラリをロード
- `dlsym()` - 名前で関数ポインタを取得
- `dlcall()` - 型変換付きでC関数を呼び出す
- `dlclose()` - ライブラリをアンロード

**機能:**
- 動的関数呼び出しのためのlibffi統合
- 自動型変換（Hemlock ↔ C型）
- すべてのプリミティブ型をサポート
- ポインタとバッファのサポート

#### 7. ランタイム（`runtime.c`）- 865行

**目的:** 式の評価と文の実行

**主要関数:**
- `eval_expr()` - 式を評価（再帰的）
- `eval_stmt()` - 文を実行
- 制御フロー処理（if、while、for、switchなど）
- 例外処理（try/catch/finally/throw）

**機能:**
- 再帰的な式評価
- ブール演算の短絡評価
- メソッド呼び出し検出と`self`バインディング
- 例外伝播
- break/continue/return処理

### モジュラー設計の利点

**1. 関心の分離**
- 各モジュールは1つの明確な責務を持つ
- 機能がどこに実装されているか見つけやすい
- 変更時の認知負荷を軽減

**2. より高速なインクリメンタルビルド**
- 変更されたモジュールのみ再コンパイルが必要
- 並列コンパイルが可能
- 開発中のイテレーション時間を短縮

**3. より簡単なテストとデバッグ**
- モジュールを単独でテスト可能
- バグは特定のサブシステムに限定
- テスト用のモック実装が可能

**4. スケーラビリティ**
- 新機能を適切なモジュールに追加可能
- モジュールを独立してリファクタリング可能
- ファイルごとのコードサイズが管理可能

**5. コード構成**
- 関連機能の論理的なグルーピング
- 明確な依存関係グラフ
- 新しい貢献者のオンボーディングが容易

---

## ランタイムアーキテクチャ

### 値の表現

Hemlockのすべての値は、タグ付きユニオンを使用する`Value`構造体で表現されます:

```c
typedef struct Value {
    ValueType type;  // ランタイム型タグ
    union {
        int32_t i32_value;
        int64_t i64_value;
        uint8_t u8_value;
        uint32_t u32_value;
        uint64_t u64_value;
        float f32_value;
        double f64_value;
        bool bool_value;
        char *string_value;
        uint32_t rune_value;
        void *ptr_value;
        Buffer *buffer_value;
        Array *array_value;
        Object *object_value;
        Function *function_value;
        File *file_value;
        Task *task_value;
        Channel *channel_value;
    };
} Value;
```

**設計上の決定:**
- 柔軟性を維持しながら型安全性を確保する**タグ付きユニオン**
- 動的型付けと型チェックを可能にする**ランタイム型タグ**
- プリミティブ用の**直接値ストレージ**（ボックス化なし）
- ヒープ割り当て型用の**ポインタストレージ**（文字列、オブジェクト、配列）

### メモリレイアウト例

**整数（i32）:**
```
Value {
    type: TYPE_I32,
    i32_value: 42
}
```
- 合計サイズ: 約16バイト（8バイトタグ + 8バイトユニオン）
- スタック割り当て
- ヒープ割り当て不要

**文字列:**
```
Value {
    type: TYPE_STRING,
    string_value: 0x7f8a4c000000  // ヒープへのポインタ
}

ヒープ: "hello\0"（6バイト、null終端UTF-8）
```
- 値はスタック上で16バイト
- 文字列データはヒープ割り当て
- 手動で解放が必要

**オブジェクト:**
```
Value {
    type: TYPE_OBJECT,
    object_value: 0x7f8a4c001000  // ヒープへのポインタ
}

ヒープ: Object {
    type_name: "Person",
    fields: [
        { name: "name", value: Value{TYPE_STRING, "Alice"} },
        { name: "age", value: Value{TYPE_I32, 30} }
    ],
    field_count: 2,
    capacity: 4
}
```
- オブジェクト構造はヒープ上
- フィールドは動的配列に格納
- フィールド値は埋め込まれたValue構造体

### 環境の実装

変数は環境チェーンに格納されます:

```c
typedef struct Environment {
    HashMap *bindings;           // name → Value
    struct Environment *parent;  // レキシカル親スコープ
} Environment;
```

**スコープチェーンの例:**
```
グローバルスコープ: { print: <builtin>, args: <array> }
    ↑
関数スコープ: { x: 10, y: 20 }
    ↑
ブロックスコープ: { i: 0 }
```

**検索アルゴリズム:**
1. 現在の環境のハッシュマップをチェック
2. 見つからない場合、親環境をチェック
3. 見つかるかグローバルスコープに達するまで繰り返す
4. どのスコープでも見つからない場合はエラー

---

## 型システムの実装

### 型チェック戦略

Hemlockは**オプションの型注釈**付きの**ランタイム型チェック**を使用します:

```hemlock
let x = 42;           // 型チェックなし、i32を推論
let y: u8 = 255;      // ランタイムチェック: 値はu8に収まる必要あり
let z: i32 = x + y;   // ランタイムチェック + 型プロモーション
```

**実装フロー:**
1. **リテラル推論** - レキサー/パーサーがリテラルから初期型を決定
2. **型注釈チェック** - 注釈がある場合、代入時に検証
3. **プロモーション** - 二項演算は共通型にプロモート
4. **変換** - 明示的な変換はオンデマンドで発生

### 型プロモーションの実装

型プロモーションは、精度を保持する固定階層に従います:

```c
// 簡略化されたプロモーションロジック
ValueType promote_types(ValueType a, ValueType b) {
    // f64は常に勝つ
    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;

    // f32とi64/u64はf64にプロモート（精度保持）
    if (a == TYPE_F32 || b == TYPE_F32) {
        ValueType other = (a == TYPE_F32) ? b : a;
        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;
        return TYPE_F32;
    }

    // 大きい整数型が勝つ
    int rank_a = get_type_rank(a);
    int rank_b = get_type_rank(b);
    return (rank_a > rank_b) ? a : b;
}
```

**型ランク:**
- i8: 0
- u8: 1
- i16: 2
- u16: 3
- i32: 4
- u32: 5
- i64: 6
- u64: 7
- f32: 8
- f64: 9

### ダックタイピングの実装

オブジェクトの型チェックは構造的比較を使用します:

```c
bool duck_type_check(Object *obj, TypeDef *type_def) {
    // すべての必須フィールドをチェック
    for (each field in type_def) {
        if (!object_has_field(obj, field.name)) {
            return false;  // フィールドが見つからない
        }

        Value *field_value = object_get_field(obj, field.name);
        if (!type_matches(field_value, field.type)) {
            return false;  // 型が違う
        }
    }

    return true;  // すべての必須フィールドが存在し、正しい型
}
```

**ダックタイピングで許可されること:**
- オブジェクトの余分なフィールド（無視される）
- 部分構造型付け（オブジェクトは必要以上のものを持てる）
- 検証後の型名の割り当て

---

## メモリ管理

### 割り当て戦略

Hemlockは2つの割り当てプリミティブを持つ**手動メモリ管理**を使用します:

**1. 生ポインタ（`ptr`）:**
```c
void *alloc(size_t bytes) {
    void *ptr = malloc(bytes);
    if (!ptr) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return ptr;
}
```
- 直接malloc/free
- トラッキングなし
- ユーザーの責任で解放

**2. バッファ（`buffer`）:**
```c
typedef struct Buffer {
    void *data;
    size_t length;
    size_t capacity;
} Buffer;

Buffer *create_buffer(size_t size) {
    Buffer *buf = malloc(sizeof(Buffer));
    buf->data = malloc(size);
    buf->length = size;
    buf->capacity = size;
    return buf;
}
```
- サイズと容量を追跡
- アクセス時の境界チェック
- それでも手動freeが必要

### ヒープ割り当て型

**文字列:**
- ヒープ上のUTF-8バイト配列
- Cとの相互運用のためnull終端
- 変更可能（その場で変更可能）
- 参照カウント（スコープ終了時に自動解放）

**オブジェクト:**
- 動的フィールド配列
- フィールド名と値はヒープ上
- 参照カウント（スコープ終了時に自動解放）
- 循環参照の可能性あり（訪問済みセットトラッキングで処理）

**配列:**
- 動的な容量倍増成長
- 要素は埋め込まれたValue構造体
- 成長時の自動再割り当て
- 参照カウント（スコープ終了時に自動解放）

**クロージャ:**
- 参照によって環境をキャプチャ
- 環境はヒープ割り当て
- クロージャ環境は参照されなくなると適切に解放

---

## 並行処理モデル

### スレッディングアーキテクチャ

Hemlockは**1:1スレッディング**とPOSIXスレッド（pthreads）を使用します:

```
ユーザータスク        OSスレッド           CPUコア
---------          ---------          --------
spawn(f1) ------>  pthread_create --> コア0
spawn(f2) ------>  pthread_create --> コア1
spawn(f3) ------>  pthread_create --> コア2
```

**主な特徴:**
- 各`spawn()`は新しいpthreadを作成
- カーネルがスレッドをコア間でスケジュール
- 真の並列実行（GILなし）
- プリエンプティブマルチタスキング

### タスクの実装

```c
typedef struct Task {
    pthread_t thread;        // OSスレッドハンドル
    Value result;            // 戻り値
    char *error;             // 例外メッセージ（スローされた場合）
    pthread_mutex_t lock;    // 状態を保護
    TaskState state;         // RUNNING、FINISHED、ERROR
} Task;
```

**タスクのライフサイクル:**
1. `spawn(func, args)` → タスクを作成、pthreadを開始
2. スレッドが引数付きで関数を実行
3. 戻り時: 結果を格納、状態をFINISHEDに設定
4. 例外時: エラーメッセージを格納、状態をERRORに設定
5. `join(task)` → スレッドを待機、結果を返すか例外をスロー

### チャネルの実装

```c
typedef struct Channel {
    void **buffer;           // Value*の循環バッファ
    size_t capacity;         // 最大バッファアイテム数
    size_t count;            // バッファ内の現在のアイテム数
    size_t read_index;       // 次の読み取り位置
    size_t write_index;      // 次の書き込み位置
    bool closed;             // チャネルクローズフラグ
    pthread_mutex_t lock;    // バッファを保護
    pthread_cond_t not_full; // スペースが利用可能時のシグナル
    pthread_cond_t not_empty;// データが利用可能時のシグナル
} Channel;
```

**送信操作:**
1. mutexをロック
2. バッファがフルなら待機（not_fullでcond_wait）
3. buffer[write_index]に値を書き込み
4. write_indexをインクリメント（循環）
5. not_emptyをシグナル
6. mutexをアンロック

**受信操作:**
1. mutexをロック
2. バッファが空なら待機（not_emptyでcond_wait）
3. buffer[read_index]から値を読み取り
4. read_indexをインクリメント（循環）
5. not_fullをシグナル
6. mutexをアンロック

**同期保証:**
- スレッドセーフなsend/recv（mutexで保護）
- ブロッキングセマンティクス（プロデューサーはフルで待機、コンシューマーは空で待機）
- 順序付き配信（チャネル内でFIFO）

---

## 将来の計画

### 完了: コンパイラバックエンド ✓

コンパイラバックエンド（`hemlockc`）は以下で実装済み:
- ASTからのCコード生成
- コンパイル時型チェック（デフォルトで有効）
- ランタイムライブラリ（`libhemlock_runtime.a`）
- インタプリタとの完全なパリティ（98%のテスト合格率）
- アンボックス最適化フレームワーク

### 現在のフォーカス: 型システムの強化

**最近の改善:**
- 統一された型チェックと型推論システム
- コンパイル時型チェックがデフォルトで有効
- 型のみの検証用`--check`フラグ
- 最適化ヒント用のコード生成への型コンテキスト渡し

### 将来の強化

**潜在的な追加:**
- ジェネリクス/テンプレート
- パターンマッチング
- 型認識IDEサポートのためのLSP統合
- より積極的なアンボックス最適化
- スタック割り当てのためのエスケープ解析

### 長期的な最適化

**可能な改善:**
- メソッド呼び出しのインラインキャッシング
- ホットコードパスのJITコンパイル
- より良い並行処理のためのワークスティーリングスケジューラ
- プロファイルガイド最適化

---

## 実装ガイドライン

### 新機能の追加

新機能を実装する際は、以下のガイドラインに従ってください:

**1. 適切なモジュールを選択:**
- 新しい値型 → `values.c`
- 型変換 → `types.c`
- 組み込み関数 → `builtins.c`
- I/O操作 → `io.c`
- 制御フロー → `runtime.c`

**2. すべてのレイヤーを更新:**
- 必要に応じてASTノード型を追加（`ast.h`、`ast.c`）
- 必要に応じてレキサートークンを追加（`lexer.c`）
- パーサールールを追加（`parser.c`）
- ランタイム動作を実装（`runtime.c`または適切なモジュール）
- テストを追加（`tests/`）

**3. 一貫性を維持:**
- 既存のコードスタイルに従う
- 一貫した命名規則を使用
- ヘッダーでパブリックAPIをドキュメント化
- エラーメッセージを明確で一貫性のあるものにする

**4. 徹底的にテスト:**
- 実装前にテストケースを追加
- 成功とエラーのパスをテスト
- エッジケースをテスト
- メモリリークがないことを確認（valgrind）

### パフォーマンスの考慮事項

**現在のボトルネック:**
- 変数アクセスのHashMap検索
- 再帰関数呼び出し（TCOなし）
- 文字列連結（毎回新しい文字列を割り当て）
- すべての操作での型チェックオーバーヘッド

**最適化の機会:**
- 変数位置のキャッシュ（インラインキャッシング）
- 末尾呼び出し最適化
- 連結用文字列ビルダー
- ランタイムチェックをスキップする型推論

### デバッグのヒント

**便利なツール:**
- `valgrind` - メモリリーク検出
- `gdb` - クラッシュのデバッグ
- `-g`フラグ - デバッグシンボル
- `printf`デバッグ - シンプルだが効果的

**よくある問題:**
- セグフォルト → NULLポインタ参照（戻り値をチェック）
- メモリリーク → free()呼び出しの欠落（value_freeパスをチェック）
- 型エラー → type_convert()とtype_check()ロジックをチェック
- スレッドでのクラッシュ → 競合状態（mutex使用をチェック）

---

## 結論

Hemlockの実装は以下を優先しています:
- **モジュール性** - 関心の明確な分離
- **シンプルさ** - 直接的な実装
- **明示性** - 隠された魔法なし
- **保守性** - 理解と変更が容易

現在のツリーウォーキングインタプリタは、迅速な機能開発と実験を容易にするために意図的にシンプルにしています。将来のコンパイラバックエンドは、同じセマンティクスを維持しながらパフォーマンスを向上させます。
