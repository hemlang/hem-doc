# Hemlock è¯­è¨€è®¾è®¡ç†å¿µ

> "ä¸€é—¨å°å·§ã€éå®‰å…¨çš„è¯­è¨€ï¼Œç”¨äºå®‰å…¨åœ°ç¼–å†™éå®‰å…¨ä»£ç ã€‚"

æœ¬æ–‡æ¡£è®°å½•äº† AI åŠ©æ‰‹åœ¨ä½¿ç”¨ Hemlock æ—¶éœ€è¦äº†è§£çš„æ ¸å¿ƒè®¾è®¡åŸåˆ™ã€‚
å¦‚éœ€è¯¦ç»†æ–‡æ¡£ï¼Œè¯·å‚é˜… `docs/README.md` å’Œ `stdlib/docs/` ç›®å½•ã€‚

---

## æ ¸å¿ƒå®šä½

Hemlock æ˜¯ä¸€é—¨**ç³»ç»Ÿè„šæœ¬è¯­è¨€**ï¼Œå…·æœ‰æ‰‹åŠ¨å†…å­˜ç®¡ç†å’Œæ˜¾å¼æ§åˆ¶ï¼š
- æ‹¥æœ‰ C è¯­è¨€çš„èƒ½åŠ›ï¼ŒåŒæ—¶å…·å¤‡ç°ä»£è„šæœ¬çš„ä¾¿åˆ©æ€§
- å†…ç½®ç»“æ„åŒ–å¼‚æ­¥å¹¶å‘
- æ— éšè—è¡Œä¸ºæˆ–é­”æ³•

**Hemlock ä¸æ˜¯ï¼š** å†…å­˜å®‰å…¨çš„ã€å¸¦åƒåœ¾å›æ”¶çš„è¯­è¨€ï¼Œä¹Ÿä¸ä¼šéšè—å¤æ‚æ€§ã€‚
**Hemlock æ˜¯ï¼š** æ˜¾å¼ä¼˜äºéšå¼ã€å…·æœ‰æ•™è‚²æ„ä¹‰ã€ç³»ç»Ÿå·¥ä½œçš„"C è„šæœ¬å±‚"ã€‚

---

## è®¾è®¡åŸåˆ™

### 1. æ˜¾å¼ä¼˜äºéšå¼
- åˆ†å·æ˜¯å¼ºåˆ¶æ€§çš„ï¼ˆæ— è‡ªåŠ¨åˆ†å·æ’å…¥ï¼‰
- æ‰‹åŠ¨å†…å­˜ç®¡ç†ï¼ˆalloc/freeï¼‰
- ç±»å‹æ³¨è§£å¯é€‰ï¼Œä½†åœ¨è¿è¡Œæ—¶æ£€æŸ¥

### 2. é»˜è®¤åŠ¨æ€ï¼Œå¯é€‰ç±»å‹
- æ¯ä¸ªå€¼éƒ½æœ‰è¿è¡Œæ—¶ç±»å‹æ ‡ç­¾
- å­—é¢é‡æ¨æ–­ç±»å‹ï¼š`42` â†’ i32ï¼Œ`5000000000` â†’ i64ï¼Œ`3.14` â†’ f64
- å¯é€‰çš„ç±»å‹æ³¨è§£å¼ºåˆ¶æ‰§è¡Œè¿è¡Œæ—¶æ£€æŸ¥

### 3. éå®‰å…¨æ˜¯ç‰¹æ€§
- å…è®¸æŒ‡é’ˆè¿ç®—ï¼ˆç”¨æˆ·è‡ªè¡Œè´Ÿè´£ï¼‰
- åŸå§‹ `ptr` æ— è¾¹ç•Œæ£€æŸ¥ï¼ˆä½¿ç”¨ `buffer` è·å¾—å®‰å…¨æ€§ï¼‰
- å…è®¸åŒé‡é‡Šæ”¾å¯¼è‡´å´©æºƒ

### 4. ç»“æ„åŒ–å¹¶å‘æ˜¯ä¸€ç­‰å…¬æ°‘
- å†…ç½® `async`/`await`ï¼ŒåŸºäº pthread çš„å¹¶è¡Œ
- ç”¨äºé€šä¿¡çš„ channel
- `spawn`/`join`/`detach` ç”¨äºä»»åŠ¡ç®¡ç†

### 5. ç±» C è¯­æ³•
- `{}` å—æ€»æ˜¯å¿…éœ€çš„
- æ³¨é‡Šï¼š`// è¡Œæ³¨é‡Š` å’Œ `/* å—æ³¨é‡Š */`
- è¿ç®—ç¬¦ä¸ C ä¸€è‡´ï¼š`+`ã€`-`ã€`*`ã€`%`ã€`&&`ã€`||`ã€`!`ã€`&`ã€`|`ã€`^`ã€`<<`ã€`>>`
- è‡ªå¢/è‡ªå‡ï¼š`++x`ã€`x++`ã€`--x`ã€`x--`ï¼ˆå‰ç¼€å’Œåç¼€ï¼‰
- å¤åˆèµ‹å€¼ï¼š`+=`ã€`-=`ã€`*=`ã€`/=`ã€`%=`ã€`&=`ã€`|=`ã€`^=`ã€`<<=`ã€`>>=`
- `/` æ€»æ˜¯è¿”å›æµ®ç‚¹æ•°ï¼ˆä½¿ç”¨ `divi()` è¿›è¡Œæ•´æ•°é™¤æ³•ï¼‰
- ç±»å‹è¯­æ³•ï¼š`let x: type = value;`

---

## å¿«é€Ÿå‚è€ƒ

### ç±»å‹
```
æœ‰ç¬¦å·ï¼š  i8, i16, i32, i64
æ— ç¬¦å·ï¼š  u8, u16, u32, u64
æµ®ç‚¹ï¼š    f32, f64
å…¶ä»–ï¼š    bool, string, rune, array, ptr, buffer, null, object, file, task, channel
åˆ«åï¼š    integer (i32), number (f64), byte (u8)
```

**ç±»å‹æå‡ï¼š** i8 â†’ i16 â†’ i32 â†’ i64 â†’ f32 â†’ f64ï¼ˆæµ®ç‚¹æ€»æ˜¯èµ¢ï¼Œä½† i64/u64 + f32 â†’ f64 ä»¥ä¿æŒç²¾åº¦ï¼‰

### å­—é¢é‡
```hemlock
let x = 42;              // i32
let big = 5000000000;    // i64 (> i32 æœ€å¤§å€¼)
let hex = 0xDEADBEEF;    // åå…­è¿›åˆ¶å­—é¢é‡
let bin = 0b1010;        // äºŒè¿›åˆ¶å­—é¢é‡
let oct = 0o777;         // å…«è¿›åˆ¶å­—é¢é‡
let sep = 1_000_000;     // å…è®¸æ•°å­—åˆ†éš”ç¬¦
let pi = 3.14;           // f64
let half = .5;           // f64 (æ— å‰å¯¼é›¶)
let s = "hello";         // string
let esc = "\x41\u{1F600}"; // åå…­è¿›åˆ¶å’Œ Unicode è½¬ä¹‰
let ch = 'A';            // rune
let emoji = 'ğŸš€';        // rune (Unicode)
let arr = [1, 2, 3];     // array
let obj = { x: 10 };     // object
```

### ç±»å‹è½¬æ¢
```hemlock
// ç±»å‹æ„é€ å‡½æ•° - å°†å­—ç¬¦ä¸²è§£æä¸ºç±»å‹
let n = i32("42");       // å°†å­—ç¬¦ä¸²è§£æä¸º i32
let f = f64("3.14");     // å°†å­—ç¬¦ä¸²è§£æä¸º f64
let b = bool("true");    // å°†å­—ç¬¦ä¸²è§£æä¸º bool ("true" æˆ– "false")

// æ”¯æŒæ‰€æœ‰æ•°å€¼ç±»å‹
let a = i8("-128");      // i8, i16, i32, i64
let c = u8("255");       // u8, u16, u32, u64
let d = f32("1.5");      // f32, f64

// åå…­è¿›åˆ¶å’Œè´Ÿæ•°
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42

// ç±»å‹åˆ«åä¹Ÿé€‚ç”¨
let x = integer("100");  // ç­‰åŒäº i32("100")
let y = number("1.5");   // ç­‰åŒäº f64("1.5")
let z = byte("200");     // ç­‰åŒäº u8("200")

// æ•°å€¼ç±»å‹ä¹‹é—´çš„è½¬æ¢
let big = i64(42);       // i32 è½¬ i64
let truncated = i32(3.99); // f64 è½¬ i32 (æˆªæ–­ä¸º 3)

// ç±»å‹æ³¨è§£éªŒè¯ç±»å‹ï¼ˆä½†ä¸è§£æå­—ç¬¦ä¸²ï¼‰
let f: f64 = 100;        // é€šè¿‡æ³¨è§£å°† i32 è½¬ä¸º f64ï¼ˆæ•°å€¼å¼ºåˆ¶è½¬æ¢å¯è¡Œï¼‰
// let n: i32 = "42";    // é”™è¯¯ - ä½¿ç”¨ i32("42") è§£æå­—ç¬¦ä¸²
```

### å†…çœ
```hemlock
typeof(42);              // "i32"
typeof("hello");         // "string"
typeof([1, 2, 3]);       // "array"
typeof(null);            // "null"
len("hello");            // 5 (å­—ç¬¦ä¸²å­—èŠ‚é•¿åº¦)
len([1, 2, 3]);          // 3 (æ•°ç»„é•¿åº¦)
```

### å†…å­˜
```hemlock
let p = alloc(64);       // åŸå§‹æŒ‡é’ˆ
let b = buffer(64);      // å®‰å…¨ç¼“å†²åŒºï¼ˆè¾¹ç•Œæ£€æŸ¥ï¼‰
memset(p, 0, 64);
memcpy(dest, src, 64);
free(p);                 // éœ€è¦æ‰‹åŠ¨æ¸…ç†
```

### æ§åˆ¶æµ
```hemlock
if (x > 0) { } else if (x < 0) { } else { }
while (cond) { break; continue; }
for (let i = 0; i < 10; i++) { }
for (item in array) { }
loop { if (done) { break; } }   // æ— é™å¾ªç¯ï¼ˆæ¯” while(true) æ›´æ¸…æ™°ï¼‰
switch (x) { case 1: break; default: break; }  // C é£æ ¼è´¯ç©¿
defer cleanup();         // å‡½æ•°è¿”å›æ—¶æ‰§è¡Œ

// å¾ªç¯æ ‡ç­¾ç”¨äºåµŒå¥—å¾ªç¯ä¸­çš„å®šå‘ break/continue
outer: while (cond) {
    inner: for (let i = 0; i < 10; i++) {
        if (i == 5) { break outer; }     // è·³å‡ºå¤–å±‚å¾ªç¯
        if (i == 3) { continue outer; }  // ç»§ç»­å¤–å±‚å¾ªç¯
    }
}
```

### æ¨¡å¼åŒ¹é…
```hemlock
// match è¡¨è¾¾å¼ - è¿”å›å€¼
let result = match (value) {
    0 => "zero",                    // å­—é¢é‡æ¨¡å¼
    1 | 2 | 3 => "small",           // OR æ¨¡å¼
    n if n < 10 => "medium",        // å®ˆå«è¡¨è¾¾å¼
    n => "large: " + n              // å˜é‡ç»‘å®š
};

// ç±»å‹æ¨¡å¼
match (val) {
    n: i32 => "integer",
    s: string => "string",
    _ => "other"                    // é€šé…ç¬¦
}

// å¯¹è±¡è§£æ„
match (point) {
    { x: 0, y: 0 } => "origin",
    { x, y } => "at " + x + "," + y
}

// å¸¦å‰©ä½™éƒ¨åˆ†çš„æ•°ç»„è§£æ„
match (arr) {
    [] => "empty",
    [first, ...rest] => "head: " + first,
    _ => "other"
}

// åµŒå¥—æ¨¡å¼
match (user) {
    { name, address: { city } } => name + " in " + city
}
```

å®Œæ•´æ–‡æ¡£è¯·å‚é˜… `docs/language-guide/pattern-matching.md`ã€‚

### ç©ºå€¼åˆå¹¶è¿ç®—ç¬¦
```hemlock
// ç©ºå€¼åˆå¹¶ (??) - å¦‚æœå·¦ä¾§éç©ºåˆ™è¿”å›å·¦ä¾§ï¼Œå¦åˆ™è¿”å›å³ä¾§
let name = user.name ?? "Anonymous";
let first = a ?? b ?? c ?? "fallback";

// ç©ºå€¼åˆå¹¶èµ‹å€¼ (??=) - ä»…å½“ä¸ºç©ºæ—¶èµ‹å€¼
let config = null;
config ??= { timeout: 30 };    // config ç°åœ¨æ˜¯ { timeout: 30 }
config ??= { timeout: 60 };    // config ä¸å˜ï¼ˆéç©ºï¼‰

// é€‚ç”¨äºå±æ€§å’Œç´¢å¼•
obj.field ??= "default";
arr[0] ??= "first";

// å®‰å…¨å¯¼èˆª (?.) - å¦‚æœå¯¹è±¡ä¸ºç©ºåˆ™è¿”å› null
let city = user?.address?.city;  // å¦‚æœä»»ä½•éƒ¨åˆ†ä¸ºç©ºåˆ™ä¸º null
let upper = name?.to_upper();    // å®‰å…¨æ–¹æ³•è°ƒç”¨
let item = arr?.[0];             // å®‰å…¨ç´¢å¼•
```

### å‡½æ•°
```hemlock
fn add(a: i32, b: i32): i32 { return a + b; }
fn greet(name: string, msg?: "Hello") { print(msg + " " + name); }
let f = fn(x) { return x * 2; };  // åŒ¿å/é—­åŒ…

// è¡¨è¾¾å¼ä½“å‡½æ•°ï¼ˆç®­å¤´è¯­æ³•ï¼‰
fn double(x: i32): i32 => x * 2;
fn max(a: i32, b: i32): i32 => a > b ? a : b;
let square = fn(x: i32): i32 => x * x;  // åŒ¿åè¡¨è¾¾å¼ä½“

// å‚æ•°ä¿®é¥°ç¬¦
fn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // æŒ‰å¼•ç”¨ä¼ é€’
fn print_all(const items: array) { for (i in items) { print(i); } }  // ä¸å¯å˜
```

### å‘½åå‚æ•°
```hemlock
// å‡½æ•°å¯ä»¥ä½¿ç”¨å‘½åå‚æ•°è°ƒç”¨
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " is " + age + " years old");
}

// ä½ç½®å‚æ•°ï¼ˆä¼ ç»Ÿæ–¹å¼ï¼‰
create_user("Alice", 25, false);

// å‘½åå‚æ•° - å¯ä»¥ä»»æ„é¡ºåº
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);

// é€šè¿‡å‘½åæ‰€éœ€å‚æ•°æ¥è·³è¿‡å¯é€‰å‚æ•°
create_user("David", active: false);  // ä½¿ç”¨é»˜è®¤ age=18

// å‘½åå‚æ•°å¿…é¡»åœ¨ä½ç½®å‚æ•°ä¹‹å
create_user("Eve", age: 21);          // æ­£ç¡®ï¼šä½ç½®å‚æ•°åœ¨å‰ï¼Œå‘½åå‚æ•°åœ¨å
// create_user(name: "Bad", 25);      // é”™è¯¯ï¼šä½ç½®å‚æ•°åœ¨å‘½åå‚æ•°ä¹‹å
```

**è§„åˆ™ï¼š**
- å‘½åå‚æ•°ä½¿ç”¨ `name: value` è¯­æ³•
- å¯ä»¥åœ¨ä½ç½®å‚æ•°ä¹‹åä»¥ä»»æ„é¡ºåºå‡ºç°
- ä½ç½®å‚æ•°ä¸èƒ½è·Ÿåœ¨å‘½åå‚æ•°ä¹‹å
- ä¸é»˜è®¤/å¯é€‰å‚æ•°é…åˆä½¿ç”¨
- æœªçŸ¥å‚æ•°åä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯

### å¯¹è±¡å’Œæšä¸¾
```hemlock
define Person { name: string, age: i32, active?: true }
let p: Person = { name: "Alice", age: 30 };
let json = p.serialize();
let restored = json.deserialize();

// å¯¹è±¡ç®€å†™è¯­æ³•ï¼ˆES6 é£æ ¼ï¼‰
let name = "Alice";
let age = 30;
let person = { name, age };         // ç­‰åŒäº { name: name, age: age }

// å¯¹è±¡å±•å¼€è¿ç®—ç¬¦
let defaults = { theme: "dark", size: "medium" };
let config = { ...defaults, size: "large" };  // å¤åˆ¶ defaultsï¼Œè¦†ç›– size

enum Color { RED, GREEN, BLUE }
enum Status { OK = 0, ERROR = 1 }
```

### å¤åˆç±»å‹ï¼ˆäº¤å‰/é¸­å­ç±»å‹ï¼‰
```hemlock
// å®šä¹‰ç»“æ„ç±»å‹
define HasName { name: string }
define HasAge { age: i32 }
define HasEmail { email: string }

// å¤åˆç±»å‹ï¼šå¯¹è±¡å¿…é¡»æ»¡è¶³æ‰€æœ‰ç±»å‹
let person: HasName & HasAge = { name: "Alice", age: 30 };

// å¸¦å¤åˆç±»å‹çš„å‡½æ•°å‚æ•°
fn greet(p: HasName & HasAge) {
    print(p.name + " is " + p.age);
}

// ä¸‰ä¸ªæˆ–æ›´å¤šç±»å‹
fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}

// å…è®¸é¢å¤–å­—æ®µï¼ˆé¸­å­ç±»å‹ï¼‰
let employee: HasName & HasAge = {
    name: "Bob",
    age: 25,
    department: "Engineering"  // æ­£ç¡® - é¢å¤–å­—æ®µè¢«å¿½ç•¥
};
```

å¤åˆç±»å‹æä¾›ç±»ä¼¼æ¥å£çš„è¡Œä¸ºï¼Œæ— éœ€å•ç‹¬çš„ `interface` å…³é”®å­—ï¼Œ
æ„å»ºåœ¨ç°æœ‰çš„ `define` å’Œé¸­å­ç±»å‹èŒƒå¼ä¹‹ä¸Šã€‚

### ç±»å‹åˆ«å
```hemlock
// ç®€å•ç±»å‹åˆ«å
type Integer = i32;
type Text = string;

// å‡½æ•°ç±»å‹åˆ«å
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// å¤åˆç±»å‹åˆ«åï¼ˆé€‚åˆå¯é‡ç”¨æ¥å£ï¼‰
define HasName { name: string }
define HasAge { age: i32 }
type Person = HasName & HasAge;

// æ³›å‹ç±»å‹åˆ«å
type Pair<T> = { first: T, second: T };

// ä½¿ç”¨ç±»å‹åˆ«å
let x: Integer = 42;
let cb: Callback = fn(n) { print(n); };
let p: Person = { name: "Alice", age: 30 };
```

ç±»å‹åˆ«åä¸ºå¤æ‚ç±»å‹åˆ›å»ºå‘½åå¿«æ·æ–¹å¼ï¼Œæé«˜å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

### å‡½æ•°ç±»å‹
```hemlock
// å‡½æ•°ç±»å‹æ³¨è§£ç”¨äºå‚æ•°
fn apply_fn(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// è¿”å›å‡½æ•°çš„é«˜é˜¶å‡½æ•°
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// å¼‚æ­¥å‡½æ•°ç±»å‹
fn run_async(handler: async fn(): void) {
    spawn(handler);
}

// å¤šå‚æ•°å‡½æ•°ç±»å‹
type BinaryOp = fn(i32, i32): i32;
let add: BinaryOp = fn(a, b) { return a + b; };
```

### Const å‚æ•°
```hemlock
// Const å‚æ•° - æ·±åº¦ä¸å¯å˜æ€§
fn print_all(const items: array) {
    // items.push(4);  // é”™è¯¯ï¼šæ— æ³•ä¿®æ”¹ const å‚æ•°
    for (item in items) {
        print(item);
    }
}

// å¯¹è±¡çš„ const - æ— æ³•é€šè¿‡ä»»ä½•è·¯å¾„ä¿®æ”¹
fn describe(const person: object) {
    print(person.name);       // æ­£ç¡®ï¼šå…è®¸è¯»å–
    // person.name = "Bob";   // é”™è¯¯ï¼šæ— æ³•ä¿®æ”¹
}

// å…è®¸åµŒå¥—è¯»å–è®¿é—®
fn get_city(const user: object) {
    return user.address.city;  // æ­£ç¡®ï¼šè¯»å–åµŒå¥—å±æ€§
}
```

`const` ä¿®é¥°ç¬¦é˜²æ­¢å¯¹å‚æ•°çš„ä»»ä½•ä¿®æ”¹ï¼ŒåŒ…æ‹¬åµŒå¥—å±æ€§ã€‚
è¿™ä¸ºä¸åº”ä¿®æ”¹å…¶è¾“å…¥çš„å‡½æ•°æä¾›äº†ç¼–è¯‘æ—¶å®‰å…¨æ€§ã€‚

### Ref å‚æ•°ï¼ˆæŒ‰å¼•ç”¨ä¼ é€’ï¼‰
```hemlock
// Ref å‚æ•° - ç›´æ¥ä¿®æ”¹è°ƒç”¨è€…çš„å˜é‡
fn increment(ref x: i32) {
    x = x + 1;  // ä¿®æ”¹åŸå§‹å˜é‡
}

let count = 10;
increment(count);
print(count);  // 11 - åŸå§‹å€¼å·²ä¿®æ”¹

// ç»å…¸äº¤æ¢å‡½æ•°
fn swap(ref a: i32, ref b: i32) {
    let temp = a;
    a = b;
    b = temp;
}

let x = 1;
let y = 2;
swap(x, y);
print(x, y);  // 2 1

// æ··åˆ ref å’Œæ™®é€šå‚æ•°
fn add_to(ref target: i32, amount: i32) {
    target = target + amount;
}

let total = 100;
add_to(total, 50);
print(total);  // 150
```

`ref` ä¿®é¥°ç¬¦ä¼ é€’å¯¹è°ƒç”¨è€…å˜é‡çš„å¼•ç”¨ï¼Œå…è®¸å‡½æ•°ç›´æ¥ä¿®æ”¹å®ƒã€‚
æ²¡æœ‰ `ref` æ—¶ï¼ŒåŸå§‹ç±»å‹æŒ‰å€¼ä¼ é€’ï¼ˆå¤åˆ¶ï¼‰ã€‚å½“éœ€è¦åœ¨ä¸è¿”å›å€¼çš„æƒ…å†µä¸‹
ä¿®æ”¹è°ƒç”¨è€…çŠ¶æ€æ—¶ï¼Œä½¿ç”¨ `ref`ã€‚

**è§„åˆ™ï¼š**
- `ref` å‚æ•°å¿…é¡»ä¼ é€’å˜é‡ï¼Œä¸èƒ½æ˜¯å­—é¢é‡æˆ–è¡¨è¾¾å¼
- é€‚ç”¨äºæ‰€æœ‰ç±»å‹ï¼ˆåŸå§‹ç±»å‹ã€æ•°ç»„ã€å¯¹è±¡ï¼‰
- ä¸ç±»å‹æ³¨è§£ç»“åˆï¼š`ref x: i32`
- ä¸èƒ½ä¸ `const` ç»“åˆï¼ˆå®ƒä»¬æ˜¯å¯¹ç«‹çš„ï¼‰

### Define ä¸­çš„æ–¹æ³•ç­¾å
```hemlock
// å¸¦æ–¹æ³•ç­¾åçš„ defineï¼ˆæ¥å£æ¨¡å¼ï¼‰
define Comparable {
    value: i32,
    fn compare(other: Self): i32   // å¿…éœ€çš„æ–¹æ³•ç­¾å
}

// å¯¹è±¡å¿…é¡»æä¾›å¿…éœ€çš„æ–¹æ³•
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};

// ä½¿ç”¨ ? è¡¨ç¤ºå¯é€‰æ–¹æ³•
define Serializable {
    fn serialize(): string,        // å¿…éœ€
    fn pretty?(): string           // å¯é€‰æ–¹æ³•
}

// Self ç±»å‹æŒ‡å‘å®šä¹‰ç±»å‹
define Cloneable {
    fn clone(): Self   // è¿”å›ä¸å¯¹è±¡ç›¸åŒçš„ç±»å‹
}
```

`define` å—ä¸­çš„æ–¹æ³•ç­¾åä½¿ç”¨é€—å·åˆ†éš”ï¼ˆç±»ä¼¼ TypeScript æ¥å£ï¼‰ï¼Œ
å»ºç«‹å¯¹è±¡å¿…é¡»æ»¡è¶³çš„å¥‘çº¦ï¼Œå¹¶é€šè¿‡ Hemlock çš„é¸­å­ç±»å‹ç³»ç»Ÿå®ç°
ç±»ä¼¼æ¥å£çš„ç¼–ç¨‹æ¨¡å¼ã€‚

### é”™è¯¯å¤„ç†
```hemlock
try { throw "error"; } catch (e) { print(e); } finally { cleanup(); }
panic("unrecoverable");  // ç«‹å³é€€å‡ºï¼Œä¸å¯æ•è·
```

### å¼‚æ­¥/å¹¶å‘
```hemlock
async fn compute(n: i32): i32 { return n * n; }
let task = spawn(compute, 42);
let result = await task;     // æˆ– join(task)
detach(spawn(background_work));

let ch = channel(10);
ch.send(value);
let val = ch.recv();
ch.close();
```

**å†…å­˜æ‰€æœ‰æƒï¼š** ä»»åŠ¡æ¥æ”¶åŸå§‹å€¼çš„å‰¯æœ¬ï¼Œä½†å…±äº«æŒ‡é’ˆã€‚å¦‚æœå°† `ptr` ä¼ é€’ç»™æ´¾ç”Ÿä»»åŠ¡ï¼Œ
å¿…é¡»ç¡®ä¿å†…å­˜åœ¨ä»»åŠ¡å®Œæˆå‰ä¿æŒæœ‰æ•ˆã€‚åœ¨ `free()` ä¹‹å‰ä½¿ç”¨ `join()`ï¼Œ
æˆ–ä½¿ç”¨ channel ä¿¡å·é€šçŸ¥å®Œæˆã€‚

### ç”¨æˆ·è¾“å…¥
```hemlock
let name = read_line();          // ä» stdin è¯»å–è¡Œï¼ˆé˜»å¡ï¼‰
print("Hello, " + name);
eprint("Error message");         // è¾“å‡ºåˆ° stderr

// read_line() åœ¨ EOF æ—¶è¿”å› null
while (true) {
    let line = read_line();
    if (line == null) { break; }
    print("Got:", line);
}
```

### æ–‡ä»¶ I/O
```hemlock
let f = open("file.txt", "r");  // æ¨¡å¼ï¼šr, w, a, r+, w+, a+
let content = f.read();
f.write("data");
f.seek(0);
f.close();
```

### ä¿¡å·
```hemlock
signal(SIGINT, fn(sig) { print("Interrupted"); });
raise(SIGUSR1);
```

---

## å­—ç¬¦ä¸²æ–¹æ³• (19 ä¸ª)

`substr`ã€`slice`ã€`find`ã€`contains`ã€`split`ã€`trim`ã€`to_upper`ã€`to_lower`ã€
`starts_with`ã€`ends_with`ã€`replace`ã€`replace_all`ã€`repeat`ã€`char_at`ã€
`byte_at`ã€`chars`ã€`bytes`ã€`to_bytes`ã€`deserialize`

æ¨¡æ¿å­—ç¬¦ä¸²ï¼š`` `Hello ${name}!` ``

**å­—ç¬¦ä¸²å¯å˜æ€§ï¼š** å­—ç¬¦ä¸²å¯é€šè¿‡ç´¢å¼•èµ‹å€¼ä¿®æ”¹ï¼ˆ`s[0] = 'H'`ï¼‰ï¼Œä½†æ‰€æœ‰å­—ç¬¦ä¸²æ–¹æ³•
è¿”å›æ–°å­—ç¬¦ä¸²è€Œä¸ä¿®æ”¹åŸå­—ç¬¦ä¸²ã€‚è¿™å…è®¸åœ¨éœ€è¦æ—¶è¿›è¡ŒåŸåœ°ä¿®æ”¹ï¼ŒåŒæ—¶ä¿æŒæ–¹æ³•é“¾çš„å‡½æ•°å¼é£æ ¼ã€‚

**å­—ç¬¦ä¸²é•¿åº¦å±æ€§ï¼š**
```hemlock
let s = "hello ğŸš€";
print(s.length);       // 7 (å­—ç¬¦/rune è®¡æ•°)
print(s.byte_length);  // 10 (å­—èŠ‚è®¡æ•° - emoji æ˜¯ 4 å­—èŠ‚ UTF-8)
```

## æ•°ç»„æ–¹æ³• (18 ä¸ª)

`push`ã€`pop`ã€`shift`ã€`unshift`ã€`insert`ã€`remove`ã€`find`ã€`contains`ã€
`slice`ã€`join`ã€`concat`ã€`reverse`ã€`first`ã€`last`ã€`clear`ã€`map`ã€`filter`ã€`reduce`

ç±»å‹åŒ–æ•°ç»„ï¼š`let nums: array<i32> = [1, 2, 3];`

---

## æ ‡å‡†åº“ (40 ä¸ªæ¨¡å—)

ä½¿ç”¨ `@stdlib/` å‰ç¼€å¯¼å…¥ï¼š
```hemlock
import { sin, cos, PI } from "@stdlib/math";
import { HashMap, Queue, Set } from "@stdlib/collections";
import { read_file, write_file } from "@stdlib/fs";
import { TcpStream, UdpSocket } from "@stdlib/net";
```

| æ¨¡å— | æè¿° |
|--------|-------------|
| `arena` | ç«æŠ€åœºå†…å­˜åˆ†é…å™¨ï¼ˆbump åˆ†é…ï¼‰ |
| `args` | å‘½ä»¤è¡Œå‚æ•°è§£æ |
| `assert` | æ–­è¨€å·¥å…· |
| `async` | ThreadPoolã€parallel_map |
| `async_fs` | å¼‚æ­¥æ–‡ä»¶ I/O æ“ä½œ |
| `collections` | HashMapã€Queueã€Stackã€Setã€LinkedListã€LRUCache |
| `compression` | gzipã€gunzipã€deflate |
| `crypto` | aes_encryptã€rsa_signã€random_bytes |
| `csv` | CSV è§£æå’Œç”Ÿæˆ |
| `datetime` | DateTime ç±»ã€æ ¼å¼åŒ–ã€è§£æ |
| `encoding` | base64_encodeã€hex_encodeã€url_encode |
| `env` | getenvã€setenvã€exitã€get_pid |
| `fmt` | å­—ç¬¦ä¸²æ ¼å¼åŒ–å·¥å…· |
| `fs` | read_fileã€write_fileã€list_dirã€exists |
| `glob` | æ–‡ä»¶æ¨¡å¼åŒ¹é… |
| `hash` | sha256ã€sha512ã€md5ã€djb2 |
| `http` | http_getã€http_postã€http_request |
| `ipc` | è¿›ç¨‹é—´é€šä¿¡ |
| `iter` | è¿­ä»£å™¨å·¥å…· |
| `json` | parseã€stringifyã€prettyã€getã€set |
| `logging` | å¸¦çº§åˆ«çš„æ—¥å¿—è®°å½•å™¨ |
| `math` | sinã€cosã€sqrtã€powã€randã€PIã€E |
| `net` | TcpListenerã€TcpStreamã€UdpSocket |
| `os` | platformã€archã€cpu_countã€hostname |
| `path` | æ–‡ä»¶è·¯å¾„æ“ä½œ |
| `process` | forkã€execã€waitã€kill |
| `random` | éšæœºæ•°ç”Ÿæˆ |
| `regex` | compileã€test (POSIX ERE) |
| `retry` | å¸¦é€€é¿çš„é‡è¯•é€»è¾‘ |
| `semver` | è¯­ä¹‰åŒ–ç‰ˆæœ¬æ§åˆ¶ |
| `shell` | Shell å‘½ä»¤å·¥å…· |
| `sqlite` | SQLite æ•°æ®åº“ã€queryã€execã€äº‹åŠ¡ |
| `strings` | pad_leftã€is_alphaã€reverseã€lines |
| `terminal` | ANSI é¢œè‰²å’Œæ ·å¼ |
| `testing` | describeã€testã€expect |
| `time` | nowã€time_msã€sleepã€clock |
| `toml` | TOML è§£æå’Œç”Ÿæˆ |
| `url` | URL è§£æå’Œæ“ä½œ |
| `uuid` | UUID ç”Ÿæˆ |
| `websocket` | WebSocket å®¢æˆ·ç«¯ |

è¯¦ç»†æ¨¡å—æ–‡æ¡£è¯·å‚é˜… `stdlib/docs/`ã€‚

---

## FFIï¼ˆå¤–éƒ¨å‡½æ•°æ¥å£ï¼‰

ä»å…±äº«åº“å£°æ˜å’Œè°ƒç”¨ C å‡½æ•°ï¼š
```hemlock
import "libc.so.6";

extern fn strlen(s: string): i32;
extern fn getpid(): i32;

let len = strlen("Hello!");  // 6
let pid = getpid();
```

ä»æ¨¡å—å¯¼å‡º FFI å‡½æ•°ï¼š
```hemlock
// string_utils.hml
import "libc.so.6";

export extern fn strlen(s: string): i32;
export fn string_length(s: string): i32 {
    return strlen(s);
}
```

åŠ¨æ€ FFIï¼ˆè¿è¡Œæ—¶ç»‘å®šï¼‰ï¼š
```hemlock
let lib = ffi_open("libc.so.6");
let puts = ffi_bind(lib, "puts", [FFI_POINTER], FFI_INT);
puts("Hello from C!");
ffi_close(lib);
```

ç±»å‹ï¼š`FFI_INT`ã€`FFI_DOUBLE`ã€`FFI_POINTER`ã€`FFI_STRING`ã€`FFI_VOID` ç­‰ã€‚

---

## åŸå­æ“ä½œ

ä½¿ç”¨åŸå­æ“ä½œè¿›è¡Œæ— é”å¹¶å‘ç¼–ç¨‹ï¼š

```hemlock
// ä¸ºåŸå­ i32 åˆ†é…å†…å­˜
let p = alloc(4);
ptr_write_i32(p, 0);

// åŸå­åŠ è½½/å­˜å‚¨
let val = atomic_load_i32(p);        // åŸå­è¯»å–
atomic_store_i32(p, 42);             // åŸå­å†™å…¥

// è·å–å¹¶ä¿®æ”¹æ“ä½œï¼ˆè¿”å›æ—§å€¼ï¼‰
let old = atomic_add_i32(p, 10);     // åŠ æ³•ï¼Œè¿”å›æ—§å€¼
old = atomic_sub_i32(p, 5);          // å‡æ³•ï¼Œè¿”å›æ—§å€¼
old = atomic_and_i32(p, 0xFF);       // æŒ‰ä½ä¸
old = atomic_or_i32(p, 0x10);        // æŒ‰ä½æˆ–
old = atomic_xor_i32(p, 0x0F);       // æŒ‰ä½å¼‚æˆ–

// æ¯”è¾ƒå¹¶äº¤æ¢ (CAS)
let success = atomic_cas_i32(p, 42, 100);  // å¦‚æœ *p == 42ï¼Œè®¾ç½®ä¸º 100
// å¦‚æœäº¤æ¢æˆåŠŸè¿”å› trueï¼Œå¦åˆ™è¿”å› false

// åŸå­äº¤æ¢
old = atomic_exchange_i32(p, 999);   // äº¤æ¢ï¼Œè¿”å›æ—§å€¼

free(p);

// å¯ç”¨ i64 å˜ä½“ (atomic_load_i64, atomic_add_i64, ç­‰)

// å†…å­˜å±éšœï¼ˆå®Œå…¨å±éšœï¼‰
atomic_fence();
```

æ‰€æœ‰æ“ä½œä½¿ç”¨é¡ºåºä¸€è‡´æ€§ï¼ˆ`memory_order_seq_cst`ï¼‰ã€‚

---

## é¡¹ç›®ç»“æ„

```
hemlock/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ frontend/         # å…±äº«ï¼šè¯æ³•åˆ†æå™¨ã€è§£æå™¨ã€ASTã€æ¨¡å—
â”‚   â”œâ”€â”€ backends/
â”‚   â”‚   â”œâ”€â”€ interpreter/  # hemlockï¼šæ ‘éå†è§£é‡Šå™¨
â”‚   â”‚   â””â”€â”€ compiler/     # hemlockcï¼šC ä»£ç ç”Ÿæˆå™¨
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ lsp/          # è¯­è¨€æœåŠ¡å™¨åè®®
â”‚   â”‚   â””â”€â”€ bundler/      # æ‰“åŒ…/åŒ…å·¥å…·
â”œâ”€â”€ runtime/              # ç¼–è¯‘ç¨‹åºè¿è¡Œæ—¶ (libhemlock_runtime.a)
â”œâ”€â”€ stdlib/               # æ ‡å‡†åº“ (40 ä¸ªæ¨¡å—)
â”‚   â””â”€â”€ docs/             # æ¨¡å—æ–‡æ¡£
â”œâ”€â”€ docs/                 # å®Œæ•´æ–‡æ¡£
â”‚   â”œâ”€â”€ language-guide/   # ç±»å‹ã€å­—ç¬¦ä¸²ã€æ•°ç»„ç­‰
â”‚   â”œâ”€â”€ reference/        # API å‚è€ƒ
â”‚   â””â”€â”€ advanced/         # å¼‚æ­¥ã€FFIã€ä¿¡å·ç­‰
â”œâ”€â”€ tests/                # 625+ æµ‹è¯•
â””â”€â”€ examples/             # ç¤ºä¾‹ç¨‹åº
```

---

## ä»£ç é£æ ¼æŒ‡å—

### å¸¸é‡å’Œé­”æ³•æ•°å­—

åœ¨å‘ C ä»£ç åº“æ·»åŠ æ•°å€¼å¸¸é‡æ—¶ï¼Œè¯·éµå¾ªä»¥ä¸‹å‡†åˆ™ï¼š

1. **åœ¨ `include/hemlock_limits.h` ä¸­å®šä¹‰å¸¸é‡** - æ­¤æ–‡ä»¶æ˜¯æ‰€æœ‰ç¼–è¯‘æ—¶å’Œè¿è¡Œæ—¶é™åˆ¶ã€å®¹é‡å’Œå‘½åå¸¸é‡çš„é›†ä¸­ä½ç½®ã€‚

2. **ä½¿ç”¨ `HML_` å‰ç¼€çš„æè¿°æ€§åç§°** - æ‰€æœ‰å¸¸é‡åº”ä»¥ `HML_` ä¸ºå‰ç¼€ä»¥æ˜ç¡®å‘½åç©ºé—´ã€‚

3. **é¿å…é­”æ³•æ•°å­—** - ç”¨å‘½åå¸¸é‡æ›¿æ¢ç¡¬ç¼–ç çš„æ•°å€¼ã€‚ç¤ºä¾‹ï¼š
   - ç±»å‹èŒƒå›´é™åˆ¶ï¼š`HML_I8_MIN`ã€`HML_I8_MAX`ã€`HML_U32_MAX`
   - ç¼“å†²åŒºå®¹é‡ï¼š`HML_INITIAL_ARRAY_CAPACITY`ã€`HML_INITIAL_LEXER_BUFFER_CAPACITY`
   - æ—¶é—´è½¬æ¢ï¼š`HML_NANOSECONDS_PER_SECOND`ã€`HML_MILLISECONDS_PER_SECOND`
   - å“ˆå¸Œç§å­ï¼š`HML_DJB2_HASH_SEED`
   - ASCII å€¼ï¼š`HML_ASCII_CASE_OFFSET`ã€`HML_ASCII_PRINTABLE_START`

4. **åŒ…å« `hemlock_limits.h`** - æºæ–‡ä»¶åº”åŒ…å«æ­¤å¤´æ–‡ä»¶ï¼ˆé€šå¸¸é€šè¿‡ `internal.h`ï¼‰ä»¥è®¿é—®å¸¸é‡ã€‚

5. **è®°å½•ç”¨é€”** - æ·»åŠ æ³¨é‡Šè¯´æ˜æ¯ä¸ªå¸¸é‡ä»£è¡¨ä»€ä¹ˆã€‚

---

## ç¦æ­¢äº‹é¡¹

- æ·»åŠ éšå¼è¡Œä¸ºï¼ˆASIã€GCã€è‡ªåŠ¨æ¸…ç†ï¼‰
- éšè—å¤æ‚æ€§ï¼ˆé­”æ³•ä¼˜åŒ–ã€éšè—å¼•ç”¨è®¡æ•°ï¼‰
- ç ´åç°æœ‰è¯­ä¹‰ï¼ˆåˆ†å·ã€æ‰‹åŠ¨å†…å­˜ã€å¯å˜å­—ç¬¦ä¸²ï¼‰
- åœ¨éšå¼è½¬æ¢ä¸­ä¸¢å¤±ç²¾åº¦
- ä½¿ç”¨é­”æ³•æ•°å­— - æ”¹ä¸ºåœ¨ `hemlock_limits.h` ä¸­å®šä¹‰å‘½åå¸¸é‡

---

## æµ‹è¯•

```bash
make test              # è¿è¡Œè§£é‡Šå™¨æµ‹è¯•
make test-compiler     # è¿è¡Œç¼–è¯‘å™¨æµ‹è¯•
make parity            # è¿è¡Œå¯¹ç­‰æµ‹è¯•ï¼ˆä¸¤è€…å¿…é¡»åŒ¹é…ï¼‰
make test-all          # è¿è¡Œæ‰€æœ‰æµ‹è¯•å¥—ä»¶
```

**é‡è¦ï¼š** ç”±äºå¼‚æ­¥/å¹¶å‘é—®é¢˜ï¼Œæµ‹è¯•å¯èƒ½ä¼šæŒ‚èµ·ã€‚è¿è¡Œæµ‹è¯•æ—¶å§‹ç»ˆä½¿ç”¨è¶…æ—¶ï¼š
```bash
timeout 60 make test   # 60 ç§’è¶…æ—¶
timeout 120 make parity
```

æµ‹è¯•ç±»åˆ«ï¼šprimitivesã€memoryã€stringsã€arraysã€functionsã€objectsã€asyncã€ffiã€deferã€signalsã€switchã€bitwiseã€typed_arraysã€modulesã€stdlib_*

---

## ç¼–è¯‘å™¨/è§£é‡Šå™¨æ¶æ„

Hemlock æœ‰ä¸¤ä¸ªå…±äº«é€šç”¨å‰ç«¯çš„æ‰§è¡Œåç«¯ï¼š

```
æºç  (.hml)
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å…±äº«å‰ç«¯                    â”‚
â”‚  - è¯æ³•åˆ†æå™¨ (src/frontend/)â”‚
â”‚  - è§£æå™¨ (src/frontend/)    â”‚
â”‚  - AST (src/frontend/)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   è§£é‡Šå™¨    â”‚    â”‚   ç¼–è¯‘å™¨    â”‚
â”‚ (hemlock)  â”‚    â”‚ (hemlockc) â”‚
â”‚            â”‚    â”‚            â”‚
â”‚ æ ‘éå†     â”‚    â”‚ ç±»å‹æ£€æŸ¥   â”‚
â”‚ æ±‚å€¼       â”‚    â”‚ AST â†’ C    â”‚
â”‚            â”‚    â”‚ gcc é“¾æ¥   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç¼–è¯‘å™¨ç±»å‹æ£€æŸ¥

ç¼–è¯‘å™¨ï¼ˆ`hemlockc`ï¼‰åŒ…å«ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ï¼Œ**é»˜è®¤å¯ç”¨**ï¼š

```bash
hemlockc program.hml -o program    # ç±»å‹æ£€æŸ¥ï¼Œç„¶åç¼–è¯‘
hemlockc --check program.hml       # ä»…ç±»å‹æ£€æŸ¥ï¼Œä¸ç¼–è¯‘
hemlockc --no-type-check prog.hml  # ç¦ç”¨ç±»å‹æ£€æŸ¥
hemlockc --strict-types prog.hml   # å¯¹éšå¼ 'any' ç±»å‹å‘å‡ºè­¦å‘Š
```

ç±»å‹æ£€æŸ¥å™¨ï¼š
- åœ¨ç¼–è¯‘æ—¶éªŒè¯ç±»å‹æ³¨è§£
- å°†æ— ç±»å‹ä»£ç è§†ä¸ºåŠ¨æ€ï¼ˆ`any` ç±»å‹ï¼‰- å§‹ç»ˆæœ‰æ•ˆ
- ä¸ºæ‹†ç®±æä¾›ä¼˜åŒ–æç¤º
- ä½¿ç”¨å®½æ¾çš„æ•°å€¼è½¬æ¢ï¼ˆèŒƒå›´åœ¨è¿è¡Œæ—¶éªŒè¯ï¼‰

### ç›®å½•ç»“æ„

```
hemlock/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ frontend/           # å…±äº«ï¼šè¯æ³•åˆ†æå™¨ã€è§£æå™¨ã€ASTã€æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ lexer.c
â”‚   â”‚   â”œâ”€â”€ parser/
â”‚   â”‚   â”œâ”€â”€ ast.c
â”‚   â”‚   â””â”€â”€ module.c
â”‚   â”œâ”€â”€ backends/
â”‚   â”‚   â”œâ”€â”€ interpreter/    # hemlockï¼šæ ‘éå†è§£é‡Šå™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ main.c
â”‚   â”‚   â”‚   â”œâ”€â”€ runtime/
â”‚   â”‚   â”‚   â””â”€â”€ builtins/
â”‚   â”‚   â””â”€â”€ compiler/       # hemlockcï¼šC ä»£ç ç”Ÿæˆå™¨
â”‚   â”‚       â”œâ”€â”€ main.c
â”‚   â”‚       â””â”€â”€ codegen/
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ lsp/            # è¯­è¨€æœåŠ¡å™¨
â”‚   â”‚   â””â”€â”€ bundler/        # æ‰“åŒ…/åŒ…å·¥å…·
â”œâ”€â”€ runtime/                # ç¼–è¯‘ç¨‹åºçš„ libhemlock_runtime.a
â”œâ”€â”€ stdlib/                 # å…±äº«æ ‡å‡†åº“
â””â”€â”€ tests/
    â”œâ”€â”€ parity/             # å¿…é¡»é€šè¿‡ä¸¤ä¸ªåç«¯çš„æµ‹è¯•
    â”œâ”€â”€ interpreter/        # è§£é‡Šå™¨ç‰¹å®šæµ‹è¯•
    â””â”€â”€ compiler/           # ç¼–è¯‘å™¨ç‰¹å®šæµ‹è¯•
```

---

## å¯¹ç­‰ä¼˜å…ˆå¼€å‘

**è§£é‡Šå™¨å’Œç¼–è¯‘å™¨å¿…é¡»å¯¹ç›¸åŒè¾“å…¥äº§ç”Ÿç›¸åŒè¾“å‡ºã€‚**

### å¼€å‘ç­–ç•¥

æ·»åŠ æˆ–ä¿®æ”¹è¯­è¨€ç‰¹æ€§æ—¶ï¼š

1. **è®¾è®¡** - åœ¨å…±äº«å‰ç«¯å®šä¹‰ AST/è¯­ä¹‰æ›´æ”¹
2. **å®ç°è§£é‡Šå™¨** - æ·»åŠ æ ‘éå†æ±‚å€¼
3. **å®ç°ç¼–è¯‘å™¨** - æ·»åŠ  C ä»£ç ç”Ÿæˆ
4. **æ·»åŠ å¯¹ç­‰æµ‹è¯•** - åœ¨ `tests/parity/` ä¸­ç¼–å†™å¸¦ `.expected` æ–‡ä»¶çš„æµ‹è¯•
5. **éªŒè¯** - åˆå¹¶å‰è¿è¡Œ `make parity`

### å¯¹ç­‰æµ‹è¯•ç»“æ„

```
tests/parity/
â”œâ”€â”€ language/       # æ ¸å¿ƒè¯­è¨€ç‰¹æ€§ï¼ˆæ§åˆ¶æµã€é—­åŒ…ç­‰ï¼‰
â”œâ”€â”€ builtins/       # å†…ç½®å‡½æ•°ï¼ˆprintã€typeofã€memory ç­‰ï¼‰
â”œâ”€â”€ methods/        # å­—ç¬¦ä¸²å’Œæ•°ç»„æ–¹æ³•
â””â”€â”€ modules/        # import/exportã€stdlib å¯¼å…¥
```

æ¯ä¸ªæµ‹è¯•æœ‰ä¸¤ä¸ªæ–‡ä»¶ï¼š
- `feature.hml` - æµ‹è¯•ç¨‹åº
- `feature.expected` - é¢„æœŸè¾“å‡ºï¼ˆä¸¤ä¸ªåç«¯å¿…é¡»åŒ¹é…ï¼‰

### å¯¹ç­‰æµ‹è¯•ç»“æœ

| çŠ¶æ€ | å«ä¹‰ |
|--------|---------|
| `PASSED` | è§£é‡Šå™¨å’Œç¼–è¯‘å™¨éƒ½åŒ¹é…é¢„æœŸè¾“å‡º |
| `INTERP_ONLY` | è§£é‡Šå™¨å·¥ä½œï¼Œç¼–è¯‘å™¨å¤±è´¥ï¼ˆéœ€è¦ä¿®å¤ç¼–è¯‘å™¨ï¼‰ |
| `COMPILER_ONLY` | ç¼–è¯‘å™¨å·¥ä½œï¼Œè§£é‡Šå™¨å¤±è´¥ï¼ˆç½•è§ï¼‰ |
| `FAILED` | ä¸¤è€…éƒ½å¤±è´¥ï¼ˆæµ‹è¯•æˆ–å®ç°é”™è¯¯ï¼‰ |

### éœ€è¦å¯¹ç­‰çš„å†…å®¹

- æ‰€æœ‰è¯­è¨€ç»“æ„ï¼ˆifã€whileã€forã€switchã€deferã€try/catchï¼‰
- æ‰€æœ‰è¿ç®—ç¬¦ï¼ˆç®—æœ¯ã€ä½ã€é€»è¾‘ã€æ¯”è¾ƒï¼‰
- æ‰€æœ‰å†…ç½®å‡½æ•°ï¼ˆprintã€typeofã€alloc ç­‰ï¼‰
- æ‰€æœ‰å­—ç¬¦ä¸²å’Œæ•°ç»„æ–¹æ³•
- ç±»å‹å¼ºåˆ¶å’Œæå‡è§„åˆ™
- è¿è¡Œæ—¶é”™è¯¯çš„é”™è¯¯æ¶ˆæ¯

### å¯èƒ½ä¸åŒçš„å†…å®¹

- æ€§èƒ½ç‰¹å¾
- å†…å­˜å¸ƒå±€ç»†èŠ‚
- è°ƒè¯•/å †æ ˆè·Ÿè¸ªæ ¼å¼
- ç¼–è¯‘é”™è¯¯ï¼ˆç¼–è¯‘å™¨å¯èƒ½åœ¨ç¼–è¯‘æ—¶æ•è·æ›´å¤šï¼‰

### æ·»åŠ å¯¹ç­‰æµ‹è¯•

```bash
# 1. åˆ›å»ºæµ‹è¯•æ–‡ä»¶
cat > tests/parity/language/my_feature.hml << 'EOF'
// æµ‹è¯•æè¿°
let x = some_feature();
print(x);
EOF

# 2. ä»è§£é‡Šå™¨ç”Ÿæˆé¢„æœŸè¾“å‡º
./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected

# 3. éªŒè¯å¯¹ç­‰
make parity
```

---

## ç‰ˆæœ¬

**v1.8.0** - å½“å‰ç‰ˆæœ¬ç‰¹æ€§ï¼š
- **æ¨¡å¼åŒ¹é…**ï¼ˆ`match` è¡¨è¾¾å¼ï¼‰- å¼ºå¤§çš„è§£æ„å’Œæ§åˆ¶æµï¼š
  - å­—é¢é‡ã€é€šé…ç¬¦å’Œå˜é‡ç»‘å®šæ¨¡å¼
  - OR æ¨¡å¼ï¼ˆ`1 | 2 | 3`ï¼‰
  - å®ˆå«è¡¨è¾¾å¼ï¼ˆ`n if n > 0`ï¼‰
  - å¯¹è±¡è§£æ„ï¼ˆ`{ x, y }`ï¼‰
  - å¸¦å‰©ä½™éƒ¨åˆ†çš„æ•°ç»„è§£æ„ï¼ˆ`[first, ...rest]`ï¼‰
  - ç±»å‹æ¨¡å¼ï¼ˆ`n: i32`ï¼‰
  - è§£é‡Šå™¨å’Œç¼–è¯‘å™¨å®Œå…¨å¯¹ç­‰
- **ç¼–è¯‘å™¨è¾…åŠ©æ³¨è§£** - 11 ä¸ªç”¨äº GCC/Clang æ§åˆ¶çš„ä¼˜åŒ–æ³¨è§£ï¼š
  - `@inline`ã€`@noinline` - å‡½æ•°å†…è”æ§åˆ¶
  - `@hot`ã€`@cold` - åˆ†æ”¯é¢„æµ‹æç¤º
  - `@pure`ã€`@const` - å‰¯ä½œç”¨æ³¨è§£
  - `@flatten` - å†…è”å‡½æ•°å†…çš„æ‰€æœ‰è°ƒç”¨
  - `@optimize(level)` - æ¯å‡½æ•°ä¼˜åŒ–çº§åˆ«ï¼ˆ"0"ã€"1"ã€"2"ã€"3"ã€"s"ã€"fast"ï¼‰
  - `@warn_unused` - å¿½ç•¥è¿”å›å€¼æ—¶è­¦å‘Š
  - `@section(name)` - è‡ªå®šä¹‰ ELF èŠ‚æ”¾ç½®ï¼ˆä¾‹å¦‚ `@section(".text.hot")`ï¼‰
- **è¡¨è¾¾å¼ä½“å‡½æ•°**ï¼ˆ`fn double(x): i32 => x * 2;`ï¼‰- ç®€æ´çš„å•è¡¨è¾¾å¼å‡½æ•°è¯­æ³•
- **å•è¡Œè¯­å¥** - æ— èŠ±æ‹¬å·çš„ `if`ã€`while`ã€`for` è¯­æ³•ï¼ˆä¾‹å¦‚ `if (x > 0) print(x);`ï¼‰
- **ç±»å‹åˆ«å**ï¼ˆ`type Name = Type;`ï¼‰- å¤æ‚ç±»å‹çš„å‘½åå¿«æ·æ–¹å¼
- **å‡½æ•°ç±»å‹æ³¨è§£**ï¼ˆ`fn(i32): i32`ï¼‰- ä¸€ç­‰å‡½æ•°ç±»å‹
- **Const å‚æ•°**ï¼ˆ`fn(const x: array)`ï¼‰- å‚æ•°çš„æ·±åº¦ä¸å¯å˜æ€§
- **Ref å‚æ•°**ï¼ˆ`fn(ref x: i32)`ï¼‰- æŒ‰å¼•ç”¨ä¼ é€’ç”¨äºç›´æ¥ä¿®æ”¹è°ƒç”¨è€…
- **define ä¸­çš„æ–¹æ³•ç­¾å**ï¼ˆ`fn method(): Type`ï¼‰- ç±»ä¼¼æ¥å£çš„å¥‘çº¦ï¼ˆé€—å·åˆ†éš”ï¼‰
- æ–¹æ³•ç­¾åä¸­çš„ **Self ç±»å‹** - æŒ‡å‘å®šä¹‰ç±»å‹
- **loop å…³é”®å­—**ï¼ˆ`loop { }`ï¼‰- æ›´æ¸…æ™°çš„æ— é™å¾ªç¯ï¼Œæ›¿ä»£ `while (true)`
- **å¾ªç¯æ ‡ç­¾**ï¼ˆ`outer: while`ï¼‰- åµŒå¥—å¾ªç¯çš„å®šå‘ break/continue
- **å¯¹è±¡ç®€å†™**ï¼ˆ`{ name }`ï¼‰- ES6 é£æ ¼ç®€å†™å±æ€§è¯­æ³•
- **å¯¹è±¡å±•å¼€**ï¼ˆ`{ ...obj }`ï¼‰- å¤åˆ¶å’Œåˆå¹¶å¯¹è±¡å­—æ®µ
- **å¤åˆé¸­å­ç±»å‹**ï¼ˆ`A & B & C`ï¼‰- ç»“æ„ç±»å‹çš„äº¤å‰ç±»å‹
- å‡½æ•°è°ƒç”¨çš„**å‘½åå‚æ•°**ï¼ˆ`foo(name: "value", age: 30)`ï¼‰
- **ç©ºå€¼åˆå¹¶è¿ç®—ç¬¦**ï¼ˆ`??`ã€`??=`ã€`?.`ï¼‰ç”¨äºå®‰å…¨çš„ç©ºå€¼å¤„ç†
- **å…«è¿›åˆ¶å­—é¢é‡**ï¼ˆ`0o777`ã€`0O123`ï¼‰
- **æ•°å­—åˆ†éš”ç¬¦**ï¼ˆ`1_000_000`ã€`0xFF_FF`ã€`0b1111_0000`ï¼‰
- **å—æ³¨é‡Š**ï¼ˆ`/* ... */`ï¼‰
- å­—ç¬¦ä¸²/rune ä¸­çš„**åå…­è¿›åˆ¶è½¬ä¹‰åºåˆ—**ï¼ˆ`\x41` = 'A'ï¼‰
- å­—ç¬¦ä¸²ä¸­çš„ **Unicode è½¬ä¹‰åºåˆ—**ï¼ˆ`\u{1F600}` = ğŸ˜€ï¼‰
- **æ— å‰å¯¼é›¶çš„æµ®ç‚¹å­—é¢é‡**ï¼ˆ`.5`ã€`.123`ã€`.5e2`ï¼‰
- hemlockc ä¸­çš„**ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥**ï¼ˆé»˜è®¤å¯ç”¨ï¼‰
- **LSP é›†æˆ**ï¼Œå¸¦å®æ—¶è¯Šæ–­çš„ç±»å‹æ£€æŸ¥
- **å¤åˆèµ‹å€¼è¿ç®—ç¬¦**ï¼ˆ`+=`ã€`-=`ã€`*=`ã€`/=`ã€`%=`ã€`&=`ã€`|=`ã€`^=`ã€`<<=`ã€`>>=`ï¼‰
- **è‡ªå¢/è‡ªå‡è¿ç®—ç¬¦**ï¼ˆ`++x`ã€`x++`ã€`--x`ã€`x--`ï¼‰
- **ç±»å‹ç²¾åº¦ä¿®å¤**ï¼ši64/u64 + f32 â†’ f64 ä»¥ä¿æŒç²¾åº¦
- å¸¦æ‹†ç®±ä¼˜åŒ–æç¤ºçš„ç»Ÿä¸€ç±»å‹ç³»ç»Ÿ
- å®Œæ•´ç±»å‹ç³»ç»Ÿï¼ˆi8-i64ã€u8-u64ã€f32/f64ã€boolã€stringã€runeã€ptrã€bufferã€arrayã€objectã€enumã€fileã€taskã€channelï¼‰
- å¸¦ 19 ä¸ªæ–¹æ³•çš„ UTF-8 å­—ç¬¦ä¸²
- å¸¦ 18 ä¸ªæ–¹æ³•çš„æ•°ç»„ï¼ŒåŒ…æ‹¬ map/filter/reduce
- å¸¦ `talloc()` å’Œ `sizeof()` çš„æ‰‹åŠ¨å†…å­˜ç®¡ç†
- å¸¦çœŸæ­£ pthread å¹¶è¡Œçš„ async/await
- ç”¨äºæ— é”å¹¶å‘ç¼–ç¨‹çš„åŸå­æ“ä½œ
- 40 ä¸ª stdlib æ¨¡å—ï¼ˆ+ arenaã€assertã€semverã€tomlã€retryã€iterã€randomã€shellï¼‰
- C äº’æ“ä½œçš„ FFIï¼Œå¸¦ `export extern fn` ç”¨äºå¯é‡ç”¨åº“åŒ…è£…
- ç¼–è¯‘å™¨ä¸­çš„ FFI ç»“æ„æ”¯æŒï¼ˆæŒ‰å€¼ä¼ é€’ C ç»“æ„ï¼‰
- FFI æŒ‡é’ˆè¾…åŠ©å‡½æ•°ï¼ˆ`ptr_null`ã€`ptr_read_*`ã€`ptr_write_*`ï¼‰
- deferã€try/catch/finally/throwã€panic
- æ–‡ä»¶ I/Oã€ä¿¡å·å¤„ç†ã€å‘½ä»¤æ‰§è¡Œ
- [hpm](https://github.com/hemlang/hpm) åŒ…ç®¡ç†å™¨ï¼Œå¸¦åŸºäº GitHub çš„æ³¨å†Œè¡¨
- ç¼–è¯‘å™¨åç«¯ï¼ˆC ä»£ç ç”Ÿæˆï¼‰ï¼Œ100% è§£é‡Šå™¨å¯¹ç­‰
- LSP æœåŠ¡å™¨ï¼Œå¸¦è·³è½¬åˆ°å®šä¹‰å’ŒæŸ¥æ‰¾å¼•ç”¨
- AST ä¼˜åŒ–éå†å’Œ O(1) æŸ¥æ‰¾çš„å˜é‡è§£æ
- apply() å†…ç½®å‡½æ•°ç”¨äºåŠ¨æ€å‡½æ•°è°ƒç”¨
- æ— ç¼“å†² channel å’Œå¤šå‚æ•°æ”¯æŒ
- 159 ä¸ªå¯¹ç­‰æµ‹è¯•ï¼ˆ100% é€šè¿‡ç‡ï¼‰

---

## ç†å¿µ

> æˆ‘ä»¬æä¾›å®‰å…¨çš„å·¥å…·ï¼ˆ`buffer`ã€ç±»å‹æ³¨è§£ã€è¾¹ç•Œæ£€æŸ¥ï¼‰ï¼Œä½†ä¸å¼ºåˆ¶ä½ ä½¿ç”¨å®ƒä»¬ï¼ˆ`ptr`ã€æ‰‹åŠ¨å†…å­˜ã€éå®‰å…¨æ“ä½œï¼‰ã€‚

**å¦‚æœä½ ä¸ç¡®å®šæŸä¸ªç‰¹æ€§æ˜¯å¦é€‚åˆ Hemlockï¼Œè¯·é—®è‡ªå·±ï¼š"è¿™æ˜¯ç»™ç¨‹åºå‘˜æ›´å¤šæ˜¾å¼æ§åˆ¶ï¼Œè¿˜æ˜¯éšè—äº†ä»€ä¹ˆï¼Ÿ"**

å¦‚æœæ˜¯éšè—ï¼Œå®ƒå¯èƒ½ä¸å±äº Hemlockã€‚
