<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hemlock言語マニュアル</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sage: #9CAF88;
            --pine: #2F4F4F;
            --dark-pine: #1a2f2f;
            --light-sage: #E8F4E1;
            --cream: #FAF9F6;
            --text: #2C3E2C;
            --text-light: #5A6F5A;
            --border: #D4E4CB;
            --code-bg: #F5F9F3;
            --accent: #6B8E6B;
        }

        [data-theme="dark"] {
            --sage: #6B8E6B;
            --pine: #9CAF88;
            --dark-pine: #0d1a1a;
            --light-sage: #1a2f2f;
            --cream: #0f1a1a;
            --text: #e0e8e0;
            --text-light: #a8b8a8;
            --border: #2a4a4a;
            --code-bg: #162626;
            --accent: #9CAF88;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) {
                --sage: #6B8E6B;
                --pine: #9CAF88;
                --dark-pine: #0d1a1a;
                --light-sage: #1a2f2f;
                --cream: #0f1a1a;
                --text: #e0e8e0;
                --text-light: #a8b8a8;
                --border: #2a4a4a;
                --code-bg: #162626;
                --accent: #9CAF88;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            line-height: 1.7;
            color: var(--text);
            background: var(--cream);
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: #2F4F4F;
            color: white;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 1rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .header-logo {
            height: 45px;
            margin-right: 1rem;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            margin-right: auto;
        }

        @media (max-width: 1023px) {
            .header {
                justify-content: flex-start;
            }
            .header h1 {
                display: none;
            }
        }

        /* Layout */
        .container {
            display: flex;
            margin-top: 70px;
            min-height: calc(100vh - 70px);
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 70px;
            width: 280px;
            height: calc(100vh - 70px);
            background: var(--light-sage);
            border-right: 2px solid var(--border);
            overflow-y: auto;
            padding: 2rem 0;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 900;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        @media (min-width: 1024px) {
            .sidebar {
                transform: translateX(0);
            }
        }

        .nav-section {
            margin-bottom: 1.5rem;
        }

        .nav-section-title {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--pine);
            padding: 0 1.5rem;
            margin-bottom: 0.5rem;
        }

        .nav-link {
            display: block;
            padding: 0.5rem 1.5rem;
            color: var(--text);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .nav-link:hover {
            background: rgba(47, 79, 79, 0.05);
            border-left-color: var(--sage);
        }

        .nav-link.active {
            background: rgba(47, 79, 79, 0.1);
            border-left-color: var(--pine);
            font-weight: 600;
            color: var(--pine);
        }

        /* Mobile Menu Toggle */
        .menu-toggle {
            display: none;
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            margin-right: 0.5rem;
        }

        @media (max-width: 1023px) {
            .menu-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }

        /* Main Content */
        .main-content {
            flex: 1;
            margin-left: 0;
            padding: 3rem 2rem;
            max-width: 900px;
        }

        @media (min-width: 1024px) {
            .main-content {
                margin-left: 280px;
            }
        }

        /* Typography */
        .content h1 {
            font-size: 2.5rem;
            color: var(--pine);
            margin: 2rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--sage);
        }

        .content h2 {
            font-size: 2rem;
            color: var(--pine);
            margin: 3rem 0 1rem;
            padding-top: 1rem;
        }

        .content h3 {
            font-size: 1.5rem;
            color: var(--accent);
            margin: 2rem 0 1rem;
        }

        .content h4 {
            font-size: 1.2rem;
            color: var(--accent);
            margin: 1.5rem 0 0.8rem;
        }

        .content p {
            margin: 1rem 0;
            color: var(--text);
        }

        .content ul, .content ol {
            margin: 1rem 0 1rem 2rem;
        }

        .content li {
            margin: 0.5rem 0;
        }

        .content blockquote {
            border-left: 4px solid var(--sage);
            background: var(--light-sage);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: var(--text-light);
        }

        .content hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }

        /* Code Blocks */
        .content code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--pine);
        }

        .code-block {
            margin: 1.5rem 0;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: var(--code-bg);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--pine);
            color: var(--light-sage);
            font-size: 0.8rem;
        }

        .code-lang {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-weight: 600;
            text-transform: lowercase;
        }

        .copy-btn {
            background: transparent;
            border: 1px solid var(--sage);
            color: var(--light-sage);
            padding: 0.3rem 0.7rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .copy-btn:hover {
            background: var(--sage);
            color: var(--pine);
        }

        .copy-btn.copied {
            background: var(--sage);
            color: var(--pine);
            border-color: var(--sage);
        }

        .copy-btn svg {
            width: 14px;
            height: 14px;
        }

        .content pre {
            background: var(--code-bg);
            margin: 0;
            padding: 1.2rem;
            overflow-x: auto;
        }

        .content pre code {
            background: none;
            padding: 0;
            border-radius: 0;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        /* Standalone pre without code-block wrapper (legacy) */
        .content > pre {
            border: 1px solid var(--border);
            border-left: 4px solid var(--pine);
            border-radius: 4px;
            margin: 1.5rem 0;
        }

        /* Tables */
        .content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        .content th,
        .content td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .content th {
            background: var(--light-sage);
            color: var(--pine);
            font-weight: 600;
        }

        /* Links */
        .content a {
            color: var(--accent);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .content a:hover {
            border-bottom-color: var(--accent);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--cream);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--sage);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* Section anchors */
        .section-anchor {
            scroll-margin-top: 90px;
        }

        /* Mobile adjustments */
        @media (max-width: 1023px) {
            .main-content {
                padding: 2rem 1rem;
            }

            .content h1 {
                font-size: 2rem;
            }

            .content h2 {
                font-size: 1.6rem;
            }

            .content h3 {
                font-size: 1.3rem;
            }
        }

        /* Page switching */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* Search */
        .search-container {
            position: relative;
            margin-right: 1rem;
        }

        .search-input {
            width: 200px;
            padding: 0.5rem 1rem;
            padding-left: 2.2rem;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.25);
            width: 280px;
        }

        .search-icon {
            position: absolute;
            left: 0.8rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
        }

        .search-results {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            right: 0;
            min-width: 320px;
            max-height: 400px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1001;
        }

        .search-results.active {
            display: block;
        }

        .search-result {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s;
        }

        .search-result:last-child {
            border-bottom: none;
        }

        .search-result:hover,
        .search-result.selected {
            background: var(--light-sage);
        }

        .search-result-title {
            font-weight: 600;
            color: var(--pine);
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
        }

        .search-result-section {
            font-size: 0.75rem;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .search-result-preview {
            font-size: 0.85rem;
            color: var(--text-light);
            margin-top: 0.25rem;
            line-height: 1.4;
        }

        .search-result-preview mark {
            background: var(--sage);
            color: var(--pine);
            padding: 0 2px;
            border-radius: 2px;
        }

        .search-no-results {
            padding: 1rem;
            text-align: center;
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .search-shortcut {
            display: none;
            margin-left: 0.5rem;
            padding: 0.15rem 0.4rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.8);
        }

        @media (min-width: 1024px) {
            .search-shortcut {
                display: inline-block;
            }
        }

        @media (max-width: 1023px) {
            .search-container {
                position: fixed;
                top: 70px;
                left: 0;
                right: 0;
                margin: 0;
                padding: 0.5rem;
                background: #1a2f2f;
                display: none;
                z-index: 999;
            }

            .search-container.active {
                display: block;
            }

            .search-input {
                width: 100%;
            }

            .search-input:focus {
                width: 100%;
            }

            .search-results {
                position: fixed;
                top: 120px;
                left: 0.5rem;
                right: 0.5rem;
                min-width: auto;
                max-height: calc(100vh - 140px);
            }

            .search-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
                background: transparent;
                border: none;
                color: white;
                font-size: 1.2rem;
                cursor: pointer;
                padding: 0.5rem;
                margin-left: auto;
            }
        }

        @media (min-width: 1024px) {
            .search-toggle {
                display: none;
            }
        }

        /* Theme Toggle */
        .theme-toggle {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            margin-left: 4px;
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .theme-toggle svg {
            width: 20px;
            height: 20px;
        }

        .theme-toggle .sun-icon {
            display: none;
        }

        .theme-toggle .moon-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .sun-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .moon-icon {
            display: none;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) .theme-toggle .sun-icon {
                display: block;
            }
            :root:not([data-theme="light"]) .theme-toggle .moon-icon {
                display: none;
            }
        }

        /* Language Switcher */
        .lang-switcher {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.4rem 0.4rem;
            border-radius: 8px;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }

        .lang-switcher:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher:focus {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher option {
            background: var(--pine);
            color: white;
        }

        [data-theme="dark"] .lang-switcher option {
            background: var(--bg-primary);
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <button class="menu-toggle" id="menuToggle" aria-label="Toggle navigation menu" aria-expanded="false">&#9776;</button>
        <img src="data:image/png;base64,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" alt="Hemlock Logo" class="header-logo">
        <h1>Hemlock言語マニュアル</h1>
        <!-- Search -->
        <div class="search-container" id="searchContainer">
            <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
            <input type="text" class="search-input" id="searchInput" placeholder="Search docs..." autocomplete="off" aria-label="Search documentation">
            <span class="search-shortcut">Ctrl+K</span>
            <div class="search-results" id="searchResults" role="listbox" aria-label="Search results"></div>
        </div>
        <button class="search-toggle" id="searchToggle" aria-label="Toggle search">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
        </button>
        <select class="lang-switcher" id="langSwitcher" onchange="switchLanguage(this.value)" aria-label="Select language">
            <option value="docs.html" >English</option>
<option value="docs-zh.html" >中文</option>
<option value="docs-de.html" >Deutsch</option>
<option value="docs-es.html" >Español</option>
<option value="docs-fr.html" >Français</option>
<option value="docs-it.html" >Italiano</option>
<option value="docs-ja.html" selected>日本語</option>
<option value="docs-pt.html" >Português</option>
<option value="docs-ru.html" >Русский</option>
        </select>
        <button class="theme-toggle" id="themeToggle" title="Toggle dark mode" aria-label="Toggle dark mode">
            <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
            <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
        </button>
    </div>

    <!-- Container -->
    <div class="container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar" id="sidebar" aria-label="Documentation navigation">
            <div class="nav-section">
<a href="#welcome" class="nav-link" data-page="welcome">ようこそ</a>
</div>
<a href="#language-reference" class="nav-link" data-page="language-reference">言語リファレンス</a>
<div class="nav-section">
<div class="nav-section-title">はじめに</div>
<a href="#getting-started-installation" class="nav-link" data-page="getting-started-installation">インストール</a>
<a href="#getting-started-quick-start" class="nav-link" data-page="getting-started-quick-start">クイックスタート</a>
<a href="#getting-started-tutorial" class="nav-link" data-page="getting-started-tutorial">チュートリアル</a>
<a href="#getting-started-learning-paths" class="nav-link" data-page="getting-started-learning-paths">学習パス</a>
</div>
<div class="nav-section">
<div class="nav-section-title">言語ガイド</div>
<a href="#language-guide-error-handling" class="nav-link" data-page="language-guide-error-handling">エラー処理</a>
<a href="#language-guide-objects" class="nav-link" data-page="language-guide-objects">オブジェクト</a>
<a href="#language-guide-pattern-matching" class="nav-link" data-page="language-guide-pattern-matching">パターンマッチング</a>
<a href="#language-guide-memory" class="nav-link" data-page="language-guide-memory">メモリ管理</a>
<a href="#language-guide-modules" class="nav-link" data-page="language-guide-modules">モジュール</a>
<a href="#language-guide-runes" class="nav-link" data-page="language-guide-runes">ルーン</a>
<a href="#language-guide-control-flow" class="nav-link" data-page="language-guide-control-flow">制御フロー</a>
<a href="#language-guide-types" class="nav-link" data-page="language-guide-types">型</a>
<a href="#language-guide-strings" class="nav-link" data-page="language-guide-strings">文字列</a>
<a href="#language-guide-syntax" class="nav-link" data-page="language-guide-syntax">構文</a>
<a href="#language-guide-arrays" class="nav-link" data-page="language-guide-arrays">配列</a>
<a href="#language-guide-functions" class="nav-link" data-page="language-guide-functions">関数</a>
</div>
<div class="nav-section">
<div class="nav-section-title">高度なトピック</div>
<a href="#advanced-ffi" class="nav-link" data-page="advanced-ffi">FFI</a>
<a href="#advanced-file-io" class="nav-link" data-page="advanced-file-io">File IO</a>
<a href="#advanced-memory-ownership" class="nav-link" data-page="advanced-memory-ownership">Memory Ownership</a>
<a href="#advanced-atomics" class="nav-link" data-page="advanced-atomics">アトミック操作</a>
<a href="#advanced-command-line-args" class="nav-link" data-page="advanced-command-line-args">コマンドライン引数</a>
<a href="#advanced-command-execution" class="nav-link" data-page="advanced-command-execution">コマンド実行</a>
<a href="#advanced-signals" class="nav-link" data-page="advanced-signals">シグナル処理</a>
<a href="#advanced-bundling-packaging" class="nav-link" data-page="advanced-bundling-packaging">バンドルとパッケージング</a>
<a href="#advanced-profiling" class="nav-link" data-page="advanced-profiling">プロファイリング</a>
<a href="#advanced-async-concurrency" class="nav-link" data-page="advanced-async-concurrency">非同期と並行処理</a>
</div>
<div class="nav-section">
<div class="nav-section-title">APIリファレンス</div>
<a href="#reference-file-api" class="nav-link" data-page="reference-file-api">ファイルAPI</a>
<a href="#reference-memory-api" class="nav-link" data-page="reference-memory-api">メモリAPI</a>
<a href="#reference-concurrency-api" class="nav-link" data-page="reference-concurrency-api">並行処理API</a>
<a href="#reference-type-system" class="nav-link" data-page="reference-type-system">型システム</a>
<a href="#reference-string-api" class="nav-link" data-page="reference-string-api">文字列API</a>
<a href="#reference-operators" class="nav-link" data-page="reference-operators">演算子</a>
<a href="#reference-builtins" class="nav-link" data-page="reference-builtins">組み込み関数</a>
<a href="#reference-array-api" class="nav-link" data-page="reference-array-api">配列API</a>
</div>
<div class="nav-section">
<div class="nav-section-title">設計と思想</div>
<a href="#design-signature-syntax" class="nav-link" data-page="design-signature-syntax">シグネチャ構文</a>
<a href="#design-implementation" class="nav-link" data-page="design-implementation">実装の詳細</a>
<a href="#design-philosophy" class="nav-link" data-page="design-philosophy">設計思想</a>
</div>
<div class="nav-section">
<div class="nav-section-title">コントリビューション</div>
<a href="#contributing-guidelines" class="nav-link" data-page="contributing-guidelines">ガイドライン</a>
<a href="#contributing-testing" class="nav-link" data-page="contributing-testing">テスト</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: はじめに</div>
<a href="#hpm-installation" class="nav-link" data-page="hpm-installation">インストール</a>
<a href="#hpm-quick-start" class="nav-link" data-page="hpm-quick-start">クイックスタート</a>
<a href="#hpm-project-setup" class="nav-link" data-page="hpm-project-setup">プロジェクトセットアップ</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: ユーザーガイド</div>
<a href="#hpm-commands" class="nav-link" data-page="hpm-commands">コマンド</a>
<a href="#hpm-troubleshooting" class="nav-link" data-page="hpm-troubleshooting">トラブルシューティング</a>
<a href="#hpm-configuration" class="nav-link" data-page="hpm-configuration">設定</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: パッケージ開発</div>
<a href="#hpm-versioning" class="nav-link" data-page="hpm-versioning">バージョニング</a>
<a href="#hpm-creating-packages" class="nav-link" data-page="hpm-creating-packages">パッケージの作成</a>
<a href="#hpm-package-spec" class="nav-link" data-page="hpm-package-spec">パッケージ仕様</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: リファレンス</div>
<a href="#hpm-architecture" class="nav-link" data-page="hpm-architecture">アーキテクチャ</a>
<a href="#hpm-exit-codes" class="nav-link" data-page="hpm-exit-codes">終了コード</a>
</div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <div class="content" id="content"></div>
        </main>
    </div>

    <script>
        // Embedded documentation pages
        const PAGES = {"ようこそ": {"id": "welcome", "content": "# Hemlock へようこそ\n\n> 「安全でないものを安全に書くための、小さく安全でない言語」\n\n**Hemlock** は、C言語のパワーとモダンなスクリプトの使いやすさを組み合わせたシステムスクリプト言語です。手動メモリ管理、明示的な制御、構造化された非同期並行処理が組み込まれています。\n\n## Hemlock とは？\n\nHemlock は以下を求めるプログラマー向けに設計されています：\n\n- メモリと実行の**明示的な制御**\n- モダンな利便性を備えた**C言語ライクな構文**\n- **隠れた動作やマジックがない**\n- pthread ベースの並行処理による**真の並列非同期**\n\nHemlock はガベージコレクション付きのメモリ安全な言語ではありません。代わりに、安全のためのツール（`buffer`、型アノテーション、境界チェック）を提供しますが、それらの使用を強制しません（`ptr`、手動メモリ管理、安全でない操作）。\n\n## クイック例\n\n```hemlock\n// こんにちは、Hemlock！\nfn greet(name: string): string {\n    return `こんにちは、${name}！`;\n}\n\nlet message = greet(\"世界\");\nprint(message);\n\n// 手動メモリ管理\nlet buf = buffer(64);\nbuf[0] = 72;  // 'H'\nbuf[1] = 105; // 'i'\nprint(buf);\nfree(buf);\n```\n\n## 機能一覧\n\n| 機能 | 説明 |\n|------|------|\n| **型システム** | i8-i64、u8-u64、f32/f64、bool、string、rune、ptr、buffer、array、object |\n| **メモリ** | `alloc()`、`buffer()`、`free()` による手動管理 |\n| **非同期** | 組み込みの `async`/`await` と真の pthread 並列処理 |\n| **FFI** | 共有ライブラリから C 関数を直接呼び出し |\n| **標準ライブラリ** | crypto、http、sqlite、json など40のモジュール |\n\n## はじめに\n\n始める準備はできましたか？以下の手順で始めましょう：\n\n1. **[インストール](#getting-started-installation)** - Hemlock をダウンロードしてセットアップ\n2. **[クイックスタート](#getting-started-quick-start)** - 数分で最初のプログラムを作成\n3. **[チュートリアル](#getting-started-tutorial)** - ステップバイステップで Hemlock を学ぶ\n\n## ドキュメントセクション\n\n- **はじめに** - インストール、クイックスタートガイド、チュートリアル\n- **言語ガイド** - 構文、型、関数などの詳細\n- **高度なトピック** - 非同期プログラミング、FFI、シグナル、アトミック操作\n- **APIリファレンス** - 組み込み関数と標準ライブラリの完全なリファレンス\n- **設計と思想** - Hemlock がこのような設計になっている理由を理解する\n\n## パッケージマネージャー\n\nHemlock には依存関係を管理するためのパッケージマネージャー **hpm** が付属しています：\n\n```bash\nhpm init my-project\nhpm add some-package\nhpm run\n```\n\n詳細については hpm ドキュメントセクションを参照してください。\n\n---\n\n左側のナビゲーションを使用してドキュメントを探索するか、検索バーを使用して特定のトピックを検索してください。\n"}, "言語リファレンス": {"id": "language-reference", "content": "# Hemlock言語設計思想\n\n> 「安全でないことを安全に記述するための、小さく安全でない言語」\n\nこのドキュメントは、Hemlockの設計思想の概要と言語のクイックリファレンスを提供します。\n詳細なガイドとAPIリファレンスについては、他のドキュメントセクションをご覧ください。\n\n---\n\n## コアアイデンティティ\n\nHemlockは**システムスクリプト言語**であり、手動メモリ管理と明示的な制御を備えています：\n- モダンなスクリプト言語の使いやすさを持つCのパワー\n- 構造化された非同期並行処理が組み込み\n- 隠れた動作やマジックがない\n\n**Hemlockではないもの：** メモリセーフ、GC言語、複雑さを隠すもの\n**Hemlockであるもの：** 暗黙より明示、教育的、システム作業のための「Cスクリプト層」\n\n---\n\n## 設計原則\n\n### 1. 暗黙より明示\n- セミコロン必須（ASIなし）\n- 手動メモリ管理（alloc/free）\n- 型注釈はオプションだが実行時にチェック\n\n### 2. デフォルトで動的、選択で型付け\n- すべての値は実行時型タグを持つ\n- リテラルは型を推論：`42` → i32、`5000000000` → i64、`3.14` → f64\n- オプションの型注釈は実行時チェックを強制\n\n### 3. アンセーフは機能\n- ポインタ演算が許可（ユーザーの責任）\n- 生の`ptr`には境界チェックなし（安全のために`buffer`を使用）\n- 二重解放によるクラッシュを許可\n\n### 4. 構造化された並行処理がファーストクラス\n- pthreadベースの並列処理を持つ`async`/`await`組み込み\n- 通信用チャネル\n- タスク管理用の`spawn`/`join`/`detach`\n\n### 5. Cライクな構文\n- `{}`ブロックは常に必須\n- コメント：`// 行` と `/* ブロック */`\n- 演算子はCと同じ：`+`、`-`、`*`、`%`、`&&`、`||`、`!`、`&`、`|`、`^`、`<<`、`>>`\n- インクリメント/デクリメント：`++x`、`x++`、`--x`、`x--`（前置と後置）\n- 複合代入：`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`|=`、`^=`、`<<=`、`>>=`\n- `/`は常にfloatを返す（整数除算には`divi()`を使用）\n- 型構文：`let x: type = value;`\n\n---\n\n## クイックリファレンス\n\n### 型\n```\n符号付き：   i8, i16, i32, i64\n符号なし：   u8, u16, u32, u64\n浮動小数点： f32, f64\nその他：     bool, string, rune, array, ptr, buffer, null, object, file, task, channel\nエイリアス： integer (i32), number (f64), byte (u8)\n```\n\n**型昇格：** i8 → i16 → i32 → i64 → f32 → f64（floatが常に優先、ただしi64/u64 + f32 → f64で精度を保持）\n\n### リテラル\n```hemlock\nlet x = 42;              // i32\nlet big = 5000000000;    // i64（> i32 最大値）\nlet hex = 0xDEADBEEF;    // 16進リテラル\nlet bin = 0b1010;        // 2進リテラル\nlet oct = 0o777;         // 8進リテラル\nlet sep = 1_000_000;     // 数値セパレータ使用可能\nlet pi = 3.14;           // f64\nlet half = .5;           // f64（先頭ゼロなし）\nlet s = \"hello\";         // string\nlet esc = \"\\x41\\u{1F600}\"; // 16進とUnicodeエスケープ\nlet ch = 'A';            // rune\nlet emoji = '🚀';        // rune（Unicode）\nlet arr = [1, 2, 3];     // array\nlet obj = { x: 10 };     // object\n```\n\n### 型変換\n```hemlock\n// 型コンストラクタ関数 - 文字列を型にパース\nlet n = i32(\"42\");       // 文字列をi32にパース\nlet f = f64(\"3.14\");     // 文字列をf64にパース\nlet b = bool(\"true\");    // 文字列をboolにパース（\"true\"または\"false\"）\n\n// すべての数値型をサポート\nlet a = i8(\"-128\");      // i8, i16, i32, i64\nlet c = u8(\"255\");       // u8, u16, u32, u64\nlet d = f32(\"1.5\");      // f32, f64\n\n// 16進数と負数\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\n\n// 型エイリアスも動作\nlet x = integer(\"100\");  // i32(\"100\")と同じ\nlet y = number(\"1.5\");   // f64(\"1.5\")と同じ\nlet z = byte(\"200\");     // u8(\"200\")と同じ\n\n// 数値型間の変換\nlet big = i64(42);       // i32からi64へ\nlet truncated = i32(3.99); // f64からi32へ（3に切り捨て）\n\n// 型注釈は型を検証（文字列をパースしない）\nlet f: f64 = 100;        // 注釈によるi32からf64へ（数値変換OK）\n// let n: i32 = \"42\";    // エラー - 文字列パースにはi32(\"42\")を使用\n```\n\n### イントロスペクション\n```hemlock\ntypeof(42);              // \"i32\"\ntypeof(\"hello\");         // \"string\"\ntypeof([1, 2, 3]);       // \"array\"\ntypeof(null);            // \"null\"\nlen(\"hello\");            // 5（バイト単位の文字列長）\nlen([1, 2, 3]);          // 3（配列長）\n```\n\n### メモリ\n```hemlock\nlet p = alloc(64);       // 生ポインタ\nlet b = buffer(64);      // 安全なバッファ（境界チェック付き）\nmemset(p, 0, 64);\nmemcpy(dest, src, 64);\nfree(p);                 // 手動クリーンアップ必須\n```\n\n### 制御フロー\n```hemlock\nif (x > 0) { } else if (x < 0) { } else { }\nwhile (cond) { break; continue; }\nfor (let i = 0; i < 10; i++) { }\nfor (item in array) { }\nloop { if (done) { break; } }   // 無限ループ（while(true)よりクリーン）\nswitch (x) { case 1: break; default: break; }  // Cスタイルのフォールスルー\ndefer cleanup();         // 関数が戻るときに実行\n\n// ネストされたループでの対象指定break/continue用ループラベル\nouter: while (cond) {\n    inner: for (let i = 0; i < 10; i++) {\n        if (i == 5) { break outer; }     // 外側ループをbreak\n        if (i == 3) { continue outer; }  // 外側ループをcontinue\n    }\n}\n```\n\n### パターンマッチング\n```hemlock\n// match式 - 値を返す\nlet result = match (value) {\n    0 => \"zero\",                    // リテラルパターン\n    1 | 2 | 3 => \"small\",           // ORパターン\n    n if n < 10 => \"medium\",        // ガード式\n    n => \"large: \" + n              // 変数バインディング\n};\n\n// 型パターン\nmatch (val) {\n    n: i32 => \"integer\",\n    s: string => \"string\",\n    _ => \"other\"                    // ワイルドカード\n}\n\n// オブジェクトの分解\nmatch (point) {\n    { x: 0, y: 0 } => \"origin\",\n    { x, y } => \"at \" + x + \",\" + y\n}\n\n// restを使った配列の分解\nmatch (arr) {\n    [] => \"empty\",\n    [first, ...rest] => \"head: \" + first,\n    _ => \"other\"\n}\n\n// ネストされたパターン\nmatch (user) {\n    { name, address: { city } } => name + \" in \" + city\n}\n```\n\n完全なドキュメントについては`docs/language-guide/pattern-matching.md`を参照してください。\n\n### Null合体演算子\n```hemlock\n// Null合体（??）- 左がnon-nullなら左を、そうでなければ右を返す\nlet name = user.name ?? \"Anonymous\";\nlet first = a ?? b ?? c ?? \"fallback\";\n\n// Null合体代入（??=）- nullの場合のみ代入\nlet config = null;\nconfig ??= { timeout: 30 };    // configは{ timeout: 30 }になる\nconfig ??= { timeout: 60 };    // configは変更されない（nullではない）\n\n// プロパティとインデックスでも動作\nobj.field ??= \"default\";\narr[0] ??= \"first\";\n\n// 安全なナビゲーション（?.）- オブジェクトがnullならnullを返す\nlet city = user?.address?.city;  // どの部分がnullでもnull\nlet upper = name?.to_upper();    // 安全なメソッド呼び出し\nlet item = arr?.[0];             // 安全なインデックス\n```\n\n### 関数\n```hemlock\nfn add(a: i32, b: i32): i32 { return a + b; }\nfn greet(name: string, msg?: \"Hello\") { print(msg + \" \" + name); }\nlet f = fn(x) { return x * 2; };  // 匿名/クロージャ\n\n// 式本体関数（アロー構文）\nfn double(x: i32): i32 => x * 2;\nfn max(a: i32, b: i32): i32 => a > b ? a : b;\nlet square = fn(x: i32): i32 => x * x;  // 匿名式本体\n\n// パラメータ修飾子\nfn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // 参照渡し\nfn print_all(const items: array) { for (i in items) { print(i); } }  // 不変\n```\n\n### 名前付き引数\n```hemlock\n// 関数は名前付き引数で呼び出し可能\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" is \" + age + \" years old\");\n}\n\n// 位置引数（従来型）\ncreate_user(\"Alice\", 25, false);\n\n// 名前付き引数 - 任意の順序で指定可能\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n\n// 必要なものだけ名前で指定してオプションパラメータをスキップ\ncreate_user(\"David\", active: false);  // デフォルトage=18を使用\n\n// 名前付き引数は位置引数の後に来る必要がある\ncreate_user(\"Eve\", age: 21);          // OK：位置引数の後に名前付き\n// create_user(name: \"Bad\", 25);      // エラー：名前付きの後に位置引数\n```\n\n**ルール：**\n- 名前付き引数は`name: value`構文を使用\n- 位置引数の後なら任意の順序で使用可能\n- 名前付き引数の後に位置引数は使用不可\n- デフォルト/オプションパラメータで動作\n- 不明なパラメータ名は実行時エラー\n\n### オブジェクトと列挙型\n```hemlock\ndefine Person { name: string, age: i32, active?: true }\nlet p: Person = { name: \"Alice\", age: 30 };\nlet json = p.serialize();\nlet restored = json.deserialize();\n\n// オブジェクトショートハンド構文（ES6スタイル）\nlet name = \"Alice\";\nlet age = 30;\nlet person = { name, age };         // { name: name, age: age }と同等\n\n// オブジェクトスプレッド演算子\nlet defaults = { theme: \"dark\", size: \"medium\" };\nlet config = { ...defaults, size: \"large\" };  // defaultsをコピーし、sizeをオーバーライド\n\nenum Color { RED, GREEN, BLUE }\nenum Status { OK = 0, ERROR = 1 }\n```\n\n### 複合型（交差型/ダック型）\n```hemlock\n// 構造型を定義\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// 複合型：オブジェクトはすべての型を満たす必要がある\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// 複合型を使った関数パラメータ\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" is \" + p.age);\n}\n\n// 3つ以上の型\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n\n// 余分なフィールドは許可（ダック型）\nlet employee: HasName & HasAge = {\n    name: \"Bob\",\n    age: 25,\n    department: \"Engineering\"  // OK - 余分なフィールドは無視\n};\n```\n\n複合型は、別の`interface`キーワードなしでインターフェースのような動作を提供し、\n既存の`define`とダック型のパラダイムの上に構築されています。\n\n### 型エイリアス\n```hemlock\n// シンプルな型エイリアス\ntype Integer = i32;\ntype Text = string;\n\n// 関数型エイリアス\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// 複合型エイリアス（再利用可能なインターフェースに最適）\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// ジェネリック型エイリアス\ntype Pair<T> = { first: T, second: T };\n\n// 型エイリアスの使用\nlet x: Integer = 42;\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\n型エイリアスは複雑な型に名前付きショートカットを作成し、可読性と保守性を向上させます。\n\n### 関数型\n```hemlock\n// パラメータ用の関数型注釈\nfn apply_fn(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// 関数を返す高階関数\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// 非同期関数型\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n\n// 複数パラメータを持つ関数型\ntype BinaryOp = fn(i32, i32): i32;\nlet add: BinaryOp = fn(a, b) { return a + b; };\n```\n\n### Constパラメータ\n```hemlock\n// Constパラメータ - 深い不変性\nfn print_all(const items: array) {\n    // items.push(4);  // エラー：constパラメータを変更できない\n    for (item in items) {\n        print(item);\n    }\n}\n\n// オブジェクトでのconst - どのパスからも変更不可\nfn describe(const person: object) {\n    print(person.name);       // OK：読み取りは許可\n    // person.name = \"Bob\";   // エラー：変更できない\n}\n\n// 読み取り用のネストされたアクセスは許可\nfn get_city(const user: object) {\n    return user.address.city;  // OK：ネストされたプロパティの読み取り\n}\n```\n\n`const`修飾子は、ネストされたプロパティを含むパラメータのあらゆる変更を防ぎます。\nこれにより、入力を変更すべきでない関数のコンパイル時安全性が提供されます。\n\n### Refパラメータ（参照渡し）\n```hemlock\n// Refパラメータ - 呼び出し元の変数を直接変更\nfn increment(ref x: i32) {\n    x = x + 1;  // 元の変数を変更\n}\n\nlet count = 10;\nincrement(count);\nprint(count);  // 11 - 元が変更された\n\n// 古典的なswap関数\nfn swap(ref a: i32, ref b: i32) {\n    let temp = a;\n    a = b;\n    b = temp;\n}\n\nlet x = 1;\nlet y = 2;\nswap(x, y);\nprint(x, y);  // 2 1\n\n// refと通常のパラメータを混在\nfn add_to(ref target: i32, amount: i32) {\n    target = target + amount;\n}\n\nlet total = 100;\nadd_to(total, 50);\nprint(total);  // 150\n```\n\n`ref`修飾子は呼び出し元の変数への参照を渡し、関数がそれを直接変更できるようにします。\n`ref`がない場合、プリミティブは値渡し（コピー）されます。値を返さずに呼び出し元の\n状態を変更する必要がある場合に`ref`を使用します。\n\n**ルール：**\n- `ref`パラメータには変数を渡す必要があり、リテラルや式は不可\n- すべての型で動作（プリミティブ、配列、オブジェクト）\n- 型注釈と組み合わせ可能：`ref x: i32`\n- `const`と組み合わせ不可（反対の意味）\n\n### Defineでのメソッドシグネチャ\n```hemlock\n// メソッドシグネチャを持つdefine（インターフェースパターン）\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32   // 必須メソッドシグネチャ\n}\n\n// オブジェクトは必須メソッドを提供する必要がある\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// ?を使ったオプションメソッド\ndefine Serializable {\n    fn serialize(): string,        // 必須\n    fn pretty?(): string           // オプションメソッド\n}\n\n// Self型は定義型を参照\ndefine Cloneable {\n    fn clone(): Self   // オブジェクトと同じ型を返す\n}\n```\n\n`define`ブロック内のメソッドシグネチャはカンマ区切り（TypeScriptインターフェースのような）を使用し、\nオブジェクトが満たすべき契約を確立し、Hemlockのダック型システムでインターフェースのような\nプログラミングパターンを可能にします。\n\n### エラーハンドリング\n```hemlock\ntry { throw \"error\"; } catch (e) { print(e); } finally { cleanup(); }\npanic(\"unrecoverable\");  // 即座に終了、catchできない\n```\n\n### 非同期/並行処理\n```hemlock\nasync fn compute(n: i32): i32 { return n * n; }\nlet task = spawn(compute, 42);\nlet result = await task;     // またはjoin(task)\ndetach(spawn(background_work));\n\nlet ch = channel(10);\nch.send(value);\nlet val = ch.recv();\nch.close();\n```\n\n**メモリ所有権：** タスクはプリミティブ値のコピーを受け取りますが、ポインタは共有します。スポーンされたタスクに`ptr`を渡す場合、タスクが完了するまでメモリが有効であることを保証する必要があります。`free()`の前に`join()`を使用するか、完了を通知するためにチャネルを使用してください。\n\n### ユーザー入力\n```hemlock\nlet name = read_line();          // stdinから行を読み取り（ブロック）\nprint(\"Hello, \" + name);\neprint(\"Error message\");         // stderrに出力\n\n// read_line()はEOFでnullを返す\nwhile (true) {\n    let line = read_line();\n    if (line == null) { break; }\n    print(\"Got:\", line);\n}\n```\n\n### ファイルI/O\n```hemlock\nlet f = open(\"file.txt\", \"r\");  // モード：r, w, a, r+, w+, a+\nlet content = f.read();\nf.write(\"data\");\nf.seek(0);\nf.close();\n```\n\n### シグナル\n```hemlock\nsignal(SIGINT, fn(sig) { print(\"Interrupted\"); });\nraise(SIGUSR1);\n```\n\n---\n\n## 文字列メソッド（19個）\n\n`substr`、`slice`、`find`、`contains`、`split`、`trim`、`to_upper`、`to_lower`、\n`starts_with`、`ends_with`、`replace`、`replace_all`、`repeat`、`char_at`、\n`byte_at`、`chars`、`bytes`、`to_bytes`、`deserialize`\n\nテンプレート文字列：`` `Hello ${name}!` ``\n\n**文字列の可変性：** 文字列はインデックス代入（`s[0] = 'H'`）で変更可能ですが、すべての文字列メソッドは元を変更せず新しい文字列を返します。これにより、必要な場合のインプレース変更を可能にしながら、メソッドチェーンを関数型に保ちます。\n\n**文字列長プロパティ：**\n```hemlock\nlet s = \"hello 🚀\";\nprint(s.length);       // 7（文字/rune数）\nprint(s.byte_length);  // 10（バイト数 - 絵文字はUTF-8で4バイト）\n```\n\n## 配列メソッド（18個）\n\n`push`、`pop`、`shift`、`unshift`、`insert`、`remove`、`find`、`contains`、\n`slice`、`join`、`concat`、`reverse`、`first`、`last`、`clear`、`map`、`filter`、`reduce`\n\n型付き配列：`let nums: array<i32> = [1, 2, 3];`\n\n---\n\n## 標準ライブラリ（40モジュール）\n\n`@stdlib/`プレフィックスでインポート：\n```hemlock\nimport { sin, cos, PI } from \"@stdlib/math\";\nimport { HashMap, Queue, Set } from \"@stdlib/collections\";\nimport { read_file, write_file } from \"@stdlib/fs\";\nimport { TcpStream, UdpSocket } from \"@stdlib/net\";\n```\n\n| モジュール | 説明 |\n|--------|-------------|\n| `arena` | アリーナメモリアロケータ（バンプアロケーション） |\n| `args` | コマンドライン引数パース |\n| `assert` | アサーションユーティリティ |\n| `async` | ThreadPool、parallel_map |\n| `async_fs` | 非同期ファイルI/O操作 |\n| `collections` | HashMap、Queue、Stack、Set、LinkedList、LRUCache |\n| `compression` | gzip、gunzip、deflate |\n| `crypto` | aes_encrypt、rsa_sign、random_bytes |\n| `csv` | CSVパースと生成 |\n| `datetime` | DateTimeクラス、フォーマット、パース |\n| `encoding` | base64_encode、hex_encode、url_encode |\n| `env` | getenv、setenv、exit、get_pid |\n| `fmt` | 文字列フォーマットユーティリティ |\n| `fs` | read_file、write_file、list_dir、exists |\n| `glob` | ファイルパターンマッチング |\n| `hash` | sha256、sha512、md5、djb2 |\n| `http` | http_get、http_post、http_request |\n| `ipc` | プロセス間通信 |\n| `iter` | イテレータユーティリティ |\n| `json` | parse、stringify、pretty、get、set |\n| `logging` | レベル付きLogger |\n| `math` | sin、cos、sqrt、pow、rand、PI、E |\n| `net` | TcpListener、TcpStream、UdpSocket |\n| `os` | platform、arch、cpu_count、hostname |\n| `path` | ファイルパス操作 |\n| `process` | fork、exec、wait、kill |\n| `random` | 乱数生成 |\n| `regex` | compile、test（POSIX ERE） |\n| `retry` | バックオフ付きリトライロジック |\n| `semver` | セマンティックバージョニング |\n| `shell` | シェルコマンドユーティリティ |\n| `sqlite` | SQLiteデータベース、query、exec、トランザクション |\n| `strings` | pad_left、is_alpha、reverse、lines |\n| `terminal` | ANSIカラーとスタイル |\n| `testing` | describe、test、expect |\n| `time` | now、time_ms、sleep、clock |\n| `toml` | TOMLパースと生成 |\n| `url` | URLパースと操作 |\n| `uuid` | UUID生成 |\n| `websocket` | WebSocketクライアント |\n\n詳細なモジュールドキュメントについては`stdlib/docs/`を参照してください。\n\n---\n\n## FFI（外部関数インターフェース）\n\n共有ライブラリからC関数を宣言して呼び出し：\n```hemlock\nimport \"libc.so.6\";\n\nextern fn strlen(s: string): i32;\nextern fn getpid(): i32;\n\nlet len = strlen(\"Hello!\");  // 6\nlet pid = getpid();\n```\n\nモジュールからFFI関数をエクスポート：\n```hemlock\n// string_utils.hml\nimport \"libc.so.6\";\n\nexport extern fn strlen(s: string): i32;\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n```\n\n動的FFI（実行時バインディング）：\n```hemlock\nlet lib = ffi_open(\"libc.so.6\");\nlet puts = ffi_bind(lib, \"puts\", [FFI_POINTER], FFI_INT);\nputs(\"Hello from C!\");\nffi_close(lib);\n```\n\n型：`FFI_INT`、`FFI_DOUBLE`、`FFI_POINTER`、`FFI_STRING`、`FFI_VOID`など\n\n---\n\n## アトミック操作\n\nアトミック操作によるロックフリー並行プログラミング：\n\n```hemlock\n// アトミックi32用のメモリを確保\nlet p = alloc(4);\nptr_write_i32(p, 0);\n\n// アトミックload/store\nlet val = atomic_load_i32(p);        // アトミックに読み取り\natomic_store_i32(p, 42);             // アトミックに書き込み\n\n// fetch-and-modify操作（古い値を返す）\nlet old = atomic_add_i32(p, 10);     // 加算、古い値を返す\nold = atomic_sub_i32(p, 5);          // 減算、古い値を返す\nold = atomic_and_i32(p, 0xFF);       // ビット単位AND\nold = atomic_or_i32(p, 0x10);        // ビット単位OR\nold = atomic_xor_i32(p, 0x0F);       // ビット単位XOR\n\n// Compare-and-swap（CAS）\nlet success = atomic_cas_i32(p, 42, 100);  // *p == 42なら100に設定\n// スワップが成功したらtrue、そうでなければfalseを返す\n\n// アトミック交換\nold = atomic_exchange_i32(p, 999);   // スワップ、古い値を返す\n\nfree(p);\n\n// i64バリアントも使用可能（atomic_load_i64、atomic_add_i64など）\n\n// メモリフェンス（フルバリア）\natomic_fence();\n```\n\nすべての操作はシーケンシャル一貫性（`memory_order_seq_cst`）を使用します。\n\n---\n\n## プロジェクト構造\n\n```\nhemlock/\n├── src/\n│   ├── frontend/         # 共有：lexer、parser、AST、modules\n│   ├── backends/\n│   │   ├── interpreter/  # hemlock：ツリーウォーキングインタプリタ\n│   │   └── compiler/     # hemlockc：Cコードジェネレータ\n│   ├── tools/\n│   │   ├── lsp/          # Language Server Protocol\n│   │   └── bundler/      # バンドル/パッケージツール\n├── runtime/              # コンパイル済みプログラムランタイム（libhemlock_runtime.a）\n├── stdlib/               # 標準ライブラリ（40モジュール）\n│   └── docs/             # モジュールドキュメント\n├── docs/                 # 完全なドキュメント\n│   ├── language-guide/   # 型、文字列、配列など\n│   ├── reference/        # APIリファレンス\n│   └── advanced/         # 非同期、FFI、シグナルなど\n├── tests/                # 625+テスト\n└── examples/             # サンプルプログラム\n```\n\n---\n\n## コードスタイルガイドライン\n\n### 定数とマジックナンバー\n\nCコードベースに数値定数を追加する際は、以下のガイドラインに従ってください：\n\n1. **`include/hemlock_limits.h`に定数を定義** - このファイルは、すべてのコンパイル時および実行時の制限、容量、名前付き定数の中心的な場所です。\n\n2. **`HML_`プレフィックスを持つ説明的な名前を使用** - すべての定数は名前空間の明確さのために`HML_`プレフィックスを付ける必要があります。\n\n3. **マジックナンバーを避ける** - ハードコードされた数値をnamed定数に置き換えてください。例：\n   - 型範囲制限：`HML_I8_MIN`、`HML_I8_MAX`、`HML_U32_MAX`\n   - バッファ容量：`HML_INITIAL_ARRAY_CAPACITY`、`HML_INITIAL_LEXER_BUFFER_CAPACITY`\n   - 時間変換：`HML_NANOSECONDS_PER_SECOND`、`HML_MILLISECONDS_PER_SECOND`\n   - ハッシュシード：`HML_DJB2_HASH_SEED`\n   - ASCII値：`HML_ASCII_CASE_OFFSET`、`HML_ASCII_PRINTABLE_START`\n\n4. **`hemlock_limits.h`をインクルード** - ソースファイルは定数にアクセスするためにこのヘッダー（多くの場合`internal.h`経由）をインクルードする必要があります。\n\n5. **目的を文書化** - 各定数が何を表すかを説明するコメントを追加してください。\n\n---\n\n## やってはいけないこと\n\n❌ 暗黙の動作を追加（ASI、GC、自動クリーンアップ）\n❌ 複雑さを隠す（マジック最適化、隠れた参照カウント）\n❌ 既存のセマンティクスを破壊（セミコロン、手動メモリ、可変文字列）\n❌ 暗黙の変換で精度を失う\n❌ マジックナンバーを使用 - 代わりに`hemlock_limits.h`にnamed定数を定義\n\n---\n\n## テスト\n\n```bash\nmake test              # インタプリタテストを実行\nmake test-compiler     # コンパイラテストを実行\nmake parity            # パリティテストを実行（両方が一致する必要がある）\nmake test-all          # すべてのテストスイートを実行\n```\n\n**重要：** 非同期/並行処理の問題によりテストがハングすることがあります。テスト実行時は常にタイムアウトを使用してください：\n```bash\ntimeout 60 make test   # 60秒タイムアウト\ntimeout 120 make parity\n```\n\nテストカテゴリ：primitives、memory、strings、arrays、functions、objects、async、ffi、defer、signals、switch、bitwise、typed_arrays、modules、stdlib_*\n\n---\n\n## コンパイラ/インタプリタアーキテクチャ\n\nHemlockには共通のフロントエンドを共有する2つの実行バックエンドがあります：\n\n```\nソース（.hml）\n    ↓\n┌─────────────────────────────┐\n│  共有フロントエンド           │\n│  - Lexer（src/frontend/）    │\n│  - Parser（src/frontend/）   │\n│  - AST（src/frontend/）      │\n└─────────────────────────────┘\n    ↓                    ↓\n┌────────────┐    ┌────────────┐\n│ インタプリタ │    │  コンパイラ │\n│ (hemlock)  │    │ (hemlockc) │\n│            │    │            │\n│ ツリーウォー│    │ 型チェック  │\n│ ク評価     │    │ AST → C    │\n│            │    │ gccリンク  │\n└────────────┘    └────────────┘\n```\n\n### コンパイラ型チェック\n\nコンパイラ（`hemlockc`）にはコンパイル時型チェックが含まれており、**デフォルトで有効**です：\n\n```bash\nhemlockc program.hml -o program    # 型チェック後、コンパイル\nhemlockc --check program.hml       # 型チェックのみ、コンパイルしない\nhemlockc --no-type-check prog.hml  # 型チェックを無効化\nhemlockc --strict-types prog.hml   # 暗黙の'any'型に警告\n```\n\n型チェッカーは：\n- コンパイル時に型注釈を検証\n- 型注釈のないコードを動的（`any`型）として扱う - 常に有効\n- アンボックス化のための最適化ヒントを提供\n- 許容的な数値変換を使用（範囲は実行時に検証）\n\n### ディレクトリ構造\n\n```\nhemlock/\n├── src/\n│   ├── frontend/           # 共有：lexer、parser、AST、modules\n│   │   ├── lexer.c\n│   │   ├── parser/\n│   │   ├── ast.c\n│   │   └── module.c\n│   ├── backends/\n│   │   ├── interpreter/    # hemlock：ツリーウォーキングインタプリタ\n│   │   │   ├── main.c\n│   │   │   ├── runtime/\n│   │   │   └── builtins/\n│   │   └── compiler/       # hemlockc：Cコードジェネレータ\n│   │       ├── main.c\n│   │       └── codegen/\n│   ├── tools/\n│   │   ├── lsp/            # 言語サーバー\n│   │   └── bundler/        # バンドル/パッケージツール\n├── runtime/                # コンパイル済みプログラム用libhemlock_runtime.a\n├── stdlib/                 # 共有標準ライブラリ\n└── tests/\n    ├── parity/             # 両方のバックエンドでパスする必要があるテスト\n    ├── interpreter/        # インタプリタ固有のテスト\n    └── compiler/           # コンパイラ固有のテスト\n```\n\n---\n\n## パリティファースト開発\n\n**インタプリタとコンパイラは、同じ入力に対して同一の出力を生成する必要があります。**\n\n### 開発ポリシー\n\n言語機能を追加または変更する際：\n\n1. **設計** - 共有フロントエンドでAST/セマンティック変更を定義\n2. **インタプリタ実装** - ツリーウォーキング評価を追加\n3. **コンパイラ実装** - Cコード生成を追加\n4. **パリティテスト追加** - `tests/parity/`に`.expected`ファイル付きでテストを記述\n5. **検証** - マージ前に`make parity`を実行\n\n### パリティテスト構造\n\n```\ntests/parity/\n├── language/       # コア言語機能（制御フロー、クロージャなど）\n├── builtins/       # 組み込み関数（print、typeof、memoryなど）\n├── methods/        # 文字列と配列メソッド\n└── modules/        # import/export、stdlibインポート\n```\n\n各テストには2つのファイルがあります：\n- `feature.hml` - テストプログラム\n- `feature.expected` - 期待される出力（両方のバックエンドで一致する必要がある）\n\n### パリティテスト結果\n\n| ステータス | 意味 |\n|--------|---------|\n| `✓ PASSED` | インタプリタとコンパイラの両方が期待される出力と一致 |\n| `◐ INTERP_ONLY` | インタプリタは動作、コンパイラは失敗（コンパイラ修正が必要） |\n| `◑ COMPILER_ONLY` | コンパイラは動作、インタプリタは失敗（まれ） |\n| `✗ FAILED` | 両方失敗（テストまたは実装のバグ） |\n\n### パリティが必要なもの\n\n- すべての言語構造（if、while、for、switch、defer、try/catch）\n- すべての演算子（算術、ビット単位、論理、比較）\n- すべての組み込み関数（print、typeof、allocなど）\n- すべての文字列と配列メソッド\n- 型強制と昇格ルール\n- 実行時エラーのエラーメッセージ\n\n### 異なっても良いもの\n\n- パフォーマンス特性\n- メモリレイアウトの詳細\n- デバッグ/スタックトレースのフォーマット\n- コンパイルエラー（コンパイラはコンパイル時により多くをキャッチする可能性がある）\n\n### パリティテストの追加\n\n```bash\n# 1. テストファイルを作成\ncat > tests/parity/language/my_feature.hml << 'EOF'\n// テストの説明\nlet x = some_feature();\nprint(x);\nEOF\n\n# 2. インタプリタから期待される出力を生成\n./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected\n\n# 3. パリティを検証\nmake parity\n```\n\n---\n\n## バージョン\n\n**v1.8.0** - 以下を含む現在のリリース：\n- **パターンマッチング**（`match`式）- 強力な分解と制御フロー：\n  - リテラル、ワイルドカード、変数バインディングパターン\n  - ORパターン（`1 | 2 | 3`）\n  - ガード式（`n if n > 0`）\n  - オブジェクト分解（`{ x, y }`）\n  - restを使った配列分解（`[first, ...rest]`）\n  - 型パターン（`n: i32`）\n  - インタプリタとコンパイラ間の完全なパリティ\n- **コンパイラヘルパー注釈** - GCC/Clang制御用の11の最適化注釈：\n  - `@inline`、`@noinline` - 関数インライン化制御\n  - `@hot`、`@cold` - 分岐予測ヒント\n  - `@pure`、`@const` - 副作用注釈\n  - `@flatten` - 関数内のすべての呼び出しをインライン化\n  - `@optimize(level)` - 関数ごとの最適化レベル（\"0\"、\"1\"、\"2\"、\"3\"、\"s\"、\"fast\"）\n  - `@warn_unused` - 戻り値が無視された場合に警告\n  - `@section(name)` - カスタムELFセクション配置（例：`@section(\".text.hot\")`）\n- **式本体関数**（`fn double(x): i32 => x * 2;`）- 簡潔な単一式関数構文\n- **単一行文** - ブレースなし`if`、`while`、`for`構文（例：`if (x > 0) print(x);`）\n- **型エイリアス**（`type Name = Type;`）- 複雑な型のnamed ショートカット\n- **関数型注釈**（`fn(i32): i32`）- ファーストクラス関数型\n- **Constパラメータ**（`fn(const x: array)`）- パラメータの深い不変性\n- **Refパラメータ**（`fn(ref x: i32)`）- 直接呼び出し元変更用の参照渡し\n- **defineでのメソッドシグネチャ**（`fn method(): Type`）- インターフェースのような契約（カンマ区切り）\n- メソッドシグネチャでの**Self型** - 定義型を参照\n- **Loopキーワード**（`loop { }`）- よりクリーンな無限ループ、`while (true)`を置き換え\n- **ループラベル**（`outer: while`）- ネストされたループでの対象指定break/continue\n- **オブジェクトショートハンド**（`{ name }`）- ES6スタイルのショートハンドプロパティ構文\n- **オブジェクトスプレッド**（`{ ...obj }`）- オブジェクトフィールドのコピーとマージ\n- **複合ダック型**（`A & B & C`）- 構造型のための交差型\n- 関数呼び出しの**名前付き引数**（`foo(name: \"value\", age: 30)`）\n- 安全なnullハンドリングのための**Null合体演算子**（`??`、`??=`、`?.`）\n- **8進リテラル**（`0o777`、`0O123`）\n- **数値セパレータ**（`1_000_000`、`0xFF_FF`、`0b1111_0000`）\n- **ブロックコメント**（`/* ... */`）\n- 文字列/runeでの**16進エスケープシーケンス**（`\\x41` = 'A'）\n- 文字列での**Unicodeエスケープシーケンス**（`\\u{1F600}` = 😀）\n- **先頭ゼロなしのfloatリテラル**（`.5`、`.123`、`.5e2`）\n- hemlockc での**コンパイル時型チェック**（デフォルトで有効）\n- リアルタイム診断用の型チェック付き**LSP統合**\n- **複合代入演算子**（`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`|=`、`^=`、`<<=`、`>>=`）\n- **インクリメント/デクリメント演算子**（`++x`、`x++`、`--x`、`x--`）\n- **型精度修正**：i64/u64 + f32 → f64で精度を保持\n- アンボックス化最適化ヒント付き統一型システム\n- 完全な型システム（i8-i64、u8-u64、f32/f64、bool、string、rune、ptr、buffer、array、object、enum、file、task、channel）\n- 19メソッド付きUTF-8文字列\n- map/filter/reduceを含む18メソッド付き配列\n- `talloc()`と`sizeof()`を使った手動メモリ管理\n- 真のpthread並列処理を持つAsync/await\n- ロックフリー並行プログラミング用アトミック操作\n- 40 stdlibモジュール（+ arena、assert、semver、toml、retry、iter、random、shell）\n- 再利用可能なライブラリラッパー用の`export extern fn`を持つCインターオペ用FFI\n- コンパイラでのFFI構造体サポート（C構造体を値渡し）\n- FFIポインタヘルパー（`ptr_null`、`ptr_read_*`、`ptr_write_*`）\n- defer、try/catch/finally/throw、panic\n- ファイルI/O、シグナルハンドリング、コマンド実行\n- GitHubベースのレジストリを持つ[hpm](https://github.com/hemlang/hpm)パッケージマネージャ\n- 100%インタプリタパリティを持つコンパイラバックエンド（Cコード生成）\n- go-to-definitionとfind-referencesを持つLSPサーバー\n- O(1)ルックアップのためのAST最適化パスと変数解決\n- 動的関数呼び出し用apply()ビルトイン\n- アンバッファードチャネルと多パラメータサポート\n- 159パリティテスト（100%パス率）\n\n---\n\n## 哲学\n\n> 私たちは安全であるためのツール（`buffer`、型注釈、境界チェック）を提供しますが、それらを使用することを強制しません（`ptr`、手動メモリ、安全でない操作）。\n\n**機能がHemlockに適合するかどうかわからない場合は、「これはプログラマにより明示的な制御を与えるか、それとも何かを隠すか？」と問いかけてください。**\n\n隠す場合、それはおそらくHemlockには属しません。\n"}, "はじめに -> インストール": {"id": "getting-started-installation", "content": "# インストール\n\nこのガイドでは、お使いのシステムにHemlockをビルドしてインストールする方法を説明します。\n\n## クイックインストール（推奨）\n\nHemlockをインストールする最も簡単な方法は、ワンライナーインストールスクリプトを使用することです：\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash\n```\n\nこれにより、お使いのプラットフォーム（LinuxまたはmacOS、x86_64またはarm64）向けの最新のビルド済みバイナリがダウンロードおよびインストールされます。\n\n### インストールオプション\n\n```bash\n# カスタムプレフィックスにインストール（デフォルト：~/.local）\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local\n\n# 特定のバージョンをインストール\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0\n\n# シェルのPATHを自動的に更新してインストール\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path\n```\n\nインストール後、動作を確認します：\n\n```bash\nhemlock --version\n```\n\n---\n\n## ソースからのビルド\n\nビルド済みバイナリがお使いのシステムで動作しない場合、またはソースからビルドしたい場合は、以下の手順に従ってください。\n\n## 前提条件\n\n### 必要な依存関係\n\nHemlockのビルドには以下の依存関係が必要です：\n\n- **Cコンパイラ**: GCCまたはClang（C11標準）\n- **Make**: GNU Make\n- **libffi**: 外部関数インターフェースライブラリ（FFIサポート用）\n- **OpenSSL**: 暗号化ライブラリ（ハッシュ関数用：md5、sha1、sha256）\n- **libwebsockets**: WebSocketおよびHTTPクライアント/サーバーサポート\n- **zlib**: 圧縮ライブラリ\n\n### 依存関係のインストール\n\n**macOS:**\n```bash\n# Homebrewがまだインストールされていない場合はインストール\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Xcode Command Line Toolsをインストール\nxcode-select --install\n\n# Homebrew経由で依存関係をインストール\nbrew install libffi openssl@3 libwebsockets\n```\n\n**macOSユーザーへの注意**: MakefileはHomebrewのインストールを自動的に検出し、正しいinclude/ライブラリパスを設定します。HemlockはIntel（x86_64）とApple Silicon（arm64）の両方のアーキテクチャをサポートしています。\n\n**Ubuntu/Debian:**\n```bash\nsudo apt-get update\nsudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev\n```\n\n**Fedora/RHEL:**\n```bash\nsudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel\n```\n\n**Arch Linux:**\n```bash\nsudo pacman -S base-devel libffi openssl libwebsockets zlib\n```\n\n## ソースからのビルド\n\n### 1. リポジトリをクローン\n\n```bash\ngit clone https://github.com/hemlang/hemlock.git\ncd hemlock\n```\n\n### 2. Hemlockをビルド\n\n```bash\nmake\n```\n\nこれによりHemlockインタプリタがコンパイルされ、実行ファイルがカレントディレクトリに配置されます。\n\n### 3. インストールの確認\n\n```bash\n./hemlock --version\n```\n\nHemlockのバージョン情報が表示されるはずです。\n\n### 4. ビルドのテスト\n\nすべてが正しく動作することを確認するためにテストスイートを実行します：\n\n```bash\nmake test\n```\n\nすべてのテストがパスするはずです。失敗がある場合は、issueとして報告してください。\n\n## システム全体へのインストール（オプション）\n\nHemlockをシステム全体（例：`/usr/local/bin`）にインストールするには：\n\n```bash\nsudo make install\n```\n\nこれにより、フルパスを指定せずにどこからでも`hemlock`を実行できるようになります。\n\n## Hemlockの実行\n\n### インタラクティブREPL\n\nRead-Eval-Print Loopを開始します：\n\n```bash\n./hemlock\n```\n\nプロンプトが表示され、Hemlockコードを入力できます：\n\n```\nHemlock REPL\n> print(\"Hello, World!\");\nHello, World!\n> let x = 42;\n> print(x * 2);\n84\n>\n```\n\nREPLを終了するには`Ctrl+D`または`Ctrl+C`を使用します。\n\n### プログラムの実行\n\nHemlockスクリプトを実行：\n\n```bash\n./hemlock program.hml\n```\n\nコマンドライン引数付きで実行：\n\n```bash\n./hemlock program.hml arg1 arg2 \"argument with spaces\"\n```\n\n## ディレクトリ構造\n\nビルド後のHemlockディレクトリは次のようになります：\n\n```\nhemlock/\n├── hemlock           # コンパイル済みインタプリタ実行ファイル\n├── src/              # ソースコード\n├── include/          # ヘッダーファイル\n├── tests/            # テストスイート\n├── examples/         # サンプルプログラム\n├── docs/             # ドキュメント\n├── stdlib/           # 標準ライブラリ\n├── Makefile          # ビルド設定\n└── README.md         # プロジェクトREADME\n```\n\n## ビルドオプション\n\n### デバッグビルド\n\nデバッグシンボル付きで最適化なしでビルド：\n\n```bash\nmake debug\n```\n\n### クリーンビルド\n\nすべてのコンパイル済みファイルを削除：\n\n```bash\nmake clean\n```\n\nスクラッチから再ビルド：\n\n```bash\nmake clean && make\n```\n\n## トラブルシューティング\n\n### macOS: ライブラリが見つからないエラー\n\nライブラリが見つからないエラー（`-lcrypto`、`-lffi`など）が発生した場合：\n\n1. Homebrewの依存関係がインストールされていることを確認：\n   ```bash\n   brew install libffi openssl@3 libwebsockets\n   ```\n\n2. Homebrewのパスを確認：\n   ```bash\n   brew --prefix libffi\n   brew --prefix openssl\n   ```\n\n3. Makefileはこれらのパスを自動検出するはずです。検出されない場合は、`brew`がPATHにあることを確認：\n   ```bash\n   which brew\n   ```\n\n### macOS: BSD型エラー（`u_int`、`u_char`が見つからない）\n\n`u_int`や`u_char`のような不明な型名に関するエラーが表示された場合：\n\n1. これはv1.0.0以降で`_POSIX_C_SOURCE`の代わりに`_DARWIN_C_SOURCE`を使用することで修正されています\n2. 最新バージョンのコードを使用していることを確認\n3. クリーンして再ビルド：\n   ```bash\n   make clean && make\n   ```\n\n### Linux: libffiが見つからない\n\n`ffi.h`や`-lffi`が見つからないエラーが発生した場合：\n\n1. `libffi-dev`がインストールされていることを確認（上記の依存関係を参照）\n2. `pkg-config`で見つけられるか確認：\n   ```bash\n   pkg-config --cflags --libs libffi\n   ```\n3. 見つからない場合は、`PKG_CONFIG_PATH`を設定する必要があるかもしれません：\n   ```bash\n   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH\n   ```\n\n### コンパイルエラー\n\nコンパイルエラーが発生した場合：\n\n1. C11互換のコンパイラがあることを確認\n2. macOSでは、Clang（デフォルト）を使用してみてください：\n   ```bash\n   make CC=clang\n   ```\n3. Linuxでは、GCCを使用してみてください：\n   ```bash\n   make CC=gcc\n   ```\n4. すべての依存関係がインストールされていることを確認\n5. スクラッチから再ビルドを試してください：\n   ```bash\n   make clean && make\n   ```\n\n### テストの失敗\n\nテストが失敗した場合：\n\n1. 最新バージョンのコードを使用していることを確認\n2. スクラッチから再ビルドを試してください：\n   ```bash\n   make clean && make test\n   ```\n3. macOSでは、最新のXcode Command Line Toolsがあることを確認：\n   ```bash\n   xcode-select --install\n   ```\n4. GitHubで以下の情報を含めてissueを報告してください：\n   - お使いのプラットフォーム（macOSバージョン / Linuxディストリビューション）\n   - アーキテクチャ（x86_64 / arm64）\n   - テスト出力\n   - `make -v`と`gcc --version`（または`clang --version`）の出力\n\n## 次のステップ\n\n- [クイックスタートガイド](#getting-started-quick-start) - 最初のHemlockプログラムを書く\n- [チュートリアル](#getting-started-tutorial) - ステップバイステップでHemlockを学ぶ\n- [言語ガイド](#language-guide-syntax) - Hemlockの機能を探索\n"}, "はじめに -> クイックスタート": {"id": "getting-started-quick-start", "content": "# クイックスタート\n\n数分でHemlockを使い始めましょう！\n\n## 最初のプログラム\n\n`hello.hml`というファイルを作成します：\n\n```hemlock\nprint(\"Hello, Hemlock!\");\n```\n\nインタプリタで実行：\n\n```bash\n./hemlock hello.hml\n```\n\nまたはネイティブ実行ファイルにコンパイル：\n\n```bash\n./hemlockc hello.hml -o hello\n./hello\n```\n\n出力：\n```\nHello, Hemlock!\n```\n\n### インタプリタ vs コンパイラ\n\nHemlockにはプログラムを実行する2つの方法があります：\n\n| ツール | ユースケース | 型チェック |\n|------|----------|---------------|\n| `hemlock` | クイックスクリプト、REPL、開発 | 実行時のみ |\n| `hemlockc` | 本番バイナリ、より良いパフォーマンス | コンパイル時（デフォルト） |\n\nコンパイラ（`hemlockc`）は実行ファイルを生成する前にコードの型チェックを行い、エラーを早期に発見します。\n\n## 基本構文\n\n### 変数\n\n```hemlock\n// 変数は'let'で宣言\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\n// 型注釈はオプション\nlet count: i32 = 100;\nlet ratio: f64 = 0.618;\n```\n\n**重要**: Hemlockではセミコロンは**必須**です！\n\n### 型\n\nHemlockには豊富な型システムがあります：\n\n```hemlock\n// 整数\nlet small: i8 = 127;          // 8ビット符号付き\nlet byte: u8 = 255;           // 8ビット符号なし\nlet num: i32 = 2147483647;    // 32ビット符号付き（デフォルト）\nlet big: i64 = 9223372036854775807;  // 64ビット符号付き\n\n// 浮動小数点\nlet f: f32 = 3.14;            // 32ビット浮動小数点\nlet d: f64 = 2.71828;         // 64ビット浮動小数点（デフォルト）\n\n// 文字列と文字\nlet text: string = \"Hello\";   // UTF-8文字列\nlet emoji: rune = '🚀';       // Unicodeコードポイント\n\n// 真偽値とnull\nlet flag: bool = true;\nlet empty = null;\n```\n\n### 制御フロー\n\n```hemlock\n// if文\nif (x > 0) {\n    print(\"positive\");\n} else if (x < 0) {\n    print(\"negative\");\n} else {\n    print(\"zero\");\n}\n\n// whileループ\nlet i = 0;\nwhile (i < 5) {\n    print(i);\n    i = i + 1;\n}\n\n// forループ\nfor (let j = 0; j < 10; j = j + 1) {\n    print(j);\n}\n```\n\n### 関数\n\n```hemlock\n// 名前付き関数\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nlet result = add(5, 3);  // 8\n\n// 匿名関数\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(multiply(4, 7));  // 28\n```\n\n## 文字列の操作\n\nHemlockの文字列は**ミュータブル**で**UTF-8**です：\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';              // \"Hello\"になる\nprint(s);\n\n// 文字列メソッド\nlet upper = s.to_upper();     // \"HELLO\"\nlet words = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\nlet sub = s.substr(1, 3);     // \"ell\"\n\n// 連結\nlet greeting = \"Hello\" + \", \" + \"World!\";\nprint(greeting);  // \"Hello, World!\"\n```\n\n## 配列\n\n混合型の動的配列：\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// 配列メソッド\nnumbers.push(6);        // [1, 2, 3, 4, 5, 6]\nlet last = numbers.pop();  // 6\nlet slice = numbers.slice(1, 4);  // [2, 3, 4]\n\n// 混合型も可能\nlet mixed = [1, \"two\", true, null];\n```\n\n## オブジェクト\n\nJavaScriptスタイルのオブジェクト：\n\n```hemlock\n// オブジェクトリテラル\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nperson.age = 31;     // フィールドを変更\n\n// 'self'を使ったメソッド\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## メモリ管理\n\nHemlockは**手動メモリ管理**を使用します：\n\n```hemlock\n// 安全なバッファ（推奨）\nlet buf = buffer(64);   // 64バイトを確保\nbuf[0] = 65;            // 最初のバイトを'A'に設定\nprint(buf[0]);          // 65\nfree(buf);              // メモリを解放\n\n// 生ポインタ（上級者向け）\nlet ptr = alloc(100);\nmemset(ptr, 0, 100);    // ゼロで埋める\nfree(ptr);\n```\n\n**重要**: `alloc()`したものは`free()`する必要があります！\n\n## エラーハンドリング\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Error: \" + e);\n} finally {\n    print(\"Done\");\n}\n```\n\n## コマンドライン引数\n\n`args`配列経由でプログラム引数にアクセス：\n\n```hemlock\n// script.hml\nprint(\"Script:\", args[0]);\nprint(`Arguments: ${args.length - 1}`);\n\nlet i = 1;\nwhile (i < args.length) {\n    print(`  arg ${i}: ${args[i]}`);\n    i = i + 1;\n}\n```\n\n実行：\n```bash\n./hemlock script.hml hello world\n```\n\n出力：\n```\nScript: script.hml\nArguments: 2\n  arg 1: hello\n  arg 2: world\n```\n\n## ファイルI/O\n\n```hemlock\n// ファイルへ書き込み\nlet f = open(\"data.txt\", \"w\");\nf.write(\"Hello, File!\");\nf.close();\n\n// ファイルから読み込み\nlet f2 = open(\"data.txt\", \"r\");\nlet content = f2.read();\nprint(content);  // \"Hello, File!\"\nf2.close();\n```\n\n## 次のステップ\n\n基本を学んだので、さらに探索しましょう：\n\n- [チュートリアル](#getting-started-tutorial) - 包括的なステップバイステップガイド\n- [言語ガイド](#language-guide-syntax) - すべての機能の詳細\n- [サンプル](../../examples/) - 実世界のサンプルプログラム\n- [APIリファレンス](#reference-builtins) - 完全なAPIドキュメント\n\n## よくある落とし穴\n\n### セミコロンの忘れ\n\n```hemlock\n// ❌ エラー：セミコロンがない\nlet x = 42\nlet y = 10\n\n// ✅ 正しい\nlet x = 42;\nlet y = 10;\n```\n\n### メモリ解放の忘れ\n\n```hemlock\n// ❌ メモリリーク\nlet buf = buffer(100);\n// ... bufを使用 ...\n// free(buf)を呼び忘れ！\n\n// ✅ 正しい\nlet buf = buffer(100);\n// ... bufを使用 ...\nfree(buf);\n```\n\n### ブレースは必須\n\n```hemlock\n// ❌ エラー：ブレースがない\nif (x > 0)\n    print(\"positive\");\n\n// ✅ 正しい\nif (x > 0) {\n    print(\"positive\");\n}\n```\n\n## ヘルプを得る\n\n- [完全なドキュメント](../README.md)を読む\n- [サンプルディレクトリ](../../examples/)を確認\n- 使用パターンについては[テストファイル](../../tests/)を参照\n- GitHubでissueを報告\n"}, "はじめに -> チュートリアル": {"id": "getting-started-tutorial", "content": "# Hemlockチュートリアル\n\nHemlockを学ぶための包括的なステップバイステップガイドです。\n\n## 目次\n\n1. [Hello World](#hello-world)\n2. [変数と型](#変数と型)\n3. [算術と演算](#算術と演算)\n4. [制御フロー](#制御フロー)\n5. [関数](#関数)\n6. [文字列とRune](#文字列とrune)\n7. [配列](#配列)\n8. [オブジェクト](#オブジェクト)\n9. [メモリ管理](#メモリ管理)\n10. [エラーハンドリング](#エラーハンドリング)\n11. [ファイルI/O](#ファイルio)\n12. [まとめ](#まとめ)\n\n## Hello World\n\n伝統的な最初のプログラムから始めましょう：\n\n```hemlock\nprint(\"Hello, World!\");\n```\n\nこれを`hello.hml`として保存し、実行します：\n\n```bash\n./hemlock hello.hml\n```\n\n**ポイント：**\n- `print()`はstdoutに出力する組み込み関数\n- 文字列はダブルクォートで囲む\n- セミコロンは**必須**\n\n## 変数と型\n\n### 変数の宣言\n\n```hemlock\n// 基本的な変数宣言\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\nprint(x);      // 42\nprint(name);   // Alice\nprint(pi);     // 3.14159\n```\n\n### 型注釈\n\n型はデフォルトで推論されますが、明示的にも指定できます：\n\n```hemlock\nlet age: i32 = 30;\nlet height: f64 = 5.9;\nlet initial: rune = 'A';\nlet active: bool = true;\n```\n\n### 型推論\n\nHemlockは値に基づいて型を推論します：\n\n```hemlock\nlet small = 42;              // i32（32ビットに収まる）\nlet large = 5000000000;      // i64（i32には大きすぎる）\nlet decimal = 3.14;          // f64（浮動小数点のデフォルト）\nlet text = \"hello\";          // string\nlet flag = true;             // bool\n```\n\n### 型チェック\n\n```hemlock\n// typeof()で型をチェック\nprint(typeof(42));        // \"i32\"\nprint(typeof(3.14));      // \"f64\"\nprint(typeof(\"hello\"));   // \"string\"\nprint(typeof(true));      // \"bool\"\nprint(typeof(null));      // \"null\"\n```\n\n## 算術と演算\n\n### 基本的な算術\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13\nprint(a - b);   // 7\nprint(a * b);   // 30\nprint(a / b);   // 3（整数除算）\nprint(a == b);  // false\nprint(a > b);   // true\n```\n\n### 型昇格\n\n型を混合すると、Hemlockはより大きい/より精度の高い型に昇格します：\n\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // resultはf64（10.0 + 3.5 = 13.5）\n\nprint(result);       // 13.5\nprint(typeof(result)); // \"f64\"\n```\n\n### ビット演算\n\n```hemlock\nlet a = 12;  // 2進数で1100\nlet b = 10;  // 2進数で1010\n\nprint(a & b);   // 8  (AND)\nprint(a | b);   // 14 (OR)\nprint(a ^ b);   // 6  (XOR)\nprint(a << 1);  // 24（左シフト）\nprint(a >> 1);  // 6 （右シフト）\nprint(~a);      // -13 (NOT)\n```\n\n## 制御フロー\n\n### if文\n\n```hemlock\nlet x = 10;\n\nif (x > 0) {\n    print(\"positive\");\n} else if (x < 0) {\n    print(\"negative\");\n} else {\n    print(\"zero\");\n}\n```\n\n**注意：** 単一の文でもブレースは**常に必須**です。\n\n### whileループ\n\n```hemlock\nlet count = 0;\nwhile (count < 5) {\n    print(`Count: ${count}`);\n    count = count + 1;\n}\n```\n\n### forループ\n\n```hemlock\n// Cスタイルのforループ\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n\n// for-inループ（配列）\nlet items = [10, 20, 30, 40];\nfor (let item in items) {\n    print(`Item: ${item}`);\n}\n```\n\n### switch文\n\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n        print(\"Monday\");\n        break;\n    case 2:\n        print(\"Tuesday\");\n        break;\n    case 3:\n        print(\"Wednesday\");\n        break;\n    default:\n        print(\"Other day\");\n        break;\n}\n```\n\n### breakとcontinue\n\n```hemlock\n// break：ループを早期終了\nlet i = 0;\nwhile (i < 10) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// 出力：0, 1, 2, 3, 4\n\n// continue：次のイテレーションにスキップ\nfor (let j = 0; j < 5; j = j + 1) {\n    if (j == 2) {\n        continue;\n    }\n    print(j);\n}\n// 出力：0, 1, 3, 4\n```\n\n## 関数\n\n### 名前付き関数\n\n```hemlock\nfn greet(name: string): string {\n    return \"Hello, \" + name + \"!\";\n}\n\nlet message = greet(\"Alice\");\nprint(message);  // \"Hello, Alice!\"\n```\n\n### 匿名関数\n\n```hemlock\nlet add = fn(a, b) {\n    return a + b;\n};\n\nprint(add(5, 3));  // 8\n```\n\n### 再帰\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### クロージャ\n\n関数は環境をキャプチャします：\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n### 高階関数\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 21);\nprint(result);  // 42\n```\n\n## 文字列とRune\n\n### 文字列の基本\n\n文字列は**ミュータブル**で**UTF-8**です：\n\n```hemlock\nlet s = \"hello\";\nprint(s.length);      // 5（文字数）\nprint(s.byte_length); // 5（バイト数）\n\n// ミューテーション\ns[0] = 'H';\nprint(s);  // \"Hello\"\n```\n\n### 文字列メソッド\n\n```hemlock\nlet text = \"  Hello, World!  \";\n\n// 大文字小文字変換\nprint(text.to_upper());  // \"  HELLO, WORLD!  \"\nprint(text.to_lower());  // \"  hello, world!  \"\n\n// トリミング\nprint(text.trim());      // \"Hello, World!\"\n\n// 部分文字列抽出\nlet hello = text.substr(2, 5);  // \"Hello\"\nlet world = text.slice(9, 14);  // \"World\"\n\n// 検索\nlet pos = text.find(\"World\");   // 9\nlet has = text.contains(\"o\");   // true\n\n// 分割\nlet parts = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\n\n// 置換\nlet s = \"hello world\".replace(\"world\", \"there\");\nprint(s);  // \"hello there\"\n```\n\n### Rune（Unicodeコードポイント）\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '🚀';\n\nprint(ch);      // 'A'\nprint(emoji);   // U+1F680\n\n// Rune + 文字列の連結\nlet msg = '>' + \" Important\";\nprint(msg);  // \"> Important\"\n\n// runeと整数間の変換\nlet code: i32 = ch;     // 65（ASCIIコード）\nlet r: rune = 128640;   // U+1F680（🚀）\n```\n\n## 配列\n\n### 配列の基本\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// 要素を変更\nnumbers[2] = 99;\nprint(numbers[2]);  // 99\n```\n\n### 配列メソッド\n\n```hemlock\nlet arr = [10, 20, 30];\n\n// 末尾に追加/削除\narr.push(40);           // [10, 20, 30, 40]\nlet last = arr.pop();   // 40、arrは[10, 20, 30]になる\n\n// 先頭に追加/削除\narr.unshift(5);         // [5, 10, 20, 30]\nlet first = arr.shift(); // 5、arrは[10, 20, 30]になる\n\n// インデックスで挿入/削除\narr.insert(1, 15);      // [10, 15, 20, 30]\nlet removed = arr.remove(2);  // 20\n\n// 検索\nlet index = arr.find(15);     // 1\nlet has = arr.contains(10);   // true\n\n// スライス\nlet slice = arr.slice(0, 2);  // [10, 15]\n\n// 文字列に結合\nlet text = arr.join(\", \");    // \"10, 15, 30\"\n```\n\n### イテレーション\n\n```hemlock\nlet items = [\"apple\", \"banana\", \"cherry\"];\n\n// for-inループ\nfor (let item in items) {\n    print(item);\n}\n\n// 手動イテレーション\nlet i = 0;\nwhile (i < items.length) {\n    print(items[i]);\n    i = i + 1;\n}\n```\n\n## オブジェクト\n\n### オブジェクトリテラル\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nprint(person.age);   // 30\n\n// フィールドの追加/変更\nperson.email = \"alice@example.com\";\nperson.age = 31;\n```\n\n### メソッドと`self`\n\n```hemlock\nlet calculator = {\n    value: 0,\n    add: fn(x) {\n        self.value = self.value + x;\n    },\n    get: fn() {\n        return self.value;\n    }\n};\n\ncalculator.add(10);\ncalculator.add(5);\nprint(calculator.get());  // 15\n```\n\n### 型定義（ダック型）\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,  // デフォルト付きオプション\n}\n\nlet p = { name: \"Bob\", age: 25 };\nlet typed: Person = p;  // ダック型が構造を検証\n\nprint(typeof(typed));   // \"Person\"\nprint(typed.active);    // true（デフォルトが適用）\n```\n\n### JSONシリアライゼーション\n\n```hemlock\nlet obj = { x: 10, y: 20, name: \"test\" };\n\n// オブジェクトからJSON\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// JSONからオブジェクト\nlet restored = json.deserialize();\nprint(restored.name);  // \"test\"\n```\n\n## メモリ管理\n\n### 安全なバッファ（推奨）\n\n```hemlock\n// バッファを確保\nlet buf = buffer(10);\nprint(buf.length);    // 10\nprint(buf.capacity);  // 10\n\n// 値を設定（境界チェック付き）\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// 値にアクセス\nprint(buf[0]);  // 65\n\n// 完了時に解放必須\nfree(buf);\n```\n\n### 生ポインタ（上級者向け）\n\n```hemlock\n// 生メモリを確保\nlet ptr = alloc(100);\n\n// ゼロで埋める\nmemset(ptr, 0, 100);\n\n// データをコピー\nlet src = alloc(50);\nmemcpy(ptr, src, 50);\n\n// 両方を解放\nfree(src);\nfree(ptr);\n```\n\n### メモリ関数\n\n```hemlock\n// 再確保\nlet p = alloc(64);\np = realloc(p, 128);  // 128バイトにリサイズ\nfree(p);\n\n// 型付き確保（将来）\n// let arr = talloc(i32, 100);  // 100個のi32の配列\n```\n\n## エラーハンドリング\n\n### try/catch\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Error: \" + e);\n}\n// 出力：Error: division by zero\n```\n\n### finallyブロック\n\n```hemlock\nlet file = null;\n\ntry {\n    file = open(\"data.txt\", \"r\");\n    let content = file.read();\n    print(content);\n} catch (e) {\n    print(\"Error: \" + e);\n} finally {\n    // 常に実行\n    if (file != null) {\n        file.close();\n    }\n}\n```\n\n### オブジェクトをthrow\n\n```hemlock\ntry {\n    throw { code: 404, message: \"Not found\" };\n} catch (e) {\n    print(`Error ${e.code}: ${e.message}`);\n}\n// 出力：Error 404: Not found\n```\n\n### panic（回復不能エラー）\n\n```hemlock\nfn validate(x) {\n    if (x < 0) {\n        panic(\"x must be non-negative\");\n    }\n    return x * 2;\n}\n\nvalidate(-5);  // プログラムは終了：panic: x must be non-negative\n```\n\n## ファイルI/O\n\n### ファイルの読み込み\n\n```hemlock\n// ファイル全体を読み込み\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n\n// 特定のバイト数を読み込み\nlet f2 = open(\"data.txt\", \"r\");\nlet chunk = f2.read(100);  // 100バイト読み込み\nf2.close();\n```\n\n### ファイルへの書き込み\n\n```hemlock\n// テキストを書き込み\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Hello, File!\\n\");\nf.write(\"Second line\\n\");\nf.close();\n\n// ファイルに追記\nlet f2 = open(\"output.txt\", \"a\");\nf2.write(\"Appended line\\n\");\nf2.close();\n```\n\n### バイナリI/O\n\n```hemlock\n// バイナリデータを書き込み\nlet buf = buffer(256);\nbuf[0] = 255;\nbuf[1] = 128;\n\nlet f = open(\"data.bin\", \"w\");\nf.write_bytes(buf);\nf.close();\n\n// バイナリデータを読み込み\nlet f2 = open(\"data.bin\", \"r\");\nlet data = f2.read_bytes(256);\nprint(data[0]);  // 255\nf2.close();\n\nfree(buf);\nfree(data);\n```\n\n### ファイルプロパティ\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\n\nprint(f.path);    // \"/path/to/file.txt\"\nprint(f.mode);    // \"r\"\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n## まとめ\n\nシンプルな単語カウンタプログラムを作りましょう：\n\n```hemlock\n// wordcount.hml - ファイル内の単語をカウント\n\nfn count_words(filename: string): i32 {\n    let file = null;\n    let count = 0;\n\n    try {\n        file = open(filename, \"r\");\n        let content = file.read();\n\n        // 空白で分割してカウント\n        let words = content.split(\" \");\n        count = words.length;\n\n    } catch (e) {\n        print(\"Error reading file: \" + e);\n        return -1;\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n\n    return count;\n}\n\n// メインプログラム\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    let words = count_words(filename);\n\n    if (words >= 0) {\n        print(`Word count: ${words}`);\n    }\n}\n```\n\n実行：\n```bash\n./hemlock wordcount.hml data.txt\n```\n\n## 次のステップ\n\nおめでとうございます！Hemlockの基本を学びました。次に探索するものはこちらです：\n\n- [非同期と並行処理](#advanced-async-concurrency) - 真のマルチスレッド\n- [FFI](#advanced-ffi) - C関数を呼び出す\n- [シグナルハンドリング](#advanced-signals) - プロセスシグナル\n- [APIリファレンス](#reference-builtins) - 完全なAPIドキュメント\n- [サンプル](../../examples/) - より実世界のプログラム\n\n## 練習問題\n\n練習のためにこれらのプログラムを作ってみてください：\n\n1. **電卓**: +、-、*、/の簡単な電卓を実装\n2. **ファイルコピー**: 1つのファイルを別のファイルにコピー\n3. **フィボナッチ**: フィボナッチ数を生成\n4. **JSONパーサー**: JSONファイルを読み込んでパース\n5. **テキストプロセッサ**: ファイル内のテキストを検索・置換\n\nHemlockで楽しいコーディングを！\n"}, "はじめに -> 学習パス": {"id": "getting-started-learning-paths", "content": "# 学習パス\n\n目標によって必要な知識は異なります。作りたいものに合ったパスを選んでください。\n\n---\n\n## パス1：クイックスクリプトと自動化\n\n**目標：** タスクを自動化し、ファイルを処理し、仕事を片付けるスクリプトを書く。\n\n**生産性までの時間：** 速い - すぐに便利なスクリプトを書き始められます。\n\n### 学ぶこと\n\n1. **[クイックスタート](#getting-started-quick-start)** - 最初のプログラム、基本構文\n2. **[文字列](#language-guide-strings)** - テキスト処理、分割、検索\n3. **[配列](#language-guide-arrays)** - リスト、フィルタリング、データ変換\n4. **[ファイルI/O](#advanced-file-io)** - ファイルの読み書き\n5. **[コマンドライン引数](#advanced-command-line-args)** - ユーザーからの入力を取得\n\n### 今はスキップ\n\n- メモリ管理（スクリプトでは自動）\n- 非同期/並行処理（シンプルなスクリプトには過剰）\n- FFI（Cインターオペが必要な場合のみ）\n\n### サンプルプロジェクト：ファイルリネーマー\n\n```hemlock\nimport { list_dir, rename } from \"@stdlib/fs\";\n\n// すべての.txtファイルを.mdにリネーム\nlet files = list_dir(\".\");\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let new_name = file.replace(\".txt\", \".md\");\n        rename(file, new_name);\n        print(`Renamed: ${file} -> ${new_name}`);\n    }\n}\n```\n\n---\n\n## パス2：データ処理と分析\n\n**目標：** データをパースし、変換し、レポートを生成する。\n\n**生産性までの時間：** 速い - Hemlockの文字列と配列メソッドがこれを簡単にします。\n\n### 学ぶこと\n\n1. **[クイックスタート](#getting-started-quick-start)** - 基本\n2. **[文字列](#language-guide-strings)** - パース、分割、フォーマット\n3. **[配列](#language-guide-arrays)** - データ変換用のmap、filter、reduce\n4. **[オブジェクト](#language-guide-objects)** - 構造化データ\n5. **標準ライブラリ：**\n   - **[@stdlib/json](#stdlib-json)** - JSONパース\n   - **[@stdlib/csv](#stdlib-csv)** - CSVファイル\n   - **[@stdlib/fs](#stdlib-fs)** - ファイル操作\n\n### サンプルプロジェクト：CSVアナライザー\n\n```hemlock\nimport { read_file } from \"@stdlib/fs\";\nimport { parse } from \"@stdlib/csv\";\n\nlet data = parse(read_file(\"sales.csv\"));\n\n// 合計売上を計算\nlet total = 0;\nfor (row in data) {\n    total = total + f64(row.amount);\n}\n\nprint(`Total sales: $${total}`);\n\n// トップセラーを見つける\nlet top = data[0];\nfor (row in data) {\n    if (f64(row.amount) > f64(top.amount)) {\n        top = row;\n    }\n}\n\nprint(`Top sale: ${top.product} - $${top.amount}`);\n```\n\n---\n\n## パス3：WebとネットワークプログラミングPath 3: Web & Network Programming\n\n**目標：** HTTPクライアントを構築し、APIを操作し、サーバーを作成する。\n\n**生産性までの時間：** 中程度 - 非同期の基本の理解が必要。\n\n### 学ぶこと\n\n1. **[クイックスタート](#getting-started-quick-start)** - 基本\n2. **[関数](#language-guide-functions)** - コールバックとクロージャ\n3. **[エラーハンドリング](#language-guide-error-handling)** - ネットワークエラー用のtry/catch\n4. **[非同期と並行処理](#advanced-async-concurrency)** - spawn、await、channels\n5. **標準ライブラリ：**\n   - **[@stdlib/http](#stdlib-http)** - HTTPリクエスト\n   - **[@stdlib/json](#stdlib-json)** - API用JSON\n   - **[@stdlib/net](#stdlib-net)** - TCP/UDPソケット\n   - **[@stdlib/url](#stdlib-url)** - URLパース\n\n### サンプルプロジェクト：APIクライアント\n\n```hemlock\nimport { http_get, http_post } from \"@stdlib/http\";\nimport { parse, stringify } from \"@stdlib/json\";\n\n// GETリクエスト\nlet response = http_get(\"https://api.example.com/users\");\nlet users = parse(response.body);\n\nfor (user in users) {\n    print(`${user.name}: ${user.email}`);\n}\n\n// POSTリクエスト\nlet new_user = { name: \"Alice\", email: \"alice@example.com\" };\nlet result = http_post(\"https://api.example.com/users\", {\n    body: stringify(new_user),\n    headers: { \"Content-Type\": \"application/json\" }\n});\n\nprint(`Created user with ID: ${parse(result.body).id}`);\n```\n\n---\n\n## パス4：システムプログラミング\n\n**目標：** 低レベルコードを書き、メモリを操作し、Cライブラリとインターフェースする。\n\n**生産性までの時間：** 長め - メモリ管理の理解が必要。\n\n### 学ぶこと\n\n1. **[クイックスタート](#getting-started-quick-start)** - 基本\n2. **[型](#language-guide-types)** - i32、u8、ptrなどの理解\n3. **[メモリ管理](#language-guide-memory)** - alloc、free、バッファ\n4. **[FFI](#advanced-ffi)** - C関数の呼び出し\n5. **[シグナル](#advanced-signals)** - シグナルハンドリング\n\n### 主要概念\n\n**メモリ安全性チェックリスト：**\n- [ ] すべての`alloc()`に対応する`free()`がある\n- [ ] 生の`ptr`が必要でなければ`buffer()`を使用\n- [ ] 解放後はポインタを`null`に設定\n- [ ] クリーンアップを保証するために`try/finally`を使用\n\n**FFI用の型マッピング：**\n| Hemlock | C |\n|---------|---|\n| `i8` | `char` / `int8_t` |\n| `i32` | `int` |\n| `i64` | `long`（64ビット） |\n| `u8` | `unsigned char` |\n| `f64` | `double` |\n| `ptr` | `void*` |\n\n### サンプルプロジェクト：カスタムメモリプール\n\n```hemlock\n// シンプルなバンプアロケータ\nlet pool_size = 1024 * 1024;  // 1MB\nlet pool = alloc(pool_size);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > pool_size) {\n        throw \"Pool exhausted\";\n    }\n    let p = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return p;\n}\n\nfn pool_reset() {\n    pool_offset = 0;\n}\n\nfn pool_destroy() {\n    free(pool);\n}\n\n// 使用例\nlet a = pool_alloc(100);\nlet b = pool_alloc(200);\nmemset(a, 0, 100);\nmemset(b, 0, 200);\n\npool_reset();  // すべてのメモリを再利用\npool_destroy();  // クリーンアップ\n```\n\n---\n\n## パス5：並列・並行プログラム\n\n**目標：** 複数のCPUコアでコードを実行し、レスポンシブなアプリケーションを構築する。\n\n**生産性までの時間：** 中程度 - async構文は簡単ですが、並列処理の推論には練習が必要。\n\n### 学ぶこと\n\n1. **[クイックスタート](#getting-started-quick-start)** - 基本\n2. **[関数](#language-guide-functions)** - クロージャ（非同期で重要）\n3. **[非同期と並行処理](#advanced-async-concurrency)** - 完全な詳細解説\n4. **[アトミック](#advanced-atomics)** - ロックフリープログラミング\n\n### 主要概念\n\n**Hemlockの非同期モデル：**\n- `async fn` - 別のスレッドで実行できる関数を定義\n- `spawn(fn, args...)` - 実行を開始、タスクハンドルを返す\n- `join(task)`または`await task` - 完了を待ち、結果を取得\n- `channel(size)` - タスク間でデータを送信するためのキューを作成\n\n**重要：** タスクは値の*コピー*を受け取ります。ポインタを渡す場合、タスクが完了するまでメモリが有効であることを保証する責任があります。\n\n### サンプルプロジェクト：並列ファイルプロセッサ\n\n```hemlock\nimport { list_dir, read_file } from \"@stdlib/fs\";\n\nasync fn process_file(path: string): i32 {\n    let content = read_file(path);\n    let lines = content.split(\"\\n\");\n    return lines.length;\n}\n\n// すべてのファイルを並列処理\nlet files = list_dir(\"data/\");\nlet tasks = [];\n\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let task = spawn(process_file, \"data/\" + file);\n        tasks.push({ name: file, task: task });\n    }\n}\n\n// 結果を収集\nlet total_lines = 0;\nfor (item in tasks) {\n    let count = join(item.task);\n    print(`${item.name}: ${count} lines`);\n    total_lines = total_lines + count;\n}\n\nprint(`Total: ${total_lines} lines`);\n```\n\n---\n\n## 最初に学ぶこと（どのパスでも）\n\n目標に関係なく、これらの基本から始めましょう：\n\n### 第1週：コア基本\n\n1. **[クイックスタート](#getting-started-quick-start)** - 最初のプログラムを書いて実行\n2. **[構文](#language-guide-syntax)** - 変数、演算子、制御フロー\n3. **[関数](#language-guide-functions)** - 関数の定義と呼び出し\n\n### 第2週：データハンドリング\n\n4. **[文字列](#language-guide-strings)** - テキスト操作\n5. **[配列](#language-guide-arrays)** - コレクションとイテレーション\n6. **[オブジェクト](#language-guide-objects)** - 構造化データ\n\n### 第3週：堅牢性\n\n7. **[エラーハンドリング](#language-guide-error-handling)** - try/catch/throw\n8. **[モジュール](#language-guide-modules)** - import/export、stdlibの使用\n\n### その後：上記からパスを選択\n\n---\n\n## チートシート：他の言語からの移行\n\n### Pythonから\n\n| Python | Hemlock | 備考 |\n|--------|---------|-------|\n| `x = 42` | `let x = 42;` | セミコロン必須 |\n| `def fn():` | `fn name() { }` | ブレース必須 |\n| `if x:` | `if (x) { }` | 括弧とブレース必須 |\n| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | Cスタイルforループ |\n| `for item in list:` | `for (item in array) { }` | for-inは同じ動作 |\n| `list.append(x)` | `array.push(x);` | 異なるメソッド名 |\n| `len(s)` | `s.length`または`len(s)` | 両方とも動作 |\n| 自動メモリ | `ptr`は手動 | ほとんどの型は自動クリーンアップ |\n\n### JavaScriptから\n\n| JavaScript | Hemlock | 備考 |\n|------------|---------|-------|\n| `let x = 42` | `let x = 42;` | 同じ（セミコロン必須） |\n| `const x = 42` | `let x = 42;` | constキーワードなし |\n| `function fn()` | `fn name() { }` | 異なるキーワード |\n| `() => x` | `fn() { return x; }` | アロー関数なし |\n| `async/await` | `async/await` | 同じ構文 |\n| `Promise` | `spawn/join` | 異なるモデル |\n| 自動GC | `ptr`は手動 | ほとんどの型は自動クリーンアップ |\n\n### C/C++から\n\n| C | Hemlock | 備考 |\n|---|---------|-------|\n| `int x = 42;` | `let x: i32 = 42;` | 型はコロンの後 |\n| `malloc(n)` | `alloc(n)` | 同じ概念 |\n| `free(p)` | `free(p)` | 同じ |\n| `char* s = \"hi\"` | `let s = \"hi\";` | 文字列は管理される |\n| `#include` | `import { } from` | モジュールインポート |\n| すべて手動 | ほとんどの型は自動 | `ptr`のみ手動が必要 |\n\n---\n\n## ヘルプを得る\n\n- **[用語集](../glossary.md)** - プログラミング用語の定義\n- **[サンプル](../../examples/)** - 完全な動作プログラム\n- **[テスト](../../tests/)** - 機能の使い方を見る\n- **GitHubのIssue** - 質問やバグ報告\n\n---\n\n## 難易度レベル\n\nドキュメント全体で以下のマーカーが表示されます：\n\n| マーカー | 意味 |\n|--------|---------|\n| **初級** | プログラミング経験不要 |\n| **中級** | 基本的なプログラミング知識を前提 |\n| **上級** | システム概念の理解が必要 |\n\n「初級」とマークされたものが分かりにくい場合は、[用語集](../glossary.md)で用語の定義を確認してください。\n"}, "言語ガイド -> エラー処理": {"id": "language-guide-error-handling", "content": "# エラーハンドリング\n\nHemlockは`try`、`catch`、`finally`、`throw`、`panic`による例外ベースのエラーハンドリングをサポートしています。このガイドでは、例外による回復可能なエラーとpanicによる回復不可能なエラーについて説明します。\n\n## 概要\n\n```hemlock\n// 基本的なエラーハンドリング\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\n// クリーンアップ付き\ntry {\n    process_file();\n} catch (e) {\n    print(\"Failed: \" + e);\n} finally {\n    cleanup();\n}\n\n// エラーのスロー\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n```\n\n## Try-Catch-Finally\n\n### 構文\n\n**基本的なtry/catch：**\n```hemlock\ntry {\n    // 危険なコード\n} catch (e) {\n    // エラーを処理、eはスローされた値を含む\n}\n```\n\n**Try/finally：**\n```hemlock\ntry {\n    // 危険なコード\n} finally {\n    // 例外がスローされても常に実行\n}\n```\n\n**Try/catch/finally：**\n```hemlock\ntry {\n    // 危険なコード\n} catch (e) {\n    // エラーを処理\n} finally {\n    // クリーンアップコード\n}\n```\n\n### Tryブロック\n\ntryブロックは文を順次実行します：\n\n```hemlock\ntry {\n    print(\"Starting...\");\n    risky_operation();\n    print(\"Success!\");  // 例外がなければ実行\n}\n```\n\n**動作：**\n- 文を順番に実行\n- 例外がスローされた場合：`catch`または`finally`にジャンプ\n- 例外がない場合：`finally`（存在すれば）を実行して続行\n\n### Catchブロック\n\ncatchブロックはスローされた値を受け取ります：\n\n```hemlock\ntry {\n    throw \"oops\";\n} catch (error) {\n    print(\"Caught: \" + error);  // error = \"oops\"\n    // errorはここでのみアクセス可能\n}\n// errorはここではアクセスできない\n```\n\n**Catchパラメータ：**\n- スローされた値（任意の型）を受け取る\n- catchブロックにスコープされる\n- 任意の名前を付けられる（慣例として`e`、`err`、または`error`）\n\n**catchでできること：**\n```hemlock\ntry {\n    risky_operation();\n} catch (e) {\n    // エラーをログ\n    print(\"Error: \" + e);\n\n    // 同じエラーを再スロー\n    throw e;\n\n    // 別のエラーをスロー\n    throw \"different error\";\n\n    // デフォルト値を返す\n    return null;\n\n    // 処理して続行\n    // （再スローなし）\n}\n```\n\n### Finallyブロック\n\nfinallyブロックは**常に実行されます**：\n\n```hemlock\ntry {\n    print(\"1: try\");\n    throw \"error\";\n} catch (e) {\n    print(\"2: catch\");\n} finally {\n    print(\"3: finally\");  // 常に実行\n}\nprint(\"4: after\");\n\n// 出力：1: try, 2: catch, 3: finally, 4: after\n```\n\n**finallyが実行されるタイミング：**\n- tryブロックの後（例外がない場合）\n- catchブロックの後（例外がキャッチされた場合）\n- try/catchに`return`、`break`、または`continue`が含まれていても\n- 制御フローがtry/catchを抜ける前\n\n**returnとfinally：**\n```hemlock\nfn example() {\n    try {\n        return 1;  // finallyの実行後に1を返す\n    } finally {\n        print(\"cleanup\");  // 戻る前に実行\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // finallyのreturnが上書き - 2を返す\n    }\n}\n```\n\n**制御フローとfinally：**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) {\n            break;  // finallyの実行後にbreak\n        }\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```\n\n## Throw文\n\n### 基本的なThrow\n\n任意の値を例外としてスロー：\n\n```hemlock\nthrow \"error message\";\nthrow 404;\nthrow { code: 500, message: \"Internal error\" };\nthrow null;\nthrow [\"error\", \"details\"];\n```\n\n**実行：**\n1. 式を評価\n2. 最も近い囲んでいる`catch`に即座にジャンプ\n3. `catch`がない場合、コールスタックを伝播\n\n### エラーのスロー\n\n```hemlock\nfn validate_age(age: i32) {\n    if (age < 0) {\n        throw \"Age cannot be negative\";\n    }\n    if (age > 150) {\n        throw \"Age is unrealistic\";\n    }\n}\n\ntry {\n    validate_age(-5);\n} catch (e) {\n    print(\"Validation error: \" + e);\n}\n```\n\n### エラーオブジェクトのスロー\n\n構造化されたエラー情報を作成：\n\n```hemlock\nfn read_file(path: string) {\n    if (!file_exists(path)) {\n        throw {\n            type: \"FileNotFound\",\n            path: path,\n            message: \"File does not exist\"\n        };\n    }\n    // ... ファイルを読み込み\n}\n\ntry {\n    read_file(\"missing.txt\");\n} catch (e) {\n    if (e.type == \"FileNotFound\") {\n        print(\"File not found: \" + e.path);\n    }\n}\n```\n\n### 再スロー\n\nエラーをキャッチして再スロー：\n\n```hemlock\nfn wrapper() {\n    try {\n        risky_operation();\n    } catch (e) {\n        print(\"Logging error: \" + e);\n        throw e;  // 呼び出し元に再スロー\n    }\n}\n\ntry {\n    wrapper();\n} catch (e) {\n    print(\"Caught in main: \" + e);\n}\n```\n\n## キャッチされない例外\n\n例外がキャッチされずにコールスタックの最上部に伝播した場合：\n\n```hemlock\nfn foo() {\n    throw \"uncaught!\";\n}\n\nfoo();  // クラッシュ：Runtime error: uncaught!\n```\n\n**動作：**\n- プログラムがクラッシュ\n- stderrにエラーメッセージを出力\n- 非ゼロのステータスコードで終了\n- スタックトレースは将来のバージョンで追加予定\n\n## Panic - 回復不可能なエラー\n\n### Panicとは？\n\n`panic()`はプログラムを即座に終了させるべき**回復不可能なエラー**用です：\n\n```hemlock\npanic();                    // デフォルトメッセージ：\"panic!\"\npanic(\"custom message\");    // カスタムメッセージ\npanic(42);                  // 非文字列値も出力される\n```\n\n**セマンティクス：**\n- 終了コード1でプログラムを**即座に終了**\n- stderrにエラーメッセージを出力：`panic: <message>`\n- try/catchで**キャッチ不可能**\n- バグや回復不可能なエラーに使用\n\n### Panic vs Throw\n\n```hemlock\n// throw - 回復可能なエラー（キャッチ可能）\ntry {\n    throw \"recoverable error\";\n} catch (e) {\n    print(\"Caught: \" + e);  // 正常にキャッチ\n}\n\n// panic - 回復不可能なエラー（キャッチ不可能）\ntry {\n    panic(\"unrecoverable error\");  // プログラムは即座に終了\n} catch (e) {\n    print(\"This never runs\");       // 実行されない\n}\n```\n\n### Panicを使用するタイミング\n\n**panicを使用する場面：**\n- **バグ**：到達不可能なコードに到達した\n- **無効な状態**：データ構造の破損が検出された\n- **回復不可能なエラー**：重要なリソースが利用不可能\n- **アサーション失敗**：`assert()`では不十分な場合\n\n**例：**\n```hemlock\n// 到達不可能なコード\nfn process_state(state: i32) {\n    if (state == 1) {\n        return \"ready\";\n    } else if (state == 2) {\n        return \"running\";\n    } else if (state == 3) {\n        return \"stopped\";\n    } else {\n        panic(\"invalid state: \" + typeof(state));  // 発生してはならない\n    }\n}\n\n// 重要なリソースのチェック\nfn init_system() {\n    let config = read_file(\"config.json\");\n    if (config == null) {\n        panic(\"config.json not found - cannot start\");\n    }\n    // ...\n}\n\n// データ構造の不変条件\nfn pop_stack(stack) {\n    if (stack.length == 0) {\n        panic(\"pop() called on empty stack\");\n    }\n    return stack.pop();\n}\n```\n\n### Panicを使用しないタイミング\n\n**代わりにthrowを使用する場面：**\n- ユーザー入力の検証\n- ファイルが見つからない\n- ネットワークエラー\n- 予期されるエラー条件\n\n```hemlock\n// 悪い：予期されるエラーにpanic\nfn divide(a, b) {\n    if (b == 0) {\n        panic(\"division by zero\");  // 厳しすぎる\n    }\n    return a / b;\n}\n\n// 良い：予期されるエラーにthrow\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";  // 回復可能\n    }\n    return a / b;\n}\n```\n\n## 制御フローとの相互作用\n\n### Try/Catch/Finally内のReturn\n\n```hemlock\nfn example() {\n    try {\n        return 1;  // finallyの実行後に1を返す\n    } finally {\n        print(\"cleanup\");\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // finallyのreturnがtryのreturnを上書き - 2を返す\n    }\n}\n```\n\n**ルール：** finallyブロックの戻り値はtry/catchの戻り値を上書きします。\n\n### Try/Catch/Finally内のBreak/Continue\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) { break; }  // finallyの実行後にbreak\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```\n\n**ルール：** Break/continueはfinallyブロックの後に実行されます。\n\n### ネストされたTry/Catch\n\n```hemlock\ntry {\n    try {\n        throw \"inner\";\n    } catch (e) {\n        print(\"Caught: \" + e);  // 出力：Caught: inner\n        throw \"outer\";  // 別のエラーを再スロー\n    }\n} catch (e) {\n    print(\"Caught: \" + e);  // 出力：Caught: outer\n}\n```\n\n**ルール：** ネストされたtry/catchブロックは期待通りに動作し、内側のcatchが先に発生します。\n\n## よくあるパターン\n\n### パターン：リソースクリーンアップ\n\nクリーンアップには常に`finally`を使用：\n\n```hemlock\nfn process_file(filename) {\n    let file = null;\n    try {\n        file = open(filename);\n        let content = file.read();\n        process(content);\n    } catch (e) {\n        print(\"Error processing file: \" + e);\n    } finally {\n        if (file != null) {\n            file.close();  // エラー時も常にクローズ\n        }\n    }\n}\n```\n\n### パターン：エラーラッピング\n\n低レベルのエラーにコンテキストを追加：\n\n```hemlock\nfn load_config(path) {\n    try {\n        let content = read_file(path);\n        return parse_json(content);\n    } catch (e) {\n        throw \"Failed to load config from \" + path + \": \" + e;\n    }\n}\n```\n\n### パターン：エラーリカバリ\n\nエラー時にフォールバックを提供：\n\n```hemlock\nfn safe_divide(a, b) {\n    try {\n        if (b == 0) {\n            throw \"division by zero\";\n        }\n        return a / b;\n    } catch (e) {\n        print(\"Error: \" + e);\n        return null;  // フォールバック値\n    }\n}\n```\n\n### パターン：バリデーション\n\nバリデーションに例外を使用：\n\n```hemlock\nfn validate_user(user) {\n    if (user.name == null || user.name == \"\") {\n        throw \"Name is required\";\n    }\n    if (user.age < 0 || user.age > 150) {\n        throw \"Invalid age\";\n    }\n    if (user.email == null || !user.email.contains(\"@\")) {\n        throw \"Invalid email\";\n    }\n}\n\ntry {\n    validate_user({ name: \"Alice\", age: -5, email: \"invalid\" });\n} catch (e) {\n    print(\"Validation failed: \" + e);\n}\n```\n\n### パターン：複数のエラータイプ\n\nエラーオブジェクトを使用してエラータイプを区別：\n\n```hemlock\nfn process_data(data) {\n    if (data == null) {\n        throw { type: \"NullData\", message: \"Data is null\" };\n    }\n\n    if (typeof(data) != \"array\") {\n        throw { type: \"TypeError\", message: \"Expected array\" };\n    }\n\n    if (data.length == 0) {\n        throw { type: \"EmptyData\", message: \"Array is empty\" };\n    }\n\n    // ... 処理\n}\n\ntry {\n    process_data(null);\n} catch (e) {\n    if (e.type == \"NullData\") {\n        print(\"No data provided\");\n    } else if (e.type == \"TypeError\") {\n        print(\"Wrong data type: \" + e.message);\n    } else {\n        print(\"Error: \" + e.message);\n    }\n}\n```\n\n## ベストプラクティス\n\n1. **例外は例外的なケースに使用** - 通常の制御フローには使用しない\n2. **意味のあるエラーをスロー** - コンテキストを含む文字列またはオブジェクト\n3. **クリーンアップには常にfinallyを使用** - リソースの解放を確実に\n4. **キャッチして無視しない** - 少なくともエラーをログ\n5. **適切に再スロー** - 処理できない場合は呼び出し元に処理させる\n6. **バグにはpanicを使用** - 回復不可能なエラーにはpanicを使用\n7. **例外をドキュメント化** - 関数がスローできるものを明確に\n\n## よくある落とし穴\n\n### 落とし穴：エラーを飲み込む\n\n```hemlock\n// 悪い：サイレントな失敗\ntry {\n    risky_operation();\n} catch (e) {\n    // エラーを無視 - サイレントな失敗\n}\n\n// 良い：ログまたは処理\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Operation failed: \" + e);\n    // 適切に処理\n}\n```\n\n### 落とし穴：Finallyのオーバーライド\n\n```hemlock\n// 悪い：finallyがreturnを上書き\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        return 0;  // 42ではなく0を返す！\n    }\n}\n\n// 良い：finallyでreturnしない\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        cleanup();  // クリーンアップのみ、returnなし\n    }\n}\n```\n\n### 落とし穴：クリーンアップ忘れ\n\n```hemlock\n// 悪い：エラー時にファイルがクローズされないかも\nfn process() {\n    let file = open(\"data.txt\");\n    let content = file.read();  // スローするかも\n    file.close();  // エラー時は到達しない\n}\n\n// 良い：finallyを使用\nfn process() {\n    let file = null;\n    try {\n        file = open(\"data.txt\");\n        let content = file.read();\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n}\n```\n\n### 落とし穴：予期されるエラーにPanicを使用\n\n```hemlock\n// 悪い：予期されるエラーにpanic\nfn read_config(path) {\n    if (!file_exists(path)) {\n        panic(\"Config file not found\");  // 厳しすぎる\n    }\n    return read_file(path);\n}\n\n// 良い：予期されるエラーにthrow\nfn read_config(path) {\n    if (!file_exists(path)) {\n        throw \"Config file not found: \" + path;  // 回復可能\n    }\n    return read_file(path);\n}\n```\n\n## 例\n\n### 例：基本的なエラーハンドリング\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    print(divide(10, 0));\n} catch (e) {\n    print(\"Error: \" + e);  // 出力：Error: division by zero\n}\n```\n\n### 例：リソース管理\n\n```hemlock\nfn copy_file(src, dst) {\n    let src_file = null;\n    let dst_file = null;\n\n    try {\n        src_file = open(src, \"r\");\n        dst_file = open(dst, \"w\");\n\n        let content = src_file.read();\n        dst_file.write(content);\n\n        print(\"File copied successfully\");\n    } catch (e) {\n        print(\"Failed to copy file: \" + e);\n        throw e;  // 再スロー\n    } finally {\n        if (src_file != null) { src_file.close(); }\n        if (dst_file != null) { dst_file.close(); }\n    }\n}\n```\n\n### 例：ネストされたエラーハンドリング\n\n```hemlock\nfn process_users(users) {\n    let success_count = 0;\n    let error_count = 0;\n\n    let i = 0;\n    while (i < users.length) {\n        try {\n            validate_user(users[i]);\n            save_user(users[i]);\n            success_count = success_count + 1;\n        } catch (e) {\n            print(\"Failed to process user: \" + e);\n            error_count = error_count + 1;\n        }\n        i = i + 1;\n    }\n\n    print(\"Processed: \" + typeof(success_count) + \" success, \" + typeof(error_count) + \" errors\");\n}\n```\n\n### 例：カスタムエラータイプ\n\n```hemlock\nfn create_error(type, message, details) {\n    return {\n        type: type,\n        message: message,\n        details: details,\n        toString: fn() {\n            return self.type + \": \" + self.message;\n        }\n    };\n}\n\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" && typeof(a) != \"f64\") {\n        throw create_error(\"TypeError\", \"a must be a number\", { value: a });\n    }\n    if (typeof(b) != \"i32\" && typeof(b) != \"f64\") {\n        throw create_error(\"TypeError\", \"b must be a number\", { value: b });\n    }\n    if (b == 0) {\n        throw create_error(\"DivisionByZero\", \"Cannot divide by zero\", { a: a, b: b });\n    }\n    return a / b;\n}\n\ntry {\n    divide(10, 0);\n} catch (e) {\n    print(e.toString());\n    if (e.type == \"DivisionByZero\") {\n        print(\"Details: a=\" + typeof(e.details.a) + \", b=\" + typeof(e.details.b));\n    }\n}\n```\n\n### 例：リトライロジック\n\n```hemlock\nfn retry(operation, max_attempts) {\n    let attempt = 0;\n\n    while (attempt < max_attempts) {\n        try {\n            return operation();  // 成功！\n        } catch (e) {\n            attempt = attempt + 1;\n            if (attempt >= max_attempts) {\n                throw \"Operation failed after \" + typeof(max_attempts) + \" attempts: \" + e;\n            }\n            print(\"Attempt \" + typeof(attempt) + \" failed, retrying...\");\n        }\n    }\n}\n\nfn unreliable_operation() {\n    // シミュレートされた不安定な操作\n    if (random() < 0.7) {\n        throw \"Operation failed\";\n    }\n    return \"Success\";\n}\n\ntry {\n    let result = retry(unreliable_operation, 3);\n    print(result);\n} catch (e) {\n    print(\"All retries failed: \" + e);\n}\n```\n\n## 実行順序\n\n実行順序の理解：\n\n```hemlock\ntry {\n    print(\"1: try block start\");\n    throw \"error\";\n    print(\"2: never reached\");\n} catch (e) {\n    print(\"3: catch block\");\n} finally {\n    print(\"4: finally block\");\n}\nprint(\"5: after try/catch/finally\");\n\n// 出力：\n// 1: try block start\n// 3: catch block\n// 4: finally block\n// 5: after try/catch/finally\n```\n\n## 現在の制限事項\n\n- **スタックトレースなし** - キャッチされない例外はスタックトレースを表示しない（計画中）\n- **一部の組み込み関数がexit** - 一部の組み込み関数はスローではなく`exit()`する（レビュー予定）\n- **カスタム例外タイプなし** - 任意の値をスローできるが、正式な例外階層はない\n\n## 関連トピック\n\n- [関数](#language-guide-functions) - 例外と関数のreturn\n- [制御フロー](#language-guide-control-flow) - 例外が制御フローに与える影響\n- [メモリ](#language-guide-memory) - メモリクリーンアップにfinallyを使用\n\n## 参照\n\n- **例外のセマンティクス**：CLAUDE.mdの「Error Handling」セクションを参照\n- **Panic vs Throw**：異なるエラータイプに対する異なる使用例\n- **Finally保証**：return/break/continueがあっても常に実行\n"}, "言語ガイド -> オブジェクト": {"id": "language-guide-objects", "content": "# オブジェクト\n\nHemlockはJavaScriptスタイルのオブジェクトを実装しており、ヒープ割り当て、動的フィールド、メソッド、ダックタイピングを備えています。オブジェクトはデータと動作を組み合わせた柔軟なデータ構造です。\n\n## 概要\n\n```hemlock\n// 無名オブジェクト\nlet person = { name: \"Alice\", age: 30, city: \"NYC\" };\nprint(person.name);  // \"Alice\"\n\n// メソッドを持つオブジェクト\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## オブジェクトリテラル\n\n### 基本構文\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n```\n\n**構文：**\n- 波括弧`{}`がオブジェクトを囲む\n- キーと値のペアはカンマで区切る\n- キーは識別子（引用符不要）\n- 値は任意の型\n\n### 空のオブジェクト\n\n```hemlock\nlet obj = {};  // 空のオブジェクト\n\n// 後でフィールドを追加\nobj.name = \"Alice\";\nobj.age = 30;\n```\n\n### ネストされたオブジェクト\n\n```hemlock\nlet user = {\n    info: {\n        name: \"Bob\",\n        age: 25\n    },\n    active: true,\n    settings: {\n        theme: \"dark\",\n        notifications: true\n    }\n};\n\nprint(user.info.name);           // \"Bob\"\nprint(user.settings.theme);      // \"dark\"\n```\n\n### 混合型の値\n\n```hemlock\nlet mixed = {\n    number: 42,\n    text: \"hello\",\n    flag: true,\n    data: null,\n    items: [1, 2, 3],\n    config: { x: 10, y: 20 }\n};\n```\n\n### 短縮プロパティ構文\n\n変数名がプロパティ名と一致する場合、短縮構文を使用：\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\nlet active = true;\n\n// 短縮：{ name } は { name: name } と等価\nlet person = { name, age, active };\n\nprint(person.name);   // \"Alice\"\nprint(person.age);    // 30\nprint(person.active); // true\n```\n\n**短縮と通常のプロパティを混合：**\n```hemlock\nlet city = \"NYC\";\nlet obj = { name, age, city, role: \"admin\" };\n```\n\n### スプレッド演算子\n\nスプレッド演算子（`...`）は1つのオブジェクトからすべてのフィールドを別のオブジェクトにコピーします：\n\n```hemlock\nlet base = { x: 1, y: 2 };\nlet extended = { ...base, z: 3 };\n\nprint(extended.x);  // 1\nprint(extended.y);  // 2\nprint(extended.z);  // 3\n```\n\n**スプレッドで値を上書き：**\n```hemlock\nlet defaults = { theme: \"light\", size: \"medium\", debug: false };\nlet custom = { ...defaults, theme: \"dark\" };\n\nprint(custom.theme);  // \"dark\"（上書き）\nprint(custom.size);   // \"medium\"（デフォルトから）\nprint(custom.debug);  // false（デフォルトから）\n```\n\n**複数のスプレッド（後のスプレッドが前を上書き）：**\n```hemlock\nlet a = { x: 1 };\nlet b = { y: 2 };\nlet merged = { ...a, ...b, z: 3 };\n\nprint(merged.x);  // 1\nprint(merged.y);  // 2\nprint(merged.z);  // 3\n\n// 後のスプレッドが前を上書き\nlet first = { val: \"first\" };\nlet second = { val: \"second\" };\nlet combined = { ...first, ...second };\nprint(combined.val);  // \"second\"\n```\n\n**短縮とスプレッドを組み合わせ：**\n```hemlock\nlet status = \"active\";\nlet data = { id: 1, name: \"Item\" };\nlet full = { ...data, status };\n\nprint(full.id);      // 1\nprint(full.name);    // \"Item\"\nprint(full.status);  // \"active\"\n```\n\n**設定上書きパターン：**\n```hemlock\nlet defaultConfig = {\n    debug: false,\n    timeout: 30,\n    retries: 3\n};\n\nlet prodConfig = { ...defaultConfig, timeout: 60 };\nlet devConfig = { ...defaultConfig, debug: true };\n\nprint(prodConfig.timeout);  // 60\nprint(devConfig.debug);     // true\n```\n\n**注意：** スプレッドは浅いコピーを実行します。ネストされたオブジェクトは参照を共有します：\n```hemlock\nlet nested = { inner: { val: 42 } };\nlet copied = { ...nested };\nprint(copied.inner.val);  // 42（nested.innerと同じ参照）\n```\n\n## フィールドアクセス\n\n### ドット記法\n\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\n\n// フィールドを読み取り\nlet name = person.name;      // \"Alice\"\nlet age = person.age;        // 30\n\n// フィールドを変更\nperson.age = 31;\nprint(person.age);           // 31\n```\n\n### 動的フィールド追加\n\n実行時に新しいフィールドを追加：\n\n```hemlock\nlet person = { name: \"Alice\" };\n\n// 新しいフィールドを追加\nperson.email = \"alice@example.com\";\nperson.phone = \"555-1234\";\n\nprint(person.email);  // \"alice@example.com\"\n```\n\n### フィールド削除\n\n**注意：** フィールド削除は現在サポートされていません。代わりに`null`を設定：\n\n```hemlock\nlet obj = { x: 10, y: 20 };\n\n// フィールドを削除できない（サポートされていない）\n// obj.x = undefined;  // Hemlockには'undefined'がない\n\n// 回避策：nullを設定\nobj.x = null;\n```\n\n## メソッドと`self`\n\n### メソッドの定義\n\nメソッドはオブジェクトフィールドに格納された関数です：\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    decrement: fn() {\n        self.count = self.count - 1;\n    },\n    get: fn() {\n        return self.count;\n    }\n};\n```\n\n### `self`キーワード\n\n関数がメソッドとして呼び出されると、`self`は自動的にオブジェクトにバインドされます：\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;  // selfはcounterを参照\n    }\n};\n\ncounter.increment();  // selfはcounterにバインド\nprint(counter.count);  // 1\n```\n\n**動作の仕組み：**\n- メソッド呼び出しは関数式がプロパティアクセスかどうかをチェックして検出\n- `self`は呼び出し時にオブジェクトに自動的にバインド\n- `self`は読み取り専用（`self`自体を再代入できない）\n\n### メソッド呼び出しの検出\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() {\n        return self.value;\n    }\n};\n\n// メソッドとして呼び出し - selfがバインド\nprint(obj.method());  // 10\n\n// 関数として呼び出し - selfはnull（エラー）\nlet f = obj.method;\nprint(f());  // エラー：selfが定義されていない\n```\n\n### パラメータを持つメソッド\n\n```hemlock\nlet calculator = {\n    result: 0,\n    add: fn(x) {\n        self.result = self.result + x;\n    },\n    multiply: fn(x) {\n        self.result = self.result * x;\n    },\n    get: fn() {\n        return self.result;\n    }\n};\n\ncalculator.add(5);\ncalculator.multiply(2);\nprint(calculator.get());  // 10\n```\n\n## `define`による型定義\n\n### 基本的な型定義\n\n`define`でオブジェクトの形状を定義：\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active: bool,\n}\n\n// オブジェクトを作成し型付き変数に代入\nlet p = { name: \"Alice\", age: 30, active: true };\nlet typed_p: Person = p;  // ダックタイピングが構造を検証\n\nprint(typeof(typed_p));  // \"Person\"\n```\n\n**`define`が行うこと：**\n- 必須フィールドを持つ型を宣言\n- ダックタイピング検証を有効に\n- `typeof()`用のオブジェクトの型名を設定\n\n### ダックタイピング\n\nオブジェクトは**構造的互換性**を使用して`define`に対して検証されます：\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK：すべての必須フィールドを持つ\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK：追加フィールドは許可\nlet p2: Person = {\n    name: \"Bob\",\n    age: 25,\n    city: \"NYC\",\n    active: true\n};\n\n// エラー：必須フィールド'age'がない\nlet p3: Person = { name: \"Carol\" };\n\n// エラー：'age'の型が違う\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```\n\n**ダックタイピングのルール：**\n- すべての必須フィールドが存在する必要がある\n- フィールドの型が一致する必要がある\n- 追加フィールドは許可され保持される\n- 検証は代入時に行われる\n\n### オプションフィールド\n\nフィールドはデフォルト値でオプションにできます：\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,       // デフォルト値付きオプション\n    nickname?: string,   // オプション、デフォルトはnull\n}\n\n// 必須フィールドのみのオブジェクト\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.active);    // true（デフォルトが適用）\nprint(typed_p.nickname);  // null（デフォルトなし）\n\n// オプションフィールドを上書き可能\nlet p2: Person = { name: \"Bob\", age: 25, active: false };\nprint(p2.active);  // false（上書き）\n```\n\n**オプションフィールドの構文：**\n- `field?: default_value` - デフォルト付きオプション\n- `field?: type` - 型注釈付きオプション、デフォルトはnull\n- オプションフィールドはダックタイピング時に欠落していれば追加される\n\n### 型チェック\n\n```hemlock\ndefine Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = { x: 10, y: 20 };\nlet point: Point = p;  // ここで型チェックが行われる\n\nprint(typeof(point));  // \"Point\"\nprint(typeof(p));      // \"object\"（元は無名のまま）\n```\n\n**型チェックが行われるタイミング：**\n- 型付き変数への代入時\n- すべての必須フィールドが存在するか検証\n- フィールドの型が一致するか検証（暗黙の変換付き）\n- オブジェクトの型名を設定\n\n## Defineのメソッドシグネチャ\n\nDefineブロックはメソッドシグネチャを指定でき、インターフェースのような契約を作成：\n\n### 必須メソッド\n\n```hemlock\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32;  // 必須メソッドシグネチャ\n}\n\n// オブジェクトは必須メソッドを提供する必要がある\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n```\n\n### オプションメソッド\n\n```hemlock\ndefine Serializable {\n    fn serialize(): string;       // 必須\n    fn pretty?(): string;         // オプションメソッド（存在しなくてよい）\n}\n```\n\n### `Self`型\n\n`Self`は定義中の型を参照し、再帰的な型定義を可能に：\n\n```hemlock\ndefine Cloneable {\n    fn clone(): Self;  // オブジェクトと同じ型を返す\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;  // パラメータとして同じ型を取る\n    fn equals(other: Self): bool;\n}\n\nlet item: Cloneable = {\n    value: 42,\n    clone: fn() {\n        return { value: self.value, clone: self.clone };\n    }\n};\n```\n\n### フィールドとメソッドの混合\n\n```hemlock\ndefine Entity {\n    id: i32,\n    name: string,\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\nlet user: Entity = {\n    id: 1,\n    name: \"Alice\",\n    validate: fn() { return self.id > 0 && self.name != \"\"; },\n    serialize: fn() { return '{\"id\":' + self.id + ',\"name\":\"' + self.name + '\"}'; }\n};\n```\n\n## 複合型（交差型）\n\n複合型は`&`を使用して、オブジェクトが複数の型定義を満たすことを要求：\n\n### 基本的な複合型\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\n// 複合型：オブジェクトはすべての型を満たす必要がある\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n```\n\n### 複合型の関数パラメータ\n\n```hemlock\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" is \" + p.age);\n}\n\ngreet({ name: \"Bob\", age: 25, city: \"NYC\" });  // 追加フィールドはOK\n```\n\n### 3つ以上の型\n\n```hemlock\ndefine HasEmail { email: string }\n\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n### 複合型の型エイリアス\n\n```hemlock\n// 複合型の名前付きエイリアスを作成\ntype Person = HasName & HasAge;\ntype Employee = HasName & HasAge & HasEmail;\n\nlet emp: Employee = {\n    name: \"Charlie\",\n    age: 35,\n    email: \"charlie@example.com\"\n};\n```\n\n**複合型のダックタイピング：** 追加フィールドは常に許可されます - オブジェクトはすべての構成型が要求するフィールドを少なくとも持っていればよいです。\n\n## JSONシリアライゼーション\n\n### JSONへのシリアライズ\n\nオブジェクトをJSON文字列に変換：\n\n```hemlock\n// obj.serialize() - オブジェクトをJSON文字列に変換\nlet obj = { x: 10, y: 20, name: \"test\" };\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// ネストされたオブジェクト\nlet nested = { inner: { a: 1, b: 2 }, outer: 3 };\nprint(nested.serialize());  // {\"inner\":{\"a\":1,\"b\":2},\"outer\":3}\n```\n\n### JSONからのデシリアライズ\n\nJSON文字列をオブジェクトにパース：\n\n```hemlock\n// json.deserialize() - JSON文字列をオブジェクトにパース\nlet json_str = '{\"x\":10,\"y\":20,\"name\":\"test\"}';\nlet obj = json_str.deserialize();\n\nprint(obj.name);   // \"test\"\nprint(obj.x);      // 10\n```\n\n### 循環参照の検出\n\n循環参照は検出されエラーになります：\n\n```hemlock\nlet obj = { x: 10 };\nobj.me = obj;  // 循環参照を作成\n\nobj.serialize();  // エラー：serialize()が循環参照を検出\n```\n\n### サポートされる型\n\nJSONシリアライゼーションがサポートする型：\n\n- **数値**：i8-i32、u8-u32、f32、f64\n- **真偽値**：true、false\n- **文字列**：エスケープシーケンス付き\n- **Null**：null値\n- **オブジェクト**：ネストされたオブジェクト\n- **配列**：ネストされた配列\n\n**サポートされない：**\n- 関数（無視される）\n- ポインタ（エラー）\n- バッファ（エラー）\n\n### エラーハンドリング\n\nシリアライゼーションとデシリアライゼーションはエラーをスローできます：\n\n```hemlock\n// 無効なJSONはエラーをスロー\ntry {\n    let bad = \"not valid json\".deserialize();\n} catch (e) {\n    print(\"Parse error:\", e);\n}\n\n// ポインタはシリアライズできない\nlet obj = { ptr: alloc(10) };\ntry {\n    obj.serialize();\n} catch (e) {\n    print(\"Serialize error:\", e);\n}\n```\n\n### ラウンドトリップの例\n\nシリアライズとデシリアライズの完全な例：\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug: bool\n}\n\n// 作成してシリアライズ\nlet config: Config = {\n    host: \"localhost\",\n    port: 8080,\n    debug: true\n};\nlet json = config.serialize();\nprint(json);  // {\"host\":\"localhost\",\"port\":8080,\"debug\":true}\n\n// デシリアライズして復元\nlet restored = json.deserialize();\nprint(restored.host);  // \"localhost\"\nprint(restored.port);  // 8080\n```\n\n## 組み込み関数\n\n### `typeof(value)`\n\n型名を文字列として返します：\n\n```hemlock\nlet obj = { x: 10 };\nprint(typeof(obj));  // \"object\"\n\ndefine Person { name: string, age: i32 }\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(typeof(p));    // \"Person\"\n```\n\n**戻り値：**\n- 無名オブジェクト：`\"object\"`\n- 型付きオブジェクト：カスタム型名（例：`\"Person\"`）\n\n## 実装の詳細\n\n### メモリモデル\n\n- **ヒープ割り当て** - すべてのオブジェクトはヒープに割り当て\n- **浅いコピー** - 代入は参照をコピー、オブジェクトではない\n- **動的フィールド** - 名前/値ペアの動的配列として格納\n- **参照カウント** - オブジェクトはスコープを抜けると自動的に解放\n\n### 参照セマンティクス\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // 浅いコピー（同じ参照）\n\nobj2.x = 20;\nprint(obj1.x);  // 20（両方が同じオブジェクトを参照）\n```\n\n### メソッドの格納\n\nメソッドはフィールドに格納された関数です：\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// methodはobj.methodに格納された関数\nprint(typeof(obj.method));  // \"function\"\n```\n\n## よくあるパターン\n\n### パターン：コンストラクタ関数\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```\n\n### パターン：オブジェクトビルダー\n\n```hemlock\nfn PersonBuilder() {\n    return {\n        name: null,\n        age: null,\n\n        setName: fn(n) {\n            self.name = n;\n            return self;  // チェーンを有効に\n        },\n\n        setAge: fn(a) {\n            self.age = a;\n            return self;\n        },\n\n        build: fn() {\n            return { name: self.name, age: self.age };\n        }\n    };\n}\n\nlet person = PersonBuilder()\n    .setName(\"Alice\")\n    .setAge(30)\n    .build();\n```\n\n### パターン：状態オブジェクト\n\n```hemlock\nlet state = {\n    status: \"idle\",\n    data: null,\n    error: null,\n\n    setState: fn(new_status) {\n        self.status = new_status;\n    },\n\n    setData: fn(new_data) {\n        self.data = new_data;\n        self.status = \"success\";\n    },\n\n    setError: fn(err) {\n        self.error = err;\n        self.status = \"error\";\n    }\n};\n```\n\n### パターン：設定オブジェクト\n\n```hemlock\nlet config = {\n    defaults: {\n        timeout: 30,\n        retries: 3,\n        debug: false\n    },\n\n    get: fn(key) {\n        if (self.defaults[key] != null) {\n            return self.defaults[key];\n        }\n        return null;\n    },\n\n    set: fn(key, value) {\n        self.defaults[key] = value;\n    }\n};\n```\n\n## ベストプラクティス\n\n1. **構造には`define`を使用** - 期待されるオブジェクトの形状を文書化\n2. **ファクトリ関数を優先** - コンストラクタでオブジェクトを作成\n3. **オブジェクトをシンプルに** - 深くネストしすぎない\n4. **`self`の使用を文書化** - メソッドの動作を明確に\n5. **代入時に検証** - ダックタイピングでエラーを早期にキャッチ\n6. **循環参照を避ける** - シリアライゼーションエラーの原因\n7. **オプションフィールドを使用** - 適切なデフォルトを提供\n\n## よくある落とし穴\n\n### 落とし穴：参照 vs 値\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // 浅いコピー\n\nobj2.x = 20;\nprint(obj1.x);  // 20（驚き！両方が変更）\n\n// 避けるには：新しいオブジェクトを作成\nlet obj3 = { x: obj1.x };  // ディープコピー（手動）\n```\n\n### 落とし穴：非メソッド呼び出しでの`self`\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// 動作：メソッドとして呼び出し\nprint(obj.method());  // 10\n\n// エラー：関数として呼び出し\nlet f = obj.method;\nprint(f());  // エラー：selfが定義されていない\n```\n\n### 落とし穴：オブジェクト内の生のポインタ\n\n```hemlock\n// オブジェクトは自動解放されるが、内部の生のポインタはされない\nfn create_objects() {\n    let obj = { data: alloc(1000) };  // 生のptrは手動解放が必要\n    // スコープを抜けるとobjは自動解放されるが、obj.dataはリーク！\n}\n\n// 解決策：スコープを抜ける前に生のポインタを解放\nfn safe_create() {\n    let obj = { data: alloc(1000) };\n    // ... obj.dataを使用 ...\n    free(obj.data);  // 生のポインタを明示的に解放\n}  // obj自体は自動解放\n```\n\n### 落とし穴：型の混乱\n\n```hemlock\nlet obj = { x: 10 };\n\ndefine Point { x: i32, y: i32 }\n\n// エラー：必須フィールド'y'がない\nlet p: Point = obj;\n```\n\n## 例\n\n### 例：ベクトル数学\n\n```hemlock\nfn createVector(x, y) {\n    return {\n        x: x,\n        y: y,\n\n        add: fn(other) {\n            return createVector(\n                self.x + other.x,\n                self.y + other.y\n            );\n        },\n\n        length: fn() {\n            return sqrt(self.x * self.x + self.y * self.y);\n        },\n\n        toString: fn() {\n            return \"(\" + typeof(self.x) + \", \" + typeof(self.y) + \")\";\n        }\n    };\n}\n\nlet v1 = createVector(3, 4);\nlet v2 = createVector(1, 2);\nlet v3 = v1.add(v2);\n\nprint(v3.toString());  // \"(4, 6)\"\n```\n\n### 例：シンプルなデータベース\n\n```hemlock\nfn createDatabase() {\n    let records = [];\n    let next_id = 1;\n\n    return {\n        insert: fn(data) {\n            let record = { id: next_id, data: data };\n            records.push(record);\n            next_id = next_id + 1;\n            return record.id;\n        },\n\n        find: fn(id) {\n            let i = 0;\n            while (i < records.length) {\n                if (records[i].id == id) {\n                    return records[i];\n                }\n                i = i + 1;\n            }\n            return null;\n        },\n\n        count: fn() {\n            return records.length;\n        }\n    };\n}\n\nlet db = createDatabase();\nlet id = db.insert({ name: \"Alice\", age: 30 });\nlet record = db.find(id);\nprint(record.data.name);  // \"Alice\"\n```\n\n### 例：イベントエミッター\n\n```hemlock\nfn createEventEmitter() {\n    let listeners = {};\n\n    return {\n        on: fn(event, handler) {\n            if (listeners[event] == null) {\n                listeners[event] = [];\n            }\n            listeners[event].push(handler);\n        },\n\n        emit: fn(event, data) {\n            if (listeners[event] != null) {\n                let i = 0;\n                while (i < listeners[event].length) {\n                    listeners[event][i](data);\n                    i = i + 1;\n                }\n            }\n        }\n    };\n}\n\nlet emitter = createEventEmitter();\n\nemitter.on(\"message\", fn(data) {\n    print(\"Received: \" + data);\n});\n\nemitter.emit(\"message\", \"Hello!\");\n```\n\n## 制限事項\n\n現在の制限事項：\n\n- **ディープコピーなし** - ネストされたオブジェクトは手動でコピーする必要がある（スプレッドは浅い）\n- **値渡しなし** - オブジェクトは常に参照で渡される\n- **計算プロパティなし** - `{[key]: value}`構文がない\n- **`self`は読み取り専用** - メソッド内で`self`を再代入できない\n- **プロパティ削除なし** - 一度追加したフィールドを削除できない\n\n**注意：** オブジェクトは参照カウントされ、スコープを抜けると自動的に解放されます。詳細は[メモリ管理](memory.md#internal-reference-counting)を参照してください。\n\n## 関連トピック\n\n- [関数](#language-guide-functions) - メソッドはオブジェクトに格納された関数\n- [配列](#language-guide-arrays) - 配列もオブジェクトのような性質を持つ\n- [型](#language-guide-types) - ダックタイピングと型定義\n- [エラーハンドリング](#language-guide-error-handling) - エラーオブジェクトのスロー\n\n## 参照\n\n- **ダックタイピング**：ダックタイピングの詳細はCLAUDE.mdの「Objects」セクションを参照\n- **JSON**：JSONシリアライゼーションの詳細はCLAUDE.mdを参照\n- **メモリ**：オブジェクトの割り当ては[メモリ](#language-guide-memory)を参照\n"}, "言語ガイド -> パターンマッチング": {"id": "language-guide-pattern-matching", "content": "# パターンマッチング\n\nHemlockは`match`式による強力なパターンマッチングを提供し、値の分解、型のチェック、複数のケースの処理を簡潔に行う方法を提供します。\n\n## 基本構文\n\n```hemlock\nlet result = match (value) {\n    pattern1 => expression1,\n    pattern2 => expression2,\n    _ => default_expression\n};\n```\n\nMatch式は`value`を各パターンに順番に評価し、最初にマッチしたアームの式の結果を返します。\n\n## パターンの種類\n\n### リテラルパターン\n\n正確な値にマッチ：\n\n```hemlock\nlet x = 42;\nlet msg = match (x) {\n    0 => \"zero\",\n    1 => \"one\",\n    42 => \"the answer\",\n    _ => \"other\"\n};\nprint(msg);  // \"the answer\"\n```\n\nサポートされるリテラル：\n- **整数**：`0`、`42`、`-5`\n- **浮動小数点数**：`3.14`、`-0.5`\n- **文字列**：`\"hello\"`、`\"world\"`\n- **真偽値**：`true`、`false`\n- **Null**：`null`\n\n### ワイルドカードパターン（`_`）\n\nバインドせずに任意の値にマッチ：\n\n```hemlock\nlet x = \"anything\";\nlet result = match (x) {\n    \"specific\" => \"found it\",\n    _ => \"wildcard matched\"\n};\n```\n\n### 変数バインディングパターン\n\nマッチした値を変数にバインド：\n\n```hemlock\nlet x = 100;\nlet result = match (x) {\n    0 => \"zero\",\n    n => \"value is \" + n  // nは100にバインド\n};\nprint(result);  // \"value is 100\"\n```\n\n### ORパターン（`|`）\n\n複数の選択肢にマッチ：\n\n```hemlock\nlet x = 2;\nlet size = match (x) {\n    1 | 2 | 3 => \"small\",\n    4 | 5 | 6 => \"medium\",\n    _ => \"large\"\n};\n\n// 文字列でも動作\nlet cmd = \"quit\";\nlet action = match (cmd) {\n    \"exit\" | \"quit\" | \"q\" => \"exiting\",\n    \"help\" | \"h\" | \"?\" => \"showing help\",\n    _ => \"unknown\"\n};\n```\n\n### ガード式（`if`）\n\nパターンに条件を追加：\n\n```hemlock\nlet x = 15;\nlet category = match (x) {\n    n if n < 0 => \"negative\",\n    n if n == 0 => \"zero\",\n    n if n < 10 => \"small\",\n    n if n < 100 => \"medium\",\n    n => \"large: \" + n\n};\nprint(category);  // \"medium\"\n\n// 複雑なガード\nlet y = 12;\nlet result = match (y) {\n    n if n % 2 == 0 && n > 10 => \"even and greater than 10\",\n    n if n % 2 == 0 => \"even\",\n    n => \"odd\"\n};\n```\n\n### 型パターン\n\n型に基づいてチェックとバインド：\n\n```hemlock\nlet val = 42;\nlet desc = match (val) {\n    num: i32 => \"integer: \" + num,\n    str: string => \"string: \" + str,\n    flag: bool => \"boolean: \" + flag,\n    _ => \"other type\"\n};\nprint(desc);  // \"integer: 42\"\n```\n\nサポートされる型：`i8`、`i16`、`i32`、`i64`、`u8`、`u16`、`u32`、`u64`、`f32`、`f64`、`bool`、`string`、`array`、`object`\n\n## 分解パターン\n\n### オブジェクトの分解\n\nオブジェクトからフィールドを抽出：\n\n```hemlock\nlet point = { x: 10, y: 20 };\nlet result = match (point) {\n    { x, y } => \"point at \" + x + \",\" + y\n};\nprint(result);  // \"point at 10,20\"\n\n// リテラルフィールド値を使用\nlet origin = { x: 0, y: 0 };\nlet name = match (origin) {\n    { x: 0, y: 0 } => \"origin\",\n    { x: 0, y } => \"on y-axis at \" + y,\n    { x, y: 0 } => \"on x-axis at \" + x,\n    { x, y } => \"point at \" + x + \",\" + y\n};\nprint(name);  // \"origin\"\n```\n\n### 配列の分解\n\n配列の構造と要素にマッチ：\n\n```hemlock\nlet arr = [1, 2, 3];\nlet desc = match (arr) {\n    [] => \"empty\",\n    [x] => \"single: \" + x,\n    [x, y] => \"pair: \" + x + \",\" + y,\n    [x, y, z] => \"triple: \" + x + \",\" + y + \",\" + z,\n    _ => \"many elements\"\n};\nprint(desc);  // \"triple: 1,2,3\"\n\n// リテラル値を使用\nlet pair = [1, 2];\nlet result = match (pair) {\n    [0, 0] => \"both zero\",\n    [1, x] => \"starts with 1, second is \" + x,\n    [x, 1] => \"ends with 1\",\n    _ => \"other\"\n};\nprint(result);  // \"starts with 1, second is 2\"\n```\n\n### 配列の残余パターン（`...`）\n\n残りの要素をキャプチャ：\n\n```hemlock\nlet nums = [1, 2, 3, 4, 5];\n\n// 先頭と残り\nlet result = match (nums) {\n    [first, ...rest] => \"first: \" + first,\n    [] => \"empty\"\n};\nprint(result);  // \"first: 1\"\n\n// 最初の2要素\nlet result2 = match (nums) {\n    [a, b, ...rest] => \"first two: \" + a + \",\" + b,\n    _ => \"too short\"\n};\nprint(result2);  // \"first two: 1,2\"\n```\n\n### ネストされた分解\n\n複雑なデータのためにパターンを組み合わせ：\n\n```hemlock\nlet user = {\n    name: \"Alice\",\n    address: { city: \"NYC\", zip: 10001 }\n};\n\nlet result = match (user) {\n    { name, address: { city, zip } } => name + \" lives in \" + city,\n    _ => \"unknown\"\n};\nprint(result);  // \"Alice lives in NYC\"\n\n// 配列を含むオブジェクト\nlet data = { items: [1, 2, 3], count: 3 };\nlet result2 = match (data) {\n    { items: [first, ...rest], count } => \"first: \" + first + \", total: \" + count,\n    _ => \"no items\"\n};\nprint(result2);  // \"first: 1, total: 3\"\n```\n\n## 式としてのMatch\n\nMatchは値を返す式です：\n\n```hemlock\n// 直接代入\nlet grade = 85;\nlet letter = match (grade) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    n if n >= 70 => \"C\",\n    n if n >= 60 => \"D\",\n    _ => \"F\"\n};\n\n// 文字列連結内\nlet msg = \"Grade: \" + match (grade) {\n    n if n >= 70 => \"passing\",\n    _ => \"failing\"\n};\n\n// 関数のreturn内\nfn classify(n: i32): string {\n    return match (n) {\n        0 => \"zero\",\n        n if n > 0 => \"positive\",\n        _ => \"negative\"\n    };\n}\n```\n\n## パターンマッチングのベストプラクティス\n\n1. **順序が重要**：パターンは上から下にチェックされる；具体的なパターンを一般的なパターンの前に配置\n2. **網羅性のためにワイルドカードを使用**：すべてのケースがカバーされていると確信がない限り、常に`_`フォールバックを含める\n3. **ネストした条件よりガードを優先**：ガードは意図をより明確にする\n4. **手動フィールドアクセスより分解を使用**：より簡潔で安全\n\n```hemlock\n// 良い：範囲チェックにガード\nmatch (score) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    _ => \"below B\"\n}\n\n// 良い：フィールドアクセスの代わりに分解\nmatch (point) {\n    { x: 0, y: 0 } => \"origin\",\n    { x, y } => \"at \" + x + \",\" + y\n}\n\n// 避ける：過度に複雑なネストされたパターン\n// 代わりに、複数のmatchに分割するかガードを使用することを検討\n```\n\n## 他の言語との比較\n\n| 機能 | Hemlock | Rust | JavaScript |\n|---------|---------|------|------------|\n| 基本的なマッチング | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |\n| 分解 | はい | はい | 部分的（switchは分解しない） |\n| ガード | `n if n > 0 =>` | `n if n > 0 =>` | なし |\n| ORパターン | `1 \\| 2 \\| 3 =>` | `1 \\| 2 \\| 3 =>` | `case 1: case 2: case 3:` |\n| 残余パターン | `[a, ...rest]` | `[a, rest @ ..]` | なし |\n| 型パターン | `n: i32` | `match`アームで型 | なし |\n| 値を返す | はい | はい | いいえ（文） |\n\n## 実装に関する注意\n\nパターンマッチングはインタープリタとコンパイラの両方のバックエンドで完全なパリティを持って実装されています - 両方とも同じ入力に対して同一の結果を生成します。この機能はHemlock v1.8.0以降で利用可能です。\n"}, "言語ガイド -> メモリ管理": {"id": "language-guide-memory", "content": "# メモリ管理\n\nHemlockは、割り当てと解放の明示的な制御を持つ**手動メモリ管理**を採用しています。このガイドでは、Hemlockのメモリモデル、2つのポインタ型、および完全なメモリAPIについて説明します。\n\n---\n\n## メモリ入門：基礎\n\n**プログラミング初心者の方**はここから始めてください。すでにメモリ管理を理解している場合は、[設計思想](#設計思想)にスキップしてください。\n\n### メモリ管理とは？\n\nプログラムがデータ（テキスト、数値、リスト）を保存する必要がある場合、それを置く場所が必要です。その場所はコンピュータのメモリ（RAM）から来ます。メモリ管理とは：\n\n1. **スペースを取得する** - 必要なときにメモリを要求する\n2. **スペースを使用する** - データの読み書き\n3. **返却する** - 終わったらメモリを返す\n\n### なぜ重要なのか？\n\n限られた本がある図書館を想像してください：\n- 本を借り続けて返さなければ、最終的に本がなくなる\n- すでに返した本を読もうとすると、混乱したり問題が発生する\n\nメモリも同じように動作します。メモリを返すのを忘れると、プログラムは徐々にメモリを多く使用していきます（「メモリリーク」）。解放後のメモリを使用しようとすると、悪いことが起こります。\n\n### 良いニュース\n\n**ほとんどの場合、これについて考える必要はありません！**\n\nHemlockはほとんどの一般的な型を自動的にクリーンアップします：\n\n```hemlock\nfn example() {\n    let name = \"Alice\";       // Hemlockがこれを管理\n    let numbers = [1, 2, 3];  // これも\n    let person = { age: 30 }; // これも\n\n    // 関数が終了すると、これらはすべて自動的にクリーンアップされる！\n}\n```\n\n### 考える必要があるとき\n\n手動メモリ管理が必要なのは以下を使用する場合のみ：\n\n1. **`alloc()`** - 生のメモリ割り当て（`ptr`を返す）\n2. **`buffer()`** - 早期解放が必要な場合（オプション - スコープ終了時に自動解放）\n\n```hemlock\n// これは手動クリーンアップが必要：\nlet raw = alloc(100);   // 生のメモリ - あなたが解放する必要がある\n// ... rawを使用 ...\nfree(raw);              // 必須！さもなければメモリリーク\n\n// これは自動的にクリーンアップされる（ただし早期解放は可能）：\nlet buf = buffer(100);  // 安全なバッファ\n// ... bufを使用 ...\n// free(buf);           // オプション - スコープ終了時に自動解放\n```\n\n### シンプルなルール\n\n> **`alloc()`を呼び出したら、`free()`を呼び出す必要がある。**\n>\n> それ以外はすべて自動的に処理される。\n\n### どちらを使うべき？\n\n| 状況 | 使用するもの | 理由 |\n|-----------|----------|-----|\n| **始めたばかり** | `buffer()` | 安全、境界チェック、自動クリーンアップ |\n| **バイトストレージが必要** | `buffer()` | 安全で簡単 |\n| **Cライブラリ（FFI）と連携** | `alloc()` / `ptr` | C相互運用に必須 |\n| **最大パフォーマンス** | `alloc()` / `ptr` | 境界チェックのオーバーヘッドなし |\n| **分からない** | `buffer()` | 常により安全な選択 |\n\n### クイック例：安全 vs 生\n\n```hemlock\n// 推奨：安全なバッファ\nfn safe_example() {\n    let data = buffer(10);\n    data[0] = 65;           // OK\n    data[5] = 66;           // OK\n    // data[100] = 67;      // エラー - Hemlockが停止（境界チェック）\n    free(data);             // クリーンアップ\n}\n\n// 上級者向け：生のポインタ（必要な場合のみ）\nfn raw_example() {\n    let data = alloc(10);\n    *data = 65;             // OK\n    *(data + 5) = 66;       // OK\n    *(data + 100) = 67;     // 危険 - 境界チェックなし、メモリ破壊！\n    free(data);             // クリーンアップ\n}\n```\n\n**`buffer()`から始めましょう。生のポインタが特に必要な場合のみ`alloc()`を使用してください。**\n\n---\n\n## 設計思想\n\nHemlockは、合理的なデフォルトを持つ明示的なメモリ管理の原則に従います：\n- ガベージコレクションなし（予測不可能な一時停止なし）\n- 一般的な型（string、array、object、buffer）の内部参照カウント\n- 生のポインタ（`ptr`）は手動の`free()`が必要\n\nこのハイブリッドアプローチにより、必要なときは完全な制御（生のポインタ）を提供しつつ、一般的な使用例（スコープ終了時に自動解放される参照カウント型）での一般的なバグを防ぎます。\n\n## 内部参照カウント\n\nランタイムは**内部参照カウント**を使用してオブジェクトの寿命を管理します。参照カウント型のほとんどのローカル変数では、クリーンアップは自動的かつ決定論的です。\n\n### 参照カウントが処理するもの\n\nランタイムは以下の場合に参照カウントを自動的に管理します：\n\n1. **変数が再代入される** - 古い値が解放される：\n   ```hemlock\n   let x = \"first\";   // ref_count = 1\n   x = \"second\";      // \"first\"は内部的に解放、\"second\"のref_count = 1\n   ```\n\n2. **スコープを抜ける** - ローカル変数が解放される：\n   ```hemlock\n   fn example() {\n       let arr = [1, 2, 3];  // ref_count = 1\n   }  // 関数が戻るとarrが解放される\n   ```\n\n3. **コンテナが解放される** - 要素が解放される：\n   ```hemlock\n   let arr = [obj1, obj2];\n   free(arr);  // obj1とobj2の参照カウントがデクリメントされる\n   ```\n\n### `free()`が必要な場合 vs 自動の場合\n\n**自動（`free()`不要）：** 参照カウント型のローカル変数はスコープを抜けると解放される：\n\n```hemlock\nfn process_data() {\n    let arr = [1, 2, 3];\n    let obj = { name: \"test\" };\n    let buf = buffer(64);\n    // ... 使用する ...\n}  // 関数が戻るとすべて自動的に解放 - free()不要\n```\n\n**手動の`free()`が必要：**\n\n1. **生のポインタ** - `alloc()`には参照カウントがない：\n   ```hemlock\n   let p = alloc(64);\n   // ... pを使用 ...\n   free(p);  // 常に必須 - そうでなければリーク\n   ```\n\n2. **早期クリーンアップ** - スコープ終了前に解放してメモリを早く解放：\n   ```hemlock\n   fn long_running() {\n       let big = buffer(10000000);  // 10MB\n       // ... bigの使用終了 ...\n       free(big);  // 今すぐ解放、関数の戻りを待たない\n       // ... bigを必要としない追加の処理 ...\n   }\n   ```\n\n3. **長期間存続するデータ** - グローバルまたは永続構造体に格納されたデータ：\n   ```hemlock\n   let cache = {};  // モジュールレベル、解放されない限りプログラム終了まで存続\n\n   fn cleanup() {\n       free(cache);  // 長期間存続するデータの手動クリーンアップ\n   }\n   ```\n\n### 参照カウント vs ガベージコレクション\n\n| 側面 | Hemlock参照カウント | ガベージコレクション |\n|--------|---------------------|-------------------|\n| クリーンアップのタイミング | 決定論的（refが0になると即座） | 非決定論的（GCが決定） |\n| ユーザーの責任 | `free()`を呼ぶ必要がある | 完全自動 |\n| ランタイムの一時停止 | なし | 「世界を止める」一時停止 |\n| 可視性 | 隠れた実装の詳細 | 通常不可視 |\n| 循環 | 訪問済みセットの追跡で処理 | トレースで処理 |\n\n### 参照カウントを持つ型\n\n| 型 | 参照カウント | 備考 |\n|------|------------|-------|\n| `ptr` | いいえ | 常に手動の`free()`が必要 |\n| `buffer` | はい | スコープ終了時に自動解放；早期クリーンアップには手動の`free()` |\n| `array` | はい | スコープ終了時に自動解放；早期クリーンアップには手動の`free()` |\n| `object` | はい | スコープ終了時に自動解放；早期クリーンアップには手動の`free()` |\n| `string` | はい | 完全自動、`free()`不要 |\n| `function` | はい | 完全自動（クロージャ環境） |\n| `task` | はい | スレッドセーフなアトミック参照カウント |\n| `channel` | はい | スレッドセーフなアトミック参照カウント |\n| プリミティブ | いいえ | スタック割り当て、ヒープ割り当てなし |\n\n### なぜこの設計か？\n\nこのハイブリッドアプローチにより：\n- **明示的な制御** - いつ解放するかを決定できる\n- **スコープバグからの安全性** - 再代入でリークしない\n- **予測可能なパフォーマンス** - GCの一時停止なし\n- **クロージャのサポート** - 関数が安全に変数をキャプチャできる\n\n設計思想は変わりません：あなたが制御しますが、ランタイムが再代入時のリークやコンテナでの二重解放などの一般的なバグを防ぐのを助けます。\n\n## 2つのポインタ型\n\nHemlockは、異なる安全特性を持つ2つの異なるポインタ型を提供します：\n\n### `ptr` - 生のポインタ（危険）\n\n生のポインタは**ただのアドレス**で、最小限の安全保証しかありません：\n\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // 解放を覚えておく必要がある\n```\n\n**特徴：**\n- ただの8バイトのアドレス\n- 境界チェックなし\n- 長さの追跡なし\n- ユーザーが完全に寿命を管理\n- エキスパートとFFI向け\n\n**使用例：**\n- 低レベルシステムプログラミング\n- 外部関数インターフェース（FFI）\n- パフォーマンスクリティカルなコード\n- 完全な制御が必要な場合\n\n**危険：**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // 割り当て範囲をはるかに超えている - 許可されるが危険\nfree(p);\nlet x = *p;       // ダングリングポインタ - 未定義動作\nfree(p);          // 二重解放 - クラッシュする\n```\n\n### `buffer` - 安全なラッパー（推奨）\n\nバッファは**境界チェックされたアクセス**を提供しつつ、手動解放が必要です：\n\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // 境界チェックあり\nprint(b.length);        // 64\nfree(b);                // まだ手動\n```\n\n**特徴：**\n- ポインタ + 長さ + 容量\n- アクセス時に境界チェック\n- まだ手動の`free()`が必要\n- ほとんどのコードでより良いデフォルト\n\n**プロパティ：**\n```hemlock\nlet buf = buffer(100);\nprint(buf.length);      // 100（現在のサイズ）\nprint(buf.capacity);    // 100（割り当て容量）\n```\n\n**境界チェック：**\n```hemlock\nlet buf = buffer(10);\nbuf[5] = 42;      // OK\nbuf[100] = 42;    // エラー：インデックスが範囲外\n```\n\n## メモリAPI\n\n### コア割り当て\n\n**`alloc(bytes)` - 生のメモリを割り当て**\n```hemlock\nlet p = alloc(1024);  // 1KBを割り当て、ptrを返す\n// ... メモリを使用\nfree(p);\n```\n\n**`buffer(size)` - 安全なバッファを割り当て**\n```hemlock\nlet buf = buffer(256);  // 256バイトのバッファを割り当て\nbuf[0] = 65;            // 'A'\nbuf[1] = 66;            // 'B'\nfree(buf);\n```\n\n**`free(ptr)` - メモリを解放**\n```hemlock\nlet p = alloc(100);\nfree(p);  // メモリリークを避けるために解放必須\n\nlet buf = buffer(100);\nfree(buf);  // ptrとbufferの両方で動作\n```\n\n**重要：** `free()`は`ptr`と`buffer`型の両方で動作します。\n\n### メモリ操作\n\n**`memset(ptr, byte, size)` - メモリを埋める**\n```hemlock\nlet p = alloc(100);\nmemset(p, 0, 100);     // 100バイトをゼロクリア\nmemset(p, 65, 10);     // 最初の10バイトを'A'で埋める\nfree(p);\n```\n\n**`memcpy(dest, src, size)` - メモリをコピー**\n```hemlock\nlet src = alloc(50);\nlet dst = alloc(50);\nmemset(src, 42, 50);\nmemcpy(dst, src, 50);  // srcからdstに50バイトをコピー\nfree(src);\nfree(dst);\n```\n\n**`realloc(ptr, size)` - 割り当てをリサイズ**\n```hemlock\nlet p = alloc(100);\n// ... 100バイトを使用\np = realloc(p, 200);   // 200バイトにリサイズ\n// ... 200バイトを使用\nfree(p);\n```\n\n**注意：** `realloc()`後、古いポインタは無効になる可能性があります。常に返されたポインタを使用してください。\n\n### 型付き割り当て\n\nHemlockは便利のために型付き割り当てヘルパーを提供します：\n\n```hemlock\nlet arr = talloc(i32, 100);  // 100個のi32値を割り当て（400バイト）\nlet size = sizeof(i32);      // 4を返す（バイト）\n```\n\n**`sizeof(type)`**は型のバイトサイズを返します：\n- `sizeof(i8)` / `sizeof(u8)` → 1\n- `sizeof(i16)` / `sizeof(u16)` → 2\n- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` → 4\n- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` → 8\n- `sizeof(ptr)` → 8（64ビットシステム）\n\n**`talloc(type, count)`**は`type`の`count`要素を割り当てます：\n\n```hemlock\nlet ints = talloc(i32, 10);   // 10個のi32値に40バイト\nlet floats = talloc(f64, 5);  // 5個のf64値に40バイト\nfree(ints);\nfree(floats);\n```\n\n## よくあるパターン\n\n### パターン：割り当て、使用、解放\n\nメモリ管理の基本パターン：\n\n```hemlock\n// 1. 割り当て\nlet data = alloc(1024);\n\n// 2. 使用\nmemset(data, 0, 1024);\n// ... 処理を行う\n\n// 3. 解放\nfree(data);\n```\n\n### パターン：安全なバッファの使用\n\n境界チェックされたアクセスにはバッファを優先：\n\n```hemlock\nlet buf = buffer(256);\n\n// 安全な反復\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\nfree(buf);\n```\n\n### パターン：try/finallyによるリソース管理\n\nエラー時もクリーンアップを確実に：\n\n```hemlock\nlet data = alloc(1024);\ntry {\n    // ... 危険な操作\n    process(data);\n} finally {\n    free(data);  // エラー時も常に解放\n}\n```\n\n## メモリ安全性の考慮事項\n\n### 二重解放\n\n**許可されるがクラッシュする：**\n```hemlock\nlet p = alloc(100);\nfree(p);\nfree(p);  // クラッシュ：二重解放を検出\n```\n\n**防止策：**\n```hemlock\nlet p = alloc(100);\nfree(p);\np = null;  // 解放後にnullを設定\n\nif (p != null) {\n    free(p);  // 実行されない\n}\n```\n\n### ダングリングポインタ\n\n**許可されるが未定義動作：**\n```hemlock\nlet p = alloc(100);\n*p = 42;      // OK\nfree(p);\nlet x = *p;   // 未定義：解放されたメモリを読み取り\n```\n\n**防止策：** 解放後のメモリにアクセスしない。\n\n### メモリリーク\n\n**作成しやすく、デバッグしにくい：**\n```hemlock\nfn leak_memory() {\n    let p = alloc(1000);\n    // 解放を忘れた！\n    return;  // メモリがリーク\n}\n```\n\n**防止策：** 常に`alloc()`と`free()`をペアにする：\n```hemlock\nfn safe_function() {\n    let p = alloc(1000);\n    try {\n        // ... pを使用\n    } finally {\n        free(p);  // 常に解放\n    }\n}\n```\n\n### ポインタ演算\n\n**許可されるが危険：**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // 割り当て境界をはるかに超えている\n*q = 42;          // 未定義：範囲外の書き込み\nfree(p);\n```\n\n**境界チェックにはバッファを使用：**\n```hemlock\nlet buf = buffer(10);\nbuf[100] = 42;  // エラー：境界チェックがオーバーフローを防止\n```\n\n## ベストプラクティス\n\n1. **デフォルトで`buffer`** - 特に生の`ptr`が必要でない限り`buffer`を使用\n2. **alloc/freeをマッチ** - すべての`alloc()`には正確に1つの`free()`\n3. **try/finallyを使用** - 例外処理でクリーンアップを確実に\n4. **解放後にnull** - use-after-freeをキャッチするために解放後にポインタをnullに設定\n5. **境界チェック** - 自動境界チェックにはバッファのインデックスを使用\n6. **所有権を文書化** - どのコードが各割り当てを所有し解放するかを明確に\n\n## 例\n\n### 例：動的文字列ビルダー\n\n```hemlock\nfn build_message(count: i32): ptr {\n    let size = count * 10;\n    let buf = alloc(size);\n\n    let i = 0;\n    while (i < count) {\n        memset(buf + (i * 10), 65 + i, 10);\n        i = i + 1;\n    }\n\n    return buf;  // 呼び出し元が解放する必要がある\n}\n\nlet msg = build_message(5);\n// ... msgを使用\nfree(msg);\n```\n\n### 例：安全な配列操作\n\n```hemlock\nfn process_array(size: i32) {\n    let arr = buffer(size);\n\n    try {\n        // 配列を埋める\n        let i = 0;\n        while (i < arr.length) {\n            arr[i] = i * 2;\n            i = i + 1;\n        }\n\n        // 処理\n        i = 0;\n        while (i < arr.length) {\n            print(arr[i]);\n            i = i + 1;\n        }\n    } finally {\n        free(arr);  // 常にクリーンアップ\n    }\n}\n```\n\n### 例：メモリプールパターン\n\n```hemlock\n// シンプルなメモリプール（簡略化）\nlet pool = alloc(10000);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > 10000) {\n        throw \"Pool exhausted\";\n    }\n\n    let ptr = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return ptr;\n}\n\n// プールを使用\nlet p1 = pool_alloc(100);\nlet p2 = pool_alloc(200);\n\n// プール全体を一度に解放\nfree(pool);\n```\n\n## 制限事項\n\n注意すべき現在の制限事項：\n\n- **生のポインタは手動解放が必要** - `alloc()`は参照カウントのない`ptr`を返す\n- **カスタムアロケータなし** - システムのmalloc/freeのみ\n\n**注意：** 参照カウント型（string、array、object、buffer）はスコープを抜けると自動的に解放されます。`alloc()`からの生の`ptr`のみ明示的な`free()`が必要です。\n\n## 関連トピック\n\n- [文字列](#language-guide-strings) - 文字列のメモリ管理とUTF-8エンコーディング\n- [配列](#language-guide-arrays) - 動的配列とそのメモリ特性\n- [オブジェクト](#language-guide-objects) - オブジェクトの割り当てと寿命\n- [エラーハンドリング](#language-guide-error-handling) - クリーンアップにtry/finallyを使用\n\n## 参照\n\n- **設計思想**: CLAUDE.mdの「Memory Management」セクションを参照\n- **型システム**: `ptr`と`buffer`型の詳細は[型](#language-guide-types)を参照\n- **FFI**: 生のポインタは外部関数インターフェースに不可欠\n"}, "言語ガイド -> モジュール": {"id": "language-guide-modules", "content": "# Hemlockモジュールシステム\n\nこのドキュメントでは、Hemlockに実装されたES6スタイルのimport/exportモジュールシステムについて説明します。\n\n## 概要\n\nHemlockはES6スタイルのimport/export構文を持つファイルベースのモジュールシステムをサポートしています。モジュールは：\n- **シングルトン**：各モジュールは1回だけロードされキャッシュされる\n- **ファイルベース**：モジュールはディスク上の.hmlファイルに対応\n- **明示的インポート**：依存関係はimport文で宣言\n- **トポロジカル実行**：依存関係は依存先より先に実行\n\nパッケージ管理とサードパーティ依存関係については、[hpm (Hemlock Package Manager)](https://github.com/hemlang/hpm)を参照してください。\n\n## 構文\n\n### Export文\n\n**インライン名前付きエクスポート：**\n```hemlock\nexport fn add(a, b) {\n    return a + b;\n}\n\nexport const PI = 3.14159;\nexport let counter = 0;\n```\n\n**エクスポートリスト：**\n```hemlock\nfn add(a, b) { return a + b; }\nfn subtract(a, b) { return a - b; }\n\nexport { add, subtract };\n```\n\n**Export Extern（FFI関数）：**\n```hemlock\nimport \"libc.so.6\";\n\n// 他のモジュールで使用するためにFFI関数をエクスポート\nexport extern fn strlen(s: string): i32;\nexport extern fn getpid(): i32;\n```\n\nFFI関数のエクスポートの詳細については、[FFIドキュメント](../advanced/ffi.md#exporting-ffi-functions)を参照してください。\n\n**Export Define（構造体型）：**\n```hemlock\n// 構造体型定義をエクスポート\nexport define Vector2 {\n    x: f32,\n    y: f32,\n}\n\nexport define Rectangle {\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n}\n```\n\n**重要：** エクスポートされた構造体型は、モジュールがロードされるとグローバルに登録されます。モジュールから何かをインポートすると自動的に利用可能になります - 名前で明示的にインポートする必要はありません（できません）：\n\n```hemlock\n// 良い - 構造体型はどのインポート後も自動的に利用可能\nimport { some_function } from \"./my_module.hml\";\nlet v: Vector2 = { x: 1.0, y: 2.0 };  // 動作する！\n\n// 悪い - 構造体型を明示的にインポートできない\nimport { Vector2 } from \"./my_module.hml\";  // エラー：未定義の変数 'Vector2'\n```\n\n構造体型のエクスポートの詳細については、[FFIドキュメント](../advanced/ffi.md#exporting-struct-types)を参照してください。\n\n**再エクスポート：**\n```hemlock\n// 別のモジュールから再エクスポート\nexport { add, subtract } from \"./math.hml\";\n```\n\n### Import文\n\n**名前付きインポート：**\n```hemlock\nimport { add, subtract } from \"./math.hml\";\nprint(add(1, 2));  // 3\n```\n\n**名前空間インポート：**\n```hemlock\nimport * as math from \"./math.hml\";\nprint(math.add(1, 2));  // 3\nprint(math.PI);  // 3.14159\n```\n\n**エイリアス：**\n```hemlock\nimport { add as sum, subtract as diff } from \"./math.hml\";\nprint(sum(1, 2));  // 3\n```\n\n## モジュール解決\n\n### パスの種類\n\n**相対パス：**\n```hemlock\nimport { foo } from \"./module.hml\";       // 同じディレクトリ\nimport { bar } from \"../parent.hml\";      // 親ディレクトリ\nimport { baz } from \"./sub/nested.hml\";   // サブディレクトリ\n```\n\n**絶対パス：**\n```hemlock\nimport { foo } from \"/absolute/path/to/module.hml\";\n```\n\n**拡張子の処理：**\n- `.hml`拡張子は省略可能 - 自動的に追加される\n- `./math`は`./math.hml`に解決\n\n## 機能\n\n### 循環依存の検出\n\nモジュールシステムは循環依存を検出してエラーを報告します：\n\n```\nError: Circular dependency detected when loading '/path/to/a.hml'\n```\n\n### モジュールキャッシング\n\nモジュールは1回ロードされキャッシュされます。同じモジュールの複数のインポートは同じインスタンスを返します：\n\n```hemlock\n// counter.hml\nexport let count = 0;\nexport fn increment() {\n    count = count + 1;\n}\n\n// a.hml\nimport { count, increment } from \"./counter.hml\";\nincrement();\nprint(count);  // 1\n\n// b.hml\nimport { count } from \"./counter.hml\";  // 同じインスタンス！\nprint(count);  // まだ1（共有状態）\n```\n\n### インポートの不変性\n\nインポートされたバインディングは再代入できません：\n\n```hemlock\nimport { add } from \"./math.hml\";\nadd = fn() { };  // エラー：インポートされたバインディングを再代入できない\n```\n\n## 実装の詳細\n\n### アーキテクチャ\n\n**ファイル：**\n- `include/module.h` - モジュールシステムAPI\n- `src/module.c` - モジュールのロード、キャッシング、実行\n- `src/parser.c`のパーササポート\n- `src/interpreter/runtime.c`のランタイムサポート\n\n**主要コンポーネント：**\n1. **ModuleCache**：絶対パスでインデックスされたロード済みモジュールを維持\n2. **Module**：ASTとエクスポートを持つロード済みモジュールを表す\n3. **パス解決**：相対/絶対パスを正規パスに解決\n4. **トポロジカル実行**：依存順序でモジュールを実行\n\n### モジュールロードプロセス\n\n1. **パースフェーズ**：モジュールファイルをトークン化してパース\n2. **依存関係解決**：インポートされたモジュールを再帰的にロード\n3. **サイクル検出**：モジュールがすでにロード中かチェック\n4. **キャッシング**：絶対パスでキャッシュにモジュールを格納\n5. **実行フェーズ**：トポロジカル順序（依存関係が先）で実行\n\n### API\n\n```c\n// 高レベルAPI\nint execute_file_with_modules(const char *file_path,\n                               int argc, char **argv,\n                               ExecutionContext *ctx);\n\n// 低レベルAPI\nModuleCache* module_cache_new(const char *initial_dir);\nvoid module_cache_free(ModuleCache *cache);\nModule* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);\nvoid execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);\n```\n\n## テスト\n\nテストモジュールは`tests/modules/`と`tests/parity/modules/`にあります：\n\n- `math.hml` - エクスポートを持つ基本モジュール\n- `test_import_named.hml` - 名前付きインポートテスト\n- `test_import_namespace.hml` - 名前空間インポートテスト\n- `test_import_alias.hml` - インポートエイリアステスト\n- `export_extern.hml` - export extern FFI関数テスト（Linux）\n\n## パッケージインポート（hpm）\n\n[hpm](https://github.com/hemlang/hpm)がインストールされていれば、GitHubからサードパーティパッケージをインポートできます：\n\n```hemlock\n// パッケージルートからインポート（package.jsonの\"main\"を使用）\nimport { app, router } from \"hemlang/sprout\";\n\n// サブパスからインポート\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// 標準ライブラリ（Hemlockに組み込み）\nimport { HashMap } from \"@stdlib/collections\";\n```\n\nパッケージは`hem_modules/`にインストールされ、GitHub `owner/repo`構文を使用して解決されます。\n\n```bash\n# パッケージをインストール\nhpm install hemlang/sprout\n\n# バージョン制約付きでインストール\nhpm install hemlang/sprout@^1.0.0\n```\n\n詳細は[hpmドキュメント](https://github.com/hemlang/hpm)を参照してください。\n\n## 現在の制限事項\n\n1. **動的インポートなし**：ランタイム関数としての`import()`はサポートされていない\n2. **条件付きエクスポートなし**：エクスポートはトップレベルでなければならない\n3. **静的ライブラリパス**：FFIライブラリインポートは静的パスを使用（プラットフォーム固有）\n\n## 将来の作業\n\n- `import()`関数による動的インポート\n- 条件付きエクスポート\n- モジュールメタデータ（`import.meta`）\n- ツリーシェイキングとデッドコード除去\n\n## 例\n\n動作するモジュールシステムの例は`tests/modules/`を参照してください。\n\nモジュール構造の例：\n```\nproject/\n├── main.hml\n├── lib/\n│   ├── math.hml\n│   ├── string.hml\n│   └── index.hml（バレルモジュール）\n└── utils/\n    └── helpers.hml\n```\n\n使用例：\n```hemlock\n// lib/math.hml\nexport fn add(a, b) { return a + b; }\nexport fn multiply(a, b) { return a * b; }\n\n// lib/index.hml（バレル）\nexport { add, multiply } from \"./math.hml\";\n\n// main.hml\nimport { add } from \"./lib/index.hml\";\nprint(add(2, 3));  // 5\n```\n"}, "言語ガイド -> ルーン": {"id": "language-guide-runes", "content": "# ルーン\n\nルーンはHemlockでの文字操作のために、**Unicodeコードポイント**（U+0000からU+10FFFF）を独自の型として表現します。バイト（u8）とは異なり、ルーンはあらゆる言語の文字や絵文字を表現できる完全なUnicode文字です。\n\n## 概要\n\n```hemlock\nlet ch = 'A';           // ルーンリテラル\nlet emoji = '🚀';       // マルチバイト文字を1つのルーンとして\nprint(ch);              // 'A'\nprint(emoji);           // U+1F680\n\nlet s = \"Hello \" + '!'; // 文字列 + ルーンの連結\nlet r = '>' + \" msg\";   // ルーン + 文字列の連結\n```\n\n## ルーンとは？\n\nルーンはUnicodeコードポイントを表す**32ビットの値**です：\n\n- **範囲：** 0から0x10FFFF（1,114,111個の有効なコードポイント）\n- **数値型ではない** - 文字表現に使用\n- **u8/charとは異なる** - ルーンは完全なUnicode、u8はただのバイト\n- **文字列のインデックスで返される** - `str[0]`はバイトではなくルーンを返す\n\n**なぜルーンか？**\n- Hemlock文字列はUTF-8エンコード\n- 1つのUnicode文字はUTF-8で1〜4バイト\n- ルーンにより、部分的なバイトではなく完全な文字を扱える\n\n## ルーンリテラル\n\n### 基本構文\n\nシングルクォートでルーンリテラルを表記：\n\n```hemlock\nlet a = 'A';            // ASCII文字\nlet b = '0';            // 数字文字\nlet c = '!';            // 句読点\nlet d = ' ';            // スペース\n```\n\n### マルチバイトUTF-8文字\n\nルーンはあらゆるUnicode文字を表現可能：\n\n```hemlock\n// 絵文字\nlet rocket = '🚀';      // 絵文字（U+1F680）\nlet heart = '❤';        // ハート（U+2764）\nlet smile = '😀';       // 笑顔（U+1F600）\n\n// CJK文字\nlet chinese = '中';     // 中国語（U+4E2D）\nlet japanese = 'あ';    // ひらがな（U+3042）\nlet korean = '한';      // ハングル（U+D55C）\n\n// 記号\nlet check = '✓';        // チェックマーク（U+2713）\nlet arrow = '→';        // 右矢印（U+2192）\n```\n\n### エスケープシーケンス\n\n特殊文字のための一般的なエスケープシーケンス：\n\n```hemlock\nlet newline = '\\n';     // 改行（U+000A）\nlet tab = '\\t';         // タブ（U+0009）\nlet backslash = '\\\\';   // バックスラッシュ（U+005C）\nlet quote = '\\'';       // シングルクォート（U+0027）\nlet dquote = '\"';       // ダブルクォート（U+0022）\nlet null_char = '\\0';   // ヌル文字（U+0000）\nlet cr = '\\r';          // キャリッジリターン（U+000D）\n```\n\n**利用可能なエスケープシーケンス：**\n- `\\n` - 改行（ラインフィード）\n- `\\t` - 水平タブ\n- `\\r` - キャリッジリターン\n- `\\0` - ヌル文字\n- `\\\\` - バックスラッシュ\n- `\\'` - シングルクォート\n- `\\\"` - ダブルクォート\n\n### Unicodeエスケープ\n\nUnicodeコードポイントには`\\u{XXXXXX}`構文を使用（最大6桁の16進数）：\n\n```hemlock\nlet rocket = '\\u{1F680}';   // 🚀 Unicodeエスケープで絵文字\nlet heart = '\\u{2764}';     // ❤ ハート\nlet ascii = '\\u{41}';       // 'A' エスケープで\nlet max = '\\u{10FFFF}';     // 最大Unicodeコードポイント\n\n// 先頭のゼロはオプション\nlet a = '\\u{41}';           // '\\u{0041}'と同じ\nlet b = '\\u{0041}';\n```\n\n**ルール：**\n- 範囲：`\\u{0}`から`\\u{10FFFF}`\n- 16進数桁：1から6桁\n- 大文字小文字を区別しない：`\\u{1F680}`または`\\u{1f680}`\n- 有効なUnicode範囲外の値はエラー\n\n## 文字列 + ルーンの連結\n\nルーンは文字列と連結可能：\n\n```hemlock\n// 文字列 + ルーン\nlet greeting = \"Hello\" + '!';       // \"Hello!\"\nlet decorated = \"Text\" + '✓';       // \"Text✓\"\n\n// ルーン + 文字列\nlet prefix = '>' + \" Message\";      // \"> Message\"\nlet bullet = '•' + \" Item\";         // \"• Item\"\n\n// 複数の連結\nlet msg = \"Hi \" + '👋' + \" World \" + '🌍';  // \"Hi 👋 World 🌍\"\n\n// メソッドチェーンも動作\nlet result = ('>' + \" Important\").to_upper();  // \"> IMPORTANT\"\n```\n\n**動作の仕組み：**\n- ルーンは自動的にUTF-8にエンコード\n- 連結時に文字列に変換\n- 文字列連結演算子がこれを透過的に処理\n\n## 型変換\n\nルーンは他の型との間で変換可能。\n\n### 整数 ↔ ルーン\n\nコードポイント値を扱うために整数とルーンの間で変換：\n\n```hemlock\n// 整数からルーン（コードポイント値）\nlet code: rune = 65;            // 'A'（ASCII 65）\nlet emoji_code: rune = 128640;  // U+1F680（🚀）\n\n// ルーンから整数（コードポイント値を取得）\nlet r = 'Z';\nlet value: i32 = r;             // 90（ASCII値）\n\nlet rocket = '🚀';\nlet code: i32 = rocket;         // 128640（U+1F680）\n```\n\n**範囲チェック：**\n- 整数からルーン：[0, 0x10FFFF]の範囲内である必要がある\n- 範囲外の値は実行時エラー\n- ルーンから整数：常に成功（コードポイントを返す）\n\n### ルーン → 文字列\n\nルーンは明示的に文字列に変換可能：\n\n```hemlock\n// 明示的な変換\nlet ch: string = 'H';           // \"H\"\nlet emoji: string = '🚀';       // \"🚀\"\n\n// 連結時は自動\nlet s = \"\" + 'A';               // \"A\"\nlet s2 = \"x\" + 'y' + \"z\";       // \"xyz\"\n```\n\n### u8（バイト） → ルーン\n\n任意のu8値（0-255）はルーンに変換可能：\n\n```hemlock\n// ASCII範囲（0-127）\nlet byte: u8 = 65;\nlet rune_val: rune = byte;      // 'A'\n\n// 拡張ASCII / Latin-1（128-255）\nlet extended: u8 = 200;\nlet r: rune = extended;         // U+00C8（È）\n\n// 注意：値0-127はASCII、128-255はLatin-1\n```\n\n### チェーン変換\n\n型変換はチェーン可能：\n\n```hemlock\n// i32 → ルーン → 文字列\nlet code: i32 = 128512;         // 笑顔のコードポイント\nlet r: rune = code;             // 😀\nlet s: string = r;              // \"😀\"\n\n// 1つの式で全部\nlet emoji: string = 128640;     // 暗黙のi32 → ルーン → 文字列（🚀）\n```\n\n## ルーン操作\n\n### 出力\n\nルーンの表示方法はコードポイントに依存：\n\n```hemlock\nlet ascii = 'A';\nprint(ascii);                   // 'A'（引用符付き、印刷可能ASCII）\n\nlet emoji = '🚀';\nprint(emoji);                   // U+1F680（非ASCIIはUnicode表記）\n\nlet tab = '\\t';\nprint(tab);                     // U+0009（非印刷は16進数で）\n\nlet space = ' ';\nprint(space);                   // ' '（印刷可能）\n```\n\n**出力形式：**\n- 印刷可能ASCII（32-126）：引用符付き文字 `'A'`\n- 非印刷またはUnicode：16進表記 `U+XXXX`\n\n### 型チェック\n\n`typeof()`を使用して値がルーンかチェック：\n\n```hemlock\nlet r = '🚀';\nprint(typeof(r));               // \"rune\"\n\nlet s = \"text\";\nlet ch = s[0];\nprint(typeof(ch));              // \"rune\"（インデックスはルーンを返す）\n\nlet num = 65;\nprint(typeof(num));             // \"i32\"\n```\n\n### 比較\n\nルーンは等価性で比較可能：\n\n```hemlock\nlet a = 'A';\nlet b = 'B';\nprint(a == a);                  // true\nprint(a == b);                  // false\n\n// 大文字小文字を区別\nlet upper = 'A';\nlet lower = 'a';\nprint(upper == lower);          // false\n\n// ルーンは整数（コードポイント値）と比較可能\nprint(a == 65);                 // true（暗黙の変換）\nprint('🚀' == 128640);          // true\n```\n\n**比較演算子：**\n- `==` - 等しい\n- `!=` - 等しくない\n- `<`、`>`、`<=`、`>=` - コードポイント順序\n\n```hemlock\nprint('A' < 'B');               // true（65 < 66）\nprint('a' > 'Z');               // true（97 > 90）\n```\n\n## 文字列インデックスとの連携\n\n文字列のインデックスはバイトではなくルーンを返す：\n\n```hemlock\nlet s = \"Hello🚀\";\nlet h = s[0];                   // 'H'（ルーン）\nlet rocket = s[5];              // '🚀'（ルーン）\n\nprint(typeof(h));               // \"rune\"\nprint(typeof(rocket));          // \"rune\"\n\n// 必要なら文字列に変換\nlet h_str: string = h;          // \"H\"\nlet rocket_str: string = rocket; // \"🚀\"\n```\n\n**重要：** 文字列のインデックスはバイトオフセットではなくコードポイント位置を使用：\n\n```hemlock\nlet text = \"Hi🚀!\";\n// コードポイント位置：0='H', 1='i', 2='🚀', 3='!'\n// バイト位置：      0='H', 1='i', 2-5='🚀', 6='!'\n\nlet r = text[2];                // '🚀'（コードポイント2）\nprint(typeof(r));               // \"rune\"\n```\n\n## 例\n\n### 例：文字分類\n\n```hemlock\nfn is_digit(r: rune): bool {\n    return r >= '0' && r <= '9';\n}\n\nfn is_upper(r: rune): bool {\n    return r >= 'A' && r <= 'Z';\n}\n\nfn is_lower(r: rune): bool {\n    return r >= 'a' && r <= 'z';\n}\n\nprint(is_digit('5'));           // true\nprint(is_upper('A'));           // true\nprint(is_lower('z'));           // true\n```\n\n### 例：大文字小文字変換\n\n```hemlock\nfn to_upper_rune(r: rune): rune {\n    if (r >= 'a' && r <= 'z') {\n        // 大文字に変換（32を引く）\n        let code: i32 = r;\n        code = code - 32;\n        return code;\n    }\n    return r;\n}\n\nfn to_lower_rune(r: rune): rune {\n    if (r >= 'A' && r <= 'Z') {\n        // 小文字に変換（32を足す）\n        let code: i32 = r;\n        code = code + 32;\n        return code;\n    }\n    return r;\n}\n\nprint(to_upper_rune('a'));      // 'A'\nprint(to_lower_rune('Z'));      // 'z'\n```\n\n### 例：文字の反復\n\n```hemlock\nfn print_chars(s: string) {\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        print(\"Position \" + typeof(i) + \": \" + typeof(ch));\n        i = i + 1;\n    }\n}\n\nprint_chars(\"Hi🚀\");\n// Position 0: 'H'\n// Position 1: 'i'\n// Position 2: U+1F680\n```\n\n### 例：ルーンから文字列を構築\n\n```hemlock\nfn repeat_char(ch: rune, count: i32): string {\n    let result = \"\";\n    let i = 0;\n    while (i < count) {\n        result = result + ch;\n        i = i + 1;\n    }\n    return result;\n}\n\nlet line = repeat_char('=', 40);  // \"========================================\"\nlet stars = repeat_char('⭐', 5);  // \"⭐⭐⭐⭐⭐\"\n```\n\n## よくあるパターン\n\n### パターン：文字フィルタ\n\n```hemlock\nfn filter_digits(s: string): string {\n    let result = \"\";\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        if (ch >= '0' && ch <= '9') {\n            result = result + ch;\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet text = \"abc123def456\";\nlet digits = filter_digits(text);  // \"123456\"\n```\n\n### パターン：文字カウント\n\n```hemlock\nfn count_char(s: string, target: rune): i32 {\n    let count = 0;\n    let i = 0;\n    while (i < s.length) {\n        if (s[i] == target) {\n            count = count + 1;\n        }\n        i = i + 1;\n    }\n    return count;\n}\n\nlet text = \"hello world\";\nlet l_count = count_char(text, 'l');  // 3\nlet o_count = count_char(text, 'o');  // 2\n```\n\n## ベストプラクティス\n\n1. **文字操作にはルーンを使用** - テキスト処理でバイトを使おうとしない\n2. **文字列のインデックスはルーンを返す** - `str[i]`がルーンを与えることを覚えておく\n3. **Unicode対応の比較** - ルーンはあらゆるUnicode文字を処理\n4. **必要なら変換** - ルーンは簡単に文字列や整数に変換可能\n5. **絵文字でテスト** - 常にマルチバイト文字で文字操作をテスト\n\n## よくある落とし穴\n\n### 落とし穴：ルーン vs バイトの混乱\n\n```hemlock\n// やらない：ルーンをバイトとして扱う\nlet r: rune = '🚀';\nlet b: u8 = r;              // エラー：ルーンのコードポイント128640はu8に収まらない\n\n// やる：適切な変換を使用\nlet r: rune = '🚀';\nlet code: i32 = r;          // OK：128640\n```\n\n### 落とし穴：文字列のバイトインデックス\n\n```hemlock\n// やらない：バイトインデックスを想定\nlet s = \"🚀\";\nlet byte = s.byte_at(0);    // 240（最初のUTF-8バイト、完全な文字ではない）\n\n// やる：コードポイントインデックスを使用\nlet s = \"🚀\";\nlet rune = s[0];            // '🚀'（完全な文字）\nlet rune2 = s.char_at(0);   // '🚀'（明示的なメソッド）\n```\n\n## 関連トピック\n\n- [文字列](#language-guide-strings) - 文字列操作とUTF-8の扱い\n- [型](#language-guide-types) - 型システムと変換\n- [制御フロー](#language-guide-control-flow) - 比較でのルーンの使用\n\n## 参照\n\n- **Unicode標準**：UnicodeコードポイントはUnicodeコンソーシアムによって定義\n- **UTF-8エンコーディング**：UTF-8の詳細は[文字列](#language-guide-strings)を参照\n- **型変換**：変換ルールは[型](#language-guide-types)を参照\n"}, "言語ガイド -> 制御フロー": {"id": "language-guide-control-flow", "content": "# 制御フロー\n\nHemlockは、必須のブレースと明示的な構文を備えた、おなじみのCスタイルの制御フローを提供します。このガイドでは、条件分岐、ループ、switch文、演算子について説明します。\n\n## 概要\n\n利用可能な制御フロー機能：\n\n- `if`/`else`/`else if` - 条件分岐\n- `while`ループ - 条件ベースの反復\n- `for`ループ - Cスタイルとfor-in反復\n- `loop` - 無限ループ（`while (true)`よりクリーン）\n- `switch`文 - 多方向分岐\n- `break`/`continue` - ループ制御\n- ループラベル - ネストされたループ向けのターゲット指定break/continue\n- `defer` - 遅延実行（クリーンアップ）\n- 論理演算子：`&&`、`||`、`!`\n- 比較演算子：`==`、`!=`、`<`、`>`、`<=`、`>=`\n- ビット演算子：`&`、`|`、`^`、`<<`、`>>`、`~`\n\n## If文\n\n### 基本的なIf/Else\n\n```hemlock\nif (x > 10) {\n    print(\"large\");\n} else {\n    print(\"small\");\n}\n```\n\n**ルール：**\n- ブレースはすべてのブランチで**常に必須**\n- 条件は括弧で囲む必要がある\n- オプションのブレースなし（Cとは異なる）\n\n### Elseなしのif\n\n```hemlock\nif (x > 0) {\n    print(\"positive\");\n}\n// elseブランチは不要\n```\n\n### Else-Ifチェーン\n\n```hemlock\nif (x > 100) {\n    print(\"very large\");\n} else if (x > 50) {\n    print(\"large\");\n} else if (x > 10) {\n    print(\"medium\");\n} else {\n    print(\"small\");\n}\n```\n\n**注意：** `else if`はネストされたif文の糖衣構文です。これらは等価です：\n\n```hemlock\n// else if（糖衣構文）\nif (a) {\n    foo();\n} else if (b) {\n    bar();\n}\n\n// 等価なネストされたif\nif (a) {\n    foo();\n} else {\n    if (b) {\n        bar();\n    }\n}\n```\n\n### ネストされたIf文\n\n```hemlock\nif (x > 0) {\n    if (x < 10) {\n        print(\"single digit positive\");\n    } else {\n        print(\"multi-digit positive\");\n    }\n} else {\n    print(\"non-positive\");\n}\n```\n\n## Whileループ\n\n条件ベースの反復：\n\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n**無限ループ（旧スタイル）：**\n```hemlock\nwhile (true) {\n    // ... 処理を行う\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**注意：** 無限ループには`loop`キーワードを推奨（下記参照）。\n\n## Loop（無限ループ）\n\n`loop`キーワードは無限ループのためのよりクリーンな構文を提供します：\n\n```hemlock\nloop {\n    // ... 処理を行う\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**`while (true)`と等価ですが、意図がより明確です。**\n\n### Breakを使った基本的なLoop\n\n```hemlock\nlet i = 0;\nloop {\n    if (i >= 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// 出力：0, 1, 2, 3, 4\n```\n\n### Continueを使ったLoop\n\n```hemlock\nlet i = 0;\nloop {\n    i = i + 1;\n    if (i > 5) {\n        break;\n    }\n    if (i == 3) {\n        continue;  // 3の出力をスキップ\n    }\n    print(i);\n}\n// 出力：1, 2, 4, 5\n```\n\n### ネストされたLoop\n\n```hemlock\nlet x = 0;\nloop {\n    if (x >= 2) { break; }\n    let y = 0;\n    loop {\n        if (y >= 3) { break; }\n        print(x * 10 + y);\n        y = y + 1;\n    }\n    x = x + 1;\n}\n// 出力：0, 1, 2, 10, 11, 12\n```\n\n### Loopの使用タイミング\n\n- **`loop`を使用** - `break`で終了する意図的な無限ループ\n- **`while`を使用** - 自然な終了条件がある場合\n- **`for`を使用** - 既知の回数または コレクションを反復する場合\n\n## Forループ\n\n### Cスタイルのfor\n\n古典的な3部構成のforループ：\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**構成要素：**\n- **初期化子**：`let i = 0` - ループ前に1回実行\n- **条件**：`i < 10` - 各反復前にチェック\n- **更新**：`i = i + 1` - 各反復後に実行\n\n**スコープ：**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n// iはここではアクセスできない（ループスコープ）\n```\n\n### For-Inループ\n\n配列要素の反復：\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nfor (let item in arr) {\n    print(item);  // 各要素を出力\n}\n```\n\n**インデックスと値を使用：**\n```hemlock\nlet arr = [\"a\", \"b\", \"c\"];\nfor (let i = 0; i < arr.length; i = i + 1) {\n    print(`Index: ${i}, Value: ${arr[i]}`);\n}\n```\n\n## Switch文\n\n値に基づく多方向分岐：\n\n### 基本的なSwitch\n\n```hemlock\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n}\n```\n\n### Defaultを使ったSwitch\n\n```hemlock\nlet color = \"blue\";\n\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"yellow\":\n        print(\"slow\");\n        break;\n    case \"green\":\n        print(\"go\");\n        break;\n    default:\n        print(\"unknown color\");\n        break;\n}\n```\n\n**ルール：**\n- `default`は他のどのcaseにもマッチしない場合にマッチ\n- `default`はswitch本体のどこにでも配置可能\n- defaultケースは1つのみ許可\n\n### フォールスルー動作\n\n`break`なしのcaseは次のcaseにフォールスルー（Cスタイルの動作）。これは**意図的な**もので、caseをグループ化するために使用できます：\n\n```hemlock\nlet grade = 85;\n\nswitch (grade) {\n    case 100:\n    case 95:\n    case 90:\n        print(\"A\");\n        break;\n    case 85:\n    case 80:\n        print(\"B\");\n        break;\n    default:\n        print(\"C or below\");\n        break;\n}\n```\n\n**明示的なフォールスルーの例：**\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n        print(\"Weekday\");\n        break;\n    case 6:\n    case 7:\n        print(\"Weekend\");\n        break;\n}\n```\n\n**重要：** 一部のモダンな言語とは異なり、Hemlockは明示的な`fallthrough`キーワードを必要としません。caseは`break`、`return`、または`throw`で終了しない限り自動的にフォールスルーします。意図しないフォールスルーを防ぐために常に`break`を使用してください。\n\n### Returnを使ったSwitch\n\n関数内では、`return`はswitchを即座に終了します：\n\n```hemlock\nfn get_day_name(day: i32): string {\n    switch (day) {\n        case 1:\n            return \"Monday\";\n        case 2:\n            return \"Tuesday\";\n        case 3:\n            return \"Wednesday\";\n        default:\n            return \"Unknown\";\n    }\n}\n```\n\n### Switchの値の型\n\nSwitchは任意の値の型で動作します：\n\n```hemlock\n// 整数\nswitch (count) {\n    case 0: print(\"zero\"); break;\n    case 1: print(\"one\"); break;\n}\n\n// 文字列\nswitch (name) {\n    case \"Alice\": print(\"A\"); break;\n    case \"Bob\": print(\"B\"); break;\n}\n\n// 真偽値\nswitch (flag) {\n    case true: print(\"on\"); break;\n    case false: print(\"off\"); break;\n}\n```\n\n**注意：** caseは値の等価性を使用して比較されます。\n\n## BreakとContinue\n\n### Break\n\n最も内側のループまたはswitchを終了：\n\n```hemlock\n// ループ内\nlet i = 0;\nwhile (true) {\n    if (i >= 10) {\n        break;  // ループを終了\n    }\n    print(i);\n    i = i + 1;\n}\n\n// switch内\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;  // switchを終了\n    case 2:\n        print(\"two\");\n        break;\n}\n```\n\n### Continue\n\nループの次の反復にスキップ：\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;  // iが5のとき反復をスキップ\n    }\n    print(i);  // 0,1,2,3,4,6,7,8,9を出力\n}\n```\n\n**違い：**\n- `break` - ループを完全に終了\n- `continue` - 次の反復にスキップ\n\n## ループラベル\n\nループラベルにより、`break`と`continue`が最も内側のループだけでなく、特定の外側のループをターゲットにできます。ネストされたループで外側のループを内側から制御する必要がある場合に便利です。\n\n### ラベル付きBreak\n\n内側のループから外側のループを終了：\n\n```hemlock\nouter: while (i < 3) {\n    let j = 0;\n    while (j < 3) {\n        if (i == 1 && j == 1) {\n            break outer;  // 外側のwhileループを終了\n        }\n        print(i * 10 + j);\n        j = j + 1;\n    }\n    i = i + 1;\n}\n// 出力：0, 1, 2, 10（i=1, j=1で停止）\n```\n\n### ラベル付きContinue\n\n外側のループの次の反復にスキップ：\n\n```hemlock\nlet i = 0;\nouter: while (i < 3) {\n    i = i + 1;\n    let j = 0;\n    while (j < 3) {\n        j = j + 1;\n        if (i == 2 && j == 1) {\n            continue outer;  // 内側ループの残りをスキップし、外側を続行\n        }\n        print(i * 10 + j);\n    }\n}\n// i=2, j=1のとき：次の外側反復にスキップ\n```\n\n### Forループでのラベル\n\nラベルはすべてのループタイプで動作します：\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 3; y = y + 1) {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n    }\n}\n```\n\n### For-Inループでのラベル\n\n```hemlock\nlet arr1 = [1, 2, 3];\nlet arr2 = [10, 20, 30];\n\nouter: for (let a in arr1) {\n    for (let b in arr2) {\n        if (a == 2 && b == 20) {\n            break outer;\n        }\n        print(a * 100 + b);\n    }\n}\n```\n\n### Loopキーワードでのラベル\n\n```hemlock\nlet x = 0;\nouter: loop {\n    let y = 0;\n    loop {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n        y = y + 1;\n        if (y >= 3) { break; }\n    }\n    x = x + 1;\n    if (x >= 3) { break; }\n}\n```\n\n### 複数のラベル\n\n異なるネストレベルにラベルを設定できます：\n\n```hemlock\nouter: for (let a = 0; a < 2; a = a + 1) {\n    inner: for (let b = 0; b < 3; b = b + 1) {\n        for (let c = 0; c < 3; c = c + 1) {\n            if (c == 1) {\n                continue inner;  // 中間ループの次の反復にスキップ\n            }\n            if (a == 1 && b == 1) {\n                break outer;      // 最外ループを終了\n            }\n            print(a * 100 + b * 10 + c);\n        }\n    }\n}\n```\n\n### ラベル付きループでのラベルなしBreak/Continue\n\nラベルなしの`break`と`continue`は、外側のループにラベルがあっても通常通り動作します（最も内側のループに影響）：\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 5; y = y + 1) {\n        if (y == 2) {\n            break;  // 内側のループのみ終了\n        }\n        print(x * 10 + y);\n    }\n}\n// 出力：0, 1, 10, 11, 20, 21\n```\n\n### ラベルの構文\n\n- ラベルはコロンが続く識別子\n- ラベルはループ文（`while`、`for`、`loop`）の直前に置く必要がある\n- ラベル名は識別子のルールに従う（文字、数字、アンダースコア）\n- 一般的な規約：`outer`、`inner`、`row`、`col`、説明的な名前\n\n## Defer文\n\n`defer`文は、現在の関数が戻るときに実行するコードをスケジュールします。ファイルのクローズ、リソースの解放、ロックの解除などのクリーンアップ操作に便利です。\n\n### 基本的なDefer\n\n```hemlock\nfn example() {\n    print(\"start\");\n    defer print(\"cleanup\");  // 関数が戻るときに実行\n    print(\"end\");\n}\n\nexample();\n// 出力：\n// start\n// end\n// cleanup\n```\n\n**主な動作：**\n- 遅延された文は関数本体が完了した**後**に実行\n- 遅延された文は関数が呼び出し元に戻る**前**に実行\n- 遅延された文は関数が例外をスローしても常に実行\n\n### 複数のDefer（LIFO順）\n\n複数の`defer`文が使用される場合、**逆順**（後入れ先出し）で実行されます：\n\n```hemlock\nfn example() {\n    defer print(\"first\");   // 最後に実行\n    defer print(\"second\");  // 2番目に実行\n    defer print(\"third\");   // 最初に実行\n    print(\"body\");\n}\n\nexample();\n// 出力：\n// body\n// third\n// second\n// first\n```\n\nこのLIFO順は意図的なものです - ネストされたリソースのクリーンアップの自然な順序（内側のリソースを外側より先にクローズ）に一致します。\n\n### ReturnとDefer\n\n遅延された文は`return`が制御を移す前に実行されます：\n\n```hemlock\nfn get_value(): i32 {\n    defer print(\"cleanup\");\n    print(\"before return\");\n    return 42;\n}\n\nlet result = get_value();\nprint(\"result:\", result);\n// 出力：\n// before return\n// cleanup\n// result: 42\n```\n\n### 例外とDefer\n\n遅延された文は例外がスローされても実行されます：\n\n```hemlock\nfn risky() {\n    defer print(\"cleanup 1\");\n    defer print(\"cleanup 2\");\n    print(\"before throw\");\n    throw \"error!\";\n    print(\"after throw\");  // 到達しない\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(\"Caught:\", e);\n}\n// 出力：\n// before throw\n// cleanup 2\n// cleanup 1\n// Caught: error!\n```\n\n### リソースクリーンアップパターン\n\n`defer`の主な使用例はリソースのクリーンアップを確実にすること：\n\n```hemlock\nfn process_file(filename: string) {\n    let file = open(filename, \"r\");\n    defer file.close();  // エラー時も常にクローズ\n\n    let content = file.read();\n    // ... コンテンツを処理 ...\n\n    // 関数が戻るときにファイルは自動的にクローズ\n}\n```\n\n**deferなし（エラーが起きやすい）：**\n```hemlock\nfn process_file_bad(filename: string) {\n    let file = open(filename, \"r\");\n    let content = file.read();\n    // これがスローすると、file.close()は呼ばれない！\n    process(content);\n    file.close();\n}\n```\n\n### クロージャとDefer\n\nDeferはクロージャを使用して状態をキャプチャできます：\n\n```hemlock\nfn example() {\n    let resource = acquire_resource();\n    defer fn() {\n        print(\"Releasing resource\");\n        release(resource);\n    }();  // 注意：即時実行関数式\n\n    use_resource(resource);\n}\n```\n\n### Deferを使用するタイミング\n\n**deferを使用する場面：**\n- ファイルとネットワーク接続のクローズ\n- 割り当てられたメモリの解放\n- ロックとミューテックスの解放\n- リソースを取得する関数でのクリーンアップ\n\n**Defer vs Finally：**\n- `defer`は単一リソースのクリーンアップにシンプル\n- `try/finally`はリカバリを伴う複雑なエラーハンドリングに適している\n\n### ベストプラクティス\n\n1. **リソース取得直後にdeferを配置：**\n   ```hemlock\n   let file = open(\"data.txt\", \"r\");\n   defer file.close();\n   // ... ファイルを使用 ...\n   ```\n\n2. **複数のリソースには複数のdeferを使用：**\n   ```hemlock\n   let file1 = open(\"input.txt\", \"r\");\n   defer file1.close();\n\n   let file2 = open(\"output.txt\", \"w\");\n   defer file2.close();\n\n   // 両方のファイルは逆順でクローズされる\n   ```\n\n3. **依存リソースにはLIFO順を考慮：**\n   ```hemlock\n   let outer = acquire_outer();\n   defer release_outer(outer);\n\n   let inner = acquire_inner(outer);\n   defer release_inner(inner);\n\n   // innerがouterより先に解放される（正しい依存順序）\n   ```\n\n## 論理演算子\n\n### 論理AND（`&&`）\n\n両方の条件がtrueである必要がある：\n\n```hemlock\nif (x > 0 && x < 10) {\n    print(\"single digit positive\");\n}\n```\n\n**短絡評価：**\n```hemlock\nif (false && expensive_check()) {\n    // expensive_check()は呼ばれない\n}\n```\n\n### 論理OR（`||`）\n\n少なくとも1つの条件がtrueである必要がある：\n\n```hemlock\nif (x < 0 || x > 100) {\n    print(\"out of range\");\n}\n```\n\n**短絡評価：**\n```hemlock\nif (true || expensive_check()) {\n    // expensive_check()は呼ばれない\n}\n```\n\n### 論理NOT（`!`）\n\n真偽値を否定：\n\n```hemlock\nif (!is_valid) {\n    print(\"invalid\");\n}\n\nif (!(x > 10)) {\n    // 以下と同等：if (x <= 10)\n}\n```\n\n## 比較演算子\n\n### 等価性\n\n```hemlock\nif (x == 10) { }    // 等しい\nif (x != 10) { }    // 等しくない\n```\n\nすべての型で動作：\n```hemlock\n\"hello\" == \"hello\"  // true\ntrue == false       // false\nnull == null        // true\n```\n\n### 関係\n\n```hemlock\nif (x < 10) { }     // より小さい\nif (x > 10) { }     // より大きい\nif (x <= 10) { }    // 以下\nif (x >= 10) { }    // 以上\n```\n\n**型の昇格が適用される：**\n```hemlock\nlet a: i32 = 10;\nlet b: i64 = 10;\nif (a == b) { }     // true（i32がi64に昇格）\n```\n\n## ビット演算子\n\nHemlockは整数操作のためのビット演算子を提供します。これらは**整数型のみ**（i8-i64、u8-u64）で動作します。\n\n### 二項ビット演算子\n\n**ビットAND（`&`）**\n```hemlock\nlet a = 12;  // 2進数で1100\nlet b = 10;  // 2進数で1010\nprint(a & b);   // 8（1000）\n```\n\n**ビットOR（`|`）**\n```hemlock\nprint(a | b);   // 14（1110）\n```\n\n**ビットXOR（`^`）**\n```hemlock\nprint(a ^ b);   // 6（0110）\n```\n\n**左シフト（`<<`）**\n```hemlock\nprint(a << 2);  // 48（110000）- 2ビット左にシフト\n```\n\n**右シフト（`>>`）**\n```hemlock\nprint(a >> 1);  // 6（110）- 1ビット右にシフト\n```\n\n### 単項ビット演算子\n\n**ビットNOT（`~`）**\n```hemlock\nlet a = 12;\nprint(~a);      // -13（2の補数）\n\nlet c: u8 = 15;   // 2進数で00001111\nprint(~c);        // 240（u8で11110000）\n```\n\n### ビット演算の例\n\n**符号なし型での例：**\n```hemlock\nlet c: u8 = 15;   // 2進数で00001111\nlet d: u8 = 7;    // 2進数で00000111\n\nprint(c & d);     // 7（00000111）\nprint(c | d);     // 15（00001111）\nprint(c ^ d);     // 8（00001000）\nprint(~c);        // 240（u8で11110000）\n```\n\n**型の保持：**\n```hemlock\n// ビット演算はオペランドの型を保持\nlet x: u8 = 255;\nlet result = ~x;  // resultは値0のu8\n\nlet y: i32 = 100;\nlet result2 = y << 2;  // result2は値400のi32\n```\n\n**一般的なパターン：**\n```hemlock\n// ビットが設定されているか確認\nif (flags & 0x04) {\n    print(\"bit 2 is set\");\n}\n\n// ビットを設定\nflags = flags | 0x08;\n\n// ビットをクリア\nflags = flags & ~0x02;\n\n// ビットをトグル\nflags = flags ^ 0x01;\n```\n\n### 演算子の優先順位\n\nビット演算子はCスタイルの優先順位に従います：\n\n1. `~`（単項NOT）- 最高、`!`と`-`と同レベル\n2. `<<`、`>>`（シフト）- 比較より高く、`+`/`-`より低い\n3. `&`（ビットAND）- `^`と`|`より高い\n4. `^`（ビットXOR）- `&`と`|`の間\n5. `|`（ビットOR）- `&`と`^`より低く、`&&`より高い\n6. `&&`、`||`（論理）- 最低優先順位\n\n**例：**\n```hemlock\n// &は|より優先順位が高い\nlet result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12\n\n// シフトはビット演算子より優先順位が高い\nlet result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12\n\n// 明確さのために括弧を使用\nlet result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5\n```\n\n**重要な注意：**\n- ビット演算子は整数型のみで動作（浮動小数点数、文字列などでは動作しない）\n- 型の昇格は標準ルールに従う（小さい型は大きい型に昇格）\n- 右シフト（`>>`）は符号付き型では算術シフト、符号なし型では論理シフト\n- シフト量は範囲チェックされない（大きなシフトの動作はプラットフォーム依存）\n\n## 演算子の優先順位（完全版）\n\n最高から最低への優先順位：\n\n1. **単項**：`!`、`-`、`~`\n2. **乗法**：`*`、`/`、`%`\n3. **加法**：`+`、`-`\n4. **シフト**：`<<`、`>>`\n5. **関係**：`<`、`>`、`<=`、`>=`\n6. **等価**：`==`、`!=`\n7. **ビットAND**：`&`\n8. **ビットXOR**：`^`\n9. **ビットOR**：`|`\n10. **論理AND**：`&&`\n11. **論理OR**：`||`\n\n**明確さのために括弧を使用：**\n```hemlock\n// 不明確\nif (a || b && c) { }\n\n// 明確\nif (a || (b && c)) { }\nif ((a || b) && c) { }\n```\n\n## よくあるパターン\n\n### パターン：入力検証\n\n```hemlock\nfn validate_age(age: i32): bool {\n    if (age < 0 || age > 150) {\n        return false;\n    }\n    return true;\n}\n```\n\n### パターン：範囲チェック\n\n```hemlock\nfn in_range(value: i32, min: i32, max: i32): bool {\n    return value >= min && value <= max;\n}\n\nif (in_range(score, 0, 100)) {\n    print(\"valid score\");\n}\n```\n\n### パターン：状態マシン\n\n```hemlock\nlet state = \"start\";\n\nwhile (true) {\n    switch (state) {\n        case \"start\":\n            print(\"Starting...\");\n            state = \"running\";\n            break;\n\n        case \"running\":\n            if (should_pause) {\n                state = \"paused\";\n            } else if (should_stop) {\n                state = \"stopped\";\n            }\n            break;\n\n        case \"paused\":\n            if (should_resume) {\n                state = \"running\";\n            }\n            break;\n\n        case \"stopped\":\n            print(\"Stopped\");\n            break;\n    }\n\n    if (state == \"stopped\") {\n        break;\n    }\n}\n```\n\n### パターン：フィルタリング付き反復\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// 偶数のみを出力\nfor (let i = 0; i < arr.length; i = i + 1) {\n    if (arr[i] % 2 != 0) {\n        continue;  // 奇数をスキップ\n    }\n    print(arr[i]);\n}\n```\n\n### パターン：早期終了\n\n```hemlock\nfn find_first_negative(arr: array): i32 {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // 早期終了\n        }\n    }\n    return -1;  // 見つからない\n}\n```\n\n## ベストプラクティス\n\n1. **常にブレースを使用** - 単一文ブロックでも（構文で強制）\n2. **明示的な条件** - 明確さのために`!x`ではなく`x == 0`を使用\n3. **深いネストを避ける** - ネストした条件を関数に抽出\n4. **早期returnを使用** - ガード句でネストを減らす\n5. **複雑な条件を分割** - 名前付き真偽値変数に分割\n6. **switchでdefault** - 常にdefaultケースを含める\n7. **フォールスルーにコメント** - 意図的なフォールスルーを明示\n\n## よくある落とし穴\n\n### 落とし穴：条件内の代入\n\n```hemlock\n// これは許可されていない（条件内の代入なし）\nif (x = 10) { }  // エラー：構文エラー\n\n// 代わりに比較を使用\nif (x == 10) { }  // OK\n```\n\n### 落とし穴：switch内のBreak忘れ\n\n```hemlock\n// 意図しないフォールスルー\nswitch (x) {\n    case 1:\n        print(\"one\");\n        // breakがない - フォールスルー！\n    case 2:\n        print(\"two\");  // 1と2の両方で実行\n        break;\n}\n\n// 修正：breakを追加\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;  // これで正しい\n    case 2:\n        print(\"two\");\n        break;\n}\n```\n\n### 落とし穴：ループ変数のスコープ\n\n```hemlock\n// iはループにスコープされている\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\nprint(i);  // エラー：iはここで定義されていない\n```\n\n## 例\n\n### 例：FizzBuzz\n\n```hemlock\nfor (let i = 1; i <= 100; i = i + 1) {\n    if (i % 15 == 0) {\n        print(\"FizzBuzz\");\n    } else if (i % 3 == 0) {\n        print(\"Fizz\");\n    } else if (i % 5 == 0) {\n        print(\"Buzz\");\n    } else {\n        print(i);\n    }\n}\n```\n\n### 例：素数チェッカー\n\n```hemlock\nfn is_prime(n: i32): bool {\n    if (n < 2) {\n        return false;\n    }\n\n    let i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            return false;\n        }\n        i = i + 1;\n    }\n\n    return true;\n}\n```\n\n### 例：メニューシステム\n\n```hemlock\nfn menu() {\n    while (true) {\n        print(\"1. Start\");\n        print(\"2. Settings\");\n        print(\"3. Exit\");\n\n        let choice = get_input();\n\n        switch (choice) {\n            case 1:\n                start_game();\n                break;\n            case 2:\n                show_settings();\n                break;\n            case 3:\n                print(\"Goodbye!\");\n                return;\n            default:\n                print(\"Invalid choice\");\n                break;\n        }\n    }\n}\n```\n\n## 関連トピック\n\n- [関数](#language-guide-functions) - 関数呼び出しとreturnを使った制御フロー\n- [エラーハンドリング](#language-guide-error-handling) - 例外を使った制御フロー\n- [型](#language-guide-types) - 条件での型変換\n\n## 参照\n\n- **構文**：文の構文の詳細は[構文](#language-guide-syntax)を参照\n- **演算子**：演算での型の昇格は[型](#language-guide-types)を参照\n"}, "言語ガイド -> 型": {"id": "language-guide-types", "content": "# 型システム\n\nHemlockは**動的型システム**を特徴とし、オプションの型注釈と実行時型チェックを備えています。\n\n---\n\n## 型選択ガイド：どの型を使うべき？\n\n**型に慣れていない方**はここから始めてください。型システムに詳しい方は[設計思想](#設計思想)にスキップできます。\n\n### 簡潔な答え\n\n**Hemlockに任せましょう：**\n\n```hemlock\nlet count = 42;        // Hemlockはこれが整数だと知っている\nlet price = 19.99;     // Hemlockはこれが小数だと知っている\nlet name = \"Alice\";    // Hemlockはこれがテキストだと知っている\nlet active = true;     // Hemlockはこれがyes/noだと知っている\n```\n\nHemlockは値に対して自動的に適切な型を選びます。型を指定する*必要*はありません。\n\n### 型注釈を追加するタイミング\n\n以下の場合に型を追加します：\n\n1. **サイズを明確にしたい** - `i8` vs `i64`はメモリやFFIで重要\n2. **コードをドキュメント化したい** - 型は関数が何を期待するか示す\n3. **早期にミスを検出したい** - Hemlockは実行時に型をチェック\n\n```hemlock\n// 型なし（問題なく動作）：\nfn add(a, b) {\n    return a + b;\n}\n\n// 型あり（より明示的）：\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### クイックリファレンス：数値型の選択\n\n| 格納するもの | 推奨型 | 例 |\n|---------------------|----------------|---------|\n| 通常の整数 | `i32`（デフォルト） | `let count = 42;` |\n| 非常に大きな数 | `i64` | `let population = 8000000000;` |\n| 負にならないカウント | `u32` | `let items: u32 = 100;` |\n| バイト（0-255） | `u8` | `let pixel: u8 = 255;` |\n| 小数/分数 | `f64`（デフォルト） | `let price = 19.99;` |\n| パフォーマンス重視の小数 | `f32` | `let x: f32 = 1.5;` |\n\n### クイックリファレンス：すべての型\n\n| カテゴリ | 型 | 使用場面 |\n|----------|-------|-------------|\n| **整数** | `i8`、`i16`、`i32`、`i64` | カウント、ID、年齢など |\n| **正の数のみ** | `u8`、`u16`、`u32`、`u64` | バイト、サイズ、配列長 |\n| **小数** | `f32`、`f64` | 金額、測定値、数学 |\n| **Yes/No** | `bool` | フラグ、条件 |\n| **テキスト** | `string` | 名前、メッセージ、あらゆるテキスト |\n| **単一文字** | `rune` | 個々の文字、絵文字 |\n| **リスト** | `array` | 値のコレクション |\n| **名前付きフィールド** | `object` | 関連データのグループ化 |\n| **生メモリ** | `ptr`、`buffer` | 低レベルプログラミング |\n| **なし** | `null` | 値の不在 |\n\n### 一般的なシナリオ\n\n**「数値が欲しいだけ」**\n```hemlock\nlet x = 42;  // 完了！Hemlockがi32を選ぶ\n```\n\n**「小数が必要」**\n```hemlock\nlet price = 19.99;  // 完了！Hemlockがf64を選ぶ\n```\n\n**「バイトを扱っている（ファイル、ネットワーク）」**\n```hemlock\nlet byte: u8 = 255;  // 0-255の範囲\n```\n\n**「本当に大きな数が必要」**\n```hemlock\nlet big = 9000000000000;  // Hemlockが自動でi64を選ぶ（> i32 最大値）\n// または明示的に：\nlet big: i64 = 9000000000000;\n```\n\n**「金額を格納している」**\n```hemlock\n// オプション1：浮動小数点（シンプルだが精度に限界あり）\nlet price: f64 = 19.99;\n\n// オプション2：セントで格納（より精密）\nlet price_cents: i32 = 1999;  // $19.99を整数セントで\n```\n\n**「Cコードにデータを渡している（FFI）」**\n```hemlock\n// C言語の型に正確に合わせる\nlet c_int: i32 = 100;      // Cの'int'\nlet c_long: i64 = 100;     // Cの'long'（64ビット環境）\nlet c_char: u8 = 65;       // Cの'char'\nlet c_double: f64 = 3.14;  // Cの'double'\n```\n\n### 型が混在するとどうなる？\n\n異なる型を組み合わせると、Hemlockは「大きい」型に昇格します：\n\n```hemlock\nlet a: i32 = 10;\nlet b: f64 = 2.5;\nlet result = a + b;  // resultはf64（12.5）\n// 整数が自動的に小数になった\n```\n\n**経験則：** 浮動小数点は常に「勝つ」 - 整数と浮動小数点を混ぜると浮動小数点になります。\n\n### 型エラー\n\n間違った型を使おうとすると、Hemlockは実行時に教えてくれます：\n\n```hemlock\nlet age: i32 = \"thirty\";  // エラー：型不一致 - i32を期待、stringを受け取った\n```\n\n型を変換するには、型コンストラクタ関数を使用します：\n\n```hemlock\nlet text = \"42\";\nlet number = i32(text);   // 文字列を整数にパース：42\nlet back = text + \"\";     // すでに文字列\n```\n\n---\n\n## 設計思想\n\n- **デフォルトで動的** - すべての値は実行時型タグを持つ\n- **選択で型付け** - オプションの型注釈は実行時チェックを強制\n- **明示的な変換** - 暗黙の変換は明確な昇格ルールに従う\n- **型について正直** - `typeof()`は常に真実を伝える\n\n## プリミティブ型\n\n### 整数型\n\n**符号付き整数：**\n```hemlock\nlet tiny: i8 = 127;              // 8ビット（-128から127）\nlet small: i16 = 32767;          // 16ビット（-32768から32767）\nlet normal: i32 = 2147483647;    // 32ビット（デフォルト）\nlet large: i64 = 9223372036854775807;  // 64ビット\n```\n\n**符号なし整数：**\n```hemlock\nlet byte: u8 = 255;              // 8ビット（0から255）\nlet word: u16 = 65535;           // 16ビット（0から65535）\nlet dword: u32 = 4294967295;     // 32ビット（0から4294967295）\nlet qword: u64 = 18446744073709551615;  // 64ビット\n```\n\n**型エイリアス：**\n```hemlock\nlet i: integer = 42;   // i32のエイリアス\nlet b: byte = 255;     // u8のエイリアス\n```\n\n### 浮動小数点型\n\n```hemlock\nlet f: f32 = 3.14159;        // 32ビット浮動小数点\nlet d: f64 = 2.718281828;    // 64ビット浮動小数点（デフォルト）\nlet n: number = 1.618;       // f64のエイリアス\n```\n\n### 真偽値型\n\n```hemlock\nlet flag: bool = true;\nlet active: bool = false;\n```\n\n### 文字列型\n\n```hemlock\nlet text: string = \"Hello, World!\";\nlet empty: string = \"\";\n```\n\n文字列は**可変**、**UTF-8エンコード**、**ヒープ割り当て**です。\n\n詳細は[文字列](#language-guide-strings)を参照してください。\n\n### ルーン型\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '🚀';\nlet newline: rune = '\\n';\nlet unicode: rune = '\\u{1F680}';\n```\n\nルーンは**Unicodeコードポイント**（U+0000からU+10FFFF）を表します。\n\n詳細は[ルーン](#language-guide-runes)を参照してください。\n\n### Null型\n\n```hemlock\nlet nothing = null;\nlet uninitialized: string = null;\n```\n\n`null`は単一の値を持つ独自の型です。\n\n## 複合型\n\n### 配列型\n\n```hemlock\nlet numbers: array = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];  // 混合型も可能\nlet empty: array = [];\n```\n\n詳細は[配列](#language-guide-arrays)を参照してください。\n\n### オブジェクト型\n\n```hemlock\nlet obj: object = { x: 10, y: 20 };\nlet person = { name: \"Alice\", age: 30 };\n```\n\n詳細は[オブジェクト](#language-guide-objects)を参照してください。\n\n### ポインタ型\n\n**生ポインタ：**\n```hemlock\nlet p: ptr = alloc(64);\n// 境界チェックなし、手動のライフタイム管理\nfree(p);\n```\n\n**安全なバッファ：**\n```hemlock\nlet buf: buffer = buffer(64);\n// 境界チェック付き、長さと容量を追跡\nfree(buf);\n```\n\n詳細は[メモリ管理](#language-guide-memory)を参照してください。\n\n## 列挙型\n\n列挙型は名前付き定数のセットを定義します：\n\n### 基本的な列挙型\n\n```hemlock\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nlet c = Color.RED;\nprint(c);              // 0\nprint(typeof(c));      // \"Color\"\n\n// 比較\nif (c == Color.RED) {\n    print(\"It's red!\");\n}\n\n// 列挙型でのswitch\nswitch (c) {\n    case Color.RED:\n        print(\"Stop\");\n        break;\n    case Color.GREEN:\n        print(\"Go\");\n        break;\n    case Color.BLUE:\n        print(\"Blue?\");\n        break;\n}\n```\n\n### 値を持つ列挙型\n\n列挙型は明示的な整数値を持つことができます：\n\n```hemlock\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 2\n}\n\nprint(Status.OK);      // 0\nprint(Status.ERROR);   // 1\n\nenum HttpCode {\n    OK = 200,\n    NOT_FOUND = 404,\n    SERVER_ERROR = 500\n}\n\nlet code = HttpCode.NOT_FOUND;\nprint(code);           // 404\n```\n\n### 自動インクリメント値\n\n明示的な値がない場合、列挙型は0から自動インクリメントします：\n\n```hemlock\nenum Priority {\n    LOW,       // 0\n    MEDIUM,    // 1\n    HIGH,      // 2\n    CRITICAL   // 3\n}\n\n// 明示的な値と自動値を混在可能\nenum Level {\n    DEBUG = 10,\n    INFO,      // 11\n    WARN,      // 12\n    ERROR = 50,\n    FATAL      // 51\n}\n```\n\n### 列挙型の使用パターン\n\n```hemlock\n// 関数パラメータとして\nfn set_priority(p: Priority) {\n    if (p == Priority.CRITICAL) {\n        print(\"Urgent!\");\n    }\n}\n\nset_priority(Priority.HIGH);\n\n// オブジェクト内で\ndefine Task {\n    name: string,\n    priority: Priority\n}\n\nlet task: Task = {\n    name: \"Fix bug\",\n    priority: Priority.HIGH\n};\n```\n\n## 特殊型\n\n### ファイル型\n\n```hemlock\nlet f: file = open(\"data.txt\", \"r\");\nf.close();\n```\n\n開いているファイルハンドルを表します。\n\n### タスク型\n\n```hemlock\nasync fn compute(): i32 { return 42; }\nlet task = spawn(compute);\nlet result: i32 = join(task);\n```\n\n非同期タスクハンドルを表します。\n\n### チャネル型\n\n```hemlock\nlet ch: channel = channel(10);\nch.send(42);\nlet value = ch.recv();\n```\n\nタスク間の通信チャネルを表します。\n\n### Void型\n\n```hemlock\nextern fn exit(code: i32): void;\n```\n\n値を返さない関数に使用（FFIのみ）。\n\n## 型推論\n\n### 整数リテラルの推論\n\nHemlockは値の範囲に基づいて整数型を推論します：\n\n```hemlock\nlet a = 42;              // i32（32ビットに収まる）\nlet b = 5000000000;      // i64（> i32 最大値）\nlet c = 128;             // i32\nlet d: u8 = 128;         // u8（明示的な注釈）\n```\n\n**ルール：**\n- i32範囲（-2147483648から2147483647）の値：`i32`と推論\n- i32範囲外だがi64範囲内の値：`i64`と推論\n- 他の型（i8、i16、u8、u16、u32、u64）には明示的な注釈を使用\n\n### 浮動小数点リテラルの推論\n\n```hemlock\nlet x = 3.14;        // f64（デフォルト）\nlet y: f32 = 3.14;   // f32（明示的）\n```\n\n### 指数表記\n\nHemlockは数値リテラルの指数表記をサポートします：\n\n```hemlock\nlet a = 1e10;        // 10000000000.0（f64）\nlet b = 1e-12;       // 0.000000000001（f64）\nlet c = 3.14e2;      // 314.0（f64）\nlet d = 2.5e-3;      // 0.0025（f64）\nlet e = 1E10;        // 大文字小文字を区別しない\nlet f = 1e+5;        // 明示的な正の指数\n```\n\n**注意：** 指数表記を使用するリテラルは常に`f64`と推論されます。\n\n### その他の型推論\n\n```hemlock\nlet s = \"hello\";     // string\nlet ch = 'A';        // rune\nlet flag = true;     // bool\nlet arr = [1, 2, 3]; // array\nlet obj = { x: 10 }; // object\nlet nothing = null;  // null\n```\n\n## 型注釈\n\n### 変数の注釈\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet name: string = \"Alice\";\n```\n\n### 関数パラメータの注釈\n\n```hemlock\nfn greet(name: string, age: i32) {\n    print(\"Hello, \" + name + \"!\");\n}\n```\n\n### 関数戻り値型の注釈\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### オブジェクト型の注釈（ダック型）\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\n```\n\n## 型チェック\n\n### 実行時型チェック\n\n型注釈は**実行時**にチェックされ、コンパイル時ではありません：\n\n```hemlock\nlet x: i32 = 42;     // OK\nlet y: i32 = 3.14;   // 実行時エラー：型不一致\n\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 3);           // OK\nadd(5, \"hello\");     // 実行時エラー：型不一致\n```\n\n### 型クエリ\n\n`typeof()`を使用して値の型をチェックします：\n\n```hemlock\nprint(typeof(42));         // \"i32\"\nprint(typeof(3.14));       // \"f64\"\nprint(typeof(\"hello\"));    // \"string\"\nprint(typeof(true));       // \"bool\"\nprint(typeof(null));       // \"null\"\nprint(typeof([1, 2, 3]));  // \"array\"\nprint(typeof({ x: 10 }));  // \"object\"\n```\n\n## 型変換\n\n### 暗黙の型昇格\n\n演算で型を混在させると、Hemlockは「上位」の型に昇格します：\n\n**昇格階層（低いから高い）：**\n```\ni8 → i16 → i32 → u32 → i64 → u64 → f32 → f64\n      ↑     ↑     ↑\n     u8    u16\n```\n\n**浮動小数点が常に勝つ：**\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // resultはf64（13.5）\n```\n\n**大きいサイズが勝つ：**\n```hemlock\nlet a: i32 = 100;\nlet b: i64 = 200;\nlet sum = a + b;     // sumはi64（300）\n```\n\n**精度の保持：** 64ビット整数とf32を混在させると、Hemlockは精度損失を避けるためにf64に昇格します（f32は24ビットの仮数部しかなく、i64/u64には不十分）：\n```hemlock\nlet big: i64 = 9007199254740993;\nlet small: f32 = 1.0;\nlet result = big + small;  // resultはf64、f32ではない！\n```\n\n**例：**\n```hemlock\nu8 + i32  → i32\ni32 + i64 → i64\nu32 + u64 → u64\ni32 + f32 → f32    // f32はi32に十分\ni64 + f32 → f64    // i64の精度を保持するためにf64が必要\ni64 + f64 → f64\ni8 + f64  → f64\n```\n\n### 明示的な型変換\n\n**整数 ↔ 浮動小数点：**\n```hemlock\nlet i: i32 = 42;\nlet f: f64 = i;      // i32 → f64（42.0）\n\nlet x: f64 = 3.14;\nlet n: i32 = x;      // f64 → i32（3、切り捨て）\n```\n\n**整数 ↔ ルーン：**\n```hemlock\nlet code: i32 = 65;\nlet ch: rune = code;  // i32 → rune（'A'）\n\nlet r: rune = 'Z';\nlet value: i32 = r;   // rune → i32（90）\n```\n\n**ルーン → 文字列：**\n```hemlock\nlet ch: rune = '🚀';\nlet s: string = ch;   // rune → string（\"🚀\"）\n```\n\n**u8 → ルーン：**\n```hemlock\nlet b: u8 = 65;\nlet r: rune = b;      // u8 → rune（'A'）\n```\n\n### 型コンストラクタ関数\n\n型名は値を変換またはパースする関数として使用できます：\n\n**文字列を数値にパース：**\n```hemlock\nlet n = i32(\"42\");       // 文字列をi32にパース：42\nlet f = f64(\"3.14159\");  // 文字列をf64にパース：3.14159\nlet b = bool(\"true\");    // 文字列をboolにパース：true\n\n// すべての数値型をサポート\nlet a = i8(\"-128\");      // i8にパース\nlet c = u8(\"255\");       // u8にパース\nlet d = i16(\"1000\");     // i16にパース\nlet e = u16(\"50000\");    // u16にパース\nlet g = i64(\"9000000000000\"); // i64にパース\nlet h = u64(\"18000000000000\"); // u64にパース\nlet j = f32(\"1.5\");      // f32にパース\n```\n\n**16進数と負数：**\n```hemlock\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\nlet bin = i32(\"0b1010\"); // 10（2進数）\n```\n\n**型エイリアスも動作：**\n```hemlock\nlet x = integer(\"100\");  // i32(\"100\")と同じ\nlet y = number(\"1.5\");   // f64(\"1.5\")と同じ\nlet z = byte(\"200\");     // u8(\"200\")と同じ\n```\n\n**数値型間の変換：**\n```hemlock\nlet big = i64(42);           // i32からi64\nlet truncated = i32(3.99);   // f64からi32（3に切り捨て）\nlet promoted = f64(100);     // i32からf64（100.0）\nlet narrowed = i8(127);      // i32からi8\n```\n\n**型注釈は数値変換を行う（文字列パースは行わない）：**\n```hemlock\nlet f: f64 = 100;        // 注釈によるi32からf64へ（OK）\nlet s: string = 'A';     // 注釈によるルーンから文字列へ（OK）\nlet code: i32 = 'A';     // 注釈によるルーンからi32へ（コードポイントを取得、OK）\n\n// 文字列パースには明示的な型コンストラクタが必要：\nlet n = i32(\"42\");       // 文字列パースには型コンストラクタを使用\n// let x: i32 = \"42\";    // エラー - 型注釈は文字列をパースしない\n```\n\n**エラー処理：**\n```hemlock\n// 無効な文字列は型コンストラクタ使用時にエラーをスロー\nlet bad = i32(\"hello\");  // 実行時エラー：\"hello\"をi32としてパースできない\nlet overflow = u8(\"256\"); // 実行時エラー：256はu8の範囲外\n```\n\n**真偽値のパース：**\n```hemlock\nlet t = bool(\"true\");    // true\nlet f = bool(\"false\");   // false\nlet bad = bool(\"yes\");   // 実行時エラー：\"true\"または\"false\"である必要がある\n```\n\n## 範囲チェック\n\n型注釈は代入時に範囲チェックを強制します：\n\n```hemlock\nlet x: u8 = 255;    // OK\nlet y: u8 = 256;    // エラー：u8の範囲外\n\nlet a: i8 = 127;    // OK\nlet b: i8 = 128;    // エラー：i8の範囲外\n\nlet c: i64 = 2147483647;   // OK\nlet d: u64 = 4294967295;   // OK\nlet e: u64 = -1;           // エラー：u64は負になれない\n```\n\n## 型昇格の例\n\n### 混合整数型\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet sum = a + b;     // i32（30）\n\nlet c: u8 = 100;\nlet d: u32 = 200;\nlet total = c + d;   // u32（300）\n```\n\n### 整数 + 浮動小数点\n\n```hemlock\nlet i: i32 = 5;\nlet f: f32 = 2.5;\nlet result = i * f;  // f32（12.5）\n```\n\n### 複雑な式\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet c: f64 = 3.0;\n\nlet result = a + b * c;  // f64（70.0）\n// 評価：b * c → f64(60.0)\n//       a + f64(60.0) → f64(70.0)\n```\n\n## ダック型（オブジェクト）\n\nオブジェクトは**構造型**（ダック型）を使用します：\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK：必要なフィールドをすべて持っている\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK：余分なフィールドは許可\nlet p2: Person = { name: \"Bob\", age: 25, city: \"NYC\" };\n\n// エラー：'age'フィールドがない\nlet p3: Person = { name: \"Carol\" };\n\n// エラー：'age'の型が違う\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```\n\n**型チェックは代入時に行われる：**\n- すべての必須フィールドが存在することを検証\n- フィールドの型が一致することを検証\n- 余分なフィールドは許可され、保持される\n- `typeof()`用にオブジェクトの型名を設定\n\n## オプションフィールド\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug?: false,     // デフォルト付きオプション\n    timeout?: i32,     // オプション、デフォルトはnull\n}\n\nlet cfg1: Config = { host: \"localhost\", port: 8080 };\nprint(cfg1.debug);    // false（デフォルト）\nprint(cfg1.timeout);  // null\n\nlet cfg2: Config = { host: \"0.0.0.0\", port: 80, debug: true };\nprint(cfg2.debug);    // true（オーバーライド）\n```\n\n## 型エイリアス\n\nHemlockは`type`キーワードを使用したカスタム型エイリアスをサポートします：\n\n### 基本的な型エイリアス\n\n```hemlock\n// シンプルな型エイリアス\ntype Integer = i32;\ntype Text = string;\n\n// エイリアスの使用\nlet x: Integer = 42;\nlet msg: Text = \"hello\";\n```\n\n### 関数型エイリアス\n\n```hemlock\n// 関数型エイリアス\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// 関数型エイリアスの使用\nlet cb: Callback = fn(n) { print(n); };\nlet isEven: Predicate = fn(n) { return n % 2 == 0; };\n```\n\n### 複合型エイリアス\n\n```hemlock\n// 複数のdefineを1つの型に結合\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\ntype Person = HasName & HasAge;\n\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\n### ジェネリック型エイリアス\n\n```hemlock\n// ジェネリック型エイリアス\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// ジェネリックエイリアスの使用\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**注意：** 型エイリアスは透過的です - `typeof()`はエイリアスではなく基底の型名を返します。\n\n## 型システムの制限\n\n現在の制限：\n\n- **関数のジェネリクスなし** - 関数の型パラメータは未サポート\n- **ユニオン型なし** - 「AまたはB」を表現できない\n- **Nullable型なし** - すべての型はnullになりうる（明示的なnullabilityには`?`サフィックスを使用）\n\n**注意：** コンパイラ（`hemlockc`）はコンパイル時型チェックを提供します。インタープリタは実行時型チェックのみを行います。詳細は[コンパイラドキュメント](#design-implementation)を参照してください。\n\n## ベストプラクティス\n\n### 型注釈を使用するタイミング\n\n**注釈を使用するケース：**\n- 正確な型が重要（例：バイト値の`u8`）\n- 関数インターフェースのドキュメント化\n- 制約の強制（例：範囲チェック）\n\n```hemlock\nfn hash(data: buffer, length: u32): u64 {\n    // 実装\n}\n```\n\n**注釈を使用しないケース：**\n- リテラルから型が明らか\n- 内部実装の詳細\n- 不要な形式的記述\n\n```hemlock\n// 不要\nlet x: i32 = 42;\n\n// より良い\nlet x = 42;\n```\n\n### 型安全パターン\n\n**使用前にチェック：**\n```hemlock\nif (typeof(value) == \"i32\") {\n    // i32として安全に使用可能\n}\n```\n\n**関数引数の検証：**\n```hemlock\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" || typeof(b) != \"i32\") {\n        throw \"arguments must be integers\";\n    }\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n```\n\n**柔軟性のためにダック型を使用：**\n```hemlock\ndefine Printable {\n    toString: fn,\n}\n\nfn print_item(item: Printable) {\n    print(item.toString());\n}\n```\n\n## 次のステップ\n\n- [文字列](#language-guide-strings) - UTF-8文字列型と操作\n- [ルーン](#language-guide-runes) - Unicodeコードポイント型\n- [配列](#language-guide-arrays) - 動的配列型\n- [オブジェクト](#language-guide-objects) - オブジェクトリテラルとダック型\n- [メモリ](#language-guide-memory) - ポインタとバッファ型\n"}, "言語ガイド -> 文字列": {"id": "language-guide-strings", "content": "# 文字列\n\nHemlock文字列は、完全なUnicodeサポートとテキスト処理のための豊富なメソッドセットを備えた**UTF-8ファーストクラスのミュータブルシーケンス**です。多くの言語とは異なり、Hemlock文字列はミュータブルで、Unicodeコードポイントとネイティブに連携します。\n\n## 概要\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // ルーンで変更（\"Hello\"になる）\nprint(s.length);        // 5（コードポイント数）\nlet c = s[0];           // ルーン（Unicodeコードポイント）を返す\nlet msg = s + \" world\"; // 連結\nlet emoji = \"🚀\";\nprint(emoji.length);    // 1（1つのコードポイント）\nprint(emoji.byte_length); // 4（4つのUTF-8バイト）\n```\n\n## プロパティ\n\nHemlock文字列の主な特徴：\n\n- **UTF-8エンコード** - 完全なUnicodeサポート（U+0000からU+10FFFF）\n- **ミュータブル** - Python、JavaScript、Java文字列とは異なる\n- **コードポイントベースのインデックス** - バイトではなく`rune`（Unicodeコードポイント）を返す\n- **ヒープ割り当て** - 内部容量追跡付き\n- **2つのlengthプロパティ**：\n  - `.length` - コードポイント数（文字数）\n  - `.byte_length` - バイト数（UTF-8エンコーディングサイズ）\n\n## UTF-8の動作\n\nすべての文字列操作はバイトではなく**コードポイント**（文字）で動作：\n\n```hemlock\nlet text = \"Hello🚀World\";\nprint(text.length);        // 11（コードポイント）\nprint(text.byte_length);   // 15（バイト、絵文字は4バイト）\n\n// インデックスはコードポイントを使用\nlet h = text[0];           // 'H'（ルーン）\nlet rocket = text[5];      // '🚀'（ルーン）\n```\n\n**マルチバイト文字は1としてカウント：**\n```hemlock\n\"Hello\".length;      // 5\n\"🚀\".length;         // 1（1つの絵文字）\n\"你好\".length;       // 2（2つの中国語文字）\n\"café\".length;       // 4（éは1つのコードポイント）\n```\n\n## 文字列リテラル\n\n```hemlock\n// 基本的な文字列\nlet s1 = \"hello\";\nlet s2 = \"world\";\n\n// エスケープシーケンス付き\nlet s3 = \"Line 1\\nLine 2\\ttabbed\";\nlet s4 = \"Quote: \\\"Hello\\\"\";\nlet s5 = \"Backslash: \\\\\";\n\n// Unicode文字\nlet s6 = \"🚀 Emoji\";\nlet s7 = \"中文字符\";\n```\n\n## テンプレート文字列（文字列補間）\n\n埋め込み式のためにバッククォートを使用：\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\n\n// 基本的な補間\nlet greeting = `Hello, ${name}!`;           // \"Hello, Alice!\"\nlet info = `${name} is ${age} years old`;   // \"Alice is 30 years old\"\n\n// 補間内の式\nlet x = 5;\nlet y = 10;\nlet sum = `${x} + ${y} = ${x + y}`;         // \"5 + 10 = 15\"\n\n// メソッド呼び出し\nlet upper = `Name: ${name.to_upper()}`;     // \"Name: ALICE\"\n\n// ネストされたオブジェクト\nlet person = { name: \"Bob\", city: \"NYC\" };\nlet desc = `${person.name} lives in ${person.city}`;  // \"Bob lives in NYC\"\n\n// 複数行（改行を保持）\nlet multi = `Line 1\nLine 2\nLine 3`;\n```\n\n**テンプレート文字列の機能：**\n- `${...}`内の式は評価されて文字列に変換される\n- 任意の有効な式が使用可能（変数、関数呼び出し、算術）\n- バッククォート文字列は通常の文字列と同じエスケープシーケンスをサポート\n- 連結なしで動的文字列を構築するのに便利\n\n### テンプレート文字列内のエスケープ\n\nテンプレート文字列にリテラルの`${`を含めるには、ドル記号をエスケープ：\n\n```hemlock\nlet price = 100;\nlet text = `Price: \\${price} or ${price}`;\n// \"Price: ${price} or 100\"\n\n// リテラルのバッククォート\nlet code = `Use \\` for template strings`;\n// \"Use ` for template strings\"\n```\n\n### 複雑な式\n\nテンプレート文字列には任意の有効な式を含めることが可能：\n\n```hemlock\n// 三項演算子のような式\nlet age = 25;\nlet status = `Status: ${age >= 18 ? \"adult\" : \"minor\"}`;\n\n// 配列アクセス\nlet items = [\"apple\", \"banana\", \"cherry\"];\nlet first = `First item: ${items[0]}`;\n\n// 引数付き関数呼び出し\nfn format_price(p) { return \"$\" + p; }\nlet msg = `Total: ${format_price(99.99)}`;  // \"Total: $99.99\"\n\n// チェーンメソッド呼び出し\nlet name = \"alice\";\nlet formatted = `Hello, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;\n// \"Hello, Alice!\"\n```\n\n### テンプレート文字列 vs 連結\n\nテンプレート文字列は連結より読みやすいことが多い：\n\n```hemlock\n// 連結（読みにくい）\nlet msg1 = \"Hello, \" + name + \"! You have \" + count + \" messages.\";\n\n// テンプレート文字列（読みやすい）\nlet msg2 = `Hello, ${name}! You have ${count} messages.`;\n```\n\n## インデックスと変更\n\n### 文字の読み取り\n\nインデックスは`rune`（Unicodeコードポイント）を返す：\n\n```hemlock\nlet s = \"Hello\";\nlet first = s[0];      // 'H'（ルーン）\nlet last = s[4];       // 'o'（ルーン）\n\n// UTF-8の例\nlet emoji = \"Hi🚀!\";\nlet rocket = emoji[2];  // '🚀'（コードポイントインデックス2のルーン）\n```\n\n### 文字の書き込み\n\n文字列はミュータブル - 個々の文字を変更可能：\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';            // \"Hello\"になる\ns[4] = '!';            // \"Hell!\"になる\n\n// Unicodeで\nlet msg = \"Go!\";\nmsg[0] = '🚀';         // \"🚀o!\"になる\n```\n\n## 連結\n\n`+`を使用して文字列を連結：\n\n```hemlock\nlet greeting = \"Hello\" + \" \" + \"World\";  // \"Hello World\"\n\n// 変数で\nlet name = \"Alice\";\nlet msg = \"Hi, \" + name + \"!\";  // \"Hi, Alice!\"\n\n// ルーンと（ルーンのドキュメントを参照）\nlet s = \"Hello\" + '!';          // \"Hello!\"\n```\n\n## 文字列メソッド\n\nHemlockは包括的なテキスト操作のための19個の文字列メソッドを提供します。\n\n### 部分文字列とスライス\n\n**`substr(start, length)`** - 位置と長さで部分文字列を抽出：\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\"（6から始めて長さ5）\nlet first = s.substr(0, 5);     // \"hello\"\n\n// UTF-8の例\nlet text = \"Hi🚀!\";\nlet emoji = text.substr(2, 1);  // \"🚀\"（位置2、長さ1）\n```\n\n**`slice(start, end)`** - 範囲で部分文字列を抽出（endを含まない）：\n```hemlock\nlet s = \"hello world\";\nlet slice = s.slice(0, 5);      // \"hello\"（インデックス0から4）\nlet slice2 = s.slice(6, 11);    // \"world\"\n```\n\n**違い：**\n- `substr(start, length)` - 長さパラメータを使用\n- `slice(start, end)` - 終了インデックスを使用（含まない）\n\n### 検索\n\n**`find(needle)`** - 最初の出現位置を検索：\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6（最初の出現のインデックス）\nlet pos2 = s.find(\"foo\");       // -1（見つからない）\nlet pos3 = s.find(\"l\");         // 2（最初の'l'）\n```\n\n**`contains(needle)`** - 文字列が部分文字列を含むかチェック：\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n### 分割とトリム\n\n**`split(delimiter)`** - 文字列の配列に分割：\n```hemlock\nlet csv = \"apple,banana,cherry\";\nlet parts = csv.split(\",\");     // [\"apple\", \"banana\", \"cherry\"]\n\nlet words = \"one two three\".split(\" \");  // [\"one\", \"two\", \"three\"]\n\n// 空の区切り文字は文字ごとに分割\nlet chars = \"abc\".split(\"\");    // [\"a\", \"b\", \"c\"]\n```\n\n**`trim()`** - 先頭と末尾の空白を削除：\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet s2 = \"\\t\\ntext\\n\\t\";\nlet clean2 = s2.trim();         // \"text\"\n```\n\n### 大文字小文字変換\n\n**`to_upper()`** - 大文字に変換：\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\n// 非ASCIIを保持\nlet s2 = \"café\";\nlet upper2 = s2.to_upper();     // \"CAFÉ\"\n```\n\n**`to_lower()`** - 小文字に変換：\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n```\n\n### 接頭辞/接尾辞チェック\n\n**`starts_with(prefix)`** - 接頭辞で始まるかチェック：\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n**`ends_with(suffix)`** - 接尾辞で終わるかチェック：\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n### 置換\n\n**`replace(old, new)`** - 最初の出現を置換：\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");      // \"hello there\"\n\nlet s3 = \"foo foo foo\";\nlet s4 = s3.replace(\"foo\", \"bar\");         // \"bar foo foo\"（最初のみ）\n```\n\n**`replace_all(old, new)`** - すべての出現を置換：\n```hemlock\nlet s = \"foo foo foo\";\nlet s2 = s.replace_all(\"foo\", \"bar\");      // \"bar bar bar\"\n\nlet s3 = \"hello world, world!\";\nlet s4 = s3.replace_all(\"world\", \"hemlock\"); // \"hello hemlock, hemlock!\"\n```\n\n### 繰り返し\n\n**`repeat(count)`** - 文字列をn回繰り返す：\n```hemlock\nlet s = \"ha\";\nlet laugh = s.repeat(3);        // \"hahaha\"\n\nlet line = \"=\".repeat(40);      // \"========================================\"\n```\n\n### 文字とバイトアクセス\n\n**`char_at(index)`** - インデックスのUnicodeコードポイントを取得（ルーンを返す）：\n```hemlock\nlet s = \"hello\";\nlet char = s.char_at(0);        // 'h'（ルーン）\n\n// UTF-8の例\nlet emoji = \"🚀\";\nlet rocket = emoji.char_at(0);  // ルーン U+1F680を返す\n```\n\n**`chars()`** - ルーン（コードポイント）の配列に変換：\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']（ルーンの配列）\n\n// UTF-8の例\nlet text = \"Hi🚀\";\nlet chars2 = text.chars();      // ['H', 'i', '🚀']\n```\n\n**`byte_at(index)`** - インデックスのバイト値を取得（u8を返す）：\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104（'h'のASCII値）\n\n// UTF-8の例\nlet emoji = \"🚀\";\nlet first_byte = emoji.byte_at(0);  // 240（最初のUTF-8バイト）\n```\n\n**`bytes()`** - バイト（u8値）の配列に変換：\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111]（u8の配列）\n\n// UTF-8の例\nlet emoji = \"🚀\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128]（4つのUTF-8バイト）\n```\n\n**`to_bytes()`** - 低レベルアクセス用にバッファに変換：\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();         // UTF-8バイトのバッファを返す\nprint(buf.length);              // 5\nfree(buf);                      // 解放を忘れずに\n```\n\n## メソッドチェーン\n\nすべての文字列メソッドは新しい文字列を返すため、チェーンが可能：\n\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \")\n    .to_upper();                    // \"FOO | BAR | BAZ\"\n```\n\n## 完全なメソッドリファレンス\n\n| メソッド | パラメータ | 戻り値 | 説明 |\n|--------|-----------|---------|-------------|\n| `substr(start, length)` | i32, i32 | string | 位置と長さで部分文字列を抽出 |\n| `slice(start, end)` | i32, i32 | string | 範囲で部分文字列を抽出（endを含まない） |\n| `find(needle)` | string | i32 | 最初の出現を検索（見つからない場合-1） |\n| `contains(needle)` | string | bool | 部分文字列を含むかチェック |\n| `split(delimiter)` | string | array | 文字列の配列に分割 |\n| `trim()` | - | string | 先頭と末尾の空白を削除 |\n| `to_upper()` | - | string | 大文字に変換 |\n| `to_lower()` | - | string | 小文字に変換 |\n| `starts_with(prefix)` | string | bool | 接頭辞で始まるかチェック |\n| `ends_with(suffix)` | string | bool | 接尾辞で終わるかチェック |\n| `replace(old, new)` | string, string | string | 最初の出現を置換 |\n| `replace_all(old, new)` | string, string | string | すべての出現を置換 |\n| `repeat(count)` | i32 | string | 文字列をn回繰り返す |\n| `char_at(index)` | i32 | rune | インデックスのコードポイントを取得 |\n| `byte_at(index)` | i32 | u8 | インデックスのバイト値を取得 |\n| `chars()` | - | array | ルーンの配列に変換 |\n| `bytes()` | - | array | u8バイトの配列に変換 |\n| `to_bytes()` | - | buffer | バッファに変換（解放必須） |\n\n## 例\n\n### 例：テキスト処理\n\n```hemlock\nfn process_input(text: string): string {\n    return text\n        .trim()\n        .to_lower()\n        .replace_all(\"  \", \" \");  // 空白を正規化\n}\n\nlet input = \"  HELLO   WORLD  \";\nlet clean = process_input(input);  // \"hello world\"\n```\n\n### 例：CSVパーサー\n\n```hemlock\nfn parse_csv_line(line: string): array {\n    let trimmed = line.trim();\n    let fields = trimmed.split(\",\");\n\n    let result = [];\n    let i = 0;\n    while (i < fields.length) {\n        result.push(fields[i].trim());\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet csv = \"apple, banana , cherry\";\nlet fields = parse_csv_line(csv);  // [\"apple\", \"banana\", \"cherry\"]\n```\n\n### 例：単語カウンター\n\n```hemlock\nfn count_words(text: string): i32 {\n    let words = text.trim().split(\" \");\n    return words.length;\n}\n\nlet sentence = \"The quick brown fox\";\nlet count = count_words(sentence);  // 4\n```\n\n### 例：文字列検証\n\n```hemlock\nfn is_valid_email(email: string): bool {\n    if (!email.contains(\"@\")) {\n        return false;\n    }\n\n    if (!email.contains(\".\")) {\n        return false;\n    }\n\n    if (email.starts_with(\"@\") || email.ends_with(\"@\")) {\n        return false;\n    }\n\n    return true;\n}\n\nprint(is_valid_email(\"user@example.com\"));  // true\nprint(is_valid_email(\"invalid\"));            // false\n```\n\n## メモリ管理\n\n文字列は内部参照カウントでヒープ割り当て：\n\n- **作成**：容量追跡付きでヒープに割り当て\n- **連結**：新しい文字列を作成（古い文字列は変更されない）\n- **メソッド**：ほとんどのメソッドは新しい文字列を返す\n- **寿命**：文字列は参照カウントされスコープを抜けると自動的に解放\n\n**自動クリーンアップ：**\n```hemlock\nfn create_strings() {\n    let s = \"hello\";\n    let s2 = s + \" world\";  // 新しい割り当て\n}  // 関数が戻るとsとs2の両方が自動的に解放\n```\n\n**注意：** ローカル文字列変数はスコープを抜けると自動的にクリーンアップされます。`free()`はスコープ終了前の早期クリーンアップや長期間存続する/グローバルデータにのみ使用してください。詳細は[メモリ管理](memory.md#internal-reference-counting)を参照してください。\n\n## ベストプラクティス\n\n1. **コードポイントインデックスを使用** - 文字列はバイトオフセットではなくコードポイント位置を使用\n2. **Unicodeでテスト** - 常にマルチバイト文字で文字列操作をテスト\n3. **イミュータブル操作を優先** - 変更より新しい文字列を返すメソッドを使用\n4. **境界をチェック** - 文字列のインデックスは境界チェックしない（無効時はnull/エラー）\n5. **入力を正規化** - ユーザー入力には`trim()`と`to_lower()`を使用\n\n## よくある落とし穴\n\n### 落とし穴：バイト vs コードポイントの混乱\n\n```hemlock\nlet emoji = \"🚀\";\nprint(emoji.length);        // 1（コードポイント）\nprint(emoji.byte_length);   // 4（バイト）\n\n// バイトとコードポイントの操作を混ぜない\nlet byte = emoji.byte_at(0);  // 240（最初のバイト）\nlet char = emoji.char_at(0);  // '🚀'（完全なコードポイント）\n```\n\n### 落とし穴：変更のサプライズ\n\n```hemlock\nlet s1 = \"hello\";\nlet s2 = s1;       // 浅いコピー\ns1[0] = 'H';       // s1を変更\nprint(s2);         // まだ\"hello\"（文字列は値型）\n```\n\n## 関連トピック\n\n- [ルーン](#language-guide-runes) - 文字列インデックスで使用されるUnicodeコードポイント型\n- [配列](#language-guide-arrays) - 文字列メソッドは配列と連携することが多い\n- [型](#language-guide-types) - 文字列型の詳細と変換\n\n## 参照\n\n- **UTF-8エンコーディング**：CLAUDE.mdの「Strings」セクションを参照\n- **型変換**：文字列変換については[型](#language-guide-types)を参照\n- **メモリ**：文字列割り当ての詳細は[メモリ](#language-guide-memory)を参照\n"}, "言語ガイド -> 構文": {"id": "language-guide-syntax", "content": "# 構文の概要\n\nこのドキュメントでは、Hemlockプログラムの基本的な構文規則と構造について説明します。\n\n## コア構文規則\n\n### セミコロンは必須\n\nJavaScriptやPythonとは異なり、セミコロンは文の末尾で**常に必須**です：\n\n```hemlock\nlet x = 42;\nlet y = 10;\nprint(x + y);\n```\n\n**これはエラーになります：**\n```hemlock\nlet x = 42  // エラー：セミコロンがない\nlet y = 10  // エラー：セミコロンがない\n```\n\n### ブレースは常に必須\n\nすべての制御フローブロックは、単一の文でもブレースを使用する必要があります：\n\n```hemlock\n// 正しい\nif (x > 0) {\n    print(\"positive\");\n}\n\n// エラー：ブレースがない\nif (x > 0)\n    print(\"positive\");\n```\n\n### コメント\n\n```hemlock\n// これは単一行コメント\n\n/*\n   これは\n   複数行コメント\n*/\n\nlet x = 42;  // インラインコメント\n```\n\n## 変数\n\n### 宣言\n\n変数は`let`で宣言：\n\n```hemlock\nlet count = 0;\nlet name = \"Alice\";\nlet pi = 3.14159;\n```\n\n### 型注釈（オプション）\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet flag: bool = true;\nlet text: string = \"hello\";\n```\n\n### 定数\n\nイミュータブルな値には`const`を使用：\n\n```hemlock\nconst MAX_SIZE: i32 = 1000;\nconst PI: f64 = 3.14159;\n```\n\nconstを再代入しようとすると実行時エラーになります：「Cannot assign to const variable」。\n\n## 式\n\n### 算術演算子\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13 - 加算\nprint(a - b);   // 7  - 減算\nprint(a * b);   // 30 - 乗算\nprint(a / b);   // 3  - 除算（整数）\n```\n\n### 比較演算子\n\n```hemlock\nprint(a == b);  // false - 等しい\nprint(a != b);  // true  - 等しくない\nprint(a > b);   // true  - より大きい\nprint(a < b);   // false - より小さい\nprint(a >= b);  // true  - 以上\nprint(a <= b);  // false - 以下\n```\n\n### 論理演算子\n\n```hemlock\nlet x = true;\nlet y = false;\n\nprint(x && y);  // false - AND\nprint(x || y);  // true  - OR\nprint(!x);      // false - NOT\n```\n\n### ビット演算子\n\n```hemlock\nlet a = 12;  // 1100\nlet b = 10;  // 1010\n\nprint(a & b);   // 8  - ビットAND\nprint(a | b);   // 14 - ビットOR\nprint(a ^ b);   // 6  - ビットXOR\nprint(a << 2);  // 48 - 左シフト\nprint(a >> 1);  // 6  - 右シフト\nprint(~a);      // -13 - ビットNOT\n```\n\n### 演算子の優先順位\n\n最高から最低：\n\n1. `()` - グループ化\n2. `!`、`~`、`-`（単項） - 単項演算子\n3. `*`、`/` - 乗算、除算\n4. `+`、`-` - 加算、減算\n5. `<<`、`>>` - ビットシフト\n6. `<`、`<=`、`>`、`>=` - 比較\n7. `==`、`!=` - 等価\n8. `&` - ビットAND\n9. `^` - ビットXOR\n10. `|` - ビットOR\n11. `&&` - 論理AND\n12. `||` - 論理OR\n\n**例：**\n```hemlock\nlet x = 2 + 3 * 4;      // 14（20ではない）\nlet y = (2 + 3) * 4;    // 20\nlet z = 5 << 2 + 1;     // 40（5 << 3）\n```\n\n## 制御フロー\n\n### If文\n\n```hemlock\nif (condition) {\n    // 本体\n}\n\nif (condition) {\n    // thenブランチ\n} else {\n    // elseブランチ\n}\n\nif (condition1) {\n    // ブランチ1\n} else if (condition2) {\n    // ブランチ2\n} else {\n    // デフォルトブランチ\n}\n```\n\n### Whileループ\n\n```hemlock\nwhile (condition) {\n    // 本体\n}\n```\n\n**例：**\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n### Forループ\n\n**Cスタイルfor：**\n```hemlock\nfor (initializer; condition; increment) {\n    // 本体\n}\n```\n\n**例：**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**For-in（配列）：**\n```hemlock\nfor (let item in array) {\n    // 本体\n}\n```\n\n**例：**\n```hemlock\nlet items = [10, 20, 30];\nfor (let x in items) {\n    print(x);\n}\n```\n\n### Switch文\n\n```hemlock\nswitch (expression) {\n    case value1:\n        // 本体\n        break;\n    case value2:\n        // 本体\n        break;\n    default:\n        // デフォルト本体\n        break;\n}\n```\n\n**例：**\n```hemlock\nlet day = 3;\nswitch (day) {\n    case 1:\n        print(\"Monday\");\n        break;\n    case 2:\n        print(\"Tuesday\");\n        break;\n    case 3:\n        print(\"Wednesday\");\n        break;\n    default:\n        print(\"Other\");\n        break;\n}\n```\n\n### BreakとContinue\n\n```hemlock\n// Break：ループを終了\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n}\n\n// Continue：次の反復にスキップ\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;\n    }\n    print(i);\n}\n```\n\n## 関数\n\n### 名前付き関数\n\n```hemlock\nfn function_name(param1: type1, param2: type2): return_type {\n    // 本体\n    return value;\n}\n```\n\n**例：**\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### 無名関数\n\n```hemlock\nlet func = fn(params) {\n    // 本体\n};\n```\n\n**例：**\n```hemlock\nlet multiply = fn(x, y) {\n    return x * y;\n};\n```\n\n### 型注釈（オプション）\n\n```hemlock\n// 注釈なし（型推論）\nfn greet(name) {\n    return \"Hello, \" + name;\n}\n\n// 注釈付き（実行時にチェック）\nfn divide(a: i32, b: i32): f64 {\n    return a / b;\n}\n```\n\n## オブジェクト\n\n### オブジェクトリテラル\n\n```hemlock\nlet obj = {\n    field1: value1,\n    field2: value2,\n};\n```\n\n**例：**\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    active: true,\n};\n```\n\n### メソッド\n\n```hemlock\nlet obj = {\n    method: fn() {\n        self.field = value;\n    },\n};\n```\n\n**例：**\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n};\n```\n\n### 型定義\n\n```hemlock\ndefine TypeName {\n    field1: type1,\n    field2: type2,\n    optional_field?: default_value,\n}\n```\n\n**例：**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,\n}\n```\n\n## 配列\n\n### 配列リテラル\n\n```hemlock\nlet arr = [element1, element2, element3];\n```\n\n**例：**\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];\nlet empty = [];\n```\n\n### 配列のインデックス\n\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);   // 10\narr[1] = 99;     // 要素を変更\n```\n\n## エラーハンドリング\n\n### Try/Catch\n\n```hemlock\ntry {\n    // 危険なコード\n} catch (e) {\n    // エラーを処理\n}\n```\n\n### Try/Finally\n\n```hemlock\ntry {\n    // 危険なコード\n} finally {\n    // 常に実行\n}\n```\n\n### Try/Catch/Finally\n\n```hemlock\ntry {\n    // 危険なコード\n} catch (e) {\n    // エラーを処理\n} finally {\n    // クリーンアップ\n}\n```\n\n### Throw\n\n```hemlock\nthrow expression;\n```\n\n**例：**\n```hemlock\nif (x < 0) {\n    throw \"x must be positive\";\n}\n```\n\n### Panic\n\n```hemlock\npanic(message);\n```\n\n**例：**\n```hemlock\npanic(\"unrecoverable error\");\n```\n\n## モジュール（実験的）\n\n### Export文\n\n```hemlock\nexport fn function_name() { }\nexport const CONSTANT = value;\nexport let variable = value;\nexport { name1, name2 };\n```\n\n### Import文\n\n```hemlock\nimport { name1, name2 } from \"./module.hml\";\nimport * as namespace from \"./module.hml\";\nimport { name as alias } from \"./module.hml\";\n```\n\n## 非同期（実験的）\n\n### 非同期関数\n\n```hemlock\nasync fn function_name(params): return_type {\n    // 本体\n}\n```\n\n### Spawn/Join\n\n```hemlock\nlet task = spawn(async_function, arg1, arg2);\nlet result = join(task);\n```\n\n### チャネル\n\n```hemlock\nlet ch = channel(capacity);\nch.send(value);\nlet value = ch.recv();\nch.close();\n```\n\n## FFI（外部関数インターフェース）\n\n### 共有ライブラリのインポート\n\n```hemlock\nimport \"library_name.so\";\n```\n\n### 外部関数の宣言\n\n```hemlock\nextern fn function_name(param: type): return_type;\n```\n\n**例：**\n```hemlock\nimport \"libc.so.6\";\nextern fn strlen(s: string): i32;\n```\n\n## リテラル\n\n### 整数リテラル\n\n```hemlock\nlet decimal = 42;\nlet negative = -100;\nlet large = 5000000000;  // 自動的にi64\n\n// 16進数（0xプレフィックス）\nlet hex = 0xDEADBEEF;\nlet hex2 = 0xFF;\n\n// 2進数（0bプレフィックス）\nlet bin = 0b1010;\nlet bin2 = 0b11110000;\n\n// 8進数（0oプレフィックス）\nlet oct = 0o777;\nlet oct2 = 0O123;\n\n// 読みやすさのための数値セパレータ\nlet million = 1_000_000;\nlet hex_sep = 0xFF_FF_FF;\nlet bin_sep = 0b1111_0000_1010_0101;\nlet oct_sep = 0o77_77;\n```\n\n### 浮動小数点リテラル\n\n```hemlock\nlet f = 3.14;\nlet e = 2.71828;\nlet sci = 1.5e-10;       // 指数表記\nlet sci2 = 2.5E+3;       // 大文字Eも動作\nlet no_lead = .5;        // 先頭のゼロなし（0.5）\nlet sep = 3.14_159_265;  // 数値セパレータ\n```\n\n### 文字列リテラル\n\n```hemlock\nlet s = \"hello\";\nlet escaped = \"line1\\nline2\\ttabbed\";\nlet quote = \"She said \\\"hello\\\"\";\n\n// 16進エスケープシーケンス\nlet hex_esc = \"\\x48\\x65\\x6c\\x6c\\x6f\";  // \"Hello\"\n\n// Unicodeエスケープシーケンス\nlet emoji = \"\\u{1F600}\";               // 😀\nlet heart = \"\\u{2764}\";                // ❤\nlet mixed = \"Hello \\u{1F30D}!\";        // Hello 🌍!\n```\n\n**エスケープシーケンス：**\n- `\\n` - 改行\n- `\\t` - タブ\n- `\\r` - キャリッジリターン\n- `\\\\` - バックスラッシュ\n- `\\\"` - ダブルクォート\n- `\\'` - シングルクォート\n- `\\0` - ヌル文字\n- `\\xNN` - 16進エスケープ（2桁）\n- `\\u{XXXX}` - Unicodeエスケープ（1-6桁）\n\n### ルーンリテラル\n\n```hemlock\nlet ch = 'A';\nlet emoji = '🚀';\nlet escaped = '\\n';\nlet unicode = '\\u{1F680}';\nlet hex_rune = '\\x41';      // 'A'\n```\n\n### 真偽値リテラル\n\n```hemlock\nlet t = true;\nlet f = false;\n```\n\n### Nullリテラル\n\n```hemlock\nlet nothing = null;\n```\n\n## スコープルール\n\n### ブロックスコープ\n\n変数は最も近い囲んでいるブロックにスコープされます：\n\n```hemlock\nlet x = 1;  // 外側のスコープ\n\nif (true) {\n    let x = 2;  // 内側のスコープ（外側をシャドウ）\n    print(x);   // 2\n}\n\nprint(x);  // 1\n```\n\n### 関数スコープ\n\n関数は独自のスコープを作成します：\n\n```hemlock\nlet global = \"global\";\n\nfn foo() {\n    let local = \"local\";\n    print(global);  // 外側のスコープを読める\n}\n\nfoo();\n// print(local);  // エラー：'local'はここで定義されていない\n```\n\n### クロージャスコープ\n\nクロージャは囲んでいるスコープの変数をキャプチャします：\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // 'count'をキャプチャ\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\n```\n\n## 空白とフォーマット\n\n### インデント\n\nHemlockは特定のインデントを強制しませんが、4スペースを推奨：\n\n```hemlock\nfn example() {\n    if (true) {\n        print(\"indented\");\n    }\n}\n```\n\n### 改行\n\n文は複数行にまたがることができます：\n\n```hemlock\nlet result =\n    very_long_function_name(\n        arg1,\n        arg2,\n        arg3\n    );\n```\n\n## Loop文\n\n`loop`キーワードは無限ループのためのよりクリーンな構文を提供します：\n\n```hemlock\nloop {\n    // ... 処理を行う\n    if (done) {\n        break;\n    }\n}\n```\n\nこれは`while (true)`と等価ですが、意図がより明確です。\n\n## 予約キーワード\n\n以下のキーワードはHemlockで予約されています：\n\n```\nlet, const, fn, if, else, while, for, in, loop, break, continue,\nreturn, true, false, null, typeof, import, export, from,\ntry, catch, finally, throw, panic, async, await, spawn, join,\ndetach, channel, define, switch, case, default, extern, self,\ntype, defer, enum, ref, buffer, Self\n```\n\n## 次のステップ\n\n- [型システム](#language-guide-types) - Hemlockの型システムを学ぶ\n- [制御フロー](#language-guide-control-flow) - 制御構造の詳細\n- [関数](#language-guide-functions) - 関数とクロージャをマスター\n- [メモリ管理](#language-guide-memory) - ポインタとバッファを理解\n"}, "言語ガイド -> 配列": {"id": "language-guide-arrays", "content": "# 配列\n\nHemlockは、データ操作と処理のための包括的なメソッドを備えた**動的配列**を提供します。配列は混合型を保持でき、必要に応じて自動的に拡張されます。\n\n## 概要\n\n```hemlock\n// 配列リテラル\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// 混合型を許可\nlet mixed = [1, \"hello\", true, null];\n\n// 動的サイズ変更\narr.push(6);           // 自動的に拡張\narr.push(7);\nprint(arr.length);     // 7\n```\n\n## 配列リテラル\n\n### 基本構文\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet strings = [\"apple\", \"banana\", \"cherry\"];\nlet booleans = [true, false, true];\n```\n\n### 空の配列\n\n```hemlock\nlet arr = [];  // 空の配列\n\n// 後で要素を追加\narr.push(1);\narr.push(2);\narr.push(3);\n```\n\n### 混合型\n\n配列は異なる型を含むことができます：\n\n```hemlock\nlet mixed = [\n    42,\n    \"hello\",\n    true,\n    null,\n    [1, 2, 3],\n    { x: 10, y: 20 }\n];\n\nprint(mixed[0]);  // 42\nprint(mixed[1]);  // \"hello\"\nprint(mixed[4]);  // [1, 2, 3]（ネストされた配列）\n```\n\n### ネストされた配列\n\n```hemlock\nlet matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\nprint(matrix[0][0]);  // 1\nprint(matrix[1][2]);  // 6\nprint(matrix[2][1]);  // 8\n```\n\n### 型付き配列\n\n配列には要素の型を強制する型注釈を付けることができます：\n\n```hemlock\n// 型付き配列の構文\nlet nums: array<i32> = [1, 2, 3, 4, 5];\nlet names: array<string> = [\"Alice\", \"Bob\", \"Carol\"];\nlet flags: array<bool> = [true, false, true];\n\n// 実行時の型チェック\nlet valid: array<i32> = [1, 2, 3];       // OK\nlet invalid: array<i32> = [1, \"two\", 3]; // 実行時エラー：型の不一致\n\n// ネストされた型付き配列\nlet matrix: array<array<i32>> = [\n    [1, 2, 3],\n    [4, 5, 6]\n];\n```\n\n**型注釈の動作：**\n- 要素は配列に追加される際に型チェックされます\n- 型の不一致は実行時エラーを引き起こします\n- 型注釈がない場合、配列は混合型を受け入れます\n\n## インデックス\n\n### 要素の読み取り\n\nゼロインデックスアクセス：\n\n```hemlock\nlet arr = [10, 20, 30, 40, 50];\n\nprint(arr[0]);  // 10（最初の要素）\nprint(arr[4]);  // 50（最後の要素）\n\n// 範囲外はnullを返す（エラーなし）\nprint(arr[10]);  // null\n```\n\n### 要素の書き込み\n\n```hemlock\nlet arr = [1, 2, 3];\n\narr[0] = 10;    // 既存を変更\narr[1] = 20;\nprint(arr);     // [10, 20, 3]\n\n// 現在の長さを超えて代入可能（配列を拡張）\narr[5] = 60;    // [10, 20, 3, null, null, 60]を作成\n```\n\n### 負のインデックス\n\n**サポートされていません** - 正のインデックスのみを使用：\n\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr[-1]);  // エラーまたは未定義動作\n\n// 最後の要素にはlengthを使用\nprint(arr[arr.length - 1]);  // 3\n```\n\n## プロパティ\n\n### `.length`プロパティ\n\n要素数を返します：\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);  // 5\n\n// 空の配列\nlet empty = [];\nprint(empty.length);  // 0\n\n// 変更後\narr.push(6);\nprint(arr.length);  // 6\n```\n\n## 配列メソッド\n\nHemlockは包括的な操作のための18個の配列メソッドを提供します。\n\n### スタック操作\n\n**`push(value)`** - 末尾に要素を追加：\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\n\nprint(arr.length);     // 5\n```\n\n**`pop()`** - 最後の要素を削除して返す：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet last = arr.pop();  // 5を返し、arrは[1, 2, 3, 4]になる\n\nprint(last);           // 5\nprint(arr.length);     // 4\n```\n\n### キュー操作\n\n**`shift()`** - 最初の要素を削除して返す：\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();   // 1を返し、arrは[2, 3]になる\n\nprint(first);              // 1\nprint(arr);                // [2, 3]\n```\n\n**`unshift(value)`** - 先頭に要素を追加：\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);            // [1, 2, 3]\narr.unshift(0);            // [0, 1, 2, 3]\n```\n\n### 挿入と削除\n\n**`insert(index, value)`** - インデックス位置に要素を挿入：\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // インデックス2に3を挿入：[1, 2, 3, 4, 5]\n\narr.insert(0, 0);      // 先頭に挿入：[0, 1, 2, 3, 4, 5]\n```\n\n**`remove(index)`** - インデックス位置の要素を削除して返す：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(2);  // 3を返し、arrは[1, 2, 4, 5]になる\n\nprint(removed);               // 3\nprint(arr);                   // [1, 2, 4, 5]\n```\n\n### 検索操作\n\n**`find(value)`** - 最初の出現位置を検索：\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2（最初の出現のインデックス）\nlet idx2 = arr.find(99);     // -1（見つからない）\n\n// 任意の型で動作\nlet words = [\"apple\", \"banana\", \"cherry\"];\nlet idx3 = words.find(\"banana\");  // 1\n```\n\n**`contains(value)`** - 配列に値が含まれるか確認：\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n```\n\n### 抽出操作\n\n**`slice(start, end)`** - 部分配列を抽出（endは含まない）：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4]（インデックス1, 2, 3）\nlet first = arr.slice(0, 2); // [1, 2]\n\n// 元の配列は変更されない\nprint(arr);                  // [1, 2, 3, 4, 5]\n```\n\n**`first()`** - 最初の要素を取得（削除せずに）：\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1（削除せずに）\nprint(arr);                  // [1, 2, 3]（変更なし）\n```\n\n**`last()`** - 最後の要素を取得（削除せずに）：\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3（削除せずに）\nprint(arr);                  // [1, 2, 3]（変更なし）\n```\n\n### 変換操作\n\n**`reverse()`** - 配列をその場で反転：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\n\nprint(arr);                  // [5, 4, 3, 2, 1]（変更された）\n```\n\n**`join(delimiter)`** - 要素を文字列に結合：\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// 混合型でも動作\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n```\n\n**`concat(other)`** - 別の配列と連結：\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]（新しい配列）\n\n// 元の配列は変更されない\nprint(a);                    // [1, 2, 3]\nprint(b);                    // [4, 5, 6]\n```\n\n### ユーティリティ操作\n\n**`clear()`** - すべての要素を削除：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();                 // []\n\nprint(arr.length);           // 0\nprint(arr);                  // []\n```\n\n## メソッドチェーン\n\n配列や値を返すメソッドはチェーンが可能です：\n\n```hemlock\nlet result = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);  // [3, 4, 5]\n\nlet text = [\"apple\", \"banana\", \"cherry\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\nlet numbers = [5, 3, 8, 1, 9]\n    .slice(1, 4)\n    .concat([10, 11]);  // [3, 8, 1, 10, 11]\n```\n\n## 完全なメソッドリファレンス\n\n| メソッド | パラメータ | 戻り値 | 変更 | 説明 |\n|--------|-----------|---------|---------|-------------|\n| `push(value)` | any | void | はい | 末尾に要素を追加 |\n| `pop()` | - | any | はい | 最後を削除して返す |\n| `shift()` | - | any | はい | 最初を削除して返す |\n| `unshift(value)` | any | void | はい | 先頭に要素を追加 |\n| `insert(index, value)` | i32, any | void | はい | インデックス位置に挿入 |\n| `remove(index)` | i32 | any | はい | インデックス位置を削除して返す |\n| `find(value)` | any | i32 | いいえ | 最初の出現位置を検索（見つからない場合-1） |\n| `contains(value)` | any | bool | いいえ | 値が含まれるか確認 |\n| `slice(start, end)` | i32, i32 | array | いいえ | 部分配列を抽出（新しい配列） |\n| `join(delimiter)` | string | string | いいえ | 文字列に結合 |\n| `concat(other)` | array | array | いいえ | 連結（新しい配列） |\n| `reverse()` | - | void | はい | その場で反転 |\n| `first()` | - | any | いいえ | 最初の要素を取得 |\n| `last()` | - | any | いいえ | 最後の要素を取得 |\n| `clear()` | - | void | はい | すべての要素を削除 |\n| `map(callback)` | fn | array | いいえ | 各要素を変換 |\n| `filter(predicate)` | fn | array | いいえ | 条件に一致する要素を選択 |\n| `reduce(callback, initial)` | fn, any | any | いいえ | 単一の値に畳み込み |\n\n## 実装の詳細\n\n### メモリモデル\n\n- **ヒープ割り当て** - 動的容量\n- **自動拡張** - 容量を超えると2倍に拡張\n- **自動縮小なし** - 容量は減少しない\n- **インデックスの境界チェックなし** - 安全のためにはメソッドを使用\n\n### 容量管理\n\n```hemlock\nlet arr = [];  // 初期容量：0\n\narr.push(1);   // 容量1に拡張\narr.push(2);   // 容量2に拡張\narr.push(3);   // 容量4に拡張（2倍）\narr.push(4);   // まだ容量4\narr.push(5);   // 容量8に拡張（2倍）\n```\n\n### 値の比較\n\n`find()`と`contains()`は値の等価性を使用：\n\n```hemlock\n// プリミティブ：値で比較\nlet arr = [1, 2, 3];\narr.contains(2);  // true\n\n// 文字列：値で比較\nlet words = [\"hello\", \"world\"];\nwords.contains(\"hello\");  // true\n\n// オブジェクト：参照で比較\nlet obj1 = { x: 10 };\nlet obj2 = { x: 10 };\nlet arr2 = [obj1];\narr2.contains(obj1);  // true（同じ参照）\narr2.contains(obj2);  // false（異なる参照）\n```\n\n## よくあるパターン\n\n### 関数型操作（map/filter/reduce）\n\n配列には組み込みの`map`、`filter`、`reduce`メソッドがあります：\n\n```hemlock\n// map - 各要素を変換\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = numbers.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\n// filter - 条件に一致する要素を選択\nlet evens = numbers.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4]\n\n// reduce - 単一の値に畳み込み\nlet sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\n// 関数型操作のチェーン\nlet result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]\n    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]\n    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220\n```\n\n### パターン：スタックとしての配列\n\n```hemlock\nlet stack = [];\n\n// スタックにプッシュ\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// スタックからポップ\nlet top = stack.pop();    // 3\nlet next = stack.pop();   // 2\n```\n\n### パターン：キューとしての配列\n\n```hemlock\nlet queue = [];\n\n// エンキュー（末尾に追加）\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// デキュー（先頭から削除）\nlet first = queue.shift();   // 1\nlet second = queue.shift();  // 2\n```\n\n## ベストプラクティス\n\n1. **直接インデックスよりメソッドを使用** - 境界チェックと明確性\n2. **境界をチェック** - 直接インデックスは境界チェックしない\n3. **不変操作を優先** - 変更より`slice()`と`concat()`を使用\n4. **容量を初期化** - サイズが分かっている場合（現在はサポートされていない）\n5. **メンバーシップには`contains()`を使用** - 手動ループより明確\n6. **メソッドをチェーン** - ネストされた呼び出しより読みやすい\n\n## よくある落とし穴\n\n### 落とし穴：直接インデックスの範囲外\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// 境界チェックなし！\narr[10] = 99;  // nullを含むスパース配列を作成\nprint(arr.length);  // 11（3ではない！）\n\n// 改善：push()を使用するか長さをチェック\nif (arr.length <= 10) {\n    arr.push(99);\n}\n```\n\n### 落とし穴：変更 vs. 新しい配列\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// 元を変更\narr.reverse();\nprint(arr);  // [3, 2, 1]\n\n// 新しい配列を返す\nlet sub = arr.slice(0, 2);\nprint(arr);  // [3, 2, 1]（変更なし）\nprint(sub);  // [3, 2]\n```\n\n### 落とし穴：参照の等価性\n\n```hemlock\nlet obj = { x: 10 };\nlet arr = [obj];\n\n// 同じ参照：true\narr.contains(obj);  // true\n\n// 異なる参照：false\narr.contains({ x: 10 });  // false（異なるオブジェクト）\n```\n\n### 落とし穴：長期間存続する配列\n\n```hemlock\n// ローカルスコープの配列は自動解放されるが、グローバル/長期間の配列は注意が必要\nlet global_cache = [];  // モジュールレベル、プログラム終了まで持続\n\nfn add_to_cache(item) {\n    global_cache.push(item);  // 無限に拡大\n}\n\n// 長期間のデータには、以下を検討：\n// - 定期的に配列をクリア：global_cache.clear();\n// - 完了時に早期解放：free(global_cache);\n```\n\n## 例\n\n### 例：配列の統計\n\n```hemlock\nfn mean(arr) {\n    let sum = 0;\n    let i = 0;\n    while (i < arr.length) {\n        sum = sum + arr[i];\n        i = i + 1;\n    }\n    return sum / arr.length;\n}\n\nfn max(arr) {\n    if (arr.length == 0) {\n        return null;\n    }\n\n    let max_val = arr[0];\n    let i = 1;\n    while (i < arr.length) {\n        if (arr[i] > max_val) {\n            max_val = arr[i];\n        }\n        i = i + 1;\n    }\n    return max_val;\n}\n\nlet numbers = [3, 7, 2, 9, 1];\nprint(mean(numbers));  // 4.4\nprint(max(numbers));   // 9\n```\n\n### 例：配列の重複排除\n\n```hemlock\nfn unique(arr) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (!result.contains(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet numbers = [1, 2, 2, 3, 1, 4, 3, 5];\nlet uniq = unique(numbers);  // [1, 2, 3, 4, 5]\n```\n\n### 例：配列のチャンク分割\n\n```hemlock\nfn chunk(arr, size) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        let chunk = arr.slice(i, i + size);\n        result.push(chunk);\n        i = i + size;\n    }\n\n    return result;\n}\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8];\nlet chunks = chunk(numbers, 3);\n// [[1, 2, 3], [4, 5, 6], [7, 8]]\n```\n\n### 例：配列のフラット化\n\n```hemlock\nfn flatten(arr) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        if (typeof(arr[i]) == \"array\") {\n            // ネストされた配列 - フラット化\n            let nested = flatten(arr[i]);\n            let j = 0;\n            while (j < nested.length) {\n                result.push(nested[j]);\n                j = j + 1;\n            }\n        } else {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet nested = [1, [2, 3], [4, [5, 6]], 7];\nlet flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]\n```\n\n### 例：ソート（バブルソート）\n\n```hemlock\nfn sort(arr) {\n    let n = arr.length;\n    let i = 0;\n\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (arr[j] > arr[j + 1]) {\n                // スワップ\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers);  // その場で変更\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## 制限事項\n\n現在の制限事項：\n\n- **インデックスの境界チェックなし** - 直接アクセスはチェックされない\n- **オブジェクトの参照等価性** - `find()`と`contains()`は参照比較を使用\n- **配列の分割代入なし** - `let [a, b] = arr`構文はない\n- **スプレッド演算子なし** - `[...arr1, ...arr2]`構文はない\n\n**注意：** 配列は参照カウントされ、スコープを抜けると自動的に解放されます。詳細は[メモリ管理](memory.md#internal-reference-counting)を参照してください。\n\n## 関連トピック\n\n- [文字列](#language-guide-strings) - 配列メソッドに似た文字列メソッド\n- [オブジェクト](#language-guide-objects) - 配列もオブジェクトのような性質を持つ\n- [関数](#language-guide-functions) - 配列での高階関数\n- [制御フロー](#language-guide-control-flow) - 配列の反復処理\n\n## 参照\n\n- **動的サイズ変更**: 配列は容量を2倍にしながら自動的に拡張\n- **メソッド**: map/filter/reduceを含む18個の包括的なメソッド\n- **メモリ**: 配列の割り当ての詳細は[メモリ](#language-guide-memory)を参照\n"}, "言語ガイド -> 関数": {"id": "language-guide-functions", "content": "# 関数\n\nHemlockの関数は、変数に代入したり、引数として渡したり、他の関数から返したりできる**第一級の値**です。このガイドでは、関数の構文、クロージャ、再帰、高度なパターンについて説明します。\n\n## 概要\n\n```hemlock\n// 名前付き関数の構文\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\n// 無名関数\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\n// クロージャ\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nprint(add5(3));  // 8\n```\n\n## 関数宣言\n\n### 名前付き関数\n\n```hemlock\nfn greet(name: string): string {\n    return \"Hello, \" + name;\n}\n\nlet msg = greet(\"Alice\");  // \"Hello, Alice\"\n```\n\n**構成要素：**\n- `fn` - 関数キーワード\n- `greet` - 関数名\n- `(name: string)` - オプションの型付きパラメータ\n- `: string` - オプションの戻り値の型\n- `{ ... }` - 関数本体\n\n### 無名関数\n\n名前のない関数で、変数に代入します：\n\n```hemlock\nlet square = fn(x) {\n    return x * x;\n};\n\nprint(square(5));  // 25\n```\n\n**名前付き vs. 無名：**\n```hemlock\n// これらは等価：\nfn add(a, b) { return a + b; }\n\nlet add = fn(a, b) { return a + b; };\n```\n\n**注意：** 名前付き関数は、無名関数を使った変数代入に脱糖されます。\n\n## パラメータ\n\n### 基本パラメータ\n\n```hemlock\nfn example(a, b, c) {\n    return a + b + c;\n}\n\nlet result = example(1, 2, 3);  // 6\n```\n\n### 型注釈\n\nパラメータへのオプションの型注釈：\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);      // OK\nadd(5, 10.5);    // 実行時の型チェックでf64に昇格\n```\n\n**型チェック：**\n- 注釈がある場合、パラメータの型は呼び出し時にチェックされる\n- 暗黙の型変換は標準の昇格ルールに従う\n- 型の不一致は実行時エラーを引き起こす\n\n### 値渡し\n\nすべての引数は**コピー**されます（値渡し）：\n\n```hemlock\nfn modify(x) {\n    x = 100;  // ローカルコピーのみを変更\n}\n\nlet a = 10;\nmodify(a);\nprint(a);  // まだ10（変更されていない）\n```\n\n**注意：** オブジェクトと配列は参照で渡されます（参照がコピーされる）ので、その内容は変更できます：\n\n```hemlock\nfn modify_array(arr) {\n    arr[0] = 99;  // 元の配列を変更\n}\n\nlet a = [1, 2, 3];\nmodify_array(a);\nprint(a[0]);  // 99（変更された）\n```\n\n## 戻り値\n\n### Return文\n\n```hemlock\nfn get_max(a: i32, b: i32): i32 {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n```\n\n### 戻り値の型注釈\n\n戻り値のオプションの型注釈：\n\n```hemlock\nfn calculate(): f64 {\n    return 3.14159;\n}\n\nfn get_name(): string {\n    return \"Alice\";\n}\n```\n\n**型チェック：**\n- 戻り値の型は関数が戻るときにチェックされる（注釈がある場合）\n- 型変換は標準の昇格ルールに従う\n\n### 暗黙のReturn\n\n戻り値の型注釈がない関数は暗黙的に`null`を返します：\n\n```hemlock\nfn print_message(msg) {\n    print(msg);\n    // 暗黙的にnullを返す\n}\n\nlet result = print_message(\"hello\");  // resultはnull\n```\n\n### 早期Return\n\n```hemlock\nfn find_first_negative(arr) {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // 早期終了\n        }\n    }\n    return -1;  // 見つからない\n}\n```\n\n### 値なしのReturn\n\n値なしの`return;`は`null`を返します：\n\n```hemlock\nfn maybe_process(value) {\n    if (value < 0) {\n        return;  // nullを返す\n    }\n    return value * 2;\n}\n```\n\n## 第一級関数\n\n関数は他の値と同様に、代入、渡し、返すことができます。\n\n### 変数としての関数\n\n```hemlock\nlet operation = fn(x, y) { return x + y; };\n\nprint(operation(5, 3));  // 8\n\n// 再代入\noperation = fn(x, y) { return x * y; };\nprint(operation(5, 3));  // 15\n```\n\n### 引数としての関数\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 5);  // 10\n```\n\n### 戻り値としての関数\n\n```hemlock\nfn get_operation(op: string) {\n    if (op == \"add\") {\n        return fn(a, b) { return a + b; };\n    } else if (op == \"multiply\") {\n        return fn(a, b) { return a * b; };\n    } else {\n        return fn(a, b) { return 0; };\n    }\n}\n\nlet add = get_operation(\"add\");\nprint(add(5, 3));  // 8\n```\n\n## クロージャ\n\n関数は定義環境をキャプチャします（レキシカルスコープ）。\n\n### 基本的なクロージャ\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n**動作の仕組み：**\n- 内部関数は外側のスコープから`count`をキャプチャ\n- `count`は返された関数の呼び出し間で持続\n- `makeCounter()`の各呼び出しは独自の`count`を持つ新しいクロージャを作成\n\n### パラメータを持つクロージャ\n\n```hemlock\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\n\nprint(add5(3));   // 8\nprint(add10(3));  // 13\n```\n\n### 複数のクロージャ\n\n```hemlock\nfn makeOperations(x) {\n    let add = fn(y) { return x + y; };\n    let multiply = fn(y) { return x * y; };\n\n    return { add: add, multiply: multiply };\n}\n\nlet ops = makeOperations(5);\nprint(ops.add(3));       // 8\nprint(ops.multiply(3));  // 15\n```\n\n### レキシカルスコープ\n\n関数はレキシカルスコープを通じて外側のスコープ変数にアクセスできます：\n\n```hemlock\nlet global = 10;\n\nfn outer() {\n    let outer_var = 20;\n\n    fn inner() {\n        // globalとouter_varにアクセス可能\n        print(global);      // 10\n        print(outer_var);   // 20\n    }\n\n    inner();\n}\n\nouter();\n```\n\nクロージャは変数を参照でキャプチャするため、外側のスコープ変数の読み取りと変更の両方が可能です（上記の`makeCounter`の例を参照）。\n\n## 再帰\n\n関数は自分自身を呼び出すことができます。\n\n### 基本的な再帰\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### 相互再帰\n\n関数は互いを呼び出すことができます：\n\n```hemlock\nfn is_even(n: i32): bool {\n    if (n == 0) {\n        return true;\n    }\n    return is_odd(n - 1);\n}\n\nfn is_odd(n: i32): bool {\n    if (n == 0) {\n        return false;\n    }\n    return is_even(n - 1);\n}\n\nprint(is_even(4));  // true\nprint(is_odd(4));   // false\n```\n\n### 再帰的データ処理\n\n```hemlock\nfn sum_array(arr: array, index: i32): i32 {\n    if (index >= arr.length) {\n        return 0;\n    }\n    return arr[index] + sum_array(arr, index + 1);\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(sum_array(numbers, 0));  // 15\n```\n\n**注意：** 末尾呼び出し最適化はまだありません - 深い再帰はスタックオーバーフローを引き起こす可能性があります。\n\n## 高階関数\n\n他の関数を受け取るか返す関数。\n\n### Mapパターン\n\n```hemlock\nfn map(arr, f) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        result.push(f(arr[i]));\n        i = i + 1;\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = map(numbers, double);  // [2, 4, 6, 8, 10]\n```\n\n### Filterパターン\n\n```hemlock\nfn filter(arr, predicate) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (predicate(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nfn is_even(x) { return x % 2 == 0; }\n\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = filter(numbers, is_even);  // [2, 4, 6]\n```\n\n### Reduceパターン\n\n```hemlock\nfn reduce(arr, f, initial) {\n    let accumulator = initial;\n    let i = 0;\n    while (i < arr.length) {\n        accumulator = f(accumulator, arr[i]);\n        i = i + 1;\n    }\n    return accumulator;\n}\n\nfn add(a, b) { return a + b; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = reduce(numbers, add, 0);  // 15\n```\n\n### 関数合成\n\n```hemlock\nfn compose(f, g) {\n    return fn(x) {\n        return f(g(x));\n    };\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\n\nlet double_then_increment = compose(increment, double);\nprint(double_then_increment(5));  // 11 (5*2 + 1)\n```\n\n## よくあるパターン\n\n### パターン：ファクトリ関数\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```\n\n### パターン：コールバック関数\n\n```hemlock\nfn process_async(data, callback) {\n    // ... 処理を行う\n    callback(data);\n}\n\nprocess_async(\"test\", fn(result) {\n    print(\"Processing complete: \" + result);\n});\n```\n\n### パターン：部分適用\n\n```hemlock\nfn partial(f, x) {\n    return fn(y) {\n        return f(x, y);\n    };\n}\n\nfn multiply(a, b) {\n    return a * b;\n}\n\nlet double = partial(multiply, 2);\nlet triple = partial(multiply, 3);\n\nprint(double(5));  // 10\nprint(triple(5));  // 15\n```\n\n### パターン：メモ化\n\n```hemlock\nfn memoize(f) {\n    let cache = {};\n\n    return fn(x) {\n        if (cache.has(x)) {\n            return cache[x];\n        }\n\n        let result = f(x);\n        cache[x] = result;\n        return result;\n    };\n}\n\nfn expensive_fibonacci(n) {\n    if (n <= 1) { return n; }\n    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);\n}\n\nlet fast_fib = memoize(expensive_fibonacci);\nprint(fast_fib(10));  // キャッシュによりはるかに高速\n```\n\n## 関数のセマンティクス\n\n### 戻り値の型の要件\n\n戻り値の型注釈がある関数は**必ず**値を返す必要があります：\n\n```hemlock\nfn get_value(): i32 {\n    // エラー：return文がない\n}\n\nfn get_value(): i32 {\n    return 42;  // OK\n}\n```\n\n### 型チェック\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);        // OK\nadd(5.5, 10.5);    // f64に昇格、f64を返す\nadd(\"a\", \"b\");     // 実行時エラー：型の不一致\n```\n\n### スコープルール\n\n```hemlock\nlet global = \"global\";\n\nfn outer() {\n    let outer_var = \"outer\";\n\n    fn inner() {\n        let inner_var = \"inner\";\n        // アクセス可能：inner_var、outer_var、global\n    }\n\n    // アクセス可能：outer_var、global\n    // アクセス不可：inner_var\n}\n\n// アクセス可能：global\n// アクセス不可：outer_var、inner_var\n```\n\n## ベストプラクティス\n\n1. **型注釈を使用** - エラーのキャッチと意図の文書化に役立つ\n2. **関数を小さく保つ** - 各関数は1つのことを行う\n3. **純粋関数を優先** - 可能な限り副作用を避ける\n4. **関数に明確な名前を付ける** - 説明的な動詞の名前を使用\n5. **早期returnを使用** - ガード句でネストを減らす\n6. **複雑なクロージャを文書化** - キャプチャされた変数を明確にする\n7. **深い再帰を避ける** - 末尾呼び出し最適化がまだない\n\n## よくある落とし穴\n\n### 落とし穴：再帰の深さ\n\n```hemlock\n// 深い再帰はスタックオーバーフローを引き起こす可能性がある\nfn count_down(n) {\n    if (n == 0) { return; }\n    count_down(n - 1);\n}\n\ncount_down(100000);  // スタックオーバーフローでクラッシュする可能性\n```\n\n### 落とし穴：キャプチャされた変数の変更\n\n```hemlock\nfn make_counter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // キャプチャされた変数の読み取りと変更が可能\n        return count;\n    };\n}\n```\n\n**注意：** これは機能しますが、すべてのクロージャが同じキャプチャされた環境を共有することに注意してください。\n\n## 例\n\n### 例：関数パイプライン\n\n```hemlock\nfn pipeline(value, ...functions) {\n    let result = value;\n    for (f in functions) {\n        result = f(result);\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\nfn square(x) { return x * x; }\n\nlet result = pipeline(3, double, increment, square);\nprint(result);  // 49 ((3*2+1)^2)\n```\n\n### 例：イベントハンドラ\n\n```hemlock\nlet handlers = [];\n\nfn on_event(name: string, handler) {\n    handlers.push({ name: name, handler: handler });\n}\n\nfn trigger_event(name: string, data) {\n    let i = 0;\n    while (i < handlers.length) {\n        if (handlers[i].name == name) {\n            handlers[i].handler(data);\n        }\n        i = i + 1;\n    }\n}\n\non_event(\"click\", fn(data) {\n    print(\"Clicked: \" + data);\n});\n\ntrigger_event(\"click\", \"button1\");\n```\n\n### 例：カスタムコンパレータによるソート\n\n```hemlock\nfn sort(arr, compare) {\n    // カスタムコンパレータによるバブルソート\n    let n = arr.length;\n    let i = 0;\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (compare(arr[j], arr[j + 1]) > 0) {\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nfn ascending(a, b) {\n    if (a < b) { return -1; }\n    if (a > b) { return 1; }\n    return 0;\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers, ascending);\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## オプションパラメータ（デフォルト引数）\n\n関数は`?:`構文を使用してデフォルト値を持つオプションパラメータを持つことができます：\n\n```hemlock\nfn greet(name, greeting?: \"Hello\") {\n    return greeting + \" \" + name;\n}\n\nprint(greet(\"Alice\"));           // \"Hello Alice\"\nprint(greet(\"Bob\", \"Hi\"));       // \"Hi Bob\"\n\nfn add(a, b?: 10, c?: 100) {\n    return a + b + c;\n}\n\nprint(add(1));          // 111 (1 + 10 + 100)\nprint(add(1, 2));       // 103 (1 + 2 + 100)\nprint(add(1, 2, 3));    // 6   (1 + 2 + 3)\n```\n\n**ルール：**\n- オプションパラメータは必須パラメータの後に来る必要がある\n- デフォルト値は任意の式でよい\n- 省略された引数はデフォルト値を使用\n\n## 可変長引数関数（残余パラメータ）\n\n関数は残余パラメータ（`...`）を使用して可変数の引数を受け取ることができます：\n\n```hemlock\nfn sum(...args) {\n    let total = 0;\n    for (arg in args) {\n        total = total + arg;\n    }\n    return total;\n}\n\nprint(sum(1, 2, 3));        // 6\nprint(sum(1, 2, 3, 4, 5));  // 15\nprint(sum());               // 0\n\nfn log(prefix, ...messages) {\n    for (msg in messages) {\n        print(prefix + \": \" + msg);\n    }\n}\n\nlog(\"INFO\", \"Starting\", \"Running\", \"Done\");\n// INFO: Starting\n// INFO: Running\n// INFO: Done\n```\n\n**ルール：**\n- 残余パラメータは最後のパラメータである必要がある\n- 残余パラメータは残りのすべての引数を配列に収集\n- 通常のパラメータやオプションパラメータと組み合わせ可能\n\n## 関数型注釈\n\n関数型により、関数パラメータと戻り値に期待される正確なシグネチャを指定できます：\n\n### 基本的な関数型\n\n```hemlock\n// 関数型の構文：fn(パラメータの型): 戻り値の型\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\nlet double = fn(n) { return n * 2; };\nlet result = apply(double, 5);  // 10\n```\n\n### 高階関数型\n\n```hemlock\n// 関数を返す関数\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\nlet add5 = make_adder(5);\nprint(add5(10));  // 15\n```\n\n### 非同期関数型\n\n```hemlock\n// 非同期関数型\nfn run_task(handler: async fn(): void) {\n    spawn(handler);\n}\n\nrun_task(async fn() {\n    print(\"Running async!\");\n});\n```\n\n### 関数型エイリアス\n\n```hemlock\n// 明確さのために名前付き関数型を作成\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\nfn filter_with(arr: array, pred: Predicate): array {\n    return arr.filter(pred);\n}\n```\n\n## Constパラメータ\n\n`const`修飾子は、関数内でパラメータが変更されることを防ぎます：\n\n### 基本的なConstパラメータ\n\n```hemlock\nfn print_all(const items: array) {\n    // items.push(4);  // エラー：constパラメータを変更できない\n    for (item in items) {\n        print(item);   // OK：読み取りは許可\n    }\n}\n\nlet nums = [1, 2, 3];\nprint_all(nums);\n```\n\n### 深い不変性\n\nConstパラメータは深い不変性を強制します - いかなるパスからも変更できません：\n\n```hemlock\nfn describe(const person: object) {\n    print(person.name);       // OK：読み取りは許可\n    // person.name = \"Bob\";   // エラー：変更できない\n    // person.address.city = \"NYC\";  // エラー：深いconst\n}\n```\n\n### Constが防ぐもの\n\n| 型 | Constでブロックされるもの | 許可されるもの |\n|------|-----------------|---------|\n| array | push、pop、shift、unshift、insert、remove、clear、reverse | slice、concat、map、filter、find、contains |\n| object | フィールド代入 | フィールド読み取り |\n| buffer | インデックス代入 | インデックス読み取り |\n| string | インデックス代入 | すべてのメソッド（新しい文字列を返す） |\n\n## 名前付き引数\n\n関数は明確さと柔軟性のために名前付き引数で呼び出すことができます：\n\n### 基本的な名前付き引数\n\n```hemlock\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" is \" + age + \" years old\");\n}\n\n// 位置引数（従来の方法）\ncreate_user(\"Alice\", 25, false);\n\n// 名前付き引数 - 任意の順序で可能\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n```\n\n### 位置引数と名前付き引数の混合\n\n```hemlock\n// 必要なものに名前を付けてオプションパラメータをスキップ\ncreate_user(\"David\", active: false);  // デフォルトのage=18を使用\n\n// 名前付き引数は位置引数の後に来る必要がある\ncreate_user(\"Eve\", age: 21);          // OK\n// create_user(name: \"Bad\", 25);      // エラー：名前付き引数の後に位置引数\n```\n\n### 名前付き引数のルール\n\n- 名前付き引数には`名前: 値`構文を使用\n- 名前付き引数は位置引数の後に任意の順序で指定可能\n- 位置引数は名前付き引数の後に来ることはできない\n- デフォルト/オプションパラメータと連携\n- 不明なパラメータ名は実行時エラーを引き起こす\n\n## 制限事項\n\n現在の制限事項：\n\n- **参照渡しなし** - `ref`キーワードはパースされるが未実装\n- **関数のオーバーロードなし** - 1つの名前に1つの関数\n- **末尾呼び出し最適化なし** - 深い再帰はスタックサイズで制限\n\n## 関連トピック\n\n- [制御フロー](#language-guide-control-flow) - 制御構造での関数の使用\n- [オブジェクト](#language-guide-objects) - メソッドはオブジェクトに格納された関数\n- [エラーハンドリング](#language-guide-error-handling) - 関数と例外処理\n- [型](#language-guide-types) - 型注釈と変換\n\n## 参照\n\n- **クロージャ**：クロージャのセマンティクスについてはCLAUDE.mdの「Functions」セクションを参照\n- **第一級の値**：関数は他の値と同様の値\n- **レキシカルスコープ**：関数は定義環境をキャプチャ\n"}, "高度なトピック -> FFI": {"id": "advanced-ffi", "content": "# HemlockのFFI（Foreign Function Interface）\n\nHemlockは、libffiを使用して共有ライブラリからC関数を呼び出すための**FFI（Foreign Function Interface）**を提供し、既存のCライブラリやシステムAPIとの統合を可能にします。\n\n## 目次\n\n- [概要](#概要)\n- [現在のステータス](#現在のステータス)\n- [サポートされている型](#サポートされている型)\n- [基本概念](#基本概念)\n- [FFI関数のエクスポート](#ffi関数のエクスポート)\n- [使用ケース](#使用ケース)\n- [将来の開発](#将来の開発)\n- [FFIコールバック](#ffiコールバック)\n- [FFI構造体](#ffi構造体)\n- [構造体型のエクスポート](#構造体型のエクスポート)\n- [現在の制限事項](#現在の制限事項)\n- [ベストプラクティス](#ベストプラクティス)\n\n## 概要\n\nForeign Function Interface (FFI)により、Hemlockプログラムは以下のことができます：\n- 共有ライブラリ（.so、.dylib、.dll）からC関数を呼び出す\n- ラッパーコードを書かずに既存のCライブラリを使用\n- システムAPIに直接アクセス\n- サードパーティのネイティブライブラリと統合\n- Hemlockと低レベルのシステム機能を橋渡し\n\n**主な機能：**\n- 動的ライブラリローディング\n- C関数バインディング\n- HemlockとC型間の自動型変換\n- すべてのプリミティブ型のサポート\n- ポータビリティのためのlibffiベースの実装\n\n## 現在のステータス\n\nFFIサポートはHemlockで利用可能で、以下の機能があります：\n\n**実装済み：**\n- 共有ライブラリからC関数を呼び出す\n- すべてのプリミティブ型（整数、浮動小数点、ポインタ）のサポート\n- 自動型変換\n- libffiベースの実装\n- 動的ライブラリローディング\n- **関数ポインタコールバック** - Hemlock関数をCに渡す\n- **extern関数のエクスポート** - モジュール間でFFIバインディングを共有\n- **構造体の受け渡しと戻り値** - C互換の構造体を値で渡す\n- **完全なポインタヘルパー** - すべての型の読み書き（i8-i64, u8-u64, f32, f64, ptr）\n- **バッファ/ポインタ変換** - `buffer_ptr()`, `ptr_to_buffer()`\n- **FFI型サイズ** - プラットフォーム対応の型サイズ用`ffi_sizeof()`\n- **プラットフォーム型** - `size_t`, `usize`, `isize`, `intptr_t`のサポート\n\n**開発中：**\n- 文字列マーシャリングヘルパー\n- エラー処理の改善\n\n**テストカバレッジ：**\n- コールバックテストを含むFFIテストがパス\n- 基本的な関数呼び出しを検証\n- 型変換をテスト\n- qsortコールバック統合をテスト\n\n## サポートされている型\n\n### プリミティブ型\n\n以下のHemlock型はC関数との間で受け渡しできます：\n\n| Hemlock型 | C型 | サイズ | 備考 |\n|--------------|--------|------|-------|\n| `i8` | `int8_t` | 1バイト | 符号付き8ビット整数 |\n| `i16` | `int16_t` | 2バイト | 符号付き16ビット整数 |\n| `i32` | `int32_t` | 4バイト | 符号付き32ビット整数 |\n| `i64` | `int64_t` | 8バイト | 符号付き64ビット整数 |\n| `u8` | `uint8_t` | 1バイト | 符号なし8ビット整数 |\n| `u16` | `uint16_t` | 2バイト | 符号なし16ビット整数 |\n| `u32` | `uint32_t` | 4バイト | 符号なし32ビット整数 |\n| `u64` | `uint64_t` | 8バイト | 符号なし64ビット整数 |\n| `f32` | `float` | 4バイト | 32ビット浮動小数点 |\n| `f64` | `double` | 8バイト | 64ビット浮動小数点 |\n| `ptr` | `void*` | 8バイト | 生ポインタ |\n\n### 型変換\n\n**自動変換：**\n- Hemlock整数 → C整数（範囲チェック付き）\n- Hemlock浮動小数点 → C浮動小数点\n- Hemlockポインタ → Cポインタ\n- C戻り値 → Hemlock値\n\n**型マッピングの例：**\n```hemlock\n// Hemlock → C\nlet i: i32 = 42;         // → int32_t (4バイト)\nlet f: f64 = 3.14;       // → double (8バイト)\nlet p: ptr = alloc(64);  // → void* (8バイト)\n\n// C → Hemlock (戻り値)\n// int32_t foo() → i32\n// double bar() → f64\n// void* baz() → ptr\n```\n\n## 基本概念\n\n### 共有ライブラリ\n\nFFIはコンパイルされた共有ライブラリで動作します：\n\n**Linux:** `.so`ファイル\n```\nlibexample.so\n/usr/lib/libm.so\n```\n\n**macOS:** `.dylib`ファイル\n```\nlibexample.dylib\n/usr/lib/libSystem.dylib\n```\n\n**Windows:** `.dll`ファイル\n```\nexample.dll\nkernel32.dll\n```\n\n### 関数シグネチャ\n\nFFIが正しく動作するには、C関数のシグネチャが既知である必要があります：\n\n```c\n// C関数シグネチャの例\nint add(int a, int b);\ndouble sqrt(double x);\nvoid* malloc(size_t size);\nvoid free(void* ptr);\n```\n\nこれらは、ライブラリがロードされ、関数がバインドされるとHemlockから呼び出せます。\n\n### プラットフォーム互換性\n\nFFIはポータビリティのために**libffi**を使用します：\n- x86、x86-64、ARM、ARM64で動作\n- 呼び出し規約を自動的に処理\n- プラットフォーム固有のABIの詳細を抽象化\n- Linux、macOS、Windows（適切なlibffiを使用）をサポート\n\n## FFI関数のエクスポート\n\n`extern fn`で宣言されたFFI関数はモジュールからエクスポートでき、複数のファイルで共有できる再利用可能なライブラリラッパーを作成できます。\n\n### 基本的なエクスポート構文\n\n```hemlock\n// string_utils.hml - C文字列関数をラップするライブラリモジュール\nimport \"libc.so.6\";\n\n// extern関数を直接エクスポート\nexport extern fn strlen(s: string): i32;\nexport extern fn strcmp(s1: string, s2: string): i32;\n\n// extern関数と一緒にラッパー関数もエクスポートできる\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n\nexport fn strings_equal(a: string, b: string): bool {\n    return strcmp(a, b) == 0;\n}\n```\n\n### エクスポートされたFFI関数のインポート\n\n```hemlock\n// main.hml - エクスポートされたFFI関数を使用\nimport { strlen, string_length, strings_equal } from \"./string_utils.hml\";\n\nlet msg = \"Hello, World!\";\nprint(strlen(msg));           // 13 - 直接extern呼び出し\nprint(string_length(msg));    // 13 - ラッパー関数\n\nprint(strings_equal(\"foo\", \"foo\"));  // true\nprint(strings_equal(\"foo\", \"bar\"));  // false\n```\n\n### export externの使用ケース\n\n**1. プラットフォーム抽象化**\n```hemlock\n// platform.hml - プラットフォームの違いを抽象化\nimport \"libc.so.6\";  // Linux\n\nexport extern fn getpid(): i32;\nexport extern fn getuid(): i32;\nexport extern fn geteuid(): i32;\n```\n\n**2. ライブラリラッパー**\n```hemlock\n// crypto_lib.hml - 暗号ライブラリ関数をラップ\nimport \"libcrypto.so\";\n\nexport extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;\nexport extern fn MD5(data: ptr, len: u64, out: ptr): ptr;\n\n// Hemlockフレンドリーなラッパーを追加\nexport fn sha256_string(s: string): string {\n    // extern関数を使用した実装\n}\n```\n\n**3. 集中化されたFFI宣言**\n```hemlock\n// libc.hml - libcバインディングの中央モジュール\nimport \"libc.so.6\";\n\n// 文字列関数\nexport extern fn strlen(s: string): i32;\nexport extern fn strcpy(dest: ptr, src: string): ptr;\nexport extern fn strcat(dest: ptr, src: string): ptr;\n\n// メモリ関数\nexport extern fn malloc(size: u64): ptr;\nexport extern fn realloc(p: ptr, size: u64): ptr;\nexport extern fn calloc(nmemb: u64, size: u64): ptr;\n\n// プロセス関数\nexport extern fn getpid(): i32;\nexport extern fn getppid(): i32;\nexport extern fn getenv(name: string): ptr;\n```\n\nプロジェクト全体で使用：\n```hemlock\nimport { strlen, malloc, getpid } from \"./libc.hml\";\n```\n\n### 通常のエクスポートとの組み合わせ\n\nエクスポートされたextern関数と通常の関数エクスポートを混在させることができます：\n\n```hemlock\n// math_extended.hml\nimport \"libm.so.6\";\n\n// 生のC関数をエクスポート\nexport extern fn sin(x: f64): f64;\nexport extern fn cos(x: f64): f64;\nexport extern fn tan(x: f64): f64;\n\n// それらを使用するHemlock関数をエクスポート\nexport fn deg_to_rad(degrees: f64): f64 {\n    return degrees * 3.14159265359 / 180.0;\n}\n\nexport fn sin_degrees(degrees: f64): f64 {\n    return sin(deg_to_rad(degrees));\n}\n```\n\n### プラットフォーム固有のライブラリ\n\nextern関数をエクスポートする際、ライブラリ名はプラットフォームによって異なることに注意してください：\n\n```hemlock\n// Linux用\nimport \"libc.so.6\";\n\n// macOS用（異なるアプローチが必要）\nimport \"libSystem.B.dylib\";\n```\n\n現在、Hemlockの`import \"library\"`構文は静的なライブラリパスを使用するため、クロスプラットフォームFFIコードにはプラットフォーム固有のモジュールが必要な場合があります。\n\n## 使用ケース\n\n### 1. システムライブラリ\n\n標準Cライブラリ関数にアクセス：\n\n**数学関数：**\n```hemlock\n// libmからsqrtを呼び出す\nlet result = sqrt(16.0);  // 4.0\n```\n\n**メモリ割り当て：**\n```hemlock\n// libcからmalloc/freeを呼び出す\nlet ptr = malloc(1024);\nfree(ptr);\n```\n\n### 2. サードパーティライブラリ\n\n既存のCライブラリを使用：\n\n**例：画像処理**\n```hemlock\n// libpngまたはlibjpegをロード\n// Cライブラリ関数を使用して画像を処理\n```\n\n**例：暗号化**\n```hemlock\n// OpenSSLまたはlibsodiumを使用\n// FFI経由で暗号化/復号化\n```\n\n### 3. システムAPI\n\n直接システムコール：\n\n**例：POSIX API**\n```hemlock\n// getpid、getuidなどを呼び出す\n// 低レベルのシステム機能にアクセス\n```\n\n### 4. パフォーマンスクリティカルなコード\n\n最適化されたC実装を呼び出す：\n\n```hemlock\n// 高度に最適化されたCライブラリを使用\n// SIMD操作、ベクトル化コード\n// ハードウェアアクセラレーション関数\n```\n\n### 5. ハードウェアアクセス\n\nハードウェアライブラリとのインターフェース：\n\n```hemlock\n// 組み込みシステムでのGPIO制御\n// USBデバイス通信\n// シリアルポートアクセス\n```\n\n### 6. レガシーコード統合\n\n既存のCコードベースを再利用：\n\n```hemlock\n// レガシーCアプリケーションから関数を呼び出す\n// Hemlockへの段階的な移行\n// 動作するCコードを保持\n```\n\n## 将来の開発\n\n### 計画されている機能\n\n**1. 構造体サポート**\n```hemlock\n// 将来：C構造体の受け渡し/戻り\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\nlet p = Point { x: 1.0, y: 2.0 };\nc_function_with_struct(p);\n```\n\n**2. 配列/バッファ処理**\n```hemlock\n// 将来：より良い配列の受け渡し\nlet arr = [1, 2, 3, 4, 5];\nprocess_array(arr);  // C関数に渡す\n```\n\n**3. 関数ポインタコールバック** （実装済み！）\n```hemlock\n// Hemlock関数をコールバックとしてCに渡す\nfn my_compare(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    return va - vb;\n}\n\n// C呼び出し可能な関数ポインタを作成\nlet cmp = callback(my_compare, [\"ptr\", \"ptr\"], \"i32\");\n\n// qsortやコールバックを期待するC関数で使用\nqsort(arr, count, elem_size, cmp);\n\n// 完了時にクリーンアップ\ncallback_free(cmp);\n```\n\n**4. 文字列マーシャリング**\n```hemlock\n// 将来：自動文字列変換\nlet s = \"hello\";\nc_string_function(s);  // C文字列に自動変換\n```\n\n**5. エラー処理**\n```hemlock\n// 将来：より良いエラー報告\ntry {\n    let result = risky_c_function();\n} catch (e) {\n    print(\"FFI error: \" + e);\n}\n```\n\n**6. 型安全性**\n```hemlock\n// 将来：FFI用の型注釈\n@ffi(\"libm.so\")\nfn sqrt(x: f64): f64;\n\nlet result = sqrt(16.0);  // 型チェック済み\n```\n\n### 機能\n\n**v1.0：**\n- 基本的なFFIとプリミティブ型\n- 動的ライブラリローディング\n- 関数呼び出し\n- libffiクロージャによるコールバックサポート\n\n**将来：**\n- 構造体サポート\n- 配列処理の改善\n- 自動バインディング生成\n\n## FFIコールバック\n\nHemlockは、libffiクロージャを使用してコールバックとしてC側にHemlock関数を渡すことをサポートしています。これにより、`qsort`、イベントループ、コールバックベースのライブラリなど、関数ポインタを期待するC APIとの統合が可能になります。\n\n### コールバックの作成\n\n`callback()`を使用してHemlock関数からC呼び出し可能な関数ポインタを作成：\n\n```hemlock\n// callback(function, param_types, return_type) -> ptr\nlet cb = callback(my_function, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n**パラメータ：**\n- `function`：ラップするHemlock関数\n- `param_types`：型名文字列の配列（例：`[\"ptr\", \"i32\"]`）\n- `return_type`：戻り値の型文字列（例：`\"i32\"`, `\"void\"`）\n\n**サポートされるコールバック型：**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - 符号付き整数\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - 符号なし整数\n- `\"f32\"`, `\"f64\"` - 浮動小数点\n- `\"ptr\"` - ポインタ\n- `\"void\"` - 戻り値なし\n- `\"bool\"` - ブール値\n\n### 例：qsort\n\n```hemlock\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// 整数用の比較関数（昇順）\nfn compare_ints(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va < vb) { return -1; }\n    if (va > vb) { return 1; }\n    return 0;\n}\n\n// 5つの整数の配列を割り当て\nlet arr = alloc(20);  // 5 * 4バイト\nptr_write_i32(arr, 5);\nptr_write_i32(ptr_offset(arr, 1, 4), 2);\nptr_write_i32(ptr_offset(arr, 2, 4), 8);\nptr_write_i32(ptr_offset(arr, 3, 4), 1);\nptr_write_i32(ptr_offset(arr, 4, 4), 9);\n\n// コールバックを作成してソート\nlet cmp = callback(compare_ints, [\"ptr\", \"ptr\"], \"i32\");\nqsort(arr, 5, 4, cmp);\n\n// 配列はソート済み：[1, 2, 5, 8, 9]\n\n// クリーンアップ\ncallback_free(cmp);\nfree(arr);\n```\n\n### ポインタヘルパー関数\n\nHemlockは生ポインタを扱うための包括的なヘルパー関数を提供します。これらはFFIコールバックや直接メモリ操作に不可欠です。\n\n#### 整数型ヘルパー\n\n| 関数 | 説明 |\n|----------|-------------|\n| `ptr_deref_i8(ptr)` | ポインタをデリファレンスしてi8を読み取り |\n| `ptr_deref_i16(ptr)` | ポインタをデリファレンスしてi16を読み取り |\n| `ptr_deref_i32(ptr)` | ポインタをデリファレンスしてi32を読み取り |\n| `ptr_deref_i64(ptr)` | ポインタをデリファレンスしてi64を読み取り |\n| `ptr_deref_u8(ptr)` | ポインタをデリファレンスしてu8を読み取り |\n| `ptr_deref_u16(ptr)` | ポインタをデリファレンスしてu16を読み取り |\n| `ptr_deref_u32(ptr)` | ポインタをデリファレンスしてu32を読み取り |\n| `ptr_deref_u64(ptr)` | ポインタをデリファレンスしてu64を読み取り |\n| `ptr_write_i8(ptr, value)` | ポインタ位置にi8を書き込み |\n| `ptr_write_i16(ptr, value)` | ポインタ位置にi16を書き込み |\n| `ptr_write_i32(ptr, value)` | ポインタ位置にi32を書き込み |\n| `ptr_write_i64(ptr, value)` | ポインタ位置にi64を書き込み |\n| `ptr_write_u8(ptr, value)` | ポインタ位置にu8を書き込み |\n| `ptr_write_u16(ptr, value)` | ポインタ位置にu16を書き込み |\n| `ptr_write_u32(ptr, value)` | ポインタ位置にu32を書き込み |\n| `ptr_write_u64(ptr, value)` | ポインタ位置にu64を書き込み |\n\n#### 浮動小数点型ヘルパー\n\n| 関数 | 説明 |\n|----------|-------------|\n| `ptr_deref_f32(ptr)` | ポインタをデリファレンスしてf32（float）を読み取り |\n| `ptr_deref_f64(ptr)` | ポインタをデリファレンスしてf64（double）を読み取り |\n| `ptr_write_f32(ptr, value)` | ポインタ位置にf32を書き込み |\n| `ptr_write_f64(ptr, value)` | ポインタ位置にf64を書き込み |\n\n#### ポインタ型ヘルパー\n\n| 関数 | 説明 |\n|----------|-------------|\n| `ptr_deref_ptr(ptr)` | ポインタへのポインタをデリファレンス |\n| `ptr_write_ptr(ptr, value)` | ポインタ位置にポインタを書き込み |\n| `ptr_offset(ptr, index, size)` | オフセットを計算：`ptr + index * size` |\n| `ptr_read_i32(ptr)` | ポインタへのポインタ経由でi32を読み取り（qsortコールバック用） |\n| `ptr_null()` | nullポインタ定数を取得 |\n\n#### バッファ変換ヘルパー\n\n| 関数 | 説明 |\n|----------|-------------|\n| `buffer_ptr(buffer)` | バッファから生ポインタを取得 |\n| `ptr_to_buffer(ptr, size)` | ポインタからデータを新しいバッファにコピー |\n\n#### FFIユーティリティ関数\n\n| 関数 | 説明 |\n|----------|-------------|\n| `ffi_sizeof(type_name)` | FFI型のバイトサイズを取得 |\n\n**`ffi_sizeof`でサポートされる型名：**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - 符号付き整数（1, 2, 4, 8バイト）\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - 符号なし整数（1, 2, 4, 8バイト）\n- `\"f32\"`, `\"f64\"` - 浮動小数点（4, 8バイト）\n- `\"ptr\"` - ポインタ（64ビットでは8バイト）\n- `\"size_t\"`, `\"usize\"` - プラットフォーム依存のサイズ型\n- `\"intptr_t\"`, `\"isize\"` - プラットフォーム依存の符号付きポインタ型\n\n#### 例：異なる型での作業\n\n```hemlock\nlet p = alloc(64);\n\n// 整数の書き込みと読み取り\nptr_write_i8(p, 42);\nprint(ptr_deref_i8(p));  // 42\n\nptr_write_i64(ptr_offset(p, 1, 8), 9000000000);\nprint(ptr_deref_i64(ptr_offset(p, 1, 8)));  // 9000000000\n\n// 浮動小数点の書き込みと読み取り\nptr_write_f64(p, 3.14159);\nprint(ptr_deref_f64(p));  // 3.14159\n\n// ポインタへのポインタ\nlet inner = alloc(4);\nptr_write_i32(inner, 999);\nptr_write_ptr(p, inner);\nlet retrieved = ptr_deref_ptr(p);\nprint(ptr_deref_i32(retrieved));  // 999\n\n// 型サイズの取得\nprint(ffi_sizeof(\"i64\"));  // 8\nprint(ffi_sizeof(\"ptr\"));  // 8（64ビット環境）\n\n// バッファ変換\nlet buf = buffer(64);\nptr_write_i32(buffer_ptr(buf), 12345);\nprint(ptr_deref_i32(buffer_ptr(buf)));  // 12345\n\nfree(inner);\nfree(p);\n```\n\n### コールバックの解放\n\n**重要：**メモリリークを防ぐため、完了時に常にコールバックを解放してください：\n\n```hemlock\nlet cb = callback(my_fn, [\"ptr\"], \"void\");\n// ...コールバックを使用...\ncallback_free(cb);  // 完了時に解放\n```\n\nコールバックはプログラム終了時にも自動的に解放されます。\n\n### コールバック内のクロージャ\n\nコールバックはクロージャ環境をキャプチャするため、外部スコープの変数にアクセスできます：\n\n```hemlock\nlet multiplier = 10;\n\nfn scale(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    // 外部スコープの'multiplier'にアクセス可能\n    return (va * multiplier) - (vb * multiplier);\n}\n\nlet cmp = callback(scale, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n### スレッド安全性\n\nコールバック呼び出しはスレッド安全性を確保するためにmutexでシリアライズされます。Hemlockインタープリターは完全にはスレッドセーフではないためです。これは以下を意味します：\n- 一度に1つのコールバックのみが実行可能\n- マルチスレッドCライブラリでも安全に使用可能\n- コールバックが複数のスレッドから非常に頻繁に呼び出される場合、パフォーマンスに影響する可能性\n\n### コールバック内のエラー処理\n\nコールバック内でスローされた例外はCコードに伝播できません。代わりに：\n- stderrに警告が出力される\n- コールバックはデフォルト値（0またはNULL）を返す\n- 例外はログに記録されるが伝播されない\n\n```hemlock\nfn risky_callback(a: ptr): i32 {\n    throw \"Something went wrong\";  // 警告が出力され、0を返す\n}\n```\n\n堅牢なエラー処理のために、入力を検証し、コールバック内でのスローを避けてください。\n\n## FFI構造体\n\nHemlockは構造体を値でC関数に渡すことをサポートしています。構造体型は型注釈付きで定義すると、FFI用に自動的に登録されます。\n\n### FFI互換構造体の定義\n\n構造体がFFI互換となるのは、すべてのフィールドにFFI互換型を使用した明示的な型注釈がある場合です：\n\n```hemlock\n// FFI互換構造体\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\n// 複数のフィールド型を持つFFI互換構造体\ndefine Rectangle {\n    top_left: Point,      // ネストされた構造体\n    width: f64,\n    height: f64,\n}\n\n// FFI互換でない（型注釈のないフィールド）\ndefine DynamicObject {\n    name,                 // 型なし - FFIで使用不可\n    value,\n}\n```\n\n### FFIでの構造体の使用\n\n構造体型を使用するextern関数を宣言：\n\n```hemlock\n// 構造体型を定義\ndefine Vector2D {\n    x: f64,\n    y: f64,\n}\n\n// Cライブラリをインポート\nimport \"libmath.so\";\n\n// 構造体を取る/返すextern関数を宣言\nextern fn vector_add(a: Vector2D, b: Vector2D): Vector2D;\nextern fn vector_length(v: Vector2D): f64;\n\n// 自然に使用\nlet a: Vector2D = { x: 3.0, y: 0.0 };\nlet b: Vector2D = { x: 0.0, y: 4.0 };\nlet result = vector_add(a, b);\nprint(result.x);  // 3.0\nprint(result.y);  // 4.0\n\nlet len = vector_length(result);\nprint(len);       // 5.0\n```\n\n### サポートされるフィールド型\n\n構造体フィールドはこれらのFFI互換型を使用する必要があります：\n\n| Hemlock型 | C型 | サイズ |\n|--------------|--------|------|\n| `i8` | `int8_t` | 1バイト |\n| `i16` | `int16_t` | 2バイト |\n| `i32` | `int32_t` | 4バイト |\n| `i64` | `int64_t` | 8バイト |\n| `u8` | `uint8_t` | 1バイト |\n| `u16` | `uint16_t` | 2バイト |\n| `u32` | `uint32_t` | 4バイト |\n| `u64` | `uint64_t` | 8バイト |\n| `f32` | `float` | 4バイト |\n| `f64` | `double` | 8バイト |\n| `ptr` | `void*` | 8バイト |\n| `string` | `char*` | 8バイト |\n| `bool` | `int` | 可変 |\n| ネストされた構造体 | struct | 可変 |\n\n### 構造体レイアウト\n\nHemlockはプラットフォームのネイティブ構造体レイアウトルール（C ABIに一致）を使用します：\n- フィールドは型に応じてアラインメント\n- 必要に応じてパディングが挿入\n- 合計サイズは最大メンバーにアラインメントするようパディング\n\n```hemlock\n// 例：C互換レイアウト\ndefine Mixed {\n    a: i8,    // オフセット0、サイズ1\n              // 3バイトパディング\n    b: i32,   // オフセット4、サイズ4\n}\n// 合計サイズ：8バイト（パディング込み）\n\ndefine Point3D {\n    x: f64,   // オフセット0、サイズ8\n    y: f64,   // オフセット8、サイズ8\n    z: f64,   // オフセット16、サイズ8\n}\n// 合計サイズ：24バイト（パディング不要）\n```\n\n### ネストされた構造体\n\n構造体は他の構造体を含むことができます：\n\n```hemlock\ndefine Inner {\n    x: i32,\n    y: i32,\n}\n\ndefine Outer {\n    inner: Inner,\n    z: i32,\n}\n\nimport \"mylib.so\";\nextern fn process_nested(data: Outer): i32;\n\nlet obj: Outer = {\n    inner: { x: 1, y: 2 },\n    z: 3,\n};\nlet result = process_nested(obj);\n```\n\n### 構造体の戻り値\n\nC関数は構造体を返すことができます：\n\n```hemlock\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\nimport \"libmath.so\";\nextern fn get_origin(): Point;\n\nlet p = get_origin();\nprint(p.x);  // 0.0\nprint(p.y);  // 0.0\n```\n\n### 制限事項\n\n- **構造体フィールドには型注釈が必要** - 型のないフィールドはFFI互換でない\n- **構造体内の配列なし** - 代わりにポインタを使用\n- **共用体なし** - 構造体型のみサポート\n- **コールバックは構造体を返せない** - コールバック戻り値にはポインタを使用\n\n### 構造体型のエクスポート\n\n`export define`を使用してモジュールから構造体型定義をエクスポートできます：\n\n```hemlock\n// geometry.hml\nexport define Vector2 {\n    x: f32,\n    y: f32,\n}\n\nexport define Rectangle {\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n}\n\nexport fn create_rect(x: f32, y: f32, w: f32, h: f32): Rectangle {\n    return { x: x, y: y, width: w, height: h };\n}\n```\n\n**重要：**エクスポートされた構造体型はモジュールがロードされると**グローバルに**登録されます。モジュールから何かをインポートすると自動的に利用可能になります。名前で明示的にインポートする必要は（できません）：\n\n```hemlock\n// main.hml\n\n// 良い例 - 構造体型はモジュールからのインポート後に自動的に利用可能\nimport { create_rect } from \"./geometry.hml\";\nlet v: Vector2 = { x: 1.0, y: 2.0 };      // 動作 - Vector2はグローバルに利用可能\nlet r: Rectangle = create_rect(0.0, 0.0, 100.0, 50.0);  // 動作\n\n// 悪い例 - 構造体型を名前で明示的にインポートできない\nimport { Vector2 } from \"./geometry.hml\";  // エラー：未定義の変数 'Vector2'\n```\n\nこの動作は、構造体型がモジュールのエクスポート環境に値として格納されるのではなく、モジュールロード時にグローバル型レジストリに登録されるためです。型はモジュールからインポートするすべてのコードで利用可能になります。\n\n## 現在の制限事項\n\nFFIには以下の制限事項があります：\n\n**1. 手動型変換**\n- 文字列変換を手動で管理する必要がある\n- Hemlock文字列 ↔ C文字列の自動変換なし\n\n**2. 限定的なエラー処理**\n- 基本的なエラー報告\n- コールバック内の例外はCに伝播できない\n\n**3. 手動ライブラリローディング**\n- ライブラリを手動でロードする必要がある\n- 自動バインディング生成なし\n\n**4. プラットフォーム固有のコード**\n- ライブラリパスはプラットフォームによって異なる\n- .so vs .dylib vs .dllを処理する必要がある\n\n## ベストプラクティス\n\n包括的なFFIドキュメントはまだ開発中ですが、一般的なベストプラクティスを以下に示します：\n\n### 1. 型安全性\n\n```hemlock\n// 型を明示的に指定\nlet x: i32 = 42;\nlet result: f64 = c_function(x);\n```\n\n### 2. メモリ管理\n\n```hemlock\n// 割り当てられたメモリを解放することを忘れずに\nlet ptr = c_malloc(1024);\n// ...ptrを使用\nc_free(ptr);\n```\n\n### 3. エラーチェック\n\n```hemlock\n// 戻り値をチェック\nlet result = c_function();\nif (result == null) {\n    print(\"C function failed\");\n}\n```\n\n### 4. プラットフォーム互換性\n\n```hemlock\n// プラットフォームの違いを処理\n// 適切なライブラリ拡張子を使用（.so、.dylib、.dll）\n```\n\n## 例\n\n動作する例については、以下を参照してください：\n- コールバックテスト：`/tests/ffi_callbacks/` - qsortコールバックの例\n- stdlib FFI使用：`/stdlib/hash.hml`、`/stdlib/regex.hml`、`/stdlib/crypto.hml`\n- サンプルプログラム：`/examples/`（利用可能な場合）\n\n## ヘルプの取得\n\nFFIはHemlockの新しい機能です。質問や問題については：\n\n1. テストスイートで動作する例を確認\n2. 低レベルの詳細についてはlibffiドキュメントを参照\n3. プロジェクトのissuesを通じてバグ報告や機能リクエスト\n\n## まとめ\n\nHemlockのFFIは以下を提供します：\n\n- 共有ライブラリからのC関数呼び出し\n- プリミティブ型サポート（i8-i64, u8-u64, f32, f64, ptr）\n- 自動型変換\n- libffiベースのポータビリティ\n- ネイティブライブラリ統合の基盤\n- **関数ポインタコールバック** - Hemlock関数をCに渡す\n- **extern関数のエクスポート** - モジュール間でFFIバインディングを共有\n- **構造体の受け渡しと戻り** - C互換構造体を値で渡す\n- **defineのエクスポート** - モジュール間で構造体型定義を共有（グローバルに自動インポート）\n- **完全なポインタヘルパー** - すべての型の読み書き（i8-i64, u8-u64, f32, f64, ptr）\n- **バッファ/ポインタ変換** - データマーシャリング用`buffer_ptr()`、`ptr_to_buffer()`\n- **FFI型サイズ** - プラットフォーム対応の型サイズ用`ffi_sizeof()`\n- **プラットフォーム型** - `size_t`、`usize`、`isize`、`intptr_t`、`uintptr_t`のサポート\n\n**現在のステータス：**FFIはプリミティブ型、構造体、コールバック、モジュールエクスポート、完全なポインタヘルパー関数で完全な機能を備えています\n\n**将来：**文字列マーシャリングヘルパー\n\n**使用ケース：**システムライブラリ、サードパーティライブラリ、qsort、イベントループ、コールバックベースAPI、再利用可能なライブラリラッパー\n\n## 貢献\n\nFFIドキュメントは拡張中です。FFIで作業している場合：\n- 使用ケースをドキュメント化\n- サンプルコードを共有\n- 問題や制限を報告\n- 改善を提案\n\nFFIシステムは、必要な場合に低レベルアクセスを提供しながら、実用的で安全になるよう設計されており、Hemlockの「暗黙より明示」と「unsafeはバグではなく機能」という哲学に従っています。\n"}, "高度なトピック -> File IO": {"id": "advanced-file-io", "content": "# HemlockでのファイルI/O\n\nHemlockは、適切なエラー処理とリソース管理を備えたファイル操作のための**Fileオブジェクト API**を提供します。\n\n## 目次\n\n- [概要](#概要)\n- [ファイルを開く](#ファイルを開く)\n- [ファイルメソッド](#ファイルメソッド)\n- [ファイルプロパティ](#ファイルプロパティ)\n- [エラー処理](#エラー処理)\n- [リソース管理](#リソース管理)\n- [完全なAPIリファレンス](#完全なapiリファレンス)\n- [一般的なパターン](#一般的なパターン)\n- [ベストプラクティス](#ベストプラクティス)\n\n## 概要\n\nFileオブジェクトAPIは以下を提供します：\n\n- **明示的なリソース管理** - ファイルは手動で閉じる必要がある\n- **複数のオープンモード** - 読み取り、書き込み、追記、読み書き\n- **テキストとバイナリ操作** - テキストとバイナリデータの両方を読み書き\n- **シーク対応** - ファイル内でのランダムアクセス\n- **包括的なエラーメッセージ** - コンテキスト対応のエラー報告\n\n**重要：**ファイルは自動的に閉じられません。ファイルディスクリプタのリークを避けるために`f.close()`を呼び出す必要があります。\n\n## ファイルを開く\n\nファイルを開くには`open(path, mode?)`を使用します：\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");     // 読み取りモード（デフォルト）\nlet f2 = open(\"output.txt\", \"w\");  // 書き込みモード（切り詰め）\nlet f3 = open(\"log.txt\", \"a\");     // 追記モード\nlet f4 = open(\"data.bin\", \"r+\");   // 読み書きモード\n```\n\n### オープンモード\n\n| モード | 説明 | ファイルの存在が必要 | 切り詰め | 位置 |\n|------|-------------|----------------|-----------|----------|\n| `\"r\"` | 読み取り（デフォルト） | はい | いいえ | 先頭 |\n| `\"w\"` | 書き込み | いいえ（作成） | はい | 先頭 |\n| `\"a\"` | 追記 | いいえ（作成） | いいえ | 末尾 |\n| `\"r+\"` | 読み書き | はい | いいえ | 先頭 |\n| `\"w+\"` | 読み書き | いいえ（作成） | はい | 先頭 |\n| `\"a+\"` | 読み取りと追記 | いいえ（作成） | いいえ | 末尾 |\n\n### 例\n\n**既存ファイルの読み取り：**\n```hemlock\nlet f = open(\"config.json\", \"r\");\n// または単に：\nlet f = open(\"config.json\");  // \"r\"がデフォルト\n```\n\n**書き込み用に新しいファイルを作成：**\n```hemlock\nlet f = open(\"output.txt\", \"w\");  // 作成または切り詰め\n```\n\n**ファイルへの追記：**\n```hemlock\nlet f = open(\"log.txt\", \"a\");  // 存在しない場合は作成\n```\n\n**読み書きモード：**\n```hemlock\nlet f = open(\"data.bin\", \"r+\");  // 既存ファイル、読み書き可能\n```\n\n## ファイルメソッド\n\n### 読み取り\n\n#### read(size?: i32): string\n\nファイルからテキストを読み取り（オプションのサイズパラメータ）。\n\n**サイズなし（すべて読み取り）：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet all = f.read();  // 現在位置からEOFまで読み取り\nf.close();\n```\n\n**サイズ指定（特定バイト数を読み取り）：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet chunk = f.read(1024);  // 最大1024バイト読み取り\nlet next = f.read(1024);   // 次の1024バイトを読み取り\nf.close();\n```\n\n**戻り値：**読み取ったデータを含む文字列、またはEOFの場合は空文字列\n\n**例 - ファイル全体の読み取り：**\n```hemlock\nlet f = open(\"poem.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n```\n\n**例 - チャンクでの読み取り：**\n```hemlock\nlet f = open(\"large.txt\", \"r\");\nwhile (true) {\n    let chunk = f.read(4096);  // 4KBチャンク\n    if (chunk == \"\") { break; }  // EOFに到達\n    process(chunk);\n}\nf.close();\n```\n\n#### read_bytes(size: i32): buffer\n\nバイナリデータを読み取り（バッファを返す）。\n\n**パラメータ：**\n- `size`（i32）- 読み取るバイト数\n\n**戻り値：**読み取ったバイトを含むバッファ\n\n```hemlock\nlet f = open(\"image.png\", \"r\");\nlet binary = f.read_bytes(256);  // 256バイト読み取り\nprint(binary.length);  // 256（またはEOFの場合はそれ以下）\n\n// 個々のバイトにアクセス\nlet first_byte = binary[0];\nprint(first_byte);\n\nf.close();\n```\n\n**例 - バイナリファイル全体の読み取り：**\n```hemlock\nlet f = open(\"data.bin\", \"r\");\nlet size = 10240;  // 予想サイズ\nlet data = f.read_bytes(size);\nf.close();\n\n// バイナリデータを処理\nlet i = 0;\nwhile (i < data.length) {\n    let byte = data[i];\n    // ...バイトを処理\n    i = i + 1;\n}\n```\n\n### 書き込み\n\n#### write(data: string): i32\n\nファイルにテキストを書き込み（書き込んだバイト数を返す）。\n\n**パラメータ：**\n- `data`（string）- 書き込むテキスト\n\n**戻り値：**書き込んだバイト数（i32）\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Wrote \" + typeof(written) + \" bytes\");  // \"Wrote 14 bytes\"\nf.close();\n```\n\n**例 - 複数行の書き込み：**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Line 1\\n\");\nf.write(\"Line 2\\n\");\nf.write(\"Line 3\\n\");\nf.close();\n```\n\n**例 - ログファイルへの追記：**\n```hemlock\nlet f = open(\"app.log\", \"a\");\nf.write(\"[INFO] Application started\\n\");\nf.write(\"[INFO] User logged in\\n\");\nf.close();\n```\n\n#### write_bytes(data: buffer): i32\n\nバイナリデータを書き込み（書き込んだバイト数を返す）。\n\n**パラメータ：**\n- `data`（buffer）- 書き込むバイナリデータ\n\n**戻り値：**書き込んだバイト数（i32）\n\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// バイナリデータを作成\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\nlet bytes = f.write_bytes(buf);\nprint(\"Wrote \" + typeof(bytes) + \" bytes\");\n\nf.close();\n```\n\n**例 - バイナリファイルのコピー：**\n```hemlock\nlet src = open(\"input.bin\", \"r\");\nlet dst = open(\"output.bin\", \"w\");\n\nlet data = src.read_bytes(1024);\nwhile (data.length > 0) {\n    dst.write_bytes(data);\n    data = src.read_bytes(1024);\n}\n\nsrc.close();\ndst.close();\n```\n\n### シーク\n\n#### seek(position: i32): i32\n\n特定の位置に移動（新しい位置を返す）。\n\n**パラメータ：**\n- `position`（i32）- ファイル先頭からのバイトオフセット\n\n**戻り値：**新しい位置（i32）\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// バイト100に移動\nf.seek(100);\n\n// 位置100から読み取り\nlet data = f.read(50);\n\n// 先頭にリセット\nf.seek(0);\n\nf.close();\n```\n\n**例 - ランダムアクセス：**\n```hemlock\nlet f = open(\"records.dat\", \"r\");\n\n// オフセット1000のレコードを読み取り\nf.seek(1000);\nlet record1 = f.read_bytes(100);\n\n// オフセット2000のレコードを読み取り\nf.seek(2000);\nlet record2 = f.read_bytes(100);\n\nf.close();\n```\n\n#### tell(): i32\n\nファイル内の現在位置を取得。\n\n**戻り値：**現在のバイトオフセット（i32）\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet pos1 = f.tell();  // 0（先頭）\n\nf.read(100);\nlet pos2 = f.tell();  // 100（100バイト読み取り後）\n\nf.seek(500);\nlet pos3 = f.tell();  // 500（シーク後）\n\nf.close();\n```\n\n**例 - 読み取り量の測定：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet start = f.tell();\nlet content = f.read();\nlet end = f.tell();\n\nlet bytes_read = end - start;\nprint(\"Read \" + typeof(bytes_read) + \" bytes\");\n\nf.close();\n```\n\n### クローズ\n\n#### close()\n\nファイルを閉じる（冪等、複数回呼び出し可能）。\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n// ...ファイルを使用\nf.close();\nf.close();  // 安全 - 2回目のクローズでエラーなし\n```\n\n**重要な注意事項：**\n- ファイルディスクリプタのリークを避けるため、常に完了時にファイルを閉じる\n- クローズは冪等 - 複数回安全に呼び出し可能\n- クローズ後、他のすべての操作はエラーになる\n- エラー時でもファイルが閉じられるように`finally`ブロックを使用\n\n## ファイルプロパティ\n\nFileオブジェクトには3つの読み取り専用プロパティがあります：\n\n### path: string\n\nファイルを開くために使用されたファイルパス。\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);  // \"/path/to/file.txt\"\nf.close();\n```\n\n### mode: string\n\nファイルが開かれたモード。\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);  // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);  // \"w\"\nf2.close();\n```\n\n### closed: bool\n\nファイルが閉じられているかどうか。\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n**例 - ファイルが開いているか確認：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ...コンテンツを処理\n}\n\nf.close();\n\nif (f.closed) {\n    print(\"File is now closed\");\n}\n```\n\n## エラー処理\n\nすべてのファイル操作にはコンテキスト付きの適切なエラーメッセージが含まれます。\n\n### 一般的なエラー\n\n**ファイルが見つからない：**\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// エラー: Failed to open 'missing.txt': No such file or directory\n```\n\n**閉じたファイルからの読み取り：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// エラー: Cannot read from closed file 'data.txt'\n```\n\n**読み取り専用ファイルへの書き込み：**\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// エラー: Cannot write to file 'readonly.txt' opened in read-only mode\n```\n\n**書き込み専用ファイルからの読み取り：**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.read();\n// エラー: Cannot read from file 'output.txt' opened in write-only mode\n```\n\n### try/catchの使用\n\n```hemlock\ntry {\n    let f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    f.close();\n    process(content);\n} catch (e) {\n    print(\"Error reading file: \" + e);\n}\n```\n\n## リソース管理\n\n### 基本パターン\n\n常にファイルを明示的に閉じる：\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### エラー処理付き（推奨）\n\nエラー時でもファイルが閉じられるように`finally`を使用：\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // エラーでも常に閉じる\n}\n```\n\n### 複数ファイル\n\n```hemlock\nlet src = null;\nlet dst = null;\n\ntry {\n    src = open(\"input.txt\", \"r\");\n    dst = open(\"output.txt\", \"w\");\n\n    let content = src.read();\n    dst.write(content);\n} finally {\n    if (src != null) { src.close(); }\n    if (dst != null) { dst.close(); }\n}\n```\n\n### ヘルパー関数パターン\n\n```hemlock\nfn with_file(path: string, mode: string, callback) {\n    let f = open(path, mode);\n    try {\n        return callback(f);\n    } finally {\n        f.close();\n    }\n}\n\n// 使用方法：\nwith_file(\"data.txt\", \"r\", fn(f) {\n    return f.read();\n});\n```\n\n## 完全なAPIリファレンス\n\n### 関数\n\n| 関数 | パラメータ | 戻り値 | 説明 |\n|----------|-----------|---------|-------------|\n| `open(path, mode?)` | path: string, mode?: string | File | ファイルを開く（モードのデフォルトは\"r\"） |\n\n### メソッド\n\n| メソッド | パラメータ | 戻り値 | 説明 |\n|--------|-----------|---------|-------------|\n| `read(size?)` | size?: i32 | string | テキストを読み取り（すべてまたは特定バイト） |\n| `read_bytes(size)` | size: i32 | buffer | バイナリデータを読み取り |\n| `write(data)` | data: string | i32 | テキストを書き込み、書き込んだバイト数を返す |\n| `write_bytes(data)` | data: buffer | i32 | バイナリデータを書き込み、書き込んだバイト数を返す |\n| `seek(position)` | position: i32 | i32 | 位置にシーク、新しい位置を返す |\n| `tell()` | - | i32 | 現在位置を取得 |\n| `close()` | - | null | ファイルを閉じる（冪等） |\n\n### プロパティ（読み取り専用）\n\n| プロパティ | 型 | 説明 |\n|----------|------|-------------|\n| `path` | string | ファイルパス |\n| `mode` | string | オープンモード |\n| `closed` | bool | ファイルが閉じられているかどうか |\n\n## 一般的なパターン\n\n### ファイル全体の読み取り\n\n```hemlock\nfn read_file(path: string): string {\n    let f = open(path, \"r\");\n    try {\n        return f.read();\n    } finally {\n        f.close();\n    }\n}\n\nlet content = read_file(\"config.json\");\n```\n\n### ファイル全体の書き込み\n\n```hemlock\nfn write_file(path: string, content: string) {\n    let f = open(path, \"w\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\");\n```\n\n### ファイルへの追記\n\n```hemlock\nfn append_file(path: string, content: string) {\n    let f = open(path, \"a\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nappend_file(\"log.txt\", \"[INFO] Event occurred\\n\");\n```\n\n### 行の読み取り\n\n```hemlock\nfn read_lines(path: string) {\n    let f = open(path, \"r\");\n    try {\n        let content = f.read();\n        return content.split(\"\\n\");\n    } finally {\n        f.close();\n    }\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### 大きなファイルのチャンク処理\n\n```hemlock\nfn process_large_file(path: string) {\n    let f = open(path, \"r\");\n    try {\n        while (true) {\n            let chunk = f.read(4096);  // 4KBチャンク\n            if (chunk == \"\") { break; }\n\n            // チャンクを処理\n            process_chunk(chunk);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n### バイナリファイルコピー\n\n```hemlock\nfn copy_file(src_path: string, dst_path: string) {\n    let src = null;\n    let dst = null;\n\n    try {\n        src = open(src_path, \"r\");\n        dst = open(dst_path, \"w\");\n\n        while (true) {\n            let chunk = src.read_bytes(4096);\n            if (chunk.length == 0) { break; }\n\n            dst.write_bytes(chunk);\n        }\n    } finally {\n        if (src != null) { src.close(); }\n        if (dst != null) { dst.close(); }\n    }\n}\n\ncopy_file(\"input.dat\", \"output.dat\");\n```\n\n### ファイルの切り詰め\n\n```hemlock\nfn truncate_file(path: string) {\n    let f = open(path, \"w\");  // \"w\"モードは切り詰め\n    f.close();\n}\n\ntruncate_file(\"empty_me.txt\");\n```\n\n### ランダムアクセス読み取り\n\n```hemlock\nfn read_at_offset(path: string, offset: i32, size: i32): string {\n    let f = open(path, \"r\");\n    try {\n        f.seek(offset);\n        return f.read(size);\n    } finally {\n        f.close();\n    }\n}\n\nlet data = read_at_offset(\"records.dat\", 1000, 100);\n```\n\n### ファイルサイズ\n\n```hemlock\nfn file_size(path: string): i32 {\n    let f = open(path, \"r\");\n    try {\n        // 末尾にシーク\n        let end = f.seek(999999999);  // 大きな数\n        f.seek(0);  // リセット\n        return end;\n    } finally {\n        f.close();\n    }\n}\n\nlet size = file_size(\"data.txt\");\nprint(\"File size: \" + typeof(size) + \" bytes\");\n```\n\n### 条件付き読み書き\n\n```hemlock\nfn update_file(path: string, condition, new_content: string) {\n    let f = open(path, \"r+\");\n    try {\n        let content = f.read();\n\n        if (condition(content)) {\n            f.seek(0);  // 先頭にリセット\n            f.write(new_content);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n## ベストプラクティス\n\n### 1. 常にtry/finallyを使用\n\n```hemlock\n// 良い例\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();\n}\n\n// 悪い例 - エラー時にファイルが閉じられない可能性\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprocess(content);  // これがスローするとファイルがリーク\nf.close();\n```\n\n### 2. 操作前にファイル状態を確認\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ...コンテンツを使用\n}\n\nf.close();\n```\n\n### 3. 適切なモードを使用\n\n```hemlock\n// 読み取りのみ？\"r\"を使用\nlet f = open(\"config.json\", \"r\");\n\n// 完全に置換？\"w\"を使用\nlet f = open(\"output.txt\", \"w\");\n\n// 末尾に追加？\"a\"を使用\nlet f = open(\"log.txt\", \"a\");\n```\n\n### 4. エラーを優雅に処理\n\n```hemlock\nfn safe_read_file(path: string): string {\n    try {\n        let f = open(path, \"r\");\n        try {\n            return f.read();\n        } finally {\n            f.close();\n        }\n    } catch (e) {\n        print(\"Warning: Could not read \" + path + \": \" + e);\n        return \"\";\n    }\n}\n```\n\n### 5. 開いた逆順でファイルを閉じる\n\n```hemlock\nlet f1 = null;\nlet f2 = null;\nlet f3 = null;\n\ntry {\n    f1 = open(\"file1.txt\", \"r\");\n    f2 = open(\"file2.txt\", \"r\");\n    f3 = open(\"file3.txt\", \"r\");\n\n    // ...ファイルを使用\n} finally {\n    // 逆順で閉じる\n    if (f3 != null) { f3.close(); }\n    if (f2 != null) { f2.close(); }\n    if (f1 != null) { f1.close(); }\n}\n```\n\n### 6. 大きなファイルは全体を読み取らない\n\n```hemlock\n// 大きなファイルには悪い例\nlet f = open(\"huge.log\", \"r\");\nlet content = f.read();  // ファイル全体をメモリにロード\nf.close();\n\n// 良い例 - チャンクで処理\nlet f = open(\"huge.log\", \"r\");\ntry {\n    while (true) {\n        let chunk = f.read(4096);\n        if (chunk == \"\") { break; }\n        process_chunk(chunk);\n    }\n} finally {\n    f.close();\n}\n```\n\n## まとめ\n\nHemlockのファイルI/O APIは以下を提供します：\n\n- シンプルで明示的なファイル操作\n- テキストとバイナリのサポート\n- seek/tellによるランダムアクセス\n- コンテキスト付きの明確なエラーメッセージ\n- 冪等なクローズ操作\n\n覚えておくべきこと：\n- 常にファイルを手動で閉じる\n- リソース安全のためにtry/finallyを使用\n- 適切なオープンモードを選択\n- エラーを優雅に処理\n- 大きなファイルはチャンクで処理\n"}, "高度なトピック -> Memory Ownership": {"id": "advanced-memory-ownership", "content": "# Hemlockにおけるメモリ所有権\n\n> 「安全であるためのツールを提供しますが、使用を強制しません。」\n\nこのドキュメントでは、Hemlockのメモリ所有権セマンティクスについて説明し、プログラマ管理メモリとランタイム管理値の両方をカバーします。\n\n## 目次\n\n1. [契約](#契約)\n2. [プログラマ管理メモリ](#プログラマ管理メモリ)\n3. [ランタイム管理値](#ランタイム管理値)\n4. [所有権移転ポイント](#所有権移転ポイント)\n5. [非同期と並行性](#非同期と並行性)\n6. [FFIメモリルール](#ffiメモリルール)\n7. [例外安全性](#例外安全性)\n8. [ベストプラクティス](#ベストプラクティス)\n\n---\n\n## 契約\n\nHemlockはメモリ管理責任を明確に分離しています：\n\n| メモリタイプ | 管理者 | クリーンアップ方法 |\n|-------------|--------|-------------------|\n| 生ポインタ (`ptr`) | **プログラマ** | `free(ptr)` |\n| バッファ (`buffer`) | **プログラマ** | `free(buf)` |\n| 文字列、配列、オブジェクト | **ランタイム** | 自動（参照カウント） |\n| 関数、クロージャ | **ランタイム** | 自動（参照カウント） |\n| タスク、チャネル | **ランタイム** | 自動（参照カウント） |\n\n**核心原則：** 明示的に割り当てたものは、明示的に解放します。それ以外は自動的に処理されます。\n\n---\n\n## プログラマ管理メモリ\n\n### 生ポインタ\n\n```hemlock\nlet p = alloc(64);       // 64バイトを割り当て\nmemset(p, 0, 64);        // 初期化\n// ... メモリを使用 ...\nfree(p);                 // あなたの責任！\n```\n\n**ルール：**\n- `alloc()` はあなたが所有するメモリを返す\n- 使い終わったら `free()` を呼ぶ必要がある\n- 二重解放はクラッシュする（意図的）\n- 解放後使用は未定義動作\n- ポインタ演算は許可されるが未チェック\n\n### 型付き割り当て\n\n```hemlock\nlet arr = talloc(\"i32\", 100);  // 100個のi32を割り当て（400バイト）\nptr_write_i32(arr, 0, 42);     // インデックス0に書き込み\nlet val = ptr_read_i32(arr, 0); // インデックス0から読み取り\nfree(arr);                      // まだあなたの責任\n```\n\n### バッファ（安全な代替）\n\n```hemlock\nlet buf = buffer(64);    // 境界チェック付きバッファ\nbuf[0] = 42;             // 安全なインデックスアクセス\n// buf[100] = 1;         // ランタイムエラー：範囲外\nfree(buf);               // 明示的なfreeが必要\n```\n\n**主な違い：** バッファは境界チェックを提供、生ポインタは提供しない。\n\n---\n\n## ランタイム管理値\n\n### 参照カウント\n\nヒープ割り当て値はアトミック参照カウントを使用：\n\n```hemlock\nlet s1 = \"hello\";        // 文字列割り当て、refcount = 1\nlet s2 = s1;             // s2はs1を共有、refcount = 2\n// 両方がスコープ外に出ると、refcount → 0、メモリ解放\n```\n\n**参照カウントされる型：**\n- `string` - UTF-8テキスト\n- `array` - 動的配列\n- `object` - キー・バリューオブジェクト\n- `function` - クロージャ\n- `task` - 非同期タスクハンドル\n- `channel` - 通信チャネル\n\n### 循環検出\n\nランタイムはオブジェクトグラフの循環を処理：\n\n```hemlock\nlet a = { ref: null };\nlet b = { ref: a };\na.ref = b;               // 循環: a → b → a\n// ランタイムは訪問済みセットを使用してクリーンアップ中に循環を検出・破壊\n```\n\n---\n\n## 所有権移転ポイント\n\n### 変数バインディング\n\n```hemlock\nlet x = [1, 2, 3];       // 配列作成、refcount 1\n                         // xが参照を所有\n```\n\n### 関数戻り値\n\n```hemlock\nfn make_array() {\n    return [1, 2, 3];    // 配列の所有権が呼び出し元に移転\n}\nlet arr = make_array();  // arrが参照を所有\n```\n\n### 代入\n\n```hemlock\nlet a = \"hello\";\nlet b = a;               // 共有参照（refcountインクリメント）\nb = \"world\";             // aはまだ\"hello\"、bは\"world\"\n```\n\n### チャネル操作\n\n```hemlock\nlet ch = channel(10);\nch.send(\"message\");      // 値がチャネルバッファにコピー\n                         // オリジナルは有効なまま\n\nlet msg = ch.recv();     // チャネルから所有権を受け取る\n```\n\n### タスクスポーン\n\n```hemlock\nlet data = { x: 1 };\nlet task = spawn(worker, data);  // dataは分離のためディープコピー\ndata.x = 2;                       // 安全 - タスクは自分のコピーを持つ\nlet result = join(task);          // resultの所有権が呼び出し元に移転\n```\n\n---\n\n## 非同期と並行性\n\n### スレッド分離\n\nスポーンされたタスクはミュータブル引数の**ディープコピー**を受け取る：\n\n```hemlock\nasync fn worker(data) {\n    data.x = 100;        // タスクのコピーのみを変更\n    return data;\n}\n\nlet obj = { x: 1 };\nlet task = spawn(worker, obj);\nobj.x = 2;               // 安全 - タスクに影響しない\nlet result = join(task);\nprint(obj.x);            // 2（タスクによって変更されていない）\nprint(result.x);         // 100（タスクの変更されたコピー）\n```\n\n### 共有コーディネーションオブジェクト\n\n一部の型は参照で共有される（コピーされない）：\n- **チャネル** - タスク間通信用\n- **タスク** - コーディネーション用（join/detach）\n\n```hemlock\nlet ch = channel(1);\nspawn(producer, ch);     // 同じチャネル、コピーではない\nspawn(consumer, ch);     // 両方のタスクがチャネルを共有\n```\n\n### タスク結果\n\n```hemlock\nlet task = spawn(compute);\nlet result = join(task);  // 呼び出し元が結果を所有\n                          // タスクの参照はタスク解放時に解放\n```\n\n### デタッチされたタスク\n\n```hemlock\ndetach(spawn(background_work));\n// タスクは独立して実行\n// 結果はタスク完了時に自動解放\n// join()を呼ばなくてもリークなし\n```\n\n---\n\n## FFIメモリルール\n\n### C関数への受け渡し\n\n```hemlock\nextern fn strlen(s: string): i32;\n\nlet s = \"hello\";\nlet len = strlen(s);     // Hemlockが所有権を保持\n                         // 文字列は呼び出し中有効\n                         // C関数は解放してはいけない\n```\n\n### C関数からの受け取り\n\n```hemlock\nextern fn strdup(s: string): ptr;\n\nlet copy = strdup(\"hello\");  // Cがこのメモリを割り当てた\nfree(copy);                   // 解放はあなたの責任\n```\n\n### 構造体の受け渡し（コンパイラのみ）\n\n```hemlock\n// C構造体レイアウトを定義\nffi_struct Point { x: f64, y: f64 }\n\nextern fn make_point(x: f64, y: f64): Point;\n\nlet p = make_point(1.0, 2.0);  // 値で返され、コピーされる\n                                // スタック構造体のクリーンアップ不要\n```\n\n### コールバックメモリ\n\n```hemlock\n// CがHemlockにコールバックする時：\n// - 引数はCが所有（解放しない）\n// - 戻り値の所有権はCに移転\n```\n\n---\n\n## 例外安全性\n\n### 保証\n\nランタイムは以下を保証：\n\n1. **正常終了時リークなし** - すべてのランタイム管理値がクリーンアップ\n2. **例外時リークなし** - スタックアンワインド中に一時値が解放\n3. **例外時もdefer実行** - クリーンアップコードが実行\n\n### 式評価\n\n```hemlock\n// 配列作成中にスローした場合：\nlet arr = [f(), g(), h()];  // 部分的な配列は解放\n\n// 関数呼び出し中にスローした場合：\nfoo(a(), b(), c());         // 以前に評価された引数は解放\n```\n\n### クリーンアップ用Defer\n\n```hemlock\nfn process_file() {\n    let f = open(\"data.txt\", \"r\");\n    defer f.close();         // returnまたは例外時に実行\n\n    let data = f.read();\n    if (data == \"\") {\n        throw \"Empty file\";  // f.close()は実行される！\n    }\n    return data;\n}\n```\n\n---\n\n## ベストプラクティス\n\n### 1. ランタイム管理型を優先\n\n```hemlock\n// これを優先：\nlet data = [1, 2, 3, 4, 5];\n\n// これより（低レベル制御が必要でない限り）：\nlet data = talloc(\"i32\", 5);\n// ... 解放を忘れずに ...\n```\n\n### 2. 手動メモリにはDeferを使用\n\n```hemlock\nfn process() {\n    let buf = alloc(1024);\n    defer free(buf);        // 確実なクリーンアップ\n\n    // ... bufを使用 ...\n    // 各returnポイントでfreeする必要なし\n}\n```\n\n### 3. 非同期で生ポインタを避ける\n\n```hemlock\n// 間違い - タスク完了前にポインタが解放される可能性\nlet p = alloc(64);\nspawn(worker, p);          // タスクはポインタ値を取得\nfree(p);                   // おっと！タスクがまだ使用中\n\n// 正しい - チャネルを使うかデータをコピー\nlet ch = channel(1);\nlet data = buffer(64);\n// ... dataを埋める ...\nch.send(data);             // ディープコピー\nspawn(worker, ch);\nfree(data);                // 安全 - タスクは自分のコピーを持つ\n```\n\n### 4. 完了時にチャネルを閉じる\n\n```hemlock\nlet ch = channel(10);\n// ... チャネルを使用 ...\nch.close();                // バッファされた値をドレインして解放\n```\n\n### 5. タスクはJoinかDetach\n\n```hemlock\nlet task = spawn(work);\n\n// オプション1: 結果を待つ\nlet result = join(task);\n\n// オプション2: Fire and forget\n// detach(task);\n\n// してはいけない: joinかdetachせずにタスクハンドルをスコープ外に\n// （クリーンアップされるが、結果がリークする可能性）\n```\n\n---\n\n## メモリ問題のデバッグ\n\n### ASANを有効化\n\n```bash\nmake asan\nASAN_OPTIONS=detect_leaks=1 ./hemlock script.hml\n```\n\n### リーク回帰テストを実行\n\n```bash\nmake leak-regression       # フルスイート\nmake leak-regression-quick # 包括的テストをスキップ\n```\n\n### Valgrind\n\n```bash\nmake valgrind-check FILE=script.hml\n```\n\n---\n\n## まとめ\n\n| 操作 | メモリ動作 |\n|------|-----------|\n| `alloc(n)` | 割り当て、あなたが解放 |\n| `buffer(n)` | 境界チェック付き割り当て、あなたが解放 |\n| `\"string\"` | ランタイムが管理 |\n| `[array]` | ランタイムが管理 |\n| `{object}` | ランタイムが管理 |\n| `spawn(fn)` | 引数をディープコピー、ランタイムがタスクを管理 |\n| `join(task)` | 呼び出し元が結果を所有 |\n| `detach(task)` | 完了時にランタイムが結果を解放 |\n| `ch.send(v)` | チャネルに値をコピー |\n| `ch.recv()` | 呼び出し元が受信値を所有 |\n| `ch.close()` | バッファされた値をドレインして解放 |\n"}, "高度なトピック -> アトミック操作": {"id": "advanced-atomics", "content": "# アトミック操作\n\nHemlockは**ロックフリー並行プログラミング**のためのアトミック操作を提供します。これらの操作により、従来のロックやミューテックスを使用せずに、複数のスレッド間で共有メモリを安全に操作できます。\n\n## 目次\n\n- [概要](#概要)\n- [アトミックを使用する場面](#アトミックを使用する場面)\n- [メモリモデル](#メモリモデル)\n- [アトミックロードとストア](#アトミックロードとストア)\n- [フェッチアンドモディファイ操作](#フェッチアンドモディファイ操作)\n- [コンペアアンドスワップ (CAS)](#コンペアアンドスワップ-cas)\n- [アトミックエクスチェンジ](#アトミックエクスチェンジ)\n- [メモリフェンス](#メモリフェンス)\n- [関数リファレンス](#関数リファレンス)\n- [一般的なパターン](#一般的なパターン)\n- [ベストプラクティス](#ベストプラクティス)\n- [制限事項](#制限事項)\n\n---\n\n## 概要\n\nアトミック操作は、中断の可能性なく完了する**不可分**な操作です。あるスレッドがアトミック操作を実行している間、他のスレッドはその操作が部分的に完了した状態を観察することはできません。\n\n**主な特徴:**\n- すべての操作で**逐次一貫性**（`memory_order_seq_cst`）を使用\n- サポートされる型: **i32** と **i64**\n- `alloc()`で確保した生ポインタに対して動作\n- 明示的なロックなしでスレッドセーフ\n\n**利用可能な操作:**\n- Load/Store - アトミックに値を読み書き\n- Add/Sub - 古い値を返す算術演算\n- And/Or/Xor - 古い値を返すビット演算\n- CAS - 条件付き更新のためのコンペアアンドスワップ\n- Exchange - アトミックに値を交換\n- Fence - 完全なメモリバリア\n\n---\n\n## アトミックを使用する場面\n\n**アトミックを使用すべき場合:**\n- タスク間で共有されるカウンタ（例：リクエスト数、進捗追跡）\n- フラグとステータスインジケータ\n- ロックフリーデータ構造\n- 単純な同期プリミティブ\n- パフォーマンスが重要な並行コード\n\n**代わりにチャネルを使用すべき場合:**\n- タスク間で複雑なデータを渡す場合\n- プロデューサー・コンシューマーパターンを実装する場合\n- メッセージパッシングセマンティクスが必要な場合\n\n**使用例 - 共有カウンタ:**\n```hemlock\n// 共有カウンタを確保\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nasync fn worker(counter: ptr, id: i32) {\n    let i = 0;\n    while (i < 1000) {\n        atomic_add_i32(counter, 1);\n        i = i + 1;\n    }\n}\n\n// 複数のワーカーを生成\nlet t1 = spawn(worker, counter, 1);\nlet t2 = spawn(worker, counter, 2);\nlet t3 = spawn(worker, counter, 3);\n\njoin(t1);\njoin(t2);\njoin(t3);\n\n// カウンタは正確に3000になる（データ競合なし）\nprint(atomic_load_i32(counter));\n\nfree(counter);\n```\n\n---\n\n## メモリモデル\n\nすべてのHemlockアトミック操作は**逐次一貫性**（`memory_order_seq_cst`）を使用し、最も強いメモリ順序保証を提供します：\n\n1. **アトミック性**: 各操作は不可分\n2. **全順序付け**: すべてのスレッドが同じ操作順序を観察\n3. **リオーダリングなし**: コンパイラやCPUによる操作の並び替えなし\n\nこれにより、弱いメモリ順序付けと比較して潜在的なパフォーマンスコストはありますが、並行コードの推論が簡単になります。\n\n---\n\n## アトミックロードとストア\n\n### atomic_load_i32 / atomic_load_i64\n\nメモリから値をアトミックに読み取ります。\n\n**シグネチャ:**\n```hemlock\natomic_load_i32(ptr: ptr): i32\natomic_load_i64(ptr: ptr): i64\n```\n\n**パラメータ:**\n- `ptr` - メモリ位置へのポインタ（適切にアラインされている必要あり）\n\n**戻り値:** メモリ位置の値\n\n**例:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\n\nlet value = atomic_load_i32(p);\nprint(value);  // 42\n\nfree(p);\n```\n\n---\n\n### atomic_store_i32 / atomic_store_i64\n\nメモリに値をアトミックに書き込みます。\n\n**シグネチャ:**\n```hemlock\natomic_store_i32(ptr: ptr, value: i32): null\natomic_store_i64(ptr: ptr, value: i64): null\n```\n\n**パラメータ:**\n- `ptr` - メモリ位置へのポインタ\n- `value` - 格納する値\n\n**戻り値:** `null`\n\n**例:**\n```hemlock\nlet p = alloc(8);\n\natomic_store_i64(p, 5000000000);\nprint(atomic_load_i64(p));  // 5000000000\n\nfree(p);\n```\n\n---\n\n## フェッチアンドモディファイ操作\n\nこれらの操作は値をアトミックに変更し、**古い**（変更前の）値を返します。\n\n### atomic_add_i32 / atomic_add_i64\n\n値にアトミックに加算します。\n\n**シグネチャ:**\n```hemlock\natomic_add_i32(ptr: ptr, value: i32): i32\natomic_add_i64(ptr: ptr, value: i64): i64\n```\n\n**戻り値:** **古い**値（加算前）\n\n**例:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_add_i32(p, 10);\nprint(old);                    // 100（古い値）\nprint(atomic_load_i32(p));     // 110（新しい値）\n\nfree(p);\n```\n\n---\n\n### atomic_sub_i32 / atomic_sub_i64\n\n値からアトミックに減算します。\n\n**シグネチャ:**\n```hemlock\natomic_sub_i32(ptr: ptr, value: i32): i32\natomic_sub_i64(ptr: ptr, value: i64): i64\n```\n\n**戻り値:** **古い**値（減算前）\n\n**例:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_sub_i32(p, 25);\nprint(old);                    // 100（古い値）\nprint(atomic_load_i32(p));     // 75（新しい値）\n\nfree(p);\n```\n\n---\n\n### atomic_and_i32 / atomic_and_i64\n\nビット単位ANDをアトミックに実行します。\n\n**シグネチャ:**\n```hemlock\natomic_and_i32(ptr: ptr, value: i32): i32\natomic_and_i64(ptr: ptr, value: i64): i64\n```\n\n**戻り値:** **古い**値（AND前）\n\n**例:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xFF);  // 2進数で255: 11111111\n\nlet old = atomic_and_i32(p, 0x0F);  // 00001111とAND\nprint(old);                    // 255（古い値）\nprint(atomic_load_i32(p));     // 15（0xFF & 0x0F = 0x0F）\n\nfree(p);\n```\n\n---\n\n### atomic_or_i32 / atomic_or_i64\n\nビット単位ORをアトミックに実行します。\n\n**シグネチャ:**\n```hemlock\natomic_or_i32(ptr: ptr, value: i32): i32\natomic_or_i64(ptr: ptr, value: i64): i64\n```\n\n**戻り値:** **古い**値（OR前）\n\n**例:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0x0F);  // 2進数で15: 00001111\n\nlet old = atomic_or_i32(p, 0xF0);  // 11110000とOR\nprint(old);                    // 15（古い値）\nprint(atomic_load_i32(p));     // 255（0x0F | 0xF0 = 0xFF）\n\nfree(p);\n```\n\n---\n\n### atomic_xor_i32 / atomic_xor_i64\n\nビット単位XORをアトミックに実行します。\n\n**シグネチャ:**\n```hemlock\natomic_xor_i32(ptr: ptr, value: i32): i32\natomic_xor_i64(ptr: ptr, value: i64): i64\n```\n\n**戻り値:** **古い**値（XOR前）\n\n**例:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xAA);  // 2進数で170: 10101010\n\nlet old = atomic_xor_i32(p, 0xFF);  // 11111111とXOR\nprint(old);                    // 170（古い値）\nprint(atomic_load_i32(p));     // 85（0xAA ^ 0xFF = 0x55）\n\nfree(p);\n```\n\n---\n\n## コンペアアンドスワップ (CAS)\n\n最も強力なアトミック操作です。現在の値と期待値をアトミックに比較し、一致する場合は新しい値で置き換えます。\n\n### atomic_cas_i32 / atomic_cas_i64\n\n**シグネチャ:**\n```hemlock\natomic_cas_i32(ptr: ptr, expected: i32, desired: i32): bool\natomic_cas_i64(ptr: ptr, expected: i64, desired: i64): bool\n```\n\n**パラメータ:**\n- `ptr` - メモリ位置へのポインタ\n- `expected` - 期待する値\n- `desired` - 期待値と一致した場合に格納する値\n\n**戻り値:**\n- `true` - スワップ成功（値が`expected`だったので`desired`になった）\n- `false` - スワップ失敗（値が`expected`ではなかったので変更なし）\n\n**例:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\n// CAS成功: 値は100なので999にスワップ\nlet success1 = atomic_cas_i32(p, 100, 999);\nprint(success1);               // true\nprint(atomic_load_i32(p));     // 999\n\n// CAS失敗: 値は999であり100ではない\nlet success2 = atomic_cas_i32(p, 100, 888);\nprint(success2);               // false\nprint(atomic_load_i32(p));     // 999（変更なし）\n\nfree(p);\n```\n\n**ユースケース:**\n- ロックとセマフォの実装\n- ロックフリーデータ構造\n- 楽観的並行制御\n- アトミックな条件付き更新\n\n---\n\n## アトミックエクスチェンジ\n\n値をアトミックにスワップし、古い値を返します。\n\n### atomic_exchange_i32 / atomic_exchange_i64\n\n**シグネチャ:**\n```hemlock\natomic_exchange_i32(ptr: ptr, value: i32): i32\natomic_exchange_i64(ptr: ptr, value: i64): i64\n```\n\n**パラメータ:**\n- `ptr` - メモリ位置へのポインタ\n- `value` - 格納する新しい値\n\n**戻り値:** **古い**値（交換前）\n\n**例:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_exchange_i32(p, 200);\nprint(old);                    // 100（古い値）\nprint(atomic_load_i32(p));     // 200（新しい値）\n\nfree(p);\n```\n\n---\n\n## メモリフェンス\n\n完全なメモリバリアで、フェンス前のすべてのメモリ操作が、フェンス後の操作の前にすべてのスレッドから可視になることを保証します。\n\n### atomic_fence\n\n**シグネチャ:**\n```hemlock\natomic_fence(): null\n```\n\n**戻り値:** `null`\n\n**例:**\n```hemlock\n// 以前のすべての書き込みが可視になることを保証\natomic_fence();\n```\n\n**注意:** ほとんどの場合、すべてのアトミック操作が既に逐次一貫性を使用しているため、明示的なフェンスは必要ありません。フェンスは非アトミックメモリ操作を同期する必要がある場合に有用です。\n\n---\n\n## 関数リファレンス\n\n### i32操作\n\n| 関数 | シグネチャ | 戻り値 | 説明 |\n|----------|-----------|---------|-------------|\n| `atomic_load_i32` | `(ptr)` | `i32` | アトミックに値をロード |\n| `atomic_store_i32` | `(ptr, value)` | `null` | アトミックに値をストア |\n| `atomic_add_i32` | `(ptr, value)` | `i32` | 加算して古い値を返す |\n| `atomic_sub_i32` | `(ptr, value)` | `i32` | 減算して古い値を返す |\n| `atomic_and_i32` | `(ptr, value)` | `i32` | ビット単位ANDして古い値を返す |\n| `atomic_or_i32` | `(ptr, value)` | `i32` | ビット単位ORして古い値を返す |\n| `atomic_xor_i32` | `(ptr, value)` | `i32` | ビット単位XORして古い値を返す |\n| `atomic_cas_i32` | `(ptr, expected, desired)` | `bool` | コンペアアンドスワップ |\n| `atomic_exchange_i32` | `(ptr, value)` | `i32` | 交換して古い値を返す |\n\n### i64操作\n\n| 関数 | シグネチャ | 戻り値 | 説明 |\n|----------|-----------|---------|-------------|\n| `atomic_load_i64` | `(ptr)` | `i64` | アトミックに値をロード |\n| `atomic_store_i64` | `(ptr, value)` | `null` | アトミックに値をストア |\n| `atomic_add_i64` | `(ptr, value)` | `i64` | 加算して古い値を返す |\n| `atomic_sub_i64` | `(ptr, value)` | `i64` | 減算して古い値を返す |\n| `atomic_and_i64` | `(ptr, value)` | `i64` | ビット単位ANDして古い値を返す |\n| `atomic_or_i64` | `(ptr, value)` | `i64` | ビット単位ORして古い値を返す |\n| `atomic_xor_i64` | `(ptr, value)` | `i64` | ビット単位XORして古い値を返す |\n| `atomic_cas_i64` | `(ptr, expected, desired)` | `bool` | コンペアアンドスワップ |\n| `atomic_exchange_i64` | `(ptr, value)` | `i64` | 交換して古い値を返す |\n\n### メモリバリア\n\n| 関数 | シグネチャ | 戻り値 | 説明 |\n|----------|-----------|---------|-------------|\n| `atomic_fence` | `()` | `null` | 完全なメモリバリア |\n\n---\n\n## 一般的なパターン\n\n### パターン: アトミックカウンタ\n\n```hemlock\n// スレッドセーフなカウンタ\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nfn increment(): i32 {\n    return atomic_add_i32(counter, 1);\n}\n\nfn decrement(): i32 {\n    return atomic_sub_i32(counter, 1);\n}\n\nfn get_count(): i32 {\n    return atomic_load_i32(counter);\n}\n\n// 使用法\nincrement();  // 0を返す（古い値）\nincrement();  // 1を返す\nincrement();  // 2を返す\nprint(get_count());  // 3\n\nfree(counter);\n```\n\n### パターン: スピンロック\n\n```hemlock\n// シンプルなスピンロック実装\nlet lock = alloc(4);\nptr_write_i32(lock, 0);  // 0 = アンロック、1 = ロック\n\nfn acquire() {\n    // ロックを0から1に設定できるまでスピン\n    while (!atomic_cas_i32(lock, 0, 1)) {\n        // ビジーウェイト\n    }\n}\n\nfn release() {\n    atomic_store_i32(lock, 0);\n}\n\n// 使用法\nacquire();\n// ... クリティカルセクション ...\nrelease();\n\nfree(lock);\n```\n\n### パターン: 一度だけの初期化\n\n```hemlock\nlet initialized = alloc(4);\nptr_write_i32(initialized, 0);  // 0 = 未初期化、1 = 初期化済み\n\nfn ensure_initialized() {\n    // 初期化する側になろうとする\n    if (atomic_cas_i32(initialized, 0, 1)) {\n        // 競争に勝ったので初期化を実行\n        do_expensive_init();\n    }\n    // そうでなければ、既に初期化済み\n}\n```\n\n### パターン: アトミックフラグ\n\n```hemlock\nlet flag = alloc(4);\nptr_write_i32(flag, 0);\n\nfn set_flag() {\n    atomic_store_i32(flag, 1);\n}\n\nfn clear_flag() {\n    atomic_store_i32(flag, 0);\n}\n\nfn test_and_set(): bool {\n    // フラグが既にセットされていればtrueを返す\n    return atomic_exchange_i32(flag, 1) == 1;\n}\n\nfn check_flag(): bool {\n    return atomic_load_i32(flag) == 1;\n}\n```\n\n### パターン: 境界付きカウンタ\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\nlet max_value = 100;\n\nfn try_increment(): bool {\n    while (true) {\n        let current = atomic_load_i32(counter);\n        if (current >= max_value) {\n            return false;  // 最大値に達している\n        }\n        if (atomic_cas_i32(counter, current, current + 1)) {\n            return true;  // インクリメント成功\n        }\n        // CAS失敗、他のスレッドが変更 - リトライ\n    }\n}\n```\n\n---\n\n## ベストプラクティス\n\n### 1. 適切なアラインメントを使用\n\nポインタはデータ型に対して適切にアラインされている必要があります：\n- i32: 4バイトアラインメント\n- i64: 8バイトアラインメント\n\n`alloc()`からのメモリは通常、適切にアラインされています。\n\n### 2. より高レベルの抽象化を優先\n\n可能な場合は、タスク間通信にチャネルを使用してください。アトミックは低レベルであり、注意深い推論が必要です。\n\n```hemlock\n// こちらを優先:\nlet ch = channel(10);\nspawn(fn() { ch.send(result); });\nlet value = ch.recv();\n\n// 適切な場合は手動のアトミック協調よりも\n```\n\n### 3. ABA問題に注意\n\nCASはABA問題の影響を受ける可能性があります：値がAからBに変わり、再びAに戻ります。CASは成功しますが、その間に状態が変わっている可能性があります。\n\n### 4. 共有前に初期化\n\nタスクを生成する前に、常にアトミック変数を初期化してください：\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);  // 生成前に初期化\n\nlet task = spawn(worker, counter);\n```\n\n### 5. すべてのタスク完了後に解放\n\nタスクがまだアクセスしている可能性がある間は、アトミックメモリを解放しないでください：\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nlet t1 = spawn(worker, counter);\nlet t2 = spawn(worker, counter);\n\njoin(t1);\njoin(t2);\n\n// これで解放しても安全\nfree(counter);\n```\n\n---\n\n## 制限事項\n\n### 現在の制限\n\n1. **i32とi64のみサポート** - 他の型に対するアトミック操作なし\n2. **ポインタアトミックなし** - ポインタをアトミックにロード/ストアできない\n3. **逐次一貫性のみ** - 弱いメモリ順序付けは利用不可\n4. **アトミック浮動小数点なし** - 必要な場合は整数表現を使用\n\n### プラットフォームに関する注意\n\n- アトミック操作は内部でC11の`<stdatomic.h>`を使用\n- POSIXスレッドをサポートするすべてのプラットフォームで利用可能\n- モダンな64ビットシステムではロックフリーであることが保証\n\n---\n\n## 関連項目\n\n- [非同期/並行処理](#advanced-async-concurrency) - タスクの生成とチャネル\n- [メモリ管理](#language-guide-memory) - ポインタとバッファの確保\n- [メモリAPI](#reference-memory-api) - 確保関数\n"}, "高度なトピック -> コマンドライン引数": {"id": "advanced-command-line-args", "content": "# Hemlockでのコマンドライン引数\n\nHemlockプログラムは、プログラム起動時に自動的に設定される組み込みの**`args`配列**を通じてコマンドライン引数にアクセスできます。\n\n## 目次\n\n- [概要](#概要)\n- [args配列](#args配列)\n- [プロパティ](#プロパティ)\n- [反復パターン](#反復パターン)\n- [一般的な使用ケース](#一般的な使用ケース)\n- [引数解析パターン](#引数解析パターン)\n- [ベストプラクティス](#ベストプラクティス)\n- [完全な例](#完全な例)\n\n## 概要\n\n`args`配列は、Hemlockプログラムに渡されたコマンドライン引数へのアクセスを提供します：\n\n- **常に利用可能** - すべてのHemlockプログラムで組み込みのグローバル変数\n- **スクリプト名を含む** - `args[0]`は常にスクリプトのパス/名前を含む\n- **文字列の配列** - すべての引数は文字列\n- **ゼロインデックス** - 標準的な配列インデックス（0, 1, 2, ...）\n\n## args配列\n\n### 基本構造\n\n```hemlock\n// args[0]は常にスクリプトのファイル名\n// args[1]からargs[n-1]が実際の引数\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // 引数の総数（スクリプト名を含む）\n```\n\n### 使用例\n\n**コマンド：**\n```bash\n./hemlock script.hml hello world \"test 123\"\n```\n\n**script.hml内：**\n```hemlock\nprint(\"Script name: \" + args[0]);     // \"script.hml\"\nprint(\"Total args: \" + typeof(args.length));  // \"4\"\nprint(\"First arg: \" + args[1]);       // \"hello\"\nprint(\"Second arg: \" + args[2]);      // \"world\"\nprint(\"Third arg: \" + args[3]);       // \"test 123\"\n```\n\n### インデックスリファレンス\n\n| インデックス | 内容 | 例の値 |\n|-------|----------|---------------|\n| `args[0]` | スクリプトパス/名前 | `\"script.hml\"`または`\"./script.hml\"` |\n| `args[1]` | 最初の引数 | `\"hello\"` |\n| `args[2]` | 2番目の引数 | `\"world\"` |\n| `args[3]` | 3番目の引数 | `\"test 123\"` |\n| ... | ... | ... |\n| `args[n-1]` | 最後の引数 | （可変） |\n\n## プロパティ\n\n### 常に存在\n\n`args`は**すべての**Hemlockプログラムで利用可能なグローバル配列です：\n\n```hemlock\n// 宣言やインポートは不要\nprint(args.length);  // すぐに動作\n```\n\n### スクリプト名を含む\n\n`args[0]`は常にスクリプトのパス/名前を含みます：\n\n```hemlock\nprint(\"Running: \" + args[0]);\n```\n\n**args[0]の可能な値：**\n- `\"script.hml\"` - ファイル名のみ\n- `\"./script.hml\"` - 相対パス\n- `\"/home/user/script.hml\"` - 絶対パス\n- スクリプトの呼び出し方法に依存\n\n### 型：文字列の配列\n\nすべての引数は文字列として格納されます：\n\n```hemlock\n// 引数: ./hemlock script.hml 42 3.14 true\n\nprint(args[1]);  // \"42\"（文字列、数値ではない）\nprint(args[2]);  // \"3.14\"（文字列、数値ではない）\nprint(args[3]);  // \"true\"（文字列、ブール値ではない）\n\n// 必要に応じて変換：\nlet num = 42;  // 必要に応じて手動でパース\n```\n\n### 最小長\n\n常に少なくとも1（スクリプト名）：\n\n```hemlock\nprint(args.length);  // 最小：1\n```\n\n**引数なしでも：**\n```bash\n./hemlock script.hml\n```\n\n```hemlock\n// script.hml内:\nprint(args.length);  // 1（スクリプト名のみ）\n```\n\n### REPLの動作\n\nREPLでは、`args.length`は0（空配列）です：\n\n```hemlock\n# REPLセッション\n> print(args.length);\n0\n```\n\n## 反復パターン\n\n### 基本的な反復\n\n`args[0]`（スクリプト名）をスキップして実際の引数を処理：\n\n```hemlock\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument \" + typeof(i) + \": \" + args[i]);\n    i = i + 1;\n}\n```\n\n**出力（`./hemlock script.hml foo bar baz`の場合）**\n```\nArgument 1: foo\nArgument 2: bar\nArgument 3: baz\n```\n\n### For-In反復（スクリプト名を含む）\n\n```hemlock\nfor (let arg in args) {\n    print(arg);\n}\n```\n\n**出力：**\n```\nscript.hml\nfoo\nbar\nbaz\n```\n\n### 引数数のチェック\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <argument>\");\n    // exitまたはreturn\n} else {\n    let arg = args[1];\n    // argを処理\n}\n```\n\n### スクリプト名以外のすべての引数を処理\n\n```hemlock\nlet actual_args = args.slice(1, args.length);\n\nfor (let arg in actual_args) {\n    print(\"Processing: \" + arg);\n}\n```\n\n## 一般的な使用ケース\n\n### 1. シンプルな引数処理\n\n必須引数のチェック：\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    print(\"Processing file: \" + filename);\n    // ...ファイルを処理\n}\n```\n\n**使用方法：**\n```bash\n./hemlock script.hml data.txt\n# 出力: Processing file: data.txt\n```\n\n### 2. 複数引数\n\n```hemlock\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <input> <output>\");\n} else {\n    let input_file = args[1];\n    let output_file = args[2];\n\n    print(\"Input: \" + input_file);\n    print(\"Output: \" + output_file);\n\n    // ファイルを処理...\n}\n```\n\n**使用方法：**\n```bash\n./hemlock convert.hml input.txt output.txt\n```\n\n### 3. 可変数の引数\n\n提供されたすべての引数を処理：\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        print(\"  \" + args[i]);\n        process_file(args[i]);\n        i = i + 1;\n    }\n}\n```\n\n**使用方法：**\n```bash\n./hemlock batch.hml file1.txt file2.txt file3.txt\n```\n\n### 4. ヘルプメッセージ\n\n```hemlock\nif (args.length < 2 || args[1] == \"--help\" || args[1] == \"-h\") {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show this help message\");\n    print(\"  -v, --verbose  Enable verbose output\");\n} else {\n    // 通常処理\n}\n```\n\n### 5. 引数の検証\n\n```hemlock\nfn validate_file(filename: string): bool {\n    // ファイルが存在するかチェック（例）\n    return filename != \"\";\n}\n\nif (args.length < 2) {\n    print(\"Error: No filename provided\");\n} else if (!validate_file(args[1])) {\n    print(\"Error: Invalid file: \" + args[1]);\n} else {\n    print(\"Processing: \" + args[1]);\n}\n```\n\n## 引数解析パターン\n\n### 名前付き引数（フラグ）\n\n名前付き引数のシンプルなパターン：\n\n```hemlock\nlet verbose = false;\nlet output_file = \"\";\nlet input_file = \"\";\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\" || args[i] == \"-v\") {\n        verbose = true;\n    } else if (args[i] == \"--output\" || args[i] == \"-o\") {\n        i = i + 1;\n        if (i < args.length) {\n            output_file = args[i];\n        }\n    } else {\n        input_file = args[i];\n    }\n    i = i + 1;\n}\n\nif (verbose) {\n    print(\"Verbose mode enabled\");\n}\nprint(\"Input: \" + input_file);\nprint(\"Output: \" + output_file);\n```\n\n**使用方法：**\n```bash\n./hemlock script.hml --verbose --output out.txt input.txt\n./hemlock script.hml -v -o out.txt input.txt\n```\n\n### ブールフラグ\n\n```hemlock\nlet debug = false;\nlet verbose = false;\nlet force = false;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--debug\") {\n        debug = true;\n    } else if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else if (args[i] == \"--force\") {\n        force = true;\n    }\n    i = i + 1;\n}\n```\n\n### 値引数\n\n```hemlock\nlet config_file = \"default.conf\";\nlet port = 8080;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--config\") {\n        i = i + 1;\n        if (i < args.length) {\n            config_file = args[i];\n        }\n    } else if (args[i] == \"--port\") {\n        i = i + 1;\n        if (i < args.length) {\n            port = 8080;  // 文字列をintにパースする必要がある\n        }\n    }\n    i = i + 1;\n}\n```\n\n### 位置引数と名前付き引数の混合\n\n```hemlock\nlet input_file = \"\";\nlet output_file = \"\";\nlet verbose = false;\n\nlet i = 1;\nlet positional = [];\n\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else {\n        // 位置引数として扱う\n        positional.push(args[i]);\n    }\n    i = i + 1;\n}\n\n// 位置引数を割り当て\nif (positional.length > 0) {\n    input_file = positional[0];\n}\nif (positional.length > 1) {\n    output_file = positional[1];\n}\n```\n\n### 引数パーサーヘルパー関数\n\n```hemlock\nfn parse_args() {\n    let options = {\n        verbose: false,\n        output: \"\",\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            options.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                options.output = args[i];\n            }\n        } else {\n            // 位置引数\n            options.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return options;\n}\n\nlet opts = parse_args();\nprint(\"Verbose: \" + typeof(opts.verbose));\nprint(\"Output: \" + opts.output);\nprint(\"Files: \" + typeof(opts.files.length));\n```\n\n## ベストプラクティス\n\n### 1. 常に引数数をチェック\n\n```hemlock\n// 良い例\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file>\");\n} else {\n    process_file(args[1]);\n}\n\n// 悪い例 - 引数がない場合にクラッシュする可能性\nprocess_file(args[1]);  // args.length == 1の場合エラー\n```\n\n### 2. 使用方法情報を提供\n\n```hemlock\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show help\");\n    print(\"  -v, --verbose  Verbose output\");\n}\n\nif (args.length < 2) {\n    show_usage();\n}\n```\n\n### 3. 引数を検証\n\n```hemlock\nfn validate_args() {\n    if (args.length < 2) {\n        print(\"Error: Missing required argument\");\n        return false;\n    }\n\n    if (args[1] == \"\") {\n        print(\"Error: Empty argument\");\n        return false;\n    }\n\n    return true;\n}\n\nif (!validate_args()) {\n    // exitまたはusageを表示\n}\n```\n\n### 4. 説明的な変数名を使用\n\n```hemlock\n// 良い例\nlet input_filename = args[1];\nlet output_filename = args[2];\nlet max_iterations = args[3];\n\n// 悪い例\nlet a = args[1];\nlet b = args[2];\nlet c = args[3];\n```\n\n### 5. スペースを含むクォート引数を処理\n\nシェルがこれを自動的に処理します：\n\n```bash\n./hemlock script.hml \"file with spaces.txt\"\n```\n\n```hemlock\nprint(args[1]);  // \"file with spaces.txt\"\n```\n\n### 6. 引数オブジェクトを作成\n\n```hemlock\nfn get_args() {\n    return {\n        script: args[0],\n        input: args[1],\n        output: args[2]\n    };\n}\n\nlet arguments = get_args();\nprint(\"Input: \" + arguments.input);\n```\n\n## 完全な例\n\n### 例1：ファイルプロセッサ\n\n```hemlock\n// 使用方法: ./hemlock process.hml <input> <output>\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <input_file> <output_file>\");\n}\n\nif (args.length < 3) {\n    show_usage();\n} else {\n    let input = args[1];\n    let output = args[2];\n\n    print(\"Processing \" + input + \" -> \" + output);\n\n    // ファイルを処理\n    let f_in = open(input, \"r\");\n    let f_out = open(output, \"w\");\n\n    try {\n        let content = f_in.read();\n        let processed = content.to_upper();  // 処理の例\n        f_out.write(processed);\n\n        print(\"Done!\");\n    } finally {\n        f_in.close();\n        f_out.close();\n    }\n}\n```\n\n### 例2：バッチファイルプロセッサ\n\n```hemlock\n// 使用方法: ./hemlock batch.hml <file1> <file2> <file3> ...\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        let filename = args[i];\n        print(\"  Processing: \" + filename);\n\n        try {\n            let f = open(filename, \"r\");\n            let content = f.read();\n            f.close();\n\n            // コンテンツを処理...\n            print(\"    \" + typeof(content.length) + \" bytes\");\n        } catch (e) {\n            print(\"    Error: \" + e);\n        }\n\n        i = i + 1;\n    }\n\n    print(\"Done!\");\n}\n```\n\n### 例3：高度な引数パーサー\n\n```hemlock\n// 使用方法: ./hemlock app.hml [OPTIONS] <files...>\n// オプション:\n//   --verbose, -v     詳細出力を有効化\n//   --output, -o FILE 出力ファイルを設定\n//   --help, -h        ヘルプを表示\n\nfn parse_arguments() {\n    let config = {\n        verbose: false,\n        output: \"output.txt\",\n        help: false,\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            config.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                config.output = args[i];\n            } else {\n                print(\"Error: --output requires a value\");\n            }\n        } else if (arg == \"--help\" || arg == \"-h\") {\n            config.help = true;\n        } else if (arg.starts_with(\"--\")) {\n            print(\"Error: Unknown option: \" + arg);\n        } else {\n            config.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return config;\n}\n\nfn show_help() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <files...>\");\n    print(\"Options:\");\n    print(\"  --verbose, -v     Enable verbose output\");\n    print(\"  --output, -o FILE Set output file\");\n    print(\"  --help, -h        Show this help\");\n}\n\nlet config = parse_arguments();\n\nif (config.help) {\n    show_help();\n} else if (config.files.length == 0) {\n    print(\"Error: No input files specified\");\n    show_help();\n} else {\n    if (config.verbose) {\n        print(\"Verbose mode enabled\");\n        print(\"Output file: \" + config.output);\n        print(\"Input files: \" + typeof(config.files.length));\n    }\n\n    // ファイルを処理\n    for (let file in config.files) {\n        if (config.verbose) {\n            print(\"Processing: \" + file);\n        }\n        // ...ファイルを処理\n    }\n}\n```\n\n### 例4：設定ツール\n\n```hemlock\n// 使用方法: ./hemlock config.hml <action> [arguments]\n// アクション:\n//   get <key>\n//   set <key> <value>\n//   list\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <action> [arguments]\");\n    print(\"Actions:\");\n    print(\"  get <key>         Get configuration value\");\n    print(\"  set <key> <value> Set configuration value\");\n    print(\"  list              List all configuration\");\n}\n\nif (args.length < 2) {\n    show_usage();\n} else {\n    let action = args[1];\n\n    if (action == \"get\") {\n        if (args.length < 3) {\n            print(\"Error: 'get' requires a key\");\n        } else {\n            let key = args[2];\n            print(\"Getting: \" + key);\n            // ...設定から取得\n        }\n    } else if (action == \"set\") {\n        if (args.length < 4) {\n            print(\"Error: 'set' requires key and value\");\n        } else {\n            let key = args[2];\n            let value = args[3];\n            print(\"Setting \" + key + \" = \" + value);\n            // ...設定に設定\n        }\n    } else if (action == \"list\") {\n        print(\"Listing all configuration:\");\n        // ...設定をリスト\n    } else {\n        print(\"Error: Unknown action: \" + action);\n        show_usage();\n    }\n}\n```\n\n## まとめ\n\nHemlockのコマンドライン引数サポートは以下を提供します：\n\n- グローバルに利用可能な組み込み`args`配列\n- 引数へのシンプルな配列ベースのアクセス\n- `args[0]`にスクリプト名\n- すべての引数は文字列\n- 配列メソッドが利用可能（.length, .sliceなど）\n\n覚えておくべきこと：\n- 要素にアクセスする前に常に`args.length`をチェック\n- `args[0]`はスクリプト名\n- 実際の引数は`args[1]`から開始\n- すべての引数は文字列 - 必要に応じて変換\n- ユーザーフレンドリーなツールのために使用方法情報を提供\n- 処理前に引数を検証\n\n一般的なパターン：\n- シンプルな位置引数\n- 名前付き/フラグ引数（--flag）\n- 値引数（--option value）\n- ヘルプメッセージ（--help）\n- 引数検証\n"}, "高度なトピック -> コマンド実行": {"id": "advanced-command-execution", "content": "# Hemlockでのコマンド実行\n\nHemlockは、シェルコマンドを実行してその出力をキャプチャするための**`exec()`組み込み関数**を提供します。\n\n## 目次\n\n- [概要](#概要)\n- [exec()関数](#exec関数)\n- [結果オブジェクト](#結果オブジェクト)\n- [基本的な使用方法](#基本的な使用方法)\n- [高度な例](#高度な例)\n- [エラー処理](#エラー処理)\n- [実装の詳細](#実装の詳細)\n- [セキュリティ上の考慮事項](#セキュリティ上の考慮事項)\n- [制限事項](#制限事項)\n- [使用ケース](#使用ケース)\n- [ベストプラクティス](#ベストプラクティス)\n- [完全な例](#完全な例)\n\n## 概要\n\n`exec()`関数により、Hemlockプログラムは以下のことができます：\n- シェルコマンドを実行\n- 標準出力（stdout）をキャプチャ\n- 終了ステータスコードを確認\n- シェル機能（パイプ、リダイレクトなど）を使用\n- システムユーティリティと統合\n\n**重要：**コマンドは`/bin/sh`を通じて実行され、完全なシェル機能を提供しますが、セキュリティ上の考慮事項も生じます。\n\n## exec()関数\n\n### シグネチャ\n\n```hemlock\nexec(command: string): object\n```\n\n**パラメータ：**\n- `command`（string）- 実行するシェルコマンド\n\n**戻り値：**2つのフィールドを持つオブジェクト：\n- `output`（string）- コマンドのstdout出力\n- `exit_code`（i32）- コマンドの終了ステータスコード\n\n### 基本的な例\n\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n```\n\n## 結果オブジェクト\n\n`exec()`が返すオブジェクトは以下の構造を持ちます：\n\n```hemlock\n{\n    output: string,      // コマンドのstdout（キャプチャされた出力）\n    exit_code: i32       // プロセスの終了ステータス（0 = 成功）\n}\n```\n\n### outputフィールド\n\nコマンドによってstdoutに書き込まれたすべてのテキストを含みます。\n\n**プロパティ：**\n- コマンドが出力を生成しない場合は空文字列\n- 改行と空白はそのまま含まれる\n- 複数行の出力は保持される\n- サイズ制限なし（動的に割り当て）\n\n**例：**\n```hemlock\nlet r1 = exec(\"echo test\");\nprint(r1.output);  // \"test\\n\"\n\nlet r2 = exec(\"ls\");\nprint(r2.output);  // 改行付きのディレクトリリスト\n\nlet r3 = exec(\"true\");\nprint(r3.output);  // \"\"（空文字列）\n```\n\n### exit_codeフィールド\n\nコマンドの終了ステータスコード。\n\n**値：**\n- `0`は通常成功を示す\n- `1-255`はエラーを示す（規則はコマンドによって異なる）\n- `-1`はコマンドが実行できなかったか、異常終了した場合\n\n**例：**\n```hemlock\nlet r1 = exec(\"true\");\nprint(r1.exit_code);  // 0（成功）\n\nlet r2 = exec(\"false\");\nprint(r2.exit_code);  // 1（失敗）\n\nlet r3 = exec(\"ls /nonexistent\");\nprint(r3.exit_code);  // 2（ファイルが見つからない、コマンドによって異なる）\n```\n\n## 基本的な使用方法\n\n### 単純なコマンド\n\n```hemlock\nlet r = exec(\"ls -la\");\nprint(r.output);\nprint(\"Exit code: \" + typeof(r.exit_code));\n```\n\n### 終了ステータスの確認\n\n```hemlock\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Found: \" + r.output);\n} else {\n    print(\"Pattern not found\");\n}\n```\n\n### パイプ付きコマンド\n\n```hemlock\nlet r = exec(\"ps aux | grep hemlock\");\nprint(r.output);\n```\n\n### 複数コマンド\n\n```hemlock\nlet r = exec(\"cd /tmp && ls -la\");\nprint(r.output);\n```\n\n### コマンド置換\n\n```hemlock\nlet r = exec(\"echo $(date)\");\nprint(r.output);  // 現在の日付\n```\n\n## 高度な例\n\n### 失敗の処理\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\nif (r.exit_code != 0) {\n    print(\"Command failed with code: \" + typeof(r.exit_code));\n    print(\"Error output: \" + r.output);  // 注意：stderrはキャプチャされない\n}\n```\n\n### 複数行出力の処理\n\n```hemlock\nlet r = exec(\"cat file.txt\");\nlet lines = r.output.split(\"\\n\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### コマンドチェーン\n\n**&& (AND)の使用：**\n```hemlock\nlet r1 = exec(\"mkdir -p /tmp/test && touch /tmp/test/file.txt\");\nif (r1.exit_code == 0) {\n    print(\"Setup complete\");\n}\n```\n\n**|| (OR)の使用：**\n```hemlock\nlet r = exec(\"command1 || command2\");\n// command1が失敗した場合のみcommand2を実行\n```\n\n**; (シーケンス)の使用：**\n```hemlock\nlet r = exec(\"command1; command2\");\n// 成功/失敗に関係なく両方を実行\n```\n\n### パイプの使用\n\n```hemlock\nlet r = exec(\"echo 'data' | base64\");\nprint(\"Base64: \" + r.output);\n```\n\n**複雑なパイプライン：**\n```hemlock\nlet r = exec(\"cat /etc/passwd | grep root | cut -d: -f1\");\nprint(r.output);\n```\n\n### 終了コードパターン\n\n異なる終了コードは異なる状態を示します：\n\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n} else if (r.exit_code == 1) {\n    print(\"File does not exist\");\n} else {\n    print(\"Test command failed: \" + typeof(r.exit_code));\n}\n```\n\n### 出力リダイレクト\n\n```hemlock\n// シェル内でstdoutをファイルにリダイレクト\nlet r1 = exec(\"echo 'test' > /tmp/output.txt\");\n\n// stderrをstdoutにリダイレクト（注意：stderrはまだHemlockにキャプチャされない）\nlet r2 = exec(\"command 2>&1\");\n```\n\n### 環境変数\n\n```hemlock\nlet r = exec(\"export VAR=value && echo $VAR\");\nprint(r.output);  // \"value\\n\"\n```\n\n### 作業ディレクトリの変更\n\n```hemlock\nlet r = exec(\"cd /tmp && pwd\");\nprint(r.output);  // \"/tmp\\n\"\n```\n\n## エラー処理\n\n### exec()が例外をスローする場合\n\n`exec()`関数はコマンドが実行できない場合に例外をスローします：\n\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command_xyz\");\n} catch (e) {\n    print(\"Failed to execute: \" + e);\n}\n```\n\n**例外がスローされる場合：**\n- `popen()`が失敗した場合（例：パイプを作成できない）\n- システムリソース制限を超えた場合\n- メモリ割り当てエラー\n\n### exec()が例外をスローしない場合\n\n```hemlock\n// コマンドは実行されるがゼロ以外の終了コードを返す\nlet r1 = exec(\"false\");\nprint(r1.exit_code);  // 1（例外ではない）\n\n// コマンドが出力を生成しない\nlet r2 = exec(\"true\");\nprint(r2.output);  // \"\"（例外ではない）\n\n// シェルでコマンドが見つからない\nlet r3 = exec(\"nonexistent_cmd\");\nprint(r3.exit_code);  // 127（例外ではない）\n```\n\n### 安全な実行パターン\n\n```hemlock\nfn safe_exec(command: string) {\n    try {\n        let r = exec(command);\n        if (r.exit_code != 0) {\n            print(\"Warning: Command failed with code \" + typeof(r.exit_code));\n            return \"\";\n        }\n        return r.output;\n    } catch (e) {\n        print(\"Error executing command: \" + e);\n        return \"\";\n    }\n}\n\nlet output = safe_exec(\"ls -la\");\n```\n\n## 実装の詳細\n\n### 動作の仕組み\n\n**内部処理：**\n- `popen()`を使用して`/bin/sh`経由でコマンドを実行\n- stdoutのみをキャプチャ（stderrはキャプチャされない）\n- 出力は動的にバッファリング（4KBから開始、必要に応じて拡張）\n- 終了ステータスは`WIFEXITED()`と`WEXITSTATUS()`マクロを使用して抽出\n- 出力文字列は適切にnull終端される\n\n**プロセスフロー：**\n1. `popen(command, \"r\")`がパイプを作成してプロセスをフォーク\n2. 子プロセスが`/bin/sh -c \"command\"`を実行\n3. 親が成長するバッファにパイプ経由でstdoutを読み取り\n4. `pclose()`が子を待機し、終了ステータスを返す\n5. 終了ステータスが抽出され、結果オブジェクトに格納\n\n### パフォーマンスの考慮事項\n\n**コスト：**\n- 各呼び出しで新しいシェルプロセスを作成（約1-5msのオーバーヘッド）\n- 出力は完全にメモリに格納（ストリーミングではない）\n- ストリーミングサポートなし（コマンドの完了を待つ）\n- 適度な出力サイズのコマンドに適している\n\n**最適化：**\n- バッファは4KBで開始し、満杯になると倍増（効率的なメモリ使用）\n- 単一の読み取りループでシステムコールを最小化\n- 追加の文字列コピーなし\n\n**使用すべき場合：**\n- 短時間実行のコマンド（< 1秒）\n- 適度な出力サイズ（< 10MB）\n- 合理的な間隔のバッチ操作\n\n**使用すべきでない場合：**\n- 長時間実行のデーモンやサービス\n- ギガバイトの出力を生成するコマンド\n- リアルタイムストリーミングデータ処理\n- 高頻度実行（> 100回/秒）\n\n## セキュリティ上の考慮事項\n\n### シェルインジェクションのリスク\n\n⚠️ **重要：**コマンドはシェル（`/bin/sh`）によって実行されるため、**シェルインジェクションが可能**です。\n\n**脆弱なコード：**\n```hemlock\n// 危険 - これをしないでください\nlet filename = args[1];  // ユーザー入力\nlet r = exec(\"cat \" + filename);  // シェルインジェクション！\n```\n\n**攻撃：**\n```bash\n./hemlock script.hml \"; rm -rf /; echo pwned\"\n# 実行される: cat ; rm -rf /; echo pwned\n```\n\n### 安全なプラクティス\n\n**1. サニタイズされていないユーザー入力を使用しない：**\n```hemlock\n// 悪い例\nlet user_input = args[1];\nlet r = exec(\"process \" + user_input);  // 危険\n\n// 良い例 - 最初に検証\nfn is_safe_filename(name: string): bool {\n    // 英数字、ダッシュ、アンダースコア、ドットのみを許可\n    let i = 0;\n    while (i < name.length) {\n        let c = name[i];\n        if (!(c >= 'a' && c <= 'z') &&\n            !(c >= 'A' && c <= 'Z') &&\n            !(c >= '0' && c <= '9') &&\n            c != '-' && c != '_' && c != '.') {\n            return false;\n        }\n        i = i + 1;\n    }\n    return true;\n}\n\nlet filename = args[1];\nif (is_safe_filename(filename)) {\n    let r = exec(\"cat \" + filename);\n} else {\n    print(\"Invalid filename\");\n}\n```\n\n**2. 拒否リストではなく許可リストを使用：**\n```hemlock\n// 良い例 - 厳密な許可リスト\nlet allowed_commands = [\"status\", \"start\", \"stop\", \"restart\"];\nlet cmd = args[1];\n\nlet found = false;\nfor (let allowed in allowed_commands) {\n    if (cmd == allowed) {\n        found = true;\n        break;\n    }\n}\n\nif (found) {\n    exec(\"service myapp \" + cmd);\n} else {\n    print(\"Invalid command\");\n}\n```\n\n**3. 特殊文字をエスケープ：**\n```hemlock\nfn shell_escape(s: string): string {\n    // シンプルなエスケープ - シングルクォートで囲み、シングルクォートをエスケープ\n    let escaped = s.replace_all(\"'\", \"'\\\\''\");\n    return \"'\" + escaped + \"'\";\n}\n\nlet user_file = args[1];\nlet safe = shell_escape(user_file);\nlet r = exec(\"cat \" + safe);\n```\n\n**4. ファイル操作にexec()を使用しない：**\n```hemlock\n// 悪い例 - ファイル操作にexecを使用\nlet r = exec(\"cat file.txt\");\n\n// 良い例 - HemlockのファイルAPIを使用\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### 権限の考慮事項\n\nコマンドはHemlockプロセスと同じ権限で実行されます：\n\n```hemlock\n// Hemlockがrootで実行されている場合、exec()コマンドもrootで実行されます！\nlet r = exec(\"rm -rf /important\");  // rootで実行している場合は危険\n```\n\n**ベストプラクティス：**必要最小限の権限でHemlockを実行してください。\n\n## 制限事項\n\n### 1. stderrキャプチャなし\n\nstdoutのみがキャプチャされ、stderrはターミナルに出力されます：\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\n// r.outputは空\n// エラーメッセージはターミナルに表示され、キャプチャされない\n```\n\n**回避策 - stderrをstdoutにリダイレクト：**\n```hemlock\nlet r = exec(\"ls /nonexistent 2>&1\");\n// これでエラーメッセージがr.outputに含まれる\n```\n\n### 2. ストリーミングなし\n\nコマンドの完了を待つ必要があります：\n\n```hemlock\nlet r = exec(\"long_running_command\");\n// コマンドが終了するまでブロック\n// 出力を段階的に処理できない\n```\n\n### 3. タイムアウトなし\n\nコマンドは無期限に実行できます：\n\n```hemlock\nlet r = exec(\"sleep 1000\");\n// 1000秒間ブロック\n// タイムアウトやキャンセルの方法がない\n```\n\n**回避策 - timeoutコマンドを使用：**\n```hemlock\nlet r = exec(\"timeout 5 long_command\");\n// 5秒後にタイムアウト\n```\n\n### 4. シグナル処理なし\n\n実行中のコマンドにシグナルを送信できません：\n\n```hemlock\nlet r = exec(\"long_command\");\n// コマンドにSIGINT、SIGTERMなどを送信できない\n```\n\n### 5. プロセス制御なし\n\n開始後のコマンドとやり取りできません：\n\n```hemlock\nlet r = exec(\"interactive_program\");\n// プログラムに入力を送信できない\n// 実行を制御できない\n```\n\n## 使用ケース\n\n### 適した使用ケース\n\n**1. システムユーティリティの実行：**\n```hemlock\nlet r = exec(\"ls -la\");\nlet r = exec(\"grep pattern file.txt\");\nlet r = exec(\"find /path -name '*.txt'\");\n```\n\n**2. Unixツールでのクイックデータ処理：**\n```hemlock\nlet r = exec(\"cat data.txt | sort | uniq | wc -l\");\nprint(\"Unique lines: \" + r.output);\n```\n\n**3. システム状態の確認：**\n```hemlock\nlet r = exec(\"df -h\");\nprint(\"Disk usage:\\n\" + r.output);\n```\n\n**4. ファイル存在チェック：**\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n}\n```\n\n**5. レポートの生成：**\n```hemlock\nlet r = exec(\"ps aux | grep myapp | wc -l\");\nlet count = r.output.trim();\nprint(\"Running instances: \" + count);\n```\n\n**6. 自動化スクリプト：**\n```hemlock\nexec(\"git add .\");\nexec(\"git commit -m 'Auto commit'\");\nlet r = exec(\"git push\");\nif (r.exit_code != 0) {\n    print(\"Push failed\");\n}\n```\n\n### 推奨されない使用\n\n**1. 長時間実行のサービス：**\n```hemlock\n// 悪い例\nlet r = exec(\"nginx\");  // 永遠にブロック\n```\n\n**2. 対話型コマンド：**\n```hemlock\n// 悪い例 - 入力を提供できない\nlet r = exec(\"ssh user@host\");\n```\n\n**3. 巨大な出力を生成するコマンド：**\n```hemlock\n// 悪い例 - 出力全体をメモリにロード\nlet r = exec(\"cat 10GB_file.log\");\n```\n\n**4. リアルタイムストリーミング：**\n```hemlock\n// 悪い例 - 出力を段階的に処理できない\nlet r = exec(\"tail -f /var/log/app.log\");\n```\n\n**5. ミッションクリティカルなエラー処理：**\n```hemlock\n// 悪い例 - stderrがキャプチャされない\nlet r = exec(\"critical_operation\");\n// 詳細なエラーメッセージを見ることができない\n```\n\n## ベストプラクティス\n\n### 1. 常に終了コードを確認\n\n```hemlock\nlet r = exec(\"important_command\");\nif (r.exit_code != 0) {\n    print(\"Command failed!\");\n    // エラーを処理\n}\n```\n\n### 2. 必要に応じて出力をトリム\n\n```hemlock\nlet r = exec(\"echo test\");\nlet clean = r.output.trim();  // 末尾の改行を削除\nprint(clean);  // \"test\"（改行なし）\n```\n\n### 3. 実行前に検証\n\n```hemlock\nfn is_valid_command(cmd: string): bool {\n    // コマンドが安全かどうかを検証\n    return true;  // 検証ロジック\n}\n\nif (is_valid_command(user_cmd)) {\n    exec(user_cmd);\n}\n```\n\n### 4. 重要な操作にはtry/catchを使用\n\n```hemlock\ntry {\n    let r = exec(\"critical_command\");\n    if (r.exit_code != 0) {\n        throw \"Command failed\";\n    }\n} catch (e) {\n    print(\"Error: \" + e);\n    // クリーンアップまたはリカバリ\n}\n```\n\n### 5. exec()よりHemlockのAPIを優先\n\n```hemlock\n// 悪い例 - ファイル操作にexecを使用\nlet r = exec(\"cat file.txt\");\n\n// 良い例 - HemlockのFile APIを使用\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### 6. 必要に応じてstderrをキャプチャ\n\n```hemlock\n// stderrをstdoutにリダイレクト\nlet r = exec(\"command 2>&1\");\n// これでr.outputにstdoutとstderrの両方が含まれる\n```\n\n### 7. シェル機能を賢く使用\n\n```hemlock\n// 効率のためにパイプを使用\nlet r = exec(\"cat large.txt | grep pattern | head -n 10\");\n\n// コマンド置換を使用\nlet r = exec(\"echo Current user: $(whoami)\");\n\n// 条件付き実行を使用\nlet r = exec(\"test -f file.txt && cat file.txt\");\n```\n\n## 完全な例\n\n### 例1：システム情報収集\n\n```hemlock\nfn get_system_info() {\n    print(\"=== System Information ===\");\n\n    // ホスト名\n    let r1 = exec(\"hostname\");\n    print(\"Hostname: \" + r1.output.trim());\n\n    // アップタイム\n    let r2 = exec(\"uptime\");\n    print(\"Uptime: \" + r2.output.trim());\n\n    // ディスク使用量\n    let r3 = exec(\"df -h /\");\n    print(\"\\nDisk Usage:\");\n    print(r3.output);\n\n    // メモリ使用量\n    let r4 = exec(\"free -h\");\n    print(\"Memory Usage:\");\n    print(r4.output);\n}\n\nget_system_info();\n```\n\n### 例2：ログ分析\n\n```hemlock\nfn analyze_log(logfile: string) {\n    print(\"Analyzing log: \" + logfile);\n\n    // 総行数をカウント\n    let r1 = exec(\"wc -l \" + logfile);\n    print(\"Total lines: \" + r1.output.trim());\n\n    // エラーをカウント\n    let r2 = exec(\"grep -c ERROR \" + logfile + \" 2>/dev/null\");\n    let errors = r2.output.trim();\n    if (r2.exit_code == 0) {\n        print(\"Errors: \" + errors);\n    } else {\n        print(\"Errors: 0\");\n    }\n\n    // 警告をカウント\n    let r3 = exec(\"grep -c WARN \" + logfile + \" 2>/dev/null\");\n    let warnings = r3.output.trim();\n    if (r3.exit_code == 0) {\n        print(\"Warnings: \" + warnings);\n    } else {\n        print(\"Warnings: 0\");\n    }\n\n    // 最近のエラー\n    print(\"\\nRecent errors:\");\n    let r4 = exec(\"grep ERROR \" + logfile + \" | tail -n 5\");\n    print(r4.output);\n}\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <logfile>\");\n} else {\n    analyze_log(args[1]);\n}\n```\n\n### 例3：Gitヘルパー\n\n```hemlock\nfn git_status() {\n    let r = exec(\"git status --short\");\n    if (r.exit_code != 0) {\n        print(\"Error: Not a git repository\");\n        return;\n    }\n\n    if (r.output == \"\") {\n        print(\"Working directory clean\");\n    } else {\n        print(\"Changes:\");\n        print(r.output);\n    }\n}\n\nfn git_quick_commit(message: string) {\n    print(\"Adding all changes...\");\n    let r1 = exec(\"git add -A\");\n    if (r1.exit_code != 0) {\n        print(\"Error adding files\");\n        return;\n    }\n\n    print(\"Committing...\");\n    let safe_msg = message.replace_all(\"'\", \"'\\\\''\");\n    let r2 = exec(\"git commit -m '\" + safe_msg + \"'\");\n    if (r2.exit_code != 0) {\n        print(\"Error committing\");\n        return;\n    }\n\n    print(\"Committed successfully\");\n    print(r2.output);\n}\n\n// 使用方法\ngit_status();\nif (args.length > 1) {\n    git_quick_commit(args[1]);\n}\n```\n\n### 例4：バックアップスクリプト\n\n```hemlock\nfn backup_directory(source: string, dest: string) {\n    print(\"Backing up \" + source + \" to \" + dest);\n\n    // バックアップディレクトリを作成\n    let r1 = exec(\"mkdir -p \" + dest);\n    if (r1.exit_code != 0) {\n        print(\"Error creating backup directory\");\n        return false;\n    }\n\n    // タイムスタンプ付きのtarballを作成\n    let r2 = exec(\"date +%Y%m%d_%H%M%S\");\n    let timestamp = r2.output.trim();\n    let backup_file = dest + \"/backup_\" + timestamp + \".tar.gz\";\n\n    print(\"Creating archive: \" + backup_file);\n    let r3 = exec(\"tar -czf \" + backup_file + \" \" + source + \" 2>&1\");\n    if (r3.exit_code != 0) {\n        print(\"Error creating backup:\");\n        print(r3.output);\n        return false;\n    }\n\n    print(\"Backup completed successfully\");\n\n    // バックアップサイズを表示\n    let r4 = exec(\"du -h \" + backup_file);\n    print(\"Backup size: \" + r4.output.trim());\n\n    return true;\n}\n\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <source> <destination>\");\n} else {\n    backup_directory(args[1], args[2]);\n}\n```\n\n## まとめ\n\nHemlockの`exec()`関数は以下を提供します：\n\n- シンプルなシェルコマンド実行\n- 出力キャプチャ（stdout）\n- 終了コードチェック\n- 完全なシェル機能アクセス（パイプ、リダイレクトなど）\n- システムユーティリティとの統合\n\n覚えておくべきこと：\n- 常に終了コードを確認\n- セキュリティの影響（シェルインジェクション）に注意\n- コマンドで使用する前にユーザー入力を検証\n- 利用可能な場合はexec()よりHemlockのAPIを優先\n- stderrはキャプチャされない（リダイレクトには`2>&1`を使用）\n- コマンドは完了するまでブロック\n- 長時間実行のサービスではなく、短時間ユーティリティに使用\n\n**セキュリティチェックリスト：**\n- サニタイズされていないユーザー入力を使用しない\n- すべての入力を検証\n- コマンドに許可リストを使用\n- 必要に応じて特殊文字をエスケープ\n- 最小権限で実行\n- シェルコマンドよりHemlockのAPIを優先\n"}, "高度なトピック -> シグナル処理": {"id": "advanced-signals", "content": "# Hemlockでのシグナル処理\n\nHemlockは、SIGINT（Ctrl+C）、SIGTERM、カスタムシグナルなどのシステムシグナルを管理するための**POSIXシグナル処理**を提供します。これにより、低レベルのプロセス制御とプロセス間通信が可能になります。\n\n## 目次\n\n- [概要](#概要)\n- [シグナルAPI](#シグナルapi)\n- [シグナル定数](#シグナル定数)\n- [基本的なシグナル処理](#基本的なシグナル処理)\n- [高度なパターン](#高度なパターン)\n- [シグナルハンドラの動作](#シグナルハンドラの動作)\n- [安全性の考慮事項](#安全性の考慮事項)\n- [一般的な使用ケース](#一般的な使用ケース)\n- [完全な例](#完全な例)\n\n## 概要\n\nシグナル処理により、プログラムは以下のことができます：\n- ユーザー割り込み（Ctrl+C、Ctrl+Z）に応答\n- グレースフルシャットダウンを実装\n- 終了リクエストを処理\n- プロセス間通信にカスタムシグナルを使用\n- アラーム/タイマーメカニズムを作成\n\n**重要：**シグナル処理はHemlockの哲学において**本質的にアンセーフ**です。ハンドラはいつでも呼び出され、通常の実行を中断する可能性があります。ユーザーは適切な同期に責任を持ちます。\n\n## シグナルAPI\n\n### signal(signum, handler_fn)\n\nシグナルハンドラ関数を登録します。\n\n**パラメータ：**\n- `signum`（i32）- シグナル番号（SIGINT、SIGTERMなどの定数）\n- `handler_fn`（関数またはnull）- シグナル受信時に呼び出す関数、または`null`でデフォルトにリセット\n\n**戻り値：**前のハンドラ関数（なければ`null`）\n\n**例：**\n```hemlock\nfn my_handler(sig) {\n    print(\"Caught signal: \" + typeof(sig));\n}\n\nlet old_handler = signal(SIGINT, my_handler);\n```\n\n**デフォルトにリセット：**\n```hemlock\nsignal(SIGINT, null);  // SIGINTをデフォルト動作にリセット\n```\n\n### raise(signum)\n\n現在のプロセスにシグナルを送信します。\n\n**パラメータ：**\n- `signum`（i32）- 送信するシグナル番号\n\n**戻り値：**`null`\n\n**例：**\n```hemlock\nraise(SIGUSR1);  // SIGUSR1ハンドラをトリガー\n```\n\n## シグナル定数\n\nHemlockは標準POSIXシグナル定数をi32値として提供します。\n\n### 割り込みと終了\n\n| 定数 | 値 | 説明 | 一般的なトリガー |\n|----------|-------|-------------|----------------|\n| `SIGINT` | 2 | キーボードからの割り込み | Ctrl+C |\n| `SIGTERM` | 15 | 終了リクエスト | `kill`コマンド |\n| `SIGQUIT` | 3 | キーボードからの終了 | Ctrl+\\ |\n| `SIGHUP` | 1 | ハングアップ検出 | ターミナルが閉じられた |\n| `SIGABRT` | 6 | アボートシグナル | `abort()`関数 |\n\n**例：**\n```hemlock\nsignal(SIGINT, handle_interrupt);   // Ctrl+C\nsignal(SIGTERM, handle_terminate);  // killコマンド\nsignal(SIGHUP, handle_hangup);      // ターミナルが閉じる\n```\n\n### ユーザー定義シグナル\n\n| 定数 | 値 | 説明 | 使用ケース |\n|----------|-------|-------------|----------|\n| `SIGUSR1` | 10 | ユーザー定義シグナル1 | カスタムIPC |\n| `SIGUSR2` | 12 | ユーザー定義シグナル2 | カスタムIPC |\n\n**例：**\n```hemlock\n// カスタム通信に使用\nsignal(SIGUSR1, reload_config);\nsignal(SIGUSR2, rotate_logs);\n```\n\n### プロセス制御\n\n| 定数 | 値 | 説明 | 備考 |\n|----------|-------|-------------|-------|\n| `SIGALRM` | 14 | アラームクロックタイマー | `alarm()`後 |\n| `SIGCHLD` | 17 | 子プロセスステータス変更 | プロセス管理 |\n| `SIGCONT` | 18 | 停止していれば続行 | SIGSTOP後に再開 |\n| `SIGSTOP` | 19 | プロセスを停止 | **キャッチ不可** |\n| `SIGTSTP` | 20 | ターミナル停止 | Ctrl+Z |\n\n**例：**\n```hemlock\nsignal(SIGALRM, handle_timeout);\nsignal(SIGCHLD, handle_child_exit);\n```\n\n### I/Oシグナル\n\n| 定数 | 値 | 説明 | 送信されるとき |\n|----------|-------|-------------|-----------|\n| `SIGPIPE` | 13 | パイプ破損 | 閉じたパイプへの書き込み |\n| `SIGTTIN` | 21 | バックグラウンドでターミナルから読み取り | BGプロセスがTTYを読み取り |\n| `SIGTTOU` | 22 | バックグラウンドでターミナルに書き込み | BGプロセスがTTYに書き込み |\n\n**例：**\n```hemlock\nsignal(SIGPIPE, handle_broken_pipe);\n```\n\n## 基本的なシグナル処理\n\n### Ctrl+Cのキャッチ\n\n```hemlock\nlet interrupted = false;\n\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n    interrupted = true;\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// プログラムは実行を継続...\n// ユーザーがCtrl+Cを押す -> handle_interrupt()が呼び出される\n\nwhile (!interrupted) {\n    // 作業を実行...\n}\n\nprint(\"Exiting due to interrupt\");\n```\n\n### ハンドラ関数のシグネチャ\n\nシグナルハンドラは1つの引数を受け取ります：シグナル番号（i32）\n\n```hemlock\nfn my_handler(signum) {\n    print(\"Received signal: \" + typeof(signum));\n    // signumにはシグナル番号が含まれる（例：SIGINTの場合は2）\n\n    if (signum == SIGINT) {\n        print(\"This is SIGINT\");\n    }\n}\n\nsignal(SIGINT, my_handler);\nsignal(SIGTERM, my_handler);  // 複数のシグナルに同じハンドラ\n```\n\n### 複数のシグナルハンドラ\n\n異なるシグナルに異なるハンドラ：\n\n```hemlock\nfn handle_int(sig) {\n    print(\"SIGINT received\");\n}\n\nfn handle_term(sig) {\n    print(\"SIGTERM received\");\n}\n\nfn handle_usr1(sig) {\n    print(\"SIGUSR1 received\");\n}\n\nsignal(SIGINT, handle_int);\nsignal(SIGTERM, handle_term);\nsignal(SIGUSR1, handle_usr1);\n```\n\n### デフォルト動作へのリセット\n\nハンドラとして`null`を渡すとデフォルト動作にリセット：\n\n```hemlock\n// カスタムハンドラを登録\nsignal(SIGINT, my_handler);\n\n// 後で、デフォルトにリセット（SIGINTで終了）\nsignal(SIGINT, null);\n```\n\n### シグナルを手動で発生\n\n自分のプロセスにシグナルを送信：\n\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\n// ハンドラを手動でトリガー\nraise(SIGUSR1);\nraise(SIGUSR1);\n\nprint(count);  // 2\n```\n\n## 高度なパターン\n\n### グレースフルシャットダウンパターン\n\n終了時のクリーンアップの一般的なパターン：\n\n```hemlock\nlet should_exit = false;\n\nfn handle_shutdown(sig) {\n    print(\"Shutting down gracefully...\");\n    should_exit = true;\n}\n\nsignal(SIGINT, handle_shutdown);\nsignal(SIGTERM, handle_shutdown);\n\n// メインループ\nwhile (!should_exit) {\n    // 作業を実行...\n    // should_exitフラグを定期的にチェック\n}\n\nprint(\"Cleanup complete\");\n```\n\n### シグナルカウンター\n\n受信したシグナルの数を追跡：\n\n```hemlock\nlet signal_count = 0;\n\nfn count_signals(sig) {\n    signal_count = signal_count + 1;\n    print(\"Received \" + typeof(signal_count) + \" signals\");\n}\n\nsignal(SIGUSR1, count_signals);\n\n// 後で...\nprint(\"Total signals: \" + typeof(signal_count));\n```\n\n### シグナルによる設定リロード\n\n```hemlock\nlet config = load_config();\n\nfn reload_config(sig) {\n    print(\"Reloading configuration...\");\n    config = load_config();\n    print(\"Configuration reloaded\");\n}\n\nsignal(SIGHUP, reload_config);  // SIGHUPでリロード\n\n// 設定をリロードするためにプロセスにSIGHUPを送信\n// シェルから: kill -HUP <pid>\n```\n\n### SIGALRMを使用したタイムアウト\n\n```hemlock\nlet timed_out = false;\n\nfn handle_alarm(sig) {\n    print(\"Timeout!\");\n    timed_out = true;\n}\n\nsignal(SIGALRM, handle_alarm);\n\n// アラームを設定（Hemlockではまだ実装されていない、例のみ）\n// alarm(5);  // 5秒タイムアウト\n\nwhile (!timed_out) {\n    // タイムアウト付きで作業を実行\n}\n```\n\n### シグナルベースのステートマシン\n\n```hemlock\nlet state = 0;\n\nfn next_state(sig) {\n    state = (state + 1) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nfn prev_state(sig) {\n    state = (state - 1 + 3) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nsignal(SIGUSR1, next_state);  // 状態を進める\nsignal(SIGUSR2, prev_state);  // 戻る\n\n// ステートマシンを制御：\n// kill -USR1 <pid>  # 次の状態\n// kill -USR2 <pid>  # 前の状態\n```\n\n## シグナルハンドラの動作\n\n### 重要な注意事項\n\n**ハンドラの実行：**\n- ハンドラはシグナル受信時に**同期的に**呼び出される\n- ハンドラは現在のプロセスコンテキストで実行\n- シグナルハンドラは定義された関数のクロージャ環境を共有\n- ハンドラは外部スコープの変数（グローバルやキャプチャされた変数など）にアクセスして変更可能\n\n**ベストプラクティス：**\n- ハンドラはシンプルで迅速に - 長時間実行の操作を避ける\n- 複雑なロジックではなくフラグを設定\n- ロックを取る可能性のある関数の呼び出しを避ける\n- ハンドラが任意の操作を中断できることに注意\n\n### キャッチできるシグナル\n\n**キャッチして処理できる：**\n- SIGINT、SIGTERM、SIGUSR1、SIGUSR2、SIGHUP、SIGQUIT\n- SIGALRM、SIGCHLD、SIGCONT、SIGTSTP\n- SIGPIPE、SIGTTIN、SIGTTOU\n- SIGABRT（ただしハンドラが戻った後にプログラムはアボート）\n\n**キャッチできない：**\n- `SIGKILL`（9）- 常にプロセスを終了\n- `SIGSTOP`（19）- 常にプロセスを停止\n\n**システム依存：**\n- 一部のシグナルはシステムによってデフォルト動作が異なる場合がある\n- 詳細はプラットフォームのシグナルドキュメントを確認\n\n### ハンドラの制限\n\n```hemlock\nfn complex_handler(sig) {\n    // シグナルハンドラでこれらを避ける：\n\n    // 長時間実行の操作\n    // process_large_file();\n\n    // ブロッキングI/O\n    // let f = open(\"log.txt\", \"a\");\n    // f.write(\"Signal received\\n\");\n\n    // 複雑な状態変更\n    // rebuild_entire_data_structure();\n\n    // シンプルなフラグ設定は安全\n    let should_stop = true;\n\n    // シンプルなカウンタ更新は通常安全\n    let signal_count = signal_count + 1;\n}\n```\n\n## 安全性の考慮事項\n\nシグナル処理はHemlockの哲学において**本質的にアンセーフ**です。\n\n### レースコンディション\n\nハンドラはいつでも呼び出され、通常の実行を中断する可能性があります：\n\n```hemlock\nlet counter = 0;\n\nfn increment(sig) {\n    counter = counter + 1;  // カウンター更新中に呼び出されるとレースコンディション\n}\n\nsignal(SIGUSR1, increment);\n\n// メインコードもカウンターを変更\ncounter = counter + 1;  // シグナルハンドラに中断される可能性\n```\n\n**問題：**メインコードが`counter`を更新中にシグナルが到着すると、結果は予測不能です。\n\n### 非同期シグナル安全性\n\nHemlockは非同期シグナル安全性を**保証しません**：\n- ハンドラは任意のHemlockコードを呼び出せる（Cの制限された非同期シグナル安全関数とは異なり）\n- これは柔軟性を提供するが、ユーザーの注意が必要\n- ハンドラが共有状態を変更する場合、レースコンディションが可能\n\n### 安全なシグナル処理のベストプラクティス\n\n**1. アトミックフラグを使用**\n\nシンプルなブール代入は一般的に安全：\n\n```hemlock\nlet should_exit = false;\n\nfn handler(sig) {\n    should_exit = true;  // シンプルな代入は安全\n}\n\nsignal(SIGINT, handler);\n\nwhile (!should_exit) {\n    // 作業...\n}\n```\n\n**2. 共有状態を最小化**\n\n```hemlock\nlet interrupt_count = 0;\n\nfn handler(sig) {\n    // この1つの変数のみを変更\n    interrupt_count = interrupt_count + 1;\n}\n```\n\n**3. 複雑な操作を延期**\n\n```hemlock\nlet pending_reload = false;\n\nfn signal_reload(sig) {\n    pending_reload = true;  // フラグを設定するだけ\n}\n\nsignal(SIGHUP, signal_reload);\n\n// メインループで：\nwhile (true) {\n    if (pending_reload) {\n        reload_config();  // ここで複雑な作業を実行\n        pending_reload = false;\n    }\n\n    // 通常の作業...\n}\n```\n\n**4. 再入可能性の問題を避ける**\n\n```hemlock\nlet in_critical_section = false;\nlet data = [];\n\nfn careful_handler(sig) {\n    if (in_critical_section) {\n        // メインコードが使用中はデータを変更しない\n        return;\n    }\n    // 続行しても安全\n}\n```\n\n## 一般的な使用ケース\n\n### 1. グレースフルサーバーシャットダウン\n\n```hemlock\nlet running = true;\n\nfn shutdown(sig) {\n    print(\"Shutdown signal received\");\n    running = false;\n}\n\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// サーバーメインループ\nwhile (running) {\n    handle_client_request();\n}\n\ncleanup_resources();\nprint(\"Server stopped\");\n```\n\n### 2. 設定リロード（再起動なし）\n\n```hemlock\nlet config = load_config(\"app.conf\");\nlet reload_needed = false;\n\nfn trigger_reload(sig) {\n    reload_needed = true;\n}\n\nsignal(SIGHUP, trigger_reload);\n\nwhile (true) {\n    if (reload_needed) {\n        print(\"Reloading configuration...\");\n        config = load_config(\"app.conf\");\n        reload_needed = false;\n    }\n\n    // configを使用...\n}\n```\n\n### 3. ログローテーション\n\n```hemlock\nlet log_file = open(\"app.log\", \"a\");\nlet rotate_needed = false;\n\nfn trigger_rotate(sig) {\n    rotate_needed = true;\n}\n\nsignal(SIGUSR1, trigger_rotate);\n\nwhile (true) {\n    if (rotate_needed) {\n        log_file.close();\n        // 古いログの名前を変更し、新しいものを開く\n        exec(\"mv app.log app.log.old\");\n        log_file = open(\"app.log\", \"a\");\n        rotate_needed = false;\n    }\n\n    // 通常のロギング...\n    log_file.write(\"Log entry\\n\");\n}\n```\n\n### 4. ステータス報告\n\n```hemlock\nlet requests_handled = 0;\n\nfn report_status(sig) {\n    print(\"Status: \" + typeof(requests_handled) + \" requests handled\");\n}\n\nsignal(SIGUSR1, report_status);\n\nwhile (true) {\n    handle_request();\n    requests_handled = requests_handled + 1;\n}\n\n// シェルから: kill -USR1 <pid>\n```\n\n### 5. デバッグモード切り替え\n\n```hemlock\nlet debug_mode = false;\n\nfn toggle_debug(sig) {\n    debug_mode = !debug_mode;\n    if (debug_mode) {\n        print(\"Debug mode: ON\");\n    } else {\n        print(\"Debug mode: OFF\");\n    }\n}\n\nsignal(SIGUSR2, toggle_debug);\n\n// シェルから: kill -USR2 <pid> で切り替え\n```\n\n## 完全な例\n\n### 例1：クリーンアップ付き割り込みハンドラ\n\n```hemlock\nlet running = true;\nlet signal_count = 0;\n\nfn handle_signal(signum) {\n    signal_count = signal_count + 1;\n\n    if (signum == SIGINT) {\n        print(\"Interrupt detected (Ctrl+C)\");\n        running = false;\n    }\n\n    if (signum == SIGUSR1) {\n        print(\"User signal 1 received\");\n    }\n}\n\n// ハンドラを登録\nsignal(SIGINT, handle_signal);\nsignal(SIGUSR1, handle_signal);\n\n// 作業をシミュレート\nlet i = 0;\nwhile (running && i < 100) {\n    print(\"Working... \" + typeof(i));\n\n    // 10回ごとにSIGUSR1をトリガー\n    if (i == 10 || i == 20) {\n        raise(SIGUSR1);\n    }\n\n    i = i + 1;\n}\n\nprint(\"Total signals received: \" + typeof(signal_count));\n```\n\n### 例2：マルチシグナルステートマシン\n\n```hemlock\nlet state = \"idle\";\nlet request_count = 0;\n\nfn start_processing(sig) {\n    state = \"processing\";\n    print(\"State: \" + state);\n}\n\nfn stop_processing(sig) {\n    state = \"idle\";\n    print(\"State: \" + state);\n}\n\nfn report_stats(sig) {\n    print(\"State: \" + state);\n    print(\"Requests: \" + typeof(request_count));\n}\n\nsignal(SIGUSR1, start_processing);\nsignal(SIGUSR2, stop_processing);\nsignal(SIGHUP, report_stats);\n\nwhile (true) {\n    if (state == \"processing\") {\n        // 作業を実行\n        request_count = request_count + 1;\n    }\n\n    // 各イテレーションでチェック...\n}\n```\n\n### 例3：ワーカープールコントローラ\n\n```hemlock\nlet worker_count = 4;\nlet should_exit = false;\n\nfn increase_workers(sig) {\n    worker_count = worker_count + 1;\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn decrease_workers(sig) {\n    if (worker_count > 1) {\n        worker_count = worker_count - 1;\n    }\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn shutdown(sig) {\n    print(\"Shutting down...\");\n    should_exit = true;\n}\n\nsignal(SIGUSR1, increase_workers);\nsignal(SIGUSR2, decrease_workers);\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// メインループはworker_countに基づいてワーカープールを調整\nwhile (!should_exit) {\n    // worker_countに基づいてワーカーを管理\n    // ...\n}\n```\n\n### 例4：タイムアウトパターン\n\n```hemlock\nlet operation_complete = false;\nlet timed_out = false;\n\nfn timeout_handler(sig) {\n    timed_out = true;\n}\n\nsignal(SIGALRM, timeout_handler);\n\n// 長い操作を開始\nasync fn long_operation() {\n    // ...作業\n    operation_complete = true;\n}\n\nlet task = spawn(long_operation);\n\n// タイムアウト付きで待機（手動チェック）\nlet elapsed = 0;\nwhile (!operation_complete && elapsed < 1000) {\n    // スリープまたはチェック\n    elapsed = elapsed + 1;\n}\n\nif (!operation_complete) {\n    print(\"Operation timed out\");\n    detach(task);  // 待機をあきらめる\n} else {\n    join(task);\n    print(\"Operation completed\");\n}\n```\n\n## シグナルハンドラのデバッグ\n\n### 診断プリントを追加\n\n```hemlock\nfn debug_handler(sig) {\n    print(\"Handler called for signal: \" + typeof(sig));\n    print(\"Stack: (not yet available)\");\n\n    // ハンドラロジック...\n}\n\nsignal(SIGINT, debug_handler);\n```\n\n### シグナル呼び出しをカウント\n\n```hemlock\nlet handler_calls = 0;\n\nfn counting_handler(sig) {\n    handler_calls = handler_calls + 1;\n    print(\"Handler call #\" + typeof(handler_calls));\n\n    // ハンドラロジック...\n}\n```\n\n### raise()でテスト\n\n```hemlock\nfn test_handler(sig) {\n    print(\"Test signal received: \" + typeof(sig));\n}\n\nsignal(SIGUSR1, test_handler);\n\n// 手動で発生させてテスト\nraise(SIGUSR1);\nprint(\"Handler should have been called\");\n```\n\n## まとめ\n\nHemlockのシグナル処理は以下を提供します：\n\n- 低レベルプロセス制御のためのPOSIXシグナル処理\n- 15の標準シグナル定数\n- シンプルなsignal()とraise() API\n- クロージャサポート付きの柔軟なハンドラ関数\n- 複数のシグナルでハンドラを共有可能\n\n覚えておくべきこと：\n- シグナル処理は本質的にアンセーフ - 注意して使用\n- ハンドラはシンプルで高速に保つ\n- 複雑な操作ではなく、状態変更にはフラグを使用\n- ハンドラはいつでも実行を中断できる\n- SIGKILLやSIGSTOPはキャッチできない\n- raise()でハンドラを徹底的にテスト\n\n一般的なパターン：\n- グレースフルシャットダウン（SIGINT、SIGTERM）\n- 設定リロード（SIGHUP）\n- ログローテーション（SIGUSR1）\n- ステータス報告（SIGUSR1/SIGUSR2）\n- デバッグモード切り替え（SIGUSR2）\n"}, "高度なトピック -> バンドルとパッケージング": {"id": "advanced-bundling-packaging", "content": "# バンドリングとパッケージング\n\nHemlockは、複数ファイルのプロジェクトを単一の配布可能ファイルにバンドルし、自己完結型の実行ファイルを作成するための組み込みツールを提供します。\n\n## 概要\n\n| コマンド | 出力 | 使用ケース |\n|---------|--------|----------|\n| `--bundle` | `.hmlc` または `.hmlb` | バイトコードを配布（実行にはHemlockが必要） |\n| `--package` | 実行ファイル | スタンドアロンバイナリ（依存関係なし） |\n| `--compile` | `.hmlc` | 単一ファイルをコンパイル（インポート解決なし） |\n\n## バンドリング\n\nバンドラーはエントリポイントからすべての`import`文を解決し、単一のファイルにフラット化します。\n\n### 基本的な使用方法\n\n```bash\n# app.hmlとそのすべてのインポートをapp.hmlcにバンドル\nhemlock --bundle app.hml\n\n# 出力パスを指定\nhemlock --bundle app.hml -o dist/app.hmlc\n\n# 圧縮バンドル（.hmlb）を作成 - ファイルサイズが小さい\nhemlock --bundle app.hml --compress -o app.hmlb\n\n# 詳細出力（解決されたモジュールを表示）\nhemlock --bundle app.hml --verbose\n```\n\n### 出力形式\n\n**`.hmlc`（非圧縮）**\n- シリアル化されたAST形式\n- 読み込みと実行が高速\n- デフォルトの出力形式\n\n**`.hmlb`（圧縮）**\n- zlib圧縮された`.hmlc`\n- ファイルサイズが小さい（通常50-70%削減）\n- 解凍のため起動がやや遅い\n\n### バンドルファイルの実行\n\n```bash\n# 非圧縮バンドルを実行\nhemlock app.hmlc\n\n# 圧縮バンドルを実行\nhemlock app.hmlb\n\n# 引数を渡す\nhemlock app.hmlc arg1 arg2\n```\n\n### 例：マルチモジュールプロジェクト\n\n```\nmyapp/\n├── main.hml\n├── lib/\n│   ├── math.hml\n│   └── utils.hml\n└── config.hml\n```\n\n```hemlock\n// main.hml\nimport { add, multiply } from \"./lib/math.hml\";\nimport { log } from \"./lib/utils.hml\";\nimport { VERSION } from \"./config.hml\";\n\nlog(`App v${VERSION}`);\nprint(add(2, 3));\n```\n\n```bash\nhemlock --bundle myapp/main.hml -o myapp.hmlc\nhemlock myapp.hmlc  # すべての依存関係がバンドルされた状態で実行\n```\n\n### stdlibインポート\n\nバンドラーは`@stdlib/`インポートを自動的に解決します：\n\n```hemlock\nimport { HashMap } from \"@stdlib/collections\";\nimport { now } from \"@stdlib/time\";\n```\n\nバンドル時、stdlibモジュールは出力に含まれます。\n\n## パッケージング\n\nパッケージングは、バンドルされたバイトコードをHemlockインタープリターのコピーに埋め込むことで、自己完結型の実行ファイルを作成します。\n\n### 基本的な使用方法\n\n```bash\n# app.hmlから実行ファイルを作成\nhemlock --package app.hml\n\n# 出力名を指定\nhemlock --package app.hml -o myapp\n\n# 圧縮をスキップ（起動が速い、ファイルが大きい）\nhemlock --package app.hml --no-compress\n\n# 詳細出力\nhemlock --package app.hml --verbose\n```\n\n### パッケージ化された実行ファイルの実行\n\n```bash\n# パッケージ化された実行ファイルは直接実行される\n./myapp\n\n# 引数はスクリプトに渡される\n./myapp arg1 arg2\n```\n\n### パッケージ形式\n\nパッケージ化された実行ファイルはHMLP形式を使用します：\n\n```\n[hemlockバイナリ][HMLB/HMLCペイロード][payload_size:u64][HMLPマジック:u32]\n```\n\nパッケージ化された実行ファイルが実行されると：\n1. ファイル末尾の埋め込みペイロードをチェック\n2. 見つかった場合、ペイロードを解凍して実行\n3. 見つからない場合、通常のHemlockインタープリターとして動作\n\n### 圧縮オプション\n\n| フラグ | 形式 | 起動 | サイズ |\n|------|--------|---------|------|\n| （デフォルト） | HMLB | 通常 | 小さい |\n| `--no-compress` | HMLC | 速い | 大きい |\n\n起動時間が重要なCLIツールには、`--no-compress`を使用してください。\n\n## バンドルの検査\n\n`--info`を使用してバンドルまたはコンパイル済みファイルを検査できます：\n\n```bash\nhemlock --info app.hmlc\n```\n\n出力：\n```\n=== File Info: app.hmlc ===\nSize: 12847 bytes\nFormat: HMLC (compiled AST)\nVersion: 1\nFlags: 0x0001 [DEBUG]\nStrings: 42\nStatements: 156\n```\n\n```bash\nhemlock --info app.hmlb\n```\n\n出力：\n```\n=== File Info: app.hmlb ===\nSize: 5234 bytes\nFormat: HMLB (compressed bundle)\nVersion: 1\nUncompressed: 12847 bytes\nCompressed: 5224 bytes\nRatio: 59.3% reduction\n```\n\n## ネイティブコンパイル\n\n真のネイティブ実行ファイル（インタープリターなし）には、Hemlockコンパイラを使用します：\n\n```bash\n# Cを経由してネイティブ実行ファイルにコンパイル\nhemlockc app.hml -o app\n\n# 生成されたCコードを保持\nhemlockc app.hml -o app --keep-c\n\n# Cのみを出力（コンパイルしない）\nhemlockc app.hml -c -o app.c\n\n# 最適化レベル\nhemlockc app.hml -o app -O2\n```\n\nコンパイラはCコードを生成し、GCCを呼び出してネイティブバイナリを生成します。以下が必要です：\n- Hemlockランタイムライブラリ（`libhemlock_runtime`）\n- Cコンパイラ（デフォルトはGCC）\n\n### コンパイラオプション\n\n| オプション | 説明 |\n|--------|-------------|\n| `-o <file>` | 出力実行ファイル名 |\n| `-c` | Cコードのみを出力 |\n| `--emit-c <file>` | Cを指定ファイルに書き込む |\n| `-k, --keep-c` | コンパイル後に生成されたCを保持 |\n| `-O<level>` | 最適化レベル（0-3） |\n| `--cc <path>` | 使用するCコンパイラ |\n| `--runtime <path>` | ランタイムライブラリへのパス |\n| `-v, --verbose` | 詳細出力 |\n\n## 比較\n\n| アプローチ | ポータビリティ | 起動 | サイズ | 依存関係 |\n|----------|-------------|---------|------|--------------|\n| `.hml` | ソースのみ | パース時間 | 最小 | Hemlock |\n| `.hmlc` | Hemlockのみ | 速い | 小 | Hemlock |\n| `.hmlb` | Hemlockのみ | 速い | より小さい | Hemlock |\n| `--package` | スタンドアロン | 速い | 大きい | なし |\n| `hemlockc` | ネイティブ | 最速 | 可変 | ランタイムライブラリ |\n\n## ベストプラクティス\n\n1. **開発**：高速な反復のために`.hml`ファイルを直接実行\n2. **配布（Hemlockあり）**：より小さいファイルのために`--compress`でバンドル\n3. **配布（スタンドアロン）**：依存関係ゼロのデプロイのためにパッケージ化\n4. **パフォーマンス重視**：ネイティブコンパイルに`hemlockc`を使用\n\n## トラブルシューティング\n\n### \"Cannot find stdlib\"\n\nバンドラーは以下の場所でstdlibを探します：\n1. `./stdlib`（実行ファイルからの相対パス）\n2. `../stdlib`（実行ファイルからの相対パス）\n3. `/usr/local/lib/hemlock/stdlib`\n\nHemlockが正しくインストールされているか、ソースディレクトリから実行していることを確認してください。\n\n### 循環依存\n\n```\nError: Circular dependency detected when loading 'path/to/module.hml'\n```\n\nサイクルを解消するためにインポートをリファクタリングしてください。共通の型には共有モジュールの使用を検討してください。\n\n### パッケージサイズが大きい\n\n- デフォルトの圧縮を使用（`--no-compress`を使用しない）\n- パッケージサイズには完全なインタープリターが含まれます（ベース約500KB-1MB）\n- 最小サイズには、ネイティブコンパイルに`hemlockc`を使用\n"}, "高度なトピック -> プロファイリング": {"id": "advanced-profiling", "content": "# プロファイリング\n\nHemlockには、**CPU時間分析**、**メモリトラッキング**、**リーク検出**のための組み込みプロファイラーが含まれています。プロファイラーは、プログラムのパフォーマンスボトルネックとメモリの問題を特定するのに役立ちます。\n\n## 目次\n\n- [概要](#概要)\n- [クイックスタート](#クイックスタート)\n- [プロファイリングモード](#プロファイリングモード)\n- [出力形式](#出力形式)\n- [リーク検出](#リーク検出)\n- [レポートの理解](#レポートの理解)\n- [フレームグラフ生成](#フレームグラフ生成)\n- [ベストプラクティス](#ベストプラクティス)\n\n---\n\n## 概要\n\nプロファイラーは`profile`サブコマンドでアクセスします：\n\n```bash\nhemlock profile [OPTIONS] <FILE>\n```\n\n**主な機能：**\n- **CPUプロファイリング** - 各関数で費やされた時間を測定（自己時間と合計時間）\n- **メモリプロファイリング** - ソース位置付きですべての割り当てを追跡\n- **リーク検出** - 解放されなかったメモリを特定\n- **複数の出力形式** - テキスト、JSON、フレームグラフ互換出力\n- **関数ごとのメモリ統計** - どの関数が最もメモリを割り当てているかを確認\n\n---\n\n## クイックスタート\n\n### CPU時間のプロファイル（デフォルト）\n\n```bash\nhemlock profile script.hml\n```\n\n### メモリ割り当てのプロファイル\n\n```bash\nhemlock profile --memory script.hml\n```\n\n### メモリリークの検出\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n### フレームグラフデータの生成\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\nflamegraph.pl profile.folded > profile.svg\n```\n\n---\n\n## プロファイリングモード\n\n### CPUプロファイリング（デフォルト）\n\n各関数で費やされた時間を測定し、以下を区別します：\n- **自己時間** - 関数自体のコードを実行するのに費やされた時間\n- **合計時間** - 自己時間に呼び出された関数で費やされた時間を加えたもの\n\n```bash\nhemlock profile script.hml\nhemlock profile --cpu script.hml  # 明示的\n```\n\n**出力例：**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 1.234ms\nFunctions called: 5 unique\n\n--- Top 5 by Self Time ---\n\nFunction                        Self      Total   Calls\n--------                        ----      -----   -----\nexpensive_calc              0.892ms    0.892ms     100  (72.3%)\nprocess_data                0.234ms    1.126ms      10  (19.0%)\nhelper                      0.067ms    0.067ms     500  (5.4%)\nmain                        0.041ms    1.234ms       1  (3.3%)\n```\n\n---\n\n### メモリプロファイリング\n\nソース位置付きですべてのメモリ割り当て（`alloc`、`buffer`、`talloc`、`realloc`）を追跡します。\n\n```bash\nhemlock profile --memory script.hml\n```\n\n**出力例：**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 0.543ms\nFunctions called: 3 unique\nTotal allocations: 15 (4.2KB)\n\n--- Top 3 by Self Time ---\n\nFunction                        Self      Total   Calls      Alloc      Count\n--------                        ----      -----   -----      -----      -----\nallocator                   0.312ms    0.312ms      10      3.2KB         10  (57.5%)\nbuffer_ops                  0.156ms    0.156ms       5       1KB          5  (28.7%)\nmain                        0.075ms    0.543ms       1        0B          0  (13.8%)\n\n--- Top 10 Allocation Sites ---\n\nLocation                                      Total    Count\n--------                                      -----    -----\nsrc/data.hml:42                               1.5KB        5\nsrc/data.hml:67                               1.0KB       10\nsrc/main.hml:15                               512B         1\n```\n\n---\n\n### 呼び出し回数モード\n\n関数呼び出しのみをカウントする最小オーバーヘッドモード（タイミングなし）。\n\n```bash\nhemlock profile --calls script.hml\n```\n\n---\n\n## 出力形式\n\n### テキスト（デフォルト）\n\nテーブル付きの人間が読みやすい要約。\n\n```bash\nhemlock profile script.hml\n```\n\n---\n\n### JSON\n\n他のツールとの統合のための機械可読形式。\n\n```bash\nhemlock profile --json script.hml\n```\n\n**出力例：**\n```json\n{\n  \"total_time_ns\": 1234567,\n  \"function_count\": 5,\n  \"total_alloc_bytes\": 4096,\n  \"total_alloc_count\": 15,\n  \"functions\": [\n    {\n      \"name\": \"expensive_calc\",\n      \"source_file\": \"script.hml\",\n      \"line\": 10,\n      \"self_time_ns\": 892000,\n      \"total_time_ns\": 892000,\n      \"call_count\": 100,\n      \"alloc_bytes\": 0,\n      \"alloc_count\": 0\n    }\n  ],\n  \"alloc_sites\": [\n    {\n      \"source_file\": \"script.hml\",\n      \"line\": 42,\n      \"total_bytes\": 1536,\n      \"alloc_count\": 5,\n      \"current_bytes\": 0\n    }\n  ]\n}\n```\n\n---\n\n### フレームグラフ\n\n[flamegraph.pl](https://github.com/brendangregg/FlameGraph)と互換性のある折りたたみスタック形式を生成します。\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\n\n# flamegraph.plでSVGを生成\nflamegraph.pl profile.folded > profile.svg\n```\n\n**折りたたみ出力例：**\n```\nmain;process_data;expensive_calc 892\nmain;process_data;helper 67\nmain;process_data 234\nmain 41\n```\n\n---\n\n## リーク検出\n\n`--leaks`フラグは解放されなかった割り当てのみを表示し、メモリリークの特定を容易にします。\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n**リークのあるプログラム例：**\n```hemlock\nfn leaky() {\n    let p1 = alloc(100);    // リーク - 解放されない\n    let p2 = alloc(200);    // OK - 下で解放\n    free(p2);\n}\n\nfn clean() {\n    let b = buffer(64);\n    free(b);                // 正しく解放\n}\n\nleaky();\nclean();\n```\n\n**--leaksでの出力：**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 0.034ms\nFunctions called: 2 unique\nTotal allocations: 3 (388B)\n\n--- Top 2 by Self Time ---\n\nFunction                        Self      Total   Calls      Alloc      Count\n--------                        ----      -----   -----      -----      -----\nleaky                       0.021ms    0.021ms       1       300B          2  (61.8%)\nclean                       0.013ms    0.013ms       1        88B          1  (38.2%)\n\n--- Memory Leaks (1 site) ---\n\nLocation                                     Leaked      Total    Count\n--------                                     ------      -----    -----\nscript.hml:2                                   100B       100B        1\n```\n\nリークレポートは以下を表示します：\n- **Leaked** - プログラム終了時に未解放のバイト\n- **Total** - このサイトで割り当てられた総バイト数\n- **Count** - このサイトでの割り当て回数\n\n---\n\n## レポートの理解\n\n### 関数統計\n\n| 列 | 説明 |\n|--------|-------------|\n| Function | 関数名 |\n| Self | 呼び出し先を除いた関数内の時間 |\n| Total | 呼び出されたすべての関数を含む時間 |\n| Calls | 関数が呼び出された回数 |\n| Alloc | この関数によって割り当てられた総バイト数 |\n| Count | この関数による割り当て回数 |\n| (%) | プログラム総時間に対する割合 |\n\n### 割り当てサイト\n\n| 列 | 説明 |\n|--------|-------------|\n| Location | ソースファイルと行番号 |\n| Total | この場所で割り当てられた総バイト数 |\n| Count | 割り当て回数 |\n| Leaked | プログラム終了時にまだ割り当てられているバイト（--leaksのみ） |\n\n### 時間単位\n\nプロファイラーは適切な単位を自動的に選択します：\n- `ns` - ナノ秒（< 1us）\n- `us` - マイクロ秒（< 1ms）\n- `ms` - ミリ秒（< 1s）\n- `s` - 秒\n\n---\n\n## コマンドリファレンス\n\n```\nhemlock profile [OPTIONS] <FILE>\n\nOPTIONS:\n    --cpu           CPU/時間プロファイリング（デフォルト）\n    --memory        メモリ割り当てプロファイリング\n    --calls         呼び出し回数のみ（最小オーバーヘッド）\n    --leaks         未解放の割り当てのみを表示（--memoryを暗黙的に含む）\n    --json          JSON形式で出力\n    --flamegraph    フレームグラフ互換形式で出力\n    --top N         上位N件を表示（デフォルト：20）\n```\n\n---\n\n## フレームグラフ生成\n\nフレームグラフは、プログラムが時間を費やしている場所を視覚化し、より広いバーはより多くの時間が費やされていることを示します。\n\n### フレームグラフの生成\n\n1. flamegraph.plをインストール：\n   ```bash\n   git clone https://github.com/brendangregg/FlameGraph\n   ```\n\n2. プログラムをプロファイル：\n   ```bash\n   hemlock profile --flamegraph script.hml > profile.folded\n   ```\n\n3. SVGを生成：\n   ```bash\n   ./FlameGraph/flamegraph.pl profile.folded > profile.svg\n   ```\n\n4. `profile.svg`をブラウザで開いてインタラクティブな視覚化を確認。\n\n### フレームグラフの読み方\n\n- **X軸**：総時間の割合（幅 = 時間の割合）\n- **Y軸**：コールスタックの深さ（下 = エントリポイント、上 = リーフ関数）\n- **色**：視覚的区別のためのランダム\n- **クリック**：関数にズームインして呼び出し先を確認\n\n---\n\n## ベストプラクティス\n\n### 1. 代表的なワークロードをプロファイル\n\n現実的なデータと使用パターンでプロファイルしてください。小さなテストケースでは実際のボトルネックが明らかにならない場合があります。\n\n```bash\n# 良い例：本番環境に近いデータでプロファイル\nhemlock profile --memory process_large_file.hml large_input.txt\n\n# あまり有用でない：小さなテストケース\nhemlock profile quick_test.hml\n```\n\n### 2. 開発中に--leaksを使用\n\nメモリリークを早期に発見するため、定期的にリーク検出を実行：\n\n```bash\nhemlock profile --leaks my_program.hml\n```\n\n### 3. 前後を比較\n\n最適化の効果を測定するため、最適化前後でプロファイル：\n\n```bash\n# 最適化前\nhemlock profile --json script.hml > before.json\n\n# 最適化後\nhemlock profile --json script.hml > after.json\n\n# 結果を比較\n```\n\n### 4. 大きなプログラムには--topを使用\n\n最も重要な関数に焦点を当てるため出力を制限：\n\n```bash\nhemlock profile --top 10 large_program.hml\n```\n\n### 5. フレームグラフと組み合わせる\n\n複雑なコールパターンでは、フレームグラフがテキスト出力より良い視覚化を提供：\n\n```bash\nhemlock profile --flamegraph complex_app.hml > app.folded\nflamegraph.pl app.folded > app.svg\n```\n\n---\n\n## プロファイラーオーバーヘッド\n\nプロファイラーはプログラム実行にいくらかのオーバーヘッドを追加します：\n\n| モード | オーバーヘッド | 使用ケース |\n|------|----------|----------|\n| `--calls` | 最小 | 関数呼び出しのカウントのみ |\n| `--cpu` | 低 | 一般的なパフォーマンスプロファイリング |\n| `--memory` | 中程度 | メモリ分析とリーク検出 |\n\n最も正確な結果を得るには、複数回プロファイルして一貫したパターンを探してください。\n\n---\n\n## 関連項目\n\n- [メモリ管理](#language-guide-memory) - ポインタとバッファ\n- [メモリAPI](#reference-memory-api) - alloc、free、buffer関数\n- [非同期/並行性](#advanced-async-concurrency) - 非同期コードのプロファイリング\n"}, "高度なトピック -> 非同期と並行処理": {"id": "advanced-async-concurrency", "content": "# Hemlockにおける非同期/並行処理\n\nHemlockは、async/await構文、タスクの生成、通信用チャネルを備えた**構造化並行処理**を提供します。実装はPOSIXスレッド（pthread）を使用した**真のマルチスレッド並列処理**を実現しています。\n\n## 目次\n\n- [概要](#概要)\n- [スレッディングモデル](#スレッディングモデル)\n- [非同期関数](#非同期関数)\n- [タスクの生成](#タスクの生成)\n- [チャネル](#チャネル)\n- [例外の伝播](#例外の伝播)\n- [実装の詳細](#実装の詳細)\n- [ベストプラクティス](#ベストプラクティス)\n- [パフォーマンス特性](#パフォーマンス特性)\n- [現在の制限事項](#現在の制限事項)\n\n## 概要\n\n**これが意味すること：**\n- ✅ **実際のOSスレッド** - 生成された各タスクは別々のpthread（POSIXスレッド）で実行される\n- ✅ **真の並列処理** - タスクは複数のCPUコアで同時に実行される\n- ✅ **カーネルスケジュール** - OSスケジューラがタスクを利用可能なコアに分散する\n- ✅ **スレッドセーフなチャネル** - 同期にpthreadミューテックスと条件変数を使用\n\n**これは以下ではない：**\n- ❌ **グリーンスレッドではない** - ユーザー空間の協調的マルチタスクではない\n- ❌ **async/awaitコルーチンではない** - JavaScript/Python asyncioのようなシングルスレッドイベントループではない\n- ❌ **エミュレートされた並行処理ではない** - 疑似的な並列処理ではない\n\nこれは、OSスレッドを使用する際の**C、C++、Rustと同じスレッディングモデル**です。複数のコアにまたがる実際の並列実行が得られます。\n\n## スレッディングモデル\n\n### 1:1スレッディング\n\nHemlockは**1:1スレッディングモデル**を使用しています：\n- 生成された各タスクは`pthread_create()`を介して専用のOSスレッドを作成する\n- OSカーネルがスレッドを利用可能なCPUコアにスケジュールする\n- プリエンプティブマルチタスク - OSがスレッド間を中断して切り替えることができる\n- **GILなし** - Pythonとは異なり、並列処理を制限するグローバルインタプリタロックがない\n\n### 同期メカニズム\n\n- **ミューテックス** - チャネルはスレッドセーフなアクセスに`pthread_mutex_t`を使用\n- **条件変数** - ブロッキングsend/recvは効率的な待機に`pthread_cond_t`を使用\n- **ロックフリー操作** - タスク状態の遷移はアトミック\n\n## 非同期関数\n\n関数を`async`として宣言して、並行実行用に設計されていることを示すことができます：\n\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n```\n\n### 重要なポイント\n\n- `async fn`は非同期関数を宣言する\n- 非同期関数は`spawn()`を使用して並行タスクとして生成できる\n- 非同期関数は直接呼び出すこともできる（現在のスレッドで同期的に実行）\n- 生成されると、各タスクは**独自のOSスレッド**で実行される（コルーチンではない！）\n- `await`キーワードは将来の使用のために予約されている\n\n### 例：直接呼び出しとスポーンの比較\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// 直接呼び出し - 同期的に実行\nlet result1 = factorial(5);  // 120\n\n// 生成されたタスク - 別のスレッドで実行\nlet task = spawn(factorial, 5);\nlet result2 = join(task);  // 120\n```\n\n## タスクの生成\n\n`spawn()`を使用して非同期関数を**別のOSスレッドで並列に**実行します：\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// 複数のタスクを生成 - これらは異なるCPUコアで並列に実行される！\nlet t1 = spawn(factorial, 5);  // スレッド1\nlet t2 = spawn(factorial, 6);  // スレッド2\nlet t3 = spawn(factorial, 7);  // スレッド3\n\n// 3つすべてが今同時に計算している！\n\n// 結果を待つ\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\n```\n\n### 組み込み関数\n\n#### spawn(async_fn, arg1, arg2, ...)\n\n新しいpthreadで新しいタスクを作成し、タスクハンドルを返します。\n\n**パラメータ：**\n- `async_fn` - 実行する非同期関数\n- `arg1, arg2, ...` - 関数に渡す引数\n\n**戻り値：** タスクハンドル（`join()`や`detach()`で使用する不透明な値）\n\n**例：**\n```hemlock\nasync fn process(data: string, count: i32): i32 {\n    // ... 処理ロジック\n    return count * 2;\n}\n\nlet task = spawn(process, \"test\", 42);\n```\n\n#### join(task)\n\nタスクの完了を待ち（スレッドが終了するまでブロック）、結果を返します。\n\n**パラメータ：**\n- `task` - `spawn()`から返されたタスクハンドル\n\n**戻り値：** 非同期関数が返した値\n\n**例：**\n```hemlock\nlet task = spawn(compute, 1000);\nlet result = join(task);  // compute()が終了するまでブロック\nprint(result);\n```\n\n**重要：** 各タスクは一度だけjoinできます。以降のjoinはエラーになります。\n\n#### detach(task)\n\nファイアアンドフォーゲット実行（スレッドは独立して実行され、joinは許可されない）。\n\n**パラメータ：**\n- `task` - `spawn()`から返されたタスクハンドル\n\n**戻り値：** `null`\n\n**例：**\n```hemlock\nasync fn background_work() {\n    // 長時間実行されるバックグラウンドタスク\n    // ...\n}\n\nlet task = spawn(background_work);\ndetach(task);  // タスクは独立して実行され、joinできない\n```\n\n**重要：** デタッチされたタスクはjoinできません。タスクが完了すると、pthreadとTaskの両方の構造体が自動的にクリーンアップされます。\n\n## チャネル\n\nチャネルは、ブロッキングセマンティクスを持つ境界付きバッファを使用して、タスク間のスレッドセーフな通信を提供します。\n\n### チャネルの作成\n\n```hemlock\nlet ch = channel(10);  // バッファサイズ10のチャネルを作成\n```\n\n**パラメータ：**\n- `capacity`（i32） - チャネルが保持できる値の最大数\n\n**戻り値：** チャネルオブジェクト\n\n### チャネルメソッド\n\n#### send(value)\n\nチャネルに値を送信します（満杯の場合はブロック）。\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet task = spawn(producer, ch, 5);\n```\n\n**動作：**\n- チャネルにスペースがあれば、値はすぐに追加される\n- チャネルが満杯の場合、送信者はスペースが利用可能になるまでブロックする\n- チャネルが閉じられている場合、例外をスロー\n\n#### recv()\n\nチャネルから値を受信します（空の場合はブロック）。\n\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet task = spawn(consumer, ch, 5);\n```\n\n**動作：**\n- チャネルに値があれば、次の値をすぐに返す\n- チャネルが空の場合、受信者は値が利用可能になるまでブロックする\n- チャネルが閉じられ空の場合、`null`を返す\n\n#### close()\n\nチャネルを閉じます（閉じられたチャネルでのrecvはnullを返す）。\n\n```hemlock\nch.close();\n```\n\n**動作：**\n- 以降の`send()`操作を防ぐ（例外をスローする）\n- 保留中の`recv()`操作は完了できる\n- 空になると、`recv()`は`null`を返す\n\n### select()による多重化\n\n`select()`関数は、複数のチャネルを同時に待機し、いずれかのチャネルでデータが利用可能になったときに返します。\n\n**シグネチャ：**\n```hemlock\nselect(channels: array, timeout_ms?: i32): object | null\n```\n\n**パラメータ：**\n- `channels` - チャネル値の配列\n- `timeout_ms`（オプション） - ミリ秒単位のタイムアウト（-1または省略で無限待機）\n\n**戻り値：**\n- `{ channel, value }` - データを持っていたチャネルと受信した値を含むオブジェクト\n- `null` - タイムアウト時（タイムアウトが指定されている場合）\n\n**例：**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// プロデューサータスク\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"from channel 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"from channel 2\");\n});\n\n// 最初の結果を待つ（ch2の方が速いはず）\nlet result = select([ch1, ch2]);\nprint(result.value);  // \"from channel 2\"\n\n// 2番目の結果を待つ\nlet result2 = select([ch1, ch2]);\nprint(result2.value);  // \"from channel 1\"\n```\n\n**タイムアウト付き：**\n```hemlock\nlet ch = channel(1);\n\n// 送信者がいないのでタイムアウトする\nlet result = select([ch], 100);  // 100msタイムアウト\nif (result == null) {\n    print(\"タイムアウトしました！\");\n}\n```\n\n**ユースケース：**\n- 複数のデータソースの中で最も速いものを待つ\n- チャネル操作にタイムアウトを実装する\n- 複数のイベントソースを持つイベントループパターン\n- ファンイン：複数のチャネルを1つにマージ\n\n**ファンインパターン：**\n```hemlock\nfn fan_in(channels: array, output: channel) {\n    while (true) {\n        let result = select(channels);\n        if (result == null) {\n            break;  // すべてのチャネルが閉じられた\n        }\n        output.send(result.value);\n    }\n    output.close();\n}\n```\n\n### 完全なプロデューサー・コンシューマーの例\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// バッファサイズ付きでチャネルを作成\nlet ch = channel(10);\n\n// プロデューサーとコンシューマーを生成\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// 完了を待つ\njoin(p);\nlet total = join(c);  // 100 (0+10+20+30+40)\nprint(total);\n```\n\n### マルチプロデューサー、マルチコンシューマー\n\nチャネルは複数のプロデューサーとコンシューマー間で安全に共有できます：\n\n```hemlock\nasync fn producer(id: i32, ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(id * 100 + i);\n        i = i + 1;\n    }\n}\n\nasync fn consumer(id: i32, ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(20);\n\n// 複数のプロデューサー\nlet p1 = spawn(producer, 1, ch, 5);\nlet p2 = spawn(producer, 2, ch, 5);\n\n// 複数のコンシューマー\nlet c1 = spawn(consumer, 1, ch, 5);\nlet c2 = spawn(consumer, 2, ch, 5);\n\n// すべてを待つ\njoin(p1);\njoin(p2);\nlet sum1 = join(c1);\nlet sum2 = join(c2);\nprint(sum1 + sum2);\n```\n\n## 例外の伝播\n\n生成されたタスクでスローされた例外は、joinされたときに伝播されます：\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"タスクが失敗しました！\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"キャッチ: \" + e);  // \"キャッチ: タスクが失敗しました！\"\n}\n```\n\n### 例外処理パターン\n\n**パターン1：タスク内で処理**\n```hemlock\nasync fn safe_task() {\n    try {\n        // リスクのある操作\n    } catch (e) {\n        print(\"タスク内でエラー: \" + e);\n        return null;\n    }\n}\n\nlet task = spawn(safe_task);\njoin(task);  // 例外は伝播されない\n```\n\n**パターン2：呼び出し元に伝播**\n```hemlock\nasync fn task_that_throws() {\n    throw \"エラー\";\n}\n\nlet task = spawn(task_that_throws);\ntry {\n    join(task);\n} catch (e) {\n    print(\"タスクからキャッチ: \" + e);\n}\n```\n\n**パターン3：例外を持つデタッチされたタスク**\n```hemlock\nasync fn detached_task() {\n    try {\n        // 作業\n    } catch (e) {\n        // 内部で処理する必要がある - 伝播できない\n        print(\"エラー: \" + e);\n    }\n}\n\nlet task = spawn(detached_task);\ndetach(task);  // デタッチされたタスクからは例外をキャッチできない\n```\n\n## 実装の詳細\n\n### スレッディングアーキテクチャ\n\n- **1:1スレッディング** - 生成された各タスクは`pthread_create()`を介して専用のOSスレッドを作成する\n- **カーネルスケジュール** - OSカーネルがスレッドを利用可能なCPUコアにスケジュールする\n- **プリエンプティブマルチタスク** - OSがスレッド間を中断して切り替えることができる\n- **GILなし** - Pythonとは異なり、並列処理を制限するグローバルインタプリタロックがない\n\n### チャネルの実装\n\nチャネルはpthread同期を備えた循環バッファを使用します：\n\n```\nチャネル構造体：\n- buffer[] - 値の固定サイズ配列\n- capacity - 要素の最大数\n- size - 現在の要素数\n- head - 読み取り位置\n- tail - 書き込み位置\n- mutex - スレッドセーフなアクセス用のpthread_mutex_t\n- not_empty - ブロッキングrecv用のpthread_cond_t\n- not_full - ブロッキングsend用のpthread_cond_t\n- closed - ブール値フラグ\n- refcount - クリーンアップ用の参照カウント\n```\n\n**ブロッキング動作：**\n- 満杯のチャネルでの`send()`: `not_full`条件変数で待機\n- 空のチャネルでの`recv()`: `not_empty`条件変数で待機\n- 両方とも反対の操作によって適切にシグナルされる\n\n### メモリとクリーンアップ\n\n- **joinされたタスク:** `join()`が返った後に自動的にクリーンアップされる\n- **デタッチされたタスク:** タスクが完了すると自動的にクリーンアップされる\n- **チャネル:** 参照カウントされ、使用されなくなったときに解放される\n\n## ベストプラクティス\n\n### 1. 常にチャネルを閉じる\n\n```hemlock\nasync fn producer(ch) {\n    // ... 値を送信\n    ch.close();  // 重要：これ以上の値がないことを通知\n}\n```\n\n### 2. 構造化並行処理を使用する\n\n同じスコープ内でタスクを生成してjoinする：\n\n```hemlock\nfn process_data(data) {\n    // タスクを生成\n    let t1 = spawn(worker, data);\n    let t2 = spawn(worker, data);\n\n    // 返す前に常にjoinする\n    let r1 = join(t1);\n    let r2 = join(t2);\n\n    return r1 + r2;\n}\n```\n\n### 3. 例外を適切に処理する\n\n```hemlock\nasync fn task() {\n    try {\n        // リスクのある操作\n    } catch (e) {\n        // エラーをログに記録\n        throw e;  // 呼び出し元が知る必要がある場合は再スロー\n    }\n}\n```\n\n### 4. 適切なチャネル容量を使用する\n\n- **小さい容量（1-10）:** 調整/シグナル用\n- **中程度の容量（10-100）:** 一般的なプロデューサー・コンシューマー用\n- **大きい容量（100以上）:** 高スループットシナリオ用\n\n```hemlock\nlet signal_ch = channel(1);      // 調整\nlet work_ch = channel(50);       // ワークキュー\nlet buffer_ch = channel(1000);   // 高スループット\n```\n\n### 5. 必要な場合のみデタッチする\n\nより良いリソース管理のために`detach()`よりも`join()`を優先する：\n\n```hemlock\n// 良い：joinして結果を取得\nlet task = spawn(work);\nlet result = join(task);\n\n// 真のファイアアンドフォーゲットにのみdetachを使用\nlet bg_task = spawn(background_logging);\ndetach(bg_task);  // 独立して実行される\n```\n\n## パフォーマンス特性\n\n### 真の並列処理\n\n- **N個の生成されたタスクがN個のCPUコアを同時に利用できる**\n- 実証済みの高速化 - ストレステストではウォール時間に対してCPU時間が8-9倍を示す（複数のコアが動作）\n- コア数に応じた線形スケーリング（スレッド数まで）\n\n### スレッドオーバーヘッド\n\n- 各タスクには約8KBのスタック + pthreadオーバーヘッドがある\n- スレッド作成コスト：約10-20μs\n- コンテキストスイッチコスト：約1-5μs\n\n### asyncを使用するタイミング\n\n**良いユースケース：**\n- 並列化可能なCPU集中型計算\n- I/Oバウンド操作（ただしI/Oはまだブロッキング）\n- 独立したデータの並行処理\n- チャネルを使用したパイプラインアーキテクチャ\n\n**理想的でないケース：**\n- 非常に短いタスク（スレッドオーバーヘッドが支配的）\n- 重い同期を持つタスク（競合オーバーヘッド）\n- シングルコアシステム（並列化の利点なし）\n\n### ブロッキングI/Oも安全\n\n1つのタスクでのブロッキング操作は他をブロックしない：\n\n```hemlock\nasync fn reader(filename: string) {\n    let f = open(filename, \"r\");  // このスレッドのみブロック\n    let content = f.read();       // このスレッドのみブロック\n    f.close();\n    return content;\n}\n\n// 両方が並行して読み取る（異なるスレッドで）\nlet t1 = spawn(reader, \"file1.txt\");\nlet t2 = spawn(reader, \"file2.txt\");\n\nlet c1 = join(t1);\nlet c2 = join(t2);\n```\n\n## スレッド安全性モデル\n\nHemlockは、タスクが共有可変状態ではなくチャネル経由で通信する**メッセージパッシング**並行処理モデルを使用します。\n\n### 引数の分離\n\nタスクを生成するとき、データ競合を防ぐために**引数はディープコピー**されます：\n\n```hemlock\nasync fn modify_array(arr: array): array {\n    arr.push(999);    // コピーを変更、元は変更されない\n    arr[0] = -1;\n    return arr;\n}\n\nlet original = [1, 2, 3];\nlet task = spawn(modify_array, original);\nlet modified = join(task);\n\nprint(original.length);  // 3 - 変更されていない！\nprint(modified.length);  // 4 - 新しい要素がある\n```\n\n**ディープコピーされるもの：**\n- 配列（およびすべての要素を再帰的に）\n- オブジェクト（およびすべてのフィールドを再帰的に）\n- 文字列\n- バッファ\n\n**共有されるもの（参照が保持される）：**\n- チャネル（通信メカニズム - 意図的に共有）\n- タスクハンドル（調整用）\n- 関数（コードは不変）\n- ファイルハンドル（OSが並行アクセスを管理）\n- ソケットハンドル（OSが並行アクセスを管理）\n\n**渡せないもの：**\n- 生のポインタ（`ptr`） - 代わりに`buffer`を使用\n\n### なぜメッセージパッシングなのか？\n\nこれはHemlockの「暗黙より明示」の哲学に従っています：\n\n```hemlock\n// 悪い例：共有可変状態（データ競合を引き起こす）\nlet counter = { value: 0 };\nlet t1 = spawn(fn() { counter.value = counter.value + 1; });  // 競合！\nlet t2 = spawn(fn() { counter.value = counter.value + 1; });  // 競合！\n\n// 良い例：チャネル経由のメッセージパッシング\nasync fn increment(ch) {\n    let val = ch.recv();\n    ch.send(val + 1);\n}\n\nlet ch = channel(1);\nch.send(0);\nlet t1 = spawn(increment, ch);\njoin(t1);\nlet result = ch.recv();  // 1 - 競合条件なし\n```\n\n### 参照カウントのスレッド安全性\n\nすべての参照カウント操作は、解放後使用バグを防ぐために**アトミック操作**を使用します：\n- `string_retain/release` - アトミック\n- `array_retain/release` - アトミック\n- `object_retain/release` - アトミック\n- `buffer_retain/release` - アトミック\n- `function_retain/release` - アトミック\n- `channel_retain/release` - アトミック\n- `task_retain/release` - アトミック\n\nこれにより、値がスレッド間で共有されている場合でも、安全なメモリ管理が保証されます。\n\n### クロージャ環境へのアクセス\n\nタスクは以下のクロージャ環境にアクセスできます：\n- 組み込み関数（`print`、`len`など）\n- グローバル関数定義\n- 定数と変数\n\nクロージャ環境は環境ごとのミューテックスによって保護されており、\n並行読み書きがスレッドセーフになります：\n\n```hemlock\nlet x = 10;\n\nasync fn read_closure(): i32 {\n    return x;  // OK：クロージャ変数の読み取り（スレッドセーフ）\n}\n\nasync fn modify_closure() {\n    x = 20;  // OK：クロージャ変数への書き込み（ミューテックスで同期）\n}\n```\n\n**注意：** 並行アクセスは同期されますが、複数のタスクから共有状態を変更すると\n論理的な競合条件（非決定論的な順序）が発生する可能性があります。予測可能な動作のためには、\nタスク通信にチャネルを使用するか、タスクから値を返してください。\n\nタスクからデータを返す必要がある場合は、戻り値またはチャネルを使用してください。\n\n## 現在の制限事項\n\n### 1. ワークスティーリングスケジューラがない\n\nタスクごとに1スレッドを使用するため、多くの短いタスクでは非効率になる可能性があります。\n\n**現在：** 1000タスク = 1000スレッド（重いオーバーヘッド）\n\n**計画中：** より効率的なワークスティーリング付きスレッドプール\n\n### 3. 非同期I/O統合がない\n\nファイル/ネットワーク操作はまだスレッドをブロックします：\n\n```hemlock\nasync fn read_file(path: string) {\n    let f = open(path, \"r\");\n    let content = f.read();  // スレッドをブロック\n    f.close();\n    return content;\n}\n```\n\n**回避策：** 並行I/O操作には複数のスレッドを使用\n\n### 4. 固定チャネル容量\n\nチャネル容量は作成時に設定され、サイズ変更できません：\n\n```hemlock\nlet ch = channel(10);\n// 動的に20にサイズ変更できない\n```\n\n### 5. チャネルサイズは固定\n\nチャネルバッファサイズは作成後に変更できません。\n\n## 一般的なパターン\n\n### 並列マップ\n\n```hemlock\nasync fn map_worker(ch_in, ch_out, fn_transform) {\n    while (true) {\n        let val = ch_in.recv();\n        if (val == null) { break; }\n\n        let result = fn_transform(val);\n        ch_out.send(result);\n    }\n    ch_out.close();\n}\n\nfn parallel_map(data, fn_transform, workers: i32) {\n    let ch_in = channel(100);\n    let ch_out = channel(100);\n\n    // ワーカーを生成\n    let tasks = [];\n    let i = 0;\n    while (i < workers) {\n        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));\n        i = i + 1;\n    }\n\n    // データを送信\n    let i = 0;\n    while (i < data.length) {\n        ch_in.send(data[i]);\n        i = i + 1;\n    }\n    ch_in.close();\n\n    // 結果を収集\n    let results = [];\n    let i = 0;\n    while (i < data.length) {\n        results.push(ch_out.recv());\n        i = i + 1;\n    }\n\n    // ワーカーを待つ\n    let i = 0;\n    while (i < tasks.length) {\n        join(tasks[i]);\n        i = i + 1;\n    }\n\n    return results;\n}\n```\n\n### パイプラインアーキテクチャ\n\n```hemlock\nasync fn stage1(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val * 2);\n    }\n    output_ch.close();\n}\n\nasync fn stage2(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val + 10);\n    }\n    output_ch.close();\n}\n\n// パイプラインを作成\nlet ch1 = channel(10);\nlet ch2 = channel(10);\nlet ch3 = channel(10);\n\nlet s1 = spawn(stage1, ch1, ch2);\nlet s2 = spawn(stage2, ch2, ch3);\n\n// 入力をフィード\nch1.send(1);\nch1.send(2);\nch1.send(3);\nch1.close();\n\n// 出力を収集\nprint(ch3.recv());  // 12 (1 * 2 + 10)\nprint(ch3.recv());  // 14 (2 * 2 + 10)\nprint(ch3.recv());  // 16 (3 * 2 + 10)\n\njoin(s1);\njoin(s2);\n```\n\n### ファンアウト、ファンイン\n\n```hemlock\nasync fn worker(id: i32, input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n\n        // 値を処理\n        let result = val * id;\n        output_ch.send(result);\n    }\n}\n\nlet input = channel(10);\nlet output = channel(10);\n\n// ファンアウト：複数のワーカー\nlet workers = 4;\nlet tasks = [];\nlet i = 0;\nwhile (i < workers) {\n    tasks.push(spawn(worker, i, input, output));\n    i = i + 1;\n}\n\n// 作業を送信\nlet i = 0;\nwhile (i < 10) {\n    input.send(i);\n    i = i + 1;\n}\ninput.close();\n\n// ファンイン：すべての結果を収集\nlet results = [];\nlet i = 0;\nwhile (i < 10) {\n    results.push(output.recv());\n    i = i + 1;\n}\n\n// すべてのワーカーを待つ\nlet i = 0;\nwhile (i < tasks.length) {\n    join(tasks[i]);\n    i = i + 1;\n}\n```\n\n## まとめ\n\nHemlockの非同期/並行処理モデルは以下を提供します：\n\n- ✅ OSスレッドを使用した真のマルチスレッド並列処理\n- ✅ シンプルで構造化された並行処理プリミティブ\n- ✅ 通信用のスレッドセーフなチャネル\n- ✅ タスク間の例外伝播\n- ✅ マルチコアシステムでの実証済みパフォーマンス\n- ✅ **引数の分離** - ディープコピーによるデータ競合の防止\n- ✅ **アトミック参照カウント** - スレッド間での安全なメモリ管理\n\nこれによりHemlockは以下に適しています：\n- 並列計算\n- 並行I/O操作\n- パイプラインアーキテクチャ\n- プロデューサー・コンシューマーパターン\n\n以下の複雑さを回避しながら：\n- 手動スレッド管理\n- 低レベル同期プリミティブ\n- デッドロックを起こしやすいロックベース設計\n- 共有可変状態のバグ\n"}, "APIリファレンス -> ファイルAPI": {"id": "reference-file-api", "content": "# ファイルAPIリファレンス\n\nHemlockのファイルI/Oシステムの完全なリファレンスです。\n\n---\n\n## 概要\n\nHemlockは適切なエラーハンドリングとリソース管理を備えた**ファイルオブジェクトAPI**をファイル操作に提供します。ファイルは手動でオープンおよびクローズする必要があります。\n\n**主な機能：**\n- メソッド付きファイルオブジェクト\n- テキストとバイナリデータの読み書き\n- シークと位置決め\n- 適切なエラーメッセージ\n- 手動リソース管理（RAIIなし）\n\n---\n\n## ファイル型\n\n**型：** `file`\n\n**説明：** I/O操作用のファイルハンドル\n\n**プロパティ（読み取り専用）：**\n- `.path` - ファイルパス（string）\n- `.mode` - オープンモード（string）\n- `.closed` - ファイルがクローズされているか（bool）\n\n---\n\n## ファイルのオープン\n\n### open\n\n読み取り、書き込み、または両方のためにファイルをオープンします。\n\n**シグネチャ：**\n```hemlock\nopen(path: string, mode?: string): file\n```\n\n**パラメータ：**\n- `path` - ファイルパス（相対または絶対）\n- `mode`（オプション）- オープンモード（デフォルト：`\"r\"`）\n\n**戻り値：** ファイルオブジェクト\n\n**モード：**\n- `\"r\"` - 読み取り（デフォルト）\n- `\"w\"` - 書き込み（既存ファイルを切り詰め）\n- `\"a\"` - 追加\n- `\"r+\"` - 読み取りと書き込み\n- `\"w+\"` - 読み取りと書き込み（切り詰め）\n- `\"a+\"` - 読み取りと追加\n\n**例：**\n```hemlock\n// 読み取りモード（デフォルト）\nlet f = open(\"data.txt\");\nlet f_read = open(\"data.txt\", \"r\");\n\n// 書き込みモード（切り詰め）\nlet f_write = open(\"output.txt\", \"w\");\n\n// 追加モード\nlet f_append = open(\"log.txt\", \"a\");\n\n// 読み取り/書き込みモード\nlet f_rw = open(\"data.bin\", \"r+\");\n\n// 読み取り/書き込み（切り詰め）\nlet f_rw_trunc = open(\"output.bin\", \"w+\");\n\n// 読み取り/追加\nlet f_ra = open(\"log.txt\", \"a+\");\n```\n\n**エラーハンドリング：**\n```hemlock\ntry {\n    let f = open(\"missing.txt\", \"r\");\n} catch (e) {\n    print(\"Failed to open:\", e);\n    // Error: Failed to open 'missing.txt': No such file or directory\n}\n```\n\n**重要：** ファイルディスクリプタのリークを避けるため、`f.close()`で手動でクローズする必要があります。\n\n---\n\n## ファイルメソッド\n\n### 読み取り\n\n#### read\n\nファイルからテキストを読み取ります。\n\n**シグネチャ：**\n```hemlock\nfile.read(size?: i32): string\n```\n\n**パラメータ：**\n- `size`（オプション）- 読み取るバイト数（省略時はEOFまで読み取り）\n\n**戻り値：** ファイル内容の文字列\n\n**例：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// ファイル全体を読み取り\nlet all = f.read();\nprint(all);\n\n// 特定のバイト数を読み取り\nlet chunk = f.read(1024);\n\nf.close();\n```\n\n**動作：**\n- 現在のファイル位置から読み取り\n- EOFでは空文字列を返す\n- ファイル位置を進める\n\n**エラー：**\n- クローズされたファイルからの読み取り\n- 書き込み専用ファイルからの読み取り\n\n---\n\n#### read_bytes\n\nファイルからバイナリデータを読み取ります。\n\n**シグネチャ：**\n```hemlock\nfile.read_bytes(size: i32): buffer\n```\n\n**パラメータ：**\n- `size` - 読み取るバイト数\n\n**戻り値：** バイナリデータを含むバッファ\n\n**例：**\n```hemlock\nlet f = open(\"data.bin\", \"r\");\n\n// 256バイトを読み取り\nlet binary = f.read_bytes(256);\nprint(binary.length);       // 256\n\n// バイナリデータを処理\nlet i = 0;\nwhile (i < binary.length) {\n    print(binary[i]);\n    i = i + 1;\n}\n\nf.close();\n```\n\n**動作：**\n- 正確なバイト数を読み取り\n- バッファを返す（文字列ではない）\n- ファイル位置を進める\n\n---\n\n### 書き込み\n\n#### write\n\nファイルにテキストを書き込みます。\n\n**シグネチャ：**\n```hemlock\nfile.write(data: string): i32\n```\n\n**パラメータ：**\n- `data` - 書き込む文字列\n\n**戻り値：** 書き込まれたバイト数（i32）\n\n**例：**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\n\n// テキストを書き込み\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Wrote\", written, \"bytes\");\n\n// 複数回書き込み\nf.write(\"Line 1\\n\");\nf.write(\"Line 2\\n\");\nf.write(\"Line 3\\n\");\n\nf.close();\n```\n\n**動作：**\n- 現在のファイル位置に書き込み\n- 書き込まれたバイト数を返す\n- ファイル位置を進める\n\n**エラー：**\n- クローズされたファイルへの書き込み\n- 読み取り専用ファイルへの書き込み\n\n---\n\n#### write_bytes\n\nファイルにバイナリデータを書き込みます。\n\n**シグネチャ：**\n```hemlock\nfile.write_bytes(data: buffer): i32\n```\n\n**パラメータ：**\n- `data` - 書き込むバッファ\n\n**戻り値：** 書き込まれたバイト数（i32）\n\n**例：**\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// バッファを作成\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// バッファを書き込み\nlet written = f.write_bytes(buf);\nprint(\"Wrote\", written, \"bytes\");\n\nf.close();\n```\n\n**動作：**\n- バッファの内容をファイルに書き込み\n- 書き込まれたバイト数を返す\n- ファイル位置を進める\n\n---\n\n### シーク\n\n#### seek\n\nファイル位置を特定のバイトオフセットに移動します。\n\n**シグネチャ：**\n```hemlock\nfile.seek(position: i32): i32\n```\n\n**パラメータ：**\n- `position` - ファイル先頭からのバイトオフセット\n\n**戻り値：** 新しいファイル位置（i32）\n\n**例：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// バイト100にジャンプ\nf.seek(100);\n\n// その位置から読み取り\nlet chunk = f.read(50);\n\n// 先頭にリセット\nf.seek(0);\n\n// 先頭から読み取り\nlet all = f.read();\n\nf.close();\n```\n\n**動作：**\n- ファイル位置を絶対オフセットに設定\n- 新しい位置を返す\n- EOF以降へのシークは許可される（書き込み時にファイルにホールを作成）\n\n---\n\n#### tell\n\n現在のファイル位置を取得します。\n\n**シグネチャ：**\n```hemlock\nfile.tell(): i32\n```\n\n**戻り値：** ファイル先頭からの現在のバイトオフセット（i32）\n\n**例：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nprint(f.tell());        // 0（先頭）\n\nf.read(100);\nprint(f.tell());        // 100（読み取り後）\n\nf.seek(50);\nprint(f.tell());        // 50（シーク後）\n\nf.close();\n```\n\n---\n\n### クローズ\n\n#### close\n\nファイルをクローズします（冪等）。\n\n**シグネチャ：**\n```hemlock\nfile.close(): null\n```\n\n**戻り値：** `null`\n\n**例：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\n// 複数回呼び出しても安全\nf.close();  // エラーなし\nf.close();  // エラーなし\n```\n\n**動作：**\n- ファイルハンドルをクローズ\n- 保留中の書き込みをフラッシュ\n- 冪等（複数回呼び出しても安全）\n- `.closed`プロパティを`true`に設定\n\n**重要：** ファイルディスクリプタのリークを避けるため、完了したら常にファイルをクローズしてください。\n\n---\n\n## ファイルプロパティ\n\n### .path\n\nファイルパスを取得します。\n\n**型：** `string`\n\n**アクセス：** 読み取り専用\n\n**例：**\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);          // \"/path/to/file.txt\"\nf.close();\n```\n\n---\n\n### .mode\n\nオープンモードを取得します。\n\n**型：** `string`\n\n**アクセス：** 読み取り専用\n\n**例：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);          // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);         // \"w\"\nf2.close();\n```\n\n---\n\n### .closed\n\nファイルがクローズされているかチェックします。\n\n**型：** `bool`\n\n**アクセス：** 読み取り専用\n\n**例：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);        // false\n\nf.close();\nprint(f.closed);        // true\n```\n\n---\n\n## エラーハンドリング\n\nすべてのファイル操作にはコンテキスト付きの適切なエラーメッセージが含まれます：\n\n### ファイルが見つからない\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Error: Failed to open 'missing.txt': No such file or directory\n```\n\n### クローズされたファイルからの読み取り\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Error: Cannot read from closed file 'data.txt'\n```\n\n### 読み取り専用ファイルへの書き込み\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Error: Cannot write to file 'readonly.txt' opened in read-only mode\n```\n\n### try/catchの使用\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    print(content);\n} catch (e) {\n    print(\"File error:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## リソース管理パターン\n\n### 基本パターン\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### エラーハンドリング付き\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // エラー時も常にクローズ\n}\n```\n\n### 安全なパターン\n\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    // ... コンテンツを処理 ...\n} catch (e) {\n    print(\"Error:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## 使用例\n\n### ファイル全体を読み取る\n\n```hemlock\nfn read_file(filename: string): string {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content;\n}\n\nlet text = read_file(\"data.txt\");\nprint(text);\n```\n\n### テキストファイルを書き込む\n\n```hemlock\nfn write_file(filename: string, content: string) {\n    let f = open(filename, \"w\");\n    f.write(content);\n    f.close();\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\\n\");\n```\n\n### ファイルに追加する\n\n```hemlock\nfn append_file(filename: string, line: string) {\n    let f = open(filename, \"a\");\n    f.write(line + \"\\n\");\n    f.close();\n}\n\nappend_file(\"log.txt\", \"Log entry 1\");\nappend_file(\"log.txt\", \"Log entry 2\");\n```\n\n### バイナリファイルを読み取る\n\n```hemlock\nfn read_binary(filename: string, size: i32): buffer {\n    let f = open(filename, \"r\");\n    let data = f.read_bytes(size);\n    f.close();\n    return data;\n}\n\nlet binary = read_binary(\"data.bin\", 256);\nprint(\"Read\", binary.length, \"bytes\");\n```\n\n### バイナリファイルを書き込む\n\n```hemlock\nfn write_binary(filename: string, data: buffer) {\n    let f = open(filename, \"w\");\n    f.write_bytes(data);\n    f.close();\n}\n\nlet buf = buffer(10);\nbuf[0] = 65;\nwrite_binary(\"output.bin\", buf);\n```\n\n### ファイルを行ごとに読み取る\n\n```hemlock\nfn read_lines(filename: string): array {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content.split(\"\\n\");\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line\", i, \":\", lines[i]);\n    i = i + 1;\n}\n```\n\n### ファイルをコピーする\n\n```hemlock\nfn copy_file(src: string, dest: string) {\n    let f_in = open(src, \"r\");\n    let f_out = open(dest, \"w\");\n\n    let content = f_in.read();\n    f_out.write(content);\n\n    f_in.close();\n    f_out.close();\n}\n\ncopy_file(\"input.txt\", \"output.txt\");\n```\n\n### ファイルをチャンクで読み取る\n\n```hemlock\nfn process_chunks(filename: string) {\n    let f = open(filename, \"r\");\n\n    while (true) {\n        let chunk = f.read(1024);  // 一度に1KBを読み取り\n        if (chunk.length == 0) {\n            break;  // EOF\n        }\n\n        // チャンクを処理\n        print(\"Processing\", chunk.length, \"bytes\");\n    }\n\n    f.close();\n}\n\nprocess_chunks(\"large_file.txt\");\n```\n\n---\n\n## 完全なメソッド要約\n\n| メソッド | シグネチャ | 戻り値 | 説明 |\n|---------------|--------------------------|-----------|------------------------------|\n| `read`        | `(size?: i32)`           | `string`  | テキストを読み取り |\n| `read_bytes`  | `(size: i32)`            | `buffer`  | バイナリデータを読み取り |\n| `write`       | `(data: string)`         | `i32`     | テキストを書き込み |\n| `write_bytes` | `(data: buffer)`         | `i32`     | バイナリデータを書き込み |\n| `seek`        | `(position: i32)`        | `i32`     | ファイル位置を設定 |\n| `tell`        | `()`                     | `i32`     | ファイル位置を取得 |\n| `close`       | `()`                     | `null`    | ファイルをクローズ（冪等） |\n\n---\n\n## 完全なプロパティ要約\n\n| プロパティ | 型 | アクセス | 説明 |\n|-----------|----------|------------|--------------------------|\n| `.path`   | `string` | 読み取り専用 | ファイルパス |\n| `.mode`   | `string` | 読み取り専用 | オープンモード |\n| `.closed` | `bool`   | 読み取り専用 | ファイルがクローズされているか |\n\n---\n\n## 旧APIからの移行\n\n**旧API（削除済み）：**\n- `read_file(path)` - `open(path, \"r\").read()`を使用\n- `write_file(path, data)` - `open(path, \"w\").write(data)`を使用\n- `append_file(path, data)` - `open(path, \"a\").write(data)`を使用\n- `file_exists(path)` - 代替なし\n\n**移行例：**\n```hemlock\n// 旧（v0.0）\nlet content = read_file(\"data.txt\");\nwrite_file(\"output.txt\", content);\n\n// 新（v0.1）\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nf2.write(content);\nf2.close();\n```\n\n---\n\n## 関連項目\n\n- [組み込み関数](#reference-builtins) - `open()`関数\n- [メモリAPI](#reference-memory-api) - バッファ型\n- [文字列API](#reference-string-api) - テキスト処理用の文字列メソッド\n"}, "APIリファレンス -> メモリAPI": {"id": "reference-memory-api", "content": "# メモリAPIリファレンス\n\nHemlockのメモリ管理関数とポインタ型の完全なリファレンスです。\n\n---\n\n## 概要\n\nHemlockは明示的な割り当てと解放による**手動メモリ管理**を提供します。メモリは2つのポインタ型で管理されます：生ポインタ（`ptr`）と安全なバッファ（`buffer`）。\n\n**主な原則：**\n- 明示的な割り当てと解放\n- ガベージコレクションなし\n- ユーザーが`free()`を呼び出す責任がある\n- スコープ/再代入の安全性のための内部参照カウント（下記参照）\n\n### 内部参照カウント\n\nランタイムはスコープを通じてオブジェクトのライフタイムを管理するために、内部的に参照カウントを使用します。ほとんどのローカル変数では、クリーンアップは自動的です。\n\n**自動（`free()`不要）：**\n- 参照カウント型（buffer、array、object、string）のローカル変数はスコープ終了時に解放される\n- 変数が再代入されると古い値が解放される\n- コンテナが解放されるとコンテナ要素が解放される\n\n**手動`free()`が必要：**\n- `alloc()`からの生ポインタ - 常に\n- スコープ終了前の早期クリーンアップ\n- 長寿命/グローバルデータ\n\n詳細は[メモリ管理ガイド](../language-guide/memory.md#内部参照カウント)を参照してください。\n\n---\n\n## ポインタ型\n\n### ptr（生ポインタ）\n\n**型：** `ptr`\n\n**説明：** 境界チェックや追跡なしの生メモリアドレス。\n\n**サイズ：** 8バイト\n\n**使用ケース：**\n- 低レベルメモリ操作\n- FFI（外部関数インターフェース）\n- 最大パフォーマンス（オーバーヘッドなし）\n\n**安全性：** 安全でない - 境界チェックなし、ユーザーがライフタイムを追跡する必要がある\n\n**例：**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n---\n\n### buffer（安全なバッファ）\n\n**型：** `buffer`\n\n**説明：** 境界チェック付きの安全なポインタラッパー。\n\n**構造：** ポインタ + 長さ + 容量 + 参照カウント\n\n**プロパティ：**\n- `.length` - バッファサイズ（i32）\n- `.capacity` - 割り当て容量（i32）\n\n**使用ケース：**\n- ほとんどのメモリ割り当て\n- 安全性が重要な場合\n- 動的配列\n\n**安全性：** インデックスアクセス時に境界チェック\n\n**参照カウント：** バッファは内部的に参照カウントされます。スコープ終了時または変数再代入時に自動的に解放されます。早期クリーンアップや長寿命データには`free()`を使用してください。\n\n**例：**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // 境界チェックあり\nprint(b.length);        // 64\nfree(b);\n```\n\n---\n\n## メモリ割り当て関数\n\n### alloc\n\n生メモリを割り当てます。\n\n**シグネチャ：**\n```hemlock\nalloc(size: i32): ptr\n```\n\n**パラメータ：**\n- `size` - 割り当てるバイト数\n\n**戻り値：** 割り当てられたメモリへのポインタ（`ptr`）\n\n**例：**\n```hemlock\nlet p = alloc(1024);        // 1KBを割り当て\nmemset(p, 0, 1024);         // ゼロで初期化\nfree(p);                    // 終了時に解放\n\n// 構造体用に割り当て\nlet struct_size = 16;\nlet p2 = alloc(struct_size);\n```\n\n**動作：**\n- 初期化されていないメモリを返す\n- メモリは手動で解放する必要がある\n- 割り当て失敗時は`null`を返す（呼び出し側でチェックが必要）\n\n**関連項目：** より安全な代替として`buffer()`\n\n---\n\n### buffer\n\n境界チェック付きの安全なバッファを割り当てます。\n\n**シグネチャ：**\n```hemlock\nbuffer(size: i32): buffer\n```\n\n**パラメータ：**\n- `size` - バイト単位のバッファサイズ\n\n**戻り値：** バッファオブジェクト\n\n**例：**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\nprint(buf.capacity);        // 256\n\n// 境界チェック付きアクセス\nbuf[0] = 65;                // 'A'\nbuf[255] = 90;              // 'Z'\n// buf[256] = 0;            // エラー：範囲外\n\nfree(buf);\n```\n\n**プロパティ：**\n- `.length` - 現在のサイズ（i32）\n- `.capacity` - 割り当て容量（i32）\n\n**動作：**\n- メモリをゼロで初期化\n- インデックスアクセス時に境界チェックを提供\n- 割り当て失敗時は`null`を返す（呼び出し側でチェックが必要）\n- 手動で解放する必要がある\n\n---\n\n### free\n\n割り当てられたメモリを解放します。\n\n**シグネチャ：**\n```hemlock\nfree(ptr: ptr | buffer): null\n```\n\n**パラメータ：**\n- `ptr` - 解放するポインタまたはバッファ\n\n**戻り値：** `null`\n\n**例：**\n```hemlock\n// 生ポインタを解放\nlet p = alloc(1024);\nfree(p);\n\n// バッファを解放\nlet buf = buffer(256);\nfree(buf);\n```\n\n**動作：**\n- `alloc()`または`buffer()`で割り当てられたメモリを解放\n- 二重解放はクラッシュを引き起こす（ユーザーの責任で回避）\n- 無効なポインタの解放は未定義動作\n\n**重要：** 割り当てたら、解放する。自動クリーンアップなし。\n\n---\n\n### realloc\n\n割り当てられたメモリのサイズを変更します。\n\n**シグネチャ：**\n```hemlock\nrealloc(ptr: ptr, new_size: i32): ptr\n```\n\n**パラメータ：**\n- `ptr` - サイズ変更するポインタ\n- `new_size` - バイト単位の新しいサイズ\n\n**戻り値：** サイズ変更されたメモリへのポインタ（アドレスが異なる場合がある）\n\n**例：**\n```hemlock\nlet p = alloc(100);\n// ... メモリを使用 ...\n\n// より多くの領域が必要\np = realloc(p, 200);        // 200バイトになった\n// ... 拡張されたメモリを使用 ...\n\nfree(p);\n```\n\n**動作：**\n- メモリを新しい場所に移動する場合がある\n- 既存データを保持（古い/新しいサイズの最小まで）\n- 成功したreallocの後は古いポインタは無効（返されたポインタを使用）\n- new_sizeが小さい場合、データは切り詰められる\n- 割り当て失敗時は`null`を返す（元のポインタは有効なまま）\n\n**重要：** 常に`null`をチェックし、結果でポインタ変数を更新してください。\n\n---\n\n## メモリ操作\n\n### memset\n\nメモリをバイト値で埋めます。\n\n**シグネチャ：**\n```hemlock\nmemset(ptr: ptr, byte: i32, size: i32): null\n```\n\n**パラメータ：**\n- `ptr` - メモリへのポインタ\n- `byte` - 埋めるバイト値（0-255）\n- `size` - 埋めるバイト数\n\n**戻り値：** `null`\n\n**例：**\n```hemlock\nlet p = alloc(100);\n\n// メモリをゼロクリア\nmemset(p, 0, 100);\n\n// 特定の値で埋める\nmemset(p, 0xFF, 100);\n\n// バッファを初期化\nlet buf = alloc(256);\nmemset(buf, 65, 256);       // 'A'で埋める\n\nfree(p);\nfree(buf);\n```\n\n**動作：**\n- 範囲内の各バイトにバイト値を書き込む\n- バイト値は8ビット（0-255）に切り詰められる\n- 境界チェックなし（安全でない）\n\n---\n\n### memcpy\n\nソースからデスティネーションにメモリをコピーします。\n\n**シグネチャ：**\n```hemlock\nmemcpy(dest: ptr, src: ptr, size: i32): null\n```\n\n**パラメータ：**\n- `dest` - デスティネーションポインタ\n- `src` - ソースポインタ\n- `size` - コピーするバイト数\n\n**戻り値：** `null`\n\n**例：**\n```hemlock\nlet src = alloc(100);\nlet dest = alloc(100);\n\n// ソースを初期化\nmemset(src, 65, 100);\n\n// デスティネーションにコピー\nmemcpy(dest, src, 100);\n\n// destはsrcと同じデータを含む\n\nfree(src);\nfree(dest);\n```\n\n**動作：**\n- srcからdestへバイト単位でコピー\n- 境界チェックなし（安全でない）\n- オーバーラップする領域は未定義動作（慎重に使用）\n\n---\n\n## 型付きメモリ操作\n\n### sizeof\n\n型のバイト数を取得します。\n\n**シグネチャ：**\n```hemlock\nsizeof(type): i32\n```\n\n**パラメータ：**\n- `type` - 型識別子（例：`i32`、`f64`、`ptr`）\n\n**戻り値：** バイト数（i32）\n\n**型サイズ：**\n\n| 型 | サイズ（バイト） |\n|------|--------------|\n| `i8` | 1 |\n| `i16` | 2 |\n| `i32`, `integer` | 4 |\n| `i64` | 8 |\n| `u8`, `byte` | 1 |\n| `u16` | 2 |\n| `u32` | 4 |\n| `u64` | 8 |\n| `f32` | 4 |\n| `f64`, `number` | 8 |\n| `bool` | 1 |\n| `ptr` | 8 |\n| `rune` | 4 |\n\n**例：**\n```hemlock\nlet int_size = sizeof(i32);      // 4\nlet ptr_size = sizeof(ptr);      // 8\nlet float_size = sizeof(f64);    // 8\nlet byte_size = sizeof(u8);      // 1\nlet rune_size = sizeof(rune);    // 4\n\n// 配列割り当てサイズを計算\nlet count = 100;\nlet total = sizeof(i32) * count; // 400バイト\n```\n\n**動作：**\n- 不明な型には0を返す\n- 型識別子と型文字列の両方を受け付ける\n\n---\n\n### talloc\n\n型付き値の配列を割り当てます。\n\n**シグネチャ：**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**パラメータ：**\n- `type` - 割り当てる型（例：`i32`、`f64`、`ptr`）\n- `count` - 要素数（正の数である必要がある）\n\n**戻り値：** 割り当てられた配列へのポインタ、割り当て失敗時は`null`\n\n**例：**\n```hemlock\nlet arr = talloc(i32, 100);      // 100個のi32の配列（400バイト）\nlet floats = talloc(f64, 50);    // 50個のf64の配列（400バイト）\nlet bytes = talloc(u8, 1024);    // 1024バイトの配列\n\n// 常に割り当て失敗をチェック\nif (arr == null) {\n    panic(\"allocation failed\");\n}\n\n// 割り当てられたメモリを使用\n// ...\n\nfree(arr);\nfree(floats);\nfree(bytes);\n```\n\n**動作：**\n- `sizeof(type) * count`バイトを割り当て\n- 初期化されていないメモリを返す\n- `free()`で手動解放が必要\n- 割り当て失敗時は`null`を返す（呼び出し側でチェックが必要）\n- countが正でない場合はパニック\n\n---\n\n## バッファプロパティ\n\n### .length\n\nバッファサイズを取得します。\n\n**型：** `i32`\n\n**アクセス：** 読み取り専用\n\n**例：**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\n\nlet buf2 = buffer(1024);\nprint(buf2.length);         // 1024\n```\n\n---\n\n### .capacity\n\nバッファ容量を取得します。\n\n**型：** `i32`\n\n**アクセス：** 読み取り専用\n\n**例：**\n```hemlock\nlet buf = buffer(256);\nprint(buf.capacity);        // 256\n```\n\n**注意：** 現在、`buffer()`で作成されたバッファでは`.length`と`.capacity`は同じです。\n\n---\n\n## 使用パターン\n\n### 基本的な割り当てパターン\n\n```hemlock\n// 割り当て\nlet p = alloc(1024);\nif (p == null) {\n    panic(\"allocation failed\");\n}\n\n// 使用\nmemset(p, 0, 1024);\n\n// 解放\nfree(p);\n```\n\n### 安全なバッファパターン\n\n```hemlock\n// バッファを割り当て\nlet buf = buffer(256);\nif (buf == null) {\n    panic(\"buffer allocation failed\");\n}\n\n// 境界チェック付きで使用\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\n// 解放\nfree(buf);\n```\n\n### 動的拡張パターン\n\n```hemlock\nlet size = 100;\nlet p = alloc(size);\nif (p == null) {\n    panic(\"allocation failed\");\n}\n\n// ... メモリを使用 ...\n\n// より多くの領域が必要 - 失敗をチェック\nlet new_p = realloc(p, 200);\nif (new_p == null) {\n    // 元のポインタはまだ有効、クリーンアップ\n    free(p);\n    panic(\"realloc failed\");\n}\np = new_p;\nsize = 200;\n\n// ... 拡張されたメモリを使用 ...\n\nfree(p);\n```\n\n### メモリコピーパターン\n\n```hemlock\nlet original = alloc(100);\nmemset(original, 65, 100);\n\n// コピーを作成\nlet copy = alloc(100);\nmemcpy(copy, original, 100);\n\nfree(original);\nfree(copy);\n```\n\n---\n\n## 安全性に関する考慮事項\n\n**Hemlockのメモリ管理は設計上安全ではありません：**\n\n### よくある落とし穴\n\n**1. メモリリーク**\n```hemlock\n// 悪い例：メモリリーク\nfn create_buffer() {\n    let p = alloc(1024);\n    return null;  // メモリがリーク！\n}\n\n// 良い例：適切なクリーンアップ\nfn create_buffer() {\n    let p = alloc(1024);\n    // ... メモリを使用 ...\n    free(p);\n    return null;\n}\n```\n\n**2. 解放後使用**\n```hemlock\n// 悪い例：解放後使用\nlet p = alloc(100);\nfree(p);\nmemset(p, 0, 100);  // クラッシュ：解放済みメモリを使用\n\n// 良い例：解放後は使用しない\nlet p2 = alloc(100);\nmemset(p2, 0, 100);\nfree(p2);\n// この後p2に触れない\n```\n\n**3. 二重解放**\n```hemlock\n// 悪い例：二重解放\nlet p = alloc(100);\nfree(p);\nfree(p);  // クラッシュ：二重解放\n\n// 良い例：一度だけ解放\nlet p2 = alloc(100);\nfree(p2);\n```\n\n**4. バッファオーバーフロー（ptr）**\n```hemlock\n// 悪い例：ptrでのバッファオーバーフロー\nlet p = alloc(10);\nmemset(p, 65, 100);  // クラッシュ：割り当てを超えて書き込み\n\n// 良い例：境界チェックにはbufferを使用\nlet buf = buffer(10);\n// buf[100] = 65;  // エラー：境界チェックが失敗\n```\n\n**5. ダングリングポインタ**\n```hemlock\n// 悪い例：ダングリングポインタ\nlet p1 = alloc(100);\nlet p2 = p1;\nfree(p1);\nmemset(p2, 0, 100);  // クラッシュ：p2はダングリング\n\n// 良い例：所有権を慎重に追跡\nlet p = alloc(100);\n// ... pを使用 ...\nfree(p);\n// pへの他の参照を保持しない\n```\n\n**6. 割り当て失敗のチェック漏れ**\n```hemlock\n// 悪い例：nullをチェックしない\nlet p = alloc(1000000000);  // メモリ不足で失敗する可能性\nmemset(p, 0, 1000000000);   // クラッシュ：pがnull\n\n// 良い例：常に割り当て結果をチェック\nlet p2 = alloc(1000000000);\nif (p2 == null) {\n    panic(\"out of memory\");\n}\nmemset(p2, 0, 1000000000);\nfree(p2);\n```\n\n---\n\n## 何をいつ使うか\n\n### `buffer()`を使用する場合：\n- 境界チェックが必要な場合\n- 動的データを扱う場合\n- 安全性が重要な場合\n- Hemlockを学習中の場合\n\n### `alloc()`を使用する場合：\n- 最大パフォーマンスが必要な場合\n- FFI/Cとのインターフェース\n- 正確なメモリレイアウトを知っている場合\n- エキスパートの場合\n\n### `realloc()`を使用する場合：\n- 割り当てを拡大/縮小する場合\n- 動的配列\n- データを保持する必要がある場合\n\n---\n\n## 完全な関数要約\n\n| 関数 | シグネチャ | 戻り値 | 説明 |\n|-----------|----------------------------------------|----------|----------------------------|\n| `alloc`   | `(size: i32)`                          | `ptr`    | 生メモリを割り当て |\n| `buffer`  | `(size: i32)`                          | `buffer` | 安全なバッファを割り当て |\n| `free`    | `(ptr: ptr \\| buffer)`                 | `null`   | メモリを解放 |\n| `realloc` | `(ptr: ptr, new_size: i32)`            | `ptr`    | 割り当てサイズを変更 |\n| `memset`  | `(ptr: ptr, byte: i32, size: i32)`     | `null`   | メモリを埋める |\n| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`     | `null`   | メモリをコピー |\n| `sizeof`  | `(type)`                               | `i32`    | 型のバイトサイズを取得 |\n| `talloc`  | `(type, count: i32)`                   | `ptr`    | 型付き配列を割り当て |\n\n---\n\n## 関連項目\n\n- [型システム](#reference-type-system) - ポインタとバッファ型\n- [組み込み関数](#reference-builtins) - すべての組み込み関数\n- [文字列API](#reference-string-api) - 文字列の`.to_bytes()`メソッド\n"}, "APIリファレンス -> 並行処理API": {"id": "reference-concurrency-api", "content": "# 並行性APIリファレンス\n\nHemlockの非同期/並行性システムの完全なリファレンスです。\n\n---\n\n## 概要\n\nHemlockは、POSIXスレッド（pthreads）を使用した真のマルチスレッド並列処理を備えた**構造化された並行性**を提供します。各スポーンされたタスクは別のOSスレッドで実行され、複数のCPUコアにわたる実際の並列実行を可能にします。\n\n**主な機能：**\n- 真のマルチスレッド並列処理（グリーンスレッドではない）\n- 非同期関数構文\n- タスクのスポーンと結合\n- スレッドセーフなチャネル\n- 例外の伝播\n\n**スレッディングモデル：**\n- 実際のOSスレッド（POSIX pthreads）\n- 真の並列処理（複数のCPUコア）\n- カーネルスケジュール（プリエンプティブマルチタスキング）\n- スレッドセーフな同期（ミューテックス、条件変数）\n\n---\n\n## 非同期関数\n\n### 非同期関数の宣言\n\n関数を`async`として宣言して、並行実行用に設計されていることを示すことができます。\n\n**構文：**\n```hemlock\nasync fn function_name(params): return_type {\n    // 関数本体\n}\n```\n\n**例：**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nasync fn process_data(data: string) {\n    print(\"Processing:\", data);\n    return null;\n}\n```\n\n**動作：**\n- `async fn`は非同期関数を宣言\n- 同期的に呼び出し可能（現在のスレッドで実行）\n- 並行タスクとしてスポーン可能（新しいスレッドで実行）\n- スポーン時は独自のOSスレッドで実行\n\n**注意：** `await`キーワードは将来の使用のために予約されていますが、現在は実装されていません。\n\n---\n\n## タスク管理\n\n### spawn\n\n新しい並行タスクを作成して開始します。\n\n**シグネチャ：**\n```hemlock\nspawn(async_fn: function, ...args): task\n```\n\n**パラメータ：**\n- `async_fn` - 実行する非同期関数\n- `...args` - 関数に渡す引数\n\n**戻り値：** タスクハンドル\n\n**例：**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// 単一タスクをスポーン\nlet t = spawn(compute, 1000);\nlet result = join(t);\nprint(result);\n\n// 複数タスクをスポーン（並列実行！）\nlet t1 = spawn(compute, 100);\nlet t2 = spawn(compute, 200);\nlet t3 = spawn(compute, 300);\n\n// 3つすべてが同時に実行中\nlet r1 = join(t1);\nlet r2 = join(t2);\nlet r3 = join(t3);\n```\n\n**動作：**\n- `pthread_create()`経由で新しいOSスレッドを作成\n- すぐに関数の実行を開始\n- 後で結合するためのタスクハンドルを返す\n- タスクは別のCPUコアで並列実行\n\n---\n\n### join\n\nタスクの完了を待ち、結果を取得します。\n\n**シグネチャ：**\n```hemlock\njoin(task: task): any\n```\n\n**パラメータ：**\n- `task` - `spawn()`からのタスクハンドル\n\n**戻り値：** タスクの戻り値\n\n**例：**\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nlet t = spawn(factorial, 10);\nlet result = join(t);  // タスク完了までブロック\nprint(result);         // 3628800\n```\n\n**動作：**\n- タスク完了まで現在のスレッドをブロック\n- タスクの戻り値を返す\n- タスクが投げた例外を伝播\n- 戻り後にタスクリソースをクリーンアップ\n\n**エラーハンドリング：**\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Caught:\", e);  // \"Caught: Task failed!\"\n}\n```\n\n---\n\n### detach\n\nタスクをデタッチします（ファイア・アンド・フォーゲット実行）。\n\n**シグネチャ：**\n```hemlock\ndetach(task: task): null\n```\n\n**パラメータ：**\n- `task` - `spawn()`からのタスクハンドル\n\n**戻り値：** `null`\n\n**例：**\n```hemlock\nasync fn background_work() {\n    print(\"Working in background...\");\n    return null;\n}\n\nlet t = spawn(background_work);\ndetach(t);  // タスクは独立して実行を継続\n\n// デタッチされたタスクは結合できない\n// join(t);  // エラー\n```\n\n**動作：**\n- タスクは独立して実行を継続\n- デタッチされたタスクは`join()`できない\n- タスク完了時にタスクとスレッドは自動的にクリーンアップ\n\n**使用ケース：**\n- ファイア・アンド・フォーゲットのバックグラウンドタスク\n- ロギング/モニタリングタスク\n- 値を返す必要がないタスク\n\n---\n\n## チャネル\n\nチャネルはタスク間のスレッドセーフな通信を提供します。\n\n### channel\n\nバッファ付きチャネルを作成します。\n\n**シグネチャ：**\n```hemlock\nchannel(capacity: i32): channel\n```\n\n**パラメータ：**\n- `capacity` - バッファサイズ（値の数）\n\n**戻り値：** チャネルオブジェクト\n\n**例：**\n```hemlock\nlet ch = channel(10);  // 容量10のバッファ付きチャネル\nlet ch2 = channel(1);  // 最小バッファ（同期的）\nlet ch3 = channel(100); // 大きなバッファ\n```\n\n**動作：**\n- スレッドセーフなチャネルを作成\n- 同期にpthreadミューテックスを使用\n- 容量は作成時に固定\n\n---\n\n### チャネルメソッド\n\n#### send\n\nチャネルに値を送信します（満杯の場合ブロック）。\n\n**シグネチャ：**\n```hemlock\nchannel.send(value: any): null\n```\n\n**パラメータ：**\n- `value` - 送信する値（任意の型）\n\n**戻り値：** `null`\n\n**例：**\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet t = spawn(producer, ch, 5);\n```\n\n**動作：**\n- チャネルに値を送信\n- チャネルが満杯の場合ブロック\n- スレッドセーフ（ミューテックス使用）\n- 値が送信されると戻る\n\n---\n\n#### recv\n\nチャネルから値を受信します（空の場合ブロック）。\n\n**シグネチャ：**\n```hemlock\nchannel.recv(): any\n```\n\n**戻り値：** チャネルからの値、またはチャネルがクローズされ空の場合`null`\n\n**例：**\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet t = spawn(consumer, ch, 5);\n```\n\n**動作：**\n- チャネルから値を受信\n- チャネルが空の場合ブロック\n- チャネルがクローズされ空の場合`null`を返す\n- スレッドセーフ（ミューテックス使用）\n\n---\n\n#### close\n\nチャネルをクローズします（これ以上の送信は不可）。\n\n**シグネチャ：**\n```hemlock\nchannel.close(): null\n```\n\n**戻り値：** `null`\n\n**例：**\n```hemlock\nasync fn producer(ch) {\n    ch.send(1);\n    ch.send(2);\n    ch.send(3);\n    ch.close();  // これ以上値がないことを通知\n    return null;\n}\n\nasync fn consumer(ch) {\n    while (true) {\n        let val = ch.recv();\n        if (val == null) {\n            break;  // チャネルがクローズ\n        }\n        print(val);\n    }\n    return null;\n}\n```\n\n**動作：**\n- チャネルをクローズ\n- これ以上の送信は不可\n- チャネルが空の場合`recv()`は`null`を返す\n- スレッドセーフ\n\n---\n\n## 完全な並行性の例\n\n### プロデューサー・コンシューマーパターン\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        print(\"Producing:\", i);\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        print(\"Consuming:\", val);\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// チャネルを作成\nlet ch = channel(10);\n\n// プロデューサーとコンシューマーをスポーン\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// 完了を待機\njoin(p);\nlet total = join(c);\nprint(\"Total:\", total);  // 0+10+20+30+40 = 100\n```\n\n---\n\n## 並列計算\n\n### 複数タスクの例\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// 複数タスクをスポーン（並列実行！）\nlet t1 = spawn(factorial, 5);   // スレッド1\nlet t2 = spawn(factorial, 6);   // スレッド2\nlet t3 = spawn(factorial, 7);   // スレッド3\nlet t4 = spawn(factorial, 8);   // スレッド4\n\n// 4つすべてが同時に計算中！\n\n// 結果を待機\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\nlet f8 = join(t4);  // 40320\n\nprint(f5, f6, f7, f8);\n```\n\n---\n\n## タスクライフサイクル\n\n### 状態遷移\n\n1. **作成済み** - タスクがスポーンされたがまだ実行されていない\n2. **実行中** - タスクがOSスレッドで実行中\n3. **完了** - タスクが終了（結果が利用可能）\n4. **結合済み** - 結果が取得され、リソースがクリーンアップ\n5. **デタッチ済み** - タスクは独立して継続\n\n### ライフサイクルの例\n\n```hemlock\nasync fn work(n: i32): i32 {\n    return n * 2;\n}\n\n// 1. タスクを作成\nlet t = spawn(work, 21);  // 状態：実行中\n\n// タスクは別スレッドで実行...\n\n// 2. タスクを結合\nlet result = join(t);     // 状態：完了 → 結合済み\nprint(result);            // 42\n\n// 結合後にタスクリソースがクリーンアップ\n```\n\n### デタッチのライフサイクル\n\n```hemlock\nasync fn background() {\n    print(\"Background task running\");\n    return null;\n}\n\n// 1. タスクを作成\nlet t = spawn(background);  // 状態：実行中\n\n// 2. タスクをデタッチ\ndetach(t);                  // 状態：デタッチ済み\n\n// タスクは独立して実行を継続\n// 完了時にOSがリソースをクリーンアップ\n```\n\n---\n\n## エラーハンドリング\n\n### 例外の伝播\n\nタスクで投げられた例外は結合時に伝播されます：\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\n// 成功するタスク\nlet t1 = spawn(risky_operation, 0);\nlet result1 = join(t1);  // 42\n\n// 失敗するタスク\nlet t2 = spawn(risky_operation, 1);\ntry {\n    let result2 = join(t2);\n} catch (e) {\n    print(\"Caught:\", e);  // \"Caught: Task failed!\"\n}\n```\n\n### 複数タスクのハンドリング\n\n```hemlock\nasync fn work(id: i32, should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task \" + typeof(id) + \" failed\";\n    }\n    return id * 10;\n}\n\nlet t1 = spawn(work, 1, 0);\nlet t2 = spawn(work, 2, 1);  // 失敗する\nlet t3 = spawn(work, 3, 0);\n\n// エラーハンドリング付きで結合\ntry {\n    let r1 = join(t1);  // OK\n    print(\"Task 1:\", r1);\n\n    let r2 = join(t2);  // 投げる\n    print(\"Task 2:\", r2);  // 到達しない\n} catch (e) {\n    print(\"Error:\", e);  // \"Error: Task 2 failed\"\n}\n\n// 残りのタスクはまだ結合可能\nlet r3 = join(t3);\nprint(\"Task 3:\", r3);\n```\n\n---\n\n## パフォーマンス特性\n\n### 真の並列処理\n\n```hemlock\nasync fn cpu_intensive(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// 順次実行\nlet start = get_time();\nlet r1 = cpu_intensive(10000000);\nlet r2 = cpu_intensive(10000000);\nlet sequential_time = get_time() - start;\n\n// 並列実行\nlet start2 = get_time();\nlet t1 = spawn(cpu_intensive, 10000000);\nlet t2 = spawn(cpu_intensive, 10000000);\njoin(t1);\njoin(t2);\nlet parallel_time = get_time() - start2;\n\n// マルチコアシステムではparallel_timeはsequential_timeの約50%になるはず\n```\n\n**実証された特性：**\n- N個のタスクはN個のCPUコアを同時に使用可能\n- ストレステストではウォール時間に対して8-9倍のCPU時間を示す（並列処理の証明）\n- スレッドオーバーヘッド：タスクあたり約8KBスタック + pthreadオーバーヘッド\n- 1つのタスクのブロッキング操作は他に影響しない\n\n---\n\n## 実装の詳細\n\n### スレッディングモデル\n\n- **1:1スレッディング** - 各タスク = 1 OSスレッド（`pthread`）\n- **カーネルスケジュール** - OSカーネルがスレッドをコアに分散\n- **プリエンプティブマルチタスキング** - OSがスレッドを中断して切り替え可能\n- **GILなし** - グローバルインタプリタロックなし（Pythonとは異なる）\n\n### 同期\n\n- **ミューテックス** - チャネルは`pthread_mutex_t`を使用\n- **条件変数** - ブロッキングsend/recvは`pthread_cond_t`を使用\n- **ロックフリー操作** - タスク状態遷移はアトミック\n\n### メモリとクリーンアップ\n\n- **結合されたタスク** - `join()`後に自動クリーンアップ\n- **デタッチされたタスク** - タスク完了時に自動クリーンアップ\n- **チャネル** - 参照カウント、使用されなくなると解放\n\n---\n\n## 制限事項\n\n- 複数チャネルの多重化のための`select()`なし\n- ワークスティーリングスケジューラなし（タスクあたり1スレッド）\n- 非同期I/O統合なし（ファイル/ネットワーク操作はブロック）\n- チャネル容量は作成時に固定\n\n---\n\n## 完全なAPI要約\n\n### 関数\n\n| 関数 | シグネチャ | 戻り値 | 説明 |\n|-----------|-----------------------------------|-----------|--------------------------------|\n| `spawn`   | `(async_fn: function, ...args)`   | `task`    | 並行タスクを作成して開始 |\n| `join`    | `(task: task)`                    | `any`     | タスクを待ち、結果を取得 |\n| `detach`  | `(task: task)`                    | `null`    | タスクをデタッチ（ファイア・アンド・フォーゲット） |\n| `channel` | `(capacity: i32)`                 | `channel` | スレッドセーフなチャネルを作成 |\n\n### チャネルメソッド\n\n| メソッド | シグネチャ | 戻り値 | 説明 |\n|---------|-----------------|---------|----------------------------------|\n| `send`  | `(value: any)`  | `null`  | 値を送信（満杯ならブロック） |\n| `recv`  | `()`            | `any`   | 値を受信（空ならブロック） |\n| `close` | `()`            | `null`  | チャネルをクローズ |\n\n### 型\n\n| 型 | 説明 |\n|-----------|--------------------------------------|\n| `task`    | 並行タスクのハンドル |\n| `channel` | スレッドセーフな通信チャネル |\n\n---\n\n## ベストプラクティス\n\n### すべきこと\n\n- タスク間の通信にチャネルを使用\n- 結合されたタスクからの例外をハンドル\n- 送信完了時にチャネルをクローズ\n- 結果の取得とクリーンアップに`join()`を使用\n- 非同期関数のみをスポーン\n\n### すべきでないこと\n\n- 同期なしに可変状態を共有しない\n- 同じタスクを2回結合しない\n- クローズされたチャネルに送信しない\n- 非async関数をスポーンしない\n- タスクの結合を忘れない（デタッチしない限り）\n\n---\n\n## 関連項目\n\n- [組み込み関数](#reference-builtins) - `spawn()`、`join()`、`detach()`、`channel()`\n- [型システム](#reference-type-system) - タスクとチャネル型\n"}, "APIリファレンス -> 型システム": {"id": "reference-type-system", "content": "# 型システムリファレンス\n\nHemlockの型システムの完全なリファレンスです。すべてのプリミティブ型と複合型を含みます。\n\n---\n\n## 概要\n\nHemlockは実行時型タグとオプションの型注釈を持つ**動的型システム**を使用します。すべての値は実行時型を持ち、型変換は明示的な昇格規則に従います。\n\n**主な機能：**\n- 実行時型チェック（インタプリタ）\n- コンパイル時型チェック（hemlockc - デフォルトで有効）\n- オプションの型注釈\n- リテラルの自動型推論\n- 明示的な型昇格規則\n- 精度を失う暗黙的変換なし\n\n---\n\n## コンパイル時型チェック（hemlockc）\n\nHemlockコンパイラ（`hemlockc`）には、実行可能ファイル生成前にコードを検証するコンパイル時型チェッカーが含まれています。これにより、プログラムを実行せずに型エラーを早期に発見できます。\n\n### デフォルトの動作\n\n型チェックはhemloccで**デフォルトで有効**です：\n\n```bash\n# 型チェックは自動的に行われる\nhemlockc program.hml -o program\n\n# エラーはコンパイル前に報告される\nhemlockc bad_types.hml\n# 出力：1 type error found\n```\n\n### コンパイラフラグ\n\n| フラグ | 説明 |\n|------|-------------|\n| `--check` | 型チェックのみ、コンパイルしない（検証後に終了） |\n| `--no-type-check` | 型チェックを無効化（推奨されない） |\n| `--strict-types` | より厳格な型警告を有効化 |\n\n**例：**\n\n```bash\n# コンパイルせずに型のみ検証\nhemlockc --check program.hml\n# 出力：program.hml: no type errors\n\n# 型チェックを無効化（注意して使用）\nhemlockc --no-type-check dynamic_code.hml -o program\n\n# 暗黙のany型に対する厳格な警告を有効化\nhemlockc --strict-types program.hml -o program\n```\n\n### 型チェッカーが検証する内容\n\n1. **型注釈** - 代入された値が宣言された型と一致することを保証\n2. **関数呼び出し** - 引数の型がパラメータの型と一致することを検証\n3. **戻り値の型** - return文が宣言された戻り値の型と一致することをチェック\n4. **演算子の使用** - オペランドが互換性があることを検証\n5. **プロパティアクセス** - 型付きオブジェクトのオブジェクトフィールドの型を検証\n\n### 許容的な数値変換\n\n型チェッカーはコンパイル時に数値型の変換を許可し、範囲の検証は実行時に行われます：\n\n```hemlock\nlet x: i8 = 100;      // OK - 100はi8に収まる（実行時に検証）\nlet y: u8 = 255;      // OK - u8の範囲内\nlet z: f64 = 42;      // OK - i32からf64は安全\n```\n\n### 動的コードのサポート\n\n型注釈のないコードは動的（`any`型）として扱われ、常に型チェッカーを通過します：\n\n```hemlock\nlet x = get_value();  // 動的 - 注釈なし\nprocess(x);           // OK - 動的な値はどこでも受け入れられる\n```\n\n---\n\n## プリミティブ型\n\n### 数値型\n\n#### 符号付き整数\n\n| 型 | サイズ | 範囲 | エイリアス |\n|--------|---------|-------------------------------------------|-----------|\n| `i8`   | 1バイト | -128から127 | - |\n| `i16`  | 2バイト | -32,768から32,767 | - |\n| `i32`  | 4バイト | -2,147,483,648から2,147,483,647 | `integer` |\n| `i64`  | 8バイト | -9,223,372,036,854,775,808から9,223,372,036,854,775,807 | - |\n\n**例：**\n```hemlock\nlet a: i8 = 127;\nlet b: i16 = 32000;\nlet c: i32 = 1000000;\nlet d: i64 = 9223372036854775807;\n\n// 型エイリアス\nlet x: integer = 42;  // i32と同じ\n```\n\n#### 符号なし整数\n\n| 型 | サイズ | 範囲 | エイリアス |\n|--------|---------|---------------------------|--------|\n| `u8`   | 1バイト | 0から255 | `byte` |\n| `u16`  | 2バイト | 0から65,535 | - |\n| `u32`  | 4バイト | 0から4,294,967,295 | - |\n| `u64`  | 8バイト | 0から18,446,744,073,709,551,615 | - |\n\n**例：**\n```hemlock\nlet a: u8 = 255;\nlet b: u16 = 65535;\nlet c: u32 = 4294967295;\nlet d: u64 = 18446744073709551615;\n\n// 型エイリアス\nlet byte_val: byte = 65;  // u8と同じ\n```\n\n#### 浮動小数点\n\n| 型 | サイズ | 精度 | エイリアス |\n|--------|---------|----------------|----------|\n| `f32`  | 4バイト | 約7桁 | - |\n| `f64`  | 8バイト | 約15桁 | `number` |\n\n**例：**\n```hemlock\nlet pi: f32 = 3.14159;\nlet precise: f64 = 3.14159265359;\n\n// 型エイリアス\nlet x: number = 2.718;  // f64と同じ\n```\n\n---\n\n### 整数リテラルの推論\n\n整数リテラルはその値に基づいて自動的に型付けされます：\n\n**規則：**\n- i32範囲（-2,147,483,648から2,147,483,647）内の値：`i32`として推論\n- i32範囲外だがi64範囲内の値：`i64`として推論\n- 他の型（i8、i16、u8、u16、u32、u64）には明示的な型注釈を使用\n\n**例：**\n```hemlock\nlet small = 42;                    // i32（i32に収まる）\nlet large = 5000000000;            // i64（> i32最大値）\nlet max_i64 = 9223372036854775807; // i64（INT64_MAX）\nlet explicit: u32 = 100;           // u32（型注釈で上書き）\n```\n\n---\n\n### ブーリアン型\n\n**型：** `bool`\n\n**値：** `true`、`false`\n\n**サイズ：** 1バイト（内部的に）\n\n**例：**\n```hemlock\nlet is_active: bool = true;\nlet done = false;\n\nif (is_active && !done) {\n    print(\"working\");\n}\n```\n\n---\n\n### 文字型\n\n#### Rune\n\n**型：** `rune`\n\n**説明：** Unicodeコードポイント（U+0000からU+10FFFF）\n\n**サイズ：** 4バイト（32ビット値）\n\n**範囲：** 0から0x10FFFF（1,114,111）\n\n**リテラル構文：** シングルクォート `'x'`\n\n**例：**\n```hemlock\n// ASCII\nlet a = 'A';\nlet digit = '0';\n\n// マルチバイトUTF-8\nlet rocket = '🚀';      // U+1F680\nlet heart = '❤';        // U+2764\nlet chinese = '中';     // U+4E2D\n\n// エスケープシーケンス\nlet newline = '\\n';\nlet tab = '\\t';\nlet backslash = '\\\\';\nlet quote = '\\'';\nlet null = '\\0';\n\n// Unicodeエスケープ\nlet emoji = '\\u{1F680}';   // 最大6桁の16進数\nlet max = '\\u{10FFFF}';    // 最大コードポイント\n```\n\n**型変換：**\n```hemlock\n// 整数からrune\nlet code: rune = 65;        // 'A'\nlet r: rune = 128640;       // 🚀\n\n// runeから整数\nlet value: i32 = 'Z';       // 90\n\n// runeから文字列\nlet s: string = 'H';        // \"H\"\n\n// u8からrune\nlet byte: u8 = 65;\nlet rune_val: rune = byte;  // 'A'\n```\n\n**関連項目：** 文字列 + rune連結については[文字列API](#reference-string-api)\n\n---\n\n### 文字列型\n\n**型：** `string`\n\n**説明：** UTF-8エンコード、可変、ヒープ割り当てのテキスト\n\n**エンコーディング：** UTF-8（U+0000からU+10FFFF）\n\n**可変性：** 可変（ほとんどの言語と異なる）\n\n**プロパティ：**\n- `.length` - コードポイント数（文字数）\n- `.byte_length` - バイト数（UTF-8エンコーディングサイズ）\n\n**リテラル構文：** ダブルクォート `\"text\"`\n\n**例：**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // 変更（\"Hello\"になる）\nprint(s.length);        // 5（コードポイント数）\nprint(s.byte_length);   // 5（UTF-8バイト数）\n\nlet emoji = \"🚀\";\nprint(emoji.length);        // 1（1つのコードポイント）\nprint(emoji.byte_length);   // 4（4つのUTF-8バイト）\n```\n\n**インデックス：**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // rune 'h'を返す\ns[0] = 'H';             // runeで設定\n```\n\n**関連項目：** 完全なメソッドリファレンスは[文字列API](#reference-string-api)\n\n---\n\n### Null型\n\n**型：** `null`\n\n**説明：** null値（値の不在）\n\n**サイズ：** 8バイト（内部的に）\n\n**値：** `null`\n\n**例：**\n```hemlock\nlet x = null;\nlet y: i32 = null;  // エラー：型の不一致\n\nif (x == null) {\n    print(\"x is null\");\n}\n```\n\n---\n\n## 複合型\n\n### 配列型\n\n**型：** `array`\n\n**説明：** 動的、ヒープ割り当て、混合型の配列\n\n**プロパティ：**\n- `.length` - 要素数\n\n**ゼロインデックス：** はい\n\n**リテラル構文：** `[elem1, elem2, ...]`\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// 混合型\nlet mixed = [1, \"hello\", true, null];\n```\n\n**関連項目：** 完全なメソッドリファレンスは[配列API](#reference-array-api)\n\n---\n\n### オブジェクト型\n\n**型：** `object`\n\n**説明：** 動的フィールドを持つJavaScriptスタイルのオブジェクト\n\n**リテラル構文：** `{ field: value, ... }`\n\n**例：**\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);  // \"Alice\"\n\n// フィールドを動的に追加\nperson.email = \"alice@example.com\";\n```\n\n**型定義：**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: bool,  // オプションフィールド\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\nprint(typeof(p));  // \"Person\"\n```\n\n---\n\n### ポインタ型\n\n#### 生ポインタ（ptr）\n\n**型：** `ptr`\n\n**説明：** 生メモリアドレス（安全でない）\n\n**サイズ：** 8バイト\n\n**境界チェック：** なし\n\n**例：**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n#### バッファ（buffer）\n\n**型：** `buffer`\n\n**説明：** 境界チェック付きの安全なポインタラッパー\n\n**構造：** ポインタ + 長さ + 容量\n\n**プロパティ：**\n- `.length` - バッファサイズ\n- `.capacity` - 割り当て容量\n\n**例：**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // 境界チェックあり\nprint(b.length);        // 64\nfree(b);\n```\n\n**関連項目：** 割り当て関数は[メモリAPI](#reference-memory-api)\n\n---\n\n## 特殊型\n\n### ファイル型\n\n**型：** `file`\n\n**説明：** I/O操作用のファイルハンドル\n\n**プロパティ：**\n- `.path` - ファイルパス（string）\n- `.mode` - オープンモード（string）\n- `.closed` - ファイルがクローズされているか（bool）\n\n**関連項目：** [ファイルAPI](#reference-file-api)\n\n---\n\n### タスク型\n\n**型：** `task`\n\n**説明：** 並行タスクのハンドル\n\n**関連項目：** [並行性API](#reference-concurrency-api)\n\n---\n\n### チャネル型\n\n**型：** `channel`\n\n**説明：** スレッドセーフな通信チャネル\n\n**関連項目：** [並行性API](#reference-concurrency-api)\n\n---\n\n### 関数型\n\n**型：** `function`\n\n**説明：** ファーストクラスの関数値\n\n**例：**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(typeof(add));      // \"function\"\nprint(typeof(multiply)); // \"function\"\n```\n\n---\n\n### Void型\n\n**型：** `void`\n\n**説明：** 戻り値の不在（内部使用）\n\n---\n\n## 型昇格規則\n\n操作で型を混合する場合、Hemlockは「より高い」型に昇格します：\n\n**昇格階層：**\n```\nf64（最高精度）\n ↑\nf32\n ↑\nu64\n ↑\ni64\n ↑\nu32\n ↑\ni32\n ↑\nu16\n ↑\ni16\n ↑\nu8\n ↑\ni8（最低）\n```\n\n**規則：**\n1. 浮動小数点は常に整数に勝つ\n2. 同じカテゴリ（int/uint/float）内ではより大きいサイズが勝つ\n3. 両方のオペランドが結果の型に昇格される\n4. **精度保持：** i64/u64 + f32はf64に昇格（f32ではない）\n\n**例：**\n```hemlock\n// サイズ昇格\nu8 + i32    → i32    // より大きいサイズが勝つ\ni32 + i64   → i64    // より大きいサイズが勝つ\nu32 + u64   → u64    // より大きいサイズが勝つ\n\n// 浮動小数点昇格\ni32 + f32   → f32    // 浮動小数点が勝つ、f32はi32に十分\ni64 + f32   → f64    // i64の精度を保持するためf64に昇格\ni64 + f64   → f64    // 浮動小数点は常に勝つ\ni8 + f64    → f64    // 浮動小数点 + 最大が勝つ\n```\n\n**なぜi64 + f32 → f64なのか？**\n\nf32は24ビットの仮数しかなく、2^24（16,777,216）より大きい整数を正確に表現できません。i64は2^63までの値を保持できるため、i64とf32を混合すると深刻な精度損失が発生します。Hemlockは代わりにf64（53ビット仮数）に昇格します。\n\n---\n\n## 範囲チェック\n\n型注釈は代入時に範囲チェックを強制します：\n\n**有効な代入：**\n```hemlock\nlet x: u8 = 255;             // OK\nlet y: i8 = 127;             // OK\nlet a: i64 = 2147483647;     // OK\nlet b: u64 = 4294967295;     // OK\n```\n\n**無効な代入（実行時エラー）：**\n```hemlock\nlet x: u8 = 256;             // エラー：範囲外\nlet y: i8 = 128;             // エラー：最大は127\nlet z: u64 = -1;             // エラー：u64は負にできない\n```\n\n---\n\n## 型イントロスペクション\n\n### typeof(value)\n\n値の型名を文字列として返します。\n\n**シグネチャ：**\n```hemlock\ntypeof(value: any): string\n```\n\n**戻り値：**\n- プリミティブ型：`\"i8\"`、`\"i16\"`、`\"i32\"`、`\"i64\"`、`\"u8\"`、`\"u16\"`、`\"u32\"`、`\"u64\"`、`\"f32\"`、`\"f64\"`、`\"bool\"`、`\"string\"`、`\"rune\"`、`\"null\"`\n- 複合型：`\"array\"`、`\"object\"`、`\"ptr\"`、`\"buffer\"`、`\"function\"`\n- 特殊型：`\"file\"`、`\"task\"`、`\"channel\"`\n- 型付きオブジェクト：カスタム型名（例：`\"Person\"`）\n\n**例：**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n```\n\n**関連項目：** [組み込み関数](builtins.md#typeof)\n\n---\n\n## 型変換\n\n### 暗黙的変換\n\nHemlockは型昇格規則に従って算術操作で暗黙的な型変換を行います。\n\n**例：**\n```hemlock\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet result = a + b;     // resultはi32（昇格される）\n```\n\n### 明示的変換\n\n明示的な変換には型注釈を使用します：\n\n**例：**\n```hemlock\n// 整数から浮動小数点\nlet i: i32 = 42;\nlet f: f64 = i;         // 42.0\n\n// 浮動小数点から整数（切り詰め）\nlet x: f64 = 3.14;\nlet y: i32 = x;         // 3\n\n// 整数からrune\nlet code: rune = 65;    // 'A'\n\n// runeから整数\nlet value: i32 = 'Z';   // 90\n\n// runeから文字列\nlet s: string = 'H';    // \"H\"\n```\n\n---\n\n## 型エイリアス\n\n### 組み込みエイリアス\n\nHemlockは一般的な型の組み込み型エイリアスを提供します：\n\n| エイリアス | 実際の型 | 用途 |\n|-----------|-------------|--------------------------|\n| `integer` | `i32`       | 汎用整数 |\n| `number`  | `f64`       | 汎用浮動小数点 |\n| `byte`    | `u8`        | バイト値 |\n\n**例：**\n```hemlock\nlet count: integer = 100;       // i32と同じ\nlet price: number = 19.99;      // f64と同じ\nlet b: byte = 255;              // u8と同じ\n```\n\n### カスタム型エイリアス\n\n`type`キーワードを使用してカスタム型エイリアスを定義：\n\n```hemlock\n// シンプルなエイリアス\ntype Integer = i32;\ntype Text = string;\n\n// 関数型エイリアス\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\n// 複合型エイリアス\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// ジェネリック型エイリアス\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n```\n\n**カスタムエイリアスの使用：**\n```hemlock\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**注意：** 型エイリアスは透過的です - `typeof()`は基礎となる型名を返します。\n\n---\n\n## 関数型\n\n関数型は関数値のシグネチャを指定します：\n\n### 構文\n\n```hemlock\nfn(param_types): return_type\n```\n\n### 例\n\n```hemlock\n// 基本的な関数型\nlet add: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// 関数パラメータ\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// 関数を返す高階関数\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// 非同期関数型\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n```\n\n---\n\n## 複合型（交差型）\n\n複合型は`&`を使用して複数の型制約を要求します：\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// オブジェクトはすべての型を満たす必要がある\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// 3つ以上の型\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n---\n\n## 要約表\n\n| 型 | サイズ | 可変 | ヒープ割り当て | 説明 |\n|------------|----------|---------|----------------|--------------------------------|\n| `i8`-`i64` | 1-8バイト | いいえ | いいえ | 符号付き整数 |\n| `u8`-`u64` | 1-8バイト | いいえ | いいえ | 符号なし整数 |\n| `f32`      | 4バイト | いいえ | いいえ | 単精度浮動小数点 |\n| `f64`      | 8バイト | いいえ | いいえ | 倍精度浮動小数点 |\n| `bool`     | 1バイト | いいえ | いいえ | ブーリアン |\n| `rune`     | 4バイト | いいえ | いいえ | Unicodeコードポイント |\n| `string`   | 可変 | はい | はい | UTF-8テキスト |\n| `array`    | 可変 | はい | はい | 動的配列 |\n| `object`   | 可変 | はい | はい | 動的オブジェクト |\n| `ptr`      | 8バイト | いいえ | いいえ | 生ポインタ |\n| `buffer`   | 可変 | はい | はい | 安全なポインタラッパー |\n| `file`     | 不透明 | はい | はい | ファイルハンドル |\n| `task`     | 不透明 | いいえ | はい | 並行タスクハンドル |\n| `channel`  | 不透明 | はい | はい | スレッドセーフチャネル |\n| `function` | 不透明 | いいえ | はい | 関数値 |\n| `null`     | 8バイト | いいえ | いいえ | Null値 |\n\n---\n\n## 関連項目\n\n- [演算子リファレンス](#reference-operators) - 操作での型の動作\n- [組み込み関数](#reference-builtins) - 型イントロスペクションと変換\n- [文字列API](#reference-string-api) - 文字列型メソッド\n- [配列API](#reference-array-api) - 配列型メソッド\n- [メモリAPI](#reference-memory-api) - ポインタとバッファ操作\n"}, "APIリファレンス -> 文字列API": {"id": "reference-string-api", "content": "# 文字列APIリファレンス\n\nHemlockの文字列型と全19個の文字列メソッドの完全なリファレンスです。\n\n---\n\n## 概要\n\nHemlockの文字列は**UTF-8エンコード、可変、ヒープ割り当て**されるシーケンスであり、完全なUnicodeサポートを提供します。すべての操作は**コードポイント**（文字）で動作し、バイトではありません。\n\n**主な機能：**\n- UTF-8エンコーディング（U+0000からU+10FFFF）\n- 可変（文字をその場で変更可能）\n- コードポイントベースのインデックス\n- 19個の組み込みメソッド\n- `+`演算子での自動連結\n\n---\n\n## 文字列型\n\n**型：** `string`\n\n**プロパティ：**\n- `.length` - コードポイント数（文字数）\n- `.byte_length` - UTF-8バイト数\n\n**リテラル構文：** ダブルクォート `\"text\"`\n\n**例：**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5（コードポイント）\nprint(s.byte_length);   // 5（バイト）\n\nlet emoji = \"🚀\";\nprint(emoji.length);        // 1（1つのコードポイント）\nprint(emoji.byte_length);   // 4（4つのUTF-8バイト）\n```\n\n---\n\n## インデックス\n\n文字列は`[]`を使用したコードポイントベースのインデックスをサポートします：\n\n**読み取りアクセス：**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // rune 'h'を返す\n```\n\n**書き込みアクセス：**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // runeで変更（\"Hello\"になる）\n```\n\n**UTF-8の例：**\n```hemlock\nlet text = \"Hi🚀!\";\nprint(text[0]);         // 'H'\nprint(text[1]);         // 'i'\nprint(text[2]);         // '🚀'（1つのコードポイント）\nprint(text[3]);         // '!'\n```\n\n---\n\n## 連結\n\n`+`演算子を使用して文字列とruneを連結します：\n\n**文字列 + 文字列：**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n```\n\n**文字列 + Rune：**\n```hemlock\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\nlet decorated = \"Text\" + '✓';      // \"Text✓\"\n```\n\n**Rune + 文字列：**\n```hemlock\nlet prefix = '>' + \" Message\";     // \"> Message\"\nlet bullet = '•' + \" Item\";        // \"• Item\"\n```\n\n**複数の連結：**\n```hemlock\nlet msg = \"Hi \" + '👋' + \" World \" + '🌍';  // \"Hi 👋 World 🌍\"\n```\n\n---\n\n## 文字列プロパティ\n\n### .length\n\nUnicodeコードポイント（文字）の数を取得します。\n\n**型：** `i32`\n\n**例：**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5\n\nlet emoji = \"🚀\";\nprint(emoji.length);    // 1（1つのコードポイント）\n\nlet text = \"Hello 🌍!\";\nprint(text.length);     // 8（7 ASCII + 1絵文字）\n```\n\n---\n\n### .byte_length\n\nUTF-8バイト数を取得します。\n\n**型：** `i32`\n\n**例：**\n```hemlock\nlet s = \"hello\";\nprint(s.byte_length);   // 5（ASCII文字1つにつき1バイト）\n\nlet emoji = \"🚀\";\nprint(emoji.byte_length); // 4（絵文字は4 UTF-8バイト）\n\nlet text = \"Hello 🌍!\";\nprint(text.byte_length);  // 11（7 ASCII + 絵文字4）\n```\n\n---\n\n## 文字列メソッド\n\n### 部分文字列とスライス\n\n#### substr\n\n位置と長さで部分文字列を抽出します。\n\n**シグネチャ：**\n```hemlock\nstring.substr(start: i32, length: i32): string\n```\n\n**パラメータ：**\n- `start` - 開始コードポイントインデックス（0ベース）\n- `length` - 抽出するコードポイント数\n\n**戻り値：** 新しい文字列\n\n**例：**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\"\nlet first = s.substr(0, 5);     // \"hello\"\n\n// UTF-8の例\nlet text = \"Hi🚀!\";\nlet emoji = text.substr(2, 1);  // \"🚀\"\n```\n\n---\n\n#### slice\n\n範囲で部分文字列を抽出します（終了は含まない）。\n\n**シグネチャ：**\n```hemlock\nstring.slice(start: i32, end: i32): string\n```\n\n**パラメータ：**\n- `start` - 開始コードポイントインデックス（0ベース）\n- `end` - 終了コードポイントインデックス（含まない）\n\n**戻り値：** 新しい文字列\n\n**例：**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.slice(0, 5);        // \"hello\"\nlet world = s.slice(6, 11);     // \"world\"\n\n// UTF-8の例\nlet text = \"Hi🚀!\";\nlet first_three = text.slice(0, 3);  // \"Hi🚀\"\n```\n\n---\n\n### 検索と検出\n\n#### find\n\n部分文字列の最初の出現位置を見つけます。\n\n**シグネチャ：**\n```hemlock\nstring.find(needle: string): i32\n```\n\n**パラメータ：**\n- `needle` - 検索する部分文字列\n\n**戻り値：** 最初の出現のコードポイントインデックス、見つからない場合は`-1`\n\n**例：**\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6\nlet pos2 = s.find(\"foo\");       // -1（見つからない）\nlet pos3 = s.find(\"l\");         // 2（最初の'l'）\n```\n\n---\n\n#### contains\n\n文字列が部分文字列を含むかチェックします。\n\n**シグネチャ：**\n```hemlock\nstring.contains(needle: string): bool\n```\n\n**パラメータ：**\n- `needle` - 検索する部分文字列\n\n**戻り値：** 見つかった場合は`true`、それ以外は`false`\n\n**例：**\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n---\n\n### 分割と結合\n\n#### split\n\n区切り文字で文字列を配列に分割します。\n\n**シグネチャ：**\n```hemlock\nstring.split(delimiter: string): array\n```\n\n**パラメータ：**\n- `delimiter` - 分割する文字列\n\n**戻り値：** 文字列の配列\n\n**例：**\n```hemlock\nlet csv = \"a,b,c\";\nlet parts = csv.split(\",\");     // [\"a\", \"b\", \"c\"]\n\nlet path = \"/usr/local/bin\";\nlet dirs = path.split(\"/\");     // [\"\", \"usr\", \"local\", \"bin\"]\n\nlet text = \"hello world foo\";\nlet words = text.split(\" \");    // [\"hello\", \"world\", \"foo\"]\n```\n\n---\n\n#### trim\n\n先頭と末尾の空白を削除します。\n\n**シグネチャ：**\n```hemlock\nstring.trim(): string\n```\n\n**戻り値：** 空白が削除された新しい文字列\n\n**例：**\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet text = \"\\n\\t  world  \\n\";\nlet clean2 = text.trim();       // \"world\"\n```\n\n---\n\n### 大文字小文字変換\n\n#### to_upper\n\n文字列を大文字に変換します。\n\n**シグネチャ：**\n```hemlock\nstring.to_upper(): string\n```\n\n**戻り値：** 大文字の新しい文字列\n\n**例：**\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\nlet mixed = \"HeLLo\";\nlet upper2 = mixed.to_upper();  // \"HELLO\"\n```\n\n---\n\n#### to_lower\n\n文字列を小文字に変換します。\n\n**シグネチャ：**\n```hemlock\nstring.to_lower(): string\n```\n\n**戻り値：** 小文字の新しい文字列\n\n**例：**\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n\nlet mixed = \"HeLLo\";\nlet lower2 = mixed.to_lower();  // \"hello\"\n```\n\n---\n\n### 接頭辞と接尾辞\n\n#### starts_with\n\n文字列が接頭辞で始まるかチェックします。\n\n**シグネチャ：**\n```hemlock\nstring.starts_with(prefix: string): bool\n```\n\n**パラメータ：**\n- `prefix` - チェックする接頭辞\n\n**戻り値：** 文字列が接頭辞で始まる場合は`true`、それ以外は`false`\n\n**例：**\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n---\n\n#### ends_with\n\n文字列が接尾辞で終わるかチェックします。\n\n**シグネチャ：**\n```hemlock\nstring.ends_with(suffix: string): bool\n```\n\n**パラメータ：**\n- `suffix` - チェックする接尾辞\n\n**戻り値：** 文字列が接尾辞で終わる場合は`true`、それ以外は`false`\n\n**例：**\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n---\n\n### 置換\n\n#### replace\n\n部分文字列の最初の出現を置換します。\n\n**シグネチャ：**\n```hemlock\nstring.replace(old: string, new: string): string\n```\n\n**パラメータ：**\n- `old` - 置換する部分文字列\n- `new` - 置換文字列\n\n**戻り値：** 最初の出現が置換された新しい文字列\n\n**例：**\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");  // \"hello there\"\n\nlet text = \"foo foo foo\";\nlet text2 = text.replace(\"foo\", \"bar\"); // \"bar foo foo\"（最初のみ）\n```\n\n---\n\n#### replace_all\n\n部分文字列のすべての出現を置換します。\n\n**シグネチャ：**\n```hemlock\nstring.replace_all(old: string, new: string): string\n```\n\n**パラメータ：**\n- `old` - 置換する部分文字列\n- `new` - 置換文字列\n\n**戻り値：** すべての出現が置換された新しい文字列\n\n**例：**\n```hemlock\nlet text = \"foo foo foo\";\nlet text2 = text.replace_all(\"foo\", \"bar\"); // \"bar bar bar\"\n\nlet s = \"hello world hello\";\nlet s2 = s.replace_all(\"hello\", \"hi\");      // \"hi world hi\"\n```\n\n---\n\n### 繰り返し\n\n#### repeat\n\n文字列をn回繰り返します。\n\n**シグネチャ：**\n```hemlock\nstring.repeat(count: i32): string\n```\n\n**パラメータ：**\n- `count` - 繰り返し回数\n\n**戻り値：** count回繰り返された新しい文字列\n\n**例：**\n```hemlock\nlet s = \"ha\";\nlet repeated = s.repeat(3);     // \"hahaha\"\n\nlet line = \"-\";\nlet separator = line.repeat(40); // \"----------------------------------------\"\n```\n\n---\n\n### 文字アクセス\n\n#### char_at\n\nインデックスのUnicodeコードポイントを取得します。\n\n**シグネチャ：**\n```hemlock\nstring.char_at(index: i32): rune\n```\n\n**パラメータ：**\n- `index` - コードポイントインデックス（0ベース）\n\n**戻り値：** Rune（Unicodeコードポイント）\n\n**例：**\n```hemlock\nlet s = \"hello\";\nlet ch = s.char_at(0);          // 'h'\nlet ch2 = s.char_at(1);         // 'e'\n\n// UTF-8の例\nlet emoji = \"🚀\";\nlet ch3 = emoji.char_at(0);     // U+1F680（ロケット）\n```\n\n---\n\n#### chars\n\n文字列をruneの配列に変換します。\n\n**シグネチャ：**\n```hemlock\nstring.chars(): array\n```\n\n**戻り値：** runeの配列（コードポイント）\n\n**例：**\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']\n\n// UTF-8の例\nlet text = \"Hi🚀!\";\nlet chars2 = text.chars();      // ['H', 'i', '🚀', '!']\n```\n\n---\n\n### バイトアクセス\n\n#### byte_at\n\nインデックスのバイト値を取得します。\n\n**シグネチャ：**\n```hemlock\nstring.byte_at(index: i32): u8\n```\n\n**パラメータ：**\n- `index` - バイトインデックス（0ベース、コードポイントインデックスではない）\n\n**戻り値：** バイト値（u8）\n\n**例：**\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104（ASCII 'h'）\nlet byte2 = s.byte_at(1);       // 101（ASCII 'e'）\n\n// UTF-8の例\nlet emoji = \"🚀\";\nlet byte3 = emoji.byte_at(0);   // 240（最初のUTF-8バイト）\n```\n\n---\n\n#### bytes\n\n文字列をバイトの配列に変換します。\n\n**シグネチャ：**\n```hemlock\nstring.bytes(): array\n```\n\n**戻り値：** u8バイトの配列\n\n**例：**\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111]\n\n// UTF-8の例\nlet emoji = \"🚀\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128]（4 UTF-8バイト）\n```\n\n---\n\n#### to_bytes\n\n文字列をバッファに変換します。\n\n**シグネチャ：**\n```hemlock\nstring.to_bytes(): buffer\n```\n\n**戻り値：** UTF-8バイトを含むバッファ\n\n**例：**\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();\nprint(buf.length);              // 5\n\n// UTF-8の例\nlet emoji = \"🚀\";\nlet buf2 = emoji.to_bytes();\nprint(buf2.length);             // 4\n```\n\n**注意：** これはレガシーメソッドです。ほとんどの場合は`.bytes()`を使用してください。\n\n---\n\n### JSONデシリアライズ\n\n#### deserialize\n\nJSON文字列を値にパースします。\n\n**シグネチャ：**\n```hemlock\nstring.deserialize(): any\n```\n\n**戻り値：** パースされた値（オブジェクト、配列、数値、文字列、bool、またはnull）\n\n**例：**\n```hemlock\nlet json = '{\"x\":10,\"y\":20}';\nlet obj = json.deserialize();\nprint(obj.x);                   // 10\nprint(obj.y);                   // 20\n\nlet arr_json = '[1,2,3]';\nlet arr = arr_json.deserialize();\nprint(arr[0]);                  // 1\n\nlet num_json = '42';\nlet num = num_json.deserialize();\nprint(num);                     // 42\n```\n\n**サポートされる型：**\n- オブジェクト：`{\"key\": value}`\n- 配列：`[1, 2, 3]`\n- 数値：`42`、`3.14`\n- 文字列：`\"text\"`\n- ブーリアン：`true`、`false`\n- Null：`null`\n\n**関連項目：** オブジェクトの`.serialize()`メソッド\n\n---\n\n## メソッドチェーン\n\n文字列メソッドは簡潔な操作のためにチェーンできます：\n\n**例：**\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \");                  // \"foo | bar | baz\"\n\nlet cleaned = \"  HELLO  \"\n    .trim()\n    .to_lower();                   // \"hello\"\n```\n\n---\n\n## 完全なメソッド要約\n\n| メソッド | シグネチャ | 戻り値 | 説明 |\n|----------------|----------------------------------------------|-----------|---------------------------------------|\n| `substr`       | `(start: i32, length: i32)`                  | `string`  | 位置/長さで部分文字列を抽出 |\n| `slice`        | `(start: i32, end: i32)`                     | `string`  | 範囲で部分文字列を抽出 |\n| `find`         | `(needle: string)`                           | `i32`     | 最初の出現を見つける（見つからない場合-1）|\n| `contains`     | `(needle: string)`                           | `bool`    | 部分文字列を含むかチェック |\n| `split`        | `(delimiter: string)`                        | `array`   | 配列に分割 |\n| `trim`         | `()`                                         | `string`  | 空白を削除 |\n| `to_upper`     | `()`                                         | `string`  | 大文字に変換 |\n| `to_lower`     | `()`                                         | `string`  | 小文字に変換 |\n| `starts_with`  | `(prefix: string)`                           | `bool`    | 接頭辞で始まるかチェック |\n| `ends_with`    | `(suffix: string)`                           | `bool`    | 接尾辞で終わるかチェック |\n| `replace`      | `(old: string, new: string)`                 | `string`  | 最初の出現を置換 |\n| `replace_all`  | `(old: string, new: string)`                 | `string`  | すべての出現を置換 |\n| `repeat`       | `(count: i32)`                               | `string`  | 文字列をn回繰り返す |\n| `char_at`      | `(index: i32)`                               | `rune`    | インデックスのコードポイントを取得 |\n| `byte_at`      | `(index: i32)`                               | `u8`      | インデックスのバイトを取得 |\n| `chars`        | `()`                                         | `array`   | runeの配列に変換 |\n| `bytes`        | `()`                                         | `array`   | バイトの配列に変換 |\n| `to_bytes`     | `()`                                         | `buffer`  | バッファに変換（レガシー） |\n| `deserialize`  | `()`                                         | `any`     | JSON文字列をパース |\n\n---\n\n## 関連項目\n\n- [型システム](#reference-type-system) - 文字列型の詳細\n- [配列API](#reference-array-api) - split()結果の配列メソッド\n- [演算子](#reference-operators) - 文字列連結演算子\n"}, "APIリファレンス -> 演算子": {"id": "reference-operators", "content": "# 演算子リファレンス\n\nHemlockのすべての演算子の完全なリファレンスです。優先順位、結合性、動作を含みます。\n\n---\n\n## 概要\n\nHemlockはCスタイルの演算子と明示的な優先順位規則を提供します。すべての演算子は厳密な型付け規則に従い、適用可能な場合は自動型昇格が行われます。\n\n---\n\n## 算術演算子\n\n### 二項算術\n\n| 演算子 | 名前 | 例 | 説明 |\n|----------|----------------|------------|------------------------------|\n| `+`      | 加算 | `a + b`    | 2つの値を加算 |\n| `-`      | 減算 | `a - b`    | aからbを減算 |\n| `*`      | 乗算 | `a * b`    | 2つの値を乗算 |\n| `/`      | 除算 | `a / b`    | aをbで除算 |\n\n**型昇格：**\n結果は型昇格規則に従います（[型システム](type-system.md#型昇格規則)を参照）。\n\n**例：**\n```hemlock\nlet a = 10 + 5;        // 15 (i32)\nlet b = 10 - 3;        // 7 (i32)\nlet c = 4 * 5;         // 20 (i32)\nlet d = 20 / 4;        // 5 (i32)\n\n// 浮動小数点除算\nlet e = 10.0 / 3.0;    // 3.333... (f64)\n\n// 混合型\nlet f: u8 = 10;\nlet g: i32 = 20;\nlet h = f + g;         // 30 (i32, 昇格される)\n```\n\n**ゼロ除算：**\n- 整数のゼロ除算：実行時エラー\n- 浮動小数点のゼロ除算：`inf`または`-inf`を返す\n\n---\n\n### 単項算術\n\n| 演算子 | 名前 | 例 | 説明 |\n|----------|----------|---------|----------------------|\n| `-`      | 否定 | `-a`    | 値を否定 |\n| `+`      | プラス | `+a`    | 恒等（何もしない） |\n\n**例：**\n```hemlock\nlet a = 5;\nlet b = -a;            // -5\nlet c = +a;            // 5（変更なし）\n\nlet x = -3.14;         // -3.14\n```\n\n---\n\n## 比較演算子\n\n| 演算子 | 名前 | 例 | 戻り値 |\n|----------|-----------------------|------------|---------|\n| `==`     | 等しい | `a == b`   | `bool`  |\n| `!=`     | 等しくない | `a != b`   | `bool`  |\n| `<`      | より小さい | `a < b`    | `bool`  |\n| `>`      | より大きい | `a > b`    | `bool`  |\n| `<=`     | 以下 | `a <= b`   | `bool`  |\n| `>=`     | 以上 | `a >= b`   | `bool`  |\n\n**型昇格：**\n比較前にオペランドが昇格されます。\n\n**例：**\n```hemlock\nprint(5 == 5);         // true\nprint(10 != 5);        // true\nprint(3 < 7);          // true\nprint(10 > 5);         // true\nprint(5 <= 5);         // true\nprint(10 >= 5);        // true\n\n// 文字列比較\nprint(\"hello\" == \"hello\");  // true\nprint(\"abc\" < \"def\");       // true（辞書順）\n\n// 混合型\nlet a: u8 = 10;\nlet b: i32 = 10;\nprint(a == b);         // true（i32に昇格）\n```\n\n---\n\n## 論理演算子\n\n| 演算子 | 名前 | 例 | 説明 |\n|----------|-------------|--------------|--------------------------|\n| `&&`     | 論理AND | `a && b`     | 両方がtrueならtrue |\n| `\\|\\|`   | 論理OR | `a \\|\\| b`   | どちらかがtrueならtrue |\n| `!`      | 論理NOT | `!a`         | ブーリアンを否定 |\n\n**短絡評価：**\n- `&&` - 最初のfalse値で停止\n- `||` - 最初のtrue値で停止\n\n**例：**\n```hemlock\nlet a = true;\nlet b = false;\n\nprint(a && b);         // false\nprint(a || b);         // true\nprint(!a);             // false\nprint(!b);             // true\n\n// 短絡\nif (x != 0 && (10 / x) > 2) {\n    print(\"safe\");\n}\n\nif (x == 0 || (10 / x) > 2) {\n    print(\"safe\");\n}\n```\n\n---\n\n## ビット演算子\n\n**制限：** 整数型のみ（i8-i64、u8-u64）\n\n### 二項ビット演算\n\n| 演算子 | 名前 | 例 | 説明 |\n|----------|--------------|------------|--------------------------|\n| `&`      | ビットAND | `a & b`    | 各ビットをAND |\n| `\\|`     | ビットOR | `a \\| b`   | 各ビットをOR |\n| `^`      | ビットXOR | `a ^ b`    | 各ビットをXOR |\n| `<<`     | 左シフト | `a << b`   | bビット左にシフト |\n| `>>`     | 右シフト | `a >> b`   | bビット右にシフト |\n\n**型保持：**\n結果の型はオペランドの型に一致（型昇格あり）。\n\n**例：**\n```hemlock\nlet a = 12;  // 2進数で1100\nlet b = 10;  // 2進数で1010\n\nprint(a & b);          // 8  (1000)\nprint(a | b);          // 14 (1110)\nprint(a ^ b);          // 6  (0110)\nprint(a << 2);         // 48 (110000)\nprint(a >> 1);         // 6  (110)\n```\n\n**符号なしの例：**\n```hemlock\nlet c: u8 = 15;        // 00001111\nlet d: u8 = 7;         // 00000111\n\nprint(c & d);          // 7  (00000111)\nprint(c | d);          // 15 (00001111)\nprint(c ^ d);          // 8  (00001000)\n```\n\n**右シフトの動作：**\n- 符号付き型：算術シフト（符号拡張）\n- 符号なし型：論理シフト（ゼロ埋め）\n\n---\n\n### 単項ビット演算\n\n| 演算子 | 名前 | 例 | 説明 |\n|----------|-------------|---------|--------------------------|\n| `~`      | ビットNOT | `~a`    | すべてのビットを反転 |\n\n**例：**\n```hemlock\nlet a = 12;            // 00001100 (i32)\nprint(~a);             // -13（2の補数）\n\nlet b: u8 = 15;        // 00001111\nprint(~b);             // 240 (11110000)\n```\n\n---\n\n## 文字列演算子\n\n### 連結\n\n| 演算子 | 名前 | 例 | 説明 |\n|----------|----------------|------------|--------------------|\n| `+`      | 連結 | `a + b`    | 文字列を結合 |\n\n**例：**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n\n// 文字列 + rune\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\n\n// rune + 文字列\nlet prefix = '>' + \" Message\";     // \"> Message\"\n```\n\n---\n\n## 代入演算子\n\n### 基本代入\n\n| 演算子 | 名前 | 例 | 説明 |\n|----------|------------|------------|--------------------------|\n| `=`      | 代入 | `a = b`    | 変数に値を代入 |\n\n**例：**\n```hemlock\nlet x = 10;\nx = 20;\n\nlet arr = [1, 2, 3];\narr[0] = 99;\n\nlet obj = { x: 10 };\nobj.x = 20;\n```\n\n### 複合代入\n\n#### 算術複合代入\n\n| 演算子 | 名前 | 例 | 等価 |\n|----------|-----------------|------------|--------------------|\n| `+=`     | 加算代入 | `a += b`   | `a = a + b`        |\n| `-=`     | 減算代入 | `a -= b`   | `a = a - b`        |\n| `*=`     | 乗算代入 | `a *= b`   | `a = a * b`        |\n| `/=`     | 除算代入 | `a /= b`   | `a = a / b`        |\n| `%=`     | 剰余代入 | `a %= b`   | `a = a % b`        |\n\n**例：**\n```hemlock\nlet x = 10;\nx += 5;      // xは15になる\nx -= 3;      // xは12になる\nx *= 2;      // xは24になる\nx /= 4;      // xは6になる\n\nlet count = 0;\ncount += 1;  // 1ずつインクリメント\n```\n\n#### ビット複合代入\n\n| 演算子 | 名前 | 例 | 等価 |\n|----------|--------------------|-------------|---------------------|\n| `&=`     | ビットAND代入 | `a &= b`    | `a = a & b`         |\n| `\\|=`    | ビットOR代入 | `a \\|= b`   | `a = a \\| b`        |\n| `^=`     | ビットXOR代入 | `a ^= b`    | `a = a ^ b`         |\n| `<<=`    | 左シフト代入 | `a <<= b`   | `a = a << b`        |\n| `>>=`    | 右シフト代入 | `a >>= b`   | `a = a >> b`        |\n\n**例：**\n```hemlock\nlet flags = 0b1111;\nflags &= 0b0011;   // flagsは0b0011になる（上位ビットをマスク）\nflags |= 0b1000;   // flagsは0b1011になる（ビットをセット）\nflags ^= 0b0001;   // flagsは0b1010になる（ビットをトグル）\n\nlet x = 1;\nx <<= 4;           // xは16になる（4ビット左シフト）\nx >>= 2;           // xは4になる（2ビット右シフト）\n```\n\n### インクリメント/デクリメント\n\n| 演算子 | 名前 | 例 | 説明 |\n|----------|------------|---------|--------------------------|\n| `++`     | インクリメント | `a++`   | 1ずつインクリメント（後置） |\n| `--`     | デクリメント | `a--`   | 1ずつデクリメント（後置） |\n\n**例：**\n```hemlock\nlet i = 0;\ni++;         // iは1になる\ni++;         // iは2になる\ni--;         // iは1になる\n\n// ループでよく使用\nfor (let j = 0; j < 10; j++) {\n    print(j);\n}\n```\n\n**注意：** `++`と`--`は両方とも後置演算子です（値はインクリメント/デクリメント前に返される）\n\n---\n\n## Null安全演算子\n\n### Null合体（`??`）\n\n左オペランドがnullでなければそれを返し、そうでなければ右オペランドを返します。\n\n| 演算子 | 名前 | 例 | 説明 |\n|----------|------------------|--------------|--------------------------------|\n| `??`     | Null合体 | `a ?? b`     | aがnullでなければa、そうでなければb |\n\n**例：**\n```hemlock\nlet name = null;\nlet display = name ?? \"Anonymous\";  // \"Anonymous\"\n\nlet value = 42;\nlet result = value ?? 0;            // 42\n\n// チェーン\nlet a = null;\nlet b = null;\nlet c = \"found\";\nlet result2 = a ?? b ?? c;          // \"found\"\n\n// 関数呼び出しとともに\nfn get_config() { return null; }\nlet config = get_config() ?? { default: true };\n```\n\n---\n\n### オプショナルチェーン（`?.`）\n\n潜在的にnullの値のプロパティやメソッドに安全にアクセスします。\n\n| 演算子 | 名前 | 例 | 説明 |\n|----------|-------------------|----------------|----------------------------------|\n| `?.`     | オプショナルチェーン | `a?.b`         | aがnullでなければa.b、そうでなければnull |\n| `?.[`    | オプショナルインデックス | `a?.[0]`       | aがnullでなければa[0]、そうでなければnull |\n| `?.(`    | オプショナル呼び出し | `a?.()`        | aがnullでなければa()を呼び出し、そうでなければnull |\n\n**例：**\n```hemlock\nlet user = null;\nlet name = user?.name;              // null（エラーなし）\n\nlet person = { name: \"Alice\", address: null };\nlet city = person?.address?.city;   // null（安全なナビゲーション）\n\n// 配列とともに\nlet arr = null;\nlet first = arr?.[0];               // null\n\nlet items = [1, 2, 3];\nlet second = items?.[1];            // 2\n\n// メソッド呼び出しとともに\nlet obj = { greet: fn() { return \"Hello\"; } };\nlet greeting = obj?.greet?.();      // \"Hello\"\n\nlet empty = null;\nlet result = empty?.method?.();     // null\n```\n\n**動作：**\n- 左オペランドがnullの場合、式全体がnullに短絡\n- 左オペランドがnullでない場合、通常通りアクセス\n- 深いプロパティアクセスのためにチェーン可能\n\n---\n\n## メンバーアクセス演算子\n\n### ドット演算子\n\n| 演算子 | 名前 | 例 | 説明 |\n|----------|------------------|--------------|-----------------------|\n| `.`      | メンバーアクセス | `obj.field`  | オブジェクトフィールドにアクセス |\n| `.`      | プロパティアクセス | `arr.length` | プロパティにアクセス |\n\n**例：**\n```hemlock\n// オブジェクトフィールドアクセス\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);        // \"Alice\"\n\n// 配列プロパティ\nlet arr = [1, 2, 3];\nprint(arr.length);         // 3\n\n// 文字列プロパティ\nlet s = \"hello\";\nprint(s.length);           // 5\n\n// メソッド呼び出し\nlet result = s.to_upper(); // \"HELLO\"\n```\n\n---\n\n### インデックス演算子\n\n| 演算子 | 名前 | 例 | 説明 |\n|----------|---------|-----------|----------------------|\n| `[]`     | インデックス | `arr[i]`  | 要素にアクセス |\n\n**例：**\n```hemlock\n// 配列インデックス\nlet arr = [10, 20, 30];\nprint(arr[0]);             // 10\narr[1] = 99;\n\n// 文字列インデックス（runeを返す）\nlet s = \"hello\";\nprint(s[0]);               // 'h'\ns[0] = 'H';                // \"Hello\"\n\n// バッファインデックス\nlet buf = buffer(10);\nbuf[0] = 65;\nprint(buf[0]);             // 65\n```\n\n---\n\n## 関数呼び出し演算子\n\n| 演算子 | 名前 | 例 | 説明 |\n|----------|---------------|--------------|--------------------|\n| `()`     | 関数呼び出し | `f(a, b)`    | 関数を呼び出し |\n\n**例：**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet result = add(5, 3);    // 8\n\n// メソッド呼び出し\nlet s = \"hello\";\nlet upper = s.to_upper();  // \"HELLO\"\n\n// ビルトイン呼び出し\nprint(\"message\");\n```\n\n---\n\n## 演算子優先順位\n\n演算子は高い優先順位から低い優先順位の順にリストされています：\n\n| 優先順位 | 演算子 | 説明 | 結合性 |\n|------------|----------------------------|--------------------------------|---------------|\n| 1          | `()` `[]` `.` `?.`         | 呼び出し、インデックス、メンバーアクセス、オプショナルチェーン | 左から右 |\n| 2          | `++` `--`                  | 後置インクリメント/デクリメント | 左から右 |\n| 3          | `!` `~` `-`（単項）`+`（単項） | 論理NOT、ビットNOT、否定 | 右から左 |\n| 4          | `*` `/` `%`                | 乗算、除算、剰余 | 左から右 |\n| 5          | `+` `-`                    | 加算、減算 | 左から右 |\n| 6          | `<<` `>>`                  | ビットシフト | 左から右 |\n| 7          | `<` `<=` `>` `>=`          | 関係 | 左から右 |\n| 8          | `==` `!=`                  | 等価 | 左から右 |\n| 9          | `&`                        | ビットAND | 左から右 |\n| 10         | `^`                        | ビットXOR | 左から右 |\n| 11         | `\\|`                       | ビットOR | 左から右 |\n| 12         | `&&`                       | 論理AND | 左から右 |\n| 13         | `\\|\\|`                     | 論理OR | 左から右 |\n| 14         | `??`                       | Null合体 | 左から右 |\n| 15         | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\\|=` `^=` `<<=` `>>=` | 代入 | 右から左 |\n\n---\n\n## 優先順位の例\n\n### 例1：算術と比較\n```hemlock\nlet result = 5 + 3 * 2;\n// 評価：5 + (3 * 2) = 11\n// 乗算は加算より優先順位が高い\n\nlet cmp = 10 > 5 + 3;\n// 評価：10 > (5 + 3) = true\n// 加算は比較より優先順位が高い\n```\n\n### 例2：ビット演算子\n```hemlock\nlet result1 = 12 | 10 & 8;\n// 評価：12 | (10 & 8) = 12 | 8 = 12\n// &は|より優先順位が高い\n\nlet result2 = 8 | 1 << 2;\n// 評価：8 | (1 << 2) = 8 | 4 = 12\n// シフトはビットORより優先順位が高い\n\n// 明確にするために括弧を使用\nlet result3 = (5 & 3) | (2 << 1);\n// 評価：1 | 4 = 5\n```\n\n### 例3：論理演算子\n```hemlock\nlet result = true || false && false;\n// 評価：true || (false && false) = true\n// &&は||より優先順位が高い\n\nlet cmp = 5 < 10 && 10 < 20;\n// 評価：(5 < 10) && (10 < 20) = true\n// 比較は&&より優先順位が高い\n```\n\n### 例4：括弧の使用\n```hemlock\n// 括弧なし\nlet a = 2 + 3 * 4;        // 14\n\n// 括弧あり\nlet b = (2 + 3) * 4;      // 20\n\n// 複雑な式\nlet c = (a + b) * (a - b);\n```\n\n---\n\n## 型固有の演算子動作\n\n### 除算（常にFloat）\n\n`/`演算子はオペランドの型に関係なく**常にfloat**（f64）を返します：\n\n```hemlock\nprint(10 / 3);             // 3.333... (f64)\nprint(5 / 2);              // 2.5 (f64)\nprint(10.0 / 4.0);         // 2.5 (f64)\nprint(-7 / 3);             // -2.333... (f64)\n```\n\nこれは予期しない整数切り詰めの一般的なバグを防ぎます。\n\n### フロア除算（div / divi）\n\nフロア除算（他の言語の整数除算のような）には、`div()`と`divi()`関数を使用します：\n\n```hemlock\n// div(a, b) - floatを返すフロア除算\nprint(div(5, 2));          // 2 (f64)\nprint(div(-7, 3));         // -3 (f64)  -- -無限大に向かって切り捨て\n\n// divi(a, b) - 整数を返すフロア除算\nprint(divi(5, 2));         // 2 (i64)\nprint(divi(-7, 3));        // -3 (i64)\nprint(typeof(divi(5, 2))); // i64\n```\n\n**整数を返す数学関数：**\n整数を返す他の丸め操作：\n\n```hemlock\nprint(floori(3.7));        // 3 (i64)\nprint(ceili(3.2));         // 4 (i64)\nprint(roundi(3.5));        // 4 (i64)\nprint(trunci(3.9));        // 3 (i64)\n\n// 配列インデックスとして直接使用可能\nlet arr = [10, 20, 30, 40];\nprint(arr[floori(1.9)]);   // 20（インデックス1）\n```\n\n### 文字列比較\n\n文字列は辞書順で比較されます：\n\n```hemlock\nprint(\"abc\" < \"def\");      // true\nprint(\"apple\" > \"banana\"); // false\nprint(\"hello\" == \"hello\"); // true\n```\n\n### Null比較\n\n```hemlock\nlet x = null;\n\nprint(x == null);          // true\nprint(x != null);          // false\n```\n\n### 型エラー\n\n互換性のない型間の一部の操作は許可されません：\n\n```hemlock\n// エラー：floatにビット演算子は使用不可\nlet x = 3.14 & 2.71;\n\n// エラー：文字列にビット演算子は使用不可\nlet y = \"hello\" & \"world\";\n\n// OK：算術の型昇格\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet c = a + b;             // i32（昇格される）\n```\n\n---\n\n## 関連項目\n\n- [型システム](#reference-type-system) - 型昇格と変換規則\n- [組み込み関数](#reference-builtins) - 組み込み操作\n- [文字列API](#reference-string-api) - 文字列連結とメソッド\n"}, "APIリファレンス -> 組み込み関数": {"id": "reference-builtins", "content": "# 組み込み関数リファレンス\n\nHemlockのすべての組み込み関数と定数の完全なリファレンスです。\n\n---\n\n## 概要\n\nHemlockは、I/O、型イントロスペクション、メモリ管理、並行処理、システムインタラクションのための組み込み関数セットを提供します。すべての組み込み関数はインポートなしでグローバルに利用可能です。\n\n---\n\n## I/O関数\n\n### print\n\n改行付きで値を標準出力に出力します。\n\n**シグネチャ:**\n```hemlock\nprint(...values): null\n```\n\n**パラメータ:**\n- `...values` - 出力する任意の数の値\n\n**戻り値:** `null`\n\n**例:**\n```hemlock\nprint(\"Hello, World!\");\nprint(42);\nprint(3.14);\nprint(true);\nprint([1, 2, 3]);\nprint({ x: 10, y: 20 });\n\n// 複数の値\nprint(\"x =\", 10, \"y =\", 20);\n```\n\n**動作:**\n- すべての値を文字列に変換\n- 複数の値をスペースで区切る\n- 末尾に改行を追加\n- 標準出力をフラッシュ\n\n---\n\n### read_line\n\n標準入力から1行のテキストを読み取ります（ユーザー入力）。\n\n**シグネチャ:**\n```hemlock\nread_line(): string | null\n```\n\n**パラメータ:** なし\n\n**戻り値:**\n- `string` - 標準入力から読み取った行（改行は除去済み）\n- `null` - EOF（ファイル/入力の終端）の場合\n\n**例:**\n```hemlock\n// シンプルなプロンプト\nprint(\"What is your name?\");\nlet name = read_line();\nprint(\"Hello, \" + name + \"!\");\n\n// 数値の読み取り（手動パースが必要）\nprint(\"Enter a number:\");\nlet input = read_line();\nlet num = parse_int(input);  // parse_intについては以下を参照\nprint(\"Double:\", num * 2);\n\n// EOFの処理\nlet line = read_line();\nif (line == null) {\n    print(\"End of input\");\n}\n\n// 複数行の読み取り\nprint(\"Enter lines (Ctrl+D to stop):\");\nwhile (true) {\n    let line = read_line();\n    if (line == null) {\n        break;\n    }\n    print(\"You said:\", line);\n}\n```\n\n**動作:**\n- ユーザーがEnterを押すまでブロック\n- 末尾の改行（`\\n`）とキャリッジリターン（`\\r`）を除去\n- EOF時に`null`を返す（Unixでは Ctrl+D、Windowsでは Ctrl+Z）\n- 標準入力からのみ読み取り（ファイルからは読み取らない）\n\n**ユーザー入力のパース:**\n\n`read_line()`は常に文字列を返すため、数値入力は手動でパースする必要があります:\n\n```hemlock\n// シンプルな整数パーサー\nfn parse_int(s: string): i32 {\n    let result: i32 = 0;\n    let negative = false;\n    let i = 0;\n\n    if (s.length > 0 && s.char_at(0) == '-') {\n        negative = true;\n        i = 1;\n    }\n\n    while (i < s.length) {\n        let c = s.char_at(i);\n        let code: i32 = c;\n        if (code >= 48 && code <= 57) {\n            result = result * 10 + (code - 48);\n        } else {\n            break;\n        }\n        i = i + 1;\n    }\n\n    if (negative) {\n        return -result;\n    }\n    return result;\n}\n\n// 使用例\nprint(\"Enter your age:\");\nlet age = parse_int(read_line());\nprint(\"In 10 years you'll be\", age + 10);\n```\n\n**関連項目:** ファイルからの読み取りについては[ファイルAPI](#reference-file-api)を参照\n\n---\n\n### eprint\n\n改行付きで値を標準エラー出力に出力します。\n\n**シグネチャ:**\n```hemlock\neprint(value: any): null\n```\n\n**パラメータ:**\n- `value` - 標準エラー出力に出力する単一の値\n\n**戻り値:** `null`\n\n**例:**\n```hemlock\neprint(\"Error: file not found\");\neprint(404);\neprint(\"Warning: \" + message);\n\n// 典型的なエラー処理パターン\nfn load_config(path: string) {\n    if (!exists(path)) {\n        eprint(\"Error: config file not found: \" + path);\n        return null;\n    }\n    // ...\n}\n```\n\n**動作:**\n- 標準エラー出力（stderr）に出力\n- 末尾に改行を追加\n- 引数は1つのみ受け付け（`print`とは異なる）\n- 通常の出力と混ざるべきでないエラーメッセージに有用\n\n**printとの違い:**\n- `print()` → stdout（通常出力、`>`でリダイレクト可能）\n- `eprint()` → stderr（エラー出力、`2>`でリダイレクト可能）\n\n```bash\n# シェルの例: stdoutとstderrを分離\n./hemlock script.hml > output.txt 2> errors.txt\n```\n\n---\n\n## 型イントロスペクション\n\n### typeof\n\n値の型名を取得します。\n\n**シグネチャ:**\n```hemlock\ntypeof(value: any): string\n```\n\n**パラメータ:**\n- `value` - 任意の値\n\n**戻り値:** 型名を文字列として返す\n\n**例:**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof(null));            // \"null\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\n// 型付きオブジェクト\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n\n// その他の型\nprint(typeof(alloc(10)));       // \"ptr\"\nprint(typeof(buffer(10)));      // \"buffer\"\nprint(typeof(open(\"file.txt\"))); // \"file\"\n```\n\n**型名:**\n- プリミティブ: `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- 複合型: `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- 特殊型: `\"file\"`, `\"task\"`, `\"channel\"`\n- カスタム型: `define`で定義されたユーザー定義の型名\n\n**関連項目:** [型システム](#reference-type-system)\n\n---\n\n## コマンド実行\n\n### exec\n\nシェルコマンドを実行し、出力をキャプチャします。\n\n**シグネチャ:**\n```hemlock\nexec(command: string): object\n```\n\n**パラメータ:**\n- `command` - 実行するシェルコマンド\n\n**戻り値:** 以下のフィールドを持つオブジェクト:\n- `output` (string) - コマンドのstdout\n- `exit_code` (i32) - 終了ステータスコード（0 = 成功）\n\n**例:**\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n\n// 終了ステータスのチェック\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Found:\", r.output);\n} else {\n    print(\"Pattern not found\");\n}\n\n// 複数行の出力を処理\nlet r2 = exec(\"ls -la\");\nlet lines = r2.output.split(\"\\n\");\n```\n\n**動作:**\n- `/bin/sh`経由でコマンドを実行\n- stdoutのみをキャプチャ（stderrはターミナルに出力）\n- コマンドが完了するまでブロック\n- 出力がない場合は空文字列を返す\n\n**エラー処理:**\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command\");\n} catch (e) {\n    print(\"Failed to execute:\", e);\n}\n```\n\n**セキュリティ警告:** シェルインジェクションに脆弱です。ユーザー入力は常に検証/サニタイズしてください。\n\n**制限事項:**\n- stderrのキャプチャなし\n- ストリーミングなし\n- タイムアウトなし\n- シグナル処理なし\n\n---\n\n### exec_argv\n\n明示的な引数配列でコマンドを実行します（シェル解釈なし）。\n\n**シグネチャ:**\n```hemlock\nexec_argv(argv: array): object\n```\n\n**パラメータ:**\n- `argv` - 文字列の配列: `[command, arg1, arg2, ...]`\n\n**戻り値:** 以下のフィールドを持つオブジェクト:\n- `output` (string) - コマンドのstdout\n- `exit_code` (i32) - 終了ステータスコード（0 = 成功）\n\n**例:**\n```hemlock\n// シンプルなコマンド\nlet result = exec_argv([\"ls\", \"-la\"]);\nprint(result.output);\n\n// スペースを含む引数のコマンド（安全！）\nlet r = exec_argv([\"grep\", \"hello world\", \"file.txt\"]);\n\n// 引数付きでスクリプトを実行\nlet r2 = exec_argv([\"python\", \"script.py\", \"--input\", \"data.json\"]);\nprint(r2.exit_code);\n```\n\n**execとの違い:**\n```hemlock\n// exec()はシェルを使用 - ユーザー入力では安全でない\nexec(\"ls \" + user_input);  // シェルインジェクションのリスク！\n\n// exec_argv()はシェルをバイパス - 安全\nexec_argv([\"ls\", user_input]);  // インジェクション不可能\n```\n\n**使用するタイミング:**\n- 引数にスペース、引用符、特殊文字が含まれる場合\n- ユーザー入力を処理する場合（セキュリティ）\n- 予測可能な引数パースが必要な場合\n\n**関連項目:** シンプルなシェルコマンドには`exec()`を使用\n\n---\n\n## エラー処理\n\n### throw\n\n例外をスローします。\n\n**シグネチャ:**\n```hemlock\nthrow expression\n```\n\n**パラメータ:**\n- `expression` - スローする値（任意の型）\n\n**戻り値:** 戻りません（制御を移譲）\n\n**例:**\n```hemlock\nthrow \"error message\";\nthrow 404;\nthrow { code: 500, message: \"Internal error\" };\nthrow null;\n```\n\n**関連項目:** try/catch/finally文\n\n---\n\n### panic\n\nエラーメッセージを出力してプログラムを即座に終了します（回復不能）。\n\n**シグネチャ:**\n```hemlock\npanic(message?: any): never\n```\n\n**パラメータ:**\n- `message`（省略可能） - 出力するエラーメッセージ\n\n**戻り値:** 戻りません（プログラムが終了）\n\n**例:**\n```hemlock\npanic();                          // デフォルト: \"panic!\"\npanic(\"unreachable code reached\");\npanic(42);\n\n// 一般的な使用例\nfn process_state(state: i32): string {\n    if (state == 1) { return \"ready\"; }\n    if (state == 2) { return \"running\"; }\n    panic(\"invalid state: \" + typeof(state));\n}\n```\n\n**動作:**\n- stderrにエラーを出力: `panic: <message>`\n- 終了コード1で終了\n- try/catchで**キャッチ不可能**\n- バグや回復不能なエラーに使用\n\n**panicとthrowの違い:**\n- `panic()` - 回復不能なエラー、即座に終了\n- `throw` - 回復可能なエラー、キャッチ可能\n\n---\n\n### assert\n\n条件が真であることをアサートするか、エラーメッセージで終了します。\n\n**シグネチャ:**\n```hemlock\nassert(condition: any, message?: string): null\n```\n\n**パラメータ:**\n- `condition` - 真偽をチェックする値\n- `message`（省略可能） - アサーション失敗時のカスタムエラーメッセージ\n\n**戻り値:** `null`（アサーションが成功した場合）\n\n**例:**\n```hemlock\n// 基本的なアサーション\nassert(x > 0);\nassert(name != null);\nassert(arr.length > 0, \"Array must not be empty\");\n\n// カスタムメッセージ付き\nfn divide(a: i32, b: i32): f64 {\n    assert(b != 0, \"Division by zero\");\n    return a / b;\n}\n\n// 関数引数の検証\nfn process_data(data: array) {\n    assert(data != null, \"data cannot be null\");\n    assert(data.length > 0, \"data cannot be empty\");\n    // ...\n}\n```\n\n**動作:**\n- 条件が真の場合: `null`を返し、実行を継続\n- 条件が偽の場合: エラーを出力し、終了コード1で終了\n- 偽の値: `false`, `0`, `0.0`, `null`, `\"\"`（空文字列）\n- 真の値: それ以外すべて\n\n**失敗時の出力:**\n```\nAssertion failed: Array must not be empty\n```\n\n**使用するタイミング:**\n- 関数の事前条件の検証\n- 開発中の不変条件のチェック\n- プログラマーエラーの早期検出\n\n**assertとpanicの違い:**\n- `assert(cond, msg)` - 条件をチェックし、偽の場合に失敗\n- `panic(msg)` - 無条件で常に失敗\n\n---\n\n## シグナル処理\n\n### signal\n\nシグナルハンドラを登録またはリセットします。\n\n**シグネチャ:**\n```hemlock\nsignal(signum: i32, handler: function | null): function | null\n```\n\n**パラメータ:**\n- `signum` - シグナル番号（`SIGINT`などの定数を使用）\n- `handler` - シグナル受信時に呼び出す関数、またはデフォルトにリセットする場合は`null`\n\n**戻り値:** 以前のハンドラ関数、または`null`\n\n**例:**\n```hemlock\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// デフォルトにリセット\nsignal(SIGINT, null);\n```\n\n**ハンドラのシグネチャ:**\n```hemlock\nfn handler(signum: i32) {\n    // signumにはシグナル番号が含まれる\n}\n```\n\n**関連項目:**\n- [シグナル定数](#シグナル定数)\n- `raise()`\n\n---\n\n### raise\n\n現在のプロセスにシグナルを送信します。\n\n**シグネチャ:**\n```hemlock\nraise(signum: i32): null\n```\n\n**パラメータ:**\n- `signum` - 発生させるシグナル番号\n\n**戻り値:** `null`\n\n**例:**\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\nraise(SIGUSR1);\nraise(SIGUSR1);\nprint(count);  // 2\n```\n\n---\n\n## グローバル変数\n\n### args\n\nコマンドライン引数の配列です。\n\n**型:** 文字列の`array`\n\n**構造:**\n- `args[0]` - スクリプトのファイル名\n- `args[1..n]` - コマンドライン引数\n\n**例:**\n```bash\n# コマンド: ./hemlock script.hml hello world\n```\n\n```hemlock\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // 3\nprint(args[1]);        // \"hello\"\nprint(args[2]);        // \"world\"\n\n// 引数を反復処理\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument\", i, \":\", args[i]);\n    i = i + 1;\n}\n```\n\n**REPLでの動作:** REPLでは、`args.length`は0（空の配列）\n\n---\n\n## シグナル定数\n\n標準POSIXシグナル定数（i32値）:\n\n### 割り込みと終了\n\n| 定数       | 値    | 説明                                   |\n|------------|-------|----------------------------------------|\n| `SIGINT`   | 2     | キーボードからの割り込み（Ctrl+C）     |\n| `SIGTERM`  | 15    | 終了要求                               |\n| `SIGQUIT`  | 3     | キーボードからの終了（Ctrl+\\）         |\n| `SIGHUP`   | 1     | 制御端末でのハングアップ検出           |\n| `SIGABRT`  | 6     | 中止シグナル                           |\n\n### ユーザー定義\n\n| 定数       | 値    | 説明                       |\n|------------|-------|----------------------------|\n| `SIGUSR1`  | 10    | ユーザー定義シグナル1      |\n| `SIGUSR2`  | 12    | ユーザー定義シグナル2      |\n\n### プロセス制御\n\n| 定数       | 値    | 説明                            |\n|------------|-------|---------------------------------|\n| `SIGALRM`  | 14    | アラームクロックタイマー        |\n| `SIGCHLD`  | 17    | 子プロセスのステータス変更      |\n| `SIGCONT`  | 18    | 停止中の場合は続行              |\n| `SIGSTOP`  | 19    | プロセス停止（キャッチ不可）    |\n| `SIGTSTP`  | 20    | 端末停止（Ctrl+Z）              |\n\n### I/O\n\n| 定数       | 値    | 説明                               |\n|------------|-------|------------------------------------|\n| `SIGPIPE`  | 13    | 壊れたパイプ                       |\n| `SIGTTIN`  | 21    | バックグラウンドでの端末読み取り   |\n| `SIGTTOU`  | 22    | バックグラウンドでの端末書き込み   |\n\n**例:**\n```hemlock\nfn handle_signal(sig) {\n    if (sig == SIGINT) {\n        print(\"Interrupt detected\");\n    }\n    if (sig == SIGTERM) {\n        print(\"Termination requested\");\n    }\n}\n\nsignal(SIGINT, handle_signal);\nsignal(SIGTERM, handle_signal);\n```\n\n**注意:** `SIGKILL`（9）と`SIGSTOP`（19）はキャッチまたは無視できません。\n\n---\n\n## 数学/算術関数\n\n### div\n\n浮動小数点数を返す床除算です。\n\n**シグネチャ:**\n```hemlock\ndiv(a: number, b: number): f64\n```\n\n**パラメータ:**\n- `a` - 被除数\n- `b` - 除数\n\n**戻り値:** `a / b`の床を浮動小数点数（f64）として返す\n\n**例:**\n```hemlock\nlet result = div(7, 2);    // 3.0（3.5ではない）\nlet result2 = div(10, 3);  // 3.0\nlet result3 = div(-7, 2);  // -4.0（床は負の無限大方向に丸める）\n```\n\n**注意:** Hemlockでは、`/`演算子は常に浮動小数点数を返します。整数部分を浮動小数点数として必要な場合は`div()`を、整数結果が必要な場合は`divi()`を使用してください。\n\n---\n\n### divi\n\n整数を返す床除算です。\n\n**シグネチャ:**\n```hemlock\ndivi(a: number, b: number): i64\n```\n\n**パラメータ:**\n- `a` - 被除数\n- `b` - 除数\n\n**戻り値:** `a / b`の床を整数（i64）として返す\n\n**例:**\n```hemlock\nlet result = divi(7, 2);    // 3\nlet result2 = divi(10, 3);  // 3\nlet result3 = divi(-7, 2);  // -4（床は負の無限大方向に丸める）\n```\n\n**比較:**\n```hemlock\nprint(7 / 2);      // 3.5（通常の除算、常に浮動小数点数）\nprint(div(7, 2));  // 3.0（床除算、浮動小数点数結果）\nprint(divi(7, 2)); // 3  （床除算、整数結果）\n```\n\n---\n\n## メモリ管理関数\n\n完全なリファレンスについては[メモリAPI](#reference-memory-api)を参照:\n- `alloc(size)` - 生メモリを確保\n- `free(ptr)` - メモリを解放\n- `buffer(size)` - 安全なバッファを確保\n- `memset(ptr, byte, size)` - メモリを埋める\n- `memcpy(dest, src, size)` - メモリをコピー\n- `realloc(ptr, new_size)` - 確保サイズを変更\n\n### sizeof\n\n型のバイト単位のサイズを取得します。\n\n**シグネチャ:**\n```hemlock\nsizeof(type): i32\n```\n\n**パラメータ:**\n- `type` - 型定数（`i32`, `f64`, `ptr`など）または型名の文字列\n\n**戻り値:** バイト単位のサイズを`i32`として返す\n\n**例:**\n```hemlock\nprint(sizeof(i8));       // 1\nprint(sizeof(i16));      // 2\nprint(sizeof(i32));      // 4\nprint(sizeof(i64));      // 8\nprint(sizeof(f32));      // 4\nprint(sizeof(f64));      // 8\nprint(sizeof(ptr));      // 8\nprint(sizeof(rune));     // 4\n\n// 型エイリアスの使用\nprint(sizeof(byte));     // 1（u8と同じ）\nprint(sizeof(integer));  // 4（i32と同じ）\nprint(sizeof(number));   // 8（f64と同じ）\n\n// 文字列形式でも動作\nprint(sizeof(\"i32\"));    // 4\n```\n\n**サポートされる型:**\n| 型 | サイズ | エイリアス |\n|------|------|---------|\n| `i8` | 1 | - |\n| `i16` | 2 | - |\n| `i32` | 4 | `integer` |\n| `i64` | 8 | - |\n| `u8` | 1 | `byte` |\n| `u16` | 2 | - |\n| `u32` | 4 | - |\n| `u64` | 8 | - |\n| `f32` | 4 | - |\n| `f64` | 8 | `number` |\n| `ptr` | 8 | - |\n| `rune` | 4 | - |\n| `bool` | 1 | - |\n\n**関連項目:** 型付き確保には`talloc()`を使用\n\n---\n\n### talloc\n\n型付き配列用のメモリを確保します（型認識確保）。\n\n**シグネチャ:**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**パラメータ:**\n- `type` - 型定数（`i32`, `f64`, `ptr`など）\n- `count` - 確保する要素数\n\n**戻り値:** 確保されたメモリへの`ptr`、失敗時は`null`\n\n**例:**\n```hemlock\n// 10個のi32の配列を確保（40バイト）\nlet int_arr = talloc(i32, 10);\nptr_write_i32(int_arr, 42);\nptr_write_i32(ptr_offset(int_arr, 1, 4), 100);\n\n// 5個のf64の配列を確保（40バイト）\nlet float_arr = talloc(f64, 5);\n\n// 100バイトの配列を確保\nlet byte_arr = talloc(u8, 100);\n\n// 解放を忘れずに！\nfree(int_arr);\nfree(float_arr);\nfree(byte_arr);\n```\n\n**allocとの比較:**\n```hemlock\n// これらは同等:\nlet p1 = talloc(i32, 10);      // 型認識: 10個のi32\nlet p2 = alloc(sizeof(i32) * 10);  // 手動計算\n\n// tallocの方が明確でエラーが起きにくい\n```\n\n**エラー処理:**\n- 確保に失敗した場合は`null`を返す\n- countが正でない場合はエラーで終了\n- サイズオーバーフロー（count * element_size）をチェック\n\n**関連項目:** `alloc()`, `sizeof()`, `free()`\n\n---\n\n## FFIポインタヘルパー\n\nこれらの関数は、生メモリへの型付き値の読み書きを支援し、FFIや低レベルメモリ操作に有用です。\n\n### ptr_null\n\nヌルポインタを作成します。\n\n**シグネチャ:**\n```hemlock\nptr_null(): ptr\n```\n\n**戻り値:** ヌルポインタ\n\n**例:**\n```hemlock\nlet p = ptr_null();\nif (p == null) {\n    print(\"Pointer is null\");\n}\n```\n\n---\n\n### ptr_offset\n\nポインタオフセットを計算します（ポインタ演算）。\n\n**シグネチャ:**\n```hemlock\nptr_offset(ptr: ptr, index: i32, element_size: i32): ptr\n```\n\n**パラメータ:**\n- `ptr` - ベースポインタ\n- `index` - 要素インデックス\n- `element_size` - 各要素のバイト単位のサイズ\n\n**戻り値:** 指定されたインデックスの要素へのポインタ\n\n**例:**\n```hemlock\nlet arr = talloc(i32, 10);\nptr_write_i32(arr, 100);                      // arr[0] = 100\nptr_write_i32(ptr_offset(arr, 1, 4), 200);    // arr[1] = 200\nptr_write_i32(ptr_offset(arr, 2, 4), 300);    // arr[2] = 300\n\nprint(ptr_read_i32(ptr_offset(arr, 1, 4)));   // 200\nfree(arr);\n```\n\n---\n\n### ポインタ読み取り関数\n\nメモリから型付き値を読み取ります。\n\n| 関数 | シグネチャ | 戻り値 | 説明 |\n|----------|-----------|---------|-------------|\n| `ptr_read_i8` | `(ptr)` | `i8` | 符号付き8ビット整数を読み取り |\n| `ptr_read_i16` | `(ptr)` | `i16` | 符号付き16ビット整数を読み取り |\n| `ptr_read_i32` | `(ptr)` | `i32` | 符号付き32ビット整数を読み取り |\n| `ptr_read_i64` | `(ptr)` | `i64` | 符号付き64ビット整数を読み取り |\n| `ptr_read_u8` | `(ptr)` | `u8` | 符号なし8ビット整数を読み取り |\n| `ptr_read_u16` | `(ptr)` | `u16` | 符号なし16ビット整数を読み取り |\n| `ptr_read_u32` | `(ptr)` | `u32` | 符号なし32ビット整数を読み取り |\n| `ptr_read_u64` | `(ptr)` | `u64` | 符号なし64ビット整数を読み取り |\n| `ptr_read_f32` | `(ptr)` | `f32` | 32ビット浮動小数点数を読み取り |\n| `ptr_read_f64` | `(ptr)` | `f64` | 64ビット浮動小数点数を読み取り |\n| `ptr_read_ptr` | `(ptr)` | `ptr` | ポインタ値を読み取り |\n\n**例:**\n```hemlock\nlet p = alloc(8);\nptr_write_f64(p, 3.14159);\nlet value = ptr_read_f64(p);\nprint(value);  // 3.14159\nfree(p);\n```\n\n---\n\n### ポインタ書き込み関数\n\nメモリに型付き値を書き込みます。\n\n| 関数 | シグネチャ | 戻り値 | 説明 |\n|----------|-----------|---------|-------------|\n| `ptr_write_i8` | `(ptr, value)` | `null` | 符号付き8ビット整数を書き込み |\n| `ptr_write_i16` | `(ptr, value)` | `null` | 符号付き16ビット整数を書き込み |\n| `ptr_write_i32` | `(ptr, value)` | `null` | 符号付き32ビット整数を書き込み |\n| `ptr_write_i64` | `(ptr, value)` | `null` | 符号付き64ビット整数を書き込み |\n| `ptr_write_u8` | `(ptr, value)` | `null` | 符号なし8ビット整数を書き込み |\n| `ptr_write_u16` | `(ptr, value)` | `null` | 符号なし16ビット整数を書き込み |\n| `ptr_write_u32` | `(ptr, value)` | `null` | 符号なし32ビット整数を書き込み |\n| `ptr_write_u64` | `(ptr, value)` | `null` | 符号なし64ビット整数を書き込み |\n| `ptr_write_f32` | `(ptr, value)` | `null` | 32ビット浮動小数点数を書き込み |\n| `ptr_write_f64` | `(ptr, value)` | `null` | 64ビット浮動小数点数を書き込み |\n| `ptr_write_ptr` | `(ptr, value)` | `null` | ポインタ値を書き込み |\n\n**例:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\nprint(ptr_read_i32(p));  // 42\nfree(p);\n```\n\n---\n\n### バッファ/ポインタ変換\n\n#### buffer_ptr\n\nバッファから生ポインタを取得します。\n\n**シグネチャ:**\n```hemlock\nbuffer_ptr(buf: buffer): ptr\n```\n\n**例:**\n```hemlock\nlet buf = buffer(64);\nlet p = buffer_ptr(buf);\n// pはbufと同じメモリを指す\n```\n\n#### ptr_to_buffer\n\n生ポインタの周りにバッファラッパーを作成します。\n\n**シグネチャ:**\n```hemlock\nptr_to_buffer(ptr: ptr, size: i32): buffer\n```\n\n**例:**\n```hemlock\nlet p = alloc(64);\nlet buf = ptr_to_buffer(p, 64);\nbuf[0] = 65;  // 境界チェック付きになる\n// 注意: bufを解放すると基底のメモリも解放される\n```\n\n---\n\n## ファイルI/O関数\n\n完全なリファレンスについては[ファイルAPI](#reference-file-api)を参照:\n- `open(path, mode?)` - ファイルを開く\n\n---\n\n## 並行処理関数\n\n完全なリファレンスについては[並行処理API](#reference-concurrency-api)を参照:\n- `spawn(fn, args...)` - タスクを生成\n- `join(task)` - タスクを待機\n- `detach(task)` - タスクを切り離す\n- `channel(capacity)` - チャネルを作成\n\n### apply\n\n引数の配列で関数を動的に呼び出します。\n\n**シグネチャ:**\n```hemlock\napply(fn: function, args: array): any\n```\n\n**パラメータ:**\n- `fn` - 呼び出す関数\n- `args` - 関数に渡す引数の配列\n\n**戻り値:** 呼び出された関数の戻り値\n\n**例:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\n// 引数の配列で呼び出し\nlet result = apply(add, [2, 3]);\nprint(result);  // 5\n\n// 動的ディスパッチ\nlet operations = {\n    add: fn(a, b) { return a + b; },\n    mul: fn(a, b) { return a * b; },\n    sub: fn(a, b) { return a - b; }\n};\n\nfn calculate(op: string, args: array) {\n    return apply(operations[op], args);\n}\n\nprint(calculate(\"add\", [10, 5]));  // 15\nprint(calculate(\"mul\", [10, 5]));  // 50\nprint(calculate(\"sub\", [10, 5]));  // 5\n\n// 可変引数\nfn sum(...nums) {\n    let total = 0;\n    for (n in nums) {\n        total = total + n;\n    }\n    return total;\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(apply(sum, numbers));  // 15\n```\n\n**ユースケース:**\n- 実行時の値に基づく動的関数ディスパッチ\n- 可変引数リストでの関数呼び出し\n- 高階ユーティリティ（map、filterなど）の実装\n- プラグイン/拡張システム\n\n---\n\n### select\n\n複数のチャネルからのデータを待機し、いずれかがデータを持ったときに戻ります。\n\n**シグネチャ:**\n```hemlock\nselect(channels: array, timeout_ms?: i32): object | null\n```\n\n**パラメータ:**\n- `channels` - チャネル値の配列\n- `timeout_ms`（省略可能） - ミリ秒単位のタイムアウト（-1または省略で無限）\n\n**戻り値:**\n- `{ channel, value }` - データを持つチャネルと受信した値を含むオブジェクト\n- `null` - タイムアウト時\n\n**例:**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// プロデューサータスク\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"from channel 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"from channel 2\");\n});\n\n// 最初のメッセージを待機\nlet result = select([ch1, ch2]);\nprint(result.value);  // \"from channel 2\"（最初に到着）\n\n// タイムアウト付き\nlet result2 = select([ch1, ch2], 1000);  // 最大1秒待機\nif (result2 == null) {\n    print(\"Timeout - no data received\");\n} else {\n    print(\"Received:\", result2.value);\n}\n\n// 継続的なselectループ\nwhile (true) {\n    let msg = select([ch1, ch2], 5000);\n    if (msg == null) {\n        print(\"No activity for 5 seconds\");\n        break;\n    }\n    print(\"Got message:\", msg.value);\n}\n```\n\n**動作:**\n- チャネルがデータを持つかタイムアウトになるまでブロック\n- チャネルが既にデータを持っている場合は即座に戻る\n- チャネルが閉じられて空の場合、`{ channel, value: null }`を返す\n- チャネルを順番にポーリング（最初に準備完了したチャネルが勝つ）\n\n**ユースケース:**\n- 複数のプロデューサーの多重化\n- チャネル操作でのタイムアウトの実装\n- 複数のソースを持つイベントループの構築\n\n---\n\n## まとめ表\n\n### 関数\n\n| 関数       | カテゴリ        | 戻り値       | 説明                            |\n|------------|-----------------|--------------|----------------------------------|\n| `print`    | I/O             | `null`       | 標準出力に出力                   |\n| `read_line`| I/O             | `string?`    | 標準入力から行を読み取り         |\n| `eprint`   | I/O             | `null`       | 標準エラー出力に出力             |\n| `typeof`   | 型              | `string`     | 型名を取得                       |\n| `exec`     | コマンド        | `object`     | シェルコマンドを実行             |\n| `exec_argv`| コマンド        | `object`     | 引数配列で実行                   |\n| `assert`   | エラー          | `null`       | 条件をアサートまたは終了         |\n| `panic`    | エラー          | `never`      | 回復不能エラー（終了）           |\n| `signal`   | シグナル        | `function?`  | シグナルハンドラを登録           |\n| `raise`    | シグナル        | `null`       | プロセスにシグナルを送信         |\n| `alloc`    | メモリ          | `ptr`        | 生メモリを確保                   |\n| `talloc`   | メモリ          | `ptr`        | 型付き確保                       |\n| `sizeof`   | メモリ          | `i32`        | 型サイズをバイトで取得           |\n| `free`     | メモリ          | `null`       | メモリを解放                     |\n| `buffer`   | メモリ          | `buffer`     | 安全なバッファを確保             |\n| `memset`   | メモリ          | `null`       | メモリを埋める                   |\n| `memcpy`   | メモリ          | `null`       | メモリをコピー                   |\n| `realloc`  | メモリ          | `ptr`        | 確保サイズを変更                 |\n| `open`     | ファイルI/O     | `file`       | ファイルを開く                   |\n| `spawn`    | 並行処理        | `task`       | 並行タスクを生成                 |\n| `join`     | 並行処理        | `any`        | タスク結果を待機                 |\n| `detach`   | 並行処理        | `null`       | タスクを切り離す                 |\n| `channel`  | 並行処理        | `channel`    | 通信チャネルを作成               |\n| `select`   | 並行処理        | `object?`    | 複数チャネルで待機               |\n| `apply`    | 関数            | `any`        | 引数配列で関数を呼び出し         |\n\n### グローバル変数\n\n| 変数       | 型       | 説明                              |\n|------------|----------|-----------------------------------|\n| `args`     | `array`  | コマンドライン引数                |\n\n### 定数\n\n| 定数       | 型    | カテゴリ | 値    | 説明                      |\n|------------|-------|----------|-------|---------------------------|\n| `SIGINT`   | `i32` | シグナル | 2     | キーボード割り込み        |\n| `SIGTERM`  | `i32` | シグナル | 15    | 終了要求                  |\n| `SIGQUIT`  | `i32` | シグナル | 3     | キーボード終了            |\n| `SIGHUP`   | `i32` | シグナル | 1     | ハングアップ              |\n| `SIGABRT`  | `i32` | シグナル | 6     | 中止                      |\n| `SIGUSR1`  | `i32` | シグナル | 10    | ユーザー定義1             |\n| `SIGUSR2`  | `i32` | シグナル | 12    | ユーザー定義2             |\n| `SIGALRM`  | `i32` | シグナル | 14    | アラームタイマー          |\n| `SIGCHLD`  | `i32` | シグナル | 17    | 子ステータス変更          |\n| `SIGCONT`  | `i32` | シグナル | 18    | 続行                      |\n| `SIGSTOP`  | `i32` | シグナル | 19    | 停止（キャッチ不可）      |\n| `SIGTSTP`  | `i32` | シグナル | 20    | 端末停止                  |\n| `SIGPIPE`  | `i32` | シグナル | 13    | 壊れたパイプ              |\n| `SIGTTIN`  | `i32` | シグナル | 21    | バックグラウンド端末読取  |\n| `SIGTTOU`  | `i32` | シグナル | 22    | バックグラウンド端末書込  |\n\n---\n\n## 関連項目\n\n- [型システム](#reference-type-system) - 型と変換\n- [メモリAPI](#reference-memory-api) - メモリ確保関数\n- [ファイルAPI](#reference-file-api) - ファイルI/O関数\n- [並行処理API](#reference-concurrency-api) - 非同期/並行処理関数\n- [文字列API](#reference-string-api) - 文字列メソッド\n- [配列API](#reference-array-api) - 配列メソッド\n"}, "APIリファレンス -> 配列API": {"id": "reference-array-api", "content": "# 配列APIリファレンス\n\nHemlockの配列型と全18個の配列メソッドの完全なリファレンスです。\n\n---\n\n## 概要\n\nHemlockの配列は**動的でヒープ割り当て**されるシーケンスであり、混合型を保持できます。データ操作と処理のための包括的なメソッドを提供します。\n\n**主な機能：**\n- 動的サイズ（自動拡張）\n- ゼロインデックス\n- 混合型を許可\n- 18個の組み込みメソッド\n- 容量追跡付きヒープ割り当て\n\n---\n\n## 配列型\n\n**型：** `array`\n\n**プロパティ：**\n- `.length` - 要素数（i32）\n\n**リテラル構文：** 角括弧 `[elem1, elem2, ...]`\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);     // 5\n\n// 混合型\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.length);   // 4\n\n// 空配列\nlet empty = [];\nprint(empty.length);   // 0\n```\n\n---\n\n## インデックス\n\n配列は`[]`を使用したゼロベースのインデックスをサポートします：\n\n**読み取りアクセス：**\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);         // 10\nprint(arr[1]);         // 20\nprint(arr[2]);         // 30\n```\n\n**書き込みアクセス：**\n```hemlock\nlet arr = [10, 20, 30];\narr[0] = 99;\narr[1] = 88;\nprint(arr);            // [99, 88, 30]\n```\n\n**注意：** 直接インデックスには境界チェックがありません。安全のためにはメソッドを使用してください。\n\n---\n\n## 配列プロパティ\n\n### .length\n\n配列の要素数を取得します。\n\n**型：** `i32`\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr.length);     // 3\n\nlet empty = [];\nprint(empty.length);   // 0\n\n// 長さは動的に変化\narr.push(4);\nprint(arr.length);     // 4\n\narr.pop();\nprint(arr.length);     // 3\n```\n\n---\n\n## 配列メソッド\n\n### スタック操作\n\n#### push\n\n配列の末尾に要素を追加します。\n\n**シグネチャ：**\n```hemlock\narray.push(value: any): null\n```\n\n**パラメータ：**\n- `value` - 追加する要素\n\n**戻り値：** `null`\n\n**変更：** はい（配列をその場で変更）\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\narr.push(\"hello\");     // [1, 2, 3, 4, 5, \"hello\"]\n```\n\n---\n\n#### pop\n\n最後の要素を削除して返します。\n\n**シグネチャ：**\n```hemlock\narray.pop(): any\n```\n\n**戻り値：** 最後の要素（配列から削除される）\n\n**変更：** はい（配列をその場で変更）\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3];\nlet last = arr.pop();  // 3\nprint(arr);            // [1, 2]\n\nlet last2 = arr.pop(); // 2\nprint(arr);            // [1]\n```\n\n**エラー：** 配列が空の場合は実行時エラー。\n\n---\n\n### キュー操作\n\n#### shift\n\n最初の要素を削除して返します。\n\n**シグネチャ：**\n```hemlock\narray.shift(): any\n```\n\n**戻り値：** 最初の要素（配列から削除される）\n\n**変更：** はい（配列をその場で変更）\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();  // 1\nprint(arr);               // [2, 3]\n\nlet first2 = arr.shift(); // 2\nprint(arr);               // [3]\n```\n\n**エラー：** 配列が空の場合は実行時エラー。\n\n---\n\n#### unshift\n\n配列の先頭に要素を追加します。\n\n**シグネチャ：**\n```hemlock\narray.unshift(value: any): null\n```\n\n**パラメータ：**\n- `value` - 追加する要素\n\n**戻り値：** `null`\n\n**変更：** はい（配列をその場で変更）\n\n**例：**\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);        // [1, 2, 3]\narr.unshift(0);        // [0, 1, 2, 3]\n```\n\n---\n\n### 挿入と削除\n\n#### insert\n\n特定のインデックスに要素を挿入します。\n\n**シグネチャ：**\n```hemlock\narray.insert(index: i32, value: any): null\n```\n\n**パラメータ：**\n- `index` - 挿入する位置（0ベース）\n- `value` - 挿入する要素\n\n**戻り値：** `null`\n\n**変更：** はい（配列をその場で変更）\n\n**例：**\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // [1, 2, 3, 4, 5]\n\nlet arr2 = [1, 3];\narr2.insert(1, 2);     // [1, 2, 3]\n\n// 末尾に挿入\narr2.insert(arr2.length, 4);  // [1, 2, 3, 4]\n```\n\n**動作：** インデックス以降の要素を右にシフトします。\n\n---\n\n#### remove\n\nインデックスの要素を削除して返します。\n\n**シグネチャ：**\n```hemlock\narray.remove(index: i32): any\n```\n\n**パラメータ：**\n- `index` - 削除する位置（0ベース）\n\n**戻り値：** 削除された要素\n\n**変更：** はい（配列をその場で変更）\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(0);  // 1\nprint(arr);                   // [2, 3, 4, 5]\n\nlet removed2 = arr.remove(2); // 4\nprint(arr);                   // [2, 3, 5]\n```\n\n**動作：** インデックス以降の要素を左にシフトします。\n\n**エラー：** インデックスが範囲外の場合は実行時エラー。\n\n---\n\n### 検索と検出\n\n#### find\n\n値の最初の出現位置を見つけます。\n\n**シグネチャ：**\n```hemlock\narray.find(value: any): i32\n```\n\n**パラメータ：**\n- `value` - 検索する値\n\n**戻り値：** 最初の出現のインデックス、見つからない場合は`-1`\n\n**例：**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2\nlet idx2 = arr.find(99);     // -1（見つからない）\n\n// 最初の重複を見つける\nlet arr2 = [1, 2, 3, 2, 4];\nlet idx3 = arr2.find(2);     // 1（最初の出現）\n```\n\n**比較：** プリミティブと文字列には値の等価性を使用します。\n\n---\n\n#### contains\n\n配列が値を含むかチェックします。\n\n**シグネチャ：**\n```hemlock\narray.contains(value: any): bool\n```\n\n**パラメータ：**\n- `value` - 検索する値\n\n**戻り値：** 見つかった場合は`true`、それ以外は`false`\n\n**例：**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n\n// 文字列でも動作\nlet words = [\"hello\", \"world\"];\nlet has3 = words.contains(\"hello\");  // true\n```\n\n---\n\n### スライスと抽出\n\n#### slice\n\n範囲で部分配列を抽出します（終了は含まない）。\n\n**シグネチャ：**\n```hemlock\narray.slice(start: i32, end: i32): array\n```\n\n**パラメータ：**\n- `start` - 開始インデックス（0ベース、含む）\n- `end` - 終了インデックス（含まない）\n\n**戻り値：** [start, end)の要素を含む新しい配列\n\n**変更：** なし（新しい配列を返す）\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4]\nlet first_three = arr.slice(0, 3);  // [1, 2, 3]\nlet last_two = arr.slice(3, 5);     // [4, 5]\n\n// 空のスライス\nlet empty = arr.slice(2, 2); // []\n```\n\n---\n\n#### first\n\n最初の要素を削除せずに取得します。\n\n**シグネチャ：**\n```hemlock\narray.first(): any\n```\n\n**戻り値：** 最初の要素\n\n**変更：** なし\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1\nprint(arr);                  // [1, 2, 3]（変更なし）\n```\n\n**エラー：** 配列が空の場合は実行時エラー。\n\n---\n\n#### last\n\n最後の要素を削除せずに取得します。\n\n**シグネチャ：**\n```hemlock\narray.last(): any\n```\n\n**戻り値：** 最後の要素\n\n**変更：** なし\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3\nprint(arr);                  // [1, 2, 3]（変更なし）\n```\n\n**エラー：** 配列が空の場合は実行時エラー。\n\n---\n\n### 配列操作\n\n#### reverse\n\n配列をその場で反転します。\n\n**シグネチャ：**\n```hemlock\narray.reverse(): null\n```\n\n**戻り値：** `null`\n\n**変更：** はい（配列をその場で変更）\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\nprint(arr);                  // [5, 4, 3, 2, 1]\n\nlet words = [\"hello\", \"world\"];\nwords.reverse();             // [\"world\", \"hello\"]\n```\n\n---\n\n#### clear\n\n配列からすべての要素を削除します。\n\n**シグネチャ：**\n```hemlock\narray.clear(): null\n```\n\n**戻り値：** `null`\n\n**変更：** はい（配列をその場で変更）\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();\nprint(arr);                  // []\nprint(arr.length);           // 0\n```\n\n---\n\n### 配列結合\n\n#### concat\n\n別の配列と連結します。\n\n**シグネチャ：**\n```hemlock\narray.concat(other: array): array\n```\n\n**パラメータ：**\n- `other` - 連結する配列\n\n**戻り値：** 両方の配列の要素を含む新しい配列\n\n**変更：** なし（新しい配列を返す）\n\n**例：**\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]\nprint(a);                    // [1, 2, 3]（変更なし）\nprint(b);                    // [4, 5, 6]（変更なし）\n\n// 連結のチェーン\nlet c = [7, 8];\nlet all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n---\n\n### 関数型操作\n\n#### map\n\nコールバック関数を使用して各要素を変換します。\n\n**シグネチャ：**\n```hemlock\narray.map(callback: fn): array\n```\n\n**パラメータ：**\n- `callback` - 要素を受け取り変換された値を返す関数\n\n**戻り値：** 変換された要素を含む新しい配列\n\n**変更：** なし（新しい配列を返す）\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet doubled = arr.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\nlet names = [\"alice\", \"bob\"];\nlet upper = names.map(fn(s) { return s.to_upper(); });\nprint(upper);  // [\"ALICE\", \"BOB\"]\n```\n\n---\n\n#### filter\n\n述語に一致する要素を選択します。\n\n**シグネチャ：**\n```hemlock\narray.filter(predicate: fn): array\n```\n\n**パラメータ：**\n- `predicate` - 要素を受け取りboolを返す関数\n\n**戻り値：** 述語がtrueを返した要素を含む新しい配列\n\n**変更：** なし（新しい配列を返す）\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6];\nlet evens = arr.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4, 6]\n\nlet words = [\"hello\", \"hi\", \"hey\", \"goodbye\"];\nlet short = words.filter(fn(s) { return s.length < 4; });\nprint(short);  // [\"hi\", \"hey\"]\n```\n\n---\n\n#### reduce\n\nアキュムレータを使用して配列を単一の値に削減します。\n\n**シグネチャ：**\n```hemlock\narray.reduce(callback: fn, initial: any): any\n```\n\n**パラメータ：**\n- `callback` - (アキュムレータ, 要素)を受け取り新しいアキュムレータを返す関数\n- `initial` - アキュムレータの初期値\n\n**戻り値：** 最終的な累積値\n\n**変更：** なし\n\n**例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sum = arr.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\nlet product = arr.reduce(fn(acc, x) { return acc * x; }, 1);\nprint(product);  // 120\n\n// 最大値を見つける\nlet max = arr.reduce(fn(acc, x) {\n    if (x > acc) { return x; }\n    return acc;\n}, arr[0]);\nprint(max);  // 5\n```\n\n---\n\n### 文字列変換\n\n#### join\n\n区切り文字で要素を文字列に結合します。\n\n**シグネチャ：**\n```hemlock\narray.join(delimiter: string): string\n```\n\n**パラメータ：**\n- `delimiter` - 要素間に配置する文字列\n\n**戻り値：** すべての要素を結合した文字列\n\n**例：**\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// 混合型でも動作\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n\n// 空の区切り文字\nlet arr = [\"a\", \"b\", \"c\"];\nlet s = arr.join(\"\");          // \"abc\"\n```\n\n**動作：** すべての要素を自動的に文字列に変換します。\n\n---\n\n## メソッドチェーン\n\n配列メソッドは簡潔な操作のためにチェーンできます：\n\n**例：**\n```hemlock\n// sliceとjoinをチェーン\nlet result = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\n// concatとsliceをチェーン\nlet combined = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);    // [3, 4, 5]\n\n// 複雑なチェーン\nlet words = [\"hello\", \"world\", \"foo\", \"bar\"];\nlet result2 = words\n    .slice(0, 3)\n    .concat([\"baz\"])\n    .join(\"-\");      // \"hello-world-foo-baz\"\n```\n\n---\n\n## 完全なメソッド要約\n\n### 変更メソッド\n\n配列をその場で変更するメソッド：\n\n| メソッド | シグネチャ | 戻り値 | 説明 |\n|----------|--------------------------|-----------|--------------------------------|\n| `push`     | `(value: any)`             | `null`    | 末尾に追加 |\n| `pop`      | `()`                       | `any`     | 末尾から削除 |\n| `shift`    | `()`                       | `any`     | 先頭から削除 |\n| `unshift`  | `(value: any)`             | `null`    | 先頭に追加 |\n| `insert`   | `(index: i32, value: any)` | `null`    | インデックスに挿入 |\n| `remove`   | `(index: i32)`             | `any`     | インデックスから削除 |\n| `reverse`  | `()`                       | `null`    | その場で反転 |\n| `clear`    | `()`                       | `null`    | すべての要素を削除 |\n\n### 非変更メソッド\n\n元の配列を変更せずに新しい値を返すメソッド：\n\n| メソッド | シグネチャ | 戻り値 | 説明 |\n|----------|--------------------------|-----------|--------------------------------|\n| `find`     | `(value: any)`             | `i32`     | 最初の出現を見つける |\n| `contains` | `(value: any)`             | `bool`    | 値を含むかチェック |\n| `slice`    | `(start: i32, end: i32)`   | `array`   | 部分配列を抽出 |\n| `first`    | `()`                       | `any`     | 最初の要素を取得 |\n| `last`     | `()`                       | `any`     | 最後の要素を取得 |\n| `concat`   | `(other: array)`           | `array`   | 配列を連結 |\n| `join`     | `(delimiter: string)`      | `string`  | 要素を文字列に結合 |\n| `map`      | `(callback: fn)`           | `array`   | 各要素を変換 |\n| `filter`   | `(predicate: fn)`          | `array`   | 一致する要素を選択 |\n| `reduce`   | `(callback: fn, initial: any)` | `any` | 単一の値に削減 |\n\n---\n\n## 使用パターン\n\n### スタック使用\n\n```hemlock\nlet stack = [];\n\n// 要素をプッシュ\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// 要素をポップ\nwhile (stack.length > 0) {\n    let item = stack.pop();\n    print(item);  // 3, 2, 1\n}\n```\n\n### キュー使用\n\n```hemlock\nlet queue = [];\n\n// エンキュー\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// デキュー\nwhile (queue.length > 0) {\n    let item = queue.shift();\n    print(item);  // 1, 2, 3\n}\n```\n\n### 配列変換\n\n```hemlock\n// フィルタ（手動）\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = [];\nlet i = 0;\nwhile (i < numbers.length) {\n    if (numbers[i] % 2 == 0) {\n        evens.push(numbers[i]);\n    }\n    i = i + 1;\n}\n\n// マップ（手動）\nlet numbers2 = [1, 2, 3, 4, 5];\nlet doubled = [];\nlet j = 0;\nwhile (j < numbers2.length) {\n    doubled.push(numbers2[j] * 2);\n    j = j + 1;\n}\n```\n\n### 配列の構築\n\n```hemlock\nlet arr = [];\n\n// ループで配列を構築\nlet i = 0;\nwhile (i < 10) {\n    arr.push(i * 10);\n    i = i + 1;\n}\n\nprint(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n```\n\n---\n\n## 実装の詳細\n\n**容量管理：**\n- 配列は必要に応じて自動的に拡張\n- 容量は超過時に2倍になる\n- 手動の容量制御なし\n\n**値の比較：**\n- `find()`と`contains()`は値の等価性を使用\n- プリミティブと文字列で正しく動作\n- オブジェクト/配列は参照で比較\n\n**メモリ：**\n- ヒープ割り当て\n- 自動解放なし（手動メモリ管理）\n- 直接インデックスアクセスには境界チェックなし\n\n---\n\n## 関連項目\n\n- [型システム](#reference-type-system) - 配列型の詳細\n- [文字列API](#reference-string-api) - 文字列join()の結果\n- [演算子](#reference-operators) - 配列インデックス演算子\n"}, "設計と思想 -> シグネチャ構文": {"id": "design-signature-syntax", "content": "# シグネチャ構文設計\n\n> Hemlockの型システムを関数型、nullable修飾子、型エイリアス、constパラメータ、メソッドシグネチャで拡張する。\n\n**ステータス:** 実装済み (v1.7.0)\n**バージョン:** 1.0\n**著者:** Claude\n\n---\n\n## 概要\n\nこのドキュメントでは、Hemlockの既存インフラストラクチャに基づいて構築する5つの相互接続された型システム拡張を提案します:\n\n1. **関数型注釈** - ファーストクラスの関数型\n2. **Nullable型修飾子** - 明示的なnull処理（既存の`nullable`フラグを拡張）\n3. **型エイリアス** - 名前付き型の省略形\n4. **Constパラメータ** - 不変性契約\n5. **Defineでのメソッドシグネチャ** - インターフェースのような動作\n\nこれらの機能は以下の哲学を共有します: **暗黙より明示、オプションだが使用時は強制**。\n\n---\n\n## 1. 関数型注釈\n\n### 動機\n\n現在、関数のシグネチャを型として表現する方法がありません:\n\n```hemlock\n// 現在: callbackには型情報がない\nfn map(arr: array, callback) { ... }\n\n// 提案: 明示的な関数型\nfn map(arr: array, callback: fn(any, i32): any): array { ... }\n```\n\n### 構文\n\n```hemlock\n// 基本的な関数型\nfn(i32, i32): i32\n\n// パラメータ名付き（ドキュメント用のみ、強制されない）\nfn(a: i32, b: i32): i32\n\n// 戻り値なし (void)\nfn(string): void\nfn(string)              // 省略形: `: void`を省略\n\n// Nullable戻り値\nfn(i32): string?\n\n// オプションパラメータ\nfn(name: string, age?: i32): void\n\n// 残余パラメータ\nfn(...args: array): i32\n\n// パラメータなし\nfn(): bool\n\n// 高階: 関数を返す関数\nfn(i32): fn(i32): i32\n\n// 非同期関数型\nasync fn(i32): i32\n```\n\n### 使用例\n\n```hemlock\n// 関数型を持つ変数\nlet add: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// 関数パラメータ\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// 戻り値型が関数\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// 関数の配列\nlet ops: array<fn(i32, i32): i32> = [add, subtract, multiply];\n\n// オブジェクトフィールド\ndefine EventHandler {\n    name: string;\n    callback: fn(Event): void;\n}\n```\n\n### AST変更\n\n```c\n// TypeKind列挙型 (include/ast.h)\ntypedef enum {\n    // ... 既存の型 ...\n    TYPE_FUNCTION,      // 新規: 関数型\n} TypeKind;\n\n// Type構造体 (include/ast.h)\nstruct Type {\n    TypeKind kind;\n    // ... 既存のフィールド ...\n\n    // TYPE_FUNCTION用:\n    struct Type **param_types;      // パラメータ型\n    char **param_names;             // オプションのパラメータ名（ドキュメント用）\n    int *param_optional;            // どのパラメータがオプションか\n    int num_params;\n    char *rest_param_name;          // 残余パラメータ名またはNULL\n    struct Type *rest_param_type;   // 残余パラメータ型\n    struct Type *return_type;       // 戻り値型（NULL = void）\n    int is_async;                   // 非同期関数型\n};\n```\n\n### パース\n\n関数型は`fn`（または`async fn`）の後にパラメータリストで始まります:\n\n```\nfunction_type := [\"async\"] \"fn\" \"(\" [param_type_list] \")\" [\":\" type]\nparam_type_list := param_type (\",\" param_type)*\nparam_type := [identifier \":\"] [\"?\"] type | \"...\" [identifier] [\":\" type]\n```\n\n**曖昧さの解消:** 型をパース中に`fn`に遭遇した場合:\n- `(`が続く場合、関数型\n- そうでなければ、構文エラー（単独の`fn`は有効な型ではない）\n\n### 型互換性\n\n```hemlock\n// 関数型には厳密な一致が必要\nlet f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // OK\n\n// パラメータの反変性（より広い型を受け入れるのはOK）\nlet g: fn(any): i32 = fn(x: i32): i32 { return x; };  // OK: i32 <: any\n\n// 戻り値の共変性（より狭い型を返すのはOK）\nlet h: fn(i32): any = fn(x: i32): i32 { return x; };  // OK: i32 <: any\n\n// アリティは一致する必要がある\nlet bad: fn(i32): i32 = fn(a, b) { return a; };       // エラー: アリティ不一致\n\n// オプションパラメータは必須と互換\nlet opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // OK\n```\n\n---\n\n## 2. Nullable型修飾子\n\n### 動機\n\n`?`サフィックスにより、シグネチャでのnull受け入れを明示的にします:\n\n```hemlock\n// 現在: nullが有効かどうか不明\nfn find(arr: array, val: any): i32 { ... }\n\n// 提案: 明示的なnullable戻り値\nfn find(arr: array, val: any): i32? { ... }\n```\n\n### 構文\n\n```hemlock\n// ?サフィックス付きNullable型\nstring?           // stringまたはnull\ni32?              // i32またはnull\nUser?             // Userまたはnull\narray<i32>?       // arrayまたはnull\nfn(i32): i32?     // i32またはnullを返す関数\n\n// 関数型との組み合わせ\nfn(string?): i32          // stringまたはnullを受け入れる\nfn(string): i32?          // i32またはnullを返す\nfn(string?): i32?         // 両方nullable\n\n// defineでの使用\ndefine Result {\n    value: any?;\n    error: string?;\n}\n```\n\n### 実装上の注意\n\n**既に存在:** `Type.nullable`フラグは既にASTにあります。この機能は主に以下が必要:\n1. 任意の型での`?`サフィックスのパーサーサポート（検証/拡張）\n2. 関数型との適切な組み合わせ\n3. ランタイム強制\n\n### 型互換性\n\n```hemlock\n// 非nullableはnullableに代入可能\nlet x: i32? = 42;           // OK\nlet y: i32? = null;         // OK\n\n// nullableは非nullableに代入不可\nlet z: i32 = x;             // エラー: xはnullかもしれない\n\n// null合体でアンラップ\nlet z: i32 = x ?? 0;        // OK: ??がデフォルトを提供\n\n// セーフナビゲーションはnullableを返す\nlet name: string? = user?.name;\n```\n\n---\n\n## 3. 型エイリアス\n\n### 動機\n\n複雑な型は名前付きの省略形から恩恵を受けます:\n\n```hemlock\n// 現在: 繰り返しの複合型\nfn process(entity: HasName & HasId & HasTimestamp) { ... }\nfn validate(entity: HasName & HasId & HasTimestamp) { ... }\n\n// 提案: 名前付きエイリアス\ntype Entity = HasName & HasId & HasTimestamp;\nfn process(entity: Entity) { ... }\nfn validate(entity: Entity) { ... }\n```\n\n### 構文\n\n```hemlock\n// 基本エイリアス\ntype Integer = i32;\ntype Text = string;\n\n// 複合型エイリアス\ntype Entity = HasName & HasId;\ntype Auditable = HasCreatedAt & HasUpdatedAt & HasCreatedBy;\n\n// 関数型エイリアス\ntype Callback = fn(Event): void;\ntype Predicate = fn(any): bool;\ntype Reducer = fn(acc: any, val: any): any;\ntype AsyncTask = async fn(): any;\n\n// Nullableエイリアス\ntype OptionalString = string?;\n\n// ジェネリックエイリアス（ジェネリック型エイリアスをサポートする場合）\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// 配列型エイリアス\ntype IntArray = array<i32>;\ntype Matrix = array<array<f64>>;\n```\n\n### スコープと可視性\n\n```hemlock\n// デフォルトでモジュールスコープ\ntype Callback = fn(Event): void;\n\n// エクスポート可能\nexport type Handler = fn(Request): Response;\n\n// 別のファイルで\nimport { Handler } from \"./handlers.hml\";\nfn register(h: Handler) { ... }\n```\n\n### AST変更\n\n```c\n// 新しい文の種類\ntypedef enum {\n    // ... 既存の文 ...\n    STMT_TYPE_ALIAS,    // 新規\n} StmtKind;\n\n// Stmtユニオン内\nstruct {\n    char *name;                 // エイリアス名\n    char **type_params;         // ジェネリックパラメータ: <T, U>\n    int num_type_params;\n    Type *aliased_type;         // 実際の型\n} type_alias;\n```\n\n### パース\n\n```\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n```\n\n**注:** `type`は新しいキーワードです。既存の識別子との競合をチェックしてください。\n\n### 解決\n\n型エイリアスは以下のタイミングで解決されます:\n- **パース時:** エイリアスが型環境に記録される\n- **チェック時:** エイリアスが基礎となる型に展開される\n- **ランタイム:** エイリアスは透過的（基礎型と同じ）\n\n```hemlock\ntype MyInt = i32;\nlet x: MyInt = 42;\ntypeof(x);           // \"i32\"（\"MyInt\"ではない）\n```\n\n---\n\n## 4. Constパラメータ\n\n### 動機\n\n関数シグネチャで不変性の意図を示します:\n\n```hemlock\n// 現在: 配列が変更されるかどうか不明\nfn print_all(items: array) { ... }\n\n// 提案: 明示的な不変性契約\nfn print_all(const items: array) { ... }\n```\n\n### 構文\n\n```hemlock\n// Constパラメータ\nfn process(const data: buffer) {\n    // data[0] = 0;        // エラー: constを変更できない\n    let x = data[0];       // OK: 読み取りは許可\n    return x;\n}\n\n// 複数のconstパラメータ\nfn compare(const a: array, const b: array): bool { ... }\n\n// constとmutableの混在\nfn update(const source: array, target: array) {\n    for (item in source) {\n        target.push(item);   // OK: targetは変更可能\n    }\n}\n\n// 型推論付きconst\nfn log(const msg) {\n    print(msg);\n}\n\n// 関数型でのconst\ntype Reader = fn(const buffer): i32;\n```\n\n### Constが防ぐもの\n\n```hemlock\nfn bad(const arr: array) {\n    arr.push(1);         // エラー: 変更メソッド\n    arr.pop();           // エラー: 変更メソッド\n    arr[0] = 5;          // エラー: インデックス代入\n    arr.clear();         // エラー: 変更メソッド\n}\n\nfn ok(const arr: array) {\n    let x = arr[0];      // OK: 読み取り\n    let len = len(arr);  // OK: 長さチェック\n    let copy = arr.slice(0, 10);  // OK: 新しい配列を作成\n    for (item in arr) {  // OK: イテレーション\n        print(item);\n    }\n}\n```\n\n### 変更 vs 非変更メソッド\n\n| 型 | 変更（constでブロック） | 非変更（許可） |\n|------|----------------------------|------------------------|\n| array | push, pop, shift, unshift, insert, remove, clear, reverse (in-place) | slice, concat, map, filter, find, contains, first, last, join |\n| string | インデックス代入 (`s[0] = 'x'`) | すべてのメソッド（新しい文字列を返す） |\n| buffer | インデックス代入, memset, memcpy (to) | インデックス読み取り, slice |\n| object | フィールド代入 | フィールド読み取り |\n\n### AST変更\n\n```c\n// 関数式内 (include/ast.h)\nstruct {\n    // ... 既存のフィールド ...\n    int *param_is_const;    // 新規: constなら1、そうでなければ0\n} function;\n\n// 関数型用のType構造体内\nstruct Type {\n    // ... 既存のフィールド ...\n    int *param_is_const;    // TYPE_FUNCTION用\n};\n```\n\n### 強制\n\n**インタプリタ:**\n- 変数バインディングでconst性を追跡\n- 変更操作前にチェック\n- const違反でランタイムエラー\n\n**コンパイラ:**\n- 有益な場合はconstで修飾されたC変数を生成\n- const違反の静的解析\n- コンパイル時の警告/エラー\n\n---\n\n## 5. Defineでのメソッドシグネチャ\n\n### 動機\n\n`define`ブロックでデータフィールドだけでなく、期待されるメソッドを指定できるようにします:\n\n```hemlock\n// 現在: データフィールドのみ\ndefine User {\n    name: string;\n    age: i32;\n}\n\n// 提案: メソッドシグネチャ\ndefine Comparable {\n    fn compare(other: Self): i32;\n}\n\ndefine Serializable {\n    fn serialize(): string;\n    fn deserialize(data: string): Self;  // 静的メソッド\n}\n```\n\n### 構文\n\n```hemlock\n// メソッドシグネチャ（本体なし）\ndefine Hashable {\n    fn hash(): i32;\n}\n\n// 複数のメソッド\ndefine Collection {\n    fn size(): i32;\n    fn is_empty(): bool;\n    fn contains(item: any): bool;\n}\n\n// フィールドとメソッドの混在\ndefine Entity {\n    id: i32;\n    name: string;\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\n// Self型の使用\ndefine Cloneable {\n    fn clone(): Self;\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;\n    fn equals(other: Self): bool;\n}\n\n// オプションメソッド\ndefine Printable {\n    fn to_string(): string;\n    fn debug_string?(): string;  // オプションメソッド（存在しない可能性あり）\n}\n\n// デフォルト実装付きメソッド\ndefine Ordered {\n    fn compare(other: Self): i32;  // 必須\n\n    // デフォルト実装（オーバーライドされなければ継承）\n    fn less_than(other: Self): bool {\n        return self.compare(other) < 0;\n    }\n    fn greater_than(other: Self): bool {\n        return self.compare(other) > 0;\n    }\n    fn equals(other: Self): bool {\n        return self.compare(other) == 0;\n    }\n}\n```\n\n### `Self`型\n\n`Self`はインターフェースを実装する具象型を参照します:\n\n```hemlock\ndefine Addable {\n    fn add(other: Self): Self;\n}\n\n// 使用時:\nlet a: Addable = {\n    value: 10,\n    add: fn(other) {\n        return { value: self.value + other.value, add: self.add };\n    }\n};\n```\n\n### 構造的型付け（ダックタイピング）\n\nメソッドシグネチャはフィールドと同じダックタイピングを使用します:\n\n```hemlock\ndefine Stringifiable {\n    fn to_string(): string;\n}\n\n// to_string()メソッドを持つ任意のオブジェクトはStringifiableを満たす\nlet x: Stringifiable = {\n    name: \"test\",\n    to_string: fn() { return self.name; }\n};\n\n// メソッド付き複合型\ndefine Named { name: string; }\ndefine Printable { fn to_string(): string; }\n\ntype NamedPrintable = Named & Printable;\n\nlet y: NamedPrintable = {\n    name: \"Alice\",\n    to_string: fn() { return \"Name: \" + self.name; }\n};\n```\n\n### AST変更\n\n```c\n// Stmtユニオン内のdefine_objectを拡張\nstruct {\n    char *name;\n    char **type_params;\n    int num_type_params;\n\n    // フィールド（既存）\n    char **field_names;\n    Type **field_types;\n    int *field_optional;\n    Expr **field_defaults;\n    int num_fields;\n\n    // メソッド（新規）\n    char **method_names;\n    Type **method_types;        // TYPE_FUNCTION\n    int *method_optional;       // オプションメソッド (fn name?(): type)\n    Expr **method_defaults;     // デフォルト実装（シグネチャのみの場合NULL）\n    int num_methods;\n} define_object;\n```\n\n### 型チェック\n\n`value: InterfaceType`をチェックする際:\n1. すべての必須フィールドが互換型で存在するかチェック\n2. すべての必須メソッドが互換シグネチャで存在するかチェック\n3. オプションフィールド/メソッドは不在でも可\n\n```hemlock\ndefine Sortable {\n    fn compare(other: Self): i32;\n}\n\n// 有効: compareメソッドを持つ\nlet valid: Sortable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// 無効: compareがない\nlet invalid: Sortable = { value: 10 };  // エラー: メソッド 'compare' がない\n\n// 無効: 間違ったシグネチャ\nlet wrong: Sortable = {\n    compare: fn() { return 0; }  // エラー: (Self): i32が期待される\n};\n```\n\n---\n\n## 相互作用の例\n\n### すべての機能を組み合わせる\n\n```hemlock\n// 複雑な関数型の型エイリアス\ntype EventCallback = fn(event: Event, context: Context?): bool;\n\n// 複合インターフェースの型エイリアス\ntype Entity = HasId & HasName & Serializable;\n\n// メソッドシグネチャ付きdefine\ndefine Repository<T> {\n    fn find(id: i32): T?;\n    fn save(const entity: T): bool;\n    fn delete(id: i32): bool;\n    fn find_all(predicate: fn(T): bool): array<T>;\n}\n\n// すべてを一緒に使用\nfn create_user_repo(): Repository<User> {\n    let users: array<User> = [];\n\n    return {\n        find: fn(id) {\n            for (u in users) {\n                if (u.id == id) { return u; }\n            }\n            return null;\n        },\n        save: fn(const entity) {\n            users.push(entity);\n            return true;\n        },\n        delete: fn(id) {\n            // ...\n            return true;\n        },\n        find_all: fn(predicate) {\n            return users.filter(predicate);\n        }\n    };\n}\n```\n\n### 明示的な型を持つコールバック\n\n```hemlock\ntype ClickHandler = fn(event: MouseEvent): void;\ntype KeyHandler = fn(event: KeyEvent, modifiers: i32): bool;\n\ndefine Widget {\n    x: i32;\n    y: i32;\n    on_click: ClickHandler?;\n    on_key: KeyHandler?;\n}\n\nfn create_button(label: string, handler: ClickHandler): Widget {\n    return {\n        x: 0, y: 0,\n        on_click: handler,\n        on_key: null\n    };\n}\n```\n\n### Nullable関数型\n\n```hemlock\n// オプションのコールバック\nfn fetch(url: string, on_complete: fn(Response): void?): void {\n    let response = http_get(url);\n    if (on_complete != null) {\n        on_complete(response);\n    }\n}\n\n// 関数型からのnullable戻り値\ntype Parser = fn(input: string): AST?;\n\nfn try_parse(parsers: array<Parser>, input: string): AST? {\n    for (p in parsers) {\n        let result = p(input);\n        if (result != null) {\n            return result;\n        }\n    }\n    return null;\n}\n```\n\n---\n\n## 実装ロードマップ\n\n### フェーズ1: コアインフラストラクチャ\n1. TypeKind列挙型に`TYPE_FUNCTION`を追加\n2. Type構造体に関数型フィールドを拡張\n3. コンパイラ型チェッカーに`CHECKED_FUNCTION`を追加\n4. `Self`型サポートを追加 (TYPE_SELF)\n\n### フェーズ2: パース\n1. パーサーに`parse_function_type()`を実装\n2. 型位置で`fn(...)`を処理\n3. `type`キーワードと`STMT_TYPE_ALIAS`パースを追加\n4. `const`パラメータ修飾子パースを追加\n5. メソッドシグネチャ用にdefineパースを拡張\n\n### フェーズ3: 型チェック\n1. 関数型互換性ルール\n2. 型エイリアス解決と展開\n3. Constパラメータ変更チェック\n4. define型でのメソッドシグネチャ検証\n5. Self型解決\n\n### フェーズ4: ランタイム\n1. 呼び出しサイトでの関数型検証\n2. Const違反検出\n3. 型エイリアス透過性\n\n### フェーズ5: パリティテスト\n1. 関数型注釈テスト\n2. Nullable組み合わせテスト\n3. 型エイリアステスト\n4. Constパラメータテスト\n5. メソッドシグネチャテスト\n\n---\n\n## 設計上の決定\n\n### 1. ジェネリック型エイリアス: **YES**\n\n型エイリアスはジェネリックパラメータをサポート:\n\n```hemlock\n// ジェネリック型エイリアス\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\ntype Mapper<T, U> = fn(T): U;\ntype AsyncResult<T> = async fn(): T?;\n\n// 使用\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\nlet result: Result<User, string> = { value: user, error: null };\nlet transform: Mapper<i32, string> = fn(n) { return n.to_string(); };\n```\n\n### 2. Const伝播: **DEEP**\n\nConstパラメータは完全に不変 - どのパスを通しても変更不可:\n\n```hemlock\nfn process(const arr: array<object>) {\n    arr.push({});        // エラー: const配列を変更できない\n    arr[0] = {};         // エラー: const配列を変更できない\n    arr[0].x = 5;        // エラー: constを通して変更できない（DEEP）\n\n    let x = arr[0].x;    // OK: 読み取りは問題ない\n    let copy = arr[0];   // OK: コピーを作成\n    copy.x = 5;          // OK: コピーはconstではない\n}\n\nfn nested(const obj: object) {\n    obj.user.name = \"x\"; // エラー: ディープconstはネストされた変更を防ぐ\n    obj.items[0] = 1;    // エラー: ディープconstはネストされた変更を防ぐ\n}\n```\n\n**根拠:** ディープconstはより強い保証を提供し、データの整合性を確保するのにより有用です。\nネストされたデータを変更する必要がある場合は、まずコピーを作成してください。\n\n### 3. スタンドアロン型エイリアスでのSelf: **NO**\n\n`Self`は明確な意味を持つ`define`ブロック内でのみ有効:\n\n```hemlock\n// 有効: Selfは定義された型を参照\ndefine Comparable {\n    fn compare(other: Self): i32;\n}\n\n// 無効: ここではSelfに意味がない\ntype Cloner = fn(Self): Self;  // エラー: defineコンテキスト外のSelf\n\n// 代わりに、ジェネリックを使用:\ntype Cloner<T> = fn(T): T;\n```\n\n### 4. メソッドのデフォルト実装: **YES (シンプルなものに限る)**\n\nシンプル/ユーティリティメソッドにデフォルト実装を許可:\n\n```hemlock\ndefine Comparable {\n    // 必須: 実装が必要\n    fn compare(other: Self): i32;\n\n    // デフォルト実装（シンプルな便利メソッド）\n    fn equals(other: Self): bool {\n        return self.compare(other) == 0;\n    }\n    fn less_than(other: Self): bool {\n        return self.compare(other) < 0;\n    }\n    fn greater_than(other: Self): bool {\n        return self.compare(other) > 0;\n    }\n}\n\ndefine Printable {\n    fn to_string(): string;\n\n    // デフォルト: 必須メソッドに委譲\n    fn print() {\n        print(self.to_string());\n    }\n    fn println() {\n        print(self.to_string() + \"\\n\");\n    }\n}\n\n// オブジェクトは必須メソッドのみ実装すればよい\nlet item: Comparable = {\n    value: 42,\n    compare: fn(other) { return self.value - other.value; }\n    // equals, less_than, greater_thanはデフォルトから継承\n};\n\nitem.less_than({ value: 50, compare: item.compare });  // true\n```\n\n**デフォルトのガイドライン:**\n- シンプルに保つ（1-3行）\n- 必須メソッドに委譲すべき\n- 複雑なロジックや副作用なし\n- プリミティブと単純な合成のみ\n\n### 5. 変性: **推論（明示的注釈なし）**\n\n変性は型パラメータの使用方法から推論されます:\n\n```hemlock\n// 変性は位置に基づいて自動\ntype Producer<T> = fn(): T;           // 戻り値のT = 共変\ntype Consumer<T> = fn(T): void;       // パラメータのT = 反変\ntype Transformer<T> = fn(T): T;       // 両方のT = 不変\n\n// 例: Dog <: Animal（DogはAnimalのサブタイプ）\nlet dog_producer: Producer<Dog> = fn() { return new_dog(); };\nlet animal_producer: Producer<Animal> = dog_producer;  // OK: 共変\n\nlet animal_consumer: Consumer<Animal> = fn(a) { print(a); };\nlet dog_consumer: Consumer<Dog> = animal_consumer;     // OK: 反変\n```\n\n**なぜ推論？**\n- ボイラープレートが少ない（`<out T>` / `<in T>`はノイズを加える）\n- 「暗黙より明示」に従う - 位置は明示的\n- ほとんどの言語が関数型の変性を処理する方法に一致\n- 変性ルールに違反した場合のエラーは明確\n\n---\n\n## 付録: 文法変更\n\n```ebnf\n(* 型 *)\ntype := simple_type | compound_type | function_type\nsimple_type := base_type [\"?\"] | identifier [\"<\" type_args \">\"] [\"?\"]\ncompound_type := simple_type (\"&\" simple_type)+\nfunction_type := [\"async\"] \"fn\" \"(\" [param_types] \")\" [\":\" type]\n\nbase_type := \"i8\" | \"i16\" | \"i32\" | \"i64\"\n           | \"u8\" | \"u16\" | \"u32\" | \"u64\"\n           | \"f32\" | \"f64\" | \"bool\" | \"string\" | \"rune\"\n           | \"ptr\" | \"buffer\" | \"void\" | \"null\"\n           | \"array\" [\"<\" type \">\"]\n           | \"object\"\n           | \"Self\"\n\nparam_types := param_type (\",\" param_type)*\nparam_type := [\"const\"] [identifier \":\"] [\"?\"] type\n            | \"...\" [identifier] [\":\" type]\n\ntype_args := type (\",\" type)*\n\n(* 文 *)\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n\ndefine_stmt := \"define\" identifier [\"<\" type_params \">\"] \"{\" define_members \"}\"\ndefine_members := (field_def | method_def)*\nfield_def := identifier (\":\" type [\"=\" expr] | \"?:\" (type | expr)) \";\"?\nmethod_def := \"fn\" identifier [\"?\"] \"(\" [param_types] \")\" [\":\" type] (block | \";\")\n            (* \"?\" はオプションメソッドを示し、block はデフォルト実装を提供 *)\n\n(* パラメータ *)\nparam := [\"const\"] [\"ref\"] identifier [\":\" type] [\"?:\" expr]\n       | \"...\" identifier [\":\" type]\n```\n"}, "設計と思想 -> 実装の詳細": {"id": "design-implementation", "content": "# Hemlock 実装詳細\n\nこのドキュメントでは、Hemlock言語の技術的な実装について説明します。プロジェクト構造、コンパイルパイプライン、ランタイムアーキテクチャ、および設計上の決定事項を含みます。\n\n---\n\n## 目次\n\n- [プロジェクト構造](#プロジェクト構造)\n- [コンパイルパイプライン](#コンパイルパイプライン)\n- [モジュラーインタプリタ設計](#モジュラーインタプリタ設計)\n- [ランタイムアーキテクチャ](#ランタイムアーキテクチャ)\n- [値の表現](#値の表現)\n- [型システムの実装](#型システムの実装)\n- [メモリ管理](#メモリ管理)\n- [並行処理モデル](#並行処理モデル)\n- [将来の計画](#将来の計画)\n\n---\n\n## プロジェクト構造\n\n```\nhemlock/\n├── src/\n│   ├── frontend/              # 共有: 字句解析器、構文解析器、AST\n│   │   ├── lexer.c            # トークン化\n│   │   ├── parser/            # 再帰下降パーサー\n│   │   ├── ast.c              # ASTノード管理\n│   │   └── module.c           # モジュール解決\n│   ├── backends/\n│   │   ├── interpreter/       # hemlock: ツリーウォーキングインタプリタ\n│   │   │   ├── main.c         # CLIエントリポイント\n│   │   │   ├── runtime.c      # 式/文の評価\n│   │   │   ├── builtins.c     # 組み込み関数\n│   │   │   └── ...\n│   │   └── compiler/          # hemlockc: Cコードジェネレータ\n│   │       ├── main.c         # CLI、オーケストレーション\n│   │       ├── type_check.c   # コンパイル時型チェック\n│   │       ├── codegen.c      # コード生成コンテキスト\n│   │       ├── codegen_expr.c # 式のコード生成\n│   │       ├── codegen_stmt.c # 文のコード生成\n│   │       └── ...\n│   ├── tools/\n│   │   ├── lsp/               # 言語サーバープロトコル\n│   │   └── bundler/           # バンドル/パッケージツール\n├── runtime/                   # libhemlock_runtime.a（コンパイル済みプログラム用）\n├── stdlib/                    # 標準ライブラリ（39モジュール）\n│   └── docs/                  # モジュールドキュメント\n├── tests/\n│   ├── parity/                # 両バックエンドで合格必須のテスト\n│   ├── interpreter/           # インタプリタ固有のテスト\n│   └── compiler/              # コンパイラ固有のテスト\n├── examples/                  # サンプルプログラム\n└── docs/                      # ドキュメント\n```\n\n### ディレクトリ構成\n\n**`include/`** - コンポーネント間のインターフェースを定義するパブリックAPIヘッダー:\n- 字句解析器、構文解析器、AST、インタプリタ間の明確な分離\n- 依存関係を最小化するための前方宣言\n- 他のプログラムにHemlockを埋め込むためのパブリックAPI\n\n**`src/`** - 実装ファイル:\n- トップレベルファイルは字句解析、構文解析、AST管理を処理\n- `main.c`はCLIとREPLを提供\n- インタプリタは別々のサブシステムにモジュール化\n\n**`src/interpreter/`** - モジュラーインタプリタ実装:\n- 各モジュールは単一の明確な責務を持つ\n- モジュール間通信用の内部APIは`internal.h`で定義\n- モジュールは独立してコンパイル可能で、より高速なビルドを実現\n\n**`tests/`** - 包括的なテストスイート:\n- 機能領域ごとに整理\n- 各ディレクトリには焦点を絞ったテストケースを含む\n- `run_tests.sh`がテスト実行を調整\n\n---\n\n## コンパイルパイプライン\n\nHemlockは、明確なフェーズを持つ従来のコンパイルパイプラインを使用します:\n\n### フェーズ1: 字句解析（レキサー）\n\n**入力:** ソースコードテキスト\n**出力:** トークンストリーム\n**実装:** `src/lexer.c`\n\n```\nソース: \"let x = 42;\"\n   ↓\nトークン: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n```\n\n**主な特徴:**\n- キーワード、識別子、リテラル、演算子、句読点を認識\n- UTF-8文字列リテラルとルーンリテラルを処理\n- エラーメッセージ用に行番号を報告\n- シングルパス、バックトラックなし\n\n### フェーズ2: 構文解析（パーサー）\n\n**入力:** トークンストリーム\n**出力:** 抽象構文木（AST）\n**実装:** `src/parser.c`\n\n```\nトークン: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n   ↓\nAST: LetStmt {\n    name: \"x\",\n    type: null,\n    value: IntLiteral(42)\n}\n```\n\n**主な特徴:**\n- 再帰下降パーサー\n- プログラム構造のツリー表現を構築\n- 演算子の優先順位を処理\n- 構文を検証（括弧、セミコロンなど）\n- 意味解析はまだ行わない（実行時に行う）\n\n**演算子の優先順位（低い順）:**\n1. 代入: `=`\n2. 論理OR: `||`\n3. 論理AND: `&&`\n4. ビット単位OR: `|`\n5. ビット単位XOR: `^`\n6. ビット単位AND: `&`\n7. 等価: `==`, `!=`\n8. 比較: `<`, `>`, `<=`, `>=`\n9. ビットシフト: `<<`, `>>`\n10. 加算/減算: `+`, `-`\n11. 乗算/除算/剰余: `*`, `/`, `%`\n12. 単項: `!`, `-`, `~`\n13. 呼び出し/インデックス/メンバー: `()`, `[]`, `.`\n\n### フェーズ3a: インタープリテーション（ツリーウォーキング）\n\n**入力:** AST\n**出力:** プログラム実行\n**実装:** `src/backends/interpreter/runtime.c`\n\n```\nAST: LetStmt { ... }\n   ↓\n実行: ASTノードを再帰的に評価\n   ↓\n結果: 変数xが値42で作成される\n```\n\n**主な特徴:**\n- 直接的なAST走査（ツリーウォーキングインタプリタ）\n- 実行時の動的型チェック\n- 環境ベースの変数ストレージ\n\n### フェーズ3b: コンパイル（hemlockc）\n\n**入力:** AST\n**出力:** Cコード生成によるネイティブ実行可能ファイル\n**実装:** `src/backends/compiler/`\n\n```\nAST: LetStmt { ... }\n   ↓\n型チェック: コンパイル時に型を検証\n   ↓\nCコード生成: 同等のCコードを生成\n   ↓\nGCC: Cをネイティブバイナリにコンパイル\n   ↓\n結果: スタンドアロン実行可能ファイル\n```\n\n**主な特徴:**\n- コンパイル時型チェック（デフォルトで有効）\n- 移植性のためのCコード生成\n- `libhemlock_runtime.a`にリンク\n- インタプリタよりも大幅に高速な実行\n\n---\n\n## コンパイラバックエンド（hemlockc）\n\nHemlockコンパイラはASTからCコードを生成し、GCCを使用してネイティブ実行可能ファイルにコンパイルします。\n\n### コンパイラアーキテクチャ\n\n```\nsrc/backends/compiler/\n├── main.c              # CLI、引数解析、オーケストレーション\n├── codegen.c           # コアコード生成コンテキスト\n├── codegen_expr.c      # 式のコード生成\n├── codegen_stmt.c      # 文のコード生成\n├── codegen_call.c      # 関数呼び出し生成\n├── codegen_closure.c   # クロージャ実装\n├── codegen_program.c   # トップレベルプログラム生成\n├── codegen_module.c    # モジュール/インポート処理\n├── type_check.c        # コンパイル時型チェック\n└── type_check.h        # 型チェッカーAPI\n```\n\n### 型チェック\n\nコンパイラには統一された型チェックシステムが含まれており、以下を行います:\n\n1. **コンパイル時に型を検証** - 実行前に型エラーをキャッチ\n2. **動的コードをサポート** - 型なしコードは`any`として扱われる（常に有効）\n3. **最適化ヒントを提供** - アンボックス可能な変数を識別\n\n**型チェックフラグ:**\n\n| フラグ | 説明 |\n|------|-------------|\n| (デフォルト) | 型チェック有効 |\n| `--check` | 型チェックのみ、コンパイルしない |\n| `--no-type-check` | 型チェックを無効化 |\n| `--strict-types` | 暗黙の`any`型で警告 |\n\n**型チェッカー実装:**\n\n```c\n// type_check.h - 主要な構造体\ntypedef struct TypeCheckContext {\n    const char *filename;\n    int error_count;\n    int warning_count;\n    UnboxableVar *unboxable_vars;  // 最適化ヒント\n    // ... 型環境、定義など\n} TypeCheckContext;\n\n// メインエントリポイント\nint type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);\n```\n\n### コード生成\n\ncodegen フェーズはASTノードをCコードに変換します:\n\n**式のマッピング:**\n```\nHemlock                 →  生成されるC\n----------------------------------------\nlet x = 42;            →  HmlValue x = hml_val_i32(42);\nx + y                  →  hml_add(x, y)\narr[i]                 →  hml_array_get(arr, i)\nobj.field              →  hml_object_get_field(obj, \"field\")\nfn(a, b) { ... }       →  環境キャプチャ付きクロージャ\n```\n\n**ランタイム統合:**\n\n生成されたCコードは`libhemlock_runtime.a`にリンクし、以下を提供します:\n- `HmlValue`タグ付きユニオン型\n- メモリ管理（参照カウント）\n- 組み込み関数（print、typeofなど）\n- 並行処理プリミティブ（タスク、チャネル）\n- FFIサポート\n\n### アンボックス最適化\n\n型チェッカーは、ボックス化された`HmlValue`の代わりにネイティブC型を使用できる変数を識別します:\n\n**アンボックス可能なパターン:**\n- 既知の整数型を持つループカウンター\n- ループ内のアキュムレータ変数\n- 明示的な型注釈を持つ変数（i32、i64、f64、bool）\n\n```hemlock\n// ループカウンター 'i' はネイティブint32_tにアンボックス可能\nfor (let i: i32 = 0; i < 1000000; i = i + 1) {\n    sum = sum + i;\n}\n```\n\n---\n\n## モジュラーインタプリタ設計\n\nインタプリタは、保守性とスケーラビリティのために、焦点を絞ったモジュールに分割されています。\n\n### モジュールの責務\n\n#### 1. 環境（`environment.c`）- 121行\n\n**目的:** 変数スコープと名前解決\n\n**主要関数:**\n- `env_create()` - オプションの親を持つ新しい環境を作成\n- `env_define()` - 現在のスコープに新しい変数を定義\n- `env_get()` - 現在または親スコープで変数を検索\n- `env_set()` - 既存の変数値を更新\n- `env_free()` - 環境とすべての変数を解放\n\n**設計:**\n- リンクされたスコープ（各環境は親へのポインタを持つ）\n- 高速な変数検索のためのHashMap\n- クロージャのレキシカルスコープをサポート\n\n#### 2. 値（`values.c`）- 394行\n\n**目的:** 値コンストラクタとデータ構造管理\n\n**主要関数:**\n- `value_create_*()` - 各値型のコンストラクタ\n- `value_copy()` - ディープ/シャローコピーロジック\n- `value_free()` - クリーンアップとメモリ解放\n- `value_to_string()` - 印刷用の文字列表現\n\n**データ構造:**\n- オブジェクト（動的フィールド配列）\n- 配列（動的リサイズ）\n- バッファ（ptr + length + capacity）\n- クロージャ（関数 + キャプチャされた環境）\n- タスクとチャネル（並行処理プリミティブ）\n\n#### 3. 型（`types.c`）- 440行\n\n**目的:** 型システム、変換、ダックタイピング\n\n**主要関数:**\n- `type_check()` - ランタイム型検証\n- `type_convert()` - 暗黙の型変換/プロモーション\n- `duck_type_check()` - オブジェクトの構造的型チェック\n- `type_name()` - 印刷可能な型名を取得\n\n**機能:**\n- 型プロモーション階層（i8 → i16 → i32 → i64 → f32 → f64、i64/u64 + f32 → f64）\n- 数値型の範囲チェック\n- オブジェクト型定義のダックタイピング\n- オプションフィールドのデフォルト値\n\n#### 4. 組み込み関数（`builtins.c`）- 955行\n\n**目的:** 組み込み関数とグローバル登録\n\n**主要関数:**\n- `register_builtins()` - すべての組み込み関数と定数を登録\n- 組み込み関数の実装（print、typeof、alloc、freeなど）\n- シグナル処理関数\n- コマンド実行（exec）\n\n**組み込み関数のカテゴリ:**\n- I/O: print、open、read_file、write_file\n- メモリ: alloc、free、memset、memcpy、realloc\n- 型: typeof、assert\n- 並行処理: spawn、join、detach、channel\n- システム: exec、signal、raise、panic\n- FFI: dlopen、dlsym、dlcall、dlclose\n\n#### 5. I/O（`io.c`）- 449行\n\n**目的:** ファイルI/OとJSONシリアライゼーション\n\n**主要関数:**\n- ファイルオブジェクトメソッド（read、write、seek、tell、close）\n- JSONシリアライゼーション/デシリアライゼーション\n- 循環参照検出\n\n**機能:**\n- プロパティを持つファイルオブジェクト（path、mode、closed）\n- UTF-8対応テキストI/O\n- バイナリI/Oサポート\n- オブジェクトと配列のJSONラウンドトリップ\n\n#### 6. FFI（`ffi.c`）- 外部関数インターフェース\n\n**目的:** 共有ライブラリからC関数を呼び出す\n\n**主要関数:**\n- `dlopen()` - 共有ライブラリをロード\n- `dlsym()` - 名前で関数ポインタを取得\n- `dlcall()` - 型変換付きでC関数を呼び出す\n- `dlclose()` - ライブラリをアンロード\n\n**機能:**\n- 動的関数呼び出しのためのlibffi統合\n- 自動型変換（Hemlock ↔ C型）\n- すべてのプリミティブ型をサポート\n- ポインタとバッファのサポート\n\n#### 7. ランタイム（`runtime.c`）- 865行\n\n**目的:** 式の評価と文の実行\n\n**主要関数:**\n- `eval_expr()` - 式を評価（再帰的）\n- `eval_stmt()` - 文を実行\n- 制御フロー処理（if、while、for、switchなど）\n- 例外処理（try/catch/finally/throw）\n\n**機能:**\n- 再帰的な式評価\n- ブール演算の短絡評価\n- メソッド呼び出し検出と`self`バインディング\n- 例外伝播\n- break/continue/return処理\n\n### モジュラー設計の利点\n\n**1. 関心の分離**\n- 各モジュールは1つの明確な責務を持つ\n- 機能がどこに実装されているか見つけやすい\n- 変更時の認知負荷を軽減\n\n**2. より高速なインクリメンタルビルド**\n- 変更されたモジュールのみ再コンパイルが必要\n- 並列コンパイルが可能\n- 開発中のイテレーション時間を短縮\n\n**3. より簡単なテストとデバッグ**\n- モジュールを単独でテスト可能\n- バグは特定のサブシステムに限定\n- テスト用のモック実装が可能\n\n**4. スケーラビリティ**\n- 新機能を適切なモジュールに追加可能\n- モジュールを独立してリファクタリング可能\n- ファイルごとのコードサイズが管理可能\n\n**5. コード構成**\n- 関連機能の論理的なグルーピング\n- 明確な依存関係グラフ\n- 新しい貢献者のオンボーディングが容易\n\n---\n\n## ランタイムアーキテクチャ\n\n### 値の表現\n\nHemlockのすべての値は、タグ付きユニオンを使用する`Value`構造体で表現されます:\n\n```c\ntypedef struct Value {\n    ValueType type;  // ランタイム型タグ\n    union {\n        int32_t i32_value;\n        int64_t i64_value;\n        uint8_t u8_value;\n        uint32_t u32_value;\n        uint64_t u64_value;\n        float f32_value;\n        double f64_value;\n        bool bool_value;\n        char *string_value;\n        uint32_t rune_value;\n        void *ptr_value;\n        Buffer *buffer_value;\n        Array *array_value;\n        Object *object_value;\n        Function *function_value;\n        File *file_value;\n        Task *task_value;\n        Channel *channel_value;\n    };\n} Value;\n```\n\n**設計上の決定:**\n- 柔軟性を維持しながら型安全性を確保する**タグ付きユニオン**\n- 動的型付けと型チェックを可能にする**ランタイム型タグ**\n- プリミティブ用の**直接値ストレージ**（ボックス化なし）\n- ヒープ割り当て型用の**ポインタストレージ**（文字列、オブジェクト、配列）\n\n### メモリレイアウト例\n\n**整数（i32）:**\n```\nValue {\n    type: TYPE_I32,\n    i32_value: 42\n}\n```\n- 合計サイズ: 約16バイト（8バイトタグ + 8バイトユニオン）\n- スタック割り当て\n- ヒープ割り当て不要\n\n**文字列:**\n```\nValue {\n    type: TYPE_STRING,\n    string_value: 0x7f8a4c000000  // ヒープへのポインタ\n}\n\nヒープ: \"hello\\0\"（6バイト、null終端UTF-8）\n```\n- 値はスタック上で16バイト\n- 文字列データはヒープ割り当て\n- 手動で解放が必要\n\n**オブジェクト:**\n```\nValue {\n    type: TYPE_OBJECT,\n    object_value: 0x7f8a4c001000  // ヒープへのポインタ\n}\n\nヒープ: Object {\n    type_name: \"Person\",\n    fields: [\n        { name: \"name\", value: Value{TYPE_STRING, \"Alice\"} },\n        { name: \"age\", value: Value{TYPE_I32, 30} }\n    ],\n    field_count: 2,\n    capacity: 4\n}\n```\n- オブジェクト構造はヒープ上\n- フィールドは動的配列に格納\n- フィールド値は埋め込まれたValue構造体\n\n### 環境の実装\n\n変数は環境チェーンに格納されます:\n\n```c\ntypedef struct Environment {\n    HashMap *bindings;           // name → Value\n    struct Environment *parent;  // レキシカル親スコープ\n} Environment;\n```\n\n**スコープチェーンの例:**\n```\nグローバルスコープ: { print: <builtin>, args: <array> }\n    ↑\n関数スコープ: { x: 10, y: 20 }\n    ↑\nブロックスコープ: { i: 0 }\n```\n\n**検索アルゴリズム:**\n1. 現在の環境のハッシュマップをチェック\n2. 見つからない場合、親環境をチェック\n3. 見つかるかグローバルスコープに達するまで繰り返す\n4. どのスコープでも見つからない場合はエラー\n\n---\n\n## 型システムの実装\n\n### 型チェック戦略\n\nHemlockは**オプションの型注釈**付きの**ランタイム型チェック**を使用します:\n\n```hemlock\nlet x = 42;           // 型チェックなし、i32を推論\nlet y: u8 = 255;      // ランタイムチェック: 値はu8に収まる必要あり\nlet z: i32 = x + y;   // ランタイムチェック + 型プロモーション\n```\n\n**実装フロー:**\n1. **リテラル推論** - レキサー/パーサーがリテラルから初期型を決定\n2. **型注釈チェック** - 注釈がある場合、代入時に検証\n3. **プロモーション** - 二項演算は共通型にプロモート\n4. **変換** - 明示的な変換はオンデマンドで発生\n\n### 型プロモーションの実装\n\n型プロモーションは、精度を保持する固定階層に従います:\n\n```c\n// 簡略化されたプロモーションロジック\nValueType promote_types(ValueType a, ValueType b) {\n    // f64は常に勝つ\n    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;\n\n    // f32とi64/u64はf64にプロモート（精度保持）\n    if (a == TYPE_F32 || b == TYPE_F32) {\n        ValueType other = (a == TYPE_F32) ? b : a;\n        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;\n        return TYPE_F32;\n    }\n\n    // 大きい整数型が勝つ\n    int rank_a = get_type_rank(a);\n    int rank_b = get_type_rank(b);\n    return (rank_a > rank_b) ? a : b;\n}\n```\n\n**型ランク:**\n- i8: 0\n- u8: 1\n- i16: 2\n- u16: 3\n- i32: 4\n- u32: 5\n- i64: 6\n- u64: 7\n- f32: 8\n- f64: 9\n\n### ダックタイピングの実装\n\nオブジェクトの型チェックは構造的比較を使用します:\n\n```c\nbool duck_type_check(Object *obj, TypeDef *type_def) {\n    // すべての必須フィールドをチェック\n    for (each field in type_def) {\n        if (!object_has_field(obj, field.name)) {\n            return false;  // フィールドが見つからない\n        }\n\n        Value *field_value = object_get_field(obj, field.name);\n        if (!type_matches(field_value, field.type)) {\n            return false;  // 型が違う\n        }\n    }\n\n    return true;  // すべての必須フィールドが存在し、正しい型\n}\n```\n\n**ダックタイピングで許可されること:**\n- オブジェクトの余分なフィールド（無視される）\n- 部分構造型付け（オブジェクトは必要以上のものを持てる）\n- 検証後の型名の割り当て\n\n---\n\n## メモリ管理\n\n### 割り当て戦略\n\nHemlockは2つの割り当てプリミティブを持つ**手動メモリ管理**を使用します:\n\n**1. 生ポインタ（`ptr`）:**\n```c\nvoid *alloc(size_t bytes) {\n    void *ptr = malloc(bytes);\n    if (!ptr) {\n        fprintf(stderr, \"Out of memory\\n\");\n        exit(1);\n    }\n    return ptr;\n}\n```\n- 直接malloc/free\n- トラッキングなし\n- ユーザーの責任で解放\n\n**2. バッファ（`buffer`）:**\n```c\ntypedef struct Buffer {\n    void *data;\n    size_t length;\n    size_t capacity;\n} Buffer;\n\nBuffer *create_buffer(size_t size) {\n    Buffer *buf = malloc(sizeof(Buffer));\n    buf->data = malloc(size);\n    buf->length = size;\n    buf->capacity = size;\n    return buf;\n}\n```\n- サイズと容量を追跡\n- アクセス時の境界チェック\n- それでも手動freeが必要\n\n### ヒープ割り当て型\n\n**文字列:**\n- ヒープ上のUTF-8バイト配列\n- Cとの相互運用のためnull終端\n- 変更可能（その場で変更可能）\n- 参照カウント（スコープ終了時に自動解放）\n\n**オブジェクト:**\n- 動的フィールド配列\n- フィールド名と値はヒープ上\n- 参照カウント（スコープ終了時に自動解放）\n- 循環参照の可能性あり（訪問済みセットトラッキングで処理）\n\n**配列:**\n- 動的な容量倍増成長\n- 要素は埋め込まれたValue構造体\n- 成長時の自動再割り当て\n- 参照カウント（スコープ終了時に自動解放）\n\n**クロージャ:**\n- 参照によって環境をキャプチャ\n- 環境はヒープ割り当て\n- クロージャ環境は参照されなくなると適切に解放\n\n---\n\n## 並行処理モデル\n\n### スレッディングアーキテクチャ\n\nHemlockは**1:1スレッディング**とPOSIXスレッド（pthreads）を使用します:\n\n```\nユーザータスク        OSスレッド           CPUコア\n---------          ---------          --------\nspawn(f1) ------>  pthread_create --> コア0\nspawn(f2) ------>  pthread_create --> コア1\nspawn(f3) ------>  pthread_create --> コア2\n```\n\n**主な特徴:**\n- 各`spawn()`は新しいpthreadを作成\n- カーネルがスレッドをコア間でスケジュール\n- 真の並列実行（GILなし）\n- プリエンプティブマルチタスキング\n\n### タスクの実装\n\n```c\ntypedef struct Task {\n    pthread_t thread;        // OSスレッドハンドル\n    Value result;            // 戻り値\n    char *error;             // 例外メッセージ（スローされた場合）\n    pthread_mutex_t lock;    // 状態を保護\n    TaskState state;         // RUNNING、FINISHED、ERROR\n} Task;\n```\n\n**タスクのライフサイクル:**\n1. `spawn(func, args)` → タスクを作成、pthreadを開始\n2. スレッドが引数付きで関数を実行\n3. 戻り時: 結果を格納、状態をFINISHEDに設定\n4. 例外時: エラーメッセージを格納、状態をERRORに設定\n5. `join(task)` → スレッドを待機、結果を返すか例外をスロー\n\n### チャネルの実装\n\n```c\ntypedef struct Channel {\n    void **buffer;           // Value*の循環バッファ\n    size_t capacity;         // 最大バッファアイテム数\n    size_t count;            // バッファ内の現在のアイテム数\n    size_t read_index;       // 次の読み取り位置\n    size_t write_index;      // 次の書き込み位置\n    bool closed;             // チャネルクローズフラグ\n    pthread_mutex_t lock;    // バッファを保護\n    pthread_cond_t not_full; // スペースが利用可能時のシグナル\n    pthread_cond_t not_empty;// データが利用可能時のシグナル\n} Channel;\n```\n\n**送信操作:**\n1. mutexをロック\n2. バッファがフルなら待機（not_fullでcond_wait）\n3. buffer[write_index]に値を書き込み\n4. write_indexをインクリメント（循環）\n5. not_emptyをシグナル\n6. mutexをアンロック\n\n**受信操作:**\n1. mutexをロック\n2. バッファが空なら待機（not_emptyでcond_wait）\n3. buffer[read_index]から値を読み取り\n4. read_indexをインクリメント（循環）\n5. not_fullをシグナル\n6. mutexをアンロック\n\n**同期保証:**\n- スレッドセーフなsend/recv（mutexで保護）\n- ブロッキングセマンティクス（プロデューサーはフルで待機、コンシューマーは空で待機）\n- 順序付き配信（チャネル内でFIFO）\n\n---\n\n## 将来の計画\n\n### 完了: コンパイラバックエンド ✓\n\nコンパイラバックエンド（`hemlockc`）は以下で実装済み:\n- ASTからのCコード生成\n- コンパイル時型チェック（デフォルトで有効）\n- ランタイムライブラリ（`libhemlock_runtime.a`）\n- インタプリタとの完全なパリティ（98%のテスト合格率）\n- アンボックス最適化フレームワーク\n\n### 現在のフォーカス: 型システムの強化\n\n**最近の改善:**\n- 統一された型チェックと型推論システム\n- コンパイル時型チェックがデフォルトで有効\n- 型のみの検証用`--check`フラグ\n- 最適化ヒント用のコード生成への型コンテキスト渡し\n\n### 将来の強化\n\n**潜在的な追加:**\n- ジェネリクス/テンプレート\n- パターンマッチング\n- 型認識IDEサポートのためのLSP統合\n- より積極的なアンボックス最適化\n- スタック割り当てのためのエスケープ解析\n\n### 長期的な最適化\n\n**可能な改善:**\n- メソッド呼び出しのインラインキャッシング\n- ホットコードパスのJITコンパイル\n- より良い並行処理のためのワークスティーリングスケジューラ\n- プロファイルガイド最適化\n\n---\n\n## 実装ガイドライン\n\n### 新機能の追加\n\n新機能を実装する際は、以下のガイドラインに従ってください:\n\n**1. 適切なモジュールを選択:**\n- 新しい値型 → `values.c`\n- 型変換 → `types.c`\n- 組み込み関数 → `builtins.c`\n- I/O操作 → `io.c`\n- 制御フロー → `runtime.c`\n\n**2. すべてのレイヤーを更新:**\n- 必要に応じてASTノード型を追加（`ast.h`、`ast.c`）\n- 必要に応じてレキサートークンを追加（`lexer.c`）\n- パーサールールを追加（`parser.c`）\n- ランタイム動作を実装（`runtime.c`または適切なモジュール）\n- テストを追加（`tests/`）\n\n**3. 一貫性を維持:**\n- 既存のコードスタイルに従う\n- 一貫した命名規則を使用\n- ヘッダーでパブリックAPIをドキュメント化\n- エラーメッセージを明確で一貫性のあるものにする\n\n**4. 徹底的にテスト:**\n- 実装前にテストケースを追加\n- 成功とエラーのパスをテスト\n- エッジケースをテスト\n- メモリリークがないことを確認（valgrind）\n\n### パフォーマンスの考慮事項\n\n**現在のボトルネック:**\n- 変数アクセスのHashMap検索\n- 再帰関数呼び出し（TCOなし）\n- 文字列連結（毎回新しい文字列を割り当て）\n- すべての操作での型チェックオーバーヘッド\n\n**最適化の機会:**\n- 変数位置のキャッシュ（インラインキャッシング）\n- 末尾呼び出し最適化\n- 連結用文字列ビルダー\n- ランタイムチェックをスキップする型推論\n\n### デバッグのヒント\n\n**便利なツール:**\n- `valgrind` - メモリリーク検出\n- `gdb` - クラッシュのデバッグ\n- `-g`フラグ - デバッグシンボル\n- `printf`デバッグ - シンプルだが効果的\n\n**よくある問題:**\n- セグフォルト → NULLポインタ参照（戻り値をチェック）\n- メモリリーク → free()呼び出しの欠落（value_freeパスをチェック）\n- 型エラー → type_convert()とtype_check()ロジックをチェック\n- スレッドでのクラッシュ → 競合状態（mutex使用をチェック）\n\n---\n\n## 結論\n\nHemlockの実装は以下を優先しています:\n- **モジュール性** - 関心の明確な分離\n- **シンプルさ** - 直接的な実装\n- **明示性** - 隠された魔法なし\n- **保守性** - 理解と変更が容易\n\n現在のツリーウォーキングインタプリタは、迅速な機能開発と実験を容易にするために意図的にシンプルにしています。将来のコンパイラバックエンドは、同じセマンティクスを維持しながらパフォーマンスを向上させます。\n"}, "設計と思想 -> 設計思想": {"id": "design-philosophy", "content": "# Hemlock言語設計哲学\n\n> 「安全でないものを安全に書くための、小さな安全でない言語。」\n\nこのドキュメントは、Hemlockの核となる設計原則と哲学を説明します。言語に変更や追加を行う前に、まずこれをお読みください。\n\n---\n\n## 目次\n\n- [コアアイデンティティ](#コアアイデンティティ)\n- [設計原則](#設計原則)\n- [安全性に関する哲学](#安全性に関する哲学)\n- [追加すべきでないもの](#追加すべきでないもの)\n- [将来の検討事項](#将来の検討事項)\n- [最終的な考え](#最終的な考え)\n\n---\n\n## コアアイデンティティ\n\nHemlockは、手動メモリ管理と明示的な制御を採用した**システムスクリプト言語**です。以下を求めるプログラマー向けに設計されています:\n\n- Cの力\n- 現代的なスクリプト言語の人間工学\n- 組み込みの構造化非同期並行処理\n- 隠された動作や魔法なし\n\n### HemlockでないもNOT\n\n- **メモリセーフ**（ダングリングポインタはあなたの責任）\n- **Rust、Go、Luaの代替**\n- **複雑さを隠す言語**\n\n### Hemlockであるもの\n\n- **常に暗黙より明示**\n- **教育的かつ実験的**\n- **システム作業のための「Cスクリプト層」**\n- **トレードオフについて正直**\n\n---\n\n## 設計原則\n\n### 1. 暗黙より明示\n\nHemlockはすべての言語構文で明示性を重視します。驚き、魔法、隠された動作があってはなりません。\n\n**悪い例（暗黙）:**\n```hemlock\nlet x = 5  // セミコロンがない - エラーになるべき\n```\n\n**良い例（明示）:**\n```hemlock\nlet x = 5;\nfree(ptr);  // あなたが割り当てたなら、あなたが解放する\n```\n\n**重要な側面:**\n- セミコロンは必須（自動セミコロン挿入なし）\n- ガベージコレクションなし\n- 手動メモリ管理（alloc/free）\n- 型注釈はオプションだが、実行時にチェックされる\n- 自動リソースクリーンアップなし（RAIIなし）、ただし`defer`が明示的なクリーンアップを提供\n\n### 2. デフォルトで動的、選択で型付き\n\nすべての値はランタイム型タグを持ちますが、システムは柔軟でありながらエラーをキャッチするように設計されています。\n\n**型推論:**\n- 小さい整数（i32に収まる）: `42` → `i32`\n- 大きい整数（> i32範囲）: `9223372036854775807` → `i64`\n- 浮動小数点: `3.14` → `f64`\n\n**必要に応じた明示的な型付け:**\n```hemlock\nlet x = 42;              // i32推論（小さい値）\nlet y: u8 = 255;         // 明示的なu8\nlet z = x + y;           // i32にプロモート\nlet big = 5000000000;    // i64推論（> i32最大値）\n```\n\n**型プロモーション規則**は、最小から最大への明確な階層に従い、浮動小数点は常に整数に勝ちます。\n\n### 3. 安全でないことは機能であり、バグではない\n\nHemlockはすべてのエラーを防ごうとはしません。代わりに、安全であるためのツールを提供しながら、必要に応じて安全でない動作を選択できるようにします。\n\n**意図的な安全でなさの例:**\n- ポインタ算術はオーバーフローする可能性がある（ユーザーの責任）\n- 生の`ptr`に境界チェックなし（安全性が必要なら`buffer`を使用）\n- ダブルフリーによるクラッシュは許可（手動メモリ管理）\n- 型システムは事故を防ぐが、必要に応じて危険な操作も許可\n\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // 割り当てを大きく超えている - 許可されるが危険\n```\n\n**哲学:** 型システムは*事故*を防ぐべきだが、*意図的な*安全でない操作は許可すべき。\n\n### 4. 構造化並行処理がファーストクラス\n\n並行処理はHemlockにおいて後付けではありません。最初から言語に組み込まれています。\n\n**主な機能:**\n- `async`/`await`が言語に組み込み\n- 通信用チャネル\n- タスク管理のための`spawn`/`join`/`detach`\n- 生スレッドなし、ロックなし - 構造化のみ\n- POSIXスレッドを使用した真のマルチスレッド並列処理\n\n**イベントループやグリーンスレッドではない** - Hemlockは複数のCPUコアにわたる真の並列処理のために実際のOSスレッドを使用します。\n\n### 5. C風の構文、低セレモニー\n\nHemlockはシステムプログラマーにとって馴染みやすく、ボイラープレートを減らします。\n\n**設計上の選択:**\n- 常に`{}`ブロック、オプションの括弧なし\n- 演算子はCと一致: `+`, `-`, `*`, `/`, `&&`, `||`, `!`\n- 型構文はRust/TypeScriptと一致: `let x: type = value;`\n- 関数はファーストクラスの値\n- 最小限のキーワードと特殊形式\n\n---\n\n## 安全性に関する哲学\n\n**Hemlockの安全性に対する見解:**\n\n> 「安全であるためのツール（`buffer`、型注釈、境界チェック）を提供しますが、それらを使うことを強制しません（`ptr`、手動メモリ、安全でない操作）。\n>\n> デフォルトは安全に導くべきですが、エスケープハッチは常に利用可能であるべきです。」\n\n### 提供される安全ツール\n\n**1. 安全なbuffer型:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // 境界チェック付き\nprint(b.length);        // 64\nfree(b);                // それでも手動\n```\n\n**2. 安全でない生ポインタ:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // 解放を覚えておく必要がある\n```\n\n**3. 型注釈:**\n```hemlock\nlet x: u8 = 255;   // OK\nlet y: u8 = 256;   // エラー: 範囲外\n```\n\n**4. ランタイム型チェック:**\n```hemlock\nlet val = some_function();\nif (typeof(val) == \"i32\") {\n    // 整数として安全に使用できる\n}\n```\n\n### 指針\n\n1. **ドキュメントでは安全なパターンをデフォルトに** - `ptr`より先に`buffer`を示し、型注釈を推奨\n2. **安全でない操作を明確に** - 生ポインタ算術は意図的に見えるべき\n3. **エスケープハッチを提供** - 経験豊富なユーザーが低レベルの作業をすることを妨げない\n4. **トレードオフについて正直に** - 何が問題になる可能性があるかをドキュメント化\n\n### 安全 vs 安全でないの例\n\n| 安全なパターン | 安全でないパターン | 安全でないを使うとき |\n|-------------|----------------|-------------------|\n| `buffer`型 | `ptr`型 | FFI、パフォーマンス重視のコード |\n| 型注釈 | 注釈なし | 外部インターフェース、検証 |\n| 境界チェック付きアクセス | ポインタ算術 | 低レベルメモリ操作 |\n| 例外処理 | null/エラーコードを返す | 例外が重すぎる場合 |\n\n---\n\n## 追加すべきでないもの\n\n何を追加し**ない**かを理解することは、何を追加するかを知ることと同じくらい重要です。\n\n### ❌ 暗黙の動作を追加しない\n\n**悪い例:**\n\n```hemlock\n// 悪い: 自動セミコロン挿入\nlet x = 5\nlet y = 10\n\n// 悪い: 精度を失う暗黙の型変換\nlet x: i32 = 3.14  // 切り捨てるべき？エラーにすべき？\n```\n\n**理由:** 暗黙の動作は驚きを生み、コードの推論を難しくします。\n\n### ❌ 複雑さを隠さない\n\n**悪い例:**\n\n```hemlock\n// 悪い: 裏での魔法の最適化\nlet arr = [1, 2, 3]  // これはスタック？ヒープ？ユーザーは知るべき！（ヒープ、参照カウント）\n\n// 悪い: 生ポインタの自動解放\nlet p = alloc(100)  // これは自動解放される？いいえ！生ptrは常にfree()が必要\n```\n\n**参照カウントについての注記:** Hemlockは文字列、配列、オブジェクト、バッファに内部参照カウントを使用しています - これらはスコープ終了時に自動解放されます。これは明示的で予測可能です（参照が0になると決定論的クリーンアップ、GCポーズなし）。生ポインタ（`alloc()`からの`ptr`）は参照カウントされず、常に手動`free()`が必要です。\n\n**理由:** 隠された複雑さはパフォーマンスの予測と問題のデバッグを不可能にします。\n\n### ❌ 既存のセマンティクスを壊さない\n\n**これらの核となる決定を変更しない:**\n- セミコロンは必須 - オプションにしない\n- 手動メモリ管理 - GCを追加しない\n- 変更可能な文字列 - 不変にしない\n- ランタイム型チェック - 削除しない\n\n**理由:** 一貫性と安定性は流行の機能より重要です。\n\n### ❌ 明示性を減らす「便利な」機能を追加しない\n\n**避けるべき機能の例:**\n- 演算子オーバーロード（ユーザー型には可能かもしれないが、慎重に）\n- 情報を失う暗黙の型強制\n- 自動リソースクリーンアップ（RAII）\n- 複雑さを隠すメソッドチェーン\n- DSLと魔法の構文\n\n**例外:** 便利な機能は、単純な操作の**明示的なシンタックスシュガー**であればOK:\n- `else if`は問題ない（ネストされたif文にすぎない）\n- 文字列補間は明確にシンタックスシュガーならOKかもしれない\n- オブジェクトのメソッド構文は問題ない（何をするか明示的）\n\n---\n\n## 将来の検討事項\n\n### 追加するかもしれない（検討中）\n\nこれらの機能はHemlockの哲学に沿っていますが、慎重な設計が必要です:\n\n**1. パターンマッチング**\n```hemlock\nmatch (value) {\n    case i32: print(\"integer\");\n    case string: print(\"text\");\n    case _: print(\"other\");\n}\n```\n- 明示的な型チェック\n- 隠れたコストなし\n- コンパイル時の網羅性チェックが可能\n\n**2. エラー型（`Result<T, E>`）**\n```hemlock\nfn divide(a: i32, b: i32): Result<i32, string> {\n    if (b == 0) {\n        return Err(\"division by zero\");\n    }\n    return Ok(a / b);\n}\n```\n- 明示的なエラー処理\n- ユーザーにエラーについて考えさせる\n- 例外の代替\n\n**3. 配列/スライス型**\n- 動的配列は既にある\n- スタック割り当て用の固定サイズ配列を追加できる\n- スタック vs ヒープについて明示的である必要がある\n\n**4. 改善されたメモリ安全ツール**\n- オプションの境界チェックフラグ\n- デバッグビルドでのメモリリーク検出\n- サニタイザ統合\n\n### おそらく追加しない\n\nこれらの機能は核となる原則に違反します:\n\n**1. ガベージコレクション**\n- メモリ管理の複雑さを隠す\n- 予測不可能なパフォーマンス\n- 明示的制御の原則に反する\n\n**2. 自動メモリ管理**\n- GCと同じ理由\n- 参照カウントは明示的ならOKかもしれない\n\n**3. データを失う暗黙の型変換**\n- 「暗黙より明示」に反する\n- 微妙なバグの原因\n\n**4. マクロ（複雑なもの）**\n- 力が強すぎ、複雑すぎ\n- シンプルなマクロシステムならOKかもしれない\n- コード生成や関数を推奨\n\n**5. 継承を持つクラスベースOOP**\n- 暗黙の動作が多すぎる\n- ダックタイピングとオブジェクトで十分\n- 継承より合成\n\n**6. 複雑な解決を持つモジュールシステム**\n- インポートはシンプルで明示的に\n- 魔法の検索パスなし\n- バージョン解決なし（OSパッケージマネージャを使用）\n\n---\n\n## 最終的な考え\n\n### 信頼と責任\n\nHemlockは**信頼と責任**についてです。プログラマーが以下を行うことを信頼します:\n\n- メモリを正しく管理する\n- 型を適切に使用する\n- エラーを適切に処理する\n- トレードオフを理解する\n\n見返りに、Hemlockは以下を提供します:\n\n- 隠れたコストなし\n- 驚きの動作なし\n- 必要な時の完全な制御\n- 望むときの安全ツール\n\n### 指針となる質問\n\n**新機能を検討するとき、尋ねてください:**\n\n> 「これはプログラマーにより明示的な制御を与えるか、それとも何かを隠すか？」\n\n- **明示的な制御を追加する**なら → おそらくHemlockに適している\n- **複雑さを隠す**なら → おそらく属さない\n- 明確にドキュメント化された**オプショナルシュガー**なら → OKかもしれない\n\n### 良い追加の例\n\n✅ **Switch文** - 明示的な制御フロー、魔法なし、明確なセマンティクス\n\n✅ **pthreadsを使ったAsync/await** - 明示的な並行処理、真の並列処理、ユーザーがスポーンを制御\n\n✅ **ptrと並ぶBuffer型** - 安全と安全でないの選択を与える\n\n✅ **オプションの型注釈** - 厳密さを強制せずにバグをキャッチ\n\n✅ **Try/catch/finally** - 明確な制御フローを持つ明示的なエラー処理\n\n### 悪い追加の例\n\n❌ **自動セミコロン挿入** - 構文エラーを隠し、コードを曖昧にする\n\n❌ **RAII/デストラクタ** - 自動クリーンアップはリソースがいつ解放されるか隠す\n\n❌ **暗黙のnull合体** - nullチェックを隠し、コードの推論を難しくする\n\n❌ **自動成長文字列** - メモリ割り当てを隠し、予測不可能なパフォーマンス\n\n---\n\n## 結論\n\nHemlockは最も安全な言語、最速の言語、最も機能豊富な言語になろうとしていません。\n\n**Hemlockは最も*正直な*言語になろうとしています。**\n\n正確に何をしているかを伝え、必要なときに制御を与え、鋭い角を隠しません。低レベルでコードを理解したいが、現代的な人間工学も楽しみたい人のための言語です。\n\n機能がHemlockに属するかどうかわからない場合は、覚えておいてください:\n\n> **常に暗黙より明示。**\n> **安全でないことは機能であり、バグではない。**\n> **ユーザーに責任がある、それでOK。**\n"}, "コントリビューション -> ガイドライン": {"id": "contributing-guidelines", "content": "# Hemlockへの貢献\n\nHemlockへの貢献にご興味をお持ちいただき、ありがとうございます！このガイドでは、言語の設計哲学とコード品質を維持しながら効果的に貢献する方法を説明します。\n\n---\n\n## 目次\n\n- [始める前に](#始める前に)\n- [貢献ワークフロー](#貢献ワークフロー)\n- [コードスタイルガイドライン](#コードスタイルガイドライン)\n- [貢献すべきもの](#貢献すべきもの)\n- [貢献すべきでないもの](#貢献すべきでないもの)\n- [共通パターン](#共通パターン)\n- [新機能の追加](#新機能の追加)\n- [コードレビュープロセス](#コードレビュープロセス)\n\n---\n\n## 始める前に\n\n### 必読ドキュメント\n\n貢献する前に、以下のドキュメントを順番にお読みください:\n\n1. **`/home/user/hemlock/docs/design/philosophy.md`** - Hemlockの核となる原則を理解する\n2. **`/home/user/hemlock/docs/design/implementation.md`** - コードベースの構造を学ぶ\n3. **`/home/user/hemlock/docs/contributing/testing.md`** - テスト要件を理解する\n4. **このドキュメント** - 貢献ガイドラインを学ぶ\n\n### 前提条件\n\n**必要な知識:**\n- Cプログラミング（ポインタ、メモリ管理、構造体）\n- コンパイラ/インタプリタの基礎（字句解析、構文解析、AST）\n- GitとGitHubワークフロー\n- Unix/Linuxコマンドライン\n\n**必要なツール:**\n- GCCまたはClangコンパイラ\n- Makeビルドシステム\n- Gitバージョン管理\n- Valgrind（メモリリーク検出用）\n- 基本的なテキストエディタまたはIDE\n\n### コミュニケーションチャネル\n\n**質問する場所:**\n- GitHub Issues - バグ報告と機能リクエスト\n- GitHub Discussions - 一般的な質問と設計の議論\n- Pull Requestコメント - 具体的なコードフィードバック\n\n---\n\n## 貢献ワークフロー\n\n### 1. Issueを見つけるか作成する\n\n**コードを書く前に:**\n- あなたの貢献に関するIssueが存在するか確認\n- なければ、何をしたいか説明するIssueを作成\n- 大きな変更を始める前にメンテナーのフィードバックを待つ\n- 小さなバグ修正はこのステップをスキップ可能\n\n**良いIssue説明には以下を含む:**\n- 問題の説明（何が壊れているか、何が欠けているか）\n- 提案する解決策（どのように修正するか）\n- 例（問題を示すコードスニペット）\n- 根拠（この変更がHemlockの哲学に沿う理由）\n\n### 2. フォークとクローン\n\n```bash\n# まずGitHub上でリポジトリをフォークし、その後:\ngit clone https://github.com/YOUR_USERNAME/hemlock.git\ncd hemlock\ngit checkout -b feature/your-feature-name\n```\n\n### 3. 変更を行う\n\n以下のガイドラインに従ってください:\n- 最初にテストを書く（TDDアプローチ）\n- 機能を実装する\n- すべてのテストが合格することを確認\n- メモリリークをチェック\n- ドキュメントを更新\n\n### 4. 変更をテストする\n\n```bash\n# 完全なテストスイートを実行\nmake test\n\n# 特定のテストカテゴリを実行\n./tests/run_tests.sh tests/category/\n\n# メモリリークをチェック\nvalgrind ./hemlock tests/your_test.hml\n\n# ビルドとテスト\nmake clean && make && make test\n```\n\n### 5. 変更をコミットする\n\n**良いコミットメッセージ:**\n```\n整数型にビット演算子を追加\n\n- &, |, ^, <<, >>, ~ 演算子を実装\n- 整数のみの演算を保証する型チェックを追加\n- 演算子優先順位テーブルを更新\n- すべての演算子に対する包括的なテストを追加\n\nCloses #42\n```\n\n**コミットメッセージの形式:**\n- 1行目: 簡潔な要約（最大50文字）\n- 空行\n- 詳細な説明（72文字で折り返し）\n- Issue番号を参照\n\n### 6. Pull Requestを提出する\n\n**提出前に:**\n- 最新のmainブランチにリベース\n- すべてのテストが合格することを確認\n- valgrindを実行してリークをチェック\n- ユーザー向け機能を追加する場合はCLAUDE.mdを更新\n\n**Pull Request説明には以下を含める:**\n- これが解決する問題\n- どのように解決するか\n- 破壊的変更（ある場合）\n- 新しい構文や動作の例\n- テストカバレッジの要約\n\n---\n\n## コードスタイルガイドライン\n\n### Cコードスタイル\n\n**フォーマット:**\n```c\n// 4スペースでインデント（タブなし）\n// 関数はK&R括弧スタイル\nvoid function_name(int arg1, char *arg2)\n{\n    if (condition) {\n        // 制御構造では同じ行に括弧\n        do_something();\n    }\n}\n\n// 行の長さ: 最大100文字\n// 演算子の周りにスペース\nint result = (a + b) * c;\n\n// ポインタのアスタリスクは型と一緒\nchar *string;   // 良い\nchar* string;   // 避ける\nchar * string;  // 避ける\n```\n\n**命名規則:**\n```c\n// 関数: lowercase_with_underscores\nvoid eval_expression(ASTNode *node);\n\n// 型: PascalCase\ntypedef struct Value Value;\ntypedef enum ValueType ValueType;\n\n// 定数: UPPERCASE_WITH_UNDERSCORES\n#define MAX_BUFFER_SIZE 4096\n\n// 変数: lowercase_with_underscores\nint item_count;\nValue *current_value;\n\n// 列挙型: TYPE_PREFIX_NAME\ntypedef enum {\n    TYPE_I32,\n    TYPE_STRING,\n    TYPE_OBJECT\n} ValueType;\n```\n\n**コメント:**\n```c\n// 簡潔な説明には単一行コメント\n// 適切な大文字で完全な文を使用\n\n/*\n * 長い説明には複数行コメント\n * 読みやすさのためにアスタリスクを揃える\n */\n\n/**\n * 関数のドキュメントコメント\n * @param node - 評価するASTノード\n * @return 評価された値\n */\nValue eval_expr(ASTNode *node);\n```\n\n**エラー処理:**\n```c\n// すべてのmalloc呼び出しをチェック\nchar *buffer = malloc(size);\nif (!buffer) {\n    fprintf(stderr, \"Error: Out of memory\\n\");\n    exit(1);\n}\n\n// エラーメッセージにコンテキストを提供\nif (file == NULL) {\n    fprintf(stderr, \"Error: Failed to open '%s': %s\\n\",\n            filename, strerror(errno));\n    exit(1);\n}\n\n// 意味のあるエラーメッセージを使用\n// 悪い: \"Error: Invalid value\"\n// 良い: \"Error: Expected integer, got string\"\n```\n\n**メモリ管理:**\n```c\n// 割り当てたものは常に解放\nValue *val = value_create_i32(42);\n// ... valを使用\nvalue_free(val);\n\n// 解放後にポインタをNULLに設定（ダブルフリー防止）\nfree(ptr);\nptr = NULL;\n\n// コメントで所有権をドキュメント化\n// この関数は 'value' の所有権を取得し、解放します\nvoid store_value(Value *value);\n\n// この関数は所有権を取得しません（呼び出し側が解放）\nValue *get_value(void);\n```\n\n### コード構成\n\n**ファイル構造:**\n```c\n// 1. インクルード（システムヘッダーが先、次にローカル）\n#include <stdio.h>\n#include <stdlib.h>\n#include \"internal.h\"\n#include \"values.h\"\n\n// 2. 定数とマクロ\n#define INITIAL_CAPACITY 16\n\n// 3. 型定義\ntypedef struct Foo Foo;\n\n// 4. 静的関数宣言（内部ヘルパー）\nstatic void helper_function(void);\n\n// 5. パブリック関数の実装\nvoid public_api_function(void)\n{\n    // 実装\n}\n\n// 6. 静的関数の実装\nstatic void helper_function(void)\n{\n    // 実装\n}\n```\n\n**ヘッダーファイル:**\n```c\n// ヘッダーガードを使用\n#ifndef HEMLOCK_MODULE_H\n#define HEMLOCK_MODULE_H\n\n// 前方宣言\ntypedef struct Value Value;\n\n// ヘッダーにはパブリックAPIのみ\nvoid public_function(Value *val);\n\n// パラメータと戻り値をドキュメント化\n/**\n * 式ASTノードを評価する\n * @param node - 評価するASTノード\n * @param env - 現在の環境\n * @return 結果値\n */\nValue *eval_expr(ASTNode *node, Environment *env);\n\n#endif // HEMLOCK_MODULE_H\n```\n\n---\n\n## 貢献すべきもの\n\n### ✅ 推奨される貢献\n\n**バグ修正:**\n- メモリリーク\n- セグメンテーションフォルト\n- 不正確な動作\n- エラーメッセージの改善\n\n**ドキュメント:**\n- コードコメント\n- APIドキュメント\n- ユーザーガイドとチュートリアル\n- サンプルプログラム\n- テストケースドキュメント\n\n**テスト:**\n- 既存機能の追加テストケース\n- エッジケースカバレッジ\n- 修正されたバグの回帰テスト\n- パフォーマンスベンチマーク\n\n**小規模な機能追加:**\n- 新しい組み込み関数（哲学に合う場合）\n- 文字列/配列メソッド\n- ユーティリティ関数\n- エラー処理の改善\n\n**パフォーマンス改善:**\n- より高速なアルゴリズム（セマンティクスを変更せずに）\n- メモリ使用量の削減\n- ベンチマークスイート\n- プロファイリングツール\n\n**ツーリング:**\n- エディタの構文ハイライト\n- 言語サーバープロトコル（LSP）\n- デバッガ統合\n- ビルドシステムの改善\n\n### 🤔 まず議論すること\n\n**主要な機能:**\n- 新しい言語構文\n- 型システムの変更\n- 構文の追加\n- 並行処理プリミティブ\n\n**議論の方法:**\n1. GitHub IssueまたはDiscussionを開く\n2. 機能と根拠を説明\n3. サンプルコードを示す\n4. Hemlockの哲学にどう合うか説明\n5. メンテナーのフィードバックを待つ\n6. 実装前に設計を反復\n\n---\n\n## 貢献すべきでないもの\n\n### ❌ 推奨されない貢献\n\n**以下のような機能を追加しない:**\n- ユーザーから複雑さを隠す\n- 動作を暗黙的または魔法的にする\n- 既存のセマンティクスや構文を壊す\n- ガベージコレクションや自動メモリ管理を追加\n- 「暗黙より明示」の原則に違反\n\n**却下される貢献の例:**\n\n**1. 自動セミコロン挿入**\n```hemlock\n// 悪い: これは却下されます\nlet x = 5  // セミコロンなし\nlet y = 10 // セミコロンなし\n```\n理由: 構文を曖昧にし、エラーを隠す\n\n**2. RAII/デストラクタ**\n```hemlock\n// 悪い: これは却下されます\nlet f = open(\"file.txt\");\n// スコープ終了時にファイルが自動的にクローズ\n```\n理由: リソースがいつ解放されるか隠す、明示的ではない\n\n**3. データを失う暗黙の型強制**\n```hemlock\n// 悪い: これは却下されます\nlet x: i32 = 3.14;  // 黙って3に切り捨て\n```\n理由: データ損失は暗黙ではなく明示的であるべき\n\n**4. ガベージコレクション**\n```c\n// 悪い: これは却下されます\nvoid *gc_malloc(size_t size) {\n    // 自動クリーンアップのために割り当てを追跡\n}\n```\n理由: メモリ管理を隠す、予測不可能なパフォーマンス\n\n**5. 複雑なマクロシステム**\n```hemlock\n// 悪い: これは却下されます\nmacro repeat($n, $block) {\n    for (let i = 0; i < $n; i++) $block\n}\n```\n理由: 魔法が多すぎ、コードの推論が難しくなる\n\n### 一般的な却下理由\n\n**「これは暗黙的すぎる」**\n- 解決策: 動作を明示的にしてドキュメント化\n\n**「これは複雑さを隠す」**\n- 解決策: 複雑さを露出させつつ人間工学的にする\n\n**「これは既存のコードを壊す」**\n- 解決策: 破壊的でない代替案を見つけるか、バージョニングを議論\n\n**「これはHemlockの哲学に合わない」**\n- 解決策: philosophy.mdを再読し、アプローチを再検討\n\n---\n\n## 共通パターン\n\n### エラー処理パターン\n\n```c\n// Hemlockコードでの回復可能なエラーにはこのパターンを使用\nValue *divide(Value *a, Value *b)\n{\n    // 前提条件をチェック\n    if (b->type != TYPE_I32) {\n        // エラー値を返すか例外をスロー\n        return create_error(\"Expected integer divisor\");\n    }\n\n    if (b->i32_value == 0) {\n        return create_error(\"Division by zero\");\n    }\n\n    // 操作を実行\n    return value_create_i32(a->i32_value / b->i32_value);\n}\n```\n\n### メモリ管理パターン\n\n```c\n// パターン: 割り当て、使用、解放\nvoid process_data(void)\n{\n    // 割り当て\n    Buffer *buf = create_buffer(1024);\n    char *str = malloc(256);\n\n    // 使用\n    if (buf && str) {\n        // ... 作業を行う\n    }\n\n    // 解放（割り当ての逆順で）\n    free(str);\n    free_buffer(buf);\n}\n```\n\n### 値作成パターン\n\n```c\n// コンストラクタを使用して値を作成\nValue *create_integer(int32_t n)\n{\n    Value *val = malloc(sizeof(Value));\n    if (!val) {\n        fprintf(stderr, \"Out of memory\\n\");\n        exit(1);\n    }\n\n    val->type = TYPE_I32;\n    val->i32_value = n;\n    return val;\n}\n```\n\n### 型チェックパターン\n\n```c\n// 操作前に型をチェック\nValue *add_values(Value *a, Value *b)\n{\n    // 型チェック\n    if (a->type != TYPE_I32 || b->type != TYPE_I32) {\n        return create_error(\"Type mismatch\");\n    }\n\n    // 安全に進行\n    return value_create_i32(a->i32_value + b->i32_value);\n}\n```\n\n### 文字列構築パターン\n\n```c\n// 効率的に文字列を構築\nvoid build_error_message(char *buffer, size_t size, const char *detail)\n{\n    snprintf(buffer, size, \"Error: %s (line %d)\", detail, line_number);\n}\n```\n\n---\n\n## 新機能の追加\n\n### 機能追加チェックリスト\n\n新機能を追加する際は、以下のステップに従ってください:\n\n#### 1. 設計フェーズ\n\n- [ ] philosophy.mdを読んで整合性を確認\n- [ ] 機能を説明するGitHub Issueを作成\n- [ ] 設計のメンテナー承認を取得\n- [ ] 仕様を書く（構文、セマンティクス、例）\n- [ ] エッジケースとエラー条件を検討\n\n#### 2. 実装フェーズ\n\n**言語構文を追加する場合:**\n\n- [ ] `lexer.h`にトークン型を追加（必要に応じて）\n- [ ] `lexer.c`にレキサールールを追加（必要に応じて）\n- [ ] `ast.h`にASTノード型を追加\n- [ ] `ast.c`にASTコンストラクタを追加\n- [ ] `parser.c`にパーサールールを追加\n- [ ] `runtime.c`または適切なモジュールにランタイム動作を追加\n- [ ] ASTフリー関数でクリーンアップを処理\n\n**組み込み関数を追加する場合:**\n\n- [ ] `builtins.c`に関数実装を追加\n- [ ] `register_builtins()`で関数を登録\n- [ ] すべてのパラメータ型の組み合わせを処理\n- [ ] 適切なエラー値を返す\n- [ ] パラメータと戻り値型をドキュメント化\n\n**値型を追加する場合:**\n\n- [ ] `values.h`に型列挙型を追加\n- [ ] Valueユニオンにフィールドを追加\n- [ ] `values.c`にコンストラクタを追加\n- [ ] クリーンアップ用に`value_free()`に追加\n- [ ] コピー用に`value_copy()`に追加\n- [ ] 印刷用に`value_to_string()`に追加\n- [ ] 数値の場合は型プロモーションルールを追加\n\n#### 3. テストフェーズ\n\n- [ ] テストケースを書く（testing.mdを参照）\n- [ ] 成功ケースをテスト\n- [ ] エラーケースをテスト\n- [ ] エッジケースをテスト\n- [ ] 完全なテストスイートを実行（`make test`）\n- [ ] valgrindでメモリリークをチェック\n- [ ] 可能であれば複数のプラットフォームでテスト\n\n#### 4. ドキュメントフェーズ\n\n- [ ] ユーザー向けドキュメントでCLAUDE.mdを更新\n- [ ] 実装を説明するコードコメントを追加\n- [ ] `examples/`に例を作成\n- [ ] 関連するdocs/ファイルを更新\n- [ ] 破壊的変更をドキュメント化\n\n#### 5. 提出フェーズ\n\n- [ ] デバッグコードとコメントをクリーンアップ\n- [ ] コードスタイル準拠を確認\n- [ ] 最新のmainにリベース\n- [ ] 詳細な説明付きでPull Requestを作成\n- [ ] コードレビューフィードバックに対応\n\n### 例: 新しい演算子の追加\n\n例として剰余演算子`%`の追加を見てみましょう:\n\n**1. レキサー (lexer.c):**\n```c\n// get_next_token()のswitch文に追加\ncase '%':\n    return create_token(TOKEN_PERCENT, \"%\", line);\n```\n\n**2. レキサーヘッダー (lexer.h):**\n```c\ntypedef enum {\n    // ... 既存のトークン\n    TOKEN_PERCENT,\n    // ...\n} TokenType;\n```\n\n**3. AST (ast.h):**\n```c\ntypedef enum {\n    // ... 既存の演算子\n    OP_MOD,\n    // ...\n} BinaryOp;\n```\n\n**4. パーサー (parser.c):**\n```c\n// parse_multiplicative()または適切な優先順位レベルに追加\nif (match(TOKEN_PERCENT)) {\n    BinaryOp op = OP_MOD;\n    ASTNode *right = parse_unary();\n    left = create_binary_op_node(op, left, right);\n}\n```\n\n**5. ランタイム (runtime.c):**\n```c\n// eval_binary_op()に追加\ncase OP_MOD:\n    // 型チェック\n    if (left->type == TYPE_I32 && right->type == TYPE_I32) {\n        if (right->i32_value == 0) {\n            fprintf(stderr, \"Error: Modulo by zero\\n\");\n            exit(1);\n        }\n        return value_create_i32(left->i32_value % right->i32_value);\n    }\n    // ... 他の型の組み合わせを処理\n    break;\n```\n\n**6. テスト (tests/operators/modulo.hml):**\n```hemlock\n// 基本的な剰余\nprint(10 % 3);  // 期待: 2\n\n// 負の剰余\nprint(-10 % 3); // 期待: -1\n\n// エラーケース（失敗するはず）\n// print(10 % 0);  // ゼロ除算\n```\n\n**7. ドキュメント (CLAUDE.md):**\n```markdown\n### 算術演算子\n- `+` - 加算\n- `-` - 減算\n- `*` - 乗算\n- `/` - 除算\n- `%` - 剰余（余り）\n```\n\n---\n\n## コードレビュープロセス\n\n### レビュアーが確認すること\n\n**1. 正確性**\n- コードは主張通りに動作するか？\n- エッジケースは処理されているか？\n- メモリリークはないか？\n- エラーは適切に処理されているか？\n\n**2. 哲学との整合性**\n- これはHemlockの設計原則に合っているか？\n- 明示的か暗黙的か？\n- 複雑さを隠していないか？\n\n**3. コード品質**\n- コードは読みやすく保守可能か？\n- 変数名は説明的か？\n- 関数は適切なサイズか？\n- 十分なドキュメントがあるか？\n\n**4. テスト**\n- 十分なテストケースがあるか？\n- テストは成功と失敗のパスをカバーしているか？\n- エッジケースはテストされているか？\n\n**5. ドキュメント**\n- ユーザー向けドキュメントは更新されているか？\n- コードコメントは明確か？\n- 例は提供されているか？\n\n### フィードバックへの対応\n\n**すべきこと:**\n- レビュアーの時間に感謝する\n- 理解できない場合は明確化の質問をする\n- 同意しない場合は理由を説明する\n- 要求された変更を迅速に行う\n- スコープが変更された場合はPR説明を更新\n\n**すべきでないこと:**\n- 批判を個人的に受け取る\n- 防御的に議論する\n- フィードバックを無視する\n- レビューコメントの上に強制プッシュする（リベースを除く）\n- PRに無関係な変更を追加する\n\n### PRをマージしてもらう\n\n**マージの要件:**\n- [ ] すべてのテストが合格\n- [ ] メモリリークなし（valgrindクリーン）\n- [ ] メンテナーからのコードレビュー承認\n- [ ] ドキュメント更新済み\n- [ ] コードスタイルガイドラインに従っている\n- [ ] Hemlockの哲学に沿っている\n\n**タイムライン:**\n- 小さなPR（バグ修正）: 通常数日以内にレビュー\n- 中程度のPR（新機能）: 1-2週間かかる可能性あり\n- 大きなPR（主要な変更）: 広範な議論が必要\n\n---\n\n## 追加リソース\n\n### 学習リソース\n\n**インタプリタの理解:**\n- \"Crafting Interpreters\" by Robert Nystrom\n- \"Writing An Interpreter In Go\" by Thorsten Ball\n- \"Modern Compiler Implementation in C\" by Andrew Appel\n\n**Cプログラミング:**\n- \"The C Programming Language\" by K&R\n- \"Expert C Programming\" by Peter van der Linden\n- \"C Interfaces and Implementations\" by David Hanson\n\n**メモリ管理:**\n- Valgrindドキュメント\n- \"Understanding and Using C Pointers\" by Richard Reese\n\n### 便利なコマンド\n\n```bash\n# デバッグシンボル付きでビルド\nmake clean && make CFLAGS=\"-g -O0\"\n\n# valgrindで実行\nvalgrind --leak-check=full ./hemlock script.hml\n\n# 特定のテストカテゴリを実行\n./tests/run_tests.sh tests/strings/\n\n# コードナビゲーション用のタグファイルを生成\nctags -R .\n\n# すべてのTODOとFIXMEを見つける\ngrep -rn \"TODO\\|FIXME\" src/ include/\n```\n\n---\n\n## 質問?\n\n貢献について質問がある場合:\n\n1. `docs/`のドキュメントを確認\n2. 既存のGitHub Issueを検索\n3. GitHub Discussionsで質問\n4. 質問を含む新しいIssueを開く\n\n**Hemlockへの貢献ありがとうございます！**\n"}, "コントリビューション -> テスト": {"id": "contributing-testing", "content": "# Hemlockテストガイド\n\nこのガイドでは、Hemlockのテスト哲学、テストの書き方、テストスイートの実行方法を説明します。\n\n---\n\n## 目次\n\n- [テスト哲学](#テスト哲学)\n- [テストスイートの構造](#テストスイートの構造)\n- [テストの実行](#テストの実行)\n- [テストの作成](#テストの作成)\n- [テストカテゴリ](#テストカテゴリ)\n- [メモリリークテスト](#メモリリークテスト)\n- [継続的インテグレーション](#継続的インテグレーション)\n- [ベストプラクティス](#ベストプラクティス)\n\n---\n\n## テスト哲学\n\n### 核となる原則\n\n**1. テスト駆動開発（TDD）**\n\n機能を実装する**前に**テストを書く:\n\n```\n1. 失敗するテストを書く\n2. 機能を実装する\n3. テストを実行する（合格するはず）\n4. 必要に応じてリファクタリング\n5. 繰り返す\n```\n\n**利点:**\n- 機能が実際に動作することを確認\n- 回帰を防ぐ\n- 期待される動作をドキュメント化\n- リファクタリングを安全にする\n\n**2. 包括的なカバレッジ**\n\n成功と失敗の両方のケースをテスト:\n\n```hemlock\n// 成功ケース\nlet x: u8 = 255;  // 動作するはず\n\n// 失敗ケース\nlet y: u8 = 256;  // エラーになるはず\n```\n\n**3. 早期かつ頻繁にテスト**\n\n以下のタイミングでテストを実行:\n- コードをコミットする前\n- 変更を加えた後\n- プルリクエストを提出する前\n- コードレビュー中\n\n**ルール:** マージ前にすべてのテストが合格する必要があります。\n\n### テストすべきもの\n\n**常にテストすべきもの:**\n- ✅ 基本機能（ハッピーパス）\n- ✅ エラー条件（サッドパス）\n- ✅ エッジケース（境界条件）\n- ✅ 型チェックと変換\n- ✅ メモリ管理（リークなし）\n- ✅ 並行処理と競合状態\n\n**テストカバレッジの例:**\n```hemlock\n// 機能: String.substr(start, length)\n\n// ハッピーパス\nprint(\"hello\".substr(0, 5));  // \"hello\"\n\n// エッジケース\nprint(\"hello\".substr(0, 0));  // \"\"（空）\nprint(\"hello\".substr(5, 0));  // \"\"（末尾で）\nprint(\"hello\".substr(2, 100)); // \"llo\"（末尾を超える）\n\n// エラーケース\n// \"hello\".substr(-1, 5);  // エラー: 負のインデックス\n// \"hello\".substr(0, -1);  // エラー: 負の長さ\n```\n\n---\n\n## テストスイートの構造\n\n### ディレクトリ構成\n\n```\ntests/\n├── run_tests.sh          # メインのテストランナースクリプト\n├── primitives/           # 型システムテスト\n│   ├── integers.hml\n│   ├── floats.hml\n│   ├── booleans.hml\n│   ├── i64.hml\n│   └── u64.hml\n├── conversions/          # 型変換テスト\n│   ├── int_to_float.hml\n│   ├── promotion.hml\n│   └── rune_conversions.hml\n├── memory/               # ポインタ/バッファテスト\n│   ├── alloc.hml\n│   ├── buffer.hml\n│   └── memcpy.hml\n├── strings/              # 文字列操作テスト\n│   ├── concat.hml\n│   ├── methods.hml\n│   ├── utf8.hml\n│   └── runes.hml\n├── control/              # 制御フローテスト\n│   ├── if.hml\n│   ├── switch.hml\n│   └── while.hml\n├── functions/            # 関数とクロージャテスト\n│   ├── basics.hml\n│   ├── closures.hml\n│   └── recursion.hml\n├── objects/              # オブジェクトテスト\n│   ├── literals.hml\n│   ├── methods.hml\n│   ├── duck_typing.hml\n│   └── serialization.hml\n├── arrays/               # 配列操作テスト\n│   ├── basics.hml\n│   ├── methods.hml\n│   └── slicing.hml\n├── loops/                # ループテスト\n│   ├── for.hml\n│   ├── while.hml\n│   ├── break.hml\n│   └── continue.hml\n├── exceptions/           # エラー処理テスト\n│   ├── try_catch.hml\n│   ├── finally.hml\n│   └── throw.hml\n├── io/                   # ファイルI/Oテスト\n│   ├── file_object.hml\n│   ├── read_write.hml\n│   └── seek.hml\n├── async/                # 並行処理テスト\n│   ├── spawn_join.hml\n│   ├── channels.hml\n│   └── exceptions.hml\n├── ffi/                  # FFIテスト\n│   ├── basic_call.hml\n│   ├── types.hml\n│   └── dlopen.hml\n├── signals/              # シグナル処理テスト\n│   ├── basic.hml\n│   ├── handlers.hml\n│   └── raise.hml\n└── args/                 # コマンドライン引数テスト\n    └── basic.hml\n```\n\n### テストファイルの命名\n\n**規則:**\n- 説明的な名前を使用: `method_chaining.hml`ではなく`test1.hml`\n- 関連テストをグループ化: `string_substr.hml`、`string_slice.hml`\n- 1ファイルに1つの機能領域\n- ファイルを焦点を絞った小さなものに保つ\n\n---\n\n## テストの実行\n\n### すべてのテストを実行\n\n```bash\n# hemlockルートディレクトリから\nmake test\n\n# または直接\n./tests/run_tests.sh\n```\n\n**出力:**\n```\nRunning tests in tests/primitives/...\n  ✓ integers.hml\n  ✓ floats.hml\n  ✓ booleans.hml\n\nRunning tests in tests/strings/...\n  ✓ concat.hml\n  ✓ methods.hml\n\n...\n\nTotal: 251 tests\nPassed: 251\nFailed: 0\n```\n\n### 特定のカテゴリを実行\n\n```bash\n# 文字列テストのみ実行\n./tests/run_tests.sh tests/strings/\n\n# 1つのテストファイルのみ実行\n./tests/run_tests.sh tests/strings/concat.hml\n\n# 複数のカテゴリを実行\n./tests/run_tests.sh tests/strings/ tests/arrays/\n```\n\n### Valgrindで実行（メモリリークチェック）\n\n```bash\n# 単一テストのリークをチェック\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\n\n# すべてのテストをチェック（遅い！）\nfor test in tests/**/*.hml; do\n    echo \"Testing $test\"\n    valgrind --leak-check=full --error-exitcode=1 ./hemlock \"$test\"\ndone\n```\n\n### 失敗したテストのデバッグ\n\n```bash\n# 詳細出力で実行\n./hemlock tests/failing_test.hml\n\n# gdbで実行\ngdb --args ./hemlock tests/failing_test.hml\n(gdb) run\n(gdb) backtrace  # クラッシュした場合\n```\n\n---\n\n## テストの作成\n\n### テストファイルの形式\n\nテストファイルは期待出力を持つHemlockプログラムです:\n\n**例: tests/primitives/integers.hml**\n```hemlock\n// 基本的な整数リテラルをテスト\nlet x = 42;\nprint(x);  // 期待: 42\n\nlet y: i32 = 100;\nprint(y);  // 期待: 100\n\n// 算術をテスト\nlet sum = x + y;\nprint(sum);  // 期待: 142\n\n// 型推論をテスト\nlet small = 10;\nprint(typeof(small));  // 期待: i32\n\nlet large = 5000000000;\nprint(typeof(large));  // 期待: i64\n```\n\n**テストの動作:**\n1. テストランナーが.hmlファイルを実行\n2. stdout出力をキャプチャ\n3. 期待出力と比較（コメントまたは別の.outファイルから）\n4. 合格/不合格を報告\n\n### 期待出力の方法\n\n**方法1: インラインコメント（シンプルなテストに推奨）**\n\n```hemlock\nprint(\"hello\");  // 期待: hello\nprint(42);       // 期待: 42\n```\n\nテストランナーは`// 期待: ...`コメントをパースします。\n\n**方法2: 別の.outファイル**\n\n期待出力で`test_name.hml.out`を作成:\n\n**test_name.hml:**\n```hemlock\nprint(\"line 1\");\nprint(\"line 2\");\nprint(\"line 3\");\n```\n\n**test_name.hml.out:**\n```\nline 1\nline 2\nline 3\n```\n\n### エラーケースのテスト\n\nエラーテストは非ゼロステータスでプログラムを終了させるべき:\n\n**例: tests/primitives/range_error.hml**\n```hemlock\n// これは型エラーで失敗するはず\nlet x: u8 = 256;  // u8の範囲外\n```\n\n**期待される動作:**\n- プログラムは非ゼロステータスで終了\n- stderrにエラーメッセージを出力\n\n**テストランナーの処理:**\n- エラーを期待するテストは別ファイルにすべき\n- 命名規則を使用: `*_error.hml`または`*_fail.hml`\n- 期待されるエラーをコメントでドキュメント化\n\n### 成功ケースのテスト\n\n**例: tests/strings/methods.hml**\n```hemlock\n// substrをテスト\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);\nprint(sub);  // 期待: world\n\n// findをテスト\nlet pos = s.find(\"world\");\nprint(pos);  // 期待: 6\n\n// containsをテスト\nlet has = s.contains(\"lo\");\nprint(has);  // 期待: true\n\n// trimをテスト\nlet padded = \"  hello  \";\nlet trimmed = padded.trim();\nprint(trimmed);  // 期待: hello\n```\n\n### エッジケースのテスト\n\n**例: tests/arrays/edge_cases.hml**\n```hemlock\n// 空の配列\nlet empty = [];\nprint(empty.length);  // 期待: 0\n\n// 単一要素\nlet single = [42];\nprint(single[0]);  // 期待: 42\n\n// 負のインデックス（別のテストファイルでエラーになるはず）\n// print(single[-1]);  // エラー\n\n// 末尾を超えるインデックス（エラーになるはず）\n// print(single[100]);  // エラー\n\n// 境界条件\nlet arr = [1, 2, 3];\nprint(arr.slice(0, 0));  // 期待: []（空）\nprint(arr.slice(3, 3));  // 期待: []（空）\nprint(arr.slice(1, 2));  // 期待: [2]\n```\n\n### 型システムのテスト\n\n**例: tests/conversions/promotion.hml**\n```hemlock\n// 二項演算での型プロモーションをテスト\n\n// i32 + i64 -> i64\nlet a: i32 = 10;\nlet b: i64 = 20;\nlet c = a + b;\nprint(typeof(c));  // 期待: i64\n\n// i32 + f32 -> f32\nlet d: i32 = 10;\nlet e: f32 = 3.14;\nlet f = d + e;\nprint(typeof(f));  // 期待: f32\n\n// u8 + i32 -> i32\nlet g: u8 = 5;\nlet h: i32 = 10;\nlet i = g + h;\nprint(typeof(i));  // 期待: i32\n```\n\n### 並行処理のテスト\n\n**例: tests/async/basic.hml**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// タスクをスポーン\nlet t1 = spawn(compute, 10);\nlet t2 = spawn(compute, 20);\n\n// 結果をジョインして出力\nlet r1 = join(t1);\nlet r2 = join(t2);\nprint(r1);  // 期待: 45\nprint(r2);  // 期待: 190\n```\n\n### 例外のテスト\n\n**例: tests/exceptions/try_catch.hml**\n```hemlock\n// 基本的なtry/catchをテスト\ntry {\n    throw \"error message\";\n} catch (e) {\n    print(\"Caught: \" + e);  // 期待: Caught: error message\n}\n\n// finallyをテスト\nlet executed = false;\ntry {\n    print(\"try\");  // 期待: try\n} finally {\n    executed = true;\n    print(\"finally\");  // 期待: finally\n}\n\n// 例外伝播をテスト\nfn risky(): i32 {\n    throw \"failure\";\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(e);  // 期待: failure\n}\n```\n\n---\n\n## テストカテゴリ\n\n### プリミティブテスト\n\n**テストすべきもの:**\n- 整数型（i8、i16、i32、i64、u8、u16、u32、u64）\n- 浮動小数点型（f32、f64）\n- ブール型\n- 文字列型\n- ルーン型\n- Null型\n\n**テスト領域の例:**\n- リテラル構文\n- 型推論\n- 範囲チェック\n- オーバーフロー動作\n- 型注釈\n\n### 変換テスト\n\n**テストすべきもの:**\n- 暗黙の型プロモーション\n- 明示的な型変換\n- 損失のある変換（エラーになるべき）\n- 操作での型プロモーション\n- 異なる型間の比較\n\n### メモリテスト\n\n**テストすべきもの:**\n- alloc/freeの正確性\n- バッファの作成とアクセス\n- バッファの境界チェック\n- memset、memcpy、realloc\n- メモリリーク検出（valgrind）\n\n### 文字列テスト\n\n**テストすべきもの:**\n- 連結\n- 全18の文字列メソッド\n- UTF-8処理\n- ルーンインデックス\n- 文字列 + ルーン連結\n- エッジケース（空文字列、単一文字など）\n\n### 制御フローテスト\n\n**テストすべきもの:**\n- if/else/else if\n- whileループ\n- forループ\n- switch文\n- break/continue\n- return文\n\n### 関数テスト\n\n**テストすべきもの:**\n- 関数定義と呼び出し\n- パラメータ渡し\n- 戻り値\n- 再帰\n- クロージャとキャプチャ\n- ファーストクラス関数\n- 無名関数\n\n### オブジェクトテスト\n\n**テストすべきもの:**\n- オブジェクトリテラル\n- フィールドアクセスと代入\n- メソッドとselfバインディング\n- ダックタイピング\n- オプションフィールド\n- JSONシリアライゼーション/デシリアライゼーション\n- 循環参照検出\n\n### 配列テスト\n\n**テストすべきもの:**\n- 配列作成\n- インデックスと代入\n- 全15の配列メソッド\n- 混合型\n- 動的リサイズ\n- エッジケース（空、単一要素）\n\n### 例外テスト\n\n**テストすべきもの:**\n- try/catch/finally\n- throw文\n- 例外伝播\n- ネストされたtry/catch\n- try/catch/finally内でのreturn\n- キャッチされない例外\n\n### I/Oテスト\n\n**テストすべきもの:**\n- ファイルオープンモード\n- 読み書き操作\n- seek/tell\n- ファイルプロパティ\n- エラー処理（ファイルがないなど）\n- リソースクリーンアップ\n\n### 非同期テスト\n\n**テストすべきもの:**\n- spawn/join/detach\n- チャネルsend/recv\n- タスク内での例外伝播\n- 複数の並行タスク\n- チャネルのブロッキング動作\n\n### FFIテスト\n\n**テストすべきもの:**\n- dlopen/dlclose\n- dlsym\n- 様々な型でのdlcall\n- 型変換\n- エラー処理\n\n---\n\n## メモリリークテスト\n\n### Valgrindの使用\n\n**基本的な使い方:**\n```bash\nvalgrind --leak-check=full ./hemlock test.hml\n```\n\n**出力例（リークなし）:**\n```\n==12345== HEAP SUMMARY:\n==12345==     in use at exit: 0 bytes in 0 blocks\n==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated\n==12345==\n==12345== All heap blocks were freed -- no leaks are possible\n```\n\n**出力例（リークあり）:**\n```\n==12345== LEAK SUMMARY:\n==12345==    definitely lost: 64 bytes in 1 blocks\n==12345==    indirectly lost: 0 bytes in 0 blocks\n==12345==      possibly lost: 0 bytes in 0 blocks\n==12345==    still reachable: 0 bytes in 0 blocks\n==12345==         suppressed: 0 bytes in 0 blocks\n```\n\n### 一般的なリークの原因\n\n**1. free()呼び出しの欠落:**\n```c\n// 悪い\nchar *str = malloc(100);\n// ... strを使用\n// 解放を忘れた！\n\n// 良い\nchar *str = malloc(100);\n// ... strを使用\nfree(str);\n```\n\n**2. ポインタの消失:**\n```c\n// 悪い\nchar *ptr = malloc(100);\nptr = malloc(200);  // 最初の割り当てへの参照を失った！\n\n// 良い\nchar *ptr = malloc(100);\nfree(ptr);\nptr = malloc(200);\n```\n\n**3. 例外パス:**\n```c\n// 悪い\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        return;  // リーク！\n    }\n    free(data);\n}\n\n// 良い\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        free(data);\n        return;\n    }\n    free(data);\n}\n```\n\n### 既知の許容可能なリーク\n\nいくつかの小さな「リーク」は意図的な起動時割り当てです:\n\n**グローバルビルトイン:**\n```hemlock\n// 組み込み関数、FFI型、定数は起動時に割り当てられ\n// 終了時に解放されない（通常〜200バイト）\n```\n\nこれらは真のリークではなく - プログラムの寿命中持続し、終了時にOSによってクリーンアップされる一度限りの割り当てです。\n\n---\n\n## 継続的インテグレーション\n\n### GitHub Actions（将来）\n\nCIがセットアップされると、すべてのテストは以下で自動的に実行されます:\n- mainブランチへのプッシュ\n- プルリクエストの作成/更新\n- スケジュールされた毎日の実行\n\n**CIワークフロー:**\n1. Hemlockをビルド\n2. テストスイートを実行\n3. メモリリークをチェック（valgrind）\n4. 結果をPRに報告\n\n### コミット前チェック\n\nコミット前に実行:\n\n```bash\n# 新規ビルド\nmake clean && make\n\n# すべてのテストを実行\nmake test\n\n# いくつかのテストでリークをチェック\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\nvalgrind --leak-check=full ./hemlock tests/strings/concat.hml\n```\n\n---\n\n## ベストプラクティス\n\n### すべきこと\n\n✅ **最初にテストを書く（TDD）**\n```bash\n1. tests/feature/new_feature.hmlを作成\n2. src/に機能を実装\n3. テストが合格するまで実行\n```\n\n✅ **成功と失敗の両方をテスト**\n```hemlock\n// 成功: tests/feature/success.hml\nlet result = do_thing();\nprint(result);  // 期待: expected value\n\n// 失敗: tests/feature/failure.hml\ndo_invalid_thing();  // エラーになるはず\n```\n\n✅ **説明的なテスト名を使用**\n```\n良い: tests/strings/substr_utf8_boundary.hml\n悪い: tests/test1.hml\n```\n\n✅ **テストを焦点を絞ったものに保つ**\n- 1ファイルに1つの機能領域\n- 明確なセットアップとアサーション\n- 最小限のコード\n\n✅ **難しいテストを説明するコメントを追加**\n```hemlock\n// クロージャが外部変数を参照でキャプチャすることをテスト\nfn outer() {\n    let x = 10;\n    let f = fn() { return x; };\n    x = 20;  // クロージャ作成後に変更\n    return f();  // 10ではなく20を返すはず\n}\n```\n\n✅ **エッジケースをテスト**\n- 空の入力\n- Null値\n- 境界値（最小/最大）\n- 大きな入力\n- 負の値\n\n### すべきでないこと\n\n❌ **テストをスキップしない**\n- マージ前にすべてのテストが合格する必要がある\n- 失敗するテストをコメントアウトしない\n- バグを修正するか機能を削除する\n\n❌ **互いに依存するテストを書かない**\n```hemlock\n// 悪い: test2.hmlがtest1.hmlの出力に依存\n// テストは独立しているべき\n```\n\n❌ **テストでランダム値を使用しない**\n```hemlock\n// 悪い: 非決定論的\nlet x = random();\nprint(x);  // 出力を予測できない\n\n// 良い: 決定論的\nlet x = 42;\nprint(x);  // 期待: 42\n```\n\n❌ **実装の詳細をテストしない**\n```hemlock\n// 悪い: 内部構造をテスト\nlet obj = { x: 10 };\n// 内部フィールド順序、容量などをチェックしない\n\n// 良い: 動作をテスト\nprint(obj.x);  // 期待: 10\n```\n\n❌ **メモリリークを無視しない**\n- すべてのテストはvalgrindクリーンであるべき\n- 既知/許容可能なリークをドキュメント化\n- マージ前にリークを修正\n\n### テストの保守\n\n**テストを更新すべきとき:**\n- 機能の動作が変更された\n- バグ修正に新しいテストケースが必要\n- エッジケースが発見された\n- パフォーマンス改善\n\n**テストを削除すべきとき:**\n- 機能が言語から削除された\n- テストが既存のカバレッジと重複\n- テストが不正確だった\n\n**テストのリファクタリング:**\n- 関連テストをグループ化\n- 共通のセットアップコードを抽出\n- 一貫した命名を使用\n- テストをシンプルで読みやすく保つ\n\n---\n\n## テストセッションの例\n\n機能をテストと共に追加する完全な例を示します:\n\n### 機能: `array.first()`メソッドの追加\n\n**1. まずテストを書く:**\n\n```bash\n# テストファイルを作成\ncat > tests/arrays/first_method.hml << 'EOF'\n// array.first()メソッドをテスト\n\n// 基本ケース\nlet arr = [1, 2, 3];\nprint(arr.first());  // 期待: 1\n\n// 単一要素\nlet single = [42];\nprint(single.first());  // 期待: 42\n\n// 空の配列（エラーになるべき - 別のテストファイル）\n// let empty = [];\n// print(empty.first());  // エラー\nEOF\n```\n\n**2. テストを実行（失敗するはず）:**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n# エラー: Method 'first' not found on array\n```\n\n**3. 機能を実装:**\n\n`src/interpreter/builtins.c`を編集:\n\n```c\n// array_firstメソッドを追加\nValue *array_first(Value *self, Value **args, int arg_count)\n{\n    if (self->array_value->length == 0) {\n        fprintf(stderr, \"Error: Cannot get first element of empty array\\n\");\n        exit(1);\n    }\n\n    return value_copy(&self->array_value->elements[0]);\n}\n\n// 配列メソッドテーブルに登録\n// ... 配列メソッド登録に追加\n```\n\n**4. テストを実行（合格するはず）:**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n1\n42\n# 成功！\n```\n\n**5. メモリリークをチェック:**\n\n```bash\nvalgrind --leak-check=full ./hemlock tests/arrays/first_method.hml\n# All heap blocks were freed -- no leaks are possible\n```\n\n**6. 完全なテストスイートを実行:**\n\n```bash\nmake test\n# Total: 252 tests (251 + 新しいもの)\n# Passed: 252\n# Failed: 0\n```\n\n**7. コミット:**\n\n```bash\ngit add tests/arrays/first_method.hml src/interpreter/builtins.c\ngit commit -m \"array.first()メソッドをテストと共に追加\"\n```\n\n---\n\n## まとめ\n\n**覚えておいてください:**\n- 最初にテストを書く（TDD）\n- 成功と失敗のケースをテスト\n- コミット前にすべてのテストを実行\n- メモリリークをチェック\n- 既知の問題をドキュメント化\n- テストをシンプルで焦点を絞ったものに保つ\n\n**テスト品質はコード品質と同じくらい重要です！**\n"}, "hpm: はじめに -> インストール": {"id": "hpm-installation", "content": "# インストール\n\nこのガイドでは、システムにhpmをインストールする方法を説明します。\n\n## クイックインストール（推奨）\n\n1つのコマンドで最新リリースをインストール:\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\nこれは自動的に:\n- オペレーティングシステムを検出（Linux、macOS）\n- アーキテクチャを検出（x86_64、arm64）\n- 適切なビルド済みバイナリをダウンロード\n- `/usr/local/bin`にインストール（必要に応じてsudoを使用）\n\n### インストールオプション\n\n```bash\n# カスタム場所にインストール（sudoが不要）\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local\n\n# 特定のバージョンをインストール\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5\n\n# オプションの組み合わせ\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5\n```\n\n### サポートされるプラットフォーム\n\n| プラットフォーム | アーキテクチャ | ステータス |\n|----------|--------------|--------|\n| Linux    | x86_64       | ✓ サポート |\n| macOS    | x86_64       | ✓ サポート |\n| macOS    | arm64 (M1/M2/M3) | ✓ サポート |\n| Linux    | arm64        | ソースからビルド |\n\n## ソースからビルド\n\nソースからビルドしたい場合、またはビルド済みバイナリでカバーされていないプラットフォームが必要な場合は、以下の手順に従ってください。\n\n### 前提条件\n\nhpmは最初に[Hemlock](https://github.com/hemlang/hemlock)がインストールされている必要があります。続行する前にHemlockのインストール手順に従ってください。\n\nHemlockがインストールされていることを確認:\n\n```bash\nhemlock --version\n```\n\n## インストール方法\n\n### 方法1: Make Install\n\nソースからビルドしてインストール。\n\n```bash\n# リポジトリをクローン\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# /usr/local/binにインストール（sudoが必要）\nsudo make install\n```\n\nインストール後、動作を確認:\n\n```bash\nhpm --version\n```\n\n### 方法2: カスタム場所\n\nカスタムディレクトリにインストール（sudoが不要）:\n\n```bash\n# リポジトリをクローン\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# ~/.local/binにインストール\nmake install PREFIX=$HOME/.local\n\n# または任意のカスタム場所\nmake install PREFIX=/opt/hemlock\n```\n\nカスタムbinディレクトリがPATHに含まれていることを確認:\n\n```bash\n# ~/.bashrcまたは~/.zshrcに追加\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n### 方法3: インストールせずに実行\n\nhpmをインストールせずに直接実行できます:\n\n```bash\n# リポジトリをクローン\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# ローカルラッパースクリプトを作成\nmake\n\n# hpmディレクトリから実行\n./hpm --help\n\n# またはhemlockで直接実行\nhemlock src/main.hml --help\n```\n\n### 方法4: 手動インストール\n\n独自のラッパースクリプトを作成:\n\n```bash\n# 永続的な場所にクローン\ngit clone https://github.com/hemlang/hpm.git ~/.hpm-source\n\n# ラッパースクリプトを作成\ncat > ~/.local/bin/hpm << 'EOF'\n#!/bin/sh\nexec hemlock \"$HOME/.hpm-source/src/main.hml\" \"$@\"\nEOF\n\nchmod +x ~/.local/bin/hpm\n```\n\n## インストール変数\n\nMakefileは以下の変数をサポート:\n\n| 変数 | デフォルト | 説明 |\n|----------|---------|-------------|\n| `PREFIX` | `/usr/local` | インストールプレフィックス |\n| `BINDIR` | `$(PREFIX)/bin` | バイナリディレクトリ |\n| `HEMLOCK` | `hemlock` | hemlockインタプリタへのパス |\n\nカスタム変数を使用した例:\n\n```bash\nmake install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock\n```\n\n## 仕組み\n\nインストーラはhpmソースコードでHemlockインタプリタを呼び出すシェルラッパースクリプトを作成します:\n\n```bash\n#!/bin/sh\nexec hemlock \"/path/to/hpm/src/main.hml\" \"$@\"\n```\n\nこのアプローチ:\n- コンパイルが不要\n- 常に最新のソースコードを実行\n- すべてのプラットフォームで確実に動作\n\n## hpmの更新\n\nhpmを最新バージョンに更新するには:\n\n```bash\ncd /path/to/hpm\ngit pull origin main\n\n# パスが変更された場合は再インストール\nsudo make install\n```\n\n## アンインストール\n\nシステムからhpmを削除:\n\n```bash\ncd /path/to/hpm\nsudo make uninstall\n```\n\nまたは手動で削除:\n\n```bash\nsudo rm /usr/local/bin/hpm\n```\n\n## インストールの確認\n\nインストール後、すべてが動作することを確認:\n\n```bash\n# バージョンを確認\nhpm --version\n\n# ヘルプを表示\nhpm --help\n\n# 初期化をテスト（空のディレクトリで）\nmkdir test-project && cd test-project\nhpm init --yes\ncat package.json\n```\n\n## トラブルシューティング\n\n### \"hemlock: command not found\"\n\nHemlockがインストールされていないかPATHにありません。まずHemlockをインストール:\n\n```bash\n# hemlockが存在するか確認\nwhich hemlock\n\n# 見つからない場合、https://github.com/hemlang/hemlockからHemlockをインストール\n```\n\n### \"Permission denied\"\n\nシステム全体へのインストールにはsudoを使用するか、ユーザーディレクトリにインストール:\n\n```bash\n# オプション1: sudoを使用\nsudo make install\n\n# オプション2: ユーザーディレクトリにインストール\nmake install PREFIX=$HOME/.local\n```\n\n### インストール後に\"hpm: command not found\"\n\nPATHにインストールディレクトリが含まれていない可能性があります:\n\n```bash\n# hpmがどこにインストールされたか確認\nls -la /usr/local/bin/hpm\n\n# カスタム場所を使用している場合はPATHに追加\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## プラットフォーム固有の注意事項\n\n### Linux\n\n標準インストールはすべてのLinuxディストリビューションで動作します。一部のディストリビューションでは以下が必要な場合があります:\n\n```bash\n# Debian/Ubuntu: ビルド必須パッケージを確認\nsudo apt-get install build-essential git\n\n# Fedora/RHEL\nsudo dnf install make git\n```\n\n### macOS\n\n標準インストールが動作します。Homebrewを使用している場合:\n\n```bash\n# Xcodeコマンドラインツールを確認\nxcode-select --install\n```\n\n### Windows (WSL)\n\nhpmはWindows Subsystem for Linuxで動作します:\n\n```bash\n# WSLターミナルで\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\nmake install PREFIX=$HOME/.local\n```\n\n## 次のステップ\n\nインストール後:\n\n1. [クイックスタート](#hpm-installation-quick-start) - 最初のプロジェクトを作成\n2. [コマンドリファレンス](#hpm-installation-commands) - すべてのコマンドを学ぶ\n3. [設定](#hpm-installation-configuration) - hpmを設定\n"}, "hpm: はじめに -> クイックスタート": {"id": "hpm-quick-start", "content": "# クイックスタート\n\nhpmを5分で使い始めましょう。\n\n## hpmのインストール\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\nその他のインストールオプションについては、[インストールガイド](#hpm-quick-start-installation)を参照してください。\n\n## 新しいプロジェクトの作成\n\n新しいディレクトリを作成してパッケージを初期化:\n\n```bash\nmkdir my-project\ncd my-project\nhpm init\n```\n\nプロジェクトの詳細を入力:\n\n```\nPackage name (owner/repo): myname/my-project\nVersion (1.0.0):\nDescription: My awesome Hemlock project\nAuthor: Your Name <you@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n`--yes`を使用してすべてのデフォルトを受け入れる:\n\n```bash\nhpm init --yes\n```\n\n## プロジェクト構造\n\n基本的なプロジェクト構造を作成:\n\n```\nmy-project/\n├── package.json        # プロジェクトマニフェスト\n├── src/\n│   └── index.hml      # メインエントリポイント\n└── test/\n    └── test.hml       # テスト\n```\n\nメインファイルを作成:\n\n```bash\nmkdir -p src test\n```\n\n**src/index.hml:**\n```hemlock\n// メインエントリポイント\nexport fn greet(name: string): string {\n    return \"Hello, \" + name + \"!\";\n}\n\nexport fn main() {\n    print(greet(\"World\"));\n}\n```\n\n## 依存関係のインストール\n\nGitHub上でパッケージを検索（パッケージは`owner/repo`形式を使用）:\n\n```bash\n# パッケージをインストール\nhpm install hemlang/sprout\n\n# バージョン制約付きでインストール\nhpm install hemlang/json@^1.0.0\n\n# 開発依存関係としてインストール\nhpm install hemlang/test-utils --dev\n```\n\nインストール後、プロジェクト構造に`hem_modules/`が追加されます:\n\n```\nmy-project/\n├── package.json\n├── package-lock.json   # ロックファイル（自動生成）\n├── hem_modules/        # インストールされたパッケージ\n│   └── hemlang/\n│       └── sprout/\n├── src/\n│   └── index.hml\n└── test/\n    └── test.hml\n```\n\n## インストールしたパッケージの使用\n\nGitHubパスを使用してパッケージをインポート:\n\n```hemlock\n// インストールしたパッケージからインポート\nimport { app, router } from \"hemlang/sprout\";\nimport { parse, stringify } from \"hemlang/json\";\n\n// サブパスからインポート\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// 標準ライブラリ（組み込み）\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile } from \"@stdlib/fs\";\n```\n\n## スクリプトの追加\n\n`package.json`にスクリプトを追加:\n\n```json\n{\n  \"name\": \"myname/my-project\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/test.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\n`hpm run`でスクリプトを実行:\n\n```bash\nhpm run start\nhpm run build\n\n# testの短縮形\nhpm test\n```\n\n## 一般的なワークフロー\n\n### すべての依存関係をインストール\n\n`package.json`を持つプロジェクトをクローンした場合:\n\n```bash\ngit clone https://github.com/someone/project.git\ncd project\nhpm install\n```\n\n### 依存関係の更新\n\nすべてのパッケージを制約内で最新バージョンに更新:\n\n```bash\nhpm update\n```\n\n特定のパッケージを更新:\n\n```bash\nhpm update hemlang/sprout\n```\n\n### インストールされたパッケージの表示\n\nすべてのインストール済みパッケージをリスト:\n\n```bash\nhpm list\n```\n\n出力に依存関係ツリーが表示されます:\n\n```\nmy-project@1.0.0\n├── hemlang/sprout@2.1.0\n│   └── hemlang/router@1.5.0\n└── hemlang/json@1.2.3\n```\n\n### 更新の確認\n\n新しいバージョンがあるパッケージを確認:\n\n```bash\nhpm outdated\n```\n\n### パッケージの削除\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n## 例: Webアプリケーション\n\nWebフレームワークを使用した完全な例:\n\n**package.json:**\n```json\n{\n  \"name\": \"myname/my-web-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A web application\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"dev\": \"hemlock --watch src/index.hml\"\n  }\n}\n```\n\n**src/index.hml:**\n```hemlock\nimport { App, Router } from \"hemlang/sprout\";\n\nfn main() {\n    let app = App.new();\n    let router = Router.new();\n\n    router.get(\"/\", fn(req, res) {\n        res.send(\"Hello, World!\");\n    });\n\n    router.get(\"/api/status\", fn(req, res) {\n        res.json({ status: \"ok\" });\n    });\n\n    app.use(router);\n    app.listen(3000);\n\n    print(\"Server running on http://localhost:3000\");\n}\n```\n\nアプリケーションを実行:\n\n```bash\nhpm install\nhpm run start\n```\n\n## 次のステップ\n\n- [コマンドリファレンス](#hpm-quick-start-commands) - すべてのhpmコマンドを学ぶ\n- [パッケージの作成](#hpm-quick-start-creating-packages) - 独自のパッケージを公開\n- [設定](#hpm-quick-start-configuration) - hpmとGitHubトークンを設定\n- [プロジェクトセットアップ](#hpm-quick-start-project-setup) - 詳細なプロジェクト設定\n"}, "hpm: はじめに -> プロジェクトセットアップ": {"id": "hpm-project-setup", "content": "# プロジェクトセットアップ\n\nhpmを使ったHemlockプロジェクトのセットアップ完全ガイド。\n\n## 新しいプロジェクトの開始\n\n### 基本セットアップ\n\nゼロから新しいプロジェクトを作成:\n\n```bash\n# プロジェクトディレクトリを作成\nmkdir my-project\ncd my-project\n\n# package.jsonを初期化\nhpm init\n\n# ディレクトリ構造を作成\nmkdir -p src test\n```\n\n### プロジェクトテンプレート\n\n以下は異なる用途に応じた一般的なプロジェクト構造です:\n\n#### ライブラリパッケージ\n\n再利用可能なライブラリ用:\n\n```\nmy-library/\n├── package.json\n├── README.md\n├── LICENSE\n├── src/\n│   ├── index.hml          # メインエントリ、パブリックAPIをエクスポート\n│   ├── core.hml           # コア機能\n│   ├── utils.hml          # ユーティリティ関数\n│   └── types.hml          # 型定義\n└── test/\n    ├── framework.hml      # テストフレームワーク\n    ├── run.hml            # テストランナー\n    └── test_core.hml      # テスト\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-library\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A reusable Hemlock library\",\n  \"main\": \"src/index.hml\",\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {}\n}\n```\n\n#### アプリケーション\n\nスタンドアロンアプリケーション用:\n\n```\nmy-app/\n├── package.json\n├── README.md\n├── src/\n│   ├── main.hml           # アプリケーションエントリポイント\n│   ├── config.hml         # 設定\n│   ├── commands/          # CLIコマンド\n│   │   ├── index.hml\n│   │   └── run.hml\n│   └── lib/               # 内部ライブラリ\n│       └── utils.hml\n├── test/\n│   └── run.hml\n└── data/                  # データファイル\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Hemlock application\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {}\n}\n```\n\n#### Webアプリケーション\n\nWebサーバー用:\n\n```\nmy-web-app/\n├── package.json\n├── README.md\n├── src/\n│   ├── main.hml           # サーバーエントリポイント\n│   ├── routes/            # ルートハンドラ\n│   │   ├── index.hml\n│   │   ├── api.hml\n│   │   └── auth.hml\n│   ├── middleware/        # ミドルウェア\n│   │   ├── index.hml\n│   │   └── auth.hml\n│   ├── models/            # データモデル\n│   │   └── user.hml\n│   └── services/          # ビジネスロジック\n│       └── user.hml\n├── test/\n│   └── run.hml\n├── static/                # 静的ファイル\n│   ├── css/\n│   └── js/\n└── views/                 # テンプレート\n    └── index.hml\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-web-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Hemlock web application\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\",\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  }\n}\n```\n\n## package.jsonファイル\n\n### 必須フィールド\n\n```json\n{\n  \"name\": \"owner/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n### すべてのフィールド\n\n```json\n{\n  \"name\": \"yourusername/my-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Package description\",\n  \"author\": \"Your Name <you@example.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/yourusername/my-package\",\n  \"homepage\": \"https://yourusername.github.io/my-package\",\n  \"bugs\": \"https://github.com/yourusername/my-package/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"utility\", \"parser\"],\n  \"dependencies\": {\n    \"owner/package\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"owner/test-lib\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n### フィールドリファレンス\n\n| フィールド | 型 | 説明 |\n|-------|------|-------------|\n| `name` | string | owner/repo形式のパッケージ名（必須） |\n| `version` | string | セマンティックバージョン（必須） |\n| `description` | string | 短い説明 |\n| `author` | string | 作者名とメール |\n| `license` | string | ライセンス識別子（MIT、Apache-2.0など） |\n| `repository` | string | リポジトリURL |\n| `homepage` | string | プロジェクトホームページ |\n| `bugs` | string | イシュートラッカーURL |\n| `main` | string | エントリポイントファイル（デフォルト: src/index.hml） |\n| `keywords` | array | 検索キーワード |\n| `dependencies` | object | ランタイム依存関係 |\n| `devDependencies` | object | 開発依存関係 |\n| `scripts` | object | 名前付きスクリプト |\n| `files` | array | 公開時に含めるファイル |\n| `native` | object | ネイティブライブラリ要件 |\n\n## package-lock.jsonファイル\n\nロックファイルは自動生成され、バージョン管理にコミットする必要があります。再現可能なインストールを保証します。\n\n```json\n{\n  \"lockVersion\": 1,\n  \"hemlock\": \"1.0.0\",\n  \"dependencies\": {\n    \"hemlang/sprout\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz\",\n      \"integrity\": \"sha256-abc123...\",\n      \"dependencies\": {\n        \"hemlang/router\": \"^1.5.0\"\n      }\n    },\n    \"hemlang/router\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://github.com/hemlang/router/archive/v1.5.0.tar.gz\",\n      \"integrity\": \"sha256-def456...\",\n      \"dependencies\": {}\n    }\n  }\n}\n```\n\n### ロックファイルのベストプラクティス\n\n- package-lock.jsonをバージョン管理に**コミット**\n- 手動で**編集しない** - 自動生成される\n- 変更をプルした後に**`hpm install`を実行**\n- 破損した場合は**削除して再生成**:\n  ```bash\n  rm package-lock.json\n  hpm install\n  ```\n\n## hem_modulesディレクトリ\n\nインストールされたパッケージは`hem_modules/`に保存されます:\n\n```\nhem_modules/\n├── hemlang/\n│   ├── sprout/\n│   │   ├── package.json\n│   │   └── src/\n│   └── router/\n│       ├── package.json\n│       └── src/\n└── alice/\n    └── http-client/\n        ├── package.json\n        └── src/\n```\n\n### hem_modulesのベストプラクティス\n\n- **.gitignoreに追加** - 依存関係をコミットしない\n- **変更しない** - 変更は上書きされる\n- **新しくインストールするには削除**:\n  ```bash\n  rm -rf hem_modules\n  hpm install\n  ```\n\n## .gitignore\n\nHemlockプロジェクトの推奨.gitignore:\n\n```gitignore\n# 依存関係\nhem_modules/\n\n# ビルド出力\ndist/\n*.hmlc\n\n# IDEファイル\n.idea/\n.vscode/\n*.swp\n*.swo\n\n# OSファイル\n.DS_Store\nThumbs.db\n\n# ログ\n*.log\nlogs/\n\n# 環境\n.env\n.env.local\n\n# テストカバレッジ\ncoverage/\n```\n\n## 依存関係の操作\n\n### 依存関係の追加\n\n```bash\n# ランタイム依存関係を追加\nhpm install hemlang/json\n\n# バージョン制約付きで追加\nhpm install hemlang/sprout@^2.0.0\n\n# 開発依存関係を追加\nhpm install hemlang/test-utils --dev\n```\n\n### 依存関係のインポート\n\n```hemlock\n// パッケージからインポート（\"main\"エントリを使用）\nimport { parse, stringify } from \"hemlang/json\";\n\n// サブパスからインポート\nimport { Router } from \"hemlang/sprout/router\";\n\n// 標準ライブラリをインポート\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile, writeFile } from \"@stdlib/fs\";\n```\n\n### インポート解決\n\nhpmは以下の順序でインポートを解決:\n\n1. **標準ライブラリ**: `@stdlib/*`は組み込みモジュールをインポート\n2. **パッケージルート**: `owner/repo`は`main`フィールドを使用\n3. **サブパス**: `owner/repo/path`は以下をチェック:\n   - `hem_modules/owner/repo/path.hml`\n   - `hem_modules/owner/repo/path/index.hml`\n   - `hem_modules/owner/repo/src/path.hml`\n   - `hem_modules/owner/repo/src/path/index.hml`\n\n## スクリプト\n\n### スクリプトの定義\n\npackage.jsonにスクリプトを追加:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n### スクリプトの実行\n\n```bash\nhpm run start\nhpm run dev\nhpm run build\n\n# testの短縮形\nhpm test\n\n# 引数を渡す\nhpm run test -- --verbose --filter=unit\n```\n\n### スクリプトの命名規則\n\n| スクリプト | 目的 |\n|--------|---------|\n| `start` | アプリケーションを実行 |\n| `dev` | 開発モードで実行 |\n| `test` | すべてのテストを実行 |\n| `build` | 本番用にビルド |\n| `clean` | 生成ファイルを削除 |\n| `lint` | コードスタイルをチェック |\n| `format` | コードをフォーマット |\n\n## 開発ワークフロー\n\n### 初期セットアップ\n\n```bash\n# プロジェクトをクローン\ngit clone https://github.com/yourusername/my-project.git\ncd my-project\n\n# 依存関係をインストール\nhpm install\n\n# テストを実行\nhpm test\n\n# 開発を開始\nhpm run dev\n```\n\n### 日常のワークフロー\n\n```bash\n# 最新の変更をプル\ngit pull\n\n# 新しい依存関係をインストール\nhpm install\n\n# 変更を加える...\n\n# テストを実行\nhpm test\n\n# コミット\ngit add .\ngit commit -m \"Add feature\"\ngit push\n```\n\n### 新機能の追加\n\n```bash\n# フィーチャーブランチを作成\ngit checkout -b feature/new-feature\n\n# 必要に応じて新しい依存関係を追加\nhpm install hemlang/new-lib\n\n# 機能を実装...\n\n# テスト\nhpm test\n\n# コミットとプッシュ\ngit add .\ngit commit -m \"Add new feature\"\ngit push -u origin feature/new-feature\n```\n\n## 環境別設定\n\n### 環境変数の使用\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nlet db_host = getenv(\"DATABASE_HOST\") ?? \"localhost\";\nlet api_key = getenv(\"API_KEY\") ?? \"\";\n\nif api_key == \"\" {\n    print(\"Warning: API_KEY not set\");\n}\n```\n\n### 設定ファイル\n\n**config.hml:**\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nexport let config = {\n    environment: getenv(\"HEMLOCK_ENV\") ?? \"development\",\n    database: {\n        host: getenv(\"DB_HOST\") ?? \"localhost\",\n        port: int(getenv(\"DB_PORT\") ?? \"5432\"),\n        name: getenv(\"DB_NAME\") ?? \"myapp\"\n    },\n    server: {\n        port: int(getenv(\"PORT\") ?? \"3000\"),\n        host: getenv(\"HOST\") ?? \"0.0.0.0\"\n    }\n};\n\nexport fn is_production(): bool {\n    return config.environment == \"production\";\n}\n```\n\n## 参照\n\n- [クイックスタート](#hpm-project-setup-quick-start) - すぐに始める\n- [コマンド](#hpm-project-setup-commands) - コマンドリファレンス\n- [パッケージの作成](#hpm-project-setup-creating-packages) - パッケージの公開\n- [設定](#hpm-project-setup-configuration) - hpmの設定\n"}, "hpm: ユーザーガイド -> コマンド": {"id": "hpm-commands", "content": "# コマンドリファレンス\n\nすべてのhpmコマンドの完全なリファレンス。\n\n## グローバルオプション\n\nこれらのオプションはどのコマンドでも使用できます:\n\n| オプション | 説明 |\n|--------|-------------|\n| `--help`, `-h` | ヘルプメッセージを表示 |\n| `--version`, `-v` | hpmのバージョンを表示 |\n| `--verbose` | 詳細な出力を表示 |\n\n## コマンド\n\n### hpm init\n\n新しい`package.json`ファイルを作成します。\n\n```bash\nhpm init        # インタラクティブモード\nhpm init --yes  # すべてのデフォルトを受け入れる\nhpm init -y     # 短縮形\n```\n\n**オプション:**\n\n| オプション | 説明 |\n|--------|-------------|\n| `--yes`, `-y` | すべてのプロンプトでデフォルト値を受け入れる |\n\n**インタラクティブプロンプト:**\n- パッケージ名（owner/repo形式）\n- バージョン（デフォルト: 1.0.0）\n- 説明\n- 作者\n- ライセンス（デフォルト: MIT）\n- メインファイル（デフォルト: src/index.hml）\n\n**例:**\n\n```bash\n$ hpm init\nPackage name (owner/repo): alice/my-lib\nVersion (1.0.0):\nDescription: A utility library\nAuthor: Alice <alice@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n---\n\n### hpm install\n\n依存関係をインストールするか、新しいパッケージを追加します。\n\n```bash\nhpm install                           # package.jsonからすべてをインストール\nhpm install owner/repo                # パッケージを追加してインストール\nhpm install owner/repo@^1.0.0        # バージョン制約付きで\nhpm install owner/repo --dev         # 開発依存関係として\nhpm i owner/repo                      # 短縮形\n```\n\n**オプション:**\n\n| オプション | 説明 |\n|--------|-------------|\n| `--dev`, `-D` | devDependenciesに追加 |\n| `--verbose` | 詳細な進捗を表示 |\n| `--dry-run` | インストールせずにプレビュー |\n| `--offline` | キャッシュのみからインストール（ネットワークなし） |\n| `--parallel` | 並列ダウンロードを有効化（実験的） |\n\n**バージョン制約の構文:**\n\n| 構文 | 例 | 意味 |\n|--------|---------|---------|\n| (なし) | `owner/repo` | 最新バージョン |\n| 固定 | `owner/repo@1.2.3` | 正確に1.2.3 |\n| キャレット | `owner/repo@^1.2.3` | >=1.2.3 <2.0.0 |\n| チルダ | `owner/repo@~1.2.3` | >=1.2.3 <1.3.0 |\n| 範囲 | `owner/repo@>=1.0.0` | 1.0.0以上 |\n\n**例:**\n\n```bash\n# すべての依存関係をインストール\nhpm install\n\n# 特定のパッケージをインストール\nhpm install hemlang/json\n\n# バージョン制約付きでインストール\nhpm install hemlang/sprout@^2.0.0\n\n# 開発依存関係としてインストール\nhpm install hemlang/test-utils --dev\n\n# インストール内容をプレビュー\nhpm install hemlang/sprout --dry-run\n\n# 詳細出力\nhpm install --verbose\n\n# キャッシュのみからインストール（オフライン）\nhpm install --offline\n```\n\n**出力:**\n\n```\nInstalling dependencies...\n  + hemlang/sprout@2.1.0\n  + hemlang/router@1.5.0 (dependency of hemlang/sprout)\n\nInstalled 2 packages in 1.2s\n```\n\n---\n\n### hpm uninstall\n\nパッケージを削除します。\n\n```bash\nhpm uninstall owner/repo\nhpm rm owner/repo          # 短縮形\nhpm remove owner/repo      # 別名\n```\n\n**例:**\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n**出力:**\n\n```\nRemoved hemlang/sprout@2.1.0\nUpdated package.json\nUpdated package-lock.json\n```\n\n---\n\n### hpm update\n\n制約内で最新バージョンにパッケージを更新します。\n\n```bash\nhpm update              # すべてのパッケージを更新\nhpm update owner/repo   # 特定のパッケージを更新\nhpm up owner/repo       # 短縮形\n```\n\n**オプション:**\n\n| オプション | 説明 |\n|--------|-------------|\n| `--verbose` | 詳細な進捗を表示 |\n| `--dry-run` | 更新せずにプレビュー |\n\n**例:**\n\n```bash\n# すべてのパッケージを更新\nhpm update\n\n# 特定のパッケージを更新\nhpm update hemlang/sprout\n\n# 更新をプレビュー\nhpm update --dry-run\n```\n\n**出力:**\n\n```\nUpdating dependencies...\n  hemlang/sprout: 2.0.0 → 2.1.0\n  hemlang/router: 1.4.0 → 1.5.0\n\nUpdated 2 packages\n```\n\n---\n\n### hpm list\n\nインストールされているパッケージを表示します。\n\n```bash\nhpm list              # 完全な依存関係ツリーを表示\nhpm list --depth=0    # 直接依存関係のみ\nhpm list --depth=1    # 1レベルの推移的依存関係\nhpm ls                # 短縮形\n```\n\n**オプション:**\n\n| オプション | 説明 |\n|--------|-------------|\n| `--depth=N` | ツリーの深さを制限（デフォルト: すべて） |\n\n**例:**\n\n```bash\n$ hpm list\nmy-project@1.0.0\n├── hemlang/sprout@2.1.0\n│   ├── hemlang/router@1.5.0\n│   └── hemlang/middleware@1.2.0\n├── hemlang/json@1.2.3\n└── hemlang/test-utils@1.0.0 (dev)\n\n$ hpm list --depth=0\nmy-project@1.0.0\n├── hemlang/sprout@2.1.0\n├── hemlang/json@1.2.3\n└── hemlang/test-utils@1.0.0 (dev)\n```\n\n---\n\n### hpm outdated\n\n新しいバージョンが利用可能なパッケージを表示します。\n\n```bash\nhpm outdated\n```\n\n**出力:**\n\n```\nPackage            Current  Wanted  Latest\nhemlang/sprout     2.0.0    2.0.5   2.1.0\nhemlang/router     1.4.0    1.4.2   1.5.0\n```\n\n- **Current**: インストールされているバージョン\n- **Wanted**: 制約に一致する最高バージョン\n- **Latest**: 最新の利用可能なバージョン\n\n---\n\n### hpm run\n\npackage.jsonからスクリプトを実行します。\n\n```bash\nhpm run <script>\nhpm run <script> -- <args>\n```\n\n**例:**\n\nこのpackage.jsonの場合:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\nスクリプトを実行:\n\n```bash\nhpm run start\nhpm run test\nhpm run build\n\n# スクリプトに引数を渡す\nhpm run test -- --verbose\n```\n\n---\n\n### hpm test\n\n`hpm run test`の短縮形。\n\n```bash\nhpm test\nhpm test -- --verbose\n```\n\n以下と同等:\n\n```bash\nhpm run test\n```\n\n---\n\n### hpm why\n\nパッケージがインストールされている理由を説明します（依存関係チェーンを表示）。\n\n```bash\nhpm why owner/repo\n```\n\n**例:**\n\n```bash\n$ hpm why hemlang/router\n\nhemlang/router@1.5.0 is installed because:\n\nmy-project@1.0.0\n└── hemlang/sprout@2.1.0\n    └── hemlang/router@1.5.0\n```\n\n---\n\n### hpm cache\n\nグローバルパッケージキャッシュを管理します。\n\n```bash\nhpm cache list    # キャッシュされたパッケージをリスト\nhpm cache clean   # すべてのキャッシュされたパッケージをクリア\n```\n\n**サブコマンド:**\n\n| サブコマンド | 説明 |\n|------------|-------------|\n| `list` | すべてのキャッシュされたパッケージとサイズを表示 |\n| `clean` | すべてのキャッシュされたパッケージを削除 |\n\n**例:**\n\n```bash\n$ hpm cache list\nCached packages in ~/.hpm/cache:\n\nhemlang/sprout\n  2.0.0 (1.2 MB)\n  2.1.0 (1.3 MB)\nhemlang/router\n  1.5.0 (450 KB)\n\nTotal: 2.95 MB\n\n$ hpm cache clean\nCleared cache (2.95 MB freed)\n```\n\n---\n\n## コマンドショートカット\n\n便宜上、いくつかのコマンドには短いエイリアスがあります:\n\n| コマンド | ショートカット |\n|---------|-----------|\n| `install` | `i` |\n| `uninstall` | `rm`, `remove` |\n| `list` | `ls` |\n| `update` | `up` |\n\n**例:**\n\n```bash\nhpm i hemlang/sprout        # hpm install hemlang/sprout\nhpm rm hemlang/sprout       # hpm uninstall hemlang/sprout\nhpm ls                      # hpm list\nhpm up                      # hpm update\n```\n\n---\n\n## 終了コード\n\nhpmは異なるエラー条件を示すために特定の終了コードを使用します:\n\n| コード | 意味 |\n|------|---------|\n| 0 | 成功 |\n| 1 | 依存関係の競合 |\n| 2 | パッケージが見つからない |\n| 3 | バージョンが見つからない |\n| 4 | ネットワークエラー |\n| 5 | 無効なpackage.json |\n| 6 | 整合性チェック失敗 |\n| 7 | GitHubレート制限超過 |\n| 8 | 循環依存 |\n\nスクリプトでの終了コードの使用:\n\n```bash\nhpm install\nif [ $? -ne 0 ]; then\n    echo \"Installation failed\"\n    exit 1\nfi\n```\n\n---\n\n## 環境変数\n\nhpmは以下の環境変数を尊重します:\n\n| 変数 | 説明 |\n|----------|-------------|\n| `GITHUB_TOKEN` | 認証用のGitHub APIトークン |\n| `HPM_CACHE_DIR` | キャッシュディレクトリの場所を上書き |\n| `HOME` | ユーザーホームディレクトリ（設定/キャッシュ用） |\n\n**例:**\n\n```bash\n# より高いレート制限のためにGitHubトークンを使用\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# カスタムキャッシュディレクトリを使用\nexport HPM_CACHE_DIR=/tmp/hpm-cache\nhpm install\n```\n\n---\n\n## 参照\n\n- [設定](#hpm-commands-configuration) - 設定ファイル\n- [パッケージ仕様](#hpm-commands-package-spec) - package.jsonの形式\n- [トラブルシューティング](#hpm-commands-troubleshooting) - よくある問題\n"}, "hpm: ユーザーガイド -> トラブルシューティング": {"id": "hpm-troubleshooting", "content": "# トラブルシューティング\n\nhpmの一般的な問題と解決策。\n\n## インストールの問題\n\n### \"hemlock: command not found\"\n\n**原因:** HemlockがインストールされていないかPATHにない。\n\n**解決策:**\n\n```bash\n# hemlockが存在するか確認\nwhich hemlock\n\n# 見つからない場合、まずHemlockをインストール\n# https://github.com/hemlang/hemlock を参照\n\n# インストール後に確認\nhemlock --version\n```\n\n### \"hpm: command not found\"\n\n**原因:** hpmがインストールされていないかPATHにない。\n\n**解決策:**\n\n```bash\n# hpmがどこにインストールされているか確認\nls -la /usr/local/bin/hpm\nls -la ~/.local/bin/hpm\n\n# カスタム場所を使用している場合、PATHに追加\nexport PATH=\"$HOME/.local/bin:$PATH\"\n\n# 永続化のため~/.bashrcまたは~/.zshrcに追加\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc\nsource ~/.bashrc\n\n# 必要に応じて再インストール\ncd /path/to/hpm\nsudo make install\n```\n\n### インストール時の\"Permission denied\"\n\n**原因:** インストールディレクトリへの書き込み権限がない。\n\n**解決策:**\n\n```bash\n# オプション1: システム全体のインストールにsudoを使用\nsudo make install\n\n# オプション2: ユーザーディレクトリにインストール（sudoが不要）\nmake install PREFIX=$HOME/.local\n```\n\n## 依存関係の問題\n\n### \"Package not found\"（終了コード2）\n\n**原因:** パッケージがGitHubに存在しない。\n\n**解決策:**\n\n```bash\n# パッケージが存在するか確認\n# https://github.com/owner/repo をチェック\n\n# スペルを確認\nhpm install hemlang/sprout  # 正しい\nhpm install hemlan/sprout   # 間違ったowner\nhpm install hemlang/spout   # 間違ったrepo\n\n# package.jsonのタイプミスを確認\ncat package.json | grep -A 5 dependencies\n```\n\n### \"Version not found\"（終了コード3）\n\n**原因:** バージョン制約に一致するリリースがない。\n\n**解決策:**\n\n```bash\n# 利用可能なバージョンをリスト（GitHubのリリース/タグを確認）\n# タグは'v'で始まる必要あり（例: v1.0.0）\n\n# 有効なバージョン制約を使用\nhpm install owner/repo@^1.0.0\n\n# 最新バージョンを試す\nhpm install owner/repo\n\n# GitHubで利用可能なタグを確認\n# https://github.com/owner/repo/tags\n```\n\n### \"Dependency conflict\"（終了コード1）\n\n**原因:** 2つのパッケージが依存関係の互換性のないバージョンを要求。\n\n**解決策:**\n\n```bash\n# 競合を確認\nhpm install --verbose\n\n# 何がその依存関係を要求しているか確認\nhpm why conflicting/package\n\n# 解決策:\n# 1. 競合しているパッケージを更新\nhpm update problem/package\n\n# 2. package.jsonでバージョン制約を変更\n# 互換性のあるバージョンを許可するように編集\n\n# 3. 競合しているパッケージの1つを削除\nhpm uninstall one/package\n```\n\n### \"Circular dependency\"（終了コード8）\n\n**原因:** パッケージAがBに依存し、BがAに依存。\n\n**解決策:**\n\n```bash\n# サイクルを特定\nhpm install --verbose\n\n# これは通常パッケージ自体のバグ\n# パッケージメンテナーに連絡\n\n# 回避策: 循環しているパッケージの1つの使用を避ける\n```\n\n## ネットワークの問題\n\n### \"Network error\"（終了コード4）\n\n**原因:** GitHub APIに接続できない。\n\n**解決策:**\n\n```bash\n# インターネット接続を確認\nping github.com\n\n# GitHub APIにアクセスできるか確認\ncurl -I https://api.github.com\n\n# 再試行（hpmは自動的にリトライ）\nhpm install\n\n# パッケージがキャッシュされている場合はオフラインモードを使用\nhpm install --offline\n\n# ファイアウォールの背後にいる場合はプロキシ設定を確認\nexport HTTPS_PROXY=http://proxy:8080\nhpm install\n```\n\n### \"GitHub rate limit exceeded\"（終了コード7）\n\n**原因:** 認証なしでAPIリクエストが多すぎる。\n\n**解決策:**\n\n```bash\n# オプション1: GitHubトークンで認証（推奨）\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# トークンを作成: GitHub → Settings → Developer settings → Personal access tokens\n\n# オプション2: トークンを設定ファイルに保存\nmkdir -p ~/.hpm\necho '{\"github_token\": \"ghp_xxxxxxxxxxxx\"}' > ~/.hpm/config.json\n\n# オプション3: レート制限のリセットを待つ（毎時リセット）\n\n# オプション4: オフラインモードを使用\nhpm install --offline\n```\n\n### 接続タイムアウト\n\n**原因:** ネットワークが遅いかGitHub APIの問題。\n\n**解決策:**\n\n```bash\n# hpmは指数バックオフで自動的にリトライ\n\n# GitHubに問題がないか確認\n# https://www.githubstatus.com を参照\n\n# 後で再試行\nhpm install\n\n# キャッシュされたパッケージを使用\nhpm install --offline\n```\n\n## Package.jsonの問題\n\n### \"Invalid package.json\"（終了コード5）\n\n**原因:** 不正な形式または必須フィールドの欠落。\n\n**解決策:**\n\n```bash\n# JSON構文を検証\ncat package.json | python -m json.tool\n\n# 必須フィールドを確認\ncat package.json\n\n# 必須フィールド:\n# - \"name\": \"owner/repo\"形式\n# - \"version\": \"X.Y.Z\"形式\n\n# 必要に応じて再生成\nrm package.json\nhpm init\n```\n\n### \"name\"形式エラー\n\n**原因:** パッケージ名が`owner/repo`形式でない。\n\n**解決策:**\n\n```json\n// 間違い\n{\n  \"name\": \"my-package\"\n}\n\n// 正しい\n{\n  \"name\": \"yourusername/my-package\"\n}\n```\n\n### \"version\"形式エラー\n\n**原因:** バージョンがsemver形式でない。\n\n**解決策:**\n\n```json\n// 間違い\n{\n  \"version\": \"1.0\"\n}\n\n// 正しい\n{\n  \"version\": \"1.0.0\"\n}\n```\n\n## ロックファイルの問題\n\n### ロックファイルの同期が取れていない\n\n**原因:** package.jsonがinstallを実行せずに変更された。\n\n**解決策:**\n\n```bash\n# ロックファイルを再生成\nrm package-lock.json\nhpm install\n```\n\n### 破損したロックファイル\n\n**原因:** 無効なJSONまたは手動編集。\n\n**解決策:**\n\n```bash\n# JSONの有効性を確認\ncat package-lock.json | python -m json.tool\n\n# 再生成\nrm package-lock.json\nhpm install\n```\n\n## hem_modulesの問題\n\n### パッケージがインストールされない\n\n**原因:** 様々な問題の可能性。\n\n**解決策:**\n\n```bash\n# クリーンにして再インストール\nrm -rf hem_modules\nhpm install\n\n# 詳細出力を確認\nhpm install --verbose\n```\n\n### インポートが機能しない\n\n**原因:** パッケージが正しくインストールされていないか、インポートパスが間違っている。\n\n**解決策:**\n\n```bash\n# パッケージがインストールされているか確認\nls hem_modules/owner/repo/\n\n# package.jsonのmainフィールドを確認\ncat hem_modules/owner/repo/package.json\n\n# 正しいインポート形式\nimport { x } from \"owner/repo\";          # mainエントリを使用\nimport { y } from \"owner/repo/subpath\";  # サブパスインポート\n```\n\n### \"Module not found\"エラー\n\n**原因:** インポートパスがファイルに解決されない。\n\n**解決策:**\n\n```bash\n# インポートパスを確認\nls hem_modules/owner/repo/src/\n\n# index.hmlを確認\nls hem_modules/owner/repo/src/index.hml\n\n# package.jsonのmainフィールドを確認\ncat hem_modules/owner/repo/package.json | grep main\n```\n\n## キャッシュの問題\n\n### キャッシュの容量が大きすぎる\n\n**解決策:**\n\n```bash\n# キャッシュサイズを表示\nhpm cache list\n\n# キャッシュをクリア\nhpm cache clean\n```\n\n### キャッシュの権限\n\n**解決策:**\n\n```bash\n# 権限を修正\nchmod -R u+rw ~/.hpm/cache\n\n# または削除して再インストール\nrm -rf ~/.hpm/cache\nhpm install\n```\n\n### 間違ったキャッシュを使用\n\n**解決策:**\n\n```bash\n# キャッシュの場所を確認\necho $HPM_CACHE_DIR\nls ~/.hpm/cache\n\n# 間違っている場合は環境変数をクリア\nunset HPM_CACHE_DIR\n```\n\n## スクリプトの問題\n\n### \"Script not found\"\n\n**原因:** スクリプト名がpackage.jsonに存在しない。\n\n**解決策:**\n\n```bash\n# 利用可能なスクリプトをリスト\ncat package.json | grep -A 20 scripts\n\n# スペルを確認\nhpm run test    # 正しい\nhpm run tests   # スクリプト名が\"test\"の場合は間違い\n```\n\n### スクリプトが失敗\n\n**原因:** スクリプトコマンドにエラー。\n\n**解決策:**\n\n```bash\n# コマンドを直接実行してエラーを確認\nhemlock test/run.hml\n\n# スクリプト定義を確認\ncat package.json | grep test\n```\n\n## デバッグ\n\n### 詳細出力を有効化\n\n```bash\nhpm install --verbose\n```\n\n### hpmバージョンを確認\n\n```bash\nhpm --version\n```\n\n### hemlockバージョンを確認\n\n```bash\nhemlock --version\n```\n\n### ドライラン\n\n変更を加えずにプレビュー:\n\n```bash\nhpm install --dry-run\n```\n\n### クリーンスレート\n\n最初から始める:\n\n```bash\nrm -rf hem_modules package-lock.json\nhpm install\n```\n\n## ヘルプを得る\n\n### コマンドヘルプ\n\n```bash\nhpm --help\nhpm install --help\n```\n\n### 問題を報告\n\nバグに遭遇した場合:\n\n1. 既存のIssueを確認: https://github.com/hemlang/hpm/issues\n2. 以下を含む新しいIssueを作成:\n   - hpmバージョン（`hpm --version`）\n   - Hemlockバージョン（`hemlock --version`）\n   - オペレーティングシステム\n   - 再現手順\n   - エラーメッセージ（`--verbose`を使用）\n\n## 終了コードリファレンス\n\n| コード | 意味 | 一般的な解決策 |\n|------|---------|-----------------|\n| 0 | 成功 | - |\n| 1 | 依存関係の競合 | 更新または制約を変更 |\n| 2 | パッケージが見つからない | スペルを確認、リポジトリの存在を確認 |\n| 3 | バージョンが見つからない | GitHubで利用可能なバージョンを確認 |\n| 4 | ネットワークエラー | 接続を確認、リトライ |\n| 5 | 無効なpackage.json | JSON構文と必須フィールドを修正 |\n| 6 | 整合性チェック失敗 | キャッシュをクリアして再インストール |\n| 7 | GitHubレート制限 | GITHUB_TOKENを追加 |\n| 8 | 循環依存 | パッケージメンテナーに連絡 |\n\n## 参照\n\n- [インストール](#hpm-troubleshooting-installation) - インストールガイド\n- [設定](#hpm-troubleshooting-configuration) - 設定オプション\n- [コマンド](#hpm-troubleshooting-commands) - コマンドリファレンス\n"}, "hpm: ユーザーガイド -> 設定": {"id": "hpm-configuration", "content": "# 設定\n\nこのガイドでは、hpmのすべての設定オプションについて説明します。\n\n## 概要\n\nhpmは以下の方法で設定できます:\n\n1. **環境変数** - ランタイム設定用\n2. **グローバル設定ファイル** - `~/.hpm/config.json`\n3. **プロジェクトファイル** - `package.json`と`package-lock.json`\n\n## 環境変数\n\n### GITHUB_TOKEN\n\n認証用のGitHub APIトークン。\n\n```bash\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n```\n\n**認証の利点:**\n- より高いAPIレート制限（60ではなく5000リクエスト/時間）\n- プライベートリポジトリへのアクセス\n- より高速な依存関係解決\n\n**トークンの作成:**\n\n1. GitHub → Settings → Developer settings → Personal access tokensに移動\n2. \"Generate new token (classic)\"をクリック\n3. スコープを選択:\n   - `repo` - プライベートリポジトリへのアクセス用\n   - `read:packages` - GitHub Packages用（使用する場合）\n4. 生成してトークンをコピー\n\n### HPM_CACHE_DIR\n\nデフォルトのキャッシュディレクトリを上書きします。\n\n```bash\nexport HPM_CACHE_DIR=/custom/cache/path\n```\n\nデフォルト: `~/.hpm/cache`\n\n**使用例:**\n- カスタムキャッシュ場所を持つCI/CDシステム\n- プロジェクト間での共有キャッシュ\n- 分離されたビルド用の一時キャッシュ\n\n### HOME\n\nユーザーホームディレクトリ。以下の場所を特定するために使用:\n- 設定ディレクトリ: `$HOME/.hpm/`\n- キャッシュディレクトリ: `$HOME/.hpm/cache/`\n\n通常はシステムによって設定されます。必要な場合のみ上書きしてください。\n\n### .bashrc / .zshrcの例\n\n```bash\n# GitHub認証（推奨）\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n\n# カスタムキャッシュ場所（オプション）\n# export HPM_CACHE_DIR=/path/to/cache\n\n# hpmをPATHに追加（カスタムインストール場所を使用する場合）\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## グローバル設定ファイル\n\n### 場所\n\n`~/.hpm/config.json`\n\n### 形式\n\n```json\n{\n  \"github_token\": \"ghp_xxxxxxxxxxxxxxxxxxxx\"\n}\n```\n\n### 設定ファイルの作成\n\n```bash\n# 設定ディレクトリを作成\nmkdir -p ~/.hpm\n\n# 設定ファイルを作成\ncat > ~/.hpm/config.json << 'EOF'\n{\n  \"github_token\": \"ghp_your_token_here\"\n}\nEOF\n\n# ファイルを保護（推奨）\nchmod 600 ~/.hpm/config.json\n```\n\n### トークンの優先順位\n\n両方が設定されている場合、環境変数が優先されます:\n\n1. `GITHUB_TOKEN`環境変数（最高）\n2. `~/.hpm/config.json`の`github_token`フィールド\n3. 認証なし（デフォルト）\n\n## ディレクトリ構造\n\n### グローバルディレクトリ\n\n```\n~/.hpm/\n├── config.json          # グローバル設定\n└── cache/               # パッケージキャッシュ\n    └── owner/\n        └── repo/\n            └── 1.0.0.tar.gz\n```\n\n### プロジェクトディレクトリ\n\n```\nmy-project/\n├── package.json         # プロジェクトマニフェスト\n├── package-lock.json    # 依存関係ロックファイル\n├── hem_modules/         # インストールされたパッケージ\n│   └── owner/\n│       └── repo/\n│           ├── package.json\n│           └── src/\n├── src/                 # ソースコード\n└── test/                # テスト\n```\n\n## パッケージキャッシュ\n\n### 場所\n\nデフォルト: `~/.hpm/cache/`\n\n上書き: `HPM_CACHE_DIR`環境変数\n\n### 構造\n\n```\n~/.hpm/cache/\n├── hemlang/\n│   ├── sprout/\n│   │   ├── 2.0.0.tar.gz\n│   │   └── 2.1.0.tar.gz\n│   └── router/\n│       └── 1.5.0.tar.gz\n└── alice/\n    └── http-client/\n        └── 1.0.0.tar.gz\n```\n\n### キャッシュの管理\n\n```bash\n# キャッシュされたパッケージを表示\nhpm cache list\n\n# キャッシュ全体をクリア\nhpm cache clean\n```\n\n### キャッシュの動作\n\n- パッケージは最初のダウンロード後にキャッシュされる\n- 以降のインストールはキャッシュされたバージョンを使用\n- キャッシュのみからインストールするには`--offline`を使用\n- キャッシュはすべてのプロジェクト間で共有\n\n## GitHub APIレート制限\n\n### 認証なし\n\n- IPアドレスあたり**60リクエスト/時間**\n- 同じIP上のすべての非認証ユーザーで共有\n- CI/CDや多くの依存関係がある場合、すぐに枯渇\n\n### 認証あり\n\n- 認証ユーザーあたり**5000リクエスト/時間**\n- 個人のレート制限、共有なし\n\n### レート制限の処理\n\nhpmは自動的に:\n- 指数バックオフでリトライ（1秒、2秒、4秒、8秒）\n- 終了コード7でレート制限エラーを報告\n- レート制限された場合に認証を提案\n\n**レート制限時の解決策:**\n\n```bash\n# オプション1: GitHubトークンで認証（推奨）\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# オプション2: レート制限のリセットを待つ\n# （制限は毎時リセット）\n\n# オプション3: オフラインモードを使用（パッケージがキャッシュされている場合）\nhpm install --offline\n```\n\n## オフラインモード\n\nネットワークアクセスなしでパッケージをインストール:\n\n```bash\nhpm install --offline\n```\n\n**要件:**\n- すべてのパッケージがキャッシュにある必要あり\n- 正確なバージョンを持つロックファイルが存在する必要あり\n\n**使用例:**\n- エアギャップ環境\n- CI/CDビルドの高速化（ウォームキャッシュ時）\n- レート制限の回避\n\n## CI/CD設定\n\n### GitHub Actions\n\n```yaml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Setup Hemlock\n      run: |\n        # Hemlockをインストール（セットアップに応じて調整）\n        curl -sSL https://hemlock.dev/install.sh | sh\n\n    - name: Cache hpm packages\n      uses: actions/cache@v3\n      with:\n        path: ~/.hpm/cache\n        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}\n        restore-keys: |\n          ${{ runner.os }}-hpm-\n\n    - name: Install dependencies\n      run: hpm install\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Run tests\n      run: hpm test\n```\n\n### GitLab CI\n\n```yaml\nstages:\n  - build\n  - test\n\nvariables:\n  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache\n\ncache:\n  paths:\n    - .hpm-cache/\n  key: $CI_COMMIT_REF_SLUG\n\nbuild:\n  stage: build\n  script:\n    - hpm install\n  artifacts:\n    paths:\n      - hem_modules/\n\ntest:\n  stage: test\n  script:\n    - hpm test\n```\n\n### Docker\n\n**Dockerfile:**\n\n```dockerfile\nFROM hemlock:latest\n\nWORKDIR /app\n\n# パッケージファイルを最初にコピー（レイヤーキャッシュ用）\nCOPY package.json package-lock.json ./\n\n# 依存関係をインストール\nRUN hpm install\n\n# ソースコードをコピー\nCOPY . .\n\n# アプリケーションを実行\nCMD [\"hemlock\", \"src/main.hml\"]\n```\n\n**docker-compose.yml:**\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    environment:\n      - GITHUB_TOKEN=${GITHUB_TOKEN}\n    volumes:\n      - hpm-cache:/root/.hpm/cache\n\nvolumes:\n  hpm-cache:\n```\n\n## プロキシ設定\n\nプロキシの背後にある環境では、システムレベルで設定:\n\n```bash\nexport HTTP_PROXY=http://proxy.example.com:8080\nexport HTTPS_PROXY=http://proxy.example.com:8080\nexport NO_PROXY=localhost,127.0.0.1\n\nhpm install\n```\n\n## セキュリティのベストプラクティス\n\n### トークンのセキュリティ\n\n1. **トークンをバージョン管理にコミットしない**\n2. **CI/CDでは環境変数を使用**\n3. **トークンスコープを最小限に制限**\n4. **定期的にトークンをローテーション**\n5. **設定ファイルを保護**:\n   ```bash\n   chmod 600 ~/.hpm/config.json\n   ```\n\n### プライベートリポジトリ\n\nプライベートパッケージにアクセスするには:\n\n1. `repo`スコープを持つトークンを作成\n2. 認証を設定（環境変数または設定ファイル）\n3. トークンがリポジトリへのアクセス権を持っていることを確認\n\n```bash\n# アクセスをテスト\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install yourorg/private-package\n```\n\n## 設定のトラブルシューティング\n\n### 設定の確認\n\n```bash\n# トークンが設定されているかチェック\necho $GITHUB_TOKEN | head -c 10\n\n# 設定ファイルをチェック\ncat ~/.hpm/config.json\n\n# キャッシュディレクトリをチェック\nls -la ~/.hpm/cache/\n\n# 詳細出力でテスト\nhpm install --verbose\n```\n\n### よくある問題\n\n**\"GitHub rate limit exceeded\"**\n- `GITHUB_TOKEN`で認証を設定\n- レート制限のリセットを待つ\n- パッケージがキャッシュされている場合は`--offline`を使用\n\n**キャッシュの\"Permission denied\"**\n```bash\n# キャッシュの権限を修正\nchmod -R u+rw ~/.hpm/cache\n```\n\n**\"Config file not found\"**\n```bash\n# 設定ディレクトリを作成\nmkdir -p ~/.hpm\ntouch ~/.hpm/config.json\n```\n\n## 参照\n\n- [インストール](#hpm-configuration-installation) - hpmのインストール\n- [トラブルシューティング](#hpm-configuration-troubleshooting) - よくある問題\n- [コマンド](#hpm-configuration-commands) - コマンドリファレンス\n"}, "hpm: パッケージ開発 -> バージョニング": {"id": "hpm-versioning", "content": "# バージョニング\n\nhpmにおけるセマンティックバージョニングの完全ガイド。\n\n## セマンティックバージョニング\n\nhpmはパッケージバージョンに[セマンティックバージョニング2.0.0](https://semver.org/)（semver）を使用します。\n\n### バージョン形式\n\n```\nMAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]\n```\n\n**例:**\n```\n1.0.0           # リリースバージョン\n2.1.3           # リリースバージョン\n1.0.0-alpha     # プレリリース\n1.0.0-beta.1    # 番号付きプレリリース\n1.0.0-rc.1      # リリース候補\n1.0.0+20231201  # ビルドメタデータ付き\n1.0.0-beta+exp  # プレリリース＋ビルドメタデータ\n```\n\n### バージョンコンポーネント\n\n| コンポーネント | 説明 | 例 |\n|-----------|-------------|---------|\n| MAJOR | 破壊的変更 | `1.0.0` → `2.0.0` |\n| MINOR | 新機能（後方互換） | `1.0.0` → `1.1.0` |\n| PATCH | バグ修正（後方互換） | `1.0.0` → `1.0.1` |\n| PRERELEASE | プレリリース識別子 | `1.0.0-alpha` |\n| BUILD | ビルドメタデータ（比較で無視） | `1.0.0+build123` |\n\n### いつインクリメントするか\n\n| 変更タイプ | インクリメント | 例 |\n|-------------|-----------|---------|\n| 破壊的なAPI変更 | MAJOR | 関数の削除 |\n| パブリック関数の名前変更 | MAJOR | `parse()` → `decode()` |\n| 関数シグネチャの変更 | MAJOR | 必須パラメータの追加 |\n| 新しい関数の追加 | MINOR | `validate()`の追加 |\n| オプションパラメータの追加 | MINOR | 新しいオプション`options`引数 |\n| バグ修正 | PATCH | nullポインタの修正 |\n| パフォーマンス改善 | PATCH | より高速なアルゴリズム |\n| 内部リファクタリング | PATCH | API変更なし |\n\n## バージョン制約\n\n### 制約の構文\n\n| 構文 | 意味 | 解決範囲 |\n|--------|---------|-------------|\n| `1.2.3` | 正確なバージョン | 1.2.3のみ |\n| `^1.2.3` | キャレット（互換） | ≥1.2.3 かつ <2.0.0 |\n| `~1.2.3` | チルダ（パッチ更新） | ≥1.2.3 かつ <1.3.0 |\n| `>=1.0.0` | 以上 | 1.0.0以上 |\n| `>1.0.0` | より大きい | 1.0.0より上 |\n| `<2.0.0` | 未満 | 2.0.0未満 |\n| `<=2.0.0` | 以下 | 2.0.0以下 |\n| `>=1.0.0 <2.0.0` | 範囲 | 1.0.0と2.0.0の間 |\n| `*` | 任意 | 任意のバージョン |\n\n### キャレット範囲（^）\n\nキャレット（`^`）は最左の非ゼロ桁を変更しない変更を許可:\n\n```\n^1.2.3  →  >=1.2.3 <2.0.0   # 1.x.xを許可\n^0.2.3  →  >=0.2.3 <0.3.0   # 0.2.xを許可\n^0.0.3  →  >=0.0.3 <0.0.4   # 0.0.3のみを許可\n```\n\n**使用場面:** メジャーバージョン内で互換性のある更新が必要な場合。\n\n**最も一般的な制約** - ほとんどの依存関係に推奨。\n\n### チルダ範囲（~）\n\nチルダ（`~`）はパッチレベルの変更のみを許可:\n\n```\n~1.2.3  →  >=1.2.3 <1.3.0   # 1.2.xを許可\n~1.2    →  >=1.2.0 <1.3.0   # 1.2.xを許可\n~1      →  >=1.0.0 <2.0.0   # 1.x.xを許可\n```\n\n**使用場面:** バグ修正のみが必要で、新機能は不要な場合。\n\n### 比較範囲\n\n比較演算子を組み合わせて正確に制御:\n\n```json\n{\n  \"dependencies\": {\n    \"owner/pkg\": \">=1.0.0 <2.0.0\",\n    \"owner/other\": \">1.5.0 <=2.1.0\"\n  }\n}\n```\n\n### 任意のバージョン（*）\n\n任意のバージョンに一致:\n\n```json\n{\n  \"dependencies\": {\n    \"owner/pkg\": \"*\"\n  }\n}\n```\n\n**警告:** 本番環境には推奨しません。常に最新バージョンを取得します。\n\n## プレリリースバージョン\n\n### プレリリース識別子\n\nプレリリースはリリースより優先順位が低い:\n\n```\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0\n```\n\n### 一般的なプレリリースタグ\n\n| タグ | 意味 | ステージ |\n|-----|---------|-------|\n| `alpha` | 初期開発 | 非常に不安定 |\n| `beta` | 機能完了 | テスト中 |\n| `rc` | リリース候補 | 最終テスト |\n| `dev` | 開発スナップショット | 不安定 |\n\n### 制約でのプレリリース\n\n制約はデフォルトでプレリリースに一致しない:\n\n```\n^1.0.0    # 1.1.0-betaに一致しない\n>=1.0.0   # 2.0.0-alphaに一致しない\n```\n\nプレリリースを含めるには、明示的に参照:\n\n```\n>=1.0.0-alpha <2.0.0   # すべての1.xプレリリースを含む\n```\n\n## バージョン比較\n\n### 比較ルール\n\n1. MAJOR、MINOR、PATCHを数値比較\n2. 同じバージョンではリリース > プレリリース\n3. プレリリースは英数字順で比較\n4. ビルドメタデータは無視\n\n### 例\n\n```\n1.0.0 < 1.0.1 < 1.1.0 < 2.0.0\n\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0\n\n1.0.0 = 1.0.0+build123  # ビルドメタデータは無視\n```\n\n### ソート\n\nバージョンは昇順でソート:\n\n```\n1.0.0\n1.0.1\n1.1.0\n1.1.1\n2.0.0-alpha\n2.0.0-beta\n2.0.0\n```\n\n## バージョン解決\n\n### 解決アルゴリズム\n\n複数のパッケージが同じ依存関係を要求する場合:\n\n1. すべての制約を収集\n2. すべての範囲の共通部分を見つける\n3. 共通部分内で最高バージョンを選択\n4. すべてを満たすバージョンがない場合はエラー\n\n### 解決例\n\n```\npackage-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npackage-b requires hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)\n\n共通部分: >=1.2.0 <1.3.0\n利用可能: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]\n解決: 1.2.5（共通部分内で最高）\n```\n\n### 競合検出\n\nすべての制約を満たすバージョンがない場合に競合が発生:\n\n```\npackage-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npackage-b requires hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)\n\n共通部分: （空）\n結果: 競合 - 両方を満たすバージョンがない\n```\n\n## ベストプラクティス\n\n### パッケージ利用者向け\n\n1. **ほとんどの依存関係にキャレット範囲を使用**:\n   ```json\n   \"hemlang/json\": \"^1.2.0\"\n   ```\n\n2. **重要な依存関係にはチルダ範囲を使用**:\n   ```json\n   \"critical/lib\": \"~1.2.0\"\n   ```\n\n3. **必要な場合のみバージョンを固定**:\n   ```json\n   \"unstable/pkg\": \"1.2.3\"\n   ```\n\n4. **再現可能なビルドのためにロックファイルをコミット**\n\n5. **セキュリティ修正を得るために定期的に更新**:\n   ```bash\n   hpm update\n   hpm outdated\n   ```\n\n### パッケージ作成者向け\n\n1. **初期開発は0.1.0から開始**:\n   - APIは頻繁に変更される可能性\n   - ユーザーは不安定さを期待\n\n2. **APIが安定したら1.0.0に移行**:\n   - 安定性へのパブリックコミットメント\n   - 破壊的変更にはメジャーバンプが必要\n\n3. **semverを厳密に守る**:\n   - 破壊的変更 = MAJOR\n   - 新機能 = MINOR\n   - バグ修正 = PATCH\n\n4. **テストにはプレリリースを使用**:\n   ```bash\n   git tag v2.0.0-beta.1\n   git push --tags\n   ```\n\n5. **破壊的変更をCHANGELOGにドキュメント化**\n\n## バージョンの公開\n\n### リリースの作成\n\n```bash\n# package.jsonのバージョンを更新\n# package.jsonを編集: \"version\": \"1.1.0\"\n\n# バージョン変更をコミット\ngit add package.json\ngit commit -m \"Bump version to 1.1.0\"\n\n# タグを作成してプッシュ\ngit tag v1.1.0\ngit push origin main --tags\n```\n\n### タグ形式\n\nタグは`v`で始まる**必要あり**:\n\n```\nv1.0.0      ✓ 正しい\nv1.0.0-beta ✓ 正しい\n1.0.0       ✗ 認識されない\n```\n\n### リリースワークフロー\n\n```bash\n# 1. テストが合格することを確認\nhpm test\n\n# 2. package.jsonのバージョンを更新\n# 3. CHANGELOG.mdを更新\n# 4. 変更をコミット\ngit add -A\ngit commit -m \"Release v1.2.0\"\n\n# 5. タグを作成\ngit tag v1.2.0\n\n# 6. すべてをプッシュ\ngit push origin main --tags\n```\n\n## バージョンの確認\n\n### インストールされたバージョンをリスト\n\n```bash\nhpm list\n```\n\n### 更新を確認\n\n```bash\nhpm outdated\n```\n\n出力:\n```\nPackage         Current  Wanted  Latest\nhemlang/json    1.0.0    1.0.5   1.2.0\nhemlang/sprout  2.0.0    2.0.3   2.1.0\n```\n\n- **Current**: インストールされているバージョン\n- **Wanted**: 制約に一致する最高バージョン\n- **Latest**: 最新の利用可能バージョン\n\n### パッケージの更新\n\n```bash\n# すべてを更新\nhpm update\n\n# 特定のパッケージを更新\nhpm update hemlang/json\n```\n\n## 参照\n\n- [パッケージの作成](#hpm-versioning-creating-packages) - 公開ガイド\n- [パッケージ仕様](#hpm-versioning-package-spec) - package.jsonの形式\n- [コマンド](#hpm-versioning-commands) - CLIリファレンス\n"}, "hpm: パッケージ開発 -> パッケージの作成": {"id": "hpm-creating-packages", "content": "# パッケージの作成\n\nこのガイドでは、Hemlockパッケージの作成、構造化、公開方法について説明します。\n\n## 概要\n\nhpmはGitHubをパッケージレジストリとして使用します。パッケージはGitHubの`owner/repo`パスで識別され、バージョンはGitタグです。公開は単にタグ付きリリースをプッシュするだけです。\n\n## 新しいパッケージの作成\n\n### 1. パッケージの初期化\n\n新しいディレクトリを作成して初期化:\n\n```bash\nmkdir my-package\ncd my-package\nhpm init\n```\n\nプロンプトに答えます:\n\n```\nPackage name (owner/repo): yourusername/my-package\nVersion (1.0.0):\nDescription: A useful Hemlock package\nAuthor: Your Name <you@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n### 2. プロジェクト構造の作成\n\nパッケージの推奨構造:\n\n```\nmy-package/\n├── package.json          # パッケージマニフェスト\n├── README.md             # ドキュメント\n├── LICENSE               # ライセンスファイル\n├── src/\n│   ├── index.hml         # メインエントリポイント（パブリックAPIをエクスポート）\n│   ├── utils.hml         # 内部ユーティリティ\n│   └── types.hml         # 型定義\n└── test/\n    ├── framework.hml     # テストフレームワーク\n    └── test_utils.hml    # テスト\n```\n\n### 3. パブリックAPIの定義\n\n**src/index.hml** - メインエントリポイント:\n\n```hemlock\n// パブリックAPIを再エクスポート\nexport { parse, stringify } from \"./parser.hml\";\nexport { Config, Options } from \"./types.hml\";\nexport { process } from \"./processor.hml\";\n\n// 直接エクスポート\nexport fn create(options: Options): Config {\n    // 実装\n}\n\nexport fn validate(config: Config): bool {\n    // 実装\n}\n```\n\n### 4. package.jsonの記述\n\n完全なpackage.jsonの例:\n\n```json\n{\n  \"name\": \"yourusername/my-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A useful Hemlock package\",\n  \"author\": \"Your Name <you@example.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/yourusername/my-package\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/bundle.hmlc\"\n  },\n  \"keywords\": [\"utility\", \"parser\", \"config\"],\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n## パッケージの命名\n\n### 要件\n\n- `owner/repo`形式である必要あり\n- `owner`はGitHubユーザー名または組織である必要あり\n- `repo`はリポジトリ名である必要あり\n- 複数単語の名前には小文字とハイフンを使用\n\n### 良い名前\n\n```\nhemlang/sprout\nalice/http-client\nmyorg/json-utils\nbob/date-formatter\n```\n\n### 避けるべき名前\n\n```\nmy-package          # ownerがない\nalice/MyPackage     # PascalCase\nalice/my_package    # アンダースコア\n```\n\n## パッケージ構造のベストプラクティス\n\n### エントリポイント\n\npackage.jsonの`main`フィールドがエントリポイントを指定:\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\nこのファイルでパブリックAPIをエクスポート:\n\n```hemlock\n// ユーザーが必要とするすべてをエクスポート\nexport { Parser, parse } from \"./parser.hml\";\nexport { Formatter, format } from \"./formatter.hml\";\n\n// 型\nexport type { Config, Options } from \"./types.hml\";\n```\n\n### 内部 vs パブリック\n\n内部実装の詳細をプライベートに保つ:\n\n```\nsrc/\n├── index.hml          # パブリック: エクスポートされるAPI\n├── parser.hml         # パブリック: index.hmlで使用\n├── formatter.hml      # パブリック: index.hmlで使用\n└── internal/\n    ├── helpers.hml    # プライベート: 内部使用のみ\n    └── constants.hml  # プライベート: 内部使用のみ\n```\n\nユーザーはパッケージルートからインポート:\n\n```hemlock\n// 良い - パブリックAPIからインポート\nimport { parse, Parser } from \"yourusername/my-package\";\n\n// 可能 - サブパスインポート\nimport { validate } from \"yourusername/my-package/validator\";\n\n// 非推奨 - 内部へのアクセス\nimport { helper } from \"yourusername/my-package/internal/helpers\";\n```\n\n### サブパスエクスポート\n\nサブパスからのインポートをサポート:\n\n```\nsrc/\n├── index.hml              # メインエントリ\n├── parser/\n│   └── index.hml          # yourusername/pkg/parser\n├── formatter/\n│   └── index.hml          # yourusername/pkg/formatter\n└── utils/\n    └── index.hml          # yourusername/pkg/utils\n```\n\nユーザーは以下のようにインポート可能:\n\n```hemlock\nimport { parse } from \"yourusername/my-package\";           // メイン\nimport { Parser } from \"yourusername/my-package/parser\";   // サブパス\nimport { format } from \"yourusername/my-package/formatter\";\n```\n\n## 依存関係\n\n### 依存関係の追加\n\n```bash\n# ランタイム依存関係\nhpm install hemlang/json\n\n# 開発依存関係\nhpm install hemlang/test-utils --dev\n```\n\n### 依存関係のベストプラクティス\n\n1. **ほとんどの依存関係にキャレット範囲を使用**:\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     }\n   }\n   ```\n\n2. **必要な場合のみバージョンを固定**（APIが不安定な場合）:\n   ```json\n   {\n     \"dependencies\": {\n       \"unstable/lib\": \"1.2.3\"\n     }\n   }\n   ```\n\n3. **過度に制限的な範囲を避ける**:\n   ```json\n   // 悪い: 制限しすぎ\n   \"hemlang/json\": \">=1.2.3 <1.2.5\"\n\n   // 良い: 互換性のある更新を許可\n   \"hemlang/json\": \"^1.2.3\"\n   ```\n\n4. **開発依存関係を分離**:\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     },\n     \"devDependencies\": {\n       \"hemlang/test-utils\": \"^1.0.0\"\n     }\n   }\n   ```\n\n## パッケージのテスト\n\n### テストの作成\n\n**test/run.hml:**\n\n```hemlock\nimport { suite, test, assert_eq } from \"./framework.hml\";\nimport { parse, stringify } from \"../src/index.hml\";\n\nfn run_tests() {\n    suite(\"Parser\", fn() {\n        test(\"parses valid input\", fn() {\n            let result = parse(\"hello\");\n            assert_eq(result.value, \"hello\");\n        });\n\n        test(\"handles empty input\", fn() {\n            let result = parse(\"\");\n            assert_eq(result.value, \"\");\n        });\n    });\n\n    suite(\"Stringify\", fn() {\n        test(\"stringifies object\", fn() {\n            let obj = { name: \"test\" };\n            let result = stringify(obj);\n            assert_eq(result, '{\"name\":\"test\"}');\n        });\n    });\n}\n\nrun_tests();\n```\n\n### テストの実行\n\nテストスクリプトを追加:\n\n```json\n{\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\n以下で実行:\n\n```bash\nhpm test\n```\n\n## 公開\n\n### 前提条件\n\n1. パッケージ名に一致するGitHubリポジトリを作成\n2. `package.json`が完全で有効であることを確認\n3. すべてのテストが合格\n\n### 公開プロセス\n\n公開は単にGitタグをプッシュするだけ:\n\n```bash\n# 1. すべてがコミットされていることを確認\ngit add .\ngit commit -m \"Prepare v1.0.0 release\"\n\n# 2. バージョンタグを作成（'v'で始まる必要あり）\ngit tag v1.0.0\n\n# 3. コードとタグをプッシュ\ngit push origin main\ngit push origin v1.0.0\n# または一度にすべてのタグをプッシュ\ngit push origin main --tags\n```\n\n### バージョンタグ\n\nタグは`vX.Y.Z`形式に従う必要あり:\n\n```bash\ngit tag v1.0.0      # リリース\ngit tag v1.0.1      # パッチ\ngit tag v1.1.0      # マイナー\ngit tag v2.0.0      # メジャー\ngit tag v1.0.0-beta.1  # プレリリース\n```\n\n### リリースチェックリスト\n\n新しいバージョンを公開する前に:\n\n1. package.jsonの**バージョンを更新**\n2. **テストを実行**: `hpm test`\n3. **CHANGELOG**を更新（ある場合）\n4. APIが変更された場合は**README**を更新\n5. **変更をコミット**\n6. **タグを作成**\n7. **GitHubにプッシュ**\n\n### 自動化の例\n\nリリーススクリプトを作成:\n\n```bash\n#!/bin/bash\n# release.sh - 新しいバージョンをリリース\n\nVERSION=$1\n\nif [ -z \"$VERSION\" ]; then\n    echo \"Usage: ./release.sh 1.0.0\"\n    exit 1\nfi\n\n# テストを実行\nhpm test || exit 1\n\n# package.jsonのバージョンを更新\nsed -i \"s/\\\"version\\\": \\\".*\\\"/\\\"version\\\": \\\"$VERSION\\\"/\" package.json\n\n# コミットとタグ\ngit add package.json\ngit commit -m \"Release v$VERSION\"\ngit tag \"v$VERSION\"\n\n# プッシュ\ngit push origin main --tags\n\necho \"Released v$VERSION\"\n```\n\n## ユーザーによるパッケージのインストール\n\n公開後、ユーザーは以下でインストール可能:\n\n```bash\n# 最新バージョン\nhpm install yourusername/my-package\n\n# 特定のバージョン\nhpm install yourusername/my-package@1.0.0\n\n# バージョン制約\nhpm install yourusername/my-package@^1.0.0\n```\n\nそしてインポート:\n\n```hemlock\nimport { parse, stringify } from \"yourusername/my-package\";\n```\n\n## ドキュメント\n\n### README.md\n\nすべてのパッケージにはREADMEが必要:\n\n```markdown\n# my-package\n\nこのパッケージが何をするかの簡単な説明。\n\n## インストール\n\n\\`\\`\\`bash\nhpm install yourusername/my-package\n\\`\\`\\`\n\n## 使用方法\n\n\\`\\`\\`hemlock\nimport { parse } from \"yourusername/my-package\";\n\nlet result = parse(\"input\");\n\\`\\`\\`\n\n## API\n\n### parse(input: string): Result\n\n入力文字列を解析します。\n\n### stringify(obj: any): string\n\nオブジェクトを文字列に変換します。\n\n## ライセンス\n\nMIT\n```\n\n### APIドキュメント\n\nすべてのパブリックエクスポートをドキュメント化:\n\n```hemlock\n/// 入力文字列を構造化されたResultに解析します。\n///\n/// # 引数\n/// * `input` - 解析する文字列\n///\n/// # 戻り値\n/// 解析されたデータまたはエラーを含むResult\n///\n/// # 例\n/// ```\n/// let result = parse(\"hello world\");\n/// print(result.value);\n/// ```\nexport fn parse(input: string): Result {\n    // 実装\n}\n```\n\n## バージョニングガイドライン\n\n[セマンティックバージョニング](https://semver.org/)に従う:\n\n- **MAJOR**（1.0.0 → 2.0.0）: 破壊的変更\n- **MINOR**（1.0.0 → 1.1.0）: 新機能、後方互換\n- **PATCH**（1.0.0 → 1.0.1）: バグ修正、後方互換\n\n### いつバンプするか\n\n| 変更タイプ | バージョンバンプ |\n|-------------|--------------|\n| 破壊的なAPI変更 | MAJOR |\n| 関数/型の削除 | MAJOR |\n| 関数シグネチャの変更 | MAJOR |\n| 新しい関数の追加 | MINOR |\n| 新しい機能の追加 | MINOR |\n| バグ修正 | PATCH |\n| ドキュメント更新 | PATCH |\n| 内部リファクタリング | PATCH |\n\n## 参照\n\n- [パッケージ仕様](#hpm-creating-packages-package-spec) - 完全なpackage.jsonリファレンス\n- [バージョニング](#hpm-creating-packages-versioning) - セマンティックバージョニングの詳細\n- [設定](#hpm-creating-packages-configuration) - GitHub認証\n"}, "hpm: パッケージ開発 -> パッケージ仕様": {"id": "hpm-package-spec", "content": "# パッケージ仕様\n\n`package.json`ファイル形式の完全なリファレンス。\n\n## 概要\n\nすべてのhpmパッケージにはプロジェクトルートに`package.json`ファイルが必要です。このファイルはパッケージのメタデータ、依存関係、スクリプトを定義します。\n\n## 最小限の例\n\n```json\n{\n  \"name\": \"owner/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n## 完全な例\n\n```json\n{\n  \"name\": \"hemlang/example-package\",\n  \"version\": \"1.2.3\",\n  \"description\": \"An example Hemlock package\",\n  \"author\": \"Hemlock Team <team@hemlock.dev>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/hemlang/example-package\",\n  \"homepage\": \"https://hemlang.github.io/example-package\",\n  \"bugs\": \"https://github.com/hemlang/example-package/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"example\", \"utility\", \"hemlock\"],\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"^2.1.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/bundle.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n## フィールドリファレンス\n\n### name（必須）\n\n`owner/repo`形式のパッケージ名。\n\n```json\n{\n  \"name\": \"hemlang/sprout\"\n}\n```\n\n**要件:**\n- `owner/repo`形式である必要あり\n- `owner`はGitHubユーザー名または組織である必要あり\n- `repo`はリポジトリ名である必要あり\n- 小文字、数字、ハイフンを使用\n- 合計最大214文字\n\n**有効な名前:**\n```\nhemlang/sprout\nalice/http-client\nmyorg/json-utils\nbob123/my-lib\n```\n\n**無効な名前:**\n```\nmy-package          # ownerがない\nhemlang/My_Package  # 大文字とアンダースコア\nhemlang             # repoがない\n```\n\n### version（必須）\n\n[セマンティックバージョニング](https://semver.org/)に従うパッケージバージョン。\n\n```json\n{\n  \"version\": \"1.2.3\"\n}\n```\n\n**形式:** `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`\n\n**有効なバージョン:**\n```\n1.0.0\n2.1.3\n1.0.0-alpha\n1.0.0-beta.1\n1.0.0-rc.1+build.123\n0.1.0\n```\n\n### description\n\nパッケージの短い説明。\n\n```json\n{\n  \"description\": \"A fast JSON parser for Hemlock\"\n}\n```\n\n- 200文字以下に保つ\n- パッケージが何をするかを説明、どのようにではなく\n\n### author\n\nパッケージ作者情報。\n\n```json\n{\n  \"author\": \"Your Name <email@example.com>\"\n}\n```\n\n**受け入れられる形式:**\n```json\n\"author\": \"Your Name\"\n\"author\": \"Your Name <email@example.com>\"\n\"author\": \"Your Name <email@example.com> (https://website.com)\"\n```\n\n### license\n\nライセンス識別子。\n\n```json\n{\n  \"license\": \"MIT\"\n}\n```\n\n**一般的なライセンス:**\n- `MIT` - MITライセンス\n- `Apache-2.0` - Apache License 2.0\n- `GPL-3.0` - GNU General Public License v3.0\n- `BSD-3-Clause` - BSD 3条項ライセンス\n- `ISC` - ISCライセンス\n- `UNLICENSED` - プロプライエタリ/プライベート\n\n可能な限り[SPDX識別子](https://spdx.org/licenses/)を使用してください。\n\n### repository\n\nソースリポジトリへのリンク。\n\n```json\n{\n  \"repository\": \"https://github.com/hemlang/sprout\"\n}\n```\n\n### homepage\n\nプロジェクトホームページURL。\n\n```json\n{\n  \"homepage\": \"https://sprout.hemlock.dev\"\n}\n```\n\n### bugs\n\nイシュートラッカーURL。\n\n```json\n{\n  \"bugs\": \"https://github.com/hemlang/sprout/issues\"\n}\n```\n\n### main\n\nパッケージのエントリポイントファイル。\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\n**デフォルト:** `src/index.hml`\n\nユーザーがパッケージをインポートするとき:\n```hemlock\nimport { x } from \"owner/repo\";\n```\n\nhpmは`main`で指定されたファイルをロードします。\n\n**インポートの解決順序:**\n1. 正確なパス: `src/index.hml`\n2. .hml拡張子付き: `src/index` → `src/index.hml`\n3. indexファイル: `src/index/` → `src/index/index.hml`\n\n### keywords\n\n発見性のためのキーワード配列。\n\n```json\n{\n  \"keywords\": [\"json\", \"parser\", \"utility\", \"hemlock\"]\n}\n```\n\n- 小文字を使用\n- 具体的で関連性のあるものに\n- 適切な場合は言語（\"hemlock\"）を含める\n\n### dependencies\n\nパッケージが動作するために必要なランタイム依存関係。\n\n```json\n{\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"~2.1.0\",\n    \"alice/logger\": \">=1.0.0 <2.0.0\"\n  }\n}\n```\n\n**キー:** パッケージ名（`owner/repo`）\n**値:** バージョン制約\n\n**バージョン制約の構文:**\n\n| 制約 | 意味 |\n|------------|---------|\n| `1.2.3` | 正確なバージョン |\n| `^1.2.3` | >=1.2.3 <2.0.0 |\n| `~1.2.3` | >=1.2.3 <1.3.0 |\n| `>=1.0.0` | 1.0.0以上 |\n| `>=1.0.0 <2.0.0` | 範囲 |\n| `*` | 任意のバージョン |\n\n### devDependencies\n\n開発専用の依存関係（テスト、ビルドなど）。\n\n```json\n{\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\",\n    \"hemlang/linter\": \"^2.0.0\"\n  }\n}\n```\n\n開発依存関係は:\n- 開発中にインストールされる\n- パッケージが依存関係として使用されるときはインストールされない\n- テスト、ビルド、リンティングなどに使用\n\n### scripts\n\n`hpm run`で実行できる名前付きコマンド。\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n**スクリプトの実行:**\n```bash\nhpm run start\nhpm run build\nhpm test        # 'hpm run test'の短縮形\n```\n\n**引数の渡し方:**\n```bash\nhpm run test -- --verbose --filter=unit\n```\n\n**一般的なスクリプト:**\n\n| スクリプト | 目的 |\n|--------|---------|\n| `start` | アプリケーションを起動 |\n| `dev` | ホットリロード付き開発モード |\n| `test` | テストを実行 |\n| `build` | 本番用にビルド |\n| `clean` | ビルド成果物を削除 |\n| `lint` | コードスタイルをチェック |\n| `format` | コードをフォーマット |\n\n### files\n\nパッケージがインストールされるときに含めるファイルとディレクトリ。\n\n```json\n{\n  \"files\": [\n    \"src/\",\n    \"lib/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n**デフォルト動作:** 指定されていない場合、以下を含む:\n- リポジトリ内のすべてのファイル\n- `.git/`、`node_modules/`、`hem_modules/`を除外\n\n**用途:**\n- パッケージサイズを削減\n- 配布からテストファイルを除外\n- 必要なファイルのみを含める\n\n### native\n\nネイティブライブラリの要件。\n\n```json\n{\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\", \"sqlite3\"]\n  }\n}\n```\n\nシステムにインストールが必要なネイティブ依存関係をドキュメント化します。\n\n## 検証\n\nhpmは様々な操作でpackage.jsonを検証します。一般的な検証エラー:\n\n### 必須フィールドの欠落\n\n```\nError: package.json missing required field: name\n```\n\n**修正:** 必須フィールドを追加。\n\n### 無効なname形式\n\n```\nError: Invalid package name. Must be in owner/repo format.\n```\n\n**修正:** `owner/repo`形式を使用。\n\n### 無効なversion\n\n```\nError: Invalid version \"1.0\". Must be semver format (X.Y.Z).\n```\n\n**修正:** 完全なsemver形式（`1.0.0`）を使用。\n\n### 無効なJSON\n\n```\nError: package.json is not valid JSON\n```\n\n**修正:** JSON構文を確認（カンマ、クォート、括弧）。\n\n## package.jsonの作成\n\n### インタラクティブ\n\n```bash\nhpm init\n```\n\n各フィールドをインタラクティブにプロンプト。\n\n### デフォルト値で\n\n```bash\nhpm init --yes\n```\n\nデフォルト値で作成:\n```json\n{\n  \"name\": \"directory-name/directory-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\n### 手動\n\nファイルを手動で作成:\n\n```bash\ncat > package.json << 'EOF'\n{\n  \"name\": \"yourname/your-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Your package description\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\nEOF\n```\n\n## ベストプラクティス\n\n1. **常にmainを指定** - デフォルトに頼らない\n2. **キャレット範囲を使用** - ほとんどの依存関係には`^1.0.0`\n3. **開発依存関係を分離** - テスト/ビルド依存関係はdevDependenciesに\n4. **キーワードを含める** - ユーザーがパッケージを見つけやすくする\n5. **スクリプトをドキュメント化** - スクリプトに明確な名前を付ける\n6. **ライセンスを指定** - オープンソースには必須\n7. **説明を追加** - ユーザーが目的を理解しやすくする\n\n## 参照\n\n- [パッケージの作成](#hpm-package-spec-creating-packages) - 公開ガイド\n- [バージョニング](#hpm-package-spec-versioning) - バージョン制約\n- [プロジェクトセットアップ](#hpm-package-spec-project-setup) - プロジェクト構造\n"}, "hpm: リファレンス -> アーキテクチャ": {"id": "hpm-architecture", "content": "# アーキテクチャ\n\nhpmの内部アーキテクチャと設計。このドキュメントは、貢献者およびhpmの動作に興味のある方向けです。\n\n## 概要\n\nhpmはHemlockで書かれており、パッケージ管理の様々な側面を処理するいくつかのモジュールで構成されています:\n\n```\nsrc/\n├── main.hml        # CLIエントリポイントとコマンドルーティング\n├── manifest.hml    # package.jsonの処理\n├── lockfile.hml    # package-lock.jsonの処理\n├── semver.hml      # セマンティックバージョニング\n├── resolver.hml    # 依存関係解決\n├── github.hml      # GitHub APIクライアント\n├── installer.hml   # パッケージのダウンロードと展開\n└── cache.hml       # グローバルキャッシュ管理\n```\n\n## モジュールの責務\n\n### main.hml\n\nCLIアプリケーションのエントリポイント。\n\n**責務:**\n- コマンドライン引数の解析\n- 適切なハンドラへのコマンドルーティング\n- ヘルプとバージョン情報の表示\n- グローバルフラグの処理（--verbose、--dry-runなど）\n- 適切なコードでの終了\n\n**主要関数:**\n- `main()` - エントリポイント、引数を解析してコマンドをディスパッチ\n- `cmd_init()` - `hpm init`を処理\n- `cmd_install()` - `hpm install`を処理\n- `cmd_uninstall()` - `hpm uninstall`を処理\n- `cmd_update()` - `hpm update`を処理\n- `cmd_list()` - `hpm list`を処理\n- `cmd_outdated()` - `hpm outdated`を処理\n- `cmd_run()` - `hpm run`を処理\n- `cmd_why()` - `hpm why`を処理\n- `cmd_cache()` - `hpm cache`を処理\n\n**コマンドショートカット:**\n```hemlock\nlet shortcuts = {\n    \"i\": \"install\",\n    \"rm\": \"uninstall\",\n    \"remove\": \"uninstall\",\n    \"ls\": \"list\",\n    \"up\": \"update\"\n};\n```\n\n### manifest.hml\n\n`package.json`ファイルの読み書きを処理。\n\n**責務:**\n- package.jsonの読み書き\n- パッケージ構造の検証\n- 依存関係の管理\n- パッケージ指定子（owner/repo@version）の解析\n\n**主要関数:**\n```hemlock\ncreate_default(): Manifest           // 空のマニフェストを作成\nread_manifest(): Manifest            // ファイルから読み込み\nwrite_manifest(m: Manifest)          // ファイルに書き込み\nvalidate(m: Manifest): bool          // 構造を検証\nget_all_dependencies(m): Map         // deps + devDepsを取得\nadd_dependency(m, pkg, ver, dev)     // 依存関係を追加\nremove_dependency(m, pkg)            // 依存関係を削除\nparse_specifier(spec): (name, ver)   // \"owner/repo@^1.0.0\"を解析\nsplit_name(name): (owner, repo)      // \"owner/repo\"を解析\n```\n\n**マニフェスト構造:**\n```hemlock\ntype Manifest = {\n    name: string,\n    version: string,\n    description: string?,\n    author: string?,\n    license: string?,\n    repository: string?,\n    main: string?,\n    dependencies: Map<string, string>,\n    devDependencies: Map<string, string>,\n    scripts: Map<string, string>\n};\n```\n\n### lockfile.hml\n\n再現可能なインストールのための`package-lock.json`ファイルを管理。\n\n**責務:**\n- ロックファイルの作成/読み取り/書き込み\n- 解決された正確なバージョンの追跡\n- ダウンロードURLと整合性ハッシュの保存\n- 孤立した依存関係の削除\n\n**主要関数:**\n```hemlock\ncreate_empty(): Lockfile              // 空のロックファイルを作成\nread_lockfile(): Lockfile             // ファイルから読み込み\nwrite_lockfile(l: Lockfile)           // ファイルに書き込み\ncreate_entry(ver, url, hash, deps)    // ロックエントリを作成\nget_locked(l, pkg): LockEntry?        // ロックされたバージョンを取得\nset_locked(l, pkg, entry)             // ロックされたバージョンを設定\nremove_locked(l, pkg)                 // エントリを削除\nprune(l, keep: Set)                   // 孤立を削除\nneeds_update(l, m): bool              // 同期が取れているかチェック\n```\n\n**ロックファイル構造:**\n```hemlock\ntype Lockfile = {\n    lockVersion: int,\n    hemlock: string,\n    dependencies: Map<string, LockEntry>\n};\n\ntype LockEntry = {\n    version: string,\n    resolved: string,     // ダウンロードURL\n    integrity: string,    // SHA256ハッシュ\n    dependencies: Map<string, string>\n};\n```\n\n### semver.hml\n\nセマンティックバージョニング2.0.0の完全な実装。\n\n**責務:**\n- バージョン文字列の解析\n- バージョンの比較\n- バージョン制約の解析と評価\n- 制約を満たすバージョンの検索\n\n**主要関数:**\n```hemlock\n// 解析\nparse(s: string): Version             // \"1.2.3-beta+build\" → Version\nstringify(v: Version): string         // Version → \"1.2.3-beta+build\"\n\n// 比較\ncompare(a, b: Version): int           // -1、0、または1\ngt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool\n\n// 制約\nparse_constraint(s: string): Constraint    // \"^1.2.3\" → Constraint\nsatisfies(v: Version, c: Constraint): bool // vがcに一致するかチェック\nmax_satisfying(versions, c): Version?      // 最高の一致を見つける\nsort(versions): [Version]                  // 昇順ソート\n\n// ユーティリティ\nconstraints_overlap(a, b: Constraint): bool  // 互換性をチェック\n```\n\n**バージョン構造:**\n```hemlock\ntype Version = {\n    major: int,\n    minor: int,\n    patch: int,\n    prerelease: [string]?,  // 例: [\"beta\", \"1\"]\n    build: string?          // 例: \"20230101\"\n};\n```\n\n**制約の種類:**\n```hemlock\ntype Constraint =\n    | Exact(Version)           // \"1.2.3\"\n    | Caret(Version)           // \"^1.2.3\" → >=1.2.3 <2.0.0\n    | Tilde(Version)           // \"~1.2.3\" → >=1.2.3 <1.3.0\n    | Range(op, Version)       // \">=1.0.0\"、\"<2.0.0\"\n    | And(Constraint, Constraint)  // 結合された範囲\n    | Any;                     // \"*\"\n```\n\n### resolver.hml\n\nnpmスタイルの依存関係解決を実装。\n\n**責務:**\n- 依存関係ツリーの解決\n- バージョン競合の検出\n- 循環依存の検出\n- 可視化ツリーの構築\n\n**主要関数:**\n```hemlock\nresolve(manifest, lockfile): ResolveResult\n    // メインリゾルバ: 解決されたバージョンを持つすべての依存関係のフラットマップを返す\n\nresolve_version(pkg, constraints: [string]): ResolvedPackage?\n    // すべての制約を満たすバージョンを見つける\n\ndetect_cycles(deps: Map): [Cycle]?\n    // DFSを使用して循環依存を見つける\n\nbuild_tree(lockfile): Tree\n    // 表示用のツリー構造を作成\n\nfind_why(pkg, lockfile): [Chain]\n    // パッケージがインストールされている理由を説明する依存関係チェーンを見つける\n```\n\n**解決アルゴリズム:**\n\n1. **制約を収集**: マニフェストと推移的依存関係を走査\n2. **各パッケージを解決**: 各パッケージについて:\n   - 依存元からのすべてのバージョン制約を取得\n   - GitHubから利用可能なバージョンを取得\n   - すべての制約を満たす最高バージョンを見つける\n   - 満たすバージョンがない場合: 競合\n3. **循環を検出**: DFSを実行して循環依存を見つける\n4. **フラットマップを返す**: パッケージ名 → 解決されたバージョン情報\n\n**ResolveResult構造:**\n```hemlock\ntype ResolveResult = {\n    packages: Map<string, ResolvedPackage>,\n    conflicts: [Conflict]?,\n    cycles: [Cycle]?\n};\n\ntype ResolvedPackage = {\n    name: string,\n    version: Version,\n    url: string,\n    dependencies: Map<string, string>\n};\n```\n\n### github.hml\n\nパッケージ発見とダウンロード用のGitHub APIクライアント。\n\n**責務:**\n- 利用可能なバージョン（タグ）の取得\n- リポジトリからのpackage.jsonのダウンロード\n- リリースtarballのダウンロード\n- 認証とレート制限の処理\n\n**主要関数:**\n```hemlock\nget_token(): string?\n    // 環境変数または設定からトークンを取得\n\ngithub_request(url, headers?): Response\n    // リトライ付きでAPIリクエストを実行\n\nget_tags(owner, repo): [string]\n    // バージョンタグを取得（v1.0.0、v1.1.0など）\n\nget_package_json(owner, repo, ref): Manifest\n    // 特定のタグ/コミットでpackage.jsonを取得\n\ndownload_tarball(owner, repo, tag): bytes\n    // リリースアーカイブをダウンロード\n\nrepo_exists(owner, repo): bool\n    // リポジトリが存在するかチェック\n\nget_repo_info(owner, repo): RepoInfo\n    // リポジトリメタデータを取得\n```\n\n**リトライロジック:**\n- 指数バックオフ: 1秒、2秒、4秒、8秒\n- 以下でリトライ: 403（レート制限）、5xx（サーバーエラー）、ネットワークエラー\n- 最大4回リトライ\n- レート制限エラーを明確に報告\n\n**使用するAPIエンドポイント:**\n```\nGET /repos/{owner}/{repo}/tags\nGET /repos/{owner}/{repo}/contents/package.json?ref={tag}\nGET /repos/{owner}/{repo}/tarball/{tag}\nGET /repos/{owner}/{repo}\n```\n\n### installer.hml\n\nパッケージのダウンロードと展開を処理。\n\n**責務:**\n- GitHubからパッケージをダウンロード\n- hem_modulesにtarballを展開\n- キャッシュされたパッケージのチェック/使用\n- パッケージのインストール/アンインストール\n\n**主要関数:**\n```hemlock\ninstall_package(pkg: ResolvedPackage): bool\n    // 単一パッケージをダウンロードしてインストール\n\ninstall_all(packages: Map, options): InstallResult\n    // 解決されたすべてのパッケージをインストール\n\nuninstall_package(name: string): bool\n    // hem_modulesからパッケージを削除\n\nget_installed(): Map<string, string>\n    // 現在インストールされているパッケージをリスト\n\nverify_integrity(pkg): bool\n    // パッケージの整合性を検証\n\nprefetch_packages(packages: Map): void\n    // キャッシュへの並列ダウンロード（実験的）\n```\n\n**インストールプロセス:**\n\n1. 正しいバージョンで既にインストールされているかチェック\n2. キャッシュにtarballがあるかチェック\n3. キャッシュにない場合、GitHubからダウンロード\n4. 将来の使用のためにキャッシュに保存\n5. `hem_modules/owner/repo/`に展開\n6. インストールを検証\n\n**作成されるディレクトリ構造:**\n```\nhem_modules/\n└── owner/\n    └── repo/\n        ├── package.json\n        ├── src/\n        └── ...\n```\n\n### cache.hml\n\nグローバルパッケージキャッシュを管理。\n\n**責務:**\n- ダウンロードしたtarballの保存\n- キャッシュされたパッケージの取得\n- キャッシュされたパッケージのリスト\n- キャッシュのクリア\n- 設定の管理\n\n**主要関数:**\n```hemlock\nget_cache_dir(): string\n    // キャッシュディレクトリを取得（HPM_CACHE_DIRを尊重）\n\nget_config_dir(): string\n    // 設定ディレクトリを取得（~/.hpm）\n\nis_cached(owner, repo, version): bool\n    // tarballがキャッシュされているかチェック\n\nget_cached_path(owner, repo, version): string\n    // キャッシュされたtarballへのパスを取得\n\nstore_tarball_file(owner, repo, version, data): void\n    // tarballをキャッシュに保存\n\nlist_cached(): [CachedPackage]\n    // すべてのキャッシュされたパッケージをリスト\n\nclear_cache(): int\n    // すべてのキャッシュされたパッケージを削除、解放バイト数を返す\n\nget_cache_size(): int\n    // 合計キャッシュサイズを計算\n\nread_config(): Config\n    // ~/.hpm/config.jsonを読み込み\n\nwrite_config(c: Config): void\n    // 設定ファイルを書き込み\n```\n\n**キャッシュ構造:**\n```\n~/.hpm/\n├── config.json\n└── cache/\n    └── owner/\n        └── repo/\n            ├── 1.0.0.tar.gz\n            └── 1.1.0.tar.gz\n```\n\n## データフロー\n\n### インストールコマンドフロー\n\n```\nhpm install owner/repo@^1.0.0\n         │\n         ▼\n    ┌─────────┐\n    │ main.hml │ 引数を解析、cmd_installを呼び出し\n    └────┬────┘\n         │\n         ▼\n    ┌──────────┐\n    │manifest.hml│ package.jsonを読み込み、依存関係を追加\n    └────┬─────┘\n         │\n         ▼\n    ┌──────────┐\n    │resolver.hml│ すべての依存関係を解決\n    └────┬─────┘\n         │\n         ├───────────────┐\n         ▼               ▼\n    ┌──────────┐    ┌─────────┐\n    │ github.hml│    │ semver.hml│ バージョンを取得、満たすものを見つける\n    └────┬─────┘    └─────────┘\n         │\n         ▼\n    ┌───────────┐\n    │installer.hml│ パッケージをダウンロードして展開\n    └────┬──────┘\n         │\n         ├───────────────┐\n         ▼               ▼\n    ┌──────────┐    ┌─────────┐\n    │ github.hml│    │ cache.hml│ ダウンロードまたはキャッシュを使用\n    └──────────┘    └─────────┘\n         │\n         ▼\n    ┌──────────┐\n    │lockfile.hml│ package-lock.jsonを更新\n    └──────────┘\n```\n\n### 解決アルゴリズムの詳細\n\n```\n入力: manifest.dependencies、manifest.devDependencies、既存のロックファイル\n\n1. 初期化:\n   - constraints = {} // Map<string, [Constraint]>\n   - resolved = {}    // Map<string, ResolvedPackage>\n   - queue = [直接依存関係]\n\n2. キューが空でない間:\n   a. pkg = queue.pop()\n   b. pkgが既に解決済みならスキップ\n   c. 依存元からpkgのすべての制約を取得\n   d. GitHubから利用可能なバージョンを取得（キャッシュ）\n   e. すべての制約を満たす最大バージョンを見つける\n   f. 見つからない場合: 競合\n   g. resolved[pkg] = {version, url, deps}\n   h. pkgの依存関係をキューに追加\n\n3. 解決されたグラフで循環を検出\n   - 循環が見つかった場合: エラー\n\n4. 解決されたマップを返す\n```\n\n## エラー処理\n\n### 終了コード\n\nmain.hmlで定義:\n\n```hemlock\nlet EXIT_SUCCESS = 0;\nlet EXIT_CONFLICT = 1;\nlet EXIT_NOT_FOUND = 2;\nlet EXIT_VERSION_NOT_FOUND = 3;\nlet EXIT_NETWORK = 4;\nlet EXIT_INVALID_MANIFEST = 5;\nlet EXIT_INTEGRITY = 6;\nlet EXIT_RATE_LIMIT = 7;\nlet EXIT_CIRCULAR = 8;\n```\n\n### エラー伝播\n\nエラーは戻り値を通じてバブルアップ:\n\n```hemlock\nfn resolve_version(pkg): Result<Version, ResolveError> {\n    let versions = github.get_tags(owner, repo)?;  // ?が伝播\n    // ...\n}\n```\n\n## テスト\n\n### テストフレームワーク\n\n`test/framework.hml`のカスタムテストフレームワーク:\n\n```hemlock\nfn suite(name: string, tests: fn()) {\n    print(\"Suite: \" + name);\n    tests();\n}\n\nfn test(name: string, body: fn()) {\n    try {\n        body();\n        print(\"  ✓ \" + name);\n    } catch e {\n        print(\"  ✗ \" + name + \": \" + e);\n        failed += 1;\n    }\n}\n\nfn assert_eq<T>(actual: T, expected: T) {\n    if actual != expected {\n        throw \"Expected \" + expected + \", got \" + actual;\n    }\n}\n```\n\n### テストファイル\n\n- `test/test_semver.hml` - バージョン解析、比較、制約\n- `test/test_manifest.hml` - マニフェストの読み書き、検証\n- `test/test_lockfile.hml` - ロックファイル操作\n- `test/test_cache.hml` - キャッシュ管理\n\n### テストの実行\n\n```bash\n# すべてのテスト\nmake test\n\n# 特定のテスト\nmake test-semver\nmake test-manifest\nmake test-lockfile\nmake test-cache\n```\n\n## 将来の改善\n\n### 計画された機能\n\n1. **整合性検証** - 完全なSHA256ハッシュチェック\n2. **ワークスペース** - モノレポサポート\n3. **プラグインシステム** - 拡張可能なコマンド\n4. **監査** - セキュリティ脆弱性チェック\n5. **プライベートレジストリ** - セルフホストパッケージホスティング\n\n### 既知の制限\n\n1. **バンドラーバグ** - スタンドアロン実行可能ファイルを作成できない\n2. **並列ダウンロード** - 実験的、競合状態の可能性あり\n3. **整合性** - SHA256が完全に実装されていない\n\n## 貢献\n\n### コードスタイル\n\n- 4スペースインデント\n- 関数は1つのことを行うべき\n- 複雑なロジックにコメント\n- 新機能にはテストを書く\n\n### コマンドの追加\n\n1. `main.hml`にハンドラを追加:\n   ```hemlock\n   fn cmd_newcmd(args: [string]) {\n       // 実装\n   }\n   ```\n\n2. コマンドディスパッチに追加:\n   ```hemlock\n   match command {\n       \"newcmd\" => cmd_newcmd(args),\n       // ...\n   }\n   ```\n\n3. ヘルプテキストを更新\n\n### モジュールの追加\n\n1. `src/newmodule.hml`を作成\n2. パブリックインターフェースをエクスポート\n3. 必要なモジュールでインポート\n4. `test/test_newmodule.hml`にテストを追加\n\n## 参照\n\n- [コマンド](#hpm-architecture-commands) - CLIリファレンス\n- [パッケージの作成](#hpm-architecture-creating-packages) - パッケージ開発\n- [バージョニング](#hpm-architecture-versioning) - セマンティックバージョニング\n"}, "hpm: リファレンス -> 終了コード": {"id": "hpm-exit-codes", "content": "# 終了コード\n\nhpmの終了コードとその意味のリファレンス。\n\n## 終了コード一覧\n\n| コード | 名前 | 説明 |\n|------|------|-------------|\n| 0 | SUCCESS | コマンドが正常に完了 |\n| 1 | CONFLICT | 依存関係のバージョン競合 |\n| 2 | NOT_FOUND | パッケージが見つからない |\n| 3 | VERSION_NOT_FOUND | 要求されたバージョンが見つからない |\n| 4 | NETWORK | ネットワークエラー |\n| 5 | INVALID_MANIFEST | 無効なpackage.json |\n| 6 | INTEGRITY | 整合性チェック失敗 |\n| 7 | RATE_LIMIT | GitHub APIレート制限超過 |\n| 8 | CIRCULAR | 循環依存を検出 |\n\n## 詳細な説明\n\n### 終了コード0: SUCCESS\n\nコマンドが正常に完了しました。\n\n```bash\n$ hpm install\nInstalled 5 packages\n$ echo $?\n0\n```\n\n### 終了コード1: CONFLICT\n\n2つ以上のパッケージが依存関係の互換性のないバージョンを要求しています。\n\n**例:**\n```\nError: Dependency conflict for hemlang/json\n\n  package-a requires hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)\n  package-b requires hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)\n\nNo version satisfies all constraints.\n```\n\n**解決策:**\n1. どのパッケージが競合しているか確認:\n   ```bash\n   hpm why hemlang/json\n   ```\n2. 競合しているパッケージを更新:\n   ```bash\n   hpm update package-a\n   ```\n3. package.jsonのバージョン制約を緩和\n4. 競合しているパッケージの1つを削除\n\n### 終了コード2: NOT_FOUND\n\n指定されたパッケージがGitHubに存在しません。\n\n**例:**\n```\nError: Package not found: hemlang/nonexistent\n\nThe repository hemlang/nonexistent does not exist on GitHub.\n```\n\n**解決策:**\n1. パッケージ名のスペルを確認\n2. リポジトリが存在するか確認: `https://github.com/owner/repo`\n3. アクセス権を確認（プライベートリポジトリの場合、GITHUB_TOKENを設定）\n\n### 終了コード3: VERSION_NOT_FOUND\n\n指定された制約に一致するバージョンがありません。\n\n**例:**\n```\nError: No version of hemlang/json matches constraint ^5.0.0\n\nAvailable versions: 1.0.0, 1.1.0, 1.2.0, 2.0.0\n```\n\n**解決策:**\n1. GitHubのリリース/タグで利用可能なバージョンを確認\n2. 有効なバージョン制約を使用\n3. バージョンタグは`v`で始まる必要あり（例: `v1.0.0`）\n\n### 終了コード4: NETWORK\n\nネットワーク関連のエラーが発生しました。\n\n**例:**\n```\nError: Network error: could not connect to api.github.com\n\nPlease check your internet connection and try again.\n```\n\n**解決策:**\n1. インターネット接続を確認\n2. GitHubにアクセスできるか確認\n3. ファイアウォールの背後にいる場合はプロキシ設定を確認\n4. パッケージがキャッシュされている場合は`--offline`を使用:\n   ```bash\n   hpm install --offline\n   ```\n5. 待ってからリトライ（hpmは自動的にリトライ）\n\n### 終了コード5: INVALID_MANIFEST\n\npackage.jsonファイルが無効または不正な形式です。\n\n**例:**\n```\nError: Invalid package.json\n\n  - Missing required field: name\n  - Invalid version format: \"1.0\"\n```\n\n**解決策:**\n1. JSON構文を確認（JSONバリデータを使用）\n2. 必須フィールドが存在することを確認（`name`、`version`）\n3. フィールド形式を確認:\n   - name: `owner/repo`形式\n   - version: `X.Y.Z` semver形式\n4. 再生成:\n   ```bash\n   rm package.json\n   hpm init\n   ```\n\n### 終了コード6: INTEGRITY\n\nパッケージの整合性検証が失敗しました。\n\n**例:**\n```\nError: Integrity check failed for hemlang/json@1.0.0\n\nExpected: sha256-abc123...\nActual:   sha256-def456...\n\nThe downloaded package may be corrupted.\n```\n\n**解決策:**\n1. キャッシュをクリアして再インストール:\n   ```bash\n   hpm cache clean\n   hpm install\n   ```\n2. ネットワーク問題を確認（部分的なダウンロード）\n3. パッケージが改ざんされていないか確認\n\n### 終了コード7: RATE_LIMIT\n\nGitHub APIのレート制限を超過しました。\n\n**例:**\n```\nError: GitHub API rate limit exceeded\n\nUnauthenticated rate limit: 60 requests/hour\nCurrent usage: 60/60\n\nRate limit resets at: 2024-01-15 10:30:00 UTC\n```\n\n**解決策:**\n1. **GitHubで認証**（推奨）:\n   ```bash\n   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx\n   hpm install\n   ```\n2. レート制限がリセットされるのを待つ（毎時リセット）\n3. パッケージがキャッシュされている場合はオフラインモードを使用:\n   ```bash\n   hpm install --offline\n   ```\n\n### 終了コード8: CIRCULAR\n\n依存関係グラフで循環依存が検出されました。\n\n**例:**\n```\nError: Circular dependency detected\n\n  package-a@1.0.0\n  └── package-b@1.0.0\n      └── package-a@1.0.0  (circular!)\n\nCannot resolve dependency tree.\n```\n\n**解決策:**\n1. これは通常パッケージ自体のバグ\n2. パッケージメンテナーに連絡\n3. 循環しているパッケージの1つの使用を避ける\n\n## スクリプトでの終了コードの使用\n\n### Bash\n\n```bash\n#!/bin/bash\n\nhpm install\nexit_code=$?\n\ncase $exit_code in\n  0)\n    echo \"Installation successful\"\n    ;;\n  1)\n    echo \"Dependency conflict - check version constraints\"\n    exit 1\n    ;;\n  2)\n    echo \"Package not found - check package name\"\n    exit 1\n    ;;\n  4)\n    echo \"Network error - check connection\"\n    exit 1\n    ;;\n  7)\n    echo \"Rate limited - set GITHUB_TOKEN\"\n    exit 1\n    ;;\n  *)\n    echo \"Unknown error: $exit_code\"\n    exit 1\n    ;;\nesac\n```\n\n### CI/CD\n\n```yaml\n# GitHub Actions\n- name: Install dependencies\n  run: |\n    hpm install\n    if [ $? -eq 7 ]; then\n      echo \"::error::GitHub rate limit exceeded. Add GITHUB_TOKEN.\"\n      exit 1\n    fi\n  env:\n    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n### Make\n\n```makefile\ninstall:\n\t@hpm install || (echo \"Installation failed with code $$?\"; exit 1)\n\ntest: install\n\t@hpm test\n```\n\n## 終了コードによるトラブルシューティング\n\n### クイックリファレンス\n\n| コード | 最初に確認すること |\n|------|---------------------|\n| 1 | `hpm why <package>`を実行して競合を確認 |\n| 2 | GitHubでパッケージ名を確認 |\n| 3 | GitHubタグで利用可能なバージョンを確認 |\n| 4 | インターネット接続を確認 |\n| 5 | package.jsonの構文を検証 |\n| 6 | `hpm cache clean && hpm install`を実行 |\n| 7 | `GITHUB_TOKEN`環境変数を設定 |\n| 8 | パッケージメンテナーに連絡 |\n\n## 参照\n\n- [トラブルシューティング](#hpm-exit-codes-troubleshooting) - 詳細な解決策\n- [コマンド](#hpm-exit-codes-commands) - コマンドリファレンス\n- [設定](#hpm-exit-codes-configuration) - GitHubトークンの設定\n"}};

        // Mobile menu toggle
        const menuToggle = document.getElementById('menuToggle');
        const sidebar = document.getElementById('sidebar');

        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
            const isOpen = sidebar.classList.contains('open');
            menuToggle.textContent = isOpen ? '\u00d7' : '\u2630';
            menuToggle.setAttribute('aria-expanded', isOpen);
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth < 1024) {
                if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                    menuToggle.setAttribute('aria-expanded', 'false');
                }
            }
        });

        // Theme toggle functionality
        const themeToggle = document.getElementById('themeToggle');
        const root = document.documentElement;

        // Get saved theme or detect system preference
        function getPreferredTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                return savedTheme;
            }
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        // Apply theme
        function setTheme(theme) {
            root.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        }

        // Initialize theme
        const initialTheme = getPreferredTheme();
        if (localStorage.getItem('theme')) {
            setTheme(initialTheme);
        }

        // Toggle theme on button click
        themeToggle.addEventListener('click', () => {
            const currentTheme = root.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            // Determine current effective theme
            let effectiveTheme;
            if (currentTheme) {
                effectiveTheme = currentTheme;
            } else {
                effectiveTheme = prefersDark ? 'dark' : 'light';
            }

            // Toggle to opposite theme
            const newTheme = effectiveTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        });

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!localStorage.getItem('theme')) {
                // Only auto-switch if user hasn't manually set a preference
                root.removeAttribute('data-theme');
            }
        });

        // Markdown parser
        function parseMarkdown(md) {
            let lines = md.split('\n');
            let html = '';
            let inCodeBlock = false;
            let codeBlockContent = '';
            let codeBlockLang = '';
            let inList = false;
            let listContent = '';
            let inBlockquote = false;
            let blockquoteContent = '';
            let inTable = false;
            let tableRows = [];
            let tableHasHeader = false;

            function processInlineMarkdown(text) {
                text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
                text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
                return text;
            }

            function makeId(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/^-+|-+$/g, '');
            }

            function flushList() {
                if (inList && listContent) {
                    html += '<ul>\n' + listContent + '</ul>\n';
                    listContent = '';
                    inList = false;
                }
            }

            function flushBlockquote() {
                if (inBlockquote && blockquoteContent) {
                    html += '<blockquote>' + processInlineMarkdown(blockquoteContent.trim()) + '</blockquote>\n';
                    blockquoteContent = '';
                    inBlockquote = false;
                }
            }

            function flushTable() {
                if (inTable && tableRows.length > 0) {
                    html += '<table>\n';
                    for (let r = 0; r < tableRows.length; r++) {
                        const row = tableRows[r];
                        const isHeader = tableHasHeader && r === 0;
                        const tag = isHeader ? 'th' : 'td';
                        html += '<tr>\n';
                        for (const cell of row) {
                            html += '<' + tag + '>' + processInlineMarkdown(cell.trim()) + '</' + tag + '>\n';
                        }
                        html += '</tr>\n';
                    }
                    html += '</table>\n';
                    tableRows = [];
                    inTable = false;
                    tableHasHeader = false;
                }
            }

            function isTableSeparator(line) {
                return /^\|?[\s-:|]+\|[\s-:|]+\|?$/.test(line) && line.includes('-');
            }

            function parseTableRow(line) {
                let cells = line.split('|');
                // Remove empty first/last cells from leading/trailing |
                if (cells.length > 0 && cells[0].trim() === '') cells.shift();
                if (cells.length > 0 && cells[cells.length - 1].trim() === '') cells.pop();
                return cells;
            }

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                const trimmedLine = line.trim();

                // Handle code blocks (including indented ones in lists)
                if (trimmedLine.startsWith('```')) {
                    if (inCodeBlock) {
                        const codeId = 'code-' + Math.random().toString(36).substr(2, 9);
                        const langDisplay = codeBlockLang || 'code';
                        const copyIcon = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>';
                        html += `<div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">${langDisplay}</span>
                                <button class="copy-btn" onclick="copyCode('${codeId}')" aria-label="Copy code">${copyIcon}<span>Copy</span></button>
                            </div>
                            <pre><code id="${codeId}">` + escapeHtml(codeBlockContent) + '</code></pre></div>\n';
                        codeBlockContent = '';
                        codeBlockLang = '';
                        inCodeBlock = false;
                    } else {
                        flushList();
                        flushBlockquote();
                        inCodeBlock = true;
                        codeBlockLang = trimmedLine.substring(3).trim();
                    }
                    continue;
                }

                if (inCodeBlock) {
                    codeBlockContent += line + '\n';
                    continue;
                }

                // Table handling
                if (trimmedLine.includes('|')) {
                    if (trimmedLine.startsWith('|') || trimmedLine.endsWith('|')) {
                        flushList();
                        flushBlockquote();
                        if (isTableSeparator(trimmedLine)) {
                            // This is the separator row (|---|---|), mark header
                            if (tableRows.length === 1) {
                                tableHasHeader = true;
                            }
                        } else {
                            // Regular table row
                            tableRows.push(parseTableRow(trimmedLine));
                            inTable = true;
                        }
                        continue;
                    }
                }
                // Flush table if we hit a non-table line
                if (inTable) {
                    flushTable();
                }

                if (line.startsWith('# ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    const id = makeId(text);
                    html += `<h1 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h1>\n`;
                    continue;
                }
                if (line.startsWith('## ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(3).trim();
                    const id = makeId(text);
                    html += `<h2 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h2>\n`;
                    continue;
                }
                if (line.startsWith('### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(4).trim();
                    const id = makeId(text);
                    html += `<h3 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h3>\n`;
                    continue;
                }
                if (line.startsWith('#### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(5).trim();
                    const id = makeId(text);
                    html += `<h4 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h4>\n`;
                    continue;
                }

                if (line.trim() === '---') {
                    flushList();
                    flushBlockquote();
                    html += '<hr>\n';
                    continue;
                }

                if (line.startsWith('> ')) {
                    flushList();
                    blockquoteContent += line.substring(2) + ' ';
                    inBlockquote = true;
                    continue;
                } else if (inBlockquote && line.trim() === '') {
                    flushBlockquote();
                    continue;
                }

                if (line.startsWith('- ') || line.startsWith('* ')) {
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    listContent += '<li>' + processInlineMarkdown(text) + '</li>\n';
                    inList = true;
                    continue;
                } else if (inList && line.trim() !== '' && !line.startsWith('#')) {
                    listContent = listContent.trimEnd();
                    if (listContent.endsWith('</li>')) {
                        listContent = listContent.substring(0, listContent.length - 5);
                        listContent += ' ' + processInlineMarkdown(line.trim()) + '</li>\n';
                    }
                    continue;
                } else if (inList && line.trim() === '') {
                    flushList();
                    continue;
                }

                if (line.trim() === '') {
                    flushList();
                    flushBlockquote();
                    continue;
                }

                flushList();
                flushBlockquote();
                if (line.trim() !== '') {
                    html += '<p>' + processInlineMarkdown(line) + '</p>\n';
                }
            }

            flushList();
            flushBlockquote();
            flushTable();

            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Copy code to clipboard
        function copyCode(codeId) {
            const codeElement = document.getElementById(codeId);
            if (!codeElement) return;

            const text = codeElement.textContent;
            navigator.clipboard.writeText(text).then(() => {
                // Find the button that triggered this
                const btn = codeElement.closest('.code-block').querySelector('.copy-btn');
                if (btn) {
                    const originalText = btn.querySelector('span').textContent;
                    btn.classList.add('copied');
                    btn.querySelector('span').textContent = 'Copied!';

                    setTimeout(() => {
                        btn.classList.remove('copied');
                        btn.querySelector('span').textContent = originalText;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Load a page
        function loadPage(pageId) {
            const pageData = Object.values(PAGES).find(p => p.id === pageId);
            if (!pageData) {
                console.error('Page not found:', pageId);
                return;
            }

            const content = parseMarkdown(pageData.content);
            document.getElementById('content').innerHTML = content;

            // Update active nav link
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.dataset.page === pageId) {
                    link.classList.add('active');
                }
            });

            // Scroll to top
            window.scrollTo(0, 0);

            // Update URL hash
            window.location.hash = pageId;
        }

        // Setup navigation
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const pageId = link.dataset.page;
                loadPage(pageId);

                // Close mobile menu
                if (window.innerWidth < 1024) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                }
            });
        });

        // Handle browser back/forward
        window.addEventListener('hashchange', () => {
            const hash = window.location.hash.substring(1);
            if (hash) {
                loadPage(hash);
            }
        });

        // Search functionality
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const searchContainer = document.getElementById('searchContainer');
        const searchToggle = document.getElementById('searchToggle');
        let selectedIndex = -1;
        let currentResults = [];

        // Build search index from PAGES
        function buildSearchIndex() {
            const index = [];
            for (const [title, page] of Object.entries(PAGES)) {
                // Extract section from page ID
                const parts = page.id.split('-');
                let section = '';
                if (parts.length > 1) {
                    section = parts.slice(0, -1).join(' ');
                }

                // Extract headings from content
                const headings = [];
                const headingRegex = /^#+\s+(.+)$/gm;
                let match;
                while ((match = headingRegex.exec(page.content)) !== null) {
                    headings.push(match[1]);
                }

                // Get preview text (first 200 chars, stripped of markdown)
                let preview = page.content
                    .replace(/^#+\s+.+$/gm, '')  // Remove headings
                    .replace(/```[\s\S]*?```/g, '')  // Remove code blocks
                    .replace(/`[^`]+`/g, '')  // Remove inline code
                    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')  // Convert links to text
                    .replace(/\*\*([^*]+)\*\*/g, '$1')  // Remove bold
                    .replace(/\*([^*]+)\*/g, '$1')  // Remove italic
                    .replace(/\n+/g, ' ')  // Normalize whitespace
                    .trim()
                    .substring(0, 200);

                index.push({
                    title: title,
                    pageId: page.id,
                    section: section,
                    headings: headings,
                    content: page.content.toLowerCase(),
                    preview: preview
                });
            }
            return index;
        }

        const searchIndex = buildSearchIndex();

        // Search function
        function search(query) {
            if (!query || query.length < 2) return [];

            const q = query.toLowerCase().trim();
            const results = [];

            for (const item of searchIndex) {
                let score = 0;
                let matchedHeading = null;
                let matchContext = '';

                // Check title (highest priority)
                const titleLower = item.title.toLowerCase();
                if (titleLower === q) {
                    score = 100;
                } else if (titleLower.startsWith(q)) {
                    score = 80;
                } else if (titleLower.includes(q)) {
                    score = 60;
                }

                // Check headings
                for (const heading of item.headings) {
                    const headingLower = heading.toLowerCase();
                    if (headingLower === q) {
                        score = Math.max(score, 50);
                        matchedHeading = heading;
                    } else if (headingLower.includes(q)) {
                        score = Math.max(score, 40);
                        if (!matchedHeading) matchedHeading = heading;
                    }
                }

                // Check content
                if (item.content.includes(q)) {
                    score = Math.max(score, 20);

                    // Find context around the match
                    const idx = item.content.indexOf(q);
                    const start = Math.max(0, idx - 40);
                    const end = Math.min(item.content.length, idx + q.length + 60);
                    matchContext = item.content.substring(start, end);
                    if (start > 0) matchContext = '...' + matchContext;
                    if (end < item.content.length) matchContext = matchContext + '...';
                }

                if (score > 0) {
                    results.push({
                        title: item.title,
                        pageId: item.pageId,
                        section: item.section,
                        score: score,
                        matchedHeading: matchedHeading,
                        preview: matchContext || item.preview,
                        query: q
                    });
                }
            }

            // Sort by score descending
            results.sort((a, b) => b.score - a.score);

            return results.slice(0, 10);  // Limit to 10 results
        }

        // Highlight query in text
        function highlightText(text, query) {
            if (!query) return text;
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }

        // Render search results
        function renderResults(results, query) {
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-no-results">No results found</div>';
                return;
            }

            const html = results.map((result, index) => {
                const titleHtml = highlightText(result.title, query);
                const previewHtml = highlightText(result.preview, query);
                const selectedClass = index === selectedIndex ? ' selected' : '';

                return `
                    <div class="search-result${selectedClass}" data-index="${index}" data-page="${result.pageId}">
                        ${result.section ? `<div class="search-result-section">${result.section}</div>` : ''}
                        <div class="search-result-title">${titleHtml}</div>
                        ${result.matchedHeading ? `<div class="search-result-preview">${highlightText(result.matchedHeading, query)}</div>` : ''}
                        <div class="search-result-preview">${previewHtml}</div>
                    </div>
                `;
            }).join('');

            searchResults.innerHTML = html;

            // Add click handlers
            searchResults.querySelectorAll('.search-result').forEach(el => {
                el.addEventListener('click', () => {
                    const pageId = el.dataset.page;
                    loadPage(pageId);
                    closeSearch();
                });
            });
        }

        // Show search results
        function showResults() {
            searchResults.classList.add('active');
        }

        // Hide search results
        function hideResults() {
            searchResults.classList.remove('active');
            selectedIndex = -1;
        }

        // Close search (mobile)
        function closeSearch() {
            hideResults();
            searchInput.value = '';
            searchInput.blur();
            if (window.innerWidth < 769) {
                searchContainer.classList.remove('active');
            }
        }

        // Debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Handle search input
        const handleSearch = debounce((query) => {
            currentResults = search(query);
            if (query.length >= 2) {
                renderResults(currentResults, query);
                showResults();
            } else {
                hideResults();
            }
        }, 150);

        searchInput.addEventListener('input', (e) => {
            handleSearch(e.target.value);
        });

        // Handle keyboard navigation
        searchInput.addEventListener('keydown', (e) => {
            if (!searchResults.classList.contains('active')) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, currentResults.length - 1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIndex >= 0 && currentResults[selectedIndex]) {
                    loadPage(currentResults[selectedIndex].pageId);
                    closeSearch();
                } else if (currentResults.length > 0) {
                    loadPage(currentResults[0].pageId);
                    closeSearch();
                }
            } else if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Close results when clicking outside
        document.addEventListener('click', (e) => {
            if (!searchContainer.contains(e.target)) {
                hideResults();
            }
        });

        // Focus search on input click
        searchInput.addEventListener('focus', () => {
            if (searchInput.value.length >= 2) {
                handleSearch(searchInput.value);
            }
        });

        // Global keyboard shortcut (Ctrl+K or Cmd+K)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                if (window.innerWidth < 769) {
                    searchContainer.classList.add('active');
                }
                searchInput.focus();
            }
            if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Mobile search toggle
        if (searchToggle) {
            searchToggle.addEventListener('click', () => {
                searchContainer.classList.toggle('active');
                if (searchContainer.classList.contains('active')) {
                    searchInput.focus();
                }
            });
        }

        // Language switcher
        function switchLanguage(filename) {
            const currentHash = window.location.hash;
            window.location.href = filename + currentHash;
        }

        // Load initial page
        const initialHash = window.location.hash.substring(1);
        const firstPageId = Object.values(PAGES)[0].id;
        loadPage(initialHash || firstPageId);
    </script>
</body>
</html>