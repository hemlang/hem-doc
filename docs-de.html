<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hemlock-Sprachhandbuch</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sage: #9CAF88;
            --pine: #2F4F4F;
            --dark-pine: #1a2f2f;
            --light-sage: #E8F4E1;
            --cream: #FAF9F6;
            --text: #2C3E2C;
            --text-light: #5A6F5A;
            --border: #D4E4CB;
            --code-bg: #F5F9F3;
            --accent: #6B8E6B;
        }

        [data-theme="dark"] {
            --sage: #6B8E6B;
            --pine: #9CAF88;
            --dark-pine: #0d1a1a;
            --light-sage: #1a2f2f;
            --cream: #0f1a1a;
            --text: #e0e8e0;
            --text-light: #a8b8a8;
            --border: #2a4a4a;
            --code-bg: #162626;
            --accent: #9CAF88;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) {
                --sage: #6B8E6B;
                --pine: #9CAF88;
                --dark-pine: #0d1a1a;
                --light-sage: #1a2f2f;
                --cream: #0f1a1a;
                --text: #e0e8e0;
                --text-light: #a8b8a8;
                --border: #2a4a4a;
                --code-bg: #162626;
                --accent: #9CAF88;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            line-height: 1.7;
            color: var(--text);
            background: var(--cream);
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: #2F4F4F;
            color: white;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .header-logo {
            height: 45px;
            margin-right: 1rem;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            margin-right: auto;
        }

        /* Layout */
        .container {
            display: flex;
            margin-top: 70px;
            min-height: calc(100vh - 70px);
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 70px;
            width: 280px;
            height: calc(100vh - 70px);
            background: var(--light-sage);
            border-right: 2px solid var(--border);
            overflow-y: auto;
            padding: 2rem 0;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 900;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        @media (min-width: 1024px) {
            .sidebar {
                transform: translateX(0);
            }
        }

        .nav-section {
            margin-bottom: 1.5rem;
        }

        .nav-section-title {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--pine);
            padding: 0 1.5rem;
            margin-bottom: 0.5rem;
        }

        .nav-link {
            display: block;
            padding: 0.5rem 1.5rem;
            color: var(--text);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .nav-link:hover {
            background: rgba(47, 79, 79, 0.05);
            border-left-color: var(--sage);
        }

        .nav-link.active {
            background: rgba(47, 79, 79, 0.1);
            border-left-color: var(--pine);
            font-weight: 600;
            color: var(--pine);
        }

        /* Mobile Menu Toggle */
        .menu-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 56px;
            height: 56px;
            background: var(--pine);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (min-width: 1024px) {
            .menu-toggle {
                display: none;
            }
        }

        /* Main Content */
        .main-content {
            flex: 1;
            margin-left: 0;
            padding: 3rem 2rem;
            max-width: 900px;
        }

        @media (min-width: 1024px) {
            .main-content {
                margin-left: 280px;
            }
        }

        /* Typography */
        .content h1 {
            font-size: 2.5rem;
            color: var(--pine);
            margin: 2rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--sage);
        }

        .content h2 {
            font-size: 2rem;
            color: var(--pine);
            margin: 3rem 0 1rem;
            padding-top: 1rem;
        }

        .content h3 {
            font-size: 1.5rem;
            color: var(--accent);
            margin: 2rem 0 1rem;
        }

        .content h4 {
            font-size: 1.2rem;
            color: var(--accent);
            margin: 1.5rem 0 0.8rem;
        }

        .content p {
            margin: 1rem 0;
            color: var(--text);
        }

        .content ul, .content ol {
            margin: 1rem 0 1rem 2rem;
        }

        .content li {
            margin: 0.5rem 0;
        }

        .content blockquote {
            border-left: 4px solid var(--sage);
            background: var(--light-sage);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: var(--text-light);
        }

        .content hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }

        /* Code Blocks */
        .content code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--pine);
        }

        .code-block {
            margin: 1.5rem 0;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: var(--code-bg);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--pine);
            color: var(--light-sage);
            font-size: 0.8rem;
        }

        .code-lang {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-weight: 600;
            text-transform: lowercase;
        }

        .copy-btn {
            background: transparent;
            border: 1px solid var(--sage);
            color: var(--light-sage);
            padding: 0.3rem 0.7rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .copy-btn:hover {
            background: var(--sage);
            color: var(--pine);
        }

        .copy-btn.copied {
            background: var(--sage);
            color: var(--pine);
            border-color: var(--sage);
        }

        .copy-btn svg {
            width: 14px;
            height: 14px;
        }

        .content pre {
            background: var(--code-bg);
            margin: 0;
            padding: 1.2rem;
            overflow-x: auto;
        }

        .content pre code {
            background: none;
            padding: 0;
            border-radius: 0;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        /* Standalone pre without code-block wrapper (legacy) */
        .content > pre {
            border: 1px solid var(--border);
            border-left: 4px solid var(--pine);
            border-radius: 4px;
            margin: 1.5rem 0;
        }

        /* Tables */
        .content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        .content th,
        .content td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .content th {
            background: var(--light-sage);
            color: var(--pine);
            font-weight: 600;
        }

        /* Links */
        .content a {
            color: var(--accent);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .content a:hover {
            border-bottom-color: var(--accent);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--cream);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--sage);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* Section anchors */
        .section-anchor {
            scroll-margin-top: 90px;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .main-content {
                padding: 2rem 1rem;
            }

            .content h1 {
                font-size: 2rem;
            }

            .content h2 {
                font-size: 1.6rem;
            }

            .content h3 {
                font-size: 1.3rem;
            }
        }

        /* Page switching */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* Search */
        .search-container {
            position: relative;
            margin-right: 1rem;
        }

        .search-input {
            width: 200px;
            padding: 0.5rem 1rem;
            padding-left: 2.2rem;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.25);
            width: 280px;
        }

        .search-icon {
            position: absolute;
            left: 0.8rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
        }

        .search-results {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            right: 0;
            min-width: 320px;
            max-height: 400px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1001;
        }

        .search-results.active {
            display: block;
        }

        .search-result {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s;
        }

        .search-result:last-child {
            border-bottom: none;
        }

        .search-result:hover,
        .search-result.selected {
            background: var(--light-sage);
        }

        .search-result-title {
            font-weight: 600;
            color: var(--pine);
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
        }

        .search-result-section {
            font-size: 0.75rem;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .search-result-preview {
            font-size: 0.85rem;
            color: var(--text-light);
            margin-top: 0.25rem;
            line-height: 1.4;
        }

        .search-result-preview mark {
            background: var(--sage);
            color: var(--pine);
            padding: 0 2px;
            border-radius: 2px;
        }

        .search-no-results {
            padding: 1rem;
            text-align: center;
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .search-shortcut {
            display: none;
            margin-left: 0.5rem;
            padding: 0.15rem 0.4rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.8);
        }

        @media (min-width: 768px) {
            .search-shortcut {
                display: inline-block;
            }
        }

        @media (max-width: 768px) {
            .search-container {
                position: fixed;
                top: 70px;
                left: 0;
                right: 0;
                margin: 0;
                padding: 0.5rem;
                background: #1a2f2f;
                display: none;
                z-index: 999;
            }

            .search-container.active {
                display: block;
            }

            .search-input {
                width: 100%;
            }

            .search-input:focus {
                width: 100%;
            }

            .search-results {
                position: fixed;
                top: 120px;
                left: 0.5rem;
                right: 0.5rem;
                min-width: auto;
                max-height: calc(100vh - 140px);
            }

            .search-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
                background: transparent;
                border: none;
                color: white;
                font-size: 1.2rem;
                cursor: pointer;
                padding: 0.5rem;
                margin-left: auto;
            }
        }

        @media (min-width: 769px) {
            .search-toggle {
                display: none;
            }
        }

        /* Theme Toggle */
        .theme-toggle {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            margin-left: 0.5rem;
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .theme-toggle svg {
            width: 20px;
            height: 20px;
        }

        .theme-toggle .sun-icon {
            display: none;
        }

        .theme-toggle .moon-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .sun-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .moon-icon {
            display: none;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) .theme-toggle .sun-icon {
                display: block;
            }
            :root:not([data-theme="light"]) .theme-toggle .moon-icon {
                display: none;
            }
        }

        /* Language Switcher */
        .lang-switcher {
            margin-left: 0.5rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 8px;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }

        .lang-switcher:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher:focus {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher option {
            background: var(--pine);
            color: white;
        }

        [data-theme="dark"] .lang-switcher option {
            background: var(--bg-primary);
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <img src="data:image/png;base64,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" alt="Hemlock Logo" class="header-logo">
        <h1>Hemlock-Sprachhandbuch</h1>
        <!-- Search -->
        <div class="search-container" id="searchContainer">
            <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
            <input type="text" class="search-input" id="searchInput" placeholder="Search docs..." autocomplete="off" aria-label="Search documentation">
            <span class="search-shortcut">Ctrl+K</span>
            <div class="search-results" id="searchResults" role="listbox" aria-label="Search results"></div>
        </div>
        <button class="search-toggle" id="searchToggle" aria-label="Toggle search">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
        </button>
        <select class="lang-switcher" id="langSwitcher" onchange="switchLanguage(this.value)" aria-label="Select language">
            <option value="docs.html" >English</option>
<option value="docs-zh.html" ></option>
<option value="docs-de.html" selected>Deutsch</option>
<option value="docs-es.html" >Espaol</option>
<option value="docs-fr.html" >Franais</option>
<option value="docs-ja.html" ></option>
<option value="docs-pt.html" >Portugus</option>
        </select>
        <button class="theme-toggle" id="themeToggle" title="Toggle dark mode" aria-label="Toggle dark mode">
            <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
            <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
        </button>
    </div>

    <!-- Mobile Menu Toggle -->
    <button class="menu-toggle" id="menuToggle" aria-label="Toggle navigation menu" aria-expanded="false">&#9776;</button>

    <!-- Container -->
    <div class="container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar" id="sidebar" aria-label="Documentation navigation">
            <div class="nav-section">
<a href="#welcome" class="nav-link" data-page="welcome">Willkommen</a>
</div>
<a href="#language-reference" class="nav-link" data-page="language-reference">Sprachreferenz</a>
<div class="nav-section">
<div class="nav-section-title">Erste Schritte</div>
<a href="#getting-started-installation" class="nav-link" data-page="getting-started-installation">Installation</a>
<a href="#getting-started-learning-paths" class="nav-link" data-page="getting-started-learning-paths">Lernpfade</a>
<a href="#getting-started-quick-start" class="nav-link" data-page="getting-started-quick-start">Schnellstart</a>
<a href="#getting-started-tutorial" class="nav-link" data-page="getting-started-tutorial">Tutorial</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Sprachhandbuch</div>
<a href="#language-guide-arrays" class="nav-link" data-page="language-guide-arrays">Arrays</a>
<a href="#language-guide-error-handling" class="nav-link" data-page="language-guide-error-handling">Fehlerbehandlung</a>
<a href="#language-guide-functions" class="nav-link" data-page="language-guide-functions">Funktionen</a>
<a href="#language-guide-control-flow" class="nav-link" data-page="language-guide-control-flow">Kontrollfluss</a>
<a href="#language-guide-modules" class="nav-link" data-page="language-guide-modules">Module</a>
<a href="#language-guide-pattern-matching" class="nav-link" data-page="language-guide-pattern-matching">Musterabgleich</a>
<a href="#language-guide-objects" class="nav-link" data-page="language-guide-objects">Objekte</a>
<a href="#language-guide-runes" class="nav-link" data-page="language-guide-runes">Runen</a>
<a href="#language-guide-memory" class="nav-link" data-page="language-guide-memory">Speicherverwaltung</a>
<a href="#language-guide-syntax" class="nav-link" data-page="language-guide-syntax">Syntax</a>
<a href="#language-guide-types" class="nav-link" data-page="language-guide-types">Typen</a>
<a href="#language-guide-strings" class="nav-link" data-page="language-guide-strings">Zeichenketten</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Fortgeschrittene Themen</div>
<a href="#advanced-async-concurrency" class="nav-link" data-page="advanced-async-concurrency">Asynchronitt & Nebenlufigkeit</a>
<a href="#advanced-atomics" class="nav-link" data-page="advanced-atomics">Atomare Operationen</a>
<a href="#advanced-command-execution" class="nav-link" data-page="advanced-command-execution">Befehlsausfhrung</a>
<a href="#advanced-bundling-packaging" class="nav-link" data-page="advanced-bundling-packaging">Bndeln & Paketieren</a>
<a href="#advanced-ffi" class="nav-link" data-page="advanced-ffi">FFI</a>
<a href="#advanced-file-io" class="nav-link" data-page="advanced-file-io">File IO</a>
<a href="#advanced-command-line-args" class="nav-link" data-page="advanced-command-line-args">Kommandozeilenargumente</a>
<a href="#advanced-profiling" class="nav-link" data-page="advanced-profiling">Profilerstellung</a>
<a href="#advanced-signals" class="nav-link" data-page="advanced-signals">Signalverarbeitung</a>
</div>
<div class="nav-section">
<div class="nav-section-title">API Referenz</div>
<a href="#reference-array-api" class="nav-link" data-page="reference-array-api">Array-API</a>
<a href="#reference-file-api" class="nav-link" data-page="reference-file-api">Datei-API</a>
<a href="#reference-builtins" class="nav-link" data-page="reference-builtins">Eingebaute Funktionen</a>
<a href="#reference-concurrency-api" class="nav-link" data-page="reference-concurrency-api">Nebenlufigkeits-API</a>
<a href="#reference-operators" class="nav-link" data-page="reference-operators">Operatoren</a>
<a href="#reference-memory-api" class="nav-link" data-page="reference-memory-api">Speicher-API</a>
<a href="#reference-string-api" class="nav-link" data-page="reference-string-api">String-API</a>
<a href="#reference-type-system" class="nav-link" data-page="reference-type-system">Typsystem</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Design & Philosophie</div>
<a href="#design-philosophy" class="nav-link" data-page="design-philosophy">Designphilosophie</a>
<a href="#design-implementation" class="nav-link" data-page="design-implementation">Implementierung</a>
<a href="#design-signature-syntax" class="nav-link" data-page="design-signature-syntax">Signatur-Syntax</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Mitwirken</div>
<a href="#contributing-guidelines" class="nav-link" data-page="contributing-guidelines">Richtlinien</a>
<a href="#contributing-testing" class="nav-link" data-page="contributing-testing">Testen</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Erste Schritte</div>
<a href="#hpm-installation" class="nav-link" data-page="hpm-installation">Installation</a>
<a href="#hpm-project-setup" class="nav-link" data-page="hpm-project-setup">Projekteinrichtung</a>
<a href="#hpm-quick-start" class="nav-link" data-page="hpm-quick-start">Schnellstart</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Benutzerhandbuch</div>
<a href="#hpm-commands" class="nav-link" data-page="hpm-commands">Befehle</a>
<a href="#hpm-troubleshooting" class="nav-link" data-page="hpm-troubleshooting">Fehlerbehebung</a>
<a href="#hpm-configuration" class="nav-link" data-page="hpm-configuration">Konfiguration</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Paketentwicklung</div>
<a href="#hpm-creating-packages" class="nav-link" data-page="hpm-creating-packages">Pakete erstellen</a>
<a href="#hpm-package-spec" class="nav-link" data-page="hpm-package-spec">Paketspezifikation</a>
<a href="#hpm-versioning" class="nav-link" data-page="hpm-versioning">Versionierung</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Referenz</div>
<a href="#hpm-architecture" class="nav-link" data-page="hpm-architecture">Architektur</a>
<a href="#hpm-exit-codes" class="nav-link" data-page="hpm-exit-codes">Exit-Codes</a>
</div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <div class="content" id="content"></div>
        </main>
    </div>

    <script>
        // Embedded documentation pages
        const PAGES = {"Willkommen": {"id": "welcome", "content": "# Willkommen bei Hemlock\n\n> \"Eine kleine, unsichere Sprache zum sicheren Schreiben unsicherer Dinge.\"\n\n**Hemlock** ist eine System-Skriptsprache, die die Leistungsfhigkeit von C mit modernen Skript-Annehmlichkeiten verbindet. Sie bietet manuelle Speicherverwaltung, explizite Kontrolle und eingebaute strukturierte asynchrone Nebenlufigkeit.\n\n## Was ist Hemlock?\n\nHemlock ist fr Programmierer konzipiert, die Folgendes wnschen:\n\n- **Explizite Kontrolle** ber Speicher und Ausfhrung\n- **C-hnliche Syntax** mit modernen Annehmlichkeiten\n- **Kein verstecktes Verhalten** oder Magie\n- **Echte parallele Asynchronitt** mit pthread-basierter Nebenlufigkeit\n\nHemlock ist keine speichersichere Sprache mit Garbage Collection. Stattdessen gibt es Ihnen die Werkzeuge zur Sicherheit (`buffer`, Typ-Annotationen, Grenzprfungen), zwingt Sie aber nicht, diese zu verwenden (`ptr`, manuelle Speicherverwaltung, unsichere Operationen).\n\n## Schnelles Beispiel\n\n```hemlock\n// Hallo, Hemlock!\nfn greet(name: string): string {\n    return `Hallo, ${name}!`;\n}\n\nlet message = greet(\"Welt\");\nprint(message);\n\n// Manuelle Speicherverwaltung\nlet buf = buffer(64);\nbuf[0] = 72;  // 'H'\nbuf[1] = 105; // 'i'\nprint(buf);\nfree(buf);\n```\n\n## Funktionen auf einen Blick\n\n| Funktion | Beschreibung |\n|----------|--------------|\n| **Typsystem** | i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object |\n| **Speicher** | Manuelle Verwaltung mit `alloc()`, `buffer()`, `free()` |\n| **Async** | Eingebautes `async`/`await` mit echter pthread-Parallelitt |\n| **FFI** | C-Funktionen direkt aus gemeinsam genutzten Bibliotheken aufrufen |\n| **Standardbibliothek** | 40 Module einschlielich crypto, http, sqlite, json und mehr |\n\n## Erste Schritte\n\nBereit loszulegen? So beginnen Sie:\n\n1. **[Installation](#getting-started-installation)** - Hemlock herunterladen und einrichten\n2. **[Schnellstart](#getting-started-quick-start)** - Schreiben Sie Ihr erstes Programm in Minuten\n3. **[Tutorial](#getting-started-tutorial)** - Lernen Sie Hemlock Schritt fr Schritt\n\n## Dokumentationsabschnitte\n\n- **Erste Schritte** - Installation, Schnellstartanleitung und Tutorials\n- **Sprachhandbuch** - Tiefgehende Einblicke in Syntax, Typen, Funktionen und mehr\n- **Fortgeschrittene Themen** - Asynchrone Programmierung, FFI, Signale und Atomics\n- **API-Referenz** - Vollstndige Referenz fr eingebaute Funktionen und Standardbibliothek\n- **Design & Philosophie** - Verstehen Sie, warum Hemlock so ist, wie es ist\n\n## Paketmanager\n\nHemlock wird mit **hpm** geliefert, einem Paketmanager zur Verwaltung von Abhngigkeiten:\n\n```bash\nhpm init my-project\nhpm add some-package\nhpm run\n```\n\nWeitere Details finden Sie in den hpm-Dokumentationsabschnitten.\n\n---\n\nVerwenden Sie die Navigation auf der linken Seite, um die Dokumentation zu erkunden, oder nutzen Sie die Suchleiste, um bestimmte Themen zu finden.\n"}, "Sprachreferenz": {"id": "language-reference", "content": "# Hemlock Sprachdesign-Philosophie\n\n> \"Eine kleine, unsichere Sprache, um unsichere Dinge sicher zu schreiben.\"\n\nDieses Dokument bietet einen berblick ber Hemlocks Designphilosophie und eine Kurzreferenz fr die Sprache.\nErkunden Sie die anderen Dokumentationsabschnitte fr detaillierte Anleitungen und API-Referenzen.\n\n---\n\n## Kernidentitt\n\nHemlock ist eine **System-Skriptsprache** mit manueller Speicherverwaltung und expliziter Kontrolle:\n- Die Macht von C mit modernen Skripting-Ergonomien\n- Strukturierte async Nebenlufigkeit integriert\n- Kein verstecktes Verhalten oder Magie\n\n**Hemlock ist NICHT:** Speichersicher, eine GC-Sprache oder versteckt Komplexitt.\n**Hemlock IST:** Explizit statt implizit, lehrreich, eine \"C-Skriptschicht\" fr Systemarbeit.\n\n---\n\n## Designprinzipien\n\n### 1. Explizit statt Implizit\n- Semikolons obligatorisch (kein ASI)\n- Manuelle Speicherverwaltung (alloc/free)\n- Typannotationen optional, aber zur Laufzeit geprft\n\n### 2. Dynamisch standardmig, typisiert nach Wahl\n- Jeder Wert hat ein Laufzeit-Typ-Tag\n- Literale inferieren Typen: `42`  i32, `5000000000`  i64, `3.14`  f64\n- Optionale Typannotationen erzwingen Laufzeitprfungen\n\n### 3. Unsicher ist ein Feature\n- Zeigerarithmetik erlaubt (Verantwortung des Benutzers)\n- Keine Grenzprfung bei rohem `ptr` (verwende `buffer` fr Sicherheit)\n- Double-Free-Abstrze erlaubt\n\n### 4. Strukturierte Nebenlufigkeit erstklassig\n- `async`/`await` eingebaut mit pthread-basierter Parallelitt\n- Kanle fr Kommunikation\n- `spawn`/`join`/`detach` fr Aufgabenverwaltung\n\n### 5. C-hnliche Syntax\n- `{}` Blcke immer erforderlich\n- Kommentare: `// Zeile` und `/* Block */`\n- Operatoren entsprechen C: `+`, `-`, `*`, `%`, `&&`, `||`, `!`, `&`, `|`, `^`, `<<`, `>>`\n- Inkrement/Dekrement: `++x`, `x++`, `--x`, `x--` (Prfix und Postfix)\n- Zusammengesetzte Zuweisung: `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`\n- `/` gibt immer Float zurck (verwende `divi()` fr Integer-Division)\n- Typsyntax: `let x: type = value;`\n\n---\n\n## Kurzreferenz\n\n### Typen\n```\nVorzeichenbehaftet: i8, i16, i32, i64\nVorzeichenlos:      u8, u16, u32, u64\nFliekomma:        f32, f64\nAndere:             bool, string, rune, array, ptr, buffer, null, object, file, task, channel\nAliase:             integer (i32), number (f64), byte (u8)\n```\n\n**Typ-Promotion:** i8  i16  i32  i64  f32  f64 (Fliekomma gewinnt immer, aber i64/u64 + f32  f64 um Przision zu erhalten)\n\n### Literale\n```hemlock\nlet x = 42;              // i32\nlet big = 5000000000;    // i64 (> i32 max)\nlet hex = 0xDEADBEEF;    // Hex-Literal\nlet bin = 0b1010;        // Binr-Literal\nlet oct = 0o777;         // Oktal-Literal\nlet sep = 1_000_000;     // Numerische Trennzeichen erlaubt\nlet pi = 3.14;           // f64\nlet half = .5;           // f64 (keine fhrende Null)\nlet s = \"hello\";         // string\nlet esc = \"\\x41\\u{1F600}\"; // Hex- und Unicode-Escapes\nlet ch = 'A';            // rune\nlet emoji = '';        // rune (Unicode)\nlet arr = [1, 2, 3];     // array\nlet obj = { x: 10 };     // object\n```\n\n### Typkonvertierung\n```hemlock\n// Typkonstruktorfunktionen - String zu Typ parsen\nlet n = i32(\"42\");       // String zu i32 parsen\nlet f = f64(\"3.14\");     // String zu f64 parsen\nlet b = bool(\"true\");    // String zu bool parsen (\"true\" oder \"false\")\n\n// Alle numerischen Typen untersttzt\nlet a = i8(\"-128\");      // i8, i16, i32, i64\nlet c = u8(\"255\");       // u8, u16, u32, u64\nlet d = f32(\"1.5\");      // f32, f64\n\n// Hex und negative Zahlen\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\n\n// Typaliase funktionieren auch\nlet x = integer(\"100\");  // Gleich wie i32(\"100\")\nlet y = number(\"1.5\");   // Gleich wie f64(\"1.5\")\nlet z = byte(\"200\");     // Gleich wie u8(\"200\")\n\n// Zwischen numerischen Typen konvertieren\nlet big = i64(42);       // i32 zu i64\nlet truncated = i32(3.99); // f64 zu i32 (schneidet auf 3 ab)\n\n// Typannotationen validieren Typen (aber parsen keine Strings)\nlet f: f64 = 100;        // i32 zu f64 via Annotation (numerische Umwandlung OK)\n// let n: i32 = \"42\";    // FEHLER - verwende i32(\"42\") fr String-Parsing\n```\n\n### Introspektion\n```hemlock\ntypeof(42);              // \"i32\"\ntypeof(\"hello\");         // \"string\"\ntypeof([1, 2, 3]);       // \"array\"\ntypeof(null);            // \"null\"\nlen(\"hello\");            // 5 (Stringlnge in Bytes)\nlen([1, 2, 3]);          // 3 (Arraylnge)\n```\n\n### Speicher\n```hemlock\nlet p = alloc(64);       // roher Zeiger\nlet b = buffer(64);      // sicherer Buffer (grenzgeprft)\nmemset(p, 0, 64);\nmemcpy(dest, src, 64);\nfree(p);                 // manuelle Bereinigung erforderlich\n```\n\n### Kontrollfluss\n```hemlock\nif (x > 0) { } else if (x < 0) { } else { }\nwhile (cond) { break; continue; }\nfor (let i = 0; i < 10; i++) { }\nfor (item in array) { }\nloop { if (done) { break; } }   // Endlosschleife (sauberer als while(true))\nswitch (x) { case 1: break; default: break; }  // C-artiges Fall-Through\ndefer cleanup();         // luft wenn Funktion zurckkehrt\n\n// Schleifenlabels fr gezieltes break/continue in verschachtelten Schleifen\nouter: while (cond) {\n    inner: for (let i = 0; i < 10; i++) {\n        if (i == 5) { break outer; }     // uere Schleife beenden\n        if (i == 3) { continue outer; }  // uere Schleife fortsetzen\n    }\n}\n```\n\n### Musterabgleich\n```hemlock\n// Match-Ausdruck - gibt Wert zurck\nlet result = match (value) {\n    0 => \"null\",                        // Literal-Muster\n    1 | 2 | 3 => \"klein\",               // ODER-Muster\n    n if n < 10 => \"mittel\",            // Guard-Ausdruck\n    n => \"gro: \" + n                  // Variablenbindung\n};\n\n// Typmuster\nmatch (val) {\n    n: i32 => \"ganzzahl\",\n    s: string => \"zeichenkette\",\n    _ => \"anderes\"                      // Platzhalter\n}\n\n// Objekt-Destrukturierung\nmatch (point) {\n    { x: 0, y: 0 } => \"ursprung\",\n    { x, y } => \"bei \" + x + \",\" + y\n}\n\n// Array-Destrukturierung mit Rest\nmatch (arr) {\n    [] => \"leer\",\n    [first, ...rest] => \"kopf: \" + first,\n    _ => \"anderes\"\n}\n\n// Verschachtelte Muster\nmatch (user) {\n    { name, address: { city } } => name + \" in \" + city\n}\n```\n\nSiehe `docs/language-guide/pattern-matching.md` fr vollstndige Dokumentation.\n\n### Null-Koaleszenz-Operatoren\n```hemlock\n// Null-Koaleszenz (??) - gibt links zurck wenn nicht-null, sonst rechts\nlet name = user.name ?? \"Anonym\";\nlet first = a ?? b ?? c ?? \"fallback\";\n\n// Null-Koaleszenz-Zuweisung (??=) - weist nur zu wenn null\nlet config = null;\nconfig ??= { timeout: 30 };    // config ist jetzt { timeout: 30 }\nconfig ??= { timeout: 60 };    // config unverndert (nicht null)\n\n// Funktioniert mit Eigenschaften und Indizes\nobj.field ??= \"standard\";\narr[0] ??= \"erstes\";\n\n// Sichere Navigation (?.) - gibt null zurck wenn Objekt null ist\nlet city = user?.address?.city;  // null wenn irgendein Teil null ist\nlet upper = name?.to_upper();    // sicherer Methodenaufruf\nlet item = arr?.[0];             // sichere Indizierung\n```\n\n### Funktionen\n```hemlock\nfn add(a: i32, b: i32): i32 { return a + b; }\nfn greet(name: string, msg?: \"Hallo\") { print(msg + \" \" + name); }\nlet f = fn(x) { return x * 2; };  // anonym/Closure\n\n// Ausdruckskrper-Funktionen (Pfeilsyntax)\nfn double(x: i32): i32 => x * 2;\nfn max(a: i32, b: i32): i32 => a > b ? a : b;\nlet square = fn(x: i32): i32 => x * x;  // anonyme Ausdruckskrper\n\n// Parametermodifikatoren\nfn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // bergabe per Referenz\nfn print_all(const items: array) { for (i in items) { print(i); } }  // unvernderlich\n```\n\n### Benannte Argumente\n```hemlock\n// Funktionen knnen mit benannten Argumenten aufgerufen werden\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" ist \" + age + \" Jahre alt\");\n}\n\n// Positionelle Argumente (traditionell)\ncreate_user(\"Alice\", 25, false);\n\n// Benannte Argumente - knnen in beliebiger Reihenfolge sein\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n\n// Optionale Parameter durch Benennung berspringen\ncreate_user(\"David\", active: false);  // Verwendet Standard age=18\n\n// Benannte Argumente mssen nach positionellen kommen\ncreate_user(\"Eve\", age: 21);          // OK: positionell dann benannt\n// create_user(name: \"Bad\", 25);      // FEHLER: positionell nach benannt\n```\n\n**Regeln:**\n- Benannte Argumente verwenden `name: value` Syntax\n- Knnen in beliebiger Reihenfolge nach positionellen Argumenten erscheinen\n- Positionelle Argumente knnen nicht nach benannten Argumenten folgen\n- Funktioniert mit Standard-/optionalen Parametern\n- Unbekannte Parameternamen verursachen Laufzeitfehler\n\n### Objekte & Enums\n```hemlock\ndefine Person { name: string, age: i32, active?: true }\nlet p: Person = { name: \"Alice\", age: 30 };\nlet json = p.serialize();\nlet restored = json.deserialize();\n\n// Objekt-Kurzschreibweise (ES6-Stil)\nlet name = \"Alice\";\nlet age = 30;\nlet person = { name, age };         // quivalent zu { name: name, age: age }\n\n// Objekt-Spread-Operator\nlet defaults = { theme: \"dark\", size: \"medium\" };\nlet config = { ...defaults, size: \"large\" };  // kopiert defaults, berschreibt size\n\nenum Color { RED, GREEN, BLUE }\nenum Status { OK = 0, ERROR = 1 }\n```\n\n### Zusammengesetzte Typen (Schnittmengen-/Duck-Typen)\n```hemlock\n// Strukturelle Typen definieren\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// Zusammengesetzter Typ: Objekt muss ALLE Typen erfllen\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// Funktionsparameter mit zusammengesetzten Typen\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" ist \" + p.age);\n}\n\n// Drei oder mehr Typen\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n\n// Zustzliche Felder erlaubt (Duck-Typing)\nlet employee: HasName & HasAge = {\n    name: \"Bob\",\n    age: 25,\n    department: \"Engineering\"  // OK - zustzliche Felder ignoriert\n};\n```\n\nZusammengesetzte Typen bieten Interface-hnliches Verhalten ohne separates `interface`-Schlsselwort,\naufbauend auf den bestehenden `define`- und Duck-Typing-Paradigmen.\n\n### Typaliase\n```hemlock\n// Einfacher Typalias\ntype Integer = i32;\ntype Text = string;\n\n// Funktionstyp-Alias\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// Zusammengesetzter Typalias (grossartig fr wiederverwendbare Interfaces)\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// Generischer Typalias\ntype Pair<T> = { first: T, second: T };\n\n// Typaliase verwenden\nlet x: Integer = 42;\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\nTypaliase erstellen benannte Abkrzungen fr komplexe Typen und verbessern Lesbarkeit und Wartbarkeit.\n\n### Funktionstypen\n```hemlock\n// Funktionstyp-Annotationen fr Parameter\nfn apply_fn(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Hhere Funktion die eine Funktion zurckgibt\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Async-Funktionstypen\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n\n// Funktionstypen mit mehreren Parametern\ntype BinaryOp = fn(i32, i32): i32;\nlet add: BinaryOp = fn(a, b) { return a + b; };\n```\n\n### Const-Parameter\n```hemlock\n// Const-Parameter - tiefe Unvernderlichkeit\nfn print_all(const items: array) {\n    // items.push(4);  // FEHLER: kann const-Parameter nicht mutieren\n    for (item in items) {\n        print(item);\n    }\n}\n\n// Const mit Objekten - keine Mutation ber irgendeinen Pfad\nfn describe(const person: object) {\n    print(person.name);       // OK: Lesen ist erlaubt\n    // person.name = \"Bob\";   // FEHLER: kann nicht mutieren\n}\n\n// Verschachtelter Zugriff ist zum Lesen erlaubt\nfn get_city(const user: object) {\n    return user.address.city;  // OK: verschachtelte Eigenschaften lesen\n}\n```\n\nDer `const`-Modifikator verhindert jede Mutation des Parameters, einschlielich verschachtelter Eigenschaften.\nDies bietet Kompilierzeit-Sicherheit fr Funktionen, die ihre Eingaben nicht modifizieren sollten.\n\n### Ref-Parameter (bergabe per Referenz)\n```hemlock\n// Ref-Parameter - Variable des Aufrufers wird direkt modifiziert\nfn increment(ref x: i32) {\n    x = x + 1;  // Modifiziert die ursprngliche Variable\n}\n\nlet count = 10;\nincrement(count);\nprint(count);  // 11 - Original wurde modifiziert\n\n// Klassische Swap-Funktion\nfn swap(ref a: i32, ref b: i32) {\n    let temp = a;\n    a = b;\n    b = temp;\n}\n\nlet x = 1;\nlet y = 2;\nswap(x, y);\nprint(x, y);  // 2 1\n\n// Ref und regulre Parameter mischen\nfn add_to(ref target: i32, amount: i32) {\n    target = target + amount;\n}\n\nlet total = 100;\nadd_to(total, 50);\nprint(total);  // 150\n```\n\nDer `ref`-Modifikator bergibt eine Referenz zur Variable des Aufrufers, sodass die Funktion\nsie direkt modifizieren kann. Ohne `ref` werden Primitives per Wert bergeben (kopiert). Verwende `ref` wenn\ndu den Zustand des Aufrufers mutieren musst, ohne einen Wert zurckzugeben.\n\n**Regeln:**\n- `ref`-Parameter mssen Variablen bergeben werden, keine Literale oder Ausdrcke\n- Funktioniert mit allen Typen (Primitives, Arrays, Objekte)\n- Kombiniere mit Typannotationen: `ref x: i32`\n- Kann nicht mit `const` kombiniert werden (sie sind Gegenstze)\n\n### Methodensignaturen in Define\n```hemlock\n// Define mit Methodensignaturen (Interface-Muster)\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32   // Erforderliche Methodensignatur\n}\n\n// Objekte mssen die erforderliche Methode bereitstellen\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// Optionale Methoden mit ?\ndefine Serializable {\n    fn serialize(): string,        // Erforderlich\n    fn pretty?(): string           // Optionale Methode\n}\n\n// Self-Typ bezieht sich auf den definierenden Typ\ndefine Cloneable {\n    fn clone(): Self   // Gibt gleichen Typ wie das Objekt zurck\n}\n```\n\nMethodensignaturen in `define`-Blcken verwenden Komma-Trennzeichen (wie TypeScript-Interfaces),\netablieren Vertrge, die Objekte erfllen mssen, und ermglichen Interface-artige Programmier-\nmuster mit Hemlocks Duck-Typing-System.\n\n### Fehlerbehandlung\n```hemlock\ntry { throw \"fehler\"; } catch (e) { print(e); } finally { cleanup(); }\npanic(\"nicht behebbar\");  // beendet sofort, nicht abfangbar\n```\n\n### Async/Nebenlufigkeit\n```hemlock\nasync fn compute(n: i32): i32 { return n * n; }\nlet task = spawn(compute, 42);\nlet result = await task;     // oder join(task)\ndetach(spawn(background_work));\n\nlet ch = channel(10);\nch.send(value);\nlet val = ch.recv();\nch.close();\n```\n\n**Speicherbesitz:** Tasks erhalten Kopien von Primitivwerten, teilen aber Zeiger. Wenn du einen `ptr` an einen gespawnten Task bergibst, musst du sicherstellen, dass der Speicher gltig bleibt, bis der Task abgeschlossen ist. Verwende `join()` vor `free()`, oder verwende Kanle, um Abschluss zu signalisieren.\n\n### Benutzereingabe\n```hemlock\nlet name = read_line();          // Zeile von stdin lesen (blockiert)\nprint(\"Hallo, \" + name);\neprint(\"Fehlermeldung\");         // Auf stderr ausgeben\n\n// read_line() gibt null bei EOF zurck\nwhile (true) {\n    let line = read_line();\n    if (line == null) { break; }\n    print(\"Erhalten:\", line);\n}\n```\n\n### Datei-I/O\n```hemlock\nlet f = open(\"datei.txt\", \"r\");  // Modi: r, w, a, r+, w+, a+\nlet content = f.read();\nf.write(\"daten\");\nf.seek(0);\nf.close();\n```\n\n### Signale\n```hemlock\nsignal(SIGINT, fn(sig) { print(\"Unterbrochen\"); });\nraise(SIGUSR1);\n```\n\n---\n\n## String-Methoden (19)\n\n`substr`, `slice`, `find`, `contains`, `split`, `trim`, `to_upper`, `to_lower`,\n`starts_with`, `ends_with`, `replace`, `replace_all`, `repeat`, `char_at`,\n`byte_at`, `chars`, `bytes`, `to_bytes`, `deserialize`\n\nTemplate-Strings: `` `Hallo ${name}!` ``\n\n**String-Mutabilitt:** Strings sind per Indexzuweisung mutierbar (`s[0] = 'H'`), aber alle String-Methoden geben neue Strings zurck, ohne das Original zu modifizieren. Dies erlaubt In-Place-Mutation wenn ntig, whrend Methodenverkettung funktional bleibt.\n\n**String-Lngeneigenschaften:**\n```hemlock\nlet s = \"hallo \";\nprint(s.length);       // 7 (Zeichen-/Rune-Anzahl)\nprint(s.byte_length);  // 10 (Byte-Anzahl - Emoji ist 4 Bytes UTF-8)\n```\n\n## Array-Methoden (18)\n\n`push`, `pop`, `shift`, `unshift`, `insert`, `remove`, `find`, `contains`,\n`slice`, `join`, `concat`, `reverse`, `first`, `last`, `clear`, `map`, `filter`, `reduce`\n\nTypisierte Arrays: `let nums: array<i32> = [1, 2, 3];`\n\n---\n\n## Standardbibliothek (40 Module)\n\nImportieren mit `@stdlib/`-Prfix:\n```hemlock\nimport { sin, cos, PI } from \"@stdlib/math\";\nimport { HashMap, Queue, Set } from \"@stdlib/collections\";\nimport { read_file, write_file } from \"@stdlib/fs\";\nimport { TcpStream, UdpSocket } from \"@stdlib/net\";\n```\n\n| Modul | Beschreibung |\n|-------|--------------|\n| `arena` | Arena-Speicherallokator (Bump-Allocation) |\n| `args` | Kommandozeilenargument-Parsing |\n| `assert` | Assertions-Utilities |\n| `async` | ThreadPool, parallel_map |\n| `async_fs` | Asynchrone Datei-I/O-Operationen |\n| `collections` | HashMap, Queue, Stack, Set, LinkedList, LRUCache |\n| `compression` | gzip, gunzip, deflate |\n| `crypto` | aes_encrypt, rsa_sign, random_bytes |\n| `csv` | CSV-Parsing und -Generierung |\n| `datetime` | DateTime-Klasse, Formatierung, Parsing |\n| `encoding` | base64_encode, hex_encode, url_encode |\n| `env` | getenv, setenv, exit, get_pid |\n| `fmt` | String-Formatierungs-Utilities |\n| `fs` | read_file, write_file, list_dir, exists |\n| `glob` | Datei-Musterabgleich |\n| `hash` | sha256, sha512, md5, djb2 |\n| `http` | http_get, http_post, http_request |\n| `ipc` | Inter-Prozess-Kommunikation |\n| `iter` | Iterator-Utilities |\n| `json` | parse, stringify, pretty, get, set |\n| `logging` | Logger mit Stufen |\n| `math` | sin, cos, sqrt, pow, rand, PI, E |\n| `net` | TcpListener, TcpStream, UdpSocket |\n| `os` | platform, arch, cpu_count, hostname |\n| `path` | Dateipfad-Manipulation |\n| `process` | fork, exec, wait, kill |\n| `random` | Zufallszahlengenerierung |\n| `regex` | compile, test (POSIX ERE) |\n| `retry` | Wiederholungslogik mit Backoff |\n| `semver` | Semantische Versionierung |\n| `shell` | Shell-Befehls-Utilities |\n| `sqlite` | SQLite-Datenbank, query, exec, Transaktionen |\n| `strings` | pad_left, is_alpha, reverse, lines |\n| `terminal` | ANSI-Farben und -Stile |\n| `testing` | describe, test, expect |\n| `time` | now, time_ms, sleep, clock |\n| `toml` | TOML-Parsing und -Generierung |\n| `url` | URL-Parsing und -Manipulation |\n| `uuid` | UUID-Generierung |\n| `websocket` | WebSocket-Client |\n\nSiehe `stdlib/docs/` fr detaillierte Moduldokumentation.\n\n---\n\n## FFI (Foreign Function Interface)\n\nC-Funktionen aus Shared Libraries deklarieren und aufrufen:\n```hemlock\nimport \"libc.so.6\";\n\nextern fn strlen(s: string): i32;\nextern fn getpid(): i32;\n\nlet len = strlen(\"Hallo!\");  // 6\nlet pid = getpid();\n```\n\nFFI-Funktionen aus Modulen exportieren:\n```hemlock\n// string_utils.hml\nimport \"libc.so.6\";\n\nexport extern fn strlen(s: string): i32;\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n```\n\nDynamisches FFI (Laufzeit-Binding):\n```hemlock\nlet lib = ffi_open(\"libc.so.6\");\nlet puts = ffi_bind(lib, \"puts\", [FFI_POINTER], FFI_INT);\nputs(\"Hallo von C!\");\nffi_close(lib);\n```\n\nTypen: `FFI_INT`, `FFI_DOUBLE`, `FFI_POINTER`, `FFI_STRING`, `FFI_VOID`, etc.\n\n---\n\n## Atomare Operationen\n\nLock-freie nebenlaeufige Programmierung mit atomaren Operationen:\n\n```hemlock\n// Speicher fr atomares i32 allokieren\nlet p = alloc(4);\nptr_write_i32(p, 0);\n\n// Atomares Laden/Speichern\nlet val = atomic_load_i32(p);        // Atomar lesen\natomic_store_i32(p, 42);             // Atomar schreiben\n\n// Fetch-and-Modify-Operationen (geben ALTEN Wert zurck)\nlet old = atomic_add_i32(p, 10);     // Addieren, alten zurckgeben\nold = atomic_sub_i32(p, 5);          // Subtrahieren, alten zurckgeben\nold = atomic_and_i32(p, 0xFF);       // Bitweises UND\nold = atomic_or_i32(p, 0x10);        // Bitweises ODER\nold = atomic_xor_i32(p, 0x0F);       // Bitweises XOR\n\n// Compare-and-Swap (CAS)\nlet success = atomic_cas_i32(p, 42, 100);  // Wenn *p == 42, auf 100 setzen\n// Gibt true zurck wenn Swap erfolgreich, sonst false\n\n// Atomarer Austausch\nold = atomic_exchange_i32(p, 999);   // Tauschen, alten zurckgeben\n\nfree(p);\n\n// i64-Varianten verfgbar (atomic_load_i64, atomic_add_i64, etc.)\n\n// Speicherbarriere (vollstndige Barriere)\natomic_fence();\n```\n\nAlle Operationen verwenden sequenzielle Konsistenz (`memory_order_seq_cst`).\n\n---\n\n## Projektstruktur\n\n```\nhemlock/\n src/\n    frontend/         # Gemeinsam: Lexer, Parser, AST, Module\n    backends/\n       interpreter/  # hemlock: Tree-Walking-Interpreter\n       compiler/     # hemlockc: C-Code-Generator\n    tools/\n       lsp/          # Language Server Protocol\n       bundler/      # Bundle-/Paket-Tools\n runtime/              # Kompilierte Programm-Laufzeit (libhemlock_runtime.a)\n stdlib/               # Standardbibliothek (40 Module)\n    docs/             # Moduldokumentation\n docs/                 # Vollstndige Dokumentation\n    language-guide/   # Typen, Strings, Arrays, etc.\n    reference/        # API-Referenzen\n    advanced/         # Async, FFI, Signale, etc.\n tests/                # 625+ Tests\n examples/             # Beispielprogramme\n```\n\n---\n\n## Code-Stil-Richtlinien\n\n### Konstanten und magische Zahlen\n\nBeim Hinzufgen von numerischen Konstanten zur C-Codebasis folge diesen Richtlinien:\n\n1. **Definiere Konstanten in `include/hemlock_limits.h`** - Diese Datei ist der zentrale Ort fr alle Kompilierzeit- und Laufzeitlimits, Kapazitaeten und benannte Konstanten.\n\n2. **Verwende beschreibende Namen mit `HML_`-Prfix** - Alle Konstanten sollten mit `HML_` prfixiert werden fr Namensraum-Klarheit.\n\n3. **Vermeide magische Zahlen** - Ersetze hart-codierte numerische Werte durch benannte Konstanten. Beispiele:\n   - Typbereichslimits: `HML_I8_MIN`, `HML_I8_MAX`, `HML_U32_MAX`\n   - Pufferkapazitaeten: `HML_INITIAL_ARRAY_CAPACITY`, `HML_INITIAL_LEXER_BUFFER_CAPACITY`\n   - Zeitumrechnungen: `HML_NANOSECONDS_PER_SECOND`, `HML_MILLISECONDS_PER_SECOND`\n   - Hash-Seeds: `HML_DJB2_HASH_SEED`\n   - ASCII-Werte: `HML_ASCII_CASE_OFFSET`, `HML_ASCII_PRINTABLE_START`\n\n4. **Inkludiere `hemlock_limits.h`** - Quelldateien sollten diesen Header einbinden (oft via `internal.h`) um auf Konstanten zuzugreifen.\n\n5. **Dokumentiere den Zweck** - Fuege einen Kommentar hinzu, der erklrt, was jede Konstante repraesentiert.\n\n---\n\n## Was man NICHT tun sollte\n\n- Implizites Verhalten hinzufgen (ASI, GC, Auto-Cleanup)\n- Komplexitt verstecken (magische Optimierungen, versteckte Refcounts)\n- Bestehende Semantik brechen (Semikolons, manueller Speicher, mutable Strings)\n- Przision bei impliziten Konvertierungen verlieren\n- Magische Zahlen verwenden - definiere stattdessen benannte Konstanten in `hemlock_limits.h`\n\n---\n\n## Testen\n\n```bash\nmake test              # Interpreter-Tests ausfhren\nmake test-compiler     # Compiler-Tests ausfhren\nmake parity            # Paritaetstests ausfhren (beide mssen bereinstimmen)\nmake test-all          # Alle Testsuiten ausfhren\n```\n\n**Wichtig:** Tests knnen aufgrund von async/Nebenlaeufigkeitsproblemen haengen bleiben. Verwende immer einen Timeout beim Ausfhren von Tests:\n```bash\ntimeout 60 make test   # 60 Sekunden Timeout\ntimeout 120 make parity\n```\n\nTestkategorien: primitives, memory, strings, arrays, functions, objects, async, ffi, defer, signals, switch, bitwise, typed_arrays, modules, stdlib_*\n\n---\n\n## Compiler/Interpreter-Architektur\n\nHemlock hat zwei Ausfuehrungsbackends, die ein gemeinsames Frontend teilen:\n\n```\nQuellcode (.hml)\n    \n\n  GEMEINSAMES FRONTEND       \n  - Lexer (src/frontend/)    \n  - Parser (src/frontend/)   \n  - AST (src/frontend/)      \n\n                        \n    \n INTERPRETER      COMPILER  \n (hemlock)       (hemlockc) \n                            \n Tree-Walk       Typcheck   \n Auswertung      AST  C    \n                 gcc Link   \n    \n```\n\n### Compiler-Typprfung\n\nDer Compiler (`hemlockc`) beinhaltet Kompilierzeit-Typprfung, **standardmig aktiviert**:\n\n```bash\nhemlockc program.hml -o program    # Typprueft, dann kompiliert\nhemlockc --check program.hml       # Nur Typprfung, nicht kompilieren\nhemlockc --no-type-check prog.hml  # Typprfung deaktivieren\nhemlockc --strict-types prog.hml   # Warnung bei impliziten 'any'-Typen\n```\n\nDer Typchecker:\n- Validiert Typannotationen zur Kompilierzeit\n- Behandelt untypisierten Code als dynamisch (`any`-Typ) - immer gltig\n- Bietet Optimierungshinweise fr Unboxing\n- Verwendet permissive numerische Konvertierungen (Bereich zur Laufzeit validiert)\n\n### Verzeichnisstruktur\n\n```\nhemlock/\n src/\n    frontend/           # Gemeinsam: Lexer, Parser, AST, Module\n       lexer.c\n       parser/\n       ast.c\n       module.c\n    backends/\n       interpreter/    # hemlock: Tree-Walking-Interpreter\n          main.c\n          runtime/\n          builtins/\n       compiler/       # hemlockc: C-Code-Generator\n           main.c\n           codegen/\n    tools/\n       lsp/            # Language Server\n       bundler/        # Bundle-/Paket-Tools\n runtime/                # libhemlock_runtime.a fr kompilierte Programme\n stdlib/                 # Gemeinsame Standardbibliothek\n tests/\n     parity/             # Tests die BEIDE Backends bestehen MUESSEN\n     interpreter/        # Interpreter-spezifische Tests\n     compiler/           # Compiler-spezifische Tests\n```\n\n---\n\n## Paritaets-zuerst-Entwicklung\n\n**Sowohl der Interpreter als auch der Compiler mssen identische Ausgabe fr die gleiche Eingabe produzieren.**\n\n### Entwicklungsrichtlinie\n\nBeim Hinzufgen oder Modifizieren von Sprachfeatures:\n\n1. **Design** - Definiere die AST-/semantische nderung im gemeinsamen Frontend\n2. **Interpreter implementieren** - Tree-Walking-Auswertung hinzufgen\n3. **Compiler implementieren** - C-Code-Generierung hinzufgen\n4. **Paritaetstest hinzufgen** - Test in `tests/parity/` mit `.expected`-Datei schreiben\n5. **Verifizieren** - Fuehre `make parity` vor dem Mergen aus\n\n### Paritaetsteststruktur\n\n```\ntests/parity/\n language/       # Kern-Sprachfeatures (Kontrollfluss, Closures, etc.)\n builtins/       # Eingebaute Funktionen (print, typeof, memory, etc.)\n methods/        # String- und Array-Methoden\n modules/        # Import/Export, Stdlib-Imports\n```\n\nJeder Test hat zwei Dateien:\n- `feature.hml` - Das Testprogramm\n- `feature.expected` - Erwartete Ausgabe (muss fr beide Backends bereinstimmen)\n\n### Paritaetstestergebnisse\n\n| Status | Bedeutung |\n|--------|-----------|\n| ` PASSED` | Sowohl Interpreter als auch Compiler stimmen mit erwarteter Ausgabe berein |\n| ` INTERP_ONLY` | Interpreter funktioniert, Compiler scheitert (braucht Compiler-Fix) |\n| ` COMPILER_ONLY` | Compiler funktioniert, Interpreter scheitert (selten) |\n| ` FAILED` | Beide scheitern (Test- oder Implementierungsfehler) |\n\n### Was Paritaet erfordert\n\n- Alle Sprachkonstrukte (if, while, for, switch, defer, try/catch)\n- Alle Operatoren (arithmetisch, bitweise, logisch, Vergleich)\n- Alle eingebauten Funktionen (print, typeof, alloc, etc.)\n- Alle String- und Array-Methoden\n- Typzwangs- und Promotionsregeln\n- Fehlermeldungen fr Laufzeitfehler\n\n### Was sich unterscheiden darf\n\n- Leistungscharakteristiken\n- Speicherlayout-Details\n- Debug-/Stacktrace-Format\n- Kompilierungsfehler (Compiler kann mehr zur Kompilierzeit erkennen)\n\n### Einen Paritaetstest hinzufgen\n\n```bash\n# 1. Testdatei erstellen\ncat > tests/parity/language/my_feature.hml << 'EOF'\n// Testbeschreibung\nlet x = some_feature();\nprint(x);\nEOF\n\n# 2. Erwartete Ausgabe vom Interpreter generieren\n./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected\n\n# 3. Paritaet verifizieren\nmake parity\n```\n\n---\n\n## Version\n\n**v1.8.0** - Aktuelles Release mit:\n- **Musterabgleich** (`match`-Ausdrcke) - Mchtige Destrukturierung und Kontrollfluss:\n  - Literal-, Platzhalter- und Variablenbindungsmuster\n  - ODER-Muster (`1 | 2 | 3`)\n  - Guard-Ausdrcke (`n if n > 0`)\n  - Objekt-Destrukturierung (`{ x, y }`)\n  - Array-Destrukturierung mit Rest (`[first, ...rest]`)\n  - Typmuster (`n: i32`)\n  - Volle Paritaet zwischen Interpreter und Compiler\n- **Compiler-Hilfsannotationen** - 11 Optimierungsannotationen fr GCC/Clang-Kontrolle:\n  - `@inline`, `@noinline` - Funktions-Inlining-Kontrolle\n  - `@hot`, `@cold` - Branch-Prediction-Hinweise\n  - `@pure`, `@const` - Seiteneffekt-Annotationen\n  - `@flatten` - alle Aufrufe innerhalb der Funktion inlinen\n  - `@optimize(level)` - Pro-Funktion-Optimierungsstufe (\"0\", \"1\", \"2\", \"3\", \"s\", \"fast\")\n  - `@warn_unused` - Warnung bei ignorierten Rueckgabewerten\n  - `@section(name)` - Benutzerdefinierte ELF-Sektionsplatzierung (z.B. `@section(\".text.hot\")`)\n- **Ausdruckskrper-Funktionen** (`fn double(x): i32 => x * 2;`) - praegnante Einzelausdruck-Funktionssyntax\n- **Einzeilige Anweisungen** - klammerlose `if`, `while`, `for`-Syntax (z.B. `if (x > 0) print(x);`)\n- **Typaliase** (`type Name = Type;`) - benannte Abkrzungen fr komplexe Typen\n- **Funktionstyp-Annotationen** (`fn(i32): i32`) - erstklassige Funktionstypen\n- **Const-Parameter** (`fn(const x: array)`) - tiefe Unvernderlichkeit fr Parameter\n- **Ref-Parameter** (`fn(ref x: i32)`) - bergabe per Referenz fr direkte Aufrufer-Mutation\n- **Methodensignaturen in define** (`fn method(): Type`) - Interface-artige Vertrge (komma-getrennt)\n- **Self-Typ** in Methodensignaturen - bezieht sich auf den definierenden Typ\n- **Loop-Schlsselwort** (`loop { }`) - sauberere Endlosschleifen, ersetzt `while (true)`\n- **Schleifenlabels** (`outer: while`) - gezieltes break/continue fr verschachtelte Schleifen\n- **Objekt-Kurzschreibweise** (`{ name }`) - ES6-Stil-Kurzeigenschaften-Syntax\n- **Objekt-Spread** (`{ ...obj }`) - Objektfelder kopieren und zusammenfuehren\n- **Zusammengesetzte Duck-Typen** (`A & B & C`) - Schnittmengentypen fr strukturelle Typisierung\n- **Benannte Argumente** fr Funktionsaufrufe (`foo(name: \"value\", age: 30)`)\n- **Null-Koaleszenz-Operatoren** (`??`, `??=`, `?.`) fr sichere Null-Behandlung\n- **Oktal-Literale** (`0o777`, `0O123`)\n- **Numerische Trennzeichen** (`1_000_000`, `0xFF_FF`, `0b1111_0000`)\n- **Blockkommentare** (`/* ... */`)\n- **Hex-Escape-Sequenzen** in Strings/Runes (`\\x41` = 'A')\n- **Unicode-Escape-Sequenzen** in Strings (`\\u{1F600}` = )\n- **Float-Literale ohne fhrende Null** (`.5`, `.123`, `.5e2`)\n- **Kompilierzeit-Typprfung** in hemlockc (standardmig aktiviert)\n- **LSP-Integration** mit Typprfung fr Echtzeit-Diagnosen\n- **Zusammengesetzte Zuweisungsoperatoren** (`+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`)\n- **Inkrement/Dekrement-Operatoren** (`++x`, `x++`, `--x`, `x--`)\n- **Typ-Praezisions-Fix**: i64/u64 + f32  f64 um Przision zu erhalten\n- Vereinheitlichtes Typsystem mit Unboxing-Optimierungshinweisen\n- Volles Typsystem (i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object, enum, file, task, channel)\n- UTF-8-Strings mit 19 Methoden\n- Arrays mit 18 Methoden einschlielich map/filter/reduce\n- Manuelle Speicherverwaltung mit `talloc()` und `sizeof()`\n- Async/await mit echter pthread-Parallelitt\n- Atomare Operationen fr lock-freie nebenlaeufige Programmierung\n- 40 Stdlib-Module (+ arena, assert, semver, toml, retry, iter, random, shell)\n- FFI fr C-Interop mit `export extern fn` fr wiederverwendbare Bibliotheks-Wrapper\n- FFI-Struct-Untersttzung im Compiler (C-Structs per Wert bergeben)\n- FFI-Zeiger-Helfer (`ptr_null`, `ptr_read_*`, `ptr_write_*`)\n- defer, try/catch/finally/throw, panic\n- Datei-I/O, Signalbehandlung, Befehlsausfuehrung\n- [hpm](https://github.com/hemlang/hpm) Paketmanager mit GitHub-basierter Registry\n- Compiler-Backend (C-Code-Generierung) mit 100% Interpreter-Paritaet\n- LSP-Server mit Go-to-Definition und Find-References\n- AST-Optimierungspass und Variablenaufloesung fr O(1)-Lookup\n- apply()-Builtin fr dynamische Funktionsaufrufe\n- Ungepufferte Kanle und Many-Params-Untersttzung\n- 159 Paritaetstests (100% Erfolgsrate)\n\n---\n\n## Philosophie\n\n> Wir geben dir die Werkzeuge, um sicher zu sein (`buffer`, Typannotationen, Grenzprfung), aber wir zwingen dich nicht, sie zu verwenden (`ptr`, manueller Speicher, unsichere Operationen).\n\n**Wenn du unsicher bist, ob ein Feature zu Hemlock passt, frage: \"Gibt dies dem Programmierer mehr explizite Kontrolle, oder versteckt es etwas?\"**\n\nWenn es versteckt, gehrt es wahrscheinlich nicht in Hemlock.\n"}, "Erste Schritte -> Installation": {"id": "getting-started-installation", "content": "# Installation\n\nDiese Anleitung hilft Ihnen bei der Installation von Hemlock auf Ihrem System.\n\n## Schnellinstallation (Empfohlen)\n\nDer einfachste Weg, Hemlock zu installieren, ist das einzeilige Installationsskript:\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash\n```\n\nDies ldt die neueste vorkompilierte Binrdatei fr Ihre Plattform herunter und installiert sie (Linux oder macOS, x86_64 oder arm64).\n\n### Installationsoptionen\n\n```bash\n# Installation in ein benutzerdefiniertes Prfix (Standard: ~/.local)\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local\n\n# Installation einer bestimmten Version\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0\n\n# Installation und automatische Aktualisierung des Shell-PATH\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path\n```\n\nNach der Installation berprfen Sie die Funktionsfhigkeit:\n\n```bash\nhemlock --version\n```\n\n---\n\n## Aus dem Quellcode kompilieren\n\nWenn Sie lieber aus dem Quellcode kompilieren mchten oder die vorkompilierten Binrdateien fr Ihr System nicht funktionieren, folgen Sie den nachstehenden Anweisungen.\n\n## Voraussetzungen\n\n### Erforderliche Abhngigkeiten\n\nHemlock bentigt folgende Abhngigkeiten zum Kompilieren:\n\n- **C-Compiler**: GCC oder Clang (C11-Standard)\n- **Make**: GNU Make\n- **libffi**: Foreign Function Interface-Bibliothek (fr FFI-Untersttzung)\n- **OpenSSL**: Kryptografie-Bibliothek (fr Hash-Funktionen: md5, sha1, sha256)\n- **libwebsockets**: WebSocket- und HTTP-Client/Server-Untersttzung\n- **zlib**: Kompressionsbibliothek\n\n### Abhngigkeiten installieren\n\n**macOS:**\n```bash\n# Homebrew installieren, falls noch nicht vorhanden\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Xcode Command Line Tools installieren\nxcode-select --install\n\n# Abhngigkeiten ber Homebrew installieren\nbrew install libffi openssl@3 libwebsockets\n```\n\n**Hinweis fr macOS-Benutzer**: Das Makefile erkennt automatisch Homebrew-Installationen und setzt die korrekten Include-/Bibliothekspfade. Hemlock untersttzt sowohl Intel- (x86_64) als auch Apple-Silicon- (arm64) Architekturen.\n\n**Ubuntu/Debian:**\n```bash\nsudo apt-get update\nsudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev\n```\n\n**Fedora/RHEL:**\n```bash\nsudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel\n```\n\n**Arch Linux:**\n```bash\nsudo pacman -S base-devel libffi openssl libwebsockets zlib\n```\n\n## Aus dem Quellcode kompilieren\n\n### 1. Repository klonen\n\n```bash\ngit clone https://github.com/hemlang/hemlock.git\ncd hemlock\n```\n\n### 2. Hemlock kompilieren\n\n```bash\nmake\n```\n\nDies kompiliert den Hemlock-Interpreter und platziert die ausfhrbare Datei im aktuellen Verzeichnis.\n\n### 3. Installation berprfen\n\n```bash\n./hemlock --version\n```\n\nSie sollten die Hemlock-Versionsinformationen sehen.\n\n### 4. Build testen\n\nFhren Sie die Testsuite aus, um sicherzustellen, dass alles korrekt funktioniert:\n\n```bash\nmake test\n```\n\nAlle Tests sollten bestehen. Falls Fehler auftreten, melden Sie diese bitte als Issue.\n\n## Systemweite Installation (Optional)\n\nUm Hemlock systemweit zu installieren (z.B. in `/usr/local/bin`):\n\n```bash\nsudo make install\n```\n\nDies ermglicht es Ihnen, `hemlock` von berall auszufhren, ohne den vollstndigen Pfad anzugeben.\n\n## Hemlock ausfhren\n\n### Interaktive REPL\n\nStarten Sie die Read-Eval-Print-Schleife:\n\n```bash\n./hemlock\n```\n\nSie sehen eine Eingabeaufforderung, in der Sie Hemlock-Code eingeben knnen:\n\n```\nHemlock REPL\n> print(\"Hallo, Welt!\");\nHallo, Welt!\n> let x = 42;\n> print(x * 2);\n84\n>\n```\n\nBeenden Sie die REPL mit `Ctrl+D` oder `Ctrl+C`.\n\n### Programme ausfhren\n\nFhren Sie ein Hemlock-Skript aus:\n\n```bash\n./hemlock programm.hml\n```\n\nMit Kommandozeilenargumenten:\n\n```bash\n./hemlock programm.hml arg1 arg2 \"Argument mit Leerzeichen\"\n```\n\n## Verzeichnisstruktur\n\nNach dem Kompilieren sieht Ihr Hemlock-Verzeichnis so aus:\n\n```\nhemlock/\n hemlock           # Kompilierte Interpreter-Ausfhrungsdatei\n src/              # Quellcode\n include/          # Header-Dateien\n tests/            # Testsuite\n examples/         # Beispielprogramme\n docs/             # Dokumentation\n stdlib/           # Standardbibliothek\n Makefile          # Build-Konfiguration\n README.md         # Projekt-README\n```\n\n## Build-Optionen\n\n### Debug-Build\n\nMit Debug-Symbolen und ohne Optimierung kompilieren:\n\n```bash\nmake debug\n```\n\n### Bereinigter Build\n\nAlle kompilierten Dateien entfernen:\n\n```bash\nmake clean\n```\n\nVon Grund auf neu kompilieren:\n\n```bash\nmake clean && make\n```\n\n## Fehlerbehebung\n\n### macOS: Bibliothek nicht gefunden\n\nWenn Sie Fehler ber fehlende Bibliotheken erhalten (`-lcrypto`, `-lffi`, usw.):\n\n1. Stellen Sie sicher, dass die Homebrew-Abhngigkeiten installiert sind:\n   ```bash\n   brew install libffi openssl@3 libwebsockets\n   ```\n\n2. berprfen Sie die Homebrew-Pfade:\n   ```bash\n   brew --prefix libffi\n   brew --prefix openssl\n   ```\n\n3. Das Makefile sollte diese Pfade automatisch erkennen. Falls nicht, berprfen Sie, ob `brew` in Ihrem PATH ist:\n   ```bash\n   which brew\n   ```\n\n### macOS: BSD-Typfehler (`u_int`, `u_char` nicht gefunden)\n\nWenn Sie Fehler ber unbekannte Typnamen wie `u_int` oder `u_char` sehen:\n\n1. Dies wurde in v1.0.0+ durch Verwendung von `_DARWIN_C_SOURCE` anstelle von `_POSIX_C_SOURCE` behoben\n2. Stellen Sie sicher, dass Sie die neueste Version des Codes haben\n3. Bereinigen und neu kompilieren:\n   ```bash\n   make clean && make\n   ```\n\n### Linux: libffi nicht gefunden\n\nWenn Sie Fehler ber fehlende `ffi.h` oder `-lffi` erhalten:\n\n1. Stellen Sie sicher, dass `libffi-dev` installiert ist (siehe Abhngigkeiten oben)\n2. Prfen Sie, ob `pkg-config` es finden kann:\n   ```bash\n   pkg-config --cflags --libs libffi\n   ```\n3. Falls nicht gefunden, mssen Sie mglicherweise `PKG_CONFIG_PATH` setzen:\n   ```bash\n   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH\n   ```\n\n### Kompilierungsfehler\n\nWenn Kompilierungsfehler auftreten:\n\n1. Stellen Sie sicher, dass Sie einen C11-kompatiblen Compiler haben\n2. Unter macOS versuchen Sie Clang (Standard):\n   ```bash\n   make CC=clang\n   ```\n3. Unter Linux versuchen Sie GCC:\n   ```bash\n   make CC=gcc\n   ```\n4. berprfen Sie, ob alle Abhngigkeiten installiert sind\n5. Versuchen Sie, von Grund auf neu zu kompilieren:\n   ```bash\n   make clean && make\n   ```\n\n### Testfehler\n\nWenn Tests fehlschlagen:\n\n1. Stellen Sie sicher, dass Sie die neueste Version des Codes haben\n2. Versuchen Sie, von Grund auf neu zu kompilieren:\n   ```bash\n   make clean && make test\n   ```\n3. Unter macOS stellen Sie sicher, dass Sie die neuesten Xcode Command Line Tools haben:\n   ```bash\n   xcode-select --install\n   ```\n4. Melden Sie das Problem auf GitHub mit:\n   - Ihrer Plattform (macOS-Version / Linux-Distribution)\n   - Architektur (x86_64 / arm64)\n   - Testausgabe\n   - Ausgabe von `make -v` und `gcc --version` (oder `clang --version`)\n\n## Nchste Schritte\n\n- [Schnellstart-Anleitung](#getting-started-quick-start) - Schreiben Sie Ihr erstes Hemlock-Programm\n- [Tutorial](#getting-started-tutorial) - Lernen Sie Hemlock Schritt fr Schritt\n- [Sprachhandbuch](#language-guide-syntax) - Entdecken Sie Hemlock-Funktionen\n"}, "Erste Schritte -> Lernpfade": {"id": "getting-started-learning-paths", "content": "# Lernpfade\n\nVerschiedene Ziele erfordern unterschiedliches Wissen. Whlen Sie den Pfad, der zu dem passt, was Sie erstellen mchten.\n\n---\n\n## Pfad 1: Schnelle Skripte & Automatisierung\n\n**Ziel:** Skripte schreiben, um Aufgaben zu automatisieren, Dateien zu verarbeiten und Dinge zu erledigen.\n\n**Zeit bis zur Produktivitt:** Schnell - Sie knnen sofort mit dem Schreiben ntzlicher Skripte beginnen.\n\n### Was Sie lernen werden\n\n1. **[Schnellstart](#getting-started-quick-start)** - Ihr erstes Programm, grundlegende Syntax\n2. **[Zeichenketten](#language-guide-strings)** - Textverarbeitung, Aufteilen, Suchen\n3. **[Arrays](#language-guide-arrays)** - Listen, Filtern, Daten transformieren\n4. **[Datei-I/O](#advanced-file-io)** - Dateien lesen und schreiben\n5. **[Kommandozeilenargumente](#advanced-command-line-args)** - Eingaben von Benutzern erhalten\n\n### Vorerst berspringen\n\n- Speicherverwaltung (automatisch fr Skripte)\n- Async/Nebenlufigkeit (bertrieben fr einfache Skripte)\n- FFI (nur fr C-Interop bentigt)\n\n### Beispielprojekt: Datei-Umbenenner\n\n```hemlock\nimport { list_dir, rename } from \"@stdlib/fs\";\n\n// Alle .txt-Dateien in .md umbenennen\nlet files = list_dir(\".\");\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let new_name = file.replace(\".txt\", \".md\");\n        rename(file, new_name);\n        print(`Umbenannt: ${file} -> ${new_name}`);\n    }\n}\n```\n\n---\n\n## Pfad 2: Datenverarbeitung & Analyse\n\n**Ziel:** Daten parsen, transformieren, Berichte generieren.\n\n**Zeit bis zur Produktivitt:** Schnell - Hemlocks String- und Array-Methoden machen dies einfach.\n\n### Was Sie lernen werden\n\n1. **[Schnellstart](#getting-started-quick-start)** - Grundlagen\n2. **[Zeichenketten](#language-guide-strings)** - Parsen, Aufteilen, Formatieren\n3. **[Arrays](#language-guide-arrays)** - map, filter, reduce fr Datentransformation\n4. **[Objekte](#language-guide-objects)** - Strukturierte Daten\n5. **Standardbibliothek:**\n   - **[@stdlib/json](#stdlib-json)** - JSON-Parsing\n   - **[@stdlib/csv](#stdlib-csv)** - CSV-Dateien\n   - **[@stdlib/fs](#stdlib-fs)** - Dateioperationen\n\n### Beispielprojekt: CSV-Analysator\n\n```hemlock\nimport { read_file } from \"@stdlib/fs\";\nimport { parse } from \"@stdlib/csv\";\n\nlet data = parse(read_file(\"sales.csv\"));\n\n// Gesamtumsatz berechnen\nlet total = 0;\nfor (row in data) {\n    total = total + f64(row.amount);\n}\n\nprint(`Gesamtumsatz: ${total}`);\n\n// Top-Verkufer finden\nlet top = data[0];\nfor (row in data) {\n    if (f64(row.amount) > f64(top.amount)) {\n        top = row;\n    }\n}\n\nprint(`Top-Verkauf: ${top.product} - ${top.amount}`);\n```\n\n---\n\n## Pfad 3: Web- & Netzwerkprogrammierung\n\n**Ziel:** HTTP-Clients erstellen, mit APIs arbeiten, Server erstellen.\n\n**Zeit bis zur Produktivitt:** Mittel - erfordert Verstndnis der Async-Grundlagen.\n\n### Was Sie lernen werden\n\n1. **[Schnellstart](#getting-started-quick-start)** - Grundlagen\n2. **[Funktionen](#language-guide-functions)** - Callbacks und Closures\n3. **[Fehlerbehandlung](#language-guide-error-handling)** - try/catch fr Netzwerkfehler\n4. **[Async & Nebenlufigkeit](#advanced-async-concurrency)** - spawn, await, Channels\n5. **Standardbibliothek:**\n   - **[@stdlib/http](#stdlib-http)** - HTTP-Anfragen\n   - **[@stdlib/json](#stdlib-json)** - JSON fr APIs\n   - **[@stdlib/net](#stdlib-net)** - TCP/UDP-Sockets\n   - **[@stdlib/url](#stdlib-url)** - URL-Parsing\n\n### Beispielprojekt: API-Client\n\n```hemlock\nimport { http_get, http_post } from \"@stdlib/http\";\nimport { parse, stringify } from \"@stdlib/json\";\n\n// GET-Anfrage\nlet response = http_get(\"https://api.example.com/users\");\nlet users = parse(response.body);\n\nfor (user in users) {\n    print(`${user.name}: ${user.email}`);\n}\n\n// POST-Anfrage\nlet new_user = { name: \"Alice\", email: \"alice@example.com\" };\nlet result = http_post(\"https://api.example.com/users\", {\n    body: stringify(new_user),\n    headers: { \"Content-Type\": \"application/json\" }\n});\n\nprint(`Benutzer erstellt mit ID: ${parse(result.body).id}`);\n```\n\n---\n\n## Pfad 4: Systemprogrammierung\n\n**Ziel:** Low-Level-Code schreiben, mit Speicher arbeiten, mit C-Bibliotheken interagieren.\n\n**Zeit bis zur Produktivitt:** Lnger - erfordert Verstndnis der Speicherverwaltung.\n\n### Was Sie lernen werden\n\n1. **[Schnellstart](#getting-started-quick-start)** - Grundlagen\n2. **[Typen](#language-guide-types)** - i32, u8, ptr usw. verstehen\n3. **[Speicherverwaltung](#language-guide-memory)** - alloc, free, Puffer\n4. **[FFI](#advanced-ffi)** - C-Funktionen aufrufen\n5. **[Signale](#advanced-signals)** - Signalverarbeitung\n\n### Schlsselkonzepte\n\n**Speichersicherheits-Checkliste:**\n- [ ] Jedes `alloc()` hat ein entsprechendes `free()`\n- [ ] `buffer()` verwenden, es sei denn, Sie bentigen rohe `ptr`\n- [ ] Zeiger nach dem Freigeben auf `null` setzen\n- [ ] `try/finally` verwenden, um Bereinigung zu garantieren\n\n**Typ-Mapping fr FFI:**\n| Hemlock | C |\n|---------|---|\n| `i8` | `char` / `int8_t` |\n| `i32` | `int` |\n| `i64` | `long` (64-Bit) |\n| `u8` | `unsigned char` |\n| `f64` | `double` |\n| `ptr` | `void*` |\n\n### Beispielprojekt: Benutzerdefinierter Speicherpool\n\n```hemlock\n// Einfacher Bump-Allocator\nlet pool_size = 1024 * 1024;  // 1MB\nlet pool = alloc(pool_size);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > pool_size) {\n        throw \"Pool erschpft\";\n    }\n    let p = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return p;\n}\n\nfn pool_reset() {\n    pool_offset = 0;\n}\n\nfn pool_destroy() {\n    free(pool);\n}\n\n// Verwenden\nlet a = pool_alloc(100);\nlet b = pool_alloc(200);\nmemset(a, 0, 100);\nmemset(b, 0, 200);\n\npool_reset();  // Gesamten Speicher wiederverwenden\npool_destroy();  // Aufrumen\n```\n\n---\n\n## Pfad 5: Parallele & Nebenlufige Programme\n\n**Ziel:** Code auf mehreren CPU-Kernen ausfhren, reaktionsfhige Anwendungen erstellen.\n\n**Zeit bis zur Produktivitt:** Mittel - Async-Syntax ist unkompliziert, aber das Nachdenken ber Parallelitt erfordert bung.\n\n### Was Sie lernen werden\n\n1. **[Schnellstart](#getting-started-quick-start)** - Grundlagen\n2. **[Funktionen](#language-guide-functions)** - Closures (wichtig fr Async)\n3. **[Async & Nebenlufigkeit](#advanced-async-concurrency)** - Vollstndiger Tiefgang\n4. **[Atomics](#advanced-atomics)** - Lock-freie Programmierung\n\n### Schlsselkonzepte\n\n**Hemlocks Async-Modell:**\n- `async fn` - Definiert eine Funktion, die auf einem anderen Thread laufen kann\n- `spawn(fn, args...)` - Startet die Ausfhrung, gibt ein Task-Handle zurck\n- `join(task)` oder `await task` - Warten auf Fertigstellung, Ergebnis abrufen\n- `channel(size)` - Warteschlange zum Senden von Daten zwischen Tasks erstellen\n\n**Wichtig:** Tasks erhalten *Kopien* von Werten. Wenn Sie einen Zeiger bergeben, sind Sie dafr verantwortlich, sicherzustellen, dass der Speicher gltig bleibt, bis der Task abgeschlossen ist.\n\n### Beispielprojekt: Paralleler Dateiprozessor\n\n```hemlock\nimport { list_dir, read_file } from \"@stdlib/fs\";\n\nasync fn process_file(path: string): i32 {\n    let content = read_file(path);\n    let lines = content.split(\"\\n\");\n    return lines.length;\n}\n\n// Alle Dateien parallel verarbeiten\nlet files = list_dir(\"data/\");\nlet tasks = [];\n\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let task = spawn(process_file, \"data/\" + file);\n        tasks.push({ name: file, task: task });\n    }\n}\n\n// Ergebnisse sammeln\nlet total_lines = 0;\nfor (item in tasks) {\n    let count = join(item.task);\n    print(`${item.name}: ${count} Zeilen`);\n    total_lines = total_lines + count;\n}\n\nprint(`Gesamt: ${total_lines} Zeilen`);\n```\n\n---\n\n## Was zuerst lernen (Jeder Pfad)\n\nEgal welches Ziel, beginnen Sie mit diesen Grundlagen:\n\n### Woche 1: Kerngrundlagen\n1. **[Schnellstart](#getting-started-quick-start)** - Schreiben und fhren Sie Ihr erstes Programm aus\n2. **[Syntax](#language-guide-syntax)** - Variablen, Operatoren, Kontrollfluss\n3. **[Funktionen](#language-guide-functions)** - Funktionen definieren und aufrufen\n\n### Woche 2: Datenverarbeitung\n4. **[Zeichenketten](#language-guide-strings)** - Textmanipulation\n5. **[Arrays](#language-guide-arrays)** - Sammlungen und Iteration\n6. **[Objekte](#language-guide-objects)** - Strukturierte Daten\n\n### Woche 3: Robustheit\n7. **[Fehlerbehandlung](#language-guide-error-handling)** - try/catch/throw\n8. **[Module](#language-guide-modules)** - Import/Export, Stdlib verwenden\n\n### Dann: Whlen Sie Ihren Pfad oben\n\n---\n\n## Spickzettel: Kommend von anderen Sprachen\n\n### Von Python\n\n| Python | Hemlock | Hinweise |\n|--------|---------|----------|\n| `x = 42` | `let x = 42;` | Semikolons erforderlich |\n| `def fn():` | `fn name() { }` | Geschweifte Klammern erforderlich |\n| `if x:` | `if (x) { }` | Klammern und geschweifte Klammern erforderlich |\n| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | C-hnliche For-Schleifen |\n| `for item in list:` | `for (item in array) { }` | For-in funktioniert gleich |\n| `list.append(x)` | `array.push(x);` | Anderer Methodenname |\n| `len(s)` | `s.length` oder `len(s)` | Beides funktioniert |\n| Automatischer Speicher | Manuell fr `ptr` | Die meisten Typen rumen automatisch auf |\n\n### Von JavaScript\n\n| JavaScript | Hemlock | Hinweise |\n|------------|---------|----------|\n| `let x = 42` | `let x = 42;` | Gleich (Semikolons erforderlich) |\n| `const x = 42` | `let x = 42;` | Kein const-Schlsselwort |\n| `function fn()` | `fn name() { }` | Anderes Schlsselwort |\n| `() => x` | `fn() { return x; }` | Keine Pfeilfunktionen |\n| `async/await` | `async/await` | Gleiche Syntax |\n| `Promise` | `spawn/join` | Anderes Modell |\n| Automatische GC | Manuell fr `ptr` | Die meisten Typen rumen automatisch auf |\n\n### Von C/C++\n\n| C | Hemlock | Hinweise |\n|---|---------|----------|\n| `int x = 42;` | `let x: i32 = 42;` | Typ nach Doppelpunkt |\n| `malloc(n)` | `alloc(n)` | Gleiches Konzept |\n| `free(p)` | `free(p)` | Gleich |\n| `char* s = \"hi\"` | `let s = \"hi\";` | Strings werden verwaltet |\n| `#include` | `import { } from` | Modul-Imports |\n| Manuell fr alles | Auto fr die meisten Typen | Nur `ptr` braucht manuell |\n\n---\n\n## Hilfe erhalten\n\n- **[Glossar](../glossary.md)** - Definitionen von Programmierbegriffen\n- **[Beispiele](../../examples/)** - Vollstndige funktionierende Programme\n- **[Tests](../../tests/)** - Sehen Sie, wie Funktionen verwendet werden\n- **GitHub Issues** - Fragen stellen, Fehler melden\n\n---\n\n## Schwierigkeitsstufen\n\nIn der gesamten Dokumentation sehen Sie diese Markierungen:\n\n| Markierung | Bedeutung |\n|------------|-----------|\n| **Anfnger** | Keine vorherige Programmiererfahrung erforderlich |\n| **Fortgeschritten** | Setzt grundlegende Programmierkenntnisse voraus |\n| **Experte** | Erfordert Verstndnis von Systemkonzepten |\n\nWenn Sie etwas, das als \"Anfnger\" markiert ist, verwirrt, schauen Sie im [Glossar](../glossary.md) nach Begriffsdefinitionen.\n"}, "Erste Schritte -> Schnellstart": {"id": "getting-started-quick-start", "content": "# Schnellstart\n\nStarten Sie mit Hemlock in wenigen Minuten!\n\n## Ihr erstes Programm\n\nErstellen Sie eine Datei namens `hello.hml`:\n\n```hemlock\nprint(\"Hallo, Hemlock!\");\n```\n\nFhren Sie es mit dem Interpreter aus:\n\n```bash\n./hemlock hello.hml\n```\n\nOder kompilieren Sie es zu einer nativen ausfhrbaren Datei:\n\n```bash\n./hemlockc hello.hml -o hello\n./hello\n```\n\nAusgabe:\n```\nHallo, Hemlock!\n```\n\n### Interpreter vs. Compiler\n\nHemlock bietet zwei Mglichkeiten, Programme auszufhren:\n\n| Werkzeug | Anwendungsfall | Typprfung |\n|----------|----------------|------------|\n| `hemlock` | Schnelle Skripte, REPL, Entwicklung | Nur zur Laufzeit |\n| `hemlockc` | Produktionsbinrdateien, bessere Leistung | Zur Kompilierzeit (Standard) |\n\nDer Compiler (`hemlockc`) prft Ihren Code auf Typfehler, bevor er eine ausfhrbare Datei generiert, und erkennt Fehler frhzeitig.\n\n## Grundlegende Syntax\n\n### Variablen\n\n```hemlock\n// Variablen werden mit 'let' deklariert\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\n// Typannotationen sind optional\nlet count: i32 = 100;\nlet ratio: f64 = 0.618;\n```\n\n**Wichtig**: Semikolons sind in Hemlock **obligatorisch**!\n\n### Typen\n\nHemlock hat ein reichhaltiges Typsystem:\n\n```hemlock\n// Ganzzahlen\nlet small: i8 = 127;          // 8-Bit mit Vorzeichen\nlet byte: u8 = 255;           // 8-Bit ohne Vorzeichen\nlet num: i32 = 2147483647;    // 32-Bit mit Vorzeichen (Standard)\nlet big: i64 = 9223372036854775807;  // 64-Bit mit Vorzeichen\n\n// Gleitkommazahlen\nlet f: f32 = 3.14;            // 32-Bit Gleitkomma\nlet d: f64 = 2.71828;         // 64-Bit Gleitkomma (Standard)\n\n// Zeichenketten und Zeichen\nlet text: string = \"Hallo\";   // UTF-8-Zeichenkette\nlet emoji: rune = '';       // Unicode-Codepunkt\n\n// Boolean und null\nlet flag: bool = true;\nlet empty = null;\n```\n\n### Kontrollfluss\n\n```hemlock\n// If-Anweisungen\nif (x > 0) {\n    print(\"positiv\");\n} else if (x < 0) {\n    print(\"negativ\");\n} else {\n    print(\"null\");\n}\n\n// While-Schleifen\nlet i = 0;\nwhile (i < 5) {\n    print(i);\n    i = i + 1;\n}\n\n// For-Schleifen\nfor (let j = 0; j < 10; j = j + 1) {\n    print(j);\n}\n```\n\n### Funktionen\n\n```hemlock\n// Benannte Funktion\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nlet result = add(5, 3);  // 8\n\n// Anonyme Funktion\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(multiply(4, 7));  // 28\n```\n\n## Mit Zeichenketten arbeiten\n\nZeichenketten in Hemlock sind **vernderbar** und **UTF-8**:\n\n```hemlock\nlet s = \"hallo\";\ns[0] = 'H';              // Jetzt \"Hallo\"\nprint(s);\n\n// Zeichenketten-Methoden\nlet upper = s.to_upper();     // \"HALLO\"\nlet words = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\nlet sub = s.substr(1, 3);     // \"all\"\n\n// Verkettung\nlet greeting = \"Hallo\" + \", \" + \"Welt!\";\nprint(greeting);  // \"Hallo, Welt!\"\n```\n\n## Arrays\n\nDynamische Arrays mit gemischten Typen:\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Array-Methoden\nnumbers.push(6);        // [1, 2, 3, 4, 5, 6]\nlet last = numbers.pop();  // 6\nlet slice = numbers.slice(1, 4);  // [2, 3, 4]\n\n// Gemischte Typen erlaubt\nlet mixed = [1, \"zwei\", true, null];\n```\n\n## Objekte\n\nJavaScript-hnliche Objekte:\n\n```hemlock\n// Objekt-Literal\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nperson.age = 31;     // Feld ndern\n\n// Methoden mit 'self'\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## Speicherverwaltung\n\nHemlock verwendet **manuelle Speicherverwaltung**:\n\n```hemlock\n// Sicherer Puffer (empfohlen)\nlet buf = buffer(64);   // 64 Bytes allokieren\nbuf[0] = 65;            // Erstes Byte auf 'A' setzen\nprint(buf[0]);          // 65\nfree(buf);              // Speicher freigeben\n\n// Roher Zeiger (fortgeschritten)\nlet ptr = alloc(100);\nmemset(ptr, 0, 100);    // Mit Nullen fllen\nfree(ptr);\n```\n\n**Wichtig**: Sie mssen `free()` aufrufen, was Sie `alloc()`iert haben!\n\n## Fehlerbehandlung\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"Division durch Null\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Fehler: \" + e);\n} finally {\n    print(\"Fertig\");\n}\n```\n\n## Kommandozeilenargumente\n\nZugriff auf Programmargumente ber das `args`-Array:\n\n```hemlock\n// script.hml\nprint(\"Skript:\", args[0]);\nprint(`Argumente: ${args.length - 1}`);\n\nlet i = 1;\nwhile (i < args.length) {\n    print(`  arg ${i}: ${args[i]}`);\n    i = i + 1;\n}\n```\n\nAusfhren mit:\n```bash\n./hemlock script.hml hallo welt\n```\n\nAusgabe:\n```\nSkript: script.hml\nArgumente: 2\n  arg 1: hallo\n  arg 2: welt\n```\n\n## Datei-I/O\n\n```hemlock\n// In Datei schreiben\nlet f = open(\"daten.txt\", \"w\");\nf.write(\"Hallo, Datei!\");\nf.close();\n\n// Aus Datei lesen\nlet f2 = open(\"daten.txt\", \"r\");\nlet content = f2.read();\nprint(content);  // \"Hallo, Datei!\"\nf2.close();\n```\n\n## Was kommt als Nchstes?\n\nNachdem Sie nun die Grundlagen gesehen haben, erkunden Sie mehr:\n\n- [Tutorial](#getting-started-tutorial) - Umfassende Schritt-fr-Schritt-Anleitung\n- [Sprachhandbuch](#language-guide-syntax) - Tiefer Einblick in alle Funktionen\n- [Beispiele](../../examples/) - Praxisnahe Beispielprogramme\n- [API-Referenz](#reference-builtins) - Vollstndige API-Dokumentation\n\n## Hufige Fallstricke\n\n### Semikolons vergessen\n\n```hemlock\n//  FEHLER: Semikolon fehlt\nlet x = 42\nlet y = 10\n\n//  KORREKT\nlet x = 42;\nlet y = 10;\n```\n\n### Speicherfreigabe vergessen\n\n```hemlock\n//  SPEICHERLECK\nlet buf = buffer(100);\n// ... buf verwenden ...\n// Vergessen, free(buf) aufzurufen!\n\n//  KORREKT\nlet buf = buffer(100);\n// ... buf verwenden ...\nfree(buf);\n```\n\n### Geschweifte Klammern sind erforderlich\n\n```hemlock\n//  FEHLER: Geschweifte Klammern fehlen\nif (x > 0)\n    print(\"positiv\");\n\n//  KORREKT\nif (x > 0) {\n    print(\"positiv\");\n}\n```\n\n## Hilfe erhalten\n\n- Lesen Sie die [vollstndige Dokumentation](../README.md)\n- Schauen Sie sich das [Beispielverzeichnis](../../examples/) an\n- Betrachten Sie [Testdateien](../../tests/) fr Verwendungsmuster\n- Melden Sie Probleme auf GitHub\n"}, "Erste Schritte -> Tutorial": {"id": "getting-started-tutorial", "content": "# Hemlock Tutorial\n\nEine umfassende Schritt-fr-Schritt-Anleitung zum Erlernen von Hemlock.\n\n## Inhaltsverzeichnis\n\n1. [Hallo Welt](#hallo-welt)\n2. [Variablen und Typen](#variablen-und-typen)\n3. [Arithmetik und Operationen](#arithmetik-und-operationen)\n4. [Kontrollfluss](#kontrollfluss)\n5. [Funktionen](#funktionen)\n6. [Zeichenketten und Runen](#zeichenketten-und-runen)\n7. [Arrays](#arrays)\n8. [Objekte](#objekte)\n9. [Speicherverwaltung](#speicherverwaltung)\n10. [Fehlerbehandlung](#fehlerbehandlung)\n11. [Datei-I/O](#datei-io)\n12. [Alles zusammenfgen](#alles-zusammenfgen)\n\n## Hallo Welt\n\nBeginnen wir mit dem traditionellen ersten Programm:\n\n```hemlock\nprint(\"Hallo, Welt!\");\n```\n\nSpeichern Sie dies als `hello.hml` und fhren Sie es aus:\n\n```bash\n./hemlock hello.hml\n```\n\n**Wichtige Punkte:**\n- `print()` ist eine eingebaute Funktion, die auf stdout ausgibt\n- Zeichenketten werden in doppelte Anfhrungszeichen eingeschlossen\n- Semikolons sind **obligatorisch**\n\n## Variablen und Typen\n\n### Variablen deklarieren\n\n```hemlock\n// Einfache Variablendeklaration\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\nprint(x);      // 42\nprint(name);   // Alice\nprint(pi);     // 3.14159\n```\n\n### Typannotationen\n\nWhrend Typen standardmig abgeleitet werden, knnen Sie explizit sein:\n\n```hemlock\nlet age: i32 = 30;\nlet height: f64 = 5.9;\nlet initial: rune = 'A';\nlet active: bool = true;\n```\n\n### Typinferenz\n\nHemlock leitet Typen basierend auf Werten ab:\n\n```hemlock\nlet small = 42;              // i32 (passt in 32-Bit)\nlet large = 5000000000;      // i64 (zu gro fr i32)\nlet decimal = 3.14;          // f64 (Standard fr Gleitkomma)\nlet text = \"hallo\";          // string\nlet flag = true;             // bool\n```\n\n### Typprfung\n\n```hemlock\n// Typen mit typeof() prfen\nprint(typeof(42));        // \"i32\"\nprint(typeof(3.14));      // \"f64\"\nprint(typeof(\"hallo\"));   // \"string\"\nprint(typeof(true));      // \"bool\"\nprint(typeof(null));      // \"null\"\n```\n\n## Arithmetik und Operationen\n\n### Grundlegende Arithmetik\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13\nprint(a - b);   // 7\nprint(a * b);   // 30\nprint(a / b);   // 3 (Ganzzahldivision)\nprint(a == b);  // false\nprint(a > b);   // true\n```\n\n### Typpromotion\n\nBeim Mischen von Typen frdert Hemlock zum greren/genaueren Typ:\n\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result ist f64 (10.0 + 3.5 = 13.5)\n\nprint(result);       // 13.5\nprint(typeof(result)); // \"f64\"\n```\n\n### Bitweise Operationen\n\n```hemlock\nlet a = 12;  // 1100 in Binr\nlet b = 10;  // 1010 in Binr\n\nprint(a & b);   // 8  (UND)\nprint(a | b);   // 14 (ODER)\nprint(a ^ b);   // 6  (XOR)\nprint(a << 1);  // 24 (Linksverschiebung)\nprint(a >> 1);  // 6  (Rechtsverschiebung)\nprint(~a);      // -13 (NICHT)\n```\n\n## Kontrollfluss\n\n### If-Anweisungen\n\n```hemlock\nlet x = 10;\n\nif (x > 0) {\n    print(\"positiv\");\n} else if (x < 0) {\n    print(\"negativ\");\n} else {\n    print(\"null\");\n}\n```\n\n**Hinweis:** Geschweifte Klammern sind **immer erforderlich**, auch fr einzelne Anweisungen.\n\n### While-Schleifen\n\n```hemlock\nlet count = 0;\nwhile (count < 5) {\n    print(`Zhler: ${count}`);\n    count = count + 1;\n}\n```\n\n### For-Schleifen\n\n```hemlock\n// C-hnliche For-Schleife\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n\n// For-in-Schleife (Arrays)\nlet items = [10, 20, 30, 40];\nfor (let item in items) {\n    print(`Element: ${item}`);\n}\n```\n\n### Switch-Anweisungen\n\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n        print(\"Montag\");\n        break;\n    case 2:\n        print(\"Dienstag\");\n        break;\n    case 3:\n        print(\"Mittwoch\");\n        break;\n    default:\n        print(\"Anderer Tag\");\n        break;\n}\n```\n\n### Break und Continue\n\n```hemlock\n// Break: Schleife vorzeitig verlassen\nlet i = 0;\nwhile (i < 10) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// Gibt aus: 0, 1, 2, 3, 4\n\n// Continue: zur nchsten Iteration springen\nfor (let j = 0; j < 5; j = j + 1) {\n    if (j == 2) {\n        continue;\n    }\n    print(j);\n}\n// Gibt aus: 0, 1, 3, 4\n```\n\n## Funktionen\n\n### Benannte Funktionen\n\n```hemlock\nfn greet(name: string): string {\n    return \"Hallo, \" + name + \"!\";\n}\n\nlet message = greet(\"Alice\");\nprint(message);  // \"Hallo, Alice!\"\n```\n\n### Anonyme Funktionen\n\n```hemlock\nlet add = fn(a, b) {\n    return a + b;\n};\n\nprint(add(5, 3));  // 8\n```\n\n### Rekursion\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### Closures\n\nFunktionen erfassen ihre Umgebung:\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n### Funktionen hherer Ordnung\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 21);\nprint(result);  // 42\n```\n\n## Zeichenketten und Runen\n\n### Grundlagen von Zeichenketten\n\nZeichenketten sind **vernderbar** und **UTF-8**:\n\n```hemlock\nlet s = \"hallo\";\nprint(s.length);      // 5 (Zeichenanzahl)\nprint(s.byte_length); // 5 (Byteanzahl)\n\n// Vernderung\ns[0] = 'H';\nprint(s);  // \"Hallo\"\n```\n\n### Zeichenketten-Methoden\n\n```hemlock\nlet text = \"  Hallo, Welt!  \";\n\n// Gro-/Kleinschreibung\nprint(text.to_upper());  // \"  HALLO, WELT!  \"\nprint(text.to_lower());  // \"  hallo, welt!  \"\n\n// Trimmen\nprint(text.trim());      // \"Hallo, Welt!\"\n\n// Teilstring-Extraktion\nlet hello = text.substr(2, 5);  // \"Hallo\"\nlet world = text.slice(9, 13);  // \"Welt\"\n\n// Suchen\nlet pos = text.find(\"Welt\");    // 9\nlet has = text.contains(\"o\");   // true\n\n// Aufteilen\nlet parts = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\n\n// Ersetzen\nlet s = \"hallo welt\".replace(\"welt\", \"dort\");\nprint(s);  // \"hallo dort\"\n```\n\n### Runen (Unicode-Codepunkte)\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '';\n\nprint(ch);      // 'A'\nprint(emoji);   // U+1F680\n\n// Rune + String-Verkettung\nlet msg = '>' + \" Wichtig\";\nprint(msg);  // \"> Wichtig\"\n\n// Zwischen Rune und Integer konvertieren\nlet code: i32 = ch;     // 65 (ASCII-Code)\nlet r: rune = 128640;   // U+1F680 ()\n```\n\n## Arrays\n\n### Array-Grundlagen\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Elemente ndern\nnumbers[2] = 99;\nprint(numbers[2]);  // 99\n```\n\n### Array-Methoden\n\n```hemlock\nlet arr = [10, 20, 30];\n\n// Am Ende hinzufgen/entfernen\narr.push(40);           // [10, 20, 30, 40]\nlet last = arr.pop();   // 40, arr ist jetzt [10, 20, 30]\n\n// Am Anfang hinzufgen/entfernen\narr.unshift(5);         // [5, 10, 20, 30]\nlet first = arr.shift(); // 5, arr ist jetzt [10, 20, 30]\n\n// An Index einfgen/entfernen\narr.insert(1, 15);      // [10, 15, 20, 30]\nlet removed = arr.remove(2);  // 20\n\n// Suchen\nlet index = arr.find(15);     // 1\nlet has = arr.contains(10);   // true\n\n// Slice\nlet slice = arr.slice(0, 2);  // [10, 15]\n\n// Zu String verbinden\nlet text = arr.join(\", \");    // \"10, 15, 30\"\n```\n\n### Iteration\n\n```hemlock\nlet items = [\"apfel\", \"banane\", \"kirsche\"];\n\n// For-in-Schleife\nfor (let item in items) {\n    print(item);\n}\n\n// Manuelle Iteration\nlet i = 0;\nwhile (i < items.length) {\n    print(items[i]);\n    i = i + 1;\n}\n```\n\n## Objekte\n\n### Objekt-Literale\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nprint(person.age);   // 30\n\n// Felder hinzufgen/ndern\nperson.email = \"alice@example.com\";\nperson.age = 31;\n```\n\n### Methoden und `self`\n\n```hemlock\nlet calculator = {\n    value: 0,\n    add: fn(x) {\n        self.value = self.value + x;\n    },\n    get: fn() {\n        return self.value;\n    }\n};\n\ncalculator.add(10);\ncalculator.add(5);\nprint(calculator.get());  // 15\n```\n\n### Typdefinitionen (Duck Typing)\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,  // Optional mit Standard\n}\n\nlet p = { name: \"Bob\", age: 25 };\nlet typed: Person = p;  // Duck Typing validiert Struktur\n\nprint(typeof(typed));   // \"Person\"\nprint(typed.active);    // true (Standard angewendet)\n```\n\n### JSON-Serialisierung\n\n```hemlock\nlet obj = { x: 10, y: 20, name: \"test\" };\n\n// Objekt zu JSON\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// JSON zu Objekt\nlet restored = json.deserialize();\nprint(restored.name);  // \"test\"\n```\n\n## Speicherverwaltung\n\n### Sichere Puffer (Empfohlen)\n\n```hemlock\n// Puffer allokieren\nlet buf = buffer(10);\nprint(buf.length);    // 10\nprint(buf.capacity);  // 10\n\n// Werte setzen (mit Grenzprfung)\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Werte zugreifen\nprint(buf[0]);  // 65\n\n// Muss freigegeben werden, wenn fertig\nfree(buf);\n```\n\n### Rohe Zeiger (Fortgeschritten)\n\n```hemlock\n// Rohen Speicher allokieren\nlet ptr = alloc(100);\n\n// Mit Nullen fllen\nmemset(ptr, 0, 100);\n\n// Daten kopieren\nlet src = alloc(50);\nmemcpy(ptr, src, 50);\n\n// Beide freigeben\nfree(src);\nfree(ptr);\n```\n\n### Speicherfunktionen\n\n```hemlock\n// Neu allokieren\nlet p = alloc(64);\np = realloc(p, 128);  // Auf 128 Bytes vergrern\nfree(p);\n\n// Typisierte Allokation (zuknftig)\n// let arr = talloc(i32, 100);  // Array von 100 i32s\n```\n\n## Fehlerbehandlung\n\n### Try/Catch\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"Division durch Null\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Fehler: \" + e);\n}\n// Ausgabe: Fehler: Division durch Null\n```\n\n### Finally-Block\n\n```hemlock\nlet file = null;\n\ntry {\n    file = open(\"daten.txt\", \"r\");\n    let content = file.read();\n    print(content);\n} catch (e) {\n    print(\"Fehler: \" + e);\n} finally {\n    // Wird immer ausgefhrt\n    if (file != null) {\n        file.close();\n    }\n}\n```\n\n### Objekte werfen\n\n```hemlock\ntry {\n    throw { code: 404, message: \"Nicht gefunden\" };\n} catch (e) {\n    print(`Fehler ${e.code}: ${e.message}`);\n}\n// Ausgabe: Fehler 404: Nicht gefunden\n```\n\n### Panic (Nicht behebbare Fehler)\n\n```hemlock\nfn validate(x) {\n    if (x < 0) {\n        panic(\"x muss nicht-negativ sein\");\n    }\n    return x * 2;\n}\n\nvalidate(-5);  // Programm beendet mit: panic: x muss nicht-negativ sein\n```\n\n## Datei-I/O\n\n### Dateien lesen\n\n```hemlock\n// Ganze Datei lesen\nlet f = open(\"daten.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n\n// Bestimmte Anzahl Bytes lesen\nlet f2 = open(\"daten.txt\", \"r\");\nlet chunk = f2.read(100);  // 100 Bytes lesen\nf2.close();\n```\n\n### Dateien schreiben\n\n```hemlock\n// Text schreiben\nlet f = open(\"ausgabe.txt\", \"w\");\nf.write(\"Hallo, Datei!\\n\");\nf.write(\"Zweite Zeile\\n\");\nf.close();\n\n// An Datei anhngen\nlet f2 = open(\"ausgabe.txt\", \"a\");\nf2.write(\"Angehngte Zeile\\n\");\nf2.close();\n```\n\n### Binr-I/O\n\n```hemlock\n// Binrdaten schreiben\nlet buf = buffer(256);\nbuf[0] = 255;\nbuf[1] = 128;\n\nlet f = open(\"daten.bin\", \"w\");\nf.write_bytes(buf);\nf.close();\n\n// Binrdaten lesen\nlet f2 = open(\"daten.bin\", \"r\");\nlet data = f2.read_bytes(256);\nprint(data[0]);  // 255\nf2.close();\n\nfree(buf);\nfree(data);\n```\n\n### Dateieigenschaften\n\n```hemlock\nlet f = open(\"/pfad/zur/datei.txt\", \"r\");\n\nprint(f.path);    // \"/pfad/zur/datei.txt\"\nprint(f.mode);    // \"r\"\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n## Alles zusammenfgen\n\nLassen Sie uns ein einfaches Wortzhler-Programm erstellen:\n\n```hemlock\n// wordcount.hml - Wrter in einer Datei zhlen\n\nfn count_words(filename: string): i32 {\n    let file = null;\n    let count = 0;\n\n    try {\n        file = open(filename, \"r\");\n        let content = file.read();\n\n        // Nach Leerzeichen aufteilen und zhlen\n        let words = content.split(\" \");\n        count = words.length;\n\n    } catch (e) {\n        print(\"Fehler beim Lesen der Datei: \" + e);\n        return -1;\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n\n    return count;\n}\n\n// Hauptprogramm\nif (args.length < 2) {\n    print(\"Verwendung: \" + args[0] + \" <dateiname>\");\n} else {\n    let filename = args[1];\n    let words = count_words(filename);\n\n    if (words >= 0) {\n        print(`Wortanzahl: ${words}`);\n    }\n}\n```\n\nAusfhren mit:\n```bash\n./hemlock wordcount.hml daten.txt\n```\n\n## Nchste Schritte\n\nHerzlichen Glckwunsch! Sie haben die Grundlagen von Hemlock gelernt. Hier ist, was Sie als Nchstes erkunden knnen:\n\n- [Async & Nebenlufigkeit](#advanced-async-concurrency) - Echtes Multi-Threading\n- [FFI](#advanced-ffi) - C-Funktionen aufrufen\n- [Signalverarbeitung](#advanced-signals) - Prozesssignale\n- [API-Referenz](#reference-builtins) - Vollstndige API-Dokumentation\n- [Beispiele](../../examples/) - Weitere praxisnahe Programme\n\n## bungsaufgaben\n\nVersuchen Sie, diese Programme zu erstellen, um zu ben:\n\n1. **Taschenrechner**: Implementieren Sie einen einfachen Rechner mit +, -, *, /\n2. **Dateikopierer**: Kopieren Sie eine Datei in eine andere\n3. **Fibonacci**: Generieren Sie Fibonacci-Zahlen\n4. **JSON-Parser**: Lesen und parsen Sie JSON-Dateien\n5. **Textprozessor**: Suchen und ersetzen Sie Text in Dateien\n\nViel Spa beim Programmieren mit Hemlock! \n"}, "Sprachhandbuch -> Arrays": {"id": "language-guide-arrays", "content": "# Arrays\n\nHemlock bietet **dynamische Arrays** mit umfassenden Methoden zur Datenmanipulation und -verarbeitung. Arrays knnen gemischte Typen enthalten und wachsen bei Bedarf automatisch.\n\n## bersicht\n\n```hemlock\n// Array-Literale\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Gemischte Typen erlaubt\nlet mixed = [1, \"hello\", true, null];\n\n// Dynamische Grenanpassung\narr.push(6);           // Wchst automatisch\narr.push(7);\nprint(arr.length);     // 7\n```\n\n## Array-Literale\n\n### Grundlegende Syntax\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet strings = [\"apple\", \"banana\", \"cherry\"];\nlet booleans = [true, false, true];\n```\n\n### Leere Arrays\n\n```hemlock\nlet arr = [];  // Leeres Array\n\n// Elemente spter hinzufgen\narr.push(1);\narr.push(2);\narr.push(3);\n```\n\n### Gemischte Typen\n\nArrays knnen verschiedene Typen enthalten:\n\n```hemlock\nlet mixed = [\n    42,\n    \"hello\",\n    true,\n    null,\n    [1, 2, 3],\n    { x: 10, y: 20 }\n];\n\nprint(mixed[0]);  // 42\nprint(mixed[1]);  // \"hello\"\nprint(mixed[4]);  // [1, 2, 3] (verschachteltes Array)\n```\n\n### Verschachtelte Arrays\n\n```hemlock\nlet matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\nprint(matrix[0][0]);  // 1\nprint(matrix[1][2]);  // 6\nprint(matrix[2][1]);  // 8\n```\n\n### Typisierte Arrays\n\nArrays knnen Typannotationen haben, um Elementtypen zu erzwingen:\n\n```hemlock\n// Typisierte Array-Syntax\nlet nums: array<i32> = [1, 2, 3, 4, 5];\nlet names: array<string> = [\"Alice\", \"Bob\", \"Carol\"];\nlet flags: array<bool> = [true, false, true];\n\n// Typberprfung zur Laufzeit\nlet valid: array<i32> = [1, 2, 3];       // OK\nlet invalid: array<i32> = [1, \"two\", 3]; // Laufzeitfehler: Typkonflikt\n\n// Verschachtelte typisierte Arrays\nlet matrix: array<array<i32>> = [\n    [1, 2, 3],\n    [4, 5, 6]\n];\n```\n\n**Typannotations-Verhalten:**\n- Elemente werden beim Hinzufgen zum Array typberprft\n- Typkonflikte verursachen Laufzeitfehler\n- Ohne Typannotation akzeptieren Arrays gemischte Typen\n\n## Indizierung\n\n### Elemente lesen\n\nNullbasierter Zugriff:\n\n```hemlock\nlet arr = [10, 20, 30, 40, 50];\n\nprint(arr[0]);  // 10 (erstes Element)\nprint(arr[4]);  // 50 (letztes Element)\n\n// Zugriff auerhalb der Grenzen gibt null zurck (kein Fehler)\nprint(arr[10]);  // null\n```\n\n### Elemente schreiben\n\n```hemlock\nlet arr = [1, 2, 3];\n\narr[0] = 10;    // Bestehendes ndern\narr[1] = 20;\nprint(arr);     // [10, 20, 3]\n\n// Kann ber aktuelle Lnge hinaus zuweisen (Array wchst)\narr[5] = 60;    // Erstellt [10, 20, 3, null, null, 60]\n```\n\n### Negative Indizes\n\n**Nicht untersttzt** - Verwende nur positive Indizes:\n\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr[-1]);  // FEHLER oder undefiniertes Verhalten\n\n// Verwende length fr letztes Element\nprint(arr[arr.length - 1]);  // 3\n```\n\n## Eigenschaften\n\n### `.length`-Eigenschaft\n\nGibt die Anzahl der Elemente zurck:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);  // 5\n\n// Leeres Array\nlet empty = [];\nprint(empty.length);  // 0\n\n// Nach nderungen\narr.push(6);\nprint(arr.length);  // 6\n```\n\n## Array-Methoden\n\nHemlock bietet 18 Array-Methoden fr umfassende Manipulation.\n\n### Stack-Operationen\n\n**`push(value)`** - Element am Ende hinzufgen:\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\n\nprint(arr.length);     // 5\n```\n\n**`pop()`** - Letztes Element entfernen und zurckgeben:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet last = arr.pop();  // Gibt 5 zurck, arr ist jetzt [1, 2, 3, 4]\n\nprint(last);           // 5\nprint(arr.length);     // 4\n```\n\n### Queue-Operationen\n\n**`shift()`** - Erstes Element entfernen und zurckgeben:\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();   // Gibt 1 zurck, arr ist jetzt [2, 3]\n\nprint(first);              // 1\nprint(arr);                // [2, 3]\n```\n\n**`unshift(value)`** - Element am Anfang hinzufgen:\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);            // [1, 2, 3]\narr.unshift(0);            // [0, 1, 2, 3]\n```\n\n### Einfge- und Entfernungsoperationen\n\n**`insert(index, value)`** - Element an Index einfgen:\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // 3 an Index 2 einfgen: [1, 2, 3, 4, 5]\n\narr.insert(0, 0);      // Am Anfang einfgen: [0, 1, 2, 3, 4, 5]\n```\n\n**`remove(index)`** - Element an Index entfernen und zurckgeben:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(2);  // Gibt 3 zurck, arr ist jetzt [1, 2, 4, 5]\n\nprint(removed);               // 3\nprint(arr);                   // [1, 2, 4, 5]\n```\n\n### Suchoperationen\n\n**`find(value)`** - Erstes Vorkommen finden:\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2 (Index des ersten Vorkommens)\nlet idx2 = arr.find(99);     // -1 (nicht gefunden)\n\n// Funktioniert mit jedem Typ\nlet words = [\"apple\", \"banana\", \"cherry\"];\nlet idx3 = words.find(\"banana\");  // 1\n```\n\n**`contains(value)`** - Prfen ob Array Wert enthlt:\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n```\n\n### Extraktionsoperationen\n\n**`slice(start, end)`** - Teilarray extrahieren (Ende exklusiv):\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4] (Indizes 1, 2, 3)\nlet first = arr.slice(0, 2); // [1, 2]\n\n// Original unverndert\nprint(arr);                  // [1, 2, 3, 4, 5]\n```\n\n**`first()`** - Erstes Element holen (ohne Entfernen):\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1 (ohne Entfernen)\nprint(arr);                  // [1, 2, 3] (unverndert)\n```\n\n**`last()`** - Letztes Element holen (ohne Entfernen):\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3 (ohne Entfernen)\nprint(arr);                  // [1, 2, 3] (unverndert)\n```\n\n### Transformationsoperationen\n\n**`reverse()`** - Array an Ort und Stelle umkehren:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\n\nprint(arr);                  // [5, 4, 3, 2, 1] (gendert)\n```\n\n**`join(delimiter)`** - Elemente zu String verbinden:\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Funktioniert mit gemischten Typen\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n```\n\n**`concat(other)`** - Mit anderem Array verketten:\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (neues Array)\n\n// Originale unverndert\nprint(a);                    // [1, 2, 3]\nprint(b);                    // [4, 5, 6]\n```\n\n### Hilfsoperationen\n\n**`clear()`** - Alle Elemente entfernen:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();                 // []\n\nprint(arr.length);           // 0\nprint(arr);                  // []\n```\n\n## Methodenverkettung\n\nMethoden, die Arrays oder Werte zurckgeben, ermglichen Verkettung:\n\n```hemlock\nlet result = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);  // [3, 4, 5]\n\nlet text = [\"apple\", \"banana\", \"cherry\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\nlet numbers = [5, 3, 8, 1, 9]\n    .slice(1, 4)\n    .concat([10, 11]);  // [3, 8, 1, 10, 11]\n```\n\n## Vollstndige Methodenreferenz\n\n| Methode | Parameter | Rckgabe | Mutiert | Beschreibung |\n|--------|-----------|---------|---------|-------------|\n| `push(value)` | any | void | Ja | Element am Ende hinzufgen |\n| `pop()` | - | any | Ja | Letztes entfernen und zurckgeben |\n| `shift()` | - | any | Ja | Erstes entfernen und zurckgeben |\n| `unshift(value)` | any | void | Ja | Element am Anfang hinzufgen |\n| `insert(index, value)` | i32, any | void | Ja | An Index einfgen |\n| `remove(index)` | i32 | any | Ja | An Index entfernen und zurckgeben |\n| `find(value)` | any | i32 | Nein | Erstes Vorkommen finden (-1 wenn nicht gefunden) |\n| `contains(value)` | any | bool | Nein | Prfen ob Wert enthalten |\n| `slice(start, end)` | i32, i32 | array | Nein | Teilarray extrahieren (neues Array) |\n| `join(delimiter)` | string | string | Nein | Zu String verbinden |\n| `concat(other)` | array | array | Nein | Verketten (neues Array) |\n| `reverse()` | - | void | Ja | An Ort und Stelle umkehren |\n| `first()` | - | any | Nein | Erstes Element holen |\n| `last()` | - | any | Nein | Letztes Element holen |\n| `clear()` | - | void | Ja | Alle Elemente entfernen |\n| `map(callback)` | fn | array | Nein | Jedes Element transformieren |\n| `filter(predicate)` | fn | array | Nein | Passende Elemente auswhlen |\n| `reduce(callback, initial)` | fn, any | any | Nein | Auf einzelnen Wert reduzieren |\n\n## Implementierungsdetails\n\n### Speichermodell\n\n- **Heap-allokiert** - Dynamische Kapazitt\n- **Automatisches Wachstum** - Verdoppelt Kapazitt bei berschreitung\n- **Kein automatisches Schrumpfen** - Kapazitt nimmt nicht ab\n- **Keine Grenzprfung bei Indizierung** - Verwende Methoden fr Sicherheit\n\n### Kapazittsverwaltung\n\n```hemlock\nlet arr = [];  // Anfangskapazitt: 0\n\narr.push(1);   // Wchst auf Kapazitt 1\narr.push(2);   // Wchst auf Kapazitt 2\narr.push(3);   // Wchst auf Kapazitt 4 (verdoppelt)\narr.push(4);   // Immer noch Kapazitt 4\narr.push(5);   // Wchst auf Kapazitt 8 (verdoppelt)\n```\n\n### Wertvergleich\n\n`find()` und `contains()` verwenden Wertgleichheit:\n\n```hemlock\n// Primitive: Vergleich nach Wert\nlet arr = [1, 2, 3];\narr.contains(2);  // true\n\n// Strings: Vergleich nach Wert\nlet words = [\"hello\", \"world\"];\nwords.contains(\"hello\");  // true\n\n// Objekte: Vergleich nach Referenz\nlet obj1 = { x: 10 };\nlet obj2 = { x: 10 };\nlet arr2 = [obj1];\narr2.contains(obj1);  // true (gleiche Referenz)\narr2.contains(obj2);  // false (verschiedene Referenz)\n```\n\n## Hufige Muster\n\n### Funktionale Operationen (map/filter/reduce)\n\nArrays haben eingebaute `map`, `filter` und `reduce` Methoden:\n\n```hemlock\n// map - jedes Element transformieren\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = numbers.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\n// filter - passende Elemente auswhlen\nlet evens = numbers.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4]\n\n// reduce - auf einzelnen Wert akkumulieren\nlet sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\n// Funktionale Operationen verketten\nlet result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]\n    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]\n    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220\n```\n\n### Muster: Array als Stack\n\n```hemlock\nlet stack = [];\n\n// Auf Stack legen\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Vom Stack nehmen\nlet top = stack.pop();    // 3\nlet next = stack.pop();   // 2\n```\n\n### Muster: Array als Queue\n\n```hemlock\nlet queue = [];\n\n// Einreihen (am Ende hinzufgen)\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Ausreihen (vom Anfang entfernen)\nlet first = queue.shift();   // 1\nlet second = queue.shift();  // 2\n```\n\n## Best Practices\n\n1. **Verwende Methoden statt direkter Indizierung** - Grenzprfung und Klarheit\n2. **Pruefe Grenzen** - Direkte Indizierung prft keine Grenzen\n3. **Bevorzuge unvernderliche Operationen** - Verwende `slice()` und `concat()` statt Mutation\n4. **Initialisiere mit Kapazitt** - Wenn du die Gre kennst (derzeit nicht untersttzt)\n5. **Verwende `contains()` fr Zugehrigkeit** - Klarer als manuelle Schleifen\n6. **Verkette Methoden** - Lesbarer als verschachtelte Aufrufe\n\n## Hufige Fallstricke\n\n### Fallstrick: Direkter Index auerhalb der Grenzen\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// Keine Grenzprfung!\narr[10] = 99;  // Erstellt duenn besetztes Array mit nulls\nprint(arr.length);  // 11 (nicht 3!)\n\n// Besser: Verwende push() oder pruefe Lnge\nif (arr.length <= 10) {\n    arr.push(99);\n}\n```\n\n### Fallstrick: Mutation vs. Neues Array\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// Mutiert Original\narr.reverse();\nprint(arr);  // [3, 2, 1]\n\n// Gibt neues Array zurck\nlet sub = arr.slice(0, 2);\nprint(arr);  // [3, 2, 1] (unverndert)\nprint(sub);  // [3, 2]\n```\n\n### Fallstrick: Referenzgleichheit\n\n```hemlock\nlet obj = { x: 10 };\nlet arr = [obj];\n\n// Gleiche Referenz: true\narr.contains(obj);  // true\n\n// Verschiedene Referenz: false\narr.contains({ x: 10 });  // false (verschiedenes Objekt)\n```\n\n### Fallstrick: Langlebige Arrays\n\n```hemlock\n// Arrays im lokalen Scope werden automatisch freigegeben, aber globale/langlebige Arrays brauchen Aufmerksamkeit\nlet global_cache = [];  // Modulebene, existiert bis Programmende\n\nfn add_to_cache(item) {\n    global_cache.push(item);  // Wchst unbegrenzt\n}\n\n// Fr langlebige Daten, erwaege:\n// - Array periodisch leeren: global_cache.clear();\n// - Frueh freigeben wenn fertig: free(global_cache);\n```\n\n## Beispiele\n\n### Beispiel: Array-Statistiken\n\n```hemlock\nfn mean(arr) {\n    let sum = 0;\n    let i = 0;\n    while (i < arr.length) {\n        sum = sum + arr[i];\n        i = i + 1;\n    }\n    return sum / arr.length;\n}\n\nfn max(arr) {\n    if (arr.length == 0) {\n        return null;\n    }\n\n    let max_val = arr[0];\n    let i = 1;\n    while (i < arr.length) {\n        if (arr[i] > max_val) {\n            max_val = arr[i];\n        }\n        i = i + 1;\n    }\n    return max_val;\n}\n\nlet numbers = [3, 7, 2, 9, 1];\nprint(mean(numbers));  // 4.4\nprint(max(numbers));   // 9\n```\n\n### Beispiel: Array-Deduplizierung\n\n```hemlock\nfn unique(arr) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (!result.contains(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet numbers = [1, 2, 2, 3, 1, 4, 3, 5];\nlet uniq = unique(numbers);  // [1, 2, 3, 4, 5]\n```\n\n### Beispiel: Array-Chunking\n\n```hemlock\nfn chunk(arr, size) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        let chunk = arr.slice(i, i + size);\n        result.push(chunk);\n        i = i + size;\n    }\n\n    return result;\n}\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8];\nlet chunks = chunk(numbers, 3);\n// [[1, 2, 3], [4, 5, 6], [7, 8]]\n```\n\n### Beispiel: Array-Flachung\n\n```hemlock\nfn flatten(arr) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        if (typeof(arr[i]) == \"array\") {\n            // Verschachteltes Array - flach machen\n            let nested = flatten(arr[i]);\n            let j = 0;\n            while (j < nested.length) {\n                result.push(nested[j]);\n                j = j + 1;\n            }\n        } else {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet nested = [1, [2, 3], [4, [5, 6]], 7];\nlet flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]\n```\n\n### Beispiel: Sortierung (Bubble Sort)\n\n```hemlock\nfn sort(arr) {\n    let n = arr.length;\n    let i = 0;\n\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (arr[j] > arr[j + 1]) {\n                // Tauschen\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers);  // Aendert an Ort und Stelle\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## Einschrnkungen\n\nAktuelle Einschrnkungen:\n\n- **Keine Grenzprfung bei Indizierung** - Direkter Zugriff ist ungeprft\n- **Referenzgleichheit fr Objekte** - `find()` und `contains()` verwenden Referenzvergleich\n- **Keine Array-Destrukturierung** - Keine `let [a, b] = arr` Syntax\n- **Kein Spread-Operator** - Keine `[...arr1, ...arr2]` Syntax\n\n**Hinweis:** Arrays sind referenzgezhlt und werden automatisch freigegeben, wenn der Scope endet. Siehe [Speicherverwaltung](memory.md#internal-reference-counting) fr Details.\n\n## Verwandte Themen\n\n- [Strings](#language-guide-strings) - String-Methoden hnlich wie Array-Methoden\n- [Objekte](#language-guide-objects) - Arrays sind auch objektaehnlich\n- [Funktionen](#language-guide-functions) - Hhere Ordnung Funktionen mit Arrays\n- [Kontrollfluss](#language-guide-control-flow) - ber Arrays iterieren\n\n## Siehe auch\n\n- **Dynamische Grenanpassung**: Arrays wachsen automatisch mit Kapazittsverdopplung\n- **Methoden**: 18 umfassende Methoden zur Manipulation inklusive map/filter/reduce\n- **Speicher**: Siehe [Speicher](#language-guide-memory) fr Array-Allokationsdetails\n"}, "Sprachhandbuch -> Fehlerbehandlung": {"id": "language-guide-error-handling", "content": "# Fehlerbehandlung\n\nHemlock untersttzt ausnahmebasierte Fehlerbehandlung mit `try`, `catch`, `finally`, `throw` und `panic`. Diese Anleitung behandelt behebbare Fehler mit Ausnahmen und nicht behebbare Fehler mit panic.\n\n## berblick\n\n```hemlock\n// Grundlegende Fehlerbehandlung\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Fehler: \" + e);\n}\n\n// Mit Bereinigung\ntry {\n    process_file();\n} catch (e) {\n    print(\"Fehlgeschlagen: \" + e);\n} finally {\n    cleanup();\n}\n\n// Fehler werfen\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"Division durch Null\";\n    }\n    return a / b;\n}\n```\n\n## Try-Catch-Finally\n\n### Syntax\n\n**Einfaches try/catch:**\n```hemlock\ntry {\n    // riskanter Code\n} catch (e) {\n    // Fehler behandeln, e enthlt den geworfenen Wert\n}\n```\n\n**Try/finally:**\n```hemlock\ntry {\n    // riskanter Code\n} finally {\n    // wird immer ausgefhrt, auch wenn Ausnahme geworfen\n}\n```\n\n**Try/catch/finally:**\n```hemlock\ntry {\n    // riskanter Code\n} catch (e) {\n    // Fehler behandeln\n} finally {\n    // Bereinigungscode\n}\n```\n\n### Try-Block\n\nDer try-Block fhrt Anweisungen sequentiell aus:\n\n```hemlock\ntry {\n    print(\"Starte...\");\n    risky_operation();\n    print(\"Erfolg!\");  // Nur wenn keine Ausnahme\n}\n```\n\n**Verhalten:**\n- Fuehrt Anweisungen der Reihe nach aus\n- Wenn Ausnahme geworfen: springt zu `catch` oder `finally`\n- Wenn keine Ausnahme: fhrt `finally` aus (falls vorhanden), dann weiter\n\n### Catch-Block\n\nDer catch-Block empfaengt den geworfenen Wert:\n\n```hemlock\ntry {\n    throw \"hoppla\";\n} catch (error) {\n    print(\"Gefangen: \" + error);  // error = \"hoppla\"\n    // error nur hier zugnglich\n}\n// error hier nicht zugnglich\n```\n\n**Catch-Parameter:**\n- Empfaengt den geworfenen Wert (beliebiger Typ)\n- Auf den catch-Block beschrnkt\n- Kann beliebig benannt werden (konventionell `e`, `err` oder `error`)\n\n**Was Sie im catch tun knnen:**\n```hemlock\ntry {\n    risky_operation();\n} catch (e) {\n    // Fehler protokollieren\n    print(\"Fehler: \" + e);\n\n    // Gleichen Fehler erneut werfen\n    throw e;\n\n    // Anderen Fehler werfen\n    throw \"anderer Fehler\";\n\n    // Standardwert zurckgeben\n    return null;\n\n    // Behandeln und fortfahren\n    // (kein erneutes Werfen)\n}\n```\n\n### Finally-Block\n\nDer finally-Block wird **immer ausgefhrt**:\n\n```hemlock\ntry {\n    print(\"1: try-Block\");\n    throw \"Fehler\";\n} catch (e) {\n    print(\"2: catch-Block\");\n} finally {\n    print(\"3: finally-Block\");  // Wird immer ausgefhrt\n}\nprint(\"4: nach try/catch/finally\");\n\n// Ausgabe: 1: try-Block, 2: catch-Block, 3: finally-Block, 4: nach try/catch/finally\n```\n\n**Wann finally ausgefhrt wird:**\n- Nach dem try-Block (wenn keine Ausnahme)\n- Nach dem catch-Block (wenn Ausnahme gefangen)\n- Auch wenn try/catch `return`, `break` oder `continue` enthlt\n- Bevor der Kontrollfluss try/catch verlsst\n\n**Finally mit return:**\n```hemlock\nfn example() {\n    try {\n        return 1;  // Gibt 1 zurck nach finally-Ausfhrung\n    } finally {\n        print(\"bereinigung\");  // Wird vor Rckgabe ausgefhrt\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // Finally-return berschreibt - gibt 2 zurck\n    }\n}\n```\n\n**Finally mit Kontrollfluss:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) {\n            break;  // Bricht nach finally-Ausfhrung ab\n        }\n    } finally {\n        print(\"bereinigung \" + typeof(i));\n    }\n}\n```\n\n## Throw-Anweisung\n\n### Einfaches Throw\n\nJeden Wert als Ausnahme werfen:\n\n```hemlock\nthrow \"Fehlermeldung\";\nthrow 404;\nthrow { code: 500, message: \"Interner Fehler\" };\nthrow null;\nthrow [\"fehler\", \"details\"];\n```\n\n**Ausfhrung:**\n1. Wertet den Ausdruck aus\n2. Springt sofort zum nchsten umschliessenden `catch`\n3. Wenn kein `catch`, propagiert nach oben im Aufrufstapel\n\n### Fehler werfen\n\n```hemlock\nfn validate_age(age: i32) {\n    if (age < 0) {\n        throw \"Alter kann nicht negativ sein\";\n    }\n    if (age > 150) {\n        throw \"Alter ist unrealistisch\";\n    }\n}\n\ntry {\n    validate_age(-5);\n} catch (e) {\n    print(\"Validierungsfehler: \" + e);\n}\n```\n\n### Fehlerobjekte werfen\n\nStrukturierte Fehlerinformationen erstellen:\n\n```hemlock\nfn read_file(path: string) {\n    if (!file_exists(path)) {\n        throw {\n            type: \"FileNotFound\",\n            path: path,\n            message: \"Datei existiert nicht\"\n        };\n    }\n    // ... Datei lesen\n}\n\ntry {\n    read_file(\"missing.txt\");\n} catch (e) {\n    if (e.type == \"FileNotFound\") {\n        print(\"Datei nicht gefunden: \" + e.path);\n    }\n}\n```\n\n### Erneutes Werfen\n\nFehler fangen und erneut werfen:\n\n```hemlock\nfn wrapper() {\n    try {\n        risky_operation();\n    } catch (e) {\n        print(\"Fehler protokollieren: \" + e);\n        throw e;  // An Aufrufer erneut werfen\n    }\n}\n\ntry {\n    wrapper();\n} catch (e) {\n    print(\"In main gefangen: \" + e);\n}\n```\n\n## Nicht gefangene Ausnahmen\n\nWenn eine Ausnahme ohne gefangen zu werden bis zum Anfang des Aufrufstapels propagiert:\n\n```hemlock\nfn foo() {\n    throw \"nicht gefangen!\";\n}\n\nfoo();  // Stuerzt ab mit: Laufzeitfehler: nicht gefangen!\n```\n\n**Verhalten:**\n- Programm stuerzt ab\n- Gibt Fehlermeldung auf stderr aus\n- Beendet mit nicht-null Statuscode\n- Stack-Trace wird in zukuenftigen Versionen hinzugefgt\n\n## Panic - Nicht behebbare Fehler\n\n### Was ist Panic?\n\n`panic()` ist fr **nicht behebbare Fehler**, die das Programm sofort beenden sollen:\n\n```hemlock\npanic();                    // Standardmeldung: \"panic!\"\npanic(\"benutzerdefinierte Meldung\");    // Benutzerdefinierte Meldung\npanic(42);                  // Nicht-String-Werte werden ausgegeben\n```\n\n**Semantik:**\n- **Beendet sofort** das Programm mit Exit-Code 1\n- Gibt Fehlermeldung auf stderr aus: `panic: <meldung>`\n- **NICHT fangbar** mit try/catch\n- Fr Bugs und nicht behebbare Fehler verwenden\n\n### Panic vs. Throw\n\n```hemlock\n// throw - Behebbarer Fehler (kann gefangen werden)\ntry {\n    throw \"behebbarer Fehler\";\n} catch (e) {\n    print(\"Gefangen: \" + e);  // Erfolgreich gefangen\n}\n\n// panic - Nicht behebbarer Fehler (kann nicht gefangen werden)\ntry {\n    panic(\"nicht behebbarer Fehler\");  // Programm beendet sofort\n} catch (e) {\n    print(\"Das wird nie ausgefhrt\");       // Wird nie ausgefhrt\n}\n```\n\n### Wann Panic verwenden\n\n**Panic verwenden fr:**\n- **Bugs**: Unerreichbarer Code wurde erreicht\n- **Ungueltiger Zustand**: Datenstrukturkorruption erkannt\n- **Nicht behebbare Fehler**: Kritische Ressource nicht verfgbar\n- **Assertionsfehler**: Wenn `assert()` nicht ausreicht\n\n**Beispiele:**\n```hemlock\n// Unerreichbarer Code\nfn process_state(state: i32) {\n    if (state == 1) {\n        return \"ready\";\n    } else if (state == 2) {\n        return \"running\";\n    } else if (state == 3) {\n        return \"stopped\";\n    } else {\n        panic(\"ungueltiger Zustand: \" + typeof(state));  // Sollte nie passieren\n    }\n}\n\n// Kritische Ressourcenpruefung\nfn init_system() {\n    let config = read_file(\"config.json\");\n    if (config == null) {\n        panic(\"config.json nicht gefunden - kann nicht starten\");\n    }\n    // ...\n}\n\n// Datenstruktur-Invariante\nfn pop_stack(stack) {\n    if (stack.length == 0) {\n        panic(\"pop() auf leerem Stack aufgerufen\");\n    }\n    return stack.pop();\n}\n```\n\n### Wann NICHT Panic verwenden\n\n**Throw stattdessen verwenden fr:**\n- Benutzereingabe-Validierung\n- Datei nicht gefunden\n- Netzwerkfehler\n- Erwartete Fehlerbedingungen\n\n```hemlock\n// SCHLECHT: Panic fr erwartete Fehler\nfn divide(a, b) {\n    if (b == 0) {\n        panic(\"Division durch Null\");  // Zu hart\n    }\n    return a / b;\n}\n\n// GUT: Throw fr erwartete Fehler\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"Division durch Null\";  // Behebbar\n    }\n    return a / b;\n}\n```\n\n## Kontrollfluss-Interaktionen\n\n### Return innerhalb Try/Catch/Finally\n\n```hemlock\nfn example() {\n    try {\n        return 1;  // Gibt 1 zurck nach finally-Ausfhrung\n    } finally {\n        print(\"bereinigung\");\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // Finally-return berschreibt try-return - gibt 2 zurck\n    }\n}\n```\n\n**Regel:** Finally-Block-Rueckgabewerte ueberschreiben try/catch-Rueckgabewerte.\n\n### Break/Continue innerhalb Try/Catch/Finally\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) { break; }  // Bricht nach finally-Ausfhrung ab\n    } finally {\n        print(\"bereinigung \" + typeof(i));\n    }\n}\n```\n\n**Regel:** Break/continue werden nach dem finally-Block ausgefhrt.\n\n### Verschachteltes Try/Catch\n\n```hemlock\ntry {\n    try {\n        throw \"inner\";\n    } catch (e) {\n        print(\"Gefangen: \" + e);  // Gibt aus: Gefangen: inner\n        throw \"outer\";  // Anderen Fehler erneut werfen\n    }\n} catch (e) {\n    print(\"Gefangen: \" + e);  // Gibt aus: Gefangen: outer\n}\n```\n\n**Regel:** Verschachtelte try/catch-Blcke funktionieren wie erwartet, innere catches geschehen zuerst.\n\n## Gngige Muster\n\n### Muster: Ressourcenbereinigung\n\nImmer `finally` fr Bereinigung verwenden:\n\n```hemlock\nfn process_file(filename) {\n    let file = null;\n    try {\n        file = open(filename);\n        let content = file.read();\n        process(content);\n    } catch (e) {\n        print(\"Fehler beim Verarbeiten der Datei: \" + e);\n    } finally {\n        if (file != null) {\n            file.close();  // Schliesst immer, auch bei Fehler\n        }\n    }\n}\n```\n\n### Muster: Fehler-Wrapping\n\nNiedrigstufige Fehler mit Kontext umwickeln:\n\n```hemlock\nfn load_config(path) {\n    try {\n        let content = read_file(path);\n        return parse_json(content);\n    } catch (e) {\n        throw \"Fehler beim Laden der Konfiguration von \" + path + \": \" + e;\n    }\n}\n```\n\n### Muster: Fehlerwiederherstellung\n\nFallback bei Fehler bereitstellen:\n\n```hemlock\nfn safe_divide(a, b) {\n    try {\n        if (b == 0) {\n            throw \"Division durch Null\";\n        }\n        return a / b;\n    } catch (e) {\n        print(\"Fehler: \" + e);\n        return null;  // Fallback-Wert\n    }\n}\n```\n\n### Muster: Validierung\n\nAusnahmen fr Validierung verwenden:\n\n```hemlock\nfn validate_user(user) {\n    if (user.name == null || user.name == \"\") {\n        throw \"Name ist erforderlich\";\n    }\n    if (user.age < 0 || user.age > 150) {\n        throw \"Ungueltiges Alter\";\n    }\n    if (user.email == null || !user.email.contains(\"@\")) {\n        throw \"Ungueltige E-Mail\";\n    }\n}\n\ntry {\n    validate_user({ name: \"Alice\", age: -5, email: \"ungltig\" });\n} catch (e) {\n    print(\"Validierung fehlgeschlagen: \" + e);\n}\n```\n\n### Muster: Mehrere Fehlertypen\n\nFehlerobjekte verwenden, um Fehlertypen zu unterscheiden:\n\n```hemlock\nfn process_data(data) {\n    if (data == null) {\n        throw { type: \"NullData\", message: \"Daten sind null\" };\n    }\n\n    if (typeof(data) != \"array\") {\n        throw { type: \"TypeError\", message: \"Array erwartet\" };\n    }\n\n    if (data.length == 0) {\n        throw { type: \"EmptyData\", message: \"Array ist leer\" };\n    }\n\n    // ... verarbeiten\n}\n\ntry {\n    process_data(null);\n} catch (e) {\n    if (e.type == \"NullData\") {\n        print(\"Keine Daten bereitgestellt\");\n    } else if (e.type == \"TypeError\") {\n        print(\"Falscher Datentyp: \" + e.message);\n    } else {\n        print(\"Fehler: \" + e.message);\n    }\n}\n```\n\n## Best Practices\n\n1. **Ausnahmen fr Ausnahmefaelle verwenden** - Nicht fr normalen Kontrollfluss\n2. **Aussagekraeftige Fehler werfen** - Strings oder Objekte mit Kontext verwenden\n3. **Immer finally fr Bereinigung verwenden** - Stellt sicher, dass Ressourcen freigegeben werden\n4. **Nicht fangen und ignorieren** - Mindestens den Fehler protokollieren\n5. **Bei Bedarf erneut werfen** - Aufrufer behandeln lassen, wenn Sie nicht knnen\n6. **Panic fr Bugs** - Panic fr nicht behebbare Fehler verwenden\n7. **Ausnahmen dokumentieren** - Klar machen, welche Funktionen werfen knnen\n\n## Hufige Fallstricke\n\n### Fallstrick: Fehler verschlucken\n\n```hemlock\n// SCHLECHT: Stilles Scheitern\ntry {\n    risky_operation();\n} catch (e) {\n    // Fehler ignoriert - stilles Scheitern\n}\n\n// GUT: Protokollieren oder behandeln\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Operation fehlgeschlagen: \" + e);\n    // Angemessen behandeln\n}\n```\n\n### Fallstrick: Finally-Ueberschreibung\n\n```hemlock\n// SCHLECHT: Finally berschreibt return\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        return 0;  // Gibt 0 zurck, nicht 42!\n    }\n}\n\n// GUT: Nicht in finally returnen\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        cleanup();  // Nur bereinigen, kein return\n    }\n}\n```\n\n### Fallstrick: Bereinigung vergessen\n\n```hemlock\n// SCHLECHT: Datei wird bei Fehler moeglicherweise nicht geschlossen\nfn process() {\n    let file = open(\"data.txt\");\n    let content = file.read();  // Kann werfen\n    file.close();  // Wird bei Fehler nie erreicht\n}\n\n// GUT: Finally verwenden\nfn process() {\n    let file = null;\n    try {\n        file = open(\"data.txt\");\n        let content = file.read();\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n}\n```\n\n### Fallstrick: Panic fr erwartete Fehler verwenden\n\n```hemlock\n// SCHLECHT: Panic fr erwarteten Fehler\nfn read_config(path) {\n    if (!file_exists(path)) {\n        panic(\"Konfigurationsdatei nicht gefunden\");  // Zu hart\n    }\n    return read_file(path);\n}\n\n// GUT: Throw fr erwarteten Fehler\nfn read_config(path) {\n    if (!file_exists(path)) {\n        throw \"Konfigurationsdatei nicht gefunden: \" + path;  // Behebbar\n    }\n    return read_file(path);\n}\n```\n\n## Beispiele\n\n### Beispiel: Grundlegende Fehlerbehandlung\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"Division durch Null\";\n    }\n    return a / b;\n}\n\ntry {\n    print(divide(10, 0));\n} catch (e) {\n    print(\"Fehler: \" + e);  // Gibt aus: Fehler: Division durch Null\n}\n```\n\n### Beispiel: Ressourcenverwaltung\n\n```hemlock\nfn copy_file(src, dst) {\n    let src_file = null;\n    let dst_file = null;\n\n    try {\n        src_file = open(src, \"r\");\n        dst_file = open(dst, \"w\");\n\n        let content = src_file.read();\n        dst_file.write(content);\n\n        print(\"Datei erfolgreich kopiert\");\n    } catch (e) {\n        print(\"Fehler beim Kopieren der Datei: \" + e);\n        throw e;  // Erneut werfen\n    } finally {\n        if (src_file != null) { src_file.close(); }\n        if (dst_file != null) { dst_file.close(); }\n    }\n}\n```\n\n### Beispiel: Verschachtelte Fehlerbehandlung\n\n```hemlock\nfn process_users(users) {\n    let success_count = 0;\n    let error_count = 0;\n\n    let i = 0;\n    while (i < users.length) {\n        try {\n            validate_user(users[i]);\n            save_user(users[i]);\n            success_count = success_count + 1;\n        } catch (e) {\n            print(\"Fehler beim Verarbeiten des Benutzers: \" + e);\n            error_count = error_count + 1;\n        }\n        i = i + 1;\n    }\n\n    print(\"Verarbeitet: \" + typeof(success_count) + \" erfolgreich, \" + typeof(error_count) + \" Fehler\");\n}\n```\n\n### Beispiel: Benutzerdefinierte Fehlertypen\n\n```hemlock\nfn create_error(type, message, details) {\n    return {\n        type: type,\n        message: message,\n        details: details,\n        toString: fn() {\n            return self.type + \": \" + self.message;\n        }\n    };\n}\n\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" && typeof(a) != \"f64\") {\n        throw create_error(\"TypeError\", \"a muss eine Zahl sein\", { value: a });\n    }\n    if (typeof(b) != \"i32\" && typeof(b) != \"f64\") {\n        throw create_error(\"TypeError\", \"b muss eine Zahl sein\", { value: b });\n    }\n    if (b == 0) {\n        throw create_error(\"DivisionByZero\", \"Division durch Null nicht mglich\", { a: a, b: b });\n    }\n    return a / b;\n}\n\ntry {\n    divide(10, 0);\n} catch (e) {\n    print(e.toString());\n    if (e.type == \"DivisionByZero\") {\n        print(\"Details: a=\" + typeof(e.details.a) + \", b=\" + typeof(e.details.b));\n    }\n}\n```\n\n### Beispiel: Wiederholungslogik\n\n```hemlock\nfn retry(operation, max_attempts) {\n    let attempt = 0;\n\n    while (attempt < max_attempts) {\n        try {\n            return operation();  // Erfolg!\n        } catch (e) {\n            attempt = attempt + 1;\n            if (attempt >= max_attempts) {\n                throw \"Operation fehlgeschlagen nach \" + typeof(max_attempts) + \" Versuchen: \" + e;\n            }\n            print(\"Versuch \" + typeof(attempt) + \" fehlgeschlagen, wiederhole...\");\n        }\n    }\n}\n\nfn unreliable_operation() {\n    // Simulierte unzuverlaessige Operation\n    if (random() < 0.7) {\n        throw \"Operation fehlgeschlagen\";\n    }\n    return \"Erfolg\";\n}\n\ntry {\n    let result = retry(unreliable_operation, 3);\n    print(result);\n} catch (e) {\n    print(\"Alle Wiederholungen fehlgeschlagen: \" + e);\n}\n```\n\n## Ausfuehrungsreihenfolge\n\nVerstndnis der Ausfuehrungsreihenfolge:\n\n```hemlock\ntry {\n    print(\"1: try-Block Start\");\n    throw \"fehler\";\n    print(\"2: nie erreicht\");\n} catch (e) {\n    print(\"3: catch-Block\");\n} finally {\n    print(\"4: finally-Block\");\n}\nprint(\"5: nach try/catch/finally\");\n\n// Ausgabe:\n// 1: try-Block Start\n// 3: catch-Block\n// 4: finally-Block\n// 5: nach try/catch/finally\n```\n\n## Aktuelle Einschrnkungen\n\n- **Kein Stack-Trace** - Nicht gefangene Ausnahmen zeigen keinen Stack-Trace (geplant)\n- **Einige Builtins beenden** - Einige eingebaute Funktionen rufen noch `exit()` statt zu werfen auf (wird berprft)\n- **Keine benutzerdefinierten Ausnahmetypen** - Jeder Wert kann geworfen werden, aber keine formale Ausnahmehierarchie\n\n## Verwandte Themen\n\n- [Functions](#language-guide-functions) - Ausnahmen und Funktionsrueckgaben\n- [Control Flow](#language-guide-control-flow) - Wie Ausnahmen den Kontrollfluss beeinflussen\n- [Memory](#language-guide-memory) - Finally fr Speicherbereinigung verwenden\n\n## Siehe auch\n\n- **Ausnahmesemantik**: Siehe CLAUDE.md Abschnitt \"Error Handling\"\n- **Panic vs. Throw**: Verschiedene Anwendungsfaelle fr verschiedene Fehlertypen\n- **Finally-Garantie**: Wird immer ausgefhrt, auch bei return/break/continue\n"}, "Sprachhandbuch -> Funktionen": {"id": "language-guide-functions", "content": "# Funktionen\n\nFunktionen in Hemlock sind **erstklassige Werte**, die Variablen zugewiesen, als Argumente bergeben und von anderen Funktionen zurckgegeben werden knnen. Diese Anleitung behandelt Funktionssyntax, Closures, Rekursion und fortgeschrittene Muster.\n\n## bersicht\n\n```hemlock\n// Benannte Funktionssyntax\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\n// Anonyme Funktion\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\n// Closures\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nprint(add5(3));  // 8\n```\n\n## Funktionsdeklaration\n\n### Benannte Funktionen\n\n```hemlock\nfn greet(name: string): string {\n    return \"Hello, \" + name;\n}\n\nlet msg = greet(\"Alice\");  // \"Hello, Alice\"\n```\n\n**Komponenten:**\n- `fn` - Funktionsschluesselwort\n- `greet` - Funktionsname\n- `(name: string)` - Parameter mit optionalen Typen\n- `: string` - Optionaler Rckgabetyp\n- `{ ... }` - Funktionskrper\n\n### Anonyme Funktionen\n\nFunktionen ohne Namen, die Variablen zugewiesen werden:\n\n```hemlock\nlet square = fn(x) {\n    return x * x;\n};\n\nprint(square(5));  // 25\n```\n\n**Benannt vs. Anonym:**\n```hemlock\n// Diese sind quivalent:\nfn add(a, b) { return a + b; }\n\nlet add = fn(a, b) { return a + b; };\n```\n\n**Hinweis:** Benannte Funktionen werden intern zu Variablenzuweisungen mit anonymen Funktionen umgewandelt.\n\n## Parameter\n\n### Grundlegende Parameter\n\n```hemlock\nfn example(a, b, c) {\n    return a + b + c;\n}\n\nlet result = example(1, 2, 3);  // 6\n```\n\n### Typannotationen\n\nOptionale Typannotationen fr Parameter:\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);      // OK\nadd(5, 10.5);    // Laufzeit-Typberprfung konvertiert zu f64\n```\n\n**Typberprfung:**\n- Parametertypen werden beim Aufruf berprft, wenn annotiert\n- Implizite Typkonvertierungen folgen Standard-Promotionsregeln\n- Typkonflikte verursachen Laufzeitfehler\n\n### Wertuebergabe (Pass-by-Value)\n\nAlle Argumente werden **kopiert** (Wertuebergabe):\n\n```hemlock\nfn modify(x) {\n    x = 100;  // Aendert nur die lokale Kopie\n}\n\nlet a = 10;\nmodify(a);\nprint(a);  // Immer noch 10 (unverndert)\n```\n\n**Hinweis:** Objekte und Arrays werden per Referenz bergeben (die Referenz wird kopiert), sodass deren Inhalt gendert werden kann:\n\n```hemlock\nfn modify_array(arr) {\n    arr[0] = 99;  // Aendert das Original-Array\n}\n\nlet a = [1, 2, 3];\nmodify_array(a);\nprint(a[0]);  // 99 (gendert)\n```\n\n## Rueckgabewerte\n\n### Return-Anweisung\n\n```hemlock\nfn get_max(a: i32, b: i32): i32 {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n```\n\n### Rckgabetyp-Annotationen\n\nOptionale Typannotation fr den Rckgabewert:\n\n```hemlock\nfn calculate(): f64 {\n    return 3.14159;\n}\n\nfn get_name(): string {\n    return \"Alice\";\n}\n```\n\n**Typberprfung:**\n- Rueckgabetypen werden beim Zurckgeben geprft (wenn annotiert)\n- Typkonvertierungen folgen Standard-Promotionsregeln\n\n### Implizite Rckgabe\n\nFunktionen ohne Rckgabetyp-Annotation geben implizit `null` zurck:\n\n```hemlock\nfn print_message(msg) {\n    print(msg);\n    // Gibt implizit null zurck\n}\n\nlet result = print_message(\"hello\");  // result ist null\n```\n\n### Fruehe Rckgabe\n\n```hemlock\nfn find_first_negative(arr) {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Fruehes Beenden\n        }\n    }\n    return -1;  // Nicht gefunden\n}\n```\n\n### Rckgabe ohne Wert\n\n`return;` ohne Wert gibt `null` zurck:\n\n```hemlock\nfn maybe_process(value) {\n    if (value < 0) {\n        return;  // Gibt null zurck\n    }\n    return value * 2;\n}\n```\n\n## Erstklassige Funktionen\n\nFunktionen knnen wie jeder andere Wert zugewiesen, bergeben und zurckgegeben werden.\n\n### Funktionen als Variablen\n\n```hemlock\nlet operation = fn(x, y) { return x + y; };\n\nprint(operation(5, 3));  // 8\n\n// Neu zuweisen\noperation = fn(x, y) { return x * y; };\nprint(operation(5, 3));  // 15\n```\n\n### Funktionen als Argumente\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 5);  // 10\n```\n\n### Funktionen als Rueckgabewerte\n\n```hemlock\nfn get_operation(op: string) {\n    if (op == \"add\") {\n        return fn(a, b) { return a + b; };\n    } else if (op == \"multiply\") {\n        return fn(a, b) { return a * b; };\n    } else {\n        return fn(a, b) { return 0; };\n    }\n}\n\nlet add = get_operation(\"add\");\nprint(add(5, 3));  // 8\n```\n\n## Closures\n\nFunktionen erfassen ihre definierende Umgebung (lexikalisches Scoping).\n\n### Grundlegende Closures\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n**Wie es funktioniert:**\n- Die innere Funktion erfasst `count` aus dem ueren Scope\n- `count` bleibt ber Aufrufe der zurueckgegebenen Funktion erhalten\n- Jeder Aufruf von `makeCounter()` erstellt eine neue Closure mit eigenem `count`\n\n### Closure mit Parametern\n\n```hemlock\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\n\nprint(add5(3));   // 8\nprint(add10(3));  // 13\n```\n\n### Mehrere Closures\n\n```hemlock\nfn makeOperations(x) {\n    let add = fn(y) { return x + y; };\n    let multiply = fn(y) { return x * y; };\n\n    return { add: add, multiply: multiply };\n}\n\nlet ops = makeOperations(5);\nprint(ops.add(3));       // 8\nprint(ops.multiply(3));  // 15\n```\n\n### Lexikalisches Scoping\n\nFunktionen knnen durch lexikalisches Scoping auf Variablen des ueren Scopes zugreifen:\n\n```hemlock\nlet global = 10;\n\nfn outer() {\n    let outer_var = 20;\n\n    fn inner() {\n        // Kann global und outer_var lesen\n        print(global);      // 10\n        print(outer_var);   // 20\n    }\n\n    inner();\n}\n\nouter();\n```\n\nClosures erfassen Variablen per Referenz, was sowohl Lesen als auch Mutation von Variablen des ueren Scopes ermglicht (wie im `makeCounter`-Beispiel oben gezeigt).\n\n## Rekursion\n\nFunktionen knnen sich selbst aufrufen.\n\n### Grundlegende Rekursion\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### Wechselseitige Rekursion\n\nFunktionen knnen sich gegenseitig aufrufen:\n\n```hemlock\nfn is_even(n: i32): bool {\n    if (n == 0) {\n        return true;\n    }\n    return is_odd(n - 1);\n}\n\nfn is_odd(n: i32): bool {\n    if (n == 0) {\n        return false;\n    }\n    return is_even(n - 1);\n}\n\nprint(is_even(4));  // true\nprint(is_odd(4));   // false\n```\n\n### Rekursive Datenverarbeitung\n\n```hemlock\nfn sum_array(arr: array, index: i32): i32 {\n    if (index >= arr.length) {\n        return 0;\n    }\n    return arr[index] + sum_array(arr, index + 1);\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(sum_array(numbers, 0));  // 15\n```\n\n**Hinweis:** Noch keine Tail-Call-Optimierung - tiefe Rekursion kann zu Stack-berlauf fhren.\n\n## Hhere Ordnung Funktionen\n\nFunktionen, die andere Funktionen entgegennehmen oder zurckgeben.\n\n### Map-Muster\n\n```hemlock\nfn map(arr, f) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        result.push(f(arr[i]));\n        i = i + 1;\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = map(numbers, double);  // [2, 4, 6, 8, 10]\n```\n\n### Filter-Muster\n\n```hemlock\nfn filter(arr, predicate) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (predicate(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nfn is_even(x) { return x % 2 == 0; }\n\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = filter(numbers, is_even);  // [2, 4, 6]\n```\n\n### Reduce-Muster\n\n```hemlock\nfn reduce(arr, f, initial) {\n    let accumulator = initial;\n    let i = 0;\n    while (i < arr.length) {\n        accumulator = f(accumulator, arr[i]);\n        i = i + 1;\n    }\n    return accumulator;\n}\n\nfn add(a, b) { return a + b; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = reduce(numbers, add, 0);  // 15\n```\n\n### Funktionskomposition\n\n```hemlock\nfn compose(f, g) {\n    return fn(x) {\n        return f(g(x));\n    };\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\n\nlet double_then_increment = compose(increment, double);\nprint(double_then_increment(5));  // 11 (5*2 + 1)\n```\n\n## Hufige Muster\n\n### Muster: Factory-Funktionen\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```\n\n### Muster: Callback-Funktionen\n\n```hemlock\nfn process_async(data, callback) {\n    // ... Verarbeitung durchfuehren\n    callback(data);\n}\n\nprocess_async(\"test\", fn(result) {\n    print(\"Processing complete: \" + result);\n});\n```\n\n### Muster: Partielle Anwendung\n\n```hemlock\nfn partial(f, x) {\n    return fn(y) {\n        return f(x, y);\n    };\n}\n\nfn multiply(a, b) {\n    return a * b;\n}\n\nlet double = partial(multiply, 2);\nlet triple = partial(multiply, 3);\n\nprint(double(5));  // 10\nprint(triple(5));  // 15\n```\n\n### Muster: Memoisierung\n\n```hemlock\nfn memoize(f) {\n    let cache = {};\n\n    return fn(x) {\n        if (cache.has(x)) {\n            return cache[x];\n        }\n\n        let result = f(x);\n        cache[x] = result;\n        return result;\n    };\n}\n\nfn expensive_fibonacci(n) {\n    if (n <= 1) { return n; }\n    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);\n}\n\nlet fast_fib = memoize(expensive_fibonacci);\nprint(fast_fib(10));  // Viel schneller mit Caching\n```\n\n## Funktionssemantik\n\n### Rckgabetyp-Anforderungen\n\nFunktionen mit Rckgabetyp-Annotation **mssen** einen Wert zurckgeben:\n\n```hemlock\nfn get_value(): i32 {\n    // FEHLER: Fehlende Return-Anweisung\n}\n\nfn get_value(): i32 {\n    return 42;  // OK\n}\n```\n\n### Typberprfung\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);        // OK\nadd(5.5, 10.5);    // Konvertiert zu f64, gibt f64 zurck\nadd(\"a\", \"b\");     // Laufzeitfehler: Typkonflikt\n```\n\n### Scope-Regeln\n\n```hemlock\nlet global = \"global\";\n\nfn outer() {\n    let outer_var = \"outer\";\n\n    fn inner() {\n        let inner_var = \"inner\";\n        // Kann zugreifen auf: inner_var, outer_var, global\n    }\n\n    // Kann zugreifen auf: outer_var, global\n    // Kann nicht zugreifen auf: inner_var\n}\n\n// Kann zugreifen auf: global\n// Kann nicht zugreifen auf: outer_var, inner_var\n```\n\n## Best Practices\n\n1. **Verwende Typannotationen** - Hilft Fehler zu finden und dokumentiert die Absicht\n2. **Halte Funktionen klein** - Jede Funktion sollte eine Sache tun\n3. **Bevorzuge reine Funktionen** - Vermeide Seiteneffekte wenn mglich\n4. **Benenne Funktionen klar** - Verwende beschreibende Verb-Namen\n5. **Fruehe Rckgabe** - Verwende Guard-Klauseln um Verschachtelung zu reduzieren\n6. **Dokumentiere komplexe Closures** - Mache erfasste Variablen explizit\n7. **Vermeide tiefe Rekursion** - Noch keine Tail-Call-Optimierung\n\n## Hufige Fallstricke\n\n### Fallstrick: Rekursionstiefe\n\n```hemlock\n// Tiefe Rekursion kann Stack-berlauf verursachen\nfn count_down(n) {\n    if (n == 0) { return; }\n    count_down(n - 1);\n}\n\ncount_down(100000);  // Kann mit Stack-berlauf abstuerzen\n```\n\n### Fallstrick: ndern erfasster Variablen\n\n```hemlock\nfn make_counter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Kann erfasste Variablen lesen und ndern\n        return count;\n    };\n}\n```\n\n**Hinweis:** Das funktioniert, aber sei dir bewusst, dass alle Closures dieselbe erfasste Umgebung teilen.\n\n## Beispiele\n\n### Beispiel: Funktions-Pipeline\n\n```hemlock\nfn pipeline(value, ...functions) {\n    let result = value;\n    for (f in functions) {\n        result = f(result);\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\nfn square(x) { return x * x; }\n\nlet result = pipeline(3, double, increment, square);\nprint(result);  // 49 ((3*2+1)^2)\n```\n\n### Beispiel: Event-Handler\n\n```hemlock\nlet handlers = [];\n\nfn on_event(name: string, handler) {\n    handlers.push({ name: name, handler: handler });\n}\n\nfn trigger_event(name: string, data) {\n    let i = 0;\n    while (i < handlers.length) {\n        if (handlers[i].name == name) {\n            handlers[i].handler(data);\n        }\n        i = i + 1;\n    }\n}\n\non_event(\"click\", fn(data) {\n    print(\"Clicked: \" + data);\n});\n\ntrigger_event(\"click\", \"button1\");\n```\n\n### Beispiel: Sortierung mit benutzerdefiniertem Vergleicher\n\n```hemlock\nfn sort(arr, compare) {\n    // Bubble-Sort mit benutzerdefiniertem Vergleicher\n    let n = arr.length;\n    let i = 0;\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (compare(arr[j], arr[j + 1]) > 0) {\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nfn ascending(a, b) {\n    if (a < b) { return -1; }\n    if (a > b) { return 1; }\n    return 0;\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers, ascending);\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## Optionale Parameter (Standardargumente)\n\nFunktionen knnen optionale Parameter mit Standardwerten haben, unter Verwendung der `?:`-Syntax:\n\n```hemlock\nfn greet(name, greeting?: \"Hello\") {\n    return greeting + \" \" + name;\n}\n\nprint(greet(\"Alice\"));           // \"Hello Alice\"\nprint(greet(\"Bob\", \"Hi\"));       // \"Hi Bob\"\n\nfn add(a, b?: 10, c?: 100) {\n    return a + b + c;\n}\n\nprint(add(1));          // 111 (1 + 10 + 100)\nprint(add(1, 2));       // 103 (1 + 2 + 100)\nprint(add(1, 2, 3));    // 6   (1 + 2 + 3)\n```\n\n**Regeln:**\n- Optionale Parameter mssen nach erforderlichen Parametern kommen\n- Standardwerte knnen beliebige Ausdrcke sein\n- Ausgelassene Argumente verwenden den Standardwert\n\n## Variadische Funktionen (Rest-Parameter)\n\nFunktionen knnen eine variable Anzahl von Argumenten akzeptieren, unter Verwendung von Rest-Parametern (`...`):\n\n```hemlock\nfn sum(...args) {\n    let total = 0;\n    for (arg in args) {\n        total = total + arg;\n    }\n    return total;\n}\n\nprint(sum(1, 2, 3));        // 6\nprint(sum(1, 2, 3, 4, 5));  // 15\nprint(sum());               // 0\n\nfn log(prefix, ...messages) {\n    for (msg in messages) {\n        print(prefix + \": \" + msg);\n    }\n}\n\nlog(\"INFO\", \"Starting\", \"Running\", \"Done\");\n// INFO: Starting\n// INFO: Running\n// INFO: Done\n```\n\n**Regeln:**\n- Der Rest-Parameter muss der letzte Parameter sein\n- Der Rest-Parameter sammelt alle verbleibenden Argumente in einem Array\n- Kann mit regulaeren und optionalen Parametern kombiniert werden\n\n## Funktionstyp-Annotationen\n\nFunktionstypen ermglichen es, die genaue Signatur fr Funktionsparameter und Rueckgabewerte zu spezifizieren:\n\n### Grundlegende Funktionstypen\n\n```hemlock\n// Funktionstyp-Syntax: fn(param_types): return_type\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\nlet double = fn(n) { return n * 2; };\nlet result = apply(double, 5);  // 10\n```\n\n### Hhere Ordnung Funktionstypen\n\n```hemlock\n// Funktion die eine Funktion zurckgibt\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\nlet add5 = make_adder(5);\nprint(add5(10));  // 15\n```\n\n### Async-Funktionstypen\n\n```hemlock\n// Async-Funktionstyp\nfn run_task(handler: async fn(): void) {\n    spawn(handler);\n}\n\nrun_task(async fn() {\n    print(\"Running async!\");\n});\n```\n\n### Funktionstyp-Aliase\n\n```hemlock\n// Benannte Funktionstypen fr Klarheit erstellen\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\nfn filter_with(arr: array, pred: Predicate): array {\n    return arr.filter(pred);\n}\n```\n\n## Const-Parameter\n\nDer `const`-Modifikator verhindert, dass ein Parameter innerhalb der Funktion veraendert wird:\n\n### Grundlegende Const-Parameter\n\n```hemlock\nfn print_all(const items: array) {\n    // items.push(4);  // FEHLER: kann const-Parameter nicht veraendern\n    for (item in items) {\n        print(item);   // OK: Lesen ist erlaubt\n    }\n}\n\nlet nums = [1, 2, 3];\nprint_all(nums);\n```\n\n### Tiefe Unvernderlichkeit\n\nConst-Parameter erzwingen tiefe Unvernderlichkeit - keine Mutation ber irgendeinen Pfad:\n\n```hemlock\nfn describe(const person: object) {\n    print(person.name);       // OK: Lesen ist erlaubt\n    // person.name = \"Bob\";   // FEHLER: kann nicht veraendern\n    // person.address.city = \"NYC\";  // FEHLER: tiefes const\n}\n```\n\n### Was Const verhindert\n\n| Typ | Durch Const blockiert | Erlaubt |\n|------|-----------------|---------|\n| array | push, pop, shift, unshift, insert, remove, clear, reverse | slice, concat, map, filter, find, contains |\n| object | Feldzuweisung | Feldlesen |\n| buffer | Indexzuweisung | Indexlesen |\n| string | Indexzuweisung | alle Methoden (geben neue Strings zurck) |\n\n## Benannte Argumente\n\nFunktionen knnen mit benannten Argumenten aufgerufen werden fr Klarheit und Flexibilitaet:\n\n### Grundlegende benannte Argumente\n\n```hemlock\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" is \" + age + \" years old\");\n}\n\n// Positionsargumente (traditionell)\ncreate_user(\"Alice\", 25, false);\n\n// Benannte Argumente - knnen in beliebiger Reihenfolge sein\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n```\n\n### Mischen von Positions- und benannten Argumenten\n\n```hemlock\n// Optionale Parameter berspringen durch Benennen des Benotigten\ncreate_user(\"David\", active: false);  // Verwendet Standard-age=18\n\n// Benannte Argumente mssen nach Positionsargumenten kommen\ncreate_user(\"Eve\", age: 21);          // OK\n// create_user(name: \"Bad\", 25);      // FEHLER: Positionsargument nach benanntem\n```\n\n### Regeln fr benannte Argumente\n\n- Verwende `name: wert`-Syntax fr benannte Argumente\n- Benannte Argumente knnen in beliebiger Reihenfolge nach Positionsargumenten erscheinen\n- Positionsargumente knnen nicht auf benannte Argumente folgen\n- Funktioniert mit Standard/optionalen Parametern\n- Unbekannte Parameternamen verursachen Laufzeitfehler\n\n## Einschrnkungen\n\nAktuelle Einschrnkungen, die zu beachten sind:\n\n- **Keine Referenzuebergabe** - `ref`-Schlsselwort wird geparst aber nicht implementiert\n- **Kein Funktionsueberladen** - Eine Funktion pro Name\n- **Keine Tail-Call-Optimierung** - Tiefe Rekursion durch Stack-Gre begrenzt\n\n## Verwandte Themen\n\n- [Kontrollfluss](#language-guide-control-flow) - Funktionen mit Kontrollstrukturen verwenden\n- [Objekte](#language-guide-objects) - Methoden sind Funktionen in Objekten gespeichert\n- [Fehlerbehandlung](#language-guide-error-handling) - Funktionen und Ausnahmebehandlung\n- [Typen](#language-guide-types) - Typannotationen und Konvertierungen\n\n## Siehe auch\n\n- **Closures**: Siehe CLAUDE.md Abschnitt \"Functions\" fr Closure-Semantik\n- **Erstklassige Werte**: Funktionen sind Werte wie alle anderen\n- **Lexikalisches Scoping**: Funktionen erfassen ihre definierende Umgebung\n"}, "Sprachhandbuch -> Kontrollfluss": {"id": "language-guide-control-flow", "content": "# Kontrollfluss\n\nHemlock bietet vertrauten C-hnlichen Kontrollfluss mit obligatorischen geschweiften Klammern und expliziter Syntax. Diese Anleitung behandelt Bedingungen, Schleifen, Switch-Anweisungen und Operatoren.\n\n## berblick\n\nVerfuegbare Kontrollfluss-Funktionen:\n\n- `if`/`else`/`else if` - Bedingte Verzweigungen\n- `while`-Schleifen - Bedingungsbasierte Iteration\n- `for`-Schleifen - C-artige und for-in-Iteration\n- `loop` - Endlosschleifen (sauberer als `while (true)`)\n- `switch`-Anweisungen - Mehrfachverzweigung\n- `break`/`continue` - Schleifensteuerung\n- Schleifen-Labels - Gezieltes break/continue fr verschachtelte Schleifen\n- `defer` - Verzgerte Ausfhrung (Bereinigung)\n- Boolesche Operatoren: `&&`, `||`, `!`\n- Vergleichsoperatoren: `==`, `!=`, `<`, `>`, `<=`, `>=`\n- Bitweise Operatoren: `&`, `|`, `^`, `<<`, `>>`, `~`\n\n## If-Anweisungen\n\n### Einfaches If/Else\n\n```hemlock\nif (x > 10) {\n    print(\"gro\");\n} else {\n    print(\"klein\");\n}\n```\n\n**Regeln:**\n- Geschweifte Klammern sind **immer erforderlich** fr alle Zweige\n- Bedingungen mssen in Klammern eingeschlossen sein\n- Keine optionalen geschweiften Klammern (anders als C)\n\n### If ohne Else\n\n```hemlock\nif (x > 0) {\n    print(\"positiv\");\n}\n// Kein else-Zweig ntig\n```\n\n### Else-If-Ketten\n\n```hemlock\nif (x > 100) {\n    print(\"sehr gro\");\n} else if (x > 50) {\n    print(\"gro\");\n} else if (x > 10) {\n    print(\"mittel\");\n} else {\n    print(\"klein\");\n}\n```\n\n**Hinweis:** `else if` ist syntaktischer Zucker fr verschachtelte if-Anweisungen. Diese sind quivalent:\n\n```hemlock\n// else if (syntaktischer Zucker)\nif (a) {\n    foo();\n} else if (b) {\n    bar();\n}\n\n// quivalentes verschachteltes if\nif (a) {\n    foo();\n} else {\n    if (b) {\n        bar();\n    }\n}\n```\n\n### Verschachtelte If-Anweisungen\n\n```hemlock\nif (x > 0) {\n    if (x < 10) {\n        print(\"einstellig positiv\");\n    } else {\n        print(\"mehrstellig positiv\");\n    }\n} else {\n    print(\"nicht positiv\");\n}\n```\n\n## While-Schleifen\n\nBedingungsbasierte Iteration:\n\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n**Endlosschleifen (alter Stil):**\n```hemlock\nwhile (true) {\n    // ... Arbeit erledigen\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**Hinweis:** Fr Endlosschleifen bevorzugen Sie das `loop`-Schlsselwort (siehe unten).\n\n## Loop (Endlosschleife)\n\nDas Schlsselwort `loop` bietet eine sauberere Syntax fr Endlosschleifen:\n\n```hemlock\nloop {\n    // ... Arbeit erledigen\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**quivalent zu `while (true)`, aber expliziter in der Absicht.**\n\n### Einfache Schleife mit Break\n\n```hemlock\nlet i = 0;\nloop {\n    if (i >= 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// Gibt aus: 0, 1, 2, 3, 4\n```\n\n### Schleife mit Continue\n\n```hemlock\nlet i = 0;\nloop {\n    i = i + 1;\n    if (i > 5) {\n        break;\n    }\n    if (i == 3) {\n        continue;  // berspringt Ausgabe von 3\n    }\n    print(i);\n}\n// Gibt aus: 1, 2, 4, 5\n```\n\n### Verschachtelte Schleifen\n\n```hemlock\nlet x = 0;\nloop {\n    if (x >= 2) { break; }\n    let y = 0;\n    loop {\n        if (y >= 3) { break; }\n        print(x * 10 + y);\n        y = y + 1;\n    }\n    x = x + 1;\n}\n// Gibt aus: 0, 1, 2, 10, 11, 12\n```\n\n### Wann Loop verwenden\n\n- **`loop` verwenden** fr absichtlich unendliche Schleifen, die via `break` beendet werden\n- **`while` verwenden** wenn es eine natuerliche Abbruchbedingung gibt\n- **`for` verwenden** beim Iterieren einer bekannten Anzahl von Malen oder ber eine Sammlung\n\n## For-Schleifen\n\n### C-artige For-Schleife\n\nKlassische dreiteilige For-Schleife:\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**Komponenten:**\n- **Initialisierer**: `let i = 0` - Wird einmal vor der Schleife ausgefhrt\n- **Bedingung**: `i < 10` - Wird vor jeder Iteration geprft\n- **Aktualisierung**: `i = i + 1` - Wird nach jeder Iteration ausgefhrt\n\n**Gltigkeitsbereich:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n// i ist hier nicht zugnglich (schleifenbezogen)\n```\n\n### For-In-Schleifen\n\nber Array-Elemente iterieren:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nfor (let item in arr) {\n    print(item);  // Gibt jedes Element aus\n}\n```\n\n**Mit Index und Wert:**\n```hemlock\nlet arr = [\"a\", \"b\", \"c\"];\nfor (let i = 0; i < arr.length; i = i + 1) {\n    print(`Index: ${i}, Wert: ${arr[i]}`);\n}\n```\n\n## Switch-Anweisungen\n\nMehrfachverzweigung basierend auf Wert:\n\n### Einfacher Switch\n\n```hemlock\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"eins\");\n        break;\n    case 2:\n        print(\"zwei\");\n        break;\n    case 3:\n        print(\"drei\");\n        break;\n}\n```\n\n### Switch mit Default\n\n```hemlock\nlet color = \"blue\";\n\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"yellow\":\n        print(\"langsam\");\n        break;\n    case \"green\":\n        print(\"los\");\n        break;\n    default:\n        print(\"unbekannte Farbe\");\n        break;\n}\n```\n\n**Regeln:**\n- `default` trifft zu, wenn kein anderer Fall zutrifft\n- `default` kann berall im Switch-Krper erscheinen\n- Nur ein default-Fall erlaubt\n\n### Fall-Through-Verhalten\n\nFaelle ohne `break` fallen durch zum nchsten Fall (C-artiges Verhalten). Dies ist **beabsichtigt** und kann zum Gruppieren von Faellen verwendet werden:\n\n```hemlock\nlet grade = 85;\n\nswitch (grade) {\n    case 100:\n    case 95:\n    case 90:\n        print(\"A\");\n        break;\n    case 85:\n    case 80:\n        print(\"B\");\n        break;\n    default:\n        print(\"C oder schlechter\");\n        break;\n}\n```\n\n**Explizites Fall-Through-Beispiel:**\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n        print(\"Wochentag\");\n        break;\n    case 6:\n    case 7:\n        print(\"Wochenende\");\n        break;\n}\n```\n\n**Wichtig:** Anders als einige moderne Sprachen erfordert Hemlock KEIN explizites `fallthrough`-Schlsselwort. Faelle fallen automatisch durch, es sei denn, sie werden durch `break`, `return` oder `throw` beendet. Verwenden Sie immer `break`, um unbeabsichtigtes Fall-Through zu verhindern.\n\n### Switch mit Return\n\nIn Funktionen beendet `return` den Switch sofort:\n\n```hemlock\nfn get_day_name(day: i32): string {\n    switch (day) {\n        case 1:\n            return \"Montag\";\n        case 2:\n            return \"Dienstag\";\n        case 3:\n            return \"Mittwoch\";\n        default:\n            return \"Unbekannt\";\n    }\n}\n```\n\n### Switch-Werttypen\n\nSwitch funktioniert mit jedem Werttyp:\n\n```hemlock\n// Ganzzahlen\nswitch (count) {\n    case 0: print(\"null\"); break;\n    case 1: print(\"eins\"); break;\n}\n\n// Strings\nswitch (name) {\n    case \"Alice\": print(\"A\"); break;\n    case \"Bob\": print(\"B\"); break;\n}\n\n// Booleans\nswitch (flag) {\n    case true: print(\"an\"); break;\n    case false: print(\"aus\"); break;\n}\n```\n\n**Hinweis:** Faelle werden mittels Wertgleichheit verglichen.\n\n## Break und Continue\n\n### Break\n\nVerlasst die innerste Schleife oder Switch:\n\n```hemlock\n// In Schleifen\nlet i = 0;\nwhile (true) {\n    if (i >= 10) {\n        break;  // Schleife verlassen\n    }\n    print(i);\n    i = i + 1;\n}\n\n// In Switch\nswitch (x) {\n    case 1:\n        print(\"eins\");\n        break;  // Switch verlassen\n    case 2:\n        print(\"zwei\");\n        break;\n}\n```\n\n### Continue\n\nSpringt zur nchsten Iteration der Schleife:\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;  // Iteration berspringen wenn i 5 ist\n    }\n    print(i);  // Gibt aus: 0,1,2,3,4,6,7,8,9\n}\n```\n\n**Unterschied:**\n- `break` - Verlasst Schleife vollstndig\n- `continue` - Springt zur nchsten Iteration\n\n## Schleifen-Labels\n\nSchleifen-Labels erlauben `break` und `continue`, spezifische uere Schleifen anzusprechen, statt nur die innerste Schleife. Dies ist ntzlich fr verschachtelte Schleifen, wo Sie eine uere Schleife von einer inneren aus steuern mssen.\n\n### Labeled Break\n\nEine uere Schleife von einer inneren verlassen:\n\n```hemlock\nouter: while (i < 3) {\n    let j = 0;\n    while (j < 3) {\n        if (i == 1 && j == 1) {\n            break outer;  // uere while-Schleife verlassen\n        }\n        print(i * 10 + j);\n        j = j + 1;\n    }\n    i = i + 1;\n}\n// Gibt aus: 0, 1, 2, 10 (stoppt bei i=1, j=1)\n```\n\n### Labeled Continue\n\nZur nchsten Iteration einer ueren Schleife springen:\n\n```hemlock\nlet i = 0;\nouter: while (i < 3) {\n    i = i + 1;\n    let j = 0;\n    while (j < 3) {\n        j = j + 1;\n        if (i == 2 && j == 1) {\n            continue outer;  // Rest der inneren Schleife berspringen, uere fortsetzen\n        }\n        print(i * 10 + j);\n    }\n}\n// Wenn i=2, j=1: springt zur nchsten ueren Iteration\n```\n\n### Labels mit For-Schleifen\n\nLabels funktionieren mit allen Schleifentypen:\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 3; y = y + 1) {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n    }\n}\n```\n\n### Labels mit For-In-Schleifen\n\n```hemlock\nlet arr1 = [1, 2, 3];\nlet arr2 = [10, 20, 30];\n\nouter: for (let a in arr1) {\n    for (let b in arr2) {\n        if (a == 2 && b == 20) {\n            break outer;\n        }\n        print(a * 100 + b);\n    }\n}\n```\n\n### Labels mit Loop-Schlsselwort\n\n```hemlock\nlet x = 0;\nouter: loop {\n    let y = 0;\n    loop {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n        y = y + 1;\n        if (y >= 3) { break; }\n    }\n    x = x + 1;\n    if (x >= 3) { break; }\n}\n```\n\n### Mehrere Labels\n\nSie knnen Labels auf verschiedenen Verschachtelungsebenen haben:\n\n```hemlock\nouter: for (let a = 0; a < 2; a = a + 1) {\n    inner: for (let b = 0; b < 3; b = b + 1) {\n        for (let c = 0; c < 3; c = c + 1) {\n            if (c == 1) {\n                continue inner;  // Zur nchsten Iteration der mittleren Schleife springen\n            }\n            if (a == 1 && b == 1) {\n                break outer;      // uerste Schleife verlassen\n            }\n            print(a * 100 + b * 10 + c);\n        }\n    }\n}\n```\n\n### Unlabeled Break/Continue mit gelabelten Schleifen\n\nUnlabeled `break` und `continue` funktionieren weiterhin normal (betreffen die innerste Schleife), auch wenn uere Schleifen Labels haben:\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 5; y = y + 1) {\n        if (y == 2) {\n            break;  // Bricht nur innere Schleife ab\n        }\n        print(x * 10 + y);\n    }\n}\n// Gibt aus: 0, 1, 10, 11, 20, 21\n```\n\n### Label-Syntax\n\n- Labels sind Bezeichner gefolgt von einem Doppelpunkt\n- Labels mssen direkt vor einer Schleifenanweisung stehen (`while`, `for`, `loop`)\n- Label-Namen folgen Bezeichnerregeln (Buchstaben, Ziffern, Unterstriche)\n- Gngige Konventionen: `outer`, `inner`, `row`, `col`, beschreibende Namen\n\n## Defer-Anweisung\n\nDie `defer`-Anweisung plant Code zur Ausfhrung, wenn die aktuelle Funktion zurckkehrt. Dies ist ntzlich fr Bereinigungsoperationen wie Dateien schlieen, Ressourcen freigeben oder Sperren lsen.\n\n### Einfaches Defer\n\n```hemlock\nfn example() {\n    print(\"start\");\n    defer print(\"bereinigung\");  // Wird ausgefhrt, wenn Funktion zurckkehrt\n    print(\"ende\");\n}\n\nexample();\n// Ausgabe:\n// start\n// ende\n// bereinigung\n```\n\n**Kernverhalten:**\n- Deferred-Anweisungen werden **nach** Abschluss des Funktionskoerpers ausgefhrt\n- Deferred-Anweisungen werden **vor** der Rckkehr der Funktion an ihren Aufrufer ausgefhrt\n- Deferred-Anweisungen werden immer ausgefhrt, auch wenn die Funktion eine Ausnahme wirft\n\n### Mehrere Defers (LIFO-Reihenfolge)\n\nWenn mehrere `defer`-Anweisungen verwendet werden, werden sie in **umgekehrter Reihenfolge** ausgefhrt (Last-In-First-Out):\n\n```hemlock\nfn example() {\n    defer print(\"erstes\");   // Wird zuletzt ausgefhrt\n    defer print(\"zweites\");  // Wird als zweites ausgefhrt\n    defer print(\"drittes\");  // Wird zuerst ausgefhrt\n    print(\"krper\");\n}\n\nexample();\n// Ausgabe:\n// krper\n// drittes\n// zweites\n// erstes\n```\n\nDiese LIFO-Reihenfolge ist beabsichtigt - sie entspricht der natuerlichen Reihenfolge fr verschachtelte Ressourcenbereinigung (innere Ressourcen vor ueren schlieen).\n\n### Defer mit Return\n\nDeferred-Anweisungen werden ausgefhrt, bevor `return` die Kontrolle bergibt:\n\n```hemlock\nfn get_value(): i32 {\n    defer print(\"bereinigung\");\n    print(\"vor return\");\n    return 42;\n}\n\nlet result = get_value();\nprint(\"ergebnis:\", result);\n// Ausgabe:\n// vor return\n// bereinigung\n// ergebnis: 42\n```\n\n### Defer mit Ausnahmen\n\nDeferred-Anweisungen werden auch ausgefhrt, wenn eine Ausnahme geworfen wird:\n\n```hemlock\nfn risky() {\n    defer print(\"bereinigung 1\");\n    defer print(\"bereinigung 2\");\n    print(\"vor throw\");\n    throw \"fehler!\";\n    print(\"nach throw\");  // Wird nie erreicht\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(\"Gefangen:\", e);\n}\n// Ausgabe:\n// vor throw\n// bereinigung 2\n// bereinigung 1\n// Gefangen: fehler!\n```\n\n### Ressourcenbereinigungsmuster\n\nDer Hauptanwendungsfall fr `defer` ist sicherzustellen, dass Ressourcen bereinigt werden:\n\n```hemlock\nfn process_file(filename: string) {\n    let file = open(filename, \"r\");\n    defer file.close();  // Schliesst immer, auch bei Fehler\n\n    let content = file.read();\n    // ... Inhalt verarbeiten ...\n\n    // Datei wird automatisch geschlossen, wenn Funktion zurckkehrt\n}\n```\n\n**Ohne defer (fehleranfaellig):**\n```hemlock\nfn process_file_bad(filename: string) {\n    let file = open(filename, \"r\");\n    let content = file.read();\n    // Wenn dies wirft, wird file.close() nie aufgerufen!\n    process(content);\n    file.close();\n}\n```\n\n### Defer mit Closures\n\nDefer kann Closures verwenden, um Zustand zu erfassen:\n\n```hemlock\nfn example() {\n    let resource = acquire_resource();\n    defer fn() {\n        print(\"Ressource freigeben\");\n        release(resource);\n    }();  // Hinweis: sofort aufgerufener Funktionsausdruck\n\n    use_resource(resource);\n}\n```\n\n### Wann Defer verwenden\n\n**Defer verwenden fr:**\n- Dateien und Netzwerkverbindungen schlieen\n- Allokierten Speicher freigeben\n- Sperren und Mutexe freigeben\n- Bereinigung in jeder Funktion, die Ressourcen erwirbt\n\n**Defer vs. Finally:**\n- `defer` ist einfacher fr Einzelressourcen-Bereinigung\n- `try/finally` ist besser fr komplexe Fehlerbehandlung mit Wiederherstellung\n\n### Best Practices\n\n1. **Defer sofort nach Ressourcenerwerb platzieren:**\n   ```hemlock\n   let file = open(\"data.txt\", \"r\");\n   defer file.close();\n   // ... Datei verwenden ...\n   ```\n\n2. **Mehrere Defers fr mehrere Ressourcen verwenden:**\n   ```hemlock\n   let file1 = open(\"input.txt\", \"r\");\n   defer file1.close();\n\n   let file2 = open(\"output.txt\", \"w\");\n   defer file2.close();\n\n   // Beide Dateien werden in umgekehrter Reihenfolge geschlossen\n   ```\n\n3. **LIFO-Reihenfolge fr abhaengige Ressourcen beachten:**\n   ```hemlock\n   let outer = acquire_outer();\n   defer release_outer(outer);\n\n   let inner = acquire_inner(outer);\n   defer release_inner(inner);\n\n   // inner wird vor outer freigegeben (korrekte Abhaengigkeitsreihenfolge)\n   ```\n\n## Boolesche Operatoren\n\n### Logisches UND (`&&`)\n\nBeide Bedingungen mssen wahr sein:\n\n```hemlock\nif (x > 0 && x < 10) {\n    print(\"einstellig positiv\");\n}\n```\n\n**Kurzschlussauswertung:**\n```hemlock\nif (false && expensive_check()) {\n    // expensive_check() wird nie aufgerufen\n}\n```\n\n### Logisches ODER (`||`)\n\nMindestens eine Bedingung muss wahr sein:\n\n```hemlock\nif (x < 0 || x > 100) {\n    print(\"auerhalb des Bereichs\");\n}\n```\n\n**Kurzschlussauswertung:**\n```hemlock\nif (true || expensive_check()) {\n    // expensive_check() wird nie aufgerufen\n}\n```\n\n### Logisches NICHT (`!`)\n\nNegiert booleschen Wert:\n\n```hemlock\nif (!is_valid) {\n    print(\"ungltig\");\n}\n\nif (!(x > 10)) {\n    // Gleich wie: if (x <= 10)\n}\n```\n\n## Vergleichsoperatoren\n\n### Gleichheit\n\n```hemlock\nif (x == 10) { }    // Gleich\nif (x != 10) { }    // Ungleich\n```\n\nFunktioniert mit allen Typen:\n```hemlock\n\"hello\" == \"hello\"  // true\ntrue == false       // false\nnull == null        // true\n```\n\n### Relational\n\n```hemlock\nif (x < 10) { }     // Kleiner als\nif (x > 10) { }     // Grer als\nif (x <= 10) { }    // Kleiner oder gleich\nif (x >= 10) { }    // Grer oder gleich\n```\n\n**Typpromotion gilt:**\n```hemlock\nlet a: i32 = 10;\nlet b: i64 = 10;\nif (a == b) { }     // true (i32 wird zu i64 befrdert)\n```\n\n## Bitweise Operatoren\n\nHemlock bietet bitweise Operatoren fr Ganzzahlmanipulation. Diese funktionieren **nur mit Ganzzahltypen** (i8-i64, u8-u64).\n\n### Binre bitweise Operatoren\n\n**Bitweises UND (`&`)**\n```hemlock\nlet a = 12;  // 1100 in binr\nlet b = 10;  // 1010 in binr\nprint(a & b);   // 8 (1000)\n```\n\n**Bitweises ODER (`|`)**\n```hemlock\nprint(a | b);   // 14 (1110)\n```\n\n**Bitweises XOR (`^`)**\n```hemlock\nprint(a ^ b);   // 6 (0110)\n```\n\n**Linksshift (`<<`)**\n```hemlock\nprint(a << 2);  // 48 (110000) - 2 nach links schieben\n```\n\n**Rechtsshift (`>>`)**\n```hemlock\nprint(a >> 1);  // 6 (110) - 1 nach rechts schieben\n```\n\n### Unaerer bitweiser Operator\n\n**Bitweises NICHT (`~`)**\n```hemlock\nlet a = 12;\nprint(~a);      // -13 (Zweierkomplement)\n\nlet c: u8 = 15;   // 00001111 in binr\nprint(~c);        // 240 (11110000) in u8\n```\n\n### Bitweise Beispiele\n\n**Mit vorzeichenlosen Typen:**\n```hemlock\nlet c: u8 = 15;   // 00001111 in binr\nlet d: u8 = 7;    // 00000111 in binr\n\nprint(c & d);     // 7  (00000111)\nprint(c | d);     // 15 (00001111)\nprint(c ^ d);     // 8  (00001000)\nprint(~c);        // 240 (11110000) - in u8\n```\n\n**Typerhaltung:**\n```hemlock\n// Bitweise Operationen erhalten den Typ der Operanden\nlet x: u8 = 255;\nlet result = ~x;  // result ist u8 mit Wert 0\n\nlet y: i32 = 100;\nlet result2 = y << 2;  // result2 ist i32 mit Wert 400\n```\n\n**Gngige Muster:**\n```hemlock\n// Prfen, ob Bit gesetzt ist\nif (flags & 0x04) {\n    print(\"Bit 2 ist gesetzt\");\n}\n\n// Bit setzen\nflags = flags | 0x08;\n\n// Bit lschen\nflags = flags & ~0x02;\n\n// Bit umschalten\nflags = flags ^ 0x01;\n```\n\n### Operatorpraezedenz\n\nBitweise Operatoren folgen C-artiger Przedenz:\n\n1. `~` (unaeres NICHT) - hoechste, gleiche Ebene wie `!` und `-`\n2. `<<`, `>>` (Shifts) - hher als Vergleiche, niedriger als `+`/`-`\n3. `&` (bitweises UND) - hher als `^` und `|`\n4. `^` (bitweises XOR) - zwischen `&` und `|`\n5. `|` (bitweises ODER) - niedriger als `&` und `^`, hher als `&&`\n6. `&&`, `||` (logisch) - niedrigste Przedenz\n\n**Beispiele:**\n```hemlock\n// & hat hhere Przedenz als |\nlet result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12\n\n// Shift hat hhere Przedenz als bitweise Operatoren\nlet result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12\n\n// Klammern fr Klarheit verwenden\nlet result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5\n```\n\n**Wichtige Hinweise:**\n- Bitweise Operatoren funktionieren nur mit Ganzzahltypen (nicht Floats, Strings, etc.)\n- Typpromotion folgt Standardregeln (kleinere Typen werden zu groesseren befrdert)\n- Rechtsshift (`>>`) ist arithmetisch fr vorzeichenbehaftete Typen, logisch fr vorzeichenlose\n- Shift-Betraege werden nicht bereichsgeprueft (Verhalten ist plattformabhaengig fr groe Shifts)\n\n## Operatorpraezedenz (Vollstndig)\n\nVon hoechster zu niedrigster Przedenz:\n\n1. **Unaer**: `!`, `-`, `~`\n2. **Multiplikativ**: `*`, `/`, `%`\n3. **Additiv**: `+`, `-`\n4. **Shift**: `<<`, `>>`\n5. **Relational**: `<`, `>`, `<=`, `>=`\n6. **Gleichheit**: `==`, `!=`\n7. **Bitweises UND**: `&`\n8. **Bitweises XOR**: `^`\n9. **Bitweises ODER**: `|`\n10. **Logisches UND**: `&&`\n11. **Logisches ODER**: `||`\n\n**Klammern fr Klarheit verwenden:**\n```hemlock\n// Unklar\nif (a || b && c) { }\n\n// Klar\nif (a || (b && c)) { }\nif ((a || b) && c) { }\n```\n\n## Gngige Muster\n\n### Muster: Eingabevalidierung\n\n```hemlock\nfn validate_age(age: i32): bool {\n    if (age < 0 || age > 150) {\n        return false;\n    }\n    return true;\n}\n```\n\n### Muster: Bereichsprfung\n\n```hemlock\nfn in_range(value: i32, min: i32, max: i32): bool {\n    return value >= min && value <= max;\n}\n\nif (in_range(score, 0, 100)) {\n    print(\"gueltige Punktzahl\");\n}\n```\n\n### Muster: Zustandsmaschine\n\n```hemlock\nlet state = \"start\";\n\nwhile (true) {\n    switch (state) {\n        case \"start\":\n            print(\"Starte...\");\n            state = \"running\";\n            break;\n\n        case \"running\":\n            if (should_pause) {\n                state = \"paused\";\n            } else if (should_stop) {\n                state = \"stopped\";\n            }\n            break;\n\n        case \"paused\":\n            if (should_resume) {\n                state = \"running\";\n            }\n            break;\n\n        case \"stopped\":\n            print(\"Gestoppt\");\n            break;\n    }\n\n    if (state == \"stopped\") {\n        break;\n    }\n}\n```\n\n### Muster: Iteration mit Filterung\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// Nur gerade Zahlen ausgeben\nfor (let i = 0; i < arr.length; i = i + 1) {\n    if (arr[i] % 2 != 0) {\n        continue;  // Ungerade Zahlen berspringen\n    }\n    print(arr[i]);\n}\n```\n\n### Muster: Fruehes Beenden\n\n```hemlock\nfn find_first_negative(arr: array): i32 {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Fruehes Beenden\n        }\n    }\n    return -1;  // Nicht gefunden\n}\n```\n\n## Best Practices\n\n1. **Immer geschweifte Klammern verwenden** - Auch fr einzeilige Blcke (durch Syntax erzwungen)\n2. **Explizite Bedingungen** - `x == 0` statt `!x` fr Klarheit verwenden\n3. **Tiefe Verschachtelung vermeiden** - Verschachtelte Bedingungen in Funktionen extrahieren\n4. **Fruehe Returns verwenden** - Verschachtelung mit Guard-Klauseln reduzieren\n5. **Komplexe Bedingungen aufteilen** - In benannte boolesche Variablen aufteilen\n6. **Default in Switch** - Immer einen Default-Fall einschliessen\n7. **Fall-Through kommentieren** - Beabsichtigtes Fall-Through explizit machen\n\n## Hufige Fallstricke\n\n### Fallstrick: Zuweisung in Bedingung\n\n```hemlock\n// Das ist NICHT erlaubt (keine Zuweisung in Bedingungen)\nif (x = 10) { }  // FEHLER: Syntaxfehler\n\n// Vergleich stattdessen verwenden\nif (x == 10) { }  // OK\n```\n\n### Fallstrick: Fehlendes Break in Switch\n\n```hemlock\n// Unbeabsichtigtes Fall-Through\nswitch (x) {\n    case 1:\n        print(\"eins\");\n        // Fehlendes break - faellt durch!\n    case 2:\n        print(\"zwei\");  // Wird fr 1 und 2 ausgefhrt\n        break;\n}\n\n// Korrektur: Break hinzufgen\nswitch (x) {\n    case 1:\n        print(\"eins\");\n        break;  // Jetzt korrekt\n    case 2:\n        print(\"zwei\");\n        break;\n}\n```\n\n### Fallstrick: Schleifenvariablen-Gltigkeitsbereich\n\n```hemlock\n// i ist auf die Schleife beschrnkt\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\nprint(i);  // FEHLER: i ist hier nicht definiert\n```\n\n## Beispiele\n\n### Beispiel: FizzBuzz\n\n```hemlock\nfor (let i = 1; i <= 100; i = i + 1) {\n    if (i % 15 == 0) {\n        print(\"FizzBuzz\");\n    } else if (i % 3 == 0) {\n        print(\"Fizz\");\n    } else if (i % 5 == 0) {\n        print(\"Buzz\");\n    } else {\n        print(i);\n    }\n}\n```\n\n### Beispiel: Primzahlpruefung\n\n```hemlock\nfn is_prime(n: i32): bool {\n    if (n < 2) {\n        return false;\n    }\n\n    let i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            return false;\n        }\n        i = i + 1;\n    }\n\n    return true;\n}\n```\n\n### Beispiel: Menuesystem\n\n```hemlock\nfn menu() {\n    while (true) {\n        print(\"1. Start\");\n        print(\"2. Einstellungen\");\n        print(\"3. Beenden\");\n\n        let choice = get_input();\n\n        switch (choice) {\n            case 1:\n                start_game();\n                break;\n            case 2:\n                show_settings();\n                break;\n            case 3:\n                print(\"Auf Wiedersehen!\");\n                return;\n            default:\n                print(\"Ungueltige Auswahl\");\n                break;\n        }\n    }\n}\n```\n\n## Verwandte Themen\n\n- [Functions](#language-guide-functions) - Kontrollfluss mit Funktionsaufrufen und Returns\n- [Error Handling](#language-guide-error-handling) - Kontrollfluss mit Ausnahmen\n- [Types](#language-guide-types) - Typkonvertierungen in Bedingungen\n\n## Siehe auch\n\n- **Syntax**: Siehe [Syntax](#language-guide-syntax) fr Anweisungssyntax-Details\n- **Operatoren**: Siehe [Types](#language-guide-types) fr Typpromotion bei Operationen\n"}, "Sprachhandbuch -> Module": {"id": "language-guide-modules", "content": "# Hemlock Modulsystem\n\nDieses Dokument beschreibt das ES6-artige Import/Export-Modulsystem von Hemlock.\n\n## bersicht\n\nHemlock untersttzt ein dateibasiertes Modulsystem mit ES6-artiger Import/Export-Syntax. Module sind:\n- **Singletons**: Jedes Modul wird einmal geladen und gecacht\n- **Dateibasiert**: Module entsprechen .hml-Dateien auf der Festplatte\n- **Explizit importiert**: Abhngigkeiten werden mit Import-Anweisungen deklariert\n- **Topologisch ausgefhrt**: Abhngigkeiten werden vor abhngigen Modulen ausgefhrt\n\nFr Paketverwaltung und Drittanbieter-Abhngigkeiten siehe [hpm (Hemlock Package Manager)](https://github.com/hemlang/hpm).\n\n## Syntax\n\n### Export-Anweisungen\n\n**Inline benannte Exports:**\n```hemlock\nexport fn add(a, b) {\n    return a + b;\n}\n\nexport const PI = 3.14159;\nexport let counter = 0;\n```\n\n**Export-Liste:**\n```hemlock\nfn add(a, b) { return a + b; }\nfn subtract(a, b) { return a - b; }\n\nexport { add, subtract };\n```\n\n**Export Extern (FFI-Funktionen):**\n```hemlock\nimport \"libc.so.6\";\n\n// FFI-Funktionen zur Verwendung in anderen Modulen exportieren\nexport extern fn strlen(s: string): i32;\nexport extern fn getpid(): i32;\n```\n\nSiehe [FFI-Dokumentation](../advanced/ffi.md#exporting-ffi-functions) fr weitere Details zum Exportieren von FFI-Funktionen.\n\n**Export Define (Struct-Typen):**\n```hemlock\n// Struct-Typdefinitionen exportieren\nexport define Vector2 {\n    x: f32,\n    y: f32,\n}\n\nexport define Rectangle {\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n}\n```\n\n**Wichtig:** Exportierte Struct-Typen werden global registriert, wenn das Modul geladen wird. Sie werden automatisch verfgbar, wenn Sie etwas aus dem Modul importieren - Sie mssen (und knnen) sie NICHT explizit nach Namen importieren:\n\n```hemlock\n// GUT - Struct-Typen sind nach jedem Import automatisch verfgbar\nimport { some_function } from \"./my_module.hml\";\nlet v: Vector2 = { x: 1.0, y: 2.0 };  // Funktioniert!\n\n// SCHLECHT - Struct-Typen knnen nicht explizit importiert werden\nimport { Vector2 } from \"./my_module.hml\";  // Fehler: Undefinierte Variable 'Vector2'\n```\n\nSiehe [FFI-Dokumentation](../advanced/ffi.md#exporting-struct-types) fr weitere Details zum Exportieren von Struct-Typen.\n\n**Re-Exports:**\n```hemlock\n// Aus einem anderen Modul re-exportieren\nexport { add, subtract } from \"./math.hml\";\n```\n\n### Import-Anweisungen\n\n**Benannte Imports:**\n```hemlock\nimport { add, subtract } from \"./math.hml\";\nprint(add(1, 2));  // 3\n```\n\n**Namespace-Import:**\n```hemlock\nimport * as math from \"./math.hml\";\nprint(math.add(1, 2));  // 3\nprint(math.PI);  // 3.14159\n```\n\n**Aliasing:**\n```hemlock\nimport { add as sum, subtract as diff } from \"./math.hml\";\nprint(sum(1, 2));  // 3\n```\n\n## Modulaufloesung\n\n### Pfadtypen\n\n**Relative Pfade:**\n```hemlock\nimport { foo } from \"./module.hml\";       // Gleiches Verzeichnis\nimport { bar } from \"../parent.hml\";      // Uebergeordnetes Verzeichnis\nimport { baz } from \"./sub/nested.hml\";   // Unterverzeichnis\n```\n\n**Absolute Pfade:**\n```hemlock\nimport { foo } from \"/absolute/path/to/module.hml\";\n```\n\n**Erweiterungsbehandlung:**\n- Die `.hml`-Erweiterung kann weggelassen werden - sie wird automatisch hinzugefgt\n- `./math` wird zu `./math.hml` aufgelst\n\n## Funktionen\n\n### Erkennung zirkulaerer Abhngigkeiten\n\nDas Modulsystem erkennt zirkulaere Abhngigkeiten und meldet einen Fehler:\n\n```\nError: Circular dependency detected when loading '/path/to/a.hml'\n```\n\n### Modul-Caching\n\nModule werden einmal geladen und gecacht. Mehrere Imports desselben Moduls geben dieselbe Instanz zurck:\n\n```hemlock\n// counter.hml\nexport let count = 0;\nexport fn increment() {\n    count = count + 1;\n}\n\n// a.hml\nimport { count, increment } from \"./counter.hml\";\nincrement();\nprint(count);  // 1\n\n// b.hml\nimport { count } from \"./counter.hml\";  // Dieselbe Instanz!\nprint(count);  // Immer noch 1 (geteilter Zustand)\n```\n\n### Import-Unvernderlichkeit\n\nImportierte Bindungen knnen nicht neu zugewiesen werden:\n\n```hemlock\nimport { add } from \"./math.hml\";\nadd = fn() { };  // FEHLER: kann importierte Bindung nicht neu zuweisen\n```\n\n## Implementierungsdetails\n\n### Architektur\n\n**Dateien:**\n- `include/module.h` - Modulsystem-API\n- `src/module.c` - Modulladen, Caching und Ausfhrung\n- Parser-Untersttzung in `src/parser.c`\n- Laufzeit-Untersttzung in `src/interpreter/runtime.c`\n\n**Schluesselkomponenten:**\n1. **ModuleCache**: Verwaltet geladene Module, indiziert nach absolutem Pfad\n2. **Module**: Repraesentiert ein geladenes Modul mit seinem AST und Exports\n3. **Pfadaufloesung**: Loest relative/absolute Pfade zu kanonischen Pfaden auf\n4. **Topologische Ausfhrung**: Fuehrt Module in Abhaengigkeitsreihenfolge aus\n\n### Modulladeprozess\n\n1. **Parse-Phase**: Tokenisieren und Parsen der Moduldatei\n2. **Abhaengigkeitsaufloesung**: Rekursives Laden importierter Module\n3. **Zykluserkennung**: Prfen, ob das Modul bereits geladen wird\n4. **Caching**: Modul im Cache nach absolutem Pfad speichern\n5. **Ausfuehrungsphase**: Ausfhrung in topologischer Reihenfolge (Abhngigkeiten zuerst)\n\n### API\n\n```c\n// High-Level-API\nint execute_file_with_modules(const char *file_path,\n                               int argc, char **argv,\n                               ExecutionContext *ctx);\n\n// Low-Level-API\nModuleCache* module_cache_new(const char *initial_dir);\nvoid module_cache_free(ModuleCache *cache);\nModule* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);\nvoid execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);\n```\n\n## Testen\n\nTestmodule befinden sich in `tests/modules/` und `tests/parity/modules/`:\n\n- `math.hml` - Basismodul mit Exports\n- `test_import_named.hml` - Test fr benannte Imports\n- `test_import_namespace.hml` - Test fr Namespace-Imports\n- `test_import_alias.hml` - Test fr Import-Aliasing\n- `export_extern.hml` - Test fr Export extern FFI-Funktion (Linux)\n\n## Paket-Imports (hpm)\n\nMit installiertem [hpm](https://github.com/hemlang/hpm) knnen Sie Drittanbieter-Pakete von GitHub importieren:\n\n```hemlock\n// Import aus Paket-Root (verwendet \"main\" aus package.json)\nimport { app, router } from \"hemlang/sprout\";\n\n// Import aus Unterpfad\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// Standardbibliothek (in Hemlock eingebaut)\nimport { HashMap } from \"@stdlib/collections\";\n```\n\nPakete werden in `hem_modules/` installiert und mit GitHub `owner/repo`-Syntax aufgelst.\n\n```bash\n# Ein Paket installieren\nhpm install hemlang/sprout\n\n# Mit Versionsbeschraenkung installieren\nhpm install hemlang/sprout@^1.0.0\n```\n\nSiehe die [hpm-Dokumentation](https://github.com/hemlang/hpm) fr vollstndige Details.\n\n## Aktuelle Einschrnkungen\n\n1. **Keine dynamischen Imports**: `import()` als Laufzeitfunktion wird nicht untersttzt\n2. **Keine bedingten Exports**: Exports mssen auf oberster Ebene sein\n3. **Statische Bibliothekspfade**: FFI-Bibliotheksimports verwenden statische Pfade (plattformspezifisch)\n\n## Zukuenftige Arbeit\n\n- Dynamische Imports mit `import()`-Funktion\n- Bedingte Exports\n- Modul-Metadaten (`import.meta`)\n- Tree Shaking und Eliminierung von totem Code\n\n## Beispiele\n\nSiehe `tests/modules/` fr funktionierende Beispiele des Modulsystems.\n\nBeispiel-Modulstruktur:\n```\nproject/\n main.hml\n lib/\n    math.hml\n    string.hml\n    index.hml (Barrel-Modul)\n utils/\n     helpers.hml\n```\n\nBeispielverwendung:\n```hemlock\n// lib/math.hml\nexport fn add(a, b) { return a + b; }\nexport fn multiply(a, b) { return a * b; }\n\n// lib/index.hml (Barrel)\nexport { add, multiply } from \"./math.hml\";\n\n// main.hml\nimport { add } from \"./lib/index.hml\";\nprint(add(2, 3));  // 5\n```\n"}, "Sprachhandbuch -> Musterabgleich": {"id": "language-guide-pattern-matching", "content": "# Pattern Matching\n\nHemlock bietet leistungsfaehiges Pattern Matching durch `match`-Ausdrcke, die eine praegnante Mglichkeit bieten, Werte zu destrukturieren, Typen zu prfen und mehrere Faelle zu behandeln.\n\n## Grundlegende Syntax\n\n```hemlock\nlet result = match (value) {\n    pattern1 => expression1,\n    pattern2 => expression2,\n    _ => default_expression\n};\n```\n\nMatch-Ausdrcke werten `value` gegen jedes Pattern der Reihe nach aus und geben das Ergebnis des Ausdrucks des ersten passenden Arms zurck.\n\n## Pattern-Typen\n\n### Literal-Patterns\n\nExakte Werte abgleichen:\n\n```hemlock\nlet x = 42;\nlet msg = match (x) {\n    0 => \"null\",\n    1 => \"eins\",\n    42 => \"die Antwort\",\n    _ => \"andere\"\n};\nprint(msg);  // \"die Antwort\"\n```\n\nUnterstuetzte Literale:\n- **Ganzzahlen**: `0`, `42`, `-5`\n- **Fliesskommazahlen**: `3.14`, `-0.5`\n- **Strings**: `\"hello\"`, `\"world\"`\n- **Booleans**: `true`, `false`\n- **Null**: `null`\n\n### Wildcard-Pattern (`_`)\n\nPasst auf jeden Wert ohne Bindung:\n\n```hemlock\nlet x = \"anything\";\nlet result = match (x) {\n    \"specific\" => \"gefunden\",\n    _ => \"wildcard matched\"\n};\n```\n\n### Variablenbindungs-Patterns\n\nDen gematchten Wert an eine Variable binden:\n\n```hemlock\nlet x = 100;\nlet result = match (x) {\n    0 => \"null\",\n    n => \"Wert ist \" + n  // n wird an 100 gebunden\n};\nprint(result);  // \"Wert ist 100\"\n```\n\n### ODER-Patterns (`|`)\n\nMehrere Alternativen abgleichen:\n\n```hemlock\nlet x = 2;\nlet size = match (x) {\n    1 | 2 | 3 => \"klein\",\n    4 | 5 | 6 => \"mittel\",\n    _ => \"gro\"\n};\n\n// Funktioniert auch mit Strings\nlet cmd = \"quit\";\nlet action = match (cmd) {\n    \"exit\" | \"quit\" | \"q\" => \"beende\",\n    \"help\" | \"h\" | \"?\" => \"zeige Hilfe\",\n    _ => \"unbekannt\"\n};\n```\n\n### Guard-Ausdrcke (`if`)\n\nBedingungen zu Patterns hinzufgen:\n\n```hemlock\nlet x = 15;\nlet category = match (x) {\n    n if n < 0 => \"negativ\",\n    n if n == 0 => \"null\",\n    n if n < 10 => \"klein\",\n    n if n < 100 => \"mittel\",\n    n => \"gro: \" + n\n};\nprint(category);  // \"mittel\"\n\n// Komplexe Guards\nlet y = 12;\nlet result = match (y) {\n    n if n % 2 == 0 && n > 10 => \"gerade und grer als 10\",\n    n if n % 2 == 0 => \"gerade\",\n    n => \"ungerade\"\n};\n```\n\n### Typ-Patterns\n\nBasierend auf Typ prfen und binden:\n\n```hemlock\nlet val = 42;\nlet desc = match (val) {\n    num: i32 => \"Ganzzahl: \" + num,\n    str: string => \"String: \" + str,\n    flag: bool => \"Boolean: \" + flag,\n    _ => \"anderer Typ\"\n};\nprint(desc);  // \"Ganzzahl: 42\"\n```\n\nUnterstuetzte Typen: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`, `bool`, `string`, `array`, `object`\n\n## Destrukturierungs-Patterns\n\n### Objekt-Destrukturierung\n\nFelder aus Objekten extrahieren:\n\n```hemlock\nlet point = { x: 10, y: 20 };\nlet result = match (point) {\n    { x, y } => \"Punkt bei \" + x + \",\" + y\n};\nprint(result);  // \"Punkt bei 10,20\"\n\n// Mit literalen Feldwerten\nlet origin = { x: 0, y: 0 };\nlet name = match (origin) {\n    { x: 0, y: 0 } => \"Ursprung\",\n    { x: 0, y } => \"auf y-Achse bei \" + y,\n    { x, y: 0 } => \"auf x-Achse bei \" + x,\n    { x, y } => \"Punkt bei \" + x + \",\" + y\n};\nprint(name);  // \"Ursprung\"\n```\n\n### Array-Destrukturierung\n\nArray-Struktur und Elemente abgleichen:\n\n```hemlock\nlet arr = [1, 2, 3];\nlet desc = match (arr) {\n    [] => \"leer\",\n    [x] => \"einzeln: \" + x,\n    [x, y] => \"Paar: \" + x + \",\" + y,\n    [x, y, z] => \"Tripel: \" + x + \",\" + y + \",\" + z,\n    _ => \"viele Elemente\"\n};\nprint(desc);  // \"Tripel: 1,2,3\"\n\n// Mit literalen Werten\nlet pair = [1, 2];\nlet result = match (pair) {\n    [0, 0] => \"beide null\",\n    [1, x] => \"beginnt mit 1, zweites ist \" + x,\n    [x, 1] => \"endet mit 1\",\n    _ => \"andere\"\n};\nprint(result);  // \"beginnt mit 1, zweites ist 2\"\n```\n\n### Array-Rest-Patterns (`...`)\n\nVerbleibende Elemente erfassen:\n\n```hemlock\nlet nums = [1, 2, 3, 4, 5];\n\n// Kopf und Rest\nlet result = match (nums) {\n    [first, ...rest] => \"erstes: \" + first,\n    [] => \"leer\"\n};\nprint(result);  // \"erstes: 1\"\n\n// Erste zwei Elemente\nlet result2 = match (nums) {\n    [a, b, ...rest] => \"erste zwei: \" + a + \",\" + b,\n    _ => \"zu kurz\"\n};\nprint(result2);  // \"erste zwei: 1,2\"\n```\n\n### Verschachtelte Destrukturierung\n\nPatterns fr komplexe Daten kombinieren:\n\n```hemlock\nlet user = {\n    name: \"Alice\",\n    address: { city: \"NYC\", zip: 10001 }\n};\n\nlet result = match (user) {\n    { name, address: { city, zip } } => name + \" lebt in \" + city,\n    _ => \"unbekannt\"\n};\nprint(result);  // \"Alice lebt in NYC\"\n\n// Objekt mit Array\nlet data = { items: [1, 2, 3], count: 3 };\nlet result2 = match (data) {\n    { items: [first, ...rest], count } => \"erstes: \" + first + \", gesamt: \" + count,\n    _ => \"keine Elemente\"\n};\nprint(result2);  // \"erstes: 1, gesamt: 3\"\n```\n\n## Match als Ausdruck\n\nMatch ist ein Ausdruck, der einen Wert zurckgibt:\n\n```hemlock\n// Direkte Zuweisung\nlet grade = 85;\nlet letter = match (grade) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    n if n >= 70 => \"C\",\n    n if n >= 60 => \"D\",\n    _ => \"F\"\n};\n\n// In String-Verkettung\nlet msg = \"Note: \" + match (grade) {\n    n if n >= 70 => \"bestanden\",\n    _ => \"durchgefallen\"\n};\n\n// In Funktionsrueckgabe\nfn classify(n: i32): string {\n    return match (n) {\n        0 => \"null\",\n        n if n > 0 => \"positiv\",\n        _ => \"negativ\"\n    };\n}\n```\n\n## Best Practices fr Pattern Matching\n\n1. **Reihenfolge ist wichtig**: Patterns werden von oben nach unten geprft; setzen Sie spezifische Patterns vor allgemeine\n2. **Wildcards fr Vollstaendigkeit**: Fuegen Sie immer einen `_`-Fallback ein, auer Sie sind sicher, dass alle Faelle abgedeckt sind\n3. **Guards statt verschachtelter Bedingungen bevorzugen**: Guards machen die Absicht klarer\n4. **Destrukturierung statt manuellem Feldzugriff bevorzugen**: Praegnanter und sicherer\n\n```hemlock\n// Gut: Guards fr Bereichsprfung\nmatch (score) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    _ => \"unter B\"\n}\n\n// Gut: Destrukturieren statt Feldzugriff\nmatch (point) {\n    { x: 0, y: 0 } => \"Ursprung\",\n    { x, y } => \"bei \" + x + \",\" + y\n}\n\n// Vermeiden: Ueberkomplexe verschachtelte Patterns\n// Stattdessen in mehrere Matches aufteilen oder Guards verwenden\n```\n\n## Vergleich mit anderen Sprachen\n\n| Feature | Hemlock | Rust | JavaScript |\n|---------|---------|------|------------|\n| Basis-Matching | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |\n| Destrukturierung | Ja | Ja | Teilweise (switch destrukturiert nicht) |\n| Guards | `n if n > 0 =>` | `n if n > 0 =>` | N/A |\n| ODER-Patterns | `1 \\| 2 \\| 3 =>` | `1 \\| 2 \\| 3 =>` | `case 1: case 2: case 3:` |\n| Rest-Patterns | `[a, ...rest]` | `[a, rest @ ..]` | N/A |\n| Typ-Patterns | `n: i32` | Typ via `match`-Arm | N/A |\n| Gibt Wert zurck | Ja | Ja | Nein (Statement) |\n\n## Implementierungshinweise\n\nPattern Matching ist sowohl im Interpreter- als auch im Compiler-Backend mit voller Paritaet implementiert - beide erzeugen identische Ergebnisse fr dieselbe Eingabe. Das Feature ist ab Hemlock v1.8.0 verfgbar.\n"}, "Sprachhandbuch -> Objekte": {"id": "language-guide-objects", "content": "# Objekte\n\nHemlock implementiert JavaScript-hnliche Objekte mit Heap-Allokation, dynamischen Feldern, Methoden und Duck-Typing. Objekte sind flexible Datenstrukturen, die Daten und Verhalten kombinieren.\n\n## berblick\n\n```hemlock\n// Anonymes Objekt\nlet person = { name: \"Alice\", age: 30, city: \"NYC\" };\nprint(person.name);  // \"Alice\"\n\n// Objekt mit Methoden\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## Objektliterale\n\n### Grundlegende Syntax\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n```\n\n**Syntax:**\n- Geschweifte Klammern `{}` umschliessen das Objekt\n- Schlssel-Wert-Paare durch Kommas getrennt\n- Schlssel sind Bezeichner (keine Anfhrungszeichen ntig)\n- Werte knnen jeden Typ haben\n\n### Leere Objekte\n\n```hemlock\nlet obj = {};  // Leeres Objekt\n\n// Felder spter hinzufgen\nobj.name = \"Alice\";\nobj.age = 30;\n```\n\n### Verschachtelte Objekte\n\n```hemlock\nlet user = {\n    info: {\n        name: \"Bob\",\n        age: 25\n    },\n    active: true,\n    settings: {\n        theme: \"dark\",\n        notifications: true\n    }\n};\n\nprint(user.info.name);           // \"Bob\"\nprint(user.settings.theme);      // \"dark\"\n```\n\n### Gemischte Werttypen\n\n```hemlock\nlet mixed = {\n    number: 42,\n    text: \"hello\",\n    flag: true,\n    data: null,\n    items: [1, 2, 3],\n    config: { x: 10, y: 20 }\n};\n```\n\n### Kurzschreibweise fr Eigenschaften\n\nWenn ein Variablenname mit dem Eigenschaftsnamen bereinstimmt, verwenden Sie die Kurzschreibweise:\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\nlet active = true;\n\n// Kurzschreibweise: { name } ist quivalent zu { name: name }\nlet person = { name, age, active };\n\nprint(person.name);   // \"Alice\"\nprint(person.age);    // 30\nprint(person.active); // true\n```\n\n**Kurzschreibweise mit regulaeren Eigenschaften mischen:**\n```hemlock\nlet city = \"NYC\";\nlet obj = { name, age, city, role: \"admin\" };\n```\n\n### Spread-Operator\n\nDer Spread-Operator (`...`) kopiert alle Felder von einem Objekt in ein anderes:\n\n```hemlock\nlet base = { x: 1, y: 2 };\nlet extended = { ...base, z: 3 };\n\nprint(extended.x);  // 1\nprint(extended.y);  // 2\nprint(extended.z);  // 3\n```\n\n**Werte mit Spread ueberschreiben:**\n```hemlock\nlet defaults = { theme: \"light\", size: \"medium\", debug: false };\nlet custom = { ...defaults, theme: \"dark\" };\n\nprint(custom.theme);  // \"dark\" (berschrieben)\nprint(custom.size);   // \"medium\" (von defaults)\nprint(custom.debug);  // false (von defaults)\n```\n\n**Mehrere Spreads (sptere Spreads ueberschreiben fruehere):**\n```hemlock\nlet a = { x: 1 };\nlet b = { y: 2 };\nlet merged = { ...a, ...b, z: 3 };\n\nprint(merged.x);  // 1\nprint(merged.y);  // 2\nprint(merged.z);  // 3\n\n// Spaeterer Spread berschreibt frueheren\nlet first = { val: \"first\" };\nlet second = { val: \"second\" };\nlet combined = { ...first, ...second };\nprint(combined.val);  // \"second\"\n```\n\n**Kurzschreibweise und Spread kombinieren:**\n```hemlock\nlet status = \"active\";\nlet data = { id: 1, name: \"Item\" };\nlet full = { ...data, status };\n\nprint(full.id);      // 1\nprint(full.name);    // \"Item\"\nprint(full.status);  // \"active\"\n```\n\n**Konfigurationsueberschreibungsmuster:**\n```hemlock\nlet defaultConfig = {\n    debug: false,\n    timeout: 30,\n    retries: 3\n};\n\nlet prodConfig = { ...defaultConfig, timeout: 60 };\nlet devConfig = { ...defaultConfig, debug: true };\n\nprint(prodConfig.timeout);  // 60\nprint(devConfig.debug);     // true\n```\n\n**Hinweis:** Spread fhrt eine flache Kopie durch. Verschachtelte Objekte teilen Referenzen:\n```hemlock\nlet nested = { inner: { val: 42 } };\nlet copied = { ...nested };\nprint(copied.inner.val);  // 42 (gleiche Referenz wie nested.inner)\n```\n\n## Feldzugriff\n\n### Punkt-Notation\n\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\n\n// Feld lesen\nlet name = person.name;      // \"Alice\"\nlet age = person.age;        // 30\n\n// Feld ndern\nperson.age = 31;\nprint(person.age);           // 31\n```\n\n### Dynamisches Hinzufgen von Feldern\n\nNeue Felder zur Laufzeit hinzufgen:\n\n```hemlock\nlet person = { name: \"Alice\" };\n\n// Neues Feld hinzufgen\nperson.email = \"alice@example.com\";\nperson.phone = \"555-1234\";\n\nprint(person.email);  // \"alice@example.com\"\n```\n\n### Feldloeschung\n\n**Hinweis:** Feldloeschung wird derzeit nicht untersttzt. Setzen Sie stattdessen auf `null`:\n\n```hemlock\nlet obj = { x: 10, y: 20 };\n\n// Felder knnen nicht gelscht werden (nicht untersttzt)\n// obj.x = undefined;  // Kein 'undefined' in Hemlock\n\n// Workaround: Auf null setzen\nobj.x = null;\n```\n\n## Methoden und `self`\n\n### Methoden definieren\n\nMethoden sind Funktionen, die in Objektfeldern gespeichert sind:\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    decrement: fn() {\n        self.count = self.count - 1;\n    },\n    get: fn() {\n        return self.count;\n    }\n};\n```\n\n### Das Schlsselwort `self`\n\nWenn eine Funktion als Methode aufgerufen wird, wird `self` automatisch an das Objekt gebunden:\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;  // self verweist auf counter\n    }\n};\n\ncounter.increment();  // self ist an counter gebunden\nprint(counter.count);  // 1\n```\n\n**Funktionsweise:**\n- Methodenaufrufe werden erkannt, indem geprft wird, ob der Funktionsausdruck ein Eigenschaftszugriff ist\n- `self` wird automatisch zum Aufrufzeitpunkt an das Objekt gebunden\n- `self` ist schreibgeschuetzt (man kann `self` selbst nicht neu zuweisen)\n\n### Methodenaufruf-Erkennung\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() {\n        return self.value;\n    }\n};\n\n// Als Methode aufgerufen - self ist gebunden\nprint(obj.method());  // 10\n\n// Als Funktion aufgerufen - self ist null (Fehler)\nlet f = obj.method;\nprint(f());  // FEHLER: self ist nicht definiert\n```\n\n### Methoden mit Parametern\n\n```hemlock\nlet calculator = {\n    result: 0,\n    add: fn(x) {\n        self.result = self.result + x;\n    },\n    multiply: fn(x) {\n        self.result = self.result * x;\n    },\n    get: fn() {\n        return self.result;\n    }\n};\n\ncalculator.add(5);\ncalculator.multiply(2);\nprint(calculator.get());  // 10\n```\n\n## Typdefinitionen mit `define`\n\n### Grundlegende Typdefinition\n\nObjektstrukturen mit `define` definieren:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active: bool,\n}\n\n// Objekt erstellen und typisierter Variable zuweisen\nlet p = { name: \"Alice\", age: 30, active: true };\nlet typed_p: Person = p;  // Duck-Typing validiert Struktur\n\nprint(typeof(typed_p));  // \"Person\"\n```\n\n**Was `define` macht:**\n- Deklariert einen Typ mit erforderlichen Feldern\n- Ermglicht Duck-Typing-Validierung\n- Setzt den Typnamen des Objekts fr `typeof()`\n\n### Duck-Typing\n\nObjekte werden gegen `define` mittels **struktureller Kompatibilitaet** validiert:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK: Hat alle erforderlichen Felder\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK: Zustzliche Felder sind erlaubt\nlet p2: Person = {\n    name: \"Bob\",\n    age: 25,\n    city: \"NYC\",\n    active: true\n};\n\n// FEHLER: Fehlendes erforderliches Feld 'age'\nlet p3: Person = { name: \"Carol\" };\n\n// FEHLER: Falscher Typ fr 'age'\nlet p4: Person = { name: \"Dave\", age: \"dreissig\" };\n```\n\n**Duck-Typing-Regeln:**\n- Alle erforderlichen Felder mssen vorhanden sein\n- Feldtypen mssen bereinstimmen\n- Zustzliche Felder sind erlaubt und werden beibehalten\n- Validierung erfolgt zum Zuweisungszeitpunkt\n\n### Optionale Felder\n\nFelder knnen mit Standardwerten optional sein:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,       // Optional mit Standardwert\n    nickname?: string,   // Optional, Standard ist null\n}\n\n// Objekt mit nur erforderlichen Feldern\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.active);    // true (Standard angewendet)\nprint(typed_p.nickname);  // null (kein Standard)\n\n// Optionale Felder knnen berschrieben werden\nlet p2: Person = { name: \"Bob\", age: 25, active: false };\nprint(p2.active);  // false (berschrieben)\n```\n\n**Syntax fr optionale Felder:**\n- `field?: default_value` - Optional mit Standard\n- `field?: type` - Optional mit Typannotation, Standard ist null\n- Optionale Felder werden beim Duck-Typing hinzugefgt, falls fehlend\n\n### Typprfung\n\n```hemlock\ndefine Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = { x: 10, y: 20 };\nlet point: Point = p;  // Typprfung erfolgt hier\n\nprint(typeof(point));  // \"Point\"\nprint(typeof(p));      // \"object\" (Original ist immer noch anonym)\n```\n\n**Wann Typprfung erfolgt:**\n- Zum Zuweisungszeitpunkt an typisierte Variable\n- Validiert, dass alle erforderlichen Felder vorhanden sind\n- Validiert, dass Feldtypen bereinstimmen (mit impliziten Konvertierungen)\n- Setzt den Typnamen des Objekts\n\n## Methodensignaturen in Define\n\nDefine-Blcke knnen Methodensignaturen spezifizieren und erstellen Interface-hnliche Vertrge:\n\n### Erforderliche Methoden\n\n```hemlock\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32;  // Erforderliche Methodensignatur\n}\n\n// Objekte mssen die erforderliche Methode bereitstellen\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n```\n\n### Optionale Methoden\n\n```hemlock\ndefine Serializable {\n    fn serialize(): string;       // Erforderlich\n    fn pretty?(): string;         // Optionale Methode (kann fehlen)\n}\n```\n\n### Der `Self`-Typ\n\n`Self` verweist auf den zu definierenden Typ und ermglicht rekursive Typdefinitionen:\n\n```hemlock\ndefine Cloneable {\n    fn clone(): Self;  // Gibt denselben Typ wie das Objekt zurck\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;  // Nimmt denselben Typ als Parameter\n    fn equals(other: Self): bool;\n}\n\nlet item: Cloneable = {\n    value: 42,\n    clone: fn() {\n        return { value: self.value, clone: self.clone };\n    }\n};\n```\n\n### Gemischte Felder und Methoden\n\n```hemlock\ndefine Entity {\n    id: i32,\n    name: string,\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\nlet user: Entity = {\n    id: 1,\n    name: \"Alice\",\n    validate: fn() { return self.id > 0 && self.name != \"\"; },\n    serialize: fn() { return '{\"id\":' + self.id + ',\"name\":\"' + self.name + '\"}'; }\n};\n```\n\n## Zusammengesetzte Typen (Schnittmengentypen)\n\nZusammengesetzte Typen verwenden `&`, um zu verlangen, dass ein Objekt mehrere Typdefinitionen erfllt:\n\n### Grundlegende zusammengesetzte Typen\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\n// Zusammengesetzter Typ: Objekt muss ALLE Typen erfllen\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n```\n\n### Funktionsparameter mit zusammengesetzten Typen\n\n```hemlock\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" ist \" + p.age);\n}\n\ngreet({ name: \"Bob\", age: 25, city: \"NYC\" });  // Zustzliche Felder OK\n```\n\n### Drei oder mehr Typen\n\n```hemlock\ndefine HasEmail { email: string }\n\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n### Typaliasse fr zusammengesetzte Typen\n\n```hemlock\n// Benannten Alias fr zusammengesetzten Typ erstellen\ntype Person = HasName & HasAge;\ntype Employee = HasName & HasAge & HasEmail;\n\nlet emp: Employee = {\n    name: \"Charlie\",\n    age: 35,\n    email: \"charlie@example.com\"\n};\n```\n\n**Duck-Typing mit zusammengesetzten Typen:** Zustzliche Felder sind immer erlaubt - das Objekt muss nur mindestens die von allen Komponententypen geforderten Felder haben.\n\n## JSON-Serialisierung\n\n### Zu JSON serialisieren\n\nObjekte in JSON-Strings konvertieren:\n\n```hemlock\n// obj.serialize() - Objekt in JSON-String konvertieren\nlet obj = { x: 10, y: 20, name: \"test\" };\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// Verschachtelte Objekte\nlet nested = { inner: { a: 1, b: 2 }, outer: 3 };\nprint(nested.serialize());  // {\"inner\":{\"a\":1,\"b\":2},\"outer\":3}\n```\n\n### Von JSON deserialisieren\n\nJSON-Strings zurck in Objekte parsen:\n\n```hemlock\n// json.deserialize() - JSON-String in Objekt parsen\nlet json_str = '{\"x\":10,\"y\":20,\"name\":\"test\"}';\nlet obj = json_str.deserialize();\n\nprint(obj.name);   // \"test\"\nprint(obj.x);      // 10\n```\n\n### Zyklenerkennung\n\nZirkulaere Referenzen werden erkannt und verursachen Fehler:\n\n```hemlock\nlet obj = { x: 10 };\nobj.me = obj;  // Zirkulaere Referenz erstellen\n\nobj.serialize();  // FEHLER: serialize() hat zirkulaere Referenz erkannt\n```\n\n### Unterstuetzte Typen\n\nJSON-Serialisierung untersttzt:\n\n- **Zahlen**: i8-i32, u8-u32, f32, f64\n- **Booleans**: true, false\n- **Strings**: Mit Escape-Sequenzen\n- **Null**: null-Wert\n- **Objekte**: Verschachtelte Objekte\n- **Arrays**: Verschachtelte Arrays\n\n**Nicht untersttzt:**\n- Funktionen (werden still ausgelassen)\n- Pointer (Fehler)\n- Buffer (Fehler)\n\n### Fehlerbehandlung\n\nSerialisierung und Deserialisierung knnen Fehler werfen:\n\n```hemlock\n// Ungueltiges JSON wirft einen Fehler\ntry {\n    let bad = \"kein gueltiges json\".deserialize();\n} catch (e) {\n    print(\"Parse-Fehler:\", e);\n}\n\n// Pointer knnen nicht serialisiert werden\nlet obj = { ptr: alloc(10) };\ntry {\n    obj.serialize();\n} catch (e) {\n    print(\"Serialisierungsfehler:\", e);\n}\n```\n\n### Round-Trip-Beispiel\n\nVollstaendiges Beispiel fr Serialisierung und Deserialisierung:\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug: bool\n}\n\n// Erstellen und serialisieren\nlet config: Config = {\n    host: \"localhost\",\n    port: 8080,\n    debug: true\n};\nlet json = config.serialize();\nprint(json);  // {\"host\":\"localhost\",\"port\":8080,\"debug\":true}\n\n// Zurck deserialisieren\nlet restored = json.deserialize();\nprint(restored.host);  // \"localhost\"\nprint(restored.port);  // 8080\n```\n\n## Eingebaute Funktionen\n\n### `typeof(value)`\n\nGibt den Typnamen als String zurck:\n\n```hemlock\nlet obj = { x: 10 };\nprint(typeof(obj));  // \"object\"\n\ndefine Person { name: string, age: i32 }\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(typeof(p));    // \"Person\"\n```\n\n**Rueckgabewerte:**\n- Anonyme Objekte: `\"object\"`\n- Typisierte Objekte: Benutzerdefinierter Typname (z.B. `\"Person\"`)\n\n## Implementierungsdetails\n\n### Speichermodell\n\n- **Heap-allokiert** - Alle Objekte werden auf dem Heap allokiert\n- **Flache Kopie** - Zuweisung kopiert die Referenz, nicht das Objekt\n- **Dynamische Felder** - Gespeichert als dynamische Arrays von Name/Wert-Paaren\n- **Referenzgezhlt** - Objekte werden automatisch freigegeben, wenn der Gltigkeitsbereich endet\n\n### Referenzsemantik\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Flache Kopie (gleiche Referenz)\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (beide verweisen auf dasselbe Objekt)\n```\n\n### Methodenspeicherung\n\nMethoden sind einfach Funktionen, die in Feldern gespeichert sind:\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// method ist eine Funktion, die in obj.method gespeichert ist\nprint(typeof(obj.method));  // \"function\"\n```\n\n## Gngige Muster\n\n### Muster: Konstruktorfunktion\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hallo, ich bin \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hallo, ich bin Alice\"\n```\n\n### Muster: Objekt-Builder\n\n```hemlock\nfn PersonBuilder() {\n    return {\n        name: null,\n        age: null,\n\n        setName: fn(n) {\n            self.name = n;\n            return self;  // Verkettung ermglichen\n        },\n\n        setAge: fn(a) {\n            self.age = a;\n            return self;\n        },\n\n        build: fn() {\n            return { name: self.name, age: self.age };\n        }\n    };\n}\n\nlet person = PersonBuilder()\n    .setName(\"Alice\")\n    .setAge(30)\n    .build();\n```\n\n### Muster: Zustandsobjekt\n\n```hemlock\nlet state = {\n    status: \"idle\",\n    data: null,\n    error: null,\n\n    setState: fn(new_status) {\n        self.status = new_status;\n    },\n\n    setData: fn(new_data) {\n        self.data = new_data;\n        self.status = \"success\";\n    },\n\n    setError: fn(err) {\n        self.error = err;\n        self.status = \"error\";\n    }\n};\n```\n\n### Muster: Konfigurationsobjekt\n\n```hemlock\nlet config = {\n    defaults: {\n        timeout: 30,\n        retries: 3,\n        debug: false\n    },\n\n    get: fn(key) {\n        if (self.defaults[key] != null) {\n            return self.defaults[key];\n        }\n        return null;\n    },\n\n    set: fn(key, value) {\n        self.defaults[key] = value;\n    }\n};\n```\n\n## Best Practices\n\n1. **`define` fr Struktur verwenden** - Erwartete Objektstrukturen dokumentieren\n2. **Factory-Funktionen bevorzugen** - Objekte mit Konstruktoren erstellen\n3. **Objekte einfach halten** - Nicht zu tief verschachteln\n4. **`self`-Verwendung dokumentieren** - Methodenverhalten klar machen\n5. **Bei Zuweisung validieren** - Duck-Typing verwenden, um Fehler frueh zu erkennen\n6. **Zirkulaere Referenzen vermeiden** - Verursachen Serialisierungsfehler\n7. **Optionale Felder verwenden** - Sinnvolle Standardwerte bereitstellen\n\n## Hufige Fallstricke\n\n### Fallstrick: Referenz vs. Wert\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Flache Kopie\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (Ueberraschung! Beide haben sich gendert)\n\n// Um das zu vermeiden: Neues Objekt erstellen\nlet obj3 = { x: obj1.x };  // Tiefe Kopie (manuell)\n```\n\n### Fallstrick: `self` bei Nicht-Methodenaufrufen\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// Funktioniert: Als Methode aufgerufen\nprint(obj.method());  // 10\n\n// FEHLER: Als Funktion aufgerufen\nlet f = obj.method;\nprint(f());  // FEHLER: self ist nicht definiert\n```\n\n### Fallstrick: Rohe Pointer in Objekten\n\n```hemlock\n// Objekte werden automatisch freigegeben, aber rohe Pointer darin NICHT\nfn create_objects() {\n    let obj = { data: alloc(1000) };  // roher ptr braucht manuelles free\n    // obj wird automatisch freigegeben, wenn Bereich endet, aber obj.data leckt!\n}\n\n// Lsung: Rohe Pointer vor Bereichsende freigeben\nfn safe_create() {\n    let obj = { data: alloc(1000) };\n    // ... obj.data verwenden ...\n    free(obj.data);  // Rohen Pointer explizit freigeben\n}  // obj selbst wird automatisch freigegeben\n```\n\n### Fallstrick: Typverwirrung\n\n```hemlock\nlet obj = { x: 10 };\n\ndefine Point { x: i32, y: i32 }\n\n// FEHLER: Fehlendes erforderliches Feld 'y'\nlet p: Point = obj;\n```\n\n## Beispiele\n\n### Beispiel: Vektormathematik\n\n```hemlock\nfn createVector(x, y) {\n    return {\n        x: x,\n        y: y,\n\n        add: fn(other) {\n            return createVector(\n                self.x + other.x,\n                self.y + other.y\n            );\n        },\n\n        length: fn() {\n            return sqrt(self.x * self.x + self.y * self.y);\n        },\n\n        toString: fn() {\n            return \"(\" + typeof(self.x) + \", \" + typeof(self.y) + \")\";\n        }\n    };\n}\n\nlet v1 = createVector(3, 4);\nlet v2 = createVector(1, 2);\nlet v3 = v1.add(v2);\n\nprint(v3.toString());  // \"(4, 6)\"\n```\n\n### Beispiel: Einfache Datenbank\n\n```hemlock\nfn createDatabase() {\n    let records = [];\n    let next_id = 1;\n\n    return {\n        insert: fn(data) {\n            let record = { id: next_id, data: data };\n            records.push(record);\n            next_id = next_id + 1;\n            return record.id;\n        },\n\n        find: fn(id) {\n            let i = 0;\n            while (i < records.length) {\n                if (records[i].id == id) {\n                    return records[i];\n                }\n                i = i + 1;\n            }\n            return null;\n        },\n\n        count: fn() {\n            return records.length;\n        }\n    };\n}\n\nlet db = createDatabase();\nlet id = db.insert({ name: \"Alice\", age: 30 });\nlet record = db.find(id);\nprint(record.data.name);  // \"Alice\"\n```\n\n### Beispiel: Event-Emitter\n\n```hemlock\nfn createEventEmitter() {\n    let listeners = {};\n\n    return {\n        on: fn(event, handler) {\n            if (listeners[event] == null) {\n                listeners[event] = [];\n            }\n            listeners[event].push(handler);\n        },\n\n        emit: fn(event, data) {\n            if (listeners[event] != null) {\n                let i = 0;\n                while (i < listeners[event].length) {\n                    listeners[event][i](data);\n                    i = i + 1;\n                }\n            }\n        }\n    };\n}\n\nlet emitter = createEventEmitter();\n\nemitter.on(\"message\", fn(data) {\n    print(\"Empfangen: \" + data);\n});\n\nemitter.emit(\"message\", \"Hallo!\");\n```\n\n## Einschrnkungen\n\nAktuelle Einschrnkungen:\n\n- **Keine tiefe Kopie** - Verschachtelte Objekte mssen manuell kopiert werden (Spread ist flach)\n- **Keine Wertuebergabe** - Objekte werden immer als Referenz bergeben\n- **Keine berechneten Eigenschaften** - Keine `{[key]: value}`-Syntax\n- **`self` ist schreibgeschuetzt** - Kann `self` in Methoden nicht neu zuweisen\n- **Keine Eigenschaftsloeschung** - Felder knnen nicht entfernt werden, sobald sie hinzugefgt sind\n\n**Hinweis:** Objekte sind referenzgezhlt und werden automatisch freigegeben, wenn der Gltigkeitsbereich endet. Siehe [Speicherverwaltung](memory.md#internal-reference-counting) fr Details.\n\n## Verwandte Themen\n\n- [Functions](#language-guide-functions) - Methoden sind Funktionen, die in Objekten gespeichert sind\n- [Arrays](#language-guide-arrays) - Arrays sind ebenfalls objektaehnlich\n- [Types](#language-guide-types) - Duck-Typing und Typdefinitionen\n- [Error Handling](#language-guide-error-handling) - Fehlerobjekte werfen\n\n## Siehe auch\n\n- **Duck-Typing**: Siehe CLAUDE.md Abschnitt \"Objects\" fr Duck-Typing-Details\n- **JSON**: Siehe CLAUDE.md fr JSON-Serialisierungsdetails\n- **Speicher**: Siehe [Memory](#language-guide-memory) fr Objekt-Allokation\n"}, "Sprachhandbuch -> Runen": {"id": "language-guide-runes", "content": "# Runes\n\nRunes repraesentieren **Unicode-Codepoints** (U+0000 bis U+10FFFF) als eigenstaendigen Typ fr Zeichenmanipulation in Hemlock. Im Gegensatz zu Bytes (u8) sind Runes vollstndige Unicode-Zeichen, die jedes Zeichen in jeder Sprache oder Emoji darstellen knnen.\n\n## berblick\n\n```hemlock\nlet ch = 'A';           // Rune-Literal\nlet emoji = '';       // Multi-Byte-Zeichen als einzelne Rune\nprint(ch);              // 'A'\nprint(emoji);           // U+1F680\n\nlet s = \"Hello \" + '!'; // String + Rune Verkettung\nlet r = '>' + \" msg\";   // Rune + String Verkettung\n```\n\n## Was ist eine Rune?\n\nEine Rune ist ein **32-Bit-Wert**, der einen Unicode-Codepoint repraesentiert:\n\n- **Bereich:** 0 bis 0x10FFFF (1.114.111 gueltige Codepoints)\n- **Kein numerischer Typ** - Wird fr Zeichendarstellung verwendet\n- **Unterschiedlich von u8/char** - Runes sind volles Unicode, u8 sind nur Bytes\n- **Von String-Indexierung zurckgegeben** - `str[0]` gibt eine Rune zurck, kein Byte\n\n**Warum Runes?**\n- Hemlock-Strings sind UTF-8-kodiert\n- Ein einzelnes Unicode-Zeichen kann 1-4 Bytes in UTF-8 sein\n- Runes ermglichen die Arbeit mit vollstaendigen Zeichen, nicht mit Teilbytes\n\n## Rune-Literale\n\n### Grundlegende Syntax\n\nEinfache Anfhrungszeichen kennzeichnen Rune-Literale:\n\n```hemlock\nlet a = 'A';            // ASCII-Zeichen\nlet b = '0';            // Ziffernzeichen\nlet c = '!';            // Satzzeichen\nlet d = ' ';            // Leerzeichen\n```\n\n### Multi-Byte UTF-8 Zeichen\n\nRunes knnen jedes Unicode-Zeichen darstellen:\n\n```hemlock\n// Emoji\nlet rocket = '';      // Emoji (U+1F680)\nlet heart = '';        // Herz (U+2764)\nlet smile = '';       // Grinsendes Gesicht (U+1F600)\n\n// CJK-Zeichen\nlet chinese = '';     // Chinesisch (U+4E2D)\nlet japanese = '';    // Hiragana (U+3042)\nlet korean = '';      // Hangul (U+D55C)\n\n// Symbole\nlet check = '';        // Haekchen (U+2713)\nlet arrow = '';        // Pfeil nach rechts (U+2192)\n```\n\n### Escape-Sequenzen\n\nGngige Escape-Sequenzen fr Sonderzeichen:\n\n```hemlock\nlet newline = '\\n';     // Zeilenumbruch (U+000A)\nlet tab = '\\t';         // Tabulator (U+0009)\nlet backslash = '\\\\';   // Backslash (U+005C)\nlet quote = '\\'';       // Einfaches Anfhrungszeichen (U+0027)\nlet dquote = '\"';       // Doppeltes Anfhrungszeichen (U+0022)\nlet null_char = '\\0';   // Null-Zeichen (U+0000)\nlet cr = '\\r';          // Wagenruecklauf (U+000D)\n```\n\n**Verfuegbare Escape-Sequenzen:**\n- `\\n` - Zeilenumbruch (Line Feed)\n- `\\t` - Horizontaler Tabulator\n- `\\r` - Wagenruecklauf\n- `\\0` - Null-Zeichen\n- `\\\\` - Backslash\n- `\\'` - Einfaches Anfhrungszeichen\n- `\\\"` - Doppeltes Anfhrungszeichen\n\n### Unicode-Escapes\n\nVerwenden Sie `\\u{XXXXXX}`-Syntax fr Unicode-Codepoints (bis zu 6 Hex-Ziffern):\n\n```hemlock\nlet rocket = '\\u{1F680}';   //  Emoji via Unicode-Escape\nlet heart = '\\u{2764}';     //  Herz\nlet ascii = '\\u{41}';       // 'A' via Escape\nlet max = '\\u{10FFFF}';     // Maximaler Unicode-Codepoint\n\n// Fhrende Nullen optional\nlet a = '\\u{41}';           // Gleich wie '\\u{0041}'\nlet b = '\\u{0041}';\n```\n\n**Regeln:**\n- Bereich: `\\u{0}` bis `\\u{10FFFF}`\n- Hex-Ziffern: 1 bis 6 Ziffern\n- Gro-/Kleinschreibung egal: `\\u{1F680}` oder `\\u{1f680}`\n- Werte auerhalb des gueltigen Unicode-Bereichs verursachen Fehler\n\n## String + Rune Verkettung\n\nRunes knnen mit Strings verkettet werden:\n\n```hemlock\n// String + Rune\nlet greeting = \"Hello\" + '!';       // \"Hello!\"\nlet decorated = \"Text\" + '';       // \"Text\"\n\n// Rune + String\nlet prefix = '>' + \" Nachricht\";    // \"> Nachricht\"\nlet bullet = '' + \" Element\";      // \" Element\"\n\n// Mehrfache Verkettungen\nlet msg = \"Hi \" + '' + \" Welt \" + '';  // \"Hi  Welt \"\n\n// Method-Chaining funktioniert\nlet result = ('>' + \" Wichtig\").to_upper();  // \"> WICHTIG\"\n```\n\n**Wie es funktioniert:**\n- Runes werden automatisch in UTF-8 kodiert\n- Whrend der Verkettung in Strings konvertiert\n- Der String-Verkettungsoperator behandelt dies transparent\n\n## Typkonvertierungen\n\nRunes knnen in/von anderen Typen konvertiert werden.\n\n### Integer <-> Rune\n\nKonvertieren zwischen Integers und Runes um mit Codepoint-Werten zu arbeiten:\n\n```hemlock\n// Integer zu Rune (Codepoint-Wert)\nlet code: rune = 65;            // 'A' (ASCII 65)\nlet emoji_code: rune = 128640;  // U+1F680 ()\n\n// Rune zu Integer (Codepoint-Wert erhalten)\nlet r = 'Z';\nlet value: i32 = r;             // 90 (ASCII-Wert)\n\nlet rocket = '';\nlet code: i32 = rocket;         // 128640 (U+1F680)\n```\n\n**Bereichsprfung:**\n- Integer zu Rune: Muss in [0, 0x10FFFF] sein\n- Werte auerhalb des Bereichs verursachen Laufzeitfehler\n- Rune zu Integer: Funktioniert immer (gibt Codepoint zurck)\n\n### Rune -> String\n\nRunes knnen explizit in Strings konvertiert werden:\n\n```hemlock\n// Explizite Konvertierung\nlet ch: string = 'H';           // \"H\"\nlet emoji: string = '';       // \"\"\n\n// Automatisch whrend Verkettung\nlet s = \"\" + 'A';               // \"A\"\nlet s2 = \"x\" + 'y' + \"z\";       // \"xyz\"\n```\n\n### u8 (Byte) -> Rune\n\nJeder u8-Wert (0-255) kann in Rune konvertiert werden:\n\n```hemlock\n// ASCII-Bereich (0-127)\nlet byte: u8 = 65;\nlet rune_val: rune = byte;      // 'A'\n\n// Erweitertes ASCII / Latin-1 (128-255)\nlet extended: u8 = 200;\nlet r: rune = extended;         // U+00C8 (E)\n\n// Hinweis: Werte 0-127 sind ASCII, 128-255 sind Latin-1\n```\n\n### Verkettete Konvertierungen\n\nTypkonvertierungen knnen verkettet werden:\n\n```hemlock\n// i32 -> Rune -> String\nlet code: i32 = 128512;         // Grinsendes Gesicht Codepoint\nlet r: rune = code;             // \nlet s: string = r;              // \"\"\n\n// Alles in einem Ausdruck\nlet emoji: string = 128640;     // Implizit i32 -> Rune -> String ()\n```\n\n## Rune-Operationen\n\n### Ausgabe\n\nWie Runes angezeigt werden haengt vom Codepoint ab:\n\n```hemlock\nlet ascii = 'A';\nprint(ascii);                   // 'A' (in Anfhrungszeichen, druckbares ASCII)\n\nlet emoji = '';\nprint(emoji);                   // U+1F680 (Unicode-Notation fr Nicht-ASCII)\n\nlet tab = '\\t';\nprint(tab);                     // U+0009 (nicht-druckbar als Hex)\n\nlet space = ' ';\nprint(space);                   // ' ' (druckbar)\n```\n\n**Ausgabeformat:**\n- Druckbares ASCII (32-126): Zeichen in Anfhrungszeichen `'A'`\n- Nicht-druckbar oder Unicode: Hex-Notation `U+XXXX`\n\n### Typprfung\n\nVerwenden Sie `typeof()` um zu prfen ob ein Wert eine Rune ist:\n\n```hemlock\nlet r = '';\nprint(typeof(r));               // \"rune\"\n\nlet s = \"text\";\nlet ch = s[0];\nprint(typeof(ch));              // \"rune\" (Indexierung gibt Runes zurck)\n\nlet num = 65;\nprint(typeof(num));             // \"i32\"\n```\n\n### Vergleich\n\nRunes knnen auf Gleichheit verglichen werden:\n\n```hemlock\nlet a = 'A';\nlet b = 'B';\nprint(a == a);                  // true\nprint(a == b);                  // false\n\n// Gro-/Kleinschreibung sensitiv\nlet upper = 'A';\nlet lower = 'a';\nprint(upper == lower);          // false\n\n// Runes knnen mit Integers verglichen werden (Codepoint-Werte)\nprint(a == 65);                 // true (implizite Konvertierung)\nprint('' == 128640);          // true\n```\n\n**Vergleichsoperatoren:**\n- `==` - Gleich\n- `!=` - Ungleich\n- `<`, `>`, `<=`, `>=` - Codepoint-Reihenfolge\n\n```hemlock\nprint('A' < 'B');               // true (65 < 66)\nprint('a' > 'Z');               // true (97 > 90)\n```\n\n## Arbeiten mit String-Indexierung\n\nString-Indexierung gibt Runes zurck, keine Bytes:\n\n```hemlock\nlet s = \"Hello\";\nlet h = s[0];                   // 'H' (Rune)\nlet rocket = s[5];              // '' (Rune)\n\nprint(typeof(h));               // \"rune\"\nprint(typeof(rocket));          // \"rune\"\n\n// Bei Bedarf in String konvertieren\nlet h_str: string = h;          // \"H\"\nlet rocket_str: string = rocket; // \"\"\n```\n\n**Wichtig:** String-Indexierung verwendet Codepoint-Positionen, keine Byte-Offsets:\n\n```hemlock\nlet text = \"Hi!\";\n// Codepoint-Positionen: 0='H', 1='i', 2='', 3='!'\n// Byte-Positionen:      0='H', 1='i', 2-5='', 6='!'\n\nlet r = text[2];                // '' (Codepoint 2)\nprint(typeof(r));               // \"rune\"\n```\n\n## Beispiele\n\n### Beispiel: Zeichenklassifikation\n\n```hemlock\nfn is_digit(r: rune): bool {\n    return r >= '0' && r <= '9';\n}\n\nfn is_upper(r: rune): bool {\n    return r >= 'A' && r <= 'Z';\n}\n\nfn is_lower(r: rune): bool {\n    return r >= 'a' && r <= 'z';\n}\n\nprint(is_digit('5'));           // true\nprint(is_upper('A'));           // true\nprint(is_lower('z'));           // true\n```\n\n### Beispiel: Gro-/Kleinschreibung Konvertierung\n\n```hemlock\nfn to_upper_rune(r: rune): rune {\n    if (r >= 'a' && r <= 'z') {\n        // In Grossbuchstaben konvertieren (32 subtrahieren)\n        let code: i32 = r;\n        code = code - 32;\n        return code;\n    }\n    return r;\n}\n\nfn to_lower_rune(r: rune): rune {\n    if (r >= 'A' && r <= 'Z') {\n        // In Kleinbuchstaben konvertieren (32 addieren)\n        let code: i32 = r;\n        code = code + 32;\n        return code;\n    }\n    return r;\n}\n\nprint(to_upper_rune('a'));      // 'A'\nprint(to_lower_rune('Z'));      // 'z'\n```\n\n### Beispiel: Zeichen-Iteration\n\n```hemlock\nfn print_chars(s: string) {\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        print(\"Position \" + typeof(i) + \": \" + typeof(ch));\n        i = i + 1;\n    }\n}\n\nprint_chars(\"Hi\");\n// Position 0: 'H'\n// Position 1: 'i'\n// Position 2: U+1F680\n```\n\n### Beispiel: Strings aus Runes bauen\n\n```hemlock\nfn repeat_char(ch: rune, count: i32): string {\n    let result = \"\";\n    let i = 0;\n    while (i < count) {\n        result = result + ch;\n        i = i + 1;\n    }\n    return result;\n}\n\nlet line = repeat_char('=', 40);  // \"========================================\"\nlet stars = repeat_char('', 5);  // \"\"\n```\n\n## Gngige Muster\n\n### Muster: Zeichenfilter\n\n```hemlock\nfn filter_digits(s: string): string {\n    let result = \"\";\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        if (ch >= '0' && ch <= '9') {\n            result = result + ch;\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet text = \"abc123def456\";\nlet digits = filter_digits(text);  // \"123456\"\n```\n\n### Muster: Zeichen zaehlen\n\n```hemlock\nfn count_char(s: string, target: rune): i32 {\n    let count = 0;\n    let i = 0;\n    while (i < s.length) {\n        if (s[i] == target) {\n            count = count + 1;\n        }\n        i = i + 1;\n    }\n    return count;\n}\n\nlet text = \"hello world\";\nlet l_count = count_char(text, 'l');  // 3\nlet o_count = count_char(text, 'o');  // 2\n```\n\n## Best Practices\n\n1. **Runes fr Zeichenoperationen verwenden** - Versuchen Sie nicht mit Bytes fr Text zu arbeiten\n2. **String-Indexierung gibt Runes zurck** - Denken Sie daran dass `str[i]` Ihnen eine Rune gibt\n3. **Unicode-bewusste Vergleiche** - Runes behandeln jedes Unicode-Zeichen\n4. **Bei Bedarf konvertieren** - Runes konvertieren einfach in Strings und Integers\n5. **Mit Emoji testen** - Testen Sie Zeichenoperationen immer mit Multi-Byte-Zeichen\n\n## Hufige Fallstricke\n\n### Fallstrick: Rune vs. Byte Verwechslung\n\n```hemlock\n// NICHT: Runes als Bytes behandeln\nlet r: rune = '';\nlet b: u8 = r;              // FEHLER: Rune-Codepoint 128640 passt nicht in u8\n\n// RICHTIG: Passende Konvertierungen verwenden\nlet r: rune = '';\nlet code: i32 = r;          // OK: 128640\n```\n\n### Fallstrick: String Byte-Indexierung\n\n```hemlock\n// NICHT: Byte-Indexierung annehmen\nlet s = \"\";\nlet byte = s.byte_at(0);    // 240 (erstes UTF-8 Byte, nicht vollstaendiges Zeichen)\n\n// RICHTIG: Codepoint-Indexierung verwenden\nlet s = \"\";\nlet rune = s[0];            // '' (vollstaendiges Zeichen)\nlet rune2 = s.char_at(0);   // '' (explizite Methode)\n```\n\n## Verwandte Themen\n\n- [Strings](#language-guide-strings) - String-Operationen und UTF-8-Behandlung\n- [Types](#language-guide-types) - Typsystem und Konvertierungen\n- [Control Flow](#language-guide-control-flow) - Verwendung von Runes in Vergleichen\n\n## Siehe auch\n\n- **Unicode-Standard**: Unicode-Codepoints werden vom Unicode Consortium definiert\n- **UTF-8-Kodierung**: Siehe [Strings](#language-guide-strings) fr UTF-8-Details\n- **Typkonvertierungen**: Siehe [Types](#language-guide-types) fr Konvertierungsregeln\n"}, "Sprachhandbuch -> Speicherverwaltung": {"id": "language-guide-memory", "content": "# Speicherverwaltung\n\nHemlock setzt auf **manuelle Speicherverwaltung** mit expliziter Kontrolle ber Allokation und Deallokation. Dieser Leitfaden behandelt Hemlocks Speichermodell, die zwei Zeigertypen und die vollstndige Speicher-API.\n\n---\n\n## Speicher 101: Die Grundlagen\n\n**Neu in der Programmierung?** Beginnen Sie hier. Wenn Sie Speicherverwaltung bereits verstehen, springen Sie zu [Philosophie](#philosophie).\n\n### Was ist Speicherverwaltung?\n\nWenn Ihr Programm Daten speichern muss (Text, Zahlen, Listen), braucht es Platz dafuer. Dieser Platz kommt aus dem Arbeitsspeicher Ihres Computers (RAM). Bei der Speicherverwaltung geht es um:\n\n1. **Platz bekommen** - Speicher anfordern, wenn Sie ihn brauchen\n2. **Platz nutzen** - Ihre Daten lesen und schreiben\n3. **Zurckgeben** - Speicher zurckgeben, wenn Sie fertig sind\n\n### Warum ist das wichtig?\n\nStellen Sie sich eine Bibliothek mit begrenzten Buechern vor:\n- Wenn Sie stndig Buecher ausleihen und nie zurckgeben, gibt es irgendwann keine mehr\n- Wenn Sie versuchen, ein bereits zurueckgegebenes Buch zu lesen, werden Sie verwirrt oder verursachen Probleme\n\nSpeicher funktioniert genauso. Wenn Sie vergessen, Speicher zurckzugeben, verbraucht Ihr Programm langsam immer mehr (ein \"Speicherleck\"). Wenn Sie versuchen, Speicher nach der Rckgabe zu nutzen, passieren schlimme Dinge.\n\n### Die gute Nachricht\n\n**Meistens mssen Sie nicht darueber nachdenken!**\n\nHemlock raumt die meisten gaengigen Typen automatisch auf:\n\n```hemlock\nfn example() {\n    let name = \"Alice\";       // Hemlock verwaltet dies\n    let numbers = [1, 2, 3];  // Und dies\n    let person = { age: 30 }; // Und dies auch\n\n    // Wenn die Funktion endet, wird alles automatisch aufgeraeumt!\n}\n```\n\n### Wann Sie darueber nachdenken MUESSEN\n\nSie brauchen manuelle Speicherverwaltung nur bei der Verwendung von:\n\n1. **`alloc()`** - rohe Speicherallokation (gibt `ptr` zurck)\n2. **`buffer()`** - wenn Sie frueh freigeben mchten (optional - wird am Scope-Ende automatisch freigegeben)\n\n```hemlock\n// Dies braucht manuelle Bereinigung:\nlet raw = alloc(100);   // Roher Speicher - SIE mssen ihn freigeben\n// ... raw verwenden ...\nfree(raw);              // Erforderlich! Sonst haben Sie ein Speicherleck\n\n// Dies wird automatisch aufgeraeumt (aber Sie KOENNEN frueh freigeben):\nlet buf = buffer(100);  // Sicherer Buffer\n// ... buf verwenden ...\n// free(buf);           // Optional - wird automatisch freigegeben wenn Scope endet\n```\n\n### Die einfache Regel\n\n> **Wenn Sie `alloc()` aufrufen, mssen Sie `free()` aufrufen.**\n>\n> Alles andere wird fr Sie erledigt.\n\n### Was sollten Sie verwenden?\n\n| Situation | Verwenden Sie dies | Warum |\n|-----------|-------------------|-------|\n| **Gerade erst angefangen** | `buffer()` | Sicher, mit Bereichsprfung, automatische Bereinigung |\n| **Byte-Speicherung bentigt** | `buffer()` | Sicher und einfach |\n| **Arbeit mit C-Bibliotheken (FFI)** | `alloc()` / `ptr` | Erforderlich fr C-Interop |\n| **Maximale Leistung** | `alloc()` / `ptr` | Kein Overhead durch Bereichsprfung |\n| **Nicht sicher** | `buffer()` | Immer die sicherere Wahl |\n\n### Schnelles Beispiel: Sicher vs Roh\n\n```hemlock\n// EMPFOHLEN: Sicherer Buffer\nfn safe_example() {\n    let data = buffer(10);\n    data[0] = 65;           // OK\n    data[5] = 66;           // OK\n    // data[100] = 67;      // FEHLER - Hemlock stoppt Sie (Bereichsprfung)\n    free(data);             // Aufraeumen\n}\n\n// FORTGESCHRITTEN: Roher Zeiger (nur wenn Sie ihn brauchen)\nfn raw_example() {\n    let data = alloc(10);\n    *data = 65;             // OK\n    *(data + 5) = 66;       // OK\n    *(data + 100) = 67;     // GEFAHR - Keine Bereichsprfung, beschaedigt Speicher!\n    free(data);             // Aufraeumen\n}\n```\n\n**Beginnen Sie mit `buffer()`. Verwenden Sie `alloc()` nur, wenn Sie speziell rohe Zeiger brauchen.**\n\n---\n\n## Philosophie\n\nHemlock folgt dem Prinzip der expliziten Speicherverwaltung mit vernuenftigen Standardeinstellungen:\n- Keine Garbage Collection (keine unvorhersehbaren Pausen)\n- Internes Referenzzaehlen fr gngige Typen (String, Array, Object, Buffer)\n- Rohe Zeiger (`ptr`) erfordern manuelles `free()`\n\nDieser hybride Ansatz gibt Ihnen vollstndige Kontrolle, wenn ntig (rohe Zeiger), whrend er gngige Fehler fr typische Anwendungsfaelle verhindert (referenzgezaehlte Typen werden beim Scope-Ende automatisch freigegeben).\n\n## Internes Referenzzaehlen\n\nDie Laufzeitumgebung verwendet **internes Referenzzaehlen** zur Verwaltung von Objektlebenszeiten. Fr die meisten lokalen Variablen referenzgezaehlter Typen ist die Bereinigung automatisch und deterministisch.\n\n### Was Referenzzaehlen handhabt\n\nDie Laufzeitumgebung verwaltet Referenzzaehler automatisch, wenn:\n\n1. **Variablen neu zugewiesen werden** - der alte Wert wird freigegeben:\n   ```hemlock\n   let x = \"first\";   // ref_count = 1\n   x = \"second\";      // \"first\" wird intern freigegeben, \"second\" ref_count = 1\n   ```\n\n2. **Scopes beendet werden** - lokale Variablen werden freigegeben:\n   ```hemlock\n   fn example() {\n       let arr = [1, 2, 3];  // ref_count = 1\n   }  // arr wird freigegeben wenn Funktion zurckkehrt\n   ```\n\n3. **Container freigegeben werden** - Elemente werden freigegeben:\n   ```hemlock\n   let arr = [obj1, obj2];\n   free(arr);  // ref_counts von obj1 und obj2 werden dekrementiert\n   ```\n\n### Wann Sie `free()` brauchen vs Wann es automatisch ist\n\n**Automatisch (kein `free()` ntig):** Lokale Variablen referenzgezaehlter Typen werden freigegeben, wenn der Scope endet:\n\n```hemlock\nfn process_data() {\n    let arr = [1, 2, 3];\n    let obj = { name: \"test\" };\n    let buf = buffer(64);\n    // ... verwenden ...\n}  // Alles wird automatisch freigegeben wenn Funktion zurckkehrt - kein free() ntig\n```\n\n**Manuelles `free()` erforderlich:**\n\n1. **Rohe Zeiger** - `alloc()` hat kein Referenzzaehlen:\n   ```hemlock\n   let p = alloc(64);\n   // ... p verwenden ...\n   free(p);  // Immer erforderlich - leckt sonst\n   ```\n\n2. **Fruehe Bereinigung** - vor Scope-Ende freigeben um Speicher frueher freizugeben:\n   ```hemlock\n   fn long_running() {\n       let big = buffer(10000000);  // 10MB\n       // ... fertig mit big ...\n       free(big);  // Jetzt freigeben, nicht auf Funktionsrueckkehr warten\n       // ... mehr Arbeit die big nicht braucht ...\n   }\n   ```\n\n3. **Langlebige Daten** - globale oder in persistenten Strukturen gespeicherte Daten:\n   ```hemlock\n   let cache = {};  // Modul-Ebene, lebt bis Programmende wenn nicht freigegeben\n\n   fn cleanup() {\n       free(cache);  // Manuelle Bereinigung fr langlebige Daten\n   }\n   ```\n\n### Referenzzaehlen vs Garbage Collection\n\n| Aspekt | Hemlock Referenzzaehlen | Garbage Collection |\n|--------|------------------------|-------------------|\n| Bereinigungszeitpunkt | Deterministisch (sofort wenn ref 0 erreicht) | Nicht-deterministisch (GC entscheidet wann) |\n| Benutzerverantwortung | Muss `free()` aufrufen | Vollautomatisch |\n| Laufzeitpausen | Keine | \"Stop the World\"-Pausen |\n| Sichtbarkeit | Verstecktes Implementierungsdetail | Normalerweise unsichtbar |\n| Zyklen | Mit visited-set Tracking behandelt | Durch Tracing behandelt |\n\n### Welche Typen haben Referenzzaehlen\n\n| Typ | Referenzgezhlt | Anmerkungen |\n|-----|-----------------|-------------|\n| `ptr` | Nein | Erfordert immer manuelles `free()` |\n| `buffer` | Ja | Auto-Freigabe bei Scope-Ende; manuelles `free()` fr fruehe Bereinigung |\n| `array` | Ja | Auto-Freigabe bei Scope-Ende; manuelles `free()` fr fruehe Bereinigung |\n| `object` | Ja | Auto-Freigabe bei Scope-Ende; manuelles `free()` fr fruehe Bereinigung |\n| `string` | Ja | Vollautomatisch, kein `free()` ntig |\n| `function` | Ja | Vollautomatisch (Closure-Umgebungen) |\n| `task` | Ja | Thread-sicheres atomares Referenzzaehlen |\n| `channel` | Ja | Thread-sicheres atomares Referenzzaehlen |\n| Primitive | Nein | Stack-allokiert, keine Heap-Allokation |\n\n### Warum dieses Design?\n\nDieser hybride Ansatz gibt Ihnen:\n- **Explizite Kontrolle** - Sie entscheiden, wann deallokiert wird\n- **Sicherheit vor Scope-Fehlern** - Neuzuweisung leckt nicht\n- **Vorhersagbare Leistung** - Keine GC-Pausen\n- **Closure-Untersttzung** - Funktionen knnen sicher Variablen erfassen\n\nDie Philosophie bleibt: Sie haben die Kontrolle, aber die Laufzeit hilft, gngige Fehler wie Lecks bei Neuzuweisung oder Doppel-Freigabe in Containern zu verhindern.\n\n## Die zwei Zeigertypen\n\nHemlock bietet zwei unterschiedliche Zeigertypen, jeder mit verschiedenen Sicherheitseigenschaften:\n\n### `ptr` - Roher Zeiger (Gefaehrlich)\n\nRohe Zeiger sind **nur Adressen** mit minimalen Sicherheitsgarantien:\n\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // Sie mssen daran denken freizugeben\n```\n\n**Eigenschaften:**\n- Nur eine 8-Byte-Adresse\n- Keine Bereichsprfung\n- Keine Laengenverfolgung\n- Benutzer verwaltet Lebensdauer vollstndig\n- Fr Experten und FFI\n\n**Anwendungsfaelle:**\n- Low-Level-Systemprogrammierung\n- Foreign Function Interface (FFI)\n- Leistungskritischer Code\n- Wenn Sie vollstndige Kontrolle brauchen\n\n**Gefahren:**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Weit ber Allokation hinaus - erlaubt aber gefaehrlich\nfree(p);\nlet x = *p;       // Dangling Pointer - undefiniertes Verhalten\nfree(p);          // Double-Free - wird abstuerzen\n```\n\n### `buffer` - Sichere Huelle (Empfohlen)\n\nBuffer bieten **bereichsgeprueften Zugriff** whrend sie weiterhin manuelle Deallokation erfordern:\n\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // bereichsgeprueft\nprint(b.length);        // 64\nfree(b);                // weiterhin manuell\n```\n\n**Eigenschaften:**\n- Zeiger + Lnge + Kapazitt\n- Bereichsgeprueft bei Zugriff\n- Erfordert weiterhin manuelles `free()`\n- Bessere Standardwahl fr den meisten Code\n\n**Properties:**\n```hemlock\nlet buf = buffer(100);\nprint(buf.length);      // 100 (aktuelle Gre)\nprint(buf.capacity);    // 100 (allokierte Kapazitt)\n```\n\n**Bereichsprfung:**\n```hemlock\nlet buf = buffer(10);\nbuf[5] = 42;      // OK\nbuf[100] = 42;    // FEHLER: Index auerhalb der Grenzen\n```\n\n## Speicher-API\n\n### Kernallokation\n\n**`alloc(bytes)` - Rohen Speicher allokieren**\n```hemlock\nlet p = alloc(1024);  // 1KB allokieren, gibt ptr zurck\n// ... Speicher verwenden\nfree(p);\n```\n\n**`buffer(size)` - Sicheren Buffer allokieren**\n```hemlock\nlet buf = buffer(256);  // 256-Byte-Buffer allokieren\nbuf[0] = 65;            // 'A'\nbuf[1] = 66;            // 'B'\nfree(buf);\n```\n\n**`free(ptr)` - Speicher freigeben**\n```hemlock\nlet p = alloc(100);\nfree(p);  // Muss freigegeben werden um Speicherleck zu vermeiden\n\nlet buf = buffer(100);\nfree(buf);  // Funktioniert sowohl fr ptr als auch buffer\n```\n\n**Wichtig:** `free()` funktioniert sowohl fr `ptr`- als auch fr `buffer`-Typen.\n\n### Speicheroperationen\n\n**`memset(ptr, byte, size)` - Speicher fuellen**\n```hemlock\nlet p = alloc(100);\nmemset(p, 0, 100);     // 100 Bytes nullen\nmemset(p, 65, 10);     // Erste 10 Bytes mit 'A' fuellen\nfree(p);\n```\n\n**`memcpy(dest, src, size)` - Speicher kopieren**\n```hemlock\nlet src = alloc(50);\nlet dst = alloc(50);\nmemset(src, 42, 50);\nmemcpy(dst, src, 50);  // 50 Bytes von src nach dst kopieren\nfree(src);\nfree(dst);\n```\n\n**`realloc(ptr, size)` - Allokation anpassen**\n```hemlock\nlet p = alloc(100);\n// ... 100 Bytes verwenden\np = realloc(p, 200);   // Auf 200 Bytes anpassen\n// ... 200 Bytes verwenden\nfree(p);\n```\n\n**Hinweis:** Nach `realloc()` kann der alte Zeiger ungltig sein. Verwenden Sie immer den zurueckgegebenen Zeiger.\n\n### Typisierte Allokation\n\nHemlock bietet typisierte Allokationshelfer fr Bequemlichkeit:\n\n```hemlock\nlet arr = talloc(i32, 100);  // 100 i32-Werte allokieren (400 Bytes)\nlet size = sizeof(i32);      // Gibt 4 zurck (Bytes)\n```\n\n**`sizeof(type)`** gibt die Gre in Bytes eines Typs zurck:\n- `sizeof(i8)` / `sizeof(u8)` -> 1\n- `sizeof(i16)` / `sizeof(u16)` -> 2\n- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` -> 4\n- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` -> 8\n- `sizeof(ptr)` -> 8 (auf 64-Bit-Systemen)\n\n**`talloc(type, count)`** allokiert `count` Elemente vom Typ `type`:\n\n```hemlock\nlet ints = talloc(i32, 10);   // 40 Bytes fr 10 i32-Werte\nlet floats = talloc(f64, 5);  // 40 Bytes fr 5 f64-Werte\nfree(ints);\nfree(floats);\n```\n\n## Gngige Muster\n\n### Muster: Allokieren, Verwenden, Freigeben\n\nDas grundlegende Muster fr Speicherverwaltung:\n\n```hemlock\n// 1. Allokieren\nlet data = alloc(1024);\n\n// 2. Verwenden\nmemset(data, 0, 1024);\n// ... Arbeit erledigen\n\n// 3. Freigeben\nfree(data);\n```\n\n### Muster: Sichere Buffer-Verwendung\n\nBevorzugen Sie Buffer fr bereichsgeprueften Zugriff:\n\n```hemlock\nlet buf = buffer(256);\n\n// Sichere Iteration\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\nfree(buf);\n```\n\n### Muster: Ressourcenverwaltung mit try/finally\n\nSicherstellen der Bereinigung auch bei Fehlern:\n\n```hemlock\nlet data = alloc(1024);\ntry {\n    // ... riskante Operationen\n    process(data);\n} finally {\n    free(data);  // Immer freigegeben, auch bei Fehler\n}\n```\n\n## Ueberlegungen zur Speichersicherheit\n\n### Double-Free\n\n**Erlaubt aber wird abstuerzen:**\n```hemlock\nlet p = alloc(100);\nfree(p);\nfree(p);  // ABSTURZ: Double-Free erkannt\n```\n\n**Praevention:**\n```hemlock\nlet p = alloc(100);\nfree(p);\np = null;  // Nach Freigabe auf null setzen\n\nif (p != null) {\n    free(p);  // Wird nicht ausgefhrt\n}\n```\n\n### Dangling Pointers\n\n**Erlaubt aber undefiniertes Verhalten:**\n```hemlock\nlet p = alloc(100);\n*p = 42;      // OK\nfree(p);\nlet x = *p;   // UNDEFINIERT: Lesen von freigegebenem Speicher\n```\n\n**Praevention:** Greifen Sie nach der Freigabe nicht auf Speicher zu.\n\n### Speicherlecks\n\n**Leicht zu erstellen, schwer zu debuggen:**\n```hemlock\nfn leak_memory() {\n    let p = alloc(1000);\n    // Vergessen freizugeben!\n    return;  // Speicher leckt\n}\n```\n\n**Praevention:** Paaren Sie immer `alloc()` mit `free()`:\n```hemlock\nfn safe_function() {\n    let p = alloc(1000);\n    try {\n        // ... p verwenden\n    } finally {\n        free(p);  // Immer freigegeben\n    }\n}\n```\n\n### Zeigerarithmetik\n\n**Erlaubt aber gefaehrlich:**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Weit ber Allokationsgrenze hinaus\n*q = 42;          // UNDEFINIERT: Schreiben auerhalb der Grenzen\nfree(p);\n```\n\n**Verwenden Sie Buffer fr Bereichsprfung:**\n```hemlock\nlet buf = buffer(10);\nbuf[100] = 42;  // FEHLER: Bereichsprfung verhindert berlauf\n```\n\n## Best Practices\n\n1. **Standardmig `buffer`** - Verwenden Sie `buffer` auer Sie brauchen speziell rohe `ptr`\n2. **alloc/free abgleichen** - Jedes `alloc()` sollte genau ein `free()` haben\n3. **try/finally verwenden** - Bereinigung mit Ausnahmebehandlung sicherstellen\n4. **Nach free auf null setzen** - Zeiger nach Freigabe auf `null` setzen um Use-after-free zu erkennen\n5. **Bereichsprfung** - Buffer-Indexierung fr automatische Bereichsprfung verwenden\n6. **Ownership dokumentieren** - Klar machen, welcher Code jede Allokation besitzt und freigibt\n\n## Beispiele\n\n### Beispiel: Dynamischer String Builder\n\n```hemlock\nfn build_message(count: i32): ptr {\n    let size = count * 10;\n    let buf = alloc(size);\n\n    let i = 0;\n    while (i < count) {\n        memset(buf + (i * 10), 65 + i, 10);\n        i = i + 1;\n    }\n\n    return buf;  // Aufrufer muss freigeben\n}\n\nlet msg = build_message(5);\n// ... msg verwenden\nfree(msg);\n```\n\n### Beispiel: Sichere Array-Operationen\n\n```hemlock\nfn process_array(size: i32) {\n    let arr = buffer(size);\n\n    try {\n        // Array fuellen\n        let i = 0;\n        while (i < arr.length) {\n            arr[i] = i * 2;\n            i = i + 1;\n        }\n\n        // Verarbeiten\n        i = 0;\n        while (i < arr.length) {\n            print(arr[i]);\n            i = i + 1;\n        }\n    } finally {\n        free(arr);  // Immer aufraeumen\n    }\n}\n```\n\n### Beispiel: Memory Pool Muster\n\n```hemlock\n// Einfacher Memory Pool (vereinfacht)\nlet pool = alloc(10000);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > 10000) {\n        throw \"Pool erschoepft\";\n    }\n\n    let ptr = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return ptr;\n}\n\n// Pool verwenden\nlet p1 = pool_alloc(100);\nlet p2 = pool_alloc(200);\n\n// Gesamten Pool auf einmal freigeben\nfree(pool);\n```\n\n## Einschrnkungen\n\nAktuelle Einschrnkungen, die zu beachten sind:\n\n- **Rohe Zeiger erfordern manuelles free** - `alloc()` gibt `ptr` ohne Referenzzaehlen zurck\n- **Keine benutzerdefinierten Allokatoren** - Nur System malloc/free\n\n**Hinweis:** Referenzgezaehlte Typen (String, Array, Object, Buffer) werden automatisch freigegeben, wenn der Scope endet. Nur rohe `ptr` von `alloc()` erfordert explizites `free()`.\n\n## Verwandte Themen\n\n- [Strings](#language-guide-strings) - String-Speicherverwaltung und UTF-8-Kodierung\n- [Arrays](#language-guide-arrays) - Dynamische Arrays und ihre Speichereigenschaften\n- [Objects](#language-guide-objects) - Objekt-Allokation und Lebensdauer\n- [Error Handling](#language-guide-error-handling) - Verwendung von try/finally fr Bereinigung\n\n## Siehe auch\n\n- **Design-Philosophie**: Siehe CLAUDE.md Abschnitt \"Memory Management\"\n- **Typsystem**: Siehe [Types](#language-guide-types) fr `ptr` und `buffer` Typdetails\n- **FFI**: Rohe Zeiger sind essentiell fr Foreign Function Interface\n"}, "Sprachhandbuch -> Syntax": {"id": "language-guide-syntax", "content": "# Syntax-bersicht\n\nDieses Dokument behandelt die grundlegenden Syntaxregeln und die Struktur von Hemlock-Programmen.\n\n## Grundlegende Syntaxregeln\n\n### Semikolons sind erforderlich\n\nIm Gegensatz zu JavaScript oder Python sind Semikolons **immer erforderlich** am Ende von Anweisungen:\n\n```hemlock\nlet x = 42;\nlet y = 10;\nprint(x + y);\n```\n\n**Dies verursacht einen Fehler:**\n```hemlock\nlet x = 42  // FEHLER: Fehlendes Semikolon\nlet y = 10  // FEHLER: Fehlendes Semikolon\n```\n\n### Geschweifte Klammern sind immer erforderlich\n\nAlle Kontrollfluss-Blcke mssen geschweifte Klammern verwenden, auch bei einzelnen Anweisungen:\n\n```hemlock\n// RICHTIG\nif (x > 0) {\n    print(\"positiv\");\n}\n\n// FEHLER: Fehlende Klammern\nif (x > 0)\n    print(\"positiv\");\n```\n\n### Kommentare\n\n```hemlock\n// Dies ist ein einzeiliger Kommentar\n\n/*\n   Dies ist ein\n   mehrzeiliger Kommentar\n*/\n\nlet x = 42;  // Inline-Kommentar\n```\n\n## Variablen\n\n### Deklaration\n\nVariablen werden mit `let` deklariert:\n\n```hemlock\nlet count = 0;\nlet name = \"Alice\";\nlet pi = 3.14159;\n```\n\n### Typannotationen (Optional)\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet flag: bool = true;\nlet text: string = \"hallo\";\n```\n\n### Konstanten\n\nVerwenden Sie `const` fr unvernderliche Werte:\n\n```hemlock\nconst MAX_SIZE: i32 = 1000;\nconst PI: f64 = 3.14159;\n```\n\nDer Versuch, eine Konstante neu zuzuweisen, fhrt zu einem Laufzeitfehler: \"Cannot assign to const variable\".\n\n## Ausdrcke\n\n### Arithmetische Operatoren\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13 - Addition\nprint(a - b);   // 7  - Subtraktion\nprint(a * b);   // 30 - Multiplikation\nprint(a / b);   // 3  - Division (ganzzahlig)\n```\n\n### Vergleichsoperatoren\n\n```hemlock\nprint(a == b);  // false - Gleich\nprint(a != b);  // true  - Ungleich\nprint(a > b);   // true  - Grer als\nprint(a < b);   // false - Kleiner als\nprint(a >= b);  // true  - Grer oder gleich\nprint(a <= b);  // false - Kleiner oder gleich\n```\n\n### Logische Operatoren\n\n```hemlock\nlet x = true;\nlet y = false;\n\nprint(x && y);  // false - UND\nprint(x || y);  // true  - ODER\nprint(!x);      // false - NICHT\n```\n\n### Bitweise Operatoren\n\n```hemlock\nlet a = 12;  // 1100\nlet b = 10;  // 1010\n\nprint(a & b);   // 8  - Bitweises UND\nprint(a | b);   // 14 - Bitweises ODER\nprint(a ^ b);   // 6  - Bitweises XOR\nprint(a << 2);  // 48 - Linksverschiebung\nprint(a >> 1);  // 6  - Rechtsverschiebung\nprint(~a);      // -13 - Bitweises NICHT\n```\n\n### Operatorrangfolge\n\nVon hoechster zu niedrigster Prioritt:\n\n1. `()` - Gruppierung\n2. `!`, `~`, `-` (unaer) - Unaere Operatoren\n3. `*`, `/` - Multiplikation, Division\n4. `+`, `-` - Addition, Subtraktion\n5. `<<`, `>>` - Bitverschiebungen\n6. `<`, `<=`, `>`, `>=` - Vergleiche\n7. `==`, `!=` - Gleichheit\n8. `&` - Bitweises UND\n9. `^` - Bitweises XOR\n10. `|` - Bitweises ODER\n11. `&&` - Logisches UND\n12. `||` - Logisches ODER\n\n**Beispiele:**\n```hemlock\nlet x = 2 + 3 * 4;      // 14 (nicht 20)\nlet y = (2 + 3) * 4;    // 20\nlet z = 5 << 2 + 1;     // 40 (5 << 3)\n```\n\n## Kontrollfluss\n\n### If-Anweisungen\n\n```hemlock\nif (condition) {\n    // Krper\n}\n\nif (condition) {\n    // Then-Zweig\n} else {\n    // Else-Zweig\n}\n\nif (condition1) {\n    // Zweig 1\n} else if (condition2) {\n    // Zweig 2\n} else {\n    // Standard-Zweig\n}\n```\n\n### While-Schleifen\n\n```hemlock\nwhile (condition) {\n    // Krper\n}\n```\n\n**Beispiel:**\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n### For-Schleifen\n\n**C-artige for-Schleife:**\n```hemlock\nfor (initializer; condition; increment) {\n    // Krper\n}\n```\n\n**Beispiel:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**For-in (Arrays):**\n```hemlock\nfor (let item in array) {\n    // Krper\n}\n```\n\n**Beispiel:**\n```hemlock\nlet items = [10, 20, 30];\nfor (let x in items) {\n    print(x);\n}\n```\n\n### Switch-Anweisungen\n\n```hemlock\nswitch (expression) {\n    case value1:\n        // Krper\n        break;\n    case value2:\n        // Krper\n        break;\n    default:\n        // Standard-Krper\n        break;\n}\n```\n\n**Beispiel:**\n```hemlock\nlet day = 3;\nswitch (day) {\n    case 1:\n        print(\"Montag\");\n        break;\n    case 2:\n        print(\"Dienstag\");\n        break;\n    case 3:\n        print(\"Mittwoch\");\n        break;\n    default:\n        print(\"Anderer Tag\");\n        break;\n}\n```\n\n### Break und Continue\n\n```hemlock\n// Break: Schleife verlassen\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n}\n\n// Continue: Zur nchsten Iteration springen\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;\n    }\n    print(i);\n}\n```\n\n## Funktionen\n\n### Benannte Funktionen\n\n```hemlock\nfn function_name(param1: type1, param2: type2): return_type {\n    // Krper\n    return value;\n}\n```\n\n**Beispiel:**\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Anonyme Funktionen\n\n```hemlock\nlet func = fn(params) {\n    // Krper\n};\n```\n\n**Beispiel:**\n```hemlock\nlet multiply = fn(x, y) {\n    return x * y;\n};\n```\n\n### Typannotationen (Optional)\n\n```hemlock\n// Ohne Annotationen (Typen werden abgeleitet)\nfn greet(name) {\n    return \"Hallo, \" + name;\n}\n\n// Mit Annotationen (zur Laufzeit geprft)\nfn divide(a: i32, b: i32): f64 {\n    return a / b;\n}\n```\n\n## Objekte\n\n### Objektliterale\n\n```hemlock\nlet obj = {\n    field1: value1,\n    field2: value2,\n};\n```\n\n**Beispiel:**\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    active: true,\n};\n```\n\n### Methoden\n\n```hemlock\nlet obj = {\n    method: fn() {\n        self.field = value;\n    },\n};\n```\n\n**Beispiel:**\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n};\n```\n\n### Typdefinitionen\n\n```hemlock\ndefine TypeName {\n    field1: type1,\n    field2: type2,\n    optional_field?: default_value,\n}\n```\n\n**Beispiel:**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,\n}\n```\n\n## Arrays\n\n### Array-Literale\n\n```hemlock\nlet arr = [element1, element2, element3];\n```\n\n**Beispiel:**\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet mixed = [1, \"zwei\", true, null];\nlet empty = [];\n```\n\n### Array-Indizierung\n\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);   // 10\narr[1] = 99;     // Element ndern\n```\n\n## Fehlerbehandlung\n\n### Try/Catch\n\n```hemlock\ntry {\n    // Riskanter Code\n} catch (e) {\n    // Fehler behandeln\n}\n```\n\n### Try/Finally\n\n```hemlock\ntry {\n    // Riskanter Code\n} finally {\n    // Wird immer ausgefhrt\n}\n```\n\n### Try/Catch/Finally\n\n```hemlock\ntry {\n    // Riskanter Code\n} catch (e) {\n    // Fehler behandeln\n} finally {\n    // Aufraeumen\n}\n```\n\n### Throw\n\n```hemlock\nthrow expression;\n```\n\n**Beispiel:**\n```hemlock\nif (x < 0) {\n    throw \"x muss positiv sein\";\n}\n```\n\n### Panic\n\n```hemlock\npanic(message);\n```\n\n**Beispiel:**\n```hemlock\npanic(\"nicht behebbarer Fehler\");\n```\n\n## Module (Experimentell)\n\n### Export-Anweisungen\n\n```hemlock\nexport fn function_name() { }\nexport const CONSTANT = value;\nexport let variable = value;\nexport { name1, name2 };\n```\n\n### Import-Anweisungen\n\n```hemlock\nimport { name1, name2 } from \"./module.hml\";\nimport * as namespace from \"./module.hml\";\nimport { name as alias } from \"./module.hml\";\n```\n\n## Async (Experimentell)\n\n### Async-Funktionen\n\n```hemlock\nasync fn function_name(params): return_type {\n    // Krper\n}\n```\n\n### Spawn/Join\n\n```hemlock\nlet task = spawn(async_function, arg1, arg2);\nlet result = join(task);\n```\n\n### Channels\n\n```hemlock\nlet ch = channel(capacity);\nch.send(value);\nlet value = ch.recv();\nch.close();\n```\n\n## FFI (Foreign Function Interface)\n\n### Shared Library importieren\n\n```hemlock\nimport \"library_name.so\";\n```\n\n### Externe Funktion deklarieren\n\n```hemlock\nextern fn function_name(param: type): return_type;\n```\n\n**Beispiel:**\n```hemlock\nimport \"libc.so.6\";\nextern fn strlen(s: string): i32;\n```\n\n## Literale\n\n### Ganzzahl-Literale\n\n```hemlock\nlet decimal = 42;\nlet negative = -100;\nlet large = 5000000000;  // Automatisch i64\n\n// Hexadezimal (0x-Prfix)\nlet hex = 0xDEADBEEF;\nlet hex2 = 0xFF;\n\n// Binr (0b-Prfix)\nlet bin = 0b1010;\nlet bin2 = 0b11110000;\n\n// Oktal (0o-Prfix)\nlet oct = 0o777;\nlet oct2 = 0O123;\n\n// Numerische Trennzeichen fr Lesbarkeit\nlet million = 1_000_000;\nlet hex_sep = 0xFF_FF_FF;\nlet bin_sep = 0b1111_0000_1010_0101;\nlet oct_sep = 0o77_77;\n```\n\n### Gleitkomma-Literale\n\n```hemlock\nlet f = 3.14;\nlet e = 2.71828;\nlet sci = 1.5e-10;       // Wissenschaftliche Notation\nlet sci2 = 2.5E+3;       // Grosses E funktioniert auch\nlet no_lead = .5;        // Ohne fhrende Null (0.5)\nlet sep = 3.14_159_265;  // Numerische Trennzeichen\n```\n\n### String-Literale\n\n```hemlock\nlet s = \"hallo\";\nlet escaped = \"zeile1\\nzeile2\\ttabuliert\";\nlet quote = \"Sie sagte \\\"hallo\\\"\";\n\n// Hex-Escape-Sequenzen\nlet hex_esc = \"\\x48\\x65\\x6c\\x6c\\x6f\";  // \"Hello\"\n\n// Unicode-Escape-Sequenzen\nlet emoji = \"\\u{1F600}\";               // (Smiley)\nlet heart = \"\\u{2764}\";                // (Herz)\nlet mixed = \"Hallo \\u{1F30D}!\";        // Hallo (Erde)!\n```\n\n**Escape-Sequenzen:**\n- `\\n` - Zeilenumbruch\n- `\\t` - Tabulator\n- `\\r` - Wagenruecklauf\n- `\\\\` - Backslash\n- `\\\"` - Anfhrungszeichen\n- `\\'` - Apostroph\n- `\\0` - Null-Zeichen\n- `\\xNN` - Hex-Escape (2 Ziffern)\n- `\\u{XXXX}` - Unicode-Escape (1-6 Ziffern)\n\n### Rune-Literale\n\n```hemlock\nlet ch = 'A';\nlet emoji = '(Rakete)';\nlet escaped = '\\n';\nlet unicode = '\\u{1F680}';\nlet hex_rune = '\\x41';      // 'A'\n```\n\n### Boolesche Literale\n\n```hemlock\nlet t = true;\nlet f = false;\n```\n\n### Null-Literal\n\n```hemlock\nlet nothing = null;\n```\n\n## Gueltigkeitsbereichsregeln\n\n### Block-Gltigkeitsbereich\n\nVariablen sind auf den nchsten umschliessenden Block beschrnkt:\n\n```hemlock\nlet x = 1;  // Aeusserer Gltigkeitsbereich\n\nif (true) {\n    let x = 2;  // Innerer Gltigkeitsbereich (ueberdeckt ueren)\n    print(x);   // 2\n}\n\nprint(x);  // 1\n```\n\n### Funktions-Gltigkeitsbereich\n\nFunktionen erstellen ihren eigenen Gltigkeitsbereich:\n\n```hemlock\nlet global = \"global\";\n\nfn foo() {\n    let local = \"lokal\";\n    print(global);  // Kann ueren Gltigkeitsbereich lesen\n}\n\nfoo();\n// print(local);  // FEHLER: 'local' ist hier nicht definiert\n```\n\n### Closure-Gltigkeitsbereich\n\nClosures erfassen Variablen aus dem umschliessenden Gltigkeitsbereich:\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Erfasst 'count'\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\n```\n\n## Whitespace und Formatierung\n\n### Einrueckung\n\nHemlock erzwingt keine bestimmte Einrueckung, aber 4 Leerzeichen werden empfohlen:\n\n```hemlock\nfn example() {\n    if (true) {\n        print(\"eingerueckt\");\n    }\n}\n```\n\n### Zeilenumbrueche\n\nAnweisungen knnen mehrere Zeilen umfassen:\n\n```hemlock\nlet result =\n    very_long_function_name(\n        arg1,\n        arg2,\n        arg3\n    );\n```\n\n## Loop-Anweisung\n\nDas `loop`-Schlsselwort bietet eine sauberere Syntax fr Endlosschleifen:\n\n```hemlock\nloop {\n    // ... Arbeit ausfhren\n    if (done) {\n        break;\n    }\n}\n```\n\nDies entspricht `while (true)`, macht aber die Absicht deutlicher.\n\n## Reservierte Schlsselwrter\n\nDie folgenden Schlsselwrter sind in Hemlock reserviert:\n\n```\nlet, const, fn, if, else, while, for, in, loop, break, continue,\nreturn, true, false, null, typeof, import, export, from,\ntry, catch, finally, throw, panic, async, await, spawn, join,\ndetach, channel, define, switch, case, default, extern, self,\ntype, defer, enum, ref, buffer, Self\n```\n\n## Nchste Schritte\n\n- [Typsystem](#language-guide-types) - Erfahren Sie mehr ber das Hemlock-Typsystem\n- [Kontrollfluss](#language-guide-control-flow) - Vertiefte Betrachtung der Kontrollstrukturen\n- [Funktionen](#language-guide-functions) - Beherrschen Sie Funktionen und Closures\n- [Speicherverwaltung](#language-guide-memory) - Verstehen Sie Pointer und Buffer\n"}, "Sprachhandbuch -> Typen": {"id": "language-guide-types", "content": "# Typsystem\n\nHemlock verfuegt ber ein **dynamisches Typsystem** mit optionalen Typannotationen und Laufzeit-Typberprfung.\n\n---\n\n## Typauswahl-Leitfaden: Welchen Typ sollte ich verwenden?\n\n**Neu bei Typen?** Beginnen Sie hier. Wenn Sie mit Typsystemen vertraut sind, springen Sie zu [Philosophie](#philosophie).\n\n### Die kurze Antwort\n\n**Lassen Sie Hemlock es einfach herausfinden:**\n\n```hemlock\nlet count = 42;        // Hemlock wei, dass dies eine Ganzzahl ist\nlet price = 19.99;     // Hemlock wei, dass dies eine Dezimalzahl ist\nlet name = \"Alice\";    // Hemlock wei, dass dies Text ist\nlet active = true;     // Hemlock wei, dass dies ja/nein ist\n```\n\nHemlock waehlt automatisch den richtigen Typ fr Ihre Werte. Sie *mssen* keine Typen angeben.\n\n### Wann Typannotationen hinzufgen\n\nFuegen Sie Typen hinzu, wenn Sie:\n\n1. **Genau ber die Gre sein wollen** - `i8` vs `i64` ist wichtig fr Speicher oder FFI\n2. **Ihren Code dokumentieren** - Typen zeigen, was eine Funktion erwartet\n3. **Fehler frueh erkennen wollen** - Hemlock prft Typen zur Laufzeit\n\n```hemlock\n// Ohne Typen (funktioniert gut):\nfn add(a, b) {\n    return a + b;\n}\n\n// Mit Typen (expliziter):\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Schnellreferenz: Zahlentypen whlen\n\n| Was Sie speichern | Empfohlener Typ | Beispiel |\n|-------------------|-----------------|----------|\n| Normale Ganzzahlen | `i32` (Standard) | `let count = 42;` |\n| Sehr groe Zahlen | `i64` | `let population = 8000000000;` |\n| Nie-negative Zhler | `u32` | `let items: u32 = 100;` |\n| Bytes (0-255) | `u8` | `let pixel: u8 = 255;` |\n| Dezimalzahlen/Brueche | `f64` (Standard) | `let price = 19.99;` |\n| Leistungskritische Dezimalzahlen | `f32` | `let x: f32 = 1.5;` |\n\n### Schnellreferenz: Alle Typen\n\n| Kategorie | Typen | Wann verwenden |\n|-----------|-------|----------------|\n| **Ganzzahlen** | `i8`, `i16`, `i32`, `i64` | Zaehlen, IDs, Alter, usw. |\n| **Nur-positive Zahlen** | `u8`, `u16`, `u32`, `u64` | Bytes, Groessen, Array-Lngen |\n| **Dezimalzahlen** | `f32`, `f64` | Geld, Messungen, Mathematik |\n| **Ja/Nein** | `bool` | Flags, Bedingungen |\n| **Text** | `string` | Namen, Nachrichten, jeder Text |\n| **Einzelnes Zeichen** | `rune` | Einzelne Buchstaben, Emoji |\n| **Listen** | `array` | Sammlungen von Werten |\n| **Benannte Felder** | `object` | Gruppierung verwandter Daten |\n| **Roher Speicher** | `ptr`, `buffer` | Low-Level-Programmierung |\n| **Nichts** | `null` | Abwesenheit eines Wertes |\n\n### Hufige Szenarien\n\n**\"Ich brauche nur eine Zahl\"**\n```hemlock\nlet x = 42;  // Fertig! Hemlock waehlt i32\n```\n\n**\"Ich brauche Dezimalzahlen\"**\n```hemlock\nlet price = 19.99;  // Fertig! Hemlock waehlt f64\n```\n\n**\"Ich arbeite mit Bytes (Dateien, Netzwerk)\"**\n```hemlock\nlet byte: u8 = 255;  // 0-255 Bereich\n```\n\n**\"Ich brauche wirklich groe Zahlen\"**\n```hemlock\nlet big = 9000000000000;  // Hemlock waehlt automatisch i64 (> i32 max)\n// Oder explizit:\nlet big: i64 = 9000000000000;\n```\n\n**\"Ich speichere Geld\"**\n```hemlock\n// Option 1: Float (einfach, aber hat Praezisionsgrenzen)\nlet price: f64 = 19.99;\n\n// Option 2: Als Cent speichern (praeziser)\nlet price_cents: i32 = 1999;  // 19.99 EUR als Ganzzahl-Cent\n```\n\n**\"Ich uebergebe Daten an C-Code (FFI)\"**\n```hemlock\n// C-Typen genau entsprechen\nlet c_int: i32 = 100;      // C 'int'\nlet c_long: i64 = 100;     // C 'long' (auf 64-bit)\nlet c_char: u8 = 65;       // C 'char'\nlet c_double: f64 = 3.14;  // C 'double'\n```\n\n### Was passiert, wenn Typen gemischt werden?\n\nWenn Sie verschiedene Typen kombinieren, befrdert Hemlock zum \"groesseren\" Typ:\n\n```hemlock\nlet a: i32 = 10;\nlet b: f64 = 2.5;\nlet result = a + b;  // result ist f64 (12.5)\n// Die Ganzzahl wurde automatisch zur Dezimalzahl\n```\n\n**Faustregel:** Floats \"gewinnen\" immer - das Mischen einer Ganzzahl mit einem Float ergibt einen Float.\n\n### Typfehler\n\nWenn Sie versuchen, den falschen Typ zu verwenden, sagt Ihnen Hemlock dies zur Laufzeit:\n\n```hemlock\nlet age: i32 = \"dreissig\";  // FEHLER: Typenkonflikt - erwartet i32, erhalten string\n```\n\nUm Typen zu konvertieren, verwenden Sie Typ-Konstruktorfunktionen:\n\n```hemlock\nlet text = \"42\";\nlet number = i32(text);   // String zu Ganzzahl parsen: 42\nlet back = text + \"\";     // Bereits ein String\n```\n\n---\n\n## Philosophie\n\n- **Standardmig dynamisch** - Jeder Wert hat ein Laufzeit-Typ-Tag\n- **Typisiert nach Wahl** - Optionale Typannotationen erzwingen Laufzeitprfungen\n- **Explizite Konvertierungen** - Implizite Konvertierungen folgen klaren Befoerderungsregeln\n- **Ehrlich ber Typen** - `typeof()` sagt immer die Wahrheit\n\n## Primitive Typen\n\n### Ganzzahltypen\n\n**Vorzeichenbehaftete Ganzzahlen:**\n```hemlock\nlet tiny: i8 = 127;              // 8-Bit  (-128 bis 127)\nlet small: i16 = 32767;          // 16-Bit (-32768 bis 32767)\nlet normal: i32 = 2147483647;    // 32-Bit (Standard)\nlet large: i64 = 9223372036854775807;  // 64-Bit\n```\n\n**Vorzeichenlose Ganzzahlen:**\n```hemlock\nlet byte: u8 = 255;              // 8-Bit  (0 bis 255)\nlet word: u16 = 65535;           // 16-Bit (0 bis 65535)\nlet dword: u32 = 4294967295;     // 32-Bit (0 bis 4294967295)\nlet qword: u64 = 18446744073709551615;  // 64-Bit\n```\n\n**Typ-Aliase:**\n```hemlock\nlet i: integer = 42;   // Alias fr i32\nlet b: byte = 255;     // Alias fr u8\n```\n\n### Gleitkommatypen\n\n```hemlock\nlet f: f32 = 3.14159;        // 32-Bit Float\nlet d: f64 = 2.718281828;    // 64-Bit Float (Standard)\nlet n: number = 1.618;       // Alias fr f64\n```\n\n### Boolescher Typ\n\n```hemlock\nlet flag: bool = true;\nlet active: bool = false;\n```\n\n### String-Typ\n\n```hemlock\nlet text: string = \"Hallo, Welt!\";\nlet empty: string = \"\";\n```\n\nStrings sind **vernderlich**, **UTF-8-kodiert** und **heap-allokiert**.\n\nSiehe [Strings](#language-guide-strings) fr vollstndige Details.\n\n### Rune-Typ\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '(Rakete)';\nlet newline: rune = '\\n';\nlet unicode: rune = '\\u{1F680}';\n```\n\nRunes repraesentieren **Unicode-Codepoints** (U+0000 bis U+10FFFF).\n\nSiehe [Runes](#language-guide-runes) fr vollstndige Details.\n\n### Null-Typ\n\n```hemlock\nlet nothing = null;\nlet uninitialized: string = null;\n```\n\n`null` ist sein eigener Typ mit einem einzelnen Wert.\n\n## Zusammengesetzte Typen\n\n### Array-Typ\n\n```hemlock\nlet numbers: array = [1, 2, 3, 4, 5];\nlet mixed = [1, \"zwei\", true, null];  // Gemischte Typen erlaubt\nlet empty: array = [];\n```\n\nSiehe [Arrays](#language-guide-arrays) fr vollstndige Details.\n\n### Object-Typ\n\n```hemlock\nlet obj: object = { x: 10, y: 20 };\nlet person = { name: \"Alice\", age: 30 };\n```\n\nSiehe [Objects](#language-guide-objects) fr vollstndige Details.\n\n### Pointer-Typen\n\n**Roher Pointer:**\n```hemlock\nlet p: ptr = alloc(64);\n// Keine Grenzprfung, manuelle Lebenszeitverwaltung\nfree(p);\n```\n\n**Sicherer Buffer:**\n```hemlock\nlet buf: buffer = buffer(64);\n// Grenzgeprueft, verfolgt Lnge und Kapazitt\nfree(buf);\n```\n\nSiehe [Speicherverwaltung](#language-guide-memory) fr vollstndige Details.\n\n## Enum-Typen\n\nEnums definieren eine Menge benannter Konstanten:\n\n### Einfache Enums\n\n```hemlock\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nlet c = Color.RED;\nprint(c);              // 0\nprint(typeof(c));      // \"Color\"\n\n// Vergleich\nif (c == Color.RED) {\n    print(\"Es ist rot!\");\n}\n\n// Switch auf Enum\nswitch (c) {\n    case Color.RED:\n        print(\"Stopp\");\n        break;\n    case Color.GREEN:\n        print(\"Los\");\n        break;\n    case Color.BLUE:\n        print(\"Blau?\");\n        break;\n}\n```\n\n### Enums mit Werten\n\nEnums knnen explizite Ganzzahlwerte haben:\n\n```hemlock\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 2\n}\n\nprint(Status.OK);      // 0\nprint(Status.ERROR);   // 1\n\nenum HttpCode {\n    OK = 200,\n    NOT_FOUND = 404,\n    SERVER_ERROR = 500\n}\n\nlet code = HttpCode.NOT_FOUND;\nprint(code);           // 404\n```\n\n### Auto-inkrementierende Werte\n\nOhne explizite Werte inkrementieren Enums automatisch von 0:\n\n```hemlock\nenum Priority {\n    LOW,       // 0\n    MEDIUM,    // 1\n    HIGH,      // 2\n    CRITICAL   // 3\n}\n\n// Kann explizite und Auto-Werte mischen\nenum Level {\n    DEBUG = 10,\n    INFO,      // 11\n    WARN,      // 12\n    ERROR = 50,\n    FATAL      // 51\n}\n```\n\n### Enum-Verwendungsmuster\n\n```hemlock\n// Als Funktionsparameter\nfn set_priority(p: Priority) {\n    if (p == Priority.CRITICAL) {\n        print(\"Dringend!\");\n    }\n}\n\nset_priority(Priority.HIGH);\n\n// In Objekten\ndefine Task {\n    name: string,\n    priority: Priority\n}\n\nlet task: Task = {\n    name: \"Fehler beheben\",\n    priority: Priority.HIGH\n};\n```\n\n## Spezielle Typen\n\n### File-Typ\n\n```hemlock\nlet f: file = open(\"data.txt\", \"r\");\nf.close();\n```\n\nRepraesentiert ein offenes Datei-Handle.\n\n### Task-Typ\n\n```hemlock\nasync fn compute(): i32 { return 42; }\nlet task = spawn(compute);\nlet result: i32 = join(task);\n```\n\nRepraesentiert ein Async-Task-Handle.\n\n### Channel-Typ\n\n```hemlock\nlet ch: channel = channel(10);\nch.send(42);\nlet value = ch.recv();\n```\n\nRepraesentiert einen Kommunikationskanal zwischen Tasks.\n\n### Void-Typ\n\n```hemlock\nextern fn exit(code: i32): void;\n```\n\nWird fr Funktionen verwendet, die keinen Wert zurckgeben (nur FFI).\n\n## Typinferenz\n\n### Ganzzahl-Literal-Inferenz\n\nHemlock leitet Ganzzahltypen basierend auf dem Wertebereich ab:\n\n```hemlock\nlet a = 42;              // i32 (passt in 32-Bit)\nlet b = 5000000000;      // i64 (> i32 max)\nlet c = 128;             // i32\nlet d: u8 = 128;         // u8 (explizite Annotation)\n```\n\n**Regeln:**\n- Werte im i32-Bereich (-2147483648 bis 2147483647): als `i32` abgeleitet\n- Werte auerhalb des i32-Bereichs aber innerhalb von i64: als `i64` abgeleitet\n- Verwenden Sie explizite Annotationen fr andere Typen (i8, i16, u8, u16, u32, u64)\n\n### Float-Literal-Inferenz\n\n```hemlock\nlet x = 3.14;        // f64 (Standard)\nlet y: f32 = 3.14;   // f32 (explizit)\n```\n\n### Wissenschaftliche Notation\n\nHemlock untersttzt wissenschaftliche Notation fr numerische Literale:\n\n```hemlock\nlet a = 1e10;        // 10000000000.0 (f64)\nlet b = 1e-12;       // 0.000000000001 (f64)\nlet c = 3.14e2;      // 314.0 (f64)\nlet d = 2.5e-3;      // 0.0025 (f64)\nlet e = 1E10;        // Gro-/Kleinschreibung egal\nlet f = 1e+5;        // Explizit positiver Exponent\n```\n\n**Hinweis:** Jedes Literal mit wissenschaftlicher Notation wird immer als `f64` abgeleitet.\n\n### Andere Typinferenz\n\n```hemlock\nlet s = \"hallo\";     // string\nlet ch = 'A';        // rune\nlet flag = true;     // bool\nlet arr = [1, 2, 3]; // array\nlet obj = { x: 10 }; // object\nlet nothing = null;  // null\n```\n\n## Typannotationen\n\n### Variablenannotationen\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet name: string = \"Alice\";\n```\n\n### Funktionsparameter-Annotationen\n\n```hemlock\nfn greet(name: string, age: i32) {\n    print(\"Hallo, \" + name + \"!\");\n}\n```\n\n### Funktions-Rckgabetyp-Annotationen\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Object-Typannotationen (Duck Typing)\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\n```\n\n## Typberprfung\n\n### Laufzeit-Typberprfung\n\nTypannotationen werden zur **Laufzeit** geprft, nicht zur Kompilierzeit:\n\n```hemlock\nlet x: i32 = 42;     // OK\nlet y: i32 = 3.14;   // Laufzeitfehler: Typenkonflikt\n\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 3);           // OK\nadd(5, \"hallo\");     // Laufzeitfehler: Typenkonflikt\n```\n\n### Typabfragen\n\nVerwenden Sie `typeof()` um Werttypen zu prfen:\n\n```hemlock\nprint(typeof(42));         // \"i32\"\nprint(typeof(3.14));       // \"f64\"\nprint(typeof(\"hallo\"));    // \"string\"\nprint(typeof(true));       // \"bool\"\nprint(typeof(null));       // \"null\"\nprint(typeof([1, 2, 3]));  // \"array\"\nprint(typeof({ x: 10 }));  // \"object\"\n```\n\n## Typkonvertierungen\n\n### Implizite Typbefoerderung\n\nBeim Mischen von Typen in Operationen befrdert Hemlock zum \"hoeheren\" Typ:\n\n**Befoerderungshierarchie (niedrigste zu hoechste):**\n```\ni8 -> i16 -> i32 -> u32 -> i64 -> u64 -> f32 -> f64\n      ^      ^      ^\n     u8     u16\n```\n\n**Float gewinnt immer:**\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result ist f64 (13.5)\n```\n\n**Grere Gre gewinnt:**\n```hemlock\nlet a: i32 = 100;\nlet b: i64 = 200;\nlet sum = a + b;     // sum ist i64 (300)\n```\n\n**Praezisionserhaltung:** Beim Mischen von 64-Bit-Ganzzahlen mit f32 befrdert Hemlock\nzu f64, um Praezisionsverlust zu vermeiden (f32 hat nur 24-Bit-Mantisse, unzureichend fr i64/u64):\n```hemlock\nlet big: i64 = 9007199254740993;\nlet small: f32 = 1.0;\nlet result = big + small;  // result ist f64, nicht f32!\n```\n\n**Beispiele:**\n```hemlock\nu8 + i32  -> i32\ni32 + i64 -> i64\nu32 + u64 -> u64\ni32 + f32 -> f32    // f32 ausreichend fr i32\ni64 + f32 -> f64    // f64 ntig um i64-Przision zu erhalten\ni64 + f64 -> f64\ni8 + f64  -> f64\n```\n\n### Explizite Typkonvertierung\n\n**Ganzzahl <-> Float:**\n```hemlock\nlet i: i32 = 42;\nlet f: f64 = i;      // i32 -> f64 (42.0)\n\nlet x: f64 = 3.14;\nlet n: i32 = x;      // f64 -> i32 (3, abgeschnitten)\n```\n\n**Ganzzahl <-> Rune:**\n```hemlock\nlet code: i32 = 65;\nlet ch: rune = code;  // i32 -> rune ('A')\n\nlet r: rune = 'Z';\nlet value: i32 = r;   // rune -> i32 (90)\n```\n\n**Rune -> String:**\n```hemlock\nlet ch: rune = '(Rakete)';\nlet s: string = ch;   // rune -> string (\"(Rakete)\")\n```\n\n**u8 -> Rune:**\n```hemlock\nlet b: u8 = 65;\nlet r: rune = b;      // u8 -> rune ('A')\n```\n\n### Typ-Konstruktorfunktionen\n\nTypnamen knnen als Funktionen verwendet werden, um Werte zu konvertieren oder zu parsen:\n\n**Strings zu Zahlen parsen:**\n```hemlock\nlet n = i32(\"42\");       // String zu i32 parsen: 42\nlet f = f64(\"3.14159\");  // String zu f64 parsen: 3.14159\nlet b = bool(\"true\");    // String zu bool parsen: true\n\n// Alle numerischen Typen untersttzt\nlet a = i8(\"-128\");      // Zu i8 parsen\nlet c = u8(\"255\");       // Zu u8 parsen\nlet d = i16(\"1000\");     // Zu i16 parsen\nlet e = u16(\"50000\");    // Zu u16 parsen\nlet g = i64(\"9000000000000\"); // Zu i64 parsen\nlet h = u64(\"18000000000000\"); // Zu u64 parsen\nlet j = f32(\"1.5\");      // Zu f32 parsen\n```\n\n**Hex und negative Zahlen:**\n```hemlock\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\nlet bin = i32(\"0b1010\"); // 10 (binr)\n```\n\n**Typ-Aliase funktionieren auch:**\n```hemlock\nlet x = integer(\"100\");  // Gleich wie i32(\"100\")\nlet y = number(\"1.5\");   // Gleich wie f64(\"1.5\")\nlet z = byte(\"200\");     // Gleich wie u8(\"200\")\n```\n\n**Zwischen numerischen Typen konvertieren:**\n```hemlock\nlet big = i64(42);           // i32 zu i64\nlet truncated = i32(3.99);   // f64 zu i32 (schneidet auf 3 ab)\nlet promoted = f64(100);     // i32 zu f64 (100.0)\nlet narrowed = i8(127);      // i32 zu i8\n```\n\n**Typannotationen fhren numerische Koersion durch (aber KEIN String-Parsen):**\n```hemlock\nlet f: f64 = 100;        // i32 zu f64 via Annotation (OK)\nlet s: string = 'A';     // Rune zu String via Annotation (OK)\nlet code: i32 = 'A';     // Rune zu i32 via Annotation (erhlt Codepoint, OK)\n\n// String-Parsen erfordert explizite Typ-Konstruktoren:\nlet n = i32(\"42\");       // Typ-Konstruktor fr String-Parsen verwenden\n// let x: i32 = \"42\";    // FEHLER - Typannotationen parsen keine Strings\n```\n\n**Fehlerbehandlung:**\n```hemlock\n// Ungueltige Strings werfen Fehler bei Verwendung von Typ-Konstruktoren\nlet bad = i32(\"hallo\");  // Laufzeitfehler: kann \"hallo\" nicht als i32 parsen\nlet overflow = u8(\"256\"); // Laufzeitfehler: 256 auerhalb des Bereichs fr u8\n```\n\n**Boolean-Parsen:**\n```hemlock\nlet t = bool(\"true\");    // true\nlet f = bool(\"false\");   // false\nlet bad = bool(\"ja\");    // Laufzeitfehler: muss \"true\" oder \"false\" sein\n```\n\n## Bereichsprfung\n\nTypannotationen erzwingen Bereichspruefungen bei Zuweisung:\n\n```hemlock\nlet x: u8 = 255;    // OK\nlet y: u8 = 256;    // FEHLER: auerhalb des Bereichs fr u8\n\nlet a: i8 = 127;    // OK\nlet b: i8 = 128;    // FEHLER: auerhalb des Bereichs fr i8\n\nlet c: i64 = 2147483647;   // OK\nlet d: u64 = 4294967295;   // OK\nlet e: u64 = -1;           // FEHLER: u64 kann nicht negativ sein\n```\n\n## Typbefoerderungs-Beispiele\n\n### Gemischte Ganzzahltypen\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet sum = a + b;     // i32 (30)\n\nlet c: u8 = 100;\nlet d: u32 = 200;\nlet total = c + d;   // u32 (300)\n```\n\n### Ganzzahl + Float\n\n```hemlock\nlet i: i32 = 5;\nlet f: f32 = 2.5;\nlet result = i * f;  // f32 (12.5)\n```\n\n### Komplexe Ausdrcke\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet c: f64 = 3.0;\n\nlet result = a + b * c;  // f64 (70.0)\n// Auswertung: b * c -> f64(60.0)\n//             a + f64(60.0) -> f64(70.0)\n```\n\n## Duck Typing (Objects)\n\nObjects verwenden **strukturelle Typisierung** (Duck Typing):\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK: Hat alle erforderlichen Felder\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK: Zustzliche Felder erlaubt\nlet p2: Person = { name: \"Bob\", age: 25, city: \"NYC\" };\n\n// FEHLER: Fehlendes 'age'-Feld\nlet p3: Person = { name: \"Carol\" };\n\n// FEHLER: Falscher Typ fr 'age'\nlet p4: Person = { name: \"Dave\", age: \"dreissig\" };\n```\n\n**Typberprfung erfolgt bei Zuweisung:**\n- Validiert, dass alle erforderlichen Felder vorhanden sind\n- Validiert, dass Feldtypen bereinstimmen\n- Zustzliche Felder sind erlaubt und werden beibehalten\n- Setzt den Typnamen des Objects fr `typeof()`\n\n## Optionale Felder\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug?: false,     // Optional mit Standard\n    timeout?: i32,     // Optional, Standard ist null\n}\n\nlet cfg1: Config = { host: \"localhost\", port: 8080 };\nprint(cfg1.debug);    // false (Standard)\nprint(cfg1.timeout);  // null\n\nlet cfg2: Config = { host: \"0.0.0.0\", port: 80, debug: true };\nprint(cfg2.debug);    // true (berschrieben)\n```\n\n## Typ-Aliase\n\nHemlock untersttzt benutzerdefinierte Typ-Aliase mit dem `type`-Schlsselwort:\n\n### Einfache Typ-Aliase\n\n```hemlock\n// Einfacher Typ-Alias\ntype Integer = i32;\ntype Text = string;\n\n// Alias verwenden\nlet x: Integer = 42;\nlet msg: Text = \"hallo\";\n```\n\n### Funktionstyp-Aliase\n\n```hemlock\n// Funktionstyp-Alias\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// Funktionstyp-Aliase verwenden\nlet cb: Callback = fn(n) { print(n); };\nlet isEven: Predicate = fn(n) { return n % 2 == 0; };\n```\n\n### Zusammengesetzte Typ-Aliase\n\n```hemlock\n// Mehrere defines zu einem Typ kombinieren\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\ntype Person = HasName & HasAge;\n\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\n### Generische Typ-Aliase\n\n```hemlock\n// Generischer Typ-Alias\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// Generische Aliase verwenden\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**Hinweis:** Typ-Aliase sind transparent - `typeof()` gibt den zugrunde liegenden Typnamen zurck, nicht den Alias.\n\n## Typsystem-Einschrnkungen\n\nAktuelle Einschrnkungen:\n\n- **Keine Generics bei Funktionen** - Funktions-Typparameter noch nicht untersttzt\n- **Keine Union-Typen** - Kann \"A oder B\" nicht ausdrcken\n- **Keine Nullable-Typen** - Alle Typen knnen null sein (verwenden Sie `?`-Suffix fr explizite Nullability)\n\n**Hinweis:** Der Compiler (`hemlockc`) bietet Kompilierzeit-Typberprfung. Der Interpreter fhrt nur Laufzeit-Typberprfung durch. Siehe die [Compiler-Dokumentation](#design-implementation) fr Details.\n\n## Best Practices\n\n### Wann Typannotationen verwenden\n\n**Verwenden Sie Annotationen, wenn:**\n- Praeziser Typ wichtig ist (z.B. `u8` fr Byte-Werte)\n- Funktionsschnittstellen dokumentieren\n- Einschrnkungen erzwingen (z.B. Bereichspruefungen)\n\n```hemlock\nfn hash(data: buffer, length: u32): u64 {\n    // Implementierung\n}\n```\n\n**Verwenden Sie keine Annotationen, wenn:**\n- Der Typ aus dem Literal offensichtlich ist\n- Interne Implementierungsdetails\n- Unnoetige Zeremonie\n\n```hemlock\n// Unntig\nlet x: i32 = 42;\n\n// Besser\nlet x = 42;\n```\n\n### Typsicherheits-Muster\n\n**Vor Verwendung prfen:**\n```hemlock\nif (typeof(value) == \"i32\") {\n    // Sicher als i32 zu verwenden\n}\n```\n\n**Funktionsargumente validieren:**\n```hemlock\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" || typeof(b) != \"i32\") {\n        throw \"Argumente mssen Ganzzahlen sein\";\n    }\n    if (b == 0) {\n        throw \"Division durch Null\";\n    }\n    return a / b;\n}\n```\n\n**Duck Typing fr Flexibilitaet verwenden:**\n```hemlock\ndefine Printable {\n    toString: fn,\n}\n\nfn print_item(item: Printable) {\n    print(item.toString());\n}\n```\n\n## Nchste Schritte\n\n- [Strings](#language-guide-strings) - UTF-8-String-Typ und Operationen\n- [Runes](#language-guide-runes) - Unicode-Codepoint-Typ\n- [Arrays](#language-guide-arrays) - Dynamischer Array-Typ\n- [Objects](#language-guide-objects) - Object-Literale und Duck Typing\n- [Memory](#language-guide-memory) - Pointer- und Buffer-Typen\n"}, "Sprachhandbuch -> Zeichenketten": {"id": "language-guide-strings", "content": "# Strings\n\nHemlock-Strings sind **UTF-8 erstklassige veraenderbare Sequenzen** mit voller Unicode-Untersttzung und einem umfangreichen Satz von Methoden zur Textverarbeitung. Anders als in vielen Sprachen sind Hemlock-Strings veraenderbar und arbeiten nativ mit Unicode-Codepoints.\n\n## berblick\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // veraendern mit Rune (jetzt \"Hello\")\nprint(s.length);        // 5 (Codepoint-Anzahl)\nlet c = s[0];           // gibt Rune zurck (Unicode-Codepoint)\nlet msg = s + \" world\"; // Verkettung\nlet emoji = \"\";\nprint(emoji.length);    // 1 (ein Codepoint)\nprint(emoji.byte_length); // 4 (vier UTF-8-Bytes)\n```\n\n## Eigenschaften\n\nHemlock-Strings haben diese Hauptmerkmale:\n\n- **UTF-8-kodiert** - Volle Unicode-Untersttzung (U+0000 bis U+10FFFF)\n- **Veraenderbar** - Anders als Python-, JavaScript- und Java-Strings\n- **Codepoint-basierte Indizierung** - Gibt `rune` (Unicode-Codepoint) zurck, nicht Byte\n- **Heap-allokiert** - Mit interner Kapazitaetsverfolgung\n- **Zwei Lngeneigenschaften**:\n  - `.length` - Codepoint-Anzahl (Anzahl der Zeichen)\n  - `.byte_length` - Byte-Anzahl (UTF-8-Kodierungsgroesse)\n\n## UTF-8-Verhalten\n\nAlle String-Operationen arbeiten mit **Codepoints** (Zeichen), nicht mit Bytes:\n\n```hemlock\nlet text = \"HelloWorld\";\nprint(text.length);        // 11 (Codepoints)\nprint(text.byte_length);   // 15 (Bytes, Emoji ist 4 Bytes)\n\n// Indizierung verwendet Codepoints\nlet h = text[0];           // 'H' (Rune)\nlet rocket = text[5];      // '' (Rune)\n```\n\n**Mehrbyte-Zeichen zaehlen als eins:**\n```hemlock\n\"Hello\".length;      // 5\n\"\".length;         // 1 (ein Emoji)\n\"\".length;       // 2 (zwei chinesische Zeichen)\n\"caf\".length;       // 4 ( ist ein Codepoint)\n```\n\n## String-Literale\n\n```hemlock\n// Einfache Strings\nlet s1 = \"hello\";\nlet s2 = \"world\";\n\n// Mit Escape-Sequenzen\nlet s3 = \"Zeile 1\\nZeile 2\\teingerueckt\";\nlet s4 = \"Zitat: \\\"Hallo\\\"\";\nlet s5 = \"Backslash: \\\\\";\n\n// Unicode-Zeichen\nlet s6 = \" Emoji\";\nlet s7 = \"\";\n```\n\n## Template-Strings (String-Interpolation)\n\nVerwenden Sie Backticks fr Template-Strings mit eingebetteten Ausdrcken:\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\n\n// Einfache Interpolation\nlet greeting = `Hallo, ${name}!`;           // \"Hallo, Alice!\"\nlet info = `${name} ist ${age} Jahre alt`;  // \"Alice ist 30 Jahre alt\"\n\n// Ausdrcke in der Interpolation\nlet x = 5;\nlet y = 10;\nlet sum = `${x} + ${y} = ${x + y}`;         // \"5 + 10 = 15\"\n\n// Methodenaufrufe\nlet upper = `Name: ${name.to_upper()}`;     // \"Name: ALICE\"\n\n// Verschachtelte Objekte\nlet person = { name: \"Bob\", city: \"NYC\" };\nlet desc = `${person.name} lebt in ${person.city}`;  // \"Bob lebt in NYC\"\n\n// Mehrzeilig (behlt Zeilenumbrueche bei)\nlet multi = `Zeile 1\nZeile 2\nZeile 3`;\n```\n\n**Template-String-Funktionen:**\n- Ausdrcke innerhalb von `${...}` werden ausgewertet und in Strings konvertiert\n- Jeder gueltige Ausdruck kann verwendet werden (Variablen, Funktionsaufrufe, Arithmetik)\n- Backtick-Strings untersttzen dieselben Escape-Sequenzen wie regulre Strings\n- Ntzlich zum Erstellen dynamischer Strings ohne Verkettung\n\n### Escaping in Template-Strings\n\nUm ein literales `${` in einem Template-String einzufuegen, escapen Sie das Dollarzeichen:\n\n```hemlock\nlet price = 100;\nlet text = `Preis: \\${price} oder ${price}`;\n// \"Preis: ${price} oder 100\"\n\n// Literaler Backtick\nlet code = `Verwende \\` fr Template-Strings`;\n// \"Verwende ` fr Template-Strings\"\n```\n\n### Komplexe Ausdrcke\n\nTemplate-Strings knnen jeden gueltigen Ausdruck enthalten:\n\n```hemlock\n// Ternaer-hnliche Ausdrcke\nlet age = 25;\nlet status = `Status: ${age >= 18 ? \"erwachsen\" : \"minderjaehrig\"}`;\n\n// Array-Zugriff\nlet items = [\"Apfel\", \"Banane\", \"Kirsche\"];\nlet first = `Erstes Element: ${items[0]}`;\n\n// Funktionsaufrufe mit Argumenten\nfn format_price(p) { return p + \" EUR\"; }\nlet msg = `Gesamt: ${format_price(99.99)}`;  // \"Gesamt: 99.99 EUR\"\n\n// Verkettete Methodenaufrufe\nlet name = \"alice\";\nlet formatted = `Hallo, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;\n// \"Hallo, Alice!\"\n```\n\n### Template-Strings vs. Verkettung\n\nTemplate-Strings sind oft sauberer als Verkettung:\n\n```hemlock\n// Verkettung (schwerer zu lesen)\nlet msg1 = \"Hallo, \" + name + \"! Du hast \" + count + \" Nachrichten.\";\n\n// Template-String (leichter zu lesen)\nlet msg2 = `Hallo, ${name}! Du hast ${count} Nachrichten.`;\n```\n\n## Indizierung und Veraenderung\n\n### Zeichen lesen\n\nIndizierung gibt eine `rune` (Unicode-Codepoint) zurck:\n\n```hemlock\nlet s = \"Hello\";\nlet first = s[0];      // 'H' (Rune)\nlet last = s[4];       // 'o' (Rune)\n\n// UTF-8-Beispiel\nlet emoji = \"Hi!\";\nlet rocket = emoji[2];  // '' (Rune an Codepoint-Index 2)\n```\n\n### Zeichen schreiben\n\nStrings sind veraenderbar - Sie knnen einzelne Zeichen modifizieren:\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';            // Jetzt \"Hello\"\ns[4] = '!';            // Jetzt \"Hell!\"\n\n// Mit Unicode\nlet msg = \"Go!\";\nmsg[0] = '';         // Jetzt \"o!\"\n```\n\n## Verkettung\n\nVerwenden Sie `+` um Strings zu verketten:\n\n```hemlock\nlet greeting = \"Hello\" + \" \" + \"World\";  // \"Hello World\"\n\n// Mit Variablen\nlet name = \"Alice\";\nlet msg = \"Hallo, \" + name + \"!\";  // \"Hallo, Alice!\"\n\n// Mit Runen (siehe Runes-Dokumentation)\nlet s = \"Hello\" + '!';          // \"Hello!\"\n```\n\n## String-Methoden\n\nHemlock bietet 19 String-Methoden fr umfassende Textmanipulation.\n\n### Teilstring & Slicing\n\n**`substr(start, length)`** - Teilstring nach Position und Lnge extrahieren:\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\" (Start bei 6, Lnge 5)\nlet first = s.substr(0, 5);     // \"hello\"\n\n// UTF-8-Beispiel\nlet text = \"Hi!\";\nlet emoji = text.substr(2, 1);  // \"\" (Position 2, Lnge 1)\n```\n\n**`slice(start, end)`** - Teilstring nach Bereich extrahieren (Ende exklusiv):\n```hemlock\nlet s = \"hello world\";\nlet slice = s.slice(0, 5);      // \"hello\" (Index 0 bis 4)\nlet slice2 = s.slice(6, 11);    // \"world\"\n```\n\n**Unterschied:**\n- `substr(start, length)` - Verwendet Laengenparameter\n- `slice(start, end)` - Verwendet Endindex (exklusiv)\n\n### Suchen & Finden\n\n**`find(needle)`** - Erstes Vorkommen finden:\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6 (Index des ersten Vorkommens)\nlet pos2 = s.find(\"foo\");       // -1 (nicht gefunden)\nlet pos3 = s.find(\"l\");         // 2 (erstes 'l')\n```\n\n**`contains(needle)`** - Prfen, ob String Teilstring enthlt:\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n### Aufteilen & Trimmen\n\n**`split(delimiter)`** - In Array von Strings aufteilen:\n```hemlock\nlet csv = \"Apfel,Banane,Kirsche\";\nlet parts = csv.split(\",\");     // [\"Apfel\", \"Banane\", \"Kirsche\"]\n\nlet words = \"eins zwei drei\".split(\" \");  // [\"eins\", \"zwei\", \"drei\"]\n\n// Leerer Delimiter teilt nach Zeichen\nlet chars = \"abc\".split(\"\");    // [\"a\", \"b\", \"c\"]\n```\n\n**`trim()`** - Fhrende/nachfolgende Leerzeichen entfernen:\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet s2 = \"\\t\\ntext\\n\\t\";\nlet clean2 = s2.trim();         // \"text\"\n```\n\n### Gro-/Kleinschreibung\n\n**`to_upper()`** - In Grossbuchstaben umwandeln:\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\n// Behaelt Nicht-ASCII bei\nlet s2 = \"caf\";\nlet upper2 = s2.to_upper();     // \"CAF\"\n```\n\n**`to_lower()`** - In Kleinbuchstaben umwandeln:\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n```\n\n### Prfix-/Suffix-Prfung\n\n**`starts_with(prefix)`** - Prfen, ob mit Prfix beginnt:\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n**`ends_with(suffix)`** - Prfen, ob mit Suffix endet:\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n### Ersetzen\n\n**`replace(old, new)`** - Erstes Vorkommen ersetzen:\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");      // \"hello there\"\n\nlet s3 = \"foo foo foo\";\nlet s4 = s3.replace(\"foo\", \"bar\");         // \"bar foo foo\" (nur erstes)\n```\n\n**`replace_all(old, new)`** - Alle Vorkommen ersetzen:\n```hemlock\nlet s = \"foo foo foo\";\nlet s2 = s.replace_all(\"foo\", \"bar\");      // \"bar bar bar\"\n\nlet s3 = \"hello world, world!\";\nlet s4 = s3.replace_all(\"world\", \"hemlock\"); // \"hello hemlock, hemlock!\"\n```\n\n### Wiederholung\n\n**`repeat(count)`** - String n-mal wiederholen:\n```hemlock\nlet s = \"ha\";\nlet laugh = s.repeat(3);        // \"hahaha\"\n\nlet line = \"=\".repeat(40);      // \"========================================\"\n```\n\n### Zeichen- & Byte-Zugriff\n\n**`char_at(index)`** - Unicode-Codepoint an Index abrufen (gibt Rune zurck):\n```hemlock\nlet s = \"hello\";\nlet char = s.char_at(0);        // 'h' (Rune)\n\n// UTF-8-Beispiel\nlet emoji = \"\";\nlet rocket = emoji.char_at(0);  // Gibt Rune U+1F680 zurck\n```\n\n**`chars()`** - In Array von Runen (Codepoints) umwandeln:\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o'] (Array von Runen)\n\n// UTF-8-Beispiel\nlet text = \"Hi\";\nlet chars2 = text.chars();      // ['H', 'i', '']\n```\n\n**`byte_at(index)`** - Byte-Wert an Index abrufen (gibt u8 zurck):\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (ASCII-Wert von 'h')\n\n// UTF-8-Beispiel\nlet emoji = \"\";\nlet first_byte = emoji.byte_at(0);  // 240 (erstes UTF-8-Byte)\n```\n\n**`bytes()`** - In Array von Bytes (u8-Werte) umwandeln:\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111] (Array von u8)\n\n// UTF-8-Beispiel\nlet emoji = \"\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 UTF-8-Bytes)\n```\n\n**`to_bytes()`** - In Buffer fr Low-Level-Zugriff umwandeln:\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();         // Gibt Buffer mit UTF-8-Bytes zurck\nprint(buf.length);              // 5\nfree(buf);                      // Nicht vergessen freizugeben\n```\n\n## Methodenverkettung\n\nAlle String-Methoden geben neue Strings zurck, was Verkettung ermglicht:\n\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \")\n    .to_upper();                    // \"FOO | BAR | BAZ\"\n```\n\n## Vollstndige Methodenreferenz\n\n| Methode | Parameter | Rckgabe | Beschreibung |\n|---------|-----------|-----------|--------------|\n| `substr(start, length)` | i32, i32 | string | Teilstring nach Position und Lnge extrahieren |\n| `slice(start, end)` | i32, i32 | string | Teilstring nach Bereich extrahieren (Ende exklusiv) |\n| `find(needle)` | string | i32 | Erstes Vorkommen finden (-1 wenn nicht gefunden) |\n| `contains(needle)` | string | bool | Prfen, ob Teilstring enthalten ist |\n| `split(delimiter)` | string | array | In Array von Strings aufteilen |\n| `trim()` | - | string | Fhrende/nachfolgende Leerzeichen entfernen |\n| `to_upper()` | - | string | In Grossbuchstaben umwandeln |\n| `to_lower()` | - | string | In Kleinbuchstaben umwandeln |\n| `starts_with(prefix)` | string | bool | Prfen, ob mit Prfix beginnt |\n| `ends_with(suffix)` | string | bool | Prfen, ob mit Suffix endet |\n| `replace(old, new)` | string, string | string | Erstes Vorkommen ersetzen |\n| `replace_all(old, new)` | string, string | string | Alle Vorkommen ersetzen |\n| `repeat(count)` | i32 | string | String n-mal wiederholen |\n| `char_at(index)` | i32 | rune | Codepoint an Index abrufen |\n| `byte_at(index)` | i32 | u8 | Byte-Wert an Index abrufen |\n| `chars()` | - | array | In Array von Runen umwandeln |\n| `bytes()` | - | array | In Array von u8-Bytes umwandeln |\n| `to_bytes()` | - | buffer | In Buffer umwandeln (muss freigegeben werden) |\n\n## Beispiele\n\n### Beispiel: Textverarbeitung\n\n```hemlock\nfn process_input(text: string): string {\n    return text\n        .trim()\n        .to_lower()\n        .replace_all(\"  \", \" \");  // Leerzeichen normalisieren\n}\n\nlet input = \"  HELLO   WORLD  \";\nlet clean = process_input(input);  // \"hello world\"\n```\n\n### Beispiel: CSV-Parser\n\n```hemlock\nfn parse_csv_line(line: string): array {\n    let trimmed = line.trim();\n    let fields = trimmed.split(\",\");\n\n    let result = [];\n    let i = 0;\n    while (i < fields.length) {\n        result.push(fields[i].trim());\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet csv = \"Apfel, Banane , Kirsche\";\nlet fields = parse_csv_line(csv);  // [\"Apfel\", \"Banane\", \"Kirsche\"]\n```\n\n### Beispiel: Wrter zaehlen\n\n```hemlock\nfn count_words(text: string): i32 {\n    let words = text.trim().split(\" \");\n    return words.length;\n}\n\nlet sentence = \"Der schnelle braune Fuchs\";\nlet count = count_words(sentence);  // 4\n```\n\n### Beispiel: String-Validierung\n\n```hemlock\nfn is_valid_email(email: string): bool {\n    if (!email.contains(\"@\")) {\n        return false;\n    }\n\n    if (!email.contains(\".\")) {\n        return false;\n    }\n\n    if (email.starts_with(\"@\") || email.ends_with(\"@\")) {\n        return false;\n    }\n\n    return true;\n}\n\nprint(is_valid_email(\"user@example.com\"));  // true\nprint(is_valid_email(\"ungltig\"));         // false\n```\n\n## Speicherverwaltung\n\nStrings sind heap-allokiert mit interner Referenzzaehlung:\n\n- **Erstellung**: Auf dem Heap allokiert mit Kapazitaetsverfolgung\n- **Verkettung**: Erzeugt neuen String (alte Strings unverndert)\n- **Methoden**: Die meisten Methoden geben neue Strings zurck\n- **Lebensdauer**: Strings sind referenzgezhlt und werden automatisch freigegeben, wenn der Gltigkeitsbereich endet\n\n**Automatische Bereinigung:**\n```hemlock\nfn create_strings() {\n    let s = \"hello\";\n    let s2 = s + \" world\";  // Neue Allokation\n}  // Sowohl s als auch s2 werden automatisch freigegeben, wenn die Funktion zurckkehrt\n```\n\n**Hinweis:** Lokale String-Variablen werden automatisch bereinigt, wenn sie den Gltigkeitsbereich verlassen. Verwenden Sie `free()` nur fr fruehe Bereinigung vor Bereichsende oder fr langlebige/globale Daten. Siehe [Speicherverwaltung](memory.md#internal-reference-counting) fr Details.\n\n## Best Practices\n\n1. **Codepoint-Indizierung verwenden** - Strings verwenden Codepoint-Positionen, nicht Byte-Offsets\n2. **Mit Unicode testen** - String-Operationen immer mit Mehrbyte-Zeichen testen\n3. **Unvernderliche Operationen bevorzugen** - Methoden verwenden, die neue Strings zurckgeben, statt Mutation\n4. **Grenzen prfen** - String-Indizierung fhrt keine Grenzprfung durch (gibt null/Fehler bei ungltig zurck)\n5. **Eingabe normalisieren** - `trim()` und `to_lower()` fr Benutzereingaben verwenden\n\n## Hufige Fallstricke\n\n### Fallstrick: Byte vs. Codepoint-Verwirrung\n\n```hemlock\nlet emoji = \"\";\nprint(emoji.length);        // 1 (Codepoint)\nprint(emoji.byte_length);   // 4 (Bytes)\n\n// Byte- und Codepoint-Operationen nicht mischen\nlet byte = emoji.byte_at(0);  // 240 (erstes Byte)\nlet char = emoji.char_at(0);  // '' (vollstaendiger Codepoint)\n```\n\n### Fallstrick: Mutations-Ueberraschungen\n\n```hemlock\nlet s1 = \"hello\";\nlet s2 = s1;       // Flache Kopie\ns1[0] = 'H';       // Veraendert s1\nprint(s2);         // Immer noch \"hello\" (Strings sind Werttypen)\n```\n\n## Verwandte Themen\n\n- [Runes](#language-guide-runes) - Unicode-Codepoint-Typ, der bei String-Indizierung verwendet wird\n- [Arrays](#language-guide-arrays) - String-Methoden geben oft Arrays zurck oder arbeiten mit ihnen\n- [Types](#language-guide-types) - String-Typ-Details und Konvertierungen\n\n## Siehe auch\n\n- **UTF-8-Kodierung**: Siehe CLAUDE.md Abschnitt \"Strings\"\n- **Typkonvertierungen**: Siehe [Types](#language-guide-types) fr String-Konvertierungen\n- **Speicher**: Siehe [Memory](#language-guide-memory) fr String-Allokationsdetails\n"}, "Fortgeschrittene Themen -> Asynchronitt & Nebenlufigkeit": {"id": "advanced-async-concurrency", "content": "# Async/Nebenlufigkeit in Hemlock\n\nHemlock bietet **strukturierte Nebenlufigkeit** mit async/await-Syntax, Task-Spawning und Channels zur Kommunikation. Die Implementierung verwendet POSIX-Threads (pthreads) fr **echte Multithread-Parallelitt**.\n\n## Inhaltsverzeichnis\n\n- [berblick](#berblick)\n- [Threading-Modell](#threading-modell)\n- [Async-Funktionen](#async-funktionen)\n- [Task-Spawning](#task-spawning)\n- [Channels](#channels)\n- [Ausnahmeweiterleitung](#ausnahmeweiterleitung)\n- [Implementierungsdetails](#implementierungsdetails)\n- [Best Practices](#best-practices)\n- [Leistungsmerkmale](#leistungsmerkmale)\n- [Aktuelle Einschrnkungen](#aktuelle-einschrnkungen)\n\n## berblick\n\n**Was das bedeutet:**\n-  **Echte OS-Threads** - Jeder gespawnte Task luft auf einem separaten pthread (POSIX-Thread)\n-  **Echte Parallelitt** - Tasks werden gleichzeitig auf mehreren CPU-Kernen ausgefhrt\n-  **Kernel-geplant** - Der OS-Scheduler verteilt Tasks auf verfgbare Kerne\n-  **Thread-sichere Channels** - Verwendet pthread-Mutexe und Bedingungsvariablen zur Synchronisation\n\n**Was das NICHT ist:**\n-  **KEINE Green Threads** - Kein User-Space-kooperatives Multitasking\n-  **KEINE async/await-Coroutinen** - Keine Single-Threaded Event-Loop wie JavaScript/Python asyncio\n-  **KEINE emulierte Nebenlufigkeit** - Keine simulierte Parallelitt\n\nDies ist das **gleiche Threading-Modell wie C, C++ und Rust** bei Verwendung von OS-Threads. Sie erhalten echte parallele Ausfhrung ber mehrere Kerne.\n\n## Threading-Modell\n\n### 1:1 Threading\n\nHemlock verwendet ein **1:1 Threading-Modell**, wobei:\n- Jeder gespawnte Task einen dedizierten OS-Thread ber `pthread_create()` erstellt\n- Der OS-Kernel Threads auf verfgbare CPU-Kerne verteilt\n- Premptives Multitasking - das OS kann Threads unterbrechen und zwischen ihnen wechseln\n- **Kein GIL** - Anders als Python gibt es keinen Global Interpreter Lock, der die Parallelitt einschrnkt\n\n### Synchronisationsmechanismen\n\n- **Mutexe** - Channels verwenden `pthread_mutex_t` fr thread-sicheren Zugriff\n- **Bedingungsvariablen** - Blockierendes send/recv verwendet `pthread_cond_t` fr effizientes Warten\n- **Lock-freie Operationen** - Task-Zustandsbergnge sind atomar\n\n## Async-Funktionen\n\nFunktionen knnen als `async` deklariert werden, um anzuzeigen, dass sie fr nebenlufige Ausfhrung konzipiert sind:\n\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n```\n\n### Wichtige Punkte\n\n- `async fn` deklariert eine asynchrone Funktion\n- Async-Funktionen knnen als nebenlufige Tasks mit `spawn()` gestartet werden\n- Async-Funktionen knnen auch direkt aufgerufen werden (luft synchron im aktuellen Thread)\n- Wenn gespawnt, luft jeder Task auf seinem **eigenen OS-Thread** (keine Coroutine!)\n- Das `await`-Schlsselwort ist fr zuknftige Verwendung reserviert\n\n### Beispiel: Direkter Aufruf vs Spawn\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Direkter Aufruf - luft synchron\nlet result1 = factorial(5);  // 120\n\n// Gespawnter Task - luft auf separatem Thread\nlet task = spawn(factorial, 5);\nlet result2 = join(task);  // 120\n```\n\n## Task-Spawning\n\nVerwenden Sie `spawn()`, um async-Funktionen **parallel auf separaten OS-Threads** auszufhren:\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Mehrere Tasks spawnen - diese laufen PARALLEL auf verschiedenen CPU-Kernen!\nlet t1 = spawn(factorial, 5);  // Thread 1\nlet t2 = spawn(factorial, 6);  // Thread 2\nlet t3 = spawn(factorial, 7);  // Thread 3\n\n// Alle drei rechnen gerade gleichzeitig!\n\n// Auf Ergebnisse warten\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\n```\n\n### Eingebaute Funktionen\n\n#### spawn(async_fn, arg1, arg2, ...)\n\nErstellt einen neuen Task auf einem neuen pthread, gibt Task-Handle zurck.\n\n**Parameter:**\n- `async_fn` - Die auszufhrende async-Funktion\n- `arg1, arg2, ...` - Argumente, die an die Funktion bergeben werden\n\n**Rckgabe:** Task-Handle (opaker Wert, der mit `join()` oder `detach()` verwendet wird)\n\n**Beispiel:**\n```hemlock\nasync fn process(data: string, count: i32): i32 {\n    // ... Verarbeitungslogik\n    return count * 2;\n}\n\nlet task = spawn(process, \"test\", 42);\n```\n\n#### join(task)\n\nWarte auf Task-Abschluss (blockiert bis Thread fertig ist), gibt Ergebnis zurck.\n\n**Parameter:**\n- `task` - Task-Handle, das von `spawn()` zurckgegeben wurde\n\n**Rckgabe:** Der von der async-Funktion zurckgegebene Wert\n\n**Beispiel:**\n```hemlock\nlet task = spawn(compute, 1000);\nlet result = join(task);  // Blockiert bis compute() fertig ist\nprint(result);\n```\n\n**Wichtig:** Jeder Task kann nur einmal gejoined werden. Nachfolgende Joins werden einen Fehler verursachen.\n\n#### detach(task)\n\nFire-and-Forget-Ausfhrung (Thread luft unabhngig, kein Join erlaubt).\n\n**Parameter:**\n- `task` - Task-Handle, das von `spawn()` zurckgegeben wurde\n\n**Rckgabe:** `null`\n\n**Beispiel:**\n```hemlock\nasync fn background_work() {\n    // Lang laufender Hintergrund-Task\n    // ...\n}\n\nlet task = spawn(background_work);\ndetach(task);  // Task luft unabhngig, kann nicht gejoined werden\n```\n\n**Wichtig:** Losgelste Tasks knnen nicht gejoined werden. Sowohl der pthread als auch die Task-Struktur werden automatisch bereinigt, wenn der Task abgeschlossen ist.\n\n## Channels\n\nChannels bieten thread-sichere Kommunikation zwischen Tasks unter Verwendung eines begrenzten Puffers mit blockierender Semantik.\n\n### Channels erstellen\n\n```hemlock\nlet ch = channel(10);  // Channel mit Puffergre 10 erstellen\n```\n\n**Parameter:**\n- `capacity` (i32) - Maximale Anzahl von Werten, die der Channel halten kann\n\n**Rckgabe:** Channel-Objekt\n\n### Channel-Methoden\n\n#### send(value)\n\nSende Wert an Channel (blockiert wenn voll).\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet task = spawn(producer, ch, 5);\n```\n\n**Verhalten:**\n- Wenn Channel Platz hat, wird Wert sofort hinzugefgt\n- Wenn Channel voll ist, blockiert der Sender bis Platz verfgbar wird\n- Wenn Channel geschlossen ist, wird Ausnahme geworfen\n\n#### recv()\n\nEmpfange Wert von Channel (blockiert wenn leer).\n\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet task = spawn(consumer, ch, 5);\n```\n\n**Verhalten:**\n- Wenn Channel Werte hat, wird nchster Wert sofort zurckgegeben\n- Wenn Channel leer ist, blockiert der Empfnger bis Wert verfgbar\n- Wenn Channel geschlossen und leer ist, gibt `null` zurck\n\n#### close()\n\nSchliee Channel (recv auf geschlossenem Channel gibt null zurck).\n\n```hemlock\nch.close();\n```\n\n**Verhalten:**\n- Verhindert weitere `send()`-Operationen (wirft Ausnahme)\n- Erlaubt ausstehenden `recv()`-Operationen abzuschlieen\n- Sobald leer, gibt `recv()` `null` zurck\n\n### Multiplexing mit select()\n\nDie `select()`-Funktion ermglicht das gleichzeitige Warten auf mehrere Channels und gibt zurck, wenn ein Channel Daten verfgbar hat.\n\n**Signatur:**\n```hemlock\nselect(channels: array, timeout_ms?: i32): object | null\n```\n\n**Parameter:**\n- `channels` - Array von Channel-Werten\n- `timeout_ms` (optional) - Timeout in Millisekunden (-1 oder weglassen fr unendliches Warten)\n\n**Rckgabe:**\n- `{ channel, value }` - Objekt mit dem Channel, der Daten hatte, und dem empfangenen Wert\n- `null` - Bei Timeout (wenn Timeout angegeben wurde)\n\n**Beispiel:**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// Producer-Tasks\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"von Channel 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"von Channel 2\");\n});\n\n// Auf erstes Ergebnis warten (ch2 sollte schneller sein)\nlet result = select([ch1, ch2]);\nprint(result.value);  // \"von Channel 2\"\n\n// Auf zweites Ergebnis warten\nlet result2 = select([ch1, ch2]);\nprint(result2.value);  // \"von Channel 1\"\n```\n\n**Mit Timeout:**\n```hemlock\nlet ch = channel(1);\n\n// Kein Sender, wird Timeout erreichen\nlet result = select([ch], 100);  // 100ms Timeout\nif (result == null) {\n    print(\"Timeout!\");\n}\n```\n\n**Anwendungsflle:**\n- Warten auf die schnellste von mehreren Datenquellen\n- Implementierung von Timeouts bei Channel-Operationen\n- Event-Loop-Muster mit mehreren Ereignisquellen\n- Fan-in: Zusammenfhren mehrerer Channels zu einem\n\n**Fan-in-Muster:**\n```hemlock\nfn fan_in(channels: array, output: channel) {\n    while (true) {\n        let result = select(channels);\n        if (result == null) {\n            break;  // Alle Channels geschlossen\n        }\n        output.send(result.value);\n    }\n    output.close();\n}\n```\n\n### Vollstndiges Producer-Consumer-Beispiel\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Channel mit Puffergre erstellen\nlet ch = channel(10);\n\n// Producer und Consumer spawnen\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Auf Abschluss warten\njoin(p);\nlet total = join(c);  // 100 (0+10+20+30+40)\nprint(total);\n```\n\n### Multi-Producer, Multi-Consumer\n\nChannels knnen sicher zwischen mehreren Producern und Consumern geteilt werden:\n\n```hemlock\nasync fn producer(id: i32, ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(id * 100 + i);\n        i = i + 1;\n    }\n}\n\nasync fn consumer(id: i32, ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(20);\n\n// Mehrere Producer\nlet p1 = spawn(producer, 1, ch, 5);\nlet p2 = spawn(producer, 2, ch, 5);\n\n// Mehrere Consumer\nlet c1 = spawn(consumer, 1, ch, 5);\nlet c2 = spawn(consumer, 2, ch, 5);\n\n// Auf alle warten\njoin(p1);\njoin(p2);\nlet sum1 = join(c1);\nlet sum2 = join(c2);\nprint(sum1 + sum2);\n```\n\n## Ausnahmeweiterleitung\n\nAusnahmen, die in gespawnten Tasks geworfen werden, werden beim Join weitergeleitet:\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task fehlgeschlagen!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Gefangen: \" + e);  // \"Gefangen: Task fehlgeschlagen!\"\n}\n```\n\n### Ausnahmebehandlungsmuster\n\n**Muster 1: Im Task behandeln**\n```hemlock\nasync fn safe_task() {\n    try {\n        // riskante Operation\n    } catch (e) {\n        print(\"Fehler im Task: \" + e);\n        return null;\n    }\n}\n\nlet task = spawn(safe_task);\njoin(task);  // Keine Ausnahme weitergeleitet\n```\n\n**Muster 2: An Aufrufer weiterleiten**\n```hemlock\nasync fn task_that_throws() {\n    throw \"fehler\";\n}\n\nlet task = spawn(task_that_throws);\ntry {\n    join(task);\n} catch (e) {\n    print(\"Von Task gefangen: \" + e);\n}\n```\n\n**Muster 3: Losgelste Tasks mit Ausnahmen**\n```hemlock\nasync fn detached_task() {\n    try {\n        // Arbeit\n    } catch (e) {\n        // Muss intern behandelt werden - kann nicht weitergeleitet werden\n        print(\"Fehler: \" + e);\n    }\n}\n\nlet task = spawn(detached_task);\ndetach(task);  // Kann keine Ausnahmen von losgelsten Tasks fangen\n```\n\n## Implementierungsdetails\n\n### Threading-Architektur\n\n- **1:1 Threading** - Jeder gespawnte Task erstellt einen dedizierten OS-Thread ber `pthread_create()`\n- **Kernel-geplant** - Der OS-Kernel verteilt Threads auf verfgbare CPU-Kerne\n- **Premptives Multitasking** - Das OS kann Threads unterbrechen und zwischen ihnen wechseln\n- **Kein GIL** - Anders als Python gibt es keinen Global Interpreter Lock, der die Parallelitt einschrnkt\n\n### Channel-Implementierung\n\nChannels verwenden einen Ringpuffer mit pthread-Synchronisation:\n\n```\nChannel-Struktur:\n- buffer[] - Array fester Gre von Values\n- capacity - Maximale Anzahl von Elementen\n- size - Aktuelle Anzahl von Elementen\n- head - Leseposition\n- tail - Schreibposition\n- mutex - pthread_mutex_t fr thread-sicheren Zugriff\n- not_empty - pthread_cond_t fr blockierendes recv\n- not_full - pthread_cond_t fr blockierendes send\n- closed - Boolean-Flag\n- refcount - Referenzzhler fr Bereinigung\n```\n\n**Blockierendes Verhalten:**\n- `send()` auf vollem Channel: wartet auf `not_full` Bedingungsvariable\n- `recv()` auf leerem Channel: wartet auf `not_empty` Bedingungsvariable\n- Beide werden durch die gegenteilige Operation entsprechend signalisiert\n\n### Speicher & Bereinigung\n\n- **Gejoinede Tasks:** Werden automatisch bereinigt, nachdem `join()` zurckkehrt\n- **Losgelste Tasks:** Werden automatisch bereinigt, wenn der Task abgeschlossen ist\n- **Channels:** Referenzgezhlt und freigegeben, wenn nicht mehr verwendet\n\n## Best Practices\n\n### 1. Channels immer schlieen\n\n```hemlock\nasync fn producer(ch) {\n    // ... Werte senden\n    ch.close();  // Wichtig: signalisiert, dass keine weiteren Werte kommen\n}\n```\n\n### 2. Strukturierte Nebenlufigkeit verwenden\n\nTasks spawnen und im selben Scope joinen:\n\n```hemlock\nfn process_data(data) {\n    // Tasks spawnen\n    let t1 = spawn(worker, data);\n    let t2 = spawn(worker, data);\n\n    // Immer vor dem Rckgeben joinen\n    let r1 = join(t1);\n    let r2 = join(t2);\n\n    return r1 + r2;\n}\n```\n\n### 3. Ausnahmen angemessen behandeln\n\n```hemlock\nasync fn task() {\n    try {\n        // riskante Operation\n    } catch (e) {\n        // Fehler loggen\n        throw e;  // Erneut werfen, wenn Aufrufer es wissen soll\n    }\n}\n```\n\n### 4. Angemessene Channel-Kapazitt verwenden\n\n- **Kleine Kapazitt (1-10):** Fr Koordination/Signalisierung\n- **Mittlere Kapazitt (10-100):** Fr allgemeines Producer-Consumer\n- **Groe Kapazitt (100+):** Fr Hochdurchsatz-Szenarien\n\n```hemlock\nlet signal_ch = channel(1);      // Koordination\nlet work_ch = channel(50);       // Arbeits-Warteschlange\nlet buffer_ch = channel(1000);   // Hoher Durchsatz\n```\n\n### 5. Nur bei Bedarf loslsen\n\nBevorzugen Sie `join()` gegenber `detach()` fr besseres Ressourcenmanagement:\n\n```hemlock\n// Gut: Join und Ergebnis erhalten\nlet task = spawn(work);\nlet result = join(task);\n\n// Detach nur fr echtes Fire-and-Forget verwenden\nlet bg_task = spawn(background_logging);\ndetach(bg_task);  // Luft unabhngig\n```\n\n## Leistungsmerkmale\n\n### Echte Parallelitt\n\n- **N gespawnte Tasks knnen N CPU-Kerne gleichzeitig nutzen**\n- Nachgewiesene Beschleunigung - Stresstests zeigen 8-9x CPU-Zeit vs Wandzeit (mehrere Kerne arbeiten)\n- Lineare Skalierung mit Anzahl der Kerne (bis zur Thread-Anzahl)\n\n### Thread-Overhead\n\n- Jeder Task hat ~8KB Stack + pthread-Overhead\n- Thread-Erstellungskosten: ~10-20s\n- Kontextwechselkosten: ~1-5s\n\n### Wann Async verwenden\n\n**Gute Anwendungsflle:**\n- CPU-intensive Berechnungen, die parallelisiert werden knnen\n- I/O-gebundene Operationen (obwohl I/O immer noch blockiert)\n- Nebenlufige Verarbeitung unabhngiger Daten\n- Pipeline-Architekturen mit Channels\n\n**Nicht ideal fr:**\n- Sehr kurze Tasks (Thread-Overhead dominiert)\n- Tasks mit starker Synchronisation (Contention-Overhead)\n- Single-Core-Systeme (kein Parallelittsvorteil)\n\n### Blockierendes I/O sicher\n\nBlockierende Operationen in einem Task blockieren keine anderen:\n\n```hemlock\nasync fn reader(filename: string) {\n    let f = open(filename, \"r\");  // Blockiert nur diesen Thread\n    let content = f.read();       // Blockiert nur diesen Thread\n    f.close();\n    return content;\n}\n\n// Beide lesen nebenlufig (auf verschiedenen Threads)\nlet t1 = spawn(reader, \"file1.txt\");\nlet t2 = spawn(reader, \"file2.txt\");\n\nlet c1 = join(t1);\nlet c2 = join(t2);\n```\n\n## Thread-Sicherheitsmodell\n\nHemlock verwendet ein **Message-Passing**-Nebenlufigkeitsmodell, bei dem Tasks ber Channels kommunizieren, anstatt gemeinsamen vernderlichen Zustand zu verwenden.\n\n### Argument-Isolation\n\nWenn Sie einen Task spawnen, werden **Argumente tief kopiert**, um Data Races zu verhindern:\n\n```hemlock\nasync fn modify_array(arr: array): array {\n    arr.push(999);    // Modifiziert die KOPIE, nicht das Original\n    arr[0] = -1;\n    return arr;\n}\n\nlet original = [1, 2, 3];\nlet task = spawn(modify_array, original);\nlet modified = join(task);\n\nprint(original.length);  // 3 - unverndert!\nprint(modified.length);  // 4 - hat neues Element\n```\n\n**Was tief kopiert wird:**\n- Arrays (und alle Elemente rekursiv)\n- Objekte (und alle Felder rekursiv)\n- Strings\n- Buffer\n\n**Was geteilt wird (Referenz beibehalten):**\n- Channels (der Kommunikationsmechanismus - absichtlich geteilt)\n- Task-Handles (fr Koordination)\n- Funktionen (Code ist unvernderlich)\n- Datei-Handles (OS verwaltet nebenlufigen Zugriff)\n- Socket-Handles (OS verwaltet nebenlufigen Zugriff)\n\n**Was nicht bergeben werden kann:**\n- Rohe Pointer (`ptr`) - verwenden Sie stattdessen `buffer`\n\n### Warum Message-Passing?\n\nDies folgt Hemlocks \"explizit statt implizit\"-Philosophie:\n\n```hemlock\n// SCHLECHT: Gemeinsamer vernderlicher Zustand (wrde Data Races verursachen)\nlet counter = { value: 0 };\nlet t1 = spawn(fn() { counter.value = counter.value + 1; });  // Race!\nlet t2 = spawn(fn() { counter.value = counter.value + 1; });  // Race!\n\n// GUT: Message-Passing ber Channels\nasync fn increment(ch) {\n    let val = ch.recv();\n    ch.send(val + 1);\n}\n\nlet ch = channel(1);\nch.send(0);\nlet t1 = spawn(increment, ch);\njoin(t1);\nlet result = ch.recv();  // 1 - keine Race Condition\n```\n\n### Thread-Sicherheit der Referenzzhlung\n\nAlle Referenzzhlungsoperationen verwenden **atomare Operationen**, um Use-after-Free-Bugs zu verhindern:\n- `string_retain/release` - atomar\n- `array_retain/release` - atomar\n- `object_retain/release` - atomar\n- `buffer_retain/release` - atomar\n- `function_retain/release` - atomar\n- `channel_retain/release` - atomar\n- `task_retain/release` - atomar\n\nDies gewhrleistet sicheres Speichermanagement auch wenn Werte ber Threads geteilt werden.\n\n### Closure-Umgebungszugriff\n\nTasks haben Zugriff auf die Closure-Umgebung fr:\n- Eingebaute Funktionen (`print`, `len`, etc.)\n- Globale Funktionsdefinitionen\n- Konstanten und Variablen\n\nDie Closure-Umgebung wird durch einen pro-Umgebung-Mutex geschtzt, was\nnebenlufige Lese- und Schreibzugriffe thread-sicher macht:\n\n```hemlock\nlet x = 10;\n\nasync fn read_closure(): i32 {\n    return x;  // OK: Lesen von Closure-Variable (thread-sicher)\n}\n\nasync fn modify_closure() {\n    x = 20;  // OK: Schreiben von Closure-Variable (synchronisiert mit Mutex)\n}\n```\n\n**Hinweis:** Obwohl nebenlufiger Zugriff synchronisiert ist, kann das Modifizieren von gemeinsam genutztem Zustand aus mehreren Tasks immer noch zu logischen Race Conditions fhren (nicht-deterministische Reihenfolge). Fr vorhersehbares Verhalten verwenden Sie Channels fr Task-Kommunikation oder Rckgabewerte von Tasks.\n\nWenn Sie Daten von einem Task zurckgeben mssen, verwenden Sie den Rckgabewert oder Channels.\n\n## Aktuelle Einschrnkungen\n\n### 1. Kein Work-Stealing-Scheduler\n\nVerwendet 1 Thread pro Task, was bei vielen kurzen Tasks ineffizient sein kann.\n\n**Aktuell:** 1000 Tasks = 1000 Threads (hoher Overhead)\n\n**Geplant:** Thread-Pool mit Work-Stealing fr bessere Effizienz\n\n### 3. Keine Async-I/O-Integration\n\nDatei-/Netzwerkoperationen blockieren immer noch den Thread:\n\n```hemlock\nasync fn read_file(path: string) {\n    let f = open(path, \"r\");\n    let content = f.read();  // Blockiert den Thread\n    f.close();\n    return content;\n}\n```\n\n**Workaround:** Verwenden Sie mehrere Threads fr nebenlufige I/O-Operationen\n\n### 4. Feste Channel-Kapazitt\n\nChannel-Kapazitt wird bei der Erstellung festgelegt und kann nicht gendert werden:\n\n```hemlock\nlet ch = channel(10);\n// Kann nicht dynamisch auf 20 gendert werden\n```\n\n### 5. Channel-Gre ist fest\n\nChannel-Puffergre kann nach der Erstellung nicht gendert werden.\n\n## Hufige Muster\n\n### Paralleles Map\n\n```hemlock\nasync fn map_worker(ch_in, ch_out, fn_transform) {\n    while (true) {\n        let val = ch_in.recv();\n        if (val == null) { break; }\n\n        let result = fn_transform(val);\n        ch_out.send(result);\n    }\n    ch_out.close();\n}\n\nfn parallel_map(data, fn_transform, workers: i32) {\n    let ch_in = channel(100);\n    let ch_out = channel(100);\n\n    // Worker spawnen\n    let tasks = [];\n    let i = 0;\n    while (i < workers) {\n        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));\n        i = i + 1;\n    }\n\n    // Daten senden\n    let i = 0;\n    while (i < data.length) {\n        ch_in.send(data[i]);\n        i = i + 1;\n    }\n    ch_in.close();\n\n    // Ergebnisse sammeln\n    let results = [];\n    let i = 0;\n    while (i < data.length) {\n        results.push(ch_out.recv());\n        i = i + 1;\n    }\n\n    // Auf Worker warten\n    let i = 0;\n    while (i < tasks.length) {\n        join(tasks[i]);\n        i = i + 1;\n    }\n\n    return results;\n}\n```\n\n### Pipeline-Architektur\n\n```hemlock\nasync fn stage1(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val * 2);\n    }\n    output_ch.close();\n}\n\nasync fn stage2(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val + 10);\n    }\n    output_ch.close();\n}\n\n// Pipeline erstellen\nlet ch1 = channel(10);\nlet ch2 = channel(10);\nlet ch3 = channel(10);\n\nlet s1 = spawn(stage1, ch1, ch2);\nlet s2 = spawn(stage2, ch2, ch3);\n\n// Eingabe einspeisen\nch1.send(1);\nch1.send(2);\nch1.send(3);\nch1.close();\n\n// Ausgabe sammeln\nprint(ch3.recv());  // 12 (1 * 2 + 10)\nprint(ch3.recv());  // 14 (2 * 2 + 10)\nprint(ch3.recv());  // 16 (3 * 2 + 10)\n\njoin(s1);\njoin(s2);\n```\n\n### Fan-Out, Fan-In\n\n```hemlock\nasync fn worker(id: i32, input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n\n        // Wert verarbeiten\n        let result = val * id;\n        output_ch.send(result);\n    }\n}\n\nlet input = channel(10);\nlet output = channel(10);\n\n// Fan-out: Mehrere Worker\nlet workers = 4;\nlet tasks = [];\nlet i = 0;\nwhile (i < workers) {\n    tasks.push(spawn(worker, i, input, output));\n    i = i + 1;\n}\n\n// Arbeit senden\nlet i = 0;\nwhile (i < 10) {\n    input.send(i);\n    i = i + 1;\n}\ninput.close();\n\n// Fan-in: Alle Ergebnisse sammeln\nlet results = [];\nlet i = 0;\nwhile (i < 10) {\n    results.push(output.recv());\n    i = i + 1;\n}\n\n// Auf alle Worker warten\nlet i = 0;\nwhile (i < tasks.length) {\n    join(tasks[i]);\n    i = i + 1;\n}\n```\n\n## Zusammenfassung\n\nHemlocks Async/Nebenlufigkeitsmodell bietet:\n\n-  Echte Multithread-Parallelitt mit OS-Threads\n-  Einfache, strukturierte Nebenlufigkeitsprimitive\n-  Thread-sichere Channels fr Kommunikation\n-  Ausnahmeweiterleitung ber Tasks\n-  Nachgewiesene Leistung auf Multi-Core-Systemen\n-  **Argument-Isolation** - Tiefe Kopie verhindert Data Races\n-  **Atomare Referenzzhlung** - Sicheres Speichermanagement ber Threads\n\nDies macht Hemlock geeignet fr:\n- Parallele Berechnungen\n- Nebenlufige I/O-Operationen\n- Pipeline-Architekturen\n- Producer-Consumer-Muster\n\nWhrend die Komplexitt vermieden wird von:\n- Manuellem Thread-Management\n- Low-Level-Synchronisationsprimitiven\n- Deadlock-anflligen Lock-basierten Designs\n- Bugs durch gemeinsamen vernderlichen Zustand\n"}, "Fortgeschrittene Themen -> Atomare Operationen": {"id": "advanced-atomics", "content": "# Atomare Operationen\n\nHemlock bietet atomare Operationen fr **lock-freie nebenlufige Programmierung**. Diese Operationen ermglichen sichere Manipulation von gemeinsamem Speicher ber mehrere Threads ohne traditionelle Locks oder Mutexe.\n\n## Inhaltsverzeichnis\n\n- [berblick](#berblick)\n- [Wann Atomics verwenden](#wann-atomics-verwenden)\n- [Speichermodell](#speichermodell)\n- [Atomares Laden und Speichern](#atomares-laden-und-speichern)\n- [Fetch-and-Modify-Operationen](#fetch-and-modify-operationen)\n- [Compare-and-Swap (CAS)](#compare-and-swap-cas)\n- [Atomarer Austausch](#atomarer-austausch)\n- [Speicherbarriere](#speicherbarriere)\n- [Funktionsreferenz](#funktionsreferenz)\n- [Hufige Muster](#hufige-muster)\n- [Best Practices](#best-practices)\n- [Einschrnkungen](#einschrnkungen)\n\n---\n\n## berblick\n\nAtomare Operationen sind **unteilbare** Operationen, die ohne Mglichkeit der Unterbrechung abgeschlossen werden. Wenn ein Thread eine atomare Operation ausfhrt, kann kein anderer Thread die Operation in einem teilweise abgeschlossenen Zustand beobachten.\n\n**Hauptmerkmale:**\n- Alle Operationen verwenden **sequenzielle Konsistenz** (`memory_order_seq_cst`)\n- Untersttzte Typen: **i32** und **i64**\n- Operationen arbeiten mit Rohpointern, die mit `alloc()` alloziert wurden\n- Thread-sicher ohne explizite Locks\n\n**Verfgbare Operationen:**\n- Load/Store - Werte atomar lesen und schreiben\n- Add/Sub - Arithmetische Operationen, die den alten Wert zurckgeben\n- And/Or/Xor - Bitweise Operationen, die den alten Wert zurckgeben\n- CAS - Compare-and-Swap fr bedingte Aktualisierungen\n- Exchange - Werte atomar tauschen\n- Fence - Vollstndige Speicherbarriere\n\n---\n\n## Wann Atomics verwenden\n\n**Verwenden Sie Atomics fr:**\n- Zhler, die ber Tasks geteilt werden (z.B. Anfragezhler, Fortschrittsverfolgung)\n- Flags und Statusindikatoren\n- Lock-freie Datenstrukturen\n- Einfache Synchronisationsprimitive\n- Leistungskritischen nebenlufigen Code\n\n**Verwenden Sie stattdessen Channels wenn:**\n- Komplexe Daten zwischen Tasks bergeben werden\n- Producer-Consumer-Muster implementiert werden\n- Message-Passing-Semantik bentigt wird\n\n**Beispiel-Anwendungsfall - Geteilter Zhler:**\n```hemlock\n// Geteilten Zhler allozieren\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nasync fn worker(counter: ptr, id: i32) {\n    let i = 0;\n    while (i < 1000) {\n        atomic_add_i32(counter, 1);\n        i = i + 1;\n    }\n}\n\n// Mehrere Worker spawnen\nlet t1 = spawn(worker, counter, 1);\nlet t2 = spawn(worker, counter, 2);\nlet t3 = spawn(worker, counter, 3);\n\njoin(t1);\njoin(t2);\njoin(t3);\n\n// Zhler wird exakt 3000 sein (keine Data Races)\nprint(atomic_load_i32(counter));\n\nfree(counter);\n```\n\n---\n\n## Speichermodell\n\nAlle atomaren Operationen in Hemlock verwenden **sequenzielle Konsistenz** (`memory_order_seq_cst`), was die strksten Speicherordnungsgarantien bietet:\n\n1. **Atomaritt**: Jede Operation ist unteilbar\n2. **Totale Ordnung**: Alle Threads sehen die gleiche Reihenfolge von Operationen\n3. **Keine Umordnung**: Operationen werden nicht vom Compiler oder der CPU umgeordnet\n\nDies macht das Nachdenken ber nebenlufigen Code einfacher, auf Kosten von etwas potentieller Leistung im Vergleich zu schwcheren Speicherordnungen.\n\n---\n\n## Atomares Laden und Speichern\n\n### atomic_load_i32 / atomic_load_i64\n\nAtomar einen Wert aus dem Speicher lesen.\n\n**Signatur:**\n```hemlock\natomic_load_i32(ptr: ptr): i32\natomic_load_i64(ptr: ptr): i64\n```\n\n**Parameter:**\n- `ptr` - Pointer auf die Speicherstelle (muss korrekt ausgerichtet sein)\n\n**Rckgabe:** Der Wert an der Speicherstelle\n\n**Beispiel:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\n\nlet value = atomic_load_i32(p);\nprint(value);  // 42\n\nfree(p);\n```\n\n---\n\n### atomic_store_i32 / atomic_store_i64\n\nAtomar einen Wert in den Speicher schreiben.\n\n**Signatur:**\n```hemlock\natomic_store_i32(ptr: ptr, value: i32): null\natomic_store_i64(ptr: ptr, value: i64): null\n```\n\n**Parameter:**\n- `ptr` - Pointer auf die Speicherstelle\n- `value` - Zu speichernder Wert\n\n**Rckgabe:** `null`\n\n**Beispiel:**\n```hemlock\nlet p = alloc(8);\n\natomic_store_i64(p, 5000000000);\nprint(atomic_load_i64(p));  // 5000000000\n\nfree(p);\n```\n\n---\n\n## Fetch-and-Modify-Operationen\n\nDiese Operationen modifizieren atomar einen Wert und geben den **alten** (vorherigen) Wert zurck.\n\n### atomic_add_i32 / atomic_add_i64\n\nAtomar zu einem Wert addieren.\n\n**Signatur:**\n```hemlock\natomic_add_i32(ptr: ptr, value: i32): i32\natomic_add_i64(ptr: ptr, value: i64): i64\n```\n\n**Rckgabe:** Der **alte** Wert (vor der Addition)\n\n**Beispiel:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_add_i32(p, 10);\nprint(old);                    // 100 (alter Wert)\nprint(atomic_load_i32(p));     // 110 (neuer Wert)\n\nfree(p);\n```\n\n---\n\n### atomic_sub_i32 / atomic_sub_i64\n\nAtomar von einem Wert subtrahieren.\n\n**Signatur:**\n```hemlock\natomic_sub_i32(ptr: ptr, value: i32): i32\natomic_sub_i64(ptr: ptr, value: i64): i64\n```\n\n**Rckgabe:** Der **alte** Wert (vor der Subtraktion)\n\n**Beispiel:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_sub_i32(p, 25);\nprint(old);                    // 100 (alter Wert)\nprint(atomic_load_i32(p));     // 75 (neuer Wert)\n\nfree(p);\n```\n\n---\n\n### atomic_and_i32 / atomic_and_i64\n\nAtomar bitweises UND ausfhren.\n\n**Signatur:**\n```hemlock\natomic_and_i32(ptr: ptr, value: i32): i32\natomic_and_i64(ptr: ptr, value: i64): i64\n```\n\n**Rckgabe:** Der **alte** Wert (vor dem UND)\n\n**Beispiel:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xFF);  // 255 in binr: 11111111\n\nlet old = atomic_and_i32(p, 0x0F);  // UND mit 00001111\nprint(old);                    // 255 (alter Wert)\nprint(atomic_load_i32(p));     // 15 (0xFF & 0x0F = 0x0F)\n\nfree(p);\n```\n\n---\n\n### atomic_or_i32 / atomic_or_i64\n\nAtomar bitweises ODER ausfhren.\n\n**Signatur:**\n```hemlock\natomic_or_i32(ptr: ptr, value: i32): i32\natomic_or_i64(ptr: ptr, value: i64): i64\n```\n\n**Rckgabe:** Der **alte** Wert (vor dem ODER)\n\n**Beispiel:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0x0F);  // 15 in binr: 00001111\n\nlet old = atomic_or_i32(p, 0xF0);  // ODER mit 11110000\nprint(old);                    // 15 (alter Wert)\nprint(atomic_load_i32(p));     // 255 (0x0F | 0xF0 = 0xFF)\n\nfree(p);\n```\n\n---\n\n### atomic_xor_i32 / atomic_xor_i64\n\nAtomar bitweises XOR ausfhren.\n\n**Signatur:**\n```hemlock\natomic_xor_i32(ptr: ptr, value: i32): i32\natomic_xor_i64(ptr: ptr, value: i64): i64\n```\n\n**Rckgabe:** Der **alte** Wert (vor dem XOR)\n\n**Beispiel:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xAA);  // 170 in binr: 10101010\n\nlet old = atomic_xor_i32(p, 0xFF);  // XOR mit 11111111\nprint(old);                    // 170 (alter Wert)\nprint(atomic_load_i32(p));     // 85 (0xAA ^ 0xFF = 0x55)\n\nfree(p);\n```\n\n---\n\n## Compare-and-Swap (CAS)\n\nDie mchtigste atomare Operation. Vergleicht atomar den aktuellen Wert mit einem erwarteten Wert und ersetzt ihn bei bereinstimmung durch einen neuen Wert.\n\n### atomic_cas_i32 / atomic_cas_i64\n\n**Signatur:**\n```hemlock\natomic_cas_i32(ptr: ptr, expected: i32, desired: i32): bool\natomic_cas_i64(ptr: ptr, expected: i64, desired: i64): bool\n```\n\n**Parameter:**\n- `ptr` - Pointer auf die Speicherstelle\n- `expected` - Wert, den wir erwarten vorzufinden\n- `desired` - Wert, der gespeichert wird, wenn die Erwartung bereinstimmt\n\n**Rckgabe:**\n- `true` - Tausch erfolgreich (Wert war `expected`, ist jetzt `desired`)\n- `false` - Tausch fehlgeschlagen (Wert war nicht `expected`, unverndert)\n\n**Beispiel:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\n// CAS erfolgreich: Wert ist 100, tausche zu 999\nlet success1 = atomic_cas_i32(p, 100, 999);\nprint(success1);               // true\nprint(atomic_load_i32(p));     // 999\n\n// CAS fehlgeschlagen: Wert ist 999, nicht 100\nlet success2 = atomic_cas_i32(p, 100, 888);\nprint(success2);               // false\nprint(atomic_load_i32(p));     // 999 (unverndert)\n\nfree(p);\n```\n\n**Anwendungsflle:**\n- Implementierung von Locks und Semaphoren\n- Lock-freie Datenstrukturen\n- Optimistische Nebenlufigkeitskontrolle\n- Atomare bedingte Aktualisierungen\n\n---\n\n## Atomarer Austausch\n\nAtomar einen Wert tauschen und den alten Wert zurckgeben.\n\n### atomic_exchange_i32 / atomic_exchange_i64\n\n**Signatur:**\n```hemlock\natomic_exchange_i32(ptr: ptr, value: i32): i32\natomic_exchange_i64(ptr: ptr, value: i64): i64\n```\n\n**Parameter:**\n- `ptr` - Pointer auf die Speicherstelle\n- `value` - Neuer zu speichernder Wert\n\n**Rckgabe:** Der **alte** Wert (vor dem Austausch)\n\n**Beispiel:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_exchange_i32(p, 200);\nprint(old);                    // 100 (alter Wert)\nprint(atomic_load_i32(p));     // 200 (neuer Wert)\n\nfree(p);\n```\n\n---\n\n## Speicherbarriere\n\nEine vollstndige Speicherbarriere, die sicherstellt, dass alle Speicheroperationen vor der Barriere fr alle Threads sichtbar sind, bevor irgendwelche Operationen nach der Barriere.\n\n### atomic_fence\n\n**Signatur:**\n```hemlock\natomic_fence(): null\n```\n\n**Rckgabe:** `null`\n\n**Beispiel:**\n```hemlock\n// Sicherstellen, dass alle vorherigen Schreiboperationen sichtbar sind\natomic_fence();\n```\n\n**Hinweis:** In den meisten Fllen bentigen Sie keine expliziten Barrieren, da alle atomaren Operationen bereits sequenzielle Konsistenz verwenden. Barrieren sind ntzlich, wenn Sie nicht-atomare Speicheroperationen synchronisieren mssen.\n\n---\n\n## Funktionsreferenz\n\n### i32-Operationen\n\n| Funktion | Signatur | Rckgabe | Beschreibung |\n|----------|----------|----------|--------------|\n| `atomic_load_i32` | `(ptr)` | `i32` | Wert atomar laden |\n| `atomic_store_i32` | `(ptr, value)` | `null` | Wert atomar speichern |\n| `atomic_add_i32` | `(ptr, value)` | `i32` | Addieren und alten Wert zurckgeben |\n| `atomic_sub_i32` | `(ptr, value)` | `i32` | Subtrahieren und alten Wert zurckgeben |\n| `atomic_and_i32` | `(ptr, value)` | `i32` | Bitweises UND und alten Wert zurckgeben |\n| `atomic_or_i32` | `(ptr, value)` | `i32` | Bitweises ODER und alten Wert zurckgeben |\n| `atomic_xor_i32` | `(ptr, value)` | `i32` | Bitweises XOR und alten Wert zurckgeben |\n| `atomic_cas_i32` | `(ptr, expected, desired)` | `bool` | Compare-and-Swap |\n| `atomic_exchange_i32` | `(ptr, value)` | `i32` | Austauschen und alten Wert zurckgeben |\n\n### i64-Operationen\n\n| Funktion | Signatur | Rckgabe | Beschreibung |\n|----------|----------|----------|--------------|\n| `atomic_load_i64` | `(ptr)` | `i64` | Wert atomar laden |\n| `atomic_store_i64` | `(ptr, value)` | `null` | Wert atomar speichern |\n| `atomic_add_i64` | `(ptr, value)` | `i64` | Addieren und alten Wert zurckgeben |\n| `atomic_sub_i64` | `(ptr, value)` | `i64` | Subtrahieren und alten Wert zurckgeben |\n| `atomic_and_i64` | `(ptr, value)` | `i64` | Bitweises UND und alten Wert zurckgeben |\n| `atomic_or_i64` | `(ptr, value)` | `i64` | Bitweises ODER und alten Wert zurckgeben |\n| `atomic_xor_i64` | `(ptr, value)` | `i64` | Bitweises XOR und alten Wert zurckgeben |\n| `atomic_cas_i64` | `(ptr, expected, desired)` | `bool` | Compare-and-Swap |\n| `atomic_exchange_i64` | `(ptr, value)` | `i64` | Austauschen und alten Wert zurckgeben |\n\n### Speicherbarriere\n\n| Funktion | Signatur | Rckgabe | Beschreibung |\n|----------|----------|----------|--------------|\n| `atomic_fence` | `()` | `null` | Vollstndige Speicherbarriere |\n\n---\n\n## Hufige Muster\n\n### Muster: Atomarer Zhler\n\n```hemlock\n// Thread-sicherer Zhler\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nfn increment(): i32 {\n    return atomic_add_i32(counter, 1);\n}\n\nfn decrement(): i32 {\n    return atomic_sub_i32(counter, 1);\n}\n\nfn get_count(): i32 {\n    return atomic_load_i32(counter);\n}\n\n// Verwendung\nincrement();  // Gibt 0 zurck (alter Wert)\nincrement();  // Gibt 1 zurck\nincrement();  // Gibt 2 zurck\nprint(get_count());  // 3\n\nfree(counter);\n```\n\n### Muster: Spinlock\n\n```hemlock\n// Einfache Spinlock-Implementierung\nlet lock = alloc(4);\nptr_write_i32(lock, 0);  // 0 = entsperrt, 1 = gesperrt\n\nfn acquire() {\n    // Drehen bis wir erfolgreich Lock von 0 auf 1 setzen\n    while (!atomic_cas_i32(lock, 0, 1)) {\n        // Busy-Wait\n    }\n}\n\nfn release() {\n    atomic_store_i32(lock, 0);\n}\n\n// Verwendung\nacquire();\n// ... kritischer Abschnitt ...\nrelease();\n\nfree(lock);\n```\n\n### Muster: Einmalige Initialisierung\n\n```hemlock\nlet initialized = alloc(4);\nptr_write_i32(initialized, 0);  // 0 = nicht initialisiert, 1 = initialisiert\n\nfn ensure_initialized() {\n    // Versuchen, derjenige zu sein, der initialisiert\n    if (atomic_cas_i32(initialized, 0, 1)) {\n        // Wir haben das Rennen gewonnen, fhre Initialisierung durch\n        do_expensive_init();\n    }\n    // Andernfalls bereits initialisiert\n}\n```\n\n### Muster: Atomares Flag\n\n```hemlock\nlet flag = alloc(4);\nptr_write_i32(flag, 0);\n\nfn set_flag() {\n    atomic_store_i32(flag, 1);\n}\n\nfn clear_flag() {\n    atomic_store_i32(flag, 0);\n}\n\nfn test_and_set(): bool {\n    // Gibt true zurck, wenn Flag bereits gesetzt war\n    return atomic_exchange_i32(flag, 1) == 1;\n}\n\nfn check_flag(): bool {\n    return atomic_load_i32(flag) == 1;\n}\n```\n\n### Muster: Begrenzter Zhler\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\nlet max_value = 100;\n\nfn try_increment(): bool {\n    while (true) {\n        let current = atomic_load_i32(counter);\n        if (current >= max_value) {\n            return false;  // Am Maximum\n        }\n        if (atomic_cas_i32(counter, current, current + 1)) {\n            return true;  // Erfolgreich inkrementiert\n        }\n        // CAS fehlgeschlagen, ein anderer Thread hat modifiziert - erneut versuchen\n    }\n}\n```\n\n---\n\n## Best Practices\n\n### 1. Korrekte Ausrichtung verwenden\n\nPointer mssen fr den Datentyp korrekt ausgerichtet sein:\n- i32: 4-Byte-Ausrichtung\n- i64: 8-Byte-Ausrichtung\n\nSpeicher von `alloc()` ist typischerweise korrekt ausgerichtet.\n\n### 2. Abstraktionen hherer Ebene bevorzugen\n\nWenn mglich, verwenden Sie Channels fr Inter-Task-Kommunikation. Atomics sind auf niedrigerer Ebene und erfordern sorgfltiges Nachdenken.\n\n```hemlock\n// Bevorzugen Sie dies:\nlet ch = channel(10);\nspawn(fn() { ch.send(result); });\nlet value = ch.recv();\n\n// Gegenber manueller atomarer Koordination, wenn angemessen\n```\n\n### 3. ABA-Problem beachten\n\nCAS kann unter dem ABA-Problem leiden: ein Wert ndert sich von A zu B und zurck zu A. Ihr CAS ist erfolgreich, aber der Zustand knnte sich dazwischen gendert haben.\n\n### 4. Vor dem Teilen initialisieren\n\nInitialisieren Sie atomare Variablen immer, bevor Sie Tasks spawnen, die auf sie zugreifen:\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);  // Initialisieren VOR dem Spawnen\n\nlet task = spawn(worker, counter);\n```\n\n### 5. Nach Abschluss aller Tasks freigeben\n\nGeben Sie atomaren Speicher nicht frei, whrend Tasks mglicherweise noch darauf zugreifen:\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nlet t1 = spawn(worker, counter);\nlet t2 = spawn(worker, counter);\n\njoin(t1);\njoin(t2);\n\n// Jetzt sicher zum Freigeben\nfree(counter);\n```\n\n---\n\n## Einschrnkungen\n\n### Aktuelle Einschrnkungen\n\n1. **Nur i32 und i64 untersttzt** - Keine atomaren Operationen fr andere Typen\n2. **Keine Pointer-Atomics** - Knnen Pointer nicht atomar laden/speichern\n3. **Nur sequenzielle Konsistenz** - Keine schwcheren Speicherordnungen verfgbar\n4. **Keine atomaren Fliekommazahlen** - Verwenden Sie bei Bedarf Integer-Darstellung\n\n### Plattformhinweise\n\n- Atomare Operationen verwenden unter der Haube C11 `<stdatomic.h>`\n- Verfgbar auf allen Plattformen, die POSIX-Threads untersttzen\n- Garantiert lock-frei auf modernen 64-Bit-Systemen\n\n---\n\n## Siehe auch\n\n- [Async/Nebenlufigkeit](#advanced-async-concurrency) - Task-Spawning und Channels\n- [Speicherverwaltung](#language-guide-memory) - Pointer- und Buffer-Allokation\n- [Speicher-API](#reference-memory-api) - Allokationsfunktionen\n"}, "Fortgeschrittene Themen -> Befehlsausfhrung": {"id": "advanced-command-execution", "content": "# Befehlsausfhrung in Hemlock\n\nHemlock bietet die **eingebaute Funktion `exec()`**, um Shell-Befehle auszufhren und ihre Ausgabe zu erfassen.\n\n## Inhaltsverzeichnis\n\n- [berblick](#berblick)\n- [Die exec()-Funktion](#die-exec-funktion)\n- [Ergebnisobjekt](#ergebnisobjekt)\n- [Grundlegende Verwendung](#grundlegende-verwendung)\n- [Fortgeschrittene Beispiele](#fortgeschrittene-beispiele)\n- [Fehlerbehandlung](#fehlerbehandlung)\n- [Implementierungsdetails](#implementierungsdetails)\n- [Sicherheitsberlegungen](#sicherheitsberlegungen)\n- [Einschrnkungen](#einschrnkungen)\n- [Anwendungsflle](#anwendungsflle)\n- [Best Practices](#best-practices)\n- [Vollstndige Beispiele](#vollstndige-beispiele)\n\n## berblick\n\nDie `exec()`-Funktion ermglicht Hemlock-Programmen:\n- Shell-Befehle auszufhren\n- Standardausgabe (stdout) zu erfassen\n- Exit-Statuscodes zu prfen\n- Shell-Funktionen zu nutzen (Pipes, Umleitungen, etc.)\n- Mit System-Dienstprogrammen zu integrieren\n\n**Wichtig:** Befehle werden ber `/bin/sh` ausgefhrt, was volle Shell-Funktionalitt bietet, aber auch Sicherheitsberlegungen mit sich bringt.\n\n## Die exec()-Funktion\n\n### Signatur\n\n```hemlock\nexec(command: string): object\n```\n\n**Parameter:**\n- `command` (string) - Auszufhrender Shell-Befehl\n\n**Rckgabe:** Ein Objekt mit zwei Feldern:\n- `output` (string) - Die stdout-Ausgabe des Befehls\n- `exit_code` (i32) - Der Exit-Statuscode des Befehls\n\n### Einfaches Beispiel\n\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n```\n\n## Ergebnisobjekt\n\nDas von `exec()` zurckgegebene Objekt hat folgende Struktur:\n\n```hemlock\n{\n    output: string,      // Befehl stdout (erfasste Ausgabe)\n    exit_code: i32       // Prozess-Exit-Status (0 = Erfolg)\n}\n```\n\n### output-Feld\n\nEnthlt den gesamten Text, der vom Befehl auf stdout geschrieben wurde.\n\n**Eigenschaften:**\n- Leerer String, wenn Befehl keine Ausgabe erzeugt\n- Enthlt Zeilenumbrche und Leerzeichen wie vorhanden\n- Mehrzeilige Ausgabe bleibt erhalten\n- Nicht grenbeschrnkt (dynamisch alloziert)\n\n**Beispiele:**\n```hemlock\nlet r1 = exec(\"echo test\");\nprint(r1.output);  // \"test\\n\"\n\nlet r2 = exec(\"ls\");\nprint(r2.output);  // Verzeichnisliste mit Zeilenumbrchen\n\nlet r3 = exec(\"true\");\nprint(r3.output);  // \"\" (leerer String)\n```\n\n### exit_code-Feld\n\nDer Exit-Statuscode des Befehls.\n\n**Werte:**\n- `0` zeigt typischerweise Erfolg an\n- `1-255` zeigen Fehler an (Konvention variiert nach Befehl)\n- `-1` wenn Befehl nicht ausgefhrt werden konnte oder abnormal beendet wurde\n\n**Beispiele:**\n```hemlock\nlet r1 = exec(\"true\");\nprint(r1.exit_code);  // 0 (Erfolg)\n\nlet r2 = exec(\"false\");\nprint(r2.exit_code);  // 1 (Fehler)\n\nlet r3 = exec(\"ls /nonexistent\");\nprint(r3.exit_code);  // 2 (Datei nicht gefunden, variiert nach Befehl)\n```\n\n## Grundlegende Verwendung\n\n### Einfacher Befehl\n\n```hemlock\nlet r = exec(\"ls -la\");\nprint(r.output);\nprint(\"Exit-Code: \" + typeof(r.exit_code));\n```\n\n### Exit-Status prfen\n\n```hemlock\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Gefunden: \" + r.output);\n} else {\n    print(\"Muster nicht gefunden\");\n}\n```\n\n### Befehle mit Pipes\n\n```hemlock\nlet r = exec(\"ps aux | grep hemlock\");\nprint(r.output);\n```\n\n### Mehrere Befehle\n\n```hemlock\nlet r = exec(\"cd /tmp && ls -la\");\nprint(r.output);\n```\n\n### Befehlsersetzung\n\n```hemlock\nlet r = exec(\"echo $(date)\");\nprint(r.output);  // Aktuelles Datum\n```\n\n## Fortgeschrittene Beispiele\n\n### Fehler behandeln\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\nif (r.exit_code != 0) {\n    print(\"Befehl fehlgeschlagen mit Code: \" + typeof(r.exit_code));\n    print(\"Fehlerausgabe: \" + r.output);  // Hinweis: stderr wird nicht erfasst\n}\n```\n\n### Mehrzeilige Ausgabe verarbeiten\n\n```hemlock\nlet r = exec(\"cat file.txt\");\nlet lines = r.output.split(\"\\n\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Zeile \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### Befehlsverkettung\n\n**Mit && (UND):**\n```hemlock\nlet r1 = exec(\"mkdir -p /tmp/test && touch /tmp/test/file.txt\");\nif (r1.exit_code == 0) {\n    print(\"Setup abgeschlossen\");\n}\n```\n\n**Mit || (ODER):**\n```hemlock\nlet r = exec(\"command1 || command2\");\n// Fhrt command2 nur aus, wenn command1 fehlschlgt\n```\n\n**Mit ; (Sequenz):**\n```hemlock\nlet r = exec(\"command1; command2\");\n// Fhrt beide aus, unabhngig von Erfolg/Fehler\n```\n\n### Pipes verwenden\n\n```hemlock\nlet r = exec(\"echo 'data' | base64\");\nprint(\"Base64: \" + r.output);\n```\n\n**Komplexe Pipelines:**\n```hemlock\nlet r = exec(\"cat /etc/passwd | grep root | cut -d: -f1\");\nprint(r.output);\n```\n\n### Exit-Code-Muster\n\nVerschiedene Exit-Codes zeigen verschiedene Bedingungen an:\n\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"Datei existiert\");\n} else if (r.exit_code == 1) {\n    print(\"Datei existiert nicht\");\n} else {\n    print(\"Test-Befehl fehlgeschlagen: \" + typeof(r.exit_code));\n}\n```\n\n### Ausgabe-Umleitungen\n\n```hemlock\n// stdout in Datei umleiten (innerhalb der Shell)\nlet r1 = exec(\"echo 'test' > /tmp/output.txt\");\n\n// stderr zu stdout umleiten (Hinweis: stderr wird von Hemlock immer noch nicht erfasst)\nlet r2 = exec(\"command 2>&1\");\n```\n\n### Umgebungsvariablen\n\n```hemlock\nlet r = exec(\"export VAR=value && echo $VAR\");\nprint(r.output);  // \"value\\n\"\n```\n\n### Arbeitsverzeichnis-nderungen\n\n```hemlock\nlet r = exec(\"cd /tmp && pwd\");\nprint(r.output);  // \"/tmp\\n\"\n```\n\n## Fehlerbehandlung\n\n### Wann exec() Ausnahmen wirft\n\nDie `exec()`-Funktion wirft eine Ausnahme, wenn der Befehl nicht ausgefhrt werden kann:\n\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command_xyz\");\n} catch (e) {\n    print(\"Ausfhrung fehlgeschlagen: \" + e);\n}\n```\n\n**Ausnahmen werden geworfen wenn:**\n- `popen()` fehlschlgt (z.B. Pipe kann nicht erstellt werden)\n- Systemressourcengrenzen berschritten werden\n- Speicherallokationsfehler auftreten\n\n### Wann exec() NICHT wirft\n\n```hemlock\n// Befehl luft, gibt aber Nicht-Null-Exit-Code zurck\nlet r1 = exec(\"false\");\nprint(r1.exit_code);  // 1 (keine Ausnahme)\n\n// Befehl erzeugt keine Ausgabe\nlet r2 = exec(\"true\");\nprint(r2.output);  // \"\" (keine Ausnahme)\n\n// Befehl von Shell nicht gefunden\nlet r3 = exec(\"nonexistent_cmd\");\nprint(r3.exit_code);  // 127 (keine Ausnahme)\n```\n\n### Sicheres Ausfhrungsmuster\n\n```hemlock\nfn safe_exec(command: string) {\n    try {\n        let r = exec(command);\n        if (r.exit_code != 0) {\n            print(\"Warnung: Befehl fehlgeschlagen mit Code \" + typeof(r.exit_code));\n            return \"\";\n        }\n        return r.output;\n    } catch (e) {\n        print(\"Fehler beim Ausfhren des Befehls: \" + e);\n        return \"\";\n    }\n}\n\nlet output = safe_exec(\"ls -la\");\n```\n\n## Implementierungsdetails\n\n### Wie es funktioniert\n\n**Unter der Haube:**\n- Verwendet `popen()`, um Befehle ber `/bin/sh` auszufhren\n- Erfasst nur stdout (stderr wird nicht erfasst)\n- Ausgabe wird dynamisch gepuffert (beginnt bei 4KB, wchst bei Bedarf)\n- Exit-Status wird mit `WIFEXITED()` und `WEXITSTATUS()` Makros extrahiert\n- Ausgabe-String wird korrekt null-terminiert\n\n**Prozessablauf:**\n1. `popen(command, \"r\")` erstellt Pipe und forkt Prozess\n2. Kindprozess fhrt `/bin/sh -c \"command\"` aus\n3. Elternprozess liest stdout ber Pipe in wachsenden Puffer\n4. `pclose()` wartet auf Kind und gibt Exit-Status zurck\n5. Exit-Status wird extrahiert und im Ergebnisobjekt gespeichert\n\n### Leistungsberlegungen\n\n**Kosten:**\n- Erstellt einen neuen Shell-Prozess fr jeden Aufruf (~1-5ms Overhead)\n- Ausgabe wird vollstndig im Speicher gehalten (nicht gestreamt)\n- Keine Streaming-Untersttzung (wartet auf Befehlsabschluss)\n- Geeignet fr Befehle mit vernnftigen Ausgabegren\n\n**Optimierungen:**\n- Puffer beginnt bei 4KB und verdoppelt sich bei Fllung (effiziente Speichernutzung)\n- Einzelne Leseschleife minimiert Systemaufrufe\n- Kein zustzliches String-Kopieren\n\n**Wann zu verwenden:**\n- Kurz laufende Befehle (< 1 Sekunde)\n- Moderate Ausgabegre (< 10MB)\n- Batch-Operationen mit vernnftigen Intervallen\n\n**Wann NICHT zu verwenden:**\n- Lang laufende Daemons oder Dienste\n- Befehle, die Gigabytes an Ausgabe erzeugen\n- Echtzeit-Streaming-Datenverarbeitung\n- Hochfrequente Ausfhrung (> 100 Aufrufe/Sekunde)\n\n## Sicherheitsberlegungen\n\n### Shell-Injection-Risiko\n\n **KRITISCH:** Befehle werden von der Shell (`/bin/sh`) ausgefhrt, was bedeutet, dass **Shell-Injection mglich** ist.\n\n**Verwundbarer Code:**\n```hemlock\n// GEFHRLICH - TUN SIE DAS NICHT\nlet filename = args[1];  // Benutzereingabe\nlet r = exec(\"cat \" + filename);  // Shell-Injection!\n```\n\n**Angriff:**\n```bash\n./hemlock script.hml \"; rm -rf /; echo pwned\"\n# Fhrt aus: cat ; rm -rf /; echo pwned\n```\n\n### Sichere Praktiken\n\n**1. Niemals unsanitisierte Benutzereingaben verwenden:**\n```hemlock\n// Schlecht\nlet user_input = args[1];\nlet r = exec(\"process \" + user_input);  // GEFHRLICH\n\n// Gut - zuerst validieren\nfn is_safe_filename(name: string): bool {\n    // Nur alphanumerische Zeichen, Bindestrich, Unterstrich, Punkt erlauben\n    let i = 0;\n    while (i < name.length) {\n        let c = name[i];\n        if (!(c >= 'a' && c <= 'z') &&\n            !(c >= 'A' && c <= 'Z') &&\n            !(c >= '0' && c <= '9') &&\n            c != '-' && c != '_' && c != '.') {\n            return false;\n        }\n        i = i + 1;\n    }\n    return true;\n}\n\nlet filename = args[1];\nif (is_safe_filename(filename)) {\n    let r = exec(\"cat \" + filename);\n} else {\n    print(\"Ungltiger Dateiname\");\n}\n```\n\n**2. Allowlists verwenden, nicht Denylists:**\n```hemlock\n// Gut - strikte Allowlist\nlet allowed_commands = [\"status\", \"start\", \"stop\", \"restart\"];\nlet cmd = args[1];\n\nlet found = false;\nfor (let allowed in allowed_commands) {\n    if (cmd == allowed) {\n        found = true;\n        break;\n    }\n}\n\nif (found) {\n    exec(\"service myapp \" + cmd);\n} else {\n    print(\"Ungltiger Befehl\");\n}\n```\n\n**3. Sonderzeichen escapen:**\n```hemlock\nfn shell_escape(s: string): string {\n    // Einfaches Escapen - in einfache Anfhrungszeichen setzen und einfache Anfhrungszeichen escapen\n    let escaped = s.replace_all(\"'\", \"'\\\\''\");\n    return \"'\" + escaped + \"'\";\n}\n\nlet user_file = args[1];\nlet safe = shell_escape(user_file);\nlet r = exec(\"cat \" + safe);\n```\n\n**4. exec() fr Dateioperationen vermeiden:**\n```hemlock\n// Schlecht - exec fr Dateioperationen verwenden\nlet r = exec(\"cat file.txt\");\n\n// Gut - Hemlocks Datei-API verwenden\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### Berechtigungsberlegungen\n\nBefehle laufen mit den gleichen Berechtigungen wie der Hemlock-Prozess:\n\n```hemlock\n// Wenn Hemlock als root luft, laufen exec()-Befehle auch als root!\nlet r = exec(\"rm -rf /important\");  // GEFHRLICH wenn als root\n```\n\n**Best Practice:** Hemlock mit den geringstmglichen Rechten ausfhren.\n\n## Einschrnkungen\n\n### 1. Keine stderr-Erfassung\n\nNur stdout wird erfasst, stderr geht zum Terminal:\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\n// r.output ist leer\n// Fehlermeldung erscheint im Terminal, wird nicht erfasst\n```\n\n**Workaround - stderr zu stdout umleiten:**\n```hemlock\nlet r = exec(\"ls /nonexistent 2>&1\");\n// Jetzt sind Fehlermeldungen in r.output\n```\n\n### 2. Kein Streaming\n\nMuss auf Befehlsabschluss warten:\n\n```hemlock\nlet r = exec(\"long_running_command\");\n// Blockiert bis Befehl fertig\n// Kann Ausgabe nicht inkrementell verarbeiten\n```\n\n### 3. Kein Timeout\n\nBefehle knnen unbegrenzt laufen:\n\n```hemlock\nlet r = exec(\"sleep 1000\");\n// Blockiert fr 1000 Sekunden\n// Keine Mglichkeit fr Timeout oder Abbruch\n```\n\n**Workaround - timeout-Befehl verwenden:**\n```hemlock\nlet r = exec(\"timeout 5 long_command\");\n// Timeout nach 5 Sekunden\n```\n\n### 4. Keine Signalbehandlung\n\nKann keine Signale an laufende Befehle senden:\n\n```hemlock\nlet r = exec(\"long_command\");\n// Kann SIGINT, SIGTERM, etc. nicht an den Befehl senden\n```\n\n### 5. Keine Prozesssteuerung\n\nKann nicht mit Befehl nach dem Start interagieren:\n\n```hemlock\nlet r = exec(\"interactive_program\");\n// Kann keine Eingabe an das Programm senden\n// Kann Ausfhrung nicht steuern\n```\n\n## Anwendungsflle\n\n### Gute Anwendungsflle\n\n**1. System-Dienstprogramme ausfhren:**\n```hemlock\nlet r = exec(\"ls -la\");\nlet r = exec(\"grep pattern file.txt\");\nlet r = exec(\"find /path -name '*.txt'\");\n```\n\n**2. Schnelle Datenverarbeitung mit Unix-Tools:**\n```hemlock\nlet r = exec(\"cat data.txt | sort | uniq | wc -l\");\nprint(\"Eindeutige Zeilen: \" + r.output);\n```\n\n**3. Systemstatus prfen:**\n```hemlock\nlet r = exec(\"df -h\");\nprint(\"Festplattennutzung:\\n\" + r.output);\n```\n\n**4. Dateiexistenz-Prfungen:**\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"Datei existiert\");\n}\n```\n\n**5. Berichte generieren:**\n```hemlock\nlet r = exec(\"ps aux | grep myapp | wc -l\");\nlet count = r.output.trim();\nprint(\"Laufende Instanzen: \" + count);\n```\n\n**6. Automatisierungsskripte:**\n```hemlock\nexec(\"git add .\");\nexec(\"git commit -m 'Auto commit'\");\nlet r = exec(\"git push\");\nif (r.exit_code != 0) {\n    print(\"Push fehlgeschlagen\");\n}\n```\n\n### Nicht empfohlen fr\n\n**1. Lang laufende Dienste:**\n```hemlock\n// Schlecht\nlet r = exec(\"nginx\");  // Blockiert fr immer\n```\n\n**2. Interaktive Befehle:**\n```hemlock\n// Schlecht - kann keine Eingabe bereitstellen\nlet r = exec(\"ssh user@host\");\n```\n\n**3. Befehle mit riesiger Ausgabe:**\n```hemlock\n// Schlecht - ldt gesamte Ausgabe in Speicher\nlet r = exec(\"cat 10GB_file.log\");\n```\n\n**4. Echtzeit-Streaming:**\n```hemlock\n// Schlecht - kann Ausgabe nicht inkrementell verarbeiten\nlet r = exec(\"tail -f /var/log/app.log\");\n```\n\n**5. Missionskritische Fehlerbehandlung:**\n```hemlock\n// Schlecht - stderr wird nicht erfasst\nlet r = exec(\"critical_operation\");\n// Kann detaillierte Fehlermeldungen nicht sehen\n```\n\n## Best Practices\n\n### 1. Immer Exit-Codes prfen\n\n```hemlock\nlet r = exec(\"important_command\");\nif (r.exit_code != 0) {\n    print(\"Befehl fehlgeschlagen!\");\n    // Fehler behandeln\n}\n```\n\n### 2. Ausgabe bei Bedarf trimmen\n\n```hemlock\nlet r = exec(\"echo test\");\nlet clean = r.output.trim();  // Abschlieenden Zeilenumbruch entfernen\nprint(clean);  // \"test\" (kein Zeilenumbruch)\n```\n\n### 3. Vor dem Ausfhren validieren\n\n```hemlock\nfn is_valid_command(cmd: string): bool {\n    // Validieren, dass Befehl sicher ist\n    return true;  // Ihre Validierungslogik\n}\n\nif (is_valid_command(user_cmd)) {\n    exec(user_cmd);\n}\n```\n\n### 4. try/catch fr kritische Operationen verwenden\n\n```hemlock\ntry {\n    let r = exec(\"critical_command\");\n    if (r.exit_code != 0) {\n        throw \"Befehl fehlgeschlagen\";\n    }\n} catch (e) {\n    print(\"Fehler: \" + e);\n    // Bereinigung oder Wiederherstellung\n}\n```\n\n### 5. Hemlock-APIs gegenber exec() bevorzugen\n\n```hemlock\n// Schlecht - exec fr Dateioperationen verwenden\nlet r = exec(\"cat file.txt\");\n\n// Gut - Hemlocks Datei-API verwenden\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### 6. stderr bei Bedarf erfassen\n\n```hemlock\n// stderr zu stdout umleiten\nlet r = exec(\"command 2>&1\");\n// Jetzt enthlt r.output sowohl stdout als auch stderr\n```\n\n### 7. Shell-Funktionen weise nutzen\n\n```hemlock\n// Pipes fr Effizienz verwenden\nlet r = exec(\"cat large.txt | grep pattern | head -n 10\");\n\n// Befehlsersetzung verwenden\nlet r = exec(\"echo Aktueller Benutzer: $(whoami)\");\n\n// Bedingte Ausfhrung verwenden\nlet r = exec(\"test -f file.txt && cat file.txt\");\n```\n\n## Vollstndige Beispiele\n\n### Beispiel 1: Systeminformationen sammeln\n\n```hemlock\nfn get_system_info() {\n    print(\"=== Systeminformationen ===\");\n\n    // Hostname\n    let r1 = exec(\"hostname\");\n    print(\"Hostname: \" + r1.output.trim());\n\n    // Betriebszeit\n    let r2 = exec(\"uptime\");\n    print(\"Betriebszeit: \" + r2.output.trim());\n\n    // Festplattennutzung\n    let r3 = exec(\"df -h /\");\n    print(\"\\nFestplattennutzung:\");\n    print(r3.output);\n\n    // Speichernutzung\n    let r4 = exec(\"free -h\");\n    print(\"Speichernutzung:\");\n    print(r4.output);\n}\n\nget_system_info();\n```\n\n### Beispiel 2: Log-Analysator\n\n```hemlock\nfn analyze_log(logfile: string) {\n    print(\"Analysiere Log: \" + logfile);\n\n    // Gesamtzeilen zhlen\n    let r1 = exec(\"wc -l \" + logfile);\n    print(\"Gesamtzeilen: \" + r1.output.trim());\n\n    // Fehler zhlen\n    let r2 = exec(\"grep -c ERROR \" + logfile + \" 2>/dev/null\");\n    let errors = r2.output.trim();\n    if (r2.exit_code == 0) {\n        print(\"Fehler: \" + errors);\n    } else {\n        print(\"Fehler: 0\");\n    }\n\n    // Warnungen zhlen\n    let r3 = exec(\"grep -c WARN \" + logfile + \" 2>/dev/null\");\n    let warnings = r3.output.trim();\n    if (r3.exit_code == 0) {\n        print(\"Warnungen: \" + warnings);\n    } else {\n        print(\"Warnungen: 0\");\n    }\n\n    // Letzte Fehler\n    print(\"\\nLetzte Fehler:\");\n    let r4 = exec(\"grep ERROR \" + logfile + \" | tail -n 5\");\n    print(r4.output);\n}\n\nif (args.length < 2) {\n    print(\"Verwendung: \" + args[0] + \" <logfile>\");\n} else {\n    analyze_log(args[1]);\n}\n```\n\n### Beispiel 3: Git-Helfer\n\n```hemlock\nfn git_status() {\n    let r = exec(\"git status --short\");\n    if (r.exit_code != 0) {\n        print(\"Fehler: Kein Git-Repository\");\n        return;\n    }\n\n    if (r.output == \"\") {\n        print(\"Arbeitsverzeichnis sauber\");\n    } else {\n        print(\"nderungen:\");\n        print(r.output);\n    }\n}\n\nfn git_quick_commit(message: string) {\n    print(\"Fge alle nderungen hinzu...\");\n    let r1 = exec(\"git add -A\");\n    if (r1.exit_code != 0) {\n        print(\"Fehler beim Hinzufgen von Dateien\");\n        return;\n    }\n\n    print(\"Committe...\");\n    let safe_msg = message.replace_all(\"'\", \"'\\\\''\");\n    let r2 = exec(\"git commit -m '\" + safe_msg + \"'\");\n    if (r2.exit_code != 0) {\n        print(\"Fehler beim Committen\");\n        return;\n    }\n\n    print(\"Erfolgreich committed\");\n    print(r2.output);\n}\n\n// Verwendung\ngit_status();\nif (args.length > 1) {\n    git_quick_commit(args[1]);\n}\n```\n\n### Beispiel 4: Backup-Skript\n\n```hemlock\nfn backup_directory(source: string, dest: string) {\n    print(\"Sichere \" + source + \" nach \" + dest);\n\n    // Backup-Verzeichnis erstellen\n    let r1 = exec(\"mkdir -p \" + dest);\n    if (r1.exit_code != 0) {\n        print(\"Fehler beim Erstellen des Backup-Verzeichnisses\");\n        return false;\n    }\n\n    // Tarball mit Zeitstempel erstellen\n    let r2 = exec(\"date +%Y%m%d_%H%M%S\");\n    let timestamp = r2.output.trim();\n    let backup_file = dest + \"/backup_\" + timestamp + \".tar.gz\";\n\n    print(\"Erstelle Archiv: \" + backup_file);\n    let r3 = exec(\"tar -czf \" + backup_file + \" \" + source + \" 2>&1\");\n    if (r3.exit_code != 0) {\n        print(\"Fehler beim Erstellen des Backups:\");\n        print(r3.output);\n        return false;\n    }\n\n    print(\"Backup erfolgreich abgeschlossen\");\n\n    // Backup-Gre anzeigen\n    let r4 = exec(\"du -h \" + backup_file);\n    print(\"Backup-Gre: \" + r4.output.trim());\n\n    return true;\n}\n\nif (args.length < 3) {\n    print(\"Verwendung: \" + args[0] + \" <source> <destination>\");\n} else {\n    backup_directory(args[1], args[2]);\n}\n```\n\n## Zusammenfassung\n\nHemlocks `exec()`-Funktion bietet:\n\n-  Einfache Shell-Befehlsausfhrung\n-  Ausgabeerfassung (stdout)\n-  Exit-Code-Prfung\n-  Voller Zugang zu Shell-Funktionen (Pipes, Umleitungen, etc.)\n-  Integration mit System-Dienstprogrammen\n\nDenken Sie daran:\n- Immer Exit-Codes prfen\n- Sich der Sicherheitsimplikationen bewusst sein (Shell-Injection)\n- Benutzereingaben vor der Verwendung in Befehlen validieren\n- Hemlock-APIs gegenber exec() bevorzugen, wenn verfgbar\n- stderr wird nicht erfasst (verwenden Sie `2>&1` zum Umleiten)\n- Befehle blockieren bis zur Fertigstellung\n- Fr kurz laufende Dienstprogramme verwenden, nicht fr lang laufende Dienste\n\n**Sicherheitscheckliste:**\n-  Niemals unsanitisierte Benutzereingaben verwenden\n-  Alle Eingaben validieren\n-  Allowlists fr Befehle verwenden\n-  Sonderzeichen bei Bedarf escapen\n-  Mit geringstmglichen Rechten ausfhren\n-  Hemlock-APIs gegenber Shell-Befehlen bevorzugen\n"}, "Fortgeschrittene Themen -> Bndeln & Paketieren": {"id": "advanced-bundling-packaging", "content": "# Bundling & Paketierung\n\nHemlock bietet eingebaute Werkzeuge, um Multi-Datei-Projekte in einzelne verteilbare Dateien zu bndeln und eigenstndige ausfhrbare Dateien zu erstellen.\n\n## berblick\n\n| Befehl | Ausgabe | Anwendungsfall |\n|--------|---------|----------------|\n| `--bundle` | `.hmlc` oder `.hmlb` | Bytecode verteilen (erfordert Hemlock zur Ausfhrung) |\n| `--package` | Ausfhrbare Datei | Eigenstndige Binrdatei (keine Abhngigkeiten) |\n| `--compile` | `.hmlc` | Einzelne Datei kompilieren (keine Import-Auflsung) |\n\n## Bundling\n\nDer Bundler lst alle `import`-Anweisungen von einem Einstiegspunkt auf und flacht sie in eine einzelne Datei ab.\n\n### Grundlegende Verwendung\n\n```bash\n# app.hml und alle Imports in app.hmlc bndeln\nhemlock --bundle app.hml\n\n# Ausgabepfad angeben\nhemlock --bundle app.hml -o dist/app.hmlc\n\n# Komprimiertes Bundle erstellen (.hmlb) - kleinere Dateigre\nhemlock --bundle app.hml --compress -o app.hmlb\n\n# Ausfhrliche Ausgabe (zeigt aufgelste Module)\nhemlock --bundle app.hml --verbose\n```\n\n### Ausgabeformate\n\n**`.hmlc` (Unkomprimiert)**\n- Serialisiertes AST-Format\n- Schnell zu laden und auszufhren\n- Standard-Ausgabeformat\n\n**`.hmlb` (Komprimiert)**\n- zlib-komprimiertes `.hmlc`\n- Kleinere Dateigre (typischerweise 50-70% Reduktion)\n- Etwas langsamerer Start durch Dekomprimierung\n\n### Gebndelte Dateien ausfhren\n\n```bash\n# Unkomprimiertes Bundle ausfhren\nhemlock app.hmlc\n\n# Komprimiertes Bundle ausfhren\nhemlock app.hmlb\n\n# Argumente bergeben\nhemlock app.hmlc arg1 arg2\n```\n\n### Beispiel: Multi-Modul-Projekt\n\n```\nmyapp/\n main.hml\n lib/\n    math.hml\n    utils.hml\n config.hml\n```\n\n```hemlock\n// main.hml\nimport { add, multiply } from \"./lib/math.hml\";\nimport { log } from \"./lib/utils.hml\";\nimport { VERSION } from \"./config.hml\";\n\nlog(`App v${VERSION}`);\nprint(add(2, 3));\n```\n\n```bash\nhemlock --bundle myapp/main.hml -o myapp.hmlc\nhemlock myapp.hmlc  # Luft mit allen gebndelten Abhngigkeiten\n```\n\n### stdlib-Imports\n\nDer Bundler lst automatisch `@stdlib/`-Imports auf:\n\n```hemlock\nimport { HashMap } from \"@stdlib/collections\";\nimport { now } from \"@stdlib/time\";\n```\n\nBeim Bndeln werden stdlib-Module in die Ausgabe einbezogen.\n\n## Paketierung\n\nPaketierung erstellt eine eigenstndige ausfhrbare Datei, indem der gebndelte Bytecode in eine Kopie des Hemlock-Interpreters eingebettet wird.\n\n### Grundlegende Verwendung\n\n```bash\n# Ausfhrbare Datei aus app.hml erstellen\nhemlock --package app.hml\n\n# Ausgabenamen angeben\nhemlock --package app.hml -o myapp\n\n# Komprimierung berspringen (schnellerer Start, grere Datei)\nhemlock --package app.hml --no-compress\n\n# Ausfhrliche Ausgabe\nhemlock --package app.hml --verbose\n```\n\n### Paketierte ausfhrbare Dateien ausfhren\n\n```bash\n# Die paketierte ausfhrbare Datei luft direkt\n./myapp\n\n# Argumente werden an das Skript bergeben\n./myapp arg1 arg2\n```\n\n### Paketformat\n\nPaketierte ausfhrbare Dateien verwenden das HMLP-Format:\n\n```\n[hemlock binary][HMLB/HMLC payload][payload_size:u64][HMLP magic:u32]\n```\n\nWenn eine paketierte ausfhrbare Datei luft:\n1. Sie prft auf ein eingebettetes Payload am Ende der Datei\n2. Falls gefunden, dekomprimiert und fhrt sie das Payload aus\n3. Falls nicht gefunden, verhlt sie sich wie ein normaler Hemlock-Interpreter\n\n### Komprimierungsoptionen\n\n| Flag | Format | Start | Gre |\n|------|--------|-------|-------|\n| (Standard) | HMLB | Normal | Kleiner |\n| `--no-compress` | HMLC | Schneller | Grer |\n\nFr CLI-Tools, bei denen Startzeit wichtig ist, verwenden Sie `--no-compress`.\n\n## Bundles inspizieren\n\nVerwenden Sie `--info`, um gebndelte oder kompilierte Dateien zu inspizieren:\n\n```bash\nhemlock --info app.hmlc\n```\n\nAusgabe:\n```\n=== Datei-Info: app.hmlc ===\nGre: 12847 Bytes\nFormat: HMLC (kompilierter AST)\nVersion: 1\nFlags: 0x0001 [DEBUG]\nStrings: 42\nAnweisungen: 156\n```\n\n```bash\nhemlock --info app.hmlb\n```\n\nAusgabe:\n```\n=== Datei-Info: app.hmlb ===\nGre: 5234 Bytes\nFormat: HMLB (komprimiertes Bundle)\nVersion: 1\nUnkomprimiert: 12847 Bytes\nKomprimiert: 5224 Bytes\nVerhltnis: 59,3% Reduktion\n```\n\n## Native Kompilierung\n\nFr echte native ausfhrbare Dateien (kein Interpreter) verwenden Sie den Hemlock-Compiler:\n\n```bash\n# Zu nativer ausfhrbarer Datei ber C kompilieren\nhemlockc app.hml -o app\n\n# Generierten C-Code behalten\nhemlockc app.hml -o app --keep-c\n\n# Nur C ausgeben (nicht kompilieren)\nhemlockc app.hml -c -o app.c\n\n# Optimierungsstufe\nhemlockc app.hml -o app -O2\n```\n\nDer Compiler generiert C-Code und ruft GCC auf, um eine native Binrdatei zu erzeugen. Dies erfordert:\n- Die Hemlock-Laufzeitbibliothek (`libhemlock_runtime`)\n- Einen C-Compiler (standardmig GCC)\n\n### Compiler-Optionen\n\n| Option | Beschreibung |\n|--------|--------------|\n| `-o <file>` | Name der ausfhrbaren Ausgabedatei |\n| `-c` | Nur C-Code ausgeben |\n| `--emit-c <file>` | C in angegebene Datei schreiben |\n| `-k, --keep-c` | Generierten C-Code nach Kompilierung behalten |\n| `-O<level>` | Optimierungsstufe (0-3) |\n| `--cc <path>` | Zu verwendender C-Compiler |\n| `--runtime <path>` | Pfad zur Laufzeitbibliothek |\n| `-v, --verbose` | Ausfhrliche Ausgabe |\n\n## Vergleich\n\n| Ansatz | Portabilitt | Start | Gre | Abhngigkeiten |\n|--------|--------------|-------|-------|----------------|\n| `.hml` | Nur Quellcode | Parse-Zeit | Kleinste | Hemlock |\n| `.hmlc` | Nur Hemlock | Schnell | Klein | Hemlock |\n| `.hmlb` | Nur Hemlock | Schnell | Kleiner | Hemlock |\n| `--package` | Eigenstndig | Schnell | Grer | Keine |\n| `hemlockc` | Nativ | Schnellste | Variiert | Laufzeit-Libs |\n\n## Best Practices\n\n1. **Entwicklung**: `.hml`-Dateien direkt ausfhren fr schnelle Iteration\n2. **Verteilung (mit Hemlock)**: Mit `--compress` fr kleinere Dateien bndeln\n3. **Verteilung (eigenstndig)**: Paketieren fr Deployment ohne Abhngigkeiten\n4. **Leistungskritisch**: `hemlockc` fr native Kompilierung verwenden\n\n## Fehlerbehebung\n\n### \"Cannot find stdlib\"\n\nDer Bundler sucht nach stdlib in:\n1. `./stdlib` (relativ zur ausfhrbaren Datei)\n2. `../stdlib` (relativ zur ausfhrbaren Datei)\n3. `/usr/local/lib/hemlock/stdlib`\n\nStellen Sie sicher, dass Hemlock ordnungsgem installiert ist oder fhren Sie es aus dem Quellverzeichnis aus.\n\n### Zirkulre Abhngigkeiten\n\n```\nFehler: Zirkulre Abhngigkeit beim Laden von 'path/to/module.hml' erkannt\n```\n\nRefaktorieren Sie Ihre Imports, um den Zyklus zu durchbrechen. Erwgen Sie die Verwendung eines gemeinsamen Moduls fr gemeinsame Typen.\n\n### Groe Paketgre\n\n- Verwenden Sie die Standardkomprimierung (verwenden Sie nicht `--no-compress`)\n- Die paketierte Gre beinhaltet den vollstndigen Interpreter (~500KB-1MB Basis)\n- Fr minimale Gre verwenden Sie `hemlockc` fr native Kompilierung\n"}, "Fortgeschrittene Themen -> FFI": {"id": "advanced-ffi", "content": "# Foreign Function Interface (FFI) in Hemlock\n\nHemlock bietet **FFI (Foreign Function Interface)**, um C-Funktionen aus Shared Libraries unter Verwendung von libffi aufzurufen, was die Integration mit bestehenden C-Bibliotheken und System-APIs ermglicht.\n\n## Inhaltsverzeichnis\n\n- [berblick](#berblick)\n- [Aktueller Status](#aktueller-status)\n- [Untersttzte Typen](#untersttzte-typen)\n- [Grundkonzepte](#grundkonzepte)\n- [FFI-Funktionen exportieren](#ffi-funktionen-exportieren)\n- [Anwendungsflle](#anwendungsflle)\n- [Zuknftige Entwicklung](#zuknftige-entwicklung)\n- [FFI-Callbacks](#ffi-callbacks)\n- [FFI-Structs](#ffi-structs)\n- [Struct-Typen exportieren](#struct-typen-exportieren)\n- [Aktuelle Einschrnkungen](#aktuelle-einschrnkungen)\n- [Best Practices](#best-practices)\n\n## berblick\n\nDas Foreign Function Interface (FFI) ermglicht Hemlock-Programmen:\n- C-Funktionen aus Shared Libraries (.so, .dylib, .dll) aufzurufen\n- Bestehende C-Bibliotheken ohne Wrapper-Code zu verwenden\n- Direkt auf System-APIs zuzugreifen\n- Mit nativen Bibliotheken von Drittanbietern zu integrieren\n- Hemlock mit Low-Level-Systemfunktionalitt zu verbinden\n\n**Hauptfhigkeiten:**\n- Dynamisches Laden von Bibliotheken\n- C-Funktionsbindung\n- Automatische Typkonvertierung zwischen Hemlock- und C-Typen\n- Untersttzung fr alle primitiven Typen\n- libffi-basierte Implementierung fr Portabilitt\n\n## Aktueller Status\n\nFFI-Untersttzung ist in Hemlock mit folgenden Funktionen verfgbar:\n\n**Implementiert:**\n-  C-Funktionen aus Shared Libraries aufrufen\n-  Untersttzung fr alle primitiven Typen (Integer, Floats, Pointer)\n-  Automatische Typkonvertierung\n-  libffi-basierte Implementierung\n-  Dynamisches Laden von Bibliotheken\n-  **Funktionspointer-Callbacks** - Hemlock-Funktionen an C bergeben\n-  **Extern-Funktionen exportieren** - FFI-Bindungen ber Module teilen\n-  **Struct-bergabe und Rckgabewerte** - C-kompatible Structs by Value bergeben\n-  **Vollstndige Pointer-Hilfsfunktionen** - Alle Typen lesen/schreiben (i8-i64, u8-u64, f32, f64, ptr)\n-  **Buffer/Pointer-Konvertierung** - `buffer_ptr()`, `ptr_to_buffer()`\n-  **FFI-Typgren** - `ffi_sizeof()` fr plattformbewusste Typgren\n-  **Plattformtypen** - `size_t`, `usize`, `isize`, `intptr_t`-Untersttzung\n\n**In Entwicklung:**\n-  String-Marshaling-Hilfsfunktionen\n-  Fehlerbehandlungsverbesserungen\n\n**Testabdeckung:**\n- FFI-Tests bestanden einschlielich Callback-Tests\n- Grundlegende Funktionsaufrufe verifiziert\n- Typkonvertierung getestet\n- qsort-Callback-Integration getestet\n\n## Untersttzte Typen\n\n### Primitive Typen\n\nDie folgenden Hemlock-Typen knnen an C-Funktionen bergeben/von ihnen empfangen werden:\n\n| Hemlock-Typ | C-Typ | Gre | Hinweise |\n|-------------|-------|-------|----------|\n| `i8` | `int8_t` | 1 Byte | Vorzeichenbehafteter 8-Bit-Integer |\n| `i16` | `int16_t` | 2 Bytes | Vorzeichenbehafteter 16-Bit-Integer |\n| `i32` | `int32_t` | 4 Bytes | Vorzeichenbehafteter 32-Bit-Integer |\n| `i64` | `int64_t` | 8 Bytes | Vorzeichenbehafteter 64-Bit-Integer |\n| `u8` | `uint8_t` | 1 Byte | Vorzeichenloser 8-Bit-Integer |\n| `u16` | `uint16_t` | 2 Bytes | Vorzeichenloser 16-Bit-Integer |\n| `u32` | `uint32_t` | 4 Bytes | Vorzeichenloser 32-Bit-Integer |\n| `u64` | `uint64_t` | 8 Bytes | Vorzeichenloser 64-Bit-Integer |\n| `f32` | `float` | 4 Bytes | 32-Bit-Fliekommazahl |\n| `f64` | `double` | 8 Bytes | 64-Bit-Fliekommazahl |\n| `ptr` | `void*` | 8 Bytes | Rohpointer |\n\n### Typkonvertierung\n\n**Automatische Konvertierungen:**\n- Hemlock-Integer  C-Integer (mit Bereichsprfung)\n- Hemlock-Floats  C-Floats\n- Hemlock-Pointer  C-Pointer\n- C-Rckgabewerte  Hemlock-Werte\n\n**Beispiel-Typzuordnungen:**\n```hemlock\n// Hemlock  C\nlet i: i32 = 42;         //  int32_t (4 Bytes)\nlet f: f64 = 3.14;       //  double (8 Bytes)\nlet p: ptr = alloc(64);  //  void* (8 Bytes)\n\n// C  Hemlock (Rckgabewerte)\n// int32_t foo()  i32\n// double bar()  f64\n// void* baz()  ptr\n```\n\n## Grundkonzepte\n\n### Shared Libraries\n\nFFI arbeitet mit kompilierten Shared Libraries:\n\n**Linux:** `.so`-Dateien\n```\nlibexample.so\n/usr/lib/libm.so\n```\n\n**macOS:** `.dylib`-Dateien\n```\nlibexample.dylib\n/usr/lib/libSystem.dylib\n```\n\n**Windows:** `.dll`-Dateien\n```\nexample.dll\nkernel32.dll\n```\n\n### Funktionssignaturen\n\nC-Funktionen mssen bekannte Signaturen haben, damit FFI korrekt funktioniert:\n\n```c\n// Beispiel-C-Funktionssignaturen\nint add(int a, int b);\ndouble sqrt(double x);\nvoid* malloc(size_t size);\nvoid free(void* ptr);\n```\n\nDiese knnen von Hemlock aufgerufen werden, sobald die Bibliothek geladen und Funktionen gebunden sind.\n\n### Plattformkompatibilitt\n\nFFI verwendet **libffi** fr Portabilitt:\n- Funktioniert auf x86, x86-64, ARM, ARM64\n- Behandelt Aufrufkonventionen automatisch\n- Abstrahiert plattformspezifische ABI-Details\n- Untersttzt Linux, macOS, Windows (mit entsprechendem libffi)\n\n## FFI-Funktionen exportieren\n\nFFI-Funktionen, die mit `extern fn` deklariert sind, knnen aus Modulen exportiert werden, sodass Sie wiederverwendbare Bibliotheks-Wrapper erstellen knnen, die ber mehrere Dateien geteilt werden.\n\n### Grundlegende Export-Syntax\n\n```hemlock\n// string_utils.hml - Ein Bibliotheksmodul, das C-String-Funktionen umhllt\nimport \"libc.so.6\";\n\n// Die extern-Funktion direkt exportieren\nexport extern fn strlen(s: string): i32;\nexport extern fn strcmp(s1: string, s2: string): i32;\n\n// Sie knnen auch Wrapper-Funktionen neben extern-Funktionen exportieren\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n\nexport fn strings_equal(a: string, b: string): bool {\n    return strcmp(a, b) == 0;\n}\n```\n\n### Exportierte FFI-Funktionen importieren\n\n```hemlock\n// main.hml - Die exportierten FFI-Funktionen verwenden\nimport { strlen, string_length, strings_equal } from \"./string_utils.hml\";\n\nlet msg = \"Hallo, Welt!\";\nprint(strlen(msg));           // 12 - direkter extern-Aufruf\nprint(string_length(msg));    // 12 - Wrapper-Funktion\n\nprint(strings_equal(\"foo\", \"foo\"));  // true\nprint(strings_equal(\"foo\", \"bar\"));  // false\n```\n\n### Anwendungsflle fr Export Extern\n\n**1. Plattformabstraktion**\n```hemlock\n// platform.hml - Plattformunterschiede abstrahieren\nimport \"libc.so.6\";  // Linux\n\nexport extern fn getpid(): i32;\nexport extern fn getuid(): i32;\nexport extern fn geteuid(): i32;\n```\n\n**2. Bibliotheks-Wrapper**\n```hemlock\n// crypto_lib.hml - Kryptobibliotheks-Funktionen umhllen\nimport \"libcrypto.so\";\n\nexport extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;\nexport extern fn MD5(data: ptr, len: u64, out: ptr): ptr;\n\n// Hemlock-freundliche Wrapper hinzufgen\nexport fn sha256_string(s: string): string {\n    // Implementierung mit der extern-Funktion\n}\n```\n\n**3. Zentrale FFI-Deklarationen**\n```hemlock\n// libc.hml - Zentrales Modul fr libc-Bindungen\nimport \"libc.so.6\";\n\n// String-Funktionen\nexport extern fn strlen(s: string): i32;\nexport extern fn strcpy(dest: ptr, src: string): ptr;\nexport extern fn strcat(dest: ptr, src: string): ptr;\n\n// Speicherfunktionen\nexport extern fn malloc(size: u64): ptr;\nexport extern fn realloc(p: ptr, size: u64): ptr;\nexport extern fn calloc(nmemb: u64, size: u64): ptr;\n\n// Prozessfunktionen\nexport extern fn getpid(): i32;\nexport extern fn getppid(): i32;\nexport extern fn getenv(name: string): ptr;\n```\n\nDann im gesamten Projekt verwenden:\n```hemlock\nimport { strlen, malloc, getpid } from \"./libc.hml\";\n```\n\n### Mit regulren Exports kombinieren\n\nSie knnen exportierte extern-Funktionen mit regulren Funktionsexporten mischen:\n\n```hemlock\n// math_extended.hml\nimport \"libm.so.6\";\n\n// Rohe C-Funktionen exportieren\nexport extern fn sin(x: f64): f64;\nexport extern fn cos(x: f64): f64;\nexport extern fn tan(x: f64): f64;\n\n// Hemlock-Funktionen exportieren, die sie verwenden\nexport fn deg_to_rad(degrees: f64): f64 {\n    return degrees * 3.14159265359 / 180.0;\n}\n\nexport fn sin_degrees(degrees: f64): f64 {\n    return sin(deg_to_rad(degrees));\n}\n```\n\n### Plattformspezifische Bibliotheken\n\nBeim Exportieren von extern-Funktionen beachten, dass Bibliotheksnamen je nach Plattform unterschiedlich sind:\n\n```hemlock\n// Fr Linux\nimport \"libc.so.6\";\n\n// Fr macOS (anderer Ansatz erforderlich)\nimport \"libSystem.B.dylib\";\n```\n\nDerzeit verwendet Hemlocks `import \"library\"`-Syntax statische Bibliothekspfade, daher knnen plattformspezifische Module fr plattformbergreifenden FFI-Code erforderlich sein.\n\n## Anwendungsflle\n\n### 1. Systembibliotheken\n\nZugriff auf Standard-C-Bibliotheksfunktionen:\n\n**Mathematikfunktionen:**\n```hemlock\n// sqrt aus libm aufrufen\nlet result = sqrt(16.0);  // 4.0\n```\n\n**Speicherallokation:**\n```hemlock\n// malloc/free aus libc aufrufen\nlet ptr = malloc(1024);\nfree(ptr);\n```\n\n### 2. Drittanbieter-Bibliotheken\n\nBestehende C-Bibliotheken verwenden:\n\n**Beispiel: Bildverarbeitung**\n```hemlock\n// libpng oder libjpeg laden\n// Bilder mit C-Bibliotheksfunktionen verarbeiten\n```\n\n**Beispiel: Kryptografie**\n```hemlock\n// OpenSSL oder libsodium verwenden\n// Verschlsselung/Entschlsselung ber FFI\n```\n\n### 3. System-APIs\n\nDirekte Systemaufrufe:\n\n**Beispiel: POSIX-APIs**\n```hemlock\n// getpid, getuid, etc. aufrufen\n// Auf Low-Level-Systemfunktionalitt zugreifen\n```\n\n### 4. Leistungskritischer Code\n\nOptimierte C-Implementierungen aufrufen:\n\n```hemlock\n// Hochoptimierte C-Bibliotheken verwenden\n// SIMD-Operationen, vektorisierter Code\n// Hardware-beschleunigte Funktionen\n```\n\n### 5. Hardware-Zugriff\n\nSchnittstelle zu Hardware-Bibliotheken:\n\n```hemlock\n// GPIO-Steuerung auf eingebetteten Systemen\n// USB-Gertekommunikation\n// Serieller Port-Zugriff\n```\n\n### 6. Integration von Legacy-Code\n\nBestehende C-Codebasen wiederverwenden:\n\n```hemlock\n// Funktionen aus Legacy-C-Anwendungen aufrufen\n// Schrittweise zu Hemlock migrieren\n// Funktionierenden C-Code bewahren\n```\n\n## Zuknftige Entwicklung\n\n### Geplante Funktionen\n\n**1. Struct-Untersttzung**\n```hemlock\n// Zukunft: C-Structs bergeben/zurckgeben\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\nlet p = Point { x: 1.0, y: 2.0 };\nc_function_with_struct(p);\n```\n\n**2. Array/Buffer-Behandlung**\n```hemlock\n// Zukunft: Bessere Array-bergabe\nlet arr = [1, 2, 3, 4, 5];\nprocess_array(arr);  // An C-Funktion bergeben\n```\n\n**3. Funktionspointer-Callbacks**  (Implementiert!)\n```hemlock\n// Hemlock-Funktionen als Callbacks an C bergeben\nfn my_compare(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    return va - vb;\n}\n\n// C-aufrufbaren Funktionspointer erstellen\nlet cmp = callback(my_compare, [\"ptr\", \"ptr\"], \"i32\");\n\n// Mit qsort oder jeder C-Funktion verwenden, die einen Callback erwartet\nqsort(arr, count, elem_size, cmp);\n\n// Aufrumen wenn fertig\ncallback_free(cmp);\n```\n\n**4. String-Marshaling**\n```hemlock\n// Zukunft: Automatische String-Konvertierung\nlet s = \"hello\";\nc_string_function(s);  // Automatisch zu C-String konvertieren\n```\n\n**5. Fehlerbehandlung**\n```hemlock\n// Zukunft: Bessere Fehlerberichterstattung\ntry {\n    let result = risky_c_function();\n} catch (e) {\n    print(\"FFI-Fehler: \" + e);\n}\n```\n\n**6. Typsicherheit**\n```hemlock\n// Zukunft: Typannotationen fr FFI\n@ffi(\"libm.so\")\nfn sqrt(x: f64): f64;\n\nlet result = sqrt(16.0);  // Typgeprft\n```\n\n### Funktionen\n\n**v1.0:**\n-  Grundlegendes FFI mit primitiven Typen\n-  Dynamisches Laden von Bibliotheken\n-  Funktionsaufrufe\n-  Callback-Untersttzung ber libffi-Closures\n\n**Zukunft:**\n- Struct-Untersttzung\n- Array-Behandlungsverbesserungen\n- Automatische Bindungsgenerierung\n\n## FFI-Callbacks\n\nHemlock untersttzt das bergeben von Funktionen an C-Code als Callbacks unter Verwendung von libffi-Closures. Dies ermglicht die Integration mit C-APIs, die Funktionspointer erwarten, wie `qsort`, Event-Loops und callback-basierte Bibliotheken.\n\n### Callbacks erstellen\n\nVerwenden Sie `callback()`, um einen C-aufrufbaren Funktionspointer aus einer Hemlock-Funktion zu erstellen:\n\n```hemlock\n// callback(function, param_types, return_type) -> ptr\nlet cb = callback(my_function, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n**Parameter:**\n- `function`: Eine Hemlock-Funktion zum Umhllen\n- `param_types`: Array von Typnamen-Strings (z.B. `[\"ptr\", \"i32\"]`)\n- `return_type`: Rckgabetyp-String (z.B. `\"i32\"`, `\"void\"`)\n\n**Untersttzte Callback-Typen:**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - Vorzeichenbehaftete Integer\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - Vorzeichenlose Integer\n- `\"f32\"`, `\"f64\"` - Fliekommazahlen\n- `\"ptr\"` - Pointer\n- `\"void\"` - Kein Rckgabewert\n- `\"bool\"` - Boolean\n\n### Beispiel: qsort\n\n```hemlock\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// Vergleichsfunktion fr Integer (aufsteigend)\nfn compare_ints(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va < vb) { return -1; }\n    if (va > vb) { return 1; }\n    return 0;\n}\n\n// Array von 5 Integern allozieren\nlet arr = alloc(20);  // 5 * 4 Bytes\nptr_write_i32(arr, 5);\nptr_write_i32(ptr_offset(arr, 1, 4), 2);\nptr_write_i32(ptr_offset(arr, 2, 4), 8);\nptr_write_i32(ptr_offset(arr, 3, 4), 1);\nptr_write_i32(ptr_offset(arr, 4, 4), 9);\n\n// Callback erstellen und sortieren\nlet cmp = callback(compare_ints, [\"ptr\", \"ptr\"], \"i32\");\nqsort(arr, 5, 4, cmp);\n\n// Array ist jetzt sortiert: [1, 2, 5, 8, 9]\n\n// Aufrumen\ncallback_free(cmp);\nfree(arr);\n```\n\n### Pointer-Hilfsfunktionen\n\nHemlock bietet umfassende Hilfsfunktionen fr die Arbeit mit Rohpointern. Diese sind essentiell fr FFI-Callbacks und direkte Speichermanipulation.\n\n#### Integer-Typ-Helfer\n\n| Funktion | Beschreibung |\n|----------|--------------|\n| `ptr_deref_i8(ptr)` | Pointer dereferenzieren, i8 lesen |\n| `ptr_deref_i16(ptr)` | Pointer dereferenzieren, i16 lesen |\n| `ptr_deref_i32(ptr)` | Pointer dereferenzieren, i32 lesen |\n| `ptr_deref_i64(ptr)` | Pointer dereferenzieren, i64 lesen |\n| `ptr_deref_u8(ptr)` | Pointer dereferenzieren, u8 lesen |\n| `ptr_deref_u16(ptr)` | Pointer dereferenzieren, u16 lesen |\n| `ptr_deref_u32(ptr)` | Pointer dereferenzieren, u32 lesen |\n| `ptr_deref_u64(ptr)` | Pointer dereferenzieren, u64 lesen |\n| `ptr_write_i8(ptr, value)` | i8 an Pointer-Position schreiben |\n| `ptr_write_i16(ptr, value)` | i16 an Pointer-Position schreiben |\n| `ptr_write_i32(ptr, value)` | i32 an Pointer-Position schreiben |\n| `ptr_write_i64(ptr, value)` | i64 an Pointer-Position schreiben |\n| `ptr_write_u8(ptr, value)` | u8 an Pointer-Position schreiben |\n| `ptr_write_u16(ptr, value)` | u16 an Pointer-Position schreiben |\n| `ptr_write_u32(ptr, value)` | u32 an Pointer-Position schreiben |\n| `ptr_write_u64(ptr, value)` | u64 an Pointer-Position schreiben |\n\n#### Float-Typ-Helfer\n\n| Funktion | Beschreibung |\n|----------|--------------|\n| `ptr_deref_f32(ptr)` | Pointer dereferenzieren, f32 (float) lesen |\n| `ptr_deref_f64(ptr)` | Pointer dereferenzieren, f64 (double) lesen |\n| `ptr_write_f32(ptr, value)` | f32 an Pointer-Position schreiben |\n| `ptr_write_f64(ptr, value)` | f64 an Pointer-Position schreiben |\n\n#### Pointer-Typ-Helfer\n\n| Funktion | Beschreibung |\n|----------|--------------|\n| `ptr_deref_ptr(ptr)` | Pointer-zu-Pointer dereferenzieren |\n| `ptr_write_ptr(ptr, value)` | Pointer an Pointer-Position schreiben |\n| `ptr_offset(ptr, index, size)` | Offset berechnen: `ptr + index * size` |\n| `ptr_read_i32(ptr)` | i32 durch Pointer-zu-Pointer lesen (fr qsort-Callbacks) |\n| `ptr_null()` | Null-Pointer-Konstante erhalten |\n\n#### Buffer-Konvertierungs-Helfer\n\n| Funktion | Beschreibung |\n|----------|--------------|\n| `buffer_ptr(buffer)` | Rohpointer aus Buffer erhalten |\n| `ptr_to_buffer(ptr, size)` | Daten von Pointer in neuen Buffer kopieren |\n\n#### FFI-Hilfsfunktionen\n\n| Funktion | Beschreibung |\n|----------|--------------|\n| `ffi_sizeof(type_name)` | Gre in Bytes eines FFI-Typs erhalten |\n\n**Untersttzte Typnamen fr `ffi_sizeof`:**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - Vorzeichenbehaftete Integer (1, 2, 4, 8 Bytes)\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - Vorzeichenlose Integer (1, 2, 4, 8 Bytes)\n- `\"f32\"`, `\"f64\"` - Floats (4, 8 Bytes)\n- `\"ptr\"` - Pointer (8 Bytes auf 64-Bit)\n- `\"size_t\"`, `\"usize\"` - Plattformabhngiger Grentyp\n- `\"intptr_t\"`, `\"isize\"` - Plattformabhngiger vorzeichenbehafteter Pointer-Typ\n\n#### Beispiel: Mit verschiedenen Typen arbeiten\n\n```hemlock\nlet p = alloc(64);\n\n// Integer schreiben und lesen\nptr_write_i8(p, 42);\nprint(ptr_deref_i8(p));  // 42\n\nptr_write_i64(ptr_offset(p, 1, 8), 9000000000);\nprint(ptr_deref_i64(ptr_offset(p, 1, 8)));  // 9000000000\n\n// Floats schreiben und lesen\nptr_write_f64(p, 3.14159);\nprint(ptr_deref_f64(p));  // 3.14159\n\n// Pointer-zu-Pointer\nlet inner = alloc(4);\nptr_write_i32(inner, 999);\nptr_write_ptr(p, inner);\nlet retrieved = ptr_deref_ptr(p);\nprint(ptr_deref_i32(retrieved));  // 999\n\n// Typgren erhalten\nprint(ffi_sizeof(\"i64\"));  // 8\nprint(ffi_sizeof(\"ptr\"));  // 8 (auf 64-Bit)\n\n// Buffer-Konvertierung\nlet buf = buffer(64);\nptr_write_i32(buffer_ptr(buf), 12345);\nprint(ptr_deref_i32(buffer_ptr(buf)));  // 12345\n\nfree(inner);\nfree(p);\n```\n\n### Callbacks freigeben\n\n**Wichtig:** Callbacks immer freigeben wenn fertig, um Speicherlecks zu vermeiden:\n\n```hemlock\nlet cb = callback(my_fn, [\"ptr\"], \"void\");\n// ... Callback verwenden ...\ncallback_free(cb);  // Freigeben wenn fertig\n```\n\nCallbacks werden auch automatisch freigegeben wenn das Programm beendet wird.\n\n### Closures in Callbacks\n\nCallbacks erfassen ihre Closure-Umgebung, sodass sie auf uere Scope-Variablen zugreifen knnen:\n\n```hemlock\nlet multiplier = 10;\n\nfn scale(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    // Kann auf 'multiplier' aus uerem Scope zugreifen\n    return (va * multiplier) - (vb * multiplier);\n}\n\nlet cmp = callback(scale, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n### Thread-Sicherheit\n\nCallback-Aufrufe werden mit einem Mutex serialisiert, um Thread-Sicherheit zu gewhrleisten, da der Hemlock-Interpreter nicht vollstndig thread-sicher ist. Das bedeutet:\n- Nur ein Callback kann gleichzeitig ausgefhrt werden\n- Sicher mit Multi-Thread-C-Bibliotheken verwendbar\n- Kann die Leistung beeinflussen, wenn Callbacks sehr hufig von mehreren Threads aufgerufen werden\n\n### Fehlerbehandlung in Callbacks\n\nAusnahmen, die in Callbacks geworfen werden, knnen nicht an C-Code weitergeleitet werden. Stattdessen:\n- Eine Warnung wird auf stderr ausgegeben\n- Der Callback gibt einen Standardwert zurck (0 oder NULL)\n- Die Ausnahme wird protokolliert, aber nicht weitergeleitet\n\n```hemlock\nfn risky_callback(a: ptr): i32 {\n    throw \"Etwas ist schiefgelaufen\";  // Warnung wird ausgegeben, gibt 0 zurck\n}\n```\n\nFr robuste Fehlerbehandlung validieren Sie Eingaben und vermeiden Sie das Werfen in Callbacks.\n\n## FFI-Structs\n\nHemlock untersttzt das bergeben von Structs by Value an C-Funktionen. Struct-Typen werden automatisch fr FFI registriert, wenn Sie sie mit Typannotationen definieren.\n\n### FFI-kompatible Structs definieren\n\nEin Struct ist FFI-kompatibel, wenn alle Felder explizite Typannotationen mit FFI-kompatiblen Typen haben:\n\n```hemlock\n// FFI-kompatibles Struct\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\n// FFI-kompatibles Struct mit mehreren Feldtypen\ndefine Rectangle {\n    top_left: Point,      // Verschachteltes Struct\n    width: f64,\n    height: f64,\n}\n\n// NICHT FFI-kompatibel (Feld ohne Typannotation)\ndefine DynamicObject {\n    name,                 // Kein Typ - nicht in FFI verwendbar\n    value,\n}\n```\n\n### Structs in FFI verwenden\n\nExtern-Funktionen deklarieren, die Struct-Typen verwenden:\n\n```hemlock\n// Den Struct-Typ definieren\ndefine Vector2D {\n    x: f64,\n    y: f64,\n}\n\n// Die C-Bibliothek importieren\nimport \"libmath.so\";\n\n// Extern-Funktion deklarieren, die Structs nimmt/zurckgibt\nextern fn vector_add(a: Vector2D, b: Vector2D): Vector2D;\nextern fn vector_length(v: Vector2D): f64;\n\n// Natrlich verwenden\nlet a: Vector2D = { x: 3.0, y: 0.0 };\nlet b: Vector2D = { x: 0.0, y: 4.0 };\nlet result = vector_add(a, b);\nprint(result.x);  // 3.0\nprint(result.y);  // 4.0\n\nlet len = vector_length(result);\nprint(len);       // 5.0\n```\n\n### Untersttzte Feldtypen\n\nStruct-Felder mssen diese FFI-kompatiblen Typen verwenden:\n\n| Hemlock-Typ | C-Typ | Gre |\n|-------------|-------|-------|\n| `i8` | `int8_t` | 1 Byte |\n| `i16` | `int16_t` | 2 Bytes |\n| `i32` | `int32_t` | 4 Bytes |\n| `i64` | `int64_t` | 8 Bytes |\n| `u8` | `uint8_t` | 1 Byte |\n| `u16` | `uint16_t` | 2 Bytes |\n| `u32` | `uint32_t` | 4 Bytes |\n| `u64` | `uint64_t` | 8 Bytes |\n| `f32` | `float` | 4 Bytes |\n| `f64` | `double` | 8 Bytes |\n| `ptr` | `void*` | 8 Bytes |\n| `string` | `char*` | 8 Bytes |\n| `bool` | `int` | variiert |\n| Verschachteltes Struct | struct | variiert |\n\n### Struct-Layout\n\nHemlock verwendet die nativen Struct-Layout-Regeln der Plattform (passend zum C-ABI):\n- Felder werden entsprechend ihrem Typ ausgerichtet\n- Padding wird nach Bedarf eingefgt\n- Gesamtgre wird auf das grte Element aufgefllt\n\n```hemlock\n// Beispiel: C-kompatibles Layout\ndefine Mixed {\n    a: i8,    // Offset 0, Gre 1\n              // 3 Bytes Padding\n    b: i32,   // Offset 4, Gre 4\n}\n// Gesamtgre: 8 Bytes (mit Padding)\n\ndefine Point3D {\n    x: f64,   // Offset 0, Gre 8\n    y: f64,   // Offset 8, Gre 8\n    z: f64,   // Offset 16, Gre 8\n}\n// Gesamtgre: 24 Bytes (kein Padding erforderlich)\n```\n\n### Verschachtelte Structs\n\nStructs knnen andere Structs enthalten:\n\n```hemlock\ndefine Inner {\n    x: i32,\n    y: i32,\n}\n\ndefine Outer {\n    inner: Inner,\n    z: i32,\n}\n\nimport \"mylib.so\";\nextern fn process_nested(data: Outer): i32;\n\nlet obj: Outer = {\n    inner: { x: 1, y: 2 },\n    z: 3,\n};\nlet result = process_nested(obj);\n```\n\n### Struct-Rckgabewerte\n\nC-Funktionen knnen Structs zurckgeben:\n\n```hemlock\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\nimport \"libmath.so\";\nextern fn get_origin(): Point;\n\nlet p = get_origin();\nprint(p.x);  // 0.0\nprint(p.y);  // 0.0\n```\n\n### Einschrnkungen\n\n- **Struct-Felder mssen Typannotationen haben** - Felder ohne Typen sind nicht FFI-kompatibel\n- **Keine Arrays in Structs** - stattdessen Pointer verwenden\n- **Keine Unions** - nur Struct-Typen werden untersttzt\n- **Callbacks knnen keine Structs zurckgeben** - Pointer fr Callback-Rckgabewerte verwenden\n\n### Struct-Typen exportieren\n\nSie knnen Struct-Typdefinitionen aus einem Modul mit `export define` exportieren:\n\n```hemlock\n// geometry.hml\nexport define Vector2 {\n    x: f32,\n    y: f32,\n}\n\nexport define Rectangle {\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n}\n\nexport fn create_rect(x: f32, y: f32, w: f32, h: f32): Rectangle {\n    return { x: x, y: y, width: w, height: h };\n}\n```\n\n**Wichtig:** Exportierte Struct-Typen werden **global** registriert, wenn das Modul geladen wird. Sie werden automatisch verfgbar, wenn Sie irgendetwas aus dem Modul importieren. Sie mssen (und knnen) sie NICHT explizit nach Namen importieren:\n\n```hemlock\n// main.hml\n\n// GUT - Struct-Typen sind nach jedem Import aus dem Modul automatisch verfgbar\nimport { create_rect } from \"./geometry.hml\";\nlet v: Vector2 = { x: 1.0, y: 2.0 };      // Funktioniert - Vector2 ist global verfgbar\nlet r: Rectangle = create_rect(0.0, 0.0, 100.0, 50.0);  // Funktioniert\n\n// SCHLECHT - kann Struct-Typen nicht explizit nach Namen importieren\nimport { Vector2 } from \"./geometry.hml\";  // Fehler: Undefinierte Variable 'Vector2'\n```\n\nDieses Verhalten existiert, weil Struct-Typen in der globalen Typ-Registry registriert werden, wenn das Modul ldt, anstatt als Werte in der Export-Umgebung des Moduls gespeichert zu werden. Der Typ wird fr allen Code verfgbar, der aus dem Modul importiert.\n\n## Aktuelle Einschrnkungen\n\nFFI hat die folgenden Einschrnkungen:\n\n**1. Manuelle Typkonvertierung**\n- Muss String-Konvertierungen manuell verwalten\n- Keine automatische Hemlock-String  C-String-Konvertierung\n\n**2. Begrenzte Fehlerbehandlung**\n- Grundlegende Fehlerberichterstattung\n- Ausnahmen in Callbacks knnen nicht an C weitergeleitet werden\n\n**3. Manuelles Laden von Bibliotheken**\n- Muss Bibliotheken manuell laden\n- Keine automatische Bindungsgenerierung\n\n**4. Plattformspezifischer Code**\n- Bibliothekspfade unterscheiden sich nach Plattform\n- Muss .so vs .dylib vs .dll behandeln\n\n## Best Practices\n\nWhrend umfassende FFI-Dokumentation noch entwickelt wird, hier allgemeine Best Practices:\n\n### 1. Typsicherheit\n\n```hemlock\n// Explizit bei Typen sein\nlet x: i32 = 42;\nlet result: f64 = c_function(x);\n```\n\n### 2. Speicherverwaltung\n\n```hemlock\n// Daran denken, allozierten Speicher freizugeben\nlet ptr = c_malloc(1024);\n// ... ptr verwenden\nc_free(ptr);\n```\n\n### 3. Fehlerprfung\n\n```hemlock\n// Rckgabewerte prfen\nlet result = c_function();\nif (result == null) {\n    print(\"C-Funktion fehlgeschlagen\");\n}\n```\n\n### 4. Plattformkompatibilitt\n\n```hemlock\n// Plattformunterschiede behandeln\n// Entsprechende Bibliothekserweiterungen verwenden (.so, .dylib, .dll)\n```\n\n## Beispiele\n\nFr funktionierende Beispiele siehe:\n- Callback-Tests: `/tests/ffi_callbacks/` - qsort-Callback-Beispiele\n- Stdlib FFI-Verwendung: `/stdlib/hash.hml`, `/stdlib/regex.hml`, `/stdlib/crypto.hml`\n- Beispielprogramme: `/examples/` (falls verfgbar)\n\n## Hilfe erhalten\n\nFFI ist ein neueres Feature in Hemlock. Bei Fragen oder Problemen:\n\n1. Test-Suite auf funktionierende Beispiele prfen\n2. libffi-Dokumentation fr Low-Level-Details heranziehen\n3. Bugs melden oder Features ber Projekt-Issues anfragen\n\n## Zusammenfassung\n\nHemlocks FFI bietet:\n\n-  C-Funktionsaufruf aus Shared Libraries\n-  Primitive Typuntersttzung (i8-i64, u8-u64, f32, f64, ptr)\n-  Automatische Typkonvertierung\n-  libffi-basierte Portabilitt\n-  Grundlage fr native Bibliotheksintegration\n-  **Funktionspointer-Callbacks** - Hemlock-Funktionen an C bergeben\n-  **Extern-Funktionen exportieren** - FFI-Bindungen ber Module teilen\n-  **Struct-bergabe und -Rckgabe** - C-kompatible Structs by Value bergeben\n-  **Export define** - Struct-Typdefinitionen ber Module teilen (automatisch global importiert)\n-  **Vollstndige Pointer-Helfer** - Alle Typen lesen/schreiben (i8-i64, u8-u64, f32, f64, ptr)\n-  **Buffer/Pointer-Konvertierung** - `buffer_ptr()`, `ptr_to_buffer()` fr Daten-Marshaling\n-  **FFI-Typgren** - `ffi_sizeof()` fr plattformbewusste Typgren\n-  **Plattformtypen** - `size_t`, `usize`, `isize`, `intptr_t`, `uintptr_t`-Untersttzung\n\n**Aktueller Status:** FFI voll ausgestattet mit primitiven Typen, Structs, Callbacks, Modul-Exports und vollstndigen Pointer-Hilfsfunktionen\n\n**Zukunft:** String-Marshaling-Hilfsfunktionen\n\n**Anwendungsflle:** Systembibliotheken, Drittanbieter-Bibliotheken, qsort, Event-Loops, callback-basierte APIs, wiederverwendbare Bibliotheks-Wrapper\n\n## Beitragen\n\nFFI-Dokumentation wird erweitert. Wenn Sie mit FFI arbeiten:\n- Dokumentieren Sie Ihre Anwendungsflle\n- Teilen Sie Beispielcode\n- Melden Sie Probleme oder Einschrnkungen\n- Schlagen Sie Verbesserungen vor\n\nDas FFI-System ist darauf ausgelegt, praktisch und sicher zu sein, whrend es bei Bedarf Low-Level-Zugriff bietet, gem Hemlocks Philosophie von \"explizit statt implizit\" und \"unsafe ist ein Feature, kein Bug\".\n"}, "Fortgeschrittene Themen -> File IO": {"id": "advanced-file-io", "content": "# Datei-I/O in Hemlock\n\nHemlock bietet eine **Dateiobjekt-API** fr Dateioperationen mit ordnungsgemer Fehlerbehandlung und Ressourcenverwaltung.\n\n## Inhaltsverzeichnis\n\n- [berblick](#berblick)\n- [Dateien ffnen](#dateien-ffnen)\n- [Dateimethoden](#dateimethoden)\n- [Dateieigenschaften](#dateieigenschaften)\n- [Fehlerbehandlung](#fehlerbehandlung)\n- [Ressourcenverwaltung](#ressourcenverwaltung)\n- [Vollstndige API-Referenz](#vollstndige-api-referenz)\n- [Hufige Muster](#hufige-muster)\n- [Best Practices](#best-practices)\n\n## berblick\n\nDie Dateiobjekt-API bietet:\n\n- **Explizite Ressourcenverwaltung** - Dateien mssen manuell geschlossen werden\n- **Mehrere ffnungsmodi** - Lesen, Schreiben, Anhngen, Lesen/Schreiben\n- **Text- und Binroperationen** - Sowohl Text- als auch Binrdaten lesen/schreiben\n- **Seek-Untersttzung** - Wahlfreier Zugriff innerhalb von Dateien\n- **Umfassende Fehlermeldungen** - Kontextbewusste Fehlerberichterstattung\n\n**Wichtig:** Dateien werden nicht automatisch geschlossen. Sie mssen `f.close()` aufrufen, um Dateideskriptor-Lecks zu vermeiden.\n\n## Dateien ffnen\n\nVerwenden Sie `open(path, mode?)`, um eine Datei zu ffnen:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");     // Lesemodus (Standard)\nlet f2 = open(\"output.txt\", \"w\");  // Schreibmodus (abschneiden)\nlet f3 = open(\"log.txt\", \"a\");     // Anhngemodus\nlet f4 = open(\"data.bin\", \"r+\");   // Lese-/Schreibmodus\n```\n\n### ffnungsmodi\n\n| Modus | Beschreibung | Datei muss existieren | Schneidet ab | Position |\n|-------|--------------|----------------------|--------------|----------|\n| `\"r\"` | Lesen (Standard) | Ja | Nein | Anfang |\n| `\"w\"` | Schreiben | Nein (erstellt) | Ja | Anfang |\n| `\"a\"` | Anhngen | Nein (erstellt) | Nein | Ende |\n| `\"r+\"` | Lesen und Schreiben | Ja | Nein | Anfang |\n| `\"w+\"` | Lesen und Schreiben | Nein (erstellt) | Ja | Anfang |\n| `\"a+\"` | Lesen und Anhngen | Nein (erstellt) | Nein | Ende |\n\n### Beispiele\n\n**Bestehende Datei lesen:**\n```hemlock\nlet f = open(\"config.json\", \"r\");\n// oder einfach:\nlet f = open(\"config.json\");  // \"r\" ist Standard\n```\n\n**Neue Datei zum Schreiben erstellen:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");  // Erstellt oder schneidet ab\n```\n\n**An Datei anhngen:**\n```hemlock\nlet f = open(\"log.txt\", \"a\");  // Erstellt wenn nicht existiert\n```\n\n**Lese- und Schreibmodus:**\n```hemlock\nlet f = open(\"data.bin\", \"r+\");  // Bestehende Datei, kann lesen/schreiben\n```\n\n## Dateimethoden\n\n### Lesen\n\n#### read(size?: i32): string\n\nText aus Datei lesen (optionaler size-Parameter).\n\n**Ohne size (alles lesen):**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet all = f.read();  // Von aktueller Position bis EOF lesen\nf.close();\n```\n\n**Mit size (bestimmte Bytes lesen):**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet chunk = f.read(1024);  // Bis zu 1024 Bytes lesen\nlet next = f.read(1024);   // Nchste 1024 Bytes lesen\nf.close();\n```\n\n**Rckgabe:** String mit den gelesenen Daten, oder leerer String bei EOF\n\n**Beispiel - Gesamte Datei lesen:**\n```hemlock\nlet f = open(\"poem.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n```\n\n**Beispiel - In Chunks lesen:**\n```hemlock\nlet f = open(\"large.txt\", \"r\");\nwhile (true) {\n    let chunk = f.read(4096);  // 4KB Chunks\n    if (chunk == \"\") { break; }  // EOF erreicht\n    process(chunk);\n}\nf.close();\n```\n\n#### read_bytes(size: i32): buffer\n\nBinrdaten lesen (gibt Buffer zurck).\n\n**Parameter:**\n- `size` (i32) - Anzahl der zu lesenden Bytes\n\n**Rckgabe:** Buffer mit den gelesenen Bytes\n\n```hemlock\nlet f = open(\"image.png\", \"r\");\nlet binary = f.read_bytes(256);  // 256 Bytes lesen\nprint(binary.length);  // 256 (oder weniger bei EOF)\n\n// Auf einzelne Bytes zugreifen\nlet first_byte = binary[0];\nprint(first_byte);\n\nf.close();\n```\n\n**Beispiel - Gesamte Binrdatei lesen:**\n```hemlock\nlet f = open(\"data.bin\", \"r\");\nlet size = 10240;  // Erwartete Gre\nlet data = f.read_bytes(size);\nf.close();\n\n// Binrdaten verarbeiten\nlet i = 0;\nwhile (i < data.length) {\n    let byte = data[i];\n    // ... Byte verarbeiten\n    i = i + 1;\n}\n```\n\n### Schreiben\n\n#### write(data: string): i32\n\nText in Datei schreiben (gibt geschriebene Bytes zurck).\n\n**Parameter:**\n- `data` (string) - Zu schreibender Text\n\n**Rckgabe:** Anzahl der geschriebenen Bytes (i32)\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nlet written = f.write(\"Hallo, Welt!\\n\");\nprint(\"Schrieb \" + typeof(written) + \" Bytes\");  // \"Schrieb 13 Bytes\"\nf.close();\n```\n\n**Beispiel - Mehrere Zeilen schreiben:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Zeile 1\\n\");\nf.write(\"Zeile 2\\n\");\nf.write(\"Zeile 3\\n\");\nf.close();\n```\n\n**Beispiel - An Log-Datei anhngen:**\n```hemlock\nlet f = open(\"app.log\", \"a\");\nf.write(\"[INFO] Anwendung gestartet\\n\");\nf.write(\"[INFO] Benutzer angemeldet\\n\");\nf.close();\n```\n\n#### write_bytes(data: buffer): i32\n\nBinrdaten schreiben (gibt geschriebene Bytes zurck).\n\n**Parameter:**\n- `data` (buffer) - Zu schreibende Binrdaten\n\n**Rckgabe:** Anzahl der geschriebenen Bytes (i32)\n\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Binrdaten erstellen\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\nlet bytes = f.write_bytes(buf);\nprint(\"Schrieb \" + typeof(bytes) + \" Bytes\");\n\nf.close();\n```\n\n**Beispiel - Binrdatei kopieren:**\n```hemlock\nlet src = open(\"input.bin\", \"r\");\nlet dst = open(\"output.bin\", \"w\");\n\nlet data = src.read_bytes(1024);\nwhile (data.length > 0) {\n    dst.write_bytes(data);\n    data = src.read_bytes(1024);\n}\n\nsrc.close();\ndst.close();\n```\n\n### Positionierung\n\n#### seek(position: i32): i32\n\nZu bestimmter Position bewegen (gibt neue Position zurck).\n\n**Parameter:**\n- `position` (i32) - Byte-Offset vom Dateianfang\n\n**Rckgabe:** Neue Position (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Zu Byte 100 bewegen\nf.seek(100);\n\n// Ab Position 100 lesen\nlet data = f.read(50);\n\n// Zum Anfang zurcksetzen\nf.seek(0);\n\nf.close();\n```\n\n**Beispiel - Wahlfreier Zugriff:**\n```hemlock\nlet f = open(\"records.dat\", \"r\");\n\n// Datensatz an Offset 1000 lesen\nf.seek(1000);\nlet record1 = f.read_bytes(100);\n\n// Datensatz an Offset 2000 lesen\nf.seek(2000);\nlet record2 = f.read_bytes(100);\n\nf.close();\n```\n\n#### tell(): i32\n\nAktuelle Position in Datei erhalten.\n\n**Rckgabe:** Aktueller Byte-Offset (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet pos1 = f.tell();  // 0 (am Anfang)\n\nf.read(100);\nlet pos2 = f.tell();  // 100 (nach Lesen von 100 Bytes)\n\nf.seek(500);\nlet pos3 = f.tell();  // 500 (nach Seek)\n\nf.close();\n```\n\n**Beispiel - Gelesene Menge messen:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet start = f.tell();\nlet content = f.read();\nlet end = f.tell();\n\nlet bytes_read = end - start;\nprint(\"Las \" + typeof(bytes_read) + \" Bytes\");\n\nf.close();\n```\n\n### Schlieen\n\n#### close()\n\nDatei schlieen (idempotent, kann mehrfach aufgerufen werden).\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n// ... Datei verwenden\nf.close();\nf.close();  // Sicher - kein Fehler beim zweiten Schlieen\n```\n\n**Wichtige Hinweise:**\n- Dateien immer schlieen wenn fertig, um Dateideskriptor-Lecks zu vermeiden\n- Schlieen ist idempotent - kann mehrfach sicher aufgerufen werden\n- Nach dem Schlieen werden alle anderen Operationen einen Fehler verursachen\n- `finally`-Blcke verwenden, um sicherzustellen, dass Dateien auch bei Fehlern geschlossen werden\n\n## Dateieigenschaften\n\nDateiobjekte haben drei schreibgeschtzte Eigenschaften:\n\n### path: string\n\nDer zum ffnen der Datei verwendete Dateipfad.\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);  // \"/path/to/file.txt\"\nf.close();\n```\n\n### mode: string\n\nDer Modus, mit dem die Datei geffnet wurde.\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);  // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);  // \"w\"\nf2.close();\n```\n\n### closed: bool\n\nOb die Datei geschlossen ist.\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n**Beispiel - Prfen ob Datei geffnet ist:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... Inhalt verarbeiten\n}\n\nf.close();\n\nif (f.closed) {\n    print(\"Datei ist jetzt geschlossen\");\n}\n```\n\n## Fehlerbehandlung\n\nAlle Dateioperationen enthalten ordnungsgeme Fehlermeldungen mit Kontext.\n\n### Hufige Fehler\n\n**Datei nicht gefunden:**\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Fehler: Konnte 'missing.txt' nicht ffnen: Keine solche Datei oder Verzeichnis\n```\n\n**Von geschlossener Datei lesen:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Fehler: Kann nicht von geschlossener Datei 'data.txt' lesen\n```\n\n**In schreibgeschtzte Datei schreiben:**\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Fehler: Kann nicht in Datei 'readonly.txt' schreiben, die im Nur-Lese-Modus geffnet wurde\n```\n\n**Von schreibgeschtzter Datei lesen:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.read();\n// Fehler: Kann nicht von Datei 'output.txt' lesen, die im Nur-Schreib-Modus geffnet wurde\n```\n\n### try/catch verwenden\n\n```hemlock\ntry {\n    let f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    f.close();\n    process(content);\n} catch (e) {\n    print(\"Fehler beim Lesen der Datei: \" + e);\n}\n```\n\n## Ressourcenverwaltung\n\n### Grundmuster\n\nDateien immer explizit schlieen:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### Mit Fehlerbehandlung (empfohlen)\n\n`finally` verwenden, um sicherzustellen, dass Dateien auch bei Fehlern geschlossen werden:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Immer schlieen, auch bei Fehler\n}\n```\n\n### Mehrere Dateien\n\n```hemlock\nlet src = null;\nlet dst = null;\n\ntry {\n    src = open(\"input.txt\", \"r\");\n    dst = open(\"output.txt\", \"w\");\n\n    let content = src.read();\n    dst.write(content);\n} finally {\n    if (src != null) { src.close(); }\n    if (dst != null) { dst.close(); }\n}\n```\n\n### Hilfsfunktions-Muster\n\n```hemlock\nfn with_file(path: string, mode: string, callback) {\n    let f = open(path, mode);\n    try {\n        return callback(f);\n    } finally {\n        f.close();\n    }\n}\n\n// Verwendung:\nwith_file(\"data.txt\", \"r\", fn(f) {\n    return f.read();\n});\n```\n\n## Vollstndige API-Referenz\n\n### Funktionen\n\n| Funktion | Parameter | Rckgabe | Beschreibung |\n|----------|-----------|----------|--------------|\n| `open(path, mode?)` | path: string, mode?: string | File | Datei ffnen (mode Standard ist \"r\") |\n\n### Methoden\n\n| Methode | Parameter | Rckgabe | Beschreibung |\n|---------|-----------|----------|--------------|\n| `read(size?)` | size?: i32 | string | Text lesen (alles oder bestimmte Bytes) |\n| `read_bytes(size)` | size: i32 | buffer | Binrdaten lesen |\n| `write(data)` | data: string | i32 | Text schreiben, gibt geschriebene Bytes zurck |\n| `write_bytes(data)` | data: buffer | i32 | Binrdaten schreiben, gibt geschriebene Bytes zurck |\n| `seek(position)` | position: i32 | i32 | Zu Position springen, gibt neue Position zurck |\n| `tell()` | - | i32 | Aktuelle Position erhalten |\n| `close()` | - | null | Datei schlieen (idempotent) |\n\n### Eigenschaften (schreibgeschtzt)\n\n| Eigenschaft | Typ | Beschreibung |\n|-------------|-----|--------------|\n| `path` | string | Dateipfad |\n| `mode` | string | ffnungsmodus |\n| `closed` | bool | Ob Datei geschlossen ist |\n\n## Hufige Muster\n\n### Gesamte Datei lesen\n\n```hemlock\nfn read_file(path: string): string {\n    let f = open(path, \"r\");\n    try {\n        return f.read();\n    } finally {\n        f.close();\n    }\n}\n\nlet content = read_file(\"config.json\");\n```\n\n### Gesamte Datei schreiben\n\n```hemlock\nfn write_file(path: string, content: string) {\n    let f = open(path, \"w\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nwrite_file(\"output.txt\", \"Hallo, Welt!\");\n```\n\n### An Datei anhngen\n\n```hemlock\nfn append_file(path: string, content: string) {\n    let f = open(path, \"a\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nappend_file(\"log.txt\", \"[INFO] Ereignis aufgetreten\\n\");\n```\n\n### Zeilen lesen\n\n```hemlock\nfn read_lines(path: string) {\n    let f = open(path, \"r\");\n    try {\n        let content = f.read();\n        return content.split(\"\\n\");\n    } finally {\n        f.close();\n    }\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Zeile \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### Groe Dateien in Chunks verarbeiten\n\n```hemlock\nfn process_large_file(path: string) {\n    let f = open(path, \"r\");\n    try {\n        while (true) {\n            let chunk = f.read(4096);  // 4KB Chunks\n            if (chunk == \"\") { break; }\n\n            // Chunk verarbeiten\n            process_chunk(chunk);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n### Binrdatei kopieren\n\n```hemlock\nfn copy_file(src_path: string, dst_path: string) {\n    let src = null;\n    let dst = null;\n\n    try {\n        src = open(src_path, \"r\");\n        dst = open(dst_path, \"w\");\n\n        while (true) {\n            let chunk = src.read_bytes(4096);\n            if (chunk.length == 0) { break; }\n\n            dst.write_bytes(chunk);\n        }\n    } finally {\n        if (src != null) { src.close(); }\n        if (dst != null) { dst.close(); }\n    }\n}\n\ncopy_file(\"input.dat\", \"output.dat\");\n```\n\n### Datei abschneiden\n\n```hemlock\nfn truncate_file(path: string) {\n    let f = open(path, \"w\");  // \"w\"-Modus schneidet ab\n    f.close();\n}\n\ntruncate_file(\"empty_me.txt\");\n```\n\n### Wahlfreies Lesen\n\n```hemlock\nfn read_at_offset(path: string, offset: i32, size: i32): string {\n    let f = open(path, \"r\");\n    try {\n        f.seek(offset);\n        return f.read(size);\n    } finally {\n        f.close();\n    }\n}\n\nlet data = read_at_offset(\"records.dat\", 1000, 100);\n```\n\n### Dateigre\n\n```hemlock\nfn file_size(path: string): i32 {\n    let f = open(path, \"r\");\n    try {\n        // Zum Ende springen\n        let end = f.seek(999999999);  // Groe Zahl\n        f.seek(0);  // Zurcksetzen\n        return end;\n    } finally {\n        f.close();\n    }\n}\n\nlet size = file_size(\"data.txt\");\nprint(\"Dateigre: \" + typeof(size) + \" Bytes\");\n```\n\n### Bedingtes Lesen/Schreiben\n\n```hemlock\nfn update_file(path: string, condition, new_content: string) {\n    let f = open(path, \"r+\");\n    try {\n        let content = f.read();\n\n        if (condition(content)) {\n            f.seek(0);  // Zum Anfang zurcksetzen\n            f.write(new_content);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n## Best Practices\n\n### 1. Immer try/finally verwenden\n\n```hemlock\n// Gut\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();\n}\n\n// Schlecht - Datei wird bei Fehler mglicherweise nicht geschlossen\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprocess(content);  // Wenn das wirft, Datei-Leck\nf.close();\n```\n\n### 2. Dateizustand vor Operationen prfen\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... Inhalt verwenden\n}\n\nf.close();\n```\n\n### 3. Geeignete Modi verwenden\n\n```hemlock\n// Nur Lesen? \"r\" verwenden\nlet f = open(\"config.json\", \"r\");\n\n// Komplett ersetzen? \"w\" verwenden\nlet f = open(\"output.txt\", \"w\");\n\n// Am Ende hinzufgen? \"a\" verwenden\nlet f = open(\"log.txt\", \"a\");\n```\n\n### 4. Fehler elegant behandeln\n\n```hemlock\nfn safe_read_file(path: string): string {\n    try {\n        let f = open(path, \"r\");\n        try {\n            return f.read();\n        } finally {\n            f.close();\n        }\n    } catch (e) {\n        print(\"Warnung: Konnte \" + path + \" nicht lesen: \" + e);\n        return \"\";\n    }\n}\n```\n\n### 5. Dateien in umgekehrter Reihenfolge des ffnens schlieen\n\n```hemlock\nlet f1 = null;\nlet f2 = null;\nlet f3 = null;\n\ntry {\n    f1 = open(\"file1.txt\", \"r\");\n    f2 = open(\"file2.txt\", \"r\");\n    f3 = open(\"file3.txt\", \"r\");\n\n    // ... Dateien verwenden\n} finally {\n    // In umgekehrter Reihenfolge schlieen\n    if (f3 != null) { f3.close(); }\n    if (f2 != null) { f2.close(); }\n    if (f1 != null) { f1.close(); }\n}\n```\n\n### 6. Groe Dateien nicht vollstndig lesen\n\n```hemlock\n// Schlecht fr groe Dateien\nlet f = open(\"huge.log\", \"r\");\nlet content = f.read();  // Ldt gesamte Datei in Speicher\nf.close();\n\n// Gut - in Chunks verarbeiten\nlet f = open(\"huge.log\", \"r\");\ntry {\n    while (true) {\n        let chunk = f.read(4096);\n        if (chunk == \"\") { break; }\n        process_chunk(chunk);\n    }\n} finally {\n    f.close();\n}\n```\n\n## Zusammenfassung\n\nHemlocks Datei-I/O-API bietet:\n\n-  Einfache, explizite Dateioperationen\n-  Text- und Binruntersttzung\n-  Wahlfreier Zugriff mit seek/tell\n-  Klare Fehlermeldungen mit Kontext\n-  Idempotente close-Operation\n\nDenken Sie daran:\n- Dateien immer manuell schlieen\n- try/finally fr Ressourcensicherheit verwenden\n- Geeignete ffnungsmodi whlen\n- Fehler elegant behandeln\n- Groe Dateien in Chunks verarbeiten\n"}, "Fortgeschrittene Themen -> Kommandozeilenargumente": {"id": "advanced-command-line-args", "content": "# Kommandozeilenargumente in Hemlock\n\nHemlock-Programme knnen auf Kommandozeilenargumente ber ein eingebautes **`args`-Array** zugreifen, das automatisch beim Programmstart befllt wird.\n\n## Inhaltsverzeichnis\n\n- [berblick](#berblick)\n- [Das args-Array](#das-args-array)\n- [Eigenschaften](#eigenschaften)\n- [Iterationsmuster](#iterationsmuster)\n- [Hufige Anwendungsflle](#hufige-anwendungsflle)\n- [Argument-Parsing-Muster](#argument-parsing-muster)\n- [Best Practices](#best-practices)\n- [Vollstndige Beispiele](#vollstndige-beispiele)\n\n## berblick\n\nDas `args`-Array bietet Zugriff auf Kommandozeilenargumente, die an Ihr Hemlock-Programm bergeben werden:\n\n- **Immer verfgbar** - Eingebaute globale Variable in allen Hemlock-Programmen\n- **Skriptname enthalten** - `args[0]` enthlt immer den Skriptpfad/-namen\n- **Array von Strings** - Alle Argumente sind Strings\n- **Nullbasiert** - Standardmige Array-Indizierung (0, 1, 2, ...)\n\n## Das args-Array\n\n### Grundstruktur\n\n```hemlock\n// args[0] ist immer der Skript-Dateiname\n// args[1] bis args[n-1] sind die eigentlichen Argumente\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // Gesamtzahl der Argumente (einschlielich Skriptname)\n```\n\n### Beispielverwendung\n\n**Befehl:**\n```bash\n./hemlock script.hml hello world \"test 123\"\n```\n\n**In script.hml:**\n```hemlock\nprint(\"Skriptname: \" + args[0]);     // \"script.hml\"\nprint(\"Anzahl args: \" + typeof(args.length));  // \"4\"\nprint(\"Erstes arg: \" + args[1]);       // \"hello\"\nprint(\"Zweites arg: \" + args[2]);      // \"world\"\nprint(\"Drittes arg: \" + args[3]);      // \"test 123\"\n```\n\n### Index-Referenz\n\n| Index | Enthlt | Beispielwert |\n|-------|---------|--------------|\n| `args[0]` | Skriptpfad/-name | `\"script.hml\"` oder `\"./script.hml\"` |\n| `args[1]` | Erstes Argument | `\"hello\"` |\n| `args[2]` | Zweites Argument | `\"world\"` |\n| `args[3]` | Drittes Argument | `\"test 123\"` |\n| ... | ... | ... |\n| `args[n-1]` | Letztes Argument | (variiert) |\n\n## Eigenschaften\n\n### Immer vorhanden\n\n`args` ist ein globales Array, das in **allen** Hemlock-Programmen verfgbar ist:\n\n```hemlock\n// Keine Deklaration oder Import erforderlich\nprint(args.length);  // Funktioniert sofort\n```\n\n### Skriptname enthalten\n\n`args[0]` enthlt immer den Skriptpfad/-namen:\n\n```hemlock\nprint(\"Fhre aus: \" + args[0]);\n```\n\n**Mgliche Werte fr args[0]:**\n- `\"script.hml\"` - Nur der Dateiname\n- `\"./script.hml\"` - Relativer Pfad\n- `\"/home/user/script.hml\"` - Absoluter Pfad\n- Hngt davon ab, wie das Skript aufgerufen wurde\n\n### Typ: Array von Strings\n\nAlle Argumente werden als Strings gespeichert:\n\n```hemlock\n// Argumente: ./hemlock script.hml 42 3.14 true\n\nprint(args[1]);  // \"42\" (String, keine Zahl)\nprint(args[2]);  // \"3.14\" (String, keine Zahl)\nprint(args[3]);  // \"true\" (String, kein Boolean)\n\n// Bei Bedarf konvertieren:\nlet num = 42;  // Bei Bedarf manuell parsen\n```\n\n### Minimale Lnge\n\nImmer mindestens 1 (der Skriptname):\n\n```hemlock\nprint(args.length);  // Minimum: 1\n```\n\n**Auch ohne Argumente:**\n```bash\n./hemlock script.hml\n```\n\n```hemlock\n// In script.hml:\nprint(args.length);  // 1 (nur Skriptname)\n```\n\n### REPL-Verhalten\n\nIm REPL ist `args.length` 0 (leeres Array):\n\n```hemlock\n# REPL-Sitzung\n> print(args.length);\n0\n```\n\n## Iterationsmuster\n\n### Einfache Iteration\n\n`args[0]` (Skriptname) berspringen und eigentliche Argumente verarbeiten:\n\n```hemlock\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument \" + typeof(i) + \": \" + args[i]);\n    i = i + 1;\n}\n```\n\n**Ausgabe fr: `./hemlock script.hml foo bar baz`**\n```\nArgument 1: foo\nArgument 2: bar\nArgument 3: baz\n```\n\n### For-In-Iteration (einschlielich Skriptname)\n\n```hemlock\nfor (let arg in args) {\n    print(arg);\n}\n```\n\n**Ausgabe:**\n```\nscript.hml\nfoo\nbar\nbaz\n```\n\n### Argumentanzahl prfen\n\n```hemlock\nif (args.length < 2) {\n    print(\"Verwendung: \" + args[0] + \" <argument>\");\n    // exit oder return\n} else {\n    let arg = args[1];\n    // arg verarbeiten\n}\n```\n\n### Alle Argumente auer Skriptname verarbeiten\n\n```hemlock\nlet actual_args = args.slice(1, args.length);\n\nfor (let arg in actual_args) {\n    print(\"Verarbeite: \" + arg);\n}\n```\n\n## Hufige Anwendungsflle\n\n### 1. Einfache Argumentverarbeitung\n\nAuf erforderliches Argument prfen:\n\n```hemlock\nif (args.length < 2) {\n    print(\"Verwendung: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    print(\"Verarbeite Datei: \" + filename);\n    // ... Datei verarbeiten\n}\n```\n\n**Verwendung:**\n```bash\n./hemlock script.hml data.txt\n# Ausgabe: Verarbeite Datei: data.txt\n```\n\n### 2. Mehrere Argumente\n\n```hemlock\nif (args.length < 3) {\n    print(\"Verwendung: \" + args[0] + \" <input> <output>\");\n} else {\n    let input_file = args[1];\n    let output_file = args[2];\n\n    print(\"Eingabe: \" + input_file);\n    print(\"Ausgabe: \" + output_file);\n\n    // Dateien verarbeiten...\n}\n```\n\n**Verwendung:**\n```bash\n./hemlock convert.hml input.txt output.txt\n```\n\n### 3. Variable Anzahl von Argumenten\n\nAlle bereitgestellten Argumente verarbeiten:\n\n```hemlock\nif (args.length < 2) {\n    print(\"Verwendung: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Verarbeite \" + typeof(args.length - 1) + \" Dateien:\");\n\n    let i = 1;\n    while (i < args.length) {\n        print(\"  \" + args[i]);\n        process_file(args[i]);\n        i = i + 1;\n    }\n}\n```\n\n**Verwendung:**\n```bash\n./hemlock batch.hml file1.txt file2.txt file3.txt\n```\n\n### 4. Hilfenachricht\n\n```hemlock\nif (args.length < 2 || args[1] == \"--help\" || args[1] == \"-h\") {\n    print(\"Verwendung: \" + args[0] + \" [OPTIONEN] <file>\");\n    print(\"Optionen:\");\n    print(\"  -h, --help     Diese Hilfenachricht anzeigen\");\n    print(\"  -v, --verbose  Ausfhrliche Ausgabe aktivieren\");\n} else {\n    // Normal verarbeiten\n}\n```\n\n### 5. Argumentvalidierung\n\n```hemlock\nfn validate_file(filename: string): bool {\n    // Prfen, ob Datei existiert (Beispiel)\n    return filename != \"\";\n}\n\nif (args.length < 2) {\n    print(\"Fehler: Kein Dateiname angegeben\");\n} else if (!validate_file(args[1])) {\n    print(\"Fehler: Ungltige Datei: \" + args[1]);\n} else {\n    print(\"Verarbeite: \" + args[1]);\n}\n```\n\n## Argument-Parsing-Muster\n\n### Benannte Argumente (Flags)\n\nEinfaches Muster fr benannte Argumente:\n\n```hemlock\nlet verbose = false;\nlet output_file = \"\";\nlet input_file = \"\";\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\" || args[i] == \"-v\") {\n        verbose = true;\n    } else if (args[i] == \"--output\" || args[i] == \"-o\") {\n        i = i + 1;\n        if (i < args.length) {\n            output_file = args[i];\n        }\n    } else {\n        input_file = args[i];\n    }\n    i = i + 1;\n}\n\nif (verbose) {\n    print(\"Ausfhrlicher Modus aktiviert\");\n}\nprint(\"Eingabe: \" + input_file);\nprint(\"Ausgabe: \" + output_file);\n```\n\n**Verwendung:**\n```bash\n./hemlock script.hml --verbose --output out.txt input.txt\n./hemlock script.hml -v -o out.txt input.txt\n```\n\n### Boolean-Flags\n\n```hemlock\nlet debug = false;\nlet verbose = false;\nlet force = false;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--debug\") {\n        debug = true;\n    } else if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else if (args[i] == \"--force\") {\n        force = true;\n    }\n    i = i + 1;\n}\n```\n\n### Wert-Argumente\n\n```hemlock\nlet config_file = \"default.conf\";\nlet port = 8080;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--config\") {\n        i = i + 1;\n        if (i < args.length) {\n            config_file = args[i];\n        }\n    } else if (args[i] == \"--port\") {\n        i = i + 1;\n        if (i < args.length) {\n            port = 8080;  // Msste String zu Int parsen\n        }\n    }\n    i = i + 1;\n}\n```\n\n### Gemischte positionelle und benannte Argumente\n\n```hemlock\nlet input_file = \"\";\nlet output_file = \"\";\nlet verbose = false;\n\nlet i = 1;\nlet positional = [];\n\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else {\n        // Als positionelles Argument behandeln\n        positional.push(args[i]);\n    }\n    i = i + 1;\n}\n\n// Positionelle Argumente zuweisen\nif (positional.length > 0) {\n    input_file = positional[0];\n}\nif (positional.length > 1) {\n    output_file = positional[1];\n}\n```\n\n### Argument-Parser-Hilfsfunktion\n\n```hemlock\nfn parse_args() {\n    let options = {\n        verbose: false,\n        output: \"\",\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            options.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                options.output = args[i];\n            }\n        } else {\n            // Positionelles Argument\n            options.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return options;\n}\n\nlet opts = parse_args();\nprint(\"Verbose: \" + typeof(opts.verbose));\nprint(\"Ausgabe: \" + opts.output);\nprint(\"Dateien: \" + typeof(opts.files.length));\n```\n\n## Best Practices\n\n### 1. Immer Argumentanzahl prfen\n\n```hemlock\n// Gut\nif (args.length < 2) {\n    print(\"Verwendung: \" + args[0] + \" <file>\");\n} else {\n    process_file(args[1]);\n}\n\n// Schlecht - kann abstrzen wenn keine Argumente\nprocess_file(args[1]);  // Fehler wenn args.length == 1\n```\n\n### 2. Verwendungsinformationen bereitstellen\n\n```hemlock\nfn show_usage() {\n    print(\"Verwendung: \" + args[0] + \" [OPTIONEN] <file>\");\n    print(\"Optionen:\");\n    print(\"  -h, --help     Hilfe anzeigen\");\n    print(\"  -v, --verbose  Ausfhrliche Ausgabe\");\n}\n\nif (args.length < 2) {\n    show_usage();\n}\n```\n\n### 3. Argumente validieren\n\n```hemlock\nfn validate_args() {\n    if (args.length < 2) {\n        print(\"Fehler: Erforderliches Argument fehlt\");\n        return false;\n    }\n\n    if (args[1] == \"\") {\n        print(\"Fehler: Leeres Argument\");\n        return false;\n    }\n\n    return true;\n}\n\nif (!validate_args()) {\n    // exit oder Verwendung anzeigen\n}\n```\n\n### 4. Aussagekrftige Variablennamen verwenden\n\n```hemlock\n// Gut\nlet input_filename = args[1];\nlet output_filename = args[2];\nlet max_iterations = args[3];\n\n// Schlecht\nlet a = args[1];\nlet b = args[2];\nlet c = args[3];\n```\n\n### 5. Argumente mit Leerzeichen in Anfhrungszeichen behandeln\n\nShell behandelt dies automatisch:\n\n```bash\n./hemlock script.hml \"file with spaces.txt\"\n```\n\n```hemlock\nprint(args[1]);  // \"file with spaces.txt\"\n```\n\n### 6. Argumentobjekte erstellen\n\n```hemlock\nfn get_args() {\n    return {\n        script: args[0],\n        input: args[1],\n        output: args[2]\n    };\n}\n\nlet arguments = get_args();\nprint(\"Eingabe: \" + arguments.input);\n```\n\n## Vollstndige Beispiele\n\n### Beispiel 1: Dateiverarbeiter\n\n```hemlock\n// Verwendung: ./hemlock process.hml <input> <output>\n\nfn show_usage() {\n    print(\"Verwendung: \" + args[0] + \" <input_file> <output_file>\");\n}\n\nif (args.length < 3) {\n    show_usage();\n} else {\n    let input = args[1];\n    let output = args[2];\n\n    print(\"Verarbeite \" + input + \" -> \" + output);\n\n    // Dateien verarbeiten\n    let f_in = open(input, \"r\");\n    let f_out = open(output, \"w\");\n\n    try {\n        let content = f_in.read();\n        let processed = content.to_upper();  // Beispielverarbeitung\n        f_out.write(processed);\n\n        print(\"Fertig!\");\n    } finally {\n        f_in.close();\n        f_out.close();\n    }\n}\n```\n\n### Beispiel 2: Stapel-Dateiverarbeiter\n\n```hemlock\n// Verwendung: ./hemlock batch.hml <file1> <file2> <file3> ...\n\nif (args.length < 2) {\n    print(\"Verwendung: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Verarbeite \" + typeof(args.length - 1) + \" Dateien:\");\n\n    let i = 1;\n    while (i < args.length) {\n        let filename = args[i];\n        print(\"  Verarbeite: \" + filename);\n\n        try {\n            let f = open(filename, \"r\");\n            let content = f.read();\n            f.close();\n\n            // Inhalt verarbeiten...\n            print(\"    \" + typeof(content.length) + \" Bytes\");\n        } catch (e) {\n            print(\"    Fehler: \" + e);\n        }\n\n        i = i + 1;\n    }\n\n    print(\"Fertig!\");\n}\n```\n\n### Beispiel 3: Fortgeschrittener Argument-Parser\n\n```hemlock\n// Verwendung: ./hemlock app.hml [OPTIONEN] <files...>\n// Optionen:\n//   --verbose, -v     Ausfhrliche Ausgabe aktivieren\n//   --output, -o FILE Ausgabedatei festlegen\n//   --help, -h        Hilfe anzeigen\n\nfn parse_arguments() {\n    let config = {\n        verbose: false,\n        output: \"output.txt\",\n        help: false,\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            config.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                config.output = args[i];\n            } else {\n                print(\"Fehler: --output erfordert einen Wert\");\n            }\n        } else if (arg == \"--help\" || arg == \"-h\") {\n            config.help = true;\n        } else if (arg.starts_with(\"--\")) {\n            print(\"Fehler: Unbekannte Option: \" + arg);\n        } else {\n            config.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return config;\n}\n\nfn show_help() {\n    print(\"Verwendung: \" + args[0] + \" [OPTIONEN] <files...>\");\n    print(\"Optionen:\");\n    print(\"  --verbose, -v     Ausfhrliche Ausgabe aktivieren\");\n    print(\"  --output, -o FILE Ausgabedatei festlegen\");\n    print(\"  --help, -h        Diese Hilfe anzeigen\");\n}\n\nlet config = parse_arguments();\n\nif (config.help) {\n    show_help();\n} else if (config.files.length == 0) {\n    print(\"Fehler: Keine Eingabedateien angegeben\");\n    show_help();\n} else {\n    if (config.verbose) {\n        print(\"Ausfhrlicher Modus aktiviert\");\n        print(\"Ausgabedatei: \" + config.output);\n        print(\"Eingabedateien: \" + typeof(config.files.length));\n    }\n\n    // Dateien verarbeiten\n    for (let file in config.files) {\n        if (config.verbose) {\n            print(\"Verarbeite: \" + file);\n        }\n        // ... Datei verarbeiten\n    }\n}\n```\n\n### Beispiel 4: Konfigurationswerkzeug\n\n```hemlock\n// Verwendung: ./hemlock config.hml <action> [arguments]\n// Aktionen:\n//   get <key>\n//   set <key> <value>\n//   list\n\nfn show_usage() {\n    print(\"Verwendung: \" + args[0] + \" <action> [arguments]\");\n    print(\"Aktionen:\");\n    print(\"  get <key>         Konfigurationswert abrufen\");\n    print(\"  set <key> <value> Konfigurationswert setzen\");\n    print(\"  list              Alle Konfigurationen auflisten\");\n}\n\nif (args.length < 2) {\n    show_usage();\n} else {\n    let action = args[1];\n\n    if (action == \"get\") {\n        if (args.length < 3) {\n            print(\"Fehler: 'get' erfordert einen Schlssel\");\n        } else {\n            let key = args[2];\n            print(\"Hole: \" + key);\n            // ... aus Konfiguration holen\n        }\n    } else if (action == \"set\") {\n        if (args.length < 4) {\n            print(\"Fehler: 'set' erfordert Schlssel und Wert\");\n        } else {\n            let key = args[2];\n            let value = args[3];\n            print(\"Setze \" + key + \" = \" + value);\n            // ... in Konfiguration setzen\n        }\n    } else if (action == \"list\") {\n        print(\"Liste alle Konfigurationen auf:\");\n        // ... Konfiguration auflisten\n    } else {\n        print(\"Fehler: Unbekannte Aktion: \" + action);\n        show_usage();\n    }\n}\n```\n\n## Zusammenfassung\n\nHemlocks Kommandozeilenargument-Untersttzung bietet:\n\n-  Eingebautes `args`-Array global verfgbar\n-  Einfacher Array-basierter Zugriff auf Argumente\n-  Skriptname in `args[0]`\n-  Alle Argumente als Strings\n-  Array-Methoden verfgbar (.length, .slice, etc.)\n\nDenken Sie daran:\n- Immer `args.length` prfen, bevor auf Elemente zugegriffen wird\n- `args[0]` ist der Skriptname\n- Eigentliche Argumente beginnen bei `args[1]`\n- Alle Argumente sind Strings - bei Bedarf konvertieren\n- Verwendungsinformationen fr benutzerfreundliche Tools bereitstellen\n- Argumente vor der Verarbeitung validieren\n\nHufige Muster:\n- Einfache positionelle Argumente\n- Benannte/Flag-Argumente (--flag)\n- Wert-Argumente (--option wert)\n- Hilfenachrichten (--help)\n- Argumentvalidierung\n"}, "Fortgeschrittene Themen -> Profilerstellung": {"id": "advanced-profiling", "content": "# Profiling\n\nHemlock enthlt einen integrierten Profiler fr **CPU-Zeit-Analyse**, **Speicherverfolgung** und **Leak-Erkennung**. Der Profiler hilft dabei, Leistungsengpsse und Speicherprobleme in Ihren Programmen zu identifizieren.\n\n## Inhaltsverzeichnis\n\n- [berblick](#berblick)\n- [Schnellstart](#schnellstart)\n- [Profiling-Modi](#profiling-modi)\n- [Ausgabeformate](#ausgabeformate)\n- [Leak-Erkennung](#leak-erkennung)\n- [Berichte verstehen](#berichte-verstehen)\n- [Flamegraph-Generierung](#flamegraph-generierung)\n- [Best Practices](#best-practices)\n\n---\n\n## berblick\n\nDer Profiler wird ber den `profile`-Unterbefehl aufgerufen:\n\n```bash\nhemlock profile [OPTIONEN] <DATEI>\n```\n\n**Hauptfunktionen:**\n- **CPU-Profiling** - Zeit messen, die in jeder Funktion verbracht wird (Self-Time und Total-Time)\n- **Speicher-Profiling** - Alle Allokationen mit Quellcode-Positionen verfolgen\n- **Leak-Erkennung** - Speicher identifizieren, der nie freigegeben wurde\n- **Mehrere Ausgabeformate** - Text, JSON und Flamegraph-kompatible Ausgabe\n- **Pro-Funktion-Speicherstatistiken** - Sehen, welche Funktionen am meisten Speicher allozieren\n\n---\n\n## Schnellstart\n\n### CPU-Zeit profilen (Standard)\n\n```bash\nhemlock profile script.hml\n```\n\n### Speicherallokationen profilen\n\n```bash\nhemlock profile --memory script.hml\n```\n\n### Speicherlecks erkennen\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n### Flamegraph-Daten generieren\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\nflamegraph.pl profile.folded > profile.svg\n```\n\n---\n\n## Profiling-Modi\n\n### CPU-Profiling (Standard)\n\nMisst Zeit, die in jeder Funktion verbracht wird, unterscheidend zwischen:\n- **Self-Time** - Zeit, die mit der Ausfhrung des eigenen Codes der Funktion verbracht wird\n- **Total-Time** - Self-Time plus Zeit in aufgerufenen Funktionen\n\n```bash\nhemlock profile script.hml\nhemlock profile --cpu script.hml  # Explizit\n```\n\n**Beispielausgabe:**\n```\n=== Hemlock Profiler-Bericht ===\n\nGesamtzeit: 1.234ms\nAufgerufene Funktionen: 5 eindeutige\n\n--- Top 5 nach Self-Time ---\n\nFunktion                        Self      Total   Aufrufe\n--------                        ----      -----   -------\nexpensive_calc              0.892ms    0.892ms     100  (72.3%)\nprocess_data                0.234ms    1.126ms      10  (19.0%)\nhelper                      0.067ms    0.067ms     500  (5.4%)\nmain                        0.041ms    1.234ms       1  (3.3%)\n```\n\n---\n\n### Speicher-Profiling\n\nVerfolgt alle Speicherallokationen (`alloc`, `buffer`, `talloc`, `realloc`) mit Quellcode-Positionen.\n\n```bash\nhemlock profile --memory script.hml\n```\n\n**Beispielausgabe:**\n```\n=== Hemlock Profiler-Bericht ===\n\nGesamtzeit: 0.543ms\nAufgerufene Funktionen: 3 eindeutige\nGesamte Allokationen: 15 (4.2KB)\n\n--- Top 3 nach Self-Time ---\n\nFunktion                        Self      Total   Aufrufe      Allok      Anzahl\n--------                        ----      -----   -------      -----      ------\nallocator                   0.312ms    0.312ms      10      3.2KB         10  (57.5%)\nbuffer_ops                  0.156ms    0.156ms       5       1KB          5  (28.7%)\nmain                        0.075ms    0.543ms       1        0B          0  (13.8%)\n\n--- Top 10 Allokationsstellen ---\n\nPosition                                      Gesamt   Anzahl\n--------                                      ------   ------\nsrc/data.hml:42                               1.5KB        5\nsrc/data.hml:67                               1.0KB       10\nsrc/main.hml:15                               512B         1\n```\n\n---\n\n### Aufrufzhler-Modus\n\nMinimaler Overhead-Modus, der nur Funktionsaufrufe zhlt (keine Zeitmessung).\n\n```bash\nhemlock profile --calls script.hml\n```\n\n---\n\n## Ausgabeformate\n\n### Text (Standard)\n\nMenschenlesbare Zusammenfassung mit Tabellen.\n\n```bash\nhemlock profile script.hml\n```\n\n---\n\n### JSON\n\nMaschinenlesbares Format fr Integration mit anderen Werkzeugen.\n\n```bash\nhemlock profile --json script.hml\n```\n\n**Beispielausgabe:**\n```json\n{\n  \"total_time_ns\": 1234567,\n  \"function_count\": 5,\n  \"total_alloc_bytes\": 4096,\n  \"total_alloc_count\": 15,\n  \"functions\": [\n    {\n      \"name\": \"expensive_calc\",\n      \"source_file\": \"script.hml\",\n      \"line\": 10,\n      \"self_time_ns\": 892000,\n      \"total_time_ns\": 892000,\n      \"call_count\": 100,\n      \"alloc_bytes\": 0,\n      \"alloc_count\": 0\n    }\n  ],\n  \"alloc_sites\": [\n    {\n      \"source_file\": \"script.hml\",\n      \"line\": 42,\n      \"total_bytes\": 1536,\n      \"alloc_count\": 5,\n      \"current_bytes\": 0\n    }\n  ]\n}\n```\n\n---\n\n### Flamegraph\n\nGeneriert zusammengeklapptes Stack-Format, kompatibel mit [flamegraph.pl](https://github.com/brendangregg/FlameGraph).\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\n\n# SVG mit flamegraph.pl generieren\nflamegraph.pl profile.folded > profile.svg\n```\n\n**Beispiel zusammengeklappte Ausgabe:**\n```\nmain;process_data;expensive_calc 892\nmain;process_data;helper 67\nmain;process_data 234\nmain 41\n```\n\n---\n\n## Leak-Erkennung\n\nDas `--leaks`-Flag zeigt nur Allokationen, die nie freigegeben wurden, was das Identifizieren von Speicherlecks erleichtert.\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n**Beispielprogramm mit Lecks:**\n```hemlock\nfn leaky() {\n    let p1 = alloc(100);    // Leck - nie freigegeben\n    let p2 = alloc(200);    // OK - unten freigegeben\n    free(p2);\n}\n\nfn clean() {\n    let b = buffer(64);\n    free(b);                // Ordnungsgem freigegeben\n}\n\nleaky();\nclean();\n```\n\n**Ausgabe mit --leaks:**\n```\n=== Hemlock Profiler-Bericht ===\n\nGesamtzeit: 0.034ms\nAufgerufene Funktionen: 2 eindeutige\nGesamte Allokationen: 3 (388B)\n\n--- Top 2 nach Self-Time ---\n\nFunktion                        Self      Total   Aufrufe      Allok      Anzahl\n--------                        ----      -----   -------      -----      ------\nleaky                       0.021ms    0.021ms       1       300B          2  (61.8%)\nclean                       0.013ms    0.013ms       1        88B          1  (38.2%)\n\n--- Speicherlecks (1 Stelle) ---\n\nPosition                                     Leck        Gesamt    Anzahl\n--------                                     ----        ------    ------\nscript.hml:2                                 100B        100B         1\n```\n\nDer Leak-Bericht zeigt:\n- **Leck** - Bytes, die bei Programmende noch nicht freigegeben sind\n- **Gesamt** - Gesamte jemals an dieser Stelle allozierte Bytes\n- **Anzahl** - Anzahl der Allokationen an dieser Stelle\n\n---\n\n## Berichte verstehen\n\n### Funktionsstatistiken\n\n| Spalte | Beschreibung |\n|--------|--------------|\n| Funktion | Funktionsname |\n| Self | Zeit in Funktion ohne aufgerufene Funktionen |\n| Total | Zeit einschlielich aller aufgerufenen Funktionen |\n| Aufrufe | Anzahl der Funktionsaufrufe |\n| Allok | Gesamte von dieser Funktion allozierte Bytes |\n| Anzahl | Anzahl der Allokationen durch diese Funktion |\n| (%) | Prozentsatz der gesamten Programmzeit |\n\n### Allokationsstellen\n\n| Spalte | Beschreibung |\n|--------|--------------|\n| Position | Quelldatei und Zeilennummer |\n| Gesamt | Gesamte an dieser Position allozierte Bytes |\n| Anzahl | Anzahl der Allokationen |\n| Leck | Bytes, die bei Programmende noch alloziert sind (nur --leaks) |\n\n### Zeiteinheiten\n\nDer Profiler whlt automatisch geeignete Einheiten:\n- `ns` - Nanosekunden (< 1us)\n- `us` - Mikrosekunden (< 1ms)\n- `ms` - Millisekunden (< 1s)\n- `s` - Sekunden\n\n---\n\n## Befehlsreferenz\n\n```\nhemlock profile [OPTIONEN] <DATEI>\n\nOPTIONEN:\n    --cpu           CPU/Zeit-Profiling (Standard)\n    --memory        Speicherallokations-Profiling\n    --calls         Nur Aufrufzhlung (minimaler Overhead)\n    --leaks         Nur nicht freigegebene Allokationen zeigen (impliziert --memory)\n    --json          Ausgabe im JSON-Format\n    --flamegraph    Ausgabe im Flamegraph-kompatiblen Format\n    --top N         Top N Eintrge zeigen (Standard: 20)\n```\n\n---\n\n## Flamegraph-Generierung\n\nFlamegraphs visualisieren, wo Ihr Programm Zeit verbringt, wobei breitere Balken mehr verbrachte Zeit anzeigen.\n\n### Flamegraph generieren\n\n1. flamegraph.pl installieren:\n   ```bash\n   git clone https://github.com/brendangregg/FlameGraph\n   ```\n\n2. Ihr Programm profilen:\n   ```bash\n   hemlock profile --flamegraph script.hml > profile.folded\n   ```\n\n3. SVG generieren:\n   ```bash\n   ./FlameGraph/flamegraph.pl profile.folded > profile.svg\n   ```\n\n4. `profile.svg` im Browser ffnen fr eine interaktive Visualisierung.\n\n### Flamegraphs lesen\n\n- **X-Achse**: Prozentsatz der Gesamtzeit (Breite = Zeitanteil)\n- **Y-Achse**: Call-Stack-Tiefe (unten = Einstiegspunkt, oben = Blattfunktionen)\n- **Farbe**: Zufllig, nur zur visuellen Unterscheidung\n- **Klick**: In eine Funktion hineinzoomen, um ihre aufgerufenen Funktionen zu sehen\n\n---\n\n## Best Practices\n\n### 1. Reprsentative Workloads profilen\n\nMit realistischen Daten und Nutzungsmustern profilen. Kleine Testflle enthllen mglicherweise nicht die echten Engpsse.\n\n```bash\n# Gut: Mit produktionshnlichen Daten profilen\nhemlock profile --memory process_large_file.hml large_input.txt\n\n# Weniger ntzlich: Kleiner Testfall\nhemlock profile quick_test.hml\n```\n\n### 2. --leaks whrend der Entwicklung verwenden\n\nLeak-Erkennung regelmig ausfhren, um Speicherlecks frh zu finden:\n\n```bash\nhemlock profile --leaks my_program.hml\n```\n\n### 3. Vorher und Nachher vergleichen\n\nVor und nach Optimierungen profilen, um die Auswirkung zu messen:\n\n```bash\n# Vor Optimierung\nhemlock profile --json script.hml > before.json\n\n# Nach Optimierung\nhemlock profile --json script.hml > after.json\n\n# Ergebnisse vergleichen\n```\n\n### 4. --top fr groe Programme verwenden\n\nAusgabe begrenzen, um sich auf die wichtigsten Funktionen zu konzentrieren:\n\n```bash\nhemlock profile --top 10 large_program.hml\n```\n\n### 5. Mit Flamegraphs kombinieren\n\nFr komplexe Aufrufmuster bieten Flamegraphs eine bessere Visualisierung als Textausgabe:\n\n```bash\nhemlock profile --flamegraph complex_app.hml > app.folded\nflamegraph.pl app.folded > app.svg\n```\n\n---\n\n## Profiler-Overhead\n\nDer Profiler fgt etwas Overhead zur Programmausfhrung hinzu:\n\n| Modus | Overhead | Anwendungsfall |\n|-------|----------|----------------|\n| `--calls` | Minimal | Nur Funktionsaufrufe zhlen |\n| `--cpu` | Niedrig | Allgemeines Leistungs-Profiling |\n| `--memory` | Moderat | Speicheranalyse und Leak-Erkennung |\n\nFr die genauesten Ergebnisse mehrfach profilen und nach konsistenten Mustern suchen.\n\n---\n\n## Siehe auch\n\n- [Speicherverwaltung](#language-guide-memory) - Pointer und Buffer\n- [Speicher-API](#reference-memory-api) - alloc, free, buffer-Funktionen\n- [Async/Nebenlufigkeit](#advanced-async-concurrency) - Async-Code profilen\n"}, "Fortgeschrittene Themen -> Signalverarbeitung": {"id": "advanced-signals", "content": "# Signalbehandlung in Hemlock\n\nHemlock bietet **POSIX-Signalbehandlung** fr die Verwaltung von Systemsignalen wie SIGINT (Strg+C), SIGTERM und benutzerdefinierten Signalen. Dies ermglicht Low-Level-Prozesssteuerung und Inter-Prozess-Kommunikation.\n\n## Inhaltsverzeichnis\n\n- [berblick](#berblick)\n- [Signal-API](#signal-api)\n- [Signal-Konstanten](#signal-konstanten)\n- [Grundlegende Signalbehandlung](#grundlegende-signalbehandlung)\n- [Fortgeschrittene Muster](#fortgeschrittene-muster)\n- [Signal-Handler-Verhalten](#signal-handler-verhalten)\n- [Sicherheitsberlegungen](#sicherheitsberlegungen)\n- [Hufige Anwendungsflle](#hufige-anwendungsflle)\n- [Vollstndige Beispiele](#vollstndige-beispiele)\n\n## berblick\n\nSignalbehandlung ermglicht Programmen:\n- Auf Benutzerunterbrechungen reagieren (Strg+C, Strg+Z)\n- Graceful Shutdown implementieren\n- Beendigungsanfragen behandeln\n- Benutzerdefinierte Signale fr Inter-Prozess-Kommunikation verwenden\n- Alarm-/Timer-Mechanismen erstellen\n\n**Wichtig:** Signalbehandlung ist in Hemlocks Philosophie **inhrent unsicher**. Handler knnen jederzeit aufgerufen werden und die normale Ausfhrung unterbrechen. Der Benutzer ist fr die ordnungsgeme Synchronisation verantwortlich.\n\n## Signal-API\n\n### signal(signum, handler_fn)\n\nEinen Signal-Handler registrieren.\n\n**Parameter:**\n- `signum` (i32) - Signalnummer (Konstante wie SIGINT, SIGTERM)\n- `handler_fn` (function oder null) - Funktion, die aufgerufen wird wenn Signal empfangen wird, oder `null` um auf Standard zurckzusetzen\n\n**Rckgabe:** Der vorherige Handler (oder `null` wenn keiner)\n\n**Beispiel:**\n```hemlock\nfn my_handler(sig) {\n    print(\"Signal empfangen: \" + typeof(sig));\n}\n\nlet old_handler = signal(SIGINT, my_handler);\n```\n\n**Auf Standard zurcksetzen:**\n```hemlock\nsignal(SIGINT, null);  // SIGINT auf Standardverhalten zurcksetzen\n```\n\n### raise(signum)\n\nEin Signal an den aktuellen Prozess senden.\n\n**Parameter:**\n- `signum` (i32) - Zu sendende Signalnummer\n\n**Rckgabe:** `null`\n\n**Beispiel:**\n```hemlock\nraise(SIGUSR1);  // SIGUSR1-Handler auslsen\n```\n\n## Signal-Konstanten\n\nHemlock bietet Standard-POSIX-Signal-Konstanten als i32-Werte.\n\n### Unterbrechung & Beendigung\n\n| Konstante | Wert | Beschreibung | Hufiger Auslser |\n|-----------|------|--------------|-------------------|\n| `SIGINT` | 2 | Unterbrechung von Tastatur | Strg+C |\n| `SIGTERM` | 15 | Beendigungsanfrage | `kill`-Befehl |\n| `SIGQUIT` | 3 | Beenden von Tastatur | Strg+\\ |\n| `SIGHUP` | 1 | Hangup erkannt | Terminal geschlossen |\n| `SIGABRT` | 6 | Abort-Signal | `abort()`-Funktion |\n\n**Beispiele:**\n```hemlock\nsignal(SIGINT, handle_interrupt);   // Strg+C\nsignal(SIGTERM, handle_terminate);  // kill-Befehl\nsignal(SIGHUP, handle_hangup);      // Terminal schliet\n```\n\n### Benutzerdefinierte Signale\n\n| Konstante | Wert | Beschreibung | Anwendungsfall |\n|-----------|------|--------------|----------------|\n| `SIGUSR1` | 10 | Benutzerdefiniertes Signal 1 | Benutzerdefinierte IPC |\n| `SIGUSR2` | 12 | Benutzerdefiniertes Signal 2 | Benutzerdefinierte IPC |\n\n**Beispiele:**\n```hemlock\n// Fr benutzerdefinierte Kommunikation verwenden\nsignal(SIGUSR1, reload_config);\nsignal(SIGUSR2, rotate_logs);\n```\n\n### Prozesssteuerung\n\n| Konstante | Wert | Beschreibung | Hinweise |\n|-----------|------|--------------|----------|\n| `SIGALRM` | 14 | Alarm-Timer | Nach `alarm()` |\n| `SIGCHLD` | 17 | Kindprozess-Statusnderung | Prozessverwaltung |\n| `SIGCONT` | 18 | Fortsetzen wenn gestoppt | Nach SIGSTOP fortsetzen |\n| `SIGSTOP` | 19 | Prozess stoppen | **Kann nicht abgefangen werden** |\n| `SIGTSTP` | 20 | Terminal-Stop | Strg+Z |\n\n**Beispiele:**\n```hemlock\nsignal(SIGALRM, handle_timeout);\nsignal(SIGCHLD, handle_child_exit);\n```\n\n### I/O-Signale\n\n| Konstante | Wert | Beschreibung | Wann gesendet |\n|-----------|------|--------------|---------------|\n| `SIGPIPE` | 13 | Gebrochene Pipe | Schreiben in geschlossene Pipe |\n| `SIGTTIN` | 21 | Hintergrund-Lesen von Terminal | BG-Prozess liest TTY |\n| `SIGTTOU` | 22 | Hintergrund-Schreiben zu Terminal | BG-Prozess schreibt TTY |\n\n**Beispiele:**\n```hemlock\nsignal(SIGPIPE, handle_broken_pipe);\n```\n\n## Grundlegende Signalbehandlung\n\n### Strg+C abfangen\n\n```hemlock\nlet interrupted = false;\n\nfn handle_interrupt(sig) {\n    print(\"SIGINT empfangen!\");\n    interrupted = true;\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Programm luft weiter...\n// Benutzer drckt Strg+C -> handle_interrupt() wird aufgerufen\n\nwhile (!interrupted) {\n    // Arbeit erledigen...\n}\n\nprint(\"Beende wegen Unterbrechung\");\n```\n\n### Handler-Funktionssignatur\n\nSignal-Handler empfangen ein Argument: die Signalnummer (i32)\n\n```hemlock\nfn my_handler(signum) {\n    print(\"Signal empfangen: \" + typeof(signum));\n    // signum enthlt die Signalnummer (z.B. 2 fr SIGINT)\n\n    if (signum == SIGINT) {\n        print(\"Das ist SIGINT\");\n    }\n}\n\nsignal(SIGINT, my_handler);\nsignal(SIGTERM, my_handler);  // Gleicher Handler fr mehrere Signale\n```\n\n### Mehrere Signal-Handler\n\nVerschiedene Handler fr verschiedene Signale:\n\n```hemlock\nfn handle_int(sig) {\n    print(\"SIGINT empfangen\");\n}\n\nfn handle_term(sig) {\n    print(\"SIGTERM empfangen\");\n}\n\nfn handle_usr1(sig) {\n    print(\"SIGUSR1 empfangen\");\n}\n\nsignal(SIGINT, handle_int);\nsignal(SIGTERM, handle_term);\nsignal(SIGUSR1, handle_usr1);\n```\n\n### Auf Standardverhalten zurcksetzen\n\n`null` als Handler bergeben, um auf Standardverhalten zurckzusetzen:\n\n```hemlock\n// Benutzerdefinierten Handler registrieren\nsignal(SIGINT, my_handler);\n\n// Spter, auf Standard zurcksetzen (bei SIGINT beenden)\nsignal(SIGINT, null);\n```\n\n### Signale manuell auslsen\n\nSignale an den eigenen Prozess senden:\n\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\n// Handler manuell auslsen\nraise(SIGUSR1);\nraise(SIGUSR1);\n\nprint(count);  // 2\n```\n\n## Fortgeschrittene Muster\n\n### Graceful-Shutdown-Muster\n\nHufiges Muster fr Bereinigung bei Beendigung:\n\n```hemlock\nlet should_exit = false;\n\nfn handle_shutdown(sig) {\n    print(\"Fahre graceful herunter...\");\n    should_exit = true;\n}\n\nsignal(SIGINT, handle_shutdown);\nsignal(SIGTERM, handle_shutdown);\n\n// Hauptschleife\nwhile (!should_exit) {\n    // Arbeit erledigen...\n    // should_exit-Flag regelmig prfen\n}\n\nprint(\"Bereinigung abgeschlossen\");\n```\n\n### Signal-Zhler\n\nAnzahl empfangener Signale verfolgen:\n\n```hemlock\nlet signal_count = 0;\n\nfn count_signals(sig) {\n    signal_count = signal_count + 1;\n    print(typeof(signal_count) + \" Signale empfangen\");\n}\n\nsignal(SIGUSR1, count_signals);\n\n// Spter...\nprint(\"Gesamte Signale: \" + typeof(signal_count));\n```\n\n### Konfiguration bei Signal neu laden\n\n```hemlock\nlet config = load_config();\n\nfn reload_config(sig) {\n    print(\"Lade Konfiguration neu...\");\n    config = load_config();\n    print(\"Konfiguration neu geladen\");\n}\n\nsignal(SIGHUP, reload_config);  // Bei SIGHUP neu laden\n\n// SIGHUP an Prozess senden, um Konfiguration neu zu laden\n// Von Shell: kill -HUP <pid>\n```\n\n### Timeout mit SIGALRM\n\n```hemlock\nlet timed_out = false;\n\nfn handle_alarm(sig) {\n    print(\"Timeout!\");\n    timed_out = true;\n}\n\nsignal(SIGALRM, handle_alarm);\n\n// Alarm setzen (noch nicht in Hemlock implementiert, nur Beispiel)\n// alarm(5);  // 5 Sekunden Timeout\n\nwhile (!timed_out) {\n    // Arbeit mit Timeout erledigen\n}\n```\n\n### Signal-basierte Zustandsmaschine\n\n```hemlock\nlet state = 0;\n\nfn next_state(sig) {\n    state = (state + 1) % 3;\n    print(\"Zustand: \" + typeof(state));\n}\n\nfn prev_state(sig) {\n    state = (state - 1 + 3) % 3;\n    print(\"Zustand: \" + typeof(state));\n}\n\nsignal(SIGUSR1, next_state);  // Zustand vorwrts\nsignal(SIGUSR2, prev_state);  // Zustand zurck\n\n// Zustandsmaschine steuern:\n// kill -USR1 <pid>  # Nchster Zustand\n// kill -USR2 <pid>  # Vorheriger Zustand\n```\n\n## Signal-Handler-Verhalten\n\n### Wichtige Hinweise\n\n**Handler-Ausfhrung:**\n- Handler werden **synchron** aufgerufen, wenn das Signal empfangen wird\n- Handler werden im aktuellen Prozesskontext ausgefhrt\n- Signal-Handler teilen die Closure-Umgebung der Funktion, in der sie definiert wurden\n- Handler knnen auf uere Scope-Variablen zugreifen und diese modifizieren (wie Globals oder erfasste Variablen)\n\n**Best Practices:**\n- Handler einfach und schnell halten - lange Operationen vermeiden\n- Flags setzen statt komplexe Logik auszufhren\n- Funktionen vermeiden, die mglicherweise Locks nehmen\n- Bewusst sein, dass Handler jede Operation unterbrechen knnen\n\n### Welche Signale abgefangen werden knnen\n\n**Kann abfangen und behandeln:**\n- SIGINT, SIGTERM, SIGUSR1, SIGUSR2, SIGHUP, SIGQUIT\n- SIGALRM, SIGCHLD, SIGCONT, SIGTSTP\n- SIGPIPE, SIGTTIN, SIGTTOU\n- SIGABRT (aber Programm wird nach Handler-Rckkehr abbrechen)\n\n**Kann nicht abfangen:**\n- `SIGKILL` (9) - Beendet Prozess immer\n- `SIGSTOP` (19) - Stoppt Prozess immer\n\n**Systemabhngig:**\n- Einige Signale haben Standardverhalten, die je nach System unterschiedlich sein knnen\n- Prfen Sie die Signal-Dokumentation Ihrer Plattform fr Details\n\n### Handler-Einschrnkungen\n\n```hemlock\nfn complex_handler(sig) {\n    // Vermeiden Sie diese in Signal-Handlern:\n\n    //  Lang laufende Operationen\n    // process_large_file();\n\n    //  Blockierende I/O\n    // let f = open(\"log.txt\", \"a\");\n    // f.write(\"Signal empfangen\\n\");\n\n    //  Komplexe Zustandsnderungen\n    // rebuild_entire_data_structure();\n\n    //  Einfaches Flag-Setzen ist sicher\n    let should_stop = true;\n\n    //  Einfache Zhler-Updates sind normalerweise sicher\n    let signal_count = signal_count + 1;\n}\n```\n\n## Sicherheitsberlegungen\n\nSignalbehandlung ist in Hemlocks Philosophie **inhrent unsicher**.\n\n### Race Conditions\n\nHandler knnen jederzeit aufgerufen werden und normale Ausfhrung unterbrechen:\n\n```hemlock\nlet counter = 0;\n\nfn increment(sig) {\n    counter = counter + 1;  // Race Condition wenn whrend counter-Update aufgerufen\n}\n\nsignal(SIGUSR1, increment);\n\n// Hauptcode modifiziert auch counter\ncounter = counter + 1;  // Knnte von Signal-Handler unterbrochen werden\n```\n\n**Problem:** Wenn Signal ankommt whrend Hauptcode `counter` aktualisiert, ist das Ergebnis unvorhersehbar.\n\n### Async-Signal-Sicherheit\n\nHemlock garantiert **keine** Async-Signal-Sicherheit:\n- Handler knnen jeden Hemlock-Code aufrufen (anders als Cs eingeschrnkte async-signal-sichere Funktionen)\n- Dies bietet Flexibilitt, erfordert aber Benutzer-Vorsicht\n- Race Conditions sind mglich, wenn Handler gemeinsamen Zustand modifiziert\n\n### Best Practices fr sichere Signalbehandlung\n\n**1. Atomare Flags verwenden**\n\nEinfache Boolean-Zuweisungen sind im Allgemeinen sicher:\n\n```hemlock\nlet should_exit = false;\n\nfn handler(sig) {\n    should_exit = true;  // Einfache Zuweisung ist sicher\n}\n\nsignal(SIGINT, handler);\n\nwhile (!should_exit) {\n    // Arbeit...\n}\n```\n\n**2. Gemeinsamen Zustand minimieren**\n\n```hemlock\nlet interrupt_count = 0;\n\nfn handler(sig) {\n    // Nur diese eine Variable modifizieren\n    interrupt_count = interrupt_count + 1;\n}\n```\n\n**3. Komplexe Operationen aufschieben**\n\n```hemlock\nlet pending_reload = false;\n\nfn signal_reload(sig) {\n    pending_reload = true;  // Nur Flag setzen\n}\n\nsignal(SIGHUP, signal_reload);\n\n// In Hauptschleife:\nwhile (true) {\n    if (pending_reload) {\n        reload_config();  // Komplexe Arbeit hier erledigen\n        pending_reload = false;\n    }\n\n    // Normale Arbeit...\n}\n```\n\n**4. Wiedereintrittsprobleme vermeiden**\n\n```hemlock\nlet in_critical_section = false;\nlet data = [];\n\nfn careful_handler(sig) {\n    if (in_critical_section) {\n        // Daten nicht modifizieren whrend Hauptcode sie verwendet\n        return;\n    }\n    // Sicher fortzufahren\n}\n```\n\n## Hufige Anwendungsflle\n\n### 1. Graceful Server-Shutdown\n\n```hemlock\nlet running = true;\n\nfn shutdown(sig) {\n    print(\"Shutdown-Signal empfangen\");\n    running = false;\n}\n\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// Server-Hauptschleife\nwhile (running) {\n    handle_client_request();\n}\n\ncleanup_resources();\nprint(\"Server gestoppt\");\n```\n\n### 2. Konfiguration neu laden (ohne Neustart)\n\n```hemlock\nlet config = load_config(\"app.conf\");\nlet reload_needed = false;\n\nfn trigger_reload(sig) {\n    reload_needed = true;\n}\n\nsignal(SIGHUP, trigger_reload);\n\nwhile (true) {\n    if (reload_needed) {\n        print(\"Lade Konfiguration neu...\");\n        config = load_config(\"app.conf\");\n        reload_needed = false;\n    }\n\n    // config verwenden...\n}\n```\n\n### 3. Log-Rotation\n\n```hemlock\nlet log_file = open(\"app.log\", \"a\");\nlet rotate_needed = false;\n\nfn trigger_rotate(sig) {\n    rotate_needed = true;\n}\n\nsignal(SIGUSR1, trigger_rotate);\n\nwhile (true) {\n    if (rotate_needed) {\n        log_file.close();\n        // Altes Log umbenennen, neues ffnen\n        exec(\"mv app.log app.log.old\");\n        log_file = open(\"app.log\", \"a\");\n        rotate_needed = false;\n    }\n\n    // Normales Logging...\n    log_file.write(\"Log-Eintrag\\n\");\n}\n```\n\n### 4. Statusberichterstattung\n\n```hemlock\nlet requests_handled = 0;\n\nfn report_status(sig) {\n    print(\"Status: \" + typeof(requests_handled) + \" Anfragen bearbeitet\");\n}\n\nsignal(SIGUSR1, report_status);\n\nwhile (true) {\n    handle_request();\n    requests_handled = requests_handled + 1;\n}\n\n// Von Shell: kill -USR1 <pid>\n```\n\n### 5. Debug-Modus umschalten\n\n```hemlock\nlet debug_mode = false;\n\nfn toggle_debug(sig) {\n    debug_mode = !debug_mode;\n    if (debug_mode) {\n        print(\"Debug-Modus: AN\");\n    } else {\n        print(\"Debug-Modus: AUS\");\n    }\n}\n\nsignal(SIGUSR2, toggle_debug);\n\n// Von Shell: kill -USR2 <pid> zum Umschalten\n```\n\n## Vollstndige Beispiele\n\n### Beispiel 1: Unterbrechungs-Handler mit Bereinigung\n\n```hemlock\nlet running = true;\nlet signal_count = 0;\n\nfn handle_signal(signum) {\n    signal_count = signal_count + 1;\n\n    if (signum == SIGINT) {\n        print(\"Unterbrechung erkannt (Strg+C)\");\n        running = false;\n    }\n\n    if (signum == SIGUSR1) {\n        print(\"Benutzersignal 1 empfangen\");\n    }\n}\n\n// Handler registrieren\nsignal(SIGINT, handle_signal);\nsignal(SIGUSR1, handle_signal);\n\n// Arbeit simulieren\nlet i = 0;\nwhile (running && i < 100) {\n    print(\"Arbeite... \" + typeof(i));\n\n    // SIGUSR1 alle 10 Iterationen auslsen\n    if (i == 10 || i == 20) {\n        raise(SIGUSR1);\n    }\n\n    i = i + 1;\n}\n\nprint(\"Gesamte empfangene Signale: \" + typeof(signal_count));\n```\n\n### Beispiel 2: Multi-Signal-Zustandsmaschine\n\n```hemlock\nlet state = \"idle\";\nlet request_count = 0;\n\nfn start_processing(sig) {\n    state = \"processing\";\n    print(\"Zustand: \" + state);\n}\n\nfn stop_processing(sig) {\n    state = \"idle\";\n    print(\"Zustand: \" + state);\n}\n\nfn report_stats(sig) {\n    print(\"Zustand: \" + state);\n    print(\"Anfragen: \" + typeof(request_count));\n}\n\nsignal(SIGUSR1, start_processing);\nsignal(SIGUSR2, stop_processing);\nsignal(SIGHUP, report_stats);\n\nwhile (true) {\n    if (state == \"processing\") {\n        // Arbeit erledigen\n        request_count = request_count + 1;\n    }\n\n    // Bei jeder Iteration prfen...\n}\n```\n\n### Beispiel 3: Worker-Pool-Controller\n\n```hemlock\nlet worker_count = 4;\nlet should_exit = false;\n\nfn increase_workers(sig) {\n    worker_count = worker_count + 1;\n    print(\"Worker: \" + typeof(worker_count));\n}\n\nfn decrease_workers(sig) {\n    if (worker_count > 1) {\n        worker_count = worker_count - 1;\n    }\n    print(\"Worker: \" + typeof(worker_count));\n}\n\nfn shutdown(sig) {\n    print(\"Fahre herunter...\");\n    should_exit = true;\n}\n\nsignal(SIGUSR1, increase_workers);\nsignal(SIGUSR2, decrease_workers);\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// Hauptschleife passt Worker-Pool basierend auf worker_count an\nwhile (!should_exit) {\n    // Worker basierend auf worker_count verwalten\n    // ...\n}\n```\n\n### Beispiel 4: Timeout-Muster\n\n```hemlock\nlet operation_complete = false;\nlet timed_out = false;\n\nfn timeout_handler(sig) {\n    timed_out = true;\n}\n\nsignal(SIGALRM, timeout_handler);\n\n// Lange Operation starten\nasync fn long_operation() {\n    // ... Arbeit\n    operation_complete = true;\n}\n\nlet task = spawn(long_operation);\n\n// Mit Timeout warten (manuelle Prfung)\nlet elapsed = 0;\nwhile (!operation_complete && elapsed < 1000) {\n    // Schlafen oder prfen\n    elapsed = elapsed + 1;\n}\n\nif (!operation_complete) {\n    print(\"Operation hat Timeout erreicht\");\n    detach(task);  // Warten aufgeben\n} else {\n    join(task);\n    print(\"Operation abgeschlossen\");\n}\n```\n\n## Signal-Handler debuggen\n\n### Diagnose-Prints hinzufgen\n\n```hemlock\nfn debug_handler(sig) {\n    print(\"Handler aufgerufen fr Signal: \" + typeof(sig));\n    print(\"Stack: (noch nicht verfgbar)\");\n\n    // Ihre Handler-Logik...\n}\n\nsignal(SIGINT, debug_handler);\n```\n\n### Signal-Aufrufe zhlen\n\n```hemlock\nlet handler_calls = 0;\n\nfn counting_handler(sig) {\n    handler_calls = handler_calls + 1;\n    print(\"Handler-Aufruf #\" + typeof(handler_calls));\n\n    // Ihre Handler-Logik...\n}\n```\n\n### Mit raise() testen\n\n```hemlock\nfn test_handler(sig) {\n    print(\"Test-Signal empfangen: \" + typeof(sig));\n}\n\nsignal(SIGUSR1, test_handler);\n\n// Durch manuelles Auslsen testen\nraise(SIGUSR1);\nprint(\"Handler sollte aufgerufen worden sein\");\n```\n\n## Zusammenfassung\n\nHemlocks Signalbehandlung bietet:\n\n-  POSIX-Signalbehandlung fr Low-Level-Prozesssteuerung\n-  15 Standard-Signal-Konstanten\n-  Einfache signal()- und raise()-API\n-  Flexible Handler-Funktionen mit Closure-Untersttzung\n-  Mehrere Signale knnen Handler teilen\n\nDenken Sie daran:\n- Signalbehandlung ist inhrent unsicher - mit Vorsicht verwenden\n- Handler einfach und schnell halten\n- Flags fr Zustandsnderungen verwenden, nicht komplexe Operationen\n- Handler knnen Ausfhrung jederzeit unterbrechen\n- SIGKILL oder SIGSTOP knnen nicht abgefangen werden\n- Handler grndlich mit raise() testen\n\nHufige Muster:\n- Graceful Shutdown (SIGINT, SIGTERM)\n- Konfiguration neu laden (SIGHUP)\n- Log-Rotation (SIGUSR1)\n- Statusberichterstattung (SIGUSR1/SIGUSR2)\n- Debug-Modus umschalten (SIGUSR2)\n"}, "API-Referenz -> Array-API": {"id": "reference-array-api", "content": "# Array-API-Referenz\n\nVollstndige Referenz fr Hemlocks Array-Typ und alle 18 Array-Methoden.\n\n---\n\n## bersicht\n\nArrays in Hemlock sind **dynamische, heap-allokierte** Sequenzen, die gemischte Typen enthalten knnen. Sie bieten umfassende Methoden zur Datenmanipulation und -verarbeitung.\n\n**Hauptmerkmale:**\n- Dynamische Grenanpassung (automatisches Wachstum)\n- Nullbasierte Indizierung\n- Gemischte Typen erlaubt\n- 18 eingebaute Methoden\n- Heap-allokiert mit Kapazitaetsverfolgung\n\n---\n\n## Array-Typ\n\n**Typ:** `array`\n\n**Eigenschaften:**\n- `.length` - Anzahl der Elemente (i32)\n\n**Literal-Syntax:** Eckige Klammern `[elem1, elem2, ...]`\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);     // 5\n\n// Gemischte Typen\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.length);   // 4\n\n// Leeres Array\nlet empty = [];\nprint(empty.length);   // 0\n```\n\n---\n\n## Indizierung\n\nArrays untersttzen nullbasierte Indizierung mit `[]`:\n\n**Lesezugriff:**\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);         // 10\nprint(arr[1]);         // 20\nprint(arr[2]);         // 30\n```\n\n**Schreibzugriff:**\n```hemlock\nlet arr = [10, 20, 30];\narr[0] = 99;\narr[1] = 88;\nprint(arr);            // [99, 88, 30]\n```\n\n**Hinweis:** Direkter Indexzugriff hat keine Grenzenprfung. Verwenden Sie Methoden fr Sicherheit.\n\n---\n\n## Array-Eigenschaften\n\n### .length\n\nGibt die Anzahl der Elemente im Array zurck.\n\n**Typ:** `i32`\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr.length);     // 3\n\nlet empty = [];\nprint(empty.length);   // 0\n\n// Lnge ndert sich dynamisch\narr.push(4);\nprint(arr.length);     // 4\n\narr.pop();\nprint(arr.length);     // 3\n```\n\n---\n\n## Array-Methoden\n\n### Stack-Operationen\n\n#### push\n\nFuegt ein Element am Ende des Arrays hinzu.\n\n**Signatur:**\n```hemlock\narray.push(value: any): null\n```\n\n**Parameter:**\n- `value` - Element zum Hinzufgen\n\n**Rckgabe:** `null`\n\n**Mutiert:** Ja (modifiziert Array direkt)\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\narr.push(\"hello\");     // [1, 2, 3, 4, 5, \"hello\"]\n```\n\n---\n\n#### pop\n\nEntfernt und gibt das letzte Element zurck.\n\n**Signatur:**\n```hemlock\narray.pop(): any\n```\n\n**Rckgabe:** Letztes Element (aus Array entfernt)\n\n**Mutiert:** Ja (modifiziert Array direkt)\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3];\nlet last = arr.pop();  // 3\nprint(arr);            // [1, 2]\n\nlet last2 = arr.pop(); // 2\nprint(arr);            // [1]\n```\n\n**Fehler:** Laufzeitfehler wenn Array leer ist.\n\n---\n\n### Warteschlangen-Operationen\n\n#### shift\n\nEntfernt und gibt das erste Element zurck.\n\n**Signatur:**\n```hemlock\narray.shift(): any\n```\n\n**Rckgabe:** Erstes Element (aus Array entfernt)\n\n**Mutiert:** Ja (modifiziert Array direkt)\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();  // 1\nprint(arr);               // [2, 3]\n\nlet first2 = arr.shift(); // 2\nprint(arr);               // [3]\n```\n\n**Fehler:** Laufzeitfehler wenn Array leer ist.\n\n---\n\n#### unshift\n\nFuegt ein Element am Anfang des Arrays hinzu.\n\n**Signatur:**\n```hemlock\narray.unshift(value: any): null\n```\n\n**Parameter:**\n- `value` - Element zum Hinzufgen\n\n**Rckgabe:** `null`\n\n**Mutiert:** Ja (modifiziert Array direkt)\n\n**Beispiele:**\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);        // [1, 2, 3]\narr.unshift(0);        // [0, 1, 2, 3]\n```\n\n---\n\n### Einfuegen & Entfernen\n\n#### insert\n\nFuegt ein Element an einem bestimmten Index ein.\n\n**Signatur:**\n```hemlock\narray.insert(index: i32, value: any): null\n```\n\n**Parameter:**\n- `index` - Position zum Einfuegen (nullbasiert)\n- `value` - Element zum Einfuegen\n\n**Rckgabe:** `null`\n\n**Mutiert:** Ja (modifiziert Array direkt)\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // [1, 2, 3, 4, 5]\n\nlet arr2 = [1, 3];\narr2.insert(1, 2);     // [1, 2, 3]\n\n// Am Ende einfgen\narr2.insert(arr2.length, 4);  // [1, 2, 3, 4]\n```\n\n**Verhalten:** Verschiebt Elemente ab dem Index nach rechts.\n\n---\n\n#### remove\n\nEntfernt und gibt das Element am Index zurck.\n\n**Signatur:**\n```hemlock\narray.remove(index: i32): any\n```\n\n**Parameter:**\n- `index` - Position zum Entfernen (nullbasiert)\n\n**Rckgabe:** Entferntes Element\n\n**Mutiert:** Ja (modifiziert Array direkt)\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(0);  // 1\nprint(arr);                   // [2, 3, 4, 5]\n\nlet removed2 = arr.remove(2); // 4\nprint(arr);                   // [2, 3, 5]\n```\n\n**Verhalten:** Verschiebt Elemente nach dem Index nach links.\n\n**Fehler:** Laufzeitfehler wenn Index auerhalb der Grenzen.\n\n---\n\n### Suchen & Finden\n\n#### find\n\nFindet das erste Vorkommen eines Wertes.\n\n**Signatur:**\n```hemlock\narray.find(value: any): i32\n```\n\n**Parameter:**\n- `value` - Zu suchender Wert\n\n**Rckgabe:** Index des ersten Vorkommens, oder `-1` wenn nicht gefunden\n\n**Beispiele:**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2\nlet idx2 = arr.find(99);     // -1 (nicht gefunden)\n\n// Erstes Duplikat finden\nlet arr2 = [1, 2, 3, 2, 4];\nlet idx3 = arr2.find(2);     // 1 (erstes Vorkommen)\n```\n\n**Vergleich:** Verwendet Wertgleichheit fr Primitive und Strings.\n\n---\n\n#### contains\n\nPrueft ob das Array einen Wert enthlt.\n\n**Signatur:**\n```hemlock\narray.contains(value: any): bool\n```\n\n**Parameter:**\n- `value` - Zu suchender Wert\n\n**Rckgabe:** `true` wenn gefunden, `false` sonst\n\n**Beispiele:**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n\n// Funktioniert mit Strings\nlet words = [\"hello\", \"world\"];\nlet has3 = words.contains(\"hello\");  // true\n```\n\n---\n\n### Slicing & Extraktion\n\n#### slice\n\nExtrahiert ein Teilarray nach Bereich (Ende exklusiv).\n\n**Signatur:**\n```hemlock\narray.slice(start: i32, end: i32): array\n```\n\n**Parameter:**\n- `start` - Startindex (nullbasiert, inklusiv)\n- `end` - Endindex (exklusiv)\n\n**Rckgabe:** Neues Array mit Elementen von [start, end)\n\n**Mutiert:** Nein (gibt neues Array zurck)\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4]\nlet first_three = arr.slice(0, 3);  // [1, 2, 3]\nlet last_two = arr.slice(3, 5);     // [4, 5]\n\n// Leerer Slice\nlet empty = arr.slice(2, 2); // []\n```\n\n---\n\n#### first\n\nGibt das erste Element zurck ohne es zu entfernen.\n\n**Signatur:**\n```hemlock\narray.first(): any\n```\n\n**Rckgabe:** Erstes Element\n\n**Mutiert:** Nein\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1\nprint(arr);                  // [1, 2, 3] (unverndert)\n```\n\n**Fehler:** Laufzeitfehler wenn Array leer ist.\n\n---\n\n#### last\n\nGibt das letzte Element zurck ohne es zu entfernen.\n\n**Signatur:**\n```hemlock\narray.last(): any\n```\n\n**Rckgabe:** Letztes Element\n\n**Mutiert:** Nein\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3\nprint(arr);                  // [1, 2, 3] (unverndert)\n```\n\n**Fehler:** Laufzeitfehler wenn Array leer ist.\n\n---\n\n### Array-Manipulation\n\n#### reverse\n\nKehrt das Array an Ort und Stelle um.\n\n**Signatur:**\n```hemlock\narray.reverse(): null\n```\n\n**Rckgabe:** `null`\n\n**Mutiert:** Ja (modifiziert Array direkt)\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\nprint(arr);                  // [5, 4, 3, 2, 1]\n\nlet words = [\"hello\", \"world\"];\nwords.reverse();             // [\"world\", \"hello\"]\n```\n\n---\n\n#### clear\n\nEntfernt alle Elemente aus dem Array.\n\n**Signatur:**\n```hemlock\narray.clear(): null\n```\n\n**Rckgabe:** `null`\n\n**Mutiert:** Ja (modifiziert Array direkt)\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();\nprint(arr);                  // []\nprint(arr.length);           // 0\n```\n\n---\n\n### Array-Kombination\n\n#### concat\n\nVerkettet mit einem anderen Array.\n\n**Signatur:**\n```hemlock\narray.concat(other: array): array\n```\n\n**Parameter:**\n- `other` - Array zum Verketten\n\n**Rckgabe:** Neues Array mit Elementen aus beiden Arrays\n\n**Mutiert:** Nein (gibt neues Array zurck)\n\n**Beispiele:**\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]\nprint(a);                    // [1, 2, 3] (unverndert)\nprint(b);                    // [4, 5, 6] (unverndert)\n\n// Verkettungen verketten\nlet c = [7, 8];\nlet all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n---\n\n### Funktionale Operationen\n\n#### map\n\nTransformiert jedes Element mit einer Callback-Funktion.\n\n**Signatur:**\n```hemlock\narray.map(callback: fn): array\n```\n\n**Parameter:**\n- `callback` - Funktion die ein Element nimmt und transformierten Wert zurckgibt\n\n**Rckgabe:** Neues Array mit transformierten Elementen\n\n**Mutiert:** Nein (gibt neues Array zurck)\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet doubled = arr.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\nlet names = [\"alice\", \"bob\"];\nlet upper = names.map(fn(s) { return s.to_upper(); });\nprint(upper);  // [\"ALICE\", \"BOB\"]\n```\n\n---\n\n#### filter\n\nWaehlt Elemente aus die einem Praedikat entsprechen.\n\n**Signatur:**\n```hemlock\narray.filter(predicate: fn): array\n```\n\n**Parameter:**\n- `predicate` - Funktion die ein Element nimmt und bool zurckgibt\n\n**Rckgabe:** Neues Array mit Elementen wo Praedikat true zurueckgab\n\n**Mutiert:** Nein (gibt neues Array zurck)\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6];\nlet evens = arr.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4, 6]\n\nlet words = [\"hello\", \"hi\", \"hey\", \"goodbye\"];\nlet short = words.filter(fn(s) { return s.length < 4; });\nprint(short);  // [\"hi\", \"hey\"]\n```\n\n---\n\n#### reduce\n\nReduziert Array auf einen einzelnen Wert mit Akkumulator.\n\n**Signatur:**\n```hemlock\narray.reduce(callback: fn, initial: any): any\n```\n\n**Parameter:**\n- `callback` - Funktion die (Akkumulator, Element) nimmt und neuen Akkumulator zurckgibt\n- `initial` - Startwert fr den Akkumulator\n\n**Rckgabe:** Endgueltiger akkumulierter Wert\n\n**Mutiert:** Nein\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sum = arr.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\nlet product = arr.reduce(fn(acc, x) { return acc * x; }, 1);\nprint(product);  // 120\n\n// Maximalwert finden\nlet max = arr.reduce(fn(acc, x) {\n    if (x > acc) { return x; }\n    return acc;\n}, arr[0]);\nprint(max);  // 5\n```\n\n---\n\n### String-Konvertierung\n\n#### join\n\nVerbindet Elemente zu einem String mit Trennzeichen.\n\n**Signatur:**\n```hemlock\narray.join(delimiter: string): string\n```\n\n**Parameter:**\n- `delimiter` - String der zwischen Elementen platziert wird\n\n**Rckgabe:** String mit allen verbundenen Elementen\n\n**Beispiele:**\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Funktioniert mit gemischten Typen\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n\n// Leeres Trennzeichen\nlet arr = [\"a\", \"b\", \"c\"];\nlet s = arr.join(\"\");          // \"abc\"\n```\n\n**Verhalten:** Konvertiert automatisch alle Elemente zu Strings.\n\n---\n\n## Methoden-Verkettung\n\nArray-Methoden knnen fr praegnante Operationen verkettet werden:\n\n**Beispiele:**\n```hemlock\n// slice und join verketten\nlet result = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\n// concat und slice verketten\nlet combined = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);    // [3, 4, 5]\n\n// Komplexe Verkettung\nlet words = [\"hello\", \"world\", \"foo\", \"bar\"];\nlet result2 = words\n    .slice(0, 3)\n    .concat([\"baz\"])\n    .join(\"-\");      // \"hello-world-foo-baz\"\n```\n\n---\n\n## Vollstndige Methodenuebersicht\n\n### Mutierende Methoden\n\nMethoden die das Array direkt modifizieren:\n\n| Methode    | Signatur                   | Rckgabe | Beschreibung                   |\n|------------|----------------------------|-----------|--------------------------------|\n| `push`     | `(value: any)`             | `null`    | Am Ende hinzufgen            |\n| `pop`      | `()`                       | `any`     | Vom Ende entfernen             |\n| `shift`    | `()`                       | `any`     | Vom Anfang entfernen           |\n| `unshift`  | `(value: any)`             | `null`    | Am Anfang hinzufgen          |\n| `insert`   | `(index: i32, value: any)` | `null`    | An Index einfgen             |\n| `remove`   | `(index: i32)`             | `any`     | An Index entfernen             |\n| `reverse`  | `()`                       | `null`    | An Ort und Stelle umkehren     |\n| `clear`    | `()`                       | `null`    | Alle Elemente entfernen        |\n\n### Nicht-mutierende Methoden\n\nMethoden die neue Werte zurckgeben ohne das Original zu modifizieren:\n\n| Methode    | Signatur                   | Rckgabe | Beschreibung                   |\n|------------|----------------------------|-----------|--------------------------------|\n| `find`     | `(value: any)`             | `i32`     | Erstes Vorkommen finden        |\n| `contains` | `(value: any)`             | `bool`    | Prfen ob Wert enthalten      |\n| `slice`    | `(start: i32, end: i32)`   | `array`   | Teilarray extrahieren          |\n| `first`    | `()`                       | `any`     | Erstes Element holen           |\n| `last`     | `()`                       | `any`     | Letztes Element holen          |\n| `concat`   | `(other: array)`           | `array`   | Arrays verketten               |\n| `join`     | `(delimiter: string)`      | `string`  | Elemente zu String verbinden   |\n| `map`      | `(callback: fn)`           | `array`   | Jedes Element transformieren   |\n| `filter`   | `(predicate: fn)`          | `array`   | Passende Elemente auswhlen   |\n| `reduce`   | `(callback: fn, initial: any)` | `any` | Auf einzelnen Wert reduzieren  |\n\n---\n\n## Verwendungsmuster\n\n### Stack-Verwendung\n\n```hemlock\nlet stack = [];\n\n// Elemente pushen\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Elemente poppen\nwhile (stack.length > 0) {\n    let item = stack.pop();\n    print(item);  // 3, 2, 1\n}\n```\n\n### Warteschlangen-Verwendung\n\n```hemlock\nlet queue = [];\n\n// Einreihen\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Ausreihen\nwhile (queue.length > 0) {\n    let item = queue.shift();\n    print(item);  // 1, 2, 3\n}\n```\n\n### Array-Transformation\n\n```hemlock\n// Filtern (manuell)\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = [];\nlet i = 0;\nwhile (i < numbers.length) {\n    if (numbers[i] % 2 == 0) {\n        evens.push(numbers[i]);\n    }\n    i = i + 1;\n}\n\n// Abbilden (manuell)\nlet numbers2 = [1, 2, 3, 4, 5];\nlet doubled = [];\nlet j = 0;\nwhile (j < numbers2.length) {\n    doubled.push(numbers2[j] * 2);\n    j = j + 1;\n}\n```\n\n### Arrays aufbauen\n\n```hemlock\nlet arr = [];\n\n// Array mit Schleife aufbauen\nlet i = 0;\nwhile (i < 10) {\n    arr.push(i * 10);\n    i = i + 1;\n}\n\nprint(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n```\n\n---\n\n## Implementierungsdetails\n\n**Kapazittsverwaltung:**\n- Arrays wachsen automatisch bei Bedarf\n- Kapazitt verdoppelt sich bei berschreitung\n- Keine manuelle Kapazitaetssteuerung\n\n**Wertvergleich:**\n- `find()` und `contains()` verwenden Wertgleichheit\n- Funktioniert korrekt fr Primitive und Strings\n- Objekte/Arrays werden per Referenz verglichen\n\n**Speicher:**\n- Heap-allokiert\n- Keine automatische Freigabe (manuelle Speicherverwaltung)\n- Keine Grenzenprfung bei direktem Indexzugriff\n\n---\n\n## Siehe auch\n\n- [Typsystem](#reference-type-system) - Array-Typ-Details\n- [String-API](#reference-string-api) - String join()-Ergebnisse\n- [Operatoren](#reference-operators) - Array-Indizierungsoperator\n"}, "API-Referenz -> Datei-API": {"id": "reference-file-api", "content": "# Datei-API-Referenz\n\nVollstndige Referenz fr Hemlocks Datei-I/O-System.\n\n---\n\n## bersicht\n\nHemlock bietet eine **Dateiobjekt-API** fr Dateioperationen mit ordnungsgemaesser Fehlerbehandlung und Ressourcenverwaltung. Dateien mssen manuell geffnet und geschlossen werden.\n\n**Hauptmerkmale:**\n- Dateiobjekt mit Methoden\n- Text- und Binaerdaten lesen/schreiben\n- Positionierung und Suchen\n- Ordnungsgemaesse Fehlermeldungen\n- Manuelle Ressourcenverwaltung (kein RAII)\n\n---\n\n## Datei-Typ\n\n**Typ:** `file`\n\n**Beschreibung:** Dateihandle fr I/O-Operationen\n\n**Eigenschaften (Nur-Lesen):**\n- `.path` - Dateipfad (string)\n- `.mode` - Oeffnungsmodus (string)\n- `.closed` - Ob Datei geschlossen (bool)\n\n---\n\n## Dateien ffnen\n\n### open\n\nOeffnet eine Datei zum Lesen, Schreiben oder beides.\n\n**Signatur:**\n```hemlock\nopen(path: string, mode?: string): file\n```\n\n**Parameter:**\n- `path` - Dateipfad (relativ oder absolut)\n- `mode` (optional) - Oeffnungsmodus (Standard: `\"r\"`)\n\n**Rckgabe:** Dateiobjekt\n\n**Modi:**\n- `\"r\"` - Lesen (Standard)\n- `\"w\"` - Schreiben (bestehende Datei abschneiden)\n- `\"a\"` - Anhaengen\n- `\"r+\"` - Lesen und Schreiben\n- `\"w+\"` - Lesen und Schreiben (abschneiden)\n- `\"a+\"` - Lesen und Anhaengen\n\n**Beispiele:**\n```hemlock\n// Lesemodus (Standard)\nlet f = open(\"data.txt\");\nlet f_read = open(\"data.txt\", \"r\");\n\n// Schreibmodus (abschneiden)\nlet f_write = open(\"output.txt\", \"w\");\n\n// Anhaengemodus\nlet f_append = open(\"log.txt\", \"a\");\n\n// Lesen/Schreiben-Modus\nlet f_rw = open(\"data.bin\", \"r+\");\n\n// Lesen/Schreiben (abschneiden)\nlet f_rw_trunc = open(\"output.bin\", \"w+\");\n\n// Lesen/Anhaengen\nlet f_ra = open(\"log.txt\", \"a+\");\n```\n\n**Fehlerbehandlung:**\n```hemlock\ntry {\n    let f = open(\"missing.txt\", \"r\");\n} catch (e) {\n    print(\"ffnen fehlgeschlagen:\", e);\n    // Fehler: Konnte 'missing.txt' nicht ffnen: Datei oder Verzeichnis nicht gefunden\n}\n```\n\n**Wichtig:** Dateien mssen manuell mit `f.close()` geschlossen werden um Dateideskriptor-Lecks zu vermeiden.\n\n---\n\n## Datei-Methoden\n\n### Lesen\n\n#### read\n\nLiest Text aus Datei.\n\n**Signatur:**\n```hemlock\nfile.read(size?: i32): string\n```\n\n**Parameter:**\n- `size` (optional) - Anzahl der zu lesenden Bytes (wenn weggelassen, bis EOF lesen)\n\n**Rckgabe:** String mit Dateiinhalt\n\n**Beispiele:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Gesamte Datei lesen\nlet all = f.read();\nprint(all);\n\n// Bestimmte Anzahl Bytes lesen\nlet chunk = f.read(1024);\n\nf.close();\n```\n\n**Verhalten:**\n- Liest ab aktueller Dateiposition\n- Gibt leeren String bei EOF zurck\n- Bewegt Dateiposition vorwrts\n\n**Fehler:**\n- Lesen aus geschlossener Datei\n- Lesen aus Nur-Schreiben-Datei\n\n---\n\n#### read_bytes\n\nLiest Binaerdaten aus Datei.\n\n**Signatur:**\n```hemlock\nfile.read_bytes(size: i32): buffer\n```\n\n**Parameter:**\n- `size` - Anzahl der zu lesenden Bytes\n\n**Rckgabe:** Buffer mit Binaerdaten\n\n**Beispiele:**\n```hemlock\nlet f = open(\"data.bin\", \"r\");\n\n// 256 Bytes lesen\nlet binary = f.read_bytes(256);\nprint(binary.length);       // 256\n\n// Binaerdaten verarbeiten\nlet i = 0;\nwhile (i < binary.length) {\n    print(binary[i]);\n    i = i + 1;\n}\n\nf.close();\n```\n\n**Verhalten:**\n- Liest exakte Anzahl Bytes\n- Gibt Buffer zurck (kein String)\n- Bewegt Dateiposition vorwrts\n\n---\n\n### Schreiben\n\n#### write\n\nSchreibt Text in Datei.\n\n**Signatur:**\n```hemlock\nfile.write(data: string): i32\n```\n\n**Parameter:**\n- `data` - Zu schreibender String\n\n**Rckgabe:** Anzahl geschriebener Bytes (i32)\n\n**Beispiele:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\n\n// Text schreiben\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Geschrieben\", written, \"Bytes\");\n\n// Mehrere Schreibvorgaenge\nf.write(\"Zeile 1\\n\");\nf.write(\"Zeile 2\\n\");\nf.write(\"Zeile 3\\n\");\n\nf.close();\n```\n\n**Verhalten:**\n- Schreibt an aktueller Dateiposition\n- Gibt Anzahl geschriebener Bytes zurck\n- Bewegt Dateiposition vorwrts\n\n**Fehler:**\n- Schreiben in geschlossene Datei\n- Schreiben in Nur-Lesen-Datei\n\n---\n\n#### write_bytes\n\nSchreibt Binaerdaten in Datei.\n\n**Signatur:**\n```hemlock\nfile.write_bytes(data: buffer): i32\n```\n\n**Parameter:**\n- `data` - Zu schreibender Buffer\n\n**Rckgabe:** Anzahl geschriebener Bytes (i32)\n\n**Beispiele:**\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Buffer erstellen\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Buffer schreiben\nlet written = f.write_bytes(buf);\nprint(\"Geschrieben\", written, \"Bytes\");\n\nf.close();\n```\n\n**Verhalten:**\n- Schreibt Buffer-Inhalt in Datei\n- Gibt Anzahl geschriebener Bytes zurck\n- Bewegt Dateiposition vorwrts\n\n---\n\n### Positionieren\n\n#### seek\n\nBewegt Dateiposition zu bestimmtem Byte-Offset.\n\n**Signatur:**\n```hemlock\nfile.seek(position: i32): i32\n```\n\n**Parameter:**\n- `position` - Byte-Offset vom Dateianfang\n\n**Rckgabe:** Neue Dateiposition (i32)\n\n**Beispiele:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Zu Byte 100 springen\nf.seek(100);\n\n// Von dieser Position lesen\nlet chunk = f.read(50);\n\n// Zum Anfang zurcksetzen\nf.seek(0);\n\n// Vom Anfang lesen\nlet all = f.read();\n\nf.close();\n```\n\n**Verhalten:**\n- Setzt Dateiposition auf absoluten Offset\n- Gibt neue Position zurck\n- Suchen hinter EOF ist erlaubt (erzeugt Loch in Datei beim Schreiben)\n\n---\n\n#### tell\n\nGibt aktuelle Dateiposition zurck.\n\n**Signatur:**\n```hemlock\nfile.tell(): i32\n```\n\n**Rckgabe:** Aktueller Byte-Offset vom Dateianfang (i32)\n\n**Beispiele:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nprint(f.tell());        // 0 (am Anfang)\n\nf.read(100);\nprint(f.tell());        // 100 (nach Lesen)\n\nf.seek(50);\nprint(f.tell());        // 50 (nach Suchen)\n\nf.close();\n```\n\n---\n\n### Schlieen\n\n#### close\n\nSchliesst Datei (idempotent).\n\n**Signatur:**\n```hemlock\nfile.close(): null\n```\n\n**Rckgabe:** `null`\n\n**Beispiele:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\n// Sicher mehrmals aufzurufen\nf.close();  // Kein Fehler\nf.close();  // Kein Fehler\n```\n\n**Verhalten:**\n- Schliesst Dateihandle\n- Leert ausstehende Schreibvorgaenge\n- Idempotent (sicher mehrmals aufzurufen)\n- Setzt `.closed`-Eigenschaft auf `true`\n\n**Wichtig:** Schlieen Sie Dateien immer wenn fertig um Dateideskriptor-Lecks zu vermeiden.\n\n---\n\n## Datei-Eigenschaften\n\n### .path\n\nGibt Dateipfad zurck.\n\n**Typ:** `string`\n\n**Zugriff:** Nur-Lesen\n\n**Beispiele:**\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);          // \"/path/to/file.txt\"\nf.close();\n```\n\n---\n\n### .mode\n\nGibt Oeffnungsmodus zurck.\n\n**Typ:** `string`\n\n**Zugriff:** Nur-Lesen\n\n**Beispiele:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);          // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);         // \"w\"\nf2.close();\n```\n\n---\n\n### .closed\n\nPrueft ob Datei geschlossen ist.\n\n**Typ:** `bool`\n\n**Zugriff:** Nur-Lesen\n\n**Beispiele:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);        // false\n\nf.close();\nprint(f.closed);        // true\n```\n\n---\n\n## Fehlerbehandlung\n\nAlle Dateioperationen enthalten ordnungsgemaesse Fehlermeldungen mit Kontext:\n\n### Datei nicht gefunden\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Fehler: Konnte 'missing.txt' nicht ffnen: Datei oder Verzeichnis nicht gefunden\n```\n\n### Lesen aus geschlossener Datei\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Fehler: Kann nicht aus geschlossener Datei 'data.txt' lesen\n```\n\n### Schreiben in Nur-Lesen-Datei\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Fehler: Kann nicht in Datei 'readonly.txt' schreiben, die im Nur-Lesen-Modus geffnet wurde\n```\n\n### Mit try/catch\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    print(content);\n} catch (e) {\n    print(\"Dateifehler:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## Ressourcenverwaltungsmuster\n\n### Grundmuster\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### Mit Fehlerbehandlung\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Immer schlieen, auch bei Fehler\n}\n```\n\n### Sicheres Muster\n\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    // ... Inhalt verarbeiten ...\n} catch (e) {\n    print(\"Fehler:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## Verwendungsbeispiele\n\n### Gesamte Datei lesen\n\n```hemlock\nfn read_file(filename: string): string {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content;\n}\n\nlet text = read_file(\"data.txt\");\nprint(text);\n```\n\n### Textdatei schreiben\n\n```hemlock\nfn write_file(filename: string, content: string) {\n    let f = open(filename, \"w\");\n    f.write(content);\n    f.close();\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\\n\");\n```\n\n### An Datei anhaengen\n\n```hemlock\nfn append_file(filename: string, line: string) {\n    let f = open(filename, \"a\");\n    f.write(line + \"\\n\");\n    f.close();\n}\n\nappend_file(\"log.txt\", \"Log-Eintrag 1\");\nappend_file(\"log.txt\", \"Log-Eintrag 2\");\n```\n\n### Binaerdatei lesen\n\n```hemlock\nfn read_binary(filename: string, size: i32): buffer {\n    let f = open(filename, \"r\");\n    let data = f.read_bytes(size);\n    f.close();\n    return data;\n}\n\nlet binary = read_binary(\"data.bin\", 256);\nprint(\"Gelesen\", binary.length, \"Bytes\");\n```\n\n### Binaerdatei schreiben\n\n```hemlock\nfn write_binary(filename: string, data: buffer) {\n    let f = open(filename, \"w\");\n    f.write_bytes(data);\n    f.close();\n}\n\nlet buf = buffer(10);\nbuf[0] = 65;\nwrite_binary(\"output.bin\", buf);\n```\n\n### Datei Zeile fr Zeile lesen\n\n```hemlock\nfn read_lines(filename: string): array {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content.split(\"\\n\");\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Zeile\", i, \":\", lines[i]);\n    i = i + 1;\n}\n```\n\n### Datei kopieren\n\n```hemlock\nfn copy_file(src: string, dest: string) {\n    let f_in = open(src, \"r\");\n    let f_out = open(dest, \"w\");\n\n    let content = f_in.read();\n    f_out.write(content);\n\n    f_in.close();\n    f_out.close();\n}\n\ncopy_file(\"input.txt\", \"output.txt\");\n```\n\n### Datei in Stuecken lesen\n\n```hemlock\nfn process_chunks(filename: string) {\n    let f = open(filename, \"r\");\n\n    while (true) {\n        let chunk = f.read(1024);  // 1KB auf einmal lesen\n        if (chunk.length == 0) {\n            break;  // EOF\n        }\n\n        // Stck verarbeiten\n        print(\"Verarbeite\", chunk.length, \"Bytes\");\n    }\n\n    f.close();\n}\n\nprocess_chunks(\"large_file.txt\");\n```\n\n---\n\n## Vollstndige Methodenuebersicht\n\n| Methode       | Signatur                 | Rckgabe | Beschreibung                 |\n|---------------|--------------------------|-----------|------------------------------|\n| `read`        | `(size?: i32)`           | `string`  | Text lesen                   |\n| `read_bytes`  | `(size: i32)`            | `buffer`  | Binaerdaten lesen            |\n| `write`       | `(data: string)`         | `i32`     | Text schreiben               |\n| `write_bytes` | `(data: buffer)`         | `i32`     | Binaerdaten schreiben        |\n| `seek`        | `(position: i32)`        | `i32`     | Dateiposition setzen         |\n| `tell`        | `()`                     | `i32`     | Dateiposition holen          |\n| `close`       | `()`                     | `null`    | Datei schlieen (idempotent)|\n\n---\n\n## Vollstndige Eigenschaftsuebersicht\n\n| Eigenschaft | Typ      | Zugriff    | Beschreibung             |\n|-------------|----------|------------|--------------------------|\n| `.path`     | `string` | Nur-Lesen  | Dateipfad                |\n| `.mode`     | `string` | Nur-Lesen  | Oeffnungsmodus           |\n| `.closed`   | `bool`   | Nur-Lesen  | Ob Datei geschlossen     |\n\n---\n\n## Migration von alter API\n\n**Alte API (Entfernt):**\n- `read_file(path)` - Verwenden Sie `open(path, \"r\").read()`\n- `write_file(path, data)` - Verwenden Sie `open(path, \"w\").write(data)`\n- `append_file(path, data)` - Verwenden Sie `open(path, \"a\").write(data)`\n- `file_exists(path)` - Noch kein Ersatz\n\n**Migrationsbeispiel:**\n```hemlock\n// Alt (v0.0)\nlet content = read_file(\"data.txt\");\nwrite_file(\"output.txt\", content);\n\n// Neu (v0.1)\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nf2.write(content);\nf2.close();\n```\n\n---\n\n## Siehe auch\n\n- [Eingebaute Funktionen](#reference-builtins) - `open()`-Funktion\n- [Speicher-API](#reference-memory-api) - Buffer-Typ\n- [String-API](#reference-string-api) - String-Methoden zur Textverarbeitung\n"}, "API-Referenz -> Eingebaute Funktionen": {"id": "reference-builtins", "content": "# Eingebaute Funktionen Referenz\n\nVollstndige Referenz fr alle eingebauten Funktionen und Konstanten in Hemlock.\n\n---\n\n## bersicht\n\nHemlock bietet eine Reihe von eingebauten Funktionen fr I/O, Typ-Introspektion, Speicherverwaltung, Nebenlufigkeit und Systeminteraktion. Alle eingebauten Funktionen sind global verfgbar ohne Imports.\n\n---\n\n## I/O-Funktionen\n\n### print\n\nGibt Werte auf stdout mit Zeilenumbruch aus.\n\n**Signatur:**\n```hemlock\nprint(...values): null\n```\n\n**Parameter:**\n- `...values` - Beliebige Anzahl von Werten zum Ausgeben\n\n**Rckgabe:** `null`\n\n**Beispiele:**\n```hemlock\nprint(\"Hello, World!\");\nprint(42);\nprint(3.14);\nprint(true);\nprint([1, 2, 3]);\nprint({ x: 10, y: 20 });\n\n// Mehrere Werte\nprint(\"x =\", 10, \"y =\", 20);\n```\n\n**Verhalten:**\n- Konvertiert alle Werte zu Strings\n- Trennt mehrere Werte mit Leerzeichen\n- Fuegt Zeilenumbruch am Ende hinzu\n- Leert stdout\n\n---\n\n### read_line\n\nLiest eine Zeile Text von stdin (Benutzereingabe).\n\n**Signatur:**\n```hemlock\nread_line(): string | null\n```\n\n**Parameter:** Keine\n\n**Rckgabe:**\n- `string` - Die von stdin gelesene Zeile (Zeilenumbruch entfernt)\n- `null` - Bei EOF (Ende der Datei/Eingabe)\n\n**Beispiele:**\n```hemlock\n// Einfache Eingabeaufforderung\nprint(\"Wie ist dein Name?\");\nlet name = read_line();\nprint(\"Hallo, \" + name + \"!\");\n\n// Zahlen lesen (erfordert manuelles Parsen)\nprint(\"Gib eine Zahl ein:\");\nlet input = read_line();\nlet num = parse_int(input);  // Siehe unten fr parse_int\nprint(\"Das Doppelte:\", num * 2);\n\n// EOF behandeln\nlet line = read_line();\nif (line == null) {\n    print(\"Ende der Eingabe\");\n}\n\n// Mehrere Zeilen lesen\nprint(\"Gib Zeilen ein (Strg+D zum Beenden):\");\nwhile (true) {\n    let line = read_line();\n    if (line == null) {\n        break;\n    }\n    print(\"Du sagtest:\", line);\n}\n```\n\n**Verhalten:**\n- Blockiert bis Benutzer Enter drueckt\n- Entfernt nachfolgenden Zeilenumbruch (`\\n`) und Wagenruecklauf (`\\r`)\n- Gibt `null` bei EOF zurck (Strg+D auf Unix, Strg+Z auf Windows)\n- Liest nur von stdin (nicht von Dateien)\n\n**Benutzereingabe parsen:**\n\nDa `read_line()` immer einen String zurckgibt, mssen Sie numerische Eingaben manuell parsen:\n\n```hemlock\n// Einfacher Integer-Parser\nfn parse_int(s: string): i32 {\n    let result: i32 = 0;\n    let negative = false;\n    let i = 0;\n\n    if (s.length > 0 && s.char_at(0) == '-') {\n        negative = true;\n        i = 1;\n    }\n\n    while (i < s.length) {\n        let c = s.char_at(i);\n        let code: i32 = c;\n        if (code >= 48 && code <= 57) {\n            result = result * 10 + (code - 48);\n        } else {\n            break;\n        }\n        i = i + 1;\n    }\n\n    if (negative) {\n        return -result;\n    }\n    return result;\n}\n\n// Verwendung\nprint(\"Gib dein Alter ein:\");\nlet age = parse_int(read_line());\nprint(\"In 10 Jahren wirst du\", age + 10, \"sein\");\n```\n\n**Siehe auch:** [Datei-API](#reference-file-api) zum Lesen aus Dateien\n\n---\n\n### eprint\n\nGibt einen Wert auf stderr mit Zeilenumbruch aus.\n\n**Signatur:**\n```hemlock\neprint(value: any): null\n```\n\n**Parameter:**\n- `value` - Einzelner Wert zum Ausgeben auf stderr\n\n**Rckgabe:** `null`\n\n**Beispiele:**\n```hemlock\neprint(\"Fehler: Datei nicht gefunden\");\neprint(404);\neprint(\"Warnung: \" + message);\n\n// Typisches Fehlerbehandlungsmuster\nfn load_config(path: string) {\n    if (!exists(path)) {\n        eprint(\"Fehler: Konfigurationsdatei nicht gefunden: \" + path);\n        return null;\n    }\n    // ...\n}\n```\n\n**Verhalten:**\n- Gibt auf stderr aus (Standardfehlerausgabe)\n- Fuegt Zeilenumbruch am Ende hinzu\n- Akzeptiert nur ein Argument (anders als `print`)\n- Ntzlich fr Fehlermeldungen die sich nicht mit normaler Ausgabe vermischen sollen\n\n**Unterschied zu print:**\n- `print()`  stdout (normale Ausgabe, kann mit `>` umgeleitet werden)\n- `eprint()`  stderr (Fehlerausgabe, kann mit `2>` umgeleitet werden)\n\n```bash\n# Shell-Beispiel: stdout und stderr trennen\n./hemlock script.hml > output.txt 2> errors.txt\n```\n\n---\n\n## Typ-Introspektion\n\n### typeof\n\nGibt den Typnamen eines Wertes zurck.\n\n**Signatur:**\n```hemlock\ntypeof(value: any): string\n```\n\n**Parameter:**\n- `value` - Beliebiger Wert\n\n**Rckgabe:** Typname als String\n\n**Beispiele:**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof(null));            // \"null\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\n// Typisierte Objekte\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n\n// Andere Typen\nprint(typeof(alloc(10)));       // \"ptr\"\nprint(typeof(buffer(10)));      // \"buffer\"\nprint(typeof(open(\"file.txt\"))); // \"file\"\n```\n\n**Typnamen:**\n- Primitive: `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- Zusammengesetzt: `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- Speziell: `\"file\"`, `\"task\"`, `\"channel\"`\n- Benutzerdefiniert: Benutzerdefinierte Typnamen aus `define`\n\n**Siehe auch:** [Typsystem](#reference-type-system)\n\n---\n\n## Befehlsausfuehrung\n\n### exec\n\nFuehrt Shell-Befehl aus und erfasst Ausgabe.\n\n**Signatur:**\n```hemlock\nexec(command: string): object\n```\n\n**Parameter:**\n- `command` - Auszufuehrender Shell-Befehl\n\n**Rckgabe:** Objekt mit Feldern:\n- `output` (string) - stdout des Befehls\n- `exit_code` (i32) - Exit-Statuscode (0 = Erfolg)\n\n**Beispiele:**\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n\n// Exit-Status prfen\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Gefunden:\", r.output);\n} else {\n    print(\"Muster nicht gefunden\");\n}\n\n// Mehrzeilige Ausgabe verarbeiten\nlet r2 = exec(\"ls -la\");\nlet lines = r2.output.split(\"\\n\");\n```\n\n**Verhalten:**\n- Fuehrt Befehl ber `/bin/sh` aus\n- Erfasst nur stdout (stderr geht zum Terminal)\n- Blockiert bis Befehl abgeschlossen ist\n- Gibt leeren String zurck wenn keine Ausgabe\n\n**Fehlerbehandlung:**\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command\");\n} catch (e) {\n    print(\"Ausfhrung fehlgeschlagen:\", e);\n}\n```\n\n**Sicherheitswarnung:** Anfaellig fr Shell-Injection. Validieren/bereinigen Sie immer Benutzereingaben.\n\n**Einschrnkungen:**\n- Keine stderr-Erfassung\n- Kein Streaming\n- Kein Timeout\n- Keine Signalbehandlung\n\n---\n\n### exec_argv\n\nFuehrt einen Befehl mit explizitem Argument-Array aus (keine Shell-Interpretation).\n\n**Signatur:**\n```hemlock\nexec_argv(argv: array): object\n```\n\n**Parameter:**\n- `argv` - Array von Strings: `[befehl, arg1, arg2, ...]`\n\n**Rckgabe:** Objekt mit Feldern:\n- `output` (string) - stdout des Befehls\n- `exit_code` (i32) - Exit-Statuscode (0 = Erfolg)\n\n**Beispiele:**\n```hemlock\n// Einfacher Befehl\nlet result = exec_argv([\"ls\", \"-la\"]);\nprint(result.output);\n\n// Befehl mit Argumenten die Leerzeichen enthalten (sicher!)\nlet r = exec_argv([\"grep\", \"hello world\", \"file.txt\"]);\n\n// Skript mit Argumenten ausfhren\nlet r2 = exec_argv([\"python\", \"script.py\", \"--input\", \"data.json\"]);\nprint(r2.exit_code);\n```\n\n**Unterschied zu exec:**\n```hemlock\n// exec() verwendet Shell - UNSICHER mit Benutzereingaben\nexec(\"ls \" + user_input);  // Shell-Injection-Risiko!\n\n// exec_argv() umgeht Shell - SICHER\nexec_argv([\"ls\", user_input]);  // Keine Injection mglich\n```\n\n**Wann verwenden:**\n- Wenn Argumente Leerzeichen, Anfhrungszeichen oder Sonderzeichen enthalten\n- Bei Verarbeitung von Benutzereingaben (Sicherheit)\n- Wenn vorhersagbares Argument-Parsing bentigt wird\n\n**Siehe auch:** `exec()` fr einfache Shell-Befehle\n\n---\n\n## Fehlerbehandlung\n\n### throw\n\nWirft eine Ausnahme.\n\n**Signatur:**\n```hemlock\nthrow expression\n```\n\n**Parameter:**\n- `expression` - Zu werfender Wert (beliebiger Typ)\n\n**Rckgabe:** Gibt nie zurck (bertrgt Kontrolle)\n\n**Beispiele:**\n```hemlock\nthrow \"Fehlermeldung\";\nthrow 404;\nthrow { code: 500, message: \"Interner Fehler\" };\nthrow null;\n```\n\n**Siehe auch:** try/catch/finally-Anweisungen\n\n---\n\n### panic\n\nBeendet Programm sofort mit Fehlermeldung (nicht wiederherstellbar).\n\n**Signatur:**\n```hemlock\npanic(message?: any): never\n```\n\n**Parameter:**\n- `message` (optional) - Auszugebende Fehlermeldung\n\n**Rckgabe:** Gibt nie zurck (Programm beendet sich)\n\n**Beispiele:**\n```hemlock\npanic();                          // Standard: \"panic!\"\npanic(\"Unerreichbarer Code erreicht\");\npanic(42);\n\n// Haeufiger Anwendungsfall\nfn process_state(state: i32): string {\n    if (state == 1) { return \"bereit\"; }\n    if (state == 2) { return \"luft\"; }\n    panic(\"Ungueltiger Status: \" + typeof(state));\n}\n```\n\n**Verhalten:**\n- Gibt Fehler auf stderr aus: `panic: <message>`\n- Beendet mit Code 1\n- **NICHT abfangbar** mit try/catch\n- Verwenden fr Bugs und nicht wiederherstellbare Fehler\n\n**Panic vs Throw:**\n- `panic()` - Nicht wiederherstellbarer Fehler, beendet sofort\n- `throw` - Wiederherstellbarer Fehler, kann abgefangen werden\n\n---\n\n### assert\n\nStellt sicher dass eine Bedingung wahr ist, oder beendet mit Fehlermeldung.\n\n**Signatur:**\n```hemlock\nassert(condition: any, message?: string): null\n```\n\n**Parameter:**\n- `condition` - Auf Wahrheit zu pruefender Wert\n- `message` (optional) - Benutzerdefinierte Fehlermeldung bei fehlgeschlagener Prfung\n\n**Rckgabe:** `null` (wenn Prfung erfolgreich)\n\n**Beispiele:**\n```hemlock\n// Grundlegende Prfungen\nassert(x > 0);\nassert(name != null);\nassert(arr.length > 0, \"Array darf nicht leer sein\");\n\n// Mit benutzerdefinierten Meldungen\nfn divide(a: i32, b: i32): f64 {\n    assert(b != 0, \"Division durch Null\");\n    return a / b;\n}\n\n// Funktionsargumente validieren\nfn process_data(data: array) {\n    assert(data != null, \"data darf nicht null sein\");\n    assert(data.length > 0, \"data darf nicht leer sein\");\n    // ...\n}\n```\n\n**Verhalten:**\n- Wenn Bedingung wahr: gibt `null` zurck, Ausfhrung fortgesetzt\n- Wenn Bedingung falsch: gibt Fehler aus und beendet mit Code 1\n- Falsche Werte: `false`, `0`, `0.0`, `null`, `\"\"` (leerer String)\n- Wahre Werte: alles andere\n\n**Ausgabe bei Fehlschlag:**\n```\nAssertion failed: Array darf nicht leer sein\n```\n\n**Wann verwenden:**\n- Validierung von Funktionsvorbedingungen\n- Prfen von Invarianten whrend der Entwicklung\n- Fruehzeitiges Erkennen von Programmierfehlern\n\n**assert vs panic:**\n- `assert(cond, msg)` - Prueft eine Bedingung, schlaegt fehl wenn falsch\n- `panic(msg)` - Schlaegt immer bedingungslos fehl\n\n---\n\n## Signalbehandlung\n\n### signal\n\nRegistriert oder setzt Signal-Handler zurck.\n\n**Signatur:**\n```hemlock\nsignal(signum: i32, handler: function | null): function | null\n```\n\n**Parameter:**\n- `signum` - Signalnummer (verwenden Sie Konstanten wie `SIGINT`)\n- `handler` - Funktion die bei Signalempfang aufgerufen wird, oder `null` zum Zurcksetzen auf Standard\n\n**Rckgabe:** Vorherige Handler-Funktion, oder `null`\n\n**Beispiele:**\n```hemlock\nfn handle_interrupt(sig) {\n    print(\"SIGINT abgefangen!\");\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Auf Standard zurcksetzen\nsignal(SIGINT, null);\n```\n\n**Handler-Signatur:**\n```hemlock\nfn handler(signum: i32) {\n    // signum enthlt die Signalnummer\n}\n```\n\n**Siehe auch:**\n- [Signalkonstanten](#signalkonstanten)\n- `raise()`\n\n---\n\n### raise\n\nSendet Signal an aktuellen Prozess.\n\n**Signatur:**\n```hemlock\nraise(signum: i32): null\n```\n\n**Parameter:**\n- `signum` - Zu sendende Signalnummer\n\n**Rckgabe:** `null`\n\n**Beispiele:**\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\nraise(SIGUSR1);\nraise(SIGUSR1);\nprint(count);  // 2\n```\n\n---\n\n## Globale Variablen\n\n### args\n\nKommandozeilenargumente-Array.\n\n**Typ:** `array` von Strings\n\n**Struktur:**\n- `args[0]` - Skriptdateiname\n- `args[1..n]` - Kommandozeilenargumente\n\n**Beispiele:**\n```bash\n# Befehl: ./hemlock script.hml hello world\n```\n\n```hemlock\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // 3\nprint(args[1]);        // \"hello\"\nprint(args[2]);        // \"world\"\n\n// Argumente durchlaufen\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument\", i, \":\", args[i]);\n    i = i + 1;\n}\n```\n\n**REPL-Verhalten:** Im REPL ist `args.length` 0 (leeres Array)\n\n---\n\n## Signalkonstanten\n\nStandard-POSIX-Signalkonstanten (i32-Werte):\n\n### Unterbrechung & Beendigung\n\n| Konstante  | Wert  | Beschreibung                                |\n|------------|-------|---------------------------------------------|\n| `SIGINT`   | 2     | Unterbrechung von Tastatur (Strg+C)         |\n| `SIGTERM`  | 15    | Beendigungsanforderung                      |\n| `SIGQUIT`  | 3     | Beenden von Tastatur (Strg+\\)               |\n| `SIGHUP`   | 1     | Aufhaengen am steuernden Terminal erkannt   |\n| `SIGABRT`  | 6     | Abbruchsignal                               |\n\n### Benutzerdefiniert\n\n| Konstante  | Wert  | Beschreibung               |\n|------------|-------|----------------------------|\n| `SIGUSR1`  | 10    | Benutzerdefiniertes Signal 1 |\n| `SIGUSR2`  | 12    | Benutzerdefiniertes Signal 2 |\n\n### Prozesssteuerung\n\n| Konstante  | Wert  | Beschreibung                      |\n|------------|-------|-----------------------------------|\n| `SIGALRM`  | 14    | Wecker-Timer                      |\n| `SIGCHLD`  | 17    | Kindprozess-Statusaenderung       |\n| `SIGCONT`  | 18    | Fortsetzen wenn gestoppt          |\n| `SIGSTOP`  | 19    | Prozess stoppen (nicht abfangbar) |\n| `SIGTSTP`  | 20    | Terminal-Stopp (Strg+Z)           |\n\n### I/O\n\n| Konstante  | Wert  | Beschreibung                           |\n|------------|-------|----------------------------------------|\n| `SIGPIPE`  | 13    | Unterbrochene Pipe                     |\n| `SIGTTIN`  | 21    | Hintergrund-Lesen vom Terminal         |\n| `SIGTTOU`  | 22    | Hintergrund-Schreiben zum Terminal     |\n\n**Beispiele:**\n```hemlock\nfn handle_signal(sig) {\n    if (sig == SIGINT) {\n        print(\"Unterbrechung erkannt\");\n    }\n    if (sig == SIGTERM) {\n        print(\"Beendigung angefordert\");\n    }\n}\n\nsignal(SIGINT, handle_signal);\nsignal(SIGTERM, handle_signal);\n```\n\n**Hinweis:** `SIGKILL` (9) und `SIGSTOP` (19) knnen nicht abgefangen oder ignoriert werden.\n\n---\n\n## Mathematik/Arithmetik-Funktionen\n\n### div\n\nGanzzahldivision die eine Gleitkommazahl zurckgibt.\n\n**Signatur:**\n```hemlock\ndiv(a: number, b: number): f64\n```\n\n**Parameter:**\n- `a` - Dividend\n- `b` - Divisor\n\n**Rckgabe:** Abrundung von `a / b` als Gleitkommazahl (f64)\n\n**Beispiele:**\n```hemlock\nlet result = div(7, 2);    // 3.0 (nicht 3.5)\nlet result2 = div(10, 3);  // 3.0\nlet result3 = div(-7, 2);  // -4.0 (Abrundung richtet sich nach negativer Unendlichkeit)\n```\n\n**Hinweis:** In Hemlock gibt der `/`-Operator immer eine Gleitkommazahl zurck. Verwenden Sie `div()` fr Ganzzahldivision wenn Sie den ganzzahligen Teil als Gleitkommazahl bentigen, oder `divi()` wenn Sie ein ganzzahliges Ergebnis bentigen.\n\n---\n\n### divi\n\nGanzzahldivision die eine Ganzzahl zurckgibt.\n\n**Signatur:**\n```hemlock\ndivi(a: number, b: number): i64\n```\n\n**Parameter:**\n- `a` - Dividend\n- `b` - Divisor\n\n**Rckgabe:** Abrundung von `a / b` als Ganzzahl (i64)\n\n**Beispiele:**\n```hemlock\nlet result = divi(7, 2);    // 3\nlet result2 = divi(10, 3);  // 3\nlet result3 = divi(-7, 2);  // -4 (Abrundung richtet sich nach negativer Unendlichkeit)\n```\n\n**Vergleich:**\n```hemlock\nprint(7 / 2);      // 3.5 (normale Division, immer Gleitkomma)\nprint(div(7, 2));  // 3.0 (Ganzzahldivision, Gleitkommaergebnis)\nprint(divi(7, 2)); // 3   (Ganzzahldivision, Ganzzahlergebnis)\n```\n\n---\n\n## Speicherverwaltungsfunktionen\n\nSiehe [Speicher-API](#reference-memory-api) fr vollstndige Referenz:\n- `alloc(size)` - Rohen Speicher allokieren\n- `free(ptr)` - Speicher freigeben\n- `buffer(size)` - Sicheren Buffer allokieren\n- `memset(ptr, byte, size)` - Speicher fuellen\n- `memcpy(dest, src, size)` - Speicher kopieren\n- `realloc(ptr, new_size)` - Allokation vergroessern/verkleinern\n\n### sizeof\n\nGibt die Gre eines Typs in Bytes zurck.\n\n**Signatur:**\n```hemlock\nsizeof(type): i32\n```\n\n**Parameter:**\n- `type` - Eine Typkonstante (`i32`, `f64`, `ptr`, etc.) oder Typname-String\n\n**Rckgabe:** Gre in Bytes als `i32`\n\n**Beispiele:**\n```hemlock\nprint(sizeof(i8));       // 1\nprint(sizeof(i16));      // 2\nprint(sizeof(i32));      // 4\nprint(sizeof(i64));      // 8\nprint(sizeof(f32));      // 4\nprint(sizeof(f64));      // 8\nprint(sizeof(ptr));      // 8\nprint(sizeof(rune));     // 4\n\n// Mit Typ-Aliasen\nprint(sizeof(byte));     // 1 (gleich wie u8)\nprint(sizeof(integer));  // 4 (gleich wie i32)\nprint(sizeof(number));   // 8 (gleich wie f64)\n\n// String-Form funktioniert auch\nprint(sizeof(\"i32\"));    // 4\n```\n\n**Unterstuetzte Typen:**\n| Typ | Gre | Aliase |\n|-----|---------|--------|\n| `i8` | 1 | - |\n| `i16` | 2 | - |\n| `i32` | 4 | `integer` |\n| `i64` | 8 | - |\n| `u8` | 1 | `byte` |\n| `u16` | 2 | - |\n| `u32` | 4 | - |\n| `u64` | 8 | - |\n| `f32` | 4 | - |\n| `f64` | 8 | `number` |\n| `ptr` | 8 | - |\n| `rune` | 4 | - |\n| `bool` | 1 | - |\n\n**Siehe auch:** `talloc()` fr typisierte Allokation\n\n---\n\n### talloc\n\nAllokiert Speicher fr ein typisiertes Array (typbewusste Allokation).\n\n**Signatur:**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**Parameter:**\n- `type` - Eine Typkonstante (`i32`, `f64`, `ptr`, etc.)\n- `count` - Anzahl der zu allokierenden Elemente\n\n**Rckgabe:** `ptr` zum allokierten Speicher, oder `null` bei Fehlschlag\n\n**Beispiele:**\n```hemlock\n// Array von 10 i32s allokieren (40 Bytes)\nlet int_arr = talloc(i32, 10);\nptr_write_i32(int_arr, 42);\nptr_write_i32(ptr_offset(int_arr, 1, 4), 100);\n\n// Array von 5 f64s allokieren (40 Bytes)\nlet float_arr = talloc(f64, 5);\n\n// Array von 100 Bytes allokieren\nlet byte_arr = talloc(u8, 100);\n\n// Nicht vergessen freizugeben!\nfree(int_arr);\nfree(float_arr);\nfree(byte_arr);\n```\n\n**Vergleich mit alloc:**\n```hemlock\n// Diese sind quivalent:\nlet p1 = talloc(i32, 10);      // Typbewusst: 10 i32s\nlet p2 = alloc(sizeof(i32) * 10);  // Manuelle Berechnung\n\n// talloc ist klarer und weniger fehleranfaellig\n```\n\n**Fehlerbehandlung:**\n- Gibt `null` zurck wenn Allokation fehlschlaegt\n- Beendet mit Fehler wenn count nicht positiv ist\n- Prueft auf Groessenueberlauf (count * element_size)\n\n**Siehe auch:** `alloc()`, `sizeof()`, `free()`\n\n---\n\n## FFI-Pointer-Hilfsfunktionen\n\nDiese Funktionen helfen beim Lesen und Schreiben von typisierten Werten im Rohspeicher, ntzlich fr FFI und Low-Level-Speichermanipulation.\n\n### ptr_null\n\nErstellt einen Null-Pointer.\n\n**Signatur:**\n```hemlock\nptr_null(): ptr\n```\n\n**Rckgabe:** Ein Null-Pointer\n\n**Beispiel:**\n```hemlock\nlet p = ptr_null();\nif (p == null) {\n    print(\"Pointer ist null\");\n}\n```\n\n---\n\n### ptr_offset\n\nBerechnet Pointer-Offset (Pointer-Arithmetik).\n\n**Signatur:**\n```hemlock\nptr_offset(ptr: ptr, index: i32, element_size: i32): ptr\n```\n\n**Parameter:**\n- `ptr` - Basis-Pointer\n- `index` - Element-Index\n- `element_size` - Gre jedes Elements in Bytes\n\n**Rckgabe:** Pointer zum Element am gegebenen Index\n\n**Beispiel:**\n```hemlock\nlet arr = talloc(i32, 10);\nptr_write_i32(arr, 100);                      // arr[0] = 100\nptr_write_i32(ptr_offset(arr, 1, 4), 200);    // arr[1] = 200\nptr_write_i32(ptr_offset(arr, 2, 4), 300);    // arr[2] = 300\n\nprint(ptr_read_i32(ptr_offset(arr, 1, 4)));   // 200\nfree(arr);\n```\n\n---\n\n### Pointer-Lesefunktionen\n\nLiest typisierte Werte aus dem Speicher.\n\n| Funktion | Signatur | Rckgabe | Beschreibung |\n|----------|----------|-----------|--------------|\n| `ptr_read_i8` | `(ptr)` | `i8` | Liest vorzeichenbehaftete 8-Bit-Ganzzahl |\n| `ptr_read_i16` | `(ptr)` | `i16` | Liest vorzeichenbehaftete 16-Bit-Ganzzahl |\n| `ptr_read_i32` | `(ptr)` | `i32` | Liest vorzeichenbehaftete 32-Bit-Ganzzahl |\n| `ptr_read_i64` | `(ptr)` | `i64` | Liest vorzeichenbehaftete 64-Bit-Ganzzahl |\n| `ptr_read_u8` | `(ptr)` | `u8` | Liest vorzeichenlose 8-Bit-Ganzzahl |\n| `ptr_read_u16` | `(ptr)` | `u16` | Liest vorzeichenlose 16-Bit-Ganzzahl |\n| `ptr_read_u32` | `(ptr)` | `u32` | Liest vorzeichenlose 32-Bit-Ganzzahl |\n| `ptr_read_u64` | `(ptr)` | `u64` | Liest vorzeichenlose 64-Bit-Ganzzahl |\n| `ptr_read_f32` | `(ptr)` | `f32` | Liest 32-Bit-Gleitkommazahl |\n| `ptr_read_f64` | `(ptr)` | `f64` | Liest 64-Bit-Gleitkommazahl |\n| `ptr_read_ptr` | `(ptr)` | `ptr` | Liest Pointer-Wert |\n\n**Beispiel:**\n```hemlock\nlet p = alloc(8);\nptr_write_f64(p, 3.14159);\nlet value = ptr_read_f64(p);\nprint(value);  // 3.14159\nfree(p);\n```\n\n---\n\n### Pointer-Schreibfunktionen\n\nSchreibt typisierte Werte in den Speicher.\n\n| Funktion | Signatur | Rckgabe | Beschreibung |\n|----------|----------|-----------|--------------|\n| `ptr_write_i8` | `(ptr, value)` | `null` | Schreibt vorzeichenbehaftete 8-Bit-Ganzzahl |\n| `ptr_write_i16` | `(ptr, value)` | `null` | Schreibt vorzeichenbehaftete 16-Bit-Ganzzahl |\n| `ptr_write_i32` | `(ptr, value)` | `null` | Schreibt vorzeichenbehaftete 32-Bit-Ganzzahl |\n| `ptr_write_i64` | `(ptr, value)` | `null` | Schreibt vorzeichenbehaftete 64-Bit-Ganzzahl |\n| `ptr_write_u8` | `(ptr, value)` | `null` | Schreibt vorzeichenlose 8-Bit-Ganzzahl |\n| `ptr_write_u16` | `(ptr, value)` | `null` | Schreibt vorzeichenlose 16-Bit-Ganzzahl |\n| `ptr_write_u32` | `(ptr, value)` | `null` | Schreibt vorzeichenlose 32-Bit-Ganzzahl |\n| `ptr_write_u64` | `(ptr, value)` | `null` | Schreibt vorzeichenlose 64-Bit-Ganzzahl |\n| `ptr_write_f32` | `(ptr, value)` | `null` | Schreibt 32-Bit-Gleitkommazahl |\n| `ptr_write_f64` | `(ptr, value)` | `null` | Schreibt 64-Bit-Gleitkommazahl |\n| `ptr_write_ptr` | `(ptr, value)` | `null` | Schreibt Pointer-Wert |\n\n**Beispiel:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\nprint(ptr_read_i32(p));  // 42\nfree(p);\n```\n\n---\n\n### Buffer/Pointer-Konvertierung\n\n#### buffer_ptr\n\nHolt rohen Pointer aus einem Buffer.\n\n**Signatur:**\n```hemlock\nbuffer_ptr(buf: buffer): ptr\n```\n\n**Beispiel:**\n```hemlock\nlet buf = buffer(64);\nlet p = buffer_ptr(buf);\n// Jetzt zeigt p auf denselben Speicher wie buf\n```\n\n#### ptr_to_buffer\n\nErstellt einen Buffer-Wrapper um einen rohen Pointer.\n\n**Signatur:**\n```hemlock\nptr_to_buffer(ptr: ptr, size: i32): buffer\n```\n\n**Beispiel:**\n```hemlock\nlet p = alloc(64);\nlet buf = ptr_to_buffer(p, 64);\nbuf[0] = 65;  // Hat jetzt Grenzenprfung\n// Hinweis: Freigeben von buf gibt den zugrundeliegenden Speicher frei\n```\n\n---\n\n## Datei-I/O-Funktionen\n\nSiehe [Datei-API](#reference-file-api) fr vollstndige Referenz:\n- `open(path, mode?)` - Datei ffnen\n\n---\n\n## Nebenlaeufigkeitsfunktionen\n\nSiehe [Nebenlaeufigkeits-API](#reference-concurrency-api) fr vollstndige Referenz:\n- `spawn(fn, args...)` - Task starten\n- `join(task)` - Auf Task warten\n- `detach(task)` - Task ablsen\n- `channel(capacity)` - Kanal erstellen\n\n### apply\n\nRuft eine Funktion dynamisch mit einem Array von Argumenten auf.\n\n**Signatur:**\n```hemlock\napply(fn: function, args: array): any\n```\n\n**Parameter:**\n- `fn` - Die aufzurufende Funktion\n- `args` - Array von Argumenten die an die Funktion bergeben werden\n\n**Rckgabe:** Der Rckgabewert der aufgerufenen Funktion\n\n**Beispiele:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\n// Mit Array von Argumenten aufrufen\nlet result = apply(add, [2, 3]);\nprint(result);  // 5\n\n// Dynamischer Dispatch\nlet operations = {\n    add: fn(a, b) { return a + b; },\n    mul: fn(a, b) { return a * b; },\n    sub: fn(a, b) { return a - b; }\n};\n\nfn calculate(op: string, args: array) {\n    return apply(operations[op], args);\n}\n\nprint(calculate(\"add\", [10, 5]));  // 15\nprint(calculate(\"mul\", [10, 5]));  // 50\nprint(calculate(\"sub\", [10, 5]));  // 5\n\n// Variable Argumente\nfn sum(...nums) {\n    let total = 0;\n    for (n in nums) {\n        total = total + n;\n    }\n    return total;\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(apply(sum, numbers));  // 15\n```\n\n**Anwendungsfaelle:**\n- Dynamischer Funktionsdispatch basierend auf Laufzeitwerten\n- Aufrufen von Funktionen mit variablen Argumentlisten\n- Implementierung von Higher-Order-Utilities (map, filter, etc.)\n- Plugin/Erweiterungssysteme\n\n---\n\n### select\n\nWartet auf Daten von mehreren Kanaelen, gibt zurck wenn einer Daten hat.\n\n**Signatur:**\n```hemlock\nselect(channels: array, timeout_ms?: i32): object | null\n```\n\n**Parameter:**\n- `channels` - Array von Kanalwerten\n- `timeout_ms` (optional) - Timeout in Millisekunden (-1 oder weglassen fr unendlich)\n\n**Rckgabe:**\n- `{ channel, value }` - Objekt mit dem Kanal der Daten hatte und dem empfangenen Wert\n- `null` - Bei Timeout\n\n**Beispiele:**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// Produzenten-Tasks\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"von Kanal 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"von Kanal 2\");\n});\n\n// Auf erste Nachricht warten\nlet result = select([ch1, ch2]);\nprint(result.value);  // \"von Kanal 2\" (kam zuerst an)\n\n// Mit Timeout\nlet result2 = select([ch1, ch2], 1000);  // Warte bis zu 1 Sekunde\nif (result2 == null) {\n    print(\"Timeout - keine Daten empfangen\");\n} else {\n    print(\"Empfangen:\", result2.value);\n}\n\n// Kontinuierliche Select-Schleife\nwhile (true) {\n    let msg = select([ch1, ch2], 5000);\n    if (msg == null) {\n        print(\"Keine Aktivitaet fr 5 Sekunden\");\n        break;\n    }\n    print(\"Nachricht erhalten:\", msg.value);\n}\n```\n\n**Verhalten:**\n- Blockiert bis ein Kanal Daten hat oder Timeout abluft\n- Gibt sofort zurck wenn ein Kanal bereits Daten hat\n- Wenn Kanal geschlossen und leer ist, gibt `{ channel, value: null }` zurck\n- Prueft Kanle der Reihe nach (erster bereiter Kanal gewinnt)\n\n**Anwendungsfaelle:**\n- Multiplexen mehrerer Produzenten\n- Implementierung von Timeouts bei Kanaloperationen\n- Aufbau von Event-Loops mit mehreren Quellen\n\n---\n\n## Zusammenfassungstabelle\n\n### Funktionen\n\n| Funktion   | Kategorie       | Rckgabe    | Beschreibung                     |\n|------------|-----------------|--------------|----------------------------------|\n| `print`    | I/O             | `null`       | Auf stdout ausgeben              |\n| `read_line`| I/O             | `string?`    | Zeile von stdin lesen            |\n| `eprint`   | I/O             | `null`       | Auf stderr ausgeben              |\n| `typeof`   | Typ             | `string`     | Typname holen                    |\n| `exec`     | Befehl          | `object`     | Shell-Befehl ausfhren          |\n| `exec_argv`| Befehl          | `object`     | Mit Argument-Array ausfhren    |\n| `assert`   | Fehler          | `null`       | Bedingung prfen oder beenden   |\n| `panic`    | Fehler          | `never`      | Nicht wiederherstellbarer Fehler (beendet) |\n| `signal`   | Signal          | `function?`  | Signal-Handler registrieren      |\n| `raise`    | Signal          | `null`       | Signal an Prozess senden         |\n| `alloc`    | Speicher        | `ptr`        | Rohen Speicher allokieren        |\n| `talloc`   | Speicher        | `ptr`        | Typisierte Allokation            |\n| `sizeof`   | Speicher        | `i32`        | Typgroesse in Bytes holen        |\n| `free`     | Speicher        | `null`       | Speicher freigeben               |\n| `buffer`   | Speicher        | `buffer`     | Sicheren Buffer allokieren       |\n| `memset`   | Speicher        | `null`       | Speicher fuellen                 |\n| `memcpy`   | Speicher        | `null`       | Speicher kopieren                |\n| `realloc`  | Speicher        | `ptr`        | Allokation vergroessern          |\n| `open`     | Datei-I/O       | `file`       | Datei ffnen                    |\n| `spawn`    | Nebenlufigkeit| `task`       | Nebenlaeufigen Task starten      |\n| `join`     | Nebenlufigkeit| `any`        | Auf Task-Ergebnis warten         |\n| `detach`   | Nebenlufigkeit| `null`       | Task abloesen                    |\n| `channel`  | Nebenlufigkeit| `channel`    | Kommunikationskanal erstellen    |\n| `select`   | Nebenlufigkeit| `object?`    | Auf mehrere Kanle warten       |\n| `apply`    | Funktionen      | `any`        | Funktion mit Args-Array aufrufen |\n\n### Globale Variablen\n\n| Variable   | Typ      | Beschreibung                      |\n|------------|----------|-----------------------------------|\n| `args`     | `array`  | Kommandozeilenargumente           |\n\n### Konstanten\n\n| Konstante  | Typ   | Kategorie | Wert  | Beschreibung              |\n|------------|-------|-----------|-------|---------------------------|\n| `SIGINT`   | `i32` | Signal    | 2     | Tastatur-Unterbrechung    |\n| `SIGTERM`  | `i32` | Signal    | 15    | Beendigungsanforderung    |\n| `SIGQUIT`  | `i32` | Signal    | 3     | Tastatur-Beenden          |\n| `SIGHUP`   | `i32` | Signal    | 1     | Aufhaengen                |\n| `SIGABRT`  | `i32` | Signal    | 6     | Abbruch                   |\n| `SIGUSR1`  | `i32` | Signal    | 10    | Benutzerdefiniert 1       |\n| `SIGUSR2`  | `i32` | Signal    | 12    | Benutzerdefiniert 2       |\n| `SIGALRM`  | `i32` | Signal    | 14    | Wecker-Timer              |\n| `SIGCHLD`  | `i32` | Signal    | 17    | Kind-Statusaenderung      |\n| `SIGCONT`  | `i32` | Signal    | 18    | Fortsetzen                |\n| `SIGSTOP`  | `i32` | Signal    | 19    | Stopp (nicht abfangbar)   |\n| `SIGTSTP`  | `i32` | Signal    | 20    | Terminal-Stopp            |\n| `SIGPIPE`  | `i32` | Signal    | 13    | Unterbrochene Pipe        |\n| `SIGTTIN`  | `i32` | Signal    | 21    | Hintergrund-Terminal-Lesen |\n| `SIGTTOU`  | `i32` | Signal    | 22    | Hintergrund-Terminal-Schreiben |\n\n---\n\n## Siehe auch\n\n- [Typsystem](#reference-type-system) - Typen und Konvertierungen\n- [Speicher-API](#reference-memory-api) - Speicherallokationsfunktionen\n- [Datei-API](#reference-file-api) - Datei-I/O-Funktionen\n- [Nebenlaeufigkeits-API](#reference-concurrency-api) - Async/Nebenlaeufigkeitsfunktionen\n- [String-API](#reference-string-api) - String-Methoden\n- [Array-API](#reference-array-api) - Array-Methoden\n"}, "API-Referenz -> Nebenlufigkeits-API": {"id": "reference-concurrency-api", "content": "# Nebenlaeufigkeits-API-Referenz\n\nVollstndige Referenz fr Hemlocks Async/Nebenlaeufigkeitssystem.\n\n---\n\n## bersicht\n\nHemlock bietet **strukturierte Nebenlufigkeit** mit echter Multi-Thread-Parallelitt unter Verwendung von POSIX-Threads (pthreads). Jeder gestartete Task luft auf einem separaten OS-Thread, was echte parallele Ausfhrung ber mehrere CPU-Kerne ermglicht.\n\n**Hauptmerkmale:**\n- Echte Multi-Thread-Parallelitt (keine Green Threads)\n- Async-Funktionssyntax\n- Task-Starten und -Beitreten\n- Thread-sichere Kanle\n- Ausnahme-Propagierung\n\n**Threading-Modell:**\n- Echte OS-Threads (POSIX pthreads)\n- Echte Parallelitt (mehrere CPU-Kerne)\n- Kernel-geplant (praeemptives Multitasking)\n- Thread-sichere Synchronisation (Mutexes, Bedingungsvariablen)\n\n---\n\n## Async-Funktionen\n\n### Async-Funktionsdeklaration\n\nFunktionen knnen als `async` deklariert werden um anzuzeigen, dass sie fr nebenlaeufige Ausfhrung konzipiert sind.\n\n**Syntax:**\n```hemlock\nasync fn function_name(params): return_type {\n    // Funktionskrper\n}\n```\n\n**Beispiele:**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nasync fn process_data(data: string) {\n    print(\"Verarbeite:\", data);\n    return null;\n}\n```\n\n**Verhalten:**\n- `async fn` deklariert eine asynchrone Funktion\n- Kann synchron aufgerufen werden (luft im aktuellen Thread)\n- Kann als nebenlaeufiger Task gestartet werden (luft auf neuem Thread)\n- Wenn gestartet, luft auf eigenem OS-Thread\n\n**Hinweis:** Das `await`-Schlsselwort ist fr zukuenftige Verwendung reserviert, aber derzeit nicht implementiert.\n\n---\n\n## Task-Verwaltung\n\n### spawn\n\nErstellt und startet einen neuen nebenlaeufigen Task.\n\n**Signatur:**\n```hemlock\nspawn(async_fn: function, ...args): task\n```\n\n**Parameter:**\n- `async_fn` - Auszufuehrende Async-Funktion\n- `...args` - An die Funktion zu uebergebende Argumente\n\n**Rckgabe:** Task-Handle\n\n**Beispiele:**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Einzelnen Task starten\nlet t = spawn(compute, 1000);\nlet result = join(t);\nprint(result);\n\n// Mehrere Tasks starten (laufen parallel!)\nlet t1 = spawn(compute, 100);\nlet t2 = spawn(compute, 200);\nlet t3 = spawn(compute, 300);\n\n// Alle drei laufen gleichzeitig\nlet r1 = join(t1);\nlet r2 = join(t2);\nlet r3 = join(t3);\n```\n\n**Verhalten:**\n- Erstellt neuen OS-Thread via `pthread_create()`\n- Beginnt sofort mit der Ausfhrung der Funktion\n- Gibt Task-Handle fr spaeteres Beitreten zurck\n- Tasks laufen parallel auf separaten CPU-Kernen\n\n---\n\n### join\n\nWartet auf Task-Abschluss und ruft Ergebnis ab.\n\n**Signatur:**\n```hemlock\njoin(task: task): any\n```\n\n**Parameter:**\n- `task` - Task-Handle von `spawn()`\n\n**Rckgabe:** Rckgabewert des Tasks\n\n**Beispiele:**\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nlet t = spawn(factorial, 10);\nlet result = join(t);  // Blockiert bis Task fertig\nprint(result);         // 3628800\n```\n\n**Verhalten:**\n- Blockiert aktuellen Thread bis Task abgeschlossen\n- Gibt Rckgabewert des Tasks zurck\n- Propagiert vom Task geworfene Ausnahmen\n- Raeumt Task-Ressourcen nach Rckkehr auf\n\n**Fehlerbehandlung:**\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task fehlgeschlagen!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Abgefangen:\", e);  // \"Abgefangen: Task fehlgeschlagen!\"\n}\n```\n\n---\n\n### detach\n\nLoest Task ab (Fire-and-Forget-Ausfhrung).\n\n**Signatur:**\n```hemlock\ndetach(task: task): null\n```\n\n**Parameter:**\n- `task` - Task-Handle von `spawn()`\n\n**Rckgabe:** `null`\n\n**Beispiele:**\n```hemlock\nasync fn background_work() {\n    print(\"Arbeite im Hintergrund...\");\n    return null;\n}\n\nlet t = spawn(background_work);\ndetach(t);  // Task luft unabhngig weiter\n\n// Kann abgeloesten Task nicht beitreten\n// join(t);  // FEHLER\n```\n\n**Verhalten:**\n- Task luft unabhngig weiter\n- Kann abgeloesten Task nicht `join()`en\n- Task und Thread werden automatisch aufgeraeumt wenn Task abgeschlossen\n\n**Anwendungsfaelle:**\n- Fire-and-Forget-Hintergrundtasks\n- Logging/Monitoring-Tasks\n- Tasks die keine Werte zurckgeben mssen\n\n---\n\n## Kanle\n\nKanle bieten thread-sichere Kommunikation zwischen Tasks.\n\n### channel\n\nErstellt einen gepufferten Kanal.\n\n**Signatur:**\n```hemlock\nchannel(capacity: i32): channel\n```\n\n**Parameter:**\n- `capacity` - Puffergroesse (Anzahl der Werte)\n\n**Rckgabe:** Kanal-Objekt\n\n**Beispiele:**\n```hemlock\nlet ch = channel(10);  // Gepufferter Kanal mit Kapazitt 10\nlet ch2 = channel(1);  // Minimaler Puffer (synchron)\nlet ch3 = channel(100); // Grosser Puffer\n```\n\n**Verhalten:**\n- Erstellt thread-sicheren Kanal\n- Verwendet pthread-Mutexes zur Synchronisation\n- Kapazitt ist bei Erstellung fest\n\n---\n\n### Kanal-Methoden\n\n#### send\n\nSendet Wert an Kanal (blockiert wenn voll).\n\n**Signatur:**\n```hemlock\nchannel.send(value: any): null\n```\n\n**Parameter:**\n- `value` - Zu sendender Wert (beliebiger Typ)\n\n**Rckgabe:** `null`\n\n**Beispiele:**\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet t = spawn(producer, ch, 5);\n```\n\n**Verhalten:**\n- Sendet Wert an Kanal\n- Blockiert wenn Kanal voll\n- Thread-sicher (verwendet Mutex)\n- Gibt zurck nachdem Wert gesendet wurde\n\n---\n\n#### recv\n\nEmpfaengt Wert von Kanal (blockiert wenn leer).\n\n**Signatur:**\n```hemlock\nchannel.recv(): any\n```\n\n**Rckgabe:** Wert vom Kanal, oder `null` wenn Kanal geschlossen und leer\n\n**Beispiele:**\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet t = spawn(consumer, ch, 5);\n```\n\n**Verhalten:**\n- Empfaengt Wert vom Kanal\n- Blockiert wenn Kanal leer\n- Gibt `null` zurck wenn Kanal geschlossen und leer\n- Thread-sicher (verwendet Mutex)\n\n---\n\n#### close\n\nSchliesst Kanal (keine weiteren Sends erlaubt).\n\n**Signatur:**\n```hemlock\nchannel.close(): null\n```\n\n**Rckgabe:** `null`\n\n**Beispiele:**\n```hemlock\nasync fn producer(ch) {\n    ch.send(1);\n    ch.send(2);\n    ch.send(3);\n    ch.close();  // Signalisiert keine weiteren Werte\n    return null;\n}\n\nasync fn consumer(ch) {\n    while (true) {\n        let val = ch.recv();\n        if (val == null) {\n            break;  // Kanal geschlossen\n        }\n        print(val);\n    }\n    return null;\n}\n```\n\n**Verhalten:**\n- Schliesst Kanal\n- Keine weiteren Sends erlaubt\n- `recv()` gibt `null` zurck wenn Kanal leer\n- Thread-sicher\n\n---\n\n## Vollstaendiges Nebenlaeufigkeitsbeispiel\n\n### Producer-Consumer-Muster\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        print(\"Produziere:\", i);\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        print(\"Konsumiere:\", val);\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Kanal erstellen\nlet ch = channel(10);\n\n// Producer und Consumer starten\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Auf Abschluss warten\njoin(p);\nlet total = join(c);\nprint(\"Gesamt:\", total);  // 0+10+20+30+40 = 100\n```\n\n---\n\n## Parallele Berechnung\n\n### Beispiel mit mehreren Tasks\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Mehrere Tasks starten (laufen parallel!)\nlet t1 = spawn(factorial, 5);   // Thread 1\nlet t2 = spawn(factorial, 6);   // Thread 2\nlet t3 = spawn(factorial, 7);   // Thread 3\nlet t4 = spawn(factorial, 8);   // Thread 4\n\n// Alle vier berechnen gleichzeitig!\n\n// Auf Ergebnisse warten\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\nlet f8 = join(t4);  // 40320\n\nprint(f5, f6, f7, f8);\n```\n\n---\n\n## Task-Lebenszyklus\n\n### Zustandsuebergaenge\n\n1. **Erstellt** - Task gestartet aber noch nicht laufend\n2. **Laufend** - Task luft auf OS-Thread\n3. **Abgeschlossen** - Task beendet (Ergebnis verfgbar)\n4. **Beigetreten** - Ergebnis abgerufen, Ressourcen aufgeraeumt\n5. **Abgeloest** - Task luft unabhngig weiter\n\n### Lebenszyklus-Beispiel\n\n```hemlock\nasync fn work(n: i32): i32 {\n    return n * 2;\n}\n\n// 1. Task erstellen\nlet t = spawn(work, 21);  // Zustand: Laufend\n\n// Task luft auf separatem Thread...\n\n// 2. Task beitreten\nlet result = join(t);     // Zustand: Abgeschlossen  Beigetreten\nprint(result);            // 42\n\n// Task-Ressourcen nach join aufgeraeumt\n```\n\n### Abgeloester Lebenszyklus\n\n```hemlock\nasync fn background() {\n    print(\"Hintergrund-Task luft\");\n    return null;\n}\n\n// 1. Task erstellen\nlet t = spawn(background);  // Zustand: Laufend\n\n// 2. Task abloesen\ndetach(t);                  // Zustand: Abgeloest\n\n// Task luft unabhngig weiter\n// Ressourcen werden vom OS aufgeraeumt wenn fertig\n```\n\n---\n\n## Fehlerbehandlung\n\n### Ausnahme-Propagierung\n\nAusnahmen die in Tasks geworfen werden, werden beim Beitreten propagiert:\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task fehlgeschlagen!\";\n    }\n    return 42;\n}\n\n// Task der erfolgreich ist\nlet t1 = spawn(risky_operation, 0);\nlet result1 = join(t1);  // 42\n\n// Task der fehlschlaegt\nlet t2 = spawn(risky_operation, 1);\ntry {\n    let result2 = join(t2);\n} catch (e) {\n    print(\"Abgefangen:\", e);  // \"Abgefangen: Task fehlgeschlagen!\"\n}\n```\n\n### Umgang mit mehreren Tasks\n\n```hemlock\nasync fn work(id: i32, should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task \" + typeof(id) + \" fehlgeschlagen\";\n    }\n    return id * 10;\n}\n\nlet t1 = spawn(work, 1, 0);\nlet t2 = spawn(work, 2, 1);  // Wird fehlschlagen\nlet t3 = spawn(work, 3, 0);\n\n// Beitreten mit Fehlerbehandlung\ntry {\n    let r1 = join(t1);  // OK\n    print(\"Task 1:\", r1);\n\n    let r2 = join(t2);  // Wirft\n    print(\"Task 2:\", r2);  // Nie erreicht\n} catch (e) {\n    print(\"Fehler:\", e);  // \"Fehler: Task 2 fehlgeschlagen\"\n}\n\n// Kann verbleibenden Task noch beitreten\nlet r3 = join(t3);\nprint(\"Task 3:\", r3);\n```\n\n---\n\n## Leistungscharakteristiken\n\n### Echte Parallelitt\n\n```hemlock\nasync fn cpu_intensive(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Sequentielle Ausfhrung\nlet start = get_time();\nlet r1 = cpu_intensive(10000000);\nlet r2 = cpu_intensive(10000000);\nlet sequential_time = get_time() - start;\n\n// Parallele Ausfhrung\nlet start2 = get_time();\nlet t1 = spawn(cpu_intensive, 10000000);\nlet t2 = spawn(cpu_intensive, 10000000);\njoin(t1);\njoin(t2);\nlet parallel_time = get_time() - start2;\n\n// parallel_time sollte ~50% von sequential_time auf Multi-Core-Systemen sein\n```\n\n**Bewiesene Charakteristiken:**\n- N Tasks knnen N CPU-Kerne gleichzeitig nutzen\n- Stresstests zeigen 8-9x CPU-Zeit vs. Wandzeit (Beweis der Parallelitt)\n- Thread-Overhead: ~8KB Stack + pthread-Overhead pro Task\n- Blockierende Operationen in einem Task blockieren andere nicht\n\n---\n\n## Implementierungsdetails\n\n### Threading-Modell\n\n- **1:1 Threading** - Jeder Task = 1 OS-Thread (`pthread`)\n- **Kernel-geplant** - OS-Kernel verteilt Threads auf Kerne\n- **Praeemptives Multitasking** - OS kann Threads unterbrechen und wechseln\n- **Kein GIL** - Kein Global Interpreter Lock (anders als Python)\n\n### Synchronisation\n\n- **Mutexes** - Kanle verwenden `pthread_mutex_t`\n- **Bedingungsvariablen** - Blockierendes send/recv verwendet `pthread_cond_t`\n- **Lock-freie Operationen** - Task-Zustandsuebergaenge sind atomar\n\n### Speicher & Aufraeumen\n\n- **Beigetretene Tasks** - Automatisch aufgeraeumt nach `join()`\n- **Abgeloeste Tasks** - Automatisch aufgeraeumt wenn Task abgeschlossen\n- **Kanle** - Referenzgezhlt, freigegeben wenn nicht mehr verwendet\n\n---\n\n## Einschrnkungen\n\n- Kein `select()` fr Multiplexen mehrerer Kanle\n- Kein Work-Stealing-Scheduler (1 Thread pro Task)\n- Keine async I/O-Integration (Datei/Netzwerk-Operationen blockieren)\n- Kanalkapazitaet bei Erstellung fest\n\n---\n\n## Vollstndige API-Zusammenfassung\n\n### Funktionen\n\n| Funktion  | Signatur                          | Rckgabe | Beschreibung                     |\n|-----------|-----------------------------------|-----------|----------------------------------|\n| `spawn`   | `(async_fn: function, ...args)`   | `task`    | Nebenlaeufigen Task erstellen und starten |\n| `join`    | `(task: task)`                    | `any`     | Auf Task warten, Ergebnis holen  |\n| `detach`  | `(task: task)`                    | `null`    | Task abloesen (Fire-and-Forget)  |\n| `channel` | `(capacity: i32)`                 | `channel` | Thread-sicheren Kanal erstellen  |\n\n### Kanal-Methoden\n\n| Methode | Signatur        | Rckgabe | Beschreibung                       |\n|---------|-----------------|-----------|-----------------------------------|\n| `send`  | `(value: any)`  | `null`    | Wert senden (blockiert wenn voll) |\n| `recv`  | `()`            | `any`     | Wert empfangen (blockiert wenn leer) |\n| `close` | `()`            | `null`    | Kanal schlieen                  |\n\n### Typen\n\n| Typ       | Beschreibung                         |\n|-----------|--------------------------------------|\n| `task`    | Handle fr nebenlaeufigen Task      |\n| `channel` | Thread-sicherer Kommunikationskanal  |\n\n---\n\n## Best Practices\n\n### Empfohlen\n\n- Verwenden Sie Kanle fr Kommunikation zwischen Tasks\n- Behandeln Sie Ausnahmen von beigetretenen Tasks\n- Schlieen Sie Kanle wenn Senden beendet\n- Verwenden Sie `join()` um Ergebnisse zu holen und aufzuraeumen\n- Starten Sie nur async-Funktionen\n\n### Vermeiden\n\n- Teilen Sie keinen veraenderbaren Zustand ohne Synchronisation\n- Treten Sie demselben Task nicht zweimal bei\n- Senden Sie nicht auf geschlossenen Kanaelen\n- Starten Sie keine nicht-async-Funktionen\n- Vergessen Sie nicht Tasks beizutreten (auer wenn abgeloest)\n\n---\n\n## Siehe auch\n\n- [Eingebaute Funktionen](#reference-builtins) - `spawn()`, `join()`, `detach()`, `channel()`\n- [Typsystem](#reference-type-system) - Task- und Kanal-Typen\n"}, "API-Referenz -> Operatoren": {"id": "reference-operators", "content": "# Operatoren-Referenz\n\nVollstndige Referenz fr alle Operatoren in Hemlock, einschlielich Przedenz, Assoziativitaet und Verhalten.\n\n---\n\n## bersicht\n\nHemlock bietet C-hnliche Operatoren mit expliziten Praezedenzregeln. Alle Operatoren folgen strikten Typisierungsregeln mit automatischer Typpromovierung wo anwendbar.\n\n---\n\n## Arithmetische Operatoren\n\n### Binre Arithmetik\n\n| Operator | Name            | Beispiel   | Beschreibung               |\n|----------|-----------------|------------|----------------------------|\n| `+`      | Addition        | `a + b`    | Zwei Werte addieren        |\n| `-`      | Subtraktion     | `a - b`    | b von a subtrahieren       |\n| `*`      | Multiplikation  | `a * b`    | Zwei Werte multiplizieren  |\n| `/`      | Division        | `a / b`    | a durch b dividieren       |\n\n**Typpromovierung:**\nErgebnisse folgen Typpromovierungsregeln (siehe [Typsystem](type-system.md#type-promotion-rules)).\n\n**Beispiele:**\n```hemlock\nlet a = 10 + 5;        // 15 (i32)\nlet b = 10 - 3;        // 7 (i32)\nlet c = 4 * 5;         // 20 (i32)\nlet d = 20 / 4;        // 5 (i32)\n\n// Gleitkomma-Division\nlet e = 10.0 / 3.0;    // 3.333... (f64)\n\n// Gemischte Typen\nlet f: u8 = 10;\nlet g: i32 = 20;\nlet h = f + g;         // 30 (i32, promoviert)\n```\n\n**Division durch Null:**\n- Ganzzahl-Division durch Null: Laufzeitfehler\n- Gleitkomma-Division durch Null: Gibt `inf` oder `-inf` zurck\n\n---\n\n### Unaere Arithmetik\n\n| Operator | Name     | Beispiel | Beschreibung          |\n|----------|----------|----------|-----------------------|\n| `-`      | Negation | `-a`     | Wert negieren         |\n| `+`      | Plus     | `+a`     | Identitt (keine nderung) |\n\n**Beispiele:**\n```hemlock\nlet a = 5;\nlet b = -a;            // -5\nlet c = +a;            // 5 (keine nderung)\n\nlet x = -3.14;         // -3.14\n```\n\n---\n\n## Vergleichsoperatoren\n\n| Operator | Name                    | Beispiel   | Rckgabe |\n|----------|-------------------------|------------|-----------|\n| `==`     | Gleich                  | `a == b`   | `bool`    |\n| `!=`     | Ungleich                | `a != b`   | `bool`    |\n| `<`      | Kleiner als             | `a < b`    | `bool`    |\n| `>`      | Grer als            | `a > b`    | `bool`    |\n| `<=`     | Kleiner oder gleich     | `a <= b`   | `bool`    |\n| `>=`     | Grer oder gleich    | `a >= b`   | `bool`    |\n\n**Typpromovierung:**\nOperanden werden vor Vergleich promoviert.\n\n**Beispiele:**\n```hemlock\nprint(5 == 5);         // true\nprint(10 != 5);        // true\nprint(3 < 7);          // true\nprint(10 > 5);         // true\nprint(5 <= 5);         // true\nprint(10 >= 5);        // true\n\n// String-Vergleich\nprint(\"hello\" == \"hello\");  // true\nprint(\"abc\" < \"def\");       // true (lexikografisch)\n\n// Gemischte Typen\nlet a: u8 = 10;\nlet b: i32 = 10;\nprint(a == b);         // true (auf i32 promoviert)\n```\n\n---\n\n## Logische Operatoren\n\n| Operator | Name         | Beispiel     | Beschreibung              |\n|----------|--------------|--------------|---------------------------|\n| `&&`     | Logisches UND| `a && b`     | Wahr wenn beide wahr      |\n| `||`     | Logisches ODER| `a || b`    | Wahr wenn einer wahr      |\n| `!`      | Logisches NICHT| `!a`       | Boolean negieren          |\n\n**Kurzschluss-Auswertung:**\n- `&&` - Stoppt beim ersten falschen Wert\n- `||` - Stoppt beim ersten wahren Wert\n\n**Beispiele:**\n```hemlock\nlet a = true;\nlet b = false;\n\nprint(a && b);         // false\nprint(a || b);         // true\nprint(!a);             // false\nprint(!b);             // true\n\n// Kurzschluss\nif (x != 0 && (10 / x) > 2) {\n    print(\"sicher\");\n}\n\nif (x == 0 || (10 / x) > 2) {\n    print(\"sicher\");\n}\n```\n\n---\n\n## Bitweise Operatoren\n\n**Einschrnkung:** Nur Ganzzahltypen (i8-i64, u8-u64)\n\n### Binre Bitweise\n\n| Operator | Name           | Beispiel   | Beschreibung              |\n|----------|----------------|------------|---------------------------|\n| `&`      | Bitweises UND  | `a & b`    | UND jedes Bit             |\n| `|`      | Bitweises ODER | `a | b`    | ODER jedes Bit            |\n| `^`      | Bitweises XOR  | `a ^ b`    | XOR jedes Bit             |\n| `<<`     | Linksverschiebung | `a << b` | Um b Bits nach links verschieben |\n| `>>`     | Rechtsverschiebung| `a >> b` | Um b Bits nach rechts verschieben |\n\n**Typerhaltung:**\nErgebnistyp entspricht Operandentypen (mit Typpromovierung).\n\n**Beispiele:**\n```hemlock\nlet a = 12;  // 1100 in Binr\nlet b = 10;  // 1010 in Binr\n\nprint(a & b);          // 8  (1000)\nprint(a | b);          // 14 (1110)\nprint(a ^ b);          // 6  (0110)\nprint(a << 2);         // 48 (110000)\nprint(a >> 1);         // 6  (110)\n```\n\n**Beispiel mit Unsigned:**\n```hemlock\nlet c: u8 = 15;        // 00001111\nlet d: u8 = 7;         // 00000111\n\nprint(c & d);          // 7  (00000111)\nprint(c | d);          // 15 (00001111)\nprint(c ^ d);          // 8  (00001000)\n```\n\n**Rechtsverschiebungs-Verhalten:**\n- Vorzeichenbehaftete Typen: Arithmetische Verschiebung (Vorzeichenerweiterung)\n- Vorzeichenlose Typen: Logische Verschiebung (Null-Fuellung)\n\n---\n\n### Unaere Bitweise\n\n| Operator | Name          | Beispiel | Beschreibung              |\n|----------|---------------|----------|---------------------------|\n| `~`      | Bitweises NICHT| `~a`    | Alle Bits umkehren        |\n\n**Beispiele:**\n```hemlock\nlet a = 12;            // 00001100 (i32)\nprint(~a);             // -13 (Zweierkomplement)\n\nlet b: u8 = 15;        // 00001111\nprint(~b);             // 240 (11110000)\n```\n\n---\n\n## String-Operatoren\n\n### Verkettung\n\n| Operator | Name        | Beispiel   | Beschreibung        |\n|----------|-------------|------------|---------------------|\n| `+`      | Verkettung  | `a + b`    | Strings verbinden   |\n\n**Beispiele:**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n\n// String + Rune\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\n\n// Rune + String\nlet prefix = '>' + \" Message\";     // \"> Message\"\n```\n\n---\n\n## Zuweisungsoperatoren\n\n### Einfache Zuweisung\n\n| Operator | Name       | Beispiel   | Beschreibung                  |\n|----------|------------|------------|-------------------------------|\n| `=`      | Zuweisung  | `a = b`    | Wert an Variable zuweisen     |\n\n**Beispiele:**\n```hemlock\nlet x = 10;\nx = 20;\n\nlet arr = [1, 2, 3];\narr[0] = 99;\n\nlet obj = { x: 10 };\nobj.x = 20;\n```\n\n### Zusammengesetzte Zuweisung\n\n#### Arithmetische zusammengesetzte Zuweisung\n\n| Operator | Name               | Beispiel   | quivalent        |\n|----------|--------------------|------------|--------------------|\n| `+=`     | Addieren und zuweisen | `a += b` | `a = a + b`        |\n| `-=`     | Subtrahieren und zuweisen | `a -= b` | `a = a - b`    |\n| `*=`     | Multiplizieren und zuweisen | `a *= b` | `a = a * b`  |\n| `/=`     | Dividieren und zuweisen | `a /= b` | `a = a / b`      |\n| `%=`     | Modulo und zuweisen | `a %= b`   | `a = a % b`        |\n\n**Beispiele:**\n```hemlock\nlet x = 10;\nx += 5;      // x ist jetzt 15\nx -= 3;      // x ist jetzt 12\nx *= 2;      // x ist jetzt 24\nx /= 4;      // x ist jetzt 6\n\nlet count = 0;\ncount += 1;  // Um 1 erhhen\n```\n\n#### Bitweise zusammengesetzte Zuweisung\n\n| Operator | Name                      | Beispiel    | quivalent         |\n|----------|---------------------------|-------------|---------------------|\n| `&=`     | Bitweises UND und zuweisen | `a &= b`   | `a = a & b`         |\n| `\\|=`    | Bitweises ODER und zuweisen| `a \\|= b`  | `a = a \\| b`        |\n| `^=`     | Bitweises XOR und zuweisen | `a ^= b`   | `a = a ^ b`         |\n| `<<=`    | Linksverschiebung und zuweisen | `a <<= b` | `a = a << b`     |\n| `>>=`    | Rechtsverschiebung und zuweisen | `a >>= b` | `a = a >> b`   |\n\n**Beispiele:**\n```hemlock\nlet flags = 0b1111;\nflags &= 0b0011;   // flags ist jetzt 0b0011 (obere Bits maskieren)\nflags |= 0b1000;   // flags ist jetzt 0b1011 (Bit setzen)\nflags ^= 0b0001;   // flags ist jetzt 0b1010 (Bit umschalten)\n\nlet x = 1;\nx <<= 4;           // x ist jetzt 16 (um 4 nach links verschieben)\nx >>= 2;           // x ist jetzt 4 (um 2 nach rechts verschieben)\n```\n\n### Inkrement/Dekrement\n\n| Operator | Name       | Beispiel | Beschreibung                  |\n|----------|------------|----------|-------------------------------|\n| `++`     | Inkrement  | `a++`    | Um 1 erhhen (Postfix)       |\n| `--`     | Dekrement  | `a--`    | Um 1 verringern (Postfix)     |\n\n**Beispiele:**\n```hemlock\nlet i = 0;\ni++;         // i ist jetzt 1\ni++;         // i ist jetzt 2\ni--;         // i ist jetzt 1\n\n// Hufig in Schleifen\nfor (let j = 0; j < 10; j++) {\n    print(j);\n}\n```\n\n**Hinweis:** Sowohl `++` als auch `--` sind Postfix-Operatoren (Wert wird vor Inkrement/Dekrement zurckgegeben)\n\n---\n\n## Null-Sicherheitsoperatoren\n\n### Null-Koaleszenz (`??`)\n\nGibt den linken Operanden zurck wenn er nicht null ist, sonst den rechten Operanden.\n\n| Operator | Name             | Beispiel     | Beschreibung                    |\n|----------|------------------|--------------|--------------------------------|\n| `??`     | Null-Koaleszenz  | `a ?? b`     | a zurckgeben wenn nicht null, sonst b |\n\n**Beispiele:**\n```hemlock\nlet name = null;\nlet display = name ?? \"Anonym\";  // \"Anonym\"\n\nlet value = 42;\nlet result = value ?? 0;            // 42\n\n// Verkettung\nlet a = null;\nlet b = null;\nlet c = \"gefunden\";\nlet result2 = a ?? b ?? c;          // \"gefunden\"\n\n// Mit Funktionsaufrufen\nfn get_config() { return null; }\nlet config = get_config() ?? { default: true };\n```\n\n---\n\n### Optionale Verkettung (`?.`)\n\nSicherer Zugriff auf Eigenschaften oder Aufruf von Methoden auf potenziell null-Werten.\n\n| Operator | Name                 | Beispiel       | Beschreibung                      |\n|----------|----------------------|----------------|-----------------------------------|\n| `?.`     | Optionale Verkettung | `a?.b`         | a.b zurckgeben wenn a nicht null, sonst null |\n| `?.[`    | Optionaler Index     | `a?.[0]`       | a[0] zurckgeben wenn a nicht null, sonst null |\n| `?.(`    | Optionaler Aufruf    | `a?.()`        | a() aufrufen wenn a nicht null, sonst null |\n\n**Beispiele:**\n```hemlock\nlet user = null;\nlet name = user?.name;              // null (kein Fehler)\n\nlet person = { name: \"Alice\", address: null };\nlet city = person?.address?.city;   // null (sichere Navigation)\n\n// Mit Arrays\nlet arr = null;\nlet first = arr?.[0];               // null\n\nlet items = [1, 2, 3];\nlet second = items?.[1];            // 2\n\n// Mit Methodenaufrufen\nlet obj = { greet: fn() { return \"Hallo\"; } };\nlet greeting = obj?.greet?.();      // \"Hallo\"\n\nlet empty = null;\nlet result = empty?.method?.();     // null\n```\n\n**Verhalten:**\n- Wenn linker Operand null, wird gesamter Ausdruck auf null kurzgeschlossen\n- Wenn linker Operand nicht null, wird Zugriff normal durchgefhrt\n- Kann fr tiefen Eigenschaftszugriff verkettet werden\n\n---\n\n## Elementzugriffsoperatoren\n\n### Punkt-Operator\n\n| Operator | Name               | Beispiel     | Beschreibung           |\n|----------|--------------------|--------------|-----------------------|\n| `.`      | Elementzugriff     | `obj.field`  | Objektfeld zugreifen   |\n| `.`      | Eigenschaftszugriff| `arr.length` | Eigenschaft zugreifen  |\n\n**Beispiele:**\n```hemlock\n// Objektfeld-Zugriff\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);        // \"Alice\"\n\n// Array-Eigenschaft\nlet arr = [1, 2, 3];\nprint(arr.length);         // 3\n\n// String-Eigenschaft\nlet s = \"hello\";\nprint(s.length);           // 5\n\n// Methodenaufruf\nlet result = s.to_upper(); // \"HELLO\"\n```\n\n---\n\n### Index-Operator\n\n| Operator | Name    | Beispiel  | Beschreibung          |\n|----------|---------|-----------|----------------------|\n| `[]`     | Index   | `arr[i]`  | Element zugreifen     |\n\n**Beispiele:**\n```hemlock\n// Array-Indizierung\nlet arr = [10, 20, 30];\nprint(arr[0]);             // 10\narr[1] = 99;\n\n// String-Indizierung (gibt Rune zurck)\nlet s = \"hello\";\nprint(s[0]);               // 'h'\ns[0] = 'H';                // \"Hello\"\n\n// Buffer-Indizierung\nlet buf = buffer(10);\nbuf[0] = 65;\nprint(buf[0]);             // 65\n```\n\n---\n\n## Funktionsaufruf-Operator\n\n| Operator | Name           | Beispiel     | Beschreibung        |\n|----------|----------------|--------------|---------------------|\n| `()`     | Funktionsaufruf| `f(a, b)`    | Funktion aufrufen   |\n\n**Beispiele:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet result = add(5, 3);    // 8\n\n// Methodenaufruf\nlet s = \"hello\";\nlet upper = s.to_upper();  // \"HELLO\"\n\n// Eingebauter Aufruf\nprint(\"message\");\n```\n\n---\n\n## Operatorpraezedenz\n\nOperatoren von hoechster zu niedrigster Przedenz:\n\n| Przedenz | Operatoren                 | Beschreibung                    | Assoziativitaet |\n|------------|----------------------------|--------------------------------|----------------|\n| 1          | `()` `[]` `.` `?.`         | Aufruf, Index, Elementzugriff, optionale Verkettung | Links-nach-rechts |\n| 2          | `++` `--`                  | Postfix-Inkrement/Dekrement    | Links-nach-rechts |\n| 3          | `!` `~` `-` (unaer) `+` (unaer) | Logisches NICHT, bitweises NICHT, Negation | Rechts-nach-links |\n| 4          | `*` `/` `%`                | Multiplikation, Division, Modulo | Links-nach-rechts |\n| 5          | `+` `-`                    | Addition, Subtraktion          | Links-nach-rechts |\n| 6          | `<<` `>>`                  | Bitverschiebungen              | Links-nach-rechts |\n| 7          | `<` `<=` `>` `>=`          | Relational                     | Links-nach-rechts |\n| 8          | `==` `!=`                  | Gleichheit                     | Links-nach-rechts |\n| 9          | `&`                        | Bitweises UND                  | Links-nach-rechts |\n| 10         | `^`                        | Bitweises XOR                  | Links-nach-rechts |\n| 11         | `|`                        | Bitweises ODER                 | Links-nach-rechts |\n| 12         | `&&`                       | Logisches UND                  | Links-nach-rechts |\n| 13         | `||`                       | Logisches ODER                 | Links-nach-rechts |\n| 14         | `??`                       | Null-Koaleszenz                | Links-nach-rechts |\n| 15         | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\\|=` `^=` `<<=` `>>=` | Zuweisung | Rechts-nach-links |\n\n---\n\n## Przedenz-Beispiele\n\n### Beispiel 1: Arithmetik und Vergleich\n```hemlock\nlet result = 5 + 3 * 2;\n// Ausgewertet als: 5 + (3 * 2) = 11\n// Multiplikation hat hhere Przedenz als Addition\n\nlet cmp = 10 > 5 + 3;\n// Ausgewertet als: 10 > (5 + 3) = true\n// Addition hat hhere Przedenz als Vergleich\n```\n\n### Beispiel 2: Bitweise Operatoren\n```hemlock\nlet result1 = 12 | 10 & 8;\n// Ausgewertet als: 12 | (10 & 8) = 12 | 8 = 12\n// & hat hhere Przedenz als |\n\nlet result2 = 8 | 1 << 2;\n// Ausgewertet als: 8 | (1 << 2) = 8 | 4 = 12\n// Verschiebung hat hhere Przedenz als bitweises ODER\n\n// Klammern fr Klarheit verwenden\nlet result3 = (5 & 3) | (2 << 1);\n// Ausgewertet als: 1 | 4 = 5\n```\n\n### Beispiel 3: Logische Operatoren\n```hemlock\nlet result = true || false && false;\n// Ausgewertet als: true || (false && false) = true\n// && hat hhere Przedenz als ||\n\nlet cmp = 5 < 10 && 10 < 20;\n// Ausgewertet als: (5 < 10) && (10 < 20) = true\n// Vergleich hat hhere Przedenz als &&\n```\n\n### Beispiel 4: Klammern verwenden\n```hemlock\n// Ohne Klammern\nlet a = 2 + 3 * 4;        // 14\n\n// Mit Klammern\nlet b = (2 + 3) * 4;      // 20\n\n// Komplexer Ausdruck\nlet c = (a + b) * (a - b);\n```\n\n---\n\n## Typspezifisches Operatorverhalten\n\n### Division (immer Gleitkomma)\n\nDer `/`-Operator **gibt immer eine Gleitkommazahl zurck** (f64), unabhngig von Operandentypen:\n\n```hemlock\nprint(10 / 3);             // 3.333... (f64)\nprint(5 / 2);              // 2.5 (f64)\nprint(10.0 / 4.0);         // 2.5 (f64)\nprint(-7 / 3);             // -2.333... (f64)\n```\n\nDies verhindert den haeufigen Bug unerwarteter Ganzzahl-Trunkierung.\n\n### Ganzzahl-Division (div / divi)\n\nFr Ganzzahl-Division (wie Integer-Division in anderen Sprachen) verwenden Sie die `div()` und `divi()` Funktionen:\n\n```hemlock\n// div(a, b) - Ganzzahl-Division gibt Gleitkomma zurck\nprint(div(5, 2));          // 2 (f64)\nprint(div(-7, 3));         // -3 (f64)  -- rundet Richtung -unendlich\n\n// divi(a, b) - Ganzzahl-Division gibt Ganzzahl zurck\nprint(divi(5, 2));         // 2 (i64)\nprint(divi(-7, 3));        // -3 (i64)\nprint(typeof(divi(5, 2))); // i64\n```\n\n**Ganzzahl-zurueckgebende Mathematikfunktionen:**\nFr andere Rundungsoperationen die Ganzzahlen zurckgeben:\n\n```hemlock\nprint(floori(3.7));        // 3 (i64)\nprint(ceili(3.2));         // 4 (i64)\nprint(roundi(3.5));        // 4 (i64)\nprint(trunci(3.9));        // 3 (i64)\n\n// Diese knnen direkt als Array-Indizes verwendet werden\nlet arr = [10, 20, 30, 40];\nprint(arr[floori(1.9)]);   // 20 (Index 1)\n```\n\n### String-Vergleich\n\nStrings werden lexikografisch verglichen:\n\n```hemlock\nprint(\"abc\" < \"def\");      // true\nprint(\"apple\" > \"banana\"); // false\nprint(\"hello\" == \"hello\"); // true\n```\n\n### Null-Vergleich\n\n```hemlock\nlet x = null;\n\nprint(x == null);          // true\nprint(x != null);          // false\n```\n\n### Typfehler\n\nManche Operationen sind zwischen inkompatiblen Typen nicht erlaubt:\n\n```hemlock\n// FEHLER: Kann bitweise Operatoren nicht auf Gleitkomma anwenden\nlet x = 3.14 & 2.71;\n\n// FEHLER: Kann bitweise Operatoren nicht auf Strings anwenden\nlet y = \"hello\" & \"world\";\n\n// OK: Typpromovierung fr Arithmetik\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet c = a + b;             // i32 (promoviert)\n```\n\n---\n\n## Siehe auch\n\n- [Typsystem](#reference-type-system) - Typpromovierungs- und Konvertierungsregeln\n- [Eingebaute Funktionen](#reference-builtins) - Eingebaute Operationen\n- [String-API](#reference-string-api) - String-Verkettung und -Methoden\n"}, "API-Referenz -> Speicher-API": {"id": "reference-memory-api", "content": "# Speicher-API-Referenz\n\nVollstndige Referenz fr Hemlocks Speicherverwaltungsfunktionen und Pointer-Typen.\n\n---\n\n## bersicht\n\nHemlock bietet **manuelle Speicherverwaltung** mit expliziter Allokation und Deallokation. Speicher wird durch zwei Pointer-Typen verwaltet: Roh-Pointer (`ptr`) und sichere Buffer (`buffer`).\n\n**Grundprinzipien:**\n- Explizite Allokation und Deallokation\n- Keine Garbage Collection\n- Benutzer verantwortlich fr Aufruf von `free()`\n- Interne Referenzzaehlung fr Scope/Neuzuweisungssicherheit (siehe unten)\n\n### Interne Referenzzaehlung\n\nDie Laufzeit verwendet Referenzzaehlung intern zur Verwaltung von Objektlebenszeiten ber Scopes. Fr die meisten lokalen Variablen ist die Bereinigung automatisch.\n\n**Automatisch (kein `free()` ntig):**\n- Lokale Variablen von referenzgezaehlten Typen (buffer, array, object, string) werden freigegeben wenn Scope endet\n- Alte Werte werden freigegeben wenn Variablen neu zugewiesen werden\n- Container-Elemente werden freigegeben wenn Container freigegeben werden\n\n**Manuelles `free()` erforderlich:**\n- Roh-Pointer von `alloc()` - immer\n- Fruehe Bereinigung vor Scope-Ende\n- Langlebige/globale Daten\n\nSiehe [Speicherverwaltungs-Leitfaden](../language-guide/memory.md#internal-reference-counting) fr Details.\n\n---\n\n## Pointer-Typen\n\n### ptr (Roh-Pointer)\n\n**Typ:** `ptr`\n\n**Beschreibung:** Rohe Speicheradresse ohne Grenzenprfung oder Verfolgung.\n\n**Gre:** 8 Bytes\n\n**Anwendungsfaelle:**\n- Low-Level-Speicheroperationen\n- FFI (Foreign Function Interface)\n- Maximale Leistung (kein Overhead)\n\n**Sicherheit:** Unsicher - keine Grenzenprfung, Benutzer muss Lebensdauer verfolgen\n\n**Beispiele:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n---\n\n### buffer (Sicherer Buffer)\n\n**Typ:** `buffer`\n\n**Beschreibung:** Sicherer Pointer-Wrapper mit Grenzenprfung.\n\n**Struktur:** Pointer + Lnge + Kapazitt + Referenzzaehler\n\n**Eigenschaften:**\n- `.length` - Buffergroesse (i32)\n- `.capacity` - Allokierte Kapazitt (i32)\n\n**Anwendungsfaelle:**\n- Die meisten Speicherallokationen\n- Wenn Sicherheit wichtig ist\n- Dynamische Arrays\n\n**Sicherheit:** Grenzenprfung bei Indexzugriff\n\n**Referenzzaehlung:** Buffer sind intern referenzgezhlt. Automatisch freigegeben wenn Scope endet oder Variable neu zugewiesen wird. Verwenden Sie `free()` fr fruehe Bereinigung oder langlebige Daten.\n\n**Beispiele:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Grenzenprfung\nprint(b.length);        // 64\nfree(b);\n```\n\n---\n\n## Speicherallokationsfunktionen\n\n### alloc\n\nAllokiert Roh-Speicher.\n\n**Signatur:**\n```hemlock\nalloc(size: i32): ptr\n```\n\n**Parameter:**\n- `size` - Anzahl der zu allokierenden Bytes\n\n**Rckgabe:** Pointer zum allokierten Speicher (`ptr`)\n\n**Beispiele:**\n```hemlock\nlet p = alloc(1024);        // 1KB allokieren\nmemset(p, 0, 1024);         // Auf Null initialisieren\nfree(p);                    // Wenn fertig freigeben\n\n// Fr Struktur allokieren\nlet struct_size = 16;\nlet p2 = alloc(struct_size);\n```\n\n**Verhalten:**\n- Gibt uninitialisierten Speicher zurck\n- Speicher muss manuell freigegeben werden\n- Gibt `null` bei Allokationsfehler zurck (Aufrufer muss prfen)\n\n**Siehe auch:** `buffer()` fr sicherere Alternative\n\n---\n\n### buffer\n\nAllokiert sicheren Buffer mit Grenzenprfung.\n\n**Signatur:**\n```hemlock\nbuffer(size: i32): buffer\n```\n\n**Parameter:**\n- `size` - Buffergroesse in Bytes\n\n**Rckgabe:** Buffer-Objekt\n\n**Beispiele:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\nprint(buf.capacity);        // 256\n\n// Zugriff mit Grenzenprfung\nbuf[0] = 65;                // 'A'\nbuf[255] = 90;              // 'Z'\n// buf[256] = 0;            // FEHLER: auerhalb der Grenzen\n\nfree(buf);\n```\n\n**Eigenschaften:**\n- `.length` - Aktuelle Gre (i32)\n- `.capacity` - Allokierte Kapazitt (i32)\n\n**Verhalten:**\n- Initialisiert Speicher auf Null\n- Bietet Grenzenprfung bei Indexzugriff\n- Gibt `null` bei Allokationsfehler zurck (Aufrufer muss prfen)\n- Muss manuell freigegeben werden\n\n---\n\n### free\n\nGibt allokierten Speicher frei.\n\n**Signatur:**\n```hemlock\nfree(ptr: ptr | buffer): null\n```\n\n**Parameter:**\n- `ptr` - Pointer oder Buffer zum Freigeben\n\n**Rckgabe:** `null`\n\n**Beispiele:**\n```hemlock\n// Roh-Pointer freigeben\nlet p = alloc(1024);\nfree(p);\n\n// Buffer freigeben\nlet buf = buffer(256);\nfree(buf);\n```\n\n**Verhalten:**\n- Gibt mit `alloc()` oder `buffer()` allokierten Speicher frei\n- Doppeltes Freigeben verursacht Absturz (Benutzerverantwortung zu vermeiden)\n- Freigeben ungltiger Pointer verursacht undefiniertes Verhalten\n\n**Wichtig:** Was Sie allokieren, geben Sie frei. Keine automatische Bereinigung.\n\n---\n\n### realloc\n\nAendert Gre von allokiertem Speicher.\n\n**Signatur:**\n```hemlock\nrealloc(ptr: ptr, new_size: i32): ptr\n```\n\n**Parameter:**\n- `ptr` - Pointer zur Groessenaenderung\n- `new_size` - Neue Gre in Bytes\n\n**Rckgabe:** Pointer zum vergroesserten Speicher (kann andere Adresse sein)\n\n**Beispiele:**\n```hemlock\nlet p = alloc(100);\n// ... Speicher verwenden ...\n\n// Mehr Platz bentigt\np = realloc(p, 200);        // Jetzt 200 Bytes\n// ... erweiterten Speicher verwenden ...\n\nfree(p);\n```\n\n**Verhalten:**\n- Kann Speicher an neue Position verschieben\n- Erhlt vorhandene Daten (bis Minimum aus alter/neuer Gre)\n- Alter Pointer ist nach erfolgreichem realloc ungltig (zurueckgegebenen Pointer verwenden)\n- Wenn new_size kleiner, werden Daten abgeschnitten\n- Gibt `null` bei Allokationsfehler zurck (Original-Pointer bleibt gltig)\n\n**Wichtig:** Immer auf `null` prfen und Pointer-Variable mit Ergebnis aktualisieren.\n\n---\n\n## Speicheroperationen\n\n### memset\n\nFuellt Speicher mit Byte-Wert.\n\n**Signatur:**\n```hemlock\nmemset(ptr: ptr, byte: i32, size: i32): null\n```\n\n**Parameter:**\n- `ptr` - Pointer zum Speicher\n- `byte` - Byte-Wert zum Fuellen (0-255)\n- `size` - Anzahl der zu fuellenden Bytes\n\n**Rckgabe:** `null`\n\n**Beispiele:**\n```hemlock\nlet p = alloc(100);\n\n// Speicher nullen\nmemset(p, 0, 100);\n\n// Mit bestimmtem Wert fuellen\nmemset(p, 0xFF, 100);\n\n// Buffer initialisieren\nlet buf = alloc(256);\nmemset(buf, 65, 256);       // Mit 'A' fuellen\n\nfree(p);\nfree(buf);\n```\n\n**Verhalten:**\n- Schreibt Byte-Wert in jedes Byte im Bereich\n- Byte-Wert wird auf 8 Bits abgeschnitten (0-255)\n- Keine Grenzenprfung (unsicher)\n\n---\n\n### memcpy\n\nKopiert Speicher von Quelle zu Ziel.\n\n**Signatur:**\n```hemlock\nmemcpy(dest: ptr, src: ptr, size: i32): null\n```\n\n**Parameter:**\n- `dest` - Ziel-Pointer\n- `src` - Quell-Pointer\n- `size` - Anzahl der zu kopierenden Bytes\n\n**Rckgabe:** `null`\n\n**Beispiele:**\n```hemlock\nlet src = alloc(100);\nlet dest = alloc(100);\n\n// Quelle initialisieren\nmemset(src, 65, 100);\n\n// Zum Ziel kopieren\nmemcpy(dest, src, 100);\n\n// dest enthlt jetzt gleiche Daten wie src\n\nfree(src);\nfree(dest);\n```\n\n**Verhalten:**\n- Kopiert Byte fr Byte von src zu dest\n- Keine Grenzenprfung (unsicher)\n- Ueberlappende Bereiche haben undefiniertes Verhalten (vorsichtig verwenden)\n\n---\n\n## Typisierte Speicheroperationen\n\n### sizeof\n\nGibt Gre eines Typs in Bytes zurck.\n\n**Signatur:**\n```hemlock\nsizeof(type): i32\n```\n\n**Parameter:**\n- `type` - Typ-Bezeichner (z.B. `i32`, `f64`, `ptr`)\n\n**Rckgabe:** Gre in Bytes (i32)\n\n**Typgroessen:**\n\n| Typ | Gre (Bytes) |\n|-----|-----------------|\n| `i8` | 1 |\n| `i16` | 2 |\n| `i32`, `integer` | 4 |\n| `i64` | 8 |\n| `u8`, `byte` | 1 |\n| `u16` | 2 |\n| `u32` | 4 |\n| `u64` | 8 |\n| `f32` | 4 |\n| `f64`, `number` | 8 |\n| `bool` | 1 |\n| `ptr` | 8 |\n| `rune` | 4 |\n\n**Beispiele:**\n```hemlock\nlet int_size = sizeof(i32);      // 4\nlet ptr_size = sizeof(ptr);      // 8\nlet float_size = sizeof(f64);    // 8\nlet byte_size = sizeof(u8);      // 1\nlet rune_size = sizeof(rune);    // 4\n\n// Array-Allokationsgroesse berechnen\nlet count = 100;\nlet total = sizeof(i32) * count; // 400 Bytes\n```\n\n**Verhalten:**\n- Gibt 0 fr unbekannte Typen zurck\n- Akzeptiert sowohl Typ-Bezeichner als auch Typ-Strings\n\n---\n\n### talloc\n\nAllokiert Array von typisierten Werten.\n\n**Signatur:**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**Parameter:**\n- `type` - Zu allokierender Typ (z.B. `i32`, `f64`, `ptr`)\n- `count` - Anzahl der Elemente (muss positiv sein)\n\n**Rckgabe:** Pointer zum allokierten Array, oder `null` bei Allokationsfehler\n\n**Beispiele:**\n```hemlock\nlet arr = talloc(i32, 100);      // Array von 100 i32s (400 Bytes)\nlet floats = talloc(f64, 50);    // Array von 50 f64s (400 Bytes)\nlet bytes = talloc(u8, 1024);    // Array von 1024 Bytes\n\n// Immer auf Allokationsfehler prfen\nif (arr == null) {\n    panic(\"Allokation fehlgeschlagen\");\n}\n\n// Allokierten Speicher verwenden\n// ...\n\nfree(arr);\nfree(floats);\nfree(bytes);\n```\n\n**Verhalten:**\n- Allokiert `sizeof(type) * count` Bytes\n- Gibt uninitialisierten Speicher zurck\n- Speicher muss manuell mit `free()` freigegeben werden\n- Gibt `null` bei Allokationsfehler zurck (Aufrufer muss prfen)\n- Bricht ab wenn count nicht positiv ist\n\n---\n\n## Buffer-Eigenschaften\n\n### .length\n\nGibt Buffergroesse zurck.\n\n**Typ:** `i32`\n\n**Zugriff:** Nur-Lesen\n\n**Beispiele:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\n\nlet buf2 = buffer(1024);\nprint(buf2.length);         // 1024\n```\n\n---\n\n### .capacity\n\nGibt Bufferkapazitaet zurck.\n\n**Typ:** `i32`\n\n**Zugriff:** Nur-Lesen\n\n**Beispiele:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.capacity);        // 256\n```\n\n**Hinweis:** Derzeit sind `.length` und `.capacity` fr mit `buffer()` erstellte Buffer gleich.\n\n---\n\n## Verwendungsmuster\n\n### Grundlegendes Allokationsmuster\n\n```hemlock\n// Allokieren\nlet p = alloc(1024);\nif (p == null) {\n    panic(\"Allokation fehlgeschlagen\");\n}\n\n// Verwenden\nmemset(p, 0, 1024);\n\n// Freigeben\nfree(p);\n```\n\n### Sicheres Buffer-Muster\n\n```hemlock\n// Buffer allokieren\nlet buf = buffer(256);\nif (buf == null) {\n    panic(\"Buffer-Allokation fehlgeschlagen\");\n}\n\n// Mit Grenzenprfung verwenden\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\n// Freigeben\nfree(buf);\n```\n\n### Dynamisches Wachstumsmuster\n\n```hemlock\nlet size = 100;\nlet p = alloc(size);\nif (p == null) {\n    panic(\"Allokation fehlgeschlagen\");\n}\n\n// ... Speicher verwenden ...\n\n// Mehr Platz bentigt - auf Fehler prfen\nlet new_p = realloc(p, 200);\nif (new_p == null) {\n    // Original-Pointer noch gltig, aufraeumen\n    free(p);\n    panic(\"Realloc fehlgeschlagen\");\n}\np = new_p;\nsize = 200;\n\n// ... erweiterten Speicher verwenden ...\n\nfree(p);\n```\n\n### Speicherkopie-Muster\n\n```hemlock\nlet original = alloc(100);\nmemset(original, 65, 100);\n\n// Kopie erstellen\nlet copy = alloc(100);\nmemcpy(copy, original, 100);\n\nfree(original);\nfree(copy);\n```\n\n---\n\n## Sicherheitsueberlegungen\n\n**Hemlocks Speicherverwaltung ist UNSICHER by Design:**\n\n### Hufige Fallstricke\n\n**1. Speicherlecks**\n```hemlock\n// SCHLECHT: Speicherleck\nfn create_buffer() {\n    let p = alloc(1024);\n    return null;  // Speicher geleakt!\n}\n\n// GUT: Ordnungsgemaesse Bereinigung\nfn create_buffer() {\n    let p = alloc(1024);\n    // ... Speicher verwenden ...\n    free(p);\n    return null;\n}\n```\n\n**2. Verwendung nach Freigabe**\n```hemlock\n// SCHLECHT: Verwendung nach Freigabe\nlet p = alloc(100);\nfree(p);\nmemset(p, 0, 100);  // ABSTURZ: Verwendung von freigegebenem Speicher\n\n// GUT: Nach Freigabe nicht verwenden\nlet p2 = alloc(100);\nmemset(p2, 0, 100);\nfree(p2);\n// p2 nach hier nicht beruehren\n```\n\n**3. Doppelte Freigabe**\n```hemlock\n// SCHLECHT: Doppelte Freigabe\nlet p = alloc(100);\nfree(p);\nfree(p);  // ABSTURZ: Doppelte Freigabe\n\n// GUT: Einmal freigeben\nlet p2 = alloc(100);\nfree(p2);\n```\n\n**4. Buffer-berlauf (ptr)**\n```hemlock\n// SCHLECHT: Buffer-berlauf mit ptr\nlet p = alloc(10);\nmemset(p, 65, 100);  // ABSTURZ: Schreiben ber Allokation hinaus\n\n// GUT: Buffer fr Grenzenprfung verwenden\nlet buf = buffer(10);\n// buf[100] = 65;  // FEHLER: Grenzenprfung schlaegt fehl\n```\n\n**5. Haengende Pointer**\n```hemlock\n// SCHLECHT: Haengender Pointer\nlet p1 = alloc(100);\nlet p2 = p1;\nfree(p1);\nmemset(p2, 0, 100);  // ABSTURZ: p2 haengt\n\n// GUT: Eigentum sorgfaeltig verfolgen\nlet p = alloc(100);\n// ... p verwenden ...\nfree(p);\n// Keine anderen Referenzen auf p behalten\n```\n\n**6. Ungeprfter Allokationsfehler**\n```hemlock\n// SCHLECHT: Nicht auf null prfen\nlet p = alloc(1000000000);  // Kann bei wenig Speicher fehlschlagen\nmemset(p, 0, 1000000000);   // ABSTURZ: p ist null\n\n// GUT: Immer Allokationsergebnis prfen\nlet p2 = alloc(1000000000);\nif (p2 == null) {\n    panic(\"Speicher erschoepft\");\n}\nmemset(p2, 0, 1000000000);\nfree(p2);\n```\n\n---\n\n## Wann was verwenden\n\n### `buffer()` verwenden wenn:\n- Sie Grenzenprfung bentigen\n- Mit dynamischen Daten arbeiten\n- Sicherheit wichtig ist\n- Hemlock lernen\n\n### `alloc()` verwenden wenn:\n- Maximale Leistung bentigt\n- FFI/Schnittstelle zu C\n- Sie exaktes Speicherlayout kennen\n- Sie ein Experte sind\n\n### `realloc()` verwenden wenn:\n- Allokationen vergroessern/verkleinern\n- Dynamische Arrays\n- Sie Daten erhalten mssen\n\n---\n\n## Vollstndige Funktionsuebersicht\n\n| Funktion  | Signatur                               | Rckgabe | Beschreibung               |\n|-----------|----------------------------------------|-----------|----------------------------|\n| `alloc`   | `(size: i32)`                          | `ptr`     | Roh-Speicher allokieren    |\n| `buffer`  | `(size: i32)`                          | `buffer`  | Sicheren Buffer allokieren |\n| `free`    | `(ptr: ptr \\| buffer)`                 | `null`    | Speicher freigeben         |\n| `realloc` | `(ptr: ptr, new_size: i32)`            | `ptr`     | Allokation vergroessern    |\n| `memset`  | `(ptr: ptr, byte: i32, size: i32)`     | `null`    | Speicher fuellen           |\n| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`     | `null`    | Speicher kopieren          |\n| `sizeof`  | `(type)`                               | `i32`     | Typgroesse in Bytes holen  |\n| `talloc`  | `(type, count: i32)`                   | `ptr`     | Typisiertes Array allokieren |\n\n---\n\n## Siehe auch\n\n- [Typsystem](#reference-type-system) - Pointer- und Buffer-Typen\n- [Eingebaute Funktionen](#reference-builtins) - Alle eingebauten Funktionen\n- [String-API](#reference-string-api) - String `.to_bytes()`-Methode\n"}, "API-Referenz -> String-API": {"id": "reference-string-api", "content": "# String-API-Referenz\n\nVollstndige Referenz fr Hemlocks String-Typ und alle 19 String-Methoden.\n\n---\n\n## bersicht\n\nStrings in Hemlock sind **UTF-8-kodierte, veraenderbare, heap-allokierte** Sequenzen mit vollstaendiger Unicode-Untersttzung. Alle Operationen arbeiten mit **Codepoints** (Zeichen), nicht Bytes.\n\n**Hauptmerkmale:**\n- UTF-8-Kodierung (U+0000 bis U+10FFFF)\n- Veraenderbar (kann Zeichen direkt ndern)\n- Codepoint-basierte Indizierung\n- 19 eingebaute Methoden\n- Automatische Verkettung mit `+`-Operator\n\n---\n\n## String-Typ\n\n**Typ:** `string`\n\n**Eigenschaften:**\n- `.length` - Anzahl der Codepoints (Zeichen)\n- `.byte_length` - Anzahl der UTF-8-Bytes\n\n**Literal-Syntax:** Doppelte Anfhrungszeichen `\"text\"`\n\n**Beispiele:**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5 (Codepoints)\nprint(s.byte_length);   // 5 (Bytes)\n\nlet emoji = \"\";\nprint(emoji.length);        // 1 (ein Codepoint)\nprint(emoji.byte_length);   // 4 (vier UTF-8-Bytes)\n```\n\n---\n\n## Indizierung\n\nStrings untersttzen Codepoint-basierte Indizierung mit `[]`:\n\n**Lesezugriff:**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Gibt Rune 'h' zurck\n```\n\n**Schreibzugriff:**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Mit Rune ndern (jetzt \"Hello\")\n```\n\n**UTF-8-Beispiel:**\n```hemlock\nlet text = \"Hi!\";\nprint(text[0]);         // 'H'\nprint(text[1]);         // 'i'\nprint(text[2]);         // '' (ein Codepoint)\nprint(text[3]);         // '!'\n```\n\n---\n\n## Verkettung\n\nVerwenden Sie den `+`-Operator um Strings und Runes zu verketten:\n\n**String + String:**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n```\n\n**String + Rune:**\n```hemlock\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\nlet decorated = \"Text\" + '';      // \"Text\"\n```\n\n**Rune + String:**\n```hemlock\nlet prefix = '>' + \" Message\";     // \"> Message\"\nlet bullet = '' + \" Item\";        // \" Item\"\n```\n\n**Mehrfache Verkettungen:**\n```hemlock\nlet msg = \"Hi \" + '' + \" World \" + '';  // \"Hi  World \"\n```\n\n---\n\n## String-Eigenschaften\n\n### .length\n\nGibt die Anzahl der Unicode-Codepoints (Zeichen) zurck.\n\n**Typ:** `i32`\n\n**Beispiele:**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5\n\nlet emoji = \"\";\nprint(emoji.length);    // 1 (ein Codepoint)\n\nlet text = \"Hello !\";\nprint(text.length);     // 8 (7 ASCII + 1 Emoji)\n```\n\n---\n\n### .byte_length\n\nGibt die Anzahl der UTF-8-Bytes zurck.\n\n**Typ:** `i32`\n\n**Beispiele:**\n```hemlock\nlet s = \"hello\";\nprint(s.byte_length);   // 5 (1 Byte pro ASCII-Zeichen)\n\nlet emoji = \"\";\nprint(emoji.byte_length); // 4 (Emoji ist 4 UTF-8-Bytes)\n\nlet text = \"Hello !\";\nprint(text.byte_length);  // 11 (7 ASCII + 4 fr Emoji)\n```\n\n---\n\n## String-Methoden\n\n### Teilstring & Slicing\n\n#### substr\n\nExtrahiert Teilstring nach Position und Lnge.\n\n**Signatur:**\n```hemlock\nstring.substr(start: i32, length: i32): string\n```\n\n**Parameter:**\n- `start` - Start-Codepoint-Index (nullbasiert)\n- `length` - Anzahl der zu extrahierenden Codepoints\n\n**Rckgabe:** Neuer String\n\n**Beispiele:**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\"\nlet first = s.substr(0, 5);     // \"hello\"\n\n// UTF-8-Beispiel\nlet text = \"Hi!\";\nlet emoji = text.substr(2, 1);  // \"\"\n```\n\n---\n\n#### slice\n\nExtrahiert Teilstring nach Bereich (Ende exklusiv).\n\n**Signatur:**\n```hemlock\nstring.slice(start: i32, end: i32): string\n```\n\n**Parameter:**\n- `start` - Start-Codepoint-Index (nullbasiert)\n- `end` - End-Codepoint-Index (exklusiv)\n\n**Rckgabe:** Neuer String\n\n**Beispiele:**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.slice(0, 5);        // \"hello\"\nlet world = s.slice(6, 11);     // \"world\"\n\n// UTF-8-Beispiel\nlet text = \"Hi!\";\nlet first_three = text.slice(0, 3);  // \"Hi\"\n```\n\n---\n\n### Suchen & Finden\n\n#### find\n\nFindet erstes Vorkommen eines Teilstrings.\n\n**Signatur:**\n```hemlock\nstring.find(needle: string): i32\n```\n\n**Parameter:**\n- `needle` - Zu suchender Teilstring\n\n**Rckgabe:** Codepoint-Index des ersten Vorkommens, oder `-1` wenn nicht gefunden\n\n**Beispiele:**\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6\nlet pos2 = s.find(\"foo\");       // -1 (nicht gefunden)\nlet pos3 = s.find(\"l\");         // 2 (erstes 'l')\n```\n\n---\n\n#### contains\n\nPrueft ob String Teilstring enthlt.\n\n**Signatur:**\n```hemlock\nstring.contains(needle: string): bool\n```\n\n**Parameter:**\n- `needle` - Zu suchender Teilstring\n\n**Rckgabe:** `true` wenn gefunden, `false` sonst\n\n**Beispiele:**\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n---\n\n### Teilen & Verbinden\n\n#### split\n\nTeilt String in Array nach Trennzeichen.\n\n**Signatur:**\n```hemlock\nstring.split(delimiter: string): array\n```\n\n**Parameter:**\n- `delimiter` - String zum Teilen\n\n**Rckgabe:** Array von Strings\n\n**Beispiele:**\n```hemlock\nlet csv = \"a,b,c\";\nlet parts = csv.split(\",\");     // [\"a\", \"b\", \"c\"]\n\nlet path = \"/usr/local/bin\";\nlet dirs = path.split(\"/\");     // [\"\", \"usr\", \"local\", \"bin\"]\n\nlet text = \"hello world foo\";\nlet words = text.split(\" \");    // [\"hello\", \"world\", \"foo\"]\n```\n\n---\n\n#### trim\n\nEntfernt fhrende und nachfolgende Leerzeichen.\n\n**Signatur:**\n```hemlock\nstring.trim(): string\n```\n\n**Rckgabe:** Neuer String ohne Leerzeichen\n\n**Beispiele:**\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet text = \"\\n\\t  world  \\n\";\nlet clean2 = text.trim();       // \"world\"\n```\n\n---\n\n### Gro-/Kleinschreibung\n\n#### to_upper\n\nKonvertiert String zu Grossbuchstaben.\n\n**Signatur:**\n```hemlock\nstring.to_upper(): string\n```\n\n**Rckgabe:** Neuer String in Grossbuchstaben\n\n**Beispiele:**\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\nlet mixed = \"HeLLo\";\nlet upper2 = mixed.to_upper();  // \"HELLO\"\n```\n\n---\n\n#### to_lower\n\nKonvertiert String zu Kleinbuchstaben.\n\n**Signatur:**\n```hemlock\nstring.to_lower(): string\n```\n\n**Rckgabe:** Neuer String in Kleinbuchstaben\n\n**Beispiele:**\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n\nlet mixed = \"HeLLo\";\nlet lower2 = mixed.to_lower();  // \"hello\"\n```\n\n---\n\n### Prfix & Suffix\n\n#### starts_with\n\nPrueft ob String mit Prfix beginnt.\n\n**Signatur:**\n```hemlock\nstring.starts_with(prefix: string): bool\n```\n\n**Parameter:**\n- `prefix` - Zu pruefendes Prfix\n\n**Rckgabe:** `true` wenn String mit Prfix beginnt, `false` sonst\n\n**Beispiele:**\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n---\n\n#### ends_with\n\nPrueft ob String mit Suffix endet.\n\n**Signatur:**\n```hemlock\nstring.ends_with(suffix: string): bool\n```\n\n**Parameter:**\n- `suffix` - Zu pruefendes Suffix\n\n**Rckgabe:** `true` wenn String mit Suffix endet, `false` sonst\n\n**Beispiele:**\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n---\n\n### Ersetzen\n\n#### replace\n\nErsetzt erstes Vorkommen eines Teilstrings.\n\n**Signatur:**\n```hemlock\nstring.replace(old: string, new: string): string\n```\n\n**Parameter:**\n- `old` - Zu ersetzender Teilstring\n- `new` - Ersetzungsstring\n\n**Rckgabe:** Neuer String mit erstem Vorkommen ersetzt\n\n**Beispiele:**\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");  // \"hello there\"\n\nlet text = \"foo foo foo\";\nlet text2 = text.replace(\"foo\", \"bar\"); // \"bar foo foo\" (nur erstes)\n```\n\n---\n\n#### replace_all\n\nErsetzt alle Vorkommen eines Teilstrings.\n\n**Signatur:**\n```hemlock\nstring.replace_all(old: string, new: string): string\n```\n\n**Parameter:**\n- `old` - Zu ersetzender Teilstring\n- `new` - Ersetzungsstring\n\n**Rckgabe:** Neuer String mit allen Vorkommen ersetzt\n\n**Beispiele:**\n```hemlock\nlet text = \"foo foo foo\";\nlet text2 = text.replace_all(\"foo\", \"bar\"); // \"bar bar bar\"\n\nlet s = \"hello world hello\";\nlet s2 = s.replace_all(\"hello\", \"hi\");      // \"hi world hi\"\n```\n\n---\n\n### Wiederholung\n\n#### repeat\n\nWiederholt String n-mal.\n\n**Signatur:**\n```hemlock\nstring.repeat(count: i32): string\n```\n\n**Parameter:**\n- `count` - Anzahl der Wiederholungen\n\n**Rckgabe:** Neuer String count-mal wiederholt\n\n**Beispiele:**\n```hemlock\nlet s = \"ha\";\nlet repeated = s.repeat(3);     // \"hahaha\"\n\nlet line = \"-\";\nlet separator = line.repeat(40); // \"----------------------------------------\"\n```\n\n---\n\n### Zeichenzugriff\n\n#### char_at\n\nGibt Unicode-Codepoint am Index zurck.\n\n**Signatur:**\n```hemlock\nstring.char_at(index: i32): rune\n```\n\n**Parameter:**\n- `index` - Codepoint-Index (nullbasiert)\n\n**Rckgabe:** Rune (Unicode-Codepoint)\n\n**Beispiele:**\n```hemlock\nlet s = \"hello\";\nlet ch = s.char_at(0);          // 'h'\nlet ch2 = s.char_at(1);         // 'e'\n\n// UTF-8-Beispiel\nlet emoji = \"\";\nlet ch3 = emoji.char_at(0);     // U+1F680 (Rakete)\n```\n\n---\n\n#### chars\n\nKonvertiert String zu Array von Runes.\n\n**Signatur:**\n```hemlock\nstring.chars(): array\n```\n\n**Rckgabe:** Array von Runes (Codepoints)\n\n**Beispiele:**\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']\n\n// UTF-8-Beispiel\nlet text = \"Hi!\";\nlet chars2 = text.chars();      // ['H', 'i', '', '!']\n```\n\n---\n\n### Byte-Zugriff\n\n#### byte_at\n\nGibt Byte-Wert am Index zurck.\n\n**Signatur:**\n```hemlock\nstring.byte_at(index: i32): u8\n```\n\n**Parameter:**\n- `index` - Byte-Index (nullbasiert, NICHT Codepoint-Index)\n\n**Rckgabe:** Byte-Wert (u8)\n\n**Beispiele:**\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (ASCII 'h')\nlet byte2 = s.byte_at(1);       // 101 (ASCII 'e')\n\n// UTF-8-Beispiel\nlet emoji = \"\";\nlet byte3 = emoji.byte_at(0);   // 240 (erstes UTF-8-Byte)\n```\n\n---\n\n#### bytes\n\nKonvertiert String zu Array von Bytes.\n\n**Signatur:**\n```hemlock\nstring.bytes(): array\n```\n\n**Rckgabe:** Array von u8-Bytes\n\n**Beispiele:**\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111]\n\n// UTF-8-Beispiel\nlet emoji = \"\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 UTF-8-Bytes)\n```\n\n---\n\n#### to_bytes\n\nKonvertiert String zu Buffer.\n\n**Signatur:**\n```hemlock\nstring.to_bytes(): buffer\n```\n\n**Rckgabe:** Buffer mit UTF-8-Bytes\n\n**Beispiele:**\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();\nprint(buf.length);              // 5\n\n// UTF-8-Beispiel\nlet emoji = \"\";\nlet buf2 = emoji.to_bytes();\nprint(buf2.length);             // 4\n```\n\n**Hinweis:** Dies ist eine Legacy-Methode. Bevorzugen Sie `.bytes()` fr die meisten Anwendungsfaelle.\n\n---\n\n### JSON-Deserialisierung\n\n#### deserialize\n\nParst JSON-String zu Wert.\n\n**Signatur:**\n```hemlock\nstring.deserialize(): any\n```\n\n**Rckgabe:** Geparster Wert (Objekt, Array, Zahl, String, Bool oder null)\n\n**Beispiele:**\n```hemlock\nlet json = '{\"x\":10,\"y\":20}';\nlet obj = json.deserialize();\nprint(obj.x);                   // 10\nprint(obj.y);                   // 20\n\nlet arr_json = '[1,2,3]';\nlet arr = arr_json.deserialize();\nprint(arr[0]);                  // 1\n\nlet num_json = '42';\nlet num = num_json.deserialize();\nprint(num);                     // 42\n```\n\n**Unterstuetzte Typen:**\n- Objekte: `{\"key\": value}`\n- Arrays: `[1, 2, 3]`\n- Zahlen: `42`, `3.14`\n- Strings: `\"text\"`\n- Booleans: `true`, `false`\n- Null: `null`\n\n**Siehe auch:** Objekt `.serialize()`-Methode\n\n---\n\n## Methoden-Verkettung\n\nString-Methoden knnen fr praegnante Operationen verkettet werden:\n\n**Beispiele:**\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \");                  // \"foo | bar | baz\"\n\nlet cleaned = \"  HELLO  \"\n    .trim()\n    .to_lower();                   // \"hello\"\n```\n\n---\n\n## Vollstndige Methodenuebersicht\n\n| Methode        | Signatur                                     | Rckgabe | Beschreibung                          |\n|----------------|----------------------------------------------|-----------|---------------------------------------|\n| `substr`       | `(start: i32, length: i32)`                  | `string`  | Teilstring nach Position/Lnge extrahieren |\n| `slice`        | `(start: i32, end: i32)`                     | `string`  | Teilstring nach Bereich extrahieren   |\n| `find`         | `(needle: string)`                           | `i32`     | Erstes Vorkommen finden (-1 wenn nicht gefunden) |\n| `contains`     | `(needle: string)`                           | `bool`    | Prfen ob Teilstring enthalten       |\n| `split`        | `(delimiter: string)`                        | `array`   | In Array teilen                       |\n| `trim`         | `()`                                         | `string`  | Leerzeichen entfernen                 |\n| `to_upper`     | `()`                                         | `string`  | Zu Grossbuchstaben konvertieren       |\n| `to_lower`     | `()`                                         | `string`  | Zu Kleinbuchstaben konvertieren       |\n| `starts_with`  | `(prefix: string)`                           | `bool`    | Prfen ob mit Prfix beginnt        |\n| `ends_with`    | `(suffix: string)`                           | `bool`    | Prfen ob mit Suffix endet           |\n| `replace`      | `(old: string, new: string)`                 | `string`  | Erstes Vorkommen ersetzen             |\n| `replace_all`  | `(old: string, new: string)`                 | `string`  | Alle Vorkommen ersetzen               |\n| `repeat`       | `(count: i32)`                               | `string`  | String n-mal wiederholen              |\n| `char_at`      | `(index: i32)`                               | `rune`    | Codepoint am Index holen              |\n| `byte_at`      | `(index: i32)`                               | `u8`      | Byte am Index holen                   |\n| `chars`        | `()`                                         | `array`   | Zu Array von Runes konvertieren       |\n| `bytes`        | `()`                                         | `array`   | Zu Array von Bytes konvertieren       |\n| `to_bytes`     | `()`                                         | `buffer`  | Zu Buffer konvertieren (Legacy)       |\n| `deserialize`  | `()`                                         | `any`     | JSON-String parsen                    |\n\n---\n\n## Siehe auch\n\n- [Typsystem](#reference-type-system) - String-Typ-Details\n- [Array-API](#reference-array-api) - Array-Methoden fr split()-Ergebnisse\n- [Operatoren](#reference-operators) - String-Verkettungsoperator\n"}, "API-Referenz -> Typsystem": {"id": "reference-type-system", "content": "# Typsystem-Referenz\n\nVollstndige Referenz fr Hemlocks Typsystem, einschlielich aller primitiven und zusammengesetzten Typen.\n\n---\n\n## bersicht\n\nHemlock verwendet ein **dynamisches Typsystem** mit Laufzeit-Typ-Tags und optionalen Typannotationen. Jeder Wert hat einen Laufzeittyp, und Typkonvertierungen folgen expliziten Promovierungsregeln.\n\n**Hauptmerkmale:**\n- Laufzeit-Typprfung (Interpreter)\n- Kompilierzeit-Typprfung (hemlockc - standardmig aktiviert)\n- Optionale Typannotationen\n- Automatische Typinferenz fr Literale\n- Explizite Typpromovierungsregeln\n- Keine impliziten Konvertierungen die Przision verlieren\n\n---\n\n## Kompilierzeit-Typprfung (hemlockc)\n\nDer Hemlock-Compiler (`hemlockc`) enthlt einen Kompilierzeit-Typchecker der Ihren Code vor der Generierung von ausfuehrbaren Dateien validiert. Dies erkennt Typfehler frueh ohne das Programm ausfhren zu mssen.\n\n### Standardverhalten\n\nTypprfung ist in hemlockc **standardmig aktiviert**:\n\n```bash\n# Typprfung erfolgt automatisch\nhemlockc program.hml -o program\n\n# Fehler werden vor Kompilierung gemeldet\nhemlockc bad_types.hml\n# Ausgabe: 1 Typfehler gefunden\n```\n\n### Compiler-Flags\n\n| Flag | Beschreibung |\n|------|--------------|\n| `--check` | Nur Typen prfen, nicht kompilieren (nach Validierung beenden) |\n| `--no-type-check` | Typprfung deaktivieren (nicht empfohlen) |\n| `--strict-types` | Strengere Typwarnungen aktivieren |\n\n**Beispiele:**\n\n```bash\n# Nur Typen validieren ohne zu kompilieren\nhemlockc --check program.hml\n# Ausgabe: program.hml: keine Typfehler\n\n# Typprfung deaktivieren (mit Vorsicht verwenden)\nhemlockc --no-type-check dynamic_code.hml -o program\n\n# Strenge Warnungen fr implizite any-Typen aktivieren\nhemlockc --strict-types program.hml -o program\n```\n\n### Was der Typchecker validiert\n\n1. **Typannotationen** - Stellt sicher dass zugewiesene Werte deklarierten Typen entsprechen\n2. **Funktionsaufrufe** - Validiert Argumenttypen gegen Parametertypen\n3. **Rueckgabetypen** - Prueft ob return-Anweisungen deklariertem Rckgabetyp entsprechen\n4. **Operatorverwendung** - Verifiziert dass Operanden kompatibel sind\n5. **Eigenschaftszugriff** - Validiert Objektfeldtypen fr typisierte Objekte\n\n### Tolerante numerische Konvertierungen\n\nDer Typchecker erlaubt numerische Typkonvertierungen zur Kompilierzeit, mit Bereichsvalidierung zur Laufzeit:\n\n```hemlock\nlet x: i8 = 100;      // OK - 100 passt in i8 (zur Laufzeit validiert)\nlet y: u8 = 255;      // OK - innerhalb u8-Bereich\nlet z: f64 = 42;      // OK - i32 zu f64 ist sicher\n```\n\n### Dynamischer Code-Support\n\nCode ohne Typannotationen wird als dynamisch (`any`-Typ) behandelt und besteht immer den Typchecker:\n\n```hemlock\nlet x = get_value();  // Dynamisch - keine Annotation\nprocess(x);           // OK - dynamische Werte berall akzeptiert\n```\n\n---\n\n## Primitive Typen\n\n### Numerische Typen\n\n#### Vorzeichenbehaftete Ganzzahlen\n\n| Typ    | Gre  | Bereich                                     | Alias     |\n|--------|----------|---------------------------------------------|-----------|\n| `i8`   | 1 Byte   | -128 bis 127                                | -         |\n| `i16`  | 2 Bytes  | -32.768 bis 32.767                          | -         |\n| `i32`  | 4 Bytes  | -2.147.483.648 bis 2.147.483.647            | `integer` |\n| `i64`  | 8 Bytes  | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807 | - |\n\n**Beispiele:**\n```hemlock\nlet a: i8 = 127;\nlet b: i16 = 32000;\nlet c: i32 = 1000000;\nlet d: i64 = 9223372036854775807;\n\n// Typ-Alias\nlet x: integer = 42;  // Gleich wie i32\n```\n\n#### Vorzeichenlose Ganzzahlen\n\n| Typ    | Gre  | Bereich                          | Alias  |\n|--------|----------|----------------------------------|--------|\n| `u8`   | 1 Byte   | 0 bis 255                        | `byte` |\n| `u16`  | 2 Bytes  | 0 bis 65.535                     | -      |\n| `u32`  | 4 Bytes  | 0 bis 4.294.967.295              | -      |\n| `u64`  | 8 Bytes  | 0 bis 18.446.744.073.709.551.615 | -      |\n\n**Beispiele:**\n```hemlock\nlet a: u8 = 255;\nlet b: u16 = 65535;\nlet c: u32 = 4294967295;\nlet d: u64 = 18446744073709551615;\n\n// Typ-Alias\nlet byte_val: byte = 65;  // Gleich wie u8\n```\n\n#### Gleitkomma\n\n| Typ    | Gre  | Przision     | Alias    |\n|--------|----------|----------------|----------|\n| `f32`  | 4 Bytes  | ~7 Stellen     | -        |\n| `f64`  | 8 Bytes  | ~15 Stellen    | `number` |\n\n**Beispiele:**\n```hemlock\nlet pi: f32 = 3.14159;\nlet precise: f64 = 3.14159265359;\n\n// Typ-Alias\nlet x: number = 2.718;  // Gleich wie f64\n```\n\n---\n\n### Ganzzahl-Literal-Inferenz\n\nGanzzahl-Literale werden automatisch basierend auf ihrem Wert typisiert:\n\n**Regeln:**\n- Werte im i32-Bereich (-2.147.483.648 bis 2.147.483.647): als `i32` inferiert\n- Werte auerhalb i32-Bereich aber innerhalb i64-Bereich: als `i64` inferiert\n- Verwenden Sie explizite Typannotationen fr andere Typen (i8, i16, u8, u16, u32, u64)\n\n**Beispiele:**\n```hemlock\nlet small = 42;                    // i32 (passt in i32)\nlet large = 5000000000;            // i64 (> i32 max)\nlet max_i64 = 9223372036854775807; // i64 (INT64_MAX)\nlet explicit: u32 = 100;           // u32 (Typannotation berschreibt)\n```\n\n---\n\n### Boolean-Typ\n\n**Typ:** `bool`\n\n**Werte:** `true`, `false`\n\n**Gre:** 1 Byte (intern)\n\n**Beispiele:**\n```hemlock\nlet is_active: bool = true;\nlet done = false;\n\nif (is_active && !done) {\n    print(\"arbeite\");\n}\n```\n\n---\n\n### Zeichen-Typen\n\n#### Rune\n\n**Typ:** `rune`\n\n**Beschreibung:** Unicode-Codepoint (U+0000 bis U+10FFFF)\n\n**Gre:** 4 Bytes (32-Bit-Wert)\n\n**Bereich:** 0 bis 0x10FFFF (1.114.111)\n\n**Literal-Syntax:** Einfache Anfhrungszeichen `'x'`\n\n**Beispiele:**\n```hemlock\n// ASCII\nlet a = 'A';\nlet digit = '0';\n\n// Mehrbyte-UTF-8\nlet rocket = '';      // U+1F680\nlet heart = '';        // U+2764\nlet chinese = '';     // U+4E2D\n\n// Escape-Sequenzen\nlet newline = '\\n';\nlet tab = '\\t';\nlet backslash = '\\\\';\nlet quote = '\\'';\nlet null = '\\0';\n\n// Unicode-Escapes\nlet emoji = '\\u{1F680}';   // Bis zu 6 Hex-Ziffern\nlet max = '\\u{10FFFF}';    // Maximaler Codepoint\n```\n\n**Typkonvertierungen:**\n```hemlock\n// Ganzzahl zu Rune\nlet code: rune = 65;        // 'A'\nlet r: rune = 128640;       // \n\n// Rune zu Ganzzahl\nlet value: i32 = 'Z';       // 90\n\n// Rune zu String\nlet s: string = 'H';        // \"H\"\n\n// u8 zu Rune\nlet byte: u8 = 65;\nlet rune_val: rune = byte;  // 'A'\n```\n\n**Siehe auch:** [String-API](#reference-string-api) fr String + Rune Verkettung\n\n---\n\n### String-Typ\n\n**Typ:** `string`\n\n**Beschreibung:** UTF-8-kodierter, veraenderbarer, heap-allokierter Text\n\n**Kodierung:** UTF-8 (U+0000 bis U+10FFFF)\n\n**Veraenderbarkeit:** Veraenderbar (anders als in den meisten Sprachen)\n\n**Eigenschaften:**\n- `.length` - Codepoint-Anzahl (Anzahl der Zeichen)\n- `.byte_length` - Byte-Anzahl (UTF-8-Kodierungsgroesse)\n\n**Literal-Syntax:** Doppelte Anfhrungszeichen `\"text\"`\n\n**Beispiele:**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // ndern (jetzt \"Hello\")\nprint(s.length);        // 5 (Codepoint-Anzahl)\nprint(s.byte_length);   // 5 (UTF-8-Bytes)\n\nlet emoji = \"\";\nprint(emoji.length);        // 1 (ein Codepoint)\nprint(emoji.byte_length);   // 4 (vier UTF-8-Bytes)\n```\n\n**Indizierung:**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Gibt Rune 'h' zurck\ns[0] = 'H';             // Mit Rune setzen\n```\n\n**Siehe auch:** [String-API](#reference-string-api) fr vollstndige Methodenreferenz\n\n---\n\n### Null-Typ\n\n**Typ:** `null`\n\n**Beschreibung:** Der Null-Wert (Abwesenheit eines Wertes)\n\n**Gre:** 8 Bytes (intern)\n\n**Wert:** `null`\n\n**Beispiele:**\n```hemlock\nlet x = null;\nlet y: i32 = null;  // FEHLER: Typfehlanpassung\n\nif (x == null) {\n    print(\"x ist null\");\n}\n```\n\n---\n\n## Zusammengesetzte Typen\n\n### Array-Typ\n\n**Typ:** `array`\n\n**Beschreibung:** Dynamisches, heap-allokiertes Array mit gemischten Typen\n\n**Eigenschaften:**\n- `.length` - Anzahl der Elemente\n\n**Nullbasiert:** Ja\n\n**Literal-Syntax:** `[elem1, elem2, ...]`\n\n**Beispiele:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Gemischte Typen\nlet mixed = [1, \"hello\", true, null];\n```\n\n**Siehe auch:** [Array-API](#reference-array-api) fr vollstndige Methodenreferenz\n\n---\n\n### Objekt-Typ\n\n**Typ:** `object`\n\n**Beschreibung:** JavaScript-hnliches Objekt mit dynamischen Feldern\n\n**Literal-Syntax:** `{ field: value, ... }`\n\n**Beispiele:**\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);  // \"Alice\"\n\n// Feld dynamisch hinzufgen\nperson.email = \"alice@example.com\";\n```\n\n**Typdefinitionen:**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: bool,  // Optionales Feld\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\nprint(typeof(p));  // \"Person\"\n```\n\n---\n\n### Pointer-Typen\n\n#### Roh-Pointer (ptr)\n\n**Typ:** `ptr`\n\n**Beschreibung:** Rohe Speicheradresse (unsicher)\n\n**Gre:** 8 Bytes\n\n**Grenzenprfung:** Keine\n\n**Beispiele:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n#### Buffer (buffer)\n\n**Typ:** `buffer`\n\n**Beschreibung:** Sicherer Pointer-Wrapper mit Grenzenprfung\n\n**Struktur:** Pointer + Lnge + Kapazitt\n\n**Eigenschaften:**\n- `.length` - Buffergroesse\n- `.capacity` - Allokierte Kapazitt\n\n**Beispiele:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Grenzenprfung\nprint(b.length);        // 64\nfree(b);\n```\n\n**Siehe auch:** [Speicher-API](#reference-memory-api) fr Allokationsfunktionen\n\n---\n\n## Spezielle Typen\n\n### Datei-Typ\n\n**Typ:** `file`\n\n**Beschreibung:** Dateihandle fr I/O-Operationen\n\n**Eigenschaften:**\n- `.path` - Dateipfad (string)\n- `.mode` - Oeffnungsmodus (string)\n- `.closed` - Ob Datei geschlossen (bool)\n\n**Siehe auch:** [Datei-API](#reference-file-api)\n\n---\n\n### Task-Typ\n\n**Typ:** `task`\n\n**Beschreibung:** Handle fr nebenlaeufigen Task\n\n**Siehe auch:** [Nebenlaeufigkeits-API](#reference-concurrency-api)\n\n---\n\n### Kanal-Typ\n\n**Typ:** `channel`\n\n**Beschreibung:** Thread-sicherer Kommunikationskanal\n\n**Siehe auch:** [Nebenlaeufigkeits-API](#reference-concurrency-api)\n\n---\n\n### Funktions-Typ\n\n**Typ:** `function`\n\n**Beschreibung:** First-Class-Funktionswert\n\n**Beispiele:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(typeof(add));      // \"function\"\nprint(typeof(multiply)); // \"function\"\n```\n\n---\n\n### Void-Typ\n\n**Typ:** `void`\n\n**Beschreibung:** Abwesenheit eines Rueckgabewertes (interne Verwendung)\n\n---\n\n## Typpromovierungsregeln\n\nBeim Mischen von Typen in Operationen promoviert Hemlock zum \"hoeheren\" Typ:\n\n**Promovierungshierarchie:**\n```\nf64 (hoechste Przision)\n \nf32\n \nu64\n \ni64\n \nu32\n \ni32\n \nu16\n \ni16\n \nu8\n \ni8 (niedrigste)\n```\n\n**Regeln:**\n1. Float gewinnt immer ber Ganzzahl\n2. Grere Gre gewinnt innerhalb gleicher Kategorie (int/uint/float)\n3. Beide Operanden werden zum Ergebnistyp promoviert\n4. **Praezisionserhaltung:** i64/u64 + f32 promoviert zu f64 (nicht f32)\n\n**Beispiele:**\n```hemlock\n// Groessenpromovierung\nu8 + i32     i32    // Grere Gre gewinnt\ni32 + i64    i64    // Grere Gre gewinnt\nu32 + u64    u64    // Grere Gre gewinnt\n\n// Float-Promovierung\ni32 + f32    f32    // Float gewinnt, f32 ausreichend fr i32\ni64 + f32    f64    // Promoviert zu f64 um i64-Przision zu erhalten\ni64 + f64    f64    // Float gewinnt immer\ni8 + f64     f64    // Float + groesster gewinnt\n```\n\n**Warum i64 + f32  f64?**\n\nf32 hat nur eine 24-Bit-Mantisse, die Ganzzahlen grer als 2^24 (16.777.216) nicht praezise darstellen kann. Da i64 Werte bis 2^63 halten kann, wrde das Mischen von i64 mit f32 schweren Praezisionsverlust verursachen. Hemlock promoviert stattdessen zu f64 (53-Bit-Mantisse).\n\n---\n\n## Bereichsprfung\n\nTypannotationen erzwingen Bereichsprfungen bei Zuweisung:\n\n**Gueltige Zuweisungen:**\n```hemlock\nlet x: u8 = 255;             // OK\nlet y: i8 = 127;             // OK\nlet a: i64 = 2147483647;     // OK\nlet b: u64 = 4294967295;     // OK\n```\n\n**Ungueltige Zuweisungen (Laufzeitfehler):**\n```hemlock\nlet x: u8 = 256;             // FEHLER: auerhalb des Bereichs\nlet y: i8 = 128;             // FEHLER: max ist 127\nlet z: u64 = -1;             // FEHLER: u64 kann nicht negativ sein\n```\n\n---\n\n## Typ-Introspektion\n\n### typeof(value)\n\nGibt den Typnamen als String zurck.\n\n**Signatur:**\n```hemlock\ntypeof(value: any): string\n```\n\n**Rckgabe:**\n- Primitive Typen: `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- Zusammengesetzte Typen: `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- Spezielle Typen: `\"file\"`, `\"task\"`, `\"channel\"`\n- Typisierte Objekte: Benutzerdefinierter Typname (z.B. `\"Person\"`)\n\n**Beispiele:**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n```\n\n**Siehe auch:** [Eingebaute Funktionen](builtins.md#typeof)\n\n---\n\n## Typkonvertierungen\n\n### Implizite Konvertierungen\n\nHemlock fhrt implizite Typkonvertierungen in arithmetischen Operationen nach den Typpromovierungsregeln durch.\n\n**Beispiele:**\n```hemlock\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet result = a + b;     // result ist i32 (promoviert)\n```\n\n### Explizite Konvertierungen\n\nVerwenden Sie Typannotationen fr explizite Konvertierungen:\n\n**Beispiele:**\n```hemlock\n// Ganzzahl zu Float\nlet i: i32 = 42;\nlet f: f64 = i;         // 42.0\n\n// Float zu Ganzzahl (trunciert)\nlet x: f64 = 3.14;\nlet y: i32 = x;         // 3\n\n// Ganzzahl zu Rune\nlet code: rune = 65;    // 'A'\n\n// Rune zu Ganzzahl\nlet value: i32 = 'Z';   // 90\n\n// Rune zu String\nlet s: string = 'H';    // \"H\"\n```\n\n---\n\n## Typ-Aliase\n\n### Eingebaute Aliase\n\nHemlock bietet eingebaute Typ-Aliase fr hufige Typen:\n\n| Alias     | Tatsaechlicher Typ | Verwendung                 |\n|-----------|-------------------|----------------------------|\n| `integer` | `i32`             | Allzweck-Ganzzahlen        |\n| `number`  | `f64`             | Allzweck-Gleitkomma        |\n| `byte`    | `u8`              | Byte-Werte                 |\n\n**Beispiele:**\n```hemlock\nlet count: integer = 100;       // Gleich wie i32\nlet price: number = 19.99;      // Gleich wie f64\nlet b: byte = 255;              // Gleich wie u8\n```\n\n### Benutzerdefinierte Typ-Aliase\n\nDefinieren Sie benutzerdefinierte Typ-Aliase mit dem `type`-Schlsselwort:\n\n```hemlock\n// Einfache Aliase\ntype Integer = i32;\ntype Text = string;\n\n// Funktionstyp-Aliase\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\n// Zusammengesetzte Typ-Aliase\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// Generische Typ-Aliase\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n```\n\n**Benutzerdefinierte Aliase verwenden:**\n```hemlock\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**Hinweis:** Typ-Aliase sind transparent - `typeof()` gibt den zugrundeliegenden Typnamen zurck.\n\n---\n\n## Funktionstypen\n\nFunktionstypen spezifizieren die Signatur von Funktionswerten:\n\n### Syntax\n\n```hemlock\nfn(param_types): return_type\n```\n\n### Beispiele\n\n```hemlock\n// Grundlegender Funktionstyp\nlet add: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// Funktionsparameter\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Higher-Order-Funktion die Funktion zurckgibt\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Async-Funktionstyp\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n```\n\n---\n\n## Zusammengesetzte Typen (Schnittmenge)\n\nZusammengesetzte Typen verwenden `&` um mehrere Typanforderungen zu verlangen:\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// Objekt muss alle Typen erfllen\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// Drei oder mehr Typen\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n---\n\n## Zusammenfassungstabelle\n\n| Typ        | Gre   | Veraenderbar | Heap-allokiert | Beschreibung                   |\n|------------|-----------|--------------|----------------|--------------------------------|\n| `i8`-`i64` | 1-8 Bytes | Nein         | Nein           | Vorzeichenbehaftete Ganzzahlen |\n| `u8`-`u64` | 1-8 Bytes | Nein         | Nein           | Vorzeichenlose Ganzzahlen      |\n| `f32`      | 4 Bytes   | Nein         | Nein           | Einfach-Praezisions-Float      |\n| `f64`      | 8 Bytes   | Nein         | Nein           | Doppel-Praezisions-Float       |\n| `bool`     | 1 Byte    | Nein         | Nein           | Boolean                        |\n| `rune`     | 4 Bytes   | Nein         | Nein           | Unicode-Codepoint              |\n| `string`   | Variabel  | Ja           | Ja             | UTF-8-Text                     |\n| `array`    | Variabel  | Ja           | Ja             | Dynamisches Array              |\n| `object`   | Variabel  | Ja           | Ja             | Dynamisches Objekt             |\n| `ptr`      | 8 Bytes   | Nein         | Nein           | Roh-Pointer                    |\n| `buffer`   | Variabel  | Ja           | Ja             | Sicherer Pointer-Wrapper       |\n| `file`     | Opak      | Ja           | Ja             | Dateihandle                    |\n| `task`     | Opak      | Nein         | Ja             | Nebenlaeufiger Task-Handle     |\n| `channel`  | Opak      | Ja           | Ja             | Thread-sicherer Kanal          |\n| `function` | Opak      | Nein         | Ja             | Funktionswert                  |\n| `null`     | 8 Bytes   | Nein         | Nein           | Null-Wert                      |\n\n---\n\n## Siehe auch\n\n- [Operatoren-Referenz](#reference-operators) - Typverhalten in Operationen\n- [Eingebaute Funktionen](#reference-builtins) - Typ-Introspektion und Konvertierung\n- [String-API](#reference-string-api) - String-Typ-Methoden\n- [Array-API](#reference-array-api) - Array-Typ-Methoden\n- [Speicher-API](#reference-memory-api) - Pointer- und Buffer-Operationen\n"}, "Design & Philosophie -> Designphilosophie": {"id": "design-philosophy", "content": "# Hemlock Sprachdesign-Philosophie\n\n> \"Eine kleine, unsichere Sprache, um unsichere Dinge sicher zu schreiben.\"\n\nDieses Dokument beschreibt die grundlegenden Designprinzipien und die Philosophie von Hemlock. Lesen Sie dies zuerst, bevor Sie nderungen oder Ergnzungen an der Sprache vornehmen.\n\n---\n\n## Inhaltsverzeichnis\n\n- [Kernidentitt](#kernidentitt)\n- [Designprinzipien](#designprinzipien)\n- [Philosophie zur Sicherheit](#philosophie-zur-sicherheit)\n- [Was NICHT hinzugefgt werden sollte](#was-nicht-hinzugefgt-werden-sollte)\n- [Zuknftige berlegungen](#zuknftige-berlegungen)\n- [Abschlieende Gedanken](#abschlieende-gedanken)\n\n---\n\n## Kernidentitt\n\nHemlock ist eine **Systemskripting-Sprache**, die manuelle Speicherverwaltung und explizite Kontrolle umfasst. Sie ist fr Programmierer konzipiert, die Folgendes wollen:\n\n- Die Leistungsfhigkeit von C\n- Die Ergonomie moderner Skriptsprachen\n- Eingebaute strukturierte asynchrone Nebenlufigkeit\n- Kein verstecktes Verhalten oder Magie\n\n### Was Hemlock NICHT ist\n\n- **Speichersicher** (baumelnde Zeiger sind Ihre Verantwortung)\n- **Ein Ersatz fr Rust, Go oder Lua**\n- **Eine Sprache, die Komplexitt vor Ihnen verbirgt**\n\n### Was Hemlock IST\n\n- **Explizit statt implizit, immer**\n- **Lehrreich und experimentell**\n- **Eine \"C-Skriptschicht\" fr Systemarbeit**\n- **Ehrlich ber Kompromisse**\n\n---\n\n## Designprinzipien\n\n### 1. Explizit statt implizit\n\nHemlock bevorzugt Explizitheit in allen Sprachkonstrukten. Es sollte keine berraschungen, keine Magie und kein verstecktes Verhalten geben.\n\n**Schlecht (implizit):**\n```hemlock\nlet x = 5  // Fehlendes Semikolon - sollte einen Fehler erzeugen\n```\n\n**Gut (explizit):**\n```hemlock\nlet x = 5;\nfree(ptr);  // Sie haben es allokiert, Sie geben es frei\n```\n\n**Schlsselaspekte:**\n- Semikolons sind obligatorisch (keine automatische Semikolon-Einfgung)\n- Keine Garbage Collection\n- Manuelle Speicherverwaltung (alloc/free)\n- Typannotationen sind optional, werden aber zur Laufzeit geprft\n- Keine automatische Ressourcenbereinigung (kein RAII), aber `defer` bietet explizite Bereinigung\n\n### 2. Dynamisch standardmig, typisiert nach Wahl\n\nJeder Wert hat ein Laufzeit-Typ-Tag, aber das System ist so konzipiert, dass es flexibel ist und dennoch Fehler erkennt.\n\n**Typinferenz:**\n- Kleine Ganzzahlen (passen in i32): `42`  `i32`\n- Groe Ganzzahlen (> i32-Bereich): `9223372036854775807`  `i64`\n- Gleitkommazahlen: `3.14`  `f64`\n\n**Explizite Typisierung bei Bedarf:**\n```hemlock\nlet x = 42;              // i32 inferiert (kleiner Wert)\nlet y: u8 = 255;         // explizites u8\nlet z = x + y;           // wird zu i32 hochgestuft\nlet big = 5000000000;    // i64 inferiert (> i32 max)\n```\n\n**Typpromotionsregeln** folgen einer klaren Hierarchie vom kleinsten zum grten, wobei Gleitkommazahlen immer ber Ganzzahlen gewinnen.\n\n### 3. Unsicherheit ist ein Feature, kein Bug\n\nHemlock versucht nicht, alle Fehler zu verhindern. Stattdessen gibt es Ihnen die Werkzeuge, um sicher zu sein, whrend Sie bei Bedarf unsicheres Verhalten whlen knnen.\n\n**Beispiele fr beabsichtigte Unsicherheit:**\n- Zeigerarithmetik kann berlaufen (Verantwortung des Benutzers)\n- Keine Bereichsprfung bei rohem `ptr` (verwenden Sie `buffer`, wenn Sie Sicherheit wollen)\n- Double-free-Abstrze sind erlaubt (manuelle Speicherverwaltung)\n- Das Typsystem verhindert Unflle, erlaubt aber Risiken bei Bedarf\n\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Weit ber die Allokation hinaus - erlaubt, aber gefhrlich\n```\n\n**Die Philosophie:** Das Typsystem sollte *Unflle* verhindern, aber *beabsichtigte* unsichere Operationen erlauben.\n\n### 4. Strukturierte Nebenlufigkeit erstklassig\n\nNebenlufigkeit ist in Hemlock kein nachtrglicher Gedanke. Sie ist von Grund auf in die Sprache eingebaut.\n\n**Schlsselfunktionen:**\n- `async`/`await` in die Sprache eingebaut\n- Kanle fr Kommunikation\n- `spawn`/`join`/`detach` fr Aufgabenverwaltung\n- Keine rohen Threads, keine Sperren - nur strukturiert\n- Echte Mehrfaden-Parallelitt mit POSIX-Threads\n\n**Kein Event-Loop oder Green Threads** - Hemlock verwendet echte Betriebssystem-Threads fr echte Parallelitt ber mehrere CPU-Kerne.\n\n### 5. C-hnliche Syntax, wenig Zeremonie\n\nHemlock sollte Systemprogrammierern vertraut vorkommen und gleichzeitig Boilerplate reduzieren.\n\n**Designentscheidungen:**\n- `{}`-Blcke immer, keine optionalen Klammern\n- Operatoren entsprechen C: `+`, `-`, `*`, `/`, `&&`, `||`, `!`\n- Typsyntax entspricht Rust/TypeScript: `let x: type = value;`\n- Funktionen sind erstklassige Werte\n- Minimale Schlsselwrter und Sonderformen\n\n---\n\n## Philosophie zur Sicherheit\n\n**Hemlocks Haltung zur Sicherheit:**\n\n> \"Wir geben Ihnen die Werkzeuge, um sicher zu sein (`buffer`, Typannotationen, Bereichsprfung), aber wir zwingen Sie nicht, sie zu verwenden (`ptr`, manuelle Speicherverwaltung, unsichere Operationen).\n>\n> Der Standard sollte zur Sicherheit fhren, aber die Hintertr sollte immer verfgbar sein.\"\n\n### Bereitgestellte Sicherheitswerkzeuge\n\n**1. Sicherer Buffer-Typ:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // bereichsgeprft\nprint(b.length);        // 64\nfree(b);                // immer noch manuell\n```\n\n**2. Unsichere rohe Zeiger:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // Sie mssen daran denken, free aufzurufen\n```\n\n**3. Typannotationen:**\n```hemlock\nlet x: u8 = 255;   // OK\nlet y: u8 = 256;   // FEHLER: auerhalb des Bereichs\n```\n\n**4. Laufzeit-Typprfung:**\n```hemlock\nlet val = some_function();\nif (typeof(val) == \"i32\") {\n    // Sicher als Ganzzahl zu verwenden\n}\n```\n\n### Leitprinzipien\n\n1. **Standard auf sichere Muster in der Dokumentation** - Zeigen Sie `buffer` vor `ptr`, ermutigen Sie zu Typannotationen\n2. **Machen Sie unsichere Operationen offensichtlich** - Rohe Zeigerarithmetik sollte beabsichtigt aussehen\n3. **Bieten Sie Hintertren** - Verhindern Sie nicht, dass erfahrene Benutzer Low-Level-Arbeit leisten\n4. **Seien Sie ehrlich ber Kompromisse** - Dokumentieren Sie, was schiefgehen kann\n\n### Beispiele fr Sicherheit vs. Unsicherheit\n\n| Sicheres Muster | Unsicheres Muster | Wann unsicher verwenden |\n|-----------------|-------------------|-------------------------|\n| `buffer`-Typ | `ptr`-Typ | FFI, leistungskritischer Code |\n| Typannotationen | Keine Annotationen | Externe Schnittstellen, Validierung |\n| Bereichsgeprfter Zugriff | Zeigerarithmetik | Low-Level-Speicheroperationen |\n| Ausnahmebehandlung | Rckgabe von null/Fehlercodes | Wenn Ausnahmen zu schwergewichtig sind |\n\n---\n\n## Was NICHT hinzugefgt werden sollte\n\nZu verstehen, was **nicht** hinzugefgt werden sollte, ist genauso wichtig wie zu wissen, was hinzugefgt werden soll.\n\n### Kein implizites Verhalten hinzufgen\n\n**Schlechte Beispiele:**\n\n```hemlock\n// SCHLECHT: Automatische Semikolon-Einfgung\nlet x = 5\nlet y = 10\n\n// SCHLECHT: Implizite Typkonvertierungen, die Przision verlieren\nlet x: i32 = 3.14  // Sollte abschneiden oder Fehler erzeugen?\n```\n\n**Warum:** Implizites Verhalten erzeugt berraschungen und macht Code schwerer nachvollziehbar.\n\n### Keine Komplexitt verbergen\n\n**Schlechte Beispiele:**\n\n```hemlock\n// SCHLECHT: Magische Hinter-den-Kulissen-Optimierung\nlet arr = [1, 2, 3]  // Ist das Stack oder Heap? Der Benutzer sollte es wissen! (Heap, refgezhlt)\n\n// SCHLECHT: Roher Zeiger automatisch freigegeben\nlet p = alloc(100)  // Wird das automatisch freigegeben? NEIN! Rohe Zeiger brauchen immer free()\n```\n\n**Hinweis zum Refcounting:** Hemlock verwendet internes Refcounting fr Strings, Arrays, Objekte und Buffer - diese WERDEN automatisch freigegeben, wenn der Scope verlassen wird. Dies ist explizit und vorhersehbar (deterministische Bereinigung, wenn ref 0 erreicht, keine GC-Pausen). Rohe Zeiger (`ptr` von `alloc()`) sind NICHT refgezhlt und erfordern immer manuelles `free()`.\n\n**Warum:** Versteckte Komplexitt macht es unmglich, Leistung vorherzusagen und Probleme zu debuggen.\n\n### Keine bestehenden Semantiken brechen\n\n**ndern Sie niemals diese Kernentscheidungen:**\n- Semikolons sind obligatorisch - machen Sie sie nicht optional\n- Manuelle Speicherverwaltung - fgen Sie keine GC hinzu\n- Vernderbare Strings - machen Sie sie nicht unvernderbar\n- Laufzeit-Typprfung - entfernen Sie sie nicht\n\n**Warum:** Konsistenz und Stabilitt sind wichtiger als trendige Features.\n\n### Keine \"praktischen\" Features hinzufgen, die Explizitheit reduzieren\n\n**Beispiele fr zu vermeidende Features:**\n- Operatorberladung (vielleicht fr Benutzertypen, aber vorsichtig)\n- Implizite Typumwandlung, die Informationen verliert\n- Automatische Ressourcenbereinigung (RAII)\n- Methodenverkettung, die Komplexitt verbirgt\n- DSLs und magische Syntax\n\n**Ausnahme:** Praktische Features sind OK, wenn sie **expliziter Zucker** ber einfache Operationen sind:\n- `else if` ist in Ordnung (es sind nur verschachtelte if-Anweisungen)\n- String-Interpolation knnte OK sein, wenn es klar syntaktischer Zucker ist\n- Methodensyntax fr Objekte ist in Ordnung (es ist explizit, was es tut)\n\n---\n\n## Zuknftige berlegungen\n\n### Vielleicht hinzufgen (in Diskussion)\n\nDiese Features passen zur Philosophie von Hemlock, bentigen aber sorgfltiges Design:\n\n**1. Pattern Matching**\n```hemlock\nmatch (value) {\n    case i32: print(\"Ganzzahl\");\n    case string: print(\"Text\");\n    case _: print(\"anderes\");\n}\n```\n- Explizite Typprfung\n- Keine versteckten Kosten\n- Kompilierzeit-Vollstndigkeitsprfung mglich\n\n**2. Fehlertypen (`Result<T, E>`)**\n```hemlock\nfn divide(a: i32, b: i32): Result<i32, string> {\n    if (b == 0) {\n        return Err(\"Division durch Null\");\n    }\n    return Ok(a / b);\n}\n```\n- Explizite Fehlerbehandlung\n- Zwingt Benutzer, ber Fehler nachzudenken\n- Alternative zu Ausnahmen\n\n**3. Array/Slice-Typen**\n- Haben bereits dynamische Arrays\n- Knnten Arrays fester Gre fr Stack-Allokation hinzufgen\n- Msste explizit ber Stack vs. Heap sein\n\n**4. Verbesserte Speichersicherheitswerkzeuge**\n- Optionales Bereichsprfungs-Flag\n- Speicherleckerkennung in Debug-Builds\n- Sanitizer-Integration\n\n### Wahrscheinlich niemals hinzufgen\n\nDiese Features verletzen Kernprinzipien:\n\n**1. Garbage Collection**\n- Verbirgt Speicherverwaltungskomplexitt\n- Unvorhersehbare Leistung\n- Gegen das Prinzip der expliziten Kontrolle\n\n**2. Automatische Speicherverwaltung**\n- Gleiche Grnde wie GC\n- Reference Counting knnte OK sein, wenn explizit\n\n**3. Implizite Typkonvertierungen, die Daten verlieren**\n- Widerspricht \"explizit statt implizit\"\n- Quelle subtiler Bugs\n\n**4. Makros (komplexe)**\n- Zu viel Macht, zu viel Komplexitt\n- Einfaches Makrosystem knnte OK sein\n- Bevorzugen Sie Codegenerierung oder Funktionen\n\n**5. Klassenbasierte OOP mit Vererbung**\n- Zu viel implizites Verhalten\n- Duck Typing und Objekte sind ausreichend\n- Komposition statt Vererbung\n\n**6. Modulsystem mit komplexer Auflsung**\n- Halten Sie Importe einfach und explizit\n- Keine magischen Suchpfade\n- Keine Versionsauflsung (verwenden Sie den OS-Paketmanager)\n\n---\n\n## Abschlieende Gedanken\n\n### Vertrauen und Verantwortung\n\nBei Hemlock geht es um **Vertrauen und Verantwortung**. Wir vertrauen dem Programmierer:\n\n- Speicher korrekt zu verwalten\n- Typen angemessen zu verwenden\n- Fehler ordnungsgem zu behandeln\n- Die Kompromisse zu verstehen\n\nIm Gegenzug bietet Hemlock:\n\n- Keine versteckten Kosten\n- Kein berraschendes Verhalten\n- Volle Kontrolle bei Bedarf\n- Sicherheitswerkzeuge bei Wunsch\n\n### Die Leitfrage\n\n**Wenn Sie ein neues Feature in Betracht ziehen, fragen Sie:**\n\n> \"Gibt dies dem Programmierer mehr explizite Kontrolle, oder verbirgt es etwas?\"\n\n- Wenn es **explizite Kontrolle hinzufgt**  passt wahrscheinlich zu Hemlock\n- Wenn es **Komplexitt verbirgt**  gehrt wahrscheinlich nicht dazu\n- Wenn es **optionaler Zucker** ist, der klar dokumentiert ist  knnte OK sein\n\n### Beispiele fr gute Ergnzungen\n\n- **Switch-Anweisungen** - Expliziter Kontrollfluss, keine Magie, klare Semantik\n\n- **Async/await mit pthreads** - Explizite Nebenlufigkeit, echte Parallelitt, Benutzer kontrolliert das Spawning\n\n- **Buffer-Typ neben ptr** - Gibt Wahl zwischen sicher und unsicher\n\n- **Optionale Typannotationen** - Hilft Bugs zu erkennen, ohne Striktheit zu erzwingen\n\n- **Try/catch/finally** - Explizite Fehlerbehandlung mit klarem Kontrollfluss\n\n### Beispiele fr schlechte Ergnzungen\n\n- **Automatische Semikolon-Einfgung** - Verbirgt Syntaxfehler, macht Code mehrdeutig\n\n- **RAII/Destruktoren** - Automatische Bereinigung verbirgt, wann Ressourcen freigegeben werden\n\n- **Implizite Null-Koaleszenz** - Verbirgt Null-Prfungen, macht Code schwerer nachvollziehbar\n\n- **Automatisch wachsende Strings** - Verbirgt Speicherallokation, unvorhersehbare Leistung\n\n---\n\n## Fazit\n\nHemlock versucht nicht, die sicherste Sprache, die schnellste Sprache oder die funktionsreichste Sprache zu sein.\n\n**Hemlock versucht, die *ehrlichste* Sprache zu sein.**\n\nSie sagt Ihnen genau, was sie tut, gibt Ihnen Kontrolle, wenn Sie sie brauchen, und verbirgt die scharfen Kanten nicht. Es ist eine Sprache fr Menschen, die ihren Code auf niedriger Ebene verstehen wollen, whrend sie moderne Ergonomie genieen.\n\nWenn Sie sich nicht sicher sind, ob ein Feature zu Hemlock gehrt, denken Sie daran:\n\n> **Explizit statt implizit, immer.**\n> **Unsicherheit ist ein Feature, kein Bug.**\n> **Der Benutzer ist verantwortlich, und das ist OK.**\n"}, "Design & Philosophie -> Implementierung": {"id": "design-implementation", "content": "# Hemlock Implementierungsdetails\n\nDieses Dokument beschreibt die technische Implementierung der Hemlock-Sprache, einschlielich Projektstruktur, Kompilierungspipeline, Laufzeitarchitektur und Designentscheidungen.\n\n---\n\n## Inhaltsverzeichnis\n\n- [Projektstruktur](#projektstruktur)\n- [Kompilierungspipeline](#kompilierungspipeline)\n- [Modulares Interpreter-Design](#modulares-interpreter-design)\n- [Laufzeitarchitektur](#laufzeitarchitektur)\n- [Wertdarstellung](#wertdarstellung)\n- [Typsystem-Implementierung](#typsystem-implementierung)\n- [Speicherverwaltung](#speicherverwaltung)\n- [Nebenlufigkeitsmodell](#nebenlufigkeitsmodell)\n- [Zukunftsplne](#zukunftsplne)\n\n---\n\n## Projektstruktur\n\n```\nhemlock/\n src/\n    frontend/              # Gemeinsam: Lexer, Parser, AST\n       lexer.c            # Tokenisierung\n       parser/            # Rekursiver Abstiegsparser\n       ast.c              # AST-Knotenverwaltung\n       module.c           # Modulauflsung\n    backends/\n       interpreter/       # hemlock: Tree-Walking-Interpreter\n          main.c         # CLI-Einstiegspunkt\n          runtime.c      # Ausdrucks-/Anweisungsauswertung\n          builtins.c     # Eingebaute Funktionen\n          ...\n       compiler/          # hemlockc: C-Code-Generator\n           main.c         # CLI, Orchestrierung\n           type_check.c   # Kompilierzeit-Typprfung\n           codegen.c      # Code-Generierungskontext\n           codegen_expr.c # Ausdrucks-Codegen\n           codegen_stmt.c # Anweisungs-Codegen\n           ...\n    tools/\n       lsp/               # Language Server Protocol\n       bundler/           # Bundle-/Paket-Werkzeuge\n runtime/                   # libhemlock_runtime.a (fr kompilierte Programme)\n stdlib/                    # Standardbibliothek (39 Module)\n    docs/                  # Moduldokumentation\n tests/\n    parity/                # Tests, die beide Backends bestehen mssen\n    interpreter/           # Interpreter-spezifische Tests\n    compiler/              # Compiler-spezifische Tests\n examples/                  # Beispielprogramme\n docs/                      # Dokumentation\n```\n\n### Verzeichnisorganisation\n\n**`include/`** - ffentliche API-Header, die die Schnittstelle zwischen Komponenten definieren:\n- Saubere Trennung zwischen Lexer, Parser, AST und Interpreter\n- Vorwrtsdeklarationen zur Minimierung von Abhngigkeiten\n- ffentliche API zum Einbetten von Hemlock in andere Programme\n\n**`src/`** - Implementierungsdateien:\n- Dateien auf oberster Ebene behandeln Lexing, Parsing, AST-Verwaltung\n- `main.c` bietet CLI und REPL\n- Der Interpreter ist in separate Subsysteme modularisiert\n\n**`src/interpreter/`** - Modulare Interpreter-Implementierung:\n- Jedes Modul hat eine einzelne, klare Verantwortung\n- Interne API in `internal.h` fr Inter-Modul-Kommunikation definiert\n- Module knnen unabhngig kompiliert werden fr schnellere Builds\n\n**`tests/`** - Umfassende Testsuite:\n- Nach Funktionsbereich organisiert\n- Jedes Verzeichnis enthlt fokussierte Testflle\n- `run_tests.sh` orchestriert die Testausfhrung\n\n---\n\n## Kompilierungspipeline\n\nHemlock verwendet eine traditionelle Kompilierungspipeline mit verschiedenen Phasen:\n\n### Phase 1: Lexikalische Analyse (Lexer)\n\n**Eingabe:** Quellcode-Text\n**Ausgabe:** Token-Strom\n**Implementierung:** `src/lexer.c`\n\n```\nQuelle: \"let x = 42;\"\n   \nTokens: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n```\n\n**Schlsselfunktionen:**\n- Erkennt Schlsselwrter, Bezeichner, Literale, Operatoren, Interpunktion\n- Behandelt UTF-8-Stringliterale und Rune-Literale\n- Meldet Zeilennummern fr Fehlermeldungen\n- Einziger Durchlauf, kein Backtracking\n\n### Phase 2: Syntaxanalyse (Parser)\n\n**Eingabe:** Token-Strom\n**Ausgabe:** Abstrakter Syntaxbaum (AST)\n**Implementierung:** `src/parser.c`\n\n```\nTokens: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n   \nAST: LetStmt {\n    name: \"x\",\n    type: null,\n    value: IntLiteral(42)\n}\n```\n\n**Schlsselfunktionen:**\n- Rekursiver Abstiegsparser\n- Baut Baumdarstellung der Programmstruktur auf\n- Behandelt Operatorprioritt\n- Validiert Syntax (Klammern, Semikolons usw.)\n- Noch keine semantische Analyse (erfolgt zur Laufzeit)\n\n**Operatorprioritt (niedrigste bis hchste):**\n1. Zuweisung: `=`\n2. Logisches ODER: `||`\n3. Logisches UND: `&&`\n4. Bitweises ODER: `|`\n5. Bitweises XOR: `^`\n6. Bitweises UND: `&`\n7. Gleichheit: `==`, `!=`\n8. Vergleich: `<`, `>`, `<=`, `>=`\n9. Bitweise Verschiebungen: `<<`, `>>`\n10. Addition/Subtraktion: `+`, `-`\n11. Multiplikation/Division/Modulo: `*`, `/`, `%`\n12. Unr: `!`, `-`, `~`\n13. Aufruf/Index/Element: `()`, `[]`, `.`\n\n### Phase 3a: Interpretation (Tree-Walking)\n\n**Eingabe:** AST\n**Ausgabe:** Programmausfhrung\n**Implementierung:** `src/backends/interpreter/runtime.c`\n\n```\nAST: LetStmt { ... }\n   \nAusfhrung: Wertet AST-Knoten rekursiv aus\n   \nErgebnis: Variable x mit Wert 42 erstellt\n```\n\n**Schlsselfunktionen:**\n- Direkte AST-Traversierung (Tree-Walking-Interpreter)\n- Dynamische Typprfung zur Laufzeit\n- Umgebungsbasierte Variablenspeicherung\n\n### Phase 3b: Kompilierung (hemlockc)\n\n**Eingabe:** AST\n**Ausgabe:** Native ausfhrbare Datei ber C-Codegenerierung\n**Implementierung:** `src/backends/compiler/`\n\n```\nAST: LetStmt { ... }\n   \nTypprfung: Typen zur Kompilierzeit validieren\n   \nC-Codegen: quivalenten C-Code generieren\n   \nGCC: C zu nativer Binrdatei kompilieren\n   \nErgebnis: Eigenstndige ausfhrbare Datei\n```\n\n**Schlsselfunktionen:**\n- Kompilierzeit-Typprfung (standardmig aktiviert)\n- C-Codegenerierung fr Portabilitt\n- Linkt gegen `libhemlock_runtime.a`\n- Deutlich schnellere Ausfhrung als Interpreter\n\n---\n\n## Compiler-Backend (hemlockc)\n\nDer Hemlock-Compiler generiert C-Code aus dem AST, der dann mit GCC zu einer nativen ausfhrbaren Datei kompiliert wird.\n\n### Compiler-Architektur\n\n```\nsrc/backends/compiler/\n main.c              # CLI, Argumentparsing, Orchestrierung\n codegen.c           # Kern-Codegenerierungskontext\n codegen_expr.c      # Ausdrucks-Codegenerierung\n codegen_stmt.c      # Anweisungs-Codegenerierung\n codegen_call.c      # Funktionsaufruf-Generierung\n codegen_closure.c   # Closure-Implementierung\n codegen_program.c   # Programm-Generierung auf oberster Ebene\n codegen_module.c    # Modul-/Import-Behandlung\n type_check.c        # Kompilierzeit-Typprfung\n type_check.h        # Typprfer-API\n```\n\n### Typprfung\n\nDer Compiler enthlt ein vereinheitlichtes Typprfungssystem, das:\n\n1. **Typen zur Kompilierzeit validiert** - Erkennt Typfehler vor der Ausfhrung\n2. **Dynamischen Code untersttzt** - Untypisierter Code wird als `any` behandelt (immer gltig)\n3. **Optimierungshinweise liefert** - Identifiziert Variablen, die unboxed werden knnen\n\n**Typprfungs-Flags:**\n\n| Flag | Beschreibung |\n|------|--------------|\n| (Standard) | Typprfung aktiviert |\n| `--check` | Nur Typprfung, nicht kompilieren |\n| `--no-type-check` | Typprfung deaktivieren |\n| `--strict-types` | Warnung bei impliziten `any`-Typen |\n\n**Typprfer-Implementierung:**\n\n```c\n// type_check.h - Schlsselstrukturen\ntypedef struct TypeCheckContext {\n    const char *filename;\n    int error_count;\n    int warning_count;\n    UnboxableVar *unboxable_vars;  // Optimierungshinweise\n    // ... Typumgebung, Definitionen usw.\n} TypeCheckContext;\n\n// Haupteinstiegspunkt\nint type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);\n```\n\n### Codegenerierung\n\nDie Codegen-Phase bersetzt AST-Knoten in C-Code:\n\n**Ausdruckszuordnung:**\n```\nHemlock                   Generiertes C\n----------------------------------------\nlet x = 42;              HmlValue x = hml_val_i32(42);\nx + y                    hml_add(x, y)\narr[i]                   hml_array_get(arr, i)\nobj.field                hml_object_get_field(obj, \"field\")\nfn(a, b) { ... }         Closure mit Umgebungserfassung\n```\n\n**Laufzeit-Integration:**\n\nGenerierter C-Code linkt gegen `libhemlock_runtime.a`, die bereitstellt:\n- `HmlValue` tagged union-Typ\n- Speicherverwaltung (Reference Counting)\n- Eingebaute Funktionen (print, typeof usw.)\n- Nebenlufigkeitsprimitiven (Tasks, Kanle)\n- FFI-Untersttzung\n\n### Unboxing-Optimierung\n\nDer Typprfer identifiziert Variablen, die native C-Typen anstelle von geboxten `HmlValue` verwenden knnen:\n\n**Unboxbare Muster:**\n- Schleifenzhler mit bekanntem Integer-Typ\n- Akkumulatorvariablen in Schleifen\n- Variablen mit expliziten Typannotationen (i32, i64, f64, bool)\n\n```hemlock\n// Schleifenzhler 'i' kann zu nativem int32_t unboxed werden\nfor (let i: i32 = 0; i < 1000000; i = i + 1) {\n    sum = sum + i;\n}\n```\n\n---\n\n## Modulares Interpreter-Design\n\nDer Interpreter ist fr Wartbarkeit und Skalierbarkeit in fokussierte Module aufgeteilt.\n\n### Modulverantwortlichkeiten\n\n#### 1. Umgebung (`environment.c`) - 121 Zeilen\n\n**Zweck:** Variablen-Scoping und Namensauflsung\n\n**Schlsselfunktionen:**\n- `env_create()` - Neue Umgebung mit optionalem Elternteil erstellen\n- `env_define()` - Neue Variable im aktuellen Scope definieren\n- `env_get()` - Variable im aktuellen oder Eltern-Scope nachschlagen\n- `env_set()` - Bestehenden Variablenwert aktualisieren\n- `env_free()` - Umgebung und alle Variablen freigeben\n\n**Design:**\n- Verknpfte Scopes (jede Umgebung hat Zeiger auf Elternteil)\n- HashMap fr schnelle Variablensuche\n- Untersttzt lexikalisches Scoping fr Closures\n\n#### 2. Werte (`values.c`) - 394 Zeilen\n\n**Zweck:** Wertkonstruktoren und Datenstrukturverwaltung\n\n**Schlsselfunktionen:**\n- `value_create_*()` - Konstruktoren fr jeden Werttyp\n- `value_copy()` - Tiefe/flache Kopierlogik\n- `value_free()` - Bereinigung und Speicherfreigabe\n- `value_to_string()` - Stringdarstellung fr Ausgabe\n\n**Datenstrukturen:**\n- Objekte (dynamische Feldarrays)\n- Arrays (dynamische Grennderung)\n- Buffer (ptr + Lnge + Kapazitt)\n- Closures (Funktion + erfasste Umgebung)\n- Tasks und Kanle (Nebenlufigkeitsprimitiven)\n\n#### 3. Typen (`types.c`) - 440 Zeilen\n\n**Zweck:** Typsystem, Konvertierungen und Duck-Typing\n\n**Schlsselfunktionen:**\n- `type_check()` - Laufzeit-Typvalidierung\n- `type_convert()` - Implizite Typkonvertierungen/-promotionen\n- `duck_type_check()` - Strukturelle Typprfung fr Objekte\n- `type_name()` - Druckbaren Typnamen abrufen\n\n**Funktionen:**\n- Typpromotionshierarchie (i8  i16  i32  i64  f32  f64, wobei i64/u64 + f32  f64)\n- Bereichsprfung fr numerische Typen\n- Duck-Typing fr Objekttypdefinitionen\n- Optionale Feldstandards\n\n#### 4. Builtins (`builtins.c`) - 955 Zeilen\n\n**Zweck:** Eingebaute Funktionen und globale Registrierung\n\n**Schlsselfunktionen:**\n- `register_builtins()` - Alle eingebauten Funktionen und Konstanten registrieren\n- Implementierungen eingebauter Funktionen (print, typeof, alloc, free usw.)\n- Signalbehandlungsfunktionen\n- Befehlsausfhrung (exec)\n\n**Kategorien von Builtins:**\n- I/O: print, open, read_file, write_file\n- Speicher: alloc, free, memset, memcpy, realloc\n- Typen: typeof, assert\n- Nebenlufigkeit: spawn, join, detach, channel\n- System: exec, signal, raise, panic\n- FFI: dlopen, dlsym, dlcall, dlclose\n\n#### 5. I/O (`io.c`) - 449 Zeilen\n\n**Zweck:** Datei-I/O und JSON-Serialisierung\n\n**Schlsselfunktionen:**\n- Dateiobjektmethoden (read, write, seek, tell, close)\n- JSON-Serialisierung/Deserialisierung\n- Erkennung zirkulrer Referenzen\n\n**Funktionen:**\n- Dateiobjekt mit Eigenschaften (Pfad, Modus, geschlossen)\n- UTF-8-bewusste Text-I/O\n- Binre I/O-Untersttzung\n- JSON-Roundtripping fr Objekte und Arrays\n\n#### 6. FFI (`ffi.c`) - Foreign Function Interface\n\n**Zweck:** Aufrufen von C-Funktionen aus gemeinsam genutzten Bibliotheken\n\n**Schlsselfunktionen:**\n- `dlopen()` - Gemeinsam genutzte Bibliothek laden\n- `dlsym()` - Funktionszeiger nach Namen abrufen\n- `dlcall()` - C-Funktion mit Typkonvertierung aufrufen\n- `dlclose()` - Bibliothek entladen\n\n**Funktionen:**\n- Integration mit libffi fr dynamische Funktionsaufrufe\n- Automatische Typkonvertierung (Hemlock  C-Typen)\n- Untersttzung fr alle primitiven Typen\n- Zeiger- und Buffer-Untersttzung\n\n#### 7. Laufzeit (`runtime.c`) - 865 Zeilen\n\n**Zweck:** Ausdrucksauswertung und Anweisungsausfhrung\n\n**Schlsselfunktionen:**\n- `eval_expr()` - Ausdrcke auswerten (rekursiv)\n- `eval_stmt()` - Anweisungen ausfhren\n- Kontrollflussbehandlung (if, while, for, switch usw.)\n- Ausnahmebehandlung (try/catch/finally/throw)\n\n**Funktionen:**\n- Rekursive Ausdrucksauswertung\n- Kurzschluss-Auswertung fr boolesche Ausdrcke\n- Methodenaufruferkennung und `self`-Bindung\n- Ausnahmepropagierung\n- Break/continue/return-Behandlung\n\n### Vorteile des modularen Designs\n\n**1. Trennung der Zustndigkeiten**\n- Jedes Modul hat eine klare Verantwortung\n- Leicht zu finden, wo Funktionen implementiert sind\n- Reduziert kognitive Belastung bei nderungen\n\n**2. Schnellere inkrementelle Builds**\n- Nur modifizierte Module mssen neu kompiliert werden\n- Parallele Kompilierung mglich\n- Krzere Iterationszeiten whrend der Entwicklung\n\n**3. Einfacheres Testen und Debuggen**\n- Module knnen isoliert getestet werden\n- Bugs sind auf spezifische Subsysteme lokalisiert\n- Mock-Implementierungen fr Tests mglich\n\n**4. Skalierbarkeit**\n- Neue Funktionen knnen zu geeigneten Modulen hinzugefgt werden\n- Module knnen unabhngig refaktoriert werden\n- Codegre pro Datei bleibt handhabbar\n\n**5. Code-Organisation**\n- Logische Gruppierung verwandter Funktionalitt\n- Klarer Abhngigkeitsgraph\n- Einfacheres Onboarding fr neue Mitwirkende\n\n---\n\n## Laufzeitarchitektur\n\n### Wertdarstellung\n\nAlle Werte in Hemlock werden durch die `Value`-Struktur unter Verwendung einer tagged union dargestellt:\n\n```c\ntypedef struct Value {\n    ValueType type;  // Laufzeit-Typ-Tag\n    union {\n        int32_t i32_value;\n        int64_t i64_value;\n        uint8_t u8_value;\n        uint32_t u32_value;\n        uint64_t u64_value;\n        float f32_value;\n        double f64_value;\n        bool bool_value;\n        char *string_value;\n        uint32_t rune_value;\n        void *ptr_value;\n        Buffer *buffer_value;\n        Array *array_value;\n        Object *object_value;\n        Function *function_value;\n        File *file_value;\n        Task *task_value;\n        Channel *channel_value;\n    };\n} Value;\n```\n\n**Designentscheidungen:**\n- **Tagged Union** fr Typsicherheit bei gleichzeitiger Flexibilitt\n- **Laufzeit-Typ-Tags** ermglichen dynamische Typisierung mit Typprfung\n- **Direkte Wertspeicherung** fr Primitiven (kein Boxing)\n- **Zeigerspeicherung** fr heap-allokierte Typen (Strings, Objekte, Arrays)\n\n### Beispiele fr Speicherlayout\n\n**Ganzzahl (i32):**\n```\nValue {\n    type: TYPE_I32,\n    i32_value: 42\n}\n```\n- Gesamtgre: ~16 Bytes (8-Byte-Tag + 8-Byte-Union)\n- Stack-allokiert\n- Keine Heap-Allokation erforderlich\n\n**String:**\n```\nValue {\n    type: TYPE_STRING,\n    string_value: 0x7f8a4c000000  // Zeiger auf Heap\n}\n\nHeap: \"hello\\0\" (6 Bytes, nullterminiertes UTF-8)\n```\n- Wert ist 16 Bytes auf dem Stack\n- Stringdaten sind heap-allokiert\n- Muss manuell freigegeben werden\n\n**Objekt:**\n```\nValue {\n    type: TYPE_OBJECT,\n    object_value: 0x7f8a4c001000  // Zeiger auf Heap\n}\n\nHeap: Object {\n    type_name: \"Person\",\n    fields: [\n        { name: \"name\", value: Value{TYPE_STRING, \"Alice\"} },\n        { name: \"age\", value: Value{TYPE_I32, 30} }\n    ],\n    field_count: 2,\n    capacity: 4\n}\n```\n- Objektstruktur auf dem Heap\n- Felder in dynamischem Array gespeichert\n- Feldwerte sind eingebettete Value-Structs\n\n### Umgebungsimplementierung\n\nVariablen werden in Umgebungsketten gespeichert:\n\n```c\ntypedef struct Environment {\n    HashMap *bindings;           // Name  Value\n    struct Environment *parent;  // Lexikalischer Eltern-Scope\n} Environment;\n```\n\n**Scope-Ketten-Beispiel:**\n```\nGlobaler Scope: { print: <builtin>, args: <array> }\n    \nFunktions-Scope: { x: 10, y: 20 }\n    \nBlock-Scope: { i: 0 }\n```\n\n**Suchalgorithmus:**\n1. Hashmap der aktuellen Umgebung prfen\n2. Falls nicht gefunden, Elternumgebung prfen\n3. Wiederholen bis gefunden oder globaler Scope erreicht\n4. Fehler wenn in keinem Scope gefunden\n\n---\n\n## Typsystem-Implementierung\n\n### Typprfungsstrategie\n\nHemlock verwendet **Laufzeit-Typprfung** mit **optionalen Typannotationen**:\n\n```hemlock\nlet x = 42;           // Keine Typprfung, inferiert i32\nlet y: u8 = 255;      // Laufzeitprfung: Wert muss in u8 passen\nlet z: i32 = x + y;   // Laufzeitprfung + Typpromotion\n```\n\n**Implementierungsfluss:**\n1. **Literalinferenz** - Lexer/Parser bestimmen initialen Typ aus Literal\n2. **Typannotationsprfung** - Falls Annotation vorhanden, bei Zuweisung validieren\n3. **Promotion** - Binre Operationen werden zu gemeinsamem Typ hochgestuft\n4. **Konvertierung** - Explizite Konvertierungen erfolgen bei Bedarf\n\n### Typpromotionsimplementierung\n\nTyppromotion folgt einer festen Hierarchie mit Przisionserhaltung:\n\n```c\n// Vereinfachte Promotionslogik\nValueType promote_types(ValueType a, ValueType b) {\n    // f64 gewinnt immer\n    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;\n\n    // f32 mit i64/u64 wird zu f64 hochgestuft (Przisionserhaltung)\n    if (a == TYPE_F32 || b == TYPE_F32) {\n        ValueType other = (a == TYPE_F32) ? b : a;\n        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;\n        return TYPE_F32;\n    }\n\n    // Grere Integer-Typen gewinnen\n    int rank_a = get_type_rank(a);\n    int rank_b = get_type_rank(b);\n    return (rank_a > rank_b) ? a : b;\n}\n```\n\n**Typrnge:**\n- i8: 0\n- u8: 1\n- i16: 2\n- u16: 3\n- i32: 4\n- u32: 5\n- i64: 6\n- u64: 7\n- f32: 8\n- f64: 9\n\n### Duck-Typing-Implementierung\n\nObjekttypprfung verwendet strukturellen Vergleich:\n\n```c\nbool duck_type_check(Object *obj, TypeDef *type_def) {\n    // Alle erforderlichen Felder prfen\n    for (each field in type_def) {\n        if (!object_has_field(obj, field.name)) {\n            return false;  // Fehlendes Feld\n        }\n\n        Value *field_value = object_get_field(obj, field.name);\n        if (!type_matches(field_value, field.type)) {\n            return false;  // Falscher Typ\n        }\n    }\n\n    return true;  // Alle erforderlichen Felder vorhanden und korrekter Typ\n}\n```\n\n**Duck-Typing erlaubt:**\n- Zustzliche Felder in Objekten (ignoriert)\n- Substrukturelle Typisierung (Objekt kann mehr als erforderlich haben)\n- Typnamenzuweisung nach Validierung\n\n---\n\n## Speicherverwaltung\n\n### Allokationsstrategie\n\nHemlock verwendet **manuelle Speicherverwaltung** mit zwei Allokationsprimitiven:\n\n**1. Rohe Zeiger (`ptr`):**\n```c\nvoid *alloc(size_t bytes) {\n    void *ptr = malloc(bytes);\n    if (!ptr) {\n        fprintf(stderr, \"Kein Speicher mehr\\n\");\n        exit(1);\n    }\n    return ptr;\n}\n```\n- Direktes malloc/free\n- Kein Tracking\n- Benutzerverantwortung zur Freigabe\n\n**2. Buffer (`buffer`):**\n```c\ntypedef struct Buffer {\n    void *data;\n    size_t length;\n    size_t capacity;\n} Buffer;\n\nBuffer *create_buffer(size_t size) {\n    Buffer *buf = malloc(sizeof(Buffer));\n    buf->data = malloc(size);\n    buf->length = size;\n    buf->capacity = size;\n    return buf;\n}\n```\n- Verfolgt Gre und Kapazitt\n- Bereichsprfung beim Zugriff\n- Erfordert immer noch manuelles free\n\n### Heap-allokierte Typen\n\n**Strings:**\n- UTF-8-Byte-Array auf dem Heap\n- Nullterminiert fr C-Interoperabilitt\n- Vernderbar (kann an Ort und Stelle modifiziert werden)\n- Refgezhlt (automatisch freigegeben, wenn Scope verlassen wird)\n\n**Objekte:**\n- Dynamisches Feldarray\n- Feldnamen und Werte auf dem Heap\n- Refgezhlt (automatisch freigegeben, wenn Scope verlassen wird)\n- Zirkulre Referenzen mglich (behandelt mit Visited-Set-Tracking)\n\n**Arrays:**\n- Dynamisches Kapazittsverdopplungswachstum\n- Elemente sind eingebettete Value-Structs\n- Automatische Neuzuweisung bei Wachstum\n- Refgezhlt (automatisch freigegeben, wenn Scope verlassen wird)\n\n**Closures:**\n- Erfassen Umgebung per Referenz\n- Umgebung ist heap-allokiert\n- Closure-Umgebungen werden ordnungsgem freigegeben, wenn nicht mehr referenziert\n\n---\n\n## Nebenlufigkeitsmodell\n\n### Threading-Architektur\n\nHemlock verwendet **1:1-Threading** mit POSIX-Threads (pthreads):\n\n```\nBenutzer-Task          OS-Thread          CPU-Kern\n------------          ---------          --------\nspawn(f1) ------>  pthread_create --> Kern 0\nspawn(f2) ------>  pthread_create --> Kern 1\nspawn(f3) ------>  pthread_create --> Kern 2\n```\n\n**Schlsseleigenschaften:**\n- Jedes `spawn()` erstellt einen neuen pthread\n- Kernel plant Threads ber Kerne\n- Echte parallele Ausfhrung (kein GIL)\n- Premptives Multitasking\n\n### Task-Implementierung\n\n```c\ntypedef struct Task {\n    pthread_t thread;        // OS-Thread-Handle\n    Value result;            // Rckgabewert\n    char *error;             // Ausnahmemeldung (falls geworfen)\n    pthread_mutex_t lock;    // Schtzt Zustand\n    TaskState state;         // RUNNING, FINISHED, ERROR\n} Task;\n```\n\n**Task-Lebenszyklus:**\n1. `spawn(func, args)`  Task erstellen, pthread starten\n2. Thread fhrt Funktion mit Argumenten aus\n3. Bei Rckgabe: Ergebnis speichern, Zustand auf FINISHED setzen\n4. Bei Ausnahme: Fehlermeldung speichern, Zustand auf ERROR setzen\n5. `join(task)`  Auf Thread warten, Ergebnis zurckgeben oder Ausnahme werfen\n\n### Kanal-Implementierung\n\n```c\ntypedef struct Channel {\n    void **buffer;           // Zirkulrer Puffer von Value*\n    size_t capacity;         // Maximale gepufferte Elemente\n    size_t count;            // Aktuelle Elemente im Puffer\n    size_t read_index;       // Nchste Leseposition\n    size_t write_index;      // Nchste Schreibposition\n    bool closed;             // Kanal-geschlossen-Flag\n    pthread_mutex_t lock;    // Schtzt Puffer\n    pthread_cond_t not_full; // Signal wenn Platz verfgbar\n    pthread_cond_t not_empty;// Signal wenn Daten verfgbar\n} Channel;\n```\n\n**Sende-Operation:**\n1. Mutex sperren\n2. Warten wenn Puffer voll (cond_wait auf not_full)\n3. Wert in buffer[write_index] schreiben\n4. write_index inkrementieren (zirkulr)\n5. not_empty signalisieren\n6. Mutex entsperren\n\n**Empfangs-Operation:**\n1. Mutex sperren\n2. Warten wenn Puffer leer (cond_wait auf not_empty)\n3. Wert aus buffer[read_index] lesen\n4. read_index inkrementieren (zirkulr)\n5. not_full signalisieren\n6. Mutex entsperren\n\n**Synchronisationsgarantien:**\n- Thread-sicheres Senden/Empfangen (durch Mutex geschtzt)\n- Blockierende Semantik (Produzent wartet wenn voll, Konsument wartet wenn leer)\n- Geordnete Zustellung (FIFO innerhalb eines Kanals)\n\n---\n\n## Zukunftsplne\n\n### Abgeschlossen: Compiler-Backend \n\nDas Compiler-Backend (`hemlockc`) wurde implementiert mit:\n- C-Codegenerierung aus AST\n- Kompilierzeit-Typprfung (standardmig aktiviert)\n- Laufzeitbibliothek (`libhemlock_runtime.a`)\n- Volle Paritt mit Interpreter (98% Testbestehensrate)\n- Unboxing-Optimierungsframework\n\n### Aktueller Fokus: Typsystem-Erweiterungen\n\n**Aktuelle Verbesserungen:**\n- Vereinheitlichte Typprfungs- und Typinferenzsysteme\n- Kompilierzeit-Typprfung standardmig aktiviert\n- `--check`-Flag fr Nur-Typ-Validierung\n- Typkontext wird an Codegen fr Optimierungshinweise bergeben\n\n### Zuknftige Erweiterungen\n\n**Potenzielle Ergnzungen:**\n- Generics/Templates\n- Pattern Matching\n- LSP-Integration fr typbewusste IDE-Untersttzung\n- Aggressivere Unboxing-Optimierungen\n- Escape-Analyse fr Stack-Allokation\n\n### Langfristige Optimierungen\n\n**Mgliche Verbesserungen:**\n- Inline-Caching fr Methodenaufrufe\n- JIT-Kompilierung fr heie Codepfade\n- Work-Stealing-Scheduler fr bessere Nebenlufigkeit\n- Profilgefhrte Optimierung\n\n---\n\n## Implementierungsrichtlinien\n\n### Hinzufgen neuer Features\n\nBeim Implementieren neuer Features befolgen Sie diese Richtlinien:\n\n**1. Das richtige Modul whlen:**\n- Neue Werttypen  `values.c`\n- Typkonvertierungen  `types.c`\n- Eingebaute Funktionen  `builtins.c`\n- I/O-Operationen  `io.c`\n- Kontrollfluss  `runtime.c`\n\n**2. Alle Schichten aktualisieren:**\n- AST-Knotentypen hinzufgen falls ntig (`ast.h`, `ast.c`)\n- Lexer-Token hinzufgen falls ntig (`lexer.c`)\n- Parser-Regeln hinzufgen (`parser.c`)\n- Laufzeitverhalten implementieren (`runtime.c` oder geeignetes Modul)\n- Tests hinzufgen (`tests/`)\n\n**3. Konsistenz beibehalten:**\n- Bestehendem Codestil folgen\n- Konsistente Namenskonventionen verwenden\n- ffentliche API in Headern dokumentieren\n- Fehlermeldungen klar und konsistent halten\n\n**4. Grndlich testen:**\n- Testflle vor der Implementierung hinzufgen\n- Erfolgs- und Fehlerpfade testen\n- Randflle testen\n- Keine Speicherlecks verifizieren (valgrind)\n\n### Leistungsberlegungen\n\n**Aktuelle Engpsse:**\n- HashMap-Suchen fr Variablenzugriff\n- Rekursive Funktionsaufrufe (keine TCO)\n- String-Verkettung (allokiert jedes Mal neuen String)\n- Typprfungs-Overhead bei jeder Operation\n\n**Optimierungsmglichkeiten:**\n- Variablenpositionen cachen (Inline-Caching)\n- Endrekursionsoptimierung\n- String-Builder fr Verkettung\n- Typinferenz um Laufzeitprfungen zu berspringen\n\n### Debugging-Tipps\n\n**Ntzliche Werkzeuge:**\n- `valgrind` - Speicherleckerkennung\n- `gdb` - Abstrze debuggen\n- `-g`-Flag - Debug-Symbole\n- `printf`-Debugging - Einfach aber effektiv\n\n**Hufige Probleme:**\n- Segfault  Nullzeiger-Dereferenzierung (Rckgabewerte prfen)\n- Speicherleck  Fehlender free()-Aufruf (value_free-Pfade prfen)\n- Typfehler  type_convert()- und type_check()-Logik prfen\n- Absturz in Threads  Race Condition (Mutex-Verwendung prfen)\n\n---\n\n## Fazit\n\nHemlocks Implementierung priorisiert:\n- **Modularitt** - Saubere Trennung der Zustndigkeiten\n- **Einfachheit** - Geradlinige Implementierung\n- **Explizitheit** - Keine versteckte Magie\n- **Wartbarkeit** - Leicht zu verstehen und zu modifizieren\n\nDer aktuelle Tree-Walking-Interpreter ist absichtlich einfach, um schnelle Feature-Entwicklung und Experimente zu ermglichen. Das zuknftige Compiler-Backend wird die Leistung verbessern und dabei die gleiche Semantik beibehalten.\n"}, "Design & Philosophie -> Signatur-Syntax": {"id": "design-signature-syntax", "content": "# Design der Signatur-Syntax\n\n> Erweiterung des Typsystems von Hemlock um Funktionstypen, Nullable-Modifikatoren, Typaliase, Const-Parameter und Methodensignaturen.\n\n**Status:** Implementiert (v1.7.0)\n**Version:** 1.0\n**Autor:** Claude\n\n---\n\n## berblick\n\nDieses Dokument schlgt fnf zusammenhngende Typsystem-Erweiterungen vor, die auf der bestehenden Infrastruktur von Hemlock aufbauen:\n\n1. **Funktionstyp-Annotationen** - Erstklassige Funktionstypen\n2. **Nullable-Typ-Modifikatoren** - Explizite Null-Behandlung (erweitert bestehendes `nullable`-Flag)\n3. **Typaliase** - Benannte Typabkrzungen\n4. **Const-Parameter** - Unvernderlichkeitsvertrge\n5. **Methodensignaturen in Define** - Interface-hnliches Verhalten\n\nDiese Features teilen die Philosophie: **explizit statt implizit, optional aber durchgesetzt wenn verwendet**.\n\n---\n\n## 1. Funktionstyp-Annotationen\n\n### Motivation\n\nDerzeit gibt es keine Mglichkeit, die Signatur einer Funktion als Typ auszudrcken:\n\n```hemlock\n// Aktuell: callback hat keine Typinformation\nfn map(arr: array, callback) { ... }\n\n// Vorgeschlagen: expliziter Funktionstyp\nfn map(arr: array, callback: fn(any, i32): any): array { ... }\n```\n\n### Syntax\n\n```hemlock\n// Einfacher Funktionstyp\nfn(i32, i32): i32\n\n// Mit Parameternamen (nur Dokumentation, nicht durchgesetzt)\nfn(a: i32, b: i32): i32\n\n// Kein Rckgabewert (void)\nfn(string): void\nfn(string)              // Kurzform: `: void` weglassen\n\n// Nullbarer Rckgabewert\nfn(i32): string?\n\n// Optionale Parameter\nfn(name: string, age?: i32): void\n\n// Rest-Parameter\nfn(...args: array): i32\n\n// Keine Parameter\nfn(): bool\n\n// Hherer Ordnung: Funktion, die Funktion zurckgibt\nfn(i32): fn(i32): i32\n\n// Async-Funktionstyp\nasync fn(i32): i32\n```\n\n### Verwendungsbeispiele\n\n```hemlock\n// Variable mit Funktionstyp\nlet add: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// Funktionsparameter\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Rckgabetyp ist Funktion\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Array von Funktionen\nlet ops: array<fn(i32, i32): i32> = [add, subtract, multiply];\n\n// Objektfeld\ndefine EventHandler {\n    name: string;\n    callback: fn(Event): void;\n}\n```\n\n### AST-nderungen\n\n```c\n// In TypeKind-Enum (include/ast.h)\ntypedef enum {\n    // ... bestehende Typen ...\n    TYPE_FUNCTION,      // NEU: Funktionstyp\n} TypeKind;\n\n// In Type-Struct (include/ast.h)\nstruct Type {\n    TypeKind kind;\n    // ... bestehende Felder ...\n\n    // Fr TYPE_FUNCTION:\n    struct Type **param_types;      // Parametertypen\n    char **param_names;             // Optionale Parameternamen (Doku)\n    int *param_optional;            // Welche Parameter optional sind\n    int num_params;\n    char *rest_param_name;          // Rest-Parametername oder NULL\n    struct Type *rest_param_type;   // Rest-Parametertyp\n    struct Type *return_type;       // Rckgabetyp (NULL = void)\n    int is_async;                   // async fn-Typ\n};\n```\n\n### Parsing\n\nFunktionstypen beginnen mit `fn` (oder `async fn`) gefolgt von Parameterliste:\n\n```\nfunction_type := [\"async\"] \"fn\" \"(\" [param_type_list] \")\" [\":\" type]\nparam_type_list := param_type (\",\" param_type)*\nparam_type := [identifier \":\"] [\"?\"] type | \"...\" [identifier] [\":\" type]\n```\n\n**Disambiguierung:** Beim Parsen eines Typs und `fn` wird angetroffen:\n- Falls gefolgt von `(`, ist es ein Funktionstyp\n- Sonst Syntaxfehler (bloes `fn` ist kein gltiger Typ)\n\n### Typkompatibilitt\n\n```hemlock\n// Exakte bereinstimmung fr Funktionstypen erforderlich\nlet f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // OK\n\n// Parameter-Kontravarianz (breitere Typen akzeptieren ist OK)\nlet g: fn(any): i32 = fn(x: i32): i32 { return x; };  // OK: i32 <: any\n\n// Rckgabe-Kovarianz (engere Typen zurckgeben ist OK)\nlet h: fn(i32): any = fn(x: i32): i32 { return x; };  // OK: i32 <: any\n\n// Aritt muss bereinstimmen\nlet bad: fn(i32): i32 = fn(a, b) { return a; };       // FEHLER: Aritt stimmt nicht berein\n\n// Optionale Parameter kompatibel mit erforderlichen\nlet opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // OK\n```\n\n---\n\n## 2. Nullable-Typ-Modifikatoren\n\n### Motivation\n\nDas `?`-Suffix macht Null-Akzeptanz in Signaturen explizit:\n\n```hemlock\n// Aktuell: unklar ob null gltig ist\nfn find(arr: array, val: any): i32 { ... }\n\n// Vorgeschlagen: explizit nullbarer Rckgabewert\nfn find(arr: array, val: any): i32? { ... }\n```\n\n### Syntax\n\n```hemlock\n// Nullbare Typen mit ?-Suffix\nstring?           // String oder null\ni32?              // i32 oder null\nUser?             // User oder null\narray<i32>?       // Array oder null\nfn(i32): i32?     // Funktion, die i32 oder null zurckgibt\n\n// Kombination mit Funktionstypen\nfn(string?): i32          // Akzeptiert String oder null\nfn(string): i32?          // Gibt i32 oder null zurck\nfn(string?): i32?         // Beide nullbar\n\n// In Define\ndefine Result {\n    value: any?;\n    error: string?;\n}\n```\n\n### Implementierungshinweise\n\n**Existiert bereits:** Das `Type.nullable`-Flag ist bereits im AST. Dieses Feature bentigt hauptschlich:\n1. Parser-Untersttzung fr `?`-Suffix bei jedem Typ (verifizieren/erweitern)\n2. Ordnungsgeme Komposition mit Funktionstypen\n3. Laufzeit-Durchsetzung\n\n### Typkompatibilitt\n\n```hemlock\n// Nicht-nullbar kann nullbar zugewiesen werden\nlet x: i32? = 42;           // OK\nlet y: i32? = null;         // OK\n\n// Nullbar kann NICHT nicht-nullbar zugewiesen werden\nlet z: i32 = x;             // FEHLER: x knnte null sein\n\n// Null-Koaleszenz zum Auspacken\nlet z: i32 = x ?? 0;        // OK: ?? liefert Standardwert\n\n// Optionale Verkettung gibt nullbar zurck\nlet name: string? = user?.name;\n```\n\n---\n\n## 3. Typaliase\n\n### Motivation\n\nKomplexe Typen profitieren von benannten Abkrzungen:\n\n```hemlock\n// Aktuell: repetitive zusammengesetzte Typen\nfn process(entity: HasName & HasId & HasTimestamp) { ... }\nfn validate(entity: HasName & HasId & HasTimestamp) { ... }\n\n// Vorgeschlagen: benannter Alias\ntype Entity = HasName & HasId & HasTimestamp;\nfn process(entity: Entity) { ... }\nfn validate(entity: Entity) { ... }\n```\n\n### Syntax\n\n```hemlock\n// Einfacher Alias\ntype Integer = i32;\ntype Text = string;\n\n// Zusammengesetzter Typ-Alias\ntype Entity = HasName & HasId;\ntype Auditable = HasCreatedAt & HasUpdatedAt & HasCreatedBy;\n\n// Funktionstyp-Alias\ntype Callback = fn(Event): void;\ntype Predicate = fn(any): bool;\ntype Reducer = fn(acc: any, val: any): any;\ntype AsyncTask = async fn(): any;\n\n// Nullbarer Alias\ntype OptionalString = string?;\n\n// Generischer Alias (falls generische Typaliase untersttzt werden)\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// Array-Typ-Alias\ntype IntArray = array<i32>;\ntype Matrix = array<array<f64>>;\n```\n\n### Scope und Sichtbarkeit\n\n```hemlock\n// Standardmig modul-begrenzt\ntype Callback = fn(Event): void;\n\n// Exportierbar\nexport type Handler = fn(Request): Response;\n\n// In einer anderen Datei\nimport { Handler } from \"./handlers.hml\";\nfn register(h: Handler) { ... }\n```\n\n### AST-nderungen\n\n```c\n// Neuer Statement-Typ\ntypedef enum {\n    // ... bestehende Statements ...\n    STMT_TYPE_ALIAS,    // NEU\n} StmtKind;\n\n// In Stmt-Union\nstruct {\n    char *name;                 // Aliasname\n    char **type_params;         // Generische Parameter: <T, U>\n    int num_type_params;\n    Type *aliased_type;         // Der eigentliche Typ\n} type_alias;\n```\n\n### Parsing\n\n```\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n```\n\n**Hinweis:** `type` ist ein neues Schlsselwort. Auf Konflikte mit bestehenden Bezeichnern prfen.\n\n### Auflsung\n\nTypaliase werden aufgelst bei:\n- **Parse-Zeit:** Alias wird in Typumgebung aufgezeichnet\n- **Prf-Zeit:** Alias wird zum zugrunde liegenden Typ erweitert\n- **Laufzeit:** Alias ist transparent (gleich wie zugrunde liegender Typ)\n\n```hemlock\ntype MyInt = i32;\nlet x: MyInt = 42;\ntypeof(x);           // \"i32\" (nicht \"MyInt\")\n```\n\n---\n\n## 4. Const-Parameter\n\n### Motivation\n\nUnvernderlichkeitsabsicht in Funktionssignaturen signalisieren:\n\n```hemlock\n// Aktuell: unklar ob Array modifiziert wird\nfn print_all(items: array) { ... }\n\n// Vorgeschlagen: expliziter Unvernderlichkeitsvertrag\nfn print_all(const items: array) { ... }\n```\n\n### Syntax\n\n```hemlock\n// Const-Parameter\nfn process(const data: buffer) {\n    // data[0] = 0;        // FEHLER: kann const nicht mutieren\n    let x = data[0];       // OK: Lesen erlaubt\n    return x;\n}\n\n// Mehrere Const-Parameter\nfn compare(const a: array, const b: array): bool { ... }\n\n// Gemischte const und vernderliche\nfn update(const source: array, target: array) {\n    for (item in source) {\n        target.push(item);   // OK: target ist vernderlich\n    }\n}\n\n// Const mit Typinferenz\nfn log(const msg) {\n    print(msg);\n}\n\n// Const in Funktionstypen\ntype Reader = fn(const buffer): i32;\n```\n\n### Was Const verhindert\n\n```hemlock\nfn bad(const arr: array) {\n    arr.push(1);         // FEHLER: mutierende Methode\n    arr.pop();           // FEHLER: mutierende Methode\n    arr[0] = 5;          // FEHLER: Index-Zuweisung\n    arr.clear();         // FEHLER: mutierende Methode\n}\n\nfn ok(const arr: array) {\n    let x = arr[0];      // OK: Lesen\n    let len = len(arr);  // OK: Lngenprfung\n    let copy = arr.slice(0, 10);  // OK: erstellt neues Array\n    for (item in arr) {  // OK: Iteration\n        print(item);\n    }\n}\n```\n\n### Mutierende vs. nicht-mutierende Methoden\n\n| Typ | Mutierend (blockiert durch const) | Nicht-mutierend (erlaubt) |\n|-----|-----------------------------------|---------------------------|\n| array | push, pop, shift, unshift, insert, remove, clear, reverse (in-place) | slice, concat, map, filter, find, contains, first, last, join |\n| string | Index-Zuweisung (`s[0] = 'x'`) | alle Methoden (geben neue Strings zurck) |\n| buffer | Index-Zuweisung, memset, memcpy (an) | Index-Lesen, slice |\n| object | Feld-Zuweisung | Feld-Lesen |\n\n### AST-nderungen\n\n```c\n// In Funktionsausdruck (include/ast.h)\nstruct {\n    // ... bestehende Felder ...\n    int *param_is_const;    // NEU: 1 wenn const, 0 sonst\n} function;\n\n// In Type-Struct fr Funktionstypen\nstruct Type {\n    // ... bestehende Felder ...\n    int *param_is_const;    // Fr TYPE_FUNCTION\n};\n```\n\n### Durchsetzung\n\n**Interpreter:**\n- Const-heit in Variablenbindungen verfolgen\n- Vor Mutationsoperationen prfen\n- Laufzeitfehler bei Const-Verletzung\n\n**Compiler:**\n- Const-qualifizierte C-Variablen emittieren wo vorteilhaft\n- Statische Analyse fr Const-Verletzungen\n- Warnung/Fehler zur Kompilierzeit\n\n---\n\n## 5. Methodensignaturen in Define\n\n### Motivation\n\n`define`-Blcken erlauben, erwartete Methoden zu spezifizieren, nicht nur Datenfelder:\n\n```hemlock\n// Aktuell: nur Datenfelder\ndefine User {\n    name: string;\n    age: i32;\n}\n\n// Vorgeschlagen: Methodensignaturen\ndefine Comparable {\n    fn compare(other: Self): i32;\n}\n\ndefine Serializable {\n    fn serialize(): string;\n    fn deserialize(data: string): Self;  // Statische Methode\n}\n```\n\n### Syntax\n\n```hemlock\n// Methodensignatur (kein Body)\ndefine Hashable {\n    fn hash(): i32;\n}\n\n// Mehrere Methoden\ndefine Collection {\n    fn size(): i32;\n    fn is_empty(): bool;\n    fn contains(item: any): bool;\n}\n\n// Gemischte Felder und Methoden\ndefine Entity {\n    id: i32;\n    name: string;\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\n// Self-Typ verwenden\ndefine Cloneable {\n    fn clone(): Self;\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;\n    fn equals(other: Self): bool;\n}\n\n// Optionale Methoden\ndefine Printable {\n    fn to_string(): string;\n    fn debug_string?(): string;  // Optionale Methode (kann fehlen)\n}\n\n// Methoden mit Standard-Implementierungen\ndefine Ordered {\n    fn compare(other: Self): i32;  // Erforderlich\n\n    // Standard-Implementierungen (geerbt wenn nicht berschrieben)\n    fn less_than(other: Self): bool {\n        return self.compare(other) < 0;\n    }\n    fn greater_than(other: Self): bool {\n        return self.compare(other) > 0;\n    }\n    fn equals(other: Self): bool {\n        return self.compare(other) == 0;\n    }\n}\n```\n\n### Der `Self`-Typ\n\n`Self` bezieht sich auf den konkreten Typ, der das Interface implementiert:\n\n```hemlock\ndefine Addable {\n    fn add(other: Self): Self;\n}\n\n// Bei Verwendung:\nlet a: Addable = {\n    value: 10,\n    add: fn(other) {\n        return { value: self.value + other.value, add: self.add };\n    }\n};\n```\n\n### Strukturelle Typisierung (Duck-Typing)\n\nMethodensignaturen verwenden das gleiche Duck-Typing wie Felder:\n\n```hemlock\ndefine Stringifiable {\n    fn to_string(): string;\n}\n\n// Jedes Objekt mit to_string()-Methode erfllt Stringifiable\nlet x: Stringifiable = {\n    name: \"test\",\n    to_string: fn() { return self.name; }\n};\n\n// Zusammengesetzte Typen mit Methoden\ndefine Named { name: string; }\ndefine Printable { fn to_string(): string; }\n\ntype NamedPrintable = Named & Printable;\n\nlet y: NamedPrintable = {\n    name: \"Alice\",\n    to_string: fn() { return \"Name: \" + self.name; }\n};\n```\n\n### AST-nderungen\n\n```c\n// define_object in Stmt-Union erweitern\nstruct {\n    char *name;\n    char **type_params;\n    int num_type_params;\n\n    // Felder (bestehend)\n    char **field_names;\n    Type **field_types;\n    int *field_optional;\n    Expr **field_defaults;\n    int num_fields;\n\n    // Methoden (NEU)\n    char **method_names;\n    Type **method_types;        // TYPE_FUNCTION\n    int *method_optional;       // Optionale Methoden (fn name?(): type)\n    Expr **method_defaults;     // Standard-Implementierungen (NULL wenn nur Signatur)\n    int num_methods;\n} define_object;\n```\n\n### Typprfung\n\nBeim Prfen von `value: InterfaceType`:\n1. Prfen dass alle erforderlichen Felder mit kompatiblen Typen existieren\n2. Prfen dass alle erforderlichen Methoden mit kompatiblen Signaturen existieren\n3. Optionale Felder/Methoden drfen fehlen\n\n```hemlock\ndefine Sortable {\n    fn compare(other: Self): i32;\n}\n\n// Gltig: hat compare-Methode\nlet valid: Sortable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// Ungltig: fehlendes compare\nlet invalid: Sortable = { value: 10 };  // FEHLER: fehlende Methode 'compare'\n\n// Ungltig: falsche Signatur\nlet wrong: Sortable = {\n    compare: fn() { return 0; }  // FEHLER: erwartet (Self): i32\n};\n```\n\n---\n\n## Interaktionsbeispiele\n\n### Alle Features kombinieren\n\n```hemlock\n// Typalias fr komplexen Funktionstyp\ntype EventCallback = fn(event: Event, context: Context?): bool;\n\n// Typalias fr zusammengesetztes Interface\ntype Entity = HasId & HasName & Serializable;\n\n// Define mit Methodensignaturen\ndefine Repository<T> {\n    fn find(id: i32): T?;\n    fn save(const entity: T): bool;\n    fn delete(id: i32): bool;\n    fn find_all(predicate: fn(T): bool): array<T>;\n}\n\n// Alles zusammen verwenden\nfn create_user_repo(): Repository<User> {\n    let users: array<User> = [];\n\n    return {\n        find: fn(id) {\n            for (u in users) {\n                if (u.id == id) { return u; }\n            }\n            return null;\n        },\n        save: fn(const entity) {\n            users.push(entity);\n            return true;\n        },\n        delete: fn(id) {\n            // ...\n            return true;\n        },\n        find_all: fn(predicate) {\n            return users.filter(predicate);\n        }\n    };\n}\n```\n\n### Callbacks mit expliziten Typen\n\n```hemlock\ntype ClickHandler = fn(event: MouseEvent): void;\ntype KeyHandler = fn(event: KeyEvent, modifiers: i32): bool;\n\ndefine Widget {\n    x: i32;\n    y: i32;\n    on_click: ClickHandler?;\n    on_key: KeyHandler?;\n}\n\nfn create_button(label: string, handler: ClickHandler): Widget {\n    return {\n        x: 0, y: 0,\n        on_click: handler,\n        on_key: null\n    };\n}\n```\n\n### Nullbare Funktionstypen\n\n```hemlock\n// Optionaler Callback\nfn fetch(url: string, on_complete: fn(Response): void?): void {\n    let response = http_get(url);\n    if (on_complete != null) {\n        on_complete(response);\n    }\n}\n\n// Nullbarer Rckgabewert vom Funktionstyp\ntype Parser = fn(input: string): AST?;\n\nfn try_parse(parsers: array<Parser>, input: string): AST? {\n    for (p in parsers) {\n        let result = p(input);\n        if (result != null) {\n            return result;\n        }\n    }\n    return null;\n}\n```\n\n---\n\n## Implementierungs-Roadmap\n\n### Phase 1: Kern-Infrastruktur\n1. `TYPE_FUNCTION` zum TypeKind-Enum hinzufgen\n2. Type-Struct mit Funktionstyp-Feldern erweitern\n3. `CHECKED_FUNCTION` zum Compiler-Typprfer hinzufgen\n4. `Self`-Typ-Untersttzung hinzufgen (TYPE_SELF)\n\n### Phase 2: Parsing\n1. `parse_function_type()` im Parser implementieren\n2. `fn(...)` in Typposition behandeln\n3. `type`-Schlsselwort und `STMT_TYPE_ALIAS`-Parsing hinzufgen\n4. `const`-Parameter-Modifikator-Parsing hinzufgen\n5. Define-Parsing fr Methodensignaturen erweitern\n\n### Phase 3: Typprfung\n1. Funktionstyp-Kompatibilittsregeln\n2. Typalias-Auflsung und -Erweiterung\n3. Const-Parameter-Mutationsprfung\n4. Methodensignatur-Validierung in Define-Typen\n5. Self-Typ-Auflsung\n\n### Phase 4: Laufzeit\n1. Funktionstyp-Validierung an Aufrufstellen\n2. Const-Verletzungserkennung\n3. Typalias-Transparenz\n\n### Phase 5: Parittstests\n1. Funktionstyp-Annotationstests\n2. Nullable-Kompositionstests\n3. Typalias-Tests\n4. Const-Parameter-Tests\n5. Methodensignatur-Tests\n\n---\n\n## Designentscheidungen\n\n### 1. Generische Typaliase: **JA**\n\nTypaliase untersttzen generische Parameter:\n\n```hemlock\n// Generische Typaliase\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\ntype Mapper<T, U> = fn(T): U;\ntype AsyncResult<T> = async fn(): T?;\n\n// Verwendung\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\nlet result: Result<User, string> = { value: user, error: null };\nlet transform: Mapper<i32, string> = fn(n) { return n.to_string(); };\n```\n\n### 2. Const-Propagierung: **TIEF**\n\nConst-Parameter sind vollstndig unvernderlich - keine Mutation ber irgendeinen Pfad:\n\n```hemlock\nfn process(const arr: array<object>) {\n    arr.push({});        // FEHLER: kann const-Array nicht mutieren\n    arr[0] = {};         // FEHLER: kann const-Array nicht mutieren\n    arr[0].x = 5;        // FEHLER: kann nicht durch const mutieren (TIEF)\n\n    let x = arr[0].x;    // OK: Lesen ist in Ordnung\n    let copy = arr[0];   // OK: erstellt eine Kopie\n    copy.x = 5;          // OK: Kopie ist nicht const\n}\n\nfn nested(const obj: object) {\n    obj.user.name = \"x\"; // FEHLER: tiefes const verhindert verschachtelte Mutation\n    obj.items[0] = 1;    // FEHLER: tiefes const verhindert verschachtelte Mutation\n}\n```\n\n**Begrndung:** Tiefes const bietet strkere Garantien und ist ntzlicher, um\nDatenintegritt zu gewhrleisten. Wenn Sie verschachtelte Daten mutieren mssen, erstellen Sie zuerst eine Kopie.\n\n### 3. Self in eigenstndigen Typaliasen: **NEIN**\n\n`Self` ist nur innerhalb von `define`-Blcken gltig, wo es eine klare Bedeutung hat:\n\n```hemlock\n// Gltig: Self bezieht sich auf den definierten Typ\ndefine Comparable {\n    fn compare(other: Self): i32;\n}\n\n// Ungltig: Self hat hier keine Bedeutung\ntype Cloner = fn(Self): Self;  // FEHLER: Self auerhalb des Define-Kontexts\n\n// Stattdessen Generics verwenden:\ntype Cloner<T> = fn(T): T;\n```\n\n### 4. Methoden-Standard-Implementierungen: **JA (nur einfache)**\n\nErlauben Sie Standard-Implementierungen fr einfache/Hilfsmethoden:\n\n```hemlock\ndefine Comparable {\n    // Erforderlich: muss implementiert werden\n    fn compare(other: Self): i32;\n\n    // Standard-Implementierungen (einfache Hilfsmethoden)\n    fn equals(other: Self): bool {\n        return self.compare(other) == 0;\n    }\n    fn less_than(other: Self): bool {\n        return self.compare(other) < 0;\n    }\n    fn greater_than(other: Self): bool {\n        return self.compare(other) > 0;\n    }\n}\n\ndefine Printable {\n    fn to_string(): string;\n\n    // Standard: delegiert an erforderliche Methode\n    fn print() {\n        print(self.to_string());\n    }\n    fn println() {\n        print(self.to_string() + \"\\n\");\n    }\n}\n\n// Objekt muss nur erforderliche Methoden implementieren\nlet item: Comparable = {\n    value: 42,\n    compare: fn(other) { return self.value - other.value; }\n    // equals, less_than, greater_than werden von Standards geerbt\n};\n\nitem.less_than({ value: 50, compare: item.compare });  // true\n```\n\n**Richtlinien fr Standards:**\n- Halten Sie sie einfach (1-3 Zeilen)\n- Sollten an erforderliche Methoden delegieren\n- Keine komplexe Logik oder Nebeneffekte\n- Nur Primitiven und einfache Kompositionen\n\n### 5. Varianz: **INFERIERT (keine expliziten Annotationen)**\n\nVarianz wird aus der Verwendung von Typparametern inferiert:\n\n```hemlock\n// Varianz ist automatisch basierend auf Position\ntype Producer<T> = fn(): T;           // T in Rckgabe = kovariant\ntype Consumer<T> = fn(T): void;       // T in Parameter = kontravariant\ntype Transformer<T> = fn(T): T;       // T in beiden = invariant\n\n// Beispiel: Dog <: Animal (Dog ist Subtyp von Animal)\nlet dog_producer: Producer<Dog> = fn() { return new_dog(); };\nlet animal_producer: Producer<Animal> = dog_producer;  // OK: kovariant\n\nlet animal_consumer: Consumer<Animal> = fn(a) { print(a); };\nlet dog_consumer: Consumer<Dog> = animal_consumer;     // OK: kontravariant\n```\n\n**Warum inferieren?**\n- Weniger Boilerplate (`<out T>` / `<in T>` fgt Rauschen hinzu)\n- Folgt \"explizit statt implizit\" - die Position IST explizit\n- Entspricht der Behandlung von Funktionstyp-Varianz in den meisten Sprachen\n- Fehler sind klar, wenn Varianzregeln verletzt werden\n\n---\n\n## Anhang: Grammatik-nderungen\n\n```ebnf\n(* Typen *)\ntype := simple_type | compound_type | function_type\nsimple_type := base_type [\"?\"] | identifier [\"<\" type_args \">\"] [\"?\"]\ncompound_type := simple_type (\"&\" simple_type)+\nfunction_type := [\"async\"] \"fn\" \"(\" [param_types] \")\" [\":\" type]\n\nbase_type := \"i8\" | \"i16\" | \"i32\" | \"i64\"\n           | \"u8\" | \"u16\" | \"u32\" | \"u64\"\n           | \"f32\" | \"f64\" | \"bool\" | \"string\" | \"rune\"\n           | \"ptr\" | \"buffer\" | \"void\" | \"null\"\n           | \"array\" [\"<\" type \">\"]\n           | \"object\"\n           | \"Self\"\n\nparam_types := param_type (\",\" param_type)*\nparam_type := [\"const\"] [identifier \":\"] [\"?\"] type\n            | \"...\" [identifier] [\":\" type]\n\ntype_args := type (\",\" type)*\n\n(* Statements *)\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n\ndefine_stmt := \"define\" identifier [\"<\" type_params \">\"] \"{\" define_members \"}\"\ndefine_members := (field_def | method_def)*\nfield_def := identifier (\":\" type [\"=\" expr] | \"?:\" (type | expr)) \";\"?\nmethod_def := \"fn\" identifier [\"?\"] \"(\" [param_types] \")\" [\":\" type] (block | \";\")\n            (* \"?\" markiert optionale Methode, block liefert Standard-Implementierung *)\n\n(* Parameter *)\nparam := [\"const\"] [\"ref\"] identifier [\":\" type] [\"?:\" expr]\n       | \"...\" identifier [\":\" type]\n```\n"}, "Mitwirken -> Richtlinien": {"id": "contributing-guidelines", "content": "# Beitragen zu Hemlock\n\nVielen Dank fr Ihr Interesse, zu Hemlock beizutragen! Diese Anleitung hilft Ihnen zu verstehen, wie Sie effektiv beitragen knnen, whrend Sie die Designphilosophie und Codequalitt der Sprache beibehalten.\n\n---\n\n## Inhaltsverzeichnis\n\n- [Bevor Sie beginnen](#bevor-sie-beginnen)\n- [Beitrags-Workflow](#beitrags-workflow)\n- [Code-Stilrichtlinien](#code-stilrichtlinien)\n- [Was Sie beitragen knnen](#was-sie-beitragen-knnen)\n- [Was Sie NICHT beitragen sollten](#was-sie-nicht-beitragen-sollten)\n- [Hufige Muster](#hufige-muster)\n- [Neue Funktionen hinzufgen](#neue-funktionen-hinzufgen)\n- [Code-Review-Prozess](#code-review-prozess)\n\n---\n\n## Bevor Sie beginnen\n\n### Erforderliche Lektre\n\nBevor Sie beitragen, lesen Sie bitte diese Dokumente in der angegebenen Reihenfolge:\n\n1. **`/home/user/hemlock/docs/design/philosophy.md`** - Verstehen Sie Hemlocks Kernprinzipien\n2. **`/home/user/hemlock/docs/design/implementation.md`** - Lernen Sie die Codebase-Struktur kennen\n3. **`/home/user/hemlock/docs/contributing/testing.md`** - Verstehen Sie die Testanforderungen\n4. **Dieses Dokument** - Lernen Sie die Beitragsrichtlinien kennen\n\n### Voraussetzungen\n\n**Erforderliches Wissen:**\n- C-Programmierung (Zeiger, Speicherverwaltung, Strukturen)\n- Compiler-/Interpreter-Grundlagen (Lexing, Parsing, AST)\n- Git- und GitHub-Workflow\n- Unix/Linux-Kommandozeile\n\n**Erforderliche Werkzeuge:**\n- GCC- oder Clang-Compiler\n- Make-Build-System\n- Git-Versionskontrolle\n- Valgrind (zur Erkennung von Speicherlecks)\n- Einfacher Texteditor oder IDE\n\n### Kommunikationskanle\n\n**Wo Sie Fragen stellen knnen:**\n- GitHub Issues - Fehlerberichte und Feature-Anfragen\n- GitHub Discussions - Allgemeine Fragen und Design-Diskussionen\n- Pull-Request-Kommentare - Spezifisches Code-Feedback\n\n---\n\n## Beitrags-Workflow\n\n### 1. Ein Issue finden oder erstellen\n\n**Bevor Sie Code schreiben:**\n- Prfen Sie, ob ein Issue fr Ihren Beitrag existiert\n- Falls nicht, erstellen Sie eines, das beschreibt, was Sie tun mchten\n- Warten Sie auf Feedback der Maintainer, bevor Sie groe nderungen beginnen\n- Kleine Fehlerbehebungen knnen diesen Schritt berspringen\n\n**Gute Issue-Beschreibungen enthalten:**\n- Problembeschreibung (was defekt ist oder fehlt)\n- Vorgeschlagene Lsung (wie Sie es beheben mchten)\n- Beispiele (Code-Snippets, die das Problem zeigen)\n- Begrndung (warum diese nderung zu Hemlocks Philosophie passt)\n\n### 2. Fork und Clone\n\n```bash\n# Forken Sie zuerst das Repository auf GitHub, dann:\ngit clone https://github.com/IHR_BENUTZERNAME/hemlock.git\ncd hemlock\ngit checkout -b feature/ihr-feature-name\n```\n\n### 3. Ihre nderungen vornehmen\n\nBefolgen Sie diese Richtlinien:\n- Schreiben Sie zuerst Tests (TDD-Ansatz)\n- Implementieren Sie das Feature\n- Stellen Sie sicher, dass alle Tests bestehen\n- Prfen Sie auf Speicherlecks\n- Aktualisieren Sie die Dokumentation\n\n### 4. Ihre nderungen testen\n\n```bash\n# Fhren Sie die vollstndige Test-Suite aus\nmake test\n\n# Fhren Sie eine bestimmte Testkategorie aus\n./tests/run_tests.sh tests/category/\n\n# Prfen Sie auf Speicherlecks\nvalgrind ./hemlock tests/your_test.hml\n\n# Bauen und testen\nmake clean && make && make test\n```\n\n### 5. Ihre nderungen committen\n\n**Gute Commit-Nachrichten:**\n```\nAdd bitwise operators for integer types\n\n- Implement &, |, ^, <<, >>, ~ operators\n- Add type checking to ensure integer-only operations\n- Update operator precedence table\n- Add comprehensive tests for all operators\n\nCloses #42\n```\n\n**Commit-Nachrichten-Format:**\n- Erste Zeile: Kurze Zusammenfassung (max. 50 Zeichen)\n- Leerzeile\n- Detaillierte Erklrung (Zeilenumbruch bei 72 Zeichen)\n- Issue-Nummern referenzieren\n\n### 6. Einen Pull Request einreichen\n\n**Vor dem Einreichen:**\n- Rebasen Sie auf den neuesten Main-Branch\n- Stellen Sie sicher, dass alle Tests bestehen\n- Fhren Sie Valgrind aus, um auf Lecks zu prfen\n- Aktualisieren Sie CLAUDE.md, wenn Sie benutzersichtbare Features hinzufgen\n\n**Die Pull-Request-Beschreibung sollte enthalten:**\n- Welches Problem dies lst\n- Wie es gelst wird\n- Breaking Changes (falls vorhanden)\n- Beispiele fr neue Syntax oder Verhaltensweisen\n- Testabdeckungs-Zusammenfassung\n\n---\n\n## Code-Stilrichtlinien\n\n### C-Code-Stil\n\n**Formatierung:**\n```c\n// Mit 4 Leerzeichen einrcken (keine Tabs)\n// K&R-Klammerstil fr Funktionen\nvoid function_name(int arg1, char *arg2)\n{\n    if (condition) {\n        // Klammer auf derselben Zeile fr Kontrollstrukturen\n        do_something();\n    }\n}\n\n// Zeilenlnge: maximal 100 Zeichen\n// Leerzeichen um Operatoren verwenden\nint result = (a + b) * c;\n\n// Zeiger-Sternchen beim Typ\nchar *string;   // Gut\nchar* string;   // Vermeiden\nchar * string;  // Vermeiden\n```\n\n**Namenskonventionen:**\n```c\n// Funktionen: kleinbuchstaben_mit_unterstrichen\nvoid eval_expression(ASTNode *node);\n\n// Typen: PascalCase\ntypedef struct Value Value;\ntypedef enum ValueType ValueType;\n\n// Konstanten: GROSSBUCHSTABEN_MIT_UNTERSTRICHEN\n#define MAX_BUFFER_SIZE 4096\n\n// Variablen: kleinbuchstaben_mit_unterstrichen\nint item_count;\nValue *current_value;\n\n// Enums: TYP_PRAEFIX_NAME\ntypedef enum {\n    TYPE_I32,\n    TYPE_STRING,\n    TYPE_OBJECT\n} ValueType;\n```\n\n**Kommentare:**\n```c\n// Einzeilige Kommentare fr kurze Erklrungen\n// Vollstndige Stze mit korrekter Groschreibung verwenden\n\n/*\n * Mehrzeilige Kommentare fr lngere Erklrungen\n * Sternchen fr Lesbarkeit ausrichten\n */\n\n/**\n * Funktionsdokumentations-Kommentar\n * @param node - AST-Knoten zur Auswertung\n * @return Ausgewerteter Wert\n */\nValue eval_expr(ASTNode *node);\n```\n\n**Fehlerbehandlung:**\n```c\n// Alle malloc-Aufrufe prfen\nchar *buffer = malloc(size);\nif (!buffer) {\n    fprintf(stderr, \"Fehler: Speicher erschpft\\n\");\n    exit(1);\n}\n\n// Kontext in Fehlermeldungen bereitstellen\nif (file == NULL) {\n    fprintf(stderr, \"Fehler: Konnte '%s' nicht ffnen: %s\\n\",\n            filename, strerror(errno));\n    exit(1);\n}\n\n// Aussagekrftige Fehlermeldungen verwenden\n// Schlecht: \"Fehler: Ungltiger Wert\"\n// Gut: \"Fehler: Integer erwartet, String erhalten\"\n```\n\n**Speicherverwaltung:**\n```c\n// Immer freigeben, was Sie allokieren\nValue *val = value_create_i32(42);\n// ... val verwenden\nvalue_free(val);\n\n// Zeiger nach dem Freigeben auf NULL setzen (verhindert Double-Free)\nfree(ptr);\nptr = NULL;\n\n// Eigentmerschaft in Kommentaren dokumentieren\n// Diese Funktion bernimmt das Eigentum von 'value' und wird es freigeben\nvoid store_value(Value *value);\n\n// Diese Funktion bernimmt NICHT das Eigentum (Aufrufer muss freigeben)\nValue *get_value(void);\n```\n\n### Code-Organisation\n\n**Dateistruktur:**\n```c\n// 1. Includes (System-Header zuerst, dann lokale)\n#include <stdio.h>\n#include <stdlib.h>\n#include \"internal.h\"\n#include \"values.h\"\n\n// 2. Konstanten und Makros\n#define INITIAL_CAPACITY 16\n\n// 3. Typdefinitionen\ntypedef struct Foo Foo;\n\n// 4. Statische Funktionsdeklarationen (interne Hilfsfunktionen)\nstatic void helper_function(void);\n\n// 5. ffentliche Funktionsimplementierungen\nvoid public_api_function(void)\n{\n    // Implementierung\n}\n\n// 6. Statische Funktionsimplementierungen\nstatic void helper_function(void)\n{\n    // Implementierung\n}\n```\n\n**Header-Dateien:**\n```c\n// Header-Guards verwenden\n#ifndef HEMLOCK_MODULE_H\n#define HEMLOCK_MODULE_H\n\n// Forward-Deklarationen\ntypedef struct Value Value;\n\n// Nur ffentliche API in Headern\nvoid public_function(Value *val);\n\n// Parameter und Rckgabewerte dokumentieren\n/**\n * Wertet einen Ausdrucks-AST-Knoten aus\n * @param node - Der auszuwertende AST-Knoten\n * @param env - Die aktuelle Umgebung\n * @return Der Ergebniswert\n */\nValue *eval_expr(ASTNode *node, Environment *env);\n\n#endif // HEMLOCK_MODULE_H\n```\n\n---\n\n## Was Sie beitragen knnen\n\n### Erwnschte Beitrge\n\n**Fehlerbehebungen:**\n- Speicherlecks\n- Segmentation Faults\n- Fehlerhaftes Verhalten\n- Verbesserungen von Fehlermeldungen\n\n**Dokumentation:**\n- Code-Kommentare\n- API-Dokumentation\n- Benutzerhandbcher und Tutorials\n- Beispielprogramme\n- Testfall-Dokumentation\n\n**Tests:**\n- Zustzliche Testflle fr bestehende Features\n- Abdeckung von Randfllen\n- Regressionstests fr behobene Fehler\n- Performance-Benchmarks\n\n**Kleine Feature-Ergnzungen:**\n- Neue eingebaute Funktionen (wenn sie zur Philosophie passen)\n- String-/Array-Methoden\n- Hilfsfunktionen\n- Verbesserungen der Fehlerbehandlung\n\n**Performance-Verbesserungen:**\n- Schnellere Algorithmen (ohne nderung der Semantik)\n- Reduzierung des Speicherverbrauchs\n- Benchmark-Suite\n- Profiling-Werkzeuge\n\n**Tooling:**\n- Editor-Syntaxhervorhebung\n- Language Server Protocol (LSP)\n- Debugger-Integration\n- Build-System-Verbesserungen\n\n### Erst diskutieren\n\n**Grere Features:**\n- Neue Sprachkonstrukte\n- Typsystem-nderungen\n- Syntax-Ergnzungen\n- Nebenlufigkeits-Primitive\n\n**Wie diskutieren:**\n1. Erffnen Sie ein GitHub-Issue oder eine Diskussion\n2. Beschreiben Sie das Feature und die Begrndung\n3. Zeigen Sie Beispielcode\n4. Erklren Sie, wie es zu Hemlocks Philosophie passt\n5. Warten Sie auf Feedback der Maintainer\n6. Iterieren Sie am Design vor der Implementierung\n\n---\n\n## Was Sie NICHT beitragen sollten\n\n### Unerwnschte Beitrge\n\n**Fgen Sie keine Features hinzu, die:**\n- Komplexitt vor dem Benutzer verstecken\n- Verhalten implizit oder magisch machen\n- Bestehende Semantik oder Syntax brechen\n- Garbage Collection oder automatische Speicherverwaltung hinzufgen\n- Das Prinzip \"explizit vor implizit\" verletzen\n\n**Beispiele fr abgelehnte Beitrge:**\n\n**1. Automatisches Einfgen von Semikolons**\n```hemlock\n// SCHLECHT: Dies wrde abgelehnt werden\nlet x = 5  // Kein Semikolon\nlet y = 10 // Kein Semikolon\n```\nWarum: Macht Syntax mehrdeutig, versteckt Fehler\n\n**2. RAII/Destruktoren**\n```hemlock\n// SCHLECHT: Dies wrde abgelehnt werden\nlet f = open(\"file.txt\");\n// Datei wird automatisch am Ende des Scopes geschlossen\n```\nWarum: Versteckt, wann Ressourcen freigegeben werden, nicht explizit\n\n**3. Implizite Typkonvertierung mit Datenverlust**\n```hemlock\n// SCHLECHT: Dies wrde abgelehnt werden\nlet x: i32 = 3.14;  // Schneidet stillschweigend auf 3 ab\n```\nWarum: Datenverlust sollte explizit sein, nicht stillschweigend\n\n**4. Garbage Collection**\n```c\n// SCHLECHT: Dies wrde abgelehnt werden\nvoid *gc_malloc(size_t size) {\n    // Allokation fr automatische Bereinigung verfolgen\n}\n```\nWarum: Versteckt Speicherverwaltung, unvorhersehbare Performance\n\n**5. Komplexes Makrosystem**\n```hemlock\n// SCHLECHT: Dies wrde abgelehnt werden\nmacro repeat($n, $block) {\n    for (let i = 0; i < $n; i++) $block\n}\n```\nWarum: Zu viel Magie, macht Code schwer nachvollziehbar\n\n### Hufige Ablehnungsgrnde\n\n**\"Das ist zu implizit\"**\n- Lsung: Machen Sie das Verhalten explizit und dokumentieren Sie es\n\n**\"Das versteckt Komplexitt\"**\n- Lsung: Legen Sie die Komplexitt offen, aber machen Sie sie ergonomisch\n\n**\"Das bricht bestehenden Code\"**\n- Lsung: Finden Sie eine nicht-brechende Alternative oder diskutieren Sie Versionierung\n\n**\"Das passt nicht zu Hemlocks Philosophie\"**\n- Lsung: Lesen Sie philosophy.md erneut und berdenken Sie den Ansatz\n\n---\n\n## Hufige Muster\n\n### Fehlerbehandlungsmuster\n\n```c\n// Verwenden Sie dieses Muster fr behebbare Fehler im Hemlock-Code\nValue *divide(Value *a, Value *b)\n{\n    // Vorbedingungen prfen\n    if (b->type != TYPE_I32) {\n        // Fehlerwert zurckgeben oder Exception werfen\n        return create_error(\"Integer-Divisor erwartet\");\n    }\n\n    if (b->i32_value == 0) {\n        return create_error(\"Division durch Null\");\n    }\n\n    // Operation ausfhren\n    return value_create_i32(a->i32_value / b->i32_value);\n}\n```\n\n### Speicherverwaltungsmuster\n\n```c\n// Muster: Allokieren, verwenden, freigeben\nvoid process_data(void)\n{\n    // Allokieren\n    Buffer *buf = create_buffer(1024);\n    char *str = malloc(256);\n\n    // Verwenden\n    if (buf && str) {\n        // ... Arbeit erledigen\n    }\n\n    // Freigeben (in umgekehrter Reihenfolge der Allokation)\n    free(str);\n    free_buffer(buf);\n}\n```\n\n### Wert-Erstellungsmuster\n\n```c\n// Werte mit Konstruktoren erstellen\nValue *create_integer(int32_t n)\n{\n    Value *val = malloc(sizeof(Value));\n    if (!val) {\n        fprintf(stderr, \"Speicher erschpft\\n\");\n        exit(1);\n    }\n\n    val->type = TYPE_I32;\n    val->i32_value = n;\n    return val;\n}\n```\n\n### Typprfungsmuster\n\n```c\n// Typen vor Operationen prfen\nValue *add_values(Value *a, Value *b)\n{\n    // Typprfung\n    if (a->type != TYPE_I32 || b->type != TYPE_I32) {\n        return create_error(\"Typkonflikt\");\n    }\n\n    // Sicher fortzufahren\n    return value_create_i32(a->i32_value + b->i32_value);\n}\n```\n\n### String-Aufbaumuster\n\n```c\n// Strings effizient aufbauen\nvoid build_error_message(char *buffer, size_t size, const char *detail)\n{\n    snprintf(buffer, size, \"Fehler: %s (Zeile %d)\", detail, line_number);\n}\n```\n\n---\n\n## Neue Funktionen hinzufgen\n\n### Checkliste fr Feature-Ergnzungen\n\nBeim Hinzufgen eines neuen Features befolgen Sie diese Schritte:\n\n#### 1. Design-Phase\n\n- [ ] Lesen Sie philosophy.md, um die Ausrichtung sicherzustellen\n- [ ] Erstellen Sie ein GitHub-Issue, das das Feature beschreibt\n- [ ] Holen Sie Maintainer-Genehmigung fr das Design ein\n- [ ] Schreiben Sie eine Spezifikation (Syntax, Semantik, Beispiele)\n- [ ] Bercksichtigen Sie Randflle und Fehlerbedingungen\n\n#### 2. Implementierungsphase\n\n**Wenn Sie ein Sprachkonstrukt hinzufgen:**\n\n- [ ] Fgen Sie Token-Typ zu `lexer.h` hinzu (falls ntig)\n- [ ] Fgen Sie Lexer-Regel in `lexer.c` hinzu (falls ntig)\n- [ ] Fgen Sie AST-Knotentyp in `ast.h` hinzu\n- [ ] Fgen Sie AST-Konstruktor in `ast.c` hinzu\n- [ ] Fgen Sie Parser-Regel in `parser.c` hinzu\n- [ ] Fgen Sie Laufzeitverhalten in `runtime.c` oder dem entsprechenden Modul hinzu\n- [ ] Behandeln Sie Aufrumen in AST-Free-Funktionen\n\n**Wenn Sie eine eingebaute Funktion hinzufgen:**\n\n- [ ] Fgen Sie Funktionsimplementierung in `builtins.c` hinzu\n- [ ] Registrieren Sie die Funktion in `register_builtins()`\n- [ ] Behandeln Sie alle Parameter-Typ-Kombinationen\n- [ ] Geben Sie entsprechende Fehlerwerte zurck\n- [ ] Dokumentieren Sie Parameter und Rckgabetyp\n\n**Wenn Sie einen Werttyp hinzufgen:**\n\n- [ ] Fgen Sie Typ-Enum in `values.h` hinzu\n- [ ] Fgen Sie Feld zur Value-Union hinzu\n- [ ] Fgen Sie Konstruktor in `values.c` hinzu\n- [ ] Fgen Sie zu `value_free()` fr Aufrumen hinzu\n- [ ] Fgen Sie zu `value_copy()` fr Kopieren hinzu\n- [ ] Fgen Sie zu `value_to_string()` fr Ausgabe hinzu\n- [ ] Fgen Sie Typ-Promotion-Regeln hinzu, falls numerisch\n\n#### 3. Testphase\n\n- [ ] Schreiben Sie Testflle (siehe testing.md)\n- [ ] Testen Sie Erfolgsflle\n- [ ] Testen Sie Fehlerflle\n- [ ] Testen Sie Randflle\n- [ ] Fhren Sie die vollstndige Test-Suite aus (`make test`)\n- [ ] Prfen Sie auf Speicherlecks mit Valgrind\n- [ ] Testen Sie auf mehreren Plattformen (wenn mglich)\n\n#### 4. Dokumentationsphase\n\n- [ ] Aktualisieren Sie CLAUDE.md mit benutzersichtbarer Dokumentation\n- [ ] Fgen Sie Code-Kommentare hinzu, die die Implementierung erklren\n- [ ] Erstellen Sie Beispiele in `examples/`\n- [ ] Aktualisieren Sie relevante docs/-Dateien\n- [ ] Dokumentieren Sie alle Breaking Changes\n\n#### 5. Einreichungsphase\n\n- [ ] Bereinigen Sie Debug-Code und Kommentare\n- [ ] berprfen Sie die Einhaltung des Code-Stils\n- [ ] Rebasen Sie auf den neuesten Main-Branch\n- [ ] Erstellen Sie einen Pull Request mit detaillierter Beschreibung\n- [ ] Reagieren Sie auf Code-Review-Feedback\n\n### Beispiel: Einen neuen Operator hinzufgen\n\nLassen Sie uns das Hinzufgen des Modulo-Operators `%` als Beispiel durchgehen:\n\n**1. Lexer (lexer.c):**\n```c\n// Zur Switch-Anweisung in get_next_token() hinzufgen\ncase '%':\n    return create_token(TOKEN_PERCENT, \"%\", line);\n```\n\n**2. Lexer-Header (lexer.h):**\n```c\ntypedef enum {\n    // ... bestehende Token\n    TOKEN_PERCENT,\n    // ...\n} TokenType;\n```\n\n**3. AST (ast.h):**\n```c\ntypedef enum {\n    // ... bestehende Operatoren\n    OP_MOD,\n    // ...\n} BinaryOp;\n```\n\n**4. Parser (parser.c):**\n```c\n// Zu parse_multiplicative() oder entsprechender Przedenzebene hinzufgen\nif (match(TOKEN_PERCENT)) {\n    BinaryOp op = OP_MOD;\n    ASTNode *right = parse_unary();\n    left = create_binary_op_node(op, left, right);\n}\n```\n\n**5. Laufzeit (runtime.c):**\n```c\n// Zu eval_binary_op() hinzufgen\ncase OP_MOD:\n    // Typprfung\n    if (left->type == TYPE_I32 && right->type == TYPE_I32) {\n        if (right->i32_value == 0) {\n            fprintf(stderr, \"Fehler: Modulo durch Null\\n\");\n            exit(1);\n        }\n        return value_create_i32(left->i32_value % right->i32_value);\n    }\n    // ... andere Typkombinationen behandeln\n    break;\n```\n\n**6. Tests (tests/operators/modulo.hml):**\n```hemlock\n// Grundlegendes Modulo\nprint(10 % 3);  // Erwartet: 2\n\n// Negatives Modulo\nprint(-10 % 3); // Erwartet: -1\n\n// Fehlerfall (sollte fehlschlagen)\n// print(10 % 0);  // Division durch Null\n```\n\n**7. Dokumentation (CLAUDE.md):**\n```markdown\n### Arithmetische Operatoren\n- `+` - Addition\n- `-` - Subtraktion\n- `*` - Multiplikation\n- `/` - Division\n- `%` - Modulo (Rest)\n```\n\n---\n\n## Code-Review-Prozess\n\n### Worauf Reviewer achten\n\n**1. Korrektheit**\n- Macht der Code, was er behauptet?\n- Werden Randflle behandelt?\n- Gibt es Speicherlecks?\n- Werden Fehler richtig behandelt?\n\n**2. Philosophie-Ausrichtung**\n- Passt dies zu Hemlocks Designprinzipien?\n- Ist es explizit oder implizit?\n- Versteckt es Komplexitt?\n\n**3. Code-Qualitt**\n- Ist der Code lesbar und wartbar?\n- Sind Variablennamen aussagekrftig?\n- Haben Funktionen eine angemessene Gre?\n- Gibt es ausreichende Dokumentation?\n\n**4. Tests**\n- Gibt es ausreichende Testflle?\n- Decken Tests Erfolgs- und Fehlerpfade ab?\n- Werden Randflle getestet?\n\n**5. Dokumentation**\n- Ist die benutzersichtbare Dokumentation aktualisiert?\n- Sind Code-Kommentare klar?\n- Werden Beispiele bereitgestellt?\n\n### Auf Feedback reagieren\n\n**Tun Sie:**\n- Danken Sie Reviewern fr ihre Zeit\n- Stellen Sie klrende Fragen, wenn Sie etwas nicht verstehen\n- Erklren Sie Ihre Begrndung, wenn Sie anderer Meinung sind\n- Nehmen Sie angeforderte nderungen zeitnah vor\n- Aktualisieren Sie die PR-Beschreibung, wenn sich der Umfang ndert\n\n**Tun Sie nicht:**\n- Kritik persnlich nehmen\n- Defensiv argumentieren\n- Feedback ignorieren\n- Force-Push ber Review-Kommentare (auer beim Rebasen)\n- Nicht zusammenhngende nderungen zum PR hinzufgen\n\n### Ihren PR gemergt bekommen\n\n**Anforderungen fr Merge:**\n- [ ] Alle Tests bestehen\n- [ ] Keine Speicherlecks (Valgrind-sauber)\n- [ ] Code-Review-Genehmigung vom Maintainer\n- [ ] Dokumentation aktualisiert\n- [ ] Befolgt Code-Stilrichtlinien\n- [ ] Passt zu Hemlocks Philosophie\n\n**Zeitrahmen:**\n- Kleine PRs (Fehlerbehebungen): Normalerweise innerhalb weniger Tage geprft\n- Mittlere PRs (neue Features): Kann 1-2 Wochen dauern\n- Groe PRs (grere nderungen): Erfordert ausfhrliche Diskussion\n\n---\n\n## Zustzliche Ressourcen\n\n### Lernressourcen\n\n**Interpreter verstehen:**\n- \"Crafting Interpreters\" von Robert Nystrom\n- \"Writing An Interpreter In Go\" von Thorsten Ball\n- \"Modern Compiler Implementation in C\" von Andrew Appel\n\n**C-Programmierung:**\n- \"The C Programming Language\" von K&R\n- \"Expert C Programming\" von Peter van der Linden\n- \"C Interfaces and Implementations\" von David Hanson\n\n**Speicherverwaltung:**\n- Valgrind-Dokumentation\n- \"Understanding and Using C Pointers\" von Richard Reese\n\n### Ntzliche Befehle\n\n```bash\n# Mit Debug-Symbolen bauen\nmake clean && make CFLAGS=\"-g -O0\"\n\n# Mit Valgrind ausfhren\nvalgrind --leak-check=full ./hemlock script.hml\n\n# Bestimmte Testkategorie ausfhren\n./tests/run_tests.sh tests/strings/\n\n# Tags-Datei fr Code-Navigation generieren\nctags -R .\n\n# Alle TODOs und FIXMEs finden\ngrep -rn \"TODO\\|FIXME\" src/ include/\n```\n\n---\n\n## Fragen?\n\nWenn Sie Fragen zum Beitragen haben:\n\n1. Prfen Sie die Dokumentation in `docs/`\n2. Suchen Sie in bestehenden GitHub-Issues\n3. Fragen Sie in GitHub Discussions\n4. Erffnen Sie ein neues Issue mit Ihrer Frage\n\n**Vielen Dank fr Ihren Beitrag zu Hemlock!**\n"}, "Mitwirken -> Testen": {"id": "contributing-testing", "content": "# Test-Leitfaden fr Hemlock\n\nDieser Leitfaden erklrt Hemlocks Test-Philosophie, wie man Tests schreibt und wie man die Test-Suite ausfhrt.\n\n---\n\n## Inhaltsverzeichnis\n\n- [Test-Philosophie](#test-philosophie)\n- [Test-Suite-Struktur](#test-suite-struktur)\n- [Tests ausfhren](#tests-ausfhren)\n- [Tests schreiben](#tests-schreiben)\n- [Testkategorien](#testkategorien)\n- [Speicherleck-Tests](#speicherleck-tests)\n- [Continuous Integration](#continuous-integration)\n- [Best Practices](#best-practices)\n\n---\n\n## Test-Philosophie\n\n### Kernprinzipien\n\n**1. Testgetriebene Entwicklung (TDD)**\n\nSchreiben Sie Tests **bevor** Sie Features implementieren:\n\n```\n1. Schreiben Sie einen fehlschlagenden Test\n2. Implementieren Sie das Feature\n3. Fhren Sie den Test aus (sollte bestehen)\n4. Refaktorieren Sie bei Bedarf\n5. Wiederholen\n```\n\n**Vorteile:**\n- Stellt sicher, dass Features tatschlich funktionieren\n- Verhindert Regressionen\n- Dokumentiert erwartetes Verhalten\n- Macht Refactoring sicherer\n\n**2. Umfassende Abdeckung**\n\nTesten Sie sowohl Erfolgs- als auch Fehlerflle:\n\n```hemlock\n// Erfolgsfall\nlet x: u8 = 255;  // Sollte funktionieren\n\n// Fehlerfall\nlet y: u8 = 256;  // Sollte einen Fehler werfen\n```\n\n**3. Frh und oft testen**\n\nFhren Sie Tests aus:\n- Vor dem Committen von Code\n- Nach dem Vornehmen von nderungen\n- Vor dem Einreichen von Pull Requests\n- Whrend des Code-Reviews\n\n**Regel:** Alle Tests mssen vor dem Mergen bestehen.\n\n### Was zu testen ist\n\n**Immer testen:**\n- Grundfunktionalitt (Happy Path)\n- Fehlerbedingungen (Sad Path)\n- Randflle (Grenzwertbedingungen)\n- Typprfung und -konvertierungen\n- Speicherverwaltung (keine Lecks)\n- Nebenlufigkeit und Race Conditions\n\n**Beispiel fr Testabdeckung:**\n```hemlock\n// Feature: String.substr(start, length)\n\n// Happy Path\nprint(\"hello\".substr(0, 5));  // \"hello\"\n\n// Randflle\nprint(\"hello\".substr(0, 0));  // \"\" (leer)\nprint(\"hello\".substr(5, 0));  // \"\" (am Ende)\nprint(\"hello\".substr(2, 100)); // \"llo\" (ber Ende hinaus)\n\n// Fehlerflle\n// \"hello\".substr(-1, 5);  // Fehler: negativer Index\n// \"hello\".substr(0, -1);  // Fehler: negative Lnge\n```\n\n---\n\n## Test-Suite-Struktur\n\n### Verzeichnisorganisation\n\n```\ntests/\n run_tests.sh          # Haupt-Testrunner-Skript\n primitives/           # Typsystem-Tests\n    integers.hml\n    floats.hml\n    booleans.hml\n    i64.hml\n    u64.hml\n conversions/          # Typkonvertierungs-Tests\n    int_to_float.hml\n    promotion.hml\n    rune_conversions.hml\n memory/               # Zeiger-/Buffer-Tests\n    alloc.hml\n    buffer.hml\n    memcpy.hml\n strings/              # String-Operationstests\n    concat.hml\n    methods.hml\n    utf8.hml\n    runes.hml\n control/              # Kontrollfluss-Tests\n    if.hml\n    switch.hml\n    while.hml\n functions/            # Funktions- und Closure-Tests\n    basics.hml\n    closures.hml\n    recursion.hml\n objects/              # Objekt-Tests\n    literals.hml\n    methods.hml\n    duck_typing.hml\n    serialization.hml\n arrays/               # Array-Operationstests\n    basics.hml\n    methods.hml\n    slicing.hml\n loops/                # Schleifen-Tests\n    for.hml\n    while.hml\n    break.hml\n    continue.hml\n exceptions/           # Fehlerbehandlungs-Tests\n    try_catch.hml\n    finally.hml\n    throw.hml\n io/                   # Datei-I/O-Tests\n    file_object.hml\n    read_write.hml\n    seek.hml\n async/                # Nebenlufigkeits-Tests\n    spawn_join.hml\n    channels.hml\n    exceptions.hml\n ffi/                  # FFI-Tests\n    basic_call.hml\n    types.hml\n    dlopen.hml\n signals/              # Signal-Behandlungs-Tests\n    basic.hml\n    handlers.hml\n    raise.hml\n args/                 # Kommandozeilen-Argument-Tests\n     basic.hml\n```\n\n### Testdatei-Benennung\n\n**Konventionen:**\n- Verwenden Sie beschreibende Namen: `method_chaining.hml` nicht `test1.hml`\n- Gruppieren Sie verwandte Tests: `string_substr.hml`, `string_slice.hml`\n- Ein Feature-Bereich pro Datei\n- Halten Sie Dateien fokussiert und klein\n\n---\n\n## Tests ausfhren\n\n### Alle Tests ausfhren\n\n```bash\n# Vom Hemlock-Stammverzeichnis\nmake test\n\n# Oder direkt\n./tests/run_tests.sh\n```\n\n**Ausgabe:**\n```\nRunning tests in tests/primitives/...\n   integers.hml\n   floats.hml\n   booleans.hml\n\nRunning tests in tests/strings/...\n   concat.hml\n   methods.hml\n\n...\n\nTotal: 251 tests\nPassed: 251\nFailed: 0\n```\n\n### Bestimmte Kategorie ausfhren\n\n```bash\n# Nur String-Tests ausfhren\n./tests/run_tests.sh tests/strings/\n\n# Nur eine Testdatei ausfhren\n./tests/run_tests.sh tests/strings/concat.hml\n\n# Mehrere Kategorien ausfhren\n./tests/run_tests.sh tests/strings/ tests/arrays/\n```\n\n### Mit Valgrind ausfhren (Speicherleck-Prfung)\n\n```bash\n# Einzelnen Test auf Lecks prfen\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\n\n# Alle Tests prfen (langsam!)\nfor test in tests/**/*.hml; do\n    echo \"Testing $test\"\n    valgrind --leak-check=full --error-exitcode=1 ./hemlock \"$test\"\ndone\n```\n\n### Fehlgeschlagene Tests debuggen\n\n```bash\n# Mit ausfhrlicher Ausgabe ausfhren\n./hemlock tests/failing_test.hml\n\n# Mit gdb ausfhren\ngdb --args ./hemlock tests/failing_test.hml\n(gdb) run\n(gdb) backtrace  # bei Absturz\n```\n\n---\n\n## Tests schreiben\n\n### Testdatei-Format\n\nTestdateien sind einfach Hemlock-Programme mit erwarteter Ausgabe:\n\n**Beispiel: tests/primitives/integers.hml**\n```hemlock\n// Grundlegende Integer-Literale testen\nlet x = 42;\nprint(x);  // Erwartet: 42\n\nlet y: i32 = 100;\nprint(y);  // Erwartet: 100\n\n// Arithmetik testen\nlet sum = x + y;\nprint(sum);  // Erwartet: 142\n\n// Typinferenz testen\nlet small = 10;\nprint(typeof(small));  // Erwartet: i32\n\nlet large = 5000000000;\nprint(typeof(large));  // Erwartet: i64\n```\n\n**Wie Tests funktionieren:**\n1. Der Testrunner fhrt die .hml-Datei aus\n2. Erfasst die stdout-Ausgabe\n3. Vergleicht mit erwarteter Ausgabe (aus Kommentaren oder separater .out-Datei)\n4. Meldet Bestanden/Fehlgeschlagen\n\n### Methoden fr erwartete Ausgabe\n\n**Methode 1: Inline-Kommentare (empfohlen fr einfache Tests)**\n\n```hemlock\nprint(\"hello\");  // Erwartet: hello\nprint(42);       // Erwartet: 42\n```\n\nDer Testrunner parst `// Erwartet: ...`-Kommentare.\n\n**Methode 2: Separate .out-Datei**\n\nErstellen Sie `test_name.hml.out` mit erwarteter Ausgabe:\n\n**test_name.hml:**\n```hemlock\nprint(\"line 1\");\nprint(\"line 2\");\nprint(\"line 3\");\n```\n\n**test_name.hml.out:**\n```\nline 1\nline 2\nline 3\n```\n\n### Fehlerflle testen\n\nFehler-Tests sollten das Programm mit einem Nicht-Null-Status beenden:\n\n**Beispiel: tests/primitives/range_error.hml**\n```hemlock\n// Dies sollte mit einem Typfehler fehlschlagen\nlet x: u8 = 256;  // Auerhalb des Bereichs fr u8\n```\n\n**Erwartetes Verhalten:**\n- Programm beendet sich mit Nicht-Null-Status\n- Gibt Fehlermeldung auf stderr aus\n\n**Testrunner-Behandlung:**\n- Tests, die Fehler erwarten, sollten in separaten Dateien sein\n- Verwenden Sie die Namenskonvention: `*_error.hml` oder `*_fail.hml`\n- Dokumentieren Sie den erwarteten Fehler in Kommentaren\n\n### Erfolgsflle testen\n\n**Beispiel: tests/strings/methods.hml**\n```hemlock\n// substr testen\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);\nprint(sub);  // Erwartet: world\n\n// find testen\nlet pos = s.find(\"world\");\nprint(pos);  // Erwartet: 6\n\n// contains testen\nlet has = s.contains(\"lo\");\nprint(has);  // Erwartet: true\n\n// trim testen\nlet padded = \"  hello  \";\nlet trimmed = padded.trim();\nprint(trimmed);  // Erwartet: hello\n```\n\n### Randflle testen\n\n**Beispiel: tests/arrays/edge_cases.hml**\n```hemlock\n// Leeres Array\nlet empty = [];\nprint(empty.length);  // Erwartet: 0\n\n// Einzelnes Element\nlet single = [42];\nprint(single[0]);  // Erwartet: 42\n\n// Negativer Index (sollte in separater Testdatei fehlschlagen)\n// print(single[-1]);  // Fehler\n\n// Index ber Ende hinaus (sollte fehlschlagen)\n// print(single[100]);  // Fehler\n\n// Grenzwertbedingungen\nlet arr = [1, 2, 3];\nprint(arr.slice(0, 0));  // Erwartet: [] (leer)\nprint(arr.slice(3, 3));  // Erwartet: [] (leer)\nprint(arr.slice(1, 2));  // Erwartet: [2]\n```\n\n### Typsystem testen\n\n**Beispiel: tests/conversions/promotion.hml**\n```hemlock\n// Typ-Promotion bei binren Operationen testen\n\n// i32 + i64 -> i64\nlet a: i32 = 10;\nlet b: i64 = 20;\nlet c = a + b;\nprint(typeof(c));  // Erwartet: i64\n\n// i32 + f32 -> f32\nlet d: i32 = 10;\nlet e: f32 = 3.14;\nlet f = d + e;\nprint(typeof(f));  // Erwartet: f32\n\n// u8 + i32 -> i32\nlet g: u8 = 5;\nlet h: i32 = 10;\nlet i = g + h;\nprint(typeof(i));  // Erwartet: i32\n```\n\n### Nebenlufigkeit testen\n\n**Beispiel: tests/async/basic.hml**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Tasks spawnen\nlet t1 = spawn(compute, 10);\nlet t2 = spawn(compute, 20);\n\n// Joinen und Ergebnisse ausgeben\nlet r1 = join(t1);\nlet r2 = join(t2);\nprint(r1);  // Erwartet: 45\nprint(r2);  // Erwartet: 190\n```\n\n### Exceptions testen\n\n**Beispiel: tests/exceptions/try_catch.hml**\n```hemlock\n// Grundlegendes try/catch testen\ntry {\n    throw \"error message\";\n} catch (e) {\n    print(\"Gefangen: \" + e);  // Erwartet: Gefangen: error message\n}\n\n// finally testen\nlet executed = false;\ntry {\n    print(\"try\");  // Erwartet: try\n} finally {\n    executed = true;\n    print(\"finally\");  // Erwartet: finally\n}\n\n// Exception-Propagierung testen\nfn risky(): i32 {\n    throw \"failure\";\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(e);  // Erwartet: failure\n}\n```\n\n---\n\n## Testkategorien\n\n### Primitiven-Tests\n\n**Was zu testen ist:**\n- Integer-Typen (i8, i16, i32, i64, u8, u16, u32, u64)\n- Float-Typen (f32, f64)\n- Boolean-Typ\n- String-Typ\n- Rune-Typ\n- Null-Typ\n\n**Beispielbereiche:**\n- Literal-Syntax\n- Typinferenz\n- Bereichsprfung\n- berlaufverhalten\n- Typannotationen\n\n### Konvertierungstests\n\n**Was zu testen ist:**\n- Implizite Typ-Promotion\n- Explizite Typkonvertierung\n- Verlustbehaftete Konvertierungen (sollten fehlschlagen)\n- Typ-Promotion bei Operationen\n- Typ-bergreifende Vergleiche\n\n### Speichertests\n\n**Was zu testen ist:**\n- alloc/free-Korrektheit\n- Buffer-Erstellung und -Zugriff\n- Grenzprfung bei Buffern\n- memset, memcpy, realloc\n- Speicherleck-Erkennung (Valgrind)\n\n### String-Tests\n\n**Was zu testen ist:**\n- Konkatenation\n- Alle 18 String-Methoden\n- UTF-8-Behandlung\n- Rune-Indizierung\n- String + Rune-Konkatenation\n- Randflle (leere Strings, einzelnes Zeichen, etc.)\n\n### Kontrollfluss-Tests\n\n**Was zu testen ist:**\n- if/else/else if\n- while-Schleifen\n- for-Schleifen\n- switch-Anweisungen\n- break/continue\n- return-Anweisungen\n\n### Funktions-Tests\n\n**Was zu testen ist:**\n- Funktionsdefinition und -aufruf\n- Parameterbergabe\n- Rckgabewerte\n- Rekursion\n- Closures und Capture\n- First-Class-Funktionen\n- Anonyme Funktionen\n\n### Objekt-Tests\n\n**Was zu testen ist:**\n- Objekt-Literale\n- Feldzugriff und -zuweisung\n- Methoden und self-Bindung\n- Duck Typing\n- Optionale Felder\n- JSON-Serialisierung/Deserialisierung\n- Erkennung zirkulrer Referenzen\n\n### Array-Tests\n\n**Was zu testen ist:**\n- Array-Erstellung\n- Indizierung und Zuweisung\n- Alle 15 Array-Methoden\n- Gemischte Typen\n- Dynamische Grenanpassung\n- Randflle (leer, einzelnes Element)\n\n### Exception-Tests\n\n**Was zu testen ist:**\n- try/catch/finally\n- throw-Anweisung\n- Exception-Propagierung\n- Verschachtelte try/catch\n- Return in try/catch/finally\n- Nicht gefangene Exceptions\n\n### I/O-Tests\n\n**Was zu testen ist:**\n- Datei-ffnungsmodi\n- Lese-/Schreiboperationen\n- Seek/Tell\n- Dateieigenschaften\n- Fehlerbehandlung (fehlende Dateien, etc.)\n- Ressourcen-Aufrumen\n\n### Async-Tests\n\n**Was zu testen ist:**\n- spawn/join/detach\n- Channel send/recv\n- Exception-Propagierung in Tasks\n- Mehrere gleichzeitige Tasks\n- Channel-Blockierungsverhalten\n\n### FFI-Tests\n\n**Was zu testen ist:**\n- dlopen/dlclose\n- dlsym\n- dlcall mit verschiedenen Typen\n- Typkonvertierung\n- Fehlerbehandlung\n\n---\n\n## Speicherleck-Tests\n\n### Valgrind verwenden\n\n**Grundlegende Verwendung:**\n```bash\nvalgrind --leak-check=full ./hemlock test.hml\n```\n\n**Beispielausgabe (keine Lecks):**\n```\n==12345== HEAP SUMMARY:\n==12345==     in use at exit: 0 bytes in 0 blocks\n==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated\n==12345==\n==12345== All heap blocks were freed -- no leaks are possible\n```\n\n**Beispielausgabe (mit Leck):**\n```\n==12345== LEAK SUMMARY:\n==12345==    definitely lost: 64 bytes in 1 blocks\n==12345==    indirectly lost: 0 bytes in 0 blocks\n==12345==      possibly lost: 0 bytes in 0 blocks\n==12345==    still reachable: 0 bytes in 0 blocks\n==12345==         suppressed: 0 bytes in 0 blocks\n```\n\n### Hufige Leck-Quellen\n\n**1. Fehlende free()-Aufrufe:**\n```c\n// SCHLECHT\nchar *str = malloc(100);\n// ... str verwenden\n// Vergessen freizugeben!\n\n// GUT\nchar *str = malloc(100);\n// ... str verwenden\nfree(str);\n```\n\n**2. Verlorene Zeiger:**\n```c\n// SCHLECHT\nchar *ptr = malloc(100);\nptr = malloc(200);  // Referenz zur ersten Allokation verloren!\n\n// GUT\nchar *ptr = malloc(100);\nfree(ptr);\nptr = malloc(200);\n```\n\n**3. Exception-Pfade:**\n```c\n// SCHLECHT\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        return;  // Leck!\n    }\n    free(data);\n}\n\n// GUT\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        free(data);\n        return;\n    }\n    free(data);\n}\n```\n\n### Bekannte akzeptable Lecks\n\nEinige kleine \"Lecks\" sind beabsichtigte Start-Allokationen:\n\n**Globale Built-ins:**\n```hemlock\n// Eingebaute Funktionen, FFI-Typen und Konstanten werden beim Start allokiert\n// und beim Beenden nicht freigegeben (typischerweise ~200 Bytes)\n```\n\nDies sind keine echten Lecks - es sind einmalige Allokationen, die fr die Programmlebensdauer bestehen bleiben und beim Beenden vom Betriebssystem bereinigt werden.\n\n---\n\n## Continuous Integration\n\n### GitHub Actions (Zukunft)\n\nSobald CI eingerichtet ist, werden alle Tests automatisch ausgefhrt bei:\n- Push zum Main-Branch\n- Pull-Request-Erstellung/-Aktualisierung\n- Geplante tgliche Lufe\n\n**CI-Workflow:**\n1. Hemlock bauen\n2. Test-Suite ausfhren\n3. Auf Speicherlecks prfen (Valgrind)\n4. Ergebnisse im PR melden\n\n### Pre-Commit-Prfungen\n\nVor dem Committen ausfhren:\n\n```bash\n# Frisch bauen\nmake clean && make\n\n# Alle Tests ausfhren\nmake test\n\n# Einige Tests auf Lecks prfen\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\nvalgrind --leak-check=full ./hemlock tests/strings/concat.hml\n```\n\n---\n\n## Best Practices\n\n### Dos\n\n**Tests zuerst schreiben (TDD)**\n```bash\n1. tests/feature/new_feature.hml erstellen\n2. Feature in src/ implementieren\n3. Tests ausfhren, bis sie bestehen\n```\n\n**Sowohl Erfolg als auch Fehler testen**\n```hemlock\n// Erfolg: tests/feature/success.hml\nlet result = do_thing();\nprint(result);  // Erwartet: erwarteter Wert\n\n// Fehler: tests/feature/failure.hml\ndo_invalid_thing();  // Sollte fehlschlagen\n```\n\n**Beschreibende Testnamen verwenden**\n```\nGut: tests/strings/substr_utf8_boundary.hml\nSchlecht:  tests/test1.hml\n```\n\n**Tests fokussiert halten**\n- Ein Feature-Bereich pro Datei\n- Klares Setup und Assertions\n- Minimaler Code\n\n**Kommentare hinzufgen, die knifflige Tests erklren**\n```hemlock\n// Testen, dass Closure uere Variable per Referenz erfasst\nfn outer() {\n    let x = 10;\n    let f = fn() { return x; };\n    x = 20;  // Nach Closure-Erstellung modifizieren\n    return f();  // Sollte 20 zurckgeben, nicht 10\n}\n```\n\n**Randflle testen**\n- Leere Eingaben\n- Null-Werte\n- Grenzwerte (min/max)\n- Groe Eingaben\n- Negative Werte\n\n### Don'ts\n\n**Tests nicht berspringen**\n- Alle Tests mssen vor dem Mergen bestehen\n- Kommentieren Sie fehlschlagende Tests nicht aus\n- Beheben Sie den Fehler oder entfernen Sie das Feature\n\n**Keine Tests schreiben, die voneinander abhngen**\n```hemlock\n// SCHLECHT: test2.hml hngt von test1.hml-Ausgabe ab\n// Tests sollten unabhngig sein\n```\n\n**Keine Zufallswerte in Tests verwenden**\n```hemlock\n// SCHLECHT: Nicht-deterministisch\nlet x = random();\nprint(x);  // Ausgabe nicht vorhersagbar\n\n// GUT: Deterministisch\nlet x = 42;\nprint(x);  // Erwartet: 42\n```\n\n**Keine Implementierungsdetails testen**\n```hemlock\n// SCHLECHT: Interne Struktur testen\nlet obj = { x: 10 };\n// Nicht interne Feldreihenfolge, Kapazitt etc. prfen\n\n// GUT: Verhalten testen\nprint(obj.x);  // Erwartet: 10\n```\n\n**Speicherlecks nicht ignorieren**\n- Alle Tests sollten Valgrind-sauber sein\n- Bekannte/akzeptable Lecks dokumentieren\n- Lecks vor dem Mergen beheben\n\n### Test-Wartung\n\n**Wann Tests aktualisieren:**\n- Feature-Verhalten ndert sich\n- Fehlerbehebungen erfordern neue Testflle\n- Randflle entdeckt\n- Performance-Verbesserungen\n\n**Wann Tests entfernen:**\n- Feature aus der Sprache entfernt\n- Test dupliziert bestehende Abdeckung\n- Test war falsch\n\n**Tests refaktorieren:**\n- Verwandte Tests zusammen gruppieren\n- Gemeinsamen Setup-Code extrahieren\n- Einheitliche Benennung verwenden\n- Tests einfach und lesbar halten\n\n---\n\n## Beispiel-Testsitzung\n\nHier ist ein vollstndiges Beispiel fr das Hinzufgen eines Features mit Tests:\n\n### Feature: `array.first()`-Methode hinzufgen\n\n**1. Zuerst den Test schreiben:**\n\n```bash\n# Testdatei erstellen\ncat > tests/arrays/first_method.hml << 'EOF'\n// array.first()-Methode testen\n\n// Grundfall\nlet arr = [1, 2, 3];\nprint(arr.first());  // Erwartet: 1\n\n// Einzelnes Element\nlet single = [42];\nprint(single.first());  // Erwartet: 42\n\n// Leeres Array (sollte fehlschlagen - separate Testdatei)\n// let empty = [];\n// print(empty.first());  // Fehler\nEOF\n```\n\n**2. Den Test ausfhren (sollte fehlschlagen):**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n# Fehler: Methode 'first' nicht auf Array gefunden\n```\n\n**3. Das Feature implementieren:**\n\n`src/interpreter/builtins.c` bearbeiten:\n\n```c\n// array_first-Methode hinzufgen\nValue *array_first(Value *self, Value **args, int arg_count)\n{\n    if (self->array_value->length == 0) {\n        fprintf(stderr, \"Fehler: Kann erstes Element eines leeren Arrays nicht holen\\n\");\n        exit(1);\n    }\n\n    return value_copy(&self->array_value->elements[0]);\n}\n\n// In Array-Methoden-Tabelle registrieren\n// ... zur Array-Methodenregistrierung hinzufgen\n```\n\n**4. Den Test ausfhren (sollte bestehen):**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n1\n42\n# Erfolg!\n```\n\n**5. Auf Speicherlecks prfen:**\n\n```bash\nvalgrind --leak-check=full ./hemlock tests/arrays/first_method.hml\n# All heap blocks were freed -- no leaks are possible\n```\n\n**6. Vollstndige Test-Suite ausfhren:**\n\n```bash\nmake test\n# Total: 252 tests (251 + neuer)\n# Passed: 252\n# Failed: 0\n```\n\n**7. Committen:**\n\n```bash\ngit add tests/arrays/first_method.hml src/interpreter/builtins.c\ngit commit -m \"Add array.first() method with tests\"\n```\n\n---\n\n## Zusammenfassung\n\n**Denken Sie daran:**\n- Tests zuerst schreiben (TDD)\n- Erfolgs- und Fehlerflle testen\n- Alle Tests vor dem Committen ausfhren\n- Auf Speicherlecks prfen\n- Bekannte Probleme dokumentieren\n- Tests einfach und fokussiert halten\n\n**Testqualitt ist genauso wichtig wie Code-Qualitt!**\n"}, "hpm: Erste Schritte -> Installation": {"id": "hpm-installation", "content": "# Installation\n\nDiese Anleitung beschreibt, wie Sie hpm auf Ihrem System installieren.\n\n## Schnellinstallation (Empfohlen)\n\nInstallieren Sie die neueste Version mit einem einzigen Befehl:\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\nDies geschieht automatisch:\n- Erkennung Ihres Betriebssystems (Linux, macOS)\n- Erkennung Ihrer Architektur (x86_64, arm64)\n- Herunterladen der passenden vorkompilierten Binrdatei\n- Installation nach `/usr/local/bin` (oder mit sudo falls erforderlich)\n\n### Installationsoptionen\n\n```bash\n# An einem benutzerdefinierten Ort installieren (kein sudo erforderlich)\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local\n\n# Eine bestimmte Version installieren\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5\n\n# Optionen kombinieren\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5\n```\n\n### Untersttzte Plattformen\n\n| Plattform | Architektur | Status |\n|-----------|-------------|--------|\n| Linux     | x86_64      |  Untersttzt |\n| macOS     | x86_64      |  Untersttzt |\n| macOS     | arm64 (M1/M2/M3) |  Untersttzt |\n| Linux     | arm64       | Aus Quellcode bauen |\n\n## Aus Quellcode bauen\n\nWenn Sie lieber aus dem Quellcode bauen mchten oder eine Plattform bentigen, die nicht durch vorkompilierte Binrdateien abgedeckt ist, folgen Sie diesen Anweisungen.\n\n### Voraussetzungen\n\nhpm erfordert, dass [Hemlock](https://github.com/hemlang/hemlock) zuerst installiert wird. Folgen Sie den Hemlock-Installationsanweisungen, bevor Sie fortfahren.\n\nberprfen Sie, ob Hemlock installiert ist:\n\n```bash\nhemlock --version\n```\n\n## Installationsmethoden\n\n### Methode 1: Make Install\n\nAus dem Quellcode bauen und installieren.\n\n```bash\n# Repository klonen\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Nach /usr/local/bin installieren (erfordert sudo)\nsudo make install\n```\n\nNach der Installation berprfen Sie, ob es funktioniert:\n\n```bash\nhpm --version\n```\n\n### Methode 2: Benutzerdefinierter Speicherort\n\nAn einem benutzerdefinierten Verzeichnis installieren (kein sudo erforderlich):\n\n```bash\n# Repository klonen\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Nach ~/.local/bin installieren\nmake install PREFIX=$HOME/.local\n\n# Oder an einem beliebigen benutzerdefinierten Ort\nmake install PREFIX=/opt/hemlock\n```\n\nStellen Sie sicher, dass Ihr benutzerdefiniertes bin-Verzeichnis in Ihrem PATH ist:\n\n```bash\n# Zu ~/.bashrc oder ~/.zshrc hinzufgen\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n### Methode 3: Ohne Installation ausfhren\n\nSie knnen hpm direkt ohne Installation ausfhren:\n\n```bash\n# Repository klonen\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Lokales Wrapper-Skript erstellen\nmake\n\n# Aus dem hpm-Verzeichnis ausfhren\n./hpm --help\n\n# Oder direkt ber hemlock ausfhren\nhemlock src/main.hml --help\n```\n\n### Methode 4: Manuelle Installation\n\nErstellen Sie Ihr eigenes Wrapper-Skript:\n\n```bash\n# An einen permanenten Ort klonen\ngit clone https://github.com/hemlang/hpm.git ~/.hpm-source\n\n# Wrapper-Skript erstellen\ncat > ~/.local/bin/hpm << 'EOF'\n#!/bin/sh\nexec hemlock \"$HOME/.hpm-source/src/main.hml\" \"$@\"\nEOF\n\nchmod +x ~/.local/bin/hpm\n```\n\n## Installationsvariablen\n\nDas Makefile untersttzt diese Variablen:\n\n| Variable | Standard | Beschreibung |\n|----------|----------|--------------|\n| `PREFIX` | `/usr/local` | Installationsprfix |\n| `BINDIR` | `$(PREFIX)/bin` | Binrverzeichnis |\n| `HEMLOCK` | `hemlock` | Pfad zum Hemlock-Interpreter |\n\nBeispiel mit benutzerdefinierten Variablen:\n\n```bash\nmake install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock\n```\n\n## Funktionsweise\n\nDer Installer erstellt ein Shell-Wrapper-Skript, das den Hemlock-Interpreter mit dem hpm-Quellcode aufruft:\n\n```bash\n#!/bin/sh\nexec hemlock \"/path/to/hpm/src/main.hml\" \"$@\"\n```\n\nDieser Ansatz:\n- Erfordert keine Kompilierung\n- Fhrt immer den neuesten Quellcode aus\n- Funktioniert zuverlssig auf allen Plattformen\n\n## hpm aktualisieren\n\nUm hpm auf die neueste Version zu aktualisieren:\n\n```bash\ncd /path/to/hpm\ngit pull origin main\n\n# Bei Pfadnderung neu installieren\nsudo make install\n```\n\n## Deinstallation\n\nhpm von Ihrem System entfernen:\n\n```bash\ncd /path/to/hpm\nsudo make uninstall\n```\n\nOder manuell entfernen:\n\n```bash\nsudo rm /usr/local/bin/hpm\n```\n\n## Installation berprfen\n\nNach der Installation berprfen Sie, ob alles funktioniert:\n\n```bash\n# Version prfen\nhpm --version\n\n# Hilfe anzeigen\nhpm --help\n\n# Initialisierung testen (in einem leeren Verzeichnis)\nmkdir test-project && cd test-project\nhpm init --yes\ncat package.json\n```\n\n## Fehlerbehebung\n\n### \"hemlock: command not found\"\n\nHemlock ist nicht installiert oder nicht in Ihrem PATH. Installieren Sie zuerst Hemlock:\n\n```bash\n# Prfen, ob hemlock existiert\nwhich hemlock\n\n# Falls nicht gefunden, Hemlock von https://github.com/hemlang/hemlock installieren\n```\n\n### \"Permission denied\"\n\nVerwenden Sie sudo fr die systemweite Installation oder installieren Sie in einem Benutzerverzeichnis:\n\n```bash\n# Option 1: sudo verwenden\nsudo make install\n\n# Option 2: In Benutzerverzeichnis installieren\nmake install PREFIX=$HOME/.local\n```\n\n### \"hpm: command not found\" nach der Installation\n\nIhr PATH enthlt mglicherweise nicht das Installationsverzeichnis:\n\n```bash\n# Prfen, wo hpm installiert wurde\nls -la /usr/local/bin/hpm\n\n# Zum PATH hinzufgen, wenn benutzerdefinierter Speicherort verwendet wird\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## Plattformspezifische Hinweise\n\n### Linux\n\nDie Standardinstallation funktioniert auf allen Linux-Distributionen. Einige Distributionen erfordern mglicherweise:\n\n```bash\n# Debian/Ubuntu: Build-Essentials sicherstellen\nsudo apt-get install build-essential git\n\n# Fedora/RHEL\nsudo dnf install make git\n```\n\n### macOS\n\nDie Standardinstallation funktioniert. Bei Verwendung von Homebrew:\n\n```bash\n# Xcode-Kommandozeilentools sicherstellen\nxcode-select --install\n```\n\n### Windows (WSL)\n\nhpm funktioniert im Windows Subsystem for Linux:\n\n```bash\n# Im WSL-Terminal\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\nmake install PREFIX=$HOME/.local\n```\n\n## Nchste Schritte\n\nNach der Installation:\n\n1. [Schnellstart](#hpm-installation-quick-start) - Erstellen Sie Ihr erstes Projekt\n2. [Befehlsreferenz](#hpm-installation-commands) - Lernen Sie alle Befehle\n3. [Konfiguration](#hpm-installation-configuration) - hpm konfigurieren\n"}, "hpm: Erste Schritte -> Projekteinrichtung": {"id": "hpm-project-setup", "content": "# Projekteinrichtung\n\nVollstndige Anleitung zur Einrichtung von Hemlock-Projekten mit hpm.\n\n## Ein neues Projekt starten\n\n### Grundlegende Einrichtung\n\nEin neues Projekt von Grund auf erstellen:\n\n```bash\n# Projektverzeichnis erstellen\nmkdir my-project\ncd my-project\n\n# package.json initialisieren\nhpm init\n\n# Verzeichnisstruktur erstellen\nmkdir -p src test\n```\n\n### Projektvorlagen\n\nHier sind gngige Projektstrukturen fr verschiedene Anwendungsflle:\n\n#### Bibliothekspaket\n\nFr wiederverwendbare Bibliotheken:\n\n```\nmy-library/\n package.json\n README.md\n LICENSE\n src/\n    index.hml          # Haupteinstiegspunkt, exportiert ffentliche API\n    core.hml           # Kernfunktionalitt\n    utils.hml          # Hilfsfunktionen\n    types.hml          # Typdefinitionen\n test/\n     framework.hml      # Test-Framework\n     run.hml            # Test-Runner\n     test_core.hml      # Tests\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-library\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Eine wiederverwendbare Hemlock-Bibliothek\",\n  \"main\": \"src/index.hml\",\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {}\n}\n```\n\n#### Anwendung\n\nFr eigenstndige Anwendungen:\n\n```\nmy-app/\n package.json\n README.md\n src/\n    main.hml           # Anwendungseinstiegspunkt\n    config.hml         # Konfiguration\n    commands/          # CLI-Befehle\n       index.hml\n       run.hml\n    lib/               # Interne Bibliotheken\n        utils.hml\n test/\n    run.hml\n data/                  # Datendateien\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Eine Hemlock-Anwendung\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {}\n}\n```\n\n#### Webanwendung\n\nFr Webserver:\n\n```\nmy-web-app/\n package.json\n README.md\n src/\n    main.hml           # Server-Einstiegspunkt\n    routes/            # Route-Handler\n       index.hml\n       api.hml\n       auth.hml\n    middleware/        # Middleware\n       index.hml\n       auth.hml\n    models/            # Datenmodelle\n       user.hml\n    services/          # Geschftslogik\n        user.hml\n test/\n    run.hml\n static/                # Statische Dateien\n    css/\n    js/\n views/                 # Templates\n     index.hml\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-web-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Eine Hemlock-Webanwendung\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\",\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  }\n}\n```\n\n## Die package.json-Datei\n\n### Erforderliche Felder\n\n```json\n{\n  \"name\": \"owner/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n### Alle Felder\n\n```json\n{\n  \"name\": \"yourusername/my-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Paketbeschreibung\",\n  \"author\": \"Ihr Name <sie@beispiel.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/yourusername/my-package\",\n  \"homepage\": \"https://yourusername.github.io/my-package\",\n  \"bugs\": \"https://github.com/yourusername/my-package/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"utility\", \"parser\"],\n  \"dependencies\": {\n    \"owner/package\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"owner/test-lib\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n### Feldreferenz\n\n| Feld | Typ | Beschreibung |\n|------|-----|--------------|\n| `name` | string | Paketname im owner/repo-Format (erforderlich) |\n| `version` | string | Semantische Version (erforderlich) |\n| `description` | string | Kurze Beschreibung |\n| `author` | string | Autorname und E-Mail |\n| `license` | string | Lizenz-Identifikator (MIT, Apache-2.0, etc.) |\n| `repository` | string | Repository-URL |\n| `homepage` | string | Projekt-Homepage |\n| `bugs` | string | Issue-Tracker-URL |\n| `main` | string | Einstiegspunktdatei (Standard: src/index.hml) |\n| `keywords` | array | Such-Schlsselwrter |\n| `dependencies` | object | Laufzeitabhngigkeiten |\n| `devDependencies` | object | Entwicklungsabhngigkeiten |\n| `scripts` | object | Benannte Skripte |\n| `files` | array | Dateien, die beim Verffentlichen enthalten sein sollen |\n| `native` | object | Native Bibliotheksanforderungen |\n\n## Die package-lock.json-Datei\n\nDie Lock-Datei wird automatisch generiert und sollte zur Versionskontrolle committet werden. Sie gewhrleistet reproduzierbare Installationen.\n\n```json\n{\n  \"lockVersion\": 1,\n  \"hemlock\": \"1.0.0\",\n  \"dependencies\": {\n    \"hemlang/sprout\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz\",\n      \"integrity\": \"sha256-abc123...\",\n      \"dependencies\": {\n        \"hemlang/router\": \"^1.5.0\"\n      }\n    },\n    \"hemlang/router\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://github.com/hemlang/router/archive/v1.5.0.tar.gz\",\n      \"integrity\": \"sha256-def456...\",\n      \"dependencies\": {}\n    }\n  }\n}\n```\n\n### Best Practices fr Lock-Dateien\n\n- **Committen** Sie package-lock.json zur Versionskontrolle\n- **Nicht manuell bearbeiten** - sie wird automatisch generiert\n- **`hpm install` ausfhren** nach dem Pullen von nderungen\n- **Lschen und neu generieren** falls beschdigt:\n  ```bash\n  rm package-lock.json\n  hpm install\n  ```\n\n## Das hem_modules-Verzeichnis\n\nInstallierte Pakete werden in `hem_modules/` gespeichert:\n\n```\nhem_modules/\n hemlang/\n    sprout/\n       package.json\n       src/\n    router/\n        package.json\n        src/\n alice/\n     http-client/\n         package.json\n         src/\n```\n\n### Best Practices fr hem_modules\n\n- **Zu .gitignore hinzufgen** - Abhngigkeiten nicht committen\n- **Nicht modifizieren** - nderungen werden berschrieben\n- **Lschen zum Neu-Installieren**:\n  ```bash\n  rm -rf hem_modules\n  hpm install\n  ```\n\n## .gitignore\n\nEmpfohlene .gitignore fr Hemlock-Projekte:\n\n```gitignore\n# Abhngigkeiten\nhem_modules/\n\n# Build-Ausgabe\ndist/\n*.hmlc\n\n# IDE-Dateien\n.idea/\n.vscode/\n*.swp\n*.swo\n\n# OS-Dateien\n.DS_Store\nThumbs.db\n\n# Logs\n*.log\nlogs/\n\n# Umgebung\n.env\n.env.local\n\n# Testabdeckung\ncoverage/\n```\n\n## Mit Abhngigkeiten arbeiten\n\n### Abhngigkeiten hinzufgen\n\n```bash\n# Laufzeitabhngigkeit hinzufgen\nhpm install hemlang/json\n\n# Mit Versionseinschrnkung hinzufgen\nhpm install hemlang/sprout@^2.0.0\n\n# Entwicklungsabhngigkeit hinzufgen\nhpm install hemlang/test-utils --dev\n```\n\n### Abhngigkeiten importieren\n\n```hemlock\n// Aus Paket importieren (verwendet \"main\"-Eintrag)\nimport { parse, stringify } from \"hemlang/json\";\n\n// Aus Unterpfad importieren\nimport { Router } from \"hemlang/sprout/router\";\n\n// Standardbibliothek importieren\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile, writeFile } from \"@stdlib/fs\";\n```\n\n### Import-Auflsung\n\nhpm lst Importe in dieser Reihenfolge auf:\n\n1. **Standardbibliothek**: `@stdlib/*` importiert eingebaute Module\n2. **Paket-Root**: `owner/repo` verwendet das `main`-Feld\n3. **Unterpfad**: `owner/repo/path` prft:\n   - `hem_modules/owner/repo/path.hml`\n   - `hem_modules/owner/repo/path/index.hml`\n   - `hem_modules/owner/repo/src/path.hml`\n   - `hem_modules/owner/repo/src/path/index.hml`\n\n## Skripte\n\n### Skripte definieren\n\nSkripte zur package.json hinzufgen:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n### Skripte ausfhren\n\n```bash\nhpm run start\nhpm run dev\nhpm run build\n\n# Kurzform fr test\nhpm test\n\n# Argumente bergeben\nhpm run test -- --verbose --filter=unit\n```\n\n### Skript-Namenskonventionen\n\n| Skript | Zweck |\n|--------|-------|\n| `start` | Anwendung ausfhren |\n| `dev` | Im Entwicklungsmodus ausfhren |\n| `test` | Alle Tests ausfhren |\n| `build` | Fr Produktion bauen |\n| `clean` | Generierte Dateien entfernen |\n| `lint` | Code-Stil prfen |\n| `format` | Code formatieren |\n\n## Entwicklungsworkflow\n\n### Ersteinrichtung\n\n```bash\n# Projekt klonen\ngit clone https://github.com/yourusername/my-project.git\ncd my-project\n\n# Abhngigkeiten installieren\nhpm install\n\n# Tests ausfhren\nhpm test\n\n# Entwicklung starten\nhpm run dev\n```\n\n### Tglicher Workflow\n\n```bash\n# Neueste nderungen pullen\ngit pull\n\n# Neue Abhngigkeiten installieren\nhpm install\n\n# nderungen vornehmen...\n\n# Tests ausfhren\nhpm test\n\n# Committen\ngit add .\ngit commit -m \"Feature hinzugefgt\"\ngit push\n```\n\n### Neues Feature hinzufgen\n\n```bash\n# Feature-Branch erstellen\ngit checkout -b feature/new-feature\n\n# Bei Bedarf neue Abhngigkeit hinzufgen\nhpm install hemlang/new-lib\n\n# Feature implementieren...\n\n# Testen\nhpm test\n\n# Committen und pushen\ngit add .\ngit commit -m \"Neues Feature hinzugefgt\"\ngit push -u origin feature/new-feature\n```\n\n## Umgebungsspezifische Konfiguration\n\n### Umgebungsvariablen verwenden\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nlet db_host = getenv(\"DATABASE_HOST\") ?? \"localhost\";\nlet api_key = getenv(\"API_KEY\") ?? \"\";\n\nif api_key == \"\" {\n    print(\"Warnung: API_KEY nicht gesetzt\");\n}\n```\n\n### Konfigurationsdatei\n\n**config.hml:**\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nexport let config = {\n    environment: getenv(\"HEMLOCK_ENV\") ?? \"development\",\n    database: {\n        host: getenv(\"DB_HOST\") ?? \"localhost\",\n        port: int(getenv(\"DB_PORT\") ?? \"5432\"),\n        name: getenv(\"DB_NAME\") ?? \"myapp\"\n    },\n    server: {\n        port: int(getenv(\"PORT\") ?? \"3000\"),\n        host: getenv(\"HOST\") ?? \"0.0.0.0\"\n    }\n};\n\nexport fn is_production(): bool {\n    return config.environment == \"production\";\n}\n```\n\n## Siehe auch\n\n- [Schnellstart](#hpm-project-setup-quick-start) - Schnell loslegen\n- [Befehle](#hpm-project-setup-commands) - Befehlsreferenz\n- [Pakete erstellen](#hpm-project-setup-creating-packages) - Pakete verffentlichen\n- [Konfiguration](#hpm-project-setup-configuration) - hpm-Konfiguration\n"}, "hpm: Erste Schritte -> Schnellstart": {"id": "hpm-quick-start", "content": "# Schnellstart\n\nStarten Sie mit hpm in 5 Minuten.\n\n## hpm installieren\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\nFr weitere Installationsoptionen siehe die [Installationsanleitung](#hpm-quick-start-installation).\n\n## Ein neues Projekt erstellen\n\nBeginnen Sie mit dem Erstellen eines neuen Verzeichnisses und der Initialisierung eines Pakets:\n\n```bash\nmkdir my-project\ncd my-project\nhpm init\n```\n\nSie werden nach Projektdetails gefragt:\n\n```\nPackage name (owner/repo): myname/my-project\nVersion (1.0.0):\nDescription: Mein tolles Hemlock-Projekt\nAuthor: Ihr Name <sie@beispiel.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\nVerwenden Sie `--yes`, um alle Standardwerte zu akzeptieren:\n\n```bash\nhpm init --yes\n```\n\n## Projektstruktur\n\nErstellen Sie die grundlegende Projektstruktur:\n\n```\nmy-project/\n package.json        # Projektmanifest\n src/\n    index.hml      # Haupteinstiegspunkt\n test/\n     test.hml       # Tests\n```\n\nErstellen Sie Ihre Hauptdatei:\n\n```bash\nmkdir -p src test\n```\n\n**src/index.hml:**\n```hemlock\n// Haupteinstiegspunkt\nexport fn greet(name: string): string {\n    return \"Hallo, \" + name + \"!\";\n}\n\nexport fn main() {\n    print(greet(\"Welt\"));\n}\n```\n\n## Abhngigkeiten installieren\n\nSuchen Sie nach Paketen auf GitHub (Pakete verwenden das `owner/repo`-Format):\n\n```bash\n# Ein Paket installieren\nhpm install hemlang/sprout\n\n# Mit Versionseinschrnkung installieren\nhpm install hemlang/json@^1.0.0\n\n# Als Entwicklungsabhngigkeit installieren\nhpm install hemlang/test-utils --dev\n```\n\nNach der Installation enthlt Ihre Projektstruktur `hem_modules/`:\n\n```\nmy-project/\n package.json\n package-lock.json   # Lock-Datei (automatisch generiert)\n hem_modules/        # Installierte Pakete\n    hemlang/\n        sprout/\n src/\n    index.hml\n test/\n     test.hml\n```\n\n## Installierte Pakete verwenden\n\nImportieren Sie Pakete mit ihrem GitHub-Pfad:\n\n```hemlock\n// Aus installiertem Paket importieren\nimport { app, router } from \"hemlang/sprout\";\nimport { parse, stringify } from \"hemlang/json\";\n\n// Aus Unterpfad importieren\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// Standardbibliothek (eingebaut)\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile } from \"@stdlib/fs\";\n```\n\n## Skripte hinzufgen\n\nFgen Sie Skripte zu Ihrer `package.json` hinzu:\n\n```json\n{\n  \"name\": \"myname/my-project\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/test.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\nFhren Sie Skripte mit `hpm run` aus:\n\n```bash\nhpm run start\nhpm run build\n\n# Kurzform fr test\nhpm test\n```\n\n## Hufige Arbeitsablufe\n\n### Alle Abhngigkeiten installieren\n\nWenn Sie ein Projekt mit einer `package.json` klonen:\n\n```bash\ngit clone https://github.com/someone/project.git\ncd project\nhpm install\n```\n\n### Abhngigkeiten aktualisieren\n\nAlle Pakete auf die neuesten Versionen innerhalb der Einschrnkungen aktualisieren:\n\n```bash\nhpm update\n```\n\nEin bestimmtes Paket aktualisieren:\n\n```bash\nhpm update hemlang/sprout\n```\n\n### Installierte Pakete anzeigen\n\nAlle installierten Pakete auflisten:\n\n```bash\nhpm list\n```\n\nDie Ausgabe zeigt den Abhngigkeitsbaum:\n\n```\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n    hemlang/router@1.5.0\n hemlang/json@1.2.3\n```\n\n### Nach Updates suchen\n\nSehen Sie, welche Pakete neuere Versionen haben:\n\n```bash\nhpm outdated\n```\n\n### Ein Paket entfernen\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n## Beispiel: Webanwendung\n\nHier ist ein vollstndiges Beispiel mit einem Web-Framework:\n\n**package.json:**\n```json\n{\n  \"name\": \"myname/my-web-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Eine Webanwendung\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"dev\": \"hemlock --watch src/index.hml\"\n  }\n}\n```\n\n**src/index.hml:**\n```hemlock\nimport { App, Router } from \"hemlang/sprout\";\n\nfn main() {\n    let app = App.new();\n    let router = Router.new();\n\n    router.get(\"/\", fn(req, res) {\n        res.send(\"Hallo, Welt!\");\n    });\n\n    router.get(\"/api/status\", fn(req, res) {\n        res.json({ status: \"ok\" });\n    });\n\n    app.use(router);\n    app.listen(3000);\n\n    print(\"Server luft auf http://localhost:3000\");\n}\n```\n\nFhren Sie die Anwendung aus:\n\n```bash\nhpm install\nhpm run start\n```\n\n## Nchste Schritte\n\n- [Befehlsreferenz](#hpm-quick-start-commands) - Lernen Sie alle hpm-Befehle\n- [Pakete erstellen](#hpm-quick-start-creating-packages) - Verffentlichen Sie Ihre eigenen Pakete\n- [Konfiguration](#hpm-quick-start-configuration) - hpm und GitHub-Tokens konfigurieren\n- [Projekteinrichtung](#hpm-quick-start-project-setup) - Detaillierte Projektkonfiguration\n"}, "hpm: Benutzerhandbuch -> Befehle": {"id": "hpm-commands", "content": "# Befehlsreferenz\n\nVollstndige Referenz fr alle hpm-Befehle.\n\n## Globale Optionen\n\nDiese Optionen funktionieren mit jedem Befehl:\n\n| Option | Beschreibung |\n|--------|--------------|\n| `--help`, `-h` | Hilfemeldung anzeigen |\n| `--version`, `-v` | hpm-Version anzeigen |\n| `--verbose` | Detaillierte Ausgabe anzeigen |\n\n## Befehle\n\n### hpm init\n\nErstellt eine neue `package.json`-Datei.\n\n```bash\nhpm init        # Interaktiver Modus\nhpm init --yes  # Alle Standardwerte akzeptieren\nhpm init -y     # Kurzform\n```\n\n**Optionen:**\n\n| Option | Beschreibung |\n|--------|--------------|\n| `--yes`, `-y` | Standardwerte fr alle Eingabeaufforderungen akzeptieren |\n\n**Interaktive Eingabeaufforderungen:**\n- Paketname (owner/repo-Format)\n- Version (Standard: 1.0.0)\n- Beschreibung\n- Autor\n- Lizenz (Standard: MIT)\n- Hauptdatei (Standard: src/index.hml)\n\n**Beispiel:**\n\n```bash\n$ hpm init\nPackage name (owner/repo): alice/my-lib\nVersion (1.0.0):\nDescription: Eine Hilfsbibliothek\nAuthor: Alice <alice@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n---\n\n### hpm install\n\nAbhngigkeiten installieren oder neue Pakete hinzufgen.\n\n```bash\nhpm install                           # Alle aus package.json installieren\nhpm install owner/repo                # Paket hinzufgen und installieren\nhpm install owner/repo@^1.0.0        # Mit Versionseinschrnkung\nhpm install owner/repo --dev         # Als Entwicklungsabhngigkeit\nhpm i owner/repo                      # Kurzform\n```\n\n**Optionen:**\n\n| Option | Beschreibung |\n|--------|--------------|\n| `--dev`, `-D` | Zu devDependencies hinzufgen |\n| `--verbose` | Detaillierten Fortschritt anzeigen |\n| `--dry-run` | Vorschau ohne Installation |\n| `--offline` | Nur aus dem Cache installieren (kein Netzwerk) |\n| `--parallel` | Parallele Downloads aktivieren (experimentell) |\n\n**Syntax fr Versionseinschrnkungen:**\n\n| Syntax | Beispiel | Bedeutung |\n|--------|----------|-----------|\n| (keine) | `owner/repo` | Neueste Version |\n| Exakt | `owner/repo@1.2.3` | Genau 1.2.3 |\n| Caret | `owner/repo@^1.2.3` | >=1.2.3 <2.0.0 |\n| Tilde | `owner/repo@~1.2.3` | >=1.2.3 <1.3.0 |\n| Bereich | `owner/repo@>=1.0.0` | Mindestens 1.0.0 |\n\n**Beispiele:**\n\n```bash\n# Alle Abhngigkeiten installieren\nhpm install\n\n# Bestimmtes Paket installieren\nhpm install hemlang/json\n\n# Mit Versionseinschrnkung installieren\nhpm install hemlang/sprout@^2.0.0\n\n# Als Entwicklungsabhngigkeit installieren\nhpm install hemlang/test-utils --dev\n\n# Vorschau, was installiert werden wrde\nhpm install hemlang/sprout --dry-run\n\n# Ausfhrliche Ausgabe\nhpm install --verbose\n\n# Nur aus dem Cache installieren (offline)\nhpm install --offline\n```\n\n**Ausgabe:**\n\n```\nInstalling dependencies...\n  + hemlang/sprout@2.1.0\n  + hemlang/router@1.5.0 (Abhngigkeit von hemlang/sprout)\n\nInstalled 2 packages in 1.2s\n```\n\n---\n\n### hpm uninstall\n\nEin Paket entfernen.\n\n```bash\nhpm uninstall owner/repo\nhpm rm owner/repo          # Kurzform\nhpm remove owner/repo      # Alternative\n```\n\n**Beispiele:**\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n**Ausgabe:**\n\n```\nRemoved hemlang/sprout@2.1.0\nUpdated package.json\nUpdated package-lock.json\n```\n\n---\n\n### hpm update\n\nPakete auf die neuesten Versionen innerhalb der Einschrnkungen aktualisieren.\n\n```bash\nhpm update              # Alle Pakete aktualisieren\nhpm update owner/repo   # Bestimmtes Paket aktualisieren\nhpm up owner/repo       # Kurzform\n```\n\n**Optionen:**\n\n| Option | Beschreibung |\n|--------|--------------|\n| `--verbose` | Detaillierten Fortschritt anzeigen |\n| `--dry-run` | Vorschau ohne Aktualisierung |\n\n**Beispiele:**\n\n```bash\n# Alle Pakete aktualisieren\nhpm update\n\n# Bestimmtes Paket aktualisieren\nhpm update hemlang/sprout\n\n# Aktualisierungen vorab anzeigen\nhpm update --dry-run\n```\n\n**Ausgabe:**\n\n```\nUpdating dependencies...\n  hemlang/sprout: 2.0.0  2.1.0\n  hemlang/router: 1.4.0  1.5.0\n\nUpdated 2 packages\n```\n\n---\n\n### hpm list\n\nInstallierte Pakete anzeigen.\n\n```bash\nhpm list              # Vollstndigen Abhngigkeitsbaum anzeigen\nhpm list --depth=0    # Nur direkte Abhngigkeiten\nhpm list --depth=1    # Eine Ebene transitiver Abhngigkeiten\nhpm ls                # Kurzform\n```\n\n**Optionen:**\n\n| Option | Beschreibung |\n|--------|--------------|\n| `--depth=N` | Baumtiefe begrenzen (Standard: alle) |\n\n**Beispiele:**\n\n```bash\n$ hpm list\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n    hemlang/router@1.5.0\n    hemlang/middleware@1.2.0\n hemlang/json@1.2.3\n hemlang/test-utils@1.0.0 (dev)\n\n$ hpm list --depth=0\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n hemlang/json@1.2.3\n hemlang/test-utils@1.0.0 (dev)\n```\n\n---\n\n### hpm outdated\n\nPakete mit neueren verfgbaren Versionen anzeigen.\n\n```bash\nhpm outdated\n```\n\n**Ausgabe:**\n\n```\nPackage            Current  Wanted  Latest\nhemlang/sprout     2.0.0    2.0.5   2.1.0\nhemlang/router     1.4.0    1.4.2   1.5.0\n```\n\n- **Current**: Installierte Version\n- **Wanted**: Hchste Version, die der Einschrnkung entspricht\n- **Latest**: Neueste verfgbare Version\n\n---\n\n### hpm run\n\nEin Skript aus package.json ausfhren.\n\n```bash\nhpm run <script>\nhpm run <script> -- <args>\n```\n\n**Beispiele:**\n\nBei dieser package.json:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\nSkripte ausfhren:\n\n```bash\nhpm run start\nhpm run test\nhpm run build\n\n# Argumente an das Skript bergeben\nhpm run test -- --verbose\n```\n\n---\n\n### hpm test\n\nKurzform fr `hpm run test`.\n\n```bash\nhpm test\nhpm test -- --verbose\n```\n\nEntspricht:\n\n```bash\nhpm run test\n```\n\n---\n\n### hpm why\n\nErklren, warum ein Paket installiert ist (Abhngigkeitskette anzeigen).\n\n```bash\nhpm why owner/repo\n```\n\n**Beispiel:**\n\n```bash\n$ hpm why hemlang/router\n\nhemlang/router@1.5.0 ist installiert, weil:\n\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n     hemlang/router@1.5.0\n```\n\n---\n\n### hpm cache\n\nDen globalen Paket-Cache verwalten.\n\n```bash\nhpm cache list    # Gecachte Pakete auflisten\nhpm cache clean   # Alle gecachten Pakete lschen\n```\n\n**Unterbefehle:**\n\n| Unterbefehl | Beschreibung |\n|-------------|--------------|\n| `list` | Alle gecachten Pakete und Gren anzeigen |\n| `clean` | Alle gecachten Pakete entfernen |\n\n**Beispiele:**\n\n```bash\n$ hpm cache list\nCached packages in ~/.hpm/cache:\n\nhemlang/sprout\n  2.0.0 (1.2 MB)\n  2.1.0 (1.3 MB)\nhemlang/router\n  1.5.0 (450 KB)\n\nTotal: 2.95 MB\n\n$ hpm cache clean\nCleared cache (2.95 MB freed)\n```\n\n---\n\n## Befehlskrzel\n\nDer Einfachheit halber haben mehrere Befehle kurze Aliase:\n\n| Befehl | Krzel |\n|--------|--------|\n| `install` | `i` |\n| `uninstall` | `rm`, `remove` |\n| `list` | `ls` |\n| `update` | `up` |\n\n**Beispiele:**\n\n```bash\nhpm i hemlang/sprout        # hpm install hemlang/sprout\nhpm rm hemlang/sprout       # hpm uninstall hemlang/sprout\nhpm ls                      # hpm list\nhpm up                      # hpm update\n```\n\n---\n\n## Exit-Codes\n\nhpm verwendet spezifische Exit-Codes, um verschiedene Fehlerbedingungen anzuzeigen:\n\n| Code | Bedeutung |\n|------|-----------|\n| 0 | Erfolg |\n| 1 | Abhngigkeitskonflikt |\n| 2 | Paket nicht gefunden |\n| 3 | Version nicht gefunden |\n| 4 | Netzwerkfehler |\n| 5 | Ungltige package.json |\n| 6 | Integrittsprfung fehlgeschlagen |\n| 7 | GitHub-Rate-Limit berschritten |\n| 8 | Zirkulre Abhngigkeit |\n\nExit-Codes in Skripten verwenden:\n\n```bash\nhpm install\nif [ $? -ne 0 ]; then\n    echo \"Installation fehlgeschlagen\"\n    exit 1\nfi\n```\n\n---\n\n## Umgebungsvariablen\n\nhpm bercksichtigt diese Umgebungsvariablen:\n\n| Variable | Beschreibung |\n|----------|--------------|\n| `GITHUB_TOKEN` | GitHub-API-Token fr Authentifizierung |\n| `HPM_CACHE_DIR` | Cache-Verzeichnis berschreiben |\n| `HOME` | Benutzer-Home-Verzeichnis (fr Konfiguration/Cache) |\n\n**Beispiele:**\n\n```bash\n# GitHub-Token fr hhere Rate-Limits verwenden\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Benutzerdefiniertes Cache-Verzeichnis verwenden\nexport HPM_CACHE_DIR=/tmp/hpm-cache\nhpm install\n```\n\n---\n\n## Siehe auch\n\n- [Konfiguration](#hpm-commands-configuration) - Konfigurationsdateien\n- [Paketspezifikation](#hpm-commands-package-spec) - package.json-Format\n- [Fehlerbehebung](#hpm-commands-troubleshooting) - Hufige Probleme\n"}, "hpm: Benutzerhandbuch -> Fehlerbehebung": {"id": "hpm-troubleshooting", "content": "# Fehlerbehebung\n\nLsungen fr hufige hpm-Probleme.\n\n## Installationsprobleme\n\n### \"hemlock: command not found\"\n\n**Ursache:** Hemlock ist nicht installiert oder nicht im PATH.\n\n**Lsung:**\n\n```bash\n# Prfen, ob hemlock existiert\nwhich hemlock\n\n# Falls nicht gefunden, zuerst Hemlock installieren\n# Besuchen Sie: https://github.com/hemlang/hemlock\n\n# Nach der Installation berprfen\nhemlock --version\n```\n\n### \"hpm: command not found\"\n\n**Ursache:** hpm ist nicht installiert oder nicht im PATH.\n\n**Lsung:**\n\n```bash\n# Prfen, wo hpm installiert ist\nls -la /usr/local/bin/hpm\nls -la ~/.local/bin/hpm\n\n# Bei benutzerdefiniertem Speicherort zum PATH hinzufgen\nexport PATH=\"$HOME/.local/bin:$PATH\"\n\n# Fr Persistenz zu ~/.bashrc oder ~/.zshrc hinzufgen\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc\nsource ~/.bashrc\n\n# Bei Bedarf neu installieren\ncd /path/to/hpm\nsudo make install\n```\n\n### \"Permission denied\" bei Installation\n\n**Ursache:** Keine Schreibberechtigung fr das Installationsverzeichnis.\n\n**Lsung:**\n\n```bash\n# Option 1: sudo fr systemweite Installation verwenden\nsudo make install\n\n# Option 2: In Benutzerverzeichnis installieren (kein sudo)\nmake install PREFIX=$HOME/.local\n```\n\n## Abhngigkeitsprobleme\n\n### \"Package not found\" (Exit-Code 2)\n\n**Ursache:** Das Paket existiert nicht auf GitHub.\n\n**Lsung:**\n\n```bash\n# Prfen, ob das Paket existiert\n# Besuchen Sie: https://github.com/owner/repo\n\n# Rechtschreibung berprfen\nhpm install hemlang/sprout  # Richtig\nhpm install hemlan/sprout   # Falscher Owner\nhpm install hemlang/spout   # Falscher Repo\n\n# Auf Tippfehler in package.json prfen\ncat package.json | grep -A 5 dependencies\n```\n\n### \"Version not found\" (Exit-Code 3)\n\n**Ursache:** Kein Release entspricht der Versionseinschrnkung.\n\n**Lsung:**\n\n```bash\n# Verfgbare Versionen auflisten (GitHub-Releases/Tags prfen)\n# Tags mssen mit 'v' beginnen (z.B. v1.0.0)\n\n# Eine gltige Versionseinschrnkung verwenden\nhpm install owner/repo@^1.0.0\n\n# Neueste Version versuchen\nhpm install owner/repo\n\n# Verfgbare Tags auf GitHub prfen\n# https://github.com/owner/repo/tags\n```\n\n### \"Dependency conflict\" (Exit-Code 1)\n\n**Ursache:** Zwei Pakete bentigen inkompatible Versionen einer Abhngigkeit.\n\n**Lsung:**\n\n```bash\n# Konflikt anzeigen\nhpm install --verbose\n\n# Prfen, was die Abhngigkeit bentigt\nhpm why conflicting/package\n\n# Lsungen:\n# 1. Das konfliktverursachende Paket aktualisieren\nhpm update problem/package\n\n# 2. Versionseinschrnkungen in package.json ndern\n# Bearbeiten, um kompatible Versionen zu erlauben\n\n# 3. Eines der konfliktverursachenden Pakete entfernen\nhpm uninstall one/package\n```\n\n### \"Circular dependency\" (Exit-Code 8)\n\n**Ursache:** Paket A hngt von B ab, das wiederum von A abhngt.\n\n**Lsung:**\n\n```bash\n# Den Zyklus identifizieren\nhpm install --verbose\n\n# Dies ist normalerweise ein Bug in den Paketen\n# Paket-Maintainer kontaktieren\n\n# Workaround: eines der Pakete vermeiden\n```\n\n## Netzwerkprobleme\n\n### \"Network error\" (Exit-Code 4)\n\n**Ursache:** Keine Verbindung zur GitHub-API mglich.\n\n**Lsung:**\n\n```bash\n# Internetverbindung prfen\nping github.com\n\n# Prfen, ob GitHub-API erreichbar ist\ncurl -I https://api.github.com\n\n# Erneut versuchen (hpm wiederholt automatisch)\nhpm install\n\n# Offline-Modus verwenden, wenn Pakete gecacht sind\nhpm install --offline\n\n# Proxy-Einstellungen prfen, falls hinter Firewall\nexport HTTPS_PROXY=http://proxy:8080\nhpm install\n```\n\n### \"GitHub rate limit exceeded\" (Exit-Code 7)\n\n**Ursache:** Zu viele API-Anfragen ohne Authentifizierung.\n\n**Lsung:**\n\n```bash\n# Option 1: Mit GitHub-Token authentifizieren (empfohlen)\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Token erstellen: GitHub  Einstellungen  Entwicklereinstellungen  Personal access tokens\n\n# Option 2: Token in Konfigurationsdatei speichern\nmkdir -p ~/.hpm\necho '{\"github_token\": \"ghp_xxxxxxxxxxxx\"}' > ~/.hpm/config.json\n\n# Option 3: Auf Rate-Limit-Reset warten (wird stndlich zurckgesetzt)\n\n# Option 4: Offline-Modus verwenden\nhpm install --offline\n```\n\n### Verbindungs-Timeout\n\n**Ursache:** Langsames Netzwerk oder GitHub-API-Probleme.\n\n**Lsung:**\n\n```bash\n# hpm wiederholt automatisch mit exponentiellem Backoff\n\n# Prfen, ob GitHub Probleme hat\n# Besuchen Sie: https://www.githubstatus.com\n\n# Spter erneut versuchen\nhpm install\n\n# Gecachte Pakete verwenden\nhpm install --offline\n```\n\n## Package.json-Probleme\n\n### \"Invalid package.json\" (Exit-Code 5)\n\n**Ursache:** Fehlerhafte oder fehlende erforderliche Felder.\n\n**Lsung:**\n\n```bash\n# JSON-Syntax validieren\ncat package.json | python -m json.tool\n\n# Erforderliche Felder prfen\ncat package.json\n\n# Erforderliche Felder:\n# - \"name\": \"owner/repo\"-Format\n# - \"version\": \"X.Y.Z\"-Format\n\n# Bei Bedarf neu generieren\nrm package.json\nhpm init\n```\n\n### \"name\"-Formatfehler\n\n**Ursache:** Paketname nicht im `owner/repo`-Format.\n\n**Lsung:**\n\n```json\n// Falsch\n{\n  \"name\": \"my-package\"\n}\n\n// Richtig\n{\n  \"name\": \"yourusername/my-package\"\n}\n```\n\n### \"version\"-Formatfehler\n\n**Ursache:** Version nicht im Semver-Format.\n\n**Lsung:**\n\n```json\n// Falsch\n{\n  \"version\": \"1.0\"\n}\n\n// Richtig\n{\n  \"version\": \"1.0.0\"\n}\n```\n\n## Lock-Datei-Probleme\n\n### Lock-Datei nicht synchron\n\n**Ursache:** package.json gendert ohne install auszufhren.\n\n**Lsung:**\n\n```bash\n# Lock-Datei neu generieren\nrm package-lock.json\nhpm install\n```\n\n### Beschdigte Lock-Datei\n\n**Ursache:** Ungltiges JSON oder manuelle Bearbeitungen.\n\n**Lsung:**\n\n```bash\n# JSON-Gltigkeit prfen\ncat package-lock.json | python -m json.tool\n\n# Neu generieren\nrm package-lock.json\nhpm install\n```\n\n## hem_modules-Probleme\n\n### Pakete werden nicht installiert\n\n**Ursache:** Verschiedene mgliche Probleme.\n\n**Lsung:**\n\n```bash\n# Bereinigen und neu installieren\nrm -rf hem_modules\nhpm install\n\n# Ausfhrliche Ausgabe prfen\nhpm install --verbose\n```\n\n### Import funktioniert nicht\n\n**Ursache:** Paket nicht korrekt installiert oder falscher Importpfad.\n\n**Lsung:**\n\n```bash\n# berprfen, ob Paket installiert ist\nls hem_modules/owner/repo/\n\n# main-Feld in package.json prfen\ncat hem_modules/owner/repo/package.json\n\n# Korrektes Import-Format\nimport { x } from \"owner/repo\";          # Verwendet main-Eintrag\nimport { y } from \"owner/repo/subpath\";  # Unterpfad-Import\n```\n\n### \"Module not found\"-Fehler\n\n**Ursache:** Importpfad lst nicht zu einer Datei auf.\n\n**Lsung:**\n\n```bash\n# Importpfad prfen\nls hem_modules/owner/repo/src/\n\n# Auf index.hml prfen\nls hem_modules/owner/repo/src/index.hml\n\n# main-Feld in package.json berprfen\ncat hem_modules/owner/repo/package.json | grep main\n```\n\n## Cache-Probleme\n\n### Cache belegt zu viel Speicherplatz\n\n**Lsung:**\n\n```bash\n# Cache-Gre anzeigen\nhpm cache list\n\n# Cache leeren\nhpm cache clean\n```\n\n### Cache-Berechtigungen\n\n**Lsung:**\n\n```bash\n# Berechtigungen reparieren\nchmod -R u+rw ~/.hpm/cache\n\n# Oder entfernen und neu installieren\nrm -rf ~/.hpm/cache\nhpm install\n```\n\n### Falschen Cache verwenden\n\n**Lsung:**\n\n```bash\n# Cache-Speicherort prfen\necho $HPM_CACHE_DIR\nls ~/.hpm/cache\n\n# Umgebungsvariable lschen, falls falsch\nunset HPM_CACHE_DIR\n```\n\n## Skript-Probleme\n\n### \"Script not found\"\n\n**Ursache:** Skriptname existiert nicht in package.json.\n\n**Lsung:**\n\n```bash\n# Verfgbare Skripte auflisten\ncat package.json | grep -A 20 scripts\n\n# Rechtschreibung prfen\nhpm run test    # Richtig\nhpm run tests   # Falsch, wenn Skript \"test\" heit\n```\n\n### Skript schlgt fehl\n\n**Ursache:** Fehler im Skriptbefehl.\n\n**Lsung:**\n\n```bash\n# Befehl direkt ausfhren, um Fehler zu sehen\nhemlock test/run.hml\n\n# Skriptdefinition prfen\ncat package.json | grep test\n```\n\n## Debugging\n\n### Ausfhrliche Ausgabe aktivieren\n\n```bash\nhpm install --verbose\n```\n\n### hpm-Version prfen\n\n```bash\nhpm --version\n```\n\n### Hemlock-Version prfen\n\n```bash\nhemlock --version\n```\n\n### Trockenlauf\n\nVorschau ohne nderungen:\n\n```bash\nhpm install --dry-run\n```\n\n### Neuanfang\n\nFrisch starten:\n\n```bash\nrm -rf hem_modules package-lock.json\nhpm install\n```\n\n## Hilfe erhalten\n\n### Befehlshilfe\n\n```bash\nhpm --help\nhpm install --help\n```\n\n### Probleme melden\n\nWenn Sie einen Bug finden:\n\n1. Bestehende Issues prfen: https://github.com/hemlang/hpm/issues\n2. Neues Issue erstellen mit:\n   - hpm-Version (`hpm --version`)\n   - Hemlock-Version (`hemlock --version`)\n   - Betriebssystem\n   - Schritte zum Reproduzieren\n   - Fehlermeldung (mit `--verbose`)\n\n## Exit-Code-Referenz\n\n| Code | Bedeutung | Hufige Lsung |\n|------|-----------|----------------|\n| 0 | Erfolg | - |\n| 1 | Abhngigkeitskonflikt | Aktualisieren oder Einschrnkungen ndern |\n| 2 | Paket nicht gefunden | Rechtschreibung prfen, Repo-Existenz verifizieren |\n| 3 | Version nicht gefunden | Verfgbare Versionen auf GitHub prfen |\n| 4 | Netzwerkfehler | Verbindung prfen, erneut versuchen |\n| 5 | Ungltige package.json | JSON-Syntax und erforderliche Felder reparieren |\n| 6 | Integrittsprfung fehlgeschlagen | Cache leeren, neu installieren |\n| 7 | GitHub-Rate-Limit | GITHUB_TOKEN hinzufgen |\n| 8 | Zirkulre Abhngigkeit | Paket-Maintainer kontaktieren |\n\n## Siehe auch\n\n- [Installation](#hpm-troubleshooting-installation) - Installationsanleitung\n- [Konfiguration](#hpm-troubleshooting-configuration) - Konfigurationsoptionen\n- [Befehle](#hpm-troubleshooting-commands) - Befehlsreferenz\n"}, "hpm: Benutzerhandbuch -> Konfiguration": {"id": "hpm-configuration", "content": "# Konfiguration\n\nDiese Anleitung behandelt alle Konfigurationsoptionen fr hpm.\n\n## bersicht\n\nhpm kann konfiguriert werden durch:\n\n1. **Umgebungsvariablen** - Fr Laufzeiteinstellungen\n2. **Globale Konfigurationsdatei** - `~/.hpm/config.json`\n3. **Projektdateien** - `package.json` und `package-lock.json`\n\n## Umgebungsvariablen\n\n### GITHUB_TOKEN\n\nGitHub-API-Token fr Authentifizierung.\n\n```bash\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n```\n\n**Vorteile der Authentifizierung:**\n- Hhere API-Rate-Limits (5000 statt 60 Anfragen/Stunde)\n- Zugriff auf private Repositories\n- Schnellere Abhngigkeitsauflsung\n\n**Token erstellen:**\n\n1. Gehen Sie zu GitHub  Einstellungen  Entwicklereinstellungen  Personal access tokens\n2. Klicken Sie auf \"Generate new token (classic)\"\n3. Whlen Sie Berechtigungen:\n   - `repo` - Fr Zugriff auf private Repositories\n   - `read:packages` - Fr GitHub Packages (falls verwendet)\n4. Generieren und Token kopieren\n\n### HPM_CACHE_DIR\n\nDas Standard-Cache-Verzeichnis berschreiben.\n\n```bash\nexport HPM_CACHE_DIR=/custom/cache/path\n```\n\nStandard: `~/.hpm/cache`\n\n**Anwendungsflle:**\n- CI/CD-Systeme mit benutzerdefinierten Cache-Speicherorten\n- Gemeinsamer Cache ber Projekte hinweg\n- Temporrer Cache fr isolierte Builds\n\n### HOME\n\nBenutzer-Home-Verzeichnis. Wird verwendet, um zu finden:\n- Konfigurationsverzeichnis: `$HOME/.hpm/`\n- Cache-Verzeichnis: `$HOME/.hpm/cache/`\n\nNormalerweise vom System gesetzt; nur bei Bedarf berschreiben.\n\n### Beispiel .bashrc / .zshrc\n\n```bash\n# GitHub-Authentifizierung (empfohlen)\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n\n# Benutzerdefinierter Cache-Speicherort (optional)\n# export HPM_CACHE_DIR=/path/to/cache\n\n# hpm zum PATH hinzufgen (bei benutzerdefiniertem Installationsort)\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## Globale Konfigurationsdatei\n\n### Speicherort\n\n`~/.hpm/config.json`\n\n### Format\n\n```json\n{\n  \"github_token\": \"ghp_xxxxxxxxxxxxxxxxxxxx\"\n}\n```\n\n### Konfigurationsdatei erstellen\n\n```bash\n# Konfigurationsverzeichnis erstellen\nmkdir -p ~/.hpm\n\n# Konfigurationsdatei erstellen\ncat > ~/.hpm/config.json << 'EOF'\n{\n  \"github_token\": \"ghp_your_token_here\"\n}\nEOF\n\n# Datei sichern (empfohlen)\nchmod 600 ~/.hpm/config.json\n```\n\n### Token-Prioritt\n\nWenn beide gesetzt sind, hat die Umgebungsvariable Vorrang:\n\n1. `GITHUB_TOKEN` Umgebungsvariable (hchste)\n2. `~/.hpm/config.json` `github_token`-Feld\n3. Keine Authentifizierung (Standard)\n\n## Verzeichnisstruktur\n\n### Globale Verzeichnisse\n\n```\n~/.hpm/\n config.json          # Globale Konfiguration\n cache/               # Paket-Cache\n     owner/\n         repo/\n             1.0.0.tar.gz\n```\n\n### Projektverzeichnisse\n\n```\nmy-project/\n package.json         # Projektmanifest\n package-lock.json    # Abhngigkeits-Lock-Datei\n hem_modules/         # Installierte Pakete\n    owner/\n        repo/\n            package.json\n            src/\n src/                 # Quellcode\n test/                # Tests\n```\n\n## Paket-Cache\n\n### Speicherort\n\nStandard: `~/.hpm/cache/`\n\nberschreiben mit: `HPM_CACHE_DIR` Umgebungsvariable\n\n### Struktur\n\n```\n~/.hpm/cache/\n hemlang/\n    sprout/\n       2.0.0.tar.gz\n       2.1.0.tar.gz\n    router/\n        1.5.0.tar.gz\n alice/\n     http-client/\n         1.0.0.tar.gz\n```\n\n### Cache verwalten\n\n```bash\n# Gecachte Pakete anzeigen\nhpm cache list\n\n# Gesamten Cache leeren\nhpm cache clean\n```\n\n### Cache-Verhalten\n\n- Pakete werden nach dem ersten Download gecacht\n- Nachfolgende Installationen verwenden gecachte Versionen\n- Verwenden Sie `--offline`, um nur aus dem Cache zu installieren\n- Der Cache wird ber alle Projekte geteilt\n\n## GitHub-API-Rate-Limits\n\n### Ohne Authentifizierung\n\n- **60 Anfragen pro Stunde** pro IP-Adresse\n- Geteilt unter allen nicht authentifizierten Benutzern derselben IP\n- Schnell erschpft bei CI/CD oder vielen Abhngigkeiten\n\n### Mit Authentifizierung\n\n- **5000 Anfragen pro Stunde** pro authentifiziertem Benutzer\n- Persnliches Rate-Limit, nicht geteilt\n\n### Rate-Limits behandeln\n\nhpm macht automatisch:\n- Wiederholungen mit exponentiellem Backoff (1s, 2s, 4s, 8s)\n- Meldet Rate-Limit-Fehler mit Exit-Code 7\n- Schlgt Authentifizierung vor, wenn Rate-Limit erreicht\n\n**Lsungen bei Rate-Limit:**\n\n```bash\n# Option 1: Mit GitHub-Token authentifizieren\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Option 2: Auf Rate-Limit-Reset warten\n# (Limits werden stndlich zurckgesetzt)\n\n# Option 3: Offline-Modus verwenden (wenn Pakete gecacht sind)\nhpm install --offline\n```\n\n## Offline-Modus\n\nPakete ohne Netzwerkzugriff installieren:\n\n```bash\nhpm install --offline\n```\n\n**Voraussetzungen:**\n- Alle Pakete mssen im Cache sein\n- Lock-Datei muss mit exakten Versionen existieren\n\n**Anwendungsflle:**\n- Air-Gapped-Umgebungen\n- Schnellere CI/CD-Builds (mit warmem Cache)\n- Rate-Limits vermeiden\n\n## CI/CD-Konfiguration\n\n### GitHub Actions\n\n```yaml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Hemlock einrichten\n      run: |\n        # Hemlock installieren (anpassen basierend auf Ihrem Setup)\n        curl -sSL https://hemlock.dev/install.sh | sh\n\n    - name: hpm-Pakete cachen\n      uses: actions/cache@v3\n      with:\n        path: ~/.hpm/cache\n        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}\n        restore-keys: |\n          ${{ runner.os }}-hpm-\n\n    - name: Abhngigkeiten installieren\n      run: hpm install\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Tests ausfhren\n      run: hpm test\n```\n\n### GitLab CI\n\n```yaml\nstages:\n  - build\n  - test\n\nvariables:\n  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache\n\ncache:\n  paths:\n    - .hpm-cache/\n  key: $CI_COMMIT_REF_SLUG\n\nbuild:\n  stage: build\n  script:\n    - hpm install\n  artifacts:\n    paths:\n      - hem_modules/\n\ntest:\n  stage: test\n  script:\n    - hpm test\n```\n\n### Docker\n\n**Dockerfile:**\n\n```dockerfile\nFROM hemlock:latest\n\nWORKDIR /app\n\n# Paketdateien zuerst kopieren (fr Layer-Caching)\nCOPY package.json package-lock.json ./\n\n# Abhngigkeiten installieren\nRUN hpm install\n\n# Quellcode kopieren\nCOPY . .\n\n# Anwendung ausfhren\nCMD [\"hemlock\", \"src/main.hml\"]\n```\n\n**docker-compose.yml:**\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    environment:\n      - GITHUB_TOKEN=${GITHUB_TOKEN}\n    volumes:\n      - hpm-cache:/root/.hpm/cache\n\nvolumes:\n  hpm-cache:\n```\n\n## Proxy-Konfiguration\n\nFr Umgebungen hinter einem Proxy auf Systemebene konfigurieren:\n\n```bash\nexport HTTP_PROXY=http://proxy.example.com:8080\nexport HTTPS_PROXY=http://proxy.example.com:8080\nexport NO_PROXY=localhost,127.0.0.1\n\nhpm install\n```\n\n## Sicherheits-Best-Practices\n\n### Token-Sicherheit\n\n1. **Tokens niemals committen** zur Versionskontrolle\n2. **Umgebungsvariablen verwenden** in CI/CD\n3. **Token-Berechtigungen einschrnken** auf das erforderliche Minimum\n4. **Tokens regelmig rotieren**\n5. **Konfigurationsdatei sichern**:\n   ```bash\n   chmod 600 ~/.hpm/config.json\n   ```\n\n### Private Repositories\n\nUm auf private Pakete zuzugreifen:\n\n1. Token mit `repo`-Berechtigung erstellen\n2. Authentifizierung konfigurieren (Umgebungsvariable oder Konfigurationsdatei)\n3. Sicherstellen, dass das Token Zugriff auf das Repository hat\n\n```bash\n# Zugriff testen\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install yourorg/private-package\n```\n\n## Konfiguration-Fehlerbehebung\n\n### Konfiguration berprfen\n\n```bash\n# Prfen, ob Token gesetzt ist\necho $GITHUB_TOKEN | head -c 10\n\n# Konfigurationsdatei prfen\ncat ~/.hpm/config.json\n\n# Cache-Verzeichnis prfen\nls -la ~/.hpm/cache/\n\n# Mit ausfhrlicher Ausgabe testen\nhpm install --verbose\n```\n\n### Hufige Probleme\n\n**\"GitHub rate limit exceeded\"**\n- Authentifizierung mit `GITHUB_TOKEN` einrichten\n- Auf Rate-Limit-Reset warten\n- `--offline` verwenden, wenn Pakete gecacht sind\n\n**\"Permission denied\" beim Cache**\n```bash\n# Cache-Berechtigungen reparieren\nchmod -R u+rw ~/.hpm/cache\n```\n\n**\"Config file not found\"**\n```bash\n# Konfigurationsverzeichnis erstellen\nmkdir -p ~/.hpm\ntouch ~/.hpm/config.json\n```\n\n## Siehe auch\n\n- [Installation](#hpm-configuration-installation) - hpm installieren\n- [Fehlerbehebung](#hpm-configuration-troubleshooting) - Hufige Probleme\n- [Befehle](#hpm-configuration-commands) - Befehlsreferenz\n"}, "hpm: Paketentwicklung -> Pakete erstellen": {"id": "hpm-creating-packages", "content": "# Pakete erstellen\n\nDiese Anleitung behandelt, wie man Hemlock-Pakete erstellt, strukturiert und verffentlicht.\n\n## bersicht\n\nhpm verwendet GitHub als Paketregistrierung. Pakete werden durch ihren GitHub-`owner/repo`-Pfad identifiziert, und Versionen sind Git-Tags. Verffentlichen bedeutet einfach, ein getaggtes Release zu pushen.\n\n## Ein neues Paket erstellen\n\n### 1. Das Paket initialisieren\n\nEin neues Verzeichnis erstellen und initialisieren:\n\n```bash\nmkdir my-package\ncd my-package\nhpm init\n```\n\nDie Eingabeaufforderungen beantworten:\n\n```\nPackage name (owner/repo): yourusername/my-package\nVersion (1.0.0):\nDescription: Ein ntzliches Hemlock-Paket\nAuthor: Ihr Name <sie@beispiel.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n### 2. Die Projektstruktur erstellen\n\nEmpfohlene Struktur fr Pakete:\n\n```\nmy-package/\n package.json          # Paketmanifest\n README.md             # Dokumentation\n LICENSE               # Lizenzdatei\n src/\n    index.hml         # Haupteinstiegspunkt (exportiert ffentliche API)\n    utils.hml         # Interne Hilfsfunktionen\n    types.hml         # Typdefinitionen\n test/\n     framework.hml     # Test-Framework\n     test_utils.hml    # Tests\n```\n\n### 3. Ihre ffentliche API definieren\n\n**src/index.hml** - Haupteinstiegspunkt:\n\n```hemlock\n// ffentliche API re-exportieren\nexport { parse, stringify } from \"./parser.hml\";\nexport { Config, Options } from \"./types.hml\";\nexport { process } from \"./processor.hml\";\n\n// Direkte Exporte\nexport fn create(options: Options): Config {\n    // Implementierung\n}\n\nexport fn validate(config: Config): bool {\n    // Implementierung\n}\n```\n\n### 4. Ihre package.json schreiben\n\nVollstndiges package.json-Beispiel:\n\n```json\n{\n  \"name\": \"yourusername/my-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Ein ntzliches Hemlock-Paket\",\n  \"author\": \"Ihr Name <sie@beispiel.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/yourusername/my-package\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/bundle.hmlc\"\n  },\n  \"keywords\": [\"utility\", \"parser\", \"config\"],\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n## Paketbenennung\n\n### Anforderungen\n\n- Muss im `owner/repo`-Format sein\n- `owner` sollte Ihr GitHub-Benutzername oder Ihre Organisation sein\n- `repo` sollte der Repository-Name sein\n- Kleinbuchstaben mit Bindestrichen fr mehrwortige Namen verwenden\n\n### Gute Namen\n\n```\nhemlang/sprout\nalice/http-client\nmyorg/json-utils\nbob/date-formatter\n```\n\n### Vermeiden\n\n```\nmy-package          # Owner fehlt\nalice/MyPackage     # PascalCase\nalice/my_package    # Unterstriche\n```\n\n## Best Practices fr Paketstruktur\n\n### Einstiegspunkt\n\nDas `main`-Feld in package.json gibt den Einstiegspunkt an:\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\nDiese Datei sollte Ihre ffentliche API exportieren:\n\n```hemlock\n// Alles exportieren, was Benutzer brauchen\nexport { Parser, parse } from \"./parser.hml\";\nexport { Formatter, format } from \"./formatter.hml\";\n\n// Typen\nexport type { Config, Options } from \"./types.hml\";\n```\n\n### Intern vs ffentlich\n\nInterne Implementierungsdetails privat halten:\n\n```\nsrc/\n index.hml          # ffentlich: exportierte API\n parser.hml         # ffentlich: von index.hml verwendet\n formatter.hml      # ffentlich: von index.hml verwendet\n internal/\n     helpers.hml    # Privat: nur interne Verwendung\n     constants.hml  # Privat: nur interne Verwendung\n```\n\nBenutzer importieren vom Paket-Root:\n\n```hemlock\n// Gut - importiert aus ffentlicher API\nimport { parse, Parser } from \"yourusername/my-package\";\n\n// Funktioniert auch - Unterpfad-Import\nimport { validate } from \"yourusername/my-package/validator\";\n\n// Nicht empfohlen - Zugriff auf Interna\nimport { helper } from \"yourusername/my-package/internal/helpers\";\n```\n\n### Unterpfad-Exporte\n\nUntersttzung fr Importe aus Unterpfaden:\n\n```\nsrc/\n index.hml              # Haupteinstieg\n parser/\n    index.hml          # yourusername/pkg/parser\n formatter/\n    index.hml          # yourusername/pkg/formatter\n utils/\n     index.hml          # yourusername/pkg/utils\n```\n\nBenutzer knnen importieren:\n\n```hemlock\nimport { parse } from \"yourusername/my-package\";           # Haupt\nimport { Parser } from \"yourusername/my-package/parser\";   # Unterpfad\nimport { format } from \"yourusername/my-package/formatter\";\n```\n\n## Abhngigkeiten\n\n### Abhngigkeiten hinzufgen\n\n```bash\n# Laufzeitabhngigkeit\nhpm install hemlang/json\n\n# Entwicklungsabhngigkeit\nhpm install hemlang/test-utils --dev\n```\n\n### Best Practices fr Abhngigkeiten\n\n1. **Caret-Bereiche verwenden** fr die meisten Abhngigkeiten:\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     }\n   }\n   ```\n\n2. **Versionen nur bei Bedarf pinnen** (API-Instabilitt):\n   ```json\n   {\n     \"dependencies\": {\n       \"unstable/lib\": \"1.2.3\"\n     }\n   }\n   ```\n\n3. **Zu restriktive Bereiche vermeiden**:\n   ```json\n   // Schlecht: zu restriktiv\n   \"hemlang/json\": \">=1.2.3 <1.2.5\"\n\n   // Gut: erlaubt kompatible Updates\n   \"hemlang/json\": \"^1.2.3\"\n   ```\n\n4. **Dev-Abhngigkeiten getrennt halten**:\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     },\n     \"devDependencies\": {\n       \"hemlang/test-utils\": \"^1.0.0\"\n     }\n   }\n   ```\n\n## Ihr Paket testen\n\n### Tests schreiben\n\n**test/run.hml:**\n\n```hemlock\nimport { suite, test, assert_eq } from \"./framework.hml\";\nimport { parse, stringify } from \"../src/index.hml\";\n\nfn run_tests() {\n    suite(\"Parser\", fn() {\n        test(\"parst gltige Eingabe\", fn() {\n            let result = parse(\"hello\");\n            assert_eq(result.value, \"hello\");\n        });\n\n        test(\"behandelt leere Eingabe\", fn() {\n            let result = parse(\"\");\n            assert_eq(result.value, \"\");\n        });\n    });\n\n    suite(\"Stringify\", fn() {\n        test(\"stringifiziert Objekt\", fn() {\n            let obj = { name: \"test\" };\n            let result = stringify(obj);\n            assert_eq(result, '{\"name\":\"test\"}');\n        });\n    });\n}\n\nrun_tests();\n```\n\n### Tests ausfhren\n\nTest-Skript hinzufgen:\n\n```json\n{\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\nAusfhren mit:\n\n```bash\nhpm test\n```\n\n## Verffentlichen\n\n### Voraussetzungen\n\n1. GitHub-Repository erstellen, das Ihrem Paketnamen entspricht\n2. Sicherstellen, dass `package.json` vollstndig und gltig ist\n3. Alle Tests bestehen\n\n### Verffentlichungsprozess\n\nVerffentlichen bedeutet einfach, einen Git-Tag zu pushen:\n\n```bash\n# 1. Sicherstellen, dass alles committet ist\ngit add .\ngit commit -m \"Prepare v1.0.0 release\"\n\n# 2. Versions-Tag erstellen (muss mit 'v' beginnen)\ngit tag v1.0.0\n\n# 3. Code und Tags pushen\ngit push origin main\ngit push origin v1.0.0\n# Oder alle Tags auf einmal pushen\ngit push origin main --tags\n```\n\n### Versions-Tags\n\nTags mssen dem Format `vX.Y.Z` folgen:\n\n```bash\ngit tag v1.0.0      # Release\ngit tag v1.0.1      # Patch\ngit tag v1.1.0      # Minor\ngit tag v2.0.0      # Major\ngit tag v1.0.0-beta.1  # Pre-Release\n```\n\n### Release-Checkliste\n\nVor dem Verffentlichen einer neuen Version:\n\n1. **Version aktualisieren** in package.json\n2. **Tests ausfhren**: `hpm test`\n3. **CHANGELOG aktualisieren** (falls vorhanden)\n4. **README aktualisieren**, falls API gendert\n5. **nderungen committen**\n6. **Tag erstellen**\n7. **Zu GitHub pushen**\n\n### Automatisiertes Beispiel\n\nRelease-Skript erstellen:\n\n```bash\n#!/bin/bash\n# release.sh - Neue Version verffentlichen\n\nVERSION=$1\n\nif [ -z \"$VERSION\" ]; then\n    echo \"Verwendung: ./release.sh 1.0.0\"\n    exit 1\nfi\n\n# Tests ausfhren\nhpm test || exit 1\n\n# Version in package.json aktualisieren\nsed -i \"s/\\\"version\\\": \\\".*\\\"/\\\"version\\\": \\\"$VERSION\\\"/\" package.json\n\n# Committen und taggen\ngit add package.json\ngit commit -m \"Release v$VERSION\"\ngit tag \"v$VERSION\"\n\n# Pushen\ngit push origin main --tags\n\necho \"v$VERSION verffentlicht\"\n```\n\n## Benutzer installieren Ihr Paket\n\nNach der Verffentlichung knnen Benutzer installieren:\n\n```bash\n# Neueste Version\nhpm install yourusername/my-package\n\n# Bestimmte Version\nhpm install yourusername/my-package@1.0.0\n\n# Versionseinschrnkung\nhpm install yourusername/my-package@^1.0.0\n```\n\nUnd importieren:\n\n```hemlock\nimport { parse, stringify } from \"yourusername/my-package\";\n```\n\n## Dokumentation\n\n### README.md\n\nJedes Paket sollte eine README haben:\n\n```markdown\n# my-package\n\nEine kurze Beschreibung, was dieses Paket tut.\n\n## Installation\n\n\\`\\`\\`bash\nhpm install yourusername/my-package\n\\`\\`\\`\n\n## Verwendung\n\n\\`\\`\\`hemlock\nimport { parse } from \"yourusername/my-package\";\n\nlet result = parse(\"input\");\n\\`\\`\\`\n\n## API\n\n### parse(input: string): Result\n\nParst die Eingabezeichenkette.\n\n### stringify(obj: any): string\n\nKonvertiert Objekt in Zeichenkette.\n\n## Lizenz\n\nMIT\n```\n\n### API-Dokumentation\n\nAlle ffentlichen Exporte dokumentieren:\n\n```hemlock\n/// Parst die Eingabezeichenkette in ein strukturiertes Result.\n///\n/// # Argumente\n/// * `input` - Die zu parsende Zeichenkette\n///\n/// # Rckgabe\n/// Ein Result mit den geparsten Daten oder einem Fehler\n///\n/// # Beispiel\n/// ```\n/// let result = parse(\"hello world\");\n/// print(result.value);\n/// ```\nexport fn parse(input: string): Result {\n    // Implementierung\n}\n```\n\n## Versionierungsrichtlinien\n\nFolgen Sie [Semantic Versioning](https://semver.org/):\n\n- **MAJOR** (1.0.0  2.0.0): Breaking Changes\n- **MINOR** (1.0.0  1.1.0): Neue Features, abwrtskompatibel\n- **PATCH** (1.0.0  1.0.1): Bugfixes, abwrtskompatibel\n\n### Wann erhhen\n\n| nderungstyp | Versionsbump |\n|--------------|--------------|\n| Breaking API-nderung | MAJOR |\n| Funktion/Typ entfernen | MAJOR |\n| Funktionssignatur ndern | MAJOR |\n| Neue Funktion hinzufgen | MINOR |\n| Neues Feature hinzufgen | MINOR |\n| Bugfix | PATCH |\n| Dokumentations-Update | PATCH |\n| Internes Refactoring | PATCH |\n\n## Siehe auch\n\n- [Paketspezifikation](#hpm-creating-packages-package-spec) - Vollstndige package.json-Referenz\n- [Versionierung](#hpm-creating-packages-versioning) - Details zur semantischen Versionierung\n- [Konfiguration](#hpm-creating-packages-configuration) - GitHub-Authentifizierung\n"}, "hpm: Paketentwicklung -> Paketspezifikation": {"id": "hpm-package-spec", "content": "# Paketspezifikation\n\nVollstndige Referenz fr das `package.json`-Dateiformat.\n\n## bersicht\n\nJedes hpm-Paket erfordert eine `package.json`-Datei im Projektstammverzeichnis. Diese Datei definiert Paketmetadaten, Abhngigkeiten und Skripte.\n\n## Minimales Beispiel\n\n```json\n{\n  \"name\": \"owner/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n## Vollstndiges Beispiel\n\n```json\n{\n  \"name\": \"hemlang/example-package\",\n  \"version\": \"1.2.3\",\n  \"description\": \"Ein Beispiel-Hemlock-Paket\",\n  \"author\": \"Hemlock Team <team@hemlock.dev>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/hemlang/example-package\",\n  \"homepage\": \"https://hemlang.github.io/example-package\",\n  \"bugs\": \"https://github.com/hemlang/example-package/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"example\", \"utility\", \"hemlock\"],\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"^2.1.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/bundle.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n## Feldreferenz\n\n### name (erforderlich)\n\nDer Paketname im `owner/repo`-Format.\n\n```json\n{\n  \"name\": \"hemlang/sprout\"\n}\n```\n\n**Anforderungen:**\n- Muss im `owner/repo`-Format sein\n- `owner` sollte Ihr GitHub-Benutzername oder Ihre Organisation sein\n- `repo` sollte der Repository-Name sein\n- Kleinbuchstaben, Zahlen und Bindestriche verwenden\n- Maximal 214 Zeichen insgesamt\n\n**Gltige Namen:**\n```\nhemlang/sprout\nalice/http-client\nmyorg/json-utils\nbob123/my-lib\n```\n\n**Ungltige Namen:**\n```\nmy-package          # Owner fehlt\nhemlang/My_Package  # Grobuchstaben und Unterstrich\nhemlang             # Repo fehlt\n```\n\n### version (erforderlich)\n\nDie Paketversion nach [Semantic Versioning](https://semver.org/).\n\n```json\n{\n  \"version\": \"1.2.3\"\n}\n```\n\n**Format:** `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`\n\n**Gltige Versionen:**\n```\n1.0.0\n2.1.3\n1.0.0-alpha\n1.0.0-beta.1\n1.0.0-rc.1+build.123\n0.1.0\n```\n\n### description\n\nKurze Beschreibung des Pakets.\n\n```json\n{\n  \"description\": \"Ein schneller JSON-Parser fr Hemlock\"\n}\n```\n\n- Unter 200 Zeichen halten\n- Beschreiben, was das Paket tut, nicht wie\n\n### author\n\nInformationen zum Paketautor.\n\n```json\n{\n  \"author\": \"Ihr Name <email@beispiel.com>\"\n}\n```\n\n**Akzeptierte Formate:**\n```json\n\"author\": \"Ihr Name\"\n\"author\": \"Ihr Name <email@beispiel.com>\"\n\"author\": \"Ihr Name <email@beispiel.com> (https://website.com)\"\n```\n\n### license\n\nDer Lizenz-Identifikator.\n\n```json\n{\n  \"license\": \"MIT\"\n}\n```\n\n**Hufige Lizenzen:**\n- `MIT` - MIT-Lizenz\n- `Apache-2.0` - Apache-Lizenz 2.0\n- `GPL-3.0` - GNU General Public License v3.0\n- `BSD-3-Clause` - BSD 3-Clause-Lizenz\n- `ISC` - ISC-Lizenz\n- `UNLICENSED` - Proprietr/privat\n\nVerwenden Sie wenn mglich [SPDX-Identifikatoren](https://spdx.org/licenses/).\n\n### repository\n\nLink zum Quell-Repository.\n\n```json\n{\n  \"repository\": \"https://github.com/hemlang/sprout\"\n}\n```\n\n### homepage\n\nProjekt-Homepage-URL.\n\n```json\n{\n  \"homepage\": \"https://sprout.hemlock.dev\"\n}\n```\n\n### bugs\n\nIssue-Tracker-URL.\n\n```json\n{\n  \"bugs\": \"https://github.com/hemlang/sprout/issues\"\n}\n```\n\n### main\n\nEinstiegspunktdatei fr das Paket.\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\n**Standard:** `src/index.hml`\n\nWenn Benutzer Ihr Paket importieren:\n```hemlock\nimport { x } from \"owner/repo\";\n```\n\nhpm ldt die in `main` angegebene Datei.\n\n**Auflsungsreihenfolge fr Importe:**\n1. Exakter Pfad: `src/index.hml`\n2. Mit .hml-Erweiterung: `src/index`  `src/index.hml`\n3. Index-Datei: `src/index/`  `src/index/index.hml`\n\n### keywords\n\nArray von Schlsselwrtern fr die Auffindbarkeit.\n\n```json\n{\n  \"keywords\": [\"json\", \"parser\", \"utility\", \"hemlock\"]\n}\n```\n\n- Kleinbuchstaben verwenden\n- Spezifisch und relevant sein\n- Sprache (\"hemlock\") einschlieen, falls angemessen\n\n### dependencies\n\nLaufzeitabhngigkeiten, die fr das Funktionieren des Pakets erforderlich sind.\n\n```json\n{\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"~2.1.0\",\n    \"alice/logger\": \">=1.0.0 <2.0.0\"\n  }\n}\n```\n\n**Schlssel:** Paketname (`owner/repo`)\n**Wert:** Versionseinschrnkung\n\n**Syntax fr Versionseinschrnkungen:**\n\n| Einschrnkung | Bedeutung |\n|---------------|-----------|\n| `1.2.3` | Exakte Version |\n| `^1.2.3` | >=1.2.3 <2.0.0 |\n| `~1.2.3` | >=1.2.3 <1.3.0 |\n| `>=1.0.0` | Mindestens 1.0.0 |\n| `>=1.0.0 <2.0.0` | Bereich |\n| `*` | Beliebige Version |\n\n### devDependencies\n\nNur fr die Entwicklung bentigte Abhngigkeiten (Testen, Bauen, etc.).\n\n```json\n{\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\",\n    \"hemlang/linter\": \"^2.0.0\"\n  }\n}\n```\n\nDev-Abhngigkeiten werden:\n- Whrend der Entwicklung installiert\n- Nicht installiert, wenn das Paket als Abhngigkeit verwendet wird\n- Fr Testen, Bauen, Linting usw. verwendet\n\n### scripts\n\nBenannte Befehle, die mit `hpm run` ausgefhrt werden knnen.\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n**Skripte ausfhren:**\n```bash\nhpm run start\nhpm run build\nhpm test        # Kurzform fr 'hpm run test'\n```\n\n**Argumente bergeben:**\n```bash\nhpm run test -- --verbose --filter=unit\n```\n\n**Hufige Skripte:**\n\n| Skript | Zweck |\n|--------|-------|\n| `start` | Anwendung starten |\n| `dev` | Entwicklungsmodus mit Hot Reload |\n| `test` | Tests ausfhren |\n| `build` | Fr Produktion bauen |\n| `clean` | Build-Artefakte entfernen |\n| `lint` | Code-Stil prfen |\n| `format` | Code formatieren |\n\n### files\n\nDateien und Verzeichnisse, die beim Installieren des Pakets enthalten sein sollen.\n\n```json\n{\n  \"files\": [\n    \"src/\",\n    \"lib/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n**Standardverhalten:** Falls nicht angegeben, enthlt:\n- Alle Dateien im Repository\n- Ausgenommen `.git/`, `node_modules/`, `hem_modules/`\n\n**Verwenden um:**\n- Paketgre zu reduzieren\n- Testdateien von der Distribution auszuschlieen\n- Nur notwendige Dateien einzuschlieen\n\n### native\n\nNative Bibliotheksanforderungen.\n\n```json\n{\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\", \"sqlite3\"]\n  }\n}\n```\n\nDokumentiert native Abhngigkeiten, die auf dem System installiert sein mssen.\n\n## Validierung\n\nhpm validiert package.json bei verschiedenen Operationen. Hufige Validierungsfehler:\n\n### Fehlende erforderliche Felder\n\n```\nError: package.json missing required field: name\n```\n\n**Lsung:** Das erforderliche Feld hinzufgen.\n\n### Ungltiges Namensformat\n\n```\nError: Invalid package name. Must be in owner/repo format.\n```\n\n**Lsung:** `owner/repo`-Format verwenden.\n\n### Ungltige Version\n\n```\nError: Invalid version \"1.0\". Must be semver format (X.Y.Z).\n```\n\n**Lsung:** Vollstndiges Semver-Format verwenden (`1.0.0`).\n\n### Ungltiges JSON\n\n```\nError: package.json is not valid JSON\n```\n\n**Lsung:** JSON-Syntax prfen (Kommas, Anfhrungszeichen, Klammern).\n\n## package.json erstellen\n\n### Interaktiv\n\n```bash\nhpm init\n```\n\nFragt interaktiv nach jedem Feld.\n\n### Mit Standardwerten\n\n```bash\nhpm init --yes\n```\n\nErstellt mit Standardwerten:\n```json\n{\n  \"name\": \"directory-name/directory-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\n### Manuell\n\nDie Datei manuell erstellen:\n\n```bash\ncat > package.json << 'EOF'\n{\n  \"name\": \"yourname/your-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Ihre Paketbeschreibung\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\nEOF\n```\n\n## Best Practices\n\n1. **Immer main angeben** - Nicht auf Standard verlassen\n2. **Caret-Bereiche verwenden** - `^1.0.0` fr die meisten Abhngigkeiten\n3. **Dev-Abhngigkeiten trennen** - Test/Build-Deps in devDependencies\n4. **Keywords einschlieen** - Helfen Benutzern, Ihr Paket zu finden\n5. **Skripte dokumentieren** - Skripte klar benennen\n6. **Lizenz angeben** - Erforderlich fr Open Source\n7. **Beschreibung hinzufgen** - Helfen Benutzern, den Zweck zu verstehen\n\n## Siehe auch\n\n- [Pakete erstellen](#hpm-package-spec-creating-packages) - Verffentlichungsanleitung\n- [Versionierung](#hpm-package-spec-versioning) - Versionseinschrnkungen\n- [Projekteinrichtung](#hpm-package-spec-project-setup) - Projektstruktur\n"}, "hpm: Paketentwicklung -> Versionierung": {"id": "hpm-versioning", "content": "# Versionierung\n\nVollstndige Anleitung zur semantischen Versionierung in hpm.\n\n## Semantische Versionierung\n\nhpm verwendet [Semantic Versioning 2.0.0](https://semver.org/) (semver) fr Paketversionen.\n\n### Versionsformat\n\n```\nMAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]\n```\n\n**Beispiele:**\n```\n1.0.0           # Release-Version\n2.1.3           # Release-Version\n1.0.0-alpha     # Pre-Release\n1.0.0-beta.1    # Pre-Release mit Nummer\n1.0.0-rc.1      # Release Candidate\n1.0.0+20231201  # Mit Build-Metadaten\n1.0.0-beta+exp  # Pre-Release mit Build-Metadaten\n```\n\n### Versionskomponenten\n\n| Komponente | Beschreibung | Beispiel |\n|------------|--------------|----------|\n| MAJOR | Breaking Changes | `1.0.0`  `2.0.0` |\n| MINOR | Neue Features (abwrtskompatibel) | `1.0.0`  `1.1.0` |\n| PATCH | Bugfixes (abwrtskompatibel) | `1.0.0`  `1.0.1` |\n| PRERELEASE | Pre-Release-Identifikator | `1.0.0-alpha` |\n| BUILD | Build-Metadaten (bei Vergleich ignoriert) | `1.0.0+build123` |\n\n### Wann erhhen\n\n| nderungstyp | Erhhen | Beispiel |\n|--------------|---------|----------|\n| Breaking API-nderung | MAJOR | Funktion entfernen |\n| ffentliche Funktion umbenennen | MAJOR | `parse()`  `decode()` |\n| Funktionssignatur ndern | MAJOR | Erforderlichen Parameter hinzufgen |\n| Neue Funktion hinzufgen | MINOR | `validate()` hinzufgen |\n| Optionalen Parameter hinzufgen | MINOR | Neues optionales `options`-Arg |\n| Bugfix | PATCH | Null-Pointer beheben |\n| Leistungsverbesserung | PATCH | Schnellerer Algorithmus |\n| Internes Refactoring | PATCH | Keine API-nderung |\n\n## Versionseinschrnkungen\n\n### Einschrnkungssyntax\n\n| Syntax | Bedeutung | Lst auf zu |\n|--------|-----------|-------------|\n| `1.2.3` | Exakte Version | Nur 1.2.3 |\n| `^1.2.3` | Caret (kompatibel) | 1.2.3 und <2.0.0 |\n| `~1.2.3` | Tilde (Patch-Updates) | 1.2.3 und <1.3.0 |\n| `>=1.0.0` | Mindestens | 1.0.0 oder hher |\n| `>1.0.0` | Grer als | Hher als 1.0.0 |\n| `<2.0.0` | Kleiner als | Niedriger als 2.0.0 |\n| `<=2.0.0` | Hchstens | 2.0.0 oder niedriger |\n| `>=1.0.0 <2.0.0` | Bereich | Zwischen 1.0.0 und 2.0.0 |\n| `*` | Beliebig | Beliebige Version |\n\n### Caret-Bereiche (^)\n\nDas Caret (`^`) erlaubt nderungen, die die linkeste Nicht-Null-Ziffer nicht modifizieren:\n\n```\n^1.2.3    >=1.2.3 <2.0.0   # Erlaubt 1.x.x\n^0.2.3    >=0.2.3 <0.3.0   # Erlaubt 0.2.x\n^0.0.3    >=0.0.3 <0.0.4   # Erlaubt nur 0.0.3\n```\n\n**Verwenden wenn:** Sie kompatible Updates innerhalb einer Major-Version wollen.\n\n**Hufigste Einschrnkung** - fr die meisten Abhngigkeiten empfohlen.\n\n### Tilde-Bereiche (~)\n\nDie Tilde (`~`) erlaubt nur Patch-Level-nderungen:\n\n```\n~1.2.3    >=1.2.3 <1.3.0   # Erlaubt 1.2.x\n~1.2      >=1.2.0 <1.3.0   # Erlaubt 1.2.x\n~1        >=1.0.0 <2.0.0   # Erlaubt 1.x.x\n```\n\n**Verwenden wenn:** Sie nur Bugfixes wollen, keine neuen Features.\n\n### Vergleichsbereiche\n\nVergleichsoperatoren fr przise Kontrolle kombinieren:\n\n```json\n{\n  \"dependencies\": {\n    \"owner/pkg\": \">=1.0.0 <2.0.0\",\n    \"owner/other\": \">1.5.0 <=2.1.0\"\n  }\n}\n```\n\n### Beliebige Version (*)\n\nEntspricht jeder Version:\n\n```json\n{\n  \"dependencies\": {\n    \"owner/pkg\": \"*\"\n  }\n}\n```\n\n**Warnung:** Nicht fr Produktion empfohlen. Wird immer die neueste Version holen.\n\n## Pre-Release-Versionen\n\n### Pre-Release-Identifikatoren\n\nPre-Releases haben niedrigere Prioritt als Releases:\n\n```\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0\n```\n\n### Hufige Pre-Release-Tags\n\n| Tag | Bedeutung | Stadium |\n|-----|-----------|---------|\n| `alpha` | Frhe Entwicklung | Sehr instabil |\n| `beta` | Feature-vollstndig | Testen |\n| `rc` | Release Candidate | Finales Testen |\n| `dev` | Entwicklungs-Snapshot | Instabil |\n\n### Pre-Release in Einschrnkungen\n\nEinschrnkungen entsprechen standardmig keinen Pre-Releases:\n\n```\n^1.0.0    # Entspricht NICHT 1.1.0-beta\n>=1.0.0   # Entspricht NICHT 2.0.0-alpha\n```\n\nUm Pre-Releases einzuschlieen, explizit referenzieren:\n\n```\n>=1.0.0-alpha <2.0.0   # Schliet alle 1.x Pre-Releases ein\n```\n\n## Versionsvergleich\n\n### Vergleichsregeln\n\n1. MAJOR, MINOR, PATCH numerisch vergleichen\n2. Release > Pre-Release mit gleicher Version\n3. Pre-Releases alphanumerisch vergleichen\n4. Build-Metadaten werden ignoriert\n\n### Beispiele\n\n```\n1.0.0 < 1.0.1 < 1.1.0 < 2.0.0\n\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0\n\n1.0.0 = 1.0.0+build123  # Build-Metadaten ignoriert\n```\n\n### Sortierung\n\nVersionen werden aufsteigend sortiert:\n\n```\n1.0.0\n1.0.1\n1.1.0\n1.1.1\n2.0.0-alpha\n2.0.0-beta\n2.0.0\n```\n\n## Versionsauflsung\n\n### Auflsungsalgorithmus\n\nWenn mehrere Pakete dieselbe Abhngigkeit bentigen:\n\n1. Alle Einschrnkungen sammeln\n2. Schnittmenge aller Bereiche finden\n3. Hchste Version in der Schnittmenge whlen\n4. Fehler, wenn keine Version alle erfllt\n\n### Beispiel-Auflsung\n\n```\npackage-a erfordert hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npackage-b erfordert hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)\n\nSchnittmenge: >=1.2.0 <1.3.0\nVerfgbar: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]\nAufgelst: 1.2.5 (hchste in Schnittmenge)\n```\n\n### Konflikterkennung\n\nKonflikt tritt auf, wenn keine Version alle Einschrnkungen erfllt:\n\n```\npackage-a erfordert hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npackage-b erfordert hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)\n\nSchnittmenge: (leer)\nErgebnis: KONFLIKT - keine Version erfllt beide\n```\n\n## Best Practices\n\n### Fr Paket-Konsumenten\n\n1. **Caret-Bereiche verwenden** fr die meisten Abhngigkeiten:\n   ```json\n   \"hemlang/json\": \"^1.2.0\"\n   ```\n\n2. **Tilde-Bereiche verwenden** fr kritische Abhngigkeiten:\n   ```json\n   \"critical/lib\": \"~1.2.0\"\n   ```\n\n3. **Versionen nur bei Bedarf pinnen**:\n   ```json\n   \"unstable/pkg\": \"1.2.3\"\n   ```\n\n4. **Lock-Datei committen** fr reproduzierbare Builds\n\n5. **Regelmig aktualisieren** um Sicherheitsfixes zu erhalten:\n   ```bash\n   hpm update\n   hpm outdated\n   ```\n\n### Fr Paket-Autoren\n\n1. **Bei 0.1.0 starten** fr die anfngliche Entwicklung:\n   - API kann sich hufig ndern\n   - Benutzer erwarten Instabilitt\n\n2. **Zu 1.0.0 wechseln**, wenn API stabil ist:\n   - ffentliche Verpflichtung zur Stabilitt\n   - Breaking Changes erfordern Major-Bump\n\n3. **Semver strikt folgen**:\n   - Breaking Change = MAJOR\n   - Neues Feature = MINOR\n   - Bugfix = PATCH\n\n4. **Pre-Releases fr Tests verwenden**:\n   ```bash\n   git tag v2.0.0-beta.1\n   git push --tags\n   ```\n\n5. **Breaking Changes dokumentieren** im CHANGELOG\n\n## Versionen verffentlichen\n\n### Releases erstellen\n\n```bash\n# Version in package.json aktualisieren\n# package.json bearbeiten: \"version\": \"1.1.0\"\n\n# Versionsnderung committen\ngit add package.json\ngit commit -m \"Bump version to 1.1.0\"\n\n# Tag erstellen und pushen\ngit tag v1.1.0\ngit push origin main --tags\n```\n\n### Tag-Format\n\nTags **mssen** mit `v` beginnen:\n\n```\nv1.0.0       Richtig\nv1.0.0-beta  Richtig\n1.0.0        Wird nicht erkannt\n```\n\n### Release-Workflow\n\n```bash\n# 1. Sicherstellen, dass Tests bestehen\nhpm test\n\n# 2. Version in package.json aktualisieren\n# 3. CHANGELOG.md aktualisieren\n# 4. nderungen committen\ngit add -A\ngit commit -m \"Release v1.2.0\"\n\n# 5. Tag erstellen\ngit tag v1.2.0\n\n# 6. Alles pushen\ngit push origin main --tags\n```\n\n## Versionen prfen\n\n### Installierte Versionen auflisten\n\n```bash\nhpm list\n```\n\n### Nach Updates suchen\n\n```bash\nhpm outdated\n```\n\nAusgabe:\n```\nPackage         Current  Wanted  Latest\nhemlang/json    1.0.0    1.0.5   1.2.0\nhemlang/sprout  2.0.0    2.0.3   2.1.0\n```\n\n- **Current**: Installierte Version\n- **Wanted**: Hchste, die Einschrnkung entspricht\n- **Latest**: Neueste verfgbar\n\n### Pakete aktualisieren\n\n```bash\n# Alle aktualisieren\nhpm update\n\n# Bestimmtes Paket aktualisieren\nhpm update hemlang/json\n```\n\n## Siehe auch\n\n- [Pakete erstellen](#hpm-versioning-creating-packages) - Verffentlichungsanleitung\n- [Paketspezifikation](#hpm-versioning-package-spec) - package.json-Format\n- [Befehle](#hpm-versioning-commands) - CLI-Referenz\n"}, "hpm: Referenz -> Architektur": {"id": "hpm-architecture", "content": "# Architektur\n\nInterne Architektur und Design von hpm. Dieses Dokument richtet sich an Mitwirkende und diejenigen, die verstehen mchten, wie hpm funktioniert.\n\n## bersicht\n\nhpm ist in Hemlock geschrieben und besteht aus mehreren Modulen, die verschiedene Aspekte der Paketverwaltung behandeln:\n\n```\nsrc/\n main.hml        # CLI-Einstiegspunkt und Befehlsrouting\n manifest.hml    # package.json-Verarbeitung\n lockfile.hml    # package-lock.json-Verarbeitung\n semver.hml      # Semantische Versionierung\n resolver.hml    # Abhngigkeitsauflsung\n github.hml      # GitHub-API-Client\n installer.hml   # Paket-Download und -Extraktion\n cache.hml       # Globale Cache-Verwaltung\n```\n\n## Modulverantwortlichkeiten\n\n### main.hml\n\nDer Einstiegspunkt fr die CLI-Anwendung.\n\n**Verantwortlichkeiten:**\n- Kommandozeilenargumente parsen\n- Befehle an entsprechende Handler weiterleiten\n- Hilfe- und Versionsinformationen anzeigen\n- Globale Flags behandeln (--verbose, --dry-run, etc.)\n- Mit entsprechenden Codes beenden\n\n**Hauptfunktionen:**\n- `main()` - Einstiegspunkt, parst Args und verteilt Befehle\n- `cmd_init()` - `hpm init` behandeln\n- `cmd_install()` - `hpm install` behandeln\n- `cmd_uninstall()` - `hpm uninstall` behandeln\n- `cmd_update()` - `hpm update` behandeln\n- `cmd_list()` - `hpm list` behandeln\n- `cmd_outdated()` - `hpm outdated` behandeln\n- `cmd_run()` - `hpm run` behandeln\n- `cmd_why()` - `hpm why` behandeln\n- `cmd_cache()` - `hpm cache` behandeln\n\n**Befehlskrzel:**\n```hemlock\nlet shortcuts = {\n    \"i\": \"install\",\n    \"rm\": \"uninstall\",\n    \"remove\": \"uninstall\",\n    \"ls\": \"list\",\n    \"up\": \"update\"\n};\n```\n\n### manifest.hml\n\nBehandelt das Lesen und Schreiben von `package.json`-Dateien.\n\n**Verantwortlichkeiten:**\n- package.json lesen/schreiben\n- Paketstruktur validieren\n- Abhngigkeiten verwalten\n- Paketspezifizierer parsen (owner/repo@version)\n\n**Hauptfunktionen:**\n```hemlock\ncreate_default(): Manifest           // Leeres Manifest erstellen\nread_manifest(): Manifest            // Aus Datei lesen\nwrite_manifest(m: Manifest)          // In Datei schreiben\nvalidate(m: Manifest): bool          // Struktur validieren\nget_all_dependencies(m): Map         // deps + devDeps holen\nadd_dependency(m, pkg, ver, dev)     // Abhngigkeit hinzufgen\nremove_dependency(m, pkg)            // Abhngigkeit entfernen\nparse_specifier(spec): (name, ver)   // \"owner/repo@^1.0.0\" parsen\nsplit_name(name): (owner, repo)      // \"owner/repo\" parsen\n```\n\n**Manifest-Struktur:**\n```hemlock\ntype Manifest = {\n    name: string,\n    version: string,\n    description: string?,\n    author: string?,\n    license: string?,\n    repository: string?,\n    main: string?,\n    dependencies: Map<string, string>,\n    devDependencies: Map<string, string>,\n    scripts: Map<string, string>\n};\n```\n\n### lockfile.hml\n\nVerwaltet die `package-lock.json`-Datei fr reproduzierbare Installationen.\n\n**Verantwortlichkeiten:**\n- Lock-Dateien erstellen/lesen/schreiben\n- Exakt aufgelste Versionen verfolgen\n- Download-URLs und Integritts-Hashes speichern\n- Verwaiste Abhngigkeiten bereinigen\n\n**Hauptfunktionen:**\n```hemlock\ncreate_empty(): Lockfile              // Leere Lockfile erstellen\nread_lockfile(): Lockfile             // Aus Datei lesen\nwrite_lockfile(l: Lockfile)           // In Datei schreiben\ncreate_entry(ver, url, hash, deps)    // Lock-Eintrag erstellen\nget_locked(l, pkg): LockEntry?        // Gesperrte Version holen\nset_locked(l, pkg, entry)             // Gesperrte Version setzen\nremove_locked(l, pkg)                 // Eintrag entfernen\nprune(l, keep: Set)                   // Verwaiste entfernen\nneeds_update(l, m): bool              // Prfen, ob nicht synchron\n```\n\n**Lockfile-Struktur:**\n```hemlock\ntype Lockfile = {\n    lockVersion: int,\n    hemlock: string,\n    dependencies: Map<string, LockEntry>\n};\n\ntype LockEntry = {\n    version: string,\n    resolved: string,     // Download-URL\n    integrity: string,    // SHA256-Hash\n    dependencies: Map<string, string>\n};\n```\n\n### semver.hml\n\nVollstndige Implementierung von Semantic Versioning 2.0.0.\n\n**Verantwortlichkeiten:**\n- Versionszeichenketten parsen\n- Versionen vergleichen\n- Versionseinschrnkungen parsen und auswerten\n- Versionen finden, die Einschrnkungen erfllen\n\n**Hauptfunktionen:**\n```hemlock\n// Parsen\nparse(s: string): Version             // \"1.2.3-beta+build\"  Version\nstringify(v: Version): string         // Version  \"1.2.3-beta+build\"\n\n// Vergleich\ncompare(a, b: Version): int           // -1, 0 oder 1\ngt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool\n\n// Einschrnkungen\nparse_constraint(s: string): Constraint    // \"^1.2.3\"  Constraint\nsatisfies(v: Version, c: Constraint): bool // Prfen, ob v c entspricht\nmax_satisfying(versions, c): Version?      // Hchste bereinstimmung finden\nsort(versions): [Version]                  // Aufsteigend sortieren\n\n// Hilfsfunktionen\nconstraints_overlap(a, b: Constraint): bool  // Kompatibilitt prfen\n```\n\n**Version-Struktur:**\n```hemlock\ntype Version = {\n    major: int,\n    minor: int,\n    patch: int,\n    prerelease: [string]?,  // z.B. [\"beta\", \"1\"]\n    build: string?          // z.B. \"20230101\"\n};\n```\n\n**Constraint-Typen:**\n```hemlock\ntype Constraint =\n    | Exact(Version)           // \"1.2.3\"\n    | Caret(Version)           // \"^1.2.3\"  >=1.2.3 <2.0.0\n    | Tilde(Version)           // \"~1.2.3\"  >=1.2.3 <1.3.0\n    | Range(op, Version)       // \">=1.0.0\", \"<2.0.0\"\n    | And(Constraint, Constraint)  // Kombinierte Bereiche\n    | Any;                     // \"*\"\n```\n\n### resolver.hml\n\nImplementiert npm-artige Abhngigkeitsauflsung.\n\n**Verantwortlichkeiten:**\n- Abhngigkeitsbume auflsen\n- Versionskonflikte erkennen\n- Zirkulre Abhngigkeiten erkennen\n- Visualisierungsbume erstellen\n\n**Hauptfunktionen:**\n```hemlock\nresolve(manifest, lockfile): ResolveResult\n    // Haupt-Resolver: gibt flache Map aller Abhngigkeiten mit aufgelsten Versionen zurck\n\nresolve_version(pkg, constraints: [string]): ResolvedPackage?\n    // Version finden, die alle Einschrnkungen erfllt\n\ndetect_cycles(deps: Map): [Cycle]?\n    // Zirkulre Abhngigkeiten mit DFS finden\n\nbuild_tree(lockfile): Tree\n    // Baumstruktur fr Anzeige erstellen\n\nfind_why(pkg, lockfile): [Chain]\n    // Abhngigkeitsketten finden, die erklren warum pkg installiert ist\n```\n\n**Auflsungsalgorithmus:**\n\n1. **Einschrnkungen sammeln**: Manifest und transitive Abhngigkeiten durchgehen\n2. **Jedes Paket auflsen**: Fr jedes Paket:\n   - Alle Versionseinschrnkungen von Abhngigen holen\n   - Verfgbare Versionen von GitHub abrufen (gecacht)\n   - Hchste Version finden, die ALLE Einschrnkungen erfllt\n   - Fehler, wenn keine Version alle erfllt (Konflikt)\n3. **Zyklen erkennen**: DFS ausfhren, um zirkulre Abhngigkeiten zu finden\n4. **Flache Map zurckgeben**: Paketname  aufgelste Versionsinformation\n\n**ResolveResult-Struktur:**\n```hemlock\ntype ResolveResult = {\n    packages: Map<string, ResolvedPackage>,\n    conflicts: [Conflict]?,\n    cycles: [Cycle]?\n};\n\ntype ResolvedPackage = {\n    name: string,\n    version: Version,\n    url: string,\n    dependencies: Map<string, string>\n};\n```\n\n### github.hml\n\nGitHub-API-Client fr Paketentdeckung und Downloads.\n\n**Verantwortlichkeiten:**\n- Verfgbare Versionen (Tags) abrufen\n- package.json aus Repositories herunterladen\n- Release-Tarballs herunterladen\n- Authentifizierung und Rate-Limits behandeln\n\n**Hauptfunktionen:**\n```hemlock\nget_token(): string?\n    // Token aus Umgebung oder Konfiguration holen\n\ngithub_request(url, headers?): Response\n    // API-Anfrage mit Wiederholungen machen\n\nget_tags(owner, repo): [string]\n    // Versions-Tags holen (v1.0.0, v1.1.0, etc.)\n\nget_package_json(owner, repo, ref): Manifest\n    // package.json bei bestimmtem Tag/Commit abrufen\n\ndownload_tarball(owner, repo, tag): bytes\n    // Release-Archiv herunterladen\n\nrepo_exists(owner, repo): bool\n    // Prfen, ob Repository existiert\n\nget_repo_info(owner, repo): RepoInfo\n    // Repository-Metadaten holen\n```\n\n**Wiederholungslogik:**\n- Exponentieller Backoff: 1s, 2s, 4s, 8s\n- Wiederholungen bei: 403 (Rate-Limit), 5xx (Serverfehler), Netzwerkfehler\n- Maximal 4 Wiederholungen\n- Rate-Limit-Fehler klar melden\n\n**Verwendete API-Endpunkte:**\n```\nGET /repos/{owner}/{repo}/tags\nGET /repos/{owner}/{repo}/contents/package.json?ref={tag}\nGET /repos/{owner}/{repo}/tarball/{tag}\nGET /repos/{owner}/{repo}\n```\n\n### installer.hml\n\nBehandelt das Herunterladen und Extrahieren von Paketen.\n\n**Verantwortlichkeiten:**\n- Pakete von GitHub herunterladen\n- Tarballs nach hem_modules extrahieren\n- Gecachte Pakete prfen/verwenden\n- Pakete installieren/deinstallieren\n\n**Hauptfunktionen:**\n```hemlock\ninstall_package(pkg: ResolvedPackage): bool\n    // Einzelnes Paket herunterladen und installieren\n\ninstall_all(packages: Map, options): InstallResult\n    // Alle aufgelsten Pakete installieren\n\nuninstall_package(name: string): bool\n    // Paket aus hem_modules entfernen\n\nget_installed(): Map<string, string>\n    // Aktuell installierte Pakete auflisten\n\nverify_integrity(pkg): bool\n    // Paketintegritt berprfen\n\nprefetch_packages(packages: Map): void\n    // Paralleler Download in Cache (experimentell)\n```\n\n**Installationsprozess:**\n\n1. Prfen, ob bereits in korrekter Version installiert\n2. Cache auf Tarball prfen\n3. Wenn nicht gecacht, von GitHub herunterladen\n4. Im Cache fr zuknftige Verwendung speichern\n5. Nach `hem_modules/owner/repo/` extrahieren\n6. Installation verifizieren\n\n**Erstellte Verzeichnisstruktur:**\n```\nhem_modules/\n owner/\n     repo/\n         package.json\n         src/\n         ...\n```\n\n### cache.hml\n\nVerwaltet den globalen Paket-Cache.\n\n**Verantwortlichkeiten:**\n- Heruntergeladene Tarballs speichern\n- Gecachte Pakete abrufen\n- Gecachte Pakete auflisten\n- Cache leeren\n- Konfiguration verwalten\n\n**Hauptfunktionen:**\n```hemlock\nget_cache_dir(): string\n    // Cache-Verzeichnis holen (bercksichtigt HPM_CACHE_DIR)\n\nget_config_dir(): string\n    // Konfigurationsverzeichnis holen (~/.hpm)\n\nis_cached(owner, repo, version): bool\n    // Prfen, ob Tarball gecacht ist\n\nget_cached_path(owner, repo, version): string\n    // Pfad zu gecachtem Tarball holen\n\nstore_tarball_file(owner, repo, version, data): void\n    // Tarball im Cache speichern\n\nlist_cached(): [CachedPackage]\n    // Alle gecachten Pakete auflisten\n\nclear_cache(): int\n    // Alle gecachten Pakete entfernen, freigegebene Bytes zurckgeben\n\nget_cache_size(): int\n    // Gesamte Cache-Gre berechnen\n\nread_config(): Config\n    // ~/.hpm/config.json lesen\n\nwrite_config(c: Config): void\n    // Konfigurationsdatei schreiben\n```\n\n**Cache-Struktur:**\n```\n~/.hpm/\n config.json\n cache/\n     owner/\n         repo/\n             1.0.0.tar.gz\n             1.1.0.tar.gz\n```\n\n## Datenfluss\n\n### Install-Befehl-Ablauf\n\n```\nhpm install owner/repo@^1.0.0\n         \n         \n    \n     main.hml  Args parsen, cmd_install aufrufen\n    \n         \n         \n    \n    manifest.hml package.json lesen, Abhngigkeit hinzufgen\n    \n         \n         \n    \n    resolver.hml Alle Abhngigkeiten auflsen\n    \n         \n         \n                        \n        \n     github.hml     semver.hml Versionen holen, passende finden\n        \n         \n         \n    \n    installer.hml Pakete herunterladen und extrahieren\n    \n         \n         \n                        \n        \n     github.hml     cache.hml Herunterladen oder Cache verwenden\n        \n         \n         \n    \n    lockfile.hml package-lock.json aktualisieren\n    \n```\n\n### Auflsungsalgorithmus-Detail\n\n```\nEingabe: manifest.dependencies, manifest.devDependencies, bestehende Lockfile\n\n1. Initialisieren:\n   - constraints = {} // Map<string, [Constraint]>\n   - resolved = {}    // Map<string, ResolvedPackage>\n   - queue = [direkte Abhngigkeiten]\n\n2. Solange Queue nicht leer:\n   a. pkg = queue.pop()\n   b. Wenn pkg bereits aufgelst, berspringen\n   c. Alle Einschrnkungen fr pkg von Abhngigen holen\n   d. Verfgbare Versionen von GitHub abrufen (gecacht)\n   e. Max Version finden, die alle Einschrnkungen erfllt\n   f. Wenn keine gefunden: KONFLIKT\n   g. resolved[pkg] = {version, url, deps}\n   h. pkg's Abhngigkeiten zur Queue hinzufgen\n\n3. Zyklen im aufgelsten Graphen erkennen\n   - Wenn Zyklus gefunden: FEHLER\n\n4. Aufgelste Map zurckgeben\n```\n\n## Fehlerbehandlung\n\n### Exit-Codes\n\nDefiniert in main.hml:\n\n```hemlock\nlet EXIT_SUCCESS = 0;\nlet EXIT_CONFLICT = 1;\nlet EXIT_NOT_FOUND = 2;\nlet EXIT_VERSION_NOT_FOUND = 3;\nlet EXIT_NETWORK = 4;\nlet EXIT_INVALID_MANIFEST = 5;\nlet EXIT_INTEGRITY = 6;\nlet EXIT_RATE_LIMIT = 7;\nlet EXIT_CIRCULAR = 8;\n```\n\n### Fehler-Propagierung\n\nFehler steigen durch Rckgabewerte auf:\n\n```hemlock\nfn resolve_version(pkg): Result<Version, ResolveError> {\n    let versions = github.get_tags(owner, repo)?;  // ? propagiert\n    // ...\n}\n```\n\n## Testen\n\n### Test-Framework\n\nEigenes Test-Framework in `test/framework.hml`:\n\n```hemlock\nfn suite(name: string, tests: fn()) {\n    print(\"Suite: \" + name);\n    tests();\n}\n\nfn test(name: string, body: fn()) {\n    try {\n        body();\n        print(\"   \" + name);\n    } catch e {\n        print(\"   \" + name + \": \" + e);\n        failed += 1;\n    }\n}\n\nfn assert_eq<T>(actual: T, expected: T) {\n    if actual != expected {\n        throw \"Erwartet \" + expected + \", bekam \" + actual;\n    }\n}\n```\n\n### Testdateien\n\n- `test/test_semver.hml` - Versionsparsen, Vergleich, Einschrnkungen\n- `test/test_manifest.hml` - Manifest-Lesen/Schreiben, Validierung\n- `test/test_lockfile.hml` - Lockfile-Operationen\n- `test/test_cache.hml` - Cache-Verwaltung\n\n### Tests ausfhren\n\n```bash\n# Alle Tests\nmake test\n\n# Spezifische Tests\nmake test-semver\nmake test-manifest\nmake test-lockfile\nmake test-cache\n```\n\n## Zuknftige Verbesserungen\n\n### Geplante Features\n\n1. **Integrittsverifikation** - Vollstndige SHA256-Hash-Prfung\n2. **Workspaces** - Monorepo-Untersttzung\n3. **Plugin-System** - Erweiterbare Befehle\n4. **Audit** - Sicherheitslcken-Prfung\n5. **Private Registry** - Selbst-gehostetes Paket-Hosting\n\n### Bekannte Einschrnkungen\n\n1. **Bundler-Bug** - Kann keine eigenstndige Executable erstellen\n2. **Parallele Downloads** - Experimentell, kann Race Conditions haben\n3. **Integritt** - SHA256 nicht vollstndig implementiert\n\n## Mitwirken\n\n### Code-Stil\n\n- 4 Leerzeichen Einrckung verwenden\n- Funktionen sollten eine Sache tun\n- Komplexe Logik kommentieren\n- Tests fr neue Features schreiben\n\n### Befehl hinzufgen\n\n1. Handler in `main.hml` hinzufgen:\n   ```hemlock\n   fn cmd_newcmd(args: [string]) {\n       // Implementierung\n   }\n   ```\n\n2. Zur Befehlsverteilung hinzufgen:\n   ```hemlock\n   match command {\n       \"newcmd\" => cmd_newcmd(args),\n       // ...\n   }\n   ```\n\n3. Hilfetext aktualisieren\n\n### Modul hinzufgen\n\n1. `src/newmodule.hml` erstellen\n2. ffentliche Schnittstelle exportieren\n3. In Modulen importieren, die es bentigen\n4. Tests in `test/test_newmodule.hml` hinzufgen\n\n## Siehe auch\n\n- [Befehle](#hpm-architecture-commands) - CLI-Referenz\n- [Pakete erstellen](#hpm-architecture-creating-packages) - Paketentwicklung\n- [Versionierung](#hpm-architecture-versioning) - Semantische Versionierung\n"}, "hpm: Referenz -> Exit-Codes": {"id": "hpm-exit-codes", "content": "# Exit-Codes\n\nReferenz fr hpm-Exit-Codes und ihre Bedeutungen.\n\n## Exit-Code-Tabelle\n\n| Code | Name | Beschreibung |\n|------|------|--------------|\n| 0 | SUCCESS | Befehl erfolgreich abgeschlossen |\n| 1 | CONFLICT | Abhngigkeits-Versionskonflikt |\n| 2 | NOT_FOUND | Paket nicht gefunden |\n| 3 | VERSION_NOT_FOUND | Angeforderte Version nicht gefunden |\n| 4 | NETWORK | Netzwerkfehler |\n| 5 | INVALID_MANIFEST | Ungltige package.json |\n| 6 | INTEGRITY | Integrittsprfung fehlgeschlagen |\n| 7 | RATE_LIMIT | GitHub-API-Rate-Limit berschritten |\n| 8 | CIRCULAR | Zirkulre Abhngigkeit erkannt |\n\n## Detaillierte Beschreibungen\n\n### Exit-Code 0: SUCCESS\n\nDer Befehl wurde erfolgreich abgeschlossen.\n\n```bash\n$ hpm install\nInstalled 5 packages\n$ echo $?\n0\n```\n\n### Exit-Code 1: CONFLICT\n\nZwei oder mehr Pakete erfordern inkompatible Versionen einer Abhngigkeit.\n\n**Beispiel:**\n```\nError: Dependency conflict for hemlang/json\n\n  package-a requires hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)\n  package-b requires hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)\n\nNo version satisfies all constraints.\n```\n\n**Lsungen:**\n1. Prfen, welche Pakete den Konflikt haben:\n   ```bash\n   hpm why hemlang/json\n   ```\n2. Das konfliktverursachende Paket aktualisieren:\n   ```bash\n   hpm update package-a\n   ```\n3. Versionseinschrnkungen in package.json lockern\n4. Eines der konfliktverursachenden Pakete entfernen\n\n### Exit-Code 2: NOT_FOUND\n\nDas angegebene Paket existiert nicht auf GitHub.\n\n**Beispiel:**\n```\nError: Package not found: hemlang/nonexistent\n\nThe repository hemlang/nonexistent does not exist on GitHub.\n```\n\n**Lsungen:**\n1. Paketnamen-Schreibweise berprfen\n2. Prfen, ob Repository existiert: `https://github.com/owner/repo`\n3. berprfen, ob Sie Zugriff haben (fr private Repos, GITHUB_TOKEN setzen)\n\n### Exit-Code 3: VERSION_NOT_FOUND\n\nKeine Version entspricht der angegebenen Einschrnkung.\n\n**Beispiel:**\n```\nError: No version of hemlang/json matches constraint ^5.0.0\n\nAvailable versions: 1.0.0, 1.1.0, 1.2.0, 2.0.0\n```\n\n**Lsungen:**\n1. Verfgbare Versionen auf GitHub-Releases/Tags prfen\n2. Eine gltige Versionseinschrnkung verwenden\n3. Versions-Tags mssen mit 'v' beginnen (z.B. `v1.0.0`)\n\n### Exit-Code 4: NETWORK\n\nEin netzwerkbezogener Fehler ist aufgetreten.\n\n**Beispiel:**\n```\nError: Network error: could not connect to api.github.com\n\nPlease check your internet connection and try again.\n```\n\n**Lsungen:**\n1. Internetverbindung prfen\n2. Prfen, ob GitHub erreichbar ist\n3. Proxy-Einstellungen berprfen, falls hinter Firewall\n4. `--offline` verwenden, wenn Pakete gecacht sind:\n   ```bash\n   hpm install --offline\n   ```\n5. Warten und erneut versuchen (hpm wiederholt automatisch)\n\n### Exit-Code 5: INVALID_MANIFEST\n\nDie package.json-Datei ist ungltig oder fehlerhaft.\n\n**Beispiel:**\n```\nError: Invalid package.json\n\n  - Missing required field: name\n  - Invalid version format: \"1.0\"\n```\n\n**Lsungen:**\n1. JSON-Syntax prfen (JSON-Validator verwenden)\n2. Sicherstellen, dass erforderliche Felder existieren (`name`, `version`)\n3. Feldformate berprfen:\n   - name: `owner/repo`-Format\n   - version: `X.Y.Z` Semver-Format\n4. Neu generieren:\n   ```bash\n   rm package.json\n   hpm init\n   ```\n\n### Exit-Code 6: INTEGRITY\n\nPaket-Integrittsverifikation fehlgeschlagen.\n\n**Beispiel:**\n```\nError: Integrity check failed for hemlang/json@1.0.0\n\nExpected: sha256-abc123...\nActual:   sha256-def456...\n\nThe downloaded package may be corrupted.\n```\n\n**Lsungen:**\n1. Cache leeren und neu installieren:\n   ```bash\n   hpm cache clean\n   hpm install\n   ```\n2. Auf Netzwerkprobleme prfen (unvollstndige Downloads)\n3. berprfen, ob das Paket manipuliert wurde\n\n### Exit-Code 7: RATE_LIMIT\n\nGitHub-API-Rate-Limit wurde berschritten.\n\n**Beispiel:**\n```\nError: GitHub API rate limit exceeded\n\nUnauthenticated rate limit: 60 requests/hour\nCurrent usage: 60/60\n\nRate limit resets at: 2024-01-15 10:30:00 UTC\n```\n\n**Lsungen:**\n1. **Mit GitHub authentifizieren** (empfohlen):\n   ```bash\n   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx\n   hpm install\n   ```\n2. Auf Rate-Limit-Reset warten (wird stndlich zurckgesetzt)\n3. Offline-Modus verwenden, wenn Pakete gecacht sind:\n   ```bash\n   hpm install --offline\n   ```\n\n### Exit-Code 8: CIRCULAR\n\nZirkulre Abhngigkeit im Abhngigkeitsgraphen erkannt.\n\n**Beispiel:**\n```\nError: Circular dependency detected\n\n  package-a@1.0.0\n   package-b@1.0.0\n       package-a@1.0.0  (zirkulr!)\n\nCannot resolve dependency tree.\n```\n\n**Lsungen:**\n1. Dies ist normalerweise ein Bug in den Paketen selbst\n2. Paket-Maintainer kontaktieren\n3. Eines der zirkulren Pakete nicht verwenden\n\n## Exit-Codes in Skripten verwenden\n\n### Bash\n\n```bash\n#!/bin/bash\n\nhpm install\nexit_code=$?\n\ncase $exit_code in\n  0)\n    echo \"Installation erfolgreich\"\n    ;;\n  1)\n    echo \"Abhngigkeitskonflikt - Versionseinschrnkungen prfen\"\n    exit 1\n    ;;\n  2)\n    echo \"Paket nicht gefunden - Paketnamen prfen\"\n    exit 1\n    ;;\n  4)\n    echo \"Netzwerkfehler - Verbindung prfen\"\n    exit 1\n    ;;\n  7)\n    echo \"Rate-limitiert - GITHUB_TOKEN setzen\"\n    exit 1\n    ;;\n  *)\n    echo \"Unbekannter Fehler: $exit_code\"\n    exit 1\n    ;;\nesac\n```\n\n### CI/CD\n\n```yaml\n# GitHub Actions\n- name: Abhngigkeiten installieren\n  run: |\n    hpm install\n    if [ $? -eq 7 ]; then\n      echo \"::error::GitHub-Rate-Limit berschritten. GITHUB_TOKEN hinzufgen.\"\n      exit 1\n    fi\n  env:\n    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n### Make\n\n```makefile\ninstall:\n\t@hpm install || (echo \"Installation fehlgeschlagen mit Code $$?\"; exit 1)\n\ntest: install\n\t@hpm test\n```\n\n## Fehlerbehebung nach Exit-Code\n\n### Kurzreferenz\n\n| Code | Zuerst prfen |\n|------|---------------|\n| 1 | `hpm why <package>` ausfhren, um Konflikt zu sehen |\n| 2 | Paketnamen auf GitHub berprfen |\n| 3 | Verfgbare Versionen auf GitHub-Tags prfen |\n| 4 | Internetverbindung prfen |\n| 5 | package.json-Syntax validieren |\n| 6 | `hpm cache clean && hpm install` ausfhren |\n| 7 | `GITHUB_TOKEN`-Umgebungsvariable setzen |\n| 8 | Paket-Maintainer kontaktieren |\n\n## Siehe auch\n\n- [Fehlerbehebung](#hpm-exit-codes-troubleshooting) - Detaillierte Lsungen\n- [Befehle](#hpm-exit-codes-commands) - Befehlsreferenz\n- [Konfiguration](#hpm-exit-codes-configuration) - GitHub-Token einrichten\n"}};

        // Mobile menu toggle
        const menuToggle = document.getElementById('menuToggle');
        const sidebar = document.getElementById('sidebar');

        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
            const isOpen = sidebar.classList.contains('open');
            menuToggle.textContent = isOpen ? '\u00d7' : '\u2630';
            menuToggle.setAttribute('aria-expanded', isOpen);
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth < 1024) {
                if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                    menuToggle.setAttribute('aria-expanded', 'false');
                }
            }
        });

        // Theme toggle functionality
        const themeToggle = document.getElementById('themeToggle');
        const root = document.documentElement;

        // Get saved theme or detect system preference
        function getPreferredTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                return savedTheme;
            }
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        // Apply theme
        function setTheme(theme) {
            root.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        }

        // Initialize theme
        const initialTheme = getPreferredTheme();
        if (localStorage.getItem('theme')) {
            setTheme(initialTheme);
        }

        // Toggle theme on button click
        themeToggle.addEventListener('click', () => {
            const currentTheme = root.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            // Determine current effective theme
            let effectiveTheme;
            if (currentTheme) {
                effectiveTheme = currentTheme;
            } else {
                effectiveTheme = prefersDark ? 'dark' : 'light';
            }

            // Toggle to opposite theme
            const newTheme = effectiveTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        });

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!localStorage.getItem('theme')) {
                // Only auto-switch if user hasn't manually set a preference
                root.removeAttribute('data-theme');
            }
        });

        // Markdown parser
        function parseMarkdown(md) {
            let lines = md.split('\n');
            let html = '';
            let inCodeBlock = false;
            let codeBlockContent = '';
            let codeBlockLang = '';
            let inList = false;
            let listContent = '';
            let inBlockquote = false;
            let blockquoteContent = '';
            let inTable = false;
            let tableRows = [];
            let tableHasHeader = false;

            function processInlineMarkdown(text) {
                text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
                text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
                return text;
            }

            function makeId(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/^-+|-+$/g, '');
            }

            function flushList() {
                if (inList && listContent) {
                    html += '<ul>\n' + listContent + '</ul>\n';
                    listContent = '';
                    inList = false;
                }
            }

            function flushBlockquote() {
                if (inBlockquote && blockquoteContent) {
                    html += '<blockquote>' + processInlineMarkdown(blockquoteContent.trim()) + '</blockquote>\n';
                    blockquoteContent = '';
                    inBlockquote = false;
                }
            }

            function flushTable() {
                if (inTable && tableRows.length > 0) {
                    html += '<table>\n';
                    for (let r = 0; r < tableRows.length; r++) {
                        const row = tableRows[r];
                        const isHeader = tableHasHeader && r === 0;
                        const tag = isHeader ? 'th' : 'td';
                        html += '<tr>\n';
                        for (const cell of row) {
                            html += '<' + tag + '>' + processInlineMarkdown(cell.trim()) + '</' + tag + '>\n';
                        }
                        html += '</tr>\n';
                    }
                    html += '</table>\n';
                    tableRows = [];
                    inTable = false;
                    tableHasHeader = false;
                }
            }

            function isTableSeparator(line) {
                return /^\|?[\s-:|]+\|[\s-:|]+\|?$/.test(line) && line.includes('-');
            }

            function parseTableRow(line) {
                let cells = line.split('|');
                // Remove empty first/last cells from leading/trailing |
                if (cells.length > 0 && cells[0].trim() === '') cells.shift();
                if (cells.length > 0 && cells[cells.length - 1].trim() === '') cells.pop();
                return cells;
            }

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                const trimmedLine = line.trim();

                // Handle code blocks (including indented ones in lists)
                if (trimmedLine.startsWith('```')) {
                    if (inCodeBlock) {
                        const codeId = 'code-' + Math.random().toString(36).substr(2, 9);
                        const langDisplay = codeBlockLang || 'code';
                        const copyIcon = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>';
                        html += `<div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">${langDisplay}</span>
                                <button class="copy-btn" onclick="copyCode('${codeId}')" aria-label="Copy code">${copyIcon}<span>Copy</span></button>
                            </div>
                            <pre><code id="${codeId}">` + escapeHtml(codeBlockContent) + '</code></pre></div>\n';
                        codeBlockContent = '';
                        codeBlockLang = '';
                        inCodeBlock = false;
                    } else {
                        flushList();
                        flushBlockquote();
                        inCodeBlock = true;
                        codeBlockLang = trimmedLine.substring(3).trim();
                    }
                    continue;
                }

                if (inCodeBlock) {
                    codeBlockContent += line + '\n';
                    continue;
                }

                // Table handling
                if (trimmedLine.includes('|')) {
                    if (trimmedLine.startsWith('|') || trimmedLine.endsWith('|')) {
                        flushList();
                        flushBlockquote();
                        if (isTableSeparator(trimmedLine)) {
                            // This is the separator row (|---|---|), mark header
                            if (tableRows.length === 1) {
                                tableHasHeader = true;
                            }
                        } else {
                            // Regular table row
                            tableRows.push(parseTableRow(trimmedLine));
                            inTable = true;
                        }
                        continue;
                    }
                }
                // Flush table if we hit a non-table line
                if (inTable) {
                    flushTable();
                }

                if (line.startsWith('# ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    const id = makeId(text);
                    html += `<h1 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h1>\n`;
                    continue;
                }
                if (line.startsWith('## ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(3).trim();
                    const id = makeId(text);
                    html += `<h2 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h2>\n`;
                    continue;
                }
                if (line.startsWith('### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(4).trim();
                    const id = makeId(text);
                    html += `<h3 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h3>\n`;
                    continue;
                }
                if (line.startsWith('#### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(5).trim();
                    const id = makeId(text);
                    html += `<h4 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h4>\n`;
                    continue;
                }

                if (line.trim() === '---') {
                    flushList();
                    flushBlockquote();
                    html += '<hr>\n';
                    continue;
                }

                if (line.startsWith('> ')) {
                    flushList();
                    blockquoteContent += line.substring(2) + ' ';
                    inBlockquote = true;
                    continue;
                } else if (inBlockquote && line.trim() === '') {
                    flushBlockquote();
                    continue;
                }

                if (line.startsWith('- ') || line.startsWith('* ')) {
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    listContent += '<li>' + processInlineMarkdown(text) + '</li>\n';
                    inList = true;
                    continue;
                } else if (inList && line.trim() !== '' && !line.startsWith('#')) {
                    listContent = listContent.trimEnd();
                    if (listContent.endsWith('</li>')) {
                        listContent = listContent.substring(0, listContent.length - 5);
                        listContent += ' ' + processInlineMarkdown(line.trim()) + '</li>\n';
                    }
                    continue;
                } else if (inList && line.trim() === '') {
                    flushList();
                    continue;
                }

                if (line.trim() === '') {
                    flushList();
                    flushBlockquote();
                    continue;
                }

                flushList();
                flushBlockquote();
                if (line.trim() !== '') {
                    html += '<p>' + processInlineMarkdown(line) + '</p>\n';
                }
            }

            flushList();
            flushBlockquote();
            flushTable();

            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Copy code to clipboard
        function copyCode(codeId) {
            const codeElement = document.getElementById(codeId);
            if (!codeElement) return;

            const text = codeElement.textContent;
            navigator.clipboard.writeText(text).then(() => {
                // Find the button that triggered this
                const btn = codeElement.closest('.code-block').querySelector('.copy-btn');
                if (btn) {
                    const originalText = btn.querySelector('span').textContent;
                    btn.classList.add('copied');
                    btn.querySelector('span').textContent = 'Copied!';

                    setTimeout(() => {
                        btn.classList.remove('copied');
                        btn.querySelector('span').textContent = originalText;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Load a page
        function loadPage(pageId) {
            const pageData = Object.values(PAGES).find(p => p.id === pageId);
            if (!pageData) {
                console.error('Page not found:', pageId);
                return;
            }

            const content = parseMarkdown(pageData.content);
            document.getElementById('content').innerHTML = content;

            // Update active nav link
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.dataset.page === pageId) {
                    link.classList.add('active');
                }
            });

            // Scroll to top
            window.scrollTo(0, 0);

            // Update URL hash
            window.location.hash = pageId;
        }

        // Setup navigation
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const pageId = link.dataset.page;
                loadPage(pageId);

                // Close mobile menu
                if (window.innerWidth < 1024) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                }
            });
        });

        // Handle browser back/forward
        window.addEventListener('hashchange', () => {
            const hash = window.location.hash.substring(1);
            if (hash) {
                loadPage(hash);
            }
        });

        // Search functionality
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const searchContainer = document.getElementById('searchContainer');
        const searchToggle = document.getElementById('searchToggle');
        let selectedIndex = -1;
        let currentResults = [];

        // Build search index from PAGES
        function buildSearchIndex() {
            const index = [];
            for (const [title, page] of Object.entries(PAGES)) {
                // Extract section from page ID
                const parts = page.id.split('-');
                let section = '';
                if (parts.length > 1) {
                    section = parts.slice(0, -1).join(' ');
                }

                // Extract headings from content
                const headings = [];
                const headingRegex = /^#+\s+(.+)$/gm;
                let match;
                while ((match = headingRegex.exec(page.content)) !== null) {
                    headings.push(match[1]);
                }

                // Get preview text (first 200 chars, stripped of markdown)
                let preview = page.content
                    .replace(/^#+\s+.+$/gm, '')  // Remove headings
                    .replace(/```[\s\S]*?```/g, '')  // Remove code blocks
                    .replace(/`[^`]+`/g, '')  // Remove inline code
                    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')  // Convert links to text
                    .replace(/\*\*([^*]+)\*\*/g, '$1')  // Remove bold
                    .replace(/\*([^*]+)\*/g, '$1')  // Remove italic
                    .replace(/\n+/g, ' ')  // Normalize whitespace
                    .trim()
                    .substring(0, 200);

                index.push({
                    title: title,
                    pageId: page.id,
                    section: section,
                    headings: headings,
                    content: page.content.toLowerCase(),
                    preview: preview
                });
            }
            return index;
        }

        const searchIndex = buildSearchIndex();

        // Search function
        function search(query) {
            if (!query || query.length < 2) return [];

            const q = query.toLowerCase().trim();
            const results = [];

            for (const item of searchIndex) {
                let score = 0;
                let matchedHeading = null;
                let matchContext = '';

                // Check title (highest priority)
                const titleLower = item.title.toLowerCase();
                if (titleLower === q) {
                    score = 100;
                } else if (titleLower.startsWith(q)) {
                    score = 80;
                } else if (titleLower.includes(q)) {
                    score = 60;
                }

                // Check headings
                for (const heading of item.headings) {
                    const headingLower = heading.toLowerCase();
                    if (headingLower === q) {
                        score = Math.max(score, 50);
                        matchedHeading = heading;
                    } else if (headingLower.includes(q)) {
                        score = Math.max(score, 40);
                        if (!matchedHeading) matchedHeading = heading;
                    }
                }

                // Check content
                if (item.content.includes(q)) {
                    score = Math.max(score, 20);

                    // Find context around the match
                    const idx = item.content.indexOf(q);
                    const start = Math.max(0, idx - 40);
                    const end = Math.min(item.content.length, idx + q.length + 60);
                    matchContext = item.content.substring(start, end);
                    if (start > 0) matchContext = '...' + matchContext;
                    if (end < item.content.length) matchContext = matchContext + '...';
                }

                if (score > 0) {
                    results.push({
                        title: item.title,
                        pageId: item.pageId,
                        section: item.section,
                        score: score,
                        matchedHeading: matchedHeading,
                        preview: matchContext || item.preview,
                        query: q
                    });
                }
            }

            // Sort by score descending
            results.sort((a, b) => b.score - a.score);

            return results.slice(0, 10);  // Limit to 10 results
        }

        // Highlight query in text
        function highlightText(text, query) {
            if (!query) return text;
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }

        // Render search results
        function renderResults(results, query) {
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-no-results">No results found</div>';
                return;
            }

            const html = results.map((result, index) => {
                const titleHtml = highlightText(result.title, query);
                const previewHtml = highlightText(result.preview, query);
                const selectedClass = index === selectedIndex ? ' selected' : '';

                return `
                    <div class="search-result${selectedClass}" data-index="${index}" data-page="${result.pageId}">
                        ${result.section ? `<div class="search-result-section">${result.section}</div>` : ''}
                        <div class="search-result-title">${titleHtml}</div>
                        ${result.matchedHeading ? `<div class="search-result-preview">${highlightText(result.matchedHeading, query)}</div>` : ''}
                        <div class="search-result-preview">${previewHtml}</div>
                    </div>
                `;
            }).join('');

            searchResults.innerHTML = html;

            // Add click handlers
            searchResults.querySelectorAll('.search-result').forEach(el => {
                el.addEventListener('click', () => {
                    const pageId = el.dataset.page;
                    loadPage(pageId);
                    closeSearch();
                });
            });
        }

        // Show search results
        function showResults() {
            searchResults.classList.add('active');
        }

        // Hide search results
        function hideResults() {
            searchResults.classList.remove('active');
            selectedIndex = -1;
        }

        // Close search (mobile)
        function closeSearch() {
            hideResults();
            searchInput.value = '';
            searchInput.blur();
            if (window.innerWidth < 769) {
                searchContainer.classList.remove('active');
            }
        }

        // Debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Handle search input
        const handleSearch = debounce((query) => {
            currentResults = search(query);
            if (query.length >= 2) {
                renderResults(currentResults, query);
                showResults();
            } else {
                hideResults();
            }
        }, 150);

        searchInput.addEventListener('input', (e) => {
            handleSearch(e.target.value);
        });

        // Handle keyboard navigation
        searchInput.addEventListener('keydown', (e) => {
            if (!searchResults.classList.contains('active')) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, currentResults.length - 1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIndex >= 0 && currentResults[selectedIndex]) {
                    loadPage(currentResults[selectedIndex].pageId);
                    closeSearch();
                } else if (currentResults.length > 0) {
                    loadPage(currentResults[0].pageId);
                    closeSearch();
                }
            } else if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Close results when clicking outside
        document.addEventListener('click', (e) => {
            if (!searchContainer.contains(e.target)) {
                hideResults();
            }
        });

        // Focus search on input click
        searchInput.addEventListener('focus', () => {
            if (searchInput.value.length >= 2) {
                handleSearch(searchInput.value);
            }
        });

        // Global keyboard shortcut (Ctrl+K or Cmd+K)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                if (window.innerWidth < 769) {
                    searchContainer.classList.add('active');
                }
                searchInput.focus();
            }
            if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Mobile search toggle
        if (searchToggle) {
            searchToggle.addEventListener('click', () => {
                searchContainer.classList.toggle('active');
                if (searchContainer.classList.contains('active')) {
                    searchInput.focus();
                }
            });
        }

        // Language switcher
        function switchLanguage(filename) {
            const currentHash = window.location.hash;
            window.location.href = filename + currentHash;
        }

        // Load initial page
        const initialHash = window.location.hash.substring(1);
        const firstPageId = Object.values(PAGES)[0].id;
        loadPage(initialHash || firstPageId);
    </script>
</body>
</html>