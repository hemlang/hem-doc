<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manuel du Langage Hemlock</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sage: #9CAF88;
            --pine: #2F4F4F;
            --dark-pine: #1a2f2f;
            --light-sage: #E8F4E1;
            --cream: #FAF9F6;
            --text: #2C3E2C;
            --text-light: #5A6F5A;
            --border: #D4E4CB;
            --code-bg: #F5F9F3;
            --accent: #6B8E6B;
        }

        [data-theme="dark"] {
            --sage: #6B8E6B;
            --pine: #9CAF88;
            --dark-pine: #0d1a1a;
            --light-sage: #1a2f2f;
            --cream: #0f1a1a;
            --text: #e0e8e0;
            --text-light: #a8b8a8;
            --border: #2a4a4a;
            --code-bg: #162626;
            --accent: #9CAF88;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) {
                --sage: #6B8E6B;
                --pine: #9CAF88;
                --dark-pine: #0d1a1a;
                --light-sage: #1a2f2f;
                --cream: #0f1a1a;
                --text: #e0e8e0;
                --text-light: #a8b8a8;
                --border: #2a4a4a;
                --code-bg: #162626;
                --accent: #9CAF88;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            line-height: 1.7;
            color: var(--text);
            background: var(--cream);
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: #2F4F4F;
            color: white;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .header-logo {
            height: 45px;
            margin-right: 1rem;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            margin-right: auto;
        }

        @media (max-width: 768px) {
            .header h1 {
                display: none;
            }
        }

        /* Layout */
        .container {
            display: flex;
            margin-top: 70px;
            min-height: calc(100vh - 70px);
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 70px;
            width: 280px;
            height: calc(100vh - 70px);
            background: var(--light-sage);
            border-right: 2px solid var(--border);
            overflow-y: auto;
            padding: 2rem 0;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 900;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        @media (min-width: 1024px) {
            .sidebar {
                transform: translateX(0);
            }
        }

        .nav-section {
            margin-bottom: 1.5rem;
        }

        .nav-section-title {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--pine);
            padding: 0 1.5rem;
            margin-bottom: 0.5rem;
        }

        .nav-link {
            display: block;
            padding: 0.5rem 1.5rem;
            color: var(--text);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .nav-link:hover {
            background: rgba(47, 79, 79, 0.05);
            border-left-color: var(--sage);
        }

        .nav-link.active {
            background: rgba(47, 79, 79, 0.1);
            border-left-color: var(--pine);
            font-weight: 600;
            color: var(--pine);
        }

        /* Mobile Menu Toggle */
        .menu-toggle {
            display: none;
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            margin-right: 0.5rem;
        }

        @media (max-width: 1023px) {
            .menu-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }

        /* Main Content */
        .main-content {
            flex: 1;
            margin-left: 0;
            padding: 3rem 2rem;
            max-width: 900px;
        }

        @media (min-width: 1024px) {
            .main-content {
                margin-left: 280px;
            }
        }

        /* Typography */
        .content h1 {
            font-size: 2.5rem;
            color: var(--pine);
            margin: 2rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--sage);
        }

        .content h2 {
            font-size: 2rem;
            color: var(--pine);
            margin: 3rem 0 1rem;
            padding-top: 1rem;
        }

        .content h3 {
            font-size: 1.5rem;
            color: var(--accent);
            margin: 2rem 0 1rem;
        }

        .content h4 {
            font-size: 1.2rem;
            color: var(--accent);
            margin: 1.5rem 0 0.8rem;
        }

        .content p {
            margin: 1rem 0;
            color: var(--text);
        }

        .content ul, .content ol {
            margin: 1rem 0 1rem 2rem;
        }

        .content li {
            margin: 0.5rem 0;
        }

        .content blockquote {
            border-left: 4px solid var(--sage);
            background: var(--light-sage);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: var(--text-light);
        }

        .content hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }

        /* Code Blocks */
        .content code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--pine);
        }

        .code-block {
            margin: 1.5rem 0;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: var(--code-bg);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--pine);
            color: var(--light-sage);
            font-size: 0.8rem;
        }

        .code-lang {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-weight: 600;
            text-transform: lowercase;
        }

        .copy-btn {
            background: transparent;
            border: 1px solid var(--sage);
            color: var(--light-sage);
            padding: 0.3rem 0.7rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .copy-btn:hover {
            background: var(--sage);
            color: var(--pine);
        }

        .copy-btn.copied {
            background: var(--sage);
            color: var(--pine);
            border-color: var(--sage);
        }

        .copy-btn svg {
            width: 14px;
            height: 14px;
        }

        .content pre {
            background: var(--code-bg);
            margin: 0;
            padding: 1.2rem;
            overflow-x: auto;
        }

        .content pre code {
            background: none;
            padding: 0;
            border-radius: 0;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        /* Standalone pre without code-block wrapper (legacy) */
        .content > pre {
            border: 1px solid var(--border);
            border-left: 4px solid var(--pine);
            border-radius: 4px;
            margin: 1.5rem 0;
        }

        /* Tables */
        .content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        .content th,
        .content td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .content th {
            background: var(--light-sage);
            color: var(--pine);
            font-weight: 600;
        }

        /* Links */
        .content a {
            color: var(--accent);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .content a:hover {
            border-bottom-color: var(--accent);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--cream);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--sage);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* Section anchors */
        .section-anchor {
            scroll-margin-top: 90px;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .main-content {
                padding: 2rem 1rem;
            }

            .content h1 {
                font-size: 2rem;
            }

            .content h2 {
                font-size: 1.6rem;
            }

            .content h3 {
                font-size: 1.3rem;
            }
        }

        /* Page switching */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* Search */
        .search-container {
            position: relative;
            margin-right: 1rem;
        }

        .search-input {
            width: 200px;
            padding: 0.5rem 1rem;
            padding-left: 2.2rem;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.25);
            width: 280px;
        }

        .search-icon {
            position: absolute;
            left: 0.8rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
        }

        .search-results {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            right: 0;
            min-width: 320px;
            max-height: 400px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1001;
        }

        .search-results.active {
            display: block;
        }

        .search-result {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s;
        }

        .search-result:last-child {
            border-bottom: none;
        }

        .search-result:hover,
        .search-result.selected {
            background: var(--light-sage);
        }

        .search-result-title {
            font-weight: 600;
            color: var(--pine);
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
        }

        .search-result-section {
            font-size: 0.75rem;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .search-result-preview {
            font-size: 0.85rem;
            color: var(--text-light);
            margin-top: 0.25rem;
            line-height: 1.4;
        }

        .search-result-preview mark {
            background: var(--sage);
            color: var(--pine);
            padding: 0 2px;
            border-radius: 2px;
        }

        .search-no-results {
            padding: 1rem;
            text-align: center;
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .search-shortcut {
            display: none;
            margin-left: 0.5rem;
            padding: 0.15rem 0.4rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.8);
        }

        @media (min-width: 768px) {
            .search-shortcut {
                display: inline-block;
            }
        }

        @media (max-width: 768px) {
            .search-container {
                position: fixed;
                top: 70px;
                left: 0;
                right: 0;
                margin: 0;
                padding: 0.5rem;
                background: #1a2f2f;
                display: none;
                z-index: 999;
            }

            .search-container.active {
                display: block;
            }

            .search-input {
                width: 100%;
            }

            .search-input:focus {
                width: 100%;
            }

            .search-results {
                position: fixed;
                top: 120px;
                left: 0.5rem;
                right: 0.5rem;
                min-width: auto;
                max-height: calc(100vh - 140px);
            }

            .search-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
                background: transparent;
                border: none;
                color: white;
                font-size: 1.2rem;
                cursor: pointer;
                padding: 0.5rem;
                margin-left: auto;
            }
        }

        @media (min-width: 769px) {
            .search-toggle {
                display: none;
            }
        }

        /* Theme Toggle */
        .theme-toggle {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            margin-left: 0.5rem;
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .theme-toggle svg {
            width: 20px;
            height: 20px;
        }

        .theme-toggle .sun-icon {
            display: none;
        }

        .theme-toggle .moon-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .sun-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .moon-icon {
            display: none;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) .theme-toggle .sun-icon {
                display: block;
            }
            :root:not([data-theme="light"]) .theme-toggle .moon-icon {
                display: none;
            }
        }

        /* Language Switcher */
        .lang-switcher {
            margin-left: 0.5rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 8px;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }

        .lang-switcher:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher:focus {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher option {
            background: var(--pine);
            color: white;
        }

        [data-theme="dark"] .lang-switcher option {
            background: var(--bg-primary);
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <button class="menu-toggle" id="menuToggle" aria-label="Toggle navigation menu" aria-expanded="false">&#9776;</button>
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA/4AAAEWCAYAAADfFEwLAAAALHRFWHRDcmVhdGlvbiBUaW1lAE1vbiAxMyBPY3QgMjAyNSAxMDo0NjoyOSAtMDUwMDkKRCAAAAAHdElNRQfpCg0VFSBTc4fRAAAACXBIWXMAAB7BAAAewQHDaVRTAAAABGdBTUEAALGPC/xhBQACWDJJREFUeNrsvQeU5NZ5JvoDqBy6qnMOM50ncEiKwxFFiaRE0xIpK5O0ktder99697x97+07Z3fPezo6x/I+rbO9luRsSbZkeW1RsmRJliVRkUGkGGc4sbunc86pcgDw7r1VqL6FAlCoZndPT8//kRhUowDcCxRw7/3u///fD4BAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIxL5AuNEVQCAQCERl+MlPflJR2/3AAw+oN7rOCAQCgUAgEIgbByT+CMQugeQLcRAweM52224XPX/4PCIQCAQCgUDcOkDij0BUCB0Rs/MOIeFCVASLZ6zSZ49C1a2LPuPziEAgEAgEAnH0gcQfgbABEyJWjoQZES22RrKF0KPMM2a2BpO/zZ491WAbAz6TCAQCgUAgEEcXSPwRiDLgCBm/NvqshxnhQrKFKMCA8Js9b4LFPkbQP3OqybbCvvg8IhAIBAKBQBxNIPFHIExgQfj1C+g+mxEuJFuIAkyeL21tZzE6lsLO82f6XOLziEAgEAgEAnH0gMQfgTCAjpQZLSKYkzEKjUgpJp+RbN2iqGBCSf+cGT1z/Hl4GD1nCuw8g/o1Po8IBAKBQCAQRxiOG12BmwXprCq4HAIOhg8Au7nXe/X7mJAyPfniF/57HjzR0hZ+O/tcW1cvrq2uKIC4JVDBhJJo8Vn/zFkRf57g6xc5fyz/fLJjaT2R/CMQCAQCgUAcHaDF3yaQ+B9u7MXvY0HK9GRfMtgmcqfiSZfMrbXPhYUQf9CI/2EjWvjM7x0srPx6cm+06J83/WQUf17ezZ8n/UbPof6Z1HsAHLpnEoFAIBAIxI1BpWmseeB44nAAib9NHAYStMs60N/4UL5sh+GeatCT/kAgKEajEZ6QSdyaLg4wJmQUPNmiS1a31k8AHEqidZh+n5sZFUwoGT1nksF2K08TCr1rf7lnkX8mkfwjEAgEAoEwIvrl/uaBKYQPIdDV3yb2mgARUiWSc1bk4r3LOhzaF+ygSOXHPv4b4m998jdN77UBMeNJP0/AHLpF28YTf40w8URLzK/1UMFYlO2wkO5DO2l0M8DAym8WMiIZLA7dmp8EEKE03l+DPqafJ/bZ/Dn4Z1LfaStg8kwiEAgEAoE4+rCZXlj/mYc2vi0ZQ5BzszVOANwYoMXfJvY67vx73/+x461vfUCu5Jy7mSw4zNgtuaXH0bXdY7Vy9OVZWWL9fr8jFovRzzzhd3JrJ/e3Rsg00N8om18ytAq6tfadHE8kwef10G2MrGkNodW9OSSTArbu+Y2ux42CDSs/b8HnSb7RYuVhos8mwS+8Sz//POqXwvMIxt4o2EEjEAgEAnGEYYPsW2Ui4qEarDGt9SEBEv/XiZuV4JjV+2a9nkpQJt5ab4Xlyb5LEAS3qqr0bxfskH9tXwqNcGkkKwU5wp/iPvOESyNmhYbxRjWCdn97fgJqv5+Xm/F5NPIggVLSryf8ZpNK+gkAo9ASDUYK/ry1nyf7aW7hyb82AVAUhoIdMwKBQCAQRw8WhN8sbXW5zEJGJN8wgxCgceHAgcR/H3EzkpajDD3hn52bl9paWzR3JI1I8W7VGgFzcYubWzTyzxN/ZTgy3XJ9e6YHBCnxSPu5J0VZiJDtSW7hyb8+vrosycLn6vAi/4zpXfv1E0o8mXfqFheYk3+e+Jdz8dcTf43c84Q/pftbmxwwivnHjhmBQCAQiCMCA8Jv5alotE1/nAb9eKRcCmEk/wcIjPHfRyA5M8dBkleTxk0gpJ/+zZMzfSw/T/g9kCP7Hu4zXTRyJqYg6/3GxNNvn04sP+KWXA4VFPXzw6u3/1rPL/wPKFVX5z9rdcLn5SYGR/r1naNG2DXyrj0zGsl3GSxm4STseXW73Z76hsbuQLCqw+P2tDqcjnpJclSLouAXBNGbL1tWFCUiy9m5ZDJ5eWVp6YeLi/OjUBoaYKbqry34bCIQCAQCcURg4JnIfzbSI9J/rlRgWFuMUgizYzCN8MEAif/rRJlY7EMbk3+jrcY3gPTbSaPGu11rhMzDLV7dWrP6Oy6sXx/8yeL5x0ASa5wOJ6H8Kjm5IKynIg+CJPwFyOoKlKqp0/L4xtAWwcIJpcMFk3h+Myu/mRcJ703CW/4L4n5VoXBtc3PLXYTs30aI/zHY8TIxgySKYlgUXWGn03UyGKx6vKWt/Zmx0eE/3trcXALjjlnO1xknpBAIBAKBOEKwGBPbTS+8G4FhvdCwdox+AgDJ/wEAXf1fJ240gb6V6l1Jnc2s/FA+5tqI9Hvzi49bM+KfgmzgX6affcdUdPmsSGiWyyFBfVUVRBNJiJAlnc2o7+p48//ZH2y7TPaPkiWeXzSXf83F2ra7/14LTe7idzi0E1oHjTKkX+9BwhN+t27hJ5IKpF8QBGd7R9eZuvr6+zweby/sQZutKMryxNj1/3tpaXEcdsJP9BoUWrw/xvojEIhDCSQJCIR9WIgOG5F9fWphu2mFjcINsyZro7TWOM7YZ6DF/3XiMJDnXZK6m86StwvSbyXeZ0X6eTKmEX26+LnP3tHI3PEfLLz8zpSaqRcEEQbaWqC7uQG8bhe8MDTKiL8kSjAbXQwT4k/PpxF9I6E2zcJ66C3+SPpzsCD9vGu/kZVfHzbCh46wfURRdHV2HT9bX9/wkMPprN/LepNzN3Qd7/md7cj2rybi8Wy+jlqqP6uZfAQCgThQGOQR1yDovi/pF5FAIBC7HhPrRYj1i5nQsD6VMJ9RiE9tLXCfi4T+cEJvf4HEXwc+VZz+M79N264/lt/G76s/D7dPifXUqlz9OfRllKsnd6xqVT+z78zOWe54/XH57wVeHb6S+250r+nfY+OT4sz0pBaXLNTW1UuE3EA8HhNcLpeUTqdZYyc5HA5QVQfZUVJkmbpEMyuroiiUoHlkWfBKkuoRBIGRfVVVNeLvp9uenHvxLZc3J+4VRUmibv09LU3wxsEeSGeyrOVyOnKvFtlXUAS1BnSWXMg3nKQekpzNym6PR0wlkyqpr1BHFnI9Spl7p90HTWBFtfitwWqb/rkxe+6Mni+j59Ds/GbPg/55Nnu24BDBRLnfKCOEfjKJJ/xeMCD+zS2t/a1tHe8hz2sTVEa8yWOqZrLZzHQ2k11WyZ9Op7PR6XSVhAVIktTe33/iVy+cf/nTUNqRGyn2Hqr7j0Agji5MVMb1n/UomQDQ8oVTIJFA3IqwkVrYSIeIFxR2GmwzGjNQ6F38+WxCdP80lE4SAHeM6SQeYu+A1hybuBld429W7NaV/blnn9L+tMqdrne/NnLBpoSfkn3N2k8Jf4Cut7Kxhq9PPf3ujUy0QxREUGQFbu/ugtt7OkGWc1ydEC54cWQMRueWWKz/uYaBv35Tzanvka+284vm8p+QJEdalrN6d3/lTW++/4aT3T0ODzgy748N0s+LQ2qkXyP3WthICfH3en3VvX0D7wkEg2egsrZZSaWSl9fX1n44NztzIZ1OpbjvhKqqULjrePf7AoHgQ/x5yfMdv3Tx/PuikcgqlM86wTpmHDwjEIj9goFlkv9sljqMh2q1xvYLcSvBhv4QP2YxSi1stObJv1GGIb213yqTkBZWiJmEDhBo8UccOlRKEGnjlif9dqywRmnUikh/fqFk3ws7pD8wF19p/5e55z6QUrJVjPQrMtwz2Ad9HS3kswqCKLAmi3B99ncOZLskNkKxtb9g8Sek3zAnKrmeG97g7SVRv0VIPz9DrhF+I60IfmGkv7Wt43Rbe8cHJEkKVFAdNZFIvDQ3M/3E8vLiJOx0mnz9hO3trbWLF179XP/Aicnauvr/Lb+deqN429u77r929dLXoTReT7+guj8CgdgXWLgiW33WQ583vKTN0jwAkFAgjjpMxir6DFb6MTFvsODHx/yYWTtGOw//ThpZ+x3c/nrPALMFxxr7CCT+tyiOggW2jICfUQNnlkatxAWbd+0HSvqT611fm3r6vYrI/gaVEPvbj3dBf3vLDsnPryRRgHgyZ3TNZjNKl7vpKuw0nuVcpY5kg3fEnjcrET+9OCRv5ecFIhnpJ0TfTwj5O8PVNfeAfSu/ms1kpufnZz8/OzNNRSN5IT4VSp9/Vs/hoatP3nnX3ac9Hu892nX4/P67yPobYE76EQgEYl9QRmHcagFufyPCb7aw/TCGGHGUwaUWprASszYzgvGhqfxEgKHF3+lyuWtr69oCgWCz2+2pczgdQbI9m0mn59fWVn+2tLhglUZYn+rvSI6BDxOQ+NvEzUpajgLhMoJ+wBAKhcWtrU3tb6sUffp4a72QH13zYn7+qJJs/ObMM++VBdWvFXqysw3u6OkCWWFp+0Clt7hA/CXYiMboVgi6/cvN3toNGm4NxjnZD62Q2lF9dnaDCkg/P5nEP08lWSEI6a4fGDz1YY/H02G3HqqqZslz/jVC4r8qZ7MJ2CH9dNE6VKO6sWduaXHxG51dxzTiDw6How+sB9YasDNGIBB7ApuEXzRZG7n861OI8cSi4DrM74/kH3EUwZF+KyOYWWph3hCmnwAojF8FQXA0NDR21dTV3+b3+/ucTlc72VaaXpiMoMPVNR9pbW1/eujalU/F47E1KE3tJ8FOGmHe4s88dPAd3Xsg8d9HHGbidFjrVQ5mVn5ChuzEWxtZ93nCz1tl2ULIfui7cy+8MyVnqKgfJV7Q29IId/V1E9K/E9PPO1grqgKxZAockgQdnsYxsskpO4WwqEAcZLXI1R/MLRp7ms7vRuNmqy+PCkm/9nzpJ5EK2SDoUltX39Xd0/cRQrxDduuRzWbnp6cmPr24MD8EO7FyGunX4vBBVzcn7HSm0vzc7HBHZ1eUPMsspEAUxSbdtZl9RrVdBALxumEjpZiZ2riRVxKFnvSbWRIxZzjiSMOA9JsZwYzGxEZLEemvqgo1tLS1v5Gsz5KxSxjsGasEj9d7/8nTZ+pfO//Kf02nU7yxgtZDI//8u4rYRyDx30ccBrJzGOqwVyiTksQu6TeLtda7YjOi9tPli+fmYisNGunvqK+Fe070MXK/g2Kevh6JsUB/uv+avNX9qWtPfCyWSnqqXL7r/+nEo/+FbC+nog6EGNLt8o2830fp2dktbJB+vScJP5nkM1g8La3tpwn5foyQbrfNaqiJePz5a1cv/0UymdiAnAAfJf6aMI7ezZ9PJaiBXYeqKiqdQHA6nX1soyC4fD6/Nx6PJfn9DD4jEAjErrGL/ttobUX89bnD+YVHEfm/0fcFgdgLWJB+Myu/UaYhXoi4YO2vq6vvbG3reNAfCJwCXYYguyBjjhP9gyc+cum183+Vr4Om9G/0XqOH4T5CfP2nOBqgVlSzlGPa95We80v/oO7qBTFK0celbTPaX/rYx1WRru3W93Vda3aHEGj7Wp7PgEBYXY8RaJq+9o4uU2VSp9PliMcTBfVRSZKMLPx6lf4gIT41/zLz3Du/OPH9//cL49/5D0vJjU6yPcQWQQgPbc30Qp701wT9cP9tg0y8rxjFGxZWN0BySJRUwUY62qQKos/v8YlxJd2j5sTbzKwYoK3XVldKUyLu/G14r62e4b3anv9OSn+89Pejv6nd94R/bso9i7t59/YCFZB+/aQSrw9RyAhBt3cdO/6mzq5jH6qA9Mvra6v/6/yrL/0hIf1UfT8GuYwQ2kLd/TU1/hTseALwkwJFGSPIsxzlCyAdMk4AIxCIfYNNrymjcCn9ZKrZhCqvnaK3Vuq97IpIhs6LEIG46WCD9JcbqwTyS5D7HAiFqzvP3PGGf9c3cOI/E9J/BnZJ+jUEAsH3kCUMpTpXRuNgfC/3CTjgy6OcdXM31s/HHwP1ox96/XXJ/21Z/m99UlB+65Ovr762j3Xs1EXb1+oYl3HdbdePNmoz05O8aFkJ+c9k0pLP5y00JrIs8+5MhqSMujt/fvRff2UzHb2LBi2phKh/derHTf+m5+Eng5IXLm+Nd8cyCR8haawelPSXbYtILTcTcRb3z4IAVDppoIAokaoIqhiXE34fOC1Jf36tcukJ8/e9cI8N753lb1Dh81D2fSDPm8Exil2Sbue52U299wplBqr6QSo/OOUHon7us6e3b+DB+obGt4HNDk1RlPjC/OynpyYnXoBSgs+ngNTc/LV68sr+Wr21GLoSZAluxD1GIBBHGyZWfjMLvz6tGL+YCeLybv6akri2ZKCY5OtRyIKCLv+ImxVlSL/RWMVoMq0otbDD4fT39PY9VF1T+2YyNHbuVV3Jufxt7R1vHrp25Z/BntYVWv73AUj89xGUCB1QURWXc6PduO2WX0EeUv1gQS/kx1sKmAX2BwuvPLSVjt1FiL2g5puXDKjBf5392bkPdr1taHhr5jgl/bSipzs7IOj1Glj7NdBIf4Ep+m9FY7m4f7J4HA6oDoRgZTsCqqyqHsmdgqwiQfEAaE9mN61i/82+2+vn4EY/V3uBXcT0661Rfm7tpZ3dwODJR0gneo/dOsiyvDoxPvp7y0uLI5Cz7Ce5hbfo83GrAuzMyNPPMhjEulL3fq4oJZlM0HPqla8BsMNFIBC7hEUsf7m+2yx3OD8BwPeZvHu/Rvh5N2J9/8oLiPHhAgjETYUKSD/v1q8XHS5KLdzQ2NTb2XX8UafTWVdhdVQqPpxJpxeyshx1Ohxhp8vVDLqxrc/vv4OsvgXmpB8t/fsMJP5HAHtNtg6heFwlgwZ9ahKemBVcr5NKpuHSxvjPC6IgUDLfGA7C0sY2I+xT0YWWqJpaX0ysVTFCr6hw8lgbc/enbv+gGk1C5toqSRRhMxZnX7+htxt6WhvhJxeugKLKEHD5FiVZTanmjd3ravQO6jcj5dxQ7YH9xOtw79eeryJLvyiK/sGTp98XCoXvsFuHTCYzMzJ09be3tjZnIWfp5639aSi29utj+7XPvFhOUUorUqcqrSxVUbZlAigl/IbeJWgVQyAQ5WBjwt5IYVwfg+zULeWIv0b6tTaS96ajwHzhiCMDA6HrSvWtikJkyLjA29M38FBtbd39hgr95lBTqeTE2urKs/Nzs1fS6XRK297Reex0W3vHvwUuRMDpcB4n5xdVVbUyfmGc/z4Cif8+4qAI9F6X83rOZRUvVylpsGjYjGY09QMGvVsTb+0PPL1w4W7C4X3sep0S3N3fA09fGoLteIJcv1t8eXWoI53NgCBJcLy5gYoG5GqhkX4q3icIXEuVU/ZPZzLQXlcDZ8n5XA4HXJ2ahS1yTqoFeLyufVFRFBpVwF+LEem3bPQqteq/3t9Uj499/DfE3/rkbxp6mRzCSSPbeB2Wfr1rP1tLkhQ4ceq2x4PBqhN260D6zJGrVy79TjwWW4Ed0k8Xffw+T/p5sg9gQvhhh/gXZvIVVVk22Y9H2VAjBAKBoNDlEC/noceH5BmlFitJJQY7lvxcAQLrb2RCJDTSr+3LE3+9+B+mDkPctNCNVfjQGf7dMkstXKKL4fF6awYGT37Q5/P3VFANlZD8aUL2vz4/NzPMbS/UbXpq4tWamtozPr//rPalKEn1DofTkcmkzca+JdeK7+XeAon/EQAhWhUfs5cEzYTsG73Ahc9UqK/7eJedEAWzfKRWeUiNYpl4wbXAUnr9hFbFEx2tEPL74C2n++Fbz78KgijAxbWxMHXzVxSVfb+D/C0ThJJqZhWZufqf7e9mpJ9ifn0dEuk0O2ygqTsgZNlxou56LBu+/fztdlPOJz7xCYEQ//0u/kCxR6S/YOmnafpOnj7zi35/oM9mFdRUMnn58qXXfi+VSlLlfkr2eRd/TcWfDmy1uH7exZ+vt6kWRCgcDpGBsk/7W5blaSjNfw2AZB+BQFQAG679RkJ++v7brVvz5L+QQ7y+obGzpqbuhNfn7SQkolYUBRfpqxOETExtbW4+MzU5/pySS7drleJPAbQsIm4ymJB+3oNG75VoJYrpDVfXdPT2DXzU6XTW2K2DqqrptbXVfx4dGf6+osjU00Y1qBObnIvFokM88aehj06nw5kn/sAdZ3sMjHh9QFV/Dpp6vqZOrv1NLZxGomWcMrmo27dIYd/smLwSPztWK4Mvx0DdX+LrxpVtdU0iVdU3KEOwPIavF1mM6kMbILowEr8VcZB1Uex6KBQWG5uaebe8AsmNx2PCwuKyRBeq2L+6tuHgr80gdokd7/F6C+I/GUfWnc1mPYIgkkXg3a0DuqVIqZS6Oq+noo1AOK0iK9DZWMfE+Kr9ATjX38Nc+xXyH50ACPu9UBcKFq5Zf9O0Oy+TQYZIPQAEkboyse2b8SjzIKDnPt7YoS4tL70COuuHmFMOJPdDEglZFF0uF7vX5L6J2j02/I3yVeGf2TK/aZGKvp1sDJT065/9j+WehbKDpNwxauG5yx9n+rzly+Gfb9N3aB9h5pJqJ6a/YO13OJ2hU7fd/uFKSH8ikXj14mvnf4eQ/nXIEX6q3s+7+WsWfy1+lXf111z19WS95HGtrq7t5DdkMpkJMPcQACgNAUAgEIgiWLj2m6n2W7WjfL9d6LsJeWjuHzjx3rPn7vnvPb39/62mtvZdXq/vNkJYWiXJUU/WHT6f/y3NLa0fu/Ouu/9HVVWoEUrV/S1T6aLCP+Iwo0wIDT9WMcpmpX/H/I2NzYPknfq1Skg/GTPMjY4M/X8jQ1e/RUg/zRBklGGoEJJIsK07heB0uWnd+MkCxAECb/g+Yq8ts3t5vtd7LhO1XqO1HmqZNeiO189omimU8qqkRkthcJFSs42fuvrEB90Ot+B2OODR+86B5rQvSgL8y89ehfVIjJV6pqsDTh/voHME+QrSPVWaEy33F031ByxWmn3OefHntABeGhqFazPz4JAkqPOHoh9oe+CTLlWaJztskmWLLLRB1AgeL9omBwJBNRqNMEJ31N2cbnR4gIlATrnBqj5lH/vbSUn/6ds/4vX5jtksXo3H4y9cvnj+U/kOUutE9Qr+PNnnY/K1Ouvj+vh3Q7OaOU6dPvN4VSj861rZKyvL//n68LWnYGdiIQk7ngX68pSj/iwiEIjKYIOMmFn53VCaS1y/zUna0upjx7ofDIXD9wiC7TSolKCMXLzwyn9JpVLaZCrfrurb1MLEJ7ZxiMMK3VjFTH9Ir9pvNFbxtbS23dbReewxURRdNosnY5XYS0NXL/91MpmkYxVeYFg/Dil4IBzv7rm7qbn1P/EnunLptfdsbW0uwI5nIx/KmIVi4WJ8J/cY6Op/E+GwxE4bdPT8ZyuXHSOyXyKyU1tXL9A89mA9iNAGD3zj5o15lftfmr9yNp1ITt7XdGbII7oU0AmarGcidRJh+FTIz+d2MWIuyzmvaUVW4U2DffDNF16l+dTgWFMDCEVifmqhwqLm7q+qoKX80y57aWMLplfW2ESA3+lRu72tPyKkPw2l8Y6GIn+E9B9URogbjkNK+vWxckaz50Wp+3ZF+mOxZy9dPP+nsixrpJ+38muz5pqVnyfhhdhUKH7PLAUj3R5PP1/+yvLSVSh2feVd/k1F/hAIBMIiRKqctV9P9j2gI/6SJHmPd/feT8YDD1LhsUrrRtrjvt6+wUcvX7rwN1CaFcCo78U2DnFoUYb0G71fRqSfEf/WtvYzlPTTsBmbxSubGxvfuHb10ldUVS0yUkGxuDA9n5Jf5zWFJL3npprJZFJQOr7A9++AgMTfJnZjlTwsRH0v62YRx2ek0GlE/M2WwveE9AOUxsFri9EggjVwiiBU/f3Fb783Jid7yNXdd2VzInpv423fv7t2YAI48i8Jol8j7T5PqQGhOuiHhlAAtuJJ9jlDRc+5qQnq1i9xRJ+q/QtczD/9/srkNMRTaTY5EHIFZu+uGbgMxQ21CMUDENN8wyhusj8oQ/r5Z6yctZ+691edPH2mItIfjUZ+cvnihb9QFCUC5S39RTPg3HmsBDBLXFmdTtdt2s6yLI9tbqxvQGkcLHbCCATCEhYCY2biu0baO/qFuebXNzR205Rirlw6sF0jEAz+gsfjeSKZTKagjJs/AnFYYRb6CvZCEYvCEZtb2k4T0v+oXdJPRTOXlxc/N3Z95EdQrDekecsAVxfeYMXeK8nh8OrOl8xms/R4KzFhxD4CiT/CNixc+vSEw4z868m+lYURwNyCYOh6/YO5Fx8kpL9bFETmkU8ODj6zfPF9i/HVS+9uf/Nr+X09QYdXZWRdzKXfU1VdO6MKhPiHoDEUhkx2J3Mdy+ZH1ik5Cz7OO4pa+wsXSc55eWwaFja28vp/gnxP3cmXodiKbEX69Qs2gvsAGxkjrIT8ilT8HQ5H1alTZz7s8/ntk/5I5IeXLp7/S/Ls0VAPo3h+I3d7M9Kvn3QzJP8trW3HyLNaiOVLp1MvwI5GgGUmgBv9eyEQiMMDnXK/kaq4XmSMb0v1IXgF0k+t/D19Az9fU1N7fwXWSFPQ9o4QndsmxkefBmvSj/0t4lDCxKvGyCtR84A1MlCwMUtDY1NfZxcj/U47ZauqEp+dmfnMzPTki1CqNcSHHGr1AChuDwSnwxkoPqe6IcslxN90rIFGr70HEv99xI2OXd7LutnIy2tEZkXuGCPSb+ZiDLqyrNwGC43campzgJB+gRL5Kp8XthMJkMjfY7GF2/5x4vt1v3js5y4JpB0i+3gYWVehEKvPd/nUmb+toRYCHk/RPaC7KKoCWRoWYNBs0sNnl9ZgdH6RTSbQc99Z2z1e7wln4nK6Jq6mXEHRK7gFxzaUDkLMrP44GNljGFiqjMRxzGbQi1zmyEA1ePLUmcd9fn+3zeLVSGT7ycsXL3yWPCOaMI6e9BvF9Ost8Ubu/WZhJOw9rK2tP8fXY3t7+1mw5+bP9scOGIFAmFgf+QntclZ+rS0tsvSHQuHmnr7+X3S7PZ0VVagMAsHgKbJ6Fswn17G/RRxKlAml0XslGpH+gqGiurqm49jxng+Ssa8tnQxFUbanJsb/YGFhjnqrat6IBdE+2LH2C7Dj2s+P1+n3gsPpKBIOlGV5hSx6QWJ85w4QSPx10Agxr2SeJ8imHYKVMrpVOfz5DcqzfbzVMXm1d9XOvlbnn5meYkr8eTf8EsIkORwOOZvVW7WZaj2XVqeI9BPStEM6BEERdtY0BoiP8S+QfnI6JyFMBUJGPheIWTyTaqCnp1b8d5w9A+dHJ2FkdoFUQoDF9HbLlyd/6PzFYw9NuAWn5HN45XgmKaXSGeaOT9P28agNBovc9zUsR6PQFKwq2c4uSlXgwsQkJDJZts3v9sBIZLbrxeUrPTmvAJGUBWpHsPnJR7se/KySSUf5+0TKYwv9KEqSmEwkDOP8zZ6dcr+r2XNq8exYKv6XK0urG7+2Kkf/Htgpp1KUUZ8upzxd1JGS38l/4tRtH/AHAv02i1cj29vfu3zpwuc40m/XvZ+fFDOL6RfBnPwLPp/vvkJFVHWDdOrnodjab0b+sVNGIBBm4VFGYXj6NpRvR0tIf0fnsbtaWtveU0EsPx0jrMWikeFkMkmJREKUREd1de2dHo+naBLW5XJ1cHW1CkVEIA4NXsdYhSf9bB0IBBt7+wY+TMbcPjtlK7K8OT4++jvLS4vDsGOc0I9PeGu/Vs+SkEGHw9nAnzubzU6BcWghehoeEJD4c+DJiQHhKCFY2v52iFM6S9OZfYIeqxid3845+H30++uJFSX8tCytPD3018Afoz9XvgHShPccVHjP5XZLqqKKqqpI5EWWCOnXGiJ+oaSfV71jpIJ07nRNJ/00YiODzrLpdrsF8r1Kzs2IvyhKpIFTneR8RhZ/ms7Pl1WzNbTpqfJ7wO1wwj2DvVBfFYSXRsYhS0j5Ymqz/p+nnnK+r/O+xRqHPxXPJn2JVNqQ4NPJgh0PgHyrS/6JpVIgVAkl4QF0/xevTsBmNMH2lcn32wnaXoJTFCQWPpDP3CdMRZbe/rmxb9z3YOPdv97hrr1CN+YnR7Ti2Jo01qLb41F8Pj/9bUx/f93vbjoJUAmJLucRontuBLPnmV8bPKMl74/Rc11p3W1gN2n7ijpS+rwNnjj1nmCw6pTNMs1Iv9ah8p0qL+RnFnNvNgA38roRmppb2iWHo5BeMJVK/SibzWTAOLc1ivohEIgiWJB+M10ULWbfa7CwftvpdAb6Bk68OxQKnwWbRJz0lcmV5aVvT4yP/kzhOk6g+kChlasnT535GO/KTMYOtdy5zVz8cRIAcRhR6VhFH47odbs91f2DJz/scDrDdgokpH9rfOz6by8vL41AcdYpo9h+jRtoBroSIu9wOFr486dTyetgTfp54PhjH4DEn4MVudgNkSomNL9JHvLf3NM6We1nRvit62g8KZEHa4DyavtiOpXiZx+dBguvoKt1quxFJ321Rmqy3JpPq6MQYqJw5UrkEGbth+KBRVGjF8nEAm6nBxrCoVxrQch3d0sTNFaH4AfnL0M0mYLJxFL4ueXLSou/UZ5NrEE8nTa8Lyy9n7BTAXq+1WgE/G43s+xDIQGgyjwGXrw2Clenp6GjoR6aasLMY6A6GKBXC1kmBijA+MIynB+botUSthJx35WNsWMdTTniD8UDEYZoNEIF4NQ1WFG7j3ft6jnYLSp7tnf9jJY9bi8Jf4WquGYCOexz/8CJh0Ph6jttFk1J/5MmpJ+39NN3wIz06639VlZ+3uuG7dfY1Pzz3LHqxvrqt6F0wg0t/QgEogQ2SL++bzay8hcRf0L2W3r6Bj7kdrtbbFZDJeOCibHRkb/b3FhfBoPMJttbW8uZTHrG5XIf1w4SRcEL9toydPNHHApYjFXKeSUWEX9JkqoGT556nLxjTXbKpULDExNjv8uRfn0KTG2crr0n2hjDUKibjJHC5P3jXWTVra2tS1DsXYjGhgMGEn8Ohzkm/5CgnMsRU+TlFo38FwgHFFv4NaKT1S18Y6DNJDpIo6QXCuJjB32qqojULF/j9xeqS+P1A14v/MIb74TvvfwabMRi8OLqteq3tN6RIPtDOqNAMp0pVumH0ul/iZx3fmsbeurrC5SflUC2XxyfYQd88K33gs/jgYIRgp1IYpUFJTcJwYg/vchsWm3x1s2DubVhV+EjB/H8ap4h+13OXsKmKq5VDtzCDHpPb//9NbV199gsmsb0/4CQ/s+WIf1mMf1G97mc2E+RtZ/Gjni9voe0gxVFnpwYH7sIxtZ+PqSg0JljfD8CcWuiDOk3IyJGZKRg6W9t67itvaPjA6Joz/WYtJ3y1ubmd4eHrnxTlmVNGAx0dWLtYjqdnuWJPwJxM2GPFPypV6J/4MSpd/t89vSHyHg4OT01+UdLiwvXYIf086mFtTEKb5Rjh4KxRyJU19R0sUFwoQx1a3lpYRKswwvNzonYIyDx30ccsYkEI0E0viHSC/i4JEnykE6a75R54q+Rfv3Ckx+9Yqie9BfiBBVRqCInFmVZgepQoIQ1Owixf+Ts7fCN51+hafaEV9eGfU6Hk/xGGYjE4xAOBEoulMdqPMq+CLjcO4KA9GIIoT99vB20TaqssokBlY8ToP+IArw2MpWbFBAECHv8Q3dU94wXeyqWWv3BwAph9kzZdc3fA9xUz7SJgr+R+nTRRJLB4u3oOna2obHpQbA3MUM9Nn58+eKFv86r91dC+vUE3Cq2Vu/mX0T+j3f3niXcX4uzU+Px+LegeAKOV/Y3EtlEIBC3ICog/fxEPE9EeELiEQTR19vX/2BtXf3bqJ6NnTqQMcTm3OzMZ2dnpmhmHo14qAb1YeMMRVaiRSdQC/HI6MmEONQoo+CvvW9mKYaLxio9vf1vC4XCZ+yUS1P2zc3N/sn83Ax9x6w8EvmxAS/graHIkBUIBPv5vzOZzHA6nU6BeXghvp8HACT++4ijQPp1aXvMOn/evY91+i9tjLzhuYUL/9Xr8CxWOwMXzzWeernD17AEuZdcs+xrKcu0tZ4EaaxY5Mrh8/0Wlu1ULEQV/alsQC0l8QW6zFvnRXj43O3wT0+/CPF0klnrqZv+dixZRPz1oPssbUeg2usrIv35kxbS/BX5KfEbyD5jc0twbWaWxhvS7cn7mt7wl7r4xMIZD/L33c2EwAFOMLxuWCj486q4VjPoBWt/c3PridbW9l+A0s7OCGosFn2WkP6/zFv6+Vg5Xh3XDunnYeVuqyf97NrD1dXv5KqVIQPob4E56ccOGIFA7Ib0m7kcs21Op7Nq8MTpRwPB4GmbVVDTqdTIyMjQn25vbdKxgxYGVRQGyNUn712oZvmTKLlJV3QnRhxq2FDwL9G2ApP3raPz2Nn6hsa32CxaWVle+pvpyYnnoNjSzwv6GY3JeRiJZ4LH4z3B75RKJs/DzhjHSNm/aOyBnob7A1szrojdKfcfZuzieozS9+gt/qwhEkUx+NLS5V8XHFIooWb659Mbj31l8kf//YeLrzxCyHY12YcuYW6p4pYgWSgLL8o/CqXCQEXKwCuJ9aCDkGpC/sHldBS69Zztfcd53y054VxfzvOJCvRRF//NWMzywrdSSYhnM1DtK/VKFPIF7aR92BlbCPl/1rej8NNrw0zcT1Wy6Tc2Df5Zn7913OD+gsk2QWe13jPshqR/7OO/YdpuHCbSz8Ho2a0kVs5bU1vX2XmM5b+1M1lKreovXr742p/SmDmoLGWfWTo97Tr46zGL7S9Yv2pr6+pdLnchLCGdzjy1vra2BqWk33T2HTtfBOLWgomXlJEmip7087nDC4vfH2i87cydv1YJ6Y9GIj+8cOGVTxLSPws7hERviSwRRRV0ar2KIm+C8YSm0d8IxIGjAgV/o/eNN1B4Gxqbelvb2h4BmwaKjY31r41eH34SrMcpvJu/XnOIJ/0F8u/xeulkX5+urOfBeNyBwn4HCCT+eRQr8KtCubRi2vd2CLT+3Pm1aPS92f5262vnWP159IvF8eyFdjgcRjl7GXmiaufj0fnuuJxuo5ZwRrvJB4focL+2Mfbo34//4D+MxRaoErqe/NMlBLoJAHI+ui7ELIGJOnBWybJQepX8TMVWeaEoJp+ip7WJ/J5SwShP4/7N7Ox089L2NgsVqHJ72Da1ZA8o3a6y4GpYWNuAb7/4KtBkfuQ+JO9rvP3z58InzhsUo18LPp9fCIXCbFt7R1fFz4T+2TD77a32Nzr2tz75myq/r91JJKOyir4zONfrmXDbpZhficscTYXT09v/IVGUPHbKTSYTF69cuvBpWc5qpF8/WNU8XKxIPw/e64bvYPVkv0TRv7W9412w49mlbqyvfQWKRf2MXPzR2o9A3KIw8JLSuxwbhUbpSUhh4j4crm4/ceq2f+/2eNrtlE/djldXlv/20sXzf5XNZLbAmPTzbSlPTLKknXbx55NlmQoBlptURfKPuNGoRMFfC0csSjNcVRVqOXa8+zFBEJ02yqOhiE8NXb38BBi/Y5pXYpHwNhS/I2ZhhwL1kCRj9sKYSVGUlcWFuXHAFMI3HOjqn0elKuUWaf9snZsXR7NSO7cTz23ns526GX2nc/WnELJZ5klnOPtPOm33dHSxzeV0MgL+c2dOAZ0nePX6BKxGIuJKenPwm9PP9B8PtLzyCx33/kBShdgr68PH4nJCua/hjlcoOQYubYi6kzdPJB+1wYae/LslUXSyHIGKCpmsvJOiT+Wt8ZoVXoCuxjq4PrfEti1tboNTlCBDkw3o7kaabIukUlDt9ZKWifcdMABXCPXif+7KCCljASRBpEdm3t5695cHg51XuL2N3KMKp4/HY4UGcGZ6clfPhN1MFWb7mxxv+9k3Opd+XZRG06KOlcCGQI6+M+WfpwLxd7lc4f7BEx9yOBwhO+WmU6nhK5de+8NMbsBqNFDVd6blSD8PO5b+AvkndXf6ff6Cmz8ZAF8fGx15BUpJv1kGAex8EYhbCCak30gPxWzClPfS89XV1R/v7u3/qCRJQTvlk34zOjc782nS370MpVZHzTVYqxs/fi2ENunLymYyVETXKl84AnHDUKGYH69BxJN+r9vtru4bGPxFSXL47ZSbSiavXr1y6bN5/SEjS7+Vi7/ZOKQwng2FwncDH9+fTr9CuEO5FML4Ph4AkPjvI/Y63ll/Piv3731wzzUTFitpnNaS2x10v6ycheqqAPicLnj43B1wdWIGXrw+DqIkieOxhbOfH/nWsdO1Pa89t3DpbVTmZ3J78bZ/0/PwP+bJv15MROvo9Q0fs/orqupiFXJIsLS+xVLqaUy8ID1K8+iJzPIOjeEQTCyuQkaWIZlKk3WWTQjosRKJsM0hQvxBNSf9rCSVpQ6CiYVleObyENtIST85Xn5Lw+3fJaR/DEqtKPz9NJsIuCGN4UHF6+91GTbdVI3c+4tIvyiKVBX3A263p9lOuYTsT1+7eun3U6nUBuxOyK8ors0kxtbK2l8U39/d0/egIIo1+erR2f0vQynhN5t4wBg7BOIWgoW7sVE/b5b5pEBE6hsa+7p7ej9iV7lfzmaXJ8ZHfz+fSox35TdSE9eUwrW6yfnPguSQavjzJpKJKTBOHYYTnIgbCptifnoDhV40k4bXBgYGT73f5XI32CmXEPD5oWtX/jhbaqDgw2d40q9/V4zqW+AFInWP9Hrv5suMRLefBnsphHHssc9A4m8Th0G0bGZ6isZ685tMiX++QSmq7x69SEazkkVW/6yq+Jmbv0obGBlUl8rU7gc72qC5thqefPUipDJZiKuZuueXrzwoORzsbGuZ6N1fn3468972t9Ac4/pZfq0s1gBuZePN35t74YHlxMbxrkDTzB31A1spOQNeyQHTK2t54l98uSJ3R1rqaqC+ahkWNrfY35uxOIT8Pi4sIKfOvxKLMeJf6/OXCPux0wmcfz7Z8dWRCbg0OQ2iJLLrz8gZ9b7GM8/cWd07BuXJmiX5p7/pzdoY3oD3x+w5LSfmV+hMe/sHfz6vSlsWspxdGRm+9ruxWIy6lWqkX2/pr5T0G12PkYJ/ibgfVcyuCoUfyx8DqqKsjV4f/lcw7njLxdohEIgjDAthsUrUxAvW/rr6hu5KSH8mk5kcGb76u1ubm3NgrCaut/ZDfl3UbhHCIUiSo5E7tULOOQnlST+2eYgDRZmJNrN3Tv/esbFLHxmr+AOBXjvlUt2h8bHrfxSLRalgpl7Ij59o06v4m3kl6MckYlt7xyB5F+u1MlVVjc/NzLwM1imE+XcQ38d9BBL/fcReER2tgfD5fEZkwApCbV09rK2uaGSi8MVzzz5lt3i99bScNcApke43t7MAMidcT+Pvqwi5/sCbz8FTl67C7Oo6E+PLfckM7sJYZP7en65c2ry3/jSNg9er+GrEzfWd2effvpjc6KFljMUW+q5vz4Hb6WHke3ZtDe6V+pg1n4da8AAQmKhfU3WIEP9N9jkaSzDiz++7nogx5/5aLyX9CmhSfjtTA1q9SZmra3B1ag6WNrdyIn4qc61W39R46sLddYPTUDyAkgzWejX2khALOODG8EZPdO0GJnH95dzmSkh/Z9exs7W1dffYKZO6p46Pjf7B1uYGFaEqR/qN4uWsZrit0viZTSJRa/9ZSZIKuazjifgTqWQyAebx/SXLzTrJhEAgdoVyeii8iK+RmB9rP0m7eZy0Px+1SfrVVCo1RD2l4rHYCuy0nRoJ4QkIQDHBKGmzQuHqasL9Cyl6SNu8ur21uQbFscRmCv/Y3iEOGnZDEc00iHxkrHJ3TW3dOTuFEQKenZ+b/fPVleVRKHXvNzJQ6OP5rYwPhfErqc99UJTGL/1yLBaNgLnFH939DxBI/A85+FnB1dUVttb+1q21z0UvTZ708yHufKhAYT+jQb7BjCToytJbU1mj5XI4ZNqEUEKcVZSdAvOu8jSt3oO3n4KXh8fhyvQss6grisr2J2RFeHl96Oduq+5eCjp81Bxv5O5P4/ndrEL5eQNR2qkqdd0XDJzktT+p5Z6S/9aGWrg4OQOymtMF4CHRFH6RCNu/xu/LTxcUS/nRSYvtRBzOj07CwvompKm2AOQEDbOyor6l8fTY3bWDs1DckOsXfjJAb/1XuPt8UzeGBzGJYEMZVy9KZeTi76XWqpbWtofBRmpFlv92dvrTK8tLw7C/pL8c4S+Kr6upqf2wVn+aTnByYtxM1A9j7BCIWxg20vbpJ0tLUp1qS3VNbWdP3wCN6bcTZ6wmk4nXrly++EepZHIddqyPRi7+/PhFI/0lqK6u6SK7FYTNstnsmC5vOMb4I244TN65SoWHffVkrNLc0vYOsJcGWl1fX/vy9NTEzyD3nhmFIurHKRrM6loyBnG7PQTeolSC0UjkR2Bu6cfxxwEDVf11qFSpXH+c9rmS48y+0xOZbCZDLfjs5fJ4vRJ5v3jCaGhBDgarnPn9HT6fv0AsQ6FwkWWZlqV3L+aV5MnxRgIkho1B2B1KUBJP3d2TyZThq0yJ/p19x6CvrQlkWYGHz94O3S2Nmvie52crV+8kn0I/W71896euffX/+MrUj9+lCEz1n1kXmjw1C4zdk3O319WymH0KWZbB53ZR4g2C7taquTQD+ckHgSq3QUN1kHzOpfwTcsr7bN9oJgXJTIaJ/gVc7vzxOz8GqT5cHJ+CH716GaaX1xjpZ/vk9wi4PMpWJuZ7cXWoayy+0BpX07UgirTx1ly3eOJfaDhpbJTuvho9M6JZJgY7z6jd4/T77fbdsItK62cCu7Fyhi5zPr+fqlE9Kgiiy0ZZ6urK8hdmpqeoCxs/e27m3m/o2qYn/RYDcTvWfrHrWPdph9N5RjsfGVz/09bmxiaUEn+jOgFg54tA3BKwSfqL0vWCsYK/j4wp2nr7Bn6JkP6AjaLVRCL+yqXXLvw+If3UIs9rovD5w/Xtp2XWk0AweJL/gnD+K1BeTAzjihEHBhvvnD51n6EGkd8fqD/W3fsBMma0peAfi0afGRm6+g3YIf1Wln6rtH2WosIdnV3nSJ2qCgWraoSMkX4K5Y0OhUPwPdxfoMWfQ5k4ZEpEDNP60W1GCulf+ocnpI9+6HHZokhTS6iR9XJra1PbJiUTicJ2OgmQJSQ1m83qY2TUSGSbnYPsr71cbNZ8YXFRbKivl6PRiKIrlxF+qiKfV5JnZeaPB4fDQVX9SxouQqQl8oKzxqDG5d+mrvE0hd12IgmtJVr4auE1PzfQC9NLqxD0eeBNJ/pgammFhQdc25o8cbqme/3ZpUtvcThc0lxi9dRXJ37ofrzrQTpb6ThbP7Dy4spl1ePyCc3VYehrawaHJDJX+7mVNZDz5fM3IyVnGbl3OXK6QORaoKuhARbXt7XbwuYS6KelrW02OVDn9zGSn4vnz8UjbMXi8MroBCxvbEFallk5bA5CzesDknVKyUhXt6dayJ8t8qpCxQNVSRTkgNO/7REc836Hb/KO5oFL8UwqU+8LTzUJVVRtXVQUhY/xBzAm/6rRc0MnBPhsEXaebatn3krhfzfnyxN5QaujRuytMhDY1Qao0GplKOhHB6z9Aycetangr25vb3139Prw98B89lxv6ddc5+wONK2sAvrQkYKbXX1Dwy9D4blRE9OTE18CY20Bs0EwDoARiCOOCq2OlpZHQrib+gZO/BJpO6tsFK0m4vGXLl+68Me67Cc84dcTEH2fqBc8Zd95PN4zfEFkfPMaWFsZi+p1o38TxNFGhcLDpqGI5D0L9OXGKnbeN0in02PXrl7WFPzL6Q9p74lWR31d9fUtGn+EwtVv546jk2/PGbj5W4n7IfYZSPxtwoxQWZGSxx97TPnohyovy8JlWf/ysb+5SQAeWr30Lxb7OxwO0U5RO0fRS0cIPxiUz87PTS4UfZe3lOdyhwca45lsmtwbN6xHY4xAq/q7xNX2jYT8OySJWdtPdrYzcTwVVPfXp5+5T5IcUlt9NSysbcBcYr3n1Y3hjTur++cCkldt8NZEtuRE1eLmBvMcoFb+mmAAQj4vK08VhYKZnvkGks9UANDj9OVIOtnW2lADoWkvuJxSoWI0PGEjmWDf1/kD+ZupMoK/uL4Jr46Mwzoh/7nRSD7uP0/6acgALZaQSKYdkKGpD1U6YeSkEgaOpJypSUKqZiMTOzU9tvROqgfgkVxL/7H3Pe/MT5yU3HPuMxP4s3jmbKXus/v8mqGSyQKD78qmJay0fjbi+vUq/nrLFcsM0dc/+Hav19dp5x4kk8nL165c/jsqWgOlHanVDHphwGkRXmM1iaHvcHXW/uOnnE7XXYV6JpJfW1tjMUJ2rf0IBOKIowwB4S39ejXxEku/z+evGxg89UtOp7PaRtHU0v8yIf2f4kg/337yor56F3+trkZeUEJdXX2TwyEV2m9KclaWWAhWOUs/Eg7EQaJSF3/9WMVHxiqPeL3edjuFKbK8OXZ9+FOEgNNsQ+W8EvXvHV/fsqGG9Q2NbS6X8xRXvLq5sfFdsB53oKjwAQOJ//7i9cRmW7n6Sro1r3SroYTsA/eyKdTXfscCadQhmmkIGBHSoomJsMsXdUlO2qC4FglhlyQRslktXD13O1hqPc1Vv6GOWfnpt5TAvzY+lSPNSsbplBzwpsE+WN3chh9euCK8sHz1BCH+NB5Q6gt1Lr64PlRFXe0BdvT4HZIjVw4328DU90l5KULE+R/E43DCHd2d4Pd5tJrBwvYW2zfkdoODet6T81Br/+LGFpwfm4Q1qvQPQuFyFEWGhlAIjjc3QEdjHQRZ6r/8LSTHxZJpWCHHrm1HIZpOQSyRhO14AhKZjEA1AzfiW+G8x4Spe78dWJHkw5CVYj9gMIA1ius3UqPmO1Jve0fnHdU1tXfbKZOmnRoeuvIZWc7SWWyjVDhm6v12SL/Rtdgi/cCs/U3/DnZi++NTk+N/C9akXy9yhW52CMQRhs6wYGbF49P28eSjSMjP7fZUD5449VGXy1Vvo+hcTP+l1yjpp6FHRpOm+rh+gOKxjZG4GGv7Ghqb79HF949EItvbgHnDEYcAuxAeNsw21Nl1/Fy4uuYOO2VSDaLZ2Zk/29hYn4FSMb80GMf1Wwn68fUtIf7NLa3vILsXeCXhGXNkDPIylKYRRjf/Gwgk/vuLih/gMvG9ZoN/3gOAL5sn+/wiq7ncdCKUn30zskAClJL/wmdVVtWgwxeNyMma7UQCUuksI/I86Vfzcwsa+Rfzanwelwtaa6sZyaYmdL/bBV6yra2+Fjoa6mB6edU/Eplt7gu2bd5V07/xyupQVhbAMbmwDF3NDWA8X5ErWhJEJuxH1f6dolSoS20oyJT4c6r9KqzGYuyAWn9gJ+Y/mWKp+nKkX2QTAdTa39/WBD1tzVAT8IOs5PZlQoGcnKLb6WRCgq3kGuj5RFFgwobXZufZTgGXf5I0kIYeJXrstlE8iqSfw25m0AukPxQKt7a2tb8T7In5paamJj4Ti7JUOPzsOW+tMhPyY9iFe78dUT+xu6fvDU6nszAgIIPsJ3TWfiutgaP8fCAQCLAtgKpNlBqp9xdIiMPprDpx8vSH3B5Pi52yU6nUtSuXL/7PdDrNk35ezE+fuk+rp7bWt4OFtpGmLw0EA/cVl5d8CXaIRtm84QjEfsHCk8/MQGFI+mvr6rsJuX4IbIr5bayv/dPsDNMg4g0URmJ++neDP78VBym4+nu8Xur98za+AvF47LvZbJaWY5VGGN/DAwaK+x0ilMndbWrBJH2eUS5dveIuc2fWFlnO6kXmnGA+oWCUZs5qgZC7apORbUKoqXs8aBZydlUCJDM5F/icZTxv/acgfx9vaijs29VQz7wBKGG+/XgXJdzC+fUR6uLkcktOoTfYtkFd6y9Nz7BwAe2mGbUgTvK9IqtMtI+/xbSOVKGfHrfCQpFyqv4hr4fOWJL90/DTy8OE9EfZmd1OCQZamuGDD9wDd/V3Q9jnY5kBisAJAbLJgzytF0hlJxaWYWxhkf0tK7LS4q/5WvFRJShqFHcjereXgnyHZRLB5gy6UQqqwkJj5Lp7+98vipLHRpFUzO9LiwvzVDAqAaVxqVZuc5bW9Apd/PmF7UNFIcmg4N/DjrV/a3xs9AtQSvr19bJVPwQCcXPDgPSXszoaifkV9FBOnDj9KBnqH7NTdiaTnrh29dIfcEJ+Vi7H+slSM40T3tLY43A4u7kiCelZ1wTFbMX3Y9uH2A+YhNWYCQ+bhSJ6CWqPd/e+z6aYHyHd8RdHhq99HUqFh8vpD+nralbnonews/PYW0jdOH0kNbMwP/cdwNj+Qwck/hzKuEof5L2yK1LGGgRVVTQXvEB+CXKfA7DjnueHnQZFa2DcUKoyXy63vKnwnAKK85nlC6fbwk0iU8onRHd+fSMXBJ/nnjnbvwqJbAaMBHq7muuZpZ/OBTTXhgvf1FT5odrnh7nESvVacoteo+PepttWSRHKRiQGE4vLrEa56Urjn5Km/YulU4WJBloPSXIw8k+3LUeibHsDs/YLkJYz8MLQGKxuR8DpcEB7fQ28+dQAnB3sYV4CBaV/TdiPAyX8NGOBkvdwYN4EG9vkfKOQkZmQoOoV3S882vHWJ6ECS8RhId43EmVc/Pl3RS+SU9SZ9vYNPuTxeJrtlBmLRX/KifmZucwZEn4oT/qNrsWWij9d+gZOvM3hcPRrJ4nHYn+7tbmxAaXeB0Z1QyAQtwbKKYkbaaEUkX7ST/r6B0++KxAMDtopMJvNLo4MXfs90iZR7yPe0m8lLqYn/ZYpTBsam96e/5tBluWJhfnZUSh1LUaLP+JGYDfCw4WYfjLWpGJ+73E6nWE7hWUymbnhoSt/pSgKdV+1k21I/y5YeVGWCPtRhMLV7wJe1C+V/unK8tI8VBBqiJNvBwMk/lCaRsxkN9Uo3VglKdFsHse2+3x+0eV2S04a5U4gSZIzP9OnT62jJ/x0oUqfVaSDDuU/a9sLEwHkuwBwkwDk3B5ShhuKyT+v2MnWZB9Rg8BBq/w/TPzw519ev/5zU7GFLhbHT7ZRQk6t8RoZp//SVHrb8Xgu5l73qlPre10oyCz09eFQPnpfYCkAT3e1gyQ4hBfXrzXS+lU5fPLJqq51mjrwuWsjee2Awm0s/gHpxRGSn0ingWYdyO2V1wYgB20m4sy7QCF7NlSF2EVPLK7C9MoaBNweONnRCm8c6IOmmjCoilp0XrZw17ERjzEPgawik+1KbqIjlYbnh0Zy28hWl+C8/JHuh/6I1LnEAkszDjidLpqxoXBOPr1ipc+b9p3R/vrvzJ5Po33sprE0219T+rc6xuJyrQaxZnH9haWlte10dU3NXWAD2SzpSK9d/VxezM+qIzVy8bfToZVz79db+gsDX/KMeMPh6l/T7iPp7BdGRq79I5Ra+S3d7LDTRSCOJspkPaGLkaux3ouQLb19Az9H2ps32ClXkeWt8bHrv7+1tTkHxer9lVr69bHFhbFJVShU7fX6itz8E/H497PZLC8SiCFOiANHhXH9ZpNt3u7e/gf8/kCPnTLJeDM+NTH2afIOaBNt5bINGYX3amsjo0PJGKSj89gdZMzKe/+o6+trX4VSrwKzNH74Hh4gMMYf7FtQd2Np3aV1VojHY4XPsPMC8oSGt9jzhL2g1K+qqvaCZXVLhop+5I+h6wwhC9n8Z/oi80SBbwxEWZb1RK1o5jwtp8MiqcL85nI+bp60OOkMbEVjEPB6ilzgfW43LEW2oT1cDfwcFHWvD3l9kPSnmSVeVnfC37tbG+GZqyNwPTJT86By17pLdKj3Nd25ObQ5HU6rWcf3X74I7zh7e15DoFSl0Od0wnpMhRgh/wGXe+eGky9pXei61uNjmgPpbBbmVtfB7ZDg3lN90FCdJ/yclV/lCqGTBiuRCKzFo6QcF7SEw0wckJ6TZgp4/sowbMZptgBBdYI4Qkl/UPRGwaAxzObUEJVMpijbwp6o4Bvtb5SO0urcRvvYUPSvqK5lUl0aZbvgB7F6a38R+ac5cNs7Oh8BG5OfLK5/cuLPkskEFZW0Grjyg1dbSrU2XfyNhHQKFv++/sHHybvWpFV3e3vrM6TTpx1+JaJ+CATiCMLCxd8srt/QvZ8ux45331NX33CfnXLJ8CM5PT31P1dXlqnl3Yr0822TBjMX45JwxI6OrrcLguDfKVdNzs/P2lUSZ4fgpCdir2FTeNjIK7HgkUiXpubWwbq6+jfZLFZZXl76IllGoLyBwmgsoNXZyOPQ0PBAl7r6+vdyx1IB5NGpyfELYBxqaBhmeKN/r1sJaPE/JNARAADjhoJ3X2YNxE9XLt37L3PPv+vZ1YsPjMYXbiPbKIumlv5w/jO/Due/M/IC4LUANPd/PgyAf9n19Sx0oNWu4FxRzD4wPyBYXNvUvdkCVHlyafeWYlHd3RDA53UToh1iZLq4aRCglVrcBUE6vzZMr0tyEJr+1uY3rFNSvrS9DU++epEJ6O2Q/p26eAkhp14BUc7dn4LG/UdSaeZV0FhVlXPPJ18PtrfAvSf6mWo/I/1cU85aLurOT9qv+c1NuLq0ACuxHOmv9ftzgoVkycgK/ODVS7CwscXKDkrea7/c/fCf5km/VdwTADaIRahAnMosD66Xuqr29PW/W5IcARtFqutrq08sLS5cg+KYfqv8t0W/4etw8TeL7S90umQQ3uj3Bz6UPxZkOXvx2pVL2qCXn+zT10+xU0cEAnHzwgbpN4svLrH2Uw8pQkKKcnSbQ80uLiz85fzcDB38l7P0m7n3lyX9Xp8vEAhWPcKXnE6nn1ldWV4A44lPdPNHHCSsJvPLpe6jD3djZ1fXu2jWJxtlqdFI5Knx0es/hPIGCquQPytNjRKPm9a29l6Xy307X5Ht7a0nZFk2Cn809brBMcjBAS3+hxOG1kyHw+nOZjOFGcJnVy/f+8LqlY+7RJcoR2TIypepjT9V4wlONfhqxt9QM3C5xVtL1ccLln7YiUemSwqKSQy/6BsIDfo0ghrYC3y8qnV8Irb4oEjaKUp8cy71Asytb8Dx1qaSA6ga/vzmFoQ8XvA6djRLQgEftNbVsImBHD/P0XhGzMMhpvp/aWsifK7+ZCyjZKXBcGfq/NpIaiW77V5Y34RnLw/Dm0/1Qy5rIdeekHP5XS6IJkh7WBUqTCbQCQOHKDCPADo5QL0OHILI3Pqp1V7lK62dimoCbG3CElP6pxZqiRB+HzveTUMbyPcb5LsXr16HdbKmcwntnvoXHu9+2z+R81uSfofTKWQzGWwIjWFG+q2sV4WFWq0IWe62U1AykXjt+sjQt8FeR1riNrcHLv5WM+1CV9fx/51OZOTPJS8vLf2hqqr6Opl1ugA48EUgjiTKTJJa6aCUWPpr6+qPd3Qeex9pa+yMGdW1tbUvT4yPPgXFIqhmpF+biDQzepiFOonHjve8XRTFWq5seXVl6QmwdjHGvOGIfYWJi78Z6TdU8Zckyd/bN/AemwYKyKTTU8NDV/7GRjiiVTo9s5AE01DDxqaW9wOnr0FDDcfHR78P9jwO8R28AUDiv4/YAxG2opeQkH76d8E9aDq6eJckOkUlL1DncbmFRDLliSrp/lhsqX94c/YddZ6q8dure352R23fCHVZhlLSn9Stte8yUBp7x9dJT/7ZS3xbuHv8qYULm2TncJXfC2d7u2F1axuy2Vysu0DItGaKpwcG3R5ClOMwRwh0X10DKPlA+SqvlxFu6k+v7kTiM1Ayfn58CrbSMddUfCn4D6NP1tR5w8oD7XclvznxtFsSJBhdXGIhAvedHmTlaWn56OeAxwvriQTE02k22aCSS1uLxxhRb6wK5XUCctZ6h84pRqsNtezPbW6yi3CKIrSGwuB2OFj9aUYAmdyANXJNV6ZnYSsRZ94Cg9Vdlx5uuftJ0jDyM6FWDSHfebC7RjoU9sWtODtqEqfKE2SjVFQ8+feEq2vaGhqbH7BTniLLm6PXhzWBHL4T1b8fhrPnVr/RLlX8i0h/T2//OZfbXXC7TaXI4z8+ehGMLf0VeyQgEIibHpUq+OtJvzcYrGrq7umj4URuG+Wpkcj290eGrv4zlBfy08YWRn1e2TbQ5/MHq6pC7+ELz2TSr0xPTdKsK3YmPVl9sf1D7CXK6GnYzZzhIf37g16fr9NOmXSMQvr+P0mlUjSFlp70G41VyqXttrL2c6S/ucPjcd/D1yUWjfxTKplMgH2PQ3wHDxhI/G8QqGiZxcSA3pXecLZQZQSS0FZylt7mBmiuzmXSWN2OwvjiMiWwwrYc7/7xyvnun61e3f7AiYderc/6np1Nrla9vDZ8+t6G00/VO6uo6iZtINyw01C4wJr8W1n95Tc2nPzxM0uX3rsRiTHafrKrPfelmou8F4Q8gVZz7vhNVVVwfXUFlqIRqPfnJjdzpH/nBhQ+kAPqw1Xsg0NywERmudrt8ogxOS3+aPblwO21/YnLG6NempxvcnGFEftzJ3oJEd8h/kG3m5H1bdI2+YIuWIpEmKAgtdiHvd7c5IOqZR/YAfVgWIvTSYotyMhZVp2WqjA0BoM7sf5Mto/cNFmGeDIFq1vRvKo/wIXVkdOTkfn2c00nv3Z7sPvHYE76BZZSoLQhLlRHmwCguBUazTJu8Xy8nJFQDltoCqrj3T3vIgNYl40ilcXFhS9sb29Rl1GjgatRR2pLzM8kvY8dMT8+Z663rr7h/8ofQ9+tzYnxsT8B41l2jO1HIG4hWFgczRT89eSDufi73e7qvoETH6RpT+2US8b7F65duUStjpqauB09FABromRo7Sdt+SM6a7+6trr6d3n9IiNhU3TzR+wrLPp2uy7+bGluaT1ZU1t3t81ileXlxS+urq6MQfE7ZyfFMA+7KYQL72BLa/vj5LCCqy7hJOsTE2PfAmOPQytPA8QBAom/DmXU9tUKjymXIrBw3Mz0FBX0E1LJpBjN55IH3SwcjfMhnVqh8ahy+FdXMxFVURXBTUhwR2MdI9M0Nv6Oni6YXV6Dl69PQCyVgpSarfry5e+e++CJd6h/f/17b3a73M7x7bl7W721z7674y3f9YouOlPIZglJOYUQAPI5S8osWKjzgoG82KDe6q+crR24dj06e3olsdnzk9euwNtuPwUNVJ1f0CLuCzn3GGjda3w+WCYEnBJvJ8sAoLul3N0XSJHVAT9EEim4tjohifnzJuU0xNJxoS/QlhyJzXroOa7NzEOY7NvT2lQ4Cd2/yuOBTEZmn2m5dDsl8IpOrZ+C7rOdSsLsxkY+BSFAtdcHHdXVbMJA5XdmkxkqC3Forq2G/ngSUuSYSDIJK5vbQlLJVD81f+Gj1W2+4U5/82Y+IwJ1L6DFsIaWbJIJSZXyAn/amQsDpFAoDA6nkwxyVtTaunphbHxH9K/7eJcCBtjNM2p2TDlPFu64onem0nIMjrHj4m9I+unfx7t77/N4vK1gA7Fo9KdTk+M0D3Q5l7mK0uOZuN/a7XALYjoDAyd/hQx6tWtRI9tbn14no14onWW3VLO+FSaNEIhbCRbeRHrPKEslcTpROnDi1KOE/DfaKTeTyUwPXb38GdJvbYOxpZ8X8+NJvwYjS6NhG0iV/INVVTprf+aVyYmxV6FYUMyOZx0CsZcoZ+03Eh0uvHc54eGud9qM6wfCF56eGBulhiT9RBtvvDMyAOjry9e1bJhNY2NTu9freTNfl1gs9pVoJLIJpe8fpvA7REDiD4x4iIRgKNraZDeV269grbey3OfTkWmW2iJyoy+Hs+CyfV0ul6AoikA6UcgfK+Td1QuNyFtb7xy9OvQ1xevwSF6ns5BOzuN0sSPaGmqho6kezo9MwsWpKaqy5/325LNvdUlORqwlUXItpTbe9rnhb3X/cs87/ibo9DPVcqqKC7nGw5UPD9DU/7OEbKgKDYDPTUQw0T+yT4nl/91tb37qi9e/05hVlOAPz1+Cc/29hHw3Qk4UX+Ws+dTRXmBWf6p4P0G4S39DY2mvzG2gpLq2KghbhFTLcqZwc+l6bHvO8/7O+7ajmYQ4n153SZIAl6amob+jZUcokMDvdpHfR2Yu/oqac9+v8/lBKSpYgJScJoR/C7ZSCVYGzQTQTgg/u99aqTvOBMybgZ6L/QZOFe7o7WITHllZhu++/Bqpc4K6ZbmSatbDjtmJQRDy2Q+17AkKzeJICL4ok4PJ4Esl51Ez2YyytbVZeHYI+Yc1WCncpYXFZSkej6vtHZ38bRHMnmuzZ5TuX27Sin7Pr/PHqdxxarljdPsblSPOTE/RjAbae2BGkK1m0T21tXXH6urtKePKcnbl+sjQF/Kxckak38raX0lcv5FyrmXqPrqQQcGAz+9/TPu9SBvx6tUrl7/B1cksjV+RtQs7XATiaMGGxdHIM8rIxd/f13/iYbspxGhY1NjoyB/FcynE+Lh+XkPIaLIUYMd4wLv4W8YVdx3rflQQxBBXBRrb/3nSt5rprmAKU8S+ooLUfXohzYKSPxlf07j+d5Oxn724/kxmZmTo2hc4Dxs96bdj6QcwN0AYvX85Ub/2jg/qrP2bExOjXwNr0o+Tb4cAqOoPRSS8HNFR8vuXtWLmIWgEKr8uLOXqlE6naUo3K2unGHT44n7JvUG5I1WVp9bnAtQcAaWx5XcS8vnAqUHSOSuwkdgGUcqlmKMLJbqKJHT+7dh3/2NEjrdAaQYAumjq/37SsRbSCJJynWTRGoUiy39A8iQfab/npzSeXSZlvDAyBi8MjUI0mQROTD8fMQ/MU6ElFIIkTaG3tVU4ldHNpduoBoCWss/rcsIDpweYZV4gRP8nyxd899SfTilyll1fPJmGuZX1wsQIRdDlYcr7NP0erXhDMJD7Pl83qpsws7EGVxeXIJJOspCB3vp6NinhceQnWVS1qIKCbs18E0SRCQlSVf/NWJztT+7+8olQ1wSUWjiKBjrk93ckEwkxk0lTLxAhEtkW6N/AkUBuYbdxeOiqStP+PffsU8A/e1bWe6Nn1OrZ/NjHf0PUpwHUCLwd671RCkEzkOtQuTSGRp2TmYp/YaGdaNfx7neSgaKdiU5lYX7+b+LxGLWem7n4m3aku4jr1w92LQe9Lpfb3dLa9t/y102LTi7Mz/62oshavcxE/fQprBAIxBGCDTE/q/RhRdb+Y909b6quqbnLTrnUODA7O/2Z9bVV2qeZWR2N1MR5lLM0FtrH+vqGVr8/8A7+YDJeem5ygqUPs9I3QcKB2BfYSN1nlIq7yNJPF+qV6PP7j9kpkxropifH/5xLM6wZKYwMFPr3zmxMZRVis+Pi39LW7fGUWPufiGxvb0Ip6TcbL+F7eIOAxH8f8cRXvmIj7U0J7FgL2ZrG8Df66yeoRXlmZa2IUPOgFu32pjp4+OwduZR0+W33nuiF27s72AkJ0W38u9Hv/WpcSVGfeD3x19L/MfIPeSsqlKb642fuocvftPb+Y/ef90juLHUSGJ5bgGcvDcH1uUVIy3KRkAFF2OsDn8sFy7EIRFKJ/I0ovR3US4AKB2rH0pj/ltoauI1pCQiwltom9VGEZm99lrndk62TSyuEhHPnIDeL1iGWTjOS3xisylvsBViNReHi/BysJ+KsjNZQCE42NUPA5S2ID5b9qYTcPf7Z0HX42rMvwXokJx6oqkr63sYzX5ZlOh1Sks+VnxF26bZp97kk3hsMJgBoFfjOaA+EJgv4xCc+YXqu3ZRjNVmwczctXfz16aiKBP1IZ/qA2+2x5a5K3eampyZegp1O1CxWbjdx/XrdDqvBrv73Zmk0B0+e+iVJkgoZCUhn+7mZ6alRMHbxN82Zi5YuBOJI4vWK+fmamltONDW1PAi20vaBsrqy/PezM9PUxd5Iwd9KBFWrr13Swfq39s6uj5C+1LNTBTW9uDD3WS62X+/5hNZ+xEGgXPYMSwNFfUNjD1nutVkWDfX88tLS4hCUkn6jcEQzbQu72YSKPG6aW9s+Qg4tGFLI+H5lfOz6V6F4HGIVZoOhhjcQSPw5WJGW3cQnV4IyL4Cp2nujKzQrkp+Rkv6JhZWdb3WH09o3EoL8psG+HPknr2F7fR2c7GyH/tZmlrM+IygNX5986r2wY/Wvfnl96A1fnvzx+4e2p06CMfmnjVgJ+V9PbQX+duxfH/rK2I/vTshJR4FUR6PwyugEPH91GObW1nPx8OxflYn/dVTXsBqPra0WUgGW3BhyHurqz7gz+b8pHGaW9ZPH2sEhiczz4fz6qLsv0JZlXgDk2qjYoUOSiu7g0naERtYzQUEqBkgt+1fm52F2a5OR9pDHA7e1tEKDP5gn/EZaKJo/vcoyENDzUbf+C2NT8L9+/FMYnVsEhyP3mkkqbD/UfNcX31Ddex2MOwKzRduHnwwoifuGUksyI5x02avnlGIvJxGszlfGdU5vwTKM66cu/rV19efs1EOW5bXRkeEvQbGbqh2BHLtx/QClgwM7M+zsN+48dvyU3x/4cP5YWt9rV69c+gKUdrSmYQjl6opAIG4+lMl4Yit9GF1C4XBrZ9fx99pN2xfZ3v7B6PXh70Cpe79ZWJQV8dB7PZVMfrZ3dJ70eLxFlsZkIvmd2ZnpETAmHWjtR+wrKkjdp08xXHjv3G5PuKvr+LtsvneQSMTP6947vZZGudj6cu2F6eQbaR/OuN3us3x9opHtL0WjkS2wtvbje3hIgMSfw27IkRUJevyxx8q69JuAH6TrTcxFL++pmt6ZjJxWqMP80OwcjdtnAnPFF5L7i5LX/o5mONXVDgGfBzxuFyPMdw90Q0t1mBHvleTmsedXr1IXv/ALa1fP/WThwq8vJtfe982p5z7+/aWX3w7F5J+lHYFiUsoahxfXR/q3MrEGSRIFByHiZAXaf5QYz6ysw8vXx+Gl4THmCk8nI2j9XIScN/qD7BKvr6wUpw3gLsrvJfV3OpgYX0tduLD9tmMdbBJjLD7n6KxqUmRFZneLphNMpjOF/WhZG8lcmj2qL0BF+yZW1yCVzYLf6YbBhkY4XlvPwgdUg/LZn/km0+GQIJXJwvWZRaB6BpTwX5mcycf7U4KmqNXO4PivdD/8xZOhY9Ow0wlYpXMpIrBQPAlgNgGg97rYF4v/DYCV26rZLLon7+L/iM3OVFlcnP9i3sWfd1Pl41NNB7BmE3cG7rflYvqdYOBa5/P7/c3NLf8P7Lj4pxbm5z6RSaeTYEz6MX0fAnELoExcv554mJJ+quDf2zfwqCRJPjvlplLJq0PXLn/BhoK/maXfKqa4pG8jcDQ1t/4ycDnDSdnbU5Pjn+fKMvPKwslPxJ6jTLYh/ThF7+JfGOOR9+5hp8tVbadMWZY3COn/bD7NsBnpN00zXKa+Zu8hG4cQOBoam34ZOO5I6jM7en3km2B/4g3HITcYKO53uFAiAsht13dabFuN078V8gQ3I5l4zeLGJmzGohCk8e+6HATUYC0Q7kf17W7v6WTidpQM031k8uXpY+0s9VwassJLa1fvPlHdtfX80uWHnA4Hm0Vwu13SpfWxD9a7wlu3V/fQPLm0g9UmNvgGjjUSq8mNViCEvy7oh7ffdTtsxWKwshmBtUgEIkzpPku2xQnpX4TNaBROdnVAbVWAEFQnNIfCsJaIQZKQ8dnNDWilXgB8PH1eRr+1vgbmVjfY9WoB/Ce72uDlkXGmjT8VWZQaXdXySnqbpglgxN/vzqUiXolF2I2u9vlAEkWqUAjNVVUQIN/Te0O3Uet9OkMnDNKQSGUgTeqcJX9TkcB4Kg0b5F5Twr+yHSHXkWDpBVlLSo6lXgzZbFqtdoe23lDbf/H2cA91yaKNoRt2GkUKfoDGW5d5t0VtQMMTO227CDsNLA9+0kmlHdTN1NDayIWrxczpLVgF4n/seM9b3G5Pk53y4rHYi9OTE89DqYu/UXyqbRf/PPhrsDO7zne2rMMdGDz1n0RRas+fT41FY381PTUxDNaudYYdLgKBOBrQTSyaTSqWdfGnomL9gyff63K5G+yUK2ezKyPDQ3+SyWSogn+5FGL6tqhcXLHh5Gd3T9/9TqfzBFcNNRqN/N3a2uoilA91QtKB2C9YhdYYaWoULR2dXXdWhUInbZYlL8zPfTayvU3TcOu1NMqFI/L1NTKmmBkhCuOQnt5++g72cedSNzc3/iqZTMSgwoxCiBsHJP4cqFX0S//whPT4Y1Qwu2hmmv1toYyuDej1xN30IeeOoWA+7Wt//mfC8OmT/LFFawch4VRBn1rmc8L6ufO3euvGhrMzNZIkwWvjU3DfqQG97hwzT2fJMQ5RYG7tve3NO2J2ZF0bqoJBsu21qRk6aeD56sSP7yfk2d1RXwe1wQC8Mj4JouRw/GTxlV/qCjZ/Ouzwr8FO7JCW2q9g9fdKnoQgRAhhJqSZEOfqQIAtstpAqpILTaDkmgrexWJJFqcvSWL+gnMu/2NrK7Ccn8iocnuK7h8ttL22hhDvTP5C/3/23gPKkes8E/2rCjnHbnQGOvfkGc4wi5lDkaIV16unPZbt9XrfOjw/h137eWX5SVrr2Gud5+O3x8/eXWltyZJtZdGiZEoyg5lEDjmc4cz0dG507kY3cs5AvXsvUEChUAVUS6REDusna4AGqu69dVE3fH/4/rqXA3rf77LDXiQGB4UYg70NWIolln2ODBB1AUTSNTb/XouZ9AMOEehFwH/nIAIXD4IQQ2Aeg/tSudK4jiJhA7yUhLwtl0alIuUUENh36i35Aa0rfNw+vjtgcHIsx1po3YhwpG7cpow/cRd5aRT5lgzyHv3OFbRRq6DGlNB9lWo/LXmly/U0ELznisjU9BEqsB8Ep8sN0Pqcsp3I/ATPNn+sSI0FzhojzBJQ6VJHQ5KJOJ1IJKq11ziANOgXS0lF3tsdjmGX230byBA0lpJr/pUvClj85Wxg5cb1y03bJ+rBMT1z9H6dTvcw15/oJ74yN3ftiyC92ZVc9JUNryKK3HDSiSxUlncZ2tDfZzKZJ+VUhsn8trY2/iKVTGDwIUzb14nMjwVp0NEx1MloNJkcDudHgbemVCqV9ZWlRX5csVA5roAORd40kVjfhc+zFIs/Ocxmi6evf/ABkMenwSaTiSe3Ntdfge4eNlIkmt3CJyWVbwaDEY/Bn+e3tVwuXVtdXnwaOocbKoq3t5gowF8gP/eRf135uY+0f96FrfxHyZ0uvIatTyR8ENQC/svERN/OznmTY3JhPrF5hqEoZi0QhJsmfKDXaAm45rjosMN6Mp8Fu8EIUHe5r11dW4sZBJAnh/thLxaHMLZgV3IW/PkZVJbVYIDNUIgQ1LE0Y3l864UP/vzou78CtcHN3Qd/klONmfq2NtP7E1kWqMsra3D3iSMEaDOclx6mGahUwaJDoF6nAx4OJf/i+HqbVg+JQh7WIxE43tdP3O6bPcOCx2mHTD7PuTOQj3EdDqMR9qNxiJRSdJktNz7nrP2pYoEoQbAyQa/SkO8q5Sp8//WrEEwkawC/3h6sjGjVwNST+LE1ToJytQJ2tbHkMTizg3p3+qhjNK4GBk/IeCIuoLI0RSirl2ObDpqi80ccowdspcpXlPBdtBpgkwf6uaOhFEAbnhI6isLnh/fa5tK4tDhPfqfDTrhyMlAIzq8c5nyxOtA4IA8l2oh2IvQTA/3koGna4PONP0xRtFpG9Ww4HPwaWlADIJ66T4qkpqN0IfPrpF1X876n0a5g2O5w/nb9WvzMpba3Nj5RLpUKcDgXf4XMShFFbiCRGdfP50ARZfAfGBw64XTJS3UKNTK/LwX2dq+DNPjg5k2x2GIAaQ8uSRbxsYnJD9MMw/dGqEbCob/kWRrF5upDZ15RRBE5IpFBQy7ob3jZjE1MPcowjF5OnaVSaWdlaeHL0Erm1wn0S6XvOwzob+xF0Bj8kGAMVoIHB39V34tKjUFF8fYWFAX4v4nyBsVVCwEddzQGlEtrS4wYPRs7ueAYNppfWFiFB04fg0prUnrQqtQQz2XBoTNCUyXRBNM6jRqmBvsgNJci4HekxwkmvY64tt9+dAq+/dJrhBMgVEjMLCa3Z6YtQzh9D99lndtkaE45JvYuhxciKbbowvH8s/4tODY6XOPYJxoJft3CMKkalh9xOOBaIEAA9lokDJPuHuJCX6ffJ+0dQG3kpzPA72wmI4Hn8VKGeEdgEG8zGkGtYqCMAD629uMzPVZLTRmB7umJV1+HaDpdVy7U6frYWlo/ukqx2GtAo1aDXqOvOxaw4FCbS2fsUwmvoSfDyx+MW6daTe9a5uMb9rX0rjVfKqm1ag2m9IfHt15kfZaBrQ977/seTscCPMCPrfwUtuIj0I+tKtCc0PnKAe59C9u74HnhPzN8D4O35KSLLf4c+OdvZtPpFPdcCWP7paxYZIH1+sZu0+n1g3LqLhTyi2urK09B+0LKX0wPxQotiPvjcy5IubWKgX5Gp9MbRkZ8f4ieCXO9LOwF8Rm06d6CzvF0iou/IorcwNIlrp9v7RdzM27EF9ts9qHBoZFHKYqiZVSLXeufW11Z+gGIW/q5OZPveXTYuP6WkEF8Xl//wKjRaHqU35BCofCMf3X5ZWgPixOrW1F+KvJmyGEzaLSEIo6OTdxpMBhG5FSE94PbWxufRc89doH8UeP6u5EQShL69fR6hkwm8/v5bcrn8z/YWPdfhUO6+Ctj8KcvCvB/64nYRp3tdtzTe2r27/zf97I0zeDUfpsHYRh0Y4b8Jrg2arSQTRchWy6CXq0RqZkCt90KFr0ekrksjLhdDY8Ah9kEgy4HBKJxzI5PXQovnEPAH7uxcwssrog/4akfGXnX1a/4n7y3ygD92uoa9LvtYEegXC4Mwez8Iw47bEQikC4WYD+dJAz7pDK2ZsXHbeXc/OsO+YQrAJP6aRFQx/H5WFmB214iKQQpiOVyYFCrwKTWklZfWd2AcCpdJ/JjwchoqqOm/kKPzl52aCwVt95WvRpZ1q6m97SBTFRFCBSRpPIZ9Wps22XTmO1TtqH0u1wnQpuZfcPzwauuSCGlp4gwoNMw9dh/bI7WU7v58HCVAheNsK0/vWddTGz2HeRiA8lSxl0oFxn02+QnLcMvPtR3MwakHNjnDg6g8tn8pZ6TKjQnetI9P61Yf+z90kER1mgb7zOxxUlI6Cd08debLRYPWqTeJadNxGV1c+ML1WqVc/GXIvOTzQwtI5d2t7h+suHFG/Ejx47/BqNSTTT6sFB4Yu76te+CtFud4uKviCLvHJHaxEuR+bVY/DUajW18YuoDDMPo5FRWLBbXlxbmPl8PiZKy9kvl7ObaKydtWGMeRKIeHBr+39F8qOUKQfXHNzfW/rLuFSc2F4qBDkUUeUNEhot/J49EonRzOF0j7p4e2an74rHo4/uBvXnonrqvk1fiYRRvDeUb3sQOD3t/mZ9Ck5Bqrvv/B7SG2UjtmZRx+BYTBfjLlJ8CK3rbQEGLIF3P/944cpWC5lrSP21mTNS003ewEN/opxkanpudh5+96zYSe84Xh9EAe/EEDNrsjXh1vmAL/4DLDvHNNFjMNVCNpYqqvXVmEr75wgWgGQYC+YgvWc72WlQGTO5DACaeIF4IXTuayKetd3lOrXm09uwx++jGbGJ9FLvMP33lOnzojltApFqQ4jV06I0Q1+UgUcjBbiIOJo1WoLSgGleTf6makgJzIBRLJXKPOL6/z24lyoJwNk3qd5tqKfri6Sy8vrZBCPmwd8C4qT93vu/mtIZRQbSQVL0SmtOtIcBfpli6NmvSoEb3YtJpSV04/CFdyTOvBK9bcPWXwssWmiaIv9ZvbBX0Wg0MOO0QSaYhmc2BmlJRTwYu3rQY3ewrQ1mnolUNBwitWos7Uz0b8z94X//ZeTVLYw0vH/C3pU6EVg8Q/kHzOrY1luItJIKxJeW+2mlBJa+oz/WjYxPvpmlaK6feRCL+vVDwYBXE3eY6bmLFgHQXBn8pt1ahhYv8rjNHj79Xp9M/Ui8HPc+VtaXF+T+Fdku/4uKviCLvIBFJHyYXeDTc+9FcaZycPvKoRiuPzA+tp6l1/8pfCCyOfPAhRjAqFdcvNheKpqmdnJo5r1ZrjvOawiYT8c+GQ8FdaAccHedCZR5U5MeVDiz+nUIRW6z9KpXa7Bsde1RmKCL2blleWV78R5BP5tfJ2t9tPyLm4n8nmifO8spiU6nk5yOR8AG0Z9LoZPFXDBBvEVGAv0zpYrF8M8trDGIE+oXa7Op3dl96OJCLnqlU8VcUcNZofMEzCGg/fO40ArSc4Rer7xgw63RwkE5Cn8Xa4ABoVIZA8lCPC9b2D+rW9CYgN+t14PP0wmYwBCpaw1wKL07d6zmzUG8LPLl38cRscuM4nlE2V/eHfmHi4Vfu7z+3uZ8LOyPFtBWz6n/nlUvwnpvP1Ij8+A6AYnQIdVd7r8MJVwM7CLhTsBIKwvH+AaAaF/KlFkKAy8bKgUo9LABb8Yd6XcTaH06niWs/ZvPH4Py5a3PEIwBfOmYcyD06eFs6Ukgyz+1dMa6nA1o1g0A5zRLFx/RQHxz1DhHOgwrq02v+TYimM6QVapWGuhxbsSLQT26lUqmCx26Bk94RGOhxkIwAryysQjqfJ98tJDZ9gMql8dxK1TwYsIcC7hJMKKhjtNXrcf+JXKmAFRJl1A95La2OeE0Dm7066w76jE8MWRE5+C7mP3Xp9qxLsFOLxatKLai6weGRU0ajaVROe8rl0p5/ZekxkB8r15HFX8LSL5c1t2WhHfGNHrfZbL9evx7//rnA3u7H0WKbhM7adSWeThFFbmA5RFx/RxZ/3+j4bRaLfCbxg/29v0Eb/Q3oHNfficFfytovJBFrgH6n09Vjs9t/AXhrWKlUurS0OM+lDuuUwk8JdVLkzZJu40+Sfwj/jYD0vVqtrldORdVqNbex7v9cuVzGcY9SCrduXolyXPyFln7i4m8yma0uV88vQwuhX3lxeXH+myCefUrK61AZg28hUYC/QN5ogC8lhwD93GtbfD8Crmy0kBzGLP1AqwR5BSgIIZxwZXUdTo17WwC+XW+AtUgIotkMsajX1AJNgN/nsEGvzYrAPdO8jsKTEEvS5a3vHxC/9ZX0zti9cGYbfVvJVYvqq1H/NKOqKR4KUDZ9Ze3JM7808TPXPjhy39Lfrj5xsgQVbSKbg8cvXIJ3nz1JLOEdl2Wq1i4cpT/qdMJKOIyxMqyGQjDl7pG8DBP36bRqSBdq/HdYkYElWcxjZjzoNZsJb8HWQRiSuTxx8e/T2osI9GeuRld0z4eumnDnYtBfRueP9/fC2YlRVKYWm/BR+Syx5K8GDpp+9GzT8wCXd++pY6heJ+FZwE4aOLvB+kGopc24Dbifh1xOMOg08NryOlEQ1L0XNM/vXX2QpCAg5IW1/v+XwCVWz+gOHDrzok1jvXZP/6mXzbQeKwL4GyAGmqn+2tz932riX9ugt7c2pDaJ3Qj9yCsSR1/fwH0gT9FRDeztfbFQKCRAOq5fTh5coUgx5naycLWAf6fL5Ub38QlUBOe1UE0lE5/Z3Fifh+6WfoXIShFFblCRGdcvJPNrY/B3u3vGej2ee2VWS5jE19f8L0B7XL8QfMgl8+O3VdTaT9M04x0d/1WKoi2NhrBsZmd76/9BwAPXzye+VSyNirzpIuJpIwagO7L4u3t6xx0O51mZVbLRSPgbkXBoDaQZ/OWm7utE5idJqjk+OfVRNBbdvCaVgweBPy8WizkQ34tIKiGUMfjWETmELu8Y+djHP0HLAeR8tv5OzP3CNGXc+Z2uweJ0uYmLtjoW48AaiwaakNSvisGemlbFWKpaZ6Kvj3KWqmNFGq6ub8LGQailfFyI22yB3Xgc0qViC+jHggHmGQR0cUw8l8qOe+mxWgh5HsajyULWFCmmsKug8ULw+rSKYdRUvTQMflPVov3Fg6tDBkZT/lnvvUtaYIq4lky+AN944QK8vroB2WKxZu6WELYe0G/V6sGlN5DPMsUCBFKJ9nOhdhv4GoNOS4rF7yf6POS7cCpFznIbTSR932sra8RdX09rKu8duDPzxPZLpmcOrpgx/SB2+8f3+rPvuhXuPDoNWrWGhAJwNS1s7kE6XwBONUH6ja1Cn8MKH77rVhhwOUg/Eh9MmobnZxdr17PEbRt8PW54/+1n4ZFzp2F8wAPr+8Fm6kAuUyBTSz3IZRnA6Rr1GgNFqxhPrJy5Zy2z9xt/OffYl/584Wt/cy225oVW9386mVSRYnR6PceQL0vqzyjT4XtG+AzXrgEKj6FO5QrqIOd2AP2MGgmI58NtAf+jY5MPqFQqk5z7y2TSF3a2Ny9D58VUNpCWsMJ1WmBF3Vq1Op1ubHzqk/yFtpDPP3599uq3obNbq2jaHGWhVUSRG046uc2LzZEtoB+JEwHq9yFALcvoUywW/EsL838H7UziYmn7pMj8Du3iPzE186BWq72F1xQ2lUx+LrC3sw7Sc6Fi7VfkJyFSz7QQ9LcAf41GYxnx+h4hxE8yJJ/Pz/tXl78Hh3Px79ZeKc/DNlLNEd/oKYPB+BC/oFwu948b62vXoFXxpozBt5kowJ8nf/zpT8lKXcZXDhzWOwCf3+2aSDhEmPJLdntjAKFJQxi/TRbacVP/S9h1HCNcTJx31/FpODU6DA6TgRDcYVneCbSZQc1aHZi0WkKcV6pyt11jwMcVGtB3NEW1Xof+wMqAmaEBAlDVKjW1kFjvQ98Y5xObgxigYkDNl7n4+gAmKnNprYUPjtzjRyC7SOpB585tbsNjL74Kry6uQY6Q8LXG63NkfTVtB0tY/lV0jcR+L5mEbEmY0a52MRdXT/pbzYDP4yLWdZwa0KYzENJA/24QssUSRvhwf+9NuacClwxL6V0daQP6/24E9t997iTpB5ZXNn6fRYD/sn+9zpFQw6w6tQruO3kUzp85QQA6v8+wciMYTxDgb0e/ywfuvBnuPD4FVoMRipUSZAsFuGlqFI6ODNQ9ABww2t8LR4YG4fSYD86O+9CrF06MDMHMYB+4rSZyP6hPKJ0aPU0UNfFidO7jIHDvt1hIKkMqn8tBOp2S/ZzWn9FKt3ParwH2k5/8JCvnmnod1Q5x8WRxKpVKnDuocEPbcJ3r9fRNWqzWY3LujcSqrq3+fZ2gik+aKObm3xVId4j5k+tOR87Bm4Gjx078pkqlarjfVirl6/Nzs5+B9k2uVDydstAqosgNKBLWRjH+Ez7w4Nj7yStOH4YA9c+o1WqbnDrRXJle86/+ValUxCFG3fKGC5Wkct2L2+KK3e6ePofD0eJejNaB1xYXrn8DOrP4K15PirwpIjPERiqLRs04MT55n0ajdcqpD429zMba6v+qVCpp6ByO2InIUsrS3y2TBqNHiN/j6f914HmFozbtri4vfRY670eEhH5ElDH41hLF1V+m/Cju/1/7+tcPFV+NBweaYPBbvlt2m4s/8Ba7ezxnriwltu7Ps6VBHEM/0usmpHUnxoaJxTmeyUIilYFIOgUOk7lRFwahw3YnXN8PENf56Z7eGhFevUqa4uOxZkuwKmBioA9eXVol516NrvU5VdZykS1r8TXTg/0QSaYgEEsQyF5An+/mI9Z+rSPt1tnyvzj+Hv/jmy8O7RRCJqrejuXdPVjY2oEBtwMGnE7wIqCuRuA5hQAr5hXAvAS1eH+AMZcLFg4OMFKC9UgYjvcNNFP88Vqsw4Zi9GZ6YIC49+M0hrjtbpMJKATuL62uEZK/YxZfcSm1pVnN7GrwB3ajEc6fPQHYzb+RDpFtlkszFLw0v9zoH3zOxGAv3D4z2fi72Vk194O9UISQLN48OQZTQwMEtENd14I5GeyoTVjNcRKB+9ZrxZ8T7EGAQxAuLK6APxAk91WuFAfr5I9il7DY4l9Pj/djSzelwI8g3EPWbUPblr4PE+UMDY88KDcdVTQS/mYykQhA98W0KxutCC+BnE2u2GaXPnrs5Id0Ov3DXF+w1Wp4Y33t93O5rFSeaklLP75eWWgVUeTGEBmEYl1ZxKEW138HWgcmZFZbDR7s/y2aL7GFnQP9UllP5Lr4i/GbtChB1Wq1xusb+000nTc2K5hBfHtr408FLv6d4oo78rEooshhpJtxAjpnGyL7FOzib7c7zsisko2EQ1+LRiObIG7t75RxiBOxrAOdUgm3pO+bnJr5ebSf5KdEroRDwT9LpZIxkFa+HSrtsSI/PVGA/yFFsAh3lKnpIz9udR1BPzrKaFEs3eI88tTTwdd/IVMoUBcX/XBuegxq5P8AFoMeHQbiMi7AxwS8jthtCEBHwR8JwYS7hwDVegY/oIR+Ajx1hK+vB9b3Q5ApZFT+zLYLKw2wouG4b4goG/YuXql5D7BVmE9t9CHg78fXvbB/1bmV3Tc1rOJ1PgL8934sAYFIHAHaZQT49dBjtxALeK/dSggJiWVdpQYPAsrBTBpKlSrsxGMwYLOjZlUbDcRNxMSEGByPDfSimY6GKGoTVgYY1BrY3AsSK7yB0bIVtkotJ3fVuIM8qK7zN52ABrGBkPgQHXvhOGkjVgDgv+87eQSGet2EFLHNPaJ+vRqB/n99923EG4KAfqpZBZeIsOnrQDWulQrKx2VgvQCnfKii0lxqyw8qxPVD9Pk5lMX/JyUS7NRSDLnCuH5y+EbH7tBotG459RULhVX/6so/Q/smVorQTxJIy0zbJ7XItrjUjY1PnrNYLf8BGk8QWwyFgh872A/sQHftuhLPqogiN750YuTuSubncveM9fT23iWzLhatF8+vr60+B93J/ORY+7vNgw1L49T00Q+pNZqT/LYk4rG/2A/sbUEr4Og2ZytzoCJvpHTyXukI+rFxYmTE9+5DuPjP+VeX8T5FyjghFVojbCt//An5kiT3I17f2Gmj0fQeQZueQG16GQ63F1HG4FtUFOAvQ0TAvizwf+GVV2h0bVv4gMyNOStyiIL/k86J5bnE+kKwlDwyt7UDWo0aTozWLP5U3XLMCnSB2NKOQadNbwCHIU9y2+/EYjBot3duUV0wR8DGfhjVpaM28xEL7pBhj5uAXLcFAXarBQ7iSWK5Dubj1q3sgWXY0Jsu0xU1Vc88oFGrELC3gcWgA5w+T4XAP3a1rxnKKdJGo7aWvo/EudfvZdDmgHi+RtS3n0qBw2gkCgGKd4N2swnMOj1YDXoolEqQK5dgCNWFrf2zm9sENOeqRWo+tanGIN6K+uEhBPq58ALu34b9vk6wd2nFD9jJfsjphtuPTIIWp0usiisKamVQMOB21s249X9awuP5/Apsy+dsK1tj43McqrC0E4Cl3QD5QEMxT3509KG/YmvpG0Tjvd5Ii/+bIHII/dpI/axW24DT5b5FTgVYQbazs/XFSqWMLehSqahkbSAPkbZPbIFVA4/B39PXP9LT6/k4KoZL7VNNJpN/trqydJHXrk7adSWuXxFFblB5I3KGa7U6m8839jNy4/pxxpPlpYUv1sOhpOL6xeYhAGmA1M3SSA8Nj0ybLZaPAG/BKxQKTy8uzP0THA70E1HmQkV+XOnC3yPHxV8/OjZ+l0YrzzhRrVazG+v+v8Gu/tCd0E/MK1EqJIgD9h09btA+0dLr6fsNELr4ryz+f2g+4Cv9Orn5K2PwLS4K8O8iIm52Yq+iMj01CQf7Ac4FmeWV2XIeNzg6eBO0kPpBE/w3Bt+jQ3c+9cXVJ3wVitJfXl1HYLcM56ZGidu/mHDWfPz1sN0BifweBDMZEtNur5PotV/TvAm3zQLlSpUA9RIC1Ti93QnfcKO+W46Mw3cvvE4s4elSlkpAzoE+zgzq3en56IYdo3ts1T81NkI8EvjzFtUwd7cCXrae9w4D73G3C+YC+wTA+8NhONbXB1W2aUFXqxiYHuwjyo9INkvOcxiMJP1eOJkCmqkZmPG/Bo2GZBnA90DzaC9adCWo2PmNHZJy7wN3nCMhAfheWYDWKbdNwSJ8SHhgnq279DfvDjiPBarlfH47aLi+sQ2X0G+M3RwcGsu3fn70PJ6UC9BB84pAvyz+ip+UdIiZ6wT6G1p0Cj3n3tGx8zRNa+TUl04ln90P7OHUk5y1n8/i38l61bJ4dQH93cj8WhZZi8VqHfGO/hd0L1au/Hw+9/Xr1658HZobXNl5qn/av6kiiijyxonEXCPFIs7NkS1kfmhuMUxMTb9HrdHY5dSJN/dbm5ufzedyEWh18Rdu+vlzJSfC0KduKUy597TBYDT1Dwz9Fmovl80EA449/+rSn6FXvsKha7pVUOZCRd54+VHS9+nsDuew0+W6WWYdbDQa+Va0mTZTKuOQpIGH19ZO+xKxbBqEZ2hiauY/MAzTxyurHAoefCaZSERBPuhXxuBbXBRyP4FwTOOYdRwvvEPDXjLg0WuNVa49lpfW6fV8rXbjcwT6AdqtgeRa/9oGVx6ph1vk64z+fGkMJJWKsLSL5m23qA2pm3uO/7BcqbCEOG9rG567ttAoAIAHIduGJAujThd53YxFIV8utX5NtV9mMxlwIHINpNZj493WWlgeZkOwG03g7XUTYJvOZ4DRMJhxnT5i8cZtKgOe1BAAT8NzV+chkkrW3dY5dQTVBP0tdbP1cyjiITBotxHsjF369+IJoBuXUGDWaaHXZSO4OprLgFNfA+qLWzvEs4Cq16Vl1PCeW04TRQEtMRwwFMfu9d6+Hjh/00mw6A1EoUBwu5D5T+RqrgyWKArY+g9a0wjQdZd93LZEPo/6vlw/r7XDa/0M8MrSCgH91WqlOmrp+9IvjD30WdT/eHHolNqFtVptROOAn2d+ZgmxzBO8sSA8V5anCy6Tf40wC4BwQ6vV6ci4Qc83GUMIzJMFiWYYvIgKWfzJMTg4fMpoNHnltKdSqUT9/pWvQavlih8v1zUtnli7ofviKjwaLq1qtBOfmjnyB2iRbdxDqVS6cH326p/D4UE/EUW7rogiN5x0IvTjg3694CDAf3jEe9ZisU7LrIuNxaLf3g/sXofaXNkpJEpqnpSaEyU9nzDgmJo+8u/5cyEqsoQAx5/EY7EwtDOIdyU2VeZCRX5cOYS1X5R/CO1jDF7f6ENyPW0KhcKSf2X5CWh38RfuU4Qu/p1CbOTsSYjyDYH+e/V6fUuaz2w2803/6vIFkA45FOPWIKKMwbeuKMBfIBzT+EsvPkf+3t7awC9ULBqRcl9j8rmcmDsbw3vlx9mQ4+SJ42LxzVQkTFLvNZjZecKWy2Uh8ViLEuBm59TihHVoCZ/MUDRsBkPw5Wd+CNsHYYSmKAkVXA1MGzVqcBtrwH0lFCLM+C2nCARNaiSkgKpD2fG+XuIBQNXxLwbGUwP9Nb9EBLQThSxdpMo6/PfPjt63paM1Bfw+mcvBk5euw+LmXktGAGEaQarxX3Ou85gsoMdU8uiv/XQScqVSS/twnH8inyPtcmFSP/Tfyt5BQ6egVtHw6K2nQatSA5dDjxW5WZJKj2aIN0SlngGBB98bZwm7isYeBfXQBdyGTKkIcXS/4UwaAokEbEQjcD0QgOVQEELpNOjVahI6wN0pLz6AyD9fmiUZGli2Wp60DH3hfQN3YpZjWTHqiUScNHxs1FvlZ5bAz3uHscAKzu06kXNs/fxrMBmgyLUNQr9CPk/GAHq+iUtatVolm9pqpSKWk1qHXVf7BgbuERkjog94KHTw1WwmgzeQ/AVVyn2+ZTEV8cYR4yQQI6+SSlVFNrrHTpz8NQT+G5aAarWyvrK88LFioZCDwy2yiou/IorcYNIBdAjnFkkXf6vVNtjXP3A/yAxNLBTyiytLi4+BOJmf2BrTLa5fak5scfGfmJy+R28w8NOGsZlM5ksIcLwC4grQjmFZylyoyI8rIsS9nQj92iz9+HXEO3qLXm8YlFMfy7L5rY21z/NCEcXGnhwX/048IFKGCNrd0zvodDp/BXiYELVlaWlh/n+AeMhhR2u/Mgbf2qK4+ktLy0a/XCnTvL9pwSv/fCzkoVchEIfAjJgLDFsql7iBKtTaNeoUlse7ng/6W8D/IwO3Xv7CyhN9aTZvxeARu68/e30e/PtOuPPYFGGrb40bbwJWHAOfRLgD55PH4H+qt7ejww52kU/k8iQv/fRQf9tNuKxmAnqxC34wGsppTdNlBJUps8pQPu2cjL8Smu8ljUdg+pUVP6zsB+C+U8cRwNZI1svWLfXYSR/7G4y63HB9b4/UsxYOw9G+vjqfAfYKoGE3EQeTRosAKAP+3YMaeSEA4QR45JZTOACy+SOwTZ8Dqdr5bPv4hbPYl9E9YB6BfKkERdR/xUoZvS9DAX2G0yUSKE/6giUAH7cJ8yt4HXryXbV+ZyzL/6lrao58sQg/uHQV0vkCTj8Ye1fvyc+ddUzhTVEnwqWurPQ/DREj9EOLoyqXy0rF9rdZ+31j4/eoVGqLnPoK+fz8xpr/OWiP6+/k4i/m2g/QDvqFpDlSCyx/s0thBn90z+8HTrWDftPtra3fjcdifHe6Q7H4K6KIIjeGdGER59Kb8sOg+ICfgH5GpTKPjU8+StOMVk6dOKZ43b/6WbTZ56cP4+ZLMRd/OXH93ZSgdA8GHC7XrwEPcJRKpdcX5mY/D62eT7JS+CmAQ5E3UA6bvq+hADCaTAhLe+6UWQ8bj8f+KRQKrkLnuH6+0r9TO7uNwRbgr9FodF7f2O8IMmlkdne2P432ZSloHYOdFIDKfuRtIgrwF4jIRp9s8tHC2ObiDzxLPYgA9TqIE2qlyXsESDj0Leay01I3tGvsxQj/yKGi6OIHfXdf/Pu1J++tsCy2LhJguhOOwLdfugS3T0/AQI+zTu7XHp6OXf5xujxsPd+MRsHncLbxBJBK0WcWox4B/xz0O+2gVquIlb/Z+hoJnd1sJC79sUJSy7LE1k49GbjomUtsOvEfOG1fvpgHmlFBLJ2Dbz5/gZDmTdTj84VC8VuBitPQDPSZLRBIJSGPwHY4W3Prx/eN7h9ShSIMO2rhjesHIfK5QaeFh86cIMSBwk7n3yOnEsGAnCapDikSBoEP3D+YRwG/ZtGBlRf4HIZuPg41rwmWZBIwo7qMWg1YdXrSL/g7TslQbdTZ+vPjtm7uh+CFuSWiYNCwzNqHfef/0qE174K0RYa/QLyVJ+TGQoUWF/y3rNh+h9Pltdsdp+RUQOJVtza+hAlzoJ2gqhPol4qb67bA8hdVDYho1ienZu6xWK18Bv9CKHTwsd2dLT/IZ/BXWPwVUeTGlk7uxfw5krMwNtL24dexsYm7dXp9v8y62HAo+BVe+jAxHhQxryh+O8WymogBfh7g0OpGaoCjocRlq9XI5sbaHxWLxSx0T933Vl7fFHmbikwXf87bRpzQb3TiAYZh9HLqK5WK2/6VpW9Dq8JNytNG+LzLAf1SRghy3syR4z+vVqtneE1ik8nEX+1sby1Be9ihmNJNcfF/m4kC/HkikaKLDKhioSAcVHz3fSH4JwOzUsupxwfnwvdCq6xwwLQoF2iaxgoI4NchKIcMSKfGkrp/7NbISzuv92QK+doNIbCZLxXh6WtzcHRkEE6Pj9QhbavlH7ua91utxBU9ikC0CQFWp8HYaBCXDQCDVCNJsQfg63G3g3S2phzoQWVh4B8qJDA1P3OQj+qvRdccjIohlnk1qIrvGrh575nAa4MsRakwwv3hwjJsBsNwz6kj/Kh/aNV/UA1wPmCzkfR+GHzvxhLgRu3F34XTaVBh/gHUTvzddigMFqMB3n3TyZpXAedOX89fiC3yGGxja32mWCSgHns/YCs+eV+pkDABhuIHHbAE8FMMTe4Xh1hgkK/TqNGrDowI9ANF1YF+sw+h7U6g2R504EwEryyuwsZ+iLTLzBivf8T34N9oGTWOBeG0wkKLjJRlmMhPe0LuQOgntGSRTS0m8EN91dCk45i5Ea/vQQo/JzIklUw8HQoerEJ317lORDkA8hbXjlp1fPhGx087Xe7fg+a8W00kEp9ZXV7ix9AdhkDnp/6bKqKIIm+cHJJFnJsbW0C/u6d3As0zcgnFIJfLvl5PHyaWM1yMzE+4VznMvNjYP00fOfpzCHAc5ZVTikTCfxo82OfSmHay9iuAQ5E3XCQMf2Ju82KWfnL09Q/g7BRTcupD+5vy7s72F4rFYgKa409I5tdp7AnbKcfFvzEOxyem7jCaTO+D1kwaTy3MzT4G4uOvo/JNGYNvD1GAf7uILroqJFwMMrTG7wvBPyd8UC90za8yDIMVA2Iu2ZLgHwEfmgf8gXd+NVhKOF8PLZwK5hNjsULKU4aKBselYyDbxJk1VvyF7V1MeAZnJkcJiG0WVYPZvSYTxLJZAni3Y1Himo6t1gT08+4QW+sxsR5O4yfajeh/m7GRIYAK5qO6a1G/GSswuLvMlHOaWD5F/+LYo9e+v3PBu5sLORhGBbvRGHz12ZfhXUemSfnkvnkuCk1H+Box3pDdBuuRKJSrZZKa0K7XQxTdA071hy9d3d0Ht80M5286gdqtJiXgZhTLZUgVCpBDQD9TPwi7PwLw3L3WmPkRqMccBHUOgzI6B3sbGDVaokTAKQdNGg0hCcSZDDilBKE/rP8ANRJ/oQqj3fEjmc3BlbVNCERihKtAz2hCDw/d/hgC/TH0NbaEyHUHeytaQ6RSzQgtWTr0vLUsrINDI6flxsyh5zvi9698Azpr0OX01WE06kIrf2OOGBr2Tnv6+j+FlRncD5/NZj4/N3v1Mejs0irZPmWRVUSRG0e6uPhLgY6WuH6NRmv1ekcfkZszvFqtJNdWV/5GJHVfJ+4YTjoRnEpZGUlc/9j45K0mk/lDwDOWoPnwy8tLC8+CfMCvAA5F3gzplHGoE6Ef2iqrzQODw/eDTP60dCr1L3u7O7PQTjws1zjRjVdDuDdp7El6ejyD7p6e/xN4OBDtmzZWlhY+w8ukobj434CiAP+6dIjlJQMKG3NBPB2GGPjnDwb+oG0MmjroJ5/TDMNWm3+LadNJHeVymd82TqpptmD9wsoTv4mAIUPQKjqbqjCYHh30CJTieHbs3m4x6MGIXrFVGqNQDKaZBqFe07Edy7jLBfP7+yQ+H5PPHfP0kfLwNdh7AJ+Jy3GYTKBTq0Xd8rE4rGaooO9UCMzvZEL6xcSmlSPtJ3RvqIwr8ZW+23qO7XzYd9/VtfSe9aX9WV+wmLCVUWOevnYdPDs2uH1mkqT9Y1ta2bT6Y6+E/XgCCqgbsaVfje4Lx9q7jSZCGhjNpOHuE0dAq9aQ8ARMKhjNZck5NN3cb5HOppsZGPF9kX5UafCuiig7DFgRgnkDiJUfGueS9lTrr2yVxP0nsllMTw92s6lBDMid3ayx2f+lSpkoHcY8PRCOJaFYqUKuWnT//doP/q/7+89+4qR17AB4mzOaplE1VanFodG6enYKFrPryyHpwyJ17mHKEIwvsY0tGVeYyR/dhwanc+JZ+RsLqlansyPgfJfM6thQ8OBruWw2CuI5qIUL6hsB+iW16n39A77BwaFPo3trxNAVC4Xvz169whHnSKWqktzsKhtdRRS5IaUT6Bdj8Tfw3uvHJ6fOy03dh4QNBg/+PpGI70Er6OdnPOmUuk8umV9LuJPL3dPn7un9beDtP0ul0qWFudnPgTTYeLuEsCnyNhUJQr9u6TO5fQp57/WN3aHRaJxy6kNb/rB/dRlnG5Ly4OyWQaOTpb+ji79erzd6R8d+ryXMhmWzgb2d/5JMJuIgDfglsx8pe5K3jyjAH2pAJhIO0eFwCOqs+li4Ra0+8FkykHDe8HquWU2dfVyNBozQ7Z8Mhpq1nSULFrqOKAHQNW2aMx7orykCaIZgR6puJEbfY2u/qs4zwNckknq2U0E7AuHERI3J+86MDYPdYiKWaJy6Dn9G0RwohVZuP4FwH2Ow63M6CejHye+WgkE46vFgtwMCdnERUyP94HFa21zXGwWxOO2fEcc8AKVm4KXQnKtCsXX6fH7mekr93P7l3gf6zq2Omvr3R8f7d5cyO8PPBF4/WqgUVKF4Er714itw3DcCZydHiQWfuwWuvbhNAw4H+FF7sRU/iMC/Ta8jMfcFBO4dCHiHMxl0P6H6RbUr6boFnmVrMfZ6tYp4N2BlBnbXN6lrYB97FbB1br9GbH4LQUJrh1Ik3p8mx+MXLoPdZICxPg8M9zhJuAFWoFRZPpNALYRChX97NEX32KxwaswLryytkvPUjFqznQ4PIuCPSf0aFhn+86RSq1mjwYifD/JIpdMpnB6SMvBCNSSAPM2x+3Ogvgu4pz728U9Qn/zkJxvM/Z3O59JivvzyS8yZM2cYtNHEpHtkzCDB4weDfqKVRu9bFtW6u7/WNzp+l0qlMoMMQWUvbKz7nwdxC5YwF66cmH45oF8D7Yss7Xb39I94R/8YjZvGZqBcLr02d/3apyuVMr9Nndzp3qreG4ooosgbIIeMKxZl8e8fGDxms9mPy60zl81eXvevPgutwEPK2ngY0CFl6Sdx/Wgu/09oP9NQTqC5/2BjbfVThUJBKq6fm69FQZACOBR5A+WwYTYNFn+r1dZ3iBAbNniw/+VstpFtSMipIcfS3y2dsNADkbxiLDF95Pivov3UJL89iXj8v21tblwHJZPGDS8K8IcacEELbxUNWiFzf2NQISBFBg62SkJz8HPv+ZZ/Xig327D0VzH1fesAErPs1RQB1YpwcNF10M9PCcgJO2zxhKrbCIbSLGXRa8Hr6SEWduA1BqrQZI3ngVcOcAoFf4Zj1DFx3kEqBUUEJNcjERhzuYk1G7cKg1SHxUyAaVsZdZp8DJr1Oi1JZ1eBagP0m3Q6yBYLdS94Fq5GVofv6D3p19MaPAFWpoyDSy6vLfyPW8/fmSpktTQqZ25zB7aCYbjv9FHivcCx99dmaRbsOj1oaBWxzMfzOXDrjbAXT0Aom0E/QAWofKUWb4/+wx1oROfhGHwticfXEnd9DODx91Rdc8FCk9eAoiQ0Jmxrz3H/Ys8Im9EI58Z9cNG/AZf8a/Dq8iqoVSoYdDuh326DHrsFTHotyVJAaqNrGQdyhSLsRKKNokulUvKYdRjHgottzsizkkgkoFwqNf7G10XCITYCIWzxJ5tLsQman9JPZuo+9o8//Sl8gPA6KQUATos5ONCPF7sqb6zgcSVcVFvi5TDotzucw4cg9CvtbG/+HWapBumsBz+Oe78caz/Z5KJ2u0bHJ/8YLbQermB0v/7lpcXfz+WyGegczy/pTqcssooocuPIIV38+YCjYe3X6w3OwaGR8yAzdR+aH5Nr/pXPo/lSCPo7zZWcHMbS32LtnzlyDBOJ8ZQTbCEUPPijUCgYgO5x/W2ZapS5UJE3Qg7BrSF08W8YKLy+sQexYVBOfblc7urGuv9FaPe06eZSD7z2SY3BTh6I9PTM0feiCeMBfnvyudzjC/Ozj0P7GJQK91EyabyNRQH+PMEgCVpd9jtp/LhBzykAGum6oNXdnxswZYmjAuLKALGUOVw7+OCfNVGaqEVj2M5VSiORZAqeeX0O7jmJ3dq55vCk85/1EoHzwyfEeTgGPlsqQgyB6WA6BS5sQa6ZvoEY8FvwcKsqoYIAv9NsIm74DSpB9M99Z47CZiAIV9e3iXUcAXv1SwfX+u/vOzvH9YNTZdp978DtT31/99Vz4ULCjbkB0vk8PPbDi3Da54WTmKCwCg0LPo7Nn+x1QyCRRB1FEzK+RCFP3PUxyMcp9LAVH78nIB9aifZq75tp9Ug8Pg6JgCYBH5/joIPjRPMM9P/U8AAh/3sdgX+Ok2DrIIyOEGAdD1YEOC2mOmdCFWKZLAL+BcAEiKVyqWLTmF591/C5z3lNfZh1WZL0xWa1sqVSib94NQQBb9JctMA1PvtRJ+xOSgHhdzIWVGHcaktcP15QR7y+++US+qVTqWcPDvaXodVlVU4eak7E2noYaz/Z5JotFuvE5PSnGYYZ4QrGlq3NjbX/GI9FI9C6qErF8ynWLUUUeWdIt/lRzNJIwD+aGw3jE5MPqVQqk8y62FDo4Kt1F38pvphO86RUO6XS9hHAgebDu4wm0weB56iXSqX+p391+RX4ETyflLlQkTdB5GTSaEndBzVvm6Po2R6VUwHaB+Q21/1f4indhNmGOqXN5F553sgdY/pbwg69vrGbrDb7L/HKwinH5xbmr/+/OAsSyHPxV7wP3+aiAP9WEWP1F8vdqVvPHoz88/ar/7YMJadRrU+ZVYaNcfPAzinHRKBu6cciBfzFNvzdrH5Y+JNRI6wASeX2nuPfeGrntV+nVLQuiIDvdy5cgtuPTEC/09kCxdut+yLQlecKj93Zx91umA3sERC8FYs1yP74yJejs6MENeD4fqMezY/xROO8494hsOj1cHLMh8B5FZZ39wnQXk7vjNwPZ69CM76QdWtt+x8dPf+9F4PXjr0WWTwFFM1gboGrm1uwFQnD+dMnSCpBrmYNo4JCuQwugwHsRiO4KpiDQIU+V7ekJcTKgBqwb5ANAP+GSJhGrXNr94bq5IX+C7tJZAqse1RQNfA/OdAHI70ueP7aAhyg34f0ElZ40DSJ69+Px+uZEKo4nqRoUmsPHBrLxXP9R58dMfWsQY3UTyy1S6NCth20NiZok8lMp9OpFmbIH1UJwA8NEPlOyuW/25gSWvuJYq1/YOiYwWAcARlSqVQSa2tthH5SWnSpDW030C/UoreBftRe0/TMsU/xXenQc5QM7O387n5gbxO6W7YUBn9FFHkHyI/J4k+OgcHhk2aLVRaLOJZ8Lje7trryNPxoLv5ylaF88E97PP0jLncrkRhmD5+/fu0foH0uFKYPVACHIm+aCMag0JLeNbZfo9GYEfC/D+R527DxeOy70WhkA+SRacoJseEyInUKOyRkfp6+/t9Fe9uGV0I9feYncrlsCg6nfCOi7EnenqIAf55YrTYqkYgLCT6EkwAZ/C8Frp7Psfl78dfxUgaSpewdm5l99pnA5ZxVYwo4NeadIQTYbnJPb7IVFg9sPugvSbwXUwbwJwCuLQ3Xufpn7HHr6GqmmP/qK+G5jyBAqcmXyvD01QUY9/TALTMTLZZqUWkB8fW3das3JpubcvfAQvCAxMSvhEJwxOMhbvWNszFA5rvCN+LeqyRenqqz/FfKVTjhG4Ka5bsKZyZ8EEmmERhOQL5cMl2JLntOOSb90HRhx4Wo7uw5ca3f4Io8Fbh8a7aas+Dy4ukcfPPFV+GRW06D1WAgbcEhCRj4Y34CFQLVWoYhLve1dHqUBD5vJdirWepr6f1wekH8H+b/+xfUnxqVCo6MDBAvBqw8YCWmPU7ZQgGnWEAPDeqH82dPwusrazC7uYN+PBrQPe3OmIcvV4AtIaBYsastewNGxxZ6ZjDBCt6Y8QF/ixu/4DllW9M3tLqIlytl4a/N13YcVgkgy+LfIX0f9wyT8VQn9BMyVaPHRmPpHxi4B2QuqNFI+JuZdBqTdEhlPOgE+rl+kxu7Ksrgr9Xq9EeOnfgDtVp9gte0fCh08LHNjXV+/JzslH0yfxNFFFHkbSRdXPz5wF8yrt9gNLoGBgfvB/ku/tn1df8XBCz+cmOLO7n4SxKJYUXosNf3+2iet3IFVSqV5eWl+T9Fr2Ls4WLej4oSVJE3XEQI/cQs6d0I/d6F9io2OfWVSqXdtdXl74B80M+XTnOEWFx/A/QbjSaLd3TsYzRN89rJFkOh4B8d7Ae6GSOUTBo3mCjAvykY9PM54zq63rFQJQz6DXZ5ApIRRKYpQ6qSHUvlsmP+bODufwlcKlnUlgOTWhceNQ8s3eyeXqZYCgO6ksyDP/gAWl3+GV47q7e6j1y1aYy5pwKvfajEVt14eK7u78N6MASnfSMw7R2oueaL3r3IW2L1rlHwYdd4n8NJ4vwx+F84OIDjfX01aEtAP583oPkPIbmrZwHA//s8bsI/UK02fQTOTY/Cd16+hK3f1Euh+TMI+K9CcwNA1V/ZUVP/3kdHnc98fuWJ8yWoGDCgxh4FT16ehQ/dcTMB6jgtn7HOvo/L9+/tk3vGhHqYiLBSaeKpZnpCES+Ihv6i1geYUNBjs8LF1TVYRWVajXpixZ8c6idZAxohB2zzumbJfIUCwInRERI+gd39dzPh/nHL4Pxp2/gVqKfqQ6Afv3KbMTFWZf7mq/FZuVwWs46Q9/lcTpg3kM/8f1glAF1vk6R0yIfLB/1ShFUkhGbEN3obWlBlMVQXi8X1Nf8qtmKJ5aEWWpDeKNDPD/FhENjXHDtx8vc0Gg2f4KcUi0b/aHV56WUQt2x1jJ8DZYFVRJEbWaTmHaF7cVvqMOziPzY++RDDqAwy62Kj0ci3YtEI3uiLufhL5Q3n5vJODOJiB4NTEE8fOfprKpVqotEIlo1vb23+YSqZjEO7AaSbi78C+hV5o+WwHjeNw2qzDTicrrMy66nuB/b+Hu1VktCd0E8srr9biI0o6EdjT4PG4G+jV34oAptKpT67uiK6L5HyQOxEhqzI20gU4C8Qu91Bl0olMrDQAKWrbJWpVioMZu7nsferevWu3VAyTcy6HrsFzt90EqLJNASiMYhlMrAXjkI6XwA05tQZNj+YKeYG98OxUxdCsxmvqX/2gf6zrxgZHfZ/bww6iqKreaqk1VYZzPQppglk6VruOYS1WdIO9Nri9j9tHdmesXn/+ns7L9+xmNg+h5qnw2nkLq6uw2sItI729cKQ0wnDvS6Sxk4qDR8nNct/DQg79AbImAoQSqfJd5jpf6bX03BnZ+vGXs6yzu0WVCqmRqqH6hr39Dbq5NQEmHHfY7dCMJGCQrVofzk0573NffQ6NMElB6sZPaNNPzJ8x2uPb71wRxX1AQbuWdTPYXSt02qGLAL+dsyaj0MHtgJwyb9OlA/lSgX0GjVMDfaDz9NDwg9kmUi4+6GqCOT3wWYoBOh3hxSq87J/Ay4u+WEI9SW+L0zYh1n8K5xCQcS9QEXSDJYbfvlYi7KdCXoQ8O+2ADQmfdR/Ghz/j9VMLFvFxI8VNKmzhUKRZRhayFhPXnU6He6DKnqlIpFo1elwVNUaDeRy2Uo+lxPTLsPU9BHq69/8R+p973sfX0kgemec4DAA/JpMxOlcLkfhzALFQgGPKQa9F3OfI5tadCs6VLABPc9oU0sZTCZTr8vlksuQWw3s7Xy5UikLCf24/pTizRAuqp0W1o65qdHmW338xOnf0mp1d/Ee/WoymfhvC/PXvw/iSj0lbZ8iirwDRcQbSsq9mAP9euExODh8ymy2TMits1AorPpXlr8H7aCfr2AWUzJzr91yhbeR+U0fOfZ+nU5/nteMUjQS/uO93W3s1dfN80mxMirypsmPQejHKd70Xu/YAzgVsZz6spnMqzvbm5fhcNZ+4fiTw+DfMg6PHDvxc2hfchu/LYV8/gdzs1eFYTalDm1RPG5uIFGAf1MIqInFohzIxA89SY0GtdR8LQvf3QOnNy+HF1idVk+VyxVygd1kJAcWDPAyhQKs7uzD4s4epHM5nLsMx4obN3MHt/7PlW/fNGYenH9k4NYX1cBkMtWc+n8tf/cXcpWC3awx7Z+1Tz52i+sIP96dDMZqtSWJHGcZ4NynsVQxs/m7B2599a6+0/6ndy+e9ad3Zygao2+A9f0grAWCUJ2tQq/NCkMuF1EC4HRzJGVd3RJfq6GVuA+/HbI7IFcqQRoB7Dx6XQ2HYAIz/YuSBtas5VqVingJYMXAiMdNCP9Y3vcIKcPJUS88+fp14pa/lTsYvQ2OXoMm8OdIF0k/eA09+zaNKRYtpFwcwi4TF/8icem3aHWE2A+z6HNx+jiWHqf1u7axBa/7N8Fk0MH0QB9MDHlq6Q67qAEw6z6u6r5Tx+DJS7MQIcoPQkoIu+EYbIcipIQhBP4dJhMYEdDGbP0qtYoQ+GHSRcy9cBBLACYoxBkRuPALg84gBKhiln1V/VnECpsyWyVZEir176pl9BAi0F/lnddy5PN58poulVicxQADcl6/cmCeH1LCLi3Os26nrfrSi8+RxsiZ7HHsf31BrfDK5kSUsIqk8GNZLdvY5LLqYa/vbppmtHIGLl5Q93Z38FjplIdaKhc1v5/FNt/ChbXNxR89W8zxk6d+RafXP8Qrs5rJpP/6+rUrXwFpq5aStk8RRd7ZIgb6xQBHC5O/wWBw9g8O3gsyXfwxcdf21sbnK5UyXrjEvKLkpu6TDfq9vrGTVqvtl3ltZNGc+LdoXfkX6M5zImrtV0SRN0GkFG8drf11Qj+fnApwlqGNDf8/8EJsuindxMafVHiNGOgn505OzdxvMpn/FbSS+c0vLsx9BrVJLMym0xgkooD+t78owF+mCHLV0wjSZa06836BLfdH01kSB1+lKo3hgcGtVqWGI95BODk2ApFUGha392Bpdw9oFhPFqdRrqb2Tf738He+7B255tlgulRGqd+hVOihXy30vBK/9SrScevJhzy18a6GYNpA/EbSAOAOtzfzM0J0XY8X05kvh2aOLsa1BFRKclo6hGAilUhBGgPTS6hrJAOC2WaDXaiUWeIfFBHqtBjgWen4/YLK/uUAASgh3phCI3YxFYcThrBPm8fqs3hi3zQwMTYHP00tY6/nfclQAHqcNAfCaNTySS/ZAE4hy0mIdVVF0mVALAEtS9ZmNOkgX8iSOHv8Wz169TrqDrRfBonNw2xkE8rH+BbPmX1pdh6WdAAHr3l43WE16zNQi4QVRU4jgEILzZ4/Dayvr4N89aJIa1sM+dsIxcrB1t37uOtwm7pdR11Mt4vYYVZrwWdvE8/xnC1rdPVmRz/kxkFWJoyLyviLxfQvgF/R7owOk0gFKiNA9VE7cHDlcLrfPYrHOyBuX1dzm5vpXBQy53Vz8u5HldHOha4B+9Lszx0+c/iWDwfh+3j2zuVzua9euXP5cvQ1ibLmKVl0RRd6B0oH7RMq9uCWuHx+j45Pn0VpmlFklm0jEvx+sZTuRsjY2vAqhM+joFtdPznG63B5PXz+O628ob0vF4vNzs1f/GuSDfmU+VORNkS7Wfm7vJaV806s1mH9ItuKNjcei343HYrsgDvrlKt2kMg2IkgwPDY/MoHH46/VriCCwH95Y9//fmUwahxsI9yZd0wkrY/DGEAX4S0uLOzBheW8FwOyA3v3qWm7//djK7N/dh5E+d9vFGA5isIvJ526ZGoezEz54eX4F1gIHxFpcYMvWx3deevjWnqOzNMM0rOxqlZpGQP28idHn3+U+cRHEtfJYhBMC3/pPBqtdY0q9p/+22Yf7b928Gl0d2M2FXNu5sK1YLpFphWYoYiHfi8YhgA4M9DExHvYCGHQ5YXpogLiwU1QzM8CMxwPz+wEoI5AczqQJ6V2f2SJqTnVazEQJ4nW72r6tJ88jHgEudN4+toiXs6YSVdWpWboErRMP2RCgdlRjhaSNa43dbAKjVgfFShnMOj1c8W9AEKcPxGAbXaWnVbFbe49dROC7EszFnLv54PBBLt6jYdR0pliAhe09mN/eIV4BvVYLjKB2evt7SWgADpPg7plrsYpWwW3TE1AqlWEzGCb94tHbszpQp6L5pDFcjBvUjIbG9bNsnSUAkwBUKRJeUa6UEPhXFyatw1fP9597gWKpFDRj34VEjvyJXsxSLAX+KzKOKohrdyleO1qUAt3AfweGXCFBpjB2lUvfpxsa9t6HAbWcQZpIJH4Qi0a24PBx/XLiVqUY/Bug/9iJUz9nNJn+N155bKGQ/y4C/X8ukR5HlmVLWWAVUeTGExEyMSl2bkkmf5zpxHIIFv9yuRTwryx9C1pd/IXAXzjfS7WxK5mfTqfTj45N/Ge0njY2RJVKZX15efHT5XI5Dwp7uCI/RelCqtkpfV+D0M/nG7tDLv9QqVTaW/OvPAHy+Yc4OYynTQvod7nc/QODw/8ZhyNwhaH9SD54sP9JdGyBtPKtI7+GIjeGKMC/VaSIz6r1FH0tg+CO3lNXVvzf+RmGUTOzm9swNsC3aAulZkzF7v7vOjFNvACeu7YA8UwGFcpqLgTnb+LOMuq1kMrm0bk0dTmy9B6H1lo+ahnB2no+s3tVkEtOSJzGEf817gNB99Jpx0TIUrY6i1EWdmIHPMt0TeGAnfCxVduk14HZaEDgV0Os9U0qvppgwr7Jnl4E/vcJ8A0kEjXgbDRx1HnAzauYgM9pNsKg2wHC7uHAO8bX2D0eqASoaRWzmth2z1hGUiK/C7ufj1oLbFnLUDVuu8n+PgLQsXIhlsrA8k6goaTQUkzy34w99E9mRp8iJ9thA72+nixnLa8FF0bXMoHxaDllR9fSWK+DU+0F40l4ZckPTqsJvD1u8DjtYDHoQa1iiDcA2rxANJmBYqlUN+qzEMsmVb8y9f4F/LtUoMqsJ/cM4WLCECukdflqUYt6rkxTTNbAaDIz9pG9AYM7hJ6qTN0lgUuPwP2O3AZQOBl3A/1CMF+RuFYIPoWa3gZhpKD/yXuZlv+WRRU99yq0+euWE1c7MDh0XG8wDMoZrJVyOYwW1MehtpBKWbHEFq9Omn4pN7oWIj98zdFjJ3/WbLZ8lDfOoFgsPDN79cqfVCpl4eIulaNXAf2KKPLOEilrfyfAQQ6tVmcbHBqSzeKPpLK3u/ulQqGAifTEUvcJFZAA4t5acrhOMJkfM3P0+K+q1epjXAPQ3im1t7vzh4l4LAKdyfwUK6MiPynplklDLMVwjdDPaus7DKHfwUHgy8ViEfN5deMfEu5R5KYTbjFImExmy+j45B/wFW+4/EQ8/udov3QR2q38ssIOlXF444gC/KVF6HrbBrAcGmPcpbWux0qZ8WgqTWK4cXx3Q+qO0zUIzDZKxQDTrNfDe2+9CX5w6SocIKCJ8R+xDSNgec/JGVje3ofl3QDmBFA9Gbj48IihN21S6bB7Dhmgr8QWbr0cXjqBvdLR58GT9rFLp+wT69Bu/ecmOHY5teN64eDqZKKUMTA00/BgwG7+2MLPEHZ6Ftx2C4z29IDbYaux47O1LhDuNLSMCibdPbAcCpKUdduxKHHXt+v0tcxydXJ8fP3EQB9URKYNLu0ddtdniWUcx+MzkCymjdAag80dcCWyMsRgNwWsqKjgsj3kJA0C5i+vb0IJaxHQd+VqqfrQwG1PIdAfAYEl3aIylO/rvyl9H8BSuJBwojJHV5LbQ5lK3oQt+hQqPpbKQiy9CVX/ek0pwtb2RVW25vJP000vALfeHueeD/RNZdwymB+HQa5ebnLnJtoi1MIJ1Lz7436zblZ64QQtBv6FgJ8/wZc6fCZUAnDSGp8hof3tRFiFQH8npmpyqFRqs6dvgE+O13F8hsOhb+VzuRhIu/hLaawPC/r56XLIuUePnXifxWr9d9D0rsGurD+cm736SQT+s9DZlVVJU6WIIu8wkUEmxk/fx3fz57n4T9yH5kmL3Doz6fRLO9ubl6DdxZ/vZnyY1H2SoB9qZH4f0OsNj/DKKcdi0f+6vbWxCOLpirsqQhVR5I0SmaSa/ExDLeE2hNDPRwj9NHLqy+WyV7Y3NzDYPiyvhhzOoTa+IbVao52eOfqfVCrVGK8sNpvNfGVhfvZx6E7mJ9oeZV9yY4kC/AVitdqgntavBfSjgc5Wq9U2YDVo8MzFE/5x7Aq/sLULdx6dboYENFK7iQt2qX/wphPwnQuXIJ7JES//qYF+sOCwgJlxSOXyEIjFMTA2fGf7xfs+4nvgWVzvVibo+mFg9o46wz/EymnLU3uXxuLF9HP39J7GpHgt4D9eyli+t/3ymb1cqJdhNBS2lGOg34sAvlpV0w30220I8NvAZtJDzUpfrSsp2I73gFPnjblcsILAP/YC2AxHgHG7wazVAZ8Z0GWzCJbxpkcAPx6+Fi9P6m3mp291G6f2cuEB3Cx8nq/PTe6hjNq7G4xBKJFqlD5k6lmcto5sQHNzw90K50ZO+smltSYe6D+7gI41VLb7cnh5aDcXdqTLWa1arUYn04SYkK5fxnLcBOjAIRJ2rSHzUP/NfuApJ3hthzJVVV2P+B2xfFI3ZPZExq0DB0TP0wr4NcC32NMUcyWy7FlN7Y6g63rQ81W9s/fU85PmwXXobPHnP598YM8/ioL3Kt7f/HtoeVyhNeVfJ6v/YTa2jWN4xHtWo9E45IxTBK7XNtbXMOugmOvcYRlyuY2rmFt/G2HOzNHjj1pt9l/lPUfYne/i3Ny1j+VyuTRIL65i7Wr4wCiLqyKK3JjSIb2pFIt/i6UfHz09nnGbzX5cbp3VSiXh9y9j5m4pFv9OoL+baz9fGUrmT9/o+FmbzfbvgOdpiADH3y3OX/9nkJcnXFGEKvKTksMy+ZM9Sl8/IfQblVMBdq3f2tz4hzr/kBToF9uj8PeGYmSDYmn7MMmw6ujxE/9eo9We47ejWCy+ODd79b/XQw/Fwg+VdMLvMFGAf13ww+1f26C2tzZErfw41R7UWNRb3KVPOEZXXo8sVVUqNe0PBEkcv4rh8AA/qZ2EoFPec+40fOfV10lVR7wDmD+eWN7vPXEEvv7iK4Sxfj8XG3w1unjyZsf06quh+WMqFUNh8HtkaAC2w2FIQYG6HF25W8/oqre4ZtagPpklSmnr36587zxLU6hZamKZxwR45yZ8UCiXwG4yQ6/dCpxPAj/PfcdG86j+MYv+mNMFa5Ewiav3h0Iw2dsDRnWTlB2z2DcuIJfXbeXVWsQCDjGIp7Pke5wlwaW3YwTPQCvwp9OVvCmUSzjwPWDFyTHvUC0bAVuF2fUtEmpRmzWr+Yf6b3kBmhsMvis9P4a9ZaPRr3el+odcfoqidoK5mGktFbCE8lFDrJjRF9gig7qxinqxSLMUa9WYcsedYxGvqS+OJtUyr2xSXqgQN/wwODu8mt7tVdHoB0NfXUn6QbOnKt7Ze/LqSdvYCggm3YXYRt/VxOrEbi4ygiZyLc3pD9AZ39t92RftOfr0Lc6js+jHb7OSYE+JnVzIli8V2Anr4F6lUuFcOou815YD1YGJHorVaiUPTX4IMfDf+NGHhr00Gid8j4CGJr3X08cc7Ae4fhbb2Iq40FF6vV5nd/f03AbypBrY2/uKjPR9Yg/zjxw3h6+ZOXLsYbvd8X8Ab+4sl0uvo83t72UzGY4wR4w0p1OOXmVxVUSRG186WRqF7sUtoF+lUpmGRrwPUoS4RpZgj6hvpFOpA2i39ovNR1z7AFqt/N3APzmnp9cz6PH0/R4qgk/m98O52Wufhe5KUMXKqMibLjJINcVIhxugX61WWwbkE/pBMpl4OhIObYA8az8nnUC/lGGCEHujvckHDAbje/jtq5TLS0uL839UKpVyIC+uv21PrMiNJwrw50kd9HPSAv4RyMADhbPKNgaMS2MNunXW1XglM4kJ6ha3duHY6DBxdRdNEVeHhQ3TKUXSs8F7bztDmOYNGs5Sjr38Kbh1ahyev76ICfioC8HrR07bJ2LhYqIXf49Z6M9M+uDU+Ah864ev4lmFuhCevdumMVJTlmGMvui52MYQw9CqMme5Ry++XjeMeHqIVV9FXP47pWZnWxveeN/8Fv9l0xtgxOGAzWiM3PdyMATTPT2Y/lRwJlV374fGPRI3+mqFxNbjcINytVwdsw4mocJywL8xQV+L+b0alYpsfmxGIyEOxBkUlrYCkMjlGxkIp03ei1aVMQWtk5kYoZvUQWnVGqpHb6+oGaagV+uoZCmrylVyqkqpStFqhj3rno559M4MAv0ctwKpZz27b3s9vOTZyh44aVpFqSlVo/8Y9L7MVjVbmYMBBPz3oEZWyL4anhu8FFmezpZLZhqrF+j60GRZnp2a1j67e/mRPq0rP2LsCeJvt3Nh55XI8sRBLtafLKUdZaiqGaI6grxdZ95GfbD2gZG7nqFYCmtVuIWHW4Ty9ZQufLcy/kMr5Logf2ezmYbVX/i0ZEiaQ9HFi1uk2uL6UbGaEe/onQyjMsgZp7ls9tLe7jb2bOmWFofPKCHUpPP5MIQLa5sLHT5/euboQ3aH4zehBfSXry3Oz/1uKpXEoR6dAL+iUVdEkXegSBD6SQEO/tzIAX+d1zd2h1ardcmts5DPL635V54GcRZ/sVAoTrqFP7W5+BtNJovPN/ZxiqYb3lqVSmVjdWUJAY6iEHDIiilW5kRF3kQRWvtlpe9DY/A2tUYeoR96/qPr/tV/hMO5+EuBfmH4YRuD//jE1J1Wm+0Xgbd/Q3u74Pq6/w9SyUQMWg0jnTxuFL6hd4AowJ8nQ8NebPHHb6Xi+8VcqMvnnDMXnth7dQIBRGpuawcB/6EG6G+D1K1RAHUlQA2t1kA/d1UNIvv6ewATB2JrOMLnqovRxfFUMavHaecMmHivnibugVPH4fFXLmGCPeYH+6/eqWG0P/QZe6NT9uHYy8HrFVqlYognAUL+W+EIUTaMeNxg0ukII39TSSH0UpB4z1NgcJe5DCZC5Lcdj5PZdCEYhJmeXgT+VS3XUrycf6ReqtYbFZxuD72a1IYUVWH5pHcNy8hKameMcCGwOCzCQ5QXWJGA+4gwBhAHgmrywcFz1zj9CTTjsPmu9e3WC4rShgpx21Ji2+VP77jDubgOW9FxKr5a+EH9LnCTSxRcT24UEfDP1ctnQ/mY7smDS8MH2aiZQc8CTZQqVaLcYFnuF63FKGhoNb4/Y7SUNn5n64WZaCllw8YcdBnpD+wIoUW/i8NkAKNBB5sHYdK36JzKoMmteXb/ys1z8bXxQrVkZmgV6UYGnc+ROqDLdclybiKST0zMxzZ3j9q8+MHmk+DhV7yA5KC50LSSQTIM1njxmZ6JU0i5VGrwRggeDgotNp1yzvJdWRuLq8Vi9djsjpNyxih2V9va2vhqF/c54WaW/xx029RKgf4HHU7nb6Ni+KD/+vLi/O8kk4kIKKBfEUUUkZZOsf1ivCcNa7/Faut3uXtulltRfY78W5w7HOSlOOW3r1tMfwvoV6vVmumZY/8RrT3jvPqTe7s7H4/FoiHoDPoVMj9FfiIig19DKn0fGYtmi8XjdLnljkE2Eg49ls1m8L5AjHT4MEo3frvEXPwZhFuOuHt6f4u/N0FjMLMf2P14ncG/E8mwkj7zHSgK8BcXvqVTijitAf5nbN61l8Nze6lKbqBUqcL19W045hsmSLGdEq8dMUmPLoqQ1532jcDT1+YIa/56Ys+lYlQUhmNGnbYOfAFsJiOc8nnh6sYmBpbq7+++fO4Xxx9+yam2FD7oveu1H+y9djRXLZgwQszkizC/tQfRVAYm+j0w1ONs+sFTFMiSxnahyeKH3/WYzcT1fjdRA/9LwX2Y8fQRIkBxWrja9TqNuoae0bV9BgfOd9o0k9cnw0gxaQ/nYi4EdEkoxDgC/rj65Z39mos/CRmows2u6csMS+Hfi4sv4Mf0t2l219KBvtno6vB2LthbqJQ0akZNKlWRV5bcj06tBoteB4VSGTKFAmH3T1AFu0ani+Xz2eKF0JzjUnipl2he0L1iIkCcwpFcZ9TD+kGQF0ZBwZneqeLl2NLYhcjCcLFUwloCcu/4ebEb9OR3wekhtWoNhONJWN0Lkt/GoNZRf7X4zYcqdWJAQtKI21iugM1shF6bDYxaLVzb3CblYe6DMlXuuRRe0KsYTcmmNWWGTb17NEsl0fecq2ZLiAL3vFcrFa4PucWBLJo6vR7zYAgfafKKFju5G9uGxX94xHe3XLKcdCr5rMB9TiwXtdiC2kkhIQX6a4RVM0fPI9D/O6gIjowRg/655aWF347XmKrlxvQroF8RRd5B8iMAjhYXf0wm5hslZGJqmVWyyUTiyVDwYBXErf1SLv5yQX/DxR+nMz1y9MS/1Wq1t/PqL8WikT/hkfmJHQqZnyI/MZHJr9Epm4bO6x27T+4epVgsbqyv+Z8B+S7+3TiRpBj8mV5P3/DA4NAfoLFobLaALUcj4T9BjbgK0qBfTAGhhNm8Q0QB/jwZGh5h6xZ/PggiQEilVrPlUkkM+BPwf3vPiRee2Pnhh1UqNXVtYwsmh/qIJZ2IYAgdakShlng9PaBdWIZSuQzhclJL19n3MbDkGov/OT3uJfH+sXQGzTQV42NbL5z6N94HrvpM/ZlfmX7vpYvBRc9Kars3kI1YMCfBfjwB+7EE6FdUMDnYD26LmZDwEfd/qIfhsxJ4nd9Awc31WazkzV4iST5aONiHI70e0DCqtivZ+r/BWKrm9o9k1NS/D7UJrsw7lXkttDCOwDiNz+91WHHuIAKGF7Z3Gy7+GopO3tFzwo/+4BQHLUR+UJ9Mw4UkAuqLkyvpbW+JrejoempADNqx5wH+7XpsZrChPsap/HC/4OwHS1t7ML+9RwrcCG8zFzSzjpcCs9YKzapwJgAMtnF4Q5/dCqN9PdDntMN+JA6bwTB6cCqkU3VqLXxl9alRzN2AvR9wpIUZgfWJ/l7wOOwkfIFueAmwcIAJHutLQ7UWVkDj+67W23nCNwzTQ/2E5BB7BTz9+ix28yI3r1fr4Nn9K49yKRZxneVquWzRGiMujXVhyNh7+daeE9eoaoWv5OI/4/zwBwL+cTrD9h++tnhptFq6WCh0WlT54F/rdLpGzBaLrJzU6J5S6+v+x6C5mHIcBvxc1HLZqaXY+/mgn5meOYZAv0MI+q8T0B+LhqF7TL+kRl0RRRR5x4hUXL+UezEBHGhTf8JoNPnkVoLmprDfv/wtaCf06xZX3Al0iClEmamZo+82mkz/CnieYplM+guLC3NPgULmp8hbS6Qy+fBJfUVJh3t6PeNojzIhs57qfmCX4x86TFy/WNiBlLWfjEGbze72+sb+kOaF2OByk8nkf19anH8Kulv6FYPEO1QU4M8TjYpi69pBoas/Bv14wOBBJwr+py1Dm4umgYWtfPAIBuUvXFuEB87UCHhbR1GduR667f6b52Hm+DEE/hd3A41vMWA0aLXNczH/G1uBB1Gd33zxIgJ3FTjIxVyvR5eHTjsmg2ho0+dc01F0xC9E5gcvhOcHKIQ4y5Uy5NB0MLexQ1j+bdEEDHuc4DCaGgR8bdKl8cRqb6kRBnKW/8XgAQL/fSSbANdmzhsC38vCzh4B8ql8hj3hmkwhVMtZo7nYA+agEOuDeso/b4+bWN1xKsRkNgf/P3vvAeVIdp6H/lXIOTXQQKPReTpN98zsbA7cXWaKtEhTkh8tyU+WzPOkY0k+z+9JFKMYLT3p2Xqy/WxJPrLlJ1nmESlSYhbzkrvcMLuzO6lzzt1AowNyLNS7/62AQqGAxizJ3eVu/XNqCkBX1Q1V99b9/vD9YoIDuOA7N0cJ+OvEQ1KNCVZmTPOnm73XjxfHtnPJiMVoZhF0C3xJvJxasL+7C0Z7wuAkgB/72CC67BcrZTglZdVEvgSDwQA/iN8M8GKTsG0+pwMGu0MwQLMNGOmxuWKRegrQOpLvxXJRqBJpt8tmhemBGIz0hilYB6FCwNddMGDr8EhMi1hfYWGd7hoigL8/SsMC8A9V0h+31jZhJ3kiemAwcipG4VIMecZN5A1iMlZ4rnu/dNK9m08+8mTiZjZgcT993j30rXtDk1dF9ld5gQeNhH9MqVhUxs6D4m8sefZbuappvlR7+/ofRctRJ+OTAO2vZTMZ5DbADlTGrClfZu3S9hlVmxZzfx30T069ze/3/2sV6L+J7v0KS78WS67uRqeLLq9x6TB9Xysro81isXh7or2P3kaRtUT84G9UKU7VwEOtHO3E0tjk4k8Axx0+n//XQZHOtFwufXf21o2/AJ3MT5dXiKj4NbTGoRpgN6xPCKi29cb6Xw+K57ydFPL567s729eh7m1zlov/WaBfcwzaHQ7XubGJD5M1aK+ieJ6U/7dkDH4aOnfv10H/a1B04E+kXOVlhPunf/on7MXp83ygK8jmclngqhxUKmXeZDIxlUqlweWfABZOZHOn29t673v6vy1/uZ9jwLF3fArXVjaoFb5RpMzv5I1crQJG3iNgRIDIKP4uHycOw2jAD3Pbu9TdX/qr026Rj5VgNFqAH50eh29dm6FmYQJMB6f9IxkjsFhnCuCuHy13Cdidh7u6xuMmxsAtpDb8W4eH1u3kMSwSEN7lcULQ7QaH1QouuxXcGGtOQDCCR1RE1O312soBCv5dHvp5j4B/DEmYj+9T8G9glRxyPPUw2IgnBOs36V4DMMYa8Bao55Jn8lzJniicdJkIcEXAP9QTQkwMC7tCn2BbyFVzD3ZfwJgmMyiI3RBYPpec779xsjqRKmf9CNjNmBVAVCLgFusKUMCOYQ9o2UfLeb0twqVWtg/gKJNR3EmhDQjokdxwMNwFse4gOG0WAcCTS6CF/ZmllXoIhUgW4LJa4L6Jc/S+ImAHIX5f2YO0hJ34ESkzK/IM8LRVkwTsXxoeoL8JnAbCtnd4DEs7+2AizxSmhOzyuKDL5QIHqQ/2bblcgXy5DEWyz5ZKcJTKQCqXx/yJrixXfMuTR7fe/MzR3Nq4p+8/viVy92NQj/uXWf4tVitj2txgPUPDPLr7ezxehuM4pspV2VoNs16yhkqFBjyQlxRvIn1rJmVT6z75u0X8bMPoiXAkMupwONUDRFMI4Eaimq9D44JWbe3XIsrphCG3yb1/8vz0P/L6fP9KFdP/wuL87PtIu49BB/266KJLC9EAHO2ynKgZxOl+cGjkYaPR5Oq0zEKhMLO5sfYkCNZ+9RypFdcP0DnoV7oX94cjPR8U53IqHFddWFyY+30yRxahszlRBxy6vFSiReqslWLYCqqxSED/HVarNdJJIWgw2d7eVPIPaRknbjfERmnxF3k1zJaJyenfJphkXFl+uVT6/uzMjf8kGm4qGuXrDP66UNGBPwiWfukzeWFT++lR8hAHBw5EOkAqgpt/Q7w/L6RUkzcrayq8OXr3M1/ZevoNBgNLXf7dNhsBqd2a5VqMBtg6OQa/0wlOReo7pUjG9UiXD+wWMxQrVflv6IKuPE76P0pA7LloGDC9IMfUzI8fXO99Q/gy+qczFeBMp6WM2Wa2UXXB1cOF0EPhC7vvPffTCyvpXdeN42XfVj7u2U4eGfZPUgJPgQhgEeC6SHsCbif1CAh53RAO+AiQZxqAsiQIxiNuN/20c5qi5S0kDmC8OyyQEop1RqVHjasJ5HSsAfLVst3KGpWLA+bK4dyQyWimJyE4x5SJCNiR9I4qQ8jnS/7RNYMA1GQEfVg6dX9958qlZCUdQnJDg5hqUQplmIz1wvmBXrCZzbKSRastyVQa1uIJyJfKMjkhgm6HzUz5FfA64YBHsMqLGQsR7P9gZkH0EBDOwewFg5FueGRqQo7BV3RYw51HpdC1tQ2qKEHFSY/fCw9OjqEpqO4HIZ6DgB4VFPdPniN1soHHYaMKEkaMgZC8GXiq7hA8AVBBgNwIi9t7sHqQgFNUAgA//MLhwh++sf/OtxnK7B40pvZDaz9fCgRqIMb4a8T642Yk7ZRfYqQsaZFrJZ/xQTeTe2bt6el9WHHtdoJkOV8gZZMHsomoqpUVC+BFLGrx+PPTF3/W4/H+GjSm7Ht2fnbm/S3Y+3XQr4suuqhFax7SynKitvhbfT5/zOcPdER4iiLkDF//HwrQofSKkuamdqCjI0u/2+P1ie7FMrs5X6sdbm6sfziTludGLTI/HXDo8pKKRjaNdik01ePQYjab3eFI5KFOy8tmMo8nDxOYSvt24vpbEU5rufcb0aAyNX3x1y0WSwPRIFmfXJ+fu/Wpcrmch9brE53BXxcqOvBXCT78iglDfjkRwMhzXEMctJLsT95GnbHd8/791YXU1ggCth/ML0LA65Lj8ZWCACzq8cIGAf9ZAjzDLo/SAV6ugPCBh5FwGGa3dymydBLwh8z+QpWk4wU0iEDzgfOjsH14BGUy3G+drgbvD06e2gzW6szJmtdisjDSlQnYZp5KzEQPC8e2fxR7cGvY1YNugsxO+dj/7a1nw/HCkRWPx/hxFASY+eQxdSevbdSoe3o3xrOHuykgt1nMDSkLEPPWLf9pKBOgOXewDxME/KOlX2pjyOuhlm2bycYsnG4ELvlHKlC32jOr2d1egfwOqBs+tnFl90AE4TwYeLb0UOgCAlWL1BFXj5Z6n0hcm0K6PcGbQPCgQIv+JYyL74vKYJ9vMeUJrPwszG7uQKZYEjMwCCDa67TRdo/39VDru1RbwdiPvAVpQA8KwUuDp7wMD4yPwmish35ufBZU2RTIx/2jEzhKZ8ButcAj4xPQ191Fwbx8txWXwL4MkftgFHkUBE8ARj5I9szghU/oXYA6B1S0TPb30h57YXWDakNYA2vazhw6ByzaCitoqKW8b8dIq9amWyM90fNWm60jTXqlXN7a3Fh7HNqn73sxoN+o2FOyqqnpS+9xud3vhXqYCHr8PDE3e+sjuWwWFQ8visgPr6O/WHXR5dUvHQAOpZWxyc2fzEP2/sGhN5J9p+sz9L765lHycB0aXYyVc6SWR5QW0WDLuH4CNmxjYxMfIGuhfrlgni8mEvGPHezvbUJ9LjwrbZ8OOHR5qeSsUJuWsf39A0P3GY0mdyeFIP/QxvoqcmtorVGkMdAqrXSrmP4GMj+cD85PX/hFm93+FsU1MHXg+vLSwkdyuVwaWqfta5dJQx+DrzHRgb+2qHPaaeUzV7/I5EH11vA986fVfCieP3Kj1fd7N+fg3Q/cLYM2SaiqjwCvAX8ANo+PqPW/z+uX09uB6mhM7Yes/Qjuwn6vTP6mBP3SHoHlPaPD8MTcIgJXw7PJheCj4TuSN46Xgwj90BUcrfg5AmYJMGWWM3uBv9v8PvxM3yOosaz1mv3JXx5523GOK1rnT9Y9K9k931b2wG42WsTsg4JrutHAEMCeg2RqFa4srEDA5YSwzwshjxsiQZ9MFIgx/7jfJ+AfueLn43EY7+4GEysQ0g10hyjwx6avZHZ7CPA/FfsV9gpHznQ570JFCnoXxAgAxovNI8meeJfOe/t3WcHaT93Tnzyc6X8mMTOMZIu86NKPLvjnY70U8NdET4azHgNUGKztHsDO0bHc31iPqN8HF0f6BYWObFWvPyV4zDOLy3SP9x35E143NQ4Wk4la7xkxE0L9pEbDN4Yx3FrfhumBPrjj3AD1kKhJQf58o5kE24bhIox0XxTXEqrMCGECijIZxbnIP7B5mJSvaWSMi4PW8A5fJwhQPv/ND6a2S31LQj+ycLSHI9GHoENrfzx+8PlqVSbL6WRBK9VFK25O05KFsQlTFy79c6fT9c+g7jHCl8vlb8/euvGJQiGfBR3066KLLp3J7aYOk9z8rdFobMpud/R1WhAS+q2tLEk5wztl8dfiPWmZ0hRT1UxOXfhNk9l8WVE0l06l/nh1Zek56Cxtnz4v6vKSSJvY/o74hxwOZzDQ1XVXh8Xxp6cn/5DJpONwNq+Gsl6dZNCQOYcmzk+/y+Vyv0dxDVQ4JDY31j5wcnwch868EJX4RR+Dr1HRgX/HwqgBfwML+lopce6pvev3FqsVp91oMVSZmkkgagNI5QqwshuHwUhQzH6nBH08dQkfDHTBSvIQ1o6TMBAIKJhE6ugQieOcVisUKmUKrGu8lGENNPeY7u7phWUKPG+crPpirnD1uJSxsAYjDHYH4dLIAHzr+VuwdyxYpTdzCf+14+XUHf5zh+JFeIfBWr6ra+KEbNkcV7I9kbzVvXC6aWWU9eMFgj5k5T/J5+mGfARo/b97ZBC6A17K6I+Wf6zLYTYjxvwfUMu/yWCAib4eeG55lYYTbOUPAslS2tdlcSPY458/WogZjJQyH0Z6BBK8+HEaUnn8MwvVWqV2T2gaydZw8ma+sPn48EY+3m00Ghkpb8A9oyME8EfIJQTiPMkFvpXw4h8xHv7q8rr8q91khssEiKO7Pi+58GtkjN+OJ+E4m6Mg/E7SB0jgx/Eq/NymfMykNz3YB0GvoHBWYP7mJ1NK66C4+9IbRuJykLInyAoHELgJkBPgqfklKXyBZzh+8519D31Q5K5ox0SvtmppseSqF7d03xvru2ixWIKdjLpSsbiws72JC8uzFrTKkAQtrb765SqDfoPRaJq+cOlfksX2u5VdWCoVv3TrxvU/KJdLBWjN3K8zVeuiiy5UOiT0k+bGBvd+3BNg7Y5Eex+5jSL5w0T8M8ViERXlt5u6ryOlKHpCnZ+68As2G7U0yuXm87lPz83e/AK0Voi2Av1U9HlRlx+zvCjQj9/7BgYfYlmDtZNCuGo1ubG2gvxDt5u6Tyu7R5OlH48bG598k9fr+xegCGMla7TU3u72Bw7299ahMaZfvU7RWp9Q0cfga1M6Yqp8jUpDHBrHVdULehn07xaT3i+uffcXDkup8Uy10JsopSLHxbSNF02z5M0JTxNwdXiaJsiKqV+dSt0+O9wVpGz8S4kEAYk1aDyQp2CwN+gHzLwW8gus+eIlmgVZ3snxE709FBlyUGO/u3c1gHH0CFi7vR4Kvt90eQo8DrsADVmGeSJxLVaqVZQ5g2l7N/Nx+2fWvhOeO1qzMo32ZuEALK/K0WtbzSYCWDE1oIsSARpEN3u0WEc9HuhyOOlZqARYJOBfcnu/c2SInm9gDcxjB8/HyE9W0g+O1fR2l0CUV4OxWA9t3MLuHmAKPuzOPmd32mnA8AWwfmvv6vB67iAsselh777t7ovCeTzT2Kqm263sPuHfY9dnaRuwryb7euHdD90NAxT0Q8usB9gGtPYjB8M7778TJgd76flSGTTGvu1jJ7TV47KJyh1e8Zfmx5NXfBd0SkyD4ogqZZSPCSOA/ivzq/DU3JJAEkguY2FML/zC0Jt/c8QZ3YUzFm31K7UkzNEE/QRjO0Oh8APQmXD7+7ufq9VqCLxbEeVI9dByp9V6qTZo0s1ms+XipcvvU4H+WqGQ//SNay/8PgH9eTjbfa4GugudLrroUpd2MfRagEPMFz50v8lk8nRaSLFYmNtYX0VCPy0Wf+UcrqxXOzKxJmvj6PjkW1wu9y+C4hVC5sXvzd668WcKIrHbSt2nz4u6/LikDbGmllt9E/D3eL1Rr9c71WFx/NFR8kui4u2s8dcK9JuhTYjN8MjoA/5A12+CwlCLXB6J+MFHtzY3ZqD1+kRP26eLpugWf5Ugw/9TP/g+BLqCSGTGVKoVBonnMNa7Wq0qQb88qOaTG36GNZkkb2qnzQyFchWkPO3CBnBtZR3unxwFl92uwup1YDZCwP8iAf5oDcfPVmMdg+N1fAQ0U5I9qw2kmPd2luNzBPDeWN+ipHb5WlkOAO/p8lFiOQTdb73zInzm8aeFRO2kIU8mbnW/IXwZcwcyZb5q/ub+1dhyatuDFn2D0UC9FiTFBJIXdvs90E0AfcDjounpMBQBSexky3oD4OUh5vXRuh8XClAle2wruv1PD8ZgZW8PMoUyeh94t/IJ33ExZWAMQox+mJTjdQghCluJJAWsWM60dwRjry0vHC/5ZlJr3axBgL2Y4eCn7r5ECQnP6CZo0J7wVAkCX796HY6yWdJGKzx6YZKS+NWz4/GNigTpVBrbn4K+YBfcPTYi/EgdMxqvjwoeyoJHQyEY8c9imAaGExhY2kcSN4HkGYLfURlQ5qrkWeXoPayS7xIhIT6nWEf0isBreC02msKvDvoFIsVv35iDA1JP7EOO/OAx2b/9K6Pv+PdsjUGOhyaLDVmMIsFlK9Z85UKSvrxIPS1I5Ef2NpHQj4L/3ljfHSaz2QcdSCGfv7G/tzsL2gzVypfY7TD4y65zNoL2z09d+BDB/g8oHgAul83++a2b1/6C9KGyzIqqfN2NVRdddJHlDGu/NCe1BP1OpytE1h2duhfj+6GyvbX5P0VCv1bWfjWDfzsysSZr/+DQyJ1+f+A3QMF5QtZBcwvzs/+GvA8kT6iz8oTrZH66vNSitT5Rp/JVp9Kkn/v6Bl/HMGxH2KhSKW9vrK9+D1pb+7W4h9SekS0NE/2DQ5dC3eHfJusoc71UvnJ8fPR/ra4sPQP1cdcJmZ8O+nWhogN/oGCfNRuZGoJ+ZPjHF/hR8lAJ8lmL1Upj2jmOwCwiZCDyEqv/nd0TWzeXV4oGg8mKwGyir5eARIHMr1iqkOtX4ZgASD8BjpgeTwJ0WoJA7FwwSPPeLx4mYNAfAI/FKlP+dfvd1N0fQR1a2FuJ5P2NQBld7stVcQ5Csj2/T4gXFyETAuTLwwNwbXWDnjd/uh58Y+SuRAUqpi/uPjWym4pbEUwL5Hg8BNwuGAwHqRs6WvetJjONQZcI6jgCzHmQQKsUc87Xzalki/n9AMfHcJTPQVn0chgPh+Gtd98Bn3/iWRqz/rWdp6JGMv+ylAegBuPRHrrHsAlq0EeSQ5OtNOnpL23lE94n4td7kK8Ay0DW/7ffc4n0la2ljzz1OkAPA6bR8QXb+p3rs5BMZeCec8MwOdALgvKn3rc8aN8/bCv2CxIeagsv3meGPk88I/WORMLH0/j+CgHyBUy9RwA+3mdM/Vgk/YqAn3oPMEDrLT1H+L/DbAY72eie3BMMoaAKGlEBg2XuHB7BE7ML1KMATy1XK7VBd+Rvf67v0b/iazzGsWuR0tTEVJZyL1ptNgbT95HBYCB/Y01EyH03kQPM5Ddk8qekOZjOD+osua5gqPu+TsYkhhrs7m4jWU6J3NMyKUutRb9dMj/lS5/1eLy+0fHJj5NqX6hfg6+k0+k/nrl5/TOgvaBttbDVQb8uuugiiZYnlNrKqHbztw4MDr+ezHXmTgvJZNLfO0zEl6E5xemLietXz5VsT7R3KByJfECZto/Mw/sE6Hwom8moGfzb5QnXyfx0eUnkjDSaSuWbprU/0BUccLpcox0WxycE/iFcN3Xq4q/l/aMJ+qO9fWM9PVFMm2lTlMmlTk//eHF+9pvQ3rVfuemKN10aRAf+QNP51Vr8SfazLxWLDYNJjIGmlj+fyXE06Ip8cyMb/2kCUpnlvX14xz13CHnZeQkOK6KvVUOPAj8FOEXCu9FQiFr+V4+S0OP2QNjlosDTbbPD66bHCBisqQjepBTxIuAW/4hKh2iXH9YPDmXLcSTgk4kGpeOmBvoocz0qCMpQM187WvR7bS5+N5uwMoZ6fDheGzMGuAmgVoLOeht5kdqAaSCZU4aEC4z0PPT5/PS843yegNoKrCYPabjDPeeG4OnFZTKTckYEvniG1WSCAeRIIP+WSP8KOe95uOQdyabLOftXdp4MU/p9EIj1Xn9hUgD9yi4XG4vAWfJYoKDfoOhH8m92fYeGJ/z8ow8K5Hxc4+OhpFFs+hEE5Y3W/Co9CQbSnwayx74ulCtQIPeoXCEgvyoAe0zZiAoJ1GGwKgURXgF/x/SPNosJrEYB6FuNxqZHq8bz8rOFHgZPzi7BZjxBFSm0NlytfKlr5L+8qfuub5D7gS7t0gJSK/dzw0usWCgobywF/yAwz2qR+tGtN9Z/JwHaHbHk5vO558hLdQnrROqmXtAqX2DtWLOVC1vZ0t8VDIWHR0Y/ZTAYRurjhy+enhx/an5u5uvQOmZVB/266KJLk2hY+7XmJC0rI926ukJDbo+nU8CByvXU+urK56CR0E/LIwpa1Kete78/0NUd6xv4GHnPyhpsMkem9/d2PkTm5R1oPT/q7OG6vNxyFrGmVrYh9E5E/qHXMQzTUQh0qVRc2trceBa0Xfw74dVoBfqN3eFIf6yv/3dJVZTrJT6TSf/57MzNv4NmC3+rMBslkZ8+BnWhogP/s6UVk7/k7ksH27tjj37tz5e/NJnnyyOnuQJ87oln4Q2XzkOXy6mIwRbHv8y+DgBSvDffWKDJYITRLgL+D+Own05BsVyGwUCAFux3OhUWYqlyNZqeDUFho0cBAwFy/DpzSIEvuoCjIqCpkQQI3zE8AM8sLFOwefVoMfTPR9++hSkMjQSp1p3QGUoIeGmgH0Zi3cKvDdMIo6hTG9p2XujEfr+flneYy0KmWIT9kxMY6+uhaQuz5Duej67t6JGA5WRLRTjJ5GjoAvm5dsE/UvnM2re7y7Wq/CxfHOqDsN9HCxHqxtDwBvyYLRcp2HZazGBijRTYK2F8vlyiFvvzg720Pxtbpgb99RZKfA6SZR37Cfu6UK0QQF+FCieEfiCDfp78hhZ8FJYR2fgVfYj3EDu8JiqN7CYTAfcW6rnhInvMDEAbz9cVSsrz6/UT6oIEfs8tr1FPDAH04yPCHz/cc+k/X/aMXiXfC+KmTAOlxUir7o5WL9UmJn+zxeImgPse6EAwbnRne4ta+6E9mZ/0gm4X2y+7reLWE40N9/UPfIpl2YiivHTyMPHh5aWFJ6G1lV8n8tNFF13OkrMI/ZqsjGjRi/X3Pwqdcy7xx0fJL+Ry2SS0jytWW/vbhUDJoN/pdLlHzo19lLxjFelW+dJR8vCTmxvrM9Ca6FRLGaqzh+vykkiH1v6WKYaDoe4Rh8M50GFxtYP9vc+jwQAax4KWR2KruH4l4Jc2NEz0DAwOf4ysUQKK8vh8LvfpmZvX/xIaLf3K9ZGeOlOXjkQH/q1FScGuBv8S6Jc2Mvj4wv8y/Ma//Oz6Y/86VykEipUKfPXKNZjsi8Ll0UHZpF+3krfPZIbAz2I0wlioGxbjcTgpFqCcSMC5YEgOF1danQUrNg9mJLwDAfyDGF+PQP/Z5VUxtRxAl9tJQGAzjhvr7YGrCBDJQalKzhbPJW1vjFyOP52Y86fKWbPFaKagFJnu0SJ/a2sLzvf1wkAkRL0UgKm3SoLDraC/1A9YTbT8GwkAPshmyJYFm9UKj1yYgK8+8wLNa+e0WuBcNEKt1ut7CdoOGnJgdXOfXvtWIMMVTLRHydQa9rihPxyUPS2kW4jFnRbykCuVCOi3In2yIj1eTa6pw2wFO9kE0F9nw687+Nc5GxB4ozs+gvsyuuFXqpQIkH6vctSrgKWKAFapHqAiKBwEEcINGOqej/fcbDSQvYl+p5Z8kJj5xeNpOkCxZ+XXi/hsMcK9Pzg5ha14Elb345QHQLozBPxzYWvgiXfE7v+0x2THFDB5cUPgr+UuqnYVY05TaYPXQxXRTYtJ0cW/6cUai/XfZTQaXZ0MvFw28xRZZG5C44utnRZdy31V2kv1YweGhi9Gwj0fY1hW5hjga7XD/f29922sr96Eztz7ddCviy66yNIitl8LbGi6+WP6PpvNHu20vEq5vLW2uvwtqFv7W5GeAtxeXL/BbLZYxyfPf4DM1UrvAy6VSv3HpcX570Oza/FZ4U9U9LlRl5dIbsfaL49FtPaTcdhpimEoFAq39nZ3bkGj4k3LxV89/pSeP+oxiJ426I34iUalG/DFQuELt25e+5MWZJqdhCDqY1AXWXTgryE4QBTaQxQta7/S4k814B7WfvSegdf/xdf2rrz3IHfkR4K4he092Dk8hvsmRqiLfd0yq7Sht55rLAbB7R9j/rMEZC7ED2Csu7sB9OM1ENxhmr+a0UQJAQUmdwEsuhxW8NhtkCmWIOhztcxfjwB0nID/2a1dCkxvnqx63x69P3HJdy5fgZrpbzce6z4snZipJZm0LVcqw5WlVXL8Dpzr6YGhSJBmCKiIfAJ1Sj+1rbwx6RyWG/F66NS4n0rDxlESJiMRuDQ0AC+sbcB0f4yCaIzb30wcipfh4aiYklnrEOzaLBa4ODwADrJXtzGHAJ1sGAPvs9llsE3PlUzuIicBBevIVUB+klzvi6RvEdTjhhb8QqUCVZ6joN4gA25FwDleA5UhouUeVQtmUn+Mu7eR+2M2GSgJosMk3C/8vUY9FPiGrpJT8Ym/NSbtEz5SosRMBg5PMrB5mITEaYqewyqUTBaDCQZ90dlha/jLI44oWm0wLg3zIWqBfi1yGLlHQ6EglEulTl6q9MVqtlhcga7g3Z2MPdSgb21tfgmaQb8WO67afU4N/CVLPzs6NvE6UgeMV7XLz3uttrW9tfnbuztby9De0q+Dfl100aVJzmAQPzN1mMFodIZ7og/dRpG1/f29v+E4DuduCXC0IxTTYjPXtPQbDEbT+emLv0nAv3Ku5nO53F/Pzdz8HLR3LVZ6h+lEYrq8pPIirP0Nbv7hSM+4zW7v7aQsDPPd293+O5FUsx2vhjIMUWv8NaTs83p9XedGxz5OBqKyHphW+JsE9P8/ZMwrPTLVln49xEaXjkUH/mfLWa7+DeDfbbDHf7b/0b/+zsHVdy4ebkQJujMhIP/ujTmIBf1w+dwgjT3nRf/+syzj+DsCQ8nyj/HgcwcHMBoMUbBYP52HCjLpV3lK1meQU8YJLuchnwcy+wno8fmoRb+VsmG8LwozG9s0XH4tu+cgQMlIJjgmVcoY97OHJrI2oGEBrGixxuvkimW4vrYOL6ysgtVihv5QF0yQ63gdDlq21I7GfWObsT8iLi8F0runp7BA2nphsJcC/eEeQdGRKRTgKJ2lxIbCpQTrNm7oeXB5dEBIZKdSrpS5CpzkcuC2W8FptlJrvZH8hxkFkAMB+7QkkuiVxc8I7CWmfAHYS60V2QzIb2aR+JVi9ZqgOEDlBFrpLQTUI7g30e8mCvapp4IcfiBmBRC7AMtShn8oHesZsa3ajyZD78XB0SlcXVoXsi6IHgaYMcBpsCZCVt/qQ7FLz7tr1kXSV8janxU3ydrfynKkfpEJ1eH5TtNU0c+xWP/dRrLA7WSwZTOZJ09Pjnehfeq+VnH9StBvADEH9cT56Xd6vd5fJ6fIxFkcV51fW135rcNEfB/aL2alBa20oNZfqrroootS1ASj7ebGhtj+vr6Bu8xms7/Tggr5/PWd7c0XoJnFX2uubuUN1WTpx3ny/PSFX7bZbG9RnI/cRl+buXlNK21fK6WoTiSmy8slnVj71dxDVrJ+skUi0QehU2t/Pv98/GB/AdqnGFaGIbZLLUz/5vZ4/Ug2bDAYB5RllculJ2Zu3fh9MYOGFplfKy4mPcRGl5aiA3+FIKO/xOz/wEOPwPbWJtk2wG53MBwB1eQl2JTKD5rBf8VUY47fFrr7i490XQx/f/+FO5ayO0MESBt3jk5g9/AEBsJBCrAD1OVeYubXAP+yuz5NgC4T/qHVee5gH86R7+gOjocgYEagV+EwfrxCXdkZXnBJ50XlAYLwsM+r3XjRwuywWihr/zEByvlyyZCp5q0uo7369Z1n/AaTiekL+mF6qA+Wdw5gcXtXsGqLAByVBZUKR1n3l8jfY11+GI9FoZecgx4JjcsAocCaaNXG2TFdKEHQ4aQu84fZLGweH8PDF8blsIC13UQd9IOQ1g6t+w9OjgqEhTKRIsh9gn2VL5XBSABxvlyGk1yBWuzRik/TGTKS5V8ysUshGQicGZA8EniRKI8CeZORuuKbyDXRio/u+VYC9BH0S34WNSEAvx6DT/5xYi5AGdwzynvO0/uF9Wlk+ZdCIupZEup2f+lvNZga7IP+SAienl2Cg9MU/VuF56DAlUz9rsisi7PMkXPT0Gjp1wL9WtprWhmrzWYoFgqM2WIxlstldeo8KY2fVUzjZyUn2Sxmi7vTFFWkHQUy3r5Czq1gqirQBv1aeXm1NgPK+emLv+R0uv4ZNKSjqlxZnJ/7UCp1egTtXftbxa3qoF8XXV7jorIytiMZ1QT9FovFE+ruvrfT8hB8b21tYMaREnTmYnwWmZ88V06cn34XmSf/CSgWIZVK+ZnZmRt/QNYoWmlNO/GG0udHXX7scpvW/qYUfmjtJ2ubSCdl4bpkZ2fr7+FsTxs1i79S4dYA+p0ul2dsfPKjRqNxRFkWjr+5mVufILgjB9pkfu0Ub1T08aeLlujAXyUI+qU9mVDob/l8TqnF07L4N4F/3GysOfO26H03Xs9X9h+P35xYSG0ECThmNhJJWIsnqPt9byBAQKsX/G4ntdRLbPtUGKYOZEGIAR/vJuCfnIsVQKv4EDnfa7PTGHun2QLZEi9a9Otx9CxTJxD0ux0qa79YguimjmneYgE/HGWyYDabYSO9b62xPJOspC2oFHhkeoIef9/4CPT4vPDYrTnSKazook4AL4JlUeGAio6twySYTSboIcA86HaB0yakM8QwgXyxRMn00vkCnObylLQOFRxvujwtpKwjlXLa7CAAcRb2T09AAuhhnxsuDPZD2O+l16Pu92L6u3K5SrMEUHd8sS9Yhm0MrsB0eAZG8BAA0R2fF1LpobXehnUxm2i/Uou9ySR7WPCigkG6N1KGAPyFU9w/uZ95+XYK1n4F8SJPyxU4BvDe43fsZ/wNv+OeYernSHH9csy/4la6rFa4b+IcvLC8DtvJY9qyUq3qe/zg2ruGXT3XLGDEF4i0SWR+LUG/3e7AZ1/J5E+TCmQzGdxLVvWGxa2Yvk/am3pjfXd1au3PpNM/OD09QQu80n1OHddvUOzV1n7Z0k+eXcvU9KV/RV7o71D0El8ulb45N3vrU6RdWWhv6T/TkqW/VHXR5TUvrayMUgq/ptAnaesbGLrPYDA6Oi2IzI+PHSUP16GRxV/NxdIKdGgCfhDCoB71er2/CgpywWq1OrM4P/fRYh10tCIS00G/Lq8EaZdRo1UYogWt/WHB2t+R5HLZK8nDBI7BVkq3VoYJTdBvdzhcE5NTHzGZTOPKciqVyvPzszO/S9YpKTibzE9znaKPP11aiQ78OxMtgr9OFAD0u9VgLjwQOr816R/M3Uyt9Kyn9i0IRDOFIizs7MH89i7NW9/lcUGsKwB93UEwGtmmhHgoaMmXLP8I6NeOkhDzEVDtcBGQCuC0WKCmRoRiExB0S4R/za734q/k7x6nXcwOAJCopCyb2X3qVoCs/3LEPpLydXfBHbkBuLG+CQ7WWnx95PLyaTnN7OQOXfuFo1CRK9tYApaRzX4rkYTtxFE99l62dtdJ64olAtYLJZhZ34bzA71COAEF1YK7fvw4BW67XeZLQGC8dXQEyXwecxpQBYTMfSB60RvE1Hr0xomx9ibSFuxHBPNGMe4eCfVo7L3BCIIngqQQqXtd1Pg63JdSEuarZUiR8itcjd5DiwmVBhaqxDHKLAsAyjwOvOzmL/yNFbPH8ORRQjK+lb0DqvjAtoY8buj2eSHodcmEgox4nqSskSMHyA7v8YNTY3BzbRPmtvboYQWu3HUlMRd5OHQB0+NJMf1SfJr0MmlihSUvHfmxUDws7RhqG0j9CPhGa/+dnQywWq1W2Nra+CpoZxSQypas9gZotvbLJH4Op5O8TKc/SMq/X1H3WqFQ+MzMzev/oVIpF6C9pb+V65zUH/qiVhddXsOiYWVUk/qp3XobQL/d7ggEAl2XOy2vhun71lbQ0qh28W9lbezIxX9waPhOMkf/H+QUeS3Icdza6vLi+9Pp1DG0D4HSY4p1eVnlh4jtF6390Umr1RrupCxMK7zTzD90Fq+GWvFQB/12h3Py/IUPmUzmaWU51Wr11sL87Aez2cwJdB7Tr4N+XToWHfi3EZHkDz8qA9PV7P5ql395e+F4MTp/unUpUTqJVLiqkRLBIbmb2SxYd0HIr86LaBgt1hwvuJk3eIFLIqI8yfK/FE9QoL59ckpBabfTTc5jwcQySqOycA4p89JQPwWn7UKZqDs7Aa0IutH6f+tk1UYbTIDoUE+3EMuuSCE3NRQjwH8L8rWidTeXsD4avmP+7sBEgdSrvJLe8ZD2Rw9Lxz1prugvVUtGlmcNLLrr8wILPy1TdHGn0Jj8bUOM63fbbSAheGTzH4mG4YHJUQHA1wTPBrT0Y5MIhKdhAAj0WUaIwTeQfjBI5HvkGEylh1Zxr81GwyIEF35FbzAg9L8S6zJaN6GuJEFvgIrFInIC1CBfrkAFQTu+VxD8s4b68ZIaQORkQMFQBKneGDow2d9L+3lpexeur23D3jG5t6vrtCwM00DFUKw7QI9FhYXBYKTlCsoEnuoT4uSc40wWpJtkNVgO7wqNY1xoOwb/lmR+ioa3ip1TLm7lrTfWf7lTJv9sJv1EOpVKwNlx/VrWfuk76yer2JFzY58g5U4qLl8lL9E/w1Q4tVqtlcuc0r1fKx0O7U39haqLLrqI0i6muJ2bv6VvYPAB8o61dFgOf3xy9BVF+r52/CetrJ1KSz+dM6O9faME+HwI0wlKBZH58WBzY+13jo6SB3A2g786bR8VfY7U5SUWtbVfDfrbWPt77uu0ELKGePr4+GgLmo0TyvAaaa9m8W8YgxT0T134sNlsvkNZBgH9c0sLc+/PCEo3rfF3lou/vkbR5UzRgX8bUaTpoXH+ottzq/R+MvhPV3KWv1n/zi9kudIQS1AoQ8CfSczXHvS4qcs7WnPRpdtpt9I9zc2O7PxVVfJ4JQiVhzMDNqOZsvujuz+CyL1UigLeLodTdEVnGtK9mQhA9DhtBAwbtK8NdXCKoN9IgT8npOgjf8C4f8p0r6odgvZRAsiX9vbh+snKwN3ByQWHwVJCdvZhV/SUbCvYNwhcOb5mOSiddBVqZX+5VrEmssfu41ImUOCKtiJfsZZqJVuZq5oKBDzvJ0/B2++Q6fSCPjeci0UoWMd+xDABtNaPBEO05izbnM8eRbLc4znxTIp6WeTIuXaLmYZICEoCtqEveF6hOGnJuygS65ED3VYbeMjGUYVEjfY/EvkxWkoDhaeDxAeAwJ01MHIaRuQPuDA0QM43wPOra1RZhGfEU2mIn6bgmcUVqswQlEjotcDSdqPyoVQqU64FsWzearDu/cL4Wz5q58xS6j7JYnQWg79Sgy3ttTTpmi9Vk8ns6gp2yuRPrf3fAG1+gVagX1kPWq9IT3Sgr3/wk6RfYvVr88XU6ekfzM3e/DJov0Alchw9B64uuuhypnRg7W+XL9zidLlCPp9vutPyqtXKwfrqCqbvU8f1S8BDknYuzkrgwYa6w9FYX//HyXvCLZ3M12onuzvb7zvY39uAs8OgdMWoLi+rvMiMGvLWHY6MWa3WDmP7a8XtzQ1cQ5yldFOn7mtSvLUC/Vy1uri8tPC+09OTQ2gce1qky63CEHXR5UzRgb9CVCn8GkQE/WrLv2aKv7/ffvxn83x5WMrVHu3ywsXBAej2eYDjajRuW/ZFF4dqtaok+QNoxFtqEY5Ba/NkOExT/eF1t05OKHDsdjWn7DObjOCwWlVAtvHaUhQ5HmsiYLJUqbPLo8IC3dmFNIHQ4AJ/rofUYXsXgajpmfhM7xt77kSQiQsUKX68SurFEzha6LH40RSNPujWCUcMLQ0YxE/3LxwtDzyevDGKbXDRsIR6W71OBwXZ11c2aLrBKlel5Y9GI3D53ACZ2Y2yNV0iNJT93xnBQyDkcEPeXIZ0oQDFcgWybJF6T6ADAlUcSJ0mefiDRLyvdQ/q90f6lMrlIHGSgmjQTz0LeM2jpcAD4ROGFvBiPSViP6F7efLM9IHPYYfHbs4LnINirD8CfXzi8J5nikUp4QCw5CBk9S9VKjWnybobswe/+FO9933dwBnQZaxVTH9bchjQtmopLUctrP19dxiNJjd0IJlM5ul0KhVX1EfLgtUK+FNL/8Dg8IVIpOdjDMvKDNmkD1PJw8RHyMv0SWgE+q0IqpQKBx3066KLLq3kLGu/el6UwX9f/+BDDMOaOiyHT8Tjn69UKhlotvbfTuow2dLv8/m7BodGPsmybFAuhOdzBwf7H9ze2piH9mn7dEujLq8kaWftb0nqh+TD4Uj0/k4LyWC2odMTXLe2yqKhHn9q4N8e9HPcElmn/PbJ8VEC2sf0tyMc1tcpunQkr2ngrwH06fdAV5A5Sh42xMxZbTYWGc0Vx6rBvwz8K9WKSXII9xHA+pY7L9Lc9mWyKfnYFThTBoP1CHK18NQSjVHqLFOPZUfgOBHqhrn4AUWp6PaPv4edHkV8OYDP7RDi1xleBsWMlDauwaGAB5vFRME/QcdyzZB/QD6HVrquAwl4BNI+dHNfze8OvBHuvAJ1TSUuVqpQL8ko9leDdaLCc/zTyZk+iZQQ3dnrvPYCo/2V+RVY3N2nCgBK1kcOXt49gJW9ONw/dg5GeruhJpH3yeR3AoqXrO8Y8oAs/CUMEZDT9Cl0MI36GHXWPc37Iv3V53BA4jgFX7tyHXq7/DAa7YFwQFD2CEoJMYyjsQThe4MyRvgbehDEQgF41wN3wjeev0luR1kusd8R3jIyTIYlQJ/jqqkyWRhWoVYOWNw7Q+7o6ogruoyLOai79sug32AwVMiLpmI0mWpVTMPQAvR7PF42lTqVKqUVO6cV2281Go32rmDHTP7F7a3Nb4A2M7X0IuehWZsvxfmzY+OTj/oDXe8j99guXbdWq+3t7+2+f3NjbQa0Ab/S0l8D/WWqiy66nCG3Ye1Xpg6T3fzdHk+YzKuTnZZXKhWXyRz2NDSHZrWK61fyCzSBfofT6T43NvEx8g7oq5fCF8l652PrayvPQ/29fRbg0EG/Li+btBmHrWLr1db+czabraeTsmi2oU2Zf0iLTLOVi39DeE0b0L+yQkD/8fGRMrymFZGf5vjD6+hjUJdO5TUJ/FWAn4n1DbD/46/+P/49//Tn2fjBfo28BPH3et44hMs8r5xgqLDUpZplCPCSBiIdoI/23PXZL2w9PmViTQZkx59Z24bx/qhMVIeiHKHyyFUAVOl7TWZ95wXAz9RJ6mgdMDacAPrJcAQW43GokL/tnArgP+LyCK7xgKR/NpByyOO+wlVpjDi14PMKEjpysNVkpm700ryG1vWI3yvWTe34ILinh7we2Ign4aSY8pagYrWAKQ2NpGlS4yVrrjRB0mNunCx1ccDh4giGI91KCj168Pp+ghIhYp/TdqgA+5PzizSV4UR/r8iZwMgKFaXLPf6JFWPzpfR4yVQG8qUidLld4LLbG+5Da8Bfb7/8IKEHQixClT3fvTkLqwcJsJtNcGGwj/zeA+RRoaEAypR+grVeHU8g1RzvPQMumw1+9sF74JvP34BEOkMfzO38QfinYw89OegII8NsVrFR1n7SB0oSPyUhVJm8aOhLBEE/WYTy5DufzWb4QFcQlAovAvqVgFvWphNgbyYXsho4ziyx+NdqjBUzHWKkQk80dtFkMvs6GYuZTOZK6vQkDi3i+hkpZkEYf0rgT4Nozk9d+DmymP7fyOGyBY20Z3FjffV9ZCxvQ2sSv7NYqfWXqS666KIlnVj7LVpbLDbwIIMxXJ0Jt7e781ky90mcLEovrdtJ3UdBv9VqtU1OTn+IzN8TijIqpycn//fS4vz3QTueWO3WLAEe3b1Yl5db1GGIZ5H60Q2t/ZFI9AE4a3knSiadeYqshSSPRKXSTell0MraT8deW9C/vPhbR0dJzGakBvxneSXq6xRdXpR0+gJ61YiWpjCdOoWBgQEml6WEaEqXHXlC4arVphgi9F7n+Zpaw2j0m12FtexeqFAr9SNQ3U4eUTdsZKLnG3zw60BasvoyoACcorW6ynOQLSN7fAFypRLNR1/CtHXVqpC6jwBKjMkPOJxwnM9TwJhGF3Dyu9siuZzzDdZsjucoCDYwLCgYAegB+NvqQZym3ONFhvt7xkZE7/466Fd+T+dycHCaRg4BxsFYVyP2gEROonZLVMch0v1349cu57mSAzkOHr04ARaTWT48mcrCd2/MUuI/FFSE2A2WtAGYKukHE0WApM47R8fUoh8QvRMEU73S5V9qotjXIhEgfrm+ug7PL2/A4Uma4nCfywlnvxe0iQAcNguNs8d4fLT27ySP4cbKBk1ZaEROAIe9rtRgpMdQmeWAAabxSaC7kZ4wnGRz9Dq4eFxJ7fSe9w8/bWYMaJaXQT80MverWaCV7v1cqVTkyuUyfYEU8nn1w6mZlqZWq5kZsoEYooFNJs3AtFQOg8HgGhkZfafBaLTDGYJ5qddWl/57sVg8hrpniFZqKmUdROWDyXzh0h2/5nS5f0nJSF2pVJ5ZWpj7raPk4YF4PUlLfxYjrv4y1UUXXVqKYu1wViyxTdxwTnRKm8fjjfX29b+ZYSRa2/aSz+deWFla/CI0ErJqgY9WZGJSvQwmk8kyfeGO95ktlgcURdQy6fR/np258TlojiduFVOsh0Hp8rLLL//yL6vX6OpxiEYkeX0C9bHoCHWHx7vDkY6AP1nrFFdWFv9LqVSS1ijS+FAr3lqRaRocDqeLgP6PtLD0/5+3Cfr1tMK6/NDymrH4q638ik3+brFa2VKxqDxGfawShNDvBNiztVpNTfJXeVfsoc//t6WvXACDwYtA+ubGFgXTl0cGoT/cRWPOlZZlgfetmWgPKestrIla9YvGMnVRL3MclCtVkUSuQo9mTRYa+30+EoGleBzylQrsnpzSSoZFy79UECMC4RpTA/RVwDz0FoNJ/ivQBtYDDqwmEyWrq9WqEp294khBkIGfeiXg1alVu9E7AuqTZFNO9Hjp2J3InwQxPh35ELwOB3Bi9gAEuV+/el1WglS4Sm3KO/zC23rveR5z+O0UD0PPJham17N7I6SO7NPzy2C1mCAW6lLcRMmVvs5LoKyY02qBByfH4DvXZ+Hg9JRuTy+uwFAkBGO9ERrmwHEya4CqSY3NFC7PwvRADLKFIg1FoPeY3JvtwyRsJg6psqE/FIRzkW7wuZ2UaBDvgyIAQ/UIiqWR4t5w8Tw8O78C87t7UGN531c2H3/0PYNv+u+gDfqVZFBNoB9aE8O0eubpwhLjU3m+phnbH+mJTpLFZVcnYzKbzbxwenJyAI0vNIC6t41WihzGZrfbJ89feJ/FYnlE0Ul8qVT88tzMrT8sFGgewk6Y+7X6QH+Z6qKLLq3kdmP769b+vv4HOrX2k3d7ZXtrEwF5OxZ/aZ5UWzkb2PtZg8E0NX3pX5L1zSOKImr5XO6vZm5d/zQ0A/5OXfz1eVKXl1yUpNugrYRrFdtPrf09Pb0dW/uzmfSTYrahVpmGGrwhFeXT7y6X2zs+OfURk8k0pbwuAf3LBPS3s/RrKd50pZsuPxJ5TVj8W8QDKd10JKu+2l1IGUusZhKnn8kLWjnYZQs2Aeucx+zaWjndvkCQngUt0pUaB1vxJKwQMOiwWMDvdshu6XLtpIqK5HkSxEawiDH66KLuMJsJWLVSAjl04TexBoGdXjw66HJCqlCggD5FwCdasN02q8BWL2IpIQSAoXUqVio0rz0tVwT128kkZPIF4Ml3P7keEviRyYpayRus/qKXAnofYKw9V6vChdDoptvsyCGZH2gztDfEYP3D3tP352tlf42rwQMTo7RtAILy4UtXnqdKEhojUKtV3hC58yuvC124Sq6G1y67jY7TCU//qtlgSm1m9gcI9jdsJpIQcnvA5bBBozS6/EtMANgco8lIQT66/WeKJXrkSSYHC9t7sBk/pGkMsR8MNNRAan0zG4P0G143FvTTa6SohV7wVGDF/ktlc7C6n4Cb65uwuLMP+UIJY8nA6xAyDUhhGbLnhyhIQuj3uGBuc5f+fFLORvtdke+5jXaJtV9i7m+V71mZrq6Vu6aW65wct4qREiC8SB3KjbTLMXJu/J2dpPAjz311Y231rwhIP4Jmwhy5uaoxyPr8geDExNSnzGbzvYobyuVy2T+/ef3avy+XSwXoPPe0Dvp10UWXM+WHtfa70dof69zan81mHt9YX/0ONGZikeYztYt/SzI/Up5x+sKlX3I4nD8LCiVpsVj44s0bL/wHVXpTrZhiHfTr8oqSDqz9EtBXWvvp1hUMDYcjPQ9Dp9b+5cX/WiqVkBy5E+/VBqWbx+MNjE+e/zgB/Q2cHpS9f3nxt4910K/LyySvGYs/NMcDqTV2LAEshmoVx1sDizg9x2AwsAh8oXmwG6DZsk0B1oSnbyXqDP7bb+xeecdm9uBuI2s0IHBDV/3vzy7AdQL6Lg32w0BPCHiOl+PRedmqXs/7zihqz/BMQ7x9/XPdsD3eHYalRAJy5RLsZdKQr5RhOBik4B/EdHMoR9kssIbGtQiWirnlpZkt6HYLoJWmlVNqJ+qKBATOeF3WYIS/X//+T1V5rtbvCi/84sCbMUaRq9e+DuLw+2kl7yR9M2AymGnWgd5gAKqCxwBcW1lHhnr6uVzl+DdGLn/xDt+5WWhMY4TXMd3lH7vhNjsyX9166l2kXpZvXLsOIz0RuG98RExh2ByPL98tSSFCfnvTndPwpSevwmm+QI/B+5XKF+EqqcuVxRUY6O6CqcE+muWAq9Wg1ftDIk68f/IcZK8WyPXycId/dM/KmHI3j5cj6VrBYWJN+FyRNlZpOsSl3X16bsDtpGSJZvS0IHWQUz1yNerqn0ilQSJ7NLBG09Xk/Fi096Fb0Ejip5Wur5MUMGpPGHXcnJHcT7U2nW6h7vA5q9Ua7mQw5nO5maOj5C40usypx2dDnSI90f6+/sFPqNP1pVOnfzg7c/NL0BzL3y5GTgf9uuiiy+1IO2u/5pwobX23Ye0ngCO/ub72BdBm8ZdEKwxLTebHTk5d+Bmn0/XzoAD95XLpuzM3r/8RWc+ovcE6VZDq86QuL4u0sfZ3MhbNPT2990Pn1v6n0mlq7VeOBYD6Olb5uWHz+fxBJNEkmGJYeU2CL+ZbsPe3Av16eI0uP3J51QN/DRd/FrQnDFa03je584NA7icle9fSNKoVAJIbccVtsCX/Sd+jn90uHD772P4Lbzssps4ZDQbKy58mgPL7Mwt0iwZ8EPJ4IBbyU5K5Ks0HDzIkkkj5GnPD14kAmy3PPIyGQrCaPKTx/qfFAswfHMBYd1hI/QasIkKdb7oAegTQ2YbUA8EuHsCCEqGp3NzJ8SajASrkeCMB/+QfGy+cTD6euHHP64IXfqCoYsME+fjBC9Mm1kwn0fFYDwW3KEgoeGN9S0izR6TP0XXtsv/cNajHbKtJAi2jzt5lJvbA331l+6mfIeDQsn6QgNW9OEyQ6070RcGF4QgaWJ1n6q3CmPxLQwPw+OyCUpVCBQkPdw6PYZtsEZ8Hzg/ERN4G9R2pi9Vihl5yDCpYCOAP/crwO568L3h+Ybdw5Fw4XQ+s5w6ix8W0z2qysIL3BA/HmRzZsmJURT00gQdQlIUKohoSMOxcCpx7ArSt/LJrv9lsrpXL5aYFXKxvgNne2tB6ibDkHAM5pxVxVNPiNhKJ3gedvVS5vb2d70JzHmipLPVDBoNDI5fC4ciHGZaVSQPJmDw5PIz/7srS4lOgDfhbKT2UL1N6Kf1FqgtKu5SuatGfmdeGdMjkr3bzl7yiLG6PN+Jye8Y7LI5Pp06/QwAHenB1krqvlYs/Oz5x/m0ej/e9oJhTK5XKc7MzNz9J5vU8tI7rbwc89Odel1eCaI3Ftgo4r8/f63A6hzq5OGYb2tra+Ba0dvFXfm7wTAwEusIjo2OfMBiMfcprEtB/a2lh7v2npyfIHt4p6Nc9bXT5kcurGvhrvLC1AL9suec4DhnLTQTsSozihmKRAFoTBeFsi2thaDmym6NbHRKfSS9l6WVJAUjMFtz+paG3/vV2PjF4NblwOcXlek/yaQ9jYI148O7xCeyR7YXVdVpI2OcGn9NJreDopu91O2gcvWSpl9n/ecGFvMoJ84I6gh2t/BtHR3CUz0GhWoGZvT2YCHdTAj+8BFqT8fy6V4GAtTiRfd5ltUG330Nj3Bul0ckBU+R5HHYam3/nuUHYSBxS0H3rePU+AvyvQGM8Il2kFLiSYz23P44F16o1OBetG4uvrwqgX2gfV3h77P5/gHrcuhr4m8Tv/DlX7/o/jr3uc1/aeeJdNWCc2E8LO/swv71HlSrT/X0QIqCdtk+ElcrsAXh8X7gLunfdcHCaUrSTl3sXd/snKdg9OoGg1wUXBvqhNxQQlDM8r7gmUE+OWDgIy/tx5GcwfmP3ytDPDbz+StQWSJNtgxzyTIYrWq8kZvr2CsmBVCkbzJbzdrMRvQGMQjAC5WPAhjKokEFGyZzT6Hi61x56/K299zxLXlJSjudWqV9QY0QfEKfTBQaDgSGLUcZut/Of/du/hYvT59VpoehGhgLyVxikZ7tUKtEFLRkjFonNX9oCXcE+m93e8KJrJYV8fjV5mNiCxsUsQzkaGdZYrVZqpAxekvGJqTf5/P7/HePzpGuQem3t7my/f3trYwEaAX8ry5WuPddFU1qldT1DeOk8/fl5TciLtfZbbye2v1bjMuvrq/iuaxXXrwV2lBZ/Cj4I8HjIHwj8K1Cs8QjwmCPA48Nk/s1A5zH9DV5h+rOuy8slCmt/K9Df1jAR7Y3d1+k4zKTTz6ZTKQTorUA/gIbxMBjqjg4Nn/s4WWNFlderVCrXyNj7YCp1KoU26qBfl5dNXtXAX5R2RGVN2nLycpTj9/E4gospkCfgqpXWn4IjEFygG1J4IJDhhSB+2QMgZg9txfpC6OZjK9TKvscOnr+0lNoeI0eZkQnewAogNJHKwmEqK1t5MQMbfjYRgI1p+KTsAKgIsJlN4HU6IORxw2AkRI8RSO0FEr/BQIDa9w8J+K+SaszFD2A82A1mI3IGGKFcq4pBBYz8TyAfBALiB0SivXqKQWCa18lo2T7f3ws9XX5ap2qVo1wG2UoBwbdJ9JgAUAD/Jw9vTAPL0LQDQZ8bLKQdqINAksLFnV3hyqSoqC141WWw44RJ89BDM/BXuv0bB12RvV8b/cef+cbus/es5nbGWMZoxuwKu0ensHt4CkEPchZEYCgaom7+9eR/gqC3w11jw/DVK9dBCrcQmq3sB8rsCEfpLHznxiy4rBa4ONwPg+FuRZQ/I4dKBNwuqthZy+5FN7IHrgFnWALrZZfBmn5T5C5s8BOkr7hUtWjfTO85koVjM6apS5Vz7gJXYh0mWzZo92zdG7wwy/I19PcvYo5ZRZ+0JGIql0q02pi2D7+LqfqUoF85XugzX66UmarAe0HHAoa7gMBr0bTA7emJ3t9h/Cp/cLD3OM/zMuhHxI/p+oSNoykb0dOEFMhOT138eafL9YvQuIC9vra6/MHkYWIf2lv5tRax+otUF1lUymE447PWs6IrAF7FchvWfnV8Md3cHm/YfRvW/pPj468TYK7MiKPFe8K0KJ/+NjA0fDkY7P4dcphZOonjuI3VlaXfIfP+MbSP6W+V5UT3itLllSJalnYl6G9Swrlc7pDb7R7t5OJkaVLa3tpEfg112kxlGGKTITEc6envHxj6GFkndSuvV6mUn52fnfkwWXshV4A07nTQr8vLJq9a4N+Cxb8VYZk0WTSk4VBsmlkAQFv7L7+IRbCrZCiXPAAoQLGx5szbe+5//m099y6vZ/bDW9l4JF458e5nk26eYQxIBEetxwT9Go31W1XhRK4P8ju6xpcKVRqTvp44hKvLa3BppB+GIgKwx2sgaO0n4B9d1fczKUS2MJc4gInuMD3GwpjocXig4PbOwyPTE7C0vQ8D4RAltpN8rmvA1P3NFZZt3Hf7vBT042cK4qU/CH2qBP7UNX85vTcmOUcMdYdkEr+Ng0Pg0MWCtK9SrXD3BqfRY0DtjqicBPHaSstu1Wow59/V99BzZb668szBzMhibrs/U867MaY+kcpAMp2BK0srBKiHYDwWocBcCjNA8TmcNERgdnuH1qPHFig4DNbySTlnNdnM5r2TBFOrcZQ/AOucK5fhyflluLm+BUME/GPmBkzbh32O3BBTAzGabtBisrKPxa9d/Beut28hczOoXC2R9M5tsGSnfYNVwE1UGEEd1JbJDVG687eKXVeK+rmVRB0l0vBcVysV9VgxQ/NL1UoWtmGnyz0MHUipVNw9ONhfAcViVlRiNSjoLFar5fzUhd+wWm1vVtQRFRjfmJ+b+b1cLpuB1hYrPV2fLm1FA/BrjZHmCKr6Xp3kgyoA9GfqVSmdMPlbtLZYrP/BTq2MXLV6vL6++m1ontvV2U7Uhgt5vRLr65+IRKIfJmXKzLa1Wu1ga3MdU5wqycRaZTzRjOvXn2tdXk5pY+3vKAyxN9Z3D2Yj6qSsTCbzfCp1iqE2yrGn5h5S1oHpjfVPkDI+xLKsX3Epvlwu/2Bu5ubH8/kcuo9K404ag52EI+prFV1+5PKqBf6iqIlA2rGAmlWb8oXaRPYHrScgNfGf9FlpDZUGNh3sLLClYVf0kGyYhgyTvDufP1rufjY5FyLAlVUloZe/IlAWU+eB1+Wgm8NkhqhodVeehuAq6vVgdkDYo+RwAPPxAxgLhsBmEuZDXry2FFs+0R+VQb9kweZB4B5AN3x14jmzQjlRKlfoNWxGU1VsvzKLgum55PxQkSt70bqL8fxDPYKlHK87v70rKCKIuI3OzQF7cBea3bW1qA2UQo8xM8bSw5FL6w/DpYPdQrLr+eRCdDW7G+AZgwHd/Zd392FpZx9cNitNsRf2ecDvdlLAPhwNwdZhErLFEuxnDk2/MflzWwaGrTImg8k25XQuH2zWnt29Yd/Mxj3AsMjDR44tw62NbZoNwGIyCtkXHDYaCoHXxHt2Ws6E59NbsXFXbEn9LEBzznmt37TcMFuFsyjBivKzxHaglcbvrBQ5jdb+3tjdyB7dyYBMxONP8agxqdcDRM8YeTy5PV7f2Pjk75hMpouKe8yRl+dfzty68WfVSkVNXHhW+ikd9P+QonaH/0nuPw0rrvKzelOKeiw1EWSSa//Q/XM7PAOS/CTfj1eqdGjtVxoOVNZ+TzfZOrb2Hx0lv1oulSSFpjSPtZrfG7II4T7SEx2I9vZ9nMynbvmitdrJ7s72+/b3djegdYpTHfTr8pMinXjdNKxR7HaHjywppjq5OFmHlHe2NiX+IeU6UyvFMN0GBofvIGPvd8i4U2Yz4kul0ndmb934vWKxIIXWKIF/O9CvRbqsiy4/Mnm1A39JzorNk/N8KjYl+FeT/SmvqaUAaEUgqFQioEgAjG77xRPH7OlKLF449cSLJ04DpdsX5h0E7ggse3w+8DkdNPbfYjKAx+kk34UUcJSQTyQBFBwCpLRwvGj556HH46UAdPP4mMaML8TjMNYdArvJQoE3WvyFxrCyw7qQs6/OHoBpAhmebSQaVFj/8axUPk/rZDfasmIIhNJF0bSQ2ZqWPMN7AgGwms30uulcAfaOjmkGASx7wNV9BdqD3Carh6qv5fsWtXVlo7GH1is8d/BE4mZ49nQ9xEGN1hNT+M1s7cDCzi7YSF28pE/9Lgepm4+y7XMG1vhccs59X3DqiK9wxXwylY8avbV39z/Cl2oV9pnEXNfN4+VgGZ0NWBZKHI8x/TSdIhyfgNHI0nuA94hlDXBUSUUBKPBXihagaPUyaOXForb601sGksNG417rmq1c6LRiWK1Wm81LpCFdTSuplMtHe7vbCxr3Ut53hyN95EX6wWbm/tS/nZu9+UV8MUMz4NdKf6Mz978IaQE6mRbHNfXjK71v26R2ZTU+q9uuHpfKz9LfNfulwzpJ0gnnQJO3gfTllX4PfsKkE2u/psU/Fhvo2NpfqVTiG+urj0NzXL8SeKjfefI+GAxF+geGPqm0OJK5MntwsI88KPPQTOLX0ZypP0uvLjlDqdhK0dkgL/UzcQZX19mx/bG+u8m4sHRSVjaTuXl6eoKhuMqxpxx/DWvQkXNjDwZD3Q38QyCky/zyzM3r/04k0VR72UhrlrYeibro8uOS1wLw74SURwL+Ug5eKzRb/lnVtUDr82HxxHfzdG0CDKx13BlbImAzDtpAtSGV4Fd2npxaON0aMRlN1NkeXcjpipKrUeb4gVAXtYpj/Luc310ikEMOAF5SENTk6HIE+hWM3yd7i8FEwTvGTgftTjATYL16mKSXWIgnYDQYBKfF2nhd6TPDK0L7GZoa0G4yi2kAlXNjPb0gppzDcp0GW1psr3Sg4bic8cWLJ2ETa6RA+HxflJLt4Xm3NraQfE44uAanb43de4vnZFdwaRElTYxKF3SlwqYhbINnwLSU2gwupbcj6XLekuVKtnypaKT1J2UGrZ78STFlqjA1U40cnC2VIVcswU7yRFCaoHcD2c+m1v0E+B+bTGYj6WeuWq3SydpqMFcfCV/cezRyaW/xdMu9kN7ybecS/mKtbMYMBwTxC94ZDJIwcnzI7t270zd6S+wXLRcvLcB61qZ+3qXwh6r4udamHOW5rSz96n6mirJoNHaZZQ3Kl15LOTo6fJ7juIqqzvKeAP4LkUjPbzEs65XOIf1/fJiIf2RlefEZaG/llzwhdNB/m6IRFqX1WUuUCkzpWvIfX2l93caCq07vqvyuFCXgV44h9d8Y7Iez2t+i38+6F7zGd+WCVA85+BHIbVr7m8CG202t/RMdFscnDxNfIe8TiWlfnStcCTwaCInxd5/PHxgaGf0UATcR+YI8XyTX/N31tZUXoNnSr547dfDxKpUzlIqdzu8oL/cc34rUr61xwmw2u8j4uNhJARhmubOzhY3TiutvGhNjE+ffHAgEflXJpYHHFPL5z966ee3/JeMZ+ZfOUrip3yHK9spzu67Y1eVHKa8F4I/SbsKgE0W5VvF8bfvKO06qmdFitRRkWMZB8C5nZIxVs8FYsxksKZfReuo1OpJTwbEjB2vOgkZ86OPJW2/fzSenEXy/cLj45i6zZ+3h7os/GHb1HIjHNGjsMZb/85uPPbhTSPYRQEkPIJgSTASoY+z5eCxKifN4EdgjAmcU8Fymm5P+DIKl2YSx5+Q7AmoTgk+FdR4PdVtsMNbdDUuJBOJSWD48hBEK/i2CQz8vdZhk7edFIrwazUlPeoeWAU3pBQXvgu3DJFVeRGzePagDf7qovpqcHyWgny6q7WYL9HcHaXw9KiWW9w5EvoEajLijV3mOksBJfcZDHfxLv0kTvuSxISlu6PfnT5aGnknMjJV5ziaFPzDi8gmBOCobAlZ38T39b9i4cbTsWsnte7Yz+y6jycSArG8QCo65I5X98pEnbaj0HKSStZ2TAy5bzrNclWMtBhP39r4HV0c9sRTZTsl11/byR7bV7J4zV8obaqQhdpOtOODsTvY7I6gMqon1VXae8llt5TGCpJEGBX+E5jFQX9ThZ9mqYzAYsNEch+yLpA42m50pFPKcomxZi04Wkpjhogn0o3ablG8xGk1Of6Cro5cqAfz53Z3tGfEZ4UVCP8nVH0bHJ9/k9wfeSz5bFOes7WxvfWB3Z2sZtNP1nRXPr6frayFngM7bWRy2snK/okjvWliNlO8D5V6tAJDaqSRqlfbS9TioK9h4qUyttt8mv0Cr/tcK4XlF9v1PsJxl7ddShtL3zu0w+VfK5b3NjfWnoRmIS3VQphlu8Ghzudyec2MTnyTzen/9inzl5OT495aXFjCNrhaZmDokSgopeFmVpC8mxOXlqOcrXTpQ5N7O/I7ySpjjO4ntb/K8ifbGLhmNRkcnBeSy2bmT46MDaAT9ajd/nobBnp9+l9fr+1+hvh5FqZFr/CUB/f+VrJuQiLod6G9leDnzXuhzuy4/rLzagb+WtlPTlfmvVr7+G7la8U284B9PhiZDASKCcIYrkhGaoS7hCKwfS9zk3SZbtsvq24s6Anv3BqfWjcDioIZcpRhihCB5wJRsKS43/IXtJwZ77YGVN0fve8pvckoKA1o2gbuurexBzGA0Ca74Pi+MEcCPcfqi/zyNsxc/NjSpceUnKAQQ3KIrv5EV5iMba2hsfU2+EI3tHw93w2I8QX9aTh7CoD8APpudAm/aAaIyQegMnoI0rE6+XAaXxVavjUx1D7B5kASGhhbUKncFp3ahEfgbNnMHA9JpU329FPRjGcs7+7SP8dBylas8HLp0XXGvQLGX+w+0cydb90vHPd/afe7Oo3LayzLiVUn9gx4X9HV1QV84CAubOzTN33E+bTYwLH+5ayxDtmyZrxhXUju2vXzSytVqhuXcro9na7CbTzqXTredgncC6ksYo9Tvea5sWExt+SNBXwaEsmoRm79INrTi1CoEc29m9q0ZruB58vBm6LCUsnEE/5pZY9FpsB37ze7Exa7hdfKg5cV2Kd3BlLH+VdRMg/Ciq0AjQWU7qw7dOI5TunZyBPRLbv/K8UEXtuTl1Squny5uIz3R8yaTSY4nbSenJ8ezpVIpL5aLmJ/uMbXg5NSFf0oWsO8ExQu2Uqk8u7K08LtkAXvYpl1SnyjBmM7c30baAP52nkzKPQqv+qz24Hilkt61U6q1ChVSh2Upxw/+vaq4vhL8y21vUY92/a71u1K0uAa0SD1fSX3/EyO3Ye3XdPF3ud3dbk9n4U9E+EQi/uVajZPS1LZKH9YUMmi3Oxzjk1MfJcBGyVZeTZ2m/mhhbubr0Aw6WhH5vSxz5g9pjda0QL9UdX8lyhlz+1m/tZJWHEFKZcCPDYwqSP2kup6VUUPeyNrCHugKXe6kHFyP7O5uP6Fqp9Laj1JjiZyfvvjzZL3ybmj0CKum06k/mb1142/ItSQOIrWyrRMCZumzksNKV+7q8iOVVzvwV0pbV6Eiz8XQJxsRosduhYFQCIxGZGSvQbFShnypDOlcHk7IZjNbmAoB7HulozHcnk0uPNTnCG/dG5xcH3H0bD9XWuhmKbs9Cxxa741G9qCcGv3rta/3v7778hPT3qEtsXzWwDOVHntg/6CU6kFgXSXH220WkCPmRSWCtvA01d5pIQ+pQgHK5NyaSMZnEJApBeCYIpAVLfe04fQ7+d3A0CnIZTZDqlikxawdJaHX64Wwyw1iFj8hbAD/McJnhNEI/Gl6OykdHlUQCGWuHAjODUPO6IadNeOkJwP/vcJRV7qS96ILPFr4KYEgHsAaYGF3T27ZkKt7xm2y58X7g5O6NFkqY7tMqVohbGYMBhtjLovHWW6k1kYfP7h+B8/wBobUL+B2woWBGAX7qESpiXwJeyenSqO+HMphZkz8pHewQPrT/Hj8mg9Yge8gXcrK9cMEACzDi20WFCNOg1UC4nSiznMl4/XjJe9GLu7dzcbdRgNmbGRFHUp9Xpc8M35weD3zSPed353yDiDrvZZFW/mbcjHXKi/sWa7xStZoZSxpOxZ/C6bzQ6t/MNjpS7VW2d3Zvg4qkGKz2a0T56d+xWq13Q31l1ytWCx8cW7m1r8j+1ybdmjFpuokfi2kRZYT5ed2G4A2+Ow0BOVlBaBn5H9ulQtdGd4ltVdrHKr7RKlIU/6u7MNW/cxC+3ug1fdKl3AtV20d/L84aWVhbOVarLD2D3Rs7S+XS1vbWxvPQ6O1XzkXq+dlWheLxWKbnJr+oEiAKkktk0n/p9mZG5+H1in7XnYG8R+Bt5EaFDWFurwU7XilSAceRO0UjFrnoWgpF9uFGNJjf0xzTbux2DKFXyQSnTSbzf5OCsjnc6tHycM9aJyrGzYy1swE9L/Xbne8sbGv+NLJyckfzc/e+hJ0lipT/T5QKhB4jf1PimJdl58QeS0Bf6U0LQDNBMsWxD96XU64ODJAganEaY9HohIgQwD22m4CNhPI9l6gf0CX6O1CfHhjbW/Ya3FlqY2cALvJWA9liL+xtgXpPMGwDGv51v6zbyhD5bk7vWPrUtk/0//6a5/f+J7hoHTSnUxl4RvP3oQLg30wOdDb5NTf+J5jaPy91WSESs0MZjEdHdaZ4zC+n4NytQpVRTsk133acFE5gKEAbqsVsuUSPWb3NAXFcgUG/F3iefXwAvxuJOAV/y6lAWAEjQBVD1RJuVvxJFR5rva60EV00cZnTLZg3DpeGyAgn15spDciZxI4TKfhNJunSolKtco/HL7jGtSfzyZL/83T1dFnk/MPp8v5AIYfuI321Ot77rwZLxz7nz9anMR4AWTVf92lCYgEvBRYVzlO7ruD5AktDyVo9paVZSymtxxPJm4F0pU8AbiCtwCe67RZIRrwU68BTP+HmQsen12AcoUDDF3vsXfhdUy5asHwdHI2MHe6FkCWQlQ2mE1WMYRCUNYwYmuoFwkPNLyBvB1c39x95qd38/Ebb+25F10/ldZ+9Iswrqb3/PvFZKjGgs3EMUv3hqdXjTyDGgm1S6daCdDK+qNFIiUpW7Qs/XTrCoaGrTZbqJPBlkmn17PZzCkoFpxen99/bnT8V8nLdLB+JF/JpDN/Shau/5OMPWXKwlZKC525vwNpw2KvBppsi9+1FuDqBaA6xEIZaiHV4+W+J60WjpLnkNJ7RpnKFaBu7ZeUT/8/e+8B5sp1nQmeQs6hgUYDaHSOr1+/QPIxi6QoUYG0R7Ioy7K1kmV7Z7zrnW899vfNjD1rf/bOamzPymFkr7+xx/bs+huPR06SLFk5MYr5xX6dcwS6G41GaORQe8+tKvStQhWAR5GPj3x9H0GgEapu3bp16/zn/Oc/rFOAHRP2WXrdzBBX6gsoX7MPpfHHVgSRvsPSxEGlPyetSbvBaH9DlNHhdAbcNxDt343Fvk7WOlzntGqGg6IPOoPBYDx95vwvm0zm+5htIc34z69fu/I/oHmtcLW186asmW9Qikt97JhnNSr6O94BoDGe7Ty0hKqVTW2NV3t+UxyNimi/GkNLk+KPgYlAV/DuNndVi25vvQCNoLo+ZqhiPEHLC1vYIAXa+bmD+P5/WJiffQpaa2ioOYC1xult41g/aW+/9k4H/qzRpXyfbdwdnae++szOpfNGg0m3trsPff496O3yi0BZiNBiVNpjs8Ndo4Nw76lhuuHdVBqWtqMwtxUDvcEAR9WCgxMV9DEqfpqAzv6uTpjfjMLL80ug1xl0z0Sv3pMrFRwEGC+TTehMnIH7xOD7rj0dvTRwMbE4QMCg/uLyKixHY3DX8CD0hwIEDLNp2MfPGNm3myz0oeQHIX1BIgsg4JRU/6U8fLqi6QTgif0tEXA7uxul2zjI5aBc3YXhzgAzaMLWjUY9VAo1if1PKwFIbQnp+no9+PSOlNfkQPAmA/4bhVgEvQ3VCg9n+nrqZ2J+c5syE5Bl4DE5tgJmzyHIyyBS0F/ha9YvrT/z7q1cfAIL6KEQIH4ly5c8/7T14sPoOEBnQqTDC+8+d4qyLmo1xnHBC6B7amOTHjvwVb7fFcJ+6nOVouEbWy/513MxO26X0wliiMOhLjgz0AsdTgcZk5qY8gCQODqiaQrYTJyx0mnxwHN7V7suJxY6sLwfj2PM0zrK4LBaoSfQASGPB9xOG+SLZcgXSnBUKEAql4fdZAqOikUgNp3uWnLl7Ae775tHBXvc+mvx2d6FzNZQNLsfIp8b9Di/6NjX3vPKwVzmTt/otx/pOo+OAmWdWCUboIEZoNPpqqR/FeaaYIF/A+AXH+ZgKHwXtDbO6NSL7mxfBQakYNmpvr6BnyXzhFWgzpAb6GfEG2g7FNUTEb8WrYlhqFSwVxO1awb+69RHkANQFoSygkX1SPjNBv8q0f5mAm3Kcq5ShFXqvzQHi8z4qBljLN2fXZabAX6lvoBe8T22KcdbEvKsMt+VOV5uAafL26mpRRhZJpRmbn+vEO1vy64qFovrW5vryIRSo/irzRcdWTP1Z87dgQDkUWZTtVwu+1fXrl76r2LVk1ZO3psK+jXYRq3AKoD2/UUtAqoViX7HgaI2Ab/aGq/2vtZ4s+Nb03iwLCPW2fhGj/kNO+E6A10YmAi2s/F8Lre5t7e7AXJgXh8Lh8PpGp+Y/CWTySQT6yTXWnI3tvMbK8tLr0Dr601124pjlG0e5PdO5XODc/edNs9P2pvX3unAn23NKDP83d6xuZXU1vdixcPHEOo/PzMPT3a4wII17nmuTneXrs4qzUsH6HA44J6xETg32A/PT8/B9sGhWIOeg4N0BtMCaLR4pCcEYb8Hvv7qFcxf516Oz054Ta7ypGcAc5i564crXXOpjdCjwbuW4/kD22xmI5QpFPXfuzoN7qVVONvXC4PdAdpj1jpg7Typd8KKLIJ8ZhmgR0GXHY6+Tz+mqQECMEal/9PBEC3xVyZ9zhAgSsv9BQJiRF+g9aMaf6XGywQH8QmZAAs7gjaKz+JEmraBGWvYySc8mVLOaSC/D3gc4HHY6Tjix4vbu1SfoMpX4P7O01K0Xwb6C9WS7fOr3348XcmHhYoCImVeID4I5QXJ3x67Dd57xyQF/LIJIB7zfioNiUyW/mHTWatDzu7yVGrF84PYlLvIlw0oSoi/HQwH4I6hfrCbBb05wfkiHDPudyMWp8dcIrjZaDDq/3T2S/01PVIEBB1CBPwoXHhuqI/OE3QSSGfLYbEC5xEPjfyXKxbgC8+9ChzZ3rAzEiPbd1xPrXU9G70yVoSyC39nNJjouUPQbzLowag34T6clw8XnwxYPblTrn50JGkB/SLzkP4uk9+zZWXqOgxwLJjY8HC53CFyM+xv56LL53N7icQBUujIjZCrDg4N3dkVDP+4QsRva2d789c3N9anQTtSxbIfmlU/OAE40FbZOiWgaSZup2assEYIKxKmBKHSeZLA8E0D/03KQKmBfgvzLEX/WeAvzb8SyMG40hhjaZtaQE5t3PUqf7PnQWrKSD8bWWI1B5ROADgxDNtuakBDq1Z4vQwwWRM73R7P6Tb3wRPQ8E2yzrPrr9SU5SQFHz1pZ8/e8S+sVtsTzOd8Pp//h2tXLv0JU+pUi2qszOu/maC/XbZRu0wjUDkO1fsBvEOi/20A/mbsIbWHFvhXgn5p/WM1TpSvAd5A8K+RnsWuk5qVhkAITNwD6vNH2fhodPsVkFnKx83r7egcGTv1SwaDoY99n9hNu1ubG//H1ia1WZqxarQAv9o5lPUL5POatXu02F0n4P+ktdVuF+CvRUuVXVBP9j36T/95/gsXyDXlRVj/7UtT8JH7L1BqttA48fJkXQBCMxuN8L47z8EKAb7PTy8AstmL5QqNyFdBANoI9j50713w5RdfA85g5J7avTQx4o68ZuaM1dnMeijPl+3PxC4OPxA4s/rpwOPXnt292r2c3vJncnndczNz8PzcPAwGA3CqJwydbjfVDzhunOJV45pXX9Hr/5O+ydW/gKyGiWAQZmIxmiKQr5RhOhal4B9TAvCbZqwSQBkCNeoskLadzuXhMJul9HW7zoqqpgZ2t68lZgYMej2qucNIOASCzhyQMdulFH8cVavekpn0DkbJd6RceXqTKteq1r9a/uYHc3w5INEYDOQ3AY+Hlt5L0UQNngL29991tgH0C53kabnDlegeOl/ocY+4IoW/Xvl2MF5KmyQGQ8DjhPtPjYLbbtPkYWGkPnaYhAI5x0gcyFdLSPTghNW4Bh6bFR44PQp+l6CVgE4AHdfI9cIX+8k0PHNthoB5Ay3L2OMKwn9b/dZDiWLaher32E8s6xjxe2mqAaaPOGwWqjnxwswi6jhwS6ntMQL8E9AY5S+SLZSwvBMIYF96LoqfVRjjU5oUehGYo3q/VOKyXi0hFO4+124O697u7hRun9istfFTpx/zeDseAQbIlMvlK8uL87+ZSBxEoZGRUNHr9VV0GGAZApAbHOy1XJ/Vt/tNT8M41DIC9U0eWuBfzSBR5r5Lv2EXqBrz+5sJQlmqqBLIsaDfyjzje0a73e7p6x98zGazT+r0Ogdf449KpdJsLLbzpd1YdBkaDWLWGcVStdnzoDX2bF12VmiQPQfsuCv1PnTis7KxmgO39bXRqmkIibWK9tcfPX3995O1uM1of2F9e2sTS7pqAQQZMCBNN3nm/KdsdvuTzGd8oVD4x6mrl/6Tioq4Wk6/mpjfzQT9zZyPWkwjZdOKhLLORdVUI3gbA6MmY3kjzlw1x66yegm7ViidjEqhYXadZx2hwGzjh21qx6XlhKNrucfjjdjtjv52Nl4sFPbIWr4KjRiB7wx0dQ8OjfwrYoPIUhqJMbK2trr878TfqYF+ZZRfWfe6mbOLHTslTmEf7HdPwP9Ju6F2OwD/ZqBfdkEZOV1u0jP03WuJpY8h1Tt1lIPrK5swMRihIvfHxeyZa47xjyK46yfA3GIywXPTs9CBEe2a/N5jNhnhvefPwLcuXcXIrenlvemeh7vO7xRLRSPdFEFIz+1eGyzVylv/LPLASr5W3Hp1f67zenIlUKyVzasEtC4ToOwmwHIsEoaBcABsZH9VMQLPaQgB8syrY8ivyIQQv4TAfSIUgjkC/rE0IGoFzOzGYLQzQBkQtK49+RmKHhoIPsQtIv0caf6ShgD5ihQ1FlTcyZGtp2LdvJ4unDAYCtB943bW9uJ1RkXY4t0ix8EqalMhv69vv/BAtlYIcJxgSxv1OhgKd8G5wT4Cmmcp8MdUhjuH+qkThr3lsEeZL5YAUzmk/V1PrjrQGUCLOZDne8aGYbwvLBMBPE4UEE44CvTNbexAigBvHSd3s+AcuHN4ACb7eyjg5+vlFzmJK1DfEjJDlndicHlpjToiJJbAc9HL3bgPnG6YVjHWHYKJ3m7y2lDfVr5UhJdnl8hzSdBd4HSu/WKyfzG15T0oplwFvmQulMvGXDVvI5sxoOyjS29Zflfo3NcHbOFNspECp9OVeCGXngX+2LBcoJGMiZU8bORvLIeDzzaD0eB2e7xt1acmoP6I3ByXLBargYD+jxKj9RQzVBip+ubszNR/KhWL6VqNL5NrrmwwYOEBQ0VHAL9Br68Rw1bKf1UCK/bGelKuD1oa2s0AJws6ZTXCodEwxKYE/Wqik1qGu1rN4jezsQaW8pglo1EC/PjAeW72+fy9QyNjv2wwGLrYjRlNpsnBoeEPGI3Gf7W1uTHFHLdUNpN1iCnz+5Xjb4BGYUHle8rxV2oNsHoDSqO9If/5xChs2dSuG+U5aqD5E6Dh93g8k23ug49Fd74lOlyVCt86xXep73fyzLmfdDidnwDmHBeLha9eu3Lxsy3qhatRjuv7u8mgX6sErRYQVQNDaqCfPT6WacRS0d+W+dBtpGupre3tOHWbOXfZsZbGVrnG60G+zrNCpz9UilGLudNSXDMc6bmbkwzFFm13N3oJKzCBYs0Md0eGe/sGfoHYYW72++Rau760MPfrCaHsn5KR2MqJp3RyKe3cZk4XLWZXw5jDzbu3nrS3aXunA3/W8GrmQaurhb8vfOHFldT23Tko9SMYvLK2Dt1dPnBZreqgWnGJIdALdrjhibvvgHgyRYGznqrCH0fXOz1OmvePAHQhs9lJgP9BTQjsUjBo0Ou4Vw7mImWo6R4NnN94uOvc5sOhc1uv7s10zqY3uvbzSUemUOBeW1yBl+YWwW61QNjnoXRyl80GAa+LOh+kDiLF/CCVoWJ2KPZXqpRppFoAvJgDX6UlAJ3kGBGQGw0G+v6priDM7+3SqD+C0LndPRjq9IHFYKSAFynuHGcRjosg/ehhCsS6eWDQGXBxkuiytbnUhr/K1UyYc4+lColBTUEuOka29hPUmUBe8xf846vi77BRo2sxsxVcPtoZ1OsExgFWWzg/0EvTJ3C88Jjw/YivA84O9glaBuKpr1vL5FiL5TIsbO4I5QNFXYIqJzhLzDo9PHLuDAQ8biqMKKVEUPAPksNHcJusk3GIJZNUE0EyqXFPKCb4nvOTVAtAzEAA1m4Rviq4HNAp8Or8Eqzt7dMUAl5KzcD7FTkfXrsDBoOdMBwO0vPBbgSP93uXr1NNAGk/C9mtsenU+pjJaBSOTBBzEPZHmQ4cJKq54BfXnrnjU0NP/HbA7N4VQb8E/CVPNYjnzEjmMt5Q2Wi/ORSKTJBzZ23n4jtMHMwSsG8eHTv1EZPJxOTb8ZVUKvWXs9NTKOKHCotFcv6LZD6WymUdMV5rFUxBqJTLJ8r9bbY2DO0bBZxqEWepKddQFmyofV9qMk/jm0n5bxK9ZamibDoLzml0cFkJuHcPDo38SyXolxpZG12BruDHCfCfE49ZKr+pB4VDSnE+tKoIqIkLKsG/BN6lcZeAnqQ3IKs1DergH+DEKFRtLYTElKVjG2j+PX3995F5YWxnXwSwb+xsb82Adv6vDLRMTJ79cafL/dMgA/3Fb167cvl3Xifop4+bCPpZx5vauKoB0mbAX42xyZbYbEZBl7Zzy7c2HblaIF+LQaTF7GqYd9AIPJVVhJTrPKsVVJ/Xr9PR0gz0a5bws9nsPpfLPdrODkqlUjK6s70ECmcSAfyT3ZHIz5HrmbVzePL9F2dnpj6TPTo6hNbUfjZNtVl6VzPnutKxLt1flaCfPV8nDt6T1rK9Y4E/Tnpx4VQzgpRetPoNE9XE399zz1e+tPHsL+CNHEHg01en4cfuv5vSsJXWrBQV1kkRXREg2i0WsAXNslgxbZzgHDg31AsrsT1Il3KW7VzcTUCPXtgA0uCDkC9WuIux+bBFZ6rc75/YRv743f6JXfLY2ysm7a/uzQSXMlt+AoL1CGhXY/uwyu+LkWserAj8yb5yhSKlvWNOvNQ30ccgmpIiQBa7ubgdhQcnxwh4dVGwO07A/1J8j+b74++W9uMQJuDYSIAy+kml/eE+bBay9mYydHvpShaNaKkMX20ls92J+eu4t8FgFwX92JC9QPP1yTacBksyYgukQFjU6WLIc5z5md3Ld+r1BvpjEwHXd48NUceJVKnAZjaDg4z3u0i/ayLg5ep28jG3AVMRNuIJiq0lwIwo2WW3wsOT4+TZdgz04XiM2G2VCejGPh8e5eqaAngsYz1huHd8GIQyBc0aTysiIEshkTmCGhwLLqIzoK/LD0PBAKXzEwTS4GzKFgqUIZDM5hUuBY4zGDjKpnA77OAlD2Q+HJJ9HGSOmN3rrOlSJkiAP0v7L4Ec+HNwTIOWoqA2nU5n93cGzrR7DToczoDP3/lxvV5vr++erx3t7+39wdLi/Pel/WOkn/RbRvEH+c1UYiOcgH6V1iSXXc3IZnPb1R5K8M+CSnY9VTpNWWNQaUCqrcE3q6kZXkrKtgT86TwfGBh6HwH/kWYbJetRBBoNamn77Fg1M1zZfijLZ2pVF2DHXEqnUoJ+NREuNne37aZSa71pewdcj0rA0VJBHMGGx+Ntd13kd6PR75J7Jlu6D0AOvOrXyOnJsx9yuz0/x35WKhW/O3X18n8ol0voNG0X9MvWzpsM+ttxPqoxjdQi0GzOufKhlmqkRkG/5cUu22RMaIF8rYfS0cKuWcqoszRmSuduEeTniW1KR+MNOxtb6LK0rKrRHem5k9gppnb2Fd/fnapiOSbmGhkcHrm7qyv0cWJ3sdtAduI3Zq5f+4NisSBVUFK7xpTnS63/as4ZNS0XtbFnnWJq4/66xvyk3X7tHQv8Fa2dvNS68dpn69q6s2Pkqdfi8+8nBh4FjNdW1mGSgPUG3zHZ5CH5HKOvfocD7EazEE3moRH045u8QIV3Wm3Q2+mDTQJEX4xPB2wGCyQqR9SBMNYbBrfVjnRu7oW9qV4Dpyvf7RvflTYSMHtyP9LzwHq2Wth7JnolPJ9e6+B0Bo6TcsjJi3y5TPeHYFvPLCcCjhTWhJqUHkD+IaCmgn75ghCBlujv5LMRfwDWDxMQz2XpezvJFFgMBlpGUILZuJ0utws29g/oPlYyUW+xVrGZdQYcU34zt+el+6zUKEUfwa6edGx+OyqQ7nUcjHr7UFlVFu1/KnpxNFsturGPVrMRHjg1Cl0dHgq48T2MfvsJSJ7o7RFK48mI+ccxd4z4b+zFybks0O9JnwS9bnj47Ckw6vX1aDzNqa/rIIjcAU54NbuxLQg4ggCyBwhIvzAySPpm1kwvqAsCkn/Y3+evz9GKAFU6HwSnSW/AD6cHuqnGgsNiRsYEA/r5+hgn0kfUYUSPFR9UO4CjzIBevw/Cfi8d14ooPrl/mIZvX7pWd+x02jyJCseHyAGkyVym0XY4NhxZgT8pwoWgiAKiDp+/32KxtFUXF5vNbpcJ4lSrlejG+tpvR3e2p4HRGxApr6zxeqLc32ZTiVRqGUtqYJMFmSzYVBqHysibdE5YpylrxKhpAagC/zfDANdQ8lcCb9ZorOtYmMxmr7fD925oNK5krVarSuKlyiimXHtVnWmgdh7MimfpfGD1NovP748QADhgsVpDRoPRQ9Z1E7n2k4nEwddWV5aeBfV7mxQBvSHwr1FnvZ32thRRayEk1izCSNkiPX3997YLNghw2Nre3pyFRop/Q4R74vSZf+b2eH8eZKC/9NT1a1f/PQH/OP+0QH9TltRbCPqVTBd2vTEy32kF/LXSjKRrscL8VqkzIm3rloyKvo50LZY11OpZDfhrUf6l8WLBZ1HcVgEaAagWy+j1jLXasavdx2TXodFodJG1uy0HHDJltre25o+PkauNjo0/4u8M/AjI07VqR0eZ/zE9dfUviL0n6WioRfmV92Blapeac4ad78r7LBuc1GJYqN1fX5eD96TdXu0dDfzFqL/0pxpFrCHiD+JF9lDXHa8kSke9a0exMcyxu0KAP6rQ9xCAxtdp1EI+vM9mp6BucX8f3BYL9Ho76rnfdd4PDQ5z9Z7g9zEPfJ2A0fWjmK3H1VXBd1ElXhB5q1Ha+D88/yL3wv61QavBUp109x+wx2fXW8pPRO7bvlAcSz+9ezUYLyStZV5iAYlrCCeuFDzQ6HKtykPQ5yEg3U0AsxN8bgetTy+BTCwzV+NFR7m4jODv8Jgwj3/vKCPQ/Ano3TxMwXhA/C35b7QnDFfWNgT1e47Tv3RwPfRI5/no6lHUnudLFj1Z2zANAvPXUc0/eZSFg3QaDHoDlMoF/i7f2B4IxhVdNLPVgn0qtTyM6x2yAs4P9hPQ7wV2XSuUSjDcHRRK80EjI0P6ZjR+CEvbe3UAjO/3BXzw0OR4/btChF8A6LliEXLlEvhtDqkIAuzED2B6fZs6EZBxcGFsiLIN+JqSTau0lgVGxX4yA5cWV6gegSQYaTEZ4cGJUXDYrGAm592Ewonc8RYkVoOkDfDS3JJQ/YCMn9dlg4lINwx1B2UHTFMVyL9UNgvfv3pdEE4USxoky0e+b2y99NHnjdcS467eS3f6Rq/ZdOYkHANuaedsST8KirqCoUm4MSBQb6VicXpxYe6zqVRyCwTDoS4yKFYWkFgHJ8r9bTYNwKJlGCrBvrJ8HVvGrm6YkGbs8PnDHo8XyyN1E+Oqg1y/VnIWyBSsZQiQWTtMHLwWi+7MiNocaiwrpfiW9Pxmn0NlLqzaeLBUf1t3d+RucszuVhsul8pboB7Jqansl80T1zoX7MOEYxzoCo4SQ/Ruu91xmvTJCSrXXigcvoOM+2+urS4/D3IQVFH0pz4mas4WDbDfrgNAeR7flg4A0AZYmvnEVqvN6/V2nGtz+/xuLPoUOV9qucDSM31NQP+PerwdPw/HIEQE/Vd+o1DIS1HHGwb9N2kMm+VlK1MmWKcjC4jY7bQK3JRBToVuJhAoE7u8lcB/kyg/myahBJBqjkQ1p4om8CdrutnhdPntdnvAbLF4jQajk6w/OM9rlWo1k8/ldhIH8cVs9ugA5NVOABrBp3LOvZ4IdKs5xJZfra+b4e6eMwaDwd7ODsjxzJXLJUyTqRL7lT81Mfk+pfAwXnLJw+SfzM5MfZGpmNFMtV95r1ECfq2UugYtF7LeI+yoViqVAvM7pQ6A8hpnHby3PKvlpL117R0N/FWaFvhX5i6VOJ7P/1jkXV/9ZvSV4mxy/SxZCLnvX5uG+0aHYayvm4I9hikPPruDgrbNwyRcj+5At8cDZCWtLwu80hdHngNuF41WJzJZLpo7MCJYs1vMYDGaKFDDvPt3n5mE71y+pvt+7LVhm8FcG7SHUiC/oXFWo4XvdgWqeosBtpO7dceE1EHMo0eHxXCwi0aWcfmgcibiulyp1OopC+h4wC/wbEfFaHPA6YA8AcNI+weaa16G6d0oAf9dNGKO7717coIKFyJQnzpc9t3rO52cTq74dLhT8nmYAHehGgEHC5tRXODo2HRaO1IOnQV7ZRZ7rv/65osTpC8G3LeXjCVGs9m8eewj6hvoOXZg2Ti78N5OPAFYnrGu9kMOfrQ7BPedGjk+P8yvE7ksrU4QdLspaMZ346k0vDi7RJ0e77njDIR8XjomfE253+MTja+wlCMK8M1ubMHC1i6NxheLJarBMEIAOwoBotOink7A108cZYfU75xk+F6YWaAOiYFgJ4S8HvC6HeC22mjUn2NEJ/H/qL/w7YvXANPk0bmAAo1lrDJBxhsdB7lqoePS4eJjLx/MPtxnDUw9ErzjlU6z+4A5AMngrdNZnU5XU/qz1jVHDIanZqev/2mpVMTcOBnoB+2yU0plZmWk+HU5IKT2dr8hNolqs8YhawA2GErMQxZhJnPJ2Bno6g8Euu4hoHNSbzB0gAbws1qtd3k83o90d/fMbG6u/ykBNgvQaKCzIFRSOAZ4E6ITbThDtATarBynQ1bLfe3sJ5fLroK6wJYB5FF/pTicktYvOxcms9nV09P3gLfD94jJZAppjftx4wykzx8mwP9VkINApXCUalWFJoBf7TUoXrM3CbVo0y0FrNRaG0JiSlAlV/Lv7buBaH8xtr3VOtp/SgD9/wLkoP/7BPT/JgP6taj9zZhSN0PMTzoeLcDGjqEaw4WNQqtF+1mxOSkSjb8rgTx6rcYWYOcrqLx+y1ob81CLvaV0oGg5U+qA32gyWTs7A0Nk3Z6w2mzDRqMpSJ25jdT9+hhFenpKhUJhem939xvbWxuX4fhaVzIwJJHTG04xakOXRVPJH/vv7wycb2c/GGjY3t5E1iFWDeInTp95wulyX2D2jbZddn9v93eXFuefgmNcoAT9UlMD/M20dBrOi9vtIaeka9LucI6bzaYenU7vwm2SvibyudzF9fWVL6RTqSg0Xgfstc5WD7gl5vVJuzXb7QL8tXL8m0b98fHB0D0vEGBlns9sjekIQntpfgk2Dg7g0XOTYnm2Y1q/02yB06EgbCVTsHF4SMFjv88vgmlouBQx6jvRG4Hnp+dFyj2A0245jviS74d8HkrjXo7t6v9p64XRj/Y8NB+xBZDmp8vWCpYvrj/TF8sd2EwGi5RyLkTpqzVwO2ww0dMNfQQoovCcpDIPNZYSz+T443GIXS1XBTG8YrVCgGsZMoWCIGYHQEE+pgUggQGBLZb7G/D5wGOxQtDnhvGeMCzuxHCQdV/d/EHkoJiihhHmwocJYMYfGggAXozFhH2S7YzYuqVoPzbdQnrLv5nd69Qb9BR8n4qEBbV+pmH/9WIIH50bep2u4fNsqUDLK0r4HJ0pD06MQW/AJ+bzy6P0mSKWJMxRzQCHyUL7V6iUYH13n1LwMS3AajaJzhU1m/y4P0fFAuQLJaqzgIKIp/si4HM6IOB1g9NqoXT8ht9yx6+FlBFhP7g9dDL8+LvupSkP2He9Ti9zXEjTBudVMp2Fh06Pgd/jpHoT1AlRqUDsMA17ZH4eZDIQTSRRRMG0Uzy467+tfOOOTpN7/YL/1KUJdz9GM2Ulz4Kh8Di5ud7QeoF5rIeJg7+bn5v9As/XUPwhLz5YbQFN0E9uhnwqlVQz1hoHXPtvtd++XSOStLWgsrfKSa5HK0EB/BHAdEd6zgS6gu81my19oG0IKpuOAFZUu/+/LRbr76yvrbwI8sgz9octQ8QahNybFJlQgn5l1L0hguvv7Bwixx1qtWGc14nEwRI0gn4JqKkZglppFrQPBOS7+gaGHu3wdnxAbzB44QaYNeS34xaLxUUMczb/Vg0EycBQkxrrnMZvtK4trUd9P7f4ddYqLUT1OjJbLJ4On6/daD/s7UafE6P9WmsagpAPEdD/cyAD/UWk9/+mRqRfsl3eMtDf5jiy1GyJRcYKJLJsIxrxt9nspDmIWWH1GI1GK1mf9MSGyKMD+egoE0ulUnu8wBaTHF1KYcD6uCpeyxhHb/X8bEOjhXXksowJpUNXCfzrKRRk7IyhUPe4r7PzHpvNNkmG0gHtrzEoko/sljv7+gfOk/vDxZXlhT9LJZOYmsmW95NeS05e1gH6emj+7d7TzF1doVGz2exrZwep5OEqAdNpMqd0E5NnP0zm2Dg7FmSOHWxvbX5mc2PtCqjbKGpRfuU9piXod7pc/mCo+26Xy30PWcMH0OGu7Cs5b07yvb6JiTMPbWys/fud7a3rzHhX4fjeqjbvT9pJU23veOCvIfIn81Lq9foaFgonF15ZpPRIaskUnDwRuf8Va+wKXIrPjxmMei52mIIvPv8yPH7PeXCYpQC10BCnRdwE2BGQuHIQh6noDoTJ30GnE2SBePH7CMqfn56jABQ/d1utzK1aUGO/d2yYivfVOF7/DxvPjP1E/3sWwxZf4RtbL0YSpYzdZDCBFGHGbWDe+p2D/eDzuOrAUSpHyNexpQAms+UiBfkVGhGuEpBbpg8UMjRwmHagpxR/KwHdXtI3I/nbqDfQCHIsnYZSRRTpi8ehy+GAiMdLS+JtxRM00k1ApVU6blTjx/z8CtnvzkESSuUKVeUvlor8nYFxBIZmcVh0ryZme5DuhL8d7Q7CQChAI/UNjXxhP3tE9RUk54mgxi/kvj9zdYYeG+bRj4S74L7xEVGQEIBT2AZYgWGPAGJ0SnQ5hLHD49xPZ2iax/nhfgFsg/JOpsjoJ7/DfTstVvBY7cdWHtO/SpVl1as00SEiVaXBNImHzozX55CunrJwjPx5kSWAn/ndrrrwYql8vK8uj5s+hG1wtLLE/NYORBOHumQ1N/Ct6Kv9z+1fTZx2D809GJhcx6IH5DxYfT7/wI1cd+TmmSU3qT/fWF9FCjI6qvLkJob5/PQBx9UEygaDoVZBr4SCukZAP/T09tMBIDdhlZPflIqsRgN52zsA2gD9rHGoBvjrFRqYh7ErGBqN9PT+qAj4X5fxQOaqPdzd/Su57NEv7u/vLYt9YaPP0qP2evfRbleg0YBuBvrpOASDoXvb6Ve1UokeJhJxxXnAY5RABcuaURqtMjE/jFT1Dww96O8MfFSsInDD44LGocvtCRcKsSRznK0oz8prR0ktVvub/Z0y2l9TeZbaLQn+WwiJtcrtN5O16W4CoCzt7KtUKu2L0X5V2j3yegno/4jb4/1pkAv5fX/q6uXfLBaLtyzoV6xJann9akKasmox+DkKqiHTqLMzcIGA/lMGo8GPgBNUrgnUhanVqvv5XP7VWGzn23u7sRVmv/Wvic/snGSvz9dDQ38zxg5Afq0100XQSg9SAn96H7BYLE4yT+/zeDseIkA3AD/8uquzWq13j5863Ts3M/1vyT0aSwNLGi8GaCwv2paDt0m0X2seyZzY5P51Vzudx9J9OztbU2aLRUeutw9brbZ+9nMCAzZWV5b/PZlPeP9SXmtaFTjarpZDmiXc3XPW5/c/arFYz5A5b4Y2mk6v7yTn8dfT6dT/dpTJsOktalUwbohpcdJuv/aOB/6Kpgr+RWVPNtpPAf9RrWD8+vZLjxf4UpeVN2c8Vmc5U86Z8JLCaPjXXr4M5/p7YTgSpKJsEsG7Rl65zBZKgZ/f24PtVAqSuSwMdXYSMK2Xu5/JH0MY0Y/uUUE9LKl3bFGJVdt1Opjsj8DU2iYG6/Vf3fzB4KeHHl8mgFa8yYl7Rsq820kBohmdAXXauLAjQaxPAKBFAu4RuGMeuwSBMRpuIKjRTQAriv1hZN+k09NnfOi4Y717fO60O2D14AAO83kKUqOZNHQT4I9j8N47TsOXX7wolDLkBH2DSKePMgXw90vRGI3kI7L3Wlwlq86EXaA3+fn0hmc3f+jUk7Hyu+xUxb+mEmFHcL9G9h9yu8UREKLknNjH66ubcJDOUiD/HtKfsN8DfK3xvidNiBg5T9RxQ46Bo2yGGmSLBTCZDBDp8MoU9uUrqnTmxfMl0u45nvmemErB3AebTFGOEYgUPQCiE0h7YssZHLhzHprtT6gi0BPwQW+XH9K5HLw6twybBwmuUKv4Xj2Ye3DtaHvkx3sfvdgf6u8ymky2di8yAowSKytLf7i/t4uGbk585DFaA8fR/voNlTS1nFTaSQL4lTcvTuW5WUSSPV1KsFL//FYEJsrWgk6rplbPGtrKZ/o5RtOGR8Z+xCVQHfVtdkWzEUPd2ds/8L8Q4P9r0Bh9Vosgv2FjfgM0f2X00Wx3OMhy5myrDFQ2l73My3N82Gg/S3FVAkhZ2b6urtBQpLfvZ8xm82n44Qxyzm53YBrOAjSP9Gs5AJSgQ2l4S38D83u1eylbOx1A7gC4Va+xdtNCZI4ish46fT7/He3uhACJl8j6J5U7k609eL84PXn2SZfb81PMOGPJvu9cv3b5/7qVQb/GWLYC/TbxIYF/BG6j3ZHeDxGgOgRy8K6+I44jJokh7HA6PzzkGH0i3B15enlp4b9m0ul9dmxB3Sn1w+Sfv2GtiTBrM1q/zPkEjawJGuk3my2O/sGhRzwe7yN6/Q1F99tqZOy7BgaHf/rK5dc+C42CsGrpFu025RqkldpQX7s7OnwRm93e3c7Gs9mjaLlUzkyeOfdjZIyC7GelUun64vzsb6VSyRgcs36la0wN9GuJLDaAfqvVhvfFd7vdnvcR8N9GCpfamOuD/QNDT16/duUvmPFWskNYh+sJ+D9pqu22AP6MyB8b+W9G96fg/2ubP3g4VkiOIu46hAwNkx5TqoWo7WtLK7Aci8EjZ06Dw2ahEVfpikZ690QwCPO7ewRgl2FqJwqDSIlHcC9G9PG75/r7YGErSgEjUtslGjlrHZ8d6KXAH8F3gS+ZvrT+bM8joTsTf7v6PRsBiTqMDNdqVbj31DAB/UbZHU3qr/SOBAk77DbwkvuvRJnX0QoAOpqagFF++d2RB7ZXQi16DvrJ8RiTSdg/OqK/x+g6/t5Nto1OkesbW3WWQaSjg25QrxeBP0bmySdDzu40iDT/ZPnI/L3oa72kHxQ/v/vcBByXKzg+JtQJWD6IU4YELV1IQ/h8vafo2Li8vAYeux0eu3CGlsZTJQyIG94/ytC0hrDbQ504+MlRqUAnideKY6SZ/gbSfYCr/y2eNe5YKQE4yV0ingue+Z5UW1DFUStgfZ7ZNnsexbMpOnVYxwQneyF3WHD1D0RnAXkTHU6P3XkGdhMp+O7V6/TjRPkosJjeCt0XfKDtaH+1Wk0vLc5/7uAgvggM6IdGej8rRqUK+pnNtktJlh+sfDttUZLxxS0ITppFhrRAPwv0WSO7HiXpjvRMEmP7SWKIeN7IvhKD6u5QuHswurM9A9q1it+siL9a1EgtgisXhgpHsAxUO3XYa/t7u6/A8aXEqvlzKu83UD1NJrNtdGwca7N/WCviQ8DeLlJSvR2+CVSrbtUpslEfNFfpVgP+WtRiZc1ptTrTAI16OWzeKQfyqgLYbkXw32y+aLFDLJGe3ruIId6WM7RcLiW3tzYwp7hh7cE1m4CQj5O58CTTFwL6C1+funrltzXU+28Z0N9GBQ0t4I8ibEjft4+MnXqcgLf3k7F4XfYoOgFsNvv7Jk6fndxYX/0MWXfmoHFuss9S1L9u4txsIbQ2QX+rdC0L8zedp2ROWvoGBu/r7Oz6AHntghtYZ2u1Gq3AJAr7tWxWm+1+o9FkI/NbKiv6uhy8LapqtCzhF+qOXIA209JMpL+nz5z9MOm3l3mbz+dzz81OX/9coZBH1hRL75euL6n/LLVfq6rCMeC32ZwDA0MfcLk9j5Nx9bbRxabNbne8W683/FW1SkX/tNJb6uf8FlxvT9ot0G4L4M80FvRLBkkd/DM0fwr848Vk3SOIYNbjsNGybRajkQqmYc45vva67GC3mlVXN/wd5v3P7e1CgYB/pMQHHA7o8XbUwT86DHo7/bB1kGBKzSk7zlEgfWVtnf4uVkw4VtM7xQ+G74l/c+flTvwZgvbvXZ6GD144R5X6gVdZ9UWKuxTFx0ZBI3B1RsAxHD7OgedlABVAkrrH7yFYRjFDpMrj8fJizgFS4+e2ozTKj8c1GA7QqgKr0X0RcGJJvDJMegYQGJp2CwnzP64/Gy7zVQNG+N91epyK4DVqI9ToOOLxhpwuIX+fP/bpYCrBxcVVGOkJwb1jQ4wLRaLFcyLeFv7OV0q0ZKPLZgUn5sPzQPuM+7GbzGA0KLUF2C4pwboc/vNi1F5iAeh0EuwW2RP0T50gFAhCTj8eDzpQMFcfxwE/q4mMjvpeueOt4LatyPDgpD1zwOR0yM4o68ZRzrSry+uwQM4XajEIfecrD43cbbTZ7S1VzqXvb26s/78E9CPtUg30K/P62ZuqmuCVcpDVjMxW4F9N30OLkgzQxEB5q5qG8BNbg1mtvBFLp2UjbBZiONhHx0897vV2PAjt5/HzpWJx5zCZuHyYSKxjvjHm3/YPDH1EpJCyTe/vDDwiGuDN8szfMEqiiiHdju4BNSQNBoPN29Fxtp39ECC2ToD/BvMWG5mqKfbfUL4pGAoP9vT2/+9kzIahcXlGwLdBxu35WHQnSq5Dy9ip0w6fzz/Zql9kLbRDa8CvNv5aZcKalftiryfWeS49c+IzgLyWOrwR5/qNaK9zvtBrCwG/3x+4s9197e/tvYaphKBQ4EZH+eTZ859yOJyPM33hybX1lWtXLv1HLDkGrdX7b7VIf7NUiXppWPKwI+g/dfrMT7jdngdAxVS50UbOS6ivf/C3yH3yV2PRbaZUm6oQ2g2Lz71Rrcnc04pwK8G+WsqWqbMzMNDbP/ik2WzuaXc80ebNZbOz8fjeVHx/f4f8bejrH7inM9D1rla/JXaHtcPn69mNRVFwupnDEdoc52YUf9XcfrvDgaLDI+2OPZZrVbxVS6dTX56dnvpLco0is0bNRlFjd6mVpmQp/eah4dH3knvsR3V6fVvaA6BQ5VdrOMc9Xm/nQXw/A81tn5No/0nTbLcb8MemRk9khajq+f0Dju4XZw7Xhg16vQ7Ltp0f7IVOAnApQCagTMeqsQOnmsMvgauJriCsxA8gWcjDfjYLOSxDF+jEQnUU3CGdPf5ymoBMgyoxG/+eHOiF6c0tWi4P+/BaYtb700NPxD4QujfxregrHbgzLG/3pRdehfvHRmC8N0zz96XesLFilpIu/Mcx35GvIXWQKEWUJUzJ8bCbTEM2X6TigW67lZYilI6bHtfwAPxgbhFGI2EKKLH2PDIkODEijjn+2/m448X9ad/K0ZaN4/RUaXAkHIShcJcM7NIKBaQvi/E9uvoO+n11YF0VgTM6GA5SGRjtDkOXx9WgC0CPhJPo8BxNrzg4ytJSegG7sw608WOvzU5ZDDo4do6AuC88FnQMVMjvsbQePlcoUK9RPQGcH1iSEb+DzzWxukJV/A62muggoZOQr9XTMKTIPScOtLB/HXMMQPtt1hsEx5PNChacN7xwv+VUbh1y5wdX/xuPL5ZIwlPXrkMJ55XYF4/BmfpA5J7Vgb7B4XYvrFTy8Omd7U0UxNEC/WqGqxroZ6e9GtBXUpCVTgCt651l+qhRkt+S6E+z1kL4Scu4ZsG+jFaLlPax8YlPWCzWvja7wJfLpd3o9vY3tne25vlaTcpj54jBmCKGzRUC8t+v/JHJZB4EbQAK0MS4+SGbGm1bLdpfNyIJGJ8wGIxtObcODxMo0KZmCLLRfmXECsW1DKPjEz9CxuvT5PpuiBRXK5W9WCz6tc2NtXmytpjFc4bOlqO2DloQhlK7LtSuIYDGMWqn1rQyf1qNMceeY4naju2WEVNTDp3GOGiCDSwb1g4Lgw5ApZLdEqL9LDCvEWCgO33m3M9iBI8ZL76Qz3/h6pWLv8fUDL9lQf8PkdtP1yQCjN7XJuhHZ8hi8vDwZfIct9rsfo/bc7fZYhlT/hajqn39/b+WyaR+KXt0tA9yh5SW1gi9dm/GvLwBh5O0RinBvjJty4yOy+HR8feTteXhdlkTCPgz6dQLG+trTxHgmwFGNHBxYe4HTpdrkNwjwi02gylG+J0ZUF9zbmQ81KL9LbUNurt77rxR0WF2DA4O4n+5OD/7VfIa7RUl6FfS+7VSMGQlE8n6MNYd6fmfNZy77P6LxUJhMZNJzySThxtkvmY4HWfy+wPD5J70hFjCVdn0TqczRID/Gqiv8SftpLVstw3w16D7K40XGdX/ifB93+JqoJ/LrP9ktlAwPH99AR45OwFdXjfUNIOTEqyWN7QVB/1+2E4ewu7REWRF6v9YIEDBG0bo33f3GRGSqV+/uI27CJB+aW5Z+Jug5u9svdTxsYH3HnZaPQj+3fFi2oC/foGA7dnNbTjT3wODoQDVCeCl6DHa7jodBa+cKAhX5asCyG1AjY2RYfz75bklmCPbx7/0OgHkI9jtcDng/tMj0GF30M2g/sGz0/PQ7RMqgmFKwWY8QQE/pf1zenh292oHDVBzAgOhq8MND0yMNirnk98u7e/R/fQS0M8xOj06MQJOtQcI4EcRvlo9PeG459RyxTQGXlDJTxcLtDyhy2KmIoFYDYGCcxDAfalWpbn+eHzIJKjxx6kSHN0vB2w1BTq56uwD7cax8AdPB6cTHQ4cLe+nE8cVWRkI8ClDg4B71CuwkL+RbaIXRQqlyhIS6K87oORYv2GuYqrKSzPzsLKzS889Pc81vvxw4PzKBf/YXk9vf8RqtTnaub4IcEmuLC99BRqV+5X0fqXR2iB0Ba0Bv1pumxYdWenkk+jHrMq85AB4O4CTZqXplKDfzry2+vydA8TY/iQxFNtlcFSJQfL9pYW5b5VJg0YDX0cM8T3VDh+DWzWg/4YaKG3k9qvVYq8/Oju72hKGImAss7W5cREajUGWOdIAgmx2u3N8/PQvWKzWdyuPXTTAv7m4MP8tYgXy4vmTlJpr5XIp107fRIO/VZRfKWymlU+sFsViKaWsA429b6qVYOMV+5Q+e8tak/nSUkgMo5yBrq4L7e6LGOhXK+VyEZg1yGgy6ScJ6Cdr6z3smORy2b+5duXSH5H7juQkvdVBP4D6NceWrlRdmzp8/gF/Z+f7ofVaUN3f2/3K8tLCUyIVnR4zOQ/P9PUP3BEMhj+p0+tl65leb+gdHhn/9NXLr/0hyCuLSOBfWV1EOo6bDfqV16Ayj10J+JWiiBYC9iODw6MfN5vNbeW4A3WiFGbWVpc/nziIx5j9G4G5/2XS6eU2gD9G0P0q4wjM63ZZFa2cRw36BiaTyent6GjJhlJrZC4dRXe2/3h9beUFEIIUrPYQy86RzhU7TkqxVjrfyXVtGRuf+JjT6fqwmkK/NP7VaiWaTqWe2trafIms/UeK7RmyR0eXKpVyvq9/8NOgcn0YDEb76znmk3bSpHbbAH+mSUaITOAPRANGVPbHBQAXAtPjkfu+Z4mZuSuppZ8olMvGb752lQqiYc59p9tFo71KcKm+zAkK60iJR/YAiuIhYJvejUG/1wt+hxM8NjuNCmuJv2EkeCQShqnVLciWivS99VzcHC+lzH6LhxbYkxjeCONSuTw8R4Dd09dnybatApuACvtVCZDUgdNmAYvJDP0BPy0bSCPVKjBfGjSM0M+tb8PV1XUKhhEsCmKGYo45WRaT2Rx8i4zRE/fcAW6yTx0B4N0dHggSMI/bWI3uic4FYYBqohgfOh9w/31dfloyTwL91FHBC3XqN5NJClaxSoLNYDrmMTDmJHUAoN4B+U2eYJVCuUKV+fE8YSpCkfyNufw1XqDRY1/wEc+2sK/FFAypZGB9EonUfOFgBOBu0JOHziBqJXBUMBEj9jpOdD3ohPMjsAkEgI+A3kQAvV7UV5AOSCdpLfCN98066Jei/FK/6ieQ8UYwJ5UAGLiysg7T5FzSygFk/+Vaie+xdu2/P3z3stfkLGMNmXB3d2+7F9Vh8vApAgIP4Rj0szn9Jb1eXxHprqwnXXZQDodTd3SUkSadmkGuBHM6aKQjKz1XyhxkqQ/S96SSB1Ikm2UBvKWtBaBtB/RLwN8aCkcmiaH8cTLn2lIhx6oMBOT+5dbm+hQzFg3jT4zIpNrvxQjKzW7NQL9qKT0UhrLabG0ZzcQYfrVIJjnI8/jZuQmK93VdwVAvMeB+xWAwDCi3Vy6Xl8j4/hkxQDfg+DxK55XO10qlUmynb6hWDep0T6U4n7KPatRi9ll6qAF/CfRLLDkt0M+C/7f8utIYh7a0IAJdwWGz2dLZzsbJelck5/c6MGuQxWIxnZ489zNmi4UFLDVi7P/l1LXLf06uuwLIhcVuOdCvGD/lOt2MhVSP+Pf09j1O7ommVjtIJA6+t7gw9304rqNOWWJ4P1xbXXmVAKiN4dHxXybXl0yozWazPU6uvS/vxqKLIHdeaUX9bwbol5oyT1xLo4Vd09ln+hlZV1BL5UPtrulkzPLx/b2/EZ0oFaYv0v7r9elzuVy0nW2KTuTXNXYajBGtaH9DFQNk3uj1hrZFh6WG7KrV1eU/2NuNofgwrufN6P1a6yTrANB7O3yh4eHRXyTg/xSoO7N4spZvJBLxL66vrb5cLpUqzHYb7CHSt0VyjWTFsovK88j276SdtBtutyPwx6ZJ9xfz/HFcJPBvfjR4x3OdVk/mmdjln6jo+I7teAJiB0nwuRzQ10lAs99LI/aIuqmqPKO+roTwiA2x3j0q/i9i9Jr8W0scQiZfhH6/r14ujheY8A0No9APnh6Fb168SkGhnqDGV/ZnbfcHJot7Rwd6AwoK9nTD9Y1NCroRrqJY3VGxBFyxLFLJyYGRbWfyBdrBxa0oeB0YqR8Gv9MJautWtpiH716chiNq9wprtTyd4fhIMbvg2soGPDQ5TgE31q/nROC8srtXLzNHfyu+tpoMcNfIAAwGgzJ6PgW25Dt72Qw5hgL47HbooEFongLkQrkEWfJA/QQE9VilAAF+mWwDP+eYe3rdpcEJwFup0i/9RZ0C5J9OjOjTqLvBAEYyjlT8UK+jYy8AfD0F+PgbqmVAfoMpAlLOfsMp5JkXDKVf4omwGgvCGMm3oAyZKSn8IDI4eE7+fXzeO0yT8d+F+c0oBfuc6IAxc4bs+0MXFiY8/Qnyhp4YttaRsfExMn/aUnlHY3V7a+NZaAT90g21IlbOUOZYyoaeAf1qImNKsR+D4m8l+Je2zYJ+VhhLJz6D4rv1376VUX8NBX81Q5Gti80KZ9Wj/ZGevjuJEfHRJlEIWSMGSnxlaeGP4/H9DWBSIEBuAOH7evJdVYCPxhUoxBOZZzWWxw8zTq0ox1oGpCkY7m5LGAr1K3Z2Nn8A7KXXSPNn3+cGh0bu7QoGf4kAHAUtnC9lMpkvzM/N/H2pWJRqMQMzvnUDtCbUKW/ZsH+Kt7Qi/dJ+lPoQJmhMg2DLg0l0fxb4s6BfD43AX7rOlbRquAXSaVpF+1UBRzAYbjvaf5g4mC0Wi3h9UIejzW63TJw+83NiGozUqpl0+k+vT1357+Qcvi1Av8Y1p+U0aYhad/h8/TabvWVedqlUiiLbCJj7CCjWo0TiIEqA7OdGRsd/Dcta1k8ux5kIKH6SAP/fB3W9CjWn6psyfhrCrGoaLZppEcCka5H7sn381MSPeLwd90Ob7Klyuby5trr8x/t7u6i/I80jgOM1hwX+fKVcTrSzXVHgUjkfX++YtHK+1QUNsQyq39/ZdlUNqZH1dmlhYfZz6VRqCxpFh28E9Ncj/eT+OhmJ9PyyVi4/sX12k4eJz68sLz1dJogf5CkNasxHnpyvWrlciZvNjcCfbCMN8vTEN/SeetLe+e22Av4M3R8ba5xI9F9lBAMXHCo8N+kemB1z9f3J17dfeM9qOnqB1/NGzG8/SGfAREA2Rv97CHAPdLgpdV8vlffj5ZBOWu2sJlT8D8ECAf8IVA8LOchGSzDaGQCTQS9+/dhWY4uzBb0eiPg7IJpIUo2ApfS22WV16lCEzmGzwr0Tw2A1m+DVxRUaVRaCvhwx6MuU8q9DVCiJzInANuh1gcNiAfY+wouR/FQ2CxfJto4KhfrnFBzXquA227MRiz+q5/SVeCnVEcsfdurJj7A+fICMyVgkBF0dHtp7BMjbB4d1sIrbxkpup3q74cLoEGYfiGX7hCOlf1cFxX0sPajXCdHvzcMErZKArAdeivIzzAR8ZeQYzCpVBeBEME3+wzx9vXjsNqMJzFjK0IjlCw00Xx6Bvl7M7xdT8Rto/nW2A7IVoEZTAfYyGTjM5SDs8aDEbl1kj5OEEZUcf7HpRLDOFkwU8vpZe51rcCXwzP+ROYBOF3SQZLI5mrOPooVJ0p+9wxTVlaDpCXqOpjSQMcpNuAfWHw3duSGeE73JZDKOT0xOIPhv97rK53JXxXxKFuyzHnSler8sT4YYgbpcLisNihbgb1kjF47BhwTklBoe0rWtTAng4bgc260UndQCJ1qGojKv3x7p6b2DgP4fbzf3kxgVm/OzM3+YTqd2QW6UsOr1PNPBqtp2CoX8KvNdLaPwjTRWtCJHWsDWZLVavS6Xe6ydjZP5OZ88PNwHdaq8zPgma67u1MTkh90ez6fJRzJnCzECt2PRnd9fX1uZYrYhOcHYyBsL8lo2MSecHQfl3JHGm+23VoksmWiY+KDXl9fbEegMdJ0m12y/HqN9PJ/L5XOXVleWvlLI55WONum6Z50Pb2lrg0WjGe13uT1hu8PRFgsKI6pbmxvXxDGouN0e1+j4xKeNRmPo+Ft8JZlM/uHM9Wv/AI3rJgv6taqfvNWgv1WOOuuUrIPZrq7QXRzHtXIq8/H93e+iRoJiXNiUGrrPg/j+dkeH7+/JvPxZYK5Fcn0/RObpn5FrtwTq0X4lO+wNX/ObAFwWcLPjpSbKapfeM5nN7omJMz9ls9vbKj2KjdyfX56duf4nomK9Mn+d7Ud9npHzU2hn22IFAC1nVAMgVTjT20m1UY32B0PhMTIWHTdwKvhcNvsqGYc/KxYLB3CsQfRDgf7RsVPv9fk7f16tOgs68o6OMl9aXlr4O7LvI5A7raT5y0b8pTGhP69WK2nhcGWtepTJRKE16H8rGEAn7W3Sbivgr2jKqASbr4jjgosBLn5SVC1v5HSpD0fe9VSycrT0VOzKw4liKpAt503ZalGfK8ZhbS9OI76oDo8Pr90OAQKozQSEI6g2iVR7Ye88BcITwS5YjScgkSdArVqF6VgU+jo6oMNmF5jjTG9rongdAtCJ3ghsxQ+pwCBPUOPM4aoJgXSn20mp/KcHeiBPgB6W08PotEtvq31s9D3pRDlt+Pr6i/ZCtUQDvggW33P+NAQ8rmNfAwiU9jgB20gH3yTHVSagltLceUG0zmG07N/nn7x81jOISrA4RtQb+6XN5+7cyO6G8LsXl1ZhpDsoOB9IS2SywNcoVAaP0w49vg4YiYTA67RBsVQh/RUi9oVSmdL0EdzjfkUfBQXW6AA4blz9s+N3BEcL9hH3iiUVsdyfAZ0M5L1soQhGgx56vF5wmMwUiAuCfseguz7kvALVULOATeo4VhlAdoHdaIacsQSZUhHWDg6gy+UEl9kqROCl7fLiq7qWggjdOdlOgAX78inbOI1z5JjiKYzm78Nh+qiuSUAZCDR3X7zDi7oOZjDk7gqMzd7jn9gWJyQ1iiwWi5WA/jPEWFITldG8jvb3d58GbeV+NdAvA/4i6G8H8BubPJRRf1Bc15LxqBaZZNcC2Yl5K6L+bYhmSfmzatGherQ/FO6e7Ontbxv0YzRkZmbqc8RISYC8fjEb7ZfOFR1Dk8msRjOtJZOHLMVZ0xB8A8YJQBv0q+Uas2WgzrVZuorf241pRfulv+n3CLAznp4898+JYc4qtdPPiMH59OLCHEabUiAH4dJr3J7smtHplCuceiPAP6t4SzkebLRfbR6pKYfT95BK3B3pOUOA1cNms2VAOZ/MFstdjrN3PDB19fK/JuCCFcqVtApYB8at4lBTGyMt4CoKiUXuhDarYKRSyRWyruHNqkKAQefwyNgn9Hp9vWwmMgsPEwe/Ozc7/TU4XpukdVMCIrci6GfHsFmOumpJUVTydzhdLZ1tWBZ2Z3vrMjBiy9DoSDJIY7C6svSct8P3uFgjXeggp3OTNfA8UttBHmHXFEV7k9b7dpxMStZWg0aL3eEIjJ+a/KTZbG6Zey82PpVM/uPszNTnyX0/B8dzrFXEH3Uo2lp3OE4nBcy02CjKceCfbl4CUiuNrf4g64+lKxi+5wbGv5Y8THxzbm7m72pkXoE8p591KClz+jVBP5Z+nTh99uMut/tjcHwfqI97uVy+vrmx9kex6M4KNKY3SsfNVoJhHUPSGqlkceF1sZ9OpxOK8X5T7q8n7Z3bbjvg3yTqrwT/uCDgRV7P9wfRAPAYHHsfibzru2QB8tQ48G7zyTNPbb3cmc7laBm2VD5PI60b8QPgV3mwWczgtdtoHj3Wt8dofAXBJsdTYDhAALAlY4AoBbUcrBDQiNvo94nMITFaXKNZ/DoKwMP+DvA6bHQ/CCXz1SIFkx6bjUbSMV8eKwWgcN3GbhyS/JHuO1svW3+s5+GU22gzke+bkFFf46vw3cvXIYx5+F4P3XaKHMdWPAHpbB50ep2YO88JYoB87ej+ztPP3ts5OcvxvE4E/WZxHOFu/6nVpcxWyISBLvKbaPwQugPkOMjO9g9TcH6wD84P9dNoNo7V4t4eLCfiVFCP5ptzYk66uBzqZXR8qbqAELWnJw4dEqSPVgT4RiOYjAYB7BuMtNIA/R5lvwtOE2QJLJPxXdqPQ7fXDV6LTUXQkGmi4B6N7pNjMOj1dGylFAKE/hIPAHP5fU47lFMV6sTB6D+mB9jQwSA6F1DDoVyt0O0Y9Qbt/TJHrfkdOhQcPWcXF9eoo0dgNYAo3CicX4GRwIOR0xUnO4a33h04P6XjoSyqEFJD1uVye0bHTt1pMptvKGeO3OB2YrHoDGhH++nNiWwXFcqVXm068CaTSV8qlZRGkZJ2qxa5VeYis3RkYK7pMtM/pTK5MuWHvTlL37lprYVx3YxGK4v2E7Ax2Nc/+LE2QT8BpcWF6amrf8DUMVZGhVg2Rb0+OwG4DfRGMveSBCivK8a1gc74Bg1Zu1EjGZAjIMza0eE/384OyLyNkTm+onJOWNDOk7GwnZo480vEML8bWJ8tzxcz6dSfzc5c/4KY8qKMWgIcG5qysm8Gg6KWqEYj509yJijHhN2+Ml2DnUfKyCydW+HuyNlQOPKEKB6muVihv2NoeOTHpq9f++8gZ9ZoRVdvelOIqzUDHA3RRpMJA/6eU+3sB/UWtrc2r+I4BMng9Q8MPUmAgo35PLe/t/tbS4vzT4O6AOqtDPrbBbGqwnQej7eXzJWW4qLZ7NE0uSdI0X4W+LPsmHoEtVKplI6OMi+Q7X+U3Y7T6ULhzmehcR4qQf+bFe1vF9yqgf468CfHFSH3508ZjMa2asFj6k88vvf/Lc7PfQOOI9uSeF0z4E/nW7VaaYvqT/YklZxUgv9W63y7aTZKZyQB/aFRq9UagvZaldyL/n55aeGbZEwwl1AC/VJajTQeyki/lv2BS7J58sy5nyfrvYo4JYq1Zj4/N3v9r4ltVIBGh4h07HqQOxpYRgqdi3iPUh5MuVyarlSoWGjTdaHF2J+027zddsCfacpIn5LuL0X967n+cLxgFAiQqjwXvdK9lTsYTpRTXpqXzoJUTqRvEzCIJfZ2iiWIpdI0/97vdtCdWQgwlVTYQ04hRQAjxQhEE7ksHBHQPtbVRcEjxwvK7xjJphoCBFheGB6E71yZqivkI/Hc63TUtQGQzv7o2Qn4xxdeA3RKrGZi5pf3rlvfH7on9Ter3+socVU99hhBN7IHEOxzrLCcXojw00Gq8tlRd+TVR0N3vWzTmfIiaJSMx3pUsMPkOqpUK7xJb+IQIBv0+jpIH4p01V+jIwB/MNjph910hh4rzZ8X8+Ux4l9lVPQF/M0REG2k1HwE+BTsk7+RUi+UyxMp76IgnlQu7zjYzpPfmqm+wvL+PuymMlTZ32O1idoKKnYpJ+TCb+7GYW5rBzK5PAyHg1TckdINxH5JB2YmfQq63BDPHkGpXIGDbJaCbmQD4OZRH4An6zseWyKTpIKLHQ5JpJWN9isxssYMxnlkMsFjF87AzNoWLFPxRDKf7P7DQUf3vlVvKpL9Vy0649GIOxInnSkCL78BkRtpmBind5EbTVsgg22pVPIHxErIQwt6PwFPSspy/cZPzp00+Frq4lr5x2p5yKii7na53H6bzd5BjEybDoUwSN8qWDItuvODdDq1I46ekpLcUOLpRsfjDWrt5KprgX6MDHUNDY9+ol3RJwIaF6enrvyeKNTHRoWk49czz7Ja5GRfQ8rtkXN9ScxNVxqCquD/9YCXFlEjpcHWEL0NdAVHTSZTW0Z0PL7/Cl+rsfNXCfxrxDD3jYyd+rdkvskouORnxO6MfmZ1ZekiaBuA0tg2RMyMRlNbKTeFfE5pqKtpEDQThpSBNLfbE+kfHPqI3e44DW1Guc0WywTI2TfSvpUA662O+mvRrtUoxvQ5HEF2iL6lGB02AkC306nkXm9f/0h3pPcDrLYGmQ/p6M7W/7m+tvoqyB2l0uOWA/2KcWvlMFGbT/X8dEwTgTYcQCmBMcRWNmCdkUxo4NgRmTxMXCfX4ZPs9k1m8ymQr6Vqjqg33CHVRAfhRoRZKfDv6PD1jYyNf0qvN7TFxMPoPpljf0Tm2EvQWGGHnVfA9EsG3Ml98mp3pGeOrD/jzfZVLpUXoLFij1pKn5rTvx0tFnYuIfvIGu6OPNDmaeAP4vtfX1qc/zZ5nQW5BhEL+tl7PrsWNKQSYgrk6TNnf9lisTboK5Bxj5Fx++za6vIlaO4MYdO72EoT0gOzxVCvy688oEw6/Qyoa36cRP1PWtvttgT+YtRfMj5k4J8srnpBIZnHoHwZWTvk/ZIovEPB/2Jq2/v16Is/SS57N+aIozo+llfjmVrsZaRbE1sRI/xeAuysBKw6rGbwe900f1yiorP12b0EgFq7jLAU3ye/56ka/dTODowQcOyyWEGP+Kh2XO4Pqws4LGbIFcvUgYD7M5kMYkRcAKXokPjghXPwt8++SB0Kz8ennE6jvfLpoQ/ufnnjeW+sELce4z2hrj0+E/AOhUqhFrJ1bA85I1ceCp6/puM59JZKtZlpKj0ce47p4k1we/FY1o6HoN9bLy+HeeVXVzcoLd3ndFJHAFYy6HZ7BJE/ETxTxgLpR6ZQgHQhT9kP2KuJYJCq5SsV7tEkPw7RHoNwDjhV+IyOlOHOTupkiaUzFIR7rHaa50+3wx2L7eE47qdSNG3hCMUQCYScWtuEK6vr8OCpURjuDgoMAImpIIL/gMMJh5i+QcD/YTYHeWOJOhhQDBDnDJ6LDqcD1ghQX93ZhYn+CAXw8poKjfaIlsWM8+N+0p9zQ31wcX4FRRS960cxT9jZmRtxRtYnXYMxMqgyQId5lgTwnyK4/wzHTsQ2G5krxej21vOgHrGiNyWD0cjTkoc6HVcsFFia27ExxKNzW2/gcT3i+boRKbJJTNIzNBoE9G80BohBOezz+c/Z7I5RAr58THkzWevw+f+n9bWVX4nubM8wfW1WFeCmtTZqGrfM6yfj7RofP/1TBoOhrTrjpVJxZeb61d8noP8Q1EW0pHnBRiiw1ZDmb7PZzyqnRTqT+gE0GiZaOYmvF/QDaIN+NRq7TByKAP82S/hVMjvbm9PMW0pKpo7MvdDg0Mivkjksqw5QqVRm1laWf2NvL7YFcmONNQClVBs1Aw5TKVoa+0gbz+Wyyoi/NB7Kc6gmDFmPpmFkmhzLe/2dgR9lo9TtNGKr+qAR9LMMnLc04s/0QQ2MaelBmDF/1+/rPNPm9nmytlwdHhk7R+bYA8zYYxg1vrGx9hs721sIaiXwoZYadUuB/jZArFrKiAzw4wMj/W6Pt2VuOpnP5UTiYAXk5ZXZ3HSOea7T99OpVAzZNUgFl7ZFrsmQ1Waz5XO5ArSO+L8hDqk2nZJKDQRlqhYF/cjcInPpk+Q42irhRuZYcm1t5bMEgOKapSytywJ0dg1SAn8UFa0sLsx9ZmT01K+T86bKdOFrtf3trY2vggrDD5pru2g5kFpG+8PdPZMEdAehjVYo5JfIMWD/pHx+aSzYnH4l1V4z0o+ljScmz/4bs9l8F8jXMr5cKl1cWpz/j4eHiV3QTnOU9sOysFhneh34ezxej16vkzmm0bGwubn+EjRfI07aSWvZbkvgzzRlbi9SnKQyG2oLNS4a+ZcT199F8KAbpd9cNht0iWAeAY6ZAG8s12c2G8FOQLlJpHMLFHUQQTBfL9kmEcaPI8YGmOgKEvAfpyJtCCgX9uMQIkA54vGgdVUHvpjDPRQKwvX1Tfq3GSPhBr0sDx33gNoC940Nw4tzi6SPevj2zquenx76YPETg4/FdvIHhm9EXw4dlfOUF+8y2I8mPYPzTqNlf9jVu20ADiNJOfKRFNVly8CwtDt6859JrDlsRguNgfcHO0UALpSl+9rFK3CQydJj3UtmYH47RiP4j911Buz1VGGhzB6Ol8tqpY9OZwU2EwmY3d2FEQLYzSqBaemOXaoIIth4zMIHXJ2uz551ZBf0dnghSkD9XuaIVh/odDmF88IL9yVMD0BHiNNuhfvGh2F2awd24od0Z/i9H8wuwG4yBQ+eHqs7N6R0BAT4PtRpwBz8Uok6cTDNAOeDjQB8ZBjoyI+GuoPwwswCfPmF1+BMfy9MDvSAUNSAUzWTq2IJQvkUFv7GeYGskXedGYfxvjB878o0t5dN2uO51MSV/YXgpwY/8G2r3oxzGHORTaPjE/cTS2xA2gC5UWJe5frA4PDpdhwB+Xx+KpNJ74MGvR8flXJZjT7PRl4MBCCpefzpsyiaw4KUuvgYirNFevre5fF67yOH0wVtAAsCZvzh7sg/J8b5rzJ9VuZ9KqfVm940qLRaxrUajZYYjZxt/NTpj5gtlrZyQDFNY3b6+u+R84hiR5JxqBQ5AjgGkLLx7RsYuI9V0sZG5uDR9tbmq6AelfihVYjbzOvXVIPGh9vjCdts9rZE2pKHh1OlUklTOC8U7saUin9DxoFNecC0lqdnZ67/djZ7lIJGQ41lUnDMeLNjQo+TGJkeaNEwb7VQLOaZt9gxAWZ7atHZ+jVF1oLQ0PDoz1qsVq2SVE2beK2qRVbh9WzvjWwqNH+1aL9qfn9nZ2DQZDb72twVHw5HTjmczkH2mIldsb2ytPQb+/u7y3AcfVU6TNWiprcC6Jea1vWmvNbUBOqsvX0DdxoMhpYAltwPDnPZbBLk5VclJqZUJYJlsOD39ORaSxMwmuX0+jrwJ3PS4XA4vQT4HzL9V1vnb9Z4KVO1tEC/vaPD109A/6dE5fyWrVqtxpeXFn4nvr+3BHKw2265Ona9rpC1b+PKpdd+cXB45FGX0/WY3mAYIuNpQ0FPco6uxWI7/08icRCDY6dCKz0faUxagX4W7LOOI1coHH6wzVNR3drc+CKWpYXG8sKsE4k9T2oiwtSRSUC//fSZc//OZDIp08NqZK5+cWb62n8h94kcqFfiYB3myjx+NZ2haqAreJZ8RYbP0unU5wv5fAbk64RmlY+TdtK02m0L/BVRf9aDzOb6K1X+Ke2fgLdDTgSG2UIBJvpPC6Xe9JxQ0o/uQWkn86KivPA7ADYifXydUhcBAXajBODGMhnYIcAUgR6+PiLAESPVnJiTjr8e7wnB1ZV1Sst32yw0x18SqxOwo9CHsZ4wzG9FqcI7vvnlrec6fmb4iR2XyV5JFtI6PQGk+N1kKePYyccdH/Y9iDmKR8zxs1REbGwUSVrkKitHO2HcAQLpyf4e4ZhIf6dW12GfAOx6IgEn5LtjmcFvXbwGT1w4DxaziX7ASWMiOjDMpG89BKRvHCRgfm8Phvz+OnVeUiSUVPeRIYAlUq1mI7jECLvAwqjVx1bC1EadAcJuD3nOQJyMS7FagYDTSdkZFPjXBJcM0hg6PW7o8npgJbYLlxbWoFirUOfBcmwPssUifOCus0zuv3DMOhCqAjjNFnrua2LaBKYkYBaFVOLwwYkxMgZX4draBsxubsPdI0MwEA4IugfAM0iA0wT97PzBt5FN8J6zE/CdS9cpeyJfK3c8t3916P3Bey46nS736NipxwhArNejPsqkd+dmp6+43B5/m9F//iAefw4ajVc1+hmABuiH45u+Wn4tRvsbaNoWi9XbPzD4PrfH+25iFDngBg03g8HYT35nFpXQlbl17OOtptI2o2YrDWvL4NDwgy6Xu63IJDn2w8X52d8lxjI6blijSEkDVfaNjjWK2BHD9IPK7RLD5BliZGdAnkKhFgW64dYiz7gduih9hEKRO9uZ42TNKG9vbV5WGQP6OtLTdyrS0/vLCucHn8tl/3Z66up/LpfLUv6r8roAZjuSU4VX2Q9ntrQGnOVKeY+A/6rit6yzRnpo0tn7BgbvCYXCP6vT6WVMEWS/YclGcrodrfoh0sWUFTMA3kBg9Qa0dh1G9UcgGGpLC0JsOgL6ZekvZB4sLczPfiaVPEQPPXutaYF+LfruW6XS3W70WrMM3eDQyP0EzLRVCrFcKsXE8pTs+qEWPZWNFc5VchkkFGXVOLvdHiCL3Co0On7eUHZXixJ1WuAWx8qufHi83t7h0fFPtg/6K/uL83O/RYA4HmcO5Kr1LJOLZXMBcz5loB+E+Wgsl0uF+dnpr5DX/0RuvCaj0aSvVMp5ss5LIFfL6a+2prFj06xKjZoDydI/MIQO/pb6ENgKhfzi3m5sDhpBf6tIvzLVEEG/Qx3086VkMvkns9NTXxTLgKtV4lDaQEq7QmnQIf2Rc7ndj8jPb3VtZWnha9DIDJKl3jHb5m9nRX/WAXc7j4NWu22BP9OUtFMtob+6yN+4vf/ZzexrDxp0BkOhXIGvvXQZHpoco8DwuHifBF95EaJzzC5EeNgALQRwWKpUqAJ7l8NJQKMZluNx0hkesqjSvx2Fka4AzW/HbVrJ5z2dPthKHNIoN8eUrgNm8wiy30X6+JUXXwMsz54sZ01P7VzyGPX6GgH9Oh0natqT/S5ltkcvHsxv3eUbuwbym4G0mEmbZm+8VfJj2C7s9+LOUak/4HYTo7RKj+fi8ppQgYCAWYvenHPpLYX9UsrDk3fzhSK8OLMAj915lirvM8MEktI+Rsr7/T7YPkzC0v4+9Hqx8oFNPHnHI+4nY4YR9q39AyiVq9DpEuxYQTgQgIHmNCUCwXuIgH9kaWwlk7B+kAA/Ac2YdoEsBdbJgm0oHAS3zQ7PTM1AvlSmn0RJny4vrsH54QEmDUGg//OiBwaPXc8DwzxgnD3krYfOjsFXX7xCS/A9Nz0Hry4sUy2BsM8LQZ9HECjkJd8Uz8winnlP2DY6KjLZPLwyvwxSScZqlQcDZywFQ93dff0DjzHCMfxh4mCZGKZT5OaiR9pyOxdNtVI5iO5sXwN1USqll1uNvs6Cfi3xPhk4QUo/ufk/RPr4EdL/Dnj9RhtWnDRB6/JON6XdIMVfNeLv7wwMdwVDj7WzPzKP8sSK+FwyebgN6urG0jmTnhuEsQaGRh4m60anYtO1/f1d1jhpGb28wTGS+nMjkX5ZKTGMoLs9nvF29plJZ5aPjjJptc/6+gfPhrsj/5LMIzYHv5JJp//L9akrfy0agpKhyeaSKg1uZSmn+jhbbTaHwdA6r7dYLG4rfi+NCQ9yANIA/Mn2sZLHT7lc7idAoU5NAGtqfXX5+UKhUJk8e/5D0OLaqNVqRyCfN7dEuwEV8QZhP6vV6nE6XYOvc9d8sVC4MjMz9dl8Lsc62NSij7cc6G9SXUTNgaQK+jFCPDI6/ihZny5Am3OiVCruQyP9mR0bHcjXlPraQu5hKSUfkIBFD7wJQF9lrAAa51kz0TrVvH6H0xUaHZv4JLk2WzvbgILCAw3QrzXPlGXldCBfp1nbt+4UJ3M5Sx5qJXLZZ/Z8KFszpk1TUUgChEM+f2db6VkgBCWeAjnoVx4/2ye1dYD2y2Q2Wycmz/5rAvrvkO2A53Px/b3fXlyYewbkKSla7C4l+0nL5uCJjXPBYDD2se8RG+0vyDp8BNqMgts24q9g2TT9/MQJILTbGvgrov7YJGSlFPqTFP5peb+zvqGZ3XLir68mlj9lJKA5XyrCdy9PwXgkDGcHe0W1dqjnrGOEv14qTozy8rykUH/cH/xGpVqlkX0EzOgEwHxxjHBvE1B6VC5RYDwdxZJ/XppHjlHmga5O2CHAH0F7lSkXSKEhJ+T5Y/PY7bQM4Nz2DgW1M0frLqfRVsV+YLlBt8MGGwQwG/R67pndKw8MObuXPSZHBuSLChsNlBknL+1O9ZHdWvG4J3t76DHg8V1d3hAF93jwGhx7PzPyxMvk+Llnd68MXUouncIvoeMiX0YqvHjb5lhQKzTM7+/p6ABzOg3riQTkikWIeL3iGBNgzenpseIYum1WWESGgysLoz0hcXwFDX7pNT0IMfCH+fcoGrh5eEjz/lFfAEX6bEajmKghnDscVr/bCR+4cJZWQzjKF2lc/+raBq1ScH5oQIjKc8el/iTXgdzkYO8BPNjNVrh7ZBBeXlgi55GDQrkM0xtbcG1tnfaxJ+CnlRcCXjd4yHmi2xRZBTgOWCoxnc1RPYHYYRLiBK8YdUYoVPI1n9kd7/EENv/Xhz+hJzfPJ6Qayhgh2Y1FX11dWVogr83k5mYhAEAJ5lQbAUSvVCrlLChuRP8/e+8BJstZnQmfzjlO93RPzvkmJZBASAQBYi0wOGCvI/aaXT9rs7DrXYz9r8P+6/Xa68deex1+24/T2sbGOALrJQghgQQocHV10+ScezrMTKfp3P85X1X1fFVd1V0j6SIh6RNFz+1Q9eXvvCe8B8E58aCpWfqVoL8hPOK8teKPWgF/qz8Q7B4eGf1Ru91xHl648IZVrEl1UVr6+Trf8tKCxV9NwFazhCCYtfuHhke/QyeDf213Z+ePYrH9BWgWDCULhVLQl7EOO50uckN9j/LGpVLpue2tTeJO4AVBLTBDRZdV4gygX81VlO8vihG9YOJcgVv1097eznNqHwwNj9wR7er5MXnu5nrp6PDwN2ZvXv8UgGpaNjVrv5pyrNE2n88fNRiMbcc0n8ttqNyDJ/XjhduGUOvxejvGJ6Y+jPPnAijmfCadnl1cmPtqsVgwIGgbAB1rolwpJ/ix5T56uQijrSzXvMt6Q9lI80VvOkxFqedyucdnb1z9nXK5TG7rSmIxNS8pVdD/UgirOlL3qYE1KW1fI7Z/ZHT8vrOAfiq4jxyCuiWTf1UlNKvWqhnl/UzN4QW3SgGgRympBP2ymH67w9ExOTXzfXo5Wmq1anplefFXEfSvgxz08y7+Sku3EvhLdeYVLRL3DU/QCVz/qxmEWu31rVz8tUJF2Dwi5dHQ8NgDlEJPT59UKpXkzvbmZdD2RpSK2hg13PtxDKznzl+UsrQ0CspKx3u7Oz+/vrZyGbQNH3w4hZa3Q1NIlM1ut4XC4fdzv6H18KSYAUSNB0Srv1/xRQXwt1vTEt571SsAXtXAnyu8sMJvbNLmJ6UDawCWt0fv+mKhWvEvHG++24zgn0A6gWYCYf2dYRiIhFisNttdJa91iWEeX04QxFPOegKJ+WKJpX+jPPXsFS8CdWSNthqL4C7bYKorCrvHaQZM6TebCJSP8ycwEg5DGMEg8ZYHENg3tBji81hj8LVYKbM0d6SY2E6mIFsoEkg2HhWzFGoODqsZxro6IY7PKJYrpERwfG73qXu/d/Btfw/qrnFN763mdkYNokV7rLeLERiSByq5r9PblWqt9rbeO58R06qY7omcX76cWhzFZ1noVxv7CRjrkUA65xkBpzZ3anvE42UW9Fgmw/pwJBRuAHh6vsduh0KhBIVSmZEJrh8k4I7RYYh2+Jjng/CAeuM5EpkfeUyMhEOQyOfgAPthJREHv90BEa9X8KaAU0nahc94EMH/Fy5fZykVaazmtvZgJ34Id0+PQcDjYnWmVIP8JFPfmQTPgJGeCAL+ElxZ2WDvhZ2BEnZgbisX923FE0a8oFapUT4ZcNosLGtBEb/PFCxGIQyA7oPzp9zl7NjqcYSW3hg9v+x3+GBicvpBxGsNF1QEvoXN9bUv7u5uk7WQDtxauDPaqYfZH59Rje3vk5t/k5sf3lcZH942nlYE/Xx6vgZTP4Gr4ZGx+8KdkR/Gg1/VAlIqFQ8T8fiC1+vtc3u8PdCmkDVWJGm/pVagMxQtK5Eea78dwdt7LPrSPJHl4FMb66tfB233Ry1g1FCSjI5PfBeOhVIwrScTBx8HOehvRUCk6+BtAfrbpRJrcjc2my1eBCG63LZP8vlYMhHfV7YR5+LrItGuHxA9RoQ36/ViKpn4lYX52c+Bej52LWs/P/7Kdhm9Xp8eHoL60WFqQ3EfydqvJJRq9Fe0q3t0YHDooyaTWebhQ4Sd+3t7D6NQO4ftYnPM4XDqYhMvFotboB63+nIoeuaPbP+hMQ4Eg+eex7Pqx8dH/zx38/qfE4s/yEG/Hku/NG4vtbtuKyWJ1nprgLa+/sE7OiPRJvbzdqVcLmVAmwRUKavJLjrXlPczclkVzloXPeWMafu04vqdRH44PX3+e61Wqy7lO67Vwsb62q8n4gdLIAf8yvR9aiF4si6CZqVKYx8CdeCv5pGhlbq1VZiIVnaRxlzqHxi6w+XSx8lCJX18/ASCfykVpHKt8W1WyyLEzjo838wz5y/+mN3ueBPXdppgqZ2drZ/d3Fi/Ds3Ek1qgX2tuKMMMAc/y9+Ge3Hc6xvX87s7W7+C8Lmo8S9Wb7pUMbFWUkvyrnvKqVwC86oE/Z/WnwhP98VZ/WnD8QmWbw7t77vkHj8mWRPD6A7hYrRkE/YVkGSwWM6QQlPZHwixVW53fAuoC2LSJ6ZmJ9M1sFmRAYnu3I6gj0j5Kg0dp6igHPBHgIWiGqMeDoNYKywhkSUmQxudd29mB0c4w8zaYGuhuPEuyMNfqQv75zEkBzC7hnnchCH7k2k0WTiA0usZCBgJeDyMBfPTqLAPWW/n4RKx42BGxBU5A7j4KoLAC5qsF524uNUjp6cZ6oyBlv7q2usks2GQE7nIEV3qd4W2xJ7AHTKVhd/fWRn5/mCzw6wdxGO/tarjHN5za66fx8Az84/06EfwT2N5DgD4X24eRjpDQpwbBit/VEWCvzywuw1EuB4/fnIPecBDGe7pY/HtNaoZEhCiicqpHh8PFAH8ik4XjwglTAAQdTqZYsRgFb1jqO7vFCm+9dA4evnyNhReQciNdKMDnLl+Fgc4QIzckIj+v0wFWrJvB0GpvErwJZob62Fhf39iC/WzC8q7eu9fe23d/7Jn4XCheOg5v5fa7cpWctVAxGaqUB89oqtpMpqrX6jmO2APb3c7Q9jn/8IYJDDRmlUgk2jcwNPJus9ncIAlDwSq5vLTwqcNUiojHbOKcr4dCYV2Ha6lUWk0m4xvQPrZPGeuodO2ztHi1IOLwjk9O/4jL5b4fVFKKkZB3ENt/CoHsYrVatUxMTgfcOiAKfjfL1e8lA/1ndF9Xtfb3Dwze6fF6p/U87+Qkf3V+7uY/QmuyJzXlQ2Od9/T2T7ndnjcr710ulZ5dX1u9DOpC0POySrRwn23nJqrqdtw3MHA7Cte6QGwstndT8RaB/tcj6P8e3gJM2V4Sifh/W1qYewTkXCi8FUjJ6sx7mWmNu8nl9vRBm1KtVI7S6XSKu690DwC5d1ZjTIeGR+5C4P8fDAY5MWO5XI6triz9TTIRPxT7jtURhW5daQ/Tx0eLoCGIwkukDGhD6tcqvt/SEQoPWq224BkfWcP++9vFhTmK+6V9ppXbdUsOjJdKKFUBslqhR5pW2mBHaLCnt+/toDMVJF8QtJ2ovK3mgdBUxBCbb2Y/8fVpN6/ULP1SSIR7cvrc++wOR9s1L7a0sruz83t7uzsEQNXc+3nQr3Y+83aI03jBUyWA5P6vVI7zxjHeSKb0xFCOlZrHSLu4fofH443iXnWv3jEhJSwCc3K/V6bHVAupUrP0s713aub8d6Hc8RDIQf/h9vbmx7Y2N6RUk/ylxeCv1m7Zs8TPDYNDwxc9Hs/7+L7OZjN/truzvazxrFedtV+x5pSvWrJcXes9ut+rEfy/6oE/lb7+QTZh8vkcFBG4UR76WrVK2uMaWTexSOCf14Kyxfrm6O1fCdr9+Uf2vvEjBqPRVUGAu7izz2LNCchTnnkHgncJwFJhjuP4awKODoOQiq1R2PYr2beFeSzRuzHLvNkKM11dsHRwAHnKdY9vzu/HmIcB3a+uMoWJJK6MQLwmstv3IADuQWC8d3gsPBIrQzHudLkjdpalIJHOkJXb9Njelbu/Z/Ct5L4qxf9Ki0tmCfzawY1Ji9VsrVRqMN3fw2pMOesXdvZYC6q1SvUN4RlKRZIT78E23Hs6z11dWd0eNJksxr3kERwi2PZRXnvRS0LwWKgx0kRSIBi54yrk8mCbzbCD7ViKHzBW/k58jwA/NZXc4t90cQq+9OwNRiK4EUtCKp2F7mAQhns6WcYA/gRsOGQYqFFGiPh8eE83nGA/k1U9WyqA22oXCQOFUA3K3HD/xWn47DNXQRpgUgrsJFKwHU+xVI4UikHWfCvjZZCCDOR7lDTepCC5NDrAYv3nt3cNX9h5+vxbu+9I3xe9SIdNBQWEaqZ64jwu5c1Re+DYbDCesC7CeQqcFp5c7kfHJt6IwuubOaBSP8nnFxH8fQpBII1nA/QjmCMPbl3M1Sjgf00is6H60PPwld1H4BNginVKREvAhFIqmfE9BtZEdz1Zij7820zWtbqQyo/eMyPAIrb0D5vN5n5o3tDJjXZhdWXx0Uw6TYIOCU9Gu93RlgGdrYdKJSndB176A1Nqmx7QLxOMUDAJd3X3vhN0KC+wzQkc9z8S05KquX9KddESUkwOh8Pd29f3r0ARC47dV97d3f79FgRHZ7ZKaAjVWu7GreJm2d84tzs7O6O36xmQUqmUie3vSVZ0tgUNj469DiVQFMpkoL8oxnl+CeSgX0shxo9zK6HQhHPZY7PZOtvVtVAsbODxVIVmpYgBVDw4Jian34Gg7Md5jwUQ9oUrOD8+iftCDTjQT68OZ/t9gSzbiThTBqrGXuvp91tczhrfb40wZu0zFcob/vcL87OkXKNzTgv0t4vRfalBP99fTd4i0CYe22qz+YdHxt6De731jI9nBc8KCbyrcTOovX8q9Kv0Gh6OZX6MXqT+0apfK9CvFdfvHJ+YejuC3Cmd1aAY9r/ZWF/9Gsit/Gqp+1ox7auRzkkAXi0Eju/DuuJ+avduFVrTytrPLpw/rpGx8QeJiFfv+KAM/1wmfUwp9fSCfuVlHBufvN/n8/8A327c69M7O9s/w4F+vZb+VuEEDfm5oyOEIk/PR/AnjTVTqZSvL87PfgKaz9RXpbVfZW/i/24H/HnlFv/+q7K8BvyxjAwP1rhJVdP4mhYJmOGCf/gbnfbAwWP7lx/aPUncjjjHnMplIb6ShsXdfRgIC/HZAZ9HcFlHIEvgkF0Gg0gCp3ycoTFNlbndEf/CVLQLNpJJiONz6Pfrh4dQQJBFMfD1muTGfqo0oL8oHEC61z3T4/B3X3mK1YHep7SEEvP8XRMj8H+eepbVbefkYLpUr3zJajBLbP7SK0/MZl7Px2aoDVEE22QZZ6EPsQQC5gqrX8ju2xp0dW3BqTDKBIhOm3+/1965tlc+HCFL/pPzy/COOy40rONCRwsu7AYxll96j4rb6oDRThsksR/Itf8YcbAPAb3E4O+zO+F1Y6Pw6PVZKFcrkMxWmPdD7OgIejqCMNgVZqkETx3/uXj8OjDeALcVgb5F7ElRO8CyN4hf6/C44Q2To/DVuaXGKNWFL0Eqm8MrC08vLkPQ64Go3w+dfi8j7KNwAQLJdGeBt0+oBQ3fHeNDkDhKQzyTsXxx55n7jorp2r3hi9cI4LuN9rTbbmcbf11g/JO53iGId49NTH6Hw+Gc4OZp7fAw9SU8SB4RQXgD9NPVGYkO6GQ6L+zt7lC6Nnbw1QWhqsIpHhqqGQSb7OAj0kBxvC215lh+SRHQOBRFMqgPstRBilKrVTP7e3ufRqFngXgJQBCgSHlFDOh6c9fvgbYLqfLvW1JaMEBrMR0rierso2MTD3EkjS3GrF7d2Fj7IzGlFR/Pz8f0AzTzCjSEE+KFmJia+WHc25pyKOfzJ/+8s721AK1Bv24li073fi2rYxNZFtbdNTI6fr9eARLB26Ko7BVA/8jYndFo97tBpvCol/B7/6MN6FfzpgDub01LUCDY0acHOGUzmSWV+/FKBvYZre3pmQvf6fP7f0jeDqgeHR5+en7uxufEtWnnx8pitVpsNltbJu1C4WS2XC6dwIucvvGFFA0Qq2bta+IWsVgsLo/XN3aGx9WPjw6/sLgwR0pyLQusmov/ywb0c+Us605GngnCvvQOq9Uaev4PN2gpaZQKyibSUYquaxqYWq0Ezfu7llXagPNG6Qmq7Jum37TpJ7XQo4ZSsn9g6HUdofDdevsnm818BefZZ0CYX2dRLrVagzwwUioNtYC/WjiGVly7Fh+LZO13KC/cd+91Ol29evuF6nwQ2/8SyK3jamSGmtb33r7+SZQ9PgQcNiJ3+9j+3i9ubqxdg7OBfrVQIv5ioN/lcrtHxsY/RqmGuWemtzY3f7lYLOZB29qvZ1y/5YuGlb/VxZd250/91Wj1fw34i0Xc6KV/Kl3+eeFcdaJF7YHN7x184M/3iqnHHt555t3x4tGE2Wg25gpFmN3ahRubO4xtndy+KS+8x2oDh83KwB/KVmAxGxkpIMWS220W9l2JFZ7i0k9d+IX/p/cHELg67VZGdEfKgFg2w1zOxzo7BQwpAlOTaNGvc2uCyPy6QwHYPzxm9ycyPGnfJyb8kMfDQKvJaLZ/Zf+5cw903fk0nG5mIPYHAwd7hWT4sJDutpgtMN4dFTwLsCzs7rE20L9HnD30+xM43YCl/Lvwzt7Xf/1/r3yuFz+wHRxlYH0/DkNdEWYFF3QY5LFQAWNd6CPhBnWRIN/A2hd2eaDqrAkKAsPp+qfv9nR2wP0XphohDBRKkUxn4TiXx2cdQG9nCIa7I4wbACTPDH77qJ/2O3kdSPtHwx8L/znUE2FeEvPbe42Ue9SvjHugTnwNJva8dDYPC9u7jMfBhuNOGQQc+FwHjjspBoJeF3hdLuYtQV4ccRxTlNmNX4vduG/aNzQftHqTwGdSUFjX+voHp7p7et+PIKcBgimXLYL1v0SwfB1OD1yz+Js63t6IQGNQzzo5OSnMouBBJF6tXPyN3Ktk6bdiPZQCETsAxc9MKCwSw/gH3G7Pu7h7NEbh5OTkueWl+b/LpNM0j+ziPdiznS6nE0GpLmCXz+d5y6TSWvHNPADO6sLeEK57+wZuQ3lBFzA5PEz93/29XUptpCSb0xJULIpX0/jE1DtRCHuD8t4IkPeXF+f/CNoTlunq4xcY06+aD3twaPguj8c7oKevyNq4u7O1ItaxNjQ8eina1f0uUIDlVDL52yh8Pwzq7v1aDNJKi6Um8PcHAqM6qltLJOIr0Aw8ZMosQv0z5y9+j9fr+z6uDrRXnqCg/Psry4uXxb7kuQHYOAUCwZAeUq3j46OnQD3tmqoC4JsoaLWyyKqx07Mr2tUzje3Wa2ms53LZy3OzN/4a+1TN0q9mgX3ZgX6N7Aft3NZlVlrqN78/cPGF1MNssThAPR6al8v4+OiGAgDP2yZlGa5pyctQKmpAQfYqyoLK32j9XouwTi1uXbY3hULhETyv3wHNgEW1UJjd/OyNP9GYZ2reRmd1B+cBMqi8ailQ1O6rdbZJwFczS01nJDoW7oy8Xk+fcH2zhefcHKjLJmpKPxno9+Ne19Pb/zG5waFeSSUTv7q6svQUtLa8q4VuKfcXHvSzZ9psNvvU9Ln/ZDZbxrmm1I6ODn9rb3d7BQDaedG9HPlUbkVp5QHIv/LfVfaNkkNFKq868P8a8G8u/AJqgH+T2Vwht+V2pcsW3Pqh4Xf+xUYuNvxM/Obrt/OJ0XK94rBarCzunVjXj3L5xvclxv1TQC/OSQSPNosZLwt0+DwsvZzH4UCQGiTXaQGf4hVyuhkbPbm6E8DOlUtwY28PpiIRZq2mGxPYdVttYBaZ9Q3MpbwGd0+Owqe+/iz72+mwNupAgPW2kQH44nM3GIhey+0RIdZVaAb+bFN7JjF3zmqxGAjMjvREWb3Iur4Ri7O6Gur1o3u7Lt7AD4pc35rFv40+iyt1V3DimacSs280mYyGy8ur0OEnPgMH6x8WNoDAmZjucRDEWH5itD/Na09tou9IHAqyAcUKUcrDt5yfhi9dv8m4AaiXy9Uai8mf39qB5d195pI/3tcNTpuVfacui4Tj/S5U5AG84esmRhkp4GE2x8bxzvDk5nEhU4/lDwPJ4pEbx8NIxHz0mRnHltz6Y8cZgHRGqPfOLlknRMWJ4NlBmRpoxCxmq3nheCtwT3iGOBKUwL9qtdosE5NT7/Z4fbJ4+HK5TKT9f5hMJg7g1AVYsp6wjiLhXo9Vj75/mEp+FdQPIamn+GQGDUFIw9LfOAR9/kDH2PjkTyH4P6foYAZQkon4J5aXFp4QlQc2kGvZa16PL6DHYwGY50NyFV7CWGQd+eiVVjWZcGTFsUJh8e2gQ1gsFovri/Oz/wfUXR+VB6dSMGP16R8YuhjsCP3L5ufVKwgcfy2bzfCeBO0EFFbUDlkdoL+Ve78qSzYCkSm87gKd5egwtYl9xsJnBoeGZ7q6e94OctBfOz46+pP5uZtSn7Zy8T+rtZ/1O85ji9vtHmpX13KplEinj1PcGErKVD7Gvz5z7sL7laAf11Fya3P9f+xsMyWHBTTWA+4NbS1uuJ/l93ZZBoQXzOvwYpUWKfy08qor4vtDukn9SqXixtzNG38spjPkSda03K6/VUC/lmeEasYMPIO8ff3974Q2cf3YT8xDTMsDx+FwhEF9jQA0A3+ZAsBoMjZ5ieF6PuL+2Q7Aq6UzBZX3WoF+JahVWvrZ3uR0ujqHR8fep5etnubXytLCbyPApRhNfo4pw7dagn5+nimyWkmFN320cp/WKq0UbVqgv3E5Xa7w4NDIQ1L2IZ2FZJPHxHAzLbmEP+dkafssFit5qvxHnJMR/p7pdPoPF+Znib+llau9UrGgdpY2gX58qG3m/MUP43l+J9+QwsnJP87P3pDS4mplDOB5FVqeq9/KRSPVsXI/VwP/AHLAL61rPh0oKL77qimvAX+utEjvx/Cz+F4rF5PGRBxwRTbwSuHm5d3JxXv3T5KRZPG446B4HNzNxb240RildGx8ob1O2kUImJYrRcbAvyFass3zJrg43A8D0TBTCtB7BPzPd3Uz8J8jcFyrspR/o52d4LYIILnGEcuJuBJcCKzPD/Ux0GsUme0leNvTGQKf08nS2mVKJ5H13N7goKtrE05d/QVnAoPBup7Zm6wjSu0NdQhu+fjf7MYOmM0mBrq7HB03EfyfiL/lNcTUeLap3dN5bnb3JNm9XUwMU1aBJ67Nw4N3XWqw9VNKROJMIKv5cSXP4vfBYGxY/xuj1ATST9vcF+mAS7kBxvRPoJrtCgi+q/htItSb29qF5b0YRPw+sGLd6bU/2smeW2+kSQTNo5A+evPFGfinr13Gf+AYJJc7PjD60BfsRksGH1jfyh24lo+3wrsnid6jci6crxY8VpPVIOd+MOIpaeA6qU6xXsWoLXh9wtdPJC90yPPAvxrt6u7vHxj8YbPZwgvptVw2+8j83I2/RMFHyscLoAD9VCKR6Kh2q7gbVqvpvb2dq6AdvyytAQD1w08J+kWG8Z7xvv6BjyoOXVYq5fLq+vrq7yLA3BF/A3DqrdA4eD1ery4m5Eqlsp8RyNBe6hy4rYRsqc9UhaORkbG36cnvTmEY66vLf1kTXF15YUFNUGl48HCXCefWSE9v74dUUprVs5nsx9dWl8mTp1VKI11WCRUStnbs60pCKN59lgnXkWjXFIL3t+kVIClsRiRSquF6Gu/q7n0LyEE/kS394+zNa38DcgubWvvVhEK+bWptYn/7/YFuPB/aKuKwLkt1IXWmmsWf9TMKlu/1+vzfDxwYq1YqayvLi/81kYgn4BQ0qYIEXFdtCT9PTgo3UFhNQ3tw+1JYpfQAWdnlcrk79LoY12rV3OLC3O8j+JdS9n1LxfRTaUNSp1xzqnH9dCGIfSvO27ZkiNtbm08VCifHY+OTD6opa7H/x1Ser3RB51NTNhQAJqOpKdvIyUn+mGuf9Krk2VAqrvnSysVYS5Ekua83hR7RRR55E5PT76VMIzqHqba/t/Mnh4cpksHU5pkuS79ynkn/1lAAAMjPduV7ytJK0abmXdN0vuG55p6YmH4fversF6FzatUMzStQV27zdVLbc01TM+d+wGq1yjg9cE/759kb1z4JcsCvJfecFfRbz1+49CG73XE/37co612Znb3+vxR8OVrn6is6tl8D9KulGeb/LY0HgBz0V7n3pT2krnzeK60PtcprwF+98IPPNEMIGHjQ2s6a0Fj0RGLW7QzF8CJLAAlarhrUvFeTy6GV7F5w++TA2Tj7RDBqkKzWUnw/xd6LqdHrxjo8vbQC8XQaLoz0g9vmYDH6BJAnO6OweZiCeC4HFDk+t78HvX4/dHt90IicE13npdeLQ/3gsdsYwR9zkxfBM8Wej3RF4MrqBp2mhmfi85cQ+JPVWJbre/54s69cr/pNQOkAu5iFnjISkBWddV61Vp/yD92E5pjiJlf1h3rf8I2/WP1sIFcvBQ7zeXj85jzcf36SucobmAeEFQqlI/jy1TnoCQXhjecnmPW/EZfPDY7WoF4aHWTEe8lsTnDlwCd3On2V3VzcbDFZGKneViLFvr+8f8Di9ruCPhiOdkJfJARWk0UgG9R4kstmg7vHh+Gr80t4Itdcn958/ML7B9/6OfxRqc8R3sdrQWr3Sna363pqdfKgeDiaLZ905MonVhoGu8la9Fhchy6T/SBg82ze03nuStDiOQa5treKh6NhfGL6QZ/f/5A8vVgtk4jH/5As5KLCQpqT0qHUmMcWPIA8Xl9b6yKVXD53pVQsklVLCW6kzuA3Xi0BW3YAjo5N3BvujHxIJZ6/ns/nPj83e+NPi5Sb8TSfsARSZIevy+2Jgo6Ch/k8B4S1SMhumUCuQ8hWs2g3BG1/INiLly6SulQq+cVkMrEN2hYQJWGezL2/szPSPzg08h9xb2iyouE8+PrNG1f/DNTBrybAUfapSvyeGt9Bq9SGSvZ+Bv57+/ov9fYNUO5n3WdcJpM+wOuop7d/EK/7lAqDk5OTJ25ev/rHdcFzidqrJnRrCYbSq9J9uUlI7AiHx0EHGzqO7YJiHsnOpemZ89/u8/l/kL9XuVy+vjA/+1/Tx0dp7n1eGdgYG/LCsVrbewIdHx1+HZotYloeNbe8tLFea4EQaV5Zo13d5/X0P5Wjw8NH0sfHu3A2MPatAvp1s69TBoRAIHhHu+flc7md3Z2tm7gHl7u7e1bdHm9TSIvdYR/DMymQSR8XQQ78JUudVM8mQGU0mWQZKIjM9IRYm7XBO89iD9A8T1v9TiuuX2nplwC/W/p7bHzyAYfTqZPBn+1Nj62vrZK3nXKe8QomTWVruzmm0wtAWbS8J7RAvxLwK5TaBsf4xNS/OEu/NPonnX66WCxkQL7GpHrxskOTtX94ZOxut1vGps/2yZs3r/22QmmuXL8AckOHFmGojC+HQhrPqYD+Wq26tbK0+HMoo2Sh+Uw5szL9W7m0Af0maD5HeXkGuH6RcAZw70uvauErr4ryGvDnys/+518w4gZYU7H6g81uNxDjP4jGeNDe5NQsCQ3hGIVJ+3YmYc5XC0aTwVAzm8xibnmB4I25tuOT3Q47gtsAs7rTZbOZGRFfuVyFxHEa0icnUCxUwGsX5q6E5/uDQfK5g00W92+EnaNjyBSKMBoWvOckN3hJCUCM/wORMIs5B6l14kvY5wXK+EfVQ3BKFhDaoHn3VeNzqaUZI7Hc432GoiEWk08x+qVqFQSmHWP2fGBoA+qqC05mCbOZLOX39t//7CfWHr6vZgDLVjwFT82vMCLCmthH0WCAHPpg//AI/vbLT8Lrx0dhsr9HdI8/vbWqYZ7ai0j/bbedh7974imRDwBg2N+bf0f0dbEn49d9q5m9IEUNCPoPoZMo+8FeEnH3zSVGzNcf7oD+aJgpTKr1Uy8J4RF1GO6JwNpBnPEn7Jwkhr9ycH30vs7zfIwY27xH3N1pvBaE8SCYYTCTa0MdTwCRtI/XWDYs/MSgj2C5a2Bg6AMWq5W31tfxwJrbWFv9jYOD/R1pjEDO8i1TXoU7owNms7ktQRz9LpmIU1YGicmf3YuK0WhsrAMxjWNTfBspJiqVitVM2goDuTbWjZQyx+cjF2S5NZnIdBC0/sHi/OzDouKCF/iaQAoeoHabzaaL0f/4+OhZUHdJVgWpt6goDzT+AGvpCjk4OPx2PRbscrl0sLK08Ag0W/mVB2RTGjm6iOwRBSIiHGrqVxzHxbnZG/+tWq1K+aJbufkrORQapQ35mpZVvBWjOBO0B4dH7unq6nmLztCPRslm0snu7t7e/oHBu5V9XC6V5uZuXvtNbHMe5AK3mlVXKXjybdSypjbiQL1e/zi0KZVK+RjX4y53Txn4n5o+9y/8gaCMyK9UImXNtf+GQOgE5AKxat7tcLhzBNq7bedEN39dKergFlumdAJZHoTwQIT9G/tNF7s6btHFrc2NR6E1GFNbDy9X0N/Ogq0kYWOp+0wmk2tgcOhBFa8gRX/VKxvrq4/hnGEAbXtr8/GJqZkh5VrDZWvDNfj2m9ev/hWcencBKIwOIN8bUJQy27Ausv0Kn3V0gkWlncp106imotqGFr/TynbAW/ubQH9Pbz+FTt2md5xwre/iWfiXII/p58NIWrmgn3m9aX1fhexQKWZpWdfVDABNZ9vwyOgbeaU2hYPoOetoXuEe9BVQD69SAnMZf00w2BHBs+4ngNsnKQxqbWXpl1Hez4M24FfzTlNrrwz0OxxO1/S58z9ls9lfx/cdynwpXA8fSyYT+6CeKlCLyb/lmH0rlhagXwn4Zd4+IDc88aBfzf3fCHK5SPrsVVFeA/5c+cVf/MX6L//Sf1Fz+a/jJsAfPjz45xc9LXLakGljEwQAI9RupNZCa5nd0VQ505MqpYMEdEwmKYZcIO8LulwsvpzcywNuJyODI5d9Naty2OdhANbCXOmlGtaFlPT4f2EXxf1bYDEeZx+liwW4vrsLk5EII8dj363zdnIxs4Bwo4YFPeh1M56AGjY5Vyk4q8Z6wFQzZKV+KUPVtpk/GKI0dd0BP3s+hQws7e43iAm7HR2zhrqBzwerpbVj74dsvpO3dN258IXdp6Zxzzcu7exDvliE+y9Ms3tSm2f6emBuZ5cpNp5cWIaNeALuuzDFQh+kDpFa1nwy0T3M8HYE/5995jmmTHlq/4YXIlB+T9+9S1WoLT8Vuxmcz2xG4icpv9VqF1IuiNkX4ukMu55cWAK/2wX94RBLjej3uBhZo9kgpPq7Z3oM/vGr36CgQ8Pl1Nxbxn2916K2ALmDqlkEqa8M9Upd7WCVuSsRbh6bmHqn3x94L9aHi5GsV7LZ7Cfn527+ZalYLDSaeyrcqx2IxlA4PKlnbVAKvIPY/oJUf47F34AHpdoBqyS1sVJaP2LvN5uNtplzFz/odLmaUtEhsNrd2d78JTwEl7j6Su7LkpWHB1b1YEdHt544SQIpsf3dWdB221OC01t1ELQCuZrCUbSrexL7TI93Rh3779MI0CU2a6Vrv1nxnixetrund6x/YOinsU+b3FBxfDaXFuc/lstlyS1G6e6uZtlsypLSIiWWUaU+au79yiwHUi5s1+j45NsQsN4LOkJXlKWru3dKzCYiA7vY5oOlpYVfKxQKx9Aa8CvDKaT2Sa+t3M3Z3x6vr9Nms7UNW8mk08tVIW8m33+sIJh6IBDs+ABwwixuCY/euH71V/Eck0AQv16VFk52+fz+tuSRhZOTq3jLtNgHasqPb5rF/wzWazVAyy4EHt16+p8K7rdP4zqgQ1bNyq8V9tHY919moF+PlVbVzX9gcPhuu93R0+6ZR0eHVw8PU+sgrpNUKonT+PgbPp+/icTN6/XdH4l2PRXb31uE071fC/izy+V0Ec+LTIldrVYStZqQXlbjktaImpu/Wh+180aS+kgV9Hu83u7evv63g06PEjpntzY3/kjkKSiAPKZfS+F4SxTYGp5afP9oeTRpufc31l1Pb98FHO8HpT7PZNK7W5vrS9MzF+5vVy/cgxZxLu1CMzCX5Ep1RZHJZB0eGfsJ4jbmepx4a349kYjvKfpTzbUfQC7/yzJdgQL0kwfV+MTUxywWyyTwoL9ez+zt7X4Mz+xF0N5DNEOnXoGgXypac0qW+pZ7lSnwbHa7cWJi+s14TCZv3rj6OKgDfq0Ql1d0eQ34axQF+FcKr9KEoQUpTUparNJiL+IBVPr42sPfvp2P32UCo4Ms+2QVJ0BPv6yUBVb3vs4OGIl0QjjgZez09DS2smsNegFZYbMVv0es77U6lxPeUG9MZXpx2+xwWw8C5FhMyEOPMiKB/5FQmBEFCqSCp3OeBF4hm5wImA3E1mNBMGuBUr7CQDz+h4eqoRHy8Gx8YcBiEnztKU0d3ZKUFduJFLOkV6qV6r2Ri89wfcRvlppMpzO+wUOsz9rDu88MUWN3U0fwd48/BZeGBli7t5NCGnaqExmbY0dp+MSjX4OJvm64a2xYID887S3V8Q37vXDH6BBcXlljCoTF9FbHZGgwHajYV+/pPLeO1/JRJWe9mljsWsvtdyULxwGT2WySeowyGOQKJZjf2oWbGztCDj4DZUuwgd1mhRL2ucFQZ94SRoPJej25MhTtvnMN1Nm++Tmlpp1kGz4ejGSN/IDFYh3jv4eAdgcFpF9bX1u5IgJyXjgC0AD9TqfLi5cut7psLnsFgSTjFyCPg3pd5mKhFIiaXN3EdH1mh9PpmZ45/x9sNvtdysEpl0rPLi3N//LR4WES5G7pUl818RPQ54GAvowECFBuInjLgDZAvaXucy3i2FvlNmavJNB29/S9GXQA2mw2M7e3u7MMzYKKch3ywJ/VZWh49HXRru6fVArQVPAA3VheWviPh6kkCUVqoF8N6LTqz1buoVqhIrJ+ARH8U87nyalz7/EHAnfq6SO1ouYhQK7CKID+xtFhahdOrblKwjY1S7+aZ5Mao7SsfeHOzgk9Vq5EPM67+TfK2MTUWzo65KAf5/znr1+98mvlcqnAjYO0Zpss/XQhAI5YrbaOdvVInZJ9vqSpplqkx2yXRoy/rJ2RiF5Sv9r+3i551PBWfrWUfarg4WUK+s+Sg55Z+z1eXzf22Zvadlatmt9YW6VUazmub+orSwufOn/x9n4EQ13898lDbGBw+IP5XO5XEAQmQa6wVAPeJrfH09XsqVPeBnWwLwt5A7mcp4wNVwP+WqEQSs4Rt3SZzWbf2PjkQ2fJS59OH38B93LKHa/FH/FN9yhp4SnSisxPUtw2rb1wZ2S4r3/w/dLY4Tmdmp+98QyO/4yO6tTj8YPHQR30S+OqyuSPIPzbrDbbJf5e2Wz2H1ZXlp6G1oCfD6vSyhIi48rp6u4Z6R8YIh6jblnl6/XsQWz//0HZ7TlQzwzTjjPlFVN07OFq2Rh4BUADyKOcaT1/4bZfwzX3FrHPBkCb2O9VV14D/i0Kn8vV5/OTm7DS6k+TSLJ0mOE0x2exbKpbtrPxe20WK0PztWoNjAgbyX0/GvBDNOiHDo8HqrXqadi9gOobuxXvf8Kc9OvcDiS6ojeQtNHIPAcyxQLkyyVGCEiv5BnQuB/+aDkRhyg+txfrwCsOTNiUukGy94smYvxth9cNmXwBrGarYf141zfq6W0Qp2zmY31k4afv9YQFpSmlx6Mf0739Ftdet7ODNNUWOAVw0mapJAviXS/N496+QqlWTnzl4GonyxJQqcJTi8sC74GRb7nYAmz/8k4MFrd3YaQ7AtP9vRDye6BSYQoLXsXR6MtzQ/2MhX83eQip3BFsFA76Ip6xvdIJs5hX/WZX9v7obfP3A8xVDDXLlfhi504+Hj4oHEbSlZyXiPnYqcJgk4AZ8gj46YK6GE4hjGA96g7GQTvNl1rogzT0dRTA6ZB6r8frlcXy0z3wkPzs8uLC76KAcIRzoM4Bf96rQplSjF2RaNe4zhjoWiJ+IKXr4sMQ+MOP3ZsYyfFzVc231+cPTkxO/4xS4w0CAdNnbl6/SozFBZADKElDy2tqG31lMpktLre7LQEZFVy/3wB9BHS3smhZR9RiaRvro7un95zdbm/LY0Buj+urK19UtIN/ltSnwP1NGR3NU9Pn3+fz+9/Pfa9RKpXK/NLC3McOD1MxUAc6Z0khpXXAawFjNaB2SghlsXimp89/Hwr+51/ksarF47E/3d3ZJo4SpVW3FZmW2pi3szwzJajfH2jrgYMA/jiVSsSU74+OTbwxHA5/gA+dEUH//8DfnIBcmQbQLNQ29obOzshEu1CJWrV6tLe7LeW2bueSesusUzpc1ltxREiXjcLw8JxvG2ZBhbJlxA9ipFxrxfOgOi9eZqBfSymlBWYbF/GyDI+MvtNobA9kU6nUV/P5XAxOlYSsT3B+5hBo/SFldME9SEbohkJ7ZHJ65iPzszd/k7g3oIWXEl0ul3sAFIowPFe2QG4VNIP8/FUNH1PpHy2vCLVsB0prP7P4Yxvfarc7OvWOFe65saWFeSKX4137tfbcbzZ3RCvQr6Voa/aw8Qd6hkfGfhTHnimaq9XKycL87BN0tHeEQm3P9XK5nMQ9aI4btyaCU1CxEoc7IwP+QPB7gZsveK/l+dkbH+dur3aGKs+uVqCfyV+4L78Jn/cT5JHG150s/bHY3s+uLrNUga2IYjVB/yvF2q9jD1fuTcq+bpD7WaxW07nzl/67CPoN2M/H3OdasvarqrwG/LliNRuaFpEI/iXQz2uGpfgRHvxLwL9kAUPGbrIk8Mtso780MgDnR/pBSqVHIFxw5eeKgZ+Vp/KZBPLJSk/gnuLyK/haxt8XqxVmXc4Wi1CoVolmn4Faj80K3T4f+OwO8rGG/Uwato+OmCt+LJtlqfFGw51czP8plK6L75JRl/gFqJCnwmEhHQQPMFf/mqFu3M7Fusjgb7WYoMPrYQSEa7ED4T54vwF3F7lrW+H0cOUBqQT8mbtgvHTcOXe03reLwDpTzruPinmL2WikFPanfSO620u1ZB1TF+p5KTxWi2dTsF9IGddiCVjZjYHTZmMkgOSN4HML7cidFKDI0gIKfcmUAngfSt/36PJT5qGLkS4f2FLcOLNXc91YuCs0uXEXTK7Te/layXHzcLlzv3AUjBeOAseFbEetXjHVDAazmaVbNAgVw4oP+XtuXPCNXBVBudIyCCDfjOC0gVDv6x+c6uru+QBuYr385ziH4qlk4jeWFue/TGCP7luTiBCEwqf0kkrjgKZ4zEBQXywrHojx+MHBGjQLsUpXSWlc+Vg6dnV0hLpGxiZ+DtuhPMwr6fTxH8/euPbXKqR7vFJBVfMeDAa78J5N5HPKUq/XCrH9PT4jQTuX5BcVpCis/e0ESFnKLLK+R7t63qjnOQjMr4gp3tSsFEoCK/ZZKBSODg6P/Bur1XYemg/DOoKcx1Eg+uVcLkvCt5LY7qw5o/Vq9ZWWIlWwZnc4AlPT5z7ocDgbbukIEvbKpVI12BHSxcyuVbKZzJdWlhYfhvZCt94YULU40IbC0+vzR202e6RdvY6PjlZEN//GGA2NjN6FwuUP86C/WCg8cv3alV8VQb8EtoDrd1WPENobEAC33Rty+dw3cG/Iw0tondJhvW5FUCe7AsGOPj3ZFKgtR4epx0Ddvf8FkazdynIG4VoPlwa5+L8ewXbb0COcqpnN9TXqr5zYZzLW9WQivux0On+vt2/gw/LwNayIxTowNXP+Y+ury39wcBDb1qgzA1gOp3NAOU4ot22CHPRbQK4A40MIlDG/rVz89Vr7mQJgaHj0bpxfeizYjbojoP2LUqlIYTRamSJ0s/e/WKVNmkwlz5UaeWbDu8bt8YTHJ6Z+3GQysTVH8tHayvLjuWz2hKz9JpPZ2q4+uA6fwvlVgWYgzo+hTPFDLv4Dg0M/xnu1iZ5dv1PCwt2eb6NyXihd/Jss0Far1T45fe773W7Pe0ChTK/Xasm9vZ2fWV9blSz9Z7X2v5JBv9YerkWaKH3HgGNruHjx9p+zWCxvlcarVCz+Kcjlmlct4JfKa8CfK6VK3aAF/ldW1w24MfCbKw/86VUC/2wR1yv19JuiF3/r0diz/9loMDlmt3YgEvRBJCDIFXWZRVh01Zfc7OFUKiPSvaNCHrInlFavxMA+/Y7c05kJvSYQ1DksVog6HOBGoO+z2xvPIGBL1vdOlwd8NgcsJxJQwn0yXSzCzf09mIh0shADKa6/wcEnvlBOe3qQEe9xXMrRgUY3rz2bWAgbjCYzfY08GASFRI0x4hPwLZULtTs7pkjbTpu8pFEHON0srTWouZ5OzE/OHq+NHRazfotJ6HzmSm8xCzwBpOTAPmAY2mgAq9HMvCSMJiOp8tgNXWZb/S2hi6W469D4yfXHLOV61UCEg8VKBVb2DmAZr7oY2sB2FaNB8syXSb/Up5+4+fneD469Z9lYbyIF4UvdabTm7uqYXubGvoL1rSTLGdf68S6Cf3M54PDmA26f1VWzrdarNTVLguye3Culp/OOjI5/r9Ppug8UKcWKxcLDq8tLv4kgLwGtc4Y3YhbJjY54+MR7mVCwj+i1PuSymcu1WrUEHKEfqJPEqbpgRaJdg4NDIz+nTNeHtzlJJhO/urQw9yWV/Luq7QDF4YDgbgR0bOSFQnE+n8sdQmuLHD8GL1rR6YasyXrc1d0zbbPZ2o4VKU7W11aeVKk/32cgttfgRKl9eGTsIY/H+26ydjbfsV7OZDJ/Nnvj2l+gcMXnij6LZUKtHq0saK3yq/NWIyuukcjE5MxPooDVCFfJpNNbszevXRsbn9RNnqVWUP5bmZ+7+ed1IQ2pFmmbllCmNt5Kq2NT+zo7I9M6CAlrsdj+Ij9Ig0PDl6LR7h/gydUQMDxx4/rV/14ulfKKsdGy9jeErI5QuM9itQba1KOeEFxsdQmpt6LoFBjbkoqJly0c7tRL6lfY3t5Us9K1DCF6mYL+Vsz0WtZ+yi7SH+3qvk/Ps4+ODr9SKJzQWSWRgUr9JNXHuLW58Q2z2fI7eM8PKbzamOV/ZGzio75A8NMrSwtPiJwystheOt/sdrsM+OP38ggM44q28eeLEZoV8Vrrlw+J4vdt5bySZRch9348x+/HNXURzgA48Kx6BvvkMjSHkrSN63+JQL+Wp5bq5XQ6A5NT537SbLE0zrXY/t4zBwexGJFFkvt/u/rg+BZ3treugPw8lbxLlcaJRmYjnEvvsFptE9ytSEH0j/t7u5uK8VYaNoC7pxrJXGM+hsKdPUPDox9GADqlHHc8S7e2tzZ+BuvOx/S3I4p9Rabua8M10orgt8mzgs7Oi5fu+IjVZnuX1Odk7V9bXf64/hq9OsprwP/shQf+BtzYa5VKhQf+1Ke0QVtuC4xdR9D961+OXfkP+IHzsWuzMBKJQH8kxGLnieCPALtw07qoCDDInkQx7SGXm8XlE7AmEF8ma39VUAC4rTawmQUFp+S6X1dsCfRvlmbPaITpaATWk0k4LJwwYDy7tw8TnRG8h+k05ICrhSx9vSBYMuC/kdmLChb3OkT9PvbslZ0YWIxCqE3EEdoPWF0V6fsgt+Ca1/J7A4/sfuP12UrJQ28yDgQQ0gg67VaIBPwQ8mC73S7wup2Mb4AUCgTOyVPi2aU1mNvcZTXzW1z1k0rRuJbZM0ZdQdjKJ2R1Z5zzBmE/F7gKoJHVQNZVpOCo1UuGOpnrDfyGrxbvJbWnAeIJEAfN7sNgx/jpJl6m11oZTj0eDKAuGLO/8dAzoaDwJgS032M0GmXWJzzoDlKpxP9cWph/jAPKjQOiUq0asY9q0Mxw2rSJdkai09x3WpVaPH7wLDSHJ6hZ+01SLD80Ytt6RwcGh/4ztkUWL0wb8v7+7i+srSw/A83ggfdaMIB8n5JZJhH8jehoA6Sb3fy/KYRIinqrARQt0N8AJAjq7tbzgGQycUVMBaRmZW3MUxJKurp73uJ2u9+GZ6VqHmmK58fx+dWNU4tEQ6kJzZaJVhZeNQuaHq2+Fus6e0VBegDXyUdw/20QsSHoX0fQ/w2jyeT1+QO6XWqVhUgg11aW/j8xNzvvZqsG8LRi2fm28oBBValBlk6s80S7uuH4JnEuH4rPqvX1D07jGvuXFGIjfadcLl25ef3afy0WCzmuvsrwHKmOTdbTcDgyA21ASqVS3juI7S+BfrfUF01YbZMCspWrMQ/0eQu23WIlh4tAWzJDKvlc/rlioZAG+To4q+fLN63oiMnWyrGumjUDBevA6Oj4Q7int7XIEvje2lx/DE4Z6SXwygN/NmYooD9OShXcmz6C+5LMLZoUk+Fw53d7vb47tzc3/jkW29vh6m7Ec6DDZDLLGP3LpdJOsVisiu1SUyqboPX6BWgN/JUeSY1+crpcndGu7ts7OsJ3IPjT40XSKNQHa2vLfw1yMj810P9Nm2dnAP1a1v7GZbPbPVMzFz4kV9geL+L4U0iVIxLt6sPP2nrxEZdNPp/LgVwJIxkgAJr3BCOu8XAw2PHt3PiSR+P60sLcZ1XapOSA4O+p5nViwjVhGh2ffKCjo+NHcQ67lXXGZz27srTwC6lUktj7tc7VV0XqvjMQjKoS4cKpdymTEy9cuv1f2R2O7wBubAuFkz/Gvk6DQs5+pfXlWctrwF8skrVfy+r/x/0D8A7B4k+ljhOMDrV6CQ8Wk9lsrCL6B2HRyrSAdwTHL1vB8ktfOrj8kXKlGp7b2TWsxg7AajGDHwFtX6gDukNBcFitDKlKFncBnIp/1wW2fBMx8huEk0WK9zeKrv2MWQ8kC78A9AX3fYMYQmBglm76KhH87WfTLNUfhQzMxQj8d4LdzHtInf4peQKU6xV6tI307TuFRICFK1SqMNQdZfXYTqYaS3jM000EYPR9ybWO3QohtfXzu09fnD1cnzSZEMYLcQzMc2G8Nwoz/b3MLZ94AyQvBGnbZeSB9SrD8J0+L8wbdllb46W08fcX/8lK/VMXlR9UL5/bxbgUSDFiIQ4E/KyEw5QtFCCdxyuXb4QPkEdA1BY8fk/fvQsGAfTTBiOlz+PDO9glutdzcQeyDbqJgA5ONzPZhk73FmPmqyjAD/X29n0/CqFj8oGA6snJyT+vLi/+wfHxUZw8C+gSwf+poF2v08FD89IgZVVg00ggzWlspCSwoZSrS8glN/9kIr4l1hW49Hoya7+oFDKLXgVs7vf2DUz39vX/jJoCY3tr82e3tzaIYb8stgVfjThEQvwLBZ1ToIeYHpA6qQmkeH2+sMXS1jJJdS6hoPgsvAQHq86c4lqkfmSFHMa9pqvdc8j6sbm+dhlUACkKWraOjtCgPxCcdLlcJIgOA6in3iKXR5SlPrm4MPvnOOcycCqYtEoxxHucqM196bVVH2ilfVJelu6e3qn+gcGPoIzVUFpkMullBP1PVqtVCovoNrHN8nmVGgLav0gmExTaouViq1RSqbkJS21uZ7lgYx4IdvTabO3J9JKpxIrEsdHT2z+G6+u7edCPx9DywtzsL5yc5KWxa6QPFb+i9J6R1Y+IxxBEteUZyGQyT4peIK0s/i+6Mk1HjHorIKvMBtG4xiem3qYnZIjakkolvgbaln5VxcdLZaHTScSmlbpPae2n1H3uycmZhxD8h/Q8P5tJP4n7yQHIyenUgD8bs/W11a8XC8Vk/+DgT+ESVmYKMOAaGR4ZG/+30e7u+Z2tza8mEnHiDTAFg6FhpbdMLpddAfkeqwT+yn0LoL2iUgn8JcWdI9gRGkJQecnj8V7APbe/XXpDrXJ4ePi546OjXdDee7TCi24lmd9ZLP2ybD7chce11TVz7uKHcBwb8kexUNifn7tJxgwLySoI/Ed1VKu+v7d7BaDJ0q8kbWxwHdG9h4ZG3k9EsNxtKjiPPoFyjmQwkS7lPUDxb2VmKiOer+GRkbF/jWN/NzQrTmsn+fzfz85e/11sbxbaK9I199FXgrX/BYJ+Kyis/ecuXHq/y+X+QZApdEqfvX71yp9As1yu5t35Ld+nZymvAX+xSGBfDfRT+WWzofaOU5b/euHkpHGAVAWLPx/rL0tRdz44tDDojvz8P+088YPxwuE9parBWMKfZE4KEEumIRxLsLRw3SEEqRYri9MnAjvJYm0QzfhkVWdAXwTDstwVBlEZIFm5jUIogBQTL4TDCxCeKt7p9oANZePVZJKBegL/gx0dEHS4xDgEYQVRijqJwP2wlGHA/+bRqhvBv5nuTSn/mNICP99KJNnziqVi/ULHOBFq0PcbLPPx4rH3U5uP35mtngRMZiOrdBVl2KFoJ2Ps9zodrC4VRkhoaFjl+aPYhP1yeWENrm9siW00sPAHyfhM9+pBsB/tCDLPgVqNG04xhSH9zmisw27iGL5yfQ5K1SpTNHzX0Ft2zHU6Hwz27Xw8MHu0HtjJxf1H5Yy7hr0m6HaEinht7oLf5jo65xtePR8c2ajXGsBUayOTvEKkDZ29UkFBwTk8OvYet9v9RiUgQ+F6HYHI/1pbXSamWXZIEEgGFaJA8j7Bwp5Zl/I1Cn/LNlNKWWW1WoN61kU2m7mG92SZHPh7gjwlnEkk9Gtc/QND53t6+z6GfSnTemN7djbWVz+Kh/aa1B7s+xqi/JII+gXHE3yrZjBK7QBQEVY7QuFRPbnai8XicjaTSYJ+a/+tENS1AEor8jpbtLunKfuBWkGhYp9SPbrcoRCCe6fT6QrYHY6w1WrrIau4GDvb4j71Mgrcj2xvb/5JbH9vE+S8JWqAXzmXeeG5VdvbEUGpuWY3hMfBoZG7u7p7/i0fn4mgf372xrWv4NwiwjFTONz5vGP7c9nsk7jWvgzNoF9J3tYK3LZzpW5qX2cnY5NvOc60DmN7e7RuatgHA/0DA+/j3aKx/bGV5cWfFzke1PYItdh+2ViEO6PDOF88bbqpiuv3cW6O6A31eEFFJ+hvxeCvZvG3j09Ovdnn8+sBG8ROn93d2b4O2kqwbyVLf7vMGQ7u1UFkfhOT0+9yezy6+oqU47u7O4+CsIZoLWkBfz4TTHVvb2cO1/RHx8YnP+hwOu+DZs80IvKbGZ+cnuo7yW/GD2LPBYJBZTaGeiqVXIRmZZAW8NcKTeLr2LD6k7INz5/eQCA443S5Ltjt9nMmk7lDpa5nKihLplaXF/8ZmsOLtLJF3FLlUouc6srwLC2lbQOw4b7iOHf+4k9gXzVIWFGmOkLQ/xkReBuxTzsdDmdbZX6hUNhPxA92oRn08+PLe2kYu3t6KR2ujAA2k8k8tbu7vcb9tqa4B68o5e/b2NuJGHdsYuqBYDD4QyiONHl3kHfjYSr5mwvzs5/HvyXPDS1l+mugX3tvUrr5s+9NTZ970Ov1/Rvgzk+cV09dv/rcz+FrWaUfVcH/K6Fv9ZbXgP8ZikaKP+kA0doc2b89Vmf9B4fe8fvLma1HH49de3e8mD5vRfRbQkxF6eqYtRwxDrm82y1mBHEmCPt90OX3Qm9nCMxGk+Cyzm7IIWGxNhI5n5QJnnEAGKFBJAiSUqBuYJ4E9Lff4YThEMAapcfD75AS4MRdFhn/hUZS2juKsaf6JIrHdryxDQFx0CByDHQHg8w9f5el8BMe3mHznrhNdvq5U+qnK4dL3U/Erk7V8MAkwj7KchD0uuDe6UkIeJwgkfSdRsLXmXtAA1vWCSFW4JErNyCRzjDwToWMX2GfF84P9EFfJMSAfsOfvlqX9ZH0RwXv8+jlWdhJpRipHylULvRNwo4pPXBjY760kd1znVRLViH8oM4yBlDWA5PV0rhVqV5xxQrHrv2Tyz1fObh6x92dM9dv94/PQ7PFiRcKZZYhPAhheGTsnmBH6AElozFZXlH4+dulhflPFIsF3nonHRo8AOHBsZYbb2MTDXdGpkEHmKR7JxPx50CufuE13dJzZIqugcHh2/CQ/SgJivzNcJ6sITD5aTywt4ATZnBuVUXlgswduS7ktNRqixk3e11u/tiPkpt/OzftW2GdbCUwtYo/tqFwG3K7PbraSJkNLly6/V+LihDdsaTELIxC1BcRyP3N3u72OsiBfRmawZ1W//EWM6mouWK3S/mkdsizgx5Bx4O4Vn6Es6TVs5nMTQT9j5ClH5jLr8+Pwt2ZXGulgkJCfGlxjuL6JbdkLRd/PRZtJSjlLRgyLwbcB1x6PHBwHu8UCie5SLSrB9fYQzjUDdCPayW7vbXx/+J63YFmS5IyREfLE8EcCoXbprPD/Wjp6DC1D62t/S+qm38LECvjJwB1UkhVwE/Ko8mpmXcGgh26+SByudxzKp4OL7t43OeZck1NSdLoq4nJmQf9geBFvXUoFgqLqWRiA+Qu6zzwbyiOxasxj7LZTPK5K9/4n4NDw0+GO6NEbquW0cSIIHGwf2BoUPkBrofy8fFRAuTnlQTulIov/r2m/YvC73COdPp8/kGn0zlqtdknLRYLZcQJgkoGlBdSEon4Z0qlErkmK0F/yzX2EoF+Ne8aNWu/BbvQfu78pR/H8bpTun+tVs0tLcz9XS6Xpf2W7d9d3T1tw51YP8UPrnFjCiBn8m8ClDh/LN3dvd8GnGJGCOla/jycZnrg2wTQGvizC+s73NPb/0Gr1aqmuK2Xy+UrmxtrvxLb36N1oNd77tUO+tVCRtRi+41j45NvCgSD/x64ccX9eXZ+9sZP4VkpZbJRu14WytmXqrwG/J9f4fn3pFhvNfAvfRfE79VGPX1zeG2u52IjX49df+teIXHRaDJbJZdzAqH5UhnqxRIc5/Jk+YShrqhATtfA+wbVmhBnAJEAru7GWJq6DP6eOOVcdhuM93ZB0EfWeRsDu4ITQR38dgdz/ac0f+RpQCEA2VKRxf0T6KV7Bj1uSOMaKlbLxljh0LOdOXCZLRb26Ijfyyzz26nDRod0OTsIqNJGXstVC5aHd54eXsvGQkYTy8NHaaDgrrERmBnuBbLxMg4CEEj8iLiPYvnNtP65Zp5gnf7PU1cYLwH1E/EddHf44dLQIHQGfEzBIbiFi9kJyHFD0oJw+J9+++jVWdg9PGTKA/rIZrbC/nECrm7MubCOLvKMMJtO9/666CsBIGU7AEkXwbgDylBzPh679rqQI1jqt4WIebgCzUIh/1rp7esf7erufSsKECH5gOLQFwpXNjfX/yR+ECNXxSKcHghaFjZl7C4VVcGe3Pw9Hq8uN/9KuZwSQboS9IPivcY1ODRyBx6GP6XMA1+tVFaWlub/UyrJcsAr879LbeMVGHUENgT++Wc02mG3O9x4tXWBJ6vTgeDmrwZcb7VLsp7DTSs/va27p/d2PTndxWLQ+10irKtUylez2eyXtjc3HkNAeawYB61Ly51ZC/S3s8q2cuVrvBpwzs6cu/D9Xq/vO4HLTICg/+rNG1c/hwe9XerfaLSrH86g+OD6pLq7s/Vn+XyeyMD0Evq1IjDUcl3k2yblsR5FwdQNbUo8tr+M340MDY++Qx5fXa/E9vd/Y2d7aw7UXUe1FBOysbBYrE6X2912bzg+Pn5SwTHSKmf9C15TZyCm07I6NhH6kcv69MyF7/B4vdNnqEr96PCQDxlqx3HxcnHv15M9Q2sfsuPO4hhnSreOu87SV8lkgjxniioXD/yBq4+sH6msra58bXdn5+bwyOi3+fyBb8N5384bRWi4wWjp6xu4fXNj/avlcqkser3J4rdpw7TZbGabzY7/szutVpvLbrcHEMR14FqImC3mKIUbUO51FBtcIu9PO6+cwkk+v314mNo6OkqlJyZn3o5nvJ4QElI8HqyvrfB9xp+RWl4lt6S0AP3tmNablLY0Fgj6f8zpcr1J6j/iMVhdWf4b7CfyxKP+MeL+7ne7PW1T1uJ+n9/b3VmGU1lEk/xX+nf/4NAdFqs1zN8nmYh/JZvNSBwBfJv4e6mmaA2Fwl29/QPf6XQ634pfa+K6IIU6Hqt/tDA/+w8I/iVlFw/8eVlO7Vx9pYJ+pWFKrzFAliWKvovn4G2hcOfP8F6ytVp1Y3lp4SPp9HEaVIxtoA76v+X79qzlNeB/xqKw+gO0Bv/S53yMOJuMg67IwuBwZOu4nI88k7x5z9zR5huq9ZrTYBRuTSCWwPobpyeYMoBKw6ovVcYguL6fFMuwsrMPxB2QwPlO1nkGesUa5BA0Hy7kYbQnwnLcOxH8W0ynGMGD/55EoL9wcMBAfL5cghv7uzATibKH3DU+Al+4ch2sFiv8zeojYTwQGewl9/iuUJAB9e14sqGAGHZFaTN1bORjns9sfXWwCjWz0SR8SGSG77jnDvDYHSBlMySwnyuVWLYBr90OJoMA+gUmf4BsPg+fQdBPYJ/u73U54A2T49AZ9AK9Jbjzy7Az4wMwyI7oOkt5+KXnbsJx/kQ8fYRflaplOMgkWaaAcqXKwincTgf48TkUxkB9ZbNYwI6XxWyGAvZPMpNlnge5k6LYhpohD6WexdyuO55LGI9LOWsJyrZUIeep16oV/F3Ja3Xm7u677fjB29/a73Q4uxWVpoM/gSD1Exvra18X2cT5+dXYvFD4IZd+fiMTZ0MDFGlZli2im7+MBEmrZLKZmzVJmyI/+FUFy6HhkTuiXQz0yxjiEfQvLS7Of/RQILThgRQTasS2KF30xFBm9bQ5HaHQoB5yqXKptJE+Po5Bawvdi+rmr0Noaids27BtThyrs6R/Ui3kWoj9m0BhaRv7YiGXy16N7e9dF8F+Yz8CuXKJVwBUofngVIvn1wL9ZznclcQ9CEYtjpnzl35CELBO91QU2C4j6P8MD/rJqoN9powL1lWwPx7b3tokjgQ+FvkshFpqluhWoLQRwoDCS1srO+4NRfI8Gh4eIdDPpzyrHx0dfXx1ZemroM0yXwe5C7Kqq25nJDqKIKclSKEwo9je7uU28+NFAyU6QCyvEFSzXDeFzyDA806fO/8DTqdLlzfNadtrxdj+7g3Qpwx7SQR2DeFaD2hTTbtGezm59wc7Qm+ANqCXL5TCb39vh9KnlkCduZzPMsGHwzWlxSSPt7nZG59C4PjVgYGhd/r8/jcbjaZ2ijIDzuf3hjsjZOWtipw8jfsSZZIE5PFvo/h3W2DfXOqVcrmyfZLPLR2mUmvxeCxRKpWoP93EP4Nr1aL3Tqlk4mECtaCeJlIrvOhFt/afAfSrhWbJ9m8KiTh/4eKPuNzut0t9S0pDlHH++iC2T0YSh3hvQ3dv36Se0L2jo8MFUuZI44Xr2N/b138Rn9GHRwDjfcFByeCevr2/t7tIhHvhcOQe5X0Q+EscEHzbJMu/ktivjnKTtae3/1wg2PGAzWZ7nTL7hFhqpWLxsc3N9d/D9m0pxk9NYagVMvdKBv2tPAAtoG4MkKXv6+0bmIh2df8Cn/4T5Zz99bXVf4fjegDqRjdN5ewroY/PUl4D/s+/8Jb8Vt/hgb9SSKr4LM7KA9G7Pnt3+Pwzn9p4/DsTlfQ44di7p8Zgsr9HHqMOIMT+IxbbTx3jdQR7R0cQPySwL1ivTWZxSMWYf8JUdgSvvaEOpkhw2YRQX0aCZzjlEXAgqJ2JRmHuIMbc8ClrwFwsBpORCCPIG4qGYPMgCTVDXVQ/4MnmtIMVQXEWwW/m5EQExQUIOnzWh3eeHpjPbARqTJMhkOedG+yDSyODQsew8IQ6FBHsHxdOoFapIdB24f3MYpC3cCLvHKTgS9duMhBPLvrnB/rhzokR9jnv1i9Z5lm4AL4vxP+LMf3442urm3BldR3YucId7RQ+4HbYWf9E/EK6ReIaoEL8AxQuwKsVBNJEI2NK+KevXW70M6UP/OzqE8NsDIzKcwOgy+GDb7/jXXD34G3M44IvRMyGoPjxtdXlL6LQQIzd0mEk12aIFweU1fKGtyRICYXCk6BPuKmjIHKTuzdv7VeCdANZ+hH0/3sV0L+8uDD3nw4PUwS+1QQaZSpCk+LeqiRwfn9Ql9cCAsRnVTIg3DILnYbgrWblVrNGNtyQUWgdQ9Cry7pVrVbSlXIlgesjga8xFIr2S6XiTi6X285m0vh3KY8CpdJd9KxXK2tuO9DfzkrEH/KNz1wut29y+txPo5B1G8hB/5M3rl/9p1q1auOeQ4J+L4J/WR5wPYUsbThJPwnNoL+VpV8Pn0HbbAUotAaxnX3QplC7RkbH3wKKGOJ8Pv/4/OyNvwfttcXXU+kGK6tfINhe0YRzaR37PwXt3dyl5z0vYNKGuV9PnLpq7nAKn8E59a9xTp2ZB6JwUljA9vOZEtp5Dn3ThEmV/mryxoL2oE2WPYOEauyr9wQCwfvgjIA4n889VyyyHPRqBGZqhJMmlf6TzVVKxzo3e+PTdrvj8b7+gTchAHsjrotW8eAGCZwZDGfE8xoFz5Ij3C/WEdwtZLLpxXgstobrgchpad8m0jiP2KeGSLRrwGQy6QL+eKZntzbXnwBt5d03hcVfA/SrpTG0gPYe3gD9M+cvfr/b4303nIL+ys725sd3d7bJYt8A/eRx4fcHBnX0f21/d2dW/CeLr5+cnnmv0vuPMik4nM7ecGeEeamoecP1DQy+DeXlR07y+XixWDgs48EptZm5gOBm4XZ7Qm6PZ8DhcE6ROz8+zwvqa6GO82IeQecfrK4sPaXgYVILmZMAaYPvCV6BoL8NL4tS+dzWEEDfQ8Df39fX/0s8fxT2d2p7a+PDYkrGViEUSoPFq7K8BvyhPaO/+B0jflaj79C/cYEbE4k45W0xbAls/w0Bi0i2iAgON32JBV1w4xdQPM8K39gM3CZ7uccZup5Ip8fpAblCEY6yOQZmC8Uy5PHf5MYfQ6C/lzpm9yQASbUhS7WkH2ikBMR/dwW8MNXfw1zhzcbTfY9c6pkbv8HEQLFUyLI9jUB/IXbA2P6J9I7i/4dDIbhzbAS24ik4zRVYR6DsZwqCrYO4kI4PP3JY7fCJ9Ud7heUtyKhWswnecvECdPq9pz/HzymkgBQGZMnqcLmZ54D0OdUxcZyB5xCsB1xO8OJ1FwJ+JyMbhNObgLiSEQtTnSUlADkYUBaDHazz1+aWIF8sYh+YWSpACmkIIciPBvww1h0FDwJ9ep7ULiIXbDzBYBAVCKLZDNtEqozLS5tQoJAMqRqkqCBALzgpCt/FL3Z5Q/DQhQfgTSN3gVUhA5CaIpNOL62vrTyWzWT2xEdQ2AfNi4ZLEzHaG40mk2iZENzfaT416tzoDPyW2YR9ITucRbZcJtx5vD59bv6VShrn+PZpNxjMErkfL0TRWwj6bxNSMClAf7W6vrQ0/1EC/fhZGdcD3rZSwsOTbcy4Hug9Nnz4XT58hp3odSFLAas/flcWruByuwZ1NKOGa1SyTp41RvvMRadWW09OcTsKjbrijguFk81rzz37h0SShP8kUEIWI2UKKK0wB/61qvLvdrFxavH8ytjrViy9mu58wY5QdHRs4udwL+WtsvVsJv1lBP3/gPPBpniWMRyODD2PYavt7e58HPuRXE61WPy1rNlabv5afA5NhIWRrq7pM1gFZaAfBdWN+bkbv08p00A7LIEPydEE/bgOCRS37b98LntTPLvauac+7zWlU1iUhf5AC6u19J4/EOgZH5+i3OGSy289ET+Yx7k2RgCiXb2yucxN0A5/ecnc/HX0l9YaVM2aQa/kVTI1ff67fX7//cD4VurVo8PUMvadx+PxdrepUv0wmWyQ0YJ6PDMfgiJ5S6rF3yvnahnXamZpcf4R3Bue7O3rvxTt6nm3wgvmhRY66jKUfQbPpc1KubyOz1w5Pj5aSSWTBBIrcLpfSQrbprOkoyM0oPeBmUz6KVFRosXir7q+blGKzLPEXyut/Q2r7cy5C+/3en3fDadnQzW2v/fxzY31G2KfNZ7R09M3rmcfRJC+g+OQlOqKwH6gVchfq/A33O+mxsYnJ2lug+AVwsC4yCFjEl/bcebUibvo+Ojwfy8vLTxCnlnQDPK1suC03Dtf4aBfaw9vCfpD4c4oypv/HQXihsIPxy29u7P977e3NpdAvr+0k/leMg6Wl7q8BvxBm8lfUeqK71bZxA7JhDGGGAX2dwoMZ+BM5uIP8knJv1ee8Q9dfvZo8V0mg9l5c3MbbmxskYqAWfkZmV1dsGoT0Bdgo/QYAweGAcGxhbHk93QGwYZgk0IFyHotpLozCDH+ImV+XZY6wMAUBNPRKCweHEChQtb4AqTyeQgi8J7q7YYbm9uN5wTdLgZuNxPJRhfVJSRcF4gFh7s74fWTo2AxmsWsA0J9k/ksS6vnttkh6HQ1OljaKYhboKsjAO8OB1koALOy14X61rkoCtKlkBW+LjbBIPZR7OgYdhIpWNs7YOz+/Z0hCPk8EMYr4HYzJQF5TtC9yJNAjlvUimDaJ13GjbVtWNjeY88pYx+57HYYxPuTt4DH5QCL2QR+uxfGApMw5BljCgf5RKrDfGwVnpx7ZmPC3CVp+SXhoSpqi/kcpUbByK8pVDY21Wq1ogo6sOoWn8/XqSdlGBUU8Jcrp9kqTOKhyFzr6lKaByz9A4PnEfR/WAX0b68sLXxUiuknl3MC/fQ3AX5p3leF9cGDE9YeSklI/8bPpfcbAgWFK0gufa0KAqNYKpnYBm03f6WG/XkfAjpAv9rBpkY+Zqcc9XqswFQOYvtfxn4lTo08d0nAX8lErwb6W/2tjONvZeWXXtsx9PJx7qrxe909vWP9/YM/bzSZOrln1DPp48/evHHtn3BuWLnnsWciGCFSP10pxviSy2af3tpcJ5CijOvXErxbsfhrgX7VWGqyqAaDHWeJMW8UIqZaX13+rcLJySG0dg0GaJ3Cj120phD8u9o99+jocA6a15EW8H2hln493iP8nNICspZItGsMBcZ/h21s7Bt7uztPb26ub+B600MoVse9jAf+3zQr7IvcX+0Ub1YiYps+d+GHcE3dC2wvrhaWlxY/n0zE0xcv3fFguzrhnp2OxfYXQB3sK+cOgGLvB3XllIW7HwMBuO+dbG1uPBuJdD0AHPBHcHhte3vz0wg6Ox1OZ5fVYu0wmU0+lCFozZFCmc6jPBFiovxwhO07qlaqyXKlHC8WCjEE4XvZTOYYAX6JyyoDinpJ/1ZV/tjsZDF28vtXq1I/2N+jLBlaKUNV19fLCPQ3ATQE/d/h9fn59Gq1+EHsE6srS0S0a+fubSCvCJ1rEA4OYte4vjAGgh3PR9nLF4OUiviMXiFk4Z87Pj7669XlxUdR1pAAfyt+HK0989UC+vWG/anNKSOeleGR0fFfQSwUaQxCvZ6L7e/91Mb6KimTWmVJ0FSevRrLa8BfZ9FSDuBhKMWpSaVBdCVuJPziVnX3l66w3V95V+89v/nE3tXvOyxlBxC0G+oIgA11IWa9htirWCnVvWZHOewInrgtzsrayX6HAFwFC/NMXw+cG+4Do0FwNydoS6CfrNjZUqHBF0AA32wSGO2plhR7b8H3JJLBiUiEgf+Tcgk2UynwIbi9bXQINuNJyCBgp3CAnnCAKRFSx1mxyY1wKOayf9/FGcYBwOzfYu/R37tHR4xHIOL1gtdmP+2+RhpB4T/WeaT4oH1CVChImFNy6y81vBeMCOYrjBjxpFAWQhcGeuH2kSHWL6e/BRbHL9XX0Kg3X5ScAUK7CuUyXF/bgPVYAvo6gxD1+aE7FACPwyHwDwB5TVhh2DsBQ15SdjQrsGPZBPzVU5+BpzevUp7RgcuO4AOvC01dH/X0rnLzQdq4aAMkYcAivjaY80HOI9FIK4OAQMO6Wjd3hMNjoK3ZkJVUKrkAzQKkNJ9ZY3t6+yfw+oiSyI8sJetrKx9NCB4DavGdai7+fNECT4I1ONgxoqcdKABepzAKaBY2XzQL5fPMK66MO26wZ+MYOgYGhu7X0z5s28neHos5PlG5tFzV1UCslmVfD5hrBzj4tivZn/n3mcA4PDL2OgRpP61IA1lDwPnJuZvX/y+u4SbQT1e0q3tET3yovP+qGRRE/wqef1y/Vj/osrAGO0L9NptdlyJOWXUUov88Hj+QyD+1lBXKMCA1iwsbJ5/fPwBt5hzFuIss7VqeIU39cxYB9gzCYrsYdZng2D8wdEdPb+9P4vRoKCcRmH59bXV5jqyyeuYNgtljPOu3QC7Et/SGudXCu47+apdyrSk222KxOmbOX/hxp9P1ehAUsMWV5aXPJOIHh26PN4pAuu18LRROKAY7B+2tnVJfGbhXqQ2twJN0X3KnHzOZzXwWj/rBwf4XcH0s4UV7o+zcwbGucR4rZ93rZOSAYl3N0LynEvlbN04rXfJ1uVTawbNyA7RBy60moW01h1p5a8myrkjX1Mz59/r8gR8FLjwL5Ym/XVqc/zIIZ55y7x7CideW3LRSKWdi+7vLwKWCtFltzyuDy/MsFGYZLxWLX8X2/N/NjbUbohFDjRtHNZMTaMfyvwb6tQ0CpkAg2DE2MfUrJpOpEaJFPFgHsf2fxjNcSbiqxaHQtH6+1fv6+ZbXgP8LKDRpVlbXjaKrPxWJREmw/JfLFTi1tigtak3An64pd//V6fGBlc18bGQ9Gxup1qteQx3sZoPZGLB6qoPeaMVlshufSy72Pbp3ZcRoFsIJfG4nvGFmHEIejwju6+L/BGBfRlBcwuoQiR5Zu82Uy17UcFL6QALYlN5PKgSJidl/LrbPmPSTuSx0erzwhulx+Ow3ngO7zQZBspzXBUBsaKTXE1IAvhVBv81sFsC2uA0QON5MJVlcf5SBfofoAVA/XYkSKaESewMIChAQ2iQpLKQ2CPcxQsDpgrBb7p0leUboKxKH/2kF6FkHR0cs9KI/EobXT401uBdIHUQeCTaTHQa94wj4/3/23gNAtqwqF16VU1dXdXd1zjndvmkCk2AGGNKAIu8JCoJP9KGCYkBABgcBRUR9gvj/qKDCrw+eyJAGAZFhcs733g63c87VoVJXDv/au86p3mfXPqFvAJ3Xe+bcqq6qc84+O65vhW91I+Av53xJZOPw+NJT8KVHvguZXIZ+hgKLaTsdbrtn7dHWalvl9jWB/sdP+rplq5JMfmeX3ssWD3nRZBcxuqCm02m8pJUnkCstrL5KY7mqUchNoKC3DGJBhxJYkjQ2be3tv8On7MOdMbSyvHSnlL5GDfTzFh8ApcVHzWJK33u9lV1GniMU2nsB1IXOyxaiLgH0s4K20MW/u6fvZqfLVW/k/ol4fCaXzRKtGw/62bRZrJJFJOzygq9uvlum8M8su/drMfcLN3Yo5uN9fVV19btBwZJcyOzu7n5x6uL4/VK7lbU3sRj5q6qPavkp7O7s3BONRjah3MWfJSAT8WmwJK9yfeRXvewNJVf/+vqGETCg4OHLQSz2CAo794MypEOk5AHB9YVA2uPW9zDB7WyD8EWA2DOEj5080tzSIaVT48nQshLRsdXbP/DKQKDuf7IpIBEQPjo3M0WI50gaxVoj9Usmk3NgzMX/x1IuUUmilnatmCnF5SKZDn7P6XSeBrrd5tOLC/PfxPYiZFmeurr6NiNKkmgkcgHUQb8IxJaswlAuI4kMJlnpuYir97XM+WTv2kcwQGLAWeVnaW7Ibt1c36mteSKvHjbdG5uCUPFMOK4Mc0jEYtFzEg+NyNp/1Qj9riDoL63juIa/AUHarwKTfSUcDt2D6/cPpN8p7kNc8evqGwyR2Ib298ekVJqyzFMKDTxKyeKeGYtGRolnCsnkYHc4alFs8hNCXYksjoiaJBPEAQL7XRLugWB/MhwJndtcX5vBNTAJYh4cNbCv50UH8H8H6Ndz7xel7KOgv29g6M9wn2dCZwpJlFHvnJudfhLEaRJ159BPuq1+kuUY+F9m6e7qoOAFB7z8kewBUMCNFJKJhDzI+Ikviq+lnxECk1ZX3RQeJCczcb8k2lCv/P5H68+ePb8/12exWkzE4j7S0QKD7S0UruZLlvG8RKBXJLcjFn2H1QY1BULcV8RbxRCBAo2tNxVvXFxNpTAAcq3e2loIJRPgRhBPPm2qqaIEga21NVSBsC/xEBQd7AGu6+2CQayPTLwn437ijr+yv4egP0ct/T6n+9CKz3gElAC3SYn8C9L1i/HzhzH3xHOBhj9Izynfsxh0f9hPpex+AugihwfQWIFC8d6Fgqn0TMTN3l9RAY3VVbSNCvnDk502F3Qh4G/zdgkt/KlcCsaCo/DA1OMwsbwCmXyaehyQUAaz5F1hBaspkkvU37fx/M88uzN5zY31J384WNFKFAAsaGZj3GVWfxaQYyc68O+c0H3K7fb4nC6nbvo7UuLxgxXc3GSllYW5Dy0obLW2d3Qh6DcrtPRko1xfX/vDtdXlKdAH/SKLpPxeZKmiz4NCqdfhdOqm/CFkScHtbT7mS5PY7wpYJ3nQr5Uyi3fxdzS3tI3IZERGSjQWmYTyHNlq8f1qz60l9KoBfv65tYRFvdQ8FjMC9xMjp95ZUeF9MzBx7JJG/9O4uT8rncPWqXRfMh5tNpuumzpb0unUIoLne0Gcuu8oObPVrOmaVmkUOL3eSp8hRRxbstnMxtTUxD9LWT9EfAS8Uk1WPGu6geOc0lU2YZutM8BJzzvEUDlCfLoIhKgBWcJpYh06cfLnfD7/W4ABISgs3j8zPUnGEx0vnoqKaiP1xDVxGtQB7I81vt9gpgMj87D0HY7FmoGBobtsdvsAbahCIbOyvPS1zY01ogAm67zJ5/frKoeINX13N0jWJSOutjzxpN6hkJ+wzlW4r42w90/E409lMhk5Vl6kyNNj+Bb1I+tZx+65quk9PR6P7h4ll92dnXOg7p58VZRLVwn034EY7T3AplyNRb8/MXbhbsLTI7oP/r7e5dIPiSDrzsbG2gtSGxWk+plS6VTYA7rOAqWSSadD42Pn/zkejxNlFlGaE0VmAmWqlNVqzZvM5gxKZRniyU8IcSUXfn6+iyz4apZ9Pbf+FwXgJ+US0ojy63eZbEDc+yVLPwv6UzvB4F24jsthsmo8IsdM/irlGPhfoSJI80cI70pu/6C+gWkdZZvPN5ceumk5tt1PQD8hunvF6SGodLtBVsQfZp0vVoVaxAsSQKbbVQEcVnnnOsRbeUlRQICtbE4mMfp2BPwBd0XpewJah1qbwe0ohtRt7oYo4R1hwn851sXrckvW8EMPPmoxj0UJmxs0+nzgd7qApRYo1r0ghRmAVI/DOskW/iLoLlBsnpdS+1HlBeceQJ65yL5/6Mhvlj0cJH0A4Ukg4QHF+8uWffkyplKnkWKhYRGyEqP4ndfmhU5fP7RWtON1yqdRNp+B+cgMTO9PQDqbhv72ejwaaHgFaUOiMNmLFFMCLgd3IJFKEzJIUzibaPv+8hO/8pRzbPT2hmu/0eKuJSEAigURn122eLAWfxwSOUUsPHOerSYQ6DbqehgO7S9A+WJN74UbdW1Xd+9vS+y2TCmkg9tbn1peWiBCDFmM1eKOWRdZuWjFiCvd/GsC7UbS+KVSyTk8YnAV4nE1hCaRxVszXZZ8NDQ09be1t78WOAI3rbK/tzfJtDHr8q3GCm1U0NUC/OxzG93YVUG/E6U+ycqoYA4nlpa11eU/QfAxDUoPlzIlCwJ/Q/GhTMmtr61+FQU7Mj7U4vpFObONtIcar4PCFb2+obGfxFIfpdJFMLb8D8lEgrDq62UfEPhMKdquFDZkt9vdKPTqcmakUqlNUAqwWm2jO7cukcRPbWzJGSGsVpvNcWLk1G8iKLydaQMC+r8/PXXxKZBAPylul9sI8Cf8EnNQLuBfkRCHoxQNzwieeZ2fh2rA30Lc0rt6+j6OY4AK12Scra2ufEUiy6KoCtvS43S6dNPAZrPZYCQc3gZjFs+ydub+Nqn8hoKp1rb2m9l0XuTzYHDrPji09rNroRGGbz1rP8uVYQaxAgxwLXPZbHZDLugkhGRnJ7gIIAxruCoWSgNW2aO4YtPfDgydeB3KBu+Fw5DAAoLr+8YunCNKSpYTQRGK0tjUfFKlnxUlEY8vRCORLTiUG+g1cV6uIDg8bfTZNzbWnsB6RUDpVUlS3iYlS76R8DhRqJMaf46asutFBUBV1qWjKpLkz+mYwnWpsbu3/09Z934K+nd27sJ1/EGmr/S4Mcrw1IuhzS+nHAN/pmiR/Gkx/suFB/8OpzMfixHeLcOabC1XM7hn5bGXLseDw4SGxG23wxtecgbrzFuZJWgqWZOlt0UpkAG1JVN84fCs4u+Kn68Hd2FmfRO2wxEK6jtq62Cgo4n+nmQKIO7/JCvA0nYQznR3wInONpDyrlNG/XSuQMMLCFv+QToFkUSSpv4j7PqRRILyDuTyRTBPPAfI7+hnErjPM09jOqxk6fnkZ5Q/LpS9SucUFH8xXgPFYjEXyQ6JEoDyHpT+NlFPCMIPIPMhkPrXu+uhr2oQGtzNVOHBF8IzsBybh5n9i5DMJWhtifc9bRpTgYJ+8hkJkyDkiN1N9XDLcD9NzUjICFd394gywBTOxk9+delHQ63u+vvuaL3hq16zm2xKJbdoEAB/ELvG00XV56sylLOaWGx2gjQ2nxck897KyurevoH34kLMC8v5/f39z83OTJEYPhH4VANTAGJSJzUrn9XvrzJkJT2IxXgG7iuSxu8KECGVWMblo76+sbejq/tnTSbjOZ/z+dxBaH9vnWtntY2QjStUA/oisM9bvLQUNEYIxNi+tPirqgJ9fYMfQaCmcPXMZbPz83MzHwsGt7dA7NJZUrB4PJ7Kigpvs9F2o2PjIPYsAn/ijixy8eeVU0IrgYp1Qy1EhVf6kLSaI3r15Es4FPrBxvrqKKhnH+DnF0/qx9az9B4xnc+QMi2ZCIL2/DE8ny4hPp0H+/x7euCzVA4Nn7zTbrefBSXo/zoKi8Qt1C3X0YUFx55br67Uir2zswzGshhcFYv/EZn71bg12Fc6f5qaW3vb2jv+CPu/TnrWzMb62heXlxYIiaNHfhZimdViSJdLKpmcZzIW6bUXr5wSjVH2KHUJYmtHZaXvVvbemUxmZmtzg9Sb9+ARZecQGVdEfckry+R6qoaMeb2V1UbairZXKrmAa7mal9EV5444IujXI2OVQ7Rei+Pjt5j2KSSTiUfHLrzwtxJJrzBFr9vtQZHCWNjezs72U1J/yh611OKP83IBx2/WoFGjEAmHN6GcK4I1VIg85dQy3OR0/tbyqKPlvzoAPSK5qJYxgF3HzfUNjW2dXT2fxHWJ8ZwppLC/PzI9OfEAHIP+yyrHwJ8rcro+UmSgT1L5gc5mXvrNx8Bk/4Qpv7G5TQHN7k5QPk+xAKDAQTgACqm03eSwp0vfSe73ZQtEOB/3TYcWb7HbHSZiUb9psJcCU7Fh57CYShcqlLC+PDULkpWdFsl6ToD5Y6NTsBmKFEnx8P/dSAyPA5jb3ITXXnuKAl6btXjvwdYm6GpqoGCdpPbbiERgPx6nYJ7eyiQBdXw9yKQVXgb0tgwHAKmDmfxBwLfiIUxlrW9i/mVfDlch2WpfbB8zow4wSSEBxY9ImkXyki/VWT6v5DWBe0p/TQ9c13AKWr3NihSIciGA/+LuJJwPXkDAH6fKAxu2U05qd0KOaJEUBYfXLv5LiBdrfF4I+L1wpq8TYvEkPDu7AAubW9bN1P6r/37q327sqWz9p59pvYWkMVMIxxaLlab3IxEb2WyGMDKXAS+L1epCgbjNyPhHwW03Hj+IS9e3FAUYk9XpcjoHBoZ/1Wq18m55hVg0+i8Xx0e/DcwGigt2Fo8cnk8O4kJXwGvzghJtYJ+/yhqLRc0I+Mx4fWsqlbIRmimsvCKNH8kL7PFUdBh4DEImRIidrmjasSPGIYvSHZUduMH14Qb3C0aAl6KfUullLi5ULWWWlqeDFtiXi15Ig9F0fSXAT46mppbu1vaOj+J4ZVODFdLp9FOTE2N/iuMhxtybVRQpwE5DY/OAUSGb3qCQTy4vLtwNYhZ/vs0UFkGBwKDl5q8W32/z+6sanS6XobAbuWQy6ZWZmclvgjg0QZR9gO1LTZDtKlq9da1uyWRqH5TK6iMrzzR4EYwAENF4KoGQmkBtQ3fRct3JXD9HiBBnpicJcJAzp9C6+3xVWjngSwX36U1s/zioW/Suqov/JTL3i8C+QvGG6861DY1NH8H5Q709COhH4Pz5xYW5C1JbldYHBNlGw8RkklojnCpaFkL2uVhFAK1PZ1f3rbhmKjwQIuHQ94jlFrTnh5anBq8AYF38WeWjGcr7v3S+22MsfKTYXnG+vXjXcDWl7JGLQW8Ro7wssns/sfT/DhyCe0inUk+Pnj/36Ww2m4dDjFG27jS1tIwYAewkVe3G+toYKIE/Oc+UTCYiiURize32tOtdh/zeX1XdGImEF6CcSJn1mtPixtEjxi2AOugv9eGLAXweIV3fkRRJzS2tPa1tHZ/A+c0QiUqW/iLoZ/tMTeY5Bv0a5Rj4c0Vk1cfP8qxCQOU8hbDV2FCXI8R/oJzwJRxOQD+Q2Ep7mryWiIcK5Ux09L5ei2vParXnCAhz2K1Q5fPQOPEiQz0BpxaaXx4Kh4C3mAIvD4lMhqado2AUcaGFIfYD6XGJ6/v4wgo8P7dA4Si9Fu6i3b7W6FxopZJAwH3Eg4QfwG4zUyCdRCDfUheARDoN8XQKgpEoxPA+dFXGexw+eEF6kEO3/CIZX/H7fEH+1EQt7qRushXeIsXuk4uS5yC/rXK5iteSWpQ+dkEG1Ieu+8A3Iv6bh2I2AOKxkMK2s1uKbVLqGIZAsNZTCwM1/TBQ3QMelRBiCvj3puDc9nlIZA+oUoQ8O/ESIM/gwOchGQ7MZYYNvn5F5UY+VwASwnHriQHoaaiDH50bMyGWr5yLrf3mZye/fuObO2/9gwZbDdFa080zV8zoICkBLPKGqFhUq/xVTSgMG4qBDodDq8BsztgeJoLBB4dG3mGz28tiPHHjvX987PwXgYvnJ2zQEuOtyMVfMb7DoX05baCJpMK0EIVWPm/Oc26+Xm9lrdVm03WhzOVyodD+PkkjKIrpFG7GWhvCEeOQWWJFTfIxFLr7Ozq7fxk3uCO5fEvtLjOMi0C+mputnmVfrRw19prf0NmN3dzV3fuS+obGD+E89bJ1QCH462Oj5/5OIkUFKBe4FeCaKEtQ6DySm38kHL5/f3+PtJ1e6j5ecNNrG7Zd1NwZJWVP08mjZCCQ4q2/lEmnw6Dv4p9XuYwoLIW+dzicum7+pEihM1pARHMcXcI80gP9JQDS0to20NLa/jEcE6WUjqTdtrc2/2Zudvo5KPJoKIRzo/H96XR6DbTn0xUDZwbbTA2w8Va1sqwZ8mv/4PDt1dU175fTsBIlIrbV5+bnZuS2UjyX2+MxQoJYQFC1COqA3wjot6gc8vck7MDt81fdwVyDZpJZXlogbv4p0M50IWJU5/uNr2devjcoQb9Q8eVwOnVDIuRyEIuKPEnUPEMvqRzRW0TPFbtklaVEfkr3fjJXnh0dPffJTCYtp11k27HUvyjTkFSmhkj9IuHQ07inH0j9yAJ/2h+h/b2LBoE/4D37cJw8Bkp5QOQBoGc91gL5ap4ktLwYwOclMPdrhYyUZIP2jq6TTc0tH5WVkbTxCoXkzk7wwzNTFx8GbUu/Vlz/i6Ldr1Q5Bv5XsbS2tRe6uzoKDPGfXHhSG71SILDeYbaFM5CrS6Fc/K8PPAFupwOctqJ3sAvBos/tQdBoo/HsxHWeHFv7YQTMWaip9MBIZys47XYwyx6gkvkfF1W477kLsBUKl4j98F7xN7TeNNvqrkv+XSx4OllI20lad6JAIFkAyG8ml9ZhcTsINqsVmqqroK+1kYLWRDYDB6k0JHHt340fUOBbW+kFi4TSKaA3H8q9BCTbpJj7EooH5WpJPibXXNzbofVvrvIXf1YoxvwXiQwlBYMsUzMu/YctWSiGQeBbkpbwIJWi9fe5XOC02sHvCECtqwEa3c3gRrBvEoB0UgjgX4ktwFxkCuKZAzzfDD7Kv3jIryArOEAOtQCZgUHbS0M+rzlQBa84OQwPjE4QhYIpV8hfe/fsg7/z3sH//iFQxhxqkjnh5myURKywu7uzBoyFhaQIHDox8kan01l2DdzcxybGRv9SYtpl3eTU3I9Za2Rp40Awb0Kwp2Y5Lz1XdU1NhyF301RqIZvNJAEuP77/EsnHeLBXBlqaW1qHWts6fl0G/dFoZB6FwP2GxuZrjNQrmUisgzrQ14urNfLsImu2mlVbD/SXfj904uQb/X7/r+GlmLCGQjocCv0/E+Oj90jkcfJ95bHN1qN030BtXavdbjcsZOfzucjC/Ny/QXkMsNo4FQprBokdhd4eVqsNQYt/wGid6diIhB/c3FgfB3XQLwqhEfWz0OKHbegFAwXne1Lw8VHd+tl6GI1PVw0XIUdPb/8ttXX1H2QzjJA87Rvra3++uDA3LrV9GbhyG0hNR0oylVwD/dhdQ21xlHKZ6Q15hRt9JevniZFTP++t9P1P6TPSVqnt7c2/lEg0WQUJPRwOh91ms+kqh4iyF9exLSgXvsuUvdx7tf2L72s6Xrq6e1+P66bCWyMWjX47kUiQ2G2eUJYHcUdVgsr1k9+LzlcUI6np5HvhurcK5WPqinFHXIK3iBrpmgL04zr+M35/1XuAAf24Pjw3Nnru46lkMgUcITB/v4bGph5cC3XbiYSN4Dx+HA6z1MjAX94/zFubm+O4b77CiNecy+1qcbs9FfH4QRgOx6Yow5bIYKFmydcLfbqkvvvPWnQ8H7V4WdQ4IuiYwnX8JlzHf59ND03W8WBw+87Z6cnHQN/Sr9ZPL5q2v1LlGPgbLHrx/VrnMHGh8lf8hpNVuUTpnsQVIODy/2Ahsv52u8VGcCAkUhlIpIup4ULxOGwgyJeBrZyz3iyR31V53ZSojzLJS3Z3m8UC06sb8OTkbIkMj7zW2n1bb+58xQWHyWbKmQqeaDZmI/np7Qj4q70VVKEQRxB+fmEZihjbREnqzi8uweuvP0N/43RbaTQl8U7YCIWh0uEEm5zyDyQLtyTay5Z6EuNvKjlWKMEx+cvjsEONpwJ2YjGqYKhyuaXsfybquUDI+dKZDGzj/bxuF1RVVMh3OrwOeX4prKGuIgAWjxMcFi80eRuhqaIe7Dp7B2HlX4rOw0J4GpLZRMnjQJYNFKELwHofFBgX//LnA+ZXpP+I18DS5i48MjFZ/JUUBmE2W1zcKXqxxbYKb6UhbXgmk4lHwqEwcz3TwODw7R5PRVnaMQT7mzPTk59IJhOExEIUZ64A3U6Xq4BglSVoO2yAQsGQ6yoKq51GniMRP5iFI8RMql3nCNa2I7m6t3V0nmlubn2vbG3DNly9OD72o+qaGkPPR0osFpWBv4hlWEtQEW6CzLPKzyu/6rlh6zKGA81cabWfOHnm1xBsvZEdSzhfQttbmx9H0PEUKAFCiRmaqYvCClhX33DCaHuRsr+39+8o8O3AYeYDtWwTijGiIjQYsZyVWTjqGxr6sC0M01DnstkdbBs5NEFLYcHWm4+JVqs7fW+xlK0pKnXJZVWuxb8vXZ/Z80xgHHyoxYMqwAf53YmR02+u9FEQWwIgCED3V1eWP766sjTHXK8M+DucLkPEfrierIO219AVF/AvI70h/1pqW6vNZh8ZOf0bLrf7TfK1pcwZn5S8ImQFieIZESd5EVTp8o8QorpEPB6F8rUHQLnO8s+lxQ/C8tqYawK1jd7Kytcz1yD9vbO4MHcPHO4/Wplk1JS/an0mW/jl9wWNgxarxWpoPpGwhEQiHgOVdVqjTrpFR9lm1NIvBGjDI6d+1ucjyttDIloE/c+PjZ7/Q3ygBIhDIxT9XFdXf8rIc+D1JsPhEJl/PPCXFcQWbMO9g4PYnNdbOah3PZPJTIlVF+Zn17mvWLd9Vglg1BtDNYTuxQI6L8EIwq/hIkWSzBNxR1V19W8QO1CpQwqFGK5NH8S16WlQzm013ijeWw9eTO1/Jcsx8P8xFon8T/5Tdh9j05rJRfR3/i1tt/3TxejycyvR7b5ELlkZzcY70/lcVyqfqohnUy4E7bQ/SV75Ymy9GUGt3VRfXQm9TfXgJnHmCChD0QNY2AzC7PoGtXjL4BQ37szpqp7zr2y6dlZKv+KYC69WWUzUhZyS0clO+xeX1uDQWbW45pHrPH1xFl5z/WnpVyaaESAYjcHCzi7019dRV32inJhe3yx6GOCfPrcbQboHmmurDuPvFY8u40OgqQAjySReM0q9HVxW26GLPiUKzMHkygZViLQEquFUVzv1KOjxD4DTSkC+CypQ7ibWfKvJJgwLEJV4NgaLkTkK+gljf7FarO2+QMMsSoi29A+AMqJfLuL7Et6G9Z19eGFuAbYJz4LFXDozX8jFuj2N/wrimGdhfLnL5fI5nU5Duapj0ch2vshzQCvX3dN3vb+q+ga+siRt3+ry0idC+/sk5EDE4F/meoXCEL8xlq6JqNCczWY1wQCCE7vL5TaUGzkSCc+Avru7UcDPtrFa/VigomUtsWCb3oyAlYB+qmFCgWl7Ynz0m9lsxmx0LJK6R6MRlmhNzc1QcahtgALQr7Wp89p8XYBWgRLZwOCJD9vtdj7n9uLK8uKH1tdWF5k+Kg0LUFraFIIqjmtC6mdYUYIAehfBwQ+hnMxPCxgYKXrx/YojUFtnSOCV+3lra/OrKEvvwiHo55mnRQzgimvo1JvECDnAWBGBdxC8Z1/Z94oQAzCmSBK5q1tsCGJPnDzzXhwHCpdvHFNr2M8f3trcWIdDZYAM/EtzhYRFGbFik3JwcLAJYMgie6UAv6jN1LKG6MXz098S9/ih4ZE77Q7Hy+AQ9MdRsP4YCtbPS7/LSuco2srj8RjyqsE1bNtAu4hc/I1kASHrI3EFfgdrESQF961/jcWihH9Ci+PEiLVfVFdZTtNcW9lzcc82xNdC8shLaXmNuPZfCS813ip75DCtkVNn3obL+S8z/Uj2sGfGLpz/CALwBCjHLYBAPqmqqm5wud1GCFkLu7tB4t4tK2pl4C/LzSBd0xbc3nrGCPAnBQHmmYV5eAjKSSTZdua9AYyQmgLz+qICnFfQc0SxllMPpJOn34F991ZgFEm4NoU31td+D9dyOUuUnqVfBPoviwjzxVyOgf+PuXDM//IiJmsxRRYVxSI06G07hwdhrqXs4FI6G5xYJk8kF6s2mawWr9WdTuSSnrHw4tAjGy+8iQDknTAC160d2NwPw0EyVfQEyBct0vlcLtXhbRx9ReO153x4Lk46Ocd4YSa84jdLLPeBSi9uVnnKhD+zsUnhKGHu7/Y2RTYT+55kLm3ZjcXgyYvTcPNQP2XtJ1imraoKZra3YW0/BM3+KkqkV+lywcLGNuUFKO6uhM0/D91NDXC2p5Na9ItOC+x6DBRct1VVw2wwCFvhCLRWVxXDBoi1P5sFG4J8v8cNO5EtuLi8Bhu7e3DdQA/8dNfJI/dVKpeCrfg6rMWW8XWDISqU/2GBPbanqeTLUPyGKAJMBTHEZ/ThJDQ/nkxTVv+JlVXYixwQH3saskGAeC6fK7is9uduDpz+X9fU9E2C2HVSCDqqa2qJe7yheR4K7W9L1zIRghUEqLcClFWfkGX99draygSop48rc5tGwYyP3JBfTalkUlYE8ACzZAH0+asajVhKidsqPsca6Fv6mUF1WHQ2OFFcrZaFUsFU2z84/Jqamppfl7XaBIxOToz/UzKRIO1WAerx2dwz5tPpVCoB5ULKkWNDDbhhqxH16DGs07FY39DY2tHZ/TFlHl4oZDKZp6cnJ/4wHA7tgTLrADDjAJi/FUJqQ1PzkBErpHy/vb3d76ZSKeLNogX8yyxvGoLDkWNlKyt9tQjAdHOhywUB//mlxXni4ii7+MugX6vebP0MCT1mk9kQOSL2oQ2UwjIvOMt7GWslNTqP1KxEZSC20ufz95Oc8zb7aWDWp2w2O45j6i5C8ME8v3wvxZpEcsAb4VnA9SQfCYfVlGyi9r1SVlq98WW0vcx+RDp9/YN/jOvnCTgE/ZHNjfUPL8zPXgBlyFiZldMoB0Q6nd5RaQP2OXj3bzUSTD6unChNb3E6ndezF0bwvDw7M/Ut0I/7PSphHu85w8psmlZeo2SjiPnjBTkVkvpYMjyeDK7lqhlzQMNLjTzTyVNnf9lTUfFW5vq4jqefHL1w7qPEdYG7t8gwQa/X2NR8BkAsFrEF5/Pe2toqAX6snCGvLzY4nNu27a3N6ZbW9qDdbtc1cuB4bqmurmnCPSEG+uCf9QQwRJD7YgOblxByZNM4SmOqqLw9/Vsul/tVwHoB5vM7q6sr71tZXiQy5jHovwrlGPiDsVR9Mrkfw/Qv55ZWDQPgCAEVPt4ry0uAA1v+G+BwwOZwgyax1YRYLZspkgCSg2Uhla2sdskyj0ch5jW7iWXIWshlrU6wWgvZfCUCx/zS9i5Ozr0iPDVRy3ghlUtnvTZPsMkdOHdbw+lzlVYPvR4UFQpFsy+WpfhmAyXds1ig1uelVvX13TCkM1lqjXaa7ak3tb5sbDG2Wf31xfsHbFY7LG/tQFd9PdRWVVLXfY/dAdUeD2wfxMDjdECl0wX11T643X8CdqIxmN/YQtC7D6lMBhY3g/Tvl/T3wkBbE5AMBnzzOa1WaMC6bCLwD8Zi0OCtpKR6LltR0X7DIJ7b3gwPvDAOkXgSHjw3Du86oz8OMvkMhFJ7sB3fgvXYOn2PvQBW3MdJCATphSI3gVKmPqQsVPj4g6lQZPQnqQCLIRYmGs5Afp1Mp2EfAf7a7h5s7IUgfJCgigXyvVkKiUhmUtkqe8UjJwM937ixdvgF4pYJSgFWsQgT1nvgBCifz5h7PLE87O/vkfED1TWB2ta2jlcJBBhC3nT31OTEg7hoZ/GcNP4mgwddhMlrrsg2WCZo4SXB76+yoFCeJ/H8OK7NuXyOgH4TsfgTRn8QCyf0wI26E4wJC7sohMjuk3oueqWiYfU2KjSpEmqRdhweOfVWBH7vkK5BlG3709OTfxuNRkhdPVBu8Vbvq1w+oSIwGrY8GrDyi6zYWmCDB/3mImt4452Ir1hCRuLf+q2x0XN/hUCBHc9yn/CCIw94bMRbwigxlDQmthYX5u4H9dR9Ig4KLe8ILUuaaqxyQ2PTKaOggGQfQND/ZWKVBX3Qz45xvv1Ub1H6jQl0ATApNrvdDeXKOdHB3gPAmLBoxHJN8n53tbV3kmwQzcyzEibxB8bHzv9JouhqLN+TJQJTtFOFQeZ1XOOiEreBnpv/ZQmZOmFFWvH8mqC/vqGxpaOz+5Os4o0I1gioPrC8tDDJ3EsG/mUWf3ux33VLJp2Wsz6whe979nPW2l+W/YJ5JpL6szZQW/dOUO4Bhb3dnc8nk5R0Ui2zyZE8vjguD7meWhZegCOsu2xB2SbFtQdfRF41espq9rdqClw90K8IEyFMfCOnzv4GF6ZVSKdTDyPo/5gU0y9S2paBfrvD4an0+Q0RskYj4cdQLiB9K3s6CV39oZj9x45j4WlcY1+vd12yBuPvXoLAfwEEymqmzdii59b/Ygf88quWQUDN+GEHbkxVVHgrB4ZOkLSrCiUQ9uM6rku/u762SsK0jkH/VSrHwB8UYF5TAcB+h+9zR7k2CDYKTvguCf0oqLJuRlbmPQv+yWJIJxYBfCgg8hZI63U1fQ+H0hFYjm7dQPj+PFb3boXNtR9w+NevCfQtI6DNSOfJE9TJ1MO8Hg8Gktm0x2K1ASHabq0PUHC6uL1dTPWHqLazomGTCKcdFQ1pu8XeibDWkcMrTK1uQH2Nj16NPAyx+sdSKVje34fBervEem9BAO+j1v+mKj+ML63BbuyAAt8nJ6cRtMfhuv5uCv4P3aCLMLva7aZpAwm3QYXDQZUL8m9o+jyXG97wkrPwrcefoUqKc6sXwefxgMdppyCeuOun82lIZA7gIHsAsXQY4vial4A57TuLqcgJgP/ZpKwzhN9gcnkVGgNVEPB5KQt/iWeg1LXS/kyAfD4Hz16chbGlVao8ITwLJNyBPpNZOotECZD/8N7Yzjmv3bVW4/Q9ekPb8I9aXLWE9ZcAPXnjY4ESyzRMASYunCXhkJDduD0VhtzjSaw+ArIkcQnt6e27XUSUgwLWMxfHR79MMu7hfajrMdEhkQN0AAlJa4mHvGnLDUUbGjd3APX4Q/rq9hizlKLwuS7lkdYj4hIVrThko6BfIXyjzGQbOXXmN1Fo+in52bHtQnOzM3+5v7dLrN1uqc2yUr11C2ErB+VmzNYdBK+0cOuN1vNqgQ1DgEOFxC8TiUQ+Oz56/m7pGfh+ErmQlxEF1dQEWhwOY+ErUBx738lkMkSAVGPDF6XQMiLIqY3ZsjGCxeH3VxlWVoRCoe+jILsI6mkHRYAGQAm2gftMLLgeEipqFofD4YNyRRB7yNk55PvzVr9LAf0lYbynr//m2tr6D+A6x3r+5OPxgy9fOPf853FeZbl7ymtkmSLS5jAGZkmGELiKgJ8UQTz/UdpL5JJN26utvWOoqbn1j9lMB0SwXlleet/a6vI8KMGa/FrmGk/SwRp5jlQqJXtaqK0lBe57LWt/yeKP97f19PS/m0/fl06lHpmbnSau4CKwr7UHGAJpkncms6HTojaXStbhgsH5JBExmTQOuZTeC9Zw9vujKnD11nIzscqePHX2/Q6n83bmPoVUKvkfOOc+iesqC/pFa7dizDY3t5zAftQNLSL7w8b6GnHH5zM0yPuE/Cpf3766svRMbV39rbjp6noGeit9Z3E9+x6O2TgIlNYgBv98v7/owL5cLsP7SC2TUWltCgRqm7p7+j6C87oDlGFa8/NzM+8Lbm8Rwsujsvcfg/4jlGPgb7BcCrmfXuFi/kkRxZ/xaUfkNCmlgwH97CudmK9qvPa70Aj/DsrFjH6P57GbrgOUrpHW6chyFbHgE1BKcszbrTbq8k/4AcjPSHhap6eRTFLismZpc9VtLya3WslFVnd24ZBGsAjGe2trYWp7C2aCQeirrZOIBwGcNju019eCw2aD8wtLsB2O0pRuE6vr9BrX9HdBKXefXEV8afVXwdxOkMb7u6vtXLx+gQLtn77xLHzvqXPwqR/+LT2nt5mEEnTQ76gSoVBQ+IQCFEF8kSOxaAormGQ2/mKaQZK94JuPPkNDCobbWqC9IQC5AusBIF+rQJUYJ7s6YGY9SGL0aTpEKTthKXUgyXfrsbrWmt2BR29qOPlMjc27RuLooZzQS84tK3KjNTPjgC60FRXegN1uN+SmSdxZsa6m3v6BG0Rsu1jHtenJib/CxTlOLP34WzX3fq14SnlMKzYV7GszXlcUMya9mqxOh7PeyHOgQLIO6oBfTVDXc2XTc48sA/xQjKutGDoxcqfd7rhJvge23d7C/OyfBINbJKzCCYyViqTUMvKMhXJBS0tw5F0Y9bT4Wm7raoCjRPyE480xPHLq3S6X+w3MPWjMXjC4/Yez05OPg3gDl+ti4erFs+Tb6hsaDcfJo2BKYr4fAf3YfsUY0REe9Cz+PFEdsbz2WG02o7HSG3Mz098BYyz+/BzjAb8WUKHn5g0Df2c1KMc4D85leYL34FDz5NGaQ6XrkjJ84tQ7KrzetzHjg1w+Gdrf//OJ8dHvcf0o3w9AGd9fag+L2WIoTAT7IsS3F4jXtCOXy4jF1gX9Pb39NyAIuotVkuAaO4dz4X1bmxtyKBQL/HlX/0M+BINtlU6n4yAGByXvSO6e8rOIAH/pmQaHTrzF7nCcZu9VKOTDS0sLf00yCYC6pV+o9L0CwEAT/Et10i9F7x8+VEa0HrNK0bKrMK+Xs3+VKdtcbrcb591HcE2/nrkPIen9xvlzz32a8e7jQ/Xk+ijuRz21amqNkfolExOh0D7Zy3kOIfleLPAndU/i+IuE9veerQnU3qZ3faIcaGltv35udvoHIE5XmOH6pqy8GAHmZZBCyvNYzb2fjqnWto6h5pbWP0D5UeFxhfLl2PTUxAdwPSfggifxM5Kyj5Rj0G+wHAP/n3ARgH9S2E2SFTrIgJfjFbUsL1qumDwhmczky7r6kc+zm4n9ujwU0881V1dRazch1iNp+iw07t+cGKruXC4U3fGtQ1Wdy7Nr663ENZ6A5c3dfaiv9hdBLv5ts1ihK1BL4/Ong9vQgdckKfSKRieABvybXDuRWoQo4SHAM8dXVsHttMNgWzPw8hVJE9haVQWLu3uwFYtCo7cSlPAbhVW8/qvOjsB3n3qe8gjMrG3CcnAHXj4yDDU+b0lZIAU+lnQL1KNBduCXMiXQ35mAKkBuOzUMP3zuHATHo2CdNEN/UyOc6GqldaLKBOn3ZryG3WaD28+Q318AoKEWpC1sUG/3X3TbXZvX1Q49GbBWLEtg/0By6efjelmgAqDuTlfayEn6O1DZtPiyv7cbxEW50+OpaOS/I/VZXlr8dCwWJTGcKavVmibgH5QLMxW8UUArpFMpYQ5VNWsFSScJYoGHjmG73eY0WyyGct0nkokNMJAWSTFIDt/rbXJGwAr9PQof9d09fSSutk++D8k1jaD/oyh4b0rzzsK2oVGBUeJsMGsc7DOogX2jng0i4kKhld/n91f39Q/9gc1mO8m2bZHEb+n319dW5kCsKOIFR5FFkL46HI4Kb2Vlr5F2ItfdCW7fI+WANsJFcSlCg1o7Ktbf2tr6aw1eL7+5ufGVdDpFAKc8//VY/PmxzbsEq1ongUad5OJgoDiKJKGi8W+DciDJhq2wY4ufR6qAn/zeS/yCBwY/aLc7WPBB0NU2ttMf4Hw6x/UjD/xZN/9SO5kMMmkSAjaN9tNy/9Ysl5gmVE/xRrXZQ8Mjr/dXVf02vi15baFgfW5mevIDuM7vQDmnBk+CqFTeGo1ZLy7katlOZPmCNS6wCj2Jq6h0yHH9N1dW+v4bKNfqAgKEz0mWQT1gcCVAv6iPRfHfxfmUpeuNbkEZw8G1lVnwKo8J/r56AM0E6n2hp7Q2+3z+qv7BYbJ/DbFdfHAQ+8cL557/R86rjq0H37+lewVq69px/TbiqUVCOEhoFg/62Rh/HviTMZNcXVl+vKq65kYjXgXVNYGXLS3OP4Jzg6yxDuZecp1lOZsleCytrWQOv5iA5iXyG6nF9NuBW8/7+gdfjnJRKZuRXDKZ9OMTY6N34dgiHDy8lZ+VL48t/VeoHAN/plwNq/4RCn9vUa5QdmMtbQ5YiIu3FhDgz2E3XBZIUsAvfZbdTYUbyK2zhTw019VQMDu/GUTQaqaVaXbWLiDoJy60NI6yz9e67Fi3ns6aCh7iGbC6s4dg3i8BYaA/c9vtCPirYWlvF1b2Q/i+hrr9m0xFC3hnYx2N+59cXS8CcJMZXphfoq71frcbWDd68lLhcEKTzwcbkTD2nwWqXZ7DFpR+6nW54GUjg/DA+Qn6DKlMFv792Rfg2p5uGO5sQeGuQIn5Snx90htq4y/Iq70yjr++qhKG21thfHmNuu1PrKzD6OIKdDbUwnBHK9T6KovkhpLfQ62/El5xchjuPT9KFCYQT8WhN3Di6RF/1wtQBPtEWCACOAv6RQI/a0WTn5L2K2fxt6HQ3A4GS1NLa6fXWxkQfJVH8PTFzY21Sbk+UtiBMF0SA/qPmkNVDXSbbTa70yhBYfzgQMQsrWXll4vI6q3mYqvmjiy52HYONTW3fBznZZ18cZSJV+fnZu5EYXVbOocHtplcLisT9mmCEryuC8RCIltn2e1aFGpk1DIkAv1CC2NLa1tvS2v7R7BurOKIkPg9RQjXwuEQz7rNW9pZ10pecCwJFA2NhNTPmBIok04vLy8tPAHqVnOhR4hO9gO10Ape6VJq40qfr9rldncZqXMiEX9+ZWmRpDbUsvbrKbRYAVUI9oEJcchls4aAitPhaIByt2y5XiwAYOsmsvaLlGi8t5q5ta1jsLml9U5pTJXmBArqowj4yVzaAG3PETMIrP1SMcRrILWN4RSgeuWIFjU90K9QOJK4ohMjp9/pqah4G/t8KFg/PDGOgnUsFgGxkkRutzISRHKYjD6vSejJIY8Ndlzw4IG19JcAA/b9QF19gyJXPCnJZPLeqckJ4sUoiuvXSrt4KYV39Zc/U5tTuUyWhhXpFuwvmiaRDc8D5V4iH7zCQdnq6q79akprNQ4NlhfiE1g/NrwuG4mEPz124dzdUO7Vx96Tn++le+F1zxppF0J6iwCeZJrgQb+Wqz9VHiF4DEYjkfM+v/96vfvYbLZa3LeuXVyYfxCKwN8B6l6MIs+LFwXQvAyCX0PM/TjGrcMjp34B5cufA27dTSWT3x+98MKn0un0AWi794vSFR9b+i+xGNr8jsulFaOKBGbQqmmR+fh+luCPxFsTATHBHXHmOJAO+W9eqOSJrnIH+ZQ7mo17SaUcNivUeL0UwhIiOnkfHKxuv8hcl4DXWLe3ZRYk9/nt/XDpGSlJn5TKz+d0QTsCfpJ6bz0colZw6v5OMgzg767t7QIHsZxLzZHL5+GZi7PEJHoIvwuHQL3K7YFGBP/roRDsxRkZlml9ktrvRFsLlDjREHw/MztPrfA58siy/7QM+umtC4ehCnDovg/FGlD+AUJ4KBMQWixmWAruUu+C7z39PKxsByFXyFESRKLUaKmvhs6GIhYkvAkPbL3w08lChrQ5EchI/uOYdLBKALafeKENoNzNmC7EVivJeOZuMDpWfT5/o4glHYXFh2Znpn4ETKydxWplx6Gaez8/tnkFgJ6bemnzIfHRBknRcrjx73FzCXTuyQtJWrG0LOgRMvcPDp14DQqsn1aC/uzUzPTkexGoLMPhfEtxr2kpDl13zcBrO202uwvEwMByhEMNVMjP6GBe2feKjb1/cPhVCNL+kgP9eQSxXzv3/LPvQ9C/C9rue2rjWdH2xFW0piZgND1HYTu49W3G2q9lNT+qtV/kKSL6jtajqanlrES8qV3hQj6xtLjwzwYI/WSFiajeor9VQT85UqnkHhgodoezSUpDyYN/0TgRjRu1QxHTLQmKP9va1kbGVBPTpgUEfd+8cO75d+NcWgPxmNLq31LbGCVZzOZyMRArUI4MJg2wY/OAWLTuiNYei8PpdJ0+e+2HEPT/AhzKdQUUrL99/tzzH8R1XLamiQ5RqFap/YzGrEshYqL6sv3v5Ppe/lsxBhDwd+Ca8vt86j7iPTQ9NfFpzsVfLdRM0UdXyMVfS0ajr+lUatfIxSwWq9dSTKWp5fVy1HVcbcyozTmFZRYB/6murp7PsqCfePzt7u58GEH/10Bd0cKv34q6oCzi93q9PUbaJRqNPIL9TGQfHvSzB7uPygeVlVZXlx4yypdTW9fwKilbkBPEY7FMyQ3M/FXxYvwvUwRrkpH1SDSu2H2gNI+x3yvOnL3uQwj6fx6UeLOAsto/v/D8M59gQD/f18eg/yqVY4s/U4yw+x/xema8niGmbi7NH1tkLSMf26RYgEBsbVKbxKxlhPxdtlme35ttdVqcFpqOrzZAwTdxf99CME/d4HP55JCvYx7PkInGqNvy2UD/xdG9uZMmu9mUyGTgIJUGp91KzJn0wg6rlcb2E2b/hso8xJJJbKcckJSDtEKmYtz9iY4WeG5usfgZnrgZisD82ib0NDcCIb03MWYI8r7a5ab8AxuRCP3e53ArYv4Jod6Z3g7Yi8VgYz9EPyP12AyF4esPPwW3DA1AS10NJfeTrfy8P53SFFugngKvPHMC7n74yUOeHnwlYRC74Rg8NDYJ5oKJkgDWV/kor0A4dlC6SB4K/kc3zrXf3nQdIVrSsvSzix1vGRVahyp9/nrc0AwRWKkVBKKrU5PjX5RCD0ogxAQmtXjKgs/nBwR6WpZTtY1SDZSTfNsujfMO+zifi2fSlIFbD/CLFJ4iK7+eS3LJ5R6FXvuJk6d+1e32/CworG2ZpyYnxu6S2Pvl++SZ9xa5XVFID5GMGwa8kE1EURMMbu2p1El2UWSFMREvgJpng0ijX2YZsiMSHDoxQp5ZEc9P8EY4FP70+Nj5b4JyE9cTFoVKLPnw+6sanS5XWSiKqKTTqYXlxYUnQQz6+ToYje0v6wfBGCs1Ark+zkEzzkVDbv7hUOg7AkI/PRZ/hVcNI8jxVkKRIpkqk+PxeNBI/XAeBhBg+ggJKFMv1tIu9x2bHUFkARRZOOlvqqqqa7p7+3+Xiysm62syEg79r4nx0XskYki1vgQ4tDyqknoi6NJ1BSZF8sIBUAf5hhQAR3TtN0J6WPKOwDYL9PYNfNRqs5XS9UHRLfsLo+df+AcmLEsUJsLG94uAf04yLOgW7DMfKIEBa6FlvULYsI+y56qtq29F8EnigNlsIDQF4cry4kdi0SjxHhKBBL1861eiiLwwWcMMzqcDQ/OJKANxbWjc3QmGoNxVWqQQ5T1p5M/1vLb0FAv0vOETJ3/a5/eTdLMlJSW2+e7mxvoHmZAakccIwKFXhhAsNjW3nDSZ9NOvkrm9vrb6IJSHZskHb/GXPVVL4B/X0fVYLDqOYFOXTwDXtPq29s6b5udmfgTlRjARczzb97SQUN3/auDzElI/qikkVdMXB2rrmrq6e+/EPbALlPJBNhwOf3Zi7MLXJWJo1srPt78a6L9SfB3/V5Zj4M8UAvrVwD9J36fG5M8CfO581UHJ/k5+TwYxef/4ow+x55Zcu2sCtWaGGZ2+4mZrTqcpJ5jQYkqIkSTiNOpyQ9L70R/jKiy5hgsF4OXYZleRhM4ELTXV9Gpbe+FipfCfOmc1Af1R6XwZ+KfrHf5VkjkgA/lqAuj3Ee801PgpGA4iyPZXVIDLXiTiq3Z7wIPvbZZD44scFkBi+p+fXSpZ3Mkdzi8uQ6Cqkrr8k4wATHQ+Zdb3I/gnPAI70ShNwee2Oyi4h6LTPr32raeG4J7HnoFEOkPPIZfP5vJw34UxaK0NwI2DvbQ+xfR7wNSreKtC6a4mWk/y25efGIIfnR+jChEFuz/egPgobEciEIxEmRFBnP/zRMmQGqrpIrlKCShkSfzU8nTLF1fE9xM3eImosbQoozDYcTlzgRDNoZBFUiWF8fp0QySLNI4h4pKeApVFWQb9WuOdL7j5WhAggzwuoUhUWNqIbAbTSeVz+WQmQz0oRAoxdjOT264AYhBsNA6ZnlNdXRNAsHIXPgebV5wwH39n7MK5v0jhG6ZNZAGb5dQg7enIZrNxnKsx3Ch9oFO8vso2BP5TIBaebSB2vZb/VtvYDbuD1tU3EHfQ38e69gIL0PL53a2tzbtQkHoGxKCfVWTJ9RER+pU9U0NjkyJvu0YpbG9tfUtSWLHzSQtAX24RWtabW1r7sY0CeicT8sy52WmiKGE9fVjB9yiWTHatUAMqJeEqFo1sSYSddtAoZJ0JBOr6VleWQqD0QGLdt9nP5KI21hQM2r39g7cGagLvMZnNVex98/nc8vra2l3LSwvjoPR6E4U+sAz1qpk8bHabLvM3vXcuz7KWHxlIGkiJZZT0UAj6m1vaelrb2v9I6W1DFW9/Oj52/jugP/9ExH6KA9d7Y6EgTkrAypIFs2GEcsYFdqyUkRLXNzR1dnZ1fwifp0Z59UI6uL31xwgKZ0Ed9BvyPLuEoubazyrSmPkU3SBeEka8Snw+fyfKdLNQrjDhlVn8eGZlAVE8v9Y+pph7Hk9FxcDg8G85nM7bmOtSMkicc+/fWF9bgnIwnOfuD6AC+omXUFV1jSFPrWQyMRoK7W+AuocYbwgj95MzXMmx+sn11ZUH+gaGRiR5QrPU1ta9em1t5blUMqlFECma+//lwP8RUz8eBfSzIVtmlA3O4n79e3wmDuLNhuP9j6anLj4A5YCfn8/sWDsG/VewHAN/rmhY/PMa5+QNnG/onvJ7gfW/gAIkq+kkxYSgX8TwLv9N2NJlXgCC+ZmNl8RMF/gNUjrfZA6nYy0ExBJLObGEk18QN38LJb0zFZoc1RegKKQq8qnike32Nj8/GVu+nZw0u74JTYEqepP92AEC7jS01daCzVo0yjisNmAI8Q9T8pFQgtYmmFhZkypGYvNJarx5uO3MEAX+bDFJe4HLZoMmvx+y+TyDEJTvzvZ0wmMT04eWfROpvBnWd/eo9f9ERzOc6e4sdrhcuZICobw011VDY40ftvYjlLm/29s6sxXf8UYz8apUJmu326yU3Z90RSafIZwGsUpbxfiwv/3uJkcNAW98ui5emGGrX6bpx8W0jHClwus1lP5OpRRC+3vf3drcIKEcSSmmnwIoyXrEhx0IyfzUxjhw4A3BemkMFwqFAv8bBP4eMFAIaJZOV9Nes3GIPBAWxbCJBCYF6O/s6jlT39D4YexflrQoG4tF/wZB/5exvWQhjr2fvO7K9ZEtFo50KrVpBPhXVFC3yQeg3PVORHLGkoWqAQ61Zy1TdPQPDN1eXRN4N85VRb8gQJhcXJj/EI4bmXSLt7KrkbCxChihoEG8Pip9/kEj4wDbcG5lefEZUCrS1Cznl2rtl9sTQAD45eetCdS9DPSVFXkENV+U0qGJrP2quch16qwHVOhak0wmIzgHgw6Ho1nvgatrak4j8D8P6tZ+HhgAKIXJMg4PQgrZ3dP/6wgcy9oqnU6ReO5PRSMRniOCJXwSpTNkY6N5gd1ks9kNZVjANcUYQztXOBdgoScT6AvY/Kv8PW23vv7Bl9UEaj/IzkNc/0I7we0/mJmefALKQZMofabcT2UKIfnAsREx8sxOp4uEZThAqfyR5zTPwcCvP4TT4URzS+vv4lrKZ6LJ7e/tfWZ2ZuoxUAeEaoSXV9IVWDWun2mvDAk3I6SQuI5X6V3QW1k5QIYLHJLL8e0HcKg44RWmRj23hHsXObe9o3OkobH5/RaLhedmeXJqcvyuSDi8B8r5xq/fIu9DRdx3XV1Dp91u5xQ54vbdCQblsEI1Rnd+3LLKc0rwR153d3cW4/GDSY+nYkjvphar1d/V3fu6i+Oj/wrqc4VXEMvvFeCflP+MgFQH8BvlGNGz8tOU0oPDI2/y+/2/WMQYhwVloeD6+uqdy4sLoyAG/KK258PajkH/FSjHwP8/aeFcN+l7FPZhCzZYja/S+7x8IWbZSFniFcTzeZGli56fhZwzmo37bRY71FZ6qYs6UQBs7u9THJzOJnNn64eIpZoIqXIslbwAZ17edObJycnFG3MF8BCCv+1QGAK+SvC6nJQcMHKQgK6mekq6R8j7WM/mggSuyTGAwH9saYWCZvI5YfnfCofg/NwSXN/fXUq5J51YahFyTaeNV7ZL3AD4b3tDLcxubFKgTk4nZHsnm/vhwvoUZE15GFtchfmNbbi2txs6m2ppKAJtxELhsMGZ1idtc8uJAfjGw0/RD3wW19JP9/7UE1i3VBah7NjunLdQyGb8dl+00VsbdJntm/kikzYL+EUxiyJ3aOD+LlugrQiSUAgzmue8rKTT6aWZ6al7GBd/3moqiqU8Kplfabyh0GGSvFLkzxTf220Gc27naVygWtw+G+KixZGgBYJLQipJzD40fPJtFd6K/8FucCRt3d7uzkcRrDwM5THZ8v14sCQLSSkUVubdHk+/3rO6XO4+bDcntlsSlPF2vMAocqvnLURqQJ99ZpPXW+nv7R98NwK0W7l+KiBovRcFp09i/aNwqBiSX/kxw9eF7QcRa7AVhdMBfF4jCqDC9vbmt1hlFSgVVVqpJo0WXgDkLep0/rrdHqvDYddVViSTiUcXF+YehaIiVYt7RbfeXMiYat2Ai5XFfpsyAvxRkO5HoN4UDoWWQQkA5D5jQYtWeImJsNLieLq9urr6V0wmCvZY1/5ENBL+6/GxC99gXPvVgABbDzYkTkVYNyHwt3oNdXQhbyS+XbF2MVl62PHNh+IZJQ/lY4yJEx/hQHg7ygPvAIb4Lp/PLa2uLL8fj1mN9uL7Rq4Pb+kvnZNIJDaNtJXD6Wy0OxyV6VSKd+uXx4VIGSR5ewy8PBCoeyfumXwIRj4SDv3NxYkx4r3Agn49vo6r4eIvv8pHGeiX64Zzegn7Rxf44zreQ8JnUsmkDPpFZJkZOAyhYeU/0VquBv7Z35hQPnD1Dw69A+fzG0GJAwrY318dPf/CZ7PZTJJ5LtFexhOaloVnkaOuvuEaIw2czWa31laXzwn6l1c6ACjlWZmJX47zp3vh+trqj3pwYBmx+vv9VTfXBGqf3d0JTkH52qK27sprAzuuC/+Z2P4NAn4913410M8qJEn6x4rBoRO/iWPrFlDKB0SBOjM/N/Oh4PbWCtO/onh+kRLvGPRf4XIM/H9C5RKI/2Bjc1tk2eCBEvtqhnLAwQtDig2YHE9tj3bZLDYLcXdvqqmmrvDE0L+5F6YgvNrpna+0uEgcm+zyLW9EFPjbTbZsT2XrQzPR1TsIMH9sfBruuP40jYmP4/62FtyHDbzWTcO9FPwT4F0wybD80BjrcTmgodoH26Eo/a7L15qY2V9wTq6smwib/1BHs2SQlwA5/pPKZqgywI5Y7NB7QL52sRTj/Tvh3mdHqWcAyVqQSKR2P3DjL+18a/Re81R4sSOZztoeGZ+E52cWKFM/STVY5fWA02GjVyxyEVAtJr0+UWoQJcl2NArP709de1PDyfttBXPYUoDEqaruBZDJugqQzBetSKK84mqM5yJvDlXg7/f5GywG09/xhQjZK8uL/x9u+hFQKiUMpUG7lEU5RwaGRrHaDLrlFq3rahsXa4ESjX8tS4nCNRkFhLqu7t4P2my2a5g+Ic8xvbK89KH1tZV5po1ErpG8m7tsrUjt7AQv4OVfAzrEqwQENzY1D6OQTyzbWgKjWjy9loWozBUbBaibsF7vKXfBhUw0Gvn82IVz/5uEh0C5VVZkZZcLG3ahAYZM1ppA4IyRMYCgYxb74DnQnltXytqvBQLSRPFXXJXUCwq7czPTk58hxKhQXBPY8ARN0K9RZ5Grv8g6WSLI2tvdeaGqqvo20Bl3xN2/s7PndefPPfdPhSJTKuu5YQXxmCudLteruaW1p6m59VdxDg1DuZA4u7a68tHVlaUpEI8lNZ4GUXhDGQgk24LRzBD5fCHPfcRzObBrMh97zf7eKOO6Jq8GgsnKgcHh9yPAfilbD1yvn52ZnrqTpGXVaDPRHARQAfzyNcLh/aVCoV3XdZ2QjtbXNw7i/vEcKMEh6wmiGBPY//bB4ZG34XO9CsrHXj4SCX9hbPT8V0Hbe0dVKXa5IIFJt8wq01gwyIL+EkFZJBwex2c6rXd9El7T3Nx6FkGR7PrMr+EihRow36uFi6iG1BA37PqGxvfgHsIp+grJUCj0FxNjF+4B5RjKCu6vZukvI/Wr8FYYIvWLhEMPSnwSolTBfOYOdnyxZNclqz+CzBncI8ewH3TDDAjfQkdn11tC+3ufkbxkWYuzXjgYK1vT8pO0/gu8jeTXo1j5eSUOD/4VPEcNjU2d7R2dH7BYrK3ArefpdOrhyYnxT8RiUTlETI+Q1bAn6XG5tHIM/A2Wy3Xh58ulEAk2NtSVWR8Y6wIpIquHDP5FGnDhIrAa3xuUL9NSW03frWzvFEn98P+Ao5pY+2XgKhOukELGExVYX9N0w30LF795NmeBhng6Dfe9MAZ9zQ2wfxCnIH83FqMKgZefHgaHzQ5mqcYm5hFIYMKZrk7492fPUaAdS8bSfd62yMzBav0zM3P0Z0MdLZRVv2iNN9EQgqXNIE3/Z7NawWq2clKaiZIA1lRUQFtdABY2t+nno9tT/lPe9qdf03j97g2B4ece3Hx+ZPlguyeezTgurq7D9MYm5Sko4L0y2SyuTHlab7fDDg68JwqSEIzGigoGs8X34Mazba9qvP4Rpp14674RBlO+r9j3qhpan7+q5ahjVS7RSOQh2cUf9HOIXynwBNyr4r3VajXk6g+HyideAOEtUHrxx0LAT65P3WtrAu8zKWPXaDw/bm5/cXAQi4K+ldvKvS+REyEAW0LwuoaCvW6oRm1t/c0I/InbNRF2nKBUbvCWNj3gLxQU/VXVga7u3nc5nU4F0KAPnc/vbm9vfXRudvopEG/kamAbQH88l/rA5/MFUIBsNzKesD5sbL8WOd6VsAiqufhTBRRx+UWh5wmHw/lq0bnYz09MT08SN3ZZiSoK+bnUuaYWk8zWscSKvb21OdPW1rFps9ub9B6aeKT09g++anrq4g8O06QohH9ecVlq60CgtqGtvfOtTpfrZVAuf+QTicTdkxOjn8PXGIjBq8jjSC7yXiZSkJfaxULSrxjjigAosbsYOtiwFYBywK9nVdPk1Whqbulsbev4KNafnQuEuf8eBMd/jmvQgaDN1FzhgasnD/5LQDYWjQYzmcy23W7XJdasq69/ydrq8rjEJcR6g5TNPxwLTZ3dvUT5w5F/0ZINh/Y/Nz524WvAAGpQDx8qc/O/wiBBzYNGmG1pY2PtHIKhNyGw1/VWqwkEbllcnH8qn8uJXPz5OaXmNSEaW+znpuqaQB2C/l8WreXYXZubG2sfXlyYPw/q3lp5Qd3UrP3UzV8i9dPFGcRDa3V1+SEQK3ZYkj12XpuYOsqec0nm/valxYXvDg2fGMA62PXqgOt0W09v/+umJifuAQ3wybS96L1CfvlxWv9VwovY92qA34gSUgT46RjrHxh6FY6td/EZOKBIMPrlsQvnviB5Jmq59uum4jwG/VeuHAN/g+VKM/5DueXxkurATwZOEQCgvmjxwjZ9j4DGup+J9BB5x2G303R1xOK/iMCfmErS2Ux+2NdJcs/LgiqZyGycP7X6WE2mzC1Np798//qzv2O2WKyh2AE8M71QdOU3FdPbkZj/e5+9ALdfM0KJ+GQ3/1LKPnwlsfMVLiccEE+B+Lb3XX1vvLAyt+1OWjLeZxH870SicMtwvySe5ambP3HTf3JyDjoaa4upAa02RXPQrIL43zV9nbC5tw/xdBaBu9Xyb8uPn3pX3099y2fzpN/Y+tKVg3zC8eDGuTPLB1snEul0ldVsKbL+S82XTGcgmUqXfP9ppoFiRUx7qRgh9IqAUpjXSlmiWPhQMIZkIsFusmrAjWVHpoenokLXZVdUcHHen5ub/gaIQb8ec/JRipalsuwgpJRGLiqlGlPEF8Jh3LvcjnrEY3J7KuZFhdfr7esfeg8KTQprPLHUhsOhP784Pvo9Adu4GoM9269pps5UaNnZCT6AAtM7QAecuNzu/kBtXcdOcHsGlGBLHiNqFn+R5VHxvFar1dbXP3iHz1/1dmxX3uOCxIA+Mz8380e7O8FNEIN+kXsxa8lSdB2IxzUVLBubms8YcddEkE1i+58F4+n7jgQQGOsfgBIA8CAgLfczguM/w3bM2+2O24gbcyGf38O2G90P7X1nfnbmKclLgk/xyIfUXCoJoZqrvyyAyQonwuNh293duQ/BytvBAChG0HabzWpzzUxf/DeGXJYdc4q0g9iHnQ2NzW9wuZy3AJSnNiTAA8fxp6Q4bjXwqpayTS68klvkns3QiOgX4uEA5W76IuEZgOPfUfmtmmcRL1QrQD8K169A4fp3lbwahUw0Gv0sCtZf1QmHULP2y3WVeYCEbuuE1DUWi45WV9foAn8ETw1dPb03z05PPQRKb7VSnDquofau7r7bfX7/6/B5yjwvCAjc2935MwRgPwRB2lPQ34uuJkAwpEhLJZP7kXD4CX9V1Sv1Lmiz2Wu7unpuwbF/H4iBv8jVXe4/VVlO/tzt9ni6e/v+W0WF942C9iZr+dOz05N/uL+/twPqllg9pW2Zmz9Z76qqq3WZ9UmJxw+ej0WjOyCWjVjLO6tozHH3T/N1CIf2V/f29h6sqQm82kg9cI69AtfA2c2N9VHQVhLzSjP5tWwssjL5lQavOtZ99r1IAWlECanqgeTxeLx9A8O/5nK5+NA/SuK3v7f7F5MXx3/A9elR0vUdg/6rVI6BP1cIuBZ9rme9V/tO47zCJdzLhOdo3oeL8TThom/K5rImFDhNuMCbzBaaVJ4y+jOkcKUFYCuxXxNJxbwOqwM66mop6CenLAd36SWdFvtOb2XzgpSGgwX+BSZTAJ3Yp/3dzx9kYp9/cvviuxH7m2WBq7++PT21MZ9DqcoVTSbhW48/Ay8dGoDOxjoaDlBk3SvCf3L/ppoqmFnfJMHr5ud3L3rf2ff6H35t9kc37uTCTUvbO7C+twfX9XZDX2sjRBIJ6spPzl3YCMLq9i6c7emA/tYWKHptFj2tTdj0JAPAdf3d8NCFScriH83Gmx7butB8U90IUWxkPGZX7vXNNy6bzYV7nglO906Glk9Esgcd8UyyNgNZm8PsIF4QRScF4qGQB+rNkMul965p7v0eFIG/WloauuhZrNZcLpuli5/d4SAgN4+APy+BftZ1FYDb6InrpdTeFonZn8R/2lGwqoOjlwIK3t9OxOO7Ur+mCJs/HrSu+JorHuZ8JpPWXJgNjuvSexR8TMTYUWzGAvt9gboTF0o8EpoFx5icR1oU865GMqUGOEvCU3dP33W1dfWEdKqB6RPipn1hdWXpo+trqwugFJjVLFEA5UocedMtCSvLSwuP19bWvdJmt+spcExt7R1vRPD911LeYp5h3QpigKSm9aef4/O+JFBb+0sitz1iYESw8YWJsQv/RyI+EwE0kXsm746tBpAU74kCotLn13WZJdcObm/z1v4rrbBS3A+gDPzLGSXkkifW/OeeeerDJPUhrqNWBMkZxpVUFG+vyyqtJwQJ3JP1gAqZ79alxfmHUPB9md1uN+JdYULg9pIzZ68bDIVDj+0Gty8gcFgpPhrl7bAGausa8XrDCDhulKy6IuVNDte6b89MT/5tNEoJ/PhxJLLs8u3CWvpF4F9x5HJ5NjxN7zFF80R0sO0tvzfiSisC/iXA70AkPTR88tdcbvfPsPXFcb6P6/VdEokfO4a02oxVvgGUgxf5UFivyfjY2lh/oqqq+hWSIkSz1NU1vJQox+fnZh7C8UD7CM8jWYma6xsar/F6K2/CtbRC1P75fH5nc2Pt44sL88+BGPBrAYarDRS0FGn8fLItLsz9+0nfmZeYzRbdULXaurpXh/b35nZ2gnPMGCoZUqCcz4Ltw7J1E4qyn6ezu+eOyspKBPxmEWFs9iAW+9LY6Ll/lNZy3tIv8kBkuYY0Y/tx/rfjuqeb0QSK5KYyqZ9a2KMaCGet/mysf6ke87PT/4FjbsSIxwoZ323tnb8Qi0U/G4tG10C8V/B7Vob5Wwj+5fMvVwnAAX25LvzrUdz6tbL5qCkjKRFnU3PLb+E6r5CJSMGxtLS2uvyHqyvLU0x/isIAeW8OoQLvGPRf+XIM/OEwHZ+WVZ/9DflbTv0nv1c7B5gFgwVER/UekOqWN/JbBvwTTapi0cpLghmoaInH9mbbXDYnPZfknydlYzdEGemJ0a3GXnFBAv28VU22pMiaV/r5zbWnHvDYK8KPbJ77lWyhUGcqFEwH6QP4pYHXf+kHS0/eshbfHTFbzKaHLkzAwlYQbj1Z5MI6tPoDNPp9MLNW5Be6GFpqu63+7BPv6H3tPT9cf/r0aHjhWlwybI+NT1Gm/ppKL0TjiVJbZFDuINb/52YWqWIh4PVCwO8Ff4Wbxue31tVAtdcDe7ED6q4/EV46jcCfjbfL5fOm3DU1/UE8iDWKgHPTTibiOx+cadlNhRtS+TRubmany2bftBesmyM1vU+2u2tXQQPwy9dG0F9a9NKplGJjQ4HZFItF5UcpLeJ4fwvWXWbzpwtyUQFgsuFm70esZNQ1/nB8pdPLCwtzxEpTIvQj/czFbdNNGAVA0nYFKXWfHoO/Ygw//uhDJYUUjk1AYAeZTJrX9paEUNyIC1mD6aQIGz5uRG5JiJHZkVkLAc9ELrdrGfglrygsVPb2D/yq0+l6HShASyF9cHDwxYnx0S9l0mmeAEnNysaG34iAf1LuS2xb69rqyr92dHX/DojBUqlg3bp6+wZeOT118T+4+8jzWgt4swKjqb2j62Rdff3bbDY7mw+89NDZbHZifW3lT6UNXQQ2RLF6PJmYrJjgi8haAQ2Nzb1GshzgGFpYXlokIQe8d83VBAgyAGCtPgrgL31uSePkZp5bmAZMpf0uJzRBzzVZFpSpVRvnjXl5ceGL3b29H8K13mXg+iYL9k1NTeAOPF5HrM44dslcJWtkBYmbBQ1wjeNpbGtz4zNLi/OjIFYeicCryAOCHfMFAwfxRCepSXXj/HGpd4BYUGbnF5sphLdyGwH9Qit/fX1jS3tn14dx/A+w7Yj9NIVj/UMb66uLoJyH/BjSYyZn55yI/LEUM72/v7eciMfHEEsaUcKZa+vqb62uCVyD436DgH5cU+pwbfZqjodMZmJ+fvbjO8HtFSj3kBMpxURg4YoDBQ1PH34+sYDTivtbcGtz8xuNTc2/qPXctANMZnt3b/8784XCF0i4l9yOoFTg8s/L9yF9T1z6W1raXuep8Lwar+sR3ZuAs62tjU8szs/JZHpGyDPlOsn3ExGxlgB3fX3DWSPti2v3ysb62gQYV+4AKLNRyN4kaRAA2UwmY8E15l96evvfK61JmoXsN339Q/9j9MILf4v7O9/WakA6w7zX8kQpKQcFmbv0ipp1n6+bSJmuBfhZxY2m9xFRYA8MDr+1wut9IzDEonJJpVL3T02O/3ksGt2DcoW2VojOMej/MZZj4A+H6fi0wLjoN0cF75cTKnAFwgyMaP0su9lYe55ar4tu9mT+zW1sSu75+UJ7RSOxhvPuqWycv+y+LE/01Glf9xMj1T1jX5u99+eXohuvjcZiF/31npmf63jFIgL3gQfWn/vZvMVcuRLchbsffgJeNjIIzTU1kM3l6OxvwHqQJAQmixlimVTV7MGqq8fTsvrqpuvvvb52+Invrj7yqo1EaNiKPyDhA0BDBkxQYXNHI8moh/j/Z/Ba06sbMAMb9LrEi6GmsgJaAzVQ7/fBLonPNxG0m64yWc3pQjYfBjHRXoGA3mpLxe7LG87MgroAr7bY8alK2EVPQVyDoF+2YCnAGt7fJOo77B+Lz1/VBDpChqDkNzfWvpHP5WKgTeZH62u2WAAFQVpnfmHWUp6Rz3mFFAr/xE1BJvgrA/8ETCBm2jPyEIQLwOOpqI5EwnEQpxuTY961NPhETiWpsm6tqq75dQQHAVAK3TNbm+t/tLgwPwbqoE1NMJXvwQpRLCFhaYNdX189X1VTc7/P53+lTn+aArV1b8jmsrH52ZmH4RCIiki1ytwViYtIR1fPDdXVNT9js9kGRPfCPjjAjfwfLk6Mfg37i1V0GHHFFoENIyCWjodAbe0NoD+eC7s7wW/h+OdZ8a+mtV9RT8H3BTgcCzIwNHHniJjURaRSlyMIibwSeEG1pPjd3t6cdLldf9/U3PpuI0IyU8i8sROPI70f4vq1Ggrt/8P05MQPCQCH8jHEe4xoZhHh2lUI9JVtUCBOF3FjwJ+SAIo4MGQwxqbmFHkSqZ2rmVu9f2DolQjgfhvblM0+QHghvn9xYuxTEpeImrJErc1E454dq6JQEDlm2ra6unxPb9/AsNFxgWOhwuVy9xr4aR73g29dHB/9OwQOclYQrbC4q0bmZ6Cwyr4yXg+pvUp9vTA/+6C3srKPeL0YaK9K3Hd+c3tr857FhbnHpH2eX8eF2SqcWFpa26/B/f82h8NxGpRyA/vT1MHBwf+Zujj+pWSyxAnBW/n1wtT48V1m7bc7HISHss9Ie4b29++TjElaKRr5Mcx7q2RBQ8EW3N6a9vurflBbV/9TRjoZm7N9aGjkHWOj574keTHJ91LzlpOVD3I9tAAtr7Dkxxd7P75cDuA/itdR2bqE42uoqbnlPShnlXkCkv6LRsKfnxgf/Zq0pqsR+GnF85fk32PAf3XLMfC/iuVrd999VAB2JYsRYg/eemGOpg4aCGj2Oh3gwYO4zS9uBemFcrls5oa6YaKZVaSCgkNBjXWpVsSRWnKF1Fs7b/9CwWz5qimfw8sWqDv2iK/z2RZP7cK3lx5+814qPJJC4Pgfz12glvlTXe3Q3VgP6UwGHA4bZLJ5Qt5nenZ7sruns+UCnp/32zy7b+987d8/vTc59Exw4k3JXLrOYrZAb11H+DV11/51JBlzPrp5/pq56Pr1BShUgMlMwA4F+XuROOyEYuSjUlNZLdbK1fRuV7O56iFQgke1BZwX4I2CQdV4JhBvCLoxowSweioqdN3Z+JJMJqbWVleIQkeO7RdZWEp1Jdb6XQgKr3UJCqqC5A5aZu2X751IxA2lk4KipWkQgT9hbJTd/GUhTR6TWkAYcHPra2xqepfNZj+t7INCJhFPfOXixbHPJxOJBIgVOnrWWhb4yy6KfF+WPA9QOPuXU2euaXM4nHoClLmhoemtFR5v+/zczDdjseiu9Lk8VsqE5Kamls5Abd0tbo/nNompX7RWkTR99y0vzv+/weD2Gmi7YeuNb4ByoUU0VkpzqtLnq0TgoJsOL5vNriwtLpB0eCLQr6aEuSSQwHpTcfUVPQMfb8sDf3bM84pAXhg6Un11+Aj4ccd6YBSwLR8hcdYE/OPYMJT2zkhBgXAN5+ZXZqcnv5dOp+OgDfiPsl4ClI8pFdBfPHAvO7DZbNV6dTZbqHJAjzBU5Mkj4mHRyxpi9ngqPP2DQyQl1muZZ6Jx7yhYf4ZLb6gVXiNSKmvNN9bdn7Vgl+q5E9yerqtruNdfVXXHlRoTuPYTboe/mpudJt50adC28mtZ+n8cYIEdW0JCT6nNFISwF8dHv3Ty9NlqXMd107QSZVRDY9NbagKBlyIgfgzX3Qvh0P6m5N1XIrhzOJ32mppAc6XP3+PxeEbsdscJKRWimsxZIOzqqyvLn9vcWF8E5bhRI8/kOSFYZYIoPrwE/Bsbm4bwWRygU3BNiK0sLz4K6l4dbD/zY5j3tuIV6QplOo6x/8D9rh3nmC7LPykoSw0PnTj5tvHR819hlDBahjNZmcq6sKutW+xYEo0xALEMyL+qyfciHh89r6Oy1KHkwDar6O0beDu+vAYEVn6cw/MoP/7x6srSJIgBvx5Hi8J76xj0X/1yDPwvs1wF0r/LroPB3J2sUFp8bwZHKBNrIbHv9dV+BNo5OEilIZXOUAu51+GZtICZxK2zE5oF/iKGZxswqVZMxVzrLPGarcpaEXtn9x2ffSZ48cTzodk7wtlo397Bgen+C+Nw/4UxAsaJv33R8R+fci8TbcdNLoSbYckSf331wGPX1w4/OR1abI5nkhUDVZ1bliyE8drmn2q5eRp/9I0Htp4/vXIQHN5LhkayhbzXarYQt3laYWryyGXxgubnG8yVxNVfZpXm4yPZRZtduFjhnT0vm3XlwJqwGFEiqI0jPdBfOlwu11Hj+/Mb62tCJnRsG2z2PO/ul8eN+nIFLcUzW6zYv9msSJiigkgkHF4lMexG4kurawLXEYI3EkvNjUm57fi4d3o0t7R1o8D18w6H4ybgNjfc2Ca3Ntf/RLLys4Ieu5kZSUfDgj/WNVwkVJgI9QMKjZ8ePnHq9212e6fOo5sqvN6bR06duTaRiJ87iMXG4vGDtUwmE7PgOLc7HV63y93gdLl6UAA9oQH2af8QN+zg9ubnFubnXgAxQNNTdoieXQ14CL09WlraXmLAulgI7e99K1f0VuFZ8YUeO6A+z45S+Gvkue9kQZ0H/ewzlwFSKBd06e+vQEgCu07JSid2/LG/zS0vLT4RjURWOrp6fgnXlLOgPlZ0741j6WIkHPo6Ct734XiU2Z31lEdq44n1iuItkSLQL1Io5rAeIQTXrXqVtxZ5Q0R5rHkSNi3gbyRjiLm9o3O4obH5TovF0sLWAcf2HK7RH1leWrgI4jnIgjUtwAEgbjN2bGRBbBig43h66uLXTp0+24HAc+gSx0OxErjfHBzEvjk7PfmVeDxOvOuMWPl/YqCfU/jxbcZ70CiUfTjWYHz0wmeGR079Hu4vRjwgSGhEU21d/Zvx+O+4BycI8S5RPpNIP4vZ7DVbLD5QAnHVpsb7Pxfc3vr7xYU5mbFfzVtLxAnBu/gDlI/vMg+WqqqaE0baNRaLPp5MJuX+17L286E9cmHBv0iRXgK+JDxy8uL4/x45eeZ37Qayl5Di9VaePTFy2jI+fuErKKMY9eSRlQ9HWcO0xu/lxPEbDTMqW5sIh1RPb//LagK1v4jyQrVgrBVQ1vj25MQYycIieyDpsfYfk/j9JyjHwJ8plwLitX7/lje/ufD2t179euvUWWthUCgAZiKrjSYT2EisPslJTy4aDEVQ+LEQKjmos/sJ4Y5WbC8PsmQtaFn8l+jv62oHn8DjmdHQQs8zOxOvCyZD19itdlIfkxkkDj2sR77IAEdygipd0XI56PO27gqemRj4Ta+oP3svvr+XpHO6GFpuXThYb9mJh5qy+ZwFN9p0k6v6yduaz5yDDAXBmgRb0nOqWZTYBS7nzDoL/397Xx7kVnLe13i4BjPA3PcMOQev4VDcQ9KakdayVLJja+1EluNySnElf8h2lcslu1w5/M9aVaYqa+ZStlKW5USyE6mikg/tSvJK8rE61lqvspJWy2NJLsk5OZz7BgbADO6HdL9Bg/0a3f0aGGCIIb9f1ePDgMDDe318/f2+q7Mo41SBWNSHrFIuMtzYBLvH4/H7fP4OVAawwL6Flcq3kd1baglvvFDKKotLx1uZc8i6VqHOAeuNtBU9w8rBBiYPEa/X61goCH+mdWz8HR+5dfM6CUtnC97RNqTKgenz+91DQyNPtba1P4O/dx5xuedEOd3b3f387Vs3v5hOpxLIrmTzHjZR9WGnSA5ZYbti22Cl2Lxx49pz4+fOEy8gF4UgGDAul7+xsekCObh+0iFu+VwuOxkJhz+PFfxXC55FGdl3yr1WPbvM6FU0+GBFIxMMhS443TC+36W5u7NkXhdrU6BSBbKquf1cAVUWPGm31VBg25k7eM9HVZQhzuvPymZK/hEqva/iHAyHt2fDl9/4w/6BwbPdPX3PEAMAHl+O25Oh/Siee8lk4odbmxvfXlpcmCzUCpEVwNQxIDmFq8vaNs9cr0iOM+m0VvqQ1+drQ/YtynyotHYInz4k8/jzhMH6DCYh/rPj5/91U7DpV/FXWZ3MxG34lYnbt/6I2ybUKSVCt81czOf40HVRhXiUzWZMLA//+/g7zv8evu0xnTa0/WieiLTdlxfm7/3l9tbmChKTfVlo/4Py9FsQRNGIPM4iQx/pR/Pm9av/efwdj308EGh8Eukb0rAoNJrIUebtmul0+vXNjfUvYcJ/DZXOPRXh5w2lrKwTGbVsJBLLiVCgsfG4xj3msO5BZLcowkOmc/Bn2gci8l+ypWEqmXRNTd7+3NjZd/xb977xxBF4HXr8sceeDBA9APfjFhKTfbqVNa2bIipw6xTlKYOM+Mt2GXHy8vP3XWKI7B84dmpgcPBjWC8+iwRjFeuG63hsfWp6auL7SFycVhbaL3KiAek/ZADx10SFRgGznM/XAC6kbx10zewsD7ldblcO8+re9v1tyjciO9ans7ls/lhTDwnl4Sc0v0DLcsBUBY3YECPP+daRK/i4lkCZ0D/OXxndykZ79tJ7IROz/3g2MfZEx/jnsQJBiL9TwaKSAmbkP3KWgWBgEx+X0X1Fd5/MZfJaYYWF35Ap77Yjm8mIFDHEvS4KPknlVlEYl80AgIlhCJN/naJcFOba6vI3UemWg6ocO9u9HgCysMmSquMkzDWZ2Jvyelt0KgSToohnH3/y3b8+Pzf7tY2NdVqHwWrrUKi5pbun90xzS8s7GxoaMJERVpfOZzLp1xYX5v8HVkzmUOlY1yUrMuLLFiYSzU3EfJdUPc9evfzj/0S212vv6PiVQsEmHegqlzlMhH4YjoS/MjM18QOO8LP9oROGLVPU+HsSeRvp9dNYKWswDCfFLJ9dX1v743Q6RTxGh5HbX4SE/LNKMr97A0J2BVpkQOTbpVrKkOh3ZP3BGt8IyU0tLy1ewcd1TPQCPb29p4PB5lFMVnutYm0ul5v0A1YEo1jOrSeTybuY7N+JRMIb3DiSpcXwY0k1j0raRZB2wXv7S0g/OfB9rus0nN/fQFKnKOknoct8Whsl9Xy7qnYKKe5/fnxo5Gxf/8C/x215gukLolivYWJ8aXLi9mtIvt7qyp+SsSQYuyyJZYullcgjTNyzb127cnFsbPxXg6HmDxW2UVWOv0wmM7Ubj30XE/5vx2LRLST2Djp5+espF1gURUOru/Ow7j2VSmXfunr5v50+M/7P29rbf0mw7/nBbyqfj+L14lurq8tflaxdqjnIEzMReF2kxPPd3ds3phOdh+fg21hWkEKGbCFWVQ64TH7ztTVkee7W3zuRyPzs9NRnT5w6/duGYegYMsnWuafPP/7E70xPTX4xvL01h0qJP90alZJ+UfSCyignM8zx7V6ul19G+nkPv/X99o7OvqHhkY8GAo0/iQRh/eS+sDL299OTE38Uje6EkZ3089EkqgKjQPofIID4M7BV6sfHsxcvui5evEj+pNZwIeh38CddF6lyd9F6Iy8zFjz7iT8wLj33SfPZbN64yBFXlcGg8FvFRbtwz4bgO9Y9JVNpdzDY5MJKmfU9WhEeCUjxRipshRP7PW7UFsLcAv/U1PLa/n+b+eRTXWfvFUK/RQtHkfhj8mmFKZMt/PadPzla4MomjOgWdNzfdJs6vCp6oz93/ALdUsVUHDJyIfKkivJsRQW2eA8uLULHKuj0nC88N8k3zmGhSbanI9sgkG2M8o2Bxnw4vJ1DYqXfEnrsjg/Hjg+7FubnRM9Ci89ZWzGSvrTaz0Ru/G03JrM9SJ/skc2Gp7ByQMLXhaQfP4+Z3ffG2wT1e3/y/Y7XloxJ0VZj+YZAwJVJZ/AD7c8VPMZyJNI9nzczhUIxSbzIXMec3bFAEoXf7x88debsx4dGTqxgEr+E28qDycoA2WWMGRMlIGG1eGH/9NTknf/H5dI6hfXLFnUKtu/ZQmAspOG3xGM6cefWV0Oh5leHRkZ/MRgMfRA/U7NuewiAuzZzK7GXeHVlefHbm5sba6h0/Kue2cmLISNoIsJbkiuLicIuvsEJ3GfvFd9+Pr29tfX83dlpQoxobQqZ4Yrtk6opGQrPP0J2o47wAQRn23vVuE9BiDKrJGe536be8aIBBjEFn9Lp1C4mbsRT/gb3HMJwelS6NpQ7loRGJLZdOHnCP4sodcg64vHYsk77YTnS7/X6gliGsOOK9fZXtGVmMBQKnjo19muYUHwY2fUwQhD/dmZ64vkIXjQQcjScOEXbCMeSYOyyHuwsEqMYlYObI33j+rXPtra1vdTXP/g+vMadc3s8vXjxDuTx3DRzZjiTzSwm9vbubG6sX9ne3lrmdojhc8xVuziwfVm83wdBFhyiaOhrUZtZjgW8nqXv3L75Qmtr22vHh0c+0tQUfD9ezx2LTKpADOMknD8ei75yb272HxOJBJumqDN2RPOPQkQ+RaS/SCLxs+lEgpCCrN9B4tQOJ28/4v5mZZeM+NsI88bG2oTb4/7c8MiJ38TrqJYBhuxMcWZs/OOrK8tfn7s78zoSpwDR1FZZnRkdBwELp1pdqlx+UXoRT/atc0trW8fw8Oi/aGxq+hmZIY/UaNlYX3t+ZnryB0hsrBM5DESROjYdGkj/4QOIPweWqF/CAxOT83K+k7/E/sdz8u8Q0m+dMTm6ZP8v5SQo/Faee09qKGjw+4jHuSj4yBZ2SCAMCXbS8WHy12BXByJV8CPxXbRP4N2ozR+6jb9Lq6XLitZZE3w/wtoKw1UVRDEY0l+oSp+n79vCC1GpIicrWsRaSWVh8iz4HH2lIlqoPI+QRGnP7uepk7wnm+KVSiaVHn5uDCGSQ9/R2WXghZG+ZRP4xCiC7lf3d+0XP0AurER0IX3ksRD/e6I0IPH+udlCqHyJccVh9wtqkLKNSUHETLF9iEeb3D8ectnCvRS3KSwc3rXVlbewghkrs9gYCaMdIIfTB3FbrsSi0S9gcv0SJsS00riuh5JXTJ2s+DQMnB177GcQ93+kT6ww41gsmrp5/dqfer3eLx47PvxkqLnlXZicjOE5OqDwvJGdKMJ4/M5hAjO1t7f31trq8rWdSGQbycmajKCpSBrbr6IFnfWIlxg3kL1Akmt5afHTx4eGT+E+Z8c18R5ew/f/J/P35sg2cLR+CJvbLytQVXUFQ8Pzj5CkcKKkz4vXrfI9sm+J2oOXgzRFiyiyfHi6zfiMxHKUjaSSHaLUGG3yKmhPXs7KIoky4e2teWLYc6ohQf6/p7d3bHFh/k10v2Ao7V9+qzX+/koIB9lF4/TY+M+1trT+umu/zsb9TjHNxe2tzf86OXH7+6i8KAlptI2qzRR56wiVrpn82LDq80TC4QQ+5smzkuKy+CBEFBXq74gMQE71HUQpU/UYFiyLohGlzvCGzXQkEk5GroU/0xAI/N/BY8d/IhRsftLn95/Bw6MbyY2F1jXxONnOZbNzqXTqzm48dm15eemtBNkbV2y4rcTgRg9VbrkwbZSkrQQCjU71aIhysb64cO/HSC/K0Clqhe0D1gAji6azgAn8dTxePzs0PKpN/knxxf6BwV9pbmkZm5q88yJud7KGUjlJU4GE+hSyGzWkIe/M2FHl9Ot4+nmyX1K3o629o+vY8aEPY93xZwrFIUVDjmxf/MLknVtfYHL5VVv5HpU5/MgCiL8mKgn1V31H5hGt0j3oFgMpCsPF5EZPKpcNNfh8+/n9ePGeX99Ebo/bmqZtvibiGVYJMVZg8/ciC1GX5WKJ8p0RKg2nl5EsFflHimuWE7osIrFOr7WFHSb91DOs6kdbWzU0BLRC4QkweVpZXFy4guQh/sI2rrKwlhFAfo9xTzKZ3IzuRL7T2tb+S1X8fUvZxmT6L2emJr7ObG9UiYfEkfwyiooLlSqMfLvIUh8sIob7b292Zup7+DXZws8iFM0trW1NTU0tbrfHTwx5pplLpFPpWGQnvJ5OpZJMoUbRvHU6+NBpZbiig4eRzy2m4cVsqGx+eWnhTjwe/ejgsaEPeNye9kw2s40J23WssM1zbcKHDctSdGqibHBRDaLrOxHWkmvVCOy1+bHHjmXSdlRZpIWqdGSzKbgObwxQyVipB6yMdlF5+4thqblcLpFMJuZ0tpvr6Ox6Jyb+19F9hZaOYXaLUDYvmodlWD956sw/ae/o/DU8VUeRbS3Kp7FC/eeTd27/2e5unHprnQh/NcNn2T6k4I2RbHt60X3DEGvId+XzxZ/kx0GlkUQHea6aQBFFw7aX09pmRdKQHWKmJyf+Dr9+mRhOAnhAYjnejdfyNlKzB+1bUjDPz8axCA9Hd3ZWE4m93YIsl8nqrOJvfl6K9Cn2OWRphyIdBHV1957QqeYfje68QrbURGKPP3tvUiOWImqFv0+EJMaUleWlt8yc+cfDoyd+i2w/qTkEXMFg6LHHHn/nCF6Lvjl/7+4beNyzHn8fKq9IpSqygX0GPoJBpEeX1H5CAv26p7dvuK9/4J+RkH6F8TOfSad/vLg4/2ncTjNI7eGX1eOoyzn8qAOIfw3h4Bkti/Q7Xe8AsCbj1Y3Jc6TonWG4UFdbM/K63Wh2Zd0qo5fJZcxzLaOEJPKWPRUJImC9BbzAYouwlIRColJBzS+kKs8qYn5fKfi56xXv3+v1Es+i6necXh/Ui+dkvOG8SS7D59cv7BcJb3/XzOUI0bUV9ENyq/uBIBi7PAEsCfdGnJdxemriK4898a7zPp/v5AFvh/Tt1ehO5Gsz05Pf4/amP0hYvyP5JWeJ9xUhZ4WRL8hTnDNYiXJhUhzFB68EiSJleOVPZLxTETVRyF45Czr/jNQ7zHqSrd/Giu7arZ3rL6LSFB2VB7Fmuf0qaBgAlN+r9b1J8rop2P6gFalFxJ+XqeWON5nxlo/cqkRB5K/Fe6mLdUPIEYtGr+sQ/6am4GlM/oe2NjdmmGtTGawMT8ZrquvEydNPt7a1fxQTudOIMz5nM5kfrawsPb8wf28KicmxjBjLPIZltZsDeeLbVCaj+Qg9Orb4PtCN/Kg06uPQoIiiYSEz4LL7pbOGE2Nvby+Oj3XuGqIxLUqvUbW1kyxXOVDoa5kuUvxsW5tzmD8pmrswP8eH+fPjXESInfqBN1zJnD62tl1bW3k7k808f/LUGbJHvbbzhNQ4GRg89q86OjovzM/PvbS5sX4X2Um/yuuvE/LvpPupnGglZB/fr2doePTd7e0dH8K64jnEFTNmgfWJ+e2tzf+Fda7XuBQdFeEX6Ud1O4cfZQDxryEcPP5VjSCgkBSGK0EhJK+4qKwnwyet1R//1REKoc1YHEX3ElaYv9tlhM+0Dk0LijU5LST091kDAM1vdszDQnZlHyGxIBFZSflnl5F//rrF+8fEULUgyvpA+BmVoNOM/FAtutbh9Xq8+NDK+SZ75y4u3CO50Xx4tLKg4UEENjt2OWWTJ7nUKMRuj2Q9ezqdNu/cuvncmbPj/87vbziP5MYcYd/kstm7iUTiNbzQv7y2unIP2Rcwne35nAh/ueS32CXce7yiTUlYyb7fqJSMsdcXGrWQWAnMSV47hWEX77vM5+Y9/gjZ5QS9Dza8nP8/WWjrAw0trFfFRkH+2bHC7hcuM8oiVBo9JTJaicadau4oDWcOz0XvycnjT4l/cnlp8Ydd3T0f1tgy0hgZPfnL8Xjsf6aSST6fn7aJTZnHynV7/+CxDwaDoWcMw+jl2ovI4HuR8PanJ+7c+geyVSkSGxx1DOy8waTs8cd5sNkxwPYt355OMoj/nszg6CRnKn6uQ4KTIY1vO3anI1kKjWpu6RhwdQy3SlmO5Gur1IFCvEaNTUFHQ9re7u7ru/H4JhKHxFdqtKWfKcehVmxTTHKnb6VS/+XM2XO/5ff7R8u4BmoIBEZPnzn7u/0DgzcWF+a/ha9FItKoAcCJ+MuMHHw/qIi/7LA+09HZ1dfXN/CBYDD4fsz+RdvyFUHSSGLRnS9OTt55KZNOJ5CY8IsMNY5pR+SfOp3DjxyA+NcQOrnQNYTKw004f3GCkqjgPTN1jGyV19q4X+R0cnEFk34DkY81uxuv4s+zQlo24XlFhP4e7yGyBFgo1GzEYlGqYMpCs3hvRPEZBO/rtIUo3L9Sw4Lyt3WEXJmRH1IDRgNefQzDrZWnhhfdH2ECTCqyspZpnjiJ+rJiKMY7q9BQEsh6f22eXlKU6+rlH39iePTE+9ra2n+WbCklyk0j4zWXyy5m0hlM9vdubG5uXN7cWF9E6jxT3dDTA4UkKzz/ogJlLPGnCrcqLQYJriEjYyrFW+aRrXgxF4TI0ufm75tVakWh5Spvl1DxAIVjHxIPL/2brTshCitVRVDJZKcpeY//Dv37IH3FPgtPjijpLxL/vb3dDSxP3sDr0NNOF/b5fN3nH3vyN+fnZr+8vr42jeyykUTyG909vUNYyX68qSn4lNfrJdtglVTFxnJpG//m/8GE/0WSfoOqk4t94DHOGU9ksoifl7wMot/njXsymcMbho6Uh1DDkCYah7wcFxlPdKIdzQoOLeOtICVLheJ9tbW3d3o8nnaHz+dWV5f/FpW5C4tmrQodo7Lw3tG+bpG7fu3yp8jWmsFQ6D1IQZAFMILB0ONjZ8+dx3Ll9trqyqurK8sTjLe8nJ04ELK3uxP5Lzk3N7e09Q0MXmgONb/X6/OdRgrvvvVj+XwUP/8Ls9NTL+zuxqNITvZ1DZJHYg4/qgDi/4BQSY5/mVCSWlJtvkD+s6bH8MVSu81N/kbU09Zsef2nl1atL7mQKz/Q1EUqmIqqlConO3cv7GJiXZpUwWe+r8rHlz1P8UwqwycTCZVwURlCSs4tLa1oZyfCe2JtqIYw04ji0CkMlg81NzstuBTm+vrqK0h/+z7rqLbg1thjXET2LAWeVEbGCxTZ//cfSB5kS2tbF1bMgySKJZvNpkjBHbx47TB5kKotjXhFW1aYRuZhqwZZoWeRss17YFnvkEpZtN0f15+m4qxD9sv2ykqeme179v9YRVk0FvjPKBUPUDrskBieCFg5TMcj+55O2pSTEVWk3FZTOeRJEj//6ZZbVrj1vbuzXzt3/rF3Yd7uWFmdbGF48vTY7xwfHl3CpJ3scBM33Abm+N5Or9c3YhjCrUH3byqfj2NC8OezM1NfikWjUVQ9wl+1tpOEr4vmnSgtTyV/eFniGDVVzeeqJRQ7e4gMAGwEk8xDy88x2XySRdSoZLuWLOcMtDx4cl2cY51dPWPIgSzjeUNIMdkWuqophlw/0DGa4z4makObYSaTyeRuXL/6Z6MnTk139/T8Sx25wMFobGw6NzJ6cnzw2NBGdCfyJn7ey5FIeBU5h8XreP3pueTo7Ozq7+zueSIYDD3lu0/2lf2BKcDObjz+1buzMy/GYtEIEhN9WTHvmkQgAWoPIP4MnEhYcas/5jMqAk8+f3F/S8Di52VVz3Xu7QCPJhJ4RYVoZmex2ef2WRbBRr8fzS6vIROzf0KkzHw29k+H3/NDTLdUQjqPhR3Cio2UEDAKhaVQFraso9sGlQg2EZEvvMeH01mQkH5XfDfhDjYFcsgZNjKNSb/tPfZ56DjRTdfAn3Pjzwnvwen7WIC70tZOUsxDFaw2iFmwcPtrEX98rbt4IZpA+xb3NL5Ulgk1Feap1hotLa0u3N6sJ7A41g3DjUwzZyP+iClyh4m+e2tzI4JKjQS8R1hHyZYVplEpqBUvbA6ef17RZkOKZaTfKZXFyRvrpIhX5ZkVueb8vahCiFUGC5kBEsBA4f1HSDy2dIg/f5a9Lp5rQFr5dY7KDXbfbXIY0ejO0sb6+l909/R+TPOnXFgmD5JD58OE8Cf29l6YuzvzJaz8s9vzlUv4DxxxU0Y7iuanyBjEe/oR8zm+L3SOmjxTrSGQ47SdRHKcl+eiFEe2PYttgpxluMpoW4kslxmj+SgGixwGg8Fxh6Yi2xp/Hdm3X61aiqGE/Kv0bJGcsPShmenJb4W3tyZGTpz6mN/vr6SmkMvr9XZ3dHb9PD6eyaTTK7u7u7exnnNna3N9NplMxpGa+POyEjF9QXRAEsLf39rWPtrU1DTW0BAYd7vdXciB6FOYprkaj0W/Ojsz/XWst8eQ2DlCo3udUhTAy3/EAMSfQSWh+SoC/+UXXjAuPffJnM6WgAe5NwV4QV8UcIV8fdL/6bnwcoPP40U5M4/aW0Po7blFi/QTCRJyN77izpjEQyHz+FvXxcKjOPlFE56rbk62rGNDsHjLJiHyJQJMQO6d2iSPST/fPy6Ha9j+Fj0LY7zR6hMZ6dcBJuoyJcpGbv3+hjad62FF93vo/qKbYkLRZNb2mnlMqbJeiKygCiVCjKWeI/1UgecLI6k8wrwBwIno8zl3NVe4FVvCUcVL5n0th/iz13RSCKtO+DWelyUXrNLm5Ek8lD56WKHw/vNGAPbMv6afV70uUWRr2Dd0TNA5QwvJUo+/jXBNT0283BAI9DU3t3yoajdgmuHdvd0X792d/TKWb2GkV6W/FrVEyobCIMQbgUykNgbpGIAemvkqiJhgn5FNo1HVNFIRN5Ws1jWqVDL/RL9pI/0+nw/5fP7Tqovkcrm1ubuzZBca2RbCBy4oLKhXIbt/XkcoiQ7a3t6ajkTCfzh64tRPd3Z1f6QQ0VMJXF6fr7+VHG1tHxwaHslns5kNrNut4GM1nUptpdOpSCaTiZFCw2YuRwpM5UkxPgyf1+tr9Pl9zT6vvwO3c5fX5+3zeLwDhRTHsuoc4d+4ieXRX5MdgbKZDJtqpJP6KHKKsDKq2NZHeR4/CgDi/5BBEKYlEnTsRHcnc8nCwp5HG9sRlEilLY9/NpcxL/SNvYTs1lkZSdSe6LwRgLtXPsRNhkoFi+P36kxolSxahT2S+YXXkfjj7yVXlhbpwisqPCPzLGmjkqKV3O/k0X3iLzJy2CohI7lX2BR8V0TyVTmQwrB+ghqlPrAeIt6QISP6Tl5Ytn11FfCakzSFsYMPNadwCn3l773e5nFdQ2EAIGANUCxUslpoCDiEPmHvlU0X4XeRYeeOefP6tf89fu58rLWt/ZeRQz6s6rcxuVmIx2Mvzk5PfSOR2FNtzcenFVW9lshBIBkPvCESIbkxSMv4c1jPc1hQyHE+bUmWQqMrxxGSy79ayHKhdxwVIvD8DQ3EWaQKi8/jefG1XC5L5gRP/GW6ZEVOB0G9ChopJ3LylDhREKMfm6aZmZ6a+JvlpcUfjJw4+eHm5pYPyPe714LVx5i495CDRMpy9yP7TsUg+fuJROKVjfXVby4tLkwisUxSFRUtazeIh2UuP8wA4v9wgl2gRcKNrZru6mns2LgdW8j7PF7Xm9N3LW+/gY+gr/H1C+3nbiB7PpaMJFq/W0lFYfq6nG2w+N+pkHAeFcgs7cWF1+P1Oob6p1LJa7FYdA0x+f2GYWS5PYGFwlwX5faBgADyCzX73HSbMZ3CUjyBr7S41KEtaoLt4HhFW+aB5RUD0TzSUcQP0yuryo+VEQut+wfFo3I4GGUJZORO+t5h7qYgKfLFykyZkTB76+0bX+rvH7zSPzj4b3w+/1mkqXCTqCmMH+1Ewt+YnZn6AZanKaRWrMsJ6T8UL3+ZbVpO8Te2nUteP4xzVSHHESqVbU6ynIeu7K424Rc5j4pbfe7G41vZbHbS4/GcEV0E/9/EzNTkC/glqRTPh/lXPc1QQv5FKWVK4l840nt7u+m3b7z1hVCo+W+OD488g88/hXWnpjJuSQcHIvgsiEzKpNNvRqM73743N/t6KpXa455NJpdEOfyqKEjang/lXH5YUbWB9qjCYcu+WhfwE95DYcFhc8ioh5QWNfKxRzqPWj5z56/+2uVyd5DUcUL6cygXf1/PE7/xVNuZm0i+L2lJXhZM/oOj0H+U0PL95ncZRmPeNEkFf7LwNLnd7uZ3/8R7PoPP3YrL5tdWV/7jzPQkKey3iw+yEJBFmN/Sz7YAH1Z/MlEqssq1sq3FeOVJFdYnW7ycwiMfyKLGRe44edh0FUb2dV0o45LndHqmQzVSAO5DVvirHtqfkyOsvGBz+9n1j3gp/YXX5EzkrLenp2+0s6v7QkNDw2m3x9ODlfxml8vlIbuF5PNmLJfNrWUymdnd3fiN5aXFy1yerCo/ttxaIgjVkWIt6XudeVpEPTzHYaIMOa6rj9dcljP3zM4hVhcp6iP0GBg8dnrw2NAlrIcMM5fKYdL5nempiU/tRMLsFn58YWFhqP9Bx4pAr+D1CBpByD8X+3w+/vD7G0LHh4afbmlt+ymfzzdaRt/VDFg27abTqSvxWOz7i4vzZMtEWkRUtu2tTjh/3RkjAQfHAx+s9YRqe40flBeaIf48+aeKj5c7PLfSy0+/vnD1Fyxnfw4tPT345MtnAv2k+iq/j6eM9FsGDhACBwdnuKFGG9pXZCEiymqgcDRihbTpqQvv/ROPxzMkuyaxxl95842PZ7MZshgk0H3LO2vQeaCGHAn5lxkCnPIinUi9U6h4XS1qCnIs+lsEVQRAXTxnGaSi7u4dUD/g1j9ejrJrIFXk+dd8OhGFyDso8qKpCvepIo/qlvBrtHcJ6v2+DxuCdqpEjhMciix3cCBRAxo7dzyGYfj6+geGSc0hEjka3t66u729RQh/hjlEaYYlHv8qPwdtX5EBgD4TbwDgjQDsuag7t3d0DnT39F4IBoNP7hsBXIcUSZ1PZzLZmVQyeS0a3bm8tDh/PZPJpFB1ihrXtLAx4MECiH8BOhX9uWr+jpXdRf9Xi9/hofB68FWNbRWO0X0lpxj+iOypAVlMLk2Xy8hlMumScP9aCgHRjgrltGu1fqcGz1USFSJZcK0FyTDc/nQ61UCKvqD7BoCGJ9757v/Q2Nj0C6LfyJtmZG5u9ndXlpeIISfJHKKdGqw+PXZ8GJ0YHZZFq5SEeOq0v85nuLFLz6qD/aztsQVnnRzII61s66Len0/1jEfh3gEPFhLjtyj6zSt4TUkAn0rEp1vx4cGi1zpetEOrJQKoHxxUhlPUaowoHEi8AY0988YyvjAvX0ROWN+i2s/kEFFI75l/NpmM4N8rGgoDgUCwu6dvPBgKnW5oaBj1erzHDLe7FR08Tz+Zy+WWMLGfS6WS0/FYbGJ1dflOOpVKoFJDpEwO6ZD9IxN9BKgcQPw1cdRyyKnQbmlpNXZ2IjLB7UZ2zwar4PC5kSKhYVNaHqQwOGr9o4JgwWX7TBSm6u/u6R05cfL051wuV4i9Vi6bnZifv/fJleXFacRU80f2mg3CAjsPqj8VoZGyIkgyOXZYeZAAAKCO4BDiy657rJLPr4uqwqGioqEihbqssFlUB2spAECgcCDxTiR23rAOJAKRHimLginOhVqMf0VEocoAIDJy8K9FcoPuNmQ0NjYFW1pbewOBxm6f39/ucXua3W530GW4fC6XQfQ4l8vi9vm0mTcTpmnu5bK5nUw2E04lE2uY5K9GIuEN/L5MtsgIvS7RB8L/iAGIvyaOGrEUCG2e/LMCjldwZJ4NfquhmgrqcnDU+kcFyYIrC1OlOWje40Mj4339A7/vdhtDmUz2Wiwa/cbU5O3v5nI5lujztRrY6tKHntuv2Q60Ldgz/1oFZU5kPTwrAACoLiTknzWm8kYAkeIuIv58UTDZLiHlhM2CYg2oO0jSZkQGNHZOsfNFZSQTGsNqPQc06wmJ5IIHiQ0CKvnBXpf+Jg+RTOCLD4uOXJlnkEsAC0D8NVEJsax24b9y70EgtIuCzev1ujOZjChfmkCl3Agtgg9aMDxMxJ9gZnbOWJifIy95r78oD40e/MLL7+LAHqJQO9viWy9tWmFuZN3ntAMAgNrCIb+X9fLxRnF2beQhU8759dKpiCi9FsgjQF1CIz9eVHRXFCHDO5KktS0OYy441BMSPZdb42Dlh6hNVNs1Vkr+dYyO5ZB9cIw8AgDir4l6IUHlQCO0SVQZnUIkfKpa1VPWptU2stQzZPetsLTL6jSIilGJtqjhw+1KDDq1EPTV7J9KciNh8QIAHk1orIO8t48n/bK1UaSkOynVoFgDjhQ0POQqBxI96+yqc6hzQaOekMrA4ZacVTsPieoS8dGIKvIvMgKonHO6RB/k0iMGIP6aOKpkVKNSeiVV0en/H0g4PPuJvHHpuepsd1gPbV3N+9bYhsapTgMBa2WX5XyV7J0LAh8AADxMcFDyRcp5JR46VQFRUKwBRxZl6JEiIxk9K4tZ1kFNIR0DoSH5W0b4RVsOs2e2jfh2cjIsOp3L8eyD7vcIAYg/B1rVnUWhqr40NF/0Hfo91e/Qav2632NJIv89VUrBwvw9tDA/l+/o7LK8wdlMxrWzEyEvpVXRGwIBl+Ey8oZhWNd1u915j9eb39rcUArqcp7n2U/8gXHx4kXh/6naQNamOt9hd0jQSbdgq/w7GRfY52H7yWkc8PdG/379+6/Slzby7/P53Pl83iBHNpu13sP9YxH/XC7HXr64EJDdGPBnc17chy6Xy3QZhuk23Cb+28RjQVmgUTTudJ+pnP4RzYejaMwBAAD1B0HNEBWZQUi+PoqUZieiD4QfcKQhIP/sa525IntdF3NCc0chUbSsU/SDyCiiK1NUh6n5nlMf1EX7Aw4PQPw1cVQ9/hS80tPR2eXCJL74t+RrB7YKVlLLoBLUU1tX896YkH9UOBsNgYCRTCRkoal8CJkq7Mtmedft18PqUwAAAKg2NHcNYc8y5DXPoFgDHgpIyDESvOZxJDzMDrJBVDC7nMOpjWTt5BRJpBNxJLp23bU/4HAAxJ9BtcljPRIkiWBzgqOgqGfi/aBBIgEuPffJisaBwgrNLzyiqrHa1mDYihEAADxKUKyFOmtkXvK37X1QrAEPGxyK7co82SV/1/vcUBg5nKKFDmJMZNtIJ1pCl+QfmXYH1B5A/B9BQHG0w8VBia1GCJr1XjAYcsfjMd7A4GgJLrdvgagDAICHBZL1sGyjOAWslYBHAQo9UlS4roijNj8cthXWIfky0i/L8+f/1o0sArIP0AIQf4BQgIOgqC+UEZ7KQ7koQD8DAACAHbrGcZCfAMB9sPPmYZsbikgHl+Z7yOE9Ah0DgNbrh639AdUDEH8A4AjBwfosQ8nCAIsCAAAAAAAAQPkoM+WhUq6lawiwAHodQAdA/AGAIwiHRYcFLA4AAAAAAAAANcIBU4ZUeChSJgD1AyD+AMARhk5IKiwQAAAAAAAAAIeLSmpqUYDuBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDL8f9DwCoJpoZhyAAAAAElFTkSuQmCC" alt="Hemlock Logo" class="header-logo">
        <h1>Manuel du Langage Hemlock</h1>
        <!-- Search -->
        <div class="search-container" id="searchContainer">
            <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
            <input type="text" class="search-input" id="searchInput" placeholder="Search docs..." autocomplete="off" aria-label="Search documentation">
            <span class="search-shortcut">Ctrl+K</span>
            <div class="search-results" id="searchResults" role="listbox" aria-label="Search results"></div>
        </div>
        <button class="search-toggle" id="searchToggle" aria-label="Toggle search">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
        </button>
        <select class="lang-switcher" id="langSwitcher" onchange="switchLanguage(this.value)" aria-label="Select language">
            <option value="docs.html" >English</option>
<option value="docs-zh.html" ></option>
<option value="docs-de.html" >Deutsch</option>
<option value="docs-es.html" >Espaol</option>
<option value="docs-fr.html" selected>Franais</option>
<option value="docs-it.html" >Italiano</option>
<option value="docs-ja.html" ></option>
<option value="docs-pt.html" >Portugus</option>
<option value="docs-ru.html" ></option>
        </select>
        <button class="theme-toggle" id="themeToggle" title="Toggle dark mode" aria-label="Toggle dark mode">
            <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
            <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
        </button>
    </div>

    <!-- Container -->
    <div class="container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar" id="sidebar" aria-label="Documentation navigation">
            <div class="nav-section">
<a href="#welcome" class="nav-link" data-page="welcome">Bienvenue</a>
</div>
<a href="#language-reference" class="nav-link" data-page="language-reference">Rfrence du Langage</a>
<div class="nav-section">
<div class="nav-section-title">Prise En Main</div>
<a href="#getting-started-quick-start" class="nav-link" data-page="getting-started-quick-start">Dmarrage Rapide</a>
<a href="#getting-started-installation" class="nav-link" data-page="getting-started-installation">Installation</a>
<a href="#getting-started-learning-paths" class="nav-link" data-page="getting-started-learning-paths">Parcours d'Apprentissage</a>
<a href="#getting-started-tutorial" class="nav-link" data-page="getting-started-tutorial">Tutoriel</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Guide Du Langage</div>
<a href="#language-guide-strings" class="nav-link" data-page="language-guide-strings">Chanes de Caractres</a>
<a href="#language-guide-pattern-matching" class="nav-link" data-page="language-guide-pattern-matching">Filtrage par Motif</a>
<a href="#language-guide-control-flow" class="nav-link" data-page="language-guide-control-flow">Flux de Contrle</a>
<a href="#language-guide-functions" class="nav-link" data-page="language-guide-functions">Fonctions</a>
<a href="#language-guide-memory" class="nav-link" data-page="language-guide-memory">Gestion de la Mmoire</a>
<a href="#language-guide-error-handling" class="nav-link" data-page="language-guide-error-handling">Gestion des Erreurs</a>
<a href="#language-guide-modules" class="nav-link" data-page="language-guide-modules">Modules</a>
<a href="#language-guide-objects" class="nav-link" data-page="language-guide-objects">Objets</a>
<a href="#language-guide-runes" class="nav-link" data-page="language-guide-runes">Runes</a>
<a href="#language-guide-syntax" class="nav-link" data-page="language-guide-syntax">Syntaxe</a>
<a href="#language-guide-arrays" class="nav-link" data-page="language-guide-arrays">Tableaux</a>
<a href="#language-guide-types" class="nav-link" data-page="language-guide-types">Types</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Sujets Avancs</div>
<a href="#advanced-command-line-args" class="nav-link" data-page="advanced-command-line-args">Arguments en Ligne de Commande</a>
<a href="#advanced-async-concurrency" class="nav-link" data-page="advanced-async-concurrency">Asynchronisme et Concurrence</a>
<a href="#advanced-bundling-packaging" class="nav-link" data-page="advanced-bundling-packaging">Empaquetage et Distribution</a>
<a href="#advanced-command-execution" class="nav-link" data-page="advanced-command-execution">Excution de Commandes</a>
<a href="#advanced-ffi" class="nav-link" data-page="advanced-ffi">FFI</a>
<a href="#advanced-file-io" class="nav-link" data-page="advanced-file-io">File IO</a>
<a href="#advanced-memory-ownership" class="nav-link" data-page="advanced-memory-ownership">Memory Ownership</a>
<a href="#advanced-atomics" class="nav-link" data-page="advanced-atomics">Oprations Atomiques</a>
<a href="#advanced-profiling" class="nav-link" data-page="advanced-profiling">Profilage</a>
<a href="#advanced-signals" class="nav-link" data-page="advanced-signals">Signaux</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Rfrence API</div>
<a href="#reference-memory-api" class="nav-link" data-page="reference-memory-api">API Mmoire</a>
<a href="#reference-concurrency-api" class="nav-link" data-page="reference-concurrency-api">API de Concurrence</a>
<a href="#reference-string-api" class="nav-link" data-page="reference-string-api">API des Chanes</a>
<a href="#reference-file-api" class="nav-link" data-page="reference-file-api">API des Fichiers</a>
<a href="#reference-array-api" class="nav-link" data-page="reference-array-api">API des Tableaux</a>
<a href="#reference-builtins" class="nav-link" data-page="reference-builtins">Fonctions Intgres</a>
<a href="#reference-operators" class="nav-link" data-page="reference-operators">Oprateurs</a>
<a href="#reference-type-system" class="nav-link" data-page="reference-type-system">Systme de Types</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Conception Et Philosophie</div>
<a href="#design-implementation" class="nav-link" data-page="design-implementation">Implmentation</a>
<a href="#design-philosophy" class="nav-link" data-page="design-philosophy">Philosophie</a>
<a href="#design-signature-syntax" class="nav-link" data-page="design-signature-syntax">Syntaxe des Signatures</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Contribuer</div>
<a href="#contributing-guidelines" class="nav-link" data-page="contributing-guidelines">Directives</a>
<a href="#contributing-testing" class="nav-link" data-page="contributing-testing">Tests</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM : Prise En Main</div>
<a href="#hpm-project-setup" class="nav-link" data-page="hpm-project-setup">Configuration du Projet</a>
<a href="#hpm-quick-start" class="nav-link" data-page="hpm-quick-start">Dmarrage Rapide</a>
<a href="#hpm-installation" class="nav-link" data-page="hpm-installation">Installation</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM : Guide Utilisateur</div>
<a href="#hpm-commands" class="nav-link" data-page="hpm-commands">Commandes</a>
<a href="#hpm-configuration" class="nav-link" data-page="hpm-configuration">Configuration</a>
<a href="#hpm-troubleshooting" class="nav-link" data-page="hpm-troubleshooting">Dpannage</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM : Dveloppement De Paquets</div>
<a href="#hpm-creating-packages" class="nav-link" data-page="hpm-creating-packages">Cration de Paquets</a>
<a href="#hpm-versioning" class="nav-link" data-page="hpm-versioning">Gestion des Versions</a>
<a href="#hpm-package-spec" class="nav-link" data-page="hpm-package-spec">Spcification des Paquets</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM : Rfrence</div>
<a href="#hpm-architecture" class="nav-link" data-page="hpm-architecture">Architecture</a>
<a href="#hpm-exit-codes" class="nav-link" data-page="hpm-exit-codes">Codes de Sortie</a>
</div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <div class="content" id="content"></div>
        </main>
    </div>

    <script>
        // Embedded documentation pages
        const PAGES = {"Bienvenue": {"id": "welcome", "content": "# Bienvenue dans Hemlock\n\n> \"Un petit langage non scuris pour crire des choses non scurises en toute scurit.\"\n\n**Hemlock** est un langage de script systme qui combine la puissance du C avec l'ergonomie des langages de script modernes. Il propose une gestion manuelle de la mmoire, un contrle explicite et une concurrence asynchrone structure intgre.\n\n## Qu'est-ce que Hemlock ?\n\nHemlock est conu pour les programmeurs qui veulent :\n\n- **Un contrle explicite** sur la mmoire et l'excution\n- **Une syntaxe similaire au C** avec des commodits modernes\n- **Aucun comportement cach** ni magie\n- **Une vraie concurrence asynchrone parallle** avec une concurrence base sur pthread\n\nHemlock N'EST PAS un langage  mmoire scurise avec ramasse-miettes. Au lieu de cela, il vous donne les outils pour tre en scurit (`buffer`, annotations de type, vrification des limites) sans vous forcer  les utiliser (`ptr`, mmoire manuelle, oprations non scurises).\n\n## Exemple Rapide\n\n```hemlock\n// Bonjour, Hemlock !\nfn greet(name: string): string {\n    return `Bonjour, ${name} !`;\n}\n\nlet message = greet(\"Monde\");\nprint(message);\n\n// Gestion manuelle de la mmoire\nlet buf = buffer(64);\nbuf[0] = 72;  // 'H'\nbuf[1] = 105; // 'i'\nprint(buf);\nfree(buf);\n```\n\n## Fonctionnalits en un Coup d'il\n\n| Fonctionnalit | Description |\n|----------------|-------------|\n| **Systme de Types** | i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object |\n| **Mmoire** | Gestion manuelle avec `alloc()`, `buffer()`, `free()` |\n| **Async** | `async`/`await` intgr avec vrai paralllisme pthread |\n| **FFI** | Appeler des fonctions C directement depuis des bibliothques partages |\n| **Bibliothque Standard** | 40 modules incluant crypto, http, sqlite, json, et plus |\n\n## Prise en Main\n\nPrt  vous lancer ? Voici comment commencer :\n\n1. **[Installation](#getting-started-installation)** - Tlcharger et configurer Hemlock\n2. **[Dmarrage Rapide](#getting-started-quick-start)** - crire votre premier programme en quelques minutes\n3. **[Tutoriel](#getting-started-tutorial)** - Apprendre Hemlock tape par tape\n\n## Sections de la Documentation\n\n- **Prise en Main** - Installation, guide de dmarrage rapide et tutoriels\n- **Guide du Langage** - Plonge approfondie dans la syntaxe, les types, les fonctions, et plus\n- **Sujets Avancs** - Programmation asynchrone, FFI, signaux et atomiques\n- **Rfrence API** - Rfrence complte pour les fonctions intgres et la bibliothque standard\n- **Conception et Philosophie** - Comprendre pourquoi Hemlock est ce qu'il est\n\n## Gestionnaire de Paquets\n\nHemlock est livr avec **hpm**, un gestionnaire de paquets pour grer les dpendances :\n\n```bash\nhpm init mon-projet\nhpm add un-paquet\nhpm run\n```\n\nConsultez les sections de documentation hpm pour plus de dtails.\n\n---\n\nUtilisez la navigation  gauche pour explorer la documentation, ou utilisez la barre de recherche pour trouver des sujets spcifiques.\n"}, "Rfrence du Langage": {"id": "language-reference", "content": "# Philosophie de conception du langage Hemlock\n\n> \"Un petit langage non securise pour ecrire des choses non securisees en toute securite.\"\n\nCe document fournit un apercu de la philosophie de conception de Hemlock et une reference rapide du langage.\nExplorez les autres sections de documentation pour des guides detailles et des references API.\n\n---\n\n## Identite fondamentale\n\nHemlock est un **langage de script systeme** avec gestion manuelle de la memoire et controle explicite :\n- La puissance du C avec l'ergonomie des langages de script modernes\n- Concurrence asynchrone structuree integree\n- Aucun comportement cache ni magie\n\n**Hemlock N'EST PAS :** Un langage securise en memoire, un langage avec ramasse-miettes (GC), ni un langage qui cache la complexite.\n**Hemlock EST :** Explicite plutot qu'implicite, educatif, une \"couche de script C\" pour le travail systeme.\n\n---\n\n## Principes de conception\n\n### 1. Explicite plutot qu'implicite\n- Points-virgules obligatoires (pas d'ASI)\n- Gestion manuelle de la memoire (alloc/free)\n- Annotations de type optionnelles mais verifiees a l'execution\n\n### 2. Dynamique par defaut, type par choix\n- Chaque valeur possede une etiquette de type a l'execution\n- Les litteraux inferent les types : `42` -> i32, `5000000000` -> i64, `3.14` -> f64\n- Les annotations de type optionnelles imposent des verifications a l'execution\n\n### 3. Non securise est une fonctionnalite\n- Arithmetique de pointeurs autorisee (responsabilite de l'utilisateur)\n- Pas de verification des limites sur les `ptr` bruts (utilisez `buffer` pour la securite)\n- Les double-free peuvent provoquer des plantages\n\n### 4. Concurrence structuree de premiere classe\n- `async`/`await` integres avec parallelisme base sur pthread\n- Canaux (channels) pour la communication\n- `spawn`/`join`/`detach` pour la gestion des taches\n\n### 5. Syntaxe proche du C\n- Blocs `{}` toujours requis\n- Commentaires : `// ligne` et `/* bloc */`\n- Operateurs identiques au C : `+`, `-`, `*`, `%`, `&&`, `||`, `!`, `&`, `|`, `^`, `<<`, `>>`\n- Increment/decrement : `++x`, `x++`, `--x`, `x--` (prefixe et postfixe)\n- Affectation composee : `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`\n- `/` retourne toujours un flottant (utilisez `divi()` pour la division entiere)\n- Syntaxe de type : `let x: type = valeur;`\n\n---\n\n## Reference rapide\n\n### Types\n```\nSignes:     i8, i16, i32, i64\nNon signes: u8, u16, u32, u64\nFlottants:  f32, f64\nAutres:     bool, string, rune, array, ptr, buffer, null, object, file, task, channel\nAlias:      integer (i32), number (f64), byte (u8)\n```\n\n**Promotion de type :** i8 -> i16 -> i32 -> i64 -> f32 -> f64 (les flottants gagnent toujours, mais i64/u64 + f32 -> f64 pour preserver la precision)\n\n### Litteraux\n```hemlock\nlet x = 42;              // i32\nlet big = 5000000000;    // i64 (> max i32)\nlet hex = 0xDEADBEEF;    // litteral hexadecimal\nlet bin = 0b1010;        // litteral binaire\nlet oct = 0o777;         // litteral octal\nlet sep = 1_000_000;     // separateurs numeriques autorises\nlet pi = 3.14;           // f64\nlet half = .5;           // f64 (sans zero initial)\nlet s = \"hello\";         // string (chaine)\nlet esc = \"\\x41\\u{1F600}\"; // echappements hex et unicode\nlet ch = 'A';            // rune\nlet emoji = '';        // rune (Unicode)\nlet arr = [1, 2, 3];     // array (tableau)\nlet obj = { x: 10 };     // object (objet)\n```\n\n### Conversion de type\n```hemlock\n// Fonctions constructeurs de type - analysent les chaines vers les types\nlet n = i32(\"42\");       // Analyse une chaine vers i32\nlet f = f64(\"3.14\");     // Analyse une chaine vers f64\nlet b = bool(\"true\");    // Analyse une chaine vers bool (\"true\" ou \"false\")\n\n// Tous les types numeriques sont supportes\nlet a = i8(\"-128\");      // i8, i16, i32, i64\nlet c = u8(\"255\");       // u8, u16, u32, u64\nlet d = f32(\"1.5\");      // f32, f64\n\n// Nombres hexadecimaux et negatifs\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\n\n// Les alias de type fonctionnent aussi\nlet x = integer(\"100\");  // Equivalent a i32(\"100\")\nlet y = number(\"1.5\");   // Equivalent a f64(\"1.5\")\nlet z = byte(\"200\");     // Equivalent a u8(\"200\")\n\n// Convertir entre types numeriques\nlet big = i64(42);       // i32 vers i64\nlet truncated = i32(3.99); // f64 vers i32 (tronque a 3)\n\n// Les annotations de type valident les types (mais n'analysent pas les chaines)\nlet f: f64 = 100;        // i32 vers f64 via annotation (coercition numerique OK)\n// let n: i32 = \"42\";    // ERREUR - utilisez i32(\"42\") pour l'analyse de chaine\n```\n\n### Introspection\n```hemlock\ntypeof(42);              // \"i32\"\ntypeof(\"hello\");         // \"string\"\ntypeof([1, 2, 3]);       // \"array\"\ntypeof(null);            // \"null\"\nlen(\"hello\");            // 5 (longueur de la chaine en octets)\nlen([1, 2, 3]);          // 3 (longueur du tableau)\n```\n\n### Memoire\n```hemlock\nlet p = alloc(64);       // pointeur brut\nlet b = buffer(64);      // tampon securise (verification des limites)\nmemset(p, 0, 64);\nmemcpy(dest, src, 64);\nfree(p);                 // nettoyage manuel requis\n```\n\n### Flux de controle\n```hemlock\nif (x > 0) { } else if (x < 0) { } else { }\nwhile (cond) { break; continue; }\nfor (let i = 0; i < 10; i++) { }\nfor (item in array) { }\nloop { if (done) { break; } }   // boucle infinie (plus propre que while(true))\nswitch (x) { case 1: break; default: break; }  // style C avec fall-through\ndefer cleanup();         // s'execute quand la fonction retourne\n\n// Etiquettes de boucle pour break/continue cibles dans les boucles imbriquees\nouter: while (cond) {\n    inner: for (let i = 0; i < 10; i++) {\n        if (i == 5) { break outer; }     // sort de la boucle externe\n        if (i == 3) { continue outer; }  // continue la boucle externe\n    }\n}\n```\n\n### Pattern matching (Filtrage par motif)\n```hemlock\n// Expression match - retourne une valeur\nlet result = match (value) {\n    0 => \"zero\",                    // Motif litteral\n    1 | 2 | 3 => \"petit\",           // Motif OU\n    n if n < 10 => \"moyen\",         // Expression de garde\n    n => \"grand: \" + n              // Liaison de variable\n};\n\n// Motifs de type\nmatch (val) {\n    n: i32 => \"entier\",\n    s: string => \"chaine\",\n    _ => \"autre\"                    // Joker (Wildcard)\n}\n\n// Destructuration d'objet\nmatch (point) {\n    { x: 0, y: 0 } => \"origine\",\n    { x, y } => \"a \" + x + \",\" + y\n}\n\n// Destructuration de tableau avec reste\nmatch (arr) {\n    [] => \"vide\",\n    [first, ...rest] => \"tete: \" + first,\n    _ => \"autre\"\n}\n\n// Motifs imbriques\nmatch (user) {\n    { name, address: { city } } => name + \" a \" + city\n}\n```\n\nVoir `docs/language-guide/pattern-matching.md` pour la documentation complete.\n\n### Operateurs de coalescence null\n```hemlock\n// Coalescence null (??) - retourne gauche si non-null, sinon droite\nlet name = user.name ?? \"Anonyme\";\nlet first = a ?? b ?? c ?? \"defaut\";\n\n// Affectation avec coalescence null (??=) - affecte seulement si null\nlet config = null;\nconfig ??= { timeout: 30 };    // config est maintenant { timeout: 30 }\nconfig ??= { timeout: 60 };    // config inchange (non null)\n\n// Fonctionne avec les proprietes et indices\nobj.field ??= \"defaut\";\narr[0] ??= \"premier\";\n\n// Navigation securisee (?.) - retourne null si l'objet est null\nlet city = user?.address?.city;  // null si une partie est null\nlet upper = name?.to_upper();    // appel de methode securise\nlet item = arr?.[0];             // indexation securisee\n```\n\n### Fonctions\n```hemlock\nfn add(a: i32, b: i32): i32 { return a + b; }\nfn greet(name: string, msg?: \"Bonjour\") { print(msg + \" \" + name); }\nlet f = fn(x) { return x * 2; };  // anonyme/closure\n\n// Fonctions a corps d'expression (syntaxe fleche)\nfn double(x: i32): i32 => x * 2;\nfn max(a: i32, b: i32): i32 => a > b ? a : b;\nlet square = fn(x: i32): i32 => x * x;  // anonyme avec corps d'expression\n\n// Modificateurs de parametres\nfn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // passage par reference\nfn print_all(const items: array) { for (i in items) { print(i); } }  // immuable\n```\n\n### Arguments nommes\n```hemlock\n// Les fonctions peuvent etre appelees avec des arguments nommes\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" a \" + age + \" ans\");\n}\n\n// Arguments positionnels (traditionnel)\ncreate_user(\"Alice\", 25, false);\n\n// Arguments nommes - peuvent etre dans n'importe quel ordre\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n\n// Sauter les parametres optionnels en nommant ce dont vous avez besoin\ncreate_user(\"David\", active: false);  // Utilise age=18 par defaut\n\n// Les arguments nommes doivent venir apres les arguments positionnels\ncreate_user(\"Eve\", age: 21);          // OK : positionnel puis nomme\n// create_user(name: \"Bad\", 25);      // ERREUR : positionnel apres nomme\n```\n\n**Regles :**\n- Les arguments nommes utilisent la syntaxe `nom: valeur`\n- Peuvent apparaitre dans n'importe quel ordre apres les arguments positionnels\n- Les arguments positionnels ne peuvent pas suivre les arguments nommes\n- Fonctionne avec les parametres par defaut/optionnels\n- Les noms de parametres inconnus causent des erreurs a l'execution\n\n### Objets et enumerations\n```hemlock\ndefine Person { name: string, age: i32, active?: true }\nlet p: Person = { name: \"Alice\", age: 30 };\nlet json = p.serialize();\nlet restored = json.deserialize();\n\n// Syntaxe raccourcie pour les objets (style ES6)\nlet name = \"Alice\";\nlet age = 30;\nlet person = { name, age };         // equivalent a { name: name, age: age }\n\n// Operateur de propagation d'objet (spread)\nlet defaults = { theme: \"dark\", size: \"medium\" };\nlet config = { ...defaults, size: \"large\" };  // copie defaults, remplace size\n\nenum Color { RED, GREEN, BLUE }\nenum Status { OK = 0, ERROR = 1 }\n```\n\n### Types composes (Intersection/Duck Types)\n```hemlock\n// Definir des types structurels\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// Type compose : l'objet doit satisfaire TOUS les types\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// Parametres de fonction avec types composes\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" a \" + p.age + \" ans\");\n}\n\n// Trois types ou plus\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n\n// Champs supplementaires autorises (duck typing)\nlet employee: HasName & HasAge = {\n    name: \"Bob\",\n    age: 25,\n    department: \"Ingenierie\"  // OK - champs supplementaires ignores\n};\n```\n\nLes types composes fournissent un comportement similaire aux interfaces sans mot-cle `interface` separe,\nen s'appuyant sur les paradigmes existants de `define` et de duck typing.\n\n### Alias de type\n```hemlock\n// Alias de type simple\ntype Integer = i32;\ntype Text = string;\n\n// Alias de type fonction\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// Alias de type compose (excellent pour les interfaces reutilisables)\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// Alias de type generique\ntype Pair<T> = { first: T, second: T };\n\n// Utilisation des alias de type\nlet x: Integer = 42;\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\nLes alias de type creent des raccourcis nommes pour les types complexes, ameliorant la lisibilite et la maintenabilite.\n\n### Types de fonction\n```hemlock\n// Annotations de type fonction pour les parametres\nfn apply_fn(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Fonction d'ordre superieur retournant une fonction\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Types de fonction asynchrone\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n\n// Types de fonction avec plusieurs parametres\ntype BinaryOp = fn(i32, i32): i32;\nlet add: BinaryOp = fn(a, b) { return a + b; };\n```\n\n### Parametres const\n```hemlock\n// Parametre const - immutabilite profonde\nfn print_all(const items: array) {\n    // items.push(4);  // ERREUR : impossible de modifier un parametre const\n    for (item in items) {\n        print(item);\n    }\n}\n\n// Const avec objets - aucune mutation par aucun chemin\nfn describe(const person: object) {\n    print(person.name);       // OK : la lecture est autorisee\n    // person.name = \"Bob\";   // ERREUR : impossible de modifier\n}\n\n// L'acces imbrique est autorise pour la lecture\nfn get_city(const user: object) {\n    return user.address.city;  // OK : lecture des proprietes imbriquees\n}\n```\n\nLe modificateur `const` empeche toute mutation du parametre, y compris les proprietes imbriquees.\nCela fournit une securite a la compilation pour les fonctions qui ne doivent pas modifier leurs entrees.\n\n### Parametres ref (passage par reference)\n```hemlock\n// Parametre ref - la variable de l'appelant est modifiee directement\nfn increment(ref x: i32) {\n    x = x + 1;  // Modifie la variable originale\n}\n\nlet count = 10;\nincrement(count);\nprint(count);  // 11 - l'original a ete modifie\n\n// Fonction swap classique\nfn swap(ref a: i32, ref b: i32) {\n    let temp = a;\n    a = b;\n    b = temp;\n}\n\nlet x = 1;\nlet y = 2;\nswap(x, y);\nprint(x, y);  // 2 1\n\n// Melanger parametres ref et reguliers\nfn add_to(ref target: i32, amount: i32) {\n    target = target + amount;\n}\n\nlet total = 100;\nadd_to(total, 50);\nprint(total);  // 150\n```\n\nLe modificateur `ref` passe une reference a la variable de l'appelant, permettant a la fonction de\nla modifier directement. Sans `ref`, les primitives sont passees par valeur (copiees). Utilisez `ref` quand\nvous devez modifier l'etat de l'appelant sans retourner de valeur.\n\n**Regles :**\n- Les parametres `ref` doivent recevoir des variables, pas des litteraux ou expressions\n- Fonctionne avec tous les types (primitives, tableaux, objets)\n- Combiner avec les annotations de type : `ref x: i32`\n- Ne peut pas etre combine avec `const` (ils sont opposes)\n\n### Signatures de methode dans define\n```hemlock\n// Define avec signatures de methode (patron interface)\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32   // Signature de methode requise\n}\n\n// Les objets doivent fournir la methode requise\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// Methodes optionnelles avec ?\ndefine Serializable {\n    fn serialize(): string,        // Requise\n    fn pretty?(): string           // Methode optionnelle\n}\n\n// Le type Self fait reference au type definissant\ndefine Cloneable {\n    fn clone(): Self   // Retourne le meme type que l'objet\n}\n```\n\nLes signatures de methode dans les blocs `define` utilisent des delimiteurs virgule (comme les interfaces TypeScript),\netablissant des contrats que les objets doivent respecter et permettant des patrons de programmation\nde type interface avec le systeme de duck typing de Hemlock.\n\n### Gestion des erreurs\n```hemlock\ntry { throw \"erreur\"; } catch (e) { print(e); } finally { cleanup(); }\npanic(\"irrecuperable\");  // quitte immediatement, non capturable\n```\n\n### Async/Concurrence\n```hemlock\nasync fn compute(n: i32): i32 { return n * n; }\nlet task = spawn(compute, 42);\nlet result = await task;     // ou join(task)\ndetach(spawn(background_work));\n\nlet ch = channel(10);\nch.send(value);\nlet val = ch.recv();\nch.close();\n```\n\n**Propriete de la memoire :** Les taches recoivent des copies des valeurs primitives mais partagent les pointeurs. Si vous passez un `ptr` a une tache lancee, vous devez vous assurer que la memoire reste valide jusqu'a ce que la tache se termine. Utilisez `join()` avant `free()`, ou utilisez des canaux pour signaler la completion.\n\n### Entree utilisateur\n```hemlock\nlet name = read_line();          // Lit une ligne depuis stdin (bloquant)\nprint(\"Bonjour, \" + name);\neprint(\"Message d'erreur\");      // Affiche sur stderr\n\n// read_line() retourne null en fin de fichier (EOF)\nwhile (true) {\n    let line = read_line();\n    if (line == null) { break; }\n    print(\"Recu:\", line);\n}\n```\n\n### E/S fichier\n```hemlock\nlet f = open(\"fichier.txt\", \"r\");  // modes: r, w, a, r+, w+, a+\nlet content = f.read();\nf.write(\"donnees\");\nf.seek(0);\nf.close();\n```\n\n### Signaux\n```hemlock\nsignal(SIGINT, fn(sig) { print(\"Interrompu\"); });\nraise(SIGUSR1);\n```\n\n---\n\n## Methodes de chaine (19)\n\n`substr`, `slice`, `find`, `contains`, `split`, `trim`, `to_upper`, `to_lower`,\n`starts_with`, `ends_with`, `replace`, `replace_all`, `repeat`, `char_at`,\n`byte_at`, `chars`, `bytes`, `to_bytes`, `deserialize`\n\nChaines de modele : `` `Bonjour ${name}!` ``\n\n**Mutabilite des chaines :** Les chaines sont mutables via l'affectation par index (`s[0] = 'H'`), mais toutes les methodes de chaine retournent de nouvelles chaines sans modifier l'originale. Cela permet la mutation sur place quand necessaire tout en gardant le chainage de methodes fonctionnel.\n\n**Proprietes de longueur de chaine :**\n```hemlock\nlet s = \"hello \";\nprint(s.length);       // 7 (nombre de caracteres/runes)\nprint(s.byte_length);  // 10 (nombre d'octets - l'emoji fait 4 octets UTF-8)\n```\n\n## Methodes de tableau (18)\n\n`push`, `pop`, `shift`, `unshift`, `insert`, `remove`, `find`, `contains`,\n`slice`, `join`, `concat`, `reverse`, `first`, `last`, `clear`, `map`, `filter`, `reduce`\n\nTableaux types : `let nums: array<i32> = [1, 2, 3];`\n\n---\n\n## Bibliotheque standard (40 modules)\n\nImporter avec le prefixe `@stdlib/` :\n```hemlock\nimport { sin, cos, PI } from \"@stdlib/math\";\nimport { HashMap, Queue, Set } from \"@stdlib/collections\";\nimport { read_file, write_file } from \"@stdlib/fs\";\nimport { TcpStream, UdpSocket } from \"@stdlib/net\";\n```\n\n| Module | Description |\n|--------|-------------|\n| `arena` | Allocateur memoire arena (allocation par bump) |\n| `args` | Analyse des arguments de ligne de commande |\n| `assert` | Utilitaires d'assertion |\n| `async` | ThreadPool, parallel_map |\n| `async_fs` | Operations d'E/S fichier asynchrones |\n| `collections` | HashMap, Queue, Stack, Set, LinkedList, LRUCache |\n| `compression` | gzip, gunzip, deflate |\n| `crypto` | aes_encrypt, rsa_sign, random_bytes |\n| `csv` | Analyse et generation CSV |\n| `datetime` | Classe DateTime, formatage, analyse |\n| `encoding` | base64_encode, hex_encode, url_encode |\n| `env` | getenv, setenv, exit, get_pid |\n| `fmt` | Utilitaires de formatage de chaine |\n| `fs` | read_file, write_file, list_dir, exists |\n| `glob` | Correspondance de motifs de fichier |\n| `hash` | sha256, sha512, md5, djb2 |\n| `http` | http_get, http_post, http_request |\n| `ipc` | Communication inter-processus |\n| `iter` | Utilitaires d'iterateur |\n| `json` | parse, stringify, pretty, get, set |\n| `logging` | Logger avec niveaux |\n| `math` | sin, cos, sqrt, pow, rand, PI, E |\n| `net` | TcpListener, TcpStream, UdpSocket |\n| `os` | platform, arch, cpu_count, hostname |\n| `path` | Manipulation de chemins de fichier |\n| `process` | fork, exec, wait, kill |\n| `random` | Generation de nombres aleatoires |\n| `regex` | compile, test (POSIX ERE) |\n| `retry` | Logique de reessai avec backoff |\n| `semver` | Versionnage semantique |\n| `shell` | Utilitaires de commandes shell |\n| `sqlite` | Base de donnees SQLite, query, exec, transactions |\n| `strings` | pad_left, is_alpha, reverse, lines |\n| `terminal` | Couleurs et styles ANSI |\n| `testing` | describe, test, expect |\n| `time` | now, time_ms, sleep, clock |\n| `toml` | Analyse et generation TOML |\n| `url` | Analyse et manipulation d'URL |\n| `uuid` | Generation d'UUID |\n| `websocket` | Client WebSocket |\n\nVoir `stdlib/docs/` pour la documentation detaillee des modules.\n\n---\n\n## FFI (Interface de fonction etrangere)\n\nDeclarer et appeler des fonctions C depuis des bibliotheques partagees :\n```hemlock\nimport \"libc.so.6\";\n\nextern fn strlen(s: string): i32;\nextern fn getpid(): i32;\n\nlet len = strlen(\"Hello!\");  // 6\nlet pid = getpid();\n```\n\nExporter des fonctions FFI depuis des modules :\n```hemlock\n// string_utils.hml\nimport \"libc.so.6\";\n\nexport extern fn strlen(s: string): i32;\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n```\n\nFFI dynamique (liaison a l'execution) :\n```hemlock\nlet lib = ffi_open(\"libc.so.6\");\nlet puts = ffi_bind(lib, \"puts\", [FFI_POINTER], FFI_INT);\nputs(\"Hello from C!\");\nffi_close(lib);\n```\n\nTypes : `FFI_INT`, `FFI_DOUBLE`, `FFI_POINTER`, `FFI_STRING`, `FFI_VOID`, etc.\n\n---\n\n## Operations atomiques\n\nProgrammation concurrente sans verrou avec des operations atomiques :\n\n```hemlock\n// Allouer de la memoire pour un i32 atomique\nlet p = alloc(4);\nptr_write_i32(p, 0);\n\n// Chargement/stockage atomique\nlet val = atomic_load_i32(p);        // Lecture atomique\natomic_store_i32(p, 42);             // Ecriture atomique\n\n// Operations fetch-and-modify (retournent l'ANCIENNE valeur)\nlet old = atomic_add_i32(p, 10);     // Ajoute, retourne l'ancienne valeur\nold = atomic_sub_i32(p, 5);          // Soustrait, retourne l'ancienne valeur\nold = atomic_and_i32(p, 0xFF);       // ET bit a bit\nold = atomic_or_i32(p, 0x10);        // OU bit a bit\nold = atomic_xor_i32(p, 0x0F);       // XOR bit a bit\n\n// Compare-and-swap (CAS)\nlet success = atomic_cas_i32(p, 42, 100);  // Si *p == 42, mettre a 100\n// Retourne true si l'echange a reussi, false sinon\n\n// Echange atomique\nold = atomic_exchange_i32(p, 999);   // Echange, retourne l'ancienne valeur\n\nfree(p);\n\n// Variantes i64 disponibles (atomic_load_i64, atomic_add_i64, etc.)\n\n// Barriere memoire (barriere complete)\natomic_fence();\n```\n\nToutes les operations utilisent la coherence sequentielle (`memory_order_seq_cst`).\n\n---\n\n## Structure du projet\n\n```\nhemlock/\n src/\n    frontend/         # Partage : lexer, parser, AST, modules\n    backends/\n       interpreter/  # hemlock : interpreteur par parcours d'arbre\n       compiler/     # hemlockc : generateur de code C\n    tools/\n       lsp/          # Language Server Protocol\n       bundler/      # Outils de bundle/package\n runtime/              # Runtime du programme compile (libhemlock_runtime.a)\n stdlib/               # Bibliotheque standard (40 modules)\n    docs/             # Documentation des modules\n docs/                 # Documentation complete\n    language-guide/   # Types, chaines, tableaux, etc.\n    reference/        # References API\n    advanced/         # Async, FFI, signaux, etc.\n tests/                # 625+ tests\n examples/             # Programmes d'exemple\n```\n\n---\n\n## Directives de style de code\n\n### Constantes et nombres magiques\n\nLors de l'ajout de constantes numeriques a la base de code C, suivez ces directives :\n\n1. **Definir les constantes dans `include/hemlock_limits.h`** - Ce fichier est l'emplacement central pour toutes les limites de compilation et d'execution, capacites et constantes nommees.\n\n2. **Utiliser des noms descriptifs avec le prefixe `HML_`** - Toutes les constantes doivent etre prefixees avec `HML_` pour la clarte de l'espace de noms.\n\n3. **Eviter les nombres magiques** - Remplacer les valeurs numeriques codees en dur par des constantes nommees. Exemples :\n   - Limites de plage de type : `HML_I8_MIN`, `HML_I8_MAX`, `HML_U32_MAX`\n   - Capacites de tampon : `HML_INITIAL_ARRAY_CAPACITY`, `HML_INITIAL_LEXER_BUFFER_CAPACITY`\n   - Conversions de temps : `HML_NANOSECONDS_PER_SECOND`, `HML_MILLISECONDS_PER_SECOND`\n   - Graines de hachage : `HML_DJB2_HASH_SEED`\n   - Valeurs ASCII : `HML_ASCII_CASE_OFFSET`, `HML_ASCII_PRINTABLE_START`\n\n4. **Inclure `hemlock_limits.h`** - Les fichiers sources doivent inclure cet en-tete (souvent via `internal.h`) pour acceder aux constantes.\n\n5. **Documenter l'objectif** - Ajouter un commentaire expliquant ce que chaque constante represente.\n\n---\n\n## Ce qu'il ne faut PAS faire\n\n- Ne pas ajouter de comportement implicite (ASI, GC, nettoyage automatique)\n- Ne pas cacher la complexite (optimisations magiques, compteurs de references caches)\n- Ne pas casser la semantique existante (points-virgules, memoire manuelle, chaines mutables)\n- Ne pas perdre de precision dans les conversions implicites\n- Ne pas utiliser de nombres magiques - definir des constantes nommees dans `hemlock_limits.h` a la place\n\n---\n\n## Tests\n\n```bash\nmake test              # Executer les tests de l'interpreteur\nmake test-compiler     # Executer les tests du compilateur\nmake parity            # Executer les tests de parite (les deux doivent correspondre)\nmake test-all          # Executer toutes les suites de tests\n```\n\n**Important :** Les tests peuvent se bloquer a cause de problemes async/concurrence. Toujours utiliser un timeout lors de l'execution des tests :\n```bash\ntimeout 60 make test   # timeout de 60 secondes\ntimeout 120 make parity\n```\n\nCategories de tests : primitives, memory, strings, arrays, functions, objects, async, ffi, defer, signals, switch, bitwise, typed_arrays, modules, stdlib_*\n\n---\n\n## Architecture compilateur/interpreteur\n\nHemlock a deux backends d'execution qui partagent un frontend commun :\n\n```\nSource (.hml)\n    \n\n  FRONTEND PARTAGE           \n  - Lexer (src/frontend/)    \n  - Parser (src/frontend/)   \n  - AST (src/frontend/)      \n\n                        \n    \n INTERPRETEUR    COMPILATEUR\n (hemlock)       (hemlockc) \n                            \n Evaluation      Verif type \n par arbre       AST  C    \n                 liaison gcc\n    \n```\n\n### Verification de type du compilateur\n\nLe compilateur (`hemlockc`) inclut une verification de type a la compilation, **activee par defaut** :\n\n```bash\nhemlockc program.hml -o program    # Verifie les types, puis compile\nhemlockc --check program.hml       # Verification de type seulement, pas de compilation\nhemlockc --no-type-check prog.hml  # Desactiver la verification de type\nhemlockc --strict-types prog.hml   # Avertir sur les types 'any' implicites\n```\n\nLe verificateur de type :\n- Valide les annotations de type a la compilation\n- Traite le code non type comme dynamique (type `any`) - toujours valide\n- Fournit des indications d'optimisation pour le deballage (unboxing)\n- Utilise des conversions numeriques permissives (plage validee a l'execution)\n\n### Structure des repertoires\n\n```\nhemlock/\n src/\n    frontend/           # Partage : lexer, parser, AST, modules\n       lexer.c\n       parser/\n       ast.c\n       module.c\n    backends/\n       interpreter/    # hemlock : interpreteur par parcours d'arbre\n          main.c\n          runtime/\n          builtins/\n       compiler/       # hemlockc : generateur de code C\n           main.c\n           codegen/\n    tools/\n       lsp/            # Serveur de langage\n       bundler/        # Outils de bundle/package\n runtime/                # libhemlock_runtime.a pour les programmes compiles\n stdlib/                 # Bibliotheque standard partagee\n tests/\n     parity/             # Tests qui DOIVENT passer les deux backends\n     interpreter/        # Tests specifiques a l'interpreteur\n     compiler/           # Tests specifiques au compilateur\n```\n\n---\n\n## Developpement parite-en-premier\n\n**L'interpreteur et le compilateur doivent produire une sortie identique pour la meme entree.**\n\n### Politique de developpement\n\nLors de l'ajout ou de la modification de fonctionnalites du langage :\n\n1. **Concevoir** - Definir le changement AST/semantique dans le frontend partage\n2. **Implementer l'interpreteur** - Ajouter l'evaluation par parcours d'arbre\n3. **Implementer le compilateur** - Ajouter la generation de code C\n4. **Ajouter un test de parite** - Ecrire le test dans `tests/parity/` avec un fichier `.expected`\n5. **Verifier** - Executer `make parity` avant de fusionner\n\n### Structure des tests de parite\n\n```\ntests/parity/\n language/       # Fonctionnalites du langage de base (flux de controle, closures, etc.)\n builtins/       # Fonctions integrees (print, typeof, memory, etc.)\n methods/        # Methodes de chaine et de tableau\n modules/        # Import/export, imports stdlib\n```\n\nChaque test a deux fichiers :\n- `feature.hml` - Le programme de test\n- `feature.expected` - Sortie attendue (doit correspondre pour les deux backends)\n\n### Resultats des tests de parite\n\n| Statut | Signification |\n|--------|---------------|\n| ` PASSED` | L'interpreteur et le compilateur correspondent a la sortie attendue |\n| ` INTERP_ONLY` | L'interpreteur fonctionne, le compilateur echoue (correction du compilateur necessaire) |\n| ` COMPILER_ONLY` | Le compilateur fonctionne, l'interpreteur echoue (rare) |\n| ` FAILED` | Les deux echouent (bug de test ou d'implementation) |\n\n### Ce qui requiert la parite\n\n- Toutes les constructions du langage (if, while, for, switch, defer, try/catch)\n- Tous les operateurs (arithmetiques, bit a bit, logiques, comparaison)\n- Toutes les fonctions integrees (print, typeof, alloc, etc.)\n- Toutes les methodes de chaine et de tableau\n- Regles de coercition et promotion de type\n- Messages d'erreur pour les erreurs d'execution\n\n### Ce qui peut differer\n\n- Caracteristiques de performance\n- Details de disposition memoire\n- Format de debogage/trace de pile\n- Erreurs de compilation (le compilateur peut en detecter plus a la compilation)\n\n### Ajouter un test de parite\n\n```bash\n# 1. Creer le fichier de test\ncat > tests/parity/language/my_feature.hml << 'EOF'\n// Description du test\nlet x = some_feature();\nprint(x);\nEOF\n\n# 2. Generer la sortie attendue depuis l'interpreteur\n./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected\n\n# 3. Verifier la parite\nmake parity\n```\n\n---\n\n## Version\n\n**v1.8.1** - Version actuelle avec :\n- **Pattern matching** (expressions `match`) - Destructuration et flux de controle puissants :\n  - Motifs litteral, joker et liaison de variable\n  - Motifs OU (`1 | 2 | 3`)\n  - Expressions de garde (`n if n > 0`)\n  - Destructuration d'objet (`{ x, y }`)\n  - Destructuration de tableau avec reste (`[first, ...rest]`)\n  - Motifs de type (`n: i32`)\n  - Parite complete entre interpreteur et compilateur\n- **Annotations d'aide au compilateur** - 11 annotations d'optimisation pour le controle GCC/Clang :\n  - `@inline`, `@noinline` - controle de l'inlining de fonction\n  - `@hot`, `@cold` - indications de prediction de branche\n  - `@pure`, `@const` - annotations d'effets de bord\n  - `@flatten` - inliner tous les appels dans la fonction\n  - `@optimize(level)` - niveau d'optimisation par fonction (\"0\", \"1\", \"2\", \"3\", \"s\", \"fast\")\n  - `@warn_unused` - avertir sur les valeurs de retour ignorees\n  - `@section(name)` - placement de section ELF personnalise (ex: `@section(\".text.hot\")`)\n- **Fonctions a corps d'expression** (`fn double(x): i32 => x * 2;`) - syntaxe concise pour les fonctions a expression unique\n- **Instructions sur une ligne** - syntaxe sans accolades pour `if`, `while`, `for` (ex: `if (x > 0) print(x);`)\n- **Alias de type** (`type Name = Type;`) - raccourcis nommes pour les types complexes\n- **Annotations de type fonction** (`fn(i32): i32`) - types de fonction de premiere classe\n- **Parametres const** (`fn(const x: array)`) - immutabilite profonde pour les parametres\n- **Parametres ref** (`fn(ref x: i32)`) - passage par reference pour la mutation directe de l'appelant\n- **Signatures de methode dans define** (`fn method(): Type`) - contrats de type interface (delimites par virgule)\n- **Type Self** dans les signatures de methode - fait reference au type definissant\n- **Mot-cle loop** (`loop { }`) - boucles infinies plus propres, remplace `while (true)`\n- **Etiquettes de boucle** (`outer: while`) - break/continue cibles pour les boucles imbriquees\n- **Raccourci objet** (`{ name }`) - syntaxe de propriete raccourcie style ES6\n- **Propagation d'objet** (`{ ...obj }`) - copier et fusionner les champs d'objet\n- **Types duck composes** (`A & B & C`) - types d'intersection pour le typage structurel\n- **Arguments nommes** pour les appels de fonction (`foo(name: \"value\", age: 30)`)\n- **Operateurs de coalescence null** (`??`, `??=`, `?.`) pour la gestion securisee des null\n- **Litteraux octaux** (`0o777`, `0O123`)\n- **Separateurs numeriques** (`1_000_000`, `0xFF_FF`, `0b1111_0000`)\n- **Commentaires bloc** (`/* ... */`)\n- **Sequences d'echappement hexadecimales** dans les chaines/runes (`\\x41` = 'A')\n- **Sequences d'echappement Unicode** dans les chaines (`\\u{1F600}` = )\n- **Litteraux flottants sans zero initial** (`.5`, `.123`, `.5e2`)\n- **Verification de type a la compilation** dans hemlockc (activee par defaut)\n- **Integration LSP** avec verification de type pour les diagnostics en temps reel\n- **Operateurs d'affectation composee** (`+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`)\n- **Operateurs d'increment/decrement** (`++x`, `x++`, `--x`, `x--`)\n- **Correction de precision de type** : i64/u64 + f32 -> f64 pour preserver la precision\n- Systeme de type unifie avec indications d'optimisation de deballage\n- Systeme de type complet (i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object, enum, file, task, channel)\n- Chaines UTF-8 avec 19 methodes\n- Tableaux avec 18 methodes incluant map/filter/reduce\n- Gestion manuelle de la memoire avec `talloc()` et `sizeof()`\n- Async/await avec vrai parallelisme pthread\n- Operations atomiques pour la programmation concurrente sans verrou\n- 40 modules stdlib (+ arena, assert, semver, toml, retry, iter, random, shell)\n- FFI pour l'interoperabilite C avec `export extern fn` pour les wrappers de bibliotheque reutilisables\n- Support des structures FFI dans le compilateur (passer des structures C par valeur)\n- Helpers de pointeur FFI (`ptr_null`, `ptr_read_*`, `ptr_write_*`)\n- defer, try/catch/finally/throw, panic\n- E/S fichier, gestion des signaux, execution de commandes\n- Gestionnaire de paquets [hpm](https://github.com/hemlang/hpm) avec registre base sur GitHub\n- Backend compilateur (generation de code C) avec 100% de parite interpreteur\n- Serveur LSP avec go-to-definition et find-references\n- Passe d'optimisation AST et resolution de variable pour recherche O(1)\n- Fonction integree apply() pour les appels de fonction dynamiques\n- Canaux non bufferises et support de nombreux parametres\n- 159 tests de parite (100% de taux de reussite)\n\n---\n\n## Philosophie\n\n> Nous vous donnons les outils pour etre en securite (`buffer`, annotations de type, verification des limites) mais nous ne vous forcons pas a les utiliser (`ptr`, memoire manuelle, operations non securisees).\n\n**Si vous n'etes pas sur qu'une fonctionnalite convient a Hemlock, demandez-vous : \"Est-ce que cela donne au programmeur plus de controle explicite, ou est-ce que cela cache quelque chose ?\"**\n\nSi cela cache, cela n'a probablement pas sa place dans Hemlock.\n"}, "Prise en Main -> Dmarrage Rapide": {"id": "getting-started-quick-start", "content": "# Demarrage rapide\n\nSoyez operationnel avec Hemlock en quelques minutes !\n\n## Votre premier programme\n\nCreez un fichier appele `hello.hml` :\n\n```hemlock\nprint(\"Hello, Hemlock!\");\n```\n\nExecutez-le avec l'interpreteur :\n\n```bash\n./hemlock hello.hml\n```\n\nOu compilez-le en executable natif :\n\n```bash\n./hemlockc hello.hml -o hello\n./hello\n```\n\nSortie :\n```\nHello, Hemlock!\n```\n\n### Interpreteur vs Compilateur\n\nHemlock offre deux manieres d'executer des programmes :\n\n| Outil | Cas d'utilisation | Verification des types |\n|-------|-------------------|------------------------|\n| `hemlock` | Scripts rapides, REPL, developpement | A l'execution uniquement |\n| `hemlockc` | Binaires de production, meilleures performances | A la compilation (par defaut) |\n\nLe compilateur (`hemlockc`) verifie les types de votre code avant de generer un executable, detectant les erreurs plus tot.\n\n## Syntaxe de base\n\n### Variables\n\n```hemlock\n// Les variables sont declarees avec 'let'\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\n// Les annotations de type sont optionnelles\nlet count: i32 = 100;\nlet ratio: f64 = 0.618;\n```\n\n**Important** : Les points-virgules sont **obligatoires** en Hemlock !\n\n### Types\n\nHemlock possede un systeme de types riche :\n\n```hemlock\n// Entiers\nlet small: i8 = 127;          // 8 bits signe\nlet byte: u8 = 255;           // 8 bits non signe\nlet num: i32 = 2147483647;    // 32 bits signe (par defaut)\nlet big: i64 = 9223372036854775807;  // 64 bits signe\n\n// Flottants\nlet f: f32 = 3.14;            // flottant 32 bits\nlet d: f64 = 2.71828;         // flottant 64 bits (par defaut)\n\n// Chaines et caracteres\nlet text: string = \"Hello\";   // chaine UTF-8\nlet emoji: rune = '';       // point de code Unicode\n\n// Booleen et null\nlet flag: bool = true;\nlet empty = null;\n```\n\n### Flux de controle\n\n```hemlock\n// Instructions if\nif (x > 0) {\n    print(\"positif\");\n} else if (x < 0) {\n    print(\"negatif\");\n} else {\n    print(\"zero\");\n}\n\n// Boucles while\nlet i = 0;\nwhile (i < 5) {\n    print(i);\n    i = i + 1;\n}\n\n// Boucles for\nfor (let j = 0; j < 10; j = j + 1) {\n    print(j);\n}\n```\n\n### Fonctions\n\n```hemlock\n// Fonction nommee\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nlet result = add(5, 3);  // 8\n\n// Fonction anonyme\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(multiply(4, 7));  // 28\n```\n\n## Travailler avec les chaines\n\nLes chaines en Hemlock sont **mutables** et **UTF-8** :\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';              // Maintenant \"Hello\"\nprint(s);\n\n// Methodes de chaines\nlet upper = s.to_upper();     // \"HELLO\"\nlet words = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\nlet sub = s.substr(1, 3);     // \"ell\"\n\n// Concatenation\nlet greeting = \"Hello\" + \", \" + \"World!\";\nprint(greeting);  // \"Hello, World!\"\n```\n\n## Tableaux\n\nTableaux dynamiques avec types mixtes :\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Methodes de tableaux\nnumbers.push(6);        // [1, 2, 3, 4, 5, 6]\nlet last = numbers.pop();  // 6\nlet slice = numbers.slice(1, 4);  // [2, 3, 4]\n\n// Types mixtes autorises\nlet mixed = [1, \"two\", true, null];\n```\n\n## Objets\n\nObjets de style JavaScript :\n\n```hemlock\n// Litteral d'objet\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nperson.age = 31;     // Modifier un champ\n\n// Methodes avec 'self'\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## Gestion de la memoire\n\nHemlock utilise la **gestion manuelle de la memoire** :\n\n```hemlock\n// Buffer securise (recommande)\nlet buf = buffer(64);   // Allouer 64 octets\nbuf[0] = 65;            // Definir le premier octet a 'A'\nprint(buf[0]);          // 65\nfree(buf);              // Liberer la memoire\n\n// Pointeur brut (avance)\nlet ptr = alloc(100);\nmemset(ptr, 0, 100);    // Remplir avec des zeros\nfree(ptr);\n```\n\n**Important** : Vous devez appeler `free()` pour ce que vous avez alloue avec `alloc()` !\n\n## Gestion des erreurs\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division par zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Erreur : \" + e);\n} finally {\n    print(\"Termine\");\n}\n```\n\n## Arguments en ligne de commande\n\nAccedez aux arguments du programme via le tableau `args` :\n\n```hemlock\n// script.hml\nprint(\"Script:\", args[0]);\nprint(`Arguments : ${args.length - 1}`);\n\nlet i = 1;\nwhile (i < args.length) {\n    print(`  arg ${i}: ${args[i]}`);\n    i = i + 1;\n}\n```\n\nExecutez avec :\n```bash\n./hemlock script.hml hello world\n```\n\nSortie :\n```\nScript: script.hml\nArguments : 2\n  arg 1: hello\n  arg 2: world\n```\n\n## Entrees/Sorties fichier\n\n```hemlock\n// Ecrire dans un fichier\nlet f = open(\"data.txt\", \"w\");\nf.write(\"Hello, File!\");\nf.close();\n\n// Lire depuis un fichier\nlet f2 = open(\"data.txt\", \"r\");\nlet content = f2.read();\nprint(content);  // \"Hello, File!\"\nf2.close();\n```\n\n## Et ensuite ?\n\nMaintenant que vous avez vu les bases, explorez davantage :\n\n- [Tutoriel](#getting-started-tutorial) - Guide complet etape par etape\n- [Guide du langage](#language-guide-syntax) - Plongee approfondie dans toutes les fonctionnalites\n- [Exemples](../../examples/) - Programmes d'exemple concrets\n- [Reference API](#reference-builtins) - Documentation complete de l'API\n\n## Pieges courants\n\n### Oublier les points-virgules\n\n```hemlock\n// ERREUR : Point-virgule manquant\nlet x = 42\nlet y = 10\n\n// CORRECT\nlet x = 42;\nlet y = 10;\n```\n\n### Oublier de liberer la memoire\n\n```hemlock\n// FUITE DE MEMOIRE\nlet buf = buffer(100);\n// ... utiliser buf ...\n// Oublie d'appeler free(buf) !\n\n// CORRECT\nlet buf = buffer(100);\n// ... utiliser buf ...\nfree(buf);\n```\n\n### Les accolades sont obligatoires\n\n```hemlock\n// ERREUR : Accolades manquantes\nif (x > 0)\n    print(\"positif\");\n\n// CORRECT\nif (x > 0) {\n    print(\"positif\");\n}\n```\n\n## Obtenir de l'aide\n\n- Lisez la [documentation complete](../README.md)\n- Consultez le [repertoire d'exemples](../../examples/)\n- Regardez les [fichiers de test](../../tests/) pour des exemples d'utilisation\n- Signalez les problemes sur GitHub\n"}, "Prise en Main -> Installation": {"id": "getting-started-installation", "content": "# Installation\n\nCe guide vous aidera a compiler et installer Hemlock sur votre systeme.\n\n## Installation rapide (Recommandee)\n\nLa maniere la plus simple d'installer Hemlock est d'utiliser le script d'installation en une ligne :\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash\n```\n\nCela telecharge et installe le dernier binaire pre-compile pour votre plateforme (Linux ou macOS, x86_64 ou arm64).\n\n### Options d'installation\n\n```bash\n# Installer vers un prefixe personnalise (par defaut : ~/.local)\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local\n\n# Installer une version specifique\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0\n\n# Installer et mettre a jour automatiquement le PATH du shell\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path\n```\n\nApres l'installation, verifiez qu'elle fonctionne :\n\n```bash\nhemlock --version\n```\n\n---\n\n## Compilation depuis les sources\n\nSi vous preferez compiler depuis les sources ou si les binaires pre-compiles ne fonctionnent pas pour votre systeme, suivez les instructions ci-dessous.\n\n## Prerequis\n\n### Dependances requises\n\nHemlock necessite les dependances suivantes pour la compilation :\n\n- **Compilateur C** : GCC ou Clang (standard C11)\n- **Make** : GNU Make\n- **libffi** : Bibliotheque d'interface de fonction etrangere (FFI - Foreign Function Interface) (pour le support FFI)\n- **OpenSSL** : Bibliotheque cryptographique (pour les fonctions de hachage : md5, sha1, sha256)\n- **libwebsockets** : Support client/serveur WebSocket et HTTP\n- **zlib** : Bibliotheque de compression\n\n### Installation des dependances\n\n**macOS :**\n```bash\n# Installer Homebrew s'il n'est pas deja installe\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Installer les outils en ligne de commande Xcode\nxcode-select --install\n\n# Installer les dependances via Homebrew\nbrew install libffi openssl@3 libwebsockets\n```\n\n**Remarque pour les utilisateurs macOS** : Le Makefile detecte automatiquement les installations Homebrew et configure les chemins d'inclusion/bibliotheque corrects. Hemlock prend en charge les architectures Intel (x86_64) et Apple Silicon (arm64).\n\n**Ubuntu/Debian :**\n```bash\nsudo apt-get update\nsudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev\n```\n\n**Fedora/RHEL :**\n```bash\nsudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel\n```\n\n**Arch Linux :**\n```bash\nsudo pacman -S base-devel libffi openssl libwebsockets zlib\n```\n\n## Compilation depuis les sources\n\n### 1. Cloner le depot\n\n```bash\ngit clone https://github.com/hemlang/hemlock.git\ncd hemlock\n```\n\n### 2. Compiler Hemlock\n\n```bash\nmake\n```\n\nCela compilera l'interpreteur Hemlock et placera l'executable dans le repertoire courant.\n\n### 3. Verifier l'installation\n\n```bash\n./hemlock --version\n```\n\nVous devriez voir les informations de version de Hemlock.\n\n### 4. Tester la compilation\n\nExecutez la suite de tests pour vous assurer que tout fonctionne correctement :\n\n```bash\nmake test\n```\n\nTous les tests devraient reussir. Si vous constatez des echecs, veuillez les signaler en creant une issue.\n\n## Installation systeme (Optionnel)\n\nPour installer Hemlock a l'echelle du systeme (par exemple, dans `/usr/local/bin`) :\n\n```bash\nsudo make install\n```\n\nCela vous permet d'executer `hemlock` de n'importe ou sans specifier le chemin complet.\n\n## Executer Hemlock\n\n### REPL interactif\n\nDemarrez la boucle lecture-evaluation-affichage (REPL - Read-Eval-Print Loop) :\n\n```bash\n./hemlock\n```\n\nVous verrez une invite ou vous pouvez taper du code Hemlock :\n\n```\nHemlock REPL\n> print(\"Hello, World!\");\nHello, World!\n> let x = 42;\n> print(x * 2);\n84\n>\n```\n\nQuittez le REPL avec `Ctrl+D` ou `Ctrl+C`.\n\n### Executer des programmes\n\nExecutez un script Hemlock :\n\n```bash\n./hemlock program.hml\n```\n\nAvec des arguments en ligne de commande :\n\n```bash\n./hemlock program.hml arg1 arg2 \"argument avec des espaces\"\n```\n\n## Structure des repertoires\n\nApres la compilation, votre repertoire Hemlock ressemblera a ceci :\n\n```\nhemlock/\n hemlock           # Executable de l'interpreteur compile\n src/              # Code source\n include/          # Fichiers d'en-tete\n tests/            # Suite de tests\n examples/         # Programmes d'exemple\n docs/             # Documentation\n stdlib/           # Bibliotheque standard\n Makefile          # Configuration de compilation\n README.md         # README du projet\n```\n\n## Options de compilation\n\n### Compilation de debogage\n\nCompiler avec les symboles de debogage et sans optimisation :\n\n```bash\nmake debug\n```\n\n### Nettoyage de la compilation\n\nSupprimer tous les fichiers compiles :\n\n```bash\nmake clean\n```\n\nRecompiler depuis zero :\n\n```bash\nmake clean && make\n```\n\n## Depannage\n\n### macOS : Erreurs de bibliotheque introuvable\n\nSi vous obtenez des erreurs concernant des bibliotheques manquantes (`-lcrypto`, `-lffi`, etc.) :\n\n1. Assurez-vous que les dependances Homebrew sont installees :\n   ```bash\n   brew install libffi openssl@3 libwebsockets\n   ```\n\n2. Verifiez les chemins Homebrew :\n   ```bash\n   brew --prefix libffi\n   brew --prefix openssl\n   ```\n\n3. Le Makefile devrait detecter automatiquement ces chemins. Si ce n'est pas le cas, verifiez que `brew` est dans votre PATH :\n   ```bash\n   which brew\n   ```\n\n### macOS : Erreurs de types BSD (`u_int`, `u_char` non trouves)\n\nSi vous voyez des erreurs concernant des noms de types inconnus comme `u_int` ou `u_char` :\n\n1. Cela a ete corrige dans v1.0.0+ en utilisant `_DARWIN_C_SOURCE` au lieu de `_POSIX_C_SOURCE`\n2. Assurez-vous d'avoir la derniere version du code\n3. Nettoyez et recompilez :\n   ```bash\n   make clean && make\n   ```\n\n### Linux : libffi non trouve\n\nSi vous obtenez des erreurs concernant `ffi.h` manquant ou `-lffi` :\n\n1. Assurez-vous que `libffi-dev` est installe (voir les dependances ci-dessus)\n2. Verifiez si `pkg-config` peut le trouver :\n   ```bash\n   pkg-config --cflags --libs libffi\n   ```\n3. S'il n'est pas trouve, vous devrez peut-etre definir `PKG_CONFIG_PATH` :\n   ```bash\n   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH\n   ```\n\n### Erreurs de compilation\n\nSi vous rencontrez des erreurs de compilation :\n\n1. Assurez-vous d'avoir un compilateur compatible C11\n2. Sur macOS, essayez d'utiliser Clang (par defaut) :\n   ```bash\n   make CC=clang\n   ```\n3. Sur Linux, essayez d'utiliser GCC :\n   ```bash\n   make CC=gcc\n   ```\n4. Verifiez que toutes les dependances sont installees\n5. Essayez de recompiler depuis zero :\n   ```bash\n   make clean && make\n   ```\n\n### Echecs de tests\n\nSi les tests echouent :\n\n1. Verifiez que vous avez la derniere version du code\n2. Essayez de recompiler depuis zero :\n   ```bash\n   make clean && make test\n   ```\n3. Sur macOS, assurez-vous d'avoir les derniers outils en ligne de commande Xcode :\n   ```bash\n   xcode-select --install\n   ```\n4. Signalez le probleme sur GitHub avec :\n   - Votre plateforme (version macOS / distribution Linux)\n   - Architecture (x86_64 / arm64)\n   - Sortie des tests\n   - Sortie de `make -v` et `gcc --version` (ou `clang --version`)\n\n## Prochaines etapes\n\n- [Guide de demarrage rapide](#getting-started-quick-start) - Ecrivez votre premier programme Hemlock\n- [Tutoriel](#getting-started-tutorial) - Apprenez Hemlock etape par etape\n- [Guide du langage](#language-guide-syntax) - Explorez les fonctionnalites de Hemlock\n"}, "Prise en Main -> Parcours d'Apprentissage": {"id": "getting-started-learning-paths", "content": "# Parcours d'apprentissage\n\nDifferents objectifs necessitent differentes connaissances. Choisissez le parcours qui correspond a ce que vous voulez construire.\n\n---\n\n## Parcours 1 : Scripts rapides et automatisation\n\n**Objectif :** Ecrire des scripts pour automatiser des taches, traiter des fichiers et accomplir des choses.\n\n**Temps jusqu'a la productivite :** Rapide - vous pouvez commencer a ecrire des scripts utiles immediatement.\n\n### Ce que vous apprendrez\n\n1. **[Demarrage rapide](#getting-started-quick-start)** - Votre premier programme, syntaxe de base\n2. **[Chaines](#language-guide-strings)** - Traitement de texte, division, recherche\n3. **[Tableaux](#language-guide-arrays)** - Listes, filtrage, transformation de donnees\n4. **[E/S fichier](#advanced-file-io)** - Lecture et ecriture de fichiers\n5. **[Arguments en ligne de commande](#advanced-command-line-args)** - Obtenir des entrees des utilisateurs\n\n### A ignorer pour l'instant\n\n- Gestion de la memoire (automatique pour les scripts)\n- Async/concurrence (excessif pour les scripts simples)\n- FFI (necessaire uniquement pour l'interoperabilite C)\n\n### Projet d'exemple : Renommeur de fichiers\n\n```hemlock\nimport { list_dir, rename } from \"@stdlib/fs\";\n\n// Renommer tous les fichiers .txt en .md\nlet files = list_dir(\".\");\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let new_name = file.replace(\".txt\", \".md\");\n        rename(file, new_name);\n        print(`Renomme : ${file} -> ${new_name}`);\n    }\n}\n```\n\n---\n\n## Parcours 2 : Traitement et analyse de donnees\n\n**Objectif :** Analyser des donnees, les transformer, generer des rapports.\n\n**Temps jusqu'a la productivite :** Rapide - les methodes de chaines et de tableaux de Hemlock rendent cela facile.\n\n### Ce que vous apprendrez\n\n1. **[Demarrage rapide](#getting-started-quick-start)** - Bases\n2. **[Chaines](#language-guide-strings)** - Analyse, division, formatage\n3. **[Tableaux](#language-guide-arrays)** - map, filter, reduce pour la transformation de donnees\n4. **[Objets](#language-guide-objects)** - Donnees structurees\n5. **Bibliotheque standard :**\n   - **[@stdlib/json](#stdlib-json)** - Analyse JSON\n   - **[@stdlib/csv](#stdlib-csv)** - Fichiers CSV\n   - **[@stdlib/fs](#stdlib-fs)** - Operations sur fichiers\n\n### Projet d'exemple : Analyseur CSV\n\n```hemlock\nimport { read_file } from \"@stdlib/fs\";\nimport { parse } from \"@stdlib/csv\";\n\nlet data = parse(read_file(\"sales.csv\"));\n\n// Calculer le total des ventes\nlet total = 0;\nfor (row in data) {\n    total = total + f64(row.amount);\n}\n\nprint(`Total des ventes : ${total} euros`);\n\n// Trouver le meilleur vendeur\nlet top = data[0];\nfor (row in data) {\n    if (f64(row.amount) > f64(top.amount)) {\n        top = row;\n    }\n}\n\nprint(`Meilleure vente : ${top.product} - ${top.amount} euros`);\n```\n\n---\n\n## Parcours 3 : Programmation web et reseau\n\n**Objectif :** Construire des clients HTTP, travailler avec des API, creer des serveurs.\n\n**Temps jusqu'a la productivite :** Moyen - necessite de comprendre les bases de l'asynchrone.\n\n### Ce que vous apprendrez\n\n1. **[Demarrage rapide](#getting-started-quick-start)** - Bases\n2. **[Fonctions](#language-guide-functions)** - Callbacks et fermetures (closures)\n3. **[Gestion des erreurs](#language-guide-error-handling)** - try/catch pour les erreurs reseau\n4. **[Async et concurrence](#advanced-async-concurrency)** - spawn, await, channels\n5. **Bibliotheque standard :**\n   - **[@stdlib/http](#stdlib-http)** - Requetes HTTP\n   - **[@stdlib/json](#stdlib-json)** - JSON pour les API\n   - **[@stdlib/net](#stdlib-net)** - Sockets TCP/UDP\n   - **[@stdlib/url](#stdlib-url)** - Analyse d'URL\n\n### Projet d'exemple : Client API\n\n```hemlock\nimport { http_get, http_post } from \"@stdlib/http\";\nimport { parse, stringify } from \"@stdlib/json\";\n\n// Requete GET\nlet response = http_get(\"https://api.example.com/users\");\nlet users = parse(response.body);\n\nfor (user in users) {\n    print(`${user.name} : ${user.email}`);\n}\n\n// Requete POST\nlet new_user = { name: \"Alice\", email: \"alice@example.com\" };\nlet result = http_post(\"https://api.example.com/users\", {\n    body: stringify(new_user),\n    headers: { \"Content-Type\": \"application/json\" }\n});\n\nprint(`Utilisateur cree avec l'ID : ${parse(result.body).id}`);\n```\n\n---\n\n## Parcours 4 : Programmation systeme\n\n**Objectif :** Ecrire du code bas niveau, travailler avec la memoire, interfacer avec des bibliotheques C.\n\n**Temps jusqu'a la productivite :** Plus long - necessite de comprendre la gestion de la memoire.\n\n### Ce que vous apprendrez\n\n1. **[Demarrage rapide](#getting-started-quick-start)** - Bases\n2. **[Types](#language-guide-types)** - Comprendre i32, u8, ptr, etc.\n3. **[Gestion de la memoire](#language-guide-memory)** - alloc, free, buffers\n4. **[FFI](#advanced-ffi)** - Appeler des fonctions C\n5. **[Signaux](#advanced-signals)** - Gestion des signaux\n\n### Concepts cles\n\n**Liste de verification de la securite memoire :**\n- [ ] Chaque `alloc()` a un `free()` correspondant\n- [ ] Utiliser `buffer()` sauf si vous avez besoin d'un `ptr` brut\n- [ ] Mettre les pointeurs a `null` apres liberation\n- [ ] Utiliser `try/finally` pour garantir le nettoyage\n\n**Correspondance des types pour FFI :**\n| Hemlock | C |\n|---------|---|\n| `i8` | `char` / `int8_t` |\n| `i32` | `int` |\n| `i64` | `long` (64 bits) |\n| `u8` | `unsigned char` |\n| `f64` | `double` |\n| `ptr` | `void*` |\n\n### Projet d'exemple : Pool de memoire personnalise\n\n```hemlock\n// Allocateur simple par incrementations (bump allocator)\nlet pool_size = 1024 * 1024;  // 1 Mo\nlet pool = alloc(pool_size);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > pool_size) {\n        throw \"Pool epuise\";\n    }\n    let p = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return p;\n}\n\nfn pool_reset() {\n    pool_offset = 0;\n}\n\nfn pool_destroy() {\n    free(pool);\n}\n\n// Utilisation\nlet a = pool_alloc(100);\nlet b = pool_alloc(200);\nmemset(a, 0, 100);\nmemset(b, 0, 200);\n\npool_reset();  // Reutiliser toute la memoire\npool_destroy();  // Nettoyer\n```\n\n---\n\n## Parcours 5 : Programmes paralleles et concurrents\n\n**Objectif :** Executer du code sur plusieurs coeurs CPU, construire des applications reactives.\n\n**Temps jusqu'a la productivite :** Moyen - la syntaxe async est simple, mais raisonner sur le parallelisme demande de la pratique.\n\n### Ce que vous apprendrez\n\n1. **[Demarrage rapide](#getting-started-quick-start)** - Bases\n2. **[Fonctions](#language-guide-functions)** - Fermetures (closures) (important pour l'async)\n3. **[Async et concurrence](#advanced-async-concurrency)** - Plongee complete\n4. **[Atomiques](#advanced-atomics)** - Programmation sans verrous (lock-free)\n\n### Concepts cles\n\n**Modele async de Hemlock :**\n- `async fn` - Definir une fonction qui peut s'executer sur un autre thread\n- `spawn(fn, args...)` - Commencer l'execution, retourne un handle de tache\n- `join(task)` ou `await task` - Attendre la fin, obtenir le resultat\n- `channel(size)` - Creer une file pour envoyer des donnees entre les taches\n\n**Important :** Les taches recoivent des *copies* des valeurs. Si vous passez un pointeur, vous etes responsable de vous assurer que la memoire reste valide jusqu'a ce que la tache se termine.\n\n### Projet d'exemple : Processeur de fichiers parallele\n\n```hemlock\nimport { list_dir, read_file } from \"@stdlib/fs\";\n\nasync fn process_file(path: string): i32 {\n    let content = read_file(path);\n    let lines = content.split(\"\\n\");\n    return lines.length;\n}\n\n// Traiter tous les fichiers en parallele\nlet files = list_dir(\"data/\");\nlet tasks = [];\n\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let task = spawn(process_file, \"data/\" + file);\n        tasks.push({ name: file, task: task });\n    }\n}\n\n// Collecter les resultats\nlet total_lines = 0;\nfor (item in tasks) {\n    let count = join(item.task);\n    print(`${item.name} : ${count} lignes`);\n    total_lines = total_lines + count;\n}\n\nprint(`Total : ${total_lines} lignes`);\n```\n\n---\n\n## Ce qu'il faut apprendre en premier (Tous les parcours)\n\nQuel que soit votre objectif, commencez par ces fondamentaux :\n\n### Semaine 1 : Bases essentielles\n1. **[Demarrage rapide](#getting-started-quick-start)** - Ecrire et executer votre premier programme\n2. **[Syntaxe](#language-guide-syntax)** - Variables, operateurs, flux de controle\n3. **[Fonctions](#language-guide-functions)** - Definir et appeler des fonctions\n\n### Semaine 2 : Manipulation des donnees\n4. **[Chaines](#language-guide-strings)** - Manipulation de texte\n5. **[Tableaux](#language-guide-arrays)** - Collections et iteration\n6. **[Objets](#language-guide-objects)** - Donnees structurees\n\n### Semaine 3 : Robustesse\n7. **[Gestion des erreurs](#language-guide-error-handling)** - try/catch/throw\n8. **[Modules](#language-guide-modules)** - Import/export, utilisation de la stdlib\n\n### Ensuite : Choisissez votre parcours ci-dessus\n\n---\n\n## Aide-memoire : Venant d'autres langages\n\n### Depuis Python\n\n| Python | Hemlock | Notes |\n|--------|---------|-------|\n| `x = 42` | `let x = 42;` | Points-virgules obligatoires |\n| `def fn():` | `fn name() { }` | Accolades obligatoires |\n| `if x:` | `if (x) { }` | Parentheses et accolades obligatoires |\n| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | Boucles for de style C |\n| `for item in list:` | `for (item in array) { }` | For-in fonctionne pareil |\n| `list.append(x)` | `array.push(x);` | Nom de methode different |\n| `len(s)` | `s.length` ou `len(s)` | Les deux fonctionnent |\n| Memoire automatique | Manuelle pour `ptr` | La plupart des types se nettoient automatiquement |\n\n### Depuis JavaScript\n\n| JavaScript | Hemlock | Notes |\n|------------|---------|-------|\n| `let x = 42` | `let x = 42;` | Pareil (points-virgules obligatoires) |\n| `const x = 42` | `let x = 42;` | Pas de mot-cle const |\n| `function fn()` | `fn name() { }` | Mot-cle different |\n| `() => x` | `fn() { return x; }` | Pas de fonctions flechees |\n| `async/await` | `async/await` | Meme syntaxe |\n| `Promise` | `spawn/join` | Modele different |\n| GC automatique | Manuel pour `ptr` | La plupart des types se nettoient automatiquement |\n\n### Depuis C/C++\n\n| C | Hemlock | Notes |\n|---|---------|-------|\n| `int x = 42;` | `let x: i32 = 42;` | Type apres les deux-points |\n| `malloc(n)` | `alloc(n)` | Meme concept |\n| `free(p)` | `free(p)` | Pareil |\n| `char* s = \"hi\"` | `let s = \"hi\";` | Les chaines sont gerees |\n| `#include` | `import { } from` | Imports de modules |\n| Tout manuel | Auto pour la plupart des types | Seul `ptr` necessite une gestion manuelle |\n\n---\n\n## Obtenir de l'aide\n\n- **[Glossaire](../glossary.md)** - Definitions des termes de programmation\n- **[Exemples](../../examples/)** - Programmes complets fonctionnels\n- **[Tests](../../tests/)** - Voir comment les fonctionnalites sont utilisees\n- **GitHub Issues** - Poser des questions, signaler des bugs\n\n---\n\n## Niveaux de difficulte\n\nDans toute la documentation, vous verrez ces marqueurs :\n\n| Marqueur | Signification |\n|----------|---------------|\n| **Debutant** | Aucune experience de programmation prealable necessaire |\n| **Intermediaire** | Suppose des connaissances de base en programmation |\n| **Avance** | Necessite une comprehension des concepts systeme |\n\nSi quelque chose marque \"Debutant\" vous deroute, consultez le [Glossaire](../glossary.md) pour les definitions des termes.\n"}, "Prise en Main -> Tutoriel": {"id": "getting-started-tutorial", "content": "# Tutoriel Hemlock\n\nUn guide complet etape par etape pour apprendre Hemlock.\n\n## Table des matieres\n\n1. [Hello World](#hello-world)\n2. [Variables et types](#variables-et-types)\n3. [Arithmetique et operations](#arithmetique-et-operations)\n4. [Flux de controle](#flux-de-controle)\n5. [Fonctions](#fonctions)\n6. [Chaines et runes](#chaines-et-runes)\n7. [Tableaux](#tableaux)\n8. [Objets](#objets)\n9. [Gestion de la memoire](#gestion-de-la-memoire)\n10. [Gestion des erreurs](#gestion-des-erreurs)\n11. [Entrees/Sorties fichier](#entreessorties-fichier)\n12. [Mettre tout ensemble](#mettre-tout-ensemble)\n\n## Hello World\n\nCommencons par le traditionnel premier programme :\n\n```hemlock\nprint(\"Hello, World!\");\n```\n\nEnregistrez ceci sous `hello.hml` et executez :\n\n```bash\n./hemlock hello.hml\n```\n\n**Points cles :**\n- `print()` est une fonction integree qui affiche sur stdout\n- Les chaines sont entourees de guillemets doubles\n- Les points-virgules sont **obligatoires**\n\n## Variables et types\n\n### Declaration de variables\n\n```hemlock\n// Declaration de variable simple\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\nprint(x);      // 42\nprint(name);   // Alice\nprint(pi);     // 3.14159\n```\n\n### Annotations de type\n\nBien que les types soient inferes par defaut, vous pouvez etre explicite :\n\n```hemlock\nlet age: i32 = 30;\nlet height: f64 = 5.9;\nlet initial: rune = 'A';\nlet active: bool = true;\n```\n\n### Inference de type\n\nHemlock infere les types en fonction des valeurs :\n\n```hemlock\nlet small = 42;              // i32 (tient dans 32 bits)\nlet large = 5000000000;      // i64 (trop grand pour i32)\nlet decimal = 3.14;          // f64 (par defaut pour les flottants)\nlet text = \"hello\";          // string\nlet flag = true;             // bool\n```\n\n### Verification de type\n\n```hemlock\n// Verifier les types avec typeof()\nprint(typeof(42));        // \"i32\"\nprint(typeof(3.14));      // \"f64\"\nprint(typeof(\"hello\"));   // \"string\"\nprint(typeof(true));      // \"bool\"\nprint(typeof(null));      // \"null\"\n```\n\n## Arithmetique et operations\n\n### Arithmetique de base\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13\nprint(a - b);   // 7\nprint(a * b);   // 30\nprint(a / b);   // 3 (division entiere)\nprint(a == b);  // false\nprint(a > b);   // true\n```\n\n### Promotion de type\n\nLors du melange de types, Hemlock promeut vers le type plus grand/plus precis :\n\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result est f64 (10.0 + 3.5 = 13.5)\n\nprint(result);       // 13.5\nprint(typeof(result)); // \"f64\"\n```\n\n### Operations bit a bit\n\n```hemlock\nlet a = 12;  // 1100 en binaire\nlet b = 10;  // 1010 en binaire\n\nprint(a & b);   // 8  (ET)\nprint(a | b);   // 14 (OU)\nprint(a ^ b);   // 6  (OU exclusif)\nprint(a << 1);  // 24 (decalage a gauche)\nprint(a >> 1);  // 6  (decalage a droite)\nprint(~a);      // -13 (NON)\n```\n\n## Flux de controle\n\n### Instructions if\n\n```hemlock\nlet x = 10;\n\nif (x > 0) {\n    print(\"positif\");\n} else if (x < 0) {\n    print(\"negatif\");\n} else {\n    print(\"zero\");\n}\n```\n\n**Remarque :** Les accolades sont **toujours obligatoires**, meme pour les instructions simples.\n\n### Boucles while\n\n```hemlock\nlet count = 0;\nwhile (count < 5) {\n    print(`Compteur : ${count}`);\n    count = count + 1;\n}\n```\n\n### Boucles for\n\n```hemlock\n// Boucle for de style C\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n\n// Boucle for-in (tableaux)\nlet items = [10, 20, 30, 40];\nfor (let item in items) {\n    print(`Element : ${item}`);\n}\n```\n\n### Instructions switch\n\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n        print(\"Lundi\");\n        break;\n    case 2:\n        print(\"Mardi\");\n        break;\n    case 3:\n        print(\"Mercredi\");\n        break;\n    default:\n        print(\"Autre jour\");\n        break;\n}\n```\n\n### Break et continue\n\n```hemlock\n// Break : sortir de la boucle prematurement\nlet i = 0;\nwhile (i < 10) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// Affiche : 0, 1, 2, 3, 4\n\n// Continue : passer a l'iteration suivante\nfor (let j = 0; j < 5; j = j + 1) {\n    if (j == 2) {\n        continue;\n    }\n    print(j);\n}\n// Affiche : 0, 1, 3, 4\n```\n\n## Fonctions\n\n### Fonctions nommees\n\n```hemlock\nfn greet(name: string): string {\n    return \"Bonjour, \" + name + \" !\";\n}\n\nlet message = greet(\"Alice\");\nprint(message);  // \"Bonjour, Alice !\"\n```\n\n### Fonctions anonymes\n\n```hemlock\nlet add = fn(a, b) {\n    return a + b;\n};\n\nprint(add(5, 3));  // 8\n```\n\n### Recursivite\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### Fermetures (Closures)\n\nLes fonctions capturent leur environnement :\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n### Fonctions d'ordre superieur\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 21);\nprint(result);  // 42\n```\n\n## Chaines et runes\n\n### Bases des chaines\n\nLes chaines sont **mutables** et **UTF-8** :\n\n```hemlock\nlet s = \"hello\";\nprint(s.length);      // 5 (nombre de caracteres)\nprint(s.byte_length); // 5 (nombre d'octets)\n\n// Mutation\ns[0] = 'H';\nprint(s);  // \"Hello\"\n```\n\n### Methodes de chaines\n\n```hemlock\nlet text = \"  Hello, World!  \";\n\n// Conversion de casse\nprint(text.to_upper());  // \"  HELLO, WORLD!  \"\nprint(text.to_lower());  // \"  hello, world!  \"\n\n// Suppression des espaces\nprint(text.trim());      // \"Hello, World!\"\n\n// Extraction de sous-chaines\nlet hello = text.substr(2, 5);  // \"Hello\"\nlet world = text.slice(9, 14);  // \"World\"\n\n// Recherche\nlet pos = text.find(\"World\");   // 9\nlet has = text.contains(\"o\");   // true\n\n// Division\nlet parts = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\n\n// Remplacement\nlet s = \"hello world\".replace(\"world\", \"there\");\nprint(s);  // \"hello there\"\n```\n\n### Runes (points de code Unicode)\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '';\n\nprint(ch);      // 'A'\nprint(emoji);   // U+1F680\n\n// Concatenation rune + chaine\nlet msg = '>' + \" Important\";\nprint(msg);  // \"> Important\"\n\n// Convertir entre rune et entier\nlet code: i32 = ch;     // 65 (code ASCII)\nlet r: rune = 128640;   // U+1F680 ()\n```\n\n## Tableaux\n\n### Bases des tableaux\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Modifier les elements\nnumbers[2] = 99;\nprint(numbers[2]);  // 99\n```\n\n### Methodes de tableaux\n\n```hemlock\nlet arr = [10, 20, 30];\n\n// Ajouter/supprimer a la fin\narr.push(40);           // [10, 20, 30, 40]\nlet last = arr.pop();   // 40, arr est maintenant [10, 20, 30]\n\n// Ajouter/supprimer au debut\narr.unshift(5);         // [5, 10, 20, 30]\nlet first = arr.shift(); // 5, arr est maintenant [10, 20, 30]\n\n// Inserer/supprimer a un index\narr.insert(1, 15);      // [10, 15, 20, 30]\nlet removed = arr.remove(2);  // 20\n\n// Recherche\nlet index = arr.find(15);     // 1\nlet has = arr.contains(10);   // true\n\n// Tranche\nlet slice = arr.slice(0, 2);  // [10, 15]\n\n// Joindre en chaine\nlet text = arr.join(\", \");    // \"10, 15, 30\"\n```\n\n### Iteration\n\n```hemlock\nlet items = [\"pomme\", \"banane\", \"cerise\"];\n\n// Boucle for-in\nfor (let item in items) {\n    print(item);\n}\n\n// Iteration manuelle\nlet i = 0;\nwhile (i < items.length) {\n    print(items[i]);\n    i = i + 1;\n}\n```\n\n## Objets\n\n### Litteraux d'objets\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nprint(person.age);   // 30\n\n// Ajouter/modifier des champs\nperson.email = \"alice@example.com\";\nperson.age = 31;\n```\n\n### Methodes et `self`\n\n```hemlock\nlet calculator = {\n    value: 0,\n    add: fn(x) {\n        self.value = self.value + x;\n    },\n    get: fn() {\n        return self.value;\n    }\n};\n\ncalculator.add(10);\ncalculator.add(5);\nprint(calculator.get());  // 15\n```\n\n### Definitions de types (Duck Typing)\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,  // Optionnel avec valeur par defaut\n}\n\nlet p = { name: \"Bob\", age: 25 };\nlet typed: Person = p;  // Le duck typing valide la structure\n\nprint(typeof(typed));   // \"Person\"\nprint(typed.active);    // true (valeur par defaut appliquee)\n```\n\n### Serialisation JSON\n\n```hemlock\nlet obj = { x: 10, y: 20, name: \"test\" };\n\n// Objet vers JSON\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// JSON vers objet\nlet restored = json.deserialize();\nprint(restored.name);  // \"test\"\n```\n\n## Gestion de la memoire\n\n### Buffers securises (Recommande)\n\n```hemlock\n// Allouer un buffer\nlet buf = buffer(10);\nprint(buf.length);    // 10\nprint(buf.capacity);  // 10\n\n// Definir des valeurs (verification des limites)\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Acceder aux valeurs\nprint(buf[0]);  // 65\n\n// Doit etre libere a la fin\nfree(buf);\n```\n\n### Pointeurs bruts (Avance)\n\n```hemlock\n// Allouer de la memoire brute\nlet ptr = alloc(100);\n\n// Remplir avec des zeros\nmemset(ptr, 0, 100);\n\n// Copier des donnees\nlet src = alloc(50);\nmemcpy(ptr, src, 50);\n\n// Liberer les deux\nfree(src);\nfree(ptr);\n```\n\n### Fonctions de memoire\n\n```hemlock\n// Reallouer\nlet p = alloc(64);\np = realloc(p, 128);  // Redimensionner a 128 octets\nfree(p);\n\n// Allocation typee (futur)\n// let arr = talloc(i32, 100);  // Tableau de 100 i32\n```\n\n## Gestion des erreurs\n\n### Try/Catch\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division par zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Erreur : \" + e);\n}\n// Sortie : Erreur : division par zero\n```\n\n### Bloc finally\n\n```hemlock\nlet file = null;\n\ntry {\n    file = open(\"data.txt\", \"r\");\n    let content = file.read();\n    print(content);\n} catch (e) {\n    print(\"Erreur : \" + e);\n} finally {\n    // S'execute toujours\n    if (file != null) {\n        file.close();\n    }\n}\n```\n\n### Lancer des objets\n\n```hemlock\ntry {\n    throw { code: 404, message: \"Non trouve\" };\n} catch (e) {\n    print(`Erreur ${e.code} : ${e.message}`);\n}\n// Sortie : Erreur 404 : Non trouve\n```\n\n### Panic (Erreurs irrecuperables)\n\n```hemlock\nfn validate(x) {\n    if (x < 0) {\n        panic(\"x doit etre non negatif\");\n    }\n    return x * 2;\n}\n\nvalidate(-5);  // Le programme se termine avec : panic: x doit etre non negatif\n```\n\n## Entrees/Sorties fichier\n\n### Lecture de fichiers\n\n```hemlock\n// Lire le fichier entier\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n\n// Lire un nombre specifique d'octets\nlet f2 = open(\"data.txt\", \"r\");\nlet chunk = f2.read(100);  // Lire 100 octets\nf2.close();\n```\n\n### Ecriture de fichiers\n\n```hemlock\n// Ecrire du texte\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Bonjour, Fichier !\\n\");\nf.write(\"Deuxieme ligne\\n\");\nf.close();\n\n// Ajouter au fichier\nlet f2 = open(\"output.txt\", \"a\");\nf2.write(\"Ligne ajoutee\\n\");\nf2.close();\n```\n\n### E/S binaires\n\n```hemlock\n// Ecrire des donnees binaires\nlet buf = buffer(256);\nbuf[0] = 255;\nbuf[1] = 128;\n\nlet f = open(\"data.bin\", \"w\");\nf.write_bytes(buf);\nf.close();\n\n// Lire des donnees binaires\nlet f2 = open(\"data.bin\", \"r\");\nlet data = f2.read_bytes(256);\nprint(data[0]);  // 255\nf2.close();\n\nfree(buf);\nfree(data);\n```\n\n### Proprietes de fichier\n\n```hemlock\nlet f = open(\"/chemin/vers/fichier.txt\", \"r\");\n\nprint(f.path);    // \"/chemin/vers/fichier.txt\"\nprint(f.mode);    // \"r\"\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n## Mettre tout ensemble\n\nConstruisons un simple programme de comptage de mots :\n\n```hemlock\n// wordcount.hml - Compter les mots dans un fichier\n\nfn count_words(filename: string): i32 {\n    let file = null;\n    let count = 0;\n\n    try {\n        file = open(filename, \"r\");\n        let content = file.read();\n\n        // Diviser par les espaces et compter\n        let words = content.split(\" \");\n        count = words.length;\n\n    } catch (e) {\n        print(\"Erreur de lecture du fichier : \" + e);\n        return -1;\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n\n    return count;\n}\n\n// Programme principal\nif (args.length < 2) {\n    print(\"Usage : \" + args[0] + \" <nom_fichier>\");\n} else {\n    let filename = args[1];\n    let words = count_words(filename);\n\n    if (words >= 0) {\n        print(`Nombre de mots : ${words}`);\n    }\n}\n```\n\nExecutez avec :\n```bash\n./hemlock wordcount.hml data.txt\n```\n\n## Prochaines etapes\n\nFelicitations ! Vous avez appris les bases de Hemlock. Voici ce que vous pouvez explorer ensuite :\n\n- [Async et concurrence](#advanced-async-concurrency) - Veritable multithreading\n- [FFI](#advanced-ffi) - Appeler des fonctions C\n- [Gestion des signaux](#advanced-signals) - Signaux de processus\n- [Reference API](#reference-builtins) - Documentation complete de l'API\n- [Exemples](../../examples/) - Plus de programmes concrets\n\n## Exercices pratiques\n\nEssayez de construire ces programmes pour vous entrainer :\n\n1. **Calculatrice** : Implementez une calculatrice simple avec +, -, *, /\n2. **Copie de fichier** : Copiez un fichier vers un autre\n3. **Fibonacci** : Generez les nombres de Fibonacci\n4. **Analyseur JSON** : Lisez et analysez des fichiers JSON\n5. **Processeur de texte** : Trouvez et remplacez du texte dans des fichiers\n\nBon codage avec Hemlock !\n"}, "Guide du Langage -> Chanes de Caractres": {"id": "language-guide-strings", "content": "# Chaines\n\nLes chaines Hemlock sont des **sequences mutables UTF-8 de premiere classe** avec un support Unicode complet et un ensemble riche de methodes pour le traitement de texte. Contrairement a de nombreux langages, les chaines Hemlock sont mutables et fonctionnent nativement avec les points de code Unicode.\n\n## Apercu\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // muter avec rune (maintenant \"Hello\")\nprint(s.length);        // 5 (compte de points de code)\nlet c = s[0];           // retourne rune (point de code Unicode)\nlet msg = s + \" world\"; // concatenation\nlet emoji = \"rocket\";\nprint(emoji.length);    // 1 (un point de code)\nprint(emoji.byte_length); // 4 (quatre octets UTF-8)\n```\n\n## Proprietes\n\nLes chaines Hemlock ont ces caracteristiques cles :\n\n- **Encodage UTF-8** - Support Unicode complet (U+0000 a U+10FFFF)\n- **Mutable** - Contrairement aux chaines Python, JavaScript et Java\n- **Indexation basee sur les points de code** - Retourne `rune` (point de code Unicode), pas un octet\n- **Allouee sur le tas** - Avec suivi de capacite interne\n- **Deux proprietes de longueur** :\n  - `.length` - Compte de points de code (nombre de caracteres)\n  - `.byte_length` - Compte d'octets (taille d'encodage UTF-8)\n\n## Comportement UTF-8\n\nToutes les operations sur les chaines fonctionnent avec les **points de code** (caracteres), pas les octets :\n\n```hemlock\nlet text = \"Helloworld\";\nprint(text.length);        // 11 (points de code)\nprint(text.byte_length);   // 15 (octets, emoji fait 4 octets)\n\n// L'indexation utilise les points de code\nlet h = text[0];           // 'H' (rune)\nlet rocket = text[5];      // 'rocket' (rune)\n```\n\n**Les caracteres multi-octets comptent comme un :**\n```hemlock\n\"Hello\".length;      // 5\n\"rocket\".length;     // 1 (un emoji)\n\"ni hao\".length;     // 2 (deux caracteres chinois)\n\"cafe\".length;       // 4 (e est un point de code)\n```\n\n## Litteraux de chaine\n\n```hemlock\n// Chaines basiques\nlet s1 = \"hello\";\nlet s2 = \"world\";\n\n// Avec sequences d'echappement\nlet s3 = \"Ligne 1\\nLigne 2\\ttabulation\";\nlet s4 = \"Citation: \\\"Bonjour\\\"\";\nlet s5 = \"Antislash: \\\\\";\n\n// Caracteres Unicode\nlet s6 = \"rocket Emoji\";\nlet s7 = \"zhongwen zifu\";\n```\n\n## Chaines de modele (interpolation de chaine)\n\nUtilisez les backticks pour les chaines de modele avec des expressions embarquees :\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\n\n// Interpolation basique\nlet greeting = `Bonjour, ${name}!`;           // \"Bonjour, Alice!\"\nlet info = `${name} a ${age} ans`;            // \"Alice a 30 ans\"\n\n// Expressions dans l'interpolation\nlet x = 5;\nlet y = 10;\nlet sum = `${x} + ${y} = ${x + y}`;           // \"5 + 10 = 15\"\n\n// Appels de methode\nlet upper = `Nom: ${name.to_upper()}`;        // \"Nom: ALICE\"\n\n// Objets imbriques\nlet person = { name: \"Bob\", city: \"NYC\" };\nlet desc = `${person.name} vit a ${person.city}`;  // \"Bob vit a NYC\"\n\n// Multi-lignes (preserve les sauts de ligne)\nlet multi = `Ligne 1\nLigne 2\nLigne 3`;\n```\n\n**Fonctionnalites des chaines de modele :**\n- Les expressions dans `${...}` sont evaluees et converties en chaines\n- Toute expression valide peut etre utilisee (variables, appels de fonction, arithmetique)\n- Les chaines backtick supportent les memes sequences d'echappement que les chaines regulieres\n- Utile pour construire des chaines dynamiques sans concatenation\n\n### Echappement dans les chaines de modele\n\nPour inclure un litteral `${` dans une chaine de modele, echappez le signe dollar :\n\n```hemlock\nlet price = 100;\nlet text = `Prix: \\${price} ou ${price}`;\n// \"Prix: ${price} ou 100\"\n\n// Backtick litteral\nlet code = `Utilisez \\` pour les chaines de modele`;\n// \"Utilisez ` pour les chaines de modele\"\n```\n\n### Expressions complexes\n\nLes chaines de modele peuvent contenir n'importe quelle expression valide :\n\n```hemlock\n// Expressions ternaires\nlet age = 25;\nlet status = `Statut: ${age >= 18 ? \"adulte\" : \"mineur\"}`;\n\n// Acces tableau\nlet items = [\"pomme\", \"banane\", \"cerise\"];\nlet first = `Premier element: ${items[0]}`;\n\n// Appels de fonction avec arguments\nfn format_price(p) { return p + \" EUR\"; }\nlet msg = `Total: ${format_price(99.99)}`;  // \"Total: 99.99 EUR\"\n\n// Appels de methode chaines\nlet name = \"alice\";\nlet formatted = `Bonjour, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;\n// \"Bonjour, Alice!\"\n```\n\n### Chaines de modele vs concatenation\n\nLes chaines de modele sont souvent plus claires que la concatenation :\n\n```hemlock\n// Concatenation (plus difficile a lire)\nlet msg1 = \"Bonjour, \" + name + \"! Vous avez \" + count + \" messages.\";\n\n// Chaine de modele (plus facile a lire)\nlet msg2 = `Bonjour, ${name}! Vous avez ${count} messages.`;\n```\n\n## Indexation et mutation\n\n### Lecture de caracteres\n\nL'indexation retourne une `rune` (point de code Unicode) :\n\n```hemlock\nlet s = \"Hello\";\nlet first = s[0];      // 'H' (rune)\nlet last = s[4];       // 'o' (rune)\n\n// Exemple UTF-8\nlet emoji = \"Hi!\";\nlet rocket = emoji[2];  // 'rocket' (rune a l'index de point de code 2)\n```\n\n### Ecriture de caracteres\n\nLes chaines sont mutables - vous pouvez modifier des caracteres individuels :\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';            // Maintenant \"Hello\"\ns[4] = '!';            // Maintenant \"Hell!\"\n\n// Avec Unicode\nlet msg = \"Go!\";\nmsg[0] = 'rocket';     // Maintenant \"rocketo!\"\n```\n\n## Concatenation\n\nUtilisez `+` pour concatener les chaines :\n\n```hemlock\nlet greeting = \"Hello\" + \" \" + \"World\";  // \"Hello World\"\n\n// Avec variables\nlet name = \"Alice\";\nlet msg = \"Salut, \" + name + \"!\";  // \"Salut, Alice!\"\n\n// Avec runes (voir documentation Runes)\nlet s = \"Hello\" + '!';          // \"Hello!\"\n```\n\n## Methodes de chaine\n\nHemlock fournit 19 methodes de chaine pour une manipulation de texte complete.\n\n### Sous-chaine et decoupage\n\n**`substr(start, length)`** - Extraire une sous-chaine par position et longueur :\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\" (commence a 6, longueur 5)\nlet first = s.substr(0, 5);     // \"hello\"\n\n// Exemple UTF-8\nlet text = \"Hirocket!\";\nlet emoji = text.substr(2, 1);  // \"rocket\" (position 2, longueur 1)\n```\n\n**`slice(start, end)`** - Extraire une sous-chaine par plage (fin exclusive) :\n```hemlock\nlet s = \"hello world\";\nlet slice = s.slice(0, 5);      // \"hello\" (index 0 a 4)\nlet slice2 = s.slice(6, 11);    // \"world\"\n```\n\n**Difference :**\n- `substr(start, length)` - Utilise le parametre longueur\n- `slice(start, end)` - Utilise l'index de fin (exclusive)\n\n### Recherche\n\n**`find(needle)`** - Trouver la premiere occurrence :\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6 (index de premiere occurrence)\nlet pos2 = s.find(\"foo\");       // -1 (non trouve)\nlet pos3 = s.find(\"l\");         // 2 (premier 'l')\n```\n\n**`contains(needle)`** - Verifier si la chaine contient une sous-chaine :\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n### Decoupage et nettoyage\n\n**`split(delimiter)`** - Decouper en tableau de chaines :\n```hemlock\nlet csv = \"pomme,banane,cerise\";\nlet parts = csv.split(\",\");     // [\"pomme\", \"banane\", \"cerise\"]\n\nlet words = \"un deux trois\".split(\" \");  // [\"un\", \"deux\", \"trois\"]\n\n// Delimiteur vide decoupe par caractere\nlet chars = \"abc\".split(\"\");    // [\"a\", \"b\", \"c\"]\n```\n\n**`trim()`** - Supprimer les espaces de debut et fin :\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet s2 = \"\\t\\ntexte\\n\\t\";\nlet clean2 = s2.trim();         // \"texte\"\n```\n\n### Conversion de casse\n\n**`to_upper()`** - Convertir en majuscules :\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\n// Preserve les non-ASCII\nlet s2 = \"cafe\";\nlet upper2 = s2.to_upper();     // \"CAFE\"\n```\n\n**`to_lower()`** - Convertir en minuscules :\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n```\n\n### Verification de prefixe/suffixe\n\n**`starts_with(prefix)`** - Verifier si commence par le prefixe :\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n**`ends_with(suffix)`** - Verifier si finit par le suffixe :\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n### Remplacement\n\n**`replace(old, new)`** - Remplacer la premiere occurrence :\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");      // \"hello there\"\n\nlet s3 = \"foo foo foo\";\nlet s4 = s3.replace(\"foo\", \"bar\");         // \"bar foo foo\" (premier seulement)\n```\n\n**`replace_all(old, new)`** - Remplacer toutes les occurrences :\n```hemlock\nlet s = \"foo foo foo\";\nlet s2 = s.replace_all(\"foo\", \"bar\");      // \"bar bar bar\"\n\nlet s3 = \"hello world, world!\";\nlet s4 = s3.replace_all(\"world\", \"hemlock\"); // \"hello hemlock, hemlock!\"\n```\n\n### Repetition\n\n**`repeat(count)`** - Repeter la chaine n fois :\n```hemlock\nlet s = \"ha\";\nlet laugh = s.repeat(3);        // \"hahaha\"\n\nlet line = \"=\".repeat(40);      // \"========================================\"\n```\n\n### Acces caractere et octet\n\n**`char_at(index)`** - Obtenir le point de code Unicode a l'index (retourne rune) :\n```hemlock\nlet s = \"hello\";\nlet char = s.char_at(0);        // 'h' (rune)\n\n// Exemple UTF-8\nlet emoji = \"rocket\";\nlet rocket = emoji.char_at(0);  // Retourne rune U+1F680\n```\n\n**`chars()`** - Convertir en tableau de runes (points de code) :\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o'] (tableau de runes)\n\n// Exemple UTF-8\nlet text = \"Hirocket\";\nlet chars2 = text.chars();      // ['H', 'i', 'rocket']\n```\n\n**`byte_at(index)`** - Obtenir la valeur d'octet a l'index (retourne u8) :\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (valeur ASCII de 'h')\n\n// Exemple UTF-8\nlet emoji = \"rocket\";\nlet first_byte = emoji.byte_at(0);  // 240 (premier octet UTF-8)\n```\n\n**`bytes()`** - Convertir en tableau d'octets (valeurs u8) :\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111] (tableau de u8)\n\n// Exemple UTF-8\nlet emoji = \"rocket\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 octets UTF-8)\n```\n\n**`to_bytes()`** - Convertir en buffer pour acces bas niveau :\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();         // Retourne buffer avec octets UTF-8\nprint(buf.length);              // 5\nfree(buf);                      // N'oubliez pas de liberer\n```\n\n## Chainage de methodes\n\nToutes les methodes de chaine retournent de nouvelles chaines, permettant le chainage :\n\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \")\n    .to_upper();                    // \"FOO | BAR | BAZ\"\n```\n\n## Reference complete des methodes\n\n| Methode | Parametres | Retourne | Description |\n|---------|------------|----------|-------------|\n| `substr(start, length)` | i32, i32 | string | Extraire sous-chaine par position et longueur |\n| `slice(start, end)` | i32, i32 | string | Extraire sous-chaine par plage (fin exclusive) |\n| `find(needle)` | string | i32 | Trouver premiere occurrence (-1 si non trouve) |\n| `contains(needle)` | string | bool | Verifier si contient sous-chaine |\n| `split(delimiter)` | string | array | Decouper en tableau de chaines |\n| `trim()` | - | string | Supprimer espaces debut/fin |\n| `to_upper()` | - | string | Convertir en majuscules |\n| `to_lower()` | - | string | Convertir en minuscules |\n| `starts_with(prefix)` | string | bool | Verifier si commence par prefixe |\n| `ends_with(suffix)` | string | bool | Verifier si finit par suffixe |\n| `replace(old, new)` | string, string | string | Remplacer premiere occurrence |\n| `replace_all(old, new)` | string, string | string | Remplacer toutes occurrences |\n| `repeat(count)` | i32 | string | Repeter chaine n fois |\n| `char_at(index)` | i32 | rune | Obtenir point de code a l'index |\n| `byte_at(index)` | i32 | u8 | Obtenir valeur d'octet a l'index |\n| `chars()` | - | array | Convertir en tableau de runes |\n| `bytes()` | - | array | Convertir en tableau d'octets u8 |\n| `to_bytes()` | - | buffer | Convertir en buffer (doit liberer) |\n\n## Exemples\n\n### Exemple : Traitement de texte\n\n```hemlock\nfn process_input(text: string): string {\n    return text\n        .trim()\n        .to_lower()\n        .replace_all(\"  \", \" \");  // Normaliser les espaces\n}\n\nlet input = \"  HELLO   WORLD  \";\nlet clean = process_input(input);  // \"hello world\"\n```\n\n### Exemple : Analyseur CSV\n\n```hemlock\nfn parse_csv_line(line: string): array {\n    let trimmed = line.trim();\n    let fields = trimmed.split(\",\");\n\n    let result = [];\n    let i = 0;\n    while (i < fields.length) {\n        result.push(fields[i].trim());\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet csv = \"pomme, banane , cerise\";\nlet fields = parse_csv_line(csv);  // [\"pomme\", \"banane\", \"cerise\"]\n```\n\n### Exemple : Compteur de mots\n\n```hemlock\nfn count_words(text: string): i32 {\n    let words = text.trim().split(\" \");\n    return words.length;\n}\n\nlet sentence = \"Le rapide renard brun\";\nlet count = count_words(sentence);  // 4\n```\n\n### Exemple : Validation de chaine\n\n```hemlock\nfn is_valid_email(email: string): bool {\n    if (!email.contains(\"@\")) {\n        return false;\n    }\n\n    if (!email.contains(\".\")) {\n        return false;\n    }\n\n    if (email.starts_with(\"@\") || email.ends_with(\"@\")) {\n        return false;\n    }\n\n    return true;\n}\n\nprint(is_valid_email(\"user@example.com\"));  // true\nprint(is_valid_email(\"invalid\"));            // false\n```\n\n## Gestion de la memoire\n\nLes chaines sont allouees sur le tas avec comptage de reference interne :\n\n- **Creation** : Allouee sur le tas avec suivi de capacite\n- **Concatenation** : Cree une nouvelle chaine (anciennes chaines inchangees)\n- **Methodes** : La plupart des methodes retournent de nouvelles chaines\n- **Duree de vie** : Les chaines sont comptees par reference et automatiquement liberees quand la portee se termine\n\n**Nettoyage automatique :**\n```hemlock\nfn create_strings() {\n    let s = \"hello\";\n    let s2 = s + \" world\";  // Nouvelle allocation\n}  // s et s2 sont automatiquement liberes quand la fonction retourne\n```\n\n**Note :** Les variables de chaine locales sont automatiquement nettoyees quand elles sortent de la portee. Utilisez `free()` uniquement pour le nettoyage anticipe avant la fin de portee ou pour les donnees globales/longue duree. Voir [Gestion de la memoire](memory.md#internal-reference-counting) pour les details.\n\n## Bonnes pratiques\n\n1. **Utilisez l'indexation par point de code** - Les chaines utilisent les positions de point de code, pas les decalages d'octets\n2. **Testez avec Unicode** - Testez toujours les operations sur chaines avec des caracteres multi-octets\n3. **Preferez les operations immuables** - Utilisez les methodes qui retournent de nouvelles chaines plutot que la mutation\n4. **Verifiez les limites** - L'indexation de chaine ne verifie pas les limites (retourne null/erreur si invalide)\n5. **Normalisez l'entree** - Utilisez `trim()` et `to_lower()` pour l'entree utilisateur\n\n## Pieges courants\n\n### Piege : Confusion octet vs. point de code\n\n```hemlock\nlet emoji = \"rocket\";\nprint(emoji.length);        // 1 (point de code)\nprint(emoji.byte_length);   // 4 (octets)\n\n// Ne melangez pas les operations octet et point de code\nlet byte = emoji.byte_at(0);  // 240 (premier octet)\nlet char = emoji.char_at(0);  // 'rocket' (point de code complet)\n```\n\n### Piege : Surprises de mutation\n\n```hemlock\nlet s1 = \"hello\";\nlet s2 = s1;       // Copie superficielle\ns1[0] = 'H';       // Mute s1\nprint(s2);         // Toujours \"hello\" (les chaines sont des types valeur)\n```\n\n## Sujets connexes\n\n- [Runes](#language-guide-runes) - Type point de code Unicode utilise dans l'indexation de chaine\n- [Tableaux](#language-guide-arrays) - Les methodes de chaine retournent ou travaillent souvent avec des tableaux\n- [Types](#language-guide-types) - Details du type chaine et conversions\n\n## Voir aussi\n\n- **Encodage UTF-8** : Voir section \"Strings\" de CLAUDE.md\n- **Conversions de type** : Voir [Types](#language-guide-types) pour les conversions de chaine\n- **Memoire** : Voir [Memoire](#language-guide-memory) pour les details d'allocation de chaine\n"}, "Guide du Langage -> Filtrage par Motif": {"id": "language-guide-pattern-matching", "content": "# Filtrage par motif (Pattern Matching)\n\nHemlock fournit un filtrage par motif puissant grace aux expressions `match`, offrant un moyen concis de destructurer les valeurs, verifier les types et gerer plusieurs cas.\n\n## Syntaxe de base\n\n```hemlock\nlet result = match (value) {\n    pattern1 => expression1,\n    pattern2 => expression2,\n    _ => expression_par_defaut\n};\n```\n\nLes expressions match evaluent `value` contre chaque motif dans l'ordre, retournant le resultat de l'expression de la premiere branche correspondante.\n\n## Types de motifs\n\n### Motifs litteraux\n\nCorrespondre a des valeurs exactes :\n\n```hemlock\nlet x = 42;\nlet msg = match (x) {\n    0 => \"zero\",\n    1 => \"un\",\n    42 => \"la reponse\",\n    _ => \"autre\"\n};\nprint(msg);  // \"la reponse\"\n```\n\nLitteraux supportes :\n- **Entiers** : `0`, `42`, `-5`\n- **Flottants** : `3.14`, `-0.5`\n- **Chaines** : `\"hello\"`, `\"world\"`\n- **Booleens** : `true`, `false`\n- **Null** : `null`\n\n### Motif joker (`_`)\n\nCorrespond a n'importe quelle valeur sans liaison :\n\n```hemlock\nlet x = \"n'importe quoi\";\nlet result = match (x) {\n    \"specifique\" => \"trouve\",\n    _ => \"joker correspond\"\n};\n```\n\n### Motifs de liaison de variable\n\nLier la valeur correspondante a une variable :\n\n```hemlock\nlet x = 100;\nlet result = match (x) {\n    0 => \"zero\",\n    n => \"la valeur est \" + n  // n lie a 100\n};\nprint(result);  // \"la valeur est 100\"\n```\n\n### Motifs OU (`|`)\n\nCorrespondre a plusieurs alternatives :\n\n```hemlock\nlet x = 2;\nlet size = match (x) {\n    1 | 2 | 3 => \"petit\",\n    4 | 5 | 6 => \"moyen\",\n    _ => \"grand\"\n};\n\n// Fonctionne avec les chaines aussi\nlet cmd = \"quit\";\nlet action = match (cmd) {\n    \"exit\" | \"quit\" | \"q\" => \"sortie\",\n    \"help\" | \"h\" | \"?\" => \"afficher aide\",\n    _ => \"inconnu\"\n};\n```\n\n### Expressions de garde (`if`)\n\nAjouter des conditions aux motifs :\n\n```hemlock\nlet x = 15;\nlet category = match (x) {\n    n if n < 0 => \"negatif\",\n    n if n == 0 => \"zero\",\n    n if n < 10 => \"petit\",\n    n if n < 100 => \"moyen\",\n    n => \"grand: \" + n\n};\nprint(category);  // \"moyen\"\n\n// Gardes complexes\nlet y = 12;\nlet result = match (y) {\n    n if n % 2 == 0 && n > 10 => \"pair et superieur a 10\",\n    n if n % 2 == 0 => \"pair\",\n    n => \"impair\"\n};\n```\n\n### Motifs de type\n\nVerifier et lier en fonction du type :\n\n```hemlock\nlet val = 42;\nlet desc = match (val) {\n    num: i32 => \"entier: \" + num,\n    str: string => \"chaine: \" + str,\n    flag: bool => \"booleen: \" + flag,\n    _ => \"autre type\"\n};\nprint(desc);  // \"entier: 42\"\n```\n\nTypes supportes : `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`, `bool`, `string`, `array`, `object`\n\n## Motifs de destructuration\n\n### Destructuration d'objet\n\nExtraire des champs des objets :\n\n```hemlock\nlet point = { x: 10, y: 20 };\nlet result = match (point) {\n    { x, y } => \"point a \" + x + \",\" + y\n};\nprint(result);  // \"point a 10,20\"\n\n// Avec valeurs de champ litterales\nlet origin = { x: 0, y: 0 };\nlet name = match (origin) {\n    { x: 0, y: 0 } => \"origine\",\n    { x: 0, y } => \"sur axe y a \" + y,\n    { x, y: 0 } => \"sur axe x a \" + x,\n    { x, y } => \"point a \" + x + \",\" + y\n};\nprint(name);  // \"origine\"\n```\n\n### Destructuration de tableau\n\nCorrespondre a la structure et aux elements du tableau :\n\n```hemlock\nlet arr = [1, 2, 3];\nlet desc = match (arr) {\n    [] => \"vide\",\n    [x] => \"unique: \" + x,\n    [x, y] => \"paire: \" + x + \",\" + y,\n    [x, y, z] => \"triple: \" + x + \",\" + y + \",\" + z,\n    _ => \"beaucoup d'elements\"\n};\nprint(desc);  // \"triple: 1,2,3\"\n\n// Avec valeurs litterales\nlet pair = [1, 2];\nlet result = match (pair) {\n    [0, 0] => \"les deux zero\",\n    [1, x] => \"commence par 1, second est \" + x,\n    [x, 1] => \"finit par 1\",\n    _ => \"autre\"\n};\nprint(result);  // \"commence par 1, second est 2\"\n```\n\n### Motifs rest de tableau (`...`)\n\nCapturer les elements restants :\n\n```hemlock\nlet nums = [1, 2, 3, 4, 5];\n\n// Tete et queue\nlet result = match (nums) {\n    [first, ...rest] => \"premier: \" + first,\n    [] => \"vide\"\n};\nprint(result);  // \"premier: 1\"\n\n// Deux premiers elements\nlet result2 = match (nums) {\n    [a, b, ...rest] => \"deux premiers: \" + a + \",\" + b,\n    _ => \"trop court\"\n};\nprint(result2);  // \"deux premiers: 1,2\"\n```\n\n### Destructuration imbriquee\n\nCombiner les motifs pour des donnees complexes :\n\n```hemlock\nlet user = {\n    name: \"Alice\",\n    address: { city: \"NYC\", zip: 10001 }\n};\n\nlet result = match (user) {\n    { name, address: { city, zip } } => name + \" vit a \" + city,\n    _ => \"inconnu\"\n};\nprint(result);  // \"Alice vit a NYC\"\n\n// Objet contenant un tableau\nlet data = { items: [1, 2, 3], count: 3 };\nlet result2 = match (data) {\n    { items: [first, ...rest], count } => \"premier: \" + first + \", total: \" + count,\n    _ => \"pas d'elements\"\n};\nprint(result2);  // \"premier: 1, total: 3\"\n```\n\n## Match comme expression\n\nMatch est une expression qui retourne une valeur :\n\n```hemlock\n// Assignation directe\nlet grade = 85;\nlet letter = match (grade) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    n if n >= 70 => \"C\",\n    n if n >= 60 => \"D\",\n    _ => \"F\"\n};\n\n// Dans une concatenation de chaines\nlet msg = \"Note: \" + match (grade) {\n    n if n >= 70 => \"reussite\",\n    _ => \"echec\"\n};\n\n// Dans un retour de fonction\nfn classify(n: i32): string {\n    return match (n) {\n        0 => \"zero\",\n        n if n > 0 => \"positif\",\n        _ => \"negatif\"\n    };\n}\n```\n\n## Bonnes pratiques du filtrage par motif\n\n1. **L'ordre compte** : Les motifs sont verifies de haut en bas ; mettez les motifs specifiques avant les generaux\n2. **Utilisez les jokers pour l'exhaustivite** : Incluez toujours un repli `_` sauf si vous etes certain que tous les cas sont couverts\n3. **Preferez les gardes aux conditions imbriquees** : Les gardes rendent l'intention plus claire\n4. **Utilisez la destructuration plutot que l'acces manuel aux champs** : Plus concis et plus sur\n\n```hemlock\n// Bon : Gardes pour verification de plage\nmatch (score) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    _ => \"en dessous de B\"\n}\n\n// Bon : Destructurer au lieu d'acceder aux champs\nmatch (point) {\n    { x: 0, y: 0 } => \"origine\",\n    { x, y } => \"a \" + x + \",\" + y\n}\n\n// Eviter : Motifs imbriques trop complexes\n// A la place, considerez diviser en plusieurs match ou utiliser des gardes\n```\n\n## Comparaison avec d'autres langages\n\n| Fonctionnalite | Hemlock | Rust | JavaScript |\n|----------------|---------|------|------------|\n| Match basique | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |\n| Destructuration | Oui | Oui | Partiel (switch ne destructure pas) |\n| Gardes | `n if n > 0 =>` | `n if n > 0 =>` | N/A |\n| Motifs OU | `1 \\| 2 \\| 3 =>` | `1 \\| 2 \\| 3 =>` | `case 1: case 2: case 3:` |\n| Motifs rest | `[a, ...rest]` | `[a, rest @ ..]` | N/A |\n| Motifs de type | `n: i32` | Type via branche `match` | N/A |\n| Retourne valeur | Oui | Oui | Non (instruction) |\n\n## Notes d'implementation\n\nLe filtrage par motif est implemente dans les backends interpreteur et compilateur avec parite complete - les deux produisent des resultats identiques pour la meme entree. Cette fonctionnalite est disponible dans Hemlock v1.8.0+.\n"}, "Guide du Langage -> Flux de Contrle": {"id": "language-guide-control-flow", "content": "# Flux de controle\n\nHemlock fournit un flux de controle familier de style C avec des accolades obligatoires et une syntaxe explicite. Ce guide couvre les conditionnelles, les boucles, les instructions switch et les operateurs.\n\n## Apercu\n\nFonctionnalites de flux de controle disponibles :\n\n- `if`/`else`/`else if` - Branches conditionnelles\n- Boucles `while` - Iteration basee sur condition\n- Boucles `for` - Style C et iteration for-in\n- `loop` - Boucles infinies (plus propre que `while (true)`)\n- Instructions `switch` - Branchement multi-voies\n- `break`/`continue` - Controle de boucle\n- Labels de boucle - break/continue cible pour les boucles imbriquees\n- `defer` - Execution differee (nettoyage)\n- Operateurs booleens : `&&`, `||`, `!`\n- Operateurs de comparaison : `==`, `!=`, `<`, `>`, `<=`, `>=`\n- Operateurs binaires : `&`, `|`, `^`, `<<`, `>>`, `~`\n\n## Instructions If\n\n### If/Else basique\n\n```hemlock\nif (x > 10) {\n    print(\"grand\");\n} else {\n    print(\"petit\");\n}\n```\n\n**Regles :**\n- Les accolades sont **toujours requises** pour toutes les branches\n- Les conditions doivent etre entre parentheses\n- Pas d'accolades optionnelles (contrairement au C)\n\n### If sans Else\n\n```hemlock\nif (x > 0) {\n    print(\"positif\");\n}\n// Pas de branche else necessaire\n```\n\n### Chaines Else-If\n\n```hemlock\nif (x > 100) {\n    print(\"tres grand\");\n} else if (x > 50) {\n    print(\"grand\");\n} else if (x > 10) {\n    print(\"moyen\");\n} else {\n    print(\"petit\");\n}\n```\n\n**Note :** `else if` est du sucre syntaxique pour des instructions if imbriquees. Ces deux sont equivalents :\n\n```hemlock\n// else if (sucre syntaxique)\nif (a) {\n    foo();\n} else if (b) {\n    bar();\n}\n\n// If imbrique equivalent\nif (a) {\n    foo();\n} else {\n    if (b) {\n        bar();\n    }\n}\n```\n\n### Instructions If imbriquees\n\n```hemlock\nif (x > 0) {\n    if (x < 10) {\n        print(\"chiffre positif\");\n    } else {\n        print(\"positif multi-chiffres\");\n    }\n} else {\n    print(\"non-positif\");\n}\n```\n\n## Boucles While\n\nIteration basee sur condition :\n\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n**Boucles infinies (ancien style) :**\n```hemlock\nwhile (true) {\n    // ... faire le travail\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**Note :** Pour les boucles infinies, preferez le mot-cle `loop` (voir ci-dessous).\n\n## Loop (boucle infinie)\n\nLe mot-cle `loop` fournit une syntaxe plus propre pour les boucles infinies :\n\n```hemlock\nloop {\n    // ... faire le travail\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**Equivalent a `while (true)` mais plus explicite sur l'intention.**\n\n### Loop basique avec Break\n\n```hemlock\nlet i = 0;\nloop {\n    if (i >= 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// Affiche : 0, 1, 2, 3, 4\n```\n\n### Loop avec Continue\n\n```hemlock\nlet i = 0;\nloop {\n    i = i + 1;\n    if (i > 5) {\n        break;\n    }\n    if (i == 3) {\n        continue;  // Sauter l'affichage de 3\n    }\n    print(i);\n}\n// Affiche : 1, 2, 4, 5\n```\n\n### Boucles imbriquees\n\n```hemlock\nlet x = 0;\nloop {\n    if (x >= 2) { break; }\n    let y = 0;\n    loop {\n        if (y >= 3) { break; }\n        print(x * 10 + y);\n        y = y + 1;\n    }\n    x = x + 1;\n}\n// Affiche : 0, 1, 2, 10, 11, 12\n```\n\n### Quand utiliser Loop\n\n- **Utilisez `loop`** pour les boucles intentionnellement infinies qui sortent via `break`\n- **Utilisez `while`** quand il y a une condition de terminaison naturelle\n- **Utilisez `for`** pour iterer un nombre connu de fois ou sur une collection\n\n## Boucles For\n\n### For style C\n\nBoucle for classique en trois parties :\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**Composants :**\n- **Initialiseur** : `let i = 0` - S'execute une fois avant la boucle\n- **Condition** : `i < 10` - Verifiee avant chaque iteration\n- **Mise a jour** : `i = i + 1` - S'execute apres chaque iteration\n\n**Portee :**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n// i non accessible ici (portee de boucle)\n```\n\n### Boucles For-In\n\nIterer sur les elements d'un tableau :\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nfor (let item in arr) {\n    print(item);  // Affiche chaque element\n}\n```\n\n**Avec index et valeur :**\n```hemlock\nlet arr = [\"a\", \"b\", \"c\"];\nfor (let i = 0; i < arr.length; i = i + 1) {\n    print(`Index: ${i}, Valeur: ${arr[i]}`);\n}\n```\n\n## Instructions Switch\n\nBranchement multi-voies base sur une valeur :\n\n### Switch basique\n\n```hemlock\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"un\");\n        break;\n    case 2:\n        print(\"deux\");\n        break;\n    case 3:\n        print(\"trois\");\n        break;\n}\n```\n\n### Switch avec Default\n\n```hemlock\nlet color = \"blue\";\n\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"yellow\":\n        print(\"ralentir\");\n        break;\n    case \"green\":\n        print(\"passer\");\n        break;\n    default:\n        print(\"couleur inconnue\");\n        break;\n}\n```\n\n**Regles :**\n- `default` correspond quand aucun autre case ne correspond\n- `default` peut apparaitre n'importe ou dans le corps du switch\n- Un seul case default autorise\n\n### Comportement de fall-through\n\nLes cases sans `break` passent au case suivant (comportement style C). C'est **intentionnel** et peut etre utilise pour grouper les cases :\n\n```hemlock\nlet grade = 85;\n\nswitch (grade) {\n    case 100:\n    case 95:\n    case 90:\n        print(\"A\");\n        break;\n    case 85:\n    case 80:\n        print(\"B\");\n        break;\n    default:\n        print(\"C ou moins\");\n        break;\n}\n```\n\n**Exemple de fallthrough explicite :**\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n        print(\"Jour de semaine\");\n        break;\n    case 6:\n    case 7:\n        print(\"Week-end\");\n        break;\n}\n```\n\n**Important :** Contrairement a certains langages modernes, Hemlock ne necessite PAS de mot-cle `fallthrough` explicite. Les cases passent automatiquement au suivant sauf s'ils sont termines par `break`, `return` ou `throw`. Utilisez toujours `break` pour eviter le fallthrough involontaire.\n\n### Switch avec Return\n\nDans les fonctions, `return` quitte immediatement le switch :\n\n```hemlock\nfn get_day_name(day: i32): string {\n    switch (day) {\n        case 1:\n            return \"Lundi\";\n        case 2:\n            return \"Mardi\";\n        case 3:\n            return \"Mercredi\";\n        default:\n            return \"Inconnu\";\n    }\n}\n```\n\n### Types de valeur Switch\n\nSwitch fonctionne avec n'importe quel type de valeur :\n\n```hemlock\n// Entiers\nswitch (count) {\n    case 0: print(\"zero\"); break;\n    case 1: print(\"un\"); break;\n}\n\n// Chaines\nswitch (name) {\n    case \"Alice\": print(\"A\"); break;\n    case \"Bob\": print(\"B\"); break;\n}\n\n// Booleens\nswitch (flag) {\n    case true: print(\"actif\"); break;\n    case false: print(\"inactif\"); break;\n}\n```\n\n**Note :** Les cases sont compares par egalite de valeur.\n\n## Break et Continue\n\n### Break\n\nQuitter la boucle ou le switch le plus interne :\n\n```hemlock\n// Dans les boucles\nlet i = 0;\nwhile (true) {\n    if (i >= 10) {\n        break;  // Quitter la boucle\n    }\n    print(i);\n    i = i + 1;\n}\n\n// Dans switch\nswitch (x) {\n    case 1:\n        print(\"un\");\n        break;  // Quitter le switch\n    case 2:\n        print(\"deux\");\n        break;\n}\n```\n\n### Continue\n\nPasser a l'iteration suivante de la boucle :\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;  // Sauter l'iteration quand i est 5\n    }\n    print(i);  // Affiche 0,1,2,3,4,6,7,8,9\n}\n```\n\n**Difference :**\n- `break` - Quitte entierement la boucle\n- `continue` - Passe a l'iteration suivante\n\n## Labels de boucle\n\nLes labels de boucle permettent a `break` et `continue` de cibler des boucles externes specifiques au lieu de la boucle la plus interne. C'est utile pour les boucles imbriquees ou vous devez controler une boucle externe depuis une boucle interne.\n\n### Break labele\n\nQuitter une boucle externe depuis une boucle interne :\n\n```hemlock\nouter: while (i < 3) {\n    let j = 0;\n    while (j < 3) {\n        if (i == 1 && j == 1) {\n            break outer;  // Quitter la boucle while externe\n        }\n        print(i * 10 + j);\n        j = j + 1;\n    }\n    i = i + 1;\n}\n// Affiche : 0, 1, 2, 10 (s'arrete a i=1, j=1)\n```\n\n### Continue labele\n\nPasser a l'iteration suivante d'une boucle externe :\n\n```hemlock\nlet i = 0;\nouter: while (i < 3) {\n    i = i + 1;\n    let j = 0;\n    while (j < 3) {\n        j = j + 1;\n        if (i == 2 && j == 1) {\n            continue outer;  // Sauter le reste de la boucle interne, continuer externe\n        }\n        print(i * 10 + j);\n    }\n}\n// Quand i=2, j=1 : saute a l'iteration externe suivante\n```\n\n### Labels avec boucles For\n\nLes labels fonctionnent avec tous les types de boucle :\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 3; y = y + 1) {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n    }\n}\n```\n\n### Labels avec boucles For-In\n\n```hemlock\nlet arr1 = [1, 2, 3];\nlet arr2 = [10, 20, 30];\n\nouter: for (let a in arr1) {\n    for (let b in arr2) {\n        if (a == 2 && b == 20) {\n            break outer;\n        }\n        print(a * 100 + b);\n    }\n}\n```\n\n### Labels avec mot-cle Loop\n\n```hemlock\nlet x = 0;\nouter: loop {\n    let y = 0;\n    loop {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n        y = y + 1;\n        if (y >= 3) { break; }\n    }\n    x = x + 1;\n    if (x >= 3) { break; }\n}\n```\n\n### Labels multiples\n\nVous pouvez avoir des labels a differents niveaux d'imbrication :\n\n```hemlock\nouter: for (let a = 0; a < 2; a = a + 1) {\n    inner: for (let b = 0; b < 3; b = b + 1) {\n        for (let c = 0; c < 3; c = c + 1) {\n            if (c == 1) {\n                continue inner;  // Passer a l'iteration suivante de la boucle du milieu\n            }\n            if (a == 1 && b == 1) {\n                break outer;      // Quitter la boucle la plus externe\n            }\n            print(a * 100 + b * 10 + c);\n        }\n    }\n}\n```\n\n### Break/Continue non labeles avec boucles labelees\n\nLes `break` et `continue` non labeles fonctionnent toujours normalement (affectant la boucle la plus interne), meme quand les boucles externes ont des labels :\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 5; y = y + 1) {\n        if (y == 2) {\n            break;  // Ne sort que de la boucle interne\n        }\n        print(x * 10 + y);\n    }\n}\n// Affiche : 0, 1, 10, 11, 20, 21\n```\n\n### Syntaxe des labels\n\n- Les labels sont des identifiants suivis de deux-points\n- Les labels doivent immediatement preceder une instruction de boucle (`while`, `for`, `loop`)\n- Les noms de label suivent les regles d'identifiant (lettres, chiffres, underscores)\n- Conventions courantes : `outer`, `inner`, `row`, `col`, noms descriptifs\n\n## Instruction Defer\n\nL'instruction `defer` planifie du code pour s'executer quand la fonction courante retourne. C'est utile pour les operations de nettoyage comme fermer des fichiers, liberer des ressources ou relacher des verrous.\n\n### Defer basique\n\n```hemlock\nfn example() {\n    print(\"debut\");\n    defer print(\"nettoyage\");  // S'execute quand la fonction retourne\n    print(\"fin\");\n}\n\nexample();\n// Sortie :\n// debut\n// fin\n// nettoyage\n```\n\n**Comportement cle :**\n- Les instructions differees s'executent **apres** que le corps de la fonction soit termine\n- Les instructions differees s'executent **avant** que la fonction ne retourne a son appelant\n- Les instructions differees s'executent toujours, meme si la fonction leve une exception\n\n### Defers multiples (ordre LIFO)\n\nQuand plusieurs instructions `defer` sont utilisees, elles s'executent dans l'**ordre inverse** (Dernier-Entre-Premier-Sorti) :\n\n```hemlock\nfn example() {\n    defer print(\"premier\");   // S'execute en dernier\n    defer print(\"second\");    // S'execute en second\n    defer print(\"troisieme\"); // S'execute en premier\n    print(\"corps\");\n}\n\nexample();\n// Sortie :\n// corps\n// troisieme\n// second\n// premier\n```\n\nCet ordre LIFO est intentionnel - il correspond a l'ordre naturel pour le nettoyage de ressources imbriquees (fermer les ressources internes avant les externes).\n\n### Defer avec Return\n\nLes instructions differees s'executent avant que `return` ne transfere le controle :\n\n```hemlock\nfn get_value(): i32 {\n    defer print(\"nettoyage\");\n    print(\"avant return\");\n    return 42;\n}\n\nlet result = get_value();\nprint(\"resultat:\", result);\n// Sortie :\n// avant return\n// nettoyage\n// resultat: 42\n```\n\n### Defer avec exceptions\n\nLes instructions differees s'executent meme quand une exception est levee :\n\n```hemlock\nfn risky() {\n    defer print(\"nettoyage 1\");\n    defer print(\"nettoyage 2\");\n    print(\"avant throw\");\n    throw \"erreur!\";\n    print(\"apres throw\");  // Jamais atteint\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(\"Attrape:\", e);\n}\n// Sortie :\n// avant throw\n// nettoyage 2\n// nettoyage 1\n// Attrape: erreur!\n```\n\n### Modele de nettoyage de ressource\n\nLe cas d'utilisation principal de `defer` est d'assurer que les ressources sont nettoyees :\n\n```hemlock\nfn process_file(filename: string) {\n    let file = open(filename, \"r\");\n    defer file.close();  // Ferme toujours, meme en cas d'erreur\n\n    let content = file.read();\n    // ... traiter le contenu ...\n\n    // Fichier automatiquement ferme quand la fonction retourne\n}\n```\n\n**Sans defer (propice aux erreurs) :**\n```hemlock\nfn process_file_bad(filename: string) {\n    let file = open(filename, \"r\");\n    let content = file.read();\n    // Si cela leve une exception, file.close() n'est jamais appele !\n    process(content);\n    file.close();\n}\n```\n\n### Defer avec fermetures\n\nDefer peut utiliser des fermetures pour capturer l'etat :\n\n```hemlock\nfn example() {\n    let resource = acquire_resource();\n    defer fn() {\n        print(\"Liberation de la ressource\");\n        release(resource);\n    }();  // Note : expression de fonction immediatement invoquee\n\n    use_resource(resource);\n}\n```\n\n### Quand utiliser Defer\n\n**Utilisez defer pour :**\n- Fermer des fichiers et connexions reseau\n- Liberer la memoire allouee\n- Relacher des verrous et mutex\n- Nettoyage dans toute fonction qui acquiert des ressources\n\n**Defer vs Finally :**\n- `defer` est plus simple pour le nettoyage de ressource unique\n- `try/finally` est mieux pour la gestion d'erreur complexe avec recuperation\n\n### Bonnes pratiques\n\n1. **Placez defer immediatement apres l'acquisition d'une ressource :**\n   ```hemlock\n   let file = open(\"data.txt\", \"r\");\n   defer file.close();\n   // ... utiliser file ...\n   ```\n\n2. **Utilisez plusieurs defers pour plusieurs ressources :**\n   ```hemlock\n   let file1 = open(\"input.txt\", \"r\");\n   defer file1.close();\n\n   let file2 = open(\"output.txt\", \"w\");\n   defer file2.close();\n\n   // Les deux fichiers seront fermes dans l'ordre inverse\n   ```\n\n3. **Rappelez-vous l'ordre LIFO pour les ressources dependantes :**\n   ```hemlock\n   let outer = acquire_outer();\n   defer release_outer(outer);\n\n   let inner = acquire_inner(outer);\n   defer release_inner(inner);\n\n   // inner libere avant outer (ordre de dependance correct)\n   ```\n\n## Operateurs booleens\n\n### ET logique (`&&`)\n\nLes deux conditions doivent etre vraies :\n\n```hemlock\nif (x > 0 && x < 10) {\n    print(\"chiffre positif\");\n}\n```\n\n**Evaluation court-circuit :**\n```hemlock\nif (false && expensive_check()) {\n    // expensive_check() jamais appelee\n}\n```\n\n### OU logique (`||`)\n\nAu moins une condition doit etre vraie :\n\n```hemlock\nif (x < 0 || x > 100) {\n    print(\"hors plage\");\n}\n```\n\n**Evaluation court-circuit :**\n```hemlock\nif (true || expensive_check()) {\n    // expensive_check() jamais appelee\n}\n```\n\n### NON logique (`!`)\n\nInverse la valeur booleenne :\n\n```hemlock\nif (!is_valid) {\n    print(\"invalide\");\n}\n\nif (!(x > 10)) {\n    // Equivalent a : if (x <= 10)\n}\n```\n\n## Operateurs de comparaison\n\n### Egalite\n\n```hemlock\nif (x == 10) { }    // Egal\nif (x != 10) { }    // Different\n```\n\nFonctionne avec tous les types :\n```hemlock\n\"hello\" == \"hello\"  // true\ntrue == false       // false\nnull == null        // true\n```\n\n### Relationnel\n\n```hemlock\nif (x < 10) { }     // Inferieur a\nif (x > 10) { }     // Superieur a\nif (x <= 10) { }    // Inferieur ou egal\nif (x >= 10) { }    // Superieur ou egal\n```\n\n**La promotion de type s'applique :**\n```hemlock\nlet a: i32 = 10;\nlet b: i64 = 10;\nif (a == b) { }     // true (i32 promu vers i64)\n```\n\n## Operateurs binaires (bitwise)\n\nHemlock fournit des operateurs binaires pour la manipulation d'entiers. Ceux-ci fonctionnent **uniquement avec les types entiers** (i8-i64, u8-u64).\n\n### Operateurs binaires binaires\n\n**ET binaire (`&`)**\n```hemlock\nlet a = 12;  // 1100 en binaire\nlet b = 10;  // 1010 en binaire\nprint(a & b);   // 8 (1000)\n```\n\n**OU binaire (`|`)**\n```hemlock\nprint(a | b);   // 14 (1110)\n```\n\n**XOR binaire (`^`)**\n```hemlock\nprint(a ^ b);   // 6 (0110)\n```\n\n**Decalage a gauche (`<<`)**\n```hemlock\nprint(a << 2);  // 48 (110000) - decaler a gauche de 2\n```\n\n**Decalage a droite (`>>`)**\n```hemlock\nprint(a >> 1);  // 6 (110) - decaler a droite de 1\n```\n\n### Operateur binaire unaire\n\n**NON binaire (`~`)**\n```hemlock\nlet a = 12;\nprint(~a);      // -13 (complement a deux)\n\nlet c: u8 = 15;   // 00001111 en binaire\nprint(~c);        // 240 (11110000) en u8\n```\n\n### Exemples binaires\n\n**Avec types non signes :**\n```hemlock\nlet c: u8 = 15;   // 00001111 en binaire\nlet d: u8 = 7;    // 00000111 en binaire\n\nprint(c & d);     // 7  (00000111)\nprint(c | d);     // 15 (00001111)\nprint(c ^ d);     // 8  (00001000)\nprint(~c);        // 240 (11110000) - en u8\n```\n\n**Preservation du type :**\n```hemlock\n// Les operations binaires preservent le type des operandes\nlet x: u8 = 255;\nlet result = ~x;  // result est u8 avec valeur 0\n\nlet y: i32 = 100;\nlet result2 = y << 2;  // result2 est i32 avec valeur 400\n```\n\n**Modeles courants :**\n```hemlock\n// Verifier si un bit est defini\nif (flags & 0x04) {\n    print(\"bit 2 est defini\");\n}\n\n// Definir un bit\nflags = flags | 0x08;\n\n// Effacer un bit\nflags = flags & ~0x02;\n\n// Inverser un bit\nflags = flags ^ 0x01;\n```\n\n### Priorite des operateurs\n\nLes operateurs binaires suivent la priorite style C :\n\n1. `~` (NON unaire) - plus haute, meme niveau que `!` et `-`\n2. `<<`, `>>` (decalages) - plus haute que comparaisons, plus basse que `+`/`-`\n3. `&` (ET binaire) - plus haute que `^` et `|`\n4. `^` (XOR binaire) - entre `&` et `|`\n5. `|` (OU binaire) - plus basse que `&` et `^`, plus haute que `&&`\n6. `&&`, `||` (logiques) - priorite la plus basse\n\n**Exemples :**\n```hemlock\n// & a une priorite plus haute que |\nlet result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12\n\n// Decalage a une priorite plus haute que les operateurs binaires\nlet result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12\n\n// Utilisez des parentheses pour la clarte\nlet result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5\n```\n\n**Notes importantes :**\n- Les operateurs binaires fonctionnent uniquement avec les types entiers (pas les flottants, chaines, etc.)\n- La promotion de type suit les regles standard (les types plus petits sont promus vers les plus grands)\n- Le decalage a droite (`>>`) est arithmetique pour les types signes, logique pour les non signes\n- Les quantites de decalage ne sont pas verifiees (comportement dependant de la plateforme pour les grands decalages)\n\n## Priorite des operateurs (complete)\n\nDe la priorite la plus haute a la plus basse :\n\n1. **Unaire** : `!`, `-`, `~`\n2. **Multiplicatif** : `*`, `/`, `%`\n3. **Additif** : `+`, `-`\n4. **Decalage** : `<<`, `>>`\n5. **Relationnel** : `<`, `>`, `<=`, `>=`\n6. **Egalite** : `==`, `!=`\n7. **ET binaire** : `&`\n8. **XOR binaire** : `^`\n9. **OU binaire** : `|`\n10. **ET logique** : `&&`\n11. **OU logique** : `||`\n\n**Utilisez des parentheses pour la clarte :**\n```hemlock\n// Pas clair\nif (a || b && c) { }\n\n// Clair\nif (a || (b && c)) { }\nif ((a || b) && c) { }\n```\n\n## Modeles courants\n\n### Modele : Validation d'entree\n\n```hemlock\nfn validate_age(age: i32): bool {\n    if (age < 0 || age > 150) {\n        return false;\n    }\n    return true;\n}\n```\n\n### Modele : Verification de plage\n\n```hemlock\nfn in_range(value: i32, min: i32, max: i32): bool {\n    return value >= min && value <= max;\n}\n\nif (in_range(score, 0, 100)) {\n    print(\"score valide\");\n}\n```\n\n### Modele : Machine a etats\n\n```hemlock\nlet state = \"start\";\n\nwhile (true) {\n    switch (state) {\n        case \"start\":\n            print(\"Demarrage...\");\n            state = \"running\";\n            break;\n\n        case \"running\":\n            if (should_pause) {\n                state = \"paused\";\n            } else if (should_stop) {\n                state = \"stopped\";\n            }\n            break;\n\n        case \"paused\":\n            if (should_resume) {\n                state = \"running\";\n            }\n            break;\n\n        case \"stopped\":\n            print(\"Arrete\");\n            break;\n    }\n\n    if (state == \"stopped\") {\n        break;\n    }\n}\n```\n\n### Modele : Iteration avec filtrage\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// Afficher uniquement les nombres pairs\nfor (let i = 0; i < arr.length; i = i + 1) {\n    if (arr[i] % 2 != 0) {\n        continue;  // Sauter les nombres impairs\n    }\n    print(arr[i]);\n}\n```\n\n### Modele : Sortie anticipee\n\n```hemlock\nfn find_first_negative(arr: array): i32 {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Sortie anticipee\n        }\n    }\n    return -1;  // Non trouve\n}\n```\n\n## Bonnes pratiques\n\n1. **Utilisez toujours des accolades** - Meme pour les blocs a instruction unique (impose par la syntaxe)\n2. **Conditions explicites** - Utilisez `x == 0` au lieu de `!x` pour la clarte\n3. **Evitez l'imbrication profonde** - Extrayez les conditions imbriquees en fonctions\n4. **Utilisez les retours anticipes** - Reduisez l'imbrication avec des clauses de garde\n5. **Divisez les conditions complexes** - Divisez en variables booleennes nommees\n6. **Default dans switch** - Incluez toujours un case default\n7. **Commentez le fall-through** - Rendez le fall-through intentionnel explicite\n\n## Pieges courants\n\n### Piege : Assignation dans la condition\n\n```hemlock\n// Ceci n'est PAS autorise (pas d'assignation dans les conditions)\nif (x = 10) { }  // ERREUR : Erreur de syntaxe\n\n// Utilisez la comparaison a la place\nif (x == 10) { }  // OK\n```\n\n### Piege : Break manquant dans Switch\n\n```hemlock\n// Fall-through involontaire\nswitch (x) {\n    case 1:\n        print(\"un\");\n        // Break manquant - fall-through !\n    case 2:\n        print(\"deux\");  // S'execute pour 1 et 2\n        break;\n}\n\n// Correction : Ajouter break\nswitch (x) {\n    case 1:\n        print(\"un\");\n        break;  // Maintenant correct\n    case 2:\n        print(\"deux\");\n        break;\n}\n```\n\n### Piege : Portee de variable de boucle\n\n```hemlock\n// i a une portee limitee a la boucle\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\nprint(i);  // ERREUR : i non defini ici\n```\n\n## Exemples\n\n### Exemple : FizzBuzz\n\n```hemlock\nfor (let i = 1; i <= 100; i = i + 1) {\n    if (i % 15 == 0) {\n        print(\"FizzBuzz\");\n    } else if (i % 3 == 0) {\n        print(\"Fizz\");\n    } else if (i % 5 == 0) {\n        print(\"Buzz\");\n    } else {\n        print(i);\n    }\n}\n```\n\n### Exemple : Verificateur de nombre premier\n\n```hemlock\nfn is_prime(n: i32): bool {\n    if (n < 2) {\n        return false;\n    }\n\n    let i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            return false;\n        }\n        i = i + 1;\n    }\n\n    return true;\n}\n```\n\n### Exemple : Systeme de menu\n\n```hemlock\nfn menu() {\n    while (true) {\n        print(\"1. Demarrer\");\n        print(\"2. Parametres\");\n        print(\"3. Quitter\");\n\n        let choice = get_input();\n\n        switch (choice) {\n            case 1:\n                start_game();\n                break;\n            case 2:\n                show_settings();\n                break;\n            case 3:\n                print(\"Au revoir !\");\n                return;\n            default:\n                print(\"Choix invalide\");\n                break;\n        }\n    }\n}\n```\n\n## Sujets connexes\n\n- [Fonctions](#language-guide-functions) - Flux de controle avec appels de fonction et retours\n- [Gestion des erreurs](#language-guide-error-handling) - Flux de controle avec exceptions\n- [Types](#language-guide-types) - Conversions de type dans les conditions\n\n## Voir aussi\n\n- **Syntaxe** : Voir [Syntaxe](#language-guide-syntax) pour les details de syntaxe des instructions\n- **Operateurs** : Voir [Types](#language-guide-types) pour la promotion de type dans les operations\n"}, "Guide du Langage -> Fonctions": {"id": "language-guide-functions", "content": "# Fonctions\n\nLes fonctions en Hemlock sont des **valeurs de premiere classe** qui peuvent etre assignees a des variables, passees en arguments et retournees par d'autres fonctions. Ce guide couvre la syntaxe des fonctions, les fermetures, la recursivite et les modeles avances.\n\n## Apercu\n\n```hemlock\n// Syntaxe de fonction nommee\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\n// Fonction anonyme\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\n// Fermetures\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nprint(add5(3));  // 8\n```\n\n## Declaration de fonction\n\n### Fonctions nommees\n\n```hemlock\nfn greet(name: string): string {\n    return \"Bonjour, \" + name;\n}\n\nlet msg = greet(\"Alice\");  // \"Bonjour, Alice\"\n```\n\n**Composants :**\n- `fn` - Mot-cle fonction\n- `greet` - Nom de la fonction\n- `(name: string)` - Parametres avec types optionnels\n- `: string` - Type de retour optionnel\n- `{ ... }` - Corps de la fonction\n\n### Fonctions anonymes\n\nFonctions sans nom, assignees a des variables :\n\n```hemlock\nlet square = fn(x) {\n    return x * x;\n};\n\nprint(square(5));  // 25\n```\n\n**Nommee vs. Anonyme :**\n```hemlock\n// Ces deux sont equivalentes :\nfn add(a, b) { return a + b; }\n\nlet add = fn(a, b) { return a + b; };\n```\n\n**Note :** Les fonctions nommees se transforment en assignations de variables avec des fonctions anonymes.\n\n## Parametres\n\n### Parametres basiques\n\n```hemlock\nfn example(a, b, c) {\n    return a + b + c;\n}\n\nlet result = example(1, 2, 3);  // 6\n```\n\n### Annotations de type\n\nAnnotations de type optionnelles sur les parametres :\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);      // OK\nadd(5, 10.5);    // La verification de type a l'execution promeut vers f64\n```\n\n**Verification de type :**\n- Les types de parametre sont verifies a l'appel si annotes\n- Les conversions de type implicites suivent les regles de promotion standard\n- Les incompatibilites de type causent des erreurs a l'execution\n\n### Passage par valeur\n\nTous les arguments sont **copies** (passage par valeur) :\n\n```hemlock\nfn modify(x) {\n    x = 100;  // Modifie uniquement la copie locale\n}\n\nlet a = 10;\nmodify(a);\nprint(a);  // Toujours 10 (inchange)\n```\n\n**Note :** Les objets et tableaux sont passes par reference (la reference est copiee), donc leur contenu peut etre modifie :\n\n```hemlock\nfn modify_array(arr) {\n    arr[0] = 99;  // Modifie le tableau original\n}\n\nlet a = [1, 2, 3];\nmodify_array(a);\nprint(a[0]);  // 99 (modifie)\n```\n\n## Valeurs de retour\n\n### Instruction return\n\n```hemlock\nfn get_max(a: i32, b: i32): i32 {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n```\n\n### Annotations de type de retour\n\nAnnotation de type optionnelle pour la valeur de retour :\n\n```hemlock\nfn calculate(): f64 {\n    return 3.14159;\n}\n\nfn get_name(): string {\n    return \"Alice\";\n}\n```\n\n**Verification de type :**\n- Les types de retour sont verifies quand la fonction retourne (si annotes)\n- Les conversions de type suivent les regles de promotion standard\n\n### Retour implicite\n\nLes fonctions sans annotation de type de retour retournent implicitement `null` :\n\n```hemlock\nfn print_message(msg) {\n    print(msg);\n    // Retourne implicitement null\n}\n\nlet result = print_message(\"bonjour\");  // result est null\n```\n\n### Retour anticipe\n\n```hemlock\nfn find_first_negative(arr) {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Sortie anticipee\n        }\n    }\n    return -1;  // Non trouve\n}\n```\n\n### Retour sans valeur\n\n`return;` sans valeur retourne `null` :\n\n```hemlock\nfn maybe_process(value) {\n    if (value < 0) {\n        return;  // Retourne null\n    }\n    return value * 2;\n}\n```\n\n## Fonctions de premiere classe\n\nLes fonctions peuvent etre assignees, passees et retournees comme n'importe quelle autre valeur.\n\n### Fonctions comme variables\n\n```hemlock\nlet operation = fn(x, y) { return x + y; };\n\nprint(operation(5, 3));  // 8\n\n// Reassigner\noperation = fn(x, y) { return x * y; };\nprint(operation(5, 3));  // 15\n```\n\n### Fonctions comme arguments\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 5);  // 10\n```\n\n### Fonctions comme valeurs de retour\n\n```hemlock\nfn get_operation(op: string) {\n    if (op == \"add\") {\n        return fn(a, b) { return a + b; };\n    } else if (op == \"multiply\") {\n        return fn(a, b) { return a * b; };\n    } else {\n        return fn(a, b) { return 0; };\n    }\n}\n\nlet add = get_operation(\"add\");\nprint(add(5, 3));  // 8\n```\n\n## Fermetures (Closures)\n\nLes fonctions capturent leur environnement de definition (portee lexicale).\n\n### Fermetures basiques\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n**Comment ca marche :**\n- La fonction interne capture `count` de la portee externe\n- `count` persiste a travers les appels a la fonction retournee\n- Chaque appel a `makeCounter()` cree une nouvelle fermeture avec son propre `count`\n\n### Fermeture avec parametres\n\n```hemlock\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\n\nprint(add5(3));   // 8\nprint(add10(3));  // 13\n```\n\n### Fermetures multiples\n\n```hemlock\nfn makeOperations(x) {\n    let add = fn(y) { return x + y; };\n    let multiply = fn(y) { return x * y; };\n\n    return { add: add, multiply: multiply };\n}\n\nlet ops = makeOperations(5);\nprint(ops.add(3));       // 8\nprint(ops.multiply(3));  // 15\n```\n\n### Portee lexicale\n\nLes fonctions peuvent acceder aux variables de la portee externe via la portee lexicale :\n\n```hemlock\nlet global = 10;\n\nfn outer() {\n    let outer_var = 20;\n\n    fn inner() {\n        // Peut lire global et outer_var\n        print(global);      // 10\n        print(outer_var);   // 20\n    }\n\n    inner();\n}\n\nouter();\n```\n\nLes fermetures capturent les variables par reference, permettant la lecture et la modification des variables de la portee externe (comme montre dans l'exemple `makeCounter` ci-dessus).\n\n## Recursivite\n\nLes fonctions peuvent s'appeler elles-memes.\n\n### Recursivite basique\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### Recursivite mutuelle\n\nLes fonctions peuvent s'appeler mutuellement :\n\n```hemlock\nfn is_even(n: i32): bool {\n    if (n == 0) {\n        return true;\n    }\n    return is_odd(n - 1);\n}\n\nfn is_odd(n: i32): bool {\n    if (n == 0) {\n        return false;\n    }\n    return is_even(n - 1);\n}\n\nprint(is_even(4));  // true\nprint(is_odd(4));   // false\n```\n\n### Traitement de donnees recursif\n\n```hemlock\nfn sum_array(arr: array, index: i32): i32 {\n    if (index >= arr.length) {\n        return 0;\n    }\n    return arr[index] + sum_array(arr, index + 1);\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(sum_array(numbers, 0));  // 15\n```\n\n**Note :** Pas encore d'optimisation de la recursivite terminale - une recursivite profonde peut causer un debordement de pile.\n\n## Fonctions d'ordre superieur\n\nFonctions qui prennent ou retournent d'autres fonctions.\n\n### Modele Map\n\n```hemlock\nfn map(arr, f) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        result.push(f(arr[i]));\n        i = i + 1;\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = map(numbers, double);  // [2, 4, 6, 8, 10]\n```\n\n### Modele Filter\n\n```hemlock\nfn filter(arr, predicate) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (predicate(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nfn is_even(x) { return x % 2 == 0; }\n\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = filter(numbers, is_even);  // [2, 4, 6]\n```\n\n### Modele Reduce\n\n```hemlock\nfn reduce(arr, f, initial) {\n    let accumulator = initial;\n    let i = 0;\n    while (i < arr.length) {\n        accumulator = f(accumulator, arr[i]);\n        i = i + 1;\n    }\n    return accumulator;\n}\n\nfn add(a, b) { return a + b; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = reduce(numbers, add, 0);  // 15\n```\n\n### Composition de fonctions\n\n```hemlock\nfn compose(f, g) {\n    return fn(x) {\n        return f(g(x));\n    };\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\n\nlet double_then_increment = compose(increment, double);\nprint(double_then_increment(5));  // 11 (5*2 + 1)\n```\n\n## Modeles courants\n\n### Modele : Fonctions usine (Factory)\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Salut, je suis \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Salut, je suis Alice\"\n```\n\n### Modele : Fonctions de rappel (Callback)\n\n```hemlock\nfn process_async(data, callback) {\n    // ... faire le traitement\n    callback(data);\n}\n\nprocess_async(\"test\", fn(result) {\n    print(\"Traitement termine : \" + result);\n});\n```\n\n### Modele : Application partielle\n\n```hemlock\nfn partial(f, x) {\n    return fn(y) {\n        return f(x, y);\n    };\n}\n\nfn multiply(a, b) {\n    return a * b;\n}\n\nlet double = partial(multiply, 2);\nlet triple = partial(multiply, 3);\n\nprint(double(5));  // 10\nprint(triple(5));  // 15\n```\n\n### Modele : Memoisation\n\n```hemlock\nfn memoize(f) {\n    let cache = {};\n\n    return fn(x) {\n        if (cache.has(x)) {\n            return cache[x];\n        }\n\n        let result = f(x);\n        cache[x] = result;\n        return result;\n    };\n}\n\nfn expensive_fibonacci(n) {\n    if (n <= 1) { return n; }\n    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);\n}\n\nlet fast_fib = memoize(expensive_fibonacci);\nprint(fast_fib(10));  // Beaucoup plus rapide avec le cache\n```\n\n## Semantique des fonctions\n\n### Exigences de type de retour\n\nLes fonctions avec annotation de type de retour **doivent** retourner une valeur :\n\n```hemlock\nfn get_value(): i32 {\n    // ERREUR : Instruction return manquante\n}\n\nfn get_value(): i32 {\n    return 42;  // OK\n}\n```\n\n### Verification de type\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);        // OK\nadd(5.5, 10.5);    // Promeut vers f64, retourne f64\nadd(\"a\", \"b\");     // Erreur d'execution : type mismatch\n```\n\n### Regles de portee\n\n```hemlock\nlet global = \"global\";\n\nfn outer() {\n    let outer_var = \"outer\";\n\n    fn inner() {\n        let inner_var = \"inner\";\n        // Peut acceder : inner_var, outer_var, global\n    }\n\n    // Peut acceder : outer_var, global\n    // Ne peut pas acceder : inner_var\n}\n\n// Peut acceder : global\n// Ne peut pas acceder : outer_var, inner_var\n```\n\n## Bonnes pratiques\n\n1. **Utilisez des annotations de type** - Aide a detecter les erreurs et documente l'intention\n2. **Gardez les fonctions petites** - Chaque fonction devrait faire une seule chose\n3. **Preferez les fonctions pures** - Evitez les effets de bord quand possible\n4. **Nommez les fonctions clairement** - Utilisez des noms de verbes descriptifs\n5. **Retournez tot** - Utilisez des clauses de garde pour reduire l'imbrication\n6. **Documentez les fermetures complexes** - Rendez les variables capturees explicites\n7. **Evitez la recursivite profonde** - Pas encore d'optimisation de la recursivite terminale\n\n## Pieges courants\n\n### Piege : Profondeur de recursivite\n\n```hemlock\n// La recursivite profonde peut causer un debordement de pile\nfn count_down(n) {\n    if (n == 0) { return; }\n    count_down(n - 1);\n}\n\ncount_down(100000);  // Peut planter avec un debordement de pile\n```\n\n### Piege : Modification des variables capturees\n\n```hemlock\nfn make_counter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Peut lire et modifier les variables capturees\n        return count;\n    };\n}\n```\n\n**Note :** Cela fonctionne, mais soyez conscient que toutes les fermetures partagent le meme environnement capture.\n\n## Exemples\n\n### Exemple : Pipeline de fonctions\n\n```hemlock\nfn pipeline(value, ...functions) {\n    let result = value;\n    for (f in functions) {\n        result = f(result);\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\nfn square(x) { return x * x; }\n\nlet result = pipeline(3, double, increment, square);\nprint(result);  // 49 ((3*2+1)^2)\n```\n\n### Exemple : Gestionnaire d'evenements\n\n```hemlock\nlet handlers = [];\n\nfn on_event(name: string, handler) {\n    handlers.push({ name: name, handler: handler });\n}\n\nfn trigger_event(name: string, data) {\n    let i = 0;\n    while (i < handlers.length) {\n        if (handlers[i].name == name) {\n            handlers[i].handler(data);\n        }\n        i = i + 1;\n    }\n}\n\non_event(\"click\", fn(data) {\n    print(\"Clique : \" + data);\n});\n\ntrigger_event(\"click\", \"button1\");\n```\n\n### Exemple : Tri avec comparateur personnalise\n\n```hemlock\nfn sort(arr, compare) {\n    // Tri a bulles avec comparateur personnalise\n    let n = arr.length;\n    let i = 0;\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (compare(arr[j], arr[j + 1]) > 0) {\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nfn ascending(a, b) {\n    if (a < b) { return -1; }\n    if (a > b) { return 1; }\n    return 0;\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers, ascending);\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## Parametres optionnels (arguments par defaut)\n\nLes fonctions peuvent avoir des parametres optionnels avec des valeurs par defaut en utilisant la syntaxe `?:` :\n\n```hemlock\nfn greet(name, greeting?: \"Bonjour\") {\n    return greeting + \" \" + name;\n}\n\nprint(greet(\"Alice\"));           // \"Bonjour Alice\"\nprint(greet(\"Bob\", \"Salut\"));    // \"Salut Bob\"\n\nfn add(a, b?: 10, c?: 100) {\n    return a + b + c;\n}\n\nprint(add(1));          // 111 (1 + 10 + 100)\nprint(add(1, 2));       // 103 (1 + 2 + 100)\nprint(add(1, 2, 3));    // 6   (1 + 2 + 3)\n```\n\n**Regles :**\n- Les parametres optionnels doivent venir apres les parametres requis\n- Les valeurs par defaut peuvent etre n'importe quelle expression\n- Les arguments omis utilisent la valeur par defaut\n\n## Fonctions variadiques (parametres rest)\n\nLes fonctions peuvent accepter un nombre variable d'arguments en utilisant les parametres rest (`...`) :\n\n```hemlock\nfn sum(...args) {\n    let total = 0;\n    for (arg in args) {\n        total = total + arg;\n    }\n    return total;\n}\n\nprint(sum(1, 2, 3));        // 6\nprint(sum(1, 2, 3, 4, 5));  // 15\nprint(sum());               // 0\n\nfn log(prefix, ...messages) {\n    for (msg in messages) {\n        print(prefix + \": \" + msg);\n    }\n}\n\nlog(\"INFO\", \"Demarrage\", \"Execution\", \"Termine\");\n// INFO: Demarrage\n// INFO: Execution\n// INFO: Termine\n```\n\n**Regles :**\n- Le parametre rest doit etre le dernier parametre\n- Le parametre rest collecte tous les arguments restants dans un tableau\n- Peut etre combine avec des parametres reguliers et optionnels\n\n## Annotations de type de fonction\n\nLes types de fonction permettent de specifier la signature exacte attendue pour les parametres de fonction et les valeurs de retour :\n\n### Types de fonction basiques\n\n```hemlock\n// Syntaxe de type de fonction : fn(param_types): return_type\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\nlet double = fn(n) { return n * 2; };\nlet result = apply(double, 5);  // 10\n```\n\n### Types de fonction d'ordre superieur\n\n```hemlock\n// Fonction retournant une fonction\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\nlet add5 = make_adder(5);\nprint(add5(10));  // 15\n```\n\n### Types de fonction asynchrone\n\n```hemlock\n// Type de fonction asynchrone\nfn run_task(handler: async fn(): void) {\n    spawn(handler);\n}\n\nrun_task(async fn() {\n    print(\"Execution asynchrone !\");\n});\n```\n\n### Alias de type de fonction\n\n```hemlock\n// Creer des types de fonction nommes pour la clarte\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\nfn filter_with(arr: array, pred: Predicate): array {\n    return arr.filter(pred);\n}\n```\n\n## Parametres const\n\nLe modificateur `const` empeche un parametre d'etre modifie dans la fonction :\n\n### Parametres const basiques\n\n```hemlock\nfn print_all(const items: array) {\n    // items.push(4);  // ERREUR : cannot mutate const parameter\n    for (item in items) {\n        print(item);   // OK : la lecture est autorisee\n    }\n}\n\nlet nums = [1, 2, 3];\nprint_all(nums);\n```\n\n### Immutabilite profonde\n\nLes parametres const appliquent une immutabilite profonde - pas de modification via aucun chemin :\n\n```hemlock\nfn describe(const person: object) {\n    print(person.name);       // OK : la lecture est autorisee\n    // person.name = \"Bob\";   // ERREUR : cannot mutate\n    // person.address.city = \"NYC\";  // ERREUR : const profond\n}\n```\n\n### Ce que const empeche\n\n| Type | Bloque par const | Autorise |\n|------|------------------|----------|\n| array | push, pop, shift, unshift, insert, remove, clear, reverse | slice, concat, map, filter, find, contains |\n| object | assignation de champ | lecture de champ |\n| buffer | assignation d'index | lecture d'index |\n| string | assignation d'index | toutes les methodes (retournent de nouvelles chaines) |\n\n## Arguments nommes\n\nLes fonctions peuvent etre appelees avec des arguments nommes pour plus de clarte et de flexibilite :\n\n### Arguments nommes basiques\n\n```hemlock\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" a \" + age + \" ans\");\n}\n\n// Arguments positionnels (traditionnel)\ncreate_user(\"Alice\", 25, false);\n\n// Arguments nommes - peuvent etre dans n'importe quel ordre\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n```\n\n### Melanger positionnel et nomme\n\n```hemlock\n// Sauter les parametres optionnels en nommant ce dont vous avez besoin\ncreate_user(\"David\", active: false);  // Utilise l'age par defaut=18\n\n// Les arguments nommes doivent venir apres les positionnels\ncreate_user(\"Eve\", age: 21);          // OK\n// create_user(name: \"Bad\", 25);      // ERREUR : positionnel apres nomme\n```\n\n### Regles pour les arguments nommes\n\n- Utilisez la syntaxe `name: value` pour les arguments nommes\n- Les arguments nommes peuvent apparaitre dans n'importe quel ordre apres les arguments positionnels\n- Les arguments positionnels ne peuvent pas suivre les arguments nommes\n- Fonctionne avec les parametres par defaut/optionnels\n- Les noms de parametre inconnus causent des erreurs a l'execution\n\n## Limitations\n\nLimitations actuelles a connaitre :\n\n- **Pas de passage par reference** - Mot-cle `ref` parse mais pas implemente\n- **Pas de surcharge de fonction** - Une fonction par nom\n- **Pas d'optimisation de la recursivite terminale** - Recursivite profonde limitee par la taille de la pile\n\n## Sujets connexes\n\n- [Flux de controle](#language-guide-control-flow) - Utilisation des fonctions avec les structures de controle\n- [Objets](#language-guide-objects) - Les methodes sont des fonctions stockees dans les objets\n- [Gestion des erreurs](#language-guide-error-handling) - Fonctions et gestion des exceptions\n- [Types](#language-guide-types) - Annotations de type et conversions\n\n## Voir aussi\n\n- **Fermetures** : Voir la section \"Functions\" de CLAUDE.md pour la semantique des fermetures\n- **Valeurs de premiere classe** : Les fonctions sont des valeurs comme n'importe quelle autre\n- **Portee lexicale** : Les fonctions capturent leur environnement de definition\n"}, "Guide du Langage -> Gestion de la Mmoire": {"id": "language-guide-memory", "content": "# Gestion de la memoire\n\nHemlock adopte la **gestion manuelle de la memoire** avec un controle explicite sur l'allocation et la desallocation. Ce guide couvre le modele memoire de Hemlock, les deux types de pointeur et l'API memoire complete.\n\n---\n\n## Memoire 101 : Les bases\n\n**Nouveau en programmation ?** Commencez ici. Si vous comprenez deja la gestion de la memoire, passez a [Philosophie](#philosophie).\n\n### Qu'est-ce que la gestion de la memoire ?\n\nQuand votre programme a besoin de stocker des donnees (texte, nombres, listes), il a besoin d'espace pour les placer. Cet espace vient de la memoire de votre ordinateur (RAM). La gestion de la memoire concerne :\n\n1. **Obtenir de l'espace** - demander de la memoire quand vous en avez besoin\n2. **Utiliser l'espace** - lire et ecrire vos donnees\n3. **Le rendre** - retourner la memoire quand vous avez fini\n\n### Pourquoi est-ce important ?\n\nImaginez une bibliotheque avec des livres limites :\n- Si vous continuez a emprunter des livres et ne les rendez jamais, il n'y en a plus\n- Si vous essayez de lire un livre que vous avez deja rendu, vous serez confus ou causerez des problemes\n\nLa memoire fonctionne de la meme facon. Si vous oubliez de retourner la memoire, votre programme utilise de plus en plus (une \"fuite memoire\"). Si vous essayez d'utiliser la memoire apres l'avoir rendue, de mauvaises choses arrivent.\n\n### La bonne nouvelle\n\n**La plupart du temps, vous n'avez pas besoin d'y penser !**\n\nHemlock nettoie automatiquement la plupart des types courants :\n\n```hemlock\nfn example() {\n    let name = \"Alice\";       // Hemlock gere ceci\n    let numbers = [1, 2, 3];  // Et ceci\n    let person = { age: 30 }; // Et cela aussi\n\n    // Quand la fonction se termine, tout ceci est nettoye automatiquement !\n}\n```\n\n### Quand vous DEVEZ y penser\n\nVous avez besoin de gestion manuelle de la memoire uniquement quand vous utilisez :\n\n1. **`alloc()`** - allocation de memoire brute (retourne `ptr`)\n2. **`buffer()`** - quand vous voulez liberer tot (optionnel - il s'auto-libere a la fin de portee)\n\n```hemlock\n// Ceci necessite un nettoyage manuel :\nlet raw = alloc(100);   // Memoire brute - VOUS devez la liberer\n// ... utiliser raw ...\nfree(raw);              // Requis ! Sinon vous avez une fuite memoire\n\n// Ceci se nettoie automatiquement (mais vous POUVEZ liberer tot) :\nlet buf = buffer(100);  // Buffer securise\n// ... utiliser buf ...\n// free(buf);           // Optionnel - s'auto-libere quand la portee se termine\n```\n\n### La regle simple\n\n> **Si vous appelez `alloc()`, vous devez appeler `free()`.**\n>\n> Tout le reste est gere pour vous.\n\n### Lequel utiliser ?\n\n| Situation | Utilisez | Pourquoi |\n|-----------|----------|----------|\n| **Debutant** | `buffer()` | Securise, verifie les limites, auto-nettoyage |\n| **Besoin de stockage d'octets** | `buffer()` | Securise et facile |\n| **Travailler avec des bibliotheques C (FFI)** | `alloc()` / `ptr` | Requis pour l'interop C |\n| **Performance maximale** | `alloc()` / `ptr` | Pas de surcharge de verification des limites |\n| **Pas sur** | `buffer()` | Toujours le choix plus sur |\n\n### Exemple rapide : Securise vs Brut\n\n```hemlock\n// RECOMMANDE : Buffer securise\nfn safe_example() {\n    let data = buffer(10);\n    data[0] = 65;           // OK\n    data[5] = 66;           // OK\n    // data[100] = 67;      // ERREUR - Hemlock vous arrete (verification des limites)\n    free(data);             // Nettoyage\n}\n\n// AVANCE : Pointeur brut (seulement quand necessaire)\nfn raw_example() {\n    let data = alloc(10);\n    *data = 65;             // OK\n    *(data + 5) = 66;       // OK\n    *(data + 100) = 67;     // DANGER - Pas de verification des limites, corrompt la memoire !\n    free(data);             // Nettoyage\n}\n```\n\n**Commencez avec `buffer()`. Utilisez `alloc()` seulement quand vous avez specifiquement besoin de pointeurs bruts.**\n\n---\n\n## Philosophie\n\nHemlock suit le principe de gestion explicite de la memoire avec des valeurs par defaut sensees :\n- Pas de garbage collection (pas de pauses imprevisibles)\n- Comptage de reference interne pour les types courants (string, array, object, buffer)\n- Les pointeurs bruts (`ptr`) necessitent un `free()` manuel\n\nCette approche hybride vous donne un controle complet quand necessaire (pointeurs bruts) tout en evitant les bugs courants pour les cas d'utilisation typiques (types comptes par reference auto-liberes a la sortie de portee).\n\n## Comptage de reference interne\n\nLe runtime utilise le **comptage de reference interne** pour gerer les durees de vie des objets. Pour la plupart des variables locales de types comptes par reference, le nettoyage est automatique et deterministe.\n\n### Ce que gere le comptage de reference\n\nLe runtime gere automatiquement les comptes de reference quand :\n\n1. **Les variables sont reassignees** - l'ancienne valeur est liberee :\n   ```hemlock\n   let x = \"first\";   // ref_count = 1\n   x = \"second\";      // \"first\" libere en interne, \"second\" ref_count = 1\n   ```\n\n2. **Les portees se terminent** - les variables locales sont liberees :\n   ```hemlock\n   fn example() {\n       let arr = [1, 2, 3];  // ref_count = 1\n   }  // arr libere quand la fonction retourne\n   ```\n\n3. **Les conteneurs sont liberes** - les elements sont liberes :\n   ```hemlock\n   let arr = [obj1, obj2];\n   free(arr);  // obj1 et obj2 voient leur ref_count decremente\n   ```\n\n### Quand vous avez besoin de `free()` vs quand c'est automatique\n\n**Automatique (pas de `free()` necessaire) :** Les variables locales de types comptes par reference sont liberees quand la portee se termine :\n\n```hemlock\nfn process_data() {\n    let arr = [1, 2, 3];\n    let obj = { name: \"test\" };\n    let buf = buffer(64);\n    // ... les utiliser ...\n}  // Tout automatiquement libere quand la fonction retourne - pas de free() necessaire\n```\n\n**`free()` manuel requis :**\n\n1. **Pointeurs bruts** - `alloc()` n'a pas de comptage de reference :\n   ```hemlock\n   let p = alloc(64);\n   // ... utiliser p ...\n   free(p);  // Toujours requis - fuira sinon\n   ```\n\n2. **Nettoyage anticipe** - liberer avant la fin de portee pour liberer la memoire plus tot :\n   ```hemlock\n   fn long_running() {\n       let big = buffer(10000000);  // 10Mo\n       // ... termine avec big ...\n       free(big);  // Liberer maintenant, ne pas attendre que la fonction retourne\n       // ... plus de travail qui n'a pas besoin de big ...\n   }\n   ```\n\n3. **Donnees longue duree** - globales ou donnees stockees dans des structures persistantes :\n   ```hemlock\n   let cache = {};  // Niveau module, vit jusqu'a la fin du programme sauf si libere\n\n   fn cleanup() {\n       free(cache);  // Nettoyage manuel pour donnees longue duree\n   }\n   ```\n\n### Comptage de reference vs Garbage Collection\n\n| Aspect | Comptage ref Hemlock | Garbage Collection |\n|--------|---------------------|-------------------|\n| Moment du nettoyage | Deterministe (immediat quand ref atteint 0) | Non-deterministe (GC decide quand) |\n| Responsabilite utilisateur | Doit appeler `free()` | Entierement automatique |\n| Pauses runtime | Aucune | Pauses \"stop the world\" |\n| Visibilite | Detail d'implementation cache | Generalement invisible |\n| Cycles | Geres avec suivi de visited-set | Geres par tracage |\n\n### Quels types ont le comptage de reference\n\n| Type | Compte par ref | Notes |\n|------|------------|-------|\n| `ptr` | Non | Necessite toujours `free()` manuel |\n| `buffer` | Oui | Auto-libere a la sortie de portee ; `free()` manuel pour nettoyage anticipe |\n| `array` | Oui | Auto-libere a la sortie de portee ; `free()` manuel pour nettoyage anticipe |\n| `object` | Oui | Auto-libere a la sortie de portee ; `free()` manuel pour nettoyage anticipe |\n| `string` | Oui | Entierement automatique, pas de `free()` necessaire |\n| `function` | Oui | Entierement automatique (environnements de fermeture) |\n| `task` | Oui | Comptage de reference atomique thread-safe |\n| `channel` | Oui | Comptage de reference atomique thread-safe |\n| Primitives | Non | Allouees sur la pile, pas d'allocation tas |\n\n### Pourquoi cette conception ?\n\nCette approche hybride vous donne :\n- **Controle explicite** - Vous decidez quand desallouer\n- **Securite des bugs de portee** - La reassignation ne fuit pas\n- **Performance previsible** - Pas de pauses GC\n- **Support des fermetures** - Les fonctions peuvent capturer les variables en securite\n\nLa philosophie reste : vous etes en controle, mais le runtime aide a prevenir les bugs courants comme les fuites a la reassignation ou les double-free dans les conteneurs.\n\n## Les deux types de pointeur\n\nHemlock fournit deux types de pointeur distincts, chacun avec des caracteristiques de securite differentes :\n\n### `ptr` - Pointeur brut (dangereux)\n\nLes pointeurs bruts sont **juste des adresses** avec des garanties de securite minimales :\n\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // Vous devez vous souvenir de liberer\n```\n\n**Caracteristiques :**\n- Juste une adresse de 8 octets\n- Pas de verification des limites\n- Pas de suivi de longueur\n- L'utilisateur gere entierement la duree de vie\n- Pour experts et FFI\n\n**Cas d'utilisation :**\n- Programmation systeme bas niveau\n- Interface de fonction etrangere (FFI)\n- Code critique en performance\n- Quand vous avez besoin d'un controle complet\n\n**Dangers :**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Bien au-dela de l'allocation - autorise mais dangereux\nfree(p);\nlet x = *p;       // Pointeur pendant - comportement indefini\nfree(p);          // Double-free - va planter\n```\n\n### `buffer` - Enveloppe securisee (recommande)\n\nLes buffers fournissent un **acces verifie en limites** tout en necessitant une desallocation manuelle :\n\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // verifie en limites\nprint(b.length);        // 64\nfree(b);                // toujours manuel\n```\n\n**Caracteristiques :**\n- Pointeur + longueur + capacite\n- Verification des limites a l'acces\n- Necessite toujours `free()` manuel\n- Meilleur defaut pour la plupart du code\n\n**Proprietes :**\n```hemlock\nlet buf = buffer(100);\nprint(buf.length);      // 100 (taille actuelle)\nprint(buf.capacity);    // 100 (capacite allouee)\n```\n\n**Verification des limites :**\n```hemlock\nlet buf = buffer(10);\nbuf[5] = 42;      // OK\nbuf[100] = 42;    // ERREUR : Index out of bounds\n```\n\n## API memoire\n\n### Allocation de base\n\n**`alloc(bytes)` - Allouer de la memoire brute**\n```hemlock\nlet p = alloc(1024);  // Allouer 1Ko, retourne ptr\n// ... utiliser la memoire\nfree(p);\n```\n\n**`buffer(size)` - Allouer un buffer securise**\n```hemlock\nlet buf = buffer(256);  // Allouer un buffer de 256 octets\nbuf[0] = 65;            // 'A'\nbuf[1] = 66;            // 'B'\nfree(buf);\n```\n\n**`free(ptr)` - Liberer la memoire**\n```hemlock\nlet p = alloc(100);\nfree(p);  // Doit liberer pour eviter la fuite memoire\n\nlet buf = buffer(100);\nfree(buf);  // Fonctionne sur ptr et buffer\n```\n\n**Important :** `free()` fonctionne sur les types `ptr` et `buffer`.\n\n### Operations memoire\n\n**`memset(ptr, byte, size)` - Remplir la memoire**\n```hemlock\nlet p = alloc(100);\nmemset(p, 0, 100);     // Mettre a zero 100 octets\nmemset(p, 65, 10);     // Remplir les 10 premiers octets avec 'A'\nfree(p);\n```\n\n**`memcpy(dest, src, size)` - Copier la memoire**\n```hemlock\nlet src = alloc(50);\nlet dst = alloc(50);\nmemset(src, 42, 50);\nmemcpy(dst, src, 50);  // Copier 50 octets de src vers dst\nfree(src);\nfree(dst);\n```\n\n**`realloc(ptr, size)` - Redimensionner l'allocation**\n```hemlock\nlet p = alloc(100);\n// ... utiliser 100 octets\np = realloc(p, 200);   // Redimensionner a 200 octets\n// ... utiliser 200 octets\nfree(p);\n```\n\n**Note :** Apres `realloc()`, l'ancien pointeur peut etre invalide. Utilisez toujours le pointeur retourne.\n\n### Allocation typee\n\nHemlock fournit des aides d'allocation typee pour la commodite :\n\n```hemlock\nlet arr = talloc(i32, 100);  // Allouer 100 valeurs i32 (400 octets)\nlet size = sizeof(i32);      // Retourne 4 (octets)\n```\n\n**`sizeof(type)`** retourne la taille en octets d'un type :\n- `sizeof(i8)` / `sizeof(u8)` -> 1\n- `sizeof(i16)` / `sizeof(u16)` -> 2\n- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` -> 4\n- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` -> 8\n- `sizeof(ptr)` -> 8 (sur systemes 64-bit)\n\n**`talloc(type, count)`** alloue `count` elements de `type` :\n\n```hemlock\nlet ints = talloc(i32, 10);   // 40 octets pour 10 valeurs i32\nlet floats = talloc(f64, 5);  // 40 octets pour 5 valeurs f64\nfree(ints);\nfree(floats);\n```\n\n## Modeles courants\n\n### Modele : Allouer, utiliser, liberer\n\nLe modele basique pour la gestion memoire :\n\n```hemlock\n// 1. Allouer\nlet data = alloc(1024);\n\n// 2. Utiliser\nmemset(data, 0, 1024);\n// ... faire le travail\n\n// 3. Liberer\nfree(data);\n```\n\n### Modele : Utilisation de buffer securise\n\nPreferez les buffers pour l'acces verifie en limites :\n\n```hemlock\nlet buf = buffer(256);\n\n// Iteration securisee\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\nfree(buf);\n```\n\n### Modele : Gestion de ressource avec try/finally\n\nAssurer le nettoyage meme en cas d'erreur :\n\n```hemlock\nlet data = alloc(1024);\ntry {\n    // ... operations risquees\n    process(data);\n} finally {\n    free(data);  // Toujours libere, meme en cas d'erreur\n}\n```\n\n## Considerations de securite memoire\n\n### Double-Free\n\n**Autorise mais va planter :**\n```hemlock\nlet p = alloc(100);\nfree(p);\nfree(p);  // CRASH : Double-free detected\n```\n\n**Prevention :**\n```hemlock\nlet p = alloc(100);\nfree(p);\np = null;  // Mettre a null apres liberation\n\nif (p != null) {\n    free(p);  // Ne s'executera pas\n}\n```\n\n### Pointeurs pendants\n\n**Autorise mais comportement indefini :**\n```hemlock\nlet p = alloc(100);\n*p = 42;      // OK\nfree(p);\nlet x = *p;   // INDEFINI : Lecture de memoire liberee\n```\n\n**Prevention :** N'accedez pas a la memoire apres l'avoir liberee.\n\n### Fuites memoire\n\n**Facile a creer, difficile a debugger :**\n```hemlock\nfn leak_memory() {\n    let p = alloc(1000);\n    // Oublie de liberer !\n    return;  // Memoire fuite\n}\n```\n\n**Prevention :** Toujours associer `alloc()` avec `free()` :\n```hemlock\nfn safe_function() {\n    let p = alloc(1000);\n    try {\n        // ... utiliser p\n    } finally {\n        free(p);  // Toujours libere\n    }\n}\n```\n\n### Arithmetique de pointeur\n\n**Autorise mais dangereux :**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Bien au-dela de la limite d'allocation\n*q = 42;          // INDEFINI : Ecriture hors limites\nfree(p);\n```\n\n**Utilisez les buffers pour la verification des limites :**\n```hemlock\nlet buf = buffer(10);\nbuf[100] = 42;  // ERREUR : La verification des limites empeche le debordement\n```\n\n## Bonnes pratiques\n\n1. **Defaut sur `buffer`** - Utilisez `buffer` sauf si vous avez specifiquement besoin de `ptr` brut\n2. **Associer alloc/free** - Chaque `alloc()` devrait avoir exactement un `free()`\n3. **Utiliser try/finally** - Assurer le nettoyage avec la gestion des exceptions\n4. **Null apres free** - Mettre les pointeurs a `null` apres liberation pour attraper l'utilisation apres liberation\n5. **Verifier les limites** - Utiliser l'indexation de buffer pour la verification automatique des limites\n6. **Documenter la propriete** - Rendre clair quel code possede et libere chaque allocation\n\n## Exemples\n\n### Exemple : Constructeur de chaine dynamique\n\n```hemlock\nfn build_message(count: i32): ptr {\n    let size = count * 10;\n    let buf = alloc(size);\n\n    let i = 0;\n    while (i < count) {\n        memset(buf + (i * 10), 65 + i, 10);\n        i = i + 1;\n    }\n\n    return buf;  // L'appelant doit liberer\n}\n\nlet msg = build_message(5);\n// ... utiliser msg\nfree(msg);\n```\n\n### Exemple : Operations de tableau securisees\n\n```hemlock\nfn process_array(size: i32) {\n    let arr = buffer(size);\n\n    try {\n        // Remplir le tableau\n        let i = 0;\n        while (i < arr.length) {\n            arr[i] = i * 2;\n            i = i + 1;\n        }\n\n        // Traiter\n        i = 0;\n        while (i < arr.length) {\n            print(arr[i]);\n            i = i + 1;\n        }\n    } finally {\n        free(arr);  // Toujours nettoyer\n    }\n}\n```\n\n### Exemple : Modele de pool memoire\n\n```hemlock\n// Pool memoire simple (simplifie)\nlet pool = alloc(10000);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > 10000) {\n        throw \"Pool epuise\";\n    }\n\n    let ptr = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return ptr;\n}\n\n// Utiliser le pool\nlet p1 = pool_alloc(100);\nlet p2 = pool_alloc(200);\n\n// Liberer tout le pool d'un coup\nfree(pool);\n```\n\n## Limitations\n\nLimitations actuelles a connaitre :\n\n- **Les pointeurs bruts necessitent un free manuel** - `alloc()` retourne `ptr` sans comptage de reference\n- **Pas d'allocateurs personnalises** - Seulement malloc/free systeme\n\n**Note :** Les types comptes par reference (string, array, object, buffer) SONT automatiquement liberes quand la portee se termine. Seul le `ptr` brut de `alloc()` necessite un `free()` explicite.\n\n## Sujets connexes\n\n- [Chaines](#language-guide-strings) - Gestion memoire des chaines et encodage UTF-8\n- [Tableaux](#language-guide-arrays) - Tableaux dynamiques et leurs caracteristiques memoire\n- [Objets](#language-guide-objects) - Allocation et duree de vie des objets\n- [Gestion des erreurs](#language-guide-error-handling) - Utiliser try/finally pour le nettoyage\n\n## Voir aussi\n\n- **Philosophie de conception** : Voir section \"Memory Management\" de CLAUDE.md\n- **Systeme de types** : Voir [Types](#language-guide-types) pour les details des types `ptr` et `buffer`\n- **FFI** : Les pointeurs bruts sont essentiels pour l'Interface de Fonction Etrangere\n"}, "Guide du Langage -> Gestion des Erreurs": {"id": "language-guide-error-handling", "content": "# Gestion des erreurs\n\nHemlock supporte la gestion des erreurs basee sur les exceptions avec `try`, `catch`, `finally`, `throw` et `panic`. Ce guide couvre les erreurs recuperables avec les exceptions et les erreurs irrecuperables avec panic.\n\n## Apercu\n\n```hemlock\n// Gestion d'erreur basique\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Erreur: \" + e);\n}\n\n// Avec nettoyage\ntry {\n    process_file();\n} catch (e) {\n    print(\"Echec: \" + e);\n} finally {\n    cleanup();\n}\n\n// Lever des erreurs\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division par zero\";\n    }\n    return a / b;\n}\n```\n\n## Try-Catch-Finally\n\n### Syntaxe\n\n**Try/catch basique :**\n```hemlock\ntry {\n    // code risque\n} catch (e) {\n    // gerer l'erreur, e contient la valeur levee\n}\n```\n\n**Try/finally :**\n```hemlock\ntry {\n    // code risque\n} finally {\n    // s'execute toujours, meme si une exception est levee\n}\n```\n\n**Try/catch/finally :**\n```hemlock\ntry {\n    // code risque\n} catch (e) {\n    // gerer l'erreur\n} finally {\n    // code de nettoyage\n}\n```\n\n### Bloc Try\n\nLe bloc try execute les instructions sequentiellement :\n\n```hemlock\ntry {\n    print(\"Demarrage...\");\n    risky_operation();\n    print(\"Succes!\");  // Seulement si pas d'exception\n}\n```\n\n**Comportement :**\n- Execute les instructions dans l'ordre\n- Si une exception est levee : saute au `catch` ou `finally`\n- Si pas d'exception : execute `finally` (si present) puis continue\n\n### Bloc Catch\n\nLe bloc catch recoit la valeur levee :\n\n```hemlock\ntry {\n    throw \"oups\";\n} catch (error) {\n    print(\"Attrape: \" + error);  // error = \"oups\"\n    // error seulement accessible ici\n}\n// error non accessible ici\n```\n\n**Parametre catch :**\n- Recoit la valeur levee (n'importe quel type)\n- Portee limitee au bloc catch\n- Peut etre nomme n'importe comment (conventionnellement `e`, `err` ou `error`)\n\n**Ce que vous pouvez faire dans catch :**\n```hemlock\ntry {\n    risky_operation();\n} catch (e) {\n    // Logger l'erreur\n    print(\"Erreur: \" + e);\n\n    // Relever la meme erreur\n    throw e;\n\n    // Lever une erreur differente\n    throw \"erreur differente\";\n\n    // Retourner une valeur par defaut\n    return null;\n\n    // Gerer et continuer\n    // (pas de throw)\n}\n```\n\n### Bloc Finally\n\nLe bloc finally **s'execute toujours** :\n\n```hemlock\ntry {\n    print(\"1: bloc try\");\n    throw \"erreur\";\n} catch (e) {\n    print(\"2: bloc catch\");\n} finally {\n    print(\"3: bloc finally\");  // S'execute toujours\n}\nprint(\"4: apres try/catch/finally\");\n\n// Sortie : 1: bloc try, 2: bloc catch, 3: bloc finally, 4: apres try/catch/finally\n```\n\n**Quand finally s'execute :**\n- Apres le bloc try (si pas d'exception)\n- Apres le bloc catch (si exception attrapee)\n- Meme si try/catch contient `return`, `break` ou `continue`\n- Avant que le flux de controle ne quitte le try/catch\n\n**Finally avec return :**\n```hemlock\nfn example() {\n    try {\n        return 1;  // Retourne 1 apres que finally s'execute\n    } finally {\n        print(\"nettoyage\");  // S'execute avant de retourner\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // Le return de finally remplace - retourne 2\n    }\n}\n```\n\n**Finally avec flux de controle :**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) {\n            break;  // Break apres que finally s'execute\n        }\n    } finally {\n        print(\"nettoyage \" + typeof(i));\n    }\n}\n```\n\n## Instruction Throw\n\n### Throw basique\n\nLever n'importe quelle valeur comme exception :\n\n```hemlock\nthrow \"message d'erreur\";\nthrow 404;\nthrow { code: 500, message: \"Erreur interne\" };\nthrow null;\nthrow [\"erreur\", \"details\"];\n```\n\n**Execution :**\n1. Evalue l'expression\n2. Saute immediatement au `catch` englobant le plus proche\n3. Si pas de `catch`, propage dans la pile d'appels\n\n### Lever des erreurs\n\n```hemlock\nfn validate_age(age: i32) {\n    if (age < 0) {\n        throw \"L'age ne peut pas etre negatif\";\n    }\n    if (age > 150) {\n        throw \"L'age est irrealiste\";\n    }\n}\n\ntry {\n    validate_age(-5);\n} catch (e) {\n    print(\"Erreur de validation: \" + e);\n}\n```\n\n### Lever des objets d'erreur\n\nCreer des informations d'erreur structurees :\n\n```hemlock\nfn read_file(path: string) {\n    if (!file_exists(path)) {\n        throw {\n            type: \"FileNotFound\",\n            path: path,\n            message: \"Le fichier n'existe pas\"\n        };\n    }\n    // ... lire le fichier\n}\n\ntry {\n    read_file(\"missing.txt\");\n} catch (e) {\n    if (e.type == \"FileNotFound\") {\n        print(\"Fichier non trouve: \" + e.path);\n    }\n}\n```\n\n### Relever (re-throwing)\n\nAttraper et relever des erreurs :\n\n```hemlock\nfn wrapper() {\n    try {\n        risky_operation();\n    } catch (e) {\n        print(\"Logger erreur: \" + e);\n        throw e;  // Relever a l'appelant\n    }\n}\n\ntry {\n    wrapper();\n} catch (e) {\n    print(\"Attrape dans main: \" + e);\n}\n```\n\n## Exceptions non attrapees\n\nSi une exception se propage au sommet de la pile d'appels sans etre attrapee :\n\n```hemlock\nfn foo() {\n    throw \"non attrapee!\";\n}\n\nfoo();  // Plante avec : Runtime error: non attrapee!\n```\n\n**Comportement :**\n- Le programme plante\n- Affiche le message d'erreur sur stderr\n- Quitte avec un code de statut non nul\n- Trace de pile a ajouter dans les versions futures\n\n## Panic - Erreurs irrecuperables\n\n### Qu'est-ce que Panic ?\n\n`panic()` est pour les **erreurs irrecuperables** qui devraient immediatement terminer le programme :\n\n```hemlock\npanic();                    // Message par defaut : \"panic!\"\npanic(\"message personnalise\");    // Message personnalise\npanic(42);                  // Les valeurs non-chaine sont affichees\n```\n\n**Semantique :**\n- **Quitte immediatement** le programme avec code de sortie 1\n- Affiche le message d'erreur sur stderr : `panic: <message>`\n- **NON attrapable** avec try/catch\n- Utiliser pour les bugs et erreurs irrecuperables\n\n### Panic vs Throw\n\n```hemlock\n// throw - Erreur recuperable (peut etre attrapee)\ntry {\n    throw \"erreur recuperable\";\n} catch (e) {\n    print(\"Attrape: \" + e);  // Attrape avec succes\n}\n\n// panic - Erreur irrecuperable (ne peut pas etre attrapee)\ntry {\n    panic(\"erreur irrecuperable\");  // Le programme quitte immediatement\n} catch (e) {\n    print(\"Ceci ne s'execute jamais\");       // Ne s'execute jamais\n}\n```\n\n### Quand utiliser Panic\n\n**Utilisez panic pour :**\n- **Bugs** : Du code inatteignable a ete atteint\n- **Etat invalide** : Corruption de structure de donnees detectee\n- **Erreurs irrecuperables** : Ressource critique indisponible\n- **Echecs d'assertion** : Quand `assert()` n'est pas suffisant\n\n**Exemples :**\n```hemlock\n// Code inatteignable\nfn process_state(state: i32) {\n    if (state == 1) {\n        return \"pret\";\n    } else if (state == 2) {\n        return \"en cours\";\n    } else if (state == 3) {\n        return \"arrete\";\n    } else {\n        panic(\"etat invalide: \" + typeof(state));  // Ne devrait jamais arriver\n    }\n}\n\n// Verification de ressource critique\nfn init_system() {\n    let config = read_file(\"config.json\");\n    if (config == null) {\n        panic(\"config.json non trouve - impossible de demarrer\");\n    }\n    // ...\n}\n\n// Invariant de structure de donnees\nfn pop_stack(stack) {\n    if (stack.length == 0) {\n        panic(\"pop() appele sur pile vide\");\n    }\n    return stack.pop();\n}\n```\n\n### Quand NE PAS utiliser Panic\n\n**Utilisez throw a la place pour :**\n- Validation d'entree utilisateur\n- Fichier non trouve\n- Erreurs reseau\n- Conditions d'erreur attendues\n\n```hemlock\n// MAUVAIS : Panic pour erreurs attendues\nfn divide(a, b) {\n    if (b == 0) {\n        panic(\"division par zero\");  // Trop severe\n    }\n    return a / b;\n}\n\n// BON : Throw pour erreurs attendues\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division par zero\";  // Recuperable\n    }\n    return a / b;\n}\n```\n\n## Interactions avec le flux de controle\n\n### Return dans Try/Catch/Finally\n\n```hemlock\nfn example() {\n    try {\n        return 1;  // Retourne 1 apres que finally s'execute\n    } finally {\n        print(\"nettoyage\");\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // Le return de finally remplace celui de try - retourne 2\n    }\n}\n```\n\n**Regle :** Les valeurs de retour du bloc finally remplacent les valeurs de retour try/catch.\n\n### Break/Continue dans Try/Catch/Finally\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) { break; }  // Break apres que finally s'execute\n    } finally {\n        print(\"nettoyage \" + typeof(i));\n    }\n}\n```\n\n**Regle :** Break/continue s'executent apres le bloc finally.\n\n### Try/Catch imbrique\n\n```hemlock\ntry {\n    try {\n        throw \"inner\";\n    } catch (e) {\n        print(\"Attrape: \" + e);  // Affiche : Attrape: inner\n        throw \"outer\";  // Releve une erreur differente\n    }\n} catch (e) {\n    print(\"Attrape: \" + e);  // Affiche : Attrape: outer\n}\n```\n\n**Regle :** Les blocs try/catch imbriques fonctionnent comme attendu, les catches internes arrivent en premier.\n\n## Modeles courants\n\n### Modele : Nettoyage de ressource\n\nUtilisez toujours `finally` pour le nettoyage :\n\n```hemlock\nfn process_file(filename) {\n    let file = null;\n    try {\n        file = open(filename);\n        let content = file.read();\n        process(content);\n    } catch (e) {\n        print(\"Erreur lors du traitement du fichier: \" + e);\n    } finally {\n        if (file != null) {\n            file.close();  // Ferme toujours, meme en cas d'erreur\n        }\n    }\n}\n```\n\n### Modele : Enveloppe d'erreur\n\nEnvelopper les erreurs de bas niveau avec du contexte :\n\n```hemlock\nfn load_config(path) {\n    try {\n        let content = read_file(path);\n        return parse_json(content);\n    } catch (e) {\n        throw \"Echec du chargement de config depuis \" + path + \": \" + e;\n    }\n}\n```\n\n### Modele : Recuperation d'erreur\n\nFournir une valeur de repli en cas d'erreur :\n\n```hemlock\nfn safe_divide(a, b) {\n    try {\n        if (b == 0) {\n            throw \"division par zero\";\n        }\n        return a / b;\n    } catch (e) {\n        print(\"Erreur: \" + e);\n        return null;  // Valeur de repli\n    }\n}\n```\n\n### Modele : Validation\n\nUtiliser les exceptions pour la validation :\n\n```hemlock\nfn validate_user(user) {\n    if (user.name == null || user.name == \"\") {\n        throw \"Le nom est requis\";\n    }\n    if (user.age < 0 || user.age > 150) {\n        throw \"Age invalide\";\n    }\n    if (user.email == null || !user.email.contains(\"@\")) {\n        throw \"Email invalide\";\n    }\n}\n\ntry {\n    validate_user({ name: \"Alice\", age: -5, email: \"invalide\" });\n} catch (e) {\n    print(\"Validation echouee: \" + e);\n}\n```\n\n### Modele : Types d'erreur multiples\n\nUtiliser des objets d'erreur pour distinguer les types d'erreur :\n\n```hemlock\nfn process_data(data) {\n    if (data == null) {\n        throw { type: \"NullData\", message: \"Les donnees sont null\" };\n    }\n\n    if (typeof(data) != \"array\") {\n        throw { type: \"TypeError\", message: \"Tableau attendu\" };\n    }\n\n    if (data.length == 0) {\n        throw { type: \"EmptyData\", message: \"Le tableau est vide\" };\n    }\n\n    // ... traitement\n}\n\ntry {\n    process_data(null);\n} catch (e) {\n    if (e.type == \"NullData\") {\n        print(\"Pas de donnees fournies\");\n    } else if (e.type == \"TypeError\") {\n        print(\"Mauvais type de donnees: \" + e.message);\n    } else {\n        print(\"Erreur: \" + e.message);\n    }\n}\n```\n\n## Bonnes pratiques\n\n1. **Utilisez les exceptions pour les cas exceptionnels** - Pas pour le flux de controle normal\n2. **Levez des erreurs significatives** - Utilisez des chaines ou objets avec contexte\n3. **Utilisez toujours finally pour le nettoyage** - Assure que les ressources sont liberees\n4. **N'attrapez pas pour ignorer** - Au minimum loggez l'erreur\n5. **Relevez quand approprie** - Laissez l'appelant gerer si vous ne pouvez pas\n6. **Panic pour les bugs** - Utilisez panic pour les erreurs irrecuperables\n7. **Documentez les exceptions** - Rendez clair quelles fonctions peuvent lever\n\n## Pieges courants\n\n### Piege : Avaler les erreurs\n\n```hemlock\n// MAUVAIS : Echec silencieux\ntry {\n    risky_operation();\n} catch (e) {\n    // Erreur ignoree - echec silencieux\n}\n\n// BON : Logger ou gerer\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Operation echouee: \" + e);\n    // Gerer de maniere appropriee\n}\n```\n\n### Piege : Remplacement par Finally\n\n```hemlock\n// MAUVAIS : Finally remplace le return\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        return 0;  // Retourne 0, pas 42 !\n    }\n}\n\n// BON : Ne pas retourner dans finally\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        cleanup();  // Juste nettoyage, pas de return\n    }\n}\n```\n\n### Piege : Oublier le nettoyage\n\n```hemlock\n// MAUVAIS : Le fichier peut ne pas etre ferme en cas d'erreur\nfn process() {\n    let file = open(\"data.txt\");\n    let content = file.read();  // Peut lever\n    file.close();  // Jamais atteint si erreur\n}\n\n// BON : Utiliser finally\nfn process() {\n    let file = null;\n    try {\n        file = open(\"data.txt\");\n        let content = file.read();\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n}\n```\n\n### Piege : Utiliser Panic pour erreurs attendues\n\n```hemlock\n// MAUVAIS : Panic pour erreur attendue\nfn read_config(path) {\n    if (!file_exists(path)) {\n        panic(\"Fichier de config non trouve\");  // Trop severe\n    }\n    return read_file(path);\n}\n\n// BON : Throw pour erreur attendue\nfn read_config(path) {\n    if (!file_exists(path)) {\n        throw \"Fichier de config non trouve: \" + path;  // Recuperable\n    }\n    return read_file(path);\n}\n```\n\n## Exemples\n\n### Exemple : Gestion d'erreur basique\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division par zero\";\n    }\n    return a / b;\n}\n\ntry {\n    print(divide(10, 0));\n} catch (e) {\n    print(\"Erreur: \" + e);  // Affiche : Erreur: division par zero\n}\n```\n\n### Exemple : Gestion de ressource\n\n```hemlock\nfn copy_file(src, dst) {\n    let src_file = null;\n    let dst_file = null;\n\n    try {\n        src_file = open(src, \"r\");\n        dst_file = open(dst, \"w\");\n\n        let content = src_file.read();\n        dst_file.write(content);\n\n        print(\"Fichier copie avec succes\");\n    } catch (e) {\n        print(\"Echec de la copie du fichier: \" + e);\n        throw e;  // Relever\n    } finally {\n        if (src_file != null) { src_file.close(); }\n        if (dst_file != null) { dst_file.close(); }\n    }\n}\n```\n\n### Exemple : Gestion d'erreur imbriquee\n\n```hemlock\nfn process_users(users) {\n    let success_count = 0;\n    let error_count = 0;\n\n    let i = 0;\n    while (i < users.length) {\n        try {\n            validate_user(users[i]);\n            save_user(users[i]);\n            success_count = success_count + 1;\n        } catch (e) {\n            print(\"Echec du traitement de l'utilisateur: \" + e);\n            error_count = error_count + 1;\n        }\n        i = i + 1;\n    }\n\n    print(\"Traites: \" + typeof(success_count) + \" succes, \" + typeof(error_count) + \" erreurs\");\n}\n```\n\n### Exemple : Types d'erreur personnalises\n\n```hemlock\nfn create_error(type, message, details) {\n    return {\n        type: type,\n        message: message,\n        details: details,\n        toString: fn() {\n            return self.type + \": \" + self.message;\n        }\n    };\n}\n\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" && typeof(a) != \"f64\") {\n        throw create_error(\"TypeError\", \"a doit etre un nombre\", { value: a });\n    }\n    if (typeof(b) != \"i32\" && typeof(b) != \"f64\") {\n        throw create_error(\"TypeError\", \"b doit etre un nombre\", { value: b });\n    }\n    if (b == 0) {\n        throw create_error(\"DivisionByZero\", \"Impossible de diviser par zero\", { a: a, b: b });\n    }\n    return a / b;\n}\n\ntry {\n    divide(10, 0);\n} catch (e) {\n    print(e.toString());\n    if (e.type == \"DivisionByZero\") {\n        print(\"Details: a=\" + typeof(e.details.a) + \", b=\" + typeof(e.details.b));\n    }\n}\n```\n\n### Exemple : Logique de reessai\n\n```hemlock\nfn retry(operation, max_attempts) {\n    let attempt = 0;\n\n    while (attempt < max_attempts) {\n        try {\n            return operation();  // Succes !\n        } catch (e) {\n            attempt = attempt + 1;\n            if (attempt >= max_attempts) {\n                throw \"Operation echouee apres \" + typeof(max_attempts) + \" tentatives: \" + e;\n            }\n            print(\"Tentative \" + typeof(attempt) + \" echouee, nouvel essai...\");\n        }\n    }\n}\n\nfn unreliable_operation() {\n    // Operation peu fiable simulee\n    if (random() < 0.7) {\n        throw \"Operation echouee\";\n    }\n    return \"Succes\";\n}\n\ntry {\n    let result = retry(unreliable_operation, 3);\n    print(result);\n} catch (e) {\n    print(\"Tous les reessais ont echoue: \" + e);\n}\n```\n\n## Ordre d'execution\n\nComprendre l'ordre d'execution :\n\n```hemlock\ntry {\n    print(\"1: debut bloc try\");\n    throw \"erreur\";\n    print(\"2: jamais atteint\");\n} catch (e) {\n    print(\"3: bloc catch\");\n} finally {\n    print(\"4: bloc finally\");\n}\nprint(\"5: apres try/catch/finally\");\n\n// Sortie :\n// 1: debut bloc try\n// 3: bloc catch\n// 4: bloc finally\n// 5: apres try/catch/finally\n```\n\n## Limitations actuelles\n\n- **Pas de trace de pile** - Les exceptions non attrapees n'affichent pas la trace de pile (prevu)\n- **Certaines fonctions integrees quittent** - Certaines fonctions integrees font `exit()` au lieu de lever (a revoir)\n- **Pas de types d'exception personnalises** - N'importe quelle valeur peut etre levee, mais pas de hierarchie d'exception formelle\n\n## Sujets connexes\n\n- [Fonctions](#language-guide-functions) - Exceptions et retours de fonction\n- [Flux de controle](#language-guide-control-flow) - Comment les exceptions affectent le flux de controle\n- [Memoire](#language-guide-memory) - Utiliser finally pour le nettoyage memoire\n\n## Voir aussi\n\n- **Semantique des exceptions** : Voir section \"Error Handling\" de CLAUDE.md\n- **Panic vs Throw** : Cas d'utilisation differents pour types d'erreur differents\n- **Garantie Finally** : S'execute toujours, meme avec return/break/continue\n"}, "Guide du Langage -> Modules": {"id": "language-guide-modules", "content": "# Systeme de modules Hemlock\n\nCe document decrit le systeme de modules import/export de style ES6 implemente pour Hemlock.\n\n## Apercu\n\nHemlock supporte un systeme de modules base sur les fichiers avec une syntaxe import/export de style ES6. Les modules sont :\n- **Singletons** : Chaque module est charge une fois et mis en cache\n- **Bases sur les fichiers** : Les modules correspondent a des fichiers .hml sur disque\n- **Explicitement importes** : Les dependances sont declarees avec des instructions import\n- **Executes topologiquement** : Les dependances sont executees avant les dependants\n\nPour la gestion des paquets et les dependances tierces, voir [hpm (Hemlock Package Manager)](https://github.com/hemlang/hpm).\n\n## Syntaxe\n\n### Instructions d'export\n\n**Exports nommes en ligne :**\n```hemlock\nexport fn add(a, b) {\n    return a + b;\n}\n\nexport const PI = 3.14159;\nexport let counter = 0;\n```\n\n**Liste d'export :**\n```hemlock\nfn add(a, b) { return a + b; }\nfn subtract(a, b) { return a - b; }\n\nexport { add, subtract };\n```\n\n**Export Extern (fonctions FFI) :**\n```hemlock\nimport \"libc.so.6\";\n\n// Exporter des fonctions FFI pour utilisation dans d'autres modules\nexport extern fn strlen(s: string): i32;\nexport extern fn getpid(): i32;\n```\n\nVoir [Documentation FFI](../advanced/ffi.md#exporting-ffi-functions) pour plus de details sur l'export des fonctions FFI.\n\n**Export Define (types struct) :**\n```hemlock\n// Exporter des definitions de type struct\nexport define Vector2 {\n    x: f32,\n    y: f32,\n}\n\nexport define Rectangle {\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n}\n```\n\n**Important :** Les types struct exportes sont enregistres globalement quand le module est charge. Ils deviennent disponibles automatiquement quand vous importez quoi que ce soit du module - vous n'avez PAS besoin de (et ne pouvez pas) les importer explicitement par nom :\n\n```hemlock\n// BON - les types struct sont auto-disponibles apres tout import\nimport { some_function } from \"./my_module.hml\";\nlet v: Vector2 = { x: 1.0, y: 2.0 };  // Fonctionne !\n\n// MAUVAIS - impossible d'importer explicitement les types struct\nimport { Vector2 } from \"./my_module.hml\";  // Erreur : Undefined variable 'Vector2'\n```\n\nVoir [Documentation FFI](../advanced/ffi.md#exporting-struct-types) pour plus de details sur l'export des types struct.\n\n**Re-exports :**\n```hemlock\n// Re-exporter depuis un autre module\nexport { add, subtract } from \"./math.hml\";\n```\n\n### Instructions d'import\n\n**Imports nommes :**\n```hemlock\nimport { add, subtract } from \"./math.hml\";\nprint(add(1, 2));  // 3\n```\n\n**Import d'espace de noms :**\n```hemlock\nimport * as math from \"./math.hml\";\nprint(math.add(1, 2));  // 3\nprint(math.PI);  // 3.14159\n```\n\n**Alias :**\n```hemlock\nimport { add as sum, subtract as diff } from \"./math.hml\";\nprint(sum(1, 2));  // 3\n```\n\n## Resolution de module\n\n### Types de chemin\n\n**Chemins relatifs :**\n```hemlock\nimport { foo } from \"./module.hml\";       // Meme repertoire\nimport { bar } from \"../parent.hml\";      // Repertoire parent\nimport { baz } from \"./sub/nested.hml\";   // Sous-repertoire\n```\n\n**Chemins absolus :**\n```hemlock\nimport { foo } from \"/absolute/path/to/module.hml\";\n```\n\n**Gestion des extensions :**\n- L'extension `.hml` peut etre omise - elle sera ajoutee automatiquement\n- `./math` se resout en `./math.hml`\n\n## Fonctionnalites\n\n### Detection de dependance circulaire\n\nLe systeme de modules detecte les dependances circulaires et signale une erreur :\n\n```\nError: Circular dependency detected when loading '/path/to/a.hml'\n```\n\n### Mise en cache des modules\n\nLes modules sont charges une fois et mis en cache. Plusieurs imports du meme module retournent la meme instance :\n\n```hemlock\n// counter.hml\nexport let count = 0;\nexport fn increment() {\n    count = count + 1;\n}\n\n// a.hml\nimport { count, increment } from \"./counter.hml\";\nincrement();\nprint(count);  // 1\n\n// b.hml\nimport { count } from \"./counter.hml\";  // Meme instance !\nprint(count);  // Toujours 1 (etat partage)\n```\n\n### Immutabilite des imports\n\nLes liaisons importees ne peuvent pas etre reassignees :\n\n```hemlock\nimport { add } from \"./math.hml\";\nadd = fn() { };  // ERREUR : cannot reassign imported binding\n```\n\n## Details d'implementation\n\n### Architecture\n\n**Fichiers :**\n- `include/module.h` - API du systeme de modules\n- `src/module.c` - Chargement, mise en cache et execution des modules\n- Support parser dans `src/parser.c`\n- Support runtime dans `src/interpreter/runtime.c`\n\n**Composants cles :**\n1. **ModuleCache** : Maintient les modules charges indexes par chemin absolu\n2. **Module** : Represente un module charge avec son AST et exports\n3. **Resolution de chemin** : Resout les chemins relatifs/absolus en chemins canoniques\n4. **Execution topologique** : Execute les modules dans l'ordre des dependances\n\n### Processus de chargement des modules\n\n1. **Phase d'analyse** : Tokeniser et analyser le fichier module\n2. **Resolution des dependances** : Charger recursivement les modules importes\n3. **Detection de cycle** : Verifier si le module est deja en cours de chargement\n4. **Mise en cache** : Stocker le module dans le cache par chemin absolu\n5. **Phase d'execution** : Executer dans l'ordre topologique (dependances d'abord)\n\n### API\n\n```c\n// API haut niveau\nint execute_file_with_modules(const char *file_path,\n                               int argc, char **argv,\n                               ExecutionContext *ctx);\n\n// API bas niveau\nModuleCache* module_cache_new(const char *initial_dir);\nvoid module_cache_free(ModuleCache *cache);\nModule* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);\nvoid execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);\n```\n\n## Tests\n\nLes modules de test sont situes dans `tests/modules/` et `tests/parity/modules/` :\n\n- `math.hml` - Module basique avec exports\n- `test_import_named.hml` - Test d'import nomme\n- `test_import_namespace.hml` - Test d'import d'espace de noms\n- `test_import_alias.hml` - Test d'alias d'import\n- `export_extern.hml` - Test d'export extern de fonction FFI (Linux)\n\n## Imports de paquets (hpm)\n\nAvec [hpm](https://github.com/hemlang/hpm) installe, vous pouvez importer des paquets tiers depuis GitHub :\n\n```hemlock\n// Importer depuis la racine du paquet (utilise \"main\" de package.json)\nimport { app, router } from \"hemlang/sprout\";\n\n// Importer depuis un sous-chemin\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// Bibliotheque standard (integree a Hemlock)\nimport { HashMap } from \"@stdlib/collections\";\n```\n\nLes paquets sont installes dans `hem_modules/` et resolus en utilisant la syntaxe GitHub `owner/repo`.\n\n```bash\n# Installer un paquet\nhpm install hemlang/sprout\n\n# Installer avec contrainte de version\nhpm install hemlang/sprout@^1.0.0\n```\n\nVoir la [documentation hpm](https://github.com/hemlang/hpm) pour tous les details.\n\n## Limitations actuelles\n\n1. **Pas d'imports dynamiques** : `import()` comme fonction runtime n'est pas supporte\n2. **Pas d'exports conditionnels** : Les exports doivent etre au niveau superieur\n3. **Chemins de bibliotheque statiques** : Les imports de bibliotheque FFI utilisent des chemins statiques (specifiques a la plateforme)\n\n## Travaux futurs\n\n- Imports dynamiques avec fonction `import()`\n- Exports conditionnels\n- Metadonnees de module (`import.meta`)\n- Tree shaking et elimination de code mort\n\n## Exemples\n\nVoir `tests/modules/` pour des exemples fonctionnels du systeme de modules.\n\nExemple de structure de module :\n```\nproject/\n|-- main.hml\n|-- lib/\n|   |-- math.hml\n|   |-- string.hml\n|   |-- index.hml (module barrel)\n|-- utils/\n    |-- helpers.hml\n```\n\nExemple d'utilisation :\n```hemlock\n// lib/math.hml\nexport fn add(a, b) { return a + b; }\nexport fn multiply(a, b) { return a * b; }\n\n// lib/index.hml (barrel)\nexport { add, multiply } from \"./math.hml\";\n\n// main.hml\nimport { add } from \"./lib/index.hml\";\nprint(add(2, 3));  // 5\n```\n"}, "Guide du Langage -> Objets": {"id": "language-guide-objects", "content": "# Objets\n\nHemlock implemente des objets de style JavaScript avec allocation sur le tas, champs dynamiques, methodes et typage canard. Les objets sont des structures de donnees flexibles qui combinent donnees et comportement.\n\n## Apercu\n\n```hemlock\n// Objet anonyme\nlet person = { name: \"Alice\", age: 30, city: \"NYC\" };\nprint(person.name);  // \"Alice\"\n\n// Objet avec methodes\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## Litteraux d'objet\n\n### Syntaxe basique\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n```\n\n**Syntaxe :**\n- Les accolades `{}` enclosent l'objet\n- Paires cle-valeur separees par des virgules\n- Les cles sont des identifiants (pas de guillemets necessaires)\n- Les valeurs peuvent etre de n'importe quel type\n\n### Objets vides\n\n```hemlock\nlet obj = {};  // Objet vide\n\n// Ajouter des champs plus tard\nobj.name = \"Alice\";\nobj.age = 30;\n```\n\n### Objets imbriques\n\n```hemlock\nlet user = {\n    info: {\n        name: \"Bob\",\n        age: 25\n    },\n    active: true,\n    settings: {\n        theme: \"dark\",\n        notifications: true\n    }\n};\n\nprint(user.info.name);           // \"Bob\"\nprint(user.settings.theme);      // \"dark\"\n```\n\n### Types de valeur mixtes\n\n```hemlock\nlet mixed = {\n    number: 42,\n    text: \"hello\",\n    flag: true,\n    data: null,\n    items: [1, 2, 3],\n    config: { x: 10, y: 20 }\n};\n```\n\n### Syntaxe de propriete abregee\n\nQuand un nom de variable correspond au nom de propriete, utilisez la syntaxe abregee :\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\nlet active = true;\n\n// Abrege : { name } est equivalent a { name: name }\nlet person = { name, age, active };\n\nprint(person.name);   // \"Alice\"\nprint(person.age);    // 30\nprint(person.active); // true\n```\n\n**Melanger abrege avec proprietes regulieres :**\n```hemlock\nlet city = \"NYC\";\nlet obj = { name, age, city, role: \"admin\" };\n```\n\n### Operateur spread\n\nL'operateur spread (`...`) copie tous les champs d'un objet dans un autre :\n\n```hemlock\nlet base = { x: 1, y: 2 };\nlet extended = { ...base, z: 3 };\n\nprint(extended.x);  // 1\nprint(extended.y);  // 2\nprint(extended.z);  // 3\n```\n\n**Remplacer des valeurs avec spread :**\n```hemlock\nlet defaults = { theme: \"light\", size: \"medium\", debug: false };\nlet custom = { ...defaults, theme: \"dark\" };\n\nprint(custom.theme);  // \"dark\" (remplace)\nprint(custom.size);   // \"medium\" (depuis defaults)\nprint(custom.debug);  // false (depuis defaults)\n```\n\n**Spreads multiples (les spreads ulterieurs remplacent les precedents) :**\n```hemlock\nlet a = { x: 1 };\nlet b = { y: 2 };\nlet merged = { ...a, ...b, z: 3 };\n\nprint(merged.x);  // 1\nprint(merged.y);  // 2\nprint(merged.z);  // 3\n\n// Le spread ulterieur remplace le precedent\nlet first = { val: \"first\" };\nlet second = { val: \"second\" };\nlet combined = { ...first, ...second };\nprint(combined.val);  // \"second\"\n```\n\n**Combiner abrege et spread :**\n```hemlock\nlet status = \"active\";\nlet data = { id: 1, name: \"Item\" };\nlet full = { ...data, status };\n\nprint(full.id);      // 1\nprint(full.name);    // \"Item\"\nprint(full.status);  // \"active\"\n```\n\n**Modele de remplacement de configuration :**\n```hemlock\nlet defaultConfig = {\n    debug: false,\n    timeout: 30,\n    retries: 3\n};\n\nlet prodConfig = { ...defaultConfig, timeout: 60 };\nlet devConfig = { ...defaultConfig, debug: true };\n\nprint(prodConfig.timeout);  // 60\nprint(devConfig.debug);     // true\n```\n\n**Note :** Le spread effectue une copie superficielle. Les objets imbriques partagent les references :\n```hemlock\nlet nested = { inner: { val: 42 } };\nlet copied = { ...nested };\nprint(copied.inner.val);  // 42 (meme reference que nested.inner)\n```\n\n## Acces aux champs\n\n### Notation point\n\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\n\n// Lire le champ\nlet name = person.name;      // \"Alice\"\nlet age = person.age;        // 30\n\n// Modifier le champ\nperson.age = 31;\nprint(person.age);           // 31\n```\n\n### Ajout dynamique de champs\n\nAjouter de nouveaux champs a l'execution :\n\n```hemlock\nlet person = { name: \"Alice\" };\n\n// Ajouter un nouveau champ\nperson.email = \"alice@example.com\";\nperson.phone = \"555-1234\";\n\nprint(person.email);  // \"alice@example.com\"\n```\n\n### Suppression de champs\n\n**Note :** La suppression de champs n'est pas actuellement supportee. Definissez a `null` a la place :\n\n```hemlock\nlet obj = { x: 10, y: 20 };\n\n// Impossible de supprimer des champs (non supporte)\n// obj.x = undefined;  // Pas de 'undefined' en Hemlock\n\n// Solution : Definir a null\nobj.x = null;\n```\n\n## Methodes et `self`\n\n### Definir des methodes\n\nLes methodes sont des fonctions stockees dans les champs d'objet :\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    decrement: fn() {\n        self.count = self.count - 1;\n    },\n    get: fn() {\n        return self.count;\n    }\n};\n```\n\n### Le mot-cle `self`\n\nQuand une fonction est appelee comme methode, `self` est automatiquement lie a l'objet :\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;  // self fait reference a counter\n    }\n};\n\ncounter.increment();  // self est lie a counter\nprint(counter.count);  // 1\n```\n\n**Fonctionnement :**\n- Les appels de methode sont detectes en verifiant si l'expression de fonction est un acces de propriete\n- `self` est automatiquement lie a l'objet au moment de l'appel\n- `self` est en lecture seule (impossible de reassigner `self` lui-meme)\n\n### Detection d'appel de methode\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() {\n        return self.value;\n    }\n};\n\n// Appele comme methode - self est lie\nprint(obj.method());  // 10\n\n// Appele comme fonction - self est null (erreur)\nlet f = obj.method;\nprint(f());  // ERREUR : self is not defined\n```\n\n### Methodes avec parametres\n\n```hemlock\nlet calculator = {\n    result: 0,\n    add: fn(x) {\n        self.result = self.result + x;\n    },\n    multiply: fn(x) {\n        self.result = self.result * x;\n    },\n    get: fn() {\n        return self.result;\n    }\n};\n\ncalculator.add(5);\ncalculator.multiply(2);\nprint(calculator.get());  // 10\n```\n\n## Definitions de type avec `define`\n\n### Definition de type basique\n\nDefinir les formes d'objet avec `define` :\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active: bool,\n}\n\n// Creer un objet et assigner a une variable typee\nlet p = { name: \"Alice\", age: 30, active: true };\nlet typed_p: Person = p;  // Le typage canard valide la structure\n\nprint(typeof(typed_p));  // \"Person\"\n```\n\n**Ce que fait `define` :**\n- Declare un type avec des champs requis\n- Active la validation par typage canard\n- Definit le nom de type de l'objet pour `typeof()`\n\n### Typage canard\n\nLes objets sont valides contre `define` en utilisant la **compatibilite structurelle** :\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK : A tous les champs requis\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK : Les champs supplementaires sont autorises\nlet p2: Person = {\n    name: \"Bob\",\n    age: 25,\n    city: \"NYC\",\n    active: true\n};\n\n// ERREUR : Champ requis 'age' manquant\nlet p3: Person = { name: \"Carol\" };\n\n// ERREUR : Mauvais type pour 'age'\nlet p4: Person = { name: \"Dave\", age: \"trente\" };\n```\n\n**Regles du typage canard :**\n- Tous les champs requis doivent etre presents\n- Les types de champs doivent correspondre\n- Les champs supplementaires sont autorises et preserves\n- La validation a lieu au moment de l'assignation\n\n### Champs optionnels\n\nLes champs peuvent etre optionnels avec des valeurs par defaut :\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,       // Optionnel avec valeur par defaut\n    nickname?: string,   // Optionnel, par defaut null\n}\n\n// Objet avec seulement les champs requis\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.active);    // true (defaut applique)\nprint(typed_p.nickname);  // null (pas de defaut)\n\n// Peut remplacer les champs optionnels\nlet p2: Person = { name: \"Bob\", age: 25, active: false };\nprint(p2.active);  // false (remplace)\n```\n\n**Syntaxe des champs optionnels :**\n- `field?: default_value` - Optionnel avec defaut\n- `field?: type` - Optionnel avec annotation de type, par defaut null\n- Les champs optionnels sont ajoutes lors du typage canard si absents\n\n### Verification de type\n\n```hemlock\ndefine Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = { x: 10, y: 20 };\nlet point: Point = p;  // La verification de type a lieu ici\n\nprint(typeof(point));  // \"Point\"\nprint(typeof(p));      // \"object\" (l'original est toujours anonyme)\n```\n\n**Quand la verification de type a lieu :**\n- Au moment de l'assignation a une variable typee\n- Valide que tous les champs requis sont presents\n- Valide que les types de champs correspondent (avec conversions implicites)\n- Definit le nom de type de l'objet\n\n## Signatures de methode dans Define\n\nLes blocs define peuvent specifier des signatures de methode, creant des contrats de type interface :\n\n### Methodes requises\n\n```hemlock\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32;  // Signature de methode requise\n}\n\n// Les objets doivent fournir la methode requise\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n```\n\n### Methodes optionnelles\n\n```hemlock\ndefine Serializable {\n    fn serialize(): string;       // Requise\n    fn pretty?(): string;         // Methode optionnelle (peut etre absente)\n}\n```\n\n### Le type `Self`\n\n`Self` fait reference au type en cours de definition, permettant les definitions de type recursives :\n\n```hemlock\ndefine Cloneable {\n    fn clone(): Self;  // Retourne le meme type que l'objet\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;  // Prend le meme type en parametre\n    fn equals(other: Self): bool;\n}\n\nlet item: Cloneable = {\n    value: 42,\n    clone: fn() {\n        return { value: self.value, clone: self.clone };\n    }\n};\n```\n\n### Melange de champs et methodes\n\n```hemlock\ndefine Entity {\n    id: i32,\n    name: string,\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\nlet user: Entity = {\n    id: 1,\n    name: \"Alice\",\n    validate: fn() { return self.id > 0 && self.name != \"\"; },\n    serialize: fn() { return '{\"id\":' + self.id + ',\"name\":\"' + self.name + '\"}'; }\n};\n```\n\n## Types composes (types d'intersection)\n\nLes types composes utilisent `&` pour exiger qu'un objet satisfasse plusieurs definitions de type :\n\n### Types composes basiques\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\n// Type compose : l'objet doit satisfaire TOUS les types\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n```\n\n### Parametres de fonction avec types composes\n\n```hemlock\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" a \" + p.age + \" ans\");\n}\n\ngreet({ name: \"Bob\", age: 25, city: \"NYC\" });  // Champs supplementaires OK\n```\n\n### Trois types ou plus\n\n```hemlock\ndefine HasEmail { email: string }\n\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n### Alias de type pour types composes\n\n```hemlock\n// Creer un alias nomme pour un type compose\ntype Person = HasName & HasAge;\ntype Employee = HasName & HasAge & HasEmail;\n\nlet emp: Employee = {\n    name: \"Charlie\",\n    age: 35,\n    email: \"charlie@example.com\"\n};\n```\n\n**Typage canard avec composes :** Les champs supplementaires sont toujours autorises - l'objet doit juste avoir au moins les champs requis par tous les types composants.\n\n## Serialisation JSON\n\n### Serialiser en JSON\n\nConvertir des objets en chaines JSON :\n\n```hemlock\n// obj.serialize() - Convertir l'objet en chaine JSON\nlet obj = { x: 10, y: 20, name: \"test\" };\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// Objets imbriques\nlet nested = { inner: { a: 1, b: 2 }, outer: 3 };\nprint(nested.serialize());  // {\"inner\":{\"a\":1,\"b\":2},\"outer\":3}\n```\n\n### Deserialiser depuis JSON\n\nAnalyser des chaines JSON vers des objets :\n\n```hemlock\n// json.deserialize() - Analyser chaine JSON vers objet\nlet json_str = '{\"x\":10,\"y\":20,\"name\":\"test\"}';\nlet obj = json_str.deserialize();\n\nprint(obj.name);   // \"test\"\nprint(obj.x);      // 10\n```\n\n### Detection de cycle\n\nLes references circulaires sont detectees et causent des erreurs :\n\n```hemlock\nlet obj = { x: 10 };\nobj.me = obj;  // Creer une reference circulaire\n\nobj.serialize();  // ERREUR : serialize() detected circular reference\n```\n\n### Types supportes\n\nLa serialisation JSON supporte :\n\n- **Nombres** : i8-i32, u8-u32, f32, f64\n- **Booleens** : true, false\n- **Chaines** : Avec sequences d'echappement\n- **Null** : valeur null\n- **Objets** : Objets imbriques\n- **Tableaux** : Tableaux imbriques\n\n**Non supporte :**\n- Fonctions (omises silencieusement)\n- Pointeurs (erreur)\n- Buffers (erreur)\n\n### Gestion des erreurs\n\nLa serialisation et deserialisation peuvent lever des erreurs :\n\n```hemlock\n// JSON invalide leve une erreur\ntry {\n    let bad = \"pas du json valide\".deserialize();\n} catch (e) {\n    print(\"Erreur d'analyse :\", e);\n}\n\n// Les pointeurs ne peuvent pas etre serialises\nlet obj = { ptr: alloc(10) };\ntry {\n    obj.serialize();\n} catch (e) {\n    print(\"Erreur de serialisation :\", e);\n}\n```\n\n### Exemple aller-retour\n\nExemple complet de serialisation et deserialisation :\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug: bool\n}\n\n// Creer et serialiser\nlet config: Config = {\n    host: \"localhost\",\n    port: 8080,\n    debug: true\n};\nlet json = config.serialize();\nprint(json);  // {\"host\":\"localhost\",\"port\":8080,\"debug\":true}\n\n// Deserialiser\nlet restored = json.deserialize();\nprint(restored.host);  // \"localhost\"\nprint(restored.port);  // 8080\n```\n\n## Fonctions integrees\n\n### `typeof(value)`\n\nRetourne le nom du type sous forme de chaine :\n\n```hemlock\nlet obj = { x: 10 };\nprint(typeof(obj));  // \"object\"\n\ndefine Person { name: string, age: i32 }\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(typeof(p));    // \"Person\"\n```\n\n**Valeurs de retour :**\n- Objets anonymes : `\"object\"`\n- Objets types : Nom de type personnalise (ex. `\"Person\"`)\n\n## Details d'implementation\n\n### Modele memoire\n\n- **Alloue sur le tas** - Tous les objets sont alloues sur le tas\n- **Copie superficielle** - L'assignation copie la reference, pas l'objet\n- **Champs dynamiques** - Stockes comme tableaux dynamiques de paires nom/valeur\n- **Compte par reference** - Les objets sont automatiquement liberes quand la portee se termine\n\n### Semantique de reference\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Copie superficielle (meme reference)\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (les deux font reference au meme objet)\n```\n\n### Stockage des methodes\n\nLes methodes sont simplement des fonctions stockees dans des champs :\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// method est une fonction stockee dans obj.method\nprint(typeof(obj.method));  // \"function\"\n```\n\n## Modeles courants\n\n### Modele : Fonction constructeur\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Salut, je suis \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Salut, je suis Alice\"\n```\n\n### Modele : Constructeur d'objet (Builder)\n\n```hemlock\nfn PersonBuilder() {\n    return {\n        name: null,\n        age: null,\n\n        setName: fn(n) {\n            self.name = n;\n            return self;  // Permettre le chainage\n        },\n\n        setAge: fn(a) {\n            self.age = a;\n            return self;\n        },\n\n        build: fn() {\n            return { name: self.name, age: self.age };\n        }\n    };\n}\n\nlet person = PersonBuilder()\n    .setName(\"Alice\")\n    .setAge(30)\n    .build();\n```\n\n### Modele : Objet d'etat\n\n```hemlock\nlet state = {\n    status: \"idle\",\n    data: null,\n    error: null,\n\n    setState: fn(new_status) {\n        self.status = new_status;\n    },\n\n    setData: fn(new_data) {\n        self.data = new_data;\n        self.status = \"success\";\n    },\n\n    setError: fn(err) {\n        self.error = err;\n        self.status = \"error\";\n    }\n};\n```\n\n### Modele : Objet de configuration\n\n```hemlock\nlet config = {\n    defaults: {\n        timeout: 30,\n        retries: 3,\n        debug: false\n    },\n\n    get: fn(key) {\n        if (self.defaults[key] != null) {\n            return self.defaults[key];\n        }\n        return null;\n    },\n\n    set: fn(key, value) {\n        self.defaults[key] = value;\n    }\n};\n```\n\n## Bonnes pratiques\n\n1. **Utilisez `define` pour la structure** - Documentez les formes d'objet attendues\n2. **Preferez les fonctions usine** - Creez des objets avec des constructeurs\n3. **Gardez les objets simples** - N'imbriquez pas trop profondement\n4. **Documentez l'utilisation de `self`** - Rendez le comportement des methodes clair\n5. **Validez a l'assignation** - Utilisez le typage canard pour detecter les erreurs tot\n6. **Evitez les references circulaires** - Causera des erreurs de serialisation\n7. **Utilisez les champs optionnels** - Fournissez des defauts raisonnables\n\n## Pieges courants\n\n### Piege : Reference vs. valeur\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Copie superficielle\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (surprise ! les deux ont change)\n\n// Pour eviter : Creer un nouvel objet\nlet obj3 = { x: obj1.x };  // Copie profonde (manuelle)\n```\n\n### Piege : `self` dans les appels non-methode\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// Fonctionne : Appele comme methode\nprint(obj.method());  // 10\n\n// ERREUR : Appele comme fonction\nlet f = obj.method;\nprint(f());  // ERREUR : self is not defined\n```\n\n### Piege : Pointeurs bruts dans les objets\n\n```hemlock\n// Les objets sont auto-liberes, mais les pointeurs bruts a l'interieur NE le sont PAS\nfn create_objects() {\n    let obj = { data: alloc(1000) };  // ptr brut necessite free manuel\n    // obj est auto-libere quand la portee se termine, mais obj.data fuit !\n}\n\n// Solution : Liberer les pointeurs bruts avant la sortie de portee\nfn safe_create() {\n    let obj = { data: alloc(1000) };\n    // ... utiliser obj.data ...\n    free(obj.data);  // Liberer le pointeur brut explicitement\n}  // obj lui-meme est auto-libere\n```\n\n### Piege : Confusion de type\n\n```hemlock\nlet obj = { x: 10 };\n\ndefine Point { x: i32, y: i32 }\n\n// ERREUR : Champ requis 'y' manquant\nlet p: Point = obj;\n```\n\n## Exemples\n\n### Exemple : Mathematiques vectorielles\n\n```hemlock\nfn createVector(x, y) {\n    return {\n        x: x,\n        y: y,\n\n        add: fn(other) {\n            return createVector(\n                self.x + other.x,\n                self.y + other.y\n            );\n        },\n\n        length: fn() {\n            return sqrt(self.x * self.x + self.y * self.y);\n        },\n\n        toString: fn() {\n            return \"(\" + typeof(self.x) + \", \" + typeof(self.y) + \")\";\n        }\n    };\n}\n\nlet v1 = createVector(3, 4);\nlet v2 = createVector(1, 2);\nlet v3 = v1.add(v2);\n\nprint(v3.toString());  // \"(4, 6)\"\n```\n\n### Exemple : Base de donnees simple\n\n```hemlock\nfn createDatabase() {\n    let records = [];\n    let next_id = 1;\n\n    return {\n        insert: fn(data) {\n            let record = { id: next_id, data: data };\n            records.push(record);\n            next_id = next_id + 1;\n            return record.id;\n        },\n\n        find: fn(id) {\n            let i = 0;\n            while (i < records.length) {\n                if (records[i].id == id) {\n                    return records[i];\n                }\n                i = i + 1;\n            }\n            return null;\n        },\n\n        count: fn() {\n            return records.length;\n        }\n    };\n}\n\nlet db = createDatabase();\nlet id = db.insert({ name: \"Alice\", age: 30 });\nlet record = db.find(id);\nprint(record.data.name);  // \"Alice\"\n```\n\n### Exemple : Emetteur d'evenements\n\n```hemlock\nfn createEventEmitter() {\n    let listeners = {};\n\n    return {\n        on: fn(event, handler) {\n            if (listeners[event] == null) {\n                listeners[event] = [];\n            }\n            listeners[event].push(handler);\n        },\n\n        emit: fn(event, data) {\n            if (listeners[event] != null) {\n                let i = 0;\n                while (i < listeners[event].length) {\n                    listeners[event][i](data);\n                    i = i + 1;\n                }\n            }\n        }\n    };\n}\n\nlet emitter = createEventEmitter();\n\nemitter.on(\"message\", fn(data) {\n    print(\"Recu : \" + data);\n});\n\nemitter.emit(\"message\", \"Bonjour !\");\n```\n\n## Limitations\n\nLimitations actuelles :\n\n- **Pas de copie profonde** - Doit copier manuellement les objets imbriques (spread est superficiel)\n- **Pas de passage par valeur** - Les objets sont toujours passes par reference\n- **Pas de proprietes calculees** - Pas de syntaxe `{[key]: value}`\n- **`self` est en lecture seule** - Impossible de reassigner `self` dans les methodes\n- **Pas de suppression de propriete** - Impossible de supprimer des champs une fois ajoutes\n\n**Note :** Les objets sont comptes par reference et automatiquement liberes quand la portee se termine. Voir [Gestion de la memoire](memory.md#internal-reference-counting) pour les details.\n\n## Sujets connexes\n\n- [Fonctions](#language-guide-functions) - Les methodes sont des fonctions stockees dans les objets\n- [Tableaux](#language-guide-arrays) - Les tableaux sont aussi similaires a des objets\n- [Types](#language-guide-types) - Typage canard et definitions de type\n- [Gestion des erreurs](#language-guide-error-handling) - Lever des objets d'erreur\n\n## Voir aussi\n\n- **Typage canard** : Voir section \"Objects\" de CLAUDE.md pour les details du typage canard\n- **JSON** : Voir CLAUDE.md pour les details de serialisation JSON\n- **Memoire** : Voir [Memoire](#language-guide-memory) pour l'allocation d'objet\n"}, "Guide du Langage -> Runes": {"id": "language-guide-runes", "content": "# Runes\n\nLes runes representent des **points de code Unicode** (U+0000 a U+10FFFF) comme un type distinct pour la manipulation de caracteres en Hemlock. Contrairement aux octets (u8), les runes sont des caracteres Unicode complets qui peuvent representer n'importe quel caractere dans n'importe quelle langue ou emoji.\n\n## Apercu\n\n```hemlock\nlet ch = 'A';           // Litteral de rune\nlet emoji = 'rocket';   // Caractere multi-octet comme rune unique\nprint(ch);              // 'A'\nprint(emoji);           // U+1F680\n\nlet s = \"Hello \" + '!'; // Concatenation chaine + rune\nlet r = '>' + \" msg\";   // Concatenation rune + chaine\n```\n\n## Qu'est-ce qu'une rune ?\n\nUne rune est une **valeur de 32 bits** representant un point de code Unicode :\n\n- **Plage :** 0 a 0x10FFFF (1 114 111 points de code valides)\n- **Pas un type numerique** - Utilisee pour la representation de caracteres\n- **Distincte de u8/char** - Les runes sont du plein Unicode, u8 est juste des octets\n- **Retournee par l'indexation de chaine** - `str[0]` retourne une rune, pas un octet\n\n**Pourquoi les runes ?**\n- Les chaines Hemlock sont encodees en UTF-8\n- Un seul caractere Unicode peut faire de 1 a 4 octets en UTF-8\n- Les runes permettent de travailler avec des caracteres complets, pas des octets partiels\n\n## Litteraux de rune\n\n### Syntaxe de base\n\nLes guillemets simples denotent les litteraux de rune :\n\n```hemlock\nlet a = 'A';            // Caractere ASCII\nlet b = '0';            // Caractere chiffre\nlet c = '!';            // Ponctuation\nlet d = ' ';            // Espace\n```\n\n### Caracteres UTF-8 multi-octets\n\nLes runes peuvent representer n'importe quel caractere Unicode :\n\n```hemlock\n// Emoji\nlet rocket = 'rocket';  // Emoji (U+1F680)\nlet heart = 'coeur';    // Coeur (U+2764)\nlet smile = 'sourire';  // Visage souriant (U+1F600)\n\n// Caracteres CJK\nlet chinese = 'zhong';  // Chinois (U+4E2D)\nlet japanese = 'a';     // Hiragana (U+3042)\nlet korean = 'han';     // Hangul (U+D55C)\n\n// Symboles\nlet check = 'coche';    // Coche (U+2713)\nlet arrow = 'fleche';   // Fleche droite (U+2192)\n```\n\n### Sequences d'echappement\n\nSequences d'echappement communes pour les caracteres speciaux :\n\n```hemlock\nlet newline = '\\n';     // Nouvelle ligne (U+000A)\nlet tab = '\\t';         // Tabulation (U+0009)\nlet backslash = '\\\\';   // Antislash (U+005C)\nlet quote = '\\'';       // Guillemet simple (U+0027)\nlet dquote = '\"';       // Guillemet double (U+0022)\nlet null_char = '\\0';   // Caractere nul (U+0000)\nlet cr = '\\r';          // Retour chariot (U+000D)\n```\n\n**Sequences d'echappement disponibles :**\n- `\\n` - Nouvelle ligne (saut de ligne)\n- `\\t` - Tabulation horizontale\n- `\\r` - Retour chariot\n- `\\0` - Caractere nul\n- `\\\\` - Antislash\n- `\\'` - Guillemet simple\n- `\\\"` - Guillemet double\n\n### Echappements Unicode\n\nUtilisez la syntaxe `\\u{XXXXXX}` pour les points de code Unicode (jusqu'a 6 chiffres hexadecimaux) :\n\n```hemlock\nlet rocket = '\\u{1F680}';   // Emoji fusee via echappement Unicode\nlet heart = '\\u{2764}';     // Coeur\nlet ascii = '\\u{41}';       // 'A' via echappement\nlet max = '\\u{10FFFF}';     // Point de code Unicode maximum\n\n// Zeros initiaux optionnels\nlet a = '\\u{41}';           // Identique a '\\u{0041}'\nlet b = '\\u{0041}';\n```\n\n**Regles :**\n- Plage : `\\u{0}` a `\\u{10FFFF}`\n- Chiffres hex : 1 a 6 chiffres\n- Insensible a la casse : `\\u{1F680}` ou `\\u{1f680}`\n- Les valeurs hors de la plage Unicode valide causent une erreur\n\n## Concatenation chaine + rune\n\nLes runes peuvent etre concatenees avec des chaines :\n\n```hemlock\n// Chaine + rune\nlet greeting = \"Hello\" + '!';       // \"Hello!\"\nlet decorated = \"Text\" + 'coche';   // \"Textcoche\"\n\n// Rune + chaine\nlet prefix = '>' + \" Message\";      // \"> Message\"\nlet bullet = 'puce' + \" Element\";   // \"puce Element\"\n\n// Concatenations multiples\nlet msg = \"Hi \" + 'salut' + \" World \" + 'terre';  // \"Hi salut World terre\"\n\n// Le chainage de methodes fonctionne\nlet result = ('>' + \" Important\").to_upper();  // \"> IMPORTANT\"\n```\n\n**Fonctionnement :**\n- Les runes sont automatiquement encodees en UTF-8\n- Converties en chaines pendant la concatenation\n- L'operateur de concatenation de chaine gere cela de maniere transparente\n\n## Conversions de type\n\nLes runes peuvent se convertir vers/depuis d'autres types.\n\n### Entier <-> Rune\n\nConvertir entre entiers et runes pour travailler avec les valeurs de point de code :\n\n```hemlock\n// Entier vers rune (valeur de point de code)\nlet code: rune = 65;            // 'A' (ASCII 65)\nlet emoji_code: rune = 128640;  // U+1F680 (fusee)\n\n// Rune vers entier (obtenir la valeur du point de code)\nlet r = 'Z';\nlet value: i32 = r;             // 90 (valeur ASCII)\n\nlet rocket = 'fusee';\nlet code: i32 = rocket;         // 128640 (U+1F680)\n```\n\n**Verification de plage :**\n- Entier vers rune : Doit etre dans [0, 0x10FFFF]\n- Les valeurs hors plage causent une erreur d'execution\n- Rune vers entier : Reussit toujours (retourne le point de code)\n\n### Rune -> Chaine\n\nLes runes peuvent etre explicitement converties en chaines :\n\n```hemlock\n// Conversion explicite\nlet ch: string = 'H';           // \"H\"\nlet emoji: string = 'fusee';    // \"fusee\"\n\n// Automatique pendant la concatenation\nlet s = \"\" + 'A';               // \"A\"\nlet s2 = \"x\" + 'y' + \"z\";       // \"xyz\"\n```\n\n### u8 (octet) -> Rune\n\nToute valeur u8 (0-255) peut se convertir en rune :\n\n```hemlock\n// Plage ASCII (0-127)\nlet byte: u8 = 65;\nlet rune_val: rune = byte;      // 'A'\n\n// ASCII etendu / Latin-1 (128-255)\nlet extended: u8 = 200;\nlet r: rune = extended;         // U+00C8 (E accent grave)\n\n// Note : Les valeurs 0-127 sont ASCII, 128-255 sont Latin-1\n```\n\n### Conversions chainees\n\nLes conversions de type peuvent etre chainees :\n\n```hemlock\n// i32 -> rune -> string\nlet code: i32 = 128512;         // Point de code visage souriant\nlet r: rune = code;             // sourire\nlet s: string = r;              // \"sourire\"\n\n// Tout en une expression\nlet emoji: string = 128640;     // Implicite i32 -> rune -> string (fusee)\n```\n\n## Operations sur les runes\n\n### Affichage\n\nLa facon dont les runes sont affichees depend du point de code :\n\n```hemlock\nlet ascii = 'A';\nprint(ascii);                   // 'A' (entre guillemets, ASCII imprimable)\n\nlet emoji = 'fusee';\nprint(emoji);                   // U+1F680 (notation Unicode pour non-ASCII)\n\nlet tab = '\\t';\nprint(tab);                     // U+0009 (non-imprimable en hex)\n\nlet space = ' ';\nprint(space);                   // ' ' (imprimable)\n```\n\n**Format d'affichage :**\n- ASCII imprimable (32-126) : Caractere entre guillemets `'A'`\n- Non-imprimable ou Unicode : Notation hex `U+XXXX`\n\n### Verification de type\n\nUtilisez `typeof()` pour verifier si une valeur est une rune :\n\n```hemlock\nlet r = 'fusee';\nprint(typeof(r));               // \"rune\"\n\nlet s = \"text\";\nlet ch = s[0];\nprint(typeof(ch));              // \"rune\" (l'indexation retourne des runes)\n\nlet num = 65;\nprint(typeof(num));             // \"i32\"\n```\n\n### Comparaison\n\nLes runes peuvent etre comparees pour l'egalite :\n\n```hemlock\nlet a = 'A';\nlet b = 'B';\nprint(a == a);                  // true\nprint(a == b);                  // false\n\n// Sensible a la casse\nlet upper = 'A';\nlet lower = 'a';\nprint(upper == lower);          // false\n\n// Les runes peuvent etre comparees avec des entiers (valeurs de point de code)\nprint(a == 65);                 // true (conversion implicite)\nprint('fusee' == 128640);       // true\n```\n\n**Operateurs de comparaison :**\n- `==` - Egal\n- `!=` - Different\n- `<`, `>`, `<=`, `>=` - Ordre des points de code\n\n```hemlock\nprint('A' < 'B');               // true (65 < 66)\nprint('a' > 'Z');               // true (97 > 90)\n```\n\n## Travailler avec l'indexation de chaine\n\nL'indexation de chaine retourne des runes, pas des octets :\n\n```hemlock\nlet s = \"Hellofusee\";\nlet h = s[0];                   // 'H' (rune)\nlet rocket = s[5];              // 'fusee' (rune)\n\nprint(typeof(h));               // \"rune\"\nprint(typeof(rocket));          // \"rune\"\n\n// Convertir en chaine si necessaire\nlet h_str: string = h;          // \"H\"\nlet rocket_str: string = rocket; // \"fusee\"\n```\n\n**Important :** L'indexation de chaine utilise les positions de point de code, pas les decalages d'octets :\n\n```hemlock\nlet text = \"Hifusee!\";\n// Positions de point de code : 0='H', 1='i', 2='fusee', 3='!'\n// Positions d'octet :          0='H', 1='i', 2-5='fusee', 6='!'\n\nlet r = text[2];                // 'fusee' (point de code 2)\nprint(typeof(r));               // \"rune\"\n```\n\n## Exemples\n\n### Exemple : Classification de caracteres\n\n```hemlock\nfn is_digit(r: rune): bool {\n    return r >= '0' && r <= '9';\n}\n\nfn is_upper(r: rune): bool {\n    return r >= 'A' && r <= 'Z';\n}\n\nfn is_lower(r: rune): bool {\n    return r >= 'a' && r <= 'z';\n}\n\nprint(is_digit('5'));           // true\nprint(is_upper('A'));           // true\nprint(is_lower('z'));           // true\n```\n\n### Exemple : Conversion de casse\n\n```hemlock\nfn to_upper_rune(r: rune): rune {\n    if (r >= 'a' && r <= 'z') {\n        // Convertir en majuscule (soustraire 32)\n        let code: i32 = r;\n        code = code - 32;\n        return code;\n    }\n    return r;\n}\n\nfn to_lower_rune(r: rune): rune {\n    if (r >= 'A' && r <= 'Z') {\n        // Convertir en minuscule (ajouter 32)\n        let code: i32 = r;\n        code = code + 32;\n        return code;\n    }\n    return r;\n}\n\nprint(to_upper_rune('a'));      // 'A'\nprint(to_lower_rune('Z'));      // 'z'\n```\n\n### Exemple : Iteration sur les caracteres\n\n```hemlock\nfn print_chars(s: string) {\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        print(\"Position \" + typeof(i) + \": \" + typeof(ch));\n        i = i + 1;\n    }\n}\n\nprint_chars(\"Hifusee\");\n// Position 0: 'H'\n// Position 1: 'i'\n// Position 2: U+1F680\n```\n\n### Exemple : Construire des chaines a partir de runes\n\n```hemlock\nfn repeat_char(ch: rune, count: i32): string {\n    let result = \"\";\n    let i = 0;\n    while (i < count) {\n        result = result + ch;\n        i = i + 1;\n    }\n    return result;\n}\n\nlet line = repeat_char('=', 40);  // \"========================================\"\nlet stars = repeat_char('etoile', 5);  // \"etoileetoileetoileetoileetoile\"\n```\n\n## Modeles courants\n\n### Modele : Filtre de caracteres\n\n```hemlock\nfn filter_digits(s: string): string {\n    let result = \"\";\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        if (ch >= '0' && ch <= '9') {\n            result = result + ch;\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet text = \"abc123def456\";\nlet digits = filter_digits(text);  // \"123456\"\n```\n\n### Modele : Comptage de caracteres\n\n```hemlock\nfn count_char(s: string, target: rune): i32 {\n    let count = 0;\n    let i = 0;\n    while (i < s.length) {\n        if (s[i] == target) {\n            count = count + 1;\n        }\n        i = i + 1;\n    }\n    return count;\n}\n\nlet text = \"hello world\";\nlet l_count = count_char(text, 'l');  // 3\nlet o_count = count_char(text, 'o');  // 2\n```\n\n## Bonnes pratiques\n\n1. **Utilisez les runes pour les operations sur les caracteres** - N'essayez pas de travailler avec des octets pour le texte\n2. **L'indexation de chaine retourne des runes** - Rappelez-vous que `str[i]` vous donne une rune\n3. **Comparaisons compatibles Unicode** - Les runes gerent n'importe quel caractere Unicode\n4. **Convertissez quand necessaire** - Les runes se convertissent facilement en chaines et entiers\n5. **Testez avec des emoji** - Testez toujours les operations sur les caracteres avec des caracteres multi-octets\n\n## Pieges courants\n\n### Piege : Confusion rune vs. octet\n\n```hemlock\n// NE PAS : Traiter les runes comme des octets\nlet r: rune = 'fusee';\nlet b: u8 = r;              // ERREUR : Le point de code 128640 ne tient pas dans u8\n\n// FAIRE : Utiliser les conversions appropriees\nlet r: rune = 'fusee';\nlet code: i32 = r;          // OK : 128640\n```\n\n### Piege : Indexation d'octet de chaine\n\n```hemlock\n// NE PAS : Supposer l'indexation par octet\nlet s = \"fusee\";\nlet byte = s.byte_at(0);    // 240 (premier octet UTF-8, pas le caractere complet)\n\n// FAIRE : Utiliser l'indexation par point de code\nlet s = \"fusee\";\nlet rune = s[0];            // 'fusee' (caractere complet)\nlet rune2 = s.char_at(0);   // 'fusee' (methode explicite)\n```\n\n## Sujets connexes\n\n- [Chaines](#language-guide-strings) - Operations sur les chaines et gestion UTF-8\n- [Types](#language-guide-types) - Systeme de types et conversions\n- [Flux de controle](#language-guide-control-flow) - Utiliser les runes dans les comparaisons\n\n## Voir aussi\n\n- **Standard Unicode** : Les points de code Unicode sont definis par le Consortium Unicode\n- **Encodage UTF-8** : Voir [Chaines](#language-guide-strings) pour les details UTF-8\n- **Conversions de type** : Voir [Types](#language-guide-types) pour les regles de conversion\n"}, "Guide du Langage -> Syntaxe": {"id": "language-guide-syntax", "content": "# Apercu de la syntaxe\n\nCe document couvre les regles de syntaxe fondamentales et la structure des programmes Hemlock.\n\n## Regles de syntaxe de base\n\n### Les points-virgules sont obligatoires\n\nContrairement a JavaScript ou Python, les points-virgules sont **toujours requis** a la fin des instructions :\n\n```hemlock\nlet x = 42;\nlet y = 10;\nprint(x + y);\n```\n\n**Ceci provoquera une erreur :**\n```hemlock\nlet x = 42  // ERREUR : Point-virgule manquant\nlet y = 10  // ERREUR : Point-virgule manquant\n```\n\n### Les accolades sont toujours requises\n\nTous les blocs de flux de controle doivent utiliser des accolades, meme pour les instructions simples :\n\n```hemlock\n// CORRECT\nif (x > 0) {\n    print(\"positif\");\n}\n\n// ERREUR : Accolades manquantes\nif (x > 0)\n    print(\"positif\");\n```\n\n### Commentaires\n\n```hemlock\n// Ceci est un commentaire sur une seule ligne\n\n/*\n   Ceci est un\n   commentaire multi-lignes\n*/\n\nlet x = 42;  // Commentaire en ligne\n```\n\n## Variables\n\n### Declaration\n\nLes variables sont declarees avec `let` :\n\n```hemlock\nlet count = 0;\nlet name = \"Alice\";\nlet pi = 3.14159;\n```\n\n### Annotations de type (optionnelles)\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet flag: bool = true;\nlet text: string = \"bonjour\";\n```\n\n### Constantes\n\nUtilisez `const` pour les valeurs immuables :\n\n```hemlock\nconst MAX_SIZE: i32 = 1000;\nconst PI: f64 = 3.14159;\n```\n\nTenter de reassigner une constante entrainera une erreur d'execution : \"Cannot assign to const variable\".\n\n## Expressions\n\n### Operateurs arithmetiques\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13 - Addition\nprint(a - b);   // 7  - Soustraction\nprint(a * b);   // 30 - Multiplication\nprint(a / b);   // 3  - Division (entiere)\n```\n\n### Operateurs de comparaison\n\n```hemlock\nprint(a == b);  // false - Egal\nprint(a != b);  // true  - Different\nprint(a > b);   // true  - Superieur a\nprint(a < b);   // false - Inferieur a\nprint(a >= b);  // true  - Superieur ou egal\nprint(a <= b);  // false - Inferieur ou egal\n```\n\n### Operateurs logiques\n\n```hemlock\nlet x = true;\nlet y = false;\n\nprint(x && y);  // false - ET\nprint(x || y);  // true  - OU\nprint(!x);      // false - NON\n```\n\n### Operateurs binaires (bitwise)\n\n```hemlock\nlet a = 12;  // 1100\nlet b = 10;  // 1010\n\nprint(a & b);   // 8  - ET binaire\nprint(a | b);   // 14 - OU binaire\nprint(a ^ b);   // 6  - XOR binaire\nprint(a << 2);  // 48 - Decalage a gauche\nprint(a >> 1);  // 6  - Decalage a droite\nprint(~a);      // -13 - NON binaire\n```\n\n### Priorite des operateurs\n\nDe la plus haute a la plus basse :\n\n1. `()` - Groupement\n2. `!`, `~`, `-` (unaire) - Operateurs unaires\n3. `*`, `/` - Multiplication, Division\n4. `+`, `-` - Addition, Soustraction\n5. `<<`, `>>` - Decalages binaires\n6. `<`, `<=`, `>`, `>=` - Comparaisons\n7. `==`, `!=` - Egalite\n8. `&` - ET binaire\n9. `^` - XOR binaire\n10. `|` - OU binaire\n11. `&&` - ET logique\n12. `||` - OU logique\n\n**Exemples :**\n```hemlock\nlet x = 2 + 3 * 4;      // 14 (pas 20)\nlet y = (2 + 3) * 4;    // 20\nlet z = 5 << 2 + 1;     // 40 (5 << 3)\n```\n\n## Flux de controle\n\n### Instructions If\n\n```hemlock\nif (condition) {\n    // corps\n}\n\nif (condition) {\n    // branche then\n} else {\n    // branche else\n}\n\nif (condition1) {\n    // branche 1\n} else if (condition2) {\n    // branche 2\n} else {\n    // branche par defaut\n}\n```\n\n### Boucles While\n\n```hemlock\nwhile (condition) {\n    // corps\n}\n```\n\n**Exemple :**\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n### Boucles For\n\n**Style C :**\n```hemlock\nfor (initialiseur; condition; increment) {\n    // corps\n}\n```\n\n**Exemple :**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**For-in (tableaux) :**\n```hemlock\nfor (let item in array) {\n    // corps\n}\n```\n\n**Exemple :**\n```hemlock\nlet items = [10, 20, 30];\nfor (let x in items) {\n    print(x);\n}\n```\n\n### Instructions Switch\n\n```hemlock\nswitch (expression) {\n    case valeur1:\n        // corps\n        break;\n    case valeur2:\n        // corps\n        break;\n    default:\n        // corps par defaut\n        break;\n}\n```\n\n**Exemple :**\n```hemlock\nlet day = 3;\nswitch (day) {\n    case 1:\n        print(\"Lundi\");\n        break;\n    case 2:\n        print(\"Mardi\");\n        break;\n    case 3:\n        print(\"Mercredi\");\n        break;\n    default:\n        print(\"Autre\");\n        break;\n}\n```\n\n### Break et Continue\n\n```hemlock\n// Break : sortir de la boucle\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n}\n\n// Continue : passer a l'iteration suivante\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;\n    }\n    print(i);\n}\n```\n\n## Fonctions\n\n### Fonctions nommees\n\n```hemlock\nfn function_name(param1: type1, param2: type2): return_type {\n    // corps\n    return value;\n}\n```\n\n**Exemple :**\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Fonctions anonymes\n\n```hemlock\nlet func = fn(params) {\n    // corps\n};\n```\n\n**Exemple :**\n```hemlock\nlet multiply = fn(x, y) {\n    return x * y;\n};\n```\n\n### Annotations de type (optionnelles)\n\n```hemlock\n// Sans annotations (types inferes)\nfn greet(name) {\n    return \"Bonjour, \" + name;\n}\n\n// Avec annotations (verifiees a l'execution)\nfn divide(a: i32, b: i32): f64 {\n    return a / b;\n}\n```\n\n## Objets\n\n### Litteraux d'objet\n\n```hemlock\nlet obj = {\n    field1: value1,\n    field2: value2,\n};\n```\n\n**Exemple :**\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    active: true,\n};\n```\n\n### Methodes\n\n```hemlock\nlet obj = {\n    method: fn() {\n        self.field = value;\n    },\n};\n```\n\n**Exemple :**\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n};\n```\n\n### Definitions de type\n\n```hemlock\ndefine TypeName {\n    field1: type1,\n    field2: type2,\n    optional_field?: default_value,\n}\n```\n\n**Exemple :**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,\n}\n```\n\n## Tableaux\n\n### Litteraux de tableau\n\n```hemlock\nlet arr = [element1, element2, element3];\n```\n\n**Exemple :**\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet mixed = [1, \"deux\", true, null];\nlet empty = [];\n```\n\n### Indexation de tableau\n\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);   // 10\narr[1] = 99;     // Modifier un element\n```\n\n## Gestion des erreurs\n\n### Try/Catch\n\n```hemlock\ntry {\n    // code risque\n} catch (e) {\n    // gerer l'erreur\n}\n```\n\n### Try/Finally\n\n```hemlock\ntry {\n    // code risque\n} finally {\n    // s'execute toujours\n}\n```\n\n### Try/Catch/Finally\n\n```hemlock\ntry {\n    // code risque\n} catch (e) {\n    // gerer l'erreur\n} finally {\n    // nettoyage\n}\n```\n\n### Throw\n\n```hemlock\nthrow expression;\n```\n\n**Exemple :**\n```hemlock\nif (x < 0) {\n    throw \"x doit etre positif\";\n}\n```\n\n### Panic\n\n```hemlock\npanic(message);\n```\n\n**Exemple :**\n```hemlock\npanic(\"erreur irrecuperable\");\n```\n\n## Modules (experimental)\n\n### Instructions d'export\n\n```hemlock\nexport fn function_name() { }\nexport const CONSTANT = value;\nexport let variable = value;\nexport { name1, name2 };\n```\n\n### Instructions d'import\n\n```hemlock\nimport { name1, name2 } from \"./module.hml\";\nimport * as namespace from \"./module.hml\";\nimport { name as alias } from \"./module.hml\";\n```\n\n## Async (experimental)\n\n### Fonctions asynchrones\n\n```hemlock\nasync fn function_name(params): return_type {\n    // corps\n}\n```\n\n### Spawn/Join\n\n```hemlock\nlet task = spawn(async_function, arg1, arg2);\nlet result = join(task);\n```\n\n### Canaux (Channels)\n\n```hemlock\nlet ch = channel(capacity);\nch.send(value);\nlet value = ch.recv();\nch.close();\n```\n\n## FFI (Interface de fonction etrangere)\n\n### Importer une bibliotheque partagee\n\n```hemlock\nimport \"library_name.so\";\n```\n\n### Declarer une fonction externe\n\n```hemlock\nextern fn function_name(param: type): return_type;\n```\n\n**Exemple :**\n```hemlock\nimport \"libc.so.6\";\nextern fn strlen(s: string): i32;\n```\n\n## Litteraux\n\n### Litteraux entiers\n\n```hemlock\nlet decimal = 42;\nlet negative = -100;\nlet large = 5000000000;  // Auto i64\n\n// Hexadecimal (prefixe 0x)\nlet hex = 0xDEADBEEF;\nlet hex2 = 0xFF;\n\n// Binaire (prefixe 0b)\nlet bin = 0b1010;\nlet bin2 = 0b11110000;\n\n// Octal (prefixe 0o)\nlet oct = 0o777;\nlet oct2 = 0O123;\n\n// Separateurs numeriques pour la lisibilite\nlet million = 1_000_000;\nlet hex_sep = 0xFF_FF_FF;\nlet bin_sep = 0b1111_0000_1010_0101;\nlet oct_sep = 0o77_77;\n```\n\n### Litteraux flottants\n\n```hemlock\nlet f = 3.14;\nlet e = 2.71828;\nlet sci = 1.5e-10;       // Notation scientifique\nlet sci2 = 2.5E+3;       // E majuscule fonctionne aussi\nlet no_lead = .5;        // Sans zero initial (0.5)\nlet sep = 3.14_159_265;  // Separateurs numeriques\n```\n\n### Litteraux de chaine\n\n```hemlock\nlet s = \"bonjour\";\nlet escaped = \"ligne1\\nligne2\\ttabulation\";\nlet quote = \"Elle a dit \\\"bonjour\\\"\";\n\n// Sequences d'echappement hexadecimales\nlet hex_esc = \"\\x48\\x65\\x6c\\x6c\\x6f\";  // \"Hello\"\n\n// Sequences d'echappement Unicode\nlet emoji = \"\\u{1F600}\";               // grinning face\nlet heart = \"\\u{2764}\";                // coeur\nlet mixed = \"Bonjour \\u{1F30D}!\";      // Bonjour globe!\n```\n\n**Sequences d'echappement :**\n- `\\n` - nouvelle ligne\n- `\\t` - tabulation\n- `\\r` - retour chariot\n- `\\\\` - barre oblique inverse\n- `\\\"` - guillemet double\n- `\\'` - guillemet simple\n- `\\0` - caractere nul\n- `\\xNN` - echappement hexadecimal (2 chiffres)\n- `\\u{XXXX}` - echappement unicode (1-6 chiffres)\n\n### Litteraux de rune\n\n```hemlock\nlet ch = 'A';\nlet emoji = 'rocket';\nlet escaped = '\\n';\nlet unicode = '\\u{1F680}';\nlet hex_rune = '\\x41';      // 'A'\n```\n\n### Litteraux booleens\n\n```hemlock\nlet t = true;\nlet f = false;\n```\n\n### Litteral null\n\n```hemlock\nlet nothing = null;\n```\n\n## Regles de portee\n\n### Portee de bloc\n\nLes variables sont limitees au bloc englobant le plus proche :\n\n```hemlock\nlet x = 1;  // Portee externe\n\nif (true) {\n    let x = 2;  // Portee interne (masque l'externe)\n    print(x);   // 2\n}\n\nprint(x);  // 1\n```\n\n### Portee de fonction\n\nLes fonctions creent leur propre portee :\n\n```hemlock\nlet global = \"global\";\n\nfn foo() {\n    let local = \"local\";\n    print(global);  // Peut lire la portee externe\n}\n\nfoo();\n// print(local);  // ERREUR : 'local' non defini ici\n```\n\n### Portee de fermeture (Closure)\n\nLes fermetures capturent les variables de la portee englobante :\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Capture 'count'\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\n```\n\n## Espaces et formatage\n\n### Indentation\n\nHemlock n'impose pas d'indentation specifique, mais 4 espaces sont recommandes :\n\n```hemlock\nfn example() {\n    if (true) {\n        print(\"indente\");\n    }\n}\n```\n\n### Sauts de ligne\n\nLes instructions peuvent s'etendre sur plusieurs lignes :\n\n```hemlock\nlet result =\n    very_long_function_name(\n        arg1,\n        arg2,\n        arg3\n    );\n```\n\n## Instruction Loop\n\nLe mot-cle `loop` fournit une syntaxe plus claire pour les boucles infinies :\n\n```hemlock\nloop {\n    // ... faire le travail\n    if (done) {\n        break;\n    }\n}\n```\n\nCeci est equivalent a `while (true)` mais rend l'intention plus claire.\n\n## Mots-cles reserves\n\nLes mots-cles suivants sont reserves dans Hemlock :\n\n```\nlet, const, fn, if, else, while, for, in, loop, break, continue,\nreturn, true, false, null, typeof, import, export, from,\ntry, catch, finally, throw, panic, async, await, spawn, join,\ndetach, channel, define, switch, case, default, extern, self,\ntype, defer, enum, ref, buffer, Self\n```\n\n## Prochaines etapes\n\n- [Systeme de types](#language-guide-types) - Decouvrez le systeme de types de Hemlock\n- [Flux de controle](#language-guide-control-flow) - Approfondissez les structures de controle\n- [Fonctions](#language-guide-functions) - Maitrisez les fonctions et les fermetures\n- [Gestion de la memoire](#language-guide-memory) - Comprenez les pointeurs et les tampons\n"}, "Guide du Langage -> Tableaux": {"id": "language-guide-arrays", "content": "# Tableaux\n\nHemlock fournit des **tableaux dynamiques** avec des methodes completes pour la manipulation et le traitement des donnees. Les tableaux peuvent contenir des types mixtes et s'agrandissent automatiquement selon les besoins.\n\n## Apercu\n\n```hemlock\n// Litteraux de tableau\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Types mixtes autorises\nlet mixed = [1, \"bonjour\", true, null];\n\n// Dimensionnement dynamique\narr.push(6);           // S'agrandit automatiquement\narr.push(7);\nprint(arr.length);     // 7\n```\n\n## Litteraux de tableau\n\n### Syntaxe basique\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet strings = [\"pomme\", \"banane\", \"cerise\"];\nlet booleans = [true, false, true];\n```\n\n### Tableaux vides\n\n```hemlock\nlet arr = [];  // Tableau vide\n\n// Ajouter des elements plus tard\narr.push(1);\narr.push(2);\narr.push(3);\n```\n\n### Types mixtes\n\nLes tableaux peuvent contenir differents types :\n\n```hemlock\nlet mixed = [\n    42,\n    \"bonjour\",\n    true,\n    null,\n    [1, 2, 3],\n    { x: 10, y: 20 }\n];\n\nprint(mixed[0]);  // 42\nprint(mixed[1]);  // \"bonjour\"\nprint(mixed[4]);  // [1, 2, 3] (tableau imbrique)\n```\n\n### Tableaux imbriques\n\n```hemlock\nlet matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\nprint(matrix[0][0]);  // 1\nprint(matrix[1][2]);  // 6\nprint(matrix[2][1]);  // 8\n```\n\n### Tableaux types\n\nLes tableaux peuvent avoir des annotations de type pour appliquer les types d'elements :\n\n```hemlock\n// Syntaxe de tableau type\nlet nums: array<i32> = [1, 2, 3, 4, 5];\nlet names: array<string> = [\"Alice\", \"Bob\", \"Carol\"];\nlet flags: array<bool> = [true, false, true];\n\n// Verification de type a l'execution\nlet valid: array<i32> = [1, 2, 3];       // OK\nlet invalid: array<i32> = [1, \"deux\", 3]; // Erreur d'execution : type mismatch\n\n// Tableaux types imbriques\nlet matrix: array<array<i32>> = [\n    [1, 2, 3],\n    [4, 5, 6]\n];\n```\n\n**Comportement des annotations de type :**\n- Les elements sont verifies quand ils sont ajoutes au tableau\n- Les incompatibilites de type causent des erreurs a l'execution\n- Sans annotation de type, les tableaux acceptent des types mixtes\n\n## Indexation\n\n### Lecture d'elements\n\nAcces indexe a partir de zero :\n\n```hemlock\nlet arr = [10, 20, 30, 40, 50];\n\nprint(arr[0]);  // 10 (premier element)\nprint(arr[4]);  // 50 (dernier element)\n\n// Hors limites retourne null (pas d'erreur)\nprint(arr[10]);  // null\n```\n\n### Ecriture d'elements\n\n```hemlock\nlet arr = [1, 2, 3];\n\narr[0] = 10;    // Modifier existant\narr[1] = 20;\nprint(arr);     // [10, 20, 3]\n\n// Peut assigner au-dela de la longueur actuelle (agrandit le tableau)\narr[5] = 60;    // Cree [10, 20, 3, null, null, 60]\n```\n\n### Indices negatifs\n\n**Non supportes** - Utilisez uniquement des indices positifs :\n\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr[-1]);  // ERREUR ou comportement indefini\n\n// Utilisez length pour le dernier element\nprint(arr[arr.length - 1]);  // 3\n```\n\n## Proprietes\n\n### Propriete `.length`\n\nRetourne le nombre d'elements :\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);  // 5\n\n// Tableau vide\nlet empty = [];\nprint(empty.length);  // 0\n\n// Apres modifications\narr.push(6);\nprint(arr.length);  // 6\n```\n\n## Methodes de tableau\n\nHemlock fournit 18 methodes de tableau pour une manipulation complete.\n\n### Operations de pile\n\n**`push(value)`** - Ajouter un element a la fin :\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\n\nprint(arr.length);     // 5\n```\n\n**`pop()`** - Supprimer et retourner le dernier element :\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet last = arr.pop();  // Retourne 5, arr est maintenant [1, 2, 3, 4]\n\nprint(last);           // 5\nprint(arr.length);     // 4\n```\n\n### Operations de file\n\n**`shift()`** - Supprimer et retourner le premier element :\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();   // Retourne 1, arr est maintenant [2, 3]\n\nprint(first);              // 1\nprint(arr);                // [2, 3]\n```\n\n**`unshift(value)`** - Ajouter un element au debut :\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);            // [1, 2, 3]\narr.unshift(0);            // [0, 1, 2, 3]\n```\n\n### Insertion et suppression\n\n**`insert(index, value)`** - Inserer un element a l'index :\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // Inserer 3 a l'index 2 : [1, 2, 3, 4, 5]\n\narr.insert(0, 0);      // Inserer au debut : [0, 1, 2, 3, 4, 5]\n```\n\n**`remove(index)`** - Supprimer et retourner l'element a l'index :\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(2);  // Retourne 3, arr est maintenant [1, 2, 4, 5]\n\nprint(removed);               // 3\nprint(arr);                   // [1, 2, 4, 5]\n```\n\n### Operations de recherche\n\n**`find(value)`** - Trouver la premiere occurrence :\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2 (index de la premiere occurrence)\nlet idx2 = arr.find(99);     // -1 (non trouve)\n\n// Fonctionne avec n'importe quel type\nlet words = [\"pomme\", \"banane\", \"cerise\"];\nlet idx3 = words.find(\"banane\");  // 1\n```\n\n**`contains(value)`** - Verifier si le tableau contient une valeur :\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n```\n\n### Operations d'extraction\n\n**`slice(start, end)`** - Extraire un sous-tableau (fin exclusive) :\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4] (indices 1, 2, 3)\nlet first = arr.slice(0, 2); // [1, 2]\n\n// Original inchange\nprint(arr);                  // [1, 2, 3, 4, 5]\n```\n\n**`first()`** - Obtenir le premier element (sans le supprimer) :\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1 (sans le supprimer)\nprint(arr);                  // [1, 2, 3] (inchange)\n```\n\n**`last()`** - Obtenir le dernier element (sans le supprimer) :\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3 (sans le supprimer)\nprint(arr);                  // [1, 2, 3] (inchange)\n```\n\n### Operations de transformation\n\n**`reverse()`** - Inverser le tableau sur place :\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\n\nprint(arr);                  // [5, 4, 3, 2, 1] (modifie)\n```\n\n**`join(delimiter)`** - Joindre les elements en chaine :\n```hemlock\nlet words = [\"bonjour\", \"monde\", \"foo\"];\nlet joined = words.join(\" \");  // \"bonjour monde foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Fonctionne avec les types mixtes\nlet mixed = [1, \"bonjour\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | bonjour | true | null\"\n```\n\n**`concat(other)`** - Concatener avec un autre tableau :\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (nouveau tableau)\n\n// Originaux inchanges\nprint(a);                    // [1, 2, 3]\nprint(b);                    // [4, 5, 6]\n```\n\n### Operations utilitaires\n\n**`clear()`** - Supprimer tous les elements :\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();                 // []\n\nprint(arr.length);           // 0\nprint(arr);                  // []\n```\n\n## Chainage de methodes\n\nLes methodes qui retournent des tableaux ou des valeurs permettent le chainage :\n\n```hemlock\nlet result = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);  // [3, 4, 5]\n\nlet text = [\"pomme\", \"banane\", \"cerise\"]\n    .slice(0, 2)\n    .join(\" et \");  // \"pomme et banane\"\n\nlet numbers = [5, 3, 8, 1, 9]\n    .slice(1, 4)\n    .concat([10, 11]);  // [3, 8, 1, 10, 11]\n```\n\n## Reference complete des methodes\n\n| Methode | Parametres | Retourne | Modifie | Description |\n|---------|------------|----------|---------|-------------|\n| `push(value)` | any | void | Oui | Ajouter un element a la fin |\n| `pop()` | - | any | Oui | Supprimer et retourner le dernier |\n| `shift()` | - | any | Oui | Supprimer et retourner le premier |\n| `unshift(value)` | any | void | Oui | Ajouter un element au debut |\n| `insert(index, value)` | i32, any | void | Oui | Inserer a l'index |\n| `remove(index)` | i32 | any | Oui | Supprimer et retourner a l'index |\n| `find(value)` | any | i32 | Non | Trouver la premiere occurrence (-1 si non trouve) |\n| `contains(value)` | any | bool | Non | Verifier si contient la valeur |\n| `slice(start, end)` | i32, i32 | array | Non | Extraire un sous-tableau (nouveau tableau) |\n| `join(delimiter)` | string | string | Non | Joindre en chaine |\n| `concat(other)` | array | array | Non | Concatener (nouveau tableau) |\n| `reverse()` | - | void | Oui | Inverser sur place |\n| `first()` | - | any | Non | Obtenir le premier element |\n| `last()` | - | any | Non | Obtenir le dernier element |\n| `clear()` | - | void | Oui | Supprimer tous les elements |\n| `map(callback)` | fn | array | Non | Transformer chaque element |\n| `filter(predicate)` | fn | array | Non | Selectionner les elements correspondants |\n| `reduce(callback, initial)` | fn, any | any | Non | Reduire a une seule valeur |\n\n## Details d'implementation\n\n### Modele memoire\n\n- **Alloue sur le tas** - Capacite dynamique\n- **Croissance automatique** - Double la capacite quand depassee\n- **Pas de reduction automatique** - La capacite ne diminue pas\n- **Pas de verification des limites sur l'indexation** - Utilisez les methodes pour la securite\n\n### Gestion de la capacite\n\n```hemlock\nlet arr = [];  // Capacite initiale : 0\n\narr.push(1);   // Croit vers capacite 1\narr.push(2);   // Croit vers capacite 2\narr.push(3);   // Croit vers capacite 4 (double)\narr.push(4);   // Toujours capacite 4\narr.push(5);   // Croit vers capacite 8 (double)\n```\n\n### Comparaison de valeurs\n\n`find()` et `contains()` utilisent l'egalite de valeur :\n\n```hemlock\n// Primitives : comparaison par valeur\nlet arr = [1, 2, 3];\narr.contains(2);  // true\n\n// Chaines : comparaison par valeur\nlet words = [\"bonjour\", \"monde\"];\nwords.contains(\"bonjour\");  // true\n\n// Objets : comparaison par reference\nlet obj1 = { x: 10 };\nlet obj2 = { x: 10 };\nlet arr2 = [obj1];\narr2.contains(obj1);  // true (meme reference)\narr2.contains(obj2);  // false (reference differente)\n```\n\n## Modeles courants\n\n### Operations fonctionnelles (map/filter/reduce)\n\nLes tableaux ont des methodes integrees `map`, `filter` et `reduce` :\n\n```hemlock\n// map - transformer chaque element\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = numbers.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\n// filter - selectionner les elements correspondants\nlet evens = numbers.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4]\n\n// reduce - accumuler vers une seule valeur\nlet sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\n// Chainage des operations fonctionnelles\nlet result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]\n    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]\n    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220\n```\n\n### Modele : Tableau comme pile\n\n```hemlock\nlet stack = [];\n\n// Empiler sur la pile\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Depiler de la pile\nlet top = stack.pop();    // 3\nlet next = stack.pop();   // 2\n```\n\n### Modele : Tableau comme file\n\n```hemlock\nlet queue = [];\n\n// Enfiler (ajouter a la fin)\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Defiler (supprimer du debut)\nlet first = queue.shift();   // 1\nlet second = queue.shift();  // 2\n```\n\n## Bonnes pratiques\n\n1. **Utilisez les methodes plutot que l'indexation directe** - Verification des limites et clarte\n2. **Verifiez les limites** - L'indexation directe ne verifie pas les limites\n3. **Preferez les operations immuables** - Utilisez `slice()` et `concat()` plutot que la mutation\n4. **Initialisez avec la capacite** - Si vous connaissez la taille (pas actuellement supporte)\n5. **Utilisez `contains()` pour l'appartenance** - Plus clair que les boucles manuelles\n6. **Chainez les methodes** - Plus lisible que les appels imbriques\n\n## Pieges courants\n\n### Piege : Index direct hors limites\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// Pas de verification des limites !\narr[10] = 99;  // Cree un tableau sparse avec des nulls\nprint(arr.length);  // 11 (pas 3 !)\n\n// Mieux : Utilisez push() ou verifiez la longueur\nif (arr.length <= 10) {\n    arr.push(99);\n}\n```\n\n### Piege : Mutation vs. nouveau tableau\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// Modifie l'original\narr.reverse();\nprint(arr);  // [3, 2, 1]\n\n// Retourne un nouveau tableau\nlet sub = arr.slice(0, 2);\nprint(arr);  // [3, 2, 1] (inchange)\nprint(sub);  // [3, 2]\n```\n\n### Piege : Egalite de reference\n\n```hemlock\nlet obj = { x: 10 };\nlet arr = [obj];\n\n// Meme reference : true\narr.contains(obj);  // true\n\n// Reference differente : false\narr.contains({ x: 10 });  // false (objet different)\n```\n\n### Piege : Tableaux longue duree\n\n```hemlock\n// Les tableaux en portee locale sont auto-liberes, mais les tableaux globaux/longue duree necessitent attention\nlet global_cache = [];  // Niveau module, persiste jusqu'a la fin du programme\n\nfn add_to_cache(item) {\n    global_cache.push(item);  // Croit indefiniment\n}\n\n// Pour les donnees longue duree, considerez :\n// - Vider le tableau periodiquement : global_cache.clear();\n// - Liberer tot quand termine : free(global_cache);\n```\n\n## Exemples\n\n### Exemple : Statistiques de tableau\n\n```hemlock\nfn mean(arr) {\n    let sum = 0;\n    let i = 0;\n    while (i < arr.length) {\n        sum = sum + arr[i];\n        i = i + 1;\n    }\n    return sum / arr.length;\n}\n\nfn max(arr) {\n    if (arr.length == 0) {\n        return null;\n    }\n\n    let max_val = arr[0];\n    let i = 1;\n    while (i < arr.length) {\n        if (arr[i] > max_val) {\n            max_val = arr[i];\n        }\n        i = i + 1;\n    }\n    return max_val;\n}\n\nlet numbers = [3, 7, 2, 9, 1];\nprint(mean(numbers));  // 4.4\nprint(max(numbers));   // 9\n```\n\n### Exemple : Deduplication de tableau\n\n```hemlock\nfn unique(arr) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (!result.contains(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet numbers = [1, 2, 2, 3, 1, 4, 3, 5];\nlet uniq = unique(numbers);  // [1, 2, 3, 4, 5]\n```\n\n### Exemple : Decoupage de tableau\n\n```hemlock\nfn chunk(arr, size) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        let chunk = arr.slice(i, i + size);\n        result.push(chunk);\n        i = i + size;\n    }\n\n    return result;\n}\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8];\nlet chunks = chunk(numbers, 3);\n// [[1, 2, 3], [4, 5, 6], [7, 8]]\n```\n\n### Exemple : Aplatissement de tableau\n\n```hemlock\nfn flatten(arr) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        if (typeof(arr[i]) == \"array\") {\n            // Tableau imbrique - l'aplatir\n            let nested = flatten(arr[i]);\n            let j = 0;\n            while (j < nested.length) {\n                result.push(nested[j]);\n                j = j + 1;\n            }\n        } else {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet nested = [1, [2, 3], [4, [5, 6]], 7];\nlet flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]\n```\n\n### Exemple : Tri (tri a bulles)\n\n```hemlock\nfn sort(arr) {\n    let n = arr.length;\n    let i = 0;\n\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (arr[j] > arr[j + 1]) {\n                // Echanger\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers);  // Modifie sur place\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## Limitations\n\nLimitations actuelles :\n\n- **Pas de verification des limites sur l'indexation** - L'acces direct n'est pas verifie\n- **Egalite de reference pour les objets** - `find()` et `contains()` utilisent la comparaison de reference\n- **Pas de destructuration de tableau** - Pas de syntaxe `let [a, b] = arr`\n- **Pas d'operateur spread** - Pas de syntaxe `[...arr1, ...arr2]`\n\n**Note :** Les tableaux sont comptes par reference et automatiquement liberes quand la portee se termine. Voir [Gestion de la memoire](memory.md#internal-reference-counting) pour les details.\n\n## Sujets connexes\n\n- [Chaines](#language-guide-strings) - Methodes de chaine similaires aux methodes de tableau\n- [Objets](#language-guide-objects) - Les tableaux sont aussi similaires a des objets\n- [Fonctions](#language-guide-functions) - Fonctions d'ordre superieur avec les tableaux\n- [Flux de controle](#language-guide-control-flow) - Iterer sur les tableaux\n\n## Voir aussi\n\n- **Dimensionnement dynamique** : Les tableaux croissent automatiquement avec doublement de la capacite\n- **Methodes** : 18 methodes completes pour la manipulation incluant map/filter/reduce\n- **Memoire** : Voir [Memoire](#language-guide-memory) pour les details d'allocation de tableau\n"}, "Guide du Langage -> Types": {"id": "language-guide-types", "content": "# Systeme de types\n\nHemlock dispose d'un **systeme de types dynamique** avec des annotations de type optionnelles et une verification de type a l'execution.\n\n---\n\n## Guide de selection des types : Quel type dois-je utiliser ?\n\n**Nouveau avec les types ?** Commencez ici. Si vous etes familier avec les systemes de types, passez directement a [Philosophie](#philosophie).\n\n### La reponse courte\n\n**Laissez simplement Hemlock determiner le type :**\n\n```hemlock\nlet count = 42;        // Hemlock sait que c'est un entier\nlet price = 19.99;     // Hemlock sait que c'est un decimal\nlet name = \"Alice\";    // Hemlock sait que c'est du texte\nlet active = true;     // Hemlock sait que c'est oui/non\n```\n\nHemlock choisit automatiquement le bon type pour vos valeurs. Vous n'avez pas *besoin* de specifier les types.\n\n### Quand ajouter des annotations de type\n\nAjoutez des types quand vous voulez :\n\n1. **Etre specifique sur la taille** - `i8` vs `i64` est important pour la memoire ou FFI\n2. **Documenter votre code** - Les types montrent ce qu'une fonction attend\n3. **Detecter les erreurs tot** - Hemlock verifie les types a l'execution\n\n```hemlock\n// Sans types (fonctionne bien) :\nfn add(a, b) {\n    return a + b;\n}\n\n// Avec types (plus explicite) :\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Reference rapide : Choisir les types numeriques\n\n| Ce que vous stockez | Type suggere | Exemple |\n|---------------------|--------------|---------|\n| Nombres entiers reguliers | `i32` (par defaut) | `let count = 42;` |\n| Tres grands nombres | `i64` | `let population = 8000000000;` |\n| Comptages jamais negatifs | `u32` | `let items: u32 = 100;` |\n| Octets (0-255) | `u8` | `let pixel: u8 = 255;` |\n| Decimaux/fractions | `f64` (par defaut) | `let price = 19.99;` |\n| Decimaux critiques pour la performance | `f32` | `let x: f32 = 1.5;` |\n\n### Reference rapide : Tous les types\n\n| Categorie | Types | Quand utiliser |\n|-----------|-------|----------------|\n| **Nombres entiers** | `i8`, `i16`, `i32`, `i64` | Comptage, identifiants, ages, etc. |\n| **Nombres positifs uniquement** | `u8`, `u16`, `u32`, `u64` | Octets, tailles, longueurs de tableau |\n| **Decimaux** | `f32`, `f64` | Argent, mesures, mathematiques |\n| **Oui/Non** | `bool` | Drapeaux, conditions |\n| **Texte** | `string` | Noms, messages, tout texte |\n| **Caractere unique** | `rune` | Lettres individuelles, emoji |\n| **Listes** | `array` | Collections de valeurs |\n| **Champs nommes** | `object` | Groupement de donnees liees |\n| **Memoire brute** | `ptr`, `buffer` | Programmation bas niveau |\n| **Rien** | `null` | Absence de valeur |\n\n### Scenarios courants\n\n**\"J'ai juste besoin d'un nombre\"**\n```hemlock\nlet x = 42;  // Fait ! Hemlock choisit i32\n```\n\n**\"J'ai besoin de decimaux\"**\n```hemlock\nlet price = 19.99;  // Fait ! Hemlock choisit f64\n```\n\n**\"Je travaille avec des octets (fichiers, reseau)\"**\n```hemlock\nlet byte: u8 = 255;  // Plage 0-255\n```\n\n**\"J'ai besoin de tres grands nombres\"**\n```hemlock\nlet big = 9000000000000;  // Hemlock choisit automatiquement i64 (> i32 max)\n// Ou soyez explicite :\nlet big: i64 = 9000000000000;\n```\n\n**\"Je stocke de l'argent\"**\n```hemlock\n// Option 1 : Float (simple, mais a des limites de precision)\nlet price: f64 = 19.99;\n\n// Option 2 : Stocker en centimes (plus precis)\nlet price_cents: i32 = 1999;  // 19.99 EUR en centimes entiers\n```\n\n**\"Je passe des donnees au code C (FFI)\"**\n```hemlock\n// Correspondre exactement aux types C\nlet c_int: i32 = 100;      // C 'int'\nlet c_long: i64 = 100;     // C 'long' (sur 64-bit)\nlet c_char: u8 = 65;       // C 'char'\nlet c_double: f64 = 3.14;  // C 'double'\n```\n\n### Que se passe-t-il quand les types se melangent ?\n\nQuand vous combinez differents types, Hemlock promeut vers le type \"plus grand\" :\n\n```hemlock\nlet a: i32 = 10;\nlet b: f64 = 2.5;\nlet result = a + b;  // result est f64 (12.5)\n// L'entier est devenu un decimal automatiquement\n```\n\n**Regle generale :** Les flottants \"gagnent\" toujours - melanger un entier avec un flottant donne un flottant.\n\n### Erreurs de type\n\nSi vous essayez d'utiliser le mauvais type, Hemlock vous le dit a l'execution :\n\n```hemlock\nlet age: i32 = \"trente\";  // ERREUR : type mismatch - expected i32, got string\n```\n\nPour convertir les types, utilisez les fonctions constructeur de type :\n\n```hemlock\nlet text = \"42\";\nlet number = i32(text);   // Analyser la chaine vers un entier : 42\nlet back = text + \"\";     // Deja une chaine\n```\n\n---\n\n## Philosophie\n\n- **Dynamique par defaut** - Chaque valeur a une etiquette de type a l'execution\n- **Type par choix** - Les annotations de type optionnelles appliquent des verifications a l'execution\n- **Conversions explicites** - Les conversions implicites suivent des regles de promotion claires\n- **Honnete sur les types** - `typeof()` dit toujours la verite\n\n## Types primitifs\n\n### Types entiers\n\n**Entiers signes :**\n```hemlock\nlet tiny: i8 = 127;              // 8-bit  (-128 a 127)\nlet small: i16 = 32767;          // 16-bit (-32768 a 32767)\nlet normal: i32 = 2147483647;    // 32-bit (par defaut)\nlet large: i64 = 9223372036854775807;  // 64-bit\n```\n\n**Entiers non signes :**\n```hemlock\nlet byte: u8 = 255;              // 8-bit  (0 a 255)\nlet word: u16 = 65535;           // 16-bit (0 a 65535)\nlet dword: u32 = 4294967295;     // 32-bit (0 a 4294967295)\nlet qword: u64 = 18446744073709551615;  // 64-bit\n```\n\n**Alias de type :**\n```hemlock\nlet i: integer = 42;   // Alias pour i32\nlet b: byte = 255;     // Alias pour u8\n```\n\n### Types a virgule flottante\n\n```hemlock\nlet f: f32 = 3.14159;        // Flottant 32-bit\nlet d: f64 = 2.718281828;    // Flottant 64-bit (par defaut)\nlet n: number = 1.618;       // Alias pour f64\n```\n\n### Type booleen\n\n```hemlock\nlet flag: bool = true;\nlet active: bool = false;\n```\n\n### Type chaine\n\n```hemlock\nlet text: string = \"Bonjour, le monde !\";\nlet empty: string = \"\";\n```\n\nLes chaines sont **mutables**, **encodees en UTF-8**, et **allouees sur le tas**.\n\nVoir [Chaines](#language-guide-strings) pour les details complets.\n\n### Type rune\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = 'rocket';\nlet newline: rune = '\\n';\nlet unicode: rune = '\\u{1F680}';\n```\n\nLes runes representent des **points de code Unicode** (U+0000 a U+10FFFF).\n\nVoir [Runes](#language-guide-runes) pour les details complets.\n\n### Type null\n\n```hemlock\nlet nothing = null;\nlet uninitialized: string = null;\n```\n\n`null` est son propre type avec une seule valeur.\n\n## Types composes\n\n### Type tableau\n\n```hemlock\nlet numbers: array = [1, 2, 3, 4, 5];\nlet mixed = [1, \"deux\", true, null];  // Types mixtes autorises\nlet empty: array = [];\n```\n\nVoir [Tableaux](#language-guide-arrays) pour les details complets.\n\n### Type objet\n\n```hemlock\nlet obj: object = { x: 10, y: 20 };\nlet person = { name: \"Alice\", age: 30 };\n```\n\nVoir [Objets](#language-guide-objects) pour les details complets.\n\n### Types pointeur\n\n**Pointeur brut :**\n```hemlock\nlet p: ptr = alloc(64);\n// Pas de verification des limites, gestion manuelle de la duree de vie\nfree(p);\n```\n\n**Tampon securise :**\n```hemlock\nlet buf: buffer = buffer(64);\n// Verification des limites, suit la longueur et la capacite\nfree(buf);\n```\n\nVoir [Gestion de la memoire](#language-guide-memory) pour les details complets.\n\n## Types enum\n\nLes enums definissent un ensemble de constantes nommees :\n\n### Enums basiques\n\n```hemlock\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nlet c = Color.RED;\nprint(c);              // 0\nprint(typeof(c));      // \"Color\"\n\n// Comparaison\nif (c == Color.RED) {\n    print(\"C'est rouge !\");\n}\n\n// Switch sur enum\nswitch (c) {\n    case Color.RED:\n        print(\"Stop\");\n        break;\n    case Color.GREEN:\n        print(\"Allez\");\n        break;\n    case Color.BLUE:\n        print(\"Bleu ?\");\n        break;\n}\n```\n\n### Enums avec valeurs\n\nLes enums peuvent avoir des valeurs entieres explicites :\n\n```hemlock\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 2\n}\n\nprint(Status.OK);      // 0\nprint(Status.ERROR);   // 1\n\nenum HttpCode {\n    OK = 200,\n    NOT_FOUND = 404,\n    SERVER_ERROR = 500\n}\n\nlet code = HttpCode.NOT_FOUND;\nprint(code);           // 404\n```\n\n### Valeurs auto-incrementees\n\nSans valeurs explicites, les enums s'auto-incrementent a partir de 0 :\n\n```hemlock\nenum Priority {\n    LOW,       // 0\n    MEDIUM,    // 1\n    HIGH,      // 2\n    CRITICAL   // 3\n}\n\n// Peut melanger valeurs explicites et auto\nenum Level {\n    DEBUG = 10,\n    INFO,      // 11\n    WARN,      // 12\n    ERROR = 50,\n    FATAL      // 51\n}\n```\n\n### Modeles d'utilisation des enums\n\n```hemlock\n// Comme parametres de fonction\nfn set_priority(p: Priority) {\n    if (p == Priority.CRITICAL) {\n        print(\"Urgent !\");\n    }\n}\n\nset_priority(Priority.HIGH);\n\n// Dans les objets\ndefine Task {\n    name: string,\n    priority: Priority\n}\n\nlet task: Task = {\n    name: \"Corriger le bug\",\n    priority: Priority.HIGH\n};\n```\n\n## Types speciaux\n\n### Type fichier\n\n```hemlock\nlet f: file = open(\"data.txt\", \"r\");\nf.close();\n```\n\nRepresente un descripteur de fichier ouvert.\n\n### Type tache\n\n```hemlock\nasync fn compute(): i32 { return 42; }\nlet task = spawn(compute);\nlet result: i32 = join(task);\n```\n\nRepresente un descripteur de tache asynchrone.\n\n### Type canal\n\n```hemlock\nlet ch: channel = channel(10);\nch.send(42);\nlet value = ch.recv();\n```\n\nRepresente un canal de communication entre taches.\n\n### Type void\n\n```hemlock\nextern fn exit(code: i32): void;\n```\n\nUtilise pour les fonctions qui ne retournent pas de valeur (FFI seulement).\n\n## Inference de type\n\n### Inference de litteraux entiers\n\nHemlock infere les types entiers en fonction de la plage de valeurs :\n\n```hemlock\nlet a = 42;              // i32 (tient dans 32-bit)\nlet b = 5000000000;      // i64 (> i32 max)\nlet c = 128;             // i32\nlet d: u8 = 128;         // u8 (annotation explicite)\n```\n\n**Regles :**\n- Valeurs dans la plage i32 (-2147483648 a 2147483647) : infere comme `i32`\n- Valeurs hors plage i32 mais dans i64 : infere comme `i64`\n- Utilisez des annotations explicites pour les autres types (i8, i16, u8, u16, u32, u64)\n\n### Inference de litteraux flottants\n\n```hemlock\nlet x = 3.14;        // f64 (par defaut)\nlet y: f32 = 3.14;   // f32 (explicite)\n```\n\n### Notation scientifique\n\nHemlock supporte la notation scientifique pour les litteraux numeriques :\n\n```hemlock\nlet a = 1e10;        // 10000000000.0 (f64)\nlet b = 1e-12;       // 0.000000000001 (f64)\nlet c = 3.14e2;      // 314.0 (f64)\nlet d = 2.5e-3;      // 0.0025 (f64)\nlet e = 1E10;        // Insensible a la casse\nlet f = 1e+5;        // Exposant positif explicite\n```\n\n**Note :** Tout litteral utilisant la notation scientifique est toujours infere comme `f64`.\n\n### Autre inference de type\n\n```hemlock\nlet s = \"bonjour\";   // string\nlet ch = 'A';        // rune\nlet flag = true;     // bool\nlet arr = [1, 2, 3]; // array\nlet obj = { x: 10 }; // object\nlet nothing = null;  // null\n```\n\n## Annotations de type\n\n### Annotations de variable\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet name: string = \"Alice\";\n```\n\n### Annotations de parametre de fonction\n\n```hemlock\nfn greet(name: string, age: i32) {\n    print(\"Bonjour, \" + name + \" !\");\n}\n```\n\n### Annotations de type de retour de fonction\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Annotations de type objet (typage canard)\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\n```\n\n## Verification de type\n\n### Verification de type a l'execution\n\nLes annotations de type sont verifiees a **l'execution**, pas a la compilation :\n\n```hemlock\nlet x: i32 = 42;     // OK\nlet y: i32 = 3.14;   // Erreur d'execution : type mismatch\n\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 3);           // OK\nadd(5, \"bonjour\");   // Erreur d'execution : type mismatch\n```\n\n### Requetes de type\n\nUtilisez `typeof()` pour verifier les types de valeur :\n\n```hemlock\nprint(typeof(42));         // \"i32\"\nprint(typeof(3.14));       // \"f64\"\nprint(typeof(\"bonjour\"));  // \"string\"\nprint(typeof(true));       // \"bool\"\nprint(typeof(null));       // \"null\"\nprint(typeof([1, 2, 3]));  // \"array\"\nprint(typeof({ x: 10 }));  // \"object\"\n```\n\n## Conversions de type\n\n### Promotion de type implicite\n\nLors du melange de types dans les operations, Hemlock promeut vers le type \"superieur\" :\n\n**Hierarchie de promotion (du plus bas au plus haut) :**\n```\ni8 -> i16 -> i32 -> u32 -> i64 -> u64 -> f32 -> f64\n      ^      ^      ^\n     u8     u16\n```\n\n**Le flottant gagne toujours :**\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result est f64 (13.5)\n```\n\n**La plus grande taille gagne :**\n```hemlock\nlet a: i32 = 100;\nlet b: i64 = 200;\nlet sum = a + b;     // sum est i64 (300)\n```\n\n**Preservation de la precision :** Lors du melange d'entiers 64-bit avec f32, Hemlock promeut\nvers f64 pour eviter la perte de precision (f32 n'a que 24-bit de mantisse, insuffisant pour i64/u64) :\n```hemlock\nlet big: i64 = 9007199254740993;\nlet small: f32 = 1.0;\nlet result = big + small;  // result est f64, pas f32 !\n```\n\n**Exemples :**\n```hemlock\nu8 + i32  -> i32\ni32 + i64 -> i64\nu32 + u64 -> u64\ni32 + f32 -> f32    // f32 suffisant pour i32\ni64 + f32 -> f64    // f64 necessaire pour preserver la precision i64\ni64 + f64 -> f64\ni8 + f64  -> f64\n```\n\n### Conversion de type explicite\n\n**Entier <-> Flottant :**\n```hemlock\nlet i: i32 = 42;\nlet f: f64 = i;      // i32 -> f64 (42.0)\n\nlet x: f64 = 3.14;\nlet n: i32 = x;      // f64 -> i32 (3, tronque)\n```\n\n**Entier <-> Rune :**\n```hemlock\nlet code: i32 = 65;\nlet ch: rune = code;  // i32 -> rune ('A')\n\nlet r: rune = 'Z';\nlet value: i32 = r;   // rune -> i32 (90)\n```\n\n**Rune -> Chaine :**\n```hemlock\nlet ch: rune = 'rocket';\nlet s: string = ch;   // rune -> string (\"rocket\")\n```\n\n**u8 -> Rune :**\n```hemlock\nlet b: u8 = 65;\nlet r: rune = b;      // u8 -> rune ('A')\n```\n\n### Fonctions constructeur de type\n\nLes noms de type peuvent etre utilises comme fonctions pour convertir ou analyser des valeurs :\n\n**Analyser des chaines vers des nombres :**\n```hemlock\nlet n = i32(\"42\");       // Analyser chaine vers i32 : 42\nlet f = f64(\"3.14159\");  // Analyser chaine vers f64 : 3.14159\nlet b = bool(\"true\");    // Analyser chaine vers bool : true\n\n// Tous les types numeriques supportes\nlet a = i8(\"-128\");      // Analyser vers i8\nlet c = u8(\"255\");       // Analyser vers u8\nlet d = i16(\"1000\");     // Analyser vers i16\nlet e = u16(\"50000\");    // Analyser vers u16\nlet g = i64(\"9000000000000\"); // Analyser vers i64\nlet h = u64(\"18000000000000\"); // Analyser vers u64\nlet j = f32(\"1.5\");      // Analyser vers f32\n```\n\n**Nombres hexadecimaux et negatifs :**\n```hemlock\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\nlet bin = i32(\"0b1010\"); // 10 (binaire)\n```\n\n**Les alias de type fonctionnent aussi :**\n```hemlock\nlet x = integer(\"100\");  // Identique a i32(\"100\")\nlet y = number(\"1.5\");   // Identique a f64(\"1.5\")\nlet z = byte(\"200\");     // Identique a u8(\"200\")\n```\n\n**Convertir entre types numeriques :**\n```hemlock\nlet big = i64(42);           // i32 vers i64\nlet truncated = i32(3.99);   // f64 vers i32 (tronque a 3)\nlet promoted = f64(100);     // i32 vers f64 (100.0)\nlet narrowed = i8(127);      // i32 vers i8\n```\n\n**Les annotations de type effectuent la coercition numerique (mais PAS l'analyse de chaine) :**\n```hemlock\nlet f: f64 = 100;        // i32 vers f64 via annotation (OK)\nlet s: string = 'A';     // Rune vers string via annotation (OK)\nlet code: i32 = 'A';     // Rune vers i32 via annotation (obtient le point de code, OK)\n\n// L'analyse de chaine necessite des constructeurs de type explicites :\nlet n = i32(\"42\");       // Utiliser le constructeur de type pour l'analyse de chaine\n// let x: i32 = \"42\";    // ERREUR - les annotations de type n'analysent pas les chaines\n```\n\n**Gestion des erreurs :**\n```hemlock\n// Les chaines invalides levent des erreurs lors de l'utilisation de constructeurs de type\nlet bad = i32(\"bonjour\");  // Erreur d'execution : cannot parse \"bonjour\" as i32\nlet overflow = u8(\"256\");  // Erreur d'execution : 256 out of range for u8\n```\n\n**Analyse de booleen :**\n```hemlock\nlet t = bool(\"true\");    // true\nlet f = bool(\"false\");   // false\nlet bad = bool(\"oui\");   // Erreur d'execution : must be \"true\" or \"false\"\n```\n\n## Verification de plage\n\nLes annotations de type appliquent des verifications de plage a l'assignation :\n\n```hemlock\nlet x: u8 = 255;    // OK\nlet y: u8 = 256;    // ERREUR : out of range for u8\n\nlet a: i8 = 127;    // OK\nlet b: i8 = 128;    // ERREUR : out of range for i8\n\nlet c: i64 = 2147483647;   // OK\nlet d: u64 = 4294967295;   // OK\nlet e: u64 = -1;           // ERREUR : u64 cannot be negative\n```\n\n## Exemples de promotion de type\n\n### Types entiers mixtes\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet sum = a + b;     // i32 (30)\n\nlet c: u8 = 100;\nlet d: u32 = 200;\nlet total = c + d;   // u32 (300)\n```\n\n### Entier + Flottant\n\n```hemlock\nlet i: i32 = 5;\nlet f: f32 = 2.5;\nlet result = i * f;  // f32 (12.5)\n```\n\n### Expressions complexes\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet c: f64 = 3.0;\n\nlet result = a + b * c;  // f64 (70.0)\n// Evaluation : b * c -> f64(60.0)\n//              a + f64(60.0) -> f64(70.0)\n```\n\n## Typage canard (Objets)\n\nLes objets utilisent le **typage structurel** (typage canard) :\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK : A tous les champs requis\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK : Champs supplementaires autorises\nlet p2: Person = { name: \"Bob\", age: 25, city: \"NYC\" };\n\n// ERREUR : Champ 'age' manquant\nlet p3: Person = { name: \"Carol\" };\n\n// ERREUR : Mauvais type pour 'age'\nlet p4: Person = { name: \"Dave\", age: \"trente\" };\n```\n\n**La verification de type se fait a l'assignation :**\n- Valide que tous les champs requis sont presents\n- Valide que les types de champ correspondent\n- Les champs supplementaires sont autorises et preserves\n- Definit le nom de type de l'objet pour `typeof()`\n\n## Champs optionnels\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug?: false,     // Optionnel avec valeur par defaut\n    timeout?: i32,     // Optionnel, par defaut null\n}\n\nlet cfg1: Config = { host: \"localhost\", port: 8080 };\nprint(cfg1.debug);    // false (par defaut)\nprint(cfg1.timeout);  // null\n\nlet cfg2: Config = { host: \"0.0.0.0\", port: 80, debug: true };\nprint(cfg2.debug);    // true (remplace)\n```\n\n## Alias de type\n\nHemlock supporte les alias de type personnalises avec le mot-cle `type` :\n\n### Alias de type basiques\n\n```hemlock\n// Alias de type simple\ntype Integer = i32;\ntype Text = string;\n\n// Utiliser l'alias\nlet x: Integer = 42;\nlet msg: Text = \"bonjour\";\n```\n\n### Alias de type fonction\n\n```hemlock\n// Alias de type fonction\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// Utiliser les alias de type fonction\nlet cb: Callback = fn(n) { print(n); };\nlet isEven: Predicate = fn(n) { return n % 2 == 0; };\n```\n\n### Alias de type compose\n\n```hemlock\n// Combiner plusieurs defines en un seul type\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\ntype Person = HasName & HasAge;\n\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\n### Alias de type generique\n\n```hemlock\n// Alias de type generique\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// Utiliser les alias generiques\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**Note :** Les alias de type sont transparents - `typeof()` retourne le nom du type sous-jacent, pas l'alias.\n\n## Limitations du systeme de types\n\nLimitations actuelles :\n\n- **Pas de generiques sur les fonctions** - Les parametres de type de fonction pas encore supportes\n- **Pas de types union** - Impossible d'exprimer \"A ou B\"\n- **Pas de types nullables** - Tous les types peuvent etre null (utilisez le suffixe `?` pour la nullabilite explicite)\n\n**Note :** Le compilateur (`hemlockc`) fournit une verification de type a la compilation. L'interpreteur effectue uniquement une verification de type a l'execution. Voir la [documentation du compilateur](#design-implementation) pour plus de details.\n\n## Bonnes pratiques\n\n### Quand utiliser les annotations de type\n\n**UTILISEZ des annotations quand :**\n- Le type precis compte (ex. `u8` pour les valeurs d'octet)\n- Documenter les interfaces de fonction\n- Appliquer des contraintes (ex. verifications de plage)\n\n```hemlock\nfn hash(data: buffer, length: u32): u64 {\n    // Implementation\n}\n```\n\n**N'UTILISEZ PAS d'annotations quand :**\n- Le type est evident d'apres le litteral\n- Details d'implementation internes\n- Ceremonie inutile\n\n```hemlock\n// Inutile\nlet x: i32 = 42;\n\n// Mieux\nlet x = 42;\n```\n\n### Modeles de securite de type\n\n**Verifier avant utilisation :**\n```hemlock\nif (typeof(value) == \"i32\") {\n    // Securise a utiliser comme i32\n}\n```\n\n**Valider les arguments de fonction :**\n```hemlock\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" || typeof(b) != \"i32\") {\n        throw \"les arguments doivent etre des entiers\";\n    }\n    if (b == 0) {\n        throw \"division par zero\";\n    }\n    return a / b;\n}\n```\n\n**Utiliser le typage canard pour la flexibilite :**\n```hemlock\ndefine Printable {\n    toString: fn,\n}\n\nfn print_item(item: Printable) {\n    print(item.toString());\n}\n```\n\n## Prochaines etapes\n\n- [Chaines](#language-guide-strings) - Type chaine UTF-8 et operations\n- [Runes](#language-guide-runes) - Type point de code Unicode\n- [Tableaux](#language-guide-arrays) - Type tableau dynamique\n- [Objets](#language-guide-objects) - Litteraux d'objet et typage canard\n- [Memoire](#language-guide-memory) - Types pointeur et buffer\n"}, "Sujets Avancs -> Arguments en Ligne de Commande": {"id": "advanced-command-line-args", "content": "# Arguments en ligne de commande dans Hemlock\n\nLes programmes Hemlock peuvent acceder aux arguments en ligne de commande via un **tableau `args` integre** qui est automatiquement rempli au demarrage du programme.\n\n## Table des matieres\n\n- [Vue d'ensemble](#vue-densemble)\n- [Le tableau args](#le-tableau-args)\n- [Proprietes](#proprietes)\n- [Patterns d'iteration](#patterns-diteration)\n- [Cas d'utilisation courants](#cas-dutilisation-courants)\n- [Patterns d'analyse d'arguments](#patterns-danalyse-darguments)\n- [Bonnes pratiques](#bonnes-pratiques)\n- [Exemples complets](#exemples-complets)\n\n## Vue d'ensemble\n\nLe tableau `args` fournit un acces aux arguments en ligne de commande passes a votre programme Hemlock :\n\n- **Toujours disponible** - Variable globale integree dans tous les programmes Hemlock\n- **Nom du script inclus** - `args[0]` contient toujours le chemin/nom du script\n- **Tableau de chaines** - Tous les arguments sont des chaines\n- **Indexe a zero** - Indexation standard de tableau (0, 1, 2, ...)\n\n## Le tableau args\n\n### Structure de base\n\n```hemlock\n// args[0] est toujours le nom du fichier script\n// args[1] a args[n-1] sont les arguments reels\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // Nombre total d'arguments (incluant le nom du script)\n```\n\n### Exemple d'utilisation\n\n**Commande :**\n```bash\n./hemlock script.hml hello world \"test 123\"\n```\n\n**Dans script.hml :**\n```hemlock\nprint(\"Nom du script : \" + args[0]);     // \"script.hml\"\nprint(\"Total args : \" + typeof(args.length));  // \"4\"\nprint(\"Premier arg : \" + args[1]);       // \"hello\"\nprint(\"Deuxieme arg : \" + args[2]);      // \"world\"\nprint(\"Troisieme arg : \" + args[3]);     // \"test 123\"\n```\n\n### Reference des index\n\n| Index | Contient | Valeur d'exemple |\n|-------|----------|------------------|\n| `args[0]` | Chemin/nom du script | `\"script.hml\"` ou `\"./script.hml\"` |\n| `args[1]` | Premier argument | `\"hello\"` |\n| `args[2]` | Deuxieme argument | `\"world\"` |\n| `args[3]` | Troisieme argument | `\"test 123\"` |\n| ... | ... | ... |\n| `args[n-1]` | Dernier argument | (variable) |\n\n## Proprietes\n\n### Toujours present\n\n`args` est un tableau global disponible dans **tous** les programmes Hemlock :\n\n```hemlock\n// Pas besoin de declarer ou d'importer\nprint(args.length);  // Fonctionne immediatement\n```\n\n### Nom du script inclus\n\n`args[0]` contient toujours le chemin/nom du script :\n\n```hemlock\nprint(\"Execution de : \" + args[0]);\n```\n\n**Valeurs possibles pour args[0] :**\n- `\"script.hml\"` - Juste le nom de fichier\n- `\"./script.hml\"` - Chemin relatif\n- `\"/home/user/script.hml\"` - Chemin absolu\n- Depend de la facon dont le script a ete invoque\n\n### Type : Tableau de chaines\n\nTous les arguments sont stockes comme chaines :\n\n```hemlock\n// Arguments : ./hemlock script.hml 42 3.14 true\n\nprint(args[1]);  // \"42\" (chaine, pas nombre)\nprint(args[2]);  // \"3.14\" (chaine, pas nombre)\nprint(args[3]);  // \"true\" (chaine, pas booleen)\n\n// Convertir si necessaire :\nlet num = 42;  // Parser manuellement si necessaire\n```\n\n### Longueur minimale\n\nToujours au moins 1 (le nom du script) :\n\n```hemlock\nprint(args.length);  // Minimum : 1\n```\n\n**Meme sans arguments :**\n```bash\n./hemlock script.hml\n```\n\n```hemlock\n// Dans script.hml :\nprint(args.length);  // 1 (juste le nom du script)\n```\n\n### Comportement du REPL\n\nDans le REPL, `args.length` est 0 (tableau vide) :\n\n```hemlock\n# Session REPL\n> print(args.length);\n0\n```\n\n## Patterns d'iteration\n\n### Iteration de base\n\nIgnorer `args[0]` (nom du script) et traiter les arguments reels :\n\n```hemlock\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument \" + typeof(i) + \" : \" + args[i]);\n    i = i + 1;\n}\n```\n\n**Sortie pour : `./hemlock script.hml foo bar baz`**\n```\nArgument 1 : foo\nArgument 2 : bar\nArgument 3 : baz\n```\n\n### Iteration for-in (incluant le nom du script)\n\n```hemlock\nfor (let arg in args) {\n    print(arg);\n}\n```\n\n**Sortie :**\n```\nscript.hml\nfoo\nbar\nbaz\n```\n\n### Verification du nombre d'arguments\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage : \" + args[0] + \" <argument>\");\n    // exit ou return\n} else {\n    let arg = args[1];\n    // traiter arg\n}\n```\n\n### Traitement de tous les arguments sauf le nom du script\n\n```hemlock\nlet actual_args = args.slice(1, args.length);\n\nfor (let arg in actual_args) {\n    print(\"Traitement : \" + arg);\n}\n```\n\n## Cas d'utilisation courants\n\n### 1. Traitement d'argument simple\n\nVerifier un argument requis :\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage : \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    print(\"Traitement du fichier : \" + filename);\n    // ... traiter le fichier\n}\n```\n\n**Utilisation :**\n```bash\n./hemlock script.hml data.txt\n# Sortie : Traitement du fichier : data.txt\n```\n\n### 2. Arguments multiples\n\n```hemlock\nif (args.length < 3) {\n    print(\"Usage : \" + args[0] + \" <input> <output>\");\n} else {\n    let input_file = args[1];\n    let output_file = args[2];\n\n    print(\"Entree : \" + input_file);\n    print(\"Sortie : \" + output_file);\n\n    // Traiter les fichiers...\n}\n```\n\n**Utilisation :**\n```bash\n./hemlock convert.hml input.txt output.txt\n```\n\n### 3. Nombre variable d'arguments\n\nTraiter tous les arguments fournis :\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage : \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Traitement de \" + typeof(args.length - 1) + \" fichiers :\");\n\n    let i = 1;\n    while (i < args.length) {\n        print(\"  \" + args[i]);\n        process_file(args[i]);\n        i = i + 1;\n    }\n}\n```\n\n**Utilisation :**\n```bash\n./hemlock batch.hml file1.txt file2.txt file3.txt\n```\n\n### 4. Message d'aide\n\n```hemlock\nif (args.length < 2 || args[1] == \"--help\" || args[1] == \"-h\") {\n    print(\"Usage : \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options :\");\n    print(\"  -h, --help     Afficher ce message d'aide\");\n    print(\"  -v, --verbose  Activer la sortie verbeuse\");\n} else {\n    // Traitement normal\n}\n```\n\n### 5. Validation d'arguments\n\n```hemlock\nfn validate_file(filename: string): bool {\n    // Verifier si le fichier existe (exemple)\n    return filename != \"\";\n}\n\nif (args.length < 2) {\n    print(\"Erreur : Pas de nom de fichier fourni\");\n} else if (!validate_file(args[1])) {\n    print(\"Erreur : Fichier invalide : \" + args[1]);\n} else {\n    print(\"Traitement : \" + args[1]);\n}\n```\n\n## Patterns d'analyse d'arguments\n\n### Arguments nommes (drapeaux)\n\nPattern simple pour les arguments nommes :\n\n```hemlock\nlet verbose = false;\nlet output_file = \"\";\nlet input_file = \"\";\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\" || args[i] == \"-v\") {\n        verbose = true;\n    } else if (args[i] == \"--output\" || args[i] == \"-o\") {\n        i = i + 1;\n        if (i < args.length) {\n            output_file = args[i];\n        }\n    } else {\n        input_file = args[i];\n    }\n    i = i + 1;\n}\n\nif (verbose) {\n    print(\"Mode verbeux active\");\n}\nprint(\"Entree : \" + input_file);\nprint(\"Sortie : \" + output_file);\n```\n\n**Utilisation :**\n```bash\n./hemlock script.hml --verbose --output out.txt input.txt\n./hemlock script.hml -v -o out.txt input.txt\n```\n\n### Drapeaux booleens\n\n```hemlock\nlet debug = false;\nlet verbose = false;\nlet force = false;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--debug\") {\n        debug = true;\n    } else if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else if (args[i] == \"--force\") {\n        force = true;\n    }\n    i = i + 1;\n}\n```\n\n### Arguments avec valeurs\n\n```hemlock\nlet config_file = \"default.conf\";\nlet port = 8080;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--config\") {\n        i = i + 1;\n        if (i < args.length) {\n            config_file = args[i];\n        }\n    } else if (args[i] == \"--port\") {\n        i = i + 1;\n        if (i < args.length) {\n            port = 8080;  // Necessiterait de parser la chaine en int\n        }\n    }\n    i = i + 1;\n}\n```\n\n### Arguments positionnels et nommes melanges\n\n```hemlock\nlet input_file = \"\";\nlet output_file = \"\";\nlet verbose = false;\n\nlet i = 1;\nlet positional = [];\n\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else {\n        // Traiter comme argument positionnel\n        positional.push(args[i]);\n    }\n    i = i + 1;\n}\n\n// Assigner les arguments positionnels\nif (positional.length > 0) {\n    input_file = positional[0];\n}\nif (positional.length > 1) {\n    output_file = positional[1];\n}\n```\n\n### Fonction d'aide a l'analyse d'arguments\n\n```hemlock\nfn parse_args() {\n    let options = {\n        verbose: false,\n        output: \"\",\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            options.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                options.output = args[i];\n            }\n        } else {\n            // Argument positionnel\n            options.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return options;\n}\n\nlet opts = parse_args();\nprint(\"Verbose : \" + typeof(opts.verbose));\nprint(\"Output : \" + opts.output);\nprint(\"Fichiers : \" + typeof(opts.files.length));\n```\n\n## Bonnes pratiques\n\n### 1. Toujours verifier le nombre d'arguments\n\n```hemlock\n// Bien\nif (args.length < 2) {\n    print(\"Usage : \" + args[0] + \" <file>\");\n} else {\n    process_file(args[1]);\n}\n\n// Mauvais - peut planter si pas d'arguments\nprocess_file(args[1]);  // Erreur si args.length == 1\n```\n\n### 2. Fournir des informations d'utilisation\n\n```hemlock\nfn show_usage() {\n    print(\"Usage : \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options :\");\n    print(\"  -h, --help     Afficher l'aide\");\n    print(\"  -v, --verbose  Sortie verbeuse\");\n}\n\nif (args.length < 2) {\n    show_usage();\n}\n```\n\n### 3. Valider les arguments\n\n```hemlock\nfn validate_args() {\n    if (args.length < 2) {\n        print(\"Erreur : Argument requis manquant\");\n        return false;\n    }\n\n    if (args[1] == \"\") {\n        print(\"Erreur : Argument vide\");\n        return false;\n    }\n\n    return true;\n}\n\nif (!validate_args()) {\n    // exit ou afficher l'utilisation\n}\n```\n\n### 4. Utiliser des noms de variables descriptifs\n\n```hemlock\n// Bien\nlet input_filename = args[1];\nlet output_filename = args[2];\nlet max_iterations = args[3];\n\n// Mauvais\nlet a = args[1];\nlet b = args[2];\nlet c = args[3];\n```\n\n### 5. Gerer les arguments avec espaces entre guillemets\n\nLe shell gere cela automatiquement :\n\n```bash\n./hemlock script.hml \"fichier avec espaces.txt\"\n```\n\n```hemlock\nprint(args[1]);  // \"fichier avec espaces.txt\"\n```\n\n### 6. Creer des objets d'arguments\n\n```hemlock\nfn get_args() {\n    return {\n        script: args[0],\n        input: args[1],\n        output: args[2]\n    };\n}\n\nlet arguments = get_args();\nprint(\"Entree : \" + arguments.input);\n```\n\n## Exemples complets\n\n### Exemple 1 : Processeur de fichiers\n\n```hemlock\n// Usage : ./hemlock process.hml <input> <output>\n\nfn show_usage() {\n    print(\"Usage : \" + args[0] + \" <input_file> <output_file>\");\n}\n\nif (args.length < 3) {\n    show_usage();\n} else {\n    let input = args[1];\n    let output = args[2];\n\n    print(\"Traitement de \" + input + \" -> \" + output);\n\n    // Traiter les fichiers\n    let f_in = open(input, \"r\");\n    let f_out = open(output, \"w\");\n\n    try {\n        let content = f_in.read();\n        let processed = content.to_upper();  // Exemple de traitement\n        f_out.write(processed);\n\n        print(\"Termine !\");\n    } finally {\n        f_in.close();\n        f_out.close();\n    }\n}\n```\n\n### Exemple 2 : Processeur de fichiers par lots\n\n```hemlock\n// Usage : ./hemlock batch.hml <file1> <file2> <file3> ...\n\nif (args.length < 2) {\n    print(\"Usage : \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Traitement de \" + typeof(args.length - 1) + \" fichiers :\");\n\n    let i = 1;\n    while (i < args.length) {\n        let filename = args[i];\n        print(\"  Traitement : \" + filename);\n\n        try {\n            let f = open(filename, \"r\");\n            let content = f.read();\n            f.close();\n\n            // Traiter le contenu...\n            print(\"    \" + typeof(content.length) + \" octets\");\n        } catch (e) {\n            print(\"    Erreur : \" + e);\n        }\n\n        i = i + 1;\n    }\n\n    print(\"Termine !\");\n}\n```\n\n### Exemple 3 : Analyseur d'arguments avance\n\n```hemlock\n// Usage : ./hemlock app.hml [OPTIONS] <files...>\n// Options :\n//   --verbose, -v     Activer la sortie verbeuse\n//   --output, -o FILE Definir le fichier de sortie\n//   --help, -h        Afficher l'aide\n\nfn parse_arguments() {\n    let config = {\n        verbose: false,\n        output: \"output.txt\",\n        help: false,\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            config.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                config.output = args[i];\n            } else {\n                print(\"Erreur : --output necessite une valeur\");\n            }\n        } else if (arg == \"--help\" || arg == \"-h\") {\n            config.help = true;\n        } else if (arg.starts_with(\"--\")) {\n            print(\"Erreur : Option inconnue : \" + arg);\n        } else {\n            config.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return config;\n}\n\nfn show_help() {\n    print(\"Usage : \" + args[0] + \" [OPTIONS] <files...>\");\n    print(\"Options :\");\n    print(\"  --verbose, -v     Activer la sortie verbeuse\");\n    print(\"  --output, -o FILE Definir le fichier de sortie\");\n    print(\"  --help, -h        Afficher cette aide\");\n}\n\nlet config = parse_arguments();\n\nif (config.help) {\n    show_help();\n} else if (config.files.length == 0) {\n    print(\"Erreur : Aucun fichier d'entree specifie\");\n    show_help();\n} else {\n    if (config.verbose) {\n        print(\"Mode verbeux active\");\n        print(\"Fichier de sortie : \" + config.output);\n        print(\"Fichiers d'entree : \" + typeof(config.files.length));\n    }\n\n    // Traiter les fichiers\n    for (let file in config.files) {\n        if (config.verbose) {\n            print(\"Traitement : \" + file);\n        }\n        // ... traiter le fichier\n    }\n}\n```\n\n### Exemple 4 : Outil de configuration\n\n```hemlock\n// Usage : ./hemlock config.hml <action> [arguments]\n// Actions :\n//   get <key>\n//   set <key> <value>\n//   list\n\nfn show_usage() {\n    print(\"Usage : \" + args[0] + \" <action> [arguments]\");\n    print(\"Actions :\");\n    print(\"  get <key>         Obtenir une valeur de configuration\");\n    print(\"  set <key> <value> Definir une valeur de configuration\");\n    print(\"  list              Lister toute la configuration\");\n}\n\nif (args.length < 2) {\n    show_usage();\n} else {\n    let action = args[1];\n\n    if (action == \"get\") {\n        if (args.length < 3) {\n            print(\"Erreur : 'get' necessite une cle\");\n        } else {\n            let key = args[2];\n            print(\"Obtention de : \" + key);\n            // ... obtenir depuis la config\n        }\n    } else if (action == \"set\") {\n        if (args.length < 4) {\n            print(\"Erreur : 'set' necessite cle et valeur\");\n        } else {\n            let key = args[2];\n            let value = args[3];\n            print(\"Definition de \" + key + \" = \" + value);\n            // ... definir dans la config\n        }\n    } else if (action == \"list\") {\n        print(\"Liste de toute la configuration :\");\n        // ... lister la config\n    } else {\n        print(\"Erreur : Action inconnue : \" + action);\n        show_usage();\n    }\n}\n```\n\n## Resume\n\nLe support des arguments en ligne de commande de Hemlock fournit :\n\n-  Tableau `args` integre disponible globalement\n-  Acces simple base sur tableau aux arguments\n-  Nom du script dans `args[0]`\n-  Tous les arguments en tant que chaines\n-  Methodes de tableau disponibles (.length, .slice, etc.)\n\nRappelez-vous :\n- Toujours verifier `args.length` avant d'acceder aux elements\n- `args[0]` est le nom du script\n- Les arguments reels commencent a `args[1]`\n- Tous les arguments sont des chaines - convertir si necessaire\n- Fournir des informations d'utilisation pour des outils conviviaux\n- Valider les arguments avant le traitement\n\nPatterns courants :\n- Arguments positionnels simples\n- Arguments nommes/drapeaux (--flag)\n- Arguments avec valeurs (--option value)\n- Messages d'aide (--help)\n- Validation d'arguments\n"}, "Sujets Avancs -> Asynchronisme et Concurrence": {"id": "advanced-async-concurrency", "content": "# Async/Concurrence dans Hemlock\n\nHemlock fournit une **concurrence structuree** avec une syntaxe async/await, le lancement de taches et des canaux pour la communication. L'implementation utilise les threads POSIX (pthreads) pour un **VERITABLE parallelisme multi-thread**.\n\n## Table des matieres\n\n- [Vue d'ensemble](#vue-densemble)\n- [Modele de threading](#modele-de-threading)\n- [Fonctions asynchrones](#fonctions-asynchrones)\n- [Lancement de taches](#lancement-de-taches)\n- [Canaux](#canaux)\n- [Propagation des exceptions](#propagation-des-exceptions)\n- [Details d'implementation](#details-dimplementation)\n- [Bonnes pratiques](#bonnes-pratiques)\n- [Caracteristiques de performance](#caracteristiques-de-performance)\n- [Limitations actuelles](#limitations-actuelles)\n\n## Vue d'ensemble\n\n**Ce que cela signifie :**\n-  **Vrais threads OS** - Chaque tache lancee s'execute sur un pthread separe (thread POSIX)\n-  **Vrai parallelisme** - Les taches s'executent simultanement sur plusieurs coeurs CPU\n-  **Ordonnance par le noyau** - L'ordonnanceur du systeme d'exploitation distribue les taches sur les coeurs disponibles\n-  **Canaux thread-safe** - Utilise des mutex pthread et des variables de condition pour la synchronisation\n\n**Ce que ce n'est PAS :**\n-  **PAS des green threads** - Pas de multitache cooperatif en espace utilisateur\n-  **PAS des coroutines async/await** - Pas de boucle d'evenements mono-thread comme JavaScript/Python asyncio\n-  **PAS une concurrence emulee** - Pas de parallelisme simule\n\nC'est le **meme modele de threading que C, C++ et Rust** lors de l'utilisation des threads OS. Vous obtenez une execution parallele reelle sur plusieurs coeurs.\n\n## Modele de threading\n\n### Threading 1:1\n\nHemlock utilise un **modele de threading 1:1**, ou :\n- Chaque tache lancee cree un thread OS dedie via `pthread_create()`\n- Le noyau du systeme d'exploitation ordonnance les threads sur les coeurs CPU disponibles\n- Multitache preemptif - le systeme peut interrompre et basculer entre les threads\n- **Pas de GIL** - Contrairement a Python, il n'y a pas de Global Interpreter Lock limitant le parallelisme\n\n### Mecanismes de synchronisation\n\n- **Mutex** - Les canaux utilisent `pthread_mutex_t` pour un acces thread-safe\n- **Variables de condition** - Les send/recv bloquants utilisent `pthread_cond_t` pour une attente efficace\n- **Operations sans verrou** - Les transitions d'etat des taches sont atomiques\n\n## Fonctions asynchrones\n\nLes fonctions peuvent etre declarees comme `async` pour indiquer qu'elles sont concues pour une execution concurrente :\n\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n```\n\n### Points cles\n\n- `async fn` declare une fonction asynchrone\n- Les fonctions async peuvent etre lancees comme taches concurrentes en utilisant `spawn()`\n- Les fonctions async peuvent aussi etre appelees directement (s'execute de maniere synchrone dans le thread courant)\n- Une fois lancee, chaque tache s'execute sur **son propre thread OS** (pas une coroutine !)\n- Le mot-cle `await` est reserve pour une utilisation future\n\n### Exemple : Appel direct vs Spawn\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Appel direct - s'execute de maniere synchrone\nlet result1 = factorial(5);  // 120\n\n// Tache lancee - s'execute sur un thread separe\nlet task = spawn(factorial, 5);\nlet result2 = join(task);  // 120\n```\n\n## Lancement de taches\n\nUtilisez `spawn()` pour executer des fonctions async **en parallele sur des threads OS separes** :\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Lancer plusieurs taches - elles s'executent en PARALLELE sur differents coeurs CPU !\nlet t1 = spawn(factorial, 5);  // Thread 1\nlet t2 = spawn(factorial, 6);  // Thread 2\nlet t3 = spawn(factorial, 7);  // Thread 3\n\n// Toutes les trois calculent simultanement en ce moment !\n\n// Attendre les resultats\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\n```\n\n### Fonctions integrees\n\n#### spawn(async_fn, arg1, arg2, ...)\n\nCree une nouvelle tache sur un nouveau pthread, retourne un handle de tache.\n\n**Parametres :**\n- `async_fn` - La fonction async a executer\n- `arg1, arg2, ...` - Arguments a passer a la fonction\n\n**Retourne :** Handle de tache (valeur opaque utilisee avec `join()` ou `detach()`)\n\n**Exemple :**\n```hemlock\nasync fn process(data: string, count: i32): i32 {\n    // ... logique de traitement\n    return count * 2;\n}\n\nlet task = spawn(process, \"test\", 42);\n```\n\n#### join(task)\n\nAttend la completion de la tache (bloque jusqu'a ce que le thread se termine), retourne le resultat.\n\n**Parametres :**\n- `task` - Handle de tache retourne par `spawn()`\n\n**Retourne :** La valeur retournee par la fonction async\n\n**Exemple :**\n```hemlock\nlet task = spawn(compute, 1000);\nlet result = join(task);  // Bloque jusqu'a ce que compute() se termine\nprint(result);\n```\n\n**Important :** Chaque tache ne peut etre jointe qu'une seule fois. Les joins subsequents provoqueront une erreur.\n\n#### detach(task)\n\nExecution fire-and-forget (le thread s'execute independamment, join non autorise).\n\n**Parametres :**\n- `task` - Handle de tache retourne par `spawn()`\n\n**Retourne :** `null`\n\n**Exemple :**\n```hemlock\nasync fn background_work() {\n    // Tache de fond de longue duree\n    // ...\n}\n\nlet task = spawn(background_work);\ndetach(task);  // La tache s'execute independamment, impossible de joindre\n```\n\n**Important :** Les taches detachees ne peuvent pas etre jointes. Le pthread et la structure Task sont automatiquement nettoyes quand la tache se termine.\n\n## Canaux\n\nLes canaux fournissent une communication thread-safe entre les taches en utilisant un tampon borne avec une semantique bloquante.\n\n### Creation de canaux\n\n```hemlock\nlet ch = channel(10);  // Creer un canal avec une taille de tampon de 10\n```\n\n**Parametres :**\n- `capacity` (i32) - Nombre maximum de valeurs que le canal peut contenir\n\n**Retourne :** Objet canal\n\n### Methodes de canal\n\n#### send(value)\n\nEnvoyer une valeur au canal (bloque si plein).\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet task = spawn(producer, ch, 5);\n```\n\n**Comportement :**\n- Si le canal a de l'espace, la valeur est ajoutee immediatement\n- Si le canal est plein, l'expediteur bloque jusqu'a ce que de l'espace devienne disponible\n- Si le canal est ferme, lance une exception\n\n#### recv()\n\nRecevoir une valeur du canal (bloque si vide).\n\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet task = spawn(consumer, ch, 5);\n```\n\n**Comportement :**\n- Si le canal a des valeurs, retourne la prochaine valeur immediatement\n- Si le canal est vide, le recepteur bloque jusqu'a ce qu'une valeur soit disponible\n- Si le canal est ferme et vide, retourne `null`\n\n#### close()\n\nFermer le canal (recv sur un canal ferme retourne null).\n\n```hemlock\nch.close();\n```\n\n**Comportement :**\n- Empeche les operations `send()` ulterieures (lancera une exception)\n- Permet aux operations `recv()` en attente de se terminer\n- Une fois vide, `recv()` retourne `null`\n\n### Multiplexage avec select()\n\nLa fonction `select()` permet d'attendre sur plusieurs canaux simultanement, retournant quand n'importe quel canal a des donnees disponibles.\n\n**Signature :**\n```hemlock\nselect(channels: array, timeout_ms?: i32): object | null\n```\n\n**Parametres :**\n- `channels` - Tableau de valeurs de canaux\n- `timeout_ms` (optionnel) - Delai d'attente en millisecondes (-1 ou omettre pour attente infinie)\n\n**Retourne :**\n- `{ channel, value }` - Objet avec le canal qui avait des donnees et la valeur recue\n- `null` - En cas de timeout (si un timeout etait specifie)\n\n**Exemple :**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// Taches productrices\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"from channel 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"from channel 2\");\n});\n\n// Attendre le premier resultat (ch2 devrait etre plus rapide)\nlet result = select([ch1, ch2]);\nprint(result.value);  // \"from channel 2\"\n\n// Attendre le deuxieme resultat\nlet result2 = select([ch1, ch2]);\nprint(result2.value);  // \"from channel 1\"\n```\n\n**Avec timeout :**\n```hemlock\nlet ch = channel(1);\n\n// Pas d'expediteur, va expirer\nlet result = select([ch], 100);  // timeout de 100ms\nif (result == null) {\n    print(\"Delai depasse !\");\n}\n```\n\n**Cas d'utilisation :**\n- Attendre le plus rapide parmi plusieurs sources de donnees\n- Implementer des timeouts sur les operations de canal\n- Patterns de boucle d'evenements avec plusieurs sources d'evenements\n- Fan-in : fusionner plusieurs canaux en un seul\n\n**Pattern fan-in :**\n```hemlock\nfn fan_in(channels: array, output: channel) {\n    while (true) {\n        let result = select(channels);\n        if (result == null) {\n            break;  // Tous les canaux fermes\n        }\n        output.send(result.value);\n    }\n    output.close();\n}\n```\n\n### Exemple complet producteur-consommateur\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Creer un canal avec une taille de tampon\nlet ch = channel(10);\n\n// Lancer le producteur et le consommateur\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Attendre la completion\njoin(p);\nlet total = join(c);  // 100 (0+10+20+30+40)\nprint(total);\n```\n\n### Multi-producteur, multi-consommateur\n\nLes canaux peuvent etre partages en toute securite entre plusieurs producteurs et consommateurs :\n\n```hemlock\nasync fn producer(id: i32, ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(id * 100 + i);\n        i = i + 1;\n    }\n}\n\nasync fn consumer(id: i32, ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(20);\n\n// Plusieurs producteurs\nlet p1 = spawn(producer, 1, ch, 5);\nlet p2 = spawn(producer, 2, ch, 5);\n\n// Plusieurs consommateurs\nlet c1 = spawn(consumer, 1, ch, 5);\nlet c2 = spawn(consumer, 2, ch, 5);\n\n// Attendre tous\njoin(p1);\njoin(p2);\nlet sum1 = join(c1);\nlet sum2 = join(c2);\nprint(sum1 + sum2);\n```\n\n## Propagation des exceptions\n\nLes exceptions lancees dans les taches spawn sont propagees lors du join :\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"La tache a echoue !\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Intercepte : \" + e);  // \"Intercepte : La tache a echoue !\"\n}\n```\n\n### Patterns de gestion des exceptions\n\n**Pattern 1 : Gerer dans la tache**\n```hemlock\nasync fn safe_task() {\n    try {\n        // operation risquee\n    } catch (e) {\n        print(\"Erreur dans la tache : \" + e);\n        return null;\n    }\n}\n\nlet task = spawn(safe_task);\njoin(task);  // Pas d'exception propagee\n```\n\n**Pattern 2 : Propager a l'appelant**\n```hemlock\nasync fn task_that_throws() {\n    throw \"erreur\";\n}\n\nlet task = spawn(task_that_throws);\ntry {\n    join(task);\n} catch (e) {\n    print(\"Intercepte depuis la tache : \" + e);\n}\n```\n\n**Pattern 3 : Taches detachees avec exceptions**\n```hemlock\nasync fn detached_task() {\n    try {\n        // travail\n    } catch (e) {\n        // Doit gerer en interne - ne peut pas propager\n        print(\"Erreur : \" + e);\n    }\n}\n\nlet task = spawn(detached_task);\ndetach(task);  // Impossible d'intercepter les exceptions des taches detachees\n```\n\n## Details d'implementation\n\n### Architecture de threading\n\n- **Threading 1:1** - Chaque tache lancee cree un thread OS dedie via `pthread_create()`\n- **Ordonnance par le noyau** - Le noyau du systeme ordonnance les threads sur les coeurs CPU disponibles\n- **Multitache preemptif** - Le systeme peut interrompre et basculer entre les threads\n- **Pas de GIL** - Contrairement a Python, il n'y a pas de Global Interpreter Lock limitant le parallelisme\n\n### Implementation des canaux\n\nLes canaux utilisent un tampon circulaire avec synchronisation pthread :\n\n```\nStructure du canal :\n- buffer[] - Tableau de taille fixe de Values\n- capacity - Nombre maximum d'elements\n- size - Nombre actuel d'elements\n- head - Position de lecture\n- tail - Position d'ecriture\n- mutex - pthread_mutex_t pour un acces thread-safe\n- not_empty - pthread_cond_t pour recv bloquant\n- not_full - pthread_cond_t pour send bloquant\n- closed - Drapeau booleen\n- refcount - Compteur de references pour le nettoyage\n```\n\n**Comportement bloquant :**\n- `send()` sur canal plein : attend sur la variable de condition `not_full`\n- `recv()` sur canal vide : attend sur la variable de condition `not_empty`\n- Les deux sont signales de maniere appropriee par l'operation opposee\n\n### Memoire et nettoyage\n\n- **Taches jointes :** Automatiquement nettoyees apres que `join()` retourne\n- **Taches detachees :** Automatiquement nettoyees quand la tache se termine\n- **Canaux :** Comptes par reference et liberes quand plus utilises\n\n## Bonnes pratiques\n\n### 1. Toujours fermer les canaux\n\n```hemlock\nasync fn producer(ch) {\n    // ... envoyer des valeurs\n    ch.close();  // Important : signaler qu'il n'y a plus de valeurs\n}\n```\n\n### 2. Utiliser la concurrence structuree\n\nLancer des taches et les joindre dans la meme portee :\n\n```hemlock\nfn process_data(data) {\n    // Lancer des taches\n    let t1 = spawn(worker, data);\n    let t2 = spawn(worker, data);\n\n    // Toujours joindre avant de retourner\n    let r1 = join(t1);\n    let r2 = join(t2);\n\n    return r1 + r2;\n}\n```\n\n### 3. Gerer les exceptions de maniere appropriee\n\n```hemlock\nasync fn task() {\n    try {\n        // operation risquee\n    } catch (e) {\n        // Logger l'erreur\n        throw e;  // Relancer si l'appelant doit savoir\n    }\n}\n```\n\n### 4. Utiliser une capacite de canal appropriee\n\n- **Petite capacite (1-10) :** Pour la coordination/signalisation\n- **Capacite moyenne (10-100) :** Pour le producteur-consommateur general\n- **Grande capacite (100+) :** Pour les scenarios a haut debit\n\n```hemlock\nlet signal_ch = channel(1);      // Coordination\nlet work_ch = channel(50);       // File de travail\nlet buffer_ch = channel(1000);   // Haut debit\n```\n\n### 5. Detacher uniquement si necessaire\n\nPreferez `join()` a `detach()` pour une meilleure gestion des ressources :\n\n```hemlock\n// Bien : Joindre et obtenir le resultat\nlet task = spawn(work);\nlet result = join(task);\n\n// Utiliser detach uniquement pour le vrai fire-and-forget\nlet bg_task = spawn(background_logging);\ndetach(bg_task);  // S'executera independamment\n```\n\n## Caracteristiques de performance\n\n### Vrai parallelisme\n\n- **N taches lancees peuvent utiliser N coeurs CPU simultanement**\n- Acceleration prouvee - les tests de stress montrent 8-9x le temps CPU vs le temps reel (plusieurs coeurs travaillant)\n- Mise a l'echelle lineaire avec le nombre de coeurs (jusqu'au nombre de threads)\n\n### Surcharge des threads\n\n- Chaque tache a ~8Ko de pile + surcharge pthread\n- Cout de creation de thread : ~10-20us\n- Cout de changement de contexte : ~1-5us\n\n### Quand utiliser Async\n\n**Bons cas d'utilisation :**\n- Calculs intensifs en CPU qui peuvent etre parallelises\n- Operations liees aux E/S (bien que les E/S soient toujours bloquantes)\n- Traitement concurrent de donnees independantes\n- Architectures en pipeline avec canaux\n\n**Pas ideal pour :**\n- Taches tres courtes (la surcharge des threads domine)\n- Taches avec beaucoup de synchronisation (surcharge de contention)\n- Systemes mono-coeur (pas de benefice de parallelisme)\n\n### E/S bloquantes securisees\n\nLes operations bloquantes dans une tache ne bloquent pas les autres :\n\n```hemlock\nasync fn reader(filename: string) {\n    let f = open(filename, \"r\");  // Bloque ce thread uniquement\n    let content = f.read();       // Bloque ce thread uniquement\n    f.close();\n    return content;\n}\n\n// Les deux lisent de maniere concurrente (sur differents threads)\nlet t1 = spawn(reader, \"file1.txt\");\nlet t2 = spawn(reader, \"file2.txt\");\n\nlet c1 = join(t1);\nlet c2 = join(t2);\n```\n\n## Modele de securite des threads\n\nHemlock utilise un modele de concurrence par **passage de messages** ou les taches communiquent via des canaux plutot que par un etat mutable partage.\n\n### Isolation des arguments\n\nQuand vous lancez une tache, **les arguments sont copies en profondeur** pour prevenir les courses de donnees :\n\n```hemlock\nasync fn modify_array(arr: array): array {\n    arr.push(999);    // Modifie la COPIE, pas l'original\n    arr[0] = -1;\n    return arr;\n}\n\nlet original = [1, 2, 3];\nlet task = spawn(modify_array, original);\nlet modified = join(task);\n\nprint(original.length);  // 3 - inchange !\nprint(modified.length);  // 4 - a le nouvel element\n```\n\n**Ce qui est copie en profondeur :**\n- Tableaux (et tous les elements recursivement)\n- Objets (et tous les champs recursivement)\n- Chaines de caracteres\n- Tampons (buffers)\n\n**Ce qui est partage (reference retenue) :**\n- Canaux (le mecanisme de communication - intentionnellement partage)\n- Handles de taches (pour la coordination)\n- Fonctions (le code est immuable)\n- Handles de fichiers (le systeme gere l'acces concurrent)\n- Handles de sockets (le systeme gere l'acces concurrent)\n\n**Ce qui ne peut pas etre passe :**\n- Pointeurs bruts (`ptr`) - utilisez `buffer` a la place\n\n### Pourquoi le passage de messages ?\n\nCela suit la philosophie \"explicite plutot qu'implicite\" de Hemlock :\n\n```hemlock\n// MAUVAIS : Etat mutable partage (causerait des courses de donnees)\nlet counter = { value: 0 };\nlet t1 = spawn(fn() { counter.value = counter.value + 1; });  // Course !\nlet t2 = spawn(fn() { counter.value = counter.value + 1; });  // Course !\n\n// BON : Passage de messages via canaux\nasync fn increment(ch) {\n    let val = ch.recv();\n    ch.send(val + 1);\n}\n\nlet ch = channel(1);\nch.send(0);\nlet t1 = spawn(increment, ch);\njoin(t1);\nlet result = ch.recv();  // 1 - pas de condition de course\n```\n\n### Securite du comptage de references\n\nToutes les operations de comptage de references utilisent des **operations atomiques** pour prevenir les bugs use-after-free :\n- `string_retain/release` - atomique\n- `array_retain/release` - atomique\n- `object_retain/release` - atomique\n- `buffer_retain/release` - atomique\n- `function_retain/release` - atomique\n- `channel_retain/release` - atomique\n- `task_retain/release` - atomique\n\nCela assure une gestion memoire securisee meme quand les valeurs sont partagees entre threads.\n\n### Acces a l'environnement de closure\n\nLes taches ont acces a l'environnement de closure pour :\n- Les fonctions integrees (`print`, `len`, etc.)\n- Les definitions de fonctions globales\n- Les constantes et variables\n\nL'environnement de closure est protege par un mutex par environnement, rendant\nles lectures et ecritures concurrentes thread-safe :\n\n```hemlock\nlet x = 10;\n\nasync fn read_closure(): i32 {\n    return x;  // OK : lecture de variable de closure (thread-safe)\n}\n\nasync fn modify_closure() {\n    x = 20;  // OK : ecriture de variable de closure (synchronise avec mutex)\n}\n```\n\n**Note :** Bien que l'acces concurrent soit synchronise, modifier un etat partage depuis\nplusieurs taches peut toujours mener a des conditions de course logiques (ordonnancement\nnon deterministe). Pour un comportement previsible, utilisez des canaux pour la communication\nentre taches ou des valeurs de retour des taches.\n\nSi vous devez retourner des donnees d'une tache, utilisez la valeur de retour ou les canaux.\n\n## Limitations actuelles\n\n### 1. Pas d'ordonnanceur avec vol de travail\n\nUtilise 1 thread par tache, ce qui peut etre inefficace pour beaucoup de taches courtes.\n\n**Actuel :** 1000 taches = 1000 threads (surcharge importante)\n\n**Prevu :** Pool de threads avec vol de travail pour une meilleure efficacite\n\n### 3. Pas d'integration d'E/S asynchrones\n\nLes operations fichier/reseau bloquent toujours le thread :\n\n```hemlock\nasync fn read_file(path: string) {\n    let f = open(path, \"r\");\n    let content = f.read();  // Bloque le thread\n    f.close();\n    return content;\n}\n```\n\n**Solution de contournement :** Utilisez plusieurs threads pour les operations d'E/S concurrentes\n\n### 4. Capacite de canal fixe\n\nLa capacite du canal est definie a la creation et ne peut pas etre redimensionnee :\n\n```hemlock\nlet ch = channel(10);\n// Impossible de redimensionner dynamiquement a 20\n```\n\n### 5. La taille du canal est fixe\n\nLa taille du tampon du canal ne peut pas etre changee apres creation.\n\n## Patterns courants\n\n### Map parallele\n\n```hemlock\nasync fn map_worker(ch_in, ch_out, fn_transform) {\n    while (true) {\n        let val = ch_in.recv();\n        if (val == null) { break; }\n\n        let result = fn_transform(val);\n        ch_out.send(result);\n    }\n    ch_out.close();\n}\n\nfn parallel_map(data, fn_transform, workers: i32) {\n    let ch_in = channel(100);\n    let ch_out = channel(100);\n\n    // Lancer les workers\n    let tasks = [];\n    let i = 0;\n    while (i < workers) {\n        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));\n        i = i + 1;\n    }\n\n    // Envoyer les donnees\n    let i = 0;\n    while (i < data.length) {\n        ch_in.send(data[i]);\n        i = i + 1;\n    }\n    ch_in.close();\n\n    // Collecter les resultats\n    let results = [];\n    let i = 0;\n    while (i < data.length) {\n        results.push(ch_out.recv());\n        i = i + 1;\n    }\n\n    // Attendre les workers\n    let i = 0;\n    while (i < tasks.length) {\n        join(tasks[i]);\n        i = i + 1;\n    }\n\n    return results;\n}\n```\n\n### Architecture en pipeline\n\n```hemlock\nasync fn stage1(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val * 2);\n    }\n    output_ch.close();\n}\n\nasync fn stage2(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val + 10);\n    }\n    output_ch.close();\n}\n\n// Creer le pipeline\nlet ch1 = channel(10);\nlet ch2 = channel(10);\nlet ch3 = channel(10);\n\nlet s1 = spawn(stage1, ch1, ch2);\nlet s2 = spawn(stage2, ch2, ch3);\n\n// Alimenter l'entree\nch1.send(1);\nch1.send(2);\nch1.send(3);\nch1.close();\n\n// Collecter la sortie\nprint(ch3.recv());  // 12 (1 * 2 + 10)\nprint(ch3.recv());  // 14 (2 * 2 + 10)\nprint(ch3.recv());  // 16 (3 * 2 + 10)\n\njoin(s1);\njoin(s2);\n```\n\n### Fan-Out, Fan-In\n\n```hemlock\nasync fn worker(id: i32, input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n\n        // Traiter la valeur\n        let result = val * id;\n        output_ch.send(result);\n    }\n}\n\nlet input = channel(10);\nlet output = channel(10);\n\n// Fan-out : Plusieurs workers\nlet workers = 4;\nlet tasks = [];\nlet i = 0;\nwhile (i < workers) {\n    tasks.push(spawn(worker, i, input, output));\n    i = i + 1;\n}\n\n// Envoyer le travail\nlet i = 0;\nwhile (i < 10) {\n    input.send(i);\n    i = i + 1;\n}\ninput.close();\n\n// Fan-in : Collecter tous les resultats\nlet results = [];\nlet i = 0;\nwhile (i < 10) {\n    results.push(output.recv());\n    i = i + 1;\n}\n\n// Attendre tous les workers\nlet i = 0;\nwhile (i < tasks.length) {\n    join(tasks[i]);\n    i = i + 1;\n}\n```\n\n## Resume\n\nLe modele async/concurrence de Hemlock fournit :\n\n-  Vrai parallelisme multi-thread utilisant les threads OS\n-  Primitives de concurrence structuree simples\n-  Canaux thread-safe pour la communication\n-  Propagation des exceptions entre taches\n-  Performance prouvee sur les systemes multi-coeur\n-  **Isolation des arguments** - la copie profonde previent les courses de donnees\n-  **Comptage de references atomique** - gestion memoire securisee entre threads\n\nCela rend Hemlock adapte pour :\n- Les calculs paralleles\n- Les operations d'E/S concurrentes\n- Les architectures en pipeline\n- Les patterns producteur-consommateur\n\nTout en evitant la complexite de :\n- La gestion manuelle des threads\n- Les primitives de synchronisation bas niveau\n- Les conceptions basees sur les verrous sujettes aux deadlocks\n- Les bugs d'etat mutable partage\n"}, "Sujets Avancs -> Empaquetage et Distribution": {"id": "advanced-bundling-packaging", "content": "# Empaquetage et distribution\n\nHemlock fournit des outils integres pour regrouper des projets multi-fichiers en fichiers distribuables uniques et creer des executables autonomes.\n\n## Vue d'ensemble\n\n| Commande | Sortie | Cas d'utilisation |\n|----------|--------|-------------------|\n| `--bundle` | `.hmlc` ou `.hmlb` | Distribuer du bytecode (necessite Hemlock pour executer) |\n| `--package` | Executable | Binaire autonome (sans dependances) |\n| `--compile` | `.hmlc` | Compiler un fichier unique (pas de resolution des imports) |\n\n## Regroupement (Bundling)\n\nLe bundler resout toutes les instructions `import` depuis un point d'entree et les aplatit en un seul fichier.\n\n### Utilisation de base\n\n```bash\n# Regrouper app.hml et tous ses imports dans app.hmlc\nhemlock --bundle app.hml\n\n# Specifier le chemin de sortie\nhemlock --bundle app.hml -o dist/app.hmlc\n\n# Creer un bundle compresse (.hmlb) - taille de fichier plus petite\nhemlock --bundle app.hml --compress -o app.hmlb\n\n# Sortie verbeuse (montre les modules resolus)\nhemlock --bundle app.hml --verbose\n```\n\n### Formats de sortie\n\n**`.hmlc` (Non compresse)**\n- Format AST serialise\n- Rapide a charger et executer\n- Format de sortie par defaut\n\n**`.hmlb` (Compresse)**\n- `.hmlc` compresse avec zlib\n- Taille de fichier plus petite (reduction typique de 50-70%)\n- Demarrage legerement plus lent du a la decompression\n\n### Executer des fichiers regroupes\n\n```bash\n# Executer un bundle non compresse\nhemlock app.hmlc\n\n# Executer un bundle compresse\nhemlock app.hmlb\n\n# Passer des arguments\nhemlock app.hmlc arg1 arg2\n```\n\n### Exemple : Projet multi-modules\n\n```\nmyapp/\n main.hml\n lib/\n    math.hml\n    utils.hml\n config.hml\n```\n\n```hemlock\n// main.hml\nimport { add, multiply } from \"./lib/math.hml\";\nimport { log } from \"./lib/utils.hml\";\nimport { VERSION } from \"./config.hml\";\n\nlog(`App v${VERSION}`);\nprint(add(2, 3));\n```\n\n```bash\nhemlock --bundle myapp/main.hml -o myapp.hmlc\nhemlock myapp.hmlc  # S'execute avec toutes les dependances incluses\n```\n\n### Imports stdlib\n\nLe bundler resout automatiquement les imports `@stdlib/` :\n\n```hemlock\nimport { HashMap } from \"@stdlib/collections\";\nimport { now } from \"@stdlib/time\";\n```\n\nQuand ils sont regroupes, les modules stdlib sont inclus dans la sortie.\n\n## Empaquetage (Packaging)\n\nL'empaquetage cree un executable autonome en integrant le bytecode regroupe dans une copie de l'interpreteur Hemlock.\n\n### Utilisation de base\n\n```bash\n# Creer un executable depuis app.hml\nhemlock --package app.hml\n\n# Specifier le nom de sortie\nhemlock --package app.hml -o myapp\n\n# Ignorer la compression (demarrage plus rapide, fichier plus gros)\nhemlock --package app.hml --no-compress\n\n# Sortie verbeuse\nhemlock --package app.hml --verbose\n```\n\n### Executer des executables empaquetes\n\n```bash\n# L'executable empaquete s'execute directement\n./myapp\n\n# Les arguments sont passes au script\n./myapp arg1 arg2\n```\n\n### Format de package\n\nLes executables empaquetes utilisent le format HMLP :\n\n```\n[binaire hemlock][payload HMLB/HMLC][payload_size:u64][magic HMLP:u32]\n```\n\nQuand un executable empaquete s'execute :\n1. Il verifie s'il y a un payload integre a la fin du fichier\n2. S'il est trouve, il decompresse et execute le payload\n3. S'il n'est pas trouve, il se comporte comme un interpreteur Hemlock normal\n\n### Options de compression\n\n| Drapeau | Format | Demarrage | Taille |\n|---------|--------|-----------|--------|\n| (defaut) | HMLB | Normal | Plus petit |\n| `--no-compress` | HMLC | Plus rapide | Plus grand |\n\nPour les outils CLI ou le temps de demarrage compte, utilisez `--no-compress`.\n\n## Inspecter les bundles\n\nUtilisez `--info` pour inspecter les fichiers regroupes ou compiles :\n\n```bash\nhemlock --info app.hmlc\n```\n\nSortie :\n```\n=== Info fichier : app.hmlc ===\nTaille : 12847 octets\nFormat : HMLC (AST compile)\nVersion : 1\nDrapeaux : 0x0001 [DEBUG]\nChaines : 42\nInstructions : 156\n```\n\n```bash\nhemlock --info app.hmlb\n```\n\nSortie :\n```\n=== Info fichier : app.hmlb ===\nTaille : 5234 octets\nFormat : HMLB (bundle compresse)\nVersion : 1\nNon compresse : 12847 octets\nCompresse : 5224 octets\nRatio : reduction de 59.3%\n```\n\n## Compilation native\n\nPour de vrais executables natifs (pas d'interpreteur), utilisez le compilateur Hemlock :\n\n```bash\n# Compiler en executable natif via C\nhemlockc app.hml -o app\n\n# Garder le code C genere\nhemlockc app.hml -o app --keep-c\n\n# Emettre uniquement le C (ne pas compiler)\nhemlockc app.hml -c -o app.c\n\n# Niveau d'optimisation\nhemlockc app.hml -o app -O2\n```\n\nLe compilateur genere du code C et invoque GCC pour produire un binaire natif. Cela necessite :\n- La bibliotheque runtime Hemlock (`libhemlock_runtime`)\n- Un compilateur C (GCC par defaut)\n\n### Options du compilateur\n\n| Option | Description |\n|--------|-------------|\n| `-o <fichier>` | Nom de l'executable de sortie |\n| `-c` | Emettre uniquement le code C |\n| `--emit-c <fichier>` | Ecrire le C dans le fichier specifie |\n| `-k, --keep-c` | Garder le C genere apres compilation |\n| `-O<niveau>` | Niveau d'optimisation (0-3) |\n| `--cc <chemin>` | Compilateur C a utiliser |\n| `--runtime <chemin>` | Chemin vers la bibliotheque runtime |\n| `-v, --verbose` | Sortie verbeuse |\n\n## Comparaison\n\n| Approche | Portabilite | Demarrage | Taille | Dependances |\n|----------|-------------|-----------|--------|-------------|\n| `.hml` | Source uniquement | Temps d'analyse | Plus petit | Hemlock |\n| `.hmlc` | Hemlock uniquement | Rapide | Petit | Hemlock |\n| `.hmlb` | Hemlock uniquement | Rapide | Plus petit | Hemlock |\n| `--package` | Autonome | Rapide | Plus grand | Aucune |\n| `hemlockc` | Natif | Plus rapide | Variable | Libs runtime |\n\n## Bonnes pratiques\n\n1. **Developpement** : Executez les fichiers `.hml` directement pour une iteration rapide\n2. **Distribution (avec Hemlock)** : Regroupez avec `--compress` pour des fichiers plus petits\n3. **Distribution (autonome)** : Empaquetez pour un deploiement sans dependances\n4. **Performance critique** : Utilisez `hemlockc` pour la compilation native\n\n## Depannage\n\n### \"Cannot find stdlib\" (Impossible de trouver la stdlib)\n\nLe bundler cherche la stdlib dans :\n1. `./stdlib` (relatif a l'executable)\n2. `../stdlib` (relatif a l'executable)\n3. `/usr/local/lib/hemlock/stdlib`\n\nAssurez-vous que Hemlock est correctement installe ou executez depuis le repertoire source.\n\n### Dependances circulaires\n\n```\nErreur : Dependance circulaire detectee lors du chargement de 'path/to/module.hml'\n```\n\nRefactorisez vos imports pour casser le cycle. Considerez l'utilisation d'un module partage pour les types communs.\n\n### Grande taille de package\n\n- Utilisez la compression par defaut (n'utilisez pas `--no-compress`)\n- La taille empaquetee inclut l'interpreteur complet (~500Ko-1Mo de base)\n- Pour une taille minimale, utilisez `hemlockc` pour la compilation native\n"}, "Sujets Avancs -> Excution de Commandes": {"id": "advanced-command-execution", "content": "# Execution de commandes dans Hemlock\n\nHemlock fournit la **fonction integree `exec()`** pour executer des commandes shell et capturer leur sortie.\n\n## Table des matieres\n\n- [Vue d'ensemble](#vue-densemble)\n- [La fonction exec()](#la-fonction-exec)\n- [Objet resultat](#objet-resultat)\n- [Utilisation de base](#utilisation-de-base)\n- [Exemples avances](#exemples-avances)\n- [Gestion des erreurs](#gestion-des-erreurs)\n- [Details d'implementation](#details-dimplementation)\n- [Considerations de securite](#considerations-de-securite)\n- [Limitations](#limitations)\n- [Cas d'utilisation](#cas-dutilisation)\n- [Bonnes pratiques](#bonnes-pratiques)\n- [Exemples complets](#exemples-complets)\n\n## Vue d'ensemble\n\nLa fonction `exec()` permet aux programmes Hemlock de :\n- Executer des commandes shell\n- Capturer la sortie standard (stdout)\n- Verifier les codes de sortie\n- Utiliser les fonctionnalites du shell (pipes, redirections, etc.)\n- S'integrer avec les utilitaires systeme\n\n**Important :** Les commandes sont executees via `/bin/sh`, donnant un acces complet aux fonctionnalites du shell mais introduisant aussi des considerations de securite.\n\n## La fonction exec()\n\n### Signature\n\n```hemlock\nexec(command: string): object\n```\n\n**Parametres :**\n- `command` (string) - Commande shell a executer\n\n**Retourne :** Un objet avec deux champs :\n- `output` (string) - La sortie stdout de la commande\n- `exit_code` (i32) - Le code de sortie de la commande\n\n### Exemple de base\n\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n```\n\n## Objet resultat\n\nL'objet retourne par `exec()` a la structure suivante :\n\n```hemlock\n{\n    output: string,      // Stdout de la commande (sortie capturee)\n    exit_code: i32       // Statut de sortie du processus (0 = succes)\n}\n```\n\n### Champ output\n\nContient tout le texte ecrit sur stdout par la commande.\n\n**Proprietes :**\n- Chaine vide si la commande ne produit pas de sortie\n- Inclut les retours a la ligne et espaces tels quels\n- La sortie multi-lignes est preservee\n- Pas de limite de taille (allouee dynamiquement)\n\n**Exemples :**\n```hemlock\nlet r1 = exec(\"echo test\");\nprint(r1.output);  // \"test\\n\"\n\nlet r2 = exec(\"ls\");\nprint(r2.output);  // Listing du repertoire avec retours a la ligne\n\nlet r3 = exec(\"true\");\nprint(r3.output);  // \"\" (chaine vide)\n```\n\n### Champ exit_code\n\nLe code de sortie de la commande.\n\n**Valeurs :**\n- `0` indique typiquement le succes\n- `1-255` indiquent des erreurs (la convention varie selon la commande)\n- `-1` si la commande n'a pas pu etre executee ou s'est terminee anormalement\n\n**Exemples :**\n```hemlock\nlet r1 = exec(\"true\");\nprint(r1.exit_code);  // 0 (succes)\n\nlet r2 = exec(\"false\");\nprint(r2.exit_code);  // 1 (echec)\n\nlet r3 = exec(\"ls /nonexistent\");\nprint(r3.exit_code);  // 2 (fichier non trouve, varie selon la commande)\n```\n\n## Utilisation de base\n\n### Commande simple\n\n```hemlock\nlet r = exec(\"ls -la\");\nprint(r.output);\nprint(\"Code de sortie : \" + typeof(r.exit_code));\n```\n\n### Verification du statut de sortie\n\n```hemlock\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Trouve : \" + r.output);\n} else {\n    print(\"Pattern non trouve\");\n}\n```\n\n### Commandes avec pipes\n\n```hemlock\nlet r = exec(\"ps aux | grep hemlock\");\nprint(r.output);\n```\n\n### Commandes multiples\n\n```hemlock\nlet r = exec(\"cd /tmp && ls -la\");\nprint(r.output);\n```\n\n### Substitution de commandes\n\n```hemlock\nlet r = exec(\"echo $(date)\");\nprint(r.output);  // Date actuelle\n```\n\n## Exemples avances\n\n### Gestion des echecs\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\nif (r.exit_code != 0) {\n    print(\"Commande echouee avec le code : \" + typeof(r.exit_code));\n    print(\"Sortie d'erreur : \" + r.output);  // Note : stderr non capture\n}\n```\n\n### Traitement de sortie multi-lignes\n\n```hemlock\nlet r = exec(\"cat file.txt\");\nlet lines = r.output.split(\"\\n\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Ligne \" + typeof(i) + \" : \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### Chainage de commandes\n\n**Avec && (ET) :**\n```hemlock\nlet r1 = exec(\"mkdir -p /tmp/test && touch /tmp/test/file.txt\");\nif (r1.exit_code == 0) {\n    print(\"Configuration terminee\");\n}\n```\n\n**Avec || (OU) :**\n```hemlock\nlet r = exec(\"command1 || command2\");\n// Execute command2 seulement si command1 echoue\n```\n\n**Avec ; (sequence) :**\n```hemlock\nlet r = exec(\"command1; command2\");\n// Execute les deux peu importe le succes/echec\n```\n\n### Utilisation des pipes\n\n```hemlock\nlet r = exec(\"echo 'data' | base64\");\nprint(\"Base64 : \" + r.output);\n```\n\n**Pipelines complexes :**\n```hemlock\nlet r = exec(\"cat /etc/passwd | grep root | cut -d: -f1\");\nprint(r.output);\n```\n\n### Patterns de codes de sortie\n\nDifferents codes de sortie indiquent differentes conditions :\n\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"Le fichier existe\");\n} else if (r.exit_code == 1) {\n    print(\"Le fichier n'existe pas\");\n} else {\n    print(\"Commande test echouee : \" + typeof(r.exit_code));\n}\n```\n\n### Redirections de sortie\n\n```hemlock\n// Rediriger stdout vers un fichier (dans le shell)\nlet r1 = exec(\"echo 'test' > /tmp/output.txt\");\n\n// Rediriger stderr vers stdout (Note : stderr toujours non capture par Hemlock)\nlet r2 = exec(\"command 2>&1\");\n```\n\n### Variables d'environnement\n\n```hemlock\nlet r = exec(\"export VAR=value && echo $VAR\");\nprint(r.output);  // \"value\\n\"\n```\n\n### Changements de repertoire de travail\n\n```hemlock\nlet r = exec(\"cd /tmp && pwd\");\nprint(r.output);  // \"/tmp\\n\"\n```\n\n## Gestion des erreurs\n\n### Quand exec() lance des exceptions\n\nLa fonction `exec()` lance une exception si la commande ne peut pas etre executee :\n\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command_xyz\");\n} catch (e) {\n    print(\"Echec d'execution : \" + e);\n}\n```\n\n**Les exceptions sont lancees quand :**\n- `popen()` echoue (ex. impossible de creer un pipe)\n- Limites de ressources systeme depassees\n- Echecs d'allocation memoire\n\n### Quand exec() NE lance PAS d'exception\n\n```hemlock\n// La commande s'execute mais retourne un code de sortie non nul\nlet r1 = exec(\"false\");\nprint(r1.exit_code);  // 1 (pas une exception)\n\n// La commande ne produit pas de sortie\nlet r2 = exec(\"true\");\nprint(r2.output);  // \"\" (pas une exception)\n\n// Commande non trouvee par le shell\nlet r3 = exec(\"nonexistent_cmd\");\nprint(r3.exit_code);  // 127 (pas une exception)\n```\n\n### Pattern d'execution securisee\n\n```hemlock\nfn safe_exec(command: string) {\n    try {\n        let r = exec(command);\n        if (r.exit_code != 0) {\n            print(\"Attention : Commande echouee avec le code \" + typeof(r.exit_code));\n            return \"\";\n        }\n        return r.output;\n    } catch (e) {\n        print(\"Erreur lors de l'execution de la commande : \" + e);\n        return \"\";\n    }\n}\n\nlet output = safe_exec(\"ls -la\");\n```\n\n## Details d'implementation\n\n### Comment ca fonctionne\n\n**En interne :**\n- Utilise `popen()` pour executer les commandes via `/bin/sh`\n- Capture uniquement stdout (stderr n'est pas capture)\n- Sortie mise en tampon dynamiquement (commence a 4Ko, augmente si necessaire)\n- Statut de sortie extrait avec les macros `WIFEXITED()` et `WEXITSTATUS()`\n- La chaine de sortie est correctement terminee par null\n\n**Flux du processus :**\n1. `popen(command, \"r\")` cree un pipe et fork le processus\n2. Le processus enfant execute `/bin/sh -c \"command\"`\n3. Le parent lit stdout via le pipe dans un tampon croissant\n4. `pclose()` attend l'enfant et retourne le statut de sortie\n5. Le statut de sortie est extrait et stocke dans l'objet resultat\n\n### Considerations de performance\n\n**Couts :**\n- Cree un nouveau processus shell pour chaque appel (~1-5ms de surcharge)\n- Sortie stockee entierement en memoire (pas de streaming)\n- Pas de support du streaming (attend la completion de la commande)\n- Adapte pour les commandes avec des tailles de sortie raisonnables\n\n**Optimisations :**\n- Le tampon commence a 4Ko et double quand il est plein (utilisation memoire efficace)\n- Boucle de lecture unique minimise les appels systeme\n- Pas de copie de chaine supplementaire\n\n**Quand utiliser :**\n- Commandes courtes (< 1 seconde)\n- Taille de sortie moderee (< 10Mo)\n- Operations batch avec des intervalles raisonnables\n\n**Quand NE PAS utiliser :**\n- Daemons ou services de longue duree\n- Commandes produisant des gigaoctets de sortie\n- Traitement de donnees en streaming temps reel\n- Execution haute frequence (> 100 appels/seconde)\n\n## Considerations de securite\n\n### Risque d'injection shell\n\n **CRITIQUE :** Les commandes sont executees par le shell (`/bin/sh`), ce qui signifie que **l'injection shell est possible**.\n\n**Code vulnerable :**\n```hemlock\n// DANGEREUX - NE FAITES PAS CELA\nlet filename = args[1];  // Entree utilisateur\nlet r = exec(\"cat \" + filename);  // Injection shell !\n```\n\n**Attaque :**\n```bash\n./hemlock script.hml \"; rm -rf /; echo pwned\"\n# Execute : cat ; rm -rf /; echo pwned\n```\n\n### Pratiques securisees\n\n**1. Ne jamais utiliser d'entree utilisateur non assainie :**\n```hemlock\n// Mauvais\nlet user_input = args[1];\nlet r = exec(\"process \" + user_input);  // DANGEREUX\n\n// Bon - valider d'abord\nfn is_safe_filename(name: string): bool {\n    // Autoriser uniquement alphanumerique, tiret, underscore, point\n    let i = 0;\n    while (i < name.length) {\n        let c = name[i];\n        if (!(c >= 'a' && c <= 'z') &&\n            !(c >= 'A' && c <= 'Z') &&\n            !(c >= '0' && c <= '9') &&\n            c != '-' && c != '_' && c != '.') {\n            return false;\n        }\n        i = i + 1;\n    }\n    return true;\n}\n\nlet filename = args[1];\nif (is_safe_filename(filename)) {\n    let r = exec(\"cat \" + filename);\n} else {\n    print(\"Nom de fichier invalide\");\n}\n```\n\n**2. Utiliser des listes blanches, pas des listes noires :**\n```hemlock\n// Bon - liste blanche stricte\nlet allowed_commands = [\"status\", \"start\", \"stop\", \"restart\"];\nlet cmd = args[1];\n\nlet found = false;\nfor (let allowed in allowed_commands) {\n    if (cmd == allowed) {\n        found = true;\n        break;\n    }\n}\n\nif (found) {\n    exec(\"service myapp \" + cmd);\n} else {\n    print(\"Commande invalide\");\n}\n```\n\n**3. Echapper les caracteres speciaux :**\n```hemlock\nfn shell_escape(s: string): string {\n    // Echappement simple - entourer de guillemets simples et echapper les guillemets simples\n    let escaped = s.replace_all(\"'\", \"'\\\\''\");\n    return \"'\" + escaped + \"'\";\n}\n\nlet user_file = args[1];\nlet safe = shell_escape(user_file);\nlet r = exec(\"cat \" + safe);\n```\n\n**4. Eviter exec() pour les operations sur fichiers :**\n```hemlock\n// Mauvais - utiliser exec pour les operations sur fichiers\nlet r = exec(\"cat file.txt\");\n\n// Bon - utiliser l'API de fichiers Hemlock\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### Considerations de permissions\n\nLes commandes s'executent avec les memes permissions que le processus Hemlock :\n\n```hemlock\n// Si Hemlock s'execute en root, les commandes exec() s'executent aussi en root !\nlet r = exec(\"rm -rf /important\");  // DANGEREUX si execution en root\n```\n\n**Bonne pratique :** Executez Hemlock avec le minimum de privileges necessaires.\n\n## Limitations\n\n### 1. Pas de capture de stderr\n\nSeul stdout est capture, stderr va au terminal :\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\n// r.output est vide\n// Le message d'erreur apparait sur le terminal, non capture\n```\n\n**Solution de contournement - rediriger stderr vers stdout :**\n```hemlock\nlet r = exec(\"ls /nonexistent 2>&1\");\n// Maintenant les messages d'erreur sont dans r.output\n```\n\n### 2. Pas de streaming\n\nDoit attendre la completion de la commande :\n\n```hemlock\nlet r = exec(\"long_running_command\");\n// Bloque jusqu'a ce que la commande finisse\n// Impossible de traiter la sortie incrementalement\n```\n\n### 3. Pas de timeout\n\nLes commandes peuvent s'executer indefiniment :\n\n```hemlock\nlet r = exec(\"sleep 1000\");\n// Bloque pendant 1000 secondes\n// Pas de moyen de timeout ou annuler\n```\n\n**Solution de contournement - utiliser la commande timeout :**\n```hemlock\nlet r = exec(\"timeout 5 long_command\");\n// Expirera apres 5 secondes\n```\n\n### 4. Pas de gestion des signaux\n\nImpossible d'envoyer des signaux aux commandes en cours d'execution :\n\n```hemlock\nlet r = exec(\"long_command\");\n// Impossible d'envoyer SIGINT, SIGTERM, etc. a la commande\n```\n\n### 5. Pas de controle de processus\n\nImpossible d'interagir avec la commande apres le demarrage :\n\n```hemlock\nlet r = exec(\"interactive_program\");\n// Impossible d'envoyer de l'entree au programme\n// Impossible de controler l'execution\n```\n\n## Cas d'utilisation\n\n### Bons cas d'utilisation\n\n**1. Execution d'utilitaires systeme :**\n```hemlock\nlet r = exec(\"ls -la\");\nlet r = exec(\"grep pattern file.txt\");\nlet r = exec(\"find /path -name '*.txt'\");\n```\n\n**2. Traitement rapide de donnees avec les outils Unix :**\n```hemlock\nlet r = exec(\"cat data.txt | sort | uniq | wc -l\");\nprint(\"Lignes uniques : \" + r.output);\n```\n\n**3. Verification de l'etat systeme :**\n```hemlock\nlet r = exec(\"df -h\");\nprint(\"Utilisation disque :\\n\" + r.output);\n```\n\n**4. Verification d'existence de fichier :**\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"Le fichier existe\");\n}\n```\n\n**5. Generation de rapports :**\n```hemlock\nlet r = exec(\"ps aux | grep myapp | wc -l\");\nlet count = r.output.trim();\nprint(\"Instances en cours : \" + count);\n```\n\n**6. Scripts d'automatisation :**\n```hemlock\nexec(\"git add .\");\nexec(\"git commit -m 'Commit automatique'\");\nlet r = exec(\"git push\");\nif (r.exit_code != 0) {\n    print(\"Push echoue\");\n}\n```\n\n### Non recommande pour\n\n**1. Services de longue duree :**\n```hemlock\n// Mauvais\nlet r = exec(\"nginx\");  // Bloque indefiniment\n```\n\n**2. Commandes interactives :**\n```hemlock\n// Mauvais - impossible de fournir de l'entree\nlet r = exec(\"ssh user@host\");\n```\n\n**3. Commandes produisant d'enormes sorties :**\n```hemlock\n// Mauvais - charge toute la sortie en memoire\nlet r = exec(\"cat 10GB_file.log\");\n```\n\n**4. Streaming temps reel :**\n```hemlock\n// Mauvais - impossible de traiter la sortie incrementalement\nlet r = exec(\"tail -f /var/log/app.log\");\n```\n\n**5. Gestion d'erreurs critique :**\n```hemlock\n// Mauvais - stderr non capture\nlet r = exec(\"critical_operation\");\n// Impossible de voir les messages d'erreur detailles\n```\n\n## Bonnes pratiques\n\n### 1. Toujours verifier les codes de sortie\n\n```hemlock\nlet r = exec(\"important_command\");\nif (r.exit_code != 0) {\n    print(\"Commande echouee !\");\n    // Gerer l'erreur\n}\n```\n\n### 2. Nettoyer la sortie si necessaire\n\n```hemlock\nlet r = exec(\"echo test\");\nlet clean = r.output.trim();  // Supprimer le retour a la ligne final\nprint(clean);  // \"test\" (sans retour a la ligne)\n```\n\n### 3. Valider avant d'executer\n\n```hemlock\nfn is_valid_command(cmd: string): bool {\n    // Valider que la commande est sure\n    return true;  // Votre logique de validation\n}\n\nif (is_valid_command(user_cmd)) {\n    exec(user_cmd);\n}\n```\n\n### 4. Utiliser try/catch pour les operations critiques\n\n```hemlock\ntry {\n    let r = exec(\"critical_command\");\n    if (r.exit_code != 0) {\n        throw \"Commande echouee\";\n    }\n} catch (e) {\n    print(\"Erreur : \" + e);\n    // Nettoyage ou recuperation\n}\n```\n\n### 5. Preferer les APIs Hemlock a exec()\n\n```hemlock\n// Mauvais - utiliser exec pour les operations sur fichiers\nlet r = exec(\"cat file.txt\");\n\n// Bon - utiliser l'API File de Hemlock\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### 6. Capturer stderr si necessaire\n\n```hemlock\n// Rediriger stderr vers stdout\nlet r = exec(\"command 2>&1\");\n// Maintenant r.output contient stdout et stderr\n```\n\n### 7. Utiliser les fonctionnalites du shell judicieusement\n\n```hemlock\n// Utiliser les pipes pour l'efficacite\nlet r = exec(\"cat large.txt | grep pattern | head -n 10\");\n\n// Utiliser la substitution de commandes\nlet r = exec(\"echo Utilisateur actuel : $(whoami)\");\n\n// Utiliser l'execution conditionnelle\nlet r = exec(\"test -f file.txt && cat file.txt\");\n```\n\n## Exemples complets\n\n### Exemple 1 : Collecteur d'informations systeme\n\n```hemlock\nfn get_system_info() {\n    print(\"=== Informations systeme ===\");\n\n    // Nom d'hote\n    let r1 = exec(\"hostname\");\n    print(\"Nom d'hote : \" + r1.output.trim());\n\n    // Uptime\n    let r2 = exec(\"uptime\");\n    print(\"Uptime : \" + r2.output.trim());\n\n    // Utilisation disque\n    let r3 = exec(\"df -h /\");\n    print(\"\\nUtilisation disque :\");\n    print(r3.output);\n\n    // Utilisation memoire\n    let r4 = exec(\"free -h\");\n    print(\"Utilisation memoire :\");\n    print(r4.output);\n}\n\nget_system_info();\n```\n\n### Exemple 2 : Analyseur de logs\n\n```hemlock\nfn analyze_log(logfile: string) {\n    print(\"Analyse du log : \" + logfile);\n\n    // Compter le nombre total de lignes\n    let r1 = exec(\"wc -l \" + logfile);\n    print(\"Lignes totales : \" + r1.output.trim());\n\n    // Compter les erreurs\n    let r2 = exec(\"grep -c ERROR \" + logfile + \" 2>/dev/null\");\n    let errors = r2.output.trim();\n    if (r2.exit_code == 0) {\n        print(\"Erreurs : \" + errors);\n    } else {\n        print(\"Erreurs : 0\");\n    }\n\n    // Compter les avertissements\n    let r3 = exec(\"grep -c WARN \" + logfile + \" 2>/dev/null\");\n    let warnings = r3.output.trim();\n    if (r3.exit_code == 0) {\n        print(\"Avertissements : \" + warnings);\n    } else {\n        print(\"Avertissements : 0\");\n    }\n\n    // Erreurs recentes\n    print(\"\\nErreurs recentes :\");\n    let r4 = exec(\"grep ERROR \" + logfile + \" | tail -n 5\");\n    print(r4.output);\n}\n\nif (args.length < 2) {\n    print(\"Usage : \" + args[0] + \" <logfile>\");\n} else {\n    analyze_log(args[1]);\n}\n```\n\n### Exemple 3 : Assistant Git\n\n```hemlock\nfn git_status() {\n    let r = exec(\"git status --short\");\n    if (r.exit_code != 0) {\n        print(\"Erreur : Pas un depot git\");\n        return;\n    }\n\n    if (r.output == \"\") {\n        print(\"Repertoire de travail propre\");\n    } else {\n        print(\"Modifications :\");\n        print(r.output);\n    }\n}\n\nfn git_quick_commit(message: string) {\n    print(\"Ajout de toutes les modifications...\");\n    let r1 = exec(\"git add -A\");\n    if (r1.exit_code != 0) {\n        print(\"Erreur lors de l'ajout des fichiers\");\n        return;\n    }\n\n    print(\"Commit en cours...\");\n    let safe_msg = message.replace_all(\"'\", \"'\\\\''\");\n    let r2 = exec(\"git commit -m '\" + safe_msg + \"'\");\n    if (r2.exit_code != 0) {\n        print(\"Erreur lors du commit\");\n        return;\n    }\n\n    print(\"Commit reussi\");\n    print(r2.output);\n}\n\n// Utilisation\ngit_status();\nif (args.length > 1) {\n    git_quick_commit(args[1]);\n}\n```\n\n### Exemple 4 : Script de sauvegarde\n\n```hemlock\nfn backup_directory(source: string, dest: string) {\n    print(\"Sauvegarde de \" + source + \" vers \" + dest);\n\n    // Creer le repertoire de sauvegarde\n    let r1 = exec(\"mkdir -p \" + dest);\n    if (r1.exit_code != 0) {\n        print(\"Erreur lors de la creation du repertoire de sauvegarde\");\n        return false;\n    }\n\n    // Creer une archive avec horodatage\n    let r2 = exec(\"date +%Y%m%d_%H%M%S\");\n    let timestamp = r2.output.trim();\n    let backup_file = dest + \"/backup_\" + timestamp + \".tar.gz\";\n\n    print(\"Creation de l'archive : \" + backup_file);\n    let r3 = exec(\"tar -czf \" + backup_file + \" \" + source + \" 2>&1\");\n    if (r3.exit_code != 0) {\n        print(\"Erreur lors de la creation de la sauvegarde :\");\n        print(r3.output);\n        return false;\n    }\n\n    print(\"Sauvegarde terminee avec succes\");\n\n    // Afficher la taille de la sauvegarde\n    let r4 = exec(\"du -h \" + backup_file);\n    print(\"Taille de la sauvegarde : \" + r4.output.trim());\n\n    return true;\n}\n\nif (args.length < 3) {\n    print(\"Usage : \" + args[0] + \" <source> <destination>\");\n} else {\n    backup_directory(args[1], args[2]);\n}\n```\n\n## Resume\n\nLa fonction `exec()` de Hemlock fournit :\n\n-  Execution simple de commandes shell\n-  Capture de sortie (stdout)\n-  Verification du code de sortie\n-  Acces complet aux fonctionnalites du shell (pipes, redirections, etc.)\n-  Integration avec les utilitaires systeme\n\nRappelez-vous :\n- Toujours verifier les codes de sortie\n- Etre conscient des implications de securite (injection shell)\n- Valider les entrees utilisateur avant de les utiliser dans les commandes\n- Preferer les APIs Hemlock a exec() quand c'est possible\n- stderr n'est pas capture (utilisez `2>&1` pour rediriger)\n- Les commandes bloquent jusqu'a completion\n- Utilisez pour les utilitaires courts, pas les services de longue duree\n\n**Liste de verification de securite :**\n-  Ne jamais utiliser d'entree utilisateur non assainie\n-  Valider toutes les entrees\n-  Utiliser des listes blanches pour les commandes\n-  Echapper les caracteres speciaux si necessaire\n-  Executer avec le minimum de privileges\n-  Preferer les APIs Hemlock aux commandes shell\n"}, "Sujets Avancs -> FFI": {"id": "advanced-ffi", "content": "# Interface de fonctions etrangeres (FFI) dans Hemlock\n\nHemlock fournit une **FFI (Foreign Function Interface)** pour appeler des fonctions C depuis des bibliotheques partagees en utilisant libffi, permettant l'integration avec des bibliotheques C existantes et des APIs systeme.\n\n## Table des matieres\n\n- [Vue d'ensemble](#vue-densemble)\n- [Etat actuel](#etat-actuel)\n- [Types supportes](#types-supportes)\n- [Concepts de base](#concepts-de-base)\n- [Exportation de fonctions FFI](#exportation-de-fonctions-ffi)\n- [Cas d'utilisation](#cas-dutilisation)\n- [Developpement futur](#developpement-futur)\n- [Callbacks FFI](#callbacks-ffi)\n- [Structures FFI](#structures-ffi)\n- [Exportation de types struct](#exportation-de-types-struct)\n- [Limitations actuelles](#limitations-actuelles)\n- [Bonnes pratiques](#bonnes-pratiques)\n\n## Vue d'ensemble\n\nL'interface de fonctions etrangeres (FFI) permet aux programmes Hemlock de :\n- Appeler des fonctions C depuis des bibliotheques partagees (.so, .dylib, .dll)\n- Utiliser des bibliotheques C existantes sans ecrire de code wrapper\n- Acceder directement aux APIs systeme\n- S'integrer avec des bibliotheques natives tierces\n- Faire le pont entre Hemlock et les fonctionnalites systeme bas niveau\n\n**Capacites cles :**\n- Chargement dynamique de bibliotheques\n- Liaison de fonctions C\n- Conversion automatique de types entre Hemlock et les types C\n- Support de tous les types primitifs\n- Implementation basee sur libffi pour la portabilite\n\n## Etat actuel\n\nLe support FFI est disponible dans Hemlock avec les fonctionnalites suivantes :\n\n**Implemente :**\n-  Appeler des fonctions C depuis des bibliotheques partagees\n-  Support de tous les types primitifs (entiers, flottants, pointeurs)\n-  Conversion automatique de types\n-  Implementation basee sur libffi\n-  Chargement dynamique de bibliotheques\n-  **Callbacks avec pointeurs de fonction** - Passer des fonctions Hemlock au C\n-  **Exporter des fonctions extern** - Partager des liaisons FFI entre modules\n-  **Passage et retour de structures** - Passer des structures compatibles C par valeur\n-  **Assistants pointeur complets** - Lecture/ecriture de tous les types (i8-i64, u8-u64, f32, f64, ptr)\n-  **Conversion buffer/pointeur** - `buffer_ptr()`, `ptr_to_buffer()`\n-  **Tailles de types FFI** - `ffi_sizeof()` pour les tailles de types sensibles a la plateforme\n-  **Types de plateforme** - Support de `size_t`, `usize`, `isize`, `intptr_t`\n\n**En developpement :**\n-  Assistants de marshaling de chaines\n-  Ameliorations de la gestion des erreurs\n\n**Couverture de tests :**\n- Tests FFI passants incluant les tests de callbacks\n- Appels de fonctions basiques verifies\n- Conversion de types testee\n- Integration callback qsort testee\n\n## Types supportes\n\n### Types primitifs\n\nLes types Hemlock suivants peuvent etre passes depuis/vers les fonctions C :\n\n| Type Hemlock | Type C | Taille | Notes |\n|--------------|--------|--------|-------|\n| `i8` | `int8_t` | 1 octet | Entier signe 8 bits |\n| `i16` | `int16_t` | 2 octets | Entier signe 16 bits |\n| `i32` | `int32_t` | 4 octets | Entier signe 32 bits |\n| `i64` | `int64_t` | 8 octets | Entier signe 64 bits |\n| `u8` | `uint8_t` | 1 octet | Entier non signe 8 bits |\n| `u16` | `uint16_t` | 2 octets | Entier non signe 16 bits |\n| `u32` | `uint32_t` | 4 octets | Entier non signe 32 bits |\n| `u64` | `uint64_t` | 8 octets | Entier non signe 64 bits |\n| `f32` | `float` | 4 octets | Virgule flottante 32 bits |\n| `f64` | `double` | 8 octets | Virgule flottante 64 bits |\n| `ptr` | `void*` | 8 octets | Pointeur brut |\n\n### Conversion de types\n\n**Conversions automatiques :**\n- Entiers Hemlock  Entiers C (avec verification de plage)\n- Flottants Hemlock  Flottants C\n- Pointeurs Hemlock  Pointeurs C\n- Valeurs de retour C  Valeurs Hemlock\n\n**Exemples de correspondances de types :**\n```hemlock\n// Hemlock  C\nlet i: i32 = 42;         //  int32_t (4 octets)\nlet f: f64 = 3.14;       //  double (8 octets)\nlet p: ptr = alloc(64);  //  void* (8 octets)\n\n// C  Hemlock (valeurs de retour)\n// int32_t foo()  i32\n// double bar()  f64\n// void* baz()  ptr\n```\n\n## Concepts de base\n\n### Bibliotheques partagees\n\nFFI fonctionne avec des bibliotheques partagees compilees :\n\n**Linux :** Fichiers `.so`\n```\nlibexample.so\n/usr/lib/libm.so\n```\n\n**macOS :** Fichiers `.dylib`\n```\nlibexample.dylib\n/usr/lib/libSystem.dylib\n```\n\n**Windows :** Fichiers `.dll`\n```\nexample.dll\nkernel32.dll\n```\n\n### Signatures de fonctions\n\nLes fonctions C doivent avoir des signatures connues pour que FFI fonctionne correctement :\n\n```c\n// Exemples de signatures de fonctions C\nint add(int a, int b);\ndouble sqrt(double x);\nvoid* malloc(size_t size);\nvoid free(void* ptr);\n```\n\nCelles-ci peuvent etre appelees depuis Hemlock une fois que la bibliotheque est chargee et que les fonctions sont liees.\n\n### Compatibilite des plateformes\n\nFFI utilise **libffi** pour la portabilite :\n- Fonctionne sur x86, x86-64, ARM, ARM64\n- Gere automatiquement les conventions d'appel\n- Abstrait les details ABI specifiques a la plateforme\n- Supporte Linux, macOS, Windows (avec libffi approprie)\n\n## Exportation de fonctions FFI\n\nLes fonctions FFI declarees avec `extern fn` peuvent etre exportees depuis les modules, vous permettant de creer des wrappers de bibliotheques reutilisables qui peuvent etre partages entre plusieurs fichiers.\n\n### Syntaxe d'exportation de base\n\n```hemlock\n// string_utils.hml - Un module de bibliotheque wrappant les fonctions chaine C\nimport \"libc.so.6\";\n\n// Exporter la fonction extern directement\nexport extern fn strlen(s: string): i32;\nexport extern fn strcmp(s1: string, s2: string): i32;\n\n// Vous pouvez aussi exporter des fonctions wrapper a cote des fonctions extern\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n\nexport fn strings_equal(a: string, b: string): bool {\n    return strcmp(a, b) == 0;\n}\n```\n\n### Importation de fonctions FFI exportees\n\n```hemlock\n// main.hml - Utilisation des fonctions FFI exportees\nimport { strlen, string_length, strings_equal } from \"./string_utils.hml\";\n\nlet msg = \"Hello, World!\";\nprint(strlen(msg));           // 13 - appel extern direct\nprint(string_length(msg));    // 13 - fonction wrapper\n\nprint(strings_equal(\"foo\", \"foo\"));  // true\nprint(strings_equal(\"foo\", \"bar\"));  // false\n```\n\n### Cas d'utilisation pour export extern\n\n**1. Abstraction de plateforme**\n```hemlock\n// platform.hml - Abstraire les differences de plateforme\nimport \"libc.so.6\";  // Linux\n\nexport extern fn getpid(): i32;\nexport extern fn getuid(): i32;\nexport extern fn geteuid(): i32;\n```\n\n**2. Wrappers de bibliotheques**\n```hemlock\n// crypto_lib.hml - Wrapper de fonctions de bibliotheque crypto\nimport \"libcrypto.so\";\n\nexport extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;\nexport extern fn MD5(data: ptr, len: u64, out: ptr): ptr;\n\n// Ajouter des wrappers conviviaux pour Hemlock\nexport fn sha256_string(s: string): string {\n    // Implementation utilisant la fonction extern\n}\n```\n\n**3. Declarations FFI centralisees**\n```hemlock\n// libc.hml - Module central pour les liaisons libc\nimport \"libc.so.6\";\n\n// Fonctions chaine\nexport extern fn strlen(s: string): i32;\nexport extern fn strcpy(dest: ptr, src: string): ptr;\nexport extern fn strcat(dest: ptr, src: string): ptr;\n\n// Fonctions memoire\nexport extern fn malloc(size: u64): ptr;\nexport extern fn realloc(p: ptr, size: u64): ptr;\nexport extern fn calloc(nmemb: u64, size: u64): ptr;\n\n// Fonctions processus\nexport extern fn getpid(): i32;\nexport extern fn getppid(): i32;\nexport extern fn getenv(name: string): ptr;\n```\n\nPuis utiliser dans tout votre projet :\n```hemlock\nimport { strlen, malloc, getpid } from \"./libc.hml\";\n```\n\n### Combinaison avec les exports reguliers\n\nVous pouvez melanger les fonctions extern exportees avec les exports de fonctions regulieres :\n\n```hemlock\n// math_extended.hml\nimport \"libm.so.6\";\n\n// Exporter les fonctions C brutes\nexport extern fn sin(x: f64): f64;\nexport extern fn cos(x: f64): f64;\nexport extern fn tan(x: f64): f64;\n\n// Exporter des fonctions Hemlock qui les utilisent\nexport fn deg_to_rad(degrees: f64): f64 {\n    return degrees * 3.14159265359 / 180.0;\n}\n\nexport fn sin_degrees(degrees: f64): f64 {\n    return sin(deg_to_rad(degrees));\n}\n```\n\n### Bibliotheques specifiques a la plateforme\n\nLors de l'exportation de fonctions extern, rappelez-vous que les noms de bibliotheques different selon la plateforme :\n\n```hemlock\n// Pour Linux\nimport \"libc.so.6\";\n\n// Pour macOS (approche differente necessaire)\nimport \"libSystem.B.dylib\";\n```\n\nActuellement, la syntaxe `import \"library\"` de Hemlock utilise des chemins de bibliotheques statiques, donc des modules specifiques a la plateforme peuvent etre necessaires pour le code FFI multiplateforme.\n\n## Cas d'utilisation\n\n### 1. Bibliotheques systeme\n\nAcces aux fonctions de la bibliotheque C standard :\n\n**Fonctions mathematiques :**\n```hemlock\n// Appeler sqrt depuis libm\nlet result = sqrt(16.0);  // 4.0\n```\n\n**Allocation memoire :**\n```hemlock\n// Appeler malloc/free depuis libc\nlet ptr = malloc(1024);\nfree(ptr);\n```\n\n### 2. Bibliotheques tierces\n\nUtiliser des bibliotheques C existantes :\n\n**Exemple : Traitement d'images**\n```hemlock\n// Charger libpng ou libjpeg\n// Traiter des images en utilisant les fonctions de la bibliotheque C\n```\n\n**Exemple : Cryptographie**\n```hemlock\n// Utiliser OpenSSL ou libsodium\n// Chiffrement/dechiffrement via FFI\n```\n\n### 3. APIs systeme\n\nAppels systeme directs :\n\n**Exemple : APIs POSIX**\n```hemlock\n// Appeler getpid, getuid, etc.\n// Acces aux fonctionnalites systeme bas niveau\n```\n\n### 4. Code critique en performance\n\nAppeler des implementations C optimisees :\n\n```hemlock\n// Utiliser des bibliotheques C hautement optimisees\n// Operations SIMD, code vectorise\n// Fonctions accelerees par le materiel\n```\n\n### 5. Acces au materiel\n\nInterface avec les bibliotheques materielles :\n\n```hemlock\n// Controle GPIO sur systemes embarques\n// Communication avec peripheriques USB\n// Acces au port serie\n```\n\n### 6. Integration de code legacy\n\nReutiliser des bases de code C existantes :\n\n```hemlock\n// Appeler des fonctions depuis des applications C legacy\n// Migrer progressivement vers Hemlock\n// Preserver le code C fonctionnel\n```\n\n## Developpement futur\n\n### Fonctionnalites prevues\n\n**1. Support des structures**\n```hemlock\n// Futur : Passer/retourner des structures C\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\nlet p = Point { x: 1.0, y: 2.0 };\nc_function_with_struct(p);\n```\n\n**2. Gestion des tableaux/tampons**\n```hemlock\n// Futur : Meilleur passage de tableaux\nlet arr = [1, 2, 3, 4, 5];\nprocess_array(arr);  // Passer a une fonction C\n```\n\n**3. Callbacks avec pointeurs de fonction**  (Implemente !)\n```hemlock\n// Passer des fonctions Hemlock au C comme callbacks\nfn my_compare(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    return va - vb;\n}\n\n// Creer un pointeur de fonction appelable depuis C\nlet cmp = callback(my_compare, [\"ptr\", \"ptr\"], \"i32\");\n\n// Utiliser avec qsort ou toute fonction C attendant un callback\nqsort(arr, count, elem_size, cmp);\n\n// Nettoyer quand termine\ncallback_free(cmp);\n```\n\n**4. Marshaling de chaines**\n```hemlock\n// Futur : Conversion automatique de chaines\nlet s = \"hello\";\nc_string_function(s);  // Auto-conversion en chaine C\n```\n\n**5. Gestion des erreurs**\n```hemlock\n// Futur : Meilleur rapport d'erreurs\ntry {\n    let result = risky_c_function();\n} catch (e) {\n    print(\"Erreur FFI : \" + e);\n}\n```\n\n**6. Securite des types**\n```hemlock\n// Futur : Annotations de types pour FFI\n@ffi(\"libm.so\")\nfn sqrt(x: f64): f64;\n\nlet result = sqrt(16.0);  // Verifie au niveau des types\n```\n\n### Fonctionnalites\n\n**v1.0 :**\n-  FFI basique avec types primitifs\n-  Chargement dynamique de bibliotheques\n-  Appels de fonctions\n-  Support des callbacks via closures libffi\n\n**Futur :**\n- Support des structures\n- Ameliorations de la gestion des tableaux\n- Generation automatique de liaisons\n\n## Callbacks FFI\n\nHemlock supporte le passage de fonctions au code C comme callbacks en utilisant les closures libffi. Cela permet l'integration avec les APIs C qui attendent des pointeurs de fonction, comme `qsort`, les boucles d'evenements et les bibliotheques basees sur callbacks.\n\n### Creation de callbacks\n\nUtilisez `callback()` pour creer un pointeur de fonction appelable depuis C a partir d'une fonction Hemlock :\n\n```hemlock\n// callback(function, param_types, return_type) -> ptr\nlet cb = callback(my_function, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n**Parametres :**\n- `function` : Une fonction Hemlock a wrapper\n- `param_types` : Tableau de chaines de noms de types (ex. `[\"ptr\", \"i32\"]`)\n- `return_type` : Chaine de type de retour (ex. `\"i32\"`, `\"void\"`)\n\n**Types de callback supportes :**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - Entiers signes\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - Entiers non signes\n- `\"f32\"`, `\"f64\"` - Virgule flottante\n- `\"ptr\"` - Pointeur\n- `\"void\"` - Pas de valeur de retour\n- `\"bool\"` - Booleen\n\n### Exemple : qsort\n\n```hemlock\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// Fonction de comparaison pour entiers (ordre croissant)\nfn compare_ints(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va < vb) { return -1; }\n    if (va > vb) { return 1; }\n    return 0;\n}\n\n// Allouer un tableau de 5 entiers\nlet arr = alloc(20);  // 5 * 4 octets\nptr_write_i32(arr, 5);\nptr_write_i32(ptr_offset(arr, 1, 4), 2);\nptr_write_i32(ptr_offset(arr, 2, 4), 8);\nptr_write_i32(ptr_offset(arr, 3, 4), 1);\nptr_write_i32(ptr_offset(arr, 4, 4), 9);\n\n// Creer le callback et trier\nlet cmp = callback(compare_ints, [\"ptr\", \"ptr\"], \"i32\");\nqsort(arr, 5, 4, cmp);\n\n// Le tableau est maintenant trie : [1, 2, 5, 8, 9]\n\n// Nettoyer\ncallback_free(cmp);\nfree(arr);\n```\n\n### Fonctions d'assistance pour pointeurs\n\nHemlock fournit des fonctions d'assistance completes pour travailler avec les pointeurs bruts. Celles-ci sont essentielles pour les callbacks FFI et la manipulation directe de memoire.\n\n#### Assistants pour types entiers\n\n| Fonction | Description |\n|----------|-------------|\n| `ptr_deref_i8(ptr)` | Dereferencer pointeur, lire i8 |\n| `ptr_deref_i16(ptr)` | Dereferencer pointeur, lire i16 |\n| `ptr_deref_i32(ptr)` | Dereferencer pointeur, lire i32 |\n| `ptr_deref_i64(ptr)` | Dereferencer pointeur, lire i64 |\n| `ptr_deref_u8(ptr)` | Dereferencer pointeur, lire u8 |\n| `ptr_deref_u16(ptr)` | Dereferencer pointeur, lire u16 |\n| `ptr_deref_u32(ptr)` | Dereferencer pointeur, lire u32 |\n| `ptr_deref_u64(ptr)` | Dereferencer pointeur, lire u64 |\n| `ptr_write_i8(ptr, value)` | Ecrire i8 a l'emplacement pointeur |\n| `ptr_write_i16(ptr, value)` | Ecrire i16 a l'emplacement pointeur |\n| `ptr_write_i32(ptr, value)` | Ecrire i32 a l'emplacement pointeur |\n| `ptr_write_i64(ptr, value)` | Ecrire i64 a l'emplacement pointeur |\n| `ptr_write_u8(ptr, value)` | Ecrire u8 a l'emplacement pointeur |\n| `ptr_write_u16(ptr, value)` | Ecrire u16 a l'emplacement pointeur |\n| `ptr_write_u32(ptr, value)` | Ecrire u32 a l'emplacement pointeur |\n| `ptr_write_u64(ptr, value)` | Ecrire u64 a l'emplacement pointeur |\n\n#### Assistants pour types flottants\n\n| Fonction | Description |\n|----------|-------------|\n| `ptr_deref_f32(ptr)` | Dereferencer pointeur, lire f32 (float) |\n| `ptr_deref_f64(ptr)` | Dereferencer pointeur, lire f64 (double) |\n| `ptr_write_f32(ptr, value)` | Ecrire f32 a l'emplacement pointeur |\n| `ptr_write_f64(ptr, value)` | Ecrire f64 a l'emplacement pointeur |\n\n#### Assistants pour types pointeur\n\n| Fonction | Description |\n|----------|-------------|\n| `ptr_deref_ptr(ptr)` | Dereferencer pointeur-vers-pointeur |\n| `ptr_write_ptr(ptr, value)` | Ecrire pointeur a l'emplacement pointeur |\n| `ptr_offset(ptr, index, size)` | Calculer offset : `ptr + index * size` |\n| `ptr_read_i32(ptr)` | Lire i32 a travers pointeur-vers-pointeur (pour callbacks qsort) |\n| `ptr_null()` | Obtenir une constante pointeur null |\n\n#### Assistants de conversion de buffer\n\n| Fonction | Description |\n|----------|-------------|\n| `buffer_ptr(buffer)` | Obtenir le pointeur brut depuis un buffer |\n| `ptr_to_buffer(ptr, size)` | Copier les donnees depuis un pointeur dans un nouveau buffer |\n\n#### Fonctions utilitaires FFI\n\n| Fonction | Description |\n|----------|-------------|\n| `ffi_sizeof(type_name)` | Obtenir la taille en octets d'un type FFI |\n\n**Noms de types supportes pour `ffi_sizeof` :**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - Entiers signes (1, 2, 4, 8 octets)\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - Entiers non signes (1, 2, 4, 8 octets)\n- `\"f32\"`, `\"f64\"` - Flottants (4, 8 octets)\n- `\"ptr\"` - Pointeur (8 octets sur 64 bits)\n- `\"size_t\"`, `\"usize\"` - Type de taille dependant de la plateforme\n- `\"intptr_t\"`, `\"isize\"` - Type de pointeur signe dependant de la plateforme\n\n#### Exemple : Travailler avec differents types\n\n```hemlock\nlet p = alloc(64);\n\n// Ecrire et lire des entiers\nptr_write_i8(p, 42);\nprint(ptr_deref_i8(p));  // 42\n\nptr_write_i64(ptr_offset(p, 1, 8), 9000000000);\nprint(ptr_deref_i64(ptr_offset(p, 1, 8)));  // 9000000000\n\n// Ecrire et lire des flottants\nptr_write_f64(p, 3.14159);\nprint(ptr_deref_f64(p));  // 3.14159\n\n// Pointeur-vers-pointeur\nlet inner = alloc(4);\nptr_write_i32(inner, 999);\nptr_write_ptr(p, inner);\nlet retrieved = ptr_deref_ptr(p);\nprint(ptr_deref_i32(retrieved));  // 999\n\n// Obtenir les tailles de types\nprint(ffi_sizeof(\"i64\"));  // 8\nprint(ffi_sizeof(\"ptr\"));  // 8 (sur 64 bits)\n\n// Conversion de buffer\nlet buf = buffer(64);\nptr_write_i32(buffer_ptr(buf), 12345);\nprint(ptr_deref_i32(buffer_ptr(buf)));  // 12345\n\nfree(inner);\nfree(p);\n```\n\n### Liberation des callbacks\n\n**Important :** Toujours liberer les callbacks quand ils ne sont plus necessaires pour eviter les fuites memoire :\n\n```hemlock\nlet cb = callback(my_fn, [\"ptr\"], \"void\");\n// ... utiliser le callback ...\ncallback_free(cb);  // Liberer quand termine\n```\n\nLes callbacks sont aussi automatiquement liberes quand le programme se termine.\n\n### Closures dans les callbacks\n\nLes callbacks capturent leur environnement de closure, donc ils peuvent acceder aux variables de la portee externe :\n\n```hemlock\nlet multiplier = 10;\n\nfn scale(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    // Peut acceder a 'multiplier' depuis la portee externe\n    return (va * multiplier) - (vb * multiplier);\n}\n\nlet cmp = callback(scale, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n### Securite des threads\n\nLes invocations de callbacks sont serialisees avec un mutex pour assurer la securite des threads, car l'interpreteur Hemlock n'est pas entierement thread-safe. Cela signifie :\n- Un seul callback peut s'executer a la fois\n- Sur pour utiliser avec les bibliotheques C multi-threadees\n- Peut impacter les performances si les callbacks sont appeles tres frequemment depuis plusieurs threads\n\n### Gestion des erreurs dans les callbacks\n\nLes exceptions lancees dans les callbacks ne peuvent pas se propager au code C. A la place :\n- Un avertissement est affiche sur stderr\n- Le callback retourne une valeur par defaut (0 ou NULL)\n- L'exception est enregistree mais pas propagee\n\n```hemlock\nfn risky_callback(a: ptr): i32 {\n    throw \"Quelque chose s'est mal passe\";  // Avertissement affiche, retourne 0\n}\n```\n\nPour une gestion des erreurs robuste, validez les entrees et evitez de lancer dans les callbacks.\n\n## Structures FFI\n\nHemlock supporte le passage de structures par valeur aux fonctions C. Les types struct sont automatiquement enregistres pour FFI quand vous les definissez avec des annotations de types.\n\n### Definition de structures compatibles FFI\n\nUne structure est compatible FFI quand tous les champs ont des annotations de types explicites utilisant des types compatibles FFI :\n\n```hemlock\n// Structure compatible FFI\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\n// Structure compatible FFI avec plusieurs types de champs\ndefine Rectangle {\n    top_left: Point,      // Structure imbriquee\n    width: f64,\n    height: f64,\n}\n\n// NON compatible FFI (champ sans annotation de type)\ndefine DynamicObject {\n    name,                 // Pas de type - non utilisable en FFI\n    value,\n}\n```\n\n### Utilisation des structures en FFI\n\nDeclarez des fonctions extern qui utilisent des types struct :\n\n```hemlock\n// Definir le type struct\ndefine Vector2D {\n    x: f64,\n    y: f64,\n}\n\n// Importer la bibliotheque C\nimport \"libmath.so\";\n\n// Declarer une fonction extern qui prend/retourne des structures\nextern fn vector_add(a: Vector2D, b: Vector2D): Vector2D;\nextern fn vector_length(v: Vector2D): f64;\n\n// Utiliser naturellement\nlet a: Vector2D = { x: 3.0, y: 0.0 };\nlet b: Vector2D = { x: 0.0, y: 4.0 };\nlet result = vector_add(a, b);\nprint(result.x);  // 3.0\nprint(result.y);  // 4.0\n\nlet len = vector_length(result);\nprint(len);       // 5.0\n```\n\n### Types de champs supportes\n\nLes champs de structure doivent utiliser ces types compatibles FFI :\n\n| Type Hemlock | Type C | Taille |\n|--------------|--------|--------|\n| `i8` | `int8_t` | 1 octet |\n| `i16` | `int16_t` | 2 octets |\n| `i32` | `int32_t` | 4 octets |\n| `i64` | `int64_t` | 8 octets |\n| `u8` | `uint8_t` | 1 octet |\n| `u16` | `uint16_t` | 2 octets |\n| `u32` | `uint32_t` | 4 octets |\n| `u64` | `uint64_t` | 8 octets |\n| `f32` | `float` | 4 octets |\n| `f64` | `double` | 8 octets |\n| `ptr` | `void*` | 8 octets |\n| `string` | `char*` | 8 octets |\n| `bool` | `int` | variable |\n| Struct imbriquee | struct | variable |\n\n### Disposition des structures\n\nHemlock utilise les regles de disposition native de la plateforme (correspondant a l'ABI C) :\n- Les champs sont alignes selon leur type\n- Du padding est insere si necessaire\n- La taille totale est paddee pour aligner le plus grand membre\n\n```hemlock\n// Exemple : disposition compatible C\ndefine Mixed {\n    a: i8,    // offset 0, taille 1\n              // 3 octets de padding\n    b: i32,   // offset 4, taille 4\n}\n// Taille totale : 8 octets (avec padding)\n\ndefine Point3D {\n    x: f64,   // offset 0, taille 8\n    y: f64,   // offset 8, taille 8\n    z: f64,   // offset 16, taille 8\n}\n// Taille totale : 24 octets (pas de padding necessaire)\n```\n\n### Structures imbriquees\n\nLes structures peuvent contenir d'autres structures :\n\n```hemlock\ndefine Inner {\n    x: i32,\n    y: i32,\n}\n\ndefine Outer {\n    inner: Inner,\n    z: i32,\n}\n\nimport \"mylib.so\";\nextern fn process_nested(data: Outer): i32;\n\nlet obj: Outer = {\n    inner: { x: 1, y: 2 },\n    z: 3,\n};\nlet result = process_nested(obj);\n```\n\n### Valeurs de retour struct\n\nLes fonctions C peuvent retourner des structures :\n\n```hemlock\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\nimport \"libmath.so\";\nextern fn get_origin(): Point;\n\nlet p = get_origin();\nprint(p.x);  // 0.0\nprint(p.y);  // 0.0\n```\n\n### Limitations\n\n- **Les champs de structure doivent avoir des annotations de types** - les champs sans types ne sont pas compatibles FFI\n- **Pas de tableaux dans les structures** - utilisez des pointeurs a la place\n- **Pas d'unions** - seuls les types struct sont supportes\n- **Les callbacks ne peuvent pas retourner de structures** - utilisez des pointeurs pour les valeurs de retour des callbacks\n\n### Exportation de types struct\n\nVous pouvez exporter des definitions de types struct depuis un module en utilisant `export define` :\n\n```hemlock\n// geometry.hml\nexport define Vector2 {\n    x: f32,\n    y: f32,\n}\n\nexport define Rectangle {\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n}\n\nexport fn create_rect(x: f32, y: f32, w: f32, h: f32): Rectangle {\n    return { x: x, y: y, width: w, height: h };\n}\n```\n\n**Important :** Les types struct exportes sont enregistres **globalement** quand le module est charge. Ils deviennent automatiquement disponibles quand vous importez quoi que ce soit du module. Vous n'avez PAS besoin de (et ne pouvez pas) les importer explicitement par nom :\n\n```hemlock\n// main.hml\n\n// BON - les types struct sont auto-disponibles apres tout import du module\nimport { create_rect } from \"./geometry.hml\";\nlet v: Vector2 = { x: 1.0, y: 2.0 };      // Fonctionne - Vector2 est globalement disponible\nlet r: Rectangle = create_rect(0.0, 0.0, 100.0, 50.0);  // Fonctionne\n\n// MAUVAIS - impossible d'importer explicitement les types struct par nom\nimport { Vector2 } from \"./geometry.hml\";  // Erreur : Variable non definie 'Vector2'\n```\n\nCe comportement existe parce que les types struct sont enregistres dans le registre de types global quand le module charge, plutot que d'etre stockes comme valeurs dans l'environnement d'export du module. Le type devient disponible pour tout le code qui importe depuis le module.\n\n## Limitations actuelles\n\nFFI a les limitations suivantes :\n\n**1. Conversion de types manuelle**\n- Doit gerer manuellement les conversions de chaines\n- Pas de conversion automatique Hemlock string  C string\n\n**2. Gestion des erreurs limitee**\n- Rapport d'erreurs basique\n- Les exceptions dans les callbacks ne peuvent pas se propager au C\n\n**3. Chargement manuel de bibliotheques**\n- Doit charger manuellement les bibliotheques\n- Pas de generation automatique de liaisons\n\n**4. Code specifique a la plateforme**\n- Les chemins de bibliotheques different selon la plateforme\n- Doit gerer .so vs .dylib vs .dll\n\n## Bonnes pratiques\n\nBien que la documentation FFI complete soit encore en cours de developpement, voici les bonnes pratiques generales :\n\n### 1. Securite des types\n\n```hemlock\n// Etre explicite sur les types\nlet x: i32 = 42;\nlet result: f64 = c_function(x);\n```\n\n### 2. Gestion memoire\n\n```hemlock\n// Rappelez-vous de liberer la memoire allouee\nlet ptr = c_malloc(1024);\n// ... utiliser ptr\nc_free(ptr);\n```\n\n### 3. Verification des erreurs\n\n```hemlock\n// Verifier les valeurs de retour\nlet result = c_function();\nif (result == null) {\n    print(\"La fonction C a echoue\");\n}\n```\n\n### 4. Compatibilite des plateformes\n\n```hemlock\n// Gerer les differences de plateforme\n// Utiliser les extensions de bibliotheque appropriees (.so, .dylib, .dll)\n```\n\n## Exemples\n\nPour des exemples fonctionnels, referez-vous a :\n- Tests de callbacks : `/tests/ffi_callbacks/` - exemples de callbacks qsort\n- Utilisation FFI de la stdlib : `/stdlib/hash.hml`, `/stdlib/regex.hml`, `/stdlib/crypto.hml`\n- Programmes d'exemple : `/examples/` (si disponible)\n\n## Obtenir de l'aide\n\nFFI est une fonctionnalite plus recente dans Hemlock. Pour les questions ou problemes :\n\n1. Consultez la suite de tests pour des exemples fonctionnels\n2. Referez-vous a la documentation libffi pour les details bas niveau\n3. Signalez les bugs ou demandez des fonctionnalites via les issues du projet\n\n## Resume\n\nLa FFI de Hemlock fournit :\n\n-  Appels de fonctions C depuis des bibliotheques partagees\n-  Support des types primitifs (i8-i64, u8-u64, f32, f64, ptr)\n-  Conversion automatique de types\n-  Portabilite basee sur libffi\n-  Base pour l'integration de bibliotheques natives\n-  **Callbacks avec pointeurs de fonction** - passer des fonctions Hemlock au C\n-  **Export de fonctions extern** - partager des liaisons FFI entre modules\n-  **Passage et retour de structures** - passer des structures compatibles C par valeur\n-  **Export define** - partager des definitions de types struct entre modules (auto-importe globalement)\n-  **Assistants pointeur complets** - lecture/ecriture de tous les types (i8-i64, u8-u64, f32, f64, ptr)\n-  **Conversion buffer/pointeur** - `buffer_ptr()`, `ptr_to_buffer()` pour le marshaling de donnees\n-  **Tailles de types FFI** - `ffi_sizeof()` pour les tailles de types sensibles a la plateforme\n-  **Types de plateforme** - support de `size_t`, `usize`, `isize`, `intptr_t`, `uintptr_t`\n\n**Etat actuel :** FFI completement fonctionnel avec types primitifs, structures, callbacks, exports de modules et fonctions d'assistance pointeur completes\n\n**Futur :** Assistants de marshaling de chaines\n\n**Cas d'utilisation :** Bibliotheques systeme, bibliotheques tierces, qsort, boucles d'evenements, APIs basees sur callbacks, wrappers de bibliotheques reutilisables\n\n## Contribuer\n\nLa documentation FFI est en cours d'expansion. Si vous travaillez avec FFI :\n- Documentez vos cas d'utilisation\n- Partagez du code d'exemple\n- Signalez les problemes ou limitations\n- Suggerez des ameliorations\n\nLe systeme FFI est concu pour etre pratique et sur tout en fournissant un acces bas niveau quand necessaire, suivant la philosophie de Hemlock \"explicite plutot qu'implicite\" et \"unsafe est une fonctionnalite, pas un bug.\"\n"}, "Sujets Avancs -> File IO": {"id": "advanced-file-io", "content": "# E/S de fichiers dans Hemlock\n\nHemlock fournit une **API objet File** pour les operations sur fichiers avec une gestion des erreurs et des ressources appropriee.\n\n## Table des matieres\n\n- [Vue d'ensemble](#vue-densemble)\n- [Ouverture de fichiers](#ouverture-de-fichiers)\n- [Methodes de fichier](#methodes-de-fichier)\n- [Proprietes de fichier](#proprietes-de-fichier)\n- [Gestion des erreurs](#gestion-des-erreurs)\n- [Gestion des ressources](#gestion-des-ressources)\n- [Reference API complete](#reference-api-complete)\n- [Patterns courants](#patterns-courants)\n- [Bonnes pratiques](#bonnes-pratiques)\n\n## Vue d'ensemble\n\nL'API objet File fournit :\n\n- **Gestion explicite des ressources** - Les fichiers doivent etre fermes manuellement\n- **Plusieurs modes d'ouverture** - Lecture, ecriture, ajout, lecture/ecriture\n- **Operations texte et binaires** - Lecture/ecriture de texte et de donnees binaires\n- **Support du positionnement** - Acces aleatoire au sein des fichiers\n- **Messages d'erreur complets** - Rapport d'erreurs contextuel\n\n**Important :** Les fichiers ne sont pas fermes automatiquement. Vous devez appeler `f.close()` pour eviter les fuites de descripteurs de fichiers.\n\n## Ouverture de fichiers\n\nUtilisez `open(path, mode?)` pour ouvrir un fichier :\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");     // Mode lecture (par defaut)\nlet f2 = open(\"output.txt\", \"w\");  // Mode ecriture (tronque)\nlet f3 = open(\"log.txt\", \"a\");     // Mode ajout\nlet f4 = open(\"data.bin\", \"r+\");   // Mode lecture/ecriture\n```\n\n### Modes d'ouverture\n\n| Mode | Description | Le fichier doit exister | Tronque | Position |\n|------|-------------|-------------------------|---------|----------|\n| `\"r\"` | Lecture (par defaut) | Oui | Non | Debut |\n| `\"w\"` | Ecriture | Non (cree) | Oui | Debut |\n| `\"a\"` | Ajout | Non (cree) | Non | Fin |\n| `\"r+\"` | Lecture et ecriture | Oui | Non | Debut |\n| `\"w+\"` | Lecture et ecriture | Non (cree) | Oui | Debut |\n| `\"a+\"` | Lecture et ajout | Non (cree) | Non | Fin |\n\n### Exemples\n\n**Lecture d'un fichier existant :**\n```hemlock\nlet f = open(\"config.json\", \"r\");\n// ou simplement :\nlet f = open(\"config.json\");  // \"r\" est le defaut\n```\n\n**Creation d'un nouveau fichier pour ecriture :**\n```hemlock\nlet f = open(\"output.txt\", \"w\");  // Cree ou tronque\n```\n\n**Ajout a un fichier :**\n```hemlock\nlet f = open(\"log.txt\", \"a\");  // Cree s'il n'existe pas\n```\n\n**Mode lecture et ecriture :**\n```hemlock\nlet f = open(\"data.bin\", \"r+\");  // Fichier existant, peut lire/ecrire\n```\n\n## Methodes de fichier\n\n### Lecture\n\n#### read(size?: i32): string\n\nLire du texte depuis le fichier (parametre size optionnel).\n\n**Sans size (lire tout) :**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet all = f.read();  // Lire depuis la position actuelle jusqu'a EOF\nf.close();\n```\n\n**Avec size (lire des octets specifiques) :**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet chunk = f.read(1024);  // Lire jusqu'a 1024 octets\nlet next = f.read(1024);   // Lire les 1024 octets suivants\nf.close();\n```\n\n**Retourne :** Chaine contenant les donnees lues, ou chaine vide si a EOF\n\n**Exemple - Lecture du fichier entier :**\n```hemlock\nlet f = open(\"poem.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n```\n\n**Exemple - Lecture par morceaux :**\n```hemlock\nlet f = open(\"large.txt\", \"r\");\nwhile (true) {\n    let chunk = f.read(4096);  // Morceaux de 4Ko\n    if (chunk == \"\") { break; }  // EOF atteint\n    process(chunk);\n}\nf.close();\n```\n\n#### read_bytes(size: i32): buffer\n\nLire des donnees binaires (retourne un buffer).\n\n**Parametres :**\n- `size` (i32) - Nombre d'octets a lire\n\n**Retourne :** Buffer contenant les octets lus\n\n```hemlock\nlet f = open(\"image.png\", \"r\");\nlet binary = f.read_bytes(256);  // Lire 256 octets\nprint(binary.length);  // 256 (ou moins si EOF)\n\n// Acceder aux octets individuels\nlet first_byte = binary[0];\nprint(first_byte);\n\nf.close();\n```\n\n**Exemple - Lecture du fichier binaire entier :**\n```hemlock\nlet f = open(\"data.bin\", \"r\");\nlet size = 10240;  // Taille attendue\nlet data = f.read_bytes(size);\nf.close();\n\n// Traiter les donnees binaires\nlet i = 0;\nwhile (i < data.length) {\n    let byte = data[i];\n    // ... traiter l'octet\n    i = i + 1;\n}\n```\n\n### Ecriture\n\n#### write(data: string): i32\n\nEcrire du texte dans le fichier (retourne les octets ecrits).\n\n**Parametres :**\n- `data` (string) - Texte a ecrire\n\n**Retourne :** Nombre d'octets ecrits (i32)\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Ecrit \" + typeof(written) + \" octets\");  // \"Ecrit 14 octets\"\nf.close();\n```\n\n**Exemple - Ecriture de plusieurs lignes :**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Ligne 1\\n\");\nf.write(\"Ligne 2\\n\");\nf.write(\"Ligne 3\\n\");\nf.close();\n```\n\n**Exemple - Ajout au fichier de log :**\n```hemlock\nlet f = open(\"app.log\", \"a\");\nf.write(\"[INFO] Application demarree\\n\");\nf.write(\"[INFO] Utilisateur connecte\\n\");\nf.close();\n```\n\n#### write_bytes(data: buffer): i32\n\nEcrire des donnees binaires (retourne les octets ecrits).\n\n**Parametres :**\n- `data` (buffer) - Donnees binaires a ecrire\n\n**Retourne :** Nombre d'octets ecrits (i32)\n\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Creer des donnees binaires\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\nlet bytes = f.write_bytes(buf);\nprint(\"Ecrit \" + typeof(bytes) + \" octets\");\n\nf.close();\n```\n\n**Exemple - Copie de fichier binaire :**\n```hemlock\nlet src = open(\"input.bin\", \"r\");\nlet dst = open(\"output.bin\", \"w\");\n\nlet data = src.read_bytes(1024);\nwhile (data.length > 0) {\n    dst.write_bytes(data);\n    data = src.read_bytes(1024);\n}\n\nsrc.close();\ndst.close();\n```\n\n### Positionnement\n\n#### seek(position: i32): i32\n\nSe deplacer a une position specifique (retourne la nouvelle position).\n\n**Parametres :**\n- `position` (i32) - Offset en octets depuis le debut du fichier\n\n**Retourne :** Nouvelle position (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Aller a l'octet 100\nf.seek(100);\n\n// Lire depuis la position 100\nlet data = f.read(50);\n\n// Revenir au debut\nf.seek(0);\n\nf.close();\n```\n\n**Exemple - Acces aleatoire :**\n```hemlock\nlet f = open(\"records.dat\", \"r\");\n\n// Lire l'enregistrement a l'offset 1000\nf.seek(1000);\nlet record1 = f.read_bytes(100);\n\n// Lire l'enregistrement a l'offset 2000\nf.seek(2000);\nlet record2 = f.read_bytes(100);\n\nf.close();\n```\n\n#### tell(): i32\n\nObtenir la position actuelle dans le fichier.\n\n**Retourne :** Offset en octets actuel (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet pos1 = f.tell();  // 0 (au debut)\n\nf.read(100);\nlet pos2 = f.tell();  // 100 (apres lecture de 100 octets)\n\nf.seek(500);\nlet pos3 = f.tell();  // 500 (apres positionnement)\n\nf.close();\n```\n\n**Exemple - Mesurer la quantite lue :**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet start = f.tell();\nlet content = f.read();\nlet end = f.tell();\n\nlet bytes_read = end - start;\nprint(\"Lu \" + typeof(bytes_read) + \" octets\");\n\nf.close();\n```\n\n### Fermeture\n\n#### close()\n\nFermer le fichier (idempotent, peut etre appele plusieurs fois).\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n// ... utiliser le fichier\nf.close();\nf.close();  // Sur - pas d'erreur au deuxieme appel\n```\n\n**Notes importantes :**\n- Toujours fermer les fichiers quand termine pour eviter les fuites de descripteurs\n- La fermeture est idempotente - peut etre appelee plusieurs fois en securite\n- Apres fermeture, toutes les autres operations provoqueront une erreur\n- Utilisez des blocs `finally` pour assurer que les fichiers sont fermes meme en cas d'erreurs\n\n## Proprietes de fichier\n\nLes objets File ont trois proprietes en lecture seule :\n\n### path: string\n\nLe chemin de fichier utilise pour ouvrir le fichier.\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);  // \"/path/to/file.txt\"\nf.close();\n```\n\n### mode: string\n\nLe mode avec lequel le fichier a ete ouvert.\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);  // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);  // \"w\"\nf2.close();\n```\n\n### closed: bool\n\nSi le fichier est ferme.\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n**Exemple - Verification si le fichier est ouvert :**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... traiter le contenu\n}\n\nf.close();\n\nif (f.closed) {\n    print(\"Le fichier est maintenant ferme\");\n}\n```\n\n## Gestion des erreurs\n\nToutes les operations sur fichiers incluent des messages d'erreur avec contexte.\n\n### Erreurs courantes\n\n**Fichier non trouve :**\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Erreur : Echec de l'ouverture de 'missing.txt' : Fichier ou repertoire inexistant\n```\n\n**Lecture depuis un fichier ferme :**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Erreur : Impossible de lire depuis le fichier ferme 'data.txt'\n```\n\n**Ecriture dans un fichier en lecture seule :**\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Erreur : Impossible d'ecrire dans le fichier 'readonly.txt' ouvert en mode lecture seule\n```\n\n**Lecture depuis un fichier en ecriture seule :**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.read();\n// Erreur : Impossible de lire depuis le fichier 'output.txt' ouvert en mode ecriture seule\n```\n\n### Utilisation de try/catch\n\n```hemlock\ntry {\n    let f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    f.close();\n    process(content);\n} catch (e) {\n    print(\"Erreur de lecture du fichier : \" + e);\n}\n```\n\n## Gestion des ressources\n\n### Pattern de base\n\nToujours fermer les fichiers explicitement :\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### Avec gestion des erreurs (recommande)\n\nUtilisez `finally` pour assurer que les fichiers sont fermes meme en cas d'erreurs :\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Toujours fermer, meme en cas d'erreur\n}\n```\n\n### Fichiers multiples\n\n```hemlock\nlet src = null;\nlet dst = null;\n\ntry {\n    src = open(\"input.txt\", \"r\");\n    dst = open(\"output.txt\", \"w\");\n\n    let content = src.read();\n    dst.write(content);\n} finally {\n    if (src != null) { src.close(); }\n    if (dst != null) { dst.close(); }\n}\n```\n\n### Pattern de fonction d'aide\n\n```hemlock\nfn with_file(path: string, mode: string, callback) {\n    let f = open(path, mode);\n    try {\n        return callback(f);\n    } finally {\n        f.close();\n    }\n}\n\n// Utilisation :\nwith_file(\"data.txt\", \"r\", fn(f) {\n    return f.read();\n});\n```\n\n## Reference API complete\n\n### Fonctions\n\n| Fonction | Parametres | Retourne | Description |\n|----------|-----------|----------|-------------|\n| `open(path, mode?)` | path: string, mode?: string | File | Ouvrir un fichier (mode par defaut \"r\") |\n\n### Methodes\n\n| Methode | Parametres | Retourne | Description |\n|---------|-----------|----------|-------------|\n| `read(size?)` | size?: i32 | string | Lire du texte (tout ou octets specifiques) |\n| `read_bytes(size)` | size: i32 | buffer | Lire des donnees binaires |\n| `write(data)` | data: string | i32 | Ecrire du texte, retourne les octets ecrits |\n| `write_bytes(data)` | data: buffer | i32 | Ecrire des donnees binaires, retourne les octets ecrits |\n| `seek(position)` | position: i32 | i32 | Aller a la position, retourne la nouvelle position |\n| `tell()` | - | i32 | Obtenir la position actuelle |\n| `close()` | - | null | Fermer le fichier (idempotent) |\n\n### Proprietes (lecture seule)\n\n| Propriete | Type | Description |\n|-----------|------|-------------|\n| `path` | string | Chemin du fichier |\n| `mode` | string | Mode d'ouverture |\n| `closed` | bool | Si le fichier est ferme |\n\n## Patterns courants\n\n### Lecture du fichier entier\n\n```hemlock\nfn read_file(path: string): string {\n    let f = open(path, \"r\");\n    try {\n        return f.read();\n    } finally {\n        f.close();\n    }\n}\n\nlet content = read_file(\"config.json\");\n```\n\n### Ecriture du fichier entier\n\n```hemlock\nfn write_file(path: string, content: string) {\n    let f = open(path, \"w\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\");\n```\n\n### Ajout au fichier\n\n```hemlock\nfn append_file(path: string, content: string) {\n    let f = open(path, \"a\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nappend_file(\"log.txt\", \"[INFO] Evenement survenu\\n\");\n```\n\n### Lecture de lignes\n\n```hemlock\nfn read_lines(path: string) {\n    let f = open(path, \"r\");\n    try {\n        let content = f.read();\n        return content.split(\"\\n\");\n    } finally {\n        f.close();\n    }\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Ligne \" + typeof(i) + \" : \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### Traitement de gros fichiers par morceaux\n\n```hemlock\nfn process_large_file(path: string) {\n    let f = open(path, \"r\");\n    try {\n        while (true) {\n            let chunk = f.read(4096);  // Morceaux de 4Ko\n            if (chunk == \"\") { break; }\n\n            // Traiter le morceau\n            process_chunk(chunk);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n### Copie de fichier binaire\n\n```hemlock\nfn copy_file(src_path: string, dst_path: string) {\n    let src = null;\n    let dst = null;\n\n    try {\n        src = open(src_path, \"r\");\n        dst = open(dst_path, \"w\");\n\n        while (true) {\n            let chunk = src.read_bytes(4096);\n            if (chunk.length == 0) { break; }\n\n            dst.write_bytes(chunk);\n        }\n    } finally {\n        if (src != null) { src.close(); }\n        if (dst != null) { dst.close(); }\n    }\n}\n\ncopy_file(\"input.dat\", \"output.dat\");\n```\n\n### Troncature de fichier\n\n```hemlock\nfn truncate_file(path: string) {\n    let f = open(path, \"w\");  // Le mode \"w\" tronque\n    f.close();\n}\n\ntruncate_file(\"empty_me.txt\");\n```\n\n### Lecture a un offset specifique\n\n```hemlock\nfn read_at_offset(path: string, offset: i32, size: i32): string {\n    let f = open(path, \"r\");\n    try {\n        f.seek(offset);\n        return f.read(size);\n    } finally {\n        f.close();\n    }\n}\n\nlet data = read_at_offset(\"records.dat\", 1000, 100);\n```\n\n### Taille de fichier\n\n```hemlock\nfn file_size(path: string): i32 {\n    let f = open(path, \"r\");\n    try {\n        // Aller a la fin\n        let end = f.seek(999999999);  // Grand nombre\n        f.seek(0);  // Reinitialiser\n        return end;\n    } finally {\n        f.close();\n    }\n}\n\nlet size = file_size(\"data.txt\");\nprint(\"Taille du fichier : \" + typeof(size) + \" octets\");\n```\n\n### Lecture/ecriture conditionnelle\n\n```hemlock\nfn update_file(path: string, condition, new_content: string) {\n    let f = open(path, \"r+\");\n    try {\n        let content = f.read();\n\n        if (condition(content)) {\n            f.seek(0);  // Revenir au debut\n            f.write(new_content);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n## Bonnes pratiques\n\n### 1. Toujours utiliser try/finally\n\n```hemlock\n// Bien\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();\n}\n\n// Mauvais - le fichier pourrait ne pas se fermer en cas d'erreur\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprocess(content);  // Si cela lance, le fichier fuit\nf.close();\n```\n\n### 2. Verifier l'etat du fichier avant les operations\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... utiliser le contenu\n}\n\nf.close();\n```\n\n### 3. Utiliser les modes appropries\n\n```hemlock\n// Lecture seulement ? Utiliser \"r\"\nlet f = open(\"config.json\", \"r\");\n\n// Remplacement complet ? Utiliser \"w\"\nlet f = open(\"output.txt\", \"w\");\n\n// Ajout a la fin ? Utiliser \"a\"\nlet f = open(\"log.txt\", \"a\");\n```\n\n### 4. Gerer les erreurs gracieusement\n\n```hemlock\nfn safe_read_file(path: string): string {\n    try {\n        let f = open(path, \"r\");\n        try {\n            return f.read();\n        } finally {\n            f.close();\n        }\n    } catch (e) {\n        print(\"Attention : Impossible de lire \" + path + \" : \" + e);\n        return \"\";\n    }\n}\n```\n\n### 5. Fermer les fichiers dans l'ordre inverse de l'ouverture\n\n```hemlock\nlet f1 = null;\nlet f2 = null;\nlet f3 = null;\n\ntry {\n    f1 = open(\"file1.txt\", \"r\");\n    f2 = open(\"file2.txt\", \"r\");\n    f3 = open(\"file3.txt\", \"r\");\n\n    // ... utiliser les fichiers\n} finally {\n    // Fermer dans l'ordre inverse\n    if (f3 != null) { f3.close(); }\n    if (f2 != null) { f2.close(); }\n    if (f1 != null) { f1.close(); }\n}\n```\n\n### 6. Eviter de lire entierement les gros fichiers\n\n```hemlock\n// Mauvais pour les gros fichiers\nlet f = open(\"huge.log\", \"r\");\nlet content = f.read();  // Charge le fichier entier en memoire\nf.close();\n\n// Bien - traiter par morceaux\nlet f = open(\"huge.log\", \"r\");\ntry {\n    while (true) {\n        let chunk = f.read(4096);\n        if (chunk == \"\") { break; }\n        process_chunk(chunk);\n    }\n} finally {\n    f.close();\n}\n```\n\n## Resume\n\nL'API E/S de fichiers de Hemlock fournit :\n\n-  Operations sur fichiers simples et explicites\n-  Support texte et binaire\n-  Acces aleatoire avec seek/tell\n-  Messages d'erreur clairs avec contexte\n-  Operation de fermeture idempotente\n\nRappelez-vous :\n- Toujours fermer les fichiers manuellement\n- Utiliser try/finally pour la securite des ressources\n- Choisir les modes d'ouverture appropries\n- Gerer les erreurs gracieusement\n- Traiter les gros fichiers par morceaux\n"}, "Sujets Avancs -> Memory Ownership": {"id": "advanced-memory-ownership", "content": "# Proprit de la Mmoire dans Hemlock\n\n> \"Nous vous donnons les outils pour tre en scurit, mais nous ne vous obligeons pas  les utiliser.\"\n\nCe document dcrit la smantique de proprit de la mmoire dans Hemlock, couvrant  la fois la mmoire gre par le programmeur et les valeurs gres par le runtime.\n\n## Table des Matires\n\n1. [Le Contrat](#le-contrat)\n2. [Mmoire Gre par le Programmeur](#mmoire-gre-par-le-programmeur)\n3. [Valeurs Gres par le Runtime](#valeurs-gres-par-le-runtime)\n4. [Points de Transfert de Proprit](#points-de-transfert-de-proprit)\n5. [Async et Concurrence](#async-et-concurrence)\n6. [Rgles de Mmoire FFI](#rgles-de-mmoire-ffi)\n7. [Scurit des Exceptions](#scurit-des-exceptions)\n8. [Meilleures Pratiques](#meilleures-pratiques)\n\n---\n\n## Le Contrat\n\nHemlock a une division claire de la responsabilit de gestion de la mmoire :\n\n| Type de Mmoire | Gr Par | Mthode de Nettoyage |\n|-----------------|----------|----------------------|\n| Pointeurs bruts (`ptr`) | **Programmeur** | `free(ptr)` |\n| Buffers (`buffer`) | **Programmeur** | `free(buf)` |\n| Strings, Arrays, Objets | **Runtime** | Automatique (comptage de rfrences) |\n| Fonctions, Closures | **Runtime** | Automatique (comptage de rfrences) |\n| Tasks, Channels | **Runtime** | Automatique (comptage de rfrences) |\n\n**Le principe fondamental :** Si vous l'allouez explicitement, vous le librez explicitement. Tout le reste est gr automatiquement.\n\n---\n\n## Mmoire Gre par le Programmeur\n\n### Pointeurs Bruts\n\n```hemlock\nlet p = alloc(64);       // Allouer 64 octets\nmemset(p, 0, 64);        // Initialiser\n// ... utiliser la mmoire ...\nfree(p);                 // Votre responsabilit !\n```\n\n**Rgles :**\n- `alloc()` retourne de la mmoire que vous possdez\n- Vous devez appeler `free()` quand vous avez termin\n- Le double-free plantera (intentionnellement)\n- L'use-after-free est un comportement indfini\n- L'arithmtique des pointeurs est permise mais non vrifie\n\n### Allocation Type\n\n```hemlock\nlet arr = talloc(\"i32\", 100);  // Allouer 100 i32s (400 octets)\nptr_write_i32(arr, 0, 42);     // crire  l'index 0\nlet val = ptr_read_i32(arr, 0); // Lire depuis l'index 0\nfree(arr);                      // Toujours votre responsabilit\n```\n\n### Buffers (Alternative Sre)\n\n```hemlock\nlet buf = buffer(64);    // Buffer avec vrification des limites\nbuf[0] = 42;             // Indexation sre\n// buf[100] = 1;         // Erreur d'excution : hors limites\nfree(buf);               // Ncessite toujours un free explicite\n```\n\n**Diffrence cl :** Les buffers fournissent une vrification des limites, pas les pointeurs bruts.\n\n---\n\n## Valeurs Gres par le Runtime\n\n### Comptage de Rfrences\n\nLes valeurs alloues sur le tas utilisent un comptage de rfrences atomique :\n\n```hemlock\nlet s1 = \"hello\";        // String allou, refcount = 1\nlet s2 = s1;             // s2 partage s1, refcount = 2\n// Quand les deux sortent du scope, refcount  0, mmoire libre\n```\n\n**Types avec comptage de rfrences :**\n- `string` - Texte UTF-8\n- `array` - Arrays dynamiques\n- `object` - Objets cl-valeur\n- `function` - Closures\n- `task` - Handles de tches async\n- `channel` - Canaux de communication\n\n### Dtection de Cycles\n\nLe runtime gre les cycles dans les graphes d'objets :\n\n```hemlock\nlet a = { ref: null };\nlet b = { ref: a };\na.ref = b;               // Cycle : a  b  a\n// Le runtime utilise des ensembles visits pour dtecter et briser les cycles pendant le nettoyage\n```\n\n---\n\n## Points de Transfert de Proprit\n\n### Liaison de Variables\n\n```hemlock\nlet x = [1, 2, 3];       // Array cr avec refcount 1\n                         // x possde la rfrence\n```\n\n### Retours de Fonctions\n\n```hemlock\nfn make_array() {\n    return [1, 2, 3];    // La proprit de l'array est transfre  l'appelant\n}\nlet arr = make_array();  // arr possde maintenant la rfrence\n```\n\n### Assignation\n\n```hemlock\nlet a = \"hello\";\nlet b = a;               // Rfrence partage (refcount incrment)\nb = \"world\";             // a a toujours \"hello\", b a \"world\"\n```\n\n### Oprations de Channel\n\n```hemlock\nlet ch = channel(10);\nch.send(\"message\");      // Valeur copie dans le buffer du channel\n                         // L'original reste valide\n\nlet msg = ch.recv();     // Reoit la proprit du channel\n```\n\n### Spawning de Tasks\n\n```hemlock\nlet data = { x: 1 };\nlet task = spawn(worker, data);  // data est COPI EN PROFONDEUR pour l'isolation\ndata.x = 2;                       // Sr - le task a sa propre copie\nlet result = join(task);          // La proprit du result est transfre  l'appelant\n```\n\n---\n\n## Async et Concurrence\n\n### Isolation des Threads\n\nLes tasks spawns reoivent des **copies profondes** des arguments mutables :\n\n```hemlock\nasync fn worker(data) {\n    data.x = 100;        // Modifie seulement la copie du task\n    return data;\n}\n\nlet obj = { x: 1 };\nlet task = spawn(worker, obj);\nobj.x = 2;               // Sr - n'affecte pas le task\nlet result = join(task);\nprint(obj.x);            // 2 (inchang par le task)\nprint(result.x);         // 100 (copie modifie du task)\n```\n\n### Objets de Coordination Partags\n\nCertains types sont partags par rfrence (non copis) :\n- **Channels** - Pour la communication inter-tasks\n- **Tasks** - Pour la coordination (join/detach)\n\n```hemlock\nlet ch = channel(1);\nspawn(producer, ch);     // Mme channel, pas une copie\nspawn(consumer, ch);     // Les deux tasks partagent le channel\n```\n\n### Rsultats des Tasks\n\n```hemlock\nlet task = spawn(compute);\nlet result = join(task);  // L'appelant possde le rsultat\n                          // La rfrence du task est libre quand le task est libr\n```\n\n### Tasks Dtachs\n\n```hemlock\ndetach(spawn(background_work));\n// Le task s'excute indpendamment\n// Le rsultat est automatiquement libr quand le task se termine\n// Pas de fuite mme si personne n'appelle join()\n```\n\n---\n\n## Rgles de Mmoire FFI\n\n### Passer aux Fonctions C\n\n```hemlock\nextern fn strlen(s: string): i32;\n\nlet s = \"hello\";\nlet len = strlen(s);     // Hemlock conserve la proprit\n                         // Le string est valide pendant l'appel\n                         // La fonction C ne doit PAS le librer\n```\n\n### Recevoir des Fonctions C\n\n```hemlock\nextern fn strdup(s: string): ptr;\n\nlet copy = strdup(\"hello\");  // C a allou cette mmoire\nfree(copy);                   // Votre responsabilit de librer\n```\n\n### Passage de Structs (Compilateur Seulement)\n\n```hemlock\n// Dfinir le layout de struct C\nffi_struct Point { x: f64, y: f64 }\n\nextern fn make_point(x: f64, y: f64): Point;\n\nlet p = make_point(1.0, 2.0);  // Retourn par valeur, copi\n                                // Pas de nettoyage ncessaire pour les structs sur la pile\n```\n\n### Mmoire des Callbacks\n\n```hemlock\n// Quand C rappelle Hemlock :\n// - Les arguments appartiennent  C (ne pas librer)\n// - La proprit de la valeur de retour est transfre  C\n```\n\n---\n\n## Scurit des Exceptions\n\n### Garanties\n\nLe runtime fournit ces garanties :\n\n1. **Pas de fuite en sortie normale** - Toutes les valeurs gres par le runtime sont nettoyes\n2. **Pas de fuite en exception** - Les temporaires sont librs pendant le droulement de la pile\n3. **Defer s'excute en exception** - Le code de nettoyage s'excute\n\n### valuation d'Expressions\n\n```hemlock\n// Si cela lance pendant la cration de l'array :\nlet arr = [f(), g(), h()];  // L'array partiel est libr\n\n// Si cela lance pendant l'appel de fonction :\nfoo(a(), b(), c());         // Les args prcdemment valus sont librs\n```\n\n### Defer pour le Nettoyage\n\n```hemlock\nfn process_file() {\n    let f = open(\"data.txt\", \"r\");\n    defer f.close();         // S'excute au return OU  l'exception\n\n    let data = f.read();\n    if (data == \"\") {\n        throw \"Empty file\";  // f.close() s'excute quand mme !\n    }\n    return data;\n}\n```\n\n---\n\n## Meilleures Pratiques\n\n### 1. Prfrez les Types Grs par le Runtime\n\n```hemlock\n// Prfrez ceci :\nlet data = [1, 2, 3, 4, 5];\n\n//  ceci (sauf si vous avez besoin de contrle bas niveau) :\nlet data = talloc(\"i32\", 5);\n// ... doit se souvenir de librer ...\n```\n\n### 2. Utilisez Defer pour la Mmoire Manuelle\n\n```hemlock\nfn process() {\n    let buf = alloc(1024);\n    defer free(buf);        // Nettoyage garanti\n\n    // ... utiliser buf ...\n    // Pas besoin de librer  chaque point de retour\n}\n```\n\n### 3. vitez les Pointeurs Bruts en Async\n\n```hemlock\n// FAUX - le pointeur peut tre libr avant que le task se termine\nlet p = alloc(64);\nspawn(worker, p);          // Le task obtient la valeur du pointeur\nfree(p);                   // Oups ! Le task l'utilise encore\n\n// CORRECT - utilisez des channels ou copiez les donnes\nlet ch = channel(1);\nlet data = buffer(64);\n// ... remplir data ...\nch.send(data);             // Copie profonde\nspawn(worker, ch);\nfree(data);                // Sr - le task a sa propre copie\n```\n\n### 4. Fermez les Channels Quand Vous Avez Termin\n\n```hemlock\nlet ch = channel(10);\n// ... utiliser le channel ...\nch.close();                // Vide et libre les valeurs en buffer\n```\n\n### 5. Join ou Detach les Tasks\n\n```hemlock\nlet task = spawn(work);\n\n// Option 1 : Attendre le rsultat\nlet result = join(task);\n\n// Option 2 : Fire and forget\n// detach(task);\n\n// NE PAS : Laisser le handle du task sortir du scope sans join ou detach\n// (Il sera nettoy, mais le rsultat peut fuir)\n```\n\n---\n\n## Dboguer les Problmes de Mmoire\n\n### Activer ASAN\n\n```bash\nmake asan\nASAN_OPTIONS=detect_leaks=1 ./hemlock script.hml\n```\n\n### Excuter les Tests de Rgression de Fuites\n\n```bash\nmake leak-regression       # Suite complte\nmake leak-regression-quick # Sauter le test exhaustif\n```\n\n### Valgrind\n\n```bash\nmake valgrind-check FILE=script.hml\n```\n\n---\n\n## Rsum\n\n| Opration | Comportement Mmoire |\n|-----------|---------------------|\n| `alloc(n)` | Alloue, vous librez |\n| `buffer(n)` | Alloue avec vrification des limites, vous librez |\n| `\"string\"` | Le runtime gre |\n| `[array]` | Le runtime gre |\n| `{object}` | Le runtime gre |\n| `spawn(fn)` | Copie profonde des args, le runtime gre le task |\n| `join(task)` | L'appelant possde le rsultat |\n| `detach(task)` | Le runtime libre le rsultat quand termin |\n| `ch.send(v)` | Copie la valeur dans le channel |\n| `ch.recv()` | L'appelant possde la valeur reue |\n| `ch.close()` | Vide et libre les valeurs en buffer |\n"}, "Sujets Avancs -> Oprations Atomiques": {"id": "advanced-atomics", "content": "# Operations atomiques\n\nHemlock fournit des operations atomiques pour la **programmation concurrente sans verrou**. Ces operations permettent une manipulation securisee de la memoire partagee entre plusieurs threads sans verrous ou mutex traditionnels.\n\n## Table des matieres\n\n- [Vue d'ensemble](#vue-densemble)\n- [Quand utiliser les atomiques](#quand-utiliser-les-atomiques)\n- [Modele memoire](#modele-memoire)\n- [Chargement et stockage atomiques](#chargement-et-stockage-atomiques)\n- [Operations fetch-and-modify](#operations-fetch-and-modify)\n- [Compare-and-Swap (CAS)](#compare-and-swap-cas)\n- [Echange atomique](#echange-atomique)\n- [Barriere memoire](#barriere-memoire)\n- [Reference des fonctions](#reference-des-fonctions)\n- [Patterns courants](#patterns-courants)\n- [Bonnes pratiques](#bonnes-pratiques)\n- [Limitations](#limitations)\n\n---\n\n## Vue d'ensemble\n\nLes operations atomiques sont des operations **indivisibles** qui se terminent sans possibilite d'interruption. Quand un thread effectue une operation atomique, aucun autre thread ne peut observer l'operation dans un etat partiellement termine.\n\n**Caracteristiques cles :**\n- Toutes les operations utilisent la **coherence sequentielle** (`memory_order_seq_cst`)\n- Types supportes : **i32** et **i64**\n- Les operations fonctionnent sur des pointeurs bruts alloues avec `alloc()`\n- Thread-safe sans verrous explicites\n\n**Operations disponibles :**\n- Load/Store - Lire et ecrire des valeurs de maniere atomique\n- Add/Sub - Operations arithmetiques retournant l'ancienne valeur\n- And/Or/Xor - Operations bit a bit retournant l'ancienne valeur\n- CAS - Compare-and-swap pour les mises a jour conditionnelles\n- Exchange - Echanger des valeurs de maniere atomique\n- Fence - Barriere memoire complete\n\n---\n\n## Quand utiliser les atomiques\n\n**Utilisez les atomiques pour :**\n- Compteurs partages entre taches (ex. comptage de requetes, suivi de progression)\n- Drapeaux et indicateurs d'etat\n- Structures de donnees sans verrou\n- Primitives de synchronisation simples\n- Code concurrent critique en performance\n\n**Utilisez les canaux a la place quand :**\n- Vous passez des donnees complexes entre taches\n- Vous implementez des patterns producteur-consommateur\n- Vous avez besoin d'une semantique de passage de messages\n\n**Exemple de cas d'utilisation - Compteur partage :**\n```hemlock\n// Allouer un compteur partage\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nasync fn worker(counter: ptr, id: i32) {\n    let i = 0;\n    while (i < 1000) {\n        atomic_add_i32(counter, 1);\n        i = i + 1;\n    }\n}\n\n// Lancer plusieurs workers\nlet t1 = spawn(worker, counter, 1);\nlet t2 = spawn(worker, counter, 2);\nlet t3 = spawn(worker, counter, 3);\n\njoin(t1);\njoin(t2);\njoin(t3);\n\n// Le compteur sera exactement 3000 (pas de courses de donnees)\nprint(atomic_load_i32(counter));\n\nfree(counter);\n```\n\n---\n\n## Modele memoire\n\nToutes les operations atomiques Hemlock utilisent la **coherence sequentielle** (`memory_order_seq_cst`), qui fournit les garanties d'ordonnancement memoire les plus fortes :\n\n1. **Atomicite** : Chaque operation est indivisible\n2. **Ordonnancement total** : Tous les threads voient le meme ordre d'operations\n3. **Pas de reordonnancement** : Les operations ne sont pas reordonnees par le compilateur ou le CPU\n\nCela rend le raisonnement sur le code concurrent plus simple, au prix d'une certaine perte de performance par rapport aux ordonnancements memoire plus faibles.\n\n---\n\n## Chargement et stockage atomiques\n\n### atomic_load_i32 / atomic_load_i64\n\nLire atomiquement une valeur depuis la memoire.\n\n**Signature :**\n```hemlock\natomic_load_i32(ptr: ptr): i32\natomic_load_i64(ptr: ptr): i64\n```\n\n**Parametres :**\n- `ptr` - Pointeur vers l'emplacement memoire (doit etre correctement aligne)\n\n**Retourne :** La valeur a l'emplacement memoire\n\n**Exemple :**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\n\nlet value = atomic_load_i32(p);\nprint(value);  // 42\n\nfree(p);\n```\n\n---\n\n### atomic_store_i32 / atomic_store_i64\n\nEcrire atomiquement une valeur en memoire.\n\n**Signature :**\n```hemlock\natomic_store_i32(ptr: ptr, value: i32): null\natomic_store_i64(ptr: ptr, value: i64): null\n```\n\n**Parametres :**\n- `ptr` - Pointeur vers l'emplacement memoire\n- `value` - Valeur a stocker\n\n**Retourne :** `null`\n\n**Exemple :**\n```hemlock\nlet p = alloc(8);\n\natomic_store_i64(p, 5000000000);\nprint(atomic_load_i64(p));  // 5000000000\n\nfree(p);\n```\n\n---\n\n## Operations fetch-and-modify\n\nCes operations modifient atomiquement une valeur et retournent l'**ancienne** valeur (precedente).\n\n### atomic_add_i32 / atomic_add_i64\n\nAjouter atomiquement a une valeur.\n\n**Signature :**\n```hemlock\natomic_add_i32(ptr: ptr, value: i32): i32\natomic_add_i64(ptr: ptr, value: i64): i64\n```\n\n**Retourne :** L'**ancienne** valeur (avant addition)\n\n**Exemple :**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_add_i32(p, 10);\nprint(old);                    // 100 (ancienne valeur)\nprint(atomic_load_i32(p));     // 110 (nouvelle valeur)\n\nfree(p);\n```\n\n---\n\n### atomic_sub_i32 / atomic_sub_i64\n\nSoustraire atomiquement d'une valeur.\n\n**Signature :**\n```hemlock\natomic_sub_i32(ptr: ptr, value: i32): i32\natomic_sub_i64(ptr: ptr, value: i64): i64\n```\n\n**Retourne :** L'**ancienne** valeur (avant soustraction)\n\n**Exemple :**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_sub_i32(p, 25);\nprint(old);                    // 100 (ancienne valeur)\nprint(atomic_load_i32(p));     // 75 (nouvelle valeur)\n\nfree(p);\n```\n\n---\n\n### atomic_and_i32 / atomic_and_i64\n\nEffectuer atomiquement un ET bit a bit.\n\n**Signature :**\n```hemlock\natomic_and_i32(ptr: ptr, value: i32): i32\natomic_and_i64(ptr: ptr, value: i64): i64\n```\n\n**Retourne :** L'**ancienne** valeur (avant ET)\n\n**Exemple :**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xFF);  // 255 en binaire : 11111111\n\nlet old = atomic_and_i32(p, 0x0F);  // ET avec 00001111\nprint(old);                    // 255 (ancienne valeur)\nprint(atomic_load_i32(p));     // 15 (0xFF & 0x0F = 0x0F)\n\nfree(p);\n```\n\n---\n\n### atomic_or_i32 / atomic_or_i64\n\nEffectuer atomiquement un OU bit a bit.\n\n**Signature :**\n```hemlock\natomic_or_i32(ptr: ptr, value: i32): i32\natomic_or_i64(ptr: ptr, value: i64): i64\n```\n\n**Retourne :** L'**ancienne** valeur (avant OU)\n\n**Exemple :**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0x0F);  // 15 en binaire : 00001111\n\nlet old = atomic_or_i32(p, 0xF0);  // OU avec 11110000\nprint(old);                    // 15 (ancienne valeur)\nprint(atomic_load_i32(p));     // 255 (0x0F | 0xF0 = 0xFF)\n\nfree(p);\n```\n\n---\n\n### atomic_xor_i32 / atomic_xor_i64\n\nEffectuer atomiquement un XOR bit a bit.\n\n**Signature :**\n```hemlock\natomic_xor_i32(ptr: ptr, value: i32): i32\natomic_xor_i64(ptr: ptr, value: i64): i64\n```\n\n**Retourne :** L'**ancienne** valeur (avant XOR)\n\n**Exemple :**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xAA);  // 170 en binaire : 10101010\n\nlet old = atomic_xor_i32(p, 0xFF);  // XOR avec 11111111\nprint(old);                    // 170 (ancienne valeur)\nprint(atomic_load_i32(p));     // 85 (0xAA ^ 0xFF = 0x55)\n\nfree(p);\n```\n\n---\n\n## Compare-and-Swap (CAS)\n\nL'operation atomique la plus puissante. Compare atomiquement la valeur actuelle avec une valeur attendue et, si elles correspondent, la remplace par une nouvelle valeur.\n\n### atomic_cas_i32 / atomic_cas_i64\n\n**Signature :**\n```hemlock\natomic_cas_i32(ptr: ptr, expected: i32, desired: i32): bool\natomic_cas_i64(ptr: ptr, expected: i64, desired: i64): bool\n```\n\n**Parametres :**\n- `ptr` - Pointeur vers l'emplacement memoire\n- `expected` - Valeur qu'on s'attend a trouver\n- `desired` - Valeur a stocker si l'attente correspond\n\n**Retourne :**\n- `true` - L'echange a reussi (la valeur etait `expected`, maintenant c'est `desired`)\n- `false` - L'echange a echoue (la valeur n'etait pas `expected`, inchangee)\n\n**Exemple :**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\n// CAS reussit : la valeur est 100, echange vers 999\nlet success1 = atomic_cas_i32(p, 100, 999);\nprint(success1);               // true\nprint(atomic_load_i32(p));     // 999\n\n// CAS echoue : la valeur est 999, pas 100\nlet success2 = atomic_cas_i32(p, 100, 888);\nprint(success2);               // false\nprint(atomic_load_i32(p));     // 999 (inchange)\n\nfree(p);\n```\n\n**Cas d'utilisation :**\n- Implementation de verrous et semaphores\n- Structures de donnees sans verrou\n- Controle de concurrence optimiste\n- Mises a jour conditionnelles atomiques\n\n---\n\n## Echange atomique\n\nEchanger atomiquement une valeur, retournant l'ancienne valeur.\n\n### atomic_exchange_i32 / atomic_exchange_i64\n\n**Signature :**\n```hemlock\natomic_exchange_i32(ptr: ptr, value: i32): i32\natomic_exchange_i64(ptr: ptr, value: i64): i64\n```\n\n**Parametres :**\n- `ptr` - Pointeur vers l'emplacement memoire\n- `value` - Nouvelle valeur a stocker\n\n**Retourne :** L'**ancienne** valeur (avant echange)\n\n**Exemple :**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_exchange_i32(p, 200);\nprint(old);                    // 100 (ancienne valeur)\nprint(atomic_load_i32(p));     // 200 (nouvelle valeur)\n\nfree(p);\n```\n\n---\n\n## Barriere memoire\n\nUne barriere memoire complete qui assure que toutes les operations memoire avant la barriere sont visibles par tous les threads avant toute operation apres la barriere.\n\n### atomic_fence\n\n**Signature :**\n```hemlock\natomic_fence(): null\n```\n\n**Retourne :** `null`\n\n**Exemple :**\n```hemlock\n// S'assurer que toutes les ecritures precedentes sont visibles\natomic_fence();\n```\n\n**Note :** Dans la plupart des cas, vous n'avez pas besoin de barrieres explicites car toutes les operations atomiques utilisent deja la coherence sequentielle. Les barrieres sont utiles quand vous devez synchroniser des operations memoire non atomiques.\n\n---\n\n## Reference des fonctions\n\n### Operations i32\n\n| Fonction | Signature | Retourne | Description |\n|----------|-----------|----------|-------------|\n| `atomic_load_i32` | `(ptr)` | `i32` | Charger une valeur atomiquement |\n| `atomic_store_i32` | `(ptr, value)` | `null` | Stocker une valeur atomiquement |\n| `atomic_add_i32` | `(ptr, value)` | `i32` | Ajouter et retourner l'ancienne valeur |\n| `atomic_sub_i32` | `(ptr, value)` | `i32` | Soustraire et retourner l'ancienne valeur |\n| `atomic_and_i32` | `(ptr, value)` | `i32` | ET bit a bit et retourner l'ancienne valeur |\n| `atomic_or_i32` | `(ptr, value)` | `i32` | OU bit a bit et retourner l'ancienne valeur |\n| `atomic_xor_i32` | `(ptr, value)` | `i32` | XOR bit a bit et retourner l'ancienne valeur |\n| `atomic_cas_i32` | `(ptr, expected, desired)` | `bool` | Compare-and-swap |\n| `atomic_exchange_i32` | `(ptr, value)` | `i32` | Echanger et retourner l'ancienne valeur |\n\n### Operations i64\n\n| Fonction | Signature | Retourne | Description |\n|----------|-----------|----------|-------------|\n| `atomic_load_i64` | `(ptr)` | `i64` | Charger une valeur atomiquement |\n| `atomic_store_i64` | `(ptr, value)` | `null` | Stocker une valeur atomiquement |\n| `atomic_add_i64` | `(ptr, value)` | `i64` | Ajouter et retourner l'ancienne valeur |\n| `atomic_sub_i64` | `(ptr, value)` | `i64` | Soustraire et retourner l'ancienne valeur |\n| `atomic_and_i64` | `(ptr, value)` | `i64` | ET bit a bit et retourner l'ancienne valeur |\n| `atomic_or_i64` | `(ptr, value)` | `i64` | OU bit a bit et retourner l'ancienne valeur |\n| `atomic_xor_i64` | `(ptr, value)` | `i64` | XOR bit a bit et retourner l'ancienne valeur |\n| `atomic_cas_i64` | `(ptr, expected, desired)` | `bool` | Compare-and-swap |\n| `atomic_exchange_i64` | `(ptr, value)` | `i64` | Echanger et retourner l'ancienne valeur |\n\n### Barriere memoire\n\n| Fonction | Signature | Retourne | Description |\n|----------|-----------|----------|-------------|\n| `atomic_fence` | `()` | `null` | Barriere memoire complete |\n\n---\n\n## Patterns courants\n\n### Pattern : Compteur atomique\n\n```hemlock\n// Compteur thread-safe\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nfn increment(): i32 {\n    return atomic_add_i32(counter, 1);\n}\n\nfn decrement(): i32 {\n    return atomic_sub_i32(counter, 1);\n}\n\nfn get_count(): i32 {\n    return atomic_load_i32(counter);\n}\n\n// Utilisation\nincrement();  // Retourne 0 (ancienne valeur)\nincrement();  // Retourne 1\nincrement();  // Retourne 2\nprint(get_count());  // 3\n\nfree(counter);\n```\n\n### Pattern : Spinlock\n\n```hemlock\n// Implementation simple de spinlock\nlet lock = alloc(4);\nptr_write_i32(lock, 0);  // 0 = deverrouille, 1 = verrouille\n\nfn acquire() {\n    // Tourner jusqu'a ce qu'on reussisse a mettre le verrou de 0 a 1\n    while (!atomic_cas_i32(lock, 0, 1)) {\n        // Attente active\n    }\n}\n\nfn release() {\n    atomic_store_i32(lock, 0);\n}\n\n// Utilisation\nacquire();\n// ... section critique ...\nrelease();\n\nfree(lock);\n```\n\n### Pattern : Initialisation unique\n\n```hemlock\nlet initialized = alloc(4);\nptr_write_i32(initialized, 0);  // 0 = non initialise, 1 = initialise\n\nfn ensure_initialized() {\n    // Essayer d'etre celui qui initialise\n    if (atomic_cas_i32(initialized, 0, 1)) {\n        // On a gagne la course, faire l'initialisation\n        do_expensive_init();\n    }\n    // Sinon, deja initialise\n}\n```\n\n### Pattern : Drapeau atomique\n\n```hemlock\nlet flag = alloc(4);\nptr_write_i32(flag, 0);\n\nfn set_flag() {\n    atomic_store_i32(flag, 1);\n}\n\nfn clear_flag() {\n    atomic_store_i32(flag, 0);\n}\n\nfn test_and_set(): bool {\n    // Retourne true si le drapeau etait deja mis\n    return atomic_exchange_i32(flag, 1) == 1;\n}\n\nfn check_flag(): bool {\n    return atomic_load_i32(flag) == 1;\n}\n```\n\n### Pattern : Compteur borne\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\nlet max_value = 100;\n\nfn try_increment(): bool {\n    while (true) {\n        let current = atomic_load_i32(counter);\n        if (current >= max_value) {\n            return false;  // Au maximum\n        }\n        if (atomic_cas_i32(counter, current, current + 1)) {\n            return true;  // Incremente avec succes\n        }\n        // CAS echoue, un autre thread a modifie - reessayer\n    }\n}\n```\n\n---\n\n## Bonnes pratiques\n\n### 1. Utiliser un alignement correct\n\nLes pointeurs doivent etre correctement alignes pour le type de donnees :\n- i32 : alignement sur 4 octets\n- i64 : alignement sur 8 octets\n\nLa memoire de `alloc()` est typiquement correctement alignee.\n\n### 2. Preferer les abstractions de plus haut niveau\n\nQuand c'est possible, utilisez les canaux pour la communication inter-taches. Les atomiques sont de plus bas niveau et necessitent un raisonnement attentif.\n\n```hemlock\n// Preferez ceci :\nlet ch = channel(10);\nspawn(fn() { ch.send(result); });\nlet value = ch.recv();\n\n// Plutot que la coordination atomique manuelle quand c'est approprie\n```\n\n### 3. Etre conscient du probleme ABA\n\nLe CAS peut souffrir du probleme ABA : une valeur change de A vers B puis revient a A. Votre CAS reussit, mais l'etat peut avoir change entre temps.\n\n### 4. Initialiser avant de partager\n\nToujours initialiser les variables atomiques avant de lancer des taches qui y accedent :\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);  // Initialiser AVANT de lancer\n\nlet task = spawn(worker, counter);\n```\n\n### 5. Liberer apres que toutes les taches sont terminees\n\nNe liberez pas la memoire atomique tant que des taches peuvent encore y acceder :\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nlet t1 = spawn(worker, counter);\nlet t2 = spawn(worker, counter);\n\njoin(t1);\njoin(t2);\n\n// Maintenant c'est sur de liberer\nfree(counter);\n```\n\n---\n\n## Limitations\n\n### Limitations actuelles\n\n1. **Seuls i32 et i64 supportes** - Pas d'operations atomiques pour d'autres types\n2. **Pas d'atomiques de pointeurs** - Impossible de charger/stocker des pointeurs atomiquement\n3. **Coherence sequentielle uniquement** - Pas d'ordonnancements memoire plus faibles disponibles\n4. **Pas de virgule flottante atomique** - Utilisez une representation entiere si necessaire\n\n### Notes de plateforme\n\n- Les operations atomiques utilisent `<stdatomic.h>` du C11 en interne\n- Disponible sur toutes les plateformes qui supportent les threads POSIX\n- Garanti sans verrou sur les systemes 64 bits modernes\n\n---\n\n## Voir aussi\n\n- [Async/Concurrence](#advanced-async-concurrency) - Lancement de taches et canaux\n- [Gestion memoire](#language-guide-memory) - Allocation de pointeurs et tampons\n- [API memoire](#reference-memory-api) - Fonctions d'allocation\n"}, "Sujets Avancs -> Profilage": {"id": "advanced-profiling", "content": "# Profilage\n\nHemlock inclut un profiler integre pour l'**analyse du temps CPU**, le **suivi memoire** et la **detection de fuites**. Le profiler aide a identifier les goulots d'etranglement de performance et les problemes memoire dans vos programmes.\n\n## Table des matieres\n\n- [Vue d'ensemble](#vue-densemble)\n- [Demarrage rapide](#demarrage-rapide)\n- [Modes de profilage](#modes-de-profilage)\n- [Formats de sortie](#formats-de-sortie)\n- [Detection de fuites](#detection-de-fuites)\n- [Comprendre les rapports](#comprendre-les-rapports)\n- [Generation de flamegraph](#generation-de-flamegraph)\n- [Bonnes pratiques](#bonnes-pratiques)\n\n---\n\n## Vue d'ensemble\n\nLe profiler est accessible via la sous-commande `profile` :\n\n```bash\nhemlock profile [OPTIONS] <FILE>\n```\n\n**Fonctionnalites cles :**\n- **Profilage CPU** - Mesurer le temps passe dans chaque fonction (temps propre et temps total)\n- **Profilage memoire** - Suivre toutes les allocations avec les emplacements source\n- **Detection de fuites** - Identifier la memoire qui n'a jamais ete liberee\n- **Formats de sortie multiples** - Texte, JSON et sortie compatible flamegraph\n- **Statistiques memoire par fonction** - Voir quelles fonctions allouent le plus de memoire\n\n---\n\n## Demarrage rapide\n\n### Profiler le temps CPU (par defaut)\n\n```bash\nhemlock profile script.hml\n```\n\n### Profiler les allocations memoire\n\n```bash\nhemlock profile --memory script.hml\n```\n\n### Detecter les fuites memoire\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n### Generer des donnees flamegraph\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\nflamegraph.pl profile.folded > profile.svg\n```\n\n---\n\n## Modes de profilage\n\n### Profilage CPU (par defaut)\n\nMesure le temps passe dans chaque fonction, distinguant entre :\n- **Temps propre (Self)** - Temps passe a executer le propre code de la fonction\n- **Temps total (Total)** - Temps propre plus temps passe dans les fonctions appelees\n\n```bash\nhemlock profile script.hml\nhemlock profile --cpu script.hml  # Explicite\n```\n\n**Exemple de sortie :**\n```\n=== Rapport du profiler Hemlock ===\n\nTemps total : 1.234ms\nFonctions appelees : 5 uniques\n\n--- Top 5 par temps propre ---\n\nFonction                        Self      Total   Appels\n--------                        ----      -----   ------\nexpensive_calc              0.892ms    0.892ms     100  (72.3%)\nprocess_data                0.234ms    1.126ms      10  (19.0%)\nhelper                      0.067ms    0.067ms     500  (5.4%)\nmain                        0.041ms    1.234ms       1  (3.3%)\n```\n\n---\n\n### Profilage memoire\n\nSuit toutes les allocations memoire (`alloc`, `buffer`, `talloc`, `realloc`) avec les emplacements source.\n\n```bash\nhemlock profile --memory script.hml\n```\n\n**Exemple de sortie :**\n```\n=== Rapport du profiler Hemlock ===\n\nTemps total : 0.543ms\nFonctions appelees : 3 uniques\nAllocations totales : 15 (4.2Ko)\n\n--- Top 3 par temps propre ---\n\nFonction                        Self      Total   Appels      Alloc      Nombre\n--------                        ----      -----   ------      -----      ------\nallocator                   0.312ms    0.312ms      10      3.2Ko         10  (57.5%)\nbuffer_ops                  0.156ms    0.156ms       5       1Ko          5  (28.7%)\nmain                        0.075ms    0.543ms       1        0o          0  (13.8%)\n\n--- Top 10 sites d'allocation ---\n\nEmplacement                                   Total    Nombre\n-----------                                   -----    ------\nsrc/data.hml:42                               1.5Ko        5\nsrc/data.hml:67                               1.0Ko       10\nsrc/main.hml:15                               512o         1\n```\n\n---\n\n### Mode comptage d'appels\n\nMode a surcharge minimale qui compte uniquement les appels de fonction (pas de chronometrage).\n\n```bash\nhemlock profile --calls script.hml\n```\n\n---\n\n## Formats de sortie\n\n### Texte (par defaut)\n\nResume lisible par l'humain avec des tableaux.\n\n```bash\nhemlock profile script.hml\n```\n\n---\n\n### JSON\n\nFormat lisible par machine pour l'integration avec d'autres outils.\n\n```bash\nhemlock profile --json script.hml\n```\n\n**Exemple de sortie :**\n```json\n{\n  \"total_time_ns\": 1234567,\n  \"function_count\": 5,\n  \"total_alloc_bytes\": 4096,\n  \"total_alloc_count\": 15,\n  \"functions\": [\n    {\n      \"name\": \"expensive_calc\",\n      \"source_file\": \"script.hml\",\n      \"line\": 10,\n      \"self_time_ns\": 892000,\n      \"total_time_ns\": 892000,\n      \"call_count\": 100,\n      \"alloc_bytes\": 0,\n      \"alloc_count\": 0\n    }\n  ],\n  \"alloc_sites\": [\n    {\n      \"source_file\": \"script.hml\",\n      \"line\": 42,\n      \"total_bytes\": 1536,\n      \"alloc_count\": 5,\n      \"current_bytes\": 0\n    }\n  ]\n}\n```\n\n---\n\n### Flamegraph\n\nGenere un format de pile reduit compatible avec [flamegraph.pl](https://github.com/brendangregg/FlameGraph).\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\n\n# Generer le SVG avec flamegraph.pl\nflamegraph.pl profile.folded > profile.svg\n```\n\n**Exemple de sortie reduite :**\n```\nmain;process_data;expensive_calc 892\nmain;process_data;helper 67\nmain;process_data 234\nmain 41\n```\n\n---\n\n## Detection de fuites\n\nLe drapeau `--leaks` montre uniquement les allocations qui n'ont jamais ete liberees, facilitant l'identification des fuites memoire.\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n**Exemple de programme avec fuites :**\n```hemlock\nfn leaky() {\n    let p1 = alloc(100);    // Fuite - jamais libere\n    let p2 = alloc(200);    // OK - libere ci-dessous\n    free(p2);\n}\n\nfn clean() {\n    let b = buffer(64);\n    free(b);                // Correctement libere\n}\n\nleaky();\nclean();\n```\n\n**Sortie avec --leaks :**\n```\n=== Rapport du profiler Hemlock ===\n\nTemps total : 0.034ms\nFonctions appelees : 2 uniques\nAllocations totales : 3 (388o)\n\n--- Top 2 par temps propre ---\n\nFonction                        Self      Total   Appels      Alloc      Nombre\n--------                        ----      -----   ------      -----      ------\nleaky                       0.021ms    0.021ms       1       300o          2  (61.8%)\nclean                       0.013ms    0.013ms       1        88o          1  (38.2%)\n\n--- Fuites memoire (1 site) ---\n\nEmplacement                                  Fuite      Total    Nombre\n-----------                                  -----      -----    ------\nscript.hml:2                                  100o       100o        1\n```\n\nLe rapport de fuites montre :\n- **Fuite (Leaked)** - Octets actuellement non liberes a la fin du programme\n- **Total** - Octets totaux jamais alloues a ce site\n- **Nombre (Count)** - Nombre d'allocations a ce site\n\n---\n\n## Comprendre les rapports\n\n### Statistiques de fonction\n\n| Colonne | Description |\n|---------|-------------|\n| Fonction | Nom de la fonction |\n| Self | Temps dans la fonction excluant les appeles |\n| Total | Temps incluant toutes les fonctions appelees |\n| Appels (Calls) | Nombre de fois que la fonction a ete appelee |\n| Alloc | Octets totaux alloues par cette fonction |\n| Nombre (Count) | Nombre d'allocations par cette fonction |\n| (%) | Pourcentage du temps total du programme |\n\n### Sites d'allocation\n\n| Colonne | Description |\n|---------|-------------|\n| Emplacement (Location) | Fichier source et numero de ligne |\n| Total | Octets totaux alloues a cet emplacement |\n| Nombre (Count) | Nombre d'allocations |\n| Fuite (Leaked) | Octets encore alloues a la fin du programme (--leaks uniquement) |\n\n### Unites de temps\n\nLe profiler selectionne automatiquement les unites appropriees :\n- `ns` - Nanosecondes (< 1us)\n- `us` - Microsecondes (< 1ms)\n- `ms` - Millisecondes (< 1s)\n- `s` - Secondes\n\n---\n\n## Reference des commandes\n\n```\nhemlock profile [OPTIONS] <FILE>\n\nOPTIONS :\n    --cpu           Profilage CPU/temps (par defaut)\n    --memory        Profilage des allocations memoire\n    --calls         Comptage d'appels uniquement (surcharge minimale)\n    --leaks         Montrer uniquement les allocations non liberees (implique --memory)\n    --json          Sortie en format JSON\n    --flamegraph    Sortie en format compatible flamegraph\n    --top N         Montrer les top N entrees (defaut : 20)\n```\n\n---\n\n## Generation de flamegraph\n\nLes flamegraphs visualisent ou votre programme passe du temps, avec des barres plus larges indiquant plus de temps passe.\n\n### Generer un flamegraph\n\n1. Installer flamegraph.pl :\n   ```bash\n   git clone https://github.com/brendangregg/FlameGraph\n   ```\n\n2. Profiler votre programme :\n   ```bash\n   hemlock profile --flamegraph script.hml > profile.folded\n   ```\n\n3. Generer le SVG :\n   ```bash\n   ./FlameGraph/flamegraph.pl profile.folded > profile.svg\n   ```\n\n4. Ouvrir `profile.svg` dans un navigateur pour une visualisation interactive.\n\n### Lire les flamegraphs\n\n- **Axe X** : Pourcentage du temps total (largeur = proportion du temps)\n- **Axe Y** : Profondeur de la pile d'appels (bas = point d'entree, haut = fonctions feuilles)\n- **Couleur** : Aleatoire, pour distinction visuelle uniquement\n- **Clic** : Zoomer sur une fonction pour voir ses appeles\n\n---\n\n## Bonnes pratiques\n\n### 1. Profiler des charges de travail representatives\n\nProfilez avec des donnees et des patterns d'utilisation realistes. Les petits cas de test peuvent ne pas reveler les vrais goulots d'etranglement.\n\n```bash\n# Bien : Profiler avec des donnees type production\nhemlock profile --memory process_large_file.hml large_input.txt\n\n# Moins utile : Petit cas de test\nhemlock profile quick_test.hml\n```\n\n### 2. Utiliser --leaks pendant le developpement\n\nExecutez la detection de fuites regulierement pour attraper les fuites memoire tot :\n\n```bash\nhemlock profile --leaks my_program.hml\n```\n\n### 3. Comparer avant et apres\n\nProfilez avant et apres les optimisations pour mesurer l'impact :\n\n```bash\n# Avant optimisation\nhemlock profile --json script.hml > before.json\n\n# Apres optimisation\nhemlock profile --json script.hml > after.json\n\n# Comparer les resultats\n```\n\n### 4. Utiliser --top pour les gros programmes\n\nLimitez la sortie pour vous concentrer sur les fonctions les plus significatives :\n\n```bash\nhemlock profile --top 10 large_program.hml\n```\n\n### 5. Combiner avec les flamegraphs\n\nPour des patterns d'appels complexes, les flamegraphs fournissent une meilleure visualisation que la sortie texte :\n\n```bash\nhemlock profile --flamegraph complex_app.hml > app.folded\nflamegraph.pl app.folded > app.svg\n```\n\n---\n\n## Surcharge du profiler\n\nLe profiler ajoute une certaine surcharge a l'execution du programme :\n\n| Mode | Surcharge | Cas d'utilisation |\n|------|-----------|-------------------|\n| `--calls` | Minimale | Juste compter les appels de fonction |\n| `--cpu` | Faible | Profilage de performance general |\n| `--memory` | Moderee | Analyse memoire et detection de fuites |\n\nPour les resultats les plus precis, profilez plusieurs fois et cherchez des patterns coherents.\n\n---\n\n## Voir aussi\n\n- [Gestion memoire](#language-guide-memory) - Pointeurs et tampons\n- [API memoire](#reference-memory-api) - Fonctions alloc, free, buffer\n- [Async/Concurrence](#advanced-async-concurrency) - Profilage du code async\n"}, "Sujets Avancs -> Signaux": {"id": "advanced-signals", "content": "# Gestion des signaux dans Hemlock\n\nHemlock fournit une **gestion des signaux POSIX** pour gerer les signaux systeme comme SIGINT (Ctrl+C), SIGTERM et les signaux personnalises. Cela permet le controle de processus bas niveau et la communication inter-processus.\n\n## Table des matieres\n\n- [Vue d'ensemble](#vue-densemble)\n- [API des signaux](#api-des-signaux)\n- [Constantes de signaux](#constantes-de-signaux)\n- [Gestion basique des signaux](#gestion-basique-des-signaux)\n- [Patterns avances](#patterns-avances)\n- [Comportement des gestionnaires de signaux](#comportement-des-gestionnaires-de-signaux)\n- [Considerations de securite](#considerations-de-securite)\n- [Cas d'utilisation courants](#cas-dutilisation-courants)\n- [Exemples complets](#exemples-complets)\n\n## Vue d'ensemble\n\nLa gestion des signaux permet aux programmes de :\n- Repondre aux interruptions utilisateur (Ctrl+C, Ctrl+Z)\n- Implementer un arret gracieux\n- Gerer les demandes de terminaison\n- Utiliser des signaux personnalises pour la communication inter-processus\n- Creer des mecanismes d'alarme/minuterie\n\n**Important :** La gestion des signaux est **inheremment non securisee** dans la philosophie de Hemlock. Les gestionnaires peuvent etre appeles a tout moment, interrompant l'execution normale. L'utilisateur est responsable de la synchronisation appropriee.\n\n## API des signaux\n\n### signal(signum, handler_fn)\n\nEnregistrer une fonction de gestion de signal.\n\n**Parametres :**\n- `signum` (i32) - Numero de signal (constante comme SIGINT, SIGTERM)\n- `handler_fn` (fonction ou null) - Fonction a appeler quand le signal est recu, ou `null` pour reinitialiser au comportement par defaut\n\n**Retourne :** La fonction de gestion precedente (ou `null` si aucune)\n\n**Exemple :**\n```hemlock\nfn my_handler(sig) {\n    print(\"Signal intercepte : \" + typeof(sig));\n}\n\nlet old_handler = signal(SIGINT, my_handler);\n```\n\n**Reinitialisation au defaut :**\n```hemlock\nsignal(SIGINT, null);  // Reinitialiser SIGINT au comportement par defaut\n```\n\n### raise(signum)\n\nEnvoyer un signal au processus courant.\n\n**Parametres :**\n- `signum` (i32) - Numero de signal a envoyer\n\n**Retourne :** `null`\n\n**Exemple :**\n```hemlock\nraise(SIGUSR1);  // Declencher le gestionnaire SIGUSR1\n```\n\n## Constantes de signaux\n\nHemlock fournit les constantes de signaux POSIX standard sous forme de valeurs i32.\n\n### Interruption et terminaison\n\n| Constante | Valeur | Description | Declencheur courant |\n|-----------|--------|-------------|---------------------|\n| `SIGINT` | 2 | Interruption depuis le clavier | Ctrl+C |\n| `SIGTERM` | 15 | Demande de terminaison | Commande `kill` |\n| `SIGQUIT` | 3 | Quitter depuis le clavier | Ctrl+\\ |\n| `SIGHUP` | 1 | Deconnexion detectee | Terminal ferme |\n| `SIGABRT` | 6 | Signal d'abandon | Fonction `abort()` |\n\n**Exemples :**\n```hemlock\nsignal(SIGINT, handle_interrupt);   // Ctrl+C\nsignal(SIGTERM, handle_terminate);  // Commande kill\nsignal(SIGHUP, handle_hangup);      // Terminal ferme\n```\n\n### Signaux definis par l'utilisateur\n\n| Constante | Valeur | Description | Cas d'utilisation |\n|-----------|--------|-------------|-------------------|\n| `SIGUSR1` | 10 | Signal utilisateur 1 | IPC personnalise |\n| `SIGUSR2` | 12 | Signal utilisateur 2 | IPC personnalise |\n\n**Exemples :**\n```hemlock\n// Utiliser pour communication personnalisee\nsignal(SIGUSR1, reload_config);\nsignal(SIGUSR2, rotate_logs);\n```\n\n### Controle de processus\n\n| Constante | Valeur | Description | Notes |\n|-----------|--------|-------------|-------|\n| `SIGALRM` | 14 | Minuterie d'alarme | Apres `alarm()` |\n| `SIGCHLD` | 17 | Changement d'etat du processus enfant | Gestion de processus |\n| `SIGCONT` | 18 | Continuer si arrete | Reprendre apres SIGSTOP |\n| `SIGSTOP` | 19 | Arreter le processus | **Ne peut pas etre intercepte** |\n| `SIGTSTP` | 20 | Arret terminal | Ctrl+Z |\n\n**Exemples :**\n```hemlock\nsignal(SIGALRM, handle_timeout);\nsignal(SIGCHLD, handle_child_exit);\n```\n\n### Signaux E/S\n\n| Constante | Valeur | Description | Quand envoye |\n|-----------|--------|-------------|--------------|\n| `SIGPIPE` | 13 | Pipe casse | Ecriture vers pipe ferme |\n| `SIGTTIN` | 21 | Lecture en arriere-plan depuis terminal | Processus BG lit TTY |\n| `SIGTTOU` | 22 | Ecriture en arriere-plan vers terminal | Processus BG ecrit TTY |\n\n**Exemples :**\n```hemlock\nsignal(SIGPIPE, handle_broken_pipe);\n```\n\n## Gestion basique des signaux\n\n### Intercepter Ctrl+C\n\n```hemlock\nlet interrupted = false;\n\nfn handle_interrupt(sig) {\n    print(\"SIGINT intercepte !\");\n    interrupted = true;\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Le programme continue de s'executer...\n// L'utilisateur appuie sur Ctrl+C -> handle_interrupt() est appele\n\nwhile (!interrupted) {\n    // Faire le travail...\n}\n\nprint(\"Sortie due a l'interruption\");\n```\n\n### Signature de fonction de gestionnaire\n\nLes gestionnaires de signaux recoivent un argument : le numero de signal (i32)\n\n```hemlock\nfn my_handler(signum) {\n    print(\"Signal recu : \" + typeof(signum));\n    // signum contient le numero de signal (ex. 2 pour SIGINT)\n\n    if (signum == SIGINT) {\n        print(\"C'est SIGINT\");\n    }\n}\n\nsignal(SIGINT, my_handler);\nsignal(SIGTERM, my_handler);  // Meme gestionnaire pour plusieurs signaux\n```\n\n### Gestionnaires de signaux multiples\n\nDifferents gestionnaires pour differents signaux :\n\n```hemlock\nfn handle_int(sig) {\n    print(\"SIGINT recu\");\n}\n\nfn handle_term(sig) {\n    print(\"SIGTERM recu\");\n}\n\nfn handle_usr1(sig) {\n    print(\"SIGUSR1 recu\");\n}\n\nsignal(SIGINT, handle_int);\nsignal(SIGTERM, handle_term);\nsignal(SIGUSR1, handle_usr1);\n```\n\n### Reinitialisation au comportement par defaut\n\nPassez `null` comme gestionnaire pour reinitialiser au comportement par defaut :\n\n```hemlock\n// Enregistrer un gestionnaire personnalise\nsignal(SIGINT, my_handler);\n\n// Plus tard, reinitialiser au defaut (terminer sur SIGINT)\nsignal(SIGINT, null);\n```\n\n### Lever des signaux manuellement\n\nEnvoyer des signaux a votre propre processus :\n\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\n// Declencher le gestionnaire manuellement\nraise(SIGUSR1);\nraise(SIGUSR1);\n\nprint(count);  // 2\n```\n\n## Patterns avances\n\n### Pattern d'arret gracieux\n\nPattern courant pour le nettoyage a la terminaison :\n\n```hemlock\nlet should_exit = false;\n\nfn handle_shutdown(sig) {\n    print(\"Arret gracieux en cours...\");\n    should_exit = true;\n}\n\nsignal(SIGINT, handle_shutdown);\nsignal(SIGTERM, handle_shutdown);\n\n// Boucle principale\nwhile (!should_exit) {\n    // Faire le travail...\n    // Verifier le drapeau should_exit periodiquement\n}\n\nprint(\"Nettoyage termine\");\n```\n\n### Compteur de signaux\n\nSuivre le nombre de signaux recus :\n\n```hemlock\nlet signal_count = 0;\n\nfn count_signals(sig) {\n    signal_count = signal_count + 1;\n    print(\"Recu \" + typeof(signal_count) + \" signaux\");\n}\n\nsignal(SIGUSR1, count_signals);\n\n// Plus tard...\nprint(\"Signaux totaux : \" + typeof(signal_count));\n```\n\n### Rechargement de configuration sur signal\n\n```hemlock\nlet config = load_config();\n\nfn reload_config(sig) {\n    print(\"Rechargement de la configuration...\");\n    config = load_config();\n    print(\"Configuration rechargee\");\n}\n\nsignal(SIGHUP, reload_config);  // Recharger sur SIGHUP\n\n// Envoyer SIGHUP au processus pour recharger la config\n// Depuis le shell : kill -HUP <pid>\n```\n\n### Timeout utilisant SIGALRM\n\n```hemlock\nlet timed_out = false;\n\nfn handle_alarm(sig) {\n    print(\"Timeout !\");\n    timed_out = true;\n}\n\nsignal(SIGALRM, handle_alarm);\n\n// Definir l'alarme (pas encore implemente dans Hemlock, exemple seulement)\n// alarm(5);  // timeout de 5 secondes\n\nwhile (!timed_out) {\n    // Faire le travail avec timeout\n}\n```\n\n### Machine a etats basee sur signaux\n\n```hemlock\nlet state = 0;\n\nfn next_state(sig) {\n    state = (state + 1) % 3;\n    print(\"Etat : \" + typeof(state));\n}\n\nfn prev_state(sig) {\n    state = (state - 1 + 3) % 3;\n    print(\"Etat : \" + typeof(state));\n}\n\nsignal(SIGUSR1, next_state);  // Avancer l'etat\nsignal(SIGUSR2, prev_state);  // Reculer\n\n// Controler la machine a etats :\n// kill -USR1 <pid>  # Etat suivant\n// kill -USR2 <pid>  # Etat precedent\n```\n\n## Comportement des gestionnaires de signaux\n\n### Notes importantes\n\n**Execution des gestionnaires :**\n- Les gestionnaires sont appeles **de maniere synchrone** quand le signal est recu\n- Les gestionnaires s'executent dans le contexte du processus courant\n- Les gestionnaires de signaux partagent l'environnement de closure de la fonction ou ils sont definis\n- Les gestionnaires peuvent acceder et modifier les variables de portee externe (comme les globales ou les variables capturees)\n\n**Bonnes pratiques :**\n- Garder les gestionnaires simples et rapides - eviter les operations de longue duree\n- Definir des drapeaux plutot que d'effectuer une logique complexe\n- Eviter d'appeler des fonctions qui pourraient prendre des verrous\n- Etre conscient que les gestionnaires peuvent interrompre n'importe quelle operation\n\n### Quels signaux peuvent etre interceptes\n\n**Peuvent etre interceptes et geres :**\n- SIGINT, SIGTERM, SIGUSR1, SIGUSR2, SIGHUP, SIGQUIT\n- SIGALRM, SIGCHLD, SIGCONT, SIGTSTP\n- SIGPIPE, SIGTTIN, SIGTTOU\n- SIGABRT (mais le programme s'arretera apres le retour du gestionnaire)\n\n**Ne peuvent pas etre interceptes :**\n- `SIGKILL` (9) - Termine toujours le processus\n- `SIGSTOP` (19) - Arrete toujours le processus\n\n**Dependant du systeme :**\n- Certains signaux ont des comportements par defaut qui peuvent differer selon le systeme\n- Consultez la documentation des signaux de votre plateforme pour les specificites\n\n### Limitations des gestionnaires\n\n```hemlock\nfn complex_handler(sig) {\n    // Eviter ceci dans les gestionnaires de signaux :\n\n    //  Operations de longue duree\n    // process_large_file();\n\n    //  E/S bloquantes\n    // let f = open(\"log.txt\", \"a\");\n    // f.write(\"Signal recu\\n\");\n\n    //  Changements d'etat complexes\n    // rebuild_entire_data_structure();\n\n    //  La definition simple de drapeaux est sure\n    let should_stop = true;\n\n    //  Les mises a jour simples de compteurs sont generalement sures\n    let signal_count = signal_count + 1;\n}\n```\n\n## Considerations de securite\n\nLa gestion des signaux est **inheremment non securisee** dans la philosophie de Hemlock.\n\n### Conditions de course\n\nLes gestionnaires peuvent etre appeles a tout moment, interrompant l'execution normale :\n\n```hemlock\nlet counter = 0;\n\nfn increment(sig) {\n    counter = counter + 1;  // Condition de course si appele pendant la mise a jour du compteur\n}\n\nsignal(SIGUSR1, increment);\n\n// Le code principal modifie aussi le compteur\ncounter = counter + 1;  // Pourrait etre interrompu par le gestionnaire de signal\n```\n\n**Probleme :** Si le signal arrive pendant que le code principal met a jour `counter`, le resultat est imprevisible.\n\n### Securite async-signal\n\nHemlock ne **garantit PAS** la securite async-signal :\n- Les gestionnaires peuvent appeler n'importe quel code Hemlock (contrairement aux fonctions async-signal-safe restreintes du C)\n- Cela fournit de la flexibilite mais necessite de la prudence de l'utilisateur\n- Les conditions de course sont possibles si le gestionnaire modifie un etat partage\n\n### Bonnes pratiques pour une gestion de signaux sure\n\n**1. Utiliser des drapeaux atomiques**\n\nLes assignations booleennes simples sont generalement sures :\n\n```hemlock\nlet should_exit = false;\n\nfn handler(sig) {\n    should_exit = true;  // L'assignation simple est sure\n}\n\nsignal(SIGINT, handler);\n\nwhile (!should_exit) {\n    // travail...\n}\n```\n\n**2. Minimiser l'etat partage**\n\n```hemlock\nlet interrupt_count = 0;\n\nfn handler(sig) {\n    // Modifier uniquement cette variable\n    interrupt_count = interrupt_count + 1;\n}\n```\n\n**3. Differer les operations complexes**\n\n```hemlock\nlet pending_reload = false;\n\nfn signal_reload(sig) {\n    pending_reload = true;  // Juste definir le drapeau\n}\n\nsignal(SIGHUP, signal_reload);\n\n// Dans la boucle principale :\nwhile (true) {\n    if (pending_reload) {\n        reload_config();  // Faire le travail complexe ici\n        pending_reload = false;\n    }\n\n    // Travail normal...\n}\n```\n\n**4. Eviter les problemes de reentrance**\n\n```hemlock\nlet in_critical_section = false;\nlet data = [];\n\nfn careful_handler(sig) {\n    if (in_critical_section) {\n        // Ne pas modifier les donnees pendant que le code principal les utilise\n        return;\n    }\n    // Sur de proceder\n}\n```\n\n## Cas d'utilisation courants\n\n### 1. Arret gracieux de serveur\n\n```hemlock\nlet running = true;\n\nfn shutdown(sig) {\n    print(\"Signal d'arret recu\");\n    running = false;\n}\n\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// Boucle principale du serveur\nwhile (running) {\n    handle_client_request();\n}\n\ncleanup_resources();\nprint(\"Serveur arrete\");\n```\n\n### 2. Rechargement de configuration (sans redemarrage)\n\n```hemlock\nlet config = load_config(\"app.conf\");\nlet reload_needed = false;\n\nfn trigger_reload(sig) {\n    reload_needed = true;\n}\n\nsignal(SIGHUP, trigger_reload);\n\nwhile (true) {\n    if (reload_needed) {\n        print(\"Rechargement de la configuration...\");\n        config = load_config(\"app.conf\");\n        reload_needed = false;\n    }\n\n    // Utiliser la config...\n}\n```\n\n### 3. Rotation des logs\n\n```hemlock\nlet log_file = open(\"app.log\", \"a\");\nlet rotate_needed = false;\n\nfn trigger_rotate(sig) {\n    rotate_needed = true;\n}\n\nsignal(SIGUSR1, trigger_rotate);\n\nwhile (true) {\n    if (rotate_needed) {\n        log_file.close();\n        // Renommer l'ancien log, ouvrir le nouveau\n        exec(\"mv app.log app.log.old\");\n        log_file = open(\"app.log\", \"a\");\n        rotate_needed = false;\n    }\n\n    // Journalisation normale...\n    log_file.write(\"Entree de log\\n\");\n}\n```\n\n### 4. Rapport d'etat\n\n```hemlock\nlet requests_handled = 0;\n\nfn report_status(sig) {\n    print(\"Etat : \" + typeof(requests_handled) + \" requetes traitees\");\n}\n\nsignal(SIGUSR1, report_status);\n\nwhile (true) {\n    handle_request();\n    requests_handled = requests_handled + 1;\n}\n\n// Depuis le shell : kill -USR1 <pid>\n```\n\n### 5. Basculement du mode debug\n\n```hemlock\nlet debug_mode = false;\n\nfn toggle_debug(sig) {\n    debug_mode = !debug_mode;\n    if (debug_mode) {\n        print(\"Mode debug : ACTIVE\");\n    } else {\n        print(\"Mode debug : DESACTIVE\");\n    }\n}\n\nsignal(SIGUSR2, toggle_debug);\n\n// Depuis le shell : kill -USR2 <pid> pour basculer\n```\n\n## Exemples complets\n\n### Exemple 1 : Gestionnaire d'interruption avec nettoyage\n\n```hemlock\nlet running = true;\nlet signal_count = 0;\n\nfn handle_signal(signum) {\n    signal_count = signal_count + 1;\n\n    if (signum == SIGINT) {\n        print(\"Interruption detectee (Ctrl+C)\");\n        running = false;\n    }\n\n    if (signum == SIGUSR1) {\n        print(\"Signal utilisateur 1 recu\");\n    }\n}\n\n// Enregistrer les gestionnaires\nsignal(SIGINT, handle_signal);\nsignal(SIGUSR1, handle_signal);\n\n// Simuler du travail\nlet i = 0;\nwhile (running && i < 100) {\n    print(\"Travail en cours... \" + typeof(i));\n\n    // Declencher SIGUSR1 toutes les 10 iterations\n    if (i == 10 || i == 20) {\n        raise(SIGUSR1);\n    }\n\n    i = i + 1;\n}\n\nprint(\"Signaux totaux recus : \" + typeof(signal_count));\n```\n\n### Exemple 2 : Machine a etats multi-signaux\n\n```hemlock\nlet state = \"idle\";\nlet request_count = 0;\n\nfn start_processing(sig) {\n    state = \"processing\";\n    print(\"Etat : \" + state);\n}\n\nfn stop_processing(sig) {\n    state = \"idle\";\n    print(\"Etat : \" + state);\n}\n\nfn report_stats(sig) {\n    print(\"Etat : \" + state);\n    print(\"Requetes : \" + typeof(request_count));\n}\n\nsignal(SIGUSR1, start_processing);\nsignal(SIGUSR2, stop_processing);\nsignal(SIGHUP, report_stats);\n\nwhile (true) {\n    if (state == \"processing\") {\n        // Faire le travail\n        request_count = request_count + 1;\n    }\n\n    // Verifier a chaque iteration...\n}\n```\n\n### Exemple 3 : Controleur de pool de workers\n\n```hemlock\nlet worker_count = 4;\nlet should_exit = false;\n\nfn increase_workers(sig) {\n    worker_count = worker_count + 1;\n    print(\"Workers : \" + typeof(worker_count));\n}\n\nfn decrease_workers(sig) {\n    if (worker_count > 1) {\n        worker_count = worker_count - 1;\n    }\n    print(\"Workers : \" + typeof(worker_count));\n}\n\nfn shutdown(sig) {\n    print(\"Arret en cours...\");\n    should_exit = true;\n}\n\nsignal(SIGUSR1, increase_workers);\nsignal(SIGUSR2, decrease_workers);\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// La boucle principale ajuste le pool de workers selon worker_count\nwhile (!should_exit) {\n    // Gerer les workers selon worker_count\n    // ...\n}\n```\n\n### Exemple 4 : Pattern de timeout\n\n```hemlock\nlet operation_complete = false;\nlet timed_out = false;\n\nfn timeout_handler(sig) {\n    timed_out = true;\n}\n\nsignal(SIGALRM, timeout_handler);\n\n// Demarrer une operation longue\nasync fn long_operation() {\n    // ... travail\n    operation_complete = true;\n}\n\nlet task = spawn(long_operation);\n\n// Attendre avec timeout (verification manuelle)\nlet elapsed = 0;\nwhile (!operation_complete && elapsed < 1000) {\n    // Sleep ou verifier\n    elapsed = elapsed + 1;\n}\n\nif (!operation_complete) {\n    print(\"Operation expir\");\n    detach(task);  // Abandonner l'attente\n} else {\n    join(task);\n    print(\"Operation terminee\");\n}\n```\n\n## Debogage des gestionnaires de signaux\n\n### Ajouter des prints de diagnostic\n\n```hemlock\nfn debug_handler(sig) {\n    print(\"Gestionnaire appele pour le signal : \" + typeof(sig));\n    print(\"Pile : (pas encore disponible)\");\n\n    // Votre logique de gestionnaire...\n}\n\nsignal(SIGINT, debug_handler);\n```\n\n### Compter les appels de gestionnaire\n\n```hemlock\nlet handler_calls = 0;\n\nfn counting_handler(sig) {\n    handler_calls = handler_calls + 1;\n    print(\"Appel de gestionnaire #\" + typeof(handler_calls));\n\n    // Votre logique de gestionnaire...\n}\n```\n\n### Tester avec raise()\n\n```hemlock\nfn test_handler(sig) {\n    print(\"Signal de test recu : \" + typeof(sig));\n}\n\nsignal(SIGUSR1, test_handler);\n\n// Tester en levant manuellement\nraise(SIGUSR1);\nprint(\"Le gestionnaire devrait avoir ete appele\");\n```\n\n## Resume\n\nLa gestion des signaux de Hemlock fournit :\n\n-  Gestion des signaux POSIX pour le controle de processus bas niveau\n-  15 constantes de signaux standard\n-  API simple signal() et raise()\n-  Fonctions de gestionnaire flexibles avec support des closures\n-  Plusieurs signaux peuvent partager des gestionnaires\n\nRappelez-vous :\n- La gestion des signaux est inheremment non securisee - utilisez avec prudence\n- Garder les gestionnaires simples et rapides\n- Utiliser des drapeaux pour les changements d'etat, pas des operations complexes\n- Les gestionnaires peuvent interrompre l'execution a tout moment\n- Impossible d'intercepter SIGKILL ou SIGSTOP\n- Tester les gestionnaires minutieusement avec raise()\n\nPatterns courants :\n- Arret gracieux (SIGINT, SIGTERM)\n- Rechargement de configuration (SIGHUP)\n- Rotation des logs (SIGUSR1)\n- Rapport d'etat (SIGUSR1/SIGUSR2)\n- Basculement du mode debug (SIGUSR2)\n"}, "Rfrence API -> API Mmoire": {"id": "reference-memory-api", "content": "# Rfrence de l'API Memory\n\nRfrence complte pour les fonctions de gestion de la mmoire et les types de pointeurs de Hemlock.\n\n---\n\n## Aperu\n\nHemlock fournit une **gestion manuelle de la mmoire** avec allocation et dsallocation explicites. La mmoire est gre  travers deux types de pointeurs : les pointeurs bruts (`ptr`) et les buffers scuriss (`buffer`).\n\n**Principes cls :**\n- Allocation et dsallocation explicites\n- Pas de ramasse-miettes (garbage collection)\n- L'utilisateur est responsable d'appeler `free()`\n- Comptage de rfrences interne pour la scurit des portes/raffectations (voir ci-dessous)\n\n### Comptage de rfrences interne\n\nLe runtime utilise le comptage de rfrences en interne pour grer la dure de vie des objets  travers les portes. Pour la plupart des variables locales, le nettoyage est automatique.\n\n**Automatique (pas de `free()` ncessaire) :**\n- Les variables locales de types  comptage de rfrences (buffer, array, object, string) sont libres  la sortie de la porte\n- Les anciennes valeurs sont libres lors de la raffectation des variables\n- Les lments des conteneurs sont librs quand les conteneurs sont librs\n\n**`free()` manuel requis :**\n- Pointeurs bruts de `alloc()` - toujours\n- Nettoyage anticip avant la fin de la porte\n- Donnes  longue dure de vie/globales\n\nVoir le [Guide de gestion de la mmoire](../language-guide/memory.md#internal-reference-counting) pour les dtails.\n\n---\n\n## Types de pointeurs\n\n### ptr (Pointeur brut)\n\n**Type :** `ptr`\n\n**Description :** Adresse mmoire brute sans vrification des limites ni suivi.\n\n**Taille :** 8 octets\n\n**Cas d'utilisation :**\n- Oprations mmoire de bas niveau\n- FFI (Interface de fonction trangre)\n- Performance maximale (pas de surcharge)\n\n**Scurit :** Non sr - pas de vrification des limites, l'utilisateur doit suivre la dure de vie\n\n**Exemples :**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n---\n\n### buffer (Buffer scuris)\n\n**Type :** `buffer`\n\n**Description :** Enveloppe de pointeur scurise avec vrification des limites.\n\n**Structure :** Pointeur + longueur + capacit + ref_count\n\n**Proprits :**\n- `.length` - Taille du buffer (i32)\n- `.capacity` - Capacit alloue (i32)\n\n**Cas d'utilisation :**\n- La plupart des allocations mmoire\n- Quand la scurit est importante\n- Tableaux dynamiques\n\n**Scurit :** Vrification des limites sur l'accs par index\n\n**Comptage de rfrences :** Les buffers sont compts par rfrences en interne. Librs automatiquement  la sortie de la porte ou lors de la raffectation de la variable. Utilisez `free()` pour un nettoyage anticip ou les donnes  longue dure de vie.\n\n**Exemples :**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Vrifi aux limites\nprint(b.length);        // 64\nfree(b);\n```\n\n---\n\n## Fonctions d'allocation mmoire\n\n### alloc\n\nAlloue de la mmoire brute.\n\n**Signature :**\n```hemlock\nalloc(size: i32): ptr\n```\n\n**Paramtres :**\n- `size` - Nombre d'octets  allouer\n\n**Retourne :** Pointeur vers la mmoire alloue (`ptr`)\n\n**Exemples :**\n```hemlock\nlet p = alloc(1024);        // Allouer 1 Ko\nmemset(p, 0, 1024);         // Initialiser  zro\nfree(p);                    // Librer une fois termin\n\n// Allouer pour une structure\nlet struct_size = 16;\nlet p2 = alloc(struct_size);\n```\n\n**Comportement :**\n- Retourne de la mmoire non initialise\n- La mmoire doit tre libre manuellement\n- Retourne `null` en cas d'chec d'allocation (l'appelant doit vrifier)\n\n**Voir aussi :** `buffer()` pour une alternative plus sre\n\n---\n\n### buffer\n\nAlloue un buffer scuris avec vrification des limites.\n\n**Signature :**\n```hemlock\nbuffer(size: i32): buffer\n```\n\n**Paramtres :**\n- `size` - Taille du buffer en octets\n\n**Retourne :** Objet buffer\n\n**Exemples :**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\nprint(buf.capacity);        // 256\n\n// Accs avec vrification des limites\nbuf[0] = 65;                // 'A'\nbuf[255] = 90;              // 'Z'\n// buf[256] = 0;            // ERREUR: hors limites\n\nfree(buf);\n```\n\n**Proprits :**\n- `.length` - Taille actuelle (i32)\n- `.capacity` - Capacit alloue (i32)\n\n**Comportement :**\n- Initialise la mmoire  zro\n- Fournit une vrification des limites sur l'accs par index\n- Retourne `null` en cas d'chec d'allocation (l'appelant doit vrifier)\n- Doit tre libr manuellement\n\n---\n\n### free\n\nLibre la mmoire alloue.\n\n**Signature :**\n```hemlock\nfree(ptr: ptr | buffer): null\n```\n\n**Paramtres :**\n- `ptr` - Pointeur ou buffer  librer\n\n**Retourne :** `null`\n\n**Exemples :**\n```hemlock\n// Librer un pointeur brut\nlet p = alloc(1024);\nfree(p);\n\n// Librer un buffer\nlet buf = buffer(256);\nfree(buf);\n```\n\n**Comportement :**\n- Libre la mmoire alloue par `alloc()` ou `buffer()`\n- Double-free provoque un crash (responsabilit de l'utilisateur de l'viter)\n- Librer des pointeurs invalides provoque un comportement indfini\n\n**Important :** Vous allouez, vous librez. Pas de nettoyage automatique.\n\n---\n\n### realloc\n\nRedimensionne la mmoire alloue.\n\n**Signature :**\n```hemlock\nrealloc(ptr: ptr, new_size: i32): ptr\n```\n\n**Paramtres :**\n- `ptr` - Pointeur  redimensionner\n- `new_size` - Nouvelle taille en octets\n\n**Retourne :** Pointeur vers la mmoire redimensionne (peut tre une adresse diffrente)\n\n**Exemples :**\n```hemlock\nlet p = alloc(100);\n// ... utiliser la mmoire ...\n\n// Besoin de plus d'espace\np = realloc(p, 200);        // Maintenant 200 octets\n// ... utiliser la mmoire tendue ...\n\nfree(p);\n```\n\n**Comportement :**\n- Peut dplacer la mmoire vers un nouvel emplacement\n- Prserve les donnes existantes (jusqu'au minimum de l'ancienne/nouvelle taille)\n- L'ancien pointeur est invalide aprs un realloc russi (utiliser le pointeur retourn)\n- Si new_size est plus petit, les donnes sont tronques\n- Retourne `null` en cas d'chec d'allocation (le pointeur original reste valide)\n\n**Important :** Vrifiez toujours `null` et mettez  jour votre variable pointeur avec le rsultat.\n\n---\n\n## Oprations mmoire\n\n### memset\n\nRemplit la mmoire avec une valeur d'octet.\n\n**Signature :**\n```hemlock\nmemset(ptr: ptr, byte: i32, size: i32): null\n```\n\n**Paramtres :**\n- `ptr` - Pointeur vers la mmoire\n- `byte` - Valeur d'octet  remplir (0-255)\n- `size` - Nombre d'octets  remplir\n\n**Retourne :** `null`\n\n**Exemples :**\n```hemlock\nlet p = alloc(100);\n\n// Mettre la mmoire  zro\nmemset(p, 0, 100);\n\n// Remplir avec une valeur spcifique\nmemset(p, 0xFF, 100);\n\n// Initialiser un buffer\nlet buf = alloc(256);\nmemset(buf, 65, 256);       // Remplir avec 'A'\n\nfree(p);\nfree(buf);\n```\n\n**Comportement :**\n- crit la valeur d'octet dans chaque octet de la plage\n- La valeur d'octet est tronque  8 bits (0-255)\n- Pas de vrification des limites (non sr)\n\n---\n\n### memcpy\n\nCopie la mmoire de la source vers la destination.\n\n**Signature :**\n```hemlock\nmemcpy(dest: ptr, src: ptr, size: i32): null\n```\n\n**Paramtres :**\n- `dest` - Pointeur de destination\n- `src` - Pointeur source\n- `size` - Nombre d'octets  copier\n\n**Retourne :** `null`\n\n**Exemples :**\n```hemlock\nlet src = alloc(100);\nlet dest = alloc(100);\n\n// Initialiser la source\nmemset(src, 65, 100);\n\n// Copier vers la destination\nmemcpy(dest, src, 100);\n\n// dest contient maintenant les mmes donnes que src\n\nfree(src);\nfree(dest);\n```\n\n**Comportement :**\n- Copie octet par octet de src vers dest\n- Pas de vrification des limites (non sr)\n- Les rgions qui se chevauchent ont un comportement indfini (utiliser avec prcaution)\n\n---\n\n## Oprations mmoire types\n\n### sizeof\n\nObtient la taille d'un type en octets.\n\n**Signature :**\n```hemlock\nsizeof(type): i32\n```\n\n**Paramtres :**\n- `type` - Identifiant de type (par ex., `i32`, `f64`, `ptr`)\n\n**Retourne :** Taille en octets (i32)\n\n**Tailles des types :**\n\n| Type | Taille (octets) |\n|------|-----------------|\n| `i8` | 1 |\n| `i16` | 2 |\n| `i32`, `integer` | 4 |\n| `i64` | 8 |\n| `u8`, `byte` | 1 |\n| `u16` | 2 |\n| `u32` | 4 |\n| `u64` | 8 |\n| `f32` | 4 |\n| `f64`, `number` | 8 |\n| `bool` | 1 |\n| `ptr` | 8 |\n| `rune` | 4 |\n\n**Exemples :**\n```hemlock\nlet int_size = sizeof(i32);      // 4\nlet ptr_size = sizeof(ptr);      // 8\nlet float_size = sizeof(f64);    // 8\nlet byte_size = sizeof(u8);      // 1\nlet rune_size = sizeof(rune);    // 4\n\n// Calculer la taille d'allocation d'un tableau\nlet count = 100;\nlet total = sizeof(i32) * count; // 400 octets\n```\n\n**Comportement :**\n- Retourne 0 pour les types inconnus\n- Accepte  la fois les identifiants de type et les chanes de type\n\n---\n\n### talloc\n\nAlloue un tableau de valeurs types.\n\n**Signature :**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**Paramtres :**\n- `type` - Type  allouer (par ex., `i32`, `f64`, `ptr`)\n- `count` - Nombre d'lments (doit tre positif)\n\n**Retourne :** Pointeur vers le tableau allou, ou `null` en cas d'chec d'allocation\n\n**Exemples :**\n```hemlock\nlet arr = talloc(i32, 100);      // Tableau de 100 i32 (400 octets)\nlet floats = talloc(f64, 50);    // Tableau de 50 f64 (400 octets)\nlet bytes = talloc(u8, 1024);    // Tableau de 1024 octets\n\n// Toujours vrifier l'chec d'allocation\nif (arr == null) {\n    panic(\"chec d'allocation\");\n}\n\n// Utiliser la mmoire alloue\n// ...\n\nfree(arr);\nfree(floats);\nfree(bytes);\n```\n\n**Comportement :**\n- Alloue `sizeof(type) * count` octets\n- Retourne de la mmoire non initialise\n- La mmoire doit tre libre manuellement avec `free()`\n- Retourne `null` en cas d'chec d'allocation (l'appelant doit vrifier)\n- Panique si count n'est pas positif\n\n---\n\n## Proprits des buffers\n\n### .length\n\nObtient la taille du buffer.\n\n**Type :** `i32`\n\n**Accs :** Lecture seule\n\n**Exemples :**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\n\nlet buf2 = buffer(1024);\nprint(buf2.length);         // 1024\n```\n\n---\n\n### .capacity\n\nObtient la capacit du buffer.\n\n**Type :** `i32`\n\n**Accs :** Lecture seule\n\n**Exemples :**\n```hemlock\nlet buf = buffer(256);\nprint(buf.capacity);        // 256\n```\n\n**Note :** Actuellement, `.length` et `.capacity` sont identiques pour les buffers crs avec `buffer()`.\n\n---\n\n## Modles d'utilisation\n\n### Modle d'allocation basique\n\n```hemlock\n// Allouer\nlet p = alloc(1024);\nif (p == null) {\n    panic(\"chec d'allocation\");\n}\n\n// Utiliser\nmemset(p, 0, 1024);\n\n// Librer\nfree(p);\n```\n\n### Modle de buffer scuris\n\n```hemlock\n// Allouer le buffer\nlet buf = buffer(256);\nif (buf == null) {\n    panic(\"chec d'allocation du buffer\");\n}\n\n// Utiliser avec vrification des limites\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\n// Librer\nfree(buf);\n```\n\n### Modle de croissance dynamique\n\n```hemlock\nlet size = 100;\nlet p = alloc(size);\nif (p == null) {\n    panic(\"chec d'allocation\");\n}\n\n// ... utiliser la mmoire ...\n\n// Besoin de plus d'espace - vrifier l'chec\nlet new_p = realloc(p, 200);\nif (new_p == null) {\n    // Le pointeur original est toujours valide, nettoyer\n    free(p);\n    panic(\"chec de realloc\");\n}\np = new_p;\nsize = 200;\n\n// ... utiliser la mmoire tendue ...\n\nfree(p);\n```\n\n### Modle de copie mmoire\n\n```hemlock\nlet original = alloc(100);\nmemset(original, 65, 100);\n\n// Crer une copie\nlet copy = alloc(100);\nmemcpy(copy, original, 100);\n\nfree(original);\nfree(copy);\n```\n\n---\n\n## Considrations de scurit\n\n**La gestion de la mmoire de Hemlock est NON SRE par conception :**\n\n### Piges courants\n\n**1. Fuites de mmoire**\n```hemlock\n// MAUVAIS: Fuite de mmoire\nfn create_buffer() {\n    let p = alloc(1024);\n    return null;  // Mmoire fuite !\n}\n\n// BON: Nettoyage appropri\nfn create_buffer() {\n    let p = alloc(1024);\n    // ... utiliser la mmoire ...\n    free(p);\n    return null;\n}\n```\n\n**2. Utilisation aprs libration**\n```hemlock\n// MAUVAIS: Utilisation aprs libration\nlet p = alloc(100);\nfree(p);\nmemset(p, 0, 100);  // CRASH: utilisation de mmoire libre\n\n// BON: Ne pas utiliser aprs libration\nlet p2 = alloc(100);\nmemset(p2, 0, 100);\nfree(p2);\n// Ne pas toucher p2 aprs cela\n```\n\n**3. Double libration**\n```hemlock\n// MAUVAIS: Double libration\nlet p = alloc(100);\nfree(p);\nfree(p);  // CRASH: double libration\n\n// BON: Librer une fois\nlet p2 = alloc(100);\nfree(p2);\n```\n\n**4. Dpassement de buffer (ptr)**\n```hemlock\n// MAUVAIS: Dpassement de buffer avec ptr\nlet p = alloc(10);\nmemset(p, 65, 100);  // CRASH: criture au-del de l'allocation\n\n// BON: Utiliser buffer pour la vrification des limites\nlet buf = buffer(10);\n// buf[100] = 65;  // ERREUR: la vrification des limites choue\n```\n\n**5. Pointeurs pendants**\n```hemlock\n// MAUVAIS: Pointeur pendant\nlet p1 = alloc(100);\nlet p2 = p1;\nfree(p1);\nmemset(p2, 0, 100);  // CRASH: p2 est pendant\n\n// BON: Suivre la proprit avec soin\nlet p = alloc(100);\n// ... utiliser p ...\nfree(p);\n// Ne pas garder d'autres rfrences  p\n```\n\n**6. chec d'allocation non vrifi**\n```hemlock\n// MAUVAIS: Ne pas vrifier null\nlet p = alloc(1000000000);  // Peut chouer avec peu de mmoire\nmemset(p, 0, 1000000000);   // CRASH: p est null\n\n// BON: Toujours vrifier le rsultat de l'allocation\nlet p2 = alloc(1000000000);\nif (p2 == null) {\n    panic(\"plus de mmoire\");\n}\nmemset(p2, 0, 1000000000);\nfree(p2);\n```\n\n---\n\n## Quand utiliser quoi\n\n### Utilisez `buffer()` quand :\n- Vous avez besoin de vrification des limites\n- Vous travaillez avec des donnes dynamiques\n- La scurit est importante\n- Vous apprenez Hemlock\n\n### Utilisez `alloc()` quand :\n- Performance maximale ncessaire\n- FFI/interface avec C\n- Vous connaissez l'agencement mmoire exact\n- Vous tes un expert\n\n### Utilisez `realloc()` quand :\n- Croissance/rduction des allocations\n- Tableaux dynamiques\n- Vous devez prserver les donnes\n\n---\n\n## Rsum complet des fonctions\n\n| Fonction  | Signature                              | Retourne | Description                    |\n|-----------|----------------------------------------|----------|--------------------------------|\n| `alloc`   | `(size: i32)`                          | `ptr`    | Allouer de la mmoire brute    |\n| `buffer`  | `(size: i32)`                          | `buffer` | Allouer un buffer scuris     |\n| `free`    | `(ptr: ptr \\| buffer)`                 | `null`   | Librer la mmoire             |\n| `realloc` | `(ptr: ptr, new_size: i32)`            | `ptr`    | Redimensionner l'allocation    |\n| `memset`  | `(ptr: ptr, byte: i32, size: i32)`     | `null`   | Remplir la mmoire             |\n| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`     | `null`   | Copier la mmoire              |\n| `sizeof`  | `(type)`                               | `i32`    | Obtenir la taille du type en octets |\n| `talloc`  | `(type, count: i32)`                   | `ptr`    | Allouer un tableau typ        |\n\n---\n\n## Voir aussi\n\n- [Systme de types](#reference-type-system) - Types pointeur et buffer\n- [Fonctions intgres](#reference-builtins) - Toutes les fonctions intgres\n- [API String](#reference-string-api) - Mthode `.to_bytes()` des chanes\n"}, "Rfrence API -> API de Concurrence": {"id": "reference-concurrency-api", "content": "# Rfrence de l'API Concurrency\n\nRfrence complte pour le systme async/concurrence de Hemlock.\n\n---\n\n## Aperu\n\nHemlock fournit une **concurrence structure** avec un vritable paralllisme multi-thread utilisant les threads POSIX (pthreads). Chaque tche lance s'excute sur un thread OS spar, permettant une excution vritablement parallle sur plusieurs curs CPU.\n\n**Caractristiques principales :**\n- Vritable paralllisme multi-thread (pas de green threads)\n- Syntaxe de fonction async\n- Lancement et jointure de tches\n- Canaux thread-safe\n- Propagation des exceptions\n\n**Modle de threading :**\n-  Vrais threads OS (POSIX pthreads)\n-  Vritable paralllisme (plusieurs curs CPU)\n-  Ordonnanc par le noyau (multitche premptif)\n-  Synchronisation thread-safe (mutex, variables de condition)\n\n---\n\n## Fonctions async\n\n### Dclaration de fonction async\n\nLes fonctions peuvent tre dclares comme `async` pour indiquer qu'elles sont conues pour l'excution concurrente.\n\n**Syntaxe :**\n```hemlock\nasync fn nom_fonction(params): type_retour {\n    // corps de la fonction\n}\n```\n\n**Exemples :**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nasync fn process_data(data: string) {\n    print(\"Traitement:\", data);\n    return null;\n}\n```\n\n**Comportement :**\n- `async fn` dclare une fonction asynchrone\n- Peut tre appele de manire synchrone (s'excute dans le thread courant)\n- Peut tre lance comme tche concurrente (s'excute sur un nouveau thread)\n- Quand lance, s'excute sur son propre thread OS\n\n**Note :** Le mot-cl `await` est rserv pour une utilisation future mais n'est pas actuellement implment.\n\n---\n\n## Gestion des tches\n\n### spawn\n\nCre et dmarre une nouvelle tche concurrente.\n\n**Signature :**\n```hemlock\nspawn(async_fn: function, ...args): task\n```\n\n**Paramtres :**\n- `async_fn` - Fonction async  excuter\n- `...args` - Arguments  passer  la fonction\n\n**Retourne :** Handle de tche\n\n**Exemples :**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Lancer une seule tche\nlet t = spawn(compute, 1000);\nlet result = join(t);\nprint(result);\n\n// Lancer plusieurs tches (s'excutent en parallle !)\nlet t1 = spawn(compute, 100);\nlet t2 = spawn(compute, 200);\nlet t3 = spawn(compute, 300);\n\n// Les trois s'excutent simultanment\nlet r1 = join(t1);\nlet r2 = join(t2);\nlet r3 = join(t3);\n```\n\n**Comportement :**\n- Cre un nouveau thread OS via `pthread_create()`\n- Commence l'excution de la fonction immdiatement\n- Retourne un handle de tche pour une jointure ultrieure\n- Les tches s'excutent en parallle sur des curs CPU spars\n\n---\n\n### join\n\nAttend la fin de la tche et rcupre le rsultat.\n\n**Signature :**\n```hemlock\njoin(task: task): any\n```\n\n**Paramtres :**\n- `task` - Handle de tche de `spawn()`\n\n**Retourne :** Valeur de retour de la tche\n\n**Exemples :**\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nlet t = spawn(factorial, 10);\nlet result = join(t);  // Bloque jusqu' ce que la tche se termine\nprint(result);         // 3628800\n```\n\n**Comportement :**\n- Bloque le thread courant jusqu' ce que la tche se termine\n- Retourne la valeur de retour de la tche\n- Propage les exceptions leves par la tche\n- Nettoie les ressources de la tche aprs le retour\n\n**Gestion des erreurs :**\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"La tche a chou !\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Intercept:\", e);  // \"Intercept: La tche a chou !\"\n}\n```\n\n---\n\n### detach\n\nDtache la tche (excution fire-and-forget).\n\n**Signature :**\n```hemlock\ndetach(task: task): null\n```\n\n**Paramtres :**\n- `task` - Handle de tche de `spawn()`\n\n**Retourne :** `null`\n\n**Exemples :**\n```hemlock\nasync fn background_work() {\n    print(\"Travail en arrire-plan...\");\n    return null;\n}\n\nlet t = spawn(background_work);\ndetach(t);  // La tche continue de s'excuter indpendamment\n\n// Impossible de joindre une tche dtache\n// join(t);  // ERREUR\n```\n\n**Comportement :**\n- La tche continue de s'excuter indpendamment\n- Impossible de faire `join()` sur une tche dtache\n- La tche et le thread sont automatiquement nettoys quand la tche se termine\n\n**Cas d'utilisation :**\n- Tches en arrire-plan fire-and-forget\n- Tches de journalisation/surveillance\n- Tches qui n'ont pas besoin de retourner de valeurs\n\n---\n\n## Canaux\n\nLes canaux fournissent une communication thread-safe entre les tches.\n\n### channel\n\nCre un canal avec buffer.\n\n**Signature :**\n```hemlock\nchannel(capacity: i32): channel\n```\n\n**Paramtres :**\n- `capacity` - Taille du buffer (nombre de valeurs)\n\n**Retourne :** Objet channel\n\n**Exemples :**\n```hemlock\nlet ch = channel(10);  // Canal avec buffer de capacit 10\nlet ch2 = channel(1);  // Buffer minimal (synchrone)\nlet ch3 = channel(100); // Grand buffer\n```\n\n**Comportement :**\n- Cre un canal thread-safe\n- Utilise des mutex pthread pour la synchronisation\n- La capacit est fixe  la cration\n\n---\n\n### Mthodes des canaux\n\n#### send\n\nEnvoie une valeur au canal (bloque si plein).\n\n**Signature :**\n```hemlock\nchannel.send(value: any): null\n```\n\n**Paramtres :**\n- `value` - Valeur  envoyer (n'importe quel type)\n\n**Retourne :** `null`\n\n**Exemples :**\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet t = spawn(producer, ch, 5);\n```\n\n**Comportement :**\n- Envoie la valeur au canal\n- Bloque si le canal est plein\n- Thread-safe (utilise un mutex)\n- Retourne aprs que la valeur est envoye\n\n---\n\n#### recv\n\nReoit une valeur du canal (bloque si vide).\n\n**Signature :**\n```hemlock\nchannel.recv(): any\n```\n\n**Retourne :** Valeur du canal, ou `null` si le canal est ferm et vide\n\n**Exemples :**\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet t = spawn(consumer, ch, 5);\n```\n\n**Comportement :**\n- Reoit une valeur du canal\n- Bloque si le canal est vide\n- Retourne `null` si le canal est ferm et vide\n- Thread-safe (utilise un mutex)\n\n---\n\n#### close\n\nFerme le canal (plus d'envois autoriss).\n\n**Signature :**\n```hemlock\nchannel.close(): null\n```\n\n**Retourne :** `null`\n\n**Exemples :**\n```hemlock\nasync fn producer(ch) {\n    ch.send(1);\n    ch.send(2);\n    ch.send(3);\n    ch.close();  // Signale qu'il n'y a plus de valeurs\n    return null;\n}\n\nasync fn consumer(ch) {\n    while (true) {\n        let val = ch.recv();\n        if (val == null) {\n            break;  // Canal ferm\n        }\n        print(val);\n    }\n    return null;\n}\n```\n\n**Comportement :**\n- Ferme le canal\n- Plus d'envois autoriss\n- `recv()` retourne `null` quand le canal est vide\n- Thread-safe\n\n---\n\n## Exemple complet de concurrence\n\n### Modle producteur-consommateur\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        print(\"Production:\", i);\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        print(\"Consommation:\", val);\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Crer le canal\nlet ch = channel(10);\n\n// Lancer producteur et consommateur\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Attendre la fin\njoin(p);\nlet total = join(c);\nprint(\"Total:\", total);  // 0+10+20+30+40 = 100\n```\n\n---\n\n## Calcul parallle\n\n### Exemple de tches multiples\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Lancer plusieurs tches (s'excutent en parallle !)\nlet t1 = spawn(factorial, 5);   // Thread 1\nlet t2 = spawn(factorial, 6);   // Thread 2\nlet t3 = spawn(factorial, 7);   // Thread 3\nlet t4 = spawn(factorial, 8);   // Thread 4\n\n// Les quatre calculent simultanment !\n\n// Attendre les rsultats\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\nlet f8 = join(t4);  // 40320\n\nprint(f5, f6, f7, f8);\n```\n\n---\n\n## Cycle de vie des tches\n\n### Transitions d'tat\n\n1. **Cre** - Tche lance mais pas encore en excution\n2. **En cours** - Tche en excution sur un thread OS\n3. **Termine** - Tche termine (rsultat disponible)\n4. **Jointe** - Rsultat rcupr, ressources nettoyes\n5. **Dtache** - Tche continue indpendamment\n\n### Exemple de cycle de vie\n\n```hemlock\nasync fn work(n: i32): i32 {\n    return n * 2;\n}\n\n// 1. Crer la tche\nlet t = spawn(work, 21);  // tat: En cours\n\n// La tche s'excute sur un thread spar...\n\n// 2. Joindre la tche\nlet result = join(t);     // tat: Termine  Jointe\nprint(result);            // 42\n\n// Ressources de la tche nettoyes aprs join\n```\n\n### Cycle de vie dtach\n\n```hemlock\nasync fn background() {\n    print(\"Tche en arrire-plan en cours\");\n    return null;\n}\n\n// 1. Crer la tche\nlet t = spawn(background);  // tat: En cours\n\n// 2. Dtacher la tche\ndetach(t);                  // tat: Dtache\n\n// La tche continue de s'excuter indpendamment\n// Ressources nettoyes par l'OS quand termine\n```\n\n---\n\n## Gestion des erreurs\n\n### Propagation des exceptions\n\nLes exceptions leves dans les tches sont propages lors de la jointure :\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"La tche a chou !\";\n    }\n    return 42;\n}\n\n// Tche qui russit\nlet t1 = spawn(risky_operation, 0);\nlet result1 = join(t1);  // 42\n\n// Tche qui choue\nlet t2 = spawn(risky_operation, 1);\ntry {\n    let result2 = join(t2);\n} catch (e) {\n    print(\"Intercept:\", e);  // \"Intercept: La tche a chou !\"\n}\n```\n\n### Gestion de plusieurs tches\n\n```hemlock\nasync fn work(id: i32, should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Tche \" + typeof(id) + \" a chou\";\n    }\n    return id * 10;\n}\n\nlet t1 = spawn(work, 1, 0);\nlet t2 = spawn(work, 2, 1);  // Va chouer\nlet t3 = spawn(work, 3, 0);\n\n// Joindre avec gestion des erreurs\ntry {\n    let r1 = join(t1);  // OK\n    print(\"Tche 1:\", r1);\n\n    let r2 = join(t2);  // Lve une exception\n    print(\"Tche 2:\", r2);  // Jamais atteint\n} catch (e) {\n    print(\"Erreur:\", e);  // \"Erreur: Tche 2 a chou\"\n}\n\n// Peut toujours joindre la tche restante\nlet r3 = join(t3);\nprint(\"Tche 3:\", r3);\n```\n\n---\n\n## Caractristiques de performance\n\n### Vritable paralllisme\n\n```hemlock\nasync fn cpu_intensive(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Excution squentielle\nlet start = get_time();\nlet r1 = cpu_intensive(10000000);\nlet r2 = cpu_intensive(10000000);\nlet sequential_time = get_time() - start;\n\n// Excution parallle\nlet start2 = get_time();\nlet t1 = spawn(cpu_intensive, 10000000);\nlet t2 = spawn(cpu_intensive, 10000000);\njoin(t1);\njoin(t2);\nlet parallel_time = get_time() - start2;\n\n// parallel_time devrait tre ~50% de sequential_time sur les systmes multi-curs\n```\n\n**Caractristiques prouves :**\n- N tches peuvent utiliser N curs CPU simultanment\n- Les tests de stress montrent 8-9x le temps CPU vs temps rel (preuve de paralllisme)\n- Surcharge de thread : ~8 Ko de pile + surcharge pthread par tche\n- Les oprations bloquantes dans une tche ne bloquent pas les autres\n\n---\n\n## Dtails d'implmentation\n\n### Modle de threading\n\n- **Threading 1:1** - Chaque tche = 1 thread OS (`pthread`)\n- **Ordonnanc par le noyau** - Le noyau OS distribue les threads sur les curs\n- **Multitche premptif** - L'OS peut interrompre et changer de thread\n- **Pas de GIL** - Pas de Global Interpreter Lock (contrairement  Python)\n\n### Synchronisation\n\n- **Mutex** - Les canaux utilisent `pthread_mutex_t`\n- **Variables de condition** - send/recv bloquants utilisent `pthread_cond_t`\n- **Oprations lock-free** - Les transitions d'tat des tches sont atomiques\n\n### Mmoire et nettoyage\n\n- **Tches jointes** - Automatiquement nettoyes aprs `join()`\n- **Tches dtaches** - Automatiquement nettoyes quand la tche se termine\n- **Canaux** - Compts par rfrences, librs quand plus utiliss\n\n---\n\n## Limitations\n\n- Pas de `select()` pour le multiplexage de plusieurs canaux\n- Pas d'ordonnanceur work-stealing (1 thread par tche)\n- Pas d'intgration d'E/S async (les oprations fichier/rseau bloquent)\n- Capacit du canal fixe  la cration\n\n---\n\n## Rsum complet de l'API\n\n### Fonctions\n\n| Fonction  | Signature                         | Retourne  | Description                          |\n|-----------|-----------------------------------|-----------|--------------------------------------|\n| `spawn`   | `(async_fn: function, ...args)`   | `task`    | Crer et dmarrer une tche concurrente |\n| `join`    | `(task: task)`                    | `any`     | Attendre la tche, obtenir le rsultat |\n| `detach`  | `(task: task)`                    | `null`    | Dtacher la tche (fire-and-forget)  |\n| `channel` | `(capacity: i32)`                 | `channel` | Crer un canal thread-safe           |\n\n### Mthodes des canaux\n\n| Mthode | Signature       | Retourne | Description                           |\n|---------|-----------------|----------|---------------------------------------|\n| `send`  | `(value: any)`  | `null`   | Envoyer valeur (bloque si plein)      |\n| `recv`  | `()`            | `any`    | Recevoir valeur (bloque si vide)      |\n| `close` | `()`            | `null`   | Fermer le canal                       |\n\n### Types\n\n| Type      | Description                          |\n|-----------|--------------------------------------|\n| `task`    | Handle pour tche concurrente        |\n| `channel` | Canal de communication thread-safe   |\n\n---\n\n## Bonnes pratiques\n\n###  faire\n\n Utiliser les canaux pour la communication entre tches\n Grer les exceptions des tches jointes\n Fermer les canaux quand l'envoi est termin\n Utiliser `join()` pour obtenir les rsultats et nettoyer\n Ne lancer que des fonctions async\n\n###  viter\n\n Ne pas partager d'tat mutable sans synchronisation\n Ne pas joindre la mme tche deux fois\n Ne pas envoyer sur des canaux ferms\n Ne pas lancer de fonctions non-async\n Ne pas oublier de joindre les tches (sauf si dtaches)\n\n---\n\n## Voir aussi\n\n- [Fonctions intgres](#reference-builtins) - `spawn()`, `join()`, `detach()`, `channel()`\n- [Systme de types](#reference-type-system) - Types task et channel\n"}, "Rfrence API -> API des Chanes": {"id": "reference-string-api", "content": "# Rfrence de l'API String\n\nRfrence complte pour le type string de Hemlock et ses 19 mthodes.\n\n---\n\n## Aperu\n\nLes chanes de caractres (strings) dans Hemlock sont des squences **encodes en UTF-8, mutables, alloues sur le tas** avec support complet d'Unicode. Toutes les oprations fonctionnent avec des **points de code** (caractres), pas des octets.\n\n**Caractristiques principales :**\n- Encodage UTF-8 (U+0000  U+10FFFF)\n- Mutables (peuvent modifier les caractres sur place)\n- Indexation base sur les points de code\n- 19 mthodes intgres\n- Concatnation automatique avec l'oprateur `+`\n\n---\n\n## Type String\n\n**Type :** `string`\n\n**Proprits :**\n- `.length` - Nombre de points de code (caractres)\n- `.byte_length` - Nombre d'octets UTF-8\n\n**Syntaxe littrale :** Guillemets doubles `\"texte\"`\n\n**Exemples :**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5 (points de code)\nprint(s.byte_length);   // 5 (octets)\n\nlet emoji = \"\";\nprint(emoji.length);        // 1 (un point de code)\nprint(emoji.byte_length);   // 4 (quatre octets UTF-8)\n```\n\n---\n\n## Indexation\n\nLes chanes supportent l'indexation base sur les points de code en utilisant `[]` :\n\n**Accs en lecture :**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Retourne le rune 'h'\n```\n\n**Accs en criture :**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Modifie avec un rune (maintenant \"Hello\")\n```\n\n**Exemple UTF-8 :**\n```hemlock\nlet text = \"Hi!\";\nprint(text[0]);         // 'H'\nprint(text[1]);         // 'i'\nprint(text[2]);         // '' (un point de code)\nprint(text[3]);         // '!'\n```\n\n---\n\n## Concatnation\n\nUtilisez l'oprateur `+` pour concatner des chanes et des runes :\n\n**String + String :**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n```\n\n**String + Rune :**\n```hemlock\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\nlet decorated = \"Text\" + '';      // \"Text\"\n```\n\n**Rune + String :**\n```hemlock\nlet prefix = '>' + \" Message\";     // \"> Message\"\nlet bullet = '' + \" Item\";        // \" Item\"\n```\n\n**Concatnations multiples :**\n```hemlock\nlet msg = \"Hi \" + '' + \" World \" + '';  // \"Hi  World \"\n```\n\n---\n\n## Proprits des chanes\n\n### .length\n\nObtient le nombre de points de code Unicode (caractres).\n\n**Type :** `i32`\n\n**Exemples :**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5\n\nlet emoji = \"\";\nprint(emoji.length);    // 1 (un point de code)\n\nlet text = \"Hello !\";\nprint(text.length);     // 8 (7 ASCII + 1 emoji)\n```\n\n---\n\n### .byte_length\n\nObtient le nombre d'octets UTF-8.\n\n**Type :** `i32`\n\n**Exemples :**\n```hemlock\nlet s = \"hello\";\nprint(s.byte_length);   // 5 (1 octet par caractre ASCII)\n\nlet emoji = \"\";\nprint(emoji.byte_length); // 4 (l'emoji fait 4 octets UTF-8)\n\nlet text = \"Hello !\";\nprint(text.byte_length);  // 11 (7 ASCII + 4 pour l'emoji)\n```\n\n---\n\n## Mthodes des chanes\n\n### Sous-chane et dcoupage\n\n#### substr\n\nExtrait une sous-chane par position et longueur.\n\n**Signature :**\n```hemlock\nstring.substr(start: i32, length: i32): string\n```\n\n**Paramtres :**\n- `start` - Index du point de code de dpart (base 0)\n- `length` - Nombre de points de code  extraire\n\n**Retourne :** Nouvelle chane\n\n**Exemples :**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\"\nlet first = s.substr(0, 5);     // \"hello\"\n\n// Exemple UTF-8\nlet text = \"Hi!\";\nlet emoji = text.substr(2, 1);  // \"\"\n```\n\n---\n\n#### slice\n\nExtrait une sous-chane par plage (fin exclusive).\n\n**Signature :**\n```hemlock\nstring.slice(start: i32, end: i32): string\n```\n\n**Paramtres :**\n- `start` - Index du point de code de dpart (base 0)\n- `end` - Index du point de code de fin (exclusif)\n\n**Retourne :** Nouvelle chane\n\n**Exemples :**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.slice(0, 5);        // \"hello\"\nlet world = s.slice(6, 11);     // \"world\"\n\n// Exemple UTF-8\nlet text = \"Hi!\";\nlet first_three = text.slice(0, 3);  // \"Hi\"\n```\n\n---\n\n### Recherche\n\n#### find\n\nTrouve la premire occurrence d'une sous-chane.\n\n**Signature :**\n```hemlock\nstring.find(needle: string): i32\n```\n\n**Paramtres :**\n- `needle` - Sous-chane  rechercher\n\n**Retourne :** Index du point de code de la premire occurrence, ou `-1` si non trouve\n\n**Exemples :**\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6\nlet pos2 = s.find(\"foo\");       // -1 (non trouve)\nlet pos3 = s.find(\"l\");         // 2 (premier 'l')\n```\n\n---\n\n#### contains\n\nVrifie si la chane contient une sous-chane.\n\n**Signature :**\n```hemlock\nstring.contains(needle: string): bool\n```\n\n**Paramtres :**\n- `needle` - Sous-chane  rechercher\n\n**Retourne :** `true` si trouve, `false` sinon\n\n**Exemples :**\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n---\n\n### Sparation et jonction\n\n#### split\n\nSpare la chane en un tableau par dlimiteur.\n\n**Signature :**\n```hemlock\nstring.split(delimiter: string): array\n```\n\n**Paramtres :**\n- `delimiter` - Chane sur laquelle sparer\n\n**Retourne :** Tableau de chanes\n\n**Exemples :**\n```hemlock\nlet csv = \"a,b,c\";\nlet parts = csv.split(\",\");     // [\"a\", \"b\", \"c\"]\n\nlet path = \"/usr/local/bin\";\nlet dirs = path.split(\"/\");     // [\"\", \"usr\", \"local\", \"bin\"]\n\nlet text = \"hello world foo\";\nlet words = text.split(\" \");    // [\"hello\", \"world\", \"foo\"]\n```\n\n---\n\n#### trim\n\nSupprime les espaces blancs au dbut et  la fin.\n\n**Signature :**\n```hemlock\nstring.trim(): string\n```\n\n**Retourne :** Nouvelle chane sans espaces blancs\n\n**Exemples :**\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet text = \"\\n\\t  world  \\n\";\nlet clean2 = text.trim();       // \"world\"\n```\n\n---\n\n### Conversion de casse\n\n#### to_upper\n\nConvertit la chane en majuscules.\n\n**Signature :**\n```hemlock\nstring.to_upper(): string\n```\n\n**Retourne :** Nouvelle chane en majuscules\n\n**Exemples :**\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\nlet mixed = \"HeLLo\";\nlet upper2 = mixed.to_upper();  // \"HELLO\"\n```\n\n---\n\n#### to_lower\n\nConvertit la chane en minuscules.\n\n**Signature :**\n```hemlock\nstring.to_lower(): string\n```\n\n**Retourne :** Nouvelle chane en minuscules\n\n**Exemples :**\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n\nlet mixed = \"HeLLo\";\nlet lower2 = mixed.to_lower();  // \"hello\"\n```\n\n---\n\n### Prfixe et suffixe\n\n#### starts_with\n\nVrifie si la chane commence par un prfixe.\n\n**Signature :**\n```hemlock\nstring.starts_with(prefix: string): bool\n```\n\n**Paramtres :**\n- `prefix` - Prfixe  vrifier\n\n**Retourne :** `true` si la chane commence par le prfixe, `false` sinon\n\n**Exemples :**\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n---\n\n#### ends_with\n\nVrifie si la chane se termine par un suffixe.\n\n**Signature :**\n```hemlock\nstring.ends_with(suffix: string): bool\n```\n\n**Paramtres :**\n- `suffix` - Suffixe  vrifier\n\n**Retourne :** `true` si la chane se termine par le suffixe, `false` sinon\n\n**Exemples :**\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n---\n\n### Remplacement\n\n#### replace\n\nRemplace la premire occurrence d'une sous-chane.\n\n**Signature :**\n```hemlock\nstring.replace(old: string, new: string): string\n```\n\n**Paramtres :**\n- `old` - Sous-chane  remplacer\n- `new` - Chane de remplacement\n\n**Retourne :** Nouvelle chane avec la premire occurrence remplace\n\n**Exemples :**\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");  // \"hello there\"\n\nlet text = \"foo foo foo\";\nlet text2 = text.replace(\"foo\", \"bar\"); // \"bar foo foo\" (seulement la premire)\n```\n\n---\n\n#### replace_all\n\nRemplace toutes les occurrences d'une sous-chane.\n\n**Signature :**\n```hemlock\nstring.replace_all(old: string, new: string): string\n```\n\n**Paramtres :**\n- `old` - Sous-chane  remplacer\n- `new` - Chane de remplacement\n\n**Retourne :** Nouvelle chane avec toutes les occurrences remplaces\n\n**Exemples :**\n```hemlock\nlet text = \"foo foo foo\";\nlet text2 = text.replace_all(\"foo\", \"bar\"); // \"bar bar bar\"\n\nlet s = \"hello world hello\";\nlet s2 = s.replace_all(\"hello\", \"hi\");      // \"hi world hi\"\n```\n\n---\n\n### Rptition\n\n#### repeat\n\nRpte la chane n fois.\n\n**Signature :**\n```hemlock\nstring.repeat(count: i32): string\n```\n\n**Paramtres :**\n- `count` - Nombre de rptitions\n\n**Retourne :** Nouvelle chane rpte count fois\n\n**Exemples :**\n```hemlock\nlet s = \"ha\";\nlet repeated = s.repeat(3);     // \"hahaha\"\n\nlet line = \"-\";\nlet separator = line.repeat(40); // \"----------------------------------------\"\n```\n\n---\n\n### Accs aux caractres\n\n#### char_at\n\nObtient le point de code Unicode  l'index.\n\n**Signature :**\n```hemlock\nstring.char_at(index: i32): rune\n```\n\n**Paramtres :**\n- `index` - Index du point de code (base 0)\n\n**Retourne :** Rune (point de code Unicode)\n\n**Exemples :**\n```hemlock\nlet s = \"hello\";\nlet ch = s.char_at(0);          // 'h'\nlet ch2 = s.char_at(1);         // 'e'\n\n// Exemple UTF-8\nlet emoji = \"\";\nlet ch3 = emoji.char_at(0);     // U+1F680 (fuse)\n```\n\n---\n\n#### chars\n\nConvertit la chane en tableau de runes.\n\n**Signature :**\n```hemlock\nstring.chars(): array\n```\n\n**Retourne :** Tableau de runes (points de code)\n\n**Exemples :**\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']\n\n// Exemple UTF-8\nlet text = \"Hi!\";\nlet chars2 = text.chars();      // ['H', 'i', '', '!']\n```\n\n---\n\n### Accs aux octets\n\n#### byte_at\n\nObtient la valeur de l'octet  l'index.\n\n**Signature :**\n```hemlock\nstring.byte_at(index: i32): u8\n```\n\n**Paramtres :**\n- `index` - Index de l'octet (base 0, PAS l'index du point de code)\n\n**Retourne :** Valeur de l'octet (u8)\n\n**Exemples :**\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (ASCII 'h')\nlet byte2 = s.byte_at(1);       // 101 (ASCII 'e')\n\n// Exemple UTF-8\nlet emoji = \"\";\nlet byte3 = emoji.byte_at(0);   // 240 (premier octet UTF-8)\n```\n\n---\n\n#### bytes\n\nConvertit la chane en tableau d'octets.\n\n**Signature :**\n```hemlock\nstring.bytes(): array\n```\n\n**Retourne :** Tableau d'octets u8\n\n**Exemples :**\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111]\n\n// Exemple UTF-8\nlet emoji = \"\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 octets UTF-8)\n```\n\n---\n\n#### to_bytes\n\nConvertit la chane en buffer.\n\n**Signature :**\n```hemlock\nstring.to_bytes(): buffer\n```\n\n**Retourne :** Buffer contenant les octets UTF-8\n\n**Exemples :**\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();\nprint(buf.length);              // 5\n\n// Exemple UTF-8\nlet emoji = \"\";\nlet buf2 = emoji.to_bytes();\nprint(buf2.length);             // 4\n```\n\n**Note :** Ceci est une mthode hrite. Prfrez `.bytes()` pour la plupart des cas d'utilisation.\n\n---\n\n### Dsrialisation JSON\n\n#### deserialize\n\nParse une chane JSON en valeur.\n\n**Signature :**\n```hemlock\nstring.deserialize(): any\n```\n\n**Retourne :** Valeur parse (objet, tableau, nombre, chane, bool ou null)\n\n**Exemples :**\n```hemlock\nlet json = '{\"x\":10,\"y\":20}';\nlet obj = json.deserialize();\nprint(obj.x);                   // 10\nprint(obj.y);                   // 20\n\nlet arr_json = '[1,2,3]';\nlet arr = arr_json.deserialize();\nprint(arr[0]);                  // 1\n\nlet num_json = '42';\nlet num = num_json.deserialize();\nprint(num);                     // 42\n```\n\n**Types supports :**\n- Objets : `{\"key\": value}`\n- Tableaux : `[1, 2, 3]`\n- Nombres : `42`, `3.14`\n- Chanes : `\"text\"`\n- Boolens : `true`, `false`\n- Null : `null`\n\n**Voir aussi :** Mthode `.serialize()` des objets\n\n---\n\n## Chanage de mthodes\n\nLes mthodes de chanes peuvent tre chanes pour des oprations concises :\n\n**Exemples :**\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \");                  // \"foo | bar | baz\"\n\nlet cleaned = \"  HELLO  \"\n    .trim()\n    .to_lower();                   // \"hello\"\n```\n\n---\n\n## Rsum complet des mthodes\n\n| Mthode        | Signature                                    | Retourne  | Description                                |\n|----------------|----------------------------------------------|-----------|-------------------------------------------|\n| `substr`       | `(start: i32, length: i32)`                  | `string`  | Extraire sous-chane par position/longueur |\n| `slice`        | `(start: i32, end: i32)`                     | `string`  | Extraire sous-chane par plage             |\n| `find`         | `(needle: string)`                           | `i32`     | Trouver premire occurrence (-1 si non trouve) |\n| `contains`     | `(needle: string)`                           | `bool`    | Vrifier si contient sous-chane           |\n| `split`        | `(delimiter: string)`                        | `array`   | Sparer en tableau                         |\n| `trim`         | `()`                                         | `string`  | Supprimer espaces blancs                   |\n| `to_upper`     | `()`                                         | `string`  | Convertir en majuscules                    |\n| `to_lower`     | `()`                                         | `string`  | Convertir en minuscules                    |\n| `starts_with`  | `(prefix: string)`                           | `bool`    | Vrifier si commence par prfixe           |\n| `ends_with`    | `(suffix: string)`                           | `bool`    | Vrifier si termine par suffixe            |\n| `replace`      | `(old: string, new: string)`                 | `string`  | Remplacer premire occurrence              |\n| `replace_all`  | `(old: string, new: string)`                 | `string`  | Remplacer toutes les occurrences           |\n| `repeat`       | `(count: i32)`                               | `string`  | Rpter chane n fois                      |\n| `char_at`      | `(index: i32)`                               | `rune`    | Obtenir point de code  l'index            |\n| `byte_at`      | `(index: i32)`                               | `u8`      | Obtenir octet  l'index                    |\n| `chars`        | `()`                                         | `array`   | Convertir en tableau de runes              |\n| `bytes`        | `()`                                         | `array`   | Convertir en tableau d'octets              |\n| `to_bytes`     | `()`                                         | `buffer`  | Convertir en buffer (hrit)               |\n| `deserialize`  | `()`                                         | `any`     | Parser chane JSON                         |\n\n---\n\n## Voir aussi\n\n- [Systme de types](#reference-type-system) - Dtails sur le type string\n- [API Array](#reference-array-api) - Mthodes de tableau pour les rsultats de split()\n- [Oprateurs](#reference-operators) - Oprateur de concatnation de chanes\n"}, "Rfrence API -> API des Fichiers": {"id": "reference-file-api", "content": "# Rfrence de l'API File\n\nRfrence complte pour le systme d'entre/sortie de fichiers de Hemlock.\n\n---\n\n## Aperu\n\nHemlock fournit une **API objet File** pour les oprations sur les fichiers avec une gestion approprie des erreurs et des ressources. Les fichiers doivent tre ouverts et ferms manuellement.\n\n**Caractristiques principales :**\n- Objet file avec mthodes\n- Lecture/criture de texte et donnes binaires\n- Positionnement et recherche\n- Messages d'erreur appropris\n- Gestion manuelle des ressources (pas de RAII)\n\n---\n\n## Type File\n\n**Type :** `file`\n\n**Description :** Handle de fichier pour les oprations d'E/S\n\n**Proprits (lecture seule) :**\n- `.path` - Chemin du fichier (string)\n- `.mode` - Mode d'ouverture (string)\n- `.closed` - Si le fichier est ferm (bool)\n\n---\n\n## Ouverture des fichiers\n\n### open\n\nOuvre un fichier pour lecture, criture, ou les deux.\n\n**Signature :**\n```hemlock\nopen(path: string, mode?: string): file\n```\n\n**Paramtres :**\n- `path` - Chemin du fichier (relatif ou absolu)\n- `mode` (optionnel) - Mode d'ouverture (par dfaut : `\"r\"`)\n\n**Retourne :** Objet file\n\n**Modes :**\n- `\"r\"` - Lecture (par dfaut)\n- `\"w\"` - criture (tronque le fichier existant)\n- `\"a\"` - Ajout\n- `\"r+\"` - Lecture et criture\n- `\"w+\"` - Lecture et criture (tronque)\n- `\"a+\"` - Lecture et ajout\n\n**Exemples :**\n```hemlock\n// Mode lecture (par dfaut)\nlet f = open(\"data.txt\");\nlet f_read = open(\"data.txt\", \"r\");\n\n// Mode criture (tronque)\nlet f_write = open(\"output.txt\", \"w\");\n\n// Mode ajout\nlet f_append = open(\"log.txt\", \"a\");\n\n// Mode lecture/criture\nlet f_rw = open(\"data.bin\", \"r+\");\n\n// Lecture/criture (tronque)\nlet f_rw_trunc = open(\"output.bin\", \"w+\");\n\n// Lecture/ajout\nlet f_ra = open(\"log.txt\", \"a+\");\n```\n\n**Gestion des erreurs :**\n```hemlock\ntry {\n    let f = open(\"missing.txt\", \"r\");\n} catch (e) {\n    print(\"chec d'ouverture:\", e);\n    // Erreur: chec d'ouverture de 'missing.txt': Fichier ou rpertoire inexistant\n}\n```\n\n**Important :** Les fichiers doivent tre ferms manuellement avec `f.close()` pour viter les fuites de descripteurs de fichiers.\n\n---\n\n## Mthodes File\n\n### Lecture\n\n#### read\n\nLit du texte depuis le fichier.\n\n**Signature :**\n```hemlock\nfile.read(size?: i32): string\n```\n\n**Paramtres :**\n- `size` (optionnel) - Nombre d'octets  lire (si omis, lit jusqu' la fin du fichier)\n\n**Retourne :** Chane avec le contenu du fichier\n\n**Exemples :**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Lire le fichier entier\nlet all = f.read();\nprint(all);\n\n// Lire un nombre spcifique d'octets\nlet chunk = f.read(1024);\n\nf.close();\n```\n\n**Comportement :**\n- Lit depuis la position actuelle du fichier\n- Retourne une chane vide  la fin du fichier\n- Avance la position du fichier\n\n**Erreurs :**\n- Lecture depuis un fichier ferm\n- Lecture depuis un fichier en criture seule\n\n---\n\n#### read_bytes\n\nLit des donnes binaires depuis le fichier.\n\n**Signature :**\n```hemlock\nfile.read_bytes(size: i32): buffer\n```\n\n**Paramtres :**\n- `size` - Nombre d'octets  lire\n\n**Retourne :** Buffer avec les donnes binaires\n\n**Exemples :**\n```hemlock\nlet f = open(\"data.bin\", \"r\");\n\n// Lire 256 octets\nlet binary = f.read_bytes(256);\nprint(binary.length);       // 256\n\n// Traiter les donnes binaires\nlet i = 0;\nwhile (i < binary.length) {\n    print(binary[i]);\n    i = i + 1;\n}\n\nf.close();\n```\n\n**Comportement :**\n- Lit le nombre exact d'octets\n- Retourne un buffer (pas une chane)\n- Avance la position du fichier\n\n---\n\n### criture\n\n#### write\n\ncrit du texte dans le fichier.\n\n**Signature :**\n```hemlock\nfile.write(data: string): i32\n```\n\n**Paramtres :**\n- `data` - Chane  crire\n\n**Retourne :** Nombre d'octets crits (i32)\n\n**Exemples :**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\n\n// crire du texte\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"crit\", written, \"octets\");\n\n// critures multiples\nf.write(\"Ligne 1\\n\");\nf.write(\"Ligne 2\\n\");\nf.write(\"Ligne 3\\n\");\n\nf.close();\n```\n\n**Comportement :**\n- crit  la position actuelle du fichier\n- Retourne le nombre d'octets crits\n- Avance la position du fichier\n\n**Erreurs :**\n- criture dans un fichier ferm\n- criture dans un fichier en lecture seule\n\n---\n\n#### write_bytes\n\ncrit des donnes binaires dans le fichier.\n\n**Signature :**\n```hemlock\nfile.write_bytes(data: buffer): i32\n```\n\n**Paramtres :**\n- `data` - Buffer  crire\n\n**Retourne :** Nombre d'octets crits (i32)\n\n**Exemples :**\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Crer un buffer\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// crire le buffer\nlet written = f.write_bytes(buf);\nprint(\"crit\", written, \"octets\");\n\nf.close();\n```\n\n**Comportement :**\n- crit le contenu du buffer dans le fichier\n- Retourne le nombre d'octets crits\n- Avance la position du fichier\n\n---\n\n### Positionnement\n\n#### seek\n\nDplace la position du fichier  un dcalage d'octets spcifique.\n\n**Signature :**\n```hemlock\nfile.seek(position: i32): i32\n```\n\n**Paramtres :**\n- `position` - Dcalage en octets depuis le dbut du fichier\n\n**Retourne :** Nouvelle position du fichier (i32)\n\n**Exemples :**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Aller  l'octet 100\nf.seek(100);\n\n// Lire depuis cette position\nlet chunk = f.read(50);\n\n// Revenir au dbut\nf.seek(0);\n\n// Lire depuis le dbut\nlet all = f.read();\n\nf.close();\n```\n\n**Comportement :**\n- Dfinit la position du fichier au dcalage absolu\n- Retourne la nouvelle position\n- Se positionner au-del de la fin du fichier est autoris (cre un trou dans le fichier lors de l'criture)\n\n---\n\n#### tell\n\nObtient la position actuelle du fichier.\n\n**Signature :**\n```hemlock\nfile.tell(): i32\n```\n\n**Retourne :** Dcalage actuel en octets depuis le dbut du fichier (i32)\n\n**Exemples :**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nprint(f.tell());        // 0 (au dbut)\n\nf.read(100);\nprint(f.tell());        // 100 (aprs lecture)\n\nf.seek(50);\nprint(f.tell());        // 50 (aprs positionnement)\n\nf.close();\n```\n\n---\n\n### Fermeture\n\n#### close\n\nFerme le fichier (idempotent).\n\n**Signature :**\n```hemlock\nfile.close(): null\n```\n\n**Retourne :** `null`\n\n**Exemples :**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\n// Sr d'appeler plusieurs fois\nf.close();  // Pas d'erreur\nf.close();  // Pas d'erreur\n```\n\n**Comportement :**\n- Ferme le handle du fichier\n- Vide les critures en attente\n- Idempotent (sr d'appeler plusieurs fois)\n- Met la proprit `.closed`  `true`\n\n**Important :** Fermez toujours les fichiers une fois termin pour viter les fuites de descripteurs de fichiers.\n\n---\n\n## Proprits File\n\n### .path\n\nObtient le chemin du fichier.\n\n**Type :** `string`\n\n**Accs :** Lecture seule\n\n**Exemples :**\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);          // \"/path/to/file.txt\"\nf.close();\n```\n\n---\n\n### .mode\n\nObtient le mode d'ouverture.\n\n**Type :** `string`\n\n**Accs :** Lecture seule\n\n**Exemples :**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);          // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);         // \"w\"\nf2.close();\n```\n\n---\n\n### .closed\n\nVrifie si le fichier est ferm.\n\n**Type :** `bool`\n\n**Accs :** Lecture seule\n\n**Exemples :**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);        // false\n\nf.close();\nprint(f.closed);        // true\n```\n\n---\n\n## Gestion des erreurs\n\nToutes les oprations sur les fichiers incluent des messages d'erreur appropris avec contexte :\n\n### Fichier non trouv\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Erreur: chec d'ouverture de 'missing.txt': Fichier ou rpertoire inexistant\n```\n\n### Lecture depuis un fichier ferm\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Erreur: Impossible de lire depuis le fichier ferm 'data.txt'\n```\n\n### criture dans un fichier en lecture seule\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Erreur: Impossible d'crire dans le fichier 'readonly.txt' ouvert en mode lecture seule\n```\n\n### Utilisation de try/catch\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    print(content);\n} catch (e) {\n    print(\"Erreur fichier:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## Modles de gestion des ressources\n\n### Modle basique\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### Avec gestion des erreurs\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Toujours fermer, mme en cas d'erreur\n}\n```\n\n### Modle sr\n\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    // ... traiter le contenu ...\n} catch (e) {\n    print(\"Erreur:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## Exemples d'utilisation\n\n### Lire un fichier entier\n\n```hemlock\nfn read_file(filename: string): string {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content;\n}\n\nlet text = read_file(\"data.txt\");\nprint(text);\n```\n\n### crire un fichier texte\n\n```hemlock\nfn write_file(filename: string, content: string) {\n    let f = open(filename, \"w\");\n    f.write(content);\n    f.close();\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\\n\");\n```\n\n### Ajouter  un fichier\n\n```hemlock\nfn append_file(filename: string, line: string) {\n    let f = open(filename, \"a\");\n    f.write(line + \"\\n\");\n    f.close();\n}\n\nappend_file(\"log.txt\", \"Entre de log 1\");\nappend_file(\"log.txt\", \"Entre de log 2\");\n```\n\n### Lire un fichier binaire\n\n```hemlock\nfn read_binary(filename: string, size: i32): buffer {\n    let f = open(filename, \"r\");\n    let data = f.read_bytes(size);\n    f.close();\n    return data;\n}\n\nlet binary = read_binary(\"data.bin\", 256);\nprint(\"Lu\", binary.length, \"octets\");\n```\n\n### crire un fichier binaire\n\n```hemlock\nfn write_binary(filename: string, data: buffer) {\n    let f = open(filename, \"w\");\n    f.write_bytes(data);\n    f.close();\n}\n\nlet buf = buffer(10);\nbuf[0] = 65;\nwrite_binary(\"output.bin\", buf);\n```\n\n### Lire un fichier ligne par ligne\n\n```hemlock\nfn read_lines(filename: string): array {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content.split(\"\\n\");\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Ligne\", i, \":\", lines[i]);\n    i = i + 1;\n}\n```\n\n### Copier un fichier\n\n```hemlock\nfn copy_file(src: string, dest: string) {\n    let f_in = open(src, \"r\");\n    let f_out = open(dest, \"w\");\n\n    let content = f_in.read();\n    f_out.write(content);\n\n    f_in.close();\n    f_out.close();\n}\n\ncopy_file(\"input.txt\", \"output.txt\");\n```\n\n### Lire un fichier par morceaux\n\n```hemlock\nfn process_chunks(filename: string) {\n    let f = open(filename, \"r\");\n\n    while (true) {\n        let chunk = f.read(1024);  // Lire 1 Ko  la fois\n        if (chunk.length == 0) {\n            break;  // Fin du fichier\n        }\n\n        // Traiter le morceau\n        print(\"Traitement de\", chunk.length, \"octets\");\n    }\n\n    f.close();\n}\n\nprocess_chunks(\"large_file.txt\");\n```\n\n---\n\n## Rsum complet des mthodes\n\n| Mthode       | Signature                | Retourne  | Description                    |\n|---------------|--------------------------|-----------|--------------------------------|\n| `read`        | `(size?: i32)`           | `string`  | Lire du texte                  |\n| `read_bytes`  | `(size: i32)`            | `buffer`  | Lire des donnes binaires      |\n| `write`       | `(data: string)`         | `i32`     | crire du texte                |\n| `write_bytes` | `(data: buffer)`         | `i32`     | crire des donnes binaires    |\n| `seek`        | `(position: i32)`        | `i32`     | Dfinir la position du fichier |\n| `tell`        | `()`                     | `i32`     | Obtenir la position du fichier |\n| `close`       | `()`                     | `null`    | Fermer le fichier (idempotent) |\n\n---\n\n## Rsum complet des proprits\n\n| Proprit | Type     | Accs          | Description                    |\n|-----------|----------|----------------|--------------------------------|\n| `.path`   | `string` | Lecture seule  | Chemin du fichier              |\n| `.mode`   | `string` | Lecture seule  | Mode d'ouverture               |\n| `.closed` | `bool`   | Lecture seule  | Si le fichier est ferm        |\n\n---\n\n## Migration depuis l'ancienne API\n\n**Ancienne API (supprime) :**\n- `read_file(path)` - Utilisez `open(path, \"r\").read()`\n- `write_file(path, data)` - Utilisez `open(path, \"w\").write(data)`\n- `append_file(path, data)` - Utilisez `open(path, \"a\").write(data)`\n- `file_exists(path)` - Pas encore de remplacement\n\n**Exemple de migration :**\n```hemlock\n// Ancien (v0.0)\nlet content = read_file(\"data.txt\");\nwrite_file(\"output.txt\", content);\n\n// Nouveau (v0.1)\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nf2.write(content);\nf2.close();\n```\n\n---\n\n## Voir aussi\n\n- [Fonctions intgres](#reference-builtins) - Fonction `open()`\n- [API Memory](#reference-memory-api) - Type buffer\n- [API String](#reference-string-api) - Mthodes de chane pour le traitement de texte\n"}, "Rfrence API -> API des Tableaux": {"id": "reference-array-api", "content": "# Rfrence de l'API Array\n\nRfrence complte pour le type array de Hemlock et ses 18 mthodes.\n\n---\n\n## Aperu\n\nLes tableaux (arrays) dans Hemlock sont des squences **dynamiques, alloues sur le tas** qui peuvent contenir des types mixtes. Ils fournissent des mthodes compltes pour la manipulation et le traitement des donnes.\n\n**Caractristiques principales :**\n- Dimensionnement dynamique (croissance automatique)\n- Indexation  partir de zro\n- Types mixtes autoriss\n- 18 mthodes intgres\n- Allous sur le tas avec suivi de la capacit\n\n---\n\n## Type Array\n\n**Type :** `array`\n\n**Proprits :**\n- `.length` - Nombre d'lments (i32)\n\n**Syntaxe littrale :** Crochets `[elem1, elem2, ...]`\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);     // 5\n\n// Types mixtes\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.length);   // 4\n\n// Tableau vide\nlet empty = [];\nprint(empty.length);   // 0\n```\n\n---\n\n## Indexation\n\nLes tableaux supportent l'indexation  base zro en utilisant `[]` :\n\n**Accs en lecture :**\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);         // 10\nprint(arr[1]);         // 20\nprint(arr[2]);         // 30\n```\n\n**Accs en criture :**\n```hemlock\nlet arr = [10, 20, 30];\narr[0] = 99;\narr[1] = 88;\nprint(arr);            // [99, 88, 30]\n```\n\n**Note :** L'indexation directe ne vrifie pas les limites. Utilisez les mthodes pour plus de scurit.\n\n---\n\n## Proprits des tableaux\n\n### .length\n\nObtient le nombre d'lments dans le tableau.\n\n**Type :** `i32`\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr.length);     // 3\n\nlet empty = [];\nprint(empty.length);   // 0\n\n// La longueur change dynamiquement\narr.push(4);\nprint(arr.length);     // 4\n\narr.pop();\nprint(arr.length);     // 3\n```\n\n---\n\n## Mthodes des tableaux\n\n### Oprations de pile (Stack)\n\n#### push\n\nAjoute un lment  la fin du tableau.\n\n**Signature :**\n```hemlock\narray.push(value: any): null\n```\n\n**Paramtres :**\n- `value` - lment  ajouter\n\n**Retourne :** `null`\n\n**Modifie :** Oui (modifie le tableau sur place)\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\narr.push(\"hello\");     // [1, 2, 3, 4, 5, \"hello\"]\n```\n\n---\n\n#### pop\n\nRetire et retourne le dernier lment.\n\n**Signature :**\n```hemlock\narray.pop(): any\n```\n\n**Retourne :** Dernier lment (retir du tableau)\n\n**Modifie :** Oui (modifie le tableau sur place)\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3];\nlet last = arr.pop();  // 3\nprint(arr);            // [1, 2]\n\nlet last2 = arr.pop(); // 2\nprint(arr);            // [1]\n```\n\n**Erreur :** Erreur d'excution si le tableau est vide.\n\n---\n\n### Oprations de file (Queue)\n\n#### shift\n\nRetire et retourne le premier lment.\n\n**Signature :**\n```hemlock\narray.shift(): any\n```\n\n**Retourne :** Premier lment (retir du tableau)\n\n**Modifie :** Oui (modifie le tableau sur place)\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();  // 1\nprint(arr);               // [2, 3]\n\nlet first2 = arr.shift(); // 2\nprint(arr);               // [3]\n```\n\n**Erreur :** Erreur d'excution si le tableau est vide.\n\n---\n\n#### unshift\n\nAjoute un lment au dbut du tableau.\n\n**Signature :**\n```hemlock\narray.unshift(value: any): null\n```\n\n**Paramtres :**\n- `value` - lment  ajouter\n\n**Retourne :** `null`\n\n**Modifie :** Oui (modifie le tableau sur place)\n\n**Exemples :**\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);        // [1, 2, 3]\narr.unshift(0);        // [0, 1, 2, 3]\n```\n\n---\n\n### Insertion et suppression\n\n#### insert\n\nInsre un lment  un index spcifique.\n\n**Signature :**\n```hemlock\narray.insert(index: i32, value: any): null\n```\n\n**Paramtres :**\n- `index` - Position d'insertion (base 0)\n- `value` - lment  insrer\n\n**Retourne :** `null`\n\n**Modifie :** Oui (modifie le tableau sur place)\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // [1, 2, 3, 4, 5]\n\nlet arr2 = [1, 3];\narr2.insert(1, 2);     // [1, 2, 3]\n\n// Insertion  la fin\narr2.insert(arr2.length, 4);  // [1, 2, 3, 4]\n```\n\n**Comportement :** Dcale les lments  partir de l'index vers la droite.\n\n---\n\n#### remove\n\nRetire et retourne l'lment  l'index spcifi.\n\n**Signature :**\n```hemlock\narray.remove(index: i32): any\n```\n\n**Paramtres :**\n- `index` - Position de suppression (base 0)\n\n**Retourne :** lment supprim\n\n**Modifie :** Oui (modifie le tableau sur place)\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(0);  // 1\nprint(arr);                   // [2, 3, 4, 5]\n\nlet removed2 = arr.remove(2); // 4\nprint(arr);                   // [2, 3, 5]\n```\n\n**Comportement :** Dcale les lments aprs l'index vers la gauche.\n\n**Erreur :** Erreur d'excution si l'index est hors limites.\n\n---\n\n### Recherche\n\n#### find\n\nTrouve la premire occurrence d'une valeur.\n\n**Signature :**\n```hemlock\narray.find(value: any): i32\n```\n\n**Paramtres :**\n- `value` - Valeur  rechercher\n\n**Retourne :** Index de la premire occurrence, ou `-1` si non trouve\n\n**Exemples :**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2\nlet idx2 = arr.find(99);     // -1 (non trouve)\n\n// Trouver le premier doublon\nlet arr2 = [1, 2, 3, 2, 4];\nlet idx3 = arr2.find(2);     // 1 (premire occurrence)\n```\n\n**Comparaison :** Utilise l'galit de valeur pour les primitives et les chanes.\n\n---\n\n#### contains\n\nVrifie si le tableau contient une valeur.\n\n**Signature :**\n```hemlock\narray.contains(value: any): bool\n```\n\n**Paramtres :**\n- `value` - Valeur  rechercher\n\n**Retourne :** `true` si trouve, `false` sinon\n\n**Exemples :**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n\n// Fonctionne avec les chanes\nlet words = [\"hello\", \"world\"];\nlet has3 = words.contains(\"hello\");  // true\n```\n\n---\n\n### Dcoupage et extraction\n\n#### slice\n\nExtrait un sous-tableau par plage (fin exclusive).\n\n**Signature :**\n```hemlock\narray.slice(start: i32, end: i32): array\n```\n\n**Paramtres :**\n- `start` - Index de dpart (base 0, inclusif)\n- `end` - Index de fin (exclusif)\n\n**Retourne :** Nouveau tableau avec les lments de [start, end)\n\n**Modifie :** Non (retourne un nouveau tableau)\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4]\nlet first_three = arr.slice(0, 3);  // [1, 2, 3]\nlet last_two = arr.slice(3, 5);     // [4, 5]\n\n// Tranche vide\nlet empty = arr.slice(2, 2); // []\n```\n\n---\n\n#### first\n\nObtient le premier lment sans le retirer.\n\n**Signature :**\n```hemlock\narray.first(): any\n```\n\n**Retourne :** Premier lment\n\n**Modifie :** Non\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1\nprint(arr);                  // [1, 2, 3] (inchang)\n```\n\n**Erreur :** Erreur d'excution si le tableau est vide.\n\n---\n\n#### last\n\nObtient le dernier lment sans le retirer.\n\n**Signature :**\n```hemlock\narray.last(): any\n```\n\n**Retourne :** Dernier lment\n\n**Modifie :** Non\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3\nprint(arr);                  // [1, 2, 3] (inchang)\n```\n\n**Erreur :** Erreur d'excution si le tableau est vide.\n\n---\n\n### Manipulation de tableaux\n\n#### reverse\n\nInverse le tableau sur place.\n\n**Signature :**\n```hemlock\narray.reverse(): null\n```\n\n**Retourne :** `null`\n\n**Modifie :** Oui (modifie le tableau sur place)\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\nprint(arr);                  // [5, 4, 3, 2, 1]\n\nlet words = [\"hello\", \"world\"];\nwords.reverse();             // [\"world\", \"hello\"]\n```\n\n---\n\n#### clear\n\nSupprime tous les lments du tableau.\n\n**Signature :**\n```hemlock\narray.clear(): null\n```\n\n**Retourne :** `null`\n\n**Modifie :** Oui (modifie le tableau sur place)\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();\nprint(arr);                  // []\nprint(arr.length);           // 0\n```\n\n---\n\n### Combinaison de tableaux\n\n#### concat\n\nConcatne avec un autre tableau.\n\n**Signature :**\n```hemlock\narray.concat(other: array): array\n```\n\n**Paramtres :**\n- `other` - Tableau  concatner\n\n**Retourne :** Nouveau tableau avec les lments des deux tableaux\n\n**Modifie :** Non (retourne un nouveau tableau)\n\n**Exemples :**\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]\nprint(a);                    // [1, 2, 3] (inchang)\nprint(b);                    // [4, 5, 6] (inchang)\n\n// Enchaner les concatnations\nlet c = [7, 8];\nlet all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n---\n\n### Oprations fonctionnelles\n\n#### map\n\nTransforme chaque lment en utilisant une fonction de rappel (callback).\n\n**Signature :**\n```hemlock\narray.map(callback: fn): array\n```\n\n**Paramtres :**\n- `callback` - Fonction qui prend un lment et retourne une valeur transforme\n\n**Retourne :** Nouveau tableau avec les lments transforms\n\n**Modifie :** Non (retourne un nouveau tableau)\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet doubled = arr.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\nlet names = [\"alice\", \"bob\"];\nlet upper = names.map(fn(s) { return s.to_upper(); });\nprint(upper);  // [\"ALICE\", \"BOB\"]\n```\n\n---\n\n#### filter\n\nSlectionne les lments qui correspondent  un prdicat.\n\n**Signature :**\n```hemlock\narray.filter(predicate: fn): array\n```\n\n**Paramtres :**\n- `predicate` - Fonction qui prend un lment et retourne bool\n\n**Retourne :** Nouveau tableau avec les lments o le prdicat a retourn true\n\n**Modifie :** Non (retourne un nouveau tableau)\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6];\nlet evens = arr.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4, 6]\n\nlet words = [\"hello\", \"hi\", \"hey\", \"goodbye\"];\nlet short = words.filter(fn(s) { return s.length < 4; });\nprint(short);  // [\"hi\", \"hey\"]\n```\n\n---\n\n#### reduce\n\nRduit le tableau  une seule valeur en utilisant un accumulateur.\n\n**Signature :**\n```hemlock\narray.reduce(callback: fn, initial: any): any\n```\n\n**Paramtres :**\n- `callback` - Fonction qui prend (accumulateur, lment) et retourne le nouvel accumulateur\n- `initial` - Valeur de dpart pour l'accumulateur\n\n**Retourne :** Valeur finale accumule\n\n**Modifie :** Non\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sum = arr.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\nlet product = arr.reduce(fn(acc, x) { return acc * x; }, 1);\nprint(product);  // 120\n\n// Trouver la valeur maximale\nlet max = arr.reduce(fn(acc, x) {\n    if (x > acc) { return x; }\n    return acc;\n}, arr[0]);\nprint(max);  // 5\n```\n\n---\n\n### Conversion en chane\n\n#### join\n\nJoint les lments en une chane avec un dlimiteur.\n\n**Signature :**\n```hemlock\narray.join(delimiter: string): string\n```\n\n**Paramtres :**\n- `delimiter` - Chane  placer entre les lments\n\n**Retourne :** Chane avec tous les lments joints\n\n**Exemples :**\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Fonctionne avec les types mixtes\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n\n// Dlimiteur vide\nlet arr = [\"a\", \"b\", \"c\"];\nlet s = arr.join(\"\");          // \"abc\"\n```\n\n**Comportement :** Convertit automatiquement tous les lments en chanes.\n\n---\n\n## Chanage de mthodes\n\nLes mthodes de tableaux peuvent tre chanes pour des oprations concises :\n\n**Exemples :**\n```hemlock\n// Chaner slice et join\nlet result = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\n// Chaner concat et slice\nlet combined = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);    // [3, 4, 5]\n\n// Chanage complexe\nlet words = [\"hello\", \"world\", \"foo\", \"bar\"];\nlet result2 = words\n    .slice(0, 3)\n    .concat([\"baz\"])\n    .join(\"-\");      // \"hello-world-foo-baz\"\n```\n\n---\n\n## Rsum complet des mthodes\n\n### Mthodes modifiantes\n\nMthodes qui modifient le tableau sur place :\n\n| Mthode    | Signature                    | Retourne  | Description                         |\n|------------|------------------------------|-----------|-------------------------------------|\n| `push`     | `(value: any)`               | `null`    | Ajouter  la fin                    |\n| `pop`      | `()`                         | `any`     | Retirer de la fin                   |\n| `shift`    | `()`                         | `any`     | Retirer du dbut                    |\n| `unshift`  | `(value: any)`               | `null`    | Ajouter au dbut                    |\n| `insert`   | `(index: i32, value: any)`   | `null`    | Insrer  l'index                   |\n| `remove`   | `(index: i32)`               | `any`     | Retirer  l'index                   |\n| `reverse`  | `()`                         | `null`    | Inverser sur place                  |\n| `clear`    | `()`                         | `null`    | Supprimer tous les lments         |\n\n### Mthodes non modifiantes\n\nMthodes qui retournent de nouvelles valeurs sans modifier l'original :\n\n| Mthode    | Signature                        | Retourne  | Description                         |\n|------------|----------------------------------|-----------|-------------------------------------|\n| `find`     | `(value: any)`                   | `i32`     | Trouver la premire occurrence      |\n| `contains` | `(value: any)`                   | `bool`    | Vrifier si contient la valeur      |\n| `slice`    | `(start: i32, end: i32)`         | `array`   | Extraire un sous-tableau            |\n| `first`    | `()`                             | `any`     | Obtenir le premier lment          |\n| `last`     | `()`                             | `any`     | Obtenir le dernier lment          |\n| `concat`   | `(other: array)`                 | `array`   | Concatner les tableaux             |\n| `join`     | `(delimiter: string)`            | `string`  | Joindre les lments en chane      |\n| `map`      | `(callback: fn)`                 | `array`   | Transformer chaque lment          |\n| `filter`   | `(predicate: fn)`                | `array`   | Slectionner les lments correspondants |\n| `reduce`   | `(callback: fn, initial: any)`   | `any`     | Rduire  une seule valeur          |\n\n---\n\n## Modles d'utilisation\n\n### Utilisation comme pile (Stack)\n\n```hemlock\nlet stack = [];\n\n// Empiler des lments\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Dpiler des lments\nwhile (stack.length > 0) {\n    let item = stack.pop();\n    print(item);  // 3, 2, 1\n}\n```\n\n### Utilisation comme file (Queue)\n\n```hemlock\nlet queue = [];\n\n// Enfiler\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Dfiler\nwhile (queue.length > 0) {\n    let item = queue.shift();\n    print(item);  // 1, 2, 3\n}\n```\n\n### Transformation de tableau\n\n```hemlock\n// Filtrage (manuel)\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = [];\nlet i = 0;\nwhile (i < numbers.length) {\n    if (numbers[i] % 2 == 0) {\n        evens.push(numbers[i]);\n    }\n    i = i + 1;\n}\n\n// Mapping (manuel)\nlet numbers2 = [1, 2, 3, 4, 5];\nlet doubled = [];\nlet j = 0;\nwhile (j < numbers2.length) {\n    doubled.push(numbers2[j] * 2);\n    j = j + 1;\n}\n```\n\n### Construction de tableaux\n\n```hemlock\nlet arr = [];\n\n// Construire un tableau avec une boucle\nlet i = 0;\nwhile (i < 10) {\n    arr.push(i * 10);\n    i = i + 1;\n}\n\nprint(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n```\n\n---\n\n## Dtails d'implmentation\n\n**Gestion de la capacit :**\n- Les tableaux grandissent automatiquement selon les besoins\n- La capacit double lorsqu'elle est dpasse\n- Pas de contrle manuel de la capacit\n\n**Comparaison de valeurs :**\n- `find()` et `contains()` utilisent l'galit de valeur\n- Fonctionne correctement pour les primitives et les chanes\n- Les objets/tableaux sont compars par rfrence\n\n**Mmoire :**\n- Allous sur le tas\n- Pas de libration automatique (gestion manuelle de la mmoire)\n- Pas de vrification des limites sur l'accs direct par index\n\n---\n\n## Voir aussi\n\n- [Systme de types](#reference-type-system) - Dtails sur le type array\n- [API String](#reference-string-api) - Rsultats de join() sur les chanes\n- [Oprateurs](#reference-operators) - Oprateur d'indexation des tableaux\n"}, "Rfrence API -> Fonctions Intgres": {"id": "reference-builtins", "content": "# Rfrence des fonctions intgres\n\nRfrence complte pour toutes les fonctions et constantes intgres dans Hemlock.\n\n---\n\n## Aperu\n\nHemlock fournit un ensemble de fonctions intgres pour les E/S, l'introspection de types, la gestion de la mmoire, la concurrence et l'interaction systme. Toutes les fonctions intgres sont disponibles globalement sans imports.\n\n---\n\n## Fonctions d'E/S\n\n### print\n\nAffiche des valeurs sur stdout avec un saut de ligne.\n\n**Signature :**\n```hemlock\nprint(...values): null\n```\n\n**Paramtres :**\n- `...values` - N'importe quel nombre de valeurs  afficher\n\n**Retourne :** `null`\n\n**Exemples :**\n```hemlock\nprint(\"Hello, World!\");\nprint(42);\nprint(3.14);\nprint(true);\nprint([1, 2, 3]);\nprint({ x: 10, y: 20 });\n\n// Plusieurs valeurs\nprint(\"x =\", 10, \"y =\", 20);\n```\n\n**Comportement :**\n- Convertit toutes les valeurs en chanes\n- Spare les valeurs multiples par des espaces\n- Ajoute un saut de ligne  la fin\n- Vide stdout\n\n---\n\n### read_line\n\nLit une ligne de texte depuis stdin (entre utilisateur).\n\n**Signature :**\n```hemlock\nread_line(): string | null\n```\n\n**Paramtres :** Aucun\n\n**Retourne :**\n- `string` - La ligne lue depuis stdin (saut de ligne supprim)\n- `null` - En fin de fichier/entre (EOF)\n\n**Exemples :**\n```hemlock\n// Invite simple\nprint(\"Quel est votre nom ?\");\nlet name = read_line();\nprint(\"Bonjour, \" + name + \"!\");\n\n// Lecture de nombres (ncessite un parsing manuel)\nprint(\"Entrez un nombre:\");\nlet input = read_line();\nlet num = parse_int(input);  // Voir ci-dessous pour parse_int\nprint(\"Double:\", num * 2);\n\n// Grer EOF\nlet line = read_line();\nif (line == null) {\n    print(\"Fin de l'entre\");\n}\n\n// Lire plusieurs lignes\nprint(\"Entrez des lignes (Ctrl+D pour arrter):\");\nwhile (true) {\n    let line = read_line();\n    if (line == null) {\n        break;\n    }\n    print(\"Vous avez dit:\", line);\n}\n```\n\n**Comportement :**\n- Bloque jusqu' ce que l'utilisateur appuie sur Entre\n- Supprime le saut de ligne final (`\\n`) et le retour chariot (`\\r`)\n- Retourne `null` en EOF (Ctrl+D sur Unix, Ctrl+Z sur Windows)\n- Lit depuis stdin uniquement (pas depuis les fichiers)\n\n**Parsing de l'entre utilisateur :**\n\nComme `read_line()` retourne toujours une chane, vous devez parser l'entre numrique manuellement :\n\n```hemlock\n// Parseur d'entiers simple\nfn parse_int(s: string): i32 {\n    let result: i32 = 0;\n    let negative = false;\n    let i = 0;\n\n    if (s.length > 0 && s.char_at(0) == '-') {\n        negative = true;\n        i = 1;\n    }\n\n    while (i < s.length) {\n        let c = s.char_at(i);\n        let code: i32 = c;\n        if (code >= 48 && code <= 57) {\n            result = result * 10 + (code - 48);\n        } else {\n            break;\n        }\n        i = i + 1;\n    }\n\n    if (negative) {\n        return -result;\n    }\n    return result;\n}\n\n// Utilisation\nprint(\"Entrez votre ge:\");\nlet age = parse_int(read_line());\nprint(\"Dans 10 ans vous aurez\", age + 10);\n```\n\n**Voir aussi :** [API File](#reference-file-api) pour la lecture depuis les fichiers\n\n---\n\n### eprint\n\nAffiche une valeur sur stderr avec un saut de ligne.\n\n**Signature :**\n```hemlock\neprint(value: any): null\n```\n\n**Paramtres :**\n- `value` - Une seule valeur  afficher sur stderr\n\n**Retourne :** `null`\n\n**Exemples :**\n```hemlock\neprint(\"Erreur: fichier non trouv\");\neprint(404);\neprint(\"Avertissement: \" + message);\n\n// Modle typique de gestion d'erreur\nfn load_config(path: string) {\n    if (!exists(path)) {\n        eprint(\"Erreur: fichier de configuration non trouv: \" + path);\n        return null;\n    }\n    // ...\n}\n```\n\n**Comportement :**\n- Affiche sur stderr (flux d'erreur standard)\n- Ajoute un saut de ligne  la fin\n- N'accepte qu'un seul argument (contrairement  `print`)\n- Utile pour les messages d'erreur qui ne doivent pas se mlanger avec la sortie normale\n\n**Diffrence avec print :**\n- `print()`  stdout (sortie normale, peut tre redirige avec `>`)\n- `eprint()`  stderr (sortie d'erreur, peut tre redirige avec `2>`)\n\n```bash\n# Exemple shell: sparer stdout et stderr\n./hemlock script.hml > output.txt 2> errors.txt\n```\n\n---\n\n## Introspection de types\n\n### typeof\n\nObtient le nom du type d'une valeur.\n\n**Signature :**\n```hemlock\ntypeof(value: any): string\n```\n\n**Paramtres :**\n- `value` - N'importe quelle valeur\n\n**Retourne :** Nom du type sous forme de chane\n\n**Exemples :**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof(null));            // \"null\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\n// Objets typs\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n\n// Autres types\nprint(typeof(alloc(10)));       // \"ptr\"\nprint(typeof(buffer(10)));      // \"buffer\"\nprint(typeof(open(\"file.txt\"))); // \"file\"\n```\n\n**Noms de types :**\n- Primitifs : `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- Composites : `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- Spciaux : `\"file\"`, `\"task\"`, `\"channel\"`\n- Personnaliss : Noms de types dfinis par l'utilisateur avec `define`\n\n**Voir aussi :** [Systme de types](#reference-type-system)\n\n---\n\n## Excution de commandes\n\n### exec\n\nExcute une commande shell et capture la sortie.\n\n**Signature :**\n```hemlock\nexec(command: string): object\n```\n\n**Paramtres :**\n- `command` - Commande shell  excuter\n\n**Retourne :** Objet avec les champs :\n- `output` (string) - stdout de la commande\n- `exit_code` (i32) - Code de statut de sortie (0 = succs)\n\n**Exemples :**\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n\n// Vrifier le statut de sortie\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Trouv:\", r.output);\n} else {\n    print(\"Motif non trouv\");\n}\n\n// Traiter une sortie multi-lignes\nlet r2 = exec(\"ls -la\");\nlet lines = r2.output.split(\"\\n\");\n```\n\n**Comportement :**\n- Excute la commande via `/bin/sh`\n- Capture stdout uniquement (stderr va au terminal)\n- Bloque jusqu' ce que la commande se termine\n- Retourne une chane vide s'il n'y a pas de sortie\n\n**Gestion des erreurs :**\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command\");\n} catch (e) {\n    print(\"chec d'excution:\", e);\n}\n```\n\n**Avertissement de scurit :**  Vulnrable  l'injection shell. Toujours valider/assainir l'entre utilisateur.\n\n**Limitations :**\n- Pas de capture de stderr\n- Pas de streaming\n- Pas de timeout\n- Pas de gestion des signaux\n\n---\n\n### exec_argv\n\nExcute une commande avec un tableau d'arguments explicite (pas d'interprtation shell).\n\n**Signature :**\n```hemlock\nexec_argv(argv: array): object\n```\n\n**Paramtres :**\n- `argv` - Tableau de chanes : `[commande, arg1, arg2, ...]`\n\n**Retourne :** Objet avec les champs :\n- `output` (string) - stdout de la commande\n- `exit_code` (i32) - Code de statut de sortie (0 = succs)\n\n**Exemples :**\n```hemlock\n// Commande simple\nlet result = exec_argv([\"ls\", \"-la\"]);\nprint(result.output);\n\n// Commande avec arguments contenant des espaces (sr !)\nlet r = exec_argv([\"grep\", \"hello world\", \"file.txt\"]);\n\n// Excuter un script avec arguments\nlet r2 = exec_argv([\"python\", \"script.py\", \"--input\", \"data.json\"]);\nprint(r2.exit_code);\n```\n\n**Diffrence avec exec :**\n```hemlock\n// exec() utilise le shell - NON SR avec l'entre utilisateur\nexec(\"ls \" + user_input);  // Risque d'injection shell !\n\n// exec_argv() contourne le shell - SR\nexec_argv([\"ls\", user_input]);  // Pas d'injection possible\n```\n\n**Quand utiliser :**\n- Quand les arguments contiennent des espaces, guillemets ou caractres spciaux\n- Lors du traitement de l'entre utilisateur (scurit)\n- Quand vous avez besoin d'un parsing d'arguments prvisible\n\n**Voir aussi :** `exec()` pour les commandes shell simples\n\n---\n\n## Gestion des erreurs\n\n### throw\n\nLve une exception.\n\n**Signature :**\n```hemlock\nthrow expression\n```\n\n**Paramtres :**\n- `expression` - Valeur  lever (n'importe quel type)\n\n**Retourne :** Ne retourne jamais (transfre le contrle)\n\n**Exemples :**\n```hemlock\nthrow \"message d'erreur\";\nthrow 404;\nthrow { code: 500, message: \"Erreur interne\" };\nthrow null;\n```\n\n**Voir aussi :** instructions try/catch/finally\n\n---\n\n### panic\n\nTermine immdiatement le programme avec un message d'erreur (irrcuprable).\n\n**Signature :**\n```hemlock\npanic(message?: any): never\n```\n\n**Paramtres :**\n- `message` (optionnel) - Message d'erreur  afficher\n\n**Retourne :** Ne retourne jamais (le programme se termine)\n\n**Exemples :**\n```hemlock\npanic();                          // Par dfaut: \"panic!\"\npanic(\"code inaccessible atteint\");\npanic(42);\n\n// Cas d'utilisation courant\nfn process_state(state: i32): string {\n    if (state == 1) { return \"prt\"; }\n    if (state == 2) { return \"en cours\"; }\n    panic(\"tat invalide: \" + typeof(state));\n}\n```\n\n**Comportement :**\n- Affiche l'erreur sur stderr : `panic: <message>`\n- Quitte avec le code 1\n- **NON rattrapable** avec try/catch\n- Utiliser pour les bugs et erreurs irrcuprables\n\n**Panic vs Throw :**\n- `panic()` - Erreur irrcuprable, quitte immdiatement\n- `throw` - Erreur rcuprable, peut tre rattrape\n\n---\n\n### assert\n\nAffirme qu'une condition est vraie, ou termine avec un message d'erreur.\n\n**Signature :**\n```hemlock\nassert(condition: any, message?: string): null\n```\n\n**Paramtres :**\n- `condition` - Valeur  vrifier pour la vracit\n- `message` (optionnel) - Message d'erreur personnalis si l'assertion choue\n\n**Retourne :** `null` (si l'assertion russit)\n\n**Exemples :**\n```hemlock\n// Assertions basiques\nassert(x > 0);\nassert(name != null);\nassert(arr.length > 0, \"Le tableau ne doit pas tre vide\");\n\n// Avec messages personnaliss\nfn divide(a: i32, b: i32): f64 {\n    assert(b != 0, \"Division par zro\");\n    return a / b;\n}\n\n// Valider les arguments de fonction\nfn process_data(data: array) {\n    assert(data != null, \"data ne peut pas tre null\");\n    assert(data.length > 0, \"data ne peut pas tre vide\");\n    // ...\n}\n```\n\n**Comportement :**\n- Si la condition est vraie : retourne `null`, l'excution continue\n- Si la condition est fausse : affiche l'erreur et quitte avec le code 1\n- Valeurs fausses : `false`, `0`, `0.0`, `null`, `\"\"` (chane vide)\n- Valeurs vraies : tout le reste\n\n**Sortie en cas d'chec :**\n```\nAssertion failed: Le tableau ne doit pas tre vide\n```\n\n**Quand utiliser :**\n- Validation des prconditions de fonction\n- Vrification des invariants pendant le dveloppement\n- Attraper les erreurs de programmation tt\n\n**assert vs panic :**\n- `assert(cond, msg)` - Vrifie une condition, choue si fausse\n- `panic(msg)` - choue toujours inconditionnellement\n\n---\n\n## Gestion des signaux\n\n### signal\n\nEnregistre ou rinitialise un gestionnaire de signal.\n\n**Signature :**\n```hemlock\nsignal(signum: i32, handler: function | null): function | null\n```\n\n**Paramtres :**\n- `signum` - Numro de signal (utiliser des constantes comme `SIGINT`)\n- `handler` - Fonction  appeler quand le signal est reu, ou `null` pour rinitialiser par dfaut\n\n**Retourne :** Fonction gestionnaire prcdente, ou `null`\n\n**Exemples :**\n```hemlock\nfn handle_interrupt(sig) {\n    print(\"SIGINT intercept !\");\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Rinitialiser par dfaut\nsignal(SIGINT, null);\n```\n\n**Signature du gestionnaire :**\n```hemlock\nfn handler(signum: i32) {\n    // signum contient le numro du signal\n}\n```\n\n**Voir aussi :**\n- [Constantes de signal](#constantes-de-signal)\n- `raise()`\n\n---\n\n### raise\n\nEnvoie un signal au processus courant.\n\n**Signature :**\n```hemlock\nraise(signum: i32): null\n```\n\n**Paramtres :**\n- `signum` - Numro de signal  lever\n\n**Retourne :** `null`\n\n**Exemples :**\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\nraise(SIGUSR1);\nraise(SIGUSR1);\nprint(count);  // 2\n```\n\n---\n\n## Variables globales\n\n### args\n\nTableau des arguments de ligne de commande.\n\n**Type :** `array` de chanes\n\n**Structure :**\n- `args[0]` - Nom du fichier script\n- `args[1..n]` - Arguments de ligne de commande\n\n**Exemples :**\n```bash\n# Commande: ./hemlock script.hml hello world\n```\n\n```hemlock\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // 3\nprint(args[1]);        // \"hello\"\nprint(args[2]);        // \"world\"\n\n// Itrer sur les arguments\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument\", i, \":\", args[i]);\n    i = i + 1;\n}\n```\n\n**Comportement REPL :** Dans le REPL, `args.length` est 0 (tableau vide)\n\n---\n\n## Constantes de signal\n\nConstantes de signal POSIX standard (valeurs i32) :\n\n### Interruption et terminaison\n\n| Constante  | Valeur | Description                            |\n|------------|--------|----------------------------------------|\n| `SIGINT`   | 2      | Interruption depuis le clavier (Ctrl+C)|\n| `SIGTERM`  | 15     | Demande de terminaison                 |\n| `SIGQUIT`  | 3      | Quitter depuis le clavier (Ctrl+\\)     |\n| `SIGHUP`   | 1      | Dconnexion dtecte sur le terminal   |\n| `SIGABRT`  | 6      | Signal d'abandon                       |\n\n### Dfinis par l'utilisateur\n\n| Constante  | Valeur | Description                |\n|------------|--------|----------------------------|\n| `SIGUSR1`  | 10     | Signal dfini par l'utilisateur 1 |\n| `SIGUSR2`  | 12     | Signal dfini par l'utilisateur 2 |\n\n### Contrle de processus\n\n| Constante  | Valeur | Description                     |\n|------------|--------|---------------------------------|\n| `SIGALRM`  | 14     | Minuterie d'alarme              |\n| `SIGCHLD`  | 17     | Changement de statut du processus enfant |\n| `SIGCONT`  | 18     | Continuer si arrt             |\n| `SIGSTOP`  | 19     | Arrter le processus (ne peut pas tre intercept) |\n| `SIGTSTP`  | 20     | Arrt terminal (Ctrl+Z)         |\n\n### E/S\n\n| Constante  | Valeur | Description                        |\n|------------|--------|------------------------------------|\n| `SIGPIPE`  | 13     | Pipe cass                         |\n| `SIGTTIN`  | 21     | Lecture en arrire-plan depuis le terminal |\n| `SIGTTOU`  | 22     | criture en arrire-plan vers le terminal |\n\n**Exemples :**\n```hemlock\nfn handle_signal(sig) {\n    if (sig == SIGINT) {\n        print(\"Interruption dtecte\");\n    }\n    if (sig == SIGTERM) {\n        print(\"Terminaison demande\");\n    }\n}\n\nsignal(SIGINT, handle_signal);\nsignal(SIGTERM, handle_signal);\n```\n\n**Note :** `SIGKILL` (9) et `SIGSTOP` (19) ne peuvent pas tre intercepts ou ignors.\n\n---\n\n## Fonctions mathmatiques/arithmtiques\n\n### div\n\nDivision entire (floor) retournant un flottant.\n\n**Signature :**\n```hemlock\ndiv(a: number, b: number): f64\n```\n\n**Paramtres :**\n- `a` - Dividende\n- `b` - Diviseur\n\n**Retourne :** Partie entire de `a / b` sous forme de flottant (f64)\n\n**Exemples :**\n```hemlock\nlet result = div(7, 2);    // 3.0 (pas 3.5)\nlet result2 = div(10, 3);  // 3.0\nlet result3 = div(-7, 2);  // -4.0 (floor arrondit vers l'infini ngatif)\n```\n\n**Note :** Dans Hemlock, l'oprateur `/` retourne toujours un flottant. Utilisez `div()` pour la division entire quand vous avez besoin de la partie entire sous forme de flottant, ou `divi()` quand vous avez besoin d'un rsultat entier.\n\n---\n\n### divi\n\nDivision entire (floor) retournant un entier.\n\n**Signature :**\n```hemlock\ndivi(a: number, b: number): i64\n```\n\n**Paramtres :**\n- `a` - Dividende\n- `b` - Diviseur\n\n**Retourne :** Partie entire de `a / b` sous forme d'entier (i64)\n\n**Exemples :**\n```hemlock\nlet result = divi(7, 2);    // 3\nlet result2 = divi(10, 3);  // 3\nlet result3 = divi(-7, 2);  // -4 (floor arrondit vers l'infini ngatif)\n```\n\n**Comparaison :**\n```hemlock\nprint(7 / 2);      // 3.5 (division rgulire, toujours flottant)\nprint(div(7, 2));  // 3.0 (division entire, rsultat flottant)\nprint(divi(7, 2)); // 3   (division entire, rsultat entier)\n```\n\n---\n\n## Fonctions de gestion de la mmoire\n\nVoir [API Memory](#reference-memory-api) pour la rfrence complte :\n- `alloc(size)` - Allouer de la mmoire brute\n- `free(ptr)` - Librer la mmoire\n- `buffer(size)` - Allouer un buffer scuris\n- `memset(ptr, byte, size)` - Remplir la mmoire\n- `memcpy(dest, src, size)` - Copier la mmoire\n- `realloc(ptr, new_size)` - Redimensionner l'allocation\n\n### sizeof\n\nObtient la taille d'un type en octets.\n\n**Signature :**\n```hemlock\nsizeof(type): i32\n```\n\n**Paramtres :**\n- `type` - Une constante de type (`i32`, `f64`, `ptr`, etc.) ou une chane de nom de type\n\n**Retourne :** Taille en octets sous forme de `i32`\n\n**Exemples :**\n```hemlock\nprint(sizeof(i8));       // 1\nprint(sizeof(i16));      // 2\nprint(sizeof(i32));      // 4\nprint(sizeof(i64));      // 8\nprint(sizeof(f32));      // 4\nprint(sizeof(f64));      // 8\nprint(sizeof(ptr));      // 8\nprint(sizeof(rune));     // 4\n\n// Utilisation des alias de type\nprint(sizeof(byte));     // 1 (identique  u8)\nprint(sizeof(integer));  // 4 (identique  i32)\nprint(sizeof(number));   // 8 (identique  f64)\n\n// La forme chane fonctionne aussi\nprint(sizeof(\"i32\"));    // 4\n```\n\n**Types supports :**\n| Type | Taille | Alias |\n|------|--------|-------|\n| `i8` | 1 | - |\n| `i16` | 2 | - |\n| `i32` | 4 | `integer` |\n| `i64` | 8 | - |\n| `u8` | 1 | `byte` |\n| `u16` | 2 | - |\n| `u32` | 4 | - |\n| `u64` | 8 | - |\n| `f32` | 4 | - |\n| `f64` | 8 | `number` |\n| `ptr` | 8 | - |\n| `rune` | 4 | - |\n| `bool` | 1 | - |\n\n**Voir aussi :** `talloc()` pour l'allocation type\n\n---\n\n### talloc\n\nAlloue de la mmoire pour un tableau typ (allocation sensible au type).\n\n**Signature :**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**Paramtres :**\n- `type` - Une constante de type (`i32`, `f64`, `ptr`, etc.)\n- `count` - Nombre d'lments  allouer\n\n**Retourne :** `ptr` vers la mmoire alloue, ou `null` en cas d'chec\n\n**Exemples :**\n```hemlock\n// Allouer tableau de 10 i32 (40 octets)\nlet int_arr = talloc(i32, 10);\nptr_write_i32(int_arr, 42);\nptr_write_i32(ptr_offset(int_arr, 1, 4), 100);\n\n// Allouer tableau de 5 f64 (40 octets)\nlet float_arr = talloc(f64, 5);\n\n// Allouer tableau de 100 octets\nlet byte_arr = talloc(u8, 100);\n\n// N'oubliez pas de librer !\nfree(int_arr);\nfree(float_arr);\nfree(byte_arr);\n```\n\n**Comparaison avec alloc :**\n```hemlock\n// Ces deux sont quivalents:\nlet p1 = talloc(i32, 10);      // Sensible au type: 10 i32\nlet p2 = alloc(sizeof(i32) * 10);  // Calcul manuel\n\n// talloc est plus clair et moins sujet aux erreurs\n```\n\n**Gestion des erreurs :**\n- Retourne `null` si l'allocation choue\n- Quitte avec erreur si count n'est pas positif\n- Vrifie le dpassement de taille (count * element_size)\n\n**Voir aussi :** `alloc()`, `sizeof()`, `free()`\n\n---\n\n## Helpers de pointeurs FFI\n\nCes fonctions aident  lire et crire des valeurs types dans la mmoire brute, utiles pour FFI et la manipulation de mmoire de bas niveau.\n\n### ptr_null\n\nCre un pointeur null.\n\n**Signature :**\n```hemlock\nptr_null(): ptr\n```\n\n**Retourne :** Un pointeur null\n\n**Exemple :**\n```hemlock\nlet p = ptr_null();\nif (p == null) {\n    print(\"Le pointeur est null\");\n}\n```\n\n---\n\n### ptr_offset\n\nCalcule le dcalage de pointeur (arithmtique de pointeur).\n\n**Signature :**\n```hemlock\nptr_offset(ptr: ptr, index: i32, element_size: i32): ptr\n```\n\n**Paramtres :**\n- `ptr` - Pointeur de base\n- `index` - Index de l'lment\n- `element_size` - Taille de chaque lment en octets\n\n**Retourne :** Pointeur vers l'lment  l'index donn\n\n**Exemple :**\n```hemlock\nlet arr = talloc(i32, 10);\nptr_write_i32(arr, 100);                      // arr[0] = 100\nptr_write_i32(ptr_offset(arr, 1, 4), 200);    // arr[1] = 200\nptr_write_i32(ptr_offset(arr, 2, 4), 300);    // arr[2] = 300\n\nprint(ptr_read_i32(ptr_offset(arr, 1, 4)));   // 200\nfree(arr);\n```\n\n---\n\n### Fonctions de lecture de pointeur\n\nLisent des valeurs types depuis la mmoire.\n\n| Fonction | Signature | Retourne | Description |\n|----------|-----------|----------|-------------|\n| `ptr_read_i8` | `(ptr)` | `i8` | Lire entier sign 8 bits |\n| `ptr_read_i16` | `(ptr)` | `i16` | Lire entier sign 16 bits |\n| `ptr_read_i32` | `(ptr)` | `i32` | Lire entier sign 32 bits |\n| `ptr_read_i64` | `(ptr)` | `i64` | Lire entier sign 64 bits |\n| `ptr_read_u8` | `(ptr)` | `u8` | Lire entier non sign 8 bits |\n| `ptr_read_u16` | `(ptr)` | `u16` | Lire entier non sign 16 bits |\n| `ptr_read_u32` | `(ptr)` | `u32` | Lire entier non sign 32 bits |\n| `ptr_read_u64` | `(ptr)` | `u64` | Lire entier non sign 64 bits |\n| `ptr_read_f32` | `(ptr)` | `f32` | Lire flottant 32 bits |\n| `ptr_read_f64` | `(ptr)` | `f64` | Lire flottant 64 bits |\n| `ptr_read_ptr` | `(ptr)` | `ptr` | Lire valeur de pointeur |\n\n**Exemple :**\n```hemlock\nlet p = alloc(8);\nptr_write_f64(p, 3.14159);\nlet value = ptr_read_f64(p);\nprint(value);  // 3.14159\nfree(p);\n```\n\n---\n\n### Fonctions d'criture de pointeur\n\ncrivent des valeurs types dans la mmoire.\n\n| Fonction | Signature | Retourne | Description |\n|----------|-----------|----------|-------------|\n| `ptr_write_i8` | `(ptr, value)` | `null` | crire entier sign 8 bits |\n| `ptr_write_i16` | `(ptr, value)` | `null` | crire entier sign 16 bits |\n| `ptr_write_i32` | `(ptr, value)` | `null` | crire entier sign 32 bits |\n| `ptr_write_i64` | `(ptr, value)` | `null` | crire entier sign 64 bits |\n| `ptr_write_u8` | `(ptr, value)` | `null` | crire entier non sign 8 bits |\n| `ptr_write_u16` | `(ptr, value)` | `null` | crire entier non sign 16 bits |\n| `ptr_write_u32` | `(ptr, value)` | `null` | crire entier non sign 32 bits |\n| `ptr_write_u64` | `(ptr, value)` | `null` | crire entier non sign 64 bits |\n| `ptr_write_f32` | `(ptr, value)` | `null` | crire flottant 32 bits |\n| `ptr_write_f64` | `(ptr, value)` | `null` | crire flottant 64 bits |\n| `ptr_write_ptr` | `(ptr, value)` | `null` | crire valeur de pointeur |\n\n**Exemple :**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\nprint(ptr_read_i32(p));  // 42\nfree(p);\n```\n\n---\n\n### Conversion buffer/pointeur\n\n#### buffer_ptr\n\nObtient le pointeur brut depuis un buffer.\n\n**Signature :**\n```hemlock\nbuffer_ptr(buf: buffer): ptr\n```\n\n**Exemple :**\n```hemlock\nlet buf = buffer(64);\nlet p = buffer_ptr(buf);\n// Maintenant p pointe vers la mme mmoire que buf\n```\n\n#### ptr_to_buffer\n\nCre un wrapper buffer autour d'un pointeur brut.\n\n**Signature :**\n```hemlock\nptr_to_buffer(ptr: ptr, size: i32): buffer\n```\n\n**Exemple :**\n```hemlock\nlet p = alloc(64);\nlet buf = ptr_to_buffer(p, 64);\nbuf[0] = 65;  // Maintenant a une vrification des limites\n// Note: librer buf librera la mmoire sous-jacente\n```\n\n---\n\n## Fonctions d'E/S fichier\n\nVoir [API File](#reference-file-api) pour la rfrence complte :\n- `open(path, mode?)` - Ouvrir un fichier\n\n---\n\n## Fonctions de concurrence\n\nVoir [API Concurrency](#reference-concurrency-api) pour la rfrence complte :\n- `spawn(fn, args...)` - Lancer une tche\n- `join(task)` - Attendre une tche\n- `detach(task)` - Dtacher une tche\n- `channel(capacity)` - Crer un canal\n\n### apply\n\nAppelle une fonction dynamiquement avec un tableau d'arguments.\n\n**Signature :**\n```hemlock\napply(fn: function, args: array): any\n```\n\n**Paramtres :**\n- `fn` - La fonction  appeler\n- `args` - Tableau d'arguments  passer  la fonction\n\n**Retourne :** La valeur de retour de la fonction appele\n\n**Exemples :**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\n// Appeler avec un tableau d'arguments\nlet result = apply(add, [2, 3]);\nprint(result);  // 5\n\n// Dispatch dynamique\nlet operations = {\n    add: fn(a, b) { return a + b; },\n    mul: fn(a, b) { return a * b; },\n    sub: fn(a, b) { return a - b; }\n};\n\nfn calculate(op: string, args: array) {\n    return apply(operations[op], args);\n}\n\nprint(calculate(\"add\", [10, 5]));  // 15\nprint(calculate(\"mul\", [10, 5]));  // 50\nprint(calculate(\"sub\", [10, 5]));  // 5\n\n// Arguments variables\nfn sum(...nums) {\n    let total = 0;\n    for (n in nums) {\n        total = total + n;\n    }\n    return total;\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(apply(sum, numbers));  // 15\n```\n\n**Cas d'utilisation :**\n- Dispatch dynamique de fonction bas sur des valeurs  l'excution\n- Appel de fonctions avec des listes d'arguments variables\n- Implmentation d'utilitaires d'ordre suprieur (map, filter, etc.)\n- Systmes de plugins/extensions\n\n---\n\n### select\n\nAttend des donnes de plusieurs canaux, retourne quand l'un a des donnes.\n\n**Signature :**\n```hemlock\nselect(channels: array, timeout_ms?: i32): object | null\n```\n\n**Paramtres :**\n- `channels` - Tableau de valeurs de canal\n- `timeout_ms` (optionnel) - Timeout en millisecondes (-1 ou omettre pour infini)\n\n**Retourne :**\n- `{ channel, value }` - Objet avec le canal qui avait des donnes et la valeur reue\n- `null` - En cas de timeout\n\n**Exemples :**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// Tches productrices\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"du canal 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"du canal 2\");\n});\n\n// Attendre le premier message\nlet result = select([ch1, ch2]);\nprint(result.value);  // \"du canal 2\" (arriv en premier)\n\n// Avec timeout\nlet result2 = select([ch1, ch2], 1000);  // Attendre jusqu' 1 seconde\nif (result2 == null) {\n    print(\"Timeout - pas de donnes reues\");\n} else {\n    print(\"Reu:\", result2.value);\n}\n\n// Boucle de select continue\nwhile (true) {\n    let msg = select([ch1, ch2], 5000);\n    if (msg == null) {\n        print(\"Pas d'activit depuis 5 secondes\");\n        break;\n    }\n    print(\"Message reu:\", msg.value);\n}\n```\n\n**Comportement :**\n- Bloque jusqu' ce qu'un canal ait des donnes ou que le timeout expire\n- Retourne immdiatement si un canal a dj des donnes\n- Si le canal est ferm et vide, retourne `{ channel, value: null }`\n- Interroge les canaux dans l'ordre (le premier canal prt gagne)\n\n**Cas d'utilisation :**\n- Multiplexage de plusieurs producteurs\n- Implmentation de timeouts sur les oprations de canal\n- Construction de boucles d'vnements avec plusieurs sources\n\n---\n\n## Tableau rcapitulatif\n\n### Fonctions\n\n| Fonction   | Catgorie        | Retourne     | Description                          |\n|------------|------------------|--------------|--------------------------------------|\n| `print`    | E/S              | `null`       | Afficher sur stdout                  |\n| `read_line`| E/S              | `string?`    | Lire une ligne depuis stdin          |\n| `eprint`   | E/S              | `null`       | Afficher sur stderr                  |\n| `typeof`   | Type             | `string`     | Obtenir le nom du type               |\n| `exec`     | Commande         | `object`     | Excuter une commande shell          |\n| `exec_argv`| Commande         | `object`     | Excuter avec tableau d'arguments    |\n| `assert`   | Erreur           | `null`       | Affirmer une condition ou quitter    |\n| `panic`    | Erreur           | `never`      | Erreur irrcuprable (quitte)        |\n| `signal`   | Signal           | `function?`  | Enregistrer un gestionnaire de signal|\n| `raise`    | Signal           | `null`       | Envoyer un signal au processus       |\n| `alloc`    | Mmoire          | `ptr`        | Allouer de la mmoire brute          |\n| `talloc`   | Mmoire          | `ptr`        | Allocation type                     |\n| `sizeof`   | Mmoire          | `i32`        | Obtenir la taille du type en octets  |\n| `free`     | Mmoire          | `null`       | Librer la mmoire                   |\n| `buffer`   | Mmoire          | `buffer`     | Allouer un buffer scuris           |\n| `memset`   | Mmoire          | `null`       | Remplir la mmoire                   |\n| `memcpy`   | Mmoire          | `null`       | Copier la mmoire                    |\n| `realloc`  | Mmoire          | `ptr`        | Redimensionner l'allocation          |\n| `open`     | E/S fichier      | `file`       | Ouvrir un fichier                    |\n| `spawn`    | Concurrence      | `task`       | Lancer une tche concurrente         |\n| `join`     | Concurrence      | `any`        | Attendre le rsultat de la tche     |\n| `detach`   | Concurrence      | `null`       | Dtacher la tche                    |\n| `channel`  | Concurrence      | `channel`    | Crer un canal de communication      |\n| `select`   | Concurrence      | `object?`    | Attendre sur plusieurs canaux        |\n| `apply`    | Fonctions        | `any`        | Appeler fonction avec tableau d'args |\n\n### Variables globales\n\n| Variable   | Type     | Description                       |\n|------------|----------|-----------------------------------|\n| `args`     | `array`  | Arguments de ligne de commande    |\n\n### Constantes\n\n| Constante  | Type  | Catgorie | Valeur | Description               |\n|------------|-------|-----------|--------|---------------------------|\n| `SIGINT`   | `i32` | Signal    | 2      | Interruption clavier      |\n| `SIGTERM`  | `i32` | Signal    | 15     | Demande de terminaison    |\n| `SIGQUIT`  | `i32` | Signal    | 3      | Quitter clavier           |\n| `SIGHUP`   | `i32` | Signal    | 1      | Dconnexion               |\n| `SIGABRT`  | `i32` | Signal    | 6      | Abandon                   |\n| `SIGUSR1`  | `i32` | Signal    | 10     | Dfini par l'utilisateur 1|\n| `SIGUSR2`  | `i32` | Signal    | 12     | Dfini par l'utilisateur 2|\n| `SIGALRM`  | `i32` | Signal    | 14     | Minuterie d'alarme        |\n| `SIGCHLD`  | `i32` | Signal    | 17     | Changement statut enfant  |\n| `SIGCONT`  | `i32` | Signal    | 18     | Continuer                 |\n| `SIGSTOP`  | `i32` | Signal    | 19     | Arrt (non interceptable) |\n| `SIGTSTP`  | `i32` | Signal    | 20     | Arrt terminal            |\n| `SIGPIPE`  | `i32` | Signal    | 13     | Pipe cass                |\n| `SIGTTIN`  | `i32` | Signal    | 21     | Lecture terminal en arrire-plan |\n| `SIGTTOU`  | `i32` | Signal    | 22     | criture terminal en arrire-plan |\n\n---\n\n## Voir aussi\n\n- [Systme de types](#reference-type-system) - Types et conversions\n- [API Memory](#reference-memory-api) - Fonctions d'allocation mmoire\n- [API File](#reference-file-api) - Fonctions d'E/S fichier\n- [API Concurrency](#reference-concurrency-api) - Fonctions async/concurrence\n- [API String](#reference-string-api) - Mthodes des chanes\n- [API Array](#reference-array-api) - Mthodes des tableaux\n"}, "Rfrence API -> Oprateurs": {"id": "reference-operators", "content": "# Rfrence des oprateurs\n\nRfrence complte pour tous les oprateurs dans Hemlock, y compris la priorit, l'associativit et le comportement.\n\n---\n\n## Aperu\n\nHemlock fournit des oprateurs de style C avec des rgles de priorit explicites. Tous les oprateurs suivent des rgles de typage strictes avec promotion de type automatique lorsque applicable.\n\n---\n\n## Oprateurs arithmtiques\n\n### Arithmtique binaire\n\n| Oprateur | Nom            | Exemple    | Description                    |\n|-----------|----------------|------------|--------------------------------|\n| `+`       | Addition       | `a + b`    | Additionner deux valeurs       |\n| `-`       | Soustraction   | `a - b`    | Soustraire b de a              |\n| `*`       | Multiplication | `a * b`    | Multiplier deux valeurs        |\n| `/`       | Division       | `a / b`    | Diviser a par b                |\n\n**Promotion de type :**\nLes rsultats suivent les rgles de promotion de type (voir [Systme de types](type-system.md#rgles-de-promotion-de-type)).\n\n**Exemples :**\n```hemlock\nlet a = 10 + 5;        // 15 (i32)\nlet b = 10 - 3;        // 7 (i32)\nlet c = 4 * 5;         // 20 (i32)\nlet d = 20 / 4;        // 5 (i32)\n\n// Division flottante\nlet e = 10.0 / 3.0;    // 3.333... (f64)\n\n// Types mixtes\nlet f: u8 = 10;\nlet g: i32 = 20;\nlet h = f + g;         // 30 (i32, promu)\n```\n\n**Division par zro :**\n- Division entire par zro : Erreur d'excution\n- Division flottante par zro : Retourne `inf` ou `-inf`\n\n---\n\n### Arithmtique unaire\n\n| Oprateur | Nom      | Exemple | Description          |\n|-----------|----------|---------|----------------------|\n| `-`       | Ngation | `-a`    | Ngation de la valeur|\n| `+`       | Plus     | `+a`    | Identit (pas d'effet)|\n\n**Exemples :**\n```hemlock\nlet a = 5;\nlet b = -a;            // -5\nlet c = +a;            // 5 (pas de changement)\n\nlet x = -3.14;         // -3.14\n```\n\n---\n\n## Oprateurs de comparaison\n\n| Oprateur | Nom                       | Exemple    | Retourne |\n|-----------|---------------------------|------------|----------|\n| `==`      | gal                      | `a == b`   | `bool`   |\n| `!=`      | Diffrent                 | `a != b`   | `bool`   |\n| `<`       | Infrieur                | `a < b`    | `bool`   |\n| `>`       | Suprieur                | `a > b`    | `bool`   |\n| `<=`      | Infrieur ou gal        | `a <= b`   | `bool`   |\n| `>=`      | Suprieur ou gal        | `a >= b`   | `bool`   |\n\n**Promotion de type :**\nLes oprandes sont promus avant la comparaison.\n\n**Exemples :**\n```hemlock\nprint(5 == 5);         // true\nprint(10 != 5);        // true\nprint(3 < 7);          // true\nprint(10 > 5);         // true\nprint(5 <= 5);         // true\nprint(10 >= 5);        // true\n\n// Comparaison de chanes\nprint(\"hello\" == \"hello\");  // true\nprint(\"abc\" < \"def\");       // true (lexicographique)\n\n// Types mixtes\nlet a: u8 = 10;\nlet b: i32 = 10;\nprint(a == b);         // true (promu en i32)\n```\n\n---\n\n## Oprateurs logiques\n\n| Oprateur | Nom         | Exemple      | Description                    |\n|-----------|-------------|--------------|--------------------------------|\n| `&&`      | ET logique  | `a && b`     | Vrai si les deux sont vrais    |\n| `||`      | OU logique  | `a || b`     | Vrai si l'un est vrai          |\n| `!`       | NON logique | `!a`         | Ngation boolenne             |\n\n**valuation en court-circuit :**\n- `&&` - S'arrte  la premire valeur fausse\n- `||` - S'arrte  la premire valeur vraie\n\n**Exemples :**\n```hemlock\nlet a = true;\nlet b = false;\n\nprint(a && b);         // false\nprint(a || b);         // true\nprint(!a);             // false\nprint(!b);             // true\n\n// Court-circuit\nif (x != 0 && (10 / x) > 2) {\n    print(\"sr\");\n}\n\nif (x == 0 || (10 / x) > 2) {\n    print(\"sr\");\n}\n```\n\n---\n\n## Oprateurs bit  bit\n\n**Restriction :** Types entiers uniquement (i8-i64, u8-u64)\n\n### Bit  bit binaire\n\n| Oprateur | Nom              | Exemple    | Description               |\n|-----------|------------------|------------|---------------------------|\n| `&`       | ET bit  bit     | `a & b`    | ET sur chaque bit         |\n| `|`       | OU bit  bit     | `a | b`    | OU sur chaque bit         |\n| `^`       | XOR bit  bit    | `a ^ b`    | XOR sur chaque bit        |\n| `<<`      | Dcalage gauche  | `a << b`   | Dcaler  gauche de b bits|\n| `>>`      | Dcalage droite  | `a >> b`   | Dcaler  droite de b bits|\n\n**Prservation du type :**\nLe type du rsultat correspond aux types des oprandes (avec promotion de type).\n\n**Exemples :**\n```hemlock\nlet a = 12;  // 1100 en binaire\nlet b = 10;  // 1010 en binaire\n\nprint(a & b);          // 8  (1000)\nprint(a | b);          // 14 (1110)\nprint(a ^ b);          // 6  (0110)\nprint(a << 2);         // 48 (110000)\nprint(a >> 1);         // 6  (110)\n```\n\n**Exemple non sign :**\n```hemlock\nlet c: u8 = 15;        // 00001111\nlet d: u8 = 7;         // 00000111\n\nprint(c & d);          // 7  (00000111)\nprint(c | d);          // 15 (00001111)\nprint(c ^ d);          // 8  (00001000)\n```\n\n**Comportement du dcalage droit :**\n- Types signs : Dcalage arithmtique (tend le signe)\n- Types non signs : Dcalage logique (remplit avec des zros)\n\n---\n\n### Bit  bit unaire\n\n| Oprateur | Nom            | Exemple | Description               |\n|-----------|----------------|---------|---------------------------|\n| `~`       | NON bit  bit  | `~a`    | Inverse tous les bits     |\n\n**Exemples :**\n```hemlock\nlet a = 12;            // 00001100 (i32)\nprint(~a);             // -13 (complment  deux)\n\nlet b: u8 = 15;        // 00001111\nprint(~b);             // 240 (11110000)\n```\n\n---\n\n## Oprateurs de chane\n\n### Concatnation\n\n| Oprateur | Nom            | Exemple    | Description        |\n|-----------|----------------|------------|--------------------|\n| `+`       | Concatnation  | `a + b`    | Joindre des chanes|\n\n**Exemples :**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n\n// String + rune\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\n\n// Rune + string\nlet prefix = '>' + \" Message\";     // \"> Message\"\n```\n\n---\n\n## Oprateurs d'affectation\n\n### Affectation basique\n\n| Oprateur | Nom         | Exemple    | Description                   |\n|-----------|-------------|------------|-------------------------------|\n| `=`       | Affectation | `a = b`    | Affecter une valeur  une variable |\n\n**Exemples :**\n```hemlock\nlet x = 10;\nx = 20;\n\nlet arr = [1, 2, 3];\narr[0] = 99;\n\nlet obj = { x: 10 };\nobj.x = 20;\n```\n\n### Affectation compose\n\n#### Affectation compose arithmtique\n\n| Oprateur | Nom                   | Exemple    | quivalent         |\n|-----------|-----------------------|------------|--------------------|\n| `+=`      | Ajouter et affecter   | `a += b`   | `a = a + b`        |\n| `-=`      | Soustraire et affecter| `a -= b`   | `a = a - b`        |\n| `*=`      | Multiplier et affecter| `a *= b`   | `a = a * b`        |\n| `/=`      | Diviser et affecter   | `a /= b`   | `a = a / b`        |\n| `%=`      | Modulo et affecter    | `a %= b`   | `a = a % b`        |\n\n**Exemples :**\n```hemlock\nlet x = 10;\nx += 5;      // x vaut maintenant 15\nx -= 3;      // x vaut maintenant 12\nx *= 2;      // x vaut maintenant 24\nx /= 4;      // x vaut maintenant 6\n\nlet count = 0;\ncount += 1;  // Incrmenter de 1\n```\n\n#### Affectation compose bit  bit\n\n| Oprateur | Nom                        | Exemple     | quivalent          |\n|-----------|----------------------------|-------------|---------------------|\n| `&=`      | ET bit  bit et affecter   | `a &= b`    | `a = a & b`         |\n| `\\|=`     | OU bit  bit et affecter   | `a \\|= b`   | `a = a \\| b`        |\n| `^=`      | XOR bit  bit et affecter  | `a ^= b`    | `a = a ^ b`         |\n| `<<=`     | Dcaler gauche et affecter | `a <<= b`   | `a = a << b`        |\n| `>>=`     | Dcaler droite et affecter | `a >>= b`   | `a = a >> b`        |\n\n**Exemples :**\n```hemlock\nlet flags = 0b1111;\nflags &= 0b0011;   // flags vaut maintenant 0b0011 (masquer les bits suprieurs)\nflags |= 0b1000;   // flags vaut maintenant 0b1011 (activer un bit)\nflags ^= 0b0001;   // flags vaut maintenant 0b1010 (basculer un bit)\n\nlet x = 1;\nx <<= 4;           // x vaut maintenant 16 (dcaler  gauche de 4)\nx >>= 2;           // x vaut maintenant 4 (dcaler  droite de 2)\n```\n\n### Incrmentation/Dcrmentation\n\n| Oprateur | Nom           | Exemple | Description                    |\n|-----------|---------------|---------|--------------------------------|\n| `++`      | Incrmentation| `a++`   | Incrmenter de 1 (postfixe)    |\n| `--`      | Dcrmentation| `a--`   | Dcrmenter de 1 (postfixe)    |\n\n**Exemples :**\n```hemlock\nlet i = 0;\ni++;         // i vaut maintenant 1\ni++;         // i vaut maintenant 2\ni--;         // i vaut maintenant 1\n\n// Courant dans les boucles\nfor (let j = 0; j < 10; j++) {\n    print(j);\n}\n```\n\n**Note :** `++` et `--` sont des oprateurs postfixes (la valeur est retourne avant l'incrmentation/dcrmentation)\n\n---\n\n## Oprateurs de scurit null\n\n### Coalescence null (`??`)\n\nRetourne l'oprande gauche s'il n'est pas null, sinon retourne l'oprande droit.\n\n| Oprateur | Nom              | Exemple      | Description                      |\n|-----------|------------------|--------------|----------------------------------|\n| `??`      | Coalescence null | `a ?? b`     | Retourner a si non null, sinon b |\n\n**Exemples :**\n```hemlock\nlet name = null;\nlet display = name ?? \"Anonyme\";  // \"Anonyme\"\n\nlet value = 42;\nlet result = value ?? 0;            // 42\n\n// Chanage\nlet a = null;\nlet b = null;\nlet c = \"trouv\";\nlet result2 = a ?? b ?? c;          // \"trouv\"\n\n// Avec des appels de fonction\nfn get_config() { return null; }\nlet config = get_config() ?? { default: true };\n```\n\n---\n\n### Chanage optionnel (`?.`)\n\nAccde en toute scurit aux proprits ou appelle des mthodes sur des valeurs potentiellement null.\n\n| Oprateur | Nom                 | Exemple        | Description                           |\n|-----------|---------------------|----------------|---------------------------------------|\n| `?.`      | Chanage optionnel  | `a?.b`         | Retourner a.b si a non null, sinon null |\n| `?.[`     | Index optionnel     | `a?.[0]`       | Retourner a[0] si a non null, sinon null |\n| `?.(`     | Appel optionnel     | `a?.()`        | Appeler a() si a non null, sinon null |\n\n**Exemples :**\n```hemlock\nlet user = null;\nlet name = user?.name;              // null (pas d'erreur)\n\nlet person = { name: \"Alice\", address: null };\nlet city = person?.address?.city;   // null (navigation sre)\n\n// Avec des tableaux\nlet arr = null;\nlet first = arr?.[0];               // null\n\nlet items = [1, 2, 3];\nlet second = items?.[1];            // 2\n\n// Avec des appels de mthode\nlet obj = { greet: fn() { return \"Hello\"; } };\nlet greeting = obj?.greet?.();      // \"Hello\"\n\nlet empty = null;\nlet result = empty?.method?.();     // null\n```\n\n**Comportement :**\n- Si l'oprande gauche est null, toute l'expression court-circuite vers null\n- Si l'oprande gauche n'est pas null, l'accs se poursuit normalement\n- Peut tre chan pour un accs profond aux proprits\n\n---\n\n## Oprateurs d'accs aux membres\n\n### Oprateur point\n\n| Oprateur | Nom                | Exemple      | Description              |\n|-----------|--------------------|--------------|--------------------------|\n| `.`       | Accs membre       | `obj.field`  | Accder au champ objet   |\n| `.`       | Accs proprit    | `arr.length` | Accder  la proprit   |\n\n**Exemples :**\n```hemlock\n// Accs au champ objet\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);        // \"Alice\"\n\n// Proprit de tableau\nlet arr = [1, 2, 3];\nprint(arr.length);         // 3\n\n// Proprit de chane\nlet s = \"hello\";\nprint(s.length);           // 5\n\n// Appel de mthode\nlet result = s.to_upper(); // \"HELLO\"\n```\n\n---\n\n### Oprateur d'index\n\n| Oprateur | Nom    | Exemple   | Description           |\n|-----------|--------|-----------|----------------------|\n| `[]`      | Index  | `arr[i]`  | Accder  l'lment  |\n\n**Exemples :**\n```hemlock\n// Indexation de tableau\nlet arr = [10, 20, 30];\nprint(arr[0]);             // 10\narr[1] = 99;\n\n// Indexation de chane (retourne un rune)\nlet s = \"hello\";\nprint(s[0]);               // 'h'\ns[0] = 'H';                // \"Hello\"\n\n// Indexation de buffer\nlet buf = buffer(10);\nbuf[0] = 65;\nprint(buf[0]);             // 65\n```\n\n---\n\n## Oprateur d'appel de fonction\n\n| Oprateur | Nom              | Exemple      | Description         |\n|-----------|------------------|--------------|---------------------|\n| `()`      | Appel de fonction| `f(a, b)`    | Appeler la fonction |\n\n**Exemples :**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet result = add(5, 3);    // 8\n\n// Appel de mthode\nlet s = \"hello\";\nlet upper = s.to_upper();  // \"HELLO\"\n\n// Appel de fonction intgre\nprint(\"message\");\n```\n\n---\n\n## Priorit des oprateurs\n\nLes oprateurs sont lists de la plus haute  la plus basse priorit :\n\n| Priorit | Oprateurs                   | Description                         | Associativit   |\n|----------|------------------------------|-------------------------------------|-----------------|\n| 1        | `()` `[]` `.` `?.`           | Appel, index, accs membre, chanage optionnel | Gauche  droite |\n| 2        | `++` `--`                    | Incrmentation/dcrmentation postfixe | Gauche  droite |\n| 3        | `!` `~` `-` (unaire) `+` (unaire) | NON logique, NON bit  bit, ngation | Droite  gauche |\n| 4        | `*` `/` `%`                  | Multiplication, division, modulo    | Gauche  droite |\n| 5        | `+` `-`                      | Addition, soustraction              | Gauche  droite |\n| 6        | `<<` `>>`                    | Dcalages de bits                   | Gauche  droite |\n| 7        | `<` `<=` `>` `>=`            | Relationnel                         | Gauche  droite |\n| 8        | `==` `!=`                    | galit                             | Gauche  droite |\n| 9        | `&`                          | ET bit  bit                        | Gauche  droite |\n| 10       | `^`                          | XOR bit  bit                       | Gauche  droite |\n| 11       | `|`                          | OU bit  bit                        | Gauche  droite |\n| 12       | `&&`                         | ET logique                          | Gauche  droite |\n| 13       | `||`                         | OU logique                          | Gauche  droite |\n| 14       | `??`                         | Coalescence null                    | Gauche  droite |\n| 15       | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\\|=` `^=` `<<=` `>>=` | Affectation | Droite  gauche |\n\n---\n\n## Exemples de priorit\n\n### Exemple 1 : Arithmtique et comparaison\n```hemlock\nlet result = 5 + 3 * 2;\n// valu comme : 5 + (3 * 2) = 11\n// La multiplication a une priorit plus leve que l'addition\n\nlet cmp = 10 > 5 + 3;\n// valu comme : 10 > (5 + 3) = true\n// L'addition a une priorit plus leve que la comparaison\n```\n\n### Exemple 2 : Oprateurs bit  bit\n```hemlock\nlet result1 = 12 | 10 & 8;\n// valu comme : 12 | (10 & 8) = 12 | 8 = 12\n// & a une priorit plus leve que |\n\nlet result2 = 8 | 1 << 2;\n// valu comme : 8 | (1 << 2) = 8 | 4 = 12\n// Le dcalage a une priorit plus leve que le OU bit  bit\n\n// Utiliser des parenthses pour la clart\nlet result3 = (5 & 3) | (2 << 1);\n// valu comme : 1 | 4 = 5\n```\n\n### Exemple 3 : Oprateurs logiques\n```hemlock\nlet result = true || false && false;\n// valu comme : true || (false && false) = true\n// && a une priorit plus leve que ||\n\nlet cmp = 5 < 10 && 10 < 20;\n// valu comme : (5 < 10) && (10 < 20) = true\n// La comparaison a une priorit plus leve que &&\n```\n\n### Exemple 4 : Utilisation de parenthses\n```hemlock\n// Sans parenthses\nlet a = 2 + 3 * 4;        // 14\n\n// Avec parenthses\nlet b = (2 + 3) * 4;      // 20\n\n// Expression complexe\nlet c = (a + b) * (a - b);\n```\n\n---\n\n## Comportement des oprateurs spcifiques aux types\n\n### Division (toujours flottante)\n\nL'oprateur `/` **retourne toujours un flottant** (f64), quel que soit le type des oprandes :\n\n```hemlock\nprint(10 / 3);             // 3.333... (f64)\nprint(5 / 2);              // 2.5 (f64)\nprint(10.0 / 4.0);         // 2.5 (f64)\nprint(-7 / 3);             // -2.333... (f64)\n```\n\nCela vite le bug courant de troncature entire inattendue.\n\n### Division entire (div / divi)\n\nPour la division entire (comme la division entire dans d'autres langages), utilisez les fonctions `div()` et `divi()` :\n\n```hemlock\n// div(a, b) - division entire retournant un flottant\nprint(div(5, 2));          // 2 (f64)\nprint(div(-7, 3));         // -3 (f64)  -- arrondit vers -infini\n\n// divi(a, b) - division entire retournant un entier\nprint(divi(5, 2));         // 2 (i64)\nprint(divi(-7, 3));        // -3 (i64)\nprint(typeof(divi(5, 2))); // i64\n```\n\n**Fonctions mathmatiques retournant des entiers :**\nPour d'autres oprations d'arrondi qui retournent des entiers :\n\n```hemlock\nprint(floori(3.7));        // 3 (i64)\nprint(ceili(3.2));         // 4 (i64)\nprint(roundi(3.5));        // 4 (i64)\nprint(trunci(3.9));        // 3 (i64)\n\n// Ceux-ci peuvent tre utiliss directement comme indices de tableau\nlet arr = [10, 20, 30, 40];\nprint(arr[floori(1.9)]);   // 20 (index 1)\n```\n\n### Comparaison de chanes\n\nLes chanes sont compares lexicographiquement :\n\n```hemlock\nprint(\"abc\" < \"def\");      // true\nprint(\"apple\" > \"banana\"); // false\nprint(\"hello\" == \"hello\"); // true\n```\n\n### Comparaison null\n\n```hemlock\nlet x = null;\n\nprint(x == null);          // true\nprint(x != null);          // false\n```\n\n### Erreurs de type\n\nCertaines oprations ne sont pas autorises entre types incompatibles :\n\n```hemlock\n// ERREUR : Impossible d'utiliser les oprateurs bit  bit sur les flottants\nlet x = 3.14 & 2.71;\n\n// ERREUR : Impossible d'utiliser les oprateurs bit  bit sur les chanes\nlet y = \"hello\" & \"world\";\n\n// OK : Promotion de type pour l'arithmtique\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet c = a + b;             // i32 (promu)\n```\n\n---\n\n## Voir aussi\n\n- [Systme de types](#reference-type-system) - Rgles de promotion et conversion de types\n- [Fonctions intgres](#reference-builtins) - Oprations intgres\n- [API String](#reference-string-api) - Concatnation et mthodes de chanes\n"}, "Rfrence API -> Systme de Types": {"id": "reference-type-system", "content": "# Rfrence du systme de types\n\nRfrence complte pour le systme de types de Hemlock, y compris tous les types primitifs et composites.\n\n---\n\n## Aperu\n\nHemlock utilise un **systme de types dynamique** avec des tiquettes de type  l'excution et des annotations de type optionnelles. Chaque valeur a un type  l'excution, et les conversions de type suivent des rgles de promotion explicites.\n\n**Caractristiques principales :**\n- Vrification de type  l'excution (interprteur)\n- Vrification de type  la compilation (hemlockc - active par dfaut)\n- Annotations de type optionnelles\n- Infrence de type automatique pour les littraux\n- Rgles de promotion de type explicites\n- Pas de conversions implicites qui perdent de la prcision\n\n---\n\n## Vrification de type  la compilation (hemlockc)\n\nLe compilateur Hemlock (`hemlockc`) inclut un vrificateur de types  la compilation qui valide votre code avant de gnrer les excutables. Cela attrape les erreurs de type tt sans avoir besoin d'excuter le programme.\n\n### Comportement par dfaut\n\nLa vrification de type est **active par dfaut** dans hemlockc :\n\n```bash\n# La vrification de type se fait automatiquement\nhemlockc program.hml -o program\n\n# Les erreurs sont signales avant la compilation\nhemlockc bad_types.hml\n# Sortie: 1 type error found\n```\n\n### Options du compilateur\n\n| Option | Description |\n|--------|-------------|\n| `--check` | Vrifier les types uniquement, ne pas compiler (quitter aprs validation) |\n| `--no-type-check` | Dsactiver la vrification de type (non recommand) |\n| `--strict-types` | Activer des avertissements de type plus stricts |\n\n**Exemples :**\n\n```bash\n# Juste valider les types sans compiler\nhemlockc --check program.hml\n# Sortie: program.hml: no type errors\n\n# Dsactiver la vrification de type (utiliser avec prcaution)\nhemlockc --no-type-check dynamic_code.hml -o program\n\n# Activer les avertissements stricts pour les types any implicites\nhemlockc --strict-types program.hml -o program\n```\n\n### Ce que le vrificateur de types valide\n\n1. **Annotations de type** - S'assure que les valeurs assignes correspondent aux types dclars\n2. **Appels de fonction** - Valide les types d'arguments contre les types de paramtres\n3. **Types de retour** - Vrifie que les instructions return correspondent au type de retour dclar\n4. **Utilisation des oprateurs** - Vrifie que les oprandes sont compatibles\n5. **Accs aux proprits** - Valide les types de champs d'objet pour les objets typs\n\n### Conversions numriques permissives\n\nLe vrificateur de types autorise les conversions de types numriques  la compilation, avec validation de plage  l'excution :\n\n```hemlock\nlet x: i8 = 100;      // OK - 100 tient dans i8 (valid  l'excution)\nlet y: u8 = 255;      // OK - dans la plage u8\nlet z: f64 = 42;      // OK - i32 vers f64 est sr\n```\n\n### Support du code dynamique\n\nLe code sans annotations de type est trait comme dynamique (type `any`) et passe toujours le vrificateur de types :\n\n```hemlock\nlet x = get_value();  // Dynamique - pas d'annotation\nprocess(x);           // OK - les valeurs dynamiques sont acceptes partout\n```\n\n---\n\n## Types primitifs\n\n### Types numriques\n\n#### Entiers signs\n\n| Type   | Taille   | Plage                                      | Alias     |\n|--------|----------|-------------------------------------------|-----------|\n| `i8`   | 1 octet  | -128  127                                | -         |\n| `i16`  | 2 octets | -32 768  32 767                          | -         |\n| `i32`  | 4 octets | -2 147 483 648  2 147 483 647            | `integer` |\n| `i64`  | 8 octets | -9 223 372 036 854 775 808  9 223 372 036 854 775 807 | - |\n\n**Exemples :**\n```hemlock\nlet a: i8 = 127;\nlet b: i16 = 32000;\nlet c: i32 = 1000000;\nlet d: i64 = 9223372036854775807;\n\n// Alias de type\nlet x: integer = 42;  // Identique  i32\n```\n\n#### Entiers non signs\n\n| Type   | Taille   | Plage                        | Alias  |\n|--------|----------|------------------------------|--------|\n| `u8`   | 1 octet  | 0  255                      | `byte` |\n| `u16`  | 2 octets | 0  65 535                   | -      |\n| `u32`  | 4 octets | 0  4 294 967 295            | -      |\n| `u64`  | 8 octets | 0  18 446 744 073 709 551 615 | -   |\n\n**Exemples :**\n```hemlock\nlet a: u8 = 255;\nlet b: u16 = 65535;\nlet c: u32 = 4294967295;\nlet d: u64 = 18446744073709551615;\n\n// Alias de type\nlet byte_val: byte = 65;  // Identique  u8\n```\n\n#### Virgule flottante\n\n| Type   | Taille   | Prcision      | Alias    |\n|--------|----------|----------------|----------|\n| `f32`  | 4 octets | ~7 chiffres    | -        |\n| `f64`  | 8 octets | ~15 chiffres   | `number` |\n\n**Exemples :**\n```hemlock\nlet pi: f32 = 3.14159;\nlet precise: f64 = 3.14159265359;\n\n// Alias de type\nlet x: number = 2.718;  // Identique  f64\n```\n\n---\n\n### Infrence de type pour les littraux entiers\n\nLes littraux entiers sont automatiquement typs en fonction de leur valeur :\n\n**Rgles :**\n- Valeurs dans la plage i32 (-2 147 483 648  2 147 483 647) : infrer comme `i32`\n- Valeurs hors de la plage i32 mais dans la plage i64 : infrer comme `i64`\n- Utiliser des annotations de type explicites pour les autres types (i8, i16, u8, u16, u32, u64)\n\n**Exemples :**\n```hemlock\nlet small = 42;                    // i32 (tient dans i32)\nlet large = 5000000000;            // i64 (> max i32)\nlet max_i64 = 9223372036854775807; // i64 (INT64_MAX)\nlet explicit: u32 = 100;           // u32 (l'annotation de type prvaut)\n```\n\n---\n\n### Type boolen\n\n**Type :** `bool`\n\n**Valeurs :** `true`, `false`\n\n**Taille :** 1 octet (en interne)\n\n**Exemples :**\n```hemlock\nlet is_active: bool = true;\nlet done = false;\n\nif (is_active && !done) {\n    print(\"en cours\");\n}\n```\n\n---\n\n### Types de caractres\n\n#### Rune\n\n**Type :** `rune`\n\n**Description :** Point de code Unicode (U+0000  U+10FFFF)\n\n**Taille :** 4 octets (valeur 32 bits)\n\n**Plage :** 0  0x10FFFF (1 114 111)\n\n**Syntaxe littrale :** Guillemets simples `'x'`\n\n**Exemples :**\n```hemlock\n// ASCII\nlet a = 'A';\nlet digit = '0';\n\n// UTF-8 multi-octets\nlet rocket = '';      // U+1F680\nlet heart = '';        // U+2764\nlet chinese = '';     // U+4E2D\n\n// Squences d'chappement\nlet newline = '\\n';\nlet tab = '\\t';\nlet backslash = '\\\\';\nlet quote = '\\'';\nlet null = '\\0';\n\n// chappements Unicode\nlet emoji = '\\u{1F680}';   // Jusqu' 6 chiffres hexadcimaux\nlet max = '\\u{10FFFF}';    // Point de code maximum\n```\n\n**Conversions de type :**\n```hemlock\n// Entier vers rune\nlet code: rune = 65;        // 'A'\nlet r: rune = 128640;       // \n\n// Rune vers entier\nlet value: i32 = 'Z';       // 90\n\n// Rune vers chane\nlet s: string = 'H';        // \"H\"\n\n// u8 vers rune\nlet byte: u8 = 65;\nlet rune_val: rune = byte;  // 'A'\n```\n\n**Voir aussi :** [API String](#reference-string-api) pour la concatnation string + rune\n\n---\n\n### Type chane\n\n**Type :** `string`\n\n**Description :** Texte encod en UTF-8, mutable, allou sur le tas\n\n**Encodage :** UTF-8 (U+0000  U+10FFFF)\n\n**Mutabilit :** Mutable (contrairement  la plupart des langages)\n\n**Proprits :**\n- `.length` - Nombre de points de code (nombre de caractres)\n- `.byte_length` - Nombre d'octets (taille de l'encodage UTF-8)\n\n**Syntaxe littrale :** Guillemets doubles `\"texte\"`\n\n**Exemples :**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Modifier (maintenant \"Hello\")\nprint(s.length);        // 5 (nombre de points de code)\nprint(s.byte_length);   // 5 (octets UTF-8)\n\nlet emoji = \"\";\nprint(emoji.length);        // 1 (un point de code)\nprint(emoji.byte_length);   // 4 (quatre octets UTF-8)\n```\n\n**Indexation :**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Retourne le rune 'h'\ns[0] = 'H';             // Dfinir avec un rune\n```\n\n**Voir aussi :** [API String](#reference-string-api) pour la rfrence complte des mthodes\n\n---\n\n### Type null\n\n**Type :** `null`\n\n**Description :** La valeur null (absence de valeur)\n\n**Taille :** 8 octets (en interne)\n\n**Valeur :** `null`\n\n**Exemples :**\n```hemlock\nlet x = null;\nlet y: i32 = null;  // ERREUR: incompatibilit de type\n\nif (x == null) {\n    print(\"x est null\");\n}\n```\n\n---\n\n## Types composites\n\n### Type tableau\n\n**Type :** `array`\n\n**Description :** Tableau dynamique, allou sur le tas, de types mixtes\n\n**Proprits :**\n- `.length` - Nombre d'lments\n\n**Indexation base zro :** Oui\n\n**Syntaxe littrale :** `[elem1, elem2, ...]`\n\n**Exemples :**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Types mixtes\nlet mixed = [1, \"hello\", true, null];\n```\n\n**Voir aussi :** [API Array](#reference-array-api) pour la rfrence complte des mthodes\n\n---\n\n### Type objet\n\n**Type :** `object`\n\n**Description :** Objet de style JavaScript avec champs dynamiques\n\n**Syntaxe littrale :** `{ field: value, ... }`\n\n**Exemples :**\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);  // \"Alice\"\n\n// Ajouter un champ dynamiquement\nperson.email = \"alice@example.com\";\n```\n\n**Dfinitions de type :**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: bool,  // Champ optionnel\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\nprint(typeof(p));  // \"Person\"\n```\n\n---\n\n### Types de pointeur\n\n#### Pointeur brut (ptr)\n\n**Type :** `ptr`\n\n**Description :** Adresse mmoire brute (non sr)\n\n**Taille :** 8 octets\n\n**Vrification des limites :** Aucune\n\n**Exemples :**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n#### Buffer (buffer)\n\n**Type :** `buffer`\n\n**Description :** Enveloppe de pointeur scurise avec vrification des limites\n\n**Structure :** Pointeur + longueur + capacit\n\n**Proprits :**\n- `.length` - Taille du buffer\n- `.capacity` - Capacit alloue\n\n**Exemples :**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Vrifi aux limites\nprint(b.length);        // 64\nfree(b);\n```\n\n**Voir aussi :** [API Memory](#reference-memory-api) pour les fonctions d'allocation\n\n---\n\n## Types spciaux\n\n### Type file\n\n**Type :** `file`\n\n**Description :** Handle de fichier pour les oprations d'E/S\n\n**Proprits :**\n- `.path` - Chemin du fichier (string)\n- `.mode` - Mode d'ouverture (string)\n- `.closed` - Si le fichier est ferm (bool)\n\n**Voir aussi :** [API File](#reference-file-api)\n\n---\n\n### Type task\n\n**Type :** `task`\n\n**Description :** Handle pour une tche concurrente\n\n**Voir aussi :** [API Concurrency](#reference-concurrency-api)\n\n---\n\n### Type channel\n\n**Type :** `channel`\n\n**Description :** Canal de communication thread-safe\n\n**Voir aussi :** [API Concurrency](#reference-concurrency-api)\n\n---\n\n### Type function\n\n**Type :** `function`\n\n**Description :** Valeur de fonction de premire classe\n\n**Exemples :**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(typeof(add));      // \"function\"\nprint(typeof(multiply)); // \"function\"\n```\n\n---\n\n### Type void\n\n**Type :** `void`\n\n**Description :** Absence de valeur de retour (usage interne)\n\n---\n\n## Rgles de promotion de type\n\nLors du mlange de types dans les oprations, Hemlock promeut vers le type \"suprieur\" :\n\n**Hirarchie de promotion :**\n```\nf64 (plus haute prcision)\n \nf32\n \nu64\n \ni64\n \nu32\n \ni32\n \nu16\n \ni16\n \nu8\n \ni8 (plus basse)\n```\n\n**Rgles :**\n1. Le flottant gagne toujours sur l'entier\n2. La plus grande taille gagne dans la mme catgorie (int/uint/float)\n3. Les deux oprandes sont promus vers le type rsultat\n4. **Prservation de la prcision :** i64/u64 + f32 promeut vers f64 (pas f32)\n\n**Exemples :**\n```hemlock\n// Promotion de taille\nu8 + i32     i32    // La plus grande taille gagne\ni32 + i64    i64    // La plus grande taille gagne\nu32 + u64    u64    // La plus grande taille gagne\n\n// Promotion flottante\ni32 + f32    f32    // Le flottant gagne, f32 suffit pour i32\ni64 + f32    f64    // Promeut vers f64 pour prserver la prcision i64\ni64 + f64    f64    // Le flottant gagne toujours\ni8 + f64     f64    // Flottant + plus grand gagne\n```\n\n**Pourquoi i64 + f32  f64 ?**\n\nf32 n'a qu'une mantisse de 24 bits, qui ne peut pas reprsenter prcisment les entiers plus grands que 2^24 (16 777 216). Puisque i64 peut contenir des valeurs jusqu' 2^63, mlanger i64 avec f32 causerait une perte de prcision svre. Hemlock promeut vers f64 (mantisse de 53 bits)  la place.\n\n---\n\n## Vrification de plage\n\nLes annotations de type appliquent des vrifications de plage  l'affectation :\n\n**Affectations valides :**\n```hemlock\nlet x: u8 = 255;             // OK\nlet y: i8 = 127;             // OK\nlet a: i64 = 2147483647;     // OK\nlet b: u64 = 4294967295;     // OK\n```\n\n**Affectations invalides (erreur d'excution) :**\n```hemlock\nlet x: u8 = 256;             // ERREUR: hors plage\nlet y: i8 = 128;             // ERREUR: max est 127\nlet z: u64 = -1;             // ERREUR: u64 ne peut pas tre ngatif\n```\n\n---\n\n## Introspection de type\n\n### typeof(value)\n\nRetourne le nom du type sous forme de chane.\n\n**Signature :**\n```hemlock\ntypeof(value: any): string\n```\n\n**Retourne :**\n- Types primitifs : `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- Types composites : `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- Types spciaux : `\"file\"`, `\"task\"`, `\"channel\"`\n- Objets typs : Nom de type personnalis (ex., `\"Person\"`)\n\n**Exemples :**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n```\n\n**Voir aussi :** [Fonctions intgres](builtins.md#typeof)\n\n---\n\n## Conversions de type\n\n### Conversions implicites\n\nHemlock effectue des conversions de type implicites dans les oprations arithmtiques suivant les rgles de promotion de type.\n\n**Exemples :**\n```hemlock\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet result = a + b;     // result est i32 (promu)\n```\n\n### Conversions explicites\n\nUtilisez les annotations de type pour les conversions explicites :\n\n**Exemples :**\n```hemlock\n// Entier vers flottant\nlet i: i32 = 42;\nlet f: f64 = i;         // 42.0\n\n// Flottant vers entier (tronque)\nlet x: f64 = 3.14;\nlet y: i32 = x;         // 3\n\n// Entier vers rune\nlet code: rune = 65;    // 'A'\n\n// Rune vers entier\nlet value: i32 = 'Z';   // 90\n\n// Rune vers chane\nlet s: string = 'H';    // \"H\"\n```\n\n---\n\n## Alias de type\n\n### Alias intgrs\n\nHemlock fournit des alias de type intgrs pour les types courants :\n\n| Alias     | Type rel | Usage                        |\n|-----------|-----------|------------------------------|\n| `integer` | `i32`     | Entiers  usage gnral      |\n| `number`  | `f64`     | Flottants  usage gnral    |\n| `byte`    | `u8`      | Valeurs d'octets             |\n\n**Exemples :**\n```hemlock\nlet count: integer = 100;       // Identique  i32\nlet price: number = 19.99;      // Identique  f64\nlet b: byte = 255;              // Identique  u8\n```\n\n### Alias de type personnaliss\n\nDfinissez des alias de type personnaliss avec le mot-cl `type` :\n\n```hemlock\n// Alias simples\ntype Integer = i32;\ntype Text = string;\n\n// Alias de type fonction\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\n// Alias de type compos\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// Alias de type gnrique\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n```\n\n**Utilisation des alias personnaliss :**\n```hemlock\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**Note :** Les alias de type sont transparents - `typeof()` retourne le nom du type sous-jacent.\n\n---\n\n## Types de fonction\n\nLes types de fonction spcifient la signature des valeurs de fonction :\n\n### Syntaxe\n\n```hemlock\nfn(types_paramtres): type_retour\n```\n\n### Exemples\n\n```hemlock\n// Type de fonction basique\nlet add: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// Paramtre de fonction\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Fonction d'ordre suprieur retournant une fonction\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Type de fonction async\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n```\n\n---\n\n## Types composs (intersection)\n\nLes types composs utilisent `&` pour exiger plusieurs contraintes de type :\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// L'objet doit satisfaire tous les types\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// Trois types ou plus\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n---\n\n## Tableau rcapitulatif\n\n| Type       | Taille    | Mutable | Allou sur le tas | Description                    |\n|------------|-----------|---------|-------------------|--------------------------------|\n| `i8`-`i64` | 1-8 octets| Non     | Non               | Entiers signs                 |\n| `u8`-`u64` | 1-8 octets| Non     | Non               | Entiers non signs             |\n| `f32`      | 4 octets  | Non     | Non               | Flottant simple prcision      |\n| `f64`      | 8 octets  | Non     | Non               | Flottant double prcision      |\n| `bool`     | 1 octet   | Non     | Non               | Boolen                        |\n| `rune`     | 4 octets  | Non     | Non               | Point de code Unicode          |\n| `string`   | Variable  | Oui     | Oui               | Texte UTF-8                    |\n| `array`    | Variable  | Oui     | Oui               | Tableau dynamique              |\n| `object`   | Variable  | Oui     | Oui               | Objet dynamique                |\n| `ptr`      | 8 octets  | Non     | Non               | Pointeur brut                  |\n| `buffer`   | Variable  | Oui     | Oui               | Enveloppe de pointeur scurise|\n| `file`     | Opaque    | Oui     | Oui               | Handle de fichier              |\n| `task`     | Opaque    | Non     | Oui               | Handle de tche concurrente    |\n| `channel`  | Opaque    | Oui     | Oui               | Canal thread-safe              |\n| `function` | Opaque    | Non     | Oui               | Valeur de fonction             |\n| `null`     | 8 octets  | Non     | Non               | Valeur null                    |\n\n---\n\n## Voir aussi\n\n- [Rfrence des oprateurs](#reference-operators) - Comportement des types dans les oprations\n- [Fonctions intgres](#reference-builtins) - Introspection et conversion de types\n- [API String](#reference-string-api) - Mthodes du type string\n- [API Array](#reference-array-api) - Mthodes du type array\n- [API Memory](#reference-memory-api) - Oprations sur les pointeurs et buffers\n"}, "Conception et Philosophie -> Implmentation": {"id": "design-implementation", "content": "# Dtails d'implmentation de Hemlock\n\nCe document dcrit l'implmentation technique du langage Hemlock, incluant la structure du projet, le pipeline de compilation, l'architecture d'excution et les dcisions de conception.\n\n---\n\n## Table des matires\n\n- [Structure du projet](#structure-du-projet)\n- [Pipeline de compilation](#pipeline-de-compilation)\n- [Conception modulaire de l'interprteur](#conception-modulaire-de-linterprteur)\n- [Architecture d'excution](#architecture-dexcution)\n- [Reprsentation des valeurs](#reprsentation-des-valeurs)\n- [Implmentation du systme de types](#implmentation-du-systme-de-types)\n- [Gestion de la mmoire](#gestion-de-la-mmoire)\n- [Modle de concurrence](#modle-de-concurrence)\n- [Plans futurs](#plans-futurs)\n\n---\n\n## Structure du projet\n\n```\nhemlock/\n src/\n    frontend/              # Partag : lexer, parser, AST\n       lexer.c            # Tokenisation\n       parser/            # Parser  descente rcursive\n       ast.c              # Gestion des nuds AST\n       module.c           # Rsolution des modules\n    backends/\n       interpreter/       # hemlock : interprteur par parcours d'arbre\n          main.c         # Point d'entre CLI\n          runtime.c      # valuation des expressions/instructions\n          builtins.c     # Fonctions intgres\n          ...\n       compiler/          # hemlockc : gnrateur de code C\n           main.c         # CLI, orchestration\n           type_check.c   # Vrification de types  la compilation\n           codegen.c      # Contexte de gnration de code\n           codegen_expr.c # Gnration de code pour les expressions\n           codegen_stmt.c # Gnration de code pour les instructions\n           ...\n    tools/\n       lsp/               # Language Server Protocol\n       bundler/           # Outils de bundle/package\n runtime/                   # libhemlock_runtime.a (pour les programmes compils)\n stdlib/                    # Bibliothque standard (39 modules)\n    docs/                  # Documentation des modules\n tests/\n    parity/                # Tests devant passer sur les deux backends\n    interpreter/           # Tests spcifiques  l'interprteur\n    compiler/              # Tests spcifiques au compilateur\n examples/                  # Programmes exemples\n docs/                      # Documentation\n```\n\n### Organisation des rpertoires\n\n**`include/`** - En-ttes d'API publique qui dfinissent l'interface entre les composants :\n- Sparation nette entre lexer, parser, AST et interprteur\n- Dclarations anticipes pour minimiser les dpendances\n- API publique pour intgrer Hemlock dans d'autres programmes\n\n**`src/`** - Fichiers d'implmentation :\n- Les fichiers de niveau suprieur grent le lexing, le parsing, la gestion de l'AST\n- `main.c` fournit la CLI et le REPL\n- L'interprteur est modularis en sous-systmes spars\n\n**`src/interpreter/`** - Implmentation modulaire de l'interprteur :\n- Chaque module a une seule responsabilit claire\n- API interne dfinie dans `internal.h` pour la communication inter-modules\n- Les modules peuvent tre compils indpendamment pour des builds plus rapides\n\n**`tests/`** - Suite de tests complte :\n- Organise par domaine fonctionnel\n- Chaque rpertoire contient des cas de test cibls\n- `run_tests.sh` orchestre l'excution des tests\n\n---\n\n## Pipeline de compilation\n\nHemlock utilise un pipeline de compilation traditionnel avec des phases distinctes :\n\n### Phase 1 : Analyse lexicale (Lexer)\n\n**Entre :** Texte du code source\n**Sortie :** Flux de tokens\n**Implmentation :** `src/lexer.c`\n\n```\nSource : \"let x = 42;\"\n   \nTokens : [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n```\n\n**Caractristiques cls :**\n- Reconnat les mots-cls, identifiants, littraux, oprateurs, ponctuation\n- Gre les littraux de chane UTF-8 et les littraux de rune\n- Rapporte les numros de ligne pour les messages d'erreur\n- Passe unique, pas de retour arrire\n\n### Phase 2 : Analyse syntaxique (Parser)\n\n**Entre :** Flux de tokens\n**Sortie :** Arbre de syntaxe abstraite (AST)\n**Implmentation :** `src/parser.c`\n\n```\nTokens : [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n   \nAST : LetStmt {\n    name: \"x\",\n    type: null,\n    value: IntLiteral(42)\n}\n```\n\n**Caractristiques cls :**\n- Parser  descente rcursive\n- Construit une reprsentation arborescente de la structure du programme\n- Gre la prcdence des oprateurs\n- Valide la syntaxe (accolades, points-virgules, etc.)\n- Pas d'analyse smantique encore (faite  l'excution)\n\n**Prcdence des oprateurs (du plus bas au plus haut) :**\n1. Affectation : `=`\n2. OU logique : `||`\n3. ET logique : `&&`\n4. OU bit  bit : `|`\n5. XOR bit  bit : `^`\n6. ET bit  bit : `&`\n7. galit : `==`, `!=`\n8. Comparaison : `<`, `>`, `<=`, `>=`\n9. Dcalages bit  bit : `<<`, `>>`\n10. Addition/Soustraction : `+`, `-`\n11. Multiplication/Division/Modulo : `*`, `/`, `%`\n12. Unaire : `!`, `-`, `~`\n13. Appel/Index/Membre : `()`, `[]`, `.`\n\n### Phase 3a : Interprtation (parcours d'arbre)\n\n**Entre :** AST\n**Sortie :** Excution du programme\n**Implmentation :** `src/backends/interpreter/runtime.c`\n\n```\nAST : LetStmt { ... }\n   \nExcution : value les nuds AST rcursivement\n   \nRsultat : Variable x cre avec la valeur 42\n```\n\n**Caractristiques cls :**\n- Parcours direct de l'AST (interprteur par parcours d'arbre)\n- Vrification de type dynamique  l'excution\n- Stockage des variables bas sur l'environnement\n\n### Phase 3b : Compilation (hemlockc)\n\n**Entre :** AST\n**Sortie :** Excutable natif via gnration de code C\n**Implmentation :** `src/backends/compiler/`\n\n```\nAST : LetStmt { ... }\n   \nVrification de types : Valide les types  la compilation\n   \nGnration C : Gnre le code C quivalent\n   \nGCC : Compile le C en binaire natif\n   \nRsultat : Excutable autonome\n```\n\n**Caractristiques cls :**\n- Vrification de types  la compilation (active par dfaut)\n- Gnration de code C pour la portabilit\n- Liaison avec `libhemlock_runtime.a`\n- Excution significativement plus rapide que l'interprteur\n\n---\n\n## Backend compilateur (hemlockc)\n\nLe compilateur Hemlock gnre du code C  partir de l'AST, qui est ensuite compil en excutable natif avec GCC.\n\n### Architecture du compilateur\n\n```\nsrc/backends/compiler/\n main.c              # CLI, analyse des arguments, orchestration\n codegen.c           # Contexte de gnration de code principal\n codegen_expr.c      # Gnration de code pour les expressions\n codegen_stmt.c      # Gnration de code pour les instructions\n codegen_call.c      # Gnration des appels de fonction\n codegen_closure.c   # Implmentation des closures\n codegen_program.c   # Gnration du programme de niveau suprieur\n codegen_module.c    # Gestion des modules/imports\n type_check.c        # Vrification de types  la compilation\n type_check.h        # API du vrificateur de types\n```\n\n### Vrification de types\n\nLe compilateur inclut un systme de vrification de types unifi qui :\n\n1. **Valide les types  la compilation** - Dtecte les erreurs de type avant l'excution\n2. **Supporte le code dynamique** - Le code non typ est trait comme `any` (toujours valide)\n3. **Fournit des indices d'optimisation** - Identifie les variables qui peuvent tre dballes\n\n**Options de vrification de types :**\n\n| Option | Description |\n|--------|-------------|\n| (dfaut) | Vrification de types active |\n| `--check` | Vrifier les types uniquement, ne pas compiler |\n| `--no-type-check` | Dsactiver la vrification de types |\n| `--strict-types` | Avertir sur les types `any` implicites |\n\n**Implmentation du vrificateur de types :**\n\n```c\n// type_check.h - Structures cls\ntypedef struct TypeCheckContext {\n    const char *filename;\n    int error_count;\n    int warning_count;\n    UnboxableVar *unboxable_vars;  // Indices d'optimisation\n    // ... environnement de types, dfinitions, etc.\n} TypeCheckContext;\n\n// Point d'entre principal\nint type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);\n```\n\n### Gnration de code\n\nLa phase de gnration de code traduit les nuds AST en code C :\n\n**Correspondance des expressions :**\n```\nHemlock                   C gnr\n----------------------------------------\nlet x = 42;              HmlValue x = hml_val_i32(42);\nx + y                    hml_add(x, y)\narr[i]                   hml_array_get(arr, i)\nobj.field                hml_object_get_field(obj, \"field\")\nfn(a, b) { ... }         Closure avec capture d'environnement\n```\n\n**Intgration du runtime :**\n\nLe code C gnr est li avec `libhemlock_runtime.a` qui fournit :\n- Type union tiquet `HmlValue`\n- Gestion de la mmoire (comptage de rfrences)\n- Fonctions intgres (print, typeof, etc.)\n- Primitives de concurrence (tches, canaux)\n- Support FFI\n\n### Optimisation du dballage (unboxing)\n\nLe vrificateur de types identifie les variables qui peuvent utiliser des types C natifs au lieu de `HmlValue` emballs :\n\n**Motifs dballables :**\n- Compteurs de boucle avec type entier connu\n- Variables d'accumulateur dans les boucles\n- Variables avec annotations de type explicites (i32, i64, f64, bool)\n\n```hemlock\n// Le compteur de boucle 'i' peut tre dball en int32_t natif\nfor (let i: i32 = 0; i < 1000000; i = i + 1) {\n    sum = sum + i;\n}\n```\n\n---\n\n## Conception modulaire de l'interprteur\n\nL'interprteur est divis en modules cibls pour la maintenabilit et l'extensibilit.\n\n### Responsabilits des modules\n\n#### 1. Environnement (`environment.c`) - 121 lignes\n\n**Objectif :** Porte des variables et rsolution des noms\n\n**Fonctions cls :**\n- `env_create()` - Crer un nouvel environnement avec parent optionnel\n- `env_define()` - Dfinir une nouvelle variable dans la porte courante\n- `env_get()` - Rechercher une variable dans la porte courante ou parente\n- `env_set()` - Mettre  jour la valeur d'une variable existante\n- `env_free()` - Librer l'environnement et toutes les variables\n\n**Conception :**\n- Portes lies (chaque environnement a un pointeur vers le parent)\n- HashMap pour une recherche rapide des variables\n- Supporte la porte lexicale pour les closures\n\n#### 2. Valeurs (`values.c`) - 394 lignes\n\n**Objectif :** Constructeurs de valeurs et gestion des structures de donnes\n\n**Fonctions cls :**\n- `value_create_*()` - Constructeurs pour chaque type de valeur\n- `value_copy()` - Logique de copie profonde/superficielle\n- `value_free()` - Nettoyage et dsallocation mmoire\n- `value_to_string()` - Reprsentation en chane pour l'affichage\n\n**Structures de donnes :**\n- Objets (tableaux de champs dynamiques)\n- Tableaux (redimensionnement dynamique)\n- Buffers (ptr + longueur + capacit)\n- Closures (fonction + environnement captur)\n- Tches et canaux (primitives de concurrence)\n\n#### 3. Types (`types.c`) - 440 lignes\n\n**Objectif :** Systme de types, conversions et duck typing\n\n**Fonctions cls :**\n- `type_check()` - Validation de type  l'excution\n- `type_convert()` - Conversions/promotions de type implicites\n- `duck_type_check()` - Vrification de type structurel pour les objets\n- `type_name()` - Obtenir le nom de type affichable\n\n**Fonctionnalits :**\n- Hirarchie de promotion de type (i8  i16  i32  i64  f32  f64, avec i64/u64 + f32  f64)\n- Vrification de plage pour les types numriques\n- Duck typing pour les dfinitions de type objet\n- Valeurs par dfaut des champs optionnels\n\n#### 4. Fonctions intgres (`builtins.c`) - 955 lignes\n\n**Objectif :** Fonctions intgres et enregistrement global\n\n**Fonctions cls :**\n- `register_builtins()` - Enregistrer toutes les fonctions et constantes intgres\n- Implmentations des fonctions intgres (print, typeof, alloc, free, etc.)\n- Fonctions de gestion des signaux\n- Excution de commandes (exec)\n\n**Catgories de fonctions intgres :**\n- E/S : print, open, read_file, write_file\n- Mmoire : alloc, free, memset, memcpy, realloc\n- Types : typeof, assert\n- Concurrence : spawn, join, detach, channel\n- Systme : exec, signal, raise, panic\n- FFI : dlopen, dlsym, dlcall, dlclose\n\n#### 5. E/S (`io.c`) - 449 lignes\n\n**Objectif :** E/S de fichiers et srialisation JSON\n\n**Fonctions cls :**\n- Mthodes d'objet fichier (read, write, seek, tell, close)\n- Srialisation/dsrialisation JSON\n- Dtection des rfrences circulaires\n\n**Fonctionnalits :**\n- Objet fichier avec proprits (path, mode, closed)\n- E/S texte compatible UTF-8\n- Support E/S binaire\n- Aller-retour JSON pour objets et tableaux\n\n#### 6. FFI (`ffi.c`) - Interface de fonction trangre\n\n**Objectif :** Appeler des fonctions C depuis des bibliothques partages\n\n**Fonctions cls :**\n- `dlopen()` - Charger une bibliothque partage\n- `dlsym()` - Obtenir un pointeur de fonction par nom\n- `dlcall()` - Appeler une fonction C avec conversion de type\n- `dlclose()` - Dcharger la bibliothque\n\n**Fonctionnalits :**\n- Intgration avec libffi pour les appels de fonction dynamiques\n- Conversion de type automatique (Hemlock  types C)\n- Support pour tous les types primitifs\n- Support des pointeurs et buffers\n\n#### 7. Runtime (`runtime.c`) - 865 lignes\n\n**Objectif :** valuation des expressions et excution des instructions\n\n**Fonctions cls :**\n- `eval_expr()` - valuer les expressions (rcursif)\n- `eval_stmt()` - Excuter les instructions\n- Gestion du flux de contrle (if, while, for, switch, etc.)\n- Gestion des exceptions (try/catch/finally/throw)\n\n**Fonctionnalits :**\n- valuation rcursive des expressions\n- valuation boolenne en court-circuit\n- Dtection d'appel de mthode et liaison de `self`\n- Propagation des exceptions\n- Gestion de break/continue/return\n\n### Avantages de la conception modulaire\n\n**1. Sparation des proccupations**\n- Chaque module a une seule responsabilit claire\n- Facile de trouver o les fonctionnalits sont implmentes\n- Rduit la charge cognitive lors des modifications\n\n**2. Builds incrmentaux plus rapides**\n- Seuls les modules modifis ncessitent une recompilation\n- Compilation parallle possible\n- Temps d'itration plus courts pendant le dveloppement\n\n**3. Tests et dbogage plus faciles**\n- Les modules peuvent tre tests isolment\n- Les bugs sont localiss dans des sous-systmes spcifiques\n- Implmentations mock possibles pour les tests\n\n**4. Extensibilit**\n- Les nouvelles fonctionnalits peuvent tre ajoutes aux modules appropris\n- Les modules peuvent tre refactoriss indpendamment\n- La taille du code par fichier reste grable\n\n**5. Organisation du code**\n- Regroupement logique des fonctionnalits connexes\n- Graphe de dpendances clair\n- Intgration plus facile des nouveaux contributeurs\n\n---\n\n## Architecture d'excution\n\n### Reprsentation des valeurs\n\nToutes les valeurs dans Hemlock sont reprsentes par la structure `Value` utilisant une union tiquete :\n\n```c\ntypedef struct Value {\n    ValueType type;  // tiquette de type  l'excution\n    union {\n        int32_t i32_value;\n        int64_t i64_value;\n        uint8_t u8_value;\n        uint32_t u32_value;\n        uint64_t u64_value;\n        float f32_value;\n        double f64_value;\n        bool bool_value;\n        char *string_value;\n        uint32_t rune_value;\n        void *ptr_value;\n        Buffer *buffer_value;\n        Array *array_value;\n        Object *object_value;\n        Function *function_value;\n        File *file_value;\n        Task *task_value;\n        Channel *channel_value;\n    };\n} Value;\n```\n\n**Dcisions de conception :**\n- **Union tiquete** pour la scurit de type tout en maintenant la flexibilit\n- **tiquettes de type  l'excution** permettent le typage dynamique avec vrification de type\n- **Stockage direct des valeurs** pour les primitives (pas de boxing)\n- **Stockage de pointeur** pour les types allous sur le tas (chanes, objets, tableaux)\n\n### Exemples de disposition mmoire\n\n**Entier (i32) :**\n```\nValue {\n    type: TYPE_I32,\n    i32_value: 42\n}\n```\n- Taille totale : ~16 octets (tiquette de 8 octets + union de 8 octets)\n- Allou sur la pile\n- Pas d'allocation sur le tas ncessaire\n\n**Chane :**\n```\nValue {\n    type: TYPE_STRING,\n    string_value: 0x7f8a4c000000  // Pointeur vers le tas\n}\n\nTas : \"hello\\0\" (6 octets, UTF-8 termin par null)\n```\n- La valeur fait 16 octets sur la pile\n- Les donnes de chane sont alloues sur le tas\n- Doit tre libre manuellement\n\n**Objet :**\n```\nValue {\n    type: TYPE_OBJECT,\n    object_value: 0x7f8a4c001000  // Pointeur vers le tas\n}\n\nTas : Object {\n    type_name: \"Person\",\n    fields: [\n        { name: \"name\", value: Value{TYPE_STRING, \"Alice\"} },\n        { name: \"age\", value: Value{TYPE_I32, 30} }\n    ],\n    field_count: 2,\n    capacity: 4\n}\n```\n- Structure d'objet sur le tas\n- Champs stocks dans un tableau dynamique\n- Les valeurs des champs sont des structures Value intgres\n\n### Implmentation de l'environnement\n\nLes variables sont stockes dans des chanes d'environnement :\n\n```c\ntypedef struct Environment {\n    HashMap *bindings;           // nom  Value\n    struct Environment *parent;  // Porte parente lexicale\n} Environment;\n```\n\n**Exemple de chane de porte :**\n```\nPorte globale : { print: <builtin>, args: <array> }\n    \nPorte fonction : { x: 10, y: 20 }\n    \nPorte bloc : { i: 0 }\n```\n\n**Algorithme de recherche :**\n1. Vrifier le hashmap de l'environnement courant\n2. Si non trouv, vrifier l'environnement parent\n3. Rpter jusqu' trouver ou atteindre la porte globale\n4. Erreur si non trouv dans aucune porte\n\n---\n\n## Implmentation du systme de types\n\n### Stratgie de vrification de types\n\nHemlock utilise la **vrification de type  l'excution** avec des **annotations de type optionnelles** :\n\n```hemlock\nlet x = 42;           // Pas de vrification de type, infre i32\nlet y: u8 = 255;      // Vrification  l'excution : la valeur doit tenir dans u8\nlet z: i32 = x + y;   // Vrification  l'excution + promotion de type\n```\n\n**Flux d'implmentation :**\n1. **Infrence de littral** - Le lexer/parser dtermine le type initial du littral\n2. **Vrification d'annotation de type** - Si annotation prsente, valider  l'affectation\n3. **Promotion** - Les oprations binaires promeuvent vers un type commun\n4. **Conversion** - Les conversions explicites se font  la demande\n\n### Implmentation de la promotion de type\n\nLa promotion de type suit une hirarchie fixe avec prservation de la prcision :\n\n```c\n// Logique de promotion simplifie\nValueType promote_types(ValueType a, ValueType b) {\n    // f64 gagne toujours\n    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;\n\n    // f32 avec i64/u64 promeut vers f64 (prservation de la prcision)\n    if (a == TYPE_F32 || b == TYPE_F32) {\n        ValueType other = (a == TYPE_F32) ? b : a;\n        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;\n        return TYPE_F32;\n    }\n\n    // Les types entiers plus grands gagnent\n    int rank_a = get_type_rank(a);\n    int rank_b = get_type_rank(b);\n    return (rank_a > rank_b) ? a : b;\n}\n```\n\n**Rangs de types :**\n- i8 : 0\n- u8 : 1\n- i16 : 2\n- u16 : 3\n- i32 : 4\n- u32 : 5\n- i64 : 6\n- u64 : 7\n- f32 : 8\n- f64 : 9\n\n### Implmentation du duck typing\n\nLa vrification de type d'objet utilise la comparaison structurelle :\n\n```c\nbool duck_type_check(Object *obj, TypeDef *type_def) {\n    // Vrifier tous les champs requis\n    for (each field in type_def) {\n        if (!object_has_field(obj, field.name)) {\n            return false;  // Champ manquant\n        }\n\n        Value *field_value = object_get_field(obj, field.name);\n        if (!type_matches(field_value, field.type)) {\n            return false;  // Mauvais type\n        }\n    }\n\n    return true;  // Tous les champs requis prsents et de type correct\n}\n```\n\n**Le duck typing permet :**\n- Champs supplmentaires dans les objets (ignors)\n- Typage substructurel (l'objet peut avoir plus que requis)\n- Affectation du nom de type aprs validation\n\n---\n\n## Gestion de la mmoire\n\n### Stratgie d'allocation\n\nHemlock utilise la **gestion manuelle de la mmoire** avec deux primitives d'allocation :\n\n**1. Pointeurs bruts (`ptr`) :**\n```c\nvoid *alloc(size_t bytes) {\n    void *ptr = malloc(bytes);\n    if (!ptr) {\n        fprintf(stderr, \"Mmoire insuffisante\\n\");\n        exit(1);\n    }\n    return ptr;\n}\n```\n- malloc/free direct\n- Pas de suivi\n- Responsabilit de l'utilisateur de librer\n\n**2. Buffers (`buffer`) :**\n```c\ntypedef struct Buffer {\n    void *data;\n    size_t length;\n    size_t capacity;\n} Buffer;\n\nBuffer *create_buffer(size_t size) {\n    Buffer *buf = malloc(sizeof(Buffer));\n    buf->data = malloc(size);\n    buf->length = size;\n    buf->capacity = size;\n    return buf;\n}\n```\n- Suit la taille et la capacit\n- Vrification des limites  l'accs\n- Ncessite toujours une libration manuelle\n\n### Types allous sur le tas\n\n**Chanes :**\n- Tableau d'octets UTF-8 sur le tas\n- Termin par null pour l'interoprabilit C\n- Mutable (peut modifier sur place)\n- Comptage de rfrences (auto-libr quand la porte se termine)\n\n**Objets :**\n- Tableau de champs dynamique\n- Noms et valeurs des champs sur le tas\n- Comptage de rfrences (auto-libr quand la porte se termine)\n- Rfrences circulaires possibles (gr avec suivi d'ensemble visit)\n\n**Tableaux :**\n- Croissance par doublement de capacit dynamique\n- Les lments sont des structures Value intgres\n- Rallocation automatique lors de la croissance\n- Comptage de rfrences (auto-libr quand la porte se termine)\n\n**Closures :**\n- Capture l'environnement par rfrence\n- L'environnement est allou sur le tas\n- Les environnements de closure sont correctement librs quand ils ne sont plus rfrencs\n\n---\n\n## Modle de concurrence\n\n### Architecture de threading\n\nHemlock utilise le **threading 1:1** avec les threads POSIX (pthreads) :\n\n```\nTche utilisateur       Thread OS          Cur CPU\n----------------        ---------          --------\nspawn(f1) ------>  pthread_create --> Cur 0\nspawn(f2) ------>  pthread_create --> Cur 1\nspawn(f3) ------>  pthread_create --> Cur 2\n```\n\n**Caractristiques cls :**\n- Chaque `spawn()` cre un nouveau pthread\n- Le noyau planifie les threads sur les curs\n- Vraie excution parallle (pas de GIL)\n- Multitche premptif\n\n### Implmentation des tches\n\n```c\ntypedef struct Task {\n    pthread_t thread;        // Handle de thread OS\n    Value result;            // Valeur de retour\n    char *error;             // Message d'exception (si leve)\n    pthread_mutex_t lock;    // Protge l'tat\n    TaskState state;         // RUNNING, FINISHED, ERROR\n} Task;\n```\n\n**Cycle de vie d'une tche :**\n1. `spawn(func, args)`  Crer Task, dmarrer pthread\n2. Le thread excute la fonction avec les arguments\n3. Au retour : Stocker le rsultat, dfinir l'tat  FINISHED\n4. Sur exception : Stocker le message d'erreur, dfinir l'tat  ERROR\n5. `join(task)`  Attendre le thread, retourner le rsultat ou lever l'exception\n\n### Implmentation des canaux\n\n```c\ntypedef struct Channel {\n    void **buffer;           // Buffer circulaire de Value*\n    size_t capacity;         // Maximum d'lments en buffer\n    size_t count;            // lments actuels dans le buffer\n    size_t read_index;       // Prochaine position de lecture\n    size_t write_index;      // Prochaine position d'criture\n    bool closed;             // Indicateur de canal ferm\n    pthread_mutex_t lock;    // Protge le buffer\n    pthread_cond_t not_full; // Signal quand de l'espace est disponible\n    pthread_cond_t not_empty;// Signal quand des donnes sont disponibles\n} Channel;\n```\n\n**Opration d'envoi :**\n1. Verrouiller le mutex\n2. Attendre si le buffer est plein (cond_wait sur not_full)\n3. crire la valeur dans buffer[write_index]\n4. Incrmenter write_index (circulaire)\n5. Signaler not_empty\n6. Dverrouiller le mutex\n\n**Opration de rception :**\n1. Verrouiller le mutex\n2. Attendre si le buffer est vide (cond_wait sur not_empty)\n3. Lire la valeur depuis buffer[read_index]\n4. Incrmenter read_index (circulaire)\n5. Signaler not_full\n6. Dverrouiller le mutex\n\n**Garanties de synchronisation :**\n- Envoi/rception thread-safe (protg par mutex)\n- Smantique bloquante (le producteur attend si plein, le consommateur attend si vide)\n- Livraison ordonne (FIFO dans un canal)\n\n---\n\n## Plans futurs\n\n### Termin : Backend compilateur\n\nLe backend compilateur (`hemlockc`) a t implment avec :\n- Gnration de code C depuis l'AST\n- Vrification de types  la compilation (active par dfaut)\n- Bibliothque runtime (`libhemlock_runtime.a`)\n- Parit complte avec l'interprteur (98% de taux de russite des tests)\n- Framework d'optimisation par dballage\n\n### Focus actuel : Amliorations du systme de types\n\n**Amliorations rcentes :**\n- Systmes de vrification et d'infrence de types unifis\n- Vrification de types  la compilation active par dfaut\n- Option `--check` pour la validation de types uniquement\n- Contexte de type pass au codegen pour les indices d'optimisation\n\n### Amliorations futures\n\n**Ajouts potentiels :**\n- Gnriques/templates\n- Pattern matching\n- Intgration LSP pour le support IDE avec conscience des types\n- Optimisations de dballage plus agressives\n- Analyse d'chappement pour l'allocation sur la pile\n\n### Optimisations  long terme\n\n**Amliorations possibles :**\n- Cache en ligne pour les appels de mthode\n- Compilation JIT pour les chemins de code chauds\n- Planificateur avec vol de travail pour une meilleure concurrence\n- Optimisation guide par le profilage\n\n---\n\n## Directives d'implmentation\n\n### Ajouter de nouvelles fonctionnalits\n\nLors de l'implmentation de nouvelles fonctionnalits, suivez ces directives :\n\n**1. Choisir le bon module :**\n- Nouveaux types de valeur  `values.c`\n- Conversions de type  `types.c`\n- Fonctions intgres  `builtins.c`\n- Oprations E/S  `io.c`\n- Flux de contrle  `runtime.c`\n\n**2. Mettre  jour toutes les couches :**\n- Ajouter les types de nud AST si ncessaire (`ast.h`, `ast.c`)\n- Ajouter les tokens du lexer si ncessaire (`lexer.c`)\n- Ajouter les rgles du parser (`parser.c`)\n- Implmenter le comportement d'excution (`runtime.c` ou module appropri)\n- Ajouter les tests (`tests/`)\n\n**3. Maintenir la cohrence :**\n- Suivre le style de code existant\n- Utiliser des conventions de nommage cohrentes\n- Documenter l'API publique dans les en-ttes\n- Garder les messages d'erreur clairs et cohrents\n\n**4. Tester minutieusement :**\n- Ajouter les cas de test avant d'implmenter\n- Tester les chemins de succs et d'erreur\n- Tester les cas limites\n- Vrifier l'absence de fuites mmoire (valgrind)\n\n### Considrations de performance\n\n**Goulots d'tranglement actuels :**\n- Recherches HashMap pour l'accs aux variables\n- Appels de fonction rcursifs (pas d'optimisation des appels terminaux)\n- Concatnation de chanes (alloue une nouvelle chane  chaque fois)\n- Surcharge de vrification de type  chaque opration\n\n**Opportunits d'optimisation :**\n- Mettre en cache les emplacements de variables (cache en ligne)\n- Optimisation des appels terminaux\n- StringBuilder pour la concatnation\n- Infrence de type pour viter les vrifications  l'excution\n\n### Conseils de dbogage\n\n**Outils utiles :**\n- `valgrind` - Dtection des fuites mmoire\n- `gdb` - Dbogage des crashs\n- Option `-g` - Symboles de dbogage\n- Dbogage avec `printf` - Simple mais efficace\n\n**Problmes courants :**\n- Segfault  Drfrencement de pointeur null (vrifier les valeurs de retour)\n- Fuite mmoire  Appel free() manquant (vrifier les chemins de value_free)\n- Erreur de type  Vrifier la logique de type_convert() et type_check()\n- Crash dans les threads  Condition de course (vrifier l'utilisation des mutex)\n\n---\n\n## Conclusion\n\nL'implmentation de Hemlock priorise :\n- **Modularit** - Sparation nette des proccupations\n- **Simplicit** - Implmentation directe\n- **Explicitation** - Pas de magie cache\n- **Maintenabilit** - Facile  comprendre et modifier\n\nL'interprteur actuel par parcours d'arbre est intentionnellement simple pour faciliter le dveloppement rapide de fonctionnalits et l'exprimentation. Le futur backend compilateur amliorera les performances tout en maintenant la mme smantique.\n"}, "Conception et Philosophie -> Philosophie": {"id": "design-philosophy", "content": "# Philosophie de conception du langage Hemlock\n\n> \"Un petit langage non scuris pour crire des choses non scurises en toute scurit.\"\n\nCe document prsente les principes et la philosophie de conception fondamentaux de Hemlock. Lisez-le avant d'apporter des modifications ou des ajouts au langage.\n\n---\n\n## Table des matires\n\n- [Identit fondamentale](#identit-fondamentale)\n- [Principes de conception](#principes-de-conception)\n- [Philosophie sur la scurit](#philosophie-sur-la-scurit)\n- [Ce qu'il ne faut PAS ajouter](#ce-quil-ne-faut-pas-ajouter)\n- [Considrations futures](#considrations-futures)\n- [Rflexions finales](#rflexions-finales)\n\n---\n\n## Identit fondamentale\n\nHemlock est un **langage de script systme** qui adopte la gestion manuelle de la mmoire et le contrle explicite. Il est conu pour les programmeurs qui veulent :\n\n- La puissance du C\n- L'ergonomie des langages de script modernes\n- La concurrence asynchrone structure intgre\n- Aucun comportement cach ni magie\n\n### Ce que Hemlock N'EST PAS\n\n- **Scuris en mmoire** (les pointeurs invalides sont de votre responsabilit)\n- **Un remplacement pour Rust, Go ou Lua**\n- **Un langage qui vous cache la complexit**\n\n### Ce que Hemlock EST\n\n- **Explicite plutt qu'implicite, toujours**\n- **ducatif et exprimental**\n- **Une \"couche de script C\" pour le travail systme**\n- **Honnte sur les compromis**\n\n---\n\n## Principes de conception\n\n### 1. Explicite plutt qu'implicite\n\nHemlock favorise l'explicitation dans toutes les constructions du langage. Il ne devrait y avoir aucune surprise, aucune magie et aucun comportement cach.\n\n**Mauvais (implicite) :**\n```hemlock\nlet x = 5  // Point-virgule manquant - devrait gnrer une erreur\n```\n\n**Bon (explicite) :**\n```hemlock\nlet x = 5;\nfree(ptr);  // Vous l'avez allou, vous le librez\n```\n\n**Aspects cls :**\n- Les points-virgules sont obligatoires (pas d'insertion automatique)\n- Pas de ramasse-miettes (garbage collection)\n- Gestion manuelle de la mmoire (alloc/free)\n- Les annotations de type sont optionnelles mais vrifies  l'excution\n- Pas de nettoyage automatique des ressources (pas de RAII), mais `defer` fournit un nettoyage explicite\n\n### 2. Dynamique par dfaut, typ par choix\n\nChaque valeur possde une tiquette de type  l'excution, mais le systme est conu pour tre flexible tout en dtectant les erreurs.\n\n**Infrence de type :**\n- Petits entiers (tient dans i32) : `42`  `i32`\n- Grands entiers (> plage i32) : `9223372036854775807`  `i64`\n- Flottants : `3.14`  `f64`\n\n**Typage explicite si ncessaire :**\n```hemlock\nlet x = 42;              // i32 infr (petite valeur)\nlet y: u8 = 255;         // u8 explicite\nlet z = x + y;           // promu en i32\nlet big = 5000000000;    // i64 infr (> max i32)\n```\n\n**Les rgles de promotion de type** suivent une hirarchie claire du plus petit au plus grand, les flottants l'emportant toujours sur les entiers.\n\n### 3. L'inscurit est une fonctionnalit, pas un bug\n\nHemlock n'essaie pas de prvenir toutes les erreurs. Au lieu de cela, il vous donne les outils pour tre en scurit tout en vous permettant d'opter pour un comportement non scuris si ncessaire.\n\n**Exemples d'inscurit intentionnelle :**\n- L'arithmtique des pointeurs peut dborder (responsabilit de l'utilisateur)\n- Pas de vrification des limites sur `ptr` brut (utilisez `buffer` si vous voulez la scurit)\n- Les crashs de double libration sont autoriss (gestion manuelle de la mmoire)\n- Le systme de types prvient les accidents mais permet les piges si ncessaire\n\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Bien au-del de l'allocation - autoris mais dangereux\n```\n\n**La philosophie :** Le systme de types devrait prvenir les *accidents* mais autoriser les oprations non scurises *intentionnelles*.\n\n### 4. Concurrence structure de premire classe\n\nLa concurrence n'est pas une rflexion aprs coup dans Hemlock. Elle est intgre au langage ds le dpart.\n\n**Fonctionnalits cls :**\n- `async`/`await` intgrs au langage\n- Canaux pour la communication\n- `spawn`/`join`/`detach` pour la gestion des tches\n- Pas de threads bruts, pas de verrous - structur uniquement\n- Vrai paralllisme multi-thread utilisant les threads POSIX\n\n**Ce n'est pas une boucle d'vnements ni des green threads** - Hemlock utilise de vrais threads du systme d'exploitation pour un vrai paralllisme sur plusieurs curs CPU.\n\n### 5. Syntaxe proche du C, peu de crmonie\n\nHemlock devrait sembler familier aux programmeurs systme tout en rduisant le code rptitif.\n\n**Choix de conception :**\n- Blocs `{}` toujours, pas d'accolades optionnelles\n- Les oprateurs correspondent au C : `+`, `-`, `*`, `/`, `&&`, `||`, `!`\n- La syntaxe de type correspond  Rust/TypeScript : `let x: type = value;`\n- Les fonctions sont des valeurs de premire classe\n- Minimum de mots-cls et de formes spciales\n\n---\n\n## Philosophie sur la scurit\n\n**La position de Hemlock sur la scurit :**\n\n> \"Nous vous donnons les outils pour tre en scurit (`buffer`, annotations de type, vrification des limites) mais nous ne vous forons pas  les utiliser (`ptr`, mmoire manuelle, oprations non scurises).\n>\n> Le comportement par dfaut devrait guider vers la scurit, mais la porte de sortie devrait toujours tre disponible.\"\n\n### Outils de scurit fournis\n\n**1. Type buffer scuris :**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // vrifi aux limites\nprint(b.length);        // 64\nfree(b);                // toujours manuel\n```\n\n**2. Pointeurs bruts non scuriss :**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // Vous devez penser  librer\n```\n\n**3. Annotations de type :**\n```hemlock\nlet x: u8 = 255;   // OK\nlet y: u8 = 256;   // ERREUR : hors plage\n```\n\n**4. Vrification de type  l'excution :**\n```hemlock\nlet val = some_function();\nif (typeof(val) == \"i32\") {\n    // Sr de l'utiliser comme entier\n}\n```\n\n### Principes directeurs\n\n1. **Par dfaut, utiliser des modles srs dans la documentation** - Montrer `buffer` avant `ptr`, encourager les annotations de type\n2. **Rendre les oprations non scurises videntes** - L'arithmtique des pointeurs bruts devrait sembler intentionnelle\n3. **Fournir des portes de sortie** - Ne pas empcher les utilisateurs expriments de faire du travail bas niveau\n4. **tre honnte sur les compromis** - Documenter ce qui peut mal tourner\n\n### Exemples de scurit vs inscurit\n\n| Modle sr | Modle non sr | Quand utiliser le non sr |\n|------------|----------------|---------------------------|\n| Type `buffer` | Type `ptr` | FFI, code critique en performance |\n| Annotations de type | Pas d'annotations | Interfaces externes, validation |\n| Accs vrifi aux limites | Arithmtique de pointeurs | Oprations mmoire bas niveau |\n| Gestion des exceptions | Retour de null/codes d'erreur | Quand les exceptions sont trop lourdes |\n\n---\n\n## Ce qu'il ne faut PAS ajouter\n\nComprendre ce qu'il **ne faut pas** ajouter est aussi important que savoir quoi ajouter.\n\n### Ne pas ajouter de comportement implicite\n\n**Mauvais exemples :**\n\n```hemlock\n// MAUVAIS : Insertion automatique de point-virgule\nlet x = 5\nlet y = 10\n\n// MAUVAIS : Conversions de type implicites qui perdent en prcision\nlet x: i32 = 3.14  // Devrait tronquer ou gnrer une erreur ?\n```\n\n**Pourquoi :** Le comportement implicite cre des surprises et rend le code plus difficile  comprendre.\n\n### Ne pas cacher la complexit\n\n**Mauvais exemples :**\n\n```hemlock\n// MAUVAIS : Optimisation magique en coulisses\nlet arr = [1, 2, 3]  // Est-ce sur la pile ou le tas ? L'utilisateur devrait savoir ! (Tas, comptage de rfrences)\n\n// MAUVAIS : Pointeur brut auto-libr\nlet p = alloc(100)  // Est-ce auto-libr ? NON ! Les ptr bruts ncessitent toujours free()\n```\n\n**Note sur le comptage de rfrences :** Hemlock utilise le comptage de rfrences interne pour les chanes, tableaux, objets et buffers - ceux-ci SONT auto-librs quand la porte se termine. C'est explicite et prvisible (nettoyage dterministe quand la rfrence atteint 0, pas de pauses GC). Les pointeurs bruts (`ptr` de `alloc()`) ne sont PAS compts par rfrence et ncessitent toujours `free()` manuel.\n\n**Pourquoi :** La complexit cache rend impossible de prdire les performances et de dboguer les problmes.\n\n### Ne pas casser les smantiques existantes\n\n**Ne jamais changer ces dcisions fondamentales :**\n- Les points-virgules sont obligatoires - ne pas les rendre optionnels\n- Gestion manuelle de la mmoire - ne pas ajouter de GC\n- Chanes mutables - ne pas les rendre immuables\n- Vrification de type  l'excution - ne pas la supprimer\n\n**Pourquoi :** La cohrence et la stabilit sont plus importantes que les fonctionnalits  la mode.\n\n### Ne pas ajouter de fonctionnalits \"pratiques\" qui rduisent l'explicitation\n\n**Exemples de fonctionnalits  viter :**\n- Surcharge d'oprateurs (peut-tre pour les types utilisateur, mais avec prudence)\n- Coercition de type implicite qui perd de l'information\n- Nettoyage automatique des ressources (RAII)\n- Chanage de mthodes qui cache la complexit\n- DSL et syntaxe magique\n\n**Exception :** Les fonctionnalits de commodit sont OK si elles sont du **sucre syntaxique explicite** sur des oprations simples :\n- `else if` est bien (ce sont juste des instructions if imbriques)\n- L'interpolation de chanes pourrait tre OK si c'est clairement du sucre syntaxique\n- La syntaxe de mthode pour les objets est bien (c'est explicite ce que a fait)\n\n---\n\n## Considrations futures\n\n### Peut-tre ajouter (en discussion)\n\nCes fonctionnalits s'alignent avec la philosophie de Hemlock mais ncessitent une conception soigne :\n\n**1. Pattern matching (correspondance de motifs)**\n```hemlock\nmatch (value) {\n    case i32: print(\"entier\");\n    case string: print(\"texte\");\n    case _: print(\"autre\");\n}\n```\n- Vrification de type explicite\n- Pas de cots cachs\n- Vrification d'exhaustivit  la compilation possible\n\n**2. Types d'erreur (`Result<T, E>`)**\n```hemlock\nfn divide(a: i32, b: i32): Result<i32, string> {\n    if (b == 0) {\n        return Err(\"division par zro\");\n    }\n    return Ok(a / b);\n}\n```\n- Gestion d'erreur explicite\n- Force les utilisateurs  penser aux erreurs\n- Alternative aux exceptions\n\n**3. Types tableau/slice**\n- Nous avons dj des tableaux dynamiques\n- Pourrait ajouter des tableaux de taille fixe pour l'allocation sur la pile\n- Devrait tre explicite sur pile vs tas\n\n**4. Outils de scurit mmoire amliors**\n- Option de vrification des limites\n- Dtection des fuites mmoire en mode debug\n- Intgration des sanitizers\n\n### Probablement jamais ajouter\n\nCes fonctionnalits violent les principes fondamentaux :\n\n**1. Ramasse-miettes (garbage collection)**\n- Cache la complexit de la gestion mmoire\n- Performances imprvisibles\n- Contre le principe de contrle explicite\n\n**2. Gestion automatique de la mmoire**\n- Mmes raisons que le GC\n- Le comptage de rfrences pourrait tre OK s'il est explicite\n\n**3. Conversions de type implicites qui perdent des donnes**\n- Va contre \"explicite plutt qu'implicite\"\n- Source de bugs subtils\n\n**4. Macros (complexes)**\n- Trop de puissance, trop de complexit\n- Un systme de macros simple pourrait tre OK\n- Prfrer la gnration de code ou les fonctions\n\n**5. POO base sur les classes avec hritage**\n- Trop de comportement implicite\n- Le duck typing et les objets sont suffisants\n- Composition plutt qu'hritage\n\n**6. Systme de modules avec rsolution complexe**\n- Garder les imports simples et explicites\n- Pas de chemins de recherche magiques\n- Pas de rsolution de version (utiliser le gestionnaire de paquets de l'OS)\n\n---\n\n## Rflexions finales\n\n### Confiance et responsabilit\n\nHemlock est une question de **confiance et responsabilit**. Nous faisons confiance au programmeur pour :\n\n- Grer la mmoire correctement\n- Utiliser les types de manire approprie\n- Grer les erreurs correctement\n- Comprendre les compromis\n\nEn retour, Hemlock fournit :\n\n- Pas de cots cachs\n- Pas de comportement surprise\n- Contrle total quand ncessaire\n- Outils de scurit quand souhait\n\n### La question directrice\n\n**Quand vous considrez une nouvelle fonctionnalit, demandez-vous :**\n\n> \"Est-ce que cela donne au programmeur plus de contrle explicite, ou est-ce que cela cache quelque chose ?\"\n\n- Si cela **ajoute du contrle explicite**  convient probablement  Hemlock\n- Si cela **cache de la complexit**  n'appartient probablement pas\n- Si c'est du **sucre optionnel** clairement document  pourrait tre OK\n\n### Exemples de bons ajouts\n\nLes **instructions switch** - Flux de contrle explicite, pas de magie, smantique claire\n\nL'**async/await avec pthreads** - Concurrence explicite, vrai paralllisme, l'utilisateur contrle le lancement\n\nLe **type Buffer  ct de ptr** - Donne le choix entre sr et non sr\n\nLes **annotations de type optionnelles** - Aide  dtecter les bugs sans forcer la rigueur\n\n**Try/catch/finally** - Gestion d'erreur explicite avec flux de contrle clair\n\n### Exemples de mauvais ajouts\n\nL'**insertion automatique de point-virgule** - Cache les erreurs de syntaxe, rend le code ambigu\n\nLe **RAII/destructeurs** - Le nettoyage automatique cache quand les ressources sont libres\n\nLa **coalescence null implicite** - Cache les vrifications de null, rend le code plus difficile  comprendre\n\nLes **chanes  croissance automatique** - Cache l'allocation mmoire, performances imprvisibles\n\n---\n\n## Conclusion\n\nHemlock n'essaie pas d'tre le langage le plus sr, le plus rapide ou le plus riche en fonctionnalits.\n\n**Hemlock essaie d'tre le langage le plus *honnte*.**\n\nIl vous dit exactement ce qu'il fait, vous donne le contrle quand vous en avez besoin, et ne cache pas les bords tranchants. C'est un langage pour les personnes qui veulent comprendre leur code  bas niveau tout en profitant d'une ergonomie moderne.\n\nSi vous n'tes pas sr qu'une fonctionnalit appartient  Hemlock, souvenez-vous :\n\n> **Explicite plutt qu'implicite, toujours.**\n> **L'inscurit est une fonctionnalit, pas un bug.**\n> **L'utilisateur est responsable, et c'est OK.**\n"}, "Conception et Philosophie -> Syntaxe des Signatures": {"id": "design-signature-syntax", "content": "# Conception de la syntaxe des signatures\n\n> Extension du systme de types de Hemlock avec les types fonction, les modificateurs nullable, les alias de type, les paramtres const et les signatures de mthode.\n\n**Statut :** Implment (v1.7.0)\n**Version :** 1.0\n**Auteur :** Claude\n\n---\n\n## Aperu\n\nCe document propose cinq extensions du systme de types interconnectes qui s'appuient sur l'infrastructure existante de Hemlock :\n\n1. **Annotations de type fonction** - Types fonction de premire classe\n2. **Modificateurs de type nullable** - Gestion explicite de null (tend le flag `nullable` existant)\n3. **Alias de type** - Abrviations de type nommes\n4. **Paramtres const** - Contrats d'immuabilit\n5. **Signatures de mthode dans define** - Comportement de type interface\n\nCes fonctionnalits partagent la philosophie : **explicite plutt qu'implicite, optionnel mais appliqu quand utilis**.\n\n---\n\n## 1. Annotations de type fonction\n\n### Motivation\n\nActuellement, il n'y a pas de moyen d'exprimer la signature d'une fonction comme type :\n\n```hemlock\n// Actuel : callback n'a pas d'information de type\nfn map(arr: array, callback) { ... }\n\n// Propos : type fonction explicite\nfn map(arr: array, callback: fn(any, i32): any): array { ... }\n```\n\n### Syntaxe\n\n```hemlock\n// Type fonction basique\nfn(i32, i32): i32\n\n// Avec noms de paramtres (documentation seulement, non appliqu)\nfn(a: i32, b: i32): i32\n\n// Pas de valeur de retour (void)\nfn(string): void\nfn(string)              // Raccourci : omettre `: void`\n\n// Retour nullable\nfn(i32): string?\n\n// Paramtres optionnels\nfn(name: string, age?: i32): void\n\n// Paramtres rest\nfn(...args: array): i32\n\n// Pas de paramtres\nfn(): bool\n\n// Ordre suprieur : fonction retournant une fonction\nfn(i32): fn(i32): i32\n\n// Type fonction asynchrone\nasync fn(i32): i32\n```\n\n### Exemples d'utilisation\n\n```hemlock\n// Variable avec type fonction\nlet add: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// Paramtre de fonction\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Le type de retour est une fonction\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Tableau de fonctions\nlet ops: array<fn(i32, i32): i32> = [add, subtract, multiply];\n\n// Champ d'objet\ndefine EventHandler {\n    name: string;\n    callback: fn(Event): void;\n}\n```\n\n### Modifications de l'AST\n\n```c\n// Dans l'enum TypeKind (include/ast.h)\ntypedef enum {\n    // ... types existants ...\n    TYPE_FUNCTION,      // NOUVEAU : Type fonction\n} TypeKind;\n\n// Dans la struct Type (include/ast.h)\nstruct Type {\n    TypeKind kind;\n    // ... champs existants ...\n\n    // Pour TYPE_FUNCTION :\n    struct Type **param_types;      // Types des paramtres\n    char **param_names;             // Noms des paramtres optionnels (docs)\n    int *param_optional;            // Quels paramtres sont optionnels\n    int num_params;\n    char *rest_param_name;          // Nom du paramtre rest ou NULL\n    struct Type *rest_param_type;   // Type du paramtre rest\n    struct Type *return_type;       // Type de retour (NULL = void)\n    int is_async;                   // Type fn async\n};\n```\n\n### Analyse syntaxique\n\nLes types fonction commencent par `fn` (ou `async fn`) suivi de la liste des paramtres :\n\n```\nfunction_type := [\"async\"] \"fn\" \"(\" [param_type_list] \")\" [\":\" type]\nparam_type_list := param_type (\",\" param_type)*\nparam_type := [identifier \":\"] [\"?\"] type | \"...\" [identifier] [\":\" type]\n```\n\n**Dsambigusation :** Lors de l'analyse d'un type et que `fn` est rencontr :\n- Si suivi de `(`, c'est un type fonction\n- Sinon, erreur de syntaxe (`fn` seul n'est pas un type valide)\n\n### Compatibilit de types\n\n```hemlock\n// Correspondance exacte requise pour les types fonction\nlet f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // OK\n\n// Contravariance des paramtres (accepter des types plus larges est OK)\nlet g: fn(any): i32 = fn(x: i32): i32 { return x; };  // OK : i32 <: any\n\n// Covariance du retour (retourner des types plus troits est OK)\nlet h: fn(i32): any = fn(x: i32): i32 { return x; };  // OK : i32 <: any\n\n// L'arit doit correspondre\nlet bad: fn(i32): i32 = fn(a, b) { return a; };       // ERREUR : arit diffrente\n\n// Paramtres optionnels compatibles avec les requis\nlet opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // OK\n```\n\n---\n\n## 2. Modificateurs de type nullable\n\n### Motivation\n\nLe suffixe `?` rend l'acceptation de null explicite dans les signatures :\n\n```hemlock\n// Actuel : pas clair si null est valide\nfn find(arr: array, val: any): i32 { ... }\n\n// Propos : retour nullable explicite\nfn find(arr: array, val: any): i32? { ... }\n```\n\n### Syntaxe\n\n```hemlock\n// Types nullable avec suffixe ?\nstring?           // string ou null\ni32?              // i32 ou null\nUser?             // User ou null\narray<i32>?       // array ou null\nfn(i32): i32?     // fonction retournant i32 ou null\n\n// Composition avec les types fonction\nfn(string?): i32          // Accepte string ou null\nfn(string): i32?          // Retourne i32 ou null\nfn(string?): i32?         // Les deux nullable\n\n// Dans define\ndefine Result {\n    value: any?;\n    error: string?;\n}\n```\n\n### Notes d'implmentation\n\n**Existe dj :** Le flag `Type.nullable` est dj dans l'AST. Cette fonctionnalit ncessite principalement :\n1. Support du parser pour le suffixe `?` sur tout type (vrifier/tendre)\n2. Composition correcte avec les types fonction\n3. Application  l'excution\n\n### Compatibilit de types\n\n```hemlock\n// Non-nullable assignable  nullable\nlet x: i32? = 42;           // OK\nlet y: i32? = null;         // OK\n\n// Nullable NON assignable  non-nullable\nlet z: i32 = x;             // ERREUR : x pourrait tre null\n\n// Coalescence null pour dballer\nlet z: i32 = x ?? 0;        // OK : ?? fournit une valeur par dfaut\n\n// Le chanage optionnel retourne nullable\nlet name: string? = user?.name;\n```\n\n---\n\n## 3. Alias de type\n\n### Motivation\n\nLes types complexes bnficient d'abrviations nommes :\n\n```hemlock\n// Actuel : types composs rptitifs\nfn process(entity: HasName & HasId & HasTimestamp) { ... }\nfn validate(entity: HasName & HasId & HasTimestamp) { ... }\n\n// Propos : alias nomm\ntype Entity = HasName & HasId & HasTimestamp;\nfn process(entity: Entity) { ... }\nfn validate(entity: Entity) { ... }\n```\n\n### Syntaxe\n\n```hemlock\n// Alias basique\ntype Integer = i32;\ntype Text = string;\n\n// Alias de type compos\ntype Entity = HasName & HasId;\ntype Auditable = HasCreatedAt & HasUpdatedAt & HasCreatedBy;\n\n// Alias de type fonction\ntype Callback = fn(Event): void;\ntype Predicate = fn(any): bool;\ntype Reducer = fn(acc: any, val: any): any;\ntype AsyncTask = async fn(): any;\n\n// Alias nullable\ntype OptionalString = string?;\n\n// Alias gnrique (si nous supportons les alias de type gnriques)\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// Alias de type tableau\ntype IntArray = array<i32>;\ntype Matrix = array<array<f64>>;\n```\n\n### Porte et visibilit\n\n```hemlock\n// Porte module par dfaut\ntype Callback = fn(Event): void;\n\n// Exportable\nexport type Handler = fn(Request): Response;\n\n// Dans un autre fichier\nimport { Handler } from \"./handlers.hml\";\nfn register(h: Handler) { ... }\n```\n\n### Modifications de l'AST\n\n```c\n// Nouveau type d'instruction\ntypedef enum {\n    // ... instructions existantes ...\n    STMT_TYPE_ALIAS,    // NOUVEAU\n} StmtKind;\n\n// Dans l'union Stmt\nstruct {\n    char *name;                 // Nom de l'alias\n    char **type_params;         // Paramtres gnriques : <T, U>\n    int num_type_params;\n    Type *aliased_type;         // Le type rel\n} type_alias;\n```\n\n### Analyse syntaxique\n\n```\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n```\n\n**Note :** `type` est un nouveau mot-cl. Vrifier les conflits avec les identifiants existants.\n\n### Rsolution\n\nLes alias de type sont rsolus  :\n- **Temps d'analyse :** L'alias est enregistr dans l'environnement de types\n- **Temps de vrification :** L'alias est dvelopp vers le type sous-jacent\n- **Excution :** L'alias est transparent (mme que le type sous-jacent)\n\n```hemlock\ntype MyInt = i32;\nlet x: MyInt = 42;\ntypeof(x);           // \"i32\" (pas \"MyInt\")\n```\n\n---\n\n## 4. Paramtres const\n\n### Motivation\n\nSignaler l'intention d'immuabilit dans les signatures de fonction :\n\n```hemlock\n// Actuel : pas clair si array sera modifi\nfn print_all(items: array) { ... }\n\n// Propos : contrat d'immuabilit explicite\nfn print_all(const items: array) { ... }\n```\n\n### Syntaxe\n\n```hemlock\n// Paramtre const\nfn process(const data: buffer) {\n    // data[0] = 0;        // ERREUR : impossible de muter const\n    let x = data[0];       // OK : lecture autorise\n    return x;\n}\n\n// Plusieurs paramtres const\nfn compare(const a: array, const b: array): bool { ... }\n\n// Mlange const et mutable\nfn update(const source: array, target: array) {\n    for (item in source) {\n        target.push(item);   // OK : target est mutable\n    }\n}\n\n// Const avec infrence de type\nfn log(const msg) {\n    print(msg);\n}\n\n// Const dans les types fonction\ntype Reader = fn(const buffer): i32;\n```\n\n### Ce que const empche\n\n```hemlock\nfn bad(const arr: array) {\n    arr.push(1);         // ERREUR : mthode de mutation\n    arr.pop();           // ERREUR : mthode de mutation\n    arr[0] = 5;          // ERREUR : affectation par index\n    arr.clear();         // ERREUR : mthode de mutation\n}\n\nfn ok(const arr: array) {\n    let x = arr[0];      // OK : lecture\n    let len = len(arr);  // OK : vrification de longueur\n    let copy = arr.slice(0, 10);  // OK : cre un nouveau tableau\n    for (item in arr) {  // OK : itration\n        print(item);\n    }\n}\n```\n\n### Mthodes mutantes vs non-mutantes\n\n| Type | Mutantes (bloques par const) | Non-mutantes (autorises) |\n|------|-------------------------------|---------------------------|\n| array | push, pop, shift, unshift, insert, remove, clear, reverse (sur place) | slice, concat, map, filter, find, contains, first, last, join |\n| string | affectation par index (`s[0] = 'x'`) | toutes les mthodes (retournent de nouvelles chanes) |\n| buffer | affectation par index, memset, memcpy (vers) | lecture par index, slice |\n| object | affectation de champ | lecture de champ |\n\n### Modifications de l'AST\n\n```c\n// Dans l'expression fonction (include/ast.h)\nstruct {\n    // ... champs existants ...\n    int *param_is_const;    // NOUVEAU : 1 si const, 0 sinon\n} function;\n\n// Dans la struct Type pour les types fonction\nstruct Type {\n    // ... champs existants ...\n    int *param_is_const;    // Pour TYPE_FUNCTION\n};\n```\n\n### Application\n\n**Interprteur :**\n- Suivre la proprit const dans les liaisons de variables\n- Vrifier avant les oprations de mutation\n- Erreur  l'excution en cas de violation const\n\n**Compilateur :**\n- mettre des variables C qualifies const si bnfique\n- Analyse statique des violations const\n- Avertissement/erreur  la compilation\n\n---\n\n## 5. Signatures de mthode dans define\n\n### Motivation\n\nPermettre aux blocs `define` de spcifier les mthodes attendues, pas seulement les champs de donnes :\n\n```hemlock\n// Actuel : seulement les champs de donnes\ndefine User {\n    name: string;\n    age: i32;\n}\n\n// Propos : signatures de mthode\ndefine Comparable {\n    fn compare(other: Self): i32;\n}\n\ndefine Serializable {\n    fn serialize(): string;\n    fn deserialize(data: string): Self;  // Mthode statique\n}\n```\n\n### Syntaxe\n\n```hemlock\n// Signature de mthode (pas de corps)\ndefine Hashable {\n    fn hash(): i32;\n}\n\n// Plusieurs mthodes\ndefine Collection {\n    fn size(): i32;\n    fn is_empty(): bool;\n    fn contains(item: any): bool;\n}\n\n// Mlange de champs et mthodes\ndefine Entity {\n    id: i32;\n    name: string;\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\n// Utilisation du type Self\ndefine Cloneable {\n    fn clone(): Self;\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;\n    fn equals(other: Self): bool;\n}\n\n// Mthodes optionnelles\ndefine Printable {\n    fn to_string(): string;\n    fn debug_string?(): string;  // Mthode optionnelle (peut tre absente)\n}\n\n// Mthodes avec implmentations par dfaut\ndefine Ordered {\n    fn compare(other: Self): i32;  // Requis\n\n    // Implmentations par dfaut (hrites si non surcharges)\n    fn less_than(other: Self): bool {\n        return self.compare(other) < 0;\n    }\n    fn greater_than(other: Self): bool {\n        return self.compare(other) > 0;\n    }\n    fn equals(other: Self): bool {\n        return self.compare(other) == 0;\n    }\n}\n```\n\n### Le type `Self`\n\n`Self` fait rfrence au type concret implmentant l'interface :\n\n```hemlock\ndefine Addable {\n    fn add(other: Self): Self;\n}\n\n// Quand utilis :\nlet a: Addable = {\n    value: 10,\n    add: fn(other) {\n        return { value: self.value + other.value, add: self.add };\n    }\n};\n```\n\n### Typage structurel (duck typing)\n\nLes signatures de mthode utilisent le mme duck typing que les champs :\n\n```hemlock\ndefine Stringifiable {\n    fn to_string(): string;\n}\n\n// Tout objet avec une mthode to_string() satisfait Stringifiable\nlet x: Stringifiable = {\n    name: \"test\",\n    to_string: fn() { return self.name; }\n};\n\n// Types composs avec mthodes\ndefine Named { name: string; }\ndefine Printable { fn to_string(): string; }\n\ntype NamedPrintable = Named & Printable;\n\nlet y: NamedPrintable = {\n    name: \"Alice\",\n    to_string: fn() { return \"Nom : \" + self.name; }\n};\n```\n\n### Modifications de l'AST\n\n```c\n// tendre define_object dans l'union Stmt\nstruct {\n    char *name;\n    char **type_params;\n    int num_type_params;\n\n    // Champs (existants)\n    char **field_names;\n    Type **field_types;\n    int *field_optional;\n    Expr **field_defaults;\n    int num_fields;\n\n    // Mthodes (NOUVEAU)\n    char **method_names;\n    Type **method_types;        // TYPE_FUNCTION\n    int *method_optional;       // Mthodes optionnelles (fn name?(): type)\n    Expr **method_defaults;     // Implmentations par dfaut (NULL si signature seulement)\n    int num_methods;\n} define_object;\n```\n\n### Vrification de types\n\nLors de la vrification de `value: InterfaceType` :\n1. Vrifier que tous les champs requis existent avec des types compatibles\n2. Vrifier que toutes les mthodes requises existent avec des signatures compatibles\n3. Les champs/mthodes optionnels peuvent tre absents\n\n```hemlock\ndefine Sortable {\n    fn compare(other: Self): i32;\n}\n\n// Valide : a la mthode compare\nlet valid: Sortable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// Invalide : compare manquant\nlet invalid: Sortable = { value: 10 };  // ERREUR : mthode 'compare' manquante\n\n// Invalide : mauvaise signature\nlet wrong: Sortable = {\n    compare: fn() { return 0; }  // ERREUR : attendu (Self): i32\n};\n```\n\n---\n\n## Exemples d'interaction\n\n### Combinaison de toutes les fonctionnalits\n\n```hemlock\n// Alias de type pour type fonction complexe\ntype EventCallback = fn(event: Event, context: Context?): bool;\n\n// Alias de type pour interface compose\ntype Entity = HasId & HasName & Serializable;\n\n// Define avec signatures de mthode\ndefine Repository<T> {\n    fn find(id: i32): T?;\n    fn save(const entity: T): bool;\n    fn delete(id: i32): bool;\n    fn find_all(predicate: fn(T): bool): array<T>;\n}\n\n// Utilisation de tout ensemble\nfn create_user_repo(): Repository<User> {\n    let users: array<User> = [];\n\n    return {\n        find: fn(id) {\n            for (u in users) {\n                if (u.id == id) { return u; }\n            }\n            return null;\n        },\n        save: fn(const entity) {\n            users.push(entity);\n            return true;\n        },\n        delete: fn(id) {\n            // ...\n            return true;\n        },\n        find_all: fn(predicate) {\n            return users.filter(predicate);\n        }\n    };\n}\n```\n\n### Callbacks avec types explicites\n\n```hemlock\ntype ClickHandler = fn(event: MouseEvent): void;\ntype KeyHandler = fn(event: KeyEvent, modifiers: i32): bool;\n\ndefine Widget {\n    x: i32;\n    y: i32;\n    on_click: ClickHandler?;\n    on_key: KeyHandler?;\n}\n\nfn create_button(label: string, handler: ClickHandler): Widget {\n    return {\n        x: 0, y: 0,\n        on_click: handler,\n        on_key: null\n    };\n}\n```\n\n### Types fonction nullable\n\n```hemlock\n// Callback optionnel\nfn fetch(url: string, on_complete: fn(Response): void?): void {\n    let response = http_get(url);\n    if (on_complete != null) {\n        on_complete(response);\n    }\n}\n\n// Retour nullable depuis un type fonction\ntype Parser = fn(input: string): AST?;\n\nfn try_parse(parsers: array<Parser>, input: string): AST? {\n    for (p in parsers) {\n        let result = p(input);\n        if (result != null) {\n            return result;\n        }\n    }\n    return null;\n}\n```\n\n---\n\n## Feuille de route d'implmentation\n\n### Phase 1 : Infrastructure de base\n1. Ajouter `TYPE_FUNCTION`  l'enum TypeKind\n2. tendre la struct Type avec les champs de type fonction\n3. Ajouter `CHECKED_FUNCTION` au vrificateur de types du compilateur\n4. Ajouter le support du type `Self` (TYPE_SELF)\n\n### Phase 2 : Analyse syntaxique\n1. Implmenter `parse_function_type()` dans le parser\n2. Grer `fn(...)` en position de type\n3. Ajouter le mot-cl `type` et l'analyse de `STMT_TYPE_ALIAS`\n4. Ajouter l'analyse du modificateur de paramtre `const`\n5. tendre l'analyse de define pour les signatures de mthode\n\n### Phase 3 : Vrification de types\n1. Rgles de compatibilit des types fonction\n2. Rsolution et expansion des alias de type\n3. Vrification de mutation des paramtres const\n4. Validation des signatures de mthode dans les types define\n5. Rsolution du type Self\n\n### Phase 4 : Excution\n1. Validation du type fonction aux sites d'appel\n2. Dtection des violations const\n3. Transparence des alias de type\n\n### Phase 5 : Tests de parit\n1. Tests d'annotation de type fonction\n2. Tests de composition nullable\n3. Tests d'alias de type\n4. Tests de paramtres const\n5. Tests de signatures de mthode\n\n---\n\n## Dcisions de conception\n\n### 1. Alias de type gnriques : **OUI**\n\nLes alias de type supportent les paramtres gnriques :\n\n```hemlock\n// Alias de type gnriques\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\ntype Mapper<T, U> = fn(T): U;\ntype AsyncResult<T> = async fn(): T?;\n\n// Utilisation\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\nlet result: Result<User, string> = { value: user, error: null };\nlet transform: Mapper<i32, string> = fn(n) { return n.to_string(); };\n```\n\n### 2. Propagation const : **PROFONDE**\n\nLes paramtres const sont totalement immuables - pas de mutation par aucun chemin :\n\n```hemlock\nfn process(const arr: array<object>) {\n    arr.push({});        // ERREUR : impossible de muter un tableau const\n    arr[0] = {};         // ERREUR : impossible de muter un tableau const\n    arr[0].x = 5;        // ERREUR : impossible de muter  travers const (PROFOND)\n\n    let x = arr[0].x;    // OK : la lecture est autorise\n    let copy = arr[0];   // OK : cre une copie\n    copy.x = 5;          // OK : la copie n'est pas const\n}\n\nfn nested(const obj: object) {\n    obj.user.name = \"x\"; // ERREUR : const profond empche la mutation imbrique\n    obj.items[0] = 1;    // ERREUR : const profond empche la mutation imbrique\n}\n```\n\n**Justification :** Le const profond fournit des garanties plus fortes et est plus utile pour\nassurer l'intgrit des donnes. Si vous devez muter des donnes imbriques, faites d'abord une copie.\n\n### 3. Self dans les alias de type autonomes : **NON**\n\n`Self` n'est valide qu' l'intrieur des blocs `define` o il a un sens clair :\n\n```hemlock\n// Valide : Self fait rfrence au type dfini\ndefine Comparable {\n    fn compare(other: Self): i32;\n}\n\n// Invalide : Self n'a pas de sens ici\ntype Cloner = fn(Self): Self;  // ERREUR : Self en dehors du contexte define\n\n//  la place, utilisez les gnriques :\ntype Cloner<T> = fn(T): T;\n```\n\n### 4. Implmentations de mthode par dfaut : **OUI (simples seulement)**\n\nAutoriser les implmentations par dfaut pour les mthodes simples/utilitaires :\n\n```hemlock\ndefine Comparable {\n    // Requis : doit tre implment\n    fn compare(other: Self): i32;\n\n    // Implmentations par dfaut (mthodes de commodit simples)\n    fn equals(other: Self): bool {\n        return self.compare(other) == 0;\n    }\n    fn less_than(other: Self): bool {\n        return self.compare(other) < 0;\n    }\n    fn greater_than(other: Self): bool {\n        return self.compare(other) > 0;\n    }\n}\n\ndefine Printable {\n    fn to_string(): string;\n\n    // Dfaut : dlgue  la mthode requise\n    fn print() {\n        print(self.to_string());\n    }\n    fn println() {\n        print(self.to_string() + \"\\n\");\n    }\n}\n\n// L'objet doit seulement implmenter les mthodes requises\nlet item: Comparable = {\n    value: 42,\n    compare: fn(other) { return self.value - other.value; }\n    // equals, less_than, greater_than sont hrites des valeurs par dfaut\n};\n\nitem.less_than({ value: 50, compare: item.compare });  // true\n```\n\n**Directives pour les valeurs par dfaut :**\n- Les garder simples (1-3 lignes)\n- Devraient dlguer aux mthodes requises\n- Pas de logique complexe ni d'effets de bord\n- Primitives et compositions simples uniquement\n\n### 5. Variance : **INFRE (pas d'annotations explicites)**\n\nLa variance est infre de la faon dont les paramtres de type sont utiliss :\n\n```hemlock\n// La variance est automatique base sur la position\ntype Producer<T> = fn(): T;           // T en retour = covariant\ntype Consumer<T> = fn(T): void;       // T en paramtre = contravariant\ntype Transformer<T> = fn(T): T;       // T dans les deux = invariant\n\n// Exemple : Dog <: Animal (Dog est un sous-type de Animal)\nlet dog_producer: Producer<Dog> = fn() { return new_dog(); };\nlet animal_producer: Producer<Animal> = dog_producer;  // OK : covariant\n\nlet animal_consumer: Consumer<Animal> = fn(a) { print(a); };\nlet dog_consumer: Consumer<Dog> = animal_consumer;     // OK : contravariant\n```\n\n**Pourquoi infrer ?**\n- Moins de code rptitif (`<out T>` / `<in T>` ajoute du bruit)\n- Suit \"explicite plutt qu'implicite\" - la position EST explicite\n- Correspond  la faon dont la plupart des langages grent la variance des types fonction\n- Les erreurs sont claires quand les rgles de variance sont violes\n\n---\n\n## Annexe : Modifications de la grammaire\n\n```ebnf\n(* Types *)\ntype := simple_type | compound_type | function_type\nsimple_type := base_type [\"?\"] | identifier [\"<\" type_args \">\"] [\"?\"]\ncompound_type := simple_type (\"&\" simple_type)+\nfunction_type := [\"async\"] \"fn\" \"(\" [param_types] \")\" [\":\" type]\n\nbase_type := \"i8\" | \"i16\" | \"i32\" | \"i64\"\n           | \"u8\" | \"u16\" | \"u32\" | \"u64\"\n           | \"f32\" | \"f64\" | \"bool\" | \"string\" | \"rune\"\n           | \"ptr\" | \"buffer\" | \"void\" | \"null\"\n           | \"array\" [\"<\" type \">\"]\n           | \"object\"\n           | \"Self\"\n\nparam_types := param_type (\",\" param_type)*\nparam_type := [\"const\"] [identifier \":\"] [\"?\"] type\n            | \"...\" [identifier] [\":\" type]\n\ntype_args := type (\",\" type)*\n\n(* Instructions *)\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n\ndefine_stmt := \"define\" identifier [\"<\" type_params \">\"] \"{\" define_members \"}\"\ndefine_members := (field_def | method_def)*\nfield_def := identifier (\":\" type [\"=\" expr] | \"?:\" (type | expr)) \";\"?\nmethod_def := \"fn\" identifier [\"?\"] \"(\" [param_types] \")\" [\":\" type] (block | \";\")\n            (* \"?\" marque une mthode optionnelle, block fournit l'implmentation par dfaut *)\n\n(* Paramtres *)\nparam := [\"const\"] [\"ref\"] identifier [\":\" type] [\"?:\" expr]\n       | \"...\" identifier [\":\" type]\n```\n"}, "Contribuer -> Directives": {"id": "contributing-guidelines", "content": "# Contribuer  Hemlock\n\nMerci de votre intrt pour contribuer  Hemlock ! Ce guide vous aidera  comprendre comment contribuer efficacement tout en maintenant la philosophie de conception et la qualit du code du langage.\n\n---\n\n## Table des matires\n\n- [Avant de commencer](#avant-de-commencer)\n- [Processus de contribution](#processus-de-contribution)\n- [Directives de style de code](#directives-de-style-de-code)\n- [Quoi contribuer](#quoi-contribuer)\n- [Quoi NE PAS contribuer](#quoi-ne-pas-contribuer)\n- [Modles courants](#modles-courants)\n- [Ajouter de nouvelles fonctionnalits](#ajouter-de-nouvelles-fonctionnalits)\n- [Processus de revue de code](#processus-de-revue-de-code)\n\n---\n\n## Avant de commencer\n\n### Lectures obligatoires\n\nAvant de contribuer, veuillez lire ces documents dans l'ordre :\n\n1. **`/home/user/hemlock/docs/design/philosophy.md`** - Comprendre les principes fondamentaux de Hemlock\n2. **`/home/user/hemlock/docs/design/implementation.md`** - Apprendre la structure du code\n3. **`/home/user/hemlock/docs/contributing/testing.md`** - Comprendre les exigences de test\n4. **Ce document** - Apprendre les directives de contribution\n\n### Prrequis\n\n**Connaissances requises :**\n- Programmation C (pointeurs, gestion de la mmoire, structures)\n- Bases des compilateurs/interprteurs (lexing, parsing, AST)\n- Workflow Git et GitHub\n- Ligne de commande Unix/Linux\n\n**Outils requis :**\n- Compilateur GCC ou Clang\n- Systme de build Make\n- Contrle de version Git\n- Valgrind (pour la dtection des fuites mmoire)\n- diteur de texte basique ou IDE\n\n### Canaux de communication\n\n**O poser des questions :**\n- GitHub Issues - Rapports de bugs et demandes de fonctionnalits\n- GitHub Discussions - Questions gnrales et discussions de conception\n- Commentaires de Pull Request - Retours spcifiques sur le code\n\n---\n\n## Processus de contribution\n\n### 1. Trouver ou crer une issue\n\n**Avant d'crire du code :**\n- Vrifiez si une issue existe pour votre contribution\n- Sinon, crez-en une dcrivant ce que vous voulez faire\n- Attendez le retour des mainteneurs avant de commencer des changements importants\n- Les petites corrections de bugs peuvent sauter cette tape\n\n**Les bonnes descriptions d'issues incluent :**\n- nonc du problme (ce qui est cass ou manquant)\n- Solution propose (comment vous prvoyez de le corriger)\n- Exemples (extraits de code montrant le problme)\n- Justification (pourquoi ce changement s'aligne avec la philosophie de Hemlock)\n\n### 2. Fork et clone\n\n```bash\n# Forkez d'abord le dpt sur GitHub, puis :\ngit clone https://github.com/VOTRE_NOM_UTILISATEUR/hemlock.git\ncd hemlock\ngit checkout -b feature/nom-de-votre-fonctionnalite\n```\n\n### 3. Effectuez vos modifications\n\nSuivez ces directives :\n- crivez les tests d'abord (approche TDD)\n- Implmentez la fonctionnalit\n- Assurez-vous que tous les tests passent\n- Vrifiez les fuites mmoire\n- Mettez  jour la documentation\n\n### 4. Testez vos modifications\n\n```bash\n# Excutez la suite de tests complte\nmake test\n\n# Excutez une catgorie de test spcifique\n./tests/run_tests.sh tests/category/\n\n# Vrifiez les fuites mmoire\nvalgrind ./hemlock tests/your_test.hml\n\n# Compilez et testez\nmake clean && make && make test\n```\n\n### 5. Committez vos modifications\n\n**Bons messages de commit :**\n```\nAdd bitwise operators for integer types\n\n- Implement &, |, ^, <<, >>, ~ operators\n- Add type checking to ensure integer-only operations\n- Update operator precedence table\n- Add comprehensive tests for all operators\n\nCloses #42\n```\n\n**Format du message de commit :**\n- Premire ligne : Rsum bref (50 caractres max)\n- Ligne vide\n- Explication dtaille (retour  la ligne  72 caractres)\n- Rfrencer les numros d'issue\n\n### 6. Soumettez une Pull Request\n\n**Avant de soumettre :**\n- Rebasez sur la dernire branche main\n- Assurez-vous que tous les tests passent\n- Excutez valgrind pour vrifier les fuites\n- Mettez  jour CLAUDE.md si vous ajoutez des fonctionnalits visibles par l'utilisateur\n\n**La description de la pull request doit inclure :**\n- Quel problme cela rsout\n- Comment cela le rsout\n- Changements cassants (s'il y en a)\n- Exemples de nouvelle syntaxe ou comportement\n- Rsum de la couverture des tests\n\n---\n\n## Directives de style de code\n\n### Style de code C\n\n**Formatage :**\n```c\n// Indentation avec 4 espaces (pas de tabulations)\n// Style d'accolade K&R pour les fonctions\nvoid function_name(int arg1, char *arg2)\n{\n    if (condition) {\n        // Accolade sur la mme ligne pour les structures de contrle\n        do_something();\n    }\n}\n\n// Longueur de ligne : 100 caractres max\n// Utiliser des espaces autour des oprateurs\nint result = (a + b) * c;\n\n// Astrisque de pointeur avec le type\nchar *string;   // Bon\nchar* string;   //  viter\nchar * string;  //  viter\n```\n\n**Conventions de nommage :**\n```c\n// Fonctions : minuscules_avec_underscores\nvoid eval_expression(ASTNode *node);\n\n// Types : PascalCase\ntypedef struct Value Value;\ntypedef enum ValueType ValueType;\n\n// Constantes : MAJUSCULES_AVEC_UNDERSCORES\n#define MAX_BUFFER_SIZE 4096\n\n// Variables : minuscules_avec_underscores\nint item_count;\nValue *current_value;\n\n// Enums : TYPE_PREFIX_NOM\ntypedef enum {\n    TYPE_I32,\n    TYPE_STRING,\n    TYPE_OBJECT\n} ValueType;\n```\n\n**Commentaires :**\n```c\n// Commentaires sur une ligne pour les explications brves\n// Utiliser des phrases compltes avec majuscule initiale\n\n/*\n * Commentaires multi-lignes pour les explications plus longues\n * Aligner les astrisques pour la lisibilit\n */\n\n/**\n * Commentaire de documentation de fonction\n * @param node - Nud AST  valuer\n * @return Valeur value\n */\nValue eval_expr(ASTNode *node);\n```\n\n**Gestion des erreurs :**\n```c\n// Vrifier tous les appels malloc\nchar *buffer = malloc(size);\nif (!buffer) {\n    fprintf(stderr, \"Erreur : Mmoire insuffisante\\n\");\n    exit(1);\n}\n\n// Fournir du contexte dans les messages d'erreur\nif (file == NULL) {\n    fprintf(stderr, \"Erreur : Impossible d'ouvrir '%s' : %s\\n\",\n            filename, strerror(errno));\n    exit(1);\n}\n\n// Utiliser des messages d'erreur significatifs\n// Mauvais : \"Erreur : Valeur invalide\"\n// Bon : \"Erreur : Attendu un entier, obtenu une chane\"\n```\n\n**Gestion de la mmoire :**\n```c\n// Toujours librer ce que vous allouez\nValue *val = value_create_i32(42);\n// ... utiliser val\nvalue_free(val);\n\n// Mettre les pointeurs  NULL aprs libration (vite le double-free)\nfree(ptr);\nptr = NULL;\n\n// Documenter la proprit dans les commentaires\n// Cette fonction prend possession de 'value' et le librera\nvoid store_value(Value *value);\n\n// Cette fonction NE prend PAS possession (l'appelant doit librer)\nValue *get_value(void);\n```\n\n### Organisation du code\n\n**Structure des fichiers :**\n```c\n// 1. Includes (en-ttes systme d'abord, puis locaux)\n#include <stdio.h>\n#include <stdlib.h>\n#include \"internal.h\"\n#include \"values.h\"\n\n// 2. Constantes et macros\n#define INITIAL_CAPACITY 16\n\n// 3. Dfinitions de types\ntypedef struct Foo Foo;\n\n// 4. Dclarations de fonctions statiques (helpers internes)\nstatic void helper_function(void);\n\n// 5. Implmentations des fonctions publiques\nvoid public_api_function(void)\n{\n    // Implmentation\n}\n\n// 6. Implmentations des fonctions statiques\nstatic void helper_function(void)\n{\n    // Implmentation\n}\n```\n\n**Fichiers d'en-tte :**\n```c\n// Utiliser des gardes d'en-tte\n#ifndef HEMLOCK_MODULE_H\n#define HEMLOCK_MODULE_H\n\n// Dclarations anticipes\ntypedef struct Value Value;\n\n// API publique seulement dans les en-ttes\nvoid public_function(Value *val);\n\n// Documenter les paramtres et valeurs de retour\n/**\n * value un nud AST d'expression\n * @param node - Le nud AST  valuer\n * @param env - L'environnement courant\n * @return La valeur rsultante\n */\nValue *eval_expr(ASTNode *node, Environment *env);\n\n#endif // HEMLOCK_MODULE_H\n```\n\n---\n\n## Quoi contribuer\n\n### Contributions encourages\n\n**Corrections de bugs :**\n- Fuites mmoire\n- Erreurs de segmentation\n- Comportement incorrect\n- Amliorations des messages d'erreur\n\n**Documentation :**\n- Commentaires de code\n- Documentation d'API\n- Guides utilisateur et tutoriels\n- Programmes d'exemple\n- Documentation des cas de test\n\n**Tests :**\n- Cas de test supplmentaires pour les fonctionnalits existantes\n- Couverture des cas limites\n- Tests de rgression pour les bugs corrigs\n- Benchmarks de performance\n\n**Petits ajouts de fonctionnalits :**\n- Nouvelles fonctions intgres (si elles correspondent  la philosophie)\n- Mthodes de chane/tableau\n- Fonctions utilitaires\n- Amliorations de la gestion des erreurs\n\n**Amliorations de performance :**\n- Algorithmes plus rapides (sans changer la smantique)\n- Rduction de l'utilisation mmoire\n- Suite de benchmarks\n- Outils de profilage\n\n**Outillage :**\n- Coloration syntaxique pour les diteurs\n- Language Server Protocol (LSP)\n- Intgration du dbogueur\n- Amliorations du systme de build\n\n### Discutez d'abord\n\n**Fonctionnalits majeures :**\n- Nouvelles constructions du langage\n- Changements du systme de types\n- Ajouts de syntaxe\n- Primitives de concurrence\n\n**Comment discuter :**\n1. Ouvrez une issue ou discussion GitHub\n2. Dcrivez la fonctionnalit et la justification\n3. Montrez du code exemple\n4. Expliquez comment cela s'inscrit dans la philosophie de Hemlock\n5. Attendez le retour des mainteneurs\n6. Itrez sur la conception avant d'implmenter\n\n---\n\n## Quoi NE PAS contribuer\n\n### Contributions dconseilles\n\n**N'ajoutez pas de fonctionnalits qui :**\n- Cachent la complexit  l'utilisateur\n- Rendent le comportement implicite ou magique\n- Cassent la smantique ou la syntaxe existante\n- Ajoutent le ramasse-miettes ou la gestion automatique de la mmoire\n- Violent le principe \"explicite plutt qu'implicite\"\n\n**Exemples de contributions rejetes :**\n\n**1. Insertion automatique de point-virgule**\n```hemlock\n// MAUVAIS : Cela serait rejet\nlet x = 5  // Pas de point-virgule\nlet y = 10 // Pas de point-virgule\n```\nPourquoi : Rend la syntaxe ambigu, cache les erreurs\n\n**2. RAII/destructeurs**\n```hemlock\n// MAUVAIS : Cela serait rejet\nlet f = open(\"file.txt\");\n// Fichier automatiquement ferm  la fin de la porte\n```\nPourquoi : Cache quand les ressources sont libres, pas explicite\n\n**3. Coercition de type implicite qui perd des donnes**\n```hemlock\n// MAUVAIS : Cela serait rejet\nlet x: i32 = 3.14;  // Tronque silencieusement  3\n```\nPourquoi : La perte de donnes devrait tre explicite, pas silencieuse\n\n**4. Ramasse-miettes (garbage collection)**\n```c\n// MAUVAIS : Cela serait rejet\nvoid *gc_malloc(size_t size) {\n    // Suivre l'allocation pour un nettoyage automatique\n}\n```\nPourquoi : Cache la gestion de la mmoire, performances imprvisibles\n\n**5. Systme de macros complexe**\n```hemlock\n// MAUVAIS : Cela serait rejet\nmacro repeat($n, $block) {\n    for (let i = 0; i < $n; i++) $block\n}\n```\nPourquoi : Trop de magie, rend le code difficile  comprendre\n\n### Raisons courantes de rejet\n\n**\"C'est trop implicite\"**\n- Solution : Rendez le comportement explicite et documentez-le\n\n**\"Cela cache de la complexit\"**\n- Solution : Exposez la complexit mais rendez-la ergonomique\n\n**\"Cela casse le code existant\"**\n- Solution : Trouvez une alternative non cassante ou discutez du versioning\n\n**\"Cela ne correspond pas  la philosophie de Hemlock\"**\n- Solution : Relisez philosophy.md et reconsidrez l'approche\n\n---\n\n## Modles courants\n\n### Modle de gestion des erreurs\n\n```c\n// Utilisez ce modle pour les erreurs rcuprables dans le code Hemlock\nValue *divide(Value *a, Value *b)\n{\n    // Vrifier les prconditions\n    if (b->type != TYPE_I32) {\n        // Retourner une valeur d'erreur ou lever une exception\n        return create_error(\"Attendu un diviseur entier\");\n    }\n\n    if (b->i32_value == 0) {\n        return create_error(\"Division par zro\");\n    }\n\n    // Effectuer l'opration\n    return value_create_i32(a->i32_value / b->i32_value);\n}\n```\n\n### Modle de gestion de la mmoire\n\n```c\n// Modle : Allouer, utiliser, librer\nvoid process_data(void)\n{\n    // Allouer\n    Buffer *buf = create_buffer(1024);\n    char *str = malloc(256);\n\n    // Utiliser\n    if (buf && str) {\n        // ... faire le travail\n    }\n\n    // Librer (dans l'ordre inverse de l'allocation)\n    free(str);\n    free_buffer(buf);\n}\n```\n\n### Modle de cration de valeur\n\n```c\n// Crer des valeurs en utilisant des constructeurs\nValue *create_integer(int32_t n)\n{\n    Value *val = malloc(sizeof(Value));\n    if (!val) {\n        fprintf(stderr, \"Mmoire insuffisante\\n\");\n        exit(1);\n    }\n\n    val->type = TYPE_I32;\n    val->i32_value = n;\n    return val;\n}\n```\n\n### Modle de vrification de type\n\n```c\n// Vrifier les types avant les oprations\nValue *add_values(Value *a, Value *b)\n{\n    // Vrification de type\n    if (a->type != TYPE_I32 || b->type != TYPE_I32) {\n        return create_error(\"Incompatibilit de types\");\n    }\n\n    // Sr de procder\n    return value_create_i32(a->i32_value + b->i32_value);\n}\n```\n\n### Modle de construction de chane\n\n```c\n// Construire des chanes efficacement\nvoid build_error_message(char *buffer, size_t size, const char *detail)\n{\n    snprintf(buffer, size, \"Erreur : %s (ligne %d)\", detail, line_number);\n}\n```\n\n---\n\n## Ajouter de nouvelles fonctionnalits\n\n### Checklist d'ajout de fonctionnalit\n\nLors de l'ajout d'une nouvelle fonctionnalit, suivez ces tapes :\n\n#### 1. Phase de conception\n\n- [ ] Lire philosophy.md pour assurer l'alignement\n- [ ] Crer une issue GitHub dcrivant la fonctionnalit\n- [ ] Obtenir l'approbation du mainteneur pour la conception\n- [ ] crire la spcification (syntaxe, smantique, exemples)\n- [ ] Considrer les cas limites et les conditions d'erreur\n\n#### 2. Phase d'implmentation\n\n**Si vous ajoutez une construction du langage :**\n\n- [ ] Ajouter le type de token  `lexer.h` (si ncessaire)\n- [ ] Ajouter la rgle du lexer dans `lexer.c` (si ncessaire)\n- [ ] Ajouter le type de nud AST dans `ast.h`\n- [ ] Ajouter le constructeur AST dans `ast.c`\n- [ ] Ajouter la rgle du parser dans `parser.c`\n- [ ] Ajouter le comportement d'excution dans `runtime.c` ou le module appropri\n- [ ] Grer le nettoyage dans les fonctions de libration AST\n\n**Si vous ajoutez une fonction intgre :**\n\n- [ ] Ajouter l'implmentation de la fonction dans `builtins.c`\n- [ ] Enregistrer la fonction dans `register_builtins()`\n- [ ] Grer toutes les combinaisons de types de paramtres\n- [ ] Retourner les valeurs d'erreur appropries\n- [ ] Documenter les paramtres et le type de retour\n\n**Si vous ajoutez un type de valeur :**\n\n- [ ] Ajouter l'enum de type dans `values.h`\n- [ ] Ajouter le champ  l'union Value\n- [ ] Ajouter le constructeur dans `values.c`\n- [ ] Ajouter  `value_free()` pour le nettoyage\n- [ ] Ajouter  `value_copy()` pour la copie\n- [ ] Ajouter  `value_to_string()` pour l'affichage\n- [ ] Ajouter les rgles de promotion de type si numrique\n\n#### 3. Phase de test\n\n- [ ] crire les cas de test (voir testing.md)\n- [ ] Tester les cas de succs\n- [ ] Tester les cas d'erreur\n- [ ] Tester les cas limites\n- [ ] Excuter la suite de tests complte (`make test`)\n- [ ] Vrifier les fuites mmoire avec valgrind\n- [ ] Tester sur plusieurs plateformes (si possible)\n\n#### 4. Phase de documentation\n\n- [ ] Mettre  jour CLAUDE.md avec la documentation destine  l'utilisateur\n- [ ] Ajouter des commentaires de code expliquant l'implmentation\n- [ ] Crer des exemples dans `examples/`\n- [ ] Mettre  jour les fichiers docs/ pertinents\n- [ ] Documenter tout changement cassant\n\n#### 5. Phase de soumission\n\n- [ ] Nettoyer le code de dbogage et les commentaires\n- [ ] Vrifier la conformit au style de code\n- [ ] Rebaser sur la dernire branche main\n- [ ] Crer la pull request avec une description dtaille\n- [ ] Rpondre aux retours de la revue de code\n\n### Exemple : Ajouter un nouvel oprateur\n\nParcourons l'ajout de l'oprateur modulo `%` comme exemple :\n\n**1. Lexer (lexer.c) :**\n```c\n// Ajouter  l'instruction switch dans get_next_token()\ncase '%':\n    return create_token(TOKEN_PERCENT, \"%\", line);\n```\n\n**2. En-tte du lexer (lexer.h) :**\n```c\ntypedef enum {\n    // ... tokens existants\n    TOKEN_PERCENT,\n    // ...\n} TokenType;\n```\n\n**3. AST (ast.h) :**\n```c\ntypedef enum {\n    // ... oprateurs existants\n    OP_MOD,\n    // ...\n} BinaryOp;\n```\n\n**4. Parser (parser.c) :**\n```c\n// Ajouter  parse_multiplicative() ou au niveau de prcdence appropri\nif (match(TOKEN_PERCENT)) {\n    BinaryOp op = OP_MOD;\n    ASTNode *right = parse_unary();\n    left = create_binary_op_node(op, left, right);\n}\n```\n\n**5. Runtime (runtime.c) :**\n```c\n// Ajouter  eval_binary_op()\ncase OP_MOD:\n    // Vrification de type\n    if (left->type == TYPE_I32 && right->type == TYPE_I32) {\n        if (right->i32_value == 0) {\n            fprintf(stderr, \"Erreur : Modulo par zro\\n\");\n            exit(1);\n        }\n        return value_create_i32(left->i32_value % right->i32_value);\n    }\n    // ... grer les autres combinaisons de types\n    break;\n```\n\n**6. Tests (tests/operators/modulo.hml) :**\n```hemlock\n// Modulo basique\nprint(10 % 3);  // Attendu : 2\n\n// Modulo ngatif\nprint(-10 % 3); // Attendu : -1\n\n// Cas d'erreur (devrait chouer)\n// print(10 % 0);  // Division par zro\n```\n\n**7. Documentation (CLAUDE.md) :**\n```markdown\n### Oprateurs arithmtiques\n- `+` - Addition\n- `-` - Soustraction\n- `*` - Multiplication\n- `/` - Division\n- `%` - Modulo (reste)\n```\n\n---\n\n## Processus de revue de code\n\n### Ce que les reviewers recherchent\n\n**1. Correction**\n- Le code fait-il ce qu'il prtend ?\n- Les cas limites sont-ils grs ?\n- Y a-t-il des fuites mmoire ?\n- Les erreurs sont-elles gres correctement ?\n\n**2. Alignement avec la philosophie**\n- Est-ce que cela correspond aux principes de conception de Hemlock ?\n- Est-ce explicite ou implicite ?\n- Est-ce que cela cache de la complexit ?\n\n**3. Qualit du code**\n- Le code est-il lisible et maintenable ?\n- Les noms de variables sont-ils descriptifs ?\n- Les fonctions ont-elles une taille raisonnable ?\n- Y a-t-il une documentation adquate ?\n\n**4. Tests**\n- Y a-t-il suffisamment de cas de test ?\n- Les tests couvrent-ils les chemins de succs et d'chec ?\n- Les cas limites sont-ils tests ?\n\n**5. Documentation**\n- La documentation destine  l'utilisateur est-elle mise  jour ?\n- Les commentaires de code sont-ils clairs ?\n- Des exemples sont-ils fournis ?\n\n### Rpondre aux retours\n\n** faire :**\n- Remercier les reviewers pour leur temps\n- Poser des questions de clarification si vous ne comprenez pas\n- Expliquer votre raisonnement si vous n'tes pas d'accord\n- Effectuer les changements demands rapidement\n- Mettre  jour la description de la PR si la porte change\n\n** ne pas faire :**\n- Prendre les critiques personnellement\n- Argumenter dfensivement\n- Ignorer les retours\n- Force-push par-dessus les commentaires de revue (sauf si rebase)\n- Ajouter des changements non lis  la PR\n\n### Faire merger votre PR\n\n**Conditions pour le merge :**\n- [ ] Tous les tests passent\n- [ ] Pas de fuites mmoire (valgrind clean)\n- [ ] Approbation de la revue de code par un mainteneur\n- [ ] Documentation mise  jour\n- [ ] Suit les directives de style de code\n- [ ] S'aligne avec la philosophie de Hemlock\n\n**Dlais :**\n- Petites PR (corrections de bugs) : Gnralement reviewes en quelques jours\n- PR moyennes (nouvelles fonctionnalits) : Peut prendre 1-2 semaines\n- Grandes PR (changements majeurs) : Ncessite une discussion approfondie\n\n---\n\n## Ressources supplmentaires\n\n### Ressources d'apprentissage\n\n**Comprendre les interprteurs :**\n- \"Crafting Interpreters\" par Robert Nystrom\n- \"Writing An Interpreter In Go\" par Thorsten Ball\n- \"Modern Compiler Implementation in C\" par Andrew Appel\n\n**Programmation C :**\n- \"The C Programming Language\" par K&R\n- \"Expert C Programming\" par Peter van der Linden\n- \"C Interfaces and Implementations\" par David Hanson\n\n**Gestion de la mmoire :**\n- Documentation Valgrind\n- \"Understanding and Using C Pointers\" par Richard Reese\n\n### Commandes utiles\n\n```bash\n# Compiler avec symboles de dbogage\nmake clean && make CFLAGS=\"-g -O0\"\n\n# Excuter avec valgrind\nvalgrind --leak-check=full ./hemlock script.hml\n\n# Excuter une catgorie de test spcifique\n./tests/run_tests.sh tests/strings/\n\n# Gnrer un fichier de tags pour la navigation de code\nctags -R .\n\n# Trouver tous les TODO et FIXME\ngrep -rn \"TODO\\|FIXME\" src/ include/\n```\n\n---\n\n## Questions ?\n\nSi vous avez des questions sur la contribution :\n\n1. Consultez la documentation dans `docs/`\n2. Recherchez dans les issues GitHub existantes\n3. Demandez dans GitHub Discussions\n4. Ouvrez une nouvelle issue avec votre question\n\n**Merci de contribuer  Hemlock !**\n"}, "Contribuer -> Tests": {"id": "contributing-testing", "content": "# Guide de test pour Hemlock\n\nCe guide explique la philosophie de test de Hemlock, comment crire des tests et comment excuter la suite de tests.\n\n---\n\n## Table des matires\n\n- [Philosophie de test](#philosophie-de-test)\n- [Structure de la suite de tests](#structure-de-la-suite-de-tests)\n- [Excuter les tests](#excuter-les-tests)\n- [crire des tests](#crire-des-tests)\n- [Catgories de tests](#catgories-de-tests)\n- [Tests de fuites mmoire](#tests-de-fuites-mmoire)\n- [Intgration continue](#intgration-continue)\n- [Bonnes pratiques](#bonnes-pratiques)\n\n---\n\n## Philosophie de test\n\n### Principes fondamentaux\n\n**1. Dveloppement pilot par les tests (TDD)**\n\ncrivez les tests **avant** d'implmenter les fonctionnalits :\n\n```\n1. crire un test qui choue\n2. Implmenter la fonctionnalit\n3. Excuter le test (devrait passer)\n4. Refactoriser si ncessaire\n5. Rpter\n```\n\n**Avantages :**\n- Assure que les fonctionnalits fonctionnent rellement\n- Prvient les rgressions\n- Documente le comportement attendu\n- Rend le refactoring plus sr\n\n**2. Couverture complte**\n\nTestez les cas de succs et d'chec :\n\n```hemlock\n// Cas de succs\nlet x: u8 = 255;  // Devrait fonctionner\n\n// Cas d'chec\nlet y: u8 = 256;  // Devrait gnrer une erreur\n```\n\n**3. Testez tt et souvent**\n\nExcutez les tests :\n- Avant de committer du code\n- Aprs avoir fait des modifications\n- Avant de soumettre des pull requests\n- Pendant la revue de code\n\n**Rgle :** Tous les tests doivent passer avant le merge.\n\n### Quoi tester\n\n**Toujours tester :**\n- La fonctionnalit de base (chemin heureux)\n- Les conditions d'erreur (chemin malheureux)\n- Les cas limites (conditions aux frontires)\n- La vrification et les conversions de types\n- La gestion de la mmoire (pas de fuites)\n- La concurrence et les conditions de course\n\n**Exemple de couverture de test :**\n```hemlock\n// Fonctionnalit : String.substr(start, length)\n\n// Chemin heureux\nprint(\"hello\".substr(0, 5));  // \"hello\"\n\n// Cas limites\nprint(\"hello\".substr(0, 0));  // \"\" (vide)\nprint(\"hello\".substr(5, 0));  // \"\" ( la fin)\nprint(\"hello\".substr(2, 100)); // \"llo\" (au-del de la fin)\n\n// Cas d'erreur\n// \"hello\".substr(-1, 5);  // Erreur : index ngatif\n// \"hello\".substr(0, -1);  // Erreur : longueur ngative\n```\n\n---\n\n## Structure de la suite de tests\n\n### Organisation des rpertoires\n\n```\ntests/\n run_tests.sh          # Script principal d'excution des tests\n primitives/           # Tests du systme de types\n    integers.hml\n    floats.hml\n    booleans.hml\n    i64.hml\n    u64.hml\n conversions/          # Tests de conversion de types\n    int_to_float.hml\n    promotion.hml\n    rune_conversions.hml\n memory/               # Tests de pointeur/buffer\n    alloc.hml\n    buffer.hml\n    memcpy.hml\n strings/              # Tests d'oprations sur les chanes\n    concat.hml\n    methods.hml\n    utf8.hml\n    runes.hml\n control/              # Tests de flux de contrle\n    if.hml\n    switch.hml\n    while.hml\n functions/            # Tests de fonctions et closures\n    basics.hml\n    closures.hml\n    recursion.hml\n objects/              # Tests d'objets\n    literals.hml\n    methods.hml\n    duck_typing.hml\n    serialization.hml\n arrays/               # Tests d'oprations sur les tableaux\n    basics.hml\n    methods.hml\n    slicing.hml\n loops/                # Tests de boucles\n    for.hml\n    while.hml\n    break.hml\n    continue.hml\n exceptions/           # Tests de gestion des erreurs\n    try_catch.hml\n    finally.hml\n    throw.hml\n io/                   # Tests d'E/S de fichiers\n    file_object.hml\n    read_write.hml\n    seek.hml\n async/                # Tests de concurrence\n    spawn_join.hml\n    channels.hml\n    exceptions.hml\n ffi/                  # Tests FFI\n    basic_call.hml\n    types.hml\n    dlopen.hml\n signals/              # Tests de gestion des signaux\n    basic.hml\n    handlers.hml\n    raise.hml\n args/                 # Tests d'arguments en ligne de commande\n     basic.hml\n```\n\n### Nommage des fichiers de test\n\n**Conventions :**\n- Utiliser des noms descriptifs : `method_chaining.hml` pas `test1.hml`\n- Grouper les tests lis : `string_substr.hml`, `string_slice.hml`\n- Un domaine fonctionnel par fichier\n- Garder les fichiers cibls et petits\n\n---\n\n## Excuter les tests\n\n### Excuter tous les tests\n\n```bash\n# Depuis le rpertoire racine de hemlock\nmake test\n\n# Ou directement\n./tests/run_tests.sh\n```\n\n**Sortie :**\n```\nRunning tests in tests/primitives/...\n   integers.hml\n   floats.hml\n   booleans.hml\n\nRunning tests in tests/strings/...\n   concat.hml\n   methods.hml\n\n...\n\nTotal: 251 tests\nPassed: 251\nFailed: 0\n```\n\n### Excuter une catgorie spcifique\n\n```bash\n# Excuter seulement les tests de chanes\n./tests/run_tests.sh tests/strings/\n\n# Excuter un seul fichier de test\n./tests/run_tests.sh tests/strings/concat.hml\n\n# Excuter plusieurs catgories\n./tests/run_tests.sh tests/strings/ tests/arrays/\n```\n\n### Excuter avec Valgrind (vrification des fuites mmoire)\n\n```bash\n# Vrifier un seul test pour les fuites\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\n\n# Vrifier tous les tests (lent !)\nfor test in tests/**/*.hml; do\n    echo \"Test de $test\"\n    valgrind --leak-check=full --error-exitcode=1 ./hemlock \"$test\"\ndone\n```\n\n### Dboguer les tests chous\n\n```bash\n# Excuter avec sortie dtaille\n./hemlock tests/failing_test.hml\n\n# Excuter avec gdb\ngdb --args ./hemlock tests/failing_test.hml\n(gdb) run\n(gdb) backtrace  # si a plante\n```\n\n---\n\n## crire des tests\n\n### Format des fichiers de test\n\nLes fichiers de test sont simplement des programmes Hemlock avec une sortie attendue :\n\n**Exemple : tests/primitives/integers.hml**\n```hemlock\n// Test des littraux entiers basiques\nlet x = 42;\nprint(x);  // Attendu : 42\n\nlet y: i32 = 100;\nprint(y);  // Attendu : 100\n\n// Test de l'arithmtique\nlet sum = x + y;\nprint(sum);  // Attendu : 142\n\n// Test de l'infrence de type\nlet small = 10;\nprint(typeof(small));  // Attendu : i32\n\nlet large = 5000000000;\nprint(typeof(large));  // Attendu : i64\n```\n\n**Comment fonctionnent les tests :**\n1. Le lanceur de tests excute le fichier .hml\n2. Capture la sortie stdout\n3. Compare avec la sortie attendue (depuis les commentaires ou un fichier .out spar)\n4. Rapporte succs/chec\n\n### Mthodes pour la sortie attendue\n\n**Mthode 1 : Commentaires en ligne (recommande pour les tests simples)**\n\n```hemlock\nprint(\"hello\");  // Attendu : hello\nprint(42);       // Attendu : 42\n```\n\nLe lanceur de tests analyse les commentaires `// Attendu : ...`.\n\n**Mthode 2 : Fichier .out spar**\n\nCrez `nom_test.hml.out` avec la sortie attendue :\n\n**nom_test.hml :**\n```hemlock\nprint(\"ligne 1\");\nprint(\"ligne 2\");\nprint(\"ligne 3\");\n```\n\n**nom_test.hml.out :**\n```\nligne 1\nligne 2\nligne 3\n```\n\n### Tester les cas d'erreur\n\nLes tests d'erreur devraient faire sortir le programme avec un statut non-zro :\n\n**Exemple : tests/primitives/range_error.hml**\n```hemlock\n// Cela devrait chouer avec une erreur de type\nlet x: u8 = 256;  // Hors plage pour u8\n```\n\n**Comportement attendu :**\n- Le programme sort avec un statut non-zro\n- Affiche un message d'erreur sur stderr\n\n**Gestion par le lanceur de tests :**\n- Les tests attendant des erreurs devraient tre dans des fichiers spars\n- Utiliser la convention de nommage : `*_error.hml` ou `*_fail.hml`\n- Documenter l'erreur attendue dans les commentaires\n\n### Tester les cas de succs\n\n**Exemple : tests/strings/methods.hml**\n```hemlock\n// Test de substr\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);\nprint(sub);  // Attendu : world\n\n// Test de find\nlet pos = s.find(\"world\");\nprint(pos);  // Attendu : 6\n\n// Test de contains\nlet has = s.contains(\"lo\");\nprint(has);  // Attendu : true\n\n// Test de trim\nlet padded = \"  hello  \";\nlet trimmed = padded.trim();\nprint(trimmed);  // Attendu : hello\n```\n\n### Tester les cas limites\n\n**Exemple : tests/arrays/edge_cases.hml**\n```hemlock\n// Tableau vide\nlet empty = [];\nprint(empty.length);  // Attendu : 0\n\n// lment unique\nlet single = [42];\nprint(single[0]);  // Attendu : 42\n\n// Index ngatif (devrait gnrer une erreur dans un fichier de test spar)\n// print(single[-1]);  // Erreur\n\n// Index au-del de la fin (devrait gnrer une erreur)\n// print(single[100]);  // Erreur\n\n// Conditions aux frontires\nlet arr = [1, 2, 3];\nprint(arr.slice(0, 0));  // Attendu : [] (vide)\nprint(arr.slice(3, 3));  // Attendu : [] (vide)\nprint(arr.slice(1, 2));  // Attendu : [2]\n```\n\n### Tester le systme de types\n\n**Exemple : tests/conversions/promotion.hml**\n```hemlock\n// Test de la promotion de type dans les oprations binaires\n\n// i32 + i64 -> i64\nlet a: i32 = 10;\nlet b: i64 = 20;\nlet c = a + b;\nprint(typeof(c));  // Attendu : i64\n\n// i32 + f32 -> f32\nlet d: i32 = 10;\nlet e: f32 = 3.14;\nlet f = d + e;\nprint(typeof(f));  // Attendu : f32\n\n// u8 + i32 -> i32\nlet g: u8 = 5;\nlet h: i32 = 10;\nlet i = g + h;\nprint(typeof(i));  // Attendu : i32\n```\n\n### Tester la concurrence\n\n**Exemple : tests/async/basic.hml**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Lancer des tches\nlet t1 = spawn(compute, 10);\nlet t2 = spawn(compute, 20);\n\n// Joindre et afficher les rsultats\nlet r1 = join(t1);\nlet r2 = join(t2);\nprint(r1);  // Attendu : 45\nprint(r2);  // Attendu : 190\n```\n\n### Tester les exceptions\n\n**Exemple : tests/exceptions/try_catch.hml**\n```hemlock\n// Test du try/catch basique\ntry {\n    throw \"message d'erreur\";\n} catch (e) {\n    print(\"Captur : \" + e);  // Attendu : Captur : message d'erreur\n}\n\n// Test de finally\nlet executed = false;\ntry {\n    print(\"try\");  // Attendu : try\n} finally {\n    executed = true;\n    print(\"finally\");  // Attendu : finally\n}\n\n// Test de la propagation des exceptions\nfn risky(): i32 {\n    throw \"chec\";\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(e);  // Attendu : chec\n}\n```\n\n---\n\n## Catgories de tests\n\n### Tests des primitives\n\n**Quoi tester :**\n- Types entiers (i8, i16, i32, i64, u8, u16, u32, u64)\n- Types flottants (f32, f64)\n- Type boolen\n- Type chane\n- Type rune\n- Type null\n\n**Exemples de domaines :**\n- Syntaxe des littraux\n- Infrence de type\n- Vrification de plage\n- Comportement de dbordement\n- Annotations de type\n\n### Tests de conversion\n\n**Quoi tester :**\n- Promotion de type implicite\n- Conversion de type explicite\n- Conversions avec perte (devraient gnrer une erreur)\n- Promotion de type dans les oprations\n- Comparaisons inter-types\n\n### Tests mmoire\n\n**Quoi tester :**\n- Exactitude de alloc/free\n- Cration et accs aux buffers\n- Vrification des limites sur les buffers\n- memset, memcpy, realloc\n- Dtection des fuites mmoire (valgrind)\n\n### Tests de chanes\n\n**Quoi tester :**\n- Concatnation\n- Les 18 mthodes de chane\n- Gestion UTF-8\n- Indexation par rune\n- Concatnation chane + rune\n- Cas limites (chanes vides, caractre unique, etc.)\n\n### Tests de flux de contrle\n\n**Quoi tester :**\n- if/else/else if\n- Boucles while\n- Boucles for\n- Instructions switch\n- break/continue\n- Instructions return\n\n### Tests de fonctions\n\n**Quoi tester :**\n- Dfinition et appel de fonctions\n- Passage de paramtres\n- Valeurs de retour\n- Rcursion\n- Closures et capture\n- Fonctions de premire classe\n- Fonctions anonymes\n\n### Tests d'objets\n\n**Quoi tester :**\n- Littraux d'objets\n- Accs et affectation de champs\n- Mthodes et liaison de self\n- Duck typing\n- Champs optionnels\n- Srialisation/dsrialisation JSON\n- Dtection des rfrences circulaires\n\n### Tests de tableaux\n\n**Quoi tester :**\n- Cration de tableaux\n- Indexation et affectation\n- Les 15 mthodes de tableau\n- Types mixtes\n- Redimensionnement dynamique\n- Cas limites (vide, lment unique)\n\n### Tests d'exceptions\n\n**Quoi tester :**\n- try/catch/finally\n- Instruction throw\n- Propagation des exceptions\n- try/catch imbriqus\n- Return dans try/catch/finally\n- Exceptions non captures\n\n### Tests d'E/S\n\n**Quoi tester :**\n- Modes d'ouverture de fichiers\n- Oprations de lecture/criture\n- Seek/tell\n- Proprits de fichier\n- Gestion des erreurs (fichiers manquants, etc.)\n- Nettoyage des ressources\n\n### Tests async\n\n**Quoi tester :**\n- spawn/join/detach\n- Envoi/rception sur canal\n- Propagation des exceptions dans les tches\n- Tches concurrentes multiples\n- Comportement de blocage des canaux\n\n### Tests FFI\n\n**Quoi tester :**\n- dlopen/dlclose\n- dlsym\n- dlcall avec diffrents types\n- Conversion de types\n- Gestion des erreurs\n\n---\n\n## Tests de fuites mmoire\n\n### Utilisation de Valgrind\n\n**Utilisation basique :**\n```bash\nvalgrind --leak-check=full ./hemlock test.hml\n```\n\n**Exemple de sortie (pas de fuites) :**\n```\n==12345== HEAP SUMMARY:\n==12345==     in use at exit: 0 bytes in 0 blocks\n==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated\n==12345==\n==12345== All heap blocks were freed -- no leaks are possible\n```\n\n**Exemple de sortie (avec fuite) :**\n```\n==12345== LEAK SUMMARY:\n==12345==    definitely lost: 64 bytes in 1 blocks\n==12345==    indirectly lost: 0 bytes in 0 blocks\n==12345==      possibly lost: 0 bytes in 0 blocks\n==12345==    still reachable: 0 bytes in 0 blocks\n==12345==         suppressed: 0 bytes in 0 blocks\n```\n\n### Sources courantes de fuites\n\n**1. Appels free() manquants :**\n```c\n// MAUVAIS\nchar *str = malloc(100);\n// ... utiliser str\n// Oubli de librer !\n\n// BON\nchar *str = malloc(100);\n// ... utiliser str\nfree(str);\n```\n\n**2. Pointeurs perdus :**\n```c\n// MAUVAIS\nchar *ptr = malloc(100);\nptr = malloc(200);  // Rfrence  la premire allocation perdue !\n\n// BON\nchar *ptr = malloc(100);\nfree(ptr);\nptr = malloc(200);\n```\n\n**3. Chemins d'exception :**\n```c\n// MAUVAIS\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        return;  // Fuite !\n    }\n    free(data);\n}\n\n// BON\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        free(data);\n        return;\n    }\n    free(data);\n}\n```\n\n### Fuites acceptables connues\n\nQuelques petites \"fuites\" sont des allocations de dmarrage intentionnelles :\n\n**Fonctions intgres globales :**\n```hemlock\n// Les fonctions intgres, types FFI et constantes sont allous au dmarrage\n// et non librs  la sortie (typiquement ~200 octets)\n```\n\nCe ne sont pas de vraies fuites - ce sont des allocations uniques qui persistent pendant la dure de vie du programme et sont nettoyes par l'OS  la sortie.\n\n---\n\n## Intgration continue\n\n### GitHub Actions (futur)\n\nUne fois la CI configure, tous les tests s'excuteront automatiquement sur :\n- Push sur la branche main\n- Cration/mise  jour de pull request\n- Excutions planifies quotidiennes\n\n**Workflow CI :**\n1. Compiler Hemlock\n2. Excuter la suite de tests\n3. Vrifier les fuites mmoire (valgrind)\n4. Rapporter les rsultats sur la PR\n\n### Vrifications pr-commit\n\nAvant de committer, excutez :\n\n```bash\n# Compiler  neuf\nmake clean && make\n\n# Excuter tous les tests\nmake test\n\n# Vrifier quelques tests pour les fuites\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\nvalgrind --leak-check=full ./hemlock tests/strings/concat.hml\n```\n\n---\n\n## Bonnes pratiques\n\n###  faire\n\n**crivez les tests d'abord (TDD)**\n```bash\n1. Crer tests/feature/new_feature.hml\n2. Implmenter la fonctionnalit dans src/\n3. Excuter les tests jusqu' ce qu'ils passent\n```\n\n**Testez les succs et les checs**\n```hemlock\n// Succs : tests/feature/success.hml\nlet result = do_thing();\nprint(result);  // Attendu : valeur attendue\n\n// chec : tests/feature/failure.hml\ndo_invalid_thing();  // Devrait gnrer une erreur\n```\n\n**Utilisez des noms de tests descriptifs**\n```\nBon : tests/strings/substr_utf8_boundary.hml\nMauvais : tests/test1.hml\n```\n\n**Gardez les tests cibls**\n- Un domaine fonctionnel par fichier\n- Configuration et assertions claires\n- Code minimal\n\n**Ajoutez des commentaires expliquant les tests complexes**\n```hemlock\n// Test que la closure capture la variable externe par rfrence\nfn outer() {\n    let x = 10;\n    let f = fn() { return x; };\n    x = 20;  // Modifier aprs la cration de la closure\n    return f();  // Devrait retourner 20, pas 10\n}\n```\n\n**Testez les cas limites**\n- Entres vides\n- Valeurs null\n- Valeurs aux frontires (min/max)\n- Grandes entres\n- Valeurs ngatives\n\n###  ne pas faire\n\n**Ne sautez pas les tests**\n- Tous les tests doivent passer avant le merge\n- Ne commentez pas les tests qui chouent\n- Corrigez le bug ou supprimez la fonctionnalit\n\n**N'crivez pas de tests qui dpendent les uns des autres**\n```hemlock\n// MAUVAIS : test2.hml dpend de la sortie de test1.hml\n// Les tests devraient tre indpendants\n```\n\n**N'utilisez pas de valeurs alatoires dans les tests**\n```hemlock\n// MAUVAIS : Non-dterministe\nlet x = random();\nprint(x);  // Impossible de prdire la sortie\n\n// BON : Dterministe\nlet x = 42;\nprint(x);  // Attendu : 42\n```\n\n**Ne testez pas les dtails d'implmentation**\n```hemlock\n// MAUVAIS : Tester la structure interne\nlet obj = { x: 10 };\n// Ne pas vrifier l'ordre interne des champs, la capacit, etc.\n\n// BON : Tester le comportement\nprint(obj.x);  // Attendu : 10\n```\n\n**N'ignorez pas les fuites mmoire**\n- Tous les tests devraient tre propres selon valgrind\n- Documentez les fuites connues/acceptables\n- Corrigez les fuites avant le merge\n\n### Maintenance des tests\n\n**Quand mettre  jour les tests :**\n- Le comportement de la fonctionnalit change\n- Les corrections de bugs ncessitent de nouveaux cas de test\n- Des cas limites sont dcouverts\n- Amliorations de performance\n\n**Quand supprimer des tests :**\n- Fonctionnalit supprime du langage\n- Le test duplique une couverture existante\n- Le test tait incorrect\n\n**Refactorisation des tests :**\n- Grouper les tests lis ensemble\n- Extraire le code de configuration commun\n- Utiliser un nommage cohrent\n- Garder les tests simples et lisibles\n\n---\n\n## Exemple de session de test\n\nVoici un exemple complet d'ajout d'une fonctionnalit avec des tests :\n\n### Fonctionnalit : Ajouter la mthode `array.first()`\n\n**1. crire le test d'abord :**\n\n```bash\n# Crer le fichier de test\ncat > tests/arrays/first_method.hml << 'EOF'\n// Test de la mthode array.first()\n\n// Cas basique\nlet arr = [1, 2, 3];\nprint(arr.first());  // Attendu : 1\n\n// lment unique\nlet single = [42];\nprint(single.first());  // Attendu : 42\n\n// Tableau vide (devrait gnrer une erreur - fichier de test spar)\n// let empty = [];\n// print(empty.first());  // Erreur\nEOF\n```\n\n**2. Excuter le test (devrait chouer) :**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n# Erreur : Mthode 'first' non trouve sur array\n```\n\n**3. Implmenter la fonctionnalit :**\n\nModifier `src/interpreter/builtins.c` :\n\n```c\n// Ajouter la mthode array_first\nValue *array_first(Value *self, Value **args, int arg_count)\n{\n    if (self->array_value->length == 0) {\n        fprintf(stderr, \"Erreur : Impossible d'obtenir le premier lment d'un tableau vide\\n\");\n        exit(1);\n    }\n\n    return value_copy(&self->array_value->elements[0]);\n}\n\n// Enregistrer dans la table des mthodes de tableau\n// ... ajouter  l'enregistrement des mthodes de tableau\n```\n\n**4. Excuter le test (devrait passer) :**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n1\n42\n# Succs !\n```\n\n**5. Vrifier les fuites mmoire :**\n\n```bash\nvalgrind --leak-check=full ./hemlock tests/arrays/first_method.hml\n# All heap blocks were freed -- no leaks are possible\n```\n\n**6. Excuter la suite de tests complte :**\n\n```bash\nmake test\n# Total : 252 tests (251 + nouveau)\n# Passs : 252\n# chous : 0\n```\n\n**7. Committer :**\n\n```bash\ngit add tests/arrays/first_method.hml src/interpreter/builtins.c\ngit commit -m \"Add array.first() method with tests\"\n```\n\n---\n\n## Rsum\n\n**Rappelez-vous :**\n- crivez les tests d'abord (TDD)\n- Testez les cas de succs et d'chec\n- Excutez tous les tests avant de committer\n- Vrifiez les fuites mmoire\n- Documentez les problmes connus\n- Gardez les tests simples et cibls\n\n**La qualit des tests est aussi importante que la qualit du code !**\n"}, "hpm : Prise en Main -> Configuration du Projet": {"id": "hpm-project-setup", "content": "# Configuration du projet\n\nGuide complet pour configurer des projets Hemlock avec hpm.\n\n## Demarrer un nouveau projet\n\n### Configuration de base\n\nCreer un nouveau projet a partir de zero :\n\n```bash\n# Creer le repertoire du projet\nmkdir my-project\ncd my-project\n\n# Initialiser package.json\nhpm init\n\n# Creer la structure des repertoires\nmkdir -p src test\n```\n\n### Modeles de projets\n\nVoici des structures de projets courantes pour differents cas d'utilisation :\n\n#### Paquet bibliotheque\n\nPour les bibliotheques reutilisables :\n\n```\nmy-library/\n package.json\n README.md\n LICENSE\n src/\n    index.hml          # Entree principale, exporte l'API publique\n    core.hml           # Fonctionnalites principales\n    utils.hml          # Fonctions utilitaires\n    types.hml          # Definitions de types\n test/\n     framework.hml      # Framework de test\n     run.hml            # Lanceur de tests\n     test_core.hml      # Tests\n```\n\n**package.json :**\n\n```json\n{\n  \"name\": \"yourusername/my-library\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A reusable Hemlock library\",\n  \"main\": \"src/index.hml\",\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {}\n}\n```\n\n#### Application\n\nPour les applications autonomes :\n\n```\nmy-app/\n package.json\n README.md\n src/\n    main.hml           # Point d'entree de l'application\n    config.hml         # Configuration\n    commands/          # Commandes CLI\n       index.hml\n       run.hml\n    lib/               # Bibliotheques internes\n        utils.hml\n test/\n    run.hml\n data/                  # Fichiers de donnees\n```\n\n**package.json :**\n\n```json\n{\n  \"name\": \"yourusername/my-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Hemlock application\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {}\n}\n```\n\n#### Application web\n\nPour les serveurs web :\n\n```\nmy-web-app/\n package.json\n README.md\n src/\n    main.hml           # Point d'entree du serveur\n    routes/            # Gestionnaires de routes\n       index.hml\n       api.hml\n       auth.hml\n    middleware/        # Middleware\n       index.hml\n       auth.hml\n    models/            # Modeles de donnees\n       user.hml\n    services/          # Logique metier\n        user.hml\n test/\n    run.hml\n static/                # Fichiers statiques\n    css/\n    js/\n views/                 # Templates\n     index.hml\n```\n\n**package.json :**\n\n```json\n{\n  \"name\": \"yourusername/my-web-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Hemlock web application\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\",\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  }\n}\n```\n\n## Le fichier package.json\n\n### Champs obligatoires\n\n```json\n{\n  \"name\": \"owner/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n### Tous les champs\n\n```json\n{\n  \"name\": \"yourusername/my-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Package description\",\n  \"author\": \"Your Name <you@example.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/yourusername/my-package\",\n  \"homepage\": \"https://yourusername.github.io/my-package\",\n  \"bugs\": \"https://github.com/yourusername/my-package/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"utility\", \"parser\"],\n  \"dependencies\": {\n    \"owner/package\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"owner/test-lib\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n### Reference des champs\n\n| Champ | Type | Description |\n|-------|------|-------------|\n| `name` | string | Nom du paquet au format owner/repo (obligatoire) |\n| `version` | string | Version semantique (obligatoire) |\n| `description` | string | Description courte |\n| `author` | string | Nom et email de l'auteur |\n| `license` | string | Identifiant de licence (MIT, Apache-2.0, etc.) |\n| `repository` | string | URL du depot |\n| `homepage` | string | Page d'accueil du projet |\n| `bugs` | string | URL du gestionnaire de tickets |\n| `main` | string | Fichier point d'entree (defaut : src/index.hml) |\n| `keywords` | array | Mots-cles de recherche |\n| `dependencies` | object | Dependances d'execution |\n| `devDependencies` | object | Dependances de developpement |\n| `scripts` | object | Scripts nommes |\n| `files` | array | Fichiers a inclure lors de la publication |\n| `native` | object | Exigences de bibliotheques natives |\n\n## Le fichier package-lock.json\n\nLe fichier de verrouillage est genere automatiquement et doit etre commite dans le controle de version. Il garantit des installations reproductibles.\n\n```json\n{\n  \"lockVersion\": 1,\n  \"hemlock\": \"1.0.0\",\n  \"dependencies\": {\n    \"hemlang/sprout\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz\",\n      \"integrity\": \"sha256-abc123...\",\n      \"dependencies\": {\n        \"hemlang/router\": \"^1.5.0\"\n      }\n    },\n    \"hemlang/router\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://github.com/hemlang/router/archive/v1.5.0.tar.gz\",\n      \"integrity\": \"sha256-def456...\",\n      \"dependencies\": {}\n    }\n  }\n}\n```\n\n### Bonnes pratiques pour le fichier de verrouillage\n\n- **Commitez** package-lock.json dans le controle de version\n- **Ne modifiez pas** manuellement - il est genere automatiquement\n- **Executez `hpm install`** apres avoir tire des modifications\n- **Supprimez et regenerez** si corrompu :\n  ```bash\n  rm package-lock.json\n  hpm install\n  ```\n\n## Le repertoire hem_modules\n\nLes paquets installes sont stockes dans `hem_modules/` :\n\n```\nhem_modules/\n hemlang/\n    sprout/\n       package.json\n       src/\n    router/\n        package.json\n        src/\n alice/\n     http-client/\n         package.json\n         src/\n```\n\n### Bonnes pratiques pour hem_modules\n\n- **Ajoutez a .gitignore** - ne commitez pas les dependances\n- **Ne modifiez pas** - les modifications seront ecrasees\n- **Supprimez pour reinstaller proprement** :\n  ```bash\n  rm -rf hem_modules\n  hpm install\n  ```\n\n## .gitignore\n\nFichier .gitignore recommande pour les projets Hemlock :\n\n```gitignore\n# Dependances\nhem_modules/\n\n# Sortie de compilation\ndist/\n*.hmlc\n\n# Fichiers IDE\n.idea/\n.vscode/\n*.swp\n*.swo\n\n# Fichiers OS\n.DS_Store\nThumbs.db\n\n# Logs\n*.log\nlogs/\n\n# Environnement\n.env\n.env.local\n\n# Couverture de tests\ncoverage/\n```\n\n## Travailler avec les dependances\n\n### Ajouter des dependances\n\n```bash\n# Ajouter une dependance d'execution\nhpm install hemlang/json\n\n# Ajouter avec une contrainte de version\nhpm install hemlang/sprout@^2.0.0\n\n# Ajouter une dependance de developpement\nhpm install hemlang/test-utils --dev\n```\n\n### Importer des dependances\n\n```hemlock\n// Importer depuis un paquet (utilise l'entree \"main\")\nimport { parse, stringify } from \"hemlang/json\";\n\n// Importer depuis un sous-chemin\nimport { Router } from \"hemlang/sprout/router\";\n\n// Importer la bibliotheque standard\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile, writeFile } from \"@stdlib/fs\";\n```\n\n### Resolution des imports\n\nhpm resout les imports dans cet ordre :\n\n1. **Bibliotheque standard** : les imports `@stdlib/*` chargent les modules integres\n2. **Racine du paquet** : `owner/repo` utilise le champ `main`\n3. **Sous-chemin** : `owner/repo/path` verifie :\n   - `hem_modules/owner/repo/path.hml`\n   - `hem_modules/owner/repo/path/index.hml`\n   - `hem_modules/owner/repo/src/path.hml`\n   - `hem_modules/owner/repo/src/path/index.hml`\n\n## Scripts\n\n### Definir des scripts\n\nAjoutez des scripts a package.json :\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n### Executer des scripts\n\n```bash\nhpm run start\nhpm run dev\nhpm run build\n\n# Raccourci pour test\nhpm test\n\n# Passer des arguments\nhpm run test -- --verbose --filter=unit\n```\n\n### Conventions de nommage des scripts\n\n| Script | Objectif |\n|--------|----------|\n| `start` | Executer l'application |\n| `dev` | Executer en mode developpement |\n| `test` | Executer tous les tests |\n| `build` | Compiler pour la production |\n| `clean` | Supprimer les fichiers generes |\n| `lint` | Verifier le style du code |\n| `format` | Formater le code |\n\n## Flux de travail de developpement\n\n### Configuration initiale\n\n```bash\n# Cloner le projet\ngit clone https://github.com/yourusername/my-project.git\ncd my-project\n\n# Installer les dependances\nhpm install\n\n# Executer les tests\nhpm test\n\n# Demarrer le developpement\nhpm run dev\n```\n\n### Flux de travail quotidien\n\n```bash\n# Tirer les dernieres modifications\ngit pull\n\n# Installer les nouvelles dependances\nhpm install\n\n# Faire des modifications...\n\n# Executer les tests\nhpm test\n\n# Commiter\ngit add .\ngit commit -m \"Add feature\"\ngit push\n```\n\n### Ajouter une nouvelle fonctionnalite\n\n```bash\n# Creer une branche de fonctionnalite\ngit checkout -b feature/new-feature\n\n# Ajouter une nouvelle dependance si necessaire\nhpm install hemlang/new-lib\n\n# Implementer la fonctionnalite...\n\n# Tester\nhpm test\n\n# Commiter et pousser\ngit add .\ngit commit -m \"Add new feature\"\ngit push -u origin feature/new-feature\n```\n\n## Configuration specifique a l'environnement\n\n### Utiliser les variables d'environnement\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nlet db_host = getenv(\"DATABASE_HOST\") ?? \"localhost\";\nlet api_key = getenv(\"API_KEY\") ?? \"\";\n\nif api_key == \"\" {\n    print(\"Warning: API_KEY not set\");\n}\n```\n\n### Fichier de configuration\n\n**config.hml :**\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nexport let config = {\n    environment: getenv(\"HEMLOCK_ENV\") ?? \"development\",\n    database: {\n        host: getenv(\"DB_HOST\") ?? \"localhost\",\n        port: int(getenv(\"DB_PORT\") ?? \"5432\"),\n        name: getenv(\"DB_NAME\") ?? \"myapp\"\n    },\n    server: {\n        port: int(getenv(\"PORT\") ?? \"3000\"),\n        host: getenv(\"HOST\") ?? \"0.0.0.0\"\n    }\n};\n\nexport fn is_production(): bool {\n    return config.environment == \"production\";\n}\n```\n\n## Voir aussi\n\n- [Demarrage rapide](#hpm-project-setup-quick-start) - Commencez rapidement\n- [Commandes](#hpm-project-setup-commands) - Reference des commandes\n- [Creer des paquets](#hpm-project-setup-creating-packages) - Publication de paquets\n- [Configuration](#hpm-project-setup-configuration) - Configuration de hpm\n"}, "hpm : Prise en Main -> Dmarrage Rapide": {"id": "hpm-quick-start", "content": "# Demarrage rapide\n\nSoyez operationnel avec hpm en 5 minutes.\n\n## Installer hpm\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\nPour plus d'options d'installation, consultez le [Guide d'installation](#hpm-quick-start-installation).\n\n## Creer un nouveau projet\n\nCommencez par creer un nouveau repertoire et initialiser un paquet :\n\n```bash\nmkdir my-project\ncd my-project\nhpm init\n```\n\nVous serez invite a saisir les details du projet :\n\n```\nPackage name (owner/repo): myname/my-project\nVersion (1.0.0):\nDescription: My awesome Hemlock project\nAuthor: Your Name <you@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\nUtilisez `--yes` pour accepter toutes les valeurs par defaut :\n\n```bash\nhpm init --yes\n```\n\n## Structure du projet\n\nCreez la structure de base du projet :\n\n```\nmy-project/\n package.json        # Manifeste du projet\n src/\n    index.hml      # Point d'entree principal\n test/\n     test.hml       # Tests\n```\n\nCreez votre fichier principal :\n\n```bash\nmkdir -p src test\n```\n\n**src/index.hml :**\n```hemlock\n// Point d'entree principal\nexport fn greet(name: string): string {\n    return \"Hello, \" + name + \"!\";\n}\n\nexport fn main() {\n    print(greet(\"World\"));\n}\n```\n\n## Installer des dependances\n\nRecherchez des paquets sur GitHub (les paquets utilisent le format `owner/repo`) :\n\n```bash\n# Installer un paquet\nhpm install hemlang/sprout\n\n# Installer avec une contrainte de version\nhpm install hemlang/json@^1.0.0\n\n# Installer comme dependance de developpement\nhpm install hemlang/test-utils --dev\n```\n\nApres l'installation, la structure de votre projet inclut `hem_modules/` :\n\n```\nmy-project/\n package.json\n package-lock.json   # Fichier de verrouillage (genere automatiquement)\n hem_modules/        # Paquets installes\n    hemlang/\n        sprout/\n src/\n    index.hml\n test/\n     test.hml\n```\n\n## Utiliser les paquets installes\n\nImportez les paquets en utilisant leur chemin GitHub :\n\n```hemlock\n// Importer depuis un paquet installe\nimport { app, router } from \"hemlang/sprout\";\nimport { parse, stringify } from \"hemlang/json\";\n\n// Importer depuis un sous-chemin\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// Bibliotheque standard (integree)\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile } from \"@stdlib/fs\";\n```\n\n## Ajouter des scripts\n\nAjoutez des scripts a votre `package.json` :\n\n```json\n{\n  \"name\": \"myname/my-project\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/test.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\nExecutez les scripts avec `hpm run` :\n\n```bash\nhpm run start\nhpm run build\n\n# Raccourci pour test\nhpm test\n```\n\n## Flux de travail courants\n\n### Installer toutes les dependances\n\nLorsque vous clonez un projet avec un `package.json` :\n\n```bash\ngit clone https://github.com/someone/project.git\ncd project\nhpm install\n```\n\n### Mettre a jour les dependances\n\nMettre a jour tous les paquets vers les dernieres versions dans les contraintes :\n\n```bash\nhpm update\n```\n\nMettre a jour un paquet specifique :\n\n```bash\nhpm update hemlang/sprout\n```\n\n### Afficher les paquets installes\n\nLister tous les paquets installes :\n\n```bash\nhpm list\n```\n\nLa sortie affiche l'arbre des dependances :\n\n```\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n    hemlang/router@1.5.0\n hemlang/json@1.2.3\n```\n\n### Verifier les mises a jour disponibles\n\nVoir quels paquets ont des versions plus recentes :\n\n```bash\nhpm outdated\n```\n\n### Supprimer un paquet\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n## Exemple : Application web\n\nVoici un exemple complet utilisant un framework web :\n\n**package.json :**\n```json\n{\n  \"name\": \"myname/my-web-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A web application\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"dev\": \"hemlock --watch src/index.hml\"\n  }\n}\n```\n\n**src/index.hml :**\n```hemlock\nimport { App, Router } from \"hemlang/sprout\";\n\nfn main() {\n    let app = App.new();\n    let router = Router.new();\n\n    router.get(\"/\", fn(req, res) {\n        res.send(\"Hello, World!\");\n    });\n\n    router.get(\"/api/status\", fn(req, res) {\n        res.json({ status: \"ok\" });\n    });\n\n    app.use(router);\n    app.listen(3000);\n\n    print(\"Server running on http://localhost:3000\");\n}\n```\n\nExecutez l'application :\n\n```bash\nhpm install\nhpm run start\n```\n\n## Prochaines etapes\n\n- [Reference des commandes](#hpm-quick-start-commands) - Apprenez toutes les commandes hpm\n- [Creer des paquets](#hpm-quick-start-creating-packages) - Publiez vos propres paquets\n- [Configuration](#hpm-quick-start-configuration) - Configurez hpm et les tokens GitHub\n- [Configuration du projet](#hpm-quick-start-project-setup) - Configuration detaillee du projet\n"}, "hpm : Prise en Main -> Installation": {"id": "hpm-installation", "content": "# Installation\n\nCe guide explique comment installer hpm sur votre systeme.\n\n## Installation rapide (recommandee)\n\nInstallez la derniere version avec une seule commande :\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\nCela effectue automatiquement :\n- La detection de votre systeme d'exploitation (Linux, macOS)\n- La detection de votre architecture (x86_64, arm64)\n- Le telechargement du binaire precompile approprie\n- L'installation dans `/usr/local/bin` (ou utilise sudo si necessaire)\n\n### Options d'installation\n\n```bash\n# Installer dans un emplacement personnalise (sans sudo)\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local\n\n# Installer une version specifique\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5\n\n# Combiner les options\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5\n```\n\n### Plateformes supportees\n\n| Plateforme | Architecture | Statut |\n|------------|--------------|--------|\n| Linux    | x86_64       | Supportee |\n| macOS    | x86_64       | Supportee |\n| macOS    | arm64 (M1/M2/M3) | Supportee |\n| Linux    | arm64        | Compiler depuis les sources |\n\n## Compilation depuis les sources\n\nSi vous preferez compiler depuis les sources ou si vous avez besoin d'une plateforme non couverte par les binaires precompiles, suivez ces instructions.\n\n### Prerequis\n\nhpm necessite que [Hemlock](https://github.com/hemlang/hemlock) soit installe au prealable. Suivez les instructions d'installation de Hemlock avant de continuer.\n\nVerifiez que Hemlock est installe :\n\n```bash\nhemlock --version\n```\n\n## Methodes d'installation\n\n### Methode 1 : Make Install\n\nCompiler depuis les sources et installer.\n\n```bash\n# Cloner le depot\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Installer dans /usr/local/bin (necessite sudo)\nsudo make install\n```\n\nApres l'installation, verifiez que cela fonctionne :\n\n```bash\nhpm --version\n```\n\n### Methode 2 : Emplacement personnalise\n\nInstaller dans un repertoire personnalise (sans sudo) :\n\n```bash\n# Cloner le depot\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Installer dans ~/.local/bin\nmake install PREFIX=$HOME/.local\n\n# Ou tout autre emplacement personnalise\nmake install PREFIX=/opt/hemlock\n```\n\nAssurez-vous que votre repertoire bin personnalise est dans votre PATH :\n\n```bash\n# Ajouter a ~/.bashrc ou ~/.zshrc\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n### Methode 3 : Executer sans installer\n\nVous pouvez executer hpm directement sans l'installer :\n\n```bash\n# Cloner le depot\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Creer le script wrapper local\nmake\n\n# Executer depuis le repertoire hpm\n./hpm --help\n\n# Ou executer via hemlock directement\nhemlock src/main.hml --help\n```\n\n### Methode 4 : Installation manuelle\n\nCreez votre propre script wrapper :\n\n```bash\n# Cloner dans un emplacement permanent\ngit clone https://github.com/hemlang/hpm.git ~/.hpm-source\n\n# Creer le script wrapper\ncat > ~/.local/bin/hpm << 'EOF'\n#!/bin/sh\nexec hemlock \"$HOME/.hpm-source/src/main.hml\" \"$@\"\nEOF\n\nchmod +x ~/.local/bin/hpm\n```\n\n## Variables d'installation\n\nLe Makefile supporte ces variables :\n\n| Variable | Valeur par defaut | Description |\n|----------|-------------------|-------------|\n| `PREFIX` | `/usr/local` | Prefixe d'installation |\n| `BINDIR` | `$(PREFIX)/bin` | Repertoire des binaires |\n| `HEMLOCK` | `hemlock` | Chemin vers l'interpreteur hemlock |\n\nExemple avec des variables personnalisees :\n\n```bash\nmake install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock\n```\n\n## Fonctionnement\n\nL'installateur cree un script shell wrapper qui invoque l'interpreteur Hemlock avec le code source de hpm :\n\n```bash\n#!/bin/sh\nexec hemlock \"/path/to/hpm/src/main.hml\" \"$@\"\n```\n\nCette approche :\n- Ne necessite aucune compilation\n- Execute toujours le dernier code source\n- Fonctionne de maniere fiable sur toutes les plateformes\n\n## Mise a jour de hpm\n\nPour mettre a jour hpm vers la derniere version :\n\n```bash\ncd /path/to/hpm\ngit pull origin main\n\n# Reinstaller si le chemin a change\nsudo make install\n```\n\n## Desinstallation\n\nSupprimer hpm de votre systeme :\n\n```bash\ncd /path/to/hpm\nsudo make uninstall\n```\n\nOu supprimer manuellement :\n\n```bash\nsudo rm /usr/local/bin/hpm\n```\n\n## Verification de l'installation\n\nApres l'installation, verifiez que tout fonctionne :\n\n```bash\n# Verifier la version\nhpm --version\n\n# Afficher l'aide\nhpm --help\n\n# Tester l'initialisation (dans un repertoire vide)\nmkdir test-project && cd test-project\nhpm init --yes\ncat package.json\n```\n\n## Depannage\n\n### \"hemlock: command not found\"\n\nHemlock n'est pas installe ou n'est pas dans votre PATH. Installez d'abord Hemlock :\n\n```bash\n# Verifier si hemlock existe\nwhich hemlock\n\n# Si non trouve, installer Hemlock depuis https://github.com/hemlang/hemlock\n```\n\n### \"Permission denied\"\n\nUtilisez sudo pour une installation systeme, ou installez dans un repertoire utilisateur :\n\n```bash\n# Option 1 : Utiliser sudo\nsudo make install\n\n# Option 2 : Installer dans le repertoire utilisateur\nmake install PREFIX=$HOME/.local\n```\n\n### \"hpm: command not found\" apres l'installation\n\nVotre PATH peut ne pas inclure le repertoire d'installation :\n\n```bash\n# Verifier ou hpm a ete installe\nls -la /usr/local/bin/hpm\n\n# Ajouter au PATH si utilisation d'un emplacement personnalise\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## Notes specifiques aux plateformes\n\n### Linux\n\nL'installation standard fonctionne sur toutes les distributions Linux. Certaines distributions peuvent necessiter :\n\n```bash\n# Debian/Ubuntu : S'assurer que les outils de compilation sont installes\nsudo apt-get install build-essential git\n\n# Fedora/RHEL\nsudo dnf install make git\n```\n\n### macOS\n\nL'installation standard fonctionne. Si vous utilisez Homebrew :\n\n```bash\n# S'assurer que les outils en ligne de commande Xcode sont installes\nxcode-select --install\n```\n\n### Windows (WSL)\n\nhpm fonctionne dans le Sous-systeme Windows pour Linux :\n\n```bash\n# Dans le terminal WSL\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\nmake install PREFIX=$HOME/.local\n```\n\n## Prochaines etapes\n\nApres l'installation :\n\n1. [Demarrage rapide](#hpm-installation-quick-start) - Creez votre premier projet\n2. [Reference des commandes](#hpm-installation-commands) - Apprenez toutes les commandes\n3. [Configuration](#hpm-installation-configuration) - Configurez hpm\n"}, "hpm : Guide Utilisateur -> Commandes": {"id": "hpm-commands", "content": "# Reference des commandes\n\nReference complete de toutes les commandes hpm.\n\n## Options globales\n\nCes options fonctionnent avec toutes les commandes :\n\n| Option | Description |\n|--------|-------------|\n| `--help`, `-h` | Afficher le message d'aide |\n| `--version`, `-v` | Afficher la version de hpm |\n| `--verbose` | Afficher une sortie detaillee |\n\n## Commandes\n\n### hpm init\n\nCreer un nouveau fichier `package.json`.\n\n```bash\nhpm init        # Mode interactif\nhpm init --yes  # Accepter toutes les valeurs par defaut\nhpm init -y     # Forme courte\n```\n\n**Options :**\n\n| Option | Description |\n|--------|-------------|\n| `--yes`, `-y` | Accepter les valeurs par defaut pour toutes les invites |\n\n**Invites interactives :**\n- Nom du paquet (format owner/repo)\n- Version (defaut : 1.0.0)\n- Description\n- Auteur\n- Licence (defaut : MIT)\n- Fichier principal (defaut : src/index.hml)\n\n**Exemple :**\n\n```bash\n$ hpm init\nPackage name (owner/repo): alice/my-lib\nVersion (1.0.0):\nDescription: A utility library\nAuthor: Alice <alice@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n---\n\n### hpm install\n\nInstaller des dependances ou ajouter de nouveaux paquets.\n\n```bash\nhpm install                           # Installer tout depuis package.json\nhpm install owner/repo                # Ajouter et installer un paquet\nhpm install owner/repo@^1.0.0        # Avec contrainte de version\nhpm install owner/repo --dev         # Comme dependance de developpement\nhpm i owner/repo                      # Forme courte\n```\n\n**Options :**\n\n| Option | Description |\n|--------|-------------|\n| `--dev`, `-D` | Ajouter aux devDependencies |\n| `--verbose` | Afficher la progression detaillee |\n| `--dry-run` | Apercu sans installer |\n| `--offline` | Installer depuis le cache uniquement (sans reseau) |\n| `--parallel` | Activer les telechargements paralleles (experimental) |\n\n**Syntaxe des contraintes de version :**\n\n| Syntaxe | Exemple | Signification |\n|---------|---------|---------------|\n| (aucune) | `owner/repo` | Derniere version |\n| Exacte | `owner/repo@1.2.3` | Exactement 1.2.3 |\n| Caret | `owner/repo@^1.2.3` | >=1.2.3 <2.0.0 |\n| Tilde | `owner/repo@~1.2.3` | >=1.2.3 <1.3.0 |\n| Plage | `owner/repo@>=1.0.0` | Au moins 1.0.0 |\n\n**Exemples :**\n\n```bash\n# Installer toutes les dependances\nhpm install\n\n# Installer un paquet specifique\nhpm install hemlang/json\n\n# Installer avec contrainte de version\nhpm install hemlang/sprout@^2.0.0\n\n# Installer comme dependance de developpement\nhpm install hemlang/test-utils --dev\n\n# Apercu de ce qui serait installe\nhpm install hemlang/sprout --dry-run\n\n# Sortie verbeuse\nhpm install --verbose\n\n# Installer depuis le cache uniquement (hors ligne)\nhpm install --offline\n```\n\n**Sortie :**\n\n```\nInstalling dependencies...\n  + hemlang/sprout@2.1.0\n  + hemlang/router@1.5.0 (dependency of hemlang/sprout)\n\nInstalled 2 packages in 1.2s\n```\n\n---\n\n### hpm uninstall\n\nSupprimer un paquet.\n\n```bash\nhpm uninstall owner/repo\nhpm rm owner/repo          # Forme courte\nhpm remove owner/repo      # Alternative\n```\n\n**Exemples :**\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n**Sortie :**\n\n```\nRemoved hemlang/sprout@2.1.0\nUpdated package.json\nUpdated package-lock.json\n```\n\n---\n\n### hpm update\n\nMettre a jour les paquets vers les dernieres versions dans les contraintes.\n\n```bash\nhpm update              # Mettre a jour tous les paquets\nhpm update owner/repo   # Mettre a jour un paquet specifique\nhpm up owner/repo       # Forme courte\n```\n\n**Options :**\n\n| Option | Description |\n|--------|-------------|\n| `--verbose` | Afficher la progression detaillee |\n| `--dry-run` | Apercu sans mettre a jour |\n\n**Exemples :**\n\n```bash\n# Mettre a jour tous les paquets\nhpm update\n\n# Mettre a jour un paquet specifique\nhpm update hemlang/sprout\n\n# Apercu des mises a jour\nhpm update --dry-run\n```\n\n**Sortie :**\n\n```\nUpdating dependencies...\n  hemlang/sprout: 2.0.0  2.1.0\n  hemlang/router: 1.4.0  1.5.0\n\nUpdated 2 packages\n```\n\n---\n\n### hpm list\n\nAfficher les paquets installes.\n\n```bash\nhpm list              # Afficher l'arbre complet des dependances\nhpm list --depth=0    # Dependances directes uniquement\nhpm list --depth=1    # Un niveau de dependances transitives\nhpm ls                # Forme courte\n```\n\n**Options :**\n\n| Option | Description |\n|--------|-------------|\n| `--depth=N` | Limiter la profondeur de l'arbre (defaut : tout) |\n\n**Exemples :**\n\n```bash\n$ hpm list\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n    hemlang/router@1.5.0\n    hemlang/middleware@1.2.0\n hemlang/json@1.2.3\n hemlang/test-utils@1.0.0 (dev)\n\n$ hpm list --depth=0\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n hemlang/json@1.2.3\n hemlang/test-utils@1.0.0 (dev)\n```\n\n---\n\n### hpm outdated\n\nAfficher les paquets avec des versions plus recentes disponibles.\n\n```bash\nhpm outdated\n```\n\n**Sortie :**\n\n```\nPackage            Current  Wanted  Latest\nhemlang/sprout     2.0.0    2.0.5   2.1.0\nhemlang/router     1.4.0    1.4.2   1.5.0\n```\n\n- **Current** : Version installee\n- **Wanted** : Version la plus elevee correspondant a la contrainte\n- **Latest** : Derniere version disponible\n\n---\n\n### hpm run\n\nExecuter un script depuis package.json.\n\n```bash\nhpm run <script>\nhpm run <script> -- <args>\n```\n\n**Exemples :**\n\nAvec ce package.json :\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\nExecuter des scripts :\n\n```bash\nhpm run start\nhpm run test\nhpm run build\n\n# Passer des arguments au script\nhpm run test -- --verbose\n```\n\n---\n\n### hpm test\n\nRaccourci pour `hpm run test`.\n\n```bash\nhpm test\nhpm test -- --verbose\n```\n\nEquivalent a :\n\n```bash\nhpm run test\n```\n\n---\n\n### hpm why\n\nExpliquer pourquoi un paquet est installe (afficher la chaine de dependances).\n\n```bash\nhpm why owner/repo\n```\n\n**Exemple :**\n\n```bash\n$ hpm why hemlang/router\n\nhemlang/router@1.5.0 is installed because:\n\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n     hemlang/router@1.5.0\n```\n\n---\n\n### hpm cache\n\nGerer le cache global des paquets.\n\n```bash\nhpm cache list    # Lister les paquets en cache\nhpm cache clean   # Vider tous les paquets en cache\n```\n\n**Sous-commandes :**\n\n| Sous-commande | Description |\n|---------------|-------------|\n| `list` | Afficher tous les paquets en cache et leurs tailles |\n| `clean` | Supprimer tous les paquets en cache |\n\n**Exemples :**\n\n```bash\n$ hpm cache list\nCached packages in ~/.hpm/cache:\n\nhemlang/sprout\n  2.0.0 (1.2 MB)\n  2.1.0 (1.3 MB)\nhemlang/router\n  1.5.0 (450 KB)\n\nTotal: 2.95 MB\n\n$ hpm cache clean\nCleared cache (2.95 MB freed)\n```\n\n---\n\n## Raccourcis de commandes\n\nPour plus de commodite, plusieurs commandes ont des alias courts :\n\n| Commande | Raccourcis |\n|----------|------------|\n| `install` | `i` |\n| `uninstall` | `rm`, `remove` |\n| `list` | `ls` |\n| `update` | `up` |\n\n**Exemples :**\n\n```bash\nhpm i hemlang/sprout        # hpm install hemlang/sprout\nhpm rm hemlang/sprout       # hpm uninstall hemlang/sprout\nhpm ls                      # hpm list\nhpm up                      # hpm update\n```\n\n---\n\n## Codes de sortie\n\nhpm utilise des codes de sortie specifiques pour indiquer differentes conditions d'erreur :\n\n| Code | Signification |\n|------|---------------|\n| 0 | Succes |\n| 1 | Conflit de dependances |\n| 2 | Paquet non trouve |\n| 3 | Version non trouvee |\n| 4 | Erreur reseau |\n| 5 | package.json invalide |\n| 6 | Echec de la verification d'integrite |\n| 7 | Limite de taux GitHub depassee |\n| 8 | Dependance circulaire |\n\nUtilisez les codes de sortie dans les scripts :\n\n```bash\nhpm install\nif [ $? -ne 0 ]; then\n    echo \"Installation failed\"\n    exit 1\nfi\n```\n\n---\n\n## Variables d'environnement\n\nhpm respecte ces variables d'environnement :\n\n| Variable | Description |\n|----------|-------------|\n| `GITHUB_TOKEN` | Token API GitHub pour l'authentification |\n| `HPM_CACHE_DIR` | Remplacer l'emplacement du repertoire de cache |\n| `HOME` | Repertoire personnel de l'utilisateur (pour config/cache) |\n\n**Exemples :**\n\n```bash\n# Utiliser un token GitHub pour des limites de taux plus elevees\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Utiliser un repertoire de cache personnalise\nexport HPM_CACHE_DIR=/tmp/hpm-cache\nhpm install\n```\n\n---\n\n## Voir aussi\n\n- [Configuration](#hpm-commands-configuration) - Fichiers de configuration\n- [Specification des paquets](#hpm-commands-package-spec) - Format package.json\n- [Depannage](#hpm-commands-troubleshooting) - Problemes courants\n"}, "hpm : Guide Utilisateur -> Configuration": {"id": "hpm-configuration", "content": "# Configuration\n\nCe guide couvre toutes les options de configuration de hpm.\n\n## Apercu\n\nhpm peut etre configure via :\n\n1. **Variables d'environnement** - Pour les parametres d'execution\n2. **Fichier de configuration global** - `~/.hpm/config.json`\n3. **Fichiers de projet** - `package.json` et `package-lock.json`\n\n## Variables d'environnement\n\n### GITHUB_TOKEN\n\nToken API GitHub pour l'authentification.\n\n```bash\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n```\n\n**Avantages de l'authentification :**\n- Limites de taux API plus elevees (5000 contre 60 requetes/heure)\n- Acces aux depots prives\n- Resolution des dependances plus rapide\n\n**Creer un token :**\n\n1. Allez dans GitHub > Settings > Developer settings > Personal access tokens\n2. Cliquez sur \"Generate new token (classic)\"\n3. Selectionnez les portees :\n   - `repo` - Pour l'acces aux depots prives\n   - `read:packages` - Pour GitHub Packages (si utilise)\n4. Generez et copiez le token\n\n### HPM_CACHE_DIR\n\nRemplacer le repertoire de cache par defaut.\n\n```bash\nexport HPM_CACHE_DIR=/custom/cache/path\n```\n\nDefaut : `~/.hpm/cache`\n\n**Cas d'utilisation :**\n- Systemes CI/CD avec des emplacements de cache personnalises\n- Cache partage entre plusieurs projets\n- Cache temporaire pour des builds isoles\n\n### HOME\n\nRepertoire personnel de l'utilisateur. Utilise pour localiser :\n- Repertoire de configuration : `$HOME/.hpm/`\n- Repertoire de cache : `$HOME/.hpm/cache/`\n\nGeneralement defini par le systeme ; remplacez uniquement si necessaire.\n\n### Exemple .bashrc / .zshrc\n\n```bash\n# Authentification GitHub (recommande)\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n\n# Emplacement de cache personnalise (optionnel)\n# export HPM_CACHE_DIR=/path/to/cache\n\n# Ajouter hpm au PATH (si utilisation d'un emplacement d'installation personnalise)\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## Fichier de configuration global\n\n### Emplacement\n\n`~/.hpm/config.json`\n\n### Format\n\n```json\n{\n  \"github_token\": \"ghp_xxxxxxxxxxxxxxxxxxxx\"\n}\n```\n\n### Creer le fichier de configuration\n\n```bash\n# Creer le repertoire de configuration\nmkdir -p ~/.hpm\n\n# Creer le fichier de configuration\ncat > ~/.hpm/config.json << 'EOF'\n{\n  \"github_token\": \"ghp_your_token_here\"\n}\nEOF\n\n# Securiser le fichier (recommande)\nchmod 600 ~/.hpm/config.json\n```\n\n### Priorite des tokens\n\nSi les deux sont definis, la variable d'environnement a la priorite :\n\n1. Variable d'environnement `GITHUB_TOKEN` (la plus haute)\n2. Champ `github_token` de `~/.hpm/config.json`\n3. Pas d'authentification (par defaut)\n\n## Structure des repertoires\n\n### Repertoires globaux\n\n```\n~/.hpm/\n config.json          # Configuration globale\n cache/               # Cache des paquets\n     owner/\n         repo/\n             1.0.0.tar.gz\n```\n\n### Repertoires de projet\n\n```\nmy-project/\n package.json         # Manifeste du projet\n package-lock.json    # Fichier de verrouillage des dependances\n hem_modules/         # Paquets installes\n    owner/\n        repo/\n            package.json\n            src/\n src/                 # Code source\n test/                # Tests\n```\n\n## Cache des paquets\n\n### Emplacement\n\nDefaut : `~/.hpm/cache/`\n\nRemplacer avec : variable d'environnement `HPM_CACHE_DIR`\n\n### Structure\n\n```\n~/.hpm/cache/\n hemlang/\n    sprout/\n       2.0.0.tar.gz\n       2.1.0.tar.gz\n    router/\n        1.5.0.tar.gz\n alice/\n     http-client/\n         1.0.0.tar.gz\n```\n\n### Gestion du cache\n\n```bash\n# Voir les paquets en cache\nhpm cache list\n\n# Vider tout le cache\nhpm cache clean\n```\n\n### Comportement du cache\n\n- Les paquets sont mis en cache apres le premier telechargement\n- Les installations suivantes utilisent les versions en cache\n- Utilisez `--offline` pour installer uniquement depuis le cache\n- Le cache est partage entre tous les projets\n\n## Limites de taux de l'API GitHub\n\n### Sans authentification\n\n- **60 requetes par heure** par adresse IP\n- Partage entre tous les utilisateurs non authentifies sur la meme IP\n- Rapidement epuise en CI/CD ou avec beaucoup de dependances\n\n### Avec authentification\n\n- **5000 requetes par heure** par utilisateur authentifie\n- Limite de taux personnelle, non partagee\n\n### Gestion des limites de taux\n\nhpm automatiquement :\n- Reessaie avec un backoff exponentiel (1s, 2s, 4s, 8s)\n- Signale les erreurs de limite de taux avec le code de sortie 7\n- Suggere l'authentification en cas de limitation\n\n**Solutions en cas de limitation :**\n\n```bash\n# Option 1 : S'authentifier avec un token GitHub\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Option 2 : Attendre la reinitialisation de la limite de taux\n# (Les limites se reinitialisent toutes les heures)\n\n# Option 3 : Utiliser le mode hors ligne (si les paquets sont en cache)\nhpm install --offline\n```\n\n## Mode hors ligne\n\nInstaller des paquets sans acces reseau :\n\n```bash\nhpm install --offline\n```\n\n**Exigences :**\n- Tous les paquets doivent etre dans le cache\n- Le fichier de verrouillage doit exister avec les versions exactes\n\n**Cas d'utilisation :**\n- Environnements air-gap\n- Builds CI/CD plus rapides (avec cache prechauff)\n- Eviter les limites de taux\n\n## Configuration CI/CD\n\n### GitHub Actions\n\n```yaml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Setup Hemlock\n      run: |\n        # Installer Hemlock (ajuster selon votre configuration)\n        curl -sSL https://hemlock.dev/install.sh | sh\n\n    - name: Cache hpm packages\n      uses: actions/cache@v3\n      with:\n        path: ~/.hpm/cache\n        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}\n        restore-keys: |\n          ${{ runner.os }}-hpm-\n\n    - name: Install dependencies\n      run: hpm install\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Run tests\n      run: hpm test\n```\n\n### GitLab CI\n\n```yaml\nstages:\n  - build\n  - test\n\nvariables:\n  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache\n\ncache:\n  paths:\n    - .hpm-cache/\n  key: $CI_COMMIT_REF_SLUG\n\nbuild:\n  stage: build\n  script:\n    - hpm install\n  artifacts:\n    paths:\n      - hem_modules/\n\ntest:\n  stage: test\n  script:\n    - hpm test\n```\n\n### Docker\n\n**Dockerfile :**\n\n```dockerfile\nFROM hemlock:latest\n\nWORKDIR /app\n\n# Copier d'abord les fichiers de paquet (pour le cache des couches)\nCOPY package.json package-lock.json ./\n\n# Installer les dependances\nRUN hpm install\n\n# Copier le code source\nCOPY . .\n\n# Executer l'application\nCMD [\"hemlock\", \"src/main.hml\"]\n```\n\n**docker-compose.yml :**\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    environment:\n      - GITHUB_TOKEN=${GITHUB_TOKEN}\n    volumes:\n      - hpm-cache:/root/.hpm/cache\n\nvolumes:\n  hpm-cache:\n```\n\n## Configuration du proxy\n\nPour les environnements derriere un proxy, configurez au niveau du systeme :\n\n```bash\nexport HTTP_PROXY=http://proxy.example.com:8080\nexport HTTPS_PROXY=http://proxy.example.com:8080\nexport NO_PROXY=localhost,127.0.0.1\n\nhpm install\n```\n\n## Bonnes pratiques de securite\n\n### Securite des tokens\n\n1. **Ne commitez jamais les tokens** dans le controle de version\n2. **Utilisez des variables d'environnement** en CI/CD\n3. **Limitez les portees des tokens** au minimum requis\n4. **Faites tourner les tokens** regulierement\n5. **Securisez le fichier de configuration** :\n   ```bash\n   chmod 600 ~/.hpm/config.json\n   ```\n\n### Depots prives\n\nPour acceder aux paquets prives :\n\n1. Creez un token avec la portee `repo`\n2. Configurez l'authentification (variable d'environnement ou fichier de configuration)\n3. Assurez-vous que le token a acces au depot\n\n```bash\n# Tester l'acces\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install yourorg/private-package\n```\n\n## Depannage de la configuration\n\n### Verifier la configuration\n\n```bash\n# Verifier si le token est defini\necho $GITHUB_TOKEN | head -c 10\n\n# Verifier le fichier de configuration\ncat ~/.hpm/config.json\n\n# Verifier le repertoire de cache\nls -la ~/.hpm/cache/\n\n# Tester avec une sortie verbeuse\nhpm install --verbose\n```\n\n### Problemes courants\n\n**\"GitHub rate limit exceeded\"**\n- Configurez l'authentification avec `GITHUB_TOKEN`\n- Attendez la reinitialisation de la limite de taux\n- Utilisez `--offline` si les paquets sont en cache\n\n**\"Permission denied\" sur le cache**\n```bash\n# Corriger les permissions du cache\nchmod -R u+rw ~/.hpm/cache\n```\n\n**\"Config file not found\"**\n```bash\n# Creer le repertoire de configuration\nmkdir -p ~/.hpm\ntouch ~/.hpm/config.json\n```\n\n## Voir aussi\n\n- [Installation](#hpm-configuration-installation) - Installer hpm\n- [Depannage](#hpm-configuration-troubleshooting) - Problemes courants\n- [Commandes](#hpm-configuration-commands) - Reference des commandes\n"}, "hpm : Guide Utilisateur -> Dpannage": {"id": "hpm-troubleshooting", "content": "# Depannage\n\nSolutions aux problemes courants de hpm.\n\n## Problemes d'installation\n\n### \"hemlock: command not found\"\n\n**Cause :** Hemlock n'est pas installe ou n'est pas dans le PATH.\n\n**Solution :**\n\n```bash\n# Verifier si hemlock existe\nwhich hemlock\n\n# Si non trouve, installer d'abord Hemlock\n# Visitez : https://github.com/hemlang/hemlock\n\n# Apres l'installation, verifier\nhemlock --version\n```\n\n### \"hpm: command not found\"\n\n**Cause :** hpm n'est pas installe ou n'est pas dans le PATH.\n\n**Solution :**\n\n```bash\n# Verifier ou hpm est installe\nls -la /usr/local/bin/hpm\nls -la ~/.local/bin/hpm\n\n# Si utilisation d'un emplacement personnalise, ajouter au PATH\nexport PATH=\"$HOME/.local/bin:$PATH\"\n\n# Ajouter a ~/.bashrc ou ~/.zshrc pour la persistance\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc\nsource ~/.bashrc\n\n# Reinstaller si necessaire\ncd /path/to/hpm\nsudo make install\n```\n\n### \"Permission denied\" pendant l'installation\n\n**Cause :** Pas de permission d'ecriture dans le repertoire d'installation.\n\n**Solution :**\n\n```bash\n# Option 1 : Utiliser sudo pour une installation systeme\nsudo make install\n\n# Option 2 : Installer dans le repertoire utilisateur (sans sudo)\nmake install PREFIX=$HOME/.local\n```\n\n## Problemes de dependances\n\n### \"Package not found\" (code de sortie 2)\n\n**Cause :** Le paquet n'existe pas sur GitHub.\n\n**Solution :**\n\n```bash\n# Verifier que le paquet existe\n# Verifiez : https://github.com/owner/repo\n\n# Verifier l'orthographe\nhpm install hemlang/sprout  # Correct\nhpm install hemlan/sprout   # Mauvais proprietaire\nhpm install hemlang/spout   # Mauvais depot\n\n# Verifier les fautes de frappe dans package.json\ncat package.json | grep -A 5 dependencies\n```\n\n### \"Version not found\" (code de sortie 3)\n\n**Cause :** Aucune release ne correspond a la contrainte de version.\n\n**Solution :**\n\n```bash\n# Lister les versions disponibles (verifier les releases/tags GitHub)\n# Les tags doivent commencer par 'v' (ex: v1.0.0)\n\n# Utiliser une contrainte de version valide\nhpm install owner/repo@^1.0.0\n\n# Essayer la derniere version\nhpm install owner/repo\n\n# Verifier les tags disponibles sur GitHub\n# https://github.com/owner/repo/tags\n```\n\n### \"Dependency conflict\" (code de sortie 1)\n\n**Cause :** Deux paquets necessitent des versions incompatibles d'une dependance.\n\n**Solution :**\n\n```bash\n# Voir le conflit\nhpm install --verbose\n\n# Verifier ce qui necessite la dependance\nhpm why conflicting/package\n\n# Solutions :\n# 1. Mettre a jour le paquet en conflit\nhpm update problem/package\n\n# 2. Modifier les contraintes de version dans package.json\n# Editer pour permettre des versions compatibles\n\n# 3. Supprimer un des paquets en conflit\nhpm uninstall one/package\n```\n\n### \"Circular dependency\" (code de sortie 8)\n\n**Cause :** Le paquet A depend de B, qui depend de A.\n\n**Solution :**\n\n```bash\n# Identifier le cycle\nhpm install --verbose\n\n# C'est generalement un bug dans les paquets\n# Contacter les mainteneurs des paquets\n\n# Solution de contournement : eviter un des paquets\n```\n\n## Problemes reseau\n\n### \"Network error\" (code de sortie 4)\n\n**Cause :** Impossible de se connecter a l'API GitHub.\n\n**Solution :**\n\n```bash\n# Verifier la connexion internet\nping github.com\n\n# Verifier si l'API GitHub est accessible\ncurl -I https://api.github.com\n\n# Reessayer (hpm reessaie automatiquement)\nhpm install\n\n# Utiliser le mode hors ligne si les paquets sont en cache\nhpm install --offline\n\n# Verifier les parametres du proxy si derriere un pare-feu\nexport HTTPS_PROXY=http://proxy:8080\nhpm install\n```\n\n### \"GitHub rate limit exceeded\" (code de sortie 7)\n\n**Cause :** Trop de requetes API sans authentification.\n\n**Solution :**\n\n```bash\n# Option 1 : S'authentifier avec un token GitHub (recommande)\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Creer un token : GitHub > Settings > Developer settings > Personal access tokens\n\n# Option 2 : Enregistrer le token dans le fichier de configuration\nmkdir -p ~/.hpm\necho '{\"github_token\": \"ghp_xxxxxxxxxxxx\"}' > ~/.hpm/config.json\n\n# Option 3 : Attendre la reinitialisation de la limite (reinitialisation horaire)\n\n# Option 4 : Utiliser le mode hors ligne\nhpm install --offline\n```\n\n### Timeout de connexion\n\n**Cause :** Reseau lent ou problemes de l'API GitHub.\n\n**Solution :**\n\n```bash\n# hpm reessaie automatiquement avec un backoff exponentiel\n\n# Verifier si GitHub a des problemes\n# Visitez : https://www.githubstatus.com\n\n# Reessayer plus tard\nhpm install\n\n# Utiliser les paquets en cache\nhpm install --offline\n```\n\n## Problemes de package.json\n\n### \"Invalid package.json\" (code de sortie 5)\n\n**Cause :** Malformation ou champs obligatoires manquants.\n\n**Solution :**\n\n```bash\n# Valider la syntaxe JSON\ncat package.json | python -m json.tool\n\n# Verifier les champs obligatoires\ncat package.json\n\n# Champs obligatoires :\n# - \"name\" : format owner/repo\n# - \"version\" : format X.Y.Z\n\n# Regenerer si necessaire\nrm package.json\nhpm init\n```\n\n### Erreur de format \"name\"\n\n**Cause :** Le nom du paquet n'est pas au format `owner/repo`.\n\n**Solution :**\n\n```json\n// Incorrect\n{\n  \"name\": \"my-package\"\n}\n\n// Correct\n{\n  \"name\": \"yourusername/my-package\"\n}\n```\n\n### Erreur de format \"version\"\n\n**Cause :** La version n'est pas au format semver.\n\n**Solution :**\n\n```json\n// Incorrect\n{\n  \"version\": \"1.0\"\n}\n\n// Correct\n{\n  \"version\": \"1.0.0\"\n}\n```\n\n## Problemes de fichier de verrouillage\n\n### Fichier de verrouillage desynchronise\n\n**Cause :** package.json modifie sans executer install.\n\n**Solution :**\n\n```bash\n# Regenerer le fichier de verrouillage\nrm package-lock.json\nhpm install\n```\n\n### Fichier de verrouillage corrompu\n\n**Cause :** JSON invalide ou modifications manuelles.\n\n**Solution :**\n\n```bash\n# Verifier la validite JSON\ncat package-lock.json | python -m json.tool\n\n# Regenerer\nrm package-lock.json\nhpm install\n```\n\n## Problemes de hem_modules\n\n### Les paquets ne s'installent pas\n\n**Cause :** Divers problemes possibles.\n\n**Solution :**\n\n```bash\n# Nettoyer et reinstaller\nrm -rf hem_modules\nhpm install\n\n# Verifier la sortie verbeuse\nhpm install --verbose\n```\n\n### L'import ne fonctionne pas\n\n**Cause :** Paquet pas correctement installe ou mauvais chemin d'import.\n\n**Solution :**\n\n```bash\n# Verifier que le paquet est installe\nls hem_modules/owner/repo/\n\n# Verifier le champ main de package.json\ncat hem_modules/owner/repo/package.json\n\n# Format d'import correct\nimport { x } from \"owner/repo\";          # Utilise l'entree main\nimport { y } from \"owner/repo/subpath\";  # Import de sous-chemin\n```\n\n### Erreur \"Module not found\"\n\n**Cause :** Le chemin d'import ne correspond pas a un fichier.\n\n**Solution :**\n\n```bash\n# Verifier le chemin d'import\nls hem_modules/owner/repo/src/\n\n# Verifier index.hml\nls hem_modules/owner/repo/src/index.hml\n\n# Verifier le champ main dans package.json\ncat hem_modules/owner/repo/package.json | grep main\n```\n\n## Problemes de cache\n\n### Le cache prend trop d'espace\n\n**Solution :**\n\n```bash\n# Voir la taille du cache\nhpm cache list\n\n# Vider le cache\nhpm cache clean\n```\n\n### Permissions du cache\n\n**Solution :**\n\n```bash\n# Corriger les permissions\nchmod -R u+rw ~/.hpm/cache\n\n# Ou supprimer et reinstaller\nrm -rf ~/.hpm/cache\nhpm install\n```\n\n### Utilisation du mauvais cache\n\n**Solution :**\n\n```bash\n# Verifier l'emplacement du cache\necho $HPM_CACHE_DIR\nls ~/.hpm/cache\n\n# Effacer la variable d'environnement si incorrecte\nunset HPM_CACHE_DIR\n```\n\n## Problemes de scripts\n\n### \"Script not found\"\n\n**Cause :** Le nom du script n'existe pas dans package.json.\n\n**Solution :**\n\n```bash\n# Lister les scripts disponibles\ncat package.json | grep -A 20 scripts\n\n# Verifier l'orthographe\nhpm run test    # Correct\nhpm run tests   # Incorrect si le script s'appelle \"test\"\n```\n\n### Le script echoue\n\n**Cause :** Erreur dans la commande du script.\n\n**Solution :**\n\n```bash\n# Executer la commande directement pour voir l'erreur\nhemlock test/run.hml\n\n# Verifier la definition du script\ncat package.json | grep test\n```\n\n## Debogage\n\n### Activer la sortie verbeuse\n\n```bash\nhpm install --verbose\n```\n\n### Verifier la version de hpm\n\n```bash\nhpm --version\n```\n\n### Verifier la version de hemlock\n\n```bash\nhemlock --version\n```\n\n### Simulation (dry run)\n\nApercu sans effectuer de modifications :\n\n```bash\nhpm install --dry-run\n```\n\n### Repartir de zero\n\nCommencer proprement :\n\n```bash\nrm -rf hem_modules package-lock.json\nhpm install\n```\n\n## Obtenir de l'aide\n\n### Aide des commandes\n\n```bash\nhpm --help\nhpm install --help\n```\n\n### Signaler des problemes\n\nSi vous rencontrez un bug :\n\n1. Verifiez les issues existantes : https://github.com/hemlang/hpm/issues\n2. Creez une nouvelle issue avec :\n   - Version de hpm (`hpm --version`)\n   - Version de Hemlock (`hemlock --version`)\n   - Systeme d'exploitation\n   - Etapes pour reproduire\n   - Message d'erreur (utilisez `--verbose`)\n\n## Reference des codes de sortie\n\n| Code | Signification | Solution courante |\n|------|---------------|-------------------|\n| 0 | Succes | - |\n| 1 | Conflit de dependances | Mettre a jour ou changer les contraintes |\n| 2 | Paquet non trouve | Verifier l'orthographe, verifier que le depot existe |\n| 3 | Version non trouvee | Verifier les versions disponibles sur GitHub |\n| 4 | Erreur reseau | Verifier la connexion, reessayer |\n| 5 | package.json invalide | Corriger la syntaxe JSON et les champs obligatoires |\n| 6 | Echec de verification d'integrite | Vider le cache, reinstaller |\n| 7 | Limite de taux GitHub | Ajouter GITHUB_TOKEN |\n| 8 | Dependance circulaire | Contacter les mainteneurs des paquets |\n\n## Voir aussi\n\n- [Installation](#hpm-troubleshooting-installation) - Guide d'installation\n- [Configuration](#hpm-troubleshooting-configuration) - Options de configuration\n- [Commandes](#hpm-troubleshooting-commands) - Reference des commandes\n"}, "hpm : Dveloppement de Paquets -> Cration de Paquets": {"id": "hpm-creating-packages", "content": "# Creer des paquets\n\nCe guide explique comment creer, structurer et publier des paquets Hemlock.\n\n## Apercu\n\nhpm utilise GitHub comme registre de paquets. Les paquets sont identifies par leur chemin GitHub `owner/repo`, et les versions sont des tags Git. Publier consiste simplement a pousser une release taguee.\n\n## Creer un nouveau paquet\n\n### 1. Initialiser le paquet\n\nCreez un nouveau repertoire et initialisez :\n\n```bash\nmkdir my-package\ncd my-package\nhpm init\n```\n\nRepondez aux invites :\n\n```\nPackage name (owner/repo): yourusername/my-package\nVersion (1.0.0):\nDescription: A useful Hemlock package\nAuthor: Your Name <you@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n### 2. Creer la structure du projet\n\nStructure recommandee pour les paquets :\n\n```\nmy-package/\n package.json          # Manifeste du paquet\n README.md             # Documentation\n LICENSE               # Fichier de licence\n src/\n    index.hml         # Point d'entree principal (exporte l'API publique)\n    utils.hml         # Utilitaires internes\n    types.hml         # Definitions de types\n test/\n     framework.hml     # Framework de test\n     test_utils.hml    # Tests\n```\n\n### 3. Definir votre API publique\n\n**src/index.hml** - Point d'entree principal :\n\n```hemlock\n// Reexporter l'API publique\nexport { parse, stringify } from \"./parser.hml\";\nexport { Config, Options } from \"./types.hml\";\nexport { process } from \"./processor.hml\";\n\n// Exports directs\nexport fn create(options: Options): Config {\n    // Implementation\n}\n\nexport fn validate(config: Config): bool {\n    // Implementation\n}\n```\n\n### 4. Ecrire votre package.json\n\nExemple complet de package.json :\n\n```json\n{\n  \"name\": \"yourusername/my-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A useful Hemlock package\",\n  \"author\": \"Your Name <you@example.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/yourusername/my-package\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/bundle.hmlc\"\n  },\n  \"keywords\": [\"utility\", \"parser\", \"config\"],\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n## Nommage des paquets\n\n### Exigences\n\n- Doit etre au format `owner/repo`\n- `owner` doit etre votre nom d'utilisateur GitHub ou organisation\n- `repo` doit etre le nom du depot\n- Utilisez des minuscules avec des tirets pour les noms composes\n\n### Bons noms\n\n```\nhemlang/sprout\nalice/http-client\nmyorg/json-utils\nbob/date-formatter\n```\n\n### A eviter\n\n```\nmy-package          # Proprietaire manquant\nalice/MyPackage     # PascalCase\nalice/my_package    # Underscores\n```\n\n## Bonnes pratiques de structure des paquets\n\n### Point d'entree\n\nLe champ `main` dans package.json specifie le point d'entree :\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\nCe fichier doit exporter votre API publique :\n\n```hemlock\n// Exporter tout ce dont les utilisateurs ont besoin\nexport { Parser, parse } from \"./parser.hml\";\nexport { Formatter, format } from \"./formatter.hml\";\n\n// Types\nexport type { Config, Options } from \"./types.hml\";\n```\n\n### Interne vs public\n\nGardez les details d'implementation internes prives :\n\n```\nsrc/\n index.hml          # Public : API exportee\n parser.hml         # Public : utilise par index.hml\n formatter.hml      # Public : utilise par index.hml\n internal/\n     helpers.hml    # Prive : usage interne uniquement\n     constants.hml  # Prive : usage interne uniquement\n```\n\nLes utilisateurs importent depuis la racine de votre paquet :\n\n```hemlock\n// Bien - importe depuis l'API publique\nimport { parse, Parser } from \"yourusername/my-package\";\n\n// Fonctionne aussi - import de sous-chemin\nimport { validate } from \"yourusername/my-package/validator\";\n\n// Deconseille - acces aux internes\nimport { helper } from \"yourusername/my-package/internal/helpers\";\n```\n\n### Exports de sous-chemins\n\nSupportez l'import depuis des sous-chemins :\n\n```\nsrc/\n index.hml              # Entree principale\n parser/\n    index.hml          # yourusername/pkg/parser\n formatter/\n    index.hml          # yourusername/pkg/formatter\n utils/\n     index.hml          # yourusername/pkg/utils\n```\n\nLes utilisateurs peuvent importer :\n\n```hemlock\nimport { parse } from \"yourusername/my-package\";           // Principal\nimport { Parser } from \"yourusername/my-package/parser\";   // Sous-chemin\nimport { format } from \"yourusername/my-package/formatter\";\n```\n\n## Dependances\n\n### Ajouter des dependances\n\n```bash\n# Dependance d'execution\nhpm install hemlang/json\n\n# Dependance de developpement\nhpm install hemlang/test-utils --dev\n```\n\n### Bonnes pratiques pour les dependances\n\n1. **Utilisez des plages caret** pour la plupart des dependances :\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     }\n   }\n   ```\n\n2. **Epinglez les versions** uniquement si necessaire (instabilite de l'API) :\n   ```json\n   {\n     \"dependencies\": {\n       \"unstable/lib\": \"1.2.3\"\n     }\n   }\n   ```\n\n3. **Evitez les plages trop restrictives** :\n   ```json\n   // Mauvais : trop restrictif\n   \"hemlang/json\": \">=1.2.3 <1.2.5\"\n\n   // Bon : permet les mises a jour compatibles\n   \"hemlang/json\": \"^1.2.3\"\n   ```\n\n4. **Separez les dependances de developpement** :\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     },\n     \"devDependencies\": {\n       \"hemlang/test-utils\": \"^1.0.0\"\n     }\n   }\n   ```\n\n## Tester votre paquet\n\n### Ecrire des tests\n\n**test/run.hml :**\n\n```hemlock\nimport { suite, test, assert_eq } from \"./framework.hml\";\nimport { parse, stringify } from \"../src/index.hml\";\n\nfn run_tests() {\n    suite(\"Parser\", fn() {\n        test(\"parses valid input\", fn() {\n            let result = parse(\"hello\");\n            assert_eq(result.value, \"hello\");\n        });\n\n        test(\"handles empty input\", fn() {\n            let result = parse(\"\");\n            assert_eq(result.value, \"\");\n        });\n    });\n\n    suite(\"Stringify\", fn() {\n        test(\"stringifies object\", fn() {\n            let obj = { name: \"test\" };\n            let result = stringify(obj);\n            assert_eq(result, '{\"name\":\"test\"}');\n        });\n    });\n}\n\nrun_tests();\n```\n\n### Executer les tests\n\nAjoutez un script de test :\n\n```json\n{\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\nExecutez avec :\n\n```bash\nhpm test\n```\n\n## Publication\n\n### Prerequis\n\n1. Creez un depot GitHub correspondant au nom de votre paquet\n2. Assurez-vous que `package.json` est complet et valide\n3. Tous les tests passent\n\n### Processus de publication\n\nPublier consiste simplement a pousser un tag Git :\n\n```bash\n# 1. S'assurer que tout est commite\ngit add .\ngit commit -m \"Prepare v1.0.0 release\"\n\n# 2. Creer un tag de version (doit commencer par 'v')\ngit tag v1.0.0\n\n# 3. Pousser le code et les tags\ngit push origin main\ngit push origin v1.0.0\n# Ou pousser tous les tags d'un coup\ngit push origin main --tags\n```\n\n### Tags de version\n\nLes tags doivent suivre le format `vX.Y.Z` :\n\n```bash\ngit tag v1.0.0      # Release\ngit tag v1.0.1      # Patch\ngit tag v1.1.0      # Mineure\ngit tag v2.0.0      # Majeure\ngit tag v1.0.0-beta.1  # Pre-release\n```\n\n### Liste de verification avant publication\n\nAvant de publier une nouvelle version :\n\n1. **Mettre a jour la version** dans package.json\n2. **Executer les tests** : `hpm test`\n3. **Mettre a jour le CHANGELOG** (si vous en avez un)\n4. **Mettre a jour le README** si l'API a change\n5. **Commiter les modifications**\n6. **Creer le tag**\n7. **Pousser vers GitHub**\n\n### Exemple automatise\n\nCreez un script de release :\n\n```bash\n#!/bin/bash\n# release.sh - Publier une nouvelle version\n\nVERSION=$1\n\nif [ -z \"$VERSION\" ]; then\n    echo \"Usage: ./release.sh 1.0.0\"\n    exit 1\nfi\n\n# Executer les tests\nhpm test || exit 1\n\n# Mettre a jour la version dans package.json\nsed -i \"s/\\\"version\\\": \\\".*\\\"/\\\"version\\\": \\\"$VERSION\\\"/\" package.json\n\n# Commiter et taguer\ngit add package.json\ngit commit -m \"Release v$VERSION\"\ngit tag \"v$VERSION\"\n\n# Pousser\ngit push origin main --tags\n\necho \"Released v$VERSION\"\n```\n\n## Les utilisateurs installent votre paquet\n\nApres publication, les utilisateurs peuvent installer :\n\n```bash\n# Derniere version\nhpm install yourusername/my-package\n\n# Version specifique\nhpm install yourusername/my-package@1.0.0\n\n# Contrainte de version\nhpm install yourusername/my-package@^1.0.0\n```\n\nEt importer :\n\n```hemlock\nimport { parse, stringify } from \"yourusername/my-package\";\n```\n\n## Documentation\n\n### README.md\n\nChaque paquet devrait avoir un README :\n\n```markdown\n# my-package\n\nUne breve description de ce que fait ce paquet.\n\n## Installation\n\n\\`\\`\\`bash\nhpm install yourusername/my-package\n\\`\\`\\`\n\n## Utilisation\n\n\\`\\`\\`hemlock\nimport { parse } from \"yourusername/my-package\";\n\nlet result = parse(\"input\");\n\\`\\`\\`\n\n## API\n\n### parse(input: string): Result\n\nAnalyse la chaine d'entree.\n\n### stringify(obj: any): string\n\nConvertit un objet en chaine.\n\n## Licence\n\nMIT\n```\n\n### Documentation de l'API\n\nDocumentez tous les exports publics :\n\n```hemlock\n/// Analyse la chaine d'entree en un Result structure.\n///\n/// # Arguments\n/// * `input` - La chaine a analyser\n///\n/// # Retourne\n/// Un Result contenant les donnees analysees ou une erreur\n///\n/// # Exemple\n/// ```\n/// let result = parse(\"hello world\");\n/// print(result.value);\n/// ```\nexport fn parse(input: string): Result {\n    // Implementation\n}\n```\n\n## Directives de versionnage\n\nSuivez le [Versionnage semantique](https://semver.org/) :\n\n- **MAJEUR** (1.0.0 -> 2.0.0) : Changements incompatibles\n- **MINEUR** (1.0.0 -> 1.1.0) : Nouvelles fonctionnalites, retro-compatibles\n- **PATCH** (1.0.0 -> 1.0.1) : Corrections de bugs, retro-compatibles\n\n### Quand incrementer\n\n| Type de changement | Increment de version |\n|--------------------|---------------------|\n| Changement d'API incompatible | MAJEUR |\n| Suppression de fonction/type | MAJEUR |\n| Changement de signature de fonction | MAJEUR |\n| Ajout d'une nouvelle fonction | MINEUR |\n| Ajout d'une nouvelle fonctionnalite | MINEUR |\n| Correction de bug | PATCH |\n| Mise a jour de documentation | PATCH |\n| Refactoring interne | PATCH |\n\n## Voir aussi\n\n- [Specification des paquets](#hpm-creating-packages-package-spec) - Reference complete de package.json\n- [Versionnage](#hpm-creating-packages-versioning) - Details du versionnage semantique\n- [Configuration](#hpm-creating-packages-configuration) - Authentification GitHub\n"}, "hpm : Dveloppement de Paquets -> Gestion des Versions": {"id": "hpm-versioning", "content": "# Versionnage\n\nGuide complet du versionnage semantique dans hpm.\n\n## Versionnage semantique\n\nhpm utilise le [Versionnage semantique 2.0.0](https://semver.org/) (semver) pour les versions des paquets.\n\n### Format de version\n\n```\nMAJEUR.MINEUR.PATCH[-PRERELEASE][+BUILD]\n```\n\n**Exemples :**\n```\n1.0.0           # Version de release\n2.1.3           # Version de release\n1.0.0-alpha     # Pre-release\n1.0.0-beta.1    # Pre-release avec numero\n1.0.0-rc.1      # Release candidate\n1.0.0+20231201  # Avec metadonnees de build\n1.0.0-beta+exp  # Pre-release avec metadonnees de build\n```\n\n### Composants de version\n\n| Composant | Description | Exemple |\n|-----------|-------------|---------|\n| MAJEUR | Changements incompatibles | `1.0.0` -> `2.0.0` |\n| MINEUR | Nouvelles fonctionnalites (retro-compatible) | `1.0.0` -> `1.1.0` |\n| PATCH | Corrections de bugs (retro-compatible) | `1.0.0` -> `1.0.1` |\n| PRERELEASE | Identifiant de pre-release | `1.0.0-alpha` |\n| BUILD | Metadonnees de build (ignorees dans la comparaison) | `1.0.0+build123` |\n\n### Quand incrementer\n\n| Type de changement | Increment | Exemple |\n|--------------------|-----------|---------|\n| Changement d'API incompatible | MAJEUR | Suppression d'une fonction |\n| Renommer une fonction publique | MAJEUR | `parse()` -> `decode()` |\n| Changer la signature d'une fonction | MAJEUR | Ajouter un parametre obligatoire |\n| Ajouter une nouvelle fonction | MINEUR | Ajouter `validate()` |\n| Ajouter un parametre optionnel | MINEUR | Nouveau arg `options` optionnel |\n| Correction de bug | PATCH | Corriger un pointeur null |\n| Amelioration de performance | PATCH | Algorithme plus rapide |\n| Refactoring interne | PATCH | Pas de changement d'API |\n\n## Contraintes de version\n\n### Syntaxe des contraintes\n\n| Syntaxe | Signification | Resout vers |\n|---------|---------------|-------------|\n| `1.2.3` | Version exacte | 1.2.3 uniquement |\n| `^1.2.3` | Caret (compatible) | >=1.2.3 et <2.0.0 |\n| `~1.2.3` | Tilde (mises a jour patch) | >=1.2.3 et <1.3.0 |\n| `>=1.0.0` | Au moins | 1.0.0 ou superieur |\n| `>1.0.0` | Superieur a | Superieur a 1.0.0 |\n| `<2.0.0` | Inferieur a | Inferieur a 2.0.0 |\n| `<=2.0.0` | Au plus | 2.0.0 ou inferieur |\n| `>=1.0.0 <2.0.0` | Plage | Entre 1.0.0 et 2.0.0 |\n| `*` | N'importe quelle | N'importe quelle version |\n\n### Plages Caret (^)\n\nLe caret (`^`) permet les changements qui ne modifient pas le chiffre non-nul le plus a gauche :\n\n```\n^1.2.3  ->  >=1.2.3 <2.0.0   # Permet 1.x.x\n^0.2.3  ->  >=0.2.3 <0.3.0   # Permet 0.2.x\n^0.0.3  ->  >=0.0.3 <0.0.4   # Permet 0.0.3 uniquement\n```\n\n**Utilisez quand :** Vous voulez des mises a jour compatibles dans une version majeure.\n\n**Contrainte la plus courante** - recommandee pour la plupart des dependances.\n\n### Plages Tilde (~)\n\nLe tilde (`~`) permet uniquement les changements de niveau patch :\n\n```\n~1.2.3  ->  >=1.2.3 <1.3.0   # Permet 1.2.x\n~1.2    ->  >=1.2.0 <1.3.0   # Permet 1.2.x\n~1      ->  >=1.0.0 <2.0.0   # Permet 1.x.x\n```\n\n**Utilisez quand :** Vous voulez uniquement les corrections de bugs, pas de nouvelles fonctionnalites.\n\n### Plages de comparaison\n\nCombinez les operateurs de comparaison pour un controle precis :\n\n```json\n{\n  \"dependencies\": {\n    \"owner/pkg\": \">=1.0.0 <2.0.0\",\n    \"owner/other\": \">1.5.0 <=2.1.0\"\n  }\n}\n```\n\n### N'importe quelle version (*)\n\nCorrespond a n'importe quelle version :\n\n```json\n{\n  \"dependencies\": {\n    \"owner/pkg\": \"*\"\n  }\n}\n```\n\n**Attention :** Non recommande pour la production. Obtiendra toujours la derniere version.\n\n## Versions pre-release\n\n### Identifiants de pre-release\n\nLes pre-releases ont une precedence inferieure aux releases :\n\n```\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0\n```\n\n### Tags de pre-release courants\n\n| Tag | Signification | Etape |\n|-----|---------------|-------|\n| `alpha` | Developpement initial | Tres instable |\n| `beta` | Fonctionnalites completes | Tests |\n| `rc` | Release candidate | Tests finaux |\n| `dev` | Snapshot de developpement | Instable |\n\n### Pre-release dans les contraintes\n\nLes contraintes ne correspondent pas aux pre-releases par defaut :\n\n```\n^1.0.0    # Ne correspond PAS a 1.1.0-beta\n>=1.0.0   # Ne correspond PAS a 2.0.0-alpha\n```\n\nPour inclure les pre-releases, referencez-les explicitement :\n\n```\n>=1.0.0-alpha <2.0.0   # Inclut toutes les pre-releases 1.x\n```\n\n## Comparaison de versions\n\n### Regles de comparaison\n\n1. Comparez MAJEUR, MINEUR, PATCH numeriquement\n2. Release > pre-release avec la meme version\n3. Pre-releases comparees alphanumeriquement\n4. Les metadonnees de build sont ignorees\n\n### Exemples\n\n```\n1.0.0 < 1.0.1 < 1.1.0 < 2.0.0\n\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0\n\n1.0.0 = 1.0.0+build123  # Metadonnees de build ignorees\n```\n\n### Tri\n\nLes versions sont triees par ordre croissant :\n\n```\n1.0.0\n1.0.1\n1.1.0\n1.1.1\n2.0.0-alpha\n2.0.0-beta\n2.0.0\n```\n\n## Resolution de version\n\n### Algorithme de resolution\n\nQuand plusieurs paquets necessitent la meme dependance :\n\n1. Collecter toutes les contraintes\n2. Trouver l'intersection de toutes les plages\n3. Selectionner la version la plus elevee dans l'intersection\n4. Erreur si aucune version ne satisfait toutes les contraintes\n\n### Exemple de resolution\n\n```\npackage-a necessite hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npackage-b necessite hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)\n\nIntersection: >=1.2.0 <1.3.0\nDisponibles: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]\nResolue: 1.2.5 (la plus elevee dans l'intersection)\n```\n\n### Detection de conflits\n\nUn conflit survient quand aucune version ne satisfait toutes les contraintes :\n\n```\npackage-a necessite hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npackage-b necessite hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)\n\nIntersection: (vide)\nResultat: CONFLIT - aucune version ne satisfait les deux\n```\n\n## Bonnes pratiques\n\n### Pour les consommateurs de paquets\n\n1. **Utilisez des plages caret** pour la plupart des dependances :\n   ```json\n   \"hemlang/json\": \"^1.2.0\"\n   ```\n\n2. **Utilisez des plages tilde** pour les dependances critiques :\n   ```json\n   \"critical/lib\": \"~1.2.0\"\n   ```\n\n3. **Epinglez les versions** uniquement si necessaire :\n   ```json\n   \"unstable/pkg\": \"1.2.3\"\n   ```\n\n4. **Commitez votre fichier de verrouillage** pour des builds reproductibles\n\n5. **Mettez a jour regulierement** pour obtenir les correctifs de securite :\n   ```bash\n   hpm update\n   hpm outdated\n   ```\n\n### Pour les auteurs de paquets\n\n1. **Commencez a 0.1.0** pour le developpement initial :\n   - L'API peut changer frequemment\n   - Les utilisateurs s'attendent a de l'instabilite\n\n2. **Passez a 1.0.0** quand l'API est stable :\n   - Engagement public envers la stabilite\n   - Les changements incompatibles necessitent un increment majeur\n\n3. **Suivez strictement semver** :\n   - Changement incompatible = MAJEUR\n   - Nouvelle fonctionnalite = MINEUR\n   - Correction de bug = PATCH\n\n4. **Utilisez les pre-releases** pour les tests :\n   ```bash\n   git tag v2.0.0-beta.1\n   git push --tags\n   ```\n\n5. **Documentez les changements incompatibles** dans le CHANGELOG\n\n## Publication de versions\n\n### Creer des releases\n\n```bash\n# Mettre a jour la version dans package.json\n# Editez package.json : \"version\": \"1.1.0\"\n\n# Commiter le changement de version\ngit add package.json\ngit commit -m \"Bump version to 1.1.0\"\n\n# Creer et pousser le tag\ngit tag v1.1.0\ngit push origin main --tags\n```\n\n### Format des tags\n\nLes tags **doivent** commencer par `v` :\n\n```\nv1.0.0      Correct\nv1.0.0-beta Correct\n1.0.0       Ne sera pas reconnu\n```\n\n### Flux de travail de release\n\n```bash\n# 1. S'assurer que les tests passent\nhpm test\n\n# 2. Mettre a jour la version dans package.json\n# 3. Mettre a jour CHANGELOG.md\n# 4. Commiter les changements\ngit add -A\ngit commit -m \"Release v1.2.0\"\n\n# 5. Creer le tag\ngit tag v1.2.0\n\n# 6. Tout pousser\ngit push origin main --tags\n```\n\n## Verifier les versions\n\n### Lister les versions installees\n\n```bash\nhpm list\n```\n\n### Verifier les mises a jour disponibles\n\n```bash\nhpm outdated\n```\n\nSortie :\n```\nPackage         Current  Wanted  Latest\nhemlang/json    1.0.0    1.0.5   1.2.0\nhemlang/sprout  2.0.0    2.0.3   2.1.0\n```\n\n- **Current** : Version installee\n- **Wanted** : Plus haute correspondant a la contrainte\n- **Latest** : Derniere disponible\n\n### Mettre a jour les paquets\n\n```bash\n# Mettre a jour tout\nhpm update\n\n# Mettre a jour un paquet specifique\nhpm update hemlang/json\n```\n\n## Voir aussi\n\n- [Creer des paquets](#hpm-versioning-creating-packages) - Guide de publication\n- [Specification des paquets](#hpm-versioning-package-spec) - Format package.json\n- [Commandes](#hpm-versioning-commands) - Reference CLI\n"}, "hpm : Dveloppement de Paquets -> Spcification des Paquets": {"id": "hpm-package-spec", "content": "# Specification des paquets\n\nReference complete pour le format du fichier `package.json`.\n\n## Apercu\n\nChaque paquet hpm necessite un fichier `package.json` a la racine du projet. Ce fichier definit les metadonnees du paquet, les dependances et les scripts.\n\n## Exemple minimal\n\n```json\n{\n  \"name\": \"owner/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n## Exemple complet\n\n```json\n{\n  \"name\": \"hemlang/example-package\",\n  \"version\": \"1.2.3\",\n  \"description\": \"An example Hemlock package\",\n  \"author\": \"Hemlock Team <team@hemlock.dev>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/hemlang/example-package\",\n  \"homepage\": \"https://hemlang.github.io/example-package\",\n  \"bugs\": \"https://github.com/hemlang/example-package/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"example\", \"utility\", \"hemlock\"],\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"^2.1.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/bundle.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n## Reference des champs\n\n### name (obligatoire)\n\nLe nom du paquet au format `owner/repo`.\n\n```json\n{\n  \"name\": \"hemlang/sprout\"\n}\n```\n\n**Exigences :**\n- Doit etre au format `owner/repo`\n- `owner` doit etre votre nom d'utilisateur GitHub ou organisation\n- `repo` doit etre le nom du depot\n- Utilisez des lettres minuscules, des chiffres et des tirets\n- Maximum 214 caracteres au total\n\n**Noms valides :**\n```\nhemlang/sprout\nalice/http-client\nmyorg/json-utils\nbob123/my-lib\n```\n\n**Noms invalides :**\n```\nmy-package          # Proprietaire manquant\nhemlang/My_Package  # Majuscules et underscore\nhemlang             # Depot manquant\n```\n\n### version (obligatoire)\n\nLa version du paquet suivant le [Versionnage semantique](https://semver.org/).\n\n```json\n{\n  \"version\": \"1.2.3\"\n}\n```\n\n**Format :** `MAJEUR.MINEUR.PATCH[-PRERELEASE][+BUILD]`\n\n**Versions valides :**\n```\n1.0.0\n2.1.3\n1.0.0-alpha\n1.0.0-beta.1\n1.0.0-rc.1+build.123\n0.1.0\n```\n\n### description\n\nDescription courte du paquet.\n\n```json\n{\n  \"description\": \"A fast JSON parser for Hemlock\"\n}\n```\n\n- Gardez-la sous 200 caracteres\n- Decrivez ce que fait le paquet, pas comment\n\n### author\n\nInformations sur l'auteur du paquet.\n\n```json\n{\n  \"author\": \"Your Name <email@example.com>\"\n}\n```\n\n**Formats acceptes :**\n```json\n\"author\": \"Your Name\"\n\"author\": \"Your Name <email@example.com>\"\n\"author\": \"Your Name <email@example.com> (https://website.com)\"\n```\n\n### license\n\nL'identifiant de licence.\n\n```json\n{\n  \"license\": \"MIT\"\n}\n```\n\n**Licences courantes :**\n- `MIT` - Licence MIT\n- `Apache-2.0` - Licence Apache 2.0\n- `GPL-3.0` - Licence publique generale GNU v3.0\n- `BSD-3-Clause` - Licence BSD 3 clauses\n- `ISC` - Licence ISC\n- `UNLICENSED` - Proprietaire/prive\n\nUtilisez les [identifiants SPDX](https://spdx.org/licenses/) quand c'est possible.\n\n### repository\n\nLien vers le depot source.\n\n```json\n{\n  \"repository\": \"https://github.com/hemlang/sprout\"\n}\n```\n\n### homepage\n\nURL de la page d'accueil du projet.\n\n```json\n{\n  \"homepage\": \"https://sprout.hemlock.dev\"\n}\n```\n\n### bugs\n\nURL du gestionnaire de tickets.\n\n```json\n{\n  \"bugs\": \"https://github.com/hemlang/sprout/issues\"\n}\n```\n\n### main\n\nFichier point d'entree du paquet.\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\n**Defaut :** `src/index.hml`\n\nQuand les utilisateurs importent votre paquet :\n```hemlock\nimport { x } from \"owner/repo\";\n```\n\nhpm charge le fichier specifie dans `main`.\n\n**Ordre de resolution pour les imports :**\n1. Chemin exact : `src/index.hml`\n2. Avec extension .hml : `src/index` -> `src/index.hml`\n3. Fichier index : `src/index/` -> `src/index/index.hml`\n\n### keywords\n\nTableau de mots-cles pour la decouverte.\n\n```json\n{\n  \"keywords\": [\"json\", \"parser\", \"utility\", \"hemlock\"]\n}\n```\n\n- Utilisez des minuscules\n- Soyez specifique et pertinent\n- Incluez le langage (\"hemlock\") si approprie\n\n### dependencies\n\nDependances d'execution requises pour que le paquet fonctionne.\n\n```json\n{\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"~2.1.0\",\n    \"alice/logger\": \">=1.0.0 <2.0.0\"\n  }\n}\n```\n\n**Cle :** Nom du paquet (`owner/repo`)\n**Valeur :** Contrainte de version\n\n**Syntaxe des contraintes de version :**\n\n| Contrainte | Signification |\n|------------|---------------|\n| `1.2.3` | Version exacte |\n| `^1.2.3` | >=1.2.3 <2.0.0 |\n| `~1.2.3` | >=1.2.3 <1.3.0 |\n| `>=1.0.0` | Au moins 1.0.0 |\n| `>=1.0.0 <2.0.0` | Plage |\n| `*` | N'importe quelle version |\n\n### devDependencies\n\nDependances uniquement pour le developpement (tests, compilation, etc.).\n\n```json\n{\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\",\n    \"hemlang/linter\": \"^2.0.0\"\n  }\n}\n```\n\nLes dependances de developpement sont :\n- Installees pendant le developpement\n- Non installees quand le paquet est utilise comme dependance\n- Utilisees pour les tests, la compilation, le linting, etc.\n\n### scripts\n\nCommandes nommees qui peuvent etre executees avec `hpm run`.\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n**Executer des scripts :**\n```bash\nhpm run start\nhpm run build\nhpm test        # Raccourci pour 'hpm run test'\n```\n\n**Passer des arguments :**\n```bash\nhpm run test -- --verbose --filter=unit\n```\n\n**Scripts courants :**\n\n| Script | Objectif |\n|--------|----------|\n| `start` | Demarrer l'application |\n| `dev` | Mode developpement avec rechargement a chaud |\n| `test` | Executer les tests |\n| `build` | Compiler pour la production |\n| `clean` | Supprimer les artefacts de compilation |\n| `lint` | Verifier le style du code |\n| `format` | Formater le code |\n\n### files\n\nFichiers et repertoires a inclure quand le paquet est installe.\n\n```json\n{\n  \"files\": [\n    \"src/\",\n    \"lib/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n**Comportement par defaut :** Si non specifie, inclut :\n- Tous les fichiers du depot\n- Exclut `.git/`, `node_modules/`, `hem_modules/`\n\n**Utilisez pour :**\n- Reduire la taille du paquet\n- Exclure les fichiers de test de la distribution\n- Inclure uniquement les fichiers necessaires\n\n### native\n\nExigences de bibliotheques natives.\n\n```json\n{\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\", \"sqlite3\"]\n  }\n}\n```\n\nDocumente les dependances natives qui doivent etre installees sur le systeme.\n\n## Validation\n\nhpm valide package.json lors de diverses operations. Erreurs de validation courantes :\n\n### Champs obligatoires manquants\n\n```\nError: package.json missing required field: name\n```\n\n**Correction :** Ajoutez le champ obligatoire.\n\n### Format de nom invalide\n\n```\nError: Invalid package name. Must be in owner/repo format.\n```\n\n**Correction :** Utilisez le format `owner/repo`.\n\n### Version invalide\n\n```\nError: Invalid version \"1.0\". Must be semver format (X.Y.Z).\n```\n\n**Correction :** Utilisez le format semver complet (`1.0.0`).\n\n### JSON invalide\n\n```\nError: package.json is not valid JSON\n```\n\n**Correction :** Verifiez la syntaxe JSON (virgules, guillemets, crochets).\n\n## Creer package.json\n\n### Interactif\n\n```bash\nhpm init\n```\n\nDemande chaque champ de maniere interactive.\n\n### Avec les valeurs par defaut\n\n```bash\nhpm init --yes\n```\n\nCree avec les valeurs par defaut :\n```json\n{\n  \"name\": \"directory-name/directory-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\n### Manuel\n\nCreez le fichier manuellement :\n\n```bash\ncat > package.json << 'EOF'\n{\n  \"name\": \"yourname/your-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Your package description\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\nEOF\n```\n\n## Bonnes pratiques\n\n1. **Specifiez toujours main** - Ne vous fiez pas a la valeur par defaut\n2. **Utilisez des plages caret** - `^1.0.0` pour la plupart des dependances\n3. **Separez les dependances de developpement** - Gardez les deps test/build dans devDependencies\n4. **Incluez des mots-cles** - Aidez les utilisateurs a trouver votre paquet\n5. **Documentez les scripts** - Nommez les scripts clairement\n6. **Specifiez la licence** - Obligatoire pour l'open source\n7. **Ajoutez une description** - Aidez les utilisateurs a comprendre l'objectif\n\n## Voir aussi\n\n- [Creer des paquets](#hpm-package-spec-creating-packages) - Guide de publication\n- [Versionnage](#hpm-package-spec-versioning) - Contraintes de version\n- [Configuration du projet](#hpm-package-spec-project-setup) - Structure du projet\n"}, "hpm : Rfrence -> Architecture": {"id": "hpm-architecture", "content": "# Architecture\n\nArchitecture interne et conception de hpm. Ce document est destine aux contributeurs et a ceux qui souhaitent comprendre comment fonctionne hpm.\n\n## Apercu\n\nhpm est ecrit en Hemlock et se compose de plusieurs modules qui gerent differents aspects de la gestion des paquets :\n\n```\nsrc/\n main.hml        # Point d'entree CLI et routage des commandes\n manifest.hml    # Gestion de package.json\n lockfile.hml    # Gestion de package-lock.json\n semver.hml      # Versionnage semantique\n resolver.hml    # Resolution des dependances\n github.hml      # Client API GitHub\n installer.hml   # Telechargement et extraction des paquets\n cache.hml       # Gestion du cache global\n```\n\n## Responsabilites des modules\n\n### main.hml\n\nLe point d'entree de l'application CLI.\n\n**Responsabilites :**\n- Analyser les arguments de ligne de commande\n- Router les commandes vers les gestionnaires appropries\n- Afficher l'aide et les informations de version\n- Gerer les options globales (--verbose, --dry-run, etc.)\n- Sortir avec les codes appropries\n\n**Fonctions principales :**\n- `main()` - Point d'entree, analyse les args et dispatche les commandes\n- `cmd_init()` - Gerer `hpm init`\n- `cmd_install()` - Gerer `hpm install`\n- `cmd_uninstall()` - Gerer `hpm uninstall`\n- `cmd_update()` - Gerer `hpm update`\n- `cmd_list()` - Gerer `hpm list`\n- `cmd_outdated()` - Gerer `hpm outdated`\n- `cmd_run()` - Gerer `hpm run`\n- `cmd_why()` - Gerer `hpm why`\n- `cmd_cache()` - Gerer `hpm cache`\n\n**Raccourcis de commandes :**\n```hemlock\nlet shortcuts = {\n    \"i\": \"install\",\n    \"rm\": \"uninstall\",\n    \"remove\": \"uninstall\",\n    \"ls\": \"list\",\n    \"up\": \"update\"\n};\n```\n\n### manifest.hml\n\nGere la lecture et l'ecriture des fichiers `package.json`.\n\n**Responsabilites :**\n- Lire/ecrire package.json\n- Valider la structure du paquet\n- Gerer les dependances\n- Analyser les specificateurs de paquets (owner/repo@version)\n\n**Fonctions principales :**\n```hemlock\ncreate_default(): Manifest           // Creer un manifeste vide\nread_manifest(): Manifest            // Lire depuis le fichier\nwrite_manifest(m: Manifest)          // Ecrire dans le fichier\nvalidate(m: Manifest): bool          // Valider la structure\nget_all_dependencies(m): Map         // Obtenir deps + devDeps\nadd_dependency(m, pkg, ver, dev)     // Ajouter une dependance\nremove_dependency(m, pkg)            // Supprimer une dependance\nparse_specifier(spec): (name, ver)   // Analyser \"owner/repo@^1.0.0\"\nsplit_name(name): (owner, repo)      // Analyser \"owner/repo\"\n```\n\n**Structure Manifest :**\n```hemlock\ntype Manifest = {\n    name: string,\n    version: string,\n    description: string?,\n    author: string?,\n    license: string?,\n    repository: string?,\n    main: string?,\n    dependencies: Map<string, string>,\n    devDependencies: Map<string, string>,\n    scripts: Map<string, string>\n};\n```\n\n### lockfile.hml\n\nGere le fichier `package-lock.json` pour des installations reproductibles.\n\n**Responsabilites :**\n- Creer/lire/ecrire les fichiers de verrouillage\n- Suivre les versions exactes resolues\n- Stocker les URLs de telechargement et les hashes d'integrite\n- Elaguer les dependances orphelines\n\n**Fonctions principales :**\n```hemlock\ncreate_empty(): Lockfile              // Creer un lockfile vide\nread_lockfile(): Lockfile             // Lire depuis le fichier\nwrite_lockfile(l: Lockfile)           // Ecrire dans le fichier\ncreate_entry(ver, url, hash, deps)    // Creer une entree de verrouillage\nget_locked(l, pkg): LockEntry?        // Obtenir la version verrouillee\nset_locked(l, pkg, entry)             // Definir la version verrouillee\nremove_locked(l, pkg)                 // Supprimer une entree\nprune(l, keep: Set)                   // Supprimer les orphelins\nneeds_update(l, m): bool              // Verifier si desynchronise\n```\n\n**Structure Lockfile :**\n```hemlock\ntype Lockfile = {\n    lockVersion: int,\n    hemlock: string,\n    dependencies: Map<string, LockEntry>\n};\n\ntype LockEntry = {\n    version: string,\n    resolved: string,     // URL de telechargement\n    integrity: string,    // Hash SHA256\n    dependencies: Map<string, string>\n};\n```\n\n### semver.hml\n\nImplementation complete du Versionnage semantique 2.0.0.\n\n**Responsabilites :**\n- Analyser les chaines de version\n- Comparer les versions\n- Analyser et evaluer les contraintes de version\n- Trouver les versions satisfaisant les contraintes\n\n**Fonctions principales :**\n```hemlock\n// Analyse\nparse(s: string): Version             // \"1.2.3-beta+build\" -> Version\nstringify(v: Version): string         // Version -> \"1.2.3-beta+build\"\n\n// Comparaison\ncompare(a, b: Version): int           // -1, 0, ou 1\ngt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool\n\n// Contraintes\nparse_constraint(s: string): Constraint    // \"^1.2.3\" -> Constraint\nsatisfies(v: Version, c: Constraint): bool // Verifier si v correspond a c\nmax_satisfying(versions, c): Version?      // Trouver la plus haute correspondance\nsort(versions): [Version]                  // Trier par ordre croissant\n\n// Utilitaires\nconstraints_overlap(a, b: Constraint): bool  // Verifier la compatibilite\n```\n\n**Structure Version :**\n```hemlock\ntype Version = {\n    major: int,\n    minor: int,\n    patch: int,\n    prerelease: [string]?,  // ex: [\"beta\", \"1\"]\n    build: string?          // ex: \"20230101\"\n};\n```\n\n**Types de contraintes :**\n```hemlock\ntype Constraint =\n    | Exact(Version)           // \"1.2.3\"\n    | Caret(Version)           // \"^1.2.3\" -> >=1.2.3 <2.0.0\n    | Tilde(Version)           // \"~1.2.3\" -> >=1.2.3 <1.3.0\n    | Range(op, Version)       // \">=1.0.0\", \"<2.0.0\"\n    | And(Constraint, Constraint)  // Plages combinees\n    | Any;                     // \"*\"\n```\n\n### resolver.hml\n\nImplemente la resolution de dependances style npm.\n\n**Responsabilites :**\n- Resoudre les arbres de dependances\n- Detecter les conflits de version\n- Detecter les dependances circulaires\n- Construire des arbres de visualisation\n\n**Fonctions principales :**\n```hemlock\nresolve(manifest, lockfile): ResolveResult\n    // Resolveur principal : retourne une map plate de toutes les dependances avec versions resolues\n\nresolve_version(pkg, constraints: [string]): ResolvedPackage?\n    // Trouver une version satisfaisant toutes les contraintes\n\ndetect_cycles(deps: Map): [Cycle]?\n    // Trouver les dependances circulaires en utilisant DFS\n\nbuild_tree(lockfile): Tree\n    // Creer une structure d'arbre pour l'affichage\n\nfind_why(pkg, lockfile): [Chain]\n    // Trouver les chaines de dependances expliquant pourquoi pkg est installe\n```\n\n**Algorithme de resolution :**\n\n1. **Collecter les contraintes** : Parcourir le manifeste et les dependances transitives\n2. **Resoudre chaque paquet** : Pour chaque paquet :\n   - Obtenir toutes les contraintes de version des dependants\n   - Recuperer les versions disponibles depuis GitHub\n   - Trouver la version la plus haute satisfaisant TOUTES les contraintes\n   - Erreur si aucune version ne satisfait toutes (conflit)\n3. **Detecter les cycles** : Executer DFS pour trouver les dependances circulaires\n4. **Retourner une map plate** : Nom du paquet -> info de version resolue\n\n**Structure ResolveResult :**\n```hemlock\ntype ResolveResult = {\n    packages: Map<string, ResolvedPackage>,\n    conflicts: [Conflict]?,\n    cycles: [Cycle]?\n};\n\ntype ResolvedPackage = {\n    name: string,\n    version: Version,\n    url: string,\n    dependencies: Map<string, string>\n};\n```\n\n### github.hml\n\nClient API GitHub pour la decouverte et le telechargement de paquets.\n\n**Responsabilites :**\n- Recuperer les versions disponibles (tags)\n- Telecharger package.json depuis les depots\n- Telecharger les tarballs de release\n- Gerer l'authentification et les limites de taux\n\n**Fonctions principales :**\n```hemlock\nget_token(): string?\n    // Obtenir le token depuis env ou config\n\ngithub_request(url, headers?): Response\n    // Faire une requete API avec reessais\n\nget_tags(owner, repo): [string]\n    // Obtenir les tags de version (v1.0.0, v1.1.0, etc.)\n\nget_package_json(owner, repo, ref): Manifest\n    // Recuperer package.json a un tag/commit specifique\n\ndownload_tarball(owner, repo, tag): bytes\n    // Telecharger l'archive de release\n\nrepo_exists(owner, repo): bool\n    // Verifier si le depot existe\n\nget_repo_info(owner, repo): RepoInfo\n    // Obtenir les metadonnees du depot\n```\n\n**Logique de reessai :**\n- Backoff exponentiel : 1s, 2s, 4s, 8s\n- Reessaie sur : 403 (limite de taux), 5xx (erreur serveur), erreurs reseau\n- Maximum 4 reessais\n- Signale clairement les erreurs de limite de taux\n\n**Points de terminaison API utilises :**\n```\nGET /repos/{owner}/{repo}/tags\nGET /repos/{owner}/{repo}/contents/package.json?ref={tag}\nGET /repos/{owner}/{repo}/tarball/{tag}\nGET /repos/{owner}/{repo}\n```\n\n### installer.hml\n\nGere le telechargement et l'extraction des paquets.\n\n**Responsabilites :**\n- Telecharger les paquets depuis GitHub\n- Extraire les tarballs vers hem_modules\n- Verifier/utiliser les paquets en cache\n- Installer/desinstaller les paquets\n\n**Fonctions principales :**\n```hemlock\ninstall_package(pkg: ResolvedPackage): bool\n    // Telecharger et installer un seul paquet\n\ninstall_all(packages: Map, options): InstallResult\n    // Installer tous les paquets resolus\n\nuninstall_package(name: string): bool\n    // Supprimer un paquet de hem_modules\n\nget_installed(): Map<string, string>\n    // Lister les paquets actuellement installes\n\nverify_integrity(pkg): bool\n    // Verifier l'integrite du paquet\n\nprefetch_packages(packages: Map): void\n    // Telechargement parallele vers le cache (experimental)\n```\n\n**Processus d'installation :**\n\n1. Verifier si deja installe a la bonne version\n2. Verifier le cache pour le tarball\n3. Si pas en cache, telecharger depuis GitHub\n4. Stocker dans le cache pour utilisation future\n5. Extraire vers `hem_modules/owner/repo/`\n6. Verifier l'installation\n\n**Structure de repertoire creee :**\n```\nhem_modules/\n owner/\n     repo/\n         package.json\n         src/\n         ...\n```\n\n### cache.hml\n\nGere le cache global des paquets.\n\n**Responsabilites :**\n- Stocker les tarballs telecharges\n- Recuperer les paquets en cache\n- Lister les paquets en cache\n- Vider le cache\n- Gerer la configuration\n\n**Fonctions principales :**\n```hemlock\nget_cache_dir(): string\n    // Obtenir le repertoire de cache (respecte HPM_CACHE_DIR)\n\nget_config_dir(): string\n    // Obtenir le repertoire de config (~/.hpm)\n\nis_cached(owner, repo, version): bool\n    // Verifier si le tarball est en cache\n\nget_cached_path(owner, repo, version): string\n    // Obtenir le chemin vers le tarball en cache\n\nstore_tarball_file(owner, repo, version, data): void\n    // Sauvegarder le tarball dans le cache\n\nlist_cached(): [CachedPackage]\n    // Lister tous les paquets en cache\n\nclear_cache(): int\n    // Supprimer tous les paquets en cache, retourner les octets liberes\n\nget_cache_size(): int\n    // Calculer la taille totale du cache\n\nread_config(): Config\n    // Lire ~/.hpm/config.json\n\nwrite_config(c: Config): void\n    // Ecrire le fichier de config\n```\n\n**Structure du cache :**\n```\n~/.hpm/\n config.json\n cache/\n     owner/\n         repo/\n             1.0.0.tar.gz\n             1.1.0.tar.gz\n```\n\n## Flux de donnees\n\n### Flux de la commande Install\n\n```\nhpm install owner/repo@^1.0.0\n         \n         \n    \n     main.hml  Analyser les args, appeler cmd_install\n    \n         \n         \n    \n    manifest.hml Lire package.json, ajouter la dependance\n    \n         \n         \n    \n    resolver.hml Resoudre toutes les dependances\n    \n         \n         \n                        \n        \n     github.hml     semver.hml Obtenir versions, trouver satisfaisante\n        \n         \n         \n    \n    installer.hml Telecharger et extraire les paquets\n    \n         \n         \n                        \n        \n     github.hml     cache.hml Telecharger ou utiliser le cache\n        \n         \n         \n    \n    lockfile.hml Mettre a jour package-lock.json\n    \n```\n\n### Detail de l'algorithme de resolution\n\n```\nEntree: manifest.dependencies, manifest.devDependencies, lockfile existant\n\n1. Initialiser:\n   - constraints = {} // Map<string, [Constraint]>\n   - resolved = {}    // Map<string, ResolvedPackage>\n   - queue = [dependances directes]\n\n2. Tant que queue non vide:\n   a. pkg = queue.pop()\n   b. Si pkg deja resolu, passer\n   c. Obtenir toutes les contraintes pour pkg depuis les dependants\n   d. Recuperer les versions disponibles depuis GitHub (en cache)\n   e. Trouver la version max satisfaisant toutes les contraintes\n   f. Si aucune trouvee: CONFLIT\n   g. resolved[pkg] = {version, url, deps}\n   h. Ajouter les dependances de pkg a la queue\n\n3. Detecter les cycles dans le graphe resolu\n   - Si cycle trouve: ERREUR\n\n4. Retourner la map resolue\n```\n\n## Gestion des erreurs\n\n### Codes de sortie\n\nDefinis dans main.hml :\n\n```hemlock\nlet EXIT_SUCCESS = 0;\nlet EXIT_CONFLICT = 1;\nlet EXIT_NOT_FOUND = 2;\nlet EXIT_VERSION_NOT_FOUND = 3;\nlet EXIT_NETWORK = 4;\nlet EXIT_INVALID_MANIFEST = 5;\nlet EXIT_INTEGRITY = 6;\nlet EXIT_RATE_LIMIT = 7;\nlet EXIT_CIRCULAR = 8;\n```\n\n### Propagation des erreurs\n\nLes erreurs remontent via les valeurs de retour :\n\n```hemlock\nfn resolve_version(pkg): Result<Version, ResolveError> {\n    let versions = github.get_tags(owner, repo)?;  // ? propage\n    // ...\n}\n```\n\n## Tests\n\n### Framework de test\n\nFramework de test personnalise dans `test/framework.hml` :\n\n```hemlock\nfn suite(name: string, tests: fn()) {\n    print(\"Suite: \" + name);\n    tests();\n}\n\nfn test(name: string, body: fn()) {\n    try {\n        body();\n        print(\"   \" + name);\n    } catch e {\n        print(\"   \" + name + \": \" + e);\n        failed += 1;\n    }\n}\n\nfn assert_eq<T>(actual: T, expected: T) {\n    if actual != expected {\n        throw \"Expected \" + expected + \", got \" + actual;\n    }\n}\n```\n\n### Fichiers de test\n\n- `test/test_semver.hml` - Analyse de version, comparaison, contraintes\n- `test/test_manifest.hml` - Lecture/ecriture de manifeste, validation\n- `test/test_lockfile.hml` - Operations sur le lockfile\n- `test/test_cache.hml` - Gestion du cache\n\n### Executer les tests\n\n```bash\n# Tous les tests\nmake test\n\n# Tests specifiques\nmake test-semver\nmake test-manifest\nmake test-lockfile\nmake test-cache\n```\n\n## Ameliorations futures\n\n### Fonctionnalites prevues\n\n1. **Verification d'integrite** - Verification complete du hash SHA256\n2. **Workspaces** - Support des monorepos\n3. **Systeme de plugins** - Commandes extensibles\n4. **Audit** - Verification des vulnerabilites de securite\n5. **Registre prive** - Hebergement de paquets auto-heberge\n\n### Limitations connues\n\n1. **Bug du bundler** - Ne peut pas creer d'executable autonome\n2. **Telechargements paralleles** - Experimental, peut avoir des conditions de course\n3. **Integrite** - SHA256 pas completement implemente\n\n## Contribuer\n\n### Style de code\n\n- Utilisez une indentation de 4 espaces\n- Les fonctions doivent faire une seule chose\n- Commentez la logique complexe\n- Ecrivez des tests pour les nouvelles fonctionnalites\n\n### Ajouter une commande\n\n1. Ajoutez un gestionnaire dans `main.hml` :\n   ```hemlock\n   fn cmd_newcmd(args: [string]) {\n       // Implementation\n   }\n   ```\n\n2. Ajoutez au dispatch de commande :\n   ```hemlock\n   match command {\n       \"newcmd\" => cmd_newcmd(args),\n       // ...\n   }\n   ```\n\n3. Mettez a jour le texte d'aide\n\n### Ajouter un module\n\n1. Creez `src/newmodule.hml`\n2. Exportez l'interface publique\n3. Importez dans les modules qui en ont besoin\n4. Ajoutez des tests dans `test/test_newmodule.hml`\n\n## Voir aussi\n\n- [Commandes](#hpm-architecture-commands) - Reference CLI\n- [Creer des paquets](#hpm-architecture-creating-packages) - Developpement de paquets\n- [Versionnage](#hpm-architecture-versioning) - Versionnage semantique\n"}, "hpm : Rfrence -> Codes de Sortie": {"id": "hpm-exit-codes", "content": "# Codes de sortie\n\nReference des codes de sortie de hpm et leur signification.\n\n## Tableau des codes de sortie\n\n| Code | Nom | Description |\n|------|-----|-------------|\n| 0 | SUCCESS | Commande executee avec succes |\n| 1 | CONFLICT | Conflit de version de dependance |\n| 2 | NOT_FOUND | Paquet non trouve |\n| 3 | VERSION_NOT_FOUND | Version demandee non trouvee |\n| 4 | NETWORK | Erreur reseau |\n| 5 | INVALID_MANIFEST | package.json invalide |\n| 6 | INTEGRITY | Echec de la verification d'integrite |\n| 7 | RATE_LIMIT | Limite de taux de l'API GitHub depassee |\n| 8 | CIRCULAR | Dependance circulaire detectee |\n\n## Descriptions detaillees\n\n### Code de sortie 0 : SUCCESS\n\nLa commande s'est executee avec succes.\n\n```bash\n$ hpm install\nInstalled 5 packages\n$ echo $?\n0\n```\n\n### Code de sortie 1 : CONFLICT\n\nDeux paquets ou plus necessitent des versions incompatibles d'une dependance.\n\n**Exemple :**\n```\nError: Dependency conflict for hemlang/json\n\n  package-a requires hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)\n  package-b requires hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)\n\nNo version satisfies all constraints.\n```\n\n**Solutions :**\n1. Verifiez quels paquets ont le conflit :\n   ```bash\n   hpm why hemlang/json\n   ```\n2. Mettez a jour le paquet en conflit :\n   ```bash\n   hpm update package-a\n   ```\n3. Assouplissez les contraintes de version dans package.json\n4. Supprimez un des paquets en conflit\n\n### Code de sortie 2 : NOT_FOUND\n\nLe paquet specifie n'existe pas sur GitHub.\n\n**Exemple :**\n```\nError: Package not found: hemlang/nonexistent\n\nThe repository hemlang/nonexistent does not exist on GitHub.\n```\n\n**Solutions :**\n1. Verifiez l'orthographe du nom du paquet\n2. Verifiez si le depot existe : `https://github.com/owner/repo`\n3. Verifiez que vous avez acces (pour les depots prives, definissez GITHUB_TOKEN)\n\n### Code de sortie 3 : VERSION_NOT_FOUND\n\nAucune version ne correspond a la contrainte specifiee.\n\n**Exemple :**\n```\nError: No version of hemlang/json matches constraint ^5.0.0\n\nAvailable versions: 1.0.0, 1.1.0, 1.2.0, 2.0.0\n```\n\n**Solutions :**\n1. Verifiez les versions disponibles sur les releases/tags GitHub\n2. Utilisez une contrainte de version valide\n3. Les tags de version doivent commencer par 'v' (ex: `v1.0.0`)\n\n### Code de sortie 4 : NETWORK\n\nUne erreur liee au reseau s'est produite.\n\n**Exemple :**\n```\nError: Network error: could not connect to api.github.com\n\nPlease check your internet connection and try again.\n```\n\n**Solutions :**\n1. Verifiez votre connexion internet\n2. Verifiez si GitHub est accessible\n3. Verifiez les parametres du proxy si vous etes derriere un pare-feu\n4. Utilisez `--offline` si les paquets sont en cache :\n   ```bash\n   hpm install --offline\n   ```\n5. Attendez et reessayez (hpm reessaie automatiquement)\n\n### Code de sortie 5 : INVALID_MANIFEST\n\nLe fichier package.json est invalide ou malformation.\n\n**Exemple :**\n```\nError: Invalid package.json\n\n  - Missing required field: name\n  - Invalid version format: \"1.0\"\n```\n\n**Solutions :**\n1. Verifiez la syntaxe JSON (utilisez un validateur JSON)\n2. Assurez-vous que les champs obligatoires existent (`name`, `version`)\n3. Verifiez les formats des champs :\n   - name : format `owner/repo`\n   - version : format semver `X.Y.Z`\n4. Regenerez :\n   ```bash\n   rm package.json\n   hpm init\n   ```\n\n### Code de sortie 6 : INTEGRITY\n\nLa verification d'integrite du paquet a echoue.\n\n**Exemple :**\n```\nError: Integrity check failed for hemlang/json@1.0.0\n\nExpected: sha256-abc123...\nActual:   sha256-def456...\n\nThe downloaded package may be corrupted.\n```\n\n**Solutions :**\n1. Videz le cache et reinstallez :\n   ```bash\n   hpm cache clean\n   hpm install\n   ```\n2. Verifiez les problemes reseau (telechargements partiels)\n3. Verifiez que le paquet n'a pas ete altere\n\n### Code de sortie 7 : RATE_LIMIT\n\nLa limite de taux de l'API GitHub a ete depassee.\n\n**Exemple :**\n```\nError: GitHub API rate limit exceeded\n\nUnauthenticated rate limit: 60 requests/hour\nCurrent usage: 60/60\n\nRate limit resets at: 2024-01-15 10:30:00 UTC\n```\n\n**Solutions :**\n1. **S'authentifier avec GitHub** (recommande) :\n   ```bash\n   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx\n   hpm install\n   ```\n2. Attendre la reinitialisation de la limite de taux (reinitialisation horaire)\n3. Utiliser le mode hors ligne si les paquets sont en cache :\n   ```bash\n   hpm install --offline\n   ```\n\n### Code de sortie 8 : CIRCULAR\n\nDependance circulaire detectee dans le graphe de dependances.\n\n**Exemple :**\n```\nError: Circular dependency detected\n\n  package-a@1.0.0\n   package-b@1.0.0\n       package-a@1.0.0  (circular!)\n\nCannot resolve dependency tree.\n```\n\n**Solutions :**\n1. C'est generalement un bug dans les paquets eux-memes\n2. Contactez les mainteneurs des paquets\n3. Evitez d'utiliser un des paquets circulaires\n\n## Utiliser les codes de sortie dans les scripts\n\n### Bash\n\n```bash\n#!/bin/bash\n\nhpm install\nexit_code=$?\n\ncase $exit_code in\n  0)\n    echo \"Installation reussie\"\n    ;;\n  1)\n    echo \"Conflit de dependances - verifiez les contraintes de version\"\n    exit 1\n    ;;\n  2)\n    echo \"Paquet non trouve - verifiez le nom du paquet\"\n    exit 1\n    ;;\n  4)\n    echo \"Erreur reseau - verifiez la connexion\"\n    exit 1\n    ;;\n  7)\n    echo \"Limite de taux atteinte - definissez GITHUB_TOKEN\"\n    exit 1\n    ;;\n  *)\n    echo \"Erreur inconnue : $exit_code\"\n    exit 1\n    ;;\nesac\n```\n\n### CI/CD\n\n```yaml\n# GitHub Actions\n- name: Install dependencies\n  run: |\n    hpm install\n    if [ $? -eq 7 ]; then\n      echo \"::error::GitHub rate limit exceeded. Add GITHUB_TOKEN.\"\n      exit 1\n    fi\n  env:\n    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n### Make\n\n```makefile\ninstall:\n\t@hpm install || (echo \"Installation failed with code $$?\"; exit 1)\n\ntest: install\n\t@hpm test\n```\n\n## Depannage par code de sortie\n\n### Reference rapide\n\n| Code | Premiere chose a verifier |\n|------|---------------------------|\n| 1 | Executez `hpm why <package>` pour voir le conflit |\n| 2 | Verifiez le nom du paquet sur GitHub |\n| 3 | Verifiez les versions disponibles sur les tags GitHub |\n| 4 | Verifiez la connexion internet |\n| 5 | Validez la syntaxe de package.json |\n| 6 | Executez `hpm cache clean && hpm install` |\n| 7 | Definissez la variable d'environnement `GITHUB_TOKEN` |\n| 8 | Contactez les mainteneurs des paquets |\n\n## Voir aussi\n\n- [Depannage](#hpm-exit-codes-troubleshooting) - Solutions detaillees\n- [Commandes](#hpm-exit-codes-commands) - Reference des commandes\n- [Configuration](#hpm-exit-codes-configuration) - Configuration du token GitHub\n"}};

        // Mobile menu toggle
        const menuToggle = document.getElementById('menuToggle');
        const sidebar = document.getElementById('sidebar');

        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
            const isOpen = sidebar.classList.contains('open');
            menuToggle.textContent = isOpen ? '\u00d7' : '\u2630';
            menuToggle.setAttribute('aria-expanded', isOpen);
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth < 1024) {
                if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                    menuToggle.setAttribute('aria-expanded', 'false');
                }
            }
        });

        // Theme toggle functionality
        const themeToggle = document.getElementById('themeToggle');
        const root = document.documentElement;

        // Get saved theme or detect system preference
        function getPreferredTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                return savedTheme;
            }
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        // Apply theme
        function setTheme(theme) {
            root.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        }

        // Initialize theme
        const initialTheme = getPreferredTheme();
        if (localStorage.getItem('theme')) {
            setTheme(initialTheme);
        }

        // Toggle theme on button click
        themeToggle.addEventListener('click', () => {
            const currentTheme = root.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            // Determine current effective theme
            let effectiveTheme;
            if (currentTheme) {
                effectiveTheme = currentTheme;
            } else {
                effectiveTheme = prefersDark ? 'dark' : 'light';
            }

            // Toggle to opposite theme
            const newTheme = effectiveTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        });

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!localStorage.getItem('theme')) {
                // Only auto-switch if user hasn't manually set a preference
                root.removeAttribute('data-theme');
            }
        });

        // Markdown parser
        function parseMarkdown(md) {
            let lines = md.split('\n');
            let html = '';
            let inCodeBlock = false;
            let codeBlockContent = '';
            let codeBlockLang = '';
            let inList = false;
            let listContent = '';
            let inBlockquote = false;
            let blockquoteContent = '';
            let inTable = false;
            let tableRows = [];
            let tableHasHeader = false;

            function processInlineMarkdown(text) {
                text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
                text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
                return text;
            }

            function makeId(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/^-+|-+$/g, '');
            }

            function flushList() {
                if (inList && listContent) {
                    html += '<ul>\n' + listContent + '</ul>\n';
                    listContent = '';
                    inList = false;
                }
            }

            function flushBlockquote() {
                if (inBlockquote && blockquoteContent) {
                    html += '<blockquote>' + processInlineMarkdown(blockquoteContent.trim()) + '</blockquote>\n';
                    blockquoteContent = '';
                    inBlockquote = false;
                }
            }

            function flushTable() {
                if (inTable && tableRows.length > 0) {
                    html += '<table>\n';
                    for (let r = 0; r < tableRows.length; r++) {
                        const row = tableRows[r];
                        const isHeader = tableHasHeader && r === 0;
                        const tag = isHeader ? 'th' : 'td';
                        html += '<tr>\n';
                        for (const cell of row) {
                            html += '<' + tag + '>' + processInlineMarkdown(cell.trim()) + '</' + tag + '>\n';
                        }
                        html += '</tr>\n';
                    }
                    html += '</table>\n';
                    tableRows = [];
                    inTable = false;
                    tableHasHeader = false;
                }
            }

            function isTableSeparator(line) {
                return /^\|?[\s-:|]+\|[\s-:|]+\|?$/.test(line) && line.includes('-');
            }

            function parseTableRow(line) {
                let cells = line.split('|');
                // Remove empty first/last cells from leading/trailing |
                if (cells.length > 0 && cells[0].trim() === '') cells.shift();
                if (cells.length > 0 && cells[cells.length - 1].trim() === '') cells.pop();
                return cells;
            }

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                const trimmedLine = line.trim();

                // Handle code blocks (including indented ones in lists)
                if (trimmedLine.startsWith('```')) {
                    if (inCodeBlock) {
                        const codeId = 'code-' + Math.random().toString(36).substr(2, 9);
                        const langDisplay = codeBlockLang || 'code';
                        const copyIcon = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>';
                        html += `<div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">${langDisplay}</span>
                                <button class="copy-btn" onclick="copyCode('${codeId}')" aria-label="Copy code">${copyIcon}<span>Copy</span></button>
                            </div>
                            <pre><code id="${codeId}">` + escapeHtml(codeBlockContent) + '</code></pre></div>\n';
                        codeBlockContent = '';
                        codeBlockLang = '';
                        inCodeBlock = false;
                    } else {
                        flushList();
                        flushBlockquote();
                        inCodeBlock = true;
                        codeBlockLang = trimmedLine.substring(3).trim();
                    }
                    continue;
                }

                if (inCodeBlock) {
                    codeBlockContent += line + '\n';
                    continue;
                }

                // Table handling
                if (trimmedLine.includes('|')) {
                    if (trimmedLine.startsWith('|') || trimmedLine.endsWith('|')) {
                        flushList();
                        flushBlockquote();
                        if (isTableSeparator(trimmedLine)) {
                            // This is the separator row (|---|---|), mark header
                            if (tableRows.length === 1) {
                                tableHasHeader = true;
                            }
                        } else {
                            // Regular table row
                            tableRows.push(parseTableRow(trimmedLine));
                            inTable = true;
                        }
                        continue;
                    }
                }
                // Flush table if we hit a non-table line
                if (inTable) {
                    flushTable();
                }

                if (line.startsWith('# ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    const id = makeId(text);
                    html += `<h1 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h1>\n`;
                    continue;
                }
                if (line.startsWith('## ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(3).trim();
                    const id = makeId(text);
                    html += `<h2 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h2>\n`;
                    continue;
                }
                if (line.startsWith('### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(4).trim();
                    const id = makeId(text);
                    html += `<h3 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h3>\n`;
                    continue;
                }
                if (line.startsWith('#### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(5).trim();
                    const id = makeId(text);
                    html += `<h4 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h4>\n`;
                    continue;
                }

                if (line.trim() === '---') {
                    flushList();
                    flushBlockquote();
                    html += '<hr>\n';
                    continue;
                }

                if (line.startsWith('> ')) {
                    flushList();
                    blockquoteContent += line.substring(2) + ' ';
                    inBlockquote = true;
                    continue;
                } else if (inBlockquote && line.trim() === '') {
                    flushBlockquote();
                    continue;
                }

                if (line.startsWith('- ') || line.startsWith('* ')) {
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    listContent += '<li>' + processInlineMarkdown(text) + '</li>\n';
                    inList = true;
                    continue;
                } else if (inList && line.trim() !== '' && !line.startsWith('#')) {
                    listContent = listContent.trimEnd();
                    if (listContent.endsWith('</li>')) {
                        listContent = listContent.substring(0, listContent.length - 5);
                        listContent += ' ' + processInlineMarkdown(line.trim()) + '</li>\n';
                    }
                    continue;
                } else if (inList && line.trim() === '') {
                    flushList();
                    continue;
                }

                if (line.trim() === '') {
                    flushList();
                    flushBlockquote();
                    continue;
                }

                flushList();
                flushBlockquote();
                if (line.trim() !== '') {
                    html += '<p>' + processInlineMarkdown(line) + '</p>\n';
                }
            }

            flushList();
            flushBlockquote();
            flushTable();

            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Copy code to clipboard
        function copyCode(codeId) {
            const codeElement = document.getElementById(codeId);
            if (!codeElement) return;

            const text = codeElement.textContent;
            navigator.clipboard.writeText(text).then(() => {
                // Find the button that triggered this
                const btn = codeElement.closest('.code-block').querySelector('.copy-btn');
                if (btn) {
                    const originalText = btn.querySelector('span').textContent;
                    btn.classList.add('copied');
                    btn.querySelector('span').textContent = 'Copied!';

                    setTimeout(() => {
                        btn.classList.remove('copied');
                        btn.querySelector('span').textContent = originalText;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Load a page
        function loadPage(pageId) {
            const pageData = Object.values(PAGES).find(p => p.id === pageId);
            if (!pageData) {
                console.error('Page not found:', pageId);
                return;
            }

            const content = parseMarkdown(pageData.content);
            document.getElementById('content').innerHTML = content;

            // Update active nav link
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.dataset.page === pageId) {
                    link.classList.add('active');
                }
            });

            // Scroll to top
            window.scrollTo(0, 0);

            // Update URL hash
            window.location.hash = pageId;
        }

        // Setup navigation
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const pageId = link.dataset.page;
                loadPage(pageId);

                // Close mobile menu
                if (window.innerWidth < 1024) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                }
            });
        });

        // Handle browser back/forward
        window.addEventListener('hashchange', () => {
            const hash = window.location.hash.substring(1);
            if (hash) {
                loadPage(hash);
            }
        });

        // Search functionality
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const searchContainer = document.getElementById('searchContainer');
        const searchToggle = document.getElementById('searchToggle');
        let selectedIndex = -1;
        let currentResults = [];

        // Build search index from PAGES
        function buildSearchIndex() {
            const index = [];
            for (const [title, page] of Object.entries(PAGES)) {
                // Extract section from page ID
                const parts = page.id.split('-');
                let section = '';
                if (parts.length > 1) {
                    section = parts.slice(0, -1).join(' ');
                }

                // Extract headings from content
                const headings = [];
                const headingRegex = /^#+\s+(.+)$/gm;
                let match;
                while ((match = headingRegex.exec(page.content)) !== null) {
                    headings.push(match[1]);
                }

                // Get preview text (first 200 chars, stripped of markdown)
                let preview = page.content
                    .replace(/^#+\s+.+$/gm, '')  // Remove headings
                    .replace(/```[\s\S]*?```/g, '')  // Remove code blocks
                    .replace(/`[^`]+`/g, '')  // Remove inline code
                    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')  // Convert links to text
                    .replace(/\*\*([^*]+)\*\*/g, '$1')  // Remove bold
                    .replace(/\*([^*]+)\*/g, '$1')  // Remove italic
                    .replace(/\n+/g, ' ')  // Normalize whitespace
                    .trim()
                    .substring(0, 200);

                index.push({
                    title: title,
                    pageId: page.id,
                    section: section,
                    headings: headings,
                    content: page.content.toLowerCase(),
                    preview: preview
                });
            }
            return index;
        }

        const searchIndex = buildSearchIndex();

        // Search function
        function search(query) {
            if (!query || query.length < 2) return [];

            const q = query.toLowerCase().trim();
            const results = [];

            for (const item of searchIndex) {
                let score = 0;
                let matchedHeading = null;
                let matchContext = '';

                // Check title (highest priority)
                const titleLower = item.title.toLowerCase();
                if (titleLower === q) {
                    score = 100;
                } else if (titleLower.startsWith(q)) {
                    score = 80;
                } else if (titleLower.includes(q)) {
                    score = 60;
                }

                // Check headings
                for (const heading of item.headings) {
                    const headingLower = heading.toLowerCase();
                    if (headingLower === q) {
                        score = Math.max(score, 50);
                        matchedHeading = heading;
                    } else if (headingLower.includes(q)) {
                        score = Math.max(score, 40);
                        if (!matchedHeading) matchedHeading = heading;
                    }
                }

                // Check content
                if (item.content.includes(q)) {
                    score = Math.max(score, 20);

                    // Find context around the match
                    const idx = item.content.indexOf(q);
                    const start = Math.max(0, idx - 40);
                    const end = Math.min(item.content.length, idx + q.length + 60);
                    matchContext = item.content.substring(start, end);
                    if (start > 0) matchContext = '...' + matchContext;
                    if (end < item.content.length) matchContext = matchContext + '...';
                }

                if (score > 0) {
                    results.push({
                        title: item.title,
                        pageId: item.pageId,
                        section: item.section,
                        score: score,
                        matchedHeading: matchedHeading,
                        preview: matchContext || item.preview,
                        query: q
                    });
                }
            }

            // Sort by score descending
            results.sort((a, b) => b.score - a.score);

            return results.slice(0, 10);  // Limit to 10 results
        }

        // Highlight query in text
        function highlightText(text, query) {
            if (!query) return text;
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }

        // Render search results
        function renderResults(results, query) {
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-no-results">No results found</div>';
                return;
            }

            const html = results.map((result, index) => {
                const titleHtml = highlightText(result.title, query);
                const previewHtml = highlightText(result.preview, query);
                const selectedClass = index === selectedIndex ? ' selected' : '';

                return `
                    <div class="search-result${selectedClass}" data-index="${index}" data-page="${result.pageId}">
                        ${result.section ? `<div class="search-result-section">${result.section}</div>` : ''}
                        <div class="search-result-title">${titleHtml}</div>
                        ${result.matchedHeading ? `<div class="search-result-preview">${highlightText(result.matchedHeading, query)}</div>` : ''}
                        <div class="search-result-preview">${previewHtml}</div>
                    </div>
                `;
            }).join('');

            searchResults.innerHTML = html;

            // Add click handlers
            searchResults.querySelectorAll('.search-result').forEach(el => {
                el.addEventListener('click', () => {
                    const pageId = el.dataset.page;
                    loadPage(pageId);
                    closeSearch();
                });
            });
        }

        // Show search results
        function showResults() {
            searchResults.classList.add('active');
        }

        // Hide search results
        function hideResults() {
            searchResults.classList.remove('active');
            selectedIndex = -1;
        }

        // Close search (mobile)
        function closeSearch() {
            hideResults();
            searchInput.value = '';
            searchInput.blur();
            if (window.innerWidth < 769) {
                searchContainer.classList.remove('active');
            }
        }

        // Debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Handle search input
        const handleSearch = debounce((query) => {
            currentResults = search(query);
            if (query.length >= 2) {
                renderResults(currentResults, query);
                showResults();
            } else {
                hideResults();
            }
        }, 150);

        searchInput.addEventListener('input', (e) => {
            handleSearch(e.target.value);
        });

        // Handle keyboard navigation
        searchInput.addEventListener('keydown', (e) => {
            if (!searchResults.classList.contains('active')) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, currentResults.length - 1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIndex >= 0 && currentResults[selectedIndex]) {
                    loadPage(currentResults[selectedIndex].pageId);
                    closeSearch();
                } else if (currentResults.length > 0) {
                    loadPage(currentResults[0].pageId);
                    closeSearch();
                }
            } else if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Close results when clicking outside
        document.addEventListener('click', (e) => {
            if (!searchContainer.contains(e.target)) {
                hideResults();
            }
        });

        // Focus search on input click
        searchInput.addEventListener('focus', () => {
            if (searchInput.value.length >= 2) {
                handleSearch(searchInput.value);
            }
        });

        // Global keyboard shortcut (Ctrl+K or Cmd+K)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                if (window.innerWidth < 769) {
                    searchContainer.classList.add('active');
                }
                searchInput.focus();
            }
            if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Mobile search toggle
        if (searchToggle) {
            searchToggle.addEventListener('click', () => {
                searchContainer.classList.toggle('active');
                if (searchContainer.classList.contains('active')) {
                    searchInput.focus();
                }
            });
        }

        // Language switcher
        function switchLanguage(filename) {
            const currentHash = window.location.hash;
            window.location.href = filename + currentHash;
        }

        // Load initial page
        const initialHash = window.location.hash.substring(1);
        const firstPageId = Object.values(PAGES)[0].id;
        loadPage(initialHash || firstPageId);
    </script>
</body>
</html>