================================================================================
HEMLOCK PROGRAMMING LANGUAGE - COMPLETE DOCUMENTATION (Portugu√™s)
================================================================================

This file contains the complete documentation for the Hemlock programming
language and the hpm package manager in Portugu√™s.
It is optimized for LLM consumption.

Source: https://github.com/hemlang/hem-doc

--------------------------------------------------------------------------------
TABLE OF CONTENTS
--------------------------------------------------------------------------------

  1. Bem-vindo
  2. Refer√™ncia da Linguagem

[Primeiros Passos]
  3. Caminhos de Aprendizado
  4. Instala√ß√£o
  5. In√≠cio R√°pido
  6. Tutorial

[Guia da Linguagem]
  7. Arrays
  8. Correspond√™ncia de Padr√µes
  9. Fluxo de Controle
  10. Fun√ß√µes
  11. Gerenciamento de Mem√≥ria
  12. M√≥dulos
  13. Objetos
  14. Runas
  15. Sintaxe
  16. Strings
  17. Tipos
  18. Tratamento de Erros

[T√≥picos Avan√ßados]
  19. Argumentos de Linha de Comando
  20. Assincronismo e Concorr√™ncia
  21. Empacotamento e Distribui√ß√£o
  22. Execu√ß√£o de Comandos
  23. FFI
  24. File IO
  25. Memory Ownership
  26. Opera√ß√µes At√¥micas
  27. Perfilamento
  28. Sinais

[Refer√™ncia da API]
  29. API de Arquivos
  30. API de Arrays
  31. API de Concorr√™ncia
  32. API de Mem√≥ria
  33. API de Strings
  34. Fun√ß√µes Integradas
  35. Operadores
  36. Sistema de Tipos

[Design e Filosofia]
  37. Filosofia
  38. Implementa√ß√£o
  39. Sintaxe de Assinaturas

[Contribui√ß√£o]
  40. Diretrizes
  41. Testes

[hpm: Primeiros Passos]
  42. Configura√ß√£o do Projeto
  43. Instala√ß√£o
  44. In√≠cio R√°pido

[hpm: Guia do Usu√°rio]
  45. Comandos
  46. Configura√ß√£o
  47. Solu√ß√£o de Problemas

[hpm: Desenvolvimento de Pacotes]
  48. Cria√ß√£o de Pacotes
  49. Especifica√ß√£o de Pacotes
  50. Versionamento

[hpm: Refer√™ncia]
  51. Arquitetura
  52. C√≥digos de Sa√≠da


================================================================================
DOCUMENTATION
================================================================================

--------------------------------------------------------------------------------
## Bem-vindo
--------------------------------------------------------------------------------

# Bem-vindo ao Hemlock

> "Uma pequena linguagem insegura para escrever coisas inseguras com seguran√ßa."

**Hemlock** √© uma linguagem de scripting para sistemas que combina o poder do C com a ergonomia moderna de scripting. Ela oferece gerenciamento manual de mem√≥ria, controle expl√≠cito e concorr√™ncia ass√≠ncrona estruturada integrada.

## O que √© Hemlock?

Hemlock √© projetada para programadores que desejam:

- **Controle expl√≠cito** sobre mem√≥ria e execu√ß√£o
- **Sintaxe similar ao C** com conveni√™ncias modernas
- **Sem comportamento oculto** ou m√°gica
- **Async paralelo verdadeiro** com concorr√™ncia baseada em pthread

Hemlock N√ÉO √© uma linguagem com seguran√ßa de mem√≥ria e coleta de lixo. Em vez disso, ela fornece as ferramentas para ser seguro (`buffer`, anota√ß√µes de tipo, verifica√ß√£o de limites) sem for√ß√°-lo a us√°-las (`ptr`, mem√≥ria manual, opera√ß√µes inseguras).

## Exemplo R√°pido

```hemlock
// Ol√°, Hemlock!
fn greet(name: string): string {
    return `Ol√°, ${name}!`;
}

let message = greet("Mundo");
print(message);

// Gerenciamento manual de mem√≥ria
let buf = buffer(64);
buf[0] = 72;  // 'H'
buf[1] = 105; // 'i'
print(buf);
free(buf);
```

## Recursos em Resumo

| Recurso | Descri√ß√£o |
|---------|-----------|
| **Sistema de Tipos** | i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object |
| **Mem√≥ria** | Gerenciamento manual com `alloc()`, `buffer()`, `free()` |
| **Async** | `async`/`await` integrado com paralelismo pthread verdadeiro |
| **FFI** | Chame fun√ß√µes C diretamente de bibliotecas compartilhadas |
| **Biblioteca Padr√£o** | 40 m√≥dulos incluindo crypto, http, sqlite, json e mais |

## Primeiros Passos

Pronto para come√ßar? Veja como iniciar:

1. **[Instala√ß√£o](#getting-started-installation)** - Baixe e configure o Hemlock
2. **[In√≠cio R√°pido](#getting-started-quick-start)** - Escreva seu primeiro programa em minutos
3. **[Tutorial](#getting-started-tutorial)** - Aprenda Hemlock passo a passo

## Se√ß√µes da Documenta√ß√£o

- **Primeiros Passos** - Instala√ß√£o, guia de in√≠cio r√°pido e tutoriais
- **Guia da Linguagem** - Aprofunde-se em sintaxe, tipos, fun√ß√µes e mais
- **T√≥picos Avan√ßados** - Programa√ß√£o async, FFI, sinais e opera√ß√µes at√¥micas
- **Refer√™ncia da API** - Refer√™ncia completa de fun√ß√µes integradas e biblioteca padr√£o
- **Design e Filosofia** - Entenda por que Hemlock √© do jeito que √©

## Gerenciador de Pacotes

Hemlock vem com **hpm**, um gerenciador de pacotes para gerenciar depend√™ncias:

```bash
hpm init meu-projeto
hpm add algum-pacote
hpm run
```

Consulte as se√ß√µes da documenta√ß√£o do hpm para mais detalhes.

---

Use a navega√ß√£o √† esquerda para explorar a documenta√ß√£o, ou use a barra de pesquisa para encontrar t√≥picos espec√≠ficos.


--------------------------------------------------------------------------------
## Refer√™ncia da Linguagem
--------------------------------------------------------------------------------

# Filosofia de Design da Linguagem Hemlock

> "Uma linguagem pequena e n√£o-segura, para escrever c√≥digo n√£o-seguro de forma segura."

Este documento fornece uma visao geral da filosofia de design do Hemlock e uma referencia rapida da linguagem.
Explore as outras secoes de documentacao para guias detalhados e referencias de API.

---

## Posicionamento Central

Hemlock √© uma **linguagem de script de sistemas**, com gerenciamento manual de mem√≥ria e controle expl√≠cito:
- Poder da linguagem C com conveni√™ncia de script moderno
- Concorr√™ncia ass√≠ncrona estruturada integrada
- Sem comportamentos ocultos ou m√°gica

**Hemlock n√£o √©:** Segura em mem√≥ria, com coleta de lixo, nem esconde complexidade.
**Hemlock √©:** Expl√≠cito √© melhor que impl√≠cito, educacional, uma "camada de script C" para trabalho de sistemas.

---

## Princ√≠pios de Design

### 1. Expl√≠cito √© Melhor que Impl√≠cito
- Ponto e v√≠rgula √© obrigat√≥rio (sem inser√ß√£o autom√°tica)
- Gerenciamento manual de mem√≥ria (alloc/free)
- Anota√ß√µes de tipo opcionais, mas verificadas em runtime

### 2. Din√¢mico por Padr√£o, Tipos Opcionais
- Todo valor tem tag de tipo em runtime
- Literais inferem tipos: `42` ‚Üí i32, `5000000000` ‚Üí i64, `3.14` ‚Üí f64
- Anota√ß√µes de tipo opcionais for√ßam verifica√ß√£o em runtime

### 3. N√£o-Seguro √© um Recurso
- Aritm√©tica de ponteiros √© permitida (responsabilidade do usu√°rio)
- `ptr` bruto n√£o tem verifica√ß√£o de limites (use `buffer` para seguran√ßa)
- Double free √© permitido causar crash

### 4. Concorr√™ncia Estruturada como Cidad√£ de Primeira Classe
- `async`/`await` integrados, paralelismo baseado em pthread
- Channels para comunica√ß√£o
- `spawn`/`join`/`detach` para gerenciamento de tasks

### 5. Sintaxe Semelhante a C
- Blocos `{}` s√£o sempre obrigat√≥rios
- Coment√°rios: `// linha` e `/* bloco */`
- Operadores como C: `+`, `-`, `*`, `%`, `&&`, `||`, `!`, `&`, `|`, `^`, `<<`, `>>`
- Incremento/decremento: `++x`, `x++`, `--x`, `x--` (prefixo e p√≥s-fixo)
- Atribui√ß√£o composta: `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`
- `/` sempre retorna ponto flutuante (use `divi()` para divis√£o inteira)
- Sintaxe de tipos: `let x: type = value;`

---

## Refer√™ncia R√°pida

### Tipos
```
Com sinal:     i8, i16, i32, i64
Sem sinal:    u8, u16, u32, u64
Ponto flut:   f32, f64
Outros:       bool, string, rune, array, ptr, buffer, null, object, file, task, channel
Aliases:      integer (i32), number (f64), byte (u8)
```

**Promo√ß√£o de tipos:** i8 ‚Üí i16 ‚Üí i32 ‚Üí i64 ‚Üí f32 ‚Üí f64 (ponto flutuante sempre vence, mas i64/u64 + f32 ‚Üí f64 para manter precis√£o)

### Literais
```hemlock
let x = 42;              // i32
let big = 5000000000;    // i64 (> m√°x i32)
let hex = 0xDEADBEEF;    // Literal hexadecimal
let bin = 0b1010;        // Literal bin√°rio
let oct = 0o777;         // Literal octal
let sep = 1_000_000;     // Separador de d√≠gitos permitido
let pi = 3.14;           // f64
let half = .5;           // f64 (sem zero inicial)
let s = "hello";         // string
let esc = "\x41\u{1F600}"; // Escapes hex e Unicode
let ch = 'A';            // rune
let emoji = 'üöÄ';        // rune (Unicode)
let arr = [1, 2, 3];     // array
let obj = { x: 10 };     // object
```

### Convers√£o de Tipos
```hemlock
// Construtores de tipo - parsear strings para tipos
let n = i32("42");       // Parsear string para i32
let f = f64("3.14");     // Parsear string para f64
let b = bool("true");    // Parsear string para bool ("true" ou "false")

// Todos os tipos num√©ricos suportados
let a = i8("-128");      // i8, i16, i32, i64
let c = u8("255");       // u8, u16, u32, u64
let d = f32("1.5");      // f32, f64

// Hex e negativos
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42

// Aliases de tipo tamb√©m funcionam
let x = integer("100");  // Igual a i32("100")
let y = number("1.5");   // Igual a f64("1.5")
let z = byte("200");     // Igual a u8("200")

// Convers√£o entre tipos num√©ricos
let big = i64(42);       // i32 para i64
let truncated = i32(3.99); // f64 para i32 (trunca para 3)

// Anota√ß√µes de tipo validam tipos (mas n√£o parseiam strings)
let f: f64 = 100;        // i32 convertido para f64 via anota√ß√£o (coer√ß√£o num√©rica funciona)
// let n: i32 = "42";    // Erro - use i32("42") para parsear strings
```

### Introspec√ß√£o
```hemlock
typeof(42);              // "i32"
typeof("hello");         // "string"
typeof([1, 2, 3]);       // "array"
typeof(null);            // "null"
len("hello");            // 5 (comprimento em bytes da string)
len([1, 2, 3]);          // 3 (comprimento do array)
```

### Mem√≥ria
```hemlock
let p = alloc(64);       // Ponteiro bruto
let b = buffer(64);      // Buffer seguro (verifica√ß√£o de limites)
memset(p, 0, 64);
memcpy(dest, src, 64);
free(p);                 // Limpeza manual necess√°ria
```

### Fluxo de Controle
```hemlock
if (x > 0) { } else if (x < 0) { } else { }
while (cond) { break; continue; }
for (let i = 0; i < 10; i++) { }
for (item in array) { }
loop { if (done) { break; } }   // Loop infinito (mais claro que while(true))
switch (x) { case 1: break; default: break; }  // Fall-through estilo C
defer cleanup();         // Executa quando fun√ß√£o retorna

// Labels de loop para break/continue direcionado em loops aninhados
outer: while (cond) {
    inner: for (let i = 0; i < 10; i++) {
        if (i == 5) { break outer; }     // Sai do loop externo
        if (i == 3) { continue outer; }  // Continua loop externo
    }
}
```

### Pattern Matching
```hemlock
// Express√£o match - retorna um valor
let result = match (value) {
    0 => "zero",                    // Padr√£o literal
    1 | 2 | 3 => "small",           // Padr√£o OR
    n if n < 10 => "medium",        // Express√£o guard
    n => "large: " + n              // Binding de vari√°vel
};

// Padr√µes de tipo
match (val) {
    n: i32 => "integer",
    s: string => "string",
    _ => "other"                    // Wildcard
}

// Desestrutura√ß√£o de objeto
match (point) {
    { x: 0, y: 0 } => "origin",
    { x, y } => "at " + x + "," + y
}

// Desestrutura√ß√£o de array com rest
match (arr) {
    [] => "empty",
    [first, ...rest] => "head: " + first,
    _ => "other"
}

// Padr√µes aninhados
match (user) {
    { name, address: { city } } => name + " in " + city
}
```

Veja `docs/language-guide/pattern-matching.md` para documenta√ß√£o completa.

### Operadores de Coalesc√™ncia Nula
```hemlock
// Coalesc√™ncia nula (??) - retorna lado esquerdo se n√£o-null, sen√£o lado direito
let name = user.name ?? "Anonymous";
let first = a ?? b ?? c ?? "fallback";

// Atribui√ß√£o de coalesc√™ncia nula (??=) - atribui apenas se null
let config = null;
config ??= { timeout: 30 };    // config agora √© { timeout: 30 }
config ??= { timeout: 60 };    // config n√£o muda (n√£o-null)

// Funciona com propriedades e √≠ndices
obj.field ??= "default";
arr[0] ??= "first";

// Navega√ß√£o segura (?.) - retorna null se objeto √© null
let city = user?.address?.city;  // null se qualquer parte √© null
let upper = name?.to_upper();    // Chamada de m√©todo segura
let item = arr?.[0];             // Indexa√ß√£o segura
```

### Fun√ß√µes
```hemlock
fn add(a: i32, b: i32): i32 { return a + b; }
fn greet(name: string, msg?: "Hello") { print(msg + " " + name); }
let f = fn(x) { return x * 2; };  // An√¥nima/closure

// Fun√ß√µes com corpo de express√£o (sintaxe arrow)
fn double(x: i32): i32 => x * 2;
fn max(a: i32, b: i32): i32 => a > b ? a : b;
let square = fn(x: i32): i32 => x * x;  // Corpo de express√£o an√¥nimo

// Modificadores de par√¢metros
fn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // Passagem por refer√™ncia
fn print_all(const items: array) { for (i in items) { print(i); } }  // Imut√°vel
```

### Par√¢metros Nomeados
```hemlock
// Fun√ß√µes podem ser chamadas com par√¢metros nomeados
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " is " + age + " years old");
}

// Par√¢metros posicionais (tradicional)
create_user("Alice", 25, false);

// Par√¢metros nomeados - qualquer ordem
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);

// Pular par√¢metros opcionais nomeando os desejados
create_user("David", active: false);  // Usa age=18 padr√£o

// Par√¢metros nomeados devem vir depois dos posicionais
create_user("Eve", age: 21);          // OK: posicional primeiro, nomeado depois
// create_user(name: "Bad", 25);      // Erro: posicional depois de nomeado
```

**Regras:**
- Par√¢metros nomeados usam sintaxe `name: value`
- Podem aparecer em qualquer ordem ap√≥s par√¢metros posicionais
- Par√¢metros posicionais n√£o podem seguir nomeados
- Funcionam com par√¢metros padr√£o/opcionais
- Nomes de par√¢metros desconhecidos causam erro de runtime

### Objetos e Enums
```hemlock
define Person { name: string, age: i32, active?: true }
let p: Person = { name: "Alice", age: 30 };
let json = p.serialize();
let restored = json.deserialize();

// Sintaxe abreviada de objeto (estilo ES6)
let name = "Alice";
let age = 30;
let person = { name, age };         // Igual a { name: name, age: age }

// Operador spread de objeto
let defaults = { theme: "dark", size: "medium" };
let config = { ...defaults, size: "large" };  // Copia defaults, sobrescreve size

enum Color { RED, GREEN, BLUE }
enum Status { OK = 0, ERROR = 1 }
```

### Tipos Compostos (Interse√ß√£o/Duck Typing)
```hemlock
// Definir tipos estruturais
define HasName { name: string }
define HasAge { age: i32 }
define HasEmail { email: string }

// Tipo composto: objeto deve satisfazer todos os tipos
let person: HasName & HasAge = { name: "Alice", age: 30 };

// Par√¢metros de fun√ß√£o com tipos compostos
fn greet(p: HasName & HasAge) {
    print(p.name + " is " + p.age);
}

// Tr√™s ou mais tipos
fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}

// Campos extras permitidos (duck typing)
let employee: HasName & HasAge = {
    name: "Bob",
    age: 25,
    department: "Engineering"  // OK - campos extras ignorados
};
```

Tipos compostos fornecem comportamento similar a interfaces sem palavra-chave `interface` separada,
construindo sobre os paradigmas existentes de `define` e duck typing.

### Aliases de Tipo
```hemlock
// Alias de tipo simples
type Integer = i32;
type Text = string;

// Aliases de tipo de fun√ß√£o
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// Aliases de tipo composto (bom para interfaces reutiliz√°veis)
define HasName { name: string }
define HasAge { age: i32 }
type Person = HasName & HasAge;

// Aliases de tipo gen√©rico
type Pair<T> = { first: T, second: T };

// Usando aliases de tipo
let x: Integer = 42;
let cb: Callback = fn(n) { print(n); };
let p: Person = { name: "Alice", age: 30 };
```

Aliases de tipo criam atalhos nomeados para tipos complexos, melhorando legibilidade e manutenibilidade.

### Tipos de Fun√ß√£o
```hemlock
// Anota√ß√µes de tipo de fun√ß√£o para par√¢metros
fn apply_fn(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Fun√ß√µes de alta ordem que retornam fun√ß√µes
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Tipos de fun√ß√£o async
fn run_async(handler: async fn(): void) {
    spawn(handler);
}

// Tipos de fun√ß√£o com m√∫ltiplos par√¢metros
type BinaryOp = fn(i32, i32): i32;
let add: BinaryOp = fn(a, b) { return a + b; };
```

### Par√¢metros Const
```hemlock
// Par√¢metros const - imutabilidade profunda
fn print_all(const items: array) {
    // items.push(4);  // Erro: n√£o pode modificar par√¢metro const
    for (item in items) {
        print(item);
    }
}

// Const em objetos - n√£o pode modificar por nenhum caminho
fn describe(const person: object) {
    print(person.name);       // OK: leitura permitida
    // person.name = "Bob";   // Erro: n√£o pode modificar
}

// Acesso de leitura aninhado permitido
fn get_city(const user: object) {
    return user.address.city;  // OK: leitura de propriedade aninhada
}
```

O modificador `const` previne qualquer modifica√ß√£o ao par√¢metro, incluindo propriedades aninhadas.
Isso fornece seguran√ßa em tempo de compila√ß√£o para fun√ß√µes que n√£o devem modificar suas entradas.

### Par√¢metros Ref (Passagem por Refer√™ncia)
```hemlock
// Par√¢metros ref - modificar vari√°vel do chamador diretamente
fn increment(ref x: i32) {
    x = x + 1;  // Modifica vari√°vel original
}

let count = 10;
increment(count);
print(count);  // 11 - valor original modificado

// Fun√ß√£o swap cl√°ssica
fn swap(ref a: i32, ref b: i32) {
    let temp = a;
    a = b;
    b = temp;
}

let x = 1;
let y = 2;
swap(x, y);
print(x, y);  // 2 1

// Misturando par√¢metros ref e normais
fn add_to(ref target: i32, amount: i32) {
    target = target + amount;
}

let total = 100;
add_to(total, 50);
print(total);  // 150
```

O modificador `ref` passa uma refer√™ncia √† vari√°vel do chamador, permitindo que a fun√ß√£o a modifique diretamente.
Sem `ref`, tipos primitivos s√£o passados por valor (copiados). Use `ref` quando precisar
modificar estado do chamador sem retornar um valor.

**Regras:**
- Par√¢metros `ref` devem receber vari√°veis, n√£o literais ou express√µes
- Funciona com todos os tipos (primitivos, arrays, objetos)
- Combina com anota√ß√µes de tipo: `ref x: i32`
- N√£o pode combinar com `const` (s√£o opostos)

### Assinaturas de M√©todo em Define
```hemlock
// Define com assinaturas de m√©todo (padr√£o interface)
define Comparable {
    value: i32,
    fn compare(other: Self): i32   // Assinatura de m√©todo requerida
}

// Objetos devem fornecer m√©todos requeridos
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};

// Use ? para m√©todos opcionais
define Serializable {
    fn serialize(): string,        // Requerido
    fn pretty?(): string           // M√©todo opcional
}

// Tipo Self refere-se ao tipo definido
define Cloneable {
    fn clone(): Self   // Retorna mesmo tipo que o objeto
}
```

Assinaturas de m√©todo em blocos `define` s√£o separadas por v√≠rgula (similar a interfaces TypeScript),
estabelecendo contratos que objetos devem satisfazer e habilitando padr√µes de programa√ß√£o tipo-interface
atrav√©s do sistema de duck typing do Hemlock.

### Tratamento de Erros
```hemlock
try { throw "error"; } catch (e) { print(e); } finally { cleanup(); }
panic("unrecoverable");  // Sai imediatamente, n√£o pode ser capturado
```

### Async/Concorr√™ncia
```hemlock
async fn compute(n: i32): i32 { return n * n; }
let task = spawn(compute, 42);
let result = await task;     // Ou join(task)
detach(spawn(background_work));

let ch = channel(10);
ch.send(value);
let val = ch.recv();
ch.close();
```

**Ownership de mem√≥ria:** Tasks recebem c√≥pias de valores primitivos, mas compartilham ponteiros. Se voc√™ passa um `ptr` para uma task gerada,
voc√™ deve garantir que a mem√≥ria permanece v√°lida at√© a task completar. Use `join()` antes de `free()`,
ou use channels para sinalizar conclus√£o.

### Entrada de Usu√°rio
```hemlock
let name = read_line();          // L√™ linha de stdin (bloqueante)
print("Hello, " + name);
eprint("Error message");         // Sa√≠da para stderr

// read_line() retorna null em EOF
while (true) {
    let line = read_line();
    if (line == null) { break; }
    print("Got:", line);
}
```

### I/O de Arquivos
```hemlock
let f = open("file.txt", "r");  // Modos: r, w, a, r+, w+, a+
let content = f.read();
f.write("data");
f.seek(0);
f.close();
```

### Sinais
```hemlock
signal(SIGINT, fn(sig) { print("Interrupted"); });
raise(SIGUSR1);
```

---

## M√©todos de String (19)

`substr`, `slice`, `find`, `contains`, `split`, `trim`, `to_upper`, `to_lower`,
`starts_with`, `ends_with`, `replace`, `replace_all`, `repeat`, `char_at`,
`byte_at`, `chars`, `bytes`, `to_bytes`, `deserialize`

Template strings: `` `Hello ${name}!` ``

**Mutabilidade de strings:** Strings s√£o mut√°veis via atribui√ß√£o por √≠ndice (`s[0] = 'H'`), mas todos os m√©todos de string
retornam novas strings sem modificar a original. Isso permite modifica√ß√£o in-place quando necess√°rio enquanto mant√©m
estilo funcional para encadeamento de m√©todos.

**Propriedades de comprimento de string:**
```hemlock
let s = "hello üöÄ";
print(s.length);       // 7 (contagem de caracteres/runes)
print(s.byte_length);  // 10 (contagem de bytes - emoji √© 4 bytes UTF-8)
```

## M√©todos de Array (18)

`push`, `pop`, `shift`, `unshift`, `insert`, `remove`, `find`, `contains`,
`slice`, `join`, `concat`, `reverse`, `first`, `last`, `clear`, `map`, `filter`, `reduce`

Arrays tipados: `let nums: array<i32> = [1, 2, 3];`

---

## Biblioteca Padr√£o (40 m√≥dulos)

Importar com prefixo `@stdlib/`:
```hemlock
import { sin, cos, PI } from "@stdlib/math";
import { HashMap, Queue, Set } from "@stdlib/collections";
import { read_file, write_file } from "@stdlib/fs";
import { TcpStream, UdpSocket } from "@stdlib/net";
```

| M√≥dulo | Descri√ß√£o |
|--------|-----------|
| `arena` | Alocador de mem√≥ria arena (aloca√ß√£o bump) |
| `args` | Parsing de argumentos de linha de comando |
| `assert` | Utilit√°rios de asser√ß√£o |
| `async` | ThreadPool, parallel_map |
| `async_fs` | Opera√ß√µes de I/O de arquivos ass√≠ncronas |
| `collections` | HashMap, Queue, Stack, Set, LinkedList, LRUCache |
| `compression` | gzip, gunzip, deflate |
| `crypto` | aes_encrypt, rsa_sign, random_bytes |
| `csv` | Parsing e gera√ß√£o de CSV |
| `datetime` | Classe DateTime, formata√ß√£o, parsing |
| `encoding` | base64_encode, hex_encode, url_encode |
| `env` | getenv, setenv, exit, get_pid |
| `fmt` | Utilit√°rios de formata√ß√£o de string |
| `fs` | read_file, write_file, list_dir, exists |
| `glob` | Matching de padr√µes de arquivo |
| `hash` | sha256, sha512, md5, djb2 |
| `http` | http_get, http_post, http_request |
| `ipc` | Comunica√ß√£o entre processos |
| `iter` | Utilit√°rios de iterador |
| `json` | parse, stringify, pretty, get, set |
| `logging` | Logger com n√≠veis |
| `math` | sin, cos, sqrt, pow, rand, PI, E |
| `net` | TcpListener, TcpStream, UdpSocket |
| `os` | platform, arch, cpu_count, hostname |
| `path` | Manipula√ß√£o de caminhos de arquivo |
| `process` | fork, exec, wait, kill |
| `random` | Gera√ß√£o de n√∫meros aleat√≥rios |
| `regex` | compile, test (POSIX ERE) |
| `retry` | L√≥gica de retry com backoff |
| `semver` | Versionamento sem√¢ntico |
| `shell` | Utilit√°rios de comandos shell |
| `sqlite` | SQLite database, query, exec, transa√ß√µes |
| `strings` | pad_left, is_alpha, reverse, lines |
| `terminal` | Cores e estilos ANSI |
| `testing` | describe, test, expect |
| `time` | now, time_ms, sleep, clock |
| `toml` | Parsing e gera√ß√£o de TOML |
| `url` | Parsing e manipula√ß√£o de URL |
| `uuid` | Gera√ß√£o de UUID |
| `websocket` | Cliente WebSocket |

Veja `stdlib/docs/` para documenta√ß√£o detalhada dos m√≥dulos.

---

## FFI (Interface de Fun√ß√£o Estrangeira)

Declarar e chamar fun√ß√µes C de bibliotecas compartilhadas:
```hemlock
import "libc.so.6";

extern fn strlen(s: string): i32;
extern fn getpid(): i32;

let len = strlen("Hello!");  // 6
let pid = getpid();
```

Exportar fun√ß√µes FFI de m√≥dulos:
```hemlock
// string_utils.hml
import "libc.so.6";

export extern fn strlen(s: string): i32;
export fn string_length(s: string): i32 {
    return strlen(s);
}
```

FFI din√¢mico (binding em runtime):
```hemlock
let lib = ffi_open("libc.so.6");
let puts = ffi_bind(lib, "puts", [FFI_POINTER], FFI_INT);
puts("Hello from C!");
ffi_close(lib);
```

Tipos: `FFI_INT`, `FFI_DOUBLE`, `FFI_POINTER`, `FFI_STRING`, `FFI_VOID`, etc.

---

## Opera√ß√µes At√¥micas

Use opera√ß√µes at√¥micas para programa√ß√£o concorrente sem locks:

```hemlock
// Alocar mem√≥ria para i32 at√¥mico
let p = alloc(4);
ptr_write_i32(p, 0);

// Load/store at√¥mico
let val = atomic_load_i32(p);        // Leitura at√¥mica
atomic_store_i32(p, 42);             // Escrita at√¥mica

// Opera√ß√µes fetch-and-modify (retornam valor antigo)
let old = atomic_add_i32(p, 10);     // Adiciona, retorna antigo
old = atomic_sub_i32(p, 5);          // Subtrai, retorna antigo
old = atomic_and_i32(p, 0xFF);       // AND bit a bit
old = atomic_or_i32(p, 0x10);        // OR bit a bit
old = atomic_xor_i32(p, 0x0F);       // XOR bit a bit

// Compare-and-swap (CAS)
let success = atomic_cas_i32(p, 42, 100);  // Se *p == 42, seta para 100
// Retorna true se swap ocorreu, false caso contr√°rio

// Atomic exchange
old = atomic_exchange_i32(p, 999);   // Troca, retorna antigo

free(p);

// Variantes i64 dispon√≠veis (atomic_load_i64, atomic_add_i64, etc.)

// Barreira de mem√≥ria (barreira completa)
atomic_fence();
```

Todas as opera√ß√µes usam consist√™ncia sequencial (`memory_order_seq_cst`).

---

## Estrutura do Projeto

```
hemlock/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ frontend/         # Compartilhado: lexer, parser, AST, m√≥dulos
‚îÇ   ‚îú‚îÄ‚îÄ backends/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interpreter/  # hemlock: interpretador tree-walking
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ compiler/     # hemlockc: gerador de c√≥digo C
‚îÇ   ‚îú‚îÄ‚îÄ tools/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lsp/          # Language Server Protocol
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ bundler/      # Ferramenta de bundling/pacotes
‚îú‚îÄ‚îÄ runtime/              # Runtime de programas compilados (libhemlock_runtime.a)
‚îú‚îÄ‚îÄ stdlib/               # Biblioteca padr√£o (40 m√≥dulos)
‚îÇ   ‚îî‚îÄ‚îÄ docs/             # Documenta√ß√£o dos m√≥dulos
‚îú‚îÄ‚îÄ docs/                 # Documenta√ß√£o completa
‚îÇ   ‚îú‚îÄ‚îÄ language-guide/   # Tipos, strings, arrays, etc.
‚îÇ   ‚îú‚îÄ‚îÄ reference/        # Refer√™ncia de API
‚îÇ   ‚îî‚îÄ‚îÄ advanced/         # Async, FFI, sinais, etc.
‚îú‚îÄ‚îÄ tests/                # 625+ testes
‚îî‚îÄ‚îÄ examples/             # Programas de exemplo
```

---

## Guia de Estilo de C√≥digo

### Constantes e N√∫meros M√°gicos

Ao adicionar constantes num√©ricas ao c√≥digo C, siga estas diretrizes:

1. **Definir constantes em `include/hemlock_limits.h`** - Este arquivo √© o local centralizado para todos os limites de compile-time e runtime, capacidades e constantes nomeadas.

2. **Usar nomes descritivos com prefixo `HML_`** - Todas as constantes devem ser prefixadas com `HML_` para namespace claro.

3. **Evitar n√∫meros m√°gicos** - Substituir valores num√©ricos hardcoded com constantes nomeadas. Exemplos:
   - Limites de intervalo de tipos: `HML_I8_MIN`, `HML_I8_MAX`, `HML_U32_MAX`
   - Capacidades de buffer: `HML_INITIAL_ARRAY_CAPACITY`, `HML_INITIAL_LEXER_BUFFER_CAPACITY`
   - Convers√µes de tempo: `HML_NANOSECONDS_PER_SECOND`, `HML_MILLISECONDS_PER_SECOND`
   - Seeds de hash: `HML_DJB2_HASH_SEED`
   - Valores ASCII: `HML_ASCII_CASE_OFFSET`, `HML_ASCII_PRINTABLE_START`

4. **Incluir `hemlock_limits.h`** - Arquivos fonte devem incluir este header (tipicamente via `internal.h`) para acessar constantes.

5. **Documentar prop√≥sito** - Adicionar coment√°rios explicando o que cada constante representa.

---

## Proibi√ß√µes

- Adicionar comportamento impl√≠cito (ASI, GC, limpeza autom√°tica)
- Esconder complexidade (otimiza√ß√µes m√°gicas, contagem de refer√™ncia oculta)
- Quebrar sem√¢ntica existente (ponto e v√≠rgula, mem√≥ria manual, strings mut√°veis)
- Perder precis√£o em convers√µes impl√≠citas
- Usar n√∫meros m√°gicos - em vez disso, defina constantes nomeadas em `hemlock_limits.h`

---

## Testes

```bash
make test              # Executar testes do interpretador
make test-compiler     # Executar testes do compilador
make parity            # Executar testes de paridade (ambos devem coincidir)
make test-all          # Executar todas as su√≠tes de teste
```

**Importante:** Testes podem travar devido a problemas de async/concorr√™ncia. Sempre use timeout ao executar testes:
```bash
timeout 60 make test   # Timeout de 60 segundos
timeout 120 make parity
```

Categorias de testes: primitives, memory, strings, arrays, functions, objects, async, ffi, defer, signals, switch, bitwise, typed_arrays, modules, stdlib_*

---

## Arquitetura Compilador/Interpretador

Hemlock tem dois backends de execu√ß√£o que compartilham um frontend comum:

```
Fonte (.hml)
    ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Frontend Compartilhado      ‚îÇ
‚îÇ  - Lexer (src/frontend/)     ‚îÇ
‚îÇ  - Parser (src/frontend/)    ‚îÇ
‚îÇ  - AST (src/frontend/)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚Üì                    ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Interpretador ‚îÇ  ‚îÇ Compilador  ‚îÇ
‚îÇ (hemlock)     ‚îÇ  ‚îÇ (hemlockc)  ‚îÇ
‚îÇ               ‚îÇ  ‚îÇ             ‚îÇ
‚îÇ Tree-walking  ‚îÇ  ‚îÇ Type check  ‚îÇ
‚îÇ Avalia√ß√£o     ‚îÇ  ‚îÇ AST ‚Üí C     ‚îÇ
‚îÇ               ‚îÇ  ‚îÇ gcc link    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Verifica√ß√£o de Tipos do Compilador

O compilador (`hemlockc`) inclui verifica√ß√£o de tipos em compile-time, **habilitada por padr√£o**:

```bash
hemlockc program.hml -o program    # Verifica tipos, depois compila
hemlockc --check program.hml       # Apenas verifica tipos, n√£o compila
hemlockc --no-type-check prog.hml  # Desabilita verifica√ß√£o de tipos
hemlockc --strict-types prog.hml   # Avisa sobre tipos 'any' impl√≠citos
```

O verificador de tipos:
- Valida anota√ß√µes de tipo em compile-time
- Trata c√≥digo sem tipos como din√¢mico (tipo `any`) - sempre v√°lido
- Fornece dicas de otimiza√ß√£o para unboxing
- Usa convers√£o num√©rica permissiva (intervalos validados em runtime)

### Estrutura de Diret√≥rios

```
hemlock/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ frontend/           # Compartilhado: lexer, parser, AST, m√≥dulos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lexer.c
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ parser/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ast.c
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ module.c
‚îÇ   ‚îú‚îÄ‚îÄ backends/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interpreter/    # hemlock: interpretador tree-walking
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ runtime/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ builtins/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ compiler/       # hemlockc: gerador de c√≥digo C
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ codegen/
‚îÇ   ‚îú‚îÄ‚îÄ tools/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lsp/            # Language server
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ bundler/        # Ferramenta de bundling/pacotes
‚îú‚îÄ‚îÄ runtime/                # libhemlock_runtime.a para programas compilados
‚îú‚îÄ‚îÄ stdlib/                 # Biblioteca padr√£o compartilhada
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ parity/             # Testes que devem passar em ambos backends
    ‚îú‚îÄ‚îÄ interpreter/        # Testes espec√≠ficos do interpretador
    ‚îî‚îÄ‚îÄ compiler/           # Testes espec√≠ficos do compilador
```

---

## Desenvolvimento Parity-First

**Interpretador e compilador devem produzir sa√≠da id√™ntica para a mesma entrada.**

### Estrat√©gia de Desenvolvimento

Ao adicionar ou modificar recursos da linguagem:

1. **Design** - Definir mudan√ßas de AST/sem√¢ntica no frontend compartilhado
2. **Implementar Interpretador** - Adicionar avalia√ß√£o tree-walking
3. **Implementar Compilador** - Adicionar gera√ß√£o de c√≥digo C
4. **Adicionar Testes de Paridade** - Escrever testes em `tests/parity/` com arquivos `.expected`
5. **Verificar** - Executar `make parity` antes de merge

### Estrutura de Testes de Paridade

```
tests/parity/
‚îú‚îÄ‚îÄ language/       # Recursos core da linguagem (fluxo de controle, closures, etc.)
‚îú‚îÄ‚îÄ builtins/       # Fun√ß√µes builtin (print, typeof, memory, etc.)
‚îú‚îÄ‚îÄ methods/        # M√©todos de string e array
‚îî‚îÄ‚îÄ modules/        # import/export, imports de stdlib
```

Cada teste tem dois arquivos:
- `feature.hml` - Programa de teste
- `feature.expected` - Sa√≠da esperada (ambos backends devem coincidir)

### Resultados de Testes de Paridade

| Status | Significado |
|--------|-------------|
| `PASSED` | Interpretador e compilador coincidem com sa√≠da esperada |
| `INTERP_ONLY` | Interpretador funciona, compilador falha (precisa corrigir compilador) |
| `COMPILER_ONLY` | Compilador funciona, interpretador falha (raro) |
| `FAILED` | Ambos falham (erro de teste ou implementa√ß√£o) |

### O que Precisa de Paridade

- Todas as constru√ß√µes de linguagem (if, while, for, switch, defer, try/catch)
- Todos os operadores (aritm√©ticos, bit a bit, l√≥gicos, compara√ß√£o)
- Todas as fun√ß√µes builtin (print, typeof, alloc, etc.)
- Todos os m√©todos de string e array
- Regras de coer√ß√£o e promo√ß√£o de tipos
- Mensagens de erro para erros de runtime

### O que Pode Diferir

- Caracter√≠sticas de performance
- Detalhes de layout de mem√≥ria
- Formato de debug/stack trace
- Erros de compila√ß√£o (compilador pode capturar mais em compile-time)

### Adicionando Testes de Paridade

```bash
# 1. Criar arquivo de teste
cat > tests/parity/language/my_feature.hml << 'EOF'
// Descri√ß√£o do teste
let x = some_feature();
print(x);
EOF

# 2. Gerar sa√≠da esperada do interpretador
./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected

# 3. Verificar paridade
make parity
```

---

## Vers√£o

**v1.8.0** - Recursos da vers√£o atual:
- **Pattern Matching** (express√µes `match`) - Desestrutura√ß√£o poderosa e fluxo de controle:
  - Padr√µes literal, wildcard e binding de vari√°vel
  - Padr√µes OR (`1 | 2 | 3`)
  - Express√µes guard (`n if n > 0`)
  - Desestrutura√ß√£o de objeto (`{ x, y }`)
  - Desestrutura√ß√£o de array com rest (`[first, ...rest]`)
  - Padr√µes de tipo (`n: i32`)
  - Paridade total entre interpretador e compilador
- **Anota√ß√µes de Assist√™ncia ao Compilador** - 11 anota√ß√µes de otimiza√ß√£o para controle de GCC/Clang:
  - `@inline`, `@noinline` - Controle de inlining de fun√ß√£o
  - `@hot`, `@cold` - Dicas de predi√ß√£o de branch
  - `@pure`, `@const` - Anota√ß√µes de side-effect
  - `@flatten` - Inline todas as chamadas dentro da fun√ß√£o
  - `@optimize(level)` - N√≠vel de otimiza√ß√£o por fun√ß√£o ("0", "1", "2", "3", "s", "fast")
  - `@warn_unused` - Aviso quando valor de retorno √© ignorado
  - `@section(name)` - Coloca√ß√£o de se√ß√£o ELF customizada (ex: `@section(".text.hot")`)
- **Fun√ß√µes com corpo de express√£o** (`fn double(x): i32 => x * 2;`) - Sintaxe concisa para fun√ß√µes de express√£o √∫nica
- **Statements de linha √∫nica** - Sintaxe sem chaves para `if`, `while`, `for` (ex: `if (x > 0) print(x);`)
- **Aliases de tipo** (`type Name = Type;`) - Atalhos nomeados para tipos complexos
- **Anota√ß√µes de tipo de fun√ß√£o** (`fn(i32): i32`) - Tipos de fun√ß√£o de primeira classe
- **Par√¢metros const** (`fn(const x: array)`) - Imutabilidade profunda para par√¢metros
- **Par√¢metros ref** (`fn(ref x: i32)`) - Passagem por refer√™ncia para modificar chamador diretamente
- **Assinaturas de m√©todo em define** (`fn method(): Type`) - Contratos tipo-interface (separados por v√≠rgula)
- **Tipo Self** em assinaturas de m√©todo - Refer√™ncia ao tipo definido
- **Palavra-chave loop** (`loop { }`) - Loop infinito mais claro, substitui `while (true)`
- **Labels de loop** (`outer: while`) - Break/continue direcionado para loops aninhados
- **Abrevia√ß√£o de objeto** (`{ name }`) - Sintaxe de propriedade abreviada estilo ES6
- **Spread de objeto** (`{ ...obj }`) - Copiar e mesclar campos de objeto
- **Duck typing composto** (`A & B & C`) - Tipos de interse√ß√£o para tipos estruturais
- **Par√¢metros nomeados** para chamadas de fun√ß√£o (`foo(name: "value", age: 30)`)
- **Operadores de coalesc√™ncia nula** (`??`, `??=`, `?.`) para tratamento seguro de null
- **Literais octais** (`0o777`, `0O123`)
- **Separadores de d√≠gitos** (`1_000_000`, `0xFF_FF`, `0b1111_0000`)
- **Coment√°rios de bloco** (`/* ... */`)
- **Sequ√™ncias de escape hex** em strings/runes (`\x41` = 'A')
- **Sequ√™ncias de escape Unicode** em strings (`\u{1F600}` = üòÄ)
- **Literais float sem zero inicial** (`.5`, `.123`, `.5e2`)
- **Verifica√ß√£o de tipos em compile-time** em hemlockc (habilitada por padr√£o)
- **Integra√ß√£o LSP** com verifica√ß√£o de tipos com diagn√≥sticos em tempo real
- **Operadores de atribui√ß√£o composta** (`+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`)
- **Operadores de incremento/decremento** (`++x`, `x++`, `--x`, `x--`)
- **Corre√ß√£o de precis√£o de tipos**: i64/u64 + f32 ‚Üí f64 para manter precis√£o
- Sistema de tipos unificado com dicas de otimiza√ß√£o de unboxing
- Sistema de tipos completo (i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object, enum, file, task, channel)
- Strings UTF-8 com 19 m√©todos
- Arrays com 18 m√©todos incluindo map/filter/reduce
- Gerenciamento manual de mem√≥ria com `talloc()` e `sizeof()`
- Async/await com paralelismo pthread real
- Opera√ß√µes at√¥micas para programa√ß√£o concorrente sem locks
- 40 m√≥dulos de stdlib (+ arena, assert, semver, toml, retry, iter, random, shell)
- FFI para interop com C, com `export extern fn` para wrappers de biblioteca reutiliz√°veis
- Suporte a struct FFI no compilador (passando structs C por valor)
- Helpers de ponteiro FFI (`ptr_null`, `ptr_read_*`, `ptr_write_*`)
- defer, try/catch/finally/throw, panic
- I/O de arquivos, tratamento de sinais, execu√ß√£o de comandos
- Gerenciador de pacotes [hpm](https://github.com/hemlang/hpm) com registry baseado em GitHub
- Backend de compilador (gera√ß√£o de c√≥digo C), 100% paridade com interpretador
- Servidor LSP com jump-to-definition e find-references
- Passes de otimiza√ß√£o de AST e resolu√ß√£o de vari√°veis para lookup O(1)
- Builtin apply() para chamadas de fun√ß√£o din√¢micas
- Channels sem buffer e suporte a m√∫ltiplos argumentos
- 159 testes de paridade (100% taxa de aprova√ß√£o)

---

## Filosofia

> N√≥s fornecemos ferramentas seguras (`buffer`, anota√ß√µes de tipo, verifica√ß√£o de limites), mas n√£o for√ßamos voc√™ a us√°-las (`ptr`, mem√≥ria manual, opera√ß√µes n√£o-seguras).

**Se voc√™ n√£o tem certeza se um recurso cabe no Hemlock, pergunte-se: "Isso d√° ao programador mais controle expl√≠cito, ou esconde algo?"**

Se esconde, provavelmente n√£o pertence ao Hemlock.



################################################################################
# PRIMEIROS PASSOS
################################################################################

--------------------------------------------------------------------------------
## Caminhos de Aprendizado
--------------------------------------------------------------------------------

# Caminhos de Aprendizado

Objetivos diferentes requerem conhecimentos diferentes. Escolha o caminho que corresponde ao que voce deseja construir.

---

## Caminho 1: Scripts Rapidos e Automacao

**Objetivo:** Escrever scripts para automatizar tarefas, processar arquivos e fazer o trabalho.

**Tempo para produtividade:** Rapido - voce pode comecar a escrever scripts uteis imediatamente.

### O Que Voce Aprendera

1. **[Inicio Rapido](#getting-started-quick-start)** - Seu primeiro programa, sintaxe basica
2. **[Strings](#language-guide-strings)** - Processamento de texto, divisao, busca
3. **[Arrays](#language-guide-arrays)** - Listas, filtragem, transformacao de dados
4. **[E/S de Arquivos](#advanced-file-io)** - Ler e escrever arquivos
5. **[Argumentos de Linha de Comando](#advanced-command-line-args)** - Obter entrada do usuario

### Pule Por Enquanto

- Gerenciamento de memoria (scripts lidam automaticamente)
- Async/concorrencia (muito complexo para scripts simples)
- FFI (so necessario quando precisar de interoperabilidade com C)

### Projeto de Exemplo: Renomeador de Arquivos

```hemlock
import { list_dir, rename } from "@stdlib/fs";

// Renomeia todos os arquivos .txt para .md
let files = list_dir(".");
for (file in files) {
    if (file.ends_with(".txt")) {
        let new_name = file.replace(".txt", ".md");
        rename(file, new_name);
        print(`Renomeado: ${file} -> ${new_name}`);
    }
}
```

---

## Caminho 2: Processamento e Analise de Dados

**Objetivo:** Analisar dados, transforma-los e gerar relatorios.

**Tempo para produtividade:** Rapido - os metodos de string e array do Hemlock tornam isso facil.

### O Que Voce Aprendera

1. **[Inicio Rapido](#getting-started-quick-start)** - Fundamentos
2. **[Strings](#language-guide-strings)** - Analise, divisao, formatacao
3. **[Arrays](#language-guide-arrays)** - map, filter, reduce para transformacao de dados
4. **[Objetos](#language-guide-objects)** - Dados estruturados
5. **Biblioteca Padrao:**
   - **[@stdlib/json](#stdlib-json)** - Analise de JSON
   - **[@stdlib/csv](#stdlib-csv)** - Arquivos CSV
   - **[@stdlib/fs](#stdlib-fs)** - Operacoes de arquivo

### Projeto de Exemplo: Analisador de CSV

```hemlock
import { read_file } from "@stdlib/fs";
import { parse } from "@stdlib/csv";

let data = parse(read_file("sales.csv"));

// Calcular vendas totais
let total = 0;
for (row in data) {
    total = total + f64(row.amount);
}

print(`Vendas totais: R$${total}`);

// Encontrar maior venda
let top = data[0];
for (row in data) {
    if (f64(row.amount) > f64(top.amount)) {
        top = row;
    }
}

print(`Maior venda: ${top.product} - R$${top.amount}`);
```

---

## Caminho 3: Programacao Web e de Rede

**Objetivo:** Construir clientes HTTP, usar APIs, criar servidores.

**Tempo para produtividade:** Medio - requer entender o basico de async.

### O Que Voce Aprendera

1. **[Inicio Rapido](#getting-started-quick-start)** - Fundamentos
2. **[Funcoes](#language-guide-functions)** - Callbacks e closures
3. **[Tratamento de Erros](#language-guide-error-handling)** - try/catch para erros de rede
4. **[Async e Concorrencia](#advanced-async-concurrency)** - spawn, await, channels
5. **Biblioteca Padrao:**
   - **[@stdlib/http](#stdlib-http)** - Requisicoes HTTP
   - **[@stdlib/json](#stdlib-json)** - JSON para APIs
   - **[@stdlib/net](#stdlib-net)** - Sockets TCP/UDP
   - **[@stdlib/url](#stdlib-url)** - Analise de URL

### Projeto de Exemplo: Cliente de API

```hemlock
import { http_get, http_post } from "@stdlib/http";
import { parse, stringify } from "@stdlib/json";

// Requisicao GET
let response = http_get("https://api.example.com/users");
let users = parse(response.body);

for (user in users) {
    print(`${user.name}: ${user.email}`);
}

// Requisicao POST
let new_user = { name: "Alice", email: "alice@example.com" };
let result = http_post("https://api.example.com/users", {
    body: stringify(new_user),
    headers: { "Content-Type": "application/json" }
});

print(`ID do usuario criado: ${parse(result.body).id}`);
```

---

## Caminho 4: Programacao de Sistemas

**Objetivo:** Escrever codigo de baixo nivel, manipular memoria, interagir com bibliotecas C.

**Tempo para produtividade:** Mais longo - requer entender gerenciamento de memoria.

### O Que Voce Aprendera

1. **[Inicio Rapido](#getting-started-quick-start)** - Fundamentos
2. **[Tipos](#language-guide-types)** - Entender i32, u8, ptr, etc.
3. **[Gerenciamento de Memoria](#language-guide-memory)** - alloc, free, buffers
4. **[FFI](#advanced-ffi)** - Chamar funcoes C
5. **[Sinais](#advanced-signals)** - Tratamento de sinais

### Conceitos-Chave

**Lista de Verificacao de Seguranca de Memoria:**
- [ ] Cada `alloc()` tem um `free()` correspondente
- [ ] Use `buffer()` a menos que precise de `ptr` bruto
- [ ] Defina ponteiros para `null` apos liberar
- [ ] Use `try/finally` para garantir limpeza

**Mapeamento de Tipos FFI:**
| Hemlock | C |
|---------|---|
| `i8` | `char` / `int8_t` |
| `i32` | `int` |
| `i64` | `long` (64-bit) |
| `u8` | `unsigned char` |
| `f64` | `double` |
| `ptr` | `void*` |

### Projeto de Exemplo: Pool de Memoria Personalizado

```hemlock
// Alocador bump simples
let pool_size = 1024 * 1024;  // 1MB
let pool = alloc(pool_size);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > pool_size) {
        throw "Pool de memoria esgotado";
    }
    let p = pool + pool_offset;
    pool_offset = pool_offset + size;
    return p;
}

fn pool_reset() {
    pool_offset = 0;
}

fn pool_destroy() {
    free(pool);
}

// Usando
let a = pool_alloc(100);
let b = pool_alloc(200);
memset(a, 0, 100);
memset(b, 0, 200);

pool_reset();  // Reutilizar toda a memoria
pool_destroy();  // Limpar
```

---

## Caminho 5: Programas Paralelos e Concorrentes

**Objetivo:** Executar codigo em multiplos nucleos de CPU, construir aplicacoes responsivas.

**Tempo para produtividade:** Medio - a sintaxe async e simples, mas o pensamento paralelo requer pratica.

### O Que Voce Aprendera

1. **[Inicio Rapido](#getting-started-quick-start)** - Fundamentos
2. **[Funcoes](#language-guide-functions)** - Closures (importantes para async)
3. **[Async e Concorrencia](#advanced-async-concurrency)** - Aprofundamento completo
4. **[Operacoes Atomicas](#advanced-atomics)** - Programacao lock-free

### Conceitos-Chave

**Modelo Async do Hemlock:**
- `async fn` - Define uma funcao que pode executar em outra thread
- `spawn(fn, args...)` - Inicia a execucao, retorna um handle de tarefa
- `join(task)` ou `await task` - Espera completar, obtem o resultado
- `channel(size)` - Cria uma fila para enviar dados entre tarefas

**Importante:** Tarefas recebem *copias* dos valores. Se voce passar um ponteiro, e responsavel por garantir que a memoria permaneca valida ate a tarefa terminar.

### Projeto de Exemplo: Processador de Arquivos Paralelo

```hemlock
import { list_dir, read_file } from "@stdlib/fs";

async fn process_file(path: string): i32 {
    let content = read_file(path);
    let lines = content.split("\n");
    return lines.length;
}

// Processar todos os arquivos em paralelo
let files = list_dir("data/");
let tasks = [];

for (file in files) {
    if (file.ends_with(".txt")) {
        let task = spawn(process_file, "data/" + file);
        tasks.push({ name: file, task: task });
    }
}

// Coletar resultados
let total_lines = 0;
for (item in tasks) {
    let count = join(item.task);
    print(`${item.name}: ${count} linhas`);
    total_lines = total_lines + count;
}

print(`Total: ${total_lines} linhas`);
```

---

## O Que Aprender Primeiro em Qualquer Caminho

Independente do seu objetivo, comece com estes fundamentos:

### Semana 1: Fundamentos Essenciais
1. **[Inicio Rapido](#getting-started-quick-start)** - Escreva e execute seu primeiro programa
2. **[Sintaxe](#language-guide-syntax)** - Variaveis, operadores, fluxo de controle
3. **[Funcoes](#language-guide-functions)** - Definir e chamar funcoes

### Semana 2: Processamento de Dados
4. **[Strings](#language-guide-strings)** - Manipulacao de texto
5. **[Arrays](#language-guide-arrays)** - Colecoes e iteracao
6. **[Objetos](#language-guide-objects)** - Dados estruturados

### Semana 3: Robustez
7. **[Tratamento de Erros](#language-guide-error-handling)** - try/catch/throw
8. **[Modulos](#language-guide-modules)** - import/export, usando a biblioteca padrao

### Depois: Escolha seu Caminho Acima

---

## Guia Rapido: Vindo de Outras Linguagens

### Vindo do Python

| Python | Hemlock | Notas |
|--------|---------|-------|
| `x = 42` | `let x = 42;` | Ponto e virgula obrigatorio |
| `def fn():` | `fn name() { }` | Chaves obrigatorias |
| `if x:` | `if (x) { }` | Parenteses e chaves obrigatorios |
| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | Laco for estilo C |
| `for item in list:` | `for (item in array) { }` | for-in igual |
| `list.append(x)` | `array.push(x);` | Nomes de metodos diferentes |
| `len(s)` | `s.length` ou `len(s)` | Ambos funcionam |
| Memoria automatica | `ptr` requer gerenciamento manual | A maioria dos tipos e limpa automaticamente |

### Vindo do JavaScript

| JavaScript | Hemlock | Notas |
|------------|---------|-------|
| `let x = 42` | `let x = 42;` | Igual (ponto e virgula obrigatorio) |
| `const x = 42` | `let x = 42;` | Sem palavra-chave const |
| `function fn()` | `fn name() { }` | Palavra-chave diferente |
| `() => x` | `fn() { return x; }` | Sem arrow functions |
| `async/await` | `async/await` | Mesma sintaxe |
| `Promise` | `spawn/join` | Modelo diferente |
| GC automatico | `ptr` requer gerenciamento manual | A maioria dos tipos e limpa automaticamente |

### Vindo do C/C++

| C | Hemlock | Notas |
|---|---------|-------|
| `int x = 42;` | `let x: i32 = 42;` | Tipo apos dois-pontos |
| `malloc(n)` | `alloc(n)` | Mesmo conceito |
| `free(p)` | `free(p)` | Igual |
| `char* s = "hi"` | `let s = "hi";` | Strings sao gerenciadas |
| `#include` | `import { } from` | Importacao de modulos |
| Tudo manual | A maioria automatica | Apenas `ptr` requer gerenciamento manual |

---

## Obtendo Ajuda

- **[Glossario](../glossary.md)** - Definicoes de termos de programacao
- **[Exemplos](../../examples/)** - Programas funcionais completos
- **[Testes](../../tests/)** - Veja como os recursos sao usados
- **Issues no GitHub** - Faca perguntas, reporte bugs

---

## Niveis de Dificuldade

Ao longo da documentacao, voce vera estas marcacoes:

| Marcacao | Significado |
|----------|-------------|
| **Iniciante** | Nao requer experiencia previa em programacao |
| **Intermediario** | Assume conhecimento basico de programacao |
| **Avancado** | Requer entendimento de conceitos de sistemas |

Se algo marcado como "Iniciante" estiver confuso, consulte o [Glossario](../glossary.md) para definicoes de termos.


--------------------------------------------------------------------------------
## Instala√ß√£o
--------------------------------------------------------------------------------

# Guia de Instalacao

Este guia ira ajuda-lo a compilar e instalar o Hemlock em seu sistema.

## Instalacao Rapida (Recomendado)

A maneira mais simples de instalar o Hemlock e usando o script de instalacao de uma linha:

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash
```

Isso ira baixar e instalar o binario pre-compilado mais recente para sua plataforma (Linux ou macOS, x86_64 ou arm64).

### Opcoes de Instalacao

```bash
# Instalar em um prefixo personalizado (padrao: ~/.local)
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local

# Instalar uma versao especifica
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0

# Instalar e atualizar automaticamente o PATH do shell
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path
```

Apos a instalacao, verifique se esta funcionando corretamente:

```bash
hemlock --version
```

---

## Compilar a Partir do Codigo-Fonte

Se voce preferir compilar a partir do codigo-fonte, ou se os binarios pre-compilados nao estao disponiveis para seu sistema, siga as instrucoes abaixo.

## Pre-requisitos

### Dependencias Necessarias

A compilacao do Hemlock requer as seguintes dependencias:

- **Compilador C**: GCC ou Clang (padrao C11)
- **Make**: GNU Make
- **libffi**: Biblioteca de interface de funcoes externas (para suporte FFI)
- **OpenSSL**: Biblioteca de criptografia (para funcoes hash: md5, sha1, sha256)
- **libwebsockets**: Suporte a WebSocket e cliente/servidor HTTP
- **zlib**: Biblioteca de compressao

### Instalando Dependencias

**macOS:**
```bash
# Se ainda nao estiver instalado, instale o Homebrew primeiro
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Instale as ferramentas de linha de comando do Xcode
xcode-select --install

# Instale as dependencias via Homebrew
brew install libffi openssl@3 libwebsockets
```

**Nota para usuarios macOS**: O Makefile detecta automaticamente a instalacao do Homebrew e configura os caminhos corretos de include/library. O Hemlock suporta arquiteturas Intel (x86_64) e Apple Silicon (arm64).

**Ubuntu/Debian:**
```bash
sudo apt-get update
sudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev
```

**Fedora/RHEL:**
```bash
sudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel
```

**Arch Linux:**
```bash
sudo pacman -S base-devel libffi openssl libwebsockets zlib
```

## Compilar a Partir do Codigo-Fonte

### 1. Clonar o Repositorio

```bash
git clone https://github.com/hemlang/hemlock.git
cd hemlock
```

### 2. Compilar o Hemlock

```bash
make
```

Isso ira compilar o interpretador Hemlock e colocar o executavel no diretorio atual.

### 3. Verificar a Instalacao

```bash
./hemlock --version
```

Voce devera ver as informacoes de versao do Hemlock.

### 4. Testar a Compilacao

Execute a suite de testes para garantir que tudo esta funcionando corretamente:

```bash
make test
```

Todos os testes devem passar. Se voce encontrar alguma falha, por favor reporte como uma issue.

## Instalacao em Nivel de Sistema (Opcional)

Para instalar o Hemlock em nivel de sistema (por exemplo, em `/usr/local/bin`):

```bash
sudo make install
```

Isso permite executar `hemlock` de qualquer local sem especificar o caminho completo.

## Executar o Hemlock

### REPL Interativo

Inicie o laco de leitura-avaliacao-impressao (REPL):

```bash
./hemlock
```

Voce vera um prompt onde pode digitar codigo Hemlock:

```
Hemlock REPL
> print("Hello, World!");
Hello, World!
> let x = 42;
> print(x * 2);
84
>
```

Use `Ctrl+D` ou `Ctrl+C` para sair do REPL.

### Executar Programas

Execute um script Hemlock:

```bash
./hemlock program.hml
```

Com argumentos de linha de comando:

```bash
./hemlock program.hml arg1 arg2 "argumento com espacos"
```

## Estrutura de Diretorios

Apos a compilacao, seu diretorio Hemlock tera esta aparencia:

```
hemlock/
‚îú‚îÄ‚îÄ hemlock           # Executavel do interpretador compilado
‚îú‚îÄ‚îÄ src/              # Codigo-fonte
‚îú‚îÄ‚îÄ include/          # Arquivos de cabecalho
‚îú‚îÄ‚îÄ tests/            # Suite de testes
‚îú‚îÄ‚îÄ examples/         # Programas de exemplo
‚îú‚îÄ‚îÄ docs/             # Documentacao
‚îú‚îÄ‚îÄ stdlib/           # Biblioteca padrao
‚îú‚îÄ‚îÄ Makefile          # Configuracao de compilacao
‚îî‚îÄ‚îÄ README.md         # Descricao do projeto
```

## Opcoes de Compilacao

### Compilacao de Depuracao

Compilar com simbolos de depuracao e sem otimizacao:

```bash
make debug
```

### Limpar Compilacao

Remover todos os arquivos compilados:

```bash
make clean
```

Recompilar do zero:

```bash
make clean && make
```

## Solucao de Problemas

### macOS: Erro de Biblioteca Nao Encontrada

Se voce receber erros sobre bibliotecas ausentes (`-lcrypto`, `-lffi`, etc.):

1. Certifique-se de que as dependencias do Homebrew estao instaladas:
   ```bash
   brew install libffi openssl@3 libwebsockets
   ```

2. Verifique os caminhos do Homebrew:
   ```bash
   brew --prefix libffi
   brew --prefix openssl
   ```

3. O Makefile deve detectar esses caminhos automaticamente. Se nao detectar, verifique se `brew` esta no seu PATH:
   ```bash
   which brew
   ```

### macOS: Erros de Tipo BSD (`u_int`, `u_char` nao encontrados)

Se voce ver erros sobre nomes de tipo desconhecidos como `u_int` ou `u_char`:

1. Isso foi corrigido na versao v1.0.0+ usando `_DARWIN_C_SOURCE` em vez de `_POSIX_C_SOURCE`
2. Certifique-se de ter a versao mais recente do codigo
3. Limpe e recompile:
   ```bash
   make clean && make
   ```

### Linux: libffi Nao Encontrada

Se voce receber erros sobre `ffi.h` ou `-lffi` ausentes:

1. Certifique-se de que `libffi-dev` esta instalado (veja as dependencias acima)
2. Verifique se `pkg-config` consegue encontra-la:
   ```bash
   pkg-config --cflags --libs libffi
   ```
3. Se nao for encontrada, voce pode precisar definir `PKG_CONFIG_PATH`:
   ```bash
   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH
   ```

### Erros de Compilacao

Se voce encontrar erros de compilacao:

1. Certifique-se de ter um compilador compativel com C11
2. No macOS, tente usar Clang (padrao):
   ```bash
   make CC=clang
   ```
3. No Linux, tente usar GCC:
   ```bash
   make CC=gcc
   ```
4. Verifique se todas as dependencias estao instaladas
5. Tente recompilar do zero:
   ```bash
   make clean && make
   ```

### Falha nos Testes

Se os testes falharem:

1. Verifique se voce tem a versao mais recente do codigo
2. Tente recompilar do zero:
   ```bash
   make clean && make test
   ```
3. No macOS, certifique-se de ter as ferramentas de linha de comando do Xcode mais recentes:
   ```bash
   xcode-select --install
   ```
4. Reporte a issue no GitHub, incluindo:
   - Sua plataforma (versao do macOS / distribuicao Linux)
   - Arquitetura (x86_64 / arm64)
   - Saida do teste
   - Saida de `make -v` e `gcc --version` (ou `clang --version`)

## Proximos Passos

- [Guia de Inicio Rapido](#getting-started-quick-start) - Escreva seu primeiro programa Hemlock
- [Tutorial](#getting-started-tutorial) - Aprenda Hemlock passo a passo
- [Guia da Linguagem](#language-guide-syntax) - Explore os recursos do Hemlock


--------------------------------------------------------------------------------
## In√≠cio R√°pido
--------------------------------------------------------------------------------

# Inicio Rapido

Comece a usar o Hemlock em poucos minutos!

## Seu Primeiro Programa

Crie um arquivo chamado `hello.hml`:

```hemlock
print("Hello, Hemlock!");
```

Execute com o interpretador:

```bash
./hemlock hello.hml
```

Ou compile para um executavel nativo:

```bash
./hemlockc hello.hml -o hello
./hello
```

Saida:
```
Hello, Hemlock!
```

### Interpretador vs Compilador

O Hemlock oferece duas maneiras de executar programas:

| Ferramenta | Caso de Uso | Verificacao de Tipos |
|------------|-------------|----------------------|
| `hemlock` | Scripts rapidos, REPL, desenvolvimento | Apenas em tempo de execucao |
| `hemlockc` | Binarios de producao, melhor desempenho | Em tempo de compilacao (padrao) |

O compilador (`hemlockc`) verifica os tipos do seu codigo antes de gerar o executavel, capturando erros antecipadamente.

## Sintaxe Basica

### Variaveis

```hemlock
// Use 'let' para declarar variaveis
let x = 42;
let name = "Alice";
let pi = 3.14159;

// Anotacoes de tipo sao opcionais
let count: i32 = 100;
let ratio: f64 = 0.618;
```

**Importante**: Ponto e virgula e **obrigatorio** no Hemlock!

### Tipos

O Hemlock possui um sistema de tipos rico:

```hemlock
// Inteiros
let small: i8 = 127;          // 8 bits com sinal
let byte: u8 = 255;           // 8 bits sem sinal
let num: i32 = 2147483647;    // 32 bits com sinal (padrao)
let big: i64 = 9223372036854775807;  // 64 bits com sinal

// Ponto flutuante
let f: f32 = 3.14;            // 32 bits ponto flutuante
let d: f64 = 2.71828;         // 64 bits ponto flutuante (padrao)

// Strings e caracteres
let text: string = "Hello";   // String UTF-8
let emoji: rune = 'üöÄ';       // Ponto de codigo Unicode

// Booleano e nulo
let flag: bool = true;
let empty = null;
```

### Fluxo de Controle

```hemlock
// Instrucao if
if (x > 0) {
    print("Positivo");
} else if (x < 0) {
    print("Negativo");
} else {
    print("Zero");
}

// Laco while
let i = 0;
while (i < 5) {
    print(i);
    i = i + 1;
}

// Laco for
for (let j = 0; j < 10; j = j + 1) {
    print(j);
}
```

### Funcoes

```hemlock
// Funcao nomeada
fn add(a: i32, b: i32): i32 {
    return a + b;
}

let result = add(5, 3);  // 8

// Funcao anonima
let multiply = fn(x, y) {
    return x * y;
};

print(multiply(4, 7));  // 28
```

## Operacoes com Strings

Strings no Hemlock sao **mutaveis** e codificadas em **UTF-8**:

```hemlock
let s = "hello";
s[0] = 'H';              // Agora e "Hello"
print(s);

// Metodos de string
let upper = s.to_upper();     // "HELLO"
let words = "a,b,c".split(","); // ["a", "b", "c"]
let sub = s.substr(1, 3);     // "ell"

// Concatenacao
let greeting = "Hello" + ", " + "World!";
print(greeting);  // "Hello, World!"
```

## Arrays

Arrays dinamicos com suporte a tipos mistos:

```hemlock
let numbers = [1, 2, 3, 4, 5];
print(numbers[0]);      // 1
print(numbers.length);  // 5

// Metodos de array
numbers.push(6);        // [1, 2, 3, 4, 5, 6]
let last = numbers.pop();  // 6
let slice = numbers.slice(1, 4);  // [2, 3, 4]

// Tipos mistos permitidos
let mixed = [1, "two", true, null];
```

## Objetos

Objetos no estilo JavaScript:

```hemlock
// Literal de objeto
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};

print(person.name);  // "Alice"
person.age = 31;     // Modificar campo

// Metodos com 'self'
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    }
};

counter.increment();
print(counter.count);  // 1
```

## Gerenciamento de Memoria

O Hemlock usa **gerenciamento de memoria manual**:

```hemlock
// Buffer seguro (recomendado)
let buf = buffer(64);   // Alocar 64 bytes
buf[0] = 65;            // Definir primeiro byte como 'A'
print(buf[0]);          // 65
free(buf);              // Liberar memoria

// Ponteiros brutos (avancado)
let ptr = alloc(100);
memset(ptr, 0, 100);    // Preencher com zeros
free(ptr);
```

**Importante**: Voce deve usar `free()` na memoria que voce alocou com `alloc()`!

## Tratamento de Erros

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "Erro de divisao por zero";
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    print(result);
} catch (e) {
    print("Erro: " + e);
} finally {
    print("Concluido");
}
```

## Argumentos de Linha de Comando

Acesse os argumentos do programa atraves do array `args`:

```hemlock
// script.hml
print("Script:", args[0]);
print(`Numero de argumentos: ${args.length - 1}`);

let i = 1;
while (i < args.length) {
    print(`  Argumento ${i}: ${args[i]}`);
    i = i + 1;
}
```

Executar:
```bash
./hemlock script.hml hello world
```

Saida:
```
Script: script.hml
Numero de argumentos: 2
  Argumento 1: hello
  Argumento 2: world
```

## E/S de Arquivos

```hemlock
// Escrever em arquivo
let f = open("data.txt", "w");
f.write("Hello, File!");
f.close();

// Ler arquivo
let f2 = open("data.txt", "r");
let content = f2.read();
print(content);  // "Hello, File!"
f2.close();
```

## O Que Aprender a Seguir?

Agora que voce conhece o basico, pode explorar mais:

- [Tutorial](#getting-started-tutorial) - Guia completo passo a passo
- [Guia da Linguagem](#language-guide-syntax) - Aprofunde-se em todos os recursos
- [Exemplos](../../examples/) - Programas de exemplo do mundo real
- [Referencia da API](#reference-builtins) - Documentacao completa da API

## Armadilhas Comuns

### Esquecer o Ponto e Virgula

```hemlock
// ‚ùå Errado: falta ponto e virgula
let x = 42
let y = 10

// ‚úÖ Correto
let x = 42;
let y = 10;
```

### Esquecer de Liberar Memoria

```hemlock
// ‚ùå Vazamento de memoria
let buf = buffer(100);
// ... usar buf ...
// Esqueceu de chamar free(buf)!

// ‚úÖ Correto
let buf = buffer(100);
// ... usar buf ...
free(buf);
```

### Chaves Sao Obrigatorias

```hemlock
// ‚ùå Errado: faltam chaves
if (x > 0)
    print("Positivo");

// ‚úÖ Correto
if (x > 0) {
    print("Positivo");
}
```

## Obtendo Ajuda

- Leia a [documentacao completa](../README.md)
- Confira o [diretorio de exemplos](../../examples/)
- Veja os [arquivos de teste](../../tests/) para padroes de uso
- Reporte problemas no GitHub


--------------------------------------------------------------------------------
## Tutorial
--------------------------------------------------------------------------------

# Tutorial do Hemlock

Um guia completo passo a passo para aprender Hemlock.

## Sumario

1. [Hello World](#hello-world)
2. [Variaveis e Tipos](#variaveis-e-tipos)
3. [Aritmetica e Operacoes](#aritmetica-e-operacoes)
4. [Fluxo de Controle](#fluxo-de-controle)
5. [Funcoes](#funcoes)
6. [Strings e Caracteres](#strings-e-caracteres)
7. [Arrays](#arrays)
8. [Objetos](#objetos)
9. [Gerenciamento de Memoria](#gerenciamento-de-memoria)
10. [Tratamento de Erros](#tratamento-de-erros)
11. [E/S de Arquivos](#es-de-arquivos)
12. [Exemplo Completo](#exemplo-completo)

## Hello World

Vamos comecar com o tradicional primeiro programa:

```hemlock
print("Hello, World!");
```

Salve como `hello.hml` e execute:

```bash
./hemlock hello.hml
```

**Pontos-chave:**
- `print()` e uma funcao embutida que imprime na saida padrao
- Strings sao delimitadas por aspas duplas
- Ponto e virgula e **obrigatorio**

## Variaveis e Tipos

### Declarando Variaveis

```hemlock
// Declaracao basica de variaveis
let x = 42;
let name = "Alice";
let pi = 3.14159;

print(x);      // 42
print(name);   // Alice
print(pi);     // 3.14159
```

### Anotacoes de Tipo

Embora os tipos sejam inferidos por padrao, voce pode especifica-los explicitamente:

```hemlock
let age: i32 = 30;
let height: f64 = 5.9;
let initial: rune = 'A';
let active: bool = true;
```

### Inferencia de Tipos

O Hemlock infere os tipos com base nos valores:

```hemlock
let small = 42;              // i32 (cabe em 32 bits)
let large = 5000000000;      // i64 (muito grande para i32)
let decimal = 3.14;          // f64 (padrao para ponto flutuante)
let text = "hello";          // string
let flag = true;             // bool
```

### Verificacao de Tipos

```hemlock
// Use typeof() para verificar tipos
print(typeof(42));        // "i32"
print(typeof(3.14));      // "f64"
print(typeof("hello"));   // "string"
print(typeof(true));      // "bool"
print(typeof(null));      // "null"
```

## Aritmetica e Operacoes

### Aritmetica Basica

```hemlock
let a = 10;
let b = 3;

print(a + b);   // 13
print(a - b);   // 7
print(a * b);   // 30
print(a / b);   // 3 (divisao inteira)
print(a == b);  // false
print(a > b);   // true
```

### Promocao de Tipos

Ao misturar tipos, o Hemlock promove para o tipo maior/mais preciso:

```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // result e f64 (10.0 + 3.5 = 13.5)

print(result);       // 13.5
print(typeof(result)); // "f64"
```

### Operacoes Bit a Bit

```hemlock
let a = 12;  // Binario 1100
let b = 10;  // Binario 1010

print(a & b);   // 8  (AND)
print(a | b);   // 14 (OR)
print(a ^ b);   // 6  (XOR)
print(a << 1);  // 24 (deslocamento a esquerda)
print(a >> 1);  // 6  (deslocamento a direita)
print(~a);      // -13 (NOT)
```

## Fluxo de Controle

### Instrucao If

```hemlock
let x = 10;

if (x > 0) {
    print("Positivo");
} else if (x < 0) {
    print("Negativo");
} else {
    print("Zero");
}
```

**Nota:** Chaves sao **sempre obrigatorias**, mesmo para instrucoes unicas.

### Laco While

```hemlock
let count = 0;
while (count < 5) {
    print(`Contagem: ${count}`);
    count = count + 1;
}
```

### Laco For

```hemlock
// Laco for estilo C
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}

// Laco for-in (arrays)
let items = [10, 20, 30, 40];
for (let item in items) {
    print(`Item: ${item}`);
}
```

### Instrucao Switch

```hemlock
let day = 3;

switch (day) {
    case 1:
        print("Segunda-feira");
        break;
    case 2:
        print("Terca-feira");
        break;
    case 3:
        print("Quarta-feira");
        break;
    default:
        print("Outro dia");
        break;
}
```

### Break e Continue

```hemlock
// Break: sai do laco antecipadamente
let i = 0;
while (i < 10) {
    if (i == 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// Saida: 0, 1, 2, 3, 4

// Continue: pula para a proxima iteracao
for (let j = 0; j < 5; j = j + 1) {
    if (j == 2) {
        continue;
    }
    print(j);
}
// Saida: 0, 1, 3, 4
```

## Funcoes

### Funcoes Nomeadas

```hemlock
fn greet(name: string): string {
    return "Ola, " + name + "!";
}

let message = greet("Alice");
print(message);  // "Ola, Alice!"
```

### Funcoes Anonimas

```hemlock
let add = fn(a, b) {
    return a + b;
};

print(add(5, 3));  // 8
```

### Recursao

```hemlock
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

print(factorial(5));  // 120
```

### Closures

Funcoes capturam seu ambiente:

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
print(counter());  // 3
```

### Funcoes de Ordem Superior

```hemlock
fn apply(f, x) {
    return f(x);
}

fn double(n) {
    return n * 2;
}

let result = apply(double, 21);
print(result);  // 42
```

## Strings e Caracteres

### Basico de Strings

Strings sao **mutaveis** e codificadas em **UTF-8**:

```hemlock
let s = "hello";
print(s.length);      // 5 (contagem de caracteres)
print(s.byte_length); // 5 (contagem de bytes)

// Modificacao
s[0] = 'H';
print(s);  // "Hello"
```

### Metodos de String

```hemlock
let text = "  Hello, World!  ";

// Conversao de maiusculas/minusculas
print(text.to_upper());  // "  HELLO, WORLD!  "
print(text.to_lower());  // "  hello, world!  "

// Remover espacos em branco
print(text.trim());      // "Hello, World!"

// Extracao de substring
let hello = text.substr(2, 5);  // "Hello"
let world = text.slice(9, 14);  // "World"

// Busca
let pos = text.find("World");   // 9
let has = text.contains("o");   // true

// Divisao
let parts = "a,b,c".split(","); // ["a", "b", "c"]

// Substituicao
let s = "hello world".replace("world", "there");
print(s);  // "hello there"
```

### Caracteres (Pontos de Codigo Unicode)

```hemlock
let ch: rune = 'A';
let emoji: rune = 'üöÄ';

print(ch);      // 'A'
print(emoji);   // U+1F680

// Concatenacao de caractere + string
let msg = '>' + " Importante";
print(msg);  // "> Importante"

// Conversao entre caracteres e inteiros
let code: i32 = ch;     // 65 (codigo ASCII)
let r: rune = 128640;   // U+1F680 (üöÄ)
```

## Arrays

### Basico de Arrays

```hemlock
let numbers = [1, 2, 3, 4, 5];
print(numbers[0]);      // 1
print(numbers.length);  // 5

// Modificar elementos
numbers[2] = 99;
print(numbers[2]);  // 99
```

### Metodos de Array

```hemlock
let arr = [10, 20, 30];

// Adicionar/remover no final
arr.push(40);           // [10, 20, 30, 40]
let last = arr.pop();   // 40, arr agora e [10, 20, 30]

// Adicionar/remover no inicio
arr.unshift(5);         // [5, 10, 20, 30]
let first = arr.shift(); // 5, arr agora e [10, 20, 30]

// Inserir/remover em indice
arr.insert(1, 15);      // [10, 15, 20, 30]
let removed = arr.remove(2);  // 20

// Busca
let index = arr.find(15);     // 1
let has = arr.contains(10);   // true

// Fatiamento
let slice = arr.slice(0, 2);  // [10, 15]

// Juntar em string
let text = arr.join(", ");    // "10, 15, 30"
```

### Iteracao

```hemlock
let items = ["maca", "banana", "cereja"];

// Laco for-in
for (let item in items) {
    print(item);
}

// Iteracao manual
let i = 0;
while (i < items.length) {
    print(items[i]);
    i = i + 1;
}
```

## Objetos

### Literais de Objeto

```hemlock
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};

print(person.name);  // "Alice"
print(person.age);   // 30

// Adicionar/modificar campos
person.email = "alice@example.com";
person.age = 31;
```

### Metodos e `self`

```hemlock
let calculator = {
    value: 0,
    add: fn(x) {
        self.value = self.value + x;
    },
    get: fn() {
        return self.value;
    }
};

calculator.add(10);
calculator.add(5);
print(calculator.get());  // 15
```

### Definicoes de Tipo (Duck Typing)

```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,  // Campo opcional com valor padrao
}

let p = { name: "Bob", age: 25 };
let typed: Person = p;  // Duck typing valida a estrutura

print(typeof(typed));   // "Person"
print(typed.active);    // true (valor padrao aplicado)
```

### Serializacao JSON

```hemlock
let obj = { x: 10, y: 20, name: "test" };

// Objeto para JSON
let json = obj.serialize();
print(json);  // {"x":10,"y":20,"name":"test"}

// JSON para objeto
let restored = json.deserialize();
print(restored.name);  // "test"
```

## Gerenciamento de Memoria

### Buffers Seguros (Recomendado)

```hemlock
// Alocar buffer
let buf = buffer(10);
print(buf.length);    // 10
print(buf.capacity);  // 10

// Definir valores (com verificacao de limites)
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

// Acessar valores
print(buf[0]);  // 65

// Deve liberar quando terminar
free(buf);
```

### Ponteiros Brutos (Avancado)

```hemlock
// Alocar memoria bruta
let ptr = alloc(100);

// Preencher com zeros
memset(ptr, 0, 100);

// Copiar dados
let src = alloc(50);
memcpy(ptr, src, 50);

// Liberar ambos
free(src);
free(ptr);
```

### Funcoes de Memoria

```hemlock
// Realocar
let p = alloc(64);
p = realloc(p, 128);  // Redimensionar para 128 bytes
free(p);

// Alocacao tipada (recurso futuro)
// let arr = talloc(i32, 100);  // Array de 100 i32s
```

## Tratamento de Erros

### Try/Catch

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "Erro de divisao por zero";
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    print(result);
} catch (e) {
    print("Erro: " + e);
}
// Saida: Erro: Erro de divisao por zero
```

### Bloco Finally

```hemlock
let file = null;

try {
    file = open("data.txt", "r");
    let content = file.read();
    print(content);
} catch (e) {
    print("Erro: " + e);
} finally {
    // Sempre executa
    if (file != null) {
        file.close();
    }
}
```

### Lancando Objetos

```hemlock
try {
    throw { code: 404, message: "Nao encontrado" };
} catch (e) {
    print(`Erro ${e.code}: ${e.message}`);
}
// Saida: Erro 404: Nao encontrado
```

### Panic (Erro Irrecuperavel)

```hemlock
fn validate(x) {
    if (x < 0) {
        panic("x deve ser nao negativo");
    }
    return x * 2;
}

validate(-5);  // Programa sai com: panic: x deve ser nao negativo
```

## E/S de Arquivos

### Lendo Arquivos

```hemlock
// Ler arquivo inteiro
let f = open("data.txt", "r");
let content = f.read();
print(content);
f.close();

// Ler numero especifico de bytes
let f2 = open("data.txt", "r");
let chunk = f2.read(100);  // Ler 100 bytes
f2.close();
```

### Escrevendo Arquivos

```hemlock
// Escrever texto
let f = open("output.txt", "w");
f.write("Hello, File!\n");
f.write("Segunda linha\n");
f.close();

// Anexar ao arquivo
let f2 = open("output.txt", "a");
f2.write("Linha anexada\n");
f2.close();
```

### E/S Binaria

```hemlock
// Escrever dados binarios
let buf = buffer(256);
buf[0] = 255;
buf[1] = 128;

let f = open("data.bin", "w");
f.write_bytes(buf);
f.close();

// Ler dados binarios
let f2 = open("data.bin", "r");
let data = f2.read_bytes(256);
print(data[0]);  // 255
f2.close();

free(buf);
free(data);
```

### Propriedades de Arquivo

```hemlock
let f = open("/path/to/file.txt", "r");

print(f.path);    // "/path/to/file.txt"
print(f.mode);    // "r"
print(f.closed);  // false

f.close();
print(f.closed);  // true
```

## Exemplo Completo

Vamos construir um programa simples de contagem de palavras:

```hemlock
// wordcount.hml - Conta palavras em um arquivo

fn count_words(filename: string): i32 {
    let file = null;
    let count = 0;

    try {
        file = open(filename, "r");
        let content = file.read();

        // Dividir por espacos e contar
        let words = content.split(" ");
        count = words.length;

    } catch (e) {
        print("Erro ao ler arquivo: " + e);
        return -1;
    } finally {
        if (file != null) {
            file.close();
        }
    }

    return count;
}

// Programa principal
if (args.length < 2) {
    print("Uso: " + args[0] + " <nome_do_arquivo>");
} else {
    let filename = args[1];
    let words = count_words(filename);

    if (words >= 0) {
        print(`Contagem de palavras: ${words}`);
    }
}
```

Executar:
```bash
./hemlock wordcount.hml data.txt
```

## Proximos Passos

Parabens! Voce aprendeu o basico do Hemlock. A seguir, voce pode explorar:

- [Async e Concorrencia](#advanced-async-concurrency) - Multithreading real
- [FFI](#advanced-ffi) - Chamar funcoes C
- [Tratamento de Sinais](#advanced-signals) - Sinais de processo
- [Referencia da API](#reference-builtins) - Documentacao completa da API
- [Exemplos](../../examples/) - Mais programas do mundo real

## Exercicios

Tente construir estes programas para praticar:

1. **Calculadora**: Implemente uma calculadora simples que suporte +, -, *, /
2. **Copiador de Arquivos**: Copie um arquivo para outro
3. **Fibonacci**: Gere a sequencia de Fibonacci
4. **Analisador JSON**: Leia e analise um arquivo JSON
5. **Processador de Texto**: Encontre e substitua texto em um arquivo

Divirta-se programando com Hemlock!



################################################################################
# GUIA DA LINGUAGEM
################################################################################

--------------------------------------------------------------------------------
## Arrays
--------------------------------------------------------------------------------

# Arrays

Hemlock fornece **arrays din√¢micos** com m√©todos abrangentes para manipula√ß√£o e processamento de dados. Arrays podem armazenar tipos mistos e crescem automaticamente conforme necess√°rio.

## Vis√£o Geral

```hemlock
// Literal de array
let arr = [1, 2, 3, 4, 5];
print(arr[0]);         // 1
print(arr.length);     // 5

// Tipos mistos permitidos
let mixed = [1, "hello", true, null];

// Redimensionamento din√¢mico
arr.push(6);           // Cresce automaticamente
arr.push(7);
print(arr.length);     // 7
```

## Literais de Array

### Sintaxe B√°sica

```hemlock
let numbers = [1, 2, 3, 4, 5];
let strings = ["apple", "banana", "cherry"];
let booleans = [true, false, true];
```

### Array Vazio

```hemlock
let arr = [];  // Array vazio

// Adicionar elementos depois
arr.push(1);
arr.push(2);
arr.push(3);
```

### Tipos Mistos

Arrays podem conter tipos diferentes:

```hemlock
let mixed = [
    42,
    "hello",
    true,
    null,
    [1, 2, 3],
    { x: 10, y: 20 }
];

print(mixed[0]);  // 42
print(mixed[1]);  // "hello"
print(mixed[4]);  // [1, 2, 3] (array aninhado)
```

### Arrays Aninhados

```hemlock
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

print(matrix[0][0]);  // 1
print(matrix[1][2]);  // 6
print(matrix[2][1]);  // 8
```

### Arrays Tipados

Arrays podem usar anota√ß√µes de tipo para for√ßar tipo de elemento:

```hemlock
// Sintaxe de array tipado
let nums: array<i32> = [1, 2, 3, 4, 5];
let names: array<string> = ["Alice", "Bob", "Carol"];
let flags: array<bool> = [true, false, true];

// Verifica√ß√£o de tipo em tempo de execu√ß√£o
let valid: array<i32> = [1, 2, 3];       // Correto
let invalid: array<i32> = [1, "two", 3]; // Erro em execu√ß√£o: incompatibilidade de tipo

// Arrays tipados aninhados
let matrix: array<array<i32>> = [
    [1, 2, 3],
    [4, 5, 6]
];
```

**Comportamento de anota√ß√£o de tipo:**
- Elementos s√£o verificados quando adicionados ao array
- Incompatibilidade de tipo causa erro em tempo de execu√ß√£o
- Sem anota√ß√£o de tipo, arrays aceitam tipos mistos

## Indexa√ß√£o

### Lendo Elementos

Acesso com √≠ndice baseado em zero:

```hemlock
let arr = [10, 20, 30, 40, 50];

print(arr[0]);  // 10 (primeiro elemento)
print(arr[4]);  // 50 (√∫ltimo elemento)

// Acesso fora dos limites retorna null (sem erro)
print(arr[10]);  // null
```

### Escrevendo Elementos

```hemlock
let arr = [1, 2, 3];

arr[0] = 10;    // Modifica elemento existente
arr[1] = 20;
print(arr);     // [10, 20, 3]

// Pode atribuir al√©m do comprimento atual (array cresce)
arr[5] = 60;    // Cria [10, 20, 3, null, null, 60]
```

### √çndices Negativos

**N√£o suportados** - use apenas √≠ndices positivos:

```hemlock
let arr = [1, 2, 3];
print(arr[-1]);  // Erro ou comportamento indefinido

// Use length para obter √∫ltimo elemento
print(arr[arr.length - 1]);  // 3
```

## Propriedades

### Propriedade `.length`

Retorna o n√∫mero de elementos:

```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);  // 5

// Array vazio
let empty = [];
print(empty.length);  // 0

// Ap√≥s modifica√ß√£o
arr.push(6);
print(arr.length);  // 6
```

## M√©todos de Array

Hemlock fornece 18 m√©todos de array para opera√ß√µes abrangentes.

### Opera√ß√µes de Pilha

**`push(value)`** - Adiciona elemento no final:
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]

print(arr.length);     // 5
```

**`pop()`** - Remove e retorna o √∫ltimo elemento:
```hemlock
let arr = [1, 2, 3, 4, 5];
let last = arr.pop();  // Retorna 5, arr agora √© [1, 2, 3, 4]

print(last);           // 5
print(arr.length);     // 4
```

### Opera√ß√µes de Fila

**`shift()`** - Remove e retorna o primeiro elemento:
```hemlock
let arr = [1, 2, 3];
let first = arr.shift();   // Retorna 1, arr agora √© [2, 3]

print(first);              // 1
print(arr);                // [2, 3]
```

**`unshift(value)`** - Adiciona elemento no in√≠cio:
```hemlock
let arr = [2, 3];
arr.unshift(1);            // [1, 2, 3]
arr.unshift(0);            // [0, 1, 2, 3]
```

### Inser√ß√£o e Remo√ß√£o

**`insert(index, value)`** - Insere elemento no √≠ndice especificado:
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // Insere 3 no √≠ndice 2: [1, 2, 3, 4, 5]

arr.insert(0, 0);      // Insere no in√≠cio: [0, 1, 2, 3, 4, 5]
```

**`remove(index)`** - Remove e retorna elemento no √≠ndice especificado:
```hemlock
let arr = [1, 2, 3, 4, 5];
let removed = arr.remove(2);  // Retorna 3, arr agora √© [1, 2, 4, 5]

print(removed);               // 3
print(arr);                   // [1, 2, 4, 5]
```

### Opera√ß√µes de Busca

**`find(value)`** - Encontra a primeira ocorr√™ncia:
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2 (√≠ndice da primeira ocorr√™ncia)
let idx2 = arr.find(99);     // -1 (n√£o encontrado)

// Funciona com qualquer tipo
let words = ["apple", "banana", "cherry"];
let idx3 = words.find("banana");  // 1
```

**`contains(value)`** - Verifica se array cont√©m valor:
```hemlock
let arr = [10, 20, 30, 40];
let has = arr.contains(20);  // true
let has2 = arr.contains(99); // false
```

### Opera√ß√µes de Extra√ß√£o

**`slice(start, end)`** - Extrai subarray (end n√£o inclu√≠do):
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);   // [2, 3, 4] (√≠ndices 1, 2, 3)
let first = arr.slice(0, 2); // [1, 2]

// Array original n√£o muda
print(arr);                  // [1, 2, 3, 4, 5]
```

**`first()`** - Obt√©m o primeiro elemento (sem remover):
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1 (sem remover)
print(arr);                  // [1, 2, 3] (inalterado)
```

**`last()`** - Obt√©m o √∫ltimo elemento (sem remover):
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3 (sem remover)
print(arr);                  // [1, 2, 3] (inalterado)
```

### Opera√ß√µes de Transforma√ß√£o

**`reverse()`** - Inverte o array no local:
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]

print(arr);                  // [5, 4, 3, 2, 1] (modificado)
```

**`join(delimiter)`** - Une elementos em uma string:
```hemlock
let words = ["hello", "world", "foo"];
let joined = words.join(" ");  // "hello world foo"

let numbers = [1, 2, 3];
let csv = numbers.join(",");   // "1,2,3"

// Funciona com tipos mistos
let mixed = [1, "hello", true, null];
print(mixed.join(" | "));  // "1 | hello | true | null"
```

**`concat(other)`** - Concatena com outro array:
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (novo array)

// Arrays originais n√£o mudam
print(a);                    // [1, 2, 3]
print(b);                    // [4, 5, 6]
```

### Opera√ß√µes Utilit√°rias

**`clear()`** - Remove todos os elementos:
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();                 // []

print(arr.length);           // 0
print(arr);                  // []
```

## Encadeamento de M√©todos

M√©todos que retornam arrays ou valores podem ser encadeados:

```hemlock
let result = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);  // [3, 4, 5]

let text = ["apple", "banana", "cherry"]
    .slice(0, 2)
    .join(" and ");  // "apple and banana"

let numbers = [5, 3, 8, 1, 9]
    .slice(1, 4)
    .concat([10, 11]);  // [3, 8, 1, 10, 11]
```

## Refer√™ncia Completa de M√©todos

| M√©todo | Par√¢metros | Retorno | Modifica Original | Descri√ß√£o |
|--------|-----------|---------|---------|-------------|
| `push(value)` | any | void | Sim | Adiciona elemento no final |
| `pop()` | - | any | Sim | Remove e retorna √∫ltimo elemento |
| `shift()` | - | any | Sim | Remove e retorna primeiro elemento |
| `unshift(value)` | any | void | Sim | Adiciona elemento no in√≠cio |
| `insert(index, value)` | i32, any | void | Sim | Insere no √≠ndice especificado |
| `remove(index)` | i32 | any | Sim | Remove e retorna elemento no √≠ndice |
| `find(value)` | any | i32 | N√£o | Encontra primeira ocorr√™ncia (retorna -1 se n√£o encontrado) |
| `contains(value)` | any | bool | N√£o | Verifica se cont√©m valor |
| `slice(start, end)` | i32, i32 | array | N√£o | Extrai subarray (novo array) |
| `join(delimiter)` | string | string | N√£o | Une em string |
| `concat(other)` | array | array | N√£o | Concatena arrays (novo array) |
| `reverse()` | - | void | Sim | Inverte no local |
| `first()` | - | any | N√£o | Obt√©m primeiro elemento |
| `last()` | - | any | N√£o | Obt√©m √∫ltimo elemento |
| `clear()` | - | void | Sim | Remove todos os elementos |
| `map(callback)` | fn | array | N√£o | Transforma cada elemento |
| `filter(predicate)` | fn | array | N√£o | Seleciona elementos correspondentes |
| `reduce(callback, initial)` | fn, any | any | N√£o | Reduz a um √∫nico valor |

## Detalhes de Implementa√ß√£o

### Modelo de Mem√≥ria

- **Aloca√ß√£o no heap** - Capacidade din√¢mica
- **Crescimento autom√°tico** - Dobra quando excede capacidade
- **Sem encolhimento autom√°tico** - Capacidade n√£o diminui
- **Sem verifica√ß√£o de limites no √≠ndice** - Use m√©todos para seguran√ßa

### Gerenciamento de Capacidade

```hemlock
let arr = [];  // Capacidade inicial: 0

arr.push(1);   // Cresce para capacidade 1
arr.push(2);   // Cresce para capacidade 2
arr.push(3);   // Cresce para capacidade 4 (dobra)
arr.push(4);   // Ainda capacidade 4
arr.push(5);   // Cresce para capacidade 8 (dobra)
```

### Compara√ß√£o de Valores

`find()` e `contains()` usam compara√ß√£o de igualdade de valor:

```hemlock
// Tipos primitivos: compara por valor
let arr = [1, 2, 3];
arr.contains(2);  // true

// Strings: compara por valor
let words = ["hello", "world"];
words.contains("hello");  // true

// Objetos: compara por refer√™ncia
let obj1 = { x: 10 };
let obj2 = { x: 10 };
let arr2 = [obj1];
arr2.contains(obj1);  // true (mesma refer√™ncia)
arr2.contains(obj2);  // false (refer√™ncia diferente)
```

## Padr√µes Comuns

### Opera√ß√µes Funcionais (map/filter/reduce)

Arrays t√™m m√©todos `map`, `filter` e `reduce` embutidos:

```hemlock
// map - transforma cada elemento
let numbers = [1, 2, 3, 4, 5];
let doubled = numbers.map(fn(x) { return x * 2; });
print(doubled);  // [2, 4, 6, 8, 10]

// filter - seleciona elementos correspondentes
let evens = numbers.filter(fn(x) { return x % 2 == 0; });
print(evens);  // [2, 4]

// reduce - reduz a um √∫nico valor
let sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);
print(sum);  // 15

// Encadeando opera√ß√µes funcionais
let result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]
    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]
    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220
```

### Padr√£o: Array como Pilha

```hemlock
let stack = [];

// Empilhar
stack.push(1);
stack.push(2);
stack.push(3);

// Desempilhar
let top = stack.pop();    // 3
let next = stack.pop();   // 2
```

### Padr√£o: Array como Fila

```hemlock
let queue = [];

// Enfileirar (adicionar no final)
queue.push(1);
queue.push(2);
queue.push(3);

// Desenfileirar (remover do in√≠cio)
let first = queue.shift();   // 1
let second = queue.shift();  // 2
```

## Melhores Pr√°ticas

1. **Use m√©todos em vez de √≠ndice direto** - Verifica√ß√£o de limites e clareza de c√≥digo
2. **Verifique limites** - Indexa√ß√£o direta n√£o verifica limites
3. **Prefira opera√ß√µes imut√°veis** - Use `slice()` e `concat()` em vez de modificar original
4. **Pr√©-inicialize capacidade** - Se souber o tamanho (n√£o suportado atualmente)
5. **Use `contains()` para verificar pertin√™ncia** - Mais claro que loop manual
6. **Encadeie m√©todos** - Mais leg√≠vel que chamadas aninhadas

## Armadilhas Comuns

### Armadilha: √çndice Direto Fora dos Limites

```hemlock
let arr = [1, 2, 3];

// Sem verifica√ß√£o de limites!
arr[10] = 99;  // Cria array esparso com null
print(arr.length);  // 11 (n√£o 3!)

// Melhor: use push() ou verifique length
if (arr.length <= 10) {
    arr.push(99);
}
```

### Armadilha: Modifica√ß√£o vs Novo Array

```hemlock
let arr = [1, 2, 3];

// Modifica original
arr.reverse();
print(arr);  // [3, 2, 1]

// Retorna novo array
let sub = arr.slice(0, 2);
print(arr);  // [3, 2, 1] (inalterado)
print(sub);  // [3, 2]
```

### Armadilha: Igualdade de Refer√™ncia

```hemlock
let obj = { x: 10 };
let arr = [obj];

// Mesma refer√™ncia: true
arr.contains(obj);  // true

// Refer√™ncia diferente: false
arr.contains({ x: 10 });  // false (objeto diferente)
```

### Armadilha: Arrays de Longa Dura√ß√£o

```hemlock
// Arrays em escopo local s√£o liberados automaticamente, mas arrays globais/de longa dura√ß√£o precisam aten√ß√£o
let global_cache = [];  // N√≠vel de m√≥dulo, persiste at√© fim do programa

fn add_to_cache(item) {
    global_cache.push(item);  // Cresce infinitamente
}

// Para dados de longa dura√ß√£o, considere:
// - Limpar o array periodicamente: global_cache.clear();
// - Liberar antecipadamente: free(global_cache);
```

## Exemplos

### Exemplo: Estat√≠sticas de Array

```hemlock
fn mean(arr) {
    let sum = 0;
    let i = 0;
    while (i < arr.length) {
        sum = sum + arr[i];
        i = i + 1;
    }
    return sum / arr.length;
}

fn max(arr) {
    if (arr.length == 0) {
        return null;
    }

    let max_val = arr[0];
    let i = 1;
    while (i < arr.length) {
        if (arr[i] > max_val) {
            max_val = arr[i];
        }
        i = i + 1;
    }
    return max_val;
}

let numbers = [3, 7, 2, 9, 1];
print(mean(numbers));  // 4.4
print(max(numbers));   // 9
```

### Exemplo: Remo√ß√£o de Duplicados

```hemlock
fn unique(arr) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        if (!result.contains(arr[i])) {
            result.push(arr[i]);
        }
        i = i + 1;
    }
    return result;
}

let numbers = [1, 2, 2, 3, 1, 4, 3, 5];
let uniq = unique(numbers);  // [1, 2, 3, 4, 5]
```

### Exemplo: Dividir em Blocos

```hemlock
fn chunk(arr, size) {
    let result = [];
    let i = 0;

    while (i < arr.length) {
        let chunk = arr.slice(i, i + size);
        result.push(chunk);
        i = i + size;
    }

    return result;
}

let numbers = [1, 2, 3, 4, 5, 6, 7, 8];
let chunks = chunk(numbers, 3);
// [[1, 2, 3], [4, 5, 6], [7, 8]]
```

### Exemplo: Achatar Array

```hemlock
fn flatten(arr) {
    let result = [];
    let i = 0;

    while (i < arr.length) {
        if (typeof(arr[i]) == "array") {
            // Array aninhado - achatar
            let nested = flatten(arr[i]);
            let j = 0;
            while (j < nested.length) {
                result.push(nested[j]);
                j = j + 1;
            }
        } else {
            result.push(arr[i]);
        }
        i = i + 1;
    }

    return result;
}

let nested = [1, [2, 3], [4, [5, 6]], 7];
let flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]
```

### Exemplo: Ordena√ß√£o (Bubble Sort)

```hemlock
fn sort(arr) {
    let n = arr.length;
    let i = 0;

    while (i < n) {
        let j = 0;
        while (j < n - i - 1) {
            if (arr[j] > arr[j + 1]) {
                // Troca
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

let numbers = [5, 2, 8, 1, 9];
sort(numbers);  // Modifica no local
print(numbers);  // [1, 2, 5, 8, 9]
```

## Limita√ß√µes

Limita√ß√µes atuais:

- **Sem verifica√ß√£o de limites no √≠ndice** - Acesso direto n√£o verifica limites
- **Objetos usam igualdade de refer√™ncia** - `find()` e `contains()` usam compara√ß√£o de refer√™ncia
- **Sem desestrutura√ß√£o de array** - Sintaxe `let [a, b] = arr` n√£o suportada
- **Sem operador spread** - Sintaxe `[...arr1, ...arr2]` n√£o suportada

**Nota:** Arrays usam contagem de refer√™ncia, sendo liberados automaticamente ao sair do escopo. Veja [Gerenciamento de Mem√≥ria](memory.md#internal-reference-counting) para detalhes.

## T√≥picos Relacionados

- [Strings](#language-guide-strings) - M√©todos de string s√£o similares aos de array
- [Objetos](#language-guide-objects) - Arrays tamb√©m s√£o tipo objeto
- [Fun√ß√µes](#language-guide-functions) - Arrays e fun√ß√µes de ordem superior
- [Fluxo de Controle](#language-guide-control-flow) - Itera√ß√£o sobre arrays

## Veja Tamb√©m

- **Tamanho din√¢mico**: Arrays crescem automaticamente dobrando capacidade
- **M√©todos**: 18 m√©todos abrangentes de opera√ß√£o, incluindo map/filter/reduce
- **Mem√≥ria**: Veja [Mem√≥ria](#language-guide-memory) para detalhes de aloca√ß√£o de arrays


--------------------------------------------------------------------------------
## Correspond√™ncia de Padr√µes
--------------------------------------------------------------------------------

# Correspondencia de Padroes

Hemlock fornece correspondencia de padroes poderosa atraves de expressoes `match`, oferecendo uma forma concisa de desestruturar valores, verificar tipos e tratar multiplos casos.

## Sintaxe Basica

```hemlock
let resultado = match (valor) {
    padrao1 => expressao1,
    padrao2 => expressao2,
    _ => expressao_padrao
};
```

A expressao match compara `valor` com cada padrao em ordem, retornando o resultado da expressao do primeiro branch que corresponder.

## Tipos de Padroes

### Padroes Literais

Corresponde a valores exatos:

```hemlock
let x = 42;
let msg = match (x) {
    0 => "zero",
    1 => "um",
    42 => "a resposta",
    _ => "outro"
};
print(msg);  // "a resposta"
```

Literais suportados:
- **Inteiros**: `0`, `42`, `-5`
- **Ponto flutuante**: `3.14`, `-0.5`
- **Strings**: `"hello"`, `"world"`
- **Booleanos**: `true`, `false`
- **Nulo**: `null`

### Padrao Curinga (`_`)

Corresponde a qualquer valor mas nao vincula:

```hemlock
let x = "qualquer coisa";
let resultado = match (x) {
    "especifico" => "encontrei",
    _ => "curinga correspondeu"
};
```

### Padrao de Vinculacao de Variavel

Vincula o valor correspondido a uma variavel:

```hemlock
let x = 100;
let resultado = match (x) {
    0 => "zero",
    n => "valor e " + n  // n vinculado a 100
};
print(resultado);  // "valor e 100"
```

### Padroes OR (`|`)

Corresponde a multiplas alternativas:

```hemlock
let x = 2;
let tamanho = match (x) {
    1 | 2 | 3 => "pequeno",
    4 | 5 | 6 => "medio",
    _ => "grande"
};

// Tambem funciona com strings
let cmd = "quit";
let acao = match (cmd) {
    "exit" | "quit" | "q" => "saindo",
    "help" | "h" | "?" => "mostrando ajuda",
    _ => "desconhecido"
};
```

### Expressoes de Guarda (`if`)

Adiciona condicoes aos padroes:

```hemlock
let x = 15;
let categoria = match (x) {
    n if n < 0 => "negativo",
    n if n == 0 => "zero",
    n if n < 10 => "pequeno",
    n if n < 100 => "medio",
    n => "grande: " + n
};
print(categoria);  // "medio"

// Guardas complexas
let y = 12;
let resultado = match (y) {
    n if n % 2 == 0 && n > 10 => "par e maior que 10",
    n if n % 2 == 0 => "par",
    n => "impar"
};
```

### Padroes de Tipo

Verifica e vincula baseado em tipo:

```hemlock
let val = 42;
let desc = match (val) {
    num: i32 => "inteiro: " + num,
    str: string => "string: " + str,
    flag: bool => "booleano: " + flag,
    _ => "outro tipo"
};
print(desc);  // "inteiro: 42"
```

Tipos suportados: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`, `bool`, `string`, `array`, `object`

## Padroes de Desestruturacao

### Desestruturacao de Objetos

Extrai campos de objetos:

```hemlock
let ponto = { x: 10, y: 20 };
let resultado = match (ponto) {
    { x, y } => "ponto em " + x + "," + y
};
print(resultado);  // "ponto em 10,20"

// Com valores literais de campos
let origem = { x: 0, y: 0 };
let nome = match (origem) {
    { x: 0, y: 0 } => "origem",
    { x: 0, y } => "no eixo y em " + y,
    { x, y: 0 } => "no eixo x em " + x,
    { x, y } => "ponto em " + x + "," + y
};
print(nome);  // "origem"
```

### Desestruturacao de Arrays

Corresponde a estrutura e elementos de arrays:

```hemlock
let arr = [1, 2, 3];
let desc = match (arr) {
    [] => "vazio",
    [x] => "unico: " + x,
    [x, y] => "par: " + x + "," + y,
    [x, y, z] => "tripla: " + x + "," + y + "," + z,
    _ => "muitos elementos"
};
print(desc);  // "tripla: 1,2,3"

// Com valores literais
let par = [1, 2];
let resultado = match (par) {
    [0, 0] => "ambos zero",
    [1, x] => "comeca com 1, segundo e " + x,
    [x, 1] => "termina com 1",
    _ => "outro"
};
print(resultado);  // "comeca com 1, segundo e 2"
```

### Padrao Rest de Array (`...`)

Captura elementos restantes:

```hemlock
let nums = [1, 2, 3, 4, 5];

// Cabeca e cauda
let resultado = match (nums) {
    [primeiro, ...resto] => "primeiro: " + primeiro,
    [] => "vazio"
};
print(resultado);  // "primeiro: 1"

// Dois primeiros elementos
let resultado2 = match (nums) {
    [a, b, ...resto] => "dois primeiros: " + a + "," + b,
    _ => "muito curto"
};
print(resultado2);  // "dois primeiros: 1,2"
```

### Desestruturacao Aninhada

Combina padroes para dados complexos:

```hemlock
let usuario = {
    name: "Alice",
    address: { city: "NYC", zip: 10001 }
};

let resultado = match (usuario) {
    { name, address: { city, zip } } => name + " mora em " + city,
    _ => "desconhecido"
};
print(resultado);  // "Alice mora em NYC"

// Objeto contendo array
let dados = { items: [1, 2, 3], count: 3 };
let resultado2 = match (dados) {
    { items: [primeiro, ...resto], count } => "primeiro: " + primeiro + ", total: " + count,
    _ => "sem items"
};
print(resultado2);  // "primeiro: 1, total: 3"
```

## Match como Expressao

Match e uma expressao que retorna um valor:

```hemlock
// Atribuicao direta
let nota = 85;
let letra = match (nota) {
    n if n >= 90 => "A",
    n if n >= 80 => "B",
    n if n >= 70 => "C",
    n if n >= 60 => "D",
    _ => "F"
};

// Em concatenacao de string
let msg = "Nota: " + match (nota) {
    n if n >= 70 => "aprovado",
    _ => "reprovado"
};

// Em retorno de funcao
fn classificar(n: i32): string {
    return match (n) {
        0 => "zero",
        n if n > 0 => "positivo",
        _ => "negativo"
    };
}
```

## Melhores Praticas de Correspondencia de Padroes

1. **Ordem importa**: Padroes sao verificados de cima para baixo; coloque padroes especificos antes dos genericos
2. **Use curinga para completude**: Sempre inclua fallback `_` a menos que tenha certeza de que todos os casos estao cobertos
3. **Prefira guardas a condicoes aninhadas**: Guardas tornam a intencao mais clara
4. **Use desestruturacao em vez de acesso manual a campos**: Mais conciso e seguro

```hemlock
// Bom: use guardas para verificacao de intervalos
match (pontuacao) {
    n if n >= 90 => "A",
    n if n >= 80 => "B",
    _ => "abaixo de B"
}

// Bom: desestruturacao em vez de acessar campos
match (ponto) {
    { x: 0, y: 0 } => "origem",
    { x, y } => "em " + x + "," + y
}

// Evite: padroes aninhados muito complexos
// Considere dividir em multiplos match ou usar guardas
```

## Comparacao com Outras Linguagens

| Recurso | Hemlock | Rust | JavaScript |
|---------|---------|------|------------|
| Match basico | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |
| Desestruturacao | Sim | Sim | Parcial (switch nao desestrutura) |
| Guardas | `n if n > 0 =>` | `n if n > 0 =>` | N/A |
| Padroes OR | `1 \| 2 \| 3 =>` | `1 \| 2 \| 3 =>` | `case 1: case 2: case 3:` |
| Padroes rest | `[a, ...resto]` | `[a, resto @ ..]` | N/A |
| Padroes de tipo | `n: i32` | Via tipos em branches `match` | N/A |
| Retorna valor | Sim | Sim | Nao (declaracao) |

## Notas de Implementacao

Correspondencia de padroes e implementada tanto no interpretador quanto no backend do compilador com paridade completa - ambos produzem resultados identicos para a mesma entrada. O recurso esta disponivel no Hemlock v1.8.0+.


--------------------------------------------------------------------------------
## Fluxo de Controle
--------------------------------------------------------------------------------

# Fluxo de Controle

Hemlock fornece fluxo de controle familiar no estilo C, exigindo o uso obrigat√≥rio de chaves e sintaxe expl√≠cita. Este guia abrange declara√ß√µes condicionais, loops, declara√ß√µes switch e operadores.

## Visao Geral

Recursos de fluxo de controle dispon√≠veis:

- `if`/`else`/`else if` - Ramifica√ß√£o condicional
- `while` loops - Itera√ß√£o baseada em condi√ß√£o
- `for` loops - Estilo C e itera√ß√£o for-in
- `loop` - Loop infinito (mais claro que `while (true)`)
- Declara√ß√µes `switch` - Ramifica√ß√£o m√∫ltipla
- `break`/`continue` - Controle de loop
- R√≥tulos de loop - break/continue direcionado para loops aninhados
- `defer` - Execu√ß√£o adiada (limpeza)
- Operadores booleanos: `&&`, `||`, `!`
- Operadores de compara√ß√£o: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Operadores bit a bit: `&`, `|`, `^`, `<<`, `>>`, `~`

## Declara√ß√µes If

### If/Else B√°sico

```hemlock
if (x > 10) {
    print("grande");
} else {
    print("pequeno");
}
```

**Regras:**
- Todas as ramifica√ß√µes **devem** usar chaves
- Condi√ß√µes devem estar entre par√™nteses
- Chaves opcionais n√£o s√£o suportadas (diferente de C)

### If Sem Else

```hemlock
if (x > 0) {
    print("positivo");
}
// Ramifica√ß√£o else n√£o √© necess√°ria
```

### Cadeia Else-If

```hemlock
if (x > 100) {
    print("muito grande");
} else if (x > 50) {
    print("grande");
} else if (x > 10) {
    print("m√©dio");
} else {
    print("pequeno");
}
```

**Nota:** `else if` √© a√ß√∫car sint√°tico para declara√ß√µes if aninhadas. As duas formas a seguir s√£o equivalentes:

```hemlock
// else if (a√ß√∫car sint√°tico)
if (a) {
    foo();
} else if (b) {
    bar();
}

// if aninhado equivalente
if (a) {
    foo();
} else {
    if (b) {
        bar();
    }
}
```

### Declara√ß√µes If Aninhadas

```hemlock
if (x > 0) {
    if (x < 10) {
        print("d√≠gito √∫nico positivo");
    } else {
        print("m√∫ltiplos d√≠gitos positivos");
    }
} else {
    print("n√£o positivo");
}
```

## Loops While

Itera√ß√£o baseada em condi√ß√£o:

```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

**Loop infinito (estilo antigo):**
```hemlock
while (true) {
    // ... executar trabalho
    if (should_exit) {
        break;
    }
}
```

**Nota:** Para loops infinitos, recomenda-se usar a palavra-chave `loop` (veja abaixo).

## Loop (Loop Infinito)

A palavra-chave `loop` fornece uma sintaxe mais clara para loops infinitos:

```hemlock
loop {
    // ... executar trabalho
    if (should_exit) {
        break;
    }
}
```

**Equivalente a `while (true)`, mas com inten√ß√£o mais clara.**

### Loop B√°sico com Break

```hemlock
let i = 0;
loop {
    if (i >= 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// Sa√≠da: 0, 1, 2, 3, 4
```

### Loop com Continue

```hemlock
let i = 0;
loop {
    i = i + 1;
    if (i > 5) {
        break;
    }
    if (i == 3) {
        continue;  // Pula a impress√£o de 3
    }
    print(i);
}
// Sa√≠da: 1, 2, 4, 5
```

### Loops Aninhados

```hemlock
let x = 0;
loop {
    if (x >= 2) { break; }
    let y = 0;
    loop {
        if (y >= 3) { break; }
        print(x * 10 + y);
        y = y + 1;
    }
    x = x + 1;
}
// Sa√≠da: 0, 1, 2, 10, 11, 12
```

### Quando Usar Loop

- **Use `loop`** - Para loops infinitos intencionais, saindo com `break`
- **Use `while`** - Quando h√° uma condi√ß√£o natural de t√©rmino
- **Use `for`** - Ao iterar um n√∫mero conhecido de vezes ou sobre cole√ß√µes

## Loops For

### For Estilo C

Loop for cl√°ssico de tr√™s partes:

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**Componentes:**
- **Inicializador**: `let i = 0` - Executa uma vez antes do loop
- **Condi√ß√£o**: `i < 10` - Verificada antes de cada itera√ß√£o
- **Atualiza√ß√£o**: `i = i + 1` - Executa ap√≥s cada itera√ß√£o

**Escopo:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
// i n√£o √© acess√≠vel aqui (escopo do loop)
```

### Loops For-In

Itera sobre elementos de array:

```hemlock
let arr = [1, 2, 3, 4, 5];
for (let item in arr) {
    print(item);  // Imprime cada elemento
}
```

**Com √≠ndice e valor:**
```hemlock
let arr = ["a", "b", "c"];
for (let i = 0; i < arr.length; i = i + 1) {
    print(`√çndice: ${i}, Valor: ${arr[i]}`);
}
```

## Declara√ß√µes Switch

Ramifica√ß√£o m√∫ltipla baseada em valor:

### Switch B√°sico

```hemlock
let x = 2;

switch (x) {
    case 1:
        print("um");
        break;
    case 2:
        print("dois");
        break;
    case 3:
        print("tr√™s");
        break;
}
```

### Switch com Default

```hemlock
let color = "azul";

switch (color) {
    case "vermelho":
        print("parar");
        break;
    case "amarelo":
        print("desacelerar");
        break;
    case "verde":
        print("seguir");
        break;
    default:
        print("cor desconhecida");
        break;
}
```

**Regras:**
- `default` executa quando nenhum outro case corresponde
- `default` pode aparecer em qualquer posi√ß√£o no corpo do switch
- Apenas um case default √© permitido

### Comportamento de Fall-through

Cases sem `break` passam para o pr√≥ximo case (comportamento estilo C). Isso √© **intencional** e pode ser usado para agrupar cases:

```hemlock
let nota = 85;

switch (nota) {
    case 100:
    case 95:
    case 90:
        print("A");
        break;
    case 85:
    case 80:
        print("B");
        break;
    default:
        print("C ou abaixo");
        break;
}
```

**Exemplo de fall-through expl√≠cito:**
```hemlock
let dia = 3;

switch (dia) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        print("Dia de semana");
        break;
    case 6:
    case 7:
        print("Fim de semana");
        break;
}
```

**Importante:** Diferente de algumas linguagens modernas, Hemlock n√£o requer uma palavra-chave `fallthrough` expl√≠cita. A menos que terminados com `break`, `return` ou `throw`, cases passam automaticamente para o pr√≥ximo. Sempre use `break` para evitar fall-through acidental.

### Switch com Return

Em fun√ß√µes, `return` sai imediatamente do switch:

```hemlock
fn get_day_name(dia: i32): string {
    switch (dia) {
        case 1:
            return "Segunda";
        case 2:
            return "Ter√ßa";
        case 3:
            return "Quarta";
        default:
            return "Desconhecido";
    }
}
```

### Tipos de Valor em Switch

Switch funciona com qualquer tipo de valor:

```hemlock
// Inteiros
switch (contador) {
    case 0: print("zero"); break;
    case 1: print("um"); break;
}

// Strings
switch (nome) {
    case "Alice": print("A"); break;
    case "Bob": print("B"); break;
}

// Booleanos
switch (flag) {
    case true: print("ligado"); break;
    case false: print("desligado"); break;
}
```

**Nota:** Cases usam igualdade de valor para compara√ß√£o.

## Break e Continue

### Break

Sai do loop ou switch mais interno:

```hemlock
// Em loop
let i = 0;
while (true) {
    if (i >= 10) {
        break;  // Sai do loop
    }
    print(i);
    i = i + 1;
}

// Em switch
switch (x) {
    case 1:
        print("um");
        break;  // Sai do switch
    case 2:
        print("dois");
        break;
}
```

### Continue

Pula para a pr√≥xima itera√ß√£o do loop:

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;  // Pula quando i √© 5
    }
    print(i);  // Imprime 0,1,2,3,4,6,7,8,9
}
```

**Diferen√ßa:**
- `break` - Sai completamente do loop
- `continue` - Pula para a pr√≥xima itera√ß√£o

## R√≥tulos de Loop

R√≥tulos de loop permitem que `break` e `continue` direcionem loops externos espec√≠ficos, n√£o apenas o loop mais interno. Isso √© √∫til em loops aninhados onde voc√™ precisa controlar o loop externo a partir do loop interno.

### Break com R√≥tulo

Sai do loop externo a partir do loop interno:

```hemlock
outer: while (i < 3) {
    let j = 0;
    while (j < 3) {
        if (i == 1 && j == 1) {
            break outer;  // Sai do while externo
        }
        print(i * 10 + j);
        j = j + 1;
    }
    i = i + 1;
}
// Sa√≠da: 0, 1, 2, 10 (para em i=1, j=1)
```

### Continue com R√≥tulo

Pula para a pr√≥xima itera√ß√£o do loop externo:

```hemlock
let i = 0;
outer: while (i < 3) {
    i = i + 1;
    let j = 0;
    while (j < 3) {
        j = j + 1;
        if (i == 2 && j == 1) {
            continue outer;  // Pula o resto do loop interno, continua o externo
        }
        print(i * 10 + j);
    }
}
// Quando i=2, j=1: pula para a pr√≥xima itera√ß√£o do loop externo
```

### R√≥tulos em Loops For

R√≥tulos funcionam com todos os tipos de loop:

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 3; y = y + 1) {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
    }
}
```

### R√≥tulos em Loops For-In

```hemlock
let arr1 = [1, 2, 3];
let arr2 = [10, 20, 30];

outer: for (let a in arr1) {
    for (let b in arr2) {
        if (a == 2 && b == 20) {
            break outer;
        }
        print(a * 100 + b);
    }
}
```

### R√≥tulos com Palavra-chave Loop

```hemlock
let x = 0;
outer: loop {
    let y = 0;
    loop {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
        y = y + 1;
        if (y >= 3) { break; }
    }
    x = x + 1;
    if (x >= 3) { break; }
}
```

### M√∫ltiplos R√≥tulos

Voc√™ pode usar r√≥tulos em diferentes n√≠veis de aninhamento:

```hemlock
outer: for (let a = 0; a < 2; a = a + 1) {
    inner: for (let b = 0; b < 3; b = b + 1) {
        for (let c = 0; c < 3; c = c + 1) {
            if (c == 1) {
                continue inner;  // Pula para a pr√≥xima itera√ß√£o do loop do meio
            }
            if (a == 1 && b == 1) {
                break outer;      // Sai do loop mais externo
            }
            print(a * 100 + b * 10 + c);
        }
    }
}
```

### Break/Continue Sem R√≥tulo em Loops com R√≥tulo

`break` e `continue` sem r√≥tulo ainda funcionam normalmente (afetam o loop mais interno), mesmo quando loops externos t√™m r√≥tulos:

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 5; y = y + 1) {
        if (y == 2) {
            break;  // Sai apenas do loop interno
        }
        print(x * 10 + y);
    }
}
// Sa√≠da: 0, 1, 10, 11, 20, 21
```

### Sintaxe de R√≥tulos

- R√≥tulos s√£o identificadores seguidos de dois-pontos
- R√≥tulos devem preceder imediatamente a declara√ß√£o do loop (`while`, `for`, `loop`)
- Nomes de r√≥tulos seguem regras de identificadores (letras, n√∫meros, sublinhados)
- Conven√ß√µes comuns: `outer`, `inner`, `row`, `col`, nomes descritivos

## Declara√ß√£o Defer

A declara√ß√£o `defer` agenda c√≥digo para ser executado quando a fun√ß√£o atual retorna. Isso √© √∫til para opera√ß√µes de limpeza como fechar arquivos, liberar recursos ou desbloquear.

### Defer B√°sico

```hemlock
fn example() {
    print("in√≠cio");
    defer print("limpeza");  // Executa quando a fun√ß√£o retorna
    print("fim");
}

example();
// Sa√≠da:
// in√≠cio
// fim
// limpeza
```

**Comportamento chave:**
- Declara√ß√µes defer executam **ap√≥s** o corpo da fun√ß√£o completar
- Declara√ß√µes defer executam **antes** da fun√ß√£o retornar ao chamador
- Declara√ß√µes defer sempre executam mesmo se a fun√ß√£o lan√ßar uma exce√ß√£o

### M√∫ltiplos Defer (Ordem LIFO)

Quando usando m√∫ltiplas declara√ß√µes `defer`, elas executam em **ordem reversa** (√∫ltimo a entrar, primeiro a sair):

```hemlock
fn example() {
    defer print("primeiro");   // Executa por √∫ltimo
    defer print("segundo");    // Executa em segundo
    defer print("terceiro");   // Executa primeiro
    print("corpo");
}

example();
// Sa√≠da:
// corpo
// terceiro
// segundo
// primeiro
```

Esta ordem LIFO √© intencional - corresponde √† ordem natural de limpeza de recursos aninhados (fechar recursos internos antes dos externos).

### Defer com Return

Declara√ß√µes defer executam antes de `return` transferir controle:

```hemlock
fn get_value(): i32 {
    defer print("limpeza");
    print("antes do return");
    return 42;
}

let resultado = get_value();
print("resultado:", resultado);
// Sa√≠da:
// antes do return
// limpeza
// resultado: 42
```

### Defer com Exce√ß√µes

Declara√ß√µes defer executam mesmo se uma exce√ß√£o for lan√ßada:

```hemlock
fn arriscado() {
    defer print("limpeza 1");
    defer print("limpeza 2");
    print("antes do throw");
    throw "erro!";
    print("depois do throw");  // Nunca executa
}

try {
    arriscado();
} catch (e) {
    print("Capturado:", e);
}
// Sa√≠da:
// antes do throw
// limpeza 2
// limpeza 1
// Capturado: erro!
```

### Padr√£o de Limpeza de Recursos

O principal caso de uso para `defer` √© garantir que recursos sejam limpos:

```hemlock
fn process_file(filename: string) {
    let file = open(filename, "r");
    defer file.close();  // Sempre fecha, mesmo em erro

    let content = file.read();
    // ... processar conte√∫do ...

    // Arquivo fecha automaticamente quando a fun√ß√£o retorna
}
```

**Sem defer (propenso a erros):**
```hemlock
fn process_file_bad(filename: string) {
    let file = open(filename, "r");
    let content = file.read();
    // Se lan√ßar aqui, file.close() nunca √© chamado!
    process(content);
    file.close();
}
```

### Defer com Closures

Defer pode usar closures para capturar estado:

```hemlock
fn example() {
    let resource = acquire_resource();
    defer fn() {
        print("Liberando recurso");
        release(resource);
    }();  // Nota: express√£o de fun√ß√£o imediatamente invocada

    use_resource(resource);
}
```

### Quando Usar Defer

**Use defer para:**
- Fechar arquivos e conex√µes de rede
- Liberar mem√≥ria alocada
- Liberar locks e mutexes
- Limpeza em qualquer fun√ß√£o que adquire recursos

**Defer vs Finally:**
- `defer` √© mais simples para limpeza de √∫nico recurso
- `try/finally` √© melhor para tratamento de erros complexo com recupera√ß√£o

### Melhores Pr√°ticas

1. **Use defer imediatamente ap√≥s adquirir o recurso:**
   ```hemlock
   let file = open("data.txt", "r");
   defer file.close();
   // ... usar arquivo ...
   ```

2. **Use m√∫ltiplos defer para m√∫ltiplos recursos:**
   ```hemlock
   let file1 = open("input.txt", "r");
   defer file1.close();

   let file2 = open("output.txt", "w");
   defer file2.close();

   // Ambos os arquivos fechar√£o em ordem reversa
   ```

3. **Lembre da ordem LIFO para recursos dependentes:**
   ```hemlock
   let outer = acquire_outer();
   defer release_outer(outer);

   let inner = acquire_inner(outer);
   defer release_inner(inner);

   // inner √© liberado antes de outer (ordem de depend√™ncia correta)
   ```

## Operadores Booleanos

### E L√≥gico (`&&`)

Ambas as condi√ß√µes devem ser verdadeiras:

```hemlock
if (x > 0 && x < 10) {
    print("d√≠gito √∫nico positivo");
}
```

**Avalia√ß√£o de curto-circuito:**
```hemlock
if (false && expensive_check()) {
    // expensive_check() nunca √© chamada
}
```

### OU L√≥gico (`||`)

Pelo menos uma condi√ß√£o deve ser verdadeira:

```hemlock
if (x < 0 || x > 100) {
    print("fora do intervalo");
}
```

**Avalia√ß√£o de curto-circuito:**
```hemlock
if (true || expensive_check()) {
    // expensive_check() nunca √© chamada
}
```

### NAO L√≥gico (`!`)

Nega valor booleano:

```hemlock
if (!is_valid) {
    print("inv√°lido");
}

if (!(x > 10)) {
    // Equivalente a: if (x <= 10)
}
```

## Operadores de Compara√ß√£o

### Igualdade

```hemlock
if (x == 10) { }    // Igual a
if (x != 10) { }    // Diferente de
```

Funciona com todos os tipos:
```hemlock
"hello" == "hello"  // true
true == false       // false
null == null        // true
```

### Operadores Relacionais

```hemlock
if (x < 10) { }     // Menor que
if (x > 10) { }     // Maior que
if (x <= 10) { }    // Menor ou igual
if (x >= 10) { }    // Maior ou igual
```

**Promo√ß√£o de tipo se aplica:**
```hemlock
let a: i32 = 10;
let b: i64 = 10;
if (a == b) { }     // true (i32 promovido para i64)
```

## Operadores Bit a Bit

Hemlock fornece operadores bit a bit para manipula√ß√£o de inteiros. Estes **s√≥ podem ser usados com tipos inteiros** (i8-i64, u8-u64).

### Operadores Bit a Bit Bin√°rios

**E bit a bit (`&`)**
```hemlock
let a = 12;  // Bin√°rio 1100
let b = 10;  // Bin√°rio 1010
print(a & b);   // 8 (1000)
```

**OU bit a bit (`|`)**
```hemlock
print(a | b);   // 14 (1110)
```

**XOR bit a bit (`^`)**
```hemlock
print(a ^ b);   // 6 (0110)
```

**Deslocamento √† esquerda (`<<`)**
```hemlock
print(a << 2);  // 48 (110000) - desloca 2 bits √† esquerda
```

**Deslocamento √† direita (`>>`)**
```hemlock
print(a >> 1);  // 6 (110) - desloca 1 bit √† direita
```

### Operador Bit a Bit Un√°rio

**Complemento bit a bit (`~`)**
```hemlock
let a = 12;
print(~a);      // -13 (complemento de dois)

let c: u8 = 15;   // Bin√°rio 00001111
print(~c);        // 240 (11110000), tipo u8
```

### Exemplos de Opera√ß√µes Bit a Bit

**Usando tipos sem sinal:**
```hemlock
let c: u8 = 15;   // Bin√°rio 00001111
let d: u8 = 7;    // Bin√°rio 00000111

print(c & d);     // 7  (00000111)
print(c | d);     // 15 (00001111)
print(c ^ d);     // 8  (00001000)
print(~c);        // 240 (11110000) - tipo u8
```

**Preserva√ß√£o de tipo:**
```hemlock
// Opera√ß√µes bit a bit preservam o tipo dos operandos
let x: u8 = 255;
let resultado = ~x;  // resultado √© u8, valor 0

let y: i32 = 100;
let resultado2 = y << 2;  // resultado2 √© i32, valor 400
```

**Padr√µes comuns:**
```hemlock
// Verificar se bit est√° definido
if (flags & 0x04) {
    print("bit 2 est√° definido");
}

// Definir bit
flags = flags | 0x08;

// Limpar bit
flags = flags & ~0x02;

// Alternar bit
flags = flags ^ 0x01;
```

### Preced√™ncia de Operadores

Operadores bit a bit seguem preced√™ncia estilo C:

1. `~` (nega√ß√£o un√°ria) - Mais alta, mesmo n√≠vel que `!` e `-`
2. `<<`, `>>` (deslocamento) - Acima de compara√ß√£o, abaixo de `+`/`-`
3. `&` (E bit a bit) - Acima de `^` e `|`
4. `^` (XOR bit a bit) - Entre `&` e `|`
5. `|` (OU bit a bit) - Abaixo de `&` e `^`, acima de `&&`
6. `&&`, `||` (l√≥gicos) - Preced√™ncia mais baixa

**Exemplos:**
```hemlock
// & tem preced√™ncia maior que |
let resultado1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12

// Deslocamento tem preced√™ncia maior que operadores bit a bit
let resultado2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12

// Use par√™nteses para clareza
let resultado3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5
```

**Notas importantes:**
- Operadores bit a bit s√≥ funcionam com tipos inteiros (n√£o float, string, etc.)
- Promo√ß√£o de tipo segue regras padr√£o (tipos menores promovidos para maiores)
- Deslocamento √† direita (`>>`) √© aritm√©tico para tipos com sinal, l√≥gico para sem sinal
- Quantidade de deslocamento n√£o √© verificada por intervalo (comportamento depende da plataforma)

## Preced√™ncia de Operadores (Completa)

Da maior para a menor preced√™ncia:

1. **Un√°rio**: `!`, `-`, `~`
2. **Multiplicativo**: `*`, `/`, `%`
3. **Aditivo**: `+`, `-`
4. **Deslocamento**: `<<`, `>>`
5. **Relacional**: `<`, `>`, `<=`, `>=`
6. **Igualdade**: `==`, `!=`
7. **E bit a bit**: `&`
8. **XOR bit a bit**: `^`
9. **OU bit a bit**: `|`
10. **E l√≥gico**: `&&`
11. **OU l√≥gico**: `||`

**Use par√™nteses para clareza:**
```hemlock
// N√£o claro
if (a || b && c) { }

// Claro
if (a || (b && c)) { }
if ((a || b) && c) { }
```

## Padr√µes Comuns

### Padr√£o: Valida√ß√£o de Entrada

```hemlock
fn validate_age(idade: i32): bool {
    if (idade < 0 || idade > 150) {
        return false;
    }
    return true;
}
```

### Padr√£o: Verifica√ß√£o de Intervalo

```hemlock
fn in_range(valor: i32, min: i32, max: i32): bool {
    return valor >= min && valor <= max;
}

if (in_range(pontuacao, 0, 100)) {
    print("pontua√ß√£o v√°lida");
}
```

### Padr√£o: M√°quina de Estados

```hemlock
let estado = "inicio";

while (true) {
    switch (estado) {
        case "inicio":
            print("Iniciando...");
            estado = "executando";
            break;

        case "executando":
            if (should_pause) {
                estado = "pausado";
            } else if (should_stop) {
                estado = "parado";
            }
            break;

        case "pausado":
            if (should_resume) {
                estado = "executando";
            }
            break;

        case "parado":
            print("Parado");
            break;
    }

    if (estado == "parado") {
        break;
    }
}
```

### Padr√£o: Itera√ß√£o com Filtro

```hemlock
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Imprime apenas n√∫meros pares
for (let i = 0; i < arr.length; i = i + 1) {
    if (arr[i] % 2 != 0) {
        continue;  // Pula √≠mpares
    }
    print(arr[i]);
}
```

### Padr√£o: Sa√≠da Antecipada

```hemlock
fn find_first_negative(arr: array): i32 {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // Sa√≠da antecipada
        }
    }
    return -1;  // N√£o encontrado
}
```

## Melhores Pr√°ticas

1. **Sempre use chaves** - Mesmo para blocos de √∫nica declara√ß√£o (sintaxe for√ßa)
2. **Condi√ß√µes expl√≠citas** - Use `x == 0` em vez de `!x` para clareza
3. **Evite aninhamento profundo** - Extraia condi√ß√µes aninhadas para fun√ß√µes
4. **Use retorno antecipado** - Use cl√°usulas de guarda para reduzir aninhamento
5. **Decomponha condi√ß√µes complexas** - Divida em vari√°veis booleanas nomeadas
6. **Use default em switch** - Sempre inclua case default
7. **Comente fall-through** - Torne fall-through intencional expl√≠cito

## Armadilhas Comuns

### Armadilha: Atribui√ß√£o em Condi√ß√£o

```hemlock
// Isso n√£o √© permitido (n√£o pode atribuir em condi√ß√£o)
if (x = 10) { }  // Erro: erro de sintaxe

// Use compara√ß√£o em vez disso
if (x == 10) { }  // OK
```

### Armadilha: Break Faltando em Switch

```hemlock
// Fall-through acidental
switch (x) {
    case 1:
        print("um");
        // Break faltando - vai passar para o pr√≥ximo!
    case 2:
        print("dois");  // Executa para 1 e 2
        break;
}

// Corrigido: adicione break
switch (x) {
    case 1:
        print("um");
        break;  // Agora correto
    case 2:
        print("dois");
        break;
}
```

### Armadilha: Escopo de Vari√°vel de Loop

```hemlock
// i tem escopo limitado ao loop
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
print(i);  // Erro: i n√£o est√° definido aqui
```

## Exemplos

### Exemplo: FizzBuzz

```hemlock
for (let i = 1; i <= 100; i = i + 1) {
    if (i % 15 == 0) {
        print("FizzBuzz");
    } else if (i % 3 == 0) {
        print("Fizz");
    } else if (i % 5 == 0) {
        print("Buzz");
    } else {
        print(i);
    }
}
```

### Exemplo: Verifica√ß√£o de N√∫mero Primo

```hemlock
fn is_prime(n: i32): bool {
    if (n < 2) {
        return false;
    }

    let i = 2;
    while (i * i <= n) {
        if (n % i == 0) {
            return false;
        }
        i = i + 1;
    }

    return true;
}
```

### Exemplo: Sistema de Menu

```hemlock
fn menu() {
    while (true) {
        print("1. Iniciar");
        print("2. Configura√ß√µes");
        print("3. Sair");

        let escolha = get_input();

        switch (escolha) {
            case 1:
                start_game();
                break;
            case 2:
                show_settings();
                break;
            case 3:
                print("At√© logo!");
                return;
            default:
                print("Escolha inv√°lida");
                break;
        }
    }
}
```

## T√≥picos Relacionados

- [Fun√ß√µes](#language-guide-functions) - Fluxo de controle de chamadas e retornos de fun√ß√£o
- [Tratamento de Erros](#language-guide-error-handling) - Fluxo de controle de exce√ß√µes
- [Tipos](#language-guide-types) - Convers√£o de tipos em condi√ß√µes

## Veja Tamb√©m

- **Sintaxe**: Veja [Sintaxe](#language-guide-syntax) para detalhes de sintaxe de declara√ß√µes
- **Operadores**: Veja [Tipos](#language-guide-types) para promo√ß√£o de tipos em opera√ß√µes


--------------------------------------------------------------------------------
## Fun√ß√µes
--------------------------------------------------------------------------------

# Fun√ß√µes

Em Hemlock, fun√ß√µes s√£o **cidad√£os de primeira classe**, podendo ser atribu√≠das a vari√°veis, passadas como argumentos e retornadas de outras fun√ß√µes. Este guia cobre sintaxe de fun√ß√µes, closures, recurs√£o e padr√µes avan√ßados.

## Vis√£o Geral

```hemlock
// Sintaxe de fun√ß√£o nomeada
fn add(a: i32, b: i32): i32 {
    return a + b;
}

// Fun√ß√£o an√¥nima
let multiply = fn(x, y) {
    return x * y;
};

// Closure
fn makeAdder(x) {
    return fn(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
print(add5(3));  // 8
```

## Declara√ß√£o de Fun√ß√µes

### Fun√ß√µes Nomeadas

```hemlock
fn greet(name: string): string {
    return "Hello, " + name;
}

let msg = greet("Alice");  // "Hello, Alice"
```

**Componentes:**
- `fn` - palavra-chave de fun√ß√£o
- `greet` - nome da fun√ß√£o
- `(name: string)` - par√¢metros com tipos opcionais
- `: string` - tipo de retorno opcional
- `{ ... }` - corpo da fun√ß√£o

### Fun√ß√µes An√¥nimas

Fun√ß√µes sem nome, atribu√≠das a vari√°veis:

```hemlock
let square = fn(x) {
    return x * x;
};

print(square(5));  // 25
```

**Fun√ß√£o nomeada vs an√¥nima:**
```hemlock
// Estas duas formas s√£o equivalentes:
fn add(a, b) { return a + b; }

let add = fn(a, b) { return a + b; };
```

**Nota:** Fun√ß√µes nomeadas s√£o desa√ßucarizadas para atribui√ß√£o de vari√°vel com fun√ß√£o an√¥nima.

## Par√¢metros

### Par√¢metros B√°sicos

```hemlock
fn example(a, b, c) {
    return a + b + c;
}

let result = example(1, 2, 3);  // 6
```

### Anota√ß√µes de Tipo

Anota√ß√µes de tipo opcionais para par√¢metros:

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 10);      // OK
add(5, 10.5);    // Verifica√ß√£o de tipo em execu√ß√£o promove para f64
```

**Verifica√ß√£o de tipo:**
- Se anotado, tipos de par√¢metros s√£o verificados na chamada
- Convers√µes impl√≠citas seguem regras de promo√ß√£o padr√£o
- Incompatibilidade de tipo causa erro em tempo de execu√ß√£o

### Passagem por Valor

Todos os par√¢metros s√£o **copiados** (passagem por valor):

```hemlock
fn modify(x) {
    x = 100;  // Modifica apenas a c√≥pia local
}

let a = 10;
modify(a);
print(a);  // Ainda √© 10 (n√£o alterado)
```

**Nota:** Objetos e arrays s√£o passados por refer√™ncia (a refer√™ncia √© copiada), ent√£o seu conte√∫do pode ser modificado:

```hemlock
fn modify_array(arr) {
    arr[0] = 99;  // Modifica o array original
}

let a = [1, 2, 3];
modify_array(a);
print(a[0]);  // 99 (modificado)
```

## Valores de Retorno

### Instru√ß√£o Return

```hemlock
fn get_max(a: i32, b: i32): i32 {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}
```

### Anota√ß√£o de Tipo de Retorno

Anota√ß√£o de tipo opcional para valor de retorno:

```hemlock
fn calculate(): f64 {
    return 3.14159;
}

fn get_name(): string {
    return "Alice";
}
```

**Verifica√ß√£o de tipo:**
- Se anotado, tipo de retorno √© verificado quando a fun√ß√£o retorna
- Convers√µes de tipo seguem regras de promo√ß√£o padr√£o

### Retorno Impl√≠cito

Fun√ß√µes sem anota√ß√£o de tipo de retorno implicitamente retornam `null`:

```hemlock
fn print_message(msg) {
    print(msg);
    // Retorna null implicitamente
}

let result = print_message("hello");  // result √© null
```

### Retorno Antecipado

```hemlock
fn find_first_negative(arr) {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // Sa√≠da antecipada
        }
    }
    return -1;  // N√£o encontrado
}
```

### Retorno sem Valor

`return;` sem valor retorna `null`:

```hemlock
fn maybe_process(value) {
    if (value < 0) {
        return;  // Retorna null
    }
    return value * 2;
}
```

## Fun√ß√µes de Primeira Classe

Fun√ß√µes podem ser atribu√≠das, passadas e retornadas como qualquer outro valor.

### Fun√ß√µes como Vari√°veis

```hemlock
let operation = fn(x, y) { return x + y; };

print(operation(5, 3));  // 8

// Reatribuir
operation = fn(x, y) { return x * y; };
print(operation(5, 3));  // 15
```

### Fun√ß√µes como Argumentos

```hemlock
fn apply(f, x) {
    return f(x);
}

fn double(n) {
    return n * 2;
}

let result = apply(double, 5);  // 10
```

### Fun√ß√µes como Valores de Retorno

```hemlock
fn get_operation(op: string) {
    if (op == "add") {
        return fn(a, b) { return a + b; };
    } else if (op == "multiply") {
        return fn(a, b) { return a * b; };
    } else {
        return fn(a, b) { return 0; };
    }
}

let add = get_operation("add");
print(add(5, 3));  // 8
```

## Closures

Fun√ß√µes capturam seu ambiente de defini√ß√£o (escopo l√©xico).

### Closure B√°sico

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
print(counter());  // 3
```

**Como funciona:**
- A fun√ß√£o interna captura `count` do escopo externo
- `count` persiste entre m√∫ltiplas chamadas da fun√ß√£o retornada
- Cada chamada a `makeCounter()` cria um novo closure com seu pr√≥prio `count`

### Closure com Par√¢metros

```hemlock
fn makeAdder(x) {
    return fn(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
let add10 = makeAdder(10);

print(add5(3));   // 8
print(add10(3));  // 13
```

### M√∫ltiplos Closures

```hemlock
fn makeOperations(x) {
    let add = fn(y) { return x + y; };
    let multiply = fn(y) { return x * y; };

    return { add: add, multiply: multiply };
}

let ops = makeOperations(5);
print(ops.add(3));       // 8
print(ops.multiply(3));  // 15
```

### Escopo L√©xico

Fun√ß√µes podem acessar vari√°veis de escopos externos atrav√©s de escopo l√©xico:

```hemlock
let global = 10;

fn outer() {
    let outer_var = 20;

    fn inner() {
        // Pode ler global e outer_var
        print(global);      // 10
        print(outer_var);   // 20
    }

    inner();
}

outer();
```

Closures capturam vari√°veis por refer√™ncia, permitindo leitura e modifica√ß√£o de vari√°veis de escopo externo (como mostrado no exemplo `makeCounter` acima).

## Recurs√£o

Fun√ß√µes podem chamar a si mesmas.

### Recurs√£o B√°sica

```hemlock
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

print(factorial(5));  // 120
```

### Recurs√£o M√∫tua

Fun√ß√µes podem chamar umas √†s outras:

```hemlock
fn is_even(n: i32): bool {
    if (n == 0) {
        return true;
    }
    return is_odd(n - 1);
}

fn is_odd(n: i32): bool {
    if (n == 0) {
        return false;
    }
    return is_even(n - 1);
}

print(is_even(4));  // true
print(is_odd(4));   // false
```

### Processamento de Dados Recursivo

```hemlock
fn sum_array(arr: array, index: i32): i32 {
    if (index >= arr.length) {
        return 0;
    }
    return arr[index] + sum_array(arr, index + 1);
}

let numbers = [1, 2, 3, 4, 5];
print(sum_array(numbers, 0));  // 15
```

**Nota:** N√£o h√° otimiza√ß√£o de chamada de cauda ainda - recurs√£o profunda pode causar estouro de pilha.

## Fun√ß√µes de Ordem Superior

Fun√ß√µes que aceitam ou retornam outras fun√ß√µes.

### Padr√£o Map

```hemlock
fn map(arr, f) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        result.push(f(arr[i]));
        i = i + 1;
    }
    return result;
}

fn double(x) { return x * 2; }

let numbers = [1, 2, 3, 4, 5];
let doubled = map(numbers, double);  // [2, 4, 6, 8, 10]
```

### Padr√£o Filter

```hemlock
fn filter(arr, predicate) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        if (predicate(arr[i])) {
            result.push(arr[i]);
        }
        i = i + 1;
    }
    return result;
}

fn is_even(x) { return x % 2 == 0; }

let numbers = [1, 2, 3, 4, 5, 6];
let evens = filter(numbers, is_even);  // [2, 4, 6]
```

### Padr√£o Reduce

```hemlock
fn reduce(arr, f, initial) {
    let accumulator = initial;
    let i = 0;
    while (i < arr.length) {
        accumulator = f(accumulator, arr[i]);
        i = i + 1;
    }
    return accumulator;
}

fn add(a, b) { return a + b; }

let numbers = [1, 2, 3, 4, 5];
let sum = reduce(numbers, add, 0);  // 15
```

### Composi√ß√£o de Fun√ß√µes

```hemlock
fn compose(f, g) {
    return fn(x) {
        return f(g(x));
    };
}

fn double(x) { return x * 2; }
fn increment(x) { return x + 1; }

let double_then_increment = compose(increment, double);
print(double_then_increment(5));  // 11 (5*2 + 1)
```

## Padr√µes Comuns

### Padr√£o: Fun√ß√£o de F√°brica

```hemlock
fn createPerson(name: string, age: i32) {
    return {
        name: name,
        age: age,
        greet: fn() {
            return "Hi, I'm " + self.name;
        }
    };
}

let person = createPerson("Alice", 30);
print(person.greet());  // "Hi, I'm Alice"
```

### Padr√£o: Fun√ß√£o de Callback

```hemlock
fn process_async(data, callback) {
    // ... processar
    callback(data);
}

process_async("test", fn(result) {
    print("Processing complete: " + result);
});
```

### Padr√£o: Aplica√ß√£o Parcial

```hemlock
fn partial(f, x) {
    return fn(y) {
        return f(x, y);
    };
}

fn multiply(a, b) {
    return a * b;
}

let double = partial(multiply, 2);
let triple = partial(multiply, 3);

print(double(5));  // 10
print(triple(5));  // 15
```

### Padr√£o: Memoiza√ß√£o

```hemlock
fn memoize(f) {
    let cache = {};

    return fn(x) {
        if (cache.has(x)) {
            return cache[x];
        }

        let result = f(x);
        cache[x] = result;
        return result;
    };
}

fn expensive_fibonacci(n) {
    if (n <= 1) { return n; }
    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);
}

let fast_fib = memoize(expensive_fibonacci);
print(fast_fib(10));  // Muito mais r√°pido com cache
```

## Sem√¢ntica de Fun√ß√µes

### Requisito de Tipo de Retorno

Fun√ß√µes com anota√ß√£o de tipo de retorno **devem** retornar um valor:

```hemlock
fn get_value(): i32 {
    // Erro: falta instru√ß√£o return
}

fn get_value(): i32 {
    return 42;  // OK
}
```

### Verifica√ß√£o de Tipo

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 10);        // OK
add(5.5, 10.5);    // Promove para f64, retorna f64
add("a", "b");     // Erro em tempo de execu√ß√£o: incompatibilidade de tipo
```

### Regras de Escopo

```hemlock
let global = "global";

fn outer() {
    let outer_var = "outer";

    fn inner() {
        let inner_var = "inner";
        // Pode acessar: inner_var, outer_var, global
    }

    // Pode acessar: outer_var, global
    // N√£o pode acessar: inner_var
}

// Pode acessar: global
// N√£o pode acessar: outer_var, inner_var
```

## Melhores Pr√°ticas

1. **Use anota√ß√µes de tipo** - Ajuda a detectar erros e documentar inten√ß√£o
2. **Mantenha fun√ß√µes pequenas** - Cada fun√ß√£o deve fazer apenas uma coisa
3. **Prefira fun√ß√µes puras** - Evite efeitos colaterais quando poss√≠vel
4. **Nomeie claramente** - Use nomes de verbos descritivos
5. **Retorno antecipado** - Use cl√°usulas de guarda para reduzir aninhamento
6. **Documente closures complexos** - Deixe claro quais vari√°veis s√£o capturadas
7. **Evite recurs√£o profunda** - Sem otimiza√ß√£o de chamada de cauda ainda

## Armadilhas Comuns

### Armadilha: Profundidade de Recurs√£o

```hemlock
// Recurs√£o profunda pode causar estouro de pilha
fn count_down(n) {
    if (n == 0) { return; }
    count_down(n - 1);
}

count_down(100000);  // Pode falhar com estouro de pilha
```

### Armadilha: Modifica√ß√£o de Vari√°veis Capturadas

```hemlock
fn make_counter() {
    let count = 0;
    return fn() {
        count = count + 1;  // Pode ler e modificar vari√°veis capturadas
        return count;
    };
}
```

**Nota:** Isso funciona, mas esteja ciente de que todos os closures compartilham o mesmo ambiente capturado.

## Exemplos

### Exemplo: Pipeline de Fun√ß√µes

```hemlock
fn pipeline(value, ...functions) {
    let result = value;
    for (f in functions) {
        result = f(result);
    }
    return result;
}

fn double(x) { return x * 2; }
fn increment(x) { return x + 1; }
fn square(x) { return x * x; }

let result = pipeline(3, double, increment, square);
print(result);  // 49 ((3*2+1)^2)
```

### Exemplo: Manipulador de Eventos

```hemlock
let handlers = [];

fn on_event(name: string, handler) {
    handlers.push({ name: name, handler: handler });
}

fn trigger_event(name: string, data) {
    let i = 0;
    while (i < handlers.length) {
        if (handlers[i].name == name) {
            handlers[i].handler(data);
        }
        i = i + 1;
    }
}

on_event("click", fn(data) {
    print("Clicked: " + data);
});

trigger_event("click", "button1");
```

### Exemplo: Ordena√ß√£o com Comparador Personalizado

```hemlock
fn sort(arr, compare) {
    // Bubble sort com comparador personalizado
    let n = arr.length;
    let i = 0;
    while (i < n) {
        let j = 0;
        while (j < n - i - 1) {
            if (compare(arr[j], arr[j + 1]) > 0) {
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

fn ascending(a, b) {
    if (a < b) { return -1; }
    if (a > b) { return 1; }
    return 0;
}

let numbers = [5, 2, 8, 1, 9];
sort(numbers, ascending);
print(numbers);  // [1, 2, 5, 8, 9]
```

## Par√¢metros Opcionais (Par√¢metros Padr√£o)

Fun√ß√µes podem definir par√¢metros opcionais com valores padr√£o usando a sintaxe `?:`:

```hemlock
fn greet(name, greeting?: "Hello") {
    return greeting + " " + name;
}

print(greet("Alice"));           // "Hello Alice"
print(greet("Bob", "Hi"));       // "Hi Bob"

fn add(a, b?: 10, c?: 100) {
    return a + b + c;
}

print(add(1));          // 111 (1 + 10 + 100)
print(add(1, 2));       // 103 (1 + 2 + 100)
print(add(1, 2, 3));    // 6   (1 + 2 + 3)
```

**Regras:**
- Par√¢metros opcionais devem vir ap√≥s par√¢metros obrigat√≥rios
- Valores padr√£o podem ser qualquer express√£o
- Par√¢metros omitidos usam valores padr√£o

## Fun√ß√µes Vari√°dicas (Par√¢metros Rest)

Fun√ß√µes podem aceitar n√∫mero vari√°vel de argumentos usando par√¢metros rest (`...`):

```hemlock
fn sum(...args) {
    let total = 0;
    for (arg in args) {
        total = total + arg;
    }
    return total;
}

print(sum(1, 2, 3));        // 6
print(sum(1, 2, 3, 4, 5));  // 15
print(sum());               // 0

fn log(prefix, ...messages) {
    for (msg in messages) {
        print(prefix + ": " + msg);
    }
}

log("INFO", "Starting", "Running", "Done");
// INFO: Starting
// INFO: Running
// INFO: Done
```

**Regras:**
- Par√¢metro rest deve ser o √∫ltimo par√¢metro
- Par√¢metro rest coleta todos os argumentos restantes em um array
- Pode ser combinado com par√¢metros normais e opcionais

## Anota√ß√µes de Tipo de Fun√ß√£o

Tipos de fun√ß√£o permitem especificar assinaturas precisas para par√¢metros e valores de retorno:

### Tipo de Fun√ß√£o B√°sico

```hemlock
// Sintaxe de tipo de fun√ß√£o: fn(param_types): return_type
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

let double = fn(n) { return n * 2; };
let result = apply(double, 5);  // 10
```

### Tipos de Fun√ß√£o de Ordem Superior

```hemlock
// Fun√ß√£o que retorna fun√ß√£o
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

let add5 = make_adder(5);
print(add5(10));  // 15
```

### Tipos de Fun√ß√£o Ass√≠ncrona

```hemlock
// Tipo de fun√ß√£o ass√≠ncrona
fn run_task(handler: async fn(): void) {
    spawn(handler);
}

run_task(async fn() {
    print("Running async!");
});
```

### Aliases de Tipo de Fun√ß√£o

```hemlock
// Criar tipos de fun√ß√£o nomeados para clareza
type Callback = fn(i32): void;
type Predicate = fn(any): bool;
type BinaryOp = fn(i32, i32): i32;

fn filter_with(arr: array, pred: Predicate): array {
    return arr.filter(pred);
}
```

## Par√¢metros Const

O modificador `const` impede modifica√ß√£o de par√¢metros dentro da fun√ß√£o:

### Par√¢metro Const B√°sico

```hemlock
fn print_all(const items: array) {
    // items.push(4);  // Erro: n√£o pode modificar par√¢metro const
    for (item in items) {
        print(item);   // OK: leitura permitida
    }
}

let nums = [1, 2, 3];
print_all(nums);
```

### Imutabilidade Profunda

Par√¢metros const for√ßam imutabilidade profunda - n√£o pode modificar atrav√©s de nenhum caminho:

```hemlock
fn describe(const person: object) {
    print(person.name);       // OK: leitura permitida
    // person.name = "Bob";   // Erro: n√£o pode modificar
    // person.address.city = "NYC";  // Erro: const profundo
}
```

### Opera√ß√µes Bloqueadas por Const

| Tipo | Bloqueado por Const | Permitido |
|------|--------------|-------|
| array | push, pop, shift, unshift, insert, remove, clear, reverse | slice, concat, map, filter, find, contains |
| object | atribui√ß√£o de campo | leitura de campo |
| buffer | atribui√ß√£o de √≠ndice | leitura de √≠ndice |
| string | atribui√ß√£o de √≠ndice | todos os m√©todos (retornam novas strings) |

## Par√¢metros Nomeados

Fun√ß√µes podem ser chamadas com par√¢metros nomeados para maior clareza e flexibilidade:

### Par√¢metros Nomeados B√°sicos

```hemlock
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " is " + age + " years old");
}

// Argumentos posicionais (tradicional)
create_user("Alice", 25, false);

// Argumentos nomeados - podem estar em qualquer ordem
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);
```

### Misturando Argumentos Posicionais e Nomeados

```hemlock
// Pular par√¢metros opcionais nomeando
create_user("David", active: false);  // Usa age=18 padr√£o

// Argumentos nomeados devem vir ap√≥s posicionais
create_user("Eve", age: 21);          // OK
// create_user(name: "Bad", 25);      // Erro: argumento posicional ap√≥s nomeado
```

### Regras de Par√¢metros Nomeados

- Use sintaxe `name: value` para argumentos nomeados
- Argumentos nomeados podem aparecer em qualquer ordem ap√≥s argumentos posicionais
- Argumentos posicionais n√£o podem seguir argumentos nomeados
- Funciona com par√¢metros padr√£o/opcionais
- Nomes de par√¢metro desconhecidos causam erro em tempo de execu√ß√£o

## Limita√ß√µes

Limita√ß√µes atuais a observar:

- **Sem passagem por refer√™ncia** - Palavra-chave `ref` √© analisada mas n√£o implementada
- **Sem sobrecarga de fun√ß√£o** - Apenas uma fun√ß√£o por nome
- **Sem otimiza√ß√£o de chamada de cauda** - Recurs√£o profunda limitada pelo tamanho da pilha

## T√≥picos Relacionados

- [Fluxo de Controle](#language-guide-control-flow) - Fun√ß√µes trabalham com estruturas de controle
- [Objetos](#language-guide-objects) - M√©todos s√£o fun√ß√µes armazenadas em objetos
- [Tratamento de Erros](#language-guide-error-handling) - Fun√ß√µes e tratamento de exce√ß√µes
- [Tipos](#language-guide-types) - Anota√ß√µes de tipo e convers√µes

## Veja Tamb√©m

- **Closures**: Veja a se√ß√£o "Functions" em CLAUDE.md para sem√¢ntica de closures
- **Primeira classe**: Fun√ß√µes s√£o valores como qualquer outro
- **Escopo l√©xico**: Fun√ß√µes capturam seu ambiente de defini√ß√£o


--------------------------------------------------------------------------------
## Gerenciamento de Mem√≥ria
--------------------------------------------------------------------------------

# Gerenciamento de Memoria

Hemlock adota **gerenciamento manual de memoria**, com controle explicito sobre alocacao e liberacao. Este guia abrange o modelo de memoria do Hemlock, os dois tipos de ponteiros e a API completa de memoria.

---

## Fundamentos de Memoria 101

**Novo em programacao?** Comece aqui. Se voce ja entende gerenciamento de memoria, pode pular para [Filosofia de Design](#filosofia-de-design).

### O que e Gerenciamento de Memoria?

Quando seu programa precisa armazenar dados (texto, numeros, listas), ele precisa de espaco para colocar esses dados. Este espaco vem da memoria do computador (RAM). Gerenciamento de memoria envolve:

1. **Obter espaco** - Solicitar memoria quando necessario
2. **Usar espaco** - Ler e escrever dados
3. **Devolver espaco** - Retornar memoria quando terminar

### Por que Isso Importa?

Imagine uma biblioteca com livros limitados:
- Se voce continua emprestando livros e nunca devolve, eventualmente nao havera livros disponiveis
- Se voce tentar ler um livro que ja devolveu, havera confusao ou problemas

Memoria funciona da mesma forma. Se voce esquecer de devolver memoria, seu programa usara cada vez mais memoria ("vazamento de memoria"). Se voce tentar usar memoria apos devolve-la, coisas ruins acontecerao.

### A Boa Noticia

**Na maior parte do tempo, voce nao precisa pensar nisso!**

Hemlock limpa automaticamente a maioria dos tipos comuns:

```hemlock
fn example() {
    let nome = "Alice";       // Hemlock gerencia isso
    let numeros = [1, 2, 3];  // E isso tambem
    let pessoa = { age: 30 }; // E isso tambem

    // Quando a funcao termina, tudo e limpo automaticamente!
}
```

### Quando Voce Precisa Pensar Nisso

Voce so precisa de gerenciamento manual de memoria ao usar:

1. **`alloc()`** - Alocacao de memoria bruta (retorna `ptr`)
2. **`buffer()`** - Quando voce quer liberar antecipadamente (opcional - libera automaticamente no fim do escopo)

```hemlock
// Isso requer limpeza manual:
let raw = alloc(100);   // Memoria bruta - voce deve liberar
// ... usar raw ...
free(raw);              // Obrigatorio! Caso contrario, vazamento de memoria

// Isso limpa automaticamente (mas voce pode liberar antes):
let buf = buffer(100);  // Buffer seguro
// ... usar buf ...
// free(buf);           // Opcional - libera automaticamente no fim do escopo
```

### Regra Simples

> **Se voce chamar `alloc()`, voce deve chamar `free()`.**
>
> Todo o resto e tratado para voce.

### Qual Devo Usar?

| Cenario | Use Isso | Por Que |
|---------|----------|---------|
| **Comecando a aprender** | `buffer()` | Seguro, com verificacao de limites, limpeza automatica |
| **Precisa de armazenamento de bytes** | `buffer()` | Seguro e simples |
| **Interagindo com bibliotecas C (FFI)** | `alloc()` / `ptr` | Necessario para interoperabilidade C |
| **Performance maxima** | `alloc()` / `ptr` | Sem overhead de verificacao de limites |
| **Nao tem certeza** | `buffer()` | Sempre a escolha mais segura |

### Exemplo Rapido: Seguro vs Bruto

```hemlock
// Recomendado: buffer seguro
fn exemplo_seguro() {
    let data = buffer(10);
    data[0] = 65;           // OK
    data[5] = 66;           // OK
    // data[100] = 67;      // Erro - Hemlock impede (verificacao de limites)
    free(data);             // Limpeza
}

// Avancado: ponteiro bruto (use apenas quando necessario)
fn exemplo_bruto() {
    let data = alloc(10);
    *data = 65;             // OK
    *(data + 5) = 66;       // OK
    *(data + 100) = 67;     // Perigoso - sem verificacao de limites, corrompe memoria!
    free(data);             // Limpeza
}
```

**Comece com `buffer()`. So use `alloc()` quando precisar especificamente de ponteiros brutos.**

---

## Filosofia de Design

Hemlock segue gerenciamento explicito de memoria com padroes sensiveis:
- Sem coleta de lixo (sem pausas imprevisiveis)
- Contagem de referencias interna para tipos comuns (string, array, object, buffer)
- Ponteiros brutos (`ptr`) requerem `free()` manual

Esta abordagem hibrida oferece controle total quando necessario (ponteiros brutos), enquanto previne erros comuns em casos de uso tipicos (tipos com contagem de referencias liberam automaticamente ao sair do escopo).

## Contagem de Referencias Interna

O runtime usa **contagem de referencias interna** para gerenciar ciclos de vida de objetos. Para a maioria das variaveis locais de tipos com contagem de referencias, a limpeza e automatica e deterministica.

### O que a Contagem de Referencias Trata

O runtime gerencia automaticamente contagem de referencias quando:

1. **Reatribuicao de variavel** - Valor antigo e liberado:
   ```hemlock
   let x = "primeiro";   // ref_count = 1
   x = "segundo";        // "primeiro" liberado internamente, "segundo" ref_count = 1
   ```

2. **Saida de escopo** - Variaveis locais sao liberadas:
   ```hemlock
   fn example() {
       let arr = [1, 2, 3];  // ref_count = 1
   }  // arr liberado quando funcao retorna
   ```

3. **Container liberado** - Elementos sao liberados:
   ```hemlock
   let arr = [obj1, obj2];
   free(arr);  // ref_count de obj1 e obj2 decrementado
   ```

### Quando `free()` e Necessario vs Automatico

**Automatico (nao precisa de `free()`):** Variaveis locais de tipos com contagem de referencias sao liberadas ao sair do escopo:

```hemlock
fn process_data() {
    let arr = [1, 2, 3];
    let obj = { name: "test" };
    let buf = buffer(64);
    // ... usar eles ...
}  // Todos liberados automaticamente quando funcao retorna - nao precisa de free()
```

**Requer `free()` manual:**

1. **Ponteiros brutos** - `alloc()` nao tem contagem de referencias:
   ```hemlock
   let p = alloc(64);
   // ... usar p ...
   free(p);  // Sempre necessario - caso contrario vaza
   ```

2. **Limpeza antecipada** - Libera antes do fim do escopo para liberar memoria mais cedo:
   ```hemlock
   fn long_running() {
       let big = buffer(10000000);  // 10MB
       // ... terminou com big ...
       free(big);  // Libera agora, nao espera funcao retornar
       // ... mais trabalho que nao precisa de big ...
   }
   ```

3. **Dados de longa duracao** - Dados globais ou armazenados em estruturas persistentes:
   ```hemlock
   let cache = {};  // Nivel de modulo, vive ate o programa terminar a menos que liberado

   fn cleanup() {
       free(cache);  // Limpeza manual para dados de longa duracao
   }
   ```

### Contagem de Referencias vs Coleta de Lixo

| Aspecto | Contagem de Referencias Hemlock | Coleta de Lixo |
|---------|--------------------------------|----------------|
| Quando limpa | Deterministico (imediatamente quando ref chega a 0) | Nao-deterministico (GC decide quando) |
| Responsabilidade do usuario | Deve chamar `free()` | Totalmente automatico |
| Pausas de runtime | Nenhuma | Pausas "stop-the-world" |
| Visibilidade | Detalhe de implementacao oculto | Geralmente invisivel |
| Referencias circulares | Tratadas via rastreamento de conjunto visitado | Tratadas via rastreamento |

### Quais Tipos Tem Contagem de Referencias

| Tipo | Contagem de Referencias | Notas |
|------|------------------------|-------|
| `ptr` | Nao | Sempre requer `free()` manual |
| `buffer` | Sim | Liberado automaticamente ao sair do escopo; `free()` manual para limpeza antecipada |
| `array` | Sim | Liberado automaticamente ao sair do escopo; `free()` manual para limpeza antecipada |
| `object` | Sim | Liberado automaticamente ao sair do escopo; `free()` manual para limpeza antecipada |
| `string` | Sim | Totalmente automatico, nao precisa de `free()` |
| `function` | Sim | Totalmente automatico (ambiente de closure) |
| `task` | Sim | Contagem de referencias atomica thread-safe |
| `channel` | Sim | Contagem de referencias atomica thread-safe |
| Primitivos | Nao | Alocados na stack, sem alocacao heap |

### Por Que Este Design?

Esta abordagem hibrida oferece:
- **Controle explicito** - Voce decide quando liberar
- **Seguranca de escopo** - Reatribuicao nao vaza
- **Performance previsivel** - Sem pausas de GC
- **Suporte a closures** - Funcoes podem capturar variaveis com seguranca

A filosofia permanece: voce esta no controle, mas o runtime ajuda a prevenir erros comuns como vazamentos em reatribuicao ou double-free em containers.

## Dois Tipos de Ponteiros

Hemlock fornece dois tipos distintos de ponteiros com diferentes caracteristicas de seguranca:

### `ptr` - Ponteiro Bruto (Perigoso)

Ponteiros brutos sao **apenas enderecos**, com garantias minimas de seguranca:

```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // Voce deve lembrar de liberar
```

**Caracteristicas:**
- Apenas um endereco de 8 bytes
- Sem verificacao de limites
- Sem rastreamento de tamanho
- Ciclo de vida totalmente gerenciado pelo usuario
- Adequado para especialistas e FFI

**Casos de uso:**
- Programacao de sistemas de baixo nivel
- Interface de Funcao Estrangeira (FFI)
- Codigo critico de performance
- Quando controle total e necessario

**Perigos:**
```hemlock
let p = alloc(10);
let q = p + 100;  // Muito alem da alocacao - permitido mas perigoso
free(p);
let x = *p;       // Ponteiro dangling - comportamento indefinido
free(p);          // Double free - vai crashar
```

### `buffer` - Wrapper Seguro (Recomendado)

Buffer fornece **acesso com verificacao de limites** enquanto ainda requer liberacao manual:

```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // Verificacao de limites
print(b.length);        // 64
free(b);                // Ainda e manual
```

**Caracteristicas:**
- Ponteiro + tamanho + capacidade
- Verificacao de limites no acesso
- Ainda requer `free()` manual
- Padrao melhor para a maioria do codigo

**Propriedades:**
```hemlock
let buf = buffer(100);
print(buf.length);      // 100 (tamanho atual)
print(buf.capacity);    // 100 (capacidade alocada)
```

**Verificacao de limites:**
```hemlock
let buf = buffer(10);
buf[5] = 42;      // OK
buf[100] = 42;    // Erro: indice fora dos limites
```

## API de Memoria

### Alocacao Principal

**`alloc(bytes)` - Aloca memoria bruta**
```hemlock
let p = alloc(1024);  // Aloca 1KB, retorna ptr
// ... usar memoria
free(p);
```

**`buffer(size)` - Aloca buffer seguro**
```hemlock
let buf = buffer(256);  // Aloca buffer de 256 bytes
buf[0] = 65;            // 'A'
buf[1] = 66;            // 'B'
free(buf);
```

**`free(ptr)` - Libera memoria**
```hemlock
let p = alloc(100);
free(p);  // Deve liberar para evitar vazamento de memoria

let buf = buffer(100);
free(buf);  // Funciona para ptr e buffer
```

**Importante:** `free()` funciona para tipos `ptr` e `buffer`.

### Operacoes de Memoria

**`memset(ptr, byte, size)` - Preenche memoria**
```hemlock
let p = alloc(100);
memset(p, 0, 100);     // Zera 100 bytes
memset(p, 65, 10);     // Preenche primeiros 10 bytes com 'A'
free(p);
```

**`memcpy(dest, src, size)` - Copia memoria**
```hemlock
let src = alloc(50);
let dst = alloc(50);
memset(src, 42, 50);
memcpy(dst, src, 50);  // Copia 50 bytes de src para dst
free(src);
free(dst);
```

**`realloc(ptr, size)` - Redimensiona alocacao**
```hemlock
let p = alloc(100);
// ... usar 100 bytes
p = realloc(p, 200);   // Redimensiona para 200 bytes
// ... usar 200 bytes
free(p);
```

**Nota:** Apos `realloc()`, o ponteiro antigo pode ser invalido. Sempre use o ponteiro retornado.

### Alocacao Tipada

Hemlock fornece helpers de alocacao tipada para conveniencia:

```hemlock
let arr = talloc(i32, 100);  // Aloca 100 valores i32 (400 bytes)
let size = sizeof(i32);      // Retorna 4 (bytes)
```

**`sizeof(type)`** retorna o tamanho em bytes de um tipo:
- `sizeof(i8)` / `sizeof(u8)` -> 1
- `sizeof(i16)` / `sizeof(u16)` -> 2
- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` -> 4
- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` -> 8
- `sizeof(ptr)` -> 8 (sistemas 64-bit)

**`talloc(type, count)`** aloca `count` elementos do `type`:

```hemlock
let ints = talloc(i32, 10);   // 40 bytes para 10 valores i32
let floats = talloc(f64, 5);  // 40 bytes para 5 valores f64
free(ints);
free(floats);
```

## Padroes Comuns

### Padrao: Alocar, Usar, Liberar

O padrao basico de gerenciamento de memoria:

```hemlock
// 1. Alocar
let data = alloc(1024);

// 2. Usar
memset(data, 0, 1024);
// ... fazer trabalho

// 3. Liberar
free(data);
```

### Padrao: Uso Seguro de Buffer

Prefira buffer para acesso com verificacao de limites:

```hemlock
let buf = buffer(256);

// Iteracao segura
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

free(buf);
```

### Padrao: Gerenciamento de Recursos com try/finally

Garante limpeza mesmo em erros:

```hemlock
let data = alloc(1024);
try {
    // ... operacoes arriscadas
    process(data);
} finally {
    free(data);  // Libera mesmo em erro
}
```

## Consideracoes de Seguranca de Memoria

### Double Free

**Permitido mas vai crashar:**
```hemlock
let p = alloc(100);
free(p);
free(p);  // Crash: double free detectado
```

**Prevencao:**
```hemlock
let p = alloc(100);
free(p);
p = null;  // Define como null apos liberar

if (p != null) {
    free(p);  // Nao vai executar
}
```

### Ponteiro Dangling

**Permitido mas comportamento indefinido:**
```hemlock
let p = alloc(100);
*p = 42;      // OK
free(p);
let x = *p;   // Indefinido: lendo memoria liberada
```

**Prevencao:** Nao acesse memoria apos liberar.

### Vazamento de Memoria

**Facil de criar, dificil de debugar:**
```hemlock
fn leak_memory() {
    let p = alloc(1000);
    // Esqueceu de liberar!
    return;  // Vazamento de memoria
}
```

**Prevencao:** Sempre pareie `alloc()` com `free()`:
```hemlock
fn safe_function() {
    let p = alloc(1000);
    try {
        // ... usar p
    } finally {
        free(p);  // Sempre libera
    }
}
```

### Aritmetica de Ponteiros

**Permitida mas perigosa:**
```hemlock
let p = alloc(10);
let q = p + 100;  // Muito alem dos limites da alocacao
*q = 42;          // Indefinido: escrita fora dos limites
free(p);
```

**Use buffer para verificacao de limites:**
```hemlock
let buf = buffer(10);
buf[100] = 42;  // Erro: verificacao de limites previne overflow
```

## Melhores Praticas

1. **Use `buffer` por padrao** - Use `buffer` a menos que precise especificamente de `ptr` bruto
2. **Pareie alloc/free** - Cada `alloc()` deve ter exatamente um `free()`
3. **Use try/finally** - Use tratamento de excecoes para garantir limpeza
4. **Null apos free** - Defina ponteiros como `null` apos liberar para capturar uso-apos-liberar
5. **Verificacao de limites** - Use indexacao de buffer para verificacao automatica de limites
6. **Documente propriedade** - Deixe claro qual codigo possui e libera cada alocacao

## Exemplos

### Exemplo: Construtor de String Dinamico

```hemlock
fn build_message(count: i32): ptr {
    let size = count * 10;
    let buf = alloc(size);

    let i = 0;
    while (i < count) {
        memset(buf + (i * 10), 65 + i, 10);
        i = i + 1;
    }

    return buf;  // Chamador deve liberar
}

let msg = build_message(5);
// ... usar msg
free(msg);
```

### Exemplo: Operacoes Seguras de Array

```hemlock
fn process_array(size: i32) {
    let arr = buffer(size);

    try {
        // Preencher array
        let i = 0;
        while (i < arr.length) {
            arr[i] = i * 2;
            i = i + 1;
        }

        // Processar
        i = 0;
        while (i < arr.length) {
            print(arr[i]);
            i = i + 1;
        }
    } finally {
        free(arr);  // Sempre limpa
    }
}
```

### Exemplo: Padrao de Pool de Memoria

```hemlock
// Pool de memoria simples (simplificado)
let pool = alloc(10000);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > 10000) {
        throw "Pool esgotado";
    }

    let ptr = pool + pool_offset;
    pool_offset = pool_offset + size;
    return ptr;
}

// Usar pool
let p1 = pool_alloc(100);
let p2 = pool_alloc(200);

// Liberar pool inteiro de uma vez
free(pool);
```

## Limitacoes

Limitacoes atuais a serem observadas:

- **Ponteiros brutos requerem liberacao manual** - `alloc()` retorna `ptr` sem contagem de referencias
- **Sem alocadores customizados** - Apenas malloc/free do sistema

**Nota:** Tipos com contagem de referencias (string, array, object, buffer) liberam automaticamente ao sair do escopo. Apenas `ptr` bruto de `alloc()` requer `free()` explicito.

## Topicos Relacionados

- [Strings](#language-guide-strings) - Gerenciamento de memoria de strings e codificacao UTF-8
- [Arrays](#language-guide-arrays) - Arrays dinamicos e suas caracteristicas de memoria
- [Objetos](#language-guide-objects) - Alocacao e ciclo de vida de objetos
- [Tratamento de Erros](#language-guide-error-handling) - Limpeza com try/finally

## Veja Tambem

- **Filosofia de Design**: Veja secao "Memory Management" em CLAUDE.md
- **Sistema de Tipos**: Veja [Tipos](#language-guide-types) para detalhes dos tipos `ptr` e `buffer`
- **FFI**: Ponteiros brutos sao essenciais para Interface de Funcao Estrangeira


--------------------------------------------------------------------------------
## M√≥dulos
--------------------------------------------------------------------------------

# Sistema de M√≥dulos do Hemlock

Este documento descreve o sistema de m√≥dulos import/export no estilo ES6 implementado para Hemlock.

## Visao Geral

Hemlock suporta um sistema de m√≥dulos baseado em arquivos usando sintaxe de import/export no estilo ES6. M√≥dulos t√™m as seguintes caracter√≠sticas:
- **Singleton**: Cada m√≥dulo √© carregado apenas uma vez e armazenado em cache
- **Baseado em arquivo**: M√≥dulos correspondem a arquivos .hml no disco
- **Imports expl√≠citos**: Depend√™ncias s√£o declaradas atrav√©s de declara√ß√µes import
- **Execu√ß√£o topol√≥gica**: Depend√™ncias executam antes dos dependentes

Para gerenciamento de pacotes e depend√™ncias de terceiros, veja [hpm (Hemlock Package Manager)](https://github.com/hemlang/hpm).

## Sintaxe

### Declara√ß√µes Export

**Exports nomeados inline:**
```hemlock
export fn add(a, b) {
    return a + b;
}

export const PI = 3.14159;
export let contador = 0;
```

**Lista de exports:**
```hemlock
fn add(a, b) { return a + b; }
fn subtract(a, b) { return a - b; }

export { add, subtract };
```

**Exportando Extern (fun√ß√µes FFI):**
```hemlock
import "libc.so.6";

// Exporta fun√ß√µes FFI para uso de outros m√≥dulos
export extern fn strlen(s: string): i32;
export extern fn getpid(): i32;
```

Para mais detalhes sobre exportar fun√ß√µes FFI, veja a [documenta√ß√£o FFI](../advanced/ffi.md#exporting-ffi-functions).

**Exportando Define (tipos struct):**
```hemlock
// Exporta defini√ß√µes de tipo struct
export define Vector2 {
    x: f32,
    y: f32,
}

export define Rectangle {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
}
```

**Nota importante:** Tipos struct exportados s√£o registrados globalmente quando o m√≥dulo √© carregado. Eles ficam automaticamente dispon√≠veis quando voc√™ importa qualquer coisa do m√≥dulo - voc√™ n√£o precisa (e n√£o pode) import√°-los explicitamente por nome:

```hemlock
// Correto - tipos struct ficam dispon√≠veis automaticamente ap√≥s qualquer import
import { some_function } from "./my_module.hml";
let v: Vector2 = { x: 1.0, y: 2.0 };  // Funciona!

// Errado - n√£o pode importar tipos struct explicitamente
import { Vector2 } from "./my_module.hml";  // Erro: vari√°vel 'Vector2' indefinida
```

Para mais detalhes sobre exportar tipos struct, veja a [documenta√ß√£o FFI](../advanced/ffi.md#exporting-struct-types).

**Re-exports:**
```hemlock
// Re-exporta de outro m√≥dulo
export { add, subtract } from "./math.hml";
```

### Declara√ß√µes Import

**Imports nomeados:**
```hemlock
import { add, subtract } from "./math.hml";
print(add(1, 2));  // 3
```

**Import de namespace:**
```hemlock
import * as math from "./math.hml";
print(math.add(1, 2));  // 3
print(math.PI);  // 3.14159
```

**Aliases:**
```hemlock
import { add as soma, subtract as subtrair } from "./math.hml";
print(soma(1, 2));  // 3
```

## Resolu√ß√£o de M√≥dulos

### Tipos de Caminho

**Caminhos relativos:**
```hemlock
import { foo } from "./module.hml";       // Mesmo diret√≥rio
import { bar } from "../parent.hml";      // Diret√≥rio pai
import { baz } from "./sub/nested.hml";   // Subdiret√≥rio
```

**Caminhos absolutos:**
```hemlock
import { foo } from "/absolute/path/to/module.hml";
```

**Tratamento de extens√£o:**
- Extens√£o `.hml` pode ser omitida - ser√° adicionada automaticamente
- `./math` resolve para `./math.hml`

## Recursos

### Detec√ß√£o de Depend√™ncia Circular

O sistema de m√≥dulos detecta depend√™ncias circulares e reporta erros:

```
Error: Circular dependency detected when loading '/path/to/a.hml'
```

### Cache de M√≥dulos

M√≥dulos s√£o carregados apenas uma vez e armazenados em cache. M√∫ltiplos imports do mesmo m√≥dulo retornam a mesma inst√¢ncia:

```hemlock
// counter.hml
export let count = 0;
export fn increment() {
    count = count + 1;
}

// a.hml
import { count, increment } from "./counter.hml";
increment();
print(count);  // 1

// b.hml
import { count } from "./counter.hml";  // Mesma inst√¢ncia!
print(count);  // Ainda 1 (estado compartilhado)
```

### Imutabilidade de Imports

Bindings importados n√£o podem ser reatribu√≠dos:

```hemlock
import { add } from "./math.hml";
add = fn() { };  // Erro: n√£o pode reatribuir binding importado
```

## Detalhes de Implementa√ß√£o

### Arquitetura

**Arquivos:**
- `include/module.h` - API do sistema de m√≥dulos
- `src/module.c` - Carregamento, cache e execu√ß√£o de m√≥dulos
- Suporte de parser em `src/parser.c`
- Suporte de runtime em `src/interpreter/runtime.c`

**Componentes principais:**
1. **ModuleCache**: Mant√©m m√≥dulos carregados indexados por caminho absoluto
2. **Module**: Representa um m√≥dulo carregado com AST e exports
3. **Resolu√ß√£o de caminho**: Resolve caminhos relativos/absolutos para caminhos can√¥nicos
4. **Execu√ß√£o topol√≥gica**: Executa m√≥dulos em ordem de depend√™ncia

### Processo de Carregamento de M√≥dulos

1. **Fase de parse**: An√°lise l√©xica e sint√°tica do arquivo de m√≥dulo
2. **Resolu√ß√£o de depend√™ncias**: Carrega recursivamente m√≥dulos importados
3. **Detec√ß√£o de ciclos**: Verifica se m√≥dulo j√° est√° sendo carregado
4. **Caching**: Armazena m√≥dulo no cache por caminho absoluto
5. **Fase de execu√ß√£o**: Executa em ordem topol√≥gica (depend√™ncias primeiro)

### API

```c
// API de alto n√≠vel
int execute_file_with_modules(const char *file_path,
                               int argc, char **argv,
                               ExecutionContext *ctx);

// API de baixo n√≠vel
ModuleCache* module_cache_new(const char *initial_dir);
void module_cache_free(ModuleCache *cache);
Module* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);
void execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);
```

## Testes

M√≥dulos de teste est√£o localizados em `tests/modules/` e `tests/parity/modules/`:

- `math.hml` - M√≥dulo b√°sico com exports
- `test_import_named.hml` - Teste de imports nomeados
- `test_import_namespace.hml` - Teste de import de namespace
- `test_import_alias.hml` - Teste de alias de import
- `export_extern.hml` - Teste de export de fun√ß√µes FFI extern (Linux)

## Imports de Pacotes (hpm)

Com [hpm](https://github.com/hemlang/hpm) instalado, voc√™ pode importar pacotes de terceiros do GitHub:

```hemlock
// Importa da raiz do pacote (usando "main" do package.json)
import { app, router } from "hemlang/sprout";

// Importa de subcaminho
import { middleware } from "hemlang/sprout/middleware";

// Biblioteca padr√£o (embutida no Hemlock)
import { HashMap } from "@stdlib/collections";
```

Pacotes s√£o instalados em `hem_modules/` e resolvidos usando sintaxe `owner/repo` do GitHub.

```bash
# Instalar pacote
hpm install hemlang/sprout

# Instalar com restri√ß√£o de vers√£o
hpm install hemlang/sprout@^1.0.0
```

Para detalhes completos, veja a [documenta√ß√£o do hpm](https://github.com/hemlang/hpm).

## Limita√ß√µes Atuais

1. **Sem imports din√¢micos**: `import()` como fun√ß√£o de runtime n√£o √© suportado
2. **Sem exports condicionais**: Exports devem estar no n√≠vel superior
3. **Caminhos de biblioteca est√°ticos**: Imports de biblioteca FFI usam caminhos est√°ticos (espec√≠ficos de plataforma)

## Trabalho Futuro

- Imports din√¢micos usando fun√ß√£o `import()`
- Exports condicionais
- Metadados de m√≥dulo (`import.meta`)
- Tree shaking e elimina√ß√£o de c√≥digo morto

## Exemplos

Para exemplos funcionais do sistema de m√≥dulos, veja `tests/modules/`.

Estrutura de m√≥dulo de exemplo:
```
project/
‚îú‚îÄ‚îÄ main.hml
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ math.hml
‚îÇ   ‚îú‚îÄ‚îÄ string.hml
‚îÇ   ‚îî‚îÄ‚îÄ index.hml (m√≥dulo barrel)
‚îî‚îÄ‚îÄ utils/
    ‚îî‚îÄ‚îÄ helpers.hml
```

Uso de exemplo:
```hemlock
// lib/math.hml
export fn add(a, b) { return a + b; }
export fn multiply(a, b) { return a * b; }

// lib/index.hml (barrel)
export { add, multiply } from "./math.hml";

// main.hml
import { add } from "./lib/index.hml";
print(add(2, 3));  // 5
```


--------------------------------------------------------------------------------
## Objetos
--------------------------------------------------------------------------------

# Objetos

Hemlock implementa objetos estilo JavaScript com aloca√ß√£o no heap, campos din√¢micos, m√©todos e duck typing. Objetos s√£o estruturas de dados flex√≠veis que combinam dados e comportamento.

## Vis√£o Geral

```hemlock
// Objeto an√¥nimo
let person = { name: "Alice", age: 30, city: "NYC" };
print(person.name);  // "Alice"

// Objeto com m√©todos
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    }
};

counter.increment();
print(counter.count);  // 1
```

## Literais de Objeto

### Sintaxe B√°sica

```hemlock
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};
```

**Sintaxe:**
- Chaves `{}` envolvem o objeto
- Pares chave-valor separados por v√≠rgulas
- Chaves s√£o identificadores (n√£o precisam de aspas)
- Valores podem ser qualquer tipo

### Objeto Vazio

```hemlock
let obj = {};  // Objeto vazio

// Adicionar campos depois
obj.name = "Alice";
obj.age = 30;
```

### Objetos Aninhados

```hemlock
let user = {
    info: {
        name: "Bob",
        age: 25
    },
    active: true,
    settings: {
        theme: "dark",
        notifications: true
    }
};

print(user.info.name);           // "Bob"
print(user.settings.theme);      // "dark"
```

### Valores de Tipos Mistos

```hemlock
let mixed = {
    number: 42,
    text: "hello",
    flag: true,
    data: null,
    items: [1, 2, 3],
    config: { x: 10, y: 20 }
};
```

### Sintaxe de Propriedade Abreviada

Quando o nome da vari√°vel corresponde ao nome da propriedade, use sintaxe abreviada:

```hemlock
let name = "Alice";
let age = 30;
let active = true;

// Abreviado: { name } equivale a { name: name }
let person = { name, age, active };

print(person.name);   // "Alice"
print(person.age);    // 30
print(person.active); // true
```

**Misturando abreviado e propriedades regulares:**
```hemlock
let city = "NYC";
let obj = { name, age, city, role: "admin" };
```

### Operador Spread

O operador spread (`...`) copia todos os campos de um objeto para outro:

```hemlock
let base = { x: 1, y: 2 };
let extended = { ...base, z: 3 };

print(extended.x);  // 1
print(extended.y);  // 2
print(extended.z);  // 3
```

**Sobrescrevendo valores com spread:**
```hemlock
let defaults = { theme: "light", size: "medium", debug: false };
let custom = { ...defaults, theme: "dark" };

print(custom.theme);  // "dark" (sobrescrito)
print(custom.size);   // "medium" (de defaults)
print(custom.debug);  // false (de defaults)
```

**M√∫ltiplos spreads (√∫ltimos sobrescrevem anteriores):**
```hemlock
let a = { x: 1 };
let b = { y: 2 };
let merged = { ...a, ...b, z: 3 };

print(merged.x);  // 1
print(merged.y);  // 2
print(merged.z);  // 3

// Spreads posteriores sobrescrevem anteriores
let first = { val: "first" };
let second = { val: "second" };
let combined = { ...first, ...second };
print(combined.val);  // "second"
```

**Combinando abreviado e spread:**
```hemlock
let status = "active";
let data = { id: 1, name: "Item" };
let full = { ...data, status };

print(full.id);      // 1
print(full.name);    // "Item"
print(full.status);  // "active"
```

**Padr√£o de sobrescrita de configura√ß√£o:**
```hemlock
let defaultConfig = {
    debug: false,
    timeout: 30,
    retries: 3
};

let prodConfig = { ...defaultConfig, timeout: 60 };
let devConfig = { ...defaultConfig, debug: true };

print(prodConfig.timeout);  // 60
print(devConfig.debug);     // true
```

**Nota:** Spread executa c√≥pia rasa. Objetos aninhados compartilham refer√™ncia:
```hemlock
let nested = { inner: { val: 42 } };
let copied = { ...nested };
print(copied.inner.val);  // 42 (mesma refer√™ncia que nested.inner)
```

## Acesso a Campos

### Sintaxe de Ponto

```hemlock
let person = { name: "Alice", age: 30 };

// Lendo campos
let name = person.name;      // "Alice"
let age = person.age;        // 30

// Modificando campos
person.age = 31;
print(person.age);           // 31
```

### Adi√ß√£o Din√¢mica de Campos

Adicione novos campos em tempo de execu√ß√£o:

```hemlock
let person = { name: "Alice" };

// Adicionar novos campos
person.email = "alice@example.com";
person.phone = "555-1234";

print(person.email);  // "alice@example.com"
```

### Remo√ß√£o de Campos

**Nota:** Remo√ß√£o de campos n√£o √© suportada atualmente. Defina como `null` em vez disso:

```hemlock
let obj = { x: 10, y: 20 };

// N√£o pode remover campos (n√£o suportado)
// obj.x = undefined;  // N√£o existe 'undefined' em Hemlock

// Alternativa: definir como null
obj.x = null;
```

## M√©todos e `self`

### Definindo M√©todos

M√©todos s√£o fun√ß√µes armazenadas em campos de objeto:

```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    },
    decrement: fn() {
        self.count = self.count - 1;
    },
    get: fn() {
        return self.count;
    }
};
```

### Palavra-chave `self`

Quando uma fun√ß√£o √© chamada como m√©todo, `self` √© automaticamente vinculado ao objeto:

```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;  // self aponta para counter
    }
};

counter.increment();  // self vinculado a counter
print(counter.count);  // 1
```

**Como funciona:**
- Detec√ß√£o de chamada de m√©todo verifica se a express√£o de fun√ß√£o √© acesso a propriedade
- `self` √© automaticamente vinculado ao objeto no momento da chamada
- `self` √© somente leitura (n√£o pode reatribuir `self` em si)

### Detec√ß√£o de Chamada de M√©todo

```hemlock
let obj = {
    value: 10,
    method: fn() {
        return self.value;
    }
};

// Chamado como m√©todo - self √© vinculado
print(obj.method());  // 10

// Chamado como fun√ß√£o - self √© null (erro)
let f = obj.method;
print(f());  // Erro: self n√£o definido
```

### M√©todos com Par√¢metros

```hemlock
let calculator = {
    result: 0,
    add: fn(x) {
        self.result = self.result + x;
    },
    multiply: fn(x) {
        self.result = self.result * x;
    },
    get: fn() {
        return self.result;
    }
};

calculator.add(5);
calculator.multiply(2);
print(calculator.get());  // 10
```

## Defini√ß√µes de Tipo com `define`

### Defini√ß√£o de Tipo B√°sica

Use `define` para definir estrutura de objeto:

```hemlock
define Person {
    name: string,
    age: i32,
    active: bool,
}

// Criar objeto e atribuir a vari√°vel tipada
let p = { name: "Alice", age: 30, active: true };
let typed_p: Person = p;  // Duck typing valida estrutura

print(typeof(typed_p));  // "Person"
```

**O que `define` faz:**
- Declara tipo com campos obrigat√≥rios
- Habilita valida√ß√£o de duck typing
- Define nome do tipo do objeto para `typeof()`

### Duck Typing

Objetos s√£o validados contra `define` usando **compatibilidade estrutural**:

```hemlock
define Person {
    name: string,
    age: i32,
}

// Correto: tem todos os campos obrigat√≥rios
let p1: Person = { name: "Alice", age: 30 };

// Correto: campos extras permitidos
let p2: Person = {
    name: "Bob",
    age: 25,
    city: "NYC",
    active: true
};

// Erro: falta campo obrigat√≥rio 'age'
let p3: Person = { name: "Carol" };

// Erro: tipo errado para 'age'
let p4: Person = { name: "Dave", age: "thirty" };
```

**Regras de duck typing:**
- Todos os campos obrigat√≥rios devem estar presentes
- Tipos de campo devem corresponder
- Campos extras s√£o permitidos e preservados
- Valida√ß√£o ocorre na atribui√ß√£o

### Campos Opcionais

Campos podem ser opcionais com valores padr√£o:

```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,       // Opcional com valor padr√£o
    nickname?: string,   // Opcional, padr√£o null
}

// Objeto apenas com campos obrigat√≥rios
let p = { name: "Alice", age: 30 };
let typed_p: Person = p;

print(typed_p.active);    // true (padr√£o aplicado)
print(typed_p.nickname);  // null (sem padr√£o)

// Pode sobrescrever campos opcionais
let p2: Person = { name: "Bob", age: 25, active: false };
print(p2.active);  // false (sobrescrito)
```

**Sintaxe de campos opcionais:**
- `field?: default_value` - Opcional com valor padr√£o
- `field?: type` - Opcional com anota√ß√£o de tipo, padr√£o null
- Se campo opcional estiver faltando, √© adicionado durante verifica√ß√£o de duck typing

### Verifica√ß√£o de Tipo

```hemlock
define Point {
    x: i32,
    y: i32,
}

let p = { x: 10, y: 20 };
let point: Point = p;  // Verifica√ß√£o de tipo ocorre aqui

print(typeof(point));  // "Point"
print(typeof(p));      // "object" (objeto original ainda √© an√¥nimo)
```

**Quando verifica√ß√£o de tipo ocorre:**
- Na atribui√ß√£o a vari√°vel tipada
- Verifica se todos os campos obrigat√≥rios existem
- Verifica se tipos de campo correspondem (com convers√£o impl√≠cita)
- Define nome do tipo do objeto

## Assinaturas de M√©todo em Define

Blocos define podem especificar assinaturas de m√©todo, criando contratos tipo interface:

### M√©todos Obrigat√≥rios

```hemlock
define Comparable {
    value: i32,
    fn compare(other: Self): i32;  // Assinatura de m√©todo obrigat√≥ria
}

// Objeto deve fornecer m√©todos obrigat√≥rios
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};
```

### M√©todos Opcionais

```hemlock
define Serializable {
    fn serialize(): string;       // Obrigat√≥rio
    fn pretty?(): string;         // M√©todo opcional (pode n√£o existir)
}
```

### Tipo `Self`

`Self` refere-se ao tipo sendo definido, suportando defini√ß√µes de tipo recursivas:

```hemlock
define Cloneable {
    fn clone(): Self;  // Retorna mesmo tipo que o objeto
}

define Comparable {
    fn compare(other: Self): i32;  // Aceita mesmo tipo como par√¢metro
    fn equals(other: Self): bool;
}

let item: Cloneable = {
    value: 42,
    clone: fn() {
        return { value: self.value, clone: self.clone };
    }
};
```

### Misturando Campos e M√©todos

```hemlock
define Entity {
    id: i32,
    name: string,
    fn validate(): bool;
    fn serialize(): string;
}

let user: Entity = {
    id: 1,
    name: "Alice",
    validate: fn() { return self.id > 0 && self.name != ""; },
    serialize: fn() { return '{"id":' + self.id + ',"name":"' + self.name + '"}'; }
};
```

## Tipos Compostos (Tipos de Interse√ß√£o)

Tipos compostos usam `&` para exigir que objetos satisfa√ßam m√∫ltiplas defini√ß√µes de tipo:

### Tipo Composto B√°sico

```hemlock
define HasName { name: string }
define HasAge { age: i32 }

// Tipo composto: objeto deve satisfazer todos os tipos
let person: HasName & HasAge = { name: "Alice", age: 30 };
```

### Par√¢metros de Fun√ß√£o com Tipos Compostos

```hemlock
fn greet(p: HasName & HasAge) {
    print(p.name + " is " + p.age);
}

greet({ name: "Bob", age: 25, city: "NYC" });  // Campos extras permitidos
```

### Tr√™s ou Mais Tipos

```hemlock
define HasEmail { email: string }

fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}
```

### Aliases de Tipo para Tipos Compostos

```hemlock
// Criar alias nomeado para tipo composto
type Person = HasName & HasAge;
type Employee = HasName & HasAge & HasEmail;

let emp: Employee = {
    name: "Charlie",
    age: 35,
    email: "charlie@example.com"
};
```

**Duck typing de tipos compostos:** Campos extras s√£o sempre permitidos - objetos s√≥ precisam ter pelo menos todos os campos requeridos por todos os tipos componentes.

## Serializa√ß√£o JSON

### Serializando para JSON

Converta objetos para string JSON:

```hemlock
// obj.serialize() - converte objeto para string JSON
let obj = { x: 10, y: 20, name: "test" };
let json = obj.serialize();
print(json);  // {"x":10,"y":20,"name":"test"}

// Objetos aninhados
let nested = { inner: { a: 1, b: 2 }, outer: 3 };
print(nested.serialize());  // {"inner":{"a":1,"b":2},"outer":3}
```

### Desserializando de JSON

Parse string JSON de volta para objeto:

```hemlock
// json.deserialize() - parse string JSON para objeto
let json_str = '{"x":10,"y":20,"name":"test"}';
let obj = json_str.deserialize();

print(obj.name);   // "test"
print(obj.x);      // 10
```

### Detec√ß√£o de Refer√™ncia Circular

Refer√™ncias circulares s√£o detectadas e causam erro:

```hemlock
let obj = { x: 10 };
obj.me = obj;  // Cria refer√™ncia circular

obj.serialize();  // Erro: serialize() detectou refer√™ncia circular
```

### Tipos Suportados

Serializa√ß√£o JSON suporta:

- **N√∫meros**: i8-i32, u8-u32, f32, f64
- **Booleanos**: true, false
- **Strings**: com sequ√™ncias de escape
- **Null**: valor null
- **Objetos**: objetos aninhados
- **Arrays**: arrays aninhados

**N√£o suportados:**
- Fun√ß√µes (omitidas silenciosamente)
- Ponteiros (erro)
- Buffer (erro)

### Tratamento de Erros

Serializa√ß√£o e desserializa√ß√£o podem lan√ßar erros:

```hemlock
// JSON inv√°lido lan√ßa erro
try {
    let bad = "not valid json".deserialize();
} catch (e) {
    print("Parse error:", e);
}

// Ponteiros n√£o podem ser serializados
let obj = { ptr: alloc(10) };
try {
    obj.serialize();
} catch (e) {
    print("Serialize error:", e);
}
```

### Exemplo de Ida e Volta

Exemplo completo de serializa√ß√£o e desserializa√ß√£o:

```hemlock
define Config {
    host: string,
    port: i32,
    debug: bool
}

// Criar e serializar
let config: Config = {
    host: "localhost",
    port: 8080,
    debug: true
};
let json = config.serialize();
print(json);  // {"host":"localhost","port":8080,"debug":true}

// Desserializar
let restored = json.deserialize();
print(restored.host);  // "localhost"
print(restored.port);  // 8080
```

## Fun√ß√µes Embutidas

### `typeof(value)`

Retorna nome do tipo como string:

```hemlock
let obj = { x: 10 };
print(typeof(obj));  // "object"

define Person { name: string, age: i32 }
let p: Person = { name: "Alice", age: 30 };
print(typeof(p));    // "Person"
```

**Valores de retorno:**
- Objeto an√¥nimo: `"object"`
- Objeto tipado: nome do tipo personalizado (ex: `"Person"`)

## Detalhes de Implementa√ß√£o

### Modelo de Mem√≥ria

- **Aloca√ß√£o no heap** - Todos os objetos s√£o alocados no heap
- **C√≥pia rasa** - Atribui√ß√£o copia refer√™ncia, n√£o objeto
- **Campos din√¢micos** - Armazenados como array din√¢mico de pares nome/valor
- **Contagem de refer√™ncia** - Objetos s√£o liberados automaticamente ao sair do escopo

### Sem√¢ntica de Refer√™ncia

```hemlock
let obj1 = { x: 10 };
let obj2 = obj1;  // C√≥pia rasa (mesma refer√™ncia)

obj2.x = 20;
print(obj1.x);  // 20 (ambos apontam para mesmo objeto)
```

### Armazenamento de M√©todos

M√©todos s√£o apenas fun√ß√µes armazenadas em campos:

```hemlock
let obj = {
    value: 10,
    method: fn() { return self.value; }
};

// method √© uma fun√ß√£o armazenada em obj.method
print(typeof(obj.method));  // "function"
```

## Padr√µes Comuns

### Padr√£o: Construtor

```hemlock
fn createPerson(name: string, age: i32) {
    return {
        name: name,
        age: age,
        greet: fn() {
            return "Hi, I'm " + self.name;
        }
    };
}

let person = createPerson("Alice", 30);
print(person.greet());  // "Hi, I'm Alice"
```

### Padr√£o: Builder de Objeto

```hemlock
fn PersonBuilder() {
    return {
        name: null,
        age: null,

        setName: fn(n) {
            self.name = n;
            return self;  // Suporta encadeamento
        },

        setAge: fn(a) {
            self.age = a;
            return self;
        },

        build: fn() {
            return { name: self.name, age: self.age };
        }
    };
}

let person = PersonBuilder()
    .setName("Alice")
    .setAge(30)
    .build();
```

### Padr√£o: Objeto de Estado

```hemlock
let state = {
    status: "idle",
    data: null,
    error: null,

    setState: fn(new_status) {
        self.status = new_status;
    },

    setData: fn(new_data) {
        self.data = new_data;
        self.status = "success";
    },

    setError: fn(err) {
        self.error = err;
        self.status = "error";
    }
};
```

### Padr√£o: Objeto de Configura√ß√£o

```hemlock
let config = {
    defaults: {
        timeout: 30,
        retries: 3,
        debug: false
    },

    get: fn(key) {
        if (self.defaults[key] != null) {
            return self.defaults[key];
        }
        return null;
    },

    set: fn(key, value) {
        self.defaults[key] = value;
    }
};
```

## Melhores Pr√°ticas

1. **Use `define` para estruturas** - Documente formas de objeto esperadas
2. **Prefira fun√ß√µes de f√°brica** - Use construtores para criar objetos
3. **Mantenha objetos simples** - N√£o aninhe muito profundamente
4. **Documente uso de `self`** - Deixe comportamento de m√©todo claro
5. **Valide na atribui√ß√£o** - Use duck typing para detectar erros cedo
6. **Evite refer√™ncias circulares** - Causam erros de serializa√ß√£o
7. **Use campos opcionais** - Forne√ßa padr√µes razo√°veis

## Armadilhas Comuns

### Armadilha: Refer√™ncia vs Valor

```hemlock
let obj1 = { x: 10 };
let obj2 = obj1;  // C√≥pia rasa

obj2.x = 20;
print(obj1.x);  // 20 (inesperado! ambos mudaram)

// Evitar: criar novo objeto
let obj3 = { x: obj1.x };  // C√≥pia profunda (manual)
```

### Armadilha: `self` em Chamadas N√£o-m√©todo

```hemlock
let obj = {
    value: 10,
    method: fn() { return self.value; }
};

// V√°lido: chamado como m√©todo
print(obj.method());  // 10

// Erro: chamado como fun√ß√£o
let f = obj.method;
print(f());  // Erro: self n√£o definido
```

### Armadilha: Ponteiros Brutos em Objetos

```hemlock
// Objetos s√£o liberados automaticamente, mas ponteiros brutos neles n√£o
fn create_objects() {
    let obj = { data: alloc(1000) };  // Ponteiro bruto precisa de free manual
    // obj liberado automaticamente ao sair do escopo, mas obj.data vaza!
}

// Solu√ß√£o: libere ponteiros brutos antes de sair do escopo
fn safe_create() {
    let obj = { data: alloc(1000) };
    // ... use obj.data ...
    free(obj.data);  // Libere ponteiro bruto explicitamente
}  // obj em si √© liberado automaticamente
```

### Armadilha: Confus√£o de Tipo

```hemlock
let obj = { x: 10 };

define Point { x: i32, y: i32 }

// Erro: falta campo obrigat√≥rio 'y'
let p: Point = obj;
```

## Exemplos

### Exemplo: Matem√°tica Vetorial

```hemlock
fn createVector(x, y) {
    return {
        x: x,
        y: y,

        add: fn(other) {
            return createVector(
                self.x + other.x,
                self.y + other.y
            );
        },

        length: fn() {
            return sqrt(self.x * self.x + self.y * self.y);
        },

        toString: fn() {
            return "(" + typeof(self.x) + ", " + typeof(self.y) + ")";
        }
    };
}

let v1 = createVector(3, 4);
let v2 = createVector(1, 2);
let v3 = v1.add(v2);

print(v3.toString());  // "(4, 6)"
```

### Exemplo: Banco de Dados Simples

```hemlock
fn createDatabase() {
    let records = [];
    let next_id = 1;

    return {
        insert: fn(data) {
            let record = { id: next_id, data: data };
            records.push(record);
            next_id = next_id + 1;
            return record.id;
        },

        find: fn(id) {
            let i = 0;
            while (i < records.length) {
                if (records[i].id == id) {
                    return records[i];
                }
                i = i + 1;
            }
            return null;
        },

        count: fn() {
            return records.length;
        }
    };
}

let db = createDatabase();
let id = db.insert({ name: "Alice", age: 30 });
let record = db.find(id);
print(record.data.name);  // "Alice"
```

### Exemplo: Emissor de Eventos

```hemlock
fn createEventEmitter() {
    let listeners = {};

    return {
        on: fn(event, handler) {
            if (listeners[event] == null) {
                listeners[event] = [];
            }
            listeners[event].push(handler);
        },

        emit: fn(event, data) {
            if (listeners[event] != null) {
                let i = 0;
                while (i < listeners[event].length) {
                    listeners[event][i](data);
                    i = i + 1;
                }
            }
        }
    };
}

let emitter = createEventEmitter();

emitter.on("message", fn(data) {
    print("Received: " + data);
});

emitter.emit("message", "Hello!");
```

## Limita√ß√µes

Limita√ß√µes atuais:

- **Sem c√≥pia profunda** - Deve copiar objetos aninhados manualmente (spread √© c√≥pia rasa)
- **Sem passagem por valor** - Objetos s√£o sempre passados por refer√™ncia
- **Sem propriedades computadas** - Sintaxe `{[key]: value}` n√£o suportada
- **`self` √© somente leitura** - N√£o pode reatribuir `self` em m√©todos
- **Sem remo√ß√£o de propriedade** - Campos n√£o podem ser removidos depois de adicionados

**Nota:** Objetos usam contagem de refer√™ncia, sendo liberados automaticamente ao sair do escopo. Veja [Gerenciamento de Mem√≥ria](memory.md#internal-reference-counting) para detalhes.

## T√≥picos Relacionados

- [Fun√ß√µes](#language-guide-functions) - M√©todos s√£o fun√ß√µes armazenadas em objetos
- [Arrays](#language-guide-arrays) - Arrays tamb√©m s√£o tipo objeto
- [Tipos](#language-guide-types) - Duck typing e defini√ß√µes de tipo
- [Tratamento de Erros](#language-guide-error-handling) - Lan√ßando objetos de erro

## Veja Tamb√©m

- **Duck typing**: Veja se√ß√£o "Objects" em CLAUDE.md para detalhes de duck typing
- **JSON**: Veja CLAUDE.md para detalhes de serializa√ß√£o JSON
- **Mem√≥ria**: Veja [Mem√≥ria](#language-guide-memory) para aloca√ß√£o de objetos


--------------------------------------------------------------------------------
## Runas
--------------------------------------------------------------------------------

# Caracteres Rune

Rune representa **pontos de codigo Unicode** (U+0000 a U+10FFFF), como um tipo distinto para operacoes de caracteres em Hemlock. Diferente de bytes (u8), runes sao caracteres Unicode completos que podem representar caracteres de qualquer idioma ou emojis.

## Visao Geral

```hemlock
let ch = 'A';           // Literal rune
let emoji = 'üöÄ';       // Caractere multi-byte como um unico rune
print(ch);              // 'A'
print(emoji);           // U+1F680

let s = "Hello " + '!'; // Concatenacao string + rune
let r = '>' + " msg";   // Concatenacao rune + string
```

## O que e um Rune?

Rune e um **valor de 32 bits** que representa um ponto de codigo Unicode:

- **Intervalo:** 0 a 0x10FFFF (1.114.111 pontos de codigo validos)
- **Nao e um tipo numerico** - Usado para representacao de caracteres
- **Diferente de u8/char** - Rune e Unicode completo, u8 e apenas um byte
- **Indexacao de string retorna** - `str[0]` retorna rune, nao byte

**Por que usar rune?**
- Strings Hemlock sao codificadas em UTF-8
- Um unico caractere Unicode pode ter 1-4 bytes em UTF-8
- Rune permite trabalhar com caracteres completos, nao bytes parciais

## Literais Rune

### Sintaxe Basica

Aspas simples denotam literais rune:

```hemlock
let a = 'A';            // Caractere ASCII
let b = '0';            // Caractere digito
let c = '!';            // Pontuacao
let d = ' ';            // Espaco
```

### Caracteres UTF-8 Multi-byte

Rune pode representar qualquer caractere Unicode:

```hemlock
// Emojis
let foguete = 'üöÄ';     // Emoji (U+1F680)
let coracao = '‚ù§';      // Coracao (U+2764)
let sorriso = 'üòÄ';     // Rosto sorridente (U+1F600)

// Caracteres CJK
let chines = '‰∏≠';      // Chines (U+4E2D)
let japones = '„ÅÇ';     // Hiragana (U+3042)
let coreano = 'Ìïú';     // Hangul (U+D55C)

// Simbolos
let check = '‚úì';        // Marca de verificacao (U+2713)
let seta = '‚Üí';         // Seta direita (U+2192)
```

### Sequencias de Escape

Sequencias de escape comuns para caracteres especiais:

```hemlock
let newline = '\n';     // Quebra de linha (U+000A)
let tab = '\t';         // Tabulacao (U+0009)
let backslash = '\\';   // Barra invertida (U+005C)
let quote = '\'';       // Aspas simples (U+0027)
let dquote = '"';       // Aspas duplas (U+0022)
let null_char = '\0';   // Caractere nulo (U+0000)
let cr = '\r';          // Retorno de carro (U+000D)
```

**Sequencias de escape disponiveis:**
- `\n` - Quebra de linha
- `\t` - Tabulacao horizontal
- `\r` - Retorno de carro
- `\0` - Caractere nulo
- `\\` - Barra invertida
- `\'` - Aspas simples
- `\"` - Aspas duplas

### Escapes Unicode

Use sintaxe `\u{XXXXXX}` para pontos de codigo Unicode (ate 6 digitos hexadecimais):

```hemlock
let foguete = '\u{1F680}';   // üöÄ emoji via escape Unicode
let coracao = '\u{2764}';    // ‚ù§ coracao
let ascii = '\u{41}';        // 'A' via escape
let max = '\u{10FFFF}';      // Ponto de codigo Unicode maximo

// Zeros a esquerda sao opcionais
let a = '\u{41}';            // Mesmo que '\u{0041}'
let b = '\u{0041}';
```

**Regras:**
- Intervalo: `\u{0}` a `\u{10FFFF}`
- Digitos hexadecimais: 1 a 6 digitos
- Case-insensitive: `\u{1F680}` ou `\u{1f680}`
- Valores fora do intervalo Unicode valido causam erro

## Concatenacao String + Rune

Runes podem ser concatenados com strings:

```hemlock
// String + rune
let saudacao = "Ola" + '!';         // "Ola!"
let decorado = "Texto" + '‚úì';       // "Texto‚úì"

// Rune + string
let prefixo = '>' + " Mensagem";    // "> Mensagem"
let marcador = '‚Ä¢' + " Item";       // "‚Ä¢ Item"

// Concatenacao multipla
let msg = "Oi " + 'üëã' + " Mundo " + 'üåç';  // "Oi üëã Mundo üåç"

// Encadeamento de metodos funciona
let resultado = ('>' + " Importante").to_upper();  // "> IMPORTANTE"
```

**Como funciona:**
- Rune e automaticamente codificado em UTF-8
- Convertido para string durante concatenacao
- Operador de concatenacao de string trata isso transparentemente

## Conversao de Tipos

Runes podem ser convertidos de/para outros tipos.

### Inteiro <-> Rune

Converte entre inteiros e runes para trabalhar com valores de pontos de codigo:

```hemlock
// Inteiro para rune (valor do ponto de codigo)
let codigo: rune = 65;            // 'A' (ASCII 65)
let emoji_code: rune = 128640;    // U+1F680 (üöÄ)

// Rune para inteiro (obter valor do ponto de codigo)
let r = 'Z';
let valor: i32 = r;               // 90 (valor ASCII)

let foguete = 'üöÄ';
let codigo: i32 = foguete;        // 128640 (U+1F680)
```

**Verificacao de intervalo:**
- Inteiro para rune: deve estar no intervalo [0, 0x10FFFF]
- Valores fora do intervalo causam erro de runtime
- Rune para inteiro: sempre sucede (retorna ponto de codigo)

### Rune -> String

Runes podem ser explicitamente convertidos para strings:

```hemlock
// Conversao explicita
let ch: string = 'H';           // "H"
let emoji: string = 'üöÄ';       // "üöÄ"

// Conversao automatica em concatenacao
let s = "" + 'A';               // "A"
let s2 = "x" + 'y' + "z";       // "xyz"
```

### u8 (Byte) -> Rune

Qualquer valor u8 (0-255) pode ser convertido para rune:

```hemlock
// Intervalo ASCII (0-127)
let byte: u8 = 65;
let valor_rune: rune = byte;    // 'A'

// ASCII estendido / Latin-1 (128-255)
let estendido: u8 = 200;
let r: rune = estendido;        // U+00C8 (E)

// Nota: 0-127 e ASCII, 128-255 e Latin-1
```

### Conversoes Encadeadas

Conversoes de tipo podem ser encadeadas:

```hemlock
// i32 -> rune -> string
let codigo: i32 = 128512;       // Ponto de codigo sorriso
let r: rune = codigo;           // üòÄ
let s: string = r;              // "üòÄ"

// Em uma expressao
let emoji: string = 128640;     // Implicito i32 -> rune -> string (üöÄ)
```

## Operacoes com Runes

### Impressao

Runes sao exibidos de forma diferente dependendo do ponto de codigo:

```hemlock
let ascii = 'A';
print(ascii);                   // 'A' (com aspas, ASCII imprimivel)

let emoji = 'üöÄ';
print(emoji);                   // U+1F680 (notacao Unicode para nao-ASCII)

let tab = '\t';
print(tab);                     // U+0009 (hex para nao-imprimiveis)

let espaco = ' ';
print(espaco);                  // ' ' (imprimivel)
```

**Formato de impressao:**
- ASCII imprimivel (32-126): Caractere com aspas `'A'`
- Nao-imprimivel ou Unicode: Notacao hexadecimal `U+XXXX`

### Verificacao de Tipo

Use `typeof()` para verificar se um valor e rune:

```hemlock
let r = 'üöÄ';
print(typeof(r));               // "rune"

let s = "texto";
let ch = s[0];
print(typeof(ch));              // "rune" (indexacao retorna rune)

let num = 65;
print(typeof(num));             // "i32"
```

### Comparacao

Runes podem ser comparados por igualdade:

```hemlock
let a = 'A';
let b = 'B';
print(a == a);                  // true
print(a == b);                  // false

// Case-sensitive
let maiuscula = 'A';
let minuscula = 'a';
print(maiuscula == minuscula);  // false

// Runes podem ser comparados com inteiros (valor do ponto de codigo)
print(a == 65);                 // true (conversao implicita)
print('üöÄ' == 128640);          // true
```

**Operadores de comparacao:**
- `==` - Igual a
- `!=` - Diferente de
- `<`, `>`, `<=`, `>=` - Ordem de ponto de codigo

```hemlock
print('A' < 'B');               // true (65 < 66)
print('a' > 'Z');               // true (97 > 90)
```

## Trabalhando com Indexacao de Strings

Indexacao de strings retorna runes, nao bytes:

```hemlock
let s = "HelloüöÄ";
let h = s[0];                   // 'H' (rune)
let foguete = s[5];             // 'üöÄ' (rune)

print(typeof(h));               // "rune"
print(typeof(foguete));         // "rune"

// Pode converter para string se necessario
let h_str: string = h;          // "H"
let foguete_str: string = foguete; // "üöÄ"
```

**Importante:** Indexacao de strings usa posicao de ponto de codigo, nao offset de byte:

```hemlock
let texto = "OiüöÄ!";
// Posicoes de ponto de codigo: 0='O', 1='i', 2='üöÄ', 3='!'
// Posicoes de byte: 0='O', 1='i', 2-5='üöÄ', 6='!'

let r = texto[2];               // 'üöÄ' (ponto de codigo 2)
print(typeof(r));               // "rune"
```

## Exemplos

### Exemplo: Classificacao de Caracteres

```hemlock
fn is_digit(r: rune): bool {
    return r >= '0' && r <= '9';
}

fn is_upper(r: rune): bool {
    return r >= 'A' && r <= 'Z';
}

fn is_lower(r: rune): bool {
    return r >= 'a' && r <= 'z';
}

print(is_digit('5'));           // true
print(is_upper('A'));           // true
print(is_lower('z'));           // true
```

### Exemplo: Conversao de Caso

```hemlock
fn to_upper_rune(r: rune): rune {
    if (r >= 'a' && r <= 'z') {
        // Converte para maiuscula (subtrai 32)
        let codigo: i32 = r;
        codigo = codigo - 32;
        return codigo;
    }
    return r;
}

fn to_lower_rune(r: rune): rune {
    if (r >= 'A' && r <= 'Z') {
        // Converte para minuscula (adiciona 32)
        let codigo: i32 = r;
        codigo = codigo + 32;
        return codigo;
    }
    return r;
}

print(to_upper_rune('a'));      // 'A'
print(to_lower_rune('Z'));      // 'z'
```

### Exemplo: Iteracao de Caracteres

```hemlock
fn print_chars(s: string) {
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        print("Posicao " + typeof(i) + ": " + typeof(ch));
        i = i + 1;
    }
}

print_chars("OiüöÄ");
// Posicao 0: 'O'
// Posicao 1: 'i'
// Posicao 2: U+1F680
```

### Exemplo: Construindo Strings a partir de Runes

```hemlock
fn repeat_char(ch: rune, count: i32): string {
    let resultado = "";
    let i = 0;
    while (i < count) {
        resultado = resultado + ch;
        i = i + 1;
    }
    return resultado;
}

let linha = repeat_char('=', 40);   // "========================================"
let estrelas = repeat_char('‚≠ê', 5); // "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê"
```

## Padroes Comuns

### Padrao: Filtragem de Caracteres

```hemlock
fn filter_digits(s: string): string {
    let resultado = "";
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        if (ch >= '0' && ch <= '9') {
            resultado = resultado + ch;
        }
        i = i + 1;
    }
    return resultado;
}

let texto = "abc123def456";
let digitos = filter_digits(texto);  // "123456"
```

### Padrao: Contagem de Caracteres

```hemlock
fn count_char(s: string, alvo: rune): i32 {
    let count = 0;
    let i = 0;
    while (i < s.length) {
        if (s[i] == alvo) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

let texto = "hello world";
let count_l = count_char(texto, 'l');  // 3
let count_o = count_char(texto, 'o');  // 2
```

## Melhores Praticas

1. **Use rune para operacoes de caracteres** - Nao tente processar texto com bytes
2. **Indexacao de string retorna rune** - Lembre que `str[i]` retorna um rune
3. **Comparacoes conscientes de Unicode** - Runes tratam qualquer caractere Unicode
4. **Converta quando necessario** - Runes podem ser facilmente convertidos para strings e inteiros
5. **Teste com emojis** - Sempre teste operacoes de caracteres com caracteres multi-byte

## Armadilhas Comuns

### Armadilha: Confundir Rune com Byte

```hemlock
// Nao faca: tratar rune como byte
let r: rune = 'üöÄ';
let b: u8 = r;              // Erro: ponto de codigo rune 128640 nao cabe em u8

// Faca: use conversao apropriada
let r: rune = 'üöÄ';
let codigo: i32 = r;        // OK: 128640
```

### Armadilha: Indexacao de Bytes em String

```hemlock
// Nao faca: assumir indexacao por byte
let s = "üöÄ";
let byte = s.byte_at(0);    // 240 (primeiro byte UTF-8, nao caractere completo)

// Faca: use indexacao por ponto de codigo
let s = "üöÄ";
let rune = s[0];            // 'üöÄ' (caractere completo)
let rune2 = s.char_at(0);   // 'üöÄ' (metodo explicito)
```

## Topicos Relacionados

- [Strings](#language-guide-strings) - Operacoes de string e tratamento UTF-8
- [Tipos](#language-guide-types) - Sistema de tipos e conversoes
- [Fluxo de Controle](#language-guide-control-flow) - Usando runes em comparacoes

## Veja Tambem

- **Padrao Unicode**: Pontos de codigo Unicode sao definidos pelo Consorcio Unicode
- **Codificacao UTF-8**: Veja [Strings](#language-guide-strings) para detalhes de UTF-8
- **Conversao de Tipos**: Veja [Tipos](#language-guide-types) para regras de conversao


--------------------------------------------------------------------------------
## Sintaxe
--------------------------------------------------------------------------------

# Vis√£o Geral da Sintaxe

Este documento apresenta as regras b√°sicas de sintaxe e estrutura dos programas Hemlock.

## Regras B√°sicas de Sintaxe

### Ponto e V√≠rgula √© Obrigat√≥rio

Diferente do JavaScript ou Python, o ponto e v√≠rgula **deve** ser usado no final das instru√ß√µes:

```hemlock
let x = 42;
let y = 10;
print(x + y);
```

**O c√≥digo a seguir causar√° erro:**
```hemlock
let x = 42  // Erro: falta ponto e v√≠rgula
let y = 10  // Erro: falta ponto e v√≠rgula
```

### Chaves s√£o Obrigat√≥rias

Todos os blocos de fluxo de controle devem usar chaves, mesmo para instru√ß√µes √∫nicas:

```hemlock
// Correto
if (x > 0) {
    print("positive");
}

// Erro: faltam chaves
if (x > 0)
    print("positive");
```

### Coment√°rios

```hemlock
// Este √© um coment√°rio de linha √∫nica

/*
   Este √© um
   coment√°rio de m√∫ltiplas linhas
*/

let x = 42;  // Coment√°rio inline
```

## Vari√°veis

### Declara√ß√£o

Use `let` para declarar vari√°veis:

```hemlock
let count = 0;
let name = "Alice";
let pi = 3.14159;
```

### Anota√ß√µes de Tipo (Opcionais)

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let flag: bool = true;
let text: string = "hello";
```

### Constantes

Use `const` para declarar valores imut√°veis:

```hemlock
const MAX_SIZE: i32 = 1000;
const PI: f64 = 3.14159;
```

Tentar reatribuir uma constante causar√° um erro em tempo de execu√ß√£o: "Cannot assign to const variable".

## Express√µes

### Operadores Aritm√©ticos

```hemlock
let a = 10;
let b = 3;

print(a + b);   // 13 - adi√ß√£o
print(a - b);   // 7  - subtra√ß√£o
print(a * b);   // 30 - multiplica√ß√£o
print(a / b);   // 3  - divis√£o (inteira)
```

### Operadores de Compara√ß√£o

```hemlock
print(a == b);  // false - igual
print(a != b);  // true  - diferente
print(a > b);   // true  - maior que
print(a < b);   // false - menor que
print(a >= b);  // true  - maior ou igual
print(a <= b);  // false - menor ou igual
```

### Operadores L√≥gicos

```hemlock
let x = true;
let y = false;

print(x && y);  // false - e
print(x || y);  // true  - ou
print(!x);      // false - n√£o
```

### Operadores Bit a Bit

```hemlock
let a = 12;  // 1100
let b = 10;  // 1010

print(a & b);   // 8  - e bit a bit
print(a | b);   // 14 - ou bit a bit
print(a ^ b);   // 6  - ou exclusivo bit a bit
print(a << 2);  // 48 - deslocamento √† esquerda
print(a >> 1);  // 6  - deslocamento √† direita
print(~a);      // -13 - invers√£o bit a bit
```

### Preced√™ncia de Operadores

Da maior para a menor:

1. `()` - agrupamento
2. `!`, `~`, `-` (un√°rio) - operadores un√°rios
3. `*`, `/` - multiplica√ß√£o, divis√£o
4. `+`, `-` - adi√ß√£o, subtra√ß√£o
5. `<<`, `>>` - deslocamento de bits
6. `<`, `<=`, `>`, `>=` - compara√ß√£o
7. `==`, `!=` - igualdade
8. `&` - e bit a bit
9. `^` - ou exclusivo bit a bit
10. `|` - ou bit a bit
11. `&&` - e l√≥gico
12. `||` - ou l√≥gico

**Exemplo:**
```hemlock
let x = 2 + 3 * 4;      // 14 (n√£o 20)
let y = (2 + 3) * 4;    // 20
let z = 5 << 2 + 1;     // 40 (5 << 3)
```

## Fluxo de Controle

### Instru√ß√£o If

```hemlock
if (condition) {
    // corpo
}

if (condition) {
    // bloco then
} else {
    // bloco else
}

if (condition1) {
    // bloco 1
} else if (condition2) {
    // bloco 2
} else {
    // bloco padr√£o
}
```

### La√ßo While

```hemlock
while (condition) {
    // corpo
}
```

**Exemplo:**
```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

### La√ßo For

**For estilo C:**
```hemlock
for (initializer; condition; increment) {
    // corpo
}
```

**Exemplo:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**For-in (arrays):**
```hemlock
for (let item in array) {
    // corpo
}
```

**Exemplo:**
```hemlock
let items = [10, 20, 30];
for (let x in items) {
    print(x);
}
```

### Instru√ß√£o Switch

```hemlock
switch (expression) {
    case value1:
        // corpo
        break;
    case value2:
        // corpo
        break;
    default:
        // corpo padr√£o
        break;
}
```

**Exemplo:**
```hemlock
let day = 3;
switch (day) {
    case 1:
        print("Monday");
        break;
    case 2:
        print("Tuesday");
        break;
    case 3:
        print("Wednesday");
        break;
    default:
        print("Other");
        break;
}
```

### Break e Continue

```hemlock
// Break: sai do la√ßo
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        break;
    }
    print(i);
}

// Continue: pula para a pr√≥xima itera√ß√£o
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;
    }
    print(i);
}
```

## Fun√ß√µes

### Fun√ß√µes Nomeadas

```hemlock
fn function_name(param1: type1, param2: type2): return_type {
    // corpo
    return value;
}
```

**Exemplo:**
```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Fun√ß√µes An√¥nimas

```hemlock
let func = fn(params) {
    // corpo
};
```

**Exemplo:**
```hemlock
let multiply = fn(x, y) {
    return x * y;
};
```

### Anota√ß√µes de Tipo (Opcionais)

```hemlock
// Sem anota√ß√µes (infer√™ncia de tipo)
fn greet(name) {
    return "Hello, " + name;
}

// Com anota√ß√µes (verifica√ß√£o em tempo de execu√ß√£o)
fn divide(a: i32, b: i32): f64 {
    return a / b;
}
```

## Objetos

### Literais de Objeto

```hemlock
let obj = {
    field1: value1,
    field2: value2,
};
```

**Exemplo:**
```hemlock
let person = {
    name: "Alice",
    age: 30,
    active: true,
};
```

### M√©todos

```hemlock
let obj = {
    method: fn() {
        self.field = value;
    },
};
```

**Exemplo:**
```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    },
};
```

### Defini√ß√µes de Tipo

```hemlock
define TypeName {
    field1: type1,
    field2: type2,
    optional_field?: default_value,
}
```

**Exemplo:**
```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,
}
```

## Arrays

### Literais de Array

```hemlock
let arr = [element1, element2, element3];
```

**Exemplo:**
```hemlock
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, "two", true, null];
let empty = [];
```

### Indexa√ß√£o de Array

```hemlock
let arr = [10, 20, 30];
print(arr[0]);   // 10
arr[1] = 99;     // modificar elemento
```

## Tratamento de Erros

### Try/Catch

```hemlock
try {
    // c√≥digo que pode falhar
} catch (e) {
    // tratar erro
}
```

### Try/Finally

```hemlock
try {
    // c√≥digo que pode falhar
} finally {
    // sempre executa
}
```

### Try/Catch/Finally

```hemlock
try {
    // c√≥digo que pode falhar
} catch (e) {
    // tratar erro
} finally {
    // limpeza
}
```

### Throw

```hemlock
throw expression;
```

**Exemplo:**
```hemlock
if (x < 0) {
    throw "x must be positive";
}
```

### Panic

```hemlock
panic(message);
```

**Exemplo:**
```hemlock
panic("unrecoverable error");
```

## M√≥dulos (Experimental)

### Instru√ß√µes de Exporta√ß√£o

```hemlock
export fn function_name() { }
export const CONSTANT = value;
export let variable = value;
export { name1, name2 };
```

### Instru√ß√µes de Importa√ß√£o

```hemlock
import { name1, name2 } from "./module.hml";
import * as namespace from "./module.hml";
import { name as alias } from "./module.hml";
```

## Ass√≠ncrono (Experimental)

### Fun√ß√µes Ass√≠ncronas

```hemlock
async fn function_name(params): return_type {
    // corpo
}
```

### Spawn/Join

```hemlock
let task = spawn(async_function, arg1, arg2);
let result = join(task);
```

### Canais

```hemlock
let ch = channel(capacity);
ch.send(value);
let value = ch.recv();
ch.close();
```

## FFI (Interface de Fun√ß√£o Estrangeira)

### Importar Bibliotecas Compartilhadas

```hemlock
import "library_name.so";
```

### Declarar Fun√ß√µes Externas

```hemlock
extern fn function_name(param: type): return_type;
```

**Exemplo:**
```hemlock
import "libc.so.6";
extern fn strlen(s: string): i32;
```

## Literais

### Literais Inteiros

```hemlock
let decimal = 42;
let negative = -100;
let large = 5000000000;  // i64 autom√°tico

// Hexadecimal (prefixo 0x)
let hex = 0xDEADBEEF;
let hex2 = 0xFF;

// Bin√°rio (prefixo 0b)
let bin = 0b1010;
let bin2 = 0b11110000;

// Octal (prefixo 0o)
let oct = 0o777;
let oct2 = 0O123;

// Separadores num√©ricos para legibilidade
let million = 1_000_000;
let hex_sep = 0xFF_FF_FF;
let bin_sep = 0b1111_0000_1010_0101;
let oct_sep = 0o77_77;
```

### Literais de Ponto Flutuante

```hemlock
let f = 3.14;
let e = 2.71828;
let sci = 1.5e-10;       // nota√ß√£o cient√≠fica
let sci2 = 2.5E+3;       // E mai√∫sculo tamb√©m funciona
let no_lead = .5;        // sem zero inicial (0.5)
let sep = 3.14_159_265;  // separadores num√©ricos
```

### Literais de String

```hemlock
let s = "hello";
let escaped = "line1\nline2\ttabbed";
let quote = "She said \"hello\"";

// Sequ√™ncias de escape hexadecimal
let hex_esc = "\x48\x65\x6c\x6c\x6f";  // "Hello"

// Sequ√™ncias de escape Unicode
let emoji = "\u{1F600}";               // üòÄ
let heart = "\u{2764}";                // ‚ù§
let mixed = "Hello \u{1F30D}!";        // Hello üåç!
```

**Sequ√™ncias de Escape:**
- `\n` - nova linha
- `\t` - tabula√ß√£o
- `\r` - retorno de carro
- `\\` - barra invertida
- `\"` - aspas duplas
- `\'` - aspas simples
- `\0` - caractere nulo
- `\xNN` - escape hexadecimal (2 d√≠gitos)
- `\u{XXXX}` - escape Unicode (1-6 d√≠gitos)

### Literais Rune

```hemlock
let ch = 'A';
let emoji = 'üöÄ';
let escaped = '\n';
let unicode = '\u{1F680}';
let hex_rune = '\x41';      // 'A'
```

### Literais Booleanos

```hemlock
let t = true;
let f = false;
```

### Literal Null

```hemlock
let nothing = null;
```

## Regras de Escopo

### Escopo de Bloco

O escopo de uma vari√°vel √© o bloco mais pr√≥ximo que a cont√©m:

```hemlock
let x = 1;  // escopo externo

if (true) {
    let x = 2;  // escopo interno (oculta o externo)
    print(x);   // 2
}

print(x);  // 1
```

### Escopo de Fun√ß√£o

Fun√ß√µes criam seu pr√≥prio escopo:

```hemlock
let global = "global";

fn foo() {
    let local = "local";
    print(global);  // pode ler escopo externo
}

foo();
// print(local);  // Erro: 'local' n√£o est√° definido aqui
```

### Escopo de Closure

Closures capturam vari√°veis do escopo envolvente:

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;  // captura 'count'
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
```

## Espa√ßos em Branco e Formata√ß√£o

### Indenta√ß√£o

Hemlock n√£o imp√µe indenta√ß√£o espec√≠fica, mas 4 espa√ßos s√£o recomendados:

```hemlock
fn example() {
    if (true) {
        print("indented");
    }
}
```

### Quebras de Linha

Instru√ß√µes podem abranger m√∫ltiplas linhas:

```hemlock
let result =
    very_long_function_name(
        arg1,
        arg2,
        arg3
    );
```

## Instru√ß√£o Loop

A palavra-chave `loop` fornece sintaxe mais clara para la√ßos infinitos:

```hemlock
loop {
    // ... executar trabalho
    if (done) {
        break;
    }
}
```

Isso √© equivalente a `while (true)`, mas a inten√ß√£o √© mais clara.

## Palavras-chave Reservadas

As seguintes palavras-chave s√£o reservadas em Hemlock:

```
let, const, fn, if, else, while, for, in, loop, break, continue,
return, true, false, null, typeof, import, export, from,
try, catch, finally, throw, panic, async, await, spawn, join,
detach, channel, define, switch, case, default, extern, self,
type, defer, enum, ref, buffer, Self
```

## Pr√≥ximos Passos

- [Sistema de Tipos](#language-guide-types) - Aprenda sobre o sistema de tipos do Hemlock
- [Fluxo de Controle](#language-guide-control-flow) - Aprofunde-se nas estruturas de controle
- [Fun√ß√µes](#language-guide-functions) - Domine fun√ß√µes e closures
- [Gerenciamento de Mem√≥ria](#language-guide-memory) - Entenda ponteiros e buffers


--------------------------------------------------------------------------------
## Strings
--------------------------------------------------------------------------------

# Strings

Strings em Hemlock s√£o **sequ√™ncias mut√°veis com prioridade UTF-8**, com suporte completo a Unicode e m√©todos ricos para processamento de texto. Diferente de muitas linguagens, strings em Hemlock s√£o mut√°veis e suportam nativamente opera√ß√µes com pontos de c√≥digo Unicode.

## Vis√£o Geral

```hemlock
let s = "hello";
s[0] = 'H';             // Modifica usando rune (agora √© "Hello")
print(s.length);        // 5 (contagem de codepoints)
let c = s[0];           // Retorna rune (ponto de c√≥digo Unicode)
let msg = s + " world"; // Concatena√ß√£o
let emoji = "üöÄ";
print(emoji.length);    // 1 (um codepoint)
print(emoji.byte_length); // 4 (quatro bytes UTF-8)
```

## Propriedades

Strings em Hemlock t√™m as seguintes caracter√≠sticas principais:

- **Codifica√ß√£o UTF-8** - Suporte completo a Unicode (U+0000 a U+10FFFF)
- **Mut√°veis** - Diferente de Python, JavaScript e Java
- **Indexa√ß√£o baseada em codepoint** - Retorna `rune` (ponto de c√≥digo Unicode), n√£o bytes
- **Aloca√ß√£o no heap** - Com rastreamento interno de capacidade
- **Duas propriedades de comprimento**:
  - `.length` - Contagem de codepoints (caracteres)
  - `.byte_length` - Contagem de bytes (tamanho da codifica√ß√£o UTF-8)

## Comportamento UTF-8

Todas as opera√ß√µes de string usam **codepoints** (caracteres), n√£o bytes:

```hemlock
let text = "HelloüöÄWorld";
print(text.length);        // 11 (codepoints)
print(text.byte_length);   // 15 (bytes, emoji s√£o 4 bytes)

// Indexa√ß√£o usa codepoints
let h = text[0];           // 'H' (rune)
let rocket = text[5];      // 'üöÄ' (rune)
```

**Caracteres multibyte contam como um:**
```hemlock
"Hello".length;      // 5
"üöÄ".length;         // 1 (um emoji)
"‰Ω†Â•Ω".length;       // 2 (dois caracteres chineses)
"caf√©".length;       // 4 (√© √© um codepoint)
```

## Literais de String

```hemlock
// Strings b√°sicas
let s1 = "hello";
let s2 = "world";

// Com sequ√™ncias de escape
let s3 = "Line 1\nLine 2\ttabbed";
let s4 = "Quote: \"Hello\"";
let s5 = "Backslash: \\";

// Caracteres Unicode
let s6 = "üöÄ Emoji";
let s7 = "‰∏≠ÊñáÂ≠óÁ¨¶";
```

## Template Strings (Interpola√ß√£o de Strings)

Use crases para criar template strings com express√µes embutidas:

```hemlock
let name = "Alice";
let age = 30;

// Interpola√ß√£o b√°sica
let greeting = `Hello, ${name}!`;           // "Hello, Alice!"
let info = `${name} is ${age} years old`;   // "Alice is 30 years old"

// Express√µes na interpola√ß√£o
let x = 5;
let y = 10;
let sum = `${x} + ${y} = ${x + y}`;         // "5 + 10 = 15"

// Chamadas de m√©todo
let upper = `Name: ${name.to_upper()}`;     // "Name: ALICE"

// Objetos aninhados
let person = { name: "Bob", city: "NYC" };
let desc = `${person.name} lives in ${person.city}`;  // "Bob lives in NYC"

// M√∫ltiplas linhas (preserva quebras)
let multi = `Line 1
Line 2
Line 3`;
```

**Caracter√≠sticas de template strings:**
- Express√µes dentro de `${...}` s√£o avaliadas e convertidas para string
- Pode usar qualquer express√£o v√°lida (vari√°veis, chamadas de fun√ß√£o, aritm√©tica)
- Strings com crases suportam as mesmas sequ√™ncias de escape que strings normais
- Usa-se para construir strings din√¢micas sem concatena√ß√£o

### Escape em Template Strings

Para incluir `${` literal em uma template string, escape o cifr√£o:

```hemlock
let price = 100;
let text = `Price: \${price} or ${price}`;
// "Price: ${price} or 100"

// Crase literal
let code = `Use \` for template strings`;
// "Use ` for template strings"
```

### Express√µes Complexas

Template strings podem conter qualquer express√£o v√°lida:

```hemlock
// Tipo tern√°rio
let age = 25;
let status = `Status: ${age >= 18 ? "adult" : "minor"}`;

// Acesso a array
let items = ["apple", "banana", "cherry"];
let first = `First item: ${items[0]}`;

// Chamada de fun√ß√£o com par√¢metros
fn format_price(p) { return "$" + p; }
let msg = `Total: ${format_price(99.99)}`;  // "Total: $99.99"

// M√©todos encadeados
let name = "alice";
let formatted = `Hello, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;
// "Hello, Alice!"
```

### Template Strings vs Concatena√ß√£o

Template strings geralmente s√£o mais claras que concatena√ß√£o:

```hemlock
// Concatena√ß√£o (mais dif√≠cil de ler)
let msg1 = "Hello, " + name + "! You have " + count + " messages.";

// Template string (mais f√°cil de ler)
let msg2 = `Hello, ${name}! You have ${count} messages.`;
```

## Indexa√ß√£o e Modifica√ß√£o

### Lendo Caracteres

Indexa√ß√£o retorna `rune` (ponto de c√≥digo Unicode):

```hemlock
let s = "Hello";
let first = s[0];      // 'H' (rune)
let last = s[4];       // 'o' (rune)

// Exemplo UTF-8
let emoji = "HiüöÄ!";
let rocket = emoji[2];  // 'üöÄ' (rune no √≠ndice de codepoint 2)
```

### Escrevendo Caracteres

Strings s√£o mut√°veis - pode modificar caracteres individuais:

```hemlock
let s = "hello";
s[0] = 'H';            // Agora √© "Hello"
s[4] = '!';            // Agora √© "Hell!"

// Exemplo Unicode
let msg = "Go!";
msg[0] = 'üöÄ';         // Agora √© "üöÄo!"
```

## Concatena√ß√£o

Use `+` para concatenar strings:

```hemlock
let greeting = "Hello" + " " + "World";  // "Hello World"

// Com vari√°veis
let name = "Alice";
let msg = "Hi, " + name + "!";  // "Hi, Alice!"

// Com rune (veja documenta√ß√£o de Runas)
let s = "Hello" + '!';          // "Hello!"
```

## M√©todos de String

Hemlock fornece 19 m√©todos de string para manipula√ß√£o abrangente de texto.

### Substrings e Fatiamento

**`substr(start, length)`** - Extrai substring por posi√ß√£o e comprimento:
```hemlock
let s = "hello world";
let sub = s.substr(6, 5);       // "world" (de 6, comprimento 5)
let first = s.substr(0, 5);     // "hello"

// Exemplo UTF-8
let text = "HiüöÄ!";
let emoji = text.substr(2, 1);  // "üöÄ" (posi√ß√£o 2, comprimento 1)
```

**`slice(start, end)`** - Extrai substring por intervalo (end n√£o inclu√≠do):
```hemlock
let s = "hello world";
let slice = s.slice(0, 5);      // "hello" (√≠ndice 0 a 4)
let slice2 = s.slice(6, 11);    // "world"
```

**Diferen√ßa:**
- `substr(start, length)` - Usa par√¢metro de comprimento
- `slice(start, end)` - Usa √≠ndice final (n√£o inclu√≠do)

### Busca e Localiza√ß√£o

**`find(needle)`** - Encontra primeira ocorr√™ncia:
```hemlock
let s = "hello world";
let pos = s.find("world");      // 6 (√≠ndice da primeira ocorr√™ncia)
let pos2 = s.find("foo");       // -1 (n√£o encontrado)
let pos3 = s.find("l");         // 2 (primeiro 'l')
```

**`contains(needle)`** - Verifica se string cont√©m substring:
```hemlock
let s = "hello world";
let has = s.contains("world");  // true
let has2 = s.contains("foo");   // false
```

### Divis√£o e Aparagem

**`split(delimiter)`** - Divide em array de strings:
```hemlock
let csv = "apple,banana,cherry";
let parts = csv.split(",");     // ["apple", "banana", "cherry"]

let words = "one two three".split(" ");  // ["one", "two", "three"]

// Delimitador vazio divide por caractere
let chars = "abc".split("");    // ["a", "b", "c"]
```

**`trim()`** - Remove espa√ßos em branco do in√≠cio e fim:
```hemlock
let s = "  hello  ";
let clean = s.trim();           // "hello"

let s2 = "\t\ntext\n\t";
let clean2 = s2.trim();         // "text"
```

### Convers√£o de Caso

**`to_upper()`** - Converte para mai√∫sculas:
```hemlock
let s = "hello world";
let upper = s.to_upper();       // "HELLO WORLD"

// Preserva caracteres n√£o-ASCII
let s2 = "caf√©";
let upper2 = s2.to_upper();     // "CAF√â"
```

**`to_lower()`** - Converte para min√∫sculas:
```hemlock
let s = "HELLO WORLD";
let lower = s.to_lower();       // "hello world"
```

### Verifica√ß√£o de Prefixo/Sufixo

**`starts_with(prefix)`** - Verifica se come√ßa com prefixo:
```hemlock
let s = "hello world";
let starts = s.starts_with("hello");  // true
let starts2 = s.starts_with("world"); // false
```

**`ends_with(suffix)`** - Verifica se termina com sufixo:
```hemlock
let s = "hello world";
let ends = s.ends_with("world");      // true
let ends2 = s.ends_with("hello");     // false
```

### Substitui√ß√£o

**`replace(old, new)`** - Substitui primeira ocorr√™ncia:
```hemlock
let s = "hello world";
let s2 = s.replace("world", "there");      // "hello there"

let s3 = "foo foo foo";
let s4 = s3.replace("foo", "bar");         // "bar foo foo" (apenas primeiro)
```

**`replace_all(old, new)`** - Substitui todas as ocorr√™ncias:
```hemlock
let s = "foo foo foo";
let s2 = s.replace_all("foo", "bar");      // "bar bar bar"

let s3 = "hello world, world!";
let s4 = s3.replace_all("world", "hemlock"); // "hello hemlock, hemlock!"
```

### Repeti√ß√£o

**`repeat(count)`** - Repete string n vezes:
```hemlock
let s = "ha";
let laugh = s.repeat(3);        // "hahaha"

let line = "=".repeat(40);      // "========================================"
```

### Acesso a Caracteres e Bytes

**`char_at(index)`** - Obt√©m ponto de c√≥digo Unicode no √≠ndice (retorna rune):
```hemlock
let s = "hello";
let char = s.char_at(0);        // 'h' (rune)

// Exemplo UTF-8
let emoji = "üöÄ";
let rocket = emoji.char_at(0);  // Retorna rune U+1F680
```

**`chars()`** - Converte para array de runes (codepoints):
```hemlock
let s = "hello";
let chars = s.chars();          // ['h', 'e', 'l', 'l', 'o'] (array de runes)

// Exemplo UTF-8
let text = "HiüöÄ";
let chars2 = text.chars();      // ['H', 'i', 'üöÄ']
```

**`byte_at(index)`** - Obt√©m valor de byte no √≠ndice (retorna u8):
```hemlock
let s = "hello";
let byte = s.byte_at(0);        // 104 (valor ASCII de 'h')

// Exemplo UTF-8
let emoji = "üöÄ";
let first_byte = emoji.byte_at(0);  // 240 (primeiro byte UTF-8)
```

**`bytes()`** - Converte para array de bytes (valores u8):
```hemlock
let s = "hello";
let bytes = s.bytes();          // [104, 101, 108, 108, 111] (array u8)

// Exemplo UTF-8
let emoji = "üöÄ";
let bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 bytes UTF-8)
```

**`to_bytes()`** - Converte para buffer para acesso de baixo n√≠vel:
```hemlock
let s = "hello";
let buf = s.to_bytes();         // Retorna buffer contendo bytes UTF-8
print(buf.length);              // 5
free(buf);                      // Lembre-se de liberar
```

## Encadeamento de M√©todos

Todos os m√©todos de string retornam novas strings, suportando encadeamento:

```hemlock
let result = "  Hello World  "
    .trim()
    .to_lower()
    .replace("world", "hemlock");  // "hello hemlock"

let processed = "foo,bar,baz"
    .split(",")
    .join(" | ")
    .to_upper();                    // "FOO | BAR | BAZ"
```

## Refer√™ncia Completa de M√©todos

| M√©todo | Par√¢metros | Retorno | Descri√ß√£o |
|--------|-----------|---------|-------------|
| `substr(start, length)` | i32, i32 | string | Extrai substring por posi√ß√£o e comprimento |
| `slice(start, end)` | i32, i32 | string | Extrai substring por intervalo (end n√£o inclu√≠do) |
| `find(needle)` | string | i32 | Encontra primeira ocorr√™ncia (retorna -1 se n√£o encontrado) |
| `contains(needle)` | string | bool | Verifica se cont√©m substring |
| `split(delimiter)` | string | array | Divide em array de strings |
| `trim()` | - | string | Remove espa√ßos em branco do in√≠cio e fim |
| `to_upper()` | - | string | Converte para mai√∫sculas |
| `to_lower()` | - | string | Converte para min√∫sculas |
| `starts_with(prefix)` | string | bool | Verifica se come√ßa com prefixo |
| `ends_with(suffix)` | string | bool | Verifica se termina com sufixo |
| `replace(old, new)` | string, string | string | Substitui primeira ocorr√™ncia |
| `replace_all(old, new)` | string, string | string | Substitui todas as ocorr√™ncias |
| `repeat(count)` | i32 | string | Repete string n vezes |
| `char_at(index)` | i32 | rune | Obt√©m codepoint no √≠ndice |
| `byte_at(index)` | i32 | u8 | Obt√©m valor de byte no √≠ndice |
| `chars()` | - | array | Converte para array de runes |
| `bytes()` | - | array | Converte para array de bytes u8 |
| `to_bytes()` | - | buffer | Converte para buffer (precisa liberar) |

## Exemplos

### Exemplo: Processamento de Texto

```hemlock
fn process_input(text: string): string {
    return text
        .trim()
        .to_lower()
        .replace_all("  ", " ");  // Normaliza espa√ßos em branco
}

let input = "  HELLO   WORLD  ";
let clean = process_input(input);  // "hello world"
```

### Exemplo: Parser CSV

```hemlock
fn parse_csv_line(line: string): array {
    let trimmed = line.trim();
    let fields = trimmed.split(",");

    let result = [];
    let i = 0;
    while (i < fields.length) {
        result.push(fields[i].trim());
        i = i + 1;
    }

    return result;
}

let csv = "apple, banana , cherry";
let fields = parse_csv_line(csv);  // ["apple", "banana", "cherry"]
```

### Exemplo: Contador de Palavras

```hemlock
fn count_words(text: string): i32 {
    let words = text.trim().split(" ");
    return words.length;
}

let sentence = "The quick brown fox";
let count = count_words(sentence);  // 4
```

### Exemplo: Valida√ß√£o de String

```hemlock
fn is_valid_email(email: string): bool {
    if (!email.contains("@")) {
        return false;
    }

    if (!email.contains(".")) {
        return false;
    }

    if (email.starts_with("@") || email.ends_with("@")) {
        return false;
    }

    return true;
}

print(is_valid_email("user@example.com"));  // true
print(is_valid_email("invalid"));            // false
```

## Gerenciamento de Mem√≥ria

Strings s√£o alocadas no heap com contagem de refer√™ncia interna:

- **Cria√ß√£o**: Aloca no heap com rastreamento de capacidade
- **Concatena√ß√£o**: Cria nova string (strings antigas inalteradas)
- **M√©todos**: A maioria dos m√©todos retorna novas strings
- **Ciclo de vida**: Strings usam contagem de refer√™ncia, liberadas automaticamente ao sair do escopo

**Limpeza autom√°tica:**
```hemlock
fn create_strings() {
    let s = "hello";
    let s2 = s + " world";  // Nova aloca√ß√£o
}  // s e s2 liberadas automaticamente quando fun√ß√£o retorna
```

**Nota:** Vari√°veis de string locais s√£o limpas automaticamente ao sair do escopo. Use `free()` apenas quando precisar de limpeza antecipada (antes do fim do escopo) ou ao lidar com dados de longa dura√ß√£o/globais. Veja [Gerenciamento de Mem√≥ria](memory.md#internal-reference-counting) para detalhes.

## Melhores Pr√°ticas

1. **Use indexa√ß√£o por codepoint** - Strings usam posi√ß√µes de codepoint, n√£o offsets de byte
2. **Teste com Unicode** - Sempre teste opera√ß√µes de string com caracteres multibyte
3. **Prefira opera√ß√µes imut√°veis** - Use m√©todos que retornam novas strings em vez de modificar diretamente
4. **Verifique limites** - Indexa√ß√£o de string n√£o verifica limites (retorna null/erro se inv√°lido)
5. **Normalize entrada** - Use `trim()` e `to_lower()` para entrada de usu√°rio

## Armadilhas Comuns

### Armadilha: Confus√£o entre Bytes e Codepoints

```hemlock
let emoji = "üöÄ";
print(emoji.length);        // 1 (codepoints)
print(emoji.byte_length);   // 4 (bytes)

// N√£o misture opera√ß√µes de byte e codepoint
let byte = emoji.byte_at(0);  // 240 (primeiro byte)
let char = emoji.char_at(0);  // 'üöÄ' (codepoint completo)
```

### Armadilha: Surpresas de Modifica√ß√£o

```hemlock
let s1 = "hello";
let s2 = s1;       // C√≥pia rasa
s1[0] = 'H';       // Modifica s1
print(s2);         // Ainda √© "hello" (strings s√£o tipo valor)
```

## T√≥picos Relacionados

- [Runas](#language-guide-runes) - Tipo de ponto de c√≥digo Unicode usado em indexa√ß√£o de string
- [Arrays](#language-guide-arrays) - M√©todos de string frequentemente retornam ou usam arrays
- [Tipos](#language-guide-types) - Detalhes e convers√µes do tipo string

## Veja Tamb√©m

- **Codifica√ß√£o UTF-8**: Veja se√ß√£o "Strings" em CLAUDE.md
- **Convers√£o de tipos**: Veja [Tipos](#language-guide-types) para convers√£o de strings
- **Mem√≥ria**: Veja [Mem√≥ria](#language-guide-memory) para detalhes de aloca√ß√£o de strings


--------------------------------------------------------------------------------
## Tipos
--------------------------------------------------------------------------------

# Sistema de Tipos

Hemlock possui um **sistema de tipos din√¢mico** com anota√ß√µes de tipo opcionais e verifica√ß√£o de tipo em tempo de execu√ß√£o.

---

## Guia de Escolha de Tipos: Qual tipo devo usar?

**Novo em tipos?** Comece aqui. Se voc√™ est√° familiarizado com sistemas de tipos, pule para [Filosofia de Design](#filosofia-de-design).

### Resposta Curta

**Deixe o Hemlock decidir automaticamente:**

```hemlock
let count = 42;        // Hemlock sabe que √© um inteiro
let price = 19.99;     // Hemlock sabe que √© um decimal
let name = "Alice";    // Hemlock sabe que √© texto
let active = true;     // Hemlock sabe que √© booleano
```

Hemlock escolher√° automaticamente o tipo correto para seus valores. Voc√™ *n√£o precisa* especificar tipos.

### Quando Adicionar Anota√ß√µes de Tipo

Adicione tipos quando:

1. **Precisa especificar tamanho** - `i8` vs `i64` √© importante para mem√≥ria ou FFI
2. **Documentar c√≥digo** - Tipos mostram o que a fun√ß√£o espera
3. **Detectar erros cedo** - Hemlock verifica tipos em tempo de execu√ß√£o

```hemlock
// Sem tipos (funciona normalmente):
fn add(a, b) {
    return a + b;
}

// Com tipos (mais expl√≠cito):
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Refer√™ncia R√°pida: Escolhendo Tipos Num√©ricos

| O que armazenar | Tipo recomendado | Exemplo |
|---------|---------|------|
| Inteiros comuns | `i32` (padr√£o) | `let count = 42;` |
| N√∫meros muito grandes | `i64` | `let population = 8000000000;` |
| Contagens nunca negativas | `u32` | `let items: u32 = 100;` |
| Bytes (0-255) | `u8` | `let pixel: u8 = 255;` |
| Decimais/fra√ß√µes | `f64` (padr√£o) | `let price = 19.99;` |
| Decimais cr√≠ticos para performance | `f32` | `let x: f32 = 1.5;` |

### Refer√™ncia R√°pida: Todos os Tipos

| Categoria | Tipo | Quando usar |
|-----|------|---------|
| **Inteiros** | `i8`, `i16`, `i32`, `i64` | Contagens, IDs, idades etc. |
| **Apenas positivos** | `u8`, `u16`, `u32`, `u64` | Bytes, tamanhos, comprimentos de array |
| **Decimais** | `f32`, `f64` | Valores monet√°rios, medidas, c√°lculos matem√°ticos |
| **Sim/N√£o** | `bool` | Flags, condi√ß√µes |
| **Texto** | `string` | Nomes, mensagens, qualquer texto |
| **Caractere √∫nico** | `rune` | Letras individuais, emojis |
| **Listas** | `array` | Cole√ß√µes de valores |
| **Campos nomeados** | `object` | Agrupar dados relacionados |
| **Mem√≥ria bruta** | `ptr`, `buffer` | Programa√ß√£o de baixo n√≠vel |
| **Valor vazio** | `null` | Representar aus√™ncia de valor |

### Cen√°rios Comuns

**"S√≥ preciso de um n√∫mero"**
```hemlock
let x = 42;  // Pronto! Hemlock escolhe i32
```

**"Preciso de decimais"**
```hemlock
let price = 19.99;  // Pronto! Hemlock escolhe f64
```

**"Estou trabalhando com bytes (arquivos, rede)"**
```hemlock
let byte: u8 = 255;  // Faixa 0-255
```

**"Preciso de n√∫meros muito grandes"**
```hemlock
let big = 9000000000000;  // Hemlock escolhe i64 automaticamente (> m√°x i32)
// Ou explicitamente:
let big: i64 = 9000000000000;
```

**"Estou armazenando valores monet√°rios"**
```hemlock
// Op√ß√£o 1: Ponto flutuante (simples, mas com limita√ß√µes de precis√£o)
let price: f64 = 19.99;

// Op√ß√£o 2: Armazenar em centavos (mais preciso)
let price_cents: i32 = 1999;  // R$19,99 como centavos inteiros
```

**"Estou passando dados para c√≥digo C (FFI)"**
```hemlock
// Corresponder tipos C exatamente
let c_int: i32 = 100;      // C 'int'
let c_long: i64 = 100;     // C 'long' (sistemas 64-bit)
let c_char: u8 = 65;       // C 'char'
let c_double: f64 = 3.14;  // C 'double'
```

### O que Acontece Quando Tipos se Misturam?

Quando voc√™ combina tipos diferentes, Hemlock promove para o tipo "maior":

```hemlock
let a: i32 = 10;
let b: f64 = 2.5;
let result = a + b;  // result √© f64 (12.5)
// O inteiro se tornou decimal automaticamente
```

**Regra geral:** Ponto flutuante sempre "vence" - qualquer inteiro misturado com ponto flutuante resulta em ponto flutuante.

### Erros de Tipo

Se voc√™ tentar usar o tipo errado, Hemlock informar√° em tempo de execu√ß√£o:

```hemlock
let age: i32 = "thirty";  // Erro: incompatibilidade de tipo - esperava i32, recebeu string
```

Para converter tipos, use construtores de tipo:

```hemlock
let text = "42";
let number = i32(text);   // Analisa string para inteiro: 42
let back = text + "";     // J√° √© string
```

---

## Filosofia de Design

- **Din√¢mico por padr√£o** - Todo valor tem uma tag de tipo em tempo de execu√ß√£o
- **Tipos opcionais** - Anota√ß√µes de tipo opcionais for√ßam verifica√ß√µes em tempo de execu√ß√£o
- **Convers√£o expl√≠cita** - Convers√µes impl√≠citas seguem regras de promo√ß√£o claras
- **Honestidade de tipo** - `typeof()` sempre diz a verdade

## Tipos Primitivos

### Tipos Inteiros

**Inteiros com sinal:**
```hemlock
let tiny: i8 = 127;              // 8 bits (-128 a 127)
let small: i16 = 32767;          // 16 bits (-32768 a 32767)
let normal: i32 = 2147483647;    // 32 bits (padr√£o)
let large: i64 = 9223372036854775807;  // 64 bits
```

**Inteiros sem sinal:**
```hemlock
let byte: u8 = 255;              // 8 bits (0 a 255)
let word: u16 = 65535;           // 16 bits (0 a 65535)
let dword: u32 = 4294967295;     // 32 bits (0 a 4294967295)
let qword: u64 = 18446744073709551615;  // 64 bits
```

**Aliases de tipo:**
```hemlock
let i: integer = 42;   // Alias para i32
let b: byte = 255;     // Alias para u8
```

### Tipos de Ponto Flutuante

```hemlock
let f: f32 = 3.14159;        // Ponto flutuante 32 bits
let d: f64 = 2.718281828;    // Ponto flutuante 64 bits (padr√£o)
let n: number = 1.618;       // Alias para f64
```

### Tipo Booleano

```hemlock
let flag: bool = true;
let active: bool = false;
```

### Tipo String

```hemlock
let text: string = "Hello, World!";
let empty: string = "";
```

Strings s√£o **mut√°veis**, **codificadas em UTF-8** e **alocadas no heap**.

Veja [Strings](#language-guide-strings) para detalhes.

### Tipo Rune

```hemlock
let ch: rune = 'A';
let emoji: rune = 'üöÄ';
let newline: rune = '\n';
let unicode: rune = '\u{1F680}';
```

Runes representam **pontos de c√≥digo Unicode** (U+0000 a U+10FFFF).

Veja [Runas](#language-guide-runes) para detalhes.

### Tipo Null

```hemlock
let nothing = null;
let uninitialized: string = null;
```

`null` √© um tipo distinto com um √∫nico valor.

## Tipos Compostos

### Tipo Array

```hemlock
let numbers: array = [1, 2, 3, 4, 5];
let mixed = [1, "two", true, null];  // Tipos mistos permitidos
let empty: array = [];
```

Veja [Arrays](#language-guide-arrays) para detalhes.

### Tipo Object

```hemlock
let obj: object = { x: 10, y: 20 };
let person = { name: "Alice", age: 30 };
```

Veja [Objetos](#language-guide-objects) para detalhes.

### Tipos de Ponteiro

**Ponteiros brutos:**
```hemlock
let p: ptr = alloc(64);
// Sem verifica√ß√£o de limites, gerenciamento de ciclo de vida manual
free(p);
```

**Buffers seguros:**
```hemlock
let buf: buffer = buffer(64);
// Com verifica√ß√£o de limites, rastreia comprimento e capacidade
free(buf);
```

Veja [Gerenciamento de Mem√≥ria](#language-guide-memory) para detalhes.

## Tipos Enum

Enums definem um conjunto de constantes nomeadas:

### Enum B√°sico

```hemlock
enum Color {
    RED,
    GREEN,
    BLUE
}

let c = Color.RED;
print(c);              // 0
print(typeof(c));      // "Color"

// Compara√ß√£o
if (c == Color.RED) {
    print("It's red!");
}

// Usando switch com enum
switch (c) {
    case Color.RED:
        print("Stop");
        break;
    case Color.GREEN:
        print("Go");
        break;
    case Color.BLUE:
        print("Blue?");
        break;
}
```

### Enum com Valores

Enums podem ter valores inteiros expl√≠citos:

```hemlock
enum Status {
    OK = 0,
    ERROR = 1,
    PENDING = 2
}

print(Status.OK);      // 0
print(Status.ERROR);   // 1

enum HttpCode {
    OK = 200,
    NOT_FOUND = 404,
    SERVER_ERROR = 500
}

let code = HttpCode.NOT_FOUND;
print(code);           // 404
```

### Valores Auto-incrementados

Sem valores expl√≠citos, enums auto-incrementam a partir de 0:

```hemlock
enum Priority {
    LOW,       // 0
    MEDIUM,    // 1
    HIGH,      // 2
    CRITICAL   // 3
}

// Pode misturar valores expl√≠citos e autom√°ticos
enum Level {
    DEBUG = 10,
    INFO,      // 11
    WARN,      // 12
    ERROR = 50,
    FATAL      // 51
}
```

### Padr√µes de Uso de Enum

```hemlock
// Como par√¢metro de fun√ß√£o
fn set_priority(p: Priority) {
    if (p == Priority.CRITICAL) {
        print("Urgent!");
    }
}

set_priority(Priority.HIGH);

// Em objetos
define Task {
    name: string,
    priority: Priority
}

let task: Task = {
    name: "Fix bug",
    priority: Priority.HIGH
};
```

## Tipos Especiais

### Tipo File

```hemlock
let f: file = open("data.txt", "r");
f.close();
```

Representa um handle de arquivo aberto.

### Tipo Task

```hemlock
async fn compute(): i32 { return 42; }
let task = spawn(compute);
let result: i32 = join(task);
```

Representa um handle de tarefa ass√≠ncrona.

### Tipo Channel

```hemlock
let ch: channel = channel(10);
ch.send(42);
let value = ch.recv();
```

Representa um canal de comunica√ß√£o entre tarefas.

### Tipo Void

```hemlock
extern fn exit(code: i32): void;
```

Usado para fun√ß√µes que n√£o retornam valores (apenas FFI).

## Infer√™ncia de Tipos

### Infer√™ncia de Literais Inteiros

Hemlock infere o tipo inteiro baseado na faixa de valores:

```hemlock
let a = 42;              // i32 (cabe em 32 bits)
let b = 5000000000;      // i64 (> m√°x i32)
let c = 128;             // i32
let d: u8 = 128;         // u8 (anota√ß√£o expl√≠cita)
```

**Regras:**
- Valores na faixa i32 (-2147483648 a 2147483647): inferido como `i32`
- Valores fora da faixa i32 mas dentro da faixa i64: inferido como `i64`
- Outros tipos (i8, i16, u8, u16, u32, u64) usam anota√ß√£o expl√≠cita

### Infer√™ncia de Literais de Ponto Flutuante

```hemlock
let x = 3.14;        // f64 (padr√£o)
let y: f32 = 3.14;   // f32 (expl√≠cito)
```

### Nota√ß√£o Cient√≠fica

Hemlock suporta nota√ß√£o cient√≠fica para literais num√©ricos:

```hemlock
let a = 1e10;        // 10000000000.0 (f64)
let b = 1e-12;       // 0.000000000001 (f64)
let c = 3.14e2;      // 314.0 (f64)
let d = 2.5e-3;      // 0.0025 (f64)
let e = 1E10;        // N√£o diferencia mai√∫sculas/min√∫sculas
let f = 1e+5;        // Expoente positivo expl√≠cito
```

**Nota:** Qualquer literal usando nota√ß√£o cient√≠fica √© sempre inferido como `f64`.

### Outras Infer√™ncias de Tipo

```hemlock
let s = "hello";     // string
let ch = 'A';        // rune
let flag = true;     // bool
let arr = [1, 2, 3]; // array
let obj = { x: 10 }; // object
let nothing = null;  // null
```

## Anota√ß√µes de Tipo

### Anota√ß√µes de Vari√°vel

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let name: string = "Alice";
```

### Anota√ß√µes de Par√¢metros de Fun√ß√£o

```hemlock
fn greet(name: string, age: i32) {
    print("Hello, " + name + "!");
}
```

### Anota√ß√µes de Tipo de Retorno de Fun√ß√£o

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Anota√ß√µes de Tipo de Objeto (Duck Typing)

```hemlock
define Person {
    name: string,
    age: i32,
}

let p: Person = { name: "Bob", age: 25 };
```

## Verifica√ß√£o de Tipos

### Verifica√ß√£o de Tipo em Tempo de Execu√ß√£o

Anota√ß√µes de tipo s√£o verificadas em **tempo de execu√ß√£o**, n√£o em tempo de compila√ß√£o:

```hemlock
let x: i32 = 42;     // OK
let y: i32 = 3.14;   // Erro em tempo de execu√ß√£o: incompatibilidade de tipo

fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 3);           // OK
add(5, "hello");     // Erro em tempo de execu√ß√£o: incompatibilidade de tipo
```

### Consulta de Tipo

Use `typeof()` para verificar o tipo de um valor:

```hemlock
print(typeof(42));         // "i32"
print(typeof(3.14));       // "f64"
print(typeof("hello"));    // "string"
print(typeof(true));       // "bool"
print(typeof(null));       // "null"
print(typeof([1, 2, 3]));  // "array"
print(typeof({ x: 10 }));  // "object"
```

## Convers√£o de Tipos

### Promo√ß√£o Impl√≠cita de Tipos

Quando tipos s√£o misturados em opera√ß√µes, Hemlock promove para o tipo "maior":

**Hierarquia de promo√ß√£o (do menor para o maior):**
```
i8 ‚Üí i16 ‚Üí i32 ‚Üí u32 ‚Üí i64 ‚Üí u64 ‚Üí f32 ‚Üí f64
      ‚Üë     ‚Üë     ‚Üë
     u8    u16
```

**Ponto flutuante sempre vence:**
```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // result √© f64 (13.5)
```

**Tamanho maior vence:**
```hemlock
let a: i32 = 100;
let b: i64 = 200;
let sum = a + b;     // sum √© i64 (300)
```

**Preserva√ß√£o de precis√£o:** Quando inteiros de 64 bits s√£o misturados com f32, Hemlock promove para f64 para evitar perda de precis√£o (f32 tem apenas 24 bits de mantissa, insuficiente para representar i64/u64):
```hemlock
let big: i64 = 9007199254740993;
let small: f32 = 1.0;
let result = big + small;  // result √© f64, n√£o f32!
```

**Exemplos:**
```hemlock
u8 + i32  ‚Üí i32
i32 + i64 ‚Üí i64
u32 + u64 ‚Üí u64
i32 + f32 ‚Üí f32    // f32 √© suficiente para representar i32
i64 + f32 ‚Üí f64    // Precisa de f64 para manter precis√£o de i64
i64 + f64 ‚Üí f64
i8 + f64  ‚Üí f64
```

### Convers√£o Expl√≠cita de Tipos

**Convers√£o inteiro/ponto flutuante:**
```hemlock
let i: i32 = 42;
let f: f64 = i;      // i32 ‚Üí f64 (42.0)

let x: f64 = 3.14;
let n: i32 = x;      // f64 ‚Üí i32 (3, truncado)
```

**Convers√£o inteiro/rune:**
```hemlock
let code: i32 = 65;
let ch: rune = code;  // i32 ‚Üí rune ('A')

let r: rune = 'Z';
let value: i32 = r;   // rune ‚Üí i32 (90)
```

**Rune para string:**
```hemlock
let ch: rune = 'üöÄ';
let s: string = ch;   // rune ‚Üí string ("üöÄ")
```

**u8 para rune:**
```hemlock
let b: u8 = 65;
let r: rune = b;      // u8 ‚Üí rune ('A')
```

### Construtores de Tipo

Nomes de tipo podem ser usados como fun√ß√µes para converter ou analisar valores:

**Analisar strings para n√∫meros:**
```hemlock
let n = i32("42");       // Analisa string para i32: 42
let f = f64("3.14159");  // Analisa string para f64: 3.14159
let b = bool("true");    // Analisa string para bool: true

// Suporta todos os tipos num√©ricos
let a = i8("-128");      // Analisa para i8
let c = u8("255");       // Analisa para u8
let d = i16("1000");     // Analisa para i16
let e = u16("50000");    // Analisa para u16
let g = i64("9000000000000"); // Analisa para i64
let h = u64("18000000000000"); // Analisa para u64
let j = f32("1.5");      // Analisa para f32
```

**Hexadecimal e negativos:**
```hemlock
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42
let bin = i32("0b1010"); // 10 (bin√°rio)
```

**Aliases de tipo tamb√©m funcionam:**
```hemlock
let x = integer("100");  // Equivalente a i32("100")
let y = number("1.5");   // Equivalente a f64("1.5")
let z = byte("200");     // Equivalente a u8("200")
```

**Convers√£o entre tipos num√©ricos:**
```hemlock
let big = i64(42);           // i32 para i64
let truncated = i32(3.99);   // f64 para i32 (trunca para 3)
let promoted = f64(100);     // i32 para f64 (100.0)
let narrowed = i8(127);      // i32 para i8
```

**Anota√ß√µes de tipo executam coer√ß√£o num√©rica (mas n√£o analisam strings):**
```hemlock
let f: f64 = 100;        // i32 para f64 via anota√ß√£o (OK)
let s: string = 'A';     // Rune para string via anota√ß√£o (OK)
let code: i32 = 'A';     // Rune para i32 via anota√ß√£o (obt√©m codepoint, OK)

// An√°lise de string requer construtor de tipo expl√≠cito:
let n = i32("42");       // Use construtor de tipo para analisar string
// let x: i32 = "42";    // Erro - anota√ß√£o de tipo n√£o analisa strings
```

**Tratamento de erros:**
```hemlock
// Ao usar construtores de tipo, strings inv√°lidas lan√ßam erro
let bad = i32("hello");  // Erro em tempo de execu√ß√£o: n√£o √© poss√≠vel analisar "hello" como i32
let overflow = u8("256"); // Erro em tempo de execu√ß√£o: 256 est√° fora da faixa de u8
```

**An√°lise de booleano:**
```hemlock
let t = bool("true");    // true
let f = bool("false");   // false
let bad = bool("yes");   // Erro em tempo de execu√ß√£o: deve ser "true" ou "false"
```

## Verifica√ß√£o de Faixa

Anota√ß√µes de tipo for√ßam verifica√ß√£o de faixa na atribui√ß√£o:

```hemlock
let x: u8 = 255;    // OK
let y: u8 = 256;    // Erro: fora da faixa de u8

let a: i8 = 127;    // OK
let b: i8 = 128;    // Erro: fora da faixa de i8

let c: i64 = 2147483647;   // OK
let d: u64 = 4294967295;   // OK
let e: u64 = -1;           // Erro: u64 n√£o pode ser negativo
```

## Exemplos de Promo√ß√£o de Tipos

### Misturando Tipos Inteiros

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let sum = a + b;     // i32 (30)

let c: u8 = 100;
let d: u32 = 200;
let total = c + d;   // u32 (300)
```

### Inteiro + Ponto Flutuante

```hemlock
let i: i32 = 5;
let f: f32 = 2.5;
let result = i * f;  // f32 (12.5)
```

### Express√µes Complexas

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let c: f64 = 3.0;

let result = a + b * c;  // f64 (70.0)
// C√°lculo: b * c ‚Üí f64(60.0)
//          a + f64(60.0) ‚Üí f64(70.0)
```

## Duck Typing (Objetos)

Objetos usam **tipagem estrutural** (duck typing):

```hemlock
define Person {
    name: string,
    age: i32,
}

// OK: tem todos os campos obrigat√≥rios
let p1: Person = { name: "Alice", age: 30 };

// OK: campos extras permitidos
let p2: Person = { name: "Bob", age: 25, city: "NYC" };

// Erro: falta campo 'age'
let p3: Person = { name: "Carol" };

// Erro: tipo errado para 'age'
let p4: Person = { name: "Dave", age: "thirty" };
```

**Verifica√ß√£o de tipo ocorre na atribui√ß√£o:**
- Verifica se todos os campos obrigat√≥rios existem
- Verifica se tipos dos campos correspondem
- Permite e preserva campos extras
- Define o nome do tipo do objeto para `typeof()`

## Campos Opcionais

```hemlock
define Config {
    host: string,
    port: i32,
    debug?: false,     // Campo opcional com valor padr√£o
    timeout?: i32,     // Opcional, padr√£o null
}

let cfg1: Config = { host: "localhost", port: 8080 };
print(cfg1.debug);    // false (padr√£o)
print(cfg1.timeout);  // null

let cfg2: Config = { host: "0.0.0.0", port: 80, debug: true };
print(cfg2.debug);    // true (sobrescrito)
```

## Aliases de Tipo

Hemlock suporta aliases de tipo personalizados usando a palavra-chave `type`:

### Aliases de Tipo B√°sicos

```hemlock
// Aliases de tipo simples
type Integer = i32;
type Text = string;

// Usando aliases
let x: Integer = 42;
let msg: Text = "hello";
```

### Aliases de Tipo de Fun√ß√£o

```hemlock
// Aliases de tipo de fun√ß√£o
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// Usando aliases de tipo de fun√ß√£o
let cb: Callback = fn(n) { print(n); };
let isEven: Predicate = fn(n) { return n % 2 == 0; };
```

### Aliases de Tipo Composto

```hemlock
// Combinar m√∫ltiplos defines em um tipo
define HasName { name: string }
define HasAge { age: i32 }

type Person = HasName & HasAge;

let p: Person = { name: "Alice", age: 30 };
```

### Aliases de Tipo Gen√©rico

```hemlock
// Aliases de tipo gen√©rico
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };

// Usando aliases gen√©ricos
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
```

**Nota:** Aliases de tipo s√£o transparentes - `typeof()` retorna o nome do tipo subjacente, n√£o o alias.

## Limita√ß√µes do Sistema de Tipos

Limita√ß√µes atuais:

- **Sem gen√©ricos para fun√ß√µes** - Par√¢metros de tipo de fun√ß√£o ainda n√£o suportados
- **Sem tipos uni√£o** - N√£o √© poss√≠vel expressar "A ou B"
- **Sem tipos anul√°veis** - Todos os tipos podem ser null (use sufixo `?` para nullable expl√≠cito)

**Nota:** O compilador (`hemlockc`) fornece verifica√ß√£o de tipos em tempo de compila√ß√£o. O interpretador apenas realiza verifica√ß√£o de tipos em tempo de execu√ß√£o. Veja a [documenta√ß√£o do compilador](#design-implementation) para detalhes.

## Melhores Pr√°ticas

### Quando Usar Anota√ß√µes de Tipo

**Deve usar anota√ß√µes quando:**
- O tipo preciso importa (ex: `u8` para valores de byte)
- Documentar interfaces de fun√ß√£o
- For√ßar restri√ß√µes (ex: verifica√ß√£o de faixa)

```hemlock
fn hash(data: buffer, length: u32): u64 {
    // implementa√ß√£o
}
```

**N√£o precisa usar anota√ß√µes quando:**
- O tipo √© √≥bvio pelo literal
- Detalhes de implementa√ß√£o interna
- Formalidade desnecess√°ria

```hemlock
// Desnecess√°rio
let x: i32 = 42;

// Melhor
let x = 42;
```

### Padr√µes de Seguran√ßa de Tipos

**Verificar antes de usar:**
```hemlock
if (typeof(value) == "i32") {
    // Pode usar com seguran√ßa como i32
}
```

**Validar argumentos de fun√ß√£o:**
```hemlock
fn divide(a, b) {
    if (typeof(a) != "i32" || typeof(b) != "i32") {
        throw "arguments must be integers";
    }
    if (b == 0) {
        throw "division by zero";
    }
    return a / b;
}
```

**Usar duck typing para flexibilidade:**
```hemlock
define Printable {
    toString: fn,
}

fn print_item(item: Printable) {
    print(item.toString());
}
```

## Pr√≥ximos Passos

- [Strings](#language-guide-strings) - Tipo string UTF-8 e opera√ß√µes
- [Runas](#language-guide-runes) - Tipo de ponto de c√≥digo Unicode
- [Arrays](#language-guide-arrays) - Tipo de array din√¢mico
- [Objetos](#language-guide-objects) - Literais de objeto e duck typing
- [Mem√≥ria](#language-guide-memory) - Tipos ponteiro e buffer


--------------------------------------------------------------------------------
## Tratamento de Erros
--------------------------------------------------------------------------------

# Tratamento de Erros

Hemlock suporta tratamento de erros baseado em exce√ß√µes atrav√©s de `try`, `catch`, `finally`, `throw` e `panic`. Este guia abrange o uso de exce√ß√µes para erros recuper√°veis e panic para erros irrecuper√°veis.

## Visao Geral

```hemlock
// Tratamento b√°sico de erros
try {
    operacao_arriscada();
} catch (e) {
    print("Erro: " + e);
}

// Com opera√ß√£o de limpeza
try {
    process_file();
} catch (e) {
    print("Falhou: " + e);
} finally {
    cleanup();
}

// Lan√ßando erros
fn divide(a, b) {
    if (b == 0) {
        throw "divis√£o por zero";
    }
    return a / b;
}
```

## Try-Catch-Finally

### Sintaxe

**Try/catch b√°sico:**
```hemlock
try {
    // C√≥digo arriscado
} catch (e) {
    // Trata erro, e cont√©m o valor lan√ßado
}
```

**Try/finally:**
```hemlock
try {
    // C√≥digo arriscado
} finally {
    // Sempre executa, mesmo se exce√ß√£o for lan√ßada
}
```

**Try/catch/finally:**
```hemlock
try {
    // C√≥digo arriscado
} catch (e) {
    // Trata erro
} finally {
    // C√≥digo de limpeza
}
```

### Bloco Try

O bloco try executa declara√ß√µes em sequ√™ncia:

```hemlock
try {
    print("Iniciando...");
    operacao_arriscada();
    print("Sucesso!");  // S√≥ executa se n√£o houver exce√ß√£o
}
```

**Comportamento:**
- Executa declara√ß√µes em sequ√™ncia
- Se exce√ß√£o for lan√ßada: pula para `catch` ou `finally`
- Se n√£o houver exce√ß√£o: executa `finally` (se presente) e continua

### Bloco Catch

O bloco catch recebe o valor lan√ßado:

```hemlock
try {
    throw "ops";
} catch (erro) {
    print("Capturado: " + erro);  // erro = "ops"
    // erro s√≥ √© acess√≠vel aqui
}
// erro n√£o √© acess√≠vel aqui
```

**Par√¢metro catch:**
- Recebe o valor lan√ßado (qualquer tipo)
- Escopo limitado ao bloco catch
- Pode ter qualquer nome (comumente `e`, `err` ou `error`)

**O que voc√™ pode fazer no catch:**
```hemlock
try {
    operacao_arriscada();
} catch (e) {
    // Registrar erro
    print("Erro: " + e);

    // Relan√ßar mesmo erro
    throw e;

    // Lan√ßar erro diferente
    throw "erro diferente";

    // Retornar valor padr√£o
    return null;

    // Tratar e continuar
    // (sem relan√ßar)
}
```

### Bloco Finally

O bloco finally **sempre executa**:

```hemlock
try {
    print("1: try");
    throw "erro";
} catch (e) {
    print("2: catch");
} finally {
    print("3: finally");  // Sempre executa
}
print("4: depois");

// Sa√≠da: 1: try, 2: catch, 3: finally, 4: depois
```

**Quando finally executa:**
- Ap√≥s bloco try (se n√£o houver exce√ß√£o)
- Ap√≥s bloco catch (se exce√ß√£o foi capturada)
- Mesmo se try/catch contiver `return`, `break` ou `continue`
- Antes do fluxo de controle sair do try/catch

**Finally com return:**
```hemlock
fn example() {
    try {
        return 1;  // Retorna 1 ap√≥s finally executar
    } finally {
        print("limpeza");  // Executa antes de retornar
    }
}

fn example2() {
    try {
        return 1;
    } finally {
        return 2;  // return do finally sobrescreve - retorna 2
    }
}
```

**Finally com fluxo de controle:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    try {
        if (i == 5) {
            break;  // Break ap√≥s finally executar
        }
    } finally {
        print("limpeza " + typeof(i));
    }
}
```

## Declara√ß√£o Throw

### Throw B√°sico

Lan√ßa qualquer valor como exce√ß√£o:

```hemlock
throw "mensagem de erro";
throw 404;
throw { code: 500, message: "Erro interno" };
throw null;
throw ["erro", "detalhes"];
```

**Processo de execu√ß√£o:**
1. Avalia a express√£o
2. Pula imediatamente para o `catch` mais pr√≥ximo
3. Se n√£o houver `catch`, propaga pela pilha de chamadas

### Lan√ßando Erros

```hemlock
fn validate_age(idade: i32) {
    if (idade < 0) {
        throw "Idade n√£o pode ser negativa";
    }
    if (idade > 150) {
        throw "Idade n√£o √© realista";
    }
}

try {
    validate_age(-5);
} catch (e) {
    print("Erro de valida√ß√£o: " + e);
}
```

### Lan√ßando Objetos de Erro

Crie informa√ß√µes de erro estruturadas:

```hemlock
fn read_file(caminho: string) {
    if (!file_exists(caminho)) {
        throw {
            type: "FileNotFound",
            path: caminho,
            message: "Arquivo n√£o existe"
        };
    }
    // ... ler arquivo
}

try {
    read_file("faltando.txt");
} catch (e) {
    if (e.type == "FileNotFound") {
        print("Arquivo n√£o encontrado: " + e.path);
    }
}
```

### Relan√ßando

Captura e relan√ßa erros:

```hemlock
fn wrapper() {
    try {
        operacao_arriscada();
    } catch (e) {
        print("Registrando erro: " + e);
        throw e;  // Relan√ßa para o chamador
    }
}

try {
    wrapper();
} catch (e) {
    print("Capturado no main: " + e);
}
```

## Exce√ß√µes N√£o Capturadas

Se uma exce√ß√£o propaga at√© o topo da pilha de chamadas sem ser capturada:

```hemlock
fn foo() {
    throw "n√£o capturada!";
}

foo();  // Crash com: Runtime error: n√£o capturada!
```

**Comportamento:**
- Programa termina
- Imprime mensagem de erro no stderr
- Sai com c√≥digo de status n√£o-zero
- Stack trace ser√° adicionado em vers√µes futuras

## Panic - Erros Irrecuper√°veis

### O que √© Panic?

`panic()` √© usado para **erros irrecuper√°veis** que devem terminar o programa imediatamente:

```hemlock
panic();                    // Mensagem padr√£o: "panic!"
panic("mensagem custom");   // Mensagem personalizada
panic(42);                  // Valores n√£o-string ser√£o impressos
```

**Sem√¢ntica:**
- **Sai imediatamente** do programa com c√≥digo de sa√≠da 1
- Imprime mensagem de erro no stderr: `panic: <mensagem>`
- **N√£o pode** ser capturado por try/catch
- Usado para bugs e erros irrecuper√°veis

### Panic vs Throw

```hemlock
// throw - erro recuper√°vel (pode ser capturado)
try {
    throw "erro recuper√°vel";
} catch (e) {
    print("Capturado: " + e);  // Captura com sucesso
}

// panic - erro irrecuper√°vel (n√£o pode ser capturado)
try {
    panic("erro irrecuper√°vel");  // Programa sai imediatamente
} catch (e) {
    print("Isso nunca executa");   // Nunca executa
}
```

### Quando Usar Panic

**Use panic para:**
- **Bugs**: C√≥digo alcan√ßado que n√£o deveria ser
- **Estado inv√°lido**: Estrutura de dados corrompida detectada
- **Erros irrecuper√°veis**: Recurso cr√≠tico indispon√≠vel
- **Falhas de asser√ß√£o**: Quando `assert()` n√£o √© suficiente

**Exemplos:**
```hemlock
// C√≥digo inalcan√ß√°vel
fn process_state(estado: i32) {
    if (estado == 1) {
        return "pronto";
    } else if (estado == 2) {
        return "executando";
    } else if (estado == 3) {
        return "parado";
    } else {
        panic("estado inv√°lido: " + typeof(estado));  // N√£o deveria acontecer
    }
}

// Verifica√ß√£o de recurso cr√≠tico
fn init_system() {
    let config = read_file("config.json");
    if (config == null) {
        panic("config.json n√£o encontrado - n√£o pode iniciar");
    }
    // ...
}

// Invariante de estrutura de dados
fn pop_stack(pilha) {
    if (pilha.length == 0) {
        panic("pop() chamado em pilha vazia");
    }
    return pilha.pop();
}
```

### Quando N√£o Usar Panic

**Use throw para:**
- Valida√ß√£o de entrada do usu√°rio
- Arquivo n√£o encontrado
- Erros de rede
- Condi√ß√µes de erro esperadas

```hemlock
// Ruim: usar panic para erros esperados
fn divide(a, b) {
    if (b == 0) {
        panic("divis√£o por zero");  // Muito severo
    }
    return a / b;
}

// Bom: usar throw para erros esperados
fn divide(a, b) {
    if (b == 0) {
        throw "divis√£o por zero";  // Recuper√°vel
    }
    return a / b;
}
```

## Intera√ß√£o com Fluxo de Controle

### Return em Try/Catch/Finally

```hemlock
fn example() {
    try {
        return 1;  // Retorna 1 ap√≥s finally executar
    } finally {
        print("limpeza");
    }
}

fn example2() {
    try {
        return 1;
    } finally {
        return 2;  // return do finally sobrescreve - retorna 2
    }
}
```

**Regra:** O valor de retorno do bloco finally sobrescreve o retorno do try/catch.

### Break/Continue em Try/Catch/Finally

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    try {
        if (i == 5) { break; }  // Break ap√≥s finally executar
    } finally {
        print("limpeza " + typeof(i));
    }
}
```

**Regra:** break/continue executa ap√≥s o bloco finally.

### Try/Catch Aninhado

```hemlock
try {
    try {
        throw "interno";
    } catch (e) {
        print("Capturado: " + e);  // Imprime: Capturado: interno
        throw "externo";  // Relan√ßa erro diferente
    }
} catch (e) {
    print("Capturado: " + e);  // Imprime: Capturado: externo
}
```

**Regra:** Blocos try/catch aninhados funcionam como esperado, catch interno executa primeiro.

## Padr√µes Comuns

### Padr√£o: Limpeza de Recursos

Sempre use `finally` para limpeza:

```hemlock
fn process_file(filename) {
    let file = null;
    try {
        file = open(filename);
        let content = file.read();
        process(content);
    } catch (e) {
        print("Erro processando arquivo: " + e);
    } finally {
        if (file != null) {
            file.close();  // Fecha mesmo em erro
        }
    }
}
```

### Padr√£o: Encapsulamento de Erro

Encapsula erros de baixo n√≠vel com contexto:

```hemlock
fn load_config(caminho) {
    try {
        let content = read_file(caminho);
        return parse_json(content);
    } catch (e) {
        throw "Falha ao carregar config de " + caminho + ": " + e;
    }
}
```

### Padr√£o: Recupera√ß√£o de Erro

Fornece valor de fallback em caso de erro:

```hemlock
fn safe_divide(a, b) {
    try {
        if (b == 0) {
            throw "divis√£o por zero";
        }
        return a / b;
    } catch (e) {
        print("Erro: " + e);
        return null;  // Valor de fallback
    }
}
```

### Padr√£o: Valida√ß√£o

Use exce√ß√µes para valida√ß√£o:

```hemlock
fn validate_user(usuario) {
    if (usuario.name == null || usuario.name == "") {
        throw "Nome √© obrigat√≥rio";
    }
    if (usuario.age < 0 || usuario.age > 150) {
        throw "Idade inv√°lida";
    }
    if (usuario.email == null || !usuario.email.contains("@")) {
        throw "Email inv√°lido";
    }
}

try {
    validate_user({ name: "Alice", age: -5, email: "inv√°lido" });
} catch (e) {
    print("Valida√ß√£o falhou: " + e);
}
```

### Padr√£o: M√∫ltiplos Tipos de Erro

Use objetos de erro para distinguir tipos de erro:

```hemlock
fn process_data(dados) {
    if (dados == null) {
        throw { type: "NullData", message: "Dados s√£o nulos" };
    }

    if (typeof(dados) != "array") {
        throw { type: "TypeError", message: "Esperado array" };
    }

    if (dados.length == 0) {
        throw { type: "EmptyData", message: "Array est√° vazio" };
    }

    // ... processar
}

try {
    process_data(null);
} catch (e) {
    if (e.type == "NullData") {
        print("Nenhum dado fornecido");
    } else if (e.type == "TypeError") {
        print("Tipo de dados errado: " + e.message);
    } else {
        print("Erro: " + e.message);
    }
}
```

## Melhores Pr√°ticas

1. **Use exce√ß√µes para situa√ß√µes excepcionais** - N√£o use para fluxo de controle normal
2. **Lance erros significativos** - Use strings ou objetos com contexto
3. **Sempre use finally para limpeza** - Garanta que recursos sejam liberados
4. **N√£o capture e ignore** - Pelo menos registre o erro
5. **Relance quando apropriado** - Se voc√™ n√£o pode tratar, deixe o chamador tratar
6. **Use panic para bugs** - Use panic para erros irrecuper√°veis
7. **Documente exce√ß√µes** - Deixe claro quais fun√ß√µes podem lan√ßar exce√ß√µes

## Armadilhas Comuns

### Armadilha: Engolir Erros

```hemlock
// Ruim: falha silenciosa
try {
    operacao_arriscada();
} catch (e) {
    // Erro ignorado - falha silenciosa
}

// Bom: registrar ou tratar
try {
    operacao_arriscada();
} catch (e) {
    print("Opera√ß√£o falhou: " + e);
    // Tratar apropriadamente
}
```

### Armadilha: Sobrescrita do Finally

```hemlock
// Ruim: finally sobrescreve valor de retorno
fn get_value() {
    try {
        return 42;
    } finally {
        return 0;  // Retorna 0, n√£o 42!
    }
}

// Bom: n√£o retorne no finally
fn get_value() {
    try {
        return 42;
    } finally {
        cleanup();  // Apenas limpeza, sem retorno
    }
}
```

### Armadilha: Esquecer Limpeza

```hemlock
// Ruim: arquivo pode n√£o fechar em erro
fn process() {
    let file = open("data.txt");
    let content = file.read();  // Pode lan√ßar
    file.close();  // Nunca alcan√ßado se erro
}

// Bom: usar finally
fn process() {
    let file = null;
    try {
        file = open("data.txt");
        let content = file.read();
    } finally {
        if (file != null) {
            file.close();
        }
    }
}
```

### Armadilha: Usar Panic para Erros Esperados

```hemlock
// Ruim: usar panic para erros esperados
fn read_config(caminho) {
    if (!file_exists(caminho)) {
        panic("Arquivo de config n√£o encontrado");  // Muito severo
    }
    return read_file(caminho);
}

// Bom: usar throw para erros esperados
fn read_config(caminho) {
    if (!file_exists(caminho)) {
        throw "Arquivo de config n√£o encontrado: " + caminho;  // Recuper√°vel
    }
    return read_file(caminho);
}
```

## Exemplos

### Exemplo: Tratamento B√°sico de Erros

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "divis√£o por zero";
    }
    return a / b;
}

try {
    print(divide(10, 0));
} catch (e) {
    print("Erro: " + e);  // Imprime: Erro: divis√£o por zero
}
```

### Exemplo: Gerenciamento de Recursos

```hemlock
fn copy_file(src, dst) {
    let src_file = null;
    let dst_file = null;

    try {
        src_file = open(src, "r");
        dst_file = open(dst, "w");

        let content = src_file.read();
        dst_file.write(content);

        print("Arquivo copiado com sucesso");
    } catch (e) {
        print("Falha ao copiar arquivo: " + e);
        throw e;  // Relan√ßa
    } finally {
        if (src_file != null) { src_file.close(); }
        if (dst_file != null) { dst_file.close(); }
    }
}
```

### Exemplo: Tratamento de Erros Aninhado

```hemlock
fn process_users(usuarios) {
    let success_count = 0;
    let error_count = 0;

    let i = 0;
    while (i < usuarios.length) {
        try {
            validate_user(usuarios[i]);
            save_user(usuarios[i]);
            success_count = success_count + 1;
        } catch (e) {
            print("Falha ao processar usu√°rio: " + e);
            error_count = error_count + 1;
        }
        i = i + 1;
    }

    print("Processados: " + typeof(success_count) + " sucesso, " + typeof(error_count) + " erros");
}
```

### Exemplo: Tipos de Erro Personalizados

```hemlock
fn create_error(tipo, mensagem, detalhes) {
    return {
        type: tipo,
        message: mensagem,
        details: detalhes,
        toString: fn() {
            return self.type + ": " + self.message;
        }
    };
}

fn divide(a, b) {
    if (typeof(a) != "i32" && typeof(a) != "f64") {
        throw create_error("TypeError", "a deve ser um n√∫mero", { value: a });
    }
    if (typeof(b) != "i32" && typeof(b) != "f64") {
        throw create_error("TypeError", "b deve ser um n√∫mero", { value: b });
    }
    if (b == 0) {
        throw create_error("DivisionByZero", "N√£o pode dividir por zero", { a: a, b: b });
    }
    return a / b;
}

try {
    divide(10, 0);
} catch (e) {
    print(e.toString());
    if (e.type == "DivisionByZero") {
        print("Detalhes: a=" + typeof(e.details.a) + ", b=" + typeof(e.details.b));
    }
}
```

### Exemplo: L√≥gica de Retry

```hemlock
fn retry(operacao, max_tentativas) {
    let tentativa = 0;

    while (tentativa < max_tentativas) {
        try {
            return operacao();  // Sucesso!
        } catch (e) {
            tentativa = tentativa + 1;
            if (tentativa >= max_tentativas) {
                throw "Opera√ß√£o falhou ap√≥s " + typeof(max_tentativas) + " tentativas: " + e;
            }
            print("Tentativa " + typeof(tentativa) + " falhou, tentando novamente...");
        }
    }
}

fn operacao_instavel() {
    // Simula opera√ß√£o inst√°vel
    if (random() < 0.7) {
        throw "Opera√ß√£o falhou";
    }
    return "Sucesso";
}

try {
    let resultado = retry(operacao_instavel, 3);
    print(resultado);
} catch (e) {
    print("Todas as tentativas falharam: " + e);
}
```

## Ordem de Execu√ß√£o

Entenda a ordem de execu√ß√£o:

```hemlock
try {
    print("1: in√≠cio do bloco try");
    throw "erro";
    print("2: nunca alcan√ßado");
} catch (e) {
    print("3: bloco catch");
} finally {
    print("4: bloco finally");
}
print("5: depois do try/catch/finally");

// Sa√≠da:
// 1: in√≠cio do bloco try
// 3: bloco catch
// 4: bloco finally
// 5: depois do try/catch/finally
```

## Limita√ß√µes Atuais

- **Sem stack trace** - Exce√ß√µes n√£o capturadas n√£o mostram stack trace (planejado)
- **Algumas fun√ß√µes built-in usam exit** - Algumas fun√ß√µes built-in ainda usam `exit()` em vez de lan√ßar (a ser revisado)
- **Sem tipos de exce√ß√£o customizados** - Qualquer valor pode ser lan√ßado, mas n√£o h√° hierarquia formal de exce√ß√µes

## T√≥picos Relacionados

- [Fun√ß√µes](#language-guide-functions) - Exce√ß√µes e retorno de fun√ß√µes
- [Fluxo de Controle](#language-guide-control-flow) - Como exce√ß√µes afetam fluxo de controle
- [Mem√≥ria](#language-guide-memory) - Limpeza de mem√≥ria com finally

## Veja Tamb√©m

- **Sem√¢ntica de Exce√ß√µes**: Veja se√ß√£o "Tratamento de Erros" em CLAUDE.md
- **Panic vs Throw**: Diferentes casos de uso para diferentes tipos de erro
- **Garantias do Finally**: Sempre executa, mesmo com return/break/continue



################################################################################
# T√ìPICOS AVAN√áADOS
################################################################################

--------------------------------------------------------------------------------
## Argumentos de Linha de Comando
--------------------------------------------------------------------------------

# Hemlock Argumentos de Linha de Comando

Programas Hemlock podem acessar argumentos de linha de comando atrav√©s do **array `args` integrado**, que √© automaticamente preenchido na inicializa√ß√£o do programa.

## √çndice

- [Vis√£o Geral](#vis√£o-geral)
- [Array args](#array-args)
- [Propriedades](#propriedades)
- [Padr√µes de Itera√ß√£o](#padr√µes-de-itera√ß√£o)
- [Casos de Uso Comuns](#casos-de-uso-comuns)
- [Padr√µes de Parse de Argumentos](#padr√µes-de-parse-de-argumentos)
- [Melhores Pr√°ticas](#melhores-pr√°ticas)
- [Exemplos Completos](#exemplos-completos)

## Vis√£o Geral

O array `args` fornece acesso aos argumentos de linha de comando passados para um programa Hemlock:

- **Sempre dispon√≠vel** - vari√°vel global integrada em todos os programas Hemlock
- **Inclui nome do script** - `args[0]` sempre cont√©m o caminho/nome do script
- **Array de strings** - todos os argumentos s√£o strings
- **Indexa√ß√£o base zero** - indexa√ß√£o de array padr√£o (0, 1, 2, ...)

## Array args

### Estrutura B√°sica

```hemlock
// args[0] √© sempre o nome do arquivo do script
// args[1] at√© args[n-1] s√£o os argumentos reais
print(args[0]);        // "script.hml"
print(args.length);    // N√∫mero total de argumentos (incluindo nome do script)
```

### Exemplo de Uso

**Comando:**
```bash
./hemlock script.hml hello world "test 123"
```

**Em script.hml:**
```hemlock
print("Script name: " + args[0]);     // "script.hml"
print("Total args: " + typeof(args.length));  // "4"
print("First arg: " + args[1]);       // "hello"
print("Second arg: " + args[2]);      // "world"
print("Third arg: " + args[3]);       // "test 123"
```

### Refer√™ncia de √çndices

| √çndice | Cont√©m | Valor de Exemplo |
|--------|--------|------------------|
| `args[0]` | Caminho/nome do script | `"script.hml"` ou `"./script.hml"` |
| `args[1]` | Primeiro argumento | `"hello"` |
| `args[2]` | Segundo argumento | `"world"` |
| `args[3]` | Terceiro argumento | `"test 123"` |
| ... | ... | ... |
| `args[n-1]` | √öltimo argumento | (varia) |

## Propriedades

### Sempre Presente

`args` √© um array global dispon√≠vel em **todos** os programas Hemlock:

```hemlock
// N√£o precisa declarar ou importar
print(args.length);  // Dispon√≠vel imediatamente
```

### Inclui Nome do Script

`args[0]` sempre cont√©m o caminho/nome do script:

```hemlock
print("Running: " + args[0]);
```

**Valores poss√≠veis para args[0]:**
- `"script.hml"` - apenas nome do arquivo
- `"./script.hml"` - caminho relativo
- `"/home/user/script.hml"` - caminho absoluto
- Depende de como o script foi invocado

### Tipo: Array de Strings

Todos os argumentos s√£o armazenados como strings:

```hemlock
// Argumentos: ./hemlock script.hml 42 3.14 true

print(args[1]);  // "42" (string, n√£o n√∫mero)
print(args[2]);  // "3.14" (string, n√£o n√∫mero)
print(args[3]);  // "true" (string, n√£o booleano)

// Converter conforme necess√°rio:
let num = 42;  // Parsear manualmente se necess√°rio
```

### Comprimento M√≠nimo

Sempre pelo menos 1 (o nome do script):

```hemlock
print(args.length);  // M√≠nimo: 1
```

**Mesmo sem argumentos:**
```bash
./hemlock script.hml
```

```hemlock
// Em script.hml:
print(args.length);  // 1 (apenas nome do script)
```

### Comportamento no REPL

No REPL, `args.length` √© 0 (array vazio):

```hemlock
# Sess√£o REPL
> print(args.length);
0
```

## Padr√µes de Itera√ß√£o

### Itera√ß√£o B√°sica

Pular `args[0]` (nome do script) e processar argumentos reais:

```hemlock
let i = 1;
while (i < args.length) {
    print("Argument " + typeof(i) + ": " + args[i]);
    i = i + 1;
}
```

**Sa√≠da para `./hemlock script.hml foo bar baz`:**
```
Argument 1: foo
Argument 2: bar
Argument 3: baz
```

### Itera√ß√£o For-In (Inclui Nome do Script)

```hemlock
for (let arg in args) {
    print(arg);
}
```

**Sa√≠da:**
```
script.hml
foo
bar
baz
```

### Verificar N√∫mero de Argumentos

```hemlock
if (args.length < 2) {
    print("Usage: " + args[0] + " <argument>");
    // Sair ou retornar
} else {
    let arg = args[1];
    // Processar arg
}
```

### Processar Todos Exceto Nome do Script

```hemlock
let actual_args = args.slice(1, args.length);

for (let arg in actual_args) {
    print("Processing: " + arg);
}
```

## Casos de Uso Comuns

### 1. Processamento Simples de Argumentos

Verificar argumento obrigat√≥rio:

```hemlock
if (args.length < 2) {
    print("Usage: " + args[0] + " <filename>");
} else {
    let filename = args[1];
    print("Processing file: " + filename);
    // ... processar arquivo
}
```

**Uso:**
```bash
./hemlock script.hml data.txt
# Sa√≠da: Processing file: data.txt
```

### 2. M√∫ltiplos Argumentos

```hemlock
if (args.length < 3) {
    print("Usage: " + args[0] + " <input> <output>");
} else {
    let input_file = args[1];
    let output_file = args[2];

    print("Input: " + input_file);
    print("Output: " + output_file);

    // Processar arquivos...
}
```

**Uso:**
```bash
./hemlock convert.hml input.txt output.txt
```

### 3. N√∫mero Vari√°vel de Argumentos

Processar todos os argumentos fornecidos:

```hemlock
if (args.length < 2) {
    print("Usage: " + args[0] + " <file1> [file2] [file3] ...");
} else {
    print("Processing " + typeof(args.length - 1) + " files:");

    let i = 1;
    while (i < args.length) {
        print("  " + args[i]);
        process_file(args[i]);
        i = i + 1;
    }
}
```

**Uso:**
```bash
./hemlock batch.hml file1.txt file2.txt file3.txt
```

### 4. Mensagem de Ajuda

```hemlock
if (args.length < 2 || args[1] == "--help" || args[1] == "-h") {
    print("Usage: " + args[0] + " [OPTIONS] <file>");
    print("Options:");
    print("  -h, --help     Show this help message");
    print("  -v, --verbose  Enable verbose output");
} else {
    // Processamento normal
}
```

### 5. Valida√ß√£o de Argumentos

```hemlock
fn validate_file(filename: string): bool {
    // Verificar se arquivo existe (exemplo)
    return filename != "";
}

if (args.length < 2) {
    print("Error: No filename provided");
} else if (!validate_file(args[1])) {
    print("Error: Invalid file: " + args[1]);
} else {
    print("Processing: " + args[1]);
}
```

## Padr√µes de Parse de Argumentos

### Argumentos Nomeados (Flags)

Padr√£o simples para argumentos nomeados:

```hemlock
let verbose = false;
let output_file = "";
let input_file = "";

let i = 1;
while (i < args.length) {
    if (args[i] == "--verbose" || args[i] == "-v") {
        verbose = true;
    } else if (args[i] == "--output" || args[i] == "-o") {
        i = i + 1;
        if (i < args.length) {
            output_file = args[i];
        }
    } else {
        input_file = args[i];
    }
    i = i + 1;
}

if (verbose) {
    print("Verbose mode enabled");
}
print("Input: " + input_file);
print("Output: " + output_file);
```

**Uso:**
```bash
./hemlock script.hml --verbose --output out.txt input.txt
./hemlock script.hml -v -o out.txt input.txt
```

### Flags Booleanas

```hemlock
let debug = false;
let verbose = false;
let force = false;

let i = 1;
while (i < args.length) {
    if (args[i] == "--debug") {
        debug = true;
    } else if (args[i] == "--verbose") {
        verbose = true;
    } else if (args[i] == "--force") {
        force = true;
    }
    i = i + 1;
}
```

### Argumentos com Valor

```hemlock
let config_file = "default.conf";
let port = 8080;

let i = 1;
while (i < args.length) {
    if (args[i] == "--config") {
        i = i + 1;
        if (i < args.length) {
            config_file = args[i];
        }
    } else if (args[i] == "--port") {
        i = i + 1;
        if (i < args.length) {
            port = 8080;  // Precisa parsear string para inteiro
        }
    }
    i = i + 1;
}
```

### Misturando Posicionais e Nomeados

```hemlock
let input_file = "";
let output_file = "";
let verbose = false;

let i = 1;
let positional = [];

while (i < args.length) {
    if (args[i] == "--verbose") {
        verbose = true;
    } else {
        // Tratar como argumento posicional
        positional.push(args[i]);
    }
    i = i + 1;
}

// Atribuir argumentos posicionais
if (positional.length > 0) {
    input_file = positional[0];
}
if (positional.length > 1) {
    output_file = positional[1];
}
```

### Fun√ß√£o Auxiliar de Parser de Argumentos

```hemlock
fn parse_args() {
    let options = {
        verbose: false,
        output: "",
        files: []
    };

    let i = 1;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--verbose" || arg == "-v") {
            options.verbose = true;
        } else if (arg == "--output" || arg == "-o") {
            i = i + 1;
            if (i < args.length) {
                options.output = args[i];
            }
        } else {
            // Argumento posicional
            options.files.push(arg);
        }

        i = i + 1;
    }

    return options;
}

let opts = parse_args();
print("Verbose: " + typeof(opts.verbose));
print("Output: " + opts.output);
print("Files: " + typeof(opts.files.length));
```

## Melhores Pr√°ticas

### 1. Sempre Verifique N√∫mero de Argumentos

```hemlock
// Boa pr√°tica
if (args.length < 2) {
    print("Usage: " + args[0] + " <file>");
} else {
    process_file(args[1]);
}

// M√° pr√°tica - pode crashar se n√£o houver argumentos
process_file(args[1]);  // Erro se args.length == 1
```

### 2. Forne√ßa Informa√ß√£o de Uso

```hemlock
fn show_usage() {
    print("Usage: " + args[0] + " [OPTIONS] <file>");
    print("Options:");
    print("  -h, --help     Show help");
    print("  -v, --verbose  Verbose output");
}

if (args.length < 2) {
    show_usage();
}
```

### 3. Valide Argumentos

```hemlock
fn validate_args() {
    if (args.length < 2) {
        print("Error: Missing required argument");
        return false;
    }

    if (args[1] == "") {
        print("Error: Empty argument");
        return false;
    }

    return true;
}

if (!validate_args()) {
    // Sair ou mostrar uso
}
```

### 4. Use Nomes de Vari√°veis Descritivos

```hemlock
// Bom
let input_filename = args[1];
let output_filename = args[2];
let max_iterations = args[3];

// Ruim
let a = args[1];
let b = args[2];
let c = args[3];
```

### 5. Trate Argumentos com Aspas e Espa√ßos

O shell trata isso automaticamente:

```bash
./hemlock script.hml "file with spaces.txt"
```

```hemlock
print(args[1]);  // "file with spaces.txt"
```

### 6. Crie Objeto de Argumentos

```hemlock
fn get_args() {
    return {
        script: args[0],
        input: args[1],
        output: args[2]
    };
}

let arguments = get_args();
print("Input: " + arguments.input);
```

## Exemplos Completos

### Exemplo 1: Processador de Arquivos

```hemlock
// Uso: ./hemlock process.hml <input> <output>

fn show_usage() {
    print("Usage: " + args[0] + " <input_file> <output_file>");
}

if (args.length < 3) {
    show_usage();
} else {
    let input = args[1];
    let output = args[2];

    print("Processing " + input + " -> " + output);

    // Processar arquivo
    let f_in = open(input, "r");
    let f_out = open(output, "w");

    try {
        let content = f_in.read();
        let processed = content.to_upper();  // Processamento de exemplo
        f_out.write(processed);

        print("Done!");
    } finally {
        f_in.close();
        f_out.close();
    }
}
```

### Exemplo 2: Processador de Arquivos em Lote

```hemlock
// Uso: ./hemlock batch.hml <file1> <file2> <file3> ...

if (args.length < 2) {
    print("Usage: " + args[0] + " <file1> [file2] [file3] ...");
} else {
    print("Processing " + typeof(args.length - 1) + " files:");

    let i = 1;
    while (i < args.length) {
        let filename = args[i];
        print("  Processing: " + filename);

        try {
            let f = open(filename, "r");
            let content = f.read();
            f.close();

            // Processar conte√∫do...
            print("    " + typeof(content.length) + " bytes");
        } catch (e) {
            print("    Error: " + e);
        }

        i = i + 1;
    }

    print("Done!");
}
```

### Exemplo 3: Parser de Argumentos Avan√ßado

```hemlock
// Uso: ./hemlock app.hml [OPTIONS] <files...>
// Op√ß√µes:
//   --verbose, -v     Habilitar sa√≠da detalhada
//   --output, -o FILE Definir arquivo de sa√≠da
//   --help, -h        Mostrar ajuda

fn parse_arguments() {
    let config = {
        verbose: false,
        output: "output.txt",
        help: false,
        files: []
    };

    let i = 1;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--verbose" || arg == "-v") {
            config.verbose = true;
        } else if (arg == "--output" || arg == "-o") {
            i = i + 1;
            if (i < args.length) {
                config.output = args[i];
            } else {
                print("Error: --output requires a value");
            }
        } else if (arg == "--help" || arg == "-h") {
            config.help = true;
        } else if (arg.starts_with("--")) {
            print("Error: Unknown option: " + arg);
        } else {
            config.files.push(arg);
        }

        i = i + 1;
    }

    return config;
}

fn show_help() {
    print("Usage: " + args[0] + " [OPTIONS] <files...>");
    print("Options:");
    print("  --verbose, -v     Enable verbose output");
    print("  --output, -o FILE Set output file");
    print("  --help, -h        Show this help");
}

let config = parse_arguments();

if (config.help) {
    show_help();
} else if (config.files.length == 0) {
    print("Error: No input files specified");
    show_help();
} else {
    if (config.verbose) {
        print("Verbose mode enabled");
        print("Output file: " + config.output);
        print("Input files: " + typeof(config.files.length));
    }

    // Processar arquivos
    for (let file in config.files) {
        if (config.verbose) {
            print("Processing: " + file);
        }
        // ... processar arquivo
    }
}
```

### Exemplo 4: Ferramenta de Configura√ß√£o

```hemlock
// Uso: ./hemlock config.hml <action> [arguments]
// A√ß√µes:
//   get <key>
//   set <key> <value>
//   list

fn show_usage() {
    print("Usage: " + args[0] + " <action> [arguments]");
    print("Actions:");
    print("  get <key>         Get configuration value");
    print("  set <key> <value> Set configuration value");
    print("  list              List all configuration");
}

if (args.length < 2) {
    show_usage();
} else {
    let action = args[1];

    if (action == "get") {
        if (args.length < 3) {
            print("Error: 'get' requires a key");
        } else {
            let key = args[2];
            print("Getting: " + key);
            // ... obter da configura√ß√£o
        }
    } else if (action == "set") {
        if (args.length < 4) {
            print("Error: 'set' requires key and value");
        } else {
            let key = args[2];
            let value = args[3];
            print("Setting " + key + " = " + value);
            // ... definir configura√ß√£o
        }
    } else if (action == "list") {
        print("Listing all configuration:");
        // ... listar configura√ß√£o
    } else {
        print("Error: Unknown action: " + action);
        show_usage();
    }
}
```

## Resumo

O suporte a argumentos de linha de comando do Hemlock oferece:

- Array `args` integrado globalmente dispon√≠vel
- Acesso simples baseado em array
- Nome do script em `args[0]`
- Todos os argumentos s√£o strings
- M√©todos de array dispon√≠veis (.length, .slice, etc.)

Lembre-se:
- Sempre verifique `args.length` antes de acessar elementos
- `args[0]` √© o nome do script
- Argumentos reais come√ßam em `args[1]`
- Todos os argumentos s√£o strings - converta conforme necess√°rio
- Forne√ßa informa√ß√£o de uso para ferramentas amig√°veis ao usu√°rio
- Valide argumentos antes de processar

Padr√µes comuns:
- Argumentos posicionais simples
- Argumentos nomeados/flags (--flag)
- Argumentos com valor (--option value)
- Informa√ß√£o de ajuda (--help)
- Valida√ß√£o de argumentos


--------------------------------------------------------------------------------
## Assincronismo e Concorr√™ncia
--------------------------------------------------------------------------------

# Hemlock Assincronismo e Concorr√™ncia

Hemlock oferece **concorr√™ncia estruturada**, com suporte a sintaxe async/await, cria√ß√£o de tarefas e comunica√ß√£o por canais. A implementa√ß√£o √© baseada em threads POSIX (pthreads), proporcionando **verdadeiro paralelismo multi-thread**.

## √çndice

- [Vis√£o Geral](#vis√£o-geral)
- [Modelo de Threads](#modelo-de-threads)
- [Fun√ß√µes Ass√≠ncronas](#fun√ß√µes-ass√≠ncronas)
- [Cria√ß√£o de Tarefas](#cria√ß√£o-de-tarefas)
- [Canais](#canais)
- [Propaga√ß√£o de Exce√ß√µes](#propaga√ß√£o-de-exce√ß√µes)
- [Detalhes de Implementa√ß√£o](#detalhes-de-implementa√ß√£o)
- [Melhores Pr√°ticas](#melhores-pr√°ticas)
- [Caracter√≠sticas de Desempenho](#caracter√≠sticas-de-desempenho)
- [Limita√ß√µes Atuais](#limita√ß√µes-atuais)

## Vis√£o Geral

**Isso significa:**
- Threads reais do sistema operacional - cada tarefa criada executa em seu pr√≥prio pthread (thread POSIX)
- Paralelismo real - tarefas executam simultaneamente em m√∫ltiplos n√∫cleos de CPU
- Escalonamento do kernel - o escalonador do SO distribui tarefas entre os n√∫cleos dispon√≠veis
- Canais thread-safe - sincroniza√ß√£o usando mutexes e vari√°veis de condi√ß√£o pthread

**Isso n√£o √©:**
- N√£o s√£o green threads - n√£o √© multitarefa cooperativa em espa√ßo de usu√°rio
- N√£o s√£o coroutines async/await - n√£o √© um event loop single-thread como JavaScript/Python asyncio
- N√£o √© concorr√™ncia simulada - n√£o √© paralelismo simulado

Isso √© o **mesmo modelo de threads** que **C, C++ e Rust** usam com threads do SO. Voc√™ obt√©m execu√ß√£o paralela real em m√∫ltiplos n√∫cleos.

## Modelo de Threads

### Modelo de Threads 1:1

Hemlock usa um **modelo de threads 1:1**, onde:
- Cada tarefa criada gera uma thread dedicada do SO via `pthread_create()`
- O kernel do SO escalona threads entre os n√∫cleos de CPU dispon√≠veis
- Multitarefa preemptiva - o SO pode interromper e alternar entre threads
- **Sem GIL** - diferente de Python, n√£o h√° Global Interpreter Lock limitando o paralelismo

### Mecanismos de Sincroniza√ß√£o

- **Mutexes** - canais usam `pthread_mutex_t` para acesso thread-safe
- **Vari√°veis de Condi√ß√£o** - send/recv bloqueantes usam `pthread_cond_t` para espera eficiente
- **Opera√ß√µes Lock-free** - transi√ß√µes de estado de tarefas s√£o at√¥micas

## Fun√ß√µes Ass√≠ncronas

Fun√ß√µes podem ser declaradas como `async`, indicando que foram projetadas para execu√ß√£o concorrente:

```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}
```

### Pontos Importantes

- `async fn` declara uma fun√ß√£o ass√≠ncrona
- Fun√ß√µes ass√≠ncronas podem ser criadas como tarefas concorrentes usando `spawn()`
- Fun√ß√µes ass√≠ncronas tamb√©m podem ser chamadas diretamente (executando sincronamente na thread atual)
- Quando criadas, cada tarefa executa em **sua pr√≥pria thread do SO** (n√£o s√£o coroutines!)
- A palavra-chave `await` est√° reservada para uso futuro

### Exemplo: Chamada Direta vs Cria√ß√£o de Tarefa

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Chamada direta - executa sincronamente
let result1 = factorial(5);  // 120

// Criar tarefa - executa em thread separada
let task = spawn(factorial, 5);
let result2 = join(task);  // 120
```

## Cria√ß√£o de Tarefas

Use `spawn()` para executar fun√ß√µes ass√≠ncronas **em paralelo em threads separadas do SO**:

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Criar m√∫ltiplas tarefas - estas executam em paralelo em diferentes n√∫cleos de CPU!
let t1 = spawn(factorial, 5);  // Thread 1
let t2 = spawn(factorial, 6);  // Thread 2
let t3 = spawn(factorial, 7);  // Thread 3

// As tr√™s tarefas est√£o computando simultaneamente agora!

// Aguardar resultados
let f5 = join(t1);  // 120
let f6 = join(t2);  // 720
let f7 = join(t3);  // 5040
```

### Fun√ß√µes Integradas

#### spawn(async_fn, arg1, arg2, ...)

Cria uma nova tarefa em um novo pthread, retorna um handle de tarefa.

**Par√¢metros:**
- `async_fn` - a fun√ß√£o ass√≠ncrona a executar
- `arg1, arg2, ...` - argumentos a passar para a fun√ß√£o

**Retorna:** Handle de tarefa (valor opaco para uso com `join()` ou `detach()`)

**Exemplo:**
```hemlock
async fn process(data: string, count: i32): i32 {
    // ... l√≥gica de processamento
    return count * 2;
}

let task = spawn(process, "test", 42);
```

#### join(task)

Aguarda a tarefa completar (bloqueia at√© a thread terminar), retorna o resultado.

**Par√¢metros:**
- `task` - handle de tarefa retornado por `spawn()`

**Retorna:** O valor retornado pela fun√ß√£o ass√≠ncrona

**Exemplo:**
```hemlock
let task = spawn(compute, 1000);
let result = join(task);  // Bloqueia at√© compute() terminar
print(result);
```

**Importante:** Cada tarefa s√≥ pode ser joined uma vez. Joins subsequentes resultar√£o em erro.

#### detach(task)

Execu√ß√£o fire-and-forget (a thread executa independentemente, join n√£o √© permitido).

**Par√¢metros:**
- `task` - handle de tarefa retornado por `spawn()`

**Retorna:** `null`

**Exemplo:**
```hemlock
async fn background_work() {
    // Tarefa de longa dura√ß√£o em background
    // ...
}

let task = spawn(background_work);
detach(task);  // Tarefa executa independentemente, n√£o pode ser joined
```

**Importante:** Tarefas detached n√£o podem ser joined. Quando a tarefa completa, tanto o pthread quanto a estrutura Task s√£o automaticamente limpos.

## Canais

Canais fornecem comunica√ß√£o thread-safe entre tarefas usando buffers limitados e sem√¢ntica bloqueante.

### Criando Canais

```hemlock
let ch = channel(10);  // Cria canal com buffer de tamanho 10
```

**Par√¢metros:**
- `capacity` (i32) - n√∫mero m√°ximo de valores que o canal pode armazenar

**Retorna:** Objeto canal

### M√©todos de Canal

#### send(value)

Envia valor para o canal (bloqueia se estiver cheio).

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

let ch = channel(10);
let task = spawn(producer, ch, 5);
```

**Comportamento:**
- Se o canal tem espa√ßo, o valor √© adicionado imediatamente
- Se o canal est√° cheio, o emissor bloqueia at√© haver espa√ßo dispon√≠vel
- Se o canal est√° fechado, lan√ßa uma exce√ß√£o

#### recv()

Recebe valor do canal (bloqueia se estiver vazio).

```hemlock
async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(10);
let task = spawn(consumer, ch, 5);
```

**Comportamento:**
- Se o canal tem valores, retorna o pr√≥ximo valor imediatamente
- Se o canal est√° vazio, o receptor bloqueia at√© um valor estar dispon√≠vel
- Se o canal est√° fechado e vazio, retorna `null`

#### close()

Fecha o canal (recv em canal fechado retorna null).

```hemlock
ch.close();
```

**Comportamento:**
- Impede opera√ß√µes `send()` futuras (lan√ßar√° exce√ß√£o)
- Permite opera√ß√µes `recv()` pendentes completarem
- Uma vez vazio, `recv()` retorna `null`

### Multiplexa√ß√£o com select()

A fun√ß√£o `select()` permite esperar em m√∫ltiplos canais simultaneamente, retornando quando qualquer canal tiver dados dispon√≠veis.

**Assinatura:**
```hemlock
select(channels: array, timeout_ms?: i32): object | null
```

**Par√¢metros:**
- `channels` - array de valores de canal
- `timeout_ms` (opcional) - timeout em milissegundos (-1 ou omitido para espera infinita)

**Retorna:**
- `{ channel, value }` - objeto contendo o canal que tinha dados e o valor recebido
- `null` - em timeout (se timeout foi especificado)

**Exemplo:**
```hemlock
let ch1 = channel(1);
let ch2 = channel(1);

// Tarefas produtoras
spawn(fn() {
    sleep(100);
    ch1.send("from channel 1");
});

spawn(fn() {
    sleep(50);
    ch2.send("from channel 2");
});

// Espera pelo primeiro resultado (ch2 deve ser mais r√°pido)
let result = select([ch1, ch2]);
print(result.value);  // "from channel 2"

// Espera pelo segundo resultado
let result2 = select([ch1, ch2]);
print(result2.value);  // "from channel 1"
```

**Com Timeout:**
```hemlock
let ch = channel(1);

// Sem emissor, vai ter timeout
let result = select([ch], 100);  // timeout de 100ms
if (result == null) {
    print("Timed out!");
}
```

**Casos de Uso:**
- Esperar pelo mais r√°pido entre m√∫ltiplas fontes de dados
- Implementar timeouts em opera√ß√µes de canal
- Padr√µes de event loop com m√∫ltiplas fontes de eventos
- Fan-in: combinar m√∫ltiplos canais em um

**Padr√£o Fan-in:**
```hemlock
fn fan_in(channels: array, output: channel) {
    while (true) {
        let result = select(channels);
        if (result == null) {
            break;  // Todos os canais fechados
        }
        output.send(result.value);
    }
    output.close();
}
```

### Exemplo Completo Produtor-Consumidor

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

// Criar canal com tamanho de buffer
let ch = channel(10);

// Criar produtor e consumidor
let p = spawn(producer, ch, 5);
let c = spawn(consumer, ch, 5);

// Esperar completar
join(p);
let total = join(c);  // 100 (0+10+20+30+40)
print(total);
```

### M√∫ltiplos Produtores, M√∫ltiplos Consumidores

Canais podem ser compartilhados com seguran√ßa entre m√∫ltiplos produtores e consumidores:

```hemlock
async fn producer(id: i32, ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(id * 100 + i);
        i = i + 1;
    }
}

async fn consumer(id: i32, ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(20);

// M√∫ltiplos produtores
let p1 = spawn(producer, 1, ch, 5);
let p2 = spawn(producer, 2, ch, 5);

// M√∫ltiplos consumidores
let c1 = spawn(consumer, 1, ch, 5);
let c2 = spawn(consumer, 2, ch, 5);

// Esperar todos
join(p1);
join(p2);
let sum1 = join(c1);
let sum2 = join(c2);
print(sum1 + sum2);
```

## Propaga√ß√£o de Exce√ß√µes

Exce√ß√µes lan√ßadas em tarefas criadas s√£o propagadas no join:

```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Task failed!";
    }
    return 42;
}

let t = spawn(risky_operation, 1);
try {
    let result = join(t);
} catch (e) {
    print("Caught: " + e);  // "Caught: Task failed!"
}
```

### Padr√µes de Tratamento de Exce√ß√µes

**Padr√£o 1: Tratar na Tarefa**
```hemlock
async fn safe_task() {
    try {
        // Opera√ß√£o arriscada
    } catch (e) {
        print("Error in task: " + e);
        return null;
    }
}

let task = spawn(safe_task);
join(task);  // Sem propaga√ß√£o de exce√ß√£o
```

**Padr√£o 2: Propagar ao Chamador**
```hemlock
async fn task_that_throws() {
    throw "error";
}

let task = spawn(task_that_throws);
try {
    join(task);
} catch (e) {
    print("Caught from task: " + e);
}
```

**Padr√£o 3: Tarefas Detached com Exce√ß√µes**
```hemlock
async fn detached_task() {
    try {
        // Trabalho
    } catch (e) {
        // Deve tratar internamente - n√£o pode propagar
        print("Error: " + e);
    }
}

let task = spawn(detached_task);
detach(task);  // N√£o √© poss√≠vel capturar exce√ß√µes de tarefas detached
```

## Detalhes de Implementa√ß√£o

### Arquitetura de Threads

- **Threads 1:1** - cada tarefa criada gera uma thread dedicada do SO via `pthread_create()`
- **Escalonamento do Kernel** - o kernel do SO escalona threads entre os n√∫cleos de CPU dispon√≠veis
- **Multitarefa Preemptiva** - o SO pode interromper e alternar entre threads
- **Sem GIL** - diferente de Python, n√£o h√° Global Interpreter Lock limitando o paralelismo

### Implementa√ß√£o de Canais

Canais usam um buffer circular com sincroniza√ß√£o pthread:

```
Estrutura do Canal:
- buffer[] - array de Values de tamanho fixo
- capacity - n√∫mero m√°ximo de elementos
- size - n√∫mero atual de elementos
- head - posi√ß√£o de leitura
- tail - posi√ß√£o de escrita
- mutex - pthread_mutex_t para acesso thread-safe
- not_empty - pthread_cond_t para recv bloqueante
- not_full - pthread_cond_t para send bloqueante
- closed - flag booleana
- refcount - contagem de refer√™ncias para limpeza
```

**Comportamento Bloqueante:**
- `send()` em canal cheio: espera na vari√°vel de condi√ß√£o `not_full`
- `recv()` em canal vazio: espera na vari√°vel de condi√ß√£o `not_empty`
- Ambas s√£o sinalizadas pela opera√ß√£o oposta quando apropriado

### Mem√≥ria e Limpeza

- **Tarefas Joined:** Limpas automaticamente ap√≥s `join()` retornar
- **Tarefas Detached:** Limpas automaticamente quando a tarefa completa
- **Canais:** Contagem de refer√™ncias, liberados quando n√£o mais em uso

## Melhores Pr√°ticas

### 1. Sempre Feche Canais

```hemlock
async fn producer(ch) {
    // ... enviar valores
    ch.close();  // Importante: sinaliza que n√£o h√° mais valores
}
```

### 2. Use Concorr√™ncia Estruturada

Crie tarefas e as fa√ßa join no mesmo escopo:

```hemlock
fn process_data(data) {
    // Criar tarefas
    let t1 = spawn(worker, data);
    let t2 = spawn(worker, data);

    // Sempre join antes de retornar
    let r1 = join(t1);
    let r2 = join(t2);

    return r1 + r2;
}
```

### 3. Trate Exce√ß√µes Apropriadamente

```hemlock
async fn task() {
    try {
        // Opera√ß√£o arriscada
    } catch (e) {
        // Registrar erro
        throw e;  // Re-lan√ßar se o chamador precisa saber
    }
}
```

### 4. Use Capacidade de Canal Apropriada

- **Capacidade pequena (1-10):** Para coordena√ß√£o/sinaliza√ß√£o
- **Capacidade m√©dia (10-100):** Para produtor-consumidor geral
- **Capacidade grande (100+):** Para cen√°rios de alto throughput

```hemlock
let signal_ch = channel(1);      // Coordena√ß√£o
let work_ch = channel(50);       // Fila de trabalho
let buffer_ch = channel(1000);   // Alto throughput
```

### 5. Detach Apenas Quando Necess√°rio

Prefira `join()` sobre `detach()` para melhor gerenciamento de recursos:

```hemlock
// Bom: Join e obter resultado
let task = spawn(work);
let result = join(task);

// Use detach apenas para fire-and-forget real
let bg_task = spawn(background_logging);
detach(bg_task);  // Executar√° independentemente
```

## Caracter√≠sticas de Desempenho

### Paralelismo Real

- **N tarefas criadas podem utilizar N n√∫cleos de CPU simultaneamente**
- Speedup comprovado - testes de stress mostram tempo de CPU vs tempo de rel√≥gio de 8-9x (trabalho multi-core)
- Escala linearmente com n√∫mero de n√∫cleos (at√© o n√∫mero de threads)

### Overhead de Threads

- Cada tarefa tem ~8KB de stack + overhead de pthread
- Custo de cria√ß√£o de thread: ~10-20 microssegundos
- Custo de troca de contexto: ~1-5 microssegundos

### Quando Usar Async

**Bons casos de uso:**
- Computa√ß√µes CPU-intensivas paraleliz√°veis
- Opera√ß√µes I/O-bound (embora I/O ainda seja bloqueante)
- Processamento concorrente de dados independentes
- Arquitetura de pipeline usando canais

**N√£o ideal para:**
- Tarefas muito curtas (overhead de thread domina)
- Tarefas com muita sincroniza√ß√£o (overhead de conten√ß√£o)
- Sistemas single-core (sem ganho de paralelismo)

### I/O Bloqueante Seguro

Opera√ß√µes bloqueantes em uma tarefa n√£o bloqueiam outras tarefas:

```hemlock
async fn reader(filename: string) {
    let f = open(filename, "r");  // Bloqueia apenas esta thread
    let content = f.read();       // Bloqueia apenas esta thread
    f.close();
    return content;
}

// Ambas leem concorrentemente (em threads diferentes)
let t1 = spawn(reader, "file1.txt");
let t2 = spawn(reader, "file2.txt");

let c1 = join(t1);
let c2 = join(t2);
```

## Modelo de Seguran√ßa de Threads

Hemlock usa um modelo de concorr√™ncia **passagem de mensagens**, onde tarefas se comunicam atrav√©s de canais ao inv√©s de estado mut√°vel compartilhado.

### Isolamento de Argumentos

Quando voc√™ cria uma tarefa, **argumentos s√£o copiados profundamente** para prevenir condi√ß√µes de corrida:

```hemlock
async fn modify_array(arr: array): array {
    arr.push(999);    // Modifica a c√≥pia, n√£o o original
    arr[0] = -1;
    return arr;
}

let original = [1, 2, 3];
let task = spawn(modify_array, original);
let modified = join(task);

print(original.length);  // 3 - n√£o modificado!
print(modified.length);  // 4 - tem novo elemento
```

**O que √© copiado profundamente:**
- Arrays (e todos os elementos recursivamente)
- Objetos (e todos os campos recursivamente)
- Strings
- Buffers

**O que √© compartilhado (mant√©m refer√™ncia):**
- Canais (mecanismo de comunica√ß√£o - compartilhado intencionalmente)
- Handles de tarefa (para coordena√ß√£o)
- Fun√ß√µes (c√≥digo √© imut√°vel)
- Handles de arquivo (SO gerencia acesso concorrente)
- Handles de socket (SO gerencia acesso concorrente)

**O que n√£o pode ser passado:**
- Ponteiros brutos (`ptr`) - use `buffer` em vez disso

### Por Que Passagem de Mensagens?

Isso segue a filosofia do Hemlock de "expl√≠cito √© melhor que impl√≠cito":

```hemlock
// Ruim: Estado mut√°vel compartilhado (causaria corrida de dados)
let counter = { value: 0 };
let t1 = spawn(fn() { counter.value = counter.value + 1; });  // Corrida!
let t2 = spawn(fn() { counter.value = counter.value + 1; });  // Corrida!

// Bom: Passagem de mensagens atrav√©s de canais
async fn increment(ch) {
    let val = ch.recv();
    ch.send(val + 1);
}

let ch = channel(1);
ch.send(0);
let t1 = spawn(increment, ch);
join(t1);
let result = ch.recv();  // 1 - sem condi√ß√£o de corrida
```

### Seguran√ßa de Thread na Contagem de Refer√™ncias

Todas as opera√ß√µes de contagem de refer√™ncias usam **opera√ß√µes at√¥micas** para prevenir erros use-after-free:
- `string_retain/release` - at√¥mico
- `array_retain/release` - at√¥mico
- `object_retain/release` - at√¥mico
- `buffer_retain/release` - at√¥mico
- `function_retain/release` - at√¥mico
- `channel_retain/release` - at√¥mico
- `task_retain/release` - at√¥mico

Isso garante gerenciamento de mem√≥ria seguro mesmo quando valores s√£o compartilhados entre threads.

### Acesso ao Ambiente de Closure

Tarefas podem acessar o ambiente de closure:
- Fun√ß√µes integradas (`print`, `len`, etc.)
- Defini√ß√µes de fun√ß√µes globais
- Constantes e vari√°veis

O ambiente de closure √© protegido por um mutex por ambiente, tornando leituras e escritas concorrentes thread-safe:

```hemlock
let x = 10;

async fn read_closure(): i32 {
    return x;  // OK: lendo vari√°vel de closure (thread-safe)
}

async fn modify_closure() {
    x = 20;  // OK: escrevendo vari√°vel de closure (sincronizado com mutex)
}
```

**Nota:** Embora o acesso concorrente seja sincronizado, modificar estado compartilhado de m√∫ltiplas tarefas ainda pode levar a condi√ß√µes de corrida l√≥gicas (ordem n√£o-determin√≠stica). Para comportamento previs√≠vel, use canais para comunica√ß√£o entre tarefas ou use valores de retorno de tarefas.

Se voc√™ precisa retornar dados de tarefas, use valores de retorno ou canais.

## Limita√ß√µes Atuais

### 1. Sem Escalonador Work-Stealing

Cada tarefa usa 1 thread, o que pode ser ineficiente para muitas tarefas curtas.

**Atual:** 1000 tarefas = 1000 threads (muito overhead)

**Planejado:** Pool de threads com work-stealing para efici√™ncia

### 3. Sem Integra√ß√£o de I/O Ass√≠ncrono

Opera√ß√µes de arquivo/rede ainda bloqueiam a thread:

```hemlock
async fn read_file(path: string) {
    let f = open(path, "r");
    let content = f.read();  // Bloqueia a thread
    f.close();
    return content;
}
```

**Workaround:** Use m√∫ltiplas threads para opera√ß√µes I/O concorrentes

### 4. Capacidade de Canal Fixa

A capacidade do canal √© definida na cria√ß√£o e n√£o pode ser redimensionada:

```hemlock
let ch = channel(10);
// N√£o √© poss√≠vel redimensionar dinamicamente para 20
```

### 5. Tamanho de Canal Fixo

O tamanho do buffer do canal n√£o pode ser alterado ap√≥s a cria√ß√£o.

## Padr√µes Comuns

### Map Paralelo

```hemlock
async fn map_worker(ch_in, ch_out, fn_transform) {
    while (true) {
        let val = ch_in.recv();
        if (val == null) { break; }

        let result = fn_transform(val);
        ch_out.send(result);
    }
    ch_out.close();
}

fn parallel_map(data, fn_transform, workers: i32) {
    let ch_in = channel(100);
    let ch_out = channel(100);

    // Criar workers
    let tasks = [];
    let i = 0;
    while (i < workers) {
        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));
        i = i + 1;
    }

    // Enviar dados
    let i = 0;
    while (i < data.length) {
        ch_in.send(data[i]);
        i = i + 1;
    }
    ch_in.close();

    // Coletar resultados
    let results = [];
    let i = 0;
    while (i < data.length) {
        results.push(ch_out.recv());
        i = i + 1;
    }

    // Esperar workers
    let i = 0;
    while (i < tasks.length) {
        join(tasks[i]);
        i = i + 1;
    }

    return results;
}
```

### Arquitetura de Pipeline

```hemlock
async fn stage1(input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }
        output_ch.send(val * 2);
    }
    output_ch.close();
}

async fn stage2(input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }
        output_ch.send(val + 10);
    }
    output_ch.close();
}

// Criar pipeline
let ch1 = channel(10);
let ch2 = channel(10);
let ch3 = channel(10);

let s1 = spawn(stage1, ch1, ch2);
let s2 = spawn(stage2, ch2, ch3);

// Entrada de dados
ch1.send(1);
ch1.send(2);
ch1.send(3);
ch1.close();

// Coletar sa√≠da
print(ch3.recv());  // 12 (1 * 2 + 10)
print(ch3.recv());  // 14 (2 * 2 + 10)
print(ch3.recv());  // 16 (3 * 2 + 10)

join(s1);
join(s2);
```

### Fan-out, Fan-in

```hemlock
async fn worker(id: i32, input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }

        // Processar valor
        let result = val * id;
        output_ch.send(result);
    }
}

let input = channel(10);
let output = channel(10);

// Fan-out: m√∫ltiplos workers
let workers = 4;
let tasks = [];
let i = 0;
while (i < workers) {
    tasks.push(spawn(worker, i, input, output));
    i = i + 1;
}

// Enviar trabalho
let i = 0;
while (i < 10) {
    input.send(i);
    i = i + 1;
}
input.close();

// Fan-in: coletar todos os resultados
let results = [];
let i = 0;
while (i < 10) {
    results.push(output.recv());
    i = i + 1;
}

// Esperar todos os workers
let i = 0;
while (i < tasks.length) {
    join(tasks[i]);
    i = i + 1;
}
```

## Resumo

O modelo de assincronismo/concorr√™ncia do Hemlock oferece:

- Paralelismo multi-thread real usando threads do SO
- Primitivas simples de concorr√™ncia estruturada
- Comunica√ß√£o thread-safe via canais
- Propaga√ß√£o de exce√ß√µes entre tarefas
- Desempenho comprovado em sistemas multi-core
- **Isolamento de argumentos** - c√≥pia profunda previne corridas de dados
- **Contagem de refer√™ncias at√¥mica** - gerenciamento de mem√≥ria seguro entre threads

Isso torna Hemlock adequado para:
- Computa√ß√£o paralela
- Opera√ß√µes I/O concorrentes
- Arquiteturas de pipeline
- Padr√µes produtor-consumidor

Enquanto evita as complexidades de:
- Gerenciamento manual de threads
- Primitivas de sincroniza√ß√£o de baixo n√≠vel
- Designs baseados em locks propensos a deadlock
- Erros de estado mut√°vel compartilhado


--------------------------------------------------------------------------------
## Empacotamento e Distribui√ß√£o
--------------------------------------------------------------------------------

# Empacotamento e Distribui√ß√£o

Hemlock oferece ferramentas integradas para empacotar projetos multi-arquivo em um √∫nico arquivo distribu√≠vel e criar execut√°veis independentes.

## Vis√£o Geral

| Comando | Sa√≠da | Caso de Uso |
|---------|-------|-------------|
| `--bundle` | `.hmlc` ou `.hmlb` | Distribuir bytecode (requer Hemlock instalado) |
| `--package` | execut√°vel | Bin√°rio independente (sem depend√™ncias) |
| `--compile` | `.hmlc` | Compilar arquivo √∫nico (sem resolu√ß√£o de imports) |

## Empacotamento (Bundle)

O empacotador resolve todas as declara√ß√µes `import` a partir do ponto de entrada e as achata em um √∫nico arquivo.

### Uso B√°sico

```bash
# Empacotar app.hml e todos seus imports em app.hmlc
hemlock --bundle app.hml

# Especificar caminho de sa√≠da
hemlock --bundle app.hml -o dist/app.hmlc

# Criar pacote comprimido (.hmlb) - tamanho de arquivo menor
hemlock --bundle app.hml --compress -o app.hmlb

# Sa√≠da detalhada (mostra m√≥dulos resolvidos)
hemlock --bundle app.hml --verbose
```

### Formatos de Sa√≠da

**`.hmlc` (n√£o comprimido)**
- Formato AST serializado
- R√°pido para carregar e executar
- Formato de sa√≠da padr√£o

**`.hmlb` (comprimido)**
- `.hmlc` comprimido com zlib
- Tamanho de arquivo menor (tipicamente 50-70% de redu√ß√£o)
- In√≠cio ligeiramente mais lento devido √† descompress√£o

### Executando Arquivos Empacotados

```bash
# Executar pacote n√£o comprimido
hemlock app.hmlc

# Executar pacote comprimido
hemlock app.hmlb

# Passar argumentos
hemlock app.hmlc arg1 arg2
```

### Exemplo: Projeto Multi-m√≥dulo

```
myapp/
‚îú‚îÄ‚îÄ main.hml
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ math.hml
‚îÇ   ‚îî‚îÄ‚îÄ utils.hml
‚îî‚îÄ‚îÄ config.hml
```

```hemlock
// main.hml
import { add, multiply } from "./lib/math.hml";
import { log } from "./lib/utils.hml";
import { VERSION } from "./config.hml";

log(`App v${VERSION}`);
print(add(2, 3));
```

```bash
hemlock --bundle myapp/main.hml -o myapp.hmlc
hemlock myapp.hmlc  # Executa com todas as depend√™ncias empacotadas
```

### Imports de stdlib

O empacotador resolve automaticamente imports `@stdlib/`:

```hemlock
import { HashMap } from "@stdlib/collections";
import { now } from "@stdlib/time";
```

Durante o empacotamento, m√≥dulos stdlib s√£o inclu√≠dos na sa√≠da.

## Encapsulamento (Package)

O encapsulamento cria execut√°veis independentes incorporando o bytecode empacotado em uma c√≥pia do interpretador Hemlock.

### Uso B√°sico

```bash
# Criar execut√°vel a partir de app.hml
hemlock --package app.hml

# Especificar nome de sa√≠da
hemlock --package app.hml -o myapp

# Pular compress√£o (in√≠cio mais r√°pido, arquivo maior)
hemlock --package app.hml --no-compress

# Sa√≠da detalhada
hemlock --package app.hml --verbose
```

### Executando Execut√°veis Encapsulados

```bash
# Execut√°veis encapsulados rodam diretamente
./myapp

# Argumentos s√£o passados para o script
./myapp arg1 arg2
```

### Formato do Pacote

Execut√°veis encapsulados usam o formato HMLP:

```
[bin√°rio hemlock][payload HMLB/HMLC][payload_size:u64][magic HMLP:u32]
```

Quando um execut√°vel encapsulado roda:
1. Verifica o final do arquivo para payload incorporado
2. Se encontrado, descomprime e executa o payload
3. Se n√£o encontrado, executa como interpretador Hemlock normal

### Op√ß√µes de Compress√£o

| Flag | Formato | In√≠cio | Tamanho |
|------|---------|--------|---------|
| (padr√£o) | HMLB | Normal | Menor |
| `--no-compress` | HMLC | Mais r√°pido | Maior |

Para ferramentas CLI onde tempo de in√≠cio √© importante, use `--no-compress`.

## Inspecionando Pacotes

Use `--info` para inspecionar arquivos compilados ou empacotados:

```bash
hemlock --info app.hmlc
```

Sa√≠da:
```
=== File Info: app.hmlc ===
Size: 12847 bytes
Format: HMLC (compiled AST)
Version: 1
Flags: 0x0001 [DEBUG]
Strings: 42
Statements: 156
```

```bash
hemlock --info app.hmlb
```

Sa√≠da:
```
=== File Info: app.hmlb ===
Size: 5234 bytes
Format: HMLB (compressed bundle)
Version: 1
Uncompressed: 12847 bytes
Compressed: 5224 bytes
Ratio: 59.3% reduction
```

## Compila√ß√£o Nativa

Para execut√°veis verdadeiramente nativos (sem interpretador), use o compilador Hemlock:

```bash
# Compilar para execut√°vel nativo via C
hemlockc app.hml -o app

# Manter c√≥digo C gerado
hemlockc app.hml -o app --keep-c

# Apenas gerar C (n√£o compilar)
hemlockc app.hml -c -o app.c

# N√≠veis de otimiza√ß√£o
hemlockc app.hml -o app -O2
```

O compilador gera c√≥digo C e chama GCC para produzir um bin√°rio nativo. Isso requer:
- Biblioteca runtime Hemlock (`libhemlock_runtime`)
- Compilador C (GCC por padr√£o)

### Op√ß√µes do Compilador

| Op√ß√£o | Descri√ß√£o |
|-------|-----------|
| `-o <file>` | Nome do arquivo execut√°vel de sa√≠da |
| `-c` | Apenas gerar c√≥digo C |
| `--emit-c <file>` | Escrever C para arquivo especificado |
| `-k, --keep-c` | Manter C gerado ap√≥s compila√ß√£o |
| `-O<level>` | N√≠vel de otimiza√ß√£o (0-3) |
| `--cc <path>` | Compilador C a usar |
| `--runtime <path>` | Caminho para biblioteca runtime |
| `-v, --verbose` | Sa√≠da detalhada |

## Compara√ß√£o

| M√©todo | Portabilidade | In√≠cio | Tamanho | Depend√™ncias |
|--------|---------------|--------|---------|--------------|
| `.hml` | Apenas fonte | Tempo de parse | M√≠nimo | Hemlock |
| `.hmlc` | Apenas Hemlock | R√°pido | Pequeno | Hemlock |
| `.hmlb` | Apenas Hemlock | R√°pido | Menor | Hemlock |
| `--package` | Independente | R√°pido | Maior | Nenhuma |
| `hemlockc` | Nativo | Mais r√°pido | Vari√°vel | Lib runtime |

## Melhores Pr√°ticas

1. **Desenvolvimento**: Executar arquivos `.hml` diretamente para itera√ß√£o r√°pida
2. **Distribui√ß√£o (com Hemlock)**: Empacotar com `--compress` para arquivos menores
3. **Distribui√ß√£o (independente)**: Encapsular para deploy sem depend√™ncias
4. **Cr√≠tico para desempenho**: Usar `hemlockc` para compila√ß√£o nativa

## Solu√ß√£o de Problemas

### "Cannot find stdlib"

O empacotador procura stdlib em:
1. `./stdlib` (relativo ao execut√°vel)
2. `../stdlib` (relativo ao execut√°vel)
3. `/usr/local/lib/hemlock/stdlib`

Certifique-se de que Hemlock est√° instalado corretamente ou execute do diret√≥rio fonte.

### Depend√™ncias Circulares

```
Error: Circular dependency detected when loading 'path/to/module.hml'
```

Refatore seus imports para quebrar o ciclo. Considere usar um m√≥dulo compartilhado para tipos comuns.

### Tamanho Grande do Pacote

- Use compress√£o padr√£o (n√£o use `--no-compress`)
- Tamanho do pacote inclui interpretador completo (base ~500KB-1MB)
- Para tamanho m√≠nimo, use `hemlockc` para compila√ß√£o nativa


--------------------------------------------------------------------------------
## Execu√ß√£o de Comandos
--------------------------------------------------------------------------------

# Hemlock Execu√ß√£o de Comandos

Hemlock oferece a **fun√ß√£o integrada `exec()`** para executar comandos shell e capturar a sa√≠da.

## √çndice

- [Vis√£o Geral](#vis√£o-geral)
- [Fun√ß√£o exec()](#fun√ß√£o-exec)
- [Objeto de Resultado](#objeto-de-resultado)
- [Uso B√°sico](#uso-b√°sico)
- [Exemplos Avan√ßados](#exemplos-avan√ßados)
- [Tratamento de Erros](#tratamento-de-erros)
- [Detalhes de Implementa√ß√£o](#detalhes-de-implementa√ß√£o)
- [Considera√ß√µes de Seguran√ßa](#considera√ß√µes-de-seguran√ßa)
- [Limita√ß√µes](#limita√ß√µes)
- [Casos de Uso](#casos-de-uso)
- [Melhores Pr√°ticas](#melhores-pr√°ticas)
- [Exemplos Completos](#exemplos-completos)

## Vis√£o Geral

A fun√ß√£o `exec()` permite que programas Hemlock:
- Executem comandos shell
- Capturem a sa√≠da padr√£o (stdout)
- Verifiquem c√≥digos de sa√≠da
- Usem recursos do shell (pipes, redirecionamento, etc.)
- Integrem com ferramentas do sistema

**Importante:** Comandos s√£o executados via `/bin/sh`, fornecendo funcionalidade completa de shell, mas tamb√©m introduzindo considera√ß√µes de seguran√ßa.

## Fun√ß√£o exec()

### Assinatura

```hemlock
exec(command: string): object
```

**Par√¢metros:**
- `command` (string) - o comando shell a executar

**Retorna:** Um objeto com dois campos:
- `output` (string) - sa√≠da stdout do comando
- `exit_code` (i32) - c√≥digo de status de sa√≠da do comando

### Exemplo B√°sico

```hemlock
let result = exec("echo hello");
print(result.output);      // "hello\n"
print(result.exit_code);   // 0
```

## Objeto de Resultado

O objeto retornado por `exec()` tem a seguinte estrutura:

```hemlock
{
    output: string,      // stdout do comando (sa√≠da capturada)
    exit_code: i32       // status de sa√≠da do processo (0 = sucesso)
}
```

### Campo output

Cont√©m todo o texto que o comando escreveu no stdout.

**Propriedades:**
- String vazia se o comando n√£o produziu sa√≠da
- Inclui newlines e espa√ßos em branco como est√£o
- Sa√≠da multi-linha √© preservada
- Sem limite de tamanho (aloca√ß√£o din√¢mica)

**Exemplos:**
```hemlock
let r1 = exec("echo test");
print(r1.output);  // "test\n"

let r2 = exec("ls");
print(r2.output);  // Listagem de diret√≥rio com newlines

let r3 = exec("true");
print(r3.output);  // "" (string vazia)
```

### Campo exit_code

O c√≥digo de status de sa√≠da do comando.

**Valores:**
- `0` tipicamente indica sucesso
- `1-255` indicam erro (conven√ß√£o varia por comando)
- `-1` se o comando n√£o p√¥de ser executado ou terminou anormalmente

**Exemplos:**
```hemlock
let r1 = exec("true");
print(r1.exit_code);  // 0 (sucesso)

let r2 = exec("false");
print(r2.exit_code);  // 1 (falha)

let r3 = exec("ls /nonexistent");
print(r3.exit_code);  // 2 (arquivo n√£o encontrado, varia por comando)
```

## Uso B√°sico

### Comandos Simples

```hemlock
let r = exec("ls -la");
print(r.output);
print("Exit code: " + typeof(r.exit_code));
```

### Verificando Status de Sa√≠da

```hemlock
let r = exec("grep pattern file.txt");
if (r.exit_code == 0) {
    print("Found: " + r.output);
} else {
    print("Pattern not found");
}
```

### Comandos com Pipes

```hemlock
let r = exec("ps aux | grep hemlock");
print(r.output);
```

### M√∫ltiplos Comandos

```hemlock
let r = exec("cd /tmp && ls -la");
print(r.output);
```

### Substitui√ß√£o de Comando

```hemlock
let r = exec("echo $(date)");
print(r.output);  // Data atual
```

## Exemplos Avan√ßados

### Tratando Falhas

```hemlock
let r = exec("ls /nonexistent");
if (r.exit_code != 0) {
    print("Command failed with code: " + typeof(r.exit_code));
    print("Error output: " + r.output);  // Nota: stderr n√£o √© capturado
}
```

### Processando Sa√≠da Multi-linha

```hemlock
let r = exec("cat file.txt");
let lines = r.output.split("\n");
let i = 0;
while (i < lines.length) {
    print("Line " + typeof(i) + ": " + lines[i]);
    i = i + 1;
}
```

### Encadeamento de Comandos

**Usando && (E):**
```hemlock
let r1 = exec("mkdir -p /tmp/test && touch /tmp/test/file.txt");
if (r1.exit_code == 0) {
    print("Setup complete");
}
```

**Usando || (OU):**
```hemlock
let r = exec("command1 || command2");
// Executa command2 apenas se command1 falhar
```

**Usando ; (sequencial):**
```hemlock
let r = exec("command1; command2");
// Executa ambos independentemente de sucesso/falha
```

### Usando Pipes

```hemlock
let r = exec("echo 'data' | base64");
print("Base64: " + r.output);
```

**Pipes Complexos:**
```hemlock
let r = exec("cat /etc/passwd | grep root | cut -d: -f1");
print(r.output);
```

### Padr√µes de C√≥digo de Sa√≠da

Diferentes c√≥digos de sa√≠da indicam diferentes condi√ß√µes:

```hemlock
let r = exec("test -f myfile.txt");
if (r.exit_code == 0) {
    print("File exists");
} else if (r.exit_code == 1) {
    print("File does not exist");
} else {
    print("Test command failed: " + typeof(r.exit_code));
}
```

### Redirecionamento de Sa√≠da

```hemlock
// Redirecionar stdout para arquivo (dentro do shell)
let r1 = exec("echo 'test' > /tmp/output.txt");

// Redirecionar stderr para stdout (nota: Hemlock ainda n√£o captura stderr)
let r2 = exec("command 2>&1");
```

### Vari√°veis de Ambiente

```hemlock
let r = exec("export VAR=value && echo $VAR");
print(r.output);  // "value\n"
```

### Mudan√ßa de Diret√≥rio de Trabalho

```hemlock
let r = exec("cd /tmp && pwd");
print(r.output);  // "/tmp\n"
```

## Tratamento de Erros

### Quando exec() Lan√ßa Exce√ß√£o

A fun√ß√£o `exec()` lan√ßar√° uma exce√ß√£o se o comando n√£o puder ser executado:

```hemlock
try {
    let r = exec("nonexistent_command_xyz");
} catch (e) {
    print("Failed to execute: " + e);
}
```

**Condi√ß√µes que lan√ßam:**
- `popen()` falha (ex: n√£o pode criar pipe)
- Limites de recursos do sistema excedidos
- Falha na aloca√ß√£o de mem√≥ria

### Quando exec() N√£o Lan√ßa Exce√ß√£o

```hemlock
// Comando executa mas retorna c√≥digo de sa√≠da n√£o-zero
let r1 = exec("false");
print(r1.exit_code);  // 1 (n√£o √© exce√ß√£o)

// Comando n√£o tem sa√≠da
let r2 = exec("true");
print(r2.output);  // "" (n√£o √© exce√ß√£o)

// Shell n√£o pode encontrar comando
let r3 = exec("nonexistent_cmd");
print(r3.exit_code);  // 127 (n√£o √© exce√ß√£o)
```

### Padr√£o de Execu√ß√£o Segura

```hemlock
fn safe_exec(command: string) {
    try {
        let r = exec(command);
        if (r.exit_code != 0) {
            print("Warning: Command failed with code " + typeof(r.exit_code));
            return "";
        }
        return r.output;
    } catch (e) {
        print("Error executing command: " + e);
        return "";
    }
}

let output = safe_exec("ls -la");
```

## Detalhes de Implementa√ß√£o

### Como Funciona

**Implementa√ß√£o subjacente:**
- Usa `popen()` para executar comandos via `/bin/sh`
- Apenas stdout √© capturado (stderr n√£o √© capturado)
- Sa√≠da √© bufferizada dinamicamente (come√ßa com 4KB, cresce conforme necess√°rio)
- Status de sa√≠da √© extra√≠do usando macros `WIFEXITED()` e `WEXITSTATUS()`
- String de sa√≠da √© corretamente terminada em null

**Fluxo do processo:**
1. `popen(command, "r")` cria pipe e faz fork do processo
2. Processo filho executa `/bin/sh -c "command"`
3. Processo pai l√™ stdout via pipe para buffer crescente
4. `pclose()` espera o filho e retorna status de sa√≠da
5. Status de sa√≠da √© extra√≠do e armazenado no objeto resultado

### Considera√ß√µes de Desempenho

**Overhead:**
- Cada chamada cria um novo processo shell (~1-5ms de overhead)
- Sa√≠da √© completamente armazenada em mem√≥ria (n√£o streaming)
- Streaming n√£o √© suportado (espera comando completar)
- Adequado para comandos com tamanho de sa√≠da razo√°vel

**Otimiza√ß√µes:**
- Buffer come√ßa com 4KB, dobra quando cheio (uso eficiente de mem√≥ria)
- Loop de leitura √∫nico minimiza chamadas de sistema
- Sem c√≥pias extras de string

**Quando usar:**
- Comandos de curta dura√ß√£o (< 1 segundo)
- Tamanho de sa√≠da moderado (< 10MB)
- Opera√ß√µes em lote com intervalos razo√°veis

**Quando n√£o usar:**
- Daemons ou servi√ßos de longa dura√ß√£o
- Comandos que produzem sa√≠da em GB
- Processamento de dados streaming em tempo real
- Execu√ß√£o de alta frequ√™ncia (> 100 vezes/segundo)

## Considera√ß√µes de Seguran√ßa

### Risco de Inje√ß√£o de Shell

**Cr√≠tico:** Comandos s√£o executados pelo shell (`/bin/sh`), o que significa que **inje√ß√£o de shell √© poss√≠vel**.

**C√≥digo Vulner√°vel:**
```hemlock
// PERIGO - N√ÉO FA√áA ISSO
let filename = args[1];  // Entrada do usu√°rio
let r = exec("cat " + filename);  // Inje√ß√£o de shell!
```

**Ataque:**
```bash
./hemlock script.hml "; rm -rf /; echo pwned"
# Executa: cat ; rm -rf /; echo pwned
```

### Pr√°ticas Seguras

**1. Nunca use entrada de usu√°rio n√£o sanitizada:**
```hemlock
// Ruim
let user_input = args[1];
let r = exec("process " + user_input);  // Perigoso

// Bom - validar primeiro
fn is_safe_filename(name: string): bool {
    // Apenas permitir alfanum√©ricos, h√≠fen, sublinhado, ponto
    let i = 0;
    while (i < name.length) {
        let c = name[i];
        if (!(c >= 'a' && c <= 'z') &&
            !(c >= 'A' && c <= 'Z') &&
            !(c >= '0' && c <= '9') &&
            c != '-' && c != '_' && c != '.') {
            return false;
        }
        i = i + 1;
    }
    return true;
}

let filename = args[1];
if (is_safe_filename(filename)) {
    let r = exec("cat " + filename);
} else {
    print("Invalid filename");
}
```

**2. Use whitelist, n√£o blacklist:**
```hemlock
// Bom - whitelist estrita
let allowed_commands = ["status", "start", "stop", "restart"];
let cmd = args[1];

let found = false;
for (let allowed in allowed_commands) {
    if (cmd == allowed) {
        found = true;
        break;
    }
}

if (found) {
    exec("service myapp " + cmd);
} else {
    print("Invalid command");
}
```

**3. Escape caracteres especiais:**
```hemlock
fn shell_escape(s: string): string {
    // Escape simples - envolver em aspas simples e escapar aspas simples
    let escaped = s.replace_all("'", "'\\''");
    return "'" + escaped + "'";
}

let user_file = args[1];
let safe = shell_escape(user_file);
let r = exec("cat " + safe);
```

**4. Evite exec() para opera√ß√µes de arquivo:**
```hemlock
// Ruim - usando exec para opera√ß√µes de arquivo
let r = exec("cat file.txt");

// Bom - usar API de arquivo do Hemlock
let f = open("file.txt", "r");
let content = f.read();
f.close();
```

### Considera√ß√µes de Permiss√£o

Comandos executam com as mesmas permiss√µes que o processo Hemlock:

```hemlock
// Se Hemlock est√° rodando como root, comandos exec() tamb√©m rodam como root!
let r = exec("rm -rf /important");  // Perigoso se rodando como root
```

**Melhor pr√°tica:** Execute Hemlock com privil√©gios m√≠nimos necess√°rios.

## Limita√ß√µes

### 1. Sem Captura de stderr

Apenas stdout √© capturado, stderr vai para o terminal:

```hemlock
let r = exec("ls /nonexistent");
// r.output est√° vazio
// Mensagem de erro aparece no terminal, n√£o capturada
```

**Workaround - redirecionar stderr para stdout:**
```hemlock
let r = exec("ls /nonexistent 2>&1");
// Agora a mensagem de erro est√° em r.output
```

### 2. Sem Streaming

Deve esperar o comando completar:

```hemlock
let r = exec("long_running_command");
// Bloqueia at√© o comando terminar
// N√£o pode processar sa√≠da incrementalmente
```

### 3. Sem Timeout

Comandos podem rodar indefinidamente:

```hemlock
let r = exec("sleep 1000");
// Bloqueia por 1000 segundos
// N√£o pode timeout ou cancelar
```

**Workaround - usar comando timeout:**
```hemlock
let r = exec("timeout 5 long_command");
// Timeout ap√≥s 5 segundos
```

### 4. Sem Tratamento de Sinais

N√£o pode enviar sinais para comandos em execu√ß√£o:

```hemlock
let r = exec("long_command");
// N√£o pode enviar SIGINT, SIGTERM, etc para o comando
```

### 5. Sem Controle de Processo

N√£o pode interagir com o comando ap√≥s iniciar:

```hemlock
let r = exec("interactive_program");
// N√£o pode enviar entrada para o programa
// N√£o pode controlar a execu√ß√£o
```

## Casos de Uso

### Bons Casos de Uso

**1. Executar ferramentas do sistema:**
```hemlock
let r = exec("ls -la");
let r = exec("grep pattern file.txt");
let r = exec("find /path -name '*.txt'");
```

**2. Processamento r√°pido de dados com ferramentas Unix:**
```hemlock
let r = exec("cat data.txt | sort | uniq | wc -l");
print("Unique lines: " + r.output);
```

**3. Verificar status do sistema:**
```hemlock
let r = exec("df -h");
print("Disk usage:\n" + r.output);
```

**4. Verifica√ß√£o de exist√™ncia de arquivo:**
```hemlock
let r = exec("test -f myfile.txt");
if (r.exit_code == 0) {
    print("File exists");
}
```

**5. Gerar relat√≥rios:**
```hemlock
let r = exec("ps aux | grep myapp | wc -l");
let count = r.output.trim();
print("Running instances: " + count);
```

**6. Scripts de automa√ß√£o:**
```hemlock
exec("git add .");
exec("git commit -m 'Auto commit'");
let r = exec("git push");
if (r.exit_code != 0) {
    print("Push failed");
}
```

### Casos de Uso N√£o Recomendados

**1. Servi√ßos de longa dura√ß√£o:**
```hemlock
// Ruim
let r = exec("nginx");  // Bloqueia para sempre
```

**2. Comandos interativos:**
```hemlock
// Ruim - n√£o pode fornecer entrada
let r = exec("ssh user@host");
```

**3. Comandos com sa√≠da enorme:**
```hemlock
// Ruim - carrega sa√≠da inteira na mem√≥ria
let r = exec("cat 10GB_file.log");
```

**4. Streaming em tempo real:**
```hemlock
// Ruim - n√£o pode processar sa√≠da incrementalmente
let r = exec("tail -f /var/log/app.log");
```

**5. Tratamento de erros de miss√£o cr√≠tica:**
```hemlock
// Ruim - stderr n√£o √© capturado
let r = exec("critical_operation");
// N√£o pode ver mensagens de erro detalhadas
```

## Melhores Pr√°ticas

### 1. Sempre Verifique C√≥digo de Sa√≠da

```hemlock
let r = exec("important_command");
if (r.exit_code != 0) {
    print("Command failed!");
    // Tratar erro
}
```

### 2. Trim Sa√≠da Quando Necess√°rio

```hemlock
let r = exec("echo test");
let clean = r.output.trim();  // Remove newline final
print(clean);  // "test" (sem newline)
```

### 3. Valide Antes de Executar

```hemlock
fn is_valid_command(cmd: string): bool {
    // Validar se comando √© seguro
    return true;  // Sua l√≥gica de valida√ß√£o
}

if (is_valid_command(user_cmd)) {
    exec(user_cmd);
}
```

### 4. Use try/catch para Opera√ß√µes Cr√≠ticas

```hemlock
try {
    let r = exec("critical_command");
    if (r.exit_code != 0) {
        throw "Command failed";
    }
} catch (e) {
    print("Error: " + e);
    // Limpeza ou recupera√ß√£o
}
```

### 5. Prefira APIs Hemlock sobre exec()

```hemlock
// Ruim - usar exec para opera√ß√µes de arquivo
let r = exec("cat file.txt");

// Bom - usar API de arquivo do Hemlock
let f = open("file.txt", "r");
let content = f.read();
f.close();
```

### 6. Capture stderr Quando Necess√°rio

```hemlock
// Redirecionar stderr para stdout
let r = exec("command 2>&1");
// Agora r.output cont√©m tanto stdout quanto stderr
```

### 7. Use Recursos do Shell com Sabedoria

```hemlock
// Usar pipes para efici√™ncia
let r = exec("cat large.txt | grep pattern | head -n 10");

// Usar substitui√ß√£o de comando
let r = exec("echo Current user: $(whoami)");

// Usar execu√ß√£o condicional
let r = exec("test -f file.txt && cat file.txt");
```

## Exemplos Completos

### Exemplo 1: Coletor de Informa√ß√µes do Sistema

```hemlock
fn get_system_info() {
    print("=== System Information ===");

    // Hostname
    let r1 = exec("hostname");
    print("Hostname: " + r1.output.trim());

    // Uptime
    let r2 = exec("uptime");
    print("Uptime: " + r2.output.trim());

    // Uso de disco
    let r3 = exec("df -h /");
    print("\nDisk Usage:");
    print(r3.output);

    // Uso de mem√≥ria
    let r4 = exec("free -h");
    print("Memory Usage:");
    print(r4.output);
}

get_system_info();
```

### Exemplo 2: Analisador de Logs

```hemlock
fn analyze_log(logfile: string) {
    print("Analyzing log: " + logfile);

    // Contar linhas totais
    let r1 = exec("wc -l " + logfile);
    print("Total lines: " + r1.output.trim());

    // Contar erros
    let r2 = exec("grep -c ERROR " + logfile + " 2>/dev/null");
    let errors = r2.output.trim();
    if (r2.exit_code == 0) {
        print("Errors: " + errors);
    } else {
        print("Errors: 0");
    }

    // Contar avisos
    let r3 = exec("grep -c WARN " + logfile + " 2>/dev/null");
    let warnings = r3.output.trim();
    if (r3.exit_code == 0) {
        print("Warnings: " + warnings);
    } else {
        print("Warnings: 0");
    }

    // Erros recentes
    print("\nRecent errors:");
    let r4 = exec("grep ERROR " + logfile + " | tail -n 5");
    print(r4.output);
}

if (args.length < 2) {
    print("Usage: " + args[0] + " <logfile>");
} else {
    analyze_log(args[1]);
}
```

### Exemplo 3: Auxiliar Git

```hemlock
fn git_status() {
    let r = exec("git status --short");
    if (r.exit_code != 0) {
        print("Error: Not a git repository");
        return;
    }

    if (r.output == "") {
        print("Working directory clean");
    } else {
        print("Changes:");
        print(r.output);
    }
}

fn git_quick_commit(message: string) {
    print("Adding all changes...");
    let r1 = exec("git add -A");
    if (r1.exit_code != 0) {
        print("Error adding files");
        return;
    }

    print("Committing...");
    let safe_msg = message.replace_all("'", "'\\''");
    let r2 = exec("git commit -m '" + safe_msg + "'");
    if (r2.exit_code != 0) {
        print("Error committing");
        return;
    }

    print("Committed successfully");
    print(r2.output);
}

// Uso
git_status();
if (args.length > 1) {
    git_quick_commit(args[1]);
}
```

### Exemplo 4: Script de Backup

```hemlock
fn backup_directory(source: string, dest: string) {
    print("Backing up " + source + " to " + dest);

    // Criar diret√≥rio de backup
    let r1 = exec("mkdir -p " + dest);
    if (r1.exit_code != 0) {
        print("Error creating backup directory");
        return false;
    }

    // Criar arquivo com timestamp
    let r2 = exec("date +%Y%m%d_%H%M%S");
    let timestamp = r2.output.trim();
    let backup_file = dest + "/backup_" + timestamp + ".tar.gz";

    print("Creating archive: " + backup_file);
    let r3 = exec("tar -czf " + backup_file + " " + source + " 2>&1");
    if (r3.exit_code != 0) {
        print("Error creating backup:");
        print(r3.output);
        return false;
    }

    print("Backup completed successfully");

    // Mostrar tamanho do backup
    let r4 = exec("du -h " + backup_file);
    print("Backup size: " + r4.output.trim());

    return true;
}

if (args.length < 3) {
    print("Usage: " + args[0] + " <source> <destination>");
} else {
    backup_directory(args[1], args[2]);
}
```

## Resumo

A fun√ß√£o `exec()` do Hemlock oferece:

- Execu√ß√£o simples de comandos shell
- Captura de sa√≠da (stdout)
- Verifica√ß√£o de c√≥digo de sa√≠da
- Acesso completo a recursos do shell (pipes, redirecionamento, etc.)
- Integra√ß√£o com ferramentas do sistema

Lembre-se:
- Sempre verifique c√≥digos de sa√≠da
- Esteja ciente das implica√ß√µes de seguran√ßa (inje√ß√£o de shell)
- Valide entrada do usu√°rio antes de usar em comandos
- Prefira APIs Hemlock sobre exec() quando dispon√≠veis
- stderr n√£o √© capturado (use `2>&1` para redirecionar)
- Comandos bloqueiam at√© completar
- Use para ferramentas de curta dura√ß√£o, n√£o servi√ßos de longa dura√ß√£o

**Checklist de Seguran√ßa:**
- Nunca use entrada de usu√°rio n√£o sanitizada
- Valide toda entrada
- Use whitelist para comandos
- Escape caracteres especiais quando necess√°rio
- Execute com privil√©gios m√≠nimos
- Prefira APIs Hemlock sobre comandos shell


--------------------------------------------------------------------------------
## FFI
--------------------------------------------------------------------------------

# Hemlock FFI (Interface de Fun√ß√µes Estrangeiras)

Hemlock oferece **FFI (Interface de Fun√ß√µes Estrangeiras)**, permitindo chamar fun√ß√µes C de bibliotecas compartilhadas usando libffi, possibilitando integra√ß√£o com bibliotecas C existentes e APIs do sistema.

## √çndice

- [Vis√£o Geral](#vis√£o-geral)
- [Estado Atual](#estado-atual)
- [Tipos Suportados](#tipos-suportados)
- [Conceitos B√°sicos](#conceitos-b√°sicos)
- [Exportando Fun√ß√µes FFI](#exportando-fun√ß√µes-ffi)
- [Casos de Uso](#casos-de-uso)
- [Desenvolvimento Futuro](#desenvolvimento-futuro)
- [Callbacks FFI](#callbacks-ffi)
- [Structs FFI](#structs-ffi)
- [Limita√ß√µes Atuais](#limita√ß√µes-atuais)
- [Melhores Pr√°ticas](#melhores-pr√°ticas)

## Vis√£o Geral

A Interface de Fun√ß√µes Estrangeiras (FFI) permite que programas Hemlock:
- Chamem fun√ß√µes C de bibliotecas compartilhadas (.so, .dylib, .dll)
- Usem bibliotecas C existentes sem escrever c√≥digo wrapper
- Acessem APIs do sistema diretamente
- Integrem com bibliotecas nativas de terceiros
- Fa√ßam ponte entre Hemlock e funcionalidade de baixo n√≠vel do sistema

**Capacidades Principais:**
- Carregamento din√¢mico de bibliotecas
- Binding de fun√ß√µes C
- Convers√£o autom√°tica de tipos entre Hemlock e C
- Suporte a todos os tipos primitivos
- Implementa√ß√£o baseada em libffi para portabilidade

## Estado Atual

O suporte FFI em Hemlock possui as seguintes caracter√≠sticas:

**Implementado:**
- Chamar fun√ß√µes C de bibliotecas compartilhadas
- Suporte a todos os tipos primitivos (inteiros, floats, ponteiros)
- Convers√£o autom√°tica de tipos
- Implementa√ß√£o baseada em libffi
- Carregamento din√¢mico de bibliotecas
- **Callbacks de ponteiro de fun√ß√£o** - passar fun√ß√µes Hemlock para C
- **Exportar fun√ß√µes extern** - compartilhar bindings FFI entre m√≥dulos
- **Passagem e retorno de structs** - passar structs compat√≠veis com C por valor
- **Fun√ß√µes auxiliares de ponteiro completas** - ler/escrever todos os tipos (i8-i64, u8-u64, f32, f64, ptr)
- **Convers√£o buffer/ponteiro** - `buffer_ptr()`, `ptr_to_buffer()`
- **Tamanhos de tipo FFI** - `ffi_sizeof()` para tamanhos de tipo conscientes da plataforma
- **Tipos de plataforma** - suporte para `size_t`, `usize`, `isize`, `intptr_t`

**Em Desenvolvimento:**
- Helpers de marshaling de strings
- Melhorias no tratamento de erros

## Tipos Suportados

### Tipos Primitivos

Os seguintes tipos Hemlock podem ser passados para ou retornados de fun√ß√µes C:

| Tipo Hemlock | Tipo C | Tamanho | Descri√ß√£o |
|--------------|--------|---------|-----------|
| `i8` | `int8_t` | 1 byte | Inteiro com sinal de 8 bits |
| `i16` | `int16_t` | 2 bytes | Inteiro com sinal de 16 bits |
| `i32` | `int32_t` | 4 bytes | Inteiro com sinal de 32 bits |
| `i64` | `int64_t` | 8 bytes | Inteiro com sinal de 64 bits |
| `u8` | `uint8_t` | 1 byte | Inteiro sem sinal de 8 bits |
| `u16` | `uint16_t` | 2 bytes | Inteiro sem sinal de 16 bits |
| `u32` | `uint32_t` | 4 bytes | Inteiro sem sinal de 32 bits |
| `u64` | `uint64_t` | 8 bytes | Inteiro sem sinal de 64 bits |
| `f32` | `float` | 4 bytes | Ponto flutuante de 32 bits |
| `f64` | `double` | 8 bytes | Ponto flutuante de 64 bits |
| `ptr` | `void*` | 8 bytes | Ponteiro bruto |

### Convers√£o de Tipos

**Convers√£o Autom√°tica:**
- Inteiros Hemlock -> Inteiros C (com verifica√ß√£o de range)
- Floats Hemlock -> Floats C
- Ponteiros Hemlock -> Ponteiros C
- Valores de retorno C -> Valores Hemlock

**Exemplos de Mapeamento de Tipos:**
```hemlock
// Hemlock -> C
let i: i32 = 42;         // -> int32_t (4 bytes)
let f: f64 = 3.14;       // -> double (8 bytes)
let p: ptr = alloc(64);  // -> void* (8 bytes)

// C -> Hemlock (valores de retorno)
// int32_t foo() -> i32
// double bar() -> f64
// void* baz() -> ptr
```

## Conceitos B√°sicos

### Bibliotecas Compartilhadas

FFI trabalha com bibliotecas compartilhadas compiladas:

**Linux:** arquivos `.so`
```
libexample.so
/usr/lib/libm.so
```

**macOS:** arquivos `.dylib`
```
libexample.dylib
/usr/lib/libSystem.dylib
```

**Windows:** arquivos `.dll`
```
example.dll
kernel32.dll
```

### Assinaturas de Fun√ß√£o

Fun√ß√µes C devem ter assinaturas conhecidas para que FFI funcione:

```c
// Exemplos de assinaturas de fun√ß√µes C
int add(int a, int b);
double sqrt(double x);
void* malloc(size_t size);
void free(void* ptr);
```

Uma vez que a biblioteca √© carregada e fun√ß√µes s√£o vinculadas, elas podem ser chamadas do Hemlock.

### Compatibilidade de Plataforma

FFI usa **libffi** para portabilidade:
- Funciona em x86, x86-64, ARM, ARM64
- Trata conven√ß√µes de chamada automaticamente
- Abstrai detalhes de ABI espec√≠ficos da plataforma
- Suporta Linux, macOS, Windows (com libffi apropriada)

## Exportando Fun√ß√µes FFI

Fun√ß√µes FFI declaradas com `extern fn` podem ser exportadas de m√≥dulos, permitindo criar wrappers de biblioteca reutiliz√°veis que podem ser compartilhados entre m√∫ltiplos arquivos.

### Sintaxe B√°sica de Exporta√ß√£o

```hemlock
// string_utils.hml - m√≥dulo de biblioteca wrapping fun√ß√µes de string C
import "libc.so.6";

// Exportar fun√ß√µes extern diretamente
export extern fn strlen(s: string): i32;
export extern fn strcmp(s1: string, s2: string): i32;

// Voc√™ tamb√©m pode exportar fun√ß√µes wrapper junto com fun√ß√µes extern
export fn string_length(s: string): i32 {
    return strlen(s);
}

export fn strings_equal(a: string, b: string): bool {
    return strcmp(a, b) == 0;
}
```

### Importando Fun√ß√µes FFI Exportadas

```hemlock
// main.hml - usando fun√ß√µes FFI exportadas
import { strlen, string_length, strings_equal } from "./string_utils.hml";

let msg = "Hello, World!";
print(strlen(msg));           // 13 - chamada extern direta
print(string_length(msg));    // 13 - fun√ß√£o wrapper

print(strings_equal("foo", "foo"));  // true
print(strings_equal("foo", "bar"));  // false
```

### Casos de Uso para Export Extern

**1. Abstra√ß√£o de Plataforma**
```hemlock
// platform.hml - abstrair diferen√ßas de plataforma
import "libc.so.6";  // Linux

export extern fn getpid(): i32;
export extern fn getuid(): i32;
export extern fn geteuid(): i32;
```

**2. Wrappers de Biblioteca**
```hemlock
// crypto_lib.hml - wrapping fun√ß√µes de biblioteca de criptografia
import "libcrypto.so";

export extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;
export extern fn MD5(data: ptr, len: u64, out: ptr): ptr;

// Adicionar wrappers amig√°veis ao Hemlock
export fn sha256_string(s: string): string {
    // Implementa√ß√£o usando fun√ß√µes extern
}
```

**3. Declara√ß√µes FFI Centralizadas**
```hemlock
// libc.hml - m√≥dulo central para bindings libc
import "libc.so.6";

// Fun√ß√µes de string
export extern fn strlen(s: string): i32;
export extern fn strcpy(dest: ptr, src: string): ptr;
export extern fn strcat(dest: ptr, src: string): ptr;

// Fun√ß√µes de mem√≥ria
export extern fn malloc(size: u64): ptr;
export extern fn realloc(p: ptr, size: u64): ptr;
export extern fn calloc(nmemb: u64, size: u64): ptr;

// Fun√ß√µes de processo
export extern fn getpid(): i32;
export extern fn getppid(): i32;
export extern fn getenv(name: string): ptr;
```

Ent√£o use em todo o seu projeto:
```hemlock
import { strlen, malloc, getpid } from "./libc.hml";
```

## Casos de Uso

### 1. Bibliotecas do Sistema

Acessar fun√ß√µes da biblioteca C padr√£o:

**Fun√ß√µes Matem√°ticas:**
```hemlock
// Chamar sqrt de libm
let result = sqrt(16.0);  // 4.0
```

**Aloca√ß√£o de Mem√≥ria:**
```hemlock
// Chamar malloc/free de libc
let ptr = malloc(1024);
free(ptr);
```

### 2. Bibliotecas de Terceiros

Usar bibliotecas C existentes:

**Exemplo: Processamento de Imagem**
```hemlock
// Carregar libpng ou libjpeg
// Processar imagens usando fun√ß√µes de biblioteca C
```

**Exemplo: Criptografia**
```hemlock
// Usar OpenSSL ou libsodium
// Criptografia/descriptografia via FFI
```

### 3. APIs do Sistema

Chamadas diretas ao sistema:

**Exemplo: API POSIX**
```hemlock
// Chamar getpid, getuid, etc.
// Acessar funcionalidade de baixo n√≠vel do sistema
```

### 4. C√≥digo Cr√≠tico para Desempenho

Chamar implementa√ß√µes C otimizadas:

```hemlock
// Usar bibliotecas C altamente otimizadas
// Opera√ß√µes SIMD, c√≥digo vetorizado
// Fun√ß√µes aceleradas por hardware
```

## Callbacks FFI

Hemlock suporta passar fun√ß√µes como callbacks para c√≥digo C usando closures libffi. Isso permite integra√ß√£o com APIs C que esperam ponteiros de fun√ß√£o, como `qsort`, event loops e bibliotecas baseadas em callback.

### Criando Callbacks

Use `callback()` para criar um ponteiro de fun√ß√£o cham√°vel por C a partir de uma fun√ß√£o Hemlock:

```hemlock
// callback(function, param_types, return_type) -> ptr
let cb = callback(my_function, ["ptr", "ptr"], "i32");
```

**Par√¢metros:**
- `function`: A fun√ß√£o Hemlock a ser wrapped
- `param_types`: Array de strings de nomes de tipo (como `["ptr", "i32"]`)
- `return_type`: String de tipo de retorno (como `"i32"`, `"void"`)

**Tipos de Callback Suportados:**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - Inteiros com sinal
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - Inteiros sem sinal
- `"f32"`, `"f64"` - Floats
- `"ptr"` - Ponteiros
- `"void"` - Sem retorno
- `"bool"` - Booleano

### Exemplo: qsort

```hemlock
import "libc.so.6";
extern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;

// Fun√ß√£o de compara√ß√£o de inteiros (ordem crescente)
fn compare_ints(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    if (va < vb) { return -1; }
    if (va > vb) { return 1; }
    return 0;
}

// Alocar array de 5 inteiros
let arr = alloc(20);  // 5 * 4 bytes
ptr_write_i32(arr, 5);
ptr_write_i32(ptr_offset(arr, 1, 4), 2);
ptr_write_i32(ptr_offset(arr, 2, 4), 8);
ptr_write_i32(ptr_offset(arr, 3, 4), 1);
ptr_write_i32(ptr_offset(arr, 4, 4), 9);

// Criar callback e ordenar
let cmp = callback(compare_ints, ["ptr", "ptr"], "i32");
qsort(arr, 5, 4, cmp);

// Array agora ordenado: [1, 2, 5, 8, 9]

// Limpar
callback_free(cmp);
free(arr);
```

### Fun√ß√µes Auxiliares de Ponteiro

Hemlock fornece fun√ß√µes auxiliares abrangentes para trabalhar com ponteiros brutos. Estas s√£o essenciais para callbacks FFI e manipula√ß√£o direta de mem√≥ria.

#### Auxiliares de Tipo Inteiro

| Fun√ß√£o | Descri√ß√£o |
|--------|-----------|
| `ptr_deref_i8(ptr)` | Desreferenciar ponteiro, ler i8 |
| `ptr_deref_i16(ptr)` | Desreferenciar ponteiro, ler i16 |
| `ptr_deref_i32(ptr)` | Desreferenciar ponteiro, ler i32 |
| `ptr_deref_i64(ptr)` | Desreferenciar ponteiro, ler i64 |
| `ptr_deref_u8(ptr)` | Desreferenciar ponteiro, ler u8 |
| `ptr_deref_u16(ptr)` | Desreferenciar ponteiro, ler u16 |
| `ptr_deref_u32(ptr)` | Desreferenciar ponteiro, ler u32 |
| `ptr_deref_u64(ptr)` | Desreferenciar ponteiro, ler u64 |
| `ptr_write_i8(ptr, value)` | Escrever i8 na localiza√ß√£o do ponteiro |
| `ptr_write_i16(ptr, value)` | Escrever i16 na localiza√ß√£o do ponteiro |
| `ptr_write_i32(ptr, value)` | Escrever i32 na localiza√ß√£o do ponteiro |
| `ptr_write_i64(ptr, value)` | Escrever i64 na localiza√ß√£o do ponteiro |
| `ptr_write_u8(ptr, value)` | Escrever u8 na localiza√ß√£o do ponteiro |
| `ptr_write_u16(ptr, value)` | Escrever u16 na localiza√ß√£o do ponteiro |
| `ptr_write_u32(ptr, value)` | Escrever u32 na localiza√ß√£o do ponteiro |
| `ptr_write_u64(ptr, value)` | Escrever u64 na localiza√ß√£o do ponteiro |

#### Auxiliares de Tipo Float

| Fun√ß√£o | Descri√ß√£o |
|--------|-----------|
| `ptr_deref_f32(ptr)` | Desreferenciar ponteiro, ler f32 (float) |
| `ptr_deref_f64(ptr)` | Desreferenciar ponteiro, ler f64 (double) |
| `ptr_write_f32(ptr, value)` | Escrever f32 na localiza√ß√£o do ponteiro |
| `ptr_write_f64(ptr, value)` | Escrever f64 na localiza√ß√£o do ponteiro |

#### Auxiliares de Tipo Ponteiro

| Fun√ß√£o | Descri√ß√£o |
|--------|-----------|
| `ptr_deref_ptr(ptr)` | Desreferenciar ponteiro para ponteiro |
| `ptr_write_ptr(ptr, value)` | Escrever ponteiro na localiza√ß√£o do ponteiro |
| `ptr_offset(ptr, index, size)` | Calcular offset: `ptr + index * size` |
| `ptr_read_i32(ptr)` | Ler i32 via ponteiro para ponteiro (para callbacks qsort) |
| `ptr_null()` | Obter constante ponteiro nulo |

#### Auxiliares de Convers√£o Buffer

| Fun√ß√£o | Descri√ß√£o |
|--------|-----------|
| `buffer_ptr(buffer)` | Obter ponteiro bruto de buffer |
| `ptr_to_buffer(ptr, size)` | Copiar dados de ponteiro para novo buffer |

#### Utilit√°rios FFI

| Fun√ß√£o | Descri√ß√£o |
|--------|-----------|
| `ffi_sizeof(type_name)` | Obter tamanho em bytes de tipo FFI |

**Nomes de tipo suportados por `ffi_sizeof`:**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - Inteiros com sinal (1, 2, 4, 8 bytes)
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - Inteiros sem sinal (1, 2, 4, 8 bytes)
- `"f32"`, `"f64"` - Floats (4, 8 bytes)
- `"ptr"` - Ponteiro (8 bytes em sistemas 64-bit)
- `"size_t"`, `"usize"` - Tipo de tamanho dependente da plataforma
- `"intptr_t"`, `"isize"` - Tipo de ponteiro com sinal dependente da plataforma

### Liberando Callbacks

**Importante:** Sempre libere callbacks ap√≥s o uso para prevenir vazamentos de mem√≥ria:

```hemlock
let cb = callback(my_fn, ["ptr"], "void");
// ... usar callback ...
callback_free(cb);  // Liberar quando terminar de usar
```

Callbacks tamb√©m s√£o liberados automaticamente na sa√≠da do programa.

### Closures em Callbacks

Callbacks capturam seu ambiente de closure, ent√£o podem acessar vari√°veis do escopo externo:

```hemlock
let multiplier = 10;

fn scale(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    // Pode acessar 'multiplier' do escopo externo
    return (va * multiplier) - (vb * multiplier);
}

let cmp = callback(scale, ["ptr", "ptr"], "i32");
```

### Seguran√ßa de Thread

Invoca√ß√µes de callback s√£o serializadas via mutex para garantir seguran√ßa de thread, pois o interpretador Hemlock n√£o √© completamente thread-safe. Isso significa:
- Apenas um callback pode executar por vez
- Seguro para usar com bibliotecas C multi-threaded
- Pode impactar desempenho se callbacks s√£o chamados frequentemente de m√∫ltiplas threads

### Tratamento de Erros em Callbacks

Exce√ß√µes lan√ßadas em callbacks n√£o podem propagar para c√≥digo C. Em vez disso:
- Um aviso √© impresso em stderr
- O callback retorna um valor padr√£o (0 ou NULL)
- A exce√ß√£o √© registrada mas n√£o propagada

```hemlock
fn risky_callback(a: ptr): i32 {
    throw "Something went wrong";  // Imprime aviso, retorna 0
}
```

Para tratamento de erros robusto, valide entradas e evite lan√ßar em callbacks.

## Structs FFI

Hemlock suporta passar structs por valor para fun√ß√µes C. Tipos de struct s√£o automaticamente registrados para FFI quando voc√™ os define com anota√ß√µes de tipo.

### Definindo Structs Compat√≠veis com FFI

Uma struct √© compat√≠vel com FFI quando todos os campos t√™m anota√ß√µes de tipo expl√≠citas usando tipos compat√≠veis com FFI:

```hemlock
// Struct compat√≠vel com FFI
define Point {
    x: f64,
    y: f64,
}

// Struct compat√≠vel com FFI com m√∫ltiplos tipos de campo
define Rectangle {
    top_left: Point,      // Struct aninhada
    width: f64,
    height: f64,
}

// N√ÉO √© compat√≠vel com FFI (campos sem anota√ß√µes de tipo)
define DynamicObject {
    name,                 // Sem tipo - n√£o pode usar para FFI
    value,
}
```

### Usando Structs com FFI

Declare fun√ß√µes extern que usam tipos de struct:

```hemlock
// Definir tipo de struct
define Vector2D {
    x: f64,
    y: f64,
}

// Importar biblioteca C
import "libmath.so";

// Declarar fun√ß√µes extern que aceitam/retornam structs
extern fn vector_add(a: Vector2D, b: Vector2D): Vector2D;
extern fn vector_length(v: Vector2D): f64;

// Usar naturalmente
let a: Vector2D = { x: 3.0, y: 0.0 };
let b: Vector2D = { x: 0.0, y: 4.0 };
let result = vector_add(a, b);
print(result.x);  // 3.0
print(result.y);  // 4.0

let len = vector_length(result);
print(len);       // 5.0
```

### Tipos de Campo Suportados

Campos de struct devem usar estes tipos compat√≠veis com FFI:

| Tipo Hemlock | Tipo C | Tamanho |
|--------------|--------|---------|
| `i8` | `int8_t` | 1 byte |
| `i16` | `int16_t` | 2 bytes |
| `i32` | `int32_t` | 4 bytes |
| `i64` | `int64_t` | 8 bytes |
| `u8` | `uint8_t` | 1 byte |
| `u16` | `uint16_t` | 2 bytes |
| `u32` | `uint32_t` | 4 bytes |
| `u64` | `uint64_t` | 8 bytes |
| `f32` | `float` | 4 bytes |
| `f64` | `double` | 8 bytes |
| `ptr` | `void*` | 8 bytes |
| `string` | `char*` | 8 bytes |
| `bool` | `int` | Vari√°vel |
| Struct aninhada | struct | Vari√°vel |

### Layout de Struct

Hemlock usa as regras de layout de struct nativo da plataforma (correspondendo ao ABI C):
- Campos s√£o alinhados pelo seu tipo
- Padding √© inserido conforme necess√°rio
- Tamanho total √© padded para alinhar com o maior membro

```hemlock
// Exemplo: Layout compat√≠vel com C
define Mixed {
    a: i8,    // Offset 0, tamanho 1
              // 3 bytes de padding
    b: i32,   // Offset 4, tamanho 4
}
// Tamanho total: 8 bytes (incluindo padding)

define Point3D {
    x: f64,   // Offset 0, tamanho 8
    y: f64,   // Offset 8, tamanho 8
    z: f64,   // Offset 16, tamanho 8
}
// Tamanho total: 24 bytes (sem padding necess√°rio)
```

### Structs Aninhadas

Structs podem conter outras structs:

```hemlock
define Inner {
    x: i32,
    y: i32,
}

define Outer {
    inner: Inner,
    z: i32,
}

import "mylib.so";
extern fn process_nested(data: Outer): i32;

let obj: Outer = {
    inner: { x: 1, y: 2 },
    z: 3,
};
let result = process_nested(obj);
```

### Retorno de Struct

Fun√ß√µes C podem retornar structs:

```hemlock
define Point {
    x: f64,
    y: f64,
}

import "libmath.so";
extern fn get_origin(): Point;

let p = get_origin();
print(p.x);  // 0.0
print(p.y);  // 0.0
```

### Limita√ß√µes

- **Campos de struct devem ter anota√ß√µes de tipo** - Campos sem tipo n√£o s√£o compat√≠veis com FFI
- **Sem arrays em structs** - Use ponteiros em vez disso
- **Sem unions** - Apenas tipos de struct s√£o suportados
- **Callbacks n√£o podem retornar structs** - Use ponteiros para valores de retorno de callback

## Limita√ß√µes Atuais

FFI tem as seguintes limita√ß√µes:

**1. Convers√£o de Tipo Manual**
- Convers√£o de string deve ser gerenciada manualmente
- Sem convers√£o autom√°tica Hemlock string <-> C string

**2. Tratamento de Erros Limitado**
- Relat√≥rio de erros b√°sico
- Exce√ß√µes em callbacks n√£o podem propagar para C

**3. Carregamento Manual de Biblioteca**
- Bibliotecas devem ser carregadas manualmente
- Sem gera√ß√£o autom√°tica de bindings

**4. C√≥digo Espec√≠fico de Plataforma**
- Caminhos de biblioteca variam por plataforma
- Deve tratar .so vs .dylib vs .dll

## Melhores Pr√°ticas

Embora documenta√ß√£o abrangente de FFI ainda esteja em desenvolvimento, aqui est√£o melhores pr√°ticas gerais:

### 1. Seguran√ßa de Tipos

```hemlock
// Seja expl√≠cito sobre tipos
let x: i32 = 42;
let result: f64 = c_function(x);
```

### 2. Gerenciamento de Mem√≥ria

```hemlock
// Lembre de liberar mem√≥ria alocada
let ptr = c_malloc(1024);
// ... usar ptr
c_free(ptr);
```

### 3. Verifica√ß√£o de Erros

```hemlock
// Verifique valores de retorno
let result = c_function();
if (result == null) {
    print("C function failed");
}
```

### 4. Compatibilidade de Plataforma

```hemlock
// Trate diferen√ßas de plataforma
// Use extens√µes de biblioteca apropriadas (.so, .dylib, .dll)
```

## Resumo

O FFI do Hemlock oferece:

- Chamar fun√ß√µes C de bibliotecas compartilhadas
- Suporte a tipos primitivos (i8-i64, u8-u64, f32, f64, ptr)
- Convers√£o autom√°tica de tipos
- Portabilidade baseada em libffi
- Base para integra√ß√£o com bibliotecas nativas
- **Callbacks de ponteiro de fun√ß√£o** - passar fun√ß√µes Hemlock para C
- **Exportar fun√ß√µes extern** - compartilhar bindings FFI entre m√≥dulos
- **Passagem e retorno de struct** - passar structs compat√≠veis com C por valor
- **Exportar define** - compartilhar defini√ß√µes de tipo struct entre m√≥dulos (importados globalmente automaticamente)
- **Fun√ß√µes auxiliares de ponteiro completas** - ler/escrever todos os tipos (i8-i64, u8-u64, f32, f64, ptr)
- **Convers√£o buffer/ponteiro** - `buffer_ptr()`, `ptr_to_buffer()` para marshaling de dados
- **Tamanhos de tipo FFI** - `ffi_sizeof()` para tamanhos de tipo conscientes da plataforma
- **Tipos de plataforma** - suporte para `size_t`, `usize`, `isize`, `intptr_t`, `uintptr_t`

**Estado Atual:** FFI √© funcionalmente completo com suporte a tipos primitivos, structs, callbacks, exporta√ß√µes de m√≥dulo e fun√ß√µes auxiliares de ponteiro completas

**Futuro:** Helpers de marshaling de strings

**Casos de Uso:** Bibliotecas de sistema, bibliotecas de terceiros, qsort, event loops, APIs baseadas em callback, wrappers de biblioteca reutiliz√°veis


--------------------------------------------------------------------------------
## File IO
--------------------------------------------------------------------------------

# Hemlock E/S de Arquivos

Hemlock oferece uma **API de objetos de arquivo** para opera√ß√µes com arquivos, com tratamento de erros apropriado e gerenciamento de recursos.

## √çndice

- [Vis√£o Geral](#vis√£o-geral)
- [Abrindo Arquivos](#abrindo-arquivos)
- [M√©todos de Arquivo](#m√©todos-de-arquivo)
- [Propriedades de Arquivo](#propriedades-de-arquivo)
- [Tratamento de Erros](#tratamento-de-erros)
- [Gerenciamento de Recursos](#gerenciamento-de-recursos)
- [Refer√™ncia Completa da API](#refer√™ncia-completa-da-api)
- [Padr√µes Comuns](#padr√µes-comuns)
- [Melhores Pr√°ticas](#melhores-pr√°ticas)

## Vis√£o Geral

A API de objetos de arquivo oferece:

- **Gerenciamento expl√≠cito de recursos** - arquivos devem ser fechados manualmente
- **M√∫ltiplos modos de abertura** - leitura, escrita, append, leitura+escrita
- **Opera√ß√µes de texto e bin√°rio** - ler e escrever dados de texto e bin√°rios
- **Suporte a posicionamento** - acesso aleat√≥rio dentro de arquivos
- **Mensagens de erro abrangentes** - relat√≥rio de erros com contexto

**Importante:** Arquivos n√£o s√£o fechados automaticamente. Voc√™ deve chamar `f.close()` para evitar vazamentos de descritores de arquivo.

## Abrindo Arquivos

Use `open(path, mode?)` para abrir um arquivo:

```hemlock
let f = open("data.txt", "r");     // Modo leitura (padr√£o)
let f2 = open("output.txt", "w");  // Modo escrita (trunca)
let f3 = open("log.txt", "a");     // Modo append
let f4 = open("data.bin", "r+");   // Modo leitura+escrita
```

### Modos de Abertura

| Modo | Descri√ß√£o | Arquivo Deve Existir | Trunca | Posi√ß√£o |
|------|-----------|---------------------|--------|---------|
| `"r"` | Leitura (padr√£o) | Sim | N√£o | In√≠cio |
| `"w"` | Escrita | N√£o (cria) | Sim | In√≠cio |
| `"a"` | Append | N√£o (cria) | N√£o | Final |
| `"r+"` | Leitura+Escrita | Sim | N√£o | In√≠cio |
| `"w+"` | Leitura+Escrita | N√£o (cria) | Sim | In√≠cio |
| `"a+"` | Leitura e Append | N√£o (cria) | N√£o | Final |

### Exemplos

**Ler arquivo existente:**
```hemlock
let f = open("config.json", "r");
// Ou simplesmente:
let f = open("config.json");  // "r" √© o padr√£o
```

**Criar novo arquivo para escrita:**
```hemlock
let f = open("output.txt", "w");  // Cria ou trunca
```

**Adicionar ao arquivo:**
```hemlock
let f = open("log.txt", "a");  // Cria se n√£o existir
```

**Modo leitura+escrita:**
```hemlock
let f = open("data.bin", "r+");  // Arquivo existente, pode ler e escrever
```

## M√©todos de Arquivo

### Leitura

#### read(size?: i32): string

L√™ texto do arquivo (par√¢metro size opcional).

**Sem size (l√™ tudo):**
```hemlock
let f = open("data.txt", "r");
let all = f.read();  // L√™ da posi√ß√£o atual at√© EOF
f.close();
```

**Com size (l√™ bytes especificados):**
```hemlock
let f = open("data.txt", "r");
let chunk = f.read(1024);  // L√™ at√© 1024 bytes
let next = f.read(1024);   // L√™ pr√≥ximos 1024 bytes
f.close();
```

**Retorna:** String contendo os dados lidos, ou string vazia se no EOF

**Exemplo - Ler arquivo inteiro:**
```hemlock
let f = open("poem.txt", "r");
let content = f.read();
print(content);
f.close();
```

**Exemplo - Ler em chunks:**
```hemlock
let f = open("large.txt", "r");
while (true) {
    let chunk = f.read(4096);  // Chunks de 4KB
    if (chunk == "") { break; }  // Chegou ao EOF
    process(chunk);
}
f.close();
```

#### read_bytes(size: i32): buffer

L√™ dados bin√°rios (retorna buffer).

**Par√¢metros:**
- `size` (i32) - n√∫mero de bytes a ler

**Retorna:** Buffer contendo os bytes lidos

```hemlock
let f = open("image.png", "r");
let binary = f.read_bytes(256);  // L√™ 256 bytes
print(binary.length);  // 256 (ou menos se EOF)

// Acessar bytes individuais
let first_byte = binary[0];
print(first_byte);

f.close();
```

### Escrita

#### write(data: string): i32

Escreve texto no arquivo (retorna bytes escritos).

**Par√¢metros:**
- `data` (string) - texto a escrever

**Retorna:** N√∫mero de bytes escritos (i32)

```hemlock
let f = open("output.txt", "w");
let written = f.write("Hello, World!\n");
print("Wrote " + typeof(written) + " bytes");  // "Wrote 14 bytes"
f.close();
```

**Exemplo - Escrever m√∫ltiplas linhas:**
```hemlock
let f = open("output.txt", "w");
f.write("Line 1\n");
f.write("Line 2\n");
f.write("Line 3\n");
f.close();
```

**Exemplo - Adicionar ao arquivo de log:**
```hemlock
let f = open("app.log", "a");
f.write("[INFO] Application started\n");
f.write("[INFO] User logged in\n");
f.close();
```

#### write_bytes(data: buffer): i32

Escreve dados bin√°rios (retorna bytes escritos).

**Par√¢metros:**
- `data` (buffer) - dados bin√°rios a escrever

**Retorna:** N√∫mero de bytes escritos (i32)

```hemlock
let f = open("output.bin", "w");

// Criar dados bin√°rios
let buf = buffer(10);
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

let bytes = f.write_bytes(buf);
print("Wrote " + typeof(bytes) + " bytes");

f.close();
```

### Posicionamento

#### seek(position: i32): i32

Move para posi√ß√£o especificada (retorna nova posi√ß√£o).

**Par√¢metros:**
- `position` (i32) - offset em bytes desde o in√≠cio do arquivo

**Retorna:** Nova posi√ß√£o (i32)

```hemlock
let f = open("data.txt", "r");

// Mover para byte 100
f.seek(100);

// Ler da posi√ß√£o 100
let data = f.read(50);

// Resetar para o in√≠cio
f.seek(0);

f.close();
```

**Exemplo - Acesso aleat√≥rio:**
```hemlock
let f = open("records.dat", "r");

// Ler registro no offset 1000
f.seek(1000);
let record1 = f.read_bytes(100);

// Ler registro no offset 2000
f.seek(2000);
let record2 = f.read_bytes(100);

f.close();
```

#### tell(): i32

Obt√©m posi√ß√£o atual no arquivo.

**Retorna:** Offset atual em bytes (i32)

```hemlock
let f = open("data.txt", "r");

let pos1 = f.tell();  // 0 (no in√≠cio)

f.read(100);
let pos2 = f.tell();  // 100 (ap√≥s ler 100 bytes)

f.seek(500);
let pos3 = f.tell();  // 500 (ap√≥s seek)

f.close();
```

### Fechamento

#### close()

Fecha o arquivo (idempotente, pode ser chamado m√∫ltiplas vezes).

```hemlock
let f = open("data.txt", "r");
// ... usar arquivo
f.close();
f.close();  // Seguro - segundo close n√£o causa erro
```

**Notas importantes:**
- Sempre feche arquivos ap√≥s o uso para evitar vazamentos de descritores
- Close √© idempotente - pode ser chamado m√∫ltiplas vezes com seguran√ßa
- Ap√≥s fechar, todas as outras opera√ß√µes causar√£o erro
- Use blocos `finally` para garantir que arquivos sejam fechados mesmo em caso de erro

## Propriedades de Arquivo

Objetos de arquivo t√™m tr√™s propriedades somente-leitura:

### path: string

O caminho do arquivo usado para abrir o arquivo.

```hemlock
let f = open("/path/to/file.txt", "r");
print(f.path);  // "/path/to/file.txt"
f.close();
```

### mode: string

O modo com que o arquivo foi aberto.

```hemlock
let f = open("data.txt", "r");
print(f.mode);  // "r"
f.close();

let f2 = open("output.txt", "w");
print(f2.mode);  // "w"
f2.close();
```

### closed: bool

Se o arquivo est√° fechado.

```hemlock
let f = open("data.txt", "r");
print(f.closed);  // false

f.close();
print(f.closed);  // true
```

**Exemplo - Verificar se arquivo est√° aberto:**
```hemlock
let f = open("data.txt", "r");

if (!f.closed) {
    let content = f.read();
    // ... usar conte√∫do
}

f.close();

if (f.closed) {
    print("File is now closed");
}
```

## Tratamento de Erros

Todas as opera√ß√µes de arquivo incluem mensagens de erro apropriadas com contexto.

### Erros Comuns

**Arquivo n√£o encontrado:**
```hemlock
let f = open("missing.txt", "r");
// Erro: Failed to open 'missing.txt': No such file or directory
```

**Ler de arquivo fechado:**
```hemlock
let f = open("data.txt", "r");
f.close();
f.read();
// Erro: Cannot read from closed file 'data.txt'
```

**Escrever em arquivo somente-leitura:**
```hemlock
let f = open("readonly.txt", "r");
f.write("data");
// Erro: Cannot write to file 'readonly.txt' opened in read-only mode
```

**Ler de arquivo somente-escrita:**
```hemlock
let f = open("output.txt", "w");
f.read();
// Erro: Cannot read from file 'output.txt' opened in write-only mode
```

### Usando try/catch

```hemlock
try {
    let f = open("data.txt", "r");
    let content = f.read();
    f.close();
    process(content);
} catch (e) {
    print("Error reading file: " + e);
}
```

## Gerenciamento de Recursos

### Padr√£o B√°sico

Sempre feche arquivos explicitamente:

```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();
```

### Com Tratamento de Erros (Recomendado)

Use `finally` para garantir que arquivos sejam fechados mesmo em caso de erro:

```hemlock
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();  // Sempre fecha, mesmo em caso de erro
}
```

### M√∫ltiplos Arquivos

```hemlock
let src = null;
let dst = null;

try {
    src = open("input.txt", "r");
    dst = open("output.txt", "w");

    let content = src.read();
    dst.write(content);
} finally {
    if (src != null) { src.close(); }
    if (dst != null) { dst.close(); }
}
```

### Padr√£o com Fun√ß√£o Auxiliar

```hemlock
fn with_file(path: string, mode: string, callback) {
    let f = open(path, mode);
    try {
        return callback(f);
    } finally {
        f.close();
    }
}

// Uso:
with_file("data.txt", "r", fn(f) {
    return f.read();
});
```

## Refer√™ncia Completa da API

### Fun√ß√µes

| Fun√ß√£o | Par√¢metros | Retorno | Descri√ß√£o |
|--------|------------|---------|-----------|
| `open(path, mode?)` | path: string, mode?: string | File | Abre arquivo (modo padr√£o "r") |

### M√©todos

| M√©todo | Par√¢metros | Retorno | Descri√ß√£o |
|--------|------------|---------|-----------|
| `read(size?)` | size?: i32 | string | L√™ texto (tudo ou bytes especificados) |
| `read_bytes(size)` | size: i32 | buffer | L√™ dados bin√°rios |
| `write(data)` | data: string | i32 | Escreve texto, retorna bytes escritos |
| `write_bytes(data)` | data: buffer | i32 | Escreve dados bin√°rios, retorna bytes escritos |
| `seek(position)` | position: i32 | i32 | Posiciona na posi√ß√£o, retorna nova posi√ß√£o |
| `tell()` | - | i32 | Obt√©m posi√ß√£o atual |
| `close()` | - | null | Fecha arquivo (idempotente) |

### Propriedades (Somente Leitura)

| Propriedade | Tipo | Descri√ß√£o |
|-------------|------|-----------|
| `path` | string | Caminho do arquivo |
| `mode` | string | Modo de abertura |
| `closed` | bool | Se o arquivo est√° fechado |

## Padr√µes Comuns

### Ler Arquivo Inteiro

```hemlock
fn read_file(path: string): string {
    let f = open(path, "r");
    try {
        return f.read();
    } finally {
        f.close();
    }
}

let content = read_file("config.json");
```

### Escrever Arquivo Inteiro

```hemlock
fn write_file(path: string, content: string) {
    let f = open(path, "w");
    try {
        f.write(content);
    } finally {
        f.close();
    }
}

write_file("output.txt", "Hello, World!");
```

### Adicionar ao Arquivo

```hemlock
fn append_file(path: string, content: string) {
    let f = open(path, "a");
    try {
        f.write(content);
    } finally {
        f.close();
    }
}

append_file("log.txt", "[INFO] Event occurred\n");
```

### Ler Linhas

```hemlock
fn read_lines(path: string) {
    let f = open(path, "r");
    try {
        let content = f.read();
        return content.split("\n");
    } finally {
        f.close();
    }
}

let lines = read_lines("data.txt");
let i = 0;
while (i < lines.length) {
    print("Line " + typeof(i) + ": " + lines[i]);
    i = i + 1;
}
```

### Processar Arquivo Grande em Chunks

```hemlock
fn process_large_file(path: string) {
    let f = open(path, "r");
    try {
        while (true) {
            let chunk = f.read(4096);  // Chunks de 4KB
            if (chunk == "") { break; }

            // Processar chunk
            process_chunk(chunk);
        }
    } finally {
        f.close();
    }
}
```

### Copiar Arquivo Bin√°rio

```hemlock
fn copy_file(src_path: string, dst_path: string) {
    let src = null;
    let dst = null;

    try {
        src = open(src_path, "r");
        dst = open(dst_path, "w");

        while (true) {
            let chunk = src.read_bytes(4096);
            if (chunk.length == 0) { break; }

            dst.write_bytes(chunk);
        }
    } finally {
        if (src != null) { src.close(); }
        if (dst != null) { dst.close(); }
    }
}

copy_file("input.dat", "output.dat");
```

### Truncar Arquivo

```hemlock
fn truncate_file(path: string) {
    let f = open(path, "w");  // Modo "w" trunca
    f.close();
}

truncate_file("empty_me.txt");
```

### Leitura com Acesso Aleat√≥rio

```hemlock
fn read_at_offset(path: string, offset: i32, size: i32): string {
    let f = open(path, "r");
    try {
        f.seek(offset);
        return f.read(size);
    } finally {
        f.close();
    }
}

let data = read_at_offset("records.dat", 1000, 100);
```

## Melhores Pr√°ticas

### 1. Sempre Use try/finally

```hemlock
// Bom
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();
}

// Ruim - arquivo pode n√£o fechar em caso de erro
let f = open("data.txt", "r");
let content = f.read();
process(content);  // Se isso lan√ßar, arquivo vaza
f.close();
```

### 2. Verifique Estado do Arquivo Antes de Opera√ß√µes

```hemlock
let f = open("data.txt", "r");

if (!f.closed) {
    let content = f.read();
    // ... usar conte√∫do
}

f.close();
```

### 3. Use o Modo Apropriado

```hemlock
// Apenas leitura? Use "r"
let f = open("config.json", "r");

// Substituir completamente? Use "w"
let f = open("output.txt", "w");

// Adicionar ao final? Use "a"
let f = open("log.txt", "a");
```

### 4. Trate Erros Graciosamente

```hemlock
fn safe_read_file(path: string): string {
    try {
        let f = open(path, "r");
        try {
            return f.read();
        } finally {
            f.close();
        }
    } catch (e) {
        print("Warning: Could not read " + path + ": " + e);
        return "";
    }
}
```

### 5. Feche Arquivos na Ordem Inversa de Abertura

```hemlock
let f1 = null;
let f2 = null;
let f3 = null;

try {
    f1 = open("file1.txt", "r");
    f2 = open("file2.txt", "r");
    f3 = open("file3.txt", "r");

    // ... usar arquivos
} finally {
    // Fechar na ordem inversa
    if (f3 != null) { f3.close(); }
    if (f2 != null) { f2.close(); }
    if (f1 != null) { f1.close(); }
}
```

### 6. Evite Ler Arquivos Grandes Completamente

```hemlock
// Ruim para arquivos grandes
let f = open("huge.log", "r");
let content = f.read();  // Carrega arquivo inteiro na mem√≥ria
f.close();

// Bom - processar em chunks
let f = open("huge.log", "r");
try {
    while (true) {
        let chunk = f.read(4096);
        if (chunk == "") { break; }
        process_chunk(chunk);
    }
} finally {
    f.close();
}
```

## Resumo

A API de E/S de arquivos do Hemlock oferece:

- Opera√ß√µes de arquivo simples e expl√≠citas
- Suporte a texto e bin√°rio
- Acesso aleat√≥rio com seek/tell
- Mensagens de erro claras com contexto
- Opera√ß√£o close idempotente

Lembre-se:
- Sempre feche arquivos manualmente
- Use try/finally para garantir seguran√ßa de recursos
- Escolha o modo de abertura apropriado
- Trate erros graciosamente
- Processe arquivos grandes em chunks


--------------------------------------------------------------------------------
## Memory Ownership
--------------------------------------------------------------------------------

# Propriedade de Mem√≥ria no Hemlock

> "N√≥s te damos as ferramentas para ser seguro, mas n√£o te for√ßamos a us√°-las."

Este documento descreve a sem√¢ntica de propriedade de mem√≥ria no Hemlock, cobrindo tanto a mem√≥ria gerenciada pelo programador quanto os valores gerenciados pelo runtime.

## √çndice

1. [O Contrato](#o-contrato)
2. [Mem√≥ria Gerenciada pelo Programador](#mem√≥ria-gerenciada-pelo-programador)
3. [Valores Gerenciados pelo Runtime](#valores-gerenciados-pelo-runtime)
4. [Pontos de Transfer√™ncia de Propriedade](#pontos-de-transfer√™ncia-de-propriedade)
5. [Async e Concorr√™ncia](#async-e-concorr√™ncia)
6. [Regras de Mem√≥ria FFI](#regras-de-mem√≥ria-ffi)
7. [Seguran√ßa de Exce√ß√µes](#seguran√ßa-de-exce√ß√µes)
8. [Melhores Pr√°ticas](#melhores-pr√°ticas)

---

## O Contrato

Hemlock tem uma divis√£o clara de responsabilidade no gerenciamento de mem√≥ria:

| Tipo de Mem√≥ria | Gerenciado Por | M√©todo de Limpeza |
|-----------------|----------------|-------------------|
| Ponteiros brutos (`ptr`) | **Programador** | `free(ptr)` |
| Buffers (`buffer`) | **Programador** | `free(buf)` |
| Strings, Arrays, Objetos | **Runtime** | Autom√°tico (contagem de refer√™ncias) |
| Fun√ß√µes, Closures | **Runtime** | Autom√°tico (contagem de refer√™ncias) |
| Tasks, Channels | **Runtime** | Autom√°tico (contagem de refer√™ncias) |

**O princ√≠pio central:** Se voc√™ aloca explicitamente, voc√™ libera explicitamente. Todo o resto √© tratado automaticamente.

---

## Mem√≥ria Gerenciada pelo Programador

### Ponteiros Brutos

```hemlock
let p = alloc(64);       // Alocar 64 bytes
memset(p, 0, 64);        // Inicializar
// ... usar a mem√≥ria ...
free(p);                 // Sua responsabilidade!
```

**Regras:**
- `alloc()` retorna mem√≥ria que voc√™ possui
- Voc√™ deve chamar `free()` quando terminar
- Double-free causar√° crash (por design)
- Use-after-free √© comportamento indefinido
- Aritm√©tica de ponteiros √© permitida mas n√£o verificada

### Aloca√ß√£o Tipada

```hemlock
let arr = talloc("i32", 100);  // Alocar 100 i32s (400 bytes)
ptr_write_i32(arr, 0, 42);     // Escrever no √≠ndice 0
let val = ptr_read_i32(arr, 0); // Ler do √≠ndice 0
free(arr);                      // Ainda √© sua responsabilidade
```

### Buffers (Alternativa Segura)

```hemlock
let buf = buffer(64);    // Buffer com verifica√ß√£o de limites
buf[0] = 42;             // Indexa√ß√£o segura
// buf[100] = 1;         // Erro em tempo de execu√ß√£o: fora dos limites
free(buf);               // Ainda precisa de free expl√≠cito
```

**Diferen√ßa chave:** Buffers fornecem verifica√ß√£o de limites, ponteiros brutos n√£o.

---

## Valores Gerenciados pelo Runtime

### Contagem de Refer√™ncias

Valores alocados no heap usam contagem de refer√™ncias at√¥mica:

```hemlock
let s1 = "hello";        // String alocada, refcount = 1
let s2 = s1;             // s2 compartilha s1, refcount = 2
// Quando ambos saem do escopo, refcount ‚Üí 0, mem√≥ria liberada
```

**Tipos com contagem de refer√™ncias:**
- `string` - Texto UTF-8
- `array` - Arrays din√¢micos
- `object` - Objetos chave-valor
- `function` - Closures
- `task` - Handles de tasks async
- `channel` - Canais de comunica√ß√£o

### Detec√ß√£o de Ciclos

O runtime trata ciclos em grafos de objetos:

```hemlock
let a = { ref: null };
let b = { ref: a };
a.ref = b;               // Ciclo: a ‚Üí b ‚Üí a
// O runtime usa conjuntos visitados para detectar e quebrar ciclos durante a limpeza
```

---

## Pontos de Transfer√™ncia de Propriedade

### Binding de Vari√°veis

```hemlock
let x = [1, 2, 3];       // Array criado com refcount 1
                         // x possui a refer√™ncia
```

### Retornos de Fun√ß√µes

```hemlock
fn make_array() {
    return [1, 2, 3];    // Propriedade do array transferida para o chamador
}
let arr = make_array();  // arr agora possui a refer√™ncia
```

### Atribui√ß√£o

```hemlock
let a = "hello";
let b = a;               // Refer√™ncia compartilhada (refcount incrementado)
b = "world";             // a ainda tem "hello", b tem "world"
```

### Opera√ß√µes de Channel

```hemlock
let ch = channel(10);
ch.send("message");      // Valor copiado para o buffer do channel
                         // Original ainda v√°lido

let msg = ch.recv();     // Recebe propriedade do channel
```

### Spawning de Tasks

```hemlock
let data = { x: 1 };
let task = spawn(worker, data);  // data √© COPIADO PROFUNDAMENTE para isolamento
data.x = 2;                       // Seguro - task tem sua pr√≥pria c√≥pia
let result = join(task);          // Propriedade do result transferida para o chamador
```

---

## Async e Concorr√™ncia

### Isolamento de Threads

Tasks spawnadas recebem **c√≥pias profundas** de argumentos mut√°veis:

```hemlock
async fn worker(data) {
    data.x = 100;        // Modifica apenas a c√≥pia do task
    return data;
}

let obj = { x: 1 };
let task = spawn(worker, obj);
obj.x = 2;               // Seguro - n√£o afeta o task
let result = join(task);
print(obj.x);            // 2 (n√£o alterado pelo task)
print(result.x);         // 100 (c√≥pia modificada do task)
```

### Objetos de Coordena√ß√£o Compartilhados

Alguns tipos s√£o compartilhados por refer√™ncia (n√£o copiados):
- **Channels** - Para comunica√ß√£o entre tasks
- **Tasks** - Para coordena√ß√£o (join/detach)

```hemlock
let ch = channel(1);
spawn(producer, ch);     // Mesmo channel, n√£o uma c√≥pia
spawn(consumer, ch);     // Ambos os tasks compartilham o channel
```

### Resultados de Tasks

```hemlock
let task = spawn(compute);
let result = join(task);  // Chamador possui o resultado
                          // Refer√™ncia do task √© liberada quando o task √© liberado
```

### Tasks Desacopladas

```hemlock
detach(spawn(background_work));
// Task roda independentemente
// Resultado √© liberado automaticamente quando o task completa
// Sem leak mesmo que ningu√©m chame join()
```

---

## Regras de Mem√≥ria FFI

### Passando para Fun√ß√µes C

```hemlock
extern fn strlen(s: string): i32;

let s = "hello";
let len = strlen(s);     // Hemlock ret√©m a propriedade
                         // String √© v√°lida durante a chamada
                         // Fun√ß√£o C N√ÉO deve liber√°-la
```

### Recebendo de Fun√ß√µes C

```hemlock
extern fn strdup(s: string): ptr;

let copy = strdup("hello");  // C alocou esta mem√≥ria
free(copy);                   // Sua responsabilidade liberar
```

### Passagem de Structs (Apenas Compilador)

```hemlock
// Definir layout de struct C
ffi_struct Point { x: f64, y: f64 }

extern fn make_point(x: f64, y: f64): Point;

let p = make_point(1.0, 2.0);  // Retornado por valor, copiado
                                // N√£o precisa de limpeza para structs na stack
```

### Mem√≥ria de Callbacks

```hemlock
// Quando C chama de volta para Hemlock:
// - Argumentos pertencem a C (n√£o liberar)
// - Propriedade do valor de retorno transferida para C
```

---

## Seguran√ßa de Exce√ß√µes

### Garantias

O runtime fornece estas garantias:

1. **Sem leak em sa√≠da normal** - Todos os valores gerenciados pelo runtime s√£o limpos
2. **Sem leak em exce√ß√£o** - Tempor√°rios s√£o liberados durante o stack unwinding
3. **Defer executa em exce√ß√£o** - C√≥digo de limpeza √© executado

### Avalia√ß√£o de Express√µes

```hemlock
// Se isso lan√ßar durante a cria√ß√£o do array:
let arr = [f(), g(), h()];  // Array parcial √© liberado

// Se isso lan√ßar durante a chamada de fun√ß√£o:
foo(a(), b(), c());         // Args previamente avaliados s√£o liberados
```

### Defer para Limpeza

```hemlock
fn process_file() {
    let f = open("data.txt", "r");
    defer f.close();         // Executa no return OU exce√ß√£o

    let data = f.read();
    if (data == "") {
        throw "Empty file";  // f.close() ainda executa!
    }
    return data;
}
```

---

## Melhores Pr√°ticas

### 1. Prefira Tipos Gerenciados pelo Runtime

```hemlock
// Prefira isto:
let data = [1, 2, 3, 4, 5];

// A isto (a menos que precise de controle de baixo n√≠vel):
let data = talloc("i32", 5);
// ... deve lembrar de liberar ...
```

### 2. Use Defer para Mem√≥ria Manual

```hemlock
fn process() {
    let buf = alloc(1024);
    defer free(buf);        // Limpeza garantida

    // ... usar buf ...
    // N√£o precisa liberar em cada ponto de retorno
}
```

### 3. Evite Ponteiros Brutos em Async

```hemlock
// ERRADO - ponteiro pode ser liberado antes do task completar
let p = alloc(64);
spawn(worker, p);          // Task obt√©m o valor do ponteiro
free(p);                   // Ops! Task ainda est√° usando

// CERTO - use channels ou copie os dados
let ch = channel(1);
let data = buffer(64);
// ... preencher data ...
ch.send(data);             // C√≥pia profunda
spawn(worker, ch);
free(data);                // Seguro - task tem sua pr√≥pria c√≥pia
```

### 4. Feche Channels Quando Terminar

```hemlock
let ch = channel(10);
// ... usar channel ...
ch.close();                // Drena e libera valores no buffer
```

### 5. Join ou Detach Tasks

```hemlock
let task = spawn(work);

// Op√ß√£o 1: Esperar o resultado
let result = join(task);

// Op√ß√£o 2: Fire and forget
// detach(task);

// N√ÉO: Deixar o handle do task sair do escopo sem join ou detach
// (Ser√° limpo, mas o resultado pode ter leak)
```

---

## Depura√ß√£o de Problemas de Mem√≥ria

### Habilitar ASAN

```bash
make asan
ASAN_OPTIONS=detect_leaks=1 ./hemlock script.hml
```

### Executar Testes de Regress√£o de Leaks

```bash
make leak-regression       # Suite completa
make leak-regression-quick # Pular teste exaustivo
```

### Valgrind

```bash
make valgrind-check FILE=script.hml
```

---

## Resumo

| Opera√ß√£o | Comportamento de Mem√≥ria |
|----------|-------------------------|
| `alloc(n)` | Aloca, voc√™ libera |
| `buffer(n)` | Aloca com verifica√ß√£o de limites, voc√™ libera |
| `"string"` | Runtime gerencia |
| `[array]` | Runtime gerencia |
| `{object}` | Runtime gerencia |
| `spawn(fn)` | Copia profundamente args, runtime gerencia task |
| `join(task)` | Chamador possui resultado |
| `detach(task)` | Runtime libera resultado quando terminado |
| `ch.send(v)` | Copia valor para o channel |
| `ch.recv()` | Chamador possui valor recebido |
| `ch.close()` | Drena e libera valores no buffer |


--------------------------------------------------------------------------------
## Opera√ß√µes At√¥micas
--------------------------------------------------------------------------------

# Opera√ß√µes At√¥micas

Hemlock oferece opera√ß√µes at√¥micas para **programa√ß√£o concorrente lock-free**. Essas opera√ß√µes permitem manipular mem√≥ria compartilhada com seguran√ßa entre m√∫ltiplas threads, sem necessidade de locks ou mutexes tradicionais.

## √çndice

- [Vis√£o Geral](#vis√£o-geral)
- [Quando Usar Opera√ß√µes At√¥micas](#quando-usar-opera√ß√µes-at√¥micas)
- [Modelo de Mem√≥ria](#modelo-de-mem√≥ria)
- [Load e Store At√¥micos](#load-e-store-at√¥micos)
- [Opera√ß√µes Fetch-and-Modify](#opera√ß√µes-fetch-and-modify)
- [Compare-and-Swap (CAS)](#compare-and-swap-cas)
- [Exchange At√¥mico](#exchange-at√¥mico)
- [Barreiras de Mem√≥ria](#barreiras-de-mem√≥ria)
- [Refer√™ncia de Fun√ß√µes](#refer√™ncia-de-fun√ß√µes)
- [Padr√µes Comuns](#padr√µes-comuns)
- [Melhores Pr√°ticas](#melhores-pr√°ticas)
- [Limita√ß√µes](#limita√ß√µes)

---

## Vis√£o Geral

Opera√ß√µes at√¥micas s√£o opera√ß√µes **indivis√≠veis** que completam sem possibilidade de interrup√ß√£o. Quando uma thread executa uma opera√ß√£o at√¥mica, outras threads n√£o podem observar um estado parcialmente completado da opera√ß√£o.

**Caracter√≠sticas Principais:**
- Todas as opera√ß√µes usam **consist√™ncia sequencial** (`memory_order_seq_cst`)
- Tipos suportados: **i32** e **i64**
- Opera√ß√µes funcionam em ponteiros brutos alocados via `alloc()`
- Garantia de thread-safety sem locks expl√≠citos

**Opera√ß√µes Dispon√≠veis:**
- Load/Store - leitura e escrita at√¥mica de valores
- Add/Sub - opera√ß√µes aritm√©ticas que retornam o valor antigo
- And/Or/Xor - opera√ß√µes bitwise que retornam o valor antigo
- CAS - compare-and-swap para atualiza√ß√µes condicionais
- Exchange - troca at√¥mica de valores
- Fence - barreira de mem√≥ria completa

---

## Quando Usar Opera√ß√µes At√¥micas

**Use opera√ß√µes at√¥micas para:**
- Contadores compartilhados entre tarefas (ex: contagem de requisi√ß√µes, rastreamento de progresso)
- Flags e indicadores de estado
- Estruturas de dados lock-free
- Primitivas de sincroniza√ß√£o simples
- C√≥digo concorrente cr√≠tico para desempenho

**Use canais em vez disso para:**
- Passar dados complexos entre tarefas
- Implementar padr√µes produtor-consumidor
- Quando sem√¢ntica de passagem de mensagens √© necess√°ria

**Exemplo de Uso - Contador Compartilhado:**
```hemlock
// Alocar contador compartilhado
let counter = alloc(4);
ptr_write_i32(counter, 0);

async fn worker(counter: ptr, id: i32) {
    let i = 0;
    while (i < 1000) {
        atomic_add_i32(counter, 1);
        i = i + 1;
    }
}

// Criar m√∫ltiplos workers
let t1 = spawn(worker, counter, 1);
let t2 = spawn(worker, counter, 2);
let t3 = spawn(worker, counter, 3);

join(t1);
join(t2);
join(t3);

// Contador ser√° exatamente 3000 (sem corrida de dados)
print(atomic_load_i32(counter));

free(counter);
```

---

## Modelo de Mem√≥ria

Todas as opera√ß√µes at√¥micas do Hemlock usam **consist√™ncia sequencial** (`memory_order_seq_cst`), fornecendo as garantias mais fortes de ordena√ß√£o de mem√≥ria:

1. **Atomicidade**: Cada opera√ß√£o √© indivis√≠vel
2. **Ordena√ß√£o Global**: Todas as threads veem a mesma ordem de opera√ß√µes
3. **Sem Reordena√ß√£o**: Opera√ß√µes n√£o s√£o reordenadas pelo compilador ou CPU

Isso torna o racioc√≠nio sobre c√≥digo concorrente mais simples, mas pode ter algum custo de desempenho comparado a ordena√ß√µes de mem√≥ria mais fracas.

---

## Load e Store At√¥micos

### atomic_load_i32 / atomic_load_i64

L√™ atomicamente um valor da mem√≥ria.

**Assinatura:**
```hemlock
atomic_load_i32(ptr: ptr): i32
atomic_load_i64(ptr: ptr): i64
```

**Par√¢metros:**
- `ptr` - ponteiro para a localiza√ß√£o de mem√≥ria (deve estar corretamente alinhado)

**Retorna:** O valor na localiza√ß√£o de mem√≥ria

**Exemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);

let value = atomic_load_i32(p);
print(value);  // 42

free(p);
```

---

### atomic_store_i32 / atomic_store_i64

Escreve atomicamente um valor na mem√≥ria.

**Assinatura:**
```hemlock
atomic_store_i32(ptr: ptr, value: i32): null
atomic_store_i64(ptr: ptr, value: i64): null
```

**Par√¢metros:**
- `ptr` - ponteiro para a localiza√ß√£o de mem√≥ria
- `value` - valor a armazenar

**Retorna:** `null`

**Exemplo:**
```hemlock
let p = alloc(8);

atomic_store_i64(p, 5000000000);
print(atomic_load_i64(p));  // 5000000000

free(p);
```

---

## Opera√ß√µes Fetch-and-Modify

Essas opera√ß√µes modificam atomicamente um valor e retornam o valor **antigo** (anterior).

### atomic_add_i32 / atomic_add_i64

Adi√ß√£o at√¥mica.

**Assinatura:**
```hemlock
atomic_add_i32(ptr: ptr, value: i32): i32
atomic_add_i64(ptr: ptr, value: i64): i64
```

**Retorna:** Valor **antigo** (antes da adi√ß√£o)

**Exemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_add_i32(p, 10);
print(old);                    // 100 (valor antigo)
print(atomic_load_i32(p));     // 110 (valor novo)

free(p);
```

---

### atomic_sub_i32 / atomic_sub_i64

Subtra√ß√£o at√¥mica.

**Assinatura:**
```hemlock
atomic_sub_i32(ptr: ptr, value: i32): i32
atomic_sub_i64(ptr: ptr, value: i64): i64
```

**Retorna:** Valor **antigo** (antes da subtra√ß√£o)

**Exemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_sub_i32(p, 25);
print(old);                    // 100 (valor antigo)
print(atomic_load_i32(p));     // 75 (valor novo)

free(p);
```

---

### atomic_and_i32 / atomic_and_i64

AND bitwise at√¥mico.

**Assinatura:**
```hemlock
atomic_and_i32(ptr: ptr, value: i32): i32
atomic_and_i64(ptr: ptr, value: i64): i64
```

**Retorna:** Valor **antigo** (antes da opera√ß√£o AND)

**Exemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xFF);  // Bin√°rio 255: 11111111

let old = atomic_and_i32(p, 0x0F);  // AND com 00001111
print(old);                    // 255 (valor antigo)
print(atomic_load_i32(p));     // 15 (0xFF & 0x0F = 0x0F)

free(p);
```

---

### atomic_or_i32 / atomic_or_i64

OR bitwise at√¥mico.

**Assinatura:**
```hemlock
atomic_or_i32(ptr: ptr, value: i32): i32
atomic_or_i64(ptr: ptr, value: i64): i64
```

**Retorna:** Valor **antigo** (antes da opera√ß√£o OR)

**Exemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0x0F);  // Bin√°rio 15: 00001111

let old = atomic_or_i32(p, 0xF0);  // OR com 11110000
print(old);                    // 15 (valor antigo)
print(atomic_load_i32(p));     // 255 (0x0F | 0xF0 = 0xFF)

free(p);
```

---

### atomic_xor_i32 / atomic_xor_i64

XOR bitwise at√¥mico.

**Assinatura:**
```hemlock
atomic_xor_i32(ptr: ptr, value: i32): i32
atomic_xor_i64(ptr: ptr, value: i64): i64
```

**Retorna:** Valor **antigo** (antes da opera√ß√£o XOR)

**Exemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xAA);  // Bin√°rio 170: 10101010

let old = atomic_xor_i32(p, 0xFF);  // XOR com 11111111
print(old);                    // 170 (valor antigo)
print(atomic_load_i32(p));     // 85 (0xAA ^ 0xFF = 0x55)

free(p);
```

---

## Compare-and-Swap (CAS)

A opera√ß√£o at√¥mica mais poderosa. Compara atomicamente o valor atual com um valor esperado e, se coincidirem, substitui pelo novo valor.

### atomic_cas_i32 / atomic_cas_i64

**Assinatura:**
```hemlock
atomic_cas_i32(ptr: ptr, expected: i32, desired: i32): bool
atomic_cas_i64(ptr: ptr, expected: i64, desired: i64): bool
```

**Par√¢metros:**
- `ptr` - ponteiro para a localiza√ß√£o de mem√≥ria
- `expected` - valor que esperamos encontrar
- `desired` - valor a armazenar se expected coincidir

**Retorna:**
- `true` - troca bem-sucedida (valor era `expected`, agora √© `desired`)
- `false` - troca falhou (valor n√£o era `expected`, permanece inalterado)

**Exemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

// CAS bem-sucedido: valor √© 100, troca para 999
let success1 = atomic_cas_i32(p, 100, 999);
print(success1);               // true
print(atomic_load_i32(p));     // 999

// CAS falhou: valor √© 999, n√£o 100
let success2 = atomic_cas_i32(p, 100, 888);
print(success2);               // false
print(atomic_load_i32(p));     // 999 (inalterado)

free(p);
```

**Casos de Uso:**
- Implementar locks e sem√°foros
- Estruturas de dados lock-free
- Controle de concorr√™ncia otimista
- Atualiza√ß√µes condicionais at√¥micas

---

## Exchange At√¥mico

Troca atomicamente valores, retornando o valor antigo.

### atomic_exchange_i32 / atomic_exchange_i64

**Assinatura:**
```hemlock
atomic_exchange_i32(ptr: ptr, value: i32): i32
atomic_exchange_i64(ptr: ptr, value: i64): i64
```

**Par√¢metros:**
- `ptr` - ponteiro para a localiza√ß√£o de mem√≥ria
- `value` - novo valor a armazenar

**Retorna:** Valor **antigo** (antes da troca)

**Exemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_exchange_i32(p, 200);
print(old);                    // 100 (valor antigo)
print(atomic_load_i32(p));     // 200 (valor novo)

free(p);
```

---

## Barreiras de Mem√≥ria

Barreira de mem√≥ria completa, garantindo que todas as opera√ß√µes de mem√≥ria antes da barreira sejam vis√≠veis para todas as threads antes de qualquer opera√ß√£o ap√≥s a barreira ser executada.

### atomic_fence

**Assinatura:**
```hemlock
atomic_fence(): null
```

**Retorna:** `null`

**Exemplo:**
```hemlock
// Garantir que todas as escritas anteriores s√£o vis√≠veis para outras threads
atomic_fence();
```

**Nota:** Na maioria dos casos, voc√™ n√£o precisa de fences expl√≠citos pois todas as opera√ß√µes at√¥micas j√° usam consist√™ncia sequencial. Fences s√£o √∫teis quando voc√™ precisa sincronizar opera√ß√µes de mem√≥ria n√£o-at√¥micas.

---

## Refer√™ncia de Fun√ß√µes

### Opera√ß√µes i32

| Fun√ß√£o | Assinatura | Retorno | Descri√ß√£o |
|--------|------------|---------|-----------|
| `atomic_load_i32` | `(ptr)` | `i32` | Carrega valor atomicamente |
| `atomic_store_i32` | `(ptr, value)` | `null` | Armazena valor atomicamente |
| `atomic_add_i32` | `(ptr, value)` | `i32` | Adiciona e retorna valor antigo |
| `atomic_sub_i32` | `(ptr, value)` | `i32` | Subtrai e retorna valor antigo |
| `atomic_and_i32` | `(ptr, value)` | `i32` | AND bitwise e retorna valor antigo |
| `atomic_or_i32` | `(ptr, value)` | `i32` | OR bitwise e retorna valor antigo |
| `atomic_xor_i32` | `(ptr, value)` | `i32` | XOR bitwise e retorna valor antigo |
| `atomic_cas_i32` | `(ptr, expected, desired)` | `bool` | Compare-and-swap |
| `atomic_exchange_i32` | `(ptr, value)` | `i32` | Troca e retorna valor antigo |

### Opera√ß√µes i64

| Fun√ß√£o | Assinatura | Retorno | Descri√ß√£o |
|--------|------------|---------|-----------|
| `atomic_load_i64` | `(ptr)` | `i64` | Carrega valor atomicamente |
| `atomic_store_i64` | `(ptr, value)` | `null` | Armazena valor atomicamente |
| `atomic_add_i64` | `(ptr, value)` | `i64` | Adiciona e retorna valor antigo |
| `atomic_sub_i64` | `(ptr, value)` | `i64` | Subtrai e retorna valor antigo |
| `atomic_and_i64` | `(ptr, value)` | `i64` | AND bitwise e retorna valor antigo |
| `atomic_or_i64` | `(ptr, value)` | `i64` | OR bitwise e retorna valor antigo |
| `atomic_xor_i64` | `(ptr, value)` | `i64` | XOR bitwise e retorna valor antigo |
| `atomic_cas_i64` | `(ptr, expected, desired)` | `bool` | Compare-and-swap |
| `atomic_exchange_i64` | `(ptr, value)` | `i64` | Troca e retorna valor antigo |

### Barreira de Mem√≥ria

| Fun√ß√£o | Assinatura | Retorno | Descri√ß√£o |
|--------|------------|---------|-----------|
| `atomic_fence` | `()` | `null` | Barreira de mem√≥ria completa |

---

## Padr√µes Comuns

### Padr√£o: Contador At√¥mico

```hemlock
// Contador thread-safe
let counter = alloc(4);
ptr_write_i32(counter, 0);

fn increment(): i32 {
    return atomic_add_i32(counter, 1);
}

fn decrement(): i32 {
    return atomic_sub_i32(counter, 1);
}

fn get_count(): i32 {
    return atomic_load_i32(counter);
}

// Uso
increment();  // Retorna 0 (valor antigo)
increment();  // Retorna 1
increment();  // Retorna 2
print(get_count());  // 3

free(counter);
```

### Padr√£o: Spinlock

```hemlock
// Implementa√ß√£o simples de spinlock
let lock = alloc(4);
ptr_write_i32(lock, 0);  // 0 = desbloqueado, 1 = bloqueado

fn acquire() {
    // Gira at√© conseguir definir lock de 0 para 1
    while (!atomic_cas_i32(lock, 0, 1)) {
        // Espera ocupada
    }
}

fn release() {
    atomic_store_i32(lock, 0);
}

// Uso
acquire();
// ... se√ß√£o cr√≠tica ...
release();

free(lock);
```

### Padr√£o: Inicializa√ß√£o √önica

```hemlock
let initialized = alloc(4);
ptr_write_i32(initialized, 0);  // 0 = n√£o inicializado, 1 = inicializado

fn ensure_initialized() {
    // Tenta ser o inicializador
    if (atomic_cas_i32(initialized, 0, 1)) {
        // Vencemos a corrida, executar inicializa√ß√£o
        do_expensive_init();
    }
    // Caso contr√°rio, j√° foi inicializado
}
```

### Padr√£o: Flag At√¥mica

```hemlock
let flag = alloc(4);
ptr_write_i32(flag, 0);

fn set_flag() {
    atomic_store_i32(flag, 1);
}

fn clear_flag() {
    atomic_store_i32(flag, 0);
}

fn test_and_set(): bool {
    // Retorna true se flag j√° estava definida
    return atomic_exchange_i32(flag, 1) == 1;
}

fn check_flag(): bool {
    return atomic_load_i32(flag) == 1;
}
```

### Padr√£o: Contador Limitado

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);
let max_value = 100;

fn try_increment(): bool {
    while (true) {
        let current = atomic_load_i32(counter);
        if (current >= max_value) {
            return false;  // M√°ximo atingido
        }
        if (atomic_cas_i32(counter, current, current + 1)) {
            return true;  // Incrementado com sucesso
        }
        // CAS falhou, outra thread modificou o valor - tentar novamente
    }
}
```

---

## Melhores Pr√°ticas

### 1. Use Alinhamento Correto

Ponteiros devem estar corretamente alinhados para o tipo de dados:
- i32: alinhamento de 4 bytes
- i64: alinhamento de 8 bytes

Mem√≥ria de `alloc()` geralmente est√° corretamente alinhada.

### 2. Prefira Abstra√ß√µes de N√≠vel Superior

Se poss√≠vel, use canais para comunica√ß√£o entre tarefas. Opera√ß√µes at√¥micas s√£o de n√≠vel mais baixo e requerem racioc√≠nio cuidadoso.

```hemlock
// Prefira isto:
let ch = channel(10);
spawn(fn() { ch.send(result); });
let value = ch.recv();

// Em vez de coordena√ß√£o manual at√¥mica quando apropriado
```

### 3. Cuidado com o Problema ABA

CAS pode sofrer do problema ABA: o valor muda de A para B e depois volta para A. Seu CAS tem sucesso, mas o estado pode ter mudado no meio.

### 4. Inicialize Antes de Compartilhar

Sempre inicialize vari√°veis at√¥micas antes de criar tarefas que as acessam:

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);  // Inicializar antes de criar tarefa

let task = spawn(worker, counter);
```

### 5. Libere Ap√≥s Todas as Tarefas Terminarem

N√£o libere mem√≥ria at√¥mica enquanto tarefas ainda podem estar acessando-a:

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);

let t1 = spawn(worker, counter);
let t2 = spawn(worker, counter);

join(t1);
join(t2);

// Agora seguro para liberar
free(counter);
```

---

## Limita√ß√µes

### Limita√ß√µes Atuais

1. **Apenas i32 e i64** - Sem opera√ß√µes at√¥micas para outros tipos
2. **Sem at√¥micos de ponteiro** - N√£o √© poss√≠vel carregar/armazenar ponteiros atomicamente
3. **Apenas consist√™ncia sequencial** - Ordena√ß√µes de mem√≥ria mais fracas n√£o dispon√≠veis
4. **Sem floats at√¥micos** - Use representa√ß√£o inteira se necess√°rio

### Notas de Plataforma

- Opera√ß√µes at√¥micas usam `<stdatomic.h>` do C11 internamente
- Dispon√≠vel em todas as plataformas que suportam POSIX threads
- Garantidamente lock-free em sistemas modernos de 64 bits

---

## Veja Tamb√©m

- [Assincronismo/Concorr√™ncia](#advanced-async-concurrency) - Cria√ß√£o de tarefas e canais
- [Gerenciamento de Mem√≥ria](#language-guide-memory) - Ponteiros e aloca√ß√£o de buffers
- [API de Mem√≥ria](#reference-memory-api) - Fun√ß√µes de aloca√ß√£o


--------------------------------------------------------------------------------
## Perfilamento
--------------------------------------------------------------------------------

# Perfilamento

Hemlock inclui um profiler integrado para **an√°lise de tempo de CPU**, **rastreamento de mem√≥ria** e **detec√ß√£o de vazamentos**. O profiler ajuda a identificar gargalos de desempenho e problemas de mem√≥ria em seus programas.

## √çndice

- [Vis√£o Geral](#vis√£o-geral)
- [In√≠cio R√°pido](#in√≠cio-r√°pido)
- [Modos de Perfilamento](#modos-de-perfilamento)
- [Formatos de Sa√≠da](#formatos-de-sa√≠da)
- [Detec√ß√£o de Vazamentos](#detec√ß√£o-de-vazamentos)
- [Entendendo os Relat√≥rios](#entendendo-os-relat√≥rios)
- [Gera√ß√£o de Flamegraph](#gera√ß√£o-de-flamegraph)
- [Melhores Pr√°ticas](#melhores-pr√°ticas)

---

## Vis√£o Geral

O profiler √© acessado atrav√©s do subcomando `profile`:

```bash
hemlock profile [OPTIONS] <FILE>
```

**Recursos Principais:**
- **Perfilamento de CPU** - mede tempo gasto em cada fun√ß√£o (self time e total time)
- **Perfilamento de Mem√≥ria** - rastreia todas as aloca√ß√µes e suas localiza√ß√µes de origem
- **Detec√ß√£o de Vazamentos** - identifica mem√≥ria que nunca foi liberada
- **M√∫ltiplos Formatos de Sa√≠da** - texto, JSON e sa√≠da compat√≠vel com flamegraph
- **Estat√≠sticas de Mem√≥ria por Fun√ß√£o** - veja quais fun√ß√µes alocam mais mem√≥ria

---

## In√≠cio R√°pido

### Perfilar Tempo de CPU (Padr√£o)

```bash
hemlock profile script.hml
```

### Perfilar Aloca√ß√µes de Mem√≥ria

```bash
hemlock profile --memory script.hml
```

### Detectar Vazamentos de Mem√≥ria

```bash
hemlock profile --leaks script.hml
```

### Gerar Dados de Flamegraph

```bash
hemlock profile --flamegraph script.hml > profile.folded
flamegraph.pl profile.folded > profile.svg
```

---

## Modos de Perfilamento

### Perfilamento de CPU (Padr√£o)

Mede tempo gasto em cada fun√ß√£o, distinguindo:
- **Self time** - tempo gasto executando o c√≥digo da pr√≥pria fun√ß√£o
- **Total time** - self time mais tempo gasto em fun√ß√µes chamadas

```bash
hemlock profile script.hml
hemlock profile --cpu script.hml  # Expl√≠cito
```

**Sa√≠da de Exemplo:**
```
=== Hemlock Profiler Report ===

Total time: 1.234ms
Functions called: 5 unique

--- Top 5 by Self Time ---

Function                        Self      Total   Calls
--------                        ----      -----   -----
expensive_calc              0.892ms    0.892ms     100  (72.3%)
process_data                0.234ms    1.126ms      10  (19.0%)
helper                      0.067ms    0.067ms     500  (5.4%)
main                        0.041ms    1.234ms       1  (3.3%)
```

---

### Perfilamento de Mem√≥ria

Rastreia todas as aloca√ß√µes de mem√≥ria (`alloc`, `buffer`, `talloc`, `realloc`) e suas localiza√ß√µes de origem.

```bash
hemlock profile --memory script.hml
```

**Sa√≠da de Exemplo:**
```
=== Hemlock Profiler Report ===

Total time: 0.543ms
Functions called: 3 unique
Total allocations: 15 (4.2KB)

--- Top 3 by Self Time ---

Function                        Self      Total   Calls      Alloc      Count
--------                        ----      -----   -----      -----      -----
allocator                   0.312ms    0.312ms      10      3.2KB         10  (57.5%)
buffer_ops                  0.156ms    0.156ms       5       1KB          5  (28.7%)
main                        0.075ms    0.543ms       1        0B          0  (13.8%)

--- Top 10 Allocation Sites ---

Location                                      Total    Count
--------                                      -----    -----
src/data.hml:42                               1.5KB        5
src/data.hml:67                               1.0KB       10
src/main.hml:15                               512B         1
```

---

### Modo de Contagem de Chamadas

Modo de overhead m√≠nimo que apenas conta chamadas de fun√ß√£o (sem cronometragem).

```bash
hemlock profile --calls script.hml
```

---

## Formatos de Sa√≠da

### Texto (Padr√£o)

Resumo leg√≠vel por humanos com tabelas.

```bash
hemlock profile script.hml
```

---

### JSON

Formato leg√≠vel por m√°quina para integra√ß√£o com outras ferramentas.

```bash
hemlock profile --json script.hml
```

**Sa√≠da de Exemplo:**
```json
{
  "total_time_ns": 1234567,
  "function_count": 5,
  "total_alloc_bytes": 4096,
  "total_alloc_count": 15,
  "functions": [
    {
      "name": "expensive_calc",
      "source_file": "script.hml",
      "line": 10,
      "self_time_ns": 892000,
      "total_time_ns": 892000,
      "call_count": 100,
      "alloc_bytes": 0,
      "alloc_count": 0
    }
  ],
  "alloc_sites": [
    {
      "source_file": "script.hml",
      "line": 42,
      "total_bytes": 1536,
      "alloc_count": 5,
      "current_bytes": 0
    }
  ]
}
```

---

### Flamegraph

Gera formato de stack colapsado compat√≠vel com [flamegraph.pl](https://github.com/brendangregg/FlameGraph).

```bash
hemlock profile --flamegraph script.hml > profile.folded

# Gerar SVG usando flamegraph.pl
flamegraph.pl profile.folded > profile.svg
```

**Sa√≠da Colapsada de Exemplo:**
```
main;process_data;expensive_calc 892
main;process_data;helper 67
main;process_data 234
main 41
```

---

## Detec√ß√£o de Vazamentos

A flag `--leaks` mostra apenas aloca√ß√µes que nunca foram liberadas, facilitando a identifica√ß√£o de vazamentos de mem√≥ria.

```bash
hemlock profile --leaks script.hml
```

**Programa de Exemplo com Vazamentos:**
```hemlock
fn leaky() {
    let p1 = alloc(100);    // Vazamento - nunca liberado
    let p2 = alloc(200);    // OK - liberado abaixo
    free(p2);
}

fn clean() {
    let b = buffer(64);
    free(b);                // Liberado corretamente
}

leaky();
clean();
```

**Sa√≠da com --leaks:**
```
=== Hemlock Profiler Report ===

Total time: 0.034ms
Functions called: 2 unique
Total allocations: 3 (388B)

--- Top 2 by Self Time ---

Function                        Self      Total   Calls      Alloc      Count
--------                        ----      -----   -----      -----      -----
leaky                       0.021ms    0.021ms       1       300B          2  (61.8%)
clean                       0.013ms    0.013ms       1        88B          1  (38.2%)

--- Memory Leaks (1 site) ---

Location                                     Leaked      Total    Count
--------                                     ------      -----    -----
script.hml:2                                   100B       100B        1
```

O relat√≥rio de vazamentos mostra:
- **Leaked** - bytes atualmente n√£o liberados na sa√≠da do programa
- **Total** - total de bytes alocados nesta localiza√ß√£o
- **Count** - n√∫mero de aloca√ß√µes nesta localiza√ß√£o

---

## Entendendo os Relat√≥rios

### Estat√≠sticas de Fun√ß√£o

| Coluna | Descri√ß√£o |
|--------|-----------|
| Function | Nome da fun√ß√£o |
| Self | Tempo gasto na fun√ß√£o (excluindo chamadas) |
| Total | Tempo incluindo todas as fun√ß√µes chamadas |
| Calls | N√∫mero de vezes que a fun√ß√£o foi chamada |
| Alloc | Total de bytes alocados por esta fun√ß√£o |
| Count | N√∫mero de aloca√ß√µes por esta fun√ß√£o |
| (%) | Porcentagem do tempo total do programa |

### Sites de Aloca√ß√£o

| Coluna | Descri√ß√£o |
|--------|-----------|
| Location | Arquivo fonte e n√∫mero da linha |
| Total | Total de bytes alocados nesta localiza√ß√£o |
| Count | N√∫mero de aloca√ß√µes |
| Leaked | Bytes ainda alocados na sa√≠da do programa (apenas --leaks) |

### Unidades de Tempo

O profiler escolhe automaticamente unidades apropriadas:
- `ns` - nanosegundos (< 1 microssegundo)
- `us` - microssegundos (< 1 milissegundo)
- `ms` - milissegundos (< 1 segundo)
- `s` - segundos

---

## Refer√™ncia de Comandos

```
hemlock profile [OPTIONS] <FILE>

OPTIONS:
    --cpu           Perfilamento de CPU/tempo (padr√£o)
    --memory        Perfilamento de aloca√ß√£o de mem√≥ria
    --calls         Apenas contagem de chamadas (overhead m√≠nimo)
    --leaks         Mostrar apenas aloca√ß√µes n√£o liberadas (implica --memory)
    --json          Sa√≠da em formato JSON
    --flamegraph    Sa√≠da em formato compat√≠vel com flamegraph
    --top N         Mostrar top N entradas (padr√£o: 20)
```

---

## Gera√ß√£o de Flamegraph

Flamegraphs visualizam onde seu programa gasta tempo, com barras mais largas representando mais tempo.

### Gerando um Flamegraph

1. Instalar flamegraph.pl:
   ```bash
   git clone https://github.com/brendangregg/FlameGraph
   ```

2. Perfilar seu programa:
   ```bash
   hemlock profile --flamegraph script.hml > profile.folded
   ```

3. Gerar SVG:
   ```bash
   ./FlameGraph/flamegraph.pl profile.folded > profile.svg
   ```

4. Abrir `profile.svg` em um navegador para visualiza√ß√£o interativa.

### Lendo Flamegraphs

- **Eixo X**: Porcentagem do tempo total (largura = propor√ß√£o do tempo)
- **Eixo Y**: Profundidade da call stack (fundo = ponto de entrada, topo = fun√ß√µes folha)
- **Cores**: Aleat√≥rias, apenas para distin√ß√£o visual
- **Clique**: Zoom em uma fun√ß√£o para ver suas chamadas

---

## Melhores Pr√°ticas

### 1. Perfile Cargas de Trabalho Representativas

Use dados e padr√µes de uso reais para perfilar. Casos de teste pequenos podem n√£o revelar os verdadeiros gargalos.

```bash
# Bom: perfilar com dados semelhantes a produ√ß√£o
hemlock profile --memory process_large_file.hml large_input.txt

# Menos √∫til: casos de teste min√∫sculos
hemlock profile quick_test.hml
```

### 2. Use --leaks Durante o Desenvolvimento

Execute detec√ß√£o de vazamentos regularmente para encontrar vazamentos de mem√≥ria cedo:

```bash
hemlock profile --leaks my_program.hml
```

### 3. Compare Antes e Depois das Otimiza√ß√µes

Perfile antes e depois de otimiza√ß√µes para medir o impacto:

```bash
# Antes
hemlock profile --json script.hml > before.json

# Depois
hemlock profile --json script.hml > after.json

# Comparar resultados
```

### 4. Use --top para Programas Grandes

Limite a sa√≠da para focar nas fun√ß√µes mais importantes:

```bash
hemlock profile --top 10 large_program.hml
```

### 5. Combine com Flamegraphs

Para padr√µes de chamada complexos, flamegraphs fornecem melhor visualiza√ß√£o do que sa√≠da de texto:

```bash
hemlock profile --flamegraph complex_app.hml > app.folded
flamegraph.pl app.folded > app.svg
```

---

## Overhead do Profiler

O profiler adiciona algum overhead √† execu√ß√£o do programa:

| Modo | Overhead | Caso de Uso |
|------|----------|-------------|
| `--calls` | M√≠nimo | Apenas contagem de chamadas de fun√ß√£o |
| `--cpu` | Baixo | Perfilamento de desempenho geral |
| `--memory` | Moderado | An√°lise de mem√≥ria e detec√ß√£o de vazamentos |

Para resultados mais precisos, perfile m√∫ltiplas vezes e procure padr√µes consistentes.

---

## Veja Tamb√©m

- [Gerenciamento de Mem√≥ria](#language-guide-memory) - Ponteiros e buffers
- [API de Mem√≥ria](#reference-memory-api) - Fun√ß√µes alloc, free, buffer
- [Assincronismo/Concorr√™ncia](#advanced-async-concurrency) - Perfilando c√≥digo ass√≠ncrono


--------------------------------------------------------------------------------
## Sinais
--------------------------------------------------------------------------------

# Hemlock Tratamento de Sinais

Hemlock oferece **tratamento de sinais POSIX** para gerenciar sinais do sistema como SIGINT (Ctrl+C), SIGTERM e sinais personalizados. Isso permite controle de processo de baixo n√≠vel e comunica√ß√£o entre processos.

## √çndice

- [Vis√£o Geral](#vis√£o-geral)
- [API de Sinais](#api-de-sinais)
- [Constantes de Sinais](#constantes-de-sinais)
- [Tratamento B√°sico de Sinais](#tratamento-b√°sico-de-sinais)
- [Padr√µes Avan√ßados](#padr√µes-avan√ßados)
- [Comportamento de Handlers de Sinais](#comportamento-de-handlers-de-sinais)
- [Considera√ß√µes de Seguran√ßa](#considera√ß√µes-de-seguran√ßa)
- [Casos de Uso Comuns](#casos-de-uso-comuns)
- [Exemplos Completos](#exemplos-completos)

## Vis√£o Geral

O tratamento de sinais permite que programas:
- Respondam a interrup√ß√µes do usu√°rio (Ctrl+C, Ctrl+Z)
- Implementem shutdown gracioso
- Tratem requisi√ß√µes de termina√ß√£o
- Usem sinais personalizados para comunica√ß√£o entre processos
- Criem mecanismos de alarme/timer

**Importante:** Seguindo a filosofia do Hemlock, o tratamento de sinais √© **inerentemente inseguro**. Handlers podem ser chamados a qualquer momento, interrompendo a execu√ß√£o normal. O usu√°rio √© respons√°vel pela sincroniza√ß√£o apropriada.

## API de Sinais

### signal(signum, handler_fn)

Registra uma fun√ß√£o de tratamento de sinal.

**Par√¢metros:**
- `signum` (i32) - n√∫mero do sinal (ex: constantes SIGINT, SIGTERM)
- `handler_fn` (function ou null) - fun√ß√£o a chamar quando o sinal √© recebido, ou `null` para resetar ao padr√£o

**Retorna:** Fun√ß√£o handler anterior (ou `null` se nenhuma)

**Exemplo:**
```hemlock
fn my_handler(sig) {
    print("Caught signal: " + typeof(sig));
}

let old_handler = signal(SIGINT, my_handler);
```

**Resetar para padr√£o:**
```hemlock
signal(SIGINT, null);  // Reseta SIGINT para comportamento padr√£o
```

### raise(signum)

Envia um sinal para o processo atual.

**Par√¢metros:**
- `signum` (i32) - n√∫mero do sinal a enviar

**Retorna:** `null`

**Exemplo:**
```hemlock
raise(SIGUSR1);  // Dispara handler SIGUSR1
```

## Constantes de Sinais

Hemlock fornece constantes de sinais POSIX padr√£o como valores i32.

### Interrup√ß√£o e Termina√ß√£o

| Constante | Valor | Descri√ß√£o | Gatilho Comum |
|-----------|-------|-----------|---------------|
| `SIGINT` | 2 | Interrup√ß√£o do teclado | Ctrl+C |
| `SIGTERM` | 15 | Requisi√ß√£o de termina√ß√£o | Comando `kill` |
| `SIGQUIT` | 3 | Quit do teclado | Ctrl+\ |
| `SIGHUP` | 1 | Hangup detectado | Terminal fechado |
| `SIGABRT` | 6 | Sinal de abort | Fun√ß√£o `abort()` |

**Exemplo:**
```hemlock
signal(SIGINT, handle_interrupt);   // Ctrl+C
signal(SIGTERM, handle_terminate);  // Comando kill
signal(SIGHUP, handle_hangup);      // Terminal fechado
```

### Sinais Definidos pelo Usu√°rio

| Constante | Valor | Descri√ß√£o | Caso de Uso |
|-----------|-------|-----------|-------------|
| `SIGUSR1` | 10 | Sinal definido pelo usu√°rio 1 | IPC personalizado |
| `SIGUSR2` | 12 | Sinal definido pelo usu√°rio 2 | IPC personalizado |

**Exemplo:**
```hemlock
// Para comunica√ß√£o personalizada
signal(SIGUSR1, reload_config);
signal(SIGUSR2, rotate_logs);
```

### Controle de Processo

| Constante | Valor | Descri√ß√£o | Nota |
|-----------|-------|-----------|------|
| `SIGALRM` | 14 | Timer de alarme | Ap√≥s `alarm()` |
| `SIGCHLD` | 17 | Mudan√ßa de estado do filho | Gerenciamento de processo |
| `SIGCONT` | 18 | Continuar se parado | Retomar ap√≥s SIGSTOP |
| `SIGSTOP` | 19 | Parar processo | **N√£o pode ser capturado** |
| `SIGTSTP` | 20 | Stop do terminal | Ctrl+Z |

**Exemplo:**
```hemlock
signal(SIGALRM, handle_timeout);
signal(SIGCHLD, handle_child_exit);
```

### Sinais de I/O

| Constante | Valor | Descri√ß√£o | Quando Enviado |
|-----------|-------|-----------|----------------|
| `SIGPIPE` | 13 | Pipe quebrado | Escrita em pipe fechado |
| `SIGTTIN` | 21 | Leitura de background do terminal | Processo em background l√™ TTY |
| `SIGTTOU` | 22 | Escrita de background no terminal | Processo em background escreve TTY |

**Exemplo:**
```hemlock
signal(SIGPIPE, handle_broken_pipe);
```

## Tratamento B√°sico de Sinais

### Capturando Ctrl+C

```hemlock
let interrupted = false;

fn handle_interrupt(sig) {
    print("Caught SIGINT!");
    interrupted = true;
}

signal(SIGINT, handle_interrupt);

// Programa continua executando...
// Usu√°rio pressiona Ctrl+C -> handle_interrupt() √© chamado

while (!interrupted) {
    // Fazer trabalho...
}

print("Exiting due to interrupt");
```

### Assinatura da Fun√ß√£o Handler

Handlers de sinal recebem um argumento: o n√∫mero do sinal (i32)

```hemlock
fn my_handler(signum) {
    print("Received signal: " + typeof(signum));
    // signum cont√©m o n√∫mero do sinal (ex: 2 para SIGINT)

    if (signum == SIGINT) {
        print("This is SIGINT");
    }
}

signal(SIGINT, my_handler);
signal(SIGTERM, my_handler);  // Mesmo handler para m√∫ltiplos sinais
```

### M√∫ltiplos Handlers de Sinal

Diferentes handlers para diferentes sinais:

```hemlock
fn handle_int(sig) {
    print("SIGINT received");
}

fn handle_term(sig) {
    print("SIGTERM received");
}

fn handle_usr1(sig) {
    print("SIGUSR1 received");
}

signal(SIGINT, handle_int);
signal(SIGTERM, handle_term);
signal(SIGUSR1, handle_usr1);
```

### Resetar para Comportamento Padr√£o

Passe `null` como handler para resetar para comportamento padr√£o:

```hemlock
// Registrar handler personalizado
signal(SIGINT, my_handler);

// Depois, resetar para padr√£o (terminar em SIGINT)
signal(SIGINT, null);
```

### Disparar Sinal Manualmente

Envie um sinal para seu pr√≥prio processo:

```hemlock
let count = 0;

fn increment(sig) {
    count = count + 1;
}

signal(SIGUSR1, increment);

// Disparar handler manualmente
raise(SIGUSR1);
raise(SIGUSR1);

print(count);  // 2
```

## Padr√µes Avan√ßados

### Padr√£o de Shutdown Gracioso

Padr√£o comum para limpeza na termina√ß√£o:

```hemlock
let should_exit = false;

fn handle_shutdown(sig) {
    print("Shutting down gracefully...");
    should_exit = true;
}

signal(SIGINT, handle_shutdown);
signal(SIGTERM, handle_shutdown);

// Loop principal
while (!should_exit) {
    // Fazer trabalho...
    // Verificar flag should_exit periodicamente
}

print("Cleanup complete");
```

### Contador de Sinais

Rastrear n√∫mero de sinais recebidos:

```hemlock
let signal_count = 0;

fn count_signals(sig) {
    signal_count = signal_count + 1;
    print("Received " + typeof(signal_count) + " signals");
}

signal(SIGUSR1, count_signals);

// Depois...
print("Total signals: " + typeof(signal_count));
```

### Recarregar Configura√ß√£o por Sinal

```hemlock
let config = load_config();

fn reload_config(sig) {
    print("Reloading configuration...");
    config = load_config();
    print("Configuration reloaded");
}

signal(SIGHUP, reload_config);  // Recarregar ao receber SIGHUP

// Do shell, envie SIGHUP para o processo para recarregar config
// kill -HUP <pid>
```

### Timeout com SIGALRM

```hemlock
let timed_out = false;

fn handle_alarm(sig) {
    print("Timeout!");
    timed_out = true;
}

signal(SIGALRM, handle_alarm);

// Definir alarme (ainda n√£o implementado em Hemlock, apenas exemplo)
// alarm(5);  // timeout de 5 segundos

while (!timed_out) {
    // Trabalho com timeout
}
```

### M√°quina de Estados Baseada em Sinais

```hemlock
let state = 0;

fn next_state(sig) {
    state = (state + 1) % 3;
    print("State: " + typeof(state));
}

fn prev_state(sig) {
    state = (state - 1 + 3) % 3;
    print("State: " + typeof(state));
}

signal(SIGUSR1, next_state);  // Avan√ßar estado
signal(SIGUSR2, prev_state);  // Retroceder estado

// Controlar m√°quina de estados:
// kill -USR1 <pid>  # pr√≥ximo estado
// kill -USR2 <pid>  # estado anterior
```

## Comportamento de Handlers de Sinais

### Notas Importantes

**Execu√ß√£o de Handler:**
- Handlers s√£o chamados **sincronamente** quando o sinal √© recebido
- Handlers executam no contexto do processo atual
- Handlers de sinal compartilham o ambiente de closure da fun√ß√£o que os definiu
- Handlers podem acessar e modificar vari√°veis do escopo externo (como globais ou vari√°veis capturadas)

**Melhores Pr√°ticas:**
- Mantenha handlers simples e r√°pidos - evite opera√ß√µes de longa dura√ß√£o
- Defina flags em vez de executar l√≥gica complexa
- Evite chamar fun√ß√µes que podem adquirir locks
- Esteja ciente de que handlers podem interromper qualquer opera√ß√£o

### Quais Sinais Podem Ser Capturados

**Podem ser capturados e tratados:**
- SIGINT, SIGTERM, SIGUSR1, SIGUSR2, SIGHUP, SIGQUIT
- SIGALRM, SIGCHLD, SIGCONT, SIGTSTP
- SIGPIPE, SIGTTIN, SIGTTOU
- SIGABRT (mas o programa abortar√° ap√≥s o handler retornar)

**N√£o podem ser capturados:**
- `SIGKILL` (9) - sempre termina o processo
- `SIGSTOP` (19) - sempre para o processo

**Dependentes do Sistema:**
- Comportamento padr√£o de alguns sinais pode variar entre sistemas
- Consulte a documenta√ß√£o de sinais da sua plataforma para detalhes

### Limita√ß√µes de Handlers

```hemlock
fn complex_handler(sig) {
    // Evite isso em handlers de sinal:

    // ‚ùå Opera√ß√µes de longa dura√ß√£o
    // process_large_file();

    // ‚ùå I/O bloqueante
    // let f = open("log.txt", "a");
    // f.write("Signal received\n");

    // ‚ùå Mudan√ßas complexas de estado
    // rebuild_entire_data_structure();

    // ‚úÖ Definir flag simples √© seguro
    let should_stop = true;

    // ‚úÖ Atualiza√ß√£o simples de contador geralmente √© seguro
    let signal_count = signal_count + 1;
}
```

## Considera√ß√µes de Seguran√ßa

Seguindo a filosofia do Hemlock, o tratamento de sinais √© **inerentemente inseguro**.

### Condi√ß√µes de Corrida

Handlers podem ser chamados a qualquer momento, interrompendo a execu√ß√£o normal:

```hemlock
let counter = 0;

fn increment(sig) {
    counter = counter + 1;  // Condi√ß√£o de corrida se chamado durante atualiza√ß√£o de counter
}

signal(SIGUSR1, increment);

// C√≥digo principal tamb√©m modifica counter
counter = counter + 1;  // Pode ser interrompido pelo handler de sinal
```

**Problema:** Se o sinal chega enquanto o c√≥digo principal est√° atualizando `counter`, o resultado √© imprevis√≠vel.

### Seguran√ßa de Sinal Ass√≠ncrono

Hemlock **n√£o** garante seguran√ßa de sinal ass√≠ncrono:
- Handlers podem chamar qualquer c√≥digo Hemlock (diferente de fun√ß√µes C restritas async-signal-safe)
- Isso fornece flexibilidade mas requer cuidado do usu√°rio
- Condi√ß√µes de corrida podem ocorrer se handlers modificam estado compartilhado

### Melhores Pr√°ticas para Tratamento Seguro de Sinais

**1. Use Flags At√¥micas**

Atribui√ß√µes booleanas simples geralmente s√£o seguras:

```hemlock
let should_exit = false;

fn handler(sig) {
    should_exit = true;  // Atribui√ß√£o simples √© segura
}

signal(SIGINT, handler);

while (!should_exit) {
    // Trabalho...
}
```

**2. Minimize Estado Compartilhado**

```hemlock
let interrupt_count = 0;

fn handler(sig) {
    // Modifique apenas esta vari√°vel
    interrupt_count = interrupt_count + 1;
}
```

**3. Adie Opera√ß√µes Complexas**

```hemlock
let pending_reload = false;

fn signal_reload(sig) {
    pending_reload = true;  // Apenas define flag
}

signal(SIGHUP, signal_reload);

// No loop principal:
while (true) {
    if (pending_reload) {
        reload_config();  // Faz trabalho complexo aqui
        pending_reload = false;
    }

    // Trabalho normal...
}
```

**4. Evite Problemas de Reentr√¢ncia**

```hemlock
let in_critical_section = false;
let data = [];

fn careful_handler(sig) {
    if (in_critical_section) {
        // N√£o modifique dados enquanto c√≥digo principal os usa
        return;
    }
    // Pode continuar com seguran√ßa
}
```

## Casos de Uso Comuns

### 1. Shutdown Gracioso de Servidor

```hemlock
let running = true;

fn shutdown(sig) {
    print("Shutdown signal received");
    running = false;
}

signal(SIGINT, shutdown);
signal(SIGTERM, shutdown);

// Loop principal do servidor
while (running) {
    handle_client_request();
}

cleanup_resources();
print("Server stopped");
```

### 2. Recarregar Configura√ß√£o (Sem Reiniciar)

```hemlock
let config = load_config("app.conf");
let reload_needed = false;

fn trigger_reload(sig) {
    reload_needed = true;
}

signal(SIGHUP, trigger_reload);

while (true) {
    if (reload_needed) {
        print("Reloading configuration...");
        config = load_config("app.conf");
        reload_needed = false;
    }

    // Usar configura√ß√£o...
}
```

### 3. Rota√ß√£o de Logs

```hemlock
let log_file = open("app.log", "a");
let rotate_needed = false;

fn trigger_rotate(sig) {
    rotate_needed = true;
}

signal(SIGUSR1, trigger_rotate);

while (true) {
    if (rotate_needed) {
        log_file.close();
        // Renomear log antigo, abrir novo
        exec("mv app.log app.log.old");
        log_file = open("app.log", "a");
        rotate_needed = false;
    }

    // Logging normal...
    log_file.write("Log entry\n");
}
```

### 4. Relat√≥rio de Status

```hemlock
let requests_handled = 0;

fn report_status(sig) {
    print("Status: " + typeof(requests_handled) + " requests handled");
}

signal(SIGUSR1, report_status);

while (true) {
    handle_request();
    requests_handled = requests_handled + 1;
}

// Do shell: kill -USR1 <pid>
```

### 5. Alternar Modo Debug

```hemlock
let debug_mode = false;

fn toggle_debug(sig) {
    debug_mode = !debug_mode;
    if (debug_mode) {
        print("Debug mode: ON");
    } else {
        print("Debug mode: OFF");
    }
}

signal(SIGUSR2, toggle_debug);

// Do shell: kill -USR2 <pid> para alternar
```

## Exemplos Completos

### Exemplo 1: Handler de Interrup√ß√£o com Limpeza

```hemlock
let running = true;
let signal_count = 0;

fn handle_signal(signum) {
    signal_count = signal_count + 1;

    if (signum == SIGINT) {
        print("Interrupt detected (Ctrl+C)");
        running = false;
    }

    if (signum == SIGUSR1) {
        print("User signal 1 received");
    }
}

// Registrar handlers
signal(SIGINT, handle_signal);
signal(SIGUSR1, handle_signal);

// Simular algum trabalho
let i = 0;
while (running && i < 100) {
    print("Working... " + typeof(i));

    // Disparar SIGUSR1 a cada 10 itera√ß√µes
    if (i == 10 || i == 20) {
        raise(SIGUSR1);
    }

    i = i + 1;
}

print("Total signals received: " + typeof(signal_count));
```

### Exemplo 2: M√°quina de Estados Multi-sinal

```hemlock
let state = "idle";
let request_count = 0;

fn start_processing(sig) {
    state = "processing";
    print("State: " + state);
}

fn stop_processing(sig) {
    state = "idle";
    print("State: " + state);
}

fn report_stats(sig) {
    print("State: " + state);
    print("Requests: " + typeof(request_count));
}

signal(SIGUSR1, start_processing);
signal(SIGUSR2, stop_processing);
signal(SIGHUP, report_stats);

while (true) {
    if (state == "processing") {
        // Fazer trabalho
        request_count = request_count + 1;
    }

    // Verificar a cada itera√ß√£o...
}
```

### Exemplo 3: Controlador de Pool de Workers

```hemlock
let worker_count = 4;
let should_exit = false;

fn increase_workers(sig) {
    worker_count = worker_count + 1;
    print("Workers: " + typeof(worker_count));
}

fn decrease_workers(sig) {
    if (worker_count > 1) {
        worker_count = worker_count - 1;
    }
    print("Workers: " + typeof(worker_count));
}

fn shutdown(sig) {
    print("Shutting down...");
    should_exit = true;
}

signal(SIGUSR1, increase_workers);
signal(SIGUSR2, decrease_workers);
signal(SIGINT, shutdown);
signal(SIGTERM, shutdown);

// Loop principal ajusta pool de workers baseado em worker_count
while (!should_exit) {
    // Gerenciar workers baseado em worker_count
    // ...
}
```

## Depurando Handlers de Sinal

### Adicionar Prints de Diagn√≥stico

```hemlock
fn debug_handler(sig) {
    print("Handler called for signal: " + typeof(sig));
    print("Stack: (not yet available)");

    // Sua l√≥gica de handler...
}

signal(SIGINT, debug_handler);
```

### Contar Chamadas de Handler

```hemlock
let handler_calls = 0;

fn counting_handler(sig) {
    handler_calls = handler_calls + 1;
    print("Handler call #" + typeof(handler_calls));

    // Sua l√≥gica de handler...
}
```

### Testar Usando raise()

```hemlock
fn test_handler(sig) {
    print("Test signal received: " + typeof(sig));
}

signal(SIGUSR1, test_handler);

// Testar disparando manualmente
raise(SIGUSR1);
print("Handler should have been called");
```

## Resumo

O tratamento de sinais do Hemlock oferece:

- Tratamento de sinais POSIX para controle de processo de baixo n√≠vel
- 15 constantes de sinais padr√£o
- API simples signal() e raise()
- Fun√ß√µes handler flex√≠veis com suporte a closures
- M√∫ltiplos sinais podem compartilhar um handler

Lembre-se:
- O tratamento de sinais √© inerentemente inseguro - use com cuidado
- Mantenha handlers simples e r√°pidos
- Use flags para mudan√ßas de estado, n√£o opera√ß√µes complexas
- Handlers podem interromper a execu√ß√£o a qualquer momento
- SIGKILL ou SIGSTOP n√£o podem ser capturados
- Use raise() para testar handlers completamente

Padr√µes comuns:
- Shutdown gracioso (SIGINT, SIGTERM)
- Recarregar configura√ß√£o (SIGHUP)
- Rota√ß√£o de logs (SIGUSR1)
- Relat√≥rio de status (SIGUSR1/SIGUSR2)
- Alternar modo debug (SIGUSR2)



################################################################################
# REFER√äNCIA DA API
################################################################################

--------------------------------------------------------------------------------
## API de Arquivos
--------------------------------------------------------------------------------

# Referencia da API de Arquivos

Documentacao completa do sistema de I/O de arquivos do Hemlock.

---

## Visao Geral

Hemlock fornece uma **API de objeto de arquivo** para operacoes de arquivo com tratamento de erros e gerenciamento de recursos adequados. Arquivos devem ser abertos e fechados manualmente.

**Caracteristicas Principais:**
- Objetos de arquivo com metodos
- Leitura e escrita de texto e dados binarios
- Operacoes de posicionamento
- Mensagens de erro adequadas
- Gerenciamento manual de recursos (sem RAII)

---

## Tipo File

**Tipo:** `file`

**Descricao:** Handle de arquivo para operacoes de I/O

**Propriedades (somente leitura):**
- `.path` - Caminho do arquivo (string)
- `.mode` - Modo de abertura (string)
- `.closed` - Se o arquivo esta fechado (bool)

---

## Abrindo Arquivos

### open

Abre um arquivo para leitura, escrita ou ambos.

**Assinatura:**
```hemlock
open(path: string, mode?: string): file
```

**Parametros:**
- `path` - Caminho do arquivo (relativo ou absoluto)
- `mode` (opcional) - Modo de abertura (padrao: `"r"`)

**Retorna:** Objeto de arquivo

**Modos:**
- `"r"` - Leitura (padrao)
- `"w"` - Escrita (trunca arquivo existente)
- `"a"` - Acrescentar
- `"r+"` - Leitura e escrita
- `"w+"` - Leitura e escrita (trunca)
- `"a+"` - Leitura e acrescentar

**Exemplo:**
```hemlock
// Modo de leitura (padrao)
let f = open("data.txt");
let f_read = open("data.txt", "r");

// Modo de escrita (trunca)
let f_write = open("output.txt", "w");

// Modo de acrescentar
let f_append = open("log.txt", "a");

// Modo de leitura e escrita
let f_rw = open("data.bin", "r+");

// Leitura e escrita (trunca)
let f_rw_trunc = open("output.bin", "w+");

// Leitura e acrescentar
let f_ra = open("log.txt", "a+");
```

**Tratamento de Erros:**
```hemlock
try {
    let f = open("missing.txt", "r");
} catch (e) {
    print("Falha ao abrir:", e);
    // Erro: Failed to open 'missing.txt': No such file or directory
}
```

**Importante:** Arquivos devem ser fechados manualmente usando `f.close()` para evitar vazamento de descritores de arquivo.

---

## Metodos de Arquivo

### Leitura

#### read

Le texto de um arquivo.

**Assinatura:**
```hemlock
file.read(size?: i32): string
```

**Parametros:**
- `size` (opcional) - Numero de bytes a ler (se omitido, le ate o fim do arquivo)

**Retorna:** String contendo o conteudo do arquivo

**Exemplo:**
```hemlock
let f = open("data.txt", "r");

// Le o arquivo inteiro
let all = f.read();
print(all);

// Le quantidade especificada de bytes
let chunk = f.read(1024);

f.close();
```

**Comportamento:**
- Le a partir da posicao atual do arquivo
- Retorna string vazia no fim do arquivo
- Avanca a posicao do arquivo

**Erros:**
- Ler de arquivo fechado
- Ler de arquivo somente escrita

---

#### read_bytes

Le dados binarios de um arquivo.

**Assinatura:**
```hemlock
file.read_bytes(size: i32): buffer
```

**Parametros:**
- `size` - Numero de bytes a ler

**Retorna:** Buffer contendo dados binarios

**Exemplo:**
```hemlock
let f = open("data.bin", "r");

// Le 256 bytes
let binary = f.read_bytes(256);
print(binary.length);       // 256

// Processa dados binarios
let i = 0;
while (i < binary.length) {
    print(binary[i]);
    i = i + 1;
}

f.close();
```

**Comportamento:**
- Le quantidade exata de bytes
- Retorna buffer (nao string)
- Avanca a posicao do arquivo

---

### Escrita

#### write

Escreve texto em um arquivo.

**Assinatura:**
```hemlock
file.write(data: string): i32
```

**Parametros:**
- `data` - String a ser escrita

**Retorna:** Numero de bytes escritos (i32)

**Exemplo:**
```hemlock
let f = open("output.txt", "w");

// Escreve texto
let written = f.write("Hello, World!\n");
print("Escreveu", written, "bytes");

// Multiplas escritas
f.write("Linha 1\n");
f.write("Linha 2\n");
f.write("Linha 3\n");

f.close();
```

**Comportamento:**
- Escreve na posicao atual do arquivo
- Retorna numero de bytes escritos
- Avanca a posicao do arquivo

**Erros:**
- Escrever em arquivo fechado
- Escrever em arquivo somente leitura

---

#### write_bytes

Escreve dados binarios em um arquivo.

**Assinatura:**
```hemlock
file.write_bytes(data: buffer): i32
```

**Parametros:**
- `data` - Buffer a ser escrito

**Retorna:** Numero de bytes escritos (i32)

**Exemplo:**
```hemlock
let f = open("output.bin", "w");

// Cria buffer
let buf = buffer(10);
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

// Escreve buffer
let written = f.write_bytes(buf);
print("Escreveu", written, "bytes");

f.close();
```

**Comportamento:**
- Escreve conteudo do buffer no arquivo
- Retorna numero de bytes escritos
- Avanca a posicao do arquivo

---

### Posicionamento

#### seek

Move a posicao do arquivo para um deslocamento de byte especificado.

**Assinatura:**
```hemlock
file.seek(position: i32): i32
```

**Parametros:**
- `position` - Deslocamento em bytes a partir do inicio do arquivo

**Retorna:** Nova posicao do arquivo (i32)

**Exemplo:**
```hemlock
let f = open("data.txt", "r");

// Pula para o byte 100
f.seek(100);

// Le a partir dessa posicao
let chunk = f.read(50);

// Volta ao inicio
f.seek(0);

// Le a partir do inicio
let all = f.read();

f.close();
```

**Comportamento:**
- Define a posicao do arquivo como deslocamento absoluto
- Retorna a nova posicao
- Permite posicionar alem do fim do arquivo (criar buracos ao escrever)

---

#### tell

Obtem a posicao atual do arquivo.

**Assinatura:**
```hemlock
file.tell(): i32
```

**Retorna:** Deslocamento atual em bytes a partir do inicio do arquivo (i32)

**Exemplo:**
```hemlock
let f = open("data.txt", "r");

print(f.tell());        // 0 (no inicio)

f.read(100);
print(f.tell());        // 100 (apos ler)

f.seek(50);
print(f.tell());        // 50 (apos seek)

f.close();
```

---

### Fechamento

#### close

Fecha o arquivo (idempotente).

**Assinatura:**
```hemlock
file.close(): null
```

**Retorna:** `null`

**Exemplo:**
```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();

// Pode ser chamado multiplas vezes com seguranca
f.close();  // Sem erro
f.close();  // Sem erro
```

**Comportamento:**
- Fecha o handle do arquivo
- Libera qualquer escrita pendente
- Idempotente (pode ser chamado multiplas vezes com seguranca)
- Define a propriedade `.closed` como `true`

**Importante:** Sempre feche arquivos quando terminar para evitar vazamento de descritores de arquivo.

---

## Propriedades de Arquivo

### .path

Obtem o caminho do arquivo.

**Tipo:** `string`

**Acesso:** Somente leitura

**Exemplo:**
```hemlock
let f = open("/path/to/file.txt", "r");
print(f.path);          // "/path/to/file.txt"
f.close();
```

---

### .mode

Obtem o modo de abertura.

**Tipo:** `string`

**Acesso:** Somente leitura

**Exemplo:**
```hemlock
let f = open("data.txt", "r");
print(f.mode);          // "r"
f.close();

let f2 = open("output.txt", "w");
print(f2.mode);         // "w"
f2.close();
```

---

### .closed

Verifica se o arquivo esta fechado.

**Tipo:** `bool`

**Acesso:** Somente leitura

**Exemplo:**
```hemlock
let f = open("data.txt", "r");
print(f.closed);        // false

f.close();
print(f.closed);        // true
```

---

## Tratamento de Erros

Todas as operacoes de arquivo incluem mensagens de erro adequadas com contexto:

### Arquivo Nao Encontrado
```hemlock
let f = open("missing.txt", "r");
// Erro: Failed to open 'missing.txt': No such file or directory
```

### Ler de Arquivo Fechado
```hemlock
let f = open("data.txt", "r");
f.close();
f.read();
// Erro: Cannot read from closed file 'data.txt'
```

### Escrever em Arquivo Somente Leitura
```hemlock
let f = open("readonly.txt", "r");
f.write("data");
// Erro: Cannot write to file 'readonly.txt' opened in read-only mode
```

### Usando try/catch
```hemlock
let f = null;
try {
    f = open("data.txt", "r");
    let content = f.read();
    print(content);
} catch (e) {
    print("Erro de arquivo:", e);
} finally {
    if (f != null && !f.closed) {
        f.close();
    }
}
```

---

## Padroes de Gerenciamento de Recursos

### Padrao Basico

```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();
```

### Com Tratamento de Erros

```hemlock
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();  // Sempre fecha, mesmo com erro
}
```

### Padrao Seguro

```hemlock
let f = null;
try {
    f = open("data.txt", "r");
    let content = f.read();
    // ... processa conteudo ...
} catch (e) {
    print("Erro:", e);
} finally {
    if (f != null && !f.closed) {
        f.close();
    }
}
```

---

## Exemplos de Uso

### Ler Arquivo Inteiro

```hemlock
fn read_file(filename: string): string {
    let f = open(filename, "r");
    let content = f.read();
    f.close();
    return content;
}

let text = read_file("data.txt");
print(text);
```

### Escrever Arquivo de Texto

```hemlock
fn write_file(filename: string, content: string) {
    let f = open(filename, "w");
    f.write(content);
    f.close();
}

write_file("output.txt", "Hello, World!\n");
```

### Acrescentar a Arquivo

```hemlock
fn append_file(filename: string, line: string) {
    let f = open(filename, "a");
    f.write(line + "\n");
    f.close();
}

append_file("log.txt", "Entrada de log 1");
append_file("log.txt", "Entrada de log 2");
```

### Ler Arquivo Binario

```hemlock
fn read_binary(filename: string, size: i32): buffer {
    let f = open(filename, "r");
    let data = f.read_bytes(size);
    f.close();
    return data;
}

let binary = read_binary("data.bin", 256);
print("Leu", binary.length, "bytes");
```

### Escrever Arquivo Binario

```hemlock
fn write_binary(filename: string, data: buffer) {
    let f = open(filename, "w");
    f.write_bytes(data);
    f.close();
}

let buf = buffer(10);
buf[0] = 65;
write_binary("output.bin", buf);
```

### Ler Arquivo Linha por Linha

```hemlock
fn read_lines(filename: string): array {
    let f = open(filename, "r");
    let content = f.read();
    f.close();
    return content.split("\n");
}

let lines = read_lines("data.txt");
let i = 0;
while (i < lines.length) {
    print("Linha", i, ":", lines[i]);
    i = i + 1;
}
```

### Copiar Arquivo

```hemlock
fn copy_file(src: string, dest: string) {
    let f_in = open(src, "r");
    let f_out = open(dest, "w");

    let content = f_in.read();
    f_out.write(content);

    f_in.close();
    f_out.close();
}

copy_file("input.txt", "output.txt");
```

### Ler Arquivo em Pedacos

```hemlock
fn process_chunks(filename: string) {
    let f = open(filename, "r");

    while (true) {
        let chunk = f.read(1024);  // Le 1KB por vez
        if (chunk.length == 0) {
            break;  // Fim do arquivo
        }

        // Processa pedaco
        print("Processando", chunk.length, "bytes");
    }

    f.close();
}

process_chunks("large_file.txt");
```

---

## Resumo Completo dos Metodos

| Metodo        | Assinatura               | Retorna   | Descricao                        |
|---------------|--------------------------|-----------|----------------------------------|
| `read`        | `(size?: i32)`           | `string`  | Le texto                         |
| `read_bytes`  | `(size: i32)`            | `buffer`  | Le dados binarios                |
| `write`       | `(data: string)`         | `i32`     | Escreve texto                    |
| `write_bytes` | `(data: buffer)`         | `i32`     | Escreve dados binarios           |
| `seek`        | `(position: i32)`        | `i32`     | Define posicao do arquivo        |
| `tell`        | `()`                     | `i32`     | Obtem posicao do arquivo         |
| `close`       | `()`                     | `null`    | Fecha arquivo (idempotente)      |

---

## Resumo Completo das Propriedades

| Propriedade | Tipo     | Acesso        | Descricao              |
|-------------|----------|---------------|------------------------|
| `.path`     | `string` | Somente leitura | Caminho do arquivo   |
| `.mode`     | `string` | Somente leitura | Modo de abertura     |
| `.closed`   | `bool`   | Somente leitura | Se o arquivo esta fechado |

---

## Migrando da API Antiga

**API Antiga (removida):**
- `read_file(path)` - Use `open(path, "r").read()`
- `write_file(path, data)` - Use `open(path, "w").write(data)`
- `append_file(path, data)` - Use `open(path, "a").write(data)`
- `file_exists(path)` - Sem substituto por enquanto

**Exemplo de Migracao:**
```hemlock
// Antigo (v0.0)
let content = read_file("data.txt");
write_file("output.txt", content);

// Novo (v0.1)
let f = open("data.txt", "r");
let content = f.read();
f.close();

let f2 = open("output.txt", "w");
f2.write(content);
f2.close();
```

---

## Veja Tambem

- [Funcoes Integradas](#reference-builtins) - Funcao `open()`
- [API de Memoria](#reference-memory-api) - Tipo buffer
- [API de Strings](#reference-string-api) - Metodos de string para processamento de texto


--------------------------------------------------------------------------------
## API de Arrays
--------------------------------------------------------------------------------

# Referencia da API de Arrays

Documentacao completa do tipo array do Hemlock e todos os seus 18 metodos de array.

---

## Visao Geral

Arrays em Hemlock sao sequencias **dinamicas, alocadas no heap** que podem armazenar tipos mistos. Eles fornecem metodos abrangentes para manipulacao e processamento de dados.

**Caracteristicas Principais:**
- Tamanho dinamico (cresce automaticamente)
- Indexacao comecando em zero
- Permite tipos mistos
- 18 metodos integrados
- Alocado no heap e rastreia capacidade

---

## Tipo Array

**Tipo:** `array`

**Propriedades:**
- `.length` - Numero de elementos (i32)

**Sintaxe Literal:** Colchetes `[elem1, elem2, ...]`

**Exemplo:**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);     // 5

// Tipos mistos
let mixed = [1, "hello", true, null];
print(mixed.length);   // 4

// Array vazio
let empty = [];
print(empty.length);   // 0
```

---

## Indexacao

Arrays suportam indexacao baseada em zero usando `[]`:

**Acesso de Leitura:**
```hemlock
let arr = [10, 20, 30];
print(arr[0]);         // 10
print(arr[1]);         // 20
print(arr[2]);         // 30
```

**Acesso de Escrita:**
```hemlock
let arr = [10, 20, 30];
arr[0] = 99;
arr[1] = 88;
print(arr);            // [99, 88, 30]
```

**Nota:** A indexacao direta nao verifica limites. Use metodos para seguranca.

---

## Propriedades do Array

### .length

Obtem o numero de elementos no array.

**Tipo:** `i32`

**Exemplo:**
```hemlock
let arr = [1, 2, 3];
print(arr.length);     // 3

let empty = [];
print(empty.length);   // 0

// O comprimento muda dinamicamente
arr.push(4);
print(arr.length);     // 4

arr.pop();
print(arr.length);     // 3
```

---

## Metodos do Array

### Operacoes de Pilha

#### push

Adiciona um elemento ao final do array.

**Assinatura:**
```hemlock
array.push(value: any): null
```

**Parametros:**
- `value` - O elemento a ser adicionado

**Retorna:** `null`

**Modifica o Original:** Sim (modifica o array no local)

**Exemplo:**
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]
arr.push("hello");     // [1, 2, 3, 4, 5, "hello"]
```

---

#### pop

Remove e retorna o ultimo elemento.

**Assinatura:**
```hemlock
array.pop(): any
```

**Retorna:** O ultimo elemento (removido do array)

**Modifica o Original:** Sim (modifica o array no local)

**Exemplo:**
```hemlock
let arr = [1, 2, 3];
let last = arr.pop();  // 3
print(arr);            // [1, 2]

let last2 = arr.pop(); // 2
print(arr);            // [1]
```

**Erro:** Lanca erro de tempo de execucao se o array estiver vazio.

---

### Operacoes de Fila

#### shift

Remove e retorna o primeiro elemento.

**Assinatura:**
```hemlock
array.shift(): any
```

**Retorna:** O primeiro elemento (removido do array)

**Modifica o Original:** Sim (modifica o array no local)

**Exemplo:**
```hemlock
let arr = [1, 2, 3];
let first = arr.shift();  // 1
print(arr);               // [2, 3]

let first2 = arr.shift(); // 2
print(arr);               // [3]
```

**Erro:** Lanca erro de tempo de execucao se o array estiver vazio.

---

#### unshift

Adiciona um elemento ao inicio do array.

**Assinatura:**
```hemlock
array.unshift(value: any): null
```

**Parametros:**
- `value` - O elemento a ser adicionado

**Retorna:** `null`

**Modifica o Original:** Sim (modifica o array no local)

**Exemplo:**
```hemlock
let arr = [2, 3];
arr.unshift(1);        // [1, 2, 3]
arr.unshift(0);        // [0, 1, 2, 3]
```

---

### Insercao e Remocao

#### insert

Insere um elemento em um indice especificado.

**Assinatura:**
```hemlock
array.insert(index: i32, value: any): null
```

**Parametros:**
- `index` - Posicao de insercao (baseada em 0)
- `value` - Elemento a ser inserido

**Retorna:** `null`

**Modifica o Original:** Sim (modifica o array no local)

**Exemplo:**
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // [1, 2, 3, 4, 5]

let arr2 = [1, 3];
arr2.insert(1, 2);     // [1, 2, 3]

// Insere no final
arr2.insert(arr2.length, 4);  // [1, 2, 3, 4]
```

**Comportamento:** Desloca elementos no indice e apos para a direita.

---

#### remove

Remove e retorna o elemento em um indice especificado.

**Assinatura:**
```hemlock
array.remove(index: i32): any
```

**Parametros:**
- `index` - Posicao a ser removida (baseada em 0)

**Retorna:** O elemento removido

**Modifica o Original:** Sim (modifica o array no local)

**Exemplo:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let removed = arr.remove(0);  // 1
print(arr);                   // [2, 3, 4, 5]

let removed2 = arr.remove(2); // 4
print(arr);                   // [2, 3, 5]
```

**Comportamento:** Desloca elementos apos o indice para a esquerda.

**Erro:** Lanca erro de tempo de execucao se o indice estiver fora dos limites.

---

### Busca e Localizacao

#### find

Encontra a primeira ocorrencia de um valor.

**Assinatura:**
```hemlock
array.find(value: any): i32
```

**Parametros:**
- `value` - O valor a ser buscado

**Retorna:** Indice da primeira ocorrencia, ou `-1` se nao encontrado

**Exemplo:**
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2
let idx2 = arr.find(99);     // -1 (nao encontrado)

// Encontra primeira duplicata
let arr2 = [1, 2, 3, 2, 4];
let idx3 = arr2.find(2);     // 1 (primeira ocorrencia)
```

**Comparacao:** Usa igualdade de valor para tipos primitivos e strings.

---

#### contains

Verifica se o array contem um valor.

**Assinatura:**
```hemlock
array.contains(value: any): bool
```

**Parametros:**
- `value` - O valor a ser buscado

**Retorna:** `true` se encontrado, caso contrario `false`

**Exemplo:**
```hemlock
let arr = [10, 20, 30, 40];
let has = arr.contains(20);  // true
let has2 = arr.contains(99); // false

// Funciona com strings tambem
let words = ["hello", "world"];
let has3 = words.contains("hello");  // true
```

---

### Fatiamento e Extracao

#### slice

Extrai um sub-array por intervalo (final exclusivo).

**Assinatura:**
```hemlock
array.slice(start: i32, end: i32): array
```

**Parametros:**
- `start` - Indice inicial (baseado em 0, inclusivo)
- `end` - Indice final (exclusivo)

**Retorna:** Novo array contendo elementos no intervalo [start, end)

**Modifica o Original:** Nao (retorna novo array)

**Exemplo:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);   // [2, 3, 4]
let first_three = arr.slice(0, 3);  // [1, 2, 3]
let last_two = arr.slice(3, 5);     // [4, 5]

// Fatia vazia
let empty = arr.slice(2, 2); // []
```

---

#### first

Obtem o primeiro elemento sem remover.

**Assinatura:**
```hemlock
array.first(): any
```

**Retorna:** O primeiro elemento

**Modifica o Original:** Nao

**Exemplo:**
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1
print(arr);                  // [1, 2, 3] (inalterado)
```

**Erro:** Lanca erro de tempo de execucao se o array estiver vazio.

---

#### last

Obtem o ultimo elemento sem remover.

**Assinatura:**
```hemlock
array.last(): any
```

**Retorna:** O ultimo elemento

**Modifica o Original:** Nao

**Exemplo:**
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3
print(arr);                  // [1, 2, 3] (inalterado)
```

**Erro:** Lanca erro de tempo de execucao se o array estiver vazio.

---

### Operacoes com Arrays

#### reverse

Inverte o array no local.

**Assinatura:**
```hemlock
array.reverse(): null
```

**Retorna:** `null`

**Modifica o Original:** Sim (modifica o array no local)

**Exemplo:**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]
print(arr);                  // [5, 4, 3, 2, 1]

let words = ["hello", "world"];
words.reverse();             // ["world", "hello"]
```

---

#### clear

Remove todos os elementos do array.

**Assinatura:**
```hemlock
array.clear(): null
```

**Retorna:** `null`

**Modifica o Original:** Sim (modifica o array no local)

**Exemplo:**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();
print(arr);                  // []
print(arr.length);           // 0
```

---

### Combinacao de Arrays

#### concat

Concatena com outro array.

**Assinatura:**
```hemlock
array.concat(other: array): array
```

**Parametros:**
- `other` - O array a ser concatenado

**Retorna:** Novo array contendo elementos de ambos os arrays

**Modifica o Original:** Nao (retorna novo array)

**Exemplo:**
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]
print(a);                    // [1, 2, 3] (inalterado)
print(b);                    // [4, 5, 6] (inalterado)

// Concatenacao em cadeia
let c = [7, 8];
let all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]
```

---

### Operacoes Funcionais

#### map

Transforma cada elemento usando uma funcao callback.

**Assinatura:**
```hemlock
array.map(callback: fn): array
```

**Parametros:**
- `callback` - Funcao que recebe um elemento e retorna o valor transformado

**Retorna:** Novo array contendo elementos transformados

**Modifica o Original:** Nao (retorna novo array)

**Exemplo:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let doubled = arr.map(fn(x) { return x * 2; });
print(doubled);  // [2, 4, 6, 8, 10]

let names = ["alice", "bob"];
let upper = names.map(fn(s) { return s.to_upper(); });
print(upper);  // ["ALICE", "BOB"]
```

---

#### filter

Seleciona elementos que correspondem a um predicado.

**Assinatura:**
```hemlock
array.filter(predicate: fn): array
```

**Parametros:**
- `predicate` - Funcao que recebe um elemento e retorna bool

**Retorna:** Novo array contendo elementos para os quais o predicado retorna true

**Modifica o Original:** Nao (retorna novo array)

**Exemplo:**
```hemlock
let arr = [1, 2, 3, 4, 5, 6];
let evens = arr.filter(fn(x) { return x % 2 == 0; });
print(evens);  // [2, 4, 6]

let words = ["hello", "hi", "hey", "goodbye"];
let short = words.filter(fn(s) { return s.length < 4; });
print(short);  // ["hi", "hey"]
```

---

#### reduce

Reduz o array a um unico valor usando um acumulador.

**Assinatura:**
```hemlock
array.reduce(callback: fn, initial: any): any
```

**Parametros:**
- `callback` - Funcao que recebe (acumulador, elemento) e retorna novo acumulador
- `initial` - Valor inicial do acumulador

**Retorna:** Valor acumulado final

**Modifica o Original:** Nao

**Exemplo:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sum = arr.reduce(fn(acc, x) { return acc + x; }, 0);
print(sum);  // 15

let product = arr.reduce(fn(acc, x) { return acc * x; }, 1);
print(product);  // 120

// Encontra o maximo
let max = arr.reduce(fn(acc, x) {
    if (x > acc) { return x; }
    return acc;
}, arr[0]);
print(max);  // 5
```

---

### Conversao para String

#### join

Junta elementos em uma string usando um delimitador.

**Assinatura:**
```hemlock
array.join(delimiter: string): string
```

**Parametros:**
- `delimiter` - String a ser colocada entre os elementos

**Retorna:** String concatenando todos os elementos

**Exemplo:**
```hemlock
let words = ["hello", "world", "foo"];
let joined = words.join(" ");  // "hello world foo"

let numbers = [1, 2, 3];
let csv = numbers.join(",");   // "1,2,3"

// Funciona com tipos mistos tambem
let mixed = [1, "hello", true, null];
print(mixed.join(" | "));  // "1 | hello | true | null"

// Delimitador vazio
let arr = ["a", "b", "c"];
let s = arr.join("");          // "abc"
```

**Comportamento:** Converte automaticamente todos os elementos para strings.

---

## Encadeamento de Metodos

Metodos de array podem ser encadeados para operacoes concisas:

**Exemplo:**
```hemlock
// Encadeando slice e join
let result = ["apple", "banana", "cherry", "date"]
    .slice(0, 2)
    .join(" and ");  // "apple and banana"

// Encadeando concat e slice
let combined = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);    // [3, 4, 5]

// Encadeamento complexo
let words = ["hello", "world", "foo", "bar"];
let result2 = words
    .slice(0, 3)
    .concat(["baz"])
    .join("-");      // "hello-world-foo-baz"
```

---

## Resumo Completo dos Metodos

### Metodos que Modificam

Metodos que modificam o array no local:

| Metodo     | Assinatura                   | Retorna   | Descricao                      |
|------------|------------------------------|-----------|--------------------------------|
| `push`     | `(value: any)`               | `null`    | Adiciona ao final              |
| `pop`      | `()`                         | `any`     | Remove do final                |
| `shift`    | `()`                         | `any`     | Remove do inicio               |
| `unshift`  | `(value: any)`               | `null`    | Adiciona ao inicio             |
| `insert`   | `(index: i32, value: any)`   | `null`    | Insere no indice               |
| `remove`   | `(index: i32)`               | `any`     | Remove no indice               |
| `reverse`  | `()`                         | `null`    | Inverte no local               |
| `clear`    | `()`                         | `null`    | Remove todos os elementos      |

### Metodos que Nao Modificam

Metodos que retornam novos valores sem modificar o original:

| Metodo     | Assinatura                       | Retorna   | Descricao                      |
|------------|----------------------------------|-----------|--------------------------------|
| `find`     | `(value: any)`                   | `i32`     | Encontra primeira ocorrencia   |
| `contains` | `(value: any)`                   | `bool`    | Verifica se contem valor       |
| `slice`    | `(start: i32, end: i32)`         | `array`   | Extrai sub-array               |
| `first`    | `()`                             | `any`     | Obtem primeiro elemento        |
| `last`     | `()`                             | `any`     | Obtem ultimo elemento          |
| `concat`   | `(other: array)`                 | `array`   | Concatena arrays               |
| `join`     | `(delimiter: string)`            | `string`  | Junta elementos em string      |
| `map`      | `(callback: fn)`                 | `array`   | Transforma cada elemento       |
| `filter`   | `(predicate: fn)`                | `array`   | Seleciona elementos            |
| `reduce`   | `(callback: fn, initial: any)`   | `any`     | Reduz a um unico valor         |

---

## Padroes de Uso

### Uso como Pilha

```hemlock
let stack = [];

// Empilhar
stack.push(1);
stack.push(2);
stack.push(3);

// Desempilhar
while (stack.length > 0) {
    let item = stack.pop();
    print(item);  // 3, 2, 1
}
```

### Uso como Fila

```hemlock
let queue = [];

// Enfileirar
queue.push(1);
queue.push(2);
queue.push(3);

// Desenfileirar
while (queue.length > 0) {
    let item = queue.shift();
    print(item);  // 1, 2, 3
}
```

### Transformacao de Array

```hemlock
// Filtragem (modo manual)
let numbers = [1, 2, 3, 4, 5, 6];
let evens = [];
let i = 0;
while (i < numbers.length) {
    if (numbers[i] % 2 == 0) {
        evens.push(numbers[i]);
    }
    i = i + 1;
}

// Mapeamento (modo manual)
let numbers2 = [1, 2, 3, 4, 5];
let doubled = [];
let j = 0;
while (j < numbers2.length) {
    doubled.push(numbers2[j] * 2);
    j = j + 1;
}
```

### Construindo Arrays

```hemlock
let arr = [];

// Construir array com loop
let i = 0;
while (i < 10) {
    arr.push(i * 10);
    i = i + 1;
}

print(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
```

---

## Detalhes de Implementacao

**Gerenciamento de Capacidade:**
- Arrays crescem automaticamente conforme necessario
- Capacidade dobra quando excedida
- Sem controle manual de capacidade

**Comparacao de Valores:**
- `find()` e `contains()` usam igualdade de valor
- Funciona corretamente para tipos primitivos e strings
- Objetos/arrays sao comparados por referencia

**Memoria:**
- Alocado no heap
- Sem liberacao automatica (gerenciamento manual de memoria)
- Acesso direto por indice nao verifica limites

---

## Veja Tambem

- [Sistema de Tipos](#reference-type-system) - Detalhes do tipo array
- [API de Strings](#reference-string-api) - Resultado do join() em strings
- [Operadores](#reference-operators) - Operador de indexacao de array


--------------------------------------------------------------------------------
## API de Concorr√™ncia
--------------------------------------------------------------------------------

# Referencia da API de Concorrencia

Documentacao completa do sistema assincrono/concorrente do Hemlock.

---

## Visao Geral

Hemlock fornece **concorrencia estruturada** e verdadeiro paralelismo multithreaded usando threads POSIX (pthreads). Cada tarefa criada executa em uma thread de sistema operacional separada, permitindo execucao paralela real atraves de multiplos nucleos de CPU.

**Caracteristicas Principais:**
- Verdadeiro paralelismo multithreaded (nao green threads)
- Sintaxe de funcoes assincronas
- Criacao e uniao de tarefas
- Canais thread-safe
- Propagacao de excecoes

**Modelo de Threading:**
- Threads de SO reais (POSIX pthreads)
- Verdadeiro paralelismo (multiplos nucleos de CPU)
- Escalonamento do kernel (multitarefa preemptiva)
- Sincronizacao thread-safe (mutexes, variaveis de condicao)

---

## Funcoes Assincronas

### Declaracao de Funcao Assincrona

Funcoes podem ser declaradas como `async` para indicar que sao projetadas para execucao concorrente.

**Sintaxe:**
```hemlock
async fn nome_funcao(params): tipo_retorno {
    // corpo da funcao
}
```

**Exemplo:**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

async fn process_data(data: string) {
    print("Processando:", data);
    return null;
}
```

**Comportamento:**
- `async fn` declara uma funcao assincrona
- Pode ser chamada sincronamente (executa na thread atual)
- Pode ser criada como tarefa concorrente (executa em nova thread)
- Quando criada, executa em sua propria thread de SO

**Nota:** A palavra-chave `await` esta reservada para uso futuro, mas nao esta implementada atualmente.

---

## Gerenciamento de Tarefas

### spawn

Cria e inicia uma nova tarefa concorrente.

**Assinatura:**
```hemlock
spawn(async_fn: function, ...args): task
```

**Parametros:**
- `async_fn` - A funcao assincrona a executar
- `...args` - Argumentos a passar para a funcao

**Retorna:** Handle de tarefa

**Exemplo:**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Cria uma unica tarefa
let t = spawn(compute, 1000);
let result = join(t);
print(result);

// Cria multiplas tarefas (executam em paralelo!)
let t1 = spawn(compute, 100);
let t2 = spawn(compute, 200);
let t3 = spawn(compute, 300);

// Tres tarefas executando simultaneamente!

// Aguarda resultados
let r1 = join(t1);
let r2 = join(t2);
let r3 = join(t3);
```

**Comportamento:**
- Cria nova thread de SO via `pthread_create()`
- Comeca a executar a funcao imediatamente
- Retorna handle de tarefa para uniao posterior
- Tarefas executam em paralelo em nucleos de CPU separados

---

### join

Aguarda a conclusao de uma tarefa e obtem seu resultado.

**Assinatura:**
```hemlock
join(task: task): any
```

**Parametros:**
- `task` - Handle de tarefa de `spawn()`

**Retorna:** O valor de retorno da tarefa

**Exemplo:**
```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

let t = spawn(factorial, 10);
let result = join(t);  // Bloqueia ate a tarefa completar
print(result);         // 3628800
```

**Comportamento:**
- Bloqueia a thread atual ate a tarefa completar
- Retorna o valor de retorno da tarefa
- Propaga excecoes lancadas na tarefa
- Limpa recursos da tarefa apos retornar

**Tratamento de Erros:**
```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Tarefa falhou!";
    }
    return 42;
}

let t = spawn(risky_operation, 1);
try {
    let result = join(t);
} catch (e) {
    print("Capturado:", e);  // "Capturado: Tarefa falhou!"
}
```

---

### detach

Desanexa uma tarefa (execucao fire-and-forget).

**Assinatura:**
```hemlock
detach(task: task): null
```

**Parametros:**
- `task` - Handle de tarefa de `spawn()`

**Retorna:** `null`

**Exemplo:**
```hemlock
async fn background_work() {
    print("Trabalhando em segundo plano...");
    return null;
}

let t = spawn(background_work);
detach(t);  // Tarefa continua executando independentemente

// Nao pode unir tarefa desanexada
// join(t);  // Erro
```

**Comportamento:**
- Tarefa continua executando independentemente
- Nao pode fazer `join()` em tarefa desanexada
- Tarefa e thread sao limpos automaticamente quando completa

**Casos de Uso:**
- Tarefas de segundo plano fire-and-forget
- Tarefas de log/monitoramento
- Tarefas onde o valor de retorno nao e necessario

---

## Canais

Canais fornecem comunicacao thread-safe entre tarefas.

### channel

Cria um canal com buffer.

**Assinatura:**
```hemlock
channel(capacity: i32): channel
```

**Parametros:**
- `capacity` - Tamanho do buffer (numero de valores)

**Retorna:** Objeto de canal

**Exemplo:**
```hemlock
let ch = channel(10);  // Canal com buffer de capacidade 10
let ch2 = channel(1);  // Buffer minimo (sincrono)
let ch3 = channel(100); // Buffer grande
```

**Comportamento:**
- Cria canal thread-safe
- Usa pthread mutex para sincronizacao
- Capacidade e fixa na criacao

---

### Metodos de Canal

#### send

Envia um valor para o canal (bloqueia se cheio).

**Assinatura:**
```hemlock
channel.send(value: any): null
```

**Parametros:**
- `value` - Valor a enviar (qualquer tipo)

**Retorna:** `null`

**Exemplo:**
```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

let ch = channel(10);
let t = spawn(producer, ch, 5);
```

**Comportamento:**
- Envia valor para o canal
- Bloqueia se o canal estiver cheio
- Thread-safe (usa mutex)
- Retorna apos o valor ser enviado

---

#### recv

Recebe um valor do canal (bloqueia se vazio).

**Assinatura:**
```hemlock
channel.recv(): any
```

**Retorna:** Valor do canal, ou `null` se o canal estiver fechado e vazio

**Exemplo:**
```hemlock
async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(10);
let t = spawn(consumer, ch, 5);
```

**Comportamento:**
- Recebe valor do canal
- Bloqueia se o canal estiver vazio
- Retorna `null` se o canal estiver fechado e vazio
- Thread-safe (usa mutex)

---

#### close

Fecha o canal (nao permite mais envios).

**Assinatura:**
```hemlock
channel.close(): null
```

**Retorna:** `null`

**Exemplo:**
```hemlock
async fn producer(ch) {
    ch.send(1);
    ch.send(2);
    ch.send(3);
    ch.close();  // Sinaliza que nao ha mais valores
    return null;
}

async fn consumer(ch) {
    while (true) {
        let val = ch.recv();
        if (val == null) {
            break;  // Canal fechado
        }
        print(val);
    }
    return null;
}
```

**Comportamento:**
- Fecha o canal
- Nao permite mais envios
- `recv()` retorna `null` quando o canal estiver vazio
- Thread-safe

---

## Exemplo Completo de Concorrencia

### Padrao Produtor-Consumidor

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        print("Produzindo:", i);
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        print("Consumindo:", val);
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

// Cria canal
let ch = channel(10);

// Cria produtor e consumidor
let p = spawn(producer, ch, 5);
let c = spawn(consumer, ch, 5);

// Aguarda conclusao
join(p);
let total = join(c);
print("Total:", total);  // 0+10+20+30+40 = 100
```

---

## Computacao Paralela

### Exemplo Multi-Tarefa

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Cria multiplas tarefas (executam em paralelo!)
let t1 = spawn(factorial, 5);   // Thread 1
let t2 = spawn(factorial, 6);   // Thread 2
let t3 = spawn(factorial, 7);   // Thread 3
let t4 = spawn(factorial, 8);   // Thread 4

// Quatro tarefas computando simultaneamente!

// Aguarda resultados
let f5 = join(t1);  // 120
let f6 = join(t2);  // 720
let f7 = join(t3);  // 5040
let f8 = join(t4);  // 40320

print(f5, f6, f7, f8);
```

---

## Ciclo de Vida de Tarefas

### Transicoes de Estado

1. **Criada** - Tarefa foi criada mas ainda nao esta executando
2. **Executando** - Tarefa esta executando em thread de SO
3. **Completada** - Tarefa terminou (resultado disponivel)
4. **Unida** - Resultado foi obtido, recursos limpos
5. **Desanexada** - Tarefa continua executando independentemente

### Exemplo de Ciclo de Vida

```hemlock
async fn work(n: i32): i32 {
    return n * 2;
}

// 1. Cria tarefa
let t = spawn(work, 21);  // Estado: Executando

// Tarefa executa em thread separada...

// 2. Une tarefa
let result = join(t);     // Estado: Completada -> Unida
print(result);            // 42

// Recursos da tarefa sao limpos apos uniao
```

### Ciclo de Vida Desanexado

```hemlock
async fn background() {
    print("Tarefa de segundo plano executando");
    return null;
}

// 1. Cria tarefa
let t = spawn(background);  // Estado: Executando

// 2. Desanexa tarefa
detach(t);                  // Estado: Desanexada

// Tarefa continua executando independentemente
// Recursos limpos pelo SO quando completa
```

---

## Tratamento de Erros

### Propagacao de Excecoes

Excecoes lancadas em tarefas sao propagadas ao unir:

```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Tarefa falhou!";
    }
    return 42;
}

// Tarefa bem-sucedida
let t1 = spawn(risky_operation, 0);
let result1 = join(t1);  // 42

// Tarefa que falha
let t2 = spawn(risky_operation, 1);
try {
    let result2 = join(t2);
} catch (e) {
    print("Capturado:", e);  // "Capturado: Tarefa falhou!"
}
```

### Tratando Multiplas Tarefas

```hemlock
async fn work(id: i32, should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Tarefa " + typeof(id) + " falhou";
    }
    return id * 10;
}

let t1 = spawn(work, 1, 0);
let t2 = spawn(work, 2, 1);  // Vai falhar
let t3 = spawn(work, 3, 0);

// Une com tratamento de erros
try {
    let r1 = join(t1);  // OK
    print("Tarefa 1:", r1);

    let r2 = join(t2);  // Lanca excecao
    print("Tarefa 2:", r2);  // Nunca alcancado
} catch (e) {
    print("Erro:", e);  // "Erro: Tarefa 2 falhou"
}

// Ainda pode unir tarefas restantes
let r3 = join(t3);
print("Tarefa 3:", r3);
```

---

## Caracteristicas de Performance

### Verdadeiro Paralelismo

```hemlock
async fn cpu_intensive(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Execucao sequencial
let start = get_time();
let r1 = cpu_intensive(10000000);
let r2 = cpu_intensive(10000000);
let sequential_time = get_time() - start;

// Execucao paralela
let start2 = get_time();
let t1 = spawn(cpu_intensive, 10000000);
let t2 = spawn(cpu_intensive, 10000000);
join(t1);
join(t2);
let parallel_time = get_time() - start2;

// parallel_time deve ser ~50% de sequential_time em sistema multi-core
```

**Caracteristicas Comprovadas:**
- N tarefas podem utilizar N nucleos de CPU simultaneamente
- Testes de estresse mostram razao de tempo CPU/wall de 8-9x (prova de paralelismo)
- Overhead de thread: ~8KB de pilha + overhead de pthread por tarefa
- Operacao bloqueante em uma tarefa nao bloqueia outras tarefas

---

## Detalhes de Implementacao

### Modelo de Threading

- **Threading 1:1** - Cada tarefa = 1 thread de SO (`pthread`)
- **Escalonamento do Kernel** - Kernel do SO distribui threads entre nucleos
- **Multitarefa Preemptiva** - SO pode interromper e alternar threads
- **Sem GIL** - Sem lock de interpretador global (diferente de Python)

### Sincronizacao

- **Mutexes** - Canais usam `pthread_mutex_t`
- **Variaveis de Condicao** - send/recv bloqueantes usam `pthread_cond_t`
- **Operacoes Lock-Free** - Transicoes de estado de tarefa sao atomicas

### Memoria e Limpeza

- **Tarefas Unidas** - Limpas automaticamente apos `join()`
- **Tarefas Desanexadas** - Limpas automaticamente quando tarefa completa
- **Canais** - Contados por referencia, liberados quando nao mais em uso

---

## Limitacoes

- Sem `select()` para multiplexar multiplos canais
- Sem escalonador work-stealing (1 thread por tarefa)
- Sem integracao de I/O assincrono (operacoes de arquivo/rede bloqueiam)
- Capacidade de canal e fixa na criacao

---

## Resumo Completo da API

### Funcoes

| Funcao    | Assinatura                            | Retorna   | Descricao                           |
|-----------|---------------------------------------|-----------|-------------------------------------|
| `spawn`   | `(async_fn: function, ...args)`       | `task`    | Cria e inicia tarefa concorrente    |
| `join`    | `(task: task)`                        | `any`     | Aguarda tarefa, obtem resultado     |
| `detach`  | `(task: task)`                        | `null`    | Desanexa tarefa (fire-and-forget)   |
| `channel` | `(capacity: i32)`                     | `channel` | Cria canal thread-safe              |

### Metodos de Canal

| Metodo  | Assinatura        | Retorna | Descricao                           |
|---------|-------------------|---------|-------------------------------------|
| `send`  | `(value: any)`    | `null`  | Envia valor (bloqueia se cheio)     |
| `recv`  | `()`              | `any`   | Recebe valor (bloqueia se vazio)    |
| `close` | `()`              | `null`  | Fecha canal                         |

### Tipos

| Tipo      | Descricao                              |
|-----------|----------------------------------------|
| `task`    | Handle para uma tarefa concorrente     |
| `channel` | Canal de comunicacao thread-safe       |

---

## Melhores Praticas

### O Que Fazer

- Use canais para comunicacao entre tarefas
- Trate excecoes de tarefas unidas
- Feche canais apos enviar
- Use `join()` para obter resultados e limpar
- Apenas crie funcoes async

### O Que Nao Fazer

- Nao compartilhe estado mutavel sem sincronizacao
- Nao una a mesma tarefa duas vezes
- Nao envie para canal fechado
- Nao crie funcoes nao-async
- Nao esqueca de unir tarefas (a menos que desanexadas)

---

## Veja Tambem

- [Funcoes Integradas](#reference-builtins) - `spawn()`, `join()`, `detach()`, `channel()`
- [Sistema de Tipos](#reference-type-system) - Tipos task e channel


--------------------------------------------------------------------------------
## API de Mem√≥ria
--------------------------------------------------------------------------------

# Referencia da API de Memoria

Documentacao completa das funcoes de gerenciamento de memoria e tipos de ponteiro do Hemlock.

---

## Visao Geral

Hemlock fornece **gerenciamento manual de memoria** com alocacao e liberacao explicitas. A memoria e gerenciada atraves de dois tipos de ponteiro: ponteiros brutos (`ptr`) e buffers seguros (`buffer`).

**Principios Fundamentais:**
- Alocacao e liberacao explicitas
- Sem coleta de lixo
- Usuario responsavel por chamar `free()`
- Contagem de referencias interna para seguranca de escopo/reatribuicao (veja abaixo)

### Contagem de Referencias Interna

O runtime usa contagem de referencias internamente para gerenciar tempos de vida de objetos dentro de escopos. Para a maioria das variaveis locais, a limpeza e automatica.

**Automatico (sem `free()` necessario):**
- Variaveis locais de tipos com contagem de referencias (buffer, array, object, string) sao liberadas ao sair do escopo
- Reatribuicao de variavel libera o valor antigo
- Elementos de container sao liberados quando o container e liberado

**Requer `free()` manual:**
- Ponteiros brutos de `alloc()` - sempre requerem
- Limpeza antecipada antes do fim do escopo
- Dados de longa duracao/globais

Veja o [Guia de Gerenciamento de Memoria](../language-guide/memory.md#internal-reference-counting) para detalhes.

---

## Tipos de Ponteiro

### ptr (Ponteiro Bruto)

**Tipo:** `ptr`

**Descricao:** Endereco de memoria bruto sem verificacao de limites ou rastreamento.

**Tamanho:** 8 bytes

**Casos de Uso:**
- Operacoes de memoria de baixo nivel
- FFI (Interface de Funcao Estrangeira)
- Performance maxima (sem overhead)

**Seguranca:** Inseguro - sem verificacao de limites, usuario deve rastrear tempo de vida

**Exemplo:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

---

### buffer (Buffer Seguro)

**Tipo:** `buffer`

**Descricao:** Wrapper de ponteiro seguro com verificacao de limites.

**Estrutura:** Ponteiro + comprimento + capacidade + contagem de referencias

**Propriedades:**
- `.length` - Tamanho do buffer (i32)
- `.capacity` - Capacidade alocada (i32)

**Casos de Uso:**
- Maioria das alocacoes de memoria
- Quando seguranca e importante
- Arrays dinamicos

**Seguranca:** Verificacao de limites em acesso indexado

**Contagem de Referencias:** Buffers sao contados por referencia internamente. Liberacao automatica ao sair do escopo ou reatribuir variavel. Use `free()` para limpeza antecipada ou dados de longa duracao.

**Exemplo:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // Verificacao de limites
print(b.length);        // 64
free(b);
```

---

## Funcoes de Alocacao de Memoria

### alloc

Aloca memoria bruta.

**Assinatura:**
```hemlock
alloc(size: i32): ptr
```

**Parametros:**
- `size` - Numero de bytes a alocar

**Retorna:** Ponteiro para memoria alocada (`ptr`)

**Exemplo:**
```hemlock
let p = alloc(1024);        // Aloca 1KB
memset(p, 0, 1024);         // Inicializa com zeros
free(p);                    // Libera quando terminar

// Aloca para estrutura
let struct_size = 16;
let p2 = alloc(struct_size);
```

**Comportamento:**
- Retorna memoria nao inicializada
- Memoria deve ser liberada manualmente
- Retorna `null` em falha de alocacao (chamador deve verificar)

**Veja Tambem:** `buffer()` para alternativa mais segura

---

### buffer

Aloca buffer seguro com verificacao de limites.

**Assinatura:**
```hemlock
buffer(size: i32): buffer
```

**Parametros:**
- `size` - Tamanho do buffer (bytes)

**Retorna:** Objeto buffer

**Exemplo:**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256
print(buf.capacity);        // 256

// Acesso com verificacao de limites
buf[0] = 65;                // 'A'
buf[255] = 90;              // 'Z'
// buf[256] = 0;            // Erro: fora dos limites

free(buf);
```

**Propriedades:**
- `.length` - Tamanho atual (i32)
- `.capacity` - Capacidade alocada (i32)

**Comportamento:**
- Inicializa memoria com zeros
- Fornece verificacao de limites em acesso indexado
- Retorna `null` em falha de alocacao (chamador deve verificar)
- Deve ser liberado manualmente

---

### free

Libera memoria alocada.

**Assinatura:**
```hemlock
free(ptr: ptr | buffer): null
```

**Parametros:**
- `ptr` - Ponteiro ou buffer a liberar

**Retorna:** `null`

**Exemplo:**
```hemlock
// Libera ponteiro bruto
let p = alloc(1024);
free(p);

// Libera buffer
let buf = buffer(256);
free(buf);
```

**Comportamento:**
- Libera memoria alocada por `alloc()` ou `buffer()`
- Liberacao dupla causa crash (responsabilidade do usuario evitar)
- Liberar ponteiro invalido causa comportamento indefinido

**Importante:** Voce aloca, voce libera. Sem limpeza automatica.

---

### realloc

Redimensiona memoria alocada.

**Assinatura:**
```hemlock
realloc(ptr: ptr, new_size: i32): ptr
```

**Parametros:**
- `ptr` - Ponteiro a redimensionar
- `new_size` - Novo tamanho (bytes)

**Retorna:** Ponteiro para memoria redimensionada (pode ser endereco diferente)

**Exemplo:**
```hemlock
let p = alloc(100);
// ... usa memoria ...

// Precisa de mais espaco
p = realloc(p, 200);        // Agora 200 bytes
// ... usa memoria expandida ...

free(p);
```

**Comportamento:**
- Pode mover memoria para novo local
- Preserva dados existentes (ate o minimo do tamanho antigo/novo)
- Ponteiro antigo invalido apos realloc bem-sucedido (use o ponteiro retornado)
- Se new_size for menor, dados sao truncados
- Retorna `null` em falha de alocacao (ponteiro original ainda valido)

**Importante:** Sempre verifique `null` e atualize variavel de ponteiro com o resultado.

---

## Operacoes de Memoria

### memset

Preenche memoria com um valor de byte.

**Assinatura:**
```hemlock
memset(ptr: ptr, byte: i32, size: i32): null
```

**Parametros:**
- `ptr` - Ponteiro para memoria
- `byte` - Valor de byte a preencher (0-255)
- `size` - Numero de bytes a preencher

**Retorna:** `null`

**Exemplo:**
```hemlock
let p = alloc(100);

// Zera memoria
memset(p, 0, 100);

// Preenche com valor especifico
memset(p, 0xFF, 100);

// Inicializa buffer
let buf = alloc(256);
memset(buf, 65, 256);       // Preenche com 'A'

free(p);
free(buf);
```

**Comportamento:**
- Escreve valor de byte em cada byte no intervalo
- Valor de byte truncado para 8 bits (0-255)
- Sem verificacao de limites (inseguro)

---

### memcpy

Copia memoria da origem para o destino.

**Assinatura:**
```hemlock
memcpy(dest: ptr, src: ptr, size: i32): null
```

**Parametros:**
- `dest` - Ponteiro de destino
- `src` - Ponteiro de origem
- `size` - Numero de bytes a copiar

**Retorna:** `null`

**Exemplo:**
```hemlock
let src = alloc(100);
let dest = alloc(100);

// Inicializa origem
memset(src, 65, 100);

// Copia para destino
memcpy(dest, src, 100);

// dest agora contem os mesmos dados que src

free(src);
free(dest);
```

**Comportamento:**
- Copia byte a byte de src para dest
- Sem verificacao de limites (inseguro)
- Comportamento indefinido para regioes sobrepostas (use com cuidado)

---

## Operacoes de Memoria Tipadas

### sizeof

Obtem o tamanho em bytes de um tipo.

**Assinatura:**
```hemlock
sizeof(type): i32
```

**Parametros:**
- `type` - Identificador de tipo (ex: `i32`, `f64`, `ptr`)

**Retorna:** Tamanho em bytes (i32)

**Tamanhos de Tipos:**

| Tipo | Tamanho (bytes) |
|------|-----------------|
| `i8` | 1 |
| `i16` | 2 |
| `i32`, `integer` | 4 |
| `i64` | 8 |
| `u8`, `byte` | 1 |
| `u16` | 2 |
| `u32` | 4 |
| `u64` | 8 |
| `f32` | 4 |
| `f64`, `number` | 8 |
| `bool` | 1 |
| `ptr` | 8 |
| `rune` | 4 |

**Exemplo:**
```hemlock
let int_size = sizeof(i32);      // 4
let ptr_size = sizeof(ptr);      // 8
let float_size = sizeof(f64);    // 8
let byte_size = sizeof(u8);      // 1
let rune_size = sizeof(rune);    // 4

// Calcula tamanho de alocacao de array
let count = 100;
let total = sizeof(i32) * count; // 400 bytes
```

**Comportamento:**
- Retorna 0 para tipo desconhecido
- Aceita identificadores de tipo e strings de tipo

---

### talloc

Aloca array de valores tipados.

**Assinatura:**
```hemlock
talloc(type, count: i32): ptr
```

**Parametros:**
- `type` - Tipo a alocar (ex: `i32`, `f64`, `ptr`)
- `count` - Numero de elementos (deve ser positivo)

**Retorna:** Ponteiro para array alocado, ou `null` em falha de alocacao

**Exemplo:**
```hemlock
let arr = talloc(i32, 100);      // Array de 100 i32 (400 bytes)
let floats = talloc(f64, 50);    // Array de 50 f64 (400 bytes)
let bytes = talloc(u8, 1024);    // Array de 1024 bytes

// Sempre verifique falha de alocacao
if (arr == null) {
    panic("alocacao falhou");
}

// Usa memoria alocada
// ...

free(arr);
free(floats);
free(bytes);
```

**Comportamento:**
- Aloca `sizeof(type) * count` bytes
- Retorna memoria nao inicializada
- Memoria deve ser liberada manualmente com `free()`
- Retorna `null` em falha de alocacao (chamador deve verificar)
- Panic se count nao for positivo

---

## Propriedades de Buffer

### .length

Obtem o tamanho do buffer.

**Tipo:** `i32`

**Acesso:** Somente leitura

**Exemplo:**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256

let buf2 = buffer(1024);
print(buf2.length);         // 1024
```

---

### .capacity

Obtem a capacidade do buffer.

**Tipo:** `i32`

**Acesso:** Somente leitura

**Exemplo:**
```hemlock
let buf = buffer(256);
print(buf.capacity);        // 256
```

**Nota:** Atualmente, `.length` e `.capacity` sao iguais para buffers criados com `buffer()`.

---

## Padroes de Uso

### Padrao de Alocacao Basica

```hemlock
// Aloca
let p = alloc(1024);
if (p == null) {
    panic("alocacao falhou");
}

// Usa
memset(p, 0, 1024);

// Libera
free(p);
```

### Padrao de Buffer Seguro

```hemlock
// Aloca buffer
let buf = buffer(256);
if (buf == null) {
    panic("alocacao de buffer falhou");
}

// Usa com verificacao de limites
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

// Libera
free(buf);
```

### Padrao de Crescimento Dinamico

```hemlock
let size = 100;
let p = alloc(size);
if (p == null) {
    panic("alocacao falhou");
}

// ... usa memoria ...

// Precisa de mais espaco - verifica falha
let new_p = realloc(p, 200);
if (new_p == null) {
    // Ponteiro original ainda valido, limpa
    free(p);
    panic("realloc falhou");
}
p = new_p;
size = 200;

// ... usa memoria expandida ...

free(p);
```

### Padrao de Copia de Memoria

```hemlock
let original = alloc(100);
memset(original, 65, 100);

// Cria copia
let copy = alloc(100);
memcpy(copy, original, 100);

free(original);
free(copy);
```

---

## Consideracoes de Seguranca

**Gerenciamento de memoria Hemlock e inseguro por design:**

### Armadilhas Comuns

**1. Vazamento de Memoria**
```hemlock
// Errado: vazamento de memoria
fn create_buffer() {
    let p = alloc(1024);
    return null;  // Memoria vazou!
}

// Correto: limpeza adequada
fn create_buffer() {
    let p = alloc(1024);
    // ... usa memoria ...
    free(p);
    return null;
}
```

**2. Uso Apos Liberacao**
```hemlock
// Errado: uso apos liberacao
let p = alloc(100);
free(p);
memset(p, 0, 100);  // Crash: usando memoria liberada

// Correto: nao usa apos liberar
let p2 = alloc(100);
memset(p2, 0, 100);
free(p2);
// Nao usa p2 depois disso
```

**3. Liberacao Dupla**
```hemlock
// Errado: liberacao dupla
let p = alloc(100);
free(p);
free(p);  // Crash: liberacao dupla

// Correto: libera apenas uma vez
let p2 = alloc(100);
free(p2);
```

**4. Estouro de Buffer (ptr)**
```hemlock
// Errado: estouro de buffer para ptr
let p = alloc(10);
memset(p, 65, 100);  // Crash: escrevendo alem da alocacao

// Correto: usa buffer para verificacao de limites
let buf = buffer(10);
// buf[100] = 65;  // Erro: verificacao de limites falha
```

**5. Ponteiro Pendurado**
```hemlock
// Errado: ponteiro pendurado
let p1 = alloc(100);
let p2 = p1;
free(p1);
memset(p2, 0, 100);  // Crash: p2 esta pendurado

// Correto: rastreia propriedade cuidadosamente
let p = alloc(100);
// ... usa p ...
free(p);
// Nao mantem outras referencias para p
```

**6. Falha de Alocacao Nao Verificada**
```hemlock
// Errado: nao verifica null
let p = alloc(1000000000);  // Pode falhar em pouca memoria
memset(p, 0, 1000000000);   // Crash: p e null

// Correto: sempre verifica resultado de alocacao
let p2 = alloc(1000000000);
if (p2 == null) {
    panic("sem memoria");
}
memset(p2, 0, 1000000000);
free(p2);
```

---

## Quando Usar O Que

### Use `buffer()` quando:
- Verificacao de limites e necessaria
- Trabalhando com dados dinamicos
- Seguranca e importante
- Aprendendo Hemlock

### Use `alloc()` quando:
- Performance maxima e necessaria
- FFI/interfaceando com C
- Voce sabe o layout exato de memoria
- Voce e um especialista

### Use `realloc()` quando:
- Crescendo/diminuindo alocacoes
- Arrays dinamicos
- Dados precisam ser preservados

---

## Resumo Completo das Funcoes

| Funcao    | Assinatura                                 | Retorna  | Descricao                  |
|-----------|--------------------------------------------|----------|----------------------------|
| `alloc`   | `(size: i32)`                              | `ptr`    | Aloca memoria bruta        |
| `buffer`  | `(size: i32)`                              | `buffer` | Aloca buffer seguro        |
| `free`    | `(ptr: ptr \| buffer)`                     | `null`   | Libera memoria             |
| `realloc` | `(ptr: ptr, new_size: i32)`                | `ptr`    | Redimensiona alocacao      |
| `memset`  | `(ptr: ptr, byte: i32, size: i32)`         | `null`   | Preenche memoria           |
| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`         | `null`   | Copia memoria              |
| `sizeof`  | `(type)`                                   | `i32`    | Obtem tamanho do tipo      |
| `talloc`  | `(type, count: i32)`                       | `ptr`    | Aloca array tipado         |

---

## Veja Tambem

- [Sistema de Tipos](#reference-type-system) - Tipos de ponteiro e buffer
- [Funcoes Integradas](#reference-builtins) - Todas as funcoes integradas
- [API de Strings](#reference-string-api) - Metodo `.to_bytes()` de strings


--------------------------------------------------------------------------------
## API de Strings
--------------------------------------------------------------------------------

# Referencia da API de Strings

Referencia completa do tipo string do Hemlock e todos os seus 19 metodos de string.

---

## Visao Geral

Strings em Hemlock sao sequencias **codificadas em UTF-8, mutaveis e alocadas no heap** com suporte completo a Unicode. Todas as operacoes sao baseadas em **pontos de codigo** (caracteres), nao em bytes.

**Caracteristicas Principais:**
- Codificacao UTF-8 (U+0000 a U+10FFFF)
- Mutavel (pode modificar caracteres no local)
- Indexacao baseada em pontos de codigo
- 19 metodos integrados
- Concatenacao automatica com operador `+`

---

## Tipo String

**Tipo:** `string`

**Propriedades:**
- `.length` - Numero de pontos de codigo (caracteres)
- `.byte_length` - Numero de bytes UTF-8

**Sintaxe Literal:** Aspas duplas `"texto"`

**Exemplo:**
```hemlock
let s = "hello";
print(s.length);        // 5 (pontos de codigo)
print(s.byte_length);   // 5 (bytes)

let emoji = "üöÄ";
print(emoji.length);        // 1 (um ponto de codigo)
print(emoji.byte_length);   // 4 (quatro bytes UTF-8)
```

---

## Indexacao

Strings suportam indexacao baseada em pontos de codigo usando `[]`:

**Acesso de Leitura:**
```hemlock
let s = "hello";
let ch = s[0];          // Retorna rune 'h'
```

**Acesso de Escrita:**
```hemlock
let s = "hello";
s[0] = 'H';             // Muta com rune (agora "Hello")
```

**Exemplo UTF-8:**
```hemlock
let text = "HiüöÄ!";
print(text[0]);         // 'H'
print(text[1]);         // 'i'
print(text[2]);         // 'üöÄ' (um ponto de codigo)
print(text[3]);         // '!'
```

---

## Concatenacao

Use o operador `+` para concatenar strings e runes:

**String + String:**
```hemlock
let s = "hello" + " " + "world";  // "hello world"
let msg = "Count: " + typeof(42); // "Count: 42"
```

**String + Rune:**
```hemlock
let greeting = "Hello" + '!';      // "Hello!"
let decorated = "Text" + '‚úì';      // "Text‚úì"
```

**Rune + String:**
```hemlock
let prefix = '>' + " Message";     // "> Message"
let bullet = '‚Ä¢' + " Item";        // "‚Ä¢ Item"
```

**Concatenacao Multipla:**
```hemlock
let msg = "Hi " + 'üëã' + " World " + 'üåç';  // "Hi üëã World üåç"
```

---

## Propriedades de String

### .length

Obtem o numero de pontos de codigo Unicode (caracteres).

**Tipo:** `i32`

**Exemplo:**
```hemlock
let s = "hello";
print(s.length);        // 5

let emoji = "üöÄ";
print(emoji.length);    // 1 (um ponto de codigo)

let text = "Hello üåç!";
print(text.length);     // 8 (7 ASCII + 1 emoji)
```

---

### .byte_length

Obtem o numero de bytes UTF-8.

**Tipo:** `i32`

**Exemplo:**
```hemlock
let s = "hello";
print(s.byte_length);   // 5 (1 byte por caractere ASCII)

let emoji = "üöÄ";
print(emoji.byte_length); // 4 (emoji sao 4 bytes UTF-8)

let text = "Hello üåç!";
print(text.byte_length);  // 11 (7 ASCII + 4 para emoji)
```

---

## Metodos de String

### Substrings e Fatiamento

#### substr

Extrai substring por posicao e comprimento.

**Assinatura:**
```hemlock
string.substr(start: i32, length: i32): string
```

**Parametros:**
- `start` - Indice do ponto de codigo inicial (baseado em 0)
- `length` - Numero de pontos de codigo a extrair

**Retorna:** Nova string

**Exemplo:**
```hemlock
let s = "hello world";
let sub = s.substr(6, 5);       // "world"
let first = s.substr(0, 5);     // "hello"

// Exemplo UTF-8
let text = "HiüöÄ!";
let emoji = text.substr(2, 1);  // "üöÄ"
```

---

#### slice

Extrai substring por intervalo (final exclusivo).

**Assinatura:**
```hemlock
string.slice(start: i32, end: i32): string
```

**Parametros:**
- `start` - Indice do ponto de codigo inicial (baseado em 0)
- `end` - Indice do ponto de codigo final (exclusivo)

**Retorna:** Nova string

**Exemplo:**
```hemlock
let s = "hello world";
let sub = s.slice(0, 5);        // "hello"
let world = s.slice(6, 11);     // "world"

// Exemplo UTF-8
let text = "HiüöÄ!";
let first_three = text.slice(0, 3);  // "HiüöÄ"
```

---

### Busca e Localizacao

#### find

Encontra a primeira ocorrencia de uma substring.

**Assinatura:**
```hemlock
string.find(needle: string): i32
```

**Parametros:**
- `needle` - A substring a ser buscada

**Retorna:** Indice do ponto de codigo da primeira ocorrencia, ou `-1` se nao encontrada

**Exemplo:**
```hemlock
let s = "hello world";
let pos = s.find("world");      // 6
let pos2 = s.find("foo");       // -1 (nao encontrado)
let pos3 = s.find("l");         // 2 (primeiro 'l')
```

---

#### contains

Verifica se a string contem uma substring.

**Assinatura:**
```hemlock
string.contains(needle: string): bool
```

**Parametros:**
- `needle` - A substring a ser buscada

**Retorna:** `true` se encontrada, caso contrario `false`

**Exemplo:**
```hemlock
let s = "hello world";
let has = s.contains("world");  // true
let has2 = s.contains("foo");   // false
```

---

### Divisao e Uniao

#### split

Divide a string em um array por delimitador.

**Assinatura:**
```hemlock
string.split(delimiter: string): array
```

**Parametros:**
- `delimiter` - A string pela qual dividir

**Retorna:** Array de strings

**Exemplo:**
```hemlock
let csv = "a,b,c";
let parts = csv.split(",");     // ["a", "b", "c"]

let path = "/usr/local/bin";
let dirs = path.split("/");     // ["", "usr", "local", "bin"]

let text = "hello world foo";
let words = text.split(" ");    // ["hello", "world", "foo"]
```

---

#### trim

Remove espacos em branco do inicio e fim.

**Assinatura:**
```hemlock
string.trim(): string
```

**Retorna:** Nova string com espacos removidos

**Exemplo:**
```hemlock
let s = "  hello  ";
let clean = s.trim();           // "hello"

let text = "\n\t  world  \n";
let clean2 = text.trim();       // "world"
```

---

### Conversao de Maiusculas/Minusculas

#### to_upper

Converte a string para maiusculas.

**Assinatura:**
```hemlock
string.to_upper(): string
```

**Retorna:** Nova string em maiusculas

**Exemplo:**
```hemlock
let s = "hello world";
let upper = s.to_upper();       // "HELLO WORLD"

let mixed = "HeLLo";
let upper2 = mixed.to_upper();  // "HELLO"
```

---

#### to_lower

Converte a string para minusculas.

**Assinatura:**
```hemlock
string.to_lower(): string
```

**Retorna:** Nova string em minusculas

**Exemplo:**
```hemlock
let s = "HELLO WORLD";
let lower = s.to_lower();       // "hello world"

let mixed = "HeLLo";
let lower2 = mixed.to_lower();  // "hello"
```

---

### Prefixo e Sufixo

#### starts_with

Verifica se a string comeca com o prefixo especificado.

**Assinatura:**
```hemlock
string.starts_with(prefix: string): bool
```

**Parametros:**
- `prefix` - O prefixo a verificar

**Retorna:** `true` se a string comecar com o prefixo, caso contrario `false`

**Exemplo:**
```hemlock
let s = "hello world";
let starts = s.starts_with("hello");  // true
let starts2 = s.starts_with("world"); // false
```

---

#### ends_with

Verifica se a string termina com o sufixo especificado.

**Assinatura:**
```hemlock
string.ends_with(suffix: string): bool
```

**Parametros:**
- `suffix` - O sufixo a verificar

**Retorna:** `true` se a string terminar com o sufixo, caso contrario `false`

**Exemplo:**
```hemlock
let s = "hello world";
let ends = s.ends_with("world");      // true
let ends2 = s.ends_with("hello");     // false
```

---

### Substituicao

#### replace

Substitui a primeira ocorrencia de uma substring.

**Assinatura:**
```hemlock
string.replace(old: string, new: string): string
```

**Parametros:**
- `old` - A substring a ser substituida
- `new` - A string de substituicao

**Retorna:** Nova string com a primeira ocorrencia substituida

**Exemplo:**
```hemlock
let s = "hello world";
let s2 = s.replace("world", "there");  // "hello there"

let text = "foo foo foo";
let text2 = text.replace("foo", "bar"); // "bar foo foo" (apenas a primeira)
```

---

#### replace_all

Substitui todas as ocorrencias de uma substring.

**Assinatura:**
```hemlock
string.replace_all(old: string, new: string): string
```

**Parametros:**
- `old` - A substring a ser substituida
- `new` - A string de substituicao

**Retorna:** Nova string com todas as ocorrencias substituidas

**Exemplo:**
```hemlock
let text = "foo foo foo";
let text2 = text.replace_all("foo", "bar"); // "bar bar bar"

let s = "hello world hello";
let s2 = s.replace_all("hello", "hi");      // "hi world hi"
```

---

### Repeticao

#### repeat

Repete a string n vezes.

**Assinatura:**
```hemlock
string.repeat(count: i32): string
```

**Parametros:**
- `count` - Numero de repeticoes

**Retorna:** Nova string repetida count vezes

**Exemplo:**
```hemlock
let s = "ha";
let repeated = s.repeat(3);     // "hahaha"

let line = "-";
let separator = line.repeat(40); // "----------------------------------------"
```

---

### Acesso a Caracteres

#### char_at

Obtem o ponto de codigo Unicode em um indice especificado.

**Assinatura:**
```hemlock
string.char_at(index: i32): rune
```

**Parametros:**
- `index` - Indice do ponto de codigo (baseado em 0)

**Retorna:** Rune (ponto de codigo Unicode)

**Exemplo:**
```hemlock
let s = "hello";
let ch = s.char_at(0);          // 'h'
let ch2 = s.char_at(1);         // 'e'

// Exemplo UTF-8
let emoji = "üöÄ";
let ch3 = emoji.char_at(0);     // U+1F680 (foguete)
```

---

#### chars

Converte a string em um array de runes.

**Assinatura:**
```hemlock
string.chars(): array
```

**Retorna:** Array de runes (pontos de codigo)

**Exemplo:**
```hemlock
let s = "hello";
let chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']

// Exemplo UTF-8
let text = "HiüöÄ!";
let chars2 = text.chars();      // ['H', 'i', 'üöÄ', '!']
```

---

### Acesso a Bytes

#### byte_at

Obtem o valor do byte em um indice especificado.

**Assinatura:**
```hemlock
string.byte_at(index: i32): u8
```

**Parametros:**
- `index` - Indice do byte (baseado em 0, nao indice de ponto de codigo)

**Retorna:** Valor do byte (u8)

**Exemplo:**
```hemlock
let s = "hello";
let byte = s.byte_at(0);        // 104 (ASCII 'h')
let byte2 = s.byte_at(1);       // 101 (ASCII 'e')

// Exemplo UTF-8
let emoji = "üöÄ";
let byte3 = emoji.byte_at(0);   // 240 (primeiro byte UTF-8)
```

---

#### bytes

Converte a string em um array de bytes.

**Assinatura:**
```hemlock
string.bytes(): array
```

**Retorna:** Array de bytes u8

**Exemplo:**
```hemlock
let s = "hello";
let bytes = s.bytes();          // [104, 101, 108, 108, 111]

// Exemplo UTF-8
let emoji = "üöÄ";
let bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 bytes UTF-8)
```

---

#### to_bytes

Converte a string em um buffer.

**Assinatura:**
```hemlock
string.to_bytes(): buffer
```

**Retorna:** Buffer contendo bytes UTF-8

**Exemplo:**
```hemlock
let s = "hello";
let buf = s.to_bytes();
print(buf.length);              // 5

// Exemplo UTF-8
let emoji = "üöÄ";
let buf2 = emoji.to_bytes();
print(buf2.length);             // 4
```

**Nota:** Este e um metodo legado. Prefira `.bytes()` na maioria dos casos.

---

### Desserializacao JSON

#### deserialize

Analisa uma string JSON em um valor.

**Assinatura:**
```hemlock
string.deserialize(): any
```

**Retorna:** Valor analisado (objeto, array, numero, string, booleano ou null)

**Exemplo:**
```hemlock
let json = '{"x":10,"y":20}';
let obj = json.deserialize();
print(obj.x);                   // 10
print(obj.y);                   // 20

let arr_json = '[1,2,3]';
let arr = arr_json.deserialize();
print(arr[0]);                  // 1

let num_json = '42';
let num = num_json.deserialize();
print(num);                     // 42
```

**Tipos Suportados:**
- Objetos: `{"key": value}`
- Arrays: `[1, 2, 3]`
- Numeros: `42`, `3.14`
- Strings: `"texto"`
- Booleanos: `true`, `false`
- Nulo: `null`

**Veja Tambem:** Metodo `.serialize()` de objetos

---

## Encadeamento de Metodos

Metodos de string podem ser encadeados para operacoes concisas:

**Exemplo:**
```hemlock
let result = "  Hello World  "
    .trim()
    .to_lower()
    .replace("world", "hemlock");  // "hello hemlock"

let processed = "foo,bar,baz"
    .split(",")
    .join(" | ");                  // "foo | bar | baz"

let cleaned = "  HELLO  "
    .trim()
    .to_lower();                   // "hello"
```

---

## Resumo Completo dos Metodos

| Metodo         | Assinatura                                       | Retorna   | Descricao                         |
|----------------|--------------------------------------------------|-----------|-----------------------------------|
| `substr`       | `(start: i32, length: i32)`                      | `string`  | Extrai substring por posicao/comprimento |
| `slice`        | `(start: i32, end: i32)`                         | `string`  | Extrai substring por intervalo    |
| `find`         | `(needle: string)`                               | `i32`     | Encontra primeira ocorrencia (-1 se nao encontrada) |
| `contains`     | `(needle: string)`                               | `bool`    | Verifica se contem substring      |
| `split`        | `(delimiter: string)`                            | `array`   | Divide em array                   |
| `trim`         | `()`                                             | `string`  | Remove espacos em branco          |
| `to_upper`     | `()`                                             | `string`  | Converte para maiusculas          |
| `to_lower`     | `()`                                             | `string`  | Converte para minusculas          |
| `starts_with`  | `(prefix: string)`                               | `bool`    | Verifica se comeca com prefixo    |
| `ends_with`    | `(suffix: string)`                               | `bool`    | Verifica se termina com sufixo    |
| `replace`      | `(old: string, new: string)`                     | `string`  | Substitui primeira ocorrencia     |
| `replace_all`  | `(old: string, new: string)`                     | `string`  | Substitui todas as ocorrencias    |
| `repeat`       | `(count: i32)`                                   | `string`  | Repete a string n vezes           |
| `char_at`      | `(index: i32)`                                   | `rune`    | Obtem ponto de codigo no indice   |
| `byte_at`      | `(index: i32)`                                   | `u8`      | Obtem byte no indice              |
| `chars`        | `()`                                             | `array`   | Converte para array de runes      |
| `bytes`        | `()`                                             | `array`   | Converte para array de bytes      |
| `to_bytes`     | `()`                                             | `buffer`  | Converte para buffer (legado)     |
| `deserialize`  | `()`                                             | `any`     | Analisa string JSON               |

---

## Veja Tambem

- [Sistema de Tipos](#reference-type-system) - Detalhes do tipo string
- [API de Arrays](#reference-array-api) - Metodos de array para resultados de split()
- [Operadores](#reference-operators) - Operador de concatenacao de strings


--------------------------------------------------------------------------------
## Fun√ß√µes Integradas
--------------------------------------------------------------------------------

# Referencia de Funcoes Integradas

Documentacao completa de todas as funcoes integradas e constantes do Hemlock.

---

## Visao Geral

Hemlock fornece um conjunto de funcoes integradas para I/O, introspeccao de tipos, gerenciamento de memoria, concorrencia e interacao com o sistema. Todas as funcoes integradas estao disponiveis globalmente sem necessidade de importacao.

---

## Funcoes de I/O

### print

Imprime valores na saida padrao com nova linha.

**Assinatura:**
```hemlock
print(...values): null
```

**Parametros:**
- `...values` - Qualquer numero de valores para imprimir

**Retorna:** `null`

**Exemplo:**
```hemlock
print("Hello, World!");
print(42);
print(3.14);
print(true);
print([1, 2, 3]);
print({ x: 10, y: 20 });

// Multiplos valores
print("x =", 10, "y =", 20);
```

**Comportamento:**
- Converte todos os valores para strings
- Multiplos valores separados por espacos
- Adiciona nova linha no final
- Libera a saida padrao

---

### read_line

Le uma linha de texto da entrada padrao (entrada do usuario).

**Assinatura:**
```hemlock
read_line(): string | null
```

**Parametros:** Nenhum

**Retorna:**
- `string` - A linha lida da entrada padrao (sem nova linha)
- `null` - Em EOF (fim de arquivo/entrada)

**Exemplo:**
```hemlock
// Prompt simples
print("Qual e o seu nome?");
let name = read_line();
print("Ola, " + name + "!");

// Lendo numero (requer parsing manual)
print("Digite um numero:");
let input = read_line();
let num = parse_int(input);  // Veja parse_int abaixo
print("Dobro:", num * 2);

// Tratando EOF
let line = read_line();
if (line == null) {
    print("Fim da entrada");
}

// Lendo multiplas linhas
print("Digite linhas (Ctrl+D para parar):");
while (true) {
    let line = read_line();
    if (line == null) {
        break;
    }
    print("Voce disse:", line);
}
```

**Comportamento:**
- Bloqueia ate o usuario pressionar Enter
- Remove nova linha final (`\n`) e retorno de carro (`\r`)
- Retorna `null` em EOF (Ctrl+D no Unix, Ctrl+Z no Windows)
- Le apenas da entrada padrao (nao de arquivo)

**Parseando Entrada do Usuario:**

Como `read_line()` sempre retorna string, voce precisa parsear entrada numerica manualmente:

```hemlock
// Parser de inteiro simples
fn parse_int(s: string): i32 {
    let result: i32 = 0;
    let negative = false;
    let i = 0;

    if (s.length > 0 && s.char_at(0) == '-') {
        negative = true;
        i = 1;
    }

    while (i < s.length) {
        let c = s.char_at(i);
        let code: i32 = c;
        if (code >= 48 && code <= 57) {
            result = result * 10 + (code - 48);
        } else {
            break;
        }
        i = i + 1;
    }

    if (negative) {
        return -result;
    }
    return result;
}

// Uso
print("Digite sua idade:");
let age = parse_int(read_line());
print("Em 10 anos voce tera", age + 10);
```

**Veja Tambem:** [API de Arquivos](#reference-file-api) para ler de arquivos

---

### eprint

Imprime valores na saida de erro padrao com nova linha.

**Assinatura:**
```hemlock
eprint(value: any): null
```

**Parametros:**
- `value` - Valor unico para imprimir na saida de erro padrao

**Retorna:** `null`

**Exemplo:**
```hemlock
eprint("Erro: arquivo nao encontrado");
eprint(404);
eprint("Aviso: " + message);

// Padrao tipico de tratamento de erros
fn load_config(path: string) {
    if (!exists(path)) {
        eprint("Erro: arquivo de configuracao nao encontrado: " + path);
        return null;
    }
    // ...
}
```

**Comportamento:**
- Imprime na saida de erro padrao (stderr)
- Adiciona nova linha no final
- Aceita apenas um argumento (diferente de `print`)
- Util para mensagens de erro que nao devem misturar com saida normal

**Diferenca de print:**
- `print()` -> stdout (saida normal, redirecionada com `>`)
- `eprint()` -> stderr (saida de erro, redirecionada com `2>`)

```bash
# Exemplo no shell: separando stdout e stderr
./hemlock script.hml > output.txt 2> errors.txt
```

---

## Introspeccao de Tipos

### typeof

Obtem o nome do tipo de um valor.

**Assinatura:**
```hemlock
typeof(value: any): string
```

**Parametros:**
- `value` - Qualquer valor

**Retorna:** String com o nome do tipo

**Exemplo:**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("hello"));         // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof(null));            // "null"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"

// Objetos tipados
define Person { name: string }
let p: Person = { name: "Alice" };
print(typeof(p));               // "Person"

// Outros tipos
print(typeof(alloc(10)));       // "ptr"
print(typeof(buffer(10)));      // "buffer"
print(typeof(open("file.txt"))); // "file"
```

**Nomes de Tipos:**
- Tipos primitivos: `"i8"`, `"i16"`, `"i32"`, `"i64"`, `"u8"`, `"u16"`, `"u32"`, `"u64"`, `"f32"`, `"f64"`, `"bool"`, `"string"`, `"rune"`, `"null"`
- Tipos compostos: `"array"`, `"object"`, `"ptr"`, `"buffer"`, `"function"`
- Tipos especiais: `"file"`, `"task"`, `"channel"`
- Tipos personalizados: Nomes de tipo definidos pelo usuario de `define`

**Veja Tambem:** [Sistema de Tipos](#reference-type-system)

---

## Execucao de Comandos

### exec

Executa um comando shell e captura a saida.

**Assinatura:**
```hemlock
exec(command: string): object
```

**Parametros:**
- `command` - O comando shell a executar

**Retorna:** Objeto contendo:
- `output` (string) - Saida padrao do comando
- `exit_code` (i32) - Codigo de saida (0 = sucesso)

**Exemplo:**
```hemlock
let result = exec("echo hello");
print(result.output);      // "hello\n"
print(result.exit_code);   // 0

// Verifica status de saida
let r = exec("grep pattern file.txt");
if (r.exit_code == 0) {
    print("Encontrado:", r.output);
} else {
    print("Padrao nao encontrado");
}

// Tratando saida multi-linha
let r2 = exec("ls -la");
let lines = r2.output.split("\n");
```

**Comportamento:**
- Executa comando via `/bin/sh`
- Captura apenas stdout (stderr vai para o terminal)
- Bloqueia ate o comando completar
- Retorna string vazia se nao houver saida

**Tratamento de Erros:**
```hemlock
try {
    let r = exec("comando_inexistente");
} catch (e) {
    print("Falha ao executar:", e);
}
```

**Aviso de Seguranca:** Risco de injecao de shell. Sempre valide/sanitize entrada do usuario.

**Limitacoes:**
- Sem captura de stderr
- Sem streaming
- Sem timeout
- Sem tratamento de sinais

---

### exec_argv

Executa um comando com array explicito de argumentos (sem interpretacao de shell).

**Assinatura:**
```hemlock
exec_argv(argv: array): object
```

**Parametros:**
- `argv` - Array de strings: `[comando, arg1, arg2, ...]`

**Retorna:** Objeto contendo:
- `output` (string) - Saida padrao do comando
- `exit_code` (i32) - Codigo de saida (0 = sucesso)

**Exemplo:**
```hemlock
// Comando simples
let result = exec_argv(["ls", "-la"]);
print(result.output);

// Argumentos com espacos (seguro!)
let r = exec_argv(["grep", "hello world", "file.txt"]);

// Executar script com argumentos
let r2 = exec_argv(["python", "script.py", "--input", "data.json"]);
print(r2.exit_code);
```

**Diferenca de exec:**
```hemlock
// exec() usa shell - inseguro para entrada do usuario
exec("ls " + user_input);  // Risco de injecao de shell!

// exec_argv() ignora shell - seguro
exec_argv(["ls", user_input]);  // Injecao impossivel
```

**Quando usar:**
- Quando argumentos contem espacos, aspas ou caracteres especiais
- Ao tratar entrada do usuario (seguranca)
- Quando voce precisa de parsing previsivel de argumentos

**Veja Tambem:** `exec()` para comandos de shell simples

---

## Tratamento de Erros

### throw

Lanca uma excecao.

**Assinatura:**
```hemlock
throw expression
```

**Parametros:**
- `expression` - Valor a ser lancado (qualquer tipo)

**Retorna:** Nunca retorna (transfere controle)

**Exemplo:**
```hemlock
throw "mensagem de erro";
throw 404;
throw { code: 500, message: "Erro interno" };
throw null;
```

**Veja Tambem:** Instrucao try/catch/finally

---

### panic

Encerra o programa imediatamente com mensagem de erro (irrecuperavel).

**Assinatura:**
```hemlock
panic(message?: any): never
```

**Parametros:**
- `message` (opcional) - Mensagem de erro a imprimir

**Retorna:** Nunca retorna (programa termina)

**Exemplo:**
```hemlock
panic();                          // Padrao: "panic!"
panic("codigo inalcancavel atingido");
panic(42);

// Caso de uso comum
fn process_state(state: i32): string {
    if (state == 1) { return "pronto"; }
    if (state == 2) { return "executando"; }
    panic("estado invalido: " + typeof(state));
}
```

**Comportamento:**
- Imprime erro na saida de erro padrao: `panic: <mensagem>`
- Termina com codigo 1
- **Nao pode** ser capturado com try/catch
- Use para bugs e erros irrecuperaveis

**panic vs throw:**
- `panic()` - Erro irrecuperavel, termina imediatamente
- `throw` - Erro recuperavel, pode ser capturado

---

### assert

Asserta que uma condicao e verdadeira, caso contrario termina com mensagem de erro.

**Assinatura:**
```hemlock
assert(condition: any, message?: string): null
```

**Parametros:**
- `condition` - Valor a verificar como verdadeiro
- `message` (opcional) - Mensagem de erro personalizada se assert falhar

**Retorna:** `null` (se assert passar)

**Exemplo:**
```hemlock
// Assert basico
assert(x > 0);
assert(name != null);
assert(arr.length > 0, "Array nao pode estar vazio");

// Com mensagem personalizada
fn divide(a: i32, b: i32): f64 {
    assert(b != 0, "Divisao por zero");
    return a / b;
}

// Validando argumentos de funcao
fn process_data(data: array) {
    assert(data != null, "data nao pode ser null");
    assert(data.length > 0, "data nao pode estar vazio");
    // ...
}
```

**Comportamento:**
- Se condicao for verdadeira: retorna `null`, continua execucao
- Se condicao for falsa: imprime erro e termina com codigo 1
- Valores falsos: `false`, `0`, `0.0`, `null`, `""` (string vazia)
- Valores verdadeiros: todo o resto

**Saida em Falha:**
```
Assertion failed: Array nao pode estar vazio
```

**Quando usar:**
- Validando pre-condicoes de funcoes
- Verificando invariantes durante desenvolvimento
- Capturando erros de programador cedo

**assert vs panic:**
- `assert(cond, msg)` - Verifica condicao, falha se falso
- `panic(msg)` - Falha incondicionalmente

---

## Tratamento de Sinais

### signal

Registra ou reseta um handler de sinal.

**Assinatura:**
```hemlock
signal(signum: i32, handler: function | null): function | null
```

**Parametros:**
- `signum` - Numero do sinal (use constantes como `SIGINT`)
- `handler` - Funcao a chamar quando sinal for recebido, ou `null` para resetar ao padrao

**Retorna:** Funcao handler anterior, ou `null`

**Exemplo:**
```hemlock
fn handle_interrupt(sig) {
    print("Capturado SIGINT!");
}

signal(SIGINT, handle_interrupt);

// Reseta ao padrao
signal(SIGINT, null);
```

**Assinatura do Handler:**
```hemlock
fn handler(signum: i32) {
    // signum contem o numero do sinal
}
```

**Veja Tambem:**
- [Constantes de Sinal](#constantes-de-sinal)
- `raise()`

---

### raise

Envia um sinal para o processo atual.

**Assinatura:**
```hemlock
raise(signum: i32): null
```

**Parametros:**
- `signum` - Numero do sinal a enviar

**Retorna:** `null`

**Exemplo:**
```hemlock
let count = 0;

fn increment(sig) {
    count = count + 1;
}

signal(SIGUSR1, increment);

raise(SIGUSR1);
raise(SIGUSR1);
print(count);  // 2
```

---

## Variaveis Globais

### args

Array de argumentos de linha de comando.

**Tipo:** `array` de strings

**Estrutura:**
- `args[0]` - Nome do arquivo do script
- `args[1..n]` - Argumentos de linha de comando

**Exemplo:**
```bash
# Comando: ./hemlock script.hml hello world
```

```hemlock
print(args[0]);        // "script.hml"
print(args.length);    // 3
print(args[1]);        // "hello"
print(args[2]);        // "world"

// Itera sobre argumentos
let i = 1;
while (i < args.length) {
    print("Argumento", i, ":", args[i]);
    i = i + 1;
}
```

**Comportamento no REPL:** No REPL, `args.length` e 0 (array vazio)

---

## Constantes de Sinal

Constantes de sinal POSIX padrao (valores i32):

### Interrupcao e Terminacao

| Constante  | Valor | Descricao                              |
|------------|-------|----------------------------------------|
| `SIGINT`   | 2     | Interrupcao do teclado (Ctrl+C)        |
| `SIGTERM`  | 15    | Requisicao de terminacao               |
| `SIGQUIT`  | 3     | Quit do teclado (Ctrl+\)               |
| `SIGHUP`   | 1     | Hangup detectado no terminal de controle |
| `SIGABRT`  | 6     | Sinal de abort                         |

### Definidos pelo Usuario

| Constante  | Valor | Descricao                   |
|------------|-------|-----------------------------|
| `SIGUSR1`  | 10    | Sinal definido pelo usuario 1 |
| `SIGUSR2`  | 12    | Sinal definido pelo usuario 2 |

### Controle de Processo

| Constante  | Valor | Descricao                        |
|------------|-------|----------------------------------|
| `SIGALRM`  | 14    | Timer de alarme                  |
| `SIGCHLD`  | 17    | Mudanca de status do filho       |
| `SIGCONT`  | 18    | Continua se parado               |
| `SIGSTOP`  | 19    | Para processo (nao pode ser capturado) |
| `SIGTSTP`  | 20    | Stop do terminal (Ctrl+Z)        |

### I/O

| Constante  | Valor | Descricao                       |
|------------|-------|---------------------------------|
| `SIGPIPE`  | 13    | Pipe quebrado                   |
| `SIGTTIN`  | 21    | Leitura de terminal em segundo plano |
| `SIGTTOU`  | 22    | Escrita em terminal em segundo plano |

**Exemplo:**
```hemlock
fn handle_signal(sig) {
    if (sig == SIGINT) {
        print("Interrupcao detectada");
    }
    if (sig == SIGTERM) {
        print("Terminacao solicitada");
    }
}

signal(SIGINT, handle_signal);
signal(SIGTERM, handle_signal);
```

**Nota:** `SIGKILL` (9) e `SIGSTOP` (19) nao podem ser capturados ou ignorados.

---

## Funcoes Matematicas/Aritmeticas

### div

Retorna divisao inteira (floor) como ponto flutuante.

**Assinatura:**
```hemlock
div(a: number, b: number): f64
```

**Parametros:**
- `a` - Dividendo
- `b` - Divisor

**Retorna:** Floor de `a / b`, como ponto flutuante (f64)

**Exemplo:**
```hemlock
let result = div(7, 2);    // 3.0 (nao 3.5)
let result2 = div(10, 3);  // 3.0
let result3 = div(-7, 2);  // -4.0 (floor em direcao a -infinito)
```

**Nota:** Em Hemlock, o operador `/` sempre retorna ponto flutuante. Use `div()` quando precisar da parte inteira como float, ou `divi()` quando precisar de resultado inteiro.

---

### divi

Retorna divisao inteira (floor) como inteiro.

**Assinatura:**
```hemlock
divi(a: number, b: number): i64
```

**Parametros:**
- `a` - Dividendo
- `b` - Divisor

**Retorna:** Floor de `a / b`, como inteiro (i64)

**Exemplo:**
```hemlock
let result = divi(7, 2);    // 3
let result2 = divi(10, 3);  // 3
let result3 = divi(-7, 2);  // -4 (floor em direcao a -infinito)
```

**Comparacao:**
```hemlock
print(7 / 2);      // 3.5 (divisao regular, sempre float)
print(div(7, 2));  // 3.0 (divisao floor, resultado float)
print(divi(7, 2)); // 3   (divisao floor, resultado inteiro)
```

---

## Funcoes de Gerenciamento de Memoria

Veja [API de Memoria](#reference-memory-api) para referencia completa:
- `alloc(size)` - Aloca memoria bruta
- `free(ptr)` - Libera memoria
- `buffer(size)` - Aloca buffer seguro
- `memset(ptr, byte, size)` - Preenche memoria
- `memcpy(dest, src, size)` - Copia memoria
- `realloc(ptr, new_size)` - Redimensiona alocacao

### sizeof

Obtem o tamanho em bytes de um tipo.

**Assinatura:**
```hemlock
sizeof(type): i32
```

**Parametros:**
- `type` - Constante de tipo (`i32`, `f64`, `ptr`, etc.) ou nome de tipo como string

**Retorna:** Tamanho em bytes, como `i32`

**Exemplo:**
```hemlock
print(sizeof(i8));       // 1
print(sizeof(i16));      // 2
print(sizeof(i32));      // 4
print(sizeof(i64));      // 8
print(sizeof(f32));      // 4
print(sizeof(f64));      // 8
print(sizeof(ptr));      // 8
print(sizeof(rune));     // 4

// Usando alias de tipo
print(sizeof(byte));     // 1 (mesmo que u8)
print(sizeof(integer));  // 4 (mesmo que i32)
print(sizeof(number));   // 8 (mesmo que f64)

// Forma de string tambem funciona
print(sizeof("i32"));    // 4
```

**Tipos Suportados:**
| Tipo | Tamanho | Alias |
|------|---------|-------|
| `i8` | 1 | - |
| `i16` | 2 | - |
| `i32` | 4 | `integer` |
| `i64` | 8 | - |
| `u8` | 1 | `byte` |
| `u16` | 2 | - |
| `u32` | 4 | - |
| `u64` | 8 | - |
| `f32` | 4 | - |
| `f64` | 8 | `number` |
| `ptr` | 8 | - |
| `rune` | 4 | - |
| `bool` | 1 | - |

**Veja Tambem:** `talloc()` para alocacao tipada

---

### talloc

Aloca memoria para array tipado (alocacao type-aware).

**Assinatura:**
```hemlock
talloc(type, count: i32): ptr
```

**Parametros:**
- `type` - Constante de tipo (`i32`, `f64`, `ptr`, etc.)
- `count` - Numero de elementos a alocar

**Retorna:** `ptr` para memoria alocada, ou `null` em falha

**Exemplo:**
```hemlock
// Aloca array de 10 i32 (40 bytes)
let int_arr = talloc(i32, 10);
ptr_write_i32(int_arr, 42);
ptr_write_i32(ptr_offset(int_arr, 1, 4), 100);

// Aloca array de 5 f64 (40 bytes)
let float_arr = talloc(f64, 5);

// Aloca array de 100 bytes
let byte_arr = talloc(u8, 100);

// Nao esqueca de liberar!
free(int_arr);
free(float_arr);
free(byte_arr);
```

**Comparacao com alloc:**
```hemlock
// Estes sao equivalentes:
let p1 = talloc(i32, 10);      // Type-aware: 10 i32
let p2 = alloc(sizeof(i32) * 10);  // Calculo manual

// talloc e mais claro e menos propenso a erros
```

**Tratamento de Erros:**
- Retorna `null` em falha de alocacao
- Termina com erro se count nao for positivo
- Verifica overflow de tamanho (count * element_size)

**Veja Tambem:** `alloc()`, `sizeof()`, `free()`

---

## Helpers de Ponteiro FFI

Estas funcoes ajudam a ler e escrever valores tipados em memoria bruta, uteis para FFI e operacoes de memoria de baixo nivel.

### ptr_null

Cria um ponteiro nulo.

**Assinatura:**
```hemlock
ptr_null(): ptr
```

**Retorna:** Ponteiro nulo

**Exemplo:**
```hemlock
let p = ptr_null();
if (p == null) {
    print("Ponteiro e nulo");
}
```

---

### ptr_offset

Calcula deslocamento de ponteiro (aritmetica de ponteiros).

**Assinatura:**
```hemlock
ptr_offset(ptr: ptr, index: i32, element_size: i32): ptr
```

**Parametros:**
- `ptr` - Ponteiro base
- `index` - Indice do elemento
- `element_size` - Tamanho de cada elemento em bytes

**Retorna:** Ponteiro para elemento no indice dado

**Exemplo:**
```hemlock
let arr = talloc(i32, 10);
ptr_write_i32(arr, 100);                      // arr[0] = 100
ptr_write_i32(ptr_offset(arr, 1, 4), 200);    // arr[1] = 200
ptr_write_i32(ptr_offset(arr, 2, 4), 300);    // arr[2] = 300

print(ptr_read_i32(ptr_offset(arr, 1, 4)));   // 200
free(arr);
```

---

### Funcoes de Leitura de Ponteiro

Le valores tipados da memoria.

| Funcao | Assinatura | Retorna | Descricao |
|--------|------------|---------|-----------|
| `ptr_read_i8` | `(ptr)` | `i8` | Le inteiro 8-bit com sinal |
| `ptr_read_i16` | `(ptr)` | `i16` | Le inteiro 16-bit com sinal |
| `ptr_read_i32` | `(ptr)` | `i32` | Le inteiro 32-bit com sinal |
| `ptr_read_i64` | `(ptr)` | `i64` | Le inteiro 64-bit com sinal |
| `ptr_read_u8` | `(ptr)` | `u8` | Le inteiro 8-bit sem sinal |
| `ptr_read_u16` | `(ptr)` | `u16` | Le inteiro 16-bit sem sinal |
| `ptr_read_u32` | `(ptr)` | `u32` | Le inteiro 32-bit sem sinal |
| `ptr_read_u64` | `(ptr)` | `u64` | Le inteiro 64-bit sem sinal |
| `ptr_read_f32` | `(ptr)` | `f32` | Le float 32-bit |
| `ptr_read_f64` | `(ptr)` | `f64` | Le float 64-bit |
| `ptr_read_ptr` | `(ptr)` | `ptr` | Le valor de ponteiro |

**Exemplo:**
```hemlock
let p = alloc(8);
ptr_write_f64(p, 3.14159);
let value = ptr_read_f64(p);
print(value);  // 3.14159
free(p);
```

---

### Funcoes de Escrita de Ponteiro

Escreve valores tipados na memoria.

| Funcao | Assinatura | Retorna | Descricao |
|--------|------------|---------|-----------|
| `ptr_write_i8` | `(ptr, value)` | `null` | Escreve inteiro 8-bit com sinal |
| `ptr_write_i16` | `(ptr, value)` | `null` | Escreve inteiro 16-bit com sinal |
| `ptr_write_i32` | `(ptr, value)` | `null` | Escreve inteiro 32-bit com sinal |
| `ptr_write_i64` | `(ptr, value)` | `null` | Escreve inteiro 64-bit com sinal |
| `ptr_write_u8` | `(ptr, value)` | `null` | Escreve inteiro 8-bit sem sinal |
| `ptr_write_u16` | `(ptr, value)` | `null` | Escreve inteiro 16-bit sem sinal |
| `ptr_write_u32` | `(ptr, value)` | `null` | Escreve inteiro 32-bit sem sinal |
| `ptr_write_u64` | `(ptr, value)` | `null` | Escreve inteiro 64-bit sem sinal |
| `ptr_write_f32` | `(ptr, value)` | `null` | Escreve float 32-bit |
| `ptr_write_f64` | `(ptr, value)` | `null` | Escreve float 64-bit |
| `ptr_write_ptr` | `(ptr, value)` | `null` | Escreve valor de ponteiro |

**Exemplo:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);
print(ptr_read_i32(p));  // 42
free(p);
```

---

### Conversao Buffer/Ponteiro

#### buffer_ptr

Obtem ponteiro bruto de um buffer.

**Assinatura:**
```hemlock
buffer_ptr(buf: buffer): ptr
```

**Exemplo:**
```hemlock
let buf = buffer(64);
let p = buffer_ptr(buf);
// Agora p aponta para a mesma memoria que buf
```

#### ptr_to_buffer

Cria wrapper de buffer em torno de ponteiro bruto.

**Assinatura:**
```hemlock
ptr_to_buffer(ptr: ptr, size: i32): buffer
```

**Exemplo:**
```hemlock
let p = alloc(64);
let buf = ptr_to_buffer(p, 64);
buf[0] = 65;  // Agora tem verificacao de limites
// Nota: liberar buf liberara a memoria subjacente
```

---

## Funcoes de I/O de Arquivo

Veja [API de Arquivos](#reference-file-api) para referencia completa:
- `open(path, mode?)` - Abre arquivo

---

## Funcoes de Concorrencia

Veja [API de Concorrencia](#reference-concurrency-api) para referencia completa:
- `spawn(fn, args...)` - Cria tarefa
- `join(task)` - Aguarda tarefa
- `detach(task)` - Desanexa tarefa
- `channel(capacity)` - Cria canal

### apply

Chama uma funcao dinamicamente com array de argumentos.

**Assinatura:**
```hemlock
apply(fn: function, args: array): any
```

**Parametros:**
- `fn` - A funcao a chamar
- `args` - Array de argumentos a passar para a funcao

**Retorna:** Valor de retorno da funcao chamada

**Exemplo:**
```hemlock
fn add(a, b) {
    return a + b;
}

// Chama com array de argumentos
let result = apply(add, [2, 3]);
print(result);  // 5

// Despacho dinamico
let operations = {
    add: fn(a, b) { return a + b; },
    mul: fn(a, b) { return a * b; },
    sub: fn(a, b) { return a - b; }
};

fn calculate(op: string, args: array) {
    return apply(operations[op], args);
}

print(calculate("add", [10, 5]));  // 15
print(calculate("mul", [10, 5]));  // 50
print(calculate("sub", [10, 5]));  // 5

// Argumentos variaveis
fn sum(...nums) {
    let total = 0;
    for (n in nums) {
        total = total + n;
    }
    return total;
}

let numbers = [1, 2, 3, 4, 5];
print(apply(sum, numbers));  // 15
```

**Casos de Uso:**
- Despacho dinamico de funcoes baseado em valores de runtime
- Chamando funcoes com listas de argumentos variaveis
- Implementando utilitarios de ordem superior (map, filter, etc.)
- Sistemas de plugins/extensoes

---

### select

Aguarda dados em multiplos canais, retorna quando qualquer canal tem dados.

**Assinatura:**
```hemlock
select(channels: array, timeout_ms?: i32): object | null
```

**Parametros:**
- `channels` - Array de valores de canal
- `timeout_ms` (opcional) - Timeout em milissegundos (-1 ou omitido para esperar infinitamente)

**Retorna:**
- `{ channel, value }` - Objeto contendo o canal que tinha dados e o valor recebido
- `null` - Em timeout

**Exemplo:**
```hemlock
let ch1 = channel(1);
let ch2 = channel(1);

// Tarefas produtoras
spawn(fn() {
    sleep(100);
    ch1.send("do canal 1");
});

spawn(fn() {
    sleep(50);
    ch2.send("do canal 2");
});

// Aguarda primeira mensagem
let result = select([ch1, ch2]);
print(result.value);  // "do canal 2" (chegou primeiro)

// Com timeout
let result2 = select([ch1, ch2], 1000);  // Aguarda no maximo 1 segundo
if (result2 == null) {
    print("Timeout - nenhum dado recebido");
} else {
    print("Recebido:", result2.value);
}

// Loop de select continuo
while (true) {
    let msg = select([ch1, ch2], 5000);
    if (msg == null) {
        print("Sem atividade por 5 segundos");
        break;
    }
    print("Recebeu mensagem:", msg.value);
}
```

**Comportamento:**
- Bloqueia ate um canal ter dados ou timeout expirar
- Retorna imediatamente se canal ja tiver dados
- Se canal estiver fechado e vazio, retorna `{ channel, value: null }`
- Faz polling de canais em ordem (primeiro pronto vence)

**Casos de Uso:**
- Multiplexando multiplos produtores
- Implementando timeouts em operacoes de canal
- Construindo loops de eventos com multiplas fontes

---

## Tabela de Resumo

### Funcoes

| Funcao     | Categoria        | Retorna      | Descricao                         |
|------------|------------------|--------------|-----------------------------------|
| `print`    | I/O              | `null`       | Imprime na saida padrao           |
| `read_line`| I/O              | `string?`    | Le linha da entrada padrao        |
| `eprint`   | I/O              | `null`       | Imprime na saida de erro padrao   |
| `typeof`   | Tipo             | `string`     | Obtem nome do tipo                |
| `exec`     | Comando          | `object`     | Executa comando shell             |
| `exec_argv`| Comando          | `object`     | Executa com array de argumentos   |
| `assert`   | Erro             | `null`       | Asserta condicao ou termina       |
| `panic`    | Erro             | `never`      | Erro irrecuperavel (termina)      |
| `signal`   | Sinal            | `function?`  | Registra handler de sinal         |
| `raise`    | Sinal            | `null`       | Envia sinal para processo         |
| `alloc`    | Memoria          | `ptr`        | Aloca memoria bruta               |
| `talloc`   | Memoria          | `ptr`        | Alocacao tipada                   |
| `sizeof`   | Memoria          | `i32`        | Obtem tamanho do tipo             |
| `free`     | Memoria          | `null`       | Libera memoria                    |
| `buffer`   | Memoria          | `buffer`     | Aloca buffer seguro               |
| `memset`   | Memoria          | `null`       | Preenche memoria                  |
| `memcpy`   | Memoria          | `null`       | Copia memoria                     |
| `realloc`  | Memoria          | `ptr`        | Redimensiona alocacao             |
| `open`     | I/O de Arquivo   | `file`       | Abre arquivo                      |
| `spawn`    | Concorrencia     | `task`       | Cria tarefa concorrente           |
| `join`     | Concorrencia     | `any`        | Aguarda resultado da tarefa       |
| `detach`   | Concorrencia     | `null`       | Desanexa tarefa                   |
| `channel`  | Concorrencia     | `channel`    | Cria canal de comunicacao         |
| `select`   | Concorrencia     | `object?`    | Aguarda multiplos canais          |
| `apply`    | Funcao           | `any`        | Chama funcao com array de args    |

### Variaveis Globais

| Variavel   | Tipo     | Descricao                         |
|------------|----------|-----------------------------------|
| `args`     | `array`  | Argumentos de linha de comando    |

### Constantes

| Constante  | Tipo  | Categoria | Valor | Descricao                |
|------------|-------|-----------|-------|--------------------------|
| `SIGINT`   | `i32` | Sinal     | 2     | Interrupcao do teclado   |
| `SIGTERM`  | `i32` | Sinal     | 15    | Requisicao de terminacao |
| `SIGQUIT`  | `i32` | Sinal     | 3     | Quit do teclado          |
| `SIGHUP`   | `i32` | Sinal     | 1     | Hangup                   |
| `SIGABRT`  | `i32` | Sinal     | 6     | Abort                    |
| `SIGUSR1`  | `i32` | Sinal     | 10    | Definido pelo usuario 1  |
| `SIGUSR2`  | `i32` | Sinal     | 12    | Definido pelo usuario 2  |
| `SIGALRM`  | `i32` | Sinal     | 14    | Timer de alarme          |
| `SIGCHLD`  | `i32` | Sinal     | 17    | Mudanca de status do filho |
| `SIGCONT`  | `i32` | Sinal     | 18    | Continua                 |
| `SIGSTOP`  | `i32` | Sinal     | 19    | Para (nao pode capturar) |
| `SIGTSTP`  | `i32` | Sinal     | 20    | Stop do terminal         |
| `SIGPIPE`  | `i32` | Sinal     | 13    | Pipe quebrado            |
| `SIGTTIN`  | `i32` | Sinal     | 21    | Leitura de terminal bg   |
| `SIGTTOU`  | `i32` | Sinal     | 22    | Escrita em terminal bg   |

---

## Veja Tambem

- [Sistema de Tipos](#reference-type-system) - Tipos e conversoes
- [API de Memoria](#reference-memory-api) - Funcoes de alocacao de memoria
- [API de Arquivos](#reference-file-api) - Funcoes de I/O de arquivo
- [API de Concorrencia](#reference-concurrency-api) - Funcoes async/concorrencia
- [API de Strings](#reference-string-api) - Metodos de string
- [API de Arrays](#reference-array-api) - Metodos de array


--------------------------------------------------------------------------------
## Operadores
--------------------------------------------------------------------------------

# Referencia de Operadores

Referencia completa de todos os operadores em Hemlock, incluindo precedencia, associatividade e comportamento.

---

## Visao Geral

Hemlock fornece operadores estilo C com regras de precedencia claras. Todos os operadores seguem regras de tipo estritas com promocao automatica de tipo quando aplicavel.

---

## Operadores Aritmeticos

### Aritmetica Binaria

| Operador | Nome       | Exemplo    | Descricao         |
|----------|------------|------------|-------------------|
| `+`      | Adicao     | `a + b`    | Soma dois valores |
| `-`      | Subtracao  | `a - b`    | Subtrai b de a    |
| `*`      | Multiplicacao | `a * b` | Multiplica dois valores |
| `/`      | Divisao    | `a / b`    | Divide a por b    |

**Promocao de Tipo:**
O resultado segue as regras de promocao de tipo (veja [Sistema de Tipos](type-system.md#type-promotion-rules)).

**Exemplo:**
```hemlock
let a = 10 + 5;        // 15 (i32)
let b = 10 - 3;        // 7 (i32)
let c = 4 * 5;         // 20 (i32)
let d = 20 / 4;        // 5 (i32)

// Divisao float
let e = 10.0 / 3.0;    // 3.333... (f64)

// Tipos mistos
let f: u8 = 10;
let g: i32 = 20;
let h = f + g;         // 30 (i32, promovido)
```

**Divisao por Zero:**
- Inteiro dividido por zero: erro de runtime
- Float dividido por zero: retorna `inf` ou `-inf`

---

### Aritmetica Unaria

| Operador | Nome     | Exemplo | Descricao       |
|----------|----------|---------|-----------------|
| `-`      | Negacao  | `-a`    | Nega valor      |
| `+`      | Positivo | `+a`    | Identidade (noop) |

**Exemplo:**
```hemlock
let a = 5;
let b = -a;            // -5
let c = +a;            // 5 (sem mudanca)

let x = -3.14;         // -3.14
```

---

## Operadores de Comparacao

| Operador | Nome            | Exemplo    | Retorna  |
|----------|-----------------|------------|----------|
| `==`     | Igual           | `a == b`   | `bool`   |
| `!=`     | Diferente       | `a != b`   | `bool`   |
| `<`      | Menor que       | `a < b`    | `bool`   |
| `>`      | Maior que       | `a > b`    | `bool`   |
| `<=`     | Menor ou igual  | `a <= b`   | `bool`   |
| `>=`     | Maior ou igual  | `a >= b`   | `bool`   |

**Promocao de Tipo:**
Operandos sao promovidos antes da comparacao.

**Exemplo:**
```hemlock
print(5 == 5);         // true
print(10 != 5);        // true
print(3 < 7);          // true
print(10 > 5);         // true
print(5 <= 5);         // true
print(10 >= 5);        // true

// Comparacao de string
print("hello" == "hello");  // true
print("abc" < "def");       // true (lexicografica)

// Tipos mistos
let a: u8 = 10;
let b: i32 = 10;
print(a == b);         // true (promovido para i32)
```

---

## Operadores Logicos

| Operador | Nome      | Exemplo      | Descricao                  |
|----------|-----------|--------------|----------------------------|
| `&&`     | E logico  | `a && b`     | True se ambos forem true   |
| `||`     | Ou logico | `a || b`     | True se qualquer for true  |
| `!`      | Nao logico| `!a`         | Inverte booleano           |

**Avaliacao Curto-Circuito:**
- `&&` - Para no primeiro valor falso
- `||` - Para no primeiro valor verdadeiro

**Exemplo:**
```hemlock
let a = true;
let b = false;

print(a && b);         // false
print(a || b);         // true
print(!a);             // false
print(!b);             // true

// Curto-circuito
if (x != 0 && (10 / x) > 2) {
    print("seguro");
}

if (x == 0 || (10 / x) > 2) {
    print("seguro");
}
```

---

## Operadores Bit a Bit

**Restricao:** Apenas para tipos inteiros (i8-i64, u8-u64)

### Bit a Bit Binarios

| Operador | Nome         | Exemplo    | Descricao               |
|----------|--------------|------------|-------------------------|
| `&`      | E bit a bit  | `a & b`    | E em cada bit           |
| `|`      | Ou bit a bit | `a | b`    | Ou em cada bit          |
| `^`      | Xor bit a bit| `a ^ b`    | Ou exclusivo em cada bit|
| `<<`     | Shift esquerda | `a << b` | Desloca bits a esquerda |
| `>>`     | Shift direita | `a >> b`  | Desloca bits a direita  |

**Preservacao de Tipo:**
O tipo do resultado corresponde ao tipo do operando (apos promocao).

**Exemplo:**
```hemlock
let a = 12;  // 1100 em binario
let b = 10;  // 1010 em binario

print(a & b);          // 8  (1000)
print(a | b);          // 14 (1110)
print(a ^ b);          // 6  (0110)
print(a << 2);         // 48 (110000)
print(a >> 1);         // 6  (110)
```

**Exemplo Sem Sinal:**
```hemlock
let c: u8 = 15;        // 00001111
let d: u8 = 7;         // 00000111

print(c & d);          // 7  (00000111)
print(c | d);          // 15 (00001111)
print(c ^ d);          // 8  (00001000)
```

**Comportamento de Shift Direita:**
- Tipos com sinal: shift aritmetico (extensao de sinal)
- Tipos sem sinal: shift logico (preenche com zeros)

---

### Bit a Bit Unario

| Operador | Nome             | Exemplo | Descricao          |
|----------|------------------|---------|---------------------|
| `~`      | Complemento bit a bit | `~a` | Inverte todos os bits |

**Exemplo:**
```hemlock
let a = 12;            // 00001100 (i32)
print(~a);             // -13 (complemento de dois)

let b: u8 = 15;        // 00001111
print(~b);             // 240 (11110000)
```

---

## Operadores de String

### Concatenacao

| Operador | Nome         | Exemplo    | Descricao        |
|----------|--------------|------------|------------------|
| `+`      | Concatenacao | `a + b`    | Concatena strings|

**Exemplo:**
```hemlock
let s = "hello" + " " + "world";  // "hello world"
let msg = "Contagem: " + typeof(42); // "Contagem: 42"

// String + rune
let greeting = "Hello" + '!';      // "Hello!"

// Rune + string
let prefix = '>' + " Mensagem";    // "> Mensagem"
```

---

## Operadores de Atribuicao

### Atribuicao Basica

| Operador | Nome       | Exemplo    | Descricao              |
|----------|------------|------------|------------------------|
| `=`      | Atribuicao | `a = b`    | Atribui valor a variavel |

**Exemplo:**
```hemlock
let x = 10;
x = 20;

let arr = [1, 2, 3];
arr[0] = 99;

let obj = { x: 10 };
obj.x = 20;
```

### Atribuicao Composta

#### Atribuicao Composta Aritmetica

| Operador | Nome             | Exemplo    | Equivalente        |
|----------|------------------|------------|--------------------|
| `+=`     | Adicao atribuicao | `a += b`  | `a = a + b`        |
| `-=`     | Subtracao atribuicao | `a -= b` | `a = a - b`       |
| `*=`     | Multiplicacao atribuicao | `a *= b` | `a = a * b`   |
| `/=`     | Divisao atribuicao | `a /= b` | `a = a / b`       |
| `%=`     | Modulo atribuicao | `a %= b`  | `a = a % b`        |

**Exemplo:**
```hemlock
let x = 10;
x += 5;      // x agora e 15
x -= 3;      // x agora e 12
x *= 2;      // x agora e 24
x /= 4;      // x agora e 6

let count = 0;
count += 1;  // Incrementa por 1
```

#### Atribuicao Composta Bit a Bit

| Operador | Nome              | Exemplo     | Equivalente         |
|----------|-------------------|-------------|---------------------|
| `&=`     | E atribuicao      | `a &= b`    | `a = a & b`         |
| `\|=`    | Ou atribuicao     | `a \|= b`   | `a = a \| b`        |
| `^=`     | Xor atribuicao    | `a ^= b`    | `a = a ^ b`         |
| `<<=`    | Shift esq atribuicao | `a <<= b` | `a = a << b`      |
| `>>=`    | Shift dir atribuicao | `a >>= b` | `a = a >> b`      |

**Exemplo:**
```hemlock
let flags = 0b1111;
flags &= 0b0011;   // flags agora e 0b0011 (mascara bits superiores)
flags |= 0b1000;   // flags agora e 0b1011 (define um bit)
flags ^= 0b0001;   // flags agora e 0b1010 (alterna um bit)

let x = 1;
x <<= 4;           // x agora e 16 (shift esquerda por 4)
x >>= 2;           // x agora e 4 (shift direita por 2)
```

### Incremento/Decremento

| Operador | Nome       | Exemplo | Descricao        |
|----------|------------|---------|------------------|
| `++`     | Incremento | `a++`   | Adiciona 1 (sufixo) |
| `--`     | Decremento | `a--`   | Subtrai 1 (sufixo) |

**Exemplo:**
```hemlock
let i = 0;
i++;         // i agora e 1
i++;         // i agora e 2
i--;         // i agora e 1

// Comum em loops
for (let j = 0; j < 10; j++) {
    print(j);
}
```

**Nota:** `++` e `--` sao ambos operadores sufixo (retornam valor antes de incrementar/decrementar)

---

## Operadores Null-Safe

### Coalescencia Nula (`??`)

Retorna operando esquerdo se nao for null, caso contrario retorna direito.

| Operador | Nome               | Exemplo      | Descricao                          |
|----------|--------------------|--------------|------------------------------------|
| `??`     | Coalescencia nula  | `a ?? b`     | Retorna a se nao-null, senao b    |

**Exemplo:**
```hemlock
let name = null;
let display = name ?? "Anonimo";  // "Anonimo"

let value = 42;
let result = value ?? 0;            // 42

// Encadeamento
let a = null;
let b = null;
let c = "encontrado";
let result2 = a ?? b ?? c;          // "encontrado"

// Com chamadas de funcao
fn get_config() { return null; }
let config = get_config() ?? { default: true };
```

---

### Encadeamento Opcional (`?.`)

Acessa propriedades ou chama metodos com seguranca em valores potencialmente nulos.

| Operador | Nome                | Exemplo        | Descricao                                |
|----------|---------------------|----------------|------------------------------------------|
| `?.`     | Encadeamento opcional | `a?.b`       | Retorna a.b se a nao-null, senao null   |
| `?.[`    | Indice opcional     | `a?.[0]`       | Retorna a[0] se a nao-null, senao null  |
| `?.(`    | Chamada opcional    | `a?.()`        | Chama a() se a nao-null, senao null     |

**Exemplo:**
```hemlock
let user = null;
let name = user?.name;              // null (sem erro)

let person = { name: "Alice", address: null };
let city = person?.address?.city;   // null (navegacao segura)

// Com arrays
let arr = null;
let first = arr?.[0];               // null

let items = [1, 2, 3];
let second = items?.[1];            // 2

// Com chamadas de metodo
let obj = { greet: fn() { return "Ola"; } };
let greeting = obj?.greet?.();      // "Ola"

let empty = null;
let result = empty?.method?.();     // null
```

**Comportamento:**
- Se operando esquerdo for null, toda a expressao curto-circuita para null
- Se operando esquerdo nao for null, procede com acesso normalmente
- Pode ser encadeado para acesso profundo de propriedades

---

## Operadores de Acesso a Membros

### Operador Ponto

| Operador | Nome             | Exemplo      | Descricao            |
|----------|------------------|--------------|----------------------|
| `.`      | Acesso a membro  | `obj.field`  | Acessa campo do objeto |
| `.`      | Acesso a propriedade | `arr.length` | Acessa propriedade |

**Exemplo:**
```hemlock
// Acesso a campo de objeto
let person = { name: "Alice", age: 30 };
print(person.name);        // "Alice"

// Propriedade de array
let arr = [1, 2, 3];
print(arr.length);         // 3

// Propriedade de string
let s = "hello";
print(s.length);           // 5

// Chamada de metodo
let result = s.to_upper(); // "HELLO"
```

---

### Operador de Indice

| Operador | Nome   | Exemplo   | Descricao      |
|----------|--------|-----------|----------------|
| `[]`     | Indice | `arr[i]`  | Acessa elemento |

**Exemplo:**
```hemlock
// Indexacao de array
let arr = [10, 20, 30];
print(arr[0]);             // 10
arr[1] = 99;

// Indexacao de string (retorna rune)
let s = "hello";
print(s[0]);               // 'h'
s[0] = 'H';                // "Hello"

// Indexacao de buffer
let buf = buffer(10);
buf[0] = 65;
print(buf[0]);             // 65
```

---

## Operador de Chamada de Funcao

| Operador | Nome            | Exemplo      | Descricao      |
|----------|-----------------|--------------|----------------|
| `()`     | Chamada de funcao | `f(a, b)`  | Chama funcao   |

**Exemplo:**
```hemlock
fn add(a, b) {
    return a + b;
}

let result = add(5, 3);    // 8

// Chamada de metodo
let s = "hello";
let upper = s.to_upper();  // "HELLO"

// Chamada de funcao integrada
print("mensagem");
```

---

## Precedencia de Operadores

Operadores listados da maior para a menor precedencia:

| Precedencia | Operadores                     | Descricao                            | Associatividade |
|-------------|--------------------------------|--------------------------------------|-----------------|
| 1           | `()` `[]` `.` `?.`             | Chamada, indice, membro, opcional    | Esquerda para direita |
| 2           | `++` `--`                      | Incremento/decremento sufixo         | Esquerda para direita |
| 3           | `!` `~` `-` (unario) `+` (unario) | Nao logico, complemento, negacao  | Direita para esquerda |
| 4           | `*` `/` `%`                    | Multiplicacao, divisao, modulo       | Esquerda para direita |
| 5           | `+` `-`                        | Adicao, subtracao                    | Esquerda para direita |
| 6           | `<<` `>>`                      | Shifts bit a bit                     | Esquerda para direita |
| 7           | `<` `<=` `>` `>=`              | Relacional                           | Esquerda para direita |
| 8           | `==` `!=`                      | Igualdade                            | Esquerda para direita |
| 9           | `&`                            | E bit a bit                          | Esquerda para direita |
| 10          | `^`                            | Xor bit a bit                        | Esquerda para direita |
| 11          | `|`                            | Ou bit a bit                         | Esquerda para direita |
| 12          | `&&`                           | E logico                             | Esquerda para direita |
| 13          | `||`                           | Ou logico                            | Esquerda para direita |
| 14          | `??`                           | Coalescencia nula                    | Esquerda para direita |
| 15          | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\|=` `^=` `<<=` `>>=` | Atribuicao | Direita para esquerda |

---

## Exemplos de Precedencia

### Exemplo 1: Aritmetica e Comparacao
```hemlock
let result = 5 + 3 * 2;
// Avaliado como: 5 + (3 * 2) = 11
// Multiplicacao tem maior precedencia que adicao

let cmp = 10 > 5 + 3;
// Avaliado como: 10 > (5 + 3) = true
// Adicao tem maior precedencia que comparacao
```

### Exemplo 2: Operadores Bit a Bit
```hemlock
let result1 = 12 | 10 & 8;
// Avaliado como: 12 | (10 & 8) = 12 | 8 = 12
// & tem maior precedencia que |

let result2 = 8 | 1 << 2;
// Avaliado como: 8 | (1 << 2) = 8 | 4 = 12
// Shift tem maior precedencia que ou bit a bit

// Use parenteses para clareza
let result3 = (5 & 3) | (2 << 1);
// Avaliado como: 1 | 4 = 5
```

### Exemplo 3: Operadores Logicos
```hemlock
let result = true || false && false;
// Avaliado como: true || (false && false) = true
// && tem maior precedencia que ||

let cmp = 5 < 10 && 10 < 20;
// Avaliado como: (5 < 10) && (10 < 20) = true
// Comparacao tem maior precedencia que &&
```

### Exemplo 4: Usando Parenteses
```hemlock
// Sem parenteses
let a = 2 + 3 * 4;        // 14

// Com parenteses
let b = (2 + 3) * 4;      // 20

// Expressao complexa
let c = (a + b) * (a - b);
```

---

## Comportamento de Operadores Especificos por Tipo

### Divisao (Sempre Retorna Float)

O operador `/` **sempre retorna ponto flutuante** (f64), independente dos tipos dos operandos:

```hemlock
print(10 / 3);             // 3.333... (f64)
print(5 / 2);              // 2.5 (f64)
print(10.0 / 4.0);         // 2.5 (f64)
print(-7 / 3);             // -2.333... (f64)
```

Isso previne erros comuns de truncamento inteiro inesperado.

### Divisao Floor (div / divi)

Para divisao floor (similar a divisao inteira em outras linguagens), use as funcoes `div()` e `divi()`:

```hemlock
// div(a, b) - divisao floor retornando float
print(div(5, 2));          // 2 (f64)
print(div(-7, 3));         // -3 (f64)  -- floor em direcao a -infinito

// divi(a, b) - divisao floor retornando inteiro
print(divi(5, 2));         // 2 (i64)
print(divi(-7, 3));        // -3 (i64)
print(typeof(divi(5, 2))); // i64
```

**Funcoes matematicas que retornam inteiro:**
Para outras operacoes de arredondamento que retornam inteiro:

```hemlock
print(floori(3.7));        // 3 (i64)
print(ceili(3.2));         // 4 (i64)
print(roundi(3.5));        // 4 (i64)
print(trunci(3.9));        // 3 (i64)

// Podem ser usados diretamente como indices de array
let arr = [10, 20, 30, 40];
print(arr[floori(1.9)]);   // 20 (indice 1)
```

### Comparacao de Strings

Strings sao comparadas lexicograficamente:

```hemlock
print("abc" < "def");      // true
print("apple" > "banana"); // false
print("hello" == "hello"); // true
```

### Comparacao com Null

```hemlock
let x = null;

print(x == null);          // true
print(x != null);          // false
```

### Erros de Tipo

Certas operacoes nao sao permitidas entre tipos incompativeis:

```hemlock
// ERRO: Nao pode usar operadores bit a bit em floats
let x = 3.14 & 2.71;

// ERRO: Nao pode usar operadores bit a bit em strings
let y = "hello" & "world";

// OK: Promocao de tipo para aritmetica
let a: u8 = 10;
let b: i32 = 20;
let c = a + b;             // i32 (promovido)
```

---

## Veja Tambem

- [Sistema de Tipos](#reference-type-system) - Regras de promocao e conversao de tipos
- [Funcoes Integradas](#reference-builtins) - Operacoes integradas
- [API de Strings](#reference-string-api) - Concatenacao e metodos de string


--------------------------------------------------------------------------------
## Sistema de Tipos
--------------------------------------------------------------------------------

# Referencia do Sistema de Tipos

Referencia completa do sistema de tipos do Hemlock, incluindo todos os tipos primitivos e compostos.

---

## Visao Geral

Hemlock usa um **sistema de tipos dinamico** com tags de tipo em tempo de execucao e anotacoes de tipo opcionais. Todo valor tem um tipo em tempo de execucao, e conversoes de tipo seguem regras de promocao claras.

**Caracteristicas Principais:**
- Verificacao de tipo em tempo de execucao (interpretador)
- Verificacao de tipo em tempo de compilacao (hemlockc - habilitada por padrao)
- Anotacoes de tipo opcionais
- Inferencia de tipo automatica para literais
- Regras de promocao de tipo claras
- Sem conversoes implicitas que percam precisao

---

## Verificacao de Tipo em Tempo de Compilacao (hemlockc)

O compilador Hemlock (`hemlockc`) inclui um verificador de tipo em tempo de compilacao que valida seu codigo antes de gerar o executavel. Isso detecta erros de tipo cedo sem executar o programa.

### Comportamento Padrao

Verificacao de tipo e **habilitada por padrao** no hemlockc:

```bash
# Verificacao de tipo acontece automaticamente
hemlockc program.hml -o program

# Erros sao reportados antes da compilacao
hemlockc bad_types.hml
# Saida: 1 type error found
```

### Flags do Compilador

| Flag | Descricao |
|------|-----------|
| `--check` | Apenas verifica tipos, nao compila (termina apos validacao) |
| `--no-type-check` | Desabilita verificacao de tipo (nao recomendado) |
| `--strict-types` | Habilita avisos mais rigorosos de tipo |

**Exemplo:**

```bash
# Apenas valida tipos sem compilar
hemlockc --check program.hml
# Saida: program.hml: no type errors

# Desabilita verificacao de tipo (use com cautela)
hemlockc --no-type-check dynamic_code.hml -o program

# Habilita avisos rigorosos para tipos 'any' implicitos
hemlockc --strict-types program.hml -o program
```

### O Que o Verificador de Tipo Valida

1. **Anotacoes de Tipo** - Garante que valores atribuidos correspondam aos tipos declarados
2. **Chamadas de Funcao** - Verifica que tipos de argumentos correspondam aos tipos de parametros
3. **Tipos de Retorno** - Verifica que instrucoes return correspondam ao tipo de retorno declarado
4. **Uso de Operadores** - Valida que operandos sao compativeis
5. **Acesso a Propriedades** - Verifica tipos de campo de objeto para objetos tipados

### Coercao Numerica Relaxada

O verificador de tipo permite coercoes de tipo numerico em tempo de compilacao, com validacao de faixa em tempo de execucao:

```hemlock
let x: i8 = 100;      // OK - 100 cabe em i8 (validado em tempo de execucao)
let y: u8 = 255;      // OK - dentro da faixa de u8
let z: f64 = 42;      // OK - i32 para f64 e seguro
```

### Suporte a Codigo Dinamico

Codigo sem anotacoes de tipo e tratado como dinamico (tipo `any`), e sempre passa no verificador de tipo:

```hemlock
let x = get_value();  // Dinamico - sem anotacao
process(x);           // OK - valores dinamicos aceitos em qualquer lugar
```

---

## Tipos Primitivos

### Tipos Numericos

#### Inteiros com Sinal

| Tipo   | Tamanho | Faixa                                      | Alias     |
|--------|---------|-------------------------------------------|-----------|
| `i8`   | 1 byte  | -128 a 127                                | -         |
| `i16`  | 2 bytes | -32.768 a 32.767                          | -         |
| `i32`  | 4 bytes | -2.147.483.648 a 2.147.483.647            | `integer` |
| `i64`  | 8 bytes | -9.223.372.036.854.775.808 a 9.223.372.036.854.775.807 | - |

**Exemplo:**
```hemlock
let a: i8 = 127;
let b: i16 = 32000;
let c: i32 = 1000000;
let d: i64 = 9223372036854775807;

// Alias de tipo
let x: integer = 42;  // Mesmo que i32
```

#### Inteiros sem Sinal

| Tipo   | Tamanho | Faixa                         | Alias  |
|--------|---------|-------------------------------|--------|
| `u8`   | 1 byte  | 0 a 255                       | `byte` |
| `u16`  | 2 bytes | 0 a 65.535                    | -      |
| `u32`  | 4 bytes | 0 a 4.294.967.295             | -      |
| `u64`  | 8 bytes | 0 a 18.446.744.073.709.551.615| -      |

**Exemplo:**
```hemlock
let a: u8 = 255;
let b: u16 = 65535;
let c: u32 = 4294967295;
let d: u64 = 18446744073709551615;

// Alias de tipo
let byte_val: byte = 65;  // Mesmo que u8
```

#### Ponto Flutuante

| Tipo   | Tamanho | Precisao              | Alias    |
|--------|---------|----------------------|----------|
| `f32`  | 4 bytes | ~7 digitos           | -        |
| `f64`  | 8 bytes | ~15 digitos          | `number` |

**Exemplo:**
```hemlock
let pi: f32 = 3.14159;
let precise: f64 = 3.14159265359;

// Alias de tipo
let x: number = 2.718;  // Mesmo que f64
```

---

### Inferencia de Literais Inteiros

Literais inteiros determinam seu tipo automaticamente baseado no valor:

**Regras:**
- Valores na faixa de i32 (-2.147.483.648 a 2.147.483.647): inferidos como `i32`
- Valores fora da faixa de i32 mas na faixa de i64: inferidos como `i64`
- Outros tipos (i8, i16, u8, u16, u32, u64) usam anotacoes de tipo explicitas

**Exemplo:**
```hemlock
let small = 42;                    // i32 (cabe em i32)
let large = 5000000000;            // i64 (> i32 max)
let max_i64 = 9223372036854775807; // i64 (INT64_MAX)
let explicit: u32 = 100;           // u32 (anotacao de tipo sobrescreve)
```

---

### Tipo Booleano

**Tipo:** `bool`

**Valores:** `true`, `false`

**Tamanho:** 1 byte (internamente)

**Exemplo:**
```hemlock
let is_active: bool = true;
let done = false;

if (is_active && !done) {
    print("trabalhando");
}
```

---

### Tipos de Caractere

#### Rune

**Tipo:** `rune`

**Descricao:** Ponto de codigo Unicode (U+0000 a U+10FFFF)

**Tamanho:** 4 bytes (valor de 32 bits)

**Faixa:** 0 a 0x10FFFF (1.114.111)

**Sintaxe Literal:** Aspas simples `'x'`

**Exemplo:**
```hemlock
// ASCII
let a = 'A';
let digit = '0';

// UTF-8 multi-byte
let rocket = 'üöÄ';      // U+1F680
let heart = '‚ù§';        // U+2764
let chinese = '‰∏≠';     // U+4E2D

// Sequencias de escape
let newline = '\n';
let tab = '\t';
let backslash = '\\';
let quote = '\'';
let null = '\0';

// Escapes Unicode
let emoji = '\u{1F680}';   // Ate 6 digitos hex
let max = '\u{10FFFF}';    // Ponto de codigo maximo
```

**Conversoes de Tipo:**
```hemlock
// Inteiro para rune
let code: rune = 65;        // 'A'
let r: rune = 128640;       // üöÄ

// Rune para inteiro
let value: i32 = 'Z';       // 90

// Rune para string
let s: string = 'H';        // "H"

// u8 para rune
let byte: u8 = 65;
let rune_val: rune = byte;  // 'A'
```

**Veja Tambem:** [API de Strings](#reference-string-api) para concatenacao string + rune

---

### Tipo String

**Tipo:** `string`

**Descricao:** Texto codificado em UTF-8, mutavel, alocado no heap

**Codificacao:** UTF-8 (U+0000 a U+10FFFF)

**Mutabilidade:** Mutavel (diferente da maioria das linguagens)

**Propriedades:**
- `.length` - Contagem de pontos de codigo (caracteres)
- `.byte_length` - Contagem de bytes (tamanho de codificacao UTF-8)

**Sintaxe Literal:** Aspas duplas `"texto"`

**Exemplo:**
```hemlock
let s = "hello";
s[0] = 'H';             // Muta (agora "Hello")
print(s.length);        // 5 (contagem de pontos de codigo)
print(s.byte_length);   // 5 (bytes UTF-8)

let emoji = "üöÄ";
print(emoji.length);        // 1 (um ponto de codigo)
print(emoji.byte_length);   // 4 (quatro bytes UTF-8)
```

**Indexacao:**
```hemlock
let s = "hello";
let ch = s[0];          // Retorna rune 'h'
s[0] = 'H';             // Define com rune
```

**Veja Tambem:** [API de Strings](#reference-string-api) para referencia completa de metodos

---

### Tipo Null

**Tipo:** `null`

**Descricao:** Valor nulo (representa ausencia de valor)

**Tamanho:** 8 bytes (internamente)

**Valor:** `null`

**Exemplo:**
```hemlock
let x = null;
let y: i32 = null;  // ERRO: tipo incompativel

if (x == null) {
    print("x e nulo");
}
```

---

## Tipos Compostos

### Tipo Array

**Tipo:** `array`

**Descricao:** Array dinamico, alocado no heap, de tipo misto

**Propriedades:**
- `.length` - Numero de elementos

**Baseado em Zero:** Sim

**Sintaxe Literal:** `[elem1, elem2, ...]`

**Exemplo:**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr[0]);         // 1
print(arr.length);     // 5

// Tipos mistos
let mixed = [1, "hello", true, null];
```

**Veja Tambem:** [API de Arrays](#reference-array-api) para referencia completa de metodos

---

### Tipo Objeto

**Tipo:** `object`

**Descricao:** Objeto de campos dinamicos estilo JavaScript

**Sintaxe Literal:** `{ campo: valor, ... }`

**Exemplo:**
```hemlock
let person = { name: "Alice", age: 30 };
print(person.name);  // "Alice"

// Adiciona campo dinamicamente
person.email = "alice@example.com";
```

**Definicoes de Tipo:**
```hemlock
define Person {
    name: string,
    age: i32,
    active?: bool,  // Campo opcional
}

let p: Person = { name: "Bob", age: 25 };
print(typeof(p));  // "Person"
```

---

### Tipos de Ponteiro

#### Ponteiro Bruto (ptr)

**Tipo:** `ptr`

**Descricao:** Endereco de memoria bruto (inseguro)

**Tamanho:** 8 bytes

**Verificacao de Limites:** Nenhuma

**Exemplo:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

#### Buffer

**Tipo:** `buffer`

**Descricao:** Wrapper de ponteiro seguro com verificacao de limites

**Estrutura:** Ponteiro + comprimento + capacidade

**Propriedades:**
- `.length` - Tamanho do buffer
- `.capacity` - Capacidade alocada

**Exemplo:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // Verificacao de limites
print(b.length);        // 64
free(b);
```

**Veja Tambem:** [API de Memoria](#reference-memory-api) para funcoes de alocacao

---

## Tipos Especiais

### Tipo File

**Tipo:** `file`

**Descricao:** Handle de arquivo para operacoes de I/O

**Propriedades:**
- `.path` - Caminho do arquivo (string)
- `.mode` - Modo de abertura (string)
- `.closed` - Se o arquivo esta fechado (bool)

**Veja Tambem:** [API de Arquivos](#reference-file-api)

---

### Tipo Task

**Tipo:** `task`

**Descricao:** Handle para uma tarefa concorrente

**Veja Tambem:** [API de Concorrencia](#reference-concurrency-api)

---

### Tipo Channel

**Tipo:** `channel`

**Descricao:** Canal de comunicacao thread-safe

**Veja Tambem:** [API de Concorrencia](#reference-concurrency-api)

---

### Tipo Function

**Tipo:** `function`

**Descricao:** Valor de funcao de primeira classe

**Exemplo:**
```hemlock
fn add(a, b) {
    return a + b;
}

let multiply = fn(x, y) {
    return x * y;
};

print(typeof(add));      // "function"
print(typeof(multiply)); // "function"
```

---

### Tipo Void

**Tipo:** `void`

**Descricao:** Representa nenhum valor de retorno (uso interno)

---

## Regras de Promocao de Tipo

Quando tipos sao misturados em operacoes, Hemlock promove para o tipo "maior":

**Hierarquia de Promocao:**
```
f64 (maior precisao)
 ‚Üë
f32
 ‚Üë
u64
 ‚Üë
i64
 ‚Üë
u32
 ‚Üë
i32
 ‚Üë
u16
 ‚Üë
i16
 ‚Üë
u8
 ‚Üë
i8 (menor)
```

**Regras:**
1. Floats sempre tem precedencia sobre inteiros
2. Dentro da mesma categoria (int/uint/float) tamanho maior tem precedencia
3. Ambos operandos sao promovidos para o tipo resultado
4. **Preservacao de Precisao:** i64/u64 + f32 promove para f64 (nao f32)

**Exemplo:**
```hemlock
// Promocao de tamanho
u8 + i32    ‚Üí i32    // Tamanho maior vence
i32 + i64   ‚Üí i64    // Tamanho maior vence
u32 + u64   ‚Üí u64    // Tamanho maior vence

// Promocao de float
i32 + f32   ‚Üí f32    // Float vence, f32 suficiente para i32
i64 + f32   ‚Üí f64    // Promove para f64 para preservar precisao de i64
i64 + f64   ‚Üí f64    // Float sempre vence
i8 + f64    ‚Üí f64    // Float + maior vence
```

**Por que i64 + f32 ‚Üí f64?**

f32 tem apenas 24 bits de mantissa, nao pode representar precisamente inteiros maiores que 2^24 (16.777.216). Como i64 pode armazenar valores ate 2^63, misturar i64 com f32 causaria perda severa de precisao. Hemlock promove para f64 (53 bits de mantissa) em vez disso.

---

## Verificacao de Faixa

Anotacoes de tipo aplicam verificacao de faixa na atribuicao:

**Atribuicoes Validas:**
```hemlock
let x: u8 = 255;             // OK
let y: i8 = 127;             // OK
let a: i64 = 2147483647;     // OK
let b: u64 = 4294967295;     // OK
```

**Atribuicoes Invalidas (erro de runtime):**
```hemlock
let x: u8 = 256;             // ERRO: fora da faixa
let y: i8 = 128;             // ERRO: max e 127
let z: u64 = -1;             // ERRO: u64 nao pode ser negativo
```

---

## Introspeccao de Tipo

### typeof(value)

Retorna o nome do tipo como string.

**Assinatura:**
```hemlock
typeof(value: any): string
```

**Retorna:**
- Tipos primitivos: `"i8"`, `"i16"`, `"i32"`, `"i64"`, `"u8"`, `"u16"`, `"u32"`, `"u64"`, `"f32"`, `"f64"`, `"bool"`, `"string"`, `"rune"`, `"null"`
- Tipos compostos: `"array"`, `"object"`, `"ptr"`, `"buffer"`, `"function"`
- Tipos especiais: `"file"`, `"task"`, `"channel"`
- Objetos tipados: Nome de tipo personalizado (ex: `"Person"`)

**Exemplo:**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("hello"));         // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"

define Person { name: string }
let p: Person = { name: "Alice" };
print(typeof(p));               // "Person"
```

**Veja Tambem:** [Funcoes Integradas](builtins.md#typeof)

---

## Conversao de Tipo

### Conversao Implicita

Hemlock realiza conversao implicita de tipo em operacoes aritmeticas seguindo regras de promocao de tipo.

**Exemplo:**
```hemlock
let a: u8 = 10;
let b: i32 = 20;
let result = a + b;     // result e i32 (promovido)
```

### Conversao Explicita

Use anotacoes de tipo para conversao explicita:

**Exemplo:**
```hemlock
// Inteiro para float
let i: i32 = 42;
let f: f64 = i;         // 42.0

// Float para inteiro (trunca)
let x: f64 = 3.14;
let y: i32 = x;         // 3

// Inteiro para rune
let code: rune = 65;    // 'A'

// Rune para inteiro
let value: i32 = 'Z';   // 90

// Rune para string
let s: string = 'H';    // "H"
```

---

## Alias de Tipo

### Alias Integrados

Hemlock fornece alias de tipo integrados para tipos comuns:

| Alias     | Tipo Real | Uso           |
|-----------|----------|---------------|
| `integer` | `i32`    | Inteiro geral |
| `number`  | `f64`    | Float geral   |
| `byte`    | `u8`     | Valores de byte |

**Exemplo:**
```hemlock
let count: integer = 100;       // Mesmo que i32
let price: number = 19.99;      // Mesmo que f64
let b: byte = 255;              // Mesmo que u8
```

### Alias de Tipo Personalizados

Use a palavra-chave `type` para definir alias de tipo personalizados:

```hemlock
// Alias simples
type Integer = i32;
type Text = string;

// Alias de tipo de funcao
type Callback = fn(i32): void;
type Predicate = fn(any): bool;
type BinaryOp = fn(i32, i32): i32;

// Alias de tipo composto
define HasName { name: string }
define HasAge { age: i32 }
type Person = HasName & HasAge;

// Alias de tipo generico
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };
```

**Usando alias personalizados:**
```hemlock
let cb: Callback = fn(n) { print(n); };
let p: Person = { name: "Alice", age: 30 };
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
```

**Nota:** Alias de tipo sao transparentes - `typeof()` retorna o nome do tipo subjacente.

---

## Tipos de Funcao

Tipos de funcao especificam a assinatura de valores de funcao:

### Sintaxe

```hemlock
fn(tipos_parametros): tipo_retorno
```

### Exemplos

```hemlock
// Tipo de funcao basico
let add: fn(i32, i32): i32 = fn(a, b) { return a + b; };

// Parametro de funcao
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Funcao de ordem superior retornando funcao
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Tipo de funcao assincrona
fn run_async(handler: async fn(): void) {
    spawn(handler);
}
```

---

## Tipos Compostos (Tipos de Intersecao)

Tipos compostos usam `&` para requerer multiplas restricoes de tipo:

```hemlock
define HasName { name: string }
define HasAge { age: i32 }
define HasEmail { email: string }

// Objeto deve satisfazer todos os tipos
let person: HasName & HasAge = { name: "Alice", age: 30 };

// Tres ou mais tipos
fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}
```

---

## Tabela de Resumo

| Tipo       | Tamanho  | Mutavel | Heap | Descricao                |
|------------|----------|---------|------|--------------------------|
| `i8`-`i64` | 1-8 bytes | Nao    | Nao  | Inteiros com sinal       |
| `u8`-`u64` | 1-8 bytes | Nao    | Nao  | Inteiros sem sinal       |
| `f32`      | 4 bytes  | Nao    | Nao  | Float precisao simples   |
| `f64`      | 8 bytes  | Nao    | Nao  | Float precisao dupla     |
| `bool`     | 1 byte   | Nao    | Nao  | Booleano                 |
| `rune`     | 4 bytes  | Nao    | Nao  | Ponto de codigo Unicode  |
| `string`   | Variavel | Sim    | Sim  | Texto UTF-8              |
| `array`    | Variavel | Sim    | Sim  | Array dinamico           |
| `object`   | Variavel | Sim    | Sim  | Objeto dinamico          |
| `ptr`      | 8 bytes  | Nao    | Nao  | Ponteiro bruto           |
| `buffer`   | Variavel | Sim    | Sim  | Wrapper de ponteiro seguro |
| `file`     | Opaco    | Sim    | Sim  | Handle de arquivo        |
| `task`     | Opaco    | Nao    | Sim  | Handle de tarefa concorrente |
| `channel`  | Opaco    | Sim    | Sim  | Canal thread-safe        |
| `function` | Opaco    | Nao    | Sim  | Valor de funcao          |
| `null`     | 8 bytes  | Nao    | Nao  | Valor nulo               |

---

## Veja Tambem

- [Referencia de Operadores](#reference-operators) - Comportamento de tipo em operacoes
- [Funcoes Integradas](#reference-builtins) - Introspeccao e conversao de tipo
- [API de Strings](#reference-string-api) - Metodos do tipo string
- [API de Arrays](#reference-array-api) - Metodos do tipo array
- [API de Memoria](#reference-memory-api) - Operacoes com ponteiro e buffer



################################################################################
# DESIGN E FILOSOFIA
################################################################################

--------------------------------------------------------------------------------
## Filosofia
--------------------------------------------------------------------------------

# Filosofia de Design da Linguagem Hemlock

> "Uma linguagem pequena e n√£o-segura, para escrever c√≥digo n√£o-seguro de forma segura."

Este documento registra os princ√≠pios e filosofia de design centrais do Hemlock. Por favor, leia este documento antes de fazer qualquer altera√ß√£o ou adi√ß√£o √† linguagem.

---

## Sum√°rio

- [Posicionamento Central](#posicionamento-central)
- [Princ√≠pios de Design](#princ√≠pios-de-design)
- [Filosofia de Seguran√ßa](#filosofia-de-seguran√ßa)
- [Recursos que N√£o Devem Ser Adicionados](#recursos-que-n√£o-devem-ser-adicionados)
- [Considera√ß√µes Futuras](#considera√ß√µes-futuras)
- [Conclus√£o](#conclus√£o)

---

## Posicionamento Central

Hemlock √© uma **linguagem de script de sistemas**, com gerenciamento manual de mem√≥ria e controle expl√≠cito. Foi projetada para programadores que precisam de:

- O poder da linguagem C
- A facilidade de uso de linguagens de script modernas
- Concorr√™ncia ass√≠ncrona estruturada integrada
- Sem comportamentos ocultos ou m√°gica

### O que Hemlock N√£o √â

- **Segura em rela√ß√£o √† mem√≥ria** (ponteiros pendurados s√£o sua responsabilidade)
- **Substituta de Rust, Go ou Lua**
- **Uma linguagem que esconde complexidade de voc√™**

### O que Hemlock √â

- **Sempre expl√≠cito √© melhor que impl√≠cito**
- **Educacional e experimental**
- **Uma "camada de script C" para trabalho de sistemas**
- **Honesta sobre os trade-offs**

---

## Princ√≠pios de Design

### 1. Expl√≠cito √© Melhor que Impl√≠cito

Hemlock favorece o expl√≠cito em todas as constru√ß√µes da linguagem. N√£o deve haver surpresas, m√°gica ou comportamentos ocultos.

**Pr√°tica ruim (impl√≠cita):**
```hemlock
let x = 5  // Ponto e v√≠rgula faltando - deveria dar erro
```

**Boa pr√°tica (expl√≠cita):**
```hemlock
let x = 5;
free(ptr);  // Voc√™ alocou, voc√™ libera
```

**Pontos-chave:**
- Ponto e v√≠rgula √© obrigat√≥rio (sem inser√ß√£o autom√°tica de ponto e v√≠rgula)
- Sem coleta de lixo
- Gerenciamento manual de mem√≥ria (alloc/free)
- Anota√ß√µes de tipo s√£o opcionais, mas s√£o verificadas em tempo de execu√ß√£o
- Sem limpeza autom√°tica de recursos (sem RAII), mas `defer` oferece limpeza expl√≠cita

### 2. Din√¢mico por Padr√£o, Tipos Opcionais

Cada valor tem uma tag de tipo em tempo de execu√ß√£o, mas o sistema foi projetado para ser flex√≠vel enquanto ainda captura erros.

**Infer√™ncia de tipos:**
- Inteiros pequenos (cabem em i32): `42` ‚Üí `i32`
- Inteiros grandes (excedem o intervalo de i32): `9223372036854775807` ‚Üí `i64`
- Ponto flutuante: `3.14` ‚Üí `f64`

**Tipos expl√≠citos quando necess√°rio:**
```hemlock
let x = 42;              // Inferido como i32 (valor pequeno)
let y: u8 = 255;         // u8 expl√≠cito
let z = x + y;           // Promovido para i32
let big = 5000000000;    // Inferido como i64 (excede m√°ximo de i32)
```

**Regras de promo√ß√£o de tipos** seguem uma hierarquia clara do menor para o maior, com ponto flutuante sempre tendo prioridade sobre inteiros.

### 3. N√£o-Seguro √© um Recurso, N√£o um Defeito

Hemlock n√£o tenta prevenir todos os erros. Em vez disso, oferece ferramentas seguras enquanto permite que voc√™ opte por comportamento n√£o-seguro quando necess√°rio.

**Exemplos de n√£o-seguran√ßa intencional:**
- Aritm√©tica de ponteiros pode estourar (responsabilidade do usu√°rio)
- `ptr` bruto n√£o tem verifica√ß√£o de limites (use `buffer` se precisar de seguran√ßa)
- Double free √© permitido causar crash (gerenciamento manual de mem√≥ria)
- Sistema de tipos previne acidentes mas permite opera√ß√µes perigosas quando necess√°rio

```hemlock
let p = alloc(10);
let q = p + 100;  // Muito al√©m da aloca√ß√£o - permitido mas perigoso
```

**Filosofia:** O sistema de tipos deve prevenir *acidentes*, mas permitir opera√ß√µes n√£o-seguras *intencionais*.

### 4. Concorr√™ncia Estruturada como Cidad√£ de Primeira Classe

Concorr√™ncia n√£o √© uma reflex√£o tardia em Hemlock. Est√° integrada na linguagem desde o in√≠cio.

**Recursos principais:**
- `async`/`await` integrados na linguagem
- Channels para comunica√ß√£o
- `spawn`/`join`/`detach` para gerenciamento de tarefas
- Sem threads brutas, sem locks - apenas estruturado
- Usa threads POSIX para paralelismo real multi-thread

**N√£o √© um event loop ou green threads** - Hemlock usa threads reais do sistema operacional para paralelismo verdadeiro em m√∫ltiplos n√∫cleos de CPU.

### 5. Sintaxe Semelhante a C, Baixa Cerim√¥nia

Hemlock deve parecer familiar para programadores de sistemas, enquanto reduz c√≥digo boilerplate.

**Escolhas de design:**
- Sempre usa blocos `{}`, sem chaves opcionais
- Operadores correspondem a C: `+`, `-`, `*`, `/`, `&&`, `||`, `!`
- Sintaxe de tipos corresponde a Rust/TypeScript: `let x: type = value;`
- Fun√ß√µes s√£o valores de primeira classe
- M√≠nimo de palavras-chave e formas especiais

---

## Filosofia de Seguran√ßa

**A vis√£o do Hemlock sobre seguran√ßa:**

> "N√≥s damos a voc√™ ferramentas seguras (`buffer`, anota√ß√µes de tipo, verifica√ß√£o de limites), mas n√£o for√ßamos voc√™ a us√°-las (`ptr`, mem√≥ria manual, opera√ß√µes n√£o-seguras).
>
> O padr√£o deve guiar para seguran√ßa, mas escotilhas de escape devem estar sempre dispon√≠veis."

### Ferramentas de Seguran√ßa Oferecidas

**1. Tipo buffer seguro:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // Verifica√ß√£o de limites
print(b.length);        // 64
free(b);                // Ainda √© manual
```

**2. Ponteiros brutos n√£o-seguros:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // Voc√™ deve lembrar de liberar
```

**3. Anota√ß√µes de tipo:**
```hemlock
let x: u8 = 255;   // Correto
let y: u8 = 256;   // Erro: fora do intervalo
```

**4. Verifica√ß√£o de tipos em tempo de execu√ß√£o:**
```hemlock
let val = some_function();
if (typeof(val) == "i32") {
    // Pode usar com seguran√ßa como inteiro
}
```

### Princ√≠pios Orientadores

1. **Usar modo seguro por padr√£o na documenta√ß√£o** - Mostrar `buffer` antes de `ptr`, encorajar anota√ß√µes de tipo
2. **Tornar opera√ß√µes n√£o-seguras vis√≠veis** - Aritm√©tica de ponteiros brutos deve parecer intencional
3. **Oferecer escotilhas de escape** - N√£o impedir usu√°rios experientes de fazer trabalho de baixo n√≠vel
4. **Ser honesto sobre trade-offs** - Documentar o que pode dar errado

### Exemplos de Seguro vs N√£o-Seguro

| Modo Seguro | Modo N√£o-Seguro | Quando Usar N√£o-Seguro |
|-------------|-----------------|------------------------|
| Tipo `buffer` | Tipo `ptr` | FFI, c√≥digo cr√≠tico para performance |
| Anota√ß√µes de tipo | Sem anota√ß√µes | Interfaces externas, valida√ß√£o |
| Acesso com verifica√ß√£o de limites | Aritm√©tica de ponteiros | Opera√ß√µes de mem√≥ria de baixo n√≠vel |
| Tratamento de exce√ß√µes | Retornar null/c√≥digo de erro | Quando exce√ß√µes s√£o muito pesadas |

---

## Recursos que N√£o Devem Ser Adicionados

Entender o que **n√£o** deve ser adicionado √© t√£o importante quanto saber o que deve ser adicionado.

### N√£o Adicione Comportamentos Impl√≠citos

**Exemplos ruins:**

```hemlock
// Ruim: inser√ß√£o autom√°tica de ponto e v√≠rgula
let x = 5
let y = 10

// Ruim: convers√£o de tipo impl√≠cita com perda de precis√£o
let x: i32 = 3.14  // Deveria truncar ou dar erro?
```

**Motivo:** Comportamentos impl√≠citos causam surpresas e tornam o c√≥digo mais dif√≠cil de entender.

### N√£o Esconda Complexidade

**Exemplos ruins:**

```hemlock
// Ruim: otimiza√ß√µes m√°gicas por tr√°s dos panos
let arr = [1, 2, 3]  // Isso √© stack ou heap? O usu√°rio deveria saber! (heap, contagem de refer√™ncia)

// Ruim: libera√ß√£o autom√°tica de ponteiros brutos
let p = alloc(100)  // Isso ser√° liberado automaticamente? N√£o! Ponteiros brutos sempre precisam de free()
```

**Nota sobre contagem de refer√™ncia:** Hemlock usa contagem de refer√™ncia interna para strings, arrays, objetos e buffers - estes s√£o liberados automaticamente quando saem do escopo. Isso √© expl√≠cito e previs√≠vel (limpeza determin√≠stica quando a contagem chega a 0, sem pausas de GC). Ponteiros brutos (`ptr` de `alloc()`) n√£o s√£o contados por refer√™ncia e sempre precisam de `free()` manual.

**Motivo:** Complexidade oculta torna imposs√≠vel prever performance e depurar problemas.

### N√£o Quebre Sem√¢nticas Existentes

**Nunca mude estas decis√µes centrais:**
- Ponto e v√≠rgula √© obrigat√≥rio - n√£o torn√°-lo opcional
- Gerenciamento manual de mem√≥ria - n√£o adicionar GC
- Strings mut√°veis - n√£o torn√°-las imut√°veis
- Verifica√ß√£o de tipos em tempo de execu√ß√£o - n√£o remov√™-la

**Motivo:** Consist√™ncia e estabilidade s√£o mais importantes que recursos da moda.

### N√£o Adicione Recursos de "Conveni√™ncia" que Reduzam Explicitude

**Exemplos de recursos a evitar:**
- Sobrecarga de operadores (tipos de usu√°rio talvez ok, mas com cuidado)
- Coer√ß√£o de tipo impl√≠cita que perde informa√ß√£o
- Limpeza autom√°tica de recursos (RAII)
- Encadeamento de m√©todos que esconde complexidade
- DSLs e sintaxe m√°gica

**Exce√ß√£o:** Se um recurso de conveni√™ncia √© **a√ß√∫car sint√°tico expl√≠cito** para opera√ß√µes simples, pode ser ok:
- `else if` √© ok (√© apenas if aninhado)
- Interpola√ß√£o de strings pode ser ok, se for obviamente a√ß√∫car sint√°tico
- Sintaxe de m√©todos para objetos √© ok (√© expl√≠cito o que faz)

---

## Considera√ß√µes Futuras

### Pode Ser Adicionado (Em Discuss√£o)

Estes recursos se alinham com a filosofia do Hemlock, mas precisam de design cuidadoso:

**1. Pattern Matching**
```hemlock
match (value) {
    case i32: print("inteiro");
    case string: print("texto");
    case _: print("outro");
}
```
- Verifica√ß√£o de tipos expl√≠cita
- Sem custos ocultos
- Poss√≠vel verifica√ß√£o de exaustividade em tempo de compila√ß√£o

**2. Tipos de Erro (`Result<T, E>`)**
```hemlock
fn divide(a: i32, b: i32): Result<i32, string> {
    if (b == 0) {
        return Err("divis√£o por zero");
    }
    return Ok(a / b);
}
```
- Tratamento de erros expl√≠cito
- For√ßa o usu√°rio a considerar erros
- Alternativa a exce√ß√µes

**3. Tipos de Array/Slice**
- J√° tem arrays din√¢micos
- Pode adicionar arrays de tamanho fixo para aloca√ß√£o em stack
- Precisa ser expl√≠cito sobre stack vs heap

**4. Ferramentas de Seguran√ßa de Mem√≥ria Melhoradas**
- Flag opcional de verifica√ß√£o de limites
- Detec√ß√£o de vazamento de mem√≥ria em builds de debug
- Integra√ß√£o com sanitizers

### Provavelmente Nunca Ser√° Adicionado

Estes recursos violam princ√≠pios centrais:

**1. Coleta de Lixo**
- Esconde complexidade de gerenciamento de mem√≥ria
- Performance imprevis√≠vel
- Viola princ√≠pio de controle expl√≠cito

**2. Gerenciamento Autom√°tico de Mem√≥ria**
- Mesmas raz√µes que GC
- Contagem de refer√™ncia pode ser ok se expl√≠cita

**3. Convers√µes de Tipo Impl√≠citas que Perdem Dados**
- Viola "expl√≠cito √© melhor que impl√≠cito"
- Fonte de erros sutis

**4. Macros (Complexas)**
- Muito poder, muita complexidade
- Sistema de macros simples pode ser ok
- Prefira gera√ß√£o de c√≥digo ou fun√ß√µes

**5. Orienta√ß√£o a Objetos Baseada em Classes com Heran√ßa**
- Muitos comportamentos impl√≠citos
- Duck typing e objetos s√£o suficientes
- Composi√ß√£o sobre heran√ßa

**6. Sistema de M√≥dulos com Resolu√ß√£o Complexa**
- Manter imports simples e expl√≠citos
- Sem caminhos de busca m√°gicos
- Sem resolu√ß√£o de vers√µes (use gerenciador de pacotes do SO)

---

## Conclus√£o

### Confian√ßa e Responsabilidade

Hemlock √© sobre **confian√ßa e responsabilidade**. N√≥s confiamos que os programadores podem:

- Gerenciar mem√≥ria corretamente
- Usar tipos apropriadamente
- Tratar erros corretamente
- Entender trade-offs

Em troca, Hemlock oferece:

- Sem custos ocultos
- Sem comportamentos inesperados
- Controle total quando necess√°rio
- Ferramentas seguras quando necess√°rio

### Perguntas Orientadoras

**Ao considerar um novo recurso, pergunte:**

> "Isso d√° ao programador mais controle expl√≠cito, ou esconde algo?"

- Se **aumenta controle expl√≠cito** ‚Üí Provavelmente cabe no Hemlock
- Se **esconde complexidade** ‚Üí Provavelmente n√£o pertence aqui
- Se √© **a√ß√∫car sint√°tico opcional** com documenta√ß√£o clara ‚Üí Talvez ok

### Bons Exemplos de Adi√ß√µes

- **Switch statement** - Fluxo de controle expl√≠cito, sem m√°gica, sem√¢ntica clara

- **Async/await com pthreads** - Concorr√™ncia expl√≠cita, paralelismo real, usu√°rio controla spawn

- **Tipo Buffer junto com ptr** - Oferece escolha entre seguro e n√£o-seguro

- **Anota√ß√µes de tipo opcionais** - Ajuda a capturar erros sem for√ßar rigidez

- **Try/catch/finally** - Tratamento de erros expl√≠cito com fluxo de controle claro

### Maus Exemplos de Adi√ß√µes

- **Inser√ß√£o autom√°tica de ponto e v√≠rgula** - Esconde erros de sintaxe, torna c√≥digo obscuro

- **RAII/Destrutores** - Limpeza autom√°tica esconde quando recursos s√£o liberados

- **Coalesc√™ncia de null impl√≠cita** - Esconde verifica√ß√µes de null, torna c√≥digo mais dif√≠cil de entender

- **Strings com crescimento autom√°tico** - Esconde aloca√ß√£o de mem√≥ria, performance imprevis√≠vel

---

## Resumo

Hemlock n√£o tenta ser a linguagem mais segura, a mais r√°pida ou a mais rica em recursos.

**Hemlock tenta ser a linguagem mais *honesta*.**

Ela diz exatamente o que est√° fazendo, d√° controle quando voc√™ precisa, e n√£o esconde arestas cortantes. √â uma linguagem para quem quer entender c√≥digo em n√≠vel baixo enquanto ainda aproveita conveni√™ncias modernas.

Se voc√™ n√£o tem certeza se um recurso pertence ao Hemlock, lembre-se:

> **Sempre expl√≠cito √© melhor que impl√≠cito.**
> **N√£o-seguro √© um recurso, n√£o um defeito.**
> **O usu√°rio √© respons√°vel, e isso est√° ok.**


--------------------------------------------------------------------------------
## Implementa√ß√£o
--------------------------------------------------------------------------------

# Detalhes de Implementa√ß√£o do Hemlock

Este documento descreve a implementa√ß√£o t√©cnica da linguagem Hemlock, incluindo estrutura do projeto, pipeline de compila√ß√£o, arquitetura de runtime e decis√µes de design.

---

## Sum√°rio

- [Estrutura do Projeto](#estrutura-do-projeto)
- [Pipeline de Compila√ß√£o](#pipeline-de-compila√ß√£o)
- [Design Modular do Interpretador](#design-modular-do-interpretador)
- [Arquitetura de Runtime](#arquitetura-de-runtime)
- [Representa√ß√£o de Valores](#representa√ß√£o-de-valores)
- [Implementa√ß√£o do Sistema de Tipos](#implementa√ß√£o-do-sistema-de-tipos)
- [Gerenciamento de Mem√≥ria](#gerenciamento-de-mem√≥ria)
- [Modelo de Concorr√™ncia](#modelo-de-concorr√™ncia)
- [Planos Futuros](#planos-futuros)

---

## Estrutura do Projeto

```
hemlock/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ frontend/              # Compartilhado: lexer, parser, AST
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lexer.c            # An√°lise l√©xica
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ parser/            # Parser descendente recursivo
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ast.c              # Gerenciamento de n√≥s AST
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ module.c           # Resolu√ß√£o de m√≥dulos
‚îÇ   ‚îú‚îÄ‚îÄ backends/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interpreter/       # hemlock: interpretador tree-walking
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.c         # Ponto de entrada CLI
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ runtime.c      # Avalia√ß√£o de express√µes/statements
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ builtins.c     # Fun√ß√µes builtin
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ compiler/          # hemlockc: gerador de c√≥digo C
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ main.c         # CLI, orquestra√ß√£o
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ type_check.c   # Verifica√ß√£o de tipos em compile-time
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ codegen.c      # Contexto de gera√ß√£o de c√≥digo
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ codegen_expr.c # Gera√ß√£o de c√≥digo para express√µes
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ codegen_stmt.c # Gera√ß√£o de c√≥digo para statements
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ tools/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lsp/               # Protocolo Language Server
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ bundler/           # Ferramenta de bundling/pacotes
‚îú‚îÄ‚îÄ runtime/                   # libhemlock_runtime.a (para programas compilados)
‚îú‚îÄ‚îÄ stdlib/                    # Biblioteca padr√£o (39 m√≥dulos)
‚îÇ   ‚îî‚îÄ‚îÄ docs/                  # Documenta√ß√£o dos m√≥dulos
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ parity/                # Testes que devem passar em ambos backends
‚îÇ   ‚îú‚îÄ‚îÄ interpreter/           # Testes espec√≠ficos do interpretador
‚îÇ   ‚îî‚îÄ‚îÄ compiler/              # Testes espec√≠ficos do compilador
‚îú‚îÄ‚îÄ examples/                  # Programas de exemplo
‚îî‚îÄ‚îÄ docs/                      # Documenta√ß√£o
```

### Organiza√ß√£o de Diret√≥rios

**`include/`** - Headers de API p√∫blica que definem interfaces entre componentes:
- Separa√ß√£o clara entre lexer, parser, AST e interpretador
- Declara√ß√µes forward para minimizar depend√™ncias
- API p√∫blica para incorporar Hemlock em outros programas

**`src/`** - Arquivos de implementa√ß√£o:
- Arquivos de n√≠vel superior tratam lexing, parsing, gerenciamento de AST
- `main.c` fornece CLI e REPL
- Interpretador modularizado em subsistemas independentes

**`src/interpreter/`** - Implementa√ß√£o modular do interpretador:
- Cada m√≥dulo tem uma √∫nica responsabilidade clara
- APIs internas definidas em `internal.h` para comunica√ß√£o entre m√≥dulos
- M√≥dulos podem ser compilados independentemente para builds mais r√°pidos

**`tests/`** - Su√≠te de testes abrangente:
- Organizada por √°rea funcional
- Cada diret√≥rio cont√©m casos de teste focados
- `run_tests.sh` orquestra execu√ß√£o de testes

---

## Pipeline de Compila√ß√£o

Hemlock usa um pipeline de compila√ß√£o tradicional com fases distintas:

### Fase 1: An√°lise L√©xica (Lexer)

**Entrada:** Texto do c√≥digo fonte
**Sa√≠da:** Stream de tokens
**Implementa√ß√£o:** `src/lexer.c`

```
Fonte: "let x = 42;"
   ‚Üì
Tokens: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
```

**Recursos principais:**
- Reconhece palavras-chave, identificadores, literais, operadores, pontua√ß√£o
- Trata literais de string UTF-8 e literais de rune
- Reporta n√∫meros de linha para mensagens de erro
- Passagem √∫nica, sem backtracking

### Fase 2: An√°lise Sint√°tica (Parser)

**Entrada:** Stream de tokens
**Sa√≠da:** √Årvore Sint√°tica Abstrata (AST)
**Implementa√ß√£o:** `src/parser.c`

```
Tokens: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
   ‚Üì
AST: LetStmt {
    name: "x",
    type: null,
    value: IntLiteral(42)
}
```

**Recursos principais:**
- Parser descendente recursivo
- Constr√≥i representa√ß√£o em √°rvore da estrutura do programa
- Trata preced√™ncia de operadores
- Valida sintaxe (chaves, ponto e v√≠rgula, etc.)
- Sem an√°lise sem√¢ntica ainda (feita em tempo de execu√ß√£o)

**Preced√™ncia de Operadores (da mais baixa para a mais alta):**
1. Atribui√ß√£o: `=`
2. Ou l√≥gico: `||`
3. E l√≥gico: `&&`
4. Ou bit a bit: `|`
5. Xor bit a bit: `^`
6. E bit a bit: `&`
7. Igualdade: `==`, `!=`
8. Compara√ß√£o: `<`, `>`, `<=`, `>=`
9. Shift: `<<`, `>>`
10. Adi√ß√£o/Subtra√ß√£o: `+`, `-`
11. Multiplica√ß√£o/Divis√£o/M√≥dulo: `*`, `/`, `%`
12. Un√°rio: `!`, `-`, `~`
13. Chamada/√çndice/Membro: `()`, `[]`, `.`

### Fase 3a: Execu√ß√£o Interpretada (Tree-Walking)

**Entrada:** AST
**Sa√≠da:** Execu√ß√£o do programa
**Implementa√ß√£o:** `src/backends/interpreter/runtime.c`

```
AST: LetStmt { ... }
   ‚Üì
Execu√ß√£o: Avaliar n√≥s AST recursivamente
   ‚Üì
Resultado: Criar vari√°vel x com valor 42
```

**Recursos principais:**
- Travessia direta de AST (interpretador tree-walking)
- Verifica√ß√£o de tipos din√¢mica em tempo de execu√ß√£o
- Armazenamento de vari√°veis baseado em ambiente

### Fase 3b: Compila√ß√£o (hemlockc)

**Entrada:** AST
**Sa√≠da:** Execut√°vel nativo via gera√ß√£o de c√≥digo C
**Implementa√ß√£o:** `src/backends/compiler/`

```
AST: LetStmt { ... }
   ‚Üì
Verifica√ß√£o de Tipos: Validar tipos em compile-time
   ‚Üì
Gera√ß√£o de C√≥digo C: Gerar c√≥digo C equivalente
   ‚Üì
GCC: Compilar C para bin√°rio nativo
   ‚Üì
Resultado: Execut√°vel standalone
```

**Recursos principais:**
- Verifica√ß√£o de tipos em compile-time (habilitada por padr√£o)
- Gera√ß√£o de c√≥digo C para portabilidade
- Linka com `libhemlock_runtime.a`
- Execu√ß√£o significativamente mais r√°pida que interpretador

---

## Backend do Compilador (hemlockc)

O compilador Hemlock gera c√≥digo C a partir do AST, que √© ent√£o compilado para execut√°vel nativo usando GCC.

### Arquitetura do Compilador

```
src/backends/compiler/
‚îú‚îÄ‚îÄ main.c              # CLI, parsing de argumentos, orquestra√ß√£o
‚îú‚îÄ‚îÄ codegen.c           # Contexto core de gera√ß√£o de c√≥digo
‚îú‚îÄ‚îÄ codegen_expr.c      # Gera√ß√£o de c√≥digo para express√µes
‚îú‚îÄ‚îÄ codegen_stmt.c      # Gera√ß√£o de c√≥digo para statements
‚îú‚îÄ‚îÄ codegen_call.c      # Gera√ß√£o de chamadas de fun√ß√£o
‚îú‚îÄ‚îÄ codegen_closure.c   # Implementa√ß√£o de closures
‚îú‚îÄ‚îÄ codegen_program.c   # Gera√ß√£o de programa de n√≠vel superior
‚îú‚îÄ‚îÄ codegen_module.c    # Tratamento de m√≥dulos/imports
‚îú‚îÄ‚îÄ type_check.c        # Verifica√ß√£o de tipos em compile-time
‚îî‚îÄ‚îÄ type_check.h        # API do type checker
```

### Verifica√ß√£o de Tipos

O compilador inclui um sistema unificado de verifica√ß√£o de tipos que pode:

1. **Validar tipos em compile-time** - Capturar erros de tipo antes da execu√ß√£o
2. **Suportar c√≥digo din√¢mico** - C√≥digo sem tipos √© tratado como `any` (sempre v√°lido)
3. **Fornecer dicas de otimiza√ß√£o** - Identificar vari√°veis que podem ser unboxed

**Flags de verifica√ß√£o de tipos:**

| Flag | Descri√ß√£o |
|------|-----------|
| (padr√£o) | Verifica√ß√£o de tipos habilitada |
| `--check` | Apenas verificar tipos, n√£o compilar |
| `--no-type-check` | Desabilitar verifica√ß√£o de tipos |
| `--strict-types` | Avisar sobre tipos `any` impl√≠citos |

**Implementa√ß√£o do Type Checker:**

```c
// type_check.h - Estruturas principais
typedef struct TypeCheckContext {
    const char *filename;
    int error_count;
    int warning_count;
    UnboxableVar *unboxable_vars;  // Dicas de otimiza√ß√£o
    // ... ambiente de tipos, defini√ß√µes, etc
} TypeCheckContext;

// Ponto de entrada principal
int type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);
```

### Gera√ß√£o de C√≥digo

A fase de gera√ß√£o de c√≥digo transforma n√≥s AST em c√≥digo C:

**Mapeamento de Express√µes:**
```
Hemlock                 ‚Üí  C Gerado
----------------------------------------
let x = 42;            ‚Üí  HmlValue x = hml_val_i32(42);
x + y                  ‚Üí  hml_add(x, y)
arr[i]                 ‚Üí  hml_array_get(arr, i)
obj.field              ‚Üí  hml_object_get_field(obj, "field")
fn(a, b) { ... }       ‚Üí  closure com captura de ambiente
```

**Integra√ß√£o com Runtime:**

O c√≥digo C gerado linka com `libhemlock_runtime.a`, que fornece:
- Tipo `HmlValue` tagged union
- Gerenciamento de mem√≥ria (contagem de refer√™ncia)
- Fun√ß√µes builtin (print, typeof, etc.)
- Primitivas de concorr√™ncia (tasks, channels)
- Suporte FFI

### Otimiza√ß√£o de Unboxing

O type checker identifica vari√°veis que podem usar tipos C nativos ao inv√©s de `HmlValue` boxed:

**Padr√µes unbox√°veis:**
- Contadores de loop com tipo inteiro conhecido
- Vari√°veis acumuladoras em loops
- Vari√°veis com anota√ß√µes de tipo expl√≠citas (i32, i64, f64, bool)

```hemlock
// Contador de loop 'i' pode ser unboxed para int32_t nativo
for (let i: i32 = 0; i < 1000000; i = i + 1) {
    sum = sum + i;
}
```

---

## Design Modular do Interpretador

O interpretador √© dividido em m√≥dulos focados para melhor manutenibilidade e extensibilidade.

### Responsabilidades dos M√≥dulos

#### 1. Ambiente (`environment.c`) - 121 linhas

**Prop√≥sito:** Escopo de vari√°veis e resolu√ß√£o de nomes

**Fun√ß√µes principais:**
- `env_create()` - Criar novo ambiente com pai opcional
- `env_define()` - Definir nova vari√°vel no escopo atual
- `env_get()` - Buscar vari√°vel no escopo atual ou pai
- `env_set()` - Atualizar valor de vari√°vel existente
- `env_free()` - Liberar ambiente e todas as vari√°veis

**Design:**
- Escopos encadeados (cada ambiente tem ponteiro para pai)
- HashMap para busca r√°pida de vari√°veis
- Suporta escopo l√©xico para closures

#### 2. Valores (`values.c`) - 394 linhas

**Prop√≥sito:** Construtores de valores e gerenciamento de estruturas de dados

**Fun√ß√µes principais:**
- `value_create_*()` - Construtores para cada tipo de valor
- `value_copy()` - L√≥gica de c√≥pia profunda/rasa
- `value_free()` - Limpeza e libera√ß√£o de mem√≥ria
- `value_to_string()` - Representa√ß√£o em string para impress√£o

**Estruturas de dados:**
- Objetos (array din√¢mico de campos)
- Arrays (redimensionamento din√¢mico)
- Buffers (ptr + length + capacity)
- Closures (fun√ß√£o + ambiente capturado)
- Tasks e Channels (primitivas de concorr√™ncia)

#### 3. Tipos (`types.c`) - 440 linhas

**Prop√≥sito:** Sistema de tipos, convers√µes e duck typing

**Fun√ß√µes principais:**
- `type_check()` - Valida√ß√£o de tipos em tempo de execu√ß√£o
- `type_convert()` - Convers√£o/promo√ß√£o de tipos impl√≠cita
- `duck_type_check()` - Verifica√ß√£o de tipos estruturais para objetos
- `type_name()` - Obter nome do tipo para impress√£o

**Recursos:**
- Hierarquia de promo√ß√£o de tipos (i8 ‚Üí i16 ‚Üí i32 ‚Üí i64 ‚Üí f32 ‚Üí f64, i64/u64 + f32 ‚Üí f64)
- Verifica√ß√£o de intervalo para tipos num√©ricos
- Duck typing para defini√ß√µes de tipo de objeto
- Valores padr√£o para campos opcionais

#### 4. Builtins (`builtins.c`) - 955 linhas

**Prop√≥sito:** Fun√ß√µes builtin e registro global

**Fun√ß√µes principais:**
- `register_builtins()` - Registrar todas as fun√ß√µes e constantes builtin
- Implementa√ß√µes de fun√ß√µes builtin (print, typeof, alloc, free, etc.)
- Fun√ß√µes de tratamento de sinais
- Execu√ß√£o de comandos (exec)

**Categorias de builtins:**
- I/O: print, open, read_file, write_file
- Mem√≥ria: alloc, free, memset, memcpy, realloc
- Tipos: typeof, assert
- Concorr√™ncia: spawn, join, detach, channel
- Sistema: exec, signal, raise, panic
- FFI: dlopen, dlsym, dlcall, dlclose

#### 5. I/O (`io.c`) - 449 linhas

**Prop√≥sito:** I/O de arquivos e serializa√ß√£o JSON

**Fun√ß√µes principais:**
- M√©todos de objeto File (read, write, seek, tell, close)
- Serializa√ß√£o/deserializa√ß√£o JSON
- Detec√ß√£o de refer√™ncia circular

**Recursos:**
- Objetos file com atributos (path, mode, closed)
- I/O de texto com awareness de UTF-8
- Suporte a I/O bin√°rio
- Roundtrip JSON para objetos e arrays

#### 6. FFI (`ffi.c`) - Interface de Fun√ß√£o Estrangeira

**Prop√≥sito:** Chamar fun√ß√µes C de bibliotecas compartilhadas

**Fun√ß√µes principais:**
- `dlopen()` - Carregar biblioteca compartilhada
- `dlsym()` - Obter ponteiro de fun√ß√£o por nome
- `dlcall()` - Chamar fun√ß√£o C com convers√£o de tipos
- `dlclose()` - Descarregar biblioteca

**Recursos:**
- Integra√ß√£o com libffi para chamadas de fun√ß√£o din√¢micas
- Convers√£o autom√°tica de tipos (Hemlock ‚Üî tipos C)
- Suporte para todos os tipos primitivos
- Suporte para ponteiros e buffers

#### 7. Runtime (`runtime.c`) - 865 linhas

**Prop√≥sito:** Avalia√ß√£o de express√µes e execu√ß√£o de statements

**Fun√ß√µes principais:**
- `eval_expr()` - Avaliar express√µes (recursivo)
- `eval_stmt()` - Executar statements
- Tratamento de fluxo de controle (if, while, for, switch, etc.)
- Tratamento de exce√ß√µes (try/catch/finally/throw)

**Recursos:**
- Avalia√ß√£o recursiva de express√µes
- Avalia√ß√£o short-circuit de booleanos
- Detec√ß√£o de chamada de m√©todo e binding de `self`
- Propaga√ß√£o de exce√ß√µes
- Tratamento de break/continue/return

### Benef√≠cios do Design Modular

**1. Separa√ß√£o de Concerns**
- Cada m√≥dulo tem uma responsabilidade clara
- F√°cil encontrar onde um recurso est√° implementado
- Reduz carga cognitiva ao fazer mudan√ßas

**2. Builds Incrementais Mais R√°pidos**
- Apenas m√≥dulos modificados precisam ser recompilados
- Compila√ß√£o paralela poss√≠vel
- Tempo de itera√ß√£o mais curto durante desenvolvimento

**3. Testes e Debug Mais F√°ceis**
- M√≥dulos podem ser testados independentemente
- Erros localizados em subsistemas espec√≠ficos
- Implementa√ß√µes mock poss√≠veis para testes

**4. Extensibilidade**
- Novos recursos podem ser adicionados aos m√≥dulos apropriados
- M√≥dulos podem ser refatorados independentemente
- Quantidade de c√≥digo por arquivo permanece gerenci√°vel

**5. Organiza√ß√£o de C√≥digo**
- Agrupamento l√≥gico de funcionalidades relacionadas
- Grafo de depend√™ncias claro
- Mais f√°cil de onboarding para novos contribuidores

---

## Arquitetura de Runtime

### Representa√ß√£o de Valores

Todos os valores em Hemlock s√£o representados pela struct `Value` usando tagged union:

```c
typedef struct Value {
    ValueType type;  // Tag de tipo em runtime
    union {
        int32_t i32_value;
        int64_t i64_value;
        uint8_t u8_value;
        uint32_t u32_value;
        uint64_t u64_value;
        float f32_value;
        double f64_value;
        bool bool_value;
        char *string_value;
        uint32_t rune_value;
        void *ptr_value;
        Buffer *buffer_value;
        Array *array_value;
        Object *object_value;
        Function *function_value;
        File *file_value;
        Task *task_value;
        Channel *channel_value;
    };
} Value;
```

**Decis√µes de design:**
- **Tagged union** para type safety mantendo flexibilidade
- **Tag de tipo em runtime** habilita tipagem din√¢mica com verifica√ß√£o de tipos
- **Armazenamento direto de valores** para tipos primitivos (sem boxing)
- **Armazenamento de ponteiros** para tipos alocados em heap (strings, objetos, arrays)

### Exemplos de Layout de Mem√≥ria

**Inteiro (i32):**
```
Value {
    type: TYPE_I32,
    i32_value: 42
}
```
- Tamanho total: ~16 bytes (8 bytes tag + 8 bytes union)
- Alocado em stack
- N√£o requer aloca√ß√£o em heap

**String:**
```
Value {
    type: TYPE_STRING,
    string_value: 0x7f8a4c000000  // Ponteiro para heap
}

Heap: "hello\0" (6 bytes, UTF-8 terminado em null)
```
- Value ocupa 16 bytes em stack
- Dados da string s√£o alocados em heap
- Deve ser liberado manualmente

**Objeto:**
```
Value {
    type: TYPE_OBJECT,
    object_value: 0x7f8a4c001000  // Ponteiro para heap
}

Heap: Object {
    type_name: "Person",
    fields: [
        { name: "name", value: Value{TYPE_STRING, "Alice"} },
        { name: "age", value: Value{TYPE_I32, 30} }
    ],
    field_count: 2,
    capacity: 4
}
```
- Estrutura Object em heap
- Campos armazenados em array din√¢mico
- Valores de campos s√£o structs Value embutidas

### Implementa√ß√£o de Ambiente

Vari√°veis s√£o armazenadas em cadeia de ambientes:

```c
typedef struct Environment {
    HashMap *bindings;           // nome ‚Üí Value
    struct Environment *parent;  // Escopo pai l√©xico
} Environment;
```

**Exemplo de cadeia de escopo:**
```
Escopo Global: { print: <builtin>, args: <array> }
    ‚Üë
Escopo de Fun√ß√£o: { x: 10, y: 20 }
    ‚Üë
Escopo de Bloco: { i: 0 }
```

**Algoritmo de busca:**
1. Verificar hashmap do ambiente atual
2. Se n√£o encontrado, verificar ambiente pai
3. Repetir at√© encontrar ou alcan√ßar escopo global
4. Erro se n√£o encontrado em nenhum escopo

---

## Implementa√ß√£o do Sistema de Tipos

### Estrat√©gia de Verifica√ß√£o de Tipos

Hemlock usa **verifica√ß√£o de tipos em runtime** com **anota√ß√µes de tipo opcionais**:

```hemlock
let x = 42;           // Sem verifica√ß√£o de tipo, inferido como i32
let y: u8 = 255;      // Verifica√ß√£o runtime: valor deve caber em u8
let z: i32 = x + y;   // Verifica√ß√£o runtime + promo√ß√£o de tipo
```

**Fluxo de implementa√ß√£o:**
1. **Infer√™ncia de literal** - Lexer/parser determina tipo inicial do literal
2. **Verifica√ß√£o de anota√ß√£o** - Se anota√ß√£o presente, validar na atribui√ß√£o
3. **Promo√ß√£o** - Opera√ß√µes bin√°rias promovem para tipo comum
4. **Convers√£o** - Convers√µes expl√≠citas acontecem conforme necess√°rio

### Implementa√ß√£o de Promo√ß√£o de Tipos

A promo√ß√£o de tipos segue hierarquia fixa e preserva precis√£o:

```c
// L√≥gica simplificada de promo√ß√£o
ValueType promote_types(ValueType a, ValueType b) {
    // f64 sempre vence
    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;

    // f32 com i64/u64 promove para f64 (preserva√ß√£o de precis√£o)
    if (a == TYPE_F32 || b == TYPE_F32) {
        ValueType other = (a == TYPE_F32) ? b : a;
        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;
        return TYPE_F32;
    }

    // Tipo inteiro maior vence
    int rank_a = get_type_rank(a);
    int rank_b = get_type_rank(b);
    return (rank_a > rank_b) ? a : b;
}
```

**Ranks de tipo:**
- i8: 0
- u8: 1
- i16: 2
- u16: 3
- i32: 4
- u32: 5
- i64: 6
- u64: 7
- f32: 8
- f64: 9

### Implementa√ß√£o de Duck Typing

Verifica√ß√£o de tipos de objeto usa compara√ß√£o estrutural:

```c
bool duck_type_check(Object *obj, TypeDef *type_def) {
    // Verificar todos os campos requeridos
    for (each field in type_def) {
        if (!object_has_field(obj, field.name)) {
            return false;  // Campo faltando
        }

        Value *field_value = object_get_field(obj, field.name);
        if (!type_matches(field_value, field.type)) {
            return false;  // Tipo errado
        }
    }

    return true;  // Todos os campos requeridos presentes e tipados corretamente
}
```

**Duck typing permite:**
- Campos extras em objetos (ignorados)
- Tipos de subestrutura (objetos podem ter mais do que requerido)
- Atribui√ß√£o de nome de tipo ap√≥s valida√ß√£o

---

## Gerenciamento de Mem√≥ria

### Estrat√©gia de Aloca√ß√£o

Hemlock usa **gerenciamento manual de mem√≥ria** com duas primitivas de aloca√ß√£o:

**1. Ponteiros Brutos (`ptr`):**
```c
void *alloc(size_t bytes) {
    void *ptr = malloc(bytes);
    if (!ptr) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }
    return ptr;
}
```
- malloc/free direto
- Sem rastreamento
- Usu√°rio respons√°vel pela libera√ß√£o

**2. Buffers (`buffer`):**
```c
typedef struct Buffer {
    void *data;
    size_t length;
    size_t capacity;
} Buffer;

Buffer *create_buffer(size_t size) {
    Buffer *buf = malloc(sizeof(Buffer));
    buf->data = malloc(size);
    buf->length = size;
    buf->capacity = size;
    return buf;
}
```
- Rastreia tamanho e capacidade
- Verifica√ß√£o de limites em acesso
- Ainda requer free manual

### Tipos Alocados em Heap

**Strings:**
- Array de bytes UTF-8 em heap
- Terminada em null para interop com C
- Mut√°veis (podem ser modificadas in-place)
- Contagem de refer√™ncia (liberadas automaticamente ao sair do escopo)

**Objetos:**
- Array din√¢mico de campos
- Nomes e valores de campos em heap
- Contagem de refer√™ncia (liberados automaticamente ao sair do escopo)
- Refer√™ncias circulares poss√≠veis (tratadas com visited-set tracking)

**Arrays:**
- Capacidade din√¢mica com crescimento por dobra
- Elementos s√£o structs Value embutidas
- Realoca√ß√£o autom√°tica em crescimento
- Contagem de refer√™ncia (liberados automaticamente ao sair do escopo)

**Closures:**
- Capturam ambiente por refer√™ncia
- Ambiente √© alocado em heap
- Ambiente de closure liberado corretamente quando n√£o mais referenciado

---

## Modelo de Concorr√™ncia

### Arquitetura de Threads

Hemlock usa modelo de **threads 1:1** com threads POSIX (pthreads):

```
Tasks de Usu√°rio       Threads SO           N√∫cleos CPU
--------------         ----------           -----------
spawn(f1) ------>  pthread_create --> Core 0
spawn(f2) ------>  pthread_create --> Core 1
spawn(f3) ------>  pthread_create --> Core 2
```

**Caracter√≠sticas principais:**
- Cada `spawn()` cria um novo pthread
- Kernel agenda threads entre cores
- Execu√ß√£o paralela real (sem GIL)
- Multitarefa preemptiva

### Implementa√ß√£o de Tasks

```c
typedef struct Task {
    pthread_t thread;        // Handle da thread SO
    Value result;            // Valor de retorno
    char *error;             // Mensagem de exce√ß√£o (se lan√ßada)
    pthread_mutex_t lock;    // Protege estado
    TaskState state;         // RUNNING, FINISHED, ERROR
} Task;
```

**Ciclo de vida da task:**
1. `spawn(func, args)` ‚Üí Cria Task, inicia pthread
2. Thread executa fun√ß√£o com argumentos
3. No retorno: armazena resultado, define estado para FINISHED
4. Na exce√ß√£o: armazena mensagem de erro, define estado para ERROR
5. `join(task)` ‚Üí Espera thread, retorna resultado ou lan√ßa exce√ß√£o

### Implementa√ß√£o de Channels

```c
typedef struct Channel {
    void **buffer;           // Buffer circular de Value*
    size_t capacity;         // M√°ximo de itens no buffer
    size_t count;            // Itens atuais no buffer
    size_t read_index;       // Pr√≥xima posi√ß√£o de leitura
    size_t write_index;      // Pr√≥xima posi√ß√£o de escrita
    bool closed;             // Flag de channel fechado
    pthread_mutex_t lock;    // Protege buffer
    pthread_cond_t not_full; // Sinaliza quando h√° espa√ßo
    pthread_cond_t not_empty;// Sinaliza quando h√° dados
} Channel;
```

**Opera√ß√£o de envio:**
1. Trava mutex
2. Se buffer cheio espera (cond_wait em not_full)
3. Escreve valor em buffer[write_index]
4. Incrementa write_index (circular)
5. Sinaliza not_empty
6. Destrava mutex

**Opera√ß√£o de recebimento:**
1. Trava mutex
2. Se buffer vazio espera (cond_wait em not_empty)
3. L√™ valor de buffer[read_index]
4. Incrementa read_index (circular)
5. Sinaliza not_full
6. Destrava mutex

**Garantias de sincroniza√ß√£o:**
- Send/recv thread-safe (protegidos por mutex)
- Sem√¢ntica bloqueante (produtor espera quando cheio, consumidor espera quando vazio)
- Entrega ordenada (FIFO dentro do channel)

---

## Planos Futuros

### Conclu√≠do: Backend do Compilador

O backend do compilador (`hemlockc`) est√° implementado:
- Gera√ß√£o de c√≥digo C a partir do AST
- Verifica√ß√£o de tipos em compile-time (habilitada por padr√£o)
- Biblioteca de runtime (`libhemlock_runtime.a`)
- Paridade total com interpretador (98% taxa de aprova√ß√£o em testes)
- Framework de otimiza√ß√£o de unboxing

### Foco Atual: Melhorias no Sistema de Tipos

**Melhorias recentes:**
- Sistema unificado de verifica√ß√£o e infer√™ncia de tipos
- Verifica√ß√£o de tipos em compile-time habilitada por padr√£o
- Flag `--check` para valida√ß√£o apenas de tipos
- Contexto de tipos passado para gera√ß√£o de c√≥digo para dicas de otimiza√ß√£o

### Melhorias Futuras

**Poss√≠veis adi√ß√µes:**
- Generics/templates
- Pattern matching
- Integra√ß√£o LSP para suporte de IDE com awareness de tipos
- Otimiza√ß√µes de unboxing mais agressivas
- An√°lise de escape para aloca√ß√£o em stack

### Otimiza√ß√µes de Longo Prazo

**Poss√≠veis melhorias:**
- Cache inline para chamadas de m√©todo
- Compila√ß√£o JIT para caminhos de c√≥digo quentes
- Scheduler work-stealing para melhor concorr√™ncia
- Otimiza√ß√£o guiada por profile

---

## Diretrizes de Implementa√ß√£o

### Adicionando Novos Recursos

Ao implementar novos recursos, siga estas diretrizes:

**1. Escolha o m√≥dulo correto:**
- Novos tipos de valor ‚Üí `values.c`
- Convers√µes de tipo ‚Üí `types.c`
- Fun√ß√µes builtin ‚Üí `builtins.c`
- Opera√ß√µes I/O ‚Üí `io.c`
- Fluxo de controle ‚Üí `runtime.c`

**2. Atualize todas as camadas:**
- Adicione tipo de n√≥ AST se necess√°rio (`ast.h`, `ast.c`)
- Adicione token do lexer se necess√°rio (`lexer.c`)
- Adicione regras do parser (`parser.c`)
- Implemente comportamento runtime (`runtime.c` ou m√≥dulo apropriado)
- Adicione testes (`tests/`)

**3. Mantenha consist√™ncia:**
- Siga estilo de c√≥digo existente
- Use conven√ß√µes de nomenclatura consistentes
- Documente APIs p√∫blicas em headers
- Mantenha mensagens de erro claras e consistentes

**4. Teste completamente:**
- Adicione casos de teste antes de implementar
- Teste caminhos de sucesso e erro
- Teste casos de borda
- Verifique que n√£o h√° vazamentos de mem√≥ria (valgrind)

### Considera√ß√µes de Performance

**Gargalos atuais:**
- Busca em HashMap para acesso a vari√°veis
- Chamadas de fun√ß√£o recursivas (sem TCO)
- Concatena√ß√£o de strings (aloca nova string cada vez)
- Overhead de verifica√ß√£o de tipo por opera√ß√£o

**Oportunidades de otimiza√ß√£o:**
- Cache de localiza√ß√£o de vari√°veis (cache inline)
- Otimiza√ß√£o de tail call
- String builder para concatena√ß√£o
- Infer√™ncia de tipos para pular verifica√ß√µes runtime

### Dicas de Debug

**Ferramentas √∫teis:**
- `valgrind` - Detec√ß√£o de vazamento de mem√≥ria
- `gdb` - Debug de crashes
- Flag `-g` - S√≠mbolos de debug
- Debug com `printf` - Simples mas efetivo

**Problemas comuns:**
- Segfault ‚Üí Desrefer√™ncia de ponteiro nulo (verifique valores de retorno)
- Vazamento de mem√≥ria ‚Üí Chamada free() faltando (verifique caminhos de value_free)
- Erros de tipo ‚Üí Verifique l√≥gica de type_convert() e type_check()
- Crash em thread ‚Üí Condi√ß√£o de corrida (verifique uso de mutex)

---

## Resumo

A implementa√ß√£o do Hemlock prioriza:
- **Modularidade** - Separa√ß√£o clara de concerns
- **Simplicidade** - Implementa√ß√£o direta
- **Explicitude** - Sem m√°gica oculta
- **Manutenibilidade** - F√°cil de entender e modificar

O interpretador tree-walking atual √© intencionalmente simples para facilitar desenvolvimento r√°pido de recursos e experimenta√ß√£o. O backend do compilador futuro melhorar√° performance mantendo a mesma sem√¢ntica.


--------------------------------------------------------------------------------
## Sintaxe de Assinaturas
--------------------------------------------------------------------------------

# Design de Sintaxe de Assinaturas

> Estendendo o sistema de tipos do Hemlock com tipos de fun√ß√£o, modificadores nullable, aliases de tipo, par√¢metros const e assinaturas de m√©todo.

**Status:** Implementado (v1.7.0)
**Vers√£o:** 1.0
**Autor:** Claude

---

## Vis√£o Geral

Este documento prop√µe cinco extens√µes inter-relacionadas do sistema de tipos que se baseiam na infraestrutura existente do Hemlock:

1. **Anota√ß√µes de Tipo de Fun√ß√£o** - Tipos de fun√ß√£o de primeira classe
2. **Modificador de Tipo Nullable** - Tratamento expl√≠cito de null (estendendo flag `nullable` existente)
3. **Aliases de Tipo** - Abrevia√ß√µes de tipo nomeadas
4. **Par√¢metros Const** - Contratos de imutabilidade
5. **Assinaturas de M√©todo em Define** - Comportamento de interface

Estes recursos compartilham a mesma filosofia: **expl√≠cito √© melhor que impl√≠cito, opcional mas aplicado quando usado**.

---

## 1. Anota√ß√µes de Tipo de Fun√ß√£o

### Motiva√ß√£o

Atualmente, n√£o h√° como expressar a assinatura de uma fun√ß√£o como um tipo:

```hemlock
// Atual: callback n√£o tem informa√ß√£o de tipo
fn map(arr: array, callback) { ... }

// Proposto: tipo de fun√ß√£o expl√≠cito
fn map(arr: array, callback: fn(any, i32): any): array { ... }
```

### Sintaxe

```hemlock
// Tipo de fun√ß√£o b√°sico
fn(i32, i32): i32

// Com nomes de par√¢metros (apenas documenta√ß√£o, n√£o aplicado)
fn(a: i32, b: i32): i32

// Sem retorno (void)
fn(string): void
fn(string)              // Abrevia√ß√£o: omitir `: void`

// Retorno nullable
fn(i32): string?

// Par√¢metros opcionais
fn(name: string, age?: i32): void

// Par√¢metros rest
fn(...args: array): i32

// Sem par√¢metros
fn(): bool

// Alta ordem: fun√ß√£o que retorna fun√ß√£o
fn(i32): fn(i32): i32

// Tipo de fun√ß√£o async
async fn(i32): i32
```

### Exemplos de Uso

```hemlock
// Vari√°vel com tipo de fun√ß√£o
let add: fn(i32, i32): i32 = fn(a, b) { return a + b; };

// Par√¢metro de fun√ß√£o
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Tipo de retorno √© uma fun√ß√£o
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Array de fun√ß√µes
let ops: array<fn(i32, i32): i32> = [add, subtract, multiply];

// Campo de objeto
define EventHandler {
    name: string;
    callback: fn(Event): void;
}
```

### Mudan√ßas no AST

```c
// No enum TypeKind (include/ast.h)
typedef enum {
    // ... tipos existentes ...
    TYPE_FUNCTION,      // Novo: tipo de fun√ß√£o
} TypeKind;

// Na struct Type (include/ast.h)
struct Type {
    TypeKind kind;
    // ... campos existentes ...

    // Para TYPE_FUNCTION:
    struct Type **param_types;      // Tipos de par√¢metros
    char **param_names;             // Nomes de par√¢metros opcionais (documenta√ß√£o)
    int *param_optional;            // Quais par√¢metros s√£o opcionais
    int num_params;
    char *rest_param_name;          // Nome do par√¢metro rest ou NULL
    struct Type *rest_param_type;   // Tipo do par√¢metro rest
    struct Type *return_type;       // Tipo de retorno (NULL = void)
    int is_async;                   // Tipo fn async
};
```

### Parsing

Tipos de fun√ß√£o come√ßam com `fn` (ou `async fn`) seguido por lista de par√¢metros:

```
function_type := ["async"] "fn" "(" [param_type_list] ")" [":" type]
param_type_list := param_type ("," param_type)*
param_type := [identifier ":"] ["?"] type | "..." [identifier] [":" type]
```

**Desambigua√ß√£o:** Ao fazer parse de tipo e encontrar `fn`:
- Se seguido por `(`, √© um tipo de fun√ß√£o
- Caso contr√°rio, erro de sintaxe (`fn` isolado n√£o √© tipo v√°lido)

### Compatibilidade de Tipos

```hemlock
// Tipos de fun√ß√£o requerem correspond√™ncia exata
let f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // OK

// Contravari√¢ncia de par√¢metros (aceitar tipo mais amplo √© ok)
let g: fn(any): i32 = fn(x: i32): i32 { return x; };  // OK: i32 <: any

// Covari√¢ncia de retorno (retornar tipo mais estreito √© ok)
let h: fn(i32): any = fn(x: i32): i32 { return x; };  // OK: i32 <: any

// N√∫mero de par√¢metros deve corresponder
let bad: fn(i32): i32 = fn(a, b) { return a; };       // Erro: n√∫mero de par√¢metros n√£o corresponde

// Par√¢metros opcionais compat√≠veis com requeridos
let opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // OK
```

---

## 2. Modificador de Tipo Nullable

### Motiva√ß√£o

O sufixo `?` torna a aceita√ß√£o de null expl√≠cita nas assinaturas:

```hemlock
// Atual: n√£o est√° claro se null √© v√°lido
fn find(arr: array, val: any): i32 { ... }

// Proposto: retorno nullable expl√≠cito
fn find(arr: array, val: any): i32? { ... }
```

### Sintaxe

```hemlock
// Tipo nullable com sufixo ?
string?           // string ou null
i32?              // i32 ou null
User?             // User ou null
array<i32>?       // array ou null
fn(i32): i32?     // Fun√ß√£o que retorna i32 ou null

// Combina√ß√£o com tipos de fun√ß√£o
fn(string?): i32          // Aceita string ou null
fn(string): i32?          // Retorna i32 ou null
fn(string?): i32?         // Ambos nullable

// Em define
define Result {
    value: any?;
    error: string?;
}
```

### Notas de Implementa√ß√£o

**J√° existe:** Flag `Type.nullable` j√° existe no AST. Este recurso principalmente requer:
1. Suporte do parser para sufixo `?` em qualquer tipo (validar/estender)
2. Combina√ß√£o adequada com tipos de fun√ß√£o
3. Aplica√ß√£o em runtime

### Compatibilidade de Tipos

```hemlock
// N√£o-null pode ser atribu√≠do a nullable
let x: i32? = 42;           // OK
let y: i32? = null;         // OK

// Nullable n√£o pode ser atribu√≠do a n√£o-null
let z: i32 = x;             // Erro: x pode ser null

// Coalesc√™ncia de null para desempacotar
let z: i32 = x ?? 0;        // OK: ?? fornece valor padr√£o

// Encadeamento opcional retorna nullable
let name: string? = user?.name;
```

---

## 3. Aliases de Tipo

### Motiva√ß√£o

Tipos complexos se beneficiam de abrevia√ß√µes nomeadas:

```hemlock
// Atual: tipos compostos repetidos
fn process(entity: HasName & HasId & HasTimestamp) { ... }
fn validate(entity: HasName & HasId & HasTimestamp) { ... }

// Proposto: alias nomeado
type Entity = HasName & HasId & HasTimestamp;
fn process(entity: Entity) { ... }
fn validate(entity: Entity) { ... }
```

### Sintaxe

```hemlock
// Alias b√°sico
type Integer = i32;
type Text = string;

// Alias de tipo composto
type Entity = HasName & HasId;
type Auditable = HasCreatedAt & HasUpdatedAt & HasCreatedBy;

// Alias de tipo de fun√ß√£o
type Callback = fn(Event): void;
type Predicate = fn(any): bool;
type Reducer = fn(acc: any, val: any): any;
type AsyncTask = async fn(): any;

// Alias nullable
type OptionalString = string?;

// Alias gen√©rico (se suportarmos aliases de tipo gen√©ricos)
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };

// Alias de tipo array
type IntArray = array<i32>;
type Matrix = array<array<f64>>;
```

### Escopo e Visibilidade

```hemlock
// Escopo de m√≥dulo por padr√£o
type Callback = fn(Event): void;

// Export√°vel
export type Handler = fn(Request): Response;

// Em outro arquivo
import { Handler } from "./handlers.hml";
fn register(h: Handler) { ... }
```

### Mudan√ßas no AST

```c
// Novo tipo de statement
typedef enum {
    // ... statements existentes ...
    STMT_TYPE_ALIAS,    // Novo
} StmtKind;

// Na union Stmt
struct {
    char *name;                 // Nome do alias
    char **type_params;         // Par√¢metros gen√©ricos: <T, U>
    int num_type_params;
    Type *aliased_type;         // Tipo real
} type_alias;
```

### Parsing

```
type_alias := "type" identifier ["<" type_params ">"] "=" type ";"
```

**Nota:** `type` √© uma nova palavra-chave. Verificar conflitos com identificadores existentes.

### Resolu√ß√£o

Aliases de tipo s√£o resolvidos em:
- **Tempo de parse:** Alias √© registrado no ambiente de tipos
- **Tempo de verifica√ß√£o:** Alias √© expandido para tipo subjacente
- **Runtime:** Alias √© transparente (mesmo que tipo subjacente)

```hemlock
type MyInt = i32;
let x: MyInt = 42;
typeof(x);           // "i32" (n√£o "MyInt")
```

---

## 4. Par√¢metros Const

### Motiva√ß√£o

Expressar inten√ß√£o de imutabilidade nas assinaturas de fun√ß√£o:

```hemlock
// Atual: n√£o est√° claro se array ser√° modificado
fn print_all(items: array) { ... }

// Proposto: contrato de imutabilidade expl√≠cito
fn print_all(const items: array) { ... }
```

### Sintaxe

```hemlock
// Par√¢metro const
fn process(const data: buffer) {
    // data[0] = 0;        // Erro: n√£o pode modificar const
    let x = data[0];       // OK: leitura permitida
    return x;
}

// M√∫ltiplos par√¢metros const
fn compare(const a: array, const b: array): bool { ... }

// Misturando const e mut√°vel
fn update(const source: array, target: array) {
    for (item in source) {
        target.push(item);   // OK: target √© mut√°vel
    }
}

// Const com infer√™ncia de tipo
fn log(const msg) {
    print(msg);
}

// Const em tipo de fun√ß√£o
type Reader = fn(const buffer): i32;
```

### Opera√ß√µes que Const Impede

```hemlock
fn bad(const arr: array) {
    arr.push(1);         // Erro: m√©todo modificador
    arr.pop();           // Erro: m√©todo modificador
    arr[0] = 5;          // Erro: atribui√ß√£o por √≠ndice
    arr.clear();         // Erro: m√©todo modificador
}

fn ok(const arr: array) {
    let x = arr[0];      // OK: leitura
    let len = len(arr);  // OK: verificar comprimento
    let copy = arr.slice(0, 10);  // OK: cria novo array
    for (item in arr) {  // OK: itera√ß√£o
        print(item);
    }
}
```

### M√©todos Modificadores vs N√£o-Modificadores

| Tipo | Modificadores (bloqueados por const) | N√£o-Modificadores (permitidos) |
|------|--------------------------------------|--------------------------------|
| array | push, pop, shift, unshift, insert, remove, clear, reverse (in-place) | slice, concat, map, filter, find, contains, first, last, join |
| string | Atribui√ß√£o por √≠ndice (`s[0] = 'x'`) | Todos os m√©todos (retornam nova string) |
| buffer | Atribui√ß√£o por √≠ndice, memset, memcpy (destino) | Leitura por √≠ndice, slice |
| object | Atribui√ß√£o de campo | Leitura de campo |

### Mudan√ßas no AST

```c
// Na express√£o de fun√ß√£o (include/ast.h)
struct {
    // ... campos existentes ...
    int *param_is_const;    // Novo: 1 para const, 0 caso contr√°rio
} function;

// Na struct Type para tipo de fun√ß√£o
struct Type {
    // ... campos existentes ...
    int *param_is_const;    // Para TYPE_FUNCTION
};
```

### Aplica√ß√£o

**Interpretador:**
- Rastrear const-ness em binding de vari√°veis
- Verificar antes de opera√ß√µes modificadoras
- Erro runtime em viola√ß√£o de const

**Compilador:**
- Gerar vari√°veis C qualificadas com const quando ben√©fico
- An√°lise est√°tica para viola√ß√µes de const
- Avisos/erros em tempo de compila√ß√£o

---

## 5. Assinaturas de M√©todo em Define

### Motiva√ß√£o

Permitir que blocos `define` especifiquem m√©todos esperados, n√£o apenas campos de dados:

```hemlock
// Atual: apenas campos de dados
define User {
    name: string;
    age: i32;
}

// Proposto: assinaturas de m√©todo
define Comparable {
    fn compare(other: Self): i32;
}

define Serializable {
    fn serialize(): string;
    fn deserialize(data: string): Self;  // M√©todo est√°tico
}
```

### Sintaxe

```hemlock
// Assinatura de m√©todo (sem corpo)
define Hashable {
    fn hash(): i32;
}

// M√∫ltiplos m√©todos
define Collection {
    fn size(): i32;
    fn is_empty(): bool;
    fn contains(item: any): bool;
}

// Misturando campos e m√©todos
define Entity {
    id: i32;
    name: string;
    fn validate(): bool;
    fn serialize(): string;
}

// Usando tipo Self
define Cloneable {
    fn clone(): Self;
}

define Comparable {
    fn compare(other: Self): i32;
    fn equals(other: Self): bool;
}

// M√©todo opcional
define Printable {
    fn to_string(): string;
    fn debug_string?(): string;  // M√©todo opcional (pode n√£o existir)
}

// M√©todo com implementa√ß√£o padr√£o
define Ordered {
    fn compare(other: Self): i32;  // Requerido

    // Implementa√ß√£o padr√£o (herdada se n√£o sobrescrita)
    fn less_than(other: Self): bool {
        return self.compare(other) < 0;
    }
    fn greater_than(other: Self): bool {
        return self.compare(other) > 0;
    }
    fn equals(other: Self): bool {
        return self.compare(other) == 0;
    }
}
```

### Tipo `Self`

`Self` refere-se ao tipo concreto que implementa a interface:

```hemlock
define Addable {
    fn add(other: Self): Self;
}

// Ao usar:
let a: Addable = {
    value: 10,
    add: fn(other) {
        return { value: self.value + other.value, add: self.add };
    }
};
```

### Tipagem Estrutural (Duck Typing)

Assinaturas de m√©todo usam o mesmo duck typing que campos:

```hemlock
define Stringifiable {
    fn to_string(): string;
}

// Qualquer objeto com m√©todo to_string() satisfaz Stringifiable
let x: Stringifiable = {
    name: "test",
    to_string: fn() { return self.name; }
};

// Tipos compostos com m√©todos
define Named { name: string; }
define Printable { fn to_string(): string; }

type NamedPrintable = Named & Printable;

let y: NamedPrintable = {
    name: "Alice",
    to_string: fn() { return "Name: " + self.name; }
};
```

### Mudan√ßas no AST

```c
// Estendendo define_object na union Stmt
struct {
    char *name;
    char **type_params;
    int num_type_params;

    // Campos (existentes)
    char **field_names;
    Type **field_types;
    int *field_optional;
    Expr **field_defaults;
    int num_fields;

    // M√©todos (novos)
    char **method_names;
    Type **method_types;        // TYPE_FUNCTION
    int *method_optional;       // M√©todos opcionais (fn name?(): type)
    Expr **method_defaults;     // Implementa√ß√£o padr√£o (NULL se apenas assinatura)
    int num_methods;
} define_object;
```

### Verifica√ß√£o de Tipos

Ao verificar `value: InterfaceType`:
1. Verificar que todos os campos requeridos existem e tipos s√£o compat√≠veis
2. Verificar que todos os m√©todos requeridos existem e assinaturas s√£o compat√≠veis
3. Campos/m√©todos opcionais podem estar ausentes

```hemlock
define Sortable {
    fn compare(other: Self): i32;
}

// V√°lido: tem m√©todo compare
let valid: Sortable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};

// Inv√°lido: falta compare
let invalid: Sortable = { value: 10 };  // Erro: falta m√©todo 'compare'

// Inv√°lido: assinatura errada
let wrong: Sortable = {
    compare: fn() { return 0; }  // Erro: esperava (Self): i32
};
```

---

## Exemplos de Intera√ß√£o

### Combinando Todos os Recursos

```hemlock
// Alias de tipo para tipo de fun√ß√£o complexo
type EventCallback = fn(event: Event, context: Context?): bool;

// Alias de tipo para interface composta
type Entity = HasId & HasName & Serializable;

// Define com assinaturas de m√©todo
define Repository<T> {
    fn find(id: i32): T?;
    fn save(const entity: T): bool;
    fn delete(id: i32): bool;
    fn find_all(predicate: fn(T): bool): array<T>;
}

// Usando tudo junto
fn create_user_repo(): Repository<User> {
    let users: array<User> = [];

    return {
        find: fn(id) {
            for (u in users) {
                if (u.id == id) { return u; }
            }
            return null;
        },
        save: fn(const entity) {
            users.push(entity);
            return true;
        },
        delete: fn(id) {
            // ...
            return true;
        },
        find_all: fn(predicate) {
            return users.filter(predicate);
        }
    };
}
```

### Callbacks com Tipos Expl√≠citos

```hemlock
type ClickHandler = fn(event: MouseEvent): void;
type KeyHandler = fn(event: KeyEvent, modifiers: i32): bool;

define Widget {
    x: i32;
    y: i32;
    on_click: ClickHandler?;
    on_key: KeyHandler?;
}

fn create_button(label: string, handler: ClickHandler): Widget {
    return {
        x: 0, y: 0,
        on_click: handler,
        on_key: null
    };
}
```

### Tipos de Fun√ß√£o Nullable

```hemlock
// Callback opcional
fn fetch(url: string, on_complete: fn(Response): void?): void {
    let response = http_get(url);
    if (on_complete != null) {
        on_complete(response);
    }
}

// Retorno nullable de tipo de fun√ß√£o
type Parser = fn(input: string): AST?;

fn try_parse(parsers: array<Parser>, input: string): AST? {
    for (p in parsers) {
        let result = p(input);
        if (result != null) {
            return result;
        }
    }
    return null;
}
```

---

## Roteiro de Implementa√ß√£o

### Fase 1: Infraestrutura Core
1. Adicionar `TYPE_FUNCTION` ao enum TypeKind
2. Estender struct Type com campos de tipo de fun√ß√£o
3. Adicionar `CHECKED_FUNCTION` ao type checker do compilador
4. Adicionar suporte a tipo `Self` (TYPE_SELF)

### Fase 2: Parsing
1. Implementar `parse_function_type()` no parser
2. Tratar `fn(...)` em posi√ß√£o de tipo
3. Adicionar palavra-chave `type` e parsing de `STMT_TYPE_ALIAS`
4. Adicionar parsing de modificador de par√¢metro `const`
5. Estender parsing de define para suportar assinaturas de m√©todo

### Fase 3: Verifica√ß√£o de Tipos
1. Regras de compatibilidade de tipos de fun√ß√£o
2. Resolu√ß√£o e expans√£o de aliases de tipo
3. Verifica√ß√£o de modifica√ß√£o de par√¢metros const
4. Valida√ß√£o de assinatura de m√©todo em tipos define
5. Resolu√ß√£o de tipo Self

### Fase 4: Runtime
1. Valida√ß√£o de tipo de fun√ß√£o em ponto de chamada
2. Detec√ß√£o de viola√ß√£o de const
3. Transpar√™ncia de alias de tipo

### Fase 5: Testes de Paridade
1. Testes de anota√ß√£o de tipo de fun√ß√£o
2. Testes de combina√ß√£o nullable
3. Testes de alias de tipo
4. Testes de par√¢metros const
5. Testes de assinatura de m√©todo

---

## Decis√µes de Design

### 1. Aliases de Tipo Gen√©ricos: **Sim**

Aliases de tipo suportam par√¢metros gen√©ricos:

```hemlock
// Aliases de tipo gen√©ricos
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };
type Mapper<T, U> = fn(T): U;
type AsyncResult<T> = async fn(): T?;

// Uso
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
let result: Result<User, string> = { value: user, error: null };
let transform: Mapper<i32, string> = fn(n) { return n.to_string(); };
```

### 2. Propaga√ß√£o de Const: **Profunda**

Par√¢metros const s√£o totalmente imut√°veis - n√£o podem ser modificados por nenhum caminho:

```hemlock
fn process(const arr: array<object>) {
    arr.push({});        // Erro: n√£o pode modificar array const
    arr[0] = {};         // Erro: n√£o pode modificar array const
    arr[0].x = 5;        // Erro: n√£o pode modificar atrav√©s de const (profundo)

    let x = arr[0].x;    // OK: leitura √© permitida
    let copy = arr[0];   // OK: criar c√≥pia
    copy.x = 5;          // OK: c√≥pia n√£o √© const
}

fn nested(const obj: object) {
    obj.user.name = "x"; // Erro: const profundo impede modifica√ß√£o aninhada
    obj.items[0] = 1;    // Erro: const profundo impede modifica√ß√£o aninhada
}
```

**Justificativa:** Const profundo fornece garantias mais fortes e √© mais √∫til para garantir integridade de dados. Se voc√™ precisa modificar dados aninhados, fa√ßa uma c√≥pia primeiro.

### 3. Self em Aliases de Tipo Standalone: **N√£o**

`Self` s√≥ √© v√°lido dentro de blocos `define` onde tem significado claro:

```hemlock
// V√°lido: Self refere-se ao tipo definido
define Comparable {
    fn compare(other: Self): i32;
}

// Inv√°lido: Self n√£o tem significado aqui
type Cloner = fn(Self): Self;  // Erro: Self fora de contexto define

// Use gen√©rico em vez disso:
type Cloner<T> = fn(T): T;
```

### 4. Implementa√ß√µes Padr√£o de M√©todo: **Sim (apenas simples)**

Permitir implementa√ß√£o padr√£o para m√©todos simples/utilit√°rios:

```hemlock
define Comparable {
    // Requerido: deve ser implementado
    fn compare(other: Self): i32;

    // Implementa√ß√£o padr√£o (m√©todos de conveni√™ncia simples)
    fn equals(other: Self): bool {
        return self.compare(other) == 0;
    }
    fn less_than(other: Self): bool {
        return self.compare(other) < 0;
    }
    fn greater_than(other: Self): bool {
        return self.compare(other) > 0;
    }
}

define Printable {
    fn to_string(): string;

    // Padr√£o: delegar para m√©todo requerido
    fn print() {
        print(self.to_string());
    }
    fn println() {
        print(self.to_string() + "\n");
    }
}

// Objetos s√≥ precisam implementar m√©todos requeridos
let item: Comparable = {
    value: 42,
    compare: fn(other) { return self.value - other.value; }
    // equals, less_than, greater_than herdados dos padr√µes
};

item.less_than({ value: 50, compare: item.compare });  // true
```

**Diretrizes para implementa√ß√µes padr√£o:**
- Manter simples (1-3 linhas)
- Devem delegar para m√©todos requeridos
- Sem l√≥gica complexa ou efeitos colaterais
- Apenas tipos primitivos e composi√ß√£o direta

### 5. Vari√¢ncia: **Inferida (sem anota√ß√µes expl√≠citas)**

Vari√¢ncia √© inferida com base em como par√¢metros de tipo s√£o usados:

```hemlock
// Vari√¢ncia determinada automaticamente pela posi√ß√£o
type Producer<T> = fn(): T;           // T em posi√ß√£o de retorno = covariante
type Consumer<T> = fn(T): void;       // T em posi√ß√£o de par√¢metro = contravariante
type Transformer<T> = fn(T): T;       // T em ambas posi√ß√µes = invariante

// Exemplo: Dog <: Animal (Dog √© subtipo de Animal)
let dog_producer: Producer<Dog> = fn() { return new_dog(); };
let animal_producer: Producer<Animal> = dog_producer;  // OK: covariante

let animal_consumer: Consumer<Animal> = fn(a) { print(a); };
let dog_consumer: Consumer<Dog> = animal_consumer;     // OK: contravariante
```

**Por que inferida?**
- Menos boilerplate (`<out T>` / `<in T>` adiciona ru√≠do)
- Segue "expl√≠cito √© melhor que impl√≠cito" - a posi√ß√£o em si √© expl√≠cita
- Consistente com como a maioria das linguagens trata vari√¢ncia de tipo de fun√ß√£o
- Erros claros quando regras de vari√¢ncia s√£o violadas

---

## Ap√™ndice: Mudan√ßas de Sintaxe

```ebnf
(* Tipos *)
type := simple_type | compound_type | function_type
simple_type := base_type ["?"] | identifier ["<" type_args ">"] ["?"]
compound_type := simple_type ("&" simple_type)+
function_type := ["async"] "fn" "(" [param_types] ")" [":" type]

base_type := "i8" | "i16" | "i32" | "i64"
           | "u8" | "u16" | "u32" | "u64"
           | "f32" | "f64" | "bool" | "string" | "rune"
           | "ptr" | "buffer" | "void" | "null"
           | "array" ["<" type ">"]
           | "object"
           | "Self"

param_types := param_type ("," param_type)*
param_type := ["const"] [identifier ":"] ["?"] type
            | "..." [identifier] [":" type]

type_args := type ("," type)*

(* Statements *)
type_alias := "type" identifier ["<" type_params ">"] "=" type ";"

define_stmt := "define" identifier ["<" type_params ">"] "{" define_members "}"
define_members := (field_def | method_def)*
field_def := identifier (":" type ["=" expr] | "?:" (type | expr)) ";"?
method_def := "fn" identifier ["?"] "(" [param_types] ")" [":" type] (block | ";")
            (* "?" marca m√©todo opcional, block fornece implementa√ß√£o padr√£o *)

(* Par√¢metros *)
param := ["const"] ["ref"] identifier [":" type] ["?:" expr]
       | "..." identifier [":" type]
```



################################################################################
# CONTRIBUI√á√ÉO
################################################################################

--------------------------------------------------------------------------------
## Diretrizes
--------------------------------------------------------------------------------

# Diretrizes de Contribui√ß√£o do Hemlock

Obrigado pelo seu interesse em contribuir para o Hemlock! Este guia ajudar√° voc√™ a entender como contribuir c√≥digo de forma efetiva, mantendo a filosofia de design e qualidade de c√≥digo da linguagem.

---

## Sum√°rio

- [Antes de Come√ßar](#antes-de-come√ßar)
- [Fluxo de Trabalho de Contribui√ß√£o](#fluxo-de-trabalho-de-contribui√ß√£o)
- [Guia de Estilo de C√≥digo](#guia-de-estilo-de-c√≥digo)
- [O que Contribuir](#o-que-contribuir)
- [O que N√£o Contribuir](#o-que-n√£o-contribuir)
- [Padr√µes Comuns](#padr√µes-comuns)
- [Adicionando Novos Recursos](#adicionando-novos-recursos)
- [Processo de Code Review](#processo-de-code-review)

---

## Antes de Come√ßar

### Documenta√ß√£o Obrigat√≥ria

Antes de contribuir, por favor leia os seguintes documentos na ordem:

1. **`/home/user/hemlock/docs/design/philosophy.md`** - Entender os princ√≠pios centrais do Hemlock
2. **`/home/user/hemlock/docs/design/implementation.md`** - Aprender a estrutura do c√≥digo
3. **`/home/user/hemlock/docs/contributing/testing.md`** - Entender os requisitos de teste
4. **Este documento** - Aprender as diretrizes de contribui√ß√£o

### Pr√©-requisitos

**Conhecimento necess√°rio:**
- Programa√ß√£o C (ponteiros, gerenciamento de mem√≥ria, structs)
- Fundamentos de compiladores/interpretadores (an√°lise l√©xica, sint√°tica, AST)
- Fluxo de trabalho Git e GitHub
- Linha de comando Unix/Linux

**Ferramentas necess√°rias:**
- Compilador GCC ou Clang
- Sistema de build Make
- Controle de vers√£o Git
- Valgrind (para detec√ß√£o de vazamento de mem√≥ria)
- Editor de texto ou IDE b√°sico

### Canais de Comunica√ß√£o

**Onde perguntar:**
- GitHub Issues - Relat√≥rios de bug e solicita√ß√µes de recursos
- GitHub Discussions - Perguntas gerais e discuss√µes de design
- Coment√°rios em Pull Request - Feedback espec√≠fico de c√≥digo

---

## Fluxo de Trabalho de Contribui√ß√£o

### 1. Encontrar ou Criar uma Issue

**Antes de escrever c√≥digo:**
- Verificar se j√° existe uma issue relacionada √† sua contribui√ß√£o
- Se n√£o existir, criar uma issue descrevendo o que voc√™ quer fazer
- Esperar feedback dos mantenedores antes de come√ßar grandes mudan√ßas
- Pequenas corre√ß√µes de bugs podem pular esta etapa

**Uma boa descri√ß√£o de issue inclui:**
- Declara√ß√£o do problema (o que est√° quebrado ou faltando)
- Solu√ß√£o proposta (como voc√™ planeja corrigir)
- Exemplos (trechos de c√≥digo mostrando o problema)
- Justificativa (por que esta mudan√ßa est√° alinhada com a filosofia do Hemlock)

### 2. Fork e Clone

```bash
# Primeiro fa√ßa fork do reposit√≥rio no GitHub, ent√£o:
git clone https://github.com/SEU_USUARIO/hemlock.git
cd hemlock
git checkout -b feature/nome-do-seu-recurso
```

### 3. Fazer Mudan√ßas

Siga estas diretrizes:
- Escrever testes primeiro (abordagem TDD)
- Implementar o recurso
- Garantir que todos os testes passem
- Verificar vazamentos de mem√≥ria
- Atualizar documenta√ß√£o

### 4. Testar Suas Mudan√ßas

```bash
# Executar su√≠te de testes completa
make test

# Executar categoria espec√≠fica de testes
./tests/run_tests.sh tests/category/

# Verificar vazamentos de mem√≥ria
valgrind ./hemlock tests/your_test.hml

# Build e teste
make clean && make && make test
```

### 5. Commitar Suas Mudan√ßas

**Boas mensagens de commit:**
```
Add bitwise operators for integer types

- Implement &, |, ^, <<, >>, ~ operators
- Add type checking to ensure integer-only operations
- Update operator precedence table
- Add comprehensive tests for all operators

Closes #42
```

**Formato da mensagem de commit:**
- Primeira linha: resumo curto (m√°ximo 50 caracteres)
- Linha em branco
- Descri√ß√£o detalhada (quebra de linha em 72 caracteres)
- Referenciar n√∫mero da issue

### 6. Submeter Pull Request

**Antes de submeter:**
- Rebase no main mais recente
- Garantir que todos os testes passam
- Executar valgrind para verificar vazamentos
- Atualizar CLAUDE.md se adicionar recursos voltados ao usu√°rio

**A descri√ß√£o do pull request deve incluir:**
- Que problema isso resolve
- Como foi resolvido
- Breaking changes (se houver)
- Exemplos de nova sintaxe ou comportamento
- Resumo da cobertura de testes

---

## Guia de Estilo de C√≥digo

### Estilo de C√≥digo C

**Formata√ß√£o:**
```c
// Use 4 espa√ßos para indenta√ß√£o (n√£o tabs)
// Estilo K&R para chaves em fun√ß√µes
void function_name(int arg1, char *arg2)
{
    if (condition) {
        // Chaves de estruturas de controle na mesma linha
        do_something();
    }
}

// Comprimento de linha: m√°ximo 100 caracteres
// Espa√ßos ao redor de operadores
int result = (a + b) * c;

// Asterisco de ponteiro junto ao tipo
char *string;   // Correto
char* string;   // Evitar
char * string;  // Evitar
```

**Conven√ß√µes de Nomenclatura:**
```c
// Fun√ß√µes: min√∫sculas com underscores
void eval_expression(ASTNode *node);

// Tipos: PascalCase
typedef struct Value Value;
typedef enum ValueType ValueType;

// Constantes: mai√∫sculas com underscores
#define MAX_BUFFER_SIZE 4096

// Vari√°veis: min√∫sculas com underscores
int item_count;
Value *current_value;

// Enums: TYPE_PREFIX_NAME
typedef enum {
    TYPE_I32,
    TYPE_STRING,
    TYPE_OBJECT
} ValueType;
```

**Coment√°rios:**
```c
// Coment√°rios de linha √∫nica para explica√ß√µes breves
// Use frases completas e capitaliza√ß√£o correta

/*
 * Coment√°rios de m√∫ltiplas linhas para explica√ß√µes mais longas
 * Alinhe os asteriscos para melhor legibilidade
 */

/**
 * Coment√°rio de documenta√ß√£o de fun√ß√£o
 * @param node - N√≥ AST a ser avaliado
 * @return Valor avaliado
 */
Value eval_expr(ASTNode *node);
```

**Tratamento de Erros:**
```c
// Verificar todas as chamadas malloc
char *buffer = malloc(size);
if (!buffer) {
    fprintf(stderr, "Error: Out of memory\n");
    exit(1);
}

// Fornecer contexto nas mensagens de erro
if (file == NULL) {
    fprintf(stderr, "Error: Failed to open '%s': %s\n",
            filename, strerror(errno));
    exit(1);
}

// Usar mensagens de erro significativas
// Ruim: Error: Invalid value
// Bom: Error: Expected integer, got string
```

**Gerenciamento de Mem√≥ria:**
```c
// Sempre liberar mem√≥ria que voc√™ alocou
Value *val = value_create_i32(42);
// ... usar val
value_free(val);

// Definir ponteiros como NULL ap√≥s liberar (previne double free)
free(ptr);
ptr = NULL;

// Documentar ownership em coment√°rios
// Esta fun√ß√£o assume ownership de 'value' e ir√° liber√°-lo
void store_value(Value *value);

// Esta fun√ß√£o n√£o assume ownership (chamador deve liberar)
Value *get_value(void);
```

### Organiza√ß√£o de C√≥digo

**Estrutura de Arquivos:**
```c
// 1. Includes (headers de sistema primeiro, depois locais)
#include <stdio.h>
#include <stdlib.h>
#include "internal.h"
#include "values.h"

// 2. Constantes e macros
#define INITIAL_CAPACITY 16

// 3. Defini√ß√µes de tipos
typedef struct Foo Foo;

// 4. Declara√ß√µes de fun√ß√µes est√°ticas (helpers internos)
static void helper_function(void);

// 5. Implementa√ß√£o de fun√ß√µes p√∫blicas
void public_api_function(void)
{
    // Implementa√ß√£o
}

// 6. Implementa√ß√£o de fun√ß√µes est√°ticas
static void helper_function(void)
{
    // Implementa√ß√£o
}
```

**Arquivos Header:**
```c
// Usar include guards
#ifndef HEMLOCK_MODULE_H
#define HEMLOCK_MODULE_H

// Declara√ß√µes forward
typedef struct Value Value;

// Apenas API p√∫blica em headers
void public_function(Value *val);

// Documentar par√¢metros e valores de retorno
/**
 * Avalia n√≥ AST de express√£o
 * @param node - N√≥ AST a ser avaliado
 * @param env - Ambiente atual
 * @return Valor resultante
 */
Value *eval_expr(ASTNode *node, Environment *env);

#endif // HEMLOCK_MODULE_H
```

---

## O que Contribuir

### Contribui√ß√µes Encorajadas

**Corre√ß√µes de Bugs:**
- Vazamentos de mem√≥ria
- Segfaults
- Comportamento incorreto
- Melhorias em mensagens de erro

**Documenta√ß√£o:**
- Coment√°rios de c√≥digo
- Documenta√ß√£o de API
- Guias de usu√°rio e tutoriais
- Programas de exemplo
- Documenta√ß√£o de casos de teste

**Testes:**
- Casos de teste adicionais para recursos existentes
- Cobertura de casos de borda
- Testes de regress√£o para bugs corrigidos
- Benchmarks de performance

**Pequenas Adi√ß√µes de Recursos:**
- Novas fun√ß√µes builtin (se alinhadas com a filosofia)
- M√©todos de string/array
- Fun√ß√µes utilit√°rias
- Melhorias no tratamento de erros

**Melhorias de Performance:**
- Algoritmos mais r√°pidos (sem mudar sem√¢ntica)
- Redu√ß√£o de uso de mem√≥ria
- Su√≠te de benchmarks
- Ferramentas de profiling

**Ferramentas:**
- Syntax highlighting para editores
- Language Server Protocol (LSP)
- Integra√ß√£o com debugger
- Melhorias no sistema de build

### Discutir Primeiro

**Recursos Maiores:**
- Novas constru√ß√µes de linguagem
- Mudan√ßas no sistema de tipos
- Adi√ß√µes de sintaxe
- Primitivas de concorr√™ncia

**Como Discutir:**
1. Abrir issue ou discussion no GitHub
2. Descrever o recurso e justificativa
3. Mostrar c√≥digo de exemplo
4. Explicar como se alinha com a filosofia do Hemlock
5. Aguardar feedback dos mantenedores
6. Iterar no design antes de implementar

---

## O que N√£o Contribuir

### Contribui√ß√µes Desencorajadas

**N√£o adicione recursos que:**
- Escondem complexidade do usu√°rio
- Tornam comportamento impl√≠cito ou m√°gico
- Quebram sem√¢ntica ou sintaxe existente
- Adicionam coleta de lixo ou gerenciamento autom√°tico de mem√≥ria
- Violam o princ√≠pio "expl√≠cito √© melhor que impl√≠cito"

**Exemplos de contribui√ß√µes que ser√£o rejeitadas:**

**1. Inser√ß√£o Autom√°tica de Ponto e V√≠rgula**
```hemlock
// Ruim: isso ser√° rejeitado
let x = 5  // Sem ponto e v√≠rgula
let y = 10 // Sem ponto e v√≠rgula
```
Motivo: Torna sintaxe amb√≠gua, esconde erros

**2. RAII/Destrutores**
```hemlock
// Ruim: isso ser√° rejeitado
let f = open("file.txt");
// Arquivo fechado automaticamente ao sair do escopo
```
Motivo: Esconde quando recursos s√£o liberados, n√£o √© expl√≠cito o suficiente

**3. Convers√µes de Tipo Impl√≠citas com Perda de Dados**
```hemlock
// Ruim: isso ser√° rejeitado
let x: i32 = 3.14;  // Trunca silenciosamente para 3
```
Motivo: Perda de dados deveria ser expl√≠cita, n√£o silenciosa

**4. Coleta de Lixo**
```c
// Ruim: isso ser√° rejeitado
void *gc_malloc(size_t size) {
    // Rastrear aloca√ß√µes para limpeza autom√°tica
}
```
Motivo: Esconde gerenciamento de mem√≥ria, performance imprevis√≠vel

**5. Sistema de Macros Complexo**
```hemlock
// Ruim: isso ser√° rejeitado
macro repeat($n, $block) {
    for (let i = 0; i < $n; i++) $block
}
```
Motivo: Muita m√°gica, torna c√≥digo dif√≠cil de raciocinar

### Motivos Comuns de Rejei√ß√£o

**"Isso √© muito impl√≠cito"**
- Solu√ß√£o: Tornar comportamento expl√≠cito e documentar

**"Isso esconde complexidade"**
- Solu√ß√£o: Expor complexidade mas torn√°-la ergon√¥mica

**"Isso quebra c√≥digo existente"**
- Solu√ß√£o: Encontrar alternativa n√£o-breaking ou discutir versionamento

**"Isso n√£o se alinha com a filosofia do Hemlock"**
- Solu√ß√£o: Reler philosophy.md e reconsiderar abordagem

---

## Padr√µes Comuns

### Padr√£o de Tratamento de Erros

```c
// Use este padr√£o para erros recuper√°veis em c√≥digo Hemlock
Value *divide(Value *a, Value *b)
{
    // Verificar pr√©-condi√ß√µes
    if (b->type != TYPE_I32) {
        // Retornar valor de erro ou lan√ßar exce√ß√£o
        return create_error("Expected integer divisor");
    }

    if (b->i32_value == 0) {
        return create_error("Division by zero");
    }

    // Executar opera√ß√£o
    return value_create_i32(a->i32_value / b->i32_value);
}
```

### Padr√£o de Gerenciamento de Mem√≥ria

```c
// Padr√£o: alocar, usar, liberar
void process_data(void)
{
    // Alocar
    Buffer *buf = create_buffer(1024);
    char *str = malloc(256);

    // Usar
    if (buf && str) {
        // ... fazer trabalho
    }

    // Liberar (na ordem reversa da aloca√ß√£o)
    free(str);
    free_buffer(buf);
}
```

### Padr√£o de Cria√ß√£o de Valores

```c
// Usar construtores para criar valores
Value *create_integer(int32_t n)
{
    Value *val = malloc(sizeof(Value));
    if (!val) {
        fprintf(stderr, "Out of memory\n");
        exit(1);
    }

    val->type = TYPE_I32;
    val->i32_value = n;
    return val;
}
```

### Padr√£o de Verifica√ß√£o de Tipos

```c
// Verificar tipos antes de opera√ß√µes
Value *add_values(Value *a, Value *b)
{
    // Verifica√ß√£o de tipos
    if (a->type != TYPE_I32 || b->type != TYPE_I32) {
        return create_error("Type mismatch");
    }

    // Pode prosseguir com seguran√ßa
    return value_create_i32(a->i32_value + b->i32_value);
}
```

### Padr√£o de Constru√ß√£o de Strings

```c
// Construir strings eficientemente
void build_error_message(char *buffer, size_t size, const char *detail)
{
    snprintf(buffer, size, "Error: %s (line %d)", detail, line_number);
}
```

---

## Adicionando Novos Recursos

### Checklist de Adi√ß√£o de Recursos

Ao adicionar um novo recurso, por favor siga estes passos:

#### 1. Fase de Design

- [ ] Ler philosophy.md para garantir alinhamento
- [ ] Criar issue no GitHub descrevendo o recurso
- [ ] Obter aprova√ß√£o dos mantenedores no design
- [ ] Escrever especifica√ß√£o (sintaxe, sem√¢ntica, exemplos)
- [ ] Considerar casos de borda e condi√ß√µes de erro

#### 2. Fase de Implementa√ß√£o

**Se adicionando constru√ß√£o de linguagem:**

- [ ] Adicionar tipo de token em `lexer.h` (se necess√°rio)
- [ ] Adicionar regra l√©xica em `lexer.c` (se necess√°rio)
- [ ] Adicionar tipo de n√≥ AST em `ast.h`
- [ ] Adicionar construtor AST em `ast.c`
- [ ] Adicionar regra de parsing em `parser.c`
- [ ] Adicionar comportamento runtime em `runtime.c` ou m√≥dulo apropriado
- [ ] Tratar limpeza em fun√ß√µes de libera√ß√£o de AST

**Se adicionando fun√ß√£o builtin:**

- [ ] Adicionar implementa√ß√£o da fun√ß√£o em `builtins.c`
- [ ] Registrar fun√ß√£o em `register_builtins()`
- [ ] Tratar todas as combina√ß√µes de tipos de argumentos
- [ ] Retornar valores de erro apropriados
- [ ] Documentar par√¢metros e tipos de retorno

**Se adicionando tipo de valor:**

- [ ] Adicionar enum de tipo em `values.h`
- [ ] Adicionar campo √† union Value
- [ ] Adicionar construtor em `values.c`
- [ ] Adicionar a `value_free()` para limpeza
- [ ] Adicionar a `value_copy()` para c√≥pia
- [ ] Adicionar a `value_to_string()` para impress√£o
- [ ] Adicionar regras de promo√ß√£o de tipo se num√©rico

#### 3. Fase de Testes

- [ ] Escrever casos de teste (veja testing.md)
- [ ] Testar casos de sucesso
- [ ] Testar casos de erro
- [ ] Testar casos de borda
- [ ] Executar su√≠te de testes completa (`make test`)
- [ ] Verificar vazamentos de mem√≥ria com valgrind
- [ ] Testar em m√∫ltiplas plataformas (se poss√≠vel)

#### 4. Fase de Documenta√ß√£o

- [ ] Atualizar CLAUDE.md com documenta√ß√£o voltada ao usu√°rio
- [ ] Adicionar coment√°rios de c√≥digo explicando implementa√ß√£o
- [ ] Criar exemplos em `examples/`
- [ ] Atualizar arquivos docs/ relevantes
- [ ] Documentar quaisquer breaking changes

#### 5. Fase de Submiss√£o

- [ ] Limpar c√≥digo de debug e coment√°rios
- [ ] Verificar conformidade com estilo de c√≥digo
- [ ] Rebase no main mais recente
- [ ] Criar pull request com descri√ß√£o detalhada
- [ ] Responder ao feedback do code review

### Exemplo: Adicionando Novo Operador

Vamos usar o exemplo de adicionar o operador m√≥dulo `%`:

**1. Lexer (lexer.c):**
```c
// Adicionar ao switch statement em get_next_token()
case '%':
    return create_token(TOKEN_PERCENT, "%", line);
```

**2. Header do Lexer (lexer.h):**
```c
typedef enum {
    // ... tokens existentes
    TOKEN_PERCENT,
    // ...
} TokenType;
```

**3. AST (ast.h):**
```c
typedef enum {
    // ... operadores existentes
    OP_MOD,
    // ...
} BinaryOp;
```

**4. Parser (parser.c):**
```c
// Adicionar a parse_multiplicative() ou n√≠vel de preced√™ncia apropriado
if (match(TOKEN_PERCENT)) {
    BinaryOp op = OP_MOD;
    ASTNode *right = parse_unary();
    left = create_binary_op_node(op, left, right);
}
```

**5. Runtime (runtime.c):**
```c
// Adicionar a eval_binary_op()
case OP_MOD:
    // Verifica√ß√£o de tipos
    if (left->type == TYPE_I32 && right->type == TYPE_I32) {
        if (right->i32_value == 0) {
            fprintf(stderr, "Error: Modulo by zero\n");
            exit(1);
        }
        return value_create_i32(left->i32_value % right->i32_value);
    }
    // ... tratar outras combina√ß√µes de tipos
    break;
```

**6. Teste (tests/operators/modulo.hml):**
```hemlock
// M√≥dulo b√°sico
print(10 % 3);  // Expect: 2

// M√≥dulo com negativos
print(-10 % 3); // Expect: -1

// Caso de erro (deveria falhar)
// print(10 % 0);  // Divis√£o por zero
```

**7. Documenta√ß√£o (CLAUDE.md):**
```markdown
### Operadores Aritm√©ticos
- `+` - Adi√ß√£o
- `-` - Subtra√ß√£o
- `*` - Multiplica√ß√£o
- `/` - Divis√£o
- `%` - M√≥dulo (resto)
```

---

## Processo de Code Review

### O que os Revisores Procuram

**1. Corretude**
- O c√≥digo faz o que diz fazer?
- Casos de borda s√£o tratados?
- H√° vazamentos de mem√≥ria?
- Erros s√£o tratados corretamente?

**2. Alinhamento com Filosofia**
- Isso est√° alinhado com os princ√≠pios de design do Hemlock?
- √â expl√≠cito ou impl√≠cito?
- Esconde complexidade?

**3. Qualidade de C√≥digo**
- O c√≥digo √© leg√≠vel e manuten√≠vel?
- Nomes de vari√°veis s√£o descritivos?
- Fun√ß√µes t√™m tamanho razo√°vel?
- H√° documenta√ß√£o suficiente?

**4. Testes**
- H√° casos de teste suficientes?
- Testes cobrem caminhos de sucesso e falha?
- Casos de borda s√£o testados?

**5. Documenta√ß√£o**
- Documenta√ß√£o voltada ao usu√°rio est√° atualizada?
- Coment√°rios de c√≥digo s√£o claros?
- Exemplos s√£o fornecidos?

### Respondendo ao Feedback

**Fa√ßa:**
- Agradecer o tempo do revisor
- Fazer perguntas de esclarecimento se n√£o entender
- Explicar seu racioc√≠nio se discordar
- Fazer mudan√ßas solicitadas prontamente
- Atualizar descri√ß√£o do PR se escopo mudar

**N√£o fa√ßa:**
- Levar cr√≠ticas para o lado pessoal
- Argumentar defensivamente
- Ignorar feedback
- Fazer force push em coment√°rios de review (exceto rebase)
- Adicionar mudan√ßas n√£o relacionadas ao PR

### Fazendo Seu PR Ser Aceito

**Requisitos para merge:**
- [ ] Todos os testes passam
- [ ] Sem vazamentos de mem√≥ria (valgrind limpo)
- [ ] Aprova√ß√£o de code review do mantenedor
- [ ] Documenta√ß√£o atualizada
- [ ] Guia de estilo de c√≥digo seguido
- [ ] Alinhado com a filosofia do Hemlock

**Timeline:**
- PRs pequenos (corre√ß√µes de bugs): Geralmente revisados em poucos dias
- PRs m√©dios (novos recursos): Pode levar 1-2 semanas
- PRs grandes (mudan√ßas maiores): Requer discuss√£o extensa

---

## Recursos Adicionais

### Recursos de Aprendizado

**Entendendo Interpretadores:**
- "Crafting Interpreters" por Robert Nystrom
- "Writing An Interpreter In Go" por Thorsten Ball
- "Modern Compiler Implementation in C" por Andrew Appel

**Programa√ß√£o C:**
- "The C Programming Language" por K&R
- "Expert C Programming" por Peter van der Linden
- "C Interfaces and Implementations" por David Hanson

**Gerenciamento de Mem√≥ria:**
- Documenta√ß√£o do Valgrind
- "Understanding and Using C Pointers" por Richard Reese

### Comandos √öteis

```bash
# Build com s√≠mbolos de debug
make clean && make CFLAGS="-g -O0"

# Executar com valgrind
valgrind --leak-check=full ./hemlock script.hml

# Executar categoria espec√≠fica de testes
./tests/run_tests.sh tests/strings/

# Gerar arquivo tags para navega√ß√£o de c√≥digo
ctags -R .

# Encontrar todos os TODO e FIXME
grep -rn "TODO\|FIXME" src/ include/
```

---

## D√∫vidas?

Se voc√™ tem perguntas sobre contribuir:

1. Verificar documenta√ß√£o em `docs/`
2. Pesquisar issues existentes no GitHub
3. Perguntar no GitHub Discussions
4. Abrir uma nova issue com sua pergunta

**Obrigado por contribuir para o Hemlock!**


--------------------------------------------------------------------------------
## Testes
--------------------------------------------------------------------------------

# Guia de Testes do Hemlock

Este guia explica a filosofia de testes do Hemlock, como escrever testes e como executar a su√≠te de testes.

---

## Sum√°rio

- [Filosofia de Testes](#filosofia-de-testes)
- [Estrutura da Su√≠te de Testes](#estrutura-da-su√≠te-de-testes)
- [Executando Testes](#executando-testes)
- [Escrevendo Testes](#escrevendo-testes)
- [Categorias de Testes](#categorias-de-testes)
- [Testes de Vazamento de Mem√≥ria](#testes-de-vazamento-de-mem√≥ria)
- [Integra√ß√£o Cont√≠nua](#integra√ß√£o-cont√≠nua)
- [Melhores Pr√°ticas](#melhores-pr√°ticas)

---

## Filosofia de Testes

### Princ√≠pios Centrais

**1. Desenvolvimento Orientado a Testes (TDD)**

Escreva testes **antes** de implementar recursos:

```
1. Escrever um teste que falha
2. Implementar o recurso
3. Executar teste (deve passar)
4. Refatorar se necess√°rio
5. Repetir
```

**Benef√≠cios:**
- Garante que o recurso realmente funciona
- Previne regress√µes
- Documenta comportamento esperado
- Torna refatora√ß√£o mais segura

**2. Cobertura Abrangente**

Testar casos de sucesso e falha:

```hemlock
// Caso de sucesso
let x: u8 = 255;  // Deveria funcionar

// Caso de falha
let y: u8 = 256;  // Deveria dar erro
```

**3. Testar Cedo e Frequentemente**

Executar testes:
- Antes de commitar c√≥digo
- Depois de fazer mudan√ßas
- Antes de submeter pull request
- Durante code review

**Regra:** Todos os testes devem passar antes do merge.

### O que Testar

**Sempre teste:**
- Funcionalidade b√°sica (caminho feliz)
- Condi√ß√µes de erro (caminho de exce√ß√£o)
- Casos de borda (condi√ß√µes limite)
- Verifica√ß√£o e convers√£o de tipos
- Gerenciamento de mem√≥ria (sem vazamentos)
- Concorr√™ncia e condi√ß√µes de corrida

**Exemplo de cobertura de testes:**
```hemlock
// Recurso: String.substr(start, length)

// Caminho feliz
print("hello".substr(0, 5));  // "hello"

// Casos de borda
print("hello".substr(0, 0));  // "" (vazio)
print("hello".substr(5, 0));  // "" (no final)
print("hello".substr(2, 100)); // "llo" (al√©m do final)

// Casos de erro
// "hello".substr(-1, 5);  // Erro: √≠ndice negativo
// "hello".substr(0, -1);  // Erro: comprimento negativo
```

---

## Estrutura da Su√≠te de Testes

### Organiza√ß√£o de Diret√≥rios

```
tests/
‚îú‚îÄ‚îÄ run_tests.sh          # Script principal de execu√ß√£o de testes
‚îú‚îÄ‚îÄ primitives/           # Testes do sistema de tipos
‚îÇ   ‚îú‚îÄ‚îÄ integers.hml
‚îÇ   ‚îú‚îÄ‚îÄ floats.hml
‚îÇ   ‚îú‚îÄ‚îÄ booleans.hml
‚îÇ   ‚îú‚îÄ‚îÄ i64.hml
‚îÇ   ‚îî‚îÄ‚îÄ u64.hml
‚îú‚îÄ‚îÄ conversions/          # Testes de convers√£o de tipos
‚îÇ   ‚îú‚îÄ‚îÄ int_to_float.hml
‚îÇ   ‚îú‚îÄ‚îÄ promotion.hml
‚îÇ   ‚îî‚îÄ‚îÄ rune_conversions.hml
‚îú‚îÄ‚îÄ memory/               # Testes de ponteiro/buffer
‚îÇ   ‚îú‚îÄ‚îÄ alloc.hml
‚îÇ   ‚îú‚îÄ‚îÄ buffer.hml
‚îÇ   ‚îî‚îÄ‚îÄ memcpy.hml
‚îú‚îÄ‚îÄ strings/              # Testes de manipula√ß√£o de strings
‚îÇ   ‚îú‚îÄ‚îÄ concat.hml
‚îÇ   ‚îú‚îÄ‚îÄ methods.hml
‚îÇ   ‚îú‚îÄ‚îÄ utf8.hml
‚îÇ   ‚îî‚îÄ‚îÄ runes.hml
‚îú‚îÄ‚îÄ control/              # Testes de fluxo de controle
‚îÇ   ‚îú‚îÄ‚îÄ if.hml
‚îÇ   ‚îú‚îÄ‚îÄ switch.hml
‚îÇ   ‚îî‚îÄ‚îÄ while.hml
‚îú‚îÄ‚îÄ functions/            # Testes de fun√ß√µes e closures
‚îÇ   ‚îú‚îÄ‚îÄ basics.hml
‚îÇ   ‚îú‚îÄ‚îÄ closures.hml
‚îÇ   ‚îî‚îÄ‚îÄ recursion.hml
‚îú‚îÄ‚îÄ objects/              # Testes de objetos
‚îÇ   ‚îú‚îÄ‚îÄ literals.hml
‚îÇ   ‚îú‚îÄ‚îÄ methods.hml
‚îÇ   ‚îú‚îÄ‚îÄ duck_typing.hml
‚îÇ   ‚îî‚îÄ‚îÄ serialization.hml
‚îú‚îÄ‚îÄ arrays/               # Testes de opera√ß√µes de arrays
‚îÇ   ‚îú‚îÄ‚îÄ basics.hml
‚îÇ   ‚îú‚îÄ‚îÄ methods.hml
‚îÇ   ‚îî‚îÄ‚îÄ slicing.hml
‚îú‚îÄ‚îÄ loops/                # Testes de loops
‚îÇ   ‚îú‚îÄ‚îÄ for.hml
‚îÇ   ‚îú‚îÄ‚îÄ while.hml
‚îÇ   ‚îú‚îÄ‚îÄ break.hml
‚îÇ   ‚îî‚îÄ‚îÄ continue.hml
‚îú‚îÄ‚îÄ exceptions/           # Testes de tratamento de erros
‚îÇ   ‚îú‚îÄ‚îÄ try_catch.hml
‚îÇ   ‚îú‚îÄ‚îÄ finally.hml
‚îÇ   ‚îî‚îÄ‚îÄ throw.hml
‚îú‚îÄ‚îÄ io/                   # Testes de I/O de arquivos
‚îÇ   ‚îú‚îÄ‚îÄ file_object.hml
‚îÇ   ‚îú‚îÄ‚îÄ read_write.hml
‚îÇ   ‚îî‚îÄ‚îÄ seek.hml
‚îú‚îÄ‚îÄ async/                # Testes de concorr√™ncia
‚îÇ   ‚îú‚îÄ‚îÄ spawn_join.hml
‚îÇ   ‚îú‚îÄ‚îÄ channels.hml
‚îÇ   ‚îî‚îÄ‚îÄ exceptions.hml
‚îú‚îÄ‚îÄ ffi/                  # Testes de FFI
‚îÇ   ‚îú‚îÄ‚îÄ basic_call.hml
‚îÇ   ‚îú‚îÄ‚îÄ types.hml
‚îÇ   ‚îî‚îÄ‚îÄ dlopen.hml
‚îú‚îÄ‚îÄ signals/              # Testes de tratamento de sinais
‚îÇ   ‚îú‚îÄ‚îÄ basic.hml
‚îÇ   ‚îú‚îÄ‚îÄ handlers.hml
‚îÇ   ‚îî‚îÄ‚îÄ raise.hml
‚îî‚îÄ‚îÄ args/                 # Testes de argumentos de linha de comando
    ‚îî‚îÄ‚îÄ basic.hml
```

### Nomenclatura de Arquivos de Teste

**Conven√ß√µes:**
- Usar nomes descritivos: `method_chaining.hml` ao inv√©s de `test1.hml`
- Agrupar testes relacionados: `string_substr.hml`, `string_slice.hml`
- Uma √°rea funcional por arquivo
- Manter arquivos focados e pequenos

---

## Executando Testes

### Executar Todos os Testes

```bash
# Do diret√≥rio raiz do hemlock
make test

# Ou diretamente
./tests/run_tests.sh
```

**Sa√≠da:**
```
Running tests in tests/primitives/...
  ‚úì integers.hml
  ‚úì floats.hml
  ‚úì booleans.hml

Running tests in tests/strings/...
  ‚úì concat.hml
  ‚úì methods.hml

...

Total: 251 tests
Passed: 251
Failed: 0
```

### Executar Categoria Espec√≠fica

```bash
# Apenas testes de strings
./tests/run_tests.sh tests/strings/

# Apenas um arquivo de teste
./tests/run_tests.sh tests/strings/concat.hml

# M√∫ltiplas categorias
./tests/run_tests.sh tests/strings/ tests/arrays/
```

### Executar com Valgrind (Verifica√ß√£o de Vazamento de Mem√≥ria)

```bash
# Verificar vazamentos em um √∫nico teste
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml

# Verificar todos os testes (muito lento!)
for test in tests/**/*.hml; do
    echo "Testing $test"
    valgrind --leak-check=full --error-exitcode=1 ./hemlock "$test"
done
```

### Debugando Testes que Falham

```bash
# Executar com sa√≠da verbosa
./hemlock tests/failing_test.hml

# Executar com gdb
gdb --args ./hemlock tests/failing_test.hml
(gdb) run
(gdb) backtrace  # Se crashar
```

---

## Escrevendo Testes

### Formato de Arquivo de Teste

Arquivos de teste s√£o simplesmente programas Hemlock com sa√≠da esperada:

**Exemplo: tests/primitives/integers.hml**
```hemlock
// Testar literais inteiros b√°sicos
let x = 42;
print(x);  // Expect: 42

let y: i32 = 100;
print(y);  // Expect: 100

// Testar aritm√©tica
let sum = x + y;
print(sum);  // Expect: 142

// Testar infer√™ncia de tipos
let small = 10;
print(typeof(small));  // Expect: i32

let large = 5000000000;
print(typeof(large));  // Expect: i64
```

**Como os testes funcionam:**
1. O executor de testes executa o arquivo .hml
2. Captura sa√≠da stdout
3. Compara com sa√≠da esperada (de coment√°rios ou arquivo .out separado)
4. Reporta passou/falhou

### M√©todos de Sa√≠da Esperada

**M√©todo 1: Coment√°rios Inline (recomendado para testes simples)**

```hemlock
print("hello");  // Expect: hello
print(42);       // Expect: 42
```

O executor de testes faz parse de coment√°rios `// Expect: ...`.

**M√©todo 2: Arquivo .out Separado**

Criar `test_name.hml.out` com sa√≠da esperada:

**test_name.hml:**
```hemlock
print("line 1");
print("line 2");
print("line 3");
```

**test_name.hml.out:**
```
line 1
line 2
line 3
```

### Testando Casos de Erro

Testes de erro devem fazer o programa sair com status n√£o-zero:

**Exemplo: tests/primitives/range_error.hml**
```hemlock
// Isso deveria falhar com erro de tipo
let x: u8 = 256;  // Fora do intervalo de u8
```

**Comportamento esperado:**
- Programa sai com status n√£o-zero
- Imprime mensagem de erro em stderr

**Tratamento do executor de testes:**
- Testes esperados a dar erro devem estar em arquivos separados
- Usar conven√ß√£o de nomenclatura: `*_error.hml` ou `*_fail.hml`
- Documentar erro esperado em coment√°rio

### Testando Casos de Sucesso

**Exemplo: tests/strings/methods.hml**
```hemlock
// Testar substr
let s = "hello world";
let sub = s.substr(6, 5);
print(sub);  // Expect: world

// Testar find
let pos = s.find("world");
print(pos);  // Expect: 6

// Testar contains
let has = s.contains("lo");
print(has);  // Expect: true

// Testar trim
let padded = "  hello  ";
let trimmed = padded.trim();
print(trimmed);  // Expect: hello
```

### Testando Casos de Borda

**Exemplo: tests/arrays/edge_cases.hml**
```hemlock
// Array vazio
let empty = [];
print(empty.length);  // Expect: 0

// √önico elemento
let single = [42];
print(single[0]);  // Expect: 42

// √çndice negativo (deveria dar erro em arquivo de teste separado)
// print(single[-1]);  // Erro

// √çndice al√©m do final (deveria dar erro)
// print(single[100]);  // Erro

// Condi√ß√µes de borda
let arr = [1, 2, 3];
print(arr.slice(0, 0));  // Expect: [] (vazio)
print(arr.slice(3, 3));  // Expect: [] (vazio)
print(arr.slice(1, 2));  // Expect: [2]
```

### Testando Sistema de Tipos

**Exemplo: tests/conversions/promotion.hml**
```hemlock
// Testar promo√ß√£o de tipos em opera√ß√µes bin√°rias

// i32 + i64 -> i64
let a: i32 = 10;
let b: i64 = 20;
let c = a + b;
print(typeof(c));  // Expect: i64

// i32 + f32 -> f32
let d: i32 = 10;
let e: f32 = 3.14;
let f = d + e;
print(typeof(f));  // Expect: f32

// u8 + i32 -> i32
let g: u8 = 5;
let h: i32 = 10;
let i = g + h;
print(typeof(i));  // Expect: i32
```

### Testando Concorr√™ncia

**Exemplo: tests/async/basic.hml**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Spawn tasks
let t1 = spawn(compute, 10);
let t2 = spawn(compute, 20);

// Esperar e imprimir resultados
let r1 = join(t1);
let r2 = join(t2);
print(r1);  // Expect: 45
print(r2);  // Expect: 190
```

### Testando Exce√ß√µes

**Exemplo: tests/exceptions/try_catch.hml**
```hemlock
// Testar try/catch b√°sico
try {
    throw "error message";
} catch (e) {
    print("Caught: " + e);  // Expect: Caught: error message
}

// Testar finally
let executed = false;
try {
    print("try");  // Expect: try
} finally {
    executed = true;
    print("finally");  // Expect: finally
}

// Testar propaga√ß√£o de exce√ß√£o
fn risky(): i32 {
    throw "failure";
}

try {
    risky();
} catch (e) {
    print(e);  // Expect: failure
}
```

---

## Categorias de Testes

### Testes de Tipos Primitivos

**O que testar:**
- Tipos inteiros (i8, i16, i32, i64, u8, u16, u32, u64)
- Tipos de ponto flutuante (f32, f64)
- Tipo booleano
- Tipo string
- Tipo rune
- Tipo null

**√Åreas de exemplo:**
- Sintaxe de literais
- Infer√™ncia de tipos
- Verifica√ß√£o de intervalos
- Comportamento de overflow
- Anota√ß√µes de tipo

### Testes de Convers√µes

**O que testar:**
- Promo√ß√£o de tipos impl√≠cita
- Convers√£o de tipos expl√≠cita
- Convers√µes com perda (deveriam dar erro)
- Promo√ß√£o de tipos em opera√ß√µes
- Compara√ß√µes entre tipos

### Testes de Mem√≥ria

**O que testar:**
- Corretude de alloc/free
- Cria√ß√£o e acesso de Buffer
- Verifica√ß√£o de limites de buffer
- memset, memcpy, realloc
- Detec√ß√£o de vazamento de mem√≥ria (valgrind)

### Testes de Strings

**O que testar:**
- Concatena√ß√£o
- Todos os 18 m√©todos de string
- Tratamento de UTF-8
- Indexa√ß√£o de runes
- Concatena√ß√£o string + rune
- Casos de borda (string vazia, √∫nico caractere, etc.)

### Testes de Fluxo de Controle

**O que testar:**
- if/else/else if
- Loops while
- Loops for
- Statements switch
- break/continue
- Statements return

### Testes de Fun√ß√µes

**O que testar:**
- Defini√ß√£o e chamada de fun√ß√µes
- Passagem de par√¢metros
- Valores de retorno
- Recurs√£o
- Closures e captura
- Fun√ß√µes de primeira classe
- Fun√ß√µes an√¥nimas

### Testes de Objetos

**O que testar:**
- Literais de objeto
- Acesso e atribui√ß√£o de campos
- M√©todos e binding de self
- Duck typing
- Campos opcionais
- Serializa√ß√£o/deserializa√ß√£o JSON
- Detec√ß√£o de refer√™ncia circular

### Testes de Arrays

**O que testar:**
- Cria√ß√£o de arrays
- Indexa√ß√£o e atribui√ß√£o
- Todos os 15 m√©todos de array
- Tipos misturados
- Redimensionamento din√¢mico
- Casos de borda (vazio, √∫nico elemento)

### Testes de Exce√ß√µes

**O que testar:**
- try/catch/finally
- Statement throw
- Propaga√ß√£o de exce√ß√µes
- try/catch aninhado
- return em try/catch/finally
- Exce√ß√µes n√£o capturadas

### Testes de I/O

**O que testar:**
- Modos de abertura de arquivo
- Opera√ß√µes de leitura/escrita
- Seek/tell
- Atributos de arquivo
- Tratamento de erros (arquivo faltando, etc.)
- Limpeza de recursos

### Testes de Async

**O que testar:**
- spawn/join/detach
- Channel send/recv
- Propaga√ß√£o de exce√ß√µes em tasks
- M√∫ltiplas tasks concorrentes
- Comportamento de bloqueio de channels

### Testes de FFI

**O que testar:**
- dlopen/dlclose
- dlsym
- dlcall com v√°rios tipos
- Convers√£o de tipos
- Tratamento de erros

---

## Testes de Vazamento de Mem√≥ria

### Usando Valgrind

**Uso b√°sico:**
```bash
valgrind --leak-check=full ./hemlock test.hml
```

**Exemplo de sa√≠da (sem vazamentos):**
```
==12345== HEAP SUMMARY:
==12345==     in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated
==12345==
==12345== All heap blocks were freed -- no leaks are possible
```

**Exemplo de sa√≠da (com vazamentos):**
```
==12345== LEAK SUMMARY:
==12345==    definitely lost: 64 bytes in 1 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==      possibly lost: 0 bytes in 0 blocks
==12345==    still reachable: 0 bytes in 0 blocks
==12345==         suppressed: 0 bytes in 0 blocks
```

### Fontes Comuns de Vazamentos

**1. Chamadas free() faltando:**
```c
// Ruim
char *str = malloc(100);
// ... usar str
// Esqueceu de liberar!

// Bom
char *str = malloc(100);
// ... usar str
free(str);
```

**2. Ponteiros perdidos:**
```c
// Ruim
char *ptr = malloc(100);
ptr = malloc(200);  // Perdeu refer√™ncia para primeira aloca√ß√£o!

// Bom
char *ptr = malloc(100);
free(ptr);
ptr = malloc(200);
```

**3. Caminhos de exce√ß√£o:**
```c
// Ruim
void func() {
    char *data = malloc(100);
    if (error_condition) {
        return;  // Vazamento!
    }
    free(data);
}

// Bom
void func() {
    char *data = malloc(100);
    if (error_condition) {
        free(data);
        return;
    }
    free(data);
}
```

### Vazamentos Conhecidos e Aceit√°veis

Alguns pequenos "vazamentos" s√£o aloca√ß√µes de inicializa√ß√£o intencionais:

**Builtins globais:**
```hemlock
// Fun√ß√µes builtin, tipos FFI e constantes s√£o alocados na inicializa√ß√£o
// e n√£o s√£o liberados na sa√≠da (geralmente ~200 bytes)
```

Estes n√£o s√£o vazamentos reais - s√£o aloca√ß√µes √∫nicas que duram toda a vida do programa e s√£o limpas pelo SO na sa√≠da.

---

## Integra√ß√£o Cont√≠nua

### GitHub Actions (Futuro)

Uma vez que CI esteja configurado, todos os testes executar√£o automaticamente em:
- Push para branch main
- Cria√ß√£o/atualiza√ß√£o de Pull Request
- Execu√ß√£o agendada di√°ria

**Workflow de CI:**
1. Build do Hemlock
2. Executar su√≠te de testes
3. Verificar vazamentos de mem√≥ria (valgrind)
4. Reportar resultados no PR

### Verifica√ß√µes Pr√©-Commit

Antes de commitar, execute:

```bash
# Build limpo
make clean && make

# Executar todos os testes
make test

# Verificar vazamentos em alguns testes
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml
valgrind --leak-check=full ./hemlock tests/strings/concat.hml
```

---

## Melhores Pr√°ticas

### Fa√ßa

**Escreva testes primeiro (TDD)**
```bash
1. Criar tests/feature/new_feature.hml
2. Implementar recurso em src/
3. Executar testes at√© passar
```

**Teste casos de sucesso e falha**
```hemlock
// Sucesso: tests/feature/success.hml
let result = do_thing();
print(result);  // Expect: expected value

// Falha: tests/feature/failure.hml
do_invalid_thing();  // Deveria dar erro
```

**Use nomes de teste descritivos**
```
Bom: tests/strings/substr_utf8_boundary.hml
Ruim: tests/test1.hml
```

**Mantenha testes focados**
- Uma √°rea funcional por arquivo
- Setup e assertivas claras
- C√≥digo m√≠nimo

**Adicione coment√°rios explicando testes complicados**
```hemlock
// Testar que closures capturam vari√°veis externas por refer√™ncia
fn outer() {
    let x = 10;
    let f = fn() { return x; };
    x = 20;  // Modificar ap√≥s cria√ß√£o da closure
    return f();  // Deveria retornar 20, n√£o 10
}
```

**Teste casos de borda**
- Entradas vazias
- Valores null
- Valores de fronteira (min/max)
- Entradas grandes
- Valores negativos

### N√£o Fa√ßa

**N√£o pule testes**
- Todos os testes devem passar antes do merge
- N√£o comente testes que falham
- Corrija o bug ou remova o recurso

**N√£o escreva testes que dependem uns dos outros**
```hemlock
// Ruim: test2.hml depende da sa√≠da de test1.hml
// Testes devem ser independentes
```

**N√£o use valores aleat√≥rios em testes**
```hemlock
// Ruim: n√£o-determin√≠stico
let x = random();
print(x);  // N√£o pode prever sa√≠da

// Bom: determin√≠stico
let x = 42;
print(x);  // Expect: 42
```

**N√£o teste detalhes de implementa√ß√£o**
```hemlock
// Ruim: testa estrutura interna
let obj = { x: 10 };
// N√£o verifique ordem interna de campos, capacidade, etc.

// Bom: testa comportamento
print(obj.x);  // Expect: 10
```

**N√£o ignore vazamentos de mem√≥ria**
- Todos os testes devem estar limpos no valgrind
- Documente vazamentos conhecidos/aceit√°veis
- Corrija vazamentos antes do merge

### Manuten√ß√£o de Testes

**Quando atualizar testes:**
- Comportamento de recurso muda
- Corre√ß√£o de bug precisa de novo caso de teste
- Caso de borda √© descoberto
- Melhorias de performance

**Quando remover testes:**
- Recurso √© removido da linguagem
- Teste duplica cobertura existente
- Teste est√° incorreto

**Refatorando testes:**
- Agrupar testes relacionados juntos
- Extrair c√≥digo de setup comum
- Usar nomenclatura consistente
- Manter testes simples e leg√≠veis

---

## Exemplo de Sess√£o de Teste

Aqui est√° um exemplo completo de adicionar um recurso com testes:

### Recurso: Adicionar M√©todo `array.first()`

**1. Escrever teste primeiro:**

```bash
# Criar arquivo de teste
cat > tests/arrays/first_method.hml << 'EOF'
// Testar m√©todo array.first()

// Caso b√°sico
let arr = [1, 2, 3];
print(arr.first());  // Expect: 1

// √önico elemento
let single = [42];
print(single.first());  // Expect: 42

// Array vazio (deveria dar erro - arquivo de teste separado)
// let empty = [];
// print(empty.first());  // Erro
EOF
```

**2. Executar teste (deveria falhar):**

```bash
./hemlock tests/arrays/first_method.hml
# Error: Method 'first' not found on array
```

**3. Implementar recurso:**

Editar `src/interpreter/builtins.c`:

```c
// Adicionar m√©todo array_first
Value *array_first(Value *self, Value **args, int arg_count)
{
    if (self->array_value->length == 0) {
        fprintf(stderr, "Error: Cannot get first element of empty array\n");
        exit(1);
    }

    return value_copy(&self->array_value->elements[0]);
}

// Registrar na tabela de m√©todos de array
// ... adicionar ao registro de m√©todos de array
```

**4. Executar teste (deveria passar):**

```bash
./hemlock tests/arrays/first_method.hml
1
42
# Sucesso!
```

**5. Verificar vazamentos de mem√≥ria:**

```bash
valgrind --leak-check=full ./hemlock tests/arrays/first_method.hml
# All heap blocks were freed -- no leaks are possible
```

**6. Executar su√≠te de testes completa:**

```bash
make test
# Total: 252 tests (251 + novo)
# Passed: 252
# Failed: 0
```

**7. Commitar:**

```bash
git add tests/arrays/first_method.hml src/interpreter/builtins.c
git commit -m "Add array.first() method with tests"
```

---

## Resumo

**Lembre-se:**
- Escrever testes primeiro (TDD)
- Testar casos de sucesso e falha
- Executar todos os testes antes de commitar
- Verificar vazamentos de mem√≥ria
- Documentar problemas conhecidos
- Manter testes simples e focados

**Qualidade de testes √© t√£o importante quanto qualidade de c√≥digo!**



################################################################################
# HPM: PRIMEIROS PASSOS
################################################################################

--------------------------------------------------------------------------------
## Configura√ß√£o do Projeto
--------------------------------------------------------------------------------

# Configuracao do Projeto

Guia completo para configurar projetos Hemlock com hpm.

## Criando um Novo Projeto

### Configuracao Basica

Crie um novo projeto do zero:

```bash
# Criar diretorio do projeto
mkdir my-project
cd my-project

# Inicializar package.json
hpm init

# Criar estrutura de diretorios
mkdir -p src test
```

### Templates de Projeto

Aqui estao estruturas de projeto comuns para diferentes casos de uso:

#### Biblioteca de Pacotes

Para bibliotecas reutilizaveis:

```
my-library/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ index.hml          # Entrada principal, exporta API publica
‚îÇ   ‚îú‚îÄ‚îÄ core.hml           # Funcionalidade principal
‚îÇ   ‚îú‚îÄ‚îÄ utils.hml          # Funcoes utilitarias
‚îÇ   ‚îî‚îÄ‚îÄ types.hml          # Definicoes de tipos
‚îî‚îÄ‚îÄ test/
    ‚îú‚îÄ‚îÄ framework.hml      # Framework de testes
    ‚îú‚îÄ‚îÄ run.hml            # Executor de testes
    ‚îî‚îÄ‚îÄ test_core.hml      # Testes
```

**package.json:**

```json
{
  "name": "yourusername/my-library",
  "version": "1.0.0",
  "description": "A reusable Hemlock library",
  "main": "src/index.hml",
  "scripts": {
    "test": "hemlock test/run.hml"
  },
  "dependencies": {},
  "devDependencies": {}
}
```

#### Aplicacao

Para aplicacoes standalone:

```
my-app/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.hml           # Ponto de entrada da aplicacao
‚îÇ   ‚îú‚îÄ‚îÄ config.hml         # Configuracao
‚îÇ   ‚îú‚îÄ‚îÄ commands/          # Comandos CLI
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.hml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ run.hml
‚îÇ   ‚îî‚îÄ‚îÄ lib/               # Bibliotecas internas
‚îÇ       ‚îî‚îÄ‚îÄ utils.hml
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îî‚îÄ‚îÄ run.hml
‚îî‚îÄ‚îÄ data/                  # Arquivos de dados
```

**package.json:**

```json
{
  "name": "yourusername/my-app",
  "version": "1.0.0",
  "description": "A Hemlock application",
  "main": "src/main.hml",
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc"
  },
  "dependencies": {
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {}
}
```

#### Aplicacao Web

Para servidores web:

```
my-web-app/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.hml           # Ponto de entrada do servidor
‚îÇ   ‚îú‚îÄ‚îÄ routes/            # Handlers de rotas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.hml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.hml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.hml
‚îÇ   ‚îú‚îÄ‚îÄ middleware/        # Middleware
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.hml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.hml
‚îÇ   ‚îú‚îÄ‚îÄ models/            # Modelos de dados
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.hml
‚îÇ   ‚îî‚îÄ‚îÄ services/          # Logica de negocios
‚îÇ       ‚îî‚îÄ‚îÄ user.hml
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îî‚îÄ‚îÄ run.hml
‚îú‚îÄ‚îÄ static/                # Arquivos estaticos
‚îÇ   ‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îî‚îÄ‚îÄ js/
‚îî‚îÄ‚îÄ views/                 # Templates
    ‚îî‚îÄ‚îÄ index.hml
```

**package.json:**

```json
{
  "name": "yourusername/my-web-app",
  "version": "1.0.0",
  "description": "A Hemlock web application",
  "main": "src/main.hml",
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml"
  },
  "dependencies": {
    "hemlang/sprout": "^2.0.0",
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  }
}
```

## Arquivo package.json

### Campos Obrigatorios

```json
{
  "name": "owner/repo",
  "version": "1.0.0"
}
```

### Todos os Campos

```json
{
  "name": "yourusername/my-package",
  "version": "1.0.0",
  "description": "Package description",
  "author": "Your Name <you@example.com>",
  "license": "MIT",
  "repository": "https://github.com/yourusername/my-package",
  "homepage": "https://yourusername.github.io/my-package",
  "bugs": "https://github.com/yourusername/my-package/issues",
  "main": "src/index.hml",
  "keywords": ["utility", "parser"],
  "dependencies": {
    "owner/package": "^1.0.0"
  },
  "devDependencies": {
    "owner/test-lib": "^1.0.0"
  },
  "scripts": {
    "start": "hemlock src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc"
  },
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ],
  "native": {
    "requires": ["libcurl", "openssl"]
  }
}
```

### Referencia de Campos

| Campo | Tipo | Descricao |
|-------|------|-----------|
| `name` | string | Nome do pacote no formato owner/repo (obrigatorio) |
| `version` | string | Versao semantica (obrigatorio) |
| `description` | string | Descricao curta |
| `author` | string | Nome e email do autor |
| `license` | string | Identificador da licenca (MIT, Apache-2.0, etc.) |
| `repository` | string | URL do repositorio |
| `homepage` | string | Pagina inicial do projeto |
| `bugs` | string | URL do rastreador de issues |
| `main` | string | Arquivo de ponto de entrada (padrao: src/index.hml) |
| `keywords` | array | Palavras-chave para busca |
| `dependencies` | object | Dependencias de tempo de execucao |
| `devDependencies` | object | Dependencias de desenvolvimento |
| `scripts` | object | Scripts nomeados |
| `files` | array | Arquivos a incluir na publicacao |
| `native` | object | Requisitos de bibliotecas nativas |

## Arquivo package-lock.json

O arquivo de lock e gerado automaticamente e deve ser commitado no controle de versao. Ele garante instalacoes reproduziveis.

```json
{
  "lockVersion": 1,
  "hemlock": "1.0.0",
  "dependencies": {
    "hemlang/sprout": {
      "version": "2.1.0",
      "resolved": "https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz",
      "integrity": "sha256-abc123...",
      "dependencies": {
        "hemlang/router": "^1.5.0"
      }
    },
    "hemlang/router": {
      "version": "1.5.0",
      "resolved": "https://github.com/hemlang/router/archive/v1.5.0.tar.gz",
      "integrity": "sha256-def456...",
      "dependencies": {}
    }
  }
}
```

### Melhores Praticas do Arquivo de Lock

- **Comite** package-lock.json no controle de versao
- **Nao edite manualmente** - e gerado automaticamente
- **Execute `hpm install`** apos puxar alteracoes
- **Delete e regenere** se corrompido:
  ```bash
  rm package-lock.json
  hpm install
  ```

## Diretorio hem_modules

Pacotes instalados sao armazenados em `hem_modules/`:

```
hem_modules/
‚îú‚îÄ‚îÄ hemlang/
‚îÇ   ‚îú‚îÄ‚îÄ sprout/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ router/
‚îÇ       ‚îú‚îÄ‚îÄ package.json
‚îÇ       ‚îî‚îÄ‚îÄ src/
‚îî‚îÄ‚îÄ alice/
    ‚îî‚îÄ‚îÄ http-client/
        ‚îú‚îÄ‚îÄ package.json
        ‚îî‚îÄ‚îÄ src/
```

### Melhores Praticas do hem_modules

- **Adicione ao .gitignore** - Nao comite dependencias
- **Nao modifique** - Alteracoes serao sobrescritas
- **Delete para reinstalar**:
  ```bash
  rm -rf hem_modules
  hpm install
  ```

## .gitignore

.gitignore recomendado para projetos Hemlock:

```gitignore
# Dependencias
hem_modules/

# Saida de build
dist/
*.hmlc

# Arquivos de IDE
.idea/
.vscode/
*.swp
*.swo

# Arquivos do OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Ambiente
.env
.env.local

# Cobertura de testes
coverage/
```

## Trabalhando com Dependencias

### Adicionando Dependencias

```bash
# Adicionar dependencia de tempo de execucao
hpm install hemlang/json

# Adicionar com restricao de versao
hpm install hemlang/sprout@^2.0.0

# Adicionar dependencia de desenvolvimento
hpm install hemlang/test-utils --dev
```

### Importando Dependencias

```hemlock
// Importar de pacote (usa entrada "main")
import { parse, stringify } from "hemlang/json";

// Importar de subcaminho
import { Router } from "hemlang/sprout/router";

// Importar biblioteca padrao
import { HashMap } from "@stdlib/collections";
import { readFile, writeFile } from "@stdlib/fs";
```

### Resolucao de Imports

O hpm resolve imports na seguinte ordem:

1. **Biblioteca padrao**: Imports `@stdlib/*` carregam modulos embutidos
2. **Raiz do pacote**: `owner/repo` usa o campo `main`
3. **Subcaminho**: `owner/repo/path` verifica:
   - `hem_modules/owner/repo/path.hml`
   - `hem_modules/owner/repo/path/index.hml`
   - `hem_modules/owner/repo/src/path.hml`
   - `hem_modules/owner/repo/src/path/index.hml`

## Scripts

### Definindo Scripts

Adicione scripts no package.json:

```json
{
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "test:unit": "hemlock test/unit/run.hml",
    "test:integration": "hemlock test/integration/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc",
    "clean": "rm -rf dist hem_modules",
    "lint": "hemlock-lint src/",
    "format": "hemlock-fmt src/"
  }
}
```

### Executando Scripts

```bash
hpm run start
hpm run dev
hpm run build

# Atalho para test
hpm test

# Passar argumentos
hpm run test -- --verbose --filter=unit
```

### Convencoes de Nomeacao de Scripts

| Script | Proposito |
|--------|-----------|
| `start` | Executar a aplicacao |
| `dev` | Executar em modo de desenvolvimento |
| `test` | Executar todos os testes |
| `build` | Compilar para producao |
| `clean` | Remover arquivos gerados |
| `lint` | Verificar estilo de codigo |
| `format` | Formatar codigo |

## Fluxo de Trabalho de Desenvolvimento

### Configuracao Inicial

```bash
# Clonar projeto
git clone https://github.com/yourusername/my-project.git
cd my-project

# Instalar dependencias
hpm install

# Executar testes
hpm test

# Iniciar desenvolvimento
hpm run dev
```

### Fluxo de Trabalho Diario

```bash
# Puxar ultimas alteracoes
git pull

# Instalar quaisquer novas dependencias
hpm install

# Fazer alteracoes...

# Executar testes
hpm test

# Commitar
git add .
git commit -m "Add feature"
git push
```

### Adicionando Nova Funcionalidade

```bash
# Criar branch de feature
git checkout -b feature/new-feature

# Adicionar novas dependencias se necessario
hpm install hemlang/new-lib

# Implementar funcionalidade...

# Testar
hpm test

# Commitar e enviar
git add .
git commit -m "Add new feature"
git push -u origin feature/new-feature
```

## Configuracao Especifica por Ambiente

### Usando Variaveis de Ambiente

```hemlock
import { getenv } from "@stdlib/env";

let db_host = getenv("DATABASE_HOST") ?? "localhost";
let api_key = getenv("API_KEY") ?? "";

if api_key == "" {
    print("Warning: API_KEY not set");
}
```

### Arquivo de Configuracao

**config.hml:**

```hemlock
import { getenv } from "@stdlib/env";

export let config = {
    environment: getenv("HEMLOCK_ENV") ?? "development",
    database: {
        host: getenv("DB_HOST") ?? "localhost",
        port: int(getenv("DB_PORT") ?? "5432"),
        name: getenv("DB_NAME") ?? "myapp"
    },
    server: {
        port: int(getenv("PORT") ?? "3000"),
        host: getenv("HOST") ?? "0.0.0.0"
    }
};

export fn is_production(): bool {
    return config.environment == "production";
}
```

## Veja Tambem

- [Inicio Rapido](#hpm-project-setup-quick-start) - Introducao rapida
- [Comandos](#hpm-project-setup-commands) - Referencia de comandos
- [Criacao de Pacotes](#hpm-project-setup-creating-packages) - Publicar pacotes
- [Configuracao](#hpm-project-setup-configuration) - Configuracao do hpm


--------------------------------------------------------------------------------
## Instala√ß√£o
--------------------------------------------------------------------------------

# Instalacao

Este guia explica como instalar o hpm no seu sistema.

## Instalacao Rapida (Recomendada)

Instale a versao mais recente com um unico comando:

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh
```

Isso automaticamente:
- Detecta seu sistema operacional (Linux, macOS)
- Detecta sua arquitetura (x86_64, arm64)
- Baixa o binario pre-compilado correspondente
- Instala em `/usr/local/bin` (usa sudo se necessario)

### Opcoes de Instalacao

```bash
# Instalar em local personalizado (sem sudo)
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local

# Instalar versao especifica
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5

# Combinar opcoes
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5
```

### Plataformas Suportadas

| Plataforma | Arquitetura | Status |
|------------|-------------|--------|
| Linux      | x86_64      | Suportado |
| macOS      | x86_64      | Suportado |
| macOS      | arm64 (M1/M2/M3) | Suportado |
| Linux      | arm64       | Compilar do codigo-fonte |

## Compilando do Codigo-Fonte

Se voce prefere compilar do codigo-fonte, ou precisa de uma plataforma nao coberta pelos binarios pre-compilados, siga estas instrucoes.

### Pre-requisitos

O hpm requer que o [Hemlock](https://github.com/hemlang/hemlock) esteja instalado. Por favor, siga as instrucoes de instalacao do Hemlock primeiro.

Verifique se o Hemlock esta instalado:

```bash
hemlock --version
```

## Metodos de Instalacao

### Metodo 1: Make Install

Compile e instale a partir do codigo-fonte.

```bash
# Clonar o repositorio
git clone https://github.com/hemlang/hpm.git
cd hpm

# Instalar em /usr/local/bin (requer sudo)
sudo make install
```

Apos a instalacao, verifique se esta funcionando:

```bash
hpm --version
```

### Metodo 2: Local Personalizado

Instale em um diretorio personalizado (sem sudo):

```bash
# Clonar o repositorio
git clone https://github.com/hemlang/hpm.git
cd hpm

# Instalar em ~/.local/bin
make install PREFIX=$HOME/.local

# Ou qualquer local personalizado
make install PREFIX=/opt/hemlock
```

Certifique-se de que seu diretorio bin personalizado esta no PATH:

```bash
# Adicionar ao ~/.bashrc ou ~/.zshrc
export PATH="$HOME/.local/bin:$PATH"
```

### Metodo 3: Executar Sem Instalar

Voce pode executar o hpm diretamente sem instalar:

```bash
# Clonar o repositorio
git clone https://github.com/hemlang/hpm.git
cd hpm

# Criar script wrapper local
make

# Executar do diretorio hpm
./hpm --help

# Ou executar diretamente via hemlock
hemlock src/main.hml --help
```

### Metodo 4: Instalacao Manual

Crie seu proprio script wrapper:

```bash
# Clonar para um local permanente
git clone https://github.com/hemlang/hpm.git ~/.hpm-source

# Criar script wrapper
cat > ~/.local/bin/hpm << 'EOF'
#!/bin/sh
exec hemlock "$HOME/.hpm-source/src/main.hml" "$@"
EOF

chmod +x ~/.local/bin/hpm
```

## Variaveis de Instalacao

O Makefile suporta as seguintes variaveis:

| Variavel | Padrao | Descricao |
|----------|--------|-----------|
| `PREFIX` | `/usr/local` | Prefixo de instalacao |
| `BINDIR` | `$(PREFIX)/bin` | Diretorio de binarios |
| `HEMLOCK` | `hemlock` | Caminho do interpretador hemlock |

Exemplo usando variaveis personalizadas:

```bash
make install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock
```

## Como Funciona

O instalador cria um script shell wrapper que invoca o interpretador Hemlock com o codigo-fonte do hpm:

```bash
#!/bin/sh
exec hemlock "/path/to/hpm/src/main.hml" "$@"
```

Esta abordagem:
- Nao requer compilacao
- Sempre executa o codigo-fonte mais recente
- Funciona de forma confiavel em todas as plataformas

## Atualizando o hpm

Para atualizar o hpm para a versao mais recente:

```bash
cd /path/to/hpm
git pull origin main

# Reinstalar se o caminho mudou
sudo make install
```

## Desinstalacao

Para remover o hpm do sistema:

```bash
cd /path/to/hpm
sudo make uninstall
```

Ou remova manualmente:

```bash
sudo rm /usr/local/bin/hpm
```

## Verificando a Instalacao

Apos a instalacao, verifique se tudo esta funcionando:

```bash
# Verificar versao
hpm --version

# Ver ajuda
hpm --help

# Testar inicializacao (em um diretorio vazio)
mkdir test-project && cd test-project
hpm init --yes
cat package.json
```

## Solucao de Problemas

### "hemlock: command not found"

O Hemlock nao esta instalado ou nao esta no PATH. Instale o Hemlock primeiro:

```bash
# Verificar se hemlock existe
which hemlock

# Se nao encontrado, instale o Hemlock de https://github.com/hemlang/hemlock
```

### "Permission denied"

Use sudo para instalacao em todo o sistema, ou instale no diretorio do usuario:

```bash
# Opcao 1: Usar sudo
sudo make install

# Opcao 2: Instalar no diretorio do usuario
make install PREFIX=$HOME/.local
```

### "hpm: command not found" apos instalacao

Seu PATH pode nao incluir o diretorio de instalacao:

```bash
# Verificar onde o hpm foi instalado
ls -la /usr/local/bin/hpm

# Se usando local personalizado, adicionar ao PATH
export PATH="$HOME/.local/bin:$PATH"
```

## Notas Especificas por Plataforma

### Linux

A instalacao padrao funciona em todas as distribuicoes Linux. Algumas distribuicoes podem precisar:

```bash
# Debian/Ubuntu: garantir que ferramentas de compilacao estao instaladas
sudo apt-get install build-essential git

# Fedora/RHEL
sudo dnf install make git
```

### macOS

A instalacao padrao funciona. Se usar Homebrew:

```bash
# Garantir que as ferramentas de linha de comando do Xcode estao instaladas
xcode-select --install
```

### Windows (WSL)

O hpm funciona no Windows Subsystem for Linux:

```bash
# No terminal WSL
git clone https://github.com/hemlang/hpm.git
cd hpm
make install PREFIX=$HOME/.local
```

## Proximos Passos

Apos a instalacao:

1. [Inicio Rapido](#hpm-installation-quick-start) - Crie seu primeiro projeto
2. [Referencia de Comandos](#hpm-installation-commands) - Aprenda todos os comandos
3. [Configuracao](#hpm-installation-configuration) - Configure o hpm


--------------------------------------------------------------------------------
## In√≠cio R√°pido
--------------------------------------------------------------------------------

# Inicio Rapido

Comece a usar o hpm em 5 minutos.

## Instalar o hpm

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh
```

Veja o [Guia de Instalacao](#hpm-quick-start-installation) para mais opcoes de instalacao.

## Criar um Novo Projeto

Primeiro, crie um novo diretorio e inicialize o pacote:

```bash
mkdir my-project
cd my-project
hpm init
```

O sistema solicitara os detalhes do projeto:

```
Package name (owner/repo): myname/my-project
Version (1.0.0):
Description: My awesome Hemlock project
Author: Your Name <you@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

Use `--yes` para aceitar todos os valores padrao:

```bash
hpm init --yes
```

## Estrutura do Projeto

Crie a estrutura basica do projeto:

```
my-project/
‚îú‚îÄ‚îÄ package.json        # Manifesto do projeto
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ index.hml      # Ponto de entrada principal
‚îî‚îÄ‚îÄ test/
    ‚îî‚îÄ‚îÄ test.hml       # Arquivo de testes
```

Crie o arquivo principal:

```bash
mkdir -p src test
```

**src/index.hml:**
```hemlock
// Ponto de entrada principal
export fn greet(name: string): string {
    return "Hello, " + name + "!";
}

export fn main() {
    print(greet("World"));
}
```

## Instalar Dependencias

Pesquise pacotes no GitHub (pacotes usam o formato `owner/repo`):

```bash
# Instalar um pacote
hpm install hemlang/sprout

# Instalar com restricao de versao
hpm install hemlang/json@^1.0.0

# Instalar como dependencia de desenvolvimento
hpm install hemlang/test-utils --dev
```

Apos a instalacao, a estrutura do seu projeto incluira `hem_modules/`:

```
my-project/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ package-lock.json   # Arquivo de lock (gerado automaticamente)
‚îú‚îÄ‚îÄ hem_modules/        # Pacotes instalados
‚îÇ   ‚îî‚îÄ‚îÄ hemlang/
‚îÇ       ‚îî‚îÄ‚îÄ sprout/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ index.hml
‚îî‚îÄ‚îÄ test/
    ‚îî‚îÄ‚îÄ test.hml
```

## Usando Pacotes Instalados

Importe pacotes usando o caminho do GitHub:

```hemlock
// Importar de pacote instalado
import { app, router } from "hemlang/sprout";
import { parse, stringify } from "hemlang/json";

// Importar de subcaminho
import { middleware } from "hemlang/sprout/middleware";

// Biblioteca padrao (embutida)
import { HashMap } from "@stdlib/collections";
import { readFile } from "@stdlib/fs";
```

## Adicionar Scripts

Adicione scripts no `package.json`:

```json
{
  "name": "myname/my-project",
  "version": "1.0.0",
  "scripts": {
    "start": "hemlock src/index.hml",
    "test": "hemlock test/test.hml",
    "build": "hemlock --bundle src/index.hml -o dist/app.hmlc"
  }
}
```

Execute scripts com `hpm run`:

```bash
hpm run start
hpm run build

# Atalho para test
hpm test
```

## Fluxos de Trabalho Comuns

### Instalar Todas as Dependencias

Quando voce clona um projeto com `package.json`:

```bash
git clone https://github.com/someone/project.git
cd project
hpm install
```

### Atualizar Dependencias

Atualize todos os pacotes para as versoes mais recentes dentro das restricoes:

```bash
hpm update
```

Atualize pacotes especificos:

```bash
hpm update hemlang/sprout
```

### Ver Pacotes Instalados

Liste todos os pacotes instalados:

```bash
hpm list
```

A saida mostra a arvore de dependencias:

```
my-project@1.0.0
‚îú‚îÄ‚îÄ hemlang/sprout@2.1.0
‚îÇ   ‚îî‚îÄ‚îÄ hemlang/router@1.5.0
‚îî‚îÄ‚îÄ hemlang/json@1.2.3
```

### Verificar Atualizacoes

Veja quais pacotes tem versoes mais recentes disponiveis:

```bash
hpm outdated
```

### Remover Pacotes

```bash
hpm uninstall hemlang/sprout
```

## Exemplo: Aplicacao Web

Aqui esta um exemplo completo usando um framework web:

**package.json:**
```json
{
  "name": "myname/my-web-app",
  "version": "1.0.0",
  "description": "A web application",
  "main": "src/index.hml",
  "dependencies": {
    "hemlang/sprout": "^2.0.0"
  },
  "scripts": {
    "start": "hemlock src/index.hml",
    "dev": "hemlock --watch src/index.hml"
  }
}
```

**src/index.hml:**
```hemlock
import { App, Router } from "hemlang/sprout";

fn main() {
    let app = App.new();
    let router = Router.new();

    router.get("/", fn(req, res) {
        res.send("Hello, World!");
    });

    router.get("/api/status", fn(req, res) {
        res.json({ status: "ok" });
    });

    app.use(router);
    app.listen(3000);

    print("Server running on http://localhost:3000");
}
```

Execute a aplicacao:

```bash
hpm install
hpm run start
```

## Proximos Passos

- [Referencia de Comandos](#hpm-quick-start-commands) - Aprenda todos os comandos do hpm
- [Criacao de Pacotes](#hpm-quick-start-creating-packages) - Publique seus proprios pacotes
- [Configuracao](#hpm-quick-start-configuration) - Configure o hpm e o token do GitHub
- [Configuracao do Projeto](#hpm-quick-start-project-setup) - Configuracao detalhada do projeto



################################################################################
# HPM: GUIA DO USU√ÅRIO
################################################################################

--------------------------------------------------------------------------------
## Comandos
--------------------------------------------------------------------------------

# Referencia de Comandos

Referencia completa de todos os comandos do hpm.

## Opcoes Globais

Estas opcoes se aplicam a qualquer comando:

| Opcao | Descricao |
|-------|-----------|
| `--help`, `-h` | Mostrar informacoes de ajuda |
| `--version`, `-v` | Mostrar versao do hpm |
| `--verbose` | Mostrar saida detalhada |

## Comandos

### hpm init

Cria um novo arquivo `package.json`.

```bash
hpm init        # Modo interativo
hpm init --yes  # Aceitar todos os valores padrao
hpm init -y     # Forma abreviada
```

**Opcoes:**

| Opcao | Descricao |
|-------|-----------|
| `--yes`, `-y` | Aceitar valores padrao para todos os prompts |

**Prompts Interativos:**
- Nome do pacote (formato owner/repo)
- Versao (padrao: 1.0.0)
- Descricao
- Autor
- Licenca (padrao: MIT)
- Arquivo principal (padrao: src/index.hml)

**Exemplo:**

```bash
$ hpm init
Package name (owner/repo): alice/my-lib
Version (1.0.0):
Description: A utility library
Author: Alice <alice@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

---

### hpm install

Instala dependencias ou adiciona novos pacotes.

```bash
hpm install                           # Instalar todas as dependencias do package.json
hpm install owner/repo                # Adicionar e instalar pacote
hpm install owner/repo@^1.0.0        # Com restricao de versao
hpm install owner/repo --dev         # Como dependencia de desenvolvimento
hpm i owner/repo                      # Forma abreviada
```

**Opcoes:**

| Opcao | Descricao |
|-------|-----------|
| `--dev`, `-D` | Adicionar a devDependencies |
| `--verbose` | Mostrar progresso detalhado |
| `--dry-run` | Visualizar sem instalar |
| `--offline` | Instalar apenas do cache (sem rede) |
| `--parallel` | Habilitar downloads paralelos (experimental) |

**Sintaxe de Restricao de Versao:**

| Sintaxe | Exemplo | Significado |
|---------|---------|-------------|
| (nenhuma) | `owner/repo` | Versao mais recente |
| Exata | `owner/repo@1.2.3` | Exatamente 1.2.3 |
| Circunflexo | `owner/repo@^1.2.3` | >=1.2.3 <2.0.0 |
| Til | `owner/repo@~1.2.3` | >=1.2.3 <1.3.0 |
| Intervalo | `owner/repo@>=1.0.0` | Pelo menos 1.0.0 |

**Exemplos:**

```bash
# Instalar todas as dependencias
hpm install

# Instalar pacote especifico
hpm install hemlang/json

# Instalar com restricao de versao
hpm install hemlang/sprout@^2.0.0

# Instalar como dependencia de desenvolvimento
hpm install hemlang/test-utils --dev

# Visualizar o que sera instalado
hpm install hemlang/sprout --dry-run

# Saida detalhada
hpm install --verbose

# Instalar apenas do cache (offline)
hpm install --offline
```

**Saida:**

```
Installing dependencies...
  + hemlang/sprout@2.1.0
  + hemlang/router@1.5.0 (dependency of hemlang/sprout)

Installed 2 packages in 1.2s
```

---

### hpm uninstall

Remove um pacote.

```bash
hpm uninstall owner/repo
hpm rm owner/repo          # Forma abreviada
hpm remove owner/repo      # Forma alternativa
```

**Exemplo:**

```bash
hpm uninstall hemlang/sprout
```

**Saida:**

```
Removed hemlang/sprout@2.1.0
Updated package.json
Updated package-lock.json
```

---

### hpm update

Atualiza pacotes para as versoes mais recentes dentro das restricoes.

```bash
hpm update              # Atualizar todos os pacotes
hpm update owner/repo   # Atualizar pacote especifico
hpm up owner/repo       # Forma abreviada
```

**Opcoes:**

| Opcao | Descricao |
|-------|-----------|
| `--verbose` | Mostrar progresso detalhado |
| `--dry-run` | Visualizar sem atualizar |

**Exemplos:**

```bash
# Atualizar todos os pacotes
hpm update

# Atualizar pacote especifico
hpm update hemlang/sprout

# Visualizar atualizacoes
hpm update --dry-run
```

**Saida:**

```
Updating dependencies...
  hemlang/sprout: 2.0.0 ‚Üí 2.1.0
  hemlang/router: 1.4.0 ‚Üí 1.5.0

Updated 2 packages
```

---

### hpm list

Mostra pacotes instalados.

```bash
hpm list              # Mostrar arvore completa de dependencias
hpm list --depth=0    # Apenas dependencias diretas
hpm list --depth=1    # Um nivel de dependencias transitivas
hpm ls                # Forma abreviada
```

**Opcoes:**

| Opcao | Descricao |
|-------|-----------|
| `--depth=N` | Limitar profundidade da arvore (padrao: todas) |

**Exemplo:**

```bash
$ hpm list
my-project@1.0.0
‚îú‚îÄ‚îÄ hemlang/sprout@2.1.0
‚îÇ   ‚îú‚îÄ‚îÄ hemlang/router@1.5.0
‚îÇ   ‚îî‚îÄ‚îÄ hemlang/middleware@1.2.0
‚îú‚îÄ‚îÄ hemlang/json@1.2.3
‚îî‚îÄ‚îÄ hemlang/test-utils@1.0.0 (dev)

$ hpm list --depth=0
my-project@1.0.0
‚îú‚îÄ‚îÄ hemlang/sprout@2.1.0
‚îú‚îÄ‚îÄ hemlang/json@1.2.3
‚îî‚îÄ‚îÄ hemlang/test-utils@1.0.0 (dev)
```

---

### hpm outdated

Mostra pacotes com versoes mais recentes disponiveis.

```bash
hpm outdated
```

**Saida:**

```
Package            Current  Wanted  Latest
hemlang/sprout     2.0.0    2.0.5   2.1.0
hemlang/router     1.4.0    1.4.2   1.5.0
```

- **Current**: Versao instalada
- **Wanted**: Versao mais alta que satisfaz a restricao
- **Latest**: Versao mais recente disponivel

---

### hpm run

Executa scripts do package.json.

```bash
hpm run <script>
hpm run <script> -- <args>
```

**Exemplo:**

Dado o seguinte package.json:

```json
{
  "scripts": {
    "start": "hemlock src/index.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/index.hml -o dist/app.hmlc"
  }
}
```

Execute scripts:

```bash
hpm run start
hpm run test
hpm run build

# Passar argumentos para o script
hpm run test -- --verbose
```

---

### hpm test

Atalho para `hpm run test`.

```bash
hpm test
hpm test -- --verbose
```

Equivalente a:

```bash
hpm run test
```

---

### hpm why

Explica por que um pacote foi instalado (mostra cadeia de dependencias).

```bash
hpm why owner/repo
```

**Exemplo:**

```bash
$ hpm why hemlang/router

hemlang/router@1.5.0 is installed because:

my-project@1.0.0
‚îî‚îÄ‚îÄ hemlang/sprout@2.1.0
    ‚îî‚îÄ‚îÄ hemlang/router@1.5.0
```

---

### hpm cache

Gerencia o cache global de pacotes.

```bash
hpm cache list    # Listar pacotes em cache
hpm cache clean   # Limpar todos os pacotes em cache
```

**Subcomandos:**

| Subcomando | Descricao |
|------------|-----------|
| `list` | Mostrar todos os pacotes em cache e tamanhos |
| `clean` | Remover todos os pacotes em cache |

**Exemplo:**

```bash
$ hpm cache list
Cached packages in ~/.hpm/cache:

hemlang/sprout
  2.0.0 (1.2 MB)
  2.1.0 (1.3 MB)
hemlang/router
  1.5.0 (450 KB)

Total: 2.95 MB

$ hpm cache clean
Cleared cache (2.95 MB freed)
```

---

## Atalhos de Comandos

Para conveniencia, varios comandos tem aliases curtos:

| Comando | Atalhos |
|---------|---------|
| `install` | `i` |
| `uninstall` | `rm`, `remove` |
| `list` | `ls` |
| `update` | `up` |

**Exemplos:**

```bash
hpm i hemlang/sprout        # hpm install hemlang/sprout
hpm rm hemlang/sprout       # hpm uninstall hemlang/sprout
hpm ls                      # hpm list
hpm up                      # hpm update
```

---

## Codigos de Saida

O hpm usa codigos de saida especificos para indicar diferentes condicoes de erro:

| Codigo | Significado |
|--------|-------------|
| 0 | Sucesso |
| 1 | Conflito de dependencias |
| 2 | Pacote nao encontrado |
| 3 | Versao nao encontrada |
| 4 | Erro de rede |
| 5 | package.json invalido |
| 6 | Verificacao de integridade falhou |
| 7 | Limite de taxa do GitHub excedido |
| 8 | Dependencia circular |

Usando codigos de saida em scripts:

```bash
hpm install
if [ $? -ne 0 ]; then
    echo "Installation failed"
    exit 1
fi
```

---

## Variaveis de Ambiente

O hpm suporta as seguintes variaveis de ambiente:

| Variavel | Descricao |
|----------|-----------|
| `GITHUB_TOKEN` | Token de API do GitHub para autenticacao |
| `HPM_CACHE_DIR` | Substituir localizacao do diretorio de cache |
| `HOME` | Diretorio home do usuario (usado para config/cache) |

**Exemplos:**

```bash
# Usar token do GitHub para limites de taxa mais altos
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Usar diretorio de cache personalizado
export HPM_CACHE_DIR=/tmp/hpm-cache
hpm install
```

---

## Veja Tambem

- [Configuracao](#hpm-commands-configuration) - Arquivos de configuracao
- [Especificacao de Pacotes](#hpm-commands-package-spec) - Formato do package.json
- [Solucao de Problemas](#hpm-commands-troubleshooting) - Problemas comuns


--------------------------------------------------------------------------------
## Configura√ß√£o
--------------------------------------------------------------------------------

# Configuracao

Este guia cobre todas as opcoes de configuracao do hpm.

## Visao Geral

O hpm pode ser configurado atraves de:

1. **Variaveis de ambiente** - Para configuracoes em tempo de execucao
2. **Arquivo de configuracao global** - `~/.hpm/config.json`
3. **Arquivos do projeto** - `package.json` e `package-lock.json`

## Variaveis de Ambiente

### GITHUB_TOKEN

Token de API do GitHub para autenticacao.

```bash
export GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx
```

**Beneficios da autenticacao:**
- Limites de taxa de API mais altos (5000 vs 60 requisicoes/hora)
- Acesso a repositorios privados
- Resolucao de dependencias mais rapida

**Criando um token:**

1. Va para GitHub ‚Üí Settings ‚Üí Developer settings ‚Üí Personal access tokens
2. Clique em "Generate new token (classic)"
3. Selecione os escopos:
   - `repo` - Para acesso a repositorios privados
   - `read:packages` - Para GitHub Packages (se usado)
4. Gere e copie o token

### HPM_CACHE_DIR

Substitui o diretorio de cache padrao.

```bash
export HPM_CACHE_DIR=/custom/cache/path
```

Padrao: `~/.hpm/cache`

**Casos de uso:**
- Sistemas CI/CD com localizacao de cache personalizada
- Compartilhamento de cache entre projetos
- Cache temporario para builds isoladas

### HOME

Diretorio home do usuario. Usado para localizar:
- Diretorio de configuracao: `$HOME/.hpm/`
- Diretorio de cache: `$HOME/.hpm/cache/`

Normalmente definido pelo sistema; substitua apenas se necessario.

### Exemplo .bashrc / .zshrc

```bash
# Autenticacao do GitHub (recomendado)
export GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx

# Localizacao de cache personalizada (opcional)
# export HPM_CACHE_DIR=/path/to/cache

# Adicionar hpm ao PATH (se usando local de instalacao personalizado)
export PATH="$HOME/.local/bin:$PATH"
```

## Arquivo de Configuracao Global

### Localizacao

`~/.hpm/config.json`

### Formato

```json
{
  "github_token": "ghp_xxxxxxxxxxxxxxxxxxxx"
}
```

### Criando o Arquivo de Configuracao

```bash
# Criar diretorio de configuracao
mkdir -p ~/.hpm

# Criar arquivo de configuracao
cat > ~/.hpm/config.json << 'EOF'
{
  "github_token": "ghp_your_token_here"
}
EOF

# Proteger o arquivo (recomendado)
chmod 600 ~/.hpm/config.json
```

### Prioridade do Token

Se ambos estiverem definidos, a variavel de ambiente tem precedencia:

1. Variavel de ambiente `GITHUB_TOKEN` (mais alta)
2. Campo `github_token` em `~/.hpm/config.json`
3. Sem autenticacao (padrao)

## Estrutura de Diretorios

### Diretorio Global

```
~/.hpm/
‚îú‚îÄ‚îÄ config.json          # Configuracao global
‚îî‚îÄ‚îÄ cache/               # Cache de pacotes
    ‚îî‚îÄ‚îÄ owner/
        ‚îî‚îÄ‚îÄ repo/
            ‚îî‚îÄ‚îÄ 1.0.0.tar.gz
```

### Diretorio do Projeto

```
my-project/
‚îú‚îÄ‚îÄ package.json         # Manifesto do projeto
‚îú‚îÄ‚îÄ package-lock.json    # Arquivo de lock de dependencias
‚îú‚îÄ‚îÄ hem_modules/         # Pacotes instalados
‚îÇ   ‚îî‚îÄ‚îÄ owner/
‚îÇ       ‚îî‚îÄ‚îÄ repo/
‚îÇ           ‚îú‚îÄ‚îÄ package.json
‚îÇ           ‚îî‚îÄ‚îÄ src/
‚îú‚îÄ‚îÄ src/                 # Codigo-fonte
‚îî‚îÄ‚îÄ test/                # Testes
```

## Cache de Pacotes

### Localizacao

Padrao: `~/.hpm/cache/`

Substitua com a variavel de ambiente `HPM_CACHE_DIR`

### Estrutura

```
~/.hpm/cache/
‚îú‚îÄ‚îÄ hemlang/
‚îÇ   ‚îú‚îÄ‚îÄ sprout/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 2.0.0.tar.gz
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 2.1.0.tar.gz
‚îÇ   ‚îî‚îÄ‚îÄ router/
‚îÇ       ‚îî‚îÄ‚îÄ 1.5.0.tar.gz
‚îî‚îÄ‚îÄ alice/
    ‚îî‚îÄ‚îÄ http-client/
        ‚îî‚îÄ‚îÄ 1.0.0.tar.gz
```

### Gerenciando o Cache

```bash
# Ver pacotes em cache
hpm cache list

# Limpar todo o cache
hpm cache clean
```

### Comportamento do Cache

- Pacotes sao armazenados em cache apos o primeiro download
- Instalacoes subsequentes usam versoes em cache
- Use `--offline` para instalar apenas do cache
- O cache e compartilhado entre todos os projetos

## Limites de Taxa da API do GitHub

### Sem Autenticacao

- **60 requisicoes por hora**, por endereco IP
- Compartilhado entre todos os usuarios nao autenticados no mesmo IP
- Pode esgotar rapidamente em CI/CD ou com muitas dependencias

### Com Autenticacao

- **5000 requisicoes por hora**, por usuario autenticado
- Limite de taxa pessoal, nao compartilhado

### Lidando com Limites de Taxa

O hpm automaticamente:
- Tenta novamente com backoff exponencial (1s, 2s, 4s, 8s)
- Relata erros de limite de taxa com codigo de saida 7
- Sugere autenticacao se limitado

**Solucoes quando limitado:**

```bash
# Opcao 1: Autenticar com token do GitHub
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Opcao 2: Esperar o limite de taxa ser resetado
# (limite reseta a cada hora)

# Opcao 3: Usar modo offline (se pacotes estao em cache)
hpm install --offline
```

## Modo Offline

Instalar pacotes sem acesso a rede:

```bash
hpm install --offline
```

**Requisitos:**
- Todos os pacotes devem estar no cache
- Arquivo de lock deve existir com versoes exatas

**Casos de uso:**
- Ambientes com rede isolada
- Builds CI/CD mais rapidas (com cache quente)
- Evitar limites de taxa

## Configuracao CI/CD

### GitHub Actions

```yaml
name: CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Setup Hemlock
      run: |
        # Instalar Hemlock (ajuste conforme sua configuracao)
        curl -sSL https://hemlock.dev/install.sh | sh

    - name: Cache hpm packages
      uses: actions/cache@v3
      with:
        path: ~/.hpm/cache
        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-hpm-

    - name: Install dependencies
      run: hpm install
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Run tests
      run: hpm test
```

### GitLab CI

```yaml
stages:
  - build
  - test

variables:
  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache

cache:
  paths:
    - .hpm-cache/
  key: $CI_COMMIT_REF_SLUG

build:
  stage: build
  script:
    - hpm install
  artifacts:
    paths:
      - hem_modules/

test:
  stage: test
  script:
    - hpm test
```

### Docker

**Dockerfile:**

```dockerfile
FROM hemlock:latest

WORKDIR /app

# Copiar arquivos de pacote primeiro (para cache de camadas)
COPY package.json package-lock.json ./

# Instalar dependencias
RUN hpm install

# Copiar codigo-fonte
COPY . .

# Executar aplicacao
CMD ["hemlock", "src/main.hml"]
```

**docker-compose.yml:**

```yaml
version: '3.8'

services:
  app:
    build: .
    environment:
      - GITHUB_TOKEN=${GITHUB_TOKEN}
    volumes:
      - hpm-cache:/root/.hpm/cache

volumes:
  hpm-cache:
```

## Configuracao de Proxy

Para ambientes atras de um proxy, configure no nivel do sistema:

```bash
export HTTP_PROXY=http://proxy.example.com:8080
export HTTPS_PROXY=http://proxy.example.com:8080
export NO_PROXY=localhost,127.0.0.1

hpm install
```

## Melhores Praticas de Seguranca

### Seguranca do Token

1. **Nunca comite tokens** no controle de versao
2. **Use variaveis de ambiente** em CI/CD
3. **Limite escopos do token** ao minimo necessario
4. **Rotacione tokens regularmente**
5. **Proteja arquivos de configuracao**:
   ```bash
   chmod 600 ~/.hpm/config.json
   ```

### Repositorios Privados

Para acessar pacotes privados:

1. Crie um token com escopo `repo`
2. Configure autenticacao (variavel de ambiente ou arquivo de configuracao)
3. Garanta que o token tem acesso ao repositorio

```bash
# Testar acesso
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install yourorg/private-package
```

## Solucao de Problemas de Configuracao

### Verificando Configuracao

```bash
# Verificar se token esta definido
echo $GITHUB_TOKEN | head -c 10

# Verificar arquivo de configuracao
cat ~/.hpm/config.json

# Verificar diretorio de cache
ls -la ~/.hpm/cache/

# Testar com saida detalhada
hpm install --verbose
```

### Problemas Comuns

**"GitHub rate limit exceeded"**
- Configure autenticacao com `GITHUB_TOKEN`
- Espere o limite de taxa resetar
- Use `--offline` se pacotes estao em cache

**"Permission denied" no cache**
```bash
# Corrigir permissoes do cache
chmod -R u+rw ~/.hpm/cache
```

**"Config file not found"**
```bash
# Criar diretorio de configuracao
mkdir -p ~/.hpm
touch ~/.hpm/config.json
```

## Veja Tambem

- [Instalacao](#hpm-configuration-installation) - Instalando o hpm
- [Solucao de Problemas](#hpm-configuration-troubleshooting) - Problemas comuns
- [Comandos](#hpm-configuration-commands) - Referencia de comandos


--------------------------------------------------------------------------------
## Solu√ß√£o de Problemas
--------------------------------------------------------------------------------

# Solucao de Problemas

Solucoes para problemas comuns do hpm.

## Problemas de Instalacao

### "hemlock: command not found"

**Causa:** O Hemlock nao esta instalado ou nao esta no PATH.

**Solucao:**

```bash
# Verificar se hemlock existe
which hemlock

# Se nao encontrado, instale o Hemlock primeiro
# Visite: https://github.com/hemlang/hemlock

# Apos a instalacao, verifique
hemlock --version
```

### "hpm: command not found"

**Causa:** O hpm nao esta instalado ou nao esta no PATH.

**Solucao:**

```bash
# Verificar localizacao da instalacao do hpm
ls -la /usr/local/bin/hpm
ls -la ~/.local/bin/hpm

# Se usando local personalizado, adicionar ao PATH
export PATH="$HOME/.local/bin:$PATH"

# Adicionar ao ~/.bashrc ou ~/.zshrc para persistir
echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc

# Se necessario, reinstale
cd /path/to/hpm
sudo make install
```

### "Permission denied" durante instalacao

**Causa:** Sem permissao de escrita no diretorio de instalacao.

**Solucao:**

```bash
# Opcao 1: Usar sudo para instalacao em todo o sistema
sudo make install

# Opcao 2: Instalar no diretorio do usuario (sem sudo)
make install PREFIX=$HOME/.local
```

## Problemas de Dependencias

### "Package not found" (codigo de saida 2)

**Causa:** O pacote nao existe no GitHub.

**Solucao:**

```bash
# Verificar se o pacote existe
# Visite: https://github.com/owner/repo

# Verificar ortografia
hpm install hemlang/sprout  # Correto
hpm install hemlan/sprout   # Owner errado
hpm install hemlang/spout   # Repo errado

# Verificar erros de digitacao no package.json
cat package.json | grep -A 5 dependencies
```

### "Version not found" (codigo de saida 3)

**Causa:** Nenhuma versao publicada corresponde a restricao de versao.

**Solucao:**

```bash
# Listar versoes disponiveis (verificar releases/tags do GitHub)
# Tags devem comecar com 'v' (ex: v1.0.0)

# Usar uma restricao de versao valida
hpm install owner/repo@^1.0.0

# Tentar a versao mais recente
hpm install owner/repo

# Verificar tags disponiveis no GitHub
# https://github.com/owner/repo/tags
```

### "Dependency conflict" (codigo de saida 1)

**Causa:** Dois pacotes requerem versoes incompativeis de uma dependencia.

**Solucao:**

```bash
# Ver conflitos
hpm install --verbose

# Verificar o que requer a dependencia
hpm why conflicting/package

# Solucoes:
# 1. Atualizar pacotes conflitantes
hpm update problem/package

# 2. Alterar restricoes de versao no package.json
# Editar para permitir versoes compativeis

# 3. Remover um dos pacotes conflitantes
hpm uninstall one/package
```

### "Circular dependency" (codigo de saida 8)

**Causa:** Pacote A depende de B, e B depende de A.

**Solucao:**

```bash
# Identificar o ciclo
hpm install --verbose

# Isso geralmente e um bug no pacote
# Contatar o mantenedor do pacote

# Solucao alternativa: evitar usar um dos pacotes
```

## Problemas de Rede

### "Network error" (codigo de saida 4)

**Causa:** Nao foi possivel conectar a API do GitHub.

**Solucao:**

```bash
# Verificar conexao de rede
ping github.com

# Verificar se API do GitHub esta acessivel
curl -I https://api.github.com

# Tentar novamente (hpm tenta automaticamente)
hpm install

# Se pacotes estao em cache, usar modo offline
hpm install --offline

# Se atras de firewall, verificar configuracoes de proxy
export HTTPS_PROXY=http://proxy:8080
hpm install
```

### "GitHub rate limit exceeded" (codigo de saida 7)

**Causa:** Muitas requisicoes de API sem autenticacao.

**Solucao:**

```bash
# Opcao 1: Autenticar com token do GitHub (recomendado)
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Criar token: GitHub ‚Üí Settings ‚Üí Developer settings ‚Üí Personal access tokens

# Opcao 2: Salvar token no arquivo de configuracao
mkdir -p ~/.hpm
echo '{"github_token": "ghp_xxxxxxxxxxxx"}' > ~/.hpm/config.json

# Opcao 3: Esperar limite de taxa resetar (reseta a cada hora)

# Opcao 4: Usar modo offline
hpm install --offline
```

### Timeout de conexao

**Causa:** Rede lenta ou problemas na API do GitHub.

**Solucao:**

```bash
# hpm tenta automaticamente com backoff exponencial

# Verificar se GitHub esta com problemas
# Visite: https://www.githubstatus.com

# Tentar novamente mais tarde
hpm install

# Usar pacotes em cache
hpm install --offline
```

## Problemas do Package.json

### "Invalid package.json" (codigo de saida 5)

**Causa:** Formato incorreto ou campos obrigatorios ausentes.

**Solucao:**

```bash
# Validar sintaxe JSON
cat package.json | python -m json.tool

# Verificar campos obrigatorios
cat package.json

# Campos obrigatorios:
# - "name": formato owner/repo
# - "version": formato X.Y.Z

# Se necessario, regenerar
rm package.json
hpm init
```

### Formato incorreto do "name"

**Causa:** Nome do pacote nao esta no formato `owner/repo`.

**Solucao:**

```json
// Errado
{
  "name": "my-package"
}

// Correto
{
  "name": "yourusername/my-package"
}
```

### Formato incorreto da "version"

**Causa:** Versao nao esta no formato semver.

**Solucao:**

```json
// Errado
{
  "version": "1.0"
}

// Correto
{
  "version": "1.0.0"
}
```

## Problemas do Arquivo de Lock

### Arquivo de lock dessincronizado

**Causa:** package.json foi modificado sem executar install.

**Solucao:**

```bash
# Regenerar arquivo de lock
rm package-lock.json
hpm install
```

### Arquivo de lock corrompido

**Causa:** JSON invalido ou edicao manual.

**Solucao:**

```bash
# Verificar validade do JSON
cat package-lock.json | python -m json.tool

# Regenerar
rm package-lock.json
hpm install
```

## Problemas do hem_modules

### Pacote nao instalado

**Causa:** Varios problemas possiveis.

**Solucao:**

```bash
# Limpar e reinstalar
rm -rf hem_modules
hpm install

# Verificar saida detalhada
hpm install --verbose
```

### Import nao funciona

**Causa:** Pacote nao instalado corretamente ou caminho de import errado.

**Solucao:**

```bash
# Verificar se pacote esta instalado
ls hem_modules/owner/repo/

# Verificar campo main do package.json
cat hem_modules/owner/repo/package.json

# Formato correto de import
import { x } from "owner/repo";          # Usa entrada main
import { y } from "owner/repo/subpath";  # Import de subcaminho
```

### Erro "Module not found"

**Causa:** Caminho de import nao resolve para um arquivo.

**Solucao:**

```bash
# Verificar caminho de import
ls hem_modules/owner/repo/src/

# Verificar index.hml
ls hem_modules/owner/repo/src/index.hml

# Verificar campo main no package.json
cat hem_modules/owner/repo/package.json | grep main
```

## Problemas de Cache

### Cache ocupando muito espaco

**Solucao:**

```bash
# Ver tamanho do cache
hpm cache list

# Limpar cache
hpm cache clean
```

### Permissoes do cache

**Solucao:**

```bash
# Corrigir permissoes
chmod -R u+rw ~/.hpm/cache

# Ou remover e reinstalar
rm -rf ~/.hpm/cache
hpm install
```

### Usando cache errado

**Solucao:**

```bash
# Verificar localizacao do cache
echo $HPM_CACHE_DIR
ls ~/.hpm/cache

# Se incorreto, limpar variavel de ambiente
unset HPM_CACHE_DIR
```

## Problemas de Scripts

### "Script not found"

**Causa:** Nome do script nao existe no package.json.

**Solucao:**

```bash
# Listar scripts disponiveis
cat package.json | grep -A 20 scripts

# Verificar ortografia
hpm run test    # Correto
hpm run tests   # Errado se o script e chamado "test"
```

### Script falha

**Causa:** Erro no comando do script.

**Solucao:**

```bash
# Executar comando diretamente para ver erro
hemlock test/run.hml

# Verificar definicao do script
cat package.json | grep test
```

## Depuracao

### Habilitar saida detalhada

```bash
hpm install --verbose
```

### Verificar versao do hpm

```bash
hpm --version
```

### Verificar versao do hemlock

```bash
hemlock --version
```

### Execucao simulada

Visualizar sem fazer alteracoes:

```bash
hpm install --dry-run
```

### Comecar do zero

Reiniciar completamente:

```bash
rm -rf hem_modules package-lock.json
hpm install
```

## Obtendo Ajuda

### Ajuda de comandos

```bash
hpm --help
hpm install --help
```

### Reportando problemas

Se encontrar um bug:

1. Verifique issues existentes: https://github.com/hemlang/hpm/issues
2. Crie um novo issue incluindo:
   - Versao do hpm (`hpm --version`)
   - Versao do Hemlock (`hemlock --version`)
   - Sistema operacional
   - Passos para reproduzir
   - Mensagem de erro (use `--verbose`)

## Referencia de Codigos de Saida

| Codigo | Significado | Solucao Comum |
|--------|-------------|---------------|
| 0 | Sucesso | - |
| 1 | Conflito de dependencias | Atualizar ou alterar restricoes |
| 2 | Pacote nao encontrado | Verificar ortografia, confirmar que repo existe |
| 3 | Versao nao encontrada | Verificar versoes disponiveis no GitHub |
| 4 | Erro de rede | Verificar conexao, tentar novamente |
| 5 | package.json invalido | Corrigir sintaxe JSON e campos obrigatorios |
| 6 | Verificacao de integridade falhou | Limpar cache, reinstalar |
| 7 | Limite de taxa do GitHub | Adicionar GITHUB_TOKEN |
| 8 | Dependencia circular | Contatar mantenedor do pacote |

## Veja Tambem

- [Instalacao](#hpm-troubleshooting-installation) - Guia de instalacao
- [Configuracao](#hpm-troubleshooting-configuration) - Opcoes de configuracao
- [Comandos](#hpm-troubleshooting-commands) - Referencia de comandos



################################################################################
# HPM: DESENVOLVIMENTO DE PACOTES
################################################################################

--------------------------------------------------------------------------------
## Cria√ß√£o de Pacotes
--------------------------------------------------------------------------------

# Criacao de Pacotes

Este guia explica como criar, organizar e publicar pacotes Hemlock.

## Visao Geral

O hpm usa o GitHub como seu registro de pacotes. Os pacotes sao identificados pelo caminho `owner/repo` do GitHub, e as versoes sao tags Git. Publicar e simplesmente enviar releases com tags.

## Criando um Novo Pacote

### 1. Inicializar o Pacote

Crie um novo diretorio e inicialize:

```bash
mkdir my-package
cd my-package
hpm init
```

Responda aos prompts:

```
Package name (owner/repo): yourusername/my-package
Version (1.0.0):
Description: A useful Hemlock package
Author: Your Name <you@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

### 2. Criar Estrutura do Projeto

Estrutura recomendada para um pacote:

```
my-package/
‚îú‚îÄ‚îÄ package.json          # Manifesto do pacote
‚îú‚îÄ‚îÄ README.md             # Documentacao
‚îú‚îÄ‚îÄ LICENSE               # Arquivo de licenca
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ index.hml         # Ponto de entrada principal (exporta API publica)
‚îÇ   ‚îú‚îÄ‚îÄ utils.hml         # Utilitarios internos
‚îÇ   ‚îî‚îÄ‚îÄ types.hml         # Definicoes de tipos
‚îî‚îÄ‚îÄ test/
    ‚îú‚îÄ‚îÄ framework.hml     # Framework de testes
    ‚îî‚îÄ‚îÄ test_utils.hml    # Testes
```

### 3. Definir sua API Publica

**src/index.hml** - Ponto de entrada principal:

```hemlock
// Re-exportar API publica
export { parse, stringify } from "./parser.hml";
export { Config, Options } from "./types.hml";
export { process } from "./processor.hml";

// Exports diretos
export fn create(options: Options): Config {
    // Implementacao
}

export fn validate(config: Config): bool {
    // Implementacao
}
```

### 4. Escrever seu package.json

Exemplo completo de package.json:

```json
{
  "name": "yourusername/my-package",
  "version": "1.0.0",
  "description": "A useful Hemlock package",
  "author": "Your Name <you@example.com>",
  "license": "MIT",
  "repository": "https://github.com/yourusername/my-package",
  "main": "src/index.hml",
  "dependencies": {
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  },
  "scripts": {
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/index.hml -o dist/bundle.hmlc"
  },
  "keywords": ["utility", "parser", "config"],
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ]
}
```

## Nomeacao de Pacotes

### Requisitos

- Deve estar no formato `owner/repo`
- `owner` deve ser seu nome de usuario ou organizacao do GitHub
- `repo` deve ser o nome do repositorio
- Use letras minusculas e hifens para nomes com varias palavras

### Bons Nomes

```
hemlang/sprout
alice/http-client
myorg/json-utils
bob/date-formatter
```

### Evite

```
my-package          # Falta owner
alice/MyPackage     # PascalCase
alice/my_package    # Underscores
```

## Melhores Praticas de Estrutura de Pacotes

### Ponto de Entrada

O campo `main` no package.json especifica o ponto de entrada:

```json
{
  "main": "src/index.hml"
}
```

Este arquivo deve exportar sua API publica:

```hemlock
// Exportar tudo que os usuarios precisam
export { Parser, parse } from "./parser.hml";
export { Formatter, format } from "./formatter.hml";

// Tipos
export type { Config, Options } from "./types.hml";
```

### Interno vs Publico

Mantenha detalhes de implementacao interna privados:

```
src/
‚îú‚îÄ‚îÄ index.hml          # Publico: API exportada
‚îú‚îÄ‚îÄ parser.hml         # Publico: usado pelo index.hml
‚îú‚îÄ‚îÄ formatter.hml      # Publico: usado pelo index.hml
‚îî‚îÄ‚îÄ internal/
    ‚îú‚îÄ‚îÄ helpers.hml    # Privado: apenas para uso interno
    ‚îî‚îÄ‚îÄ constants.hml  # Privado: apenas para uso interno
```

Usuarios importam da raiz do seu pacote:

```hemlock
// Bom - importa da API publica
import { parse, Parser } from "yourusername/my-package";

// Tambem funciona - import de subcaminho
import { validate } from "yourusername/my-package/validator";

// Desencorajado - acessando internos
import { helper } from "yourusername/my-package/internal/helpers";
```

### Exports de Subcaminho

Suporte imports de subcaminhos:

```
src/
‚îú‚îÄ‚îÄ index.hml              # Entrada principal
‚îú‚îÄ‚îÄ parser/
‚îÇ   ‚îî‚îÄ‚îÄ index.hml          # yourusername/pkg/parser
‚îú‚îÄ‚îÄ formatter/
‚îÇ   ‚îî‚îÄ‚îÄ index.hml          # yourusername/pkg/formatter
‚îî‚îÄ‚îÄ utils/
    ‚îî‚îÄ‚îÄ index.hml          # yourusername/pkg/utils
```

Usuarios podem importar:

```hemlock
import { parse } from "yourusername/my-package";           // Principal
import { Parser } from "yourusername/my-package/parser";   // Subcaminho
import { format } from "yourusername/my-package/formatter";
```

## Dependencias

### Adicionando Dependencias

```bash
# Dependencias de tempo de execucao
hpm install hemlang/json

# Dependencias de desenvolvimento
hpm install hemlang/test-utils --dev
```

### Melhores Praticas para Dependencias

1. **Use intervalos de circunflexo para a maioria das dependencias**:
   ```json
   {
     "dependencies": {
       "hemlang/json": "^1.0.0"
     }
   }
   ```

2. **Trave versoes apenas quando necessario** (API instavel):
   ```json
   {
     "dependencies": {
       "unstable/lib": "1.2.3"
     }
   }
   ```

3. **Evite intervalos muito restritivos**:
   ```json
   // Ruim: muito restritivo
   "hemlang/json": ">=1.2.3 <1.2.5"

   // Bom: permite atualizacoes compativeis
   "hemlang/json": "^1.2.3"
   ```

4. **Separe dependencias de desenvolvimento**:
   ```json
   {
     "dependencies": {
       "hemlang/json": "^1.0.0"
     },
     "devDependencies": {
       "hemlang/test-utils": "^1.0.0"
     }
   }
   ```

## Testando seu Pacote

### Escrevendo Testes

**test/run.hml:**

```hemlock
import { suite, test, assert_eq } from "./framework.hml";
import { parse, stringify } from "../src/index.hml";

fn run_tests() {
    suite("Parser", fn() {
        test("parses valid input", fn() {
            let result = parse("hello");
            assert_eq(result.value, "hello");
        });

        test("handles empty input", fn() {
            let result = parse("");
            assert_eq(result.value, "");
        });
    });

    suite("Stringify", fn() {
        test("stringifies object", fn() {
            let obj = { name: "test" };
            let result = stringify(obj);
            assert_eq(result, '{"name":"test"}');
        });
    });
}

run_tests();
```

### Executando Testes

Adicione um script de teste:

```json
{
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
```

Execute:

```bash
hpm test
```

## Publicacao

### Pre-requisitos

1. Crie um repositorio GitHub que corresponda ao nome do seu pacote
2. Garanta que `package.json` esta completo e valido
3. Todos os testes passando

### Processo de Publicacao

Publicar e simplesmente enviar tags Git:

```bash
# 1. Garanta que tudo esta commitado
git add .
git commit -m "Prepare v1.0.0 release"

# 2. Criar tag de versao (deve comecar com 'v')
git tag v1.0.0

# 3. Enviar codigo e tags
git push origin main
git push origin v1.0.0
# Ou enviar todas as tags de uma vez
git push origin main --tags
```

### Tags de Versao

Tags devem seguir o formato `vX.Y.Z`:

```bash
git tag v1.0.0      # Release
git tag v1.0.1      # Patch
git tag v1.1.0      # Minor
git tag v2.0.0      # Major
git tag v1.0.0-beta.1  # Pre-release
```

### Checklist de Publicacao

Antes de publicar uma nova versao:

1. **Atualizar** versao no package.json
2. **Executar testes**: `hpm test`
3. **Atualizar CHANGELOG** (se tiver)
4. **Atualizar README** (se a API mudou)
5. **Commitar alteracoes**
6. **Criar tag**
7. **Enviar para o GitHub**

### Exemplo de Automacao

Criar um script de release:

```bash
#!/bin/bash
# release.sh - Publicar uma nova versao

VERSION=$1

if [ -z "$VERSION" ]; then
    echo "Usage: ./release.sh 1.0.0"
    exit 1
fi

# Executar testes
hpm test || exit 1

# Atualizar versao no package.json
sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json

# Commitar e criar tag
git add package.json
git commit -m "Release v$VERSION"
git tag "v$VERSION"

# Enviar
git push origin main --tags

echo "Released v$VERSION"
```

## Usuarios Instalando seu Pacote

Apos a publicacao, usuarios podem instalar:

```bash
# Versao mais recente
hpm install yourusername/my-package

# Versao especifica
hpm install yourusername/my-package@1.0.0

# Restricao de versao
hpm install yourusername/my-package@^1.0.0
```

E importar:

```hemlock
import { parse, stringify } from "yourusername/my-package";
```

## Documentacao

### README.md

Todo pacote deve ter um README:

```markdown
# my-package

A brief description of what this package does.

## Installation

\`\`\`bash
hpm install yourusername/my-package
\`\`\`

## Usage

\`\`\`hemlock
import { parse } from "yourusername/my-package";

let result = parse("input");
\`\`\`

## API

### parse(input: string): Result

Parses the input string.

### stringify(obj: any): string

Converts object to string.

## License

MIT
```

### Documentacao da API

Documente todos os exports publicos:

```hemlock
/// Analisa a string de entrada em um Result estruturado.
///
/// # Argumentos
/// * `input` - A string a ser analisada
///
/// # Retorna
/// Um Result contendo os dados analisados ou um erro
///
/// # Exemplo
/// ```
/// let result = parse("hello world");
/// print(result.value);
/// ```
export fn parse(input: string): Result {
    // Implementacao
}
```

## Guia de Versionamento

Siga o [Versionamento Semantico](https://semver.org/):

- **MAJOR** (1.0.0 ‚Üí 2.0.0): Mudancas incompativeis
- **MINOR** (1.0.0 ‚Üí 1.1.0): Novos recursos, compativel com versoes anteriores
- **PATCH** (1.0.0 ‚Üí 1.0.1): Correcoes de bugs, compativel com versoes anteriores

### Quando Incrementar

| Tipo de Mudanca | Incremento de Versao |
|-----------------|---------------------|
| Mudanca incompativel de API | MAJOR |
| Remocao de funcao/tipo | MAJOR |
| Alteracao de assinatura de funcao | MAJOR |
| Adicionar nova funcao | MINOR |
| Adicionar novo recurso | MINOR |
| Correcao de bug | PATCH |
| Atualizacao de documentacao | PATCH |
| Refatoracao interna | PATCH |

## Veja Tambem

- [Especificacao de Pacotes](#hpm-creating-packages-package-spec) - Referencia completa do package.json
- [Versionamento](#hpm-creating-packages-versioning) - Detalhes do versionamento semantico
- [Configuracao](#hpm-creating-packages-configuration) - Autenticacao do GitHub


--------------------------------------------------------------------------------
## Especifica√ß√£o de Pacotes
--------------------------------------------------------------------------------

# Especificacao de Pacotes

Referencia completa do formato do arquivo `package.json`.

## Visao Geral

Todo pacote hpm requer um arquivo `package.json` na raiz do projeto. Este arquivo define metadados do pacote, dependencias e scripts.

## Exemplo Minimo

```json
{
  "name": "owner/repo",
  "version": "1.0.0"
}
```

## Exemplo Completo

```json
{
  "name": "hemlang/example-package",
  "version": "1.2.3",
  "description": "An example Hemlock package",
  "author": "Hemlock Team <team@hemlock.dev>",
  "license": "MIT",
  "repository": "https://github.com/hemlang/example-package",
  "homepage": "https://hemlang.github.io/example-package",
  "bugs": "https://github.com/hemlang/example-package/issues",
  "main": "src/index.hml",
  "keywords": ["example", "utility", "hemlock"],
  "dependencies": {
    "hemlang/json": "^1.0.0",
    "hemlang/http": "^2.1.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  },
  "scripts": {
    "start": "hemlock src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/bundle.hmlc"
  },
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ],
  "native": {
    "requires": ["libcurl", "openssl"]
  }
}
```

## Referencia de Campos

### name (obrigatorio)

Nome do pacote no formato `owner/repo`.

```json
{
  "name": "hemlang/sprout"
}
```

**Requisitos:**
- Deve estar no formato `owner/repo`
- `owner` deve ser seu nome de usuario ou organizacao do GitHub
- `repo` deve ser o nome do repositorio
- Use letras minusculas, numeros e hifens
- Maximo de 214 caracteres no total

**Nomes validos:**
```
hemlang/sprout
alice/http-client
myorg/json-utils
bob123/my-lib
```

**Nomes invalidos:**
```
my-package          # Falta owner
hemlang/My_Package  # Maiusculas e underscores
hemlang             # Falta repo
```

### version (obrigatorio)

Versao do pacote seguindo [Versionamento Semantico](https://semver.org/).

```json
{
  "version": "1.2.3"
}
```

**Formato:** `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`

**Versoes validas:**
```
1.0.0
2.1.3
1.0.0-alpha
1.0.0-beta.1
1.0.0-rc.1+build.123
0.1.0
```

### description

Descricao curta do pacote.

```json
{
  "description": "A fast JSON parser for Hemlock"
}
```

- Mantenha abaixo de 200 caracteres
- Descreva o que o pacote faz, nao como

### author

Informacoes do autor do pacote.

```json
{
  "author": "Your Name <email@example.com>"
}
```

**Formatos aceitos:**
```json
"author": "Your Name"
"author": "Your Name <email@example.com>"
"author": "Your Name <email@example.com> (https://website.com)"
```

### license

Identificador da licenca.

```json
{
  "license": "MIT"
}
```

**Licencas comuns:**
- `MIT` - Licenca MIT
- `Apache-2.0` - Licenca Apache 2.0
- `GPL-3.0` - GNU General Public License v3.0
- `BSD-3-Clause` - Licenca BSD 3-Clause
- `ISC` - Licenca ISC
- `UNLICENSED` - Proprietario/privado

Use [identificadores SPDX](https://spdx.org/licenses/) quando possivel.

### repository

Link para o repositorio fonte.

```json
{
  "repository": "https://github.com/hemlang/sprout"
}
```

### homepage

URL da pagina inicial do projeto.

```json
{
  "homepage": "https://sprout.hemlock.dev"
}
```

### bugs

URL do rastreador de issues.

```json
{
  "bugs": "https://github.com/hemlang/sprout/issues"
}
```

### main

Arquivo de ponto de entrada do pacote.

```json
{
  "main": "src/index.hml"
}
```

**Padrao:** `src/index.hml`

Quando usuarios importam seu pacote:
```hemlock
import { x } from "owner/repo";
```

O hpm carrega o arquivo especificado em `main`.

**Ordem de resolucao de imports:**
1. Caminho exato: `src/index.hml`
2. Com extensao .hml: `src/index` ‚Üí `src/index.hml`
3. Arquivo index: `src/index/` ‚Üí `src/index/index.hml`

### keywords

Array de palavras-chave para descoberta.

```json
{
  "keywords": ["json", "parser", "utility", "hemlock"]
}
```

- Use minusculas
- Seja especifico e relevante
- Inclua a linguagem ("hemlock") se apropriado

### dependencies

Dependencias de tempo de execucao necessarias para o pacote funcionar.

```json
{
  "dependencies": {
    "hemlang/json": "^1.0.0",
    "hemlang/http": "~2.1.0",
    "alice/logger": ">=1.0.0 <2.0.0"
  }
}
```

**Chave:** Nome do pacote (`owner/repo`)
**Valor:** Restricao de versao

**Sintaxe de restricao de versao:**

| Restricao | Significado |
|-----------|-------------|
| `1.2.3` | Versao exata |
| `^1.2.3` | >=1.2.3 <2.0.0 |
| `~1.2.3` | >=1.2.3 <1.3.0 |
| `>=1.0.0` | Pelo menos 1.0.0 |
| `>=1.0.0 <2.0.0` | Intervalo |
| `*` | Qualquer versao |

### devDependencies

Dependencias apenas para desenvolvimento (testes, build, etc.).

```json
{
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0",
    "hemlang/linter": "^2.0.0"
  }
}
```

Dependencias de desenvolvimento sao:
- Instaladas durante o desenvolvimento
- Nao instaladas quando o pacote e usado como dependencia
- Usadas para testes, build, linting, etc.

### scripts

Comandos nomeados que podem ser executados com `hpm run`.

```json
{
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "test:unit": "hemlock test/unit/run.hml",
    "test:integration": "hemlock test/integration/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc",
    "clean": "rm -rf dist hem_modules",
    "lint": "hemlock-lint src/",
    "format": "hemlock-fmt src/"
  }
}
```

**Executando scripts:**
```bash
hpm run start
hpm run build
hpm test        # Atalho para 'hpm run test'
```

**Passando argumentos:**
```bash
hpm run test -- --verbose --filter=unit
```

**Scripts comuns:**

| Script | Proposito |
|--------|-----------|
| `start` | Iniciar a aplicacao |
| `dev` | Modo de desenvolvimento com hot reload |
| `test` | Executar testes |
| `build` | Compilar para producao |
| `clean` | Remover artefatos de build |
| `lint` | Verificar estilo de codigo |
| `format` | Formatar codigo |

### files

Arquivos e diretorios a incluir quando o pacote e instalado.

```json
{
  "files": [
    "src/",
    "lib/",
    "LICENSE",
    "README.md"
  ]
}
```

**Comportamento padrao:** Se nao especificado, inclui:
- Todos os arquivos no repositorio
- Exclui `.git/`, `node_modules/`, `hem_modules/`

**Usado para:**
- Reduzir tamanho do pacote
- Excluir arquivos de teste da distribuicao
- Incluir apenas arquivos necessarios

### native

Requisitos de bibliotecas nativas.

```json
{
  "native": {
    "requires": ["libcurl", "openssl", "sqlite3"]
  }
}
```

Documenta dependencias nativas que devem estar instaladas no sistema.

## Validacao

O hpm valida package.json durante varias operacoes. Erros comuns de validacao:

### Campo obrigatorio ausente

```
Error: package.json missing required field: name
```

**Correcao:** Adicionar campo obrigatorio.

### Formato de nome invalido

```
Error: Invalid package name. Must be in owner/repo format.
```

**Correcao:** Usar formato `owner/repo`.

### Versao invalida

```
Error: Invalid version "1.0". Must be semver format (X.Y.Z).
```

**Correcao:** Usar formato semver completo (`1.0.0`).

### JSON invalido

```
Error: package.json is not valid JSON
```

**Correcao:** Verificar sintaxe JSON (virgulas, aspas, chaves).

## Criando package.json

### Interativo

```bash
hpm init
```

Solicita interativamente cada campo.

### Com valores padrao

```bash
hpm init --yes
```

Cria com valores padrao:
```json
{
  "name": "directory-name/directory-name",
  "version": "1.0.0",
  "description": "",
  "author": "",
  "license": "MIT",
  "main": "src/index.hml",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
```

### Manual

Criar arquivo manualmente:

```bash
cat > package.json << 'EOF'
{
  "name": "yourname/your-package",
  "version": "1.0.0",
  "description": "Your package description",
  "main": "src/index.hml",
  "dependencies": {},
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
EOF
```

## Melhores Praticas

1. **Sempre especifique main** - Nao dependa do padrao
2. **Use intervalos de circunflexo** - `^1.0.0` para a maioria das dependencias
3. **Separe dependencias de desenvolvimento** - Coloque dependencias de teste/build em devDependencies
4. **Inclua palavras-chave** - Ajude usuarios a encontrar seu pacote
5. **Documente scripts** - Nomeie scripts claramente
6. **Especifique licenca** - Obrigatorio para projetos open source
7. **Adicione descricao** - Ajude usuarios a entender o proposito

## Veja Tambem

- [Criacao de Pacotes](#hpm-package-spec-creating-packages) - Guia de publicacao
- [Versionamento](#hpm-package-spec-versioning) - Restricoes de versao
- [Configuracao do Projeto](#hpm-package-spec-project-setup) - Estrutura do projeto


--------------------------------------------------------------------------------
## Versionamento
--------------------------------------------------------------------------------

# Versionamento

Guia completo de versionamento semantico no hpm.

## Versionamento Semantico

O hpm usa [Versionamento Semantico 2.0.0](https://semver.org/) (semver) para versoes de pacotes.

### Formato de Versao

```
MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]
```

**Exemplos:**
```
1.0.0           # Versao de release
2.1.3           # Versao de release
1.0.0-alpha     # Pre-release
1.0.0-beta.1    # Pre-release numerado
1.0.0-rc.1      # Release candidate
1.0.0+20231201  # Com metadados de build
1.0.0-beta+exp  # Pre-release com metadados de build
```

### Componentes da Versao

| Componente | Descricao | Exemplo |
|------------|-----------|---------|
| MAJOR | Mudancas incompativeis | `1.0.0` ‚Üí `2.0.0` |
| MINOR | Novos recursos (compativel) | `1.0.0` ‚Üí `1.1.0` |
| PATCH | Correcoes de bugs (compativel) | `1.0.0` ‚Üí `1.0.1` |
| PRERELEASE | Identificador de pre-release | `1.0.0-alpha` |
| BUILD | Metadados de build (ignorado na comparacao) | `1.0.0+build123` |

### Quando Incrementar

| Tipo de Mudanca | Incremento | Exemplo |
|-----------------|------------|---------|
| Mudanca incompativel de API | MAJOR | Remover funcao |
| Renomear funcao publica | MAJOR | `parse()` ‚Üí `decode()` |
| Mudar assinatura de funcao | MAJOR | Adicionar parametro obrigatorio |
| Adicionar nova funcao | MINOR | Adicionar `validate()` |
| Adicionar parametro opcional | MINOR | Novo parametro `options` opcional |
| Correcao de bug | PATCH | Corrigir null pointer |
| Melhoria de performance | PATCH | Algoritmo mais rapido |
| Refatoracao interna | PATCH | Sem mudanca de API |

## Restricoes de Versao

### Sintaxe de Restricoes

| Sintaxe | Significado | Resolve para |
|---------|-------------|--------------|
| `1.2.3` | Versao exata | Apenas 1.2.3 |
| `^1.2.3` | Circunflexo (compativel) | >=1.2.3 e <2.0.0 |
| `~1.2.3` | Til (atualizacoes de patch) | >=1.2.3 e <1.3.0 |
| `>=1.0.0` | Pelo menos | 1.0.0 ou superior |
| `>1.0.0` | Maior que | Superior a 1.0.0 |
| `<2.0.0` | Menor que | Inferior a 2.0.0 |
| `<=2.0.0` | No maximo | 2.0.0 ou inferior |
| `>=1.0.0 <2.0.0` | Intervalo | Entre 1.0.0 e 2.0.0 |
| `*` | Qualquer | Qualquer versao |

### Intervalo de Circunflexo (^)

O circunflexo (`^`) permite mudancas que nao modificam o digito nao-zero mais a esquerda:

```
^1.2.3  ‚Üí  >=1.2.3 <2.0.0   # Permite 1.x.x
^0.2.3  ‚Üí  >=0.2.3 <0.3.0   # Permite 0.2.x
^0.0.3  ‚Üí  >=0.0.3 <0.0.4   # Permite apenas 0.0.3
```

**Caso de uso:** Voce quer atualizacoes compativeis dentro da versao major.

**Restricao mais comum** - Recomendada para a maioria das dependencias.

### Intervalo de Til (~)

O til (`~`) permite apenas mudancas de patch:

```
~1.2.3  ‚Üí  >=1.2.3 <1.3.0   # Permite 1.2.x
~1.2    ‚Üí  >=1.2.0 <1.3.0   # Permite 1.2.x
~1      ‚Üí  >=1.0.0 <2.0.0   # Permite 1.x.x
```

**Caso de uso:** Voce quer apenas correcoes de bugs, sem novos recursos.

### Intervalos de Comparacao

Combine operadores de comparacao para controle preciso:

```json
{
  "dependencies": {
    "owner/pkg": ">=1.0.0 <2.0.0",
    "owner/other": ">1.5.0 <=2.1.0"
  }
}
```

### Qualquer Versao (*)

Corresponde a qualquer versao:

```json
{
  "dependencies": {
    "owner/pkg": "*"
  }
}
```

**Aviso:** Nao recomendado para producao. Sempre obtera a versao mais recente.

## Versoes Pre-release

### Identificadores Pre-release

Versoes pre-release tem menor precedencia que versoes de release:

```
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0
```

### Tags Pre-release Comuns

| Tag | Significado | Estagio |
|-----|-------------|---------|
| `alpha` | Desenvolvimento inicial | Muito instavel |
| `beta` | Feature-complete | Em testes |
| `rc` | Release candidate | Testes finais |
| `dev` | Snapshot de desenvolvimento | Instavel |

### Pre-release em Restricoes

Restricoes nao correspondem a versoes pre-release por padrao:

```
^1.0.0    # Nao corresponde a 1.1.0-beta
>=1.0.0   # Nao corresponde a 2.0.0-alpha
```

Para incluir versoes pre-release, referencie-as explicitamente:

```
>=1.0.0-alpha <2.0.0   # Inclui todos os pre-releases 1.x
```

## Comparacao de Versoes

### Regras de Comparacao

1. Compare MAJOR, MINOR, PATCH numericamente
2. Release > pre-release com mesmo numero de versao
3. Pre-releases sao comparados alfanumericamente
4. Metadados de build sao ignorados

### Exemplos

```
1.0.0 < 1.0.1 < 1.1.0 < 2.0.0

1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0

1.0.0 = 1.0.0+build123  # Metadados de build ignorados
```

### Ordenacao

Versoes sao ordenadas em ordem crescente:

```
1.0.0
1.0.1
1.1.0
1.1.1
2.0.0-alpha
2.0.0-beta
2.0.0
```

## Resolucao de Versoes

### Algoritmo de Resolucao

Quando multiplos pacotes requerem a mesma dependencia:

1. Coletar todas as restricoes
2. Encontrar intersecao de todos os intervalos
3. Selecionar a versao mais alta na intersecao
4. Erro se nenhuma versao satisfizer todas as restricoes

### Exemplo de Resolucao

```
package-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)
package-b requires hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)

Intersecao: >=1.2.0 <1.3.0
Disponiveis: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]
Resolvido: 1.2.5 (mais alta na intersecao)
```

### Deteccao de Conflitos

Conflitos ocorrem quando nenhuma versao satisfaz todas as restricoes:

```
package-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)
package-b requires hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)

Intersecao: (vazia)
Resultado: CONFLITO - nenhuma versao satisfaz ambas
```

## Melhores Praticas

### Para Consumidores de Pacotes

1. **Use intervalos de circunflexo para a maioria das dependencias**:
   ```json
   "hemlang/json": "^1.2.0"
   ```

2. **Use intervalos de til para dependencias criticas**:
   ```json
   "critical/lib": "~1.2.0"
   ```

3. **Trave versoes apenas quando necessario**:
   ```json
   "unstable/pkg": "1.2.3"
   ```

4. **Comite arquivo de lock** para builds reproduziveis

5. **Atualize regularmente** para obter correcoes de seguranca:
   ```bash
   hpm update
   hpm outdated
   ```

### Para Autores de Pacotes

1. **Comece com 0.1.0 para desenvolvimento inicial**:
   - API pode mudar frequentemente
   - Usuarios esperam instabilidade

2. **Avance para 1.0.0 quando a API estiver estavel**:
   - Compromisso publico com estabilidade
   - Mudancas incompativeis requerem incremento de major

3. **Siga semver estritamente**:
   - Mudancas incompativeis = MAJOR
   - Novos recursos = MINOR
   - Correcoes de bugs = PATCH

4. **Use versoes pre-release para testes**:
   ```bash
   git tag v2.0.0-beta.1
   git push --tags
   ```

5. **Documente mudancas incompativeis** no CHANGELOG

## Publicando Versoes

### Criando uma Release

```bash
# Atualizar versao no package.json
# Editar package.json: "version": "1.1.0"

# Commitar mudanca de versao
git add package.json
git commit -m "Bump version to 1.1.0"

# Criar e enviar tag
git tag v1.1.0
git push origin main --tags
```

### Formato de Tag

Tags **devem** comecar com `v`:

```
v1.0.0      Correto
v1.0.0-beta Correto
1.0.0       Nao sera reconhecido
```

### Fluxo de Trabalho de Release

```bash
# 1. Garantir que testes passam
hpm test

# 2. Atualizar versao no package.json
# 3. Atualizar CHANGELOG.md
# 4. Commitar mudancas
git add -A
git commit -m "Release v1.2.0"

# 5. Criar tag
git tag v1.2.0

# 6. Enviar tudo
git push origin main --tags
```

## Verificando Versoes

### Listar Versoes Instaladas

```bash
hpm list
```

### Verificar Atualizacoes

```bash
hpm outdated
```

Saida:
```
Package         Current  Wanted  Latest
hemlang/json    1.0.0    1.0.5   1.2.0
hemlang/sprout  2.0.0    2.0.3   2.1.0
```

- **Current**: Versao instalada
- **Wanted**: Versao mais alta que satisfaz a restricao
- **Latest**: Versao mais recente disponivel

### Atualizar Pacotes

```bash
# Atualizar todos
hpm update

# Atualizar pacote especifico
hpm update hemlang/json
```

## Veja Tambem

- [Criacao de Pacotes](#hpm-versioning-creating-packages) - Guia de publicacao
- [Especificacao de Pacotes](#hpm-versioning-package-spec) - Formato do package.json
- [Comandos](#hpm-versioning-commands) - Referencia da CLI



################################################################################
# HPM: REFER√äNCIA
################################################################################

--------------------------------------------------------------------------------
## Arquitetura
--------------------------------------------------------------------------------

# Arquitetura

Arquitetura interna e design do hpm. Este documento e destinado a contribuidores e pessoas interessadas em entender como o hpm funciona.

## Visao Geral

O hpm e escrito em Hemlock e consiste em varios modulos que lidam com diferentes aspectos do gerenciamento de pacotes:

```
src/
‚îú‚îÄ‚îÄ main.hml        # Ponto de entrada da CLI e roteamento de comandos
‚îú‚îÄ‚îÄ manifest.hml    # Processamento do package.json
‚îú‚îÄ‚îÄ lockfile.hml    # Processamento do package-lock.json
‚îú‚îÄ‚îÄ semver.hml      # Versionamento semantico
‚îú‚îÄ‚îÄ resolver.hml    # Resolucao de dependencias
‚îú‚îÄ‚îÄ github.hml      # Cliente da API do GitHub
‚îú‚îÄ‚îÄ installer.hml   # Download e extracao de pacotes
‚îî‚îÄ‚îÄ cache.hml       # Gerenciamento de cache global
```

## Responsabilidades dos Modulos

### main.hml

Ponto de entrada para a aplicacao CLI.

**Responsabilidades:**
- Analisar argumentos de linha de comando
- Rotear comandos para handlers apropriados
- Exibir ajuda e informacoes de versao
- Lidar com flags globais (--verbose, --dry-run, etc.)
- Sair com codigos apropriados

**Funcoes principais:**
- `main()` - Ponto de entrada, analisa args e despacha comandos
- `cmd_init()` - Trata `hpm init`
- `cmd_install()` - Trata `hpm install`
- `cmd_uninstall()` - Trata `hpm uninstall`
- `cmd_update()` - Trata `hpm update`
- `cmd_list()` - Trata `hpm list`
- `cmd_outdated()` - Trata `hpm outdated`
- `cmd_run()` - Trata `hpm run`
- `cmd_why()` - Trata `hpm why`
- `cmd_cache()` - Trata `hpm cache`

**Atalhos de comandos:**
```hemlock
let shortcuts = {
    "i": "install",
    "rm": "uninstall",
    "remove": "uninstall",
    "ls": "list",
    "up": "update"
};
```

### manifest.hml

Lida com leitura e escrita de arquivos `package.json`.

**Responsabilidades:**
- Ler e escrever package.json
- Validar estrutura do pacote
- Gerenciar dependencias
- Analisar especificadores de pacotes (owner/repo@version)

**Funcoes principais:**
```hemlock
create_default(): Manifest           // Criar manifesto vazio
read_manifest(): Manifest            // Ler do arquivo
write_manifest(m: Manifest)          // Escrever no arquivo
validate(m: Manifest): bool          // Validar estrutura
get_all_dependencies(m): Map         // Obter deps + devDeps
add_dependency(m, pkg, ver, dev)     // Adicionar dependencia
remove_dependency(m, pkg)            // Remover dependencia
parse_specifier(spec): (name, ver)   // Analisar "owner/repo@^1.0.0"
split_name(name): (owner, repo)      // Analisar "owner/repo"
```

**Estrutura do Manifest:**
```hemlock
type Manifest = {
    name: string,
    version: string,
    description: string?,
    author: string?,
    license: string?,
    repository: string?,
    main: string?,
    dependencies: Map<string, string>,
    devDependencies: Map<string, string>,
    scripts: Map<string, string>
};
```

### lockfile.hml

Gerencia o arquivo `package-lock.json` para instalacoes reproduziveis.

**Responsabilidades:**
- Criar/ler/escrever arquivo de lock
- Rastrear versoes resolvidas exatas
- Armazenar URLs de download e hashes de integridade
- Limpar dependencias orfas

**Funcoes principais:**
```hemlock
create_empty(): Lockfile              // Criar lockfile vazio
read_lockfile(): Lockfile             // Ler do arquivo
write_lockfile(l: Lockfile)           // Escrever no arquivo
create_entry(ver, url, hash, deps)    // Criar entrada de lock
get_locked(l, pkg): LockEntry?        // Obter versao travada
set_locked(l, pkg, entry)             // Definir versao travada
remove_locked(l, pkg)                 // Remover entrada
prune(l, keep: Set)                   // Remover orfaos
needs_update(l, m): bool              // Verificar se esta dessincronizado
```

**Estrutura do Lockfile:**
```hemlock
type Lockfile = {
    lockVersion: int,
    hemlock: string,
    dependencies: Map<string, LockEntry>
};

type LockEntry = {
    version: string,
    resolved: string,     // URL de download
    integrity: string,    // Hash SHA256
    dependencies: Map<string, string>
};
```

### semver.hml

Implementacao completa do Versionamento Semantico 2.0.0.

**Responsabilidades:**
- Analisar strings de versao
- Comparar versoes
- Analisar e avaliar restricoes de versao
- Encontrar versoes que satisfazem restricoes

**Funcoes principais:**
```hemlock
// Analise
parse(s: string): Version             // "1.2.3-beta+build" ‚Üí Version
stringify(v: Version): string         // Version ‚Üí "1.2.3-beta+build"

// Comparacao
compare(a, b: Version): int           // -1, 0, ou 1
gt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool

// Restricoes
parse_constraint(s: string): Constraint    // "^1.2.3" ‚Üí Constraint
satisfies(v: Version, c: Constraint): bool // Verificar se v corresponde a c
max_satisfying(versions, c): Version?      // Encontrar mais alta que corresponde
sort(versions): [Version]                  // Ordenar em ordem crescente

// Utilitarios
constraints_overlap(a, b: Constraint): bool  // Verificar compatibilidade
```

**Estrutura de Version:**
```hemlock
type Version = {
    major: int,
    minor: int,
    patch: int,
    prerelease: [string]?,  // Ex: ["beta", "1"]
    build: string?          // Ex: "20230101"
};
```

**Tipos de Constraint:**
```hemlock
type Constraint =
    | Exact(Version)           // "1.2.3"
    | Caret(Version)           // "^1.2.3" ‚Üí >=1.2.3 <2.0.0
    | Tilde(Version)           // "~1.2.3" ‚Üí >=1.2.3 <1.3.0
    | Range(op, Version)       // ">=1.0.0", "<2.0.0"
    | And(Constraint, Constraint)  // Intervalos combinados
    | Any;                     // "*"
```

### resolver.hml

Implementa resolucao de dependencias estilo npm.

**Responsabilidades:**
- Resolver arvore de dependencias
- Detectar conflitos de versao
- Detectar dependencias circulares
- Construir arvore de visualizacao

**Funcoes principais:**
```hemlock
resolve(manifest, lockfile): ResolveResult
    // Resolvedor principal: retorna mapa plano de todas as dependencias
    // com suas versoes resolvidas

resolve_version(pkg, constraints: [string]): ResolvedPackage?
    // Encontrar versao que satisfaz todas as restricoes

detect_cycles(deps: Map): [Cycle]?
    // Usar DFS para encontrar dependencias circulares

build_tree(lockfile): Tree
    // Criar estrutura de arvore para exibicao

find_why(pkg, lockfile): [Chain]
    // Encontrar cadeias de dependencia explicando por que pkg esta instalado
```

**Algoritmo de Resolucao:**

1. **Coletar restricoes**: Percorrer manifesto e dependencias transitivas
2. **Resolver cada pacote**: Para cada pacote:
   - Obter todas as restricoes de versao dos dependentes
   - Buscar versoes disponiveis do GitHub
   - Encontrar versao mais alta que satisfaz todas as restricoes
   - Erro se nenhuma versao satisfaz todas (conflito)
3. **Detectar ciclos**: Executar DFS para encontrar dependencias circulares
4. **Retornar mapa plano**: Nome do pacote ‚Üí informacao de versao resolvida

**Estrutura de ResolveResult:**
```hemlock
type ResolveResult = {
    packages: Map<string, ResolvedPackage>,
    conflicts: [Conflict]?,
    cycles: [Cycle]?
};

type ResolvedPackage = {
    name: string,
    version: Version,
    url: string,
    dependencies: Map<string, string>
};
```

### github.hml

Cliente da API do GitHub para descoberta e download de pacotes.

**Responsabilidades:**
- Buscar versoes disponiveis (tags)
- Baixar package.json dos repositorios
- Baixar tarballs de release
- Lidar com autenticacao e limites de taxa

**Funcoes principais:**
```hemlock
get_token(): string?
    // Obter token do ambiente ou configuracao

github_request(url, headers?): Response
    // Requisicao de API com retentativas

get_tags(owner, repo): [string]
    // Obter tags de versao (v1.0.0, v1.1.0, etc.)

get_package_json(owner, repo, ref): Manifest
    // Obter package.json em uma tag/commit especifica

download_tarball(owner, repo, tag): bytes
    // Baixar arquivo de release

repo_exists(owner, repo): bool
    // Verificar se repositorio existe

get_repo_info(owner, repo): RepoInfo
    // Obter metadados do repositorio
```

**Logica de retentativa:**
- Backoff exponencial: 1s, 2s, 4s, 8s
- Condicoes de retentativa: 403 (limite de taxa), 5xx (erros de servidor), erros de rede
- Maximo de 4 tentativas
- Relata claramente erros de limite de taxa

**Endpoints de API usados:**
```
GET /repos/{owner}/{repo}/tags
GET /repos/{owner}/{repo}/contents/package.json?ref={tag}
GET /repos/{owner}/{repo}/tarball/{tag}
GET /repos/{owner}/{repo}
```

### installer.hml

Lida com download e extracao de pacotes.

**Responsabilidades:**
- Baixar pacotes do GitHub
- Extrair tarballs para hem_modules
- Verificar/usar pacotes em cache
- Instalar/desinstalar pacotes

**Funcoes principais:**
```hemlock
install_package(pkg: ResolvedPackage): bool
    // Baixar e instalar um unico pacote

install_all(packages: Map, options): InstallResult
    // Instalar todos os pacotes resolvidos

uninstall_package(name: string): bool
    // Remover pacote do hem_modules

get_installed(): Map<string, string>
    // Listar pacotes atualmente instalados

verify_integrity(pkg): bool
    // Verificar integridade do pacote

prefetch_packages(packages: Map): void
    // Baixar para cache em paralelo (experimental)
```

**Processo de instalacao:**

1. Verificar se a versao correta ja esta instalada
2. Verificar tarball no cache
3. Se nao estiver em cache, baixar do GitHub
4. Armazenar no cache para uso futuro
5. Extrair para `hem_modules/owner/repo/`
6. Verificar instalacao

**Estrutura de diretorio criada:**
```
hem_modules/
‚îî‚îÄ‚îÄ owner/
    ‚îî‚îÄ‚îÄ repo/
        ‚îú‚îÄ‚îÄ package.json
        ‚îú‚îÄ‚îÄ src/
        ‚îî‚îÄ‚îÄ ...
```

### cache.hml

Gerencia o cache global de pacotes.

**Responsabilidades:**
- Armazenar tarballs baixados
- Recuperar pacotes em cache
- Listar pacotes em cache
- Limpar cache
- Gerenciar configuracao

**Funcoes principais:**
```hemlock
get_cache_dir(): string
    // Obter diretorio de cache (respeita HPM_CACHE_DIR)

get_config_dir(): string
    // Obter diretorio de configuracao (~/.hpm)

is_cached(owner, repo, version): bool
    // Verificar se tarball esta em cache

get_cached_path(owner, repo, version): string
    // Obter caminho para tarball em cache

store_tarball_file(owner, repo, version, data): void
    // Salvar tarball no cache

list_cached(): [CachedPackage]
    // Listar todos os pacotes em cache

clear_cache(): int
    // Remover todos os pacotes em cache, retorna bytes liberados

get_cache_size(): int
    // Calcular tamanho total do cache

read_config(): Config
    // Ler ~/.hpm/config.json

write_config(c: Config): void
    // Escrever arquivo de configuracao
```

**Estrutura do cache:**
```
~/.hpm/
‚îú‚îÄ‚îÄ config.json
‚îî‚îÄ‚îÄ cache/
    ‚îî‚îÄ‚îÄ owner/
        ‚îî‚îÄ‚îÄ repo/
            ‚îú‚îÄ‚îÄ 1.0.0.tar.gz
            ‚îî‚îÄ‚îÄ 1.1.0.tar.gz
```

## Fluxo de Dados

### Fluxo do Comando Install

```
hpm install owner/repo@^1.0.0
         ‚îÇ
         ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ main.hml ‚îÇ Analisa args, chama cmd_install
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇmanifest.hml‚îÇ Le package.json, adiciona dependencia
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇresolver.hml‚îÇ Resolve todas as dependencias
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚ñº               ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ github.hml‚îÇ    ‚îÇ semver.hml‚îÇ Busca versoes, encontra satisfazendo
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇinstaller.hml‚îÇ Baixa e extrai pacotes
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚ñº               ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ github.hml‚îÇ    ‚îÇ cache.hml‚îÇ Baixa ou usa cache
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇlockfile.hml‚îÇ Atualiza package-lock.json
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Detalhes do Algoritmo de Resolucao

```
Entrada: manifest.dependencies, manifest.devDependencies, lockfile existente

1. Inicializar:
   - constraints = {} // Map<string, [Constraint]>
   - resolved = {}    // Map<string, ResolvedPackage>
   - queue = [dependencias diretas]

2. Enquanto queue nao estiver vazia:
   a. pkg = queue.pop()
   b. Se pkg ja esta resolvido, pular
   c. Obter todas as restricoes para pkg dos dependentes
   d. Buscar versoes disponiveis do GitHub (em cache)
   e. Encontrar versao mais alta que satisfaz todas as restricoes
   f. Se nao encontrada: conflito
   g. resolved[pkg] = {version, url, deps}
   h. Adicionar dependencias de pkg a queue

3. Detectar ciclos no grafo resolvido
   - Se ciclos encontrados: erro

4. Retornar mapa resolvido
```

## Tratamento de Erros

### Codigos de Saida

Definidos em main.hml:

```hemlock
let EXIT_SUCCESS = 0;
let EXIT_CONFLICT = 1;
let EXIT_NOT_FOUND = 2;
let EXIT_VERSION_NOT_FOUND = 3;
let EXIT_NETWORK = 4;
let EXIT_INVALID_MANIFEST = 5;
let EXIT_INTEGRITY = 6;
let EXIT_RATE_LIMIT = 7;
let EXIT_CIRCULAR = 8;
```

### Propagacao de Erros

Erros borbulham atraves de valores de retorno:

```hemlock
fn resolve_version(pkg): Result<Version, ResolveError> {
    let versions = github.get_tags(owner, repo)?;  // ? propaga erros
    // ...
}
```

## Testes

### Framework de Testes

Framework de testes personalizado em `test/framework.hml`:

```hemlock
fn suite(name: string, tests: fn()) {
    print("Suite: " + name);
    tests();
}

fn test(name: string, body: fn()) {
    try {
        body();
        print("  ‚úì " + name);
    } catch e {
        print("  ‚úó " + name + ": " + e);
        failed += 1;
    }
}

fn assert_eq<T>(actual: T, expected: T) {
    if actual != expected {
        throw "Expected " + expected + ", got " + actual;
    }
}
```

### Arquivos de Teste

- `test/test_semver.hml` - Analise de versao, comparacao, restricoes
- `test/test_manifest.hml` - Leitura/escrita de manifesto, validacao
- `test/test_lockfile.hml` - Operacoes de lockfile
- `test/test_cache.hml` - Gerenciamento de cache

### Executando Testes

```bash
# Todos os testes
make test

# Testes especificos
make test-semver
make test-manifest
make test-lockfile
make test-cache
```

## Melhorias Futuras

### Recursos Planejados

1. **Verificacao de integridade** - Verificacao completa de hash SHA256
2. **Workspaces** - Suporte a monorepo
3. **Sistema de plugins** - Comandos extensiveis
4. **Auditoria** - Verificacao de vulnerabilidades de seguranca
5. **Registro privado** - Hospedagem de pacotes auto-hospedada

### Limitacoes Conhecidas

1. **Bug do bundler** - Nao consegue criar executaveis standalone
2. **Downloads paralelos** - Experimental, pode ter condicoes de corrida
3. **Integridade** - SHA256 nao totalmente implementado

## Contribuindo

### Estilo de Codigo

- Use indentacao de 4 espacos
- Funcoes devem fazer apenas uma coisa
- Comente logica complexa
- Escreva testes para novos recursos

### Adicionando Comandos

1. Adicionar handler em `main.hml`:
   ```hemlock
   fn cmd_newcmd(args: [string]) {
       // Implementacao
   }
   ```

2. Adicionar ao despacho de comandos:
   ```hemlock
   match command {
       "newcmd" => cmd_newcmd(args),
       // ...
   }
   ```

3. Atualizar texto de ajuda

### Adicionando Modulos

1. Criar `src/newmodule.hml`
2. Exportar interface publica
3. Importar nos modulos que precisam
4. Adicionar testes em `test/test_newmodule.hml`

## Veja Tambem

- [Comandos](#hpm-architecture-commands) - Referencia da CLI
- [Criacao de Pacotes](#hpm-architecture-creating-packages) - Desenvolvimento de pacotes
- [Versionamento](#hpm-architecture-versioning) - Versionamento semantico


--------------------------------------------------------------------------------
## C√≥digos de Sa√≠da
--------------------------------------------------------------------------------

# Codigos de Saida

Referencia dos codigos de saida do hpm e seus significados.

## Tabela de Codigos de Saida

| Codigo | Nome | Descricao |
|--------|------|-----------|
| 0 | SUCCESS | Comando completado com sucesso |
| 1 | CONFLICT | Conflito de versao de dependencias |
| 2 | NOT_FOUND | Pacote nao encontrado |
| 3 | VERSION_NOT_FOUND | Versao solicitada nao encontrada |
| 4 | NETWORK | Erro de rede |
| 5 | INVALID_MANIFEST | package.json invalido |
| 6 | INTEGRITY | Verificacao de integridade falhou |
| 7 | RATE_LIMIT | Limite de taxa da API do GitHub excedido |
| 8 | CIRCULAR | Dependencia circular detectada |

## Descricoes Detalhadas

### Codigo de Saida 0: SUCCESS

Comando completado com sucesso.

```bash
$ hpm install
Installed 5 packages
$ echo $?
0
```

### Codigo de Saida 1: CONFLICT

Dois ou mais pacotes requerem versoes incompativeis de uma dependencia.

**Exemplo:**
```
Error: Dependency conflict for hemlang/json

  package-a requires hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)
  package-b requires hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)

No version satisfies all constraints.
```

**Solucao:**
1. Verificar quais pacotes estao em conflito:
   ```bash
   hpm why hemlang/json
   ```
2. Atualizar os pacotes conflitantes:
   ```bash
   hpm update package-a
   ```
3. Relaxar restricoes de versao no package.json
4. Remover um dos pacotes conflitantes

### Codigo de Saida 2: NOT_FOUND

O pacote especificado nao existe no GitHub.

**Exemplo:**
```
Error: Package not found: hemlang/nonexistent

The repository hemlang/nonexistent does not exist on GitHub.
```

**Solucao:**
1. Verificar ortografia do nome do pacote
2. Verificar se o repositorio existe: `https://github.com/owner/repo`
3. Verificar se voce tem acesso (para repositorios privados, configurar GITHUB_TOKEN)

### Codigo de Saida 3: VERSION_NOT_FOUND

Nenhuma versao corresponde a restricao especificada.

**Exemplo:**
```
Error: No version of hemlang/json matches constraint ^5.0.0

Available versions: 1.0.0, 1.1.0, 1.2.0, 2.0.0
```

**Solucao:**
1. Verificar versoes disponiveis em releases/tags do GitHub
2. Usar uma restricao de versao valida
3. Tags de versao devem comecar com 'v' (ex: `v1.0.0`)

### Codigo de Saida 4: NETWORK

Ocorreu um erro relacionado a rede.

**Exemplo:**
```
Error: Network error: could not connect to api.github.com

Please check your internet connection and try again.
```

**Solucao:**
1. Verificar conexao de rede
2. Verificar se o GitHub esta acessivel
3. Se atras de firewall, verificar configuracoes de proxy
4. Se pacotes estao em cache, usar `--offline`:
   ```bash
   hpm install --offline
   ```
5. Esperar e tentar novamente (hpm tenta automaticamente)

### Codigo de Saida 5: INVALID_MANIFEST

Arquivo package.json e invalido ou malformado.

**Exemplo:**
```
Error: Invalid package.json

  - Missing required field: name
  - Invalid version format: "1.0"
```

**Solucao:**
1. Verificar sintaxe JSON (usar validador JSON)
2. Garantir que campos obrigatorios existem (`name`, `version`)
3. Verificar formatos dos campos:
   - name: formato `owner/repo`
   - version: formato semver `X.Y.Z`
4. Regenerar:
   ```bash
   rm package.json
   hpm init
   ```

### Codigo de Saida 6: INTEGRITY

Verificacao de integridade do pacote falhou.

**Exemplo:**
```
Error: Integrity check failed for hemlang/json@1.0.0

Expected: sha256-abc123...
Actual:   sha256-def456...

The downloaded package may be corrupted.
```

**Solucao:**
1. Limpar cache e reinstalar:
   ```bash
   hpm cache clean
   hpm install
   ```
2. Verificar problemas de rede (download parcial)
3. Verificar se o pacote nao foi adulterado

### Codigo de Saida 7: RATE_LIMIT

Limite de taxa da API do GitHub excedido.

**Exemplo:**
```
Error: GitHub API rate limit exceeded

Unauthenticated rate limit: 60 requests/hour
Current usage: 60/60

Rate limit resets at: 2024-01-15 10:30:00 UTC
```

**Solucao:**
1. **Usar autenticacao do GitHub** (recomendado):
   ```bash
   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
   hpm install
   ```
2. Esperar limite de taxa resetar (reseta a cada hora)
3. Se pacotes estao em cache, usar modo offline:
   ```bash
   hpm install --offline
   ```

### Codigo de Saida 8: CIRCULAR

Dependencia circular detectada no grafo de dependencias.

**Exemplo:**
```
Error: Circular dependency detected

  package-a@1.0.0
  ‚îî‚îÄ‚îÄ package-b@1.0.0
      ‚îî‚îÄ‚îÄ package-a@1.0.0  (circular!)

Cannot resolve dependency tree.
```

**Solucao:**
1. Isso geralmente e um bug no proprio pacote
2. Contatar o mantenedor do pacote
3. Evitar usar um dos pacotes circulares

## Usando Codigos de Saida em Scripts

### Bash

```bash
#!/bin/bash

hpm install
exit_code=$?

case $exit_code in
  0)
    echo "Installation successful"
    ;;
  1)
    echo "Dependency conflict - check version constraints"
    exit 1
    ;;
  2)
    echo "Package not found - check package name"
    exit 1
    ;;
  4)
    echo "Network error - check connection"
    exit 1
    ;;
  7)
    echo "Rate limited - set GITHUB_TOKEN"
    exit 1
    ;;
  *)
    echo "Unknown error: $exit_code"
    exit 1
    ;;
esac
```

### CI/CD

```yaml
# GitHub Actions
- name: Install dependencies
  run: |
    hpm install
    if [ $? -eq 7 ]; then
      echo "::error::GitHub rate limit exceeded. Add GITHUB_TOKEN."
      exit 1
    fi
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### Make

```makefile
install:
	@hpm install || (echo "Installation failed with code $$?"; exit 1)

test: install
	@hpm test
```

## Solucao de Problemas por Codigo de Saida

### Referencia Rapida

| Codigo | Verificar Primeiro |
|--------|-------------------|
| 1 | Executar `hpm why <package>` para ver conflitos |
| 2 | Verificar nome do pacote no GitHub |
| 3 | Verificar versoes disponiveis nas tags do GitHub |
| 4 | Verificar conexao de rede |
| 5 | Validar sintaxe do package.json |
| 6 | Executar `hpm cache clean && hpm install` |
| 7 | Definir variavel de ambiente `GITHUB_TOKEN` |
| 8 | Contatar mantenedor do pacote |

## Veja Tambem

- [Solucao de Problemas](#hpm-exit-codes-troubleshooting) - Solucoes detalhadas
- [Comandos](#hpm-exit-codes-commands) - Referencia de comandos
- [Configuracao](#hpm-exit-codes-configuration) - Configurar token do GitHub



================================================================================
END OF DOCUMENTATION
================================================================================