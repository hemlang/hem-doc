<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manual del Lenguaje Hemlock</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sage: #9CAF88;
            --pine: #2F4F4F;
            --dark-pine: #1a2f2f;
            --light-sage: #E8F4E1;
            --cream: #FAF9F6;
            --text: #2C3E2C;
            --text-light: #5A6F5A;
            --border: #D4E4CB;
            --code-bg: #F5F9F3;
            --accent: #6B8E6B;
        }

        [data-theme="dark"] {
            --sage: #6B8E6B;
            --pine: #9CAF88;
            --dark-pine: #0d1a1a;
            --light-sage: #1a2f2f;
            --cream: #0f1a1a;
            --text: #e0e8e0;
            --text-light: #a8b8a8;
            --border: #2a4a4a;
            --code-bg: #162626;
            --accent: #9CAF88;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) {
                --sage: #6B8E6B;
                --pine: #9CAF88;
                --dark-pine: #0d1a1a;
                --light-sage: #1a2f2f;
                --cream: #0f1a1a;
                --text: #e0e8e0;
                --text-light: #a8b8a8;
                --border: #2a4a4a;
                --code-bg: #162626;
                --accent: #9CAF88;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            line-height: 1.7;
            color: var(--text);
            background: var(--cream);
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: #2F4F4F;
            color: white;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .header-logo {
            height: 45px;
            margin-right: 1rem;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            margin-right: auto;
        }

        /* Layout */
        .container {
            display: flex;
            margin-top: 70px;
            min-height: calc(100vh - 70px);
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 70px;
            width: 280px;
            height: calc(100vh - 70px);
            background: var(--light-sage);
            border-right: 2px solid var(--border);
            overflow-y: auto;
            padding: 2rem 0;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 900;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        @media (min-width: 1024px) {
            .sidebar {
                transform: translateX(0);
            }
        }

        .nav-section {
            margin-bottom: 1.5rem;
        }

        .nav-section-title {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--pine);
            padding: 0 1.5rem;
            margin-bottom: 0.5rem;
        }

        .nav-link {
            display: block;
            padding: 0.5rem 1.5rem;
            color: var(--text);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .nav-link:hover {
            background: rgba(47, 79, 79, 0.05);
            border-left-color: var(--sage);
        }

        .nav-link.active {
            background: rgba(47, 79, 79, 0.1);
            border-left-color: var(--pine);
            font-weight: 600;
            color: var(--pine);
        }

        /* Mobile Menu Toggle */
        .menu-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 56px;
            height: 56px;
            background: var(--pine);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (min-width: 1024px) {
            .menu-toggle {
                display: none;
            }
        }

        /* Main Content */
        .main-content {
            flex: 1;
            margin-left: 0;
            padding: 3rem 2rem;
            max-width: 900px;
        }

        @media (min-width: 1024px) {
            .main-content {
                margin-left: 280px;
            }
        }

        /* Typography */
        .content h1 {
            font-size: 2.5rem;
            color: var(--pine);
            margin: 2rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--sage);
        }

        .content h2 {
            font-size: 2rem;
            color: var(--pine);
            margin: 3rem 0 1rem;
            padding-top: 1rem;
        }

        .content h3 {
            font-size: 1.5rem;
            color: var(--accent);
            margin: 2rem 0 1rem;
        }

        .content h4 {
            font-size: 1.2rem;
            color: var(--accent);
            margin: 1.5rem 0 0.8rem;
        }

        .content p {
            margin: 1rem 0;
            color: var(--text);
        }

        .content ul, .content ol {
            margin: 1rem 0 1rem 2rem;
        }

        .content li {
            margin: 0.5rem 0;
        }

        .content blockquote {
            border-left: 4px solid var(--sage);
            background: var(--light-sage);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: var(--text-light);
        }

        .content hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }

        /* Code Blocks */
        .content code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--pine);
        }

        .code-block {
            margin: 1.5rem 0;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: var(--code-bg);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--pine);
            color: var(--light-sage);
            font-size: 0.8rem;
        }

        .code-lang {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-weight: 600;
            text-transform: lowercase;
        }

        .copy-btn {
            background: transparent;
            border: 1px solid var(--sage);
            color: var(--light-sage);
            padding: 0.3rem 0.7rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .copy-btn:hover {
            background: var(--sage);
            color: var(--pine);
        }

        .copy-btn.copied {
            background: var(--sage);
            color: var(--pine);
            border-color: var(--sage);
        }

        .copy-btn svg {
            width: 14px;
            height: 14px;
        }

        .content pre {
            background: var(--code-bg);
            margin: 0;
            padding: 1.2rem;
            overflow-x: auto;
        }

        .content pre code {
            background: none;
            padding: 0;
            border-radius: 0;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        /* Standalone pre without code-block wrapper (legacy) */
        .content > pre {
            border: 1px solid var(--border);
            border-left: 4px solid var(--pine);
            border-radius: 4px;
            margin: 1.5rem 0;
        }

        /* Tables */
        .content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        .content th,
        .content td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .content th {
            background: var(--light-sage);
            color: var(--pine);
            font-weight: 600;
        }

        /* Links */
        .content a {
            color: var(--accent);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .content a:hover {
            border-bottom-color: var(--accent);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--cream);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--sage);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* Section anchors */
        .section-anchor {
            scroll-margin-top: 90px;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .main-content {
                padding: 2rem 1rem;
            }

            .content h1 {
                font-size: 2rem;
            }

            .content h2 {
                font-size: 1.6rem;
            }

            .content h3 {
                font-size: 1.3rem;
            }
        }

        /* Page switching */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* Search */
        .search-container {
            position: relative;
            margin-right: 1rem;
        }

        .search-input {
            width: 200px;
            padding: 0.5rem 1rem;
            padding-left: 2.2rem;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.25);
            width: 280px;
        }

        .search-icon {
            position: absolute;
            left: 0.8rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
        }

        .search-results {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            right: 0;
            min-width: 320px;
            max-height: 400px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1001;
        }

        .search-results.active {
            display: block;
        }

        .search-result {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s;
        }

        .search-result:last-child {
            border-bottom: none;
        }

        .search-result:hover,
        .search-result.selected {
            background: var(--light-sage);
        }

        .search-result-title {
            font-weight: 600;
            color: var(--pine);
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
        }

        .search-result-section {
            font-size: 0.75rem;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .search-result-preview {
            font-size: 0.85rem;
            color: var(--text-light);
            margin-top: 0.25rem;
            line-height: 1.4;
        }

        .search-result-preview mark {
            background: var(--sage);
            color: var(--pine);
            padding: 0 2px;
            border-radius: 2px;
        }

        .search-no-results {
            padding: 1rem;
            text-align: center;
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .search-shortcut {
            display: none;
            margin-left: 0.5rem;
            padding: 0.15rem 0.4rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.8);
        }

        @media (min-width: 768px) {
            .search-shortcut {
                display: inline-block;
            }
        }

        @media (max-width: 768px) {
            .search-container {
                position: fixed;
                top: 70px;
                left: 0;
                right: 0;
                margin: 0;
                padding: 0.5rem;
                background: #1a2f2f;
                display: none;
                z-index: 999;
            }

            .search-container.active {
                display: block;
            }

            .search-input {
                width: 100%;
            }

            .search-input:focus {
                width: 100%;
            }

            .search-results {
                position: fixed;
                top: 120px;
                left: 0.5rem;
                right: 0.5rem;
                min-width: auto;
                max-height: calc(100vh - 140px);
            }

            .search-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
                background: transparent;
                border: none;
                color: white;
                font-size: 1.2rem;
                cursor: pointer;
                padding: 0.5rem;
                margin-left: auto;
            }
        }

        @media (min-width: 769px) {
            .search-toggle {
                display: none;
            }
        }

        /* Theme Toggle */
        .theme-toggle {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            margin-left: 0.5rem;
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .theme-toggle svg {
            width: 20px;
            height: 20px;
        }

        .theme-toggle .sun-icon {
            display: none;
        }

        .theme-toggle .moon-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .sun-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .moon-icon {
            display: none;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) .theme-toggle .sun-icon {
                display: block;
            }
            :root:not([data-theme="light"]) .theme-toggle .moon-icon {
                display: none;
            }
        }

        /* Language Switcher */
        .lang-switcher {
            margin-left: 0.5rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 8px;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }

        .lang-switcher:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher:focus {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher option {
            background: var(--pine);
            color: white;
        }

        [data-theme="dark"] .lang-switcher option {
            background: var(--bg-primary);
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <img src="data:image/png;base64,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" alt="Hemlock Logo" class="header-logo">
        <h1>Manual del Lenguaje Hemlock</h1>
        <!-- Search -->
        <div class="search-container" id="searchContainer">
            <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
            <input type="text" class="search-input" id="searchInput" placeholder="Search docs..." autocomplete="off">
            <span class="search-shortcut">Ctrl+K</span>
            <div class="search-results" id="searchResults"></div>
        </div>
        <button class="search-toggle" id="searchToggle">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
        </button>
        <select class="lang-switcher" id="langSwitcher" onchange="switchLanguage(this.value)">
            <option value="docs.html" >English</option>
<option value="docs-zh.html" ></option>
<option value="docs-de.html" >Deutsch</option>
<option value="docs-es.html" selected>Espaol</option>
<option value="docs-ja.html" ></option>
<option value="docs-pt.html" >Portugus</option>
        </select>
        <button class="theme-toggle" id="themeToggle" title="Toggle dark mode">
            <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
            <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
        </button>
    </div>

    <!-- Mobile Menu Toggle -->
    <button class="menu-toggle" id="menuToggle">&#9776;</button>

    <!-- Container -->
    <div class="container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar" id="sidebar">
            <div class="nav-section">
<a href="#welcome" class="nav-link" data-page="welcome">Bienvenido</a>
</div>
<a href="#language-reference" class="nav-link" data-page="language-reference">Referencia del Lenguaje</a>
<div class="nav-section">
<div class="nav-section-title">Primeros Pasos</div>
<a href="#getting-started-quick-start" class="nav-link" data-page="getting-started-quick-start">Inicio Rpido</a>
<a href="#getting-started-installation" class="nav-link" data-page="getting-started-installation">Instalacin</a>
<a href="#getting-started-learning-paths" class="nav-link" data-page="getting-started-learning-paths">Rutas de Aprendizaje</a>
<a href="#getting-started-tutorial" class="nav-link" data-page="getting-started-tutorial">Tutorial</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Gua Del Lenguaje</div>
<a href="#language-guide-arrays" class="nav-link" data-page="language-guide-arrays">Arreglos</a>
<a href="#language-guide-strings" class="nav-link" data-page="language-guide-strings">Cadenas</a>
<a href="#language-guide-pattern-matching" class="nav-link" data-page="language-guide-pattern-matching">Coincidencia de Patrones</a>
<a href="#language-guide-control-flow" class="nav-link" data-page="language-guide-control-flow">Flujo de Control</a>
<a href="#language-guide-functions" class="nav-link" data-page="language-guide-functions">Funciones</a>
<a href="#language-guide-memory" class="nav-link" data-page="language-guide-memory">Gestin de Memoria</a>
<a href="#language-guide-error-handling" class="nav-link" data-page="language-guide-error-handling">Manejo de Errores</a>
<a href="#language-guide-modules" class="nav-link" data-page="language-guide-modules">Mdulos</a>
<a href="#language-guide-objects" class="nav-link" data-page="language-guide-objects">Objetos</a>
<a href="#language-guide-runes" class="nav-link" data-page="language-guide-runes">Runas</a>
<a href="#language-guide-syntax" class="nav-link" data-page="language-guide-syntax">Sintaxis</a>
<a href="#language-guide-types" class="nav-link" data-page="language-guide-types">Tipos</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Temas Avanzados</div>
<a href="#advanced-command-line-args" class="nav-link" data-page="advanced-command-line-args">Argumentos de Lnea de Comandos</a>
<a href="#advanced-async-concurrency" class="nav-link" data-page="advanced-async-concurrency">Asincrona y Concurrencia</a>
<a href="#advanced-command-execution" class="nav-link" data-page="advanced-command-execution">Ejecucin de Comandos</a>
<a href="#advanced-bundling-packaging" class="nav-link" data-page="advanced-bundling-packaging">Empaquetado y Distribucin</a>
<a href="#advanced-ffi" class="nav-link" data-page="advanced-ffi">FFI</a>
<a href="#advanced-file-io" class="nav-link" data-page="advanced-file-io">File IO</a>
<a href="#advanced-atomics" class="nav-link" data-page="advanced-atomics">Operaciones Atmicas</a>
<a href="#advanced-profiling" class="nav-link" data-page="advanced-profiling">Perfilado</a>
<a href="#advanced-signals" class="nav-link" data-page="advanced-signals">Seales</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Referencia De API</div>
<a href="#reference-file-api" class="nav-link" data-page="reference-file-api">API de Archivos</a>
<a href="#reference-array-api" class="nav-link" data-page="reference-array-api">API de Arreglos</a>
<a href="#reference-string-api" class="nav-link" data-page="reference-string-api">API de Cadenas</a>
<a href="#reference-concurrency-api" class="nav-link" data-page="reference-concurrency-api">API de Concurrencia</a>
<a href="#reference-memory-api" class="nav-link" data-page="reference-memory-api">API de Memoria</a>
<a href="#reference-builtins" class="nav-link" data-page="reference-builtins">Funciones Integradas</a>
<a href="#reference-operators" class="nav-link" data-page="reference-operators">Operadores</a>
<a href="#reference-type-system" class="nav-link" data-page="reference-type-system">Sistema de Tipos</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Diseo Y Filosofa</div>
<a href="#design-philosophy" class="nav-link" data-page="design-philosophy">Filosofa</a>
<a href="#design-implementation" class="nav-link" data-page="design-implementation">Implementacin</a>
<a href="#design-signature-syntax" class="nav-link" data-page="design-signature-syntax">Sintaxis de Firmas</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Contribuir</div>
<a href="#contributing-guidelines" class="nav-link" data-page="contributing-guidelines">Guas de Contribucin</a>
<a href="#contributing-testing" class="nav-link" data-page="contributing-testing">Pruebas</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Primeros Pasos</div>
<a href="#hpm-project-setup" class="nav-link" data-page="hpm-project-setup">Configuracin del Proyecto</a>
<a href="#hpm-quick-start" class="nav-link" data-page="hpm-quick-start">Inicio Rpido</a>
<a href="#hpm-installation" class="nav-link" data-page="hpm-installation">Instalacin</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Gua Del Usuario</div>
<a href="#hpm-commands" class="nav-link" data-page="hpm-commands">Comandos</a>
<a href="#hpm-configuration" class="nav-link" data-page="hpm-configuration">Configuracin</a>
<a href="#hpm-troubleshooting" class="nav-link" data-page="hpm-troubleshooting">Solucin de Problemas</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Desarrollo De Paquetes</div>
<a href="#hpm-creating-packages" class="nav-link" data-page="hpm-creating-packages">Creacin de Paquetes</a>
<a href="#hpm-package-spec" class="nav-link" data-page="hpm-package-spec">Especificacin de Paquetes</a>
<a href="#hpm-versioning" class="nav-link" data-page="hpm-versioning">Versionado</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: Referencia</div>
<a href="#hpm-architecture" class="nav-link" data-page="hpm-architecture">Arquitectura</a>
<a href="#hpm-exit-codes" class="nav-link" data-page="hpm-exit-codes">Cdigos de Salida</a>
</div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <div class="content" id="content"></div>
        </main>
    </div>

    <script>
        // Embedded documentation pages
        const PAGES = {"Bienvenido": {"id": "welcome", "content": "# Bienvenido a Hemlock\n\n> \"Un lenguaje pequeo e inseguro para escribir cosas inseguras de manera segura.\"\n\n**Hemlock** es un lenguaje de scripting de sistemas que combina el poder de C con la ergonoma de los scripts modernos. Cuenta con gestin manual de memoria, control explcito y concurrencia asncrona estructurada incorporada.\n\n## Qu es Hemlock?\n\nHemlock est diseado para programadores que desean:\n\n- **Control explcito** sobre la memoria y la ejecucin\n- **Sintaxis similar a C** con comodidades modernas\n- **Sin comportamiento oculto** ni magia\n- **Asincrona paralela real** con concurrencia basada en pthread\n\nHemlock NO es un lenguaje con seguridad de memoria y recoleccin de basura. En cambio, te proporciona las herramientas para estar seguro (`buffer`, anotaciones de tipos, verificacin de lmites) sin obligarte a usarlas (`ptr`, memoria manual, operaciones inseguras).\n\n## Ejemplo Rpido\n\n```hemlock\n// Hola, Hemlock!\nfn greet(name: string): string {\n    return `Hola, ${name}!`;\n}\n\nlet message = greet(\"Mundo\");\nprint(message);\n\n// Gestin manual de memoria\nlet buf = buffer(64);\nbuf[0] = 72;  // 'H'\nbuf[1] = 105; // 'i'\nprint(buf);\nfree(buf);\n```\n\n## Caractersticas de un Vistazo\n\n| Caracterstica | Descripcin |\n|----------------|-------------|\n| **Sistema de Tipos** | i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object |\n| **Memoria** | Gestin manual con `alloc()`, `buffer()`, `free()` |\n| **Async** | `async`/`await` incorporado con verdadero paralelismo pthread |\n| **FFI** | Llamar funciones C directamente desde bibliotecas compartidas |\n| **Biblioteca Estndar** | 40 mdulos incluyendo crypto, http, sqlite, json y ms |\n\n## Primeros Pasos\n\nListo para comenzar? As es como empezar:\n\n1. **[Instalacin](#getting-started-installation)** - Descargar y configurar Hemlock\n2. **[Inicio Rpido](#getting-started-quick-start)** - Escribe tu primer programa en minutos\n3. **[Tutorial](#getting-started-tutorial)** - Aprende Hemlock paso a paso\n\n## Secciones de Documentacin\n\n- **Primeros Pasos** - Instalacin, gua de inicio rpido y tutoriales\n- **Gua del Lenguaje** - Profundizacin en sintaxis, tipos, funciones y ms\n- **Temas Avanzados** - Programacin asncrona, FFI, seales y atmicos\n- **Referencia de API** - Referencia completa para funciones integradas y biblioteca estndar\n- **Diseo y Filosofa** - Comprender por qu Hemlock es como es\n\n## Gestor de Paquetes\n\nHemlock viene con **hpm**, un gestor de paquetes para administrar dependencias:\n\n```bash\nhpm init my-project\nhpm add some-package\nhpm run\n```\n\nConsulta las secciones de documentacin de hpm para ms detalles.\n\n---\n\nUsa la navegacin a la izquierda para explorar la documentacin, o utiliza la barra de bsqueda para encontrar temas especficos.\n"}, "Referencia del Lenguaje": {"id": "language-reference", "content": "# Filosofia de Diseno del Lenguaje Hemlock\n\n> \"Un lenguaje pequeno e inseguro para escribir cosas inseguras de manera segura.\"\n\nEste documento captura los principios de diseno fundamentales para asistentes de IA que trabajan con Hemlock.\nPara documentacion detallada, consulte `docs/README.md` y el directorio `stdlib/docs/`.\n\n---\n\n## Identidad Central\n\nHemlock es un **lenguaje de scripting de sistemas** con gestion manual de memoria y control explicito:\n- El poder de C con ergonomia de scripting moderna\n- Concurrencia asincrona estructurada incorporada\n- Sin comportamiento oculto ni magia\n\n**Hemlock NO ES:** Seguro en memoria, un lenguaje con GC, ni oculta complejidad.\n**Hemlock ES:** Explicito sobre implicito, educativo, una \"capa de scripting C\" para trabajo de sistemas.\n\n---\n\n## Principios de Diseno\n\n### 1. Explicito Sobre Implicito\n- Punto y coma obligatorio (sin ASI)\n- Gestion manual de memoria (alloc/free)\n- Anotaciones de tipo opcionales pero verificadas en tiempo de ejecucion\n\n### 2. Dinamico por Defecto, Tipado por Eleccion\n- Cada valor tiene una etiqueta de tipo en tiempo de ejecucion\n- Los literales infieren tipos: `42`  i32, `5000000000`  i64, `3.14`  f64\n- Las anotaciones de tipo opcionales imponen verificaciones en tiempo de ejecucion\n\n### 3. Inseguro es una Caracteristica\n- Aritmetica de punteros permitida (responsabilidad del usuario)\n- Sin verificacion de limites en `ptr` crudo (use `buffer` para seguridad)\n- Se permiten fallos por doble liberacion\n\n### 4. Concurrencia Estructurada de Primera Clase\n- `async`/`await` incorporados con paralelismo basado en pthread\n- Canales para comunicacion\n- `spawn`/`join`/`detach` para gestion de tareas\n\n### 5. Sintaxis Similar a C\n- Bloques `{}` siempre requeridos\n- Comentarios: `// linea` y `/* bloque */`\n- Operadores coinciden con C: `+`, `-`, `*`, `%`, `&&`, `||`, `!`, `&`, `|`, `^`, `<<`, `>>`\n- Incremento/decremento: `++x`, `x++`, `--x`, `x--` (prefijo y posfijo)\n- Asignacion compuesta: `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`\n- `/` siempre devuelve flotante (use `divi()` para division entera)\n- Sintaxis de tipo: `let x: type = value;`\n\n---\n\n## Referencia Rapida\n\n### Tipos\n```\nSigned:   i8, i16, i32, i64\nUnsigned: u8, u16, u32, u64\nFloats:   f32, f64\nOther:    bool, string, rune, array, ptr, buffer, null, object, file, task, channel\nAliases:  integer (i32), number (f64), byte (u8)\n```\n\n**Promocion de tipos:** i8  i16  i32  i64  f32  f64 (los flotantes siempre ganan, pero i64/u64 + f32  f64 para preservar precision)\n\n### Literales\n```hemlock\nlet x = 42;              // i32\nlet big = 5000000000;    // i64 (> i32 max)\nlet hex = 0xDEADBEEF;    // hex literal\nlet bin = 0b1010;        // binary literal\nlet oct = 0o777;         // octal literal\nlet sep = 1_000_000;     // numeric separators allowed\nlet pi = 3.14;           // f64\nlet half = .5;           // f64 (no leading zero)\nlet s = \"hello\";         // string\nlet esc = \"\\x41\\u{1F600}\"; // hex and unicode escapes\nlet ch = 'A';            // rune\nlet emoji = '';        // rune (Unicode)\nlet arr = [1, 2, 3];     // array\nlet obj = { x: 10 };     // object\n```\n\n### Conversion de Tipos\n```hemlock\n// Type constructor functions - parse strings to types\nlet n = i32(\"42\");       // Parse string to i32\nlet f = f64(\"3.14\");     // Parse string to f64\nlet b = bool(\"true\");    // Parse string to bool (\"true\" or \"false\")\n\n// All numeric types supported\nlet a = i8(\"-128\");      // i8, i16, i32, i64\nlet c = u8(\"255\");       // u8, u16, u32, u64\nlet d = f32(\"1.5\");      // f32, f64\n\n// Hex and negative numbers\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\n\n// Type aliases work too\nlet x = integer(\"100\");  // Same as i32(\"100\")\nlet y = number(\"1.5\");   // Same as f64(\"1.5\")\nlet z = byte(\"200\");     // Same as u8(\"200\")\n\n// Convert between numeric types\nlet big = i64(42);       // i32 to i64\nlet truncated = i32(3.99); // f64 to i32 (truncates to 3)\n\n// Type annotations validate types (but don't parse strings)\nlet f: f64 = 100;        // i32 to f64 via annotation (numeric coercion OK)\n// let n: i32 = \"42\";    // ERROR - use i32(\"42\") for string parsing\n```\n\n### Introspeccion\n```hemlock\ntypeof(42);              // \"i32\"\ntypeof(\"hello\");         // \"string\"\ntypeof([1, 2, 3]);       // \"array\"\ntypeof(null);            // \"null\"\nlen(\"hello\");            // 5 (string length in bytes)\nlen([1, 2, 3]);          // 3 (array length)\n```\n\n### Memoria\n```hemlock\nlet p = alloc(64);       // raw pointer\nlet b = buffer(64);      // safe buffer (bounds checked)\nmemset(p, 0, 64);\nmemcpy(dest, src, 64);\nfree(p);                 // manual cleanup required\n```\n\n### Flujo de Control\n```hemlock\nif (x > 0) { } else if (x < 0) { } else { }\nwhile (cond) { break; continue; }\nfor (let i = 0; i < 10; i++) { }\nfor (item in array) { }\nloop { if (done) { break; } }   // infinite loop (cleaner than while(true))\nswitch (x) { case 1: break; default: break; }  // C-style fall-through\ndefer cleanup();         // runs when function returns\n\n// Loop labels for targeted break/continue in nested loops\nouter: while (cond) {\n    inner: for (let i = 0; i < 10; i++) {\n        if (i == 5) { break outer; }     // break outer loop\n        if (i == 3) { continue outer; }  // continue outer loop\n    }\n}\n```\n\n### Coincidencia de Patrones\n```hemlock\n// Match expression - returns value\nlet result = match (value) {\n    0 => \"zero\",                    // Literal pattern\n    1 | 2 | 3 => \"small\",           // OR pattern\n    n if n < 10 => \"medium\",        // Guard expression\n    n => \"large: \" + n              // Variable binding\n};\n\n// Type patterns\nmatch (val) {\n    n: i32 => \"integer\",\n    s: string => \"string\",\n    _ => \"other\"                    // Wildcard\n}\n\n// Object destructuring\nmatch (point) {\n    { x: 0, y: 0 } => \"origin\",\n    { x, y } => \"at \" + x + \",\" + y\n}\n\n// Array destructuring with rest\nmatch (arr) {\n    [] => \"empty\",\n    [first, ...rest] => \"head: \" + first,\n    _ => \"other\"\n}\n\n// Nested patterns\nmatch (user) {\n    { name, address: { city } } => name + \" in \" + city\n}\n```\n\nConsulte `docs/language-guide/pattern-matching.md` para documentacion completa.\n\n### Operadores de Coalescencia Nula\n```hemlock\n// Null coalescing (??) - returns left if non-null, else right\nlet name = user.name ?? \"Anonymous\";\nlet first = a ?? b ?? c ?? \"fallback\";\n\n// Null coalescing assignment (??=) - assigns only if null\nlet config = null;\nconfig ??= { timeout: 30 };    // config is now { timeout: 30 }\nconfig ??= { timeout: 60 };    // config unchanged (not null)\n\n// Works with properties and indices\nobj.field ??= \"default\";\narr[0] ??= \"first\";\n\n// Safe navigation (?.) - returns null if object is null\nlet city = user?.address?.city;  // null if any part is null\nlet upper = name?.to_upper();    // safe method call\nlet item = arr?.[0];             // safe indexing\n```\n\n### Funciones\n```hemlock\nfn add(a: i32, b: i32): i32 { return a + b; }\nfn greet(name: string, msg?: \"Hello\") { print(msg + \" \" + name); }\nlet f = fn(x) { return x * 2; };  // anonymous/closure\n\n// Expression-bodied functions (arrow syntax)\nfn double(x: i32): i32 => x * 2;\nfn max(a: i32, b: i32): i32 => a > b ? a : b;\nlet square = fn(x: i32): i32 => x * x;  // anonymous expression-bodied\n\n// Parameter modifiers\nfn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // pass-by-reference\nfn print_all(const items: array) { for (i in items) { print(i); } }  // immutable\n```\n\n### Argumentos con Nombre\n```hemlock\n// Functions can be called with named arguments\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" is \" + age + \" years old\");\n}\n\n// Positional arguments (traditional)\ncreate_user(\"Alice\", 25, false);\n\n// Named arguments - can be in any order\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n\n// Skip optional parameters by naming what you need\ncreate_user(\"David\", active: false);  // Uses default age=18\n\n// Named arguments must come after positional arguments\ncreate_user(\"Eve\", age: 21);          // OK: positional then named\n// create_user(name: \"Bad\", 25);      // ERROR: positional after named\n```\n\n**Reglas:**\n- Los argumentos con nombre usan sintaxis `name: value`\n- Pueden aparecer en cualquier orden despues de los argumentos posicionales\n- Los argumentos posicionales no pueden seguir a los argumentos con nombre\n- Funciona con parametros por defecto/opcionales\n- Los nombres de parametros desconocidos causan errores en tiempo de ejecucion\n\n### Objetos y Enums\n```hemlock\ndefine Person { name: string, age: i32, active?: true }\nlet p: Person = { name: \"Alice\", age: 30 };\nlet json = p.serialize();\nlet restored = json.deserialize();\n\n// Object shorthand syntax (ES6-style)\nlet name = \"Alice\";\nlet age = 30;\nlet person = { name, age };         // equivalent to { name: name, age: age }\n\n// Object spread operator\nlet defaults = { theme: \"dark\", size: \"medium\" };\nlet config = { ...defaults, size: \"large\" };  // copies defaults, overrides size\n\nenum Color { RED, GREEN, BLUE }\nenum Status { OK = 0, ERROR = 1 }\n```\n\n### Tipos Compuestos (Interseccion/Tipos Duck)\n```hemlock\n// Define structural types\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// Compound type: object must satisfy ALL types\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// Function parameters with compound types\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" is \" + p.age);\n}\n\n// Three or more types\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n\n// Extra fields allowed (duck typing)\nlet employee: HasName & HasAge = {\n    name: \"Bob\",\n    age: 25,\n    department: \"Engineering\"  // OK - extra fields ignored\n};\n```\n\nLos tipos compuestos proporcionan comportamiento similar a interfaces sin una palabra clave `interface` separada,\nconstruyendo sobre los paradigmas existentes de `define` y duck typing.\n\n### Alias de Tipos\n```hemlock\n// Simple type alias\ntype Integer = i32;\ntype Text = string;\n\n// Function type alias\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// Compound type alias (great for reusable interfaces)\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// Generic type alias\ntype Pair<T> = { first: T, second: T };\n\n// Using type aliases\nlet x: Integer = 42;\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\nLos alias de tipos crean atajos con nombre para tipos complejos, mejorando la legibilidad y mantenibilidad.\n\n### Tipos de Funcion\n```hemlock\n// Function type annotations for parameters\nfn apply_fn(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Higher-order function returning a function\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Async function types\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n\n// Function types with multiple parameters\ntype BinaryOp = fn(i32, i32): i32;\nlet add: BinaryOp = fn(a, b) { return a + b; };\n```\n\n### Parametros Const\n```hemlock\n// Const parameter - deep immutability\nfn print_all(const items: array) {\n    // items.push(4);  // ERROR: cannot mutate const parameter\n    for (item in items) {\n        print(item);\n    }\n}\n\n// Const with objects - no mutation through any path\nfn describe(const person: object) {\n    print(person.name);       // OK: reading is allowed\n    // person.name = \"Bob\";   // ERROR: cannot mutate\n}\n\n// Nested access is allowed for reading\nfn get_city(const user: object) {\n    return user.address.city;  // OK: reading nested properties\n}\n```\n\nEl modificador `const` previene cualquier mutacion del parametro, incluyendo propiedades anidadas.\nEsto proporciona seguridad en tiempo de compilacion para funciones que no deben modificar sus entradas.\n\n### Parametros Ref (Paso por Referencia)\n```hemlock\n// Ref parameter - caller's variable is modified directly\nfn increment(ref x: i32) {\n    x = x + 1;  // Modifies the original variable\n}\n\nlet count = 10;\nincrement(count);\nprint(count);  // 11 - original was modified\n\n// Classic swap function\nfn swap(ref a: i32, ref b: i32) {\n    let temp = a;\n    a = b;\n    b = temp;\n}\n\nlet x = 1;\nlet y = 2;\nswap(x, y);\nprint(x, y);  // 2 1\n\n// Mix ref and regular parameters\nfn add_to(ref target: i32, amount: i32) {\n    target = target + amount;\n}\n\nlet total = 100;\nadd_to(total, 50);\nprint(total);  // 150\n```\n\nEl modificador `ref` pasa una referencia a la variable del llamador, permitiendo que la funcion\nla modifique directamente. Sin `ref`, los primitivos se pasan por valor (copiados). Use `ref` cuando\nnecesite mutar el estado del llamador sin devolver un valor.\n\n**Reglas:**\n- Los parametros `ref` deben recibir variables, no literales o expresiones\n- Funciona con todos los tipos (primitivos, arrays, objetos)\n- Combine con anotaciones de tipo: `ref x: i32`\n- No se puede combinar con `const` (son opuestos)\n\n### Firmas de Metodos en Define\n```hemlock\n// Define with method signatures (interface pattern)\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32   // Required method signature\n}\n\n// Objects must provide the required method\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// Optional methods with ?\ndefine Serializable {\n    fn serialize(): string,        // Required\n    fn pretty?(): string           // Optional method\n}\n\n// Self type refers to the defining type\ndefine Cloneable {\n    fn clone(): Self   // Returns same type as the object\n}\n```\n\nLas firmas de metodos en bloques `define` usan delimitadores de coma (como interfaces de TypeScript),\nestableciendo contratos que los objetos deben cumplir y habilitando patrones de programacion\nsimilares a interfaces con el sistema de duck typing de Hemlock.\n\n### Manejo de Errores\n```hemlock\ntry { throw \"error\"; } catch (e) { print(e); } finally { cleanup(); }\npanic(\"unrecoverable\");  // exits immediately, not catchable\n```\n\n### Async/Concurrencia\n```hemlock\nasync fn compute(n: i32): i32 { return n * n; }\nlet task = spawn(compute, 42);\nlet result = await task;     // or join(task)\ndetach(spawn(background_work));\n\nlet ch = channel(10);\nch.send(value);\nlet val = ch.recv();\nch.close();\n```\n\n**Propiedad de memoria:** Las tareas reciben copias de valores primitivos pero comparten punteros. Si pasa un `ptr` a una tarea generada, debe asegurarse de que la memoria permanezca valida hasta que la tarea complete. Use `join()` antes de `free()`, o use canales para senalar finalizacion.\n\n### Entrada de Usuario\n```hemlock\nlet name = read_line();          // Read line from stdin (blocks)\nprint(\"Hello, \" + name);\neprint(\"Error message\");         // Print to stderr\n\n// read_line() returns null on EOF\nwhile (true) {\n    let line = read_line();\n    if (line == null) { break; }\n    print(\"Got:\", line);\n}\n```\n\n### E/S de Archivos\n```hemlock\nlet f = open(\"file.txt\", \"r\");  // modes: r, w, a, r+, w+, a+\nlet content = f.read();\nf.write(\"data\");\nf.seek(0);\nf.close();\n```\n\n### Senales\n```hemlock\nsignal(SIGINT, fn(sig) { print(\"Interrupted\"); });\nraise(SIGUSR1);\n```\n\n---\n\n## Metodos de String (19)\n\n`substr`, `slice`, `find`, `contains`, `split`, `trim`, `to_upper`, `to_lower`,\n`starts_with`, `ends_with`, `replace`, `replace_all`, `repeat`, `char_at`,\n`byte_at`, `chars`, `bytes`, `to_bytes`, `deserialize`\n\nStrings de plantilla: `` `Hello ${name}!` ``\n\n**Mutabilidad de strings:** Los strings son mutables via asignacion por indice (`s[0] = 'H'`), pero todos los metodos de string devuelven nuevos strings sin modificar el original. Esto permite mutacion in situ cuando se necesita mientras mantiene el encadenamiento de metodos funcional.\n\n**Propiedades de longitud de string:**\n```hemlock\nlet s = \"hello \";\nprint(s.length);       // 7 (character/rune count)\nprint(s.byte_length);  // 10 (byte count - emoji is 4 bytes UTF-8)\n```\n\n## Metodos de Array (18)\n\n`push`, `pop`, `shift`, `unshift`, `insert`, `remove`, `find`, `contains`,\n`slice`, `join`, `concat`, `reverse`, `first`, `last`, `clear`, `map`, `filter`, `reduce`\n\nArrays tipados: `let nums: array<i32> = [1, 2, 3];`\n\n---\n\n## Biblioteca Estandar (40 modulos)\n\nImporte con prefijo `@stdlib/`:\n```hemlock\nimport { sin, cos, PI } from \"@stdlib/math\";\nimport { HashMap, Queue, Set } from \"@stdlib/collections\";\nimport { read_file, write_file } from \"@stdlib/fs\";\nimport { TcpStream, UdpSocket } from \"@stdlib/net\";\n```\n\n| Modulo | Descripcion |\n|--------|-------------|\n| `arena` | Asignador de memoria arena (asignacion bump) |\n| `args` | Analisis de argumentos de linea de comandos |\n| `assert` | Utilidades de asercion |\n| `async` | ThreadPool, parallel_map |\n| `async_fs` | Operaciones de E/S de archivos asincronas |\n| `collections` | HashMap, Queue, Stack, Set, LinkedList, LRUCache |\n| `compression` | gzip, gunzip, deflate |\n| `crypto` | aes_encrypt, rsa_sign, random_bytes |\n| `csv` | Analisis y generacion de CSV |\n| `datetime` | Clase DateTime, formateo, analisis |\n| `encoding` | base64_encode, hex_encode, url_encode |\n| `env` | getenv, setenv, exit, get_pid |\n| `fmt` | Utilidades de formateo de strings |\n| `fs` | read_file, write_file, list_dir, exists |\n| `glob` | Coincidencia de patrones de archivos |\n| `hash` | sha256, sha512, md5, djb2 |\n| `http` | http_get, http_post, http_request |\n| `ipc` | Comunicacion entre procesos |\n| `iter` | Utilidades de iterador |\n| `json` | parse, stringify, pretty, get, set |\n| `logging` | Logger con niveles |\n| `math` | sin, cos, sqrt, pow, rand, PI, E |\n| `net` | TcpListener, TcpStream, UdpSocket |\n| `os` | platform, arch, cpu_count, hostname |\n| `path` | Manipulacion de rutas de archivos |\n| `process` | fork, exec, wait, kill |\n| `random` | Generacion de numeros aleatorios |\n| `regex` | compile, test (POSIX ERE) |\n| `retry` | Logica de reintento con backoff |\n| `semver` | Versionado semantico |\n| `shell` | Utilidades de comandos shell |\n| `sqlite` | Base de datos SQLite, query, exec, transacciones |\n| `strings` | pad_left, is_alpha, reverse, lines |\n| `terminal` | Colores y estilos ANSI |\n| `testing` | describe, test, expect |\n| `time` | now, time_ms, sleep, clock |\n| `toml` | Analisis y generacion de TOML |\n| `url` | Analisis y manipulacion de URL |\n| `uuid` | Generacion de UUID |\n| `websocket` | Cliente WebSocket |\n\nConsulte `stdlib/docs/` para documentacion detallada de modulos.\n\n---\n\n## FFI (Interfaz de Funcion Foranea)\n\nDeclare y llame funciones C desde bibliotecas compartidas:\n```hemlock\nimport \"libc.so.6\";\n\nextern fn strlen(s: string): i32;\nextern fn getpid(): i32;\n\nlet len = strlen(\"Hello!\");  // 6\nlet pid = getpid();\n```\n\nExporte funciones FFI desde modulos:\n```hemlock\n// string_utils.hml\nimport \"libc.so.6\";\n\nexport extern fn strlen(s: string): i32;\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n```\n\nFFI dinamico (enlace en tiempo de ejecucion):\n```hemlock\nlet lib = ffi_open(\"libc.so.6\");\nlet puts = ffi_bind(lib, \"puts\", [FFI_POINTER], FFI_INT);\nputs(\"Hello from C!\");\nffi_close(lib);\n```\n\nTipos: `FFI_INT`, `FFI_DOUBLE`, `FFI_POINTER`, `FFI_STRING`, `FFI_VOID`, etc.\n\n---\n\n## Operaciones Atomicas\n\nProgramacion concurrente sin bloqueos con operaciones atomicas:\n\n```hemlock\n// Allocate memory for atomic i32\nlet p = alloc(4);\nptr_write_i32(p, 0);\n\n// Atomic load/store\nlet val = atomic_load_i32(p);        // Read atomically\natomic_store_i32(p, 42);             // Write atomically\n\n// Fetch-and-modify operations (return OLD value)\nlet old = atomic_add_i32(p, 10);     // Add, return old\nold = atomic_sub_i32(p, 5);          // Subtract, return old\nold = atomic_and_i32(p, 0xFF);       // Bitwise AND\nold = atomic_or_i32(p, 0x10);        // Bitwise OR\nold = atomic_xor_i32(p, 0x0F);       // Bitwise XOR\n\n// Compare-and-swap (CAS)\nlet success = atomic_cas_i32(p, 42, 100);  // If *p == 42, set to 100\n// Returns true if swap succeeded, false otherwise\n\n// Atomic exchange\nold = atomic_exchange_i32(p, 999);   // Swap, return old\n\nfree(p);\n\n// i64 variants available (atomic_load_i64, atomic_add_i64, etc.)\n\n// Memory fence (full barrier)\natomic_fence();\n```\n\nTodas las operaciones usan consistencia secuencial (`memory_order_seq_cst`).\n\n---\n\n## Estructura del Proyecto\n\n```\nhemlock/\n src/\n    frontend/         # Shared: lexer, parser, AST, modules\n    backends/\n       interpreter/  # hemlock: tree-walking interpreter\n       compiler/     # hemlockc: C code generator\n    tools/\n       lsp/          # Language Server Protocol\n       bundler/      # Bundle/package tools\n runtime/              # Compiled program runtime (libhemlock_runtime.a)\n stdlib/               # Standard library (40 modules)\n    docs/             # Module documentation\n docs/                 # Full documentation\n    language-guide/   # Types, strings, arrays, etc.\n    reference/        # API references\n    advanced/         # Async, FFI, signals, etc.\n tests/                # 625+ tests\n examples/             # Example programs\n```\n\n---\n\n## Guias de Estilo de Codigo\n\n### Constantes y Numeros Magicos\n\nAl agregar constantes numericas al codigo base en C, siga estas guias:\n\n1. **Defina constantes en `include/hemlock_limits.h`** - Este archivo es la ubicacion central para todos los limites de tiempo de compilacion y ejecucion, capacidades y constantes con nombre.\n\n2. **Use nombres descriptivos con prefijo `HML_`** - Todas las constantes deben tener prefijo `HML_` para claridad de espacio de nombres.\n\n3. **Evite numeros magicos** - Reemplace valores numericos codificados con constantes con nombre. Ejemplos:\n   - Limites de rango de tipos: `HML_I8_MIN`, `HML_I8_MAX`, `HML_U32_MAX`\n   - Capacidades de buffer: `HML_INITIAL_ARRAY_CAPACITY`, `HML_INITIAL_LEXER_BUFFER_CAPACITY`\n   - Conversiones de tiempo: `HML_NANOSECONDS_PER_SECOND`, `HML_MILLISECONDS_PER_SECOND`\n   - Semillas de hash: `HML_DJB2_HASH_SEED`\n   - Valores ASCII: `HML_ASCII_CASE_OFFSET`, `HML_ASCII_PRINTABLE_START`\n\n4. **Incluya `hemlock_limits.h`** - Los archivos fuente deben incluir este encabezado (frecuentemente via `internal.h`) para acceder a las constantes.\n\n5. **Documente el proposito** - Agregue un comentario explicando lo que cada constante representa.\n\n---\n\n## Que NO Hacer\n\n- No agregar comportamiento implicito (ASI, GC, limpieza automatica)\n- No ocultar complejidad (optimizaciones magicas, conteos de referencias ocultos)\n- No romper semantica existente (punto y coma, memoria manual, strings mutables)\n- No perder precision en conversiones implicitas\n- No usar numeros magicos - defina constantes con nombre en `hemlock_limits.h` en su lugar\n\n---\n\n## Pruebas\n\n```bash\nmake test              # Run interpreter tests\nmake test-compiler     # Run compiler tests\nmake parity            # Run parity tests (both must match)\nmake test-all          # Run all test suites\n```\n\n**Importante:** Las pruebas pueden colgarse debido a problemas de async/concurrencia. Siempre use un timeout al ejecutar pruebas:\n```bash\ntimeout 60 make test   # 60 second timeout\ntimeout 120 make parity\n```\n\nCategorias de pruebas: primitives, memory, strings, arrays, functions, objects, async, ffi, defer, signals, switch, bitwise, typed_arrays, modules, stdlib_*\n\n---\n\n## Arquitectura del Compilador/Interprete\n\nHemlock tiene dos backends de ejecucion que comparten un frontend comun:\n\n```\nSource (.hml)\n    \n\n  SHARED FRONTEND            \n  - Lexer (src/frontend/)    \n  - Parser (src/frontend/)   \n  - AST (src/frontend/)      \n\n                        \n    \n INTERPRETER      COMPILER  \n (hemlock)       (hemlockc) \n                            \n Tree-walk       Type check \n evaluation      AST  C    \n                 gcc link   \n    \n```\n\n### Verificacion de Tipos del Compilador\n\nEl compilador (`hemlockc`) incluye verificacion de tipos en tiempo de compilacion, **habilitada por defecto**:\n\n```bash\nhemlockc program.hml -o program    # Type checks, then compiles\nhemlockc --check program.hml       # Type check only, don't compile\nhemlockc --no-type-check prog.hml  # Disable type checking\nhemlockc --strict-types prog.hml   # Warn on implicit 'any' types\n```\n\nEl verificador de tipos:\n- Valida anotaciones de tipo en tiempo de compilacion\n- Trata codigo sin tipo como dinamico (tipo `any`) - siempre valido\n- Proporciona sugerencias de optimizacion para unboxing\n- Usa conversiones numericas permisivas (rango validado en tiempo de ejecucion)\n\n### Estructura de Directorios\n\n```\nhemlock/\n src/\n    frontend/           # Shared: lexer, parser, AST, modules\n       lexer.c\n       parser/\n       ast.c\n       module.c\n    backends/\n       interpreter/    # hemlock: tree-walking interpreter\n          main.c\n          runtime/\n          builtins/\n       compiler/       # hemlockc: C code generator\n           main.c\n           codegen/\n    tools/\n       lsp/            # Language server\n       bundler/        # Bundle/package tools\n runtime/                # libhemlock_runtime.a for compiled programs\n stdlib/                 # Shared standard library\n tests/\n     parity/             # Tests that MUST pass both backends\n     interpreter/        # Interpreter-specific tests\n     compiler/           # Compiler-specific tests\n```\n\n---\n\n## Desarrollo con Paridad Primero\n\n**Tanto el interprete como el compilador deben producir salida identica para la misma entrada.**\n\n### Politica de Desarrollo\n\nAl agregar o modificar caracteristicas del lenguaje:\n\n1. **Disenar** - Definir el cambio AST/semantico en el frontend compartido\n2. **Implementar interprete** - Agregar evaluacion tree-walking\n3. **Implementar compilador** - Agregar generacion de codigo C\n4. **Agregar prueba de paridad** - Escribir prueba en `tests/parity/` con archivo `.expected`\n5. **Verificar** - Ejecutar `make parity` antes de fusionar\n\n### Estructura de Pruebas de Paridad\n\n```\ntests/parity/\n language/       # Core language features (control flow, closures, etc.)\n builtins/       # Built-in functions (print, typeof, memory, etc.)\n methods/        # String and array methods\n modules/        # Import/export, stdlib imports\n```\n\nCada prueba tiene dos archivos:\n- `feature.hml` - El programa de prueba\n- `feature.expected` - Salida esperada (debe coincidir para ambos backends)\n\n### Resultados de Pruebas de Paridad\n\n| Estado | Significado |\n|--------|-------------|\n| ` PASSED` | Tanto interprete como compilador coinciden con salida esperada |\n| ` INTERP_ONLY` | Interprete funciona, compilador falla (necesita correccion del compilador) |\n| ` COMPILER_ONLY` | Compilador funciona, interprete falla (raro) |\n| ` FAILED` | Ambos fallan (error de prueba o implementacion) |\n\n### Que Requiere Paridad\n\n- Todas las construcciones del lenguaje (if, while, for, switch, defer, try/catch)\n- Todos los operadores (aritmeticos, bitwise, logicos, comparacion)\n- Todas las funciones incorporadas (print, typeof, alloc, etc.)\n- Todos los metodos de string y array\n- Reglas de coercion y promocion de tipos\n- Mensajes de error para errores en tiempo de ejecucion\n\n### Que Puede Diferir\n\n- Caracteristicas de rendimiento\n- Detalles de disposicion de memoria\n- Formato de debug/stack trace\n- Errores de compilacion (el compilador puede detectar mas en tiempo de compilacion)\n\n### Agregar una Prueba de Paridad\n\n```bash\n# 1. Create test file\ncat > tests/parity/language/my_feature.hml << 'EOF'\n// Test description\nlet x = some_feature();\nprint(x);\nEOF\n\n# 2. Generate expected output from interpreter\n./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected\n\n# 3. Verify parity\nmake parity\n```\n\n---\n\n## Version\n\n**v1.8.0** - Version actual con:\n- **Coincidencia de patrones** (expresiones `match`) - Desestructuracion y flujo de control poderosos:\n  - Patrones literales, comodin y enlace de variables\n  - Patrones OR (`1 | 2 | 3`)\n  - Expresiones guard (`n if n > 0`)\n  - Desestructuracion de objetos (`{ x, y }`)\n  - Desestructuracion de arrays con rest (`[first, ...rest]`)\n  - Patrones de tipo (`n: i32`)\n  - Paridad completa entre interprete y compilador\n- **Anotaciones auxiliares del compilador** - 11 anotaciones de optimizacion para control de GCC/Clang:\n  - `@inline`, `@noinline` - control de inlining de funciones\n  - `@hot`, `@cold` - sugerencias de prediccion de rama\n  - `@pure`, `@const` - anotaciones de efectos secundarios\n  - `@flatten` - hacer inline a todas las llamadas dentro de la funcion\n  - `@optimize(level)` - nivel de optimizacion por funcion (\"0\", \"1\", \"2\", \"3\", \"s\", \"fast\")\n  - `@warn_unused` - advertir sobre valores de retorno ignorados\n  - `@section(name)` - colocacion de seccion ELF personalizada (ej., `@section(\".text.hot\")`)\n- **Funciones con cuerpo de expresion** (`fn double(x): i32 => x * 2;`) - sintaxis concisa de funcion de una sola expresion\n- **Sentencias de una linea** - sintaxis sin llaves para `if`, `while`, `for` (ej., `if (x > 0) print(x);`)\n- **Alias de tipos** (`type Name = Type;`) - atajos con nombre para tipos complejos\n- **Anotaciones de tipo de funcion** (`fn(i32): i32`) - tipos de funcion de primera clase\n- **Parametros const** (`fn(const x: array)`) - inmutabilidad profunda para parametros\n- **Parametros ref** (`fn(ref x: i32)`) - paso por referencia para mutacion directa del llamador\n- **Firmas de metodos en define** (`fn method(): Type`) - contratos tipo interfaz (delimitados por coma)\n- **Tipo Self** en firmas de metodos - se refiere al tipo que define\n- **Palabra clave loop** (`loop { }`) - bucles infinitos mas limpios, reemplaza `while (true)`\n- **Etiquetas de bucle** (`outer: while`) - break/continue dirigido para bucles anidados\n- **Shorthand de objetos** (`{ name }`) - sintaxis de propiedad abreviada estilo ES6\n- **Spread de objetos** (`{ ...obj }`) - copiar y fusionar campos de objetos\n- **Tipos duck compuestos** (`A & B & C`) - tipos de interseccion para tipado estructural\n- **Argumentos con nombre** para llamadas de funcion (`foo(name: \"value\", age: 30)`)\n- **Operadores de coalescencia nula** (`??`, `??=`, `?.`) para manejo seguro de null\n- **Literales octales** (`0o777`, `0O123`)\n- **Separadores numericos** (`1_000_000`, `0xFF_FF`, `0b1111_0000`)\n- **Comentarios de bloque** (`/* ... */`)\n- **Secuencias de escape hexadecimales** en strings/runes (`\\x41` = 'A')\n- **Secuencias de escape Unicode** en strings (`\\u{1F600}` = )\n- **Literales flotantes sin cero inicial** (`.5`, `.123`, `.5e2`)\n- **Verificacion de tipos en tiempo de compilacion** en hemlockc (habilitada por defecto)\n- **Integracion LSP** con verificacion de tipos para diagnosticos en tiempo real\n- **Operadores de asignacion compuesta** (`+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`)\n- **Operadores de incremento/decremento** (`++x`, `x++`, `--x`, `x--`)\n- **Correccion de precision de tipos**: i64/u64 + f32  f64 para preservar precision\n- Sistema de tipos unificado con sugerencias de optimizacion de unboxing\n- Sistema de tipos completo (i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object, enum, file, task, channel)\n- Strings UTF-8 con 19 metodos\n- Arrays con 18 metodos incluyendo map/filter/reduce\n- Gestion manual de memoria con `talloc()` y `sizeof()`\n- Async/await con verdadero paralelismo pthread\n- Operaciones atomicas para programacion concurrente sin bloqueos\n- 40 modulos stdlib (+ arena, assert, semver, toml, retry, iter, random, shell)\n- FFI para interoperabilidad con C con `export extern fn` para wrappers de biblioteca reutilizables\n- Soporte de struct FFI en compilador (pasar structs C por valor)\n- Helpers de puntero FFI (`ptr_null`, `ptr_read_*`, `ptr_write_*`)\n- defer, try/catch/finally/throw, panic\n- E/S de archivos, manejo de senales, ejecucion de comandos\n- Gestor de paquetes [hpm](https://github.com/hemlang/hpm) con registro basado en GitHub\n- Backend de compilador (generacion de codigo C) con 100% de paridad con interprete\n- Servidor LSP con ir-a-definicion y encontrar-referencias\n- Paso de optimizacion AST y resolucion de variables para busqueda O(1)\n- Builtin apply() para llamadas de funcion dinamicas\n- Canales sin buffer y soporte de muchos parametros\n- 159 pruebas de paridad (100% tasa de aprobacion)\n\n---\n\n## Filosofia\n\n> Le damos las herramientas para estar seguro (`buffer`, anotaciones de tipo, verificacion de limites) pero no le obligamos a usarlas (`ptr`, memoria manual, operaciones inseguras).\n\n**Si no esta seguro de si una caracteristica encaja en Hemlock, pregunte: \"Esto le da al programador mas control explicito, o esconde algo?\"**\n\nSi esconde, probablemente no pertenece a Hemlock.\n"}, "Primeros Pasos -> Inicio Rpido": {"id": "getting-started-quick-start", "content": "# Inicio Rapido\n\nPonga Hemlock en funcionamiento en minutos.\n\n## Su Primer Programa\n\nCree un archivo llamado `hello.hml`:\n\n```hemlock\nprint(\"Hello, Hemlock!\");\n```\n\nEjecute con el interprete:\n\n```bash\n./hemlock hello.hml\n```\n\nO compile a un ejecutable nativo:\n\n```bash\n./hemlockc hello.hml -o hello\n./hello\n```\n\nSalida:\n```\nHello, Hemlock!\n```\n\n### Interprete vs Compilador\n\nHemlock proporciona dos formas de ejecutar programas:\n\n| Herramienta | Caso de Uso | Verificacion de Tipos |\n|-------------|-------------|----------------------|\n| `hemlock` | Scripts rapidos, REPL, desarrollo | Solo en tiempo de ejecucion |\n| `hemlockc` | Binarios de produccion, mejor rendimiento | Tiempo de compilacion (por defecto) |\n\nEl compilador (`hemlockc`) verifica los tipos de su codigo antes de generar un ejecutable, detectando errores tempranamente.\n\n## Sintaxis Basica\n\n### Variables\n\n```hemlock\n// Las variables se declaran con 'let'\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\n// Las anotaciones de tipo son opcionales\nlet count: i32 = 100;\nlet ratio: f64 = 0.618;\n```\n\n**Importante**: Los puntos y coma son **obligatorios** en Hemlock.\n\n### Tipos\n\nHemlock tiene un sistema de tipos rico:\n\n```hemlock\n// Enteros\nlet small: i8 = 127;          // 8 bits con signo\nlet byte: u8 = 255;           // 8 bits sin signo\nlet num: i32 = 2147483647;    // 32 bits con signo (por defecto)\nlet big: i64 = 9223372036854775807;  // 64 bits con signo\n\n// Flotantes\nlet f: f32 = 3.14;            // flotante de 32 bits\nlet d: f64 = 2.71828;         // flotante de 64 bits (por defecto)\n\n// Cadenas y caracteres\nlet text: string = \"Hello\";   // cadena UTF-8\nlet emoji: rune = '';       // punto de codigo Unicode\n\n// Booleano y nulo\nlet flag: bool = true;\nlet empty = null;\n```\n\n### Flujo de Control\n\n```hemlock\n// Sentencias if\nif (x > 0) {\n    print(\"positive\");\n} else if (x < 0) {\n    print(\"negative\");\n} else {\n    print(\"zero\");\n}\n\n// Bucles while\nlet i = 0;\nwhile (i < 5) {\n    print(i);\n    i = i + 1;\n}\n\n// Bucles for\nfor (let j = 0; j < 10; j = j + 1) {\n    print(j);\n}\n```\n\n### Funciones\n\n```hemlock\n// Funcion con nombre\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nlet result = add(5, 3);  // 8\n\n// Funcion anonima\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(multiply(4, 7));  // 28\n```\n\n## Trabajando con Cadenas\n\nLas cadenas en Hemlock son **mutables** y **UTF-8**:\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';              // Ahora \"Hello\"\nprint(s);\n\n// Metodos de cadena\nlet upper = s.to_upper();     // \"HELLO\"\nlet words = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\nlet sub = s.substr(1, 3);     // \"ell\"\n\n// Concatenacion\nlet greeting = \"Hello\" + \", \" + \"World!\";\nprint(greeting);  // \"Hello, World!\"\n```\n\n## Arreglos\n\nArreglos dinamicos con tipos mixtos:\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Metodos de arreglo\nnumbers.push(6);        // [1, 2, 3, 4, 5, 6]\nlet last = numbers.pop();  // 6\nlet slice = numbers.slice(1, 4);  // [2, 3, 4]\n\n// Tipos mixtos permitidos\nlet mixed = [1, \"two\", true, null];\n```\n\n## Objetos\n\nObjetos al estilo JavaScript:\n\n```hemlock\n// Literal de objeto\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nperson.age = 31;     // Modificar campo\n\n// Metodos con 'self'\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## Gestion de Memoria\n\nHemlock usa **gestion de memoria manual**:\n\n```hemlock\n// Buffer seguro (recomendado)\nlet buf = buffer(64);   // Asignar 64 bytes\nbuf[0] = 65;            // Establecer primer byte a 'A'\nprint(buf[0]);          // 65\nfree(buf);              // Liberar memoria\n\n// Puntero crudo (avanzado)\nlet ptr = alloc(100);\nmemset(ptr, 0, 100);    // Llenar con ceros\nfree(ptr);\n```\n\n**Importante**: Debe liberar con `free()` lo que asigna con `alloc()`.\n\n## Manejo de Errores\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Error: \" + e);\n} finally {\n    print(\"Done\");\n}\n```\n\n## Argumentos de Linea de Comandos\n\nAcceda a los argumentos del programa a traves del arreglo `args`:\n\n```hemlock\n// script.hml\nprint(\"Script:\", args[0]);\nprint(`Arguments: ${args.length - 1}`);\n\nlet i = 1;\nwhile (i < args.length) {\n    print(`  arg ${i}: ${args[i]}`);\n    i = i + 1;\n}\n```\n\nEjecute con:\n```bash\n./hemlock script.hml hello world\n```\n\nSalida:\n```\nScript: script.hml\nArguments: 2\n  arg 1: hello\n  arg 2: world\n```\n\n## E/S de Archivos\n\n```hemlock\n// Escribir en archivo\nlet f = open(\"data.txt\", \"w\");\nf.write(\"Hello, File!\");\nf.close();\n\n// Leer de archivo\nlet f2 = open(\"data.txt\", \"r\");\nlet content = f2.read();\nprint(content);  // \"Hello, File!\"\nf2.close();\n```\n\n## Que Sigue\n\nAhora que ha visto lo basico, explore mas:\n\n- [Tutorial](#getting-started-tutorial) - Guia completa paso a paso\n- [Guia del Lenguaje](#language-guide-syntax) - Profundice en todas las caracteristicas\n- [Ejemplos](../../examples/) - Programas de ejemplo del mundo real\n- [Referencia de API](#reference-builtins) - Documentacion completa de la API\n\n## Errores Comunes\n\n### Olvidar los Puntos y Coma\n\n```hemlock\n//  ERROR: Falta punto y coma\nlet x = 42\nlet y = 10\n\n//  CORRECTO\nlet x = 42;\nlet y = 10;\n```\n\n### Olvidar Liberar Memoria\n\n```hemlock\n//  FUGA DE MEMORIA\nlet buf = buffer(100);\n// ... usar buf ...\n// Olvido llamar a free(buf)!\n\n//  CORRECTO\nlet buf = buffer(100);\n// ... usar buf ...\nfree(buf);\n```\n\n### Las Llaves Son Obligatorias\n\n```hemlock\n//  ERROR: Faltan llaves\nif (x > 0)\n    print(\"positive\");\n\n//  CORRECTO\nif (x > 0) {\n    print(\"positive\");\n}\n```\n\n## Obteniendo Ayuda\n\n- Lea la [documentacion completa](../README.md)\n- Revise el [directorio de ejemplos](../../examples/)\n- Vea los [archivos de prueba](../../tests/) para patrones de uso\n- Reporte problemas en GitHub\n"}, "Primeros Pasos -> Instalacin": {"id": "getting-started-installation", "content": "# Instalacion\n\nEsta guia le ayudara a compilar e instalar Hemlock en su sistema.\n\n## Instalacion Rapida (Recomendada)\n\nLa forma mas sencilla de instalar Hemlock es usando el script de instalacion de una linea:\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash\n```\n\nEsto descarga e instala el binario precompilado mas reciente para su plataforma (Linux o macOS, x86_64 o arm64).\n\n### Opciones de Instalacion\n\n```bash\n# Instalar en un prefijo personalizado (por defecto: ~/.local)\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local\n\n# Instalar una version especifica\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0\n\n# Instalar y actualizar automaticamente el PATH del shell\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path\n```\n\nDespues de la instalacion, verifique que funciona:\n\n```bash\nhemlock --version\n```\n\n---\n\n## Compilacion desde el Codigo Fuente\n\nSi prefiere compilar desde el codigo fuente o los binarios precompilados no funcionan en su sistema, siga las instrucciones a continuacion.\n\n## Requisitos Previos\n\n### Dependencias Requeridas\n\nHemlock requiere las siguientes dependencias para compilar:\n\n- **Compilador C**: GCC o Clang (estandar C11)\n- **Make**: GNU Make\n- **libffi**: Biblioteca de Interfaz de Funciones Foraneas (para soporte FFI)\n- **OpenSSL**: Biblioteca criptografica (para funciones hash: md5, sha1, sha256)\n- **libwebsockets**: Soporte para cliente/servidor WebSocket y HTTP\n- **zlib**: Biblioteca de compresion\n\n### Instalacion de Dependencias\n\n**macOS:**\n```bash\n# Instalar Homebrew si aun no esta instalado\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Instalar Xcode Command Line Tools\nxcode-select --install\n\n# Instalar dependencias via Homebrew\nbrew install libffi openssl@3 libwebsockets\n```\n\n**Nota para usuarios de macOS**: El Makefile detecta automaticamente las instalaciones de Homebrew y configura las rutas correctas de include/library. Hemlock soporta arquitecturas Intel (x86_64) y Apple Silicon (arm64).\n\n**Ubuntu/Debian:**\n```bash\nsudo apt-get update\nsudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev\n```\n\n**Fedora/RHEL:**\n```bash\nsudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel\n```\n\n**Arch Linux:**\n```bash\nsudo pacman -S base-devel libffi openssl libwebsockets zlib\n```\n\n## Compilacion desde el Codigo Fuente\n\n### 1. Clonar el Repositorio\n\n```bash\ngit clone https://github.com/hemlang/hemlock.git\ncd hemlock\n```\n\n### 2. Compilar Hemlock\n\n```bash\nmake\n```\n\nEsto compilara el interprete de Hemlock y colocara el ejecutable en el directorio actual.\n\n### 3. Verificar la Instalacion\n\n```bash\n./hemlock --version\n```\n\nDeberia ver la informacion de version de Hemlock.\n\n### 4. Probar la Compilacion\n\nEjecute el conjunto de pruebas para asegurarse de que todo funciona correctamente:\n\n```bash\nmake test\n```\n\nTodas las pruebas deberian pasar. Si ve algun fallo, por favor reportelo como un issue.\n\n## Instalacion a Nivel del Sistema (Opcional)\n\nPara instalar Hemlock a nivel del sistema (por ejemplo, en `/usr/local/bin`):\n\n```bash\nsudo make install\n```\n\nEsto le permite ejecutar `hemlock` desde cualquier lugar sin especificar la ruta completa.\n\n## Ejecutando Hemlock\n\n### REPL Interactivo\n\nInicie el bucle Leer-Evaluar-Imprimir (REPL):\n\n```bash\n./hemlock\n```\n\nVera un prompt donde puede escribir codigo Hemlock:\n\n```\nHemlock REPL\n> print(\"Hello, World!\");\nHello, World!\n> let x = 42;\n> print(x * 2);\n84\n>\n```\n\nSalga del REPL con `Ctrl+D` o `Ctrl+C`.\n\n### Ejecutando Programas\n\nEjecute un script de Hemlock:\n\n```bash\n./hemlock program.hml\n```\n\nCon argumentos de linea de comandos:\n\n```bash\n./hemlock program.hml arg1 arg2 \"argumento con espacios\"\n```\n\n## Estructura de Directorios\n\nDespues de compilar, su directorio de Hemlock se vera asi:\n\n```\nhemlock/\n hemlock           # Ejecutable del interprete compilado\n src/              # Codigo fuente\n include/          # Archivos de cabecera\n tests/            # Conjunto de pruebas\n examples/         # Programas de ejemplo\n docs/             # Documentacion\n stdlib/           # Biblioteca estandar\n Makefile          # Configuracion de compilacion\n README.md         # README del proyecto\n```\n\n## Opciones de Compilacion\n\n### Compilacion de Depuracion\n\nCompilar con simbolos de depuracion y sin optimizacion:\n\n```bash\nmake debug\n```\n\n### Compilacion Limpia\n\nEliminar todos los archivos compilados:\n\n```bash\nmake clean\n```\n\nRecompilar desde cero:\n\n```bash\nmake clean && make\n```\n\n## Solucion de Problemas\n\n### macOS: Errores de Biblioteca No Encontrada\n\nSi obtiene errores sobre bibliotecas faltantes (`-lcrypto`, `-lffi`, etc.):\n\n1. Asegurese de que las dependencias de Homebrew estan instaladas:\n   ```bash\n   brew install libffi openssl@3 libwebsockets\n   ```\n\n2. Verifique las rutas de Homebrew:\n   ```bash\n   brew --prefix libffi\n   brew --prefix openssl\n   ```\n\n3. El Makefile deberia auto-detectar estas rutas. Si no lo hace, verifique que `brew` esta en su PATH:\n   ```bash\n   which brew\n   ```\n\n### macOS: Errores de Tipo BSD (`u_int`, `u_char` no encontrado)\n\nSi ve errores sobre nombres de tipo desconocidos como `u_int` o `u_char`:\n\n1. Esto se corrigio en v1.0.0+ usando `_DARWIN_C_SOURCE` en lugar de `_POSIX_C_SOURCE`\n2. Asegurese de tener la version mas reciente del codigo\n3. Limpie y recompile:\n   ```bash\n   make clean && make\n   ```\n\n### Linux: libffi No Encontrada\n\nSi obtiene errores sobre `ffi.h` o `-lffi` faltantes:\n\n1. Asegurese de que `libffi-dev` esta instalada (vea las dependencias arriba)\n2. Verifique si `pkg-config` puede encontrarla:\n   ```bash\n   pkg-config --cflags --libs libffi\n   ```\n3. Si no se encuentra, puede necesitar configurar `PKG_CONFIG_PATH`:\n   ```bash\n   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH\n   ```\n\n### Errores de Compilacion\n\nSi encuentra errores de compilacion:\n\n1. Asegurese de tener un compilador compatible con C11\n2. En macOS, intente usar Clang (por defecto):\n   ```bash\n   make CC=clang\n   ```\n3. En Linux, intente usar GCC:\n   ```bash\n   make CC=gcc\n   ```\n4. Verifique que todas las dependencias estan instaladas\n5. Intente recompilar desde cero:\n   ```bash\n   make clean && make\n   ```\n\n### Fallos en las Pruebas\n\nSi las pruebas fallan:\n\n1. Verifique que tiene la version mas reciente del codigo\n2. Intente recompilar desde cero:\n   ```bash\n   make clean && make test\n   ```\n3. En macOS, asegurese de tener las Xcode Command Line Tools mas recientes:\n   ```bash\n   xcode-select --install\n   ```\n4. Reporte el problema en GitHub con:\n   - Su plataforma (version de macOS / distribucion de Linux)\n   - Arquitectura (x86_64 / arm64)\n   - Salida de las pruebas\n   - Salida de `make -v` y `gcc --version` (o `clang --version`)\n\n## Proximos Pasos\n\n- [Guia de Inicio Rapido](#getting-started-quick-start) - Escriba su primer programa en Hemlock\n- [Tutorial](#getting-started-tutorial) - Aprenda Hemlock paso a paso\n- [Guia del Lenguaje](#language-guide-syntax) - Explore las caracteristicas de Hemlock\n"}, "Primeros Pasos -> Rutas de Aprendizaje": {"id": "getting-started-learning-paths", "content": "# Rutas de Aprendizaje\n\nDiferentes objetivos requieren diferentes conocimientos. Elija la ruta que coincida con lo que desea construir.\n\n---\n\n## Ruta 1: Scripts Rapidos y Automatizacion\n\n**Objetivo:** Escribir scripts para automatizar tareas, procesar archivos y realizar trabajos.\n\n**Tiempo para ser productivo:** Rapido - puede comenzar a escribir scripts utiles inmediatamente.\n\n### Lo Que Aprendera\n\n1. **[Inicio Rapido](#getting-started-quick-start)** - Su primer programa, sintaxis basica\n2. **[Cadenas](#language-guide-strings)** - Procesamiento de texto, division, busqueda\n3. **[Arreglos](#language-guide-arrays)** - Listas, filtrado, transformacion de datos\n4. **[E/S de Archivos](#advanced-file-io)** - Lectura y escritura de archivos\n5. **[Argumentos de Linea de Comandos](#advanced-command-line-args)** - Obtener entrada de usuarios\n\n### Omitir Por Ahora\n\n- Gestion de memoria (automatica para scripts)\n- Async/concurrencia (excesivo para scripts simples)\n- FFI (solo necesario para interoperabilidad con C)\n\n### Proyecto de Ejemplo: Renombrador de Archivos\n\n```hemlock\nimport { list_dir, rename } from \"@stdlib/fs\";\n\n// Renombrar todos los archivos .txt a .md\nlet files = list_dir(\".\");\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let new_name = file.replace(\".txt\", \".md\");\n        rename(file, new_name);\n        print(`Renamed: ${file} -> ${new_name}`);\n    }\n}\n```\n\n---\n\n## Ruta 2: Procesamiento y Analisis de Datos\n\n**Objetivo:** Analizar datos, transformarlos, generar informes.\n\n**Tiempo para ser productivo:** Rapido - los metodos de cadenas y arreglos de Hemlock lo hacen facil.\n\n### Lo Que Aprendera\n\n1. **[Inicio Rapido](#getting-started-quick-start)** - Conceptos basicos\n2. **[Cadenas](#language-guide-strings)** - Analisis, division, formato\n3. **[Arreglos](#language-guide-arrays)** - map, filter, reduce para transformacion de datos\n4. **[Objetos](#language-guide-objects)** - Datos estructurados\n5. **Biblioteca Estandar:**\n   - **[@stdlib/json](#stdlib-json)** - Analisis de JSON\n   - **[@stdlib/csv](#stdlib-csv)** - Archivos CSV\n   - **[@stdlib/fs](#stdlib-fs)** - Operaciones de archivo\n\n### Proyecto de Ejemplo: Analizador CSV\n\n```hemlock\nimport { read_file } from \"@stdlib/fs\";\nimport { parse } from \"@stdlib/csv\";\n\nlet data = parse(read_file(\"sales.csv\"));\n\n// Calcular ventas totales\nlet total = 0;\nfor (row in data) {\n    total = total + f64(row.amount);\n}\n\nprint(`Total sales: $${total}`);\n\n// Encontrar el mejor vendedor\nlet top = data[0];\nfor (row in data) {\n    if (f64(row.amount) > f64(top.amount)) {\n        top = row;\n    }\n}\n\nprint(`Top sale: ${top.product} - $${top.amount}`);\n```\n\n---\n\n## Ruta 3: Programacion Web y de Redes\n\n**Objetivo:** Construir clientes HTTP, trabajar con APIs, crear servidores.\n\n**Tiempo para ser productivo:** Medio - requiere entender los conceptos basicos de async.\n\n### Lo Que Aprendera\n\n1. **[Inicio Rapido](#getting-started-quick-start)** - Conceptos basicos\n2. **[Funciones](#language-guide-functions)** - Callbacks y clausuras\n3. **[Manejo de Errores](#language-guide-error-handling)** - try/catch para errores de red\n4. **[Async y Concurrencia](#advanced-async-concurrency)** - spawn, await, canales\n5. **Biblioteca Estandar:**\n   - **[@stdlib/http](#stdlib-http)** - Solicitudes HTTP\n   - **[@stdlib/json](#stdlib-json)** - JSON para APIs\n   - **[@stdlib/net](#stdlib-net)** - Sockets TCP/UDP\n   - **[@stdlib/url](#stdlib-url)** - Analisis de URL\n\n### Proyecto de Ejemplo: Cliente de API\n\n```hemlock\nimport { http_get, http_post } from \"@stdlib/http\";\nimport { parse, stringify } from \"@stdlib/json\";\n\n// Solicitud GET\nlet response = http_get(\"https://api.example.com/users\");\nlet users = parse(response.body);\n\nfor (user in users) {\n    print(`${user.name}: ${user.email}`);\n}\n\n// Solicitud POST\nlet new_user = { name: \"Alice\", email: \"alice@example.com\" };\nlet result = http_post(\"https://api.example.com/users\", {\n    body: stringify(new_user),\n    headers: { \"Content-Type\": \"application/json\" }\n});\n\nprint(`Created user with ID: ${parse(result.body).id}`);\n```\n\n---\n\n## Ruta 4: Programacion de Sistemas\n\n**Objetivo:** Escribir codigo de bajo nivel, trabajar con memoria, interfaces con bibliotecas C.\n\n**Tiempo para ser productivo:** Mas largo - requiere entender la gestion de memoria.\n\n### Lo Que Aprendera\n\n1. **[Inicio Rapido](#getting-started-quick-start)** - Conceptos basicos\n2. **[Tipos](#language-guide-types)** - Entender i32, u8, ptr, etc.\n3. **[Gestion de Memoria](#language-guide-memory)** - alloc, free, buffers\n4. **[FFI](#advanced-ffi)** - Llamar funciones C\n5. **[Senales](#advanced-signals)** - Manejo de senales\n\n### Conceptos Clave\n\n**Lista de Verificacion de Seguridad de Memoria:**\n- [ ] Cada `alloc()` tiene un `free()` correspondiente\n- [ ] Usar `buffer()` a menos que necesite `ptr` crudo\n- [ ] Establecer punteros a `null` despues de liberar\n- [ ] Usar `try/finally` para garantizar limpieza\n\n**Mapeo de Tipos para FFI:**\n| Hemlock | C |\n|---------|---|\n| `i8` | `char` / `int8_t` |\n| `i32` | `int` |\n| `i64` | `long` (64-bit) |\n| `u8` | `unsigned char` |\n| `f64` | `double` |\n| `ptr` | `void*` |\n\n### Proyecto de Ejemplo: Pool de Memoria Personalizado\n\n```hemlock\n// Asignador bump simple\nlet pool_size = 1024 * 1024;  // 1MB\nlet pool = alloc(pool_size);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > pool_size) {\n        throw \"Pool exhausted\";\n    }\n    let p = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return p;\n}\n\nfn pool_reset() {\n    pool_offset = 0;\n}\n\nfn pool_destroy() {\n    free(pool);\n}\n\n// Usarlo\nlet a = pool_alloc(100);\nlet b = pool_alloc(200);\nmemset(a, 0, 100);\nmemset(b, 0, 200);\n\npool_reset();  // Reutilizar toda la memoria\npool_destroy();  // Limpiar\n```\n\n---\n\n## Ruta 5: Programas Paralelos y Concurrentes\n\n**Objetivo:** Ejecutar codigo en multiples nucleos de CPU, construir aplicaciones responsivas.\n\n**Tiempo para ser productivo:** Medio - la sintaxis async es directa, pero razonar sobre paralelismo requiere practica.\n\n### Lo Que Aprendera\n\n1. **[Inicio Rapido](#getting-started-quick-start)** - Conceptos basicos\n2. **[Funciones](#language-guide-functions)** - Clausuras (importantes para async)\n3. **[Async y Concurrencia](#advanced-async-concurrency)** - Profundizacion completa\n4. **[Atomicos](#advanced-atomics)** - Programacion sin bloqueos\n\n### Conceptos Clave\n\n**Modelo async de Hemlock:**\n- `async fn` - Definir una funcion que puede ejecutarse en otro hilo\n- `spawn(fn, args...)` - Comenzar a ejecutarla, devuelve un manejador de tarea\n- `join(task)` o `await task` - Esperar a que termine, obtener resultado\n- `channel(size)` - Crear una cola para enviar datos entre tareas\n\n**Importante:** Las tareas reciben *copias* de valores. Si pasa un puntero, usted es responsable de asegurar que la memoria permanezca valida hasta que la tarea complete.\n\n### Proyecto de Ejemplo: Procesador de Archivos Paralelo\n\n```hemlock\nimport { list_dir, read_file } from \"@stdlib/fs\";\n\nasync fn process_file(path: string): i32 {\n    let content = read_file(path);\n    let lines = content.split(\"\\n\");\n    return lines.length;\n}\n\n// Procesar todos los archivos en paralelo\nlet files = list_dir(\"data/\");\nlet tasks = [];\n\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let task = spawn(process_file, \"data/\" + file);\n        tasks.push({ name: file, task: task });\n    }\n}\n\n// Recolectar resultados\nlet total_lines = 0;\nfor (item in tasks) {\n    let count = join(item.task);\n    print(`${item.name}: ${count} lines`);\n    total_lines = total_lines + count;\n}\n\nprint(`Total: ${total_lines} lines`);\n```\n\n---\n\n## Que Aprender Primero (Cualquier Ruta)\n\nSin importar su objetivo, comience con estos fundamentos:\n\n### Semana 1: Conceptos Basicos Principales\n1. **[Inicio Rapido](#getting-started-quick-start)** - Escriba y ejecute su primer programa\n2. **[Sintaxis](#language-guide-syntax)** - Variables, operadores, flujo de control\n3. **[Funciones](#language-guide-functions)** - Definir y llamar funciones\n\n### Semana 2: Manejo de Datos\n4. **[Cadenas](#language-guide-strings)** - Manipulacion de texto\n5. **[Arreglos](#language-guide-arrays)** - Colecciones e iteracion\n6. **[Objetos](#language-guide-objects)** - Datos estructurados\n\n### Semana 3: Robustez\n7. **[Manejo de Errores](#language-guide-error-handling)** - try/catch/throw\n8. **[Modulos](#language-guide-modules)** - Import/export, usando stdlib\n\n### Luego: Elija Su Ruta Arriba\n\n---\n\n## Hoja de Referencia: Viniendo de Otros Lenguajes\n\n### Desde Python\n\n| Python | Hemlock | Notas |\n|--------|---------|-------|\n| `x = 42` | `let x = 42;` | Punto y coma requerido |\n| `def fn():` | `fn name() { }` | Llaves requeridas |\n| `if x:` | `if (x) { }` | Parentesis y llaves requeridos |\n| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | Bucles for estilo C |\n| `for item in list:` | `for (item in array) { }` | For-in funciona igual |\n| `list.append(x)` | `array.push(x);` | Nombre de metodo diferente |\n| `len(s)` | `s.length` o `len(s)` | Ambos funcionan |\n| Memoria automatica | Manual para `ptr` | La mayoria de tipos auto-limpian |\n\n### Desde JavaScript\n\n| JavaScript | Hemlock | Notas |\n|------------|---------|-------|\n| `let x = 42` | `let x = 42;` | Igual (punto y coma requerido) |\n| `const x = 42` | `let x = 42;` | Sin palabra clave const |\n| `function fn()` | `fn name() { }` | Palabra clave diferente |\n| `() => x` | `fn() { return x; }` | Sin funciones flecha |\n| `async/await` | `async/await` | Misma sintaxis |\n| `Promise` | `spawn/join` | Modelo diferente |\n| GC automatico | Manual para `ptr` | La mayoria de tipos auto-limpian |\n\n### Desde C/C++\n\n| C | Hemlock | Notas |\n|---|---------|-------|\n| `int x = 42;` | `let x: i32 = 42;` | Tipo despues de dos puntos |\n| `malloc(n)` | `alloc(n)` | Mismo concepto |\n| `free(p)` | `free(p)` | Igual |\n| `char* s = \"hi\"` | `let s = \"hi\";` | Las cadenas son gestionadas |\n| `#include` | `import { } from` | Importaciones de modulos |\n| Manual todo | Auto para la mayoria de tipos | Solo `ptr` necesita manual |\n\n---\n\n## Obteniendo Ayuda\n\n- **[Glosario](../glossary.md)** - Definiciones de terminos de programacion\n- **[Ejemplos](../../examples/)** - Programas completos funcionando\n- **[Pruebas](../../tests/)** - Ver como se usan las caracteristicas\n- **GitHub Issues** - Hacer preguntas, reportar errores\n\n---\n\n## Niveles de Dificultad\n\nA lo largo de la documentacion, vera estos marcadores:\n\n| Marcador | Significado |\n|----------|-------------|\n| **Principiante** | No se necesita experiencia previa en programacion |\n| **Intermedio** | Asume conocimientos basicos de programacion |\n| **Avanzado** | Requiere comprension de conceptos de sistemas |\n\nSi algo marcado como \"Principiante\" le confunde, consulte el [Glosario](../glossary.md) para definiciones de terminos.\n"}, "Primeros Pasos -> Tutorial": {"id": "getting-started-tutorial", "content": "# Tutorial de Hemlock\n\nUna guia completa paso a paso para aprender Hemlock.\n\n## Tabla de Contenidos\n\n1. [Hola Mundo](#hola-mundo)\n2. [Variables y Tipos](#variables-y-tipos)\n3. [Aritmetica y Operaciones](#aritmetica-y-operaciones)\n4. [Flujo de Control](#flujo-de-control)\n5. [Funciones](#funciones)\n6. [Cadenas y Runes](#cadenas-y-runes)\n7. [Arreglos](#arreglos)\n8. [Objetos](#objetos)\n9. [Gestion de Memoria](#gestion-de-memoria)\n10. [Manejo de Errores](#manejo-de-errores)\n11. [E/S de Archivos](#es-de-archivos)\n12. [Poniendolo Todo Junto](#poniendolo-todo-junto)\n\n## Hola Mundo\n\nComencemos con el tradicional primer programa:\n\n```hemlock\nprint(\"Hello, World!\");\n```\n\nGuardelo como `hello.hml` y ejecute:\n\n```bash\n./hemlock hello.hml\n```\n\n**Puntos Clave:**\n- `print()` es una funcion incorporada que escribe a stdout\n- Las cadenas se encierran entre comillas dobles\n- Los puntos y coma son **obligatorios**\n\n## Variables y Tipos\n\n### Declarando Variables\n\n```hemlock\n// Declaracion basica de variable\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\nprint(x);      // 42\nprint(name);   // Alice\nprint(pi);     // 3.14159\n```\n\n### Anotaciones de Tipo\n\nAunque los tipos se infieren por defecto, puede ser explicito:\n\n```hemlock\nlet age: i32 = 30;\nlet height: f64 = 5.9;\nlet initial: rune = 'A';\nlet active: bool = true;\n```\n\n### Inferencia de Tipos\n\nHemlock infiere tipos basandose en los valores:\n\n```hemlock\nlet small = 42;              // i32 (cabe en 32 bits)\nlet large = 5000000000;      // i64 (muy grande para i32)\nlet decimal = 3.14;          // f64 (por defecto para flotantes)\nlet text = \"hello\";          // string\nlet flag = true;             // bool\n```\n\n### Verificacion de Tipos\n\n```hemlock\n// Verificar tipos con typeof()\nprint(typeof(42));        // \"i32\"\nprint(typeof(3.14));      // \"f64\"\nprint(typeof(\"hello\"));   // \"string\"\nprint(typeof(true));      // \"bool\"\nprint(typeof(null));      // \"null\"\n```\n\n## Aritmetica y Operaciones\n\n### Aritmetica Basica\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13\nprint(a - b);   // 7\nprint(a * b);   // 30\nprint(a / b);   // 3 (division entera)\nprint(a == b);  // false\nprint(a > b);   // true\n```\n\n### Promocion de Tipos\n\nAl mezclar tipos, Hemlock promueve al tipo mas grande/preciso:\n\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result es f64 (10.0 + 3.5 = 13.5)\n\nprint(result);       // 13.5\nprint(typeof(result)); // \"f64\"\n```\n\n### Operaciones de Bits\n\n```hemlock\nlet a = 12;  // 1100 en binario\nlet b = 10;  // 1010 en binario\n\nprint(a & b);   // 8  (AND)\nprint(a | b);   // 14 (OR)\nprint(a ^ b);   // 6  (XOR)\nprint(a << 1);  // 24 (desplazamiento izquierda)\nprint(a >> 1);  // 6  (desplazamiento derecha)\nprint(~a);      // -13 (NOT)\n```\n\n## Flujo de Control\n\n### Sentencias If\n\n```hemlock\nlet x = 10;\n\nif (x > 0) {\n    print(\"positive\");\n} else if (x < 0) {\n    print(\"negative\");\n} else {\n    print(\"zero\");\n}\n```\n\n**Nota:** Las llaves son **siempre requeridas**, incluso para sentencias individuales.\n\n### Bucles While\n\n```hemlock\nlet count = 0;\nwhile (count < 5) {\n    print(`Count: ${count}`);\n    count = count + 1;\n}\n```\n\n### Bucles For\n\n```hemlock\n// Bucle for estilo C\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n\n// Bucle for-in (arreglos)\nlet items = [10, 20, 30, 40];\nfor (let item in items) {\n    print(`Item: ${item}`);\n}\n```\n\n### Sentencias Switch\n\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n        print(\"Monday\");\n        break;\n    case 2:\n        print(\"Tuesday\");\n        break;\n    case 3:\n        print(\"Wednesday\");\n        break;\n    default:\n        print(\"Other day\");\n        break;\n}\n```\n\n### Break y Continue\n\n```hemlock\n// Break: salir del bucle anticipadamente\nlet i = 0;\nwhile (i < 10) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// Imprime: 0, 1, 2, 3, 4\n\n// Continue: saltar a la siguiente iteracion\nfor (let j = 0; j < 5; j = j + 1) {\n    if (j == 2) {\n        continue;\n    }\n    print(j);\n}\n// Imprime: 0, 1, 3, 4\n```\n\n## Funciones\n\n### Funciones con Nombre\n\n```hemlock\nfn greet(name: string): string {\n    return \"Hello, \" + name + \"!\";\n}\n\nlet message = greet(\"Alice\");\nprint(message);  // \"Hello, Alice!\"\n```\n\n### Funciones Anonimas\n\n```hemlock\nlet add = fn(a, b) {\n    return a + b;\n};\n\nprint(add(5, 3));  // 8\n```\n\n### Recursion\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### Clausuras\n\nLas funciones capturan su entorno:\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n### Funciones de Orden Superior\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 21);\nprint(result);  // 42\n```\n\n## Cadenas y Runes\n\n### Conceptos Basicos de Cadenas\n\nLas cadenas son **mutables** y **UTF-8**:\n\n```hemlock\nlet s = \"hello\";\nprint(s.length);      // 5 (conteo de caracteres)\nprint(s.byte_length); // 5 (conteo de bytes)\n\n// Mutacion\ns[0] = 'H';\nprint(s);  // \"Hello\"\n```\n\n### Metodos de Cadena\n\n```hemlock\nlet text = \"  Hello, World!  \";\n\n// Conversion de mayusculas/minusculas\nprint(text.to_upper());  // \"  HELLO, WORLD!  \"\nprint(text.to_lower());  // \"  hello, world!  \"\n\n// Recorte\nprint(text.trim());      // \"Hello, World!\"\n\n// Extraccion de subcadena\nlet hello = text.substr(2, 5);  // \"Hello\"\nlet world = text.slice(9, 14);  // \"World\"\n\n// Busqueda\nlet pos = text.find(\"World\");   // 9\nlet has = text.contains(\"o\");   // true\n\n// Division\nlet parts = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\n\n// Reemplazo\nlet s = \"hello world\".replace(\"world\", \"there\");\nprint(s);  // \"hello there\"\n```\n\n### Runes (Puntos de Codigo Unicode)\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '';\n\nprint(ch);      // 'A'\nprint(emoji);   // U+1F680\n\n// Concatenacion Rune + String\nlet msg = '>' + \" Important\";\nprint(msg);  // \"> Important\"\n\n// Convertir entre rune y entero\nlet code: i32 = ch;     // 65 (codigo ASCII)\nlet r: rune = 128640;   // U+1F680 ()\n```\n\n## Arreglos\n\n### Conceptos Basicos de Arreglos\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// Modificar elementos\nnumbers[2] = 99;\nprint(numbers[2]);  // 99\n```\n\n### Metodos de Arreglo\n\n```hemlock\nlet arr = [10, 20, 30];\n\n// Agregar/eliminar al final\narr.push(40);           // [10, 20, 30, 40]\nlet last = arr.pop();   // 40, arr ahora es [10, 20, 30]\n\n// Agregar/eliminar al principio\narr.unshift(5);         // [5, 10, 20, 30]\nlet first = arr.shift(); // 5, arr ahora es [10, 20, 30]\n\n// Insertar/eliminar en indice\narr.insert(1, 15);      // [10, 15, 20, 30]\nlet removed = arr.remove(2);  // 20\n\n// Busqueda\nlet index = arr.find(15);     // 1\nlet has = arr.contains(10);   // true\n\n// Porcion\nlet slice = arr.slice(0, 2);  // [10, 15]\n\n// Unir a cadena\nlet text = arr.join(\", \");    // \"10, 15, 30\"\n```\n\n### Iteracion\n\n```hemlock\nlet items = [\"apple\", \"banana\", \"cherry\"];\n\n// Bucle for-in\nfor (let item in items) {\n    print(item);\n}\n\n// Iteracion manual\nlet i = 0;\nwhile (i < items.length) {\n    print(items[i]);\n    i = i + 1;\n}\n```\n\n## Objetos\n\n### Literales de Objeto\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nprint(person.age);   // 30\n\n// Agregar/modificar campos\nperson.email = \"alice@example.com\";\nperson.age = 31;\n```\n\n### Metodos y `self`\n\n```hemlock\nlet calculator = {\n    value: 0,\n    add: fn(x) {\n        self.value = self.value + x;\n    },\n    get: fn() {\n        return self.value;\n    }\n};\n\ncalculator.add(10);\ncalculator.add(5);\nprint(calculator.get());  // 15\n```\n\n### Definiciones de Tipo (Duck Typing)\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,  // Opcional con valor por defecto\n}\n\nlet p = { name: \"Bob\", age: 25 };\nlet typed: Person = p;  // Duck typing valida la estructura\n\nprint(typeof(typed));   // \"Person\"\nprint(typed.active);    // true (por defecto aplicado)\n```\n\n### Serializacion JSON\n\n```hemlock\nlet obj = { x: 10, y: 20, name: \"test\" };\n\n// Objeto a JSON\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// JSON a Objeto\nlet restored = json.deserialize();\nprint(restored.name);  // \"test\"\n```\n\n## Gestion de Memoria\n\n### Buffers Seguros (Recomendado)\n\n```hemlock\n// Asignar buffer\nlet buf = buffer(10);\nprint(buf.length);    // 10\nprint(buf.capacity);  // 10\n\n// Establecer valores (con verificacion de limites)\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Acceder a valores\nprint(buf[0]);  // 65\n\n// Debe liberar cuando termine\nfree(buf);\n```\n\n### Punteros Crudos (Avanzado)\n\n```hemlock\n// Asignar memoria cruda\nlet ptr = alloc(100);\n\n// Llenar con ceros\nmemset(ptr, 0, 100);\n\n// Copiar datos\nlet src = alloc(50);\nmemcpy(ptr, src, 50);\n\n// Liberar ambos\nfree(src);\nfree(ptr);\n```\n\n### Funciones de Memoria\n\n```hemlock\n// Reasignar\nlet p = alloc(64);\np = realloc(p, 128);  // Redimensionar a 128 bytes\nfree(p);\n\n// Asignacion tipada (futuro)\n// let arr = talloc(i32, 100);  // Arreglo de 100 i32s\n```\n\n## Manejo de Errores\n\n### Try/Catch\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"Error: \" + e);\n}\n// Salida: Error: division by zero\n```\n\n### Bloque Finally\n\n```hemlock\nlet file = null;\n\ntry {\n    file = open(\"data.txt\", \"r\");\n    let content = file.read();\n    print(content);\n} catch (e) {\n    print(\"Error: \" + e);\n} finally {\n    // Siempre se ejecuta\n    if (file != null) {\n        file.close();\n    }\n}\n```\n\n### Lanzando Objetos\n\n```hemlock\ntry {\n    throw { code: 404, message: \"Not found\" };\n} catch (e) {\n    print(`Error ${e.code}: ${e.message}`);\n}\n// Salida: Error 404: Not found\n```\n\n### Panic (Errores Irrecuperables)\n\n```hemlock\nfn validate(x) {\n    if (x < 0) {\n        panic(\"x must be non-negative\");\n    }\n    return x * 2;\n}\n\nvalidate(-5);  // El programa termina con: panic: x must be non-negative\n```\n\n## E/S de Archivos\n\n### Leyendo Archivos\n\n```hemlock\n// Leer archivo completo\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n\n// Leer numero especifico de bytes\nlet f2 = open(\"data.txt\", \"r\");\nlet chunk = f2.read(100);  // Leer 100 bytes\nf2.close();\n```\n\n### Escribiendo Archivos\n\n```hemlock\n// Escribir texto\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Hello, File!\\n\");\nf.write(\"Second line\\n\");\nf.close();\n\n// Agregar al archivo\nlet f2 = open(\"output.txt\", \"a\");\nf2.write(\"Appended line\\n\");\nf2.close();\n```\n\n### E/S Binaria\n\n```hemlock\n// Escribir datos binarios\nlet buf = buffer(256);\nbuf[0] = 255;\nbuf[1] = 128;\n\nlet f = open(\"data.bin\", \"w\");\nf.write_bytes(buf);\nf.close();\n\n// Leer datos binarios\nlet f2 = open(\"data.bin\", \"r\");\nlet data = f2.read_bytes(256);\nprint(data[0]);  // 255\nf2.close();\n\nfree(buf);\nfree(data);\n```\n\n### Propiedades de Archivo\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\n\nprint(f.path);    // \"/path/to/file.txt\"\nprint(f.mode);    // \"r\"\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n## Poniendolo Todo Junto\n\nConstruyamos un programa simple de contador de palabras:\n\n```hemlock\n// wordcount.hml - Contar palabras en un archivo\n\nfn count_words(filename: string): i32 {\n    let file = null;\n    let count = 0;\n\n    try {\n        file = open(filename, \"r\");\n        let content = file.read();\n\n        // Dividir por espacios en blanco y contar\n        let words = content.split(\" \");\n        count = words.length;\n\n    } catch (e) {\n        print(\"Error reading file: \" + e);\n        return -1;\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n\n    return count;\n}\n\n// Programa principal\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    let words = count_words(filename);\n\n    if (words >= 0) {\n        print(`Word count: ${words}`);\n    }\n}\n```\n\nEjecute con:\n```bash\n./hemlock wordcount.hml data.txt\n```\n\n## Proximos Pasos\n\nFelicitaciones! Ha aprendido lo basico de Hemlock. Esto es lo que puede explorar a continuacion:\n\n- [Async y Concurrencia](#advanced-async-concurrency) - Multi-hilos verdaderos\n- [FFI](#advanced-ffi) - Llamar funciones C\n- [Manejo de Senales](#advanced-signals) - Senales de proceso\n- [Referencia de API](#reference-builtins) - Documentacion completa de la API\n- [Ejemplos](../../examples/) - Mas programas del mundo real\n\n## Ejercicios de Practica\n\nIntente construir estos programas para practicar:\n\n1. **Calculadora**: Implemente una calculadora simple con +, -, *, /\n2. **Copia de Archivo**: Copie un archivo a otro\n3. **Fibonacci**: Genere numeros de Fibonacci\n4. **Parser JSON**: Lea y analice archivos JSON\n5. **Procesador de Texto**: Encuentre y reemplace texto en archivos\n\nFeliz programacion con Hemlock!\n"}, "Gua del Lenguaje -> Arreglos": {"id": "language-guide-arrays", "content": "# Arrays\n\nHemlock proporciona **arrays dinamicos** con metodos completos para manipulacion y procesamiento de datos. Los arrays pueden contener tipos mezclados y crecer automaticamente segun sea necesario.\n\n## Resumen\n\n```hemlock\n// Literales de array\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Tipos mezclados permitidos\nlet mixed = [1, \"hello\", true, null];\n\n// Tamano dinamico\narr.push(6);           // Crece automaticamente\narr.push(7);\nprint(arr.length);     // 7\n```\n\n## Literales de Array\n\n### Sintaxis Basica\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet strings = [\"apple\", \"banana\", \"cherry\"];\nlet booleans = [true, false, true];\n```\n\n### Arrays Vacios\n\n```hemlock\nlet arr = [];  // Array vacio\n\n// Agregar elementos despues\narr.push(1);\narr.push(2);\narr.push(3);\n```\n\n### Tipos Mezclados\n\nLos arrays pueden contener diferentes tipos:\n\n```hemlock\nlet mixed = [\n    42,\n    \"hello\",\n    true,\n    null,\n    [1, 2, 3],\n    { x: 10, y: 20 }\n];\n\nprint(mixed[0]);  // 42\nprint(mixed[1]);  // \"hello\"\nprint(mixed[4]);  // [1, 2, 3] (array anidado)\n```\n\n### Arrays Anidados\n\n```hemlock\nlet matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\nprint(matrix[0][0]);  // 1\nprint(matrix[1][2]);  // 6\nprint(matrix[2][1]);  // 8\n```\n\n### Arrays con Tipo\n\nLos arrays pueden tener anotaciones de tipo para imponer tipos de elementos:\n\n```hemlock\n// Sintaxis de array con tipo\nlet nums: array<i32> = [1, 2, 3, 4, 5];\nlet names: array<string> = [\"Alice\", \"Bob\", \"Carol\"];\nlet flags: array<bool> = [true, false, true];\n\n// Verificacion de tipos en tiempo de ejecucion\nlet valid: array<i32> = [1, 2, 3];       // OK\nlet invalid: array<i32> = [1, \"two\", 3]; // Error de tiempo de ejecucion: incompatibilidad de tipos\n\n// Arrays anidados con tipo\nlet matrix: array<array<i32>> = [\n    [1, 2, 3],\n    [4, 5, 6]\n];\n```\n\n**Comportamiento de anotacion de tipo:**\n- Los elementos se verifican por tipo cuando se agregan al array\n- Las incompatibilidades de tipo causan errores de tiempo de ejecucion\n- Sin anotacion de tipo, los arrays aceptan tipos mezclados\n\n## Indexacion\n\n### Leer Elementos\n\nAcceso indexado desde cero:\n\n```hemlock\nlet arr = [10, 20, 30, 40, 50];\n\nprint(arr[0]);  // 10 (primer elemento)\nprint(arr[4]);  // 50 (ultimo elemento)\n\n// Fuera de limites retorna null (sin error)\nprint(arr[10]);  // null\n```\n\n### Escribir Elementos\n\n```hemlock\nlet arr = [1, 2, 3];\n\narr[0] = 10;    // Modificar existente\narr[1] = 20;\nprint(arr);     // [10, 20, 3]\n\n// Puede asignar mas alla de la longitud actual (crece el array)\narr[5] = 60;    // Crea [10, 20, 3, null, null, 60]\n```\n\n### Indices Negativos\n\n**No soportado** - Usar solo indices positivos:\n\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr[-1]);  // ERROR o comportamiento indefinido\n\n// Usar length para el ultimo elemento\nprint(arr[arr.length - 1]);  // 3\n```\n\n## Propiedades\n\n### Propiedad `.length`\n\nRetorna el numero de elementos:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);  // 5\n\n// Array vacio\nlet empty = [];\nprint(empty.length);  // 0\n\n// Despues de modificaciones\narr.push(6);\nprint(arr.length);  // 6\n```\n\n## Metodos de Array\n\nHemlock proporciona 18 metodos de array para manipulacion completa.\n\n### Operaciones de Pila\n\n**`push(value)`** - Agregar elemento al final:\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\n\nprint(arr.length);     // 5\n```\n\n**`pop()`** - Remover y retornar ultimo elemento:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet last = arr.pop();  // Retorna 5, arr es ahora [1, 2, 3, 4]\n\nprint(last);           // 5\nprint(arr.length);     // 4\n```\n\n### Operaciones de Cola\n\n**`shift()`** - Remover y retornar primer elemento:\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();   // Retorna 1, arr es ahora [2, 3]\n\nprint(first);              // 1\nprint(arr);                // [2, 3]\n```\n\n**`unshift(value)`** - Agregar elemento al principio:\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);            // [1, 2, 3]\narr.unshift(0);            // [0, 1, 2, 3]\n```\n\n### Insercion y Remocion\n\n**`insert(index, value)`** - Insertar elemento en indice:\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // Insertar 3 en indice 2: [1, 2, 3, 4, 5]\n\narr.insert(0, 0);      // Insertar al principio: [0, 1, 2, 3, 4, 5]\n```\n\n**`remove(index)`** - Remover y retornar elemento en indice:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(2);  // Retorna 3, arr es ahora [1, 2, 4, 5]\n\nprint(removed);               // 3\nprint(arr);                   // [1, 2, 4, 5]\n```\n\n### Operaciones de Busqueda\n\n**`find(value)`** - Encontrar primera ocurrencia:\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2 (indice de primera ocurrencia)\nlet idx2 = arr.find(99);     // -1 (no encontrado)\n\n// Funciona con cualquier tipo\nlet words = [\"apple\", \"banana\", \"cherry\"];\nlet idx3 = words.find(\"banana\");  // 1\n```\n\n**`contains(value)`** - Verificar si array contiene valor:\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n```\n\n### Operaciones de Extraccion\n\n**`slice(start, end)`** - Extraer subarray (end exclusivo):\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4] (indices 1, 2, 3)\nlet first = arr.slice(0, 2); // [1, 2]\n\n// Original sin cambios\nprint(arr);                  // [1, 2, 3, 4, 5]\n```\n\n**`first()`** - Obtener primer elemento (sin remover):\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1 (sin remover)\nprint(arr);                  // [1, 2, 3] (sin cambios)\n```\n\n**`last()`** - Obtener ultimo elemento (sin remover):\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3 (sin remover)\nprint(arr);                  // [1, 2, 3] (sin cambios)\n```\n\n### Operaciones de Transformacion\n\n**`reverse()`** - Invertir array en su lugar:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\n\nprint(arr);                  // [5, 4, 3, 2, 1] (modificado)\n```\n\n**`join(delimiter)`** - Unir elementos en cadena:\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Funciona con tipos mezclados\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n```\n\n**`concat(other)`** - Concatenar con otro array:\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (nuevo array)\n\n// Originales sin cambios\nprint(a);                    // [1, 2, 3]\nprint(b);                    // [4, 5, 6]\n```\n\n### Operaciones de Utilidad\n\n**`clear()`** - Remover todos los elementos:\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();                 // []\n\nprint(arr.length);           // 0\nprint(arr);                  // []\n```\n\n## Encadenamiento de Metodos\n\nLos metodos que retornan arrays o valores permiten encadenamiento:\n\n```hemlock\nlet result = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);  // [3, 4, 5]\n\nlet text = [\"apple\", \"banana\", \"cherry\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\nlet numbers = [5, 3, 8, 1, 9]\n    .slice(1, 4)\n    .concat([10, 11]);  // [3, 8, 1, 10, 11]\n```\n\n## Referencia Completa de Metodos\n\n| Metodo | Parametros | Retorna | Muta | Descripcion |\n|--------|------------|---------|------|-------------|\n| `push(value)` | any | void | Si | Agregar elemento al final |\n| `pop()` | - | any | Si | Remover y retornar ultimo |\n| `shift()` | - | any | Si | Remover y retornar primero |\n| `unshift(value)` | any | void | Si | Agregar elemento al principio |\n| `insert(index, value)` | i32, any | void | Si | Insertar en indice |\n| `remove(index)` | i32 | any | Si | Remover y retornar en indice |\n| `find(value)` | any | i32 | No | Encontrar primera ocurrencia (-1 si no encontrado) |\n| `contains(value)` | any | bool | No | Verificar si contiene valor |\n| `slice(start, end)` | i32, i32 | array | No | Extraer subarray (nuevo array) |\n| `join(delimiter)` | string | string | No | Unir en cadena |\n| `concat(other)` | array | array | No | Concatenar (nuevo array) |\n| `reverse()` | - | void | Si | Invertir en su lugar |\n| `first()` | - | any | No | Obtener primer elemento |\n| `last()` | - | any | No | Obtener ultimo elemento |\n| `clear()` | - | void | Si | Remover todos los elementos |\n| `map(callback)` | fn | array | No | Transformar cada elemento |\n| `filter(predicate)` | fn | array | No | Seleccionar elementos coincidentes |\n| `reduce(callback, initial)` | fn, any | any | No | Reducir a valor unico |\n\n## Detalles de Implementacion\n\n### Modelo de Memoria\n\n- **Asignado en heap** - Capacidad dinamica\n- **Crecimiento automatico** - Duplica capacidad cuando se excede\n- **Sin reduccion automatica** - La capacidad no disminuye\n- **Sin verificacion de limites en indexacion** - Usar metodos para seguridad\n\n### Gestion de Capacidad\n\n```hemlock\nlet arr = [];  // Capacidad inicial: 0\n\narr.push(1);   // Crece a capacidad 1\narr.push(2);   // Crece a capacidad 2\narr.push(3);   // Crece a capacidad 4 (duplica)\narr.push(4);   // Aun capacidad 4\narr.push(5);   // Crece a capacidad 8 (duplica)\n```\n\n### Comparacion de Valores\n\n`find()` y `contains()` usan igualdad de valores:\n\n```hemlock\n// Primitivos: comparar por valor\nlet arr = [1, 2, 3];\narr.contains(2);  // true\n\n// Cadenas: comparar por valor\nlet words = [\"hello\", \"world\"];\nwords.contains(\"hello\");  // true\n\n// Objetos: comparar por referencia\nlet obj1 = { x: 10 };\nlet obj2 = { x: 10 };\nlet arr2 = [obj1];\narr2.contains(obj1);  // true (misma referencia)\narr2.contains(obj2);  // false (diferente referencia)\n```\n\n## Patrones Comunes\n\n### Operaciones Funcionales (map/filter/reduce)\n\nLos arrays tienen metodos integrados `map`, `filter` y `reduce`:\n\n```hemlock\n// map - transformar cada elemento\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = numbers.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\n// filter - seleccionar elementos coincidentes\nlet evens = numbers.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4]\n\n// reduce - acumular a valor unico\nlet sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\n// Encadenamiento de operaciones funcionales\nlet result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]\n    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]\n    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220\n```\n\n### Patron: Array como Pila\n\n```hemlock\nlet stack = [];\n\n// Push a la pila\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Pop de la pila\nlet top = stack.pop();    // 3\nlet next = stack.pop();   // 2\n```\n\n### Patron: Array como Cola\n\n```hemlock\nlet queue = [];\n\n// Encolar (agregar al final)\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Desencolar (remover del frente)\nlet first = queue.shift();   // 1\nlet second = queue.shift();  // 2\n```\n\n## Mejores Practicas\n\n1. **Usar metodos sobre indexacion directa** - Verificacion de limites y claridad\n2. **Verificar limites** - La indexacion directa no verifica limites\n3. **Preferir operaciones inmutables** - Usar `slice()` y `concat()` sobre mutacion\n4. **Inicializar con capacidad** - Si conoces el tamano (actualmente no soportado)\n5. **Usar `contains()` para membresia** - Mas claro que bucles manuales\n6. **Encadenar metodos** - Mas legible que llamadas anidadas\n\n## Errores Comunes\n\n### Error: Indice Directo Fuera de Limites\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// Sin verificacion de limites!\narr[10] = 99;  // Crea array disperso con nulls\nprint(arr.length);  // 11 (no 3!)\n\n// Mejor: Usar push() o verificar length\nif (arr.length <= 10) {\n    arr.push(99);\n}\n```\n\n### Error: Mutacion vs. Nuevo Array\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// Muta original\narr.reverse();\nprint(arr);  // [3, 2, 1]\n\n// Retorna nuevo array\nlet sub = arr.slice(0, 2);\nprint(arr);  // [3, 2, 1] (sin cambios)\nprint(sub);  // [3, 2]\n```\n\n### Error: Igualdad de Referencia\n\n```hemlock\nlet obj = { x: 10 };\nlet arr = [obj];\n\n// Misma referencia: true\narr.contains(obj);  // true\n\n// Diferente referencia: false\narr.contains({ x: 10 });  // false (diferente objeto)\n```\n\n### Error: Arrays de Larga Vida\n\n```hemlock\n// Los arrays en alcance local se liberan automaticamente, pero los arrays globales/de larga vida necesitan atencion\nlet global_cache = [];  // Nivel de modulo, persiste hasta fin del programa\n\nfn add_to_cache(item) {\n    global_cache.push(item);  // Crece indefinidamente\n}\n\n// Para datos de larga vida, considera:\n// - Limpiar el array periodicamente: global_cache.clear();\n// - Liberar temprano cuando termines: free(global_cache);\n```\n\n## Ejemplos\n\n### Ejemplo: Estadisticas de Array\n\n```hemlock\nfn mean(arr) {\n    let sum = 0;\n    let i = 0;\n    while (i < arr.length) {\n        sum = sum + arr[i];\n        i = i + 1;\n    }\n    return sum / arr.length;\n}\n\nfn max(arr) {\n    if (arr.length == 0) {\n        return null;\n    }\n\n    let max_val = arr[0];\n    let i = 1;\n    while (i < arr.length) {\n        if (arr[i] > max_val) {\n            max_val = arr[i];\n        }\n        i = i + 1;\n    }\n    return max_val;\n}\n\nlet numbers = [3, 7, 2, 9, 1];\nprint(mean(numbers));  // 4.4\nprint(max(numbers));   // 9\n```\n\n### Ejemplo: Deduplicacion de Array\n\n```hemlock\nfn unique(arr) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (!result.contains(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet numbers = [1, 2, 2, 3, 1, 4, 3, 5];\nlet uniq = unique(numbers);  // [1, 2, 3, 4, 5]\n```\n\n### Ejemplo: Fragmentacion de Array\n\n```hemlock\nfn chunk(arr, size) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        let chunk = arr.slice(i, i + size);\n        result.push(chunk);\n        i = i + size;\n    }\n\n    return result;\n}\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8];\nlet chunks = chunk(numbers, 3);\n// [[1, 2, 3], [4, 5, 6], [7, 8]]\n```\n\n### Ejemplo: Aplanamiento de Array\n\n```hemlock\nfn flatten(arr) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        if (typeof(arr[i]) == \"array\") {\n            // Array anidado - aplanarlo\n            let nested = flatten(arr[i]);\n            let j = 0;\n            while (j < nested.length) {\n                result.push(nested[j]);\n                j = j + 1;\n            }\n        } else {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet nested = [1, [2, 3], [4, [5, 6]], 7];\nlet flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]\n```\n\n### Ejemplo: Ordenamiento (Burbuja)\n\n```hemlock\nfn sort(arr) {\n    let n = arr.length;\n    let i = 0;\n\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (arr[j] > arr[j + 1]) {\n                // Intercambiar\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers);  // Modifica en su lugar\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## Limitaciones\n\nLimitaciones actuales:\n\n- **Sin verificacion de limites en indexacion** - El acceso directo no se verifica\n- **Igualdad de referencia para objetos** - `find()` y `contains()` usan comparacion de referencia\n- **Sin desestructuracion de arrays** - Sin sintaxis `let [a, b] = arr`\n- **Sin operador spread** - Sin sintaxis `[...arr1, ...arr2]`\n\n**Nota:** Los arrays tienen conteo de referencias y se liberan automaticamente cuando el alcance termina. Ver [Gestion de Memoria](memory.md#conteo-de-referencias-interno) para detalles.\n\n## Temas Relacionados\n\n- [Strings](#language-guide-strings) - Metodos de cadena similares a metodos de array\n- [Objects](#language-guide-objects) - Los arrays tambien son similares a objetos\n- [Functions](#language-guide-functions) - Funciones de orden superior con arrays\n- [Control Flow](#language-guide-control-flow) - Iterando sobre arrays\n\n## Ver Tambien\n\n- **Tamano Dinamico**: Los arrays crecen automaticamente con duplicacion de capacidad\n- **Metodos**: 18 metodos completos para manipulacion incluyendo map/filter/reduce\n- **Memoria**: Ver [Memory](#language-guide-memory) para detalles de asignacion de arrays\n"}, "Gua del Lenguaje -> Cadenas": {"id": "language-guide-strings", "content": "# Cadenas\n\nLas cadenas de Hemlock son **secuencias mutables de primera clase codificadas en UTF-8** con soporte completo de Unicode y un amplio conjunto de metodos para procesamiento de texto. A diferencia de muchos lenguajes, las cadenas de Hemlock son mutables y trabajan nativamente con puntos de codigo Unicode.\n\n## Resumen\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // mutar con rune (ahora \"Hello\")\nprint(s.length);        // 5 (conteo de puntos de codigo)\nlet c = s[0];           // retorna rune (punto de codigo Unicode)\nlet msg = s + \" world\"; // concatenacion\nlet emoji = \"rocket\";\nprint(emoji.length);    // 1 (un punto de codigo)\nprint(emoji.byte_length); // 4 (cuatro bytes UTF-8)\n```\n\n## Propiedades\n\nLas cadenas de Hemlock tienen estas caracteristicas clave:\n\n- **Codificadas en UTF-8** - Soporte completo de Unicode (U+0000 a U+10FFFF)\n- **Mutables** - A diferencia de cadenas en Python, JavaScript y Java\n- **Indexacion basada en puntos de codigo** - Retorna `rune` (punto de codigo Unicode), no byte\n- **Asignadas en heap** - Con seguimiento de capacidad interna\n- **Dos propiedades de longitud**:\n  - `.length` - Conteo de puntos de codigo (numero de caracteres)\n  - `.byte_length` - Conteo de bytes (tamano de codificacion UTF-8)\n\n## Comportamiento UTF-8\n\nTodas las operaciones de cadena trabajan con **puntos de codigo** (caracteres), no bytes:\n\n```hemlock\nlet text = \"Helloroute\";\nprint(text.length);        // 11 (puntos de codigo)\nprint(text.byte_length);   // 15 (bytes, el emoji son 4 bytes)\n\n// La indexacion usa puntos de codigo\nlet h = text[0];           // 'H' (rune)\nlet rocket = text[5];      // 'rocket' (rune)\n```\n\n**Los caracteres multi-byte cuentan como uno:**\n```hemlock\n\"Hello\".length;      // 5\n\"rocket\".length;     // 1 (un emoji)\n\"nihao\".length;      // 2 (dos caracteres chinos)\n\"cafe\".length;       // 4 (e con acento es un punto de codigo)\n```\n\n## Literales de Cadena\n\n```hemlock\n// Cadenas basicas\nlet s1 = \"hello\";\nlet s2 = \"world\";\n\n// Con secuencias de escape\nlet s3 = \"Line 1\\nLine 2\\ttabbed\";\nlet s4 = \"Quote: \\\"Hello\\\"\";\nlet s5 = \"Backslash: \\\\\";\n\n// Caracteres Unicode\nlet s6 = \"rocket Emoji\";\nlet s7 = \"zhongwenzifu\";\n```\n\n## Cadenas de Plantilla (Interpolacion de Cadenas)\n\nUsa comillas invertidas para cadenas de plantilla con expresiones embebidas:\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\n\n// Interpolacion basica\nlet greeting = `Hello, ${name}!`;           // \"Hello, Alice!\"\nlet info = `${name} is ${age} years old`;   // \"Alice is 30 years old\"\n\n// Expresiones en interpolacion\nlet x = 5;\nlet y = 10;\nlet sum = `${x} + ${y} = ${x + y}`;         // \"5 + 10 = 15\"\n\n// Llamadas a metodos\nlet upper = `Name: ${name.to_upper()}`;     // \"Name: ALICE\"\n\n// Objetos anidados\nlet person = { name: \"Bob\", city: \"NYC\" };\nlet desc = `${person.name} lives in ${person.city}`;  // \"Bob lives in NYC\"\n\n// Multi-linea (preserva saltos de linea)\nlet multi = `Line 1\nLine 2\nLine 3`;\n```\n\n**Caracteristicas de cadenas de plantilla:**\n- Las expresiones dentro de `${...}` se evaluan y convierten a cadenas\n- Se puede usar cualquier expresion valida (variables, llamadas a funciones, aritmetica)\n- Las cadenas con comillas invertidas soportan las mismas secuencias de escape que las cadenas regulares\n- Util para construir cadenas dinamicas sin concatenacion\n\n### Escape en Cadenas de Plantilla\n\nPara incluir un `${` literal en una cadena de plantilla, escapa el signo de dolar:\n\n```hemlock\nlet price = 100;\nlet text = `Price: \\${price} or ${price}`;\n// \"Price: ${price} or 100\"\n\n// Comilla invertida literal\nlet code = `Use \\` for template strings`;\n// \"Use ` for template strings\"\n```\n\n### Expresiones Complejas\n\nLas cadenas de plantilla pueden contener cualquier expresion valida:\n\n```hemlock\n// Expresiones tipo ternario\nlet age = 25;\nlet status = `Status: ${age >= 18 ? \"adult\" : \"minor\"}`;\n\n// Acceso a array\nlet items = [\"apple\", \"banana\", \"cherry\"];\nlet first = `First item: ${items[0]}`;\n\n// Llamadas a funciones con argumentos\nfn format_price(p) { return \"$\" + p; }\nlet msg = `Total: ${format_price(99.99)}`;  // \"Total: $99.99\"\n\n// Llamadas a metodos encadenados\nlet name = \"alice\";\nlet formatted = `Hello, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;\n// \"Hello, Alice!\"\n```\n\n### Cadenas de Plantilla vs Concatenacion\n\nLas cadenas de plantilla son frecuentemente mas limpias que la concatenacion:\n\n```hemlock\n// Concatenacion (mas dificil de leer)\nlet msg1 = \"Hello, \" + name + \"! You have \" + count + \" messages.\";\n\n// Cadena de plantilla (mas facil de leer)\nlet msg2 = `Hello, ${name}! You have ${count} messages.`;\n```\n\n## Indexacion y Mutacion\n\n### Lectura de Caracteres\n\nLa indexacion retorna un `rune` (punto de codigo Unicode):\n\n```hemlock\nlet s = \"Hello\";\nlet first = s[0];      // 'H' (rune)\nlet last = s[4];       // 'o' (rune)\n\n// Ejemplo UTF-8\nlet emoji = \"Hirocket!\";\nlet rocket = emoji[2];  // 'rocket' (rune en indice de punto de codigo 2)\n```\n\n### Escritura de Caracteres\n\nLas cadenas son mutables - puedes modificar caracteres individuales:\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';            // Ahora \"Hello\"\ns[4] = '!';            // Ahora \"Hell!\"\n\n// Con Unicode\nlet msg = \"Go!\";\nmsg[0] = 'rocket';     // Ahora \"rocketo!\"\n```\n\n## Concatenacion\n\nUsa `+` para concatenar cadenas:\n\n```hemlock\nlet greeting = \"Hello\" + \" \" + \"World\";  // \"Hello World\"\n\n// Con variables\nlet name = \"Alice\";\nlet msg = \"Hi, \" + name + \"!\";  // \"Hi, Alice!\"\n\n// Con runes (ver documentacion de Runes)\nlet s = \"Hello\" + '!';          // \"Hello!\"\n```\n\n## Metodos de Cadena\n\nHemlock proporciona 19 metodos de cadena para manipulacion completa de texto.\n\n### Subcadena y Extraccion\n\n**`substr(start, length)`** - Extraer subcadena por posicion y longitud:\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\" (inicia en 6, longitud 5)\nlet first = s.substr(0, 5);     // \"hello\"\n\n// Ejemplo UTF-8\nlet text = \"Hirocket!\";\nlet emoji = text.substr(2, 1);  // \"rocket\" (posicion 2, longitud 1)\n```\n\n**`slice(start, end)`** - Extraer subcadena por rango (end exclusivo):\n```hemlock\nlet s = \"hello world\";\nlet slice = s.slice(0, 5);      // \"hello\" (indice 0 a 4)\nlet slice2 = s.slice(6, 11);    // \"world\"\n```\n\n**Diferencia:**\n- `substr(start, length)` - Usa parametro de longitud\n- `slice(start, end)` - Usa indice final (exclusivo)\n\n### Busqueda y Encontrar\n\n**`find(needle)`** - Encontrar primera ocurrencia:\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6 (indice de primera ocurrencia)\nlet pos2 = s.find(\"foo\");       // -1 (no encontrado)\nlet pos3 = s.find(\"l\");         // 2 (primera 'l')\n```\n\n**`contains(needle)`** - Verificar si la cadena contiene subcadena:\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n### Division y Recorte\n\n**`split(delimiter)`** - Dividir en array de cadenas:\n```hemlock\nlet csv = \"apple,banana,cherry\";\nlet parts = csv.split(\",\");     // [\"apple\", \"banana\", \"cherry\"]\n\nlet words = \"one two three\".split(\" \");  // [\"one\", \"two\", \"three\"]\n\n// Delimitador vacio divide por caracter\nlet chars = \"abc\".split(\"\");    // [\"a\", \"b\", \"c\"]\n```\n\n**`trim()`** - Remover espacios al inicio/final:\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet s2 = \"\\t\\ntext\\n\\t\";\nlet clean2 = s2.trim();         // \"text\"\n```\n\n### Conversion de Mayusculas/Minusculas\n\n**`to_upper()`** - Convertir a mayusculas:\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\n// Preserva no-ASCII\nlet s2 = \"cafe\";\nlet upper2 = s2.to_upper();     // \"CAFE\"\n```\n\n**`to_lower()`** - Convertir a minusculas:\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n```\n\n### Verificacion de Prefijo/Sufijo\n\n**`starts_with(prefix)`** - Verificar si inicia con prefijo:\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n**`ends_with(suffix)`** - Verificar si termina con sufijo:\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n### Reemplazo\n\n**`replace(old, new)`** - Reemplazar primera ocurrencia:\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");      // \"hello there\"\n\nlet s3 = \"foo foo foo\";\nlet s4 = s3.replace(\"foo\", \"bar\");         // \"bar foo foo\" (solo primera)\n```\n\n**`replace_all(old, new)`** - Reemplazar todas las ocurrencias:\n```hemlock\nlet s = \"foo foo foo\";\nlet s2 = s.replace_all(\"foo\", \"bar\");      // \"bar bar bar\"\n\nlet s3 = \"hello world, world!\";\nlet s4 = s3.replace_all(\"world\", \"hemlock\"); // \"hello hemlock, hemlock!\"\n```\n\n### Repeticion\n\n**`repeat(count)`** - Repetir cadena n veces:\n```hemlock\nlet s = \"ha\";\nlet laugh = s.repeat(3);        // \"hahaha\"\n\nlet line = \"=\".repeat(40);      // \"========================================\"\n```\n\n### Acceso a Caracteres y Bytes\n\n**`char_at(index)`** - Obtener punto de codigo Unicode en indice (retorna rune):\n```hemlock\nlet s = \"hello\";\nlet char = s.char_at(0);        // 'h' (rune)\n\n// Ejemplo UTF-8\nlet emoji = \"rocket\";\nlet rocket = emoji.char_at(0);  // Retorna rune U+1F680\n```\n\n**`chars()`** - Convertir a array de runes (puntos de codigo):\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o'] (array de runes)\n\n// Ejemplo UTF-8\nlet text = \"Hirocket\";\nlet chars2 = text.chars();      // ['H', 'i', 'rocket']\n```\n\n**`byte_at(index)`** - Obtener valor de byte en indice (retorna u8):\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (valor ASCII de 'h')\n\n// Ejemplo UTF-8\nlet emoji = \"rocket\";\nlet first_byte = emoji.byte_at(0);  // 240 (primer byte UTF-8)\n```\n\n**`bytes()`** - Convertir a array de bytes (valores u8):\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111] (array de u8)\n\n// Ejemplo UTF-8\nlet emoji = \"rocket\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 bytes UTF-8)\n```\n\n**`to_bytes()`** - Convertir a buffer para acceso de bajo nivel:\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();         // Retorna buffer con bytes UTF-8\nprint(buf.length);              // 5\nfree(buf);                      // Recuerda liberar\n```\n\n## Encadenamiento de Metodos\n\nTodos los metodos de cadena retornan nuevas cadenas, permitiendo encadenamiento:\n\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \")\n    .to_upper();                    // \"FOO | BAR | BAZ\"\n```\n\n## Referencia Completa de Metodos\n\n| Metodo | Parametros | Retorna | Descripcion |\n|--------|-----------|---------|-------------|\n| `substr(start, length)` | i32, i32 | string | Extraer subcadena por posicion y longitud |\n| `slice(start, end)` | i32, i32 | string | Extraer subcadena por rango (end exclusivo) |\n| `find(needle)` | string | i32 | Encontrar primera ocurrencia (-1 si no encontrado) |\n| `contains(needle)` | string | bool | Verificar si contiene subcadena |\n| `split(delimiter)` | string | array | Dividir en array de cadenas |\n| `trim()` | - | string | Remover espacios al inicio/final |\n| `to_upper()` | - | string | Convertir a mayusculas |\n| `to_lower()` | - | string | Convertir a minusculas |\n| `starts_with(prefix)` | string | bool | Verificar si inicia con prefijo |\n| `ends_with(suffix)` | string | bool | Verificar si termina con sufijo |\n| `replace(old, new)` | string, string | string | Reemplazar primera ocurrencia |\n| `replace_all(old, new)` | string, string | string | Reemplazar todas las ocurrencias |\n| `repeat(count)` | i32 | string | Repetir cadena n veces |\n| `char_at(index)` | i32 | rune | Obtener punto de codigo en indice |\n| `byte_at(index)` | i32 | u8 | Obtener valor de byte en indice |\n| `chars()` | - | array | Convertir a array de runes |\n| `bytes()` | - | array | Convertir a array de bytes u8 |\n| `to_bytes()` | - | buffer | Convertir a buffer (debe liberarse) |\n\n## Ejemplos\n\n### Ejemplo: Procesamiento de Texto\n\n```hemlock\nfn process_input(text: string): string {\n    return text\n        .trim()\n        .to_lower()\n        .replace_all(\"  \", \" \");  // Normalizar espacios\n}\n\nlet input = \"  HELLO   WORLD  \";\nlet clean = process_input(input);  // \"hello world\"\n```\n\n### Ejemplo: Analizador CSV\n\n```hemlock\nfn parse_csv_line(line: string): array {\n    let trimmed = line.trim();\n    let fields = trimmed.split(\",\");\n\n    let result = [];\n    let i = 0;\n    while (i < fields.length) {\n        result.push(fields[i].trim());\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet csv = \"apple, banana , cherry\";\nlet fields = parse_csv_line(csv);  // [\"apple\", \"banana\", \"cherry\"]\n```\n\n### Ejemplo: Contador de Palabras\n\n```hemlock\nfn count_words(text: string): i32 {\n    let words = text.trim().split(\" \");\n    return words.length;\n}\n\nlet sentence = \"The quick brown fox\";\nlet count = count_words(sentence);  // 4\n```\n\n### Ejemplo: Validacion de Cadenas\n\n```hemlock\nfn is_valid_email(email: string): bool {\n    if (!email.contains(\"@\")) {\n        return false;\n    }\n\n    if (!email.contains(\".\")) {\n        return false;\n    }\n\n    if (email.starts_with(\"@\") || email.ends_with(\"@\")) {\n        return false;\n    }\n\n    return true;\n}\n\nprint(is_valid_email(\"user@example.com\"));  // true\nprint(is_valid_email(\"invalid\"));            // false\n```\n\n## Gestion de Memoria\n\nLas cadenas se asignan en heap con conteo de referencias interno:\n\n- **Creacion**: Asignadas en heap con seguimiento de capacidad\n- **Concatenacion**: Crea nueva cadena (cadenas originales sin cambios)\n- **Metodos**: La mayoria de metodos retornan nuevas cadenas\n- **Tiempo de vida**: Las cadenas tienen conteo de referencias y se liberan automaticamente cuando el alcance termina\n\n**Limpieza automatica:**\n```hemlock\nfn create_strings() {\n    let s = \"hello\";\n    let s2 = s + \" world\";  // Nueva asignacion\n}  // Tanto s como s2 se liberan automaticamente cuando la funcion retorna\n```\n\n**Nota:** Las variables de cadena locales se limpian automaticamente cuando salen del alcance. Usa `free()` solo para limpieza anticipada antes de que termine el alcance o para datos de larga vida/globales. Ver [Gestion de Memoria](memory.md#conteo-de-referencias-interno) para detalles.\n\n## Mejores Practicas\n\n1. **Usar indexacion de puntos de codigo** - Las cadenas usan posiciones de puntos de codigo, no desplazamientos de bytes\n2. **Probar con Unicode** - Siempre probar operaciones de cadena con caracteres multi-byte\n3. **Preferir operaciones inmutables** - Usar metodos que retornan nuevas cadenas en vez de mutacion\n4. **Verificar limites** - La indexacion de cadenas no verifica limites (retorna null/error en invalido)\n5. **Normalizar entrada** - Usar `trim()` y `to_lower()` para entrada de usuario\n\n## Errores Comunes\n\n### Error: Confusion Byte vs. Punto de Codigo\n\n```hemlock\nlet emoji = \"rocket\";\nprint(emoji.length);        // 1 (punto de codigo)\nprint(emoji.byte_length);   // 4 (bytes)\n\n// No mezclar operaciones de byte y punto de codigo\nlet byte = emoji.byte_at(0);  // 240 (primer byte, no caracter completo)\nlet char = emoji.char_at(0);  // 'rocket' (punto de codigo completo)\n```\n\n### Error: Sorpresas de Mutacion\n\n```hemlock\nlet s1 = \"hello\";\nlet s2 = s1;       // Copia superficial\ns1[0] = 'H';       // Muta s1\nprint(s2);         // Sigue siendo \"hello\" (las cadenas son tipos de valor)\n```\n\n## Temas Relacionados\n\n- [Runes](#language-guide-runes) - Tipo de punto de codigo Unicode usado en indexacion de cadenas\n- [Arrays](#language-guide-arrays) - Los metodos de cadena frecuentemente retornan o trabajan con arrays\n- [Types](#language-guide-types) - Detalles del tipo string y conversiones\n\n## Ver Tambien\n\n- **Codificacion UTF-8**: Ver seccion \"Strings\" en CLAUDE.md\n- **Conversiones de Tipo**: Ver [Types](#language-guide-types) para conversiones de cadenas\n- **Memoria**: Ver [Memory](#language-guide-memory) para detalles de asignacion de cadenas\n"}, "Gua del Lenguaje -> Coincidencia de Patrones": {"id": "language-guide-pattern-matching", "content": "# Coincidencia de Patrones\n\nHemlock proporciona coincidencia de patrones poderosa a travs de expresiones `match`, ofreciendo una forma concisa de desestructurar valores, verificar tipos y manejar mltiples casos.\n\n## Sintaxis Bsica\n\n```hemlock\nlet result = match (value) {\n    pattern1 => expression1,\n    pattern2 => expression2,\n    _ => default_expression\n};\n```\n\nLas expresiones match evalan `value` contra cada patrn en orden, retornando el resultado de la expresin del primer brazo que coincida.\n\n## Tipos de Patrones\n\n### Patrones Literales\n\nCoincide contra valores exactos:\n\n```hemlock\nlet x = 42;\nlet msg = match (x) {\n    0 => \"zero\",\n    1 => \"one\",\n    42 => \"the answer\",\n    _ => \"other\"\n};\nprint(msg);  // \"the answer\"\n```\n\nLiterales soportados:\n- **Enteros**: `0`, `42`, `-5`\n- **Flotantes**: `3.14`, `-0.5`\n- **Strings**: `\"hello\"`, `\"world\"`\n- **Booleanos**: `true`, `false`\n- **Null**: `null`\n\n### Patrn Comodn (`_`)\n\nCoincide cualquier valor sin vincular:\n\n```hemlock\nlet x = \"anything\";\nlet result = match (x) {\n    \"specific\" => \"found it\",\n    _ => \"wildcard matched\"\n};\n```\n\n### Patrones de Vinculacin de Variables\n\nVincula el valor coincidente a una variable:\n\n```hemlock\nlet x = 100;\nlet result = match (x) {\n    0 => \"zero\",\n    n => \"value is \" + n  // n se vincula a 100\n};\nprint(result);  // \"value is 100\"\n```\n\n### Patrones OR (`|`)\n\nCoincide mltiples alternativas:\n\n```hemlock\nlet x = 2;\nlet size = match (x) {\n    1 | 2 | 3 => \"small\",\n    4 | 5 | 6 => \"medium\",\n    _ => \"large\"\n};\n\n// Funciona con strings tambin\nlet cmd = \"quit\";\nlet action = match (cmd) {\n    \"exit\" | \"quit\" | \"q\" => \"exiting\",\n    \"help\" | \"h\" | \"?\" => \"showing help\",\n    _ => \"unknown\"\n};\n```\n\n### Expresiones de Guarda (`if`)\n\nAgregue condiciones a los patrones:\n\n```hemlock\nlet x = 15;\nlet category = match (x) {\n    n if n < 0 => \"negative\",\n    n if n == 0 => \"zero\",\n    n if n < 10 => \"small\",\n    n if n < 100 => \"medium\",\n    n => \"large: \" + n\n};\nprint(category);  // \"medium\"\n\n// Guardas complejas\nlet y = 12;\nlet result = match (y) {\n    n if n % 2 == 0 && n > 10 => \"even and greater than 10\",\n    n if n % 2 == 0 => \"even\",\n    n => \"odd\"\n};\n```\n\n### Patrones de Tipo\n\nVerifica y vincula basado en tipo:\n\n```hemlock\nlet val = 42;\nlet desc = match (val) {\n    num: i32 => \"integer: \" + num,\n    str: string => \"string: \" + str,\n    flag: bool => \"boolean: \" + flag,\n    _ => \"other type\"\n};\nprint(desc);  // \"integer: 42\"\n```\n\nTipos soportados: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`, `bool`, `string`, `array`, `object`\n\n## Patrones de Desestructuracin\n\n### Desestructuracin de Objetos\n\nExtraer campos de objetos:\n\n```hemlock\nlet point = { x: 10, y: 20 };\nlet result = match (point) {\n    { x, y } => \"point at \" + x + \",\" + y\n};\nprint(result);  // \"point at 10,20\"\n\n// Con valores literales de campo\nlet origin = { x: 0, y: 0 };\nlet name = match (origin) {\n    { x: 0, y: 0 } => \"origin\",\n    { x: 0, y } => \"on y-axis at \" + y,\n    { x, y: 0 } => \"on x-axis at \" + x,\n    { x, y } => \"point at \" + x + \",\" + y\n};\nprint(name);  // \"origin\"\n```\n\n### Desestructuracin de Arrays\n\nCoincide estructura y elementos de array:\n\n```hemlock\nlet arr = [1, 2, 3];\nlet desc = match (arr) {\n    [] => \"empty\",\n    [x] => \"single: \" + x,\n    [x, y] => \"pair: \" + x + \",\" + y,\n    [x, y, z] => \"triple: \" + x + \",\" + y + \",\" + z,\n    _ => \"many elements\"\n};\nprint(desc);  // \"triple: 1,2,3\"\n\n// Con valores literales\nlet pair = [1, 2];\nlet result = match (pair) {\n    [0, 0] => \"both zero\",\n    [1, x] => \"starts with 1, second is \" + x,\n    [x, 1] => \"ends with 1\",\n    _ => \"other\"\n};\nprint(result);  // \"starts with 1, second is 2\"\n```\n\n### Patrones Rest de Array (`...`)\n\nCapturar elementos restantes:\n\n```hemlock\nlet nums = [1, 2, 3, 4, 5];\n\n// Cabeza y cola\nlet result = match (nums) {\n    [first, ...rest] => \"first: \" + first,\n    [] => \"empty\"\n};\nprint(result);  // \"first: 1\"\n\n// Primeros dos elementos\nlet result2 = match (nums) {\n    [a, b, ...rest] => \"first two: \" + a + \",\" + b,\n    _ => \"too short\"\n};\nprint(result2);  // \"first two: 1,2\"\n```\n\n### Desestructuracin Anidada\n\nCombine patrones para datos complejos:\n\n```hemlock\nlet user = {\n    name: \"Alice\",\n    address: { city: \"NYC\", zip: 10001 }\n};\n\nlet result = match (user) {\n    { name, address: { city, zip } } => name + \" lives in \" + city,\n    _ => \"unknown\"\n};\nprint(result);  // \"Alice lives in NYC\"\n\n// Objeto conteniendo array\nlet data = { items: [1, 2, 3], count: 3 };\nlet result2 = match (data) {\n    { items: [first, ...rest], count } => \"first: \" + first + \", total: \" + count,\n    _ => \"no items\"\n};\nprint(result2);  // \"first: 1, total: 3\"\n```\n\n## Match como Expresin\n\nMatch es una expresin que retorna un valor:\n\n```hemlock\n// Asignacin directa\nlet grade = 85;\nlet letter = match (grade) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    n if n >= 70 => \"C\",\n    n if n >= 60 => \"D\",\n    _ => \"F\"\n};\n\n// En concatenacin de strings\nlet msg = \"Grade: \" + match (grade) {\n    n if n >= 70 => \"passing\",\n    _ => \"failing\"\n};\n\n// En retorno de funcin\nfn classify(n: i32): string {\n    return match (n) {\n        0 => \"zero\",\n        n if n > 0 => \"positive\",\n        _ => \"negative\"\n    };\n}\n```\n\n## Mejores Prcticas de Coincidencia de Patrones\n\n1. **El orden importa**: Los patrones se verifican de arriba hacia abajo; coloque patrones especficos antes de los generales\n2. **Use comodines para exhaustividad**: Siempre incluya un `_` de respaldo a menos que est seguro de que todos los casos estn cubiertos\n3. **Prefiera guardas sobre condiciones anidadas**: Las guardas hacen la intencin ms clara\n4. **Use desestructuracin sobre acceso manual de campos**: Ms conciso y seguro\n\n```hemlock\n// Bien: Guardas para verificacin de rangos\nmatch (score) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    _ => \"below B\"\n}\n\n// Bien: Desestructurar en lugar de acceder campos\nmatch (point) {\n    { x: 0, y: 0 } => \"origin\",\n    { x, y } => \"at \" + x + \",\" + y\n}\n\n// Evitar: Patrones anidados excesivamente complejos\n// En su lugar, considere dividir en mltiples matches o usar guardas\n```\n\n## Comparacin con Otros Lenguajes\n\n| Caracterstica | Hemlock | Rust | JavaScript |\n|----------------|---------|------|------------|\n| Coincidencia bsica | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |\n| Desestructuracin | S | S | Parcial (switch no desestructura) |\n| Guardas | `n if n > 0 =>` | `n if n > 0 =>` | N/A |\n| Patrones OR | `1 \\| 2 \\| 3 =>` | `1 \\| 2 \\| 3 =>` | `case 1: case 2: case 3:` |\n| Patrones rest | `[a, ...rest]` | `[a, rest @ ..]` | N/A |\n| Patrones de tipo | `n: i32` | Tipo va brazo `match` | N/A |\n| Retorna valor | S | S | No (sentencia) |\n\n## Notas de Implementacin\n\nLa coincidencia de patrones est implementada tanto en el backend del intrprete como del compilador con paridad completa - ambos producen resultados idnticos para la misma entrada. La caracterstica est disponible en Hemlock v1.8.0+.\n"}, "Gua del Lenguaje -> Flujo de Control": {"id": "language-guide-control-flow", "content": "# Flujo de Control\n\nHemlock proporciona flujo de control estilo C familiar con llaves obligatorias y sintaxis explcita. Esta gua cubre condicionales, bucles, sentencias switch y operadores.\n\n## Resumen\n\nCaractersticas de flujo de control disponibles:\n\n- `if`/`else`/`else if` - Ramas condicionales\n- Bucles `while` - Iteracin basada en condiciones\n- Bucles `for` - Iteracin estilo C y for-in\n- `loop` - Bucles infinitos (ms limpio que `while (true)`)\n- Sentencias `switch` - Ramificacin mltiple\n- `break`/`continue` - Control de bucles\n- Etiquetas de bucle - break/continue dirigido para bucles anidados\n- `defer` - Ejecucin diferida (limpieza)\n- Operadores booleanos: `&&`, `||`, `!`\n- Operadores de comparacin: `==`, `!=`, `<`, `>`, `<=`, `>=`\n- Operadores bit a bit: `&`, `|`, `^`, `<<`, `>>`, `~`\n\n## Sentencias If\n\n### If/Else Bsico\n\n```hemlock\nif (x > 10) {\n    print(\"large\");\n} else {\n    print(\"small\");\n}\n```\n\n**Reglas:**\n- Las llaves son **siempre requeridas** para todas las ramas\n- Las condiciones deben estar encerradas en parntesis\n- Sin llaves opcionales (a diferencia de C)\n\n### If Sin Else\n\n```hemlock\nif (x > 0) {\n    print(\"positive\");\n}\n// No se necesita rama else\n```\n\n### Cadenas Else-If\n\n```hemlock\nif (x > 100) {\n    print(\"very large\");\n} else if (x > 50) {\n    print(\"large\");\n} else if (x > 10) {\n    print(\"medium\");\n} else {\n    print(\"small\");\n}\n```\n\n**Nota:** `else if` es azcar sintctico para sentencias if anidadas. Estos son equivalentes:\n\n```hemlock\n// else if (azcar sintctico)\nif (a) {\n    foo();\n} else if (b) {\n    bar();\n}\n\n// If anidado equivalente\nif (a) {\n    foo();\n} else {\n    if (b) {\n        bar();\n    }\n}\n```\n\n### Sentencias If Anidadas\n\n```hemlock\nif (x > 0) {\n    if (x < 10) {\n        print(\"single digit positive\");\n    } else {\n        print(\"multi-digit positive\");\n    }\n} else {\n    print(\"non-positive\");\n}\n```\n\n## Bucles While\n\nIteracin basada en condiciones:\n\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n**Bucles infinitos (estilo antiguo):**\n```hemlock\nwhile (true) {\n    // ... hacer trabajo\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**Nota:** Para bucles infinitos, prefiera la palabra clave `loop` (ver abajo).\n\n## Loop (Bucle Infinito)\n\nLa palabra clave `loop` proporciona una sintaxis ms limpia para bucles infinitos:\n\n```hemlock\nloop {\n    // ... hacer trabajo\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**Equivalente a `while (true)` pero ms explcito sobre la intencin.**\n\n### Bucle Bsico con Break\n\n```hemlock\nlet i = 0;\nloop {\n    if (i >= 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// Imprime: 0, 1, 2, 3, 4\n```\n\n### Bucle con Continue\n\n```hemlock\nlet i = 0;\nloop {\n    i = i + 1;\n    if (i > 5) {\n        break;\n    }\n    if (i == 3) {\n        continue;  // Omite imprimir 3\n    }\n    print(i);\n}\n// Imprime: 1, 2, 4, 5\n```\n\n### Bucles Anidados\n\n```hemlock\nlet x = 0;\nloop {\n    if (x >= 2) { break; }\n    let y = 0;\n    loop {\n        if (y >= 3) { break; }\n        print(x * 10 + y);\n        y = y + 1;\n    }\n    x = x + 1;\n}\n// Imprime: 0, 1, 2, 10, 11, 12\n```\n\n### Cundo Usar Loop\n\n- **Use `loop`** para bucles intencionalmente infinitos que salen va `break`\n- **Use `while`** cuando hay una condicin de terminacin natural\n- **Use `for`** cuando itera un nmero conocido de veces o sobre una coleccin\n\n## Bucles For\n\n### For Estilo C\n\nBucle for clsico de tres partes:\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**Componentes:**\n- **Inicializador**: `let i = 0` - Se ejecuta una vez antes del bucle\n- **Condicin**: `i < 10` - Se verifica antes de cada iteracin\n- **Actualizacin**: `i = i + 1` - Se ejecuta despus de cada iteracin\n\n**mbito:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n// i no es accesible aqu (mbito del bucle)\n```\n\n### Bucles For-In\n\nIterar sobre elementos de array:\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nfor (let item in arr) {\n    print(item);  // Imprime cada elemento\n}\n```\n\n**Con ndice y valor:**\n```hemlock\nlet arr = [\"a\", \"b\", \"c\"];\nfor (let i = 0; i < arr.length; i = i + 1) {\n    print(`Index: ${i}, Value: ${arr[i]}`);\n}\n```\n\n## Sentencias Switch\n\nRamificacin mltiple basada en valor:\n\n### Switch Bsico\n\n```hemlock\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n}\n```\n\n### Switch con Default\n\n```hemlock\nlet color = \"blue\";\n\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"yellow\":\n        print(\"slow\");\n        break;\n    case \"green\":\n        print(\"go\");\n        break;\n    default:\n        print(\"unknown color\");\n        break;\n}\n```\n\n**Reglas:**\n- `default` coincide cuando ningn otro caso coincide\n- `default` puede aparecer en cualquier lugar del cuerpo del switch\n- Solo se permite un caso default\n\n### Comportamiento de Fall-Through\n\nLos casos sin `break` caen al siguiente caso (comportamiento estilo C). Esto es **intencional** y puede usarse para agrupar casos:\n\n```hemlock\nlet grade = 85;\n\nswitch (grade) {\n    case 100:\n    case 95:\n    case 90:\n        print(\"A\");\n        break;\n    case 85:\n    case 80:\n        print(\"B\");\n        break;\n    default:\n        print(\"C or below\");\n        break;\n}\n```\n\n**Ejemplo de fallthrough explcito:**\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n        print(\"Weekday\");\n        break;\n    case 6:\n    case 7:\n        print(\"Weekend\");\n        break;\n}\n```\n\n**Importante:** A diferencia de algunos lenguajes modernos, Hemlock NO requiere una palabra clave `fallthrough` explcita. Los casos automticamente caen al siguiente a menos que terminen con `break`, `return` o `throw`. Siempre use `break` para prevenir fallthrough no intencionado.\n\n### Switch con Return\n\nEn funciones, `return` sale del switch inmediatamente:\n\n```hemlock\nfn get_day_name(day: i32): string {\n    switch (day) {\n        case 1:\n            return \"Monday\";\n        case 2:\n            return \"Tuesday\";\n        case 3:\n            return \"Wednesday\";\n        default:\n            return \"Unknown\";\n    }\n}\n```\n\n### Tipos de Valor en Switch\n\nSwitch funciona con cualquier tipo de valor:\n\n```hemlock\n// Enteros\nswitch (count) {\n    case 0: print(\"zero\"); break;\n    case 1: print(\"one\"); break;\n}\n\n// Strings\nswitch (name) {\n    case \"Alice\": print(\"A\"); break;\n    case \"Bob\": print(\"B\"); break;\n}\n\n// Booleanos\nswitch (flag) {\n    case true: print(\"on\"); break;\n    case false: print(\"off\"); break;\n}\n```\n\n**Nota:** Los casos se comparan usando igualdad de valores.\n\n## Break y Continue\n\n### Break\n\nSale del bucle o switch ms interno:\n\n```hemlock\n// En bucles\nlet i = 0;\nwhile (true) {\n    if (i >= 10) {\n        break;  // Sale del bucle\n    }\n    print(i);\n    i = i + 1;\n}\n\n// En switch\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;  // Sale del switch\n    case 2:\n        print(\"two\");\n        break;\n}\n```\n\n### Continue\n\nSalta a la siguiente iteracin del bucle:\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;  // Omite la iteracin cuando i es 5\n    }\n    print(i);  // Imprime 0,1,2,3,4,6,7,8,9\n}\n```\n\n**Diferencia:**\n- `break` - Sale del bucle completamente\n- `continue` - Salta a la siguiente iteracin\n\n## Etiquetas de Bucle\n\nLas etiquetas de bucle permiten que `break` y `continue` apunten a bucles externos especficos en lugar de solo al bucle ms interno. Esto es til para bucles anidados donde necesita controlar un bucle externo desde uno interno.\n\n### Break con Etiqueta\n\nSalir de un bucle externo desde un bucle interno:\n\n```hemlock\nouter: while (i < 3) {\n    let j = 0;\n    while (j < 3) {\n        if (i == 1 && j == 1) {\n            break outer;  // Sale del bucle while externo\n        }\n        print(i * 10 + j);\n        j = j + 1;\n    }\n    i = i + 1;\n}\n// Imprime: 0, 1, 2, 10 (se detiene en i=1, j=1)\n```\n\n### Continue con Etiqueta\n\nSaltar a la siguiente iteracin de un bucle externo:\n\n```hemlock\nlet i = 0;\nouter: while (i < 3) {\n    i = i + 1;\n    let j = 0;\n    while (j < 3) {\n        j = j + 1;\n        if (i == 2 && j == 1) {\n            continue outer;  // Omite el resto del bucle interno, contina el externo\n        }\n        print(i * 10 + j);\n    }\n}\n// Cuando i=2, j=1: salta a la siguiente iteracin externa\n```\n\n### Etiquetas con Bucles For\n\nLas etiquetas funcionan con todos los tipos de bucle:\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 3; y = y + 1) {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n    }\n}\n```\n\n### Etiquetas con Bucles For-In\n\n```hemlock\nlet arr1 = [1, 2, 3];\nlet arr2 = [10, 20, 30];\n\nouter: for (let a in arr1) {\n    for (let b in arr2) {\n        if (a == 2 && b == 20) {\n            break outer;\n        }\n        print(a * 100 + b);\n    }\n}\n```\n\n### Etiquetas con Palabra Clave Loop\n\n```hemlock\nlet x = 0;\nouter: loop {\n    let y = 0;\n    loop {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n        y = y + 1;\n        if (y >= 3) { break; }\n    }\n    x = x + 1;\n    if (x >= 3) { break; }\n}\n```\n\n### Mltiples Etiquetas\n\nPuede tener etiquetas en diferentes niveles de anidamiento:\n\n```hemlock\nouter: for (let a = 0; a < 2; a = a + 1) {\n    inner: for (let b = 0; b < 3; b = b + 1) {\n        for (let c = 0; c < 3; c = c + 1) {\n            if (c == 1) {\n                continue inner;  // Salta a la siguiente iteracin del bucle medio\n            }\n            if (a == 1 && b == 1) {\n                break outer;      // Sale del bucle ms externo\n            }\n            print(a * 100 + b * 10 + c);\n        }\n    }\n}\n```\n\n### Break/Continue Sin Etiqueta con Bucles Etiquetados\n\n`break` y `continue` sin etiqueta siguen funcionando normalmente (afectando al bucle ms interno), incluso cuando los bucles externos tienen etiquetas:\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 5; y = y + 1) {\n        if (y == 2) {\n            break;  // Solo sale del bucle interno\n        }\n        print(x * 10 + y);\n    }\n}\n// Imprime: 0, 1, 10, 11, 20, 21\n```\n\n### Sintaxis de Etiquetas\n\n- Las etiquetas son identificadores seguidos de dos puntos\n- Las etiquetas deben preceder inmediatamente a una sentencia de bucle (`while`, `for`, `loop`)\n- Los nombres de etiquetas siguen las reglas de identificadores (letras, dgitos, guiones bajos)\n- Convenciones comunes: `outer`, `inner`, `row`, `col`, nombres descriptivos\n\n## Sentencia Defer\n\nLa sentencia `defer` programa cdigo para ejecutarse cuando la funcin actual retorna. Esto es til para operaciones de limpieza como cerrar archivos, liberar recursos o liberar bloqueos.\n\n### Defer Bsico\n\n```hemlock\nfn example() {\n    print(\"start\");\n    defer print(\"cleanup\");  // Se ejecuta cuando la funcin retorna\n    print(\"end\");\n}\n\nexample();\n// Salida:\n// start\n// end\n// cleanup\n```\n\n**Comportamiento clave:**\n- Las sentencias diferidas se ejecutan **despus** de que el cuerpo de la funcin se complete\n- Las sentencias diferidas se ejecutan **antes** de que la funcin retorne a su llamador\n- Las sentencias diferidas siempre se ejecutan, incluso si la funcin lanza una excepcin\n\n### Mltiples Defers (Orden LIFO)\n\nCuando se usan mltiples sentencias `defer`, se ejecutan en **orden inverso** (ltimo en Entrar, Primero en Salir):\n\n```hemlock\nfn example() {\n    defer print(\"first\");   // Se ejecuta ltimo\n    defer print(\"second\");  // Se ejecuta segundo\n    defer print(\"third\");   // Se ejecuta primero\n    print(\"body\");\n}\n\nexample();\n// Salida:\n// body\n// third\n// second\n// first\n```\n\nEste orden LIFO es intencional - coincide con el orden natural para la limpieza de recursos anidados (cerrar recursos internos antes que los externos).\n\n### Defer con Return\n\nLas sentencias diferidas se ejecutan antes de que `return` transfiera el control:\n\n```hemlock\nfn get_value(): i32 {\n    defer print(\"cleanup\");\n    print(\"before return\");\n    return 42;\n}\n\nlet result = get_value();\nprint(\"result:\", result);\n// Salida:\n// before return\n// cleanup\n// result: 42\n```\n\n### Defer con Excepciones\n\nLas sentencias diferidas se ejecutan incluso cuando se lanza una excepcin:\n\n```hemlock\nfn risky() {\n    defer print(\"cleanup 1\");\n    defer print(\"cleanup 2\");\n    print(\"before throw\");\n    throw \"error!\";\n    print(\"after throw\");  // Nunca se alcanza\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(\"Caught:\", e);\n}\n// Salida:\n// before throw\n// cleanup 2\n// cleanup 1\n// Caught: error!\n```\n\n### Patrn de Limpieza de Recursos\n\nEl caso de uso principal para `defer` es asegurar que los recursos se limpien:\n\n```hemlock\nfn process_file(filename: string) {\n    let file = open(filename, \"r\");\n    defer file.close();  // Siempre cierra, incluso en error\n\n    let content = file.read();\n    // ... procesar contenido ...\n\n    // El archivo se cierra automticamente cuando la funcin retorna\n}\n```\n\n**Sin defer (propenso a errores):**\n```hemlock\nfn process_file_bad(filename: string) {\n    let file = open(filename, \"r\");\n    let content = file.read();\n    // Si esto lanza, file.close() nunca se llama!\n    process(content);\n    file.close();\n}\n```\n\n### Defer con Closures\n\nDefer puede usar closures para capturar estado:\n\n```hemlock\nfn example() {\n    let resource = acquire_resource();\n    defer fn() {\n        print(\"Releasing resource\");\n        release(resource);\n    }();  // Nota: expresin de funcin invocada inmediatamente\n\n    use_resource(resource);\n}\n```\n\n### Cundo Usar Defer\n\n**Use defer para:**\n- Cerrar archivos y conexiones de red\n- Liberar memoria asignada\n- Liberar bloqueos y mutexes\n- Limpieza en cualquier funcin que adquiera recursos\n\n**Defer vs Finally:**\n- `defer` es ms simple para limpieza de un solo recurso\n- `try/finally` es mejor para manejo de errores complejo con recuperacin\n\n### Mejores Prcticas\n\n1. **Coloque defer inmediatamente despus de adquirir un recurso:**\n   ```hemlock\n   let file = open(\"data.txt\", \"r\");\n   defer file.close();\n   // ... usar archivo ...\n   ```\n\n2. **Use mltiples defers para mltiples recursos:**\n   ```hemlock\n   let file1 = open(\"input.txt\", \"r\");\n   defer file1.close();\n\n   let file2 = open(\"output.txt\", \"w\");\n   defer file2.close();\n\n   // Ambos archivos se cerrarn en orden inverso\n   ```\n\n3. **Recuerde el orden LIFO para recursos dependientes:**\n   ```hemlock\n   let outer = acquire_outer();\n   defer release_outer(outer);\n\n   let inner = acquire_inner(outer);\n   defer release_inner(inner);\n\n   // inner se libera antes que outer (orden de dependencia correcto)\n   ```\n\n## Operadores Booleanos\n\n### AND Lgico (`&&`)\n\nAmbas condiciones deben ser verdaderas:\n\n```hemlock\nif (x > 0 && x < 10) {\n    print(\"single digit positive\");\n}\n```\n\n**Evaluacin de cortocircuito:**\n```hemlock\nif (false && expensive_check()) {\n    // expensive_check() nunca se llama\n}\n```\n\n### OR Lgico (`||`)\n\nAl menos una condicin debe ser verdadera:\n\n```hemlock\nif (x < 0 || x > 100) {\n    print(\"out of range\");\n}\n```\n\n**Evaluacin de cortocircuito:**\n```hemlock\nif (true || expensive_check()) {\n    // expensive_check() nunca se llama\n}\n```\n\n### NOT Lgico (`!`)\n\nNiega el valor booleano:\n\n```hemlock\nif (!is_valid) {\n    print(\"invalid\");\n}\n\nif (!(x > 10)) {\n    // Igual que: if (x <= 10)\n}\n```\n\n## Operadores de Comparacin\n\n### Igualdad\n\n```hemlock\nif (x == 10) { }    // Igual\nif (x != 10) { }    // No igual\n```\n\nFunciona con todos los tipos:\n```hemlock\n\"hello\" == \"hello\"  // true\ntrue == false       // false\nnull == null        // true\n```\n\n### Relacionales\n\n```hemlock\nif (x < 10) { }     // Menor que\nif (x > 10) { }     // Mayor que\nif (x <= 10) { }    // Menor o igual\nif (x >= 10) { }    // Mayor o igual\n```\n\n**Se aplica promocin de tipos:**\n```hemlock\nlet a: i32 = 10;\nlet b: i64 = 10;\nif (a == b) { }     // true (i32 promovido a i64)\n```\n\n## Operadores Bit a Bit\n\nHemlock proporciona operadores bit a bit para manipulacin de enteros. Estos funcionan **solo con tipos enteros** (i8-i64, u8-u64).\n\n### Operadores Bit a Bit Binarios\n\n**AND Bit a Bit (`&`)**\n```hemlock\nlet a = 12;  // 1100 en binario\nlet b = 10;  // 1010 en binario\nprint(a & b);   // 8 (1000)\n```\n\n**OR Bit a Bit (`|`)**\n```hemlock\nprint(a | b);   // 14 (1110)\n```\n\n**XOR Bit a Bit (`^`)**\n```hemlock\nprint(a ^ b);   // 6 (0110)\n```\n\n**Desplazamiento a la Izquierda (`<<`)**\n```hemlock\nprint(a << 2);  // 48 (110000) - desplaza a la izquierda 2\n```\n\n**Desplazamiento a la Derecha (`>>`)**\n```hemlock\nprint(a >> 1);  // 6 (110) - desplaza a la derecha 1\n```\n\n### Operador Bit a Bit Unario\n\n**NOT Bit a Bit (`~`)**\n```hemlock\nlet a = 12;\nprint(~a);      // -13 (complemento a dos)\n\nlet c: u8 = 15;   // 00001111 en binario\nprint(~c);        // 240 (11110000) en u8\n```\n\n### Ejemplos Bit a Bit\n\n**Con tipos sin signo:**\n```hemlock\nlet c: u8 = 15;   // 00001111 en binario\nlet d: u8 = 7;    // 00000111 en binario\n\nprint(c & d);     // 7  (00000111)\nprint(c | d);     // 15 (00001111)\nprint(c ^ d);     // 8  (00001000)\nprint(~c);        // 240 (11110000) - en u8\n```\n\n**Preservacin de tipos:**\n```hemlock\n// Las operaciones bit a bit preservan el tipo de los operandos\nlet x: u8 = 255;\nlet result = ~x;  // result es u8 con valor 0\n\nlet y: i32 = 100;\nlet result2 = y << 2;  // result2 es i32 con valor 400\n```\n\n**Patrones comunes:**\n```hemlock\n// Verificar si un bit est establecido\nif (flags & 0x04) {\n    print(\"bit 2 is set\");\n}\n\n// Establecer un bit\nflags = flags | 0x08;\n\n// Limpiar un bit\nflags = flags & ~0x02;\n\n// Alternar un bit\nflags = flags ^ 0x01;\n```\n\n### Precedencia de Operadores\n\nLos operadores bit a bit siguen la precedencia estilo C:\n\n1. `~` (NOT unario) - ms alta, mismo nivel que `!` y `-`\n2. `<<`, `>>` (desplazamientos) - mayor que comparaciones, menor que `+`/`-`\n3. `&` (AND bit a bit) - mayor que `^` y `|`\n4. `^` (XOR bit a bit) - entre `&` y `|`\n5. `|` (OR bit a bit) - menor que `&` y `^`, mayor que `&&`\n6. `&&`, `||` (lgicos) - precedencia ms baja\n\n**Ejemplos:**\n```hemlock\n// & tiene mayor precedencia que |\nlet result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12\n\n// Desplazamiento tiene mayor precedencia que operadores bit a bit\nlet result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12\n\n// Use parntesis para claridad\nlet result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5\n```\n\n**Notas importantes:**\n- Los operadores bit a bit solo funcionan con tipos enteros (no flotantes, strings, etc.)\n- La promocin de tipos sigue las reglas estndar (tipos ms pequeos se promueven a ms grandes)\n- El desplazamiento a la derecha (`>>`) es aritmtico para tipos con signo, lgico para sin signo\n- Las cantidades de desplazamiento no se verifican por rango (el comportamiento depende de la plataforma para desplazamientos grandes)\n\n## Precedencia de Operadores (Completa)\n\nDe mayor a menor precedencia:\n\n1. **Unarios**: `!`, `-`, `~`\n2. **Multiplicativos**: `*`, `/`, `%`\n3. **Aditivos**: `+`, `-`\n4. **Desplazamiento**: `<<`, `>>`\n5. **Relacionales**: `<`, `>`, `<=`, `>=`\n6. **Igualdad**: `==`, `!=`\n7. **AND Bit a Bit**: `&`\n8. **XOR Bit a Bit**: `^`\n9. **OR Bit a Bit**: `|`\n10. **AND Lgico**: `&&`\n11. **OR Lgico**: `||`\n\n**Use parntesis para claridad:**\n```hemlock\n// Poco claro\nif (a || b && c) { }\n\n// Claro\nif (a || (b && c)) { }\nif ((a || b) && c) { }\n```\n\n## Patrones Comunes\n\n### Patrn: Validacin de Entrada\n\n```hemlock\nfn validate_age(age: i32): bool {\n    if (age < 0 || age > 150) {\n        return false;\n    }\n    return true;\n}\n```\n\n### Patrn: Verificacin de Rango\n\n```hemlock\nfn in_range(value: i32, min: i32, max: i32): bool {\n    return value >= min && value <= max;\n}\n\nif (in_range(score, 0, 100)) {\n    print(\"valid score\");\n}\n```\n\n### Patrn: Mquina de Estados\n\n```hemlock\nlet state = \"start\";\n\nwhile (true) {\n    switch (state) {\n        case \"start\":\n            print(\"Starting...\");\n            state = \"running\";\n            break;\n\n        case \"running\":\n            if (should_pause) {\n                state = \"paused\";\n            } else if (should_stop) {\n                state = \"stopped\";\n            }\n            break;\n\n        case \"paused\":\n            if (should_resume) {\n                state = \"running\";\n            }\n            break;\n\n        case \"stopped\":\n            print(\"Stopped\");\n            break;\n    }\n\n    if (state == \"stopped\") {\n        break;\n    }\n}\n```\n\n### Patrn: Iteracin con Filtrado\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// Imprimir solo nmeros pares\nfor (let i = 0; i < arr.length; i = i + 1) {\n    if (arr[i] % 2 != 0) {\n        continue;  // Omitir nmeros impares\n    }\n    print(arr[i]);\n}\n```\n\n### Patrn: Salida Temprana\n\n```hemlock\nfn find_first_negative(arr: array): i32 {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Salida temprana\n        }\n    }\n    return -1;  // No encontrado\n}\n```\n\n## Mejores Prcticas\n\n1. **Siempre use llaves** - Incluso para bloques de una sola sentencia (requerido por sintaxis)\n2. **Condiciones explcitas** - Use `x == 0` en lugar de `!x` para claridad\n3. **Evite anidamiento profundo** - Extraiga condiciones anidadas a funciones\n4. **Use retornos tempranos** - Reduzca el anidamiento con clusulas de guarda\n5. **Divida condiciones complejas** - Seprelas en variables booleanas nombradas\n6. **Default en switch** - Siempre incluya un caso default\n7. **Comente fall-through** - Haga explcito el fall-through intencional\n\n## Errores Comunes\n\n### Error: Asignacin en Condicin\n\n```hemlock\n// Esto NO est permitido (sin asignacin en condiciones)\nif (x = 10) { }  // ERROR: Error de sintaxis\n\n// Use comparacin en su lugar\nif (x == 10) { }  // OK\n```\n\n### Error: Break Faltante en Switch\n\n```hemlock\n// Fall-through no intencional\nswitch (x) {\n    case 1:\n        print(\"one\");\n        // Falta break - cae al siguiente!\n    case 2:\n        print(\"two\");  // Se ejecuta tanto para 1 como para 2\n        break;\n}\n\n// Correccin: Agregar break\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;  // Ahora correcto\n    case 2:\n        print(\"two\");\n        break;\n}\n```\n\n### Error: mbito de Variable de Bucle\n\n```hemlock\n// i tiene mbito del bucle\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\nprint(i);  // ERROR: i no est definida aqu\n```\n\n## Ejemplos\n\n### Ejemplo: FizzBuzz\n\n```hemlock\nfor (let i = 1; i <= 100; i = i + 1) {\n    if (i % 15 == 0) {\n        print(\"FizzBuzz\");\n    } else if (i % 3 == 0) {\n        print(\"Fizz\");\n    } else if (i % 5 == 0) {\n        print(\"Buzz\");\n    } else {\n        print(i);\n    }\n}\n```\n\n### Ejemplo: Verificador de Primos\n\n```hemlock\nfn is_prime(n: i32): bool {\n    if (n < 2) {\n        return false;\n    }\n\n    let i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            return false;\n        }\n        i = i + 1;\n    }\n\n    return true;\n}\n```\n\n### Ejemplo: Sistema de Men\n\n```hemlock\nfn menu() {\n    while (true) {\n        print(\"1. Start\");\n        print(\"2. Settings\");\n        print(\"3. Exit\");\n\n        let choice = get_input();\n\n        switch (choice) {\n            case 1:\n                start_game();\n                break;\n            case 2:\n                show_settings();\n                break;\n            case 3:\n                print(\"Goodbye!\");\n                return;\n            default:\n                print(\"Invalid choice\");\n                break;\n        }\n    }\n}\n```\n\n## Temas Relacionados\n\n- [Funciones](#language-guide-functions) - Flujo de control con llamadas a funciones y retornos\n- [Manejo de Errores](#language-guide-error-handling) - Flujo de control con excepciones\n- [Tipos](#language-guide-types) - Conversiones de tipos en condiciones\n\n## Ver Tambin\n\n- **Sintaxis**: Consulte [Sintaxis](#language-guide-syntax) para detalles de sintaxis de sentencias\n- **Operadores**: Consulte [Tipos](#language-guide-types) para promocin de tipos en operaciones\n"}, "Gua del Lenguaje -> Funciones": {"id": "language-guide-functions", "content": "# Funciones\n\nLas funciones en Hemlock son **valores de primera clase** que pueden asignarse a variables, pasarse como argumentos y retornarse desde otras funciones. Esta guia cubre la sintaxis de funciones, clausuras, recursion y patrones avanzados.\n\n## Resumen\n\n```hemlock\n// Sintaxis de funcion con nombre\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\n// Funcion anonima\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\n// Clausuras\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nprint(add5(3));  // 8\n```\n\n## Declaracion de Funciones\n\n### Funciones con Nombre\n\n```hemlock\nfn greet(name: string): string {\n    return \"Hello, \" + name;\n}\n\nlet msg = greet(\"Alice\");  // \"Hello, Alice\"\n```\n\n**Componentes:**\n- `fn` - Palabra clave de funcion\n- `greet` - Nombre de la funcion\n- `(name: string)` - Parametros con tipos opcionales\n- `: string` - Tipo de retorno opcional\n- `{ ... }` - Cuerpo de la funcion\n\n### Funciones Anonimas\n\nFunciones sin nombre, asignadas a variables:\n\n```hemlock\nlet square = fn(x) {\n    return x * x;\n};\n\nprint(square(5));  // 25\n```\n\n**Con nombre vs. Anonima:**\n```hemlock\n// Estas son equivalentes:\nfn add(a, b) { return a + b; }\n\nlet add = fn(a, b) { return a + b; };\n```\n\n**Nota:** Las funciones con nombre se descomponen en asignaciones de variables con funciones anonimas.\n\n## Parametros\n\n### Parametros Basicos\n\n```hemlock\nfn example(a, b, c) {\n    return a + b + c;\n}\n\nlet result = example(1, 2, 3);  // 6\n```\n\n### Anotaciones de Tipo\n\nAnotaciones de tipo opcionales en parametros:\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);      // OK\nadd(5, 10.5);    // La verificacion de tipo en tiempo de ejecucion promueve a f64\n```\n\n**Verificacion de tipos:**\n- Los tipos de parametros se verifican en el momento de la llamada si estan anotados\n- Las conversiones implicitas de tipo siguen reglas estandar de promocion\n- Las incompatibilidades de tipo causan errores de tiempo de ejecucion\n\n### Paso por Valor\n\nTodos los argumentos se **copian** (paso por valor):\n\n```hemlock\nfn modify(x) {\n    x = 100;  // Solo modifica la copia local\n}\n\nlet a = 10;\nmodify(a);\nprint(a);  // Sigue siendo 10 (sin cambios)\n```\n\n**Nota:** Los objetos y arrays se pasan por referencia (la referencia se copia), por lo que su contenido puede modificarse:\n\n```hemlock\nfn modify_array(arr) {\n    arr[0] = 99;  // Modifica el array original\n}\n\nlet a = [1, 2, 3];\nmodify_array(a);\nprint(a[0]);  // 99 (modificado)\n```\n\n## Valores de Retorno\n\n### Sentencia Return\n\n```hemlock\nfn get_max(a: i32, b: i32): i32 {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n```\n\n### Anotaciones de Tipo de Retorno\n\nAnotacion de tipo opcional para el valor de retorno:\n\n```hemlock\nfn calculate(): f64 {\n    return 3.14159;\n}\n\nfn get_name(): string {\n    return \"Alice\";\n}\n```\n\n**Verificacion de tipos:**\n- Los tipos de retorno se verifican cuando la funcion retorna (si estan anotados)\n- Las conversiones de tipo siguen reglas estandar de promocion\n\n### Retorno Implicito\n\nLas funciones sin anotacion de tipo de retorno retornan implicitamente `null`:\n\n```hemlock\nfn print_message(msg) {\n    print(msg);\n    // Retorna implicitamente null\n}\n\nlet result = print_message(\"hello\");  // result es null\n```\n\n### Retorno Temprano\n\n```hemlock\nfn find_first_negative(arr) {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // Salida temprana\n        }\n    }\n    return -1;  // No encontrado\n}\n```\n\n### Retorno Sin Valor\n\n`return;` sin valor retorna `null`:\n\n```hemlock\nfn maybe_process(value) {\n    if (value < 0) {\n        return;  // Retorna null\n    }\n    return value * 2;\n}\n```\n\n## Funciones de Primera Clase\n\nLas funciones pueden asignarse, pasarse y retornarse como cualquier otro valor.\n\n### Funciones como Variables\n\n```hemlock\nlet operation = fn(x, y) { return x + y; };\n\nprint(operation(5, 3));  // 8\n\n// Reasignar\noperation = fn(x, y) { return x * y; };\nprint(operation(5, 3));  // 15\n```\n\n### Funciones como Argumentos\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 5);  // 10\n```\n\n### Funciones como Valores de Retorno\n\n```hemlock\nfn get_operation(op: string) {\n    if (op == \"add\") {\n        return fn(a, b) { return a + b; };\n    } else if (op == \"multiply\") {\n        return fn(a, b) { return a * b; };\n    } else {\n        return fn(a, b) { return 0; };\n    }\n}\n\nlet add = get_operation(\"add\");\nprint(add(5, 3));  // 8\n```\n\n## Clausuras\n\nLas funciones capturan su entorno de definicion (alcance lexico).\n\n### Clausuras Basicas\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n**Como funciona:**\n- La funcion interna captura `count` del alcance externo\n- `count` persiste entre llamadas a la funcion retornada\n- Cada llamada a `makeCounter()` crea una nueva clausura con su propio `count`\n\n### Clausura con Parametros\n\n```hemlock\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\n\nprint(add5(3));   // 8\nprint(add10(3));  // 13\n```\n\n### Clausuras Multiples\n\n```hemlock\nfn makeOperations(x) {\n    let add = fn(y) { return x + y; };\n    let multiply = fn(y) { return x * y; };\n\n    return { add: add, multiply: multiply };\n}\n\nlet ops = makeOperations(5);\nprint(ops.add(3));       // 8\nprint(ops.multiply(3));  // 15\n```\n\n### Alcance Lexico\n\nLas funciones pueden acceder a variables del alcance externo a traves del alcance lexico:\n\n```hemlock\nlet global = 10;\n\nfn outer() {\n    let outer_var = 20;\n\n    fn inner() {\n        // Puede leer global y outer_var\n        print(global);      // 10\n        print(outer_var);   // 20\n    }\n\n    inner();\n}\n\nouter();\n```\n\nLas clausuras capturan variables por referencia, permitiendo tanto lectura como mutacion de variables del alcance externo (como se muestra en el ejemplo `makeCounter` anterior).\n\n## Recursion\n\nLas funciones pueden llamarse a si mismas.\n\n### Recursion Basica\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### Recursion Mutua\n\nLas funciones pueden llamarse entre si:\n\n```hemlock\nfn is_even(n: i32): bool {\n    if (n == 0) {\n        return true;\n    }\n    return is_odd(n - 1);\n}\n\nfn is_odd(n: i32): bool {\n    if (n == 0) {\n        return false;\n    }\n    return is_even(n - 1);\n}\n\nprint(is_even(4));  // true\nprint(is_odd(4));   // false\n```\n\n### Procesamiento Recursivo de Datos\n\n```hemlock\nfn sum_array(arr: array, index: i32): i32 {\n    if (index >= arr.length) {\n        return 0;\n    }\n    return arr[index] + sum_array(arr, index + 1);\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(sum_array(numbers, 0));  // 15\n```\n\n**Nota:** Aun no hay optimizacion de llamada de cola - la recursion profunda puede causar desbordamiento de pila.\n\n## Funciones de Orden Superior\n\nFunciones que toman o retornan otras funciones.\n\n### Patron Map\n\n```hemlock\nfn map(arr, f) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        result.push(f(arr[i]));\n        i = i + 1;\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = map(numbers, double);  // [2, 4, 6, 8, 10]\n```\n\n### Patron Filter\n\n```hemlock\nfn filter(arr, predicate) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (predicate(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nfn is_even(x) { return x % 2 == 0; }\n\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = filter(numbers, is_even);  // [2, 4, 6]\n```\n\n### Patron Reduce\n\n```hemlock\nfn reduce(arr, f, initial) {\n    let accumulator = initial;\n    let i = 0;\n    while (i < arr.length) {\n        accumulator = f(accumulator, arr[i]);\n        i = i + 1;\n    }\n    return accumulator;\n}\n\nfn add(a, b) { return a + b; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = reduce(numbers, add, 0);  // 15\n```\n\n### Composicion de Funciones\n\n```hemlock\nfn compose(f, g) {\n    return fn(x) {\n        return f(g(x));\n    };\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\n\nlet double_then_increment = compose(increment, double);\nprint(double_then_increment(5));  // 11 (5*2 + 1)\n```\n\n## Patrones Comunes\n\n### Patron: Funciones Fabrica\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```\n\n### Patron: Funciones Callback\n\n```hemlock\nfn process_async(data, callback) {\n    // ... hacer procesamiento\n    callback(data);\n}\n\nprocess_async(\"test\", fn(result) {\n    print(\"Processing complete: \" + result);\n});\n```\n\n### Patron: Aplicacion Parcial\n\n```hemlock\nfn partial(f, x) {\n    return fn(y) {\n        return f(x, y);\n    };\n}\n\nfn multiply(a, b) {\n    return a * b;\n}\n\nlet double = partial(multiply, 2);\nlet triple = partial(multiply, 3);\n\nprint(double(5));  // 10\nprint(triple(5));  // 15\n```\n\n### Patron: Memorizacion\n\n```hemlock\nfn memoize(f) {\n    let cache = {};\n\n    return fn(x) {\n        if (cache.has(x)) {\n            return cache[x];\n        }\n\n        let result = f(x);\n        cache[x] = result;\n        return result;\n    };\n}\n\nfn expensive_fibonacci(n) {\n    if (n <= 1) { return n; }\n    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);\n}\n\nlet fast_fib = memoize(expensive_fibonacci);\nprint(fast_fib(10));  // Mucho mas rapido con cache\n```\n\n## Semantica de Funciones\n\n### Requisitos de Tipo de Retorno\n\nLas funciones con anotacion de tipo de retorno **deben** retornar un valor:\n\n```hemlock\nfn get_value(): i32 {\n    // ERROR: Falta sentencia return\n}\n\nfn get_value(): i32 {\n    return 42;  // OK\n}\n```\n\n### Verificacion de Tipos\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);        // OK\nadd(5.5, 10.5);    // Promueve a f64, retorna f64\nadd(\"a\", \"b\");     // Error de tiempo de ejecucion: incompatibilidad de tipos\n```\n\n### Reglas de Alcance\n\n```hemlock\nlet global = \"global\";\n\nfn outer() {\n    let outer_var = \"outer\";\n\n    fn inner() {\n        let inner_var = \"inner\";\n        // Puede acceder: inner_var, outer_var, global\n    }\n\n    // Puede acceder: outer_var, global\n    // No puede acceder: inner_var\n}\n\n// Puede acceder: global\n// No puede acceder: outer_var, inner_var\n```\n\n## Mejores Practicas\n\n1. **Usar anotaciones de tipo** - Ayuda a detectar errores y documenta la intencion\n2. **Mantener funciones pequenas** - Cada funcion debe hacer una cosa\n3. **Preferir funciones puras** - Evitar efectos secundarios cuando sea posible\n4. **Nombrar funciones claramente** - Usar nombres verbales descriptivos\n5. **Retornar temprano** - Usar clausulas de guarda para reducir anidamiento\n6. **Documentar clausuras complejas** - Hacer explicitas las variables capturadas\n7. **Evitar recursion profunda** - Aun no hay optimizacion de llamada de cola\n\n## Errores Comunes\n\n### Error: Profundidad de Recursion\n\n```hemlock\n// La recursion profunda puede causar desbordamiento de pila\nfn count_down(n) {\n    if (n == 0) { return; }\n    count_down(n - 1);\n}\n\ncount_down(100000);  // Puede fallar con desbordamiento de pila\n```\n\n### Error: Modificar Variables Capturadas\n\n```hemlock\nfn make_counter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Puede leer y modificar variables capturadas\n        return count;\n    };\n}\n```\n\n**Nota:** Esto funciona, pero ten en cuenta que todas las clausuras comparten el mismo entorno capturado.\n\n## Ejemplos\n\n### Ejemplo: Pipeline de Funciones\n\n```hemlock\nfn pipeline(value, ...functions) {\n    let result = value;\n    for (f in functions) {\n        result = f(result);\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\nfn square(x) { return x * x; }\n\nlet result = pipeline(3, double, increment, square);\nprint(result);  // 49 ((3*2+1)^2)\n```\n\n### Ejemplo: Manejador de Eventos\n\n```hemlock\nlet handlers = [];\n\nfn on_event(name: string, handler) {\n    handlers.push({ name: name, handler: handler });\n}\n\nfn trigger_event(name: string, data) {\n    let i = 0;\n    while (i < handlers.length) {\n        if (handlers[i].name == name) {\n            handlers[i].handler(data);\n        }\n        i = i + 1;\n    }\n}\n\non_event(\"click\", fn(data) {\n    print(\"Clicked: \" + data);\n});\n\ntrigger_event(\"click\", \"button1\");\n```\n\n### Ejemplo: Ordenamiento con Comparador Personalizado\n\n```hemlock\nfn sort(arr, compare) {\n    // Ordenamiento burbuja con comparador personalizado\n    let n = arr.length;\n    let i = 0;\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (compare(arr[j], arr[j + 1]) > 0) {\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nfn ascending(a, b) {\n    if (a < b) { return -1; }\n    if (a > b) { return 1; }\n    return 0;\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers, ascending);\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## Parametros Opcionales (Argumentos por Defecto)\n\nLas funciones pueden tener parametros opcionales con valores por defecto usando la sintaxis `?:`:\n\n```hemlock\nfn greet(name, greeting?: \"Hello\") {\n    return greeting + \" \" + name;\n}\n\nprint(greet(\"Alice\"));           // \"Hello Alice\"\nprint(greet(\"Bob\", \"Hi\"));       // \"Hi Bob\"\n\nfn add(a, b?: 10, c?: 100) {\n    return a + b + c;\n}\n\nprint(add(1));          // 111 (1 + 10 + 100)\nprint(add(1, 2));       // 103 (1 + 2 + 100)\nprint(add(1, 2, 3));    // 6   (1 + 2 + 3)\n```\n\n**Reglas:**\n- Los parametros opcionales deben venir despues de los parametros requeridos\n- Los valores por defecto pueden ser cualquier expresion\n- Los argumentos omitidos usan el valor por defecto\n\n## Funciones Variadicas (Parametros Rest)\n\nLas funciones pueden aceptar un numero variable de argumentos usando parametros rest (`...`):\n\n```hemlock\nfn sum(...args) {\n    let total = 0;\n    for (arg in args) {\n        total = total + arg;\n    }\n    return total;\n}\n\nprint(sum(1, 2, 3));        // 6\nprint(sum(1, 2, 3, 4, 5));  // 15\nprint(sum());               // 0\n\nfn log(prefix, ...messages) {\n    for (msg in messages) {\n        print(prefix + \": \" + msg);\n    }\n}\n\nlog(\"INFO\", \"Starting\", \"Running\", \"Done\");\n// INFO: Starting\n// INFO: Running\n// INFO: Done\n```\n\n**Reglas:**\n- El parametro rest debe ser el ultimo parametro\n- El parametro rest recolecta todos los argumentos restantes en un array\n- Puede combinarse con parametros regulares y opcionales\n\n## Anotaciones de Tipo de Funcion\n\nLos tipos de funcion te permiten especificar la firma exacta esperada para parametros de funcion y valores de retorno:\n\n### Tipos de Funcion Basicos\n\n```hemlock\n// Sintaxis de tipo de funcion: fn(param_types): return_type\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\nlet double = fn(n) { return n * 2; };\nlet result = apply(double, 5);  // 10\n```\n\n### Tipos de Funciones de Orden Superior\n\n```hemlock\n// Funcion que retorna una funcion\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\nlet add5 = make_adder(5);\nprint(add5(10));  // 15\n```\n\n### Tipos de Funcion Async\n\n```hemlock\n// Tipo de funcion async\nfn run_task(handler: async fn(): void) {\n    spawn(handler);\n}\n\nrun_task(async fn() {\n    print(\"Running async!\");\n});\n```\n\n### Alias de Tipo de Funcion\n\n```hemlock\n// Crear tipos de funcion nombrados para claridad\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\nfn filter_with(arr: array, pred: Predicate): array {\n    return arr.filter(pred);\n}\n```\n\n## Parametros Const\n\nEl modificador `const` previene que un parametro sea mutado dentro de la funcion:\n\n### Parametros Const Basicos\n\n```hemlock\nfn print_all(const items: array) {\n    // items.push(4);  // ERROR: no se puede mutar parametro const\n    for (item in items) {\n        print(item);   // OK: leer esta permitido\n    }\n}\n\nlet nums = [1, 2, 3];\nprint_all(nums);\n```\n\n### Inmutabilidad Profunda\n\nLos parametros const imponen inmutabilidad profunda - ninguna mutacion a traves de ninguna ruta:\n\n```hemlock\nfn describe(const person: object) {\n    print(person.name);       // OK: leer esta permitido\n    // person.name = \"Bob\";   // ERROR: no se puede mutar\n    // person.address.city = \"NYC\";  // ERROR: const profundo\n}\n```\n\n### Lo Que Const Previene\n\n| Tipo | Bloqueado por Const | Permitido |\n|------|---------------------|-----------|\n| array | push, pop, shift, unshift, insert, remove, clear, reverse | slice, concat, map, filter, find, contains |\n| object | asignacion de campo | lectura de campo |\n| buffer | asignacion de indice | lectura de indice |\n| string | asignacion de indice | todos los metodos (retornan nuevas cadenas) |\n\n## Argumentos con Nombre\n\nLas funciones pueden llamarse con argumentos con nombre para claridad y flexibilidad:\n\n### Argumentos con Nombre Basicos\n\n```hemlock\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" is \" + age + \" years old\");\n}\n\n// Argumentos posicionales (tradicional)\ncreate_user(\"Alice\", 25, false);\n\n// Argumentos con nombre - pueden estar en cualquier orden\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n```\n\n### Mezclar Posicionales y con Nombre\n\n```hemlock\n// Saltar parametros opcionales nombrando lo que necesitas\ncreate_user(\"David\", active: false);  // Usa age=18 por defecto\n\n// Los argumentos con nombre deben venir despues de los posicionales\ncreate_user(\"Eve\", age: 21);          // OK\n// create_user(name: \"Bad\", 25);      // ERROR: posicional despues de nombrado\n```\n\n### Reglas para Argumentos con Nombre\n\n- Usar sintaxis `name: value` para argumentos con nombre\n- Los argumentos con nombre pueden aparecer en cualquier orden despues de los argumentos posicionales\n- Los argumentos posicionales no pueden seguir a los argumentos con nombre\n- Funciona con parametros por defecto/opcionales\n- Nombres de parametros desconocidos causan errores de tiempo de ejecucion\n\n## Limitaciones\n\nLimitaciones actuales a tener en cuenta:\n\n- **Sin paso por referencia** - La palabra clave `ref` se analiza pero no esta implementada\n- **Sin sobrecarga de funciones** - Una funcion por nombre\n- **Sin optimizacion de llamada de cola** - La recursion profunda limitada por tamano de pila\n\n## Temas Relacionados\n\n- [Flujo de Control](#language-guide-control-flow) - Usando funciones con estructuras de control\n- [Objetos](#language-guide-objects) - Los metodos son funciones almacenadas en objetos\n- [Manejo de Errores](#language-guide-error-handling) - Funciones y manejo de excepciones\n- [Tipos](#language-guide-types) - Anotaciones de tipo y conversiones\n\n## Ver Tambien\n\n- **Clausuras**: Ver la seccion \"Funciones\" en CLAUDE.md para semantica de clausuras\n- **Valores de Primera Clase**: Las funciones son valores como cualquier otro\n- **Alcance Lexico**: Las funciones capturan su entorno de definicion\n"}, "Gua del Lenguaje -> Gestin de Memoria": {"id": "language-guide-memory", "content": "# Gestin de Memoria\n\nHemlock adopta la **gestin manual de memoria** con control explcito sobre la asignacin y liberacin. Esta gua cubre el modelo de memoria de Hemlock, los dos tipos de punteros y la API completa de memoria.\n\n---\n\n## Memoria 101: Lo Bsico\n\n**Nuevo en programacin?** Comience aqu. Si ya entiende la gestin de memoria, salte a [Filosofa](#filosofa).\n\n### Qu es la Gestin de Memoria?\n\nCuando su programa necesita almacenar datos (texto, nmeros, listas), necesita espacio para colocarlos. Ese espacio viene de la memoria de su computadora (RAM). La gestin de memoria trata sobre:\n\n1. **Obtener espacio** - solicitar memoria cuando la necesita\n2. **Usar espacio** - leer y escribir sus datos\n3. **Devolverla** - retornar la memoria cuando haya terminado\n\n### Por Qu Importa?\n\nImagine una biblioteca con libros limitados:\n- Si sigue sacando libros y nunca los devuelve, eventualmente no quedan\n- Si intenta leer un libro que ya devolvi, se confundir o causar problemas\n\nLa memoria funciona de la misma manera. Si olvida devolver la memoria, su programa lentamente usa ms y ms (una \"fuga de memoria\"). Si intenta usar memoria despus de devolverla, suceden cosas malas.\n\n### Las Buenas Noticias\n\n**La mayor parte del tiempo, no necesita pensar en esto!**\n\nHemlock limpia automticamente la mayora de los tipos comunes:\n\n```hemlock\nfn example() {\n    let name = \"Alice\";       // Hemlock maneja esto\n    let numbers = [1, 2, 3];  // Y esto\n    let person = { age: 30 }; // Y esto tambin\n\n    // Cuando la funcin termina, todo esto se limpia automticamente!\n}\n```\n\n### Cundo S Necesita Pensar en Ello\n\nSolo necesita gestin manual de memoria cuando usa:\n\n1. **`alloc()`** - asignacin de memoria cruda (retorna `ptr`)\n2. **`buffer()`** - cuando quiere liberar temprano (opcional - se auto-libera al final del mbito)\n\n```hemlock\n// Esto necesita limpieza manual:\nlet raw = alloc(100);   // Memoria cruda - USTED debe liberarla\n// ... usar raw ...\nfree(raw);              // Requerido! O tiene una fuga de memoria\n\n// Esto se limpia automticamente (pero PUEDE liberar temprano):\nlet buf = buffer(100);  // Buffer seguro\n// ... usar buf ...\n// free(buf);           // Opcional - se auto-liberar cuando el mbito termine\n```\n\n### La Regla Simple\n\n> **Si llama a `alloc()`, debe llamar a `free()`.**\n>\n> Todo lo dems se maneja por usted.\n\n### Cul Debera Usar?\n\n| Situacin | Use Esto | Por Qu |\n|-----------|----------|---------|\n| **Recin comenzando** | `buffer()` | Seguro, con verificacin de lmites, auto-limpieza |\n| **Necesita almacenamiento de bytes** | `buffer()` | Seguro y fcil |\n| **Trabajando con bibliotecas C (FFI)** | `alloc()` / `ptr` | Requerido para interoperabilidad con C |\n| **Mximo rendimiento** | `alloc()` / `ptr` | Sin overhead de verificacin de lmites |\n| **No est seguro** | `buffer()` | Siempre la opcin ms segura |\n\n### Ejemplo Rpido: Seguro vs Crudo\n\n```hemlock\n// RECOMENDADO: Buffer seguro\nfn safe_example() {\n    let data = buffer(10);\n    data[0] = 65;           // OK\n    data[5] = 66;           // OK\n    // data[100] = 67;      // ERROR - Hemlock lo detiene (verificacin de lmites)\n    free(data);             // Limpiar\n}\n\n// AVANZADO: Puntero crudo (solo cuando lo necesita)\nfn raw_example() {\n    let data = alloc(10);\n    *data = 65;             // OK\n    *(data + 5) = 66;       // OK\n    *(data + 100) = 67;     // PELIGRO - Sin verificacin de lmites, corrompe memoria!\n    free(data);             // Limpiar\n}\n```\n\n**Comience con `buffer()`. Solo use `alloc()` cuando especficamente necesite punteros crudos.**\n\n---\n\n## Filosofa\n\nHemlock sigue el principio de gestin explcita de memoria con valores por defecto sensatos:\n- Sin recoleccin de basura (sin pausas impredecibles)\n- Conteo de referencias interno para tipos comunes (string, array, object, buffer)\n- Los punteros crudos (`ptr`) requieren `free()` manual\n\nEste enfoque hbrido le da control completo cuando lo necesita (punteros crudos) mientras previene errores comunes para casos de uso tpicos (tipos con conteo de referencias auto-liberados al salir del mbito).\n\n## Conteo de Referencias Interno\n\nEl runtime usa **conteo de referencias interno** para gestionar tiempos de vida de objetos. Para la mayora de las variables locales de tipos con conteo de referencias, la limpieza es automtica y determinista.\n\n### Qu Maneja el Conteo de Referencias\n\nEl runtime automticamente gestiona conteos de referencias cuando:\n\n1. **Las variables se reasignan** - el valor antiguo se libera:\n   ```hemlock\n   let x = \"first\";   // ref_count = 1\n   x = \"second\";      // \"first\" liberado internamente, \"second\" ref_count = 1\n   ```\n\n2. **Los mbitos terminan** - las variables locales se liberan:\n   ```hemlock\n   fn example() {\n       let arr = [1, 2, 3];  // ref_count = 1\n   }  // arr liberado cuando la funcin retorna\n   ```\n\n3. **Los contenedores se liberan** - los elementos se liberan:\n   ```hemlock\n   let arr = [obj1, obj2];\n   free(arr);  // obj1 y obj2 obtienen sus ref_counts decrementados\n   ```\n\n### Cundo Necesita `free()` vs Cundo Es Automtico\n\n**Automtico (no necesita `free()`):** Las variables locales de tipos con conteo de referencias se liberan cuando el mbito termina:\n\n```hemlock\nfn process_data() {\n    let arr = [1, 2, 3];\n    let obj = { name: \"test\" };\n    let buf = buffer(64);\n    // ... usarlos ...\n}  // Todos liberados automticamente cuando la funcin retorna - no necesita free()\n```\n\n**Se requiere `free()` manual:**\n\n1. **Punteros crudos** - `alloc()` no tiene conteo de referencias:\n   ```hemlock\n   let p = alloc(64);\n   // ... usar p ...\n   free(p);  // Siempre requerido - fugar de otro modo\n   ```\n\n2. **Limpieza temprana** - liberar antes de que el mbito termine para liberar memoria ms pronto:\n   ```hemlock\n   fn long_running() {\n       let big = buffer(10000000);  // 10MB\n       // ... terminado con big ...\n       free(big);  // Liberar ahora, no esperar a que la funcin retorne\n       // ... ms trabajo que no necesita big ...\n   }\n   ```\n\n3. **Datos de larga vida** - globales o datos almacenados en estructuras persistentes:\n   ```hemlock\n   let cache = {};  // Nivel de mdulo, vive hasta que el programa termine a menos que se libere\n\n   fn cleanup() {\n       free(cache);  // Limpieza manual para datos de larga vida\n   }\n   ```\n\n### Conteo de Referencias vs Recoleccin de Basura\n\n| Aspecto | Conteo de Referencias Hemlock | Recoleccin de Basura |\n|---------|------------------------------|----------------------|\n| Momento de limpieza | Determinista (inmediato cuando ref llega a 0) | No determinista (GC decide cundo) |\n| Responsabilidad del usuario | Debe llamar `free()` | Completamente automtico |\n| Pausas del runtime | Ninguna | Pausas \"detener el mundo\" |\n| Visibilidad | Detalle de implementacin oculto | Usualmente invisible |\n| Ciclos | Manejados con seguimiento de conjunto visitado | Manejados por rastreo |\n\n### Qu Tipos Tienen Conteo de Referencias\n\n| Tipo | Con Conteo | Notas |\n|------|------------|-------|\n| `ptr` | No | Siempre requiere `free()` manual |\n| `buffer` | S | Auto-liberado al salir del mbito; `free()` manual para limpieza temprana |\n| `array` | S | Auto-liberado al salir del mbito; `free()` manual para limpieza temprana |\n| `object` | S | Auto-liberado al salir del mbito; `free()` manual para limpieza temprana |\n| `string` | S | Completamente automtico, no necesita `free()` |\n| `function` | S | Completamente automtico (entornos de closure) |\n| `task` | S | Conteo de referencias atmico thread-safe |\n| `channel` | S | Conteo de referencias atmico thread-safe |\n| Primitivos | No | Asignados en stack, sin asignacin de heap |\n\n### Por Qu Este Diseo?\n\nEste enfoque hbrido le da:\n- **Control explcito** - Usted decide cundo liberar\n- **Seguridad contra bugs de mbito** - La reasignacin no fuga\n- **Rendimiento predecible** - Sin pausas de GC\n- **Soporte de closures** - Las funciones pueden capturar variables de forma segura\n\nLa filosofa permanece: usted tiene el control, pero el runtime ayuda a prevenir errores comunes como fugas en reasignacin o double-free en contenedores.\n\n## Los Dos Tipos de Punteros\n\nHemlock proporciona dos tipos de punteros distintos, cada uno con diferentes caractersticas de seguridad:\n\n### `ptr` - Puntero Crudo (Peligroso)\n\nLos punteros crudos son **solo direcciones** con garantas de seguridad mnimas:\n\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // Debe recordar liberar\n```\n\n**Caractersticas:**\n- Solo una direccin de 8 bytes\n- Sin verificacin de lmites\n- Sin seguimiento de longitud\n- El usuario gestiona el tiempo de vida completamente\n- Para expertos y FFI\n\n**Casos de uso:**\n- Programacin de sistemas de bajo nivel\n- Interfaz de Funciones Forneas (FFI)\n- Cdigo crtico para rendimiento\n- Cuando necesita control completo\n\n**Peligros:**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Muy pasado el lmite de asignacin - permitido pero peligroso\nfree(p);\nlet x = *p;       // Puntero colgante - comportamiento indefinido\nfree(p);          // Double-free - fallar\n```\n\n### `buffer` - Envoltorio Seguro (Recomendado)\n\nLos buffers proporcionan **acceso con verificacin de lmites** mientras an requieren liberacin manual:\n\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // verificado por lmites\nprint(b.length);        // 64\nfree(b);                // an manual\n```\n\n**Caractersticas:**\n- Puntero + longitud + capacidad\n- Verificacin de lmites en acceso\n- An requiere `free()` manual\n- Mejor opcin por defecto para la mayora del cdigo\n\n**Propiedades:**\n```hemlock\nlet buf = buffer(100);\nprint(buf.length);      // 100 (tamao actual)\nprint(buf.capacity);    // 100 (capacidad asignada)\n```\n\n**Verificacin de lmites:**\n```hemlock\nlet buf = buffer(10);\nbuf[5] = 42;      // OK\nbuf[100] = 42;    // ERROR: Index out of bounds\n```\n\n## API de Memoria\n\n### Asignacin Bsica\n\n**`alloc(bytes)` - Asignar memoria cruda**\n```hemlock\nlet p = alloc(1024);  // Asignar 1KB, retorna ptr\n// ... usar memoria\nfree(p);\n```\n\n**`buffer(size)` - Asignar buffer seguro**\n```hemlock\nlet buf = buffer(256);  // Asignar buffer de 256 bytes\nbuf[0] = 65;            // 'A'\nbuf[1] = 66;            // 'B'\nfree(buf);\n```\n\n**`free(ptr)` - Liberar memoria**\n```hemlock\nlet p = alloc(100);\nfree(p);  // Debe liberar para evitar fuga de memoria\n\nlet buf = buffer(100);\nfree(buf);  // Funciona tanto en ptr como en buffer\n```\n\n**Importante:** `free()` funciona tanto en tipos `ptr` como `buffer`.\n\n### Operaciones de Memoria\n\n**`memset(ptr, byte, size)` - Llenar memoria**\n```hemlock\nlet p = alloc(100);\nmemset(p, 0, 100);     // Poner a cero 100 bytes\nmemset(p, 65, 10);     // Llenar los primeros 10 bytes con 'A'\nfree(p);\n```\n\n**`memcpy(dest, src, size)` - Copiar memoria**\n```hemlock\nlet src = alloc(50);\nlet dst = alloc(50);\nmemset(src, 42, 50);\nmemcpy(dst, src, 50);  // Copiar 50 bytes de src a dst\nfree(src);\nfree(dst);\n```\n\n**`realloc(ptr, size)` - Redimensionar asignacin**\n```hemlock\nlet p = alloc(100);\n// ... usar 100 bytes\np = realloc(p, 200);   // Redimensionar a 200 bytes\n// ... usar 200 bytes\nfree(p);\n```\n\n**Nota:** Despus de `realloc()`, el puntero antiguo puede ser invlido. Siempre use el puntero retornado.\n\n### Asignacin Tipada\n\nHemlock proporciona ayudantes de asignacin tipada por conveniencia:\n\n```hemlock\nlet arr = talloc(i32, 100);  // Asignar 100 valores i32 (400 bytes)\nlet size = sizeof(i32);      // Retorna 4 (bytes)\n```\n\n**`sizeof(type)`** retorna el tamao en bytes de un tipo:\n- `sizeof(i8)` / `sizeof(u8)`  1\n- `sizeof(i16)` / `sizeof(u16)`  2\n- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)`  4\n- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)`  8\n- `sizeof(ptr)`  8 (en sistemas de 64 bits)\n\n**`talloc(type, count)`** asigna `count` elementos de `type`:\n\n```hemlock\nlet ints = talloc(i32, 10);   // 40 bytes para 10 valores i32\nlet floats = talloc(f64, 5);  // 40 bytes para 5 valores f64\nfree(ints);\nfree(floats);\n```\n\n## Patrones Comunes\n\n### Patrn: Asignar, Usar, Liberar\n\nEl patrn bsico para gestin de memoria:\n\n```hemlock\n// 1. Asignar\nlet data = alloc(1024);\n\n// 2. Usar\nmemset(data, 0, 1024);\n// ... hacer trabajo\n\n// 3. Liberar\nfree(data);\n```\n\n### Patrn: Uso de Buffer Seguro\n\nPrefiera buffers para acceso con verificacin de lmites:\n\n```hemlock\nlet buf = buffer(256);\n\n// Iteracin segura\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\nfree(buf);\n```\n\n### Patrn: Gestin de Recursos con try/finally\n\nAsegure la limpieza incluso en errores:\n\n```hemlock\nlet data = alloc(1024);\ntry {\n    // ... operaciones riesgosas\n    process(data);\n} finally {\n    free(data);  // Siempre liberado, incluso en error\n}\n```\n\n## Consideraciones de Seguridad de Memoria\n\n### Double-Free\n\n**Permitido pero fallar:**\n```hemlock\nlet p = alloc(100);\nfree(p);\nfree(p);  // FALLA: Double-free detectado\n```\n\n**Prevencin:**\n```hemlock\nlet p = alloc(100);\nfree(p);\np = null;  // Establecer a null despus de liberar\n\nif (p != null) {\n    free(p);  // No se ejecutar\n}\n```\n\n### Punteros Colgantes\n\n**Permitido pero comportamiento indefinido:**\n```hemlock\nlet p = alloc(100);\n*p = 42;      // OK\nfree(p);\nlet x = *p;   // INDEFINIDO: Leyendo memoria liberada\n```\n\n**Prevencin:** No acceda a memoria despus de liberar.\n\n### Fugas de Memoria\n\n**Fciles de crear, difciles de depurar:**\n```hemlock\nfn leak_memory() {\n    let p = alloc(1000);\n    // Olvid liberar!\n    return;  // Memoria fugada\n}\n```\n\n**Prevencin:** Siempre empareje `alloc()` con `free()`:\n```hemlock\nfn safe_function() {\n    let p = alloc(1000);\n    try {\n        // ... usar p\n    } finally {\n        free(p);  // Siempre liberado\n    }\n}\n```\n\n### Aritmtica de Punteros\n\n**Permitida pero peligrosa:**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Muy pasado el lmite de asignacin\n*q = 42;          // INDEFINIDO: Escritura fuera de lmites\nfree(p);\n```\n\n**Use buffers para verificacin de lmites:**\n```hemlock\nlet buf = buffer(10);\nbuf[100] = 42;  // ERROR: La verificacin de lmites previene el desbordamiento\n```\n\n## Mejores Prcticas\n\n1. **Por defecto use `buffer`** - Use `buffer` a menos que especficamente necesite `ptr` crudo\n2. **Empareje alloc/free** - Cada `alloc()` debe tener exactamente un `free()`\n3. **Use try/finally** - Asegure limpieza con manejo de excepciones\n4. **Null despus de free** - Establezca punteros a `null` despus de liberar para detectar uso despus de liberacin\n5. **Verificacin de lmites** - Use indexacin de buffer para verificacin automtica de lmites\n6. **Documente propiedad** - Deje claro qu cdigo posee y libera cada asignacin\n\n## Ejemplos\n\n### Ejemplo: Constructor de Strings Dinmico\n\n```hemlock\nfn build_message(count: i32): ptr {\n    let size = count * 10;\n    let buf = alloc(size);\n\n    let i = 0;\n    while (i < count) {\n        memset(buf + (i * 10), 65 + i, 10);\n        i = i + 1;\n    }\n\n    return buf;  // El llamador debe liberar\n}\n\nlet msg = build_message(5);\n// ... usar msg\nfree(msg);\n```\n\n### Ejemplo: Operaciones de Array Seguras\n\n```hemlock\nfn process_array(size: i32) {\n    let arr = buffer(size);\n\n    try {\n        // Llenar array\n        let i = 0;\n        while (i < arr.length) {\n            arr[i] = i * 2;\n            i = i + 1;\n        }\n\n        // Procesar\n        i = 0;\n        while (i < arr.length) {\n            print(arr[i]);\n            i = i + 1;\n        }\n    } finally {\n        free(arr);  // Siempre limpiar\n    }\n}\n```\n\n### Ejemplo: Patrn de Pool de Memoria\n\n```hemlock\n// Pool de memoria simple (simplificado)\nlet pool = alloc(10000);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > 10000) {\n        throw \"Pool exhausted\";\n    }\n\n    let ptr = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return ptr;\n}\n\n// Usar pool\nlet p1 = pool_alloc(100);\nlet p2 = pool_alloc(200);\n\n// Liberar todo el pool de una vez\nfree(pool);\n```\n\n## Limitaciones\n\nLimitaciones actuales a tener en cuenta:\n\n- **Los punteros crudos requieren free manual** - `alloc()` retorna `ptr` sin conteo de referencias\n- **Sin asignadores personalizados** - Solo malloc/free del sistema\n\n**Nota:** Los tipos con conteo de referencias (string, array, object, buffer) S se liberan automticamente cuando el mbito termina. Solo `ptr` crudo de `alloc()` requiere `free()` explcito.\n\n## Temas Relacionados\n\n- [Strings](#language-guide-strings) - Gestin de memoria de strings y codificacin UTF-8\n- [Arrays](#language-guide-arrays) - Arrays dinmicos y sus caractersticas de memoria\n- [Objetos](#language-guide-objects) - Asignacin y tiempo de vida de objetos\n- [Manejo de Errores](#language-guide-error-handling) - Usando try/finally para limpieza\n\n## Ver Tambin\n\n- **Filosofa de Diseo**: Consulte la seccin \"Memory Management\" de CLAUDE.md\n- **Sistema de Tipos**: Consulte [Tipos](#language-guide-types) para detalles de tipos `ptr` y `buffer`\n- **FFI**: Los punteros crudos son esenciales para la Interfaz de Funciones Forneas\n"}, "Gua del Lenguaje -> Manejo de Errores": {"id": "language-guide-error-handling", "content": "# Manejo de Errores\n\nHemlock soporta manejo de errores basado en excepciones con `try`, `catch`, `finally`, `throw` y `panic`. Esta gua cubre errores recuperables con excepciones y errores irrecuperables con panic.\n\n## Resumen\n\n```hemlock\n// Manejo bsico de errores\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\n// Con limpieza\ntry {\n    process_file();\n} catch (e) {\n    print(\"Failed: \" + e);\n} finally {\n    cleanup();\n}\n\n// Lanzando errores\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n```\n\n## Try-Catch-Finally\n\n### Sintaxis\n\n**Try/catch bsico:**\n```hemlock\ntry {\n    // cdigo riesgoso\n} catch (e) {\n    // manejar error, e contiene el valor lanzado\n}\n```\n\n**Try/finally:**\n```hemlock\ntry {\n    // cdigo riesgoso\n} finally {\n    // siempre se ejecuta, incluso si se lanza excepcin\n}\n```\n\n**Try/catch/finally:**\n```hemlock\ntry {\n    // cdigo riesgoso\n} catch (e) {\n    // manejar error\n} finally {\n    // cdigo de limpieza\n}\n```\n\n### Bloque Try\n\nEl bloque try ejecuta sentencias secuencialmente:\n\n```hemlock\ntry {\n    print(\"Starting...\");\n    risky_operation();\n    print(\"Success!\");  // Solo si no hay excepcin\n}\n```\n\n**Comportamiento:**\n- Ejecuta sentencias en orden\n- Si se lanza excepcin: salta a `catch` o `finally`\n- Si no hay excepcin: ejecuta `finally` (si est presente) y luego contina\n\n### Bloque Catch\n\nEl bloque catch recibe el valor lanzado:\n\n```hemlock\ntry {\n    throw \"oops\";\n} catch (error) {\n    print(\"Caught: \" + error);  // error = \"oops\"\n    // error solo accesible aqu\n}\n// error no accesible aqu\n```\n\n**Parmetro catch:**\n- Recibe el valor lanzado (cualquier tipo)\n- Con mbito del bloque catch\n- Puede tener cualquier nombre (convencionalmente `e`, `err` o `error`)\n\n**Qu puede hacer en catch:**\n```hemlock\ntry {\n    risky_operation();\n} catch (e) {\n    // Registrar el error\n    print(\"Error: \" + e);\n\n    // Relanzar el mismo error\n    throw e;\n\n    // Lanzar error diferente\n    throw \"different error\";\n\n    // Retornar un valor por defecto\n    return null;\n\n    // Manejar y continuar\n    // (sin relanzar)\n}\n```\n\n### Bloque Finally\n\nEl bloque finally **siempre se ejecuta**:\n\n```hemlock\ntry {\n    print(\"1: try\");\n    throw \"error\";\n} catch (e) {\n    print(\"2: catch\");\n} finally {\n    print(\"3: finally\");  // Siempre se ejecuta\n}\nprint(\"4: after\");\n\n// Salida: 1: try, 2: catch, 3: finally, 4: after\n```\n\n**Cundo se ejecuta finally:**\n- Despus del bloque try (si no hay excepcin)\n- Despus del bloque catch (si se captur excepcin)\n- Incluso si try/catch contiene `return`, `break` o `continue`\n- Antes de que el flujo de control salga del try/catch\n\n**Finally con return:**\n```hemlock\nfn example() {\n    try {\n        return 1;  // Retorna 1 despus de que finally se ejecute\n    } finally {\n        print(\"cleanup\");  // Se ejecuta antes de retornar\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // El return de finally sobrescribe - retorna 2\n    }\n}\n```\n\n**Finally con flujo de control:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) {\n            break;  // Sale despus de que finally se ejecute\n        }\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```\n\n## Sentencia Throw\n\n### Throw Bsico\n\nLanza cualquier valor como excepcin:\n\n```hemlock\nthrow \"error message\";\nthrow 404;\nthrow { code: 500, message: \"Internal error\" };\nthrow null;\nthrow [\"error\", \"details\"];\n```\n\n**Ejecucin:**\n1. Evala la expresin\n2. Inmediatamente salta al `catch` ms cercano\n3. Si no hay `catch`, propaga hacia arriba en la pila de llamadas\n\n### Lanzando Errores\n\n```hemlock\nfn validate_age(age: i32) {\n    if (age < 0) {\n        throw \"Age cannot be negative\";\n    }\n    if (age > 150) {\n        throw \"Age is unrealistic\";\n    }\n}\n\ntry {\n    validate_age(-5);\n} catch (e) {\n    print(\"Validation error: \" + e);\n}\n```\n\n### Lanzando Objetos de Error\n\nCree informacin de error estructurada:\n\n```hemlock\nfn read_file(path: string) {\n    if (!file_exists(path)) {\n        throw {\n            type: \"FileNotFound\",\n            path: path,\n            message: \"File does not exist\"\n        };\n    }\n    // ... leer archivo\n}\n\ntry {\n    read_file(\"missing.txt\");\n} catch (e) {\n    if (e.type == \"FileNotFound\") {\n        print(\"File not found: \" + e.path);\n    }\n}\n```\n\n### Relanzamiento\n\nCapturar y relanzar errores:\n\n```hemlock\nfn wrapper() {\n    try {\n        risky_operation();\n    } catch (e) {\n        print(\"Logging error: \" + e);\n        throw e;  // Relanzar al llamador\n    }\n}\n\ntry {\n    wrapper();\n} catch (e) {\n    print(\"Caught in main: \" + e);\n}\n```\n\n## Excepciones No Capturadas\n\nSi una excepcin propaga hasta el tope de la pila de llamadas sin ser capturada:\n\n```hemlock\nfn foo() {\n    throw \"uncaught!\";\n}\n\nfoo();  // Falla con: Runtime error: uncaught!\n```\n\n**Comportamiento:**\n- El programa falla\n- Imprime mensaje de error a stderr\n- Sale con cdigo de estado distinto de cero\n- Traza de pila a ser agregada en versiones futuras\n\n## Panic - Errores Irrecuperables\n\n### Qu es Panic?\n\n`panic()` es para **errores irrecuperables** que deben terminar el programa inmediatamente:\n\n```hemlock\npanic();                    // Mensaje por defecto: \"panic!\"\npanic(\"custom message\");    // Mensaje personalizado\npanic(42);                  // Valores no string se imprimen\n```\n\n**Semntica:**\n- **Sale inmediatamente** del programa con cdigo de salida 1\n- Imprime mensaje de error a stderr: `panic: <mensaje>`\n- **NO es capturable** con try/catch\n- Usar para bugs y errores irrecuperables\n\n### Panic vs Throw\n\n```hemlock\n// throw - Error recuperable (puede ser capturado)\ntry {\n    throw \"recoverable error\";\n} catch (e) {\n    print(\"Caught: \" + e);  // Capturado exitosamente\n}\n\n// panic - Error irrecuperable (no puede ser capturado)\ntry {\n    panic(\"unrecoverable error\");  // El programa sale inmediatamente\n} catch (e) {\n    print(\"This never runs\");       // Nunca se ejecuta\n}\n```\n\n### Cundo Usar Panic\n\n**Use panic para:**\n- **Bugs**: Se alcanz cdigo inalcanzable\n- **Estado invlido**: Se detect corrupcin de estructura de datos\n- **Errores irrecuperables**: Recurso crtico no disponible\n- **Fallos de asercin**: Cuando `assert()` no es suficiente\n\n**Ejemplos:**\n```hemlock\n// Cdigo inalcanzable\nfn process_state(state: i32) {\n    if (state == 1) {\n        return \"ready\";\n    } else if (state == 2) {\n        return \"running\";\n    } else if (state == 3) {\n        return \"stopped\";\n    } else {\n        panic(\"invalid state: \" + typeof(state));  // Nunca debera pasar\n    }\n}\n\n// Verificacin de recurso crtico\nfn init_system() {\n    let config = read_file(\"config.json\");\n    if (config == null) {\n        panic(\"config.json not found - cannot start\");\n    }\n    // ...\n}\n\n// Invariante de estructura de datos\nfn pop_stack(stack) {\n    if (stack.length == 0) {\n        panic(\"pop() called on empty stack\");\n    }\n    return stack.pop();\n}\n```\n\n### Cundo NO Usar Panic\n\n**Use throw en su lugar para:**\n- Validacin de entrada de usuario\n- Archivo no encontrado\n- Errores de red\n- Condiciones de error esperadas\n\n```hemlock\n// MAL: Panic para errores esperados\nfn divide(a, b) {\n    if (b == 0) {\n        panic(\"division by zero\");  // Demasiado severo\n    }\n    return a / b;\n}\n\n// BIEN: Throw para errores esperados\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";  // Recuperable\n    }\n    return a / b;\n}\n```\n\n## Interacciones de Flujo de Control\n\n### Return Dentro de Try/Catch/Finally\n\n```hemlock\nfn example() {\n    try {\n        return 1;  // Retorna 1 despus de que finally se ejecute\n    } finally {\n        print(\"cleanup\");\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // El return de finally sobrescribe el return de try - retorna 2\n    }\n}\n```\n\n**Regla:** Los valores de retorno del bloque finally sobrescriben los valores de retorno de try/catch.\n\n### Break/Continue Dentro de Try/Catch/Finally\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) { break; }  // Sale despus de que finally se ejecute\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```\n\n**Regla:** Break/continue se ejecutan despus del bloque finally.\n\n### Try/Catch Anidados\n\n```hemlock\ntry {\n    try {\n        throw \"inner\";\n    } catch (e) {\n        print(\"Caught: \" + e);  // Imprime: Caught: inner\n        throw \"outer\";  // Relanza error diferente\n    }\n} catch (e) {\n    print(\"Caught: \" + e);  // Imprime: Caught: outer\n}\n```\n\n**Regla:** Los bloques try/catch anidados funcionan como se espera, las capturas internas suceden primero.\n\n## Patrones Comunes\n\n### Patrn: Limpieza de Recursos\n\nSiempre use `finally` para limpieza:\n\n```hemlock\nfn process_file(filename) {\n    let file = null;\n    try {\n        file = open(filename);\n        let content = file.read();\n        process(content);\n    } catch (e) {\n        print(\"Error processing file: \" + e);\n    } finally {\n        if (file != null) {\n            file.close();  // Siempre cierra, incluso en error\n        }\n    }\n}\n```\n\n### Patrn: Envolvimiento de Errores\n\nEnvuelva errores de nivel inferior con contexto:\n\n```hemlock\nfn load_config(path) {\n    try {\n        let content = read_file(path);\n        return parse_json(content);\n    } catch (e) {\n        throw \"Failed to load config from \" + path + \": \" + e;\n    }\n}\n```\n\n### Patrn: Recuperacin de Errores\n\nProporcione alternativa en caso de error:\n\n```hemlock\nfn safe_divide(a, b) {\n    try {\n        if (b == 0) {\n            throw \"division by zero\";\n        }\n        return a / b;\n    } catch (e) {\n        print(\"Error: \" + e);\n        return null;  // Valor alternativo\n    }\n}\n```\n\n### Patrn: Validacin\n\nUse excepciones para validacin:\n\n```hemlock\nfn validate_user(user) {\n    if (user.name == null || user.name == \"\") {\n        throw \"Name is required\";\n    }\n    if (user.age < 0 || user.age > 150) {\n        throw \"Invalid age\";\n    }\n    if (user.email == null || !user.email.contains(\"@\")) {\n        throw \"Invalid email\";\n    }\n}\n\ntry {\n    validate_user({ name: \"Alice\", age: -5, email: \"invalid\" });\n} catch (e) {\n    print(\"Validation failed: \" + e);\n}\n```\n\n### Patrn: Mltiples Tipos de Error\n\nUse objetos de error para distinguir tipos de error:\n\n```hemlock\nfn process_data(data) {\n    if (data == null) {\n        throw { type: \"NullData\", message: \"Data is null\" };\n    }\n\n    if (typeof(data) != \"array\") {\n        throw { type: \"TypeError\", message: \"Expected array\" };\n    }\n\n    if (data.length == 0) {\n        throw { type: \"EmptyData\", message: \"Array is empty\" };\n    }\n\n    // ... procesar\n}\n\ntry {\n    process_data(null);\n} catch (e) {\n    if (e.type == \"NullData\") {\n        print(\"No data provided\");\n    } else if (e.type == \"TypeError\") {\n        print(\"Wrong data type: \" + e.message);\n    } else {\n        print(\"Error: \" + e.message);\n    }\n}\n```\n\n## Mejores Prcticas\n\n1. **Use excepciones para casos excepcionales** - No para flujo de control normal\n2. **Lance errores significativos** - Use strings u objetos con contexto\n3. **Siempre use finally para limpieza** - Asegura que los recursos se liberen\n4. **No capture e ignore** - Al menos registre el error\n5. **Relance cuando sea apropiado** - Deje que el llamador maneje si usted no puede\n6. **Panic para bugs** - Use panic para errores irrecuperables\n7. **Documente las excepciones** - Deje claro qu funciones pueden lanzar\n\n## Errores Comunes\n\n### Error: Tragarse Errores\n\n```hemlock\n// MAL: Fallo silencioso\ntry {\n    risky_operation();\n} catch (e) {\n    // Error ignorado - fallo silencioso\n}\n\n// BIEN: Registrar o manejar\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Operation failed: \" + e);\n    // Manejar apropiadamente\n}\n```\n\n### Error: Sobrescritura de Finally\n\n```hemlock\n// MAL: Finally sobrescribe return\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        return 0;  // Retorna 0, no 42!\n    }\n}\n\n// BIEN: No retornar en finally\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        cleanup();  // Solo limpieza, sin return\n    }\n}\n```\n\n### Error: Olvidar Limpieza\n\n```hemlock\n// MAL: El archivo puede no cerrarse en error\nfn process() {\n    let file = open(\"data.txt\");\n    let content = file.read();  // Puede lanzar\n    file.close();  // Nunca se alcanza si hay error\n}\n\n// BIEN: Usar finally\nfn process() {\n    let file = null;\n    try {\n        file = open(\"data.txt\");\n        let content = file.read();\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n}\n```\n\n### Error: Usar Panic para Errores Esperados\n\n```hemlock\n// MAL: Panic para error esperado\nfn read_config(path) {\n    if (!file_exists(path)) {\n        panic(\"Config file not found\");  // Demasiado severo\n    }\n    return read_file(path);\n}\n\n// BIEN: Throw para error esperado\nfn read_config(path) {\n    if (!file_exists(path)) {\n        throw \"Config file not found: \" + path;  // Recuperable\n    }\n    return read_file(path);\n}\n```\n\n## Ejemplos\n\n### Ejemplo: Manejo Bsico de Errores\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    print(divide(10, 0));\n} catch (e) {\n    print(\"Error: \" + e);  // Imprime: Error: division by zero\n}\n```\n\n### Ejemplo: Gestin de Recursos\n\n```hemlock\nfn copy_file(src, dst) {\n    let src_file = null;\n    let dst_file = null;\n\n    try {\n        src_file = open(src, \"r\");\n        dst_file = open(dst, \"w\");\n\n        let content = src_file.read();\n        dst_file.write(content);\n\n        print(\"File copied successfully\");\n    } catch (e) {\n        print(\"Failed to copy file: \" + e);\n        throw e;  // Relanzar\n    } finally {\n        if (src_file != null) { src_file.close(); }\n        if (dst_file != null) { dst_file.close(); }\n    }\n}\n```\n\n### Ejemplo: Manejo de Errores Anidado\n\n```hemlock\nfn process_users(users) {\n    let success_count = 0;\n    let error_count = 0;\n\n    let i = 0;\n    while (i < users.length) {\n        try {\n            validate_user(users[i]);\n            save_user(users[i]);\n            success_count = success_count + 1;\n        } catch (e) {\n            print(\"Failed to process user: \" + e);\n            error_count = error_count + 1;\n        }\n        i = i + 1;\n    }\n\n    print(\"Processed: \" + typeof(success_count) + \" success, \" + typeof(error_count) + \" errors\");\n}\n```\n\n### Ejemplo: Tipos de Error Personalizados\n\n```hemlock\nfn create_error(type, message, details) {\n    return {\n        type: type,\n        message: message,\n        details: details,\n        toString: fn() {\n            return self.type + \": \" + self.message;\n        }\n    };\n}\n\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" && typeof(a) != \"f64\") {\n        throw create_error(\"TypeError\", \"a must be a number\", { value: a });\n    }\n    if (typeof(b) != \"i32\" && typeof(b) != \"f64\") {\n        throw create_error(\"TypeError\", \"b must be a number\", { value: b });\n    }\n    if (b == 0) {\n        throw create_error(\"DivisionByZero\", \"Cannot divide by zero\", { a: a, b: b });\n    }\n    return a / b;\n}\n\ntry {\n    divide(10, 0);\n} catch (e) {\n    print(e.toString());\n    if (e.type == \"DivisionByZero\") {\n        print(\"Details: a=\" + typeof(e.details.a) + \", b=\" + typeof(e.details.b));\n    }\n}\n```\n\n### Ejemplo: Lgica de Reintento\n\n```hemlock\nfn retry(operation, max_attempts) {\n    let attempt = 0;\n\n    while (attempt < max_attempts) {\n        try {\n            return operation();  // xito!\n        } catch (e) {\n            attempt = attempt + 1;\n            if (attempt >= max_attempts) {\n                throw \"Operation failed after \" + typeof(max_attempts) + \" attempts: \" + e;\n            }\n            print(\"Attempt \" + typeof(attempt) + \" failed, retrying...\");\n        }\n    }\n}\n\nfn unreliable_operation() {\n    // Operacin no confiable simulada\n    if (random() < 0.7) {\n        throw \"Operation failed\";\n    }\n    return \"Success\";\n}\n\ntry {\n    let result = retry(unreliable_operation, 3);\n    print(result);\n} catch (e) {\n    print(\"All retries failed: \" + e);\n}\n```\n\n## Orden de Ejecucin\n\nEntendiendo el orden de ejecucin:\n\n```hemlock\ntry {\n    print(\"1: try block start\");\n    throw \"error\";\n    print(\"2: never reached\");\n} catch (e) {\n    print(\"3: catch block\");\n} finally {\n    print(\"4: finally block\");\n}\nprint(\"5: after try/catch/finally\");\n\n// Salida:\n// 1: try block start\n// 3: catch block\n// 4: finally block\n// 5: after try/catch/finally\n```\n\n## Limitaciones Actuales\n\n- **Sin traza de pila** - Las excepciones no capturadas no muestran traza de pila (planificado)\n- **Algunos builtins salen** - Algunas funciones integradas todava usan `exit()` en lugar de lanzar (a revisar)\n- **Sin tipos de excepcin personalizados** - Cualquier valor puede ser lanzado, pero no hay jerarqua formal de excepciones\n\n## Temas Relacionados\n\n- [Funciones](#language-guide-functions) - Excepciones y retornos de funciones\n- [Flujo de Control](#language-guide-control-flow) - Cmo las excepciones afectan el flujo de control\n- [Memoria](#language-guide-memory) - Usando finally para limpieza de memoria\n\n## Ver Tambin\n\n- **Semntica de Excepciones**: Consulte la seccin \"Error Handling\" de CLAUDE.md\n- **Panic vs Throw**: Diferentes casos de uso para diferentes tipos de error\n- **Garanta de Finally**: Siempre se ejecuta, incluso con return/break/continue\n"}, "Gua del Lenguaje -> Mdulos": {"id": "language-guide-modules", "content": "# Sistema de Mdulos de Hemlock\n\nEste documento describe el sistema de mdulos de importacin/exportacin estilo ES6 implementado para Hemlock.\n\n## Resumen\n\nHemlock soporta un sistema de mdulos basado en archivos con sintaxis de importacin/exportacin estilo ES6. Los mdulos son:\n- **Singletons**: Cada mdulo se carga una vez y se almacena en cach\n- **Basados en archivos**: Los mdulos corresponden a archivos .hml en disco\n- **Importados explcitamente**: Las dependencias se declaran con sentencias import\n- **Ejecutados topolgicamente**: Las dependencias se ejecutan antes que los dependientes\n\nPara gestin de paquetes y dependencias de terceros, consulte [hpm (Hemlock Package Manager)](https://github.com/hemlang/hpm).\n\n## Sintaxis\n\n### Sentencias Export\n\n**Exportaciones con nombre en lnea:**\n```hemlock\nexport fn add(a, b) {\n    return a + b;\n}\n\nexport const PI = 3.14159;\nexport let counter = 0;\n```\n\n**Lista de exportacin:**\n```hemlock\nfn add(a, b) { return a + b; }\nfn subtract(a, b) { return a - b; }\n\nexport { add, subtract };\n```\n\n**Export Extern (Funciones FFI):**\n```hemlock\nimport \"libc.so.6\";\n\n// Exportar funciones FFI para uso en otros mdulos\nexport extern fn strlen(s: string): i32;\nexport extern fn getpid(): i32;\n```\n\nConsulte la [Documentacin FFI](../advanced/ffi.md#exporting-ffi-functions) para ms detalles sobre la exportacin de funciones FFI.\n\n**Export Define (Tipos Struct):**\n```hemlock\n// Exportar definiciones de tipos struct\nexport define Vector2 {\n    x: f32,\n    y: f32,\n}\n\nexport define Rectangle {\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n}\n```\n\n**Importante:** Los tipos struct exportados se registran globalmente cuando el mdulo se carga. Se vuelven disponibles automticamente cuando importa cualquier cosa del mdulo - NO necesita (y no puede) importarlos explcitamente por nombre:\n\n```hemlock\n// BIEN - los tipos struct estn auto-disponibles despus de cualquier importacin\nimport { some_function } from \"./my_module.hml\";\nlet v: Vector2 = { x: 1.0, y: 2.0 };  // Funciona!\n\n// MAL - no puede importar explcitamente tipos struct\nimport { Vector2 } from \"./my_module.hml\";  // Error: Undefined variable 'Vector2'\n```\n\nConsulte la [Documentacin FFI](../advanced/ffi.md#exporting-struct-types) para ms detalles sobre la exportacin de tipos struct.\n\n**Re-exportaciones:**\n```hemlock\n// Re-exportar desde otro mdulo\nexport { add, subtract } from \"./math.hml\";\n```\n\n### Sentencias Import\n\n**Importaciones con nombre:**\n```hemlock\nimport { add, subtract } from \"./math.hml\";\nprint(add(1, 2));  // 3\n```\n\n**Importacin de espacio de nombres:**\n```hemlock\nimport * as math from \"./math.hml\";\nprint(math.add(1, 2));  // 3\nprint(math.PI);  // 3.14159\n```\n\n**Alias:**\n```hemlock\nimport { add as sum, subtract as diff } from \"./math.hml\";\nprint(sum(1, 2));  // 3\n```\n\n## Resolucin de Mdulos\n\n### Tipos de Ruta\n\n**Rutas relativas:**\n```hemlock\nimport { foo } from \"./module.hml\";       // Mismo directorio\nimport { bar } from \"../parent.hml\";      // Directorio padre\nimport { baz } from \"./sub/nested.hml\";   // Subdirectorio\n```\n\n**Rutas absolutas:**\n```hemlock\nimport { foo } from \"/absolute/path/to/module.hml\";\n```\n\n**Manejo de extensiones:**\n- La extensin `.hml` puede omitirse - se agregar automticamente\n- `./math` se resuelve a `./math.hml`\n\n## Caractersticas\n\n### Deteccin de Dependencias Circulares\n\nEl sistema de mdulos detecta dependencias circulares y reporta un error:\n\n```\nError: Circular dependency detected when loading '/path/to/a.hml'\n```\n\n### Cach de Mdulos\n\nLos mdulos se cargan una vez y se almacenan en cach. Mltiples importaciones del mismo mdulo retornan la misma instancia:\n\n```hemlock\n// counter.hml\nexport let count = 0;\nexport fn increment() {\n    count = count + 1;\n}\n\n// a.hml\nimport { count, increment } from \"./counter.hml\";\nincrement();\nprint(count);  // 1\n\n// b.hml\nimport { count } from \"./counter.hml\";  // Misma instancia!\nprint(count);  // Todava 1 (estado compartido)\n```\n\n### Inmutabilidad de Importaciones\n\nLos bindings importados no pueden ser reasignados:\n\n```hemlock\nimport { add } from \"./math.hml\";\nadd = fn() { };  // ERROR: cannot reassign imported binding\n```\n\n## Detalles de Implementacin\n\n### Arquitectura\n\n**Archivos:**\n- `include/module.h` - API del sistema de mdulos\n- `src/module.c` - Carga, cach y ejecucin de mdulos\n- Soporte del parser en `src/parser.c`\n- Soporte del runtime en `src/interpreter/runtime.c`\n\n**Componentes clave:**\n1. **ModuleCache**: Mantiene mdulos cargados indexados por ruta absoluta\n2. **Module**: Representa un mdulo cargado con su AST y exportaciones\n3. **Resolucin de Rutas**: Resuelve rutas relativas/absolutas a rutas cannicas\n4. **Ejecucin Topolgica**: Ejecuta mdulos en orden de dependencias\n\n### Proceso de Carga de Mdulos\n\n1. **Fase de Anlisis**: Tokenizar y parsear el archivo del mdulo\n2. **Resolucin de Dependencias**: Cargar recursivamente mdulos importados\n3. **Deteccin de Ciclos**: Verificar si el mdulo ya est siendo cargado\n4. **Cach**: Almacenar mdulo en cach por ruta absoluta\n5. **Fase de Ejecucin**: Ejecutar en orden topolgico (dependencias primero)\n\n### API\n\n```c\n// API de alto nivel\nint execute_file_with_modules(const char *file_path,\n                               int argc, char **argv,\n                               ExecutionContext *ctx);\n\n// API de bajo nivel\nModuleCache* module_cache_new(const char *initial_dir);\nvoid module_cache_free(ModuleCache *cache);\nModule* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);\nvoid execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);\n```\n\n## Pruebas\n\nLos mdulos de prueba estn ubicados en `tests/modules/` y `tests/parity/modules/`:\n\n- `math.hml` - Mdulo bsico con exportaciones\n- `test_import_named.hml` - Prueba de importacin con nombre\n- `test_import_namespace.hml` - Prueba de importacin de espacio de nombres\n- `test_import_alias.hml` - Prueba de alias de importacin\n- `export_extern.hml` - Prueba de exportacin de funcin FFI extern (Linux)\n\n## Importaciones de Paquetes (hpm)\n\nCon [hpm](https://github.com/hemlang/hpm) instalado, puede importar paquetes de terceros desde GitHub:\n\n```hemlock\n// Importar desde la raz del paquete (usa \"main\" de package.json)\nimport { app, router } from \"hemlang/sprout\";\n\n// Importar desde subruta\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// Biblioteca estndar (incorporada en Hemlock)\nimport { HashMap } from \"@stdlib/collections\";\n```\n\nLos paquetes se instalan en `hem_modules/` y se resuelven usando la sintaxis `owner/repo` de GitHub.\n\n```bash\n# Instalar un paquete\nhpm install hemlang/sprout\n\n# Instalar con restriccin de versin\nhpm install hemlang/sprout@^1.0.0\n```\n\nConsulte la [documentacin de hpm](https://github.com/hemlang/hpm) para detalles completos.\n\n## Limitaciones Actuales\n\n1. **Sin Importaciones Dinmicas**: `import()` como funcin en tiempo de ejecucin no est soportado\n2. **Sin Exportaciones Condicionales**: Las exportaciones deben estar en el nivel superior\n3. **Rutas de Biblioteca Estticas**: Las importaciones de bibliotecas FFI usan rutas estticas (especficas de plataforma)\n\n## Trabajo Futuro\n\n- Importaciones dinmicas con funcin `import()`\n- Exportaciones condicionales\n- Metadatos de mdulo (`import.meta`)\n- Tree shaking y eliminacin de cdigo muerto\n\n## Ejemplos\n\nConsulte `tests/modules/` para ejemplos funcionales del sistema de mdulos.\n\nEstructura de mdulos de ejemplo:\n```\nproject/\n main.hml\n lib/\n    math.hml\n    string.hml\n    index.hml (mdulo barrel)\n utils/\n     helpers.hml\n```\n\nUso de ejemplo:\n```hemlock\n// lib/math.hml\nexport fn add(a, b) { return a + b; }\nexport fn multiply(a, b) { return a * b; }\n\n// lib/index.hml (barrel)\nexport { add, multiply } from \"./math.hml\";\n\n// main.hml\nimport { add } from \"./lib/index.hml\";\nprint(add(2, 3));  // 5\n```\n"}, "Gua del Lenguaje -> Objetos": {"id": "language-guide-objects", "content": "# Objetos\n\nHemlock implementa objetos estilo JavaScript con asignacion en heap, campos dinamicos, metodos y duck typing. Los objetos son estructuras de datos flexibles que combinan datos y comportamiento.\n\n## Resumen\n\n```hemlock\n// Objeto anonimo\nlet person = { name: \"Alice\", age: 30, city: \"NYC\" };\nprint(person.name);  // \"Alice\"\n\n// Objeto con metodos\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## Literales de Objeto\n\n### Sintaxis Basica\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n```\n\n**Sintaxis:**\n- Llaves `{}` encierran el objeto\n- Pares clave-valor separados por comas\n- Las claves son identificadores (no necesitan comillas)\n- Los valores pueden ser de cualquier tipo\n\n### Objetos Vacios\n\n```hemlock\nlet obj = {};  // Objeto vacio\n\n// Agregar campos despues\nobj.name = \"Alice\";\nobj.age = 30;\n```\n\n### Objetos Anidados\n\n```hemlock\nlet user = {\n    info: {\n        name: \"Bob\",\n        age: 25\n    },\n    active: true,\n    settings: {\n        theme: \"dark\",\n        notifications: true\n    }\n};\n\nprint(user.info.name);           // \"Bob\"\nprint(user.settings.theme);      // \"dark\"\n```\n\n### Tipos de Valor Mezclados\n\n```hemlock\nlet mixed = {\n    number: 42,\n    text: \"hello\",\n    flag: true,\n    data: null,\n    items: [1, 2, 3],\n    config: { x: 10, y: 20 }\n};\n```\n\n### Sintaxis de Propiedad Abreviada\n\nCuando el nombre de variable coincide con el nombre de propiedad, usa sintaxis abreviada:\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\nlet active = true;\n\n// Abreviado: { name } es equivalente a { name: name }\nlet person = { name, age, active };\n\nprint(person.name);   // \"Alice\"\nprint(person.age);    // 30\nprint(person.active); // true\n```\n\n**Mezclar abreviado con propiedades regulares:**\n```hemlock\nlet city = \"NYC\";\nlet obj = { name, age, city, role: \"admin\" };\n```\n\n### Operador Spread\n\nEl operador spread (`...`) copia todos los campos de un objeto a otro:\n\n```hemlock\nlet base = { x: 1, y: 2 };\nlet extended = { ...base, z: 3 };\n\nprint(extended.x);  // 1\nprint(extended.y);  // 2\nprint(extended.z);  // 3\n```\n\n**Sobrescribir valores con spread:**\n```hemlock\nlet defaults = { theme: \"light\", size: \"medium\", debug: false };\nlet custom = { ...defaults, theme: \"dark\" };\n\nprint(custom.theme);  // \"dark\" (sobrescrito)\nprint(custom.size);   // \"medium\" (de defaults)\nprint(custom.debug);  // false (de defaults)\n```\n\n**Multiples spreads (los posteriores sobrescriben a los anteriores):**\n```hemlock\nlet a = { x: 1 };\nlet b = { y: 2 };\nlet merged = { ...a, ...b, z: 3 };\n\nprint(merged.x);  // 1\nprint(merged.y);  // 2\nprint(merged.z);  // 3\n\n// El spread posterior sobrescribe al anterior\nlet first = { val: \"first\" };\nlet second = { val: \"second\" };\nlet combined = { ...first, ...second };\nprint(combined.val);  // \"second\"\n```\n\n**Combinar abreviado y spread:**\n```hemlock\nlet status = \"active\";\nlet data = { id: 1, name: \"Item\" };\nlet full = { ...data, status };\n\nprint(full.id);      // 1\nprint(full.name);    // \"Item\"\nprint(full.status);  // \"active\"\n```\n\n**Patron de sobrescritura de configuracion:**\n```hemlock\nlet defaultConfig = {\n    debug: false,\n    timeout: 30,\n    retries: 3\n};\n\nlet prodConfig = { ...defaultConfig, timeout: 60 };\nlet devConfig = { ...defaultConfig, debug: true };\n\nprint(prodConfig.timeout);  // 60\nprint(devConfig.debug);     // true\n```\n\n**Nota:** Spread realiza una copia superficial. Los objetos anidados comparten referencias:\n```hemlock\nlet nested = { inner: { val: 42 } };\nlet copied = { ...nested };\nprint(copied.inner.val);  // 42 (misma referencia que nested.inner)\n```\n\n## Acceso a Campos\n\n### Notacion de Punto\n\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\n\n// Leer campo\nlet name = person.name;      // \"Alice\"\nlet age = person.age;        // 30\n\n// Modificar campo\nperson.age = 31;\nprint(person.age);           // 31\n```\n\n### Adicion Dinamica de Campos\n\nAgregar nuevos campos en tiempo de ejecucion:\n\n```hemlock\nlet person = { name: \"Alice\" };\n\n// Agregar nuevo campo\nperson.email = \"alice@example.com\";\nperson.phone = \"555-1234\";\n\nprint(person.email);  // \"alice@example.com\"\n```\n\n### Eliminacion de Campos\n\n**Nota:** La eliminacion de campos no esta soportada actualmente. Establece a `null` en su lugar:\n\n```hemlock\nlet obj = { x: 10, y: 20 };\n\n// No se pueden eliminar campos (no soportado)\n// obj.x = undefined;  // No hay 'undefined' en Hemlock\n\n// Alternativa: Establecer a null\nobj.x = null;\n```\n\n## Metodos y `self`\n\n### Definiendo Metodos\n\nLos metodos son funciones almacenadas en campos de objeto:\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    decrement: fn() {\n        self.count = self.count - 1;\n    },\n    get: fn() {\n        return self.count;\n    }\n};\n```\n\n### La Palabra Clave `self`\n\nCuando una funcion se llama como metodo, `self` se vincula automaticamente al objeto:\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;  // self se refiere a counter\n    }\n};\n\ncounter.increment();  // self se vincula a counter\nprint(counter.count);  // 1\n```\n\n**Como funciona:**\n- Las llamadas a metodos se detectan verificando si la expresion de funcion es acceso a propiedad\n- `self` se vincula automaticamente al objeto en el momento de la llamada\n- `self` es de solo lectura (no se puede reasignar `self` en si)\n\n### Deteccion de Llamada a Metodo\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() {\n        return self.value;\n    }\n};\n\n// Llamado como metodo - self se vincula\nprint(obj.method());  // 10\n\n// Llamado como funcion - self es null (error)\nlet f = obj.method;\nprint(f());  // ERROR: self no esta definido\n```\n\n### Metodos con Parametros\n\n```hemlock\nlet calculator = {\n    result: 0,\n    add: fn(x) {\n        self.result = self.result + x;\n    },\n    multiply: fn(x) {\n        self.result = self.result * x;\n    },\n    get: fn() {\n        return self.result;\n    }\n};\n\ncalculator.add(5);\ncalculator.multiply(2);\nprint(calculator.get());  // 10\n```\n\n## Definiciones de Tipo con `define`\n\n### Definicion de Tipo Basica\n\nDefine formas de objeto con `define`:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active: bool,\n}\n\n// Crear objeto y asignar a variable tipada\nlet p = { name: \"Alice\", age: 30, active: true };\nlet typed_p: Person = p;  // Duck typing valida la estructura\n\nprint(typeof(typed_p));  // \"Person\"\n```\n\n**Que hace `define`:**\n- Declara un tipo con campos requeridos\n- Habilita validacion por duck typing\n- Establece el nombre de tipo del objeto para `typeof()`\n\n### Duck Typing\n\nLos objetos se validan contra `define` usando **compatibilidad estructural**:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK: Tiene todos los campos requeridos\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK: Campos extra estan permitidos\nlet p2: Person = {\n    name: \"Bob\",\n    age: 25,\n    city: \"NYC\",\n    active: true\n};\n\n// ERROR: Falta campo requerido 'age'\nlet p3: Person = { name: \"Carol\" };\n\n// ERROR: Tipo incorrecto para 'age'\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```\n\n**Reglas de duck typing:**\n- Todos los campos requeridos deben estar presentes\n- Los tipos de campo deben coincidir\n- Los campos extra estan permitidos y se preservan\n- La validacion ocurre en el momento de la asignacion\n\n### Campos Opcionales\n\nLos campos pueden ser opcionales con valores por defecto:\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,       // Opcional con valor por defecto\n    nickname?: string,   // Opcional, por defecto null\n}\n\n// Objeto con solo campos requeridos\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.active);    // true (por defecto aplicado)\nprint(typed_p.nickname);  // null (sin por defecto)\n\n// Puede sobrescribir campos opcionales\nlet p2: Person = { name: \"Bob\", age: 25, active: false };\nprint(p2.active);  // false (sobrescrito)\n```\n\n**Sintaxis de campo opcional:**\n- `field?: default_value` - Opcional con valor por defecto\n- `field?: type` - Opcional con anotacion de tipo, por defecto null\n- Los campos opcionales se agregan durante duck typing si faltan\n\n### Verificacion de Tipos\n\n```hemlock\ndefine Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = { x: 10, y: 20 };\nlet point: Point = p;  // Verificacion de tipo ocurre aqui\n\nprint(typeof(point));  // \"Point\"\nprint(typeof(p));      // \"object\" (el original sigue siendo anonimo)\n```\n\n**Cuando ocurre la verificacion de tipo:**\n- En el momento de asignacion a variable tipada\n- Valida que todos los campos requeridos esten presentes\n- Valida que los tipos de campo coincidan (con conversiones implicitas)\n- Establece el nombre de tipo del objeto\n\n## Firmas de Metodo en Define\n\nLos bloques define pueden especificar firmas de metodo, creando contratos tipo interfaz:\n\n### Metodos Requeridos\n\n```hemlock\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32;  // Firma de metodo requerida\n}\n\n// Los objetos deben proporcionar el metodo requerido\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n```\n\n### Metodos Opcionales\n\n```hemlock\ndefine Serializable {\n    fn serialize(): string;       // Requerido\n    fn pretty?(): string;         // Metodo opcional (puede estar ausente)\n}\n```\n\n### El Tipo `Self`\n\n`Self` se refiere al tipo que se esta definiendo, habilitando definiciones de tipo recursivas:\n\n```hemlock\ndefine Cloneable {\n    fn clone(): Self;  // Retorna el mismo tipo que el objeto\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;  // Toma el mismo tipo como parametro\n    fn equals(other: Self): bool;\n}\n\nlet item: Cloneable = {\n    value: 42,\n    clone: fn() {\n        return { value: self.value, clone: self.clone };\n    }\n};\n```\n\n### Campos y Metodos Mezclados\n\n```hemlock\ndefine Entity {\n    id: i32,\n    name: string,\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\nlet user: Entity = {\n    id: 1,\n    name: \"Alice\",\n    validate: fn() { return self.id > 0 && self.name != \"\"; },\n    serialize: fn() { return '{\"id\":' + self.id + ',\"name\":\"' + self.name + '\"}'; }\n};\n```\n\n## Tipos Compuestos (Tipos de Interseccion)\n\nLos tipos compuestos usan `&` para requerir que un objeto satisfaga multiples definiciones de tipo:\n\n### Tipos Compuestos Basicos\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\n// Tipo compuesto: el objeto debe satisfacer TODOS los tipos\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n```\n\n### Parametros de Funcion con Tipos Compuestos\n\n```hemlock\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" is \" + p.age);\n}\n\ngreet({ name: \"Bob\", age: 25, city: \"NYC\" });  // Campos extra OK\n```\n\n### Tres o Mas Tipos\n\n```hemlock\ndefine HasEmail { email: string }\n\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n### Alias de Tipo para Tipos Compuestos\n\n```hemlock\n// Crear un alias nombrado para un tipo compuesto\ntype Person = HasName & HasAge;\ntype Employee = HasName & HasAge & HasEmail;\n\nlet emp: Employee = {\n    name: \"Charlie\",\n    age: 35,\n    email: \"charlie@example.com\"\n};\n```\n\n**Duck typing con compuestos:** Los campos extra siempre estan permitidos - el objeto solo necesita tener al menos los campos requeridos por todos los tipos componentes.\n\n## Serializacion JSON\n\n### Serializar a JSON\n\nConvertir objetos a cadenas JSON:\n\n```hemlock\n// obj.serialize() - Convertir objeto a cadena JSON\nlet obj = { x: 10, y: 20, name: \"test\" };\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// Objetos anidados\nlet nested = { inner: { a: 1, b: 2 }, outer: 3 };\nprint(nested.serialize());  // {\"inner\":{\"a\":1,\"b\":2},\"outer\":3}\n```\n\n### Deserializar desde JSON\n\nAnalizar cadenas JSON de vuelta a objetos:\n\n```hemlock\n// json.deserialize() - Analizar cadena JSON a objeto\nlet json_str = '{\"x\":10,\"y\":20,\"name\":\"test\"}';\nlet obj = json_str.deserialize();\n\nprint(obj.name);   // \"test\"\nprint(obj.x);      // 10\n```\n\n### Deteccion de Ciclos\n\nLas referencias circulares se detectan y causan errores:\n\n```hemlock\nlet obj = { x: 10 };\nobj.me = obj;  // Crear referencia circular\n\nobj.serialize();  // ERROR: serialize() detecto referencia circular\n```\n\n### Tipos Soportados\n\nLa serializacion JSON soporta:\n\n- **Numeros**: i8-i32, u8-u32, f32, f64\n- **Booleanos**: true, false\n- **Cadenas**: Con secuencias de escape\n- **Null**: valor null\n- **Objetos**: Objetos anidados\n- **Arrays**: Arrays anidados\n\n**No soportado:**\n- Funciones (omitidas silenciosamente)\n- Punteros (error)\n- Buffers (error)\n\n### Manejo de Errores\n\nLa serializacion y deserializacion pueden lanzar errores:\n\n```hemlock\n// JSON invalido lanza un error\ntry {\n    let bad = \"not valid json\".deserialize();\n} catch (e) {\n    print(\"Parse error:\", e);\n}\n\n// Los punteros no se pueden serializar\nlet obj = { ptr: alloc(10) };\ntry {\n    obj.serialize();\n} catch (e) {\n    print(\"Serialize error:\", e);\n}\n```\n\n### Ejemplo de Ida y Vuelta\n\nEjemplo completo de serializar y deserializar:\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug: bool\n}\n\n// Crear y serializar\nlet config: Config = {\n    host: \"localhost\",\n    port: 8080,\n    debug: true\n};\nlet json = config.serialize();\nprint(json);  // {\"host\":\"localhost\",\"port\":8080,\"debug\":true}\n\n// Deserializar de vuelta\nlet restored = json.deserialize();\nprint(restored.host);  // \"localhost\"\nprint(restored.port);  // 8080\n```\n\n## Funciones Integradas\n\n### `typeof(value)`\n\nRetorna el nombre del tipo como cadena:\n\n```hemlock\nlet obj = { x: 10 };\nprint(typeof(obj));  // \"object\"\n\ndefine Person { name: string, age: i32 }\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(typeof(p));    // \"Person\"\n```\n\n**Valores de retorno:**\n- Objetos anonimos: `\"object\"`\n- Objetos tipados: Nombre de tipo personalizado (ej., `\"Person\"`)\n\n## Detalles de Implementacion\n\n### Modelo de Memoria\n\n- **Asignado en heap** - Todos los objetos se asignan en el heap\n- **Copia superficial** - La asignacion copia la referencia, no el objeto\n- **Campos dinamicos** - Almacenados como arrays dinamicos de pares nombre/valor\n- **Conteo de referencias** - Los objetos se liberan automaticamente cuando el alcance termina\n\n### Semantica de Referencia\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Copia superficial (misma referencia)\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (ambos refieren al mismo objeto)\n```\n\n### Almacenamiento de Metodos\n\nLos metodos son simplemente funciones almacenadas en campos:\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// method es una funcion almacenada en obj.method\nprint(typeof(obj.method));  // \"function\"\n```\n\n## Patrones Comunes\n\n### Patron: Funcion Constructora\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```\n\n### Patron: Constructor de Objetos\n\n```hemlock\nfn PersonBuilder() {\n    return {\n        name: null,\n        age: null,\n\n        setName: fn(n) {\n            self.name = n;\n            return self;  // Habilitar encadenamiento\n        },\n\n        setAge: fn(a) {\n            self.age = a;\n            return self;\n        },\n\n        build: fn() {\n            return { name: self.name, age: self.age };\n        }\n    };\n}\n\nlet person = PersonBuilder()\n    .setName(\"Alice\")\n    .setAge(30)\n    .build();\n```\n\n### Patron: Objeto de Estado\n\n```hemlock\nlet state = {\n    status: \"idle\",\n    data: null,\n    error: null,\n\n    setState: fn(new_status) {\n        self.status = new_status;\n    },\n\n    setData: fn(new_data) {\n        self.data = new_data;\n        self.status = \"success\";\n    },\n\n    setError: fn(err) {\n        self.error = err;\n        self.status = \"error\";\n    }\n};\n```\n\n### Patron: Objeto de Configuracion\n\n```hemlock\nlet config = {\n    defaults: {\n        timeout: 30,\n        retries: 3,\n        debug: false\n    },\n\n    get: fn(key) {\n        if (self.defaults[key] != null) {\n            return self.defaults[key];\n        }\n        return null;\n    },\n\n    set: fn(key, value) {\n        self.defaults[key] = value;\n    }\n};\n```\n\n## Mejores Practicas\n\n1. **Usar `define` para estructura** - Documentar formas esperadas de objetos\n2. **Preferir funciones fabrica** - Crear objetos con constructores\n3. **Mantener objetos simples** - No anidar demasiado profundamente\n4. **Documentar uso de `self`** - Hacer claro el comportamiento de metodos\n5. **Validar en asignacion** - Usar duck typing para detectar errores temprano\n6. **Evitar referencias circulares** - Causaran errores de serializacion\n7. **Usar campos opcionales** - Proporcionar valores por defecto sensatos\n\n## Errores Comunes\n\n### Error: Referencia vs. Valor\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // Copia superficial\n\nobj2.x = 20;\nprint(obj1.x);  // 20 (sorpresa! ambos cambiaron)\n\n// Para evitar: Crear nuevo objeto\nlet obj3 = { x: obj1.x };  // Copia profunda (manual)\n```\n\n### Error: `self` en Llamadas No-Metodo\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// Funciona: Llamado como metodo\nprint(obj.method());  // 10\n\n// ERROR: Llamado como funcion\nlet f = obj.method;\nprint(f());  // ERROR: self no esta definido\n```\n\n### Error: Punteros Crudos en Objetos\n\n```hemlock\n// Los objetos se liberan automaticamente, pero los punteros crudos dentro NO\nfn create_objects() {\n    let obj = { data: alloc(1000) };  // ptr crudo necesita free manual\n    // obj se libera automaticamente cuando el alcance termina, pero obj.data tiene fuga!\n}\n\n// Solucion: Liberar punteros crudos antes de que termine el alcance\nfn safe_create() {\n    let obj = { data: alloc(1000) };\n    // ... usar obj.data ...\n    free(obj.data);  // Liberar el puntero crudo explicitamente\n}  // obj en si se libera automaticamente\n```\n\n### Error: Confusion de Tipos\n\n```hemlock\nlet obj = { x: 10 };\n\ndefine Point { x: i32, y: i32 }\n\n// ERROR: Falta campo requerido 'y'\nlet p: Point = obj;\n```\n\n## Ejemplos\n\n### Ejemplo: Matematica Vectorial\n\n```hemlock\nfn createVector(x, y) {\n    return {\n        x: x,\n        y: y,\n\n        add: fn(other) {\n            return createVector(\n                self.x + other.x,\n                self.y + other.y\n            );\n        },\n\n        length: fn() {\n            return sqrt(self.x * self.x + self.y * self.y);\n        },\n\n        toString: fn() {\n            return \"(\" + typeof(self.x) + \", \" + typeof(self.y) + \")\";\n        }\n    };\n}\n\nlet v1 = createVector(3, 4);\nlet v2 = createVector(1, 2);\nlet v3 = v1.add(v2);\n\nprint(v3.toString());  // \"(4, 6)\"\n```\n\n### Ejemplo: Base de Datos Simple\n\n```hemlock\nfn createDatabase() {\n    let records = [];\n    let next_id = 1;\n\n    return {\n        insert: fn(data) {\n            let record = { id: next_id, data: data };\n            records.push(record);\n            next_id = next_id + 1;\n            return record.id;\n        },\n\n        find: fn(id) {\n            let i = 0;\n            while (i < records.length) {\n                if (records[i].id == id) {\n                    return records[i];\n                }\n                i = i + 1;\n            }\n            return null;\n        },\n\n        count: fn() {\n            return records.length;\n        }\n    };\n}\n\nlet db = createDatabase();\nlet id = db.insert({ name: \"Alice\", age: 30 });\nlet record = db.find(id);\nprint(record.data.name);  // \"Alice\"\n```\n\n### Ejemplo: Emisor de Eventos\n\n```hemlock\nfn createEventEmitter() {\n    let listeners = {};\n\n    return {\n        on: fn(event, handler) {\n            if (listeners[event] == null) {\n                listeners[event] = [];\n            }\n            listeners[event].push(handler);\n        },\n\n        emit: fn(event, data) {\n            if (listeners[event] != null) {\n                let i = 0;\n                while (i < listeners[event].length) {\n                    listeners[event][i](data);\n                    i = i + 1;\n                }\n            }\n        }\n    };\n}\n\nlet emitter = createEventEmitter();\n\nemitter.on(\"message\", fn(data) {\n    print(\"Received: \" + data);\n});\n\nemitter.emit(\"message\", \"Hello!\");\n```\n\n## Limitaciones\n\nLimitaciones actuales:\n\n- **Sin copia profunda** - Debe copiar manualmente objetos anidados (spread es superficial)\n- **Sin paso por valor** - Los objetos siempre se pasan por referencia\n- **Sin propiedades computadas** - Sin sintaxis `{[key]: value}`\n- **`self` es de solo lectura** - No se puede reasignar `self` en metodos\n- **Sin eliminacion de propiedades** - No se pueden remover campos una vez agregados\n\n**Nota:** Los objetos tienen conteo de referencias y se liberan automaticamente cuando el alcance termina. Ver [Gestion de Memoria](memory.md#conteo-de-referencias-interno) para detalles.\n\n## Temas Relacionados\n\n- [Functions](#language-guide-functions) - Los metodos son funciones almacenadas en objetos\n- [Arrays](#language-guide-arrays) - Los arrays tambien son tipo objeto\n- [Types](#language-guide-types) - Duck typing y definiciones de tipo\n- [Error Handling](#language-guide-error-handling) - Lanzar objetos de error\n\n## Ver Tambien\n\n- **Duck Typing**: Ver seccion \"Objects\" en CLAUDE.md para detalles de duck typing\n- **JSON**: Ver CLAUDE.md para detalles de serializacion JSON\n- **Memoria**: Ver [Memory](#language-guide-memory) para asignacion de objetos\n"}, "Gua del Lenguaje -> Runas": {"id": "language-guide-runes", "content": "# Runes\n\nLos runes representan **puntos de cdigo Unicode** (U+0000 a U+10FFFF) como un tipo distinto para manipulacin de caracteres en Hemlock. A diferencia de los bytes (u8), los runes son caracteres Unicode completos que pueden representar cualquier caracter en cualquier idioma o emoji.\n\n## Resumen\n\n```hemlock\nlet ch = 'A';           // Literal rune\nlet emoji = '';       // Caracter multi-byte como rune nico\nprint(ch);              // 'A'\nprint(emoji);           // U+1F680\n\nlet s = \"Hello \" + '!'; // Concatenacin string + rune\nlet r = '>' + \" msg\";   // Concatenacin rune + string\n```\n\n## Qu es un Rune?\n\nUn rune es un **valor de 32 bits** que representa un punto de cdigo Unicode:\n\n- **Rango:** 0 a 0x10FFFF (1,114,111 puntos de cdigo vlidos)\n- **No es un tipo numrico** - Usado para representacin de caracteres\n- **Distinto de u8/char** - Los runes son Unicode completo, u8 es solo bytes\n- **Retornado por indexacin de strings** - `str[0]` retorna un rune, no un byte\n\n**Por qu runes?**\n- Los strings de Hemlock estn codificados en UTF-8\n- Un solo caracter Unicode puede ser 1-4 bytes en UTF-8\n- Los runes permiten trabajar con caracteres completos, no bytes parciales\n\n## Literales Rune\n\n### Sintaxis Bsica\n\nLas comillas simples denotan literales rune:\n\n```hemlock\nlet a = 'A';            // Caracter ASCII\nlet b = '0';            // Caracter dgito\nlet c = '!';            // Puntuacin\nlet d = ' ';            // Espacio\n```\n\n### Caracteres UTF-8 Multi-byte\n\nLos runes pueden representar cualquier caracter Unicode:\n\n```hemlock\n// Emoji\nlet rocket = '';      // Emoji (U+1F680)\nlet heart = '';        // Corazn (U+2764)\nlet smile = '';       // Cara sonriente (U+1F600)\n\n// Caracteres CJK\nlet chinese = '';     // Chino (U+4E2D)\nlet japanese = '';    // Hiragana (U+3042)\nlet korean = '';      // Hangul (U+D55C)\n\n// Smbolos\nlet check = '';        // Marca de verificacin (U+2713)\nlet arrow = '';        // Flecha derecha (U+2192)\n```\n\n### Secuencias de Escape\n\nSecuencias de escape comunes para caracteres especiales:\n\n```hemlock\nlet newline = '\\n';     // Nueva lnea (U+000A)\nlet tab = '\\t';         // Tabulacin (U+0009)\nlet backslash = '\\\\';   // Barra invertida (U+005C)\nlet quote = '\\'';       // Comilla simple (U+0027)\nlet dquote = '\"';       // Comilla doble (U+0022)\nlet null_char = '\\0';   // Caracter nulo (U+0000)\nlet cr = '\\r';          // Retorno de carro (U+000D)\n```\n\n**Secuencias de escape disponibles:**\n- `\\n` - Nueva lnea (line feed)\n- `\\t` - Tabulacin horizontal\n- `\\r` - Retorno de carro\n- `\\0` - Caracter nulo\n- `\\\\` - Barra invertida\n- `\\'` - Comilla simple\n- `\\\"` - Comilla doble\n\n### Escapes Unicode\n\nUse la sintaxis `\\u{XXXXXX}` para puntos de cdigo Unicode (hasta 6 dgitos hexadecimales):\n\n```hemlock\nlet rocket = '\\u{1F680}';   //  Emoji va escape Unicode\nlet heart = '\\u{2764}';     //  Corazn\nlet ascii = '\\u{41}';       // 'A' va escape\nlet max = '\\u{10FFFF}';     // Punto de cdigo Unicode mximo\n\n// Ceros iniciales opcionales\nlet a = '\\u{41}';           // Igual que '\\u{0041}'\nlet b = '\\u{0041}';\n```\n\n**Reglas:**\n- Rango: `\\u{0}` a `\\u{10FFFF}`\n- Dgitos hexadecimales: 1 a 6 dgitos\n- Insensible a maysculas: `\\u{1F680}` o `\\u{1f680}`\n- Valores fuera del rango Unicode vlido causan error\n\n## Concatenacin String + Rune\n\nLos runes pueden concatenarse con strings:\n\n```hemlock\n// String + rune\nlet greeting = \"Hello\" + '!';       // \"Hello!\"\nlet decorated = \"Text\" + '';       // \"Text\"\n\n// Rune + string\nlet prefix = '>' + \" Message\";      // \"> Message\"\nlet bullet = '' + \" Item\";         // \" Item\"\n\n// Mltiples concatenaciones\nlet msg = \"Hi \" + '' + \" World \" + '';  // \"Hi  World \"\n\n// El encadenamiento de mtodos funciona\nlet result = ('>' + \" Important\").to_upper();  // \"> IMPORTANT\"\n```\n\n**Cmo funciona:**\n- Los runes se codifican automticamente a UTF-8\n- Se convierten a strings durante la concatenacin\n- El operador de concatenacin de strings maneja esto transparentemente\n\n## Conversiones de Tipo\n\nLos runes pueden convertirse hacia/desde otros tipos.\n\n### Entero  Rune\n\nConvertir entre enteros y runes para trabajar con valores de puntos de cdigo:\n\n```hemlock\n// Entero a rune (valor de punto de cdigo)\nlet code: rune = 65;            // 'A' (ASCII 65)\nlet emoji_code: rune = 128640;  // U+1F680 ()\n\n// Rune a entero (obtener valor de punto de cdigo)\nlet r = 'Z';\nlet value: i32 = r;             // 90 (valor ASCII)\n\nlet rocket = '';\nlet code: i32 = rocket;         // 128640 (U+1F680)\n```\n\n**Verificacin de rango:**\n- Entero a rune: Debe estar en [0, 0x10FFFF]\n- Valores fuera de rango causan error en tiempo de ejecucin\n- Rune a entero: Siempre tiene xito (retorna punto de cdigo)\n\n### Rune  String\n\nLos runes pueden convertirse explcitamente a strings:\n\n```hemlock\n// Conversin explcita\nlet ch: string = 'H';           // \"H\"\nlet emoji: string = '';       // \"\"\n\n// Automtico durante concatenacin\nlet s = \"\" + 'A';               // \"A\"\nlet s2 = \"x\" + 'y' + \"z\";       // \"xyz\"\n```\n\n### u8 (Byte)  Rune\n\nCualquier valor u8 (0-255) puede convertirse a rune:\n\n```hemlock\n// Rango ASCII (0-127)\nlet byte: u8 = 65;\nlet rune_val: rune = byte;      // 'A'\n\n// ASCII extendido / Latin-1 (128-255)\nlet extended: u8 = 200;\nlet r: rune = extended;         // U+00C8 ()\n\n// Nota: Valores 0-127 son ASCII, 128-255 son Latin-1\n```\n\n### Conversiones Encadenadas\n\nLas conversiones de tipo pueden encadenarse:\n\n```hemlock\n// i32  rune  string\nlet code: i32 = 128512;         // Punto de cdigo de cara sonriente\nlet r: rune = code;             // \nlet s: string = r;              // \"\"\n\n// Todo en una expresin\nlet emoji: string = 128640;     // Implcito i32  rune  string ()\n```\n\n## Operaciones con Runes\n\n### Impresin\n\nCmo se muestran los runes depende del punto de cdigo:\n\n```hemlock\nlet ascii = 'A';\nprint(ascii);                   // 'A' (entre comillas, ASCII imprimible)\n\nlet emoji = '';\nprint(emoji);                   // U+1F680 (notacin Unicode para no-ASCII)\n\nlet tab = '\\t';\nprint(tab);                     // U+0009 (no imprimible como hex)\n\nlet space = ' ';\nprint(space);                   // ' ' (imprimible)\n```\n\n**Formato de impresin:**\n- ASCII imprimible (32-126): Caracter entre comillas `'A'`\n- No imprimible o Unicode: Notacin hexadecimal `U+XXXX`\n\n### Verificacin de Tipo\n\nUse `typeof()` para verificar si un valor es un rune:\n\n```hemlock\nlet r = '';\nprint(typeof(r));               // \"rune\"\n\nlet s = \"text\";\nlet ch = s[0];\nprint(typeof(ch));              // \"rune\" (la indexacin retorna runes)\n\nlet num = 65;\nprint(typeof(num));             // \"i32\"\n```\n\n### Comparacin\n\nLos runes pueden compararse por igualdad:\n\n```hemlock\nlet a = 'A';\nlet b = 'B';\nprint(a == a);                  // true\nprint(a == b);                  // false\n\n// Sensible a maysculas\nlet upper = 'A';\nlet lower = 'a';\nprint(upper == lower);          // false\n\n// Los runes pueden compararse con enteros (valores de punto de cdigo)\nprint(a == 65);                 // true (conversin implcita)\nprint('' == 128640);          // true\n```\n\n**Operadores de comparacin:**\n- `==` - Igual\n- `!=` - No igual\n- `<`, `>`, `<=`, `>=` - Orden de punto de cdigo\n\n```hemlock\nprint('A' < 'B');               // true (65 < 66)\nprint('a' > 'Z');               // true (97 > 90)\n```\n\n## Trabajando con Indexacin de Strings\n\nLa indexacin de strings retorna runes, no bytes:\n\n```hemlock\nlet s = \"Hello\";\nlet h = s[0];                   // 'H' (rune)\nlet rocket = s[5];              // '' (rune)\n\nprint(typeof(h));               // \"rune\"\nprint(typeof(rocket));          // \"rune\"\n\n// Convertir a string si es necesario\nlet h_str: string = h;          // \"H\"\nlet rocket_str: string = rocket; // \"\"\n```\n\n**Importante:** La indexacin de strings usa posiciones de punto de cdigo, no offsets de bytes:\n\n```hemlock\nlet text = \"Hi!\";\n// Posiciones de punto de cdigo: 0='H', 1='i', 2='', 3='!'\n// Posiciones de byte:            0='H', 1='i', 2-5='', 6='!'\n\nlet r = text[2];                // '' (punto de cdigo 2)\nprint(typeof(r));               // \"rune\"\n```\n\n## Ejemplos\n\n### Ejemplo: Clasificacin de Caracteres\n\n```hemlock\nfn is_digit(r: rune): bool {\n    return r >= '0' && r <= '9';\n}\n\nfn is_upper(r: rune): bool {\n    return r >= 'A' && r <= 'Z';\n}\n\nfn is_lower(r: rune): bool {\n    return r >= 'a' && r <= 'z';\n}\n\nprint(is_digit('5'));           // true\nprint(is_upper('A'));           // true\nprint(is_lower('z'));           // true\n```\n\n### Ejemplo: Conversin de Maysculas/Minsculas\n\n```hemlock\nfn to_upper_rune(r: rune): rune {\n    if (r >= 'a' && r <= 'z') {\n        // Convertir a mayscula (restar 32)\n        let code: i32 = r;\n        code = code - 32;\n        return code;\n    }\n    return r;\n}\n\nfn to_lower_rune(r: rune): rune {\n    if (r >= 'A' && r <= 'Z') {\n        // Convertir a minscula (sumar 32)\n        let code: i32 = r;\n        code = code + 32;\n        return code;\n    }\n    return r;\n}\n\nprint(to_upper_rune('a'));      // 'A'\nprint(to_lower_rune('Z'));      // 'z'\n```\n\n### Ejemplo: Iteracin de Caracteres\n\n```hemlock\nfn print_chars(s: string) {\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        print(\"Position \" + typeof(i) + \": \" + typeof(ch));\n        i = i + 1;\n    }\n}\n\nprint_chars(\"Hi\");\n// Position 0: 'H'\n// Position 1: 'i'\n// Position 2: U+1F680\n```\n\n### Ejemplo: Construyendo Strings desde Runes\n\n```hemlock\nfn repeat_char(ch: rune, count: i32): string {\n    let result = \"\";\n    let i = 0;\n    while (i < count) {\n        result = result + ch;\n        i = i + 1;\n    }\n    return result;\n}\n\nlet line = repeat_char('=', 40);  // \"========================================\"\nlet stars = repeat_char('', 5);  // \"\"\n```\n\n## Patrones Comunes\n\n### Patrn: Filtro de Caracteres\n\n```hemlock\nfn filter_digits(s: string): string {\n    let result = \"\";\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        if (ch >= '0' && ch <= '9') {\n            result = result + ch;\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet text = \"abc123def456\";\nlet digits = filter_digits(text);  // \"123456\"\n```\n\n### Patrn: Conteo de Caracteres\n\n```hemlock\nfn count_char(s: string, target: rune): i32 {\n    let count = 0;\n    let i = 0;\n    while (i < s.length) {\n        if (s[i] == target) {\n            count = count + 1;\n        }\n        i = i + 1;\n    }\n    return count;\n}\n\nlet text = \"hello world\";\nlet l_count = count_char(text, 'l');  // 3\nlet o_count = count_char(text, 'o');  // 2\n```\n\n## Mejores Prcticas\n\n1. **Use runes para operaciones de caracteres** - No intente trabajar con bytes para texto\n2. **La indexacin de strings retorna runes** - Recuerde que `str[i]` le da un rune\n3. **Comparaciones conscientes de Unicode** - Los runes manejan cualquier caracter Unicode\n4. **Convierta cuando sea necesario** - Los runes se convierten fcilmente a strings y enteros\n5. **Pruebe con emoji** - Siempre pruebe operaciones de caracteres con caracteres multi-byte\n\n## Errores Comunes\n\n### Error: Confusin entre Rune y Byte\n\n```hemlock\n// NO: Tratar runes como bytes\nlet r: rune = '';\nlet b: u8 = r;              // ERROR: El punto de cdigo 128640 no cabe en u8\n\n// S: Usar conversiones apropiadas\nlet r: rune = '';\nlet code: i32 = r;          // OK: 128640\n```\n\n### Error: Indexacin de Bytes de String\n\n```hemlock\n// NO: Asumir indexacin de bytes\nlet s = \"\";\nlet byte = s.byte_at(0);    // 240 (primer byte UTF-8, no caracter completo)\n\n// S: Usar indexacin de punto de cdigo\nlet s = \"\";\nlet rune = s[0];            // '' (caracter completo)\nlet rune2 = s.char_at(0);   // '' (mtodo explcito)\n```\n\n## Temas Relacionados\n\n- [Strings](#language-guide-strings) - Operaciones de strings y manejo UTF-8\n- [Tipos](#language-guide-types) - Sistema de tipos y conversiones\n- [Flujo de Control](#language-guide-control-flow) - Usando runes en comparaciones\n\n## Ver Tambin\n\n- **Estndar Unicode**: Los puntos de cdigo Unicode son definidos por el Consorcio Unicode\n- **Codificacin UTF-8**: Consulte [Strings](#language-guide-strings) para detalles de UTF-8\n- **Conversiones de Tipo**: Consulte [Tipos](#language-guide-types) para reglas de conversin\n"}, "Gua del Lenguaje -> Sintaxis": {"id": "language-guide-syntax", "content": "# Resumen de Sintaxis\n\nEste documento cubre las reglas fundamentales de sintaxis y la estructura de los programas Hemlock.\n\n## Reglas Fundamentales de Sintaxis\n\n### Los Punto y Coma Son Obligatorios\n\nA diferencia de JavaScript o Python, los punto y coma son **siempre requeridos** al final de las sentencias:\n\n```hemlock\nlet x = 42;\nlet y = 10;\nprint(x + y);\n```\n\n**Esto causara un error:**\n```hemlock\nlet x = 42  // ERROR: Falta punto y coma\nlet y = 10  // ERROR: Falta punto y coma\n```\n\n### Las Llaves Son Siempre Requeridas\n\nTodos los bloques de flujo de control deben usar llaves, incluso para sentencias individuales:\n\n```hemlock\n// CORRECTO\nif (x > 0) {\n    print(\"positivo\");\n}\n\n// ERROR: Faltan llaves\nif (x > 0)\n    print(\"positivo\");\n```\n\n### Comentarios\n\n```hemlock\n// Este es un comentario de una linea\n\n/*\n   Este es un\n   comentario de multiples lineas\n*/\n\nlet x = 42;  // Comentario en linea\n```\n\n## Variables\n\n### Declaracion\n\nLas variables se declaran con `let`:\n\n```hemlock\nlet count = 0;\nlet name = \"Alice\";\nlet pi = 3.14159;\n```\n\n### Anotaciones de Tipo (Opcionales)\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet flag: bool = true;\nlet text: string = \"hello\";\n```\n\n### Constantes\n\nUsa `const` para valores inmutables:\n\n```hemlock\nconst MAX_SIZE: i32 = 1000;\nconst PI: f64 = 3.14159;\n```\n\nIntentar reasignar una constante resultara en un error de tiempo de ejecucion: \"Cannot assign to const variable\".\n\n## Expresiones\n\n### Operadores Aritmeticos\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13 - Suma\nprint(a - b);   // 7  - Resta\nprint(a * b);   // 30 - Multiplicacion\nprint(a / b);   // 3  - Division (entera)\n```\n\n### Operadores de Comparacion\n\n```hemlock\nprint(a == b);  // false - Igual\nprint(a != b);  // true  - No igual\nprint(a > b);   // true  - Mayor que\nprint(a < b);   // false - Menor que\nprint(a >= b);  // true  - Mayor o igual\nprint(a <= b);  // false - Menor o igual\n```\n\n### Operadores Logicos\n\n```hemlock\nlet x = true;\nlet y = false;\n\nprint(x && y);  // false - AND\nprint(x || y);  // true  - OR\nprint(!x);      // false - NOT\n```\n\n### Operadores de Bits\n\n```hemlock\nlet a = 12;  // 1100\nlet b = 10;  // 1010\n\nprint(a & b);   // 8  - AND de bits\nprint(a | b);   // 14 - OR de bits\nprint(a ^ b);   // 6  - XOR de bits\nprint(a << 2);  // 48 - Desplazamiento a la izquierda\nprint(a >> 1);  // 6  - Desplazamiento a la derecha\nprint(~a);      // -13 - NOT de bits\n```\n\n### Precedencia de Operadores\n\nDe mayor a menor:\n\n1. `()` - Agrupacion\n2. `!`, `~`, `-` (unario) - Operadores unarios\n3. `*`, `/` - Multiplicacion, Division\n4. `+`, `-` - Suma, Resta\n5. `<<`, `>>` - Desplazamientos de bits\n6. `<`, `<=`, `>`, `>=` - Comparaciones\n7. `==`, `!=` - Igualdad\n8. `&` - AND de bits\n9. `^` - XOR de bits\n10. `|` - OR de bits\n11. `&&` - AND logico\n12. `||` - OR logico\n\n**Ejemplos:**\n```hemlock\nlet x = 2 + 3 * 4;      // 14 (no 20)\nlet y = (2 + 3) * 4;    // 20\nlet z = 5 << 2 + 1;     // 40 (5 << 3)\n```\n\n## Flujo de Control\n\n### Sentencias If\n\n```hemlock\nif (condition) {\n    // cuerpo\n}\n\nif (condition) {\n    // rama then\n} else {\n    // rama else\n}\n\nif (condition1) {\n    // rama 1\n} else if (condition2) {\n    // rama 2\n} else {\n    // rama por defecto\n}\n```\n\n### Bucles While\n\n```hemlock\nwhile (condition) {\n    // cuerpo\n}\n```\n\n**Ejemplo:**\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n### Bucles For\n\n**For estilo C:**\n```hemlock\nfor (initializer; condition; increment) {\n    // cuerpo\n}\n```\n\n**Ejemplo:**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**For-in (arrays):**\n```hemlock\nfor (let item in array) {\n    // cuerpo\n}\n```\n\n**Ejemplo:**\n```hemlock\nlet items = [10, 20, 30];\nfor (let x in items) {\n    print(x);\n}\n```\n\n### Sentencias Switch\n\n```hemlock\nswitch (expression) {\n    case value1:\n        // cuerpo\n        break;\n    case value2:\n        // cuerpo\n        break;\n    default:\n        // cuerpo por defecto\n        break;\n}\n```\n\n**Ejemplo:**\n```hemlock\nlet day = 3;\nswitch (day) {\n    case 1:\n        print(\"Monday\");\n        break;\n    case 2:\n        print(\"Tuesday\");\n        break;\n    case 3:\n        print(\"Wednesday\");\n        break;\n    default:\n        print(\"Other\");\n        break;\n}\n```\n\n### Break y Continue\n\n```hemlock\n// Break: salir del bucle\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n}\n\n// Continue: saltar a la siguiente iteracion\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;\n    }\n    print(i);\n}\n```\n\n## Funciones\n\n### Funciones con Nombre\n\n```hemlock\nfn function_name(param1: type1, param2: type2): return_type {\n    // cuerpo\n    return value;\n}\n```\n\n**Ejemplo:**\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Funciones Anonimas\n\n```hemlock\nlet func = fn(params) {\n    // cuerpo\n};\n```\n\n**Ejemplo:**\n```hemlock\nlet multiply = fn(x, y) {\n    return x * y;\n};\n```\n\n### Anotaciones de Tipo (Opcionales)\n\n```hemlock\n// Sin anotaciones (tipos inferidos)\nfn greet(name) {\n    return \"Hello, \" + name;\n}\n\n// Con anotaciones (verificados en tiempo de ejecucion)\nfn divide(a: i32, b: i32): f64 {\n    return a / b;\n}\n```\n\n## Objetos\n\n### Literales de Objeto\n\n```hemlock\nlet obj = {\n    field1: value1,\n    field2: value2,\n};\n```\n\n**Ejemplo:**\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    active: true,\n};\n```\n\n### Metodos\n\n```hemlock\nlet obj = {\n    method: fn() {\n        self.field = value;\n    },\n};\n```\n\n**Ejemplo:**\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n};\n```\n\n### Definiciones de Tipo\n\n```hemlock\ndefine TypeName {\n    field1: type1,\n    field2: type2,\n    optional_field?: default_value,\n}\n```\n\n**Ejemplo:**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,\n}\n```\n\n## Arrays\n\n### Literales de Array\n\n```hemlock\nlet arr = [element1, element2, element3];\n```\n\n**Ejemplo:**\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];\nlet empty = [];\n```\n\n### Indexacion de Arrays\n\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);   // 10\narr[1] = 99;     // Modificar elemento\n```\n\n## Manejo de Errores\n\n### Try/Catch\n\n```hemlock\ntry {\n    // codigo riesgoso\n} catch (e) {\n    // manejar error\n}\n```\n\n### Try/Finally\n\n```hemlock\ntry {\n    // codigo riesgoso\n} finally {\n    // siempre se ejecuta\n}\n```\n\n### Try/Catch/Finally\n\n```hemlock\ntry {\n    // codigo riesgoso\n} catch (e) {\n    // manejar error\n} finally {\n    // limpieza\n}\n```\n\n### Throw\n\n```hemlock\nthrow expression;\n```\n\n**Ejemplo:**\n```hemlock\nif (x < 0) {\n    throw \"x must be positive\";\n}\n```\n\n### Panic\n\n```hemlock\npanic(message);\n```\n\n**Ejemplo:**\n```hemlock\npanic(\"unrecoverable error\");\n```\n\n## Modulos (Experimental)\n\n### Sentencias Export\n\n```hemlock\nexport fn function_name() { }\nexport const CONSTANT = value;\nexport let variable = value;\nexport { name1, name2 };\n```\n\n### Sentencias Import\n\n```hemlock\nimport { name1, name2 } from \"./module.hml\";\nimport * as namespace from \"./module.hml\";\nimport { name as alias } from \"./module.hml\";\n```\n\n## Async (Experimental)\n\n### Funciones Async\n\n```hemlock\nasync fn function_name(params): return_type {\n    // cuerpo\n}\n```\n\n### Spawn/Join\n\n```hemlock\nlet task = spawn(async_function, arg1, arg2);\nlet result = join(task);\n```\n\n### Canales\n\n```hemlock\nlet ch = channel(capacity);\nch.send(value);\nlet value = ch.recv();\nch.close();\n```\n\n## FFI (Interfaz de Funcion Foranea)\n\n### Importar Biblioteca Compartida\n\n```hemlock\nimport \"library_name.so\";\n```\n\n### Declarar Funcion Externa\n\n```hemlock\nextern fn function_name(param: type): return_type;\n```\n\n**Ejemplo:**\n```hemlock\nimport \"libc.so.6\";\nextern fn strlen(s: string): i32;\n```\n\n## Literales\n\n### Literales Enteros\n\n```hemlock\nlet decimal = 42;\nlet negative = -100;\nlet large = 5000000000;  // Auto i64\n\n// Hexadecimal (prefijo 0x)\nlet hex = 0xDEADBEEF;\nlet hex2 = 0xFF;\n\n// Binario (prefijo 0b)\nlet bin = 0b1010;\nlet bin2 = 0b11110000;\n\n// Octal (prefijo 0o)\nlet oct = 0o777;\nlet oct2 = 0O123;\n\n// Separadores numericos para legibilidad\nlet million = 1_000_000;\nlet hex_sep = 0xFF_FF_FF;\nlet bin_sep = 0b1111_0000_1010_0101;\nlet oct_sep = 0o77_77;\n```\n\n### Literales de Punto Flotante\n\n```hemlock\nlet f = 3.14;\nlet e = 2.71828;\nlet sci = 1.5e-10;       // Notacion cientifica\nlet sci2 = 2.5E+3;       // E mayuscula tambien funciona\nlet no_lead = .5;        // Sin cero inicial (0.5)\nlet sep = 3.14_159_265;  // Separadores numericos\n```\n\n### Literales de Cadena\n\n```hemlock\nlet s = \"hello\";\nlet escaped = \"line1\\nline2\\ttabbed\";\nlet quote = \"She said \\\"hello\\\"\";\n\n// Secuencias de escape hexadecimales\nlet hex_esc = \"\\x48\\x65\\x6c\\x6c\\x6f\";  // \"Hello\"\n\n// Secuencias de escape Unicode\nlet emoji = \"\\u{1F600}\";               // grinning face\nlet heart = \"\\u{2764}\";                // heart\nlet mixed = \"Hello \\u{1F30D}!\";        // Hello earth!\n```\n\n**Secuencias de escape:**\n- `\\n` - nueva linea\n- `\\t` - tabulador\n- `\\r` - retorno de carro\n- `\\\\` - barra invertida\n- `\\\"` - comilla doble\n- `\\'` - comilla simple\n- `\\0` - caracter nulo\n- `\\xNN` - escape hexadecimal (2 digitos)\n- `\\u{XXXX}` - escape unicode (1-6 digitos)\n\n### Literales Rune\n\n```hemlock\nlet ch = 'A';\nlet emoji = 'rocket';\nlet escaped = '\\n';\nlet unicode = '\\u{1F680}';\nlet hex_rune = '\\x41';      // 'A'\n```\n\n### Literales Booleanos\n\n```hemlock\nlet t = true;\nlet f = false;\n```\n\n### Literal Null\n\n```hemlock\nlet nothing = null;\n```\n\n## Reglas de Alcance\n\n### Alcance de Bloque\n\nLas variables tienen alcance en el bloque mas cercano:\n\n```hemlock\nlet x = 1;  // Alcance externo\n\nif (true) {\n    let x = 2;  // Alcance interno (oculta el externo)\n    print(x);   // 2\n}\n\nprint(x);  // 1\n```\n\n### Alcance de Funcion\n\nLas funciones crean su propio alcance:\n\n```hemlock\nlet global = \"global\";\n\nfn foo() {\n    let local = \"local\";\n    print(global);  // Puede leer alcance externo\n}\n\nfoo();\n// print(local);  // ERROR: 'local' no definido aqui\n```\n\n### Alcance de Clausura\n\nLas clausuras capturan variables del alcance que las contiene:\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // Captura 'count'\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\n```\n\n## Espacios en Blanco y Formato\n\n### Indentacion\n\nHemlock no impone una indentacion especifica, pero se recomiendan 4 espacios:\n\n```hemlock\nfn example() {\n    if (true) {\n        print(\"indented\");\n    }\n}\n```\n\n### Saltos de Linea\n\nLas sentencias pueden abarcar multiples lineas:\n\n```hemlock\nlet result =\n    very_long_function_name(\n        arg1,\n        arg2,\n        arg3\n    );\n```\n\n## Sentencia Loop\n\nLa palabra clave `loop` proporciona una sintaxis mas limpia para bucles infinitos:\n\n```hemlock\nloop {\n    // ... hacer trabajo\n    if (done) {\n        break;\n    }\n}\n```\n\nEsto es equivalente a `while (true)` pero hace la intencion mas clara.\n\n## Palabras Clave Reservadas\n\nLas siguientes palabras clave estan reservadas en Hemlock:\n\n```\nlet, const, fn, if, else, while, for, in, loop, break, continue,\nreturn, true, false, null, typeof, import, export, from,\ntry, catch, finally, throw, panic, async, await, spawn, join,\ndetach, channel, define, switch, case, default, extern, self,\ntype, defer, enum, ref, buffer, Self\n```\n\n## Siguientes Pasos\n\n- [Sistema de Tipos](#language-guide-types) - Aprende sobre el sistema de tipos de Hemlock\n- [Flujo de Control](#language-guide-control-flow) - Profundiza en las estructuras de control\n- [Funciones](#language-guide-functions) - Domina funciones y clausuras\n- [Gestion de Memoria](#language-guide-memory) - Entiende punteros y buffers\n"}, "Gua del Lenguaje -> Tipos": {"id": "language-guide-types", "content": "# Sistema de Tipos\n\nHemlock presenta un **sistema de tipos dinamico** con anotaciones de tipo opcionales y verificacion de tipos en tiempo de ejecucion.\n\n---\n\n## Guia de Seleccion de Tipos: Que Tipo Debo Usar?\n\n**Nuevo en tipos?** Comienza aqui. Si estas familiarizado con sistemas de tipos, salta a [Filosofia](#filosofia).\n\n### La Respuesta Corta\n\n**Simplemente deja que Hemlock lo descubra:**\n\n```hemlock\nlet count = 42;        // Hemlock sabe que esto es un entero\nlet price = 19.99;     // Hemlock sabe que esto es un decimal\nlet name = \"Alice\";    // Hemlock sabe que esto es texto\nlet active = true;     // Hemlock sabe que esto es si/no\n```\n\nHemlock automaticamente elige el tipo correcto para tus valores. No *necesitas* especificar tipos.\n\n### Cuando Agregar Anotaciones de Tipo\n\nAgrega tipos cuando quieras:\n\n1. **Ser especifico sobre el tamano** - `i8` vs `i64` importa para memoria o FFI\n2. **Documentar tu codigo** - Los tipos muestran lo que espera una funcion\n3. **Detectar errores temprano** - Hemlock verifica tipos en tiempo de ejecucion\n\n```hemlock\n// Sin tipos (funciona bien):\nfn add(a, b) {\n    return a + b;\n}\n\n// Con tipos (mas explicito):\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Referencia Rapida: Eligiendo Tipos Numericos\n\n| Lo que almacenas | Tipo sugerido | Ejemplo |\n|------------------|---------------|---------|\n| Numeros enteros regulares | `i32` (por defecto) | `let count = 42;` |\n| Numeros muy grandes | `i64` | `let population = 8000000000;` |\n| Conteos nunca negativos | `u32` | `let items: u32 = 100;` |\n| Bytes (0-255) | `u8` | `let pixel: u8 = 255;` |\n| Decimales/fracciones | `f64` (por defecto) | `let price = 19.99;` |\n| Decimales criticos para rendimiento | `f32` | `let x: f32 = 1.5;` |\n\n### Referencia Rapida: Todos los Tipos\n\n| Categoria | Tipos | Cuando usar |\n|-----------|-------|-------------|\n| **Numeros enteros** | `i8`, `i16`, `i32`, `i64` | Conteo, IDs, edades, etc. |\n| **Numeros solo positivos** | `u8`, `u16`, `u32`, `u64` | Bytes, tamanos, longitudes de array |\n| **Decimales** | `f32`, `f64` | Dinero, medidas, matematicas |\n| **Si/No** | `bool` | Banderas, condiciones |\n| **Texto** | `string` | Nombres, mensajes, cualquier texto |\n| **Caracter individual** | `rune` | Letras individuales, emoji |\n| **Listas** | `array` | Colecciones de valores |\n| **Campos nombrados** | `object` | Agrupar datos relacionados |\n| **Memoria cruda** | `ptr`, `buffer` | Programacion de bajo nivel |\n| **Nada** | `null` | Ausencia de un valor |\n\n### Escenarios Comunes\n\n**\"Solo necesito un numero\"**\n```hemlock\nlet x = 42;  // Listo! Hemlock elige i32\n```\n\n**\"Necesito decimales\"**\n```hemlock\nlet price = 19.99;  // Listo! Hemlock elige f64\n```\n\n**\"Estoy trabajando con bytes (archivos, red)\"**\n```hemlock\nlet byte: u8 = 255;  // rango 0-255\n```\n\n**\"Necesito numeros realmente grandes\"**\n```hemlock\nlet big = 9000000000000;  // Hemlock auto-elige i64 (> max de i32)\n// O se explicito:\nlet big: i64 = 9000000000000;\n```\n\n**\"Estoy almacenando dinero\"**\n```hemlock\n// Opcion 1: Float (simple, pero tiene limites de precision)\nlet price: f64 = 19.99;\n\n// Opcion 2: Almacenar como centavos (mas preciso)\nlet price_cents: i32 = 1999;  // $19.99 como centavos enteros\n```\n\n**\"Estoy pasando datos a codigo C (FFI)\"**\n```hemlock\n// Coincidir tipos C exactamente\nlet c_int: i32 = 100;      // C 'int'\nlet c_long: i64 = 100;     // C 'long' (en 64-bit)\nlet c_char: u8 = 65;       // C 'char'\nlet c_double: f64 = 3.14;  // C 'double'\n```\n\n### Que Pasa Cuando Se Mezclan Tipos?\n\nCuando combinas diferentes tipos, Hemlock promueve al tipo \"mayor\":\n\n```hemlock\nlet a: i32 = 10;\nlet b: f64 = 2.5;\nlet result = a + b;  // result es f64 (12.5)\n// El entero se convirtio en decimal automaticamente\n```\n\n**Regla general:** Los floats siempre \"ganan\" - mezclar cualquier entero con un float te da un float.\n\n### Errores de Tipo\n\nSi intentas usar el tipo incorrecto, Hemlock te lo dice en tiempo de ejecucion:\n\n```hemlock\nlet age: i32 = \"thirty\";  // ERROR: incompatibilidad de tipos - esperaba i32, obtuvo string\n```\n\nPara convertir tipos, usa funciones constructoras de tipo:\n\n```hemlock\nlet text = \"42\";\nlet number = i32(text);   // Analizar cadena a entero: 42\nlet back = text + \"\";     // Ya es una cadena\n```\n\n---\n\n## Filosofia\n\n- **Dinamico por defecto** - Cada valor tiene una etiqueta de tipo en tiempo de ejecucion\n- **Tipado por eleccion** - Anotaciones de tipo opcionales imponen verificaciones en tiempo de ejecucion\n- **Conversiones explicitas** - Las conversiones implicitas siguen reglas de promocion claras\n- **Honesto sobre tipos** - `typeof()` siempre dice la verdad\n\n## Tipos Primitivos\n\n### Tipos Enteros\n\n**Enteros con signo:**\n```hemlock\nlet tiny: i8 = 127;              // 8-bit  (-128 a 127)\nlet small: i16 = 32767;          // 16-bit (-32768 a 32767)\nlet normal: i32 = 2147483647;    // 32-bit (por defecto)\nlet large: i64 = 9223372036854775807;  // 64-bit\n```\n\n**Enteros sin signo:**\n```hemlock\nlet byte: u8 = 255;              // 8-bit  (0 a 255)\nlet word: u16 = 65535;           // 16-bit (0 a 65535)\nlet dword: u32 = 4294967295;     // 32-bit (0 a 4294967295)\nlet qword: u64 = 18446744073709551615;  // 64-bit\n```\n\n**Alias de tipo:**\n```hemlock\nlet i: integer = 42;   // Alias para i32\nlet b: byte = 255;     // Alias para u8\n```\n\n### Tipos de Punto Flotante\n\n```hemlock\nlet f: f32 = 3.14159;        // float de 32-bit\nlet d: f64 = 2.718281828;    // float de 64-bit (por defecto)\nlet n: number = 1.618;       // Alias para f64\n```\n\n### Tipo Booleano\n\n```hemlock\nlet flag: bool = true;\nlet active: bool = false;\n```\n\n### Tipo String\n\n```hemlock\nlet text: string = \"Hello, World!\";\nlet empty: string = \"\";\n```\n\nLas cadenas son **mutables**, **codificadas en UTF-8** y **asignadas en el heap**.\n\nVer [Strings](#language-guide-strings) para detalles completos.\n\n### Tipo Rune\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = 'rocket';\nlet newline: rune = '\\n';\nlet unicode: rune = '\\u{1F680}';\n```\n\nLos runes representan **puntos de codigo Unicode** (U+0000 a U+10FFFF).\n\nVer [Runes](#language-guide-runes) para detalles completos.\n\n### Tipo Null\n\n```hemlock\nlet nothing = null;\nlet uninitialized: string = null;\n```\n\n`null` es su propio tipo con un unico valor.\n\n## Tipos Compuestos\n\n### Tipo Array\n\n```hemlock\nlet numbers: array = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];  // Tipos mezclados permitidos\nlet empty: array = [];\n```\n\nVer [Arrays](#language-guide-arrays) para detalles completos.\n\n### Tipo Object\n\n```hemlock\nlet obj: object = { x: 10, y: 20 };\nlet person = { name: \"Alice\", age: 30 };\n```\n\nVer [Objects](#language-guide-objects) para detalles completos.\n\n### Tipos de Puntero\n\n**Puntero crudo:**\n```hemlock\nlet p: ptr = alloc(64);\n// Sin verificacion de limites, gestion manual de tiempo de vida\nfree(p);\n```\n\n**Buffer seguro:**\n```hemlock\nlet buf: buffer = buffer(64);\n// Con verificacion de limites, rastrea longitud y capacidad\nfree(buf);\n```\n\nVer [Gestion de Memoria](#language-guide-memory) para detalles completos.\n\n## Tipos Enum\n\nLos enums definen un conjunto de constantes nombradas:\n\n### Enums Basicos\n\n```hemlock\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nlet c = Color.RED;\nprint(c);              // 0\nprint(typeof(c));      // \"Color\"\n\n// Comparacion\nif (c == Color.RED) {\n    print(\"It's red!\");\n}\n\n// Switch sobre enum\nswitch (c) {\n    case Color.RED:\n        print(\"Stop\");\n        break;\n    case Color.GREEN:\n        print(\"Go\");\n        break;\n    case Color.BLUE:\n        print(\"Blue?\");\n        break;\n}\n```\n\n### Enums con Valores\n\nLos enums pueden tener valores enteros explicitos:\n\n```hemlock\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 2\n}\n\nprint(Status.OK);      // 0\nprint(Status.ERROR);   // 1\n\nenum HttpCode {\n    OK = 200,\n    NOT_FOUND = 404,\n    SERVER_ERROR = 500\n}\n\nlet code = HttpCode.NOT_FOUND;\nprint(code);           // 404\n```\n\n### Valores Auto-incrementales\n\nSin valores explicitos, los enums auto-incrementan desde 0:\n\n```hemlock\nenum Priority {\n    LOW,       // 0\n    MEDIUM,    // 1\n    HIGH,      // 2\n    CRITICAL   // 3\n}\n\n// Puede mezclar valores explicitos y auto\nenum Level {\n    DEBUG = 10,\n    INFO,      // 11\n    WARN,      // 12\n    ERROR = 50,\n    FATAL      // 51\n}\n```\n\n### Patrones de Uso de Enum\n\n```hemlock\n// Como parametros de funcion\nfn set_priority(p: Priority) {\n    if (p == Priority.CRITICAL) {\n        print(\"Urgent!\");\n    }\n}\n\nset_priority(Priority.HIGH);\n\n// En objetos\ndefine Task {\n    name: string,\n    priority: Priority\n}\n\nlet task: Task = {\n    name: \"Fix bug\",\n    priority: Priority.HIGH\n};\n```\n\n## Tipos Especiales\n\n### Tipo File\n\n```hemlock\nlet f: file = open(\"data.txt\", \"r\");\nf.close();\n```\n\nRepresenta un manejador de archivo abierto.\n\n### Tipo Task\n\n```hemlock\nasync fn compute(): i32 { return 42; }\nlet task = spawn(compute);\nlet result: i32 = join(task);\n```\n\nRepresenta un manejador de tarea asincrona.\n\n### Tipo Channel\n\n```hemlock\nlet ch: channel = channel(10);\nch.send(42);\nlet value = ch.recv();\n```\n\nRepresenta un canal de comunicacion entre tareas.\n\n### Tipo Void\n\n```hemlock\nextern fn exit(code: i32): void;\n```\n\nUsado para funciones que no retornan un valor (solo FFI).\n\n## Inferencia de Tipos\n\n### Inferencia de Literales Enteros\n\nHemlock infiere tipos enteros basado en el rango de valores:\n\n```hemlock\nlet a = 42;              // i32 (cabe en 32-bit)\nlet b = 5000000000;      // i64 (> max de i32)\nlet c = 128;             // i32\nlet d: u8 = 128;         // u8 (anotacion explicita)\n```\n\n**Reglas:**\n- Valores en rango i32 (-2147483648 a 2147483647): inferir como `i32`\n- Valores fuera del rango i32 pero dentro de i64: inferir como `i64`\n- Usar anotaciones explicitas para otros tipos (i8, i16, u8, u16, u32, u64)\n\n### Inferencia de Literales Float\n\n```hemlock\nlet x = 3.14;        // f64 (por defecto)\nlet y: f32 = 3.14;   // f32 (explicito)\n```\n\n### Notacion Cientifica\n\nHemlock soporta notacion cientifica para literales numericos:\n\n```hemlock\nlet a = 1e10;        // 10000000000.0 (f64)\nlet b = 1e-12;       // 0.000000000001 (f64)\nlet c = 3.14e2;      // 314.0 (f64)\nlet d = 2.5e-3;      // 0.0025 (f64)\nlet e = 1E10;        // Insensible a mayusculas\nlet f = 1e+5;        // Exponente positivo explicito\n```\n\n**Nota:** Cualquier literal usando notacion cientifica siempre se infiere como `f64`.\n\n### Otra Inferencia de Tipos\n\n```hemlock\nlet s = \"hello\";     // string\nlet ch = 'A';        // rune\nlet flag = true;     // bool\nlet arr = [1, 2, 3]; // array\nlet obj = { x: 10 }; // object\nlet nothing = null;  // null\n```\n\n## Anotaciones de Tipo\n\n### Anotaciones de Variable\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet name: string = \"Alice\";\n```\n\n### Anotaciones de Parametros de Funcion\n\n```hemlock\nfn greet(name: string, age: i32) {\n    print(\"Hello, \" + name + \"!\");\n}\n```\n\n### Anotaciones de Tipo de Retorno de Funcion\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### Anotaciones de Tipo de Objeto (Duck Typing)\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\n```\n\n## Verificacion de Tipos\n\n### Verificacion de Tipos en Tiempo de Ejecucion\n\nLas anotaciones de tipo se verifican en **tiempo de ejecucion**, no en tiempo de compilacion:\n\n```hemlock\nlet x: i32 = 42;     // OK\nlet y: i32 = 3.14;   // Error de tiempo de ejecucion: incompatibilidad de tipos\n\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 3);           // OK\nadd(5, \"hello\");     // Error de tiempo de ejecucion: incompatibilidad de tipos\n```\n\n### Consultas de Tipo\n\nUsa `typeof()` para verificar tipos de valores:\n\n```hemlock\nprint(typeof(42));         // \"i32\"\nprint(typeof(3.14));       // \"f64\"\nprint(typeof(\"hello\"));    // \"string\"\nprint(typeof(true));       // \"bool\"\nprint(typeof(null));       // \"null\"\nprint(typeof([1, 2, 3]));  // \"array\"\nprint(typeof({ x: 10 }));  // \"object\"\n```\n\n## Conversiones de Tipo\n\n### Promocion Implicita de Tipo\n\nCuando se mezclan tipos en operaciones, Hemlock promueve al tipo \"superior\":\n\n**Jerarquia de Promocion (menor a mayor):**\n```\ni8 -> i16 -> i32 -> u32 -> i64 -> u64 -> f32 -> f64\n      ^      ^      ^\n     u8    u16\n```\n\n**Float siempre gana:**\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result es f64 (13.5)\n```\n\n**El tamano mayor gana:**\n```hemlock\nlet a: i32 = 100;\nlet b: i64 = 200;\nlet sum = a + b;     // sum es i64 (300)\n```\n\n**Preservacion de precision:** Cuando se mezclan enteros de 64-bit con f32, Hemlock promueve\na f64 para evitar perdida de precision (f32 tiene solo mantisa de 24-bit, insuficiente para i64/u64):\n```hemlock\nlet big: i64 = 9007199254740993;\nlet small: f32 = 1.0;\nlet result = big + small;  // result es f64, no f32!\n```\n\n**Ejemplos:**\n```hemlock\nu8 + i32  -> i32\ni32 + i64 -> i64\nu32 + u64 -> u64\ni32 + f32 -> f32    // f32 suficiente para i32\ni64 + f32 -> f64    // f64 necesario para preservar precision de i64\ni64 + f64 -> f64\ni8 + f64  -> f64\n```\n\n### Conversion Explicita de Tipo\n\n**Entero <-> Float:**\n```hemlock\nlet i: i32 = 42;\nlet f: f64 = i;      // i32 -> f64 (42.0)\n\nlet x: f64 = 3.14;\nlet n: i32 = x;      // f64 -> i32 (3, truncado)\n```\n\n**Entero <-> Rune:**\n```hemlock\nlet code: i32 = 65;\nlet ch: rune = code;  // i32 -> rune ('A')\n\nlet r: rune = 'Z';\nlet value: i32 = r;   // rune -> i32 (90)\n```\n\n**Rune -> String:**\n```hemlock\nlet ch: rune = 'rocket';\nlet s: string = ch;   // rune -> string (\"rocket\")\n```\n\n**u8 -> Rune:**\n```hemlock\nlet b: u8 = 65;\nlet r: rune = b;      // u8 -> rune ('A')\n```\n\n### Funciones Constructoras de Tipo\n\nLos nombres de tipo pueden usarse como funciones para convertir o analizar valores:\n\n**Analizar cadenas a numeros:**\n```hemlock\nlet n = i32(\"42\");       // Analizar cadena a i32: 42\nlet f = f64(\"3.14159\");  // Analizar cadena a f64: 3.14159\nlet b = bool(\"true\");    // Analizar cadena a bool: true\n\n// Todos los tipos numericos soportados\nlet a = i8(\"-128\");      // Analizar a i8\nlet c = u8(\"255\");       // Analizar a u8\nlet d = i16(\"1000\");     // Analizar a i16\nlet e = u16(\"50000\");    // Analizar a u16\nlet g = i64(\"9000000000000\"); // Analizar a i64\nlet h = u64(\"18000000000000\"); // Analizar a u64\nlet j = f32(\"1.5\");      // Analizar a f32\n```\n\n**Hex y numeros negativos:**\n```hemlock\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\nlet bin = i32(\"0b1010\"); // 10 (binario)\n```\n\n**Alias de tipo tambien funcionan:**\n```hemlock\nlet x = integer(\"100\");  // Igual que i32(\"100\")\nlet y = number(\"1.5\");   // Igual que f64(\"1.5\")\nlet z = byte(\"200\");     // Igual que u8(\"200\")\n```\n\n**Convertir entre tipos numericos:**\n```hemlock\nlet big = i64(42);           // i32 a i64\nlet truncated = i32(3.99);   // f64 a i32 (trunca a 3)\nlet promoted = f64(100);     // i32 a f64 (100.0)\nlet narrowed = i8(127);      // i32 a i8\n```\n\n**Las anotaciones de tipo realizan coercion numerica (pero NO analisis de cadenas):**\n```hemlock\nlet f: f64 = 100;        // i32 a f64 via anotacion (OK)\nlet s: string = 'A';     // Rune a string via anotacion (OK)\nlet code: i32 = 'A';     // Rune a i32 via anotacion (obtiene codepoint, OK)\n\n// Analisis de cadenas requiere constructores de tipo explicitos:\nlet n = i32(\"42\");       // Usar constructor de tipo para analisis de cadenas\n// let x: i32 = \"42\";    // ERROR - las anotaciones de tipo no analizan cadenas\n```\n\n**Manejo de errores:**\n```hemlock\n// Cadenas invalidas lanzan errores cuando usan constructores de tipo\nlet bad = i32(\"hello\");  // Error de tiempo de ejecucion: no se puede analizar \"hello\" como i32\nlet overflow = u8(\"256\"); // Error de tiempo de ejecucion: 256 fuera de rango para u8\n```\n\n**Analisis de booleanos:**\n```hemlock\nlet t = bool(\"true\");    // true\nlet f = bool(\"false\");   // false\nlet bad = bool(\"yes\");   // Error de tiempo de ejecucion: debe ser \"true\" o \"false\"\n```\n\n## Verificacion de Rango\n\nLas anotaciones de tipo imponen verificaciones de rango en la asignacion:\n\n```hemlock\nlet x: u8 = 255;    // OK\nlet y: u8 = 256;    // ERROR: fuera de rango para u8\n\nlet a: i8 = 127;    // OK\nlet b: i8 = 128;    // ERROR: fuera de rango para i8\n\nlet c: i64 = 2147483647;   // OK\nlet d: u64 = 4294967295;   // OK\nlet e: u64 = -1;           // ERROR: u64 no puede ser negativo\n```\n\n## Ejemplos de Promocion de Tipo\n\n### Tipos Enteros Mezclados\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet sum = a + b;     // i32 (30)\n\nlet c: u8 = 100;\nlet d: u32 = 200;\nlet total = c + d;   // u32 (300)\n```\n\n### Entero + Float\n\n```hemlock\nlet i: i32 = 5;\nlet f: f32 = 2.5;\nlet result = i * f;  // f32 (12.5)\n```\n\n### Expresiones Complejas\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet c: f64 = 3.0;\n\nlet result = a + b * c;  // f64 (70.0)\n// Evaluacion: b * c -> f64(60.0)\n//             a + f64(60.0) -> f64(70.0)\n```\n\n## Duck Typing (Objetos)\n\nLos objetos usan **tipado estructural** (duck typing):\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK: Tiene todos los campos requeridos\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK: Campos extra permitidos\nlet p2: Person = { name: \"Bob\", age: 25, city: \"NYC\" };\n\n// ERROR: Falta campo 'age'\nlet p3: Person = { name: \"Carol\" };\n\n// ERROR: Tipo incorrecto para 'age'\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```\n\n**La verificacion de tipo ocurre en la asignacion:**\n- Valida que todos los campos requeridos esten presentes\n- Valida que los tipos de campo coincidan\n- Los campos extra estan permitidos y preservados\n- Establece el nombre de tipo del objeto para `typeof()`\n\n## Campos Opcionales\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug?: false,     // Opcional con valor por defecto\n    timeout?: i32,     // Opcional, por defecto null\n}\n\nlet cfg1: Config = { host: \"localhost\", port: 8080 };\nprint(cfg1.debug);    // false (por defecto)\nprint(cfg1.timeout);  // null\n\nlet cfg2: Config = { host: \"0.0.0.0\", port: 80, debug: true };\nprint(cfg2.debug);    // true (sobrescrito)\n```\n\n## Alias de Tipo\n\nHemlock soporta alias de tipo personalizados usando la palabra clave `type`:\n\n### Alias de Tipo Basicos\n\n```hemlock\n// Alias de tipo simple\ntype Integer = i32;\ntype Text = string;\n\n// Usando el alias\nlet x: Integer = 42;\nlet msg: Text = \"hello\";\n```\n\n### Alias de Tipo de Funcion\n\n```hemlock\n// Alias de tipo de funcion\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// Usando alias de tipo de funcion\nlet cb: Callback = fn(n) { print(n); };\nlet isEven: Predicate = fn(n) { return n % 2 == 0; };\n```\n\n### Alias de Tipo Compuesto\n\n```hemlock\n// Combinar multiples defines en un tipo\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\ntype Person = HasName & HasAge;\n\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\n### Alias de Tipo Generico\n\n```hemlock\n// Alias de tipo generico\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// Usando alias genericos\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**Nota:** Los alias de tipo son transparentes - `typeof()` retorna el nombre del tipo subyacente, no el alias.\n\n## Limitaciones del Sistema de Tipos\n\nLimitaciones actuales:\n\n- **Sin genericos en funciones** - Parametros de tipo en funciones aun no soportados\n- **Sin tipos union** - No se puede expresar \"A o B\"\n- **Sin tipos nullable** - Todos los tipos pueden ser null (usar sufijo `?` para nulabilidad explicita)\n\n**Nota:** El compilador (`hemlockc`) proporciona verificacion de tipos en tiempo de compilacion. El interprete realiza verificacion de tipos solo en tiempo de ejecucion. Ver la [documentacion del compilador](#design-implementation) para detalles.\n\n## Mejores Practicas\n\n### Cuando Usar Anotaciones de Tipo\n\n**USA anotaciones cuando:**\n- El tipo preciso importa (ej., `u8` para valores de byte)\n- Documentar interfaces de funciones\n- Imponer restricciones (ej., verificaciones de rango)\n\n```hemlock\nfn hash(data: buffer, length: u32): u64 {\n    // Implementacion\n}\n```\n\n**NO uses anotaciones cuando:**\n- El tipo es obvio del literal\n- Detalles de implementacion interna\n- Ceremonia innecesaria\n\n```hemlock\n// Innecesario\nlet x: i32 = 42;\n\n// Mejor\nlet x = 42;\n```\n\n### Patrones de Seguridad de Tipo\n\n**Verificar antes de usar:**\n```hemlock\nif (typeof(value) == \"i32\") {\n    // Seguro usar como i32\n}\n```\n\n**Validar argumentos de funcion:**\n```hemlock\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" || typeof(b) != \"i32\") {\n        throw \"arguments must be integers\";\n    }\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n```\n\n**Usar duck typing para flexibilidad:**\n```hemlock\ndefine Printable {\n    toString: fn,\n}\n\nfn print_item(item: Printable) {\n    print(item.toString());\n}\n```\n\n## Siguientes Pasos\n\n- [Strings](#language-guide-strings) - Tipo string UTF-8 y operaciones\n- [Runes](#language-guide-runes) - Tipo de punto de codigo Unicode\n- [Arrays](#language-guide-arrays) - Tipo de array dinamico\n- [Objects](#language-guide-objects) - Literales de objeto y duck typing\n- [Memory](#language-guide-memory) - Tipos de puntero y buffer\n"}, "Temas Avanzados -> Argumentos de Lnea de Comandos": {"id": "advanced-command-line-args", "content": "# Argumentos de Linea de Comandos en Hemlock\n\nLos programas de Hemlock pueden acceder a los argumentos de linea de comandos a traves de un **array `args` integrado** que se llena automaticamente al iniciar el programa.\n\n## Tabla de Contenidos\n\n- [Vision General](#vision-general)\n- [El Array args](#el-array-args)\n- [Propiedades](#propiedades)\n- [Patrones de Iteracion](#patrones-de-iteracion)\n- [Casos de Uso Comunes](#casos-de-uso-comunes)\n- [Patrones de Analisis de Argumentos](#patrones-de-analisis-de-argumentos)\n- [Mejores Practicas](#mejores-practicas)\n- [Ejemplos Completos](#ejemplos-completos)\n\n## Vision General\n\nEl array `args` proporciona acceso a los argumentos de linea de comandos pasados a tu programa de Hemlock:\n\n- **Siempre disponible** - Variable global integrada en todos los programas de Hemlock\n- **Nombre del script incluido** - `args[0]` siempre contiene la ruta/nombre del script\n- **Array de strings** - Todos los argumentos son strings\n- **Indexado desde cero** - Indexacion estandar de array (0, 1, 2, ...)\n\n## El Array args\n\n### Estructura Basica\n\n```hemlock\n// args[0] es siempre el nombre del archivo de script\n// args[1] a args[n-1] son los argumentos reales\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // Numero total de argumentos (incluyendo nombre del script)\n```\n\n### Ejemplo de Uso\n\n**Comando:**\n```bash\n./hemlock script.hml hello world \"test 123\"\n```\n\n**En script.hml:**\n```hemlock\nprint(\"Script name: \" + args[0]);     // \"script.hml\"\nprint(\"Total args: \" + typeof(args.length));  // \"4\"\nprint(\"First arg: \" + args[1]);       // \"hello\"\nprint(\"Second arg: \" + args[2]);      // \"world\"\nprint(\"Third arg: \" + args[3]);       // \"test 123\"\n```\n\n### Referencia de Indices\n\n| Indice | Contiene | Valor de Ejemplo |\n|--------|----------|------------------|\n| `args[0]` | Ruta/nombre del script | `\"script.hml\"` o `\"./script.hml\"` |\n| `args[1]` | Primer argumento | `\"hello\"` |\n| `args[2]` | Segundo argumento | `\"world\"` |\n| `args[3]` | Tercer argumento | `\"test 123\"` |\n| ... | ... | ... |\n| `args[n-1]` | Ultimo argumento | (varia) |\n\n## Propiedades\n\n### Siempre Presente\n\n`args` es un array global disponible en **todos** los programas de Hemlock:\n\n```hemlock\n// No necesita declararse o importarse\nprint(args.length);  // Funciona inmediatamente\n```\n\n### Nombre del Script Incluido\n\n`args[0]` siempre contiene la ruta/nombre del script:\n\n```hemlock\nprint(\"Running: \" + args[0]);\n```\n\n**Valores posibles para args[0]:**\n- `\"script.hml\"` - Solo el nombre del archivo\n- `\"./script.hml\"` - Ruta relativa\n- `\"/home/user/script.hml\"` - Ruta absoluta\n- Depende de como se invoco el script\n\n### Tipo: Array de Strings\n\nTodos los argumentos se almacenan como strings:\n\n```hemlock\n// Argumentos: ./hemlock script.hml 42 3.14 true\n\nprint(args[1]);  // \"42\" (string, no numero)\nprint(args[2]);  // \"3.14\" (string, no numero)\nprint(args[3]);  // \"true\" (string, no booleano)\n\n// Convertir segun necesidad:\nlet num = 42;  // Parsear manualmente si es necesario\n```\n\n### Longitud Minima\n\nSiempre al menos 1 (el nombre del script):\n\n```hemlock\nprint(args.length);  // Minimo: 1\n```\n\n**Incluso sin argumentos:**\n```bash\n./hemlock script.hml\n```\n\n```hemlock\n// En script.hml:\nprint(args.length);  // 1 (solo nombre del script)\n```\n\n### Comportamiento en REPL\n\nEn el REPL, `args.length` es 0 (array vacio):\n\n```hemlock\n# Sesion REPL\n> print(args.length);\n0\n```\n\n## Patrones de Iteracion\n\n### Iteracion Basica\n\nSaltar `args[0]` (nombre del script) y procesar argumentos reales:\n\n```hemlock\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument \" + typeof(i) + \": \" + args[i]);\n    i = i + 1;\n}\n```\n\n**Salida para: `./hemlock script.hml foo bar baz`**\n```\nArgument 1: foo\nArgument 2: bar\nArgument 3: baz\n```\n\n### Iteracion For-In (Incluyendo Nombre del Script)\n\n```hemlock\nfor (let arg in args) {\n    print(arg);\n}\n```\n\n**Salida:**\n```\nscript.hml\nfoo\nbar\nbaz\n```\n\n### Verificando Cantidad de Argumentos\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <argument>\");\n    // salir o retornar\n} else {\n    let arg = args[1];\n    // procesar arg\n}\n```\n\n### Procesando Todos los Argumentos Excepto el Nombre del Script\n\n```hemlock\nlet actual_args = args.slice(1, args.length);\n\nfor (let arg in actual_args) {\n    print(\"Processing: \" + arg);\n}\n```\n\n## Casos de Uso Comunes\n\n### 1. Procesamiento Simple de Argumentos\n\nVerificar argumento requerido:\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    print(\"Processing file: \" + filename);\n    // ... procesar archivo\n}\n```\n\n**Uso:**\n```bash\n./hemlock script.hml data.txt\n# Salida: Processing file: data.txt\n```\n\n### 2. Multiples Argumentos\n\n```hemlock\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <input> <output>\");\n} else {\n    let input_file = args[1];\n    let output_file = args[2];\n\n    print(\"Input: \" + input_file);\n    print(\"Output: \" + output_file);\n\n    // Procesar archivos...\n}\n```\n\n**Uso:**\n```bash\n./hemlock convert.hml input.txt output.txt\n```\n\n### 3. Numero Variable de Argumentos\n\nProcesar todos los argumentos proporcionados:\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        print(\"  \" + args[i]);\n        process_file(args[i]);\n        i = i + 1;\n    }\n}\n```\n\n**Uso:**\n```bash\n./hemlock batch.hml file1.txt file2.txt file3.txt\n```\n\n### 4. Mensaje de Ayuda\n\n```hemlock\nif (args.length < 2 || args[1] == \"--help\" || args[1] == \"-h\") {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show this help message\");\n    print(\"  -v, --verbose  Enable verbose output\");\n} else {\n    // Procesar normalmente\n}\n```\n\n### 5. Validacion de Argumentos\n\n```hemlock\nfn validate_file(filename: string): bool {\n    // Verificar si el archivo existe (ejemplo)\n    return filename != \"\";\n}\n\nif (args.length < 2) {\n    print(\"Error: No filename provided\");\n} else if (!validate_file(args[1])) {\n    print(\"Error: Invalid file: \" + args[1]);\n} else {\n    print(\"Processing: \" + args[1]);\n}\n```\n\n## Patrones de Analisis de Argumentos\n\n### Argumentos con Nombre (Flags)\n\nPatron simple para argumentos con nombre:\n\n```hemlock\nlet verbose = false;\nlet output_file = \"\";\nlet input_file = \"\";\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\" || args[i] == \"-v\") {\n        verbose = true;\n    } else if (args[i] == \"--output\" || args[i] == \"-o\") {\n        i = i + 1;\n        if (i < args.length) {\n            output_file = args[i];\n        }\n    } else {\n        input_file = args[i];\n    }\n    i = i + 1;\n}\n\nif (verbose) {\n    print(\"Verbose mode enabled\");\n}\nprint(\"Input: \" + input_file);\nprint(\"Output: \" + output_file);\n```\n\n**Uso:**\n```bash\n./hemlock script.hml --verbose --output out.txt input.txt\n./hemlock script.hml -v -o out.txt input.txt\n```\n\n### Flags Booleanos\n\n```hemlock\nlet debug = false;\nlet verbose = false;\nlet force = false;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--debug\") {\n        debug = true;\n    } else if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else if (args[i] == \"--force\") {\n        force = true;\n    }\n    i = i + 1;\n}\n```\n\n### Argumentos con Valor\n\n```hemlock\nlet config_file = \"default.conf\";\nlet port = 8080;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--config\") {\n        i = i + 1;\n        if (i < args.length) {\n            config_file = args[i];\n        }\n    } else if (args[i] == \"--port\") {\n        i = i + 1;\n        if (i < args.length) {\n            port = 8080;  // Necesitaria parsear string a int\n        }\n    }\n    i = i + 1;\n}\n```\n\n### Argumentos Posicionales y con Nombre Mezclados\n\n```hemlock\nlet input_file = \"\";\nlet output_file = \"\";\nlet verbose = false;\n\nlet i = 1;\nlet positional = [];\n\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else {\n        // Tratar como argumento posicional\n        positional.push(args[i]);\n    }\n    i = i + 1;\n}\n\n// Asignar argumentos posicionales\nif (positional.length > 0) {\n    input_file = positional[0];\n}\nif (positional.length > 1) {\n    output_file = positional[1];\n}\n```\n\n### Funcion Auxiliar de Analizador de Argumentos\n\n```hemlock\nfn parse_args() {\n    let options = {\n        verbose: false,\n        output: \"\",\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            options.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                options.output = args[i];\n            }\n        } else {\n            // Argumento posicional\n            options.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return options;\n}\n\nlet opts = parse_args();\nprint(\"Verbose: \" + typeof(opts.verbose));\nprint(\"Output: \" + opts.output);\nprint(\"Files: \" + typeof(opts.files.length));\n```\n\n## Mejores Practicas\n\n### 1. Siempre Verificar Cantidad de Argumentos\n\n```hemlock\n// Bueno\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file>\");\n} else {\n    process_file(args[1]);\n}\n\n// Malo - puede fallar si no hay argumentos\nprocess_file(args[1]);  // Error si args.length == 1\n```\n\n### 2. Proporcionar Informacion de Uso\n\n```hemlock\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show help\");\n    print(\"  -v, --verbose  Verbose output\");\n}\n\nif (args.length < 2) {\n    show_usage();\n}\n```\n\n### 3. Validar Argumentos\n\n```hemlock\nfn validate_args() {\n    if (args.length < 2) {\n        print(\"Error: Missing required argument\");\n        return false;\n    }\n\n    if (args[1] == \"\") {\n        print(\"Error: Empty argument\");\n        return false;\n    }\n\n    return true;\n}\n\nif (!validate_args()) {\n    // salir o mostrar uso\n}\n```\n\n### 4. Usar Nombres de Variables Descriptivos\n\n```hemlock\n// Bueno\nlet input_filename = args[1];\nlet output_filename = args[2];\nlet max_iterations = args[3];\n\n// Malo\nlet a = args[1];\nlet b = args[2];\nlet c = args[3];\n```\n\n### 5. Manejar Argumentos con Comillas y Espacios\n\nEl shell maneja esto automaticamente:\n\n```bash\n./hemlock script.hml \"file with spaces.txt\"\n```\n\n```hemlock\nprint(args[1]);  // \"file with spaces.txt\"\n```\n\n### 6. Crear Objetos de Argumentos\n\n```hemlock\nfn get_args() {\n    return {\n        script: args[0],\n        input: args[1],\n        output: args[2]\n    };\n}\n\nlet arguments = get_args();\nprint(\"Input: \" + arguments.input);\n```\n\n## Ejemplos Completos\n\n### Ejemplo 1: Procesador de Archivos\n\n```hemlock\n// Uso: ./hemlock process.hml <input> <output>\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <input_file> <output_file>\");\n}\n\nif (args.length < 3) {\n    show_usage();\n} else {\n    let input = args[1];\n    let output = args[2];\n\n    print(\"Processing \" + input + \" -> \" + output);\n\n    // Procesar archivos\n    let f_in = open(input, \"r\");\n    let f_out = open(output, \"w\");\n\n    try {\n        let content = f_in.read();\n        let processed = content.to_upper();  // Procesamiento de ejemplo\n        f_out.write(processed);\n\n        print(\"Done!\");\n    } finally {\n        f_in.close();\n        f_out.close();\n    }\n}\n```\n\n### Ejemplo 2: Procesador de Archivos por Lotes\n\n```hemlock\n// Uso: ./hemlock batch.hml <file1> <file2> <file3> ...\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        let filename = args[i];\n        print(\"  Processing: \" + filename);\n\n        try {\n            let f = open(filename, \"r\");\n            let content = f.read();\n            f.close();\n\n            // Procesar contenido...\n            print(\"    \" + typeof(content.length) + \" bytes\");\n        } catch (e) {\n            print(\"    Error: \" + e);\n        }\n\n        i = i + 1;\n    }\n\n    print(\"Done!\");\n}\n```\n\n### Ejemplo 3: Analizador de Argumentos Avanzado\n\n```hemlock\n// Uso: ./hemlock app.hml [OPTIONS] <files...>\n// Opciones:\n//   --verbose, -v     Habilitar salida detallada\n//   --output, -o FILE Establecer archivo de salida\n//   --help, -h        Mostrar ayuda\n\nfn parse_arguments() {\n    let config = {\n        verbose: false,\n        output: \"output.txt\",\n        help: false,\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            config.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                config.output = args[i];\n            } else {\n                print(\"Error: --output requires a value\");\n            }\n        } else if (arg == \"--help\" || arg == \"-h\") {\n            config.help = true;\n        } else if (arg.starts_with(\"--\")) {\n            print(\"Error: Unknown option: \" + arg);\n        } else {\n            config.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return config;\n}\n\nfn show_help() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <files...>\");\n    print(\"Options:\");\n    print(\"  --verbose, -v     Enable verbose output\");\n    print(\"  --output, -o FILE Set output file\");\n    print(\"  --help, -h        Show this help\");\n}\n\nlet config = parse_arguments();\n\nif (config.help) {\n    show_help();\n} else if (config.files.length == 0) {\n    print(\"Error: No input files specified\");\n    show_help();\n} else {\n    if (config.verbose) {\n        print(\"Verbose mode enabled\");\n        print(\"Output file: \" + config.output);\n        print(\"Input files: \" + typeof(config.files.length));\n    }\n\n    // Procesar archivos\n    for (let file in config.files) {\n        if (config.verbose) {\n            print(\"Processing: \" + file);\n        }\n        // ... procesar archivo\n    }\n}\n```\n\n### Ejemplo 4: Herramienta de Configuracion\n\n```hemlock\n// Uso: ./hemlock config.hml <action> [arguments]\n// Acciones:\n//   get <key>\n//   set <key> <value>\n//   list\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <action> [arguments]\");\n    print(\"Actions:\");\n    print(\"  get <key>         Get configuration value\");\n    print(\"  set <key> <value> Set configuration value\");\n    print(\"  list              List all configuration\");\n}\n\nif (args.length < 2) {\n    show_usage();\n} else {\n    let action = args[1];\n\n    if (action == \"get\") {\n        if (args.length < 3) {\n            print(\"Error: 'get' requires a key\");\n        } else {\n            let key = args[2];\n            print(\"Getting: \" + key);\n            // ... obtener de configuracion\n        }\n    } else if (action == \"set\") {\n        if (args.length < 4) {\n            print(\"Error: 'set' requires key and value\");\n        } else {\n            let key = args[2];\n            let value = args[3];\n            print(\"Setting \" + key + \" = \" + value);\n            // ... establecer en configuracion\n        }\n    } else if (action == \"list\") {\n        print(\"Listing all configuration:\");\n        // ... listar configuracion\n    } else {\n        print(\"Error: Unknown action: \" + action);\n        show_usage();\n    }\n}\n```\n\n## Resumen\n\nEl soporte de argumentos de linea de comandos de Hemlock proporciona:\n\n-  Array `args` integrado disponible globalmente\n-  Acceso simple basado en array a los argumentos\n-  Nombre del script en `args[0]`\n-  Todos los argumentos como strings\n-  Metodos de array disponibles (.length, .slice, etc.)\n\nRecuerda:\n- Siempre verificar `args.length` antes de acceder a elementos\n- `args[0]` es el nombre del script\n- Los argumentos reales comienzan en `args[1]`\n- Todos los argumentos son strings - convertir segun necesidad\n- Proporcionar informacion de uso para herramientas amigables\n- Validar argumentos antes de procesar\n\nPatrones comunes:\n- Argumentos posicionales simples\n- Argumentos con nombre/flags (--flag)\n- Argumentos con valor (--option value)\n- Mensajes de ayuda (--help)\n- Validacion de argumentos\n"}, "Temas Avanzados -> Asincrona y Concurrencia": {"id": "advanced-async-concurrency", "content": "# Async/Concurrencia en Hemlock\n\nHemlock proporciona **concurrencia estructurada** con sintaxis async/await, creacion de tareas y canales para comunicacion. La implementacion utiliza hilos POSIX (pthreads) para **VERDADERO paralelismo multihilo**.\n\n## Tabla de Contenidos\n\n- [Vision General](#vision-general)\n- [Modelo de Hilos](#modelo-de-hilos)\n- [Funciones Async](#funciones-async)\n- [Creacion de Tareas](#creacion-de-tareas)\n- [Canales](#canales)\n- [Propagacion de Excepciones](#propagacion-de-excepciones)\n- [Detalles de Implementacion](#detalles-de-implementacion)\n- [Mejores Practicas](#mejores-practicas)\n- [Caracteristicas de Rendimiento](#caracteristicas-de-rendimiento)\n- [Limitaciones Actuales](#limitaciones-actuales)\n\n## Vision General\n\n**Lo que esto significa:**\n-  **Hilos reales del SO** - Cada tarea creada se ejecuta en un pthread separado (hilo POSIX)\n-  **Verdadero paralelismo** - Las tareas se ejecutan simultaneamente en multiples nucleos de CPU\n-  **Planificado por el kernel** - El planificador del SO distribuye las tareas entre los nucleos disponibles\n-  **Canales seguros para hilos** - Utiliza mutexes y variables de condicion de pthread para sincronizacion\n\n**Lo que esto NO es:**\n-  **NO son hilos verdes** - No es multitarea cooperativa en espacio de usuario\n-  **NO son corrutinas async/await** - No es un bucle de eventos de un solo hilo como JavaScript/Python asyncio\n-  **NO es concurrencia emulada** - No es paralelismo simulado\n\nEste es el **mismo modelo de hilos que C, C++ y Rust** cuando se usan hilos del SO. Obtienes ejecucion paralela real a traves de multiples nucleos.\n\n## Modelo de Hilos\n\n### Hilos 1:1\n\nHemlock utiliza un **modelo de hilos 1:1**, donde:\n- Cada tarea creada crea un hilo dedicado del SO via `pthread_create()`\n- El kernel del SO planifica los hilos a traves de los nucleos de CPU disponibles\n- Multitarea preventiva - el SO puede interrumpir y cambiar entre hilos\n- **Sin GIL** - A diferencia de Python, no hay un Bloqueo Global del Interprete limitando el paralelismo\n\n### Mecanismos de Sincronizacion\n\n- **Mutexes** - Los canales usan `pthread_mutex_t` para acceso seguro entre hilos\n- **Variables de condicion** - send/recv bloqueantes usan `pthread_cond_t` para espera eficiente\n- **Operaciones sin bloqueo** - Las transiciones de estado de tareas son atomicas\n\n## Funciones Async\n\nLas funciones pueden declararse como `async` para indicar que estan disenadas para ejecucion concurrente:\n\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n```\n\n### Puntos Clave\n\n- `async fn` declara una funcion asincrona\n- Las funciones async pueden crearse como tareas concurrentes usando `spawn()`\n- Las funciones async tambien pueden llamarse directamente (se ejecuta sincronicamente en el hilo actual)\n- Cuando se crean, cada tarea se ejecuta en su **propio hilo del SO** (no es una corrutina!)\n- La palabra clave `await` esta reservada para uso futuro\n\n### Ejemplo: Llamada Directa vs Spawn\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Llamada directa - se ejecuta sincronicamente\nlet result1 = factorial(5);  // 120\n\n// Tarea creada - se ejecuta en hilo separado\nlet task = spawn(factorial, 5);\nlet result2 = join(task);  // 120\n```\n\n## Creacion de Tareas\n\nUsa `spawn()` para ejecutar funciones async **en paralelo en hilos separados del SO**:\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Crear multiples tareas - estas se ejecutan en PARALELO en diferentes nucleos de CPU!\nlet t1 = spawn(factorial, 5);  // Hilo 1\nlet t2 = spawn(factorial, 6);  // Hilo 2\nlet t3 = spawn(factorial, 7);  // Hilo 3\n\n// Las tres estan computando simultaneamente ahora mismo!\n\n// Esperar resultados\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\n```\n\n### Funciones Integradas\n\n#### spawn(async_fn, arg1, arg2, ...)\n\nCrea una nueva tarea en un nuevo pthread, retorna el manejador de tarea.\n\n**Parametros:**\n- `async_fn` - La funcion async a ejecutar\n- `arg1, arg2, ...` - Argumentos a pasar a la funcion\n\n**Retorna:** Manejador de tarea (valor opaco usado con `join()` o `detach()`)\n\n**Ejemplo:**\n```hemlock\nasync fn process(data: string, count: i32): i32 {\n    // ... logica de procesamiento\n    return count * 2;\n}\n\nlet task = spawn(process, \"test\", 42);\n```\n\n#### join(task)\n\nEspera a que la tarea complete (bloquea hasta que el hilo termine), retorna el resultado.\n\n**Parametros:**\n- `task` - Manejador de tarea retornado por `spawn()`\n\n**Retorna:** El valor retornado por la funcion async\n\n**Ejemplo:**\n```hemlock\nlet task = spawn(compute, 1000);\nlet result = join(task);  // Bloquea hasta que compute() termine\nprint(result);\n```\n\n**Importante:** Cada tarea solo puede unirse una vez. Uniones posteriores daran error.\n\n#### detach(task)\n\nEjecucion de disparar y olvidar (el hilo se ejecuta independientemente, no se permite union).\n\n**Parametros:**\n- `task` - Manejador de tarea retornado por `spawn()`\n\n**Retorna:** `null`\n\n**Ejemplo:**\n```hemlock\nasync fn background_work() {\n    // Tarea de fondo de larga duracion\n    // ...\n}\n\nlet task = spawn(background_work);\ndetach(task);  // La tarea se ejecuta independientemente, no se puede unir\n```\n\n**Importante:** Las tareas desacopladas no pueden unirse. Tanto el pthread como la estructura Task se limpian automaticamente cuando la tarea completa.\n\n## Canales\n\nLos canales proporcionan comunicacion segura entre hilos usando un buffer limitado con semantica de bloqueo.\n\n### Creando Canales\n\n```hemlock\nlet ch = channel(10);  // Crear canal con tamano de buffer de 10\n```\n\n**Parametros:**\n- `capacity` (i32) - Numero maximo de valores que el canal puede contener\n\n**Retorna:** Objeto Canal\n\n### Metodos de Canal\n\n#### send(value)\n\nEnviar valor al canal (bloquea si esta lleno).\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet task = spawn(producer, ch, 5);\n```\n\n**Comportamiento:**\n- Si el canal tiene espacio, el valor se agrega inmediatamente\n- Si el canal esta lleno, el emisor bloquea hasta que haya espacio disponible\n- Si el canal esta cerrado, lanza una excepcion\n\n#### recv()\n\nRecibir valor del canal (bloquea si esta vacio).\n\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet task = spawn(consumer, ch, 5);\n```\n\n**Comportamiento:**\n- Si el canal tiene valores, retorna el siguiente valor inmediatamente\n- Si el canal esta vacio, el receptor bloquea hasta que haya un valor disponible\n- Si el canal esta cerrado y vacio, retorna `null`\n\n#### close()\n\nCerrar canal (recv en canal cerrado retorna null).\n\n```hemlock\nch.close();\n```\n\n**Comportamiento:**\n- Previene futuras operaciones `send()` (lanzara excepcion)\n- Permite que las operaciones `recv()` pendientes completen\n- Una vez vacio, `recv()` retorna `null`\n\n### Multiplexacion con select()\n\nLa funcion `select()` permite esperar en multiples canales simultaneamente, retornando cuando cualquier canal tiene datos disponibles.\n\n**Firma:**\n```hemlock\nselect(channels: array, timeout_ms?: i32): object | null\n```\n\n**Parametros:**\n- `channels` - Array de valores de canal\n- `timeout_ms` (opcional) - Tiempo de espera en milisegundos (-1 u omitir para espera infinita)\n\n**Retorna:**\n- `{ channel, value }` - Objeto con el canal que tenia datos y el valor recibido\n- `null` - En tiempo de espera agotado (si se especifico timeout)\n\n**Ejemplo:**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// Tareas productoras\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"from channel 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"from channel 2\");\n});\n\n// Esperar primer resultado (ch2 deberia ser mas rapido)\nlet result = select([ch1, ch2]);\nprint(result.value);  // \"from channel 2\"\n\n// Esperar segundo resultado\nlet result2 = select([ch1, ch2]);\nprint(result2.value);  // \"from channel 1\"\n```\n\n**Con tiempo de espera:**\n```hemlock\nlet ch = channel(1);\n\n// Sin emisor, se agotara el tiempo\nlet result = select([ch], 100);  // 100ms de timeout\nif (result == null) {\n    print(\"Timed out!\");\n}\n```\n\n**Casos de uso:**\n- Esperar el mas rapido de multiples fuentes de datos\n- Implementar tiempos de espera en operaciones de canal\n- Patrones de bucle de eventos con multiples fuentes de eventos\n- Fan-in: fusionar multiples canales en uno\n\n**Patron fan-in:**\n```hemlock\nfn fan_in(channels: array, output: channel) {\n    while (true) {\n        let result = select(channels);\n        if (result == null) {\n            break;  // Todos los canales cerrados\n        }\n        output.send(result.value);\n    }\n    output.close();\n}\n```\n\n### Ejemplo Completo de Productor-Consumidor\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Crear canal con tamano de buffer\nlet ch = channel(10);\n\n// Crear productor y consumidor\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Esperar finalizacion\njoin(p);\nlet total = join(c);  // 100 (0+10+20+30+40)\nprint(total);\n```\n\n### Multi-Productor, Multi-Consumidor\n\nLos canales pueden compartirse de forma segura entre multiples productores y consumidores:\n\n```hemlock\nasync fn producer(id: i32, ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(id * 100 + i);\n        i = i + 1;\n    }\n}\n\nasync fn consumer(id: i32, ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(20);\n\n// Multiples productores\nlet p1 = spawn(producer, 1, ch, 5);\nlet p2 = spawn(producer, 2, ch, 5);\n\n// Multiples consumidores\nlet c1 = spawn(consumer, 1, ch, 5);\nlet c2 = spawn(consumer, 2, ch, 5);\n\n// Esperar a todos\njoin(p1);\njoin(p2);\nlet sum1 = join(c1);\nlet sum2 = join(c2);\nprint(sum1 + sum2);\n```\n\n## Propagacion de Excepciones\n\nLas excepciones lanzadas en tareas creadas se propagan cuando se unen:\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Caught: \" + e);  // \"Caught: Task failed!\"\n}\n```\n\n### Patrones de Manejo de Excepciones\n\n**Patron 1: Manejar en la tarea**\n```hemlock\nasync fn safe_task() {\n    try {\n        // operacion riesgosa\n    } catch (e) {\n        print(\"Error in task: \" + e);\n        return null;\n    }\n}\n\nlet task = spawn(safe_task);\njoin(task);  // Sin excepcion propagada\n```\n\n**Patron 2: Propagar al llamador**\n```hemlock\nasync fn task_that_throws() {\n    throw \"error\";\n}\n\nlet task = spawn(task_that_throws);\ntry {\n    join(task);\n} catch (e) {\n    print(\"Caught from task: \" + e);\n}\n```\n\n**Patron 3: Tareas desacopladas con excepciones**\n```hemlock\nasync fn detached_task() {\n    try {\n        // trabajo\n    } catch (e) {\n        // Debe manejarse internamente - no puede propagarse\n        print(\"Error: \" + e);\n    }\n}\n\nlet task = spawn(detached_task);\ndetach(task);  // No se pueden capturar excepciones de tareas desacopladas\n```\n\n## Detalles de Implementacion\n\n### Arquitectura de Hilos\n\n- **Hilos 1:1** - Cada tarea creada crea un hilo dedicado del SO via `pthread_create()`\n- **Planificado por el kernel** - El kernel del SO planifica los hilos a traves de los nucleos de CPU disponibles\n- **Multitarea preventiva** - El SO puede interrumpir y cambiar entre hilos\n- **Sin GIL** - A diferencia de Python, no hay un Bloqueo Global del Interprete limitando el paralelismo\n\n### Implementacion de Canales\n\nLos canales usan un buffer circular con sincronizacion de pthread:\n\n```\nEstructura de Canal:\n- buffer[] - Array de tamano fijo de Values\n- capacity - Numero maximo de elementos\n- size - Numero actual de elementos\n- head - Posicion de lectura\n- tail - Posicion de escritura\n- mutex - pthread_mutex_t para acceso seguro entre hilos\n- not_empty - pthread_cond_t para recv bloqueante\n- not_full - pthread_cond_t para send bloqueante\n- closed - Flag booleano\n- refcount - Contador de referencias para limpieza\n```\n\n**Comportamiento de bloqueo:**\n- `send()` en canal lleno: espera en la variable de condicion `not_full`\n- `recv()` en canal vacio: espera en la variable de condicion `not_empty`\n- Ambas son senalizadas cuando corresponde por la operacion opuesta\n\n### Memoria y Limpieza\n\n- **Tareas unidas:** Limpiadas automaticamente despues de que `join()` retorna\n- **Tareas desacopladas:** Limpiadas automaticamente cuando la tarea completa\n- **Canales:** Contados por referencia y liberados cuando ya no se usan\n\n## Mejores Practicas\n\n### 1. Siempre Cerrar Canales\n\n```hemlock\nasync fn producer(ch) {\n    // ... enviar valores\n    ch.close();  // Importante: senalar que no hay mas valores\n}\n```\n\n### 2. Usar Concurrencia Estructurada\n\nCrear tareas y unirlas en el mismo ambito:\n\n```hemlock\nfn process_data(data) {\n    // Crear tareas\n    let t1 = spawn(worker, data);\n    let t2 = spawn(worker, data);\n\n    // Siempre unir antes de retornar\n    let r1 = join(t1);\n    let r2 = join(t2);\n\n    return r1 + r2;\n}\n```\n\n### 3. Manejar Excepciones Apropiadamente\n\n```hemlock\nasync fn task() {\n    try {\n        // operacion riesgosa\n    } catch (e) {\n        // Registrar error\n        throw e;  // Re-lanzar si el llamador debe saberlo\n    }\n}\n```\n\n### 4. Usar Capacidad de Canal Apropiada\n\n- **Capacidad pequena (1-10):** Para coordinacion/senalizacion\n- **Capacidad media (10-100):** Para productor-consumidor general\n- **Capacidad grande (100+):** Para escenarios de alto rendimiento\n\n```hemlock\nlet signal_ch = channel(1);      // Coordinacion\nlet work_ch = channel(50);       // Cola de trabajo\nlet buffer_ch = channel(1000);   // Alto rendimiento\n```\n\n### 5. Desacoplar Solo Cuando Sea Necesario\n\nPreferir `join()` sobre `detach()` para mejor gestion de recursos:\n\n```hemlock\n// Bueno: Unir y obtener resultado\nlet task = spawn(work);\nlet result = join(task);\n\n// Usar detach solo para verdadero disparar y olvidar\nlet bg_task = spawn(background_logging);\ndetach(bg_task);  // Se ejecutara independientemente\n```\n\n## Caracteristicas de Rendimiento\n\n### Verdadero Paralelismo\n\n- **N tareas creadas pueden utilizar N nucleos de CPU simultaneamente**\n- Aceleracion probada - pruebas de estres muestran 8-9x tiempo de CPU vs tiempo real (multiples nucleos trabajando)\n- Escalado lineal con numero de nucleos (hasta el conteo de hilos)\n\n### Sobrecarga de Hilos\n\n- Cada tarea tiene ~8KB de pila + sobrecarga de pthread\n- Costo de creacion de hilo: ~10-20us\n- Costo de cambio de contexto: ~1-5us\n\n### Cuando Usar Async\n\n**Buenos casos de uso:**\n- Computaciones intensivas de CPU que pueden paralelizarse\n- Operaciones limitadas por I/O (aunque I/O sigue siendo bloqueante)\n- Procesamiento concurrente de datos independientes\n- Arquitecturas de pipeline con canales\n\n**No ideal para:**\n- Tareas muy cortas (la sobrecarga de hilos domina)\n- Tareas con sincronizacion pesada (sobrecarga de contencion)\n- Sistemas de un solo nucleo (sin beneficio de paralelismo)\n\n### I/O Bloqueante Seguro\n\nLas operaciones bloqueantes en una tarea no bloquean otras:\n\n```hemlock\nasync fn reader(filename: string) {\n    let f = open(filename, \"r\");  // Bloquea solo este hilo\n    let content = f.read();       // Bloquea solo este hilo\n    f.close();\n    return content;\n}\n\n// Ambos leen concurrentemente (en diferentes hilos)\nlet t1 = spawn(reader, \"file1.txt\");\nlet t2 = spawn(reader, \"file2.txt\");\n\nlet c1 = join(t1);\nlet c2 = join(t2);\n```\n\n## Modelo de Seguridad de Hilos\n\nHemlock usa un modelo de concurrencia de **paso de mensajes** donde las tareas se comunican via canales en lugar de estado mutable compartido.\n\n### Aislamiento de Argumentos\n\nCuando creas una tarea, **los argumentos se copian profundamente** para prevenir carreras de datos:\n\n```hemlock\nasync fn modify_array(arr: array): array {\n    arr.push(999);    // Modifica la COPIA, no el original\n    arr[0] = -1;\n    return arr;\n}\n\nlet original = [1, 2, 3];\nlet task = spawn(modify_array, original);\nlet modified = join(task);\n\nprint(original.length);  // 3 - sin cambios!\nprint(modified.length);  // 4 - tiene nuevo elemento\n```\n\n**Lo que se copia profundamente:**\n- Arrays (y todos los elementos recursivamente)\n- Objetos (y todos los campos recursivamente)\n- Strings\n- Buffers\n\n**Lo que se comparte (referencia retenida):**\n- Canales (el mecanismo de comunicacion - compartido intencionalmente)\n- Manejadores de tarea (para coordinacion)\n- Funciones (el codigo es inmutable)\n- Manejadores de archivo (el SO gestiona acceso concurrente)\n- Manejadores de socket (el SO gestiona acceso concurrente)\n\n**Lo que no puede pasarse:**\n- Punteros crudos (`ptr`) - usar `buffer` en su lugar\n\n### Por Que Paso de Mensajes?\n\nEsto sigue la filosofia de Hemlock de \"explicito sobre implicito\":\n\n```hemlock\n// MAL: Estado mutable compartido (causaria carreras de datos)\nlet counter = { value: 0 };\nlet t1 = spawn(fn() { counter.value = counter.value + 1; });  // Carrera!\nlet t2 = spawn(fn() { counter.value = counter.value + 1; });  // Carrera!\n\n// BIEN: Paso de mensajes via canales\nasync fn increment(ch) {\n    let val = ch.recv();\n    ch.send(val + 1);\n}\n\nlet ch = channel(1);\nch.send(0);\nlet t1 = spawn(increment, ch);\njoin(t1);\nlet result = ch.recv();  // 1 - sin condicion de carrera\n```\n\n### Seguridad de Hilos en Conteo de Referencias\n\nTodas las operaciones de conteo de referencias usan **operaciones atomicas** para prevenir errores de uso despues de liberar:\n- `string_retain/release` - atomico\n- `array_retain/release` - atomico\n- `object_retain/release` - atomico\n- `buffer_retain/release` - atomico\n- `function_retain/release` - atomico\n- `channel_retain/release` - atomico\n- `task_retain/release` - atomico\n\nEsto asegura gestion de memoria segura incluso cuando los valores se comparten entre hilos.\n\n### Acceso al Entorno de Clausura\n\nLas tareas tienen acceso al entorno de clausura para:\n- Funciones integradas (`print`, `len`, etc.)\n- Definiciones de funciones globales\n- Constantes y variables\n\nEl entorno de clausura esta protegido por un mutex por entorno, haciendo\nlas lecturas y escrituras concurrentes seguras para hilos:\n\n```hemlock\nlet x = 10;\n\nasync fn read_closure(): i32 {\n    return x;  // OK: leyendo variable de clausura (seguro para hilos)\n}\n\nasync fn modify_closure() {\n    x = 20;  // OK: escribiendo variable de clausura (sincronizado con mutex)\n}\n```\n\n**Nota:** Aunque el acceso concurrente esta sincronizado, modificar estado compartido desde\nmultiples tareas todavia puede llevar a condiciones de carrera logicas (ordenamiento\nno determinista). Para comportamiento predecible, usa canales para comunicacion de tareas o\nvalores de retorno de tareas.\n\nSi necesitas retornar datos de una tarea, usa el valor de retorno o canales.\n\n## Limitaciones Actuales\n\n### 1. Sin Planificador con Robo de Trabajo\n\nUsa 1 hilo por tarea, lo cual puede ser ineficiente para muchas tareas cortas.\n\n**Actual:** 1000 tareas = 1000 hilos (sobrecarga pesada)\n\n**Planeado:** Pool de hilos con robo de trabajo para mejor eficiencia\n\n### 3. Sin Integracion de I/O Async\n\nLas operaciones de archivo/red todavia bloquean el hilo:\n\n```hemlock\nasync fn read_file(path: string) {\n    let f = open(path, \"r\");\n    let content = f.read();  // Bloquea el hilo\n    f.close();\n    return content;\n}\n```\n\n**Solucion temporal:** Usar multiples hilos para operaciones de I/O concurrentes\n\n### 4. Capacidad de Canal Fija\n\nLa capacidad del canal se establece en la creacion y no puede redimensionarse:\n\n```hemlock\nlet ch = channel(10);\n// No puede redimensionarse dinamicamente a 20\n```\n\n### 5. El Tamano del Canal es Fijo\n\nEl tamano del buffer del canal no puede cambiarse despues de la creacion.\n\n## Patrones Comunes\n\n### Map Paralelo\n\n```hemlock\nasync fn map_worker(ch_in, ch_out, fn_transform) {\n    while (true) {\n        let val = ch_in.recv();\n        if (val == null) { break; }\n\n        let result = fn_transform(val);\n        ch_out.send(result);\n    }\n    ch_out.close();\n}\n\nfn parallel_map(data, fn_transform, workers: i32) {\n    let ch_in = channel(100);\n    let ch_out = channel(100);\n\n    // Crear workers\n    let tasks = [];\n    let i = 0;\n    while (i < workers) {\n        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));\n        i = i + 1;\n    }\n\n    // Enviar datos\n    let i = 0;\n    while (i < data.length) {\n        ch_in.send(data[i]);\n        i = i + 1;\n    }\n    ch_in.close();\n\n    // Recolectar resultados\n    let results = [];\n    let i = 0;\n    while (i < data.length) {\n        results.push(ch_out.recv());\n        i = i + 1;\n    }\n\n    // Esperar a los workers\n    let i = 0;\n    while (i < tasks.length) {\n        join(tasks[i]);\n        i = i + 1;\n    }\n\n    return results;\n}\n```\n\n### Arquitectura de Pipeline\n\n```hemlock\nasync fn stage1(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val * 2);\n    }\n    output_ch.close();\n}\n\nasync fn stage2(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val + 10);\n    }\n    output_ch.close();\n}\n\n// Crear pipeline\nlet ch1 = channel(10);\nlet ch2 = channel(10);\nlet ch3 = channel(10);\n\nlet s1 = spawn(stage1, ch1, ch2);\nlet s2 = spawn(stage2, ch2, ch3);\n\n// Alimentar entrada\nch1.send(1);\nch1.send(2);\nch1.send(3);\nch1.close();\n\n// Recolectar salida\nprint(ch3.recv());  // 12 (1 * 2 + 10)\nprint(ch3.recv());  // 14 (2 * 2 + 10)\nprint(ch3.recv());  // 16 (3 * 2 + 10)\n\njoin(s1);\njoin(s2);\n```\n\n### Fan-Out, Fan-In\n\n```hemlock\nasync fn worker(id: i32, input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n\n        // Procesar valor\n        let result = val * id;\n        output_ch.send(result);\n    }\n}\n\nlet input = channel(10);\nlet output = channel(10);\n\n// Fan-out: Multiples workers\nlet workers = 4;\nlet tasks = [];\nlet i = 0;\nwhile (i < workers) {\n    tasks.push(spawn(worker, i, input, output));\n    i = i + 1;\n}\n\n// Enviar trabajo\nlet i = 0;\nwhile (i < 10) {\n    input.send(i);\n    i = i + 1;\n}\ninput.close();\n\n// Fan-in: Recolectar todos los resultados\nlet results = [];\nlet i = 0;\nwhile (i < 10) {\n    results.push(output.recv());\n    i = i + 1;\n}\n\n// Esperar a todos los workers\nlet i = 0;\nwhile (i < tasks.length) {\n    join(tasks[i]);\n    i = i + 1;\n}\n```\n\n## Resumen\n\nEl modelo de async/concurrencia de Hemlock proporciona:\n\n-  Verdadero paralelismo multihilo usando hilos del SO\n-  Primitivas de concurrencia estructurada simples\n-  Canales seguros para hilos para comunicacion\n-  Propagacion de excepciones a traves de tareas\n-  Rendimiento probado en sistemas multinucleo\n-  **Aislamiento de argumentos** - copia profunda previene carreras de datos\n-  **Conteo de referencias atomico** - gestion de memoria segura a traves de hilos\n\nEsto hace que Hemlock sea adecuado para:\n- Computaciones paralelas\n- Operaciones de I/O concurrentes\n- Arquitecturas de pipeline\n- Patrones productor-consumidor\n\nMientras evita la complejidad de:\n- Gestion manual de hilos\n- Primitivas de sincronizacion de bajo nivel\n- Disenos basados en bloqueos propensos a deadlocks\n- Errores de estado mutable compartido\n"}, "Temas Avanzados -> Ejecucin de Comandos": {"id": "advanced-command-execution", "content": "# Ejecucion de Comandos en Hemlock\n\nHemlock proporciona la **funcion integrada `exec()`** para ejecutar comandos de shell y capturar su salida.\n\n## Tabla de Contenidos\n\n- [Vision General](#vision-general)\n- [La Funcion exec()](#la-funcion-exec)\n- [Objeto de Resultado](#objeto-de-resultado)\n- [Uso Basico](#uso-basico)\n- [Ejemplos Avanzados](#ejemplos-avanzados)\n- [Manejo de Errores](#manejo-de-errores)\n- [Detalles de Implementacion](#detalles-de-implementacion)\n- [Consideraciones de Seguridad](#consideraciones-de-seguridad)\n- [Limitaciones](#limitaciones)\n- [Casos de Uso](#casos-de-uso)\n- [Mejores Practicas](#mejores-practicas)\n- [Ejemplos Completos](#ejemplos-completos)\n\n## Vision General\n\nLa funcion `exec()` permite a los programas de Hemlock:\n- Ejecutar comandos de shell\n- Capturar salida estandar (stdout)\n- Verificar codigos de estado de salida\n- Usar caracteristicas del shell (pipes, redirecciones, etc.)\n- Integrarse con utilidades del sistema\n\n**Importante:** Los comandos se ejecutan via `/bin/sh`, dando capacidades completas del shell pero tambien introduciendo consideraciones de seguridad.\n\n## La Funcion exec()\n\n### Firma\n\n```hemlock\nexec(command: string): object\n```\n\n**Parametros:**\n- `command` (string) - Comando de shell a ejecutar\n\n**Retorna:** Un objeto con dos campos:\n- `output` (string) - La salida stdout del comando\n- `exit_code` (i32) - El codigo de estado de salida del comando\n\n### Ejemplo Basico\n\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n```\n\n## Objeto de Resultado\n\nEl objeto retornado por `exec()` tiene la siguiente estructura:\n\n```hemlock\n{\n    output: string,      // stdout del comando (salida capturada)\n    exit_code: i32       // Estado de salida del proceso (0 = exito)\n}\n```\n\n### Campo output\n\nContiene todo el texto escrito a stdout por el comando.\n\n**Propiedades:**\n- Cadena vacia si el comando no produce salida\n- Incluye saltos de linea y espacios en blanco tal cual\n- Salida multi-linea preservada\n- Sin limite de tamano (asignado dinamicamente)\n\n**Ejemplos:**\n```hemlock\nlet r1 = exec(\"echo test\");\nprint(r1.output);  // \"test\\n\"\n\nlet r2 = exec(\"ls\");\nprint(r2.output);  // Listado de directorio con saltos de linea\n\nlet r3 = exec(\"true\");\nprint(r3.output);  // \"\" (cadena vacia)\n```\n\n### Campo exit_code\n\nEl codigo de estado de salida del comando.\n\n**Valores:**\n- `0` tipicamente indica exito\n- `1-255` indican errores (la convencion varia por comando)\n- `-1` si el comando no pudo ejecutarse o termino anormalmente\n\n**Ejemplos:**\n```hemlock\nlet r1 = exec(\"true\");\nprint(r1.exit_code);  // 0 (exito)\n\nlet r2 = exec(\"false\");\nprint(r2.exit_code);  // 1 (fallo)\n\nlet r3 = exec(\"ls /nonexistent\");\nprint(r3.exit_code);  // 2 (archivo no encontrado, varia por comando)\n```\n\n## Uso Basico\n\n### Comando Simple\n\n```hemlock\nlet r = exec(\"ls -la\");\nprint(r.output);\nprint(\"Exit code: \" + typeof(r.exit_code));\n```\n\n### Verificando Estado de Salida\n\n```hemlock\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Found: \" + r.output);\n} else {\n    print(\"Pattern not found\");\n}\n```\n\n### Comandos con Pipes\n\n```hemlock\nlet r = exec(\"ps aux | grep hemlock\");\nprint(r.output);\n```\n\n### Multiples Comandos\n\n```hemlock\nlet r = exec(\"cd /tmp && ls -la\");\nprint(r.output);\n```\n\n### Sustitucion de Comandos\n\n```hemlock\nlet r = exec(\"echo $(date)\");\nprint(r.output);  // Fecha actual\n```\n\n## Ejemplos Avanzados\n\n### Manejando Fallos\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\nif (r.exit_code != 0) {\n    print(\"Command failed with code: \" + typeof(r.exit_code));\n    print(\"Error output: \" + r.output);  // Nota: stderr no se captura\n}\n```\n\n### Procesando Salida Multi-Linea\n\n```hemlock\nlet r = exec(\"cat file.txt\");\nlet lines = r.output.split(\"\\n\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### Encadenamiento de Comandos\n\n**Con && (AND):**\n```hemlock\nlet r1 = exec(\"mkdir -p /tmp/test && touch /tmp/test/file.txt\");\nif (r1.exit_code == 0) {\n    print(\"Setup complete\");\n}\n```\n\n**Con || (OR):**\n```hemlock\nlet r = exec(\"command1 || command2\");\n// Ejecuta command2 solo si command1 falla\n```\n\n**Con ; (secuencia):**\n```hemlock\nlet r = exec(\"command1; command2\");\n// Ejecuta ambos independientemente del exito/fallo\n```\n\n### Usando Pipes\n\n```hemlock\nlet r = exec(\"echo 'data' | base64\");\nprint(\"Base64: \" + r.output);\n```\n\n**Pipelines complejos:**\n```hemlock\nlet r = exec(\"cat /etc/passwd | grep root | cut -d: -f1\");\nprint(r.output);\n```\n\n### Patrones de Codigo de Salida\n\nDiferentes codigos de salida indican diferentes condiciones:\n\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n} else if (r.exit_code == 1) {\n    print(\"File does not exist\");\n} else {\n    print(\"Test command failed: \" + typeof(r.exit_code));\n}\n```\n\n### Redirecciones de Salida\n\n```hemlock\n// Redirigir stdout a archivo (dentro del shell)\nlet r1 = exec(\"echo 'test' > /tmp/output.txt\");\n\n// Redirigir stderr a stdout (Nota: stderr todavia no se captura por Hemlock)\nlet r2 = exec(\"command 2>&1\");\n```\n\n### Variables de Entorno\n\n```hemlock\nlet r = exec(\"export VAR=value && echo $VAR\");\nprint(r.output);  // \"value\\n\"\n```\n\n### Cambios de Directorio de Trabajo\n\n```hemlock\nlet r = exec(\"cd /tmp && pwd\");\nprint(r.output);  // \"/tmp\\n\"\n```\n\n## Manejo de Errores\n\n### Cuando exec() Lanza Excepciones\n\nLa funcion `exec()` lanza una excepcion si el comando no puede ejecutarse:\n\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command_xyz\");\n} catch (e) {\n    print(\"Failed to execute: \" + e);\n}\n```\n\n**Se lanzan excepciones cuando:**\n- `popen()` falla (ej. no puede crear pipe)\n- Se exceden los limites de recursos del sistema\n- Fallos de asignacion de memoria\n\n### Cuando exec() NO Lanza\n\n```hemlock\n// El comando se ejecuta pero retorna codigo de salida no cero\nlet r1 = exec(\"false\");\nprint(r1.exit_code);  // 1 (no es una excepcion)\n\n// El comando no produce salida\nlet r2 = exec(\"true\");\nprint(r2.output);  // \"\" (no es una excepcion)\n\n// Comando no encontrado por el shell\nlet r3 = exec(\"nonexistent_cmd\");\nprint(r3.exit_code);  // 127 (no es una excepcion)\n```\n\n### Patron de Ejecucion Segura\n\n```hemlock\nfn safe_exec(command: string) {\n    try {\n        let r = exec(command);\n        if (r.exit_code != 0) {\n            print(\"Warning: Command failed with code \" + typeof(r.exit_code));\n            return \"\";\n        }\n        return r.output;\n    } catch (e) {\n        print(\"Error executing command: \" + e);\n        return \"\";\n    }\n}\n\nlet output = safe_exec(\"ls -la\");\n```\n\n## Detalles de Implementacion\n\n### Como Funciona\n\n**Bajo el capo:**\n- Usa `popen()` para ejecutar comandos via `/bin/sh`\n- Captura solo stdout (stderr no se captura)\n- Salida almacenada dinamicamente (comienza en 4KB, crece segun necesidad)\n- Estado de salida extraido usando macros `WIFEXITED()` y `WEXITSTATUS()`\n- Cadena de salida correctamente terminada en null\n\n**Flujo del proceso:**\n1. `popen(command, \"r\")` crea pipe y bifurca el proceso\n2. El proceso hijo ejecuta `/bin/sh -c \"command\"`\n3. El padre lee stdout via pipe a buffer creciente\n4. `pclose()` espera al hijo y retorna estado de salida\n5. Estado de salida se extrae y almacena en objeto de resultado\n\n### Consideraciones de Rendimiento\n\n**Costos:**\n- Crea un nuevo proceso de shell para cada llamada (~1-5ms de sobrecarga)\n- Salida almacenada completamente en memoria (no transmitida)\n- Sin soporte de streaming (espera a que el comando complete)\n- Adecuado para comandos con tamanos de salida razonables\n\n**Optimizaciones:**\n- Buffer comienza en 4KB y se duplica cuando esta lleno (uso eficiente de memoria)\n- Bucle de lectura unico minimiza llamadas al sistema\n- Sin copia adicional de strings\n\n**Cuando usar:**\n- Comandos de corta duracion (< 1 segundo)\n- Tamano de salida moderado (< 10MB)\n- Operaciones por lotes con intervalos razonables\n\n**Cuando NO usar:**\n- Daemons o servicios de larga duracion\n- Comandos que producen gigabytes de salida\n- Procesamiento de datos de streaming en tiempo real\n- Ejecucion de alta frecuencia (> 100 llamadas/segundo)\n\n## Consideraciones de Seguridad\n\n### Riesgo de Inyeccion de Shell\n\n **CRITICO:** Los comandos son ejecutados por el shell (`/bin/sh`), lo que significa que **la inyeccion de shell es posible**.\n\n**Codigo vulnerable:**\n```hemlock\n// PELIGROSO - NO HACER ESTO\nlet filename = args[1];  // Entrada de usuario\nlet r = exec(\"cat \" + filename);  // Inyeccion de shell!\n```\n\n**Ataque:**\n```bash\n./hemlock script.hml \"; rm -rf /; echo pwned\"\n# Ejecuta: cat ; rm -rf /; echo pwned\n```\n\n### Practicas Seguras\n\n**1. Nunca usar entrada de usuario sin sanitizar:**\n```hemlock\n// Malo\nlet user_input = args[1];\nlet r = exec(\"process \" + user_input);  // PELIGROSO\n\n// Bueno - validar primero\nfn is_safe_filename(name: string): bool {\n    // Solo permitir alfanumericos, guion, guion bajo, punto\n    let i = 0;\n    while (i < name.length) {\n        let c = name[i];\n        if (!(c >= 'a' && c <= 'z') &&\n            !(c >= 'A' && c <= 'Z') &&\n            !(c >= '0' && c <= '9') &&\n            c != '-' && c != '_' && c != '.') {\n            return false;\n        }\n        i = i + 1;\n    }\n    return true;\n}\n\nlet filename = args[1];\nif (is_safe_filename(filename)) {\n    let r = exec(\"cat \" + filename);\n} else {\n    print(\"Invalid filename\");\n}\n```\n\n**2. Usar listas permitidas, no listas denegadas:**\n```hemlock\n// Bueno - lista estricta de permitidos\nlet allowed_commands = [\"status\", \"start\", \"stop\", \"restart\"];\nlet cmd = args[1];\n\nlet found = false;\nfor (let allowed in allowed_commands) {\n    if (cmd == allowed) {\n        found = true;\n        break;\n    }\n}\n\nif (found) {\n    exec(\"service myapp \" + cmd);\n} else {\n    print(\"Invalid command\");\n}\n```\n\n**3. Escapar caracteres especiales:**\n```hemlock\nfn shell_escape(s: string): string {\n    // Escape simple - envolver en comillas simples y escapar comillas simples\n    let escaped = s.replace_all(\"'\", \"'\\\\''\");\n    return \"'\" + escaped + \"'\";\n}\n\nlet user_file = args[1];\nlet safe = shell_escape(user_file);\nlet r = exec(\"cat \" + safe);\n```\n\n**4. Evitar exec() para operaciones de archivo:**\n```hemlock\n// Malo - usar exec para operaciones de archivo\nlet r = exec(\"cat file.txt\");\n\n// Bueno - usar API de archivos de Hemlock\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### Consideraciones de Permisos\n\nLos comandos se ejecutan con los mismos permisos que el proceso de Hemlock:\n\n```hemlock\n// Si Hemlock se ejecuta como root, los comandos exec() tambien se ejecutan como root!\nlet r = exec(\"rm -rf /important\");  // PELIGROSO si se ejecuta como root\n```\n\n**Mejor practica:** Ejecutar Hemlock con los privilegios minimos necesarios.\n\n## Limitaciones\n\n### 1. Sin Captura de stderr\n\nSolo stdout se captura, stderr va a la terminal:\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\n// r.output esta vacio\n// El mensaje de error aparece en la terminal, no se captura\n```\n\n**Solucion - redirigir stderr a stdout:**\n```hemlock\nlet r = exec(\"ls /nonexistent 2>&1\");\n// Ahora los mensajes de error estan en r.output\n```\n\n### 2. Sin Streaming\n\nDebe esperar a que el comando complete:\n\n```hemlock\nlet r = exec(\"long_running_command\");\n// Bloquea hasta que el comando termine\n// No puede procesar salida incrementalmente\n```\n\n### 3. Sin Timeout\n\nLos comandos pueden ejecutarse indefinidamente:\n\n```hemlock\nlet r = exec(\"sleep 1000\");\n// Bloquea por 1000 segundos\n// No hay forma de hacer timeout o cancelar\n```\n\n**Solucion - usar comando timeout:**\n```hemlock\nlet r = exec(\"timeout 5 long_command\");\n// Hara timeout despues de 5 segundos\n```\n\n### 4. Sin Manejo de Senales\n\nNo se pueden enviar senales a comandos en ejecucion:\n\n```hemlock\nlet r = exec(\"long_command\");\n// No se puede enviar SIGINT, SIGTERM, etc. al comando\n```\n\n### 5. Sin Control de Proceso\n\nNo se puede interactuar con el comando despues de iniciarlo:\n\n```hemlock\nlet r = exec(\"interactive_program\");\n// No se puede enviar entrada al programa\n// No se puede controlar la ejecucion\n```\n\n## Casos de Uso\n\n### Buenos Casos de Uso\n\n**1. Ejecutar utilidades del sistema:**\n```hemlock\nlet r = exec(\"ls -la\");\nlet r = exec(\"grep pattern file.txt\");\nlet r = exec(\"find /path -name '*.txt'\");\n```\n\n**2. Procesamiento rapido de datos con herramientas Unix:**\n```hemlock\nlet r = exec(\"cat data.txt | sort | uniq | wc -l\");\nprint(\"Unique lines: \" + r.output);\n```\n\n**3. Verificar estado del sistema:**\n```hemlock\nlet r = exec(\"df -h\");\nprint(\"Disk usage:\\n\" + r.output);\n```\n\n**4. Verificaciones de existencia de archivos:**\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n}\n```\n\n**5. Generar reportes:**\n```hemlock\nlet r = exec(\"ps aux | grep myapp | wc -l\");\nlet count = r.output.trim();\nprint(\"Running instances: \" + count);\n```\n\n**6. Scripts de automatizacion:**\n```hemlock\nexec(\"git add .\");\nexec(\"git commit -m 'Auto commit'\");\nlet r = exec(\"git push\");\nif (r.exit_code != 0) {\n    print(\"Push failed\");\n}\n```\n\n### No Recomendado Para\n\n**1. Servicios de larga duracion:**\n```hemlock\n// Malo\nlet r = exec(\"nginx\");  // Bloquea para siempre\n```\n\n**2. Comandos interactivos:**\n```hemlock\n// Malo - no puede proporcionar entrada\nlet r = exec(\"ssh user@host\");\n```\n\n**3. Comandos que producen salida enorme:**\n```hemlock\n// Malo - carga toda la salida en memoria\nlet r = exec(\"cat 10GB_file.log\");\n```\n\n**4. Streaming en tiempo real:**\n```hemlock\n// Malo - no puede procesar salida incrementalmente\nlet r = exec(\"tail -f /var/log/app.log\");\n```\n\n**5. Manejo de errores criticos para la mision:**\n```hemlock\n// Malo - stderr no se captura\nlet r = exec(\"critical_operation\");\n// No puede ver mensajes de error detallados\n```\n\n## Mejores Practicas\n\n### 1. Siempre Verificar Codigos de Salida\n\n```hemlock\nlet r = exec(\"important_command\");\nif (r.exit_code != 0) {\n    print(\"Command failed!\");\n    // Manejar error\n}\n```\n\n### 2. Recortar Salida Cuando Sea Necesario\n\n```hemlock\nlet r = exec(\"echo test\");\nlet clean = r.output.trim();  // Remover salto de linea final\nprint(clean);  // \"test\" (sin salto de linea)\n```\n\n### 3. Validar Antes de Ejecutar\n\n```hemlock\nfn is_valid_command(cmd: string): bool {\n    // Validar que el comando es seguro\n    return true;  // Tu logica de validacion\n}\n\nif (is_valid_command(user_cmd)) {\n    exec(user_cmd);\n}\n```\n\n### 4. Usar try/catch para Operaciones Criticas\n\n```hemlock\ntry {\n    let r = exec(\"critical_command\");\n    if (r.exit_code != 0) {\n        throw \"Command failed\";\n    }\n} catch (e) {\n    print(\"Error: \" + e);\n    // Limpieza o recuperacion\n}\n```\n\n### 5. Preferir APIs de Hemlock Sobre exec()\n\n```hemlock\n// Malo - usar exec para operaciones de archivo\nlet r = exec(\"cat file.txt\");\n\n// Bueno - usar API de archivos de Hemlock\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### 6. Capturar stderr Cuando Sea Necesario\n\n```hemlock\n// Redirigir stderr a stdout\nlet r = exec(\"command 2>&1\");\n// Ahora r.output contiene tanto stdout como stderr\n```\n\n### 7. Usar Caracteristicas del Shell Sabiamente\n\n```hemlock\n// Usar pipes para eficiencia\nlet r = exec(\"cat large.txt | grep pattern | head -n 10\");\n\n// Usar sustitucion de comandos\nlet r = exec(\"echo Current user: $(whoami)\");\n\n// Usar ejecucion condicional\nlet r = exec(\"test -f file.txt && cat file.txt\");\n```\n\n## Ejemplos Completos\n\n### Ejemplo 1: Recopilador de Informacion del Sistema\n\n```hemlock\nfn get_system_info() {\n    print(\"=== System Information ===\");\n\n    // Nombre de host\n    let r1 = exec(\"hostname\");\n    print(\"Hostname: \" + r1.output.trim());\n\n    // Uptime\n    let r2 = exec(\"uptime\");\n    print(\"Uptime: \" + r2.output.trim());\n\n    // Uso de disco\n    let r3 = exec(\"df -h /\");\n    print(\"\\nDisk Usage:\");\n    print(r3.output);\n\n    // Uso de memoria\n    let r4 = exec(\"free -h\");\n    print(\"Memory Usage:\");\n    print(r4.output);\n}\n\nget_system_info();\n```\n\n### Ejemplo 2: Analizador de Logs\n\n```hemlock\nfn analyze_log(logfile: string) {\n    print(\"Analyzing log: \" + logfile);\n\n    // Contar lineas totales\n    let r1 = exec(\"wc -l \" + logfile);\n    print(\"Total lines: \" + r1.output.trim());\n\n    // Contar errores\n    let r2 = exec(\"grep -c ERROR \" + logfile + \" 2>/dev/null\");\n    let errors = r2.output.trim();\n    if (r2.exit_code == 0) {\n        print(\"Errors: \" + errors);\n    } else {\n        print(\"Errors: 0\");\n    }\n\n    // Contar advertencias\n    let r3 = exec(\"grep -c WARN \" + logfile + \" 2>/dev/null\");\n    let warnings = r3.output.trim();\n    if (r3.exit_code == 0) {\n        print(\"Warnings: \" + warnings);\n    } else {\n        print(\"Warnings: 0\");\n    }\n\n    // Errores recientes\n    print(\"\\nRecent errors:\");\n    let r4 = exec(\"grep ERROR \" + logfile + \" | tail -n 5\");\n    print(r4.output);\n}\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <logfile>\");\n} else {\n    analyze_log(args[1]);\n}\n```\n\n### Ejemplo 3: Ayudante de Git\n\n```hemlock\nfn git_status() {\n    let r = exec(\"git status --short\");\n    if (r.exit_code != 0) {\n        print(\"Error: Not a git repository\");\n        return;\n    }\n\n    if (r.output == \"\") {\n        print(\"Working directory clean\");\n    } else {\n        print(\"Changes:\");\n        print(r.output);\n    }\n}\n\nfn git_quick_commit(message: string) {\n    print(\"Adding all changes...\");\n    let r1 = exec(\"git add -A\");\n    if (r1.exit_code != 0) {\n        print(\"Error adding files\");\n        return;\n    }\n\n    print(\"Committing...\");\n    let safe_msg = message.replace_all(\"'\", \"'\\\\''\");\n    let r2 = exec(\"git commit -m '\" + safe_msg + \"'\");\n    if (r2.exit_code != 0) {\n        print(\"Error committing\");\n        return;\n    }\n\n    print(\"Committed successfully\");\n    print(r2.output);\n}\n\n// Uso\ngit_status();\nif (args.length > 1) {\n    git_quick_commit(args[1]);\n}\n```\n\n### Ejemplo 4: Script de Respaldo\n\n```hemlock\nfn backup_directory(source: string, dest: string) {\n    print(\"Backing up \" + source + \" to \" + dest);\n\n    // Crear directorio de respaldo\n    let r1 = exec(\"mkdir -p \" + dest);\n    if (r1.exit_code != 0) {\n        print(\"Error creating backup directory\");\n        return false;\n    }\n\n    // Crear tarball con marca de tiempo\n    let r2 = exec(\"date +%Y%m%d_%H%M%S\");\n    let timestamp = r2.output.trim();\n    let backup_file = dest + \"/backup_\" + timestamp + \".tar.gz\";\n\n    print(\"Creating archive: \" + backup_file);\n    let r3 = exec(\"tar -czf \" + backup_file + \" \" + source + \" 2>&1\");\n    if (r3.exit_code != 0) {\n        print(\"Error creating backup:\");\n        print(r3.output);\n        return false;\n    }\n\n    print(\"Backup completed successfully\");\n\n    // Mostrar tamano del respaldo\n    let r4 = exec(\"du -h \" + backup_file);\n    print(\"Backup size: \" + r4.output.trim());\n\n    return true;\n}\n\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <source> <destination>\");\n} else {\n    backup_directory(args[1], args[2]);\n}\n```\n\n## Resumen\n\nLa funcion `exec()` de Hemlock proporciona:\n\n-  Ejecucion simple de comandos de shell\n-  Captura de salida (stdout)\n-  Verificacion de codigo de salida\n-  Acceso completo a caracteristicas del shell (pipes, redirecciones, etc.)\n-  Integracion con utilidades del sistema\n\nRecuerda:\n- Siempre verificar codigos de salida\n- Estar consciente de las implicaciones de seguridad (inyeccion de shell)\n- Validar entrada de usuario antes de usar en comandos\n- Preferir APIs de Hemlock sobre exec() cuando esten disponibles\n- stderr no se captura (usar `2>&1` para redirigir)\n- Los comandos bloquean hasta completar\n- Usar para utilidades de corta duracion, no servicios de larga duracion\n\n**Lista de verificacion de seguridad:**\n-  Nunca usar entrada de usuario sin sanitizar\n-  Validar toda entrada\n-  Usar listas de permitidos para comandos\n-  Escapar caracteres especiales cuando sea necesario\n-  Ejecutar con privilegios minimos\n-  Preferir APIs de Hemlock sobre comandos de shell\n"}, "Temas Avanzados -> Empaquetado y Distribucin": {"id": "advanced-bundling-packaging", "content": "# Empaquetado y Distribucion\n\nHemlock proporciona herramientas integradas para empaquetar proyectos de multiples archivos en archivos distribuibles unicos y crear ejecutables autocontenidos.\n\n## Vision General\n\n| Comando | Salida | Caso de Uso |\n|---------|--------|-------------|\n| `--bundle` | `.hmlc` o `.hmlb` | Distribuir bytecode (requiere Hemlock para ejecutar) |\n| `--package` | Ejecutable | Binario independiente (sin dependencias) |\n| `--compile` | `.hmlc` | Compilar archivo unico (sin resolucion de imports) |\n\n## Empaquetado (Bundling)\n\nEl empaquetador resuelve todas las sentencias `import` desde un punto de entrada y las aplana en un solo archivo.\n\n### Uso Basico\n\n```bash\n# Empaquetar app.hml y todos sus imports en app.hmlc\nhemlock --bundle app.hml\n\n# Especificar ruta de salida\nhemlock --bundle app.hml -o dist/app.hmlc\n\n# Crear paquete comprimido (.hmlb) - tamano de archivo mas pequeno\nhemlock --bundle app.hml --compress -o app.hmlb\n\n# Salida detallada (muestra modulos resueltos)\nhemlock --bundle app.hml --verbose\n```\n\n### Formatos de Salida\n\n**`.hmlc` (Sin comprimir)**\n- Formato AST serializado\n- Rapido de cargar y ejecutar\n- Formato de salida por defecto\n\n**`.hmlb` (Comprimido)**\n- `.hmlc` comprimido con zlib\n- Tamano de archivo mas pequeno (tipicamente 50-70% de reduccion)\n- Inicio ligeramente mas lento debido a la descompresion\n\n### Ejecutando Archivos Empaquetados\n\n```bash\n# Ejecutar paquete sin comprimir\nhemlock app.hmlc\n\n# Ejecutar paquete comprimido\nhemlock app.hmlb\n\n# Pasar argumentos\nhemlock app.hmlc arg1 arg2\n```\n\n### Ejemplo: Proyecto Multi-Modulo\n\n```\nmyapp/\n main.hml\n lib/\n    math.hml\n    utils.hml\n config.hml\n```\n\n```hemlock\n// main.hml\nimport { add, multiply } from \"./lib/math.hml\";\nimport { log } from \"./lib/utils.hml\";\nimport { VERSION } from \"./config.hml\";\n\nlog(`App v${VERSION}`);\nprint(add(2, 3));\n```\n\n```bash\nhemlock --bundle myapp/main.hml -o myapp.hmlc\nhemlock myapp.hmlc  # Se ejecuta con todas las dependencias empaquetadas\n```\n\n### Imports de stdlib\n\nEl empaquetador resuelve automaticamente imports de `@stdlib/`:\n\n```hemlock\nimport { HashMap } from \"@stdlib/collections\";\nimport { now } from \"@stdlib/time\";\n```\n\nCuando se empaqueta, los modulos de stdlib se incluyen en la salida.\n\n## Empaquetado como Ejecutable\n\nEl empaquetado crea un ejecutable autocontenido incrustando el bytecode empaquetado en una copia del interprete de Hemlock.\n\n### Uso Basico\n\n```bash\n# Crear ejecutable desde app.hml\nhemlock --package app.hml\n\n# Especificar nombre de salida\nhemlock --package app.hml -o myapp\n\n# Saltar compresion (inicio mas rapido, archivo mas grande)\nhemlock --package app.hml --no-compress\n\n# Salida detallada\nhemlock --package app.hml --verbose\n```\n\n### Ejecutando Ejecutables Empaquetados\n\n```bash\n# El ejecutable empaquetado se ejecuta directamente\n./myapp\n\n# Los argumentos se pasan al script\n./myapp arg1 arg2\n```\n\n### Formato de Paquete\n\nLos ejecutables empaquetados usan el formato HMLP:\n\n```\n[binario hemlock][carga HMLB/HMLC][tamano_carga:u64][magic HMLP:u32]\n```\n\nCuando un ejecutable empaquetado se ejecuta:\n1. Verifica si hay una carga incrustada al final del archivo\n2. Si la encuentra, descomprime y ejecuta la carga\n3. Si no la encuentra, se comporta como un interprete normal de Hemlock\n\n### Opciones de Compresion\n\n| Flag | Formato | Inicio | Tamano |\n|------|---------|--------|--------|\n| (por defecto) | HMLB | Normal | Mas pequeno |\n| `--no-compress` | HMLC | Mas rapido | Mas grande |\n\nPara herramientas CLI donde el tiempo de inicio importa, usa `--no-compress`.\n\n## Inspeccionando Paquetes\n\nUsa `--info` para inspeccionar archivos empaquetados o compilados:\n\n```bash\nhemlock --info app.hmlc\n```\n\nSalida:\n```\n=== File Info: app.hmlc ===\nSize: 12847 bytes\nFormat: HMLC (compiled AST)\nVersion: 1\nFlags: 0x0001 [DEBUG]\nStrings: 42\nStatements: 156\n```\n\n```bash\nhemlock --info app.hmlb\n```\n\nSalida:\n```\n=== File Info: app.hmlb ===\nSize: 5234 bytes\nFormat: HMLB (compressed bundle)\nVersion: 1\nUncompressed: 12847 bytes\nCompressed: 5224 bytes\nRatio: 59.3% reduction\n```\n\n## Compilacion Nativa\n\nPara ejecutables verdaderamente nativos (sin interprete), usa el compilador de Hemlock:\n\n```bash\n# Compilar a ejecutable nativo via C\nhemlockc app.hml -o app\n\n# Mantener codigo C generado\nhemlockc app.hml -o app --keep-c\n\n# Emitir solo C (no compilar)\nhemlockc app.hml -c -o app.c\n\n# Nivel de optimizacion\nhemlockc app.hml -o app -O2\n```\n\nEl compilador genera codigo C e invoca GCC para producir un binario nativo. Esto requiere:\n- La biblioteca de runtime de Hemlock (`libhemlock_runtime`)\n- Un compilador de C (GCC por defecto)\n\n### Opciones del Compilador\n\n| Opcion | Descripcion |\n|--------|-------------|\n| `-o <file>` | Nombre del ejecutable de salida |\n| `-c` | Emitir solo codigo C |\n| `--emit-c <file>` | Escribir C al archivo especificado |\n| `-k, --keep-c` | Mantener C generado despues de compilacion |\n| `-O<level>` | Nivel de optimizacion (0-3) |\n| `--cc <path>` | Compilador de C a usar |\n| `--runtime <path>` | Ruta a la biblioteca de runtime |\n| `-v, --verbose` | Salida detallada |\n\n## Comparacion\n\n| Enfoque | Portabilidad | Inicio | Tamano | Dependencias |\n|---------|--------------|--------|--------|--------------|\n| `.hml` | Solo fuente | Tiempo de parseo | Mas pequeno | Hemlock |\n| `.hmlc` | Solo Hemlock | Rapido | Pequeno | Hemlock |\n| `.hmlb` | Solo Hemlock | Rapido | Mas pequeno | Hemlock |\n| `--package` | Independiente | Rapido | Mas grande | Ninguna |\n| `hemlockc` | Nativo | Mas rapido | Variable | Libs de runtime |\n\n## Mejores Practicas\n\n1. **Desarrollo**: Ejecutar archivos `.hml` directamente para iteracion rapida\n2. **Distribucion (con Hemlock)**: Empaquetar con `--compress` para archivos mas pequenos\n3. **Distribucion (independiente)**: Empaquetar como ejecutable para despliegue sin dependencias\n4. **Critico en rendimiento**: Usar `hemlockc` para compilacion nativa\n\n## Solucion de Problemas\n\n### \"Cannot find stdlib\"\n\nEl empaquetador busca stdlib en:\n1. `./stdlib` (relativo al ejecutable)\n2. `../stdlib` (relativo al ejecutable)\n3. `/usr/local/lib/hemlock/stdlib`\n\nAsegurate de que Hemlock este correctamente instalado o ejecuta desde el directorio fuente.\n\n### Dependencias Circulares\n\n```\nError: Circular dependency detected when loading 'path/to/module.hml'\n```\n\nRefactoriza tus imports para romper el ciclo. Considera usar un modulo compartido para tipos comunes.\n\n### Tamano Grande de Paquete\n\n- Usa compresion por defecto (no uses `--no-compress`)\n- El tamano empaquetado incluye el interprete completo (~500KB-1MB base)\n- Para tamano minimo, usa `hemlockc` para compilacion nativa\n"}, "Temas Avanzados -> FFI": {"id": "advanced-ffi", "content": "# Interfaz de Funciones Foraneas (FFI) en Hemlock\n\nHemlock proporciona **FFI (Interfaz de Funciones Foraneas)** para llamar funciones de C desde bibliotecas compartidas usando libffi, habilitando la integracion con bibliotecas C existentes y APIs del sistema.\n\n## Tabla de Contenidos\n\n- [Vision General](#vision-general)\n- [Estado Actual](#estado-actual)\n- [Tipos Soportados](#tipos-soportados)\n- [Conceptos Basicos](#conceptos-basicos)\n- [Exportando Funciones FFI](#exportando-funciones-ffi)\n- [Casos de Uso](#casos-de-uso)\n- [Desarrollo Futuro](#desarrollo-futuro)\n- [Callbacks FFI](#callbacks-ffi)\n- [Structs FFI](#structs-ffi)\n- [Exportando Tipos de Struct](#exportando-tipos-de-struct)\n- [Limitaciones Actuales](#limitaciones-actuales)\n- [Mejores Practicas](#mejores-practicas)\n\n## Vision General\n\nLa Interfaz de Funciones Foraneas (FFI) permite a los programas de Hemlock:\n- Llamar funciones de C desde bibliotecas compartidas (.so, .dylib, .dll)\n- Usar bibliotecas C existentes sin escribir codigo envolvente\n- Acceder a APIs del sistema directamente\n- Integrarse con bibliotecas nativas de terceros\n- Conectar Hemlock con funcionalidad de bajo nivel del sistema\n\n**Capacidades clave:**\n- Carga dinamica de bibliotecas\n- Vinculacion de funciones C\n- Conversion automatica de tipos entre Hemlock y tipos C\n- Soporte para todos los tipos primitivos\n- Implementacion basada en libffi para portabilidad\n\n## Estado Actual\n\nEl soporte FFI esta disponible en Hemlock con las siguientes caracteristicas:\n\n**Implementado:**\n-  Llamar funciones C desde bibliotecas compartidas\n-  Soporte para todos los tipos primitivos (enteros, flotantes, punteros)\n-  Conversion automatica de tipos\n-  Implementacion basada en libffi\n-  Carga dinamica de bibliotecas\n-  **Callbacks de punteros a funcion** - Pasar funciones de Hemlock a C\n-  **Exportar funciones extern** - Compartir bindings FFI entre modulos\n-  **Paso de structs y valores de retorno** - Pasar structs compatibles con C por valor\n-  **Ayudantes de puntero completos** - Leer/escribir todos los tipos (i8-i64, u8-u64, f32, f64, ptr)\n-  **Conversion buffer/puntero** - `buffer_ptr()`, `ptr_to_buffer()`\n-  **Tamanos de tipos FFI** - `ffi_sizeof()` para tamanos de tipo conscientes de la plataforma\n-  **Tipos de plataforma** - Soporte para `size_t`, `usize`, `isize`, `intptr_t`\n\n**En Desarrollo:**\n-  Ayudantes de marshaling de strings\n-  Mejoras en manejo de errores\n\n**Cobertura de Pruebas:**\n- Pruebas FFI pasando incluyendo pruebas de callback\n- Llamada basica de funciones verificada\n- Conversion de tipos probada\n- Integracion de callback qsort probada\n\n## Tipos Soportados\n\n### Tipos Primitivos\n\nLos siguientes tipos de Hemlock pueden pasarse a/desde funciones C:\n\n| Tipo Hemlock | Tipo C | Tamano | Notas |\n|--------------|--------|--------|-------|\n| `i8` | `int8_t` | 1 byte | Entero con signo de 8 bits |\n| `i16` | `int16_t` | 2 bytes | Entero con signo de 16 bits |\n| `i32` | `int32_t` | 4 bytes | Entero con signo de 32 bits |\n| `i64` | `int64_t` | 8 bytes | Entero con signo de 64 bits |\n| `u8` | `uint8_t` | 1 byte | Entero sin signo de 8 bits |\n| `u16` | `uint16_t` | 2 bytes | Entero sin signo de 16 bits |\n| `u32` | `uint32_t` | 4 bytes | Entero sin signo de 32 bits |\n| `u64` | `uint64_t` | 8 bytes | Entero sin signo de 64 bits |\n| `f32` | `float` | 4 bytes | Punto flotante de 32 bits |\n| `f64` | `double` | 8 bytes | Punto flotante de 64 bits |\n| `ptr` | `void*` | 8 bytes | Puntero crudo |\n\n### Conversion de Tipos\n\n**Conversiones automaticas:**\n- Enteros de Hemlock  Enteros de C (con verificacion de rango)\n- Flotantes de Hemlock  Flotantes de C\n- Punteros de Hemlock  Punteros de C\n- Valores de retorno de C  Valores de Hemlock\n\n**Mapeos de tipo de ejemplo:**\n```hemlock\n// Hemlock  C\nlet i: i32 = 42;         //  int32_t (4 bytes)\nlet f: f64 = 3.14;       //  double (8 bytes)\nlet p: ptr = alloc(64);  //  void* (8 bytes)\n\n// C  Hemlock (valores de retorno)\n// int32_t foo()  i32\n// double bar()  f64\n// void* baz()  ptr\n```\n\n## Conceptos Basicos\n\n### Bibliotecas Compartidas\n\nFFI funciona con bibliotecas compartidas compiladas:\n\n**Linux:** archivos `.so`\n```\nlibexample.so\n/usr/lib/libm.so\n```\n\n**macOS:** archivos `.dylib`\n```\nlibexample.dylib\n/usr/lib/libSystem.dylib\n```\n\n**Windows:** archivos `.dll`\n```\nexample.dll\nkernel32.dll\n```\n\n### Firmas de Funcion\n\nLas funciones C deben tener firmas conocidas para que FFI funcione correctamente:\n\n```c\n// Firmas de funcion C de ejemplo\nint add(int a, int b);\ndouble sqrt(double x);\nvoid* malloc(size_t size);\nvoid free(void* ptr);\n```\n\nEstas pueden llamarse desde Hemlock una vez que la biblioteca este cargada y las funciones vinculadas.\n\n### Compatibilidad de Plataforma\n\nFFI usa **libffi** para portabilidad:\n- Funciona en x86, x86-64, ARM, ARM64\n- Maneja convenciones de llamada automaticamente\n- Abstrae detalles ABI especificos de la plataforma\n- Soporta Linux, macOS, Windows (con libffi apropiado)\n\n## Exportando Funciones FFI\n\nLas funciones FFI declaradas con `extern fn` pueden exportarse desde modulos, permitiendote crear envoltorios de biblioteca reutilizables que pueden compartirse entre multiples archivos.\n\n### Sintaxis Basica de Exportacion\n\n```hemlock\n// string_utils.hml - Un modulo de biblioteca envolviendo funciones de strings de C\nimport \"libc.so.6\";\n\n// Exportar la funcion extern directamente\nexport extern fn strlen(s: string): i32;\nexport extern fn strcmp(s1: string, s2: string): i32;\n\n// Tambien puedes exportar funciones envolventes junto con funciones extern\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n\nexport fn strings_equal(a: string, b: string): bool {\n    return strcmp(a, b) == 0;\n}\n```\n\n### Importando Funciones FFI Exportadas\n\n```hemlock\n// main.hml - Usando las funciones FFI exportadas\nimport { strlen, string_length, strings_equal } from \"./string_utils.hml\";\n\nlet msg = \"Hello, World!\";\nprint(strlen(msg));           // 13 - llamada extern directa\nprint(string_length(msg));    // 13 - funcion envolvente\n\nprint(strings_equal(\"foo\", \"foo\"));  // true\nprint(strings_equal(\"foo\", \"bar\"));  // false\n```\n\n### Casos de Uso para Export Extern\n\n**1. Abstraccion de Plataforma**\n```hemlock\n// platform.hml - Abstraer diferencias de plataforma\nimport \"libc.so.6\";  // Linux\n\nexport extern fn getpid(): i32;\nexport extern fn getuid(): i32;\nexport extern fn geteuid(): i32;\n```\n\n**2. Envoltorios de Biblioteca**\n```hemlock\n// crypto_lib.hml - Envolver funciones de biblioteca crypto\nimport \"libcrypto.so\";\n\nexport extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;\nexport extern fn MD5(data: ptr, len: u64, out: ptr): ptr;\n\n// Agregar envoltorios amigables para Hemlock\nexport fn sha256_string(s: string): string {\n    // Implementacion usando la funcion extern\n}\n```\n\n**3. Declaraciones FFI Centralizadas**\n```hemlock\n// libc.hml - Modulo central para bindings de libc\nimport \"libc.so.6\";\n\n// Funciones de string\nexport extern fn strlen(s: string): i32;\nexport extern fn strcpy(dest: ptr, src: string): ptr;\nexport extern fn strcat(dest: ptr, src: string): ptr;\n\n// Funciones de memoria\nexport extern fn malloc(size: u64): ptr;\nexport extern fn realloc(p: ptr, size: u64): ptr;\nexport extern fn calloc(nmemb: u64, size: u64): ptr;\n\n// Funciones de proceso\nexport extern fn getpid(): i32;\nexport extern fn getppid(): i32;\nexport extern fn getenv(name: string): ptr;\n```\n\nLuego usar en todo tu proyecto:\n```hemlock\nimport { strlen, malloc, getpid } from \"./libc.hml\";\n```\n\n### Combinando con Exportaciones Regulares\n\nPuedes mezclar funciones extern exportadas con exportaciones de funciones regulares:\n\n```hemlock\n// math_extended.hml\nimport \"libm.so.6\";\n\n// Exportar funciones C crudas\nexport extern fn sin(x: f64): f64;\nexport extern fn cos(x: f64): f64;\nexport extern fn tan(x: f64): f64;\n\n// Exportar funciones de Hemlock que las usan\nexport fn deg_to_rad(degrees: f64): f64 {\n    return degrees * 3.14159265359 / 180.0;\n}\n\nexport fn sin_degrees(degrees: f64): f64 {\n    return sin(deg_to_rad(degrees));\n}\n```\n\n### Bibliotecas Especificas de Plataforma\n\nAl exportar funciones extern, recuerda que los nombres de biblioteca difieren por plataforma:\n\n```hemlock\n// Para Linux\nimport \"libc.so.6\";\n\n// Para macOS (enfoque diferente necesario)\nimport \"libSystem.B.dylib\";\n```\n\nActualmente, la sintaxis `import \"library\"` de Hemlock usa rutas de biblioteca estaticas, por lo que pueden necesitarse modulos especificos de plataforma para codigo FFI multiplataforma.\n\n## Casos de Uso\n\n### 1. Bibliotecas del Sistema\n\nAcceder a funciones de la biblioteca estandar de C:\n\n**Funciones matematicas:**\n```hemlock\n// Llamar sqrt desde libm\nlet result = sqrt(16.0);  // 4.0\n```\n\n**Asignacion de memoria:**\n```hemlock\n// Llamar malloc/free desde libc\nlet ptr = malloc(1024);\nfree(ptr);\n```\n\n### 2. Bibliotecas de Terceros\n\nUsar bibliotecas C existentes:\n\n**Ejemplo: Procesamiento de imagenes**\n```hemlock\n// Cargar libpng o libjpeg\n// Procesar imagenes usando funciones de biblioteca C\n```\n\n**Ejemplo: Criptografia**\n```hemlock\n// Usar OpenSSL o libsodium\n// Encriptacion/desencriptacion via FFI\n```\n\n### 3. APIs del Sistema\n\nLlamadas al sistema directas:\n\n**Ejemplo: APIs POSIX**\n```hemlock\n// Llamar getpid, getuid, etc.\n// Acceder a funcionalidad de bajo nivel del sistema\n```\n\n### 4. Codigo Critico en Rendimiento\n\nLlamar implementaciones C optimizadas:\n\n```hemlock\n// Usar bibliotecas C altamente optimizadas\n// Operaciones SIMD, codigo vectorizado\n// Funciones aceleradas por hardware\n```\n\n### 5. Acceso a Hardware\n\nInterfaz con bibliotecas de hardware:\n\n```hemlock\n// Control GPIO en sistemas embebidos\n// Comunicacion con dispositivos USB\n// Acceso a puerto serial\n```\n\n### 6. Integracion de Codigo Legado\n\nReutilizar bases de codigo C existentes:\n\n```hemlock\n// Llamar funciones de aplicaciones C legadas\n// Migrar gradualmente a Hemlock\n// Preservar codigo C funcionando\n```\n\n## Desarrollo Futuro\n\n### Caracteristicas Planeadas\n\n**1. Soporte de Structs**\n```hemlock\n// Futuro: Pasar/retornar structs de C\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\nlet p = Point { x: 1.0, y: 2.0 };\nc_function_with_struct(p);\n```\n\n**2. Manejo de Arrays/Buffers**\n```hemlock\n// Futuro: Mejor paso de arrays\nlet arr = [1, 2, 3, 4, 5];\nprocess_array(arr);  // Pasar a funcion C\n```\n\n**3. Callbacks de Punteros a Funcion**  (Implementado!)\n```hemlock\n// Pasar funciones de Hemlock a C como callbacks\nfn my_compare(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    return va - vb;\n}\n\n// Crear un puntero a funcion llamable desde C\nlet cmp = callback(my_compare, [\"ptr\", \"ptr\"], \"i32\");\n\n// Usar con qsort o cualquier funcion C que espera un callback\nqsort(arr, count, elem_size, cmp);\n\n// Limpiar cuando termines\ncallback_free(cmp);\n```\n\n**4. Marshaling de Strings**\n```hemlock\n// Futuro: Conversion automatica de strings\nlet s = \"hello\";\nc_string_function(s);  // Auto-convertir a string C\n```\n\n**5. Manejo de Errores**\n```hemlock\n// Futuro: Mejor reporte de errores\ntry {\n    let result = risky_c_function();\n} catch (e) {\n    print(\"FFI error: \" + e);\n}\n```\n\n**6. Seguridad de Tipos**\n```hemlock\n// Futuro: Anotaciones de tipo para FFI\n@ffi(\"libm.so\")\nfn sqrt(x: f64): f64;\n\nlet result = sqrt(16.0);  // Verificado por tipos\n```\n\n### Caracteristicas\n\n**v1.0:**\n-  FFI basico con tipos primitivos\n-  Carga dinamica de bibliotecas\n-  Llamada de funciones\n-  Soporte de callbacks via clausuras libffi\n\n**Futuro:**\n- Soporte de structs\n- Mejoras en manejo de arrays\n- Generacion automatica de bindings\n\n## Callbacks FFI\n\nHemlock soporta pasar funciones a codigo C como callbacks usando clausuras libffi. Esto habilita la integracion con APIs de C que esperan punteros a funcion, como `qsort`, bucles de eventos y bibliotecas basadas en callbacks.\n\n### Creando Callbacks\n\nUsa `callback()` para crear un puntero a funcion llamable desde C a partir de una funcion de Hemlock:\n\n```hemlock\n// callback(function, param_types, return_type) -> ptr\nlet cb = callback(my_function, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n**Parametros:**\n- `function`: Una funcion de Hemlock para envolver\n- `param_types`: Array de strings de nombres de tipo (ej. `[\"ptr\", \"i32\"]`)\n- `return_type`: String de tipo de retorno (ej. `\"i32\"`, `\"void\"`)\n\n**Tipos de callback soportados:**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - Enteros con signo\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - Enteros sin signo\n- `\"f32\"`, `\"f64\"` - Punto flotante\n- `\"ptr\"` - Puntero\n- `\"void\"` - Sin valor de retorno\n- `\"bool\"` - Booleano\n\n### Ejemplo: qsort\n\n```hemlock\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// Funcion de comparacion para enteros (orden ascendente)\nfn compare_ints(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va < vb) { return -1; }\n    if (va > vb) { return 1; }\n    return 0;\n}\n\n// Asignar array de 5 enteros\nlet arr = alloc(20);  // 5 * 4 bytes\nptr_write_i32(arr, 5);\nptr_write_i32(ptr_offset(arr, 1, 4), 2);\nptr_write_i32(ptr_offset(arr, 2, 4), 8);\nptr_write_i32(ptr_offset(arr, 3, 4), 1);\nptr_write_i32(ptr_offset(arr, 4, 4), 9);\n\n// Crear callback y ordenar\nlet cmp = callback(compare_ints, [\"ptr\", \"ptr\"], \"i32\");\nqsort(arr, 5, 4, cmp);\n\n// El array ahora esta ordenado: [1, 2, 5, 8, 9]\n\n// Limpiar\ncallback_free(cmp);\nfree(arr);\n```\n\n### Funciones Auxiliares de Puntero\n\nHemlock proporciona funciones auxiliares completas para trabajar con punteros crudos. Estas son esenciales para callbacks FFI y manipulacion directa de memoria.\n\n#### Auxiliares de Tipos Enteros\n\n| Funcion | Descripcion |\n|---------|-------------|\n| `ptr_deref_i8(ptr)` | Dereferenciar puntero, leer i8 |\n| `ptr_deref_i16(ptr)` | Dereferenciar puntero, leer i16 |\n| `ptr_deref_i32(ptr)` | Dereferenciar puntero, leer i32 |\n| `ptr_deref_i64(ptr)` | Dereferenciar puntero, leer i64 |\n| `ptr_deref_u8(ptr)` | Dereferenciar puntero, leer u8 |\n| `ptr_deref_u16(ptr)` | Dereferenciar puntero, leer u16 |\n| `ptr_deref_u32(ptr)` | Dereferenciar puntero, leer u32 |\n| `ptr_deref_u64(ptr)` | Dereferenciar puntero, leer u64 |\n| `ptr_write_i8(ptr, value)` | Escribir i8 en ubicacion del puntero |\n| `ptr_write_i16(ptr, value)` | Escribir i16 en ubicacion del puntero |\n| `ptr_write_i32(ptr, value)` | Escribir i32 en ubicacion del puntero |\n| `ptr_write_i64(ptr, value)` | Escribir i64 en ubicacion del puntero |\n| `ptr_write_u8(ptr, value)` | Escribir u8 en ubicacion del puntero |\n| `ptr_write_u16(ptr, value)` | Escribir u16 en ubicacion del puntero |\n| `ptr_write_u32(ptr, value)` | Escribir u32 en ubicacion del puntero |\n| `ptr_write_u64(ptr, value)` | Escribir u64 en ubicacion del puntero |\n\n#### Auxiliares de Tipos Flotantes\n\n| Funcion | Descripcion |\n|---------|-------------|\n| `ptr_deref_f32(ptr)` | Dereferenciar puntero, leer f32 (float) |\n| `ptr_deref_f64(ptr)` | Dereferenciar puntero, leer f64 (double) |\n| `ptr_write_f32(ptr, value)` | Escribir f32 en ubicacion del puntero |\n| `ptr_write_f64(ptr, value)` | Escribir f64 en ubicacion del puntero |\n\n#### Auxiliares de Tipos Puntero\n\n| Funcion | Descripcion |\n|---------|-------------|\n| `ptr_deref_ptr(ptr)` | Dereferenciar puntero a puntero |\n| `ptr_write_ptr(ptr, value)` | Escribir puntero en ubicacion del puntero |\n| `ptr_offset(ptr, index, size)` | Calcular desplazamiento: `ptr + index * size` |\n| `ptr_read_i32(ptr)` | Leer i32 a traves de puntero a puntero (para callbacks qsort) |\n| `ptr_null()` | Obtener una constante de puntero nulo |\n\n#### Auxiliares de Conversion de Buffer\n\n| Funcion | Descripcion |\n|---------|-------------|\n| `buffer_ptr(buffer)` | Obtener puntero crudo de un buffer |\n| `ptr_to_buffer(ptr, size)` | Copiar datos de puntero a un nuevo buffer |\n\n#### Funciones de Utilidad FFI\n\n| Funcion | Descripcion |\n|---------|-------------|\n| `ffi_sizeof(type_name)` | Obtener tamano en bytes de un tipo FFI |\n\n**Nombres de tipo soportados para `ffi_sizeof`:**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - Enteros con signo (1, 2, 4, 8 bytes)\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - Enteros sin signo (1, 2, 4, 8 bytes)\n- `\"f32\"`, `\"f64\"` - Flotantes (4, 8 bytes)\n- `\"ptr\"` - Puntero (8 bytes en 64-bit)\n- `\"size_t\"`, `\"usize\"` - Tipo de tamano dependiente de plataforma\n- `\"intptr_t\"`, `\"isize\"` - Tipo de puntero con signo dependiente de plataforma\n\n#### Ejemplo: Trabajando con Diferentes Tipos\n\n```hemlock\nlet p = alloc(64);\n\n// Escribir y leer enteros\nptr_write_i8(p, 42);\nprint(ptr_deref_i8(p));  // 42\n\nptr_write_i64(ptr_offset(p, 1, 8), 9000000000);\nprint(ptr_deref_i64(ptr_offset(p, 1, 8)));  // 9000000000\n\n// Escribir y leer flotantes\nptr_write_f64(p, 3.14159);\nprint(ptr_deref_f64(p));  // 3.14159\n\n// Puntero a puntero\nlet inner = alloc(4);\nptr_write_i32(inner, 999);\nptr_write_ptr(p, inner);\nlet retrieved = ptr_deref_ptr(p);\nprint(ptr_deref_i32(retrieved));  // 999\n\n// Obtener tamanos de tipo\nprint(ffi_sizeof(\"i64\"));  // 8\nprint(ffi_sizeof(\"ptr\"));  // 8 (en 64-bit)\n\n// Conversion de buffer\nlet buf = buffer(64);\nptr_write_i32(buffer_ptr(buf), 12345);\nprint(ptr_deref_i32(buffer_ptr(buf)));  // 12345\n\nfree(inner);\nfree(p);\n```\n\n### Liberando Callbacks\n\n**Importante:** Siempre liberar callbacks cuando termines para prevenir fugas de memoria:\n\n```hemlock\nlet cb = callback(my_fn, [\"ptr\"], \"void\");\n// ... usar callback ...\ncallback_free(cb);  // Liberar cuando termines\n```\n\nLos callbacks tambien se liberan automaticamente cuando el programa termina.\n\n### Clausuras en Callbacks\n\nLos callbacks capturan su entorno de clausura, por lo que pueden acceder a variables del ambito exterior:\n\n```hemlock\nlet multiplier = 10;\n\nfn scale(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    // Puede acceder a 'multiplier' del ambito exterior\n    return (va * multiplier) - (vb * multiplier);\n}\n\nlet cmp = callback(scale, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n### Seguridad de Hilos\n\nLas invocaciones de callback se serializan con un mutex para asegurar seguridad de hilos, ya que el interprete de Hemlock no es completamente seguro para hilos. Esto significa:\n- Solo un callback puede ejecutarse a la vez\n- Seguro de usar con bibliotecas C multihilo\n- Puede impactar rendimiento si los callbacks se llaman muy frecuentemente desde multiples hilos\n\n### Manejo de Errores en Callbacks\n\nLas excepciones lanzadas en callbacks no pueden propagarse a codigo C. En su lugar:\n- Se imprime una advertencia a stderr\n- El callback retorna un valor por defecto (0 o NULL)\n- La excepcion se registra pero no se propaga\n\n```hemlock\nfn risky_callback(a: ptr): i32 {\n    throw \"Something went wrong\";  // Advertencia impresa, retorna 0\n}\n```\n\nPara manejo de errores robusto, valida las entradas y evita lanzar en callbacks.\n\n## Structs FFI\n\nHemlock soporta pasar structs por valor a funciones C. Los tipos de struct se registran automaticamente para FFI cuando los defines con anotaciones de tipo.\n\n### Definiendo Structs Compatibles con FFI\n\nUn struct es compatible con FFI cuando todos los campos tienen anotaciones de tipo explicitas usando tipos compatibles con FFI:\n\n```hemlock\n// Struct compatible con FFI\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\n// Struct compatible con FFI con multiples tipos de campo\ndefine Rectangle {\n    top_left: Point,      // Struct anidado\n    width: f64,\n    height: f64,\n}\n\n// NO compatible con FFI (campo sin anotacion de tipo)\ndefine DynamicObject {\n    name,                 // Sin tipo - no usable en FFI\n    value,\n}\n```\n\n### Usando Structs en FFI\n\nDeclarar funciones extern que usan tipos de struct:\n\n```hemlock\n// Definir el tipo de struct\ndefine Vector2D {\n    x: f64,\n    y: f64,\n}\n\n// Importar la biblioteca C\nimport \"libmath.so\";\n\n// Declarar funcion extern que toma/retorna structs\nextern fn vector_add(a: Vector2D, b: Vector2D): Vector2D;\nextern fn vector_length(v: Vector2D): f64;\n\n// Usarlo naturalmente\nlet a: Vector2D = { x: 3.0, y: 0.0 };\nlet b: Vector2D = { x: 0.0, y: 4.0 };\nlet result = vector_add(a, b);\nprint(result.x);  // 3.0\nprint(result.y);  // 4.0\n\nlet len = vector_length(result);\nprint(len);       // 5.0\n```\n\n### Tipos de Campo Soportados\n\nLos campos de struct deben usar estos tipos compatibles con FFI:\n\n| Tipo Hemlock | Tipo C | Tamano |\n|--------------|--------|--------|\n| `i8` | `int8_t` | 1 byte |\n| `i16` | `int16_t` | 2 bytes |\n| `i32` | `int32_t` | 4 bytes |\n| `i64` | `int64_t` | 8 bytes |\n| `u8` | `uint8_t` | 1 byte |\n| `u16` | `uint16_t` | 2 bytes |\n| `u32` | `uint32_t` | 4 bytes |\n| `u64` | `uint64_t` | 8 bytes |\n| `f32` | `float` | 4 bytes |\n| `f64` | `double` | 8 bytes |\n| `ptr` | `void*` | 8 bytes |\n| `string` | `char*` | 8 bytes |\n| `bool` | `int` | varia |\n| Struct anidado | struct | varia |\n\n### Layout de Struct\n\nHemlock usa las reglas de layout de struct nativas de la plataforma (coincidiendo con la ABI de C):\n- Los campos se alinean segun su tipo\n- Se inserta padding segun necesidad\n- El tamano total se rellena para alinear al miembro mas grande\n\n```hemlock\n// Ejemplo: layout compatible con C\ndefine Mixed {\n    a: i8,    // offset 0, tamano 1\n              // 3 bytes padding\n    b: i32,   // offset 4, tamano 4\n}\n// Tamano total: 8 bytes (con padding)\n\ndefine Point3D {\n    x: f64,   // offset 0, tamano 8\n    y: f64,   // offset 8, tamano 8\n    z: f64,   // offset 16, tamano 8\n}\n// Tamano total: 24 bytes (sin padding necesario)\n```\n\n### Structs Anidados\n\nLos structs pueden contener otros structs:\n\n```hemlock\ndefine Inner {\n    x: i32,\n    y: i32,\n}\n\ndefine Outer {\n    inner: Inner,\n    z: i32,\n}\n\nimport \"mylib.so\";\nextern fn process_nested(data: Outer): i32;\n\nlet obj: Outer = {\n    inner: { x: 1, y: 2 },\n    z: 3,\n};\nlet result = process_nested(obj);\n```\n\n### Valores de Retorno de Struct\n\nLas funciones C pueden retornar structs:\n\n```hemlock\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\nimport \"libmath.so\";\nextern fn get_origin(): Point;\n\nlet p = get_origin();\nprint(p.x);  // 0.0\nprint(p.y);  // 0.0\n```\n\n### Limitaciones\n\n- **Los campos de struct deben tener anotaciones de tipo** - campos sin tipos no son compatibles con FFI\n- **Sin arrays en structs** - usar punteros en su lugar\n- **Sin unions** - solo tipos struct son soportados\n- **Los callbacks no pueden retornar structs** - usar punteros para valores de retorno de callback\n\n### Exportando Tipos de Struct\n\nPuedes exportar definiciones de tipo de struct desde un modulo usando `export define`:\n\n```hemlock\n// geometry.hml\nexport define Vector2 {\n    x: f32,\n    y: f32,\n}\n\nexport define Rectangle {\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n}\n\nexport fn create_rect(x: f32, y: f32, w: f32, h: f32): Rectangle {\n    return { x: x, y: y, width: w, height: h };\n}\n```\n\n**Importante:** Los tipos de struct exportados se registran **globalmente** cuando el modulo se carga. Se vuelven disponibles automaticamente cuando importas cualquier cosa del modulo. NO necesitas (y no puedes) importarlos explicitamente por nombre:\n\n```hemlock\n// main.hml\n\n// BUENO - los tipos de struct estan auto-disponibles despues de cualquier import del modulo\nimport { create_rect } from \"./geometry.hml\";\nlet v: Vector2 = { x: 1.0, y: 2.0 };      // Funciona - Vector2 esta globalmente disponible\nlet r: Rectangle = create_rect(0.0, 0.0, 100.0, 50.0);  // Funciona\n\n// MALO - no se pueden importar tipos de struct explicitamente por nombre\nimport { Vector2 } from \"./geometry.hml\";  // Error: Undefined variable 'Vector2'\n```\n\nEste comportamiento existe porque los tipos de struct se registran en el registro global de tipos cuando el modulo carga, en lugar de almacenarse como valores en el entorno de exportacion del modulo. El tipo se vuelve disponible para todo el codigo que importa del modulo.\n\n## Limitaciones Actuales\n\nFFI tiene las siguientes limitaciones:\n\n**1. Conversion Manual de Tipos**\n- Debe gestionar manualmente conversiones de strings\n- Sin conversion automatica de string Hemlock  string C\n\n**2. Manejo de Errores Limitado**\n- Reporte basico de errores\n- Las excepciones en callbacks no pueden propagarse a C\n\n**3. Carga Manual de Bibliotecas**\n- Debe cargar manualmente las bibliotecas\n- Sin generacion automatica de bindings\n\n**4. Codigo Especifico de Plataforma**\n- Las rutas de biblioteca difieren por plataforma\n- Debe manejar .so vs .dylib vs .dll\n\n## Mejores Practicas\n\nMientras la documentacion completa de FFI todavia esta siendo desarrollada, aqui hay mejores practicas generales:\n\n### 1. Seguridad de Tipos\n\n```hemlock\n// Ser explicito sobre tipos\nlet x: i32 = 42;\nlet result: f64 = c_function(x);\n```\n\n### 2. Gestion de Memoria\n\n```hemlock\n// Recordar liberar memoria asignada\nlet ptr = c_malloc(1024);\n// ... usar ptr\nc_free(ptr);\n```\n\n### 3. Verificacion de Errores\n\n```hemlock\n// Verificar valores de retorno\nlet result = c_function();\nif (result == null) {\n    print(\"C function failed\");\n}\n```\n\n### 4. Compatibilidad de Plataforma\n\n```hemlock\n// Manejar diferencias de plataforma\n// Usar extensiones de biblioteca apropiadas (.so, .dylib, .dll)\n```\n\n## Ejemplos\n\nPara ejemplos funcionales, referirse a:\n- Pruebas de callback: `/tests/ffi_callbacks/` - ejemplos de callback qsort\n- Uso de FFI en stdlib: `/stdlib/hash.hml`, `/stdlib/regex.hml`, `/stdlib/crypto.hml`\n- Programas de ejemplo: `/examples/` (si estan disponibles)\n\n## Obteniendo Ayuda\n\nFFI es una caracteristica mas nueva en Hemlock. Para preguntas o problemas:\n\n1. Verificar la suite de pruebas para ejemplos funcionales\n2. Referirse a documentacion de libffi para detalles de bajo nivel\n3. Reportar bugs o solicitar caracteristicas via issues del proyecto\n\n## Resumen\n\nEl FFI de Hemlock proporciona:\n\n-  Llamada de funciones C desde bibliotecas compartidas\n-  Soporte de tipos primitivos (i8-i64, u8-u64, f32, f64, ptr)\n-  Conversion automatica de tipos\n-  Portabilidad basada en libffi\n-  Base para integracion de bibliotecas nativas\n-  **Callbacks de punteros a funcion** - pasar funciones de Hemlock a C\n-  **Exportar funciones extern** - compartir bindings FFI entre modulos\n-  **Paso y retorno de structs** - pasar structs compatibles con C por valor\n-  **Export define** - compartir definiciones de tipo de struct entre modulos (auto-importados globalmente)\n-  **Auxiliares de puntero completos** - leer/escribir todos los tipos (i8-i64, u8-u64, f32, f64, ptr)\n-  **Conversion buffer/puntero** - `buffer_ptr()`, `ptr_to_buffer()` para marshaling de datos\n-  **Tamanos de tipos FFI** - `ffi_sizeof()` para tamanos de tipo conscientes de plataforma\n-  **Tipos de plataforma** - soporte para `size_t`, `usize`, `isize`, `intptr_t`, `uintptr_t`\n\n**Estado actual:** FFI completamente caracterizado con tipos primitivos, structs, callbacks, exportaciones de modulo y funciones auxiliares de puntero completas\n\n**Futuro:** Ayudantes de marshaling de strings\n\n**Casos de uso:** Bibliotecas del sistema, bibliotecas de terceros, qsort, bucles de eventos, APIs basadas en callbacks, envoltorios de biblioteca reutilizables\n\n## Contribuyendo\n\nLa documentacion de FFI esta siendo expandida. Si trabajas con FFI:\n- Documenta tus casos de uso\n- Comparte codigo de ejemplo\n- Reporta problemas o limitaciones\n- Sugiere mejoras\n\nEl sistema FFI esta disenado para ser practico y seguro mientras proporciona acceso de bajo nivel cuando se necesita, siguiendo la filosofia de Hemlock de \"explicito sobre implicito\" y \"unsafe es una caracteristica, no un bug.\"\n"}, "Temas Avanzados -> File IO": {"id": "advanced-file-io", "content": "# E/S de Archivos en Hemlock\n\nHemlock proporciona una **API de objeto File** para operaciones de archivo con manejo de errores apropiado y gestion de recursos.\n\n## Tabla de Contenidos\n\n- [Vision General](#vision-general)\n- [Abriendo Archivos](#abriendo-archivos)\n- [Metodos de File](#metodos-de-file)\n- [Propiedades de File](#propiedades-de-file)\n- [Manejo de Errores](#manejo-de-errores)\n- [Gestion de Recursos](#gestion-de-recursos)\n- [Referencia Completa de API](#referencia-completa-de-api)\n- [Patrones Comunes](#patrones-comunes)\n- [Mejores Practicas](#mejores-practicas)\n\n## Vision General\n\nLa API de objeto File proporciona:\n\n- **Gestion explicita de recursos** - Los archivos deben cerrarse manualmente\n- **Multiples modos de apertura** - Lectura, escritura, anexar, lectura/escritura\n- **Operaciones de texto y binario** - Leer/escribir tanto texto como datos binarios\n- **Soporte de busqueda** - Acceso aleatorio dentro de archivos\n- **Mensajes de error completos** - Reporte de errores consciente del contexto\n\n**Importante:** Los archivos no se cierran automaticamente. Debes llamar `f.close()` para evitar fugas de descriptores de archivo.\n\n## Abriendo Archivos\n\nUsa `open(path, mode?)` para abrir un archivo:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");     // Modo lectura (por defecto)\nlet f2 = open(\"output.txt\", \"w\");  // Modo escritura (trunca)\nlet f3 = open(\"log.txt\", \"a\");     // Modo anexar\nlet f4 = open(\"data.bin\", \"r+\");   // Modo lectura/escritura\n```\n\n### Modos de Apertura\n\n| Modo | Descripcion | Archivo Debe Existir | Trunca | Posicion |\n|------|-------------|---------------------|--------|----------|\n| `\"r\"` | Lectura (por defecto) | Si | No | Inicio |\n| `\"w\"` | Escritura | No (crea) | Si | Inicio |\n| `\"a\"` | Anexar | No (crea) | No | Final |\n| `\"r+\"` | Leer y escribir | Si | No | Inicio |\n| `\"w+\"` | Leer y escribir | No (crea) | Si | Inicio |\n| `\"a+\"` | Leer y anexar | No (crea) | No | Final |\n\n### Ejemplos\n\n**Leyendo un archivo existente:**\n```hemlock\nlet f = open(\"config.json\", \"r\");\n// o simplemente:\nlet f = open(\"config.json\");  // \"r\" es por defecto\n```\n\n**Creando un nuevo archivo para escritura:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");  // Crea o trunca\n```\n\n**Anexando a un archivo:**\n```hemlock\nlet f = open(\"log.txt\", \"a\");  // Crea si no existe\n```\n\n**Modo lectura y escritura:**\n```hemlock\nlet f = open(\"data.bin\", \"r+\");  // Archivo existente, puede leer/escribir\n```\n\n## Metodos de File\n\n### Lectura\n\n#### read(size?: i32): string\n\nLeer texto del archivo (parametro size opcional).\n\n**Sin size (leer todo):**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet all = f.read();  // Leer desde posicion actual hasta EOF\nf.close();\n```\n\n**Con size (leer bytes especificos):**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet chunk = f.read(1024);  // Leer hasta 1024 bytes\nlet next = f.read(1024);   // Leer siguientes 1024 bytes\nf.close();\n```\n\n**Retorna:** String conteniendo los datos leidos, o string vacio si esta en EOF\n\n**Ejemplo - Leyendo archivo completo:**\n```hemlock\nlet f = open(\"poem.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n```\n\n**Ejemplo - Leyendo en chunks:**\n```hemlock\nlet f = open(\"large.txt\", \"r\");\nwhile (true) {\n    let chunk = f.read(4096);  // Chunks de 4KB\n    if (chunk == \"\") { break; }  // EOF alcanzado\n    process(chunk);\n}\nf.close();\n```\n\n#### read_bytes(size: i32): buffer\n\nLeer datos binarios (retorna buffer).\n\n**Parametros:**\n- `size` (i32) - Numero de bytes a leer\n\n**Retorna:** Buffer conteniendo los bytes leidos\n\n```hemlock\nlet f = open(\"image.png\", \"r\");\nlet binary = f.read_bytes(256);  // Leer 256 bytes\nprint(binary.length);  // 256 (o menos si EOF)\n\n// Acceder a bytes individuales\nlet first_byte = binary[0];\nprint(first_byte);\n\nf.close();\n```\n\n**Ejemplo - Leyendo archivo binario completo:**\n```hemlock\nlet f = open(\"data.bin\", \"r\");\nlet size = 10240;  // Tamano esperado\nlet data = f.read_bytes(size);\nf.close();\n\n// Procesar datos binarios\nlet i = 0;\nwhile (i < data.length) {\n    let byte = data[i];\n    // ... procesar byte\n    i = i + 1;\n}\n```\n\n### Escritura\n\n#### write(data: string): i32\n\nEscribir texto al archivo (retorna bytes escritos).\n\n**Parametros:**\n- `data` (string) - Texto a escribir\n\n**Retorna:** Numero de bytes escritos (i32)\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Wrote \" + typeof(written) + \" bytes\");  // \"Wrote 14 bytes\"\nf.close();\n```\n\n**Ejemplo - Escribiendo multiples lineas:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Line 1\\n\");\nf.write(\"Line 2\\n\");\nf.write(\"Line 3\\n\");\nf.close();\n```\n\n**Ejemplo - Anexando a archivo de log:**\n```hemlock\nlet f = open(\"app.log\", \"a\");\nf.write(\"[INFO] Application started\\n\");\nf.write(\"[INFO] User logged in\\n\");\nf.close();\n```\n\n#### write_bytes(data: buffer): i32\n\nEscribir datos binarios (retorna bytes escritos).\n\n**Parametros:**\n- `data` (buffer) - Datos binarios a escribir\n\n**Retorna:** Numero de bytes escritos (i32)\n\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Crear datos binarios\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\nlet bytes = f.write_bytes(buf);\nprint(\"Wrote \" + typeof(bytes) + \" bytes\");\n\nf.close();\n```\n\n**Ejemplo - Copiando archivo binario:**\n```hemlock\nlet src = open(\"input.bin\", \"r\");\nlet dst = open(\"output.bin\", \"w\");\n\nlet data = src.read_bytes(1024);\nwhile (data.length > 0) {\n    dst.write_bytes(data);\n    data = src.read_bytes(1024);\n}\n\nsrc.close();\ndst.close();\n```\n\n### Busqueda\n\n#### seek(position: i32): i32\n\nMoverse a posicion especifica (retorna nueva posicion).\n\n**Parametros:**\n- `position` (i32) - Desplazamiento en bytes desde el inicio del archivo\n\n**Retorna:** Nueva posicion (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Moverse al byte 100\nf.seek(100);\n\n// Leer desde posicion 100\nlet data = f.read(50);\n\n// Restablecer al inicio\nf.seek(0);\n\nf.close();\n```\n\n**Ejemplo - Acceso aleatorio:**\n```hemlock\nlet f = open(\"records.dat\", \"r\");\n\n// Leer registro en offset 1000\nf.seek(1000);\nlet record1 = f.read_bytes(100);\n\n// Leer registro en offset 2000\nf.seek(2000);\nlet record2 = f.read_bytes(100);\n\nf.close();\n```\n\n#### tell(): i32\n\nObtener posicion actual en el archivo.\n\n**Retorna:** Desplazamiento actual en bytes (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet pos1 = f.tell();  // 0 (al inicio)\n\nf.read(100);\nlet pos2 = f.tell();  // 100 (despues de leer 100 bytes)\n\nf.seek(500);\nlet pos3 = f.tell();  // 500 (despues de busqueda)\n\nf.close();\n```\n\n**Ejemplo - Midiendo cantidad leida:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet start = f.tell();\nlet content = f.read();\nlet end = f.tell();\n\nlet bytes_read = end - start;\nprint(\"Read \" + typeof(bytes_read) + \" bytes\");\n\nf.close();\n```\n\n### Cierre\n\n#### close()\n\nCerrar archivo (idempotente, puede llamarse multiples veces).\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n// ... usar archivo\nf.close();\nf.close();  // Seguro - sin error en segundo cierre\n```\n\n**Notas importantes:**\n- Siempre cerrar archivos cuando termines para evitar fugas de descriptores de archivo\n- El cierre es idempotente - puede llamarse multiples veces de forma segura\n- Despues de cerrar, todas las otras operaciones daran error\n- Usar bloques `finally` para asegurar que los archivos se cierren incluso en errores\n\n## Propiedades de File\n\nLos objetos File tienen tres propiedades de solo lectura:\n\n### path: string\n\nLa ruta del archivo usada para abrirlo.\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);  // \"/path/to/file.txt\"\nf.close();\n```\n\n### mode: string\n\nEl modo con el que se abrio el archivo.\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);  // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);  // \"w\"\nf2.close();\n```\n\n### closed: bool\n\nSi el archivo esta cerrado.\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n**Ejemplo - Verificando si el archivo esta abierto:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... procesar contenido\n}\n\nf.close();\n\nif (f.closed) {\n    print(\"File is now closed\");\n}\n```\n\n## Manejo de Errores\n\nTodas las operaciones de archivo incluyen mensajes de error apropiados con contexto.\n\n### Errores Comunes\n\n**Archivo no encontrado:**\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Error: Failed to open 'missing.txt': No such file or directory\n```\n\n**Leyendo de archivo cerrado:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Error: Cannot read from closed file 'data.txt'\n```\n\n**Escribiendo a archivo de solo lectura:**\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Error: Cannot write to file 'readonly.txt' opened in read-only mode\n```\n\n**Leyendo de archivo de solo escritura:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.read();\n// Error: Cannot read from file 'output.txt' opened in write-only mode\n```\n\n### Usando try/catch\n\n```hemlock\ntry {\n    let f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    f.close();\n    process(content);\n} catch (e) {\n    print(\"Error reading file: \" + e);\n}\n```\n\n## Gestion de Recursos\n\n### Patron Basico\n\nSiempre cerrar archivos explicitamente:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### Con Manejo de Errores (Recomendado)\n\nUsar `finally` para asegurar que los archivos se cierren incluso en errores:\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Siempre cerrar, incluso en error\n}\n```\n\n### Multiples Archivos\n\n```hemlock\nlet src = null;\nlet dst = null;\n\ntry {\n    src = open(\"input.txt\", \"r\");\n    dst = open(\"output.txt\", \"w\");\n\n    let content = src.read();\n    dst.write(content);\n} finally {\n    if (src != null) { src.close(); }\n    if (dst != null) { dst.close(); }\n}\n```\n\n### Patron de Funcion Auxiliar\n\n```hemlock\nfn with_file(path: string, mode: string, callback) {\n    let f = open(path, mode);\n    try {\n        return callback(f);\n    } finally {\n        f.close();\n    }\n}\n\n// Uso:\nwith_file(\"data.txt\", \"r\", fn(f) {\n    return f.read();\n});\n```\n\n## Referencia Completa de API\n\n### Funciones\n\n| Funcion | Parametros | Retorna | Descripcion |\n|---------|-----------|---------|-------------|\n| `open(path, mode?)` | path: string, mode?: string | File | Abrir archivo (modo por defecto es \"r\") |\n\n### Metodos\n\n| Metodo | Parametros | Retorna | Descripcion |\n|--------|-----------|---------|-------------|\n| `read(size?)` | size?: i32 | string | Leer texto (todo o bytes especificos) |\n| `read_bytes(size)` | size: i32 | buffer | Leer datos binarios |\n| `write(data)` | data: string | i32 | Escribir texto, retorna bytes escritos |\n| `write_bytes(data)` | data: buffer | i32 | Escribir datos binarios, retorna bytes escritos |\n| `seek(position)` | position: i32 | i32 | Buscar posicion, retorna nueva posicion |\n| `tell()` | - | i32 | Obtener posicion actual |\n| `close()` | - | null | Cerrar archivo (idempotente) |\n\n### Propiedades (solo lectura)\n\n| Propiedad | Tipo | Descripcion |\n|-----------|------|-------------|\n| `path` | string | Ruta del archivo |\n| `mode` | string | Modo de apertura |\n| `closed` | bool | Si el archivo esta cerrado |\n\n## Patrones Comunes\n\n### Leyendo Archivo Completo\n\n```hemlock\nfn read_file(path: string): string {\n    let f = open(path, \"r\");\n    try {\n        return f.read();\n    } finally {\n        f.close();\n    }\n}\n\nlet content = read_file(\"config.json\");\n```\n\n### Escribiendo Archivo Completo\n\n```hemlock\nfn write_file(path: string, content: string) {\n    let f = open(path, \"w\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\");\n```\n\n### Anexando a Archivo\n\n```hemlock\nfn append_file(path: string, content: string) {\n    let f = open(path, \"a\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nappend_file(\"log.txt\", \"[INFO] Event occurred\\n\");\n```\n\n### Leyendo Lineas\n\n```hemlock\nfn read_lines(path: string) {\n    let f = open(path, \"r\");\n    try {\n        let content = f.read();\n        return content.split(\"\\n\");\n    } finally {\n        f.close();\n    }\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### Procesando Archivos Grandes en Chunks\n\n```hemlock\nfn process_large_file(path: string) {\n    let f = open(path, \"r\");\n    try {\n        while (true) {\n            let chunk = f.read(4096);  // Chunks de 4KB\n            if (chunk == \"\") { break; }\n\n            // Procesar chunk\n            process_chunk(chunk);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n### Copia de Archivo Binario\n\n```hemlock\nfn copy_file(src_path: string, dst_path: string) {\n    let src = null;\n    let dst = null;\n\n    try {\n        src = open(src_path, \"r\");\n        dst = open(dst_path, \"w\");\n\n        while (true) {\n            let chunk = src.read_bytes(4096);\n            if (chunk.length == 0) { break; }\n\n            dst.write_bytes(chunk);\n        }\n    } finally {\n        if (src != null) { src.close(); }\n        if (dst != null) { dst.close(); }\n    }\n}\n\ncopy_file(\"input.dat\", \"output.dat\");\n```\n\n### Truncar Archivo\n\n```hemlock\nfn truncate_file(path: string) {\n    let f = open(path, \"w\");  // Modo \"w\" trunca\n    f.close();\n}\n\ntruncate_file(\"empty_me.txt\");\n```\n\n### Lectura de Acceso Aleatorio\n\n```hemlock\nfn read_at_offset(path: string, offset: i32, size: i32): string {\n    let f = open(path, \"r\");\n    try {\n        f.seek(offset);\n        return f.read(size);\n    } finally {\n        f.close();\n    }\n}\n\nlet data = read_at_offset(\"records.dat\", 1000, 100);\n```\n\n### Tamano de Archivo\n\n```hemlock\nfn file_size(path: string): i32 {\n    let f = open(path, \"r\");\n    try {\n        // Buscar al final\n        let end = f.seek(999999999);  // Numero grande\n        f.seek(0);  // Restablecer\n        return end;\n    } finally {\n        f.close();\n    }\n}\n\nlet size = file_size(\"data.txt\");\nprint(\"File size: \" + typeof(size) + \" bytes\");\n```\n\n### Lectura/Escritura Condicional\n\n```hemlock\nfn update_file(path: string, condition, new_content: string) {\n    let f = open(path, \"r+\");\n    try {\n        let content = f.read();\n\n        if (condition(content)) {\n            f.seek(0);  // Restablecer al inicio\n            f.write(new_content);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n## Mejores Practicas\n\n### 1. Siempre Usar try/finally\n\n```hemlock\n// Bueno\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();\n}\n\n// Malo - el archivo podria no cerrarse en error\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprocess(content);  // Si esto lanza, el archivo tiene fuga\nf.close();\n```\n\n### 2. Verificar Estado del Archivo Antes de Operaciones\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... usar contenido\n}\n\nf.close();\n```\n\n### 3. Usar Modos Apropiados\n\n```hemlock\n// Solo lectura? Usar \"r\"\nlet f = open(\"config.json\", \"r\");\n\n// Reemplazando completamente? Usar \"w\"\nlet f = open(\"output.txt\", \"w\");\n\n// Agregando al final? Usar \"a\"\nlet f = open(\"log.txt\", \"a\");\n```\n\n### 4. Manejar Errores Graciosamente\n\n```hemlock\nfn safe_read_file(path: string): string {\n    try {\n        let f = open(path, \"r\");\n        try {\n            return f.read();\n        } finally {\n            f.close();\n        }\n    } catch (e) {\n        print(\"Warning: Could not read \" + path + \": \" + e);\n        return \"\";\n    }\n}\n```\n\n### 5. Cerrar Archivos en Orden Inverso de Apertura\n\n```hemlock\nlet f1 = null;\nlet f2 = null;\nlet f3 = null;\n\ntry {\n    f1 = open(\"file1.txt\", \"r\");\n    f2 = open(\"file2.txt\", \"r\");\n    f3 = open(\"file3.txt\", \"r\");\n\n    // ... usar archivos\n} finally {\n    // Cerrar en orden inverso\n    if (f3 != null) { f3.close(); }\n    if (f2 != null) { f2.close(); }\n    if (f1 != null) { f1.close(); }\n}\n```\n\n### 6. Evitar Leer Archivos Grandes Completamente\n\n```hemlock\n// Malo para archivos grandes\nlet f = open(\"huge.log\", \"r\");\nlet content = f.read();  // Carga archivo completo en memoria\nf.close();\n\n// Bueno - procesar en chunks\nlet f = open(\"huge.log\", \"r\");\ntry {\n    while (true) {\n        let chunk = f.read(4096);\n        if (chunk == \"\") { break; }\n        process_chunk(chunk);\n    }\n} finally {\n    f.close();\n}\n```\n\n## Resumen\n\nLa API de E/S de Archivos de Hemlock proporciona:\n\n-  Operaciones de archivo simples y explicitas\n-  Soporte de texto y binario\n-  Acceso aleatorio con seek/tell\n-  Mensajes de error claros con contexto\n-  Operacion de cierre idempotente\n\nRecuerda:\n- Siempre cerrar archivos manualmente\n- Usar try/finally para seguridad de recursos\n- Elegir modos de apertura apropiados\n- Manejar errores graciosamente\n- Procesar archivos grandes en chunks\n"}, "Temas Avanzados -> Operaciones Atmicas": {"id": "advanced-atomics", "content": "# Operaciones Atomicas\n\nHemlock proporciona operaciones atomicas para **programacion concurrente sin bloqueos**. Estas operaciones permiten la manipulacion segura de memoria compartida a traves de multiples hilos sin bloqueos o mutexes tradicionales.\n\n## Tabla de Contenidos\n\n- [Vision General](#vision-general)\n- [Cuando Usar Atomicos](#cuando-usar-atomicos)\n- [Modelo de Memoria](#modelo-de-memoria)\n- [Carga y Almacenamiento Atomico](#carga-y-almacenamiento-atomico)\n- [Operaciones Fetch-and-Modify](#operaciones-fetch-and-modify)\n- [Compare-and-Swap (CAS)](#compare-and-swap-cas)\n- [Intercambio Atomico](#intercambio-atomico)\n- [Barrera de Memoria](#barrera-de-memoria)\n- [Referencia de Funciones](#referencia-de-funciones)\n- [Patrones Comunes](#patrones-comunes)\n- [Mejores Practicas](#mejores-practicas)\n- [Limitaciones](#limitaciones)\n\n---\n\n## Vision General\n\nLas operaciones atomicas son operaciones **indivisibles** que se completan sin posibilidad de interrupcion. Cuando un hilo realiza una operacion atomica, ningun otro hilo puede observar la operacion en un estado parcialmente completado.\n\n**Caracteristicas clave:**\n- Todas las operaciones usan **consistencia secuencial** (`memory_order_seq_cst`)\n- Tipos soportados: **i32** e **i64**\n- Las operaciones trabajan con punteros crudos asignados con `alloc()`\n- Seguro para hilos sin bloqueos explicitos\n\n**Operaciones disponibles:**\n- Load/Store - Leer y escribir valores atomicamente\n- Add/Sub - Operaciones aritmeticas que retornan el valor anterior\n- And/Or/Xor - Operaciones de bits que retornan el valor anterior\n- CAS - Compare-and-swap para actualizaciones condicionales\n- Exchange - Intercambiar valores atomicamente\n- Fence - Barrera de memoria completa\n\n---\n\n## Cuando Usar Atomicos\n\n**Usar atomicos para:**\n- Contadores compartidos entre tareas (ej. conteos de solicitudes, seguimiento de progreso)\n- Flags e indicadores de estado\n- Estructuras de datos sin bloqueos\n- Primitivas de sincronizacion simples\n- Codigo concurrente critico en rendimiento\n\n**Usar canales en su lugar cuando:**\n- Pasar datos complejos entre tareas\n- Implementar patrones productor-consumidor\n- Necesitas semantica de paso de mensajes\n\n**Caso de uso de ejemplo - Contador compartido:**\n```hemlock\n// Asignar contador compartido\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nasync fn worker(counter: ptr, id: i32) {\n    let i = 0;\n    while (i < 1000) {\n        atomic_add_i32(counter, 1);\n        i = i + 1;\n    }\n}\n\n// Crear multiples workers\nlet t1 = spawn(worker, counter, 1);\nlet t2 = spawn(worker, counter, 2);\nlet t3 = spawn(worker, counter, 3);\n\njoin(t1);\njoin(t2);\njoin(t3);\n\n// El contador sera exactamente 3000 (sin carreras de datos)\nprint(atomic_load_i32(counter));\n\nfree(counter);\n```\n\n---\n\n## Modelo de Memoria\n\nTodas las operaciones atomicas de Hemlock usan **consistencia secuencial** (`memory_order_seq_cst`), que proporciona las garantias de ordenamiento de memoria mas fuertes:\n\n1. **Atomicidad**: Cada operacion es indivisible\n2. **Ordenamiento total**: Todos los hilos ven el mismo orden de operaciones\n3. **Sin reordenamiento**: Las operaciones no son reordenadas por el compilador o la CPU\n\nEsto hace que razonar sobre codigo concurrente sea mas simple, a costa de algo de rendimiento potencial comparado con ordenamientos de memoria mas debiles.\n\n---\n\n## Carga y Almacenamiento Atomico\n\n### atomic_load_i32 / atomic_load_i64\n\nLeer atomicamente un valor de memoria.\n\n**Firma:**\n```hemlock\natomic_load_i32(ptr: ptr): i32\natomic_load_i64(ptr: ptr): i64\n```\n\n**Parametros:**\n- `ptr` - Puntero a la ubicacion de memoria (debe estar correctamente alineado)\n\n**Retorna:** El valor en la ubicacion de memoria\n\n**Ejemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\n\nlet value = atomic_load_i32(p);\nprint(value);  // 42\n\nfree(p);\n```\n\n---\n\n### atomic_store_i32 / atomic_store_i64\n\nEscribir atomicamente un valor a memoria.\n\n**Firma:**\n```hemlock\natomic_store_i32(ptr: ptr, value: i32): null\natomic_store_i64(ptr: ptr, value: i64): null\n```\n\n**Parametros:**\n- `ptr` - Puntero a la ubicacion de memoria\n- `value` - Valor a almacenar\n\n**Retorna:** `null`\n\n**Ejemplo:**\n```hemlock\nlet p = alloc(8);\n\natomic_store_i64(p, 5000000000);\nprint(atomic_load_i64(p));  // 5000000000\n\nfree(p);\n```\n\n---\n\n## Operaciones Fetch-and-Modify\n\nEstas operaciones modifican atomicamente un valor y retornan el valor **anterior** (previo).\n\n### atomic_add_i32 / atomic_add_i64\n\nSumar atomicamente a un valor.\n\n**Firma:**\n```hemlock\natomic_add_i32(ptr: ptr, value: i32): i32\natomic_add_i64(ptr: ptr, value: i64): i64\n```\n\n**Retorna:** El valor **anterior** (antes de la suma)\n\n**Ejemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_add_i32(p, 10);\nprint(old);                    // 100 (valor anterior)\nprint(atomic_load_i32(p));     // 110 (valor nuevo)\n\nfree(p);\n```\n\n---\n\n### atomic_sub_i32 / atomic_sub_i64\n\nRestar atomicamente de un valor.\n\n**Firma:**\n```hemlock\natomic_sub_i32(ptr: ptr, value: i32): i32\natomic_sub_i64(ptr: ptr, value: i64): i64\n```\n\n**Retorna:** El valor **anterior** (antes de la resta)\n\n**Ejemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_sub_i32(p, 25);\nprint(old);                    // 100 (valor anterior)\nprint(atomic_load_i32(p));     // 75 (valor nuevo)\n\nfree(p);\n```\n\n---\n\n### atomic_and_i32 / atomic_and_i64\n\nRealizar atomicamente AND de bits.\n\n**Firma:**\n```hemlock\natomic_and_i32(ptr: ptr, value: i32): i32\natomic_and_i64(ptr: ptr, value: i64): i64\n```\n\n**Retorna:** El valor **anterior** (antes del AND)\n\n**Ejemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xFF);  // 255 en binario: 11111111\n\nlet old = atomic_and_i32(p, 0x0F);  // AND con 00001111\nprint(old);                    // 255 (valor anterior)\nprint(atomic_load_i32(p));     // 15 (0xFF & 0x0F = 0x0F)\n\nfree(p);\n```\n\n---\n\n### atomic_or_i32 / atomic_or_i64\n\nRealizar atomicamente OR de bits.\n\n**Firma:**\n```hemlock\natomic_or_i32(ptr: ptr, value: i32): i32\natomic_or_i64(ptr: ptr, value: i64): i64\n```\n\n**Retorna:** El valor **anterior** (antes del OR)\n\n**Ejemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0x0F);  // 15 en binario: 00001111\n\nlet old = atomic_or_i32(p, 0xF0);  // OR con 11110000\nprint(old);                    // 15 (valor anterior)\nprint(atomic_load_i32(p));     // 255 (0x0F | 0xF0 = 0xFF)\n\nfree(p);\n```\n\n---\n\n### atomic_xor_i32 / atomic_xor_i64\n\nRealizar atomicamente XOR de bits.\n\n**Firma:**\n```hemlock\natomic_xor_i32(ptr: ptr, value: i32): i32\natomic_xor_i64(ptr: ptr, value: i64): i64\n```\n\n**Retorna:** El valor **anterior** (antes del XOR)\n\n**Ejemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xAA);  // 170 en binario: 10101010\n\nlet old = atomic_xor_i32(p, 0xFF);  // XOR con 11111111\nprint(old);                    // 170 (valor anterior)\nprint(atomic_load_i32(p));     // 85 (0xAA ^ 0xFF = 0x55)\n\nfree(p);\n```\n\n---\n\n## Compare-and-Swap (CAS)\n\nLa operacion atomica mas poderosa. Compara atomicamente el valor actual con un valor esperado y, si coinciden, lo reemplaza con un nuevo valor.\n\n### atomic_cas_i32 / atomic_cas_i64\n\n**Firma:**\n```hemlock\natomic_cas_i32(ptr: ptr, expected: i32, desired: i32): bool\natomic_cas_i64(ptr: ptr, expected: i64, desired: i64): bool\n```\n\n**Parametros:**\n- `ptr` - Puntero a la ubicacion de memoria\n- `expected` - Valor que esperamos encontrar\n- `desired` - Valor a almacenar si la expectativa coincide\n\n**Retorna:**\n- `true` - El intercambio tuvo exito (el valor era `expected`, ahora es `desired`)\n- `false` - El intercambio fallo (el valor no era `expected`, sin cambios)\n\n**Ejemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\n// CAS exitoso: el valor es 100, intercambiar a 999\nlet success1 = atomic_cas_i32(p, 100, 999);\nprint(success1);               // true\nprint(atomic_load_i32(p));     // 999\n\n// CAS fallido: el valor es 999, no 100\nlet success2 = atomic_cas_i32(p, 100, 888);\nprint(success2);               // false\nprint(atomic_load_i32(p));     // 999 (sin cambios)\n\nfree(p);\n```\n\n**Casos de uso:**\n- Implementar bloqueos y semaforos\n- Estructuras de datos sin bloqueos\n- Control de concurrencia optimista\n- Actualizaciones condicionales atomicas\n\n---\n\n## Intercambio Atomico\n\nIntercambiar atomicamente un valor, retornando el valor anterior.\n\n### atomic_exchange_i32 / atomic_exchange_i64\n\n**Firma:**\n```hemlock\natomic_exchange_i32(ptr: ptr, value: i32): i32\natomic_exchange_i64(ptr: ptr, value: i64): i64\n```\n\n**Parametros:**\n- `ptr` - Puntero a la ubicacion de memoria\n- `value` - Nuevo valor a almacenar\n\n**Retorna:** El valor **anterior** (antes del intercambio)\n\n**Ejemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_exchange_i32(p, 200);\nprint(old);                    // 100 (valor anterior)\nprint(atomic_load_i32(p));     // 200 (valor nuevo)\n\nfree(p);\n```\n\n---\n\n## Barrera de Memoria\n\nUna barrera de memoria completa que asegura que todas las operaciones de memoria antes de la barrera sean visibles para todos los hilos antes de cualquier operacion despues de la barrera.\n\n### atomic_fence\n\n**Firma:**\n```hemlock\natomic_fence(): null\n```\n\n**Retorna:** `null`\n\n**Ejemplo:**\n```hemlock\n// Asegurar que todas las escrituras anteriores sean visibles\natomic_fence();\n```\n\n**Nota:** En la mayoria de los casos, no necesitas barreras explicitas porque todas las operaciones atomicas ya usan consistencia secuencial. Las barreras son utiles cuando necesitas sincronizar operaciones de memoria no atomicas.\n\n---\n\n## Referencia de Funciones\n\n### Operaciones i32\n\n| Funcion | Firma | Retorna | Descripcion |\n|---------|-------|---------|-------------|\n| `atomic_load_i32` | `(ptr)` | `i32` | Cargar valor atomicamente |\n| `atomic_store_i32` | `(ptr, value)` | `null` | Almacenar valor atomicamente |\n| `atomic_add_i32` | `(ptr, value)` | `i32` | Sumar y retornar valor anterior |\n| `atomic_sub_i32` | `(ptr, value)` | `i32` | Restar y retornar valor anterior |\n| `atomic_and_i32` | `(ptr, value)` | `i32` | AND de bits y retornar valor anterior |\n| `atomic_or_i32` | `(ptr, value)` | `i32` | OR de bits y retornar valor anterior |\n| `atomic_xor_i32` | `(ptr, value)` | `i32` | XOR de bits y retornar valor anterior |\n| `atomic_cas_i32` | `(ptr, expected, desired)` | `bool` | Compare-and-swap |\n| `atomic_exchange_i32` | `(ptr, value)` | `i32` | Intercambiar y retornar valor anterior |\n\n### Operaciones i64\n\n| Funcion | Firma | Retorna | Descripcion |\n|---------|-------|---------|-------------|\n| `atomic_load_i64` | `(ptr)` | `i64` | Cargar valor atomicamente |\n| `atomic_store_i64` | `(ptr, value)` | `null` | Almacenar valor atomicamente |\n| `atomic_add_i64` | `(ptr, value)` | `i64` | Sumar y retornar valor anterior |\n| `atomic_sub_i64` | `(ptr, value)` | `i64` | Restar y retornar valor anterior |\n| `atomic_and_i64` | `(ptr, value)` | `i64` | AND de bits y retornar valor anterior |\n| `atomic_or_i64` | `(ptr, value)` | `i64` | OR de bits y retornar valor anterior |\n| `atomic_xor_i64` | `(ptr, value)` | `i64` | XOR de bits y retornar valor anterior |\n| `atomic_cas_i64` | `(ptr, expected, desired)` | `bool` | Compare-and-swap |\n| `atomic_exchange_i64` | `(ptr, value)` | `i64` | Intercambiar y retornar valor anterior |\n\n### Barrera de Memoria\n\n| Funcion | Firma | Retorna | Descripcion |\n|---------|-------|---------|-------------|\n| `atomic_fence` | `()` | `null` | Barrera de memoria completa |\n\n---\n\n## Patrones Comunes\n\n### Patron: Contador Atomico\n\n```hemlock\n// Contador seguro para hilos\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nfn increment(): i32 {\n    return atomic_add_i32(counter, 1);\n}\n\nfn decrement(): i32 {\n    return atomic_sub_i32(counter, 1);\n}\n\nfn get_count(): i32 {\n    return atomic_load_i32(counter);\n}\n\n// Uso\nincrement();  // Retorna 0 (valor anterior)\nincrement();  // Retorna 1\nincrement();  // Retorna 2\nprint(get_count());  // 3\n\nfree(counter);\n```\n\n### Patron: Spinlock\n\n```hemlock\n// Implementacion simple de spinlock\nlet lock = alloc(4);\nptr_write_i32(lock, 0);  // 0 = desbloqueado, 1 = bloqueado\n\nfn acquire() {\n    // Girar hasta que establezcamos exitosamente el bloqueo de 0 a 1\n    while (!atomic_cas_i32(lock, 0, 1)) {\n        // Espera activa\n    }\n}\n\nfn release() {\n    atomic_store_i32(lock, 0);\n}\n\n// Uso\nacquire();\n// ... seccion critica ...\nrelease();\n\nfree(lock);\n```\n\n### Patron: Inicializacion Unica\n\n```hemlock\nlet initialized = alloc(4);\nptr_write_i32(initialized, 0);  // 0 = no inicializado, 1 = inicializado\n\nfn ensure_initialized() {\n    // Intentar ser el que inicializa\n    if (atomic_cas_i32(initialized, 0, 1)) {\n        // Ganamos la carrera, hacer inicializacion\n        do_expensive_init();\n    }\n    // De lo contrario, ya inicializado\n}\n```\n\n### Patron: Flag Atomico\n\n```hemlock\nlet flag = alloc(4);\nptr_write_i32(flag, 0);\n\nfn set_flag() {\n    atomic_store_i32(flag, 1);\n}\n\nfn clear_flag() {\n    atomic_store_i32(flag, 0);\n}\n\nfn test_and_set(): bool {\n    // Retorna true si el flag ya estaba establecido\n    return atomic_exchange_i32(flag, 1) == 1;\n}\n\nfn check_flag(): bool {\n    return atomic_load_i32(flag) == 1;\n}\n```\n\n### Patron: Contador Acotado\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\nlet max_value = 100;\n\nfn try_increment(): bool {\n    while (true) {\n        let current = atomic_load_i32(counter);\n        if (current >= max_value) {\n            return false;  // En el maximo\n        }\n        if (atomic_cas_i32(counter, current, current + 1)) {\n            return true;  // Incrementado exitosamente\n        }\n        // CAS fallo, otro hilo modifico - reintentar\n    }\n}\n```\n\n---\n\n## Mejores Practicas\n\n### 1. Usar Alineacion Apropiada\n\nLos punteros deben estar correctamente alineados para el tipo de datos:\n- i32: alineacion de 4 bytes\n- i64: alineacion de 8 bytes\n\nLa memoria de `alloc()` tipicamente esta correctamente alineada.\n\n### 2. Preferir Abstracciones de Nivel Superior\n\nCuando sea posible, usa canales para comunicacion entre tareas. Los atomicos son de nivel mas bajo y requieren razonamiento cuidadoso.\n\n```hemlock\n// Preferir esto:\nlet ch = channel(10);\nspawn(fn() { ch.send(result); });\nlet value = ch.recv();\n\n// Sobre coordinacion atomica manual cuando sea apropiado\n```\n\n### 3. Estar Consciente del Problema ABA\n\nCAS puede sufrir del problema ABA: un valor cambia de A a B y vuelve a A. Tu CAS tiene exito, pero el estado puede haber cambiado entre medio.\n\n### 4. Inicializar Antes de Compartir\n\nSiempre inicializa las variables atomicas antes de crear tareas que las accedan:\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);  // Inicializar ANTES de crear tareas\n\nlet task = spawn(worker, counter);\n```\n\n### 5. Liberar Despues de que Todas las Tareas Completen\n\nNo liberes memoria atomica mientras las tareas todavia podrian accederla:\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nlet t1 = spawn(worker, counter);\nlet t2 = spawn(worker, counter);\n\njoin(t1);\njoin(t2);\n\n// Ahora es seguro liberar\nfree(counter);\n```\n\n---\n\n## Limitaciones\n\n### Limitaciones Actuales\n\n1. **Solo i32 e i64 soportados** - Sin operaciones atomicas para otros tipos\n2. **Sin atomicos de puntero** - No se pueden cargar/almacenar punteros atomicamente\n3. **Solo consistencia secuencial** - Sin ordenamientos de memoria mas debiles disponibles\n4. **Sin punto flotante atomico** - Usar representacion entera si es necesario\n\n### Notas de Plataforma\n\n- Las operaciones atomicas usan `<stdatomic.h>` de C11 internamente\n- Disponible en todas las plataformas que soportan hilos POSIX\n- Garantizado estar libre de bloqueos en sistemas modernos de 64 bits\n\n---\n\n## Ver Tambien\n\n- [Async/Concurrencia](#advanced-async-concurrency) - Creacion de tareas y canales\n- [Gestion de Memoria](#language-guide-memory) - Asignacion de punteros y buffers\n- [API de Memoria](#reference-memory-api) - Funciones de asignacion\n"}, "Temas Avanzados -> Perfilado": {"id": "advanced-profiling", "content": "# Perfilado\n\nHemlock incluye un perfilador integrado para **analisis de tiempo de CPU**, **seguimiento de memoria** y **deteccion de fugas**. El perfilador ayuda a identificar cuellos de botella de rendimiento y problemas de memoria en tus programas.\n\n## Tabla de Contenidos\n\n- [Vision General](#vision-general)\n- [Inicio Rapido](#inicio-rapido)\n- [Modos de Perfilado](#modos-de-perfilado)\n- [Formatos de Salida](#formatos-de-salida)\n- [Deteccion de Fugas](#deteccion-de-fugas)\n- [Entendiendo los Reportes](#entendiendo-los-reportes)\n- [Generacion de Flamegraph](#generacion-de-flamegraph)\n- [Mejores Practicas](#mejores-practicas)\n\n---\n\n## Vision General\n\nEl perfilador se accede via el subcomando `profile`:\n\n```bash\nhemlock profile [OPTIONS] <FILE>\n```\n\n**Caracteristicas clave:**\n- **Perfilado de CPU** - Medir tiempo gastado en cada funcion (tiempo propio y tiempo total)\n- **Perfilado de memoria** - Rastrear todas las asignaciones con ubicaciones de codigo fuente\n- **Deteccion de fugas** - Identificar memoria que nunca fue liberada\n- **Multiples formatos de salida** - Texto, JSON y salida compatible con flamegraph\n- **Estadisticas de memoria por funcion** - Ver que funciones asignan mas memoria\n\n---\n\n## Inicio Rapido\n\n### Perfilar tiempo de CPU (por defecto)\n\n```bash\nhemlock profile script.hml\n```\n\n### Perfilar asignaciones de memoria\n\n```bash\nhemlock profile --memory script.hml\n```\n\n### Detectar fugas de memoria\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n### Generar datos de flamegraph\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\nflamegraph.pl profile.folded > profile.svg\n```\n\n---\n\n## Modos de Perfilado\n\n### Perfilado de CPU (por defecto)\n\nMide el tiempo gastado en cada funcion, distinguiendo entre:\n- **Tiempo propio** - Tiempo gastado ejecutando el codigo propio de la funcion\n- **Tiempo total** - Tiempo propio mas tiempo gastado en funciones llamadas\n\n```bash\nhemlock profile script.hml\nhemlock profile --cpu script.hml  # Explicito\n```\n\n**Ejemplo de salida:**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 1.234ms\nFunctions called: 5 unique\n\n--- Top 5 by Self Time ---\n\nFunction                        Self      Total   Calls\n--------                        ----      -----   -----\nexpensive_calc              0.892ms    0.892ms     100  (72.3%)\nprocess_data                0.234ms    1.126ms      10  (19.0%)\nhelper                      0.067ms    0.067ms     500  (5.4%)\nmain                        0.041ms    1.234ms       1  (3.3%)\n```\n\n---\n\n### Perfilado de Memoria\n\nRastrea todas las asignaciones de memoria (`alloc`, `buffer`, `talloc`, `realloc`) con ubicaciones de codigo fuente.\n\n```bash\nhemlock profile --memory script.hml\n```\n\n**Ejemplo de salida:**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 0.543ms\nFunctions called: 3 unique\nTotal allocations: 15 (4.2KB)\n\n--- Top 3 by Self Time ---\n\nFunction                        Self      Total   Calls      Alloc      Count\n--------                        ----      -----   -----      -----      -----\nallocator                   0.312ms    0.312ms      10      3.2KB         10  (57.5%)\nbuffer_ops                  0.156ms    0.156ms       5       1KB          5  (28.7%)\nmain                        0.075ms    0.543ms       1        0B          0  (13.8%)\n\n--- Top 10 Allocation Sites ---\n\nLocation                                      Total    Count\n--------                                      -----    -----\nsrc/data.hml:42                               1.5KB        5\nsrc/data.hml:67                               1.0KB       10\nsrc/main.hml:15                               512B         1\n```\n\n---\n\n### Modo de Conteo de Llamadas\n\nModo de sobrecarga minima que solo cuenta llamadas a funciones (sin tiempos).\n\n```bash\nhemlock profile --calls script.hml\n```\n\n---\n\n## Formatos de Salida\n\n### Texto (por defecto)\n\nResumen legible por humanos con tablas.\n\n```bash\nhemlock profile script.hml\n```\n\n---\n\n### JSON\n\nFormato legible por maquina para integracion con otras herramientas.\n\n```bash\nhemlock profile --json script.hml\n```\n\n**Ejemplo de salida:**\n```json\n{\n  \"total_time_ns\": 1234567,\n  \"function_count\": 5,\n  \"total_alloc_bytes\": 4096,\n  \"total_alloc_count\": 15,\n  \"functions\": [\n    {\n      \"name\": \"expensive_calc\",\n      \"source_file\": \"script.hml\",\n      \"line\": 10,\n      \"self_time_ns\": 892000,\n      \"total_time_ns\": 892000,\n      \"call_count\": 100,\n      \"alloc_bytes\": 0,\n      \"alloc_count\": 0\n    }\n  ],\n  \"alloc_sites\": [\n    {\n      \"source_file\": \"script.hml\",\n      \"line\": 42,\n      \"total_bytes\": 1536,\n      \"alloc_count\": 5,\n      \"current_bytes\": 0\n    }\n  ]\n}\n```\n\n---\n\n### Flamegraph\n\nGenera formato de pila colapsada compatible con [flamegraph.pl](https://github.com/brendangregg/FlameGraph).\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\n\n# Generar SVG con flamegraph.pl\nflamegraph.pl profile.folded > profile.svg\n```\n\n**Ejemplo de salida colapsada:**\n```\nmain;process_data;expensive_calc 892\nmain;process_data;helper 67\nmain;process_data 234\nmain 41\n```\n\n---\n\n## Deteccion de Fugas\n\nEl flag `--leaks` muestra solo asignaciones que nunca fueron liberadas, haciendo facil identificar fugas de memoria.\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n**Programa de ejemplo con fugas:**\n```hemlock\nfn leaky() {\n    let p1 = alloc(100);    // Fuga - nunca liberado\n    let p2 = alloc(200);    // OK - liberado abajo\n    free(p2);\n}\n\nfn clean() {\n    let b = buffer(64);\n    free(b);                // Correctamente liberado\n}\n\nleaky();\nclean();\n```\n\n**Salida con --leaks:**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 0.034ms\nFunctions called: 2 unique\nTotal allocations: 3 (388B)\n\n--- Top 2 by Self Time ---\n\nFunction                        Self      Total   Calls      Alloc      Count\n--------                        ----      -----   -----      -----      -----\nleaky                       0.021ms    0.021ms       1       300B          2  (61.8%)\nclean                       0.013ms    0.013ms       1        88B          1  (38.2%)\n\n--- Memory Leaks (1 site) ---\n\nLocation                                     Leaked      Total    Count\n--------                                     ------      -----    -----\nscript.hml:2                                   100B       100B        1\n```\n\nEl reporte de fugas muestra:\n- **Leaked** - Bytes actualmente sin liberar al terminar el programa\n- **Total** - Total de bytes alguna vez asignados en este sitio\n- **Count** - Numero de asignaciones en este sitio\n\n---\n\n## Entendiendo los Reportes\n\n### Estadisticas de Funcion\n\n| Columna | Descripcion |\n|---------|-------------|\n| Function | Nombre de funcion |\n| Self | Tiempo en funcion excluyendo funciones llamadas |\n| Total | Tiempo incluyendo todas las funciones llamadas |\n| Calls | Numero de veces que la funcion fue llamada |\n| Alloc | Total de bytes asignados por esta funcion |\n| Count | Numero de asignaciones por esta funcion |\n| (%) | Porcentaje del tiempo total del programa |\n\n### Sitios de Asignacion\n\n| Columna | Descripcion |\n|---------|-------------|\n| Location | Archivo fuente y numero de linea |\n| Total | Total de bytes asignados en esta ubicacion |\n| Count | Numero de asignaciones |\n| Leaked | Bytes todavia asignados al terminar el programa (solo --leaks) |\n\n### Unidades de Tiempo\n\nEl perfilador selecciona automaticamente unidades apropiadas:\n- `ns` - Nanosegundos (< 1us)\n- `us` - Microsegundos (< 1ms)\n- `ms` - Milisegundos (< 1s)\n- `s` - Segundos\n\n---\n\n## Referencia de Comandos\n\n```\nhemlock profile [OPTIONS] <FILE>\n\nOPTIONS:\n    --cpu           Perfilado de CPU/tiempo (por defecto)\n    --memory        Perfilado de asignacion de memoria\n    --calls         Solo conteo de llamadas (sobrecarga minima)\n    --leaks         Mostrar solo asignaciones sin liberar (implica --memory)\n    --json          Salida en formato JSON\n    --flamegraph    Salida en formato compatible con flamegraph\n    --top N         Mostrar top N entradas (por defecto: 20)\n```\n\n---\n\n## Generacion de Flamegraph\n\nLos flamegraphs visualizan donde tu programa pasa tiempo, con barras mas anchas indicando mas tiempo gastado.\n\n### Generar un Flamegraph\n\n1. Instalar flamegraph.pl:\n   ```bash\n   git clone https://github.com/brendangregg/FlameGraph\n   ```\n\n2. Perfilar tu programa:\n   ```bash\n   hemlock profile --flamegraph script.hml > profile.folded\n   ```\n\n3. Generar SVG:\n   ```bash\n   ./FlameGraph/flamegraph.pl profile.folded > profile.svg\n   ```\n\n4. Abrir `profile.svg` en un navegador para una visualizacion interactiva.\n\n### Leyendo Flamegraphs\n\n- **Eje X**: Porcentaje de tiempo total (ancho = proporcion de tiempo)\n- **Eje Y**: Profundidad de pila de llamadas (abajo = punto de entrada, arriba = funciones hoja)\n- **Color**: Aleatorio, solo para distincion visual\n- **Click**: Hacer zoom en una funcion para ver sus funciones llamadas\n\n---\n\n## Mejores Practicas\n\n### 1. Perfilar Cargas de Trabajo Representativas\n\nPerfilar con datos y patrones de uso realistas. Casos de prueba pequenos pueden no revelar cuellos de botella reales.\n\n```bash\n# Bueno: Perfilar con datos similares a produccion\nhemlock profile --memory process_large_file.hml large_input.txt\n\n# Menos util: Caso de prueba pequeno\nhemlock profile quick_test.hml\n```\n\n### 2. Usar --leaks Durante Desarrollo\n\nEjecutar deteccion de fugas regularmente para detectar fugas de memoria temprano:\n\n```bash\nhemlock profile --leaks my_program.hml\n```\n\n### 3. Comparar Antes y Despues\n\nPerfilar antes y despues de optimizaciones para medir impacto:\n\n```bash\n# Antes de optimizacion\nhemlock profile --json script.hml > before.json\n\n# Despues de optimizacion\nhemlock profile --json script.hml > after.json\n\n# Comparar resultados\n```\n\n### 4. Usar --top para Programas Grandes\n\nLimitar salida para enfocarse en las funciones mas significativas:\n\n```bash\nhemlock profile --top 10 large_program.hml\n```\n\n### 5. Combinar con Flamegraphs\n\nPara patrones de llamada complejos, los flamegraphs proporcionan mejor visualizacion que salida de texto:\n\n```bash\nhemlock profile --flamegraph complex_app.hml > app.folded\nflamegraph.pl app.folded > app.svg\n```\n\n---\n\n## Sobrecarga del Perfilador\n\nEl perfilador agrega algo de sobrecarga a la ejecucion del programa:\n\n| Modo | Sobrecarga | Caso de Uso |\n|------|------------|-------------|\n| `--calls` | Minima | Solo contar llamadas a funciones |\n| `--cpu` | Baja | Perfilado de rendimiento general |\n| `--memory` | Moderada | Analisis de memoria y deteccion de fugas |\n\nPara resultados mas precisos, perfilar multiples veces y buscar patrones consistentes.\n\n---\n\n## Ver Tambien\n\n- [Gestion de Memoria](#language-guide-memory) - Punteros y buffers\n- [API de Memoria](#reference-memory-api) - Funciones alloc, free, buffer\n- [Async/Concurrencia](#advanced-async-concurrency) - Perfilando codigo async\n"}, "Temas Avanzados -> Seales": {"id": "advanced-signals", "content": "# Manejo de Senales en Hemlock\n\nHemlock proporciona **manejo de senales POSIX** para gestionar senales del sistema como SIGINT (Ctrl+C), SIGTERM y senales personalizadas. Esto habilita control de procesos de bajo nivel y comunicacion entre procesos.\n\n## Tabla de Contenidos\n\n- [Vision General](#vision-general)\n- [API de Senales](#api-de-senales)\n- [Constantes de Senal](#constantes-de-senal)\n- [Manejo Basico de Senales](#manejo-basico-de-senales)\n- [Patrones Avanzados](#patrones-avanzados)\n- [Comportamiento del Manejador de Senales](#comportamiento-del-manejador-de-senales)\n- [Consideraciones de Seguridad](#consideraciones-de-seguridad)\n- [Casos de Uso Comunes](#casos-de-uso-comunes)\n- [Ejemplos Completos](#ejemplos-completos)\n\n## Vision General\n\nEl manejo de senales permite a los programas:\n- Responder a interrupciones de usuario (Ctrl+C, Ctrl+Z)\n- Implementar apagado gracioso\n- Manejar solicitudes de terminacion\n- Usar senales personalizadas para comunicacion entre procesos\n- Crear mecanismos de alarma/temporizador\n\n**Importante:** El manejo de senales es **inherentemente inseguro** en la filosofia de Hemlock. Los manejadores pueden llamarse en cualquier momento, interrumpiendo la ejecucion normal. El usuario es responsable de la sincronizacion apropiada.\n\n## API de Senales\n\n### signal(signum, handler_fn)\n\nRegistrar una funcion manejadora de senal.\n\n**Parametros:**\n- `signum` (i32) - Numero de senal (constante como SIGINT, SIGTERM)\n- `handler_fn` (funcion o null) - Funcion a llamar cuando se recibe la senal, o `null` para restablecer al comportamiento por defecto\n\n**Retorna:** La funcion manejadora anterior (o `null` si no habia ninguna)\n\n**Ejemplo:**\n```hemlock\nfn my_handler(sig) {\n    print(\"Caught signal: \" + typeof(sig));\n}\n\nlet old_handler = signal(SIGINT, my_handler);\n```\n\n**Restableciendo al comportamiento por defecto:**\n```hemlock\nsignal(SIGINT, null);  // Restablecer SIGINT al comportamiento por defecto\n```\n\n### raise(signum)\n\nEnviar una senal al proceso actual.\n\n**Parametros:**\n- `signum` (i32) - Numero de senal a enviar\n\n**Retorna:** `null`\n\n**Ejemplo:**\n```hemlock\nraise(SIGUSR1);  // Disparar manejador de SIGUSR1\n```\n\n## Constantes de Senal\n\nHemlock proporciona constantes de senal POSIX estandar como valores i32.\n\n### Interrupcion y Terminacion\n\n| Constante | Valor | Descripcion | Disparador Comun |\n|-----------|-------|-------------|------------------|\n| `SIGINT` | 2 | Interrupcion desde teclado | Ctrl+C |\n| `SIGTERM` | 15 | Solicitud de terminacion | Comando `kill` |\n| `SIGQUIT` | 3 | Salir desde teclado | Ctrl+\\ |\n| `SIGHUP` | 1 | Hangup detectado | Terminal cerrada |\n| `SIGABRT` | 6 | Senal de aborto | Funcion `abort()` |\n\n**Ejemplos:**\n```hemlock\nsignal(SIGINT, handle_interrupt);   // Ctrl+C\nsignal(SIGTERM, handle_terminate);  // Comando kill\nsignal(SIGHUP, handle_hangup);      // Terminal se cierra\n```\n\n### Senales Definidas por Usuario\n\n| Constante | Valor | Descripcion | Caso de Uso |\n|-----------|-------|-------------|-------------|\n| `SIGUSR1` | 10 | Senal definida por usuario 1 | IPC personalizado |\n| `SIGUSR2` | 12 | Senal definida por usuario 2 | IPC personalizado |\n\n**Ejemplos:**\n```hemlock\n// Usar para comunicacion personalizada\nsignal(SIGUSR1, reload_config);\nsignal(SIGUSR2, rotate_logs);\n```\n\n### Control de Proceso\n\n| Constante | Valor | Descripcion | Notas |\n|-----------|-------|-------------|-------|\n| `SIGALRM` | 14 | Temporizador de alarma | Despues de `alarm()` |\n| `SIGCHLD` | 17 | Cambio de estado de proceso hijo | Gestion de procesos |\n| `SIGCONT` | 18 | Continuar si esta detenido | Reanudar despues de SIGSTOP |\n| `SIGSTOP` | 19 | Detener proceso | **No puede capturarse** |\n| `SIGTSTP` | 20 | Detener desde terminal | Ctrl+Z |\n\n**Ejemplos:**\n```hemlock\nsignal(SIGALRM, handle_timeout);\nsignal(SIGCHLD, handle_child_exit);\n```\n\n### Senales de E/S\n\n| Constante | Valor | Descripcion | Cuando se Envia |\n|-----------|-------|-------------|-----------------|\n| `SIGPIPE` | 13 | Pipe roto | Escribir a pipe cerrado |\n| `SIGTTIN` | 21 | Lectura en segundo plano desde terminal | Proceso BG lee TTY |\n| `SIGTTOU` | 22 | Escritura en segundo plano a terminal | Proceso BG escribe TTY |\n\n**Ejemplos:**\n```hemlock\nsignal(SIGPIPE, handle_broken_pipe);\n```\n\n## Manejo Basico de Senales\n\n### Capturando Ctrl+C\n\n```hemlock\nlet interrupted = false;\n\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n    interrupted = true;\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// El programa continua ejecutandose...\n// El usuario presiona Ctrl+C -> handle_interrupt() es llamada\n\nwhile (!interrupted) {\n    // Hacer trabajo...\n}\n\nprint(\"Exiting due to interrupt\");\n```\n\n### Firma de Funcion Manejadora\n\nLos manejadores de senal reciben un argumento: el numero de senal (i32)\n\n```hemlock\nfn my_handler(signum) {\n    print(\"Received signal: \" + typeof(signum));\n    // signum contiene el numero de senal (ej. 2 para SIGINT)\n\n    if (signum == SIGINT) {\n        print(\"This is SIGINT\");\n    }\n}\n\nsignal(SIGINT, my_handler);\nsignal(SIGTERM, my_handler);  // Mismo manejador para multiples senales\n```\n\n### Multiples Manejadores de Senal\n\nDiferentes manejadores para diferentes senales:\n\n```hemlock\nfn handle_int(sig) {\n    print(\"SIGINT received\");\n}\n\nfn handle_term(sig) {\n    print(\"SIGTERM received\");\n}\n\nfn handle_usr1(sig) {\n    print(\"SIGUSR1 received\");\n}\n\nsignal(SIGINT, handle_int);\nsignal(SIGTERM, handle_term);\nsignal(SIGUSR1, handle_usr1);\n```\n\n### Restableciendo al Comportamiento por Defecto\n\nPasar `null` como manejador para restablecer al comportamiento por defecto:\n\n```hemlock\n// Registrar manejador personalizado\nsignal(SIGINT, my_handler);\n\n// Despues, restablecer al comportamiento por defecto (terminar en SIGINT)\nsignal(SIGINT, null);\n```\n\n### Enviando Senales Manualmente\n\nEnviar senales a tu propio proceso:\n\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\n// Disparar manejador manualmente\nraise(SIGUSR1);\nraise(SIGUSR1);\n\nprint(count);  // 2\n```\n\n## Patrones Avanzados\n\n### Patron de Apagado Gracioso\n\nPatron comun para limpieza en terminacion:\n\n```hemlock\nlet should_exit = false;\n\nfn handle_shutdown(sig) {\n    print(\"Shutting down gracefully...\");\n    should_exit = true;\n}\n\nsignal(SIGINT, handle_shutdown);\nsignal(SIGTERM, handle_shutdown);\n\n// Bucle principal\nwhile (!should_exit) {\n    // Hacer trabajo...\n    // Verificar flag should_exit periodicamente\n}\n\nprint(\"Cleanup complete\");\n```\n\n### Contador de Senales\n\nRastrear numero de senales recibidas:\n\n```hemlock\nlet signal_count = 0;\n\nfn count_signals(sig) {\n    signal_count = signal_count + 1;\n    print(\"Received \" + typeof(signal_count) + \" signals\");\n}\n\nsignal(SIGUSR1, count_signals);\n\n// Despues...\nprint(\"Total signals: \" + typeof(signal_count));\n```\n\n### Recarga de Configuracion en Senal\n\n```hemlock\nlet config = load_config();\n\nfn reload_config(sig) {\n    print(\"Reloading configuration...\");\n    config = load_config();\n    print(\"Configuration reloaded\");\n}\n\nsignal(SIGHUP, reload_config);  // Recargar en SIGHUP\n\n// Enviar SIGHUP al proceso para recargar config\n// Desde shell: kill -HUP <pid>\n```\n\n### Timeout Usando SIGALRM\n\n```hemlock\nlet timed_out = false;\n\nfn handle_alarm(sig) {\n    print(\"Timeout!\");\n    timed_out = true;\n}\n\nsignal(SIGALRM, handle_alarm);\n\n// Establecer alarma (aun no implementado en Hemlock, solo ejemplo)\n// alarm(5);  // timeout de 5 segundos\n\nwhile (!timed_out) {\n    // Hacer trabajo con timeout\n}\n```\n\n### Maquina de Estados Basada en Senales\n\n```hemlock\nlet state = 0;\n\nfn next_state(sig) {\n    state = (state + 1) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nfn prev_state(sig) {\n    state = (state - 1 + 3) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nsignal(SIGUSR1, next_state);  // Avanzar estado\nsignal(SIGUSR2, prev_state);  // Retroceder\n\n// Controlar maquina de estados:\n// kill -USR1 <pid>  # Siguiente estado\n// kill -USR2 <pid>  # Estado anterior\n```\n\n## Comportamiento del Manejador de Senales\n\n### Notas Importantes\n\n**Ejecucion del Manejador:**\n- Los manejadores se llaman **sincronicamente** cuando se recibe la senal\n- Los manejadores se ejecutan en el contexto del proceso actual\n- Los manejadores de senal comparten el entorno de clausura de la funcion donde fueron definidos\n- Los manejadores pueden acceder y modificar variables del ambito exterior (como globales o variables capturadas)\n\n**Mejores Practicas:**\n- Mantener los manejadores simples y rapidos - evitar operaciones de larga duracion\n- Establecer flags en lugar de realizar logica compleja\n- Evitar llamar funciones que puedan tomar bloqueos\n- Estar consciente de que los manejadores pueden interrumpir cualquier operacion\n\n### Que Senales Pueden Capturarse\n\n**Pueden capturarse y manejarse:**\n- SIGINT, SIGTERM, SIGUSR1, SIGUSR2, SIGHUP, SIGQUIT\n- SIGALRM, SIGCHLD, SIGCONT, SIGTSTP\n- SIGPIPE, SIGTTIN, SIGTTOU\n- SIGABRT (pero el programa abortara despues de que el manejador retorne)\n\n**No pueden capturarse:**\n- `SIGKILL` (9) - Siempre termina el proceso\n- `SIGSTOP` (19) - Siempre detiene el proceso\n\n**Dependiente del sistema:**\n- Algunas senales tienen comportamientos por defecto que pueden diferir por sistema\n- Verificar la documentacion de senales de tu plataforma para detalles\n\n### Limitaciones del Manejador\n\n```hemlock\nfn complex_handler(sig) {\n    // Evitar esto en manejadores de senal:\n\n    //  Operaciones de larga duracion\n    // process_large_file();\n\n    //  E/S bloqueante\n    // let f = open(\"log.txt\", \"a\");\n    // f.write(\"Signal received\\n\");\n\n    //  Cambios de estado complejos\n    // rebuild_entire_data_structure();\n\n    //  Establecer flag simple es seguro\n    let should_stop = true;\n\n    //  Actualizaciones simples de contador usualmente son seguras\n    let signal_count = signal_count + 1;\n}\n```\n\n## Consideraciones de Seguridad\n\nEl manejo de senales es **inherentemente inseguro** en la filosofia de Hemlock.\n\n### Condiciones de Carrera\n\nLos manejadores pueden llamarse en cualquier momento, interrumpiendo la ejecucion normal:\n\n```hemlock\nlet counter = 0;\n\nfn increment(sig) {\n    counter = counter + 1;  // Condicion de carrera si se llama durante actualizacion de counter\n}\n\nsignal(SIGUSR1, increment);\n\n// El codigo principal tambien modifica counter\ncounter = counter + 1;  // Podria ser interrumpido por manejador de senal\n```\n\n**Problema:** Si la senal llega mientras el codigo principal esta actualizando `counter`, el resultado es impredecible.\n\n### Seguridad Async-Signal\n\nHemlock **no** garantiza seguridad async-signal:\n- Los manejadores pueden llamar cualquier codigo de Hemlock (a diferencia de las funciones async-signal-safe restringidas de C)\n- Esto proporciona flexibilidad pero requiere precaucion del usuario\n- Las condiciones de carrera son posibles si el manejador modifica estado compartido\n\n### Mejores Practicas para Manejo Seguro de Senales\n\n**1. Usar Flags Atomicos**\n\nAsignaciones booleanas simples son generalmente seguras:\n\n```hemlock\nlet should_exit = false;\n\nfn handler(sig) {\n    should_exit = true;  // Asignacion simple es segura\n}\n\nsignal(SIGINT, handler);\n\nwhile (!should_exit) {\n    // trabajo...\n}\n```\n\n**2. Minimizar Estado Compartido**\n\n```hemlock\nlet interrupt_count = 0;\n\nfn handler(sig) {\n    // Solo modificar esta variable\n    interrupt_count = interrupt_count + 1;\n}\n```\n\n**3. Diferir Operaciones Complejas**\n\n```hemlock\nlet pending_reload = false;\n\nfn signal_reload(sig) {\n    pending_reload = true;  // Solo establecer flag\n}\n\nsignal(SIGHUP, signal_reload);\n\n// En bucle principal:\nwhile (true) {\n    if (pending_reload) {\n        reload_config();  // Hacer trabajo complejo aqui\n        pending_reload = false;\n    }\n\n    // Trabajo normal...\n}\n```\n\n**4. Evitar Problemas de Reentrada**\n\n```hemlock\nlet in_critical_section = false;\nlet data = [];\n\nfn careful_handler(sig) {\n    if (in_critical_section) {\n        // No modificar data mientras el codigo principal lo esta usando\n        return;\n    }\n    // Seguro proceder\n}\n```\n\n## Casos de Uso Comunes\n\n### 1. Apagado Gracioso de Servidor\n\n```hemlock\nlet running = true;\n\nfn shutdown(sig) {\n    print(\"Shutdown signal received\");\n    running = false;\n}\n\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// Bucle principal del servidor\nwhile (running) {\n    handle_client_request();\n}\n\ncleanup_resources();\nprint(\"Server stopped\");\n```\n\n### 2. Recarga de Configuracion (Sin Reinicio)\n\n```hemlock\nlet config = load_config(\"app.conf\");\nlet reload_needed = false;\n\nfn trigger_reload(sig) {\n    reload_needed = true;\n}\n\nsignal(SIGHUP, trigger_reload);\n\nwhile (true) {\n    if (reload_needed) {\n        print(\"Reloading configuration...\");\n        config = load_config(\"app.conf\");\n        reload_needed = false;\n    }\n\n    // Usar config...\n}\n```\n\n### 3. Rotacion de Logs\n\n```hemlock\nlet log_file = open(\"app.log\", \"a\");\nlet rotate_needed = false;\n\nfn trigger_rotate(sig) {\n    rotate_needed = true;\n}\n\nsignal(SIGUSR1, trigger_rotate);\n\nwhile (true) {\n    if (rotate_needed) {\n        log_file.close();\n        // Renombrar log viejo, abrir nuevo\n        exec(\"mv app.log app.log.old\");\n        log_file = open(\"app.log\", \"a\");\n        rotate_needed = false;\n    }\n\n    // Logging normal...\n    log_file.write(\"Log entry\\n\");\n}\n```\n\n### 4. Reporte de Estado\n\n```hemlock\nlet requests_handled = 0;\n\nfn report_status(sig) {\n    print(\"Status: \" + typeof(requests_handled) + \" requests handled\");\n}\n\nsignal(SIGUSR1, report_status);\n\nwhile (true) {\n    handle_request();\n    requests_handled = requests_handled + 1;\n}\n\n// Desde shell: kill -USR1 <pid>\n```\n\n### 5. Alternar Modo Debug\n\n```hemlock\nlet debug_mode = false;\n\nfn toggle_debug(sig) {\n    debug_mode = !debug_mode;\n    if (debug_mode) {\n        print(\"Debug mode: ON\");\n    } else {\n        print(\"Debug mode: OFF\");\n    }\n}\n\nsignal(SIGUSR2, toggle_debug);\n\n// Desde shell: kill -USR2 <pid> para alternar\n```\n\n## Ejemplos Completos\n\n### Ejemplo 1: Manejador de Interrupcion con Limpieza\n\n```hemlock\nlet running = true;\nlet signal_count = 0;\n\nfn handle_signal(signum) {\n    signal_count = signal_count + 1;\n\n    if (signum == SIGINT) {\n        print(\"Interrupt detected (Ctrl+C)\");\n        running = false;\n    }\n\n    if (signum == SIGUSR1) {\n        print(\"User signal 1 received\");\n    }\n}\n\n// Registrar manejadores\nsignal(SIGINT, handle_signal);\nsignal(SIGUSR1, handle_signal);\n\n// Simular algo de trabajo\nlet i = 0;\nwhile (running && i < 100) {\n    print(\"Working... \" + typeof(i));\n\n    // Disparar SIGUSR1 cada 10 iteraciones\n    if (i == 10 || i == 20) {\n        raise(SIGUSR1);\n    }\n\n    i = i + 1;\n}\n\nprint(\"Total signals received: \" + typeof(signal_count));\n```\n\n### Ejemplo 2: Maquina de Estados Multi-Senal\n\n```hemlock\nlet state = \"idle\";\nlet request_count = 0;\n\nfn start_processing(sig) {\n    state = \"processing\";\n    print(\"State: \" + state);\n}\n\nfn stop_processing(sig) {\n    state = \"idle\";\n    print(\"State: \" + state);\n}\n\nfn report_stats(sig) {\n    print(\"State: \" + state);\n    print(\"Requests: \" + typeof(request_count));\n}\n\nsignal(SIGUSR1, start_processing);\nsignal(SIGUSR2, stop_processing);\nsignal(SIGHUP, report_stats);\n\nwhile (true) {\n    if (state == \"processing\") {\n        // Hacer trabajo\n        request_count = request_count + 1;\n    }\n\n    // Verificar cada iteracion...\n}\n```\n\n### Ejemplo 3: Controlador de Pool de Workers\n\n```hemlock\nlet worker_count = 4;\nlet should_exit = false;\n\nfn increase_workers(sig) {\n    worker_count = worker_count + 1;\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn decrease_workers(sig) {\n    if (worker_count > 1) {\n        worker_count = worker_count - 1;\n    }\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn shutdown(sig) {\n    print(\"Shutting down...\");\n    should_exit = true;\n}\n\nsignal(SIGUSR1, increase_workers);\nsignal(SIGUSR2, decrease_workers);\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// El bucle principal ajusta pool de workers basado en worker_count\nwhile (!should_exit) {\n    // Gestionar workers basado en worker_count\n    // ...\n}\n```\n\n### Ejemplo 4: Patron de Timeout\n\n```hemlock\nlet operation_complete = false;\nlet timed_out = false;\n\nfn timeout_handler(sig) {\n    timed_out = true;\n}\n\nsignal(SIGALRM, timeout_handler);\n\n// Iniciar operacion larga\nasync fn long_operation() {\n    // ... trabajo\n    operation_complete = true;\n}\n\nlet task = spawn(long_operation);\n\n// Esperar con timeout (verificacion manual)\nlet elapsed = 0;\nwhile (!operation_complete && elapsed < 1000) {\n    // Dormir o verificar\n    elapsed = elapsed + 1;\n}\n\nif (!operation_complete) {\n    print(\"Operation timed out\");\n    detach(task);  // Abandonar espera\n} else {\n    join(task);\n    print(\"Operation completed\");\n}\n```\n\n## Depurando Manejadores de Senal\n\n### Agregar Prints de Diagnostico\n\n```hemlock\nfn debug_handler(sig) {\n    print(\"Handler called for signal: \" + typeof(sig));\n    print(\"Stack: (not yet available)\");\n\n    // Tu logica de manejador...\n}\n\nsignal(SIGINT, debug_handler);\n```\n\n### Contar Llamadas de Senal\n\n```hemlock\nlet handler_calls = 0;\n\nfn counting_handler(sig) {\n    handler_calls = handler_calls + 1;\n    print(\"Handler call #\" + typeof(handler_calls));\n\n    // Tu logica de manejador...\n}\n```\n\n### Probar con raise()\n\n```hemlock\nfn test_handler(sig) {\n    print(\"Test signal received: \" + typeof(sig));\n}\n\nsignal(SIGUSR1, test_handler);\n\n// Probar enviando manualmente\nraise(SIGUSR1);\nprint(\"Handler should have been called\");\n```\n\n## Resumen\n\nEl manejo de senales de Hemlock proporciona:\n\n-  Manejo de senales POSIX para control de procesos de bajo nivel\n-  15 constantes de senal estandar\n-  API simple de signal() y raise()\n-  Funciones manejadoras flexibles con soporte de clausura\n-  Multiples senales pueden compartir manejadores\n\nRecuerda:\n- El manejo de senales es inherentemente inseguro - usar con precaucion\n- Mantener los manejadores simples y rapidos\n- Usar flags para cambios de estado, no operaciones complejas\n- Los manejadores pueden interrumpir la ejecucion en cualquier momento\n- No se pueden capturar SIGKILL o SIGSTOP\n- Probar manejadores exhaustivamente con raise()\n\nPatrones comunes:\n- Apagado gracioso (SIGINT, SIGTERM)\n- Recarga de configuracion (SIGHUP)\n- Rotacion de logs (SIGUSR1)\n- Reporte de estado (SIGUSR1/SIGUSR2)\n- Alternar modo debug (SIGUSR2)\n"}, "Referencia de API -> API de Archivos": {"id": "reference-file-api", "content": "# Referencia de la API de Archivos\n\nReferencia completa para el sistema de E/S de archivos de Hemlock.\n\n---\n\n## Descripcion General\n\nHemlock proporciona una **API de objetos File** para operaciones de archivos con manejo adecuado de errores y gestion de recursos. Los archivos deben abrirse y cerrarse manualmente.\n\n**Caracteristicas Principales:**\n- Objeto File con metodos\n- Lectura/escritura de datos de texto y binarios\n- Busqueda y posicionamiento\n- Mensajes de error apropiados\n- Gestion manual de recursos (sin RAII)\n\n---\n\n## Tipo File\n\n**Tipo:** `file`\n\n**Descripcion:** Manejador de archivo para operaciones de E/S\n\n**Propiedades (Solo Lectura):**\n- `.path` - Ruta del archivo (string)\n- `.mode` - Modo de apertura (string)\n- `.closed` - Si el archivo esta cerrado (bool)\n\n---\n\n## Abrir Archivos\n\n### open\n\nAbre un archivo para lectura, escritura, o ambos.\n\n**Firma:**\n```hemlock\nopen(path: string, mode?: string): file\n```\n\n**Parametros:**\n- `path` - Ruta del archivo (relativa o absoluta)\n- `mode` (opcional) - Modo de apertura (predeterminado: `\"r\"`)\n\n**Retorna:** Objeto File\n\n**Modos:**\n- `\"r\"` - Lectura (predeterminado)\n- `\"w\"` - Escritura (trunca archivo existente)\n- `\"a\"` - Anexar\n- `\"r+\"` - Lectura y escritura\n- `\"w+\"` - Lectura y escritura (trunca)\n- `\"a+\"` - Lectura y anexar\n\n**Ejemplos:**\n```hemlock\n// Modo lectura (predeterminado)\nlet f = open(\"data.txt\");\nlet f_read = open(\"data.txt\", \"r\");\n\n// Modo escritura (trunca)\nlet f_write = open(\"output.txt\", \"w\");\n\n// Modo anexar\nlet f_append = open(\"log.txt\", \"a\");\n\n// Modo lectura/escritura\nlet f_rw = open(\"data.bin\", \"r+\");\n\n// Lectura/escritura (trunca)\nlet f_rw_trunc = open(\"output.bin\", \"w+\");\n\n// Lectura/anexar\nlet f_ra = open(\"log.txt\", \"a+\");\n```\n\n**Manejo de Errores:**\n```hemlock\ntry {\n    let f = open(\"missing.txt\", \"r\");\n} catch (e) {\n    print(\"Error al abrir:\", e);\n    // Error: Failed to open 'missing.txt': No such file or directory\n}\n```\n\n**Importante:** Los archivos deben cerrarse manualmente con `f.close()` para evitar fugas de descriptores de archivo.\n\n---\n\n## Metodos de File\n\n### Lectura\n\n#### read\n\nLee texto desde el archivo.\n\n**Firma:**\n```hemlock\nfile.read(size?: i32): string\n```\n\n**Parametros:**\n- `size` (opcional) - Numero de bytes a leer (si se omite, lee hasta EOF)\n\n**Retorna:** String con el contenido del archivo\n\n**Ejemplos:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Leer archivo completo\nlet all = f.read();\nprint(all);\n\n// Leer numero especifico de bytes\nlet chunk = f.read(1024);\n\nf.close();\n```\n\n**Comportamiento:**\n- Lee desde la posicion actual del archivo\n- Retorna string vacio en EOF\n- Avanza la posicion del archivo\n\n**Errores:**\n- Leer desde archivo cerrado\n- Leer desde archivo de solo escritura\n\n---\n\n#### read_bytes\n\nLee datos binarios desde el archivo.\n\n**Firma:**\n```hemlock\nfile.read_bytes(size: i32): buffer\n```\n\n**Parametros:**\n- `size` - Numero de bytes a leer\n\n**Retorna:** Buffer con datos binarios\n\n**Ejemplos:**\n```hemlock\nlet f = open(\"data.bin\", \"r\");\n\n// Leer 256 bytes\nlet binary = f.read_bytes(256);\nprint(binary.length);       // 256\n\n// Procesar datos binarios\nlet i = 0;\nwhile (i < binary.length) {\n    print(binary[i]);\n    i = i + 1;\n}\n\nf.close();\n```\n\n**Comportamiento:**\n- Lee el numero exacto de bytes\n- Retorna buffer (no string)\n- Avanza la posicion del archivo\n\n---\n\n### Escritura\n\n#### write\n\nEscribe texto al archivo.\n\n**Firma:**\n```hemlock\nfile.write(data: string): i32\n```\n\n**Parametros:**\n- `data` - String a escribir\n\n**Retorna:** Numero de bytes escritos (i32)\n\n**Ejemplos:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\n\n// Escribir texto\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Escribio\", written, \"bytes\");\n\n// Multiples escrituras\nf.write(\"Linea 1\\n\");\nf.write(\"Linea 2\\n\");\nf.write(\"Linea 3\\n\");\n\nf.close();\n```\n\n**Comportamiento:**\n- Escribe en la posicion actual del archivo\n- Retorna el numero de bytes escritos\n- Avanza la posicion del archivo\n\n**Errores:**\n- Escribir en archivo cerrado\n- Escribir en archivo de solo lectura\n\n---\n\n#### write_bytes\n\nEscribe datos binarios al archivo.\n\n**Firma:**\n```hemlock\nfile.write_bytes(data: buffer): i32\n```\n\n**Parametros:**\n- `data` - Buffer a escribir\n\n**Retorna:** Numero de bytes escritos (i32)\n\n**Ejemplos:**\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Crear buffer\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Escribir buffer\nlet written = f.write_bytes(buf);\nprint(\"Escribio\", written, \"bytes\");\n\nf.close();\n```\n\n**Comportamiento:**\n- Escribe el contenido del buffer al archivo\n- Retorna el numero de bytes escritos\n- Avanza la posicion del archivo\n\n---\n\n### Posicionamiento\n\n#### seek\n\nMueve la posicion del archivo a un desplazamiento especifico de bytes.\n\n**Firma:**\n```hemlock\nfile.seek(position: i32): i32\n```\n\n**Parametros:**\n- `position` - Desplazamiento en bytes desde el inicio del archivo\n\n**Retorna:** Nueva posicion del archivo (i32)\n\n**Ejemplos:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Saltar al byte 100\nf.seek(100);\n\n// Leer desde esa posicion\nlet chunk = f.read(50);\n\n// Reiniciar al inicio\nf.seek(0);\n\n// Leer desde el inicio\nlet all = f.read();\n\nf.close();\n```\n\n**Comportamiento:**\n- Establece la posicion del archivo al desplazamiento absoluto\n- Retorna la nueva posicion\n- Posicionarse mas alla de EOF esta permitido (crea hueco en el archivo al escribir)\n\n---\n\n#### tell\n\nObtiene la posicion actual del archivo.\n\n**Firma:**\n```hemlock\nfile.tell(): i32\n```\n\n**Retorna:** Desplazamiento actual en bytes desde el inicio del archivo (i32)\n\n**Ejemplos:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nprint(f.tell());        // 0 (al inicio)\n\nf.read(100);\nprint(f.tell());        // 100 (despues de leer)\n\nf.seek(50);\nprint(f.tell());        // 50 (despues de posicionarse)\n\nf.close();\n```\n\n---\n\n### Cierre\n\n#### close\n\nCierra el archivo (idempotente).\n\n**Firma:**\n```hemlock\nfile.close(): null\n```\n\n**Retorna:** `null`\n\n**Ejemplos:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\n// Seguro llamar multiples veces\nf.close();  // Sin error\nf.close();  // Sin error\n```\n\n**Comportamiento:**\n- Cierra el manejador del archivo\n- Vacia cualquier escritura pendiente\n- Idempotente (seguro llamar multiples veces)\n- Establece la propiedad `.closed` a `true`\n\n**Importante:** Siempre cierre los archivos cuando termine para evitar fugas de descriptores de archivo.\n\n---\n\n## Propiedades de File\n\n### .path\n\nObtiene la ruta del archivo.\n\n**Tipo:** `string`\n\n**Acceso:** Solo lectura\n\n**Ejemplos:**\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);          // \"/path/to/file.txt\"\nf.close();\n```\n\n---\n\n### .mode\n\nObtiene el modo de apertura.\n\n**Tipo:** `string`\n\n**Acceso:** Solo lectura\n\n**Ejemplos:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);          // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);         // \"w\"\nf2.close();\n```\n\n---\n\n### .closed\n\nVerifica si el archivo esta cerrado.\n\n**Tipo:** `bool`\n\n**Acceso:** Solo lectura\n\n**Ejemplos:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);        // false\n\nf.close();\nprint(f.closed);        // true\n```\n\n---\n\n## Manejo de Errores\n\nTodas las operaciones de archivo incluyen mensajes de error apropiados con contexto:\n\n### Archivo No Encontrado\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Error: Failed to open 'missing.txt': No such file or directory\n```\n\n### Leer Desde Archivo Cerrado\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Error: Cannot read from closed file 'data.txt'\n```\n\n### Escribir en Archivo de Solo Lectura\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Error: Cannot write to file 'readonly.txt' opened in read-only mode\n```\n\n### Usando try/catch\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    print(content);\n} catch (e) {\n    print(\"Error de archivo:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## Patrones de Gestion de Recursos\n\n### Patron Basico\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### Con Manejo de Errores\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Siempre cerrar, incluso en error\n}\n```\n\n### Patron Seguro\n\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    // ... procesar contenido ...\n} catch (e) {\n    print(\"Error:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## Ejemplos de Uso\n\n### Leer Archivo Completo\n\n```hemlock\nfn read_file(filename: string): string {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content;\n}\n\nlet text = read_file(\"data.txt\");\nprint(text);\n```\n\n### Escribir Archivo de Texto\n\n```hemlock\nfn write_file(filename: string, content: string) {\n    let f = open(filename, \"w\");\n    f.write(content);\n    f.close();\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\\n\");\n```\n\n### Anexar a Archivo\n\n```hemlock\nfn append_file(filename: string, line: string) {\n    let f = open(filename, \"a\");\n    f.write(line + \"\\n\");\n    f.close();\n}\n\nappend_file(\"log.txt\", \"Entrada de log 1\");\nappend_file(\"log.txt\", \"Entrada de log 2\");\n```\n\n### Leer Archivo Binario\n\n```hemlock\nfn read_binary(filename: string, size: i32): buffer {\n    let f = open(filename, \"r\");\n    let data = f.read_bytes(size);\n    f.close();\n    return data;\n}\n\nlet binary = read_binary(\"data.bin\", 256);\nprint(\"Leyo\", binary.length, \"bytes\");\n```\n\n### Escribir Archivo Binario\n\n```hemlock\nfn write_binary(filename: string, data: buffer) {\n    let f = open(filename, \"w\");\n    f.write_bytes(data);\n    f.close();\n}\n\nlet buf = buffer(10);\nbuf[0] = 65;\nwrite_binary(\"output.bin\", buf);\n```\n\n### Leer Archivo Linea por Linea\n\n```hemlock\nfn read_lines(filename: string): array {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content.split(\"\\n\");\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Linea\", i, \":\", lines[i]);\n    i = i + 1;\n}\n```\n\n### Copiar Archivo\n\n```hemlock\nfn copy_file(src: string, dest: string) {\n    let f_in = open(src, \"r\");\n    let f_out = open(dest, \"w\");\n\n    let content = f_in.read();\n    f_out.write(content);\n\n    f_in.close();\n    f_out.close();\n}\n\ncopy_file(\"input.txt\", \"output.txt\");\n```\n\n### Leer Archivo en Fragmentos\n\n```hemlock\nfn process_chunks(filename: string) {\n    let f = open(filename, \"r\");\n\n    while (true) {\n        let chunk = f.read(1024);  // Leer 1KB a la vez\n        if (chunk.length == 0) {\n            break;  // EOF\n        }\n\n        // Procesar fragmento\n        print(\"Procesando\", chunk.length, \"bytes\");\n    }\n\n    f.close();\n}\n\nprocess_chunks(\"large_file.txt\");\n```\n\n---\n\n## Resumen Completo de Metodos\n\n| Metodo        | Firma                    | Retorna   | Descripcion                  |\n|---------------|--------------------------|-----------|------------------------------|\n| `read`        | `(size?: i32)`           | `string`  | Leer texto                   |\n| `read_bytes`  | `(size: i32)`            | `buffer`  | Leer datos binarios          |\n| `write`       | `(data: string)`         | `i32`     | Escribir texto               |\n| `write_bytes` | `(data: buffer)`         | `i32`     | Escribir datos binarios      |\n| `seek`        | `(position: i32)`        | `i32`     | Establecer posicion del archivo |\n| `tell`        | `()`                     | `i32`     | Obtener posicion del archivo |\n| `close`       | `()`                     | `null`    | Cerrar archivo (idempotente) |\n\n---\n\n## Resumen Completo de Propiedades\n\n| Propiedad | Tipo     | Acceso       | Descripcion              |\n|-----------|----------|--------------|--------------------------|\n| `.path`   | `string` | Solo lectura | Ruta del archivo         |\n| `.mode`   | `string` | Solo lectura | Modo de apertura         |\n| `.closed` | `bool`   | Solo lectura | Si el archivo esta cerrado |\n\n---\n\n## Migracion desde la API Antigua\n\n**API Antigua (Eliminada):**\n- `read_file(path)` - Use `open(path, \"r\").read()`\n- `write_file(path, data)` - Use `open(path, \"w\").write(data)`\n- `append_file(path, data)` - Use `open(path, \"a\").write(data)`\n- `file_exists(path)` - Sin reemplazo aun\n\n**Ejemplo de Migracion:**\n```hemlock\n// Antiguo (v0.0)\nlet content = read_file(\"data.txt\");\nwrite_file(\"output.txt\", content);\n\n// Nuevo (v0.1)\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nf2.write(content);\nf2.close();\n```\n\n---\n\n## Ver Tambien\n\n- [Funciones Integradas](#reference-builtins) - Funcion `open()`\n- [API de Memoria](#reference-memory-api) - Tipo Buffer\n- [API de Strings](#reference-string-api) - Metodos de string para procesamiento de texto\n"}, "Referencia de API -> API de Arreglos": {"id": "reference-array-api", "content": "# Referencia de la API de Arrays\n\nReferencia completa para el tipo array de Hemlock y sus 18 metodos.\n\n---\n\n## Descripcion General\n\nLos arrays en Hemlock son secuencias **dinamicas, asignadas en el heap** que pueden contener tipos mixtos. Proporcionan metodos completos para la manipulacion y procesamiento de datos.\n\n**Caracteristicas Principales:**\n- Tamano dinamico (crecimiento automatico)\n- Indexacion desde cero\n- Tipos mixtos permitidos\n- 18 metodos integrados\n- Asignados en el heap con seguimiento de capacidad\n\n---\n\n## Tipo Array\n\n**Tipo:** `array`\n\n**Propiedades:**\n- `.length` - Numero de elementos (i32)\n\n**Sintaxis Literal:** Corchetes `[elem1, elem2, ...]`\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);     // 5\n\n// Tipos mixtos\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.length);   // 4\n\n// Array vacio\nlet empty = [];\nprint(empty.length);   // 0\n```\n\n---\n\n## Indexacion\n\nLos arrays soportan indexacion basada en cero usando `[]`:\n\n**Acceso de Lectura:**\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);         // 10\nprint(arr[1]);         // 20\nprint(arr[2]);         // 30\n```\n\n**Acceso de Escritura:**\n```hemlock\nlet arr = [10, 20, 30];\narr[0] = 99;\narr[1] = 88;\nprint(arr);            // [99, 88, 30]\n```\n\n**Nota:** La indexacion directa no tiene verificacion de limites. Use metodos para mayor seguridad.\n\n---\n\n## Propiedades de Array\n\n### .length\n\nObtiene el numero de elementos en el array.\n\n**Tipo:** `i32`\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr.length);     // 3\n\nlet empty = [];\nprint(empty.length);   // 0\n\n// La longitud cambia dinamicamente\narr.push(4);\nprint(arr.length);     // 4\n\narr.pop();\nprint(arr.length);     // 3\n```\n\n---\n\n## Metodos de Array\n\n### Operaciones de Pila\n\n#### push\n\nAgrega un elemento al final del array.\n\n**Firma:**\n```hemlock\narray.push(value: any): null\n```\n\n**Parametros:**\n- `value` - Elemento a agregar\n\n**Retorna:** `null`\n\n**Muta:** Si (modifica el array en su lugar)\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\narr.push(\"hello\");     // [1, 2, 3, 4, 5, \"hello\"]\n```\n\n---\n\n#### pop\n\nElimina y retorna el ultimo elemento.\n\n**Firma:**\n```hemlock\narray.pop(): any\n```\n\n**Retorna:** Ultimo elemento (eliminado del array)\n\n**Muta:** Si (modifica el array en su lugar)\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3];\nlet last = arr.pop();  // 3\nprint(arr);            // [1, 2]\n\nlet last2 = arr.pop(); // 2\nprint(arr);            // [1]\n```\n\n**Error:** Error en tiempo de ejecucion si el array esta vacio.\n\n---\n\n### Operaciones de Cola\n\n#### shift\n\nElimina y retorna el primer elemento.\n\n**Firma:**\n```hemlock\narray.shift(): any\n```\n\n**Retorna:** Primer elemento (eliminado del array)\n\n**Muta:** Si (modifica el array en su lugar)\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();  // 1\nprint(arr);               // [2, 3]\n\nlet first2 = arr.shift(); // 2\nprint(arr);               // [3]\n```\n\n**Error:** Error en tiempo de ejecucion si el array esta vacio.\n\n---\n\n#### unshift\n\nAgrega un elemento al inicio del array.\n\n**Firma:**\n```hemlock\narray.unshift(value: any): null\n```\n\n**Parametros:**\n- `value` - Elemento a agregar\n\n**Retorna:** `null`\n\n**Muta:** Si (modifica el array en su lugar)\n\n**Ejemplos:**\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);        // [1, 2, 3]\narr.unshift(0);        // [0, 1, 2, 3]\n```\n\n---\n\n### Insercion y Eliminacion\n\n#### insert\n\nInserta un elemento en un indice especifico.\n\n**Firma:**\n```hemlock\narray.insert(index: i32, value: any): null\n```\n\n**Parametros:**\n- `index` - Posicion donde insertar (basada en 0)\n- `value` - Elemento a insertar\n\n**Retorna:** `null`\n\n**Muta:** Si (modifica el array en su lugar)\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // [1, 2, 3, 4, 5]\n\nlet arr2 = [1, 3];\narr2.insert(1, 2);     // [1, 2, 3]\n\n// Insertar al final\narr2.insert(arr2.length, 4);  // [1, 2, 3, 4]\n```\n\n**Comportamiento:** Desplaza los elementos en y despues del indice hacia la derecha.\n\n---\n\n#### remove\n\nElimina y retorna el elemento en el indice.\n\n**Firma:**\n```hemlock\narray.remove(index: i32): any\n```\n\n**Parametros:**\n- `index` - Posicion de donde eliminar (basada en 0)\n\n**Retorna:** Elemento eliminado\n\n**Muta:** Si (modifica el array en su lugar)\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(0);  // 1\nprint(arr);                   // [2, 3, 4, 5]\n\nlet removed2 = arr.remove(2); // 4\nprint(arr);                   // [2, 3, 5]\n```\n\n**Comportamiento:** Desplaza los elementos despues del indice hacia la izquierda.\n\n**Error:** Error en tiempo de ejecucion si el indice esta fuera de limites.\n\n---\n\n### Busqueda y Encontrar\n\n#### find\n\nEncuentra la primera ocurrencia de un valor.\n\n**Firma:**\n```hemlock\narray.find(value: any): i32\n```\n\n**Parametros:**\n- `value` - Valor a buscar\n\n**Retorna:** Indice de la primera ocurrencia, o `-1` si no se encuentra\n\n**Ejemplos:**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2\nlet idx2 = arr.find(99);     // -1 (no encontrado)\n\n// Encontrar el primer duplicado\nlet arr2 = [1, 2, 3, 2, 4];\nlet idx3 = arr2.find(2);     // 1 (primera ocurrencia)\n```\n\n**Comparacion:** Usa igualdad de valor para primitivos y strings.\n\n---\n\n#### contains\n\nVerifica si el array contiene un valor.\n\n**Firma:**\n```hemlock\narray.contains(value: any): bool\n```\n\n**Parametros:**\n- `value` - Valor a buscar\n\n**Retorna:** `true` si se encuentra, `false` en caso contrario\n\n**Ejemplos:**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n\n// Funciona con strings\nlet words = [\"hello\", \"world\"];\nlet has3 = words.contains(\"hello\");  // true\n```\n\n---\n\n### Segmentacion y Extraccion\n\n#### slice\n\nExtrae un subarray por rango (fin exclusivo).\n\n**Firma:**\n```hemlock\narray.slice(start: i32, end: i32): array\n```\n\n**Parametros:**\n- `start` - Indice inicial (basado en 0, inclusivo)\n- `end` - Indice final (exclusivo)\n\n**Retorna:** Nuevo array con elementos desde [start, end)\n\n**Muta:** No (retorna nuevo array)\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4]\nlet first_three = arr.slice(0, 3);  // [1, 2, 3]\nlet last_two = arr.slice(3, 5);     // [4, 5]\n\n// Segmento vacio\nlet empty = arr.slice(2, 2); // []\n```\n\n---\n\n#### first\n\nObtiene el primer elemento sin eliminarlo.\n\n**Firma:**\n```hemlock\narray.first(): any\n```\n\n**Retorna:** Primer elemento\n\n**Muta:** No\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1\nprint(arr);                  // [1, 2, 3] (sin cambios)\n```\n\n**Error:** Error en tiempo de ejecucion si el array esta vacio.\n\n---\n\n#### last\n\nObtiene el ultimo elemento sin eliminarlo.\n\n**Firma:**\n```hemlock\narray.last(): any\n```\n\n**Retorna:** Ultimo elemento\n\n**Muta:** No\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3\nprint(arr);                  // [1, 2, 3] (sin cambios)\n```\n\n**Error:** Error en tiempo de ejecucion si el array esta vacio.\n\n---\n\n### Manipulacion de Arrays\n\n#### reverse\n\nInvierte el array en su lugar.\n\n**Firma:**\n```hemlock\narray.reverse(): null\n```\n\n**Retorna:** `null`\n\n**Muta:** Si (modifica el array en su lugar)\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\nprint(arr);                  // [5, 4, 3, 2, 1]\n\nlet words = [\"hello\", \"world\"];\nwords.reverse();             // [\"world\", \"hello\"]\n```\n\n---\n\n#### clear\n\nElimina todos los elementos del array.\n\n**Firma:**\n```hemlock\narray.clear(): null\n```\n\n**Retorna:** `null`\n\n**Muta:** Si (modifica el array en su lugar)\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();\nprint(arr);                  // []\nprint(arr.length);           // 0\n```\n\n---\n\n### Combinacion de Arrays\n\n#### concat\n\nConcatena con otro array.\n\n**Firma:**\n```hemlock\narray.concat(other: array): array\n```\n\n**Parametros:**\n- `other` - Array a concatenar\n\n**Retorna:** Nuevo array con elementos de ambos arrays\n\n**Muta:** No (retorna nuevo array)\n\n**Ejemplos:**\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]\nprint(a);                    // [1, 2, 3] (sin cambios)\nprint(b);                    // [4, 5, 6] (sin cambios)\n\n// Encadenar concatenaciones\nlet c = [7, 8];\nlet all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n---\n\n### Operaciones Funcionales\n\n#### map\n\nTransforma cada elemento usando una funcion de callback.\n\n**Firma:**\n```hemlock\narray.map(callback: fn): array\n```\n\n**Parametros:**\n- `callback` - Funcion que toma un elemento y retorna el valor transformado\n\n**Retorna:** Nuevo array con elementos transformados\n\n**Muta:** No (retorna nuevo array)\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet doubled = arr.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\nlet names = [\"alice\", \"bob\"];\nlet upper = names.map(fn(s) { return s.to_upper(); });\nprint(upper);  // [\"ALICE\", \"BOB\"]\n```\n\n---\n\n#### filter\n\nSelecciona elementos que coinciden con un predicado.\n\n**Firma:**\n```hemlock\narray.filter(predicate: fn): array\n```\n\n**Parametros:**\n- `predicate` - Funcion que toma un elemento y retorna bool\n\n**Retorna:** Nuevo array con elementos donde el predicado retorno true\n\n**Muta:** No (retorna nuevo array)\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6];\nlet evens = arr.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4, 6]\n\nlet words = [\"hello\", \"hi\", \"hey\", \"goodbye\"];\nlet short = words.filter(fn(s) { return s.length < 4; });\nprint(short);  // [\"hi\", \"hey\"]\n```\n\n---\n\n#### reduce\n\nReduce el array a un solo valor usando un acumulador.\n\n**Firma:**\n```hemlock\narray.reduce(callback: fn, initial: any): any\n```\n\n**Parametros:**\n- `callback` - Funcion que toma (acumulador, elemento) y retorna nuevo acumulador\n- `initial` - Valor inicial para el acumulador\n\n**Retorna:** Valor acumulado final\n\n**Muta:** No\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sum = arr.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\nlet product = arr.reduce(fn(acc, x) { return acc * x; }, 1);\nprint(product);  // 120\n\n// Encontrar el valor maximo\nlet max = arr.reduce(fn(acc, x) {\n    if (x > acc) { return x; }\n    return acc;\n}, arr[0]);\nprint(max);  // 5\n```\n\n---\n\n### Conversion a String\n\n#### join\n\nUne elementos en un string con un delimitador.\n\n**Firma:**\n```hemlock\narray.join(delimiter: string): string\n```\n\n**Parametros:**\n- `delimiter` - String a colocar entre elementos\n\n**Retorna:** String con todos los elementos unidos\n\n**Ejemplos:**\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Funciona con tipos mixtos\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n\n// Delimitador vacio\nlet arr = [\"a\", \"b\", \"c\"];\nlet s = arr.join(\"\");          // \"abc\"\n```\n\n**Comportamiento:** Convierte automaticamente todos los elementos a strings.\n\n---\n\n## Encadenamiento de Metodos\n\nLos metodos de array pueden encadenarse para operaciones concisas:\n\n**Ejemplos:**\n```hemlock\n// Encadenar slice y join\nlet result = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\n// Encadenar concat y slice\nlet combined = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);    // [3, 4, 5]\n\n// Encadenamiento complejo\nlet words = [\"hello\", \"world\", \"foo\", \"bar\"];\nlet result2 = words\n    .slice(0, 3)\n    .concat([\"baz\"])\n    .join(\"-\");      // \"hello-world-foo-baz\"\n```\n\n---\n\n## Resumen Completo de Metodos\n\n### Metodos que Mutan\n\nMetodos que modifican el array en su lugar:\n\n| Metodo     | Firma                      | Retorna   | Descripcion                    |\n|------------|----------------------------|-----------|--------------------------------|\n| `push`     | `(value: any)`             | `null`    | Agregar al final               |\n| `pop`      | `()`                       | `any`     | Eliminar del final             |\n| `shift`    | `()`                       | `any`     | Eliminar del inicio            |\n| `unshift`  | `(value: any)`             | `null`    | Agregar al inicio              |\n| `insert`   | `(index: i32, value: any)` | `null`    | Insertar en indice             |\n| `remove`   | `(index: i32)`             | `any`     | Eliminar en indice             |\n| `reverse`  | `()`                       | `null`    | Invertir en su lugar           |\n| `clear`    | `()`                       | `null`    | Eliminar todos los elementos   |\n\n### Metodos que No Mutan\n\nMetodos que retornan nuevos valores sin modificar el original:\n\n| Metodo     | Firma                      | Retorna   | Descripcion                    |\n|------------|----------------------------|-----------|--------------------------------|\n| `find`     | `(value: any)`             | `i32`     | Encontrar primera ocurrencia   |\n| `contains` | `(value: any)`             | `bool`    | Verificar si contiene valor    |\n| `slice`    | `(start: i32, end: i32)`   | `array`   | Extraer subarray               |\n| `first`    | `()`                       | `any`     | Obtener primer elemento        |\n| `last`     | `()`                       | `any`     | Obtener ultimo elemento        |\n| `concat`   | `(other: array)`           | `array`   | Concatenar arrays              |\n| `join`     | `(delimiter: string)`      | `string`  | Unir elementos en string       |\n| `map`      | `(callback: fn)`           | `array`   | Transformar cada elemento      |\n| `filter`   | `(predicate: fn)`          | `array`   | Seleccionar elementos que coincidan |\n| `reduce`   | `(callback: fn, initial: any)` | `any` | Reducir a un solo valor        |\n\n---\n\n## Patrones de Uso\n\n### Uso como Pila\n\n```hemlock\nlet stack = [];\n\n// Push de elementos\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Pop de elementos\nwhile (stack.length > 0) {\n    let item = stack.pop();\n    print(item);  // 3, 2, 1\n}\n```\n\n### Uso como Cola\n\n```hemlock\nlet queue = [];\n\n// Encolar\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Desencolar\nwhile (queue.length > 0) {\n    let item = queue.shift();\n    print(item);  // 1, 2, 3\n}\n```\n\n### Transformacion de Arrays\n\n```hemlock\n// Filtrar (manual)\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = [];\nlet i = 0;\nwhile (i < numbers.length) {\n    if (numbers[i] % 2 == 0) {\n        evens.push(numbers[i]);\n    }\n    i = i + 1;\n}\n\n// Mapear (manual)\nlet numbers2 = [1, 2, 3, 4, 5];\nlet doubled = [];\nlet j = 0;\nwhile (j < numbers2.length) {\n    doubled.push(numbers2[j] * 2);\n    j = j + 1;\n}\n```\n\n### Construir Arrays\n\n```hemlock\nlet arr = [];\n\n// Construir array con bucle\nlet i = 0;\nwhile (i < 10) {\n    arr.push(i * 10);\n    i = i + 1;\n}\n\nprint(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n```\n\n---\n\n## Detalles de Implementacion\n\n**Gestion de Capacidad:**\n- Los arrays crecen automaticamente cuando es necesario\n- La capacidad se duplica cuando se excede\n- Sin control manual de capacidad\n\n**Comparacion de Valores:**\n- `find()` y `contains()` usan igualdad de valor\n- Funciona correctamente para primitivos y strings\n- Objetos/arrays se comparan por referencia\n\n**Memoria:**\n- Asignados en el heap\n- Sin liberacion automatica (gestion manual de memoria)\n- Sin verificacion de limites en acceso directo por indice\n\n---\n\n## Ver Tambien\n\n- [Sistema de Tipos](#reference-type-system) - Detalles del tipo array\n- [API de Strings](#reference-string-api) - Resultados de join() en strings\n- [Operadores](#reference-operators) - Operador de indexacion de arrays\n"}, "Referencia de API -> API de Cadenas": {"id": "reference-string-api", "content": "# Referencia de la API de Strings\n\nReferencia completa para el tipo string de Hemlock y sus 19 metodos.\n\n---\n\n## Descripcion General\n\nLos strings en Hemlock son secuencias **codificadas en UTF-8, mutables, asignadas en el heap** con soporte completo de Unicode. Todas las operaciones trabajan con **puntos de codigo** (caracteres), no bytes.\n\n**Caracteristicas Principales:**\n- Codificacion UTF-8 (U+0000 a U+10FFFF)\n- Mutable (puede modificar caracteres en su lugar)\n- Indexacion basada en puntos de codigo\n- 19 metodos integrados\n- Concatenacion automatica con el operador `+`\n\n---\n\n## Tipo String\n\n**Tipo:** `string`\n\n**Propiedades:**\n- `.length` - Numero de puntos de codigo (caracteres)\n- `.byte_length` - Numero de bytes UTF-8\n\n**Sintaxis Literal:** Comillas dobles `\"texto\"`\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5 (puntos de codigo)\nprint(s.byte_length);   // 5 (bytes)\n\nlet emoji = \"\";\nprint(emoji.length);        // 1 (un punto de codigo)\nprint(emoji.byte_length);   // 4 (cuatro bytes UTF-8)\n```\n\n---\n\n## Indexacion\n\nLos strings soportan indexacion basada en puntos de codigo usando `[]`:\n\n**Acceso de Lectura:**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Retorna rune 'h'\n```\n\n**Acceso de Escritura:**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Mutar con rune (ahora \"Hello\")\n```\n\n**Ejemplo UTF-8:**\n```hemlock\nlet text = \"Hi!\";\nprint(text[0]);         // 'H'\nprint(text[1]);         // 'i'\nprint(text[2]);         // '' (un punto de codigo)\nprint(text[3]);         // '!'\n```\n\n---\n\n## Concatenacion\n\nUse el operador `+` para concatenar strings y runes:\n\n**String + String:**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n```\n\n**String + Rune:**\n```hemlock\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\nlet decorated = \"Text\" + '';      // \"Text\"\n```\n\n**Rune + String:**\n```hemlock\nlet prefix = '>' + \" Message\";     // \"> Message\"\nlet bullet = '' + \" Item\";        // \" Item\"\n```\n\n**Concatenaciones Multiples:**\n```hemlock\nlet msg = \"Hi \" + '' + \" World \" + '';  // \"Hi  World \"\n```\n\n---\n\n## Propiedades de String\n\n### .length\n\nObtiene el numero de puntos de codigo Unicode (caracteres).\n\n**Tipo:** `i32`\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5\n\nlet emoji = \"\";\nprint(emoji.length);    // 1 (un punto de codigo)\n\nlet text = \"Hello !\";\nprint(text.length);     // 8 (7 ASCII + 1 emoji)\n```\n\n---\n\n### .byte_length\n\nObtiene el numero de bytes UTF-8.\n\n**Tipo:** `i32`\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello\";\nprint(s.byte_length);   // 5 (1 byte por caracter ASCII)\n\nlet emoji = \"\";\nprint(emoji.byte_length); // 4 (emoji es 4 bytes UTF-8)\n\nlet text = \"Hello !\";\nprint(text.byte_length);  // 11 (7 ASCII + 4 para emoji)\n```\n\n---\n\n## Metodos de String\n\n### Subcadenas y Segmentacion\n\n#### substr\n\nExtrae subcadena por posicion y longitud.\n\n**Firma:**\n```hemlock\nstring.substr(start: i32, length: i32): string\n```\n\n**Parametros:**\n- `start` - Indice inicial del punto de codigo (basado en 0)\n- `length` - Numero de puntos de codigo a extraer\n\n**Retorna:** Nuevo string\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\"\nlet first = s.substr(0, 5);     // \"hello\"\n\n// Ejemplo UTF-8\nlet text = \"Hi!\";\nlet emoji = text.substr(2, 1);  // \"\"\n```\n\n---\n\n#### slice\n\nExtrae subcadena por rango (fin exclusivo).\n\n**Firma:**\n```hemlock\nstring.slice(start: i32, end: i32): string\n```\n\n**Parametros:**\n- `start` - Indice inicial del punto de codigo (basado en 0)\n- `end` - Indice final del punto de codigo (exclusivo)\n\n**Retorna:** Nuevo string\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.slice(0, 5);        // \"hello\"\nlet world = s.slice(6, 11);     // \"world\"\n\n// Ejemplo UTF-8\nlet text = \"Hi!\";\nlet first_three = text.slice(0, 3);  // \"Hi\"\n```\n\n---\n\n### Busqueda y Encontrar\n\n#### find\n\nEncuentra la primera ocurrencia de una subcadena.\n\n**Firma:**\n```hemlock\nstring.find(needle: string): i32\n```\n\n**Parametros:**\n- `needle` - Subcadena a buscar\n\n**Retorna:** Indice del punto de codigo de la primera ocurrencia, o `-1` si no se encuentra\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6\nlet pos2 = s.find(\"foo\");       // -1 (no encontrado)\nlet pos3 = s.find(\"l\");         // 2 (primera 'l')\n```\n\n---\n\n#### contains\n\nVerifica si el string contiene una subcadena.\n\n**Firma:**\n```hemlock\nstring.contains(needle: string): bool\n```\n\n**Parametros:**\n- `needle` - Subcadena a buscar\n\n**Retorna:** `true` si se encuentra, `false` en caso contrario\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n---\n\n### Dividir y Unir\n\n#### split\n\nDivide el string en un array por delimitador.\n\n**Firma:**\n```hemlock\nstring.split(delimiter: string): array\n```\n\n**Parametros:**\n- `delimiter` - String por el cual dividir\n\n**Retorna:** Array de strings\n\n**Ejemplos:**\n```hemlock\nlet csv = \"a,b,c\";\nlet parts = csv.split(\",\");     // [\"a\", \"b\", \"c\"]\n\nlet path = \"/usr/local/bin\";\nlet dirs = path.split(\"/\");     // [\"\", \"usr\", \"local\", \"bin\"]\n\nlet text = \"hello world foo\";\nlet words = text.split(\" \");    // [\"hello\", \"world\", \"foo\"]\n```\n\n---\n\n#### trim\n\nElimina espacios en blanco al inicio y al final.\n\n**Firma:**\n```hemlock\nstring.trim(): string\n```\n\n**Retorna:** Nuevo string con espacios en blanco eliminados\n\n**Ejemplos:**\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet text = \"\\n\\t  world  \\n\";\nlet clean2 = text.trim();       // \"world\"\n```\n\n---\n\n### Conversion de Mayusculas/Minusculas\n\n#### to_upper\n\nConvierte el string a mayusculas.\n\n**Firma:**\n```hemlock\nstring.to_upper(): string\n```\n\n**Retorna:** Nuevo string en mayusculas\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\nlet mixed = \"HeLLo\";\nlet upper2 = mixed.to_upper();  // \"HELLO\"\n```\n\n---\n\n#### to_lower\n\nConvierte el string a minusculas.\n\n**Firma:**\n```hemlock\nstring.to_lower(): string\n```\n\n**Retorna:** Nuevo string en minusculas\n\n**Ejemplos:**\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n\nlet mixed = \"HeLLo\";\nlet lower2 = mixed.to_lower();  // \"hello\"\n```\n\n---\n\n### Prefijo y Sufijo\n\n#### starts_with\n\nVerifica si el string comienza con un prefijo.\n\n**Firma:**\n```hemlock\nstring.starts_with(prefix: string): bool\n```\n\n**Parametros:**\n- `prefix` - Prefijo a verificar\n\n**Retorna:** `true` si el string comienza con el prefijo, `false` en caso contrario\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n---\n\n#### ends_with\n\nVerifica si el string termina con un sufijo.\n\n**Firma:**\n```hemlock\nstring.ends_with(suffix: string): bool\n```\n\n**Parametros:**\n- `suffix` - Sufijo a verificar\n\n**Retorna:** `true` si el string termina con el sufijo, `false` en caso contrario\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n---\n\n### Reemplazo\n\n#### replace\n\nReemplaza la primera ocurrencia de una subcadena.\n\n**Firma:**\n```hemlock\nstring.replace(old: string, new: string): string\n```\n\n**Parametros:**\n- `old` - Subcadena a reemplazar\n- `new` - String de reemplazo\n\n**Retorna:** Nuevo string con la primera ocurrencia reemplazada\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");  // \"hello there\"\n\nlet text = \"foo foo foo\";\nlet text2 = text.replace(\"foo\", \"bar\"); // \"bar foo foo\" (solo la primera)\n```\n\n---\n\n#### replace_all\n\nReemplaza todas las ocurrencias de una subcadena.\n\n**Firma:**\n```hemlock\nstring.replace_all(old: string, new: string): string\n```\n\n**Parametros:**\n- `old` - Subcadena a reemplazar\n- `new` - String de reemplazo\n\n**Retorna:** Nuevo string con todas las ocurrencias reemplazadas\n\n**Ejemplos:**\n```hemlock\nlet text = \"foo foo foo\";\nlet text2 = text.replace_all(\"foo\", \"bar\"); // \"bar bar bar\"\n\nlet s = \"hello world hello\";\nlet s2 = s.replace_all(\"hello\", \"hi\");      // \"hi world hi\"\n```\n\n---\n\n### Repeticion\n\n#### repeat\n\nRepite el string n veces.\n\n**Firma:**\n```hemlock\nstring.repeat(count: i32): string\n```\n\n**Parametros:**\n- `count` - Numero de repeticiones\n\n**Retorna:** Nuevo string repetido count veces\n\n**Ejemplos:**\n```hemlock\nlet s = \"ha\";\nlet repeated = s.repeat(3);     // \"hahaha\"\n\nlet line = \"-\";\nlet separator = line.repeat(40); // \"----------------------------------------\"\n```\n\n---\n\n### Acceso a Caracteres\n\n#### char_at\n\nObtiene el punto de codigo Unicode en el indice.\n\n**Firma:**\n```hemlock\nstring.char_at(index: i32): rune\n```\n\n**Parametros:**\n- `index` - Indice del punto de codigo (basado en 0)\n\n**Retorna:** Rune (punto de codigo Unicode)\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello\";\nlet ch = s.char_at(0);          // 'h'\nlet ch2 = s.char_at(1);         // 'e'\n\n// Ejemplo UTF-8\nlet emoji = \"\";\nlet ch3 = emoji.char_at(0);     // U+1F680 (cohete)\n```\n\n---\n\n#### chars\n\nConvierte el string a un array de runes.\n\n**Firma:**\n```hemlock\nstring.chars(): array\n```\n\n**Retorna:** Array de runes (puntos de codigo)\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']\n\n// Ejemplo UTF-8\nlet text = \"Hi!\";\nlet chars2 = text.chars();      // ['H', 'i', '', '!']\n```\n\n---\n\n### Acceso a Bytes\n\n#### byte_at\n\nObtiene el valor del byte en el indice.\n\n**Firma:**\n```hemlock\nstring.byte_at(index: i32): u8\n```\n\n**Parametros:**\n- `index` - Indice del byte (basado en 0, NO indice de punto de codigo)\n\n**Retorna:** Valor del byte (u8)\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (ASCII 'h')\nlet byte2 = s.byte_at(1);       // 101 (ASCII 'e')\n\n// Ejemplo UTF-8\nlet emoji = \"\";\nlet byte3 = emoji.byte_at(0);   // 240 (primer byte UTF-8)\n```\n\n---\n\n#### bytes\n\nConvierte el string a un array de bytes.\n\n**Firma:**\n```hemlock\nstring.bytes(): array\n```\n\n**Retorna:** Array de bytes u8\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111]\n\n// Ejemplo UTF-8\nlet emoji = \"\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 bytes UTF-8)\n```\n\n---\n\n#### to_bytes\n\nConvierte el string a buffer.\n\n**Firma:**\n```hemlock\nstring.to_bytes(): buffer\n```\n\n**Retorna:** Buffer conteniendo bytes UTF-8\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();\nprint(buf.length);              // 5\n\n// Ejemplo UTF-8\nlet emoji = \"\";\nlet buf2 = emoji.to_bytes();\nprint(buf2.length);             // 4\n```\n\n**Nota:** Este es un metodo heredado. Prefiera `.bytes()` para la mayoria de los casos de uso.\n\n---\n\n### Deserializacion JSON\n\n#### deserialize\n\nAnaliza un string JSON a un valor.\n\n**Firma:**\n```hemlock\nstring.deserialize(): any\n```\n\n**Retorna:** Valor analizado (objeto, array, numero, string, bool, o null)\n\n**Ejemplos:**\n```hemlock\nlet json = '{\"x\":10,\"y\":20}';\nlet obj = json.deserialize();\nprint(obj.x);                   // 10\nprint(obj.y);                   // 20\n\nlet arr_json = '[1,2,3]';\nlet arr = arr_json.deserialize();\nprint(arr[0]);                  // 1\n\nlet num_json = '42';\nlet num = num_json.deserialize();\nprint(num);                     // 42\n```\n\n**Tipos Soportados:**\n- Objetos: `{\"key\": value}`\n- Arrays: `[1, 2, 3]`\n- Numeros: `42`, `3.14`\n- Strings: `\"text\"`\n- Booleanos: `true`, `false`\n- Null: `null`\n\n**Ver Tambien:** Metodo `.serialize()` de objetos\n\n---\n\n## Encadenamiento de Metodos\n\nLos metodos de string pueden encadenarse para operaciones concisas:\n\n**Ejemplos:**\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \");                  // \"foo | bar | baz\"\n\nlet cleaned = \"  HELLO  \"\n    .trim()\n    .to_lower();                   // \"hello\"\n```\n\n---\n\n## Resumen Completo de Metodos\n\n| Metodo         | Firma                                        | Retorna   | Descripcion                           |\n|----------------|----------------------------------------------|-----------|---------------------------------------|\n| `substr`       | `(start: i32, length: i32)`                  | `string`  | Extraer subcadena por posicion/longitud |\n| `slice`        | `(start: i32, end: i32)`                     | `string`  | Extraer subcadena por rango           |\n| `find`         | `(needle: string)`                           | `i32`     | Encontrar primera ocurrencia (-1 si no se encuentra) |\n| `contains`     | `(needle: string)`                           | `bool`    | Verificar si contiene subcadena       |\n| `split`        | `(delimiter: string)`                        | `array`   | Dividir en array                      |\n| `trim`         | `()`                                         | `string`  | Eliminar espacios en blanco           |\n| `to_upper`     | `()`                                         | `string`  | Convertir a mayusculas                |\n| `to_lower`     | `()`                                         | `string`  | Convertir a minusculas                |\n| `starts_with`  | `(prefix: string)`                           | `bool`    | Verificar si comienza con prefijo     |\n| `ends_with`    | `(suffix: string)`                           | `bool`    | Verificar si termina con sufijo       |\n| `replace`      | `(old: string, new: string)`                 | `string`  | Reemplazar primera ocurrencia         |\n| `replace_all`  | `(old: string, new: string)`                 | `string`  | Reemplazar todas las ocurrencias      |\n| `repeat`       | `(count: i32)`                               | `string`  | Repetir string n veces                |\n| `char_at`      | `(index: i32)`                               | `rune`    | Obtener punto de codigo en indice     |\n| `byte_at`      | `(index: i32)`                               | `u8`      | Obtener byte en indice                |\n| `chars`        | `()`                                         | `array`   | Convertir a array de runes            |\n| `bytes`        | `()`                                         | `array`   | Convertir a array de bytes            |\n| `to_bytes`     | `()`                                         | `buffer`  | Convertir a buffer (heredado)         |\n| `deserialize`  | `()`                                         | `any`     | Analizar string JSON                  |\n\n---\n\n## Ver Tambien\n\n- [Sistema de Tipos](#reference-type-system) - Detalles del tipo string\n- [API de Arrays](#reference-array-api) - Metodos de array para resultados de split()\n- [Operadores](#reference-operators) - Operador de concatenacion de strings\n"}, "Referencia de API -> API de Concurrencia": {"id": "reference-concurrency-api", "content": "# Referencia de la API de Concurrencia\n\nReferencia completa para el sistema async/concurrencia de Hemlock.\n\n---\n\n## Descripcion General\n\nHemlock proporciona **concurrencia estructurada** con verdadero paralelismo multi-hilo usando hilos POSIX (pthreads). Cada tarea generada se ejecuta en un hilo separado del sistema operativo, permitiendo ejecucion paralela real a traves de multiples nucleos de CPU.\n\n**Caracteristicas Principales:**\n- Verdadero paralelismo multi-hilo (no hilos verdes)\n- Sintaxis de funciones async\n- Generacion y union de tareas\n- Canales seguros para hilos\n- Propagacion de excepciones\n\n**Modelo de Hilos:**\n- Hilos reales del SO (POSIX pthreads)\n- Verdadero paralelismo (multiples nucleos de CPU)\n- Planificacion del kernel (multitarea preemptiva)\n- Sincronizacion segura para hilos (mutexes, variables de condicion)\n\n---\n\n## Funciones Async\n\n### Declaracion de Funcion Async\n\nLas funciones pueden declararse como `async` para indicar que estan disenadas para ejecucion concurrente.\n\n**Sintaxis:**\n```hemlock\nasync fn nombre_funcion(params): tipo_retorno {\n    // cuerpo de funcion\n}\n```\n\n**Ejemplos:**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nasync fn process_data(data: string) {\n    print(\"Procesando:\", data);\n    return null;\n}\n```\n\n**Comportamiento:**\n- `async fn` declara una funcion asincrona\n- Puede llamarse sincronicamente (se ejecuta en el hilo actual)\n- Puede generarse como tarea concurrente (se ejecuta en nuevo hilo)\n- Cuando se genera, se ejecuta en su propio hilo del SO\n\n**Nota:** La palabra clave `await` esta reservada para uso futuro pero no esta implementada actualmente.\n\n---\n\n## Gestion de Tareas\n\n### spawn\n\nCrea e inicia una nueva tarea concurrente.\n\n**Firma:**\n```hemlock\nspawn(async_fn: function, ...args): task\n```\n\n**Parametros:**\n- `async_fn` - Funcion async a ejecutar\n- `...args` - Argumentos a pasar a la funcion\n\n**Retorna:** Manejador de tarea\n\n**Ejemplos:**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Generar una sola tarea\nlet t = spawn(compute, 1000);\nlet result = join(t);\nprint(result);\n\n// Generar multiples tareas (se ejecutan en paralelo!)\nlet t1 = spawn(compute, 100);\nlet t2 = spawn(compute, 200);\nlet t3 = spawn(compute, 300);\n\n// Las tres se estan ejecutando simultaneamente\nlet r1 = join(t1);\nlet r2 = join(t2);\nlet r3 = join(t3);\n```\n\n**Comportamiento:**\n- Crea nuevo hilo del SO via `pthread_create()`\n- Comienza a ejecutar la funcion inmediatamente\n- Retorna manejador de tarea para union posterior\n- Las tareas se ejecutan en paralelo en nucleos de CPU separados\n\n---\n\n### join\n\nEspera la finalizacion de la tarea y recupera el resultado.\n\n**Firma:**\n```hemlock\njoin(task: task): any\n```\n\n**Parametros:**\n- `task` - Manejador de tarea de `spawn()`\n\n**Retorna:** Valor de retorno de la tarea\n\n**Ejemplos:**\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nlet t = spawn(factorial, 10);\nlet result = join(t);  // Bloquea hasta que la tarea complete\nprint(result);         // 3628800\n```\n\n**Comportamiento:**\n- Bloquea el hilo actual hasta que la tarea complete\n- Retorna el valor de retorno de la tarea\n- Propaga excepciones lanzadas por la tarea\n- Limpia recursos de la tarea despues de retornar\n\n**Manejo de Errores:**\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Tarea fallo!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Capturado:\", e);  // \"Capturado: Tarea fallo!\"\n}\n```\n\n---\n\n### detach\n\nDesvincula la tarea (ejecucion de disparar y olvidar).\n\n**Firma:**\n```hemlock\ndetach(task: task): null\n```\n\n**Parametros:**\n- `task` - Manejador de tarea de `spawn()`\n\n**Retorna:** `null`\n\n**Ejemplos:**\n```hemlock\nasync fn background_work() {\n    print(\"Trabajando en segundo plano...\");\n    return null;\n}\n\nlet t = spawn(background_work);\ndetach(t);  // La tarea continua ejecutandose independientemente\n\n// No se puede unir tarea desvinculada\n// join(t);  // ERROR\n```\n\n**Comportamiento:**\n- La tarea continua ejecutandose independientemente\n- No se puede hacer `join()` a tarea desvinculada\n- La tarea y el hilo se limpian automaticamente cuando la tarea completa\n\n**Casos de Uso:**\n- Tareas de segundo plano de disparar y olvidar\n- Tareas de logging/monitoreo\n- Tareas que no necesitan retornar valores\n\n---\n\n## Canales\n\nLos canales proporcionan comunicacion segura entre hilos para tareas.\n\n### channel\n\nCrea un canal con buffer.\n\n**Firma:**\n```hemlock\nchannel(capacity: i32): channel\n```\n\n**Parametros:**\n- `capacity` - Tamano del buffer (numero de valores)\n\n**Retorna:** Objeto Canal\n\n**Ejemplos:**\n```hemlock\nlet ch = channel(10);  // Canal con buffer de capacidad 10\nlet ch2 = channel(1);  // Buffer minimo (sincrono)\nlet ch3 = channel(100); // Buffer grande\n```\n\n**Comportamiento:**\n- Crea canal seguro para hilos\n- Usa mutexes pthread para sincronizacion\n- La capacidad es fija al momento de creacion\n\n---\n\n### Metodos de Canal\n\n#### send\n\nEnvia valor al canal (bloquea si esta lleno).\n\n**Firma:**\n```hemlock\nchannel.send(value: any): null\n```\n\n**Parametros:**\n- `value` - Valor a enviar (cualquier tipo)\n\n**Retorna:** `null`\n\n**Ejemplos:**\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet t = spawn(producer, ch, 5);\n```\n\n**Comportamiento:**\n- Envia valor al canal\n- Bloquea si el canal esta lleno\n- Seguro para hilos (usa mutex)\n- Retorna despues de que el valor se envia\n\n---\n\n#### recv\n\nRecibe valor del canal (bloquea si esta vacio).\n\n**Firma:**\n```hemlock\nchannel.recv(): any\n```\n\n**Retorna:** Valor del canal, o `null` si el canal esta cerrado y vacio\n\n**Ejemplos:**\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet t = spawn(consumer, ch, 5);\n```\n\n**Comportamiento:**\n- Recibe valor del canal\n- Bloquea si el canal esta vacio\n- Retorna `null` si el canal esta cerrado y vacio\n- Seguro para hilos (usa mutex)\n\n---\n\n#### close\n\nCierra el canal (no se permiten mas envios).\n\n**Firma:**\n```hemlock\nchannel.close(): null\n```\n\n**Retorna:** `null`\n\n**Ejemplos:**\n```hemlock\nasync fn producer(ch) {\n    ch.send(1);\n    ch.send(2);\n    ch.send(3);\n    ch.close();  // Senalar que no hay mas valores\n    return null;\n}\n\nasync fn consumer(ch) {\n    while (true) {\n        let val = ch.recv();\n        if (val == null) {\n            break;  // Canal cerrado\n        }\n        print(val);\n    }\n    return null;\n}\n```\n\n**Comportamiento:**\n- Cierra el canal\n- No se permiten mas envios\n- `recv()` retorna `null` cuando el canal esta vacio\n- Seguro para hilos\n\n---\n\n## Ejemplo Completo de Concurrencia\n\n### Patron Productor-Consumidor\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        print(\"Produciendo:\", i);\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        print(\"Consumiendo:\", val);\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Crear canal\nlet ch = channel(10);\n\n// Generar productor y consumidor\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Esperar finalizacion\njoin(p);\nlet total = join(c);\nprint(\"Total:\", total);  // 0+10+20+30+40 = 100\n```\n\n---\n\n## Computacion Paralela\n\n### Ejemplo de Multiples Tareas\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Generar multiples tareas (se ejecutan en paralelo!)\nlet t1 = spawn(factorial, 5);   // Hilo 1\nlet t2 = spawn(factorial, 6);   // Hilo 2\nlet t3 = spawn(factorial, 7);   // Hilo 3\nlet t4 = spawn(factorial, 8);   // Hilo 4\n\n// Las cuatro estan computando simultaneamente!\n\n// Esperar resultados\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\nlet f8 = join(t4);  // 40320\n\nprint(f5, f6, f7, f8);\n```\n\n---\n\n## Ciclo de Vida de Tareas\n\n### Transiciones de Estado\n\n1. **Creada** - Tarea generada pero aun no ejecutando\n2. **Ejecutando** - Tarea ejecutandose en hilo del SO\n3. **Completada** - Tarea terminada (resultado disponible)\n4. **Unida** - Resultado recuperado, recursos limpiados\n5. **Desvinculada** - Tarea continua independientemente\n\n### Ejemplo de Ciclo de Vida\n\n```hemlock\nasync fn work(n: i32): i32 {\n    return n * 2;\n}\n\n// 1. Crear tarea\nlet t = spawn(work, 21);  // Estado: Ejecutando\n\n// La tarea se ejecuta en hilo separado...\n\n// 2. Unir tarea\nlet result = join(t);     // Estado: Completada -> Unida\nprint(result);            // 42\n\n// Recursos de tarea limpiados despues de union\n```\n\n### Ciclo de Vida Desvinculado\n\n```hemlock\nasync fn background() {\n    print(\"Tarea de segundo plano ejecutandose\");\n    return null;\n}\n\n// 1. Crear tarea\nlet t = spawn(background);  // Estado: Ejecutando\n\n// 2. Desvincular tarea\ndetach(t);                  // Estado: Desvinculada\n\n// La tarea continua ejecutandose independientemente\n// Recursos limpiados por el SO cuando termina\n```\n\n---\n\n## Manejo de Errores\n\n### Propagacion de Excepciones\n\nLas excepciones lanzadas en tareas se propagan cuando se unen:\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Tarea fallo!\";\n    }\n    return 42;\n}\n\n// Tarea que tiene exito\nlet t1 = spawn(risky_operation, 0);\nlet result1 = join(t1);  // 42\n\n// Tarea que falla\nlet t2 = spawn(risky_operation, 1);\ntry {\n    let result2 = join(t2);\n} catch (e) {\n    print(\"Capturado:\", e);  // \"Capturado: Tarea fallo!\"\n}\n```\n\n### Manejando Multiples Tareas\n\n```hemlock\nasync fn work(id: i32, should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Tarea \" + typeof(id) + \" fallo\";\n    }\n    return id * 10;\n}\n\nlet t1 = spawn(work, 1, 0);\nlet t2 = spawn(work, 2, 1);  // Fallara\nlet t3 = spawn(work, 3, 0);\n\n// Unir con manejo de errores\ntry {\n    let r1 = join(t1);  // OK\n    print(\"Tarea 1:\", r1);\n\n    let r2 = join(t2);  // Lanza\n    print(\"Tarea 2:\", r2);  // Nunca se alcanza\n} catch (e) {\n    print(\"Error:\", e);  // \"Error: Tarea 2 fallo\"\n}\n\n// Aun se puede unir la tarea restante\nlet r3 = join(t3);\nprint(\"Tarea 3:\", r3);\n```\n\n---\n\n## Caracteristicas de Rendimiento\n\n### Verdadero Paralelismo\n\n```hemlock\nasync fn cpu_intensive(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Ejecucion secuencial\nlet start = get_time();\nlet r1 = cpu_intensive(10000000);\nlet r2 = cpu_intensive(10000000);\nlet sequential_time = get_time() - start;\n\n// Ejecucion paralela\nlet start2 = get_time();\nlet t1 = spawn(cpu_intensive, 10000000);\nlet t2 = spawn(cpu_intensive, 10000000);\njoin(t1);\njoin(t2);\nlet parallel_time = get_time() - start2;\n\n// parallel_time deberia ser ~50% de sequential_time en sistemas multi-nucleo\n```\n\n**Caracteristicas Comprobadas:**\n- N tareas pueden utilizar N nucleos de CPU simultaneamente\n- Pruebas de estres muestran 8-9x tiempo de CPU vs tiempo real (prueba de paralelismo)\n- Sobrecarga de hilo: ~8KB de pila + sobrecarga de pthread por tarea\n- Operaciones bloqueantes en una tarea no bloquean otras\n\n---\n\n## Detalles de Implementacion\n\n### Modelo de Hilos\n\n- **Hilos 1:1** - Cada tarea = 1 hilo del SO (`pthread`)\n- **Planificacion del kernel** - El kernel del SO distribuye hilos entre nucleos\n- **Multitarea preemptiva** - El SO puede interrumpir y cambiar hilos\n- **Sin GIL** - Sin Bloqueo Global del Interprete (a diferencia de Python)\n\n### Sincronizacion\n\n- **Mutexes** - Los canales usan `pthread_mutex_t`\n- **Variables de condicion** - send/recv bloqueantes usan `pthread_cond_t`\n- **Operaciones sin bloqueo** - Las transiciones de estado de tarea son atomicas\n\n### Memoria y Limpieza\n\n- **Tareas unidas** - Limpiadas automaticamente despues de `join()`\n- **Tareas desvinculadas** - Limpiadas automaticamente cuando la tarea completa\n- **Canales** - Con conteo de referencias, liberados cuando ya no se usan\n\n---\n\n## Limitaciones\n\n- Sin `select()` para multiplexar multiples canales\n- Sin planificador de robo de trabajo (1 hilo por tarea)\n- Sin integracion de E/S async (operaciones de archivo/red bloquean)\n- Capacidad del canal fija al momento de creacion\n\n---\n\n## Resumen Completo de la API\n\n### Funciones\n\n| Funcion   | Firma                             | Retorna   | Descripcion                    |\n|-----------|-----------------------------------|-----------|--------------------------------|\n| `spawn`   | `(async_fn: function, ...args)`   | `task`    | Crear e iniciar tarea concurrente |\n| `join`    | `(task: task)`                    | `any`     | Esperar tarea, obtener resultado |\n| `detach`  | `(task: task)`                    | `null`    | Desvincular tarea (disparar y olvidar) |\n| `channel` | `(capacity: i32)`                 | `channel` | Crear canal seguro para hilos  |\n\n### Metodos de Canal\n\n| Metodo  | Firma           | Retorna | Descripcion                      |\n|---------|-----------------|---------|----------------------------------|\n| `send`  | `(value: any)`  | `null`  | Enviar valor (bloquea si lleno)  |\n| `recv`  | `()`            | `any`   | Recibir valor (bloquea si vacio) |\n| `close` | `()`            | `null`  | Cerrar canal                     |\n\n### Tipos\n\n| Tipo      | Descripcion                          |\n|-----------|--------------------------------------|\n| `task`    | Manejador para tarea concurrente     |\n| `channel` | Canal de comunicacion seguro para hilos |\n\n---\n\n## Mejores Practicas\n\n### Hacer\n\n- Use canales para comunicacion entre tareas\n- Maneje excepciones de tareas unidas\n- Cierre canales cuando termine de enviar\n- Use `join()` para obtener resultados y limpiar\n- Genere solo funciones async\n\n### No Hacer\n\n- No comparta estado mutable sin sincronizacion\n- No una la misma tarea dos veces\n- No envie en canales cerrados\n- No genere funciones no-async\n- No olvide unir tareas (a menos que esten desvinculadas)\n\n---\n\n## Ver Tambien\n\n- [Funciones Integradas](#reference-builtins) - `spawn()`, `join()`, `detach()`, `channel()`\n- [Sistema de Tipos](#reference-type-system) - Tipos de tarea y canal\n"}, "Referencia de API -> API de Memoria": {"id": "reference-memory-api", "content": "# Referencia de la API de Memoria\n\nReferencia completa para las funciones de gestion de memoria y tipos de puntero de Hemlock.\n\n---\n\n## Descripcion General\n\nHemlock proporciona **gestion manual de memoria** con asignacion y liberacion explicitas. La memoria se gestiona a traves de dos tipos de puntero: punteros crudos (`ptr`) y buffers seguros (`buffer`).\n\n**Principios Clave:**\n- Asignacion y liberacion explicitas\n- Sin recoleccion de basura\n- El usuario es responsable de llamar a `free()`\n- Conteo de referencias interno para seguridad de alcance/reasignacion (ver abajo)\n\n### Conteo de Referencias Interno\n\nEl runtime usa conteo de referencias internamente para gestionar los tiempos de vida de objetos a traves de alcances. Para la mayoria de variables locales, la limpieza es automatica.\n\n**Automatico (sin necesidad de `free()`):**\n- Variables locales de tipos con conteo de referencias (buffer, array, object, string) se liberan cuando el alcance termina\n- Los valores antiguos se liberan cuando las variables se reasignan\n- Los elementos de contenedores se liberan cuando los contenedores se liberan\n\n**Se requiere `free()` manual:**\n- Punteros crudos de `alloc()` - siempre\n- Limpieza temprana antes de que termine el alcance\n- Datos de larga duracion/globales\n\nVea la [Guia de Gestion de Memoria](../language-guide/memory.md#internal-reference-counting) para detalles.\n\n---\n\n## Tipos de Puntero\n\n### ptr (Puntero Crudo)\n\n**Tipo:** `ptr`\n\n**Descripcion:** Direccion de memoria cruda sin verificacion de limites ni seguimiento.\n\n**Tamano:** 8 bytes\n\n**Casos de Uso:**\n- Operaciones de memoria de bajo nivel\n- FFI (Interfaz de Funciones Foraneas)\n- Maximo rendimiento (sin sobrecarga)\n\n**Seguridad:** Inseguro - sin verificacion de limites, el usuario debe rastrear el tiempo de vida\n\n**Ejemplos:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n---\n\n### buffer (Buffer Seguro)\n\n**Tipo:** `buffer`\n\n**Descripcion:** Envoltorio de puntero seguro con verificacion de limites.\n\n**Estructura:** Puntero + longitud + capacidad + ref_count\n\n**Propiedades:**\n- `.length` - Tamano del buffer (i32)\n- `.capacity` - Capacidad asignada (i32)\n\n**Casos de Uso:**\n- La mayoria de las asignaciones de memoria\n- Cuando la seguridad es importante\n- Arrays dinamicos\n\n**Seguridad:** Verificacion de limites en acceso por indice\n\n**Conteo de Referencias:** Los buffers tienen conteo de referencias interno. Se liberan automaticamente cuando el alcance termina o la variable se reasigna. Use `free()` para limpieza temprana o datos de larga duracion.\n\n**Ejemplos:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Verificacion de limites\nprint(b.length);        // 64\nfree(b);\n```\n\n---\n\n## Funciones de Asignacion de Memoria\n\n### alloc\n\nAsigna memoria cruda.\n\n**Firma:**\n```hemlock\nalloc(size: i32): ptr\n```\n\n**Parametros:**\n- `size` - Numero de bytes a asignar\n\n**Retorna:** Puntero a la memoria asignada (`ptr`)\n\n**Ejemplos:**\n```hemlock\nlet p = alloc(1024);        // Asignar 1KB\nmemset(p, 0, 1024);         // Inicializar a cero\nfree(p);                    // Liberar cuando termine\n\n// Asignar para estructura\nlet struct_size = 16;\nlet p2 = alloc(struct_size);\n```\n\n**Comportamiento:**\n- Retorna memoria sin inicializar\n- La memoria debe liberarse manualmente\n- Retorna `null` en fallo de asignacion (el llamador debe verificar)\n\n**Ver Tambien:** `buffer()` para alternativa mas segura\n\n---\n\n### buffer\n\nAsigna buffer seguro con verificacion de limites.\n\n**Firma:**\n```hemlock\nbuffer(size: i32): buffer\n```\n\n**Parametros:**\n- `size` - Tamano del buffer en bytes\n\n**Retorna:** Objeto Buffer\n\n**Ejemplos:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\nprint(buf.capacity);        // 256\n\n// Acceso con verificacion de limites\nbuf[0] = 65;                // 'A'\nbuf[255] = 90;              // 'Z'\n// buf[256] = 0;            // ERROR: fuera de limites\n\nfree(buf);\n```\n\n**Propiedades:**\n- `.length` - Tamano actual (i32)\n- `.capacity` - Capacidad asignada (i32)\n\n**Comportamiento:**\n- Inicializa la memoria a cero\n- Proporciona verificacion de limites en acceso por indice\n- Retorna `null` en fallo de asignacion (el llamador debe verificar)\n- Debe liberarse manualmente\n\n---\n\n### free\n\nLibera memoria asignada.\n\n**Firma:**\n```hemlock\nfree(ptr: ptr | buffer): null\n```\n\n**Parametros:**\n- `ptr` - Puntero o buffer a liberar\n\n**Retorna:** `null`\n\n**Ejemplos:**\n```hemlock\n// Liberar puntero crudo\nlet p = alloc(1024);\nfree(p);\n\n// Liberar buffer\nlet buf = buffer(256);\nfree(buf);\n```\n\n**Comportamiento:**\n- Libera memoria asignada por `alloc()` o `buffer()`\n- Doble liberacion causa crash (responsabilidad del usuario evitarlo)\n- Liberar punteros invalidos causa comportamiento indefinido\n\n**Importante:** Tu asignas, tu liberas. Sin limpieza automatica.\n\n---\n\n### realloc\n\nRedimensiona memoria asignada.\n\n**Firma:**\n```hemlock\nrealloc(ptr: ptr, new_size: i32): ptr\n```\n\n**Parametros:**\n- `ptr` - Puntero a redimensionar\n- `new_size` - Nuevo tamano en bytes\n\n**Retorna:** Puntero a la memoria redimensionada (puede ser direccion diferente)\n\n**Ejemplos:**\n```hemlock\nlet p = alloc(100);\n// ... usar memoria ...\n\n// Necesita mas espacio\np = realloc(p, 200);        // Ahora 200 bytes\n// ... usar memoria expandida ...\n\nfree(p);\n```\n\n**Comportamiento:**\n- Puede mover la memoria a nueva ubicacion\n- Preserva datos existentes (hasta el minimo del tamano antiguo/nuevo)\n- El puntero antiguo es invalido despues de realloc exitoso (use el puntero retornado)\n- Si new_size es menor, los datos se truncan\n- Retorna `null` en fallo de asignacion (el puntero original permanece valido)\n\n**Importante:** Siempre verifique si es `null` y actualice su variable de puntero con el resultado.\n\n---\n\n## Operaciones de Memoria\n\n### memset\n\nLlena memoria con valor de byte.\n\n**Firma:**\n```hemlock\nmemset(ptr: ptr, byte: i32, size: i32): null\n```\n\n**Parametros:**\n- `ptr` - Puntero a memoria\n- `byte` - Valor de byte a llenar (0-255)\n- `size` - Numero de bytes a llenar\n\n**Retorna:** `null`\n\n**Ejemplos:**\n```hemlock\nlet p = alloc(100);\n\n// Poner memoria a cero\nmemset(p, 0, 100);\n\n// Llenar con valor especifico\nmemset(p, 0xFF, 100);\n\n// Inicializar buffer\nlet buf = alloc(256);\nmemset(buf, 65, 256);       // Llenar con 'A'\n\nfree(p);\nfree(buf);\n```\n\n**Comportamiento:**\n- Escribe el valor de byte a cada byte en el rango\n- El valor de byte se trunca a 8 bits (0-255)\n- Sin verificacion de limites (inseguro)\n\n---\n\n### memcpy\n\nCopia memoria desde origen a destino.\n\n**Firma:**\n```hemlock\nmemcpy(dest: ptr, src: ptr, size: i32): null\n```\n\n**Parametros:**\n- `dest` - Puntero destino\n- `src` - Puntero origen\n- `size` - Numero de bytes a copiar\n\n**Retorna:** `null`\n\n**Ejemplos:**\n```hemlock\nlet src = alloc(100);\nlet dest = alloc(100);\n\n// Inicializar origen\nmemset(src, 65, 100);\n\n// Copiar a destino\nmemcpy(dest, src, 100);\n\n// dest ahora contiene los mismos datos que src\n\nfree(src);\nfree(dest);\n```\n\n**Comportamiento:**\n- Copia byte por byte desde src a dest\n- Sin verificacion de limites (inseguro)\n- Regiones superpuestas tienen comportamiento indefinido (use con cuidado)\n\n---\n\n## Operaciones de Memoria Tipadas\n\n### sizeof\n\nObtiene el tamano de un tipo en bytes.\n\n**Firma:**\n```hemlock\nsizeof(type): i32\n```\n\n**Parametros:**\n- `type` - Identificador de tipo (ej., `i32`, `f64`, `ptr`)\n\n**Retorna:** Tamano en bytes (i32)\n\n**Tamanos de Tipos:**\n\n| Tipo | Tamano (bytes) |\n|------|----------------|\n| `i8` | 1 |\n| `i16` | 2 |\n| `i32`, `integer` | 4 |\n| `i64` | 8 |\n| `u8`, `byte` | 1 |\n| `u16` | 2 |\n| `u32` | 4 |\n| `u64` | 8 |\n| `f32` | 4 |\n| `f64`, `number` | 8 |\n| `bool` | 1 |\n| `ptr` | 8 |\n| `rune` | 4 |\n\n**Ejemplos:**\n```hemlock\nlet int_size = sizeof(i32);      // 4\nlet ptr_size = sizeof(ptr);      // 8\nlet float_size = sizeof(f64);    // 8\nlet byte_size = sizeof(u8);      // 1\nlet rune_size = sizeof(rune);    // 4\n\n// Calcular tamano de asignacion de array\nlet count = 100;\nlet total = sizeof(i32) * count; // 400 bytes\n```\n\n**Comportamiento:**\n- Retorna 0 para tipos desconocidos\n- Acepta tanto identificadores de tipo como strings de tipo\n\n---\n\n### talloc\n\nAsigna array de valores tipados.\n\n**Firma:**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**Parametros:**\n- `type` - Tipo a asignar (ej., `i32`, `f64`, `ptr`)\n- `count` - Numero de elementos (debe ser positivo)\n\n**Retorna:** Puntero al array asignado, o `null` en fallo de asignacion\n\n**Ejemplos:**\n```hemlock\nlet arr = talloc(i32, 100);      // Array de 100 i32s (400 bytes)\nlet floats = talloc(f64, 50);    // Array de 50 f64s (400 bytes)\nlet bytes = talloc(u8, 1024);    // Array de 1024 bytes\n\n// Siempre verificar fallo de asignacion\nif (arr == null) {\n    panic(\"fallo de asignacion\");\n}\n\n// Usar la memoria asignada\n// ...\n\nfree(arr);\nfree(floats);\nfree(bytes);\n```\n\n**Comportamiento:**\n- Asigna `sizeof(type) * count` bytes\n- Retorna memoria sin inicializar\n- La memoria debe liberarse manualmente con `free()`\n- Retorna `null` en fallo de asignacion (el llamador debe verificar)\n- Entra en panico si count no es positivo\n\n---\n\n## Propiedades de Buffer\n\n### .length\n\nObtiene el tamano del buffer.\n\n**Tipo:** `i32`\n\n**Acceso:** Solo lectura\n\n**Ejemplos:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\n\nlet buf2 = buffer(1024);\nprint(buf2.length);         // 1024\n```\n\n---\n\n### .capacity\n\nObtiene la capacidad del buffer.\n\n**Tipo:** `i32`\n\n**Acceso:** Solo lectura\n\n**Ejemplos:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.capacity);        // 256\n```\n\n**Nota:** Actualmente, `.length` y `.capacity` son iguales para buffers creados con `buffer()`.\n\n---\n\n## Patrones de Uso\n\n### Patron de Asignacion Basico\n\n```hemlock\n// Asignar\nlet p = alloc(1024);\nif (p == null) {\n    panic(\"fallo de asignacion\");\n}\n\n// Usar\nmemset(p, 0, 1024);\n\n// Liberar\nfree(p);\n```\n\n### Patron de Buffer Seguro\n\n```hemlock\n// Asignar buffer\nlet buf = buffer(256);\nif (buf == null) {\n    panic(\"fallo de asignacion de buffer\");\n}\n\n// Usar con verificacion de limites\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\n// Liberar\nfree(buf);\n```\n\n### Patron de Crecimiento Dinamico\n\n```hemlock\nlet size = 100;\nlet p = alloc(size);\nif (p == null) {\n    panic(\"fallo de asignacion\");\n}\n\n// ... usar memoria ...\n\n// Necesita mas espacio - verificar fallo\nlet new_p = realloc(p, 200);\nif (new_p == null) {\n    // El puntero original sigue valido, limpiar\n    free(p);\n    panic(\"fallo de realloc\");\n}\np = new_p;\nsize = 200;\n\n// ... usar memoria expandida ...\n\nfree(p);\n```\n\n### Patron de Copia de Memoria\n\n```hemlock\nlet original = alloc(100);\nmemset(original, 65, 100);\n\n// Crear copia\nlet copy = alloc(100);\nmemcpy(copy, original, 100);\n\nfree(original);\nfree(copy);\n```\n\n---\n\n## Consideraciones de Seguridad\n\n**La gestion de memoria de Hemlock es INSEGURA por diseno:**\n\n### Errores Comunes\n\n**1. Fugas de Memoria**\n```hemlock\n// MAL: Fuga de memoria\nfn create_buffer() {\n    let p = alloc(1024);\n    return null;  // Memoria perdida!\n}\n\n// BIEN: Limpieza apropiada\nfn create_buffer() {\n    let p = alloc(1024);\n    // ... usar memoria ...\n    free(p);\n    return null;\n}\n```\n\n**2. Uso Despues de Liberar**\n```hemlock\n// MAL: Uso despues de liberar\nlet p = alloc(100);\nfree(p);\nmemset(p, 0, 100);  // CRASH: usando memoria liberada\n\n// BIEN: No usar despues de liberar\nlet p2 = alloc(100);\nmemset(p2, 0, 100);\nfree(p2);\n// No tocar p2 despues de esto\n```\n\n**3. Doble Liberacion**\n```hemlock\n// MAL: Doble liberacion\nlet p = alloc(100);\nfree(p);\nfree(p);  // CRASH: doble liberacion\n\n// BIEN: Liberar una vez\nlet p2 = alloc(100);\nfree(p2);\n```\n\n**4. Desbordamiento de Buffer (ptr)**\n```hemlock\n// MAL: Desbordamiento de buffer con ptr\nlet p = alloc(10);\nmemset(p, 65, 100);  // CRASH: escribiendo mas alla de la asignacion\n\n// BIEN: Usar buffer para verificacion de limites\nlet buf = buffer(10);\n// buf[100] = 65;  // ERROR: verificacion de limites falla\n```\n\n**5. Punteros Colgantes**\n```hemlock\n// MAL: Puntero colgante\nlet p1 = alloc(100);\nlet p2 = p1;\nfree(p1);\nmemset(p2, 0, 100);  // CRASH: p2 esta colgando\n\n// BIEN: Rastrear propiedad cuidadosamente\nlet p = alloc(100);\n// ... usar p ...\nfree(p);\n// No mantener otras referencias a p\n```\n\n**6. Fallo de Asignacion sin Verificar**\n```hemlock\n// MAL: No verificar null\nlet p = alloc(1000000000);  // Puede fallar con poca memoria\nmemset(p, 0, 1000000000);   // CRASH: p es null\n\n// BIEN: Siempre verificar resultado de asignacion\nlet p2 = alloc(1000000000);\nif (p2 == null) {\n    panic(\"sin memoria\");\n}\nmemset(p2, 0, 1000000000);\nfree(p2);\n```\n\n---\n\n## Cuando Usar Que\n\n### Use `buffer()` cuando:\n- Necesite verificacion de limites\n- Trabaje con datos dinamicos\n- La seguridad sea importante\n- Este aprendiendo Hemlock\n\n### Use `alloc()` cuando:\n- Necesite maximo rendimiento\n- Interfaz FFI/con C\n- Conozca el layout exacto de memoria\n- Sea un experto\n\n### Use `realloc()` cuando:\n- Crezca/reduzca asignaciones\n- Arrays dinamicos\n- Necesite preservar datos\n\n---\n\n## Resumen Completo de Funciones\n\n| Funcion   | Firma                              | Retorna  | Descripcion                |\n|-----------|----------------------------------------|----------|----------------------------|\n| `alloc`   | `(size: i32)`                          | `ptr`    | Asignar memoria cruda      |\n| `buffer`  | `(size: i32)`                          | `buffer` | Asignar buffer seguro      |\n| `free`    | `(ptr: ptr \\| buffer)`                 | `null`   | Liberar memoria            |\n| `realloc` | `(ptr: ptr, new_size: i32)`            | `ptr`    | Redimensionar asignacion   |\n| `memset`  | `(ptr: ptr, byte: i32, size: i32)`     | `null`   | Llenar memoria             |\n| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`     | `null`   | Copiar memoria             |\n| `sizeof`  | `(type)`                               | `i32`    | Obtener tamano de tipo en bytes |\n| `talloc`  | `(type, count: i32)`                   | `ptr`    | Asignar array tipado       |\n\n---\n\n## Ver Tambien\n\n- [Sistema de Tipos](#reference-type-system) - Tipos de puntero y buffer\n- [Funciones Integradas](#reference-builtins) - Todas las funciones integradas\n- [API de Strings](#reference-string-api) - Metodo `.to_bytes()` de string\n"}, "Referencia de API -> Funciones Integradas": {"id": "reference-builtins", "content": "# Referencia de Funciones Integradas\n\nReferencia completa para todas las funciones integradas y constantes en Hemlock.\n\n---\n\n## Descripcion General\n\nHemlock proporciona un conjunto de funciones integradas para E/S, introspeccion de tipos, gestion de memoria, concurrencia e interaccion con el sistema. Todas las funciones integradas estan disponibles globalmente sin importaciones.\n\n---\n\n## Funciones de E/S\n\n### print\n\nImprime valores a stdout con nueva linea.\n\n**Firma:**\n```hemlock\nprint(...values): null\n```\n\n**Parametros:**\n- `...values` - Cualquier numero de valores a imprimir\n\n**Retorna:** `null`\n\n**Ejemplos:**\n```hemlock\nprint(\"Hello, World!\");\nprint(42);\nprint(3.14);\nprint(true);\nprint([1, 2, 3]);\nprint({ x: 10, y: 20 });\n\n// Multiples valores\nprint(\"x =\", 10, \"y =\", 20);\n```\n\n**Comportamiento:**\n- Convierte todos los valores a strings\n- Separa multiples valores con espacios\n- Agrega nueva linea al final\n- Vacia stdout\n\n---\n\n### read_line\n\nLee una linea de texto desde stdin (entrada del usuario).\n\n**Firma:**\n```hemlock\nread_line(): string | null\n```\n\n**Parametros:** Ninguno\n\n**Retorna:**\n- `string` - La linea leida desde stdin (nueva linea eliminada)\n- `null` - En EOF (fin de archivo/entrada)\n\n**Ejemplos:**\n```hemlock\n// Prompt simple\nprint(\"Cual es tu nombre?\");\nlet name = read_line();\nprint(\"Hola, \" + name + \"!\");\n\n// Leer numeros (requiere analisis manual)\nprint(\"Ingresa un numero:\");\nlet input = read_line();\nlet num = parse_int(input);  // Ver abajo para parse_int\nprint(\"Doble:\", num * 2);\n\n// Manejar EOF\nlet line = read_line();\nif (line == null) {\n    print(\"Fin de entrada\");\n}\n\n// Leer multiples lineas\nprint(\"Ingresa lineas (Ctrl+D para parar):\");\nwhile (true) {\n    let line = read_line();\n    if (line == null) {\n        break;\n    }\n    print(\"Dijiste:\", line);\n}\n```\n\n**Comportamiento:**\n- Bloquea hasta que el usuario presiona Enter\n- Elimina nueva linea (`\\n`) y retorno de carro (`\\r`) finales\n- Retorna `null` en EOF (Ctrl+D en Unix, Ctrl+Z en Windows)\n- Lee solo desde stdin (no desde archivos)\n\n**Analizando Entrada del Usuario:**\n\nComo `read_line()` siempre retorna un string, necesita analizar entrada numerica manualmente:\n\n```hemlock\n// Analizador simple de enteros\nfn parse_int(s: string): i32 {\n    let result: i32 = 0;\n    let negative = false;\n    let i = 0;\n\n    if (s.length > 0 && s.char_at(0) == '-') {\n        negative = true;\n        i = 1;\n    }\n\n    while (i < s.length) {\n        let c = s.char_at(i);\n        let code: i32 = c;\n        if (code >= 48 && code <= 57) {\n            result = result * 10 + (code - 48);\n        } else {\n            break;\n        }\n        i = i + 1;\n    }\n\n    if (negative) {\n        return -result;\n    }\n    return result;\n}\n\n// Uso\nprint(\"Ingresa tu edad:\");\nlet age = parse_int(read_line());\nprint(\"En 10 anos tendras\", age + 10);\n```\n\n**Ver Tambien:** [API de Archivos](#reference-file-api) para leer desde archivos\n\n---\n\n### eprint\n\nImprime un valor a stderr con nueva linea.\n\n**Firma:**\n```hemlock\neprint(value: any): null\n```\n\n**Parametros:**\n- `value` - Valor unico a imprimir a stderr\n\n**Retorna:** `null`\n\n**Ejemplos:**\n```hemlock\neprint(\"Error: archivo no encontrado\");\neprint(404);\neprint(\"Advertencia: \" + message);\n\n// Patron tipico de manejo de errores\nfn load_config(path: string) {\n    if (!exists(path)) {\n        eprint(\"Error: archivo de configuracion no encontrado: \" + path);\n        return null;\n    }\n    // ...\n}\n```\n\n**Comportamiento:**\n- Imprime a stderr (flujo de error estandar)\n- Agrega nueva linea al final\n- Solo acepta un argumento (a diferencia de `print`)\n- Util para mensajes de error que no deben mezclarse con salida normal\n\n**Diferencia con print:**\n- `print()` -> stdout (salida normal, puede redirigirse con `>`)\n- `eprint()` -> stderr (salida de error, puede redirigirse con `2>`)\n\n```bash\n# Ejemplo de shell: separar stdout y stderr\n./hemlock script.hml > output.txt 2> errors.txt\n```\n\n---\n\n## Introspeccion de Tipos\n\n### typeof\n\nObtiene el nombre del tipo de un valor.\n\n**Firma:**\n```hemlock\ntypeof(value: any): string\n```\n\n**Parametros:**\n- `value` - Cualquier valor\n\n**Retorna:** Nombre del tipo como string\n\n**Ejemplos:**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof(null));            // \"null\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\n// Objetos tipados\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n\n// Otros tipos\nprint(typeof(alloc(10)));       // \"ptr\"\nprint(typeof(buffer(10)));      // \"buffer\"\nprint(typeof(open(\"file.txt\"))); // \"file\"\n```\n\n**Nombres de Tipos:**\n- Primitivos: `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- Compuestos: `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- Especiales: `\"file\"`, `\"task\"`, `\"channel\"`\n- Personalizados: Nombres de tipos definidos por el usuario desde `define`\n\n**Ver Tambien:** [Sistema de Tipos](#reference-type-system)\n\n---\n\n## Ejecucion de Comandos\n\n### exec\n\nEjecuta comando de shell y captura salida.\n\n**Firma:**\n```hemlock\nexec(command: string): object\n```\n\n**Parametros:**\n- `command` - Comando de shell a ejecutar\n\n**Retorna:** Objeto con campos:\n- `output` (string) - stdout del comando\n- `exit_code` (i32) - Codigo de estado de salida (0 = exito)\n\n**Ejemplos:**\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n\n// Verificar estado de salida\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Encontrado:\", r.output);\n} else {\n    print(\"Patron no encontrado\");\n}\n\n// Procesar salida multi-linea\nlet r2 = exec(\"ls -la\");\nlet lines = r2.output.split(\"\\n\");\n```\n\n**Comportamiento:**\n- Ejecuta comando via `/bin/sh`\n- Captura solo stdout (stderr va a terminal)\n- Bloquea hasta que el comando complete\n- Retorna string vacio si no hay salida\n\n**Manejo de Errores:**\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command\");\n} catch (e) {\n    print(\"Fallo al ejecutar:\", e);\n}\n```\n\n**Advertencia de Seguridad:** Vulnerable a inyeccion de shell. Siempre valide/sanee entrada del usuario.\n\n**Limitaciones:**\n- Sin captura de stderr\n- Sin streaming\n- Sin timeout\n- Sin manejo de senales\n\n---\n\n### exec_argv\n\nEjecuta un comando con array de argumentos explicito (sin interpretacion de shell).\n\n**Firma:**\n```hemlock\nexec_argv(argv: array): object\n```\n\n**Parametros:**\n- `argv` - Array de strings: `[comando, arg1, arg2, ...]`\n\n**Retorna:** Objeto con campos:\n- `output` (string) - stdout del comando\n- `exit_code` (i32) - Codigo de estado de salida (0 = exito)\n\n**Ejemplos:**\n```hemlock\n// Comando simple\nlet result = exec_argv([\"ls\", \"-la\"]);\nprint(result.output);\n\n// Comando con argumentos que contienen espacios (seguro!)\nlet r = exec_argv([\"grep\", \"hello world\", \"file.txt\"]);\n\n// Ejecutar script con argumentos\nlet r2 = exec_argv([\"python\", \"script.py\", \"--input\", \"data.json\"]);\nprint(r2.exit_code);\n```\n\n**Diferencia con exec:**\n```hemlock\n// exec() usa shell - INSEGURO con entrada de usuario\nexec(\"ls \" + user_input);  // Riesgo de inyeccion de shell!\n\n// exec_argv() evita shell - SEGURO\nexec_argv([\"ls\", user_input]);  // Sin inyeccion posible\n```\n\n**Cuando usar:**\n- Cuando los argumentos contienen espacios, comillas o caracteres especiales\n- Al procesar entrada de usuario (seguridad)\n- Cuando necesita analisis predecible de argumentos\n\n**Ver Tambien:** `exec()` para comandos de shell simples\n\n---\n\n## Manejo de Errores\n\n### throw\n\nLanza una excepcion.\n\n**Firma:**\n```hemlock\nthrow expression\n```\n\n**Parametros:**\n- `expression` - Valor a lanzar (cualquier tipo)\n\n**Retorna:** Nunca retorna (transfiere control)\n\n**Ejemplos:**\n```hemlock\nthrow \"mensaje de error\";\nthrow 404;\nthrow { code: 500, message: \"Error interno\" };\nthrow null;\n```\n\n**Ver Tambien:** Sentencias try/catch/finally\n\n---\n\n### panic\n\nTermina inmediatamente el programa con mensaje de error (irrecuperable).\n\n**Firma:**\n```hemlock\npanic(message?: any): never\n```\n\n**Parametros:**\n- `message` (opcional) - Mensaje de error a imprimir\n\n**Retorna:** Nunca retorna (el programa sale)\n\n**Ejemplos:**\n```hemlock\npanic();                          // Por defecto: \"panic!\"\npanic(\"codigo inalcanzable alcanzado\");\npanic(42);\n\n// Caso de uso comun\nfn process_state(state: i32): string {\n    if (state == 1) { return \"listo\"; }\n    if (state == 2) { return \"ejecutando\"; }\n    panic(\"estado invalido: \" + typeof(state));\n}\n```\n\n**Comportamiento:**\n- Imprime error a stderr: `panic: <mensaje>`\n- Sale con codigo 1\n- **NO se puede capturar** con try/catch\n- Use para bugs y errores irrecuperables\n\n**Panic vs Throw:**\n- `panic()` - Error irrecuperable, sale inmediatamente\n- `throw` - Error recuperable, puede capturarse\n\n---\n\n### assert\n\nAfirma que una condicion es verdadera, o termina con un mensaje de error.\n\n**Firma:**\n```hemlock\nassert(condition: any, message?: string): null\n```\n\n**Parametros:**\n- `condition` - Valor a verificar por veracidad\n- `message` (opcional) - Mensaje de error personalizado si la afirmacion falla\n\n**Retorna:** `null` (si la afirmacion pasa)\n\n**Ejemplos:**\n```hemlock\n// Afirmaciones basicas\nassert(x > 0);\nassert(name != null);\nassert(arr.length > 0, \"El array no debe estar vacio\");\n\n// Con mensajes personalizados\nfn divide(a: i32, b: i32): f64 {\n    assert(b != 0, \"Division por cero\");\n    return a / b;\n}\n\n// Validar argumentos de funcion\nfn process_data(data: array) {\n    assert(data != null, \"data no puede ser null\");\n    assert(data.length > 0, \"data no puede estar vacio\");\n    // ...\n}\n```\n\n**Comportamiento:**\n- Si la condicion es verdadera: retorna `null`, la ejecucion continua\n- Si la condicion es falsa: imprime error y sale con codigo 1\n- Valores falsos: `false`, `0`, `0.0`, `null`, `\"\"` (string vacio)\n- Valores verdaderos: todo lo demas\n\n**Salida en fallo:**\n```\nAssertion failed: El array no debe estar vacio\n```\n\n**Cuando usar:**\n- Validar precondiciones de funciones\n- Verificar invariantes durante desarrollo\n- Capturar errores del programador temprano\n\n**assert vs panic:**\n- `assert(cond, msg)` - Verifica una condicion, falla si es falsa\n- `panic(msg)` - Siempre falla incondicionalmente\n\n---\n\n## Manejo de Senales\n\n### signal\n\nRegistra o reinicia manejador de senal.\n\n**Firma:**\n```hemlock\nsignal(signum: i32, handler: function | null): function | null\n```\n\n**Parametros:**\n- `signum` - Numero de senal (use constantes como `SIGINT`)\n- `handler` - Funcion a llamar cuando se recibe senal, o `null` para reiniciar a predeterminado\n\n**Retorna:** Funcion manejadora anterior, o `null`\n\n**Ejemplos:**\n```hemlock\nfn handle_interrupt(sig) {\n    print(\"SIGINT capturado!\");\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Reiniciar a predeterminado\nsignal(SIGINT, null);\n```\n\n**Firma del Manejador:**\n```hemlock\nfn handler(signum: i32) {\n    // signum contiene el numero de senal\n}\n```\n\n**Ver Tambien:**\n- [Constantes de senal](#constantes-de-senal)\n- `raise()`\n\n---\n\n### raise\n\nEnvia senal al proceso actual.\n\n**Firma:**\n```hemlock\nraise(signum: i32): null\n```\n\n**Parametros:**\n- `signum` - Numero de senal a lanzar\n\n**Retorna:** `null`\n\n**Ejemplos:**\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\nraise(SIGUSR1);\nraise(SIGUSR1);\nprint(count);  // 2\n```\n\n---\n\n## Variables Globales\n\n### args\n\nArray de argumentos de linea de comandos.\n\n**Tipo:** `array` de strings\n\n**Estructura:**\n- `args[0]` - Nombre del archivo de script\n- `args[1..n]` - Argumentos de linea de comandos\n\n**Ejemplos:**\n```bash\n# Comando: ./hemlock script.hml hello world\n```\n\n```hemlock\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // 3\nprint(args[1]);        // \"hello\"\nprint(args[2]);        // \"world\"\n\n// Iterar argumentos\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argumento\", i, \":\", args[i]);\n    i = i + 1;\n}\n```\n\n**Comportamiento en REPL:** En el REPL, `args.length` es 0 (array vacio)\n\n---\n\n## Constantes de Senal\n\nConstantes de senal POSIX estandar (valores i32):\n\n### Interrupcion y Terminacion\n\n| Constante  | Valor | Descripcion                            |\n|------------|-------|----------------------------------------|\n| `SIGINT`   | 2     | Interrupcion desde teclado (Ctrl+C)    |\n| `SIGTERM`  | 15    | Solicitud de terminacion               |\n| `SIGQUIT`  | 3     | Salir desde teclado (Ctrl+\\)           |\n| `SIGHUP`   | 1     | Colgado detectado en terminal controladora |\n| `SIGABRT`  | 6     | Senal de abortar                       |\n\n### Definidas por Usuario\n\n| Constante  | Valor | Descripcion                |\n|------------|-------|----------------------------|\n| `SIGUSR1`  | 10    | Senal definida por usuario 1 |\n| `SIGUSR2`  | 12    | Senal definida por usuario 2 |\n\n### Control de Proceso\n\n| Constante  | Valor | Descripcion                     |\n|------------|-------|---------------------------------|\n| `SIGALRM`  | 14    | Temporizador de alarma          |\n| `SIGCHLD`  | 17    | Cambio de estado de proceso hijo |\n| `SIGCONT`  | 18    | Continuar si esta detenido      |\n| `SIGSTOP`  | 19    | Detener proceso (no se puede capturar) |\n| `SIGTSTP`  | 20    | Parada de terminal (Ctrl+Z)     |\n\n### E/S\n\n| Constante  | Valor | Descripcion                        |\n|------------|-------|------------------------------------|\n| `SIGPIPE`  | 13    | Tuberia rota                       |\n| `SIGTTIN`  | 21    | Lectura de terminal en segundo plano |\n| `SIGTTOU`  | 22    | Escritura de terminal en segundo plano |\n\n**Ejemplos:**\n```hemlock\nfn handle_signal(sig) {\n    if (sig == SIGINT) {\n        print(\"Interrupcion detectada\");\n    }\n    if (sig == SIGTERM) {\n        print(\"Terminacion solicitada\");\n    }\n}\n\nsignal(SIGINT, handle_signal);\nsignal(SIGTERM, handle_signal);\n```\n\n**Nota:** `SIGKILL` (9) y `SIGSTOP` (19) no pueden capturarse ni ignorarse.\n\n---\n\n## Funciones Matematicas/Aritmeticas\n\n### div\n\nDivision entera que retorna un flotante.\n\n**Firma:**\n```hemlock\ndiv(a: number, b: number): f64\n```\n\n**Parametros:**\n- `a` - Dividendo\n- `b` - Divisor\n\n**Retorna:** Piso de `a / b` como flotante (f64)\n\n**Ejemplos:**\n```hemlock\nlet result = div(7, 2);    // 3.0 (no 3.5)\nlet result2 = div(10, 3);  // 3.0\nlet result3 = div(-7, 2);  // -4.0 (piso redondea hacia infinito negativo)\n```\n\n**Nota:** En Hemlock, el operador `/` siempre retorna un flotante. Use `div()` para division entera cuando necesite la parte entera como flotante, o `divi()` cuando necesite un resultado entero.\n\n---\n\n### divi\n\nDivision entera que retorna un entero.\n\n**Firma:**\n```hemlock\ndivi(a: number, b: number): i64\n```\n\n**Parametros:**\n- `a` - Dividendo\n- `b` - Divisor\n\n**Retorna:** Piso de `a / b` como entero (i64)\n\n**Ejemplos:**\n```hemlock\nlet result = divi(7, 2);    // 3\nlet result2 = divi(10, 3);  // 3\nlet result3 = divi(-7, 2);  // -4 (piso redondea hacia infinito negativo)\n```\n\n**Comparacion:**\n```hemlock\nprint(7 / 2);      // 3.5 (division regular, siempre flotante)\nprint(div(7, 2));  // 3.0 (division entera, resultado flotante)\nprint(divi(7, 2)); // 3   (division entera, resultado entero)\n```\n\n---\n\n## Funciones de Gestion de Memoria\n\nVea la [API de Memoria](#reference-memory-api) para referencia completa:\n- `alloc(size)` - Asignar memoria cruda\n- `free(ptr)` - Liberar memoria\n- `buffer(size)` - Asignar buffer seguro\n- `memset(ptr, byte, size)` - Llenar memoria\n- `memcpy(dest, src, size)` - Copiar memoria\n- `realloc(ptr, new_size)` - Redimensionar asignacion\n\n### sizeof\n\nObtiene el tamano de un tipo en bytes.\n\n**Firma:**\n```hemlock\nsizeof(type): i32\n```\n\n**Parametros:**\n- `type` - Una constante de tipo (`i32`, `f64`, `ptr`, etc.) o string de nombre de tipo\n\n**Retorna:** Tamano en bytes como `i32`\n\n**Ejemplos:**\n```hemlock\nprint(sizeof(i8));       // 1\nprint(sizeof(i16));      // 2\nprint(sizeof(i32));      // 4\nprint(sizeof(i64));      // 8\nprint(sizeof(f32));      // 4\nprint(sizeof(f64));      // 8\nprint(sizeof(ptr));      // 8\nprint(sizeof(rune));     // 4\n\n// Usando alias de tipo\nprint(sizeof(byte));     // 1 (igual que u8)\nprint(sizeof(integer));  // 4 (igual que i32)\nprint(sizeof(number));   // 8 (igual que f64)\n\n// Forma string tambien funciona\nprint(sizeof(\"i32\"));    // 4\n```\n\n**Tipos Soportados:**\n| Tipo | Tamano | Alias |\n|------|--------|-------|\n| `i8` | 1 | - |\n| `i16` | 2 | - |\n| `i32` | 4 | `integer` |\n| `i64` | 8 | - |\n| `u8` | 1 | `byte` |\n| `u16` | 2 | - |\n| `u32` | 4 | - |\n| `u64` | 8 | - |\n| `f32` | 4 | - |\n| `f64` | 8 | `number` |\n| `ptr` | 8 | - |\n| `rune` | 4 | - |\n| `bool` | 1 | - |\n\n**Ver Tambien:** `talloc()` para asignacion tipada\n\n---\n\n### talloc\n\nAsigna memoria para un array tipado (asignacion consciente del tipo).\n\n**Firma:**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**Parametros:**\n- `type` - Una constante de tipo (`i32`, `f64`, `ptr`, etc.)\n- `count` - Numero de elementos a asignar\n\n**Retorna:** `ptr` a memoria asignada, o `null` en fallo\n\n**Ejemplos:**\n```hemlock\n// Asignar array de 10 i32s (40 bytes)\nlet int_arr = talloc(i32, 10);\nptr_write_i32(int_arr, 42);\nptr_write_i32(ptr_offset(int_arr, 1, 4), 100);\n\n// Asignar array de 5 f64s (40 bytes)\nlet float_arr = talloc(f64, 5);\n\n// Asignar array de 100 bytes\nlet byte_arr = talloc(u8, 100);\n\n// No olvide liberar!\nfree(int_arr);\nfree(float_arr);\nfree(byte_arr);\n```\n\n**Comparacion con alloc:**\n```hemlock\n// Estos son equivalentes:\nlet p1 = talloc(i32, 10);      // Consciente del tipo: 10 i32s\nlet p2 = alloc(sizeof(i32) * 10);  // Calculo manual\n\n// talloc es mas claro y menos propenso a errores\n```\n\n**Manejo de Errores:**\n- Retorna `null` si la asignacion falla\n- Sale con error si count no es positivo\n- Verifica desbordamiento de tamano (count * tamano_elemento)\n\n**Ver Tambien:** `alloc()`, `sizeof()`, `free()`\n\n---\n\n## Ayudantes de Puntero FFI\n\nEstas funciones ayudan a leer y escribir valores tipados en memoria cruda, utiles para FFI y manipulacion de memoria de bajo nivel.\n\n### ptr_null\n\nCrea un puntero nulo.\n\n**Firma:**\n```hemlock\nptr_null(): ptr\n```\n\n**Retorna:** Un puntero nulo\n\n**Ejemplo:**\n```hemlock\nlet p = ptr_null();\nif (p == null) {\n    print(\"El puntero es nulo\");\n}\n```\n\n---\n\n### ptr_offset\n\nCalcula desplazamiento de puntero (aritmetica de punteros).\n\n**Firma:**\n```hemlock\nptr_offset(ptr: ptr, index: i32, element_size: i32): ptr\n```\n\n**Parametros:**\n- `ptr` - Puntero base\n- `index` - Indice del elemento\n- `element_size` - Tamano de cada elemento en bytes\n\n**Retorna:** Puntero al elemento en el indice dado\n\n**Ejemplo:**\n```hemlock\nlet arr = talloc(i32, 10);\nptr_write_i32(arr, 100);                      // arr[0] = 100\nptr_write_i32(ptr_offset(arr, 1, 4), 200);    // arr[1] = 200\nptr_write_i32(ptr_offset(arr, 2, 4), 300);    // arr[2] = 300\n\nprint(ptr_read_i32(ptr_offset(arr, 1, 4)));   // 200\nfree(arr);\n```\n\n---\n\n### Funciones de Lectura de Puntero\n\nLee valores tipados desde memoria.\n\n| Funcion | Firma | Retorna | Descripcion |\n|---------|-------|---------|-------------|\n| `ptr_read_i8` | `(ptr)` | `i8` | Lee entero con signo de 8 bits |\n| `ptr_read_i16` | `(ptr)` | `i16` | Lee entero con signo de 16 bits |\n| `ptr_read_i32` | `(ptr)` | `i32` | Lee entero con signo de 32 bits |\n| `ptr_read_i64` | `(ptr)` | `i64` | Lee entero con signo de 64 bits |\n| `ptr_read_u8` | `(ptr)` | `u8` | Lee entero sin signo de 8 bits |\n| `ptr_read_u16` | `(ptr)` | `u16` | Lee entero sin signo de 16 bits |\n| `ptr_read_u32` | `(ptr)` | `u32` | Lee entero sin signo de 32 bits |\n| `ptr_read_u64` | `(ptr)` | `u64` | Lee entero sin signo de 64 bits |\n| `ptr_read_f32` | `(ptr)` | `f32` | Lee flotante de 32 bits |\n| `ptr_read_f64` | `(ptr)` | `f64` | Lee flotante de 64 bits |\n| `ptr_read_ptr` | `(ptr)` | `ptr` | Lee valor de puntero |\n\n**Ejemplo:**\n```hemlock\nlet p = alloc(8);\nptr_write_f64(p, 3.14159);\nlet value = ptr_read_f64(p);\nprint(value);  // 3.14159\nfree(p);\n```\n\n---\n\n### Funciones de Escritura de Puntero\n\nEscribe valores tipados a memoria.\n\n| Funcion | Firma | Retorna | Descripcion |\n|---------|-------|---------|-------------|\n| `ptr_write_i8` | `(ptr, value)` | `null` | Escribe entero con signo de 8 bits |\n| `ptr_write_i16` | `(ptr, value)` | `null` | Escribe entero con signo de 16 bits |\n| `ptr_write_i32` | `(ptr, value)` | `null` | Escribe entero con signo de 32 bits |\n| `ptr_write_i64` | `(ptr, value)` | `null` | Escribe entero con signo de 64 bits |\n| `ptr_write_u8` | `(ptr, value)` | `null` | Escribe entero sin signo de 8 bits |\n| `ptr_write_u16` | `(ptr, value)` | `null` | Escribe entero sin signo de 16 bits |\n| `ptr_write_u32` | `(ptr, value)` | `null` | Escribe entero sin signo de 32 bits |\n| `ptr_write_u64` | `(ptr, value)` | `null` | Escribe entero sin signo de 64 bits |\n| `ptr_write_f32` | `(ptr, value)` | `null` | Escribe flotante de 32 bits |\n| `ptr_write_f64` | `(ptr, value)` | `null` | Escribe flotante de 64 bits |\n| `ptr_write_ptr` | `(ptr, value)` | `null` | Escribe valor de puntero |\n\n**Ejemplo:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\nprint(ptr_read_i32(p));  // 42\nfree(p);\n```\n\n---\n\n### Conversion Buffer/Puntero\n\n#### buffer_ptr\n\nObtiene puntero crudo desde un buffer.\n\n**Firma:**\n```hemlock\nbuffer_ptr(buf: buffer): ptr\n```\n\n**Ejemplo:**\n```hemlock\nlet buf = buffer(64);\nlet p = buffer_ptr(buf);\n// Ahora p apunta a la misma memoria que buf\n```\n\n#### ptr_to_buffer\n\nCrea un envoltorio de buffer alrededor de un puntero crudo.\n\n**Firma:**\n```hemlock\nptr_to_buffer(ptr: ptr, size: i32): buffer\n```\n\n**Ejemplo:**\n```hemlock\nlet p = alloc(64);\nlet buf = ptr_to_buffer(p, 64);\nbuf[0] = 65;  // Ahora tiene verificacion de limites\n// Nota: liberar buf liberara la memoria subyacente\n```\n\n---\n\n## Funciones de E/S de Archivos\n\nVea la [API de Archivos](#reference-file-api) para referencia completa:\n- `open(path, mode?)` - Abrir archivo\n\n---\n\n## Funciones de Concurrencia\n\nVea la [API de Concurrencia](#reference-concurrency-api) para referencia completa:\n- `spawn(fn, args...)` - Generar tarea\n- `join(task)` - Esperar tarea\n- `detach(task)` - Desvincular tarea\n- `channel(capacity)` - Crear canal\n\n### apply\n\nLlama una funcion dinamicamente con un array de argumentos.\n\n**Firma:**\n```hemlock\napply(fn: function, args: array): any\n```\n\n**Parametros:**\n- `fn` - La funcion a llamar\n- `args` - Array de argumentos a pasar a la funcion\n\n**Retorna:** El valor de retorno de la funcion llamada\n\n**Ejemplos:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\n// Llamar con array de argumentos\nlet result = apply(add, [2, 3]);\nprint(result);  // 5\n\n// Despacho dinamico\nlet operations = {\n    add: fn(a, b) { return a + b; },\n    mul: fn(a, b) { return a * b; },\n    sub: fn(a, b) { return a - b; }\n};\n\nfn calculate(op: string, args: array) {\n    return apply(operations[op], args);\n}\n\nprint(calculate(\"add\", [10, 5]));  // 15\nprint(calculate(\"mul\", [10, 5]));  // 50\nprint(calculate(\"sub\", [10, 5]));  // 5\n\n// Argumentos variables\nfn sum(...nums) {\n    let total = 0;\n    for (n in nums) {\n        total = total + n;\n    }\n    return total;\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(apply(sum, numbers));  // 15\n```\n\n**Casos de Uso:**\n- Despacho dinamico de funciones basado en valores en tiempo de ejecucion\n- Llamar funciones con listas de argumentos variables\n- Implementar utilidades de orden superior (map, filter, etc.)\n- Sistemas de plugins/extensiones\n\n---\n\n### select\n\nEspera datos de multiples canales, retornando cuando alguno tenga datos.\n\n**Firma:**\n```hemlock\nselect(channels: array, timeout_ms?: i32): object | null\n```\n\n**Parametros:**\n- `channels` - Array de valores de canal\n- `timeout_ms` (opcional) - Timeout en milisegundos (-1 u omitir para infinito)\n\n**Retorna:**\n- `{ channel, value }` - Objeto con el canal que tenia datos y el valor recibido\n- `null` - En timeout\n\n**Ejemplos:**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// Tareas productoras\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"desde canal 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"desde canal 2\");\n});\n\n// Esperar primer mensaje\nlet result = select([ch1, ch2]);\nprint(result.value);  // \"desde canal 2\" (llego primero)\n\n// Con timeout\nlet result2 = select([ch1, ch2], 1000);  // Esperar hasta 1 segundo\nif (result2 == null) {\n    print(\"Timeout - no se recibieron datos\");\n} else {\n    print(\"Recibido:\", result2.value);\n}\n\n// Bucle select continuo\nwhile (true) {\n    let msg = select([ch1, ch2], 5000);\n    if (msg == null) {\n        print(\"Sin actividad por 5 segundos\");\n        break;\n    }\n    print(\"Mensaje recibido:\", msg.value);\n}\n```\n\n**Comportamiento:**\n- Bloquea hasta que un canal tenga datos o expire el timeout\n- Retorna inmediatamente si un canal ya tiene datos\n- Si el canal esta cerrado y vacio, retorna `{ channel, value: null }`\n- Sondea canales en orden (el primer canal listo gana)\n\n**Casos de Uso:**\n- Multiplexar multiples productores\n- Implementar timeouts en operaciones de canal\n- Construir bucles de eventos con multiples fuentes\n\n---\n\n## Tabla Resumen\n\n### Funciones\n\n| Funcion    | Categoria       | Retorna      | Descripcion                     |\n|------------|-----------------|--------------|----------------------------------|\n| `print`    | E/S             | `null`       | Imprimir a stdout               |\n| `read_line`| E/S             | `string?`    | Leer linea desde stdin          |\n| `eprint`   | E/S             | `null`       | Imprimir a stderr               |\n| `typeof`   | Tipo            | `string`     | Obtener nombre de tipo          |\n| `exec`     | Comando         | `object`     | Ejecutar comando de shell       |\n| `exec_argv`| Comando         | `object`     | Ejecutar con array de argumentos |\n| `assert`   | Error           | `null`       | Afirmar condicion o salir       |\n| `panic`    | Error           | `never`      | Error irrecuperable (sale)      |\n| `signal`   | Senal           | `function?`  | Registrar manejador de senal    |\n| `raise`    | Senal           | `null`       | Enviar senal al proceso         |\n| `alloc`    | Memoria         | `ptr`        | Asignar memoria cruda           |\n| `talloc`   | Memoria         | `ptr`        | Asignacion tipada               |\n| `sizeof`   | Memoria         | `i32`        | Obtener tamano de tipo en bytes |\n| `free`     | Memoria         | `null`       | Liberar memoria                 |\n| `buffer`   | Memoria         | `buffer`     | Asignar buffer seguro           |\n| `memset`   | Memoria         | `null`       | Llenar memoria                  |\n| `memcpy`   | Memoria         | `null`       | Copiar memoria                  |\n| `realloc`  | Memoria         | `ptr`        | Redimensionar asignacion        |\n| `open`     | E/S Archivo     | `file`       | Abrir archivo                   |\n| `spawn`    | Concurrencia    | `task`       | Generar tarea concurrente       |\n| `join`     | Concurrencia    | `any`        | Esperar resultado de tarea      |\n| `detach`   | Concurrencia    | `null`       | Desvincular tarea               |\n| `channel`  | Concurrencia    | `channel`    | Crear canal de comunicacion     |\n| `select`   | Concurrencia    | `object?`    | Esperar en multiples canales    |\n| `apply`    | Funciones       | `any`        | Llamar funcion con array de args |\n\n### Variables Globales\n\n| Variable   | Tipo     | Descripcion                       |\n|------------|----------|-----------------------------------|\n| `args`     | `array`  | Argumentos de linea de comandos   |\n\n### Constantes\n\n| Constante  | Tipo  | Categoria | Valor | Descripcion               |\n|------------|-------|----------|-------|---------------------------|\n| `SIGINT`   | `i32` | Senal    | 2     | Interrupcion de teclado   |\n| `SIGTERM`  | `i32` | Senal    | 15    | Solicitud de terminacion  |\n| `SIGQUIT`  | `i32` | Senal    | 3     | Salir de teclado          |\n| `SIGHUP`   | `i32` | Senal    | 1     | Colgado                   |\n| `SIGABRT`  | `i32` | Senal    | 6     | Abortar                   |\n| `SIGUSR1`  | `i32` | Senal    | 10    | Definida por usuario 1    |\n| `SIGUSR2`  | `i32` | Senal    | 12    | Definida por usuario 2    |\n| `SIGALRM`  | `i32` | Senal    | 14    | Temporizador de alarma    |\n| `SIGCHLD`  | `i32` | Senal    | 17    | Cambio de estado de hijo  |\n| `SIGCONT`  | `i32` | Senal    | 18    | Continuar                 |\n| `SIGSTOP`  | `i32` | Senal    | 19    | Parar (no capturable)     |\n| `SIGTSTP`  | `i32` | Senal    | 20    | Parada de terminal        |\n| `SIGPIPE`  | `i32` | Senal    | 13    | Tuberia rota              |\n| `SIGTTIN`  | `i32` | Senal    | 21    | Lectura terminal segundo plano |\n| `SIGTTOU`  | `i32` | Senal    | 22    | Escritura terminal segundo plano |\n\n---\n\n## Ver Tambien\n\n- [Sistema de Tipos](#reference-type-system) - Tipos y conversiones\n- [API de Memoria](#reference-memory-api) - Funciones de asignacion de memoria\n- [API de Archivos](#reference-file-api) - Funciones de E/S de archivos\n- [API de Concurrencia](#reference-concurrency-api) - Funciones async/concurrencia\n- [API de Strings](#reference-string-api) - Metodos de string\n- [API de Arrays](#reference-array-api) - Metodos de array\n"}, "Referencia de API -> Operadores": {"id": "reference-operators", "content": "# Referencia de Operadores\n\nReferencia completa para todos los operadores en Hemlock, incluyendo precedencia, asociatividad y comportamiento.\n\n---\n\n## Descripcion General\n\nHemlock proporciona operadores estilo C con reglas de precedencia explicitas. Todos los operadores siguen reglas de tipado estrictas con promocion automatica de tipos donde sea aplicable.\n\n---\n\n## Operadores Aritmeticos\n\n### Aritmeticos Binarios\n\n| Operador | Nombre         | Ejemplo    | Descripcion                  |\n|----------|----------------|------------|------------------------------|\n| `+`      | Suma           | `a + b`    | Sumar dos valores            |\n| `-`      | Resta          | `a - b`    | Restar b de a                |\n| `*`      | Multiplicacion | `a * b`    | Multiplicar dos valores      |\n| `/`      | Division       | `a / b`    | Dividir a entre b            |\n\n**Promocion de Tipos:**\nLos resultados siguen reglas de promocion de tipos (vea [Sistema de Tipos](type-system.md#reglas-de-promocion-de-tipos)).\n\n**Ejemplos:**\n```hemlock\nlet a = 10 + 5;        // 15 (i32)\nlet b = 10 - 3;        // 7 (i32)\nlet c = 4 * 5;         // 20 (i32)\nlet d = 20 / 4;        // 5 (i32)\n\n// Division flotante\nlet e = 10.0 / 3.0;    // 3.333... (f64)\n\n// Tipos mixtos\nlet f: u8 = 10;\nlet g: i32 = 20;\nlet h = f + g;         // 30 (i32, promocionado)\n```\n\n**Division por Cero:**\n- Division entera por cero: Error en tiempo de ejecucion\n- Division flotante por cero: Retorna `inf` o `-inf`\n\n---\n\n### Aritmeticos Unarios\n\n| Operador | Nombre   | Ejemplo | Descripcion          |\n|----------|----------|---------|----------------------|\n| `-`      | Negacion | `-a`    | Negar valor          |\n| `+`      | Mas      | `+a`    | Identidad (sin efecto) |\n\n**Ejemplos:**\n```hemlock\nlet a = 5;\nlet b = -a;            // -5\nlet c = +a;            // 5 (sin cambio)\n\nlet x = -3.14;         // -3.14\n```\n\n---\n\n## Operadores de Comparacion\n\n| Operador | Nombre                | Ejemplo    | Retorna |\n|----------|-----------------------|------------|---------|\n| `==`     | Igual                 | `a == b`   | `bool`  |\n| `!=`     | No igual              | `a != b`   | `bool`  |\n| `<`      | Menor que             | `a < b`    | `bool`  |\n| `>`      | Mayor que             | `a > b`    | `bool`  |\n| `<=`     | Menor o igual que     | `a <= b`   | `bool`  |\n| `>=`     | Mayor o igual que     | `a >= b`   | `bool`  |\n\n**Promocion de Tipos:**\nLos operandos se promocionan antes de la comparacion.\n\n**Ejemplos:**\n```hemlock\nprint(5 == 5);         // true\nprint(10 != 5);        // true\nprint(3 < 7);          // true\nprint(10 > 5);         // true\nprint(5 <= 5);         // true\nprint(10 >= 5);        // true\n\n// Comparacion de strings\nprint(\"hello\" == \"hello\");  // true\nprint(\"abc\" < \"def\");       // true (lexicografico)\n\n// Tipos mixtos\nlet a: u8 = 10;\nlet b: i32 = 10;\nprint(a == b);         // true (promocionado a i32)\n```\n\n---\n\n## Operadores Logicos\n\n| Operador | Nombre      | Ejemplo      | Descripcion              |\n|----------|-------------|--------------|--------------------------|\n| `&&`     | AND Logico  | `a && b`     | Verdadero si ambos son verdaderos |\n| `||`     | OR Logico   | `a || b`     | Verdadero si alguno es verdadero |\n| `!`      | NOT Logico  | `!a`         | Negar booleano           |\n\n**Evaluacion de Cortocircuito:**\n- `&&` - Se detiene en el primer valor falso\n- `||` - Se detiene en el primer valor verdadero\n\n**Ejemplos:**\n```hemlock\nlet a = true;\nlet b = false;\n\nprint(a && b);         // false\nprint(a || b);         // true\nprint(!a);             // false\nprint(!b);             // true\n\n// Cortocircuito\nif (x != 0 && (10 / x) > 2) {\n    print(\"seguro\");\n}\n\nif (x == 0 || (10 / x) > 2) {\n    print(\"seguro\");\n}\n```\n\n---\n\n## Operadores de Bits\n\n**Restriccion:** Solo tipos enteros (i8-i64, u8-u64)\n\n### Binarios de Bits\n\n| Operador | Nombre           | Ejemplo    | Descripcion              |\n|----------|------------------|------------|--------------------------|\n| `&`      | AND de Bits      | `a & b`    | AND cada bit             |\n| `|`      | OR de Bits       | `a | b`    | OR cada bit              |\n| `^`      | XOR de Bits      | `a ^ b`    | XOR cada bit             |\n| `<<`     | Desplazamiento izq | `a << b` | Desplazar izquierda b bits |\n| `>>`     | Desplazamiento der | `a >> b` | Desplazar derecha b bits |\n\n**Preservacion de Tipo:**\nEl tipo del resultado coincide con los tipos de operandos (con promocion de tipos).\n\n**Ejemplos:**\n```hemlock\nlet a = 12;  // 1100 en binario\nlet b = 10;  // 1010 en binario\n\nprint(a & b);          // 8  (1000)\nprint(a | b);          // 14 (1110)\nprint(a ^ b);          // 6  (0110)\nprint(a << 2);         // 48 (110000)\nprint(a >> 1);         // 6  (110)\n```\n\n**Ejemplo Sin Signo:**\n```hemlock\nlet c: u8 = 15;        // 00001111\nlet d: u8 = 7;         // 00000111\n\nprint(c & d);          // 7  (00000111)\nprint(c | d);          // 15 (00001111)\nprint(c ^ d);          // 8  (00001000)\n```\n\n**Comportamiento de Desplazamiento Derecho:**\n- Tipos con signo: Desplazamiento aritmetico (extiende signo)\n- Tipos sin signo: Desplazamiento logico (llena con ceros)\n\n---\n\n### Unarios de Bits\n\n| Operador | Nombre        | Ejemplo | Descripcion              |\n|----------|---------------|---------|--------------------------|\n| `~`      | NOT de Bits   | `~a`    | Invertir todos los bits  |\n\n**Ejemplos:**\n```hemlock\nlet a = 12;            // 00001100 (i32)\nprint(~a);             // -13 (complemento a dos)\n\nlet b: u8 = 15;        // 00001111\nprint(~b);             // 240 (11110000)\n```\n\n---\n\n## Operadores de String\n\n### Concatenacion\n\n| Operador | Nombre         | Ejemplo    | Descripcion        |\n|----------|----------------|------------|--------------------|\n| `+`      | Concatenacion  | `a + b`    | Unir strings       |\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n\n// String + rune\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\n\n// Rune + string\nlet prefix = '>' + \" Message\";     // \"> Message\"\n```\n\n---\n\n## Operadores de Asignacion\n\n### Asignacion Basica\n\n| Operador | Nombre     | Ejemplo    | Descripcion              |\n|----------|------------|------------|--------------------------|\n| `=`      | Asignacion | `a = b`    | Asignar valor a variable |\n\n**Ejemplos:**\n```hemlock\nlet x = 10;\nx = 20;\n\nlet arr = [1, 2, 3];\narr[0] = 99;\n\nlet obj = { x: 10 };\nobj.x = 20;\n```\n\n### Asignacion Compuesta\n\n#### Asignacion Compuesta Aritmetica\n\n| Operador | Nombre            | Ejemplo    | Equivalente         |\n|----------|-------------------|------------|---------------------|\n| `+=`     | Asignar suma      | `a += b`   | `a = a + b`        |\n| `-=`     | Asignar resta     | `a -= b`   | `a = a - b`        |\n| `*=`     | Asignar mult      | `a *= b`   | `a = a * b`        |\n| `/=`     | Asignar div       | `a /= b`   | `a = a / b`        |\n| `%=`     | Asignar modulo    | `a %= b`   | `a = a % b`        |\n\n**Ejemplos:**\n```hemlock\nlet x = 10;\nx += 5;      // x ahora es 15\nx -= 3;      // x ahora es 12\nx *= 2;      // x ahora es 24\nx /= 4;      // x ahora es 6\n\nlet count = 0;\ncount += 1;  // Incrementar por 1\n```\n\n#### Asignacion Compuesta de Bits\n\n| Operador | Nombre                 | Ejemplo     | Equivalente          |\n|----------|------------------------|-------------|----------------------|\n| `&=`     | Asignar AND de bits    | `a &= b`    | `a = a & b`         |\n| `\\|=`   | Asignar OR de bits     | `a \\|= b`   | `a = a \\| b`        |\n| `^=`     | Asignar XOR de bits    | `a ^= b`    | `a = a ^ b`         |\n| `<<=`    | Asignar desp izq       | `a <<= b`   | `a = a << b`        |\n| `>>=`    | Asignar desp der       | `a >>= b`   | `a = a >> b`        |\n\n**Ejemplos:**\n```hemlock\nlet flags = 0b1111;\nflags &= 0b0011;   // flags ahora es 0b0011 (enmascarar bits superiores)\nflags |= 0b1000;   // flags ahora es 0b1011 (establecer un bit)\nflags ^= 0b0001;   // flags ahora es 0b1010 (alternar un bit)\n\nlet x = 1;\nx <<= 4;           // x ahora es 16 (desplazar izquierda por 4)\nx >>= 2;           // x ahora es 4 (desplazar derecha por 2)\n```\n\n### Incremento/Decremento\n\n| Operador | Nombre     | Ejemplo | Descripcion              |\n|----------|------------|---------|--------------------------|\n| `++`     | Incremento | `a++`   | Incrementar por 1 (postfijo) |\n| `--`     | Decremento | `a--`   | Decrementar por 1 (postfijo) |\n\n**Ejemplos:**\n```hemlock\nlet i = 0;\ni++;         // i ahora es 1\ni++;         // i ahora es 2\ni--;         // i ahora es 1\n\n// Comun en bucles\nfor (let j = 0; j < 10; j++) {\n    print(j);\n}\n```\n\n**Nota:** Tanto `++` como `--` son operadores postfijos (el valor se retorna antes del incremento/decremento)\n\n---\n\n## Operadores de Seguridad Null\n\n### Coalescencia Null (`??`)\n\nRetorna el operando izquierdo si no es null, de lo contrario retorna el operando derecho.\n\n| Operador | Nombre            | Ejemplo      | Descripcion                    |\n|----------|-------------------|--------------|--------------------------------|\n| `??`     | Coalescencia null | `a ?? b`     | Retornar a si no es null, sino b |\n\n**Ejemplos:**\n```hemlock\nlet name = null;\nlet display = name ?? \"Anonimo\";  // \"Anonimo\"\n\nlet value = 42;\nlet result = value ?? 0;            // 42\n\n// Encadenamiento\nlet a = null;\nlet b = null;\nlet c = \"encontrado\";\nlet result2 = a ?? b ?? c;          // \"encontrado\"\n\n// Con llamadas a funcion\nfn get_config() { return null; }\nlet config = get_config() ?? { default: true };\n```\n\n---\n\n### Encadenamiento Opcional (`?.`)\n\nAccede a propiedades o llama metodos de forma segura en valores potencialmente null.\n\n| Operador | Nombre               | Ejemplo        | Descripcion                      |\n|----------|----------------------|----------------|----------------------------------|\n| `?.`     | Encadenamiento opcional | `a?.b`      | Retornar a.b si a no es null, sino null |\n| `?.[`    | Indice opcional      | `a?.[0]`       | Retornar a[0] si a no es null, sino null |\n| `?.(`    | Llamada opcional     | `a?.()`        | Llamar a() si a no es null, sino null |\n\n**Ejemplos:**\n```hemlock\nlet user = null;\nlet name = user?.name;              // null (sin error)\n\nlet person = { name: \"Alice\", address: null };\nlet city = person?.address?.city;   // null (navegacion segura)\n\n// Con arrays\nlet arr = null;\nlet first = arr?.[0];               // null\n\nlet items = [1, 2, 3];\nlet second = items?.[1];            // 2\n\n// Con llamadas a metodos\nlet obj = { greet: fn() { return \"Hola\"; } };\nlet greeting = obj?.greet?.();      // \"Hola\"\n\nlet empty = null;\nlet result = empty?.method?.();     // null\n```\n\n**Comportamiento:**\n- Si el operando izquierdo es null, toda la expresion cortocircuita a null\n- Si el operando izquierdo no es null, el acceso procede normalmente\n- Puede encadenarse para acceso profundo a propiedades\n\n---\n\n## Operadores de Acceso a Miembros\n\n### Operador Punto\n\n| Operador | Nombre              | Ejemplo      | Descripcion           |\n|----------|---------------------|--------------|-----------------------|\n| `.`      | Acceso a miembro    | `obj.field`  | Acceder campo de objeto |\n| `.`      | Acceso a propiedad  | `arr.length` | Acceder propiedad     |\n\n**Ejemplos:**\n```hemlock\n// Acceso a campo de objeto\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);        // \"Alice\"\n\n// Propiedad de array\nlet arr = [1, 2, 3];\nprint(arr.length);         // 3\n\n// Propiedad de string\nlet s = \"hello\";\nprint(s.length);           // 5\n\n// Llamada a metodo\nlet result = s.to_upper(); // \"HELLO\"\n```\n\n---\n\n### Operador de Indice\n\n| Operador | Nombre  | Ejemplo   | Descripcion          |\n|----------|---------|-----------|----------------------|\n| `[]`     | Indice  | `arr[i]`  | Acceder elemento     |\n\n**Ejemplos:**\n```hemlock\n// Indexacion de array\nlet arr = [10, 20, 30];\nprint(arr[0]);             // 10\narr[1] = 99;\n\n// Indexacion de string (retorna rune)\nlet s = \"hello\";\nprint(s[0]);               // 'h'\ns[0] = 'H';                // \"Hello\"\n\n// Indexacion de buffer\nlet buf = buffer(10);\nbuf[0] = 65;\nprint(buf[0]);             // 65\n```\n\n---\n\n## Operador de Llamada a Funcion\n\n| Operador | Nombre           | Ejemplo      | Descripcion        |\n|----------|------------------|--------------|--------------------|\n| `()`     | Llamada a funcion | `f(a, b)`   | Llamar funcion     |\n\n**Ejemplos:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet result = add(5, 3);    // 8\n\n// Llamada a metodo\nlet s = \"hello\";\nlet upper = s.to_upper();  // \"HELLO\"\n\n// Llamada integrada\nprint(\"mensaje\");\n```\n\n---\n\n## Precedencia de Operadores\n\nLos operadores se listan de mayor a menor precedencia:\n\n| Precedencia | Operadores                  | Descripcion                    | Asociatividad |\n|-------------|----------------------------|--------------------------------|---------------|\n| 1          | `()` `[]` `.` `?.`         | Llamada, indice, acceso miembro, encadenamiento opcional | Izq-a-der |\n| 2          | `++` `--`                  | Incremento/decremento postfijo | Izq-a-der |\n| 3          | `!` `~` `-` (unario) `+` (unario) | NOT logico, NOT de bits, negacion | Der-a-izq |\n| 4          | `*` `/` `%`                | Multiplicacion, division, modulo | Izq-a-der |\n| 5          | `+` `-`                    | Suma, resta          | Izq-a-der |\n| 6          | `<<` `>>`                  | Desplazamientos de bits        | Izq-a-der |\n| 7          | `<` `<=` `>` `>=`          | Relacionales                   | Izq-a-der |\n| 8          | `==` `!=`                  | Igualdad                       | Izq-a-der |\n| 9          | `&`                        | AND de bits                    | Izq-a-der |\n| 10         | `^`                        | XOR de bits                    | Izq-a-der |\n| 11         | `|`                        | OR de bits                     | Izq-a-der |\n| 12         | `&&`                       | AND logico                     | Izq-a-der |\n| 13         | `||`                       | OR logico                      | Izq-a-der |\n| 14         | `??`                       | Coalescencia null              | Izq-a-der |\n| 15         | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\\|=` `^=` `<<=` `>>=` | Asignacion | Der-a-izq |\n\n---\n\n## Ejemplos de Precedencia\n\n### Ejemplo 1: Aritmetica y Comparacion\n```hemlock\nlet result = 5 + 3 * 2;\n// Evaluado como: 5 + (3 * 2) = 11\n// Multiplicacion tiene mayor precedencia que suma\n\nlet cmp = 10 > 5 + 3;\n// Evaluado como: 10 > (5 + 3) = true\n// Suma tiene mayor precedencia que comparacion\n```\n\n### Ejemplo 2: Operadores de Bits\n```hemlock\nlet result1 = 12 | 10 & 8;\n// Evaluado como: 12 | (10 & 8) = 12 | 8 = 12\n// & tiene mayor precedencia que |\n\nlet result2 = 8 | 1 << 2;\n// Evaluado como: 8 | (1 << 2) = 8 | 4 = 12\n// Desplazamiento tiene mayor precedencia que OR de bits\n\n// Use parentesis para claridad\nlet result3 = (5 & 3) | (2 << 1);\n// Evaluado como: 1 | 4 = 5\n```\n\n### Ejemplo 3: Operadores Logicos\n```hemlock\nlet result = true || false && false;\n// Evaluado como: true || (false && false) = true\n// && tiene mayor precedencia que ||\n\nlet cmp = 5 < 10 && 10 < 20;\n// Evaluado como: (5 < 10) && (10 < 20) = true\n// Comparacion tiene mayor precedencia que &&\n```\n\n### Ejemplo 4: Usando Parentesis\n```hemlock\n// Sin parentesis\nlet a = 2 + 3 * 4;        // 14\n\n// Con parentesis\nlet b = (2 + 3) * 4;      // 20\n\n// Expresion compleja\nlet c = (a + b) * (a - b);\n```\n\n---\n\n## Comportamiento de Operadores Especifico por Tipo\n\n### Division (Siempre Flotante)\n\nEl operador `/` **siempre retorna un flotante** (f64), independientemente de los tipos de operandos:\n\n```hemlock\nprint(10 / 3);             // 3.333... (f64)\nprint(5 / 2);              // 2.5 (f64)\nprint(10.0 / 4.0);         // 2.5 (f64)\nprint(-7 / 3);             // -2.333... (f64)\n```\n\nEsto previene el bug comun de truncamiento entero inesperado.\n\n### Division Entera (div / divi)\n\nPara division entera (como division de enteros en otros lenguajes), use las funciones `div()` y `divi()`:\n\n```hemlock\n// div(a, b) - division entera retornando flotante\nprint(div(5, 2));          // 2 (f64)\nprint(div(-7, 3));         // -3 (f64)  -- piso hacia -infinito\n\n// divi(a, b) - division entera retornando entero\nprint(divi(5, 2));         // 2 (i64)\nprint(divi(-7, 3));        // -3 (i64)\nprint(typeof(divi(5, 2))); // i64\n```\n\n**Funciones matematicas que retornan enteros:**\nPara otras operaciones de redondeo que retornan enteros:\n\n```hemlock\nprint(floori(3.7));        // 3 (i64)\nprint(ceili(3.2));         // 4 (i64)\nprint(roundi(3.5));        // 4 (i64)\nprint(trunci(3.9));        // 3 (i64)\n\n// Estos pueden usarse directamente como indices de array\nlet arr = [10, 20, 30, 40];\nprint(arr[floori(1.9)]);   // 20 (indice 1)\n```\n\n### Comparacion de Strings\n\nLos strings se comparan lexicograficamente:\n\n```hemlock\nprint(\"abc\" < \"def\");      // true\nprint(\"apple\" > \"banana\"); // false\nprint(\"hello\" == \"hello\"); // true\n```\n\n### Comparacion con Null\n\n```hemlock\nlet x = null;\n\nprint(x == null);          // true\nprint(x != null);          // false\n```\n\n### Errores de Tipo\n\nAlgunas operaciones no estan permitidas entre tipos incompatibles:\n\n```hemlock\n// ERROR: No se pueden usar operadores de bits en flotantes\nlet x = 3.14 & 2.71;\n\n// ERROR: No se pueden usar operadores de bits en strings\nlet y = \"hello\" & \"world\";\n\n// OK: Promocion de tipo para aritmetica\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet c = a + b;             // i32 (promocionado)\n```\n\n---\n\n## Ver Tambien\n\n- [Sistema de Tipos](#reference-type-system) - Reglas de promocion y conversion de tipos\n- [Funciones Integradas](#reference-builtins) - Operaciones integradas\n- [API de Strings](#reference-string-api) - Concatenacion y metodos de strings\n"}, "Referencia de API -> Sistema de Tipos": {"id": "reference-type-system", "content": "# Referencia del Sistema de Tipos\n\nReferencia completa para el sistema de tipos de Hemlock, incluyendo todos los tipos primitivos y compuestos.\n\n---\n\n## Descripcion General\n\nHemlock usa un **sistema de tipos dinamico** con etiquetas de tipo en tiempo de ejecucion y anotaciones de tipo opcionales. Cada valor tiene un tipo en tiempo de ejecucion, y las conversiones de tipo siguen reglas de promocion explicitas.\n\n**Caracteristicas Principales:**\n- Verificacion de tipos en tiempo de ejecucion (interprete)\n- Verificacion de tipos en tiempo de compilacion (hemlockc - habilitado por defecto)\n- Anotaciones de tipo opcionales\n- Inferencia de tipos automatica para literales\n- Reglas de promocion de tipos explicitas\n- Sin conversiones implicitas que pierdan precision\n\n---\n\n## Verificacion de Tipos en Tiempo de Compilacion (hemlockc)\n\nEl compilador de Hemlock (`hemlockc`) incluye un verificador de tipos en tiempo de compilacion que valida su codigo antes de generar ejecutables. Esto captura errores de tipo tempranamente sin necesidad de ejecutar el programa.\n\n### Comportamiento por Defecto\n\nLa verificacion de tipos esta **habilitada por defecto** en hemlockc:\n\n```bash\n# La verificacion de tipos ocurre automaticamente\nhemlockc program.hml -o program\n\n# Los errores se reportan antes de la compilacion\nhemlockc bad_types.hml\n# Salida: 1 type error found\n```\n\n### Banderas del Compilador\n\n| Bandera | Descripcion |\n|---------|-------------|\n| `--check` | Solo verificar tipos, no compilar (salir despues de validacion) |\n| `--no-type-check` | Deshabilitar verificacion de tipos (no recomendado) |\n| `--strict-types` | Habilitar advertencias de tipos mas estrictas |\n\n**Ejemplos:**\n\n```bash\n# Solo validar tipos sin compilar\nhemlockc --check program.hml\n# Salida: program.hml: no type errors\n\n# Deshabilitar verificacion de tipos (usar con precaucion)\nhemlockc --no-type-check dynamic_code.hml -o program\n\n# Habilitar advertencias estrictas para tipos any implicitos\nhemlockc --strict-types program.hml -o program\n```\n\n### Que Valida el Verificador de Tipos\n\n1. **Anotaciones de tipo** - Asegura que los valores asignados coincidan con los tipos declarados\n2. **Llamadas a funciones** - Valida tipos de argumentos contra tipos de parametros\n3. **Tipos de retorno** - Verifica que las sentencias return coincidan con el tipo de retorno declarado\n4. **Uso de operadores** - Verifica que los operandos sean compatibles\n5. **Acceso a propiedades** - Valida tipos de campos de objetos para objetos tipados\n\n### Conversiones Numericas Permisivas\n\nEl verificador de tipos permite conversiones de tipos numericos en tiempo de compilacion, con validacion de rango ocurriendo en tiempo de ejecucion:\n\n```hemlock\nlet x: i8 = 100;      // OK - 100 cabe en i8 (validado en tiempo de ejecucion)\nlet y: u8 = 255;      // OK - dentro del rango de u8\nlet z: f64 = 42;      // OK - i32 a f64 es seguro\n```\n\n### Soporte de Codigo Dinamico\n\nEl codigo sin anotaciones de tipo se trata como dinamico (tipo `any`) y siempre pasa el verificador de tipos:\n\n```hemlock\nlet x = get_value();  // Dinamico - sin anotacion\nprocess(x);           // OK - valores dinamicos aceptados en cualquier lugar\n```\n\n---\n\n## Tipos Primitivos\n\n### Tipos Numericos\n\n#### Enteros con Signo\n\n| Tipo   | Tamano    | Rango                                      | Alias     |\n|--------|-----------|-------------------------------------------|-----------|\n| `i8`   | 1 byte    | -128 a 127                                | -         |\n| `i16`  | 2 bytes   | -32,768 a 32,767                          | -         |\n| `i32`  | 4 bytes   | -2,147,483,648 a 2,147,483,647            | `integer` |\n| `i64`  | 8 bytes   | -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 | - |\n\n**Ejemplos:**\n```hemlock\nlet a: i8 = 127;\nlet b: i16 = 32000;\nlet c: i32 = 1000000;\nlet d: i64 = 9223372036854775807;\n\n// Alias de tipo\nlet x: integer = 42;  // Igual que i32\n```\n\n#### Enteros sin Signo\n\n| Tipo   | Tamano    | Rango                     | Alias  |\n|--------|-----------|---------------------------|--------|\n| `u8`   | 1 byte    | 0 a 255                   | `byte` |\n| `u16`  | 2 bytes   | 0 a 65,535                | -      |\n| `u32`  | 4 bytes   | 0 a 4,294,967,295         | -      |\n| `u64`  | 8 bytes   | 0 a 18,446,744,073,709,551,615 | - |\n\n**Ejemplos:**\n```hemlock\nlet a: u8 = 255;\nlet b: u16 = 65535;\nlet c: u32 = 4294967295;\nlet d: u64 = 18446744073709551615;\n\n// Alias de tipo\nlet byte_val: byte = 65;  // Igual que u8\n```\n\n#### Punto Flotante\n\n| Tipo   | Tamano    | Precision      | Alias    |\n|--------|-----------|----------------|----------|\n| `f32`  | 4 bytes   | ~7 digitos     | -        |\n| `f64`  | 8 bytes   | ~15 digitos    | `number` |\n\n**Ejemplos:**\n```hemlock\nlet pi: f32 = 3.14159;\nlet precise: f64 = 3.14159265359;\n\n// Alias de tipo\nlet x: number = 2.718;  // Igual que f64\n```\n\n---\n\n### Inferencia de Literales Enteros\n\nLos literales enteros se tipan automaticamente basandose en su valor:\n\n**Reglas:**\n- Valores en rango i32 (-2,147,483,648 a 2,147,483,647): inferir como `i32`\n- Valores fuera del rango i32 pero dentro del rango i64: inferir como `i64`\n- Use anotaciones de tipo explicitas para otros tipos (i8, i16, u8, u16, u32, u64)\n\n**Ejemplos:**\n```hemlock\nlet small = 42;                    // i32 (cabe en i32)\nlet large = 5000000000;            // i64 (> maximo i32)\nlet max_i64 = 9223372036854775807; // i64 (INT64_MAX)\nlet explicit: u32 = 100;           // u32 (anotacion de tipo anula)\n```\n\n---\n\n### Tipo Booleano\n\n**Tipo:** `bool`\n\n**Valores:** `true`, `false`\n\n**Tamano:** 1 byte (internamente)\n\n**Ejemplos:**\n```hemlock\nlet is_active: bool = true;\nlet done = false;\n\nif (is_active && !done) {\n    print(\"trabajando\");\n}\n```\n\n---\n\n### Tipos de Caracter\n\n#### Rune\n\n**Tipo:** `rune`\n\n**Descripcion:** Punto de codigo Unicode (U+0000 a U+10FFFF)\n\n**Tamano:** 4 bytes (valor de 32 bits)\n\n**Rango:** 0 a 0x10FFFF (1,114,111)\n\n**Sintaxis Literal:** Comillas simples `'x'`\n\n**Ejemplos:**\n```hemlock\n// ASCII\nlet a = 'A';\nlet digit = '0';\n\n// UTF-8 multi-byte\nlet rocket = '';      // U+1F680\nlet heart = '';        // U+2764\nlet chinese = '';     // U+4E2D\n\n// Secuencias de escape\nlet newline = '\\n';\nlet tab = '\\t';\nlet backslash = '\\\\';\nlet quote = '\\'';\nlet null = '\\0';\n\n// Escapes Unicode\nlet emoji = '\\u{1F680}';   // Hasta 6 digitos hex\nlet max = '\\u{10FFFF}';    // Punto de codigo maximo\n```\n\n**Conversiones de Tipo:**\n```hemlock\n// Entero a rune\nlet code: rune = 65;        // 'A'\nlet r: rune = 128640;       // \n\n// Rune a entero\nlet value: i32 = 'Z';       // 90\n\n// Rune a string\nlet s: string = 'H';        // \"H\"\n\n// u8 a rune\nlet byte: u8 = 65;\nlet rune_val: rune = byte;  // 'A'\n```\n\n**Ver Tambien:** [API de Strings](#reference-string-api) para concatenacion de string + rune\n\n---\n\n### Tipo String\n\n**Tipo:** `string`\n\n**Descripcion:** Texto codificado en UTF-8, mutable, asignado en heap\n\n**Codificacion:** UTF-8 (U+0000 a U+10FFFF)\n\n**Mutabilidad:** Mutable (a diferencia de la mayoria de lenguajes)\n\n**Propiedades:**\n- `.length` - Conteo de puntos de codigo (numero de caracteres)\n- `.byte_length` - Conteo de bytes (tamano de codificacion UTF-8)\n\n**Sintaxis Literal:** Comillas dobles `\"texto\"`\n\n**Ejemplos:**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Mutar (ahora \"Hello\")\nprint(s.length);        // 5 (conteo de puntos de codigo)\nprint(s.byte_length);   // 5 (bytes UTF-8)\n\nlet emoji = \"\";\nprint(emoji.length);        // 1 (un punto de codigo)\nprint(emoji.byte_length);   // 4 (cuatro bytes UTF-8)\n```\n\n**Indexacion:**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Retorna rune 'h'\ns[0] = 'H';             // Establecer con rune\n```\n\n**Ver Tambien:** [API de Strings](#reference-string-api) para referencia completa de metodos\n\n---\n\n### Tipo Null\n\n**Tipo:** `null`\n\n**Descripcion:** El valor null (ausencia de valor)\n\n**Tamano:** 8 bytes (internamente)\n\n**Valor:** `null`\n\n**Ejemplos:**\n```hemlock\nlet x = null;\nlet y: i32 = null;  // ERROR: discrepancia de tipo\n\nif (x == null) {\n    print(\"x es null\");\n}\n```\n\n---\n\n## Tipos Compuestos\n\n### Tipo Array\n\n**Tipo:** `array`\n\n**Descripcion:** Array dinamico, asignado en heap, de tipos mixtos\n\n**Propiedades:**\n- `.length` - Numero de elementos\n\n**Indexacion desde cero:** Si\n\n**Sintaxis Literal:** `[elem1, elem2, ...]`\n\n**Ejemplos:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Tipos mixtos\nlet mixed = [1, \"hello\", true, null];\n```\n\n**Ver Tambien:** [API de Arrays](#reference-array-api) para referencia completa de metodos\n\n---\n\n### Tipo Objeto\n\n**Tipo:** `object`\n\n**Descripcion:** Objeto estilo JavaScript con campos dinamicos\n\n**Sintaxis Literal:** `{ campo: valor, ... }`\n\n**Ejemplos:**\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);  // \"Alice\"\n\n// Agregar campo dinamicamente\nperson.email = \"alice@example.com\";\n```\n\n**Definiciones de Tipo:**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: bool,  // Campo opcional\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\nprint(typeof(p));  // \"Person\"\n```\n\n---\n\n### Tipos de Puntero\n\n#### Puntero Crudo (ptr)\n\n**Tipo:** `ptr`\n\n**Descripcion:** Direccion de memoria cruda (inseguro)\n\n**Tamano:** 8 bytes\n\n**Verificacion de Limites:** Ninguna\n\n**Ejemplos:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n#### Buffer (buffer)\n\n**Tipo:** `buffer`\n\n**Descripcion:** Envoltorio de puntero seguro con verificacion de limites\n\n**Estructura:** Puntero + longitud + capacidad\n\n**Propiedades:**\n- `.length` - Tamano del buffer\n- `.capacity` - Capacidad asignada\n\n**Ejemplos:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Verificacion de limites\nprint(b.length);        // 64\nfree(b);\n```\n\n**Ver Tambien:** [API de Memoria](#reference-memory-api) para funciones de asignacion\n\n---\n\n## Tipos Especiales\n\n### Tipo File\n\n**Tipo:** `file`\n\n**Descripcion:** Manejador de archivo para operaciones de E/S\n\n**Propiedades:**\n- `.path` - Ruta del archivo (string)\n- `.mode` - Modo de apertura (string)\n- `.closed` - Si el archivo esta cerrado (bool)\n\n**Ver Tambien:** [API de Archivos](#reference-file-api)\n\n---\n\n### Tipo Task\n\n**Tipo:** `task`\n\n**Descripcion:** Manejador para tarea concurrente\n\n**Ver Tambien:** [API de Concurrencia](#reference-concurrency-api)\n\n---\n\n### Tipo Channel\n\n**Tipo:** `channel`\n\n**Descripcion:** Canal de comunicacion seguro para hilos\n\n**Ver Tambien:** [API de Concurrencia](#reference-concurrency-api)\n\n---\n\n### Tipo Function\n\n**Tipo:** `function`\n\n**Descripcion:** Valor de funcion de primera clase\n\n**Ejemplos:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(typeof(add));      // \"function\"\nprint(typeof(multiply)); // \"function\"\n```\n\n---\n\n### Tipo Void\n\n**Tipo:** `void`\n\n**Descripcion:** Ausencia de valor de retorno (uso interno)\n\n---\n\n## Reglas de Promocion de Tipos\n\nCuando se mezclan tipos en operaciones, Hemlock promociona al tipo \"superior\":\n\n**Jerarquia de Promocion:**\n```\nf64 (mayor precision)\n \nf32\n \nu64\n \ni64\n \nu32\n \ni32\n \nu16\n \ni16\n \nu8\n \ni8 (menor)\n```\n\n**Reglas:**\n1. Flotante siempre gana sobre entero\n2. Tamano mayor gana dentro de la misma categoria (int/uint/float)\n3. Ambos operandos se promocionan al tipo del resultado\n4. **Preservacion de precision:** i64/u64 + f32 promociona a f64 (no f32)\n\n**Ejemplos:**\n```hemlock\n// Promocion por tamano\nu8 + i32     i32    // Tamano mayor gana\ni32 + i64    i64    // Tamano mayor gana\nu32 + u64    u64    // Tamano mayor gana\n\n// Promocion a flotante\ni32 + f32    f32    // Flotante gana, f32 suficiente para i32\ni64 + f32    f64    // Promociona a f64 para preservar precision de i64\ni64 + f64    f64    // Flotante siempre gana\ni8 + f64     f64    // Flotante + mayor gana\n```\n\n**Por que i64 + f32 -> f64?**\n\nf32 tiene solo una mantisa de 24 bits, que no puede representar precisamente enteros mayores que 2^24 (16,777,216). Como i64 puede contener valores hasta 2^63, mezclar i64 con f32 causaria perdida severa de precision. Hemlock promociona a f64 (mantisa de 53 bits) en su lugar.\n\n---\n\n## Verificacion de Rango\n\nLas anotaciones de tipo imponen verificaciones de rango en asignacion:\n\n**Asignaciones Validas:**\n```hemlock\nlet x: u8 = 255;             // OK\nlet y: i8 = 127;             // OK\nlet a: i64 = 2147483647;     // OK\nlet b: u64 = 4294967295;     // OK\n```\n\n**Asignaciones Invalidas (Error en Tiempo de Ejecucion):**\n```hemlock\nlet x: u8 = 256;             // ERROR: fuera de rango\nlet y: i8 = 128;             // ERROR: maximo es 127\nlet z: u64 = -1;             // ERROR: u64 no puede ser negativo\n```\n\n---\n\n## Introspeccion de Tipos\n\n### typeof(value)\n\nRetorna el nombre del tipo como string.\n\n**Firma:**\n```hemlock\ntypeof(value: any): string\n```\n\n**Retorna:**\n- Tipos primitivos: `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- Tipos compuestos: `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- Tipos especiales: `\"file\"`, `\"task\"`, `\"channel\"`\n- Objetos tipados: Nombre de tipo personalizado (ej., `\"Person\"`)\n\n**Ejemplos:**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n```\n\n**Ver Tambien:** [Funciones Integradas](builtins.md#typeof)\n\n---\n\n## Conversiones de Tipo\n\n### Conversiones Implicitas\n\nHemlock realiza conversiones de tipo implicitas en operaciones aritmeticas siguiendo las reglas de promocion de tipos.\n\n**Ejemplos:**\n```hemlock\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet result = a + b;     // result es i32 (promocionado)\n```\n\n### Conversiones Explicitas\n\nUse anotaciones de tipo para conversiones explicitas:\n\n**Ejemplos:**\n```hemlock\n// Entero a flotante\nlet i: i32 = 42;\nlet f: f64 = i;         // 42.0\n\n// Flotante a entero (trunca)\nlet x: f64 = 3.14;\nlet y: i32 = x;         // 3\n\n// Entero a rune\nlet code: rune = 65;    // 'A'\n\n// Rune a entero\nlet value: i32 = 'Z';   // 90\n\n// Rune a string\nlet s: string = 'H';    // \"H\"\n```\n\n---\n\n## Alias de Tipo\n\n### Alias Integrados\n\nHemlock proporciona alias de tipo integrados para tipos comunes:\n\n| Alias     | Tipo Real | Uso                      |\n|-----------|-----------|--------------------------|\n| `integer` | `i32`     | Enteros de proposito general |\n| `number`  | `f64`     | Flotantes de proposito general |\n| `byte`    | `u8`      | Valores de byte          |\n\n**Ejemplos:**\n```hemlock\nlet count: integer = 100;       // Igual que i32\nlet price: number = 19.99;      // Igual que f64\nlet b: byte = 255;              // Igual que u8\n```\n\n### Alias de Tipo Personalizados\n\nDefina alias de tipo personalizados usando la palabra clave `type`:\n\n```hemlock\n// Alias simples\ntype Integer = i32;\ntype Text = string;\n\n// Alias de tipo funcion\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\n// Alias de tipo compuesto\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// Alias de tipo generico\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n```\n\n**Usando alias personalizados:**\n```hemlock\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**Nota:** Los alias de tipo son transparentes - `typeof()` retorna el nombre del tipo subyacente.\n\n---\n\n## Tipos de Funcion\n\nLos tipos de funcion especifican la firma de valores de funcion:\n\n### Sintaxis\n\n```hemlock\nfn(tipos_parametros): tipo_retorno\n```\n\n### Ejemplos\n\n```hemlock\n// Tipo de funcion basico\nlet add: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// Parametro de funcion\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Funcion de orden superior retornando funcion\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Tipo de funcion async\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n```\n\n---\n\n## Tipos Compuestos (Interseccion)\n\nLos tipos compuestos usan `&` para requerir multiples restricciones de tipo:\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// El objeto debe satisfacer todos los tipos\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// Tres o mas tipos\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n---\n\n## Tabla Resumen\n\n| Tipo       | Tamano   | Mutable | Asignado en Heap | Descripcion                    |\n|------------|----------|---------|------------------|--------------------------------|\n| `i8`-`i64` | 1-8 bytes| No      | No               | Enteros con signo              |\n| `u8`-`u64` | 1-8 bytes| No      | No               | Enteros sin signo              |\n| `f32`      | 4 bytes  | No      | No               | Flotante precision simple      |\n| `f64`      | 8 bytes  | No      | No               | Flotante precision doble       |\n| `bool`     | 1 byte   | No      | No               | Booleano                       |\n| `rune`     | 4 bytes  | No      | No               | Punto de codigo Unicode        |\n| `string`   | Variable | Si      | Si               | Texto UTF-8                    |\n| `array`    | Variable | Si      | Si               | Array dinamico                 |\n| `object`   | Variable | Si      | Si               | Objeto dinamico                |\n| `ptr`      | 8 bytes  | No      | No               | Puntero crudo                  |\n| `buffer`   | Variable | Si      | Si               | Envoltorio de puntero seguro   |\n| `file`     | Opaco    | Si      | Si               | Manejador de archivo           |\n| `task`     | Opaco    | No      | Si               | Manejador de tarea concurrente |\n| `channel`  | Opaco    | Si      | Si               | Canal seguro para hilos        |\n| `function` | Opaco    | No      | Si               | Valor de funcion               |\n| `null`     | 8 bytes  | No      | No               | Valor null                     |\n\n---\n\n## Ver Tambien\n\n- [Referencia de Operadores](#reference-operators) - Comportamiento de tipos en operaciones\n- [Funciones Integradas](#reference-builtins) - Introspeccion y conversion de tipos\n- [API de Strings](#reference-string-api) - Metodos de tipo string\n- [API de Arrays](#reference-array-api) - Metodos de tipo array\n- [API de Memoria](#reference-memory-api) - Operaciones de puntero y buffer\n"}, "Diseo y Filosofa -> Filosofa": {"id": "design-philosophy", "content": "# Filosofia de Diseno del Lenguaje Hemlock\n\n> \"Un lenguaje pequeno e inseguro para escribir cosas inseguras de forma segura.\"\n\nEste documento captura los principios fundamentales de diseno y la filosofia de Hemlock. Lea esto primero antes de realizar cualquier cambio o adicion al lenguaje.\n\n---\n\n## Tabla de Contenidos\n\n- [Identidad Central](#identidad-central)\n- [Principios de Diseno](#principios-de-diseno)\n- [Filosofia sobre la Seguridad](#filosofia-sobre-la-seguridad)\n- [Que NO Agregar](#que-no-agregar)\n- [Consideraciones Futuras](#consideraciones-futuras)\n- [Reflexiones Finales](#reflexiones-finales)\n\n---\n\n## Identidad Central\n\nHemlock es un **lenguaje de scripting para sistemas** que adopta la gestion manual de memoria y el control explicito. Esta disenado para programadores que desean:\n\n- El poder de C\n- La ergonomia de los lenguajes de scripting modernos\n- Concurrencia asincrona estructurada integrada\n- Sin comportamientos ocultos ni magia\n\n### Lo que Hemlock NO ES\n\n- **Seguro en memoria** (los punteros colgantes son su responsabilidad)\n- **Un reemplazo para Rust, Go o Lua**\n- **Un lenguaje que oculta la complejidad**\n\n### Lo que Hemlock SI ES\n\n- **Explicito sobre implicito, siempre**\n- **Educativo y experimental**\n- **Una \"capa de scripting tipo C\" para trabajo de sistemas**\n- **Honesto sobre las compensaciones**\n\n---\n\n## Principios de Diseno\n\n### 1. Explicito Sobre Implicito\n\nHemlock favorece la explicitud en todas las construcciones del lenguaje. No debe haber sorpresas, ni magia, ni comportamientos ocultos.\n\n**Malo (implicito):**\n```hemlock\nlet x = 5  // Falta punto y coma - deberia dar error\n```\n\n**Bueno (explicito):**\n```hemlock\nlet x = 5;\nfree(ptr);  // Usted lo asigno, usted lo libera\n```\n\n**Aspectos clave:**\n- Los puntos y coma son obligatorios (sin insercion automatica de punto y coma)\n- Sin recoleccion de basura\n- Gestion manual de memoria (alloc/free)\n- Las anotaciones de tipo son opcionales pero se verifican en tiempo de ejecucion\n- Sin limpieza automatica de recursos (sin RAII), pero `defer` proporciona limpieza explicita\n\n### 2. Dinamico por Defecto, Tipado por Eleccion\n\nCada valor tiene una etiqueta de tipo en tiempo de ejecucion, pero el sistema esta disenado para ser flexible mientras aun detecta errores.\n\n**Inferencia de tipos:**\n- Enteros pequenos (caben en i32): `42` -> `i32`\n- Enteros grandes (> rango de i32): `9223372036854775807` -> `i64`\n- Flotantes: `3.14` -> `f64`\n\n**Tipado explicito cuando es necesario:**\n```hemlock\nlet x = 42;              // i32 inferido (valor pequeno)\nlet y: u8 = 255;         // u8 explicito\nlet z = x + y;           // se promueve a i32\nlet big = 5000000000;    // i64 inferido (> maximo de i32)\n```\n\n**Las reglas de promocion de tipos** siguen una jerarquia clara de menor a mayor, con los flotantes siempre ganando sobre los enteros.\n\n### 3. Lo Inseguro es una Caracteristica, No un Defecto\n\nHemlock no intenta prevenir todos los errores. En cambio, le proporciona las herramientas para ser seguro mientras le permite optar por comportamientos inseguros cuando es necesario.\n\n**Ejemplos de inseguridad intencional:**\n- La aritmetica de punteros puede desbordarse (responsabilidad del usuario)\n- Sin verificacion de limites en `ptr` crudo (use `buffer` si desea seguridad)\n- Se permiten bloqueos por doble liberacion (gestion manual de memoria)\n- El sistema de tipos previene accidentes pero permite riesgos cuando es necesario\n\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Muy lejos de la asignacion - permitido pero peligroso\n```\n\n**La filosofia:** El sistema de tipos debe prevenir *accidentes* pero permitir operaciones inseguras *intencionales*.\n\n### 4. Concurrencia Estructurada de Primera Clase\n\nLa concurrencia no es una ocurrencia tardia en Hemlock. Esta integrada en el lenguaje desde la base.\n\n**Caracteristicas clave:**\n- `async`/`await` integrados en el lenguaje\n- Canales para comunicacion\n- `spawn`/`join`/`detach` para gestion de tareas\n- Sin hilos crudos, sin bloqueos - solo estructurado\n- Verdadero paralelismo multi-hilo usando hilos POSIX\n\n**No es un bucle de eventos ni hilos verdes** - Hemlock usa hilos reales del sistema operativo para verdadero paralelismo a traves de multiples nucleos de CPU.\n\n### 5. Sintaxis Similar a C, Poca Ceremonia\n\nHemlock debe resultar familiar a los programadores de sistemas mientras reduce el codigo repetitivo.\n\n**Decisiones de diseno:**\n- Bloques `{}` siempre, sin llaves opcionales\n- Los operadores coinciden con C: `+`, `-`, `*`, `/`, `&&`, `||`, `!`\n- Sintaxis de tipos coincide con Rust/TypeScript: `let x: type = value;`\n- Las funciones son valores de primera clase\n- Palabras clave y formas especiales minimas\n\n---\n\n## Filosofia sobre la Seguridad\n\n**La postura de Hemlock sobre la seguridad:**\n\n> \"Le damos las herramientas para ser seguro (`buffer`, anotaciones de tipo, verificacion de limites) pero no le obligamos a usarlas (`ptr`, memoria manual, operaciones inseguras).\n>\n> El valor predeterminado debe guiar hacia la seguridad, pero la escotilla de escape siempre debe estar disponible.\"\n\n### Herramientas de Seguridad Proporcionadas\n\n**1. Tipo buffer seguro:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // con verificacion de limites\nprint(b.length);        // 64\nfree(b);                // aun manual\n```\n\n**2. Punteros crudos inseguros:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // Debe recordar liberar\n```\n\n**3. Anotaciones de tipo:**\n```hemlock\nlet x: u8 = 255;   // OK\nlet y: u8 = 256;   // ERROR: fuera de rango\n```\n\n**4. Verificacion de tipos en tiempo de ejecucion:**\n```hemlock\nlet val = some_function();\nif (typeof(val) == \"i32\") {\n    // Seguro de usar como entero\n}\n```\n\n### Principios Guia\n\n1. **Usar patrones seguros por defecto en la documentacion** - Mostrar `buffer` antes de `ptr`, fomentar anotaciones de tipo\n2. **Hacer obvias las operaciones inseguras** - La aritmetica de punteros crudos debe parecer intencional\n3. **Proporcionar escotillas de escape** - No prevenir que usuarios experimentados hagan trabajo de bajo nivel\n4. **Ser honesto sobre las compensaciones** - Documentar que puede salir mal\n\n### Ejemplos de Seguridad vs. Inseguridad\n\n| Patron Seguro | Patron Inseguro | Cuando Usar Inseguro |\n|---------------|-----------------|---------------------|\n| Tipo `buffer` | Tipo `ptr` | FFI, codigo critico para rendimiento |\n| Anotaciones de tipo | Sin anotaciones | Interfaces externas, validacion |\n| Acceso con verificacion de limites | Aritmetica de punteros | Operaciones de memoria de bajo nivel |\n| Manejo de excepciones | Retornar null/codigos de error | Cuando las excepciones son muy pesadas |\n\n---\n\n## Que NO Agregar\n\nEntender que **no** agregar es tan importante como saber que agregar.\n\n### No Agregar Comportamiento Implicito\n\n**Malos ejemplos:**\n\n```hemlock\n// MALO: Insercion automatica de punto y coma\nlet x = 5\nlet y = 10\n\n// MALO: Conversiones de tipo implicitas que pierden precision\nlet x: i32 = 3.14  // Deberia truncar o dar error?\n```\n\n**Por que:** El comportamiento implicito crea sorpresas y hace que el codigo sea mas dificil de razonar.\n\n### No Ocultar la Complejidad\n\n**Malos ejemplos:**\n\n```hemlock\n// MALO: Optimizacion magica detras de escena\nlet arr = [1, 2, 3]  // Esta en la pila o en el heap? El usuario debe saberlo! (Heap, con conteo de referencias)\n\n// MALO: Puntero crudo auto-liberado\nlet p = alloc(100)  // Se auto-libera? NO! Los ptrs crudos siempre necesitan free()\n```\n\n**Nota sobre conteo de referencias:** Hemlock usa conteo de referencias interno para strings, arrays, objetos y buffers - estos SI se auto-liberan cuando el ambito termina. Esto es explicito y predecible (limpieza determinista cuando la referencia llega a 0, sin pausas de GC). Los punteros crudos (`ptr` de `alloc()`) NO tienen conteo de referencias y siempre requieren `free()` manual.\n\n**Por que:** La complejidad oculta hace imposible predecir el rendimiento y depurar problemas.\n\n### No Romper la Semantica Existente\n\n**Nunca cambiar estas decisiones fundamentales:**\n- Los puntos y coma son obligatorios - no hacerlos opcionales\n- Gestion manual de memoria - no agregar GC\n- Strings mutables - no hacerlos inmutables\n- Verificacion de tipos en tiempo de ejecucion - no eliminarla\n\n**Por que:** La consistencia y estabilidad son mas importantes que las caracteristicas de moda.\n\n### No Agregar Caracteristicas \"Convenientes\" que Reducen la Explicitud\n\n**Ejemplos de caracteristicas a evitar:**\n- Sobrecarga de operadores (quizas para tipos de usuario, pero con cuidado)\n- Coercion de tipos implicita que pierde informacion\n- Limpieza automatica de recursos (RAII)\n- Encadenamiento de metodos que oculta complejidad\n- DSLs y sintaxis magica\n\n**Excepcion:** Las caracteristicas de conveniencia estan bien si son **azucar explicito** sobre operaciones simples:\n- `else if` esta bien (son solo sentencias if anidadas)\n- La interpolacion de strings podria estar bien si es claramente azucar sintactico\n- La sintaxis de metodos para objetos esta bien (es explicito lo que hace)\n\n---\n\n## Consideraciones Futuras\n\n### Quizas Agregar (En Discusion)\n\nEstas caracteristicas se alinean con la filosofia de Hemlock pero necesitan diseno cuidadoso:\n\n**1. Coincidencia de patrones**\n```hemlock\nmatch (value) {\n    case i32: print(\"entero\");\n    case string: print(\"texto\");\n    case _: print(\"otro\");\n}\n```\n- Verificacion de tipos explicita\n- Sin costos ocultos\n- Posible verificacion de exhaustividad en tiempo de compilacion\n\n**2. Tipos de error (`Result<T, E>`)**\n```hemlock\nfn divide(a: i32, b: i32): Result<i32, string> {\n    if (b == 0) {\n        return Err(\"division por cero\");\n    }\n    return Ok(a / b);\n}\n```\n- Manejo de errores explicito\n- Obliga a los usuarios a pensar en los errores\n- Alternativa a las excepciones\n\n**3. Tipos de array/slice**\n- Ya tenemos arrays dinamicos\n- Podriamos agregar arrays de tamano fijo para asignacion en pila\n- Necesitaria ser explicito sobre pila vs. heap\n\n**4. Herramientas mejoradas de seguridad de memoria**\n- Bandera opcional de verificacion de limites\n- Deteccion de fugas de memoria en compilaciones de depuracion\n- Integracion con sanitizadores\n\n### Probablemente Nunca Agregar\n\nEstas caracteristicas violan los principios fundamentales:\n\n**1. Recoleccion de basura**\n- Oculta la complejidad de gestion de memoria\n- Rendimiento impredecible\n- Contra el principio de control explicito\n\n**2. Gestion automatica de memoria**\n- Mismas razones que GC\n- El conteo de referencias podria estar bien si es explicito\n\n**3. Conversiones de tipo implicitas que pierden datos**\n- Va contra \"explicito sobre implicito\"\n- Fuente de errores sutiles\n\n**4. Macros (complejas)**\n- Demasiado poder, demasiada complejidad\n- Un sistema de macros simple podria estar bien\n- Preferir generacion de codigo o funciones\n\n**5. POO basada en clases con herencia**\n- Demasiado comportamiento implicito\n- El duck typing y los objetos son suficientes\n- Composicion sobre herencia\n\n**6. Sistema de modulos con resolucion compleja**\n- Mantener las importaciones simples y explicitas\n- Sin rutas de busqueda magicas\n- Sin resolucion de versiones (usar el gestor de paquetes del SO)\n\n---\n\n## Reflexiones Finales\n\n### Confianza y Responsabilidad\n\nHemlock trata sobre **confianza y responsabilidad**. Confiamos en que el programador:\n\n- Gestione la memoria correctamente\n- Use los tipos apropiadamente\n- Maneje los errores adecuadamente\n- Entienda las compensaciones\n\nA cambio, Hemlock proporciona:\n\n- Sin costos ocultos\n- Sin comportamiento sorpresa\n- Control total cuando es necesario\n- Herramientas de seguridad cuando se desean\n\n### La Pregunta Guia\n\n**Al considerar una nueva caracteristica, pregunte:**\n\n> \"Esto le da al programador mas control explicito, o oculta algo?\"\n\n- Si **agrega control explicito** -> probablemente encaja en Hemlock\n- Si **oculta complejidad** -> probablemente no pertenece\n- Si es **azucar opcional** que esta claramente documentado -> podria estar bien\n\n### Ejemplos de Buenas Adiciones\n\nSentencias switch - Flujo de control explicito, sin magia, semantica clara\n\nAsync/await con pthreads - Concurrencia explicita, verdadero paralelismo, el usuario controla el spawn\n\nTipo buffer junto con ptr - Da eleccion entre seguro e inseguro\n\nAnotaciones de tipo opcionales - Ayuda a detectar errores sin forzar rigidez\n\nTry/catch/finally - Manejo de errores explicito con flujo de control claro\n\n### Ejemplos de Malas Adiciones\n\nInsercion automatica de punto y coma - Oculta errores de sintaxis, hace el codigo ambiguo\n\nRAII/destructores - La limpieza automatica oculta cuando se liberan los recursos\n\nCoalescencia null implicita - Oculta verificaciones de null, hace el codigo mas dificil de razonar\n\nStrings auto-crecientes - Oculta asignacion de memoria, rendimiento impredecible\n\n---\n\n## Conclusion\n\nHemlock no intenta ser el lenguaje mas seguro, el lenguaje mas rapido, o el lenguaje con mas caracteristicas.\n\n**Hemlock intenta ser el lenguaje mas *honesto*.**\n\nLe dice exactamente lo que esta haciendo, le da control cuando lo necesita, y no oculta los bordes afilados. Es un lenguaje para personas que quieren entender su codigo a bajo nivel mientras aun disfrutan de ergonomia moderna.\n\nSi no esta seguro de si una caracteristica pertenece a Hemlock, recuerde:\n\n> **Explicito sobre implicito, siempre.**\n> **Lo inseguro es una caracteristica, no un defecto.**\n> **El usuario es responsable, y eso esta bien.**\n"}, "Diseo y Filosofa -> Implementacin": {"id": "design-implementation", "content": "# Detalles de Implementacion de Hemlock\n\nEste documento describe la implementacion tecnica del lenguaje Hemlock, incluyendo la estructura del proyecto, el pipeline de compilacion, la arquitectura del runtime y las decisiones de diseno.\n\n---\n\n## Tabla de Contenidos\n\n- [Estructura del Proyecto](#estructura-del-proyecto)\n- [Pipeline de Compilacion](#pipeline-de-compilacion)\n- [Diseno Modular del Interprete](#diseno-modular-del-interprete)\n- [Arquitectura del Runtime](#arquitectura-del-runtime)\n- [Representacion de Valores](#representacion-de-valores)\n- [Implementacion del Sistema de Tipos](#implementacion-del-sistema-de-tipos)\n- [Gestion de Memoria](#gestion-de-memoria)\n- [Modelo de Concurrencia](#modelo-de-concurrencia)\n- [Planes Futuros](#planes-futuros)\n\n---\n\n## Estructura del Proyecto\n\n```\nhemlock/\n src/\n    frontend/              # Compartido: lexer, parser, AST\n       lexer.c            # Tokenizacion\n       parser/            # Parser de descenso recursivo\n       ast.c              # Gestion de nodos AST\n       module.c           # Resolucion de modulos\n    backends/\n       interpreter/       # hemlock: interprete de recorrido de arbol\n          main.c         # Punto de entrada CLI\n          runtime.c      # Evaluacion de expresiones/sentencias\n          builtins.c     # Funciones integradas\n          ...\n       compiler/          # hemlockc: generador de codigo C\n           main.c         # CLI, orquestacion\n           type_check.c   # Verificacion de tipos en compilacion\n           codegen.c      # Contexto de generacion de codigo\n           codegen_expr.c # Codegen de expresiones\n           codegen_stmt.c # Codegen de sentencias\n           ...\n    tools/\n       lsp/               # Protocolo de Servidor de Lenguaje\n       bundler/           # Herramientas de empaquetado\n runtime/                   # libhemlock_runtime.a (para programas compilados)\n stdlib/                    # Biblioteca estandar (39 modulos)\n    docs/                  # Documentacion de modulos\n tests/\n    parity/                # Pruebas que deben pasar ambos backends\n    interpreter/           # Pruebas especificas del interprete\n    compiler/              # Pruebas especificas del compilador\n examples/                  # Programas de ejemplo\n docs/                      # Documentacion\n```\n\n### Organizacion de Directorios\n\n**`include/`** - Headers de API publica que definen la interfaz entre componentes:\n- Separacion limpia entre lexer, parser, AST e interprete\n- Declaraciones adelantadas para minimizar dependencias\n- API publica para incrustar Hemlock en otros programas\n\n**`src/`** - Archivos de implementacion:\n- Los archivos de nivel superior manejan lexing, parsing, gestion de AST\n- `main.c` proporciona CLI y REPL\n- El interprete esta modularizado en subsistemas separados\n\n**`src/interpreter/`** - Implementacion modular del interprete:\n- Cada modulo tiene una responsabilidad unica y clara\n- API interna definida en `internal.h` para comunicacion entre modulos\n- Los modulos pueden compilarse independientemente para compilaciones mas rapidas\n\n**`tests/`** - Suite de pruebas completa:\n- Organizada por area de caracteristica\n- Cada directorio contiene casos de prueba enfocados\n- `run_tests.sh` orquesta la ejecucion de pruebas\n\n---\n\n## Pipeline de Compilacion\n\nHemlock usa un pipeline de compilacion tradicional con fases distintas:\n\n### Fase 1: Analisis Lexico (Lexer)\n\n**Entrada:** Texto de codigo fuente\n**Salida:** Flujo de tokens\n**Implementacion:** `src/lexer.c`\n\n```\nFuente: \"let x = 42;\"\n   \nTokens: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n```\n\n**Caracteristicas clave:**\n- Reconoce palabras clave, identificadores, literales, operadores, puntuacion\n- Maneja literales de string UTF-8 y literales de runa\n- Reporta numeros de linea para mensajes de error\n- Pasada unica, sin retroceso\n\n### Fase 2: Analisis Sintactico (Parser)\n\n**Entrada:** Flujo de tokens\n**Salida:** Arbol de Sintaxis Abstracta (AST)\n**Implementacion:** `src/parser.c`\n\n```\nTokens: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n   \nAST: LetStmt {\n    name: \"x\",\n    type: null,\n    value: IntLiteral(42)\n}\n```\n\n**Caracteristicas clave:**\n- Parser de descenso recursivo\n- Construye representacion en arbol de la estructura del programa\n- Maneja precedencia de operadores\n- Valida sintaxis (llaves, puntos y coma, etc.)\n- Sin analisis semantico aun (se hace en tiempo de ejecucion)\n\n**Precedencia de Operadores (menor a mayor):**\n1. Asignacion: `=`\n2. OR logico: `||`\n3. AND logico: `&&`\n4. OR a nivel de bits: `|`\n5. XOR a nivel de bits: `^`\n6. AND a nivel de bits: `&`\n7. Igualdad: `==`, `!=`\n8. Comparacion: `<`, `>`, `<=`, `>=`\n9. Desplazamientos de bits: `<<`, `>>`\n10. Suma/Resta: `+`, `-`\n11. Multiplicacion/Division/Modulo: `*`, `/`, `%`\n12. Unarios: `!`, `-`, `~`\n13. Llamada/Indice/Miembro: `()`, `[]`, `.`\n\n### Fase 3a: Interpretacion (Recorrido de Arbol)\n\n**Entrada:** AST\n**Salida:** Ejecucion del programa\n**Implementacion:** `src/backends/interpreter/runtime.c`\n\n```\nAST: LetStmt { ... }\n   \nEjecucion: Evalua nodos AST recursivamente\n   \nResultado: Variable x creada con valor 42\n```\n\n**Caracteristicas clave:**\n- Recorrido directo del AST (interprete de recorrido de arbol)\n- Verificacion dinamica de tipos en tiempo de ejecucion\n- Almacenamiento de variables basado en entorno\n\n### Fase 3b: Compilacion (hemlockc)\n\n**Entrada:** AST\n**Salida:** Ejecutable nativo via generacion de codigo C\n**Implementacion:** `src/backends/compiler/`\n\n```\nAST: LetStmt { ... }\n   \nVerificacion de Tipos: Validar tipos en tiempo de compilacion\n   \nCodegen C: Generar codigo C equivalente\n   \nGCC: Compilar C a binario nativo\n   \nResultado: Ejecutable independiente\n```\n\n**Caracteristicas clave:**\n- Verificacion de tipos en tiempo de compilacion (habilitada por defecto)\n- Generacion de codigo C para portabilidad\n- Enlaza contra `libhemlock_runtime.a`\n- Ejecucion significativamente mas rapida que el interprete\n\n---\n\n## Backend del Compilador (hemlockc)\n\nEl compilador de Hemlock genera codigo C desde el AST, que luego se compila a un ejecutable nativo usando GCC.\n\n### Arquitectura del Compilador\n\n```\nsrc/backends/compiler/\n main.c              # CLI, parseo de argumentos, orquestacion\n codegen.c           # Contexto central de generacion de codigo\n codegen_expr.c      # Generacion de codigo de expresiones\n codegen_stmt.c      # Generacion de codigo de sentencias\n codegen_call.c      # Generacion de llamadas a funciones\n codegen_closure.c   # Implementacion de closures\n codegen_program.c   # Generacion de programa de nivel superior\n codegen_module.c    # Manejo de modulos/importaciones\n type_check.c        # Verificacion de tipos en compilacion\n type_check.h        # API del verificador de tipos\n```\n\n### Verificacion de Tipos\n\nEl compilador incluye un sistema unificado de verificacion de tipos que:\n\n1. **Valida tipos en tiempo de compilacion** - Detecta errores de tipo antes de la ejecucion\n2. **Soporta codigo dinamico** - Codigo sin tipos tratado como `any` (siempre valido)\n3. **Proporciona pistas de optimizacion** - Identifica variables que pueden desempaquetarse\n\n**Banderas de Verificacion de Tipos:**\n\n| Bandera | Descripcion |\n|---------|-------------|\n| (defecto) | Verificacion de tipos habilitada |\n| `--check` | Solo verificar tipos, no compilar |\n| `--no-type-check` | Deshabilitar verificacion de tipos |\n| `--strict-types` | Advertir sobre tipos `any` implicitos |\n\n**Implementacion del Verificador de Tipos:**\n\n```c\n// type_check.h - Estructuras clave\ntypedef struct TypeCheckContext {\n    const char *filename;\n    int error_count;\n    int warning_count;\n    UnboxableVar *unboxable_vars;  // Pistas de optimizacion\n    // ... entorno de tipos, definiciones, etc.\n} TypeCheckContext;\n\n// Punto de entrada principal\nint type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);\n```\n\n### Generacion de Codigo\n\nLa fase de codegen traduce nodos AST a codigo C:\n\n**Mapeo de Expresiones:**\n```\nHemlock                   C Generado\n----------------------------------------\nlet x = 42;              HmlValue x = hml_val_i32(42);\nx + y                    hml_add(x, y)\narr[i]                   hml_array_get(arr, i)\nobj.field                hml_object_get_field(obj, \"field\")\nfn(a, b) { ... }         Closure con captura de entorno\n```\n\n**Integracion con Runtime:**\n\nEl codigo C generado enlaza contra `libhemlock_runtime.a` que proporciona:\n- Tipo union etiquetada `HmlValue`\n- Gestion de memoria (conteo de referencias)\n- Funciones integradas (print, typeof, etc.)\n- Primitivas de concurrencia (tareas, canales)\n- Soporte FFI\n\n### Optimizacion de Desempaquetado\n\nEl verificador de tipos identifica variables que pueden usar tipos C nativos en lugar de `HmlValue` empaquetados:\n\n**Patrones Desempaquetables:**\n- Contadores de bucle con tipo entero conocido\n- Variables acumuladoras en bucles\n- Variables con anotaciones de tipo explicitas (i32, i64, f64, bool)\n\n```hemlock\n// El contador de bucle 'i' puede desempaquetarse a int32_t nativo\nfor (let i: i32 = 0; i < 1000000; i = i + 1) {\n    sum = sum + i;\n}\n```\n\n---\n\n## Diseno Modular del Interprete\n\nEl interprete esta dividido en modulos enfocados para mantenibilidad y escalabilidad.\n\n### Responsabilidades de los Modulos\n\n#### 1. Entorno (`environment.c`) - 121 lineas\n\n**Proposito:** Alcance de variables y resolucion de nombres\n\n**Funciones clave:**\n- `env_create()` - Crear nuevo entorno con padre opcional\n- `env_define()` - Definir nueva variable en alcance actual\n- `env_get()` - Buscar variable en alcances actual o padres\n- `env_set()` - Actualizar valor de variable existente\n- `env_free()` - Liberar entorno y todas las variables\n\n**Diseno:**\n- Alcances enlazados (cada entorno tiene puntero al padre)\n- HashMap para busqueda rapida de variables\n- Soporta alcance lexico para closures\n\n#### 2. Valores (`values.c`) - 394 lineas\n\n**Proposito:** Constructores de valores y gestion de estructuras de datos\n\n**Funciones clave:**\n- `value_create_*()` - Constructores para cada tipo de valor\n- `value_copy()` - Logica de copia profunda/superficial\n- `value_free()` - Limpieza y desasignacion de memoria\n- `value_to_string()` - Representacion en string para impresion\n\n**Estructuras de datos:**\n- Objetos (arrays de campos dinamicos)\n- Arrays (redimensionamiento dinamico)\n- Buffers (ptr + longitud + capacidad)\n- Closures (funcion + entorno capturado)\n- Tareas y Canales (primitivas de concurrencia)\n\n#### 3. Tipos (`types.c`) - 440 lineas\n\n**Proposito:** Sistema de tipos, conversiones y duck typing\n\n**Funciones clave:**\n- `type_check()` - Validacion de tipos en tiempo de ejecucion\n- `type_convert()` - Conversiones/promociones de tipo implicitas\n- `duck_type_check()` - Verificacion de tipos estructural para objetos\n- `type_name()` - Obtener nombre de tipo imprimible\n\n**Caracteristicas:**\n- Jerarquia de promocion de tipos (i8  i16  i32  i64  f32  f64, con i64/u64 + f32  f64)\n- Verificacion de rango para tipos numericos\n- Duck typing para definiciones de tipos de objetos\n- Valores por defecto de campos opcionales\n\n#### 4. Funciones Integradas (`builtins.c`) - 955 lineas\n\n**Proposito:** Funciones integradas y registro global\n\n**Funciones clave:**\n- `register_builtins()` - Registrar todas las funciones y constantes integradas\n- Implementaciones de funciones integradas (print, typeof, alloc, free, etc.)\n- Funciones de manejo de senales\n- Ejecucion de comandos (exec)\n\n**Categorias de funciones integradas:**\n- E/S: print, open, read_file, write_file\n- Memoria: alloc, free, memset, memcpy, realloc\n- Tipos: typeof, assert\n- Concurrencia: spawn, join, detach, channel\n- Sistema: exec, signal, raise, panic\n- FFI: dlopen, dlsym, dlcall, dlclose\n\n#### 5. E/S (`io.c`) - 449 lineas\n\n**Proposito:** E/S de archivos y serializacion JSON\n\n**Funciones clave:**\n- Metodos de objeto archivo (read, write, seek, tell, close)\n- Serializacion/deserializacion JSON\n- Deteccion de referencias circulares\n\n**Caracteristicas:**\n- Objeto archivo con propiedades (path, mode, closed)\n- E/S de texto consciente de UTF-8\n- Soporte de E/S binaria\n- Ida y vuelta JSON para objetos y arrays\n\n#### 6. FFI (`ffi.c`) - Interfaz de Funciones Foraneas\n\n**Proposito:** Llamar funciones C desde bibliotecas compartidas\n\n**Funciones clave:**\n- `dlopen()` - Cargar biblioteca compartida\n- `dlsym()` - Obtener puntero de funcion por nombre\n- `dlcall()` - Llamar funcion C con conversion de tipos\n- `dlclose()` - Descargar biblioteca\n\n**Caracteristicas:**\n- Integracion con libffi para llamadas dinamicas a funciones\n- Conversion automatica de tipos (Hemlock  tipos C)\n- Soporte para todos los tipos primitivos\n- Soporte de punteros y buffers\n\n#### 7. Runtime (`runtime.c`) - 865 lineas\n\n**Proposito:** Evaluacion de expresiones y ejecucion de sentencias\n\n**Funciones clave:**\n- `eval_expr()` - Evaluar expresiones (recursivo)\n- `eval_stmt()` - Ejecutar sentencias\n- Manejo de flujo de control (if, while, for, switch, etc.)\n- Manejo de excepciones (try/catch/finally/throw)\n\n**Caracteristicas:**\n- Evaluacion recursiva de expresiones\n- Evaluacion booleana de cortocircuito\n- Deteccion de llamadas a metodos y vinculacion de `self`\n- Propagacion de excepciones\n- Manejo de break/continue/return\n\n### Beneficios del Diseno Modular\n\n**1. Separacion de Responsabilidades**\n- Cada modulo tiene una responsabilidad clara\n- Facil encontrar donde se implementan las caracteristicas\n- Reduce la carga cognitiva al hacer cambios\n\n**2. Compilaciones Incrementales mas Rapidas**\n- Solo los modulos modificados necesitan recompilacion\n- Compilacion paralela posible\n- Tiempos de iteracion mas cortos durante el desarrollo\n\n**3. Pruebas y Depuracion mas Faciles**\n- Los modulos pueden probarse en aislamiento\n- Los errores se localizan en subsistemas especificos\n- Implementaciones mock posibles para pruebas\n\n**4. Escalabilidad**\n- Nuevas caracteristicas pueden agregarse a modulos apropiados\n- Los modulos pueden refactorizarse independientemente\n- El tamano del codigo por archivo se mantiene manejable\n\n**5. Organizacion del Codigo**\n- Agrupacion logica de funcionalidad relacionada\n- Grafo de dependencias claro\n- Incorporacion mas facil para nuevos contribuidores\n\n---\n\n## Arquitectura del Runtime\n\n### Representacion de Valores\n\nTodos los valores en Hemlock se representan por la estructura `Value` usando una union etiquetada:\n\n```c\ntypedef struct Value {\n    ValueType type;  // Etiqueta de tipo en tiempo de ejecucion\n    union {\n        int32_t i32_value;\n        int64_t i64_value;\n        uint8_t u8_value;\n        uint32_t u32_value;\n        uint64_t u64_value;\n        float f32_value;\n        double f64_value;\n        bool bool_value;\n        char *string_value;\n        uint32_t rune_value;\n        void *ptr_value;\n        Buffer *buffer_value;\n        Array *array_value;\n        Object *object_value;\n        Function *function_value;\n        File *file_value;\n        Task *task_value;\n        Channel *channel_value;\n    };\n} Value;\n```\n\n**Decisiones de diseno:**\n- **Union etiquetada** para seguridad de tipos manteniendo flexibilidad\n- **Etiquetas de tipo en tiempo de ejecucion** habilitan tipado dinamico con verificacion de tipos\n- **Almacenamiento directo de valores** para primitivos (sin empaquetado)\n- **Almacenamiento de punteros** para tipos asignados en heap (strings, objetos, arrays)\n\n### Ejemplos de Disposicion en Memoria\n\n**Entero (i32):**\n```\nValue {\n    type: TYPE_I32,\n    i32_value: 42\n}\n```\n- Tamano total: ~16 bytes (etiqueta de 8 bytes + union de 8 bytes)\n- Asignado en pila\n- No necesita asignacion en heap\n\n**String:**\n```\nValue {\n    type: TYPE_STRING,\n    string_value: 0x7f8a4c000000  // Puntero al heap\n}\n\nHeap: \"hello\\0\" (6 bytes, terminado en null UTF-8)\n```\n- El valor es 16 bytes en la pila\n- Los datos del string estan asignados en heap\n- Debe liberarse manualmente\n\n**Objeto:**\n```\nValue {\n    type: TYPE_OBJECT,\n    object_value: 0x7f8a4c001000  // Puntero al heap\n}\n\nHeap: Object {\n    type_name: \"Person\",\n    fields: [\n        { name: \"name\", value: Value{TYPE_STRING, \"Alice\"} },\n        { name: \"age\", value: Value{TYPE_I32, 30} }\n    ],\n    field_count: 2,\n    capacity: 4\n}\n```\n- Estructura del objeto en heap\n- Campos almacenados en array dinamico\n- Valores de campos son estructuras Value incrustadas\n\n### Implementacion de Entorno\n\nLas variables se almacenan en cadenas de entorno:\n\n```c\ntypedef struct Environment {\n    HashMap *bindings;           // nombre  Value\n    struct Environment *parent;  // Alcance padre lexico\n} Environment;\n```\n\n**Ejemplo de cadena de alcances:**\n```\nAlcance Global: { print: <builtin>, args: <array> }\n    \nAlcance de Funcion: { x: 10, y: 20 }\n    \nAlcance de Bloque: { i: 0 }\n```\n\n**Algoritmo de busqueda:**\n1. Verificar el hashmap del entorno actual\n2. Si no se encuentra, verificar el entorno padre\n3. Repetir hasta encontrar o alcanzar el alcance global\n4. Error si no se encuentra en ningun alcance\n\n---\n\n## Implementacion del Sistema de Tipos\n\n### Estrategia de Verificacion de Tipos\n\nHemlock usa **verificacion de tipos en tiempo de ejecucion** con **anotaciones de tipo opcionales**:\n\n```hemlock\nlet x = 42;           // Sin verificacion de tipo, infiere i32\nlet y: u8 = 255;      // Verificacion en tiempo de ejecucion: valor debe caber en u8\nlet z: i32 = x + y;   // Verificacion en tiempo de ejecucion + promocion de tipos\n```\n\n**Flujo de implementacion:**\n1. **Inferencia de literales** - Lexer/parser determinan tipo inicial del literal\n2. **Verificacion de anotacion de tipo** - Si hay anotacion presente, validar en asignacion\n3. **Promocion** - Operaciones binarias promueven a tipo comun\n4. **Conversion** - Conversiones explicitas ocurren bajo demanda\n\n### Implementacion de Promocion de Tipos\n\nLa promocion de tipos sigue una jerarquia fija con preservacion de precision:\n\n```c\n// Logica de promocion simplificada\nValueType promote_types(ValueType a, ValueType b) {\n    // f64 siempre gana\n    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;\n\n    // f32 con i64/u64 promueve a f64 (preservacion de precision)\n    if (a == TYPE_F32 || b == TYPE_F32) {\n        ValueType other = (a == TYPE_F32) ? b : a;\n        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;\n        return TYPE_F32;\n    }\n\n    // Tipos enteros mas grandes ganan\n    int rank_a = get_type_rank(a);\n    int rank_b = get_type_rank(b);\n    return (rank_a > rank_b) ? a : b;\n}\n```\n\n**Rangos de tipos:**\n- i8: 0\n- u8: 1\n- i16: 2\n- u16: 3\n- i32: 4\n- u32: 5\n- i64: 6\n- u64: 7\n- f32: 8\n- f64: 9\n\n### Implementacion de Duck Typing\n\nLa verificacion de tipos de objetos usa comparacion estructural:\n\n```c\nbool duck_type_check(Object *obj, TypeDef *type_def) {\n    // Verificar todos los campos requeridos\n    for (each field in type_def) {\n        if (!object_has_field(obj, field.name)) {\n            return false;  // Campo faltante\n        }\n\n        Value *field_value = object_get_field(obj, field.name);\n        if (!type_matches(field_value, field.type)) {\n            return false;  // Tipo incorrecto\n        }\n    }\n\n    return true;  // Todos los campos requeridos presentes y tipo correcto\n}\n```\n\n**El duck typing permite:**\n- Campos extra en objetos (ignorados)\n- Tipado subestructural (objeto puede tener mas de lo requerido)\n- Asignacion de nombre de tipo despues de validacion\n\n---\n\n## Gestion de Memoria\n\n### Estrategia de Asignacion\n\nHemlock usa **gestion manual de memoria** con dos primitivas de asignacion:\n\n**1. Punteros crudos (`ptr`):**\n```c\nvoid *alloc(size_t bytes) {\n    void *ptr = malloc(bytes);\n    if (!ptr) {\n        fprintf(stderr, \"Sin memoria\\n\");\n        exit(1);\n    }\n    return ptr;\n}\n```\n- malloc/free directo\n- Sin seguimiento\n- Responsabilidad del usuario liberar\n\n**2. Buffers (`buffer`):**\n```c\ntypedef struct Buffer {\n    void *data;\n    size_t length;\n    size_t capacity;\n} Buffer;\n\nBuffer *create_buffer(size_t size) {\n    Buffer *buf = malloc(sizeof(Buffer));\n    buf->data = malloc(size);\n    buf->length = size;\n    buf->capacity = size;\n    return buf;\n}\n```\n- Rastrea tamano y capacidad\n- Verificacion de limites en acceso\n- Aun requiere free manual\n\n### Tipos Asignados en Heap\n\n**Strings:**\n- Array de bytes UTF-8 en heap\n- Terminado en null para interoperabilidad con C\n- Mutable (puede modificar en lugar)\n- Con conteo de referencias (auto-liberado cuando el alcance termina)\n\n**Objetos:**\n- Array de campos dinamico\n- Nombres y valores de campos en heap\n- Con conteo de referencias (auto-liberado cuando el alcance termina)\n- Referencias circulares posibles (manejadas con seguimiento de conjunto visitado)\n\n**Arrays:**\n- Crecimiento dinamico con duplicacion de capacidad\n- Elementos son estructuras Value incrustadas\n- Reasignacion automatica al crecer\n- Con conteo de referencias (auto-liberado cuando el alcance termina)\n\n**Closures:**\n- Captura entorno por referencia\n- Entorno asignado en heap\n- Entornos de closure se liberan apropiadamente cuando ya no se referencian\n\n---\n\n## Modelo de Concurrencia\n\n### Arquitectura de Hilos\n\nHemlock usa **hilos 1:1** con hilos POSIX (pthreads):\n\n```\nTarea de Usuario       Hilo del SO         Nucleo de CPU\n----------------       -----------         -------------\nspawn(f1) ------>  pthread_create --> Nucleo 0\nspawn(f2) ------>  pthread_create --> Nucleo 1\nspawn(f3) ------>  pthread_create --> Nucleo 2\n```\n\n**Caracteristicas clave:**\n- Cada `spawn()` crea un nuevo pthread\n- El kernel programa hilos a traves de nucleos\n- Ejecucion paralela verdadera (sin GIL)\n- Multitarea preventiva\n\n### Implementacion de Tareas\n\n```c\ntypedef struct Task {\n    pthread_t thread;        // Handle de hilo del SO\n    Value result;            // Valor de retorno\n    char *error;             // Mensaje de excepcion (si se lanzo)\n    pthread_mutex_t lock;    // Protege el estado\n    TaskState state;         // RUNNING, FINISHED, ERROR\n} Task;\n```\n\n**Ciclo de vida de tareas:**\n1. `spawn(func, args)`  Crear Task, iniciar pthread\n2. El hilo ejecuta la funcion con argumentos\n3. Al retornar: Almacenar resultado, establecer estado a FINISHED\n4. En excepcion: Almacenar mensaje de error, establecer estado a ERROR\n5. `join(task)`  Esperar al hilo, retornar resultado o lanzar excepcion\n\n### Implementacion de Canales\n\n```c\ntypedef struct Channel {\n    void **buffer;           // Buffer circular de Value*\n    size_t capacity;         // Maximo de elementos en buffer\n    size_t count;            // Elementos actuales en buffer\n    size_t read_index;       // Siguiente posicion de lectura\n    size_t write_index;      // Siguiente posicion de escritura\n    bool closed;             // Bandera de canal cerrado\n    pthread_mutex_t lock;    // Protege el buffer\n    pthread_cond_t not_full; // Senal cuando hay espacio disponible\n    pthread_cond_t not_empty;// Senal cuando hay datos disponibles\n} Channel;\n```\n\n**Operacion de envio:**\n1. Bloquear mutex\n2. Esperar si buffer lleno (cond_wait en not_full)\n3. Escribir valor en buffer[write_index]\n4. Incrementar write_index (circular)\n5. Senalar not_empty\n6. Desbloquear mutex\n\n**Operacion de recepcion:**\n1. Bloquear mutex\n2. Esperar si buffer vacio (cond_wait en not_empty)\n3. Leer valor de buffer[read_index]\n4. Incrementar read_index (circular)\n5. Senalar not_full\n6. Desbloquear mutex\n\n**Garantias de sincronizacion:**\n- Envio/recepcion seguro entre hilos (protegido por mutex)\n- Semantica bloqueante (productor espera si esta lleno, consumidor espera si esta vacio)\n- Entrega ordenada (FIFO dentro de un canal)\n\n---\n\n## Planes Futuros\n\n### Completado: Backend del Compilador\n\nEl backend del compilador (`hemlockc`) ha sido implementado con:\n- Generacion de codigo C desde AST\n- Verificacion de tipos en tiempo de compilacion (habilitada por defecto)\n- Biblioteca de runtime (`libhemlock_runtime.a`)\n- Paridad completa con el interprete (98% de tasa de aprobacion de pruebas)\n- Marco de optimizacion de desempaquetado\n\n### Enfoque Actual: Mejoras del Sistema de Tipos\n\n**Mejoras recientes:**\n- Sistemas unificados de verificacion de tipos e inferencia de tipos\n- Verificacion de tipos en tiempo de compilacion habilitada por defecto\n- Bandera `--check` para validacion solo de tipos\n- Contexto de tipos pasado a codegen para pistas de optimizacion\n\n### Mejoras Futuras\n\n**Adiciones potenciales:**\n- Genericos/plantillas\n- Coincidencia de patrones\n- Integracion LSP para soporte de IDE consciente de tipos\n- Optimizaciones de desempaquetado mas agresivas\n- Analisis de escape para asignacion en pila\n\n### Optimizaciones a Largo Plazo\n\n**Mejoras posibles:**\n- Cache en linea para llamadas a metodos\n- Compilacion JIT para caminos de codigo calientes\n- Programador de robo de trabajo para mejor concurrencia\n- Optimizacion guiada por perfil\n\n---\n\n## Directrices de Implementacion\n\n### Agregar Nuevas Caracteristicas\n\nAl implementar nuevas caracteristicas, siga estas directrices:\n\n**1. Elegir el modulo correcto:**\n- Nuevos tipos de valor  `values.c`\n- Conversiones de tipo  `types.c`\n- Funciones integradas  `builtins.c`\n- Operaciones de E/S  `io.c`\n- Flujo de control  `runtime.c`\n\n**2. Actualizar todas las capas:**\n- Agregar tipos de nodo AST si es necesario (`ast.h`, `ast.c`)\n- Agregar tokens de lexer si es necesario (`lexer.c`)\n- Agregar reglas de parser (`parser.c`)\n- Implementar comportamiento en runtime (`runtime.c` o modulo apropiado)\n- Agregar pruebas (`tests/`)\n\n**3. Mantener consistencia:**\n- Seguir el estilo de codigo existente\n- Usar convenciones de nomenclatura consistentes\n- Documentar API publica en headers\n- Mantener mensajes de error claros y consistentes\n\n**4. Probar exhaustivamente:**\n- Agregar casos de prueba antes de implementar\n- Probar caminos de exito y error\n- Probar casos limite\n- Verificar que no haya fugas de memoria (valgrind)\n\n### Consideraciones de Rendimiento\n\n**Cuellos de botella actuales:**\n- Busquedas en HashMap para acceso a variables\n- Llamadas a funciones recursivas (sin TCO)\n- Concatenacion de strings (asigna nuevo string cada vez)\n- Sobrecarga de verificacion de tipos en cada operacion\n\n**Oportunidades de optimizacion:**\n- Cachear ubicaciones de variables (cache en linea)\n- Optimizacion de llamada de cola\n- Constructor de strings para concatenacion\n- Inferencia de tipos para omitir verificaciones en tiempo de ejecucion\n\n### Consejos de Depuracion\n\n**Herramientas utiles:**\n- `valgrind` - Deteccion de fugas de memoria\n- `gdb` - Depurar crashes\n- Bandera `-g` - Simbolos de depuracion\n- Depuracion con `printf` - Simple pero efectivo\n\n**Problemas comunes:**\n- Segfault  Desreferencia de puntero nulo (verificar valores de retorno)\n- Fuga de memoria  Llamada a free() faltante (verificar caminos de value_free)\n- Error de tipo  Verificar logica de type_convert() y type_check()\n- Crash en hilos  Condicion de carrera (verificar uso de mutex)\n\n---\n\n## Conclusion\n\nLa implementacion de Hemlock prioriza:\n- **Modularidad** - Separacion limpia de responsabilidades\n- **Simplicidad** - Implementacion directa\n- **Explicitud** - Sin magia oculta\n- **Mantenibilidad** - Facil de entender y modificar\n\nEl actual interprete de recorrido de arbol es intencionalmente simple para facilitar el desarrollo rapido de caracteristicas y la experimentacion. El futuro backend del compilador mejorara el rendimiento manteniendo la misma semantica.\n"}, "Diseo y Filosofa -> Sintaxis de Firmas": {"id": "design-signature-syntax", "content": "# Diseno de Sintaxis de Firmas\n\n> Extendiendo el sistema de tipos de Hemlock con tipos de funcion, modificadores nullables, alias de tipos, parametros const y firmas de metodos.\n\n**Estado:** Implementado (v1.7.0)\n**Version:** 1.0\n**Autor:** Claude\n\n---\n\n## Vision General\n\nEste documento propone cinco extensiones interconectadas del sistema de tipos que se construyen sobre la infraestructura existente de Hemlock:\n\n1. **Anotaciones de Tipos de Funcion** - Tipos de funcion de primera clase\n2. **Modificadores de Tipo Nullable** - Manejo explicito de null (extiende la bandera `nullable` existente)\n3. **Alias de Tipos** - Abreviaciones de tipos con nombre\n4. **Parametros Const** - Contratos de inmutabilidad\n5. **Firmas de Metodos en Define** - Comportamiento similar a interfaces\n\nEstas caracteristicas comparten la filosofia: **explicito sobre implicito, opcional pero aplicado cuando se usa**.\n\n---\n\n## 1. Anotaciones de Tipos de Funcion\n\n### Motivacion\n\nActualmente, no hay forma de expresar la firma de una funcion como un tipo:\n\n```hemlock\n// Actual: callback no tiene informacion de tipo\nfn map(arr: array, callback) { ... }\n\n// Propuesto: tipo de funcion explicito\nfn map(arr: array, callback: fn(any, i32): any): array { ... }\n```\n\n### Sintaxis\n\n```hemlock\n// Tipo de funcion basico\nfn(i32, i32): i32\n\n// Con nombres de parametros (solo documentacion, no se aplica)\nfn(a: i32, b: i32): i32\n\n// Sin valor de retorno (void)\nfn(string): void\nfn(string)              // Abreviatura: omitir `: void`\n\n// Retorno nullable\nfn(i32): string?\n\n// Parametros opcionales\nfn(name: string, age?: i32): void\n\n// Parametros rest\nfn(...args: array): i32\n\n// Sin parametros\nfn(): bool\n\n// Orden superior: funcion que retorna funcion\nfn(i32): fn(i32): i32\n\n// Tipo de funcion async\nasync fn(i32): i32\n```\n\n### Ejemplos de Uso\n\n```hemlock\n// Variable con tipo de funcion\nlet add: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// Parametro de funcion\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// El tipo de retorno es una funcion\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Array de funciones\nlet ops: array<fn(i32, i32): i32> = [add, subtract, multiply];\n\n// Campo de objeto\ndefine EventHandler {\n    name: string;\n    callback: fn(Event): void;\n}\n```\n\n### Cambios en el AST\n\n```c\n// En enum TypeKind (include/ast.h)\ntypedef enum {\n    // ... tipos existentes ...\n    TYPE_FUNCTION,      // NUEVO: Tipo de funcion\n} TypeKind;\n\n// En struct Type (include/ast.h)\nstruct Type {\n    TypeKind kind;\n    // ... campos existentes ...\n\n    // Para TYPE_FUNCTION:\n    struct Type **param_types;      // Tipos de parametros\n    char **param_names;             // Nombres de parametros opcionales (docs)\n    int *param_optional;            // Cuales parametros son opcionales\n    int num_params;\n    char *rest_param_name;          // Nombre de parametro rest o NULL\n    struct Type *rest_param_type;   // Tipo de parametro rest\n    struct Type *return_type;       // Tipo de retorno (NULL = void)\n    int is_async;                   // tipo fn async\n};\n```\n\n### Parsing\n\nLos tipos de funcion comienzan con `fn` (o `async fn`) seguido de lista de parametros:\n\n```\nfunction_type := [\"async\"] \"fn\" \"(\" [param_type_list] \")\" [\":\" type]\nparam_type_list := param_type (\",\" param_type)*\nparam_type := [identifier \":\"] [\"?\"] type | \"...\" [identifier] [\":\" type]\n```\n\n**Desambiguacion:** Al parsear un tipo y encontrar `fn`:\n- Si va seguido de `(`, es un tipo de funcion\n- De lo contrario, error de sintaxis (`fn` solo no es un tipo valido)\n\n### Compatibilidad de Tipos\n\n```hemlock\n// Se requiere coincidencia exacta para tipos de funcion\nlet f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // OK\n\n// Contravarianza de parametros (aceptar tipos mas amplios esta bien)\nlet g: fn(any): i32 = fn(x: i32): i32 { return x; };  // OK: i32 <: any\n\n// Covarianza de retorno (retornar tipos mas estrechos esta bien)\nlet h: fn(i32): any = fn(x: i32): i32 { return x; };  // OK: i32 <: any\n\n// La aridad debe coincidir\nlet bad: fn(i32): i32 = fn(a, b) { return a; };       // ERROR: aridad no coincide\n\n// Parametros opcionales compatibles con requeridos\nlet opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // OK\n```\n\n---\n\n## 2. Modificadores de Tipo Nullable\n\n### Motivacion\n\nEl sufijo `?` hace explicita la aceptacion de null en las firmas:\n\n```hemlock\n// Actual: no esta claro si null es valido\nfn find(arr: array, val: any): i32 { ... }\n\n// Propuesto: retorno nullable explicito\nfn find(arr: array, val: any): i32? { ... }\n```\n\n### Sintaxis\n\n```hemlock\n// Tipos nullables con sufijo ?\nstring?           // string o null\ni32?              // i32 o null\nUser?             // User o null\narray<i32>?       // array o null\nfn(i32): i32?     // funcion que retorna i32 o null\n\n// Composicion con tipos de funcion\nfn(string?): i32          // Acepta string o null\nfn(string): i32?          // Retorna i32 o null\nfn(string?): i32?         // Ambos nullables\n\n// En define\ndefine Result {\n    value: any?;\n    error: string?;\n}\n```\n\n### Notas de Implementacion\n\n**Ya existe:** La bandera `Type.nullable` ya esta en el AST. Esta caracteristica principalmente necesita:\n1. Soporte del parser para sufijo `?` en cualquier tipo (verificar/extender)\n2. Composicion adecuada con tipos de funcion\n3. Aplicacion en tiempo de ejecucion\n\n### Compatibilidad de Tipos\n\n```hemlock\n// No-nullable asignable a nullable\nlet x: i32? = 42;           // OK\nlet y: i32? = null;         // OK\n\n// Nullable NO asignable a no-nullable\nlet z: i32 = x;             // ERROR: x podria ser null\n\n// Coalescencia null para desenvolver\nlet z: i32 = x ?? 0;        // OK: ?? proporciona valor por defecto\n\n// Encadenamiento opcional retorna nullable\nlet name: string? = user?.name;\n```\n\n---\n\n## 3. Alias de Tipos\n\n### Motivacion\n\nLos tipos complejos se benefician de abreviaciones con nombre:\n\n```hemlock\n// Actual: tipos compuestos repetitivos\nfn process(entity: HasName & HasId & HasTimestamp) { ... }\nfn validate(entity: HasName & HasId & HasTimestamp) { ... }\n\n// Propuesto: alias con nombre\ntype Entity = HasName & HasId & HasTimestamp;\nfn process(entity: Entity) { ... }\nfn validate(entity: Entity) { ... }\n```\n\n### Sintaxis\n\n```hemlock\n// Alias basico\ntype Integer = i32;\ntype Text = string;\n\n// Alias de tipo compuesto\ntype Entity = HasName & HasId;\ntype Auditable = HasCreatedAt & HasUpdatedAt & HasCreatedBy;\n\n// Alias de tipo de funcion\ntype Callback = fn(Event): void;\ntype Predicate = fn(any): bool;\ntype Reducer = fn(acc: any, val: any): any;\ntype AsyncTask = async fn(): any;\n\n// Alias nullable\ntype OptionalString = string?;\n\n// Alias generico (si soportamos alias de tipos genericos)\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// Alias de tipo array\ntype IntArray = array<i32>;\ntype Matrix = array<array<f64>>;\n```\n\n### Alcance y Visibilidad\n\n```hemlock\n// Alcance de modulo por defecto\ntype Callback = fn(Event): void;\n\n// Exportable\nexport type Handler = fn(Request): Response;\n\n// En otro archivo\nimport { Handler } from \"./handlers.hml\";\nfn register(h: Handler) { ... }\n```\n\n### Cambios en el AST\n\n```c\n// Nuevo tipo de sentencia\ntypedef enum {\n    // ... sentencias existentes ...\n    STMT_TYPE_ALIAS,    // NUEVO\n} StmtKind;\n\n// En union Stmt\nstruct {\n    char *name;                 // Nombre del alias\n    char **type_params;         // Parametros genericos: <T, U>\n    int num_type_params;\n    Type *aliased_type;         // El tipo real\n} type_alias;\n```\n\n### Parsing\n\n```\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n```\n\n**Nota:** `type` es una nueva palabra clave. Verificar conflictos con identificadores existentes.\n\n### Resolucion\n\nLos alias de tipos se resuelven en:\n- **Tiempo de parsing:** Alias registrado en entorno de tipos\n- **Tiempo de verificacion:** Alias expandido al tipo subyacente\n- **Tiempo de ejecucion:** Alias es transparente (igual que el tipo subyacente)\n\n```hemlock\ntype MyInt = i32;\nlet x: MyInt = 42;\ntypeof(x);           // \"i32\" (no \"MyInt\")\n```\n\n---\n\n## 4. Parametros Const\n\n### Motivacion\n\nSenalar la intencion de inmutabilidad en firmas de funcion:\n\n```hemlock\n// Actual: no esta claro si el array se modificara\nfn print_all(items: array) { ... }\n\n// Propuesto: contrato de inmutabilidad explicito\nfn print_all(const items: array) { ... }\n```\n\n### Sintaxis\n\n```hemlock\n// Parametro const\nfn process(const data: buffer) {\n    // data[0] = 0;        // ERROR: no puede mutar const\n    let x = data[0];       // OK: lectura permitida\n    return x;\n}\n\n// Multiples parametros const\nfn compare(const a: array, const b: array): bool { ... }\n\n// Mezcla de const y mutable\nfn update(const source: array, target: array) {\n    for (item in source) {\n        target.push(item);   // OK: target es mutable\n    }\n}\n\n// Const con inferencia de tipos\nfn log(const msg) {\n    print(msg);\n}\n\n// Const en tipos de funcion\ntype Reader = fn(const buffer): i32;\n```\n\n### Que Previene Const\n\n```hemlock\nfn bad(const arr: array) {\n    arr.push(1);         // ERROR: metodo mutante\n    arr.pop();           // ERROR: metodo mutante\n    arr[0] = 5;          // ERROR: asignacion por indice\n    arr.clear();         // ERROR: metodo mutante\n}\n\nfn ok(const arr: array) {\n    let x = arr[0];      // OK: lectura\n    let len = len(arr);  // OK: verificacion de longitud\n    let copy = arr.slice(0, 10);  // OK: crea nuevo array\n    for (item in arr) {  // OK: iteracion\n        print(item);\n    }\n}\n```\n\n### Metodos Mutantes vs No-Mutantes\n\n| Tipo | Mutante (bloqueado por const) | No-Mutante (permitido) |\n|------|------------------------------|------------------------|\n| array | push, pop, shift, unshift, insert, remove, clear, reverse (in-place) | slice, concat, map, filter, find, contains, first, last, join |\n| string | asignacion por indice (`s[0] = 'x'`) | todos los metodos (retornan nuevos strings) |\n| buffer | asignacion por indice, memset, memcpy (hacia) | lectura por indice, slice |\n| object | asignacion de campo | lectura de campo |\n\n### Cambios en el AST\n\n```c\n// En expresion de funcion (include/ast.h)\nstruct {\n    // ... campos existentes ...\n    int *param_is_const;    // NUEVO: 1 si es const, 0 en caso contrario\n} function;\n\n// En struct Type para tipos de funcion\nstruct Type {\n    // ... campos existentes ...\n    int *param_is_const;    // Para TYPE_FUNCTION\n};\n```\n\n### Aplicacion\n\n**Interprete:**\n- Rastrear estado const en vinculaciones de variables\n- Verificar antes de operaciones de mutacion\n- Error en tiempo de ejecucion por violacion de const\n\n**Compilador:**\n- Emitir variables C calificadas con const donde sea beneficioso\n- Analisis estatico para violaciones de const\n- Advertencia/error en tiempo de compilacion\n\n---\n\n## 5. Firmas de Metodos en Define\n\n### Motivacion\n\nPermitir que los bloques `define` especifiquen metodos esperados, no solo campos de datos:\n\n```hemlock\n// Actual: solo campos de datos\ndefine User {\n    name: string;\n    age: i32;\n}\n\n// Propuesto: firmas de metodos\ndefine Comparable {\n    fn compare(other: Self): i32;\n}\n\ndefine Serializable {\n    fn serialize(): string;\n    fn deserialize(data: string): Self;  // Metodo estatico\n}\n```\n\n### Sintaxis\n\n```hemlock\n// Firma de metodo (sin cuerpo)\ndefine Hashable {\n    fn hash(): i32;\n}\n\n// Multiples metodos\ndefine Collection {\n    fn size(): i32;\n    fn is_empty(): bool;\n    fn contains(item: any): bool;\n}\n\n// Campos y metodos mezclados\ndefine Entity {\n    id: i32;\n    name: string;\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\n// Usando tipo Self\ndefine Cloneable {\n    fn clone(): Self;\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;\n    fn equals(other: Self): bool;\n}\n\n// Metodos opcionales\ndefine Printable {\n    fn to_string(): string;\n    fn debug_string?(): string;  // Metodo opcional (puede estar ausente)\n}\n\n// Metodos con implementaciones por defecto\ndefine Ordered {\n    fn compare(other: Self): i32;  // Requerido\n\n    // Implementaciones por defecto (heredadas si no se sobrescriben)\n    fn less_than(other: Self): bool {\n        return self.compare(other) < 0;\n    }\n    fn greater_than(other: Self): bool {\n        return self.compare(other) > 0;\n    }\n    fn equals(other: Self): bool {\n        return self.compare(other) == 0;\n    }\n}\n```\n\n### El Tipo `Self`\n\n`Self` se refiere al tipo concreto que implementa la interfaz:\n\n```hemlock\ndefine Addable {\n    fn add(other: Self): Self;\n}\n\n// Cuando se usa:\nlet a: Addable = {\n    value: 10,\n    add: fn(other) {\n        return { value: self.value + other.value, add: self.add };\n    }\n};\n```\n\n### Tipado Estructural (Duck Typing)\n\nLas firmas de metodos usan el mismo duck typing que los campos:\n\n```hemlock\ndefine Stringifiable {\n    fn to_string(): string;\n}\n\n// Cualquier objeto con metodo to_string() satisface Stringifiable\nlet x: Stringifiable = {\n    name: \"test\",\n    to_string: fn() { return self.name; }\n};\n\n// Tipos compuestos con metodos\ndefine Named { name: string; }\ndefine Printable { fn to_string(): string; }\n\ntype NamedPrintable = Named & Printable;\n\nlet y: NamedPrintable = {\n    name: \"Alice\",\n    to_string: fn() { return \"Name: \" + self.name; }\n};\n```\n\n### Cambios en el AST\n\n```c\n// Extender define_object en union Stmt\nstruct {\n    char *name;\n    char **type_params;\n    int num_type_params;\n\n    // Campos (existentes)\n    char **field_names;\n    Type **field_types;\n    int *field_optional;\n    Expr **field_defaults;\n    int num_fields;\n\n    // Metodos (NUEVO)\n    char **method_names;\n    Type **method_types;        // TYPE_FUNCTION\n    int *method_optional;       // Metodos opcionales (fn name?(): type)\n    Expr **method_defaults;     // Implementaciones por defecto (NULL si solo firma)\n    int num_methods;\n} define_object;\n```\n\n### Verificacion de Tipos\n\nAl verificar `value: InterfaceType`:\n1. Verificar que todos los campos requeridos existen con tipos compatibles\n2. Verificar que todos los metodos requeridos existen con firmas compatibles\n3. Campos/metodos opcionales pueden estar ausentes\n\n```hemlock\ndefine Sortable {\n    fn compare(other: Self): i32;\n}\n\n// Valido: tiene metodo compare\nlet valid: Sortable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// Invalido: falta compare\nlet invalid: Sortable = { value: 10 };  // ERROR: falta metodo 'compare'\n\n// Invalido: firma incorrecta\nlet wrong: Sortable = {\n    compare: fn() { return 0; }  // ERROR: se esperaba (Self): i32\n};\n```\n\n---\n\n## Ejemplos de Interaccion\n\n### Combinando Todas las Caracteristicas\n\n```hemlock\n// Alias de tipo para tipo de funcion complejo\ntype EventCallback = fn(event: Event, context: Context?): bool;\n\n// Alias de tipo para interfaz compuesta\ntype Entity = HasId & HasName & Serializable;\n\n// Define con firmas de metodos\ndefine Repository<T> {\n    fn find(id: i32): T?;\n    fn save(const entity: T): bool;\n    fn delete(id: i32): bool;\n    fn find_all(predicate: fn(T): bool): array<T>;\n}\n\n// Usando todo junto\nfn create_user_repo(): Repository<User> {\n    let users: array<User> = [];\n\n    return {\n        find: fn(id) {\n            for (u in users) {\n                if (u.id == id) { return u; }\n            }\n            return null;\n        },\n        save: fn(const entity) {\n            users.push(entity);\n            return true;\n        },\n        delete: fn(id) {\n            // ...\n            return true;\n        },\n        find_all: fn(predicate) {\n            return users.filter(predicate);\n        }\n    };\n}\n```\n\n### Callbacks con Tipos Explicitos\n\n```hemlock\ntype ClickHandler = fn(event: MouseEvent): void;\ntype KeyHandler = fn(event: KeyEvent, modifiers: i32): bool;\n\ndefine Widget {\n    x: i32;\n    y: i32;\n    on_click: ClickHandler?;\n    on_key: KeyHandler?;\n}\n\nfn create_button(label: string, handler: ClickHandler): Widget {\n    return {\n        x: 0, y: 0,\n        on_click: handler,\n        on_key: null\n    };\n}\n```\n\n### Tipos de Funcion Nullables\n\n```hemlock\n// Callback opcional\nfn fetch(url: string, on_complete: fn(Response): void?): void {\n    let response = http_get(url);\n    if (on_complete != null) {\n        on_complete(response);\n    }\n}\n\n// Retorno nullable de tipo de funcion\ntype Parser = fn(input: string): AST?;\n\nfn try_parse(parsers: array<Parser>, input: string): AST? {\n    for (p in parsers) {\n        let result = p(input);\n        if (result != null) {\n            return result;\n        }\n    }\n    return null;\n}\n```\n\n---\n\n## Hoja de Ruta de Implementacion\n\n### Fase 1: Infraestructura Central\n1. Agregar `TYPE_FUNCTION` al enum TypeKind\n2. Extender struct Type con campos de tipo de funcion\n3. Agregar `CHECKED_FUNCTION` al verificador de tipos del compilador\n4. Agregar soporte de tipo `Self` (TYPE_SELF)\n\n### Fase 2: Parsing\n1. Implementar `parse_function_type()` en el parser\n2. Manejar `fn(...)` en posicion de tipo\n3. Agregar palabra clave `type` y parsing de `STMT_TYPE_ALIAS`\n4. Agregar parsing de modificador de parametro `const`\n5. Extender parsing de define para firmas de metodos\n\n### Fase 3: Verificacion de Tipos\n1. Reglas de compatibilidad de tipos de funcion\n2. Resolucion y expansion de alias de tipos\n3. Verificacion de mutacion de parametros const\n4. Validacion de firmas de metodos en tipos define\n5. Resolucion de tipo Self\n\n### Fase 4: Runtime\n1. Validacion de tipo de funcion en sitios de llamada\n2. Deteccion de violacion de const\n3. Transparencia de alias de tipos\n\n### Fase 5: Pruebas de Paridad\n1. Pruebas de anotacion de tipos de funcion\n2. Pruebas de composicion nullable\n3. Pruebas de alias de tipos\n4. Pruebas de parametros const\n5. Pruebas de firmas de metodos\n\n---\n\n## Decisiones de Diseno\n\n### 1. Alias de Tipos Genericos: **SI**\n\nLos alias de tipos soportan parametros genericos:\n\n```hemlock\n// Alias de tipos genericos\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\ntype Mapper<T, U> = fn(T): U;\ntype AsyncResult<T> = async fn(): T?;\n\n// Uso\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\nlet result: Result<User, string> = { value: user, error: null };\nlet transform: Mapper<i32, string> = fn(n) { return n.to_string(); };\n```\n\n### 2. Propagacion de Const: **PROFUNDA**\n\nLos parametros const son completamente inmutables - sin mutacion a traves de ninguna ruta:\n\n```hemlock\nfn process(const arr: array<object>) {\n    arr.push({});        // ERROR: no puede mutar array const\n    arr[0] = {};         // ERROR: no puede mutar array const\n    arr[0].x = 5;        // ERROR: no puede mutar a traves de const (PROFUNDO)\n\n    let x = arr[0].x;    // OK: leer esta bien\n    let copy = arr[0];   // OK: crea una copia\n    copy.x = 5;          // OK: copy no es const\n}\n\nfn nested(const obj: object) {\n    obj.user.name = \"x\"; // ERROR: const profundo previene mutacion anidada\n    obj.items[0] = 1;    // ERROR: const profundo previene mutacion anidada\n}\n```\n\n**Justificacion:** Const profundo proporciona garantias mas fuertes y es mas util para\nasegurar integridad de datos. Si necesita mutar datos anidados, haga una copia primero.\n\n### 3. Self en Alias de Tipos Independientes: **NO**\n\n`Self` solo es valido dentro de bloques `define` donde tiene un significado claro:\n\n```hemlock\n// Valido: Self se refiere al tipo definido\ndefine Comparable {\n    fn compare(other: Self): i32;\n}\n\n// Invalido: Self no tiene significado aqui\ntype Cloner = fn(Self): Self;  // ERROR: Self fuera de contexto define\n\n// En su lugar, usar genericos:\ntype Cloner<T> = fn(T): T;\n```\n\n### 4. Implementaciones por Defecto de Metodos: **SI (Solo Simples)**\n\nPermitir implementaciones por defecto para metodos simples/utilitarios:\n\n```hemlock\ndefine Comparable {\n    // Requerido: debe ser implementado\n    fn compare(other: Self): i32;\n\n    // Implementaciones por defecto (metodos de conveniencia simples)\n    fn equals(other: Self): bool {\n        return self.compare(other) == 0;\n    }\n    fn less_than(other: Self): bool {\n        return self.compare(other) < 0;\n    }\n    fn greater_than(other: Self): bool {\n        return self.compare(other) > 0;\n    }\n}\n\ndefine Printable {\n    fn to_string(): string;\n\n    // Por defecto: delega al metodo requerido\n    fn print() {\n        print(self.to_string());\n    }\n    fn println() {\n        print(self.to_string() + \"\\n\");\n    }\n}\n\n// El objeto solo necesita implementar metodos requeridos\nlet item: Comparable = {\n    value: 42,\n    compare: fn(other) { return self.value - other.value; }\n    // equals, less_than, greater_than se heredan de los valores por defecto\n};\n\nitem.less_than({ value: 50, compare: item.compare });  // true\n```\n\n**Directrices para valores por defecto:**\n- Mantenerlos simples (1-3 lineas)\n- Deben delegar a metodos requeridos\n- Sin logica compleja ni efectos secundarios\n- Solo primitivas y composiciones directas\n\n### 5. Varianza: **INFERIDA (Sin Anotaciones Explicitas)**\n\nLa varianza se infiere de como se usan los parametros de tipo:\n\n```hemlock\n// La varianza es automatica basada en posicion\ntype Producer<T> = fn(): T;           // T en retorno = covariante\ntype Consumer<T> = fn(T): void;       // T en parametro = contravariante\ntype Transformer<T> = fn(T): T;       // T en ambos = invariante\n\n// Ejemplo: Dog <: Animal (Dog es subtipo de Animal)\nlet dog_producer: Producer<Dog> = fn() { return new_dog(); };\nlet animal_producer: Producer<Animal> = dog_producer;  // OK: covariante\n\nlet animal_consumer: Consumer<Animal> = fn(a) { print(a); };\nlet dog_consumer: Consumer<Dog> = animal_consumer;     // OK: contravariante\n```\n\n**Por que inferir?**\n- Menos codigo repetitivo (`<out T>` / `<in T>` agrega ruido)\n- Sigue \"explicito sobre implicito\" - la posicion ES explicita\n- Coincide con como la mayoria de los lenguajes manejan la varianza de tipos de funcion\n- Los errores son claros cuando se violan las reglas de varianza\n\n---\n\n## Apendice: Cambios en la Gramatica\n\n```ebnf\n(* Tipos *)\ntype := simple_type | compound_type | function_type\nsimple_type := base_type [\"?\"] | identifier [\"<\" type_args \">\"] [\"?\"]\ncompound_type := simple_type (\"&\" simple_type)+\nfunction_type := [\"async\"] \"fn\" \"(\" [param_types] \")\" [\":\" type]\n\nbase_type := \"i8\" | \"i16\" | \"i32\" | \"i64\"\n           | \"u8\" | \"u16\" | \"u32\" | \"u64\"\n           | \"f32\" | \"f64\" | \"bool\" | \"string\" | \"rune\"\n           | \"ptr\" | \"buffer\" | \"void\" | \"null\"\n           | \"array\" [\"<\" type \">\"]\n           | \"object\"\n           | \"Self\"\n\nparam_types := param_type (\",\" param_type)*\nparam_type := [\"const\"] [identifier \":\"] [\"?\"] type\n            | \"...\" [identifier] [\":\" type]\n\ntype_args := type (\",\" type)*\n\n(* Sentencias *)\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n\ndefine_stmt := \"define\" identifier [\"<\" type_params \">\"] \"{\" define_members \"}\"\ndefine_members := (field_def | method_def)*\nfield_def := identifier (\":\" type [\"=\" expr] | \"?:\" (type | expr)) \";\"?\nmethod_def := \"fn\" identifier [\"?\"] \"(\" [param_types] \")\" [\":\" type] (block | \";\")\n            (* \"?\" marca metodo opcional, block proporciona implementacion por defecto *)\n\n(* Parametros *)\nparam := [\"const\"] [\"ref\"] identifier [\":\" type] [\"?:\" expr]\n       | \"...\" identifier [\":\" type]\n```\n"}, "Contribuir -> Guas de Contribucin": {"id": "contributing-guidelines", "content": "# Contribuir a Hemlock\n\nGracias por tu inters en contribuir a Hemlock. Esta gua te ayudar a entender cmo contribuir de manera efectiva mientras mantienes la filosofa de diseo del lenguaje y la calidad del cdigo.\n\n---\n\n## Tabla de Contenidos\n\n- [Antes de Comenzar](#antes-de-comenzar)\n- [Flujo de Trabajo de Contribucin](#flujo-de-trabajo-de-contribucin)\n- [Gua de Estilo de Cdigo](#gua-de-estilo-de-cdigo)\n- [Qu Contribuir](#qu-contribuir)\n- [Qu NO Contribuir](#qu-no-contribuir)\n- [Patrones Comunes](#patrones-comunes)\n- [Agregar Nuevas Funcionalidades](#agregar-nuevas-funcionalidades)\n- [Proceso de Revisin de Cdigo](#proceso-de-revisin-de-cdigo)\n\n---\n\n## Antes de Comenzar\n\n### Lectura Requerida\n\nAntes de contribuir, por favor lee estos documentos en orden:\n\n1. **`/home/user/hemlock/docs/design/philosophy.md`** - Comprende los principios fundamentales de Hemlock\n2. **`/home/user/hemlock/docs/design/implementation.md`** - Aprende la estructura del cdigo base\n3. **`/home/user/hemlock/docs/contributing/testing.md`** - Comprende los requisitos de pruebas\n4. **Este documento** - Aprende las guas de contribucin\n\n### Prerrequisitos\n\n**Conocimiento requerido:**\n- Programacin en C (punteros, gestin de memoria, estructuras)\n- Fundamentos de compiladores/intrpretes (anlisis lxico, sintctico, AST)\n- Flujo de trabajo con Git y GitHub\n- Lnea de comandos Unix/Linux\n\n**Herramientas requeridas:**\n- Compilador GCC o Clang\n- Sistema de compilacin Make\n- Control de versiones Git\n- Valgrind (para deteccin de fugas de memoria)\n- Editor de texto bsico o IDE\n\n### Canales de Comunicacin\n\n**Dnde hacer preguntas:**\n- GitHub Issues - Reportes de errores y solicitudes de funcionalidades\n- GitHub Discussions - Preguntas generales y discusiones de diseo\n- Comentarios en Pull Request - Retroalimentacin especfica de cdigo\n\n---\n\n## Flujo de Trabajo de Contribucin\n\n### 1. Encontrar o Crear un Issue\n\n**Antes de escribir cdigo:**\n- Verifica si existe un issue para tu contribucin\n- Si no existe, crea uno describiendo lo que quieres hacer\n- Espera retroalimentacin de los mantenedores antes de comenzar cambios grandes\n- Las correcciones pequeas de errores pueden omitir este paso\n\n**Las buenas descripciones de issues incluyen:**\n- Declaracin del problema (qu est roto o falta)\n- Solucin propuesta (cmo planeas solucionarlo)\n- Ejemplos (fragmentos de cdigo mostrando el problema)\n- Justificacin (por qu este cambio se alinea con la filosofa de Hemlock)\n\n### 2. Fork y Clone\n\n```bash\n# Fork the repository on GitHub first, then:\ngit clone https://github.com/YOUR_USERNAME/hemlock.git\ncd hemlock\ngit checkout -b feature/your-feature-name\n```\n\n### 3. Hacer tus Cambios\n\nSigue estas directrices:\n- Escribe las pruebas primero (enfoque TDD)\n- Implementa la funcionalidad\n- Asegrate de que todas las pruebas pasen\n- Verifica fugas de memoria\n- Actualiza la documentacin\n\n### 4. Probar tus Cambios\n\n```bash\n# Run the full test suite\nmake test\n\n# Run specific test category\n./tests/run_tests.sh tests/category/\n\n# Check for memory leaks\nvalgrind ./hemlock tests/your_test.hml\n\n# Build and test\nmake clean && make && make test\n```\n\n### 5. Hacer Commit de tus Cambios\n\n**Buenos mensajes de commit:**\n```\nAdd bitwise operators for integer types\n\n- Implement &, |, ^, <<, >>, ~ operators\n- Add type checking to ensure integer-only operations\n- Update operator precedence table\n- Add comprehensive tests for all operators\n\nCloses #42\n```\n\n**Formato del mensaje de commit:**\n- Primera lnea: Resumen breve (mximo 50 caracteres)\n- Lnea en blanco\n- Explicacin detallada (ajustar a 72 caracteres)\n- Referenciar nmeros de issue\n\n### 6. Enviar un Pull Request\n\n**Antes de enviar:**\n- Haz rebase sobre la ltima rama main\n- Asegrate de que todas las pruebas pasen\n- Ejecuta valgrind para verificar fugas\n- Actualiza CLAUDE.md si agregas funcionalidades visibles al usuario\n\n**La descripcin del pull request debe incluir:**\n- Qu problema resuelve\n- Cmo lo resuelve\n- Cambios incompatibles (si los hay)\n- Ejemplos de nueva sintaxis o comportamiento\n- Resumen de cobertura de pruebas\n\n---\n\n## Gua de Estilo de Cdigo\n\n### Estilo de Cdigo C\n\n**Formato:**\n```c\n// Indent with 4 spaces (no tabs)\n// K&R brace style for functions\nvoid function_name(int arg1, char *arg2)\n{\n    if (condition) {\n        // Brace on same line for control structures\n        do_something();\n    }\n}\n\n// Line length: 100 characters max\n// Use spaces around operators\nint result = (a + b) * c;\n\n// Pointer asterisk with type\nchar *string;   // Good\nchar* string;   // Avoid\nchar * string;  // Avoid\n```\n\n**Convenciones de nombres:**\n```c\n// Functions: lowercase_with_underscores\nvoid eval_expression(ASTNode *node);\n\n// Types: PascalCase\ntypedef struct Value Value;\ntypedef enum ValueType ValueType;\n\n// Constants: UPPERCASE_WITH_UNDERSCORES\n#define MAX_BUFFER_SIZE 4096\n\n// Variables: lowercase_with_underscores\nint item_count;\nValue *current_value;\n\n// Enums: TYPE_PREFIX_NAME\ntypedef enum {\n    TYPE_I32,\n    TYPE_STRING,\n    TYPE_OBJECT\n} ValueType;\n```\n\n**Comentarios:**\n```c\n// Single-line comments for brief explanations\n// Use complete sentences with proper capitalization\n\n/*\n * Multi-line comments for longer explanations\n * Align asterisks for readability\n */\n\n/**\n * Function documentation comment\n * @param node - AST node to evaluate\n * @return Evaluated value\n */\nValue eval_expr(ASTNode *node);\n```\n\n**Manejo de errores:**\n```c\n// Check all malloc calls\nchar *buffer = malloc(size);\nif (!buffer) {\n    fprintf(stderr, \"Error: Out of memory\\n\");\n    exit(1);\n}\n\n// Provide context in error messages\nif (file == NULL) {\n    fprintf(stderr, \"Error: Failed to open '%s': %s\\n\",\n            filename, strerror(errno));\n    exit(1);\n}\n\n// Use meaningful error messages\n// Bad: \"Error: Invalid value\"\n// Good: \"Error: Expected integer, got string\"\n```\n\n**Gestin de memoria:**\n```c\n// Always free what you allocate\nValue *val = value_create_i32(42);\n// ... use val\nvalue_free(val);\n\n// Set pointers to NULL after freeing (prevents double-free)\nfree(ptr);\nptr = NULL;\n\n// Document ownership in comments\n// This function takes ownership of 'value' and will free it\nvoid store_value(Value *value);\n\n// This function does NOT take ownership (caller must free)\nValue *get_value(void);\n```\n\n### Organizacin del Cdigo\n\n**Estructura de archivos:**\n```c\n// 1. Includes (system headers first, then local)\n#include <stdio.h>\n#include <stdlib.h>\n#include \"internal.h\"\n#include \"values.h\"\n\n// 2. Constants and macros\n#define INITIAL_CAPACITY 16\n\n// 3. Type definitions\ntypedef struct Foo Foo;\n\n// 4. Static function declarations (internal helpers)\nstatic void helper_function(void);\n\n// 5. Public function implementations\nvoid public_api_function(void)\n{\n    // Implementation\n}\n\n// 6. Static function implementations\nstatic void helper_function(void)\n{\n    // Implementation\n}\n```\n\n**Archivos de cabecera:**\n```c\n// Use header guards\n#ifndef HEMLOCK_MODULE_H\n#define HEMLOCK_MODULE_H\n\n// Forward declarations\ntypedef struct Value Value;\n\n// Public API only in headers\nvoid public_function(Value *val);\n\n// Document parameters and return values\n/**\n * Evaluates an expression AST node\n * @param node - The AST node to evaluate\n * @param env - The current environment\n * @return The result value\n */\nValue *eval_expr(ASTNode *node, Environment *env);\n\n#endif // HEMLOCK_MODULE_H\n```\n\n---\n\n## Qu Contribuir\n\n### Contribuciones Recomendadas\n\n**Correcciones de errores:**\n- Fugas de memoria\n- Fallos de segmentacin\n- Comportamiento incorrecto\n- Mejoras en mensajes de error\n\n**Documentacin:**\n- Comentarios de cdigo\n- Documentacin de API\n- Guas de usuario y tutoriales\n- Programas de ejemplo\n- Documentacin de casos de prueba\n\n**Pruebas:**\n- Casos de prueba adicionales para funcionalidades existentes\n- Cobertura de casos lmite\n- Pruebas de regresin para errores corregidos\n- Benchmarks de rendimiento\n\n**Adiciones de funcionalidades pequeas:**\n- Nuevas funciones incorporadas (si encajan con la filosofa)\n- Mtodos de string/array\n- Funciones utilitarias\n- Mejoras en manejo de errores\n\n**Mejoras de rendimiento:**\n- Algoritmos ms rpidos (sin cambiar la semntica)\n- Reduccin del uso de memoria\n- Suite de benchmarks\n- Herramientas de profiling\n\n**Herramientas:**\n- Resaltado de sintaxis para editores\n- Protocolo de servidor de lenguaje (LSP)\n- Integracin con depurador\n- Mejoras del sistema de compilacin\n\n### Discutir Primero\n\n**Funcionalidades mayores:**\n- Nuevas construcciones del lenguaje\n- Cambios en el sistema de tipos\n- Adiciones de sintaxis\n- Primitivas de concurrencia\n\n**Cmo discutir:**\n1. Abre un issue o discusin en GitHub\n2. Describe la funcionalidad y justificacin\n3. Muestra cdigo de ejemplo\n4. Explica cmo encaja con la filosofa de Hemlock\n5. Espera retroalimentacin de los mantenedores\n6. Itera en el diseo antes de implementar\n\n---\n\n## Qu NO Contribuir\n\n### Contribuciones Desaconsejadas\n\n**No agregues funcionalidades que:**\n- Ocultan complejidad al usuario\n- Hacen el comportamiento implcito o mgico\n- Rompen la semntica o sintaxis existente\n- Agregan recoleccin de basura o gestin automtica de memoria\n- Violan el principio de \"explcito sobre implcito\"\n\n**Ejemplos de contribuciones rechazadas:**\n\n**1. Insercin automtica de punto y coma**\n```hemlock\n// BAD: This would be rejected\nlet x = 5  // No semicolon\nlet y = 10 // No semicolon\n```\nPor qu: Hace la sintaxis ambigua, oculta errores\n\n**2. RAII/destructores**\n```hemlock\n// BAD: This would be rejected\nlet f = open(\"file.txt\");\n// File automatically closed at end of scope\n```\nPor qu: Oculta cundo se liberan los recursos, no es explcito\n\n**3. Coercin implcita de tipos que pierde datos**\n```hemlock\n// BAD: This would be rejected\nlet x: i32 = 3.14;  // Silently truncates to 3\n```\nPor qu: La prdida de datos debe ser explcita, no silenciosa\n\n**4. Recoleccin de basura**\n```c\n// BAD: This would be rejected\nvoid *gc_malloc(size_t size) {\n    // Track allocation for automatic cleanup\n}\n```\nPor qu: Oculta la gestin de memoria, rendimiento impredecible\n\n**5. Sistema de macros complejo**\n```hemlock\n// BAD: This would be rejected\nmacro repeat($n, $block) {\n    for (let i = 0; i < $n; i++) $block\n}\n```\nPor qu: Demasiada magia, hace el cdigo difcil de razonar\n\n### Razones Comunes de Rechazo\n\n**\"Esto es demasiado implcito\"**\n- Solucin: Haz el comportamiento explcito y documntalo\n\n**\"Esto oculta complejidad\"**\n- Solucin: Expone la complejidad pero hazla ergonmica\n\n**\"Esto rompe cdigo existente\"**\n- Solucin: Encuentra una alternativa no disruptiva o discute versionado\n\n**\"Esto no encaja con la filosofa de Hemlock\"**\n- Solucin: Relee philosophy.md y reconsidera el enfoque\n\n---\n\n## Patrones Comunes\n\n### Patrn de Manejo de Errores\n\n```c\n// Use this pattern for recoverable errors in Hemlock code\nValue *divide(Value *a, Value *b)\n{\n    // Check preconditions\n    if (b->type != TYPE_I32) {\n        // Return error value or throw exception\n        return create_error(\"Expected integer divisor\");\n    }\n\n    if (b->i32_value == 0) {\n        return create_error(\"Division by zero\");\n    }\n\n    // Perform operation\n    return value_create_i32(a->i32_value / b->i32_value);\n}\n```\n\n### Patrn de Gestin de Memoria\n\n```c\n// Pattern: Allocate, use, free\nvoid process_data(void)\n{\n    // Allocate\n    Buffer *buf = create_buffer(1024);\n    char *str = malloc(256);\n\n    // Use\n    if (buf && str) {\n        // ... do work\n    }\n\n    // Free (in reverse order of allocation)\n    free(str);\n    free_buffer(buf);\n}\n```\n\n### Patrn de Creacin de Valores\n\n```c\n// Create values using constructors\nValue *create_integer(int32_t n)\n{\n    Value *val = malloc(sizeof(Value));\n    if (!val) {\n        fprintf(stderr, \"Out of memory\\n\");\n        exit(1);\n    }\n\n    val->type = TYPE_I32;\n    val->i32_value = n;\n    return val;\n}\n```\n\n### Patrn de Verificacin de Tipos\n\n```c\n// Check types before operations\nValue *add_values(Value *a, Value *b)\n{\n    // Type checking\n    if (a->type != TYPE_I32 || b->type != TYPE_I32) {\n        return create_error(\"Type mismatch\");\n    }\n\n    // Safe to proceed\n    return value_create_i32(a->i32_value + b->i32_value);\n}\n```\n\n### Patrn de Construccin de Strings\n\n```c\n// Build strings efficiently\nvoid build_error_message(char *buffer, size_t size, const char *detail)\n{\n    snprintf(buffer, size, \"Error: %s (line %d)\", detail, line_number);\n}\n```\n\n---\n\n## Agregar Nuevas Funcionalidades\n\n### Lista de Verificacin para Adicin de Funcionalidades\n\nCuando agregues una nueva funcionalidad, sigue estos pasos:\n\n#### 1. Fase de Diseo\n\n- [ ] Lee philosophy.md para asegurar alineacin\n- [ ] Crea un issue en GitHub describiendo la funcionalidad\n- [ ] Obtn aprobacin de los mantenedores para el diseo\n- [ ] Escribe especificacin (sintaxis, semntica, ejemplos)\n- [ ] Considera casos lmite y condiciones de error\n\n#### 2. Fase de Implementacin\n\n**Si agregas una construccin del lenguaje:**\n\n- [ ] Agrega tipo de token a `lexer.h` (si es necesario)\n- [ ] Agrega regla del lexer en `lexer.c` (si es necesario)\n- [ ] Agrega tipo de nodo AST en `ast.h`\n- [ ] Agrega constructor AST en `ast.c`\n- [ ] Agrega regla del parser en `parser.c`\n- [ ] Agrega comportamiento en tiempo de ejecucin en `runtime.c` o mdulo apropiado\n- [ ] Maneja limpieza en funciones free del AST\n\n**Si agregas una funcin incorporada:**\n\n- [ ] Agrega implementacin de la funcin en `builtins.c`\n- [ ] Registra la funcin en `register_builtins()`\n- [ ] Maneja todas las combinaciones de tipos de parmetros\n- [ ] Retorna valores de error apropiados\n- [ ] Documenta parmetros y tipo de retorno\n\n**Si agregas un tipo de valor:**\n\n- [ ] Agrega enum de tipo en `values.h`\n- [ ] Agrega campo a la unin Value\n- [ ] Agrega constructor en `values.c`\n- [ ] Agrega a `value_free()` para limpieza\n- [ ] Agrega a `value_copy()` para copiar\n- [ ] Agrega a `value_to_string()` para imprimir\n- [ ] Agrega reglas de promocin de tipos si es numrico\n\n#### 3. Fase de Pruebas\n\n- [ ] Escribe casos de prueba (ver testing.md)\n- [ ] Prueba casos exitosos\n- [ ] Prueba casos de error\n- [ ] Prueba casos lmite\n- [ ] Ejecuta suite completa de pruebas (`make test`)\n- [ ] Verifica fugas de memoria con valgrind\n- [ ] Prueba en mltiples plataformas (si es posible)\n\n#### 4. Fase de Documentacin\n\n- [ ] Actualiza CLAUDE.md con documentacin visible al usuario\n- [ ] Agrega comentarios de cdigo explicando la implementacin\n- [ ] Crea ejemplos en `examples/`\n- [ ] Actualiza archivos relevantes en docs/\n- [ ] Documenta cualquier cambio incompatible\n\n#### 5. Fase de Envo\n\n- [ ] Limpia cdigo de depuracin y comentarios\n- [ ] Verifica cumplimiento del estilo de cdigo\n- [ ] Haz rebase sobre la ltima main\n- [ ] Crea pull request con descripcin detallada\n- [ ] Responde a la retroalimentacin de revisin de cdigo\n\n### Ejemplo: Agregar un Nuevo Operador\n\nRecorramos el proceso de agregar el operador mdulo `%` como ejemplo:\n\n**1. Lexer (lexer.c):**\n```c\n// Add to switch statement in get_next_token()\ncase '%':\n    return create_token(TOKEN_PERCENT, \"%\", line);\n```\n\n**2. Cabecera del Lexer (lexer.h):**\n```c\ntypedef enum {\n    // ... existing tokens\n    TOKEN_PERCENT,\n    // ...\n} TokenType;\n```\n\n**3. AST (ast.h):**\n```c\ntypedef enum {\n    // ... existing operators\n    OP_MOD,\n    // ...\n} BinaryOp;\n```\n\n**4. Parser (parser.c):**\n```c\n// Add to parse_multiplicative() or appropriate precedence level\nif (match(TOKEN_PERCENT)) {\n    BinaryOp op = OP_MOD;\n    ASTNode *right = parse_unary();\n    left = create_binary_op_node(op, left, right);\n}\n```\n\n**5. Runtime (runtime.c):**\n```c\n// Add to eval_binary_op()\ncase OP_MOD:\n    // Type checking\n    if (left->type == TYPE_I32 && right->type == TYPE_I32) {\n        if (right->i32_value == 0) {\n            fprintf(stderr, \"Error: Modulo by zero\\n\");\n            exit(1);\n        }\n        return value_create_i32(left->i32_value % right->i32_value);\n    }\n    // ... handle other type combinations\n    break;\n```\n\n**6. Pruebas (tests/operators/modulo.hml):**\n```hemlock\n// Basic modulo\nprint(10 % 3);  // Expect: 2\n\n// Negative modulo\nprint(-10 % 3); // Expect: -1\n\n// Error case (should fail)\n// print(10 % 0);  // Division by zero\n```\n\n**7. Documentacin (CLAUDE.md):**\n```markdown\n### Arithmetic Operators\n- `+` - Addition\n- `-` - Subtraction\n- `*` - Multiplication\n- `/` - Division\n- `%` - Modulo (remainder)\n```\n\n---\n\n## Proceso de Revisin de Cdigo\n\n### Qu Buscan los Revisores\n\n**1. Correccin**\n- El cdigo hace lo que dice que hace?\n- Se manejan los casos lmite?\n- Hay fugas de memoria?\n- Se manejan los errores correctamente?\n\n**2. Alineacin con la Filosofa**\n- Encaja esto con los principios de diseo de Hemlock?\n- Es explcito o implcito?\n- Oculta complejidad?\n\n**3. Calidad de Cdigo**\n- Es el cdigo legible y mantenible?\n- Son descriptivos los nombres de variables?\n- Tienen las funciones un tamao razonable?\n- Hay documentacin adecuada?\n\n**4. Pruebas**\n- Hay suficientes casos de prueba?\n- Las pruebas cubren caminos de xito y fallo?\n- Se prueban los casos lmite?\n\n**5. Documentacin**\n- Se actualiz la documentacin visible al usuario?\n- Son claros los comentarios de cdigo?\n- Se proporcionan ejemplos?\n\n### Responder a la Retroalimentacin\n\n**S:**\n- Agradece a los revisores por su tiempo\n- Haz preguntas aclaratorias si no entiendes\n- Explica tu razonamiento si no ests de acuerdo\n- Haz los cambios solicitados prontamente\n- Actualiza la descripcin del PR si el alcance cambia\n\n**No:**\n- Tomes las crticas personalmente\n- Discutas defensivamente\n- Ignores la retroalimentacin\n- Hagas force-push sobre comentarios de revisin (a menos que hagas rebase)\n- Agregues cambios no relacionados al PR\n\n### Lograr que tu PR sea Fusionado\n\n**Requisitos para fusin:**\n- [ ] Todas las pruebas pasan\n- [ ] Sin fugas de memoria (valgrind limpio)\n- [ ] Aprobacin de revisin de cdigo del mantenedor\n- [ ] Documentacin actualizada\n- [ ] Sigue las guas de estilo de cdigo\n- [ ] Se alinea con la filosofa de Hemlock\n\n**Cronograma:**\n- PRs pequeos (correcciones de errores): Usualmente revisados en unos das\n- PRs medianos (nuevas funcionalidades): Puede tomar 1-2 semanas\n- PRs grandes (cambios mayores): Requiere discusin extensa\n\n---\n\n## Recursos Adicionales\n\n### Recursos de Aprendizaje\n\n**Entender intrpretes:**\n- \"Crafting Interpreters\" por Robert Nystrom\n- \"Writing An Interpreter In Go\" por Thorsten Ball\n- \"Modern Compiler Implementation in C\" por Andrew Appel\n\n**Programacin en C:**\n- \"The C Programming Language\" por K&R\n- \"Expert C Programming\" por Peter van der Linden\n- \"C Interfaces and Implementations\" por David Hanson\n\n**Gestin de memoria:**\n- Documentacin de Valgrind\n- \"Understanding and Using C Pointers\" por Richard Reese\n\n### Comandos tiles\n\n```bash\n# Build with debug symbols\nmake clean && make CFLAGS=\"-g -O0\"\n\n# Run with valgrind\nvalgrind --leak-check=full ./hemlock script.hml\n\n# Run specific test category\n./tests/run_tests.sh tests/strings/\n\n# Generate tags file for code navigation\nctags -R .\n\n# Find all TODOs and FIXMEs\ngrep -rn \"TODO\\|FIXME\" src/ include/\n```\n\n---\n\n## Preguntas?\n\nSi tienes preguntas sobre contribuir:\n\n1. Revisa la documentacin en `docs/`\n2. Busca en issues existentes de GitHub\n3. Pregunta en GitHub Discussions\n4. Abre un nuevo issue con tu pregunta\n\n**Gracias por contribuir a Hemlock!**\n"}, "Contribuir -> Pruebas": {"id": "contributing-testing", "content": "# Gua de Pruebas para Hemlock\n\nEsta gua explica la filosofa de pruebas de Hemlock, cmo escribir pruebas y cmo ejecutar la suite de pruebas.\n\n---\n\n## Tabla de Contenidos\n\n- [Filosofa de Pruebas](#filosofa-de-pruebas)\n- [Estructura de la Suite de Pruebas](#estructura-de-la-suite-de-pruebas)\n- [Ejecutar Pruebas](#ejecutar-pruebas)\n- [Escribir Pruebas](#escribir-pruebas)\n- [Categoras de Pruebas](#categoras-de-pruebas)\n- [Pruebas de Fugas de Memoria](#pruebas-de-fugas-de-memoria)\n- [Integracin Continua](#integracin-continua)\n- [Mejores Prcticas](#mejores-prcticas)\n\n---\n\n## Filosofa de Pruebas\n\n### Principios Fundamentales\n\n**1. Desarrollo Guiado por Pruebas (TDD)**\n\nEscribe pruebas **antes** de implementar funcionalidades:\n\n```\n1. Write a failing test\n2. Implement the feature\n3. Run the test (should pass)\n4. Refactor if needed\n5. Repeat\n```\n\n**Beneficios:**\n- Asegura que las funcionalidades realmente funcionan\n- Previene regresiones\n- Documenta el comportamiento esperado\n- Hace la refactorizacin ms segura\n\n**2. Cobertura Integral**\n\nPrueba tanto los casos de xito como los de fallo:\n\n```hemlock\n// Success case\nlet x: u8 = 255;  // Should work\n\n// Failure case\nlet y: u8 = 256;  // Should error\n```\n\n**3. Probar Temprano y Frecuentemente**\n\nEjecuta las pruebas:\n- Antes de hacer commit del cdigo\n- Despus de hacer cambios\n- Antes de enviar pull requests\n- Durante la revisin de cdigo\n\n**Regla:** Todas las pruebas deben pasar antes de fusionar.\n\n### Qu Probar\n\n**Siempre prueba:**\n- Funcionalidad bsica (camino feliz)\n- Condiciones de error (camino triste)\n- Casos lmite (condiciones de frontera)\n- Verificacin de tipos y conversiones\n- Gestin de memoria (sin fugas)\n- Concurrencia y condiciones de carrera\n\n**Ejemplo de cobertura de pruebas:**\n```hemlock\n// Feature: String.substr(start, length)\n\n// Happy path\nprint(\"hello\".substr(0, 5));  // \"hello\"\n\n// Edge cases\nprint(\"hello\".substr(0, 0));  // \"\" (empty)\nprint(\"hello\".substr(5, 0));  // \"\" (at end)\nprint(\"hello\".substr(2, 100)); // \"llo\" (past end)\n\n// Error cases\n// \"hello\".substr(-1, 5);  // Error: negative index\n// \"hello\".substr(0, -1);  // Error: negative length\n```\n\n---\n\n## Estructura de la Suite de Pruebas\n\n### Organizacin de Directorios\n\n```\ntests/\n run_tests.sh          # Main test runner script\n primitives/           # Type system tests\n    integers.hml\n    floats.hml\n    booleans.hml\n    i64.hml\n    u64.hml\n conversions/          # Type conversion tests\n    int_to_float.hml\n    promotion.hml\n    rune_conversions.hml\n memory/               # Pointer/buffer tests\n    alloc.hml\n    buffer.hml\n    memcpy.hml\n strings/              # String operation tests\n    concat.hml\n    methods.hml\n    utf8.hml\n    runes.hml\n control/              # Control flow tests\n    if.hml\n    switch.hml\n    while.hml\n functions/            # Function and closure tests\n    basics.hml\n    closures.hml\n    recursion.hml\n objects/              # Object tests\n    literals.hml\n    methods.hml\n    duck_typing.hml\n    serialization.hml\n arrays/               # Array operation tests\n    basics.hml\n    methods.hml\n    slicing.hml\n loops/                # Loop tests\n    for.hml\n    while.hml\n    break.hml\n    continue.hml\n exceptions/           # Error handling tests\n    try_catch.hml\n    finally.hml\n    throw.hml\n io/                   # File I/O tests\n    file_object.hml\n    read_write.hml\n    seek.hml\n async/                # Concurrency tests\n    spawn_join.hml\n    channels.hml\n    exceptions.hml\n ffi/                  # FFI tests\n    basic_call.hml\n    types.hml\n    dlopen.hml\n signals/              # Signal handling tests\n    basic.hml\n    handlers.hml\n    raise.hml\n args/                 # Command-line args tests\n     basic.hml\n```\n\n### Nomenclatura de Archivos de Prueba\n\n**Convenciones:**\n- Usa nombres descriptivos: `method_chaining.hml` no `test1.hml`\n- Agrupa pruebas relacionadas: `string_substr.hml`, `string_slice.hml`\n- Un rea de funcionalidad por archivo\n- Mantn los archivos enfocados y pequeos\n\n---\n\n## Ejecutar Pruebas\n\n### Ejecutar Todas las Pruebas\n\n```bash\n# From hemlock root directory\nmake test\n\n# Or directly\n./tests/run_tests.sh\n```\n\n**Salida:**\n```\nRunning tests in tests/primitives/...\n   integers.hml\n   floats.hml\n   booleans.hml\n\nRunning tests in tests/strings/...\n   concat.hml\n   methods.hml\n\n...\n\nTotal: 251 tests\nPassed: 251\nFailed: 0\n```\n\n### Ejecutar Categora Especfica\n\n```bash\n# Run only string tests\n./tests/run_tests.sh tests/strings/\n\n# Run only one test file\n./tests/run_tests.sh tests/strings/concat.hml\n\n# Run multiple categories\n./tests/run_tests.sh tests/strings/ tests/arrays/\n```\n\n### Ejecutar con Valgrind (Verificacin de Fugas de Memoria)\n\n```bash\n# Check single test for leaks\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\n\n# Check all tests (slow!)\nfor test in tests/**/*.hml; do\n    echo \"Testing $test\"\n    valgrind --leak-check=full --error-exitcode=1 ./hemlock \"$test\"\ndone\n```\n\n### Depurar Pruebas Fallidas\n\n```bash\n# Run with verbose output\n./hemlock tests/failing_test.hml\n\n# Run with gdb\ngdb --args ./hemlock tests/failing_test.hml\n(gdb) run\n(gdb) backtrace  # if it crashes\n```\n\n---\n\n## Escribir Pruebas\n\n### Formato de Archivos de Prueba\n\nLos archivos de prueba son simplemente programas Hemlock con salida esperada:\n\n**Ejemplo: tests/primitives/integers.hml**\n```hemlock\n// Test basic integer literals\nlet x = 42;\nprint(x);  // Expect: 42\n\nlet y: i32 = 100;\nprint(y);  // Expect: 100\n\n// Test arithmetic\nlet sum = x + y;\nprint(sum);  // Expect: 142\n\n// Test type inference\nlet small = 10;\nprint(typeof(small));  // Expect: i32\n\nlet large = 5000000000;\nprint(typeof(large));  // Expect: i64\n```\n\n**Cmo funcionan las pruebas:**\n1. El ejecutor de pruebas ejecuta el archivo .hml\n2. Captura la salida stdout\n3. Compara con la salida esperada (de comentarios o archivo .out separado)\n4. Reporta xito/fallo\n\n### Mtodos de Salida Esperada\n\n**Mtodo 1: Comentarios en lnea (recomendado para pruebas simples)**\n\n```hemlock\nprint(\"hello\");  // Expect: hello\nprint(42);       // Expect: 42\n```\n\nEl ejecutor de pruebas analiza los comentarios `// Expect: ...`.\n\n**Mtodo 2: Archivo .out separado**\n\nCrea `test_name.hml.out` con la salida esperada:\n\n**test_name.hml:**\n```hemlock\nprint(\"line 1\");\nprint(\"line 2\");\nprint(\"line 3\");\n```\n\n**test_name.hml.out:**\n```\nline 1\nline 2\nline 3\n```\n\n### Probar Casos de Error\n\nLas pruebas de error deben hacer que el programa termine con estado distinto de cero:\n\n**Ejemplo: tests/primitives/range_error.hml**\n```hemlock\n// This should fail with a type error\nlet x: u8 = 256;  // Out of range for u8\n```\n\n**Comportamiento esperado:**\n- El programa termina con estado distinto de cero\n- Imprime mensaje de error a stderr\n\n**Manejo del ejecutor de pruebas:**\n- Las pruebas que esperan errores deben estar en archivos separados\n- Usa convencin de nombres: `*_error.hml` o `*_fail.hml`\n- Documenta el error esperado en comentarios\n\n### Probar Casos de xito\n\n**Ejemplo: tests/strings/methods.hml**\n```hemlock\n// Test substr\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);\nprint(sub);  // Expect: world\n\n// Test find\nlet pos = s.find(\"world\");\nprint(pos);  // Expect: 6\n\n// Test contains\nlet has = s.contains(\"lo\");\nprint(has);  // Expect: true\n\n// Test trim\nlet padded = \"  hello  \";\nlet trimmed = padded.trim();\nprint(trimmed);  // Expect: hello\n```\n\n### Probar Casos Lmite\n\n**Ejemplo: tests/arrays/edge_cases.hml**\n```hemlock\n// Empty array\nlet empty = [];\nprint(empty.length);  // Expect: 0\n\n// Single element\nlet single = [42];\nprint(single[0]);  // Expect: 42\n\n// Negative index (should error in separate test file)\n// print(single[-1]);  // Error\n\n// Past-end index (should error)\n// print(single[100]);  // Error\n\n// Boundary conditions\nlet arr = [1, 2, 3];\nprint(arr.slice(0, 0));  // Expect: [] (empty)\nprint(arr.slice(3, 3));  // Expect: [] (empty)\nprint(arr.slice(1, 2));  // Expect: [2]\n```\n\n### Probar Sistema de Tipos\n\n**Ejemplo: tests/conversions/promotion.hml**\n```hemlock\n// Test type promotion in binary operations\n\n// i32 + i64 -> i64\nlet a: i32 = 10;\nlet b: i64 = 20;\nlet c = a + b;\nprint(typeof(c));  // Expect: i64\n\n// i32 + f32 -> f32\nlet d: i32 = 10;\nlet e: f32 = 3.14;\nlet f = d + e;\nprint(typeof(f));  // Expect: f32\n\n// u8 + i32 -> i32\nlet g: u8 = 5;\nlet h: i32 = 10;\nlet i = g + h;\nprint(typeof(i));  // Expect: i32\n```\n\n### Probar Concurrencia\n\n**Ejemplo: tests/async/basic.hml**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn tasks\nlet t1 = spawn(compute, 10);\nlet t2 = spawn(compute, 20);\n\n// Join and print results\nlet r1 = join(t1);\nlet r2 = join(t2);\nprint(r1);  // Expect: 45\nprint(r2);  // Expect: 190\n```\n\n### Probar Excepciones\n\n**Ejemplo: tests/exceptions/try_catch.hml**\n```hemlock\n// Test basic try/catch\ntry {\n    throw \"error message\";\n} catch (e) {\n    print(\"Caught: \" + e);  // Expect: Caught: error message\n}\n\n// Test finally\nlet executed = false;\ntry {\n    print(\"try\");  // Expect: try\n} finally {\n    executed = true;\n    print(\"finally\");  // Expect: finally\n}\n\n// Test exception propagation\nfn risky(): i32 {\n    throw \"failure\";\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(e);  // Expect: failure\n}\n```\n\n---\n\n## Categoras de Pruebas\n\n### Pruebas de Primitivos\n\n**Qu probar:**\n- Tipos enteros (i8, i16, i32, i64, u8, u16, u32, u64)\n- Tipos de punto flotante (f32, f64)\n- Tipo booleano\n- Tipo string\n- Tipo rune\n- Tipo null\n\n**reas de ejemplo:**\n- Sintaxis de literales\n- Inferencia de tipos\n- Verificacin de rangos\n- Comportamiento de desbordamiento\n- Anotaciones de tipo\n\n### Pruebas de Conversin\n\n**Qu probar:**\n- Promocin implcita de tipos\n- Conversin explcita de tipos\n- Conversiones con prdida (deben dar error)\n- Promocin de tipos en operaciones\n- Comparaciones entre tipos\n\n### Pruebas de Memoria\n\n**Qu probar:**\n- Correccin de alloc/free\n- Creacin y acceso a Buffer\n- Verificacin de lmites en buffers\n- memset, memcpy, realloc\n- Deteccin de fugas de memoria (valgrind)\n\n### Pruebas de Strings\n\n**Qu probar:**\n- Concatenacin\n- Los 18 mtodos de string\n- Manejo de UTF-8\n- Indexacin de runes\n- Concatenacin de string + rune\n- Casos lmite (strings vacos, un solo carcter, etc.)\n\n### Pruebas de Flujo de Control\n\n**Qu probar:**\n- if/else/else if\n- Bucles while\n- Bucles for\n- Sentencias switch\n- break/continue\n- Sentencias return\n\n### Pruebas de Funciones\n\n**Qu probar:**\n- Definicin y llamada de funciones\n- Paso de parmetros\n- Valores de retorno\n- Recursin\n- Closures y captura\n- Funciones de primera clase\n- Funciones annimas\n\n### Pruebas de Objetos\n\n**Qu probar:**\n- Literales de objeto\n- Acceso y asignacin de campos\n- Mtodos y binding de self\n- Duck typing\n- Campos opcionales\n- Serializacin/deserializacin JSON\n- Deteccin de referencias circulares\n\n### Pruebas de Arrays\n\n**Qu probar:**\n- Creacin de arrays\n- Indexacin y asignacin\n- Los 15 mtodos de array\n- Tipos mezclados\n- Redimensionamiento dinmico\n- Casos lmite (vaco, un solo elemento)\n\n### Pruebas de Excepciones\n\n**Qu probar:**\n- try/catch/finally\n- Sentencia throw\n- Propagacin de excepciones\n- try/catch anidados\n- Return en try/catch/finally\n- Excepciones no capturadas\n\n### Pruebas de E/S\n\n**Qu probar:**\n- Modos de apertura de archivos\n- Operaciones de lectura/escritura\n- Seek/tell\n- Propiedades de archivos\n- Manejo de errores (archivos faltantes, etc.)\n- Limpieza de recursos\n\n### Pruebas Asncronas\n\n**Qu probar:**\n- spawn/join/detach\n- send/recv de Channel\n- Propagacin de excepciones en tareas\n- Mltiples tareas concurrentes\n- Comportamiento de bloqueo de canales\n\n### Pruebas de FFI\n\n**Qu probar:**\n- dlopen/dlclose\n- dlsym\n- dlcall con varios tipos\n- Conversin de tipos\n- Manejo de errores\n\n---\n\n## Pruebas de Fugas de Memoria\n\n### Usar Valgrind\n\n**Uso bsico:**\n```bash\nvalgrind --leak-check=full ./hemlock test.hml\n```\n\n**Ejemplo de salida (sin fugas):**\n```\n==12345== HEAP SUMMARY:\n==12345==     in use at exit: 0 bytes in 0 blocks\n==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated\n==12345==\n==12345== All heap blocks were freed -- no leaks are possible\n```\n\n**Ejemplo de salida (con fuga):**\n```\n==12345== LEAK SUMMARY:\n==12345==    definitely lost: 64 bytes in 1 blocks\n==12345==    indirectly lost: 0 bytes in 0 blocks\n==12345==      possibly lost: 0 bytes in 0 blocks\n==12345==    still reachable: 0 bytes in 0 blocks\n==12345==         suppressed: 0 bytes in 0 blocks\n```\n\n### Fuentes Comunes de Fugas\n\n**1. Llamadas free() faltantes:**\n```c\n// BAD\nchar *str = malloc(100);\n// ... use str\n// Forgot to free!\n\n// GOOD\nchar *str = malloc(100);\n// ... use str\nfree(str);\n```\n\n**2. Punteros perdidos:**\n```c\n// BAD\nchar *ptr = malloc(100);\nptr = malloc(200);  // Lost reference to first allocation!\n\n// GOOD\nchar *ptr = malloc(100);\nfree(ptr);\nptr = malloc(200);\n```\n\n**3. Caminos de excepcin:**\n```c\n// BAD\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        return;  // Leak!\n    }\n    free(data);\n}\n\n// GOOD\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        free(data);\n        return;\n    }\n    free(data);\n}\n```\n\n### Fugas Aceptables Conocidas\n\nAlgunas pequeas \"fugas\" son asignaciones intencionales de inicio:\n\n**Funciones incorporadas globales:**\n```hemlock\n// Built-in functions, FFI types, and constants are allocated at startup\n// and not freed at exit (typically ~200 bytes)\n```\n\nEstas no son fugas verdaderas - son asignaciones nicas que persisten durante la vida del programa y son limpiadas por el SO al salir.\n\n---\n\n## Integracin Continua\n\n### GitHub Actions (Futuro)\n\nUna vez que el CI est configurado, todas las pruebas se ejecutarn automticamente en:\n- Push a la rama main\n- Creacin/actualizacin de pull request\n- Ejecuciones programadas diarias\n\n**Flujo de trabajo de CI:**\n1. Compilar Hemlock\n2. Ejecutar suite de pruebas\n3. Verificar fugas de memoria (valgrind)\n4. Reportar resultados en el PR\n\n### Verificaciones Pre-Commit\n\nAntes de hacer commit, ejecuta:\n\n```bash\n# Build fresh\nmake clean && make\n\n# Run all tests\nmake test\n\n# Check a few tests for leaks\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\nvalgrind --leak-check=full ./hemlock tests/strings/concat.hml\n```\n\n---\n\n## Mejores Prcticas\n\n### Hacer\n\n**Escribe pruebas primero (TDD)**\n```bash\n1. Create tests/feature/new_feature.hml\n2. Implement feature in src/\n3. Run tests until they pass\n```\n\n**Prueba tanto xito como fallo**\n```hemlock\n// Success: tests/feature/success.hml\nlet result = do_thing();\nprint(result);  // Expect: expected value\n\n// Failure: tests/feature/failure.hml\ndo_invalid_thing();  // Should error\n```\n\n**Usa nombres de prueba descriptivos**\n```\nGood: tests/strings/substr_utf8_boundary.hml\nBad:  tests/test1.hml\n```\n\n**Mantn las pruebas enfocadas**\n- Un rea de funcionalidad por archivo\n- Configuracin y aserciones claras\n- Cdigo mnimo\n\n**Agrega comentarios explicando pruebas complicadas**\n```hemlock\n// Test that closure captures outer variable by reference\nfn outer() {\n    let x = 10;\n    let f = fn() { return x; };\n    x = 20;  // Modify after closure creation\n    return f();  // Should return 20, not 10\n}\n```\n\n**Prueba casos lmite**\n- Entradas vacas\n- Valores null\n- Valores de frontera (min/max)\n- Entradas grandes\n- Valores negativos\n\n### No Hacer\n\n**No omitas pruebas**\n- Todas las pruebas deben pasar antes de fusionar\n- No comentes pruebas que fallan\n- Arregla el error o elimina la funcionalidad\n\n**No escribas pruebas que dependan unas de otras**\n```hemlock\n// BAD: test2.hml depends on test1.hml output\n// Tests should be independent\n```\n\n**No uses valores aleatorios en pruebas**\n```hemlock\n// BAD: Non-deterministic\nlet x = random();\nprint(x);  // Can't predict output\n\n// GOOD: Deterministic\nlet x = 42;\nprint(x);  // Expect: 42\n```\n\n**No pruebes detalles de implementacin**\n```hemlock\n// BAD: Testing internal structure\nlet obj = { x: 10 };\n// Don't check internal field order, capacity, etc.\n\n// GOOD: Testing behavior\nprint(obj.x);  // Expect: 10\n```\n\n**No ignores fugas de memoria**\n- Todas las pruebas deben pasar valgrind sin errores\n- Documenta fugas conocidas/aceptables\n- Arregla las fugas antes de fusionar\n\n### Mantenimiento de Pruebas\n\n**Cundo actualizar pruebas:**\n- El comportamiento de la funcionalidad cambia\n- Las correcciones de errores requieren nuevos casos de prueba\n- Se descubren casos lmite\n- Mejoras de rendimiento\n\n**Cundo eliminar pruebas:**\n- La funcionalidad se elimina del lenguaje\n- La prueba duplica cobertura existente\n- La prueba era incorrecta\n\n**Refactorizar pruebas:**\n- Agrupa pruebas relacionadas\n- Extrae cdigo de configuracin comn\n- Usa nombres consistentes\n- Mantn las pruebas simples y legibles\n\n---\n\n## Sesin de Prueba de Ejemplo\n\nAqu hay un ejemplo completo de agregar una funcionalidad con pruebas:\n\n### Funcionalidad: Agregar mtodo `array.first()`\n\n**1. Escribe la prueba primero:**\n\n```bash\n# Create test file\ncat > tests/arrays/first_method.hml << 'EOF'\n// Test array.first() method\n\n// Basic case\nlet arr = [1, 2, 3];\nprint(arr.first());  // Expect: 1\n\n// Single element\nlet single = [42];\nprint(single.first());  // Expect: 42\n\n// Empty array (should error - separate test file)\n// let empty = [];\n// print(empty.first());  // Error\nEOF\n```\n\n**2. Ejecuta la prueba (debe fallar):**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n# Error: Method 'first' not found on array\n```\n\n**3. Implementa la funcionalidad:**\n\nEdita `src/interpreter/builtins.c`:\n\n```c\n// Add array_first method\nValue *array_first(Value *self, Value **args, int arg_count)\n{\n    if (self->array_value->length == 0) {\n        fprintf(stderr, \"Error: Cannot get first element of empty array\\n\");\n        exit(1);\n    }\n\n    return value_copy(&self->array_value->elements[0]);\n}\n\n// Register in array method table\n// ... add to array method registration\n```\n\n**4. Ejecuta la prueba (debe pasar):**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n1\n42\n# Success!\n```\n\n**5. Verifica fugas de memoria:**\n\n```bash\nvalgrind --leak-check=full ./hemlock tests/arrays/first_method.hml\n# All heap blocks were freed -- no leaks are possible\n```\n\n**6. Ejecuta la suite completa de pruebas:**\n\n```bash\nmake test\n# Total: 252 tests (251 + new one)\n# Passed: 252\n# Failed: 0\n```\n\n**7. Commit:**\n\n```bash\ngit add tests/arrays/first_method.hml src/interpreter/builtins.c\ngit commit -m \"Add array.first() method with tests\"\n```\n\n---\n\n## Resumen\n\n**Recuerda:**\n- Escribe pruebas primero (TDD)\n- Prueba casos de xito y fallo\n- Ejecuta todas las pruebas antes de hacer commit\n- Verifica fugas de memoria\n- Documenta problemas conocidos\n- Mantn las pruebas simples y enfocadas\n\n**La calidad de las pruebas es tan importante como la calidad del cdigo!**\n"}, "hpm: Primeros Pasos -> Configuracin del Proyecto": {"id": "hpm-project-setup", "content": "# Configuracion del Proyecto\n\nGuia completa para configurar proyectos Hemlock con hpm.\n\n## Iniciar un Nuevo Proyecto\n\n### Configuracion Basica\n\nCrea un nuevo proyecto desde cero:\n\n```bash\n# Crear directorio del proyecto\nmkdir my-project\ncd my-project\n\n# Inicializar package.json\nhpm init\n\n# Crear estructura de directorios\nmkdir -p src test\n```\n\n### Plantillas de Proyecto\n\nAqui hay estructuras de proyecto comunes para diferentes casos de uso:\n\n#### Paquete de Biblioteca\n\nPara bibliotecas reutilizables:\n\n```\nmy-library/\n package.json\n README.md\n LICENSE\n src/\n    index.hml          # Entrada principal, exporta API publica\n    core.hml           # Funcionalidad principal\n    utils.hml          # Funciones utilitarias\n    types.hml          # Definiciones de tipos\n test/\n     framework.hml      # Framework de pruebas\n     run.hml            # Ejecutor de pruebas\n     test_core.hml      # Pruebas\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-library\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A reusable Hemlock library\",\n  \"main\": \"src/index.hml\",\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {}\n}\n```\n\n#### Aplicacion\n\nPara aplicaciones independientes:\n\n```\nmy-app/\n package.json\n README.md\n src/\n    main.hml           # Punto de entrada de la aplicacion\n    config.hml         # Configuracion\n    commands/          # Comandos CLI\n       index.hml\n       run.hml\n    lib/               # Bibliotecas internas\n        utils.hml\n test/\n    run.hml\n data/                  # Archivos de datos\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Hemlock application\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {}\n}\n```\n\n#### Aplicacion Web\n\nPara servidores web:\n\n```\nmy-web-app/\n package.json\n README.md\n src/\n    main.hml           # Punto de entrada del servidor\n    routes/            # Manejadores de rutas\n       index.hml\n       api.hml\n       auth.hml\n    middleware/        # Middleware\n       index.hml\n       auth.hml\n    models/            # Modelos de datos\n       user.hml\n    services/          # Logica de negocio\n        user.hml\n test/\n    run.hml\n static/                # Archivos estaticos\n    css/\n    js/\n views/                 # Plantillas\n     index.hml\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-web-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Hemlock web application\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\",\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  }\n}\n```\n\n## El Archivo package.json\n\n### Campos Requeridos\n\n```json\n{\n  \"name\": \"owner/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n### Todos los Campos\n\n```json\n{\n  \"name\": \"yourusername/my-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Package description\",\n  \"author\": \"Your Name <you@example.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/yourusername/my-package\",\n  \"homepage\": \"https://yourusername.github.io/my-package\",\n  \"bugs\": \"https://github.com/yourusername/my-package/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"utility\", \"parser\"],\n  \"dependencies\": {\n    \"owner/package\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"owner/test-lib\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n### Referencia de Campos\n\n| Campo | Tipo | Descripcion |\n|-------|------|-------------|\n| `name` | string | Nombre del paquete en formato owner/repo (requerido) |\n| `version` | string | Version semantica (requerido) |\n| `description` | string | Descripcion corta |\n| `author` | string | Nombre y email del autor |\n| `license` | string | Identificador de licencia (MIT, Apache-2.0, etc.) |\n| `repository` | string | URL del repositorio |\n| `homepage` | string | Pagina principal del proyecto |\n| `bugs` | string | URL del rastreador de problemas |\n| `main` | string | Archivo de punto de entrada (por defecto: src/index.hml) |\n| `keywords` | array | Palabras clave de busqueda |\n| `dependencies` | object | Dependencias de tiempo de ejecucion |\n| `devDependencies` | object | Dependencias de desarrollo |\n| `scripts` | object | Scripts con nombre |\n| `files` | array | Archivos a incluir al publicar |\n| `native` | object | Requisitos de bibliotecas nativas |\n\n## El Archivo package-lock.json\n\nEl archivo de bloqueo se genera automaticamente y debe incluirse en el control de versiones. Asegura instalaciones reproducibles.\n\n```json\n{\n  \"lockVersion\": 1,\n  \"hemlock\": \"1.0.0\",\n  \"dependencies\": {\n    \"hemlang/sprout\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz\",\n      \"integrity\": \"sha256-abc123...\",\n      \"dependencies\": {\n        \"hemlang/router\": \"^1.5.0\"\n      }\n    },\n    \"hemlang/router\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://github.com/hemlang/router/archive/v1.5.0.tar.gz\",\n      \"integrity\": \"sha256-def456...\",\n      \"dependencies\": {}\n    }\n  }\n}\n```\n\n### Mejores Practicas del Archivo de Bloqueo\n\n- **Incluye** package-lock.json en el control de versiones\n- **No edites** manualmente - se genera automaticamente\n- **Ejecuta `hpm install`** despues de hacer pull de cambios\n- **Elimina y regenera** si esta corrupto:\n  ```bash\n  rm package-lock.json\n  hpm install\n  ```\n\n## El Directorio hem_modules\n\nLos paquetes instalados se almacenan en `hem_modules/`:\n\n```\nhem_modules/\n hemlang/\n    sprout/\n       package.json\n       src/\n    router/\n        package.json\n        src/\n alice/\n     http-client/\n         package.json\n         src/\n```\n\n### Mejores Practicas de hem_modules\n\n- **Agregar a .gitignore** - no incluir dependencias en commits\n- **No modificar** - los cambios se sobrescribiran\n- **Eliminar para reinstalar desde cero**:\n  ```bash\n  rm -rf hem_modules\n  hpm install\n  ```\n\n## .gitignore\n\n.gitignore recomendado para proyectos Hemlock:\n\n```gitignore\n# Dependencies\nhem_modules/\n\n# Build output\ndist/\n*.hmlc\n\n# IDE files\n.idea/\n.vscode/\n*.swp\n*.swo\n\n# OS files\n.DS_Store\nThumbs.db\n\n# Logs\n*.log\nlogs/\n\n# Environment\n.env\n.env.local\n\n# Test coverage\ncoverage/\n```\n\n## Trabajar con Dependencias\n\n### Agregar Dependencias\n\n```bash\n# Agregar dependencia de tiempo de ejecucion\nhpm install hemlang/json\n\n# Agregar con restriccion de version\nhpm install hemlang/sprout@^2.0.0\n\n# Agregar dependencia de desarrollo\nhpm install hemlang/test-utils --dev\n```\n\n### Importar Dependencias\n\n```hemlock\n// Import from package (uses \"main\" entry)\nimport { parse, stringify } from \"hemlang/json\";\n\n// Import from subpath\nimport { Router } from \"hemlang/sprout/router\";\n\n// Import standard library\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile, writeFile } from \"@stdlib/fs\";\n```\n\n### Resolucion de Importaciones\n\nhpm resuelve importaciones en este orden:\n\n1. **Biblioteca estandar**: importaciones `@stdlib/*` cargan modulos integrados\n2. **Raiz del paquete**: `owner/repo` usa el campo `main`\n3. **Subruta**: `owner/repo/path` verifica:\n   - `hem_modules/owner/repo/path.hml`\n   - `hem_modules/owner/repo/path/index.hml`\n   - `hem_modules/owner/repo/src/path.hml`\n   - `hem_modules/owner/repo/src/path/index.hml`\n\n## Scripts\n\n### Definir Scripts\n\nAgrega scripts a package.json:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n### Ejecutar Scripts\n\n```bash\nhpm run start\nhpm run dev\nhpm run build\n\n# Atajo para test\nhpm test\n\n# Pasar argumentos\nhpm run test -- --verbose --filter=unit\n```\n\n### Convenciones de Nombres de Scripts\n\n| Script | Proposito |\n|--------|-----------|\n| `start` | Ejecutar la aplicacion |\n| `dev` | Ejecutar en modo desarrollo |\n| `test` | Ejecutar todas las pruebas |\n| `build` | Compilar para produccion |\n| `clean` | Eliminar archivos generados |\n| `lint` | Verificar estilo de codigo |\n| `format` | Formatear codigo |\n\n## Flujo de Trabajo de Desarrollo\n\n### Configuracion Inicial\n\n```bash\n# Clonar proyecto\ngit clone https://github.com/yourusername/my-project.git\ncd my-project\n\n# Instalar dependencias\nhpm install\n\n# Ejecutar pruebas\nhpm test\n\n# Iniciar desarrollo\nhpm run dev\n```\n\n### Flujo de Trabajo Diario\n\n```bash\n# Obtener ultimos cambios\ngit pull\n\n# Instalar cualquier nueva dependencia\nhpm install\n\n# Hacer cambios...\n\n# Ejecutar pruebas\nhpm test\n\n# Commit\ngit add .\ngit commit -m \"Add feature\"\ngit push\n```\n\n### Agregar una Nueva Caracteristica\n\n```bash\n# Crear rama de caracteristica\ngit checkout -b feature/new-feature\n\n# Agregar nueva dependencia si es necesario\nhpm install hemlang/new-lib\n\n# Implementar caracteristica...\n\n# Probar\nhpm test\n\n# Commit y push\ngit add .\ngit commit -m \"Add new feature\"\ngit push -u origin feature/new-feature\n```\n\n## Configuracion Especifica del Entorno\n\n### Usar Variables de Entorno\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nlet db_host = getenv(\"DATABASE_HOST\") ?? \"localhost\";\nlet api_key = getenv(\"API_KEY\") ?? \"\";\n\nif api_key == \"\" {\n    print(\"Warning: API_KEY not set\");\n}\n```\n\n### Archivo de Configuracion\n\n**config.hml:**\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nexport let config = {\n    environment: getenv(\"HEMLOCK_ENV\") ?? \"development\",\n    database: {\n        host: getenv(\"DB_HOST\") ?? \"localhost\",\n        port: int(getenv(\"DB_PORT\") ?? \"5432\"),\n        name: getenv(\"DB_NAME\") ?? \"myapp\"\n    },\n    server: {\n        port: int(getenv(\"PORT\") ?? \"3000\"),\n        host: getenv(\"HOST\") ?? \"0.0.0.0\"\n    }\n};\n\nexport fn is_production(): bool {\n    return config.environment == \"production\";\n}\n```\n\n## Ver Tambien\n\n- [Inicio Rapido](#hpm-project-setup-quick-start) - Comenzar rapidamente\n- [Comandos](#hpm-project-setup-commands) - Referencia de comandos\n- [Creacion de Paquetes](#hpm-project-setup-creating-packages) - Publicar paquetes\n- [Configuracion](#hpm-project-setup-configuration) - Configuracion de hpm\n"}, "hpm: Primeros Pasos -> Inicio Rpido": {"id": "hpm-quick-start", "content": "# Inicio Rapido\n\nComienza a trabajar con hpm en 5 minutos.\n\n## Instalar hpm\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\nPara mas opciones de instalacion, consulta la [Guia de Instalacion](#hpm-quick-start-installation).\n\n## Crear un Nuevo Proyecto\n\nComienza creando un nuevo directorio e inicializando un paquete:\n\n```bash\nmkdir my-project\ncd my-project\nhpm init\n```\n\nSe te solicitaran los detalles del proyecto:\n\n```\nPackage name (owner/repo): myname/my-project\nVersion (1.0.0):\nDescription: My awesome Hemlock project\nAuthor: Your Name <you@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\nUsa `--yes` para aceptar todos los valores por defecto:\n\n```bash\nhpm init --yes\n```\n\n## Estructura del Proyecto\n\nCrea la estructura basica del proyecto:\n\n```\nmy-project/\n package.json        # Manifiesto del proyecto\n src/\n    index.hml      # Punto de entrada principal\n test/\n     test.hml       # Pruebas\n```\n\nCrea tu archivo principal:\n\n```bash\nmkdir -p src test\n```\n\n**src/index.hml:**\n```hemlock\n// Main entry point\nexport fn greet(name: string): string {\n    return \"Hello, \" + name + \"!\";\n}\n\nexport fn main() {\n    print(greet(\"World\"));\n}\n```\n\n## Instalar Dependencias\n\nBusca paquetes en GitHub (los paquetes usan el formato `owner/repo`):\n\n```bash\n# Instalar un paquete\nhpm install hemlang/sprout\n\n# Instalar con restriccion de version\nhpm install hemlang/json@^1.0.0\n\n# Instalar como dependencia de desarrollo\nhpm install hemlang/test-utils --dev\n```\n\nDespues de la instalacion, la estructura de tu proyecto incluye `hem_modules/`:\n\n```\nmy-project/\n package.json\n package-lock.json   # Archivo de bloqueo (auto-generado)\n hem_modules/        # Paquetes instalados\n    hemlang/\n        sprout/\n src/\n    index.hml\n test/\n     test.hml\n```\n\n## Usar Paquetes Instalados\n\nImporta paquetes usando su ruta de GitHub:\n\n```hemlock\n// Import from installed package\nimport { app, router } from \"hemlang/sprout\";\nimport { parse, stringify } from \"hemlang/json\";\n\n// Import from subpath\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// Standard library (built-in)\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile } from \"@stdlib/fs\";\n```\n\n## Agregar Scripts\n\nAgrega scripts a tu `package.json`:\n\n```json\n{\n  \"name\": \"myname/my-project\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/test.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\nEjecuta scripts con `hpm run`:\n\n```bash\nhpm run start\nhpm run build\n\n# Atajo para test\nhpm test\n```\n\n## Flujos de Trabajo Comunes\n\n### Instalar Todas las Dependencias\n\nCuando clonas un proyecto con un `package.json`:\n\n```bash\ngit clone https://github.com/someone/project.git\ncd project\nhpm install\n```\n\n### Actualizar Dependencias\n\nActualiza todos los paquetes a las ultimas versiones dentro de las restricciones:\n\n```bash\nhpm update\n```\n\nActualiza un paquete especifico:\n\n```bash\nhpm update hemlang/sprout\n```\n\n### Ver Paquetes Instalados\n\nLista todos los paquetes instalados:\n\n```bash\nhpm list\n```\n\nLa salida muestra el arbol de dependencias:\n\n```\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n    hemlang/router@1.5.0\n hemlang/json@1.2.3\n```\n\n### Verificar Actualizaciones\n\nVe que paquetes tienen versiones mas nuevas:\n\n```bash\nhpm outdated\n```\n\n### Eliminar un Paquete\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n## Ejemplo: Aplicacion Web\n\nAqui hay un ejemplo completo usando un framework web:\n\n**package.json:**\n```json\n{\n  \"name\": \"myname/my-web-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A web application\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"dev\": \"hemlock --watch src/index.hml\"\n  }\n}\n```\n\n**src/index.hml:**\n```hemlock\nimport { App, Router } from \"hemlang/sprout\";\n\nfn main() {\n    let app = App.new();\n    let router = Router.new();\n\n    router.get(\"/\", fn(req, res) {\n        res.send(\"Hello, World!\");\n    });\n\n    router.get(\"/api/status\", fn(req, res) {\n        res.json({ status: \"ok\" });\n    });\n\n    app.use(router);\n    app.listen(3000);\n\n    print(\"Server running on http://localhost:3000\");\n}\n```\n\nEjecuta la aplicacion:\n\n```bash\nhpm install\nhpm run start\n```\n\n## Proximos Pasos\n\n- [Referencia de Comandos](#hpm-quick-start-commands) - Aprende todos los comandos de hpm\n- [Creacion de Paquetes](#hpm-quick-start-creating-packages) - Publica tus propios paquetes\n- [Configuracion](#hpm-quick-start-configuration) - Configura hpm y tokens de GitHub\n- [Configuracion del Proyecto](#hpm-quick-start-project-setup) - Configuracion detallada del proyecto\n"}, "hpm: Primeros Pasos -> Instalacin": {"id": "hpm-installation", "content": "# Instalacion\n\nEsta guia cubre como instalar hpm en tu sistema.\n\n## Instalacion Rapida (Recomendada)\n\nInstala la ultima version con un solo comando:\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\nEsto automaticamente:\n- Detecta tu sistema operativo (Linux, macOS)\n- Detecta tu arquitectura (x86_64, arm64)\n- Descarga el binario precompilado apropiado\n- Instala en `/usr/local/bin` (o usa sudo si es necesario)\n\n### Opciones de Instalacion\n\n```bash\n# Instalar en una ubicacion personalizada (no requiere sudo)\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local\n\n# Instalar una version especifica\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5\n\n# Combinar opciones\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5\n```\n\n### Plataformas Soportadas\n\n| Plataforma | Arquitectura | Estado |\n|------------|--------------|--------|\n| Linux    | x86_64       |  Soportado |\n| macOS    | x86_64       |  Soportado |\n| macOS    | arm64 (M1/M2/M3) |  Soportado |\n| Linux    | arm64        | Compilar desde fuente |\n\n## Compilar desde Fuente\n\nSi prefieres compilar desde fuente o necesitas una plataforma no cubierta por los binarios precompilados, sigue estas instrucciones.\n\n### Prerrequisitos\n\nhpm requiere que [Hemlock](https://github.com/hemlang/hemlock) este instalado primero. Sigue las instrucciones de instalacion de Hemlock antes de continuar.\n\nVerifica que Hemlock este instalado:\n\n```bash\nhemlock --version\n```\n\n## Metodos de Instalacion\n\n### Metodo 1: Make Install\n\nCompila desde fuente e instala.\n\n```bash\n# Clonar el repositorio\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Instalar en /usr/local/bin (requiere sudo)\nsudo make install\n```\n\nDespues de la instalacion, verifica que funcione:\n\n```bash\nhpm --version\n```\n\n### Metodo 2: Ubicacion Personalizada\n\nInstala en un directorio personalizado (no requiere sudo):\n\n```bash\n# Clonar el repositorio\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Instalar en ~/.local/bin\nmake install PREFIX=$HOME/.local\n\n# O cualquier ubicacion personalizada\nmake install PREFIX=/opt/hemlock\n```\n\nAsegurate de que tu directorio bin personalizado este en tu PATH:\n\n```bash\n# Agregar a ~/.bashrc o ~/.zshrc\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n### Metodo 3: Ejecutar Sin Instalar\n\nPuedes ejecutar hpm directamente sin instalar:\n\n```bash\n# Clonar el repositorio\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# Crear script wrapper local\nmake\n\n# Ejecutar desde el directorio hpm\n./hpm --help\n\n# O ejecutar via hemlock directamente\nhemlock src/main.hml --help\n```\n\n### Metodo 4: Instalacion Manual\n\nCrea tu propio script wrapper:\n\n```bash\n# Clonar en una ubicacion permanente\ngit clone https://github.com/hemlang/hpm.git ~/.hpm-source\n\n# Crear script wrapper\ncat > ~/.local/bin/hpm << 'EOF'\n#!/bin/sh\nexec hemlock \"$HOME/.hpm-source/src/main.hml\" \"$@\"\nEOF\n\nchmod +x ~/.local/bin/hpm\n```\n\n## Variables de Instalacion\n\nEl Makefile soporta estas variables:\n\n| Variable | Por Defecto | Descripcion |\n|----------|-------------|-------------|\n| `PREFIX` | `/usr/local` | Prefijo de instalacion |\n| `BINDIR` | `$(PREFIX)/bin` | Directorio de binarios |\n| `HEMLOCK` | `hemlock` | Ruta al interprete hemlock |\n\nEjemplo con variables personalizadas:\n\n```bash\nmake install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock\n```\n\n## Como Funciona\n\nEl instalador crea un script shell wrapper que invoca el interprete Hemlock con el codigo fuente de hpm:\n\n```bash\n#!/bin/sh\nexec hemlock \"/path/to/hpm/src/main.hml\" \"$@\"\n```\n\nEste enfoque:\n- No requiere compilacion\n- Siempre ejecuta el ultimo codigo fuente\n- Funciona de manera confiable en todas las plataformas\n\n## Actualizar hpm\n\nPara actualizar hpm a la ultima version:\n\n```bash\ncd /path/to/hpm\ngit pull origin main\n\n# Re-instalar si la ruta cambio\nsudo make install\n```\n\n## Desinstalar\n\nEliminar hpm de tu sistema:\n\n```bash\ncd /path/to/hpm\nsudo make uninstall\n```\n\nO eliminar manualmente:\n\n```bash\nsudo rm /usr/local/bin/hpm\n```\n\n## Verificar la Instalacion\n\nDespues de la instalacion, verifica que todo funcione:\n\n```bash\n# Verificar version\nhpm --version\n\n# Ver ayuda\nhpm --help\n\n# Probar inicializacion (en un directorio vacio)\nmkdir test-project && cd test-project\nhpm init --yes\ncat package.json\n```\n\n## Solucion de Problemas\n\n### \"hemlock: command not found\"\n\nHemlock no esta instalado o no esta en tu PATH. Instala Hemlock primero:\n\n```bash\n# Verificar si hemlock existe\nwhich hemlock\n\n# Si no se encuentra, instalar Hemlock desde https://github.com/hemlang/hemlock\n```\n\n### \"Permission denied\"\n\nUsa sudo para instalacion en todo el sistema, o instala en un directorio de usuario:\n\n```bash\n# Opcion 1: Usar sudo\nsudo make install\n\n# Opcion 2: Instalar en directorio de usuario\nmake install PREFIX=$HOME/.local\n```\n\n### \"hpm: command not found\" despues de la instalacion\n\nTu PATH puede no incluir el directorio de instalacion:\n\n```bash\n# Verificar donde se instalo hpm\nls -la /usr/local/bin/hpm\n\n# Agregar al PATH si usas ubicacion personalizada\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## Notas Especificas por Plataforma\n\n### Linux\n\nLa instalacion estandar funciona en todas las distribuciones de Linux. Algunas distribuciones pueden requerir:\n\n```bash\n# Debian/Ubuntu: Asegurar herramientas de compilacion\nsudo apt-get install build-essential git\n\n# Fedora/RHEL\nsudo dnf install make git\n```\n\n### macOS\n\nLa instalacion estandar funciona. Si usas Homebrew:\n\n```bash\n# Asegurar herramientas de linea de comandos de Xcode\nxcode-select --install\n```\n\n### Windows (WSL)\n\nhpm funciona en Windows Subsystem for Linux:\n\n```bash\n# En terminal WSL\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\nmake install PREFIX=$HOME/.local\n```\n\n## Proximos Pasos\n\nDespues de la instalacion:\n\n1. [Inicio Rapido](#hpm-installation-quick-start) - Crea tu primer proyecto\n2. [Referencia de Comandos](#hpm-installation-commands) - Aprende todos los comandos\n3. [Configuracion](#hpm-installation-configuration) - Configura hpm\n"}, "hpm: Gua del Usuario -> Comandos": {"id": "hpm-commands", "content": "# Referencia de Comandos\n\nReferencia completa de todos los comandos de hpm.\n\n## Opciones Globales\n\nEstas opciones funcionan con cualquier comando:\n\n| Opcion | Descripcion |\n|--------|-------------|\n| `--help`, `-h` | Mostrar mensaje de ayuda |\n| `--version`, `-v` | Mostrar version de hpm |\n| `--verbose` | Mostrar salida detallada |\n\n## Comandos\n\n### hpm init\n\nCrea un nuevo archivo `package.json`.\n\n```bash\nhpm init        # Modo interactivo\nhpm init --yes  # Aceptar todos los valores por defecto\nhpm init -y     # Forma corta\n```\n\n**Opciones:**\n\n| Opcion | Descripcion |\n|--------|-------------|\n| `--yes`, `-y` | Aceptar valores por defecto para todas las preguntas |\n\n**Preguntas interactivas:**\n- Nombre del paquete (formato owner/repo)\n- Version (por defecto: 1.0.0)\n- Descripcion\n- Autor\n- Licencia (por defecto: MIT)\n- Archivo principal (por defecto: src/index.hml)\n\n**Ejemplo:**\n\n```bash\n$ hpm init\nPackage name (owner/repo): alice/my-lib\nVersion (1.0.0):\nDescription: A utility library\nAuthor: Alice <alice@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n---\n\n### hpm install\n\nInstala dependencias o agrega nuevos paquetes.\n\n```bash\nhpm install                           # Instalar todo desde package.json\nhpm install owner/repo                # Agregar e instalar paquete\nhpm install owner/repo@^1.0.0        # Con restriccion de version\nhpm install owner/repo --dev         # Como dependencia de desarrollo\nhpm i owner/repo                      # Forma corta\n```\n\n**Opciones:**\n\n| Opcion | Descripcion |\n|--------|-------------|\n| `--dev`, `-D` | Agregar a devDependencies |\n| `--verbose` | Mostrar progreso detallado |\n| `--dry-run` | Vista previa sin instalar |\n| `--offline` | Instalar solo desde cache (sin red) |\n| `--parallel` | Habilitar descargas paralelas (experimental) |\n\n**Sintaxis de restriccion de version:**\n\n| Sintaxis | Ejemplo | Significado |\n|----------|---------|-------------|\n| (ninguna) | `owner/repo` | Ultima version |\n| Exacta | `owner/repo@1.2.3` | Exactamente 1.2.3 |\n| Caret | `owner/repo@^1.2.3` | >=1.2.3 <2.0.0 |\n| Tilde | `owner/repo@~1.2.3` | >=1.2.3 <1.3.0 |\n| Rango | `owner/repo@>=1.0.0` | Al menos 1.0.0 |\n\n**Ejemplos:**\n\n```bash\n# Instalar todas las dependencias\nhpm install\n\n# Instalar paquete especifico\nhpm install hemlang/json\n\n# Instalar con restriccion de version\nhpm install hemlang/sprout@^2.0.0\n\n# Instalar como dependencia de desarrollo\nhpm install hemlang/test-utils --dev\n\n# Vista previa de lo que se instalaria\nhpm install hemlang/sprout --dry-run\n\n# Salida detallada\nhpm install --verbose\n\n# Instalar solo desde cache (sin conexion)\nhpm install --offline\n```\n\n**Salida:**\n\n```\nInstalling dependencies...\n  + hemlang/sprout@2.1.0\n  + hemlang/router@1.5.0 (dependency of hemlang/sprout)\n\nInstalled 2 packages in 1.2s\n```\n\n---\n\n### hpm uninstall\n\nElimina un paquete.\n\n```bash\nhpm uninstall owner/repo\nhpm rm owner/repo          # Forma corta\nhpm remove owner/repo      # Alternativa\n```\n\n**Ejemplos:**\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n**Salida:**\n\n```\nRemoved hemlang/sprout@2.1.0\nUpdated package.json\nUpdated package-lock.json\n```\n\n---\n\n### hpm update\n\nActualiza paquetes a las ultimas versiones dentro de las restricciones.\n\n```bash\nhpm update              # Actualizar todos los paquetes\nhpm update owner/repo   # Actualizar paquete especifico\nhpm up owner/repo       # Forma corta\n```\n\n**Opciones:**\n\n| Opcion | Descripcion |\n|--------|-------------|\n| `--verbose` | Mostrar progreso detallado |\n| `--dry-run` | Vista previa sin actualizar |\n\n**Ejemplos:**\n\n```bash\n# Actualizar todos los paquetes\nhpm update\n\n# Actualizar paquete especifico\nhpm update hemlang/sprout\n\n# Vista previa de actualizaciones\nhpm update --dry-run\n```\n\n**Salida:**\n\n```\nUpdating dependencies...\n  hemlang/sprout: 2.0.0  2.1.0\n  hemlang/router: 1.4.0  1.5.0\n\nUpdated 2 packages\n```\n\n---\n\n### hpm list\n\nMuestra los paquetes instalados.\n\n```bash\nhpm list              # Mostrar arbol completo de dependencias\nhpm list --depth=0    # Solo dependencias directas\nhpm list --depth=1    # Un nivel de dependencias transitivas\nhpm ls                # Forma corta\n```\n\n**Opciones:**\n\n| Opcion | Descripcion |\n|--------|-------------|\n| `--depth=N` | Limitar profundidad del arbol (por defecto: todo) |\n\n**Ejemplos:**\n\n```bash\n$ hpm list\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n    hemlang/router@1.5.0\n    hemlang/middleware@1.2.0\n hemlang/json@1.2.3\n hemlang/test-utils@1.0.0 (dev)\n\n$ hpm list --depth=0\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n hemlang/json@1.2.3\n hemlang/test-utils@1.0.0 (dev)\n```\n\n---\n\n### hpm outdated\n\nMuestra los paquetes con versiones mas nuevas disponibles.\n\n```bash\nhpm outdated\n```\n\n**Salida:**\n\n```\nPackage            Current  Wanted  Latest\nhemlang/sprout     2.0.0    2.0.5   2.1.0\nhemlang/router     1.4.0    1.4.2   1.5.0\n```\n\n- **Current**: Version instalada\n- **Wanted**: Version mas alta que coincide con la restriccion\n- **Latest**: Ultima version disponible\n\n---\n\n### hpm run\n\nEjecuta un script desde package.json.\n\n```bash\nhpm run <script>\nhpm run <script> -- <args>\n```\n\n**Ejemplos:**\n\nDado este package.json:\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\nEjecutar scripts:\n\n```bash\nhpm run start\nhpm run test\nhpm run build\n\n# Pasar argumentos al script\nhpm run test -- --verbose\n```\n\n---\n\n### hpm test\n\nAtajo para `hpm run test`.\n\n```bash\nhpm test\nhpm test -- --verbose\n```\n\nEquivalente a:\n\n```bash\nhpm run test\n```\n\n---\n\n### hpm why\n\nExplica por que un paquete esta instalado (muestra la cadena de dependencias).\n\n```bash\nhpm why owner/repo\n```\n\n**Ejemplo:**\n\n```bash\n$ hpm why hemlang/router\n\nhemlang/router@1.5.0 is installed because:\n\nmy-project@1.0.0\n hemlang/sprout@2.1.0\n     hemlang/router@1.5.0\n```\n\n---\n\n### hpm cache\n\nAdministra la cache global de paquetes.\n\n```bash\nhpm cache list    # Listar paquetes en cache\nhpm cache clean   # Limpiar todos los paquetes en cache\n```\n\n**Subcomandos:**\n\n| Subcomando | Descripcion |\n|------------|-------------|\n| `list` | Mostrar todos los paquetes en cache y sus tamanos |\n| `clean` | Eliminar todos los paquetes en cache |\n\n**Ejemplos:**\n\n```bash\n$ hpm cache list\nCached packages in ~/.hpm/cache:\n\nhemlang/sprout\n  2.0.0 (1.2 MB)\n  2.1.0 (1.3 MB)\nhemlang/router\n  1.5.0 (450 KB)\n\nTotal: 2.95 MB\n\n$ hpm cache clean\nCleared cache (2.95 MB freed)\n```\n\n---\n\n## Atajos de Comandos\n\nPor conveniencia, varios comandos tienen alias cortos:\n\n| Comando | Atajos |\n|---------|--------|\n| `install` | `i` |\n| `uninstall` | `rm`, `remove` |\n| `list` | `ls` |\n| `update` | `up` |\n\n**Ejemplos:**\n\n```bash\nhpm i hemlang/sprout        # hpm install hemlang/sprout\nhpm rm hemlang/sprout       # hpm uninstall hemlang/sprout\nhpm ls                      # hpm list\nhpm up                      # hpm update\n```\n\n---\n\n## Codigos de Salida\n\nhpm usa codigos de salida especificos para indicar diferentes condiciones de error:\n\n| Codigo | Significado |\n|--------|-------------|\n| 0 | Exito |\n| 1 | Conflicto de dependencias |\n| 2 | Paquete no encontrado |\n| 3 | Version no encontrada |\n| 4 | Error de red |\n| 5 | package.json invalido |\n| 6 | Verificacion de integridad fallida |\n| 7 | Limite de tasa de GitHub excedido |\n| 8 | Dependencia circular |\n\nUsa codigos de salida en scripts:\n\n```bash\nhpm install\nif [ $? -ne 0 ]; then\n    echo \"Installation failed\"\n    exit 1\nfi\n```\n\n---\n\n## Variables de Entorno\n\nhpm respeta estas variables de entorno:\n\n| Variable | Descripcion |\n|----------|-------------|\n| `GITHUB_TOKEN` | Token de API de GitHub para autenticacion |\n| `HPM_CACHE_DIR` | Sobrescribir ubicacion del directorio de cache |\n| `HOME` | Directorio home del usuario (para config/cache) |\n\n**Ejemplos:**\n\n```bash\n# Usar token de GitHub para mayores limites de tasa\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Usar directorio de cache personalizado\nexport HPM_CACHE_DIR=/tmp/hpm-cache\nhpm install\n```\n\n---\n\n## Ver Tambien\n\n- [Configuracion](#hpm-commands-configuration) - Archivos de configuracion\n- [Especificacion de Paquetes](#hpm-commands-package-spec) - formato de package.json\n- [Solucion de Problemas](#hpm-commands-troubleshooting) - Problemas comunes\n"}, "hpm: Gua del Usuario -> Configuracin": {"id": "hpm-configuration", "content": "# Configuracion\n\nEsta guia cubre todas las opciones de configuracion para hpm.\n\n## Descripcion General\n\nhpm puede configurarse a traves de:\n\n1. **Variables de entorno** - Para configuraciones en tiempo de ejecucion\n2. **Archivo de configuracion global** - `~/.hpm/config.json`\n3. **Archivos del proyecto** - `package.json` y `package-lock.json`\n\n## Variables de Entorno\n\n### GITHUB_TOKEN\n\nToken de API de GitHub para autenticacion.\n\n```bash\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n```\n\n**Beneficios de la autenticacion:**\n- Mayores limites de tasa de API (5000 vs 60 solicitudes/hora)\n- Acceso a repositorios privados\n- Resolucion de dependencias mas rapida\n\n**Crear un token:**\n\n1. Ve a GitHub  Settings  Developer settings  Personal access tokens\n2. Haz clic en \"Generate new token (classic)\"\n3. Selecciona los alcances:\n   - `repo` - Para acceso a repositorios privados\n   - `read:packages` - Para GitHub Packages (si se usa)\n4. Genera y copia el token\n\n### HPM_CACHE_DIR\n\nSobrescribe el directorio de cache por defecto.\n\n```bash\nexport HPM_CACHE_DIR=/custom/cache/path\n```\n\nPor defecto: `~/.hpm/cache`\n\n**Casos de uso:**\n- Sistemas CI/CD con ubicaciones de cache personalizadas\n- Cache compartida entre proyectos\n- Cache temporal para compilaciones aisladas\n\n### HOME\n\nDirectorio home del usuario. Se usa para ubicar:\n- Directorio de configuracion: `$HOME/.hpm/`\n- Directorio de cache: `$HOME/.hpm/cache/`\n\nNormalmente establecido por el sistema; sobrescribe solo si es necesario.\n\n### Ejemplo .bashrc / .zshrc\n\n```bash\n# GitHub authentication (recommended)\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n\n# Custom cache location (optional)\n# export HPM_CACHE_DIR=/path/to/cache\n\n# Add hpm to PATH (if using custom install location)\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## Archivo de Configuracion Global\n\n### Ubicacion\n\n`~/.hpm/config.json`\n\n### Formato\n\n```json\n{\n  \"github_token\": \"ghp_xxxxxxxxxxxxxxxxxxxx\"\n}\n```\n\n### Crear el Archivo de Configuracion\n\n```bash\n# Crear directorio de configuracion\nmkdir -p ~/.hpm\n\n# Crear archivo de configuracion\ncat > ~/.hpm/config.json << 'EOF'\n{\n  \"github_token\": \"ghp_your_token_here\"\n}\nEOF\n\n# Asegurar el archivo (recomendado)\nchmod 600 ~/.hpm/config.json\n```\n\n### Prioridad del Token\n\nSi ambos estan establecidos, la variable de entorno tiene precedencia:\n\n1. Variable de entorno `GITHUB_TOKEN` (mayor)\n2. Campo `github_token` de `~/.hpm/config.json`\n3. Sin autenticacion (por defecto)\n\n## Estructura de Directorios\n\n### Directorios Globales\n\n```\n~/.hpm/\n config.json          # Configuracion global\n cache/               # Cache de paquetes\n     owner/\n         repo/\n             1.0.0.tar.gz\n```\n\n### Directorios del Proyecto\n\n```\nmy-project/\n package.json         # Manifiesto del proyecto\n package-lock.json    # Archivo de bloqueo de dependencias\n hem_modules/         # Paquetes instalados\n    owner/\n        repo/\n            package.json\n            src/\n src/                 # Codigo fuente\n test/                # Pruebas\n```\n\n## Cache de Paquetes\n\n### Ubicacion\n\nPor defecto: `~/.hpm/cache/`\n\nSobrescribir con: variable de entorno `HPM_CACHE_DIR`\n\n### Estructura\n\n```\n~/.hpm/cache/\n hemlang/\n    sprout/\n       2.0.0.tar.gz\n       2.1.0.tar.gz\n    router/\n        1.5.0.tar.gz\n alice/\n     http-client/\n         1.0.0.tar.gz\n```\n\n### Administrar la Cache\n\n```bash\n# Ver paquetes en cache\nhpm cache list\n\n# Limpiar toda la cache\nhpm cache clean\n```\n\n### Comportamiento de la Cache\n\n- Los paquetes se almacenan en cache despues de la primera descarga\n- Las instalaciones posteriores usan versiones en cache\n- Usa `--offline` para instalar solo desde cache\n- La cache se comparte entre todos los proyectos\n\n## Limites de Tasa de API de GitHub\n\n### Sin Autenticacion\n\n- **60 solicitudes por hora** por direccion IP\n- Compartido entre todos los usuarios no autenticados en la misma IP\n- Se agota rapidamente en CI/CD o con muchas dependencias\n\n### Con Autenticacion\n\n- **5000 solicitudes por hora** por usuario autenticado\n- Limite de tasa personal, no compartido\n\n### Manejo de Limites de Tasa\n\nhpm automaticamente:\n- Reintenta con retroceso exponencial (1s, 2s, 4s, 8s)\n- Reporta errores de limite de tasa con codigo de salida 7\n- Sugiere autenticacion si se alcanza el limite\n\n**Soluciones cuando se alcanza el limite:**\n\n```bash\n# Opcion 1: Autenticar con token de GitHub\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Opcion 2: Esperar a que se reinicie el limite de tasa\n# (Los limites se reinician cada hora)\n\n# Opcion 3: Usar modo sin conexion (si los paquetes estan en cache)\nhpm install --offline\n```\n\n## Modo Sin Conexion\n\nInstalar paquetes sin acceso a red:\n\n```bash\nhpm install --offline\n```\n\n**Requisitos:**\n- Todos los paquetes deben estar en cache\n- El archivo de bloqueo debe existir con versiones exactas\n\n**Casos de uso:**\n- Entornos aislados\n- Compilaciones de CI/CD mas rapidas (con cache caliente)\n- Evitar limites de tasa\n\n## Configuracion de CI/CD\n\n### GitHub Actions\n\n```yaml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Setup Hemlock\n      run: |\n        # Install Hemlock (adjust based on your setup)\n        curl -sSL https://hemlock.dev/install.sh | sh\n\n    - name: Cache hpm packages\n      uses: actions/cache@v3\n      with:\n        path: ~/.hpm/cache\n        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}\n        restore-keys: |\n          ${{ runner.os }}-hpm-\n\n    - name: Install dependencies\n      run: hpm install\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Run tests\n      run: hpm test\n```\n\n### GitLab CI\n\n```yaml\nstages:\n  - build\n  - test\n\nvariables:\n  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache\n\ncache:\n  paths:\n    - .hpm-cache/\n  key: $CI_COMMIT_REF_SLUG\n\nbuild:\n  stage: build\n  script:\n    - hpm install\n  artifacts:\n    paths:\n      - hem_modules/\n\ntest:\n  stage: test\n  script:\n    - hpm test\n```\n\n### Docker\n\n**Dockerfile:**\n\n```dockerfile\nFROM hemlock:latest\n\nWORKDIR /app\n\n# Copy package files first (for layer caching)\nCOPY package.json package-lock.json ./\n\n# Install dependencies\nRUN hpm install\n\n# Copy source code\nCOPY . .\n\n# Run application\nCMD [\"hemlock\", \"src/main.hml\"]\n```\n\n**docker-compose.yml:**\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    environment:\n      - GITHUB_TOKEN=${GITHUB_TOKEN}\n    volumes:\n      - hpm-cache:/root/.hpm/cache\n\nvolumes:\n  hpm-cache:\n```\n\n## Configuracion de Proxy\n\nPara entornos detras de un proxy, configura a nivel de sistema:\n\n```bash\nexport HTTP_PROXY=http://proxy.example.com:8080\nexport HTTPS_PROXY=http://proxy.example.com:8080\nexport NO_PROXY=localhost,127.0.0.1\n\nhpm install\n```\n\n## Mejores Practicas de Seguridad\n\n### Seguridad de Tokens\n\n1. **Nunca envies tokens** al control de versiones\n2. **Usa variables de entorno** en CI/CD\n3. **Restringe los alcances de tokens** al minimo requerido\n4. **Rota tokens** regularmente\n5. **Asegura el archivo de configuracion**:\n   ```bash\n   chmod 600 ~/.hpm/config.json\n   ```\n\n### Repositorios Privados\n\nPara acceder a paquetes privados:\n\n1. Crea un token con alcance `repo`\n2. Configura la autenticacion (variable de entorno o archivo de configuracion)\n3. Asegurate de que el token tenga acceso al repositorio\n\n```bash\n# Probar acceso\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install yourorg/private-package\n```\n\n## Solucion de Problemas de Configuracion\n\n### Verificar Configuracion\n\n```bash\n# Verificar si el token esta establecido\necho $GITHUB_TOKEN | head -c 10\n\n# Verificar archivo de configuracion\ncat ~/.hpm/config.json\n\n# Verificar directorio de cache\nls -la ~/.hpm/cache/\n\n# Probar con salida detallada\nhpm install --verbose\n```\n\n### Problemas Comunes\n\n**\"GitHub rate limit exceeded\"**\n- Configura autenticacion con `GITHUB_TOKEN`\n- Espera a que se reinicie el limite de tasa\n- Usa `--offline` si los paquetes estan en cache\n\n**\"Permission denied\" en cache**\n```bash\n# Arreglar permisos de cache\nchmod -R u+rw ~/.hpm/cache\n```\n\n**\"Config file not found\"**\n```bash\n# Crear directorio de configuracion\nmkdir -p ~/.hpm\ntouch ~/.hpm/config.json\n```\n\n## Ver Tambien\n\n- [Instalacion](#hpm-configuration-installation) - Instalar hpm\n- [Solucion de Problemas](#hpm-configuration-troubleshooting) - Problemas comunes\n- [Comandos](#hpm-configuration-commands) - Referencia de comandos\n"}, "hpm: Gua del Usuario -> Solucin de Problemas": {"id": "hpm-troubleshooting", "content": "# Solucion de Problemas\n\nSoluciones a problemas comunes de hpm.\n\n## Problemas de Instalacion\n\n### \"hemlock: command not found\"\n\n**Causa:** Hemlock no esta instalado o no esta en el PATH.\n\n**Solucion:**\n\n```bash\n# Verificar si hemlock existe\nwhich hemlock\n\n# Si no se encuentra, instalar Hemlock primero\n# Visita: https://github.com/hemlang/hemlock\n\n# Despues de la instalacion, verificar\nhemlock --version\n```\n\n### \"hpm: command not found\"\n\n**Causa:** hpm no esta instalado o no esta en el PATH.\n\n**Solucion:**\n\n```bash\n# Verificar donde esta instalado hpm\nls -la /usr/local/bin/hpm\nls -la ~/.local/bin/hpm\n\n# Si usas ubicacion personalizada, agregar al PATH\nexport PATH=\"$HOME/.local/bin:$PATH\"\n\n# Agregar a ~/.bashrc o ~/.zshrc para persistencia\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc\nsource ~/.bashrc\n\n# Reinstalar si es necesario\ncd /path/to/hpm\nsudo make install\n```\n\n### \"Permission denied\" durante la instalacion\n\n**Causa:** Sin permiso de escritura en el directorio de instalacion.\n\n**Solucion:**\n\n```bash\n# Opcion 1: Usar sudo para instalacion en todo el sistema\nsudo make install\n\n# Opcion 2: Instalar en directorio de usuario (sin sudo)\nmake install PREFIX=$HOME/.local\n```\n\n## Problemas de Dependencias\n\n### \"Package not found\" (codigo de salida 2)\n\n**Causa:** El paquete no existe en GitHub.\n\n**Solucion:**\n\n```bash\n# Verificar que el paquete existe\n# Verifica: https://github.com/owner/repo\n\n# Verificar ortografia\nhpm install hemlang/sprout  # Correcto\nhpm install hemlan/sprout   # Owner incorrecto\nhpm install hemlang/spout   # Repo incorrecto\n\n# Verificar errores tipograficos en package.json\ncat package.json | grep -A 5 dependencies\n```\n\n### \"Version not found\" (codigo de salida 3)\n\n**Causa:** Ninguna version coincide con la restriccion de version.\n\n**Solucion:**\n\n```bash\n# Listar versiones disponibles (verificar releases/tags en GitHub)\n# Las etiquetas deben comenzar con 'v' (ej., v1.0.0)\n\n# Usar una restriccion de version valida\nhpm install owner/repo@^1.0.0\n\n# Intentar ultima version\nhpm install owner/repo\n\n# Verificar etiquetas disponibles en GitHub\n# https://github.com/owner/repo/tags\n```\n\n### \"Dependency conflict\" (codigo de salida 1)\n\n**Causa:** Dos paquetes requieren versiones incompatibles de una dependencia.\n\n**Solucion:**\n\n```bash\n# Ver el conflicto\nhpm install --verbose\n\n# Verificar que requiere la dependencia\nhpm why conflicting/package\n\n# Soluciones:\n# 1. Actualizar el paquete en conflicto\nhpm update problem/package\n\n# 2. Cambiar restricciones de version en package.json\n# Editar para permitir versiones compatibles\n\n# 3. Eliminar uno de los paquetes en conflicto\nhpm uninstall one/package\n```\n\n### \"Circular dependency\" (codigo de salida 8)\n\n**Causa:** El paquete A depende de B, que depende de A.\n\n**Solucion:**\n\n```bash\n# Identificar el ciclo\nhpm install --verbose\n\n# Esto generalmente es un error en los paquetes\n# Contactar a los mantenedores del paquete\n\n# Solucion alternativa: evitar uno de los paquetes\n```\n\n## Problemas de Red\n\n### \"Network error\" (codigo de salida 4)\n\n**Causa:** No se puede conectar a la API de GitHub.\n\n**Solucion:**\n\n```bash\n# Verificar conexion a internet\nping github.com\n\n# Verificar si la API de GitHub es accesible\ncurl -I https://api.github.com\n\n# Intentar de nuevo (hpm reintenta automaticamente)\nhpm install\n\n# Usar modo sin conexion si los paquetes estan en cache\nhpm install --offline\n\n# Verificar configuracion de proxy si estas detras de un firewall\nexport HTTPS_PROXY=http://proxy:8080\nhpm install\n```\n\n### \"GitHub rate limit exceeded\" (codigo de salida 7)\n\n**Causa:** Demasiadas solicitudes a la API sin autenticacion.\n\n**Solucion:**\n\n```bash\n# Opcion 1: Autenticar con token de GitHub (recomendado)\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# Crear token: GitHub  Settings  Developer settings  Personal access tokens\n\n# Opcion 2: Guardar token en archivo de configuracion\nmkdir -p ~/.hpm\necho '{\"github_token\": \"ghp_xxxxxxxxxxxx\"}' > ~/.hpm/config.json\n\n# Opcion 3: Esperar a que se reinicie el limite de tasa (se reinicia cada hora)\n\n# Opcion 4: Usar modo sin conexion\nhpm install --offline\n```\n\n### Timeout de conexion\n\n**Causa:** Red lenta o problemas con la API de GitHub.\n\n**Solucion:**\n\n```bash\n# hpm reintenta automaticamente con retroceso exponencial\n\n# Verificar si GitHub tiene problemas\n# Visita: https://www.githubstatus.com\n\n# Intentar mas tarde\nhpm install\n\n# Usar paquetes en cache\nhpm install --offline\n```\n\n## Problemas de Package.json\n\n### \"Invalid package.json\" (codigo de salida 5)\n\n**Causa:** Formato incorrecto o campos requeridos faltantes.\n\n**Solucion:**\n\n```bash\n# Validar sintaxis JSON\ncat package.json | python -m json.tool\n\n# Verificar campos requeridos\ncat package.json\n\n# Campos requeridos:\n# - \"name\": formato \"owner/repo\"\n# - \"version\": formato \"X.Y.Z\"\n\n# Regenerar si es necesario\nrm package.json\nhpm init\n```\n\n### Error de formato \"name\"\n\n**Causa:** Nombre del paquete no esta en formato `owner/repo`.\n\n**Solucion:**\n\n```json\n// Incorrecto\n{\n  \"name\": \"my-package\"\n}\n\n// Correcto\n{\n  \"name\": \"yourusername/my-package\"\n}\n```\n\n### Error de formato \"version\"\n\n**Causa:** Version no esta en formato semver.\n\n**Solucion:**\n\n```json\n// Incorrecto\n{\n  \"version\": \"1.0\"\n}\n\n// Correcto\n{\n  \"version\": \"1.0.0\"\n}\n```\n\n## Problemas del Archivo de Bloqueo\n\n### Archivo de bloqueo desincronizado\n\n**Causa:** package.json modificado sin ejecutar install.\n\n**Solucion:**\n\n```bash\n# Regenerar archivo de bloqueo\nrm package-lock.json\nhpm install\n```\n\n### Archivo de bloqueo corrupto\n\n**Causa:** JSON invalido o ediciones manuales.\n\n**Solucion:**\n\n```bash\n# Verificar validez del JSON\ncat package-lock.json | python -m json.tool\n\n# Regenerar\nrm package-lock.json\nhpm install\n```\n\n## Problemas de hem_modules\n\n### Los paquetes no se instalan\n\n**Causa:** Varios problemas posibles.\n\n**Solucion:**\n\n```bash\n# Limpiar y reinstalar\nrm -rf hem_modules\nhpm install\n\n# Verificar salida detallada\nhpm install --verbose\n```\n\n### La importacion no funciona\n\n**Causa:** Paquete no instalado correctamente o ruta de importacion incorrecta.\n\n**Solucion:**\n\n```bash\n# Verificar que el paquete este instalado\nls hem_modules/owner/repo/\n\n# Verificar campo main de package.json\ncat hem_modules/owner/repo/package.json\n\n# Formato correcto de importacion\nimport { x } from \"owner/repo\";          # Usa entrada main\nimport { y } from \"owner/repo/subpath\";  # Importacion de subruta\n```\n\n### Error \"Module not found\"\n\n**Causa:** La ruta de importacion no resuelve a un archivo.\n\n**Solucion:**\n\n```bash\n# Verificar ruta de importacion\nls hem_modules/owner/repo/src/\n\n# Verificar existencia de index.hml\nls hem_modules/owner/repo/src/index.hml\n\n# Verificar campo main en package.json\ncat hem_modules/owner/repo/package.json | grep main\n```\n\n## Problemas de Cache\n\n### La cache ocupa demasiado espacio\n\n**Solucion:**\n\n```bash\n# Ver tamano de cache\nhpm cache list\n\n# Limpiar cache\nhpm cache clean\n```\n\n### Permisos de cache\n\n**Solucion:**\n\n```bash\n# Arreglar permisos\nchmod -R u+rw ~/.hpm/cache\n\n# O eliminar y reinstalar\nrm -rf ~/.hpm/cache\nhpm install\n```\n\n### Usando cache incorrecta\n\n**Solucion:**\n\n```bash\n# Verificar ubicacion de cache\necho $HPM_CACHE_DIR\nls ~/.hpm/cache\n\n# Limpiar variable de entorno si es incorrecta\nunset HPM_CACHE_DIR\n```\n\n## Problemas de Scripts\n\n### \"Script not found\"\n\n**Causa:** El nombre del script no existe en package.json.\n\n**Solucion:**\n\n```bash\n# Listar scripts disponibles\ncat package.json | grep -A 20 scripts\n\n# Verificar ortografia\nhpm run test    # Correcto\nhpm run tests   # Incorrecto si el script se llama \"test\"\n```\n\n### El script falla\n\n**Causa:** Error en el comando del script.\n\n**Solucion:**\n\n```bash\n# Ejecutar comando directamente para ver el error\nhemlock test/run.hml\n\n# Verificar definicion del script\ncat package.json | grep test\n```\n\n## Depuracion\n\n### Habilitar salida detallada\n\n```bash\nhpm install --verbose\n```\n\n### Verificar version de hpm\n\n```bash\nhpm --version\n```\n\n### Verificar version de hemlock\n\n```bash\nhemlock --version\n```\n\n### Ejecucion en seco\n\nVista previa sin hacer cambios:\n\n```bash\nhpm install --dry-run\n```\n\n### Empezar de cero\n\nComenzar desde cero:\n\n```bash\nrm -rf hem_modules package-lock.json\nhpm install\n```\n\n## Obtener Ayuda\n\n### Ayuda de comandos\n\n```bash\nhpm --help\nhpm install --help\n```\n\n### Reportar problemas\n\nSi encuentras un error:\n\n1. Verifica problemas existentes: https://github.com/hemlang/hpm/issues\n2. Crea un nuevo problema con:\n   - Version de hpm (`hpm --version`)\n   - Version de Hemlock (`hemlock --version`)\n   - Sistema operativo\n   - Pasos para reproducir\n   - Mensaje de error (usa `--verbose`)\n\n## Referencia de Codigos de Salida\n\n| Codigo | Significado | Solucion Comun |\n|--------|-------------|----------------|\n| 0 | Exito | - |\n| 1 | Conflicto de dependencias | Actualizar o cambiar restricciones |\n| 2 | Paquete no encontrado | Verificar ortografia, verificar que el repo existe |\n| 3 | Version no encontrada | Verificar versiones disponibles en GitHub |\n| 4 | Error de red | Verificar conexion, reintentar |\n| 5 | package.json invalido | Arreglar sintaxis JSON y campos requeridos |\n| 6 | Verificacion de integridad fallida | Limpiar cache, reinstalar |\n| 7 | Limite de tasa de GitHub | Agregar GITHUB_TOKEN |\n| 8 | Dependencia circular | Contactar mantenedores del paquete |\n\n## Ver Tambien\n\n- [Instalacion](#hpm-troubleshooting-installation) - Guia de instalacion\n- [Configuracion](#hpm-troubleshooting-configuration) - Opciones de configuracion\n- [Comandos](#hpm-troubleshooting-commands) - Referencia de comandos\n"}, "hpm: Desarrollo de Paquetes -> Creacin de Paquetes": {"id": "hpm-creating-packages", "content": "# Creacion de Paquetes\n\nEsta guia cubre como crear, estructurar y publicar paquetes Hemlock.\n\n## Descripcion General\n\nhpm usa GitHub como su registro de paquetes. Los paquetes se identifican por su ruta `owner/repo` de GitHub, y las versiones son etiquetas de Git. Publicar es simplemente enviar una version etiquetada.\n\n## Crear un Nuevo Paquete\n\n### 1. Inicializar el Paquete\n\nCrea un nuevo directorio e inicializa:\n\n```bash\nmkdir my-package\ncd my-package\nhpm init\n```\n\nResponde las preguntas:\n\n```\nPackage name (owner/repo): yourusername/my-package\nVersion (1.0.0):\nDescription: A useful Hemlock package\nAuthor: Your Name <you@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n### 2. Crear la Estructura del Proyecto\n\nEstructura recomendada para paquetes:\n\n```\nmy-package/\n package.json          # Manifiesto del paquete\n README.md             # Documentacion\n LICENSE               # Archivo de licencia\n src/\n    index.hml         # Punto de entrada principal (exporta API publica)\n    utils.hml         # Utilidades internas\n    types.hml         # Definiciones de tipos\n test/\n     framework.hml     # Framework de pruebas\n     test_utils.hml    # Pruebas\n```\n\n### 3. Definir Tu API Publica\n\n**src/index.hml** - Punto de entrada principal:\n\n```hemlock\n// Re-export public API\nexport { parse, stringify } from \"./parser.hml\";\nexport { Config, Options } from \"./types.hml\";\nexport { process } from \"./processor.hml\";\n\n// Direct exports\nexport fn create(options: Options): Config {\n    // Implementation\n}\n\nexport fn validate(config: Config): bool {\n    // Implementation\n}\n```\n\n### 4. Escribir Tu package.json\n\nEjemplo completo de package.json:\n\n```json\n{\n  \"name\": \"yourusername/my-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A useful Hemlock package\",\n  \"author\": \"Your Name <you@example.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/yourusername/my-package\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/bundle.hmlc\"\n  },\n  \"keywords\": [\"utility\", \"parser\", \"config\"],\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n## Nomenclatura de Paquetes\n\n### Requisitos\n\n- Debe estar en formato `owner/repo`\n- `owner` debe ser tu nombre de usuario u organizacion de GitHub\n- `repo` debe ser el nombre del repositorio\n- Usa minusculas con guiones para nombres de varias palabras\n\n### Buenos Nombres\n\n```\nhemlang/sprout\nalice/http-client\nmyorg/json-utils\nbob/date-formatter\n```\n\n### Evitar\n\n```\nmy-package          # Falta owner\nalice/MyPackage     # PascalCase\nalice/my_package    # Guiones bajos\n```\n\n## Mejores Practicas de Estructura de Paquetes\n\n### Punto de Entrada\n\nEl campo `main` en package.json especifica el punto de entrada:\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\nEste archivo debe exportar tu API publica:\n\n```hemlock\n// Export everything users need\nexport { Parser, parse } from \"./parser.hml\";\nexport { Formatter, format } from \"./formatter.hml\";\n\n// Types\nexport type { Config, Options } from \"./types.hml\";\n```\n\n### Interno vs Publico\n\nMantener los detalles de implementacion interna privados:\n\n```\nsrc/\n index.hml          # Publico: API exportada\n parser.hml         # Publico: usado por index.hml\n formatter.hml      # Publico: usado por index.hml\n internal/\n     helpers.hml    # Privado: solo uso interno\n     constants.hml  # Privado: solo uso interno\n```\n\nLos usuarios importan desde la raiz de tu paquete:\n\n```hemlock\n// Bien - importa desde API publica\nimport { parse, Parser } from \"yourusername/my-package\";\n\n// Tambien funciona - importacion de subruta\nimport { validate } from \"yourusername/my-package/validator\";\n\n// Desaconsejado - acceder a internos\nimport { helper } from \"yourusername/my-package/internal/helpers\";\n```\n\n### Exportaciones de Subrutas\n\nSoportar importacion desde subrutas:\n\n```\nsrc/\n index.hml              # Entrada principal\n parser/\n    index.hml          # yourusername/pkg/parser\n formatter/\n    index.hml          # yourusername/pkg/formatter\n utils/\n     index.hml          # yourusername/pkg/utils\n```\n\nLos usuarios pueden importar:\n\n```hemlock\nimport { parse } from \"yourusername/my-package\";           # Principal\nimport { Parser } from \"yourusername/my-package/parser\";   # Subruta\nimport { format } from \"yourusername/my-package/formatter\";\n```\n\n## Dependencias\n\n### Agregar Dependencias\n\n```bash\n# Dependencia de tiempo de ejecucion\nhpm install hemlang/json\n\n# Dependencia de desarrollo\nhpm install hemlang/test-utils --dev\n```\n\n### Mejores Practicas de Dependencias\n\n1. **Usar rangos caret** para la mayoria de dependencias:\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     }\n   }\n   ```\n\n2. **Fijar versiones** solo cuando sea necesario (inestabilidad de API):\n   ```json\n   {\n     \"dependencies\": {\n       \"unstable/lib\": \"1.2.3\"\n     }\n   }\n   ```\n\n3. **Evitar rangos demasiado restrictivos**:\n   ```json\n   // Malo: demasiado restrictivo\n   \"hemlang/json\": \">=1.2.3 <1.2.5\"\n\n   // Bueno: permite actualizaciones compatibles\n   \"hemlang/json\": \"^1.2.3\"\n   ```\n\n4. **Separar dependencias de desarrollo**:\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     },\n     \"devDependencies\": {\n       \"hemlang/test-utils\": \"^1.0.0\"\n     }\n   }\n   ```\n\n## Probar Tu Paquete\n\n### Escribir Pruebas\n\n**test/run.hml:**\n\n```hemlock\nimport { suite, test, assert_eq } from \"./framework.hml\";\nimport { parse, stringify } from \"../src/index.hml\";\n\nfn run_tests() {\n    suite(\"Parser\", fn() {\n        test(\"parses valid input\", fn() {\n            let result = parse(\"hello\");\n            assert_eq(result.value, \"hello\");\n        });\n\n        test(\"handles empty input\", fn() {\n            let result = parse(\"\");\n            assert_eq(result.value, \"\");\n        });\n    });\n\n    suite(\"Stringify\", fn() {\n        test(\"stringifies object\", fn() {\n            let obj = { name: \"test\" };\n            let result = stringify(obj);\n            assert_eq(result, '{\"name\":\"test\"}');\n        });\n    });\n}\n\nrun_tests();\n```\n\n### Ejecutar Pruebas\n\nAgrega un script de pruebas:\n\n```json\n{\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\nEjecuta con:\n\n```bash\nhpm test\n```\n\n## Publicacion\n\n### Prerrequisitos\n\n1. Crear un repositorio en GitHub que coincida con el nombre de tu paquete\n2. Asegurar que `package.json` este completo y sea valido\n3. Todas las pruebas pasan\n\n### Proceso de Publicacion\n\nPublicar es simplemente enviar una etiqueta de Git:\n\n```bash\n# 1. Asegurar que todo este confirmado\ngit add .\ngit commit -m \"Prepare v1.0.0 release\"\n\n# 2. Crear una etiqueta de version (debe comenzar con 'v')\ngit tag v1.0.0\n\n# 3. Enviar codigo y etiquetas\ngit push origin main\ngit push origin v1.0.0\n# O enviar todas las etiquetas a la vez\ngit push origin main --tags\n```\n\n### Etiquetas de Version\n\nLas etiquetas deben seguir el formato `vX.Y.Z`:\n\n```bash\ngit tag v1.0.0      # Release\ngit tag v1.0.1      # Parche\ngit tag v1.1.0      # Menor\ngit tag v2.0.0      # Mayor\ngit tag v1.0.0-beta.1  # Pre-release\n```\n\n### Lista de Verificacion de Lanzamiento\n\nAntes de publicar una nueva version:\n\n1. **Actualizar version** en package.json\n2. **Ejecutar pruebas**: `hpm test`\n3. **Actualizar CHANGELOG** (si tienes uno)\n4. **Actualizar README** si la API cambio\n5. **Confirmar cambios**\n6. **Crear etiqueta**\n7. **Enviar a GitHub**\n\n### Ejemplo Automatizado\n\nCrea un script de lanzamiento:\n\n```bash\n#!/bin/bash\n# release.sh - Release a new version\n\nVERSION=$1\n\nif [ -z \"$VERSION\" ]; then\n    echo \"Usage: ./release.sh 1.0.0\"\n    exit 1\nfi\n\n# Run tests\nhpm test || exit 1\n\n# Update version in package.json\nsed -i \"s/\\\"version\\\": \\\".*\\\"/\\\"version\\\": \\\"$VERSION\\\"/\" package.json\n\n# Commit and tag\ngit add package.json\ngit commit -m \"Release v$VERSION\"\ngit tag \"v$VERSION\"\n\n# Push\ngit push origin main --tags\n\necho \"Released v$VERSION\"\n```\n\n## Usuarios Instalando Tu Paquete\n\nDespues de publicar, los usuarios pueden instalar:\n\n```bash\n# Ultima version\nhpm install yourusername/my-package\n\n# Version especifica\nhpm install yourusername/my-package@1.0.0\n\n# Restriccion de version\nhpm install yourusername/my-package@^1.0.0\n```\n\nE importar:\n\n```hemlock\nimport { parse, stringify } from \"yourusername/my-package\";\n```\n\n## Documentacion\n\n### README.md\n\nCada paquete debe tener un README:\n\n```markdown\n# my-package\n\nA brief description of what this package does.\n\n## Installation\n\n\\`\\`\\`bash\nhpm install yourusername/my-package\n\\`\\`\\`\n\n## Usage\n\n\\`\\`\\`hemlock\nimport { parse } from \"yourusername/my-package\";\n\nlet result = parse(\"input\");\n\\`\\`\\`\n\n## API\n\n### parse(input: string): Result\n\nParses the input string.\n\n### stringify(obj: any): string\n\nConverts object to string.\n\n## License\n\nMIT\n```\n\n### Documentacion de API\n\nDocumenta todas las exportaciones publicas:\n\n```hemlock\n/// Parses the input string into a structured Result.\n///\n/// # Arguments\n/// * `input` - The string to parse\n///\n/// # Returns\n/// A Result containing the parsed data or an error\n///\n/// # Example\n/// ```\n/// let result = parse(\"hello world\");\n/// print(result.value);\n/// ```\nexport fn parse(input: string): Result {\n    // Implementation\n}\n```\n\n## Directrices de Versionado\n\nSigue [Versionado Semantico](https://semver.org/):\n\n- **MAJOR** (1.0.0  2.0.0): Cambios incompatibles\n- **MINOR** (1.0.0  1.1.0): Nuevas caracteristicas, compatibles hacia atras\n- **PATCH** (1.0.0  1.0.1): Correcciones de errores, compatibles hacia atras\n\n### Cuando Incrementar\n\n| Tipo de Cambio | Incremento de Version |\n|----------------|----------------------|\n| Cambio de API incompatible | MAJOR |\n| Eliminar funcion/tipo | MAJOR |\n| Cambiar firma de funcion | MAJOR |\n| Agregar nueva funcion | MINOR |\n| Agregar nueva caracteristica | MINOR |\n| Correccion de error | PATCH |\n| Actualizacion de documentacion | PATCH |\n| Refactorizacion interna | PATCH |\n\n## Ver Tambien\n\n- [Especificacion de Paquetes](#hpm-creating-packages-package-spec) - Referencia completa de package.json\n- [Versionado](#hpm-creating-packages-versioning) - Detalles de versionado semantico\n- [Configuracion](#hpm-creating-packages-configuration) - Autenticacion de GitHub\n"}, "hpm: Desarrollo de Paquetes -> Especificacin de Paquetes": {"id": "hpm-package-spec", "content": "# Especificacion de Paquetes\n\nReferencia completa para el formato del archivo `package.json`.\n\n## Descripcion General\n\nCada paquete de hpm requiere un archivo `package.json` en la raiz del proyecto. Este archivo define los metadatos del paquete, dependencias y scripts.\n\n## Ejemplo Minimo\n\n```json\n{\n  \"name\": \"owner/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n## Ejemplo Completo\n\n```json\n{\n  \"name\": \"hemlang/example-package\",\n  \"version\": \"1.2.3\",\n  \"description\": \"An example Hemlock package\",\n  \"author\": \"Hemlock Team <team@hemlock.dev>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/hemlang/example-package\",\n  \"homepage\": \"https://hemlang.github.io/example-package\",\n  \"bugs\": \"https://github.com/hemlang/example-package/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"example\", \"utility\", \"hemlock\"],\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"^2.1.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/bundle.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n## Referencia de Campos\n\n### name (requerido)\n\nEl nombre del paquete en formato `owner/repo`.\n\n```json\n{\n  \"name\": \"hemlang/sprout\"\n}\n```\n\n**Requisitos:**\n- Debe estar en formato `owner/repo`\n- `owner` debe ser tu nombre de usuario u organizacion de GitHub\n- `repo` debe ser el nombre del repositorio\n- Usa letras minusculas, numeros y guiones\n- Maximo 214 caracteres en total\n\n**Nombres validos:**\n```\nhemlang/sprout\nalice/http-client\nmyorg/json-utils\nbob123/my-lib\n```\n\n**Nombres invalidos:**\n```\nmy-package          # Falta owner\nhemlang/My_Package  # Mayusculas y guion bajo\nhemlang             # Falta repo\n```\n\n### version (requerido)\n\nLa version del paquete siguiendo [Versionado Semantico](https://semver.org/).\n\n```json\n{\n  \"version\": \"1.2.3\"\n}\n```\n\n**Formato:** `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`\n\n**Versiones validas:**\n```\n1.0.0\n2.1.3\n1.0.0-alpha\n1.0.0-beta.1\n1.0.0-rc.1+build.123\n0.1.0\n```\n\n### description\n\nDescripcion corta del paquete.\n\n```json\n{\n  \"description\": \"A fast JSON parser for Hemlock\"\n}\n```\n\n- Mantenla bajo 200 caracteres\n- Describe lo que hace el paquete, no como\n\n### author\n\nInformacion del autor del paquete.\n\n```json\n{\n  \"author\": \"Your Name <email@example.com>\"\n}\n```\n\n**Formatos aceptados:**\n```json\n\"author\": \"Your Name\"\n\"author\": \"Your Name <email@example.com>\"\n\"author\": \"Your Name <email@example.com> (https://website.com)\"\n```\n\n### license\n\nEl identificador de licencia.\n\n```json\n{\n  \"license\": \"MIT\"\n}\n```\n\n**Licencias comunes:**\n- `MIT` - Licencia MIT\n- `Apache-2.0` - Licencia Apache 2.0\n- `GPL-3.0` - Licencia Publica General GNU v3.0\n- `BSD-3-Clause` - Licencia BSD de 3 clausulas\n- `ISC` - Licencia ISC\n- `UNLICENSED` - Propietario/privado\n\nUsa [identificadores SPDX](https://spdx.org/licenses/) cuando sea posible.\n\n### repository\n\nEnlace al repositorio de codigo fuente.\n\n```json\n{\n  \"repository\": \"https://github.com/hemlang/sprout\"\n}\n```\n\n### homepage\n\nURL de la pagina principal del proyecto.\n\n```json\n{\n  \"homepage\": \"https://sprout.hemlock.dev\"\n}\n```\n\n### bugs\n\nURL del rastreador de problemas.\n\n```json\n{\n  \"bugs\": \"https://github.com/hemlang/sprout/issues\"\n}\n```\n\n### main\n\nArchivo de punto de entrada para el paquete.\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\n**Por defecto:** `src/index.hml`\n\nCuando los usuarios importan tu paquete:\n```hemlock\nimport { x } from \"owner/repo\";\n```\n\nhpm carga el archivo especificado en `main`.\n\n**Orden de resolucion para importaciones:**\n1. Ruta exacta: `src/index.hml`\n2. Con extension .hml: `src/index`  `src/index.hml`\n3. Archivo index: `src/index/`  `src/index/index.hml`\n\n### keywords\n\nArray de palabras clave para descubrimiento.\n\n```json\n{\n  \"keywords\": [\"json\", \"parser\", \"utility\", \"hemlock\"]\n}\n```\n\n- Usa minusculas\n- Se especifico y relevante\n- Incluye el lenguaje (\"hemlock\") si es apropiado\n\n### dependencies\n\nDependencias de tiempo de ejecucion requeridas para que el paquete funcione.\n\n```json\n{\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"~2.1.0\",\n    \"alice/logger\": \">=1.0.0 <2.0.0\"\n  }\n}\n```\n\n**Clave:** Nombre del paquete (`owner/repo`)\n**Valor:** Restriccion de version\n\n**Sintaxis de restriccion de version:**\n\n| Restriccion | Significado |\n|-------------|-------------|\n| `1.2.3` | Version exacta |\n| `^1.2.3` | >=1.2.3 <2.0.0 |\n| `~1.2.3` | >=1.2.3 <1.3.0 |\n| `>=1.0.0` | Al menos 1.0.0 |\n| `>=1.0.0 <2.0.0` | Rango |\n| `*` | Cualquier version |\n\n### devDependencies\n\nDependencias solo de desarrollo (pruebas, compilacion, etc.).\n\n```json\n{\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\",\n    \"hemlang/linter\": \"^2.0.0\"\n  }\n}\n```\n\nLas dependencias de desarrollo son:\n- Instaladas durante el desarrollo\n- No instaladas cuando el paquete se usa como dependencia\n- Usadas para pruebas, compilacion, linting, etc.\n\n### scripts\n\nComandos con nombre que se pueden ejecutar con `hpm run`.\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n**Ejecutar scripts:**\n```bash\nhpm run start\nhpm run build\nhpm test        # Atajo para 'hpm run test'\n```\n\n**Pasar argumentos:**\n```bash\nhpm run test -- --verbose --filter=unit\n```\n\n**Scripts comunes:**\n\n| Script | Proposito |\n|--------|-----------|\n| `start` | Iniciar la aplicacion |\n| `dev` | Modo desarrollo con recarga en caliente |\n| `test` | Ejecutar pruebas |\n| `build` | Compilar para produccion |\n| `clean` | Eliminar artefactos de compilacion |\n| `lint` | Verificar estilo de codigo |\n| `format` | Formatear codigo |\n\n### files\n\nArchivos y directorios a incluir cuando el paquete se instala.\n\n```json\n{\n  \"files\": [\n    \"src/\",\n    \"lib/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n**Comportamiento por defecto:** Si no se especifica, incluye:\n- Todos los archivos en el repositorio\n- Excluye `.git/`, `node_modules/`, `hem_modules/`\n\n**Usar para:**\n- Reducir el tamano del paquete\n- Excluir archivos de prueba de la distribucion\n- Incluir solo archivos necesarios\n\n### native\n\nRequisitos de bibliotecas nativas.\n\n```json\n{\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\", \"sqlite3\"]\n  }\n}\n```\n\nDocumenta dependencias nativas que deben estar instaladas en el sistema.\n\n## Validacion\n\nhpm valida package.json en varias operaciones. Errores de validacion comunes:\n\n### Campos requeridos faltantes\n\n```\nError: package.json missing required field: name\n```\n\n**Solucion:** Agregar el campo requerido.\n\n### Formato de nombre invalido\n\n```\nError: Invalid package name. Must be in owner/repo format.\n```\n\n**Solucion:** Usar formato `owner/repo`.\n\n### Version invalida\n\n```\nError: Invalid version \"1.0\". Must be semver format (X.Y.Z).\n```\n\n**Solucion:** Usar formato semver completo (`1.0.0`).\n\n### JSON invalido\n\n```\nError: package.json is not valid JSON\n```\n\n**Solucion:** Verificar sintaxis JSON (comas, comillas, corchetes).\n\n## Crear package.json\n\n### Interactivo\n\n```bash\nhpm init\n```\n\nSolicita cada campo de forma interactiva.\n\n### Con Valores por Defecto\n\n```bash\nhpm init --yes\n```\n\nCrea con valores por defecto:\n```json\n{\n  \"name\": \"directory-name/directory-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\n### Manual\n\nCrea el archivo manualmente:\n\n```bash\ncat > package.json << 'EOF'\n{\n  \"name\": \"yourname/your-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Your package description\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\nEOF\n```\n\n## Mejores Practicas\n\n1. **Siempre especifica main** - No dependas del valor por defecto\n2. **Usa rangos caret** - `^1.0.0` para la mayoria de dependencias\n3. **Separa dependencias de desarrollo** - Mantener dependencias de prueba/compilacion en devDependencies\n4. **Incluye palabras clave** - Ayuda a los usuarios a encontrar tu paquete\n5. **Documenta scripts** - Nombra los scripts claramente\n6. **Especifica licencia** - Requerido para codigo abierto\n7. **Agrega descripcion** - Ayuda a los usuarios a entender el proposito\n\n## Ver Tambien\n\n- [Creacion de Paquetes](#hpm-package-spec-creating-packages) - Guia de publicacion\n- [Versionado](#hpm-package-spec-versioning) - Restricciones de version\n- [Configuracion del Proyecto](#hpm-package-spec-project-setup) - Estructura del proyecto\n"}, "hpm: Desarrollo de Paquetes -> Versionado": {"id": "hpm-versioning", "content": "# Versionado\n\nGuia completa de versionado semantico en hpm.\n\n## Versionado Semantico\n\nhpm usa [Versionado Semantico 2.0.0](https://semver.org/) (semver) para versiones de paquetes.\n\n### Formato de Version\n\n```\nMAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]\n```\n\n**Ejemplos:**\n```\n1.0.0           # Version de lanzamiento\n2.1.3           # Version de lanzamiento\n1.0.0-alpha     # Pre-lanzamiento\n1.0.0-beta.1    # Pre-lanzamiento con numero\n1.0.0-rc.1      # Candidato a lanzamiento\n1.0.0+20231201  # Con metadatos de compilacion\n1.0.0-beta+exp  # Pre-lanzamiento con metadatos de compilacion\n```\n\n### Componentes de Version\n\n| Componente | Descripcion | Ejemplo |\n|------------|-------------|---------|\n| MAJOR | Cambios incompatibles | `1.0.0`  `2.0.0` |\n| MINOR | Nuevas caracteristicas (compatibles hacia atras) | `1.0.0`  `1.1.0` |\n| PATCH | Correcciones de errores (compatibles hacia atras) | `1.0.0`  `1.0.1` |\n| PRERELEASE | Identificador de pre-lanzamiento | `1.0.0-alpha` |\n| BUILD | Metadatos de compilacion (ignorado en comparacion) | `1.0.0+build123` |\n\n### Cuando Incrementar\n\n| Tipo de Cambio | Incrementar | Ejemplo |\n|----------------|-------------|---------|\n| Cambio de API incompatible | MAJOR | Eliminar una funcion |\n| Renombrar funcion publica | MAJOR | `parse()`  `decode()` |\n| Cambiar firma de funcion | MAJOR | Agregar parametro requerido |\n| Agregar nueva funcion | MINOR | Agregar `validate()` |\n| Agregar parametro opcional | MINOR | Nuevo argumento opcional `options` |\n| Correccion de error | PATCH | Arreglar puntero nulo |\n| Mejora de rendimiento | PATCH | Algoritmo mas rapido |\n| Refactorizacion interna | PATCH | Sin cambio de API |\n\n## Restricciones de Version\n\n### Sintaxis de Restricciones\n\n| Sintaxis | Significado | Resuelve a |\n|----------|-------------|------------|\n| `1.2.3` | Version exacta | Solo 1.2.3 |\n| `^1.2.3` | Caret (compatible) | 1.2.3 y <2.0.0 |\n| `~1.2.3` | Tilde (actualizaciones de parche) | 1.2.3 y <1.3.0 |\n| `>=1.0.0` | Al menos | 1.0.0 o superior |\n| `>1.0.0` | Mayor que | Superior a 1.0.0 |\n| `<2.0.0` | Menor que | Inferior a 2.0.0 |\n| `<=2.0.0` | Como maximo | 2.0.0 o inferior |\n| `>=1.0.0 <2.0.0` | Rango | Entre 1.0.0 y 2.0.0 |\n| `*` | Cualquiera | Cualquier version |\n\n### Rangos Caret (^)\n\nEl caret (`^`) permite cambios que no modifican el digito mas a la izquierda que no es cero:\n\n```\n^1.2.3    >=1.2.3 <2.0.0   # Permite 1.x.x\n^0.2.3    >=0.2.3 <0.3.0   # Permite 0.2.x\n^0.0.3    >=0.0.3 <0.0.4   # Solo permite 0.0.3\n```\n\n**Usar cuando:** Quieres actualizaciones compatibles dentro de una version mayor.\n\n**Restriccion mas comun** - recomendada para la mayoria de dependencias.\n\n### Rangos Tilde (~)\n\nEl tilde (`~`) solo permite cambios a nivel de parche:\n\n```\n~1.2.3    >=1.2.3 <1.3.0   # Permite 1.2.x\n~1.2      >=1.2.0 <1.3.0   # Permite 1.2.x\n~1        >=1.0.0 <2.0.0   # Permite 1.x.x\n```\n\n**Usar cuando:** Solo quieres correcciones de errores, sin nuevas caracteristicas.\n\n### Rangos de Comparacion\n\nCombina operadores de comparacion para control preciso:\n\n```json\n{\n  \"dependencies\": {\n    \"owner/pkg\": \">=1.0.0 <2.0.0\",\n    \"owner/other\": \">1.5.0 <=2.1.0\"\n  }\n}\n```\n\n### Cualquier Version (*)\n\nCoincide con cualquier version:\n\n```json\n{\n  \"dependencies\": {\n    \"owner/pkg\": \"*\"\n  }\n}\n```\n\n**Advertencia:** No recomendado para produccion. Siempre obtendra la ultima version.\n\n## Versiones de Pre-lanzamiento\n\n### Identificadores de Pre-lanzamiento\n\nLos pre-lanzamientos tienen menor precedencia que los lanzamientos:\n\n```\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0\n```\n\n### Etiquetas Comunes de Pre-lanzamiento\n\n| Etiqueta | Significado | Etapa |\n|----------|-------------|-------|\n| `alpha` | Desarrollo temprano | Muy inestable |\n| `beta` | Caracteristicas completas | Pruebas |\n| `rc` | Candidato a lanzamiento | Pruebas finales |\n| `dev` | Snapshot de desarrollo | Inestable |\n\n### Pre-lanzamiento en Restricciones\n\nLas restricciones no coinciden con pre-lanzamientos por defecto:\n\n```\n^1.0.0    # NO coincide con 1.1.0-beta\n>=1.0.0   # NO coincide con 2.0.0-alpha\n```\n\nPara incluir pre-lanzamientos, referencialos explicitamente:\n\n```\n>=1.0.0-alpha <2.0.0   # Incluye todos los pre-lanzamientos 1.x\n```\n\n## Comparacion de Versiones\n\n### Reglas de Comparacion\n\n1. Comparar MAJOR, MINOR, PATCH numericamente\n2. Lanzamiento > pre-lanzamiento con la misma version\n3. Pre-lanzamientos comparados alfanumericamente\n4. Metadatos de compilacion ignorados\n\n### Ejemplos\n\n```\n1.0.0 < 1.0.1 < 1.1.0 < 2.0.0\n\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0\n\n1.0.0 = 1.0.0+build123  # Metadatos de compilacion ignorados\n```\n\n### Ordenamiento\n\nLas versiones se ordenan de forma ascendente:\n\n```\n1.0.0\n1.0.1\n1.1.0\n1.1.1\n2.0.0-alpha\n2.0.0-beta\n2.0.0\n```\n\n## Resolucion de Versiones\n\n### Algoritmo de Resolucion\n\nCuando multiples paquetes requieren la misma dependencia:\n\n1. Recopilar todas las restricciones\n2. Encontrar la interseccion de todos los rangos\n3. Seleccionar la version mas alta en la interseccion\n4. Error si ninguna version satisface todas\n\n### Ejemplo de Resolucion\n\n```\npackage-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npackage-b requires hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)\n\nInterseccion: >=1.2.0 <1.3.0\nDisponibles: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]\nResuelto: 1.2.5 (mas alta en la interseccion)\n```\n\n### Deteccion de Conflictos\n\nEl conflicto ocurre cuando ninguna version satisface todas las restricciones:\n\n```\npackage-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npackage-b requires hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)\n\nInterseccion: (vacia)\nResultado: CONFLICTO - ninguna version satisface ambas\n```\n\n## Mejores Practicas\n\n### Para Consumidores de Paquetes\n\n1. **Usar rangos caret** para la mayoria de dependencias:\n   ```json\n   \"hemlang/json\": \"^1.2.0\"\n   ```\n\n2. **Usar rangos tilde** para dependencias criticas:\n   ```json\n   \"critical/lib\": \"~1.2.0\"\n   ```\n\n3. **Fijar versiones** solo cuando sea necesario:\n   ```json\n   \"unstable/pkg\": \"1.2.3\"\n   ```\n\n4. **Incluir tu archivo de bloqueo** para compilaciones reproducibles\n\n5. **Actualizar regularmente** para obtener correcciones de seguridad:\n   ```bash\n   hpm update\n   hpm outdated\n   ```\n\n### Para Autores de Paquetes\n\n1. **Comenzar en 0.1.0** para desarrollo inicial:\n   - La API puede cambiar frecuentemente\n   - Los usuarios esperan inestabilidad\n\n2. **Ir a 1.0.0** cuando la API sea estable:\n   - Compromiso publico de estabilidad\n   - Cambios incompatibles requieren incremento mayor\n\n3. **Seguir semver estrictamente**:\n   - Cambio incompatible = MAJOR\n   - Nueva caracteristica = MINOR\n   - Correccion de error = PATCH\n\n4. **Usar pre-lanzamientos** para pruebas:\n   ```bash\n   git tag v2.0.0-beta.1\n   git push --tags\n   ```\n\n5. **Documentar cambios incompatibles** en CHANGELOG\n\n## Publicar Versiones\n\n### Crear Lanzamientos\n\n```bash\n# Actualizar version en package.json\n# Editar package.json: \"version\": \"1.1.0\"\n\n# Confirmar cambio de version\ngit add package.json\ngit commit -m \"Bump version to 1.1.0\"\n\n# Crear y enviar etiqueta\ngit tag v1.1.0\ngit push origin main --tags\n```\n\n### Formato de Etiqueta\n\nLas etiquetas **deben** comenzar con `v`:\n\n```\nv1.0.0       Correcto\nv1.0.0-beta  Correcto\n1.0.0        No sera reconocido\n```\n\n### Flujo de Trabajo de Lanzamiento\n\n```bash\n# 1. Asegurar que las pruebas pasen\nhpm test\n\n# 2. Actualizar version en package.json\n# 3. Actualizar CHANGELOG.md\n# 4. Confirmar cambios\ngit add -A\ngit commit -m \"Release v1.2.0\"\n\n# 5. Crear etiqueta\ngit tag v1.2.0\n\n# 6. Enviar todo\ngit push origin main --tags\n```\n\n## Verificar Versiones\n\n### Listar Versiones Instaladas\n\n```bash\nhpm list\n```\n\n### Verificar Actualizaciones\n\n```bash\nhpm outdated\n```\n\nSalida:\n```\nPackage         Current  Wanted  Latest\nhemlang/json    1.0.0    1.0.5   1.2.0\nhemlang/sprout  2.0.0    2.0.3   2.1.0\n```\n\n- **Current**: Version instalada\n- **Wanted**: Mas alta que coincide con la restriccion\n- **Latest**: Ultima disponible\n\n### Actualizar Paquetes\n\n```bash\n# Actualizar todos\nhpm update\n\n# Actualizar paquete especifico\nhpm update hemlang/json\n```\n\n## Ver Tambien\n\n- [Creacion de Paquetes](#hpm-versioning-creating-packages) - Guia de publicacion\n- [Especificacion de Paquetes](#hpm-versioning-package-spec) - Formato de package.json\n- [Comandos](#hpm-versioning-commands) - Referencia de CLI\n"}, "hpm: Referencia -> Arquitectura": {"id": "hpm-architecture", "content": "# Arquitectura\n\nArquitectura interna y diseno de hpm. Este documento es para contribuidores y aquellos interesados en entender como funciona hpm.\n\n## Descripcion General\n\nhpm esta escrito en Hemlock y consiste en varios modulos que manejan diferentes aspectos de la gestion de paquetes:\n\n```\nsrc/\n main.hml        # Punto de entrada CLI y enrutamiento de comandos\n manifest.hml    # Manejo de package.json\n lockfile.hml    # Manejo de package-lock.json\n semver.hml      # Versionado semantico\n resolver.hml    # Resolucion de dependencias\n github.hml      # Cliente de API de GitHub\n installer.hml   # Descarga y extraccion de paquetes\n cache.hml       # Gestion de cache global\n```\n\n## Responsabilidades de los Modulos\n\n### main.hml\n\nEl punto de entrada para la aplicacion CLI.\n\n**Responsabilidades:**\n- Parsear argumentos de linea de comandos\n- Enrutar comandos a los manejadores apropiados\n- Mostrar informacion de ayuda y version\n- Manejar flags globales (--verbose, --dry-run, etc.)\n- Salir con codigos apropiados\n\n**Funciones principales:**\n- `main()` - Punto de entrada, parsea args y despacha comandos\n- `cmd_init()` - Manejar `hpm init`\n- `cmd_install()` - Manejar `hpm install`\n- `cmd_uninstall()` - Manejar `hpm uninstall`\n- `cmd_update()` - Manejar `hpm update`\n- `cmd_list()` - Manejar `hpm list`\n- `cmd_outdated()` - Manejar `hpm outdated`\n- `cmd_run()` - Manejar `hpm run`\n- `cmd_why()` - Manejar `hpm why`\n- `cmd_cache()` - Manejar `hpm cache`\n\n**Atajos de comandos:**\n```hemlock\nlet shortcuts = {\n    \"i\": \"install\",\n    \"rm\": \"uninstall\",\n    \"remove\": \"uninstall\",\n    \"ls\": \"list\",\n    \"up\": \"update\"\n};\n```\n\n### manifest.hml\n\nManeja lectura y escritura de archivos `package.json`.\n\n**Responsabilidades:**\n- Leer/escribir package.json\n- Validar estructura del paquete\n- Gestionar dependencias\n- Parsear especificadores de paquetes (owner/repo@version)\n\n**Funciones principales:**\n```hemlock\ncreate_default(): Manifest           // Crear manifiesto vacio\nread_manifest(): Manifest            // Leer desde archivo\nwrite_manifest(m: Manifest)          // Escribir a archivo\nvalidate(m: Manifest): bool          // Validar estructura\nget_all_dependencies(m): Map         // Obtener deps + devDeps\nadd_dependency(m, pkg, ver, dev)     // Agregar dependencia\nremove_dependency(m, pkg)            // Eliminar dependencia\nparse_specifier(spec): (name, ver)   // Parsear \"owner/repo@^1.0.0\"\nsplit_name(name): (owner, repo)      // Parsear \"owner/repo\"\n```\n\n**Estructura de Manifest:**\n```hemlock\ntype Manifest = {\n    name: string,\n    version: string,\n    description: string?,\n    author: string?,\n    license: string?,\n    repository: string?,\n    main: string?,\n    dependencies: Map<string, string>,\n    devDependencies: Map<string, string>,\n    scripts: Map<string, string>\n};\n```\n\n### lockfile.hml\n\nGestiona el archivo `package-lock.json` para instalaciones reproducibles.\n\n**Responsabilidades:**\n- Crear/leer/escribir archivos de bloqueo\n- Rastrear versiones exactas resueltas\n- Almacenar URLs de descarga y hashes de integridad\n- Podar dependencias huerfanas\n\n**Funciones principales:**\n```hemlock\ncreate_empty(): Lockfile              // Crear lockfile vacio\nread_lockfile(): Lockfile             // Leer desde archivo\nwrite_lockfile(l: Lockfile)           // Escribir a archivo\ncreate_entry(ver, url, hash, deps)    // Crear entrada de bloqueo\nget_locked(l, pkg): LockEntry?        // Obtener version bloqueada\nset_locked(l, pkg, entry)             // Establecer version bloqueada\nremove_locked(l, pkg)                 // Eliminar entrada\nprune(l, keep: Set)                   // Eliminar huerfanos\nneeds_update(l, m): bool              // Verificar si esta desincronizado\n```\n\n**Estructura de Lockfile:**\n```hemlock\ntype Lockfile = {\n    lockVersion: int,\n    hemlock: string,\n    dependencies: Map<string, LockEntry>\n};\n\ntype LockEntry = {\n    version: string,\n    resolved: string,     // URL de descarga\n    integrity: string,    // Hash SHA256\n    dependencies: Map<string, string>\n};\n```\n\n### semver.hml\n\nImplementacion completa de Versionado Semantico 2.0.0.\n\n**Responsabilidades:**\n- Parsear cadenas de version\n- Comparar versiones\n- Parsear y evaluar restricciones de version\n- Encontrar versiones que satisfacen restricciones\n\n**Funciones principales:**\n```hemlock\n// Parseo\nparse(s: string): Version             // \"1.2.3-beta+build\"  Version\nstringify(v: Version): string         // Version  \"1.2.3-beta+build\"\n\n// Comparacion\ncompare(a, b: Version): int           // -1, 0, o 1\ngt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool\n\n// Restricciones\nparse_constraint(s: string): Constraint    // \"^1.2.3\"  Constraint\nsatisfies(v: Version, c: Constraint): bool // Verificar si v coincide con c\nmax_satisfying(versions, c): Version?      // Encontrar coincidencia mas alta\nsort(versions): [Version]                  // Ordenar ascendente\n\n// Utilidades\nconstraints_overlap(a, b: Constraint): bool  // Verificar compatibilidad\n```\n\n**Estructura de Version:**\n```hemlock\ntype Version = {\n    major: int,\n    minor: int,\n    patch: int,\n    prerelease: [string]?,  // ej., [\"beta\", \"1\"]\n    build: string?          // ej., \"20230101\"\n};\n```\n\n**Tipos de Restriccion:**\n```hemlock\ntype Constraint =\n    | Exact(Version)           // \"1.2.3\"\n    | Caret(Version)           // \"^1.2.3\"  >=1.2.3 <2.0.0\n    | Tilde(Version)           // \"~1.2.3\"  >=1.2.3 <1.3.0\n    | Range(op, Version)       // \">=1.0.0\", \"<2.0.0\"\n    | And(Constraint, Constraint)  // Rangos combinados\n    | Any;                     // \"*\"\n```\n\n### resolver.hml\n\nImplementa resolucion de dependencias estilo npm.\n\n**Responsabilidades:**\n- Resolver arboles de dependencias\n- Detectar conflictos de versiones\n- Detectar dependencias circulares\n- Construir arboles de visualizacion\n\n**Funciones principales:**\n```hemlock\nresolve(manifest, lockfile): ResolveResult\n    // Resolutor principal: retorna mapa plano de todas las dependencias con versiones resueltas\n\nresolve_version(pkg, constraints: [string]): ResolvedPackage?\n    // Encontrar version que satisface todas las restricciones\n\ndetect_cycles(deps: Map): [Cycle]?\n    // Encontrar dependencias circulares usando DFS\n\nbuild_tree(lockfile): Tree\n    // Crear estructura de arbol para mostrar\n\nfind_why(pkg, lockfile): [Chain]\n    // Encontrar cadenas de dependencia explicando por que pkg esta instalado\n```\n\n**Algoritmo de resolucion:**\n\n1. **Recopilar restricciones**: Recorrer manifiesto y dependencias transitivas\n2. **Resolver cada paquete**: Para cada paquete:\n   - Obtener todas las restricciones de version de los dependientes\n   - Obtener versiones disponibles de GitHub\n   - Encontrar version maxima que satisface TODAS las restricciones\n   - Error si ninguna version satisface todas (conflicto)\n3. **Detectar ciclos**: Ejecutar DFS para encontrar dependencias circulares\n4. **Retornar mapa plano**: Nombre del paquete  informacion de version resuelta\n\n**Estructura de ResolveResult:**\n```hemlock\ntype ResolveResult = {\n    packages: Map<string, ResolvedPackage>,\n    conflicts: [Conflict]?,\n    cycles: [Cycle]?\n};\n\ntype ResolvedPackage = {\n    name: string,\n    version: Version,\n    url: string,\n    dependencies: Map<string, string>\n};\n```\n\n### github.hml\n\nCliente de API de GitHub para descubrimiento y descarga de paquetes.\n\n**Responsabilidades:**\n- Obtener versiones disponibles (etiquetas)\n- Descargar package.json de repositorios\n- Descargar tarballs de lanzamientos\n- Manejar autenticacion y limites de tasa\n\n**Funciones principales:**\n```hemlock\nget_token(): string?\n    // Obtener token de env o config\n\ngithub_request(url, headers?): Response\n    // Hacer solicitud a API con reintentos\n\nget_tags(owner, repo): [string]\n    // Obtener etiquetas de version (v1.0.0, v1.1.0, etc.)\n\nget_package_json(owner, repo, ref): Manifest\n    // Obtener package.json en etiqueta/commit especifico\n\ndownload_tarball(owner, repo, tag): bytes\n    // Descargar archivo de lanzamiento\n\nrepo_exists(owner, repo): bool\n    // Verificar si el repositorio existe\n\nget_repo_info(owner, repo): RepoInfo\n    // Obtener metadatos del repositorio\n```\n\n**Logica de reintento:**\n- Retroceso exponencial: 1s, 2s, 4s, 8s\n- Reintenta en: 403 (limite de tasa), 5xx (error de servidor), errores de red\n- Maximo 4 reintentos\n- Reporta errores de limite de tasa claramente\n\n**Endpoints de API usados:**\n```\nGET /repos/{owner}/{repo}/tags\nGET /repos/{owner}/{repo}/contents/package.json?ref={tag}\nGET /repos/{owner}/{repo}/tarball/{tag}\nGET /repos/{owner}/{repo}\n```\n\n### installer.hml\n\nManeja descarga y extraccion de paquetes.\n\n**Responsabilidades:**\n- Descargar paquetes de GitHub\n- Extraer tarballs a hem_modules\n- Verificar/usar paquetes en cache\n- Instalar/desinstalar paquetes\n\n**Funciones principales:**\n```hemlock\ninstall_package(pkg: ResolvedPackage): bool\n    // Descargar e instalar un solo paquete\n\ninstall_all(packages: Map, options): InstallResult\n    // Instalar todos los paquetes resueltos\n\nuninstall_package(name: string): bool\n    // Eliminar paquete de hem_modules\n\nget_installed(): Map<string, string>\n    // Listar paquetes actualmente instalados\n\nverify_integrity(pkg): bool\n    // Verificar integridad del paquete\n\nprefetch_packages(packages: Map): void\n    // Descarga paralela a cache (experimental)\n```\n\n**Proceso de instalacion:**\n\n1. Verificar si ya esta instalado en la version correcta\n2. Verificar cache por tarball\n3. Si no esta en cache, descargar de GitHub\n4. Almacenar en cache para uso futuro\n5. Extraer a `hem_modules/owner/repo/`\n6. Verificar instalacion\n\n**Estructura de directorio creada:**\n```\nhem_modules/\n owner/\n     repo/\n         package.json\n         src/\n         ...\n```\n\n### cache.hml\n\nGestiona la cache global de paquetes.\n\n**Responsabilidades:**\n- Almacenar tarballs descargados\n- Recuperar paquetes en cache\n- Listar paquetes en cache\n- Limpiar cache\n- Gestionar configuracion\n\n**Funciones principales:**\n```hemlock\nget_cache_dir(): string\n    // Obtener directorio de cache (respeta HPM_CACHE_DIR)\n\nget_config_dir(): string\n    // Obtener directorio de configuracion (~/.hpm)\n\nis_cached(owner, repo, version): bool\n    // Verificar si tarball esta en cache\n\nget_cached_path(owner, repo, version): string\n    // Obtener ruta a tarball en cache\n\nstore_tarball_file(owner, repo, version, data): void\n    // Guardar tarball en cache\n\nlist_cached(): [CachedPackage]\n    // Listar todos los paquetes en cache\n\nclear_cache(): int\n    // Eliminar todos los paquetes en cache, retorna bytes liberados\n\nget_cache_size(): int\n    // Calcular tamano total de cache\n\nread_config(): Config\n    // Leer ~/.hpm/config.json\n\nwrite_config(c: Config): void\n    // Escribir archivo de configuracion\n```\n\n**Estructura de cache:**\n```\n~/.hpm/\n config.json\n cache/\n     owner/\n         repo/\n             1.0.0.tar.gz\n             1.1.0.tar.gz\n```\n\n## Flujo de Datos\n\n### Flujo del Comando Install\n\n```\nhpm install owner/repo@^1.0.0\n         \n         \n    \n     main.hml  Parsear args, llamar cmd_install\n    \n         \n         \n    \n    manifest.hml Leer package.json, agregar dependencia\n    \n         \n         \n    \n    resolver.hml Resolver todas las dependencias\n    \n         \n         \n                        \n        \n     github.hml     semver.hml Obtener versiones, encontrar satisfactoria\n        \n         \n         \n    \n    installer.hml Descargar y extraer paquetes\n    \n         \n         \n                        \n        \n     github.hml     cache.hml Descargar o usar cache\n        \n         \n         \n    \n    lockfile.hml Actualizar package-lock.json\n    \n```\n\n### Detalle del Algoritmo de Resolucion\n\n```\nEntrada: manifest.dependencies, manifest.devDependencies, lockfile existente\n\n1. Inicializar:\n   - constraints = {} // Map<string, [Constraint]>\n   - resolved = {}    // Map<string, ResolvedPackage>\n   - queue = [dependencias directas]\n\n2. Mientras queue no este vacia:\n   a. pkg = queue.pop()\n   b. Si pkg ya esta resuelto, saltar\n   c. Obtener todas las restricciones para pkg de dependientes\n   d. Obtener versiones disponibles de GitHub (cacheado)\n   e. Encontrar version maxima que satisface TODAS las restricciones\n   f. Si ninguna encontrada: CONFLICTO\n   g. resolved[pkg] = {version, url, deps}\n   h. Agregar dependencias de pkg a queue\n\n3. Detectar ciclos en grafo resuelto\n   - Si se encuentra ciclo: ERROR\n\n4. Retornar mapa resuelto\n```\n\n## Manejo de Errores\n\n### Codigos de Salida\n\nDefinidos en main.hml:\n\n```hemlock\nlet EXIT_SUCCESS = 0;\nlet EXIT_CONFLICT = 1;\nlet EXIT_NOT_FOUND = 2;\nlet EXIT_VERSION_NOT_FOUND = 3;\nlet EXIT_NETWORK = 4;\nlet EXIT_INVALID_MANIFEST = 5;\nlet EXIT_INTEGRITY = 6;\nlet EXIT_RATE_LIMIT = 7;\nlet EXIT_CIRCULAR = 8;\n```\n\n### Propagacion de Errores\n\nLos errores se propagan a traves de valores de retorno:\n\n```hemlock\nfn resolve_version(pkg): Result<Version, ResolveError> {\n    let versions = github.get_tags(owner, repo)?;  // ? propaga\n    // ...\n}\n```\n\n## Pruebas\n\n### Framework de Pruebas\n\nFramework de pruebas personalizado en `test/framework.hml`:\n\n```hemlock\nfn suite(name: string, tests: fn()) {\n    print(\"Suite: \" + name);\n    tests();\n}\n\nfn test(name: string, body: fn()) {\n    try {\n        body();\n        print(\"   \" + name);\n    } catch e {\n        print(\"   \" + name + \": \" + e);\n        failed += 1;\n    }\n}\n\nfn assert_eq<T>(actual: T, expected: T) {\n    if actual != expected {\n        throw \"Expected \" + expected + \", got \" + actual;\n    }\n}\n```\n\n### Archivos de Prueba\n\n- `test/test_semver.hml` - Parseo de versiones, comparacion, restricciones\n- `test/test_manifest.hml` - Lectura/escritura de manifiesto, validacion\n- `test/test_lockfile.hml` - Operaciones de lockfile\n- `test/test_cache.hml` - Gestion de cache\n\n### Ejecutar Pruebas\n\n```bash\n# Todas las pruebas\nmake test\n\n# Pruebas especificas\nmake test-semver\nmake test-manifest\nmake test-lockfile\nmake test-cache\n```\n\n## Mejoras Futuras\n\n### Caracteristicas Planeadas\n\n1. **Verificacion de integridad** - Verificacion completa de hash SHA256\n2. **Espacios de trabajo** - Soporte de monorepo\n3. **Sistema de plugins** - Comandos extensibles\n4. **Auditoria** - Verificacion de vulnerabilidades de seguridad\n5. **Registro privado** - Alojamiento de paquetes auto-hospedado\n\n### Limitaciones Conocidas\n\n1. **Error del bundler** - No puede crear ejecutable independiente\n2. **Descargas paralelas** - Experimental, puede tener condiciones de carrera\n3. **Integridad** - SHA256 no completamente implementado\n\n## Contribuir\n\n### Estilo de Codigo\n\n- Usar indentacion de 4 espacios\n- Las funciones deben hacer una cosa\n- Comentar logica compleja\n- Escribir pruebas para nuevas caracteristicas\n\n### Agregar un Comando\n\n1. Agregar manejador en `main.hml`:\n   ```hemlock\n   fn cmd_newcmd(args: [string]) {\n       // Implementation\n   }\n   ```\n\n2. Agregar al despacho de comandos:\n   ```hemlock\n   match command {\n       \"newcmd\" => cmd_newcmd(args),\n       // ...\n   }\n   ```\n\n3. Actualizar texto de ayuda\n\n### Agregar un Modulo\n\n1. Crear `src/newmodule.hml`\n2. Exportar interfaz publica\n3. Importar en modulos que lo necesiten\n4. Agregar pruebas en `test/test_newmodule.hml`\n\n## Ver Tambien\n\n- [Comandos](#hpm-architecture-commands) - Referencia de CLI\n- [Creacion de Paquetes](#hpm-architecture-creating-packages) - Desarrollo de paquetes\n- [Versionado](#hpm-architecture-versioning) - Versionado semantico\n"}, "hpm: Referencia -> Cdigos de Salida": {"id": "hpm-exit-codes", "content": "# Codigos de Salida\n\nReferencia de codigos de salida de hpm y sus significados.\n\n## Tabla de Codigos de Salida\n\n| Codigo | Nombre | Descripcion |\n|--------|--------|-------------|\n| 0 | SUCCESS | Comando completado exitosamente |\n| 1 | CONFLICT | Conflicto de version de dependencia |\n| 2 | NOT_FOUND | Paquete no encontrado |\n| 3 | VERSION_NOT_FOUND | Version solicitada no encontrada |\n| 4 | NETWORK | Error de red |\n| 5 | INVALID_MANIFEST | package.json invalido |\n| 6 | INTEGRITY | Verificacion de integridad fallida |\n| 7 | RATE_LIMIT | Limite de tasa de API de GitHub excedido |\n| 8 | CIRCULAR | Dependencia circular detectada |\n\n## Descripciones Detalladas\n\n### Codigo de Salida 0: SUCCESS\n\nEl comando se completo exitosamente.\n\n```bash\n$ hpm install\nInstalled 5 packages\n$ echo $?\n0\n```\n\n### Codigo de Salida 1: CONFLICT\n\nDos o mas paquetes requieren versiones incompatibles de una dependencia.\n\n**Ejemplo:**\n```\nError: Dependency conflict for hemlang/json\n\n  package-a requires hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)\n  package-b requires hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)\n\nNo version satisfies all constraints.\n```\n\n**Soluciones:**\n1. Verificar que paquetes tienen el conflicto:\n   ```bash\n   hpm why hemlang/json\n   ```\n2. Actualizar el paquete en conflicto:\n   ```bash\n   hpm update package-a\n   ```\n3. Relajar restricciones de version en package.json\n4. Eliminar uno de los paquetes en conflicto\n\n### Codigo de Salida 2: NOT_FOUND\n\nEl paquete especificado no existe en GitHub.\n\n**Ejemplo:**\n```\nError: Package not found: hemlang/nonexistent\n\nThe repository hemlang/nonexistent does not exist on GitHub.\n```\n\n**Soluciones:**\n1. Verificar la ortografia del nombre del paquete\n2. Verificar si el repositorio existe: `https://github.com/owner/repo`\n3. Verificar que tienes acceso (para repos privados, establecer GITHUB_TOKEN)\n\n### Codigo de Salida 3: VERSION_NOT_FOUND\n\nNinguna version coincide con la restriccion especificada.\n\n**Ejemplo:**\n```\nError: No version of hemlang/json matches constraint ^5.0.0\n\nAvailable versions: 1.0.0, 1.1.0, 1.2.0, 2.0.0\n```\n\n**Soluciones:**\n1. Verificar versiones disponibles en releases/tags de GitHub\n2. Usar una restriccion de version valida\n3. Las etiquetas de version deben comenzar con 'v' (ej., `v1.0.0`)\n\n### Codigo de Salida 4: NETWORK\n\nOcurrio un error relacionado con la red.\n\n**Ejemplo:**\n```\nError: Network error: could not connect to api.github.com\n\nPlease check your internet connection and try again.\n```\n\n**Soluciones:**\n1. Verificar conexion a internet\n2. Verificar si GitHub es accesible\n3. Verificar configuracion de proxy si estas detras de un firewall\n4. Usar `--offline` si los paquetes estan en cache:\n   ```bash\n   hpm install --offline\n   ```\n5. Esperar y reintentar (hpm reintenta automaticamente)\n\n### Codigo de Salida 5: INVALID_MANIFEST\n\nEl archivo package.json es invalido o tiene formato incorrecto.\n\n**Ejemplo:**\n```\nError: Invalid package.json\n\n  - Missing required field: name\n  - Invalid version format: \"1.0\"\n```\n\n**Soluciones:**\n1. Verificar sintaxis JSON (usar un validador de JSON)\n2. Asegurar que los campos requeridos existan (`name`, `version`)\n3. Verificar formatos de campos:\n   - name: formato `owner/repo`\n   - version: formato semver `X.Y.Z`\n4. Regenerar:\n   ```bash\n   rm package.json\n   hpm init\n   ```\n\n### Codigo de Salida 6: INTEGRITY\n\nLa verificacion de integridad del paquete fallo.\n\n**Ejemplo:**\n```\nError: Integrity check failed for hemlang/json@1.0.0\n\nExpected: sha256-abc123...\nActual:   sha256-def456...\n\nThe downloaded package may be corrupted.\n```\n\n**Soluciones:**\n1. Limpiar cache y reinstalar:\n   ```bash\n   hpm cache clean\n   hpm install\n   ```\n2. Verificar problemas de red (descargas parciales)\n3. Verificar que el paquete no fue manipulado\n\n### Codigo de Salida 7: RATE_LIMIT\n\nSe ha excedido el limite de tasa de la API de GitHub.\n\n**Ejemplo:**\n```\nError: GitHub API rate limit exceeded\n\nUnauthenticated rate limit: 60 requests/hour\nCurrent usage: 60/60\n\nRate limit resets at: 2024-01-15 10:30:00 UTC\n```\n\n**Soluciones:**\n1. **Autenticar con GitHub** (recomendado):\n   ```bash\n   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx\n   hpm install\n   ```\n2. Esperar a que se reinicie el limite de tasa (se reinicia cada hora)\n3. Usar modo sin conexion si los paquetes estan en cache:\n   ```bash\n   hpm install --offline\n   ```\n\n### Codigo de Salida 8: CIRCULAR\n\nDependencia circular detectada en el grafo de dependencias.\n\n**Ejemplo:**\n```\nError: Circular dependency detected\n\n  package-a@1.0.0\n   package-b@1.0.0\n       package-a@1.0.0  (circular!)\n\nCannot resolve dependency tree.\n```\n\n**Soluciones:**\n1. Esto generalmente es un error en los paquetes mismos\n2. Contactar a los mantenedores del paquete\n3. Evitar usar uno de los paquetes circulares\n\n## Usar Codigos de Salida en Scripts\n\n### Bash\n\n```bash\n#!/bin/bash\n\nhpm install\nexit_code=$?\n\ncase $exit_code in\n  0)\n    echo \"Installation successful\"\n    ;;\n  1)\n    echo \"Dependency conflict - check version constraints\"\n    exit 1\n    ;;\n  2)\n    echo \"Package not found - check package name\"\n    exit 1\n    ;;\n  4)\n    echo \"Network error - check connection\"\n    exit 1\n    ;;\n  7)\n    echo \"Rate limited - set GITHUB_TOKEN\"\n    exit 1\n    ;;\n  *)\n    echo \"Unknown error: $exit_code\"\n    exit 1\n    ;;\nesac\n```\n\n### CI/CD\n\n```yaml\n# GitHub Actions\n- name: Install dependencies\n  run: |\n    hpm install\n    if [ $? -eq 7 ]; then\n      echo \"::error::GitHub rate limit exceeded. Add GITHUB_TOKEN.\"\n      exit 1\n    fi\n  env:\n    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n### Make\n\n```makefile\ninstall:\n\t@hpm install || (echo \"Installation failed with code $$?\"; exit 1)\n\ntest: install\n\t@hpm test\n```\n\n## Solucion de Problemas por Codigo de Salida\n\n### Referencia Rapida\n\n| Codigo | Primer Paso a Verificar |\n|--------|------------------------|\n| 1 | Ejecutar `hpm why <paquete>` para ver conflicto |\n| 2 | Verificar nombre del paquete en GitHub |\n| 3 | Verificar versiones disponibles en etiquetas de GitHub |\n| 4 | Verificar conexion a internet |\n| 5 | Validar sintaxis de package.json |\n| 6 | Ejecutar `hpm cache clean && hpm install` |\n| 7 | Establecer variable de entorno `GITHUB_TOKEN` |\n| 8 | Contactar mantenedores del paquete |\n\n## Ver Tambien\n\n- [Solucion de Problemas](#hpm-exit-codes-troubleshooting) - Soluciones detalladas\n- [Comandos](#hpm-exit-codes-commands) - Referencia de comandos\n- [Configuracion](#hpm-exit-codes-configuration) - Configurar token de GitHub\n"}};

        // Mobile menu toggle
        const menuToggle = document.getElementById('menuToggle');
        const sidebar = document.getElementById('sidebar');

        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
            menuToggle.textContent = sidebar.classList.contains('open') ? '\u00d7' : '\u2630';
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth < 1024) {
                if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                }
            }
        });

        // Theme toggle functionality
        const themeToggle = document.getElementById('themeToggle');
        const root = document.documentElement;

        // Get saved theme or detect system preference
        function getPreferredTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                return savedTheme;
            }
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        // Apply theme
        function setTheme(theme) {
            root.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        }

        // Initialize theme
        const initialTheme = getPreferredTheme();
        if (localStorage.getItem('theme')) {
            setTheme(initialTheme);
        }

        // Toggle theme on button click
        themeToggle.addEventListener('click', () => {
            const currentTheme = root.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            // Determine current effective theme
            let effectiveTheme;
            if (currentTheme) {
                effectiveTheme = currentTheme;
            } else {
                effectiveTheme = prefersDark ? 'dark' : 'light';
            }

            // Toggle to opposite theme
            const newTheme = effectiveTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        });

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!localStorage.getItem('theme')) {
                // Only auto-switch if user hasn't manually set a preference
                root.removeAttribute('data-theme');
            }
        });

        // Markdown parser
        function parseMarkdown(md) {
            let lines = md.split('\n');
            let html = '';
            let inCodeBlock = false;
            let codeBlockContent = '';
            let codeBlockLang = '';
            let inList = false;
            let listContent = '';
            let inBlockquote = false;
            let blockquoteContent = '';
            let inTable = false;
            let tableRows = [];
            let tableHasHeader = false;

            function processInlineMarkdown(text) {
                text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
                text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
                return text;
            }

            function makeId(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/^-+|-+$/g, '');
            }

            function flushList() {
                if (inList && listContent) {
                    html += '<ul>\n' + listContent + '</ul>\n';
                    listContent = '';
                    inList = false;
                }
            }

            function flushBlockquote() {
                if (inBlockquote && blockquoteContent) {
                    html += '<blockquote>' + processInlineMarkdown(blockquoteContent.trim()) + '</blockquote>\n';
                    blockquoteContent = '';
                    inBlockquote = false;
                }
            }

            function flushTable() {
                if (inTable && tableRows.length > 0) {
                    html += '<table>\n';
                    for (let r = 0; r < tableRows.length; r++) {
                        const row = tableRows[r];
                        const isHeader = tableHasHeader && r === 0;
                        const tag = isHeader ? 'th' : 'td';
                        html += '<tr>\n';
                        for (const cell of row) {
                            html += '<' + tag + '>' + processInlineMarkdown(cell.trim()) + '</' + tag + '>\n';
                        }
                        html += '</tr>\n';
                    }
                    html += '</table>\n';
                    tableRows = [];
                    inTable = false;
                    tableHasHeader = false;
                }
            }

            function isTableSeparator(line) {
                return /^\|?[\s-:|]+\|[\s-:|]+\|?$/.test(line) && line.includes('-');
            }

            function parseTableRow(line) {
                let cells = line.split('|');
                // Remove empty first/last cells from leading/trailing |
                if (cells.length > 0 && cells[0].trim() === '') cells.shift();
                if (cells.length > 0 && cells[cells.length - 1].trim() === '') cells.pop();
                return cells;
            }

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                const trimmedLine = line.trim();

                // Handle code blocks (including indented ones in lists)
                if (trimmedLine.startsWith('```')) {
                    if (inCodeBlock) {
                        const codeId = 'code-' + Math.random().toString(36).substr(2, 9);
                        const langDisplay = codeBlockLang || 'code';
                        const copyIcon = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>';
                        html += `<div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">${langDisplay}</span>
                                <button class="copy-btn" onclick="copyCode('${codeId}')">${copyIcon}<span>Copy</span></button>
                            </div>
                            <pre><code id="${codeId}">` + escapeHtml(codeBlockContent) + '</code></pre></div>\n';
                        codeBlockContent = '';
                        codeBlockLang = '';
                        inCodeBlock = false;
                    } else {
                        flushList();
                        flushBlockquote();
                        inCodeBlock = true;
                        codeBlockLang = trimmedLine.substring(3).trim();
                    }
                    continue;
                }

                if (inCodeBlock) {
                    codeBlockContent += line + '\n';
                    continue;
                }

                // Table handling
                if (trimmedLine.includes('|')) {
                    if (trimmedLine.startsWith('|') || trimmedLine.endsWith('|')) {
                        flushList();
                        flushBlockquote();
                        if (isTableSeparator(trimmedLine)) {
                            // This is the separator row (|---|---|), mark header
                            if (tableRows.length === 1) {
                                tableHasHeader = true;
                            }
                        } else {
                            // Regular table row
                            tableRows.push(parseTableRow(trimmedLine));
                            inTable = true;
                        }
                        continue;
                    }
                }
                // Flush table if we hit a non-table line
                if (inTable) {
                    flushTable();
                }

                if (line.startsWith('# ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    const id = makeId(text);
                    html += `<h1 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h1>\n`;
                    continue;
                }
                if (line.startsWith('## ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(3).trim();
                    const id = makeId(text);
                    html += `<h2 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h2>\n`;
                    continue;
                }
                if (line.startsWith('### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(4).trim();
                    const id = makeId(text);
                    html += `<h3 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h3>\n`;
                    continue;
                }
                if (line.startsWith('#### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(5).trim();
                    const id = makeId(text);
                    html += `<h4 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h4>\n`;
                    continue;
                }

                if (line.trim() === '---') {
                    flushList();
                    flushBlockquote();
                    html += '<hr>\n';
                    continue;
                }

                if (line.startsWith('> ')) {
                    flushList();
                    blockquoteContent += line.substring(2) + ' ';
                    inBlockquote = true;
                    continue;
                } else if (inBlockquote && line.trim() === '') {
                    flushBlockquote();
                    continue;
                }

                if (line.startsWith('- ') || line.startsWith('* ')) {
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    listContent += '<li>' + processInlineMarkdown(text) + '</li>\n';
                    inList = true;
                    continue;
                } else if (inList && line.trim() !== '' && !line.startsWith('#')) {
                    listContent = listContent.trimEnd();
                    if (listContent.endsWith('</li>')) {
                        listContent = listContent.substring(0, listContent.length - 5);
                        listContent += ' ' + processInlineMarkdown(line.trim()) + '</li>\n';
                    }
                    continue;
                } else if (inList && line.trim() === '') {
                    flushList();
                    continue;
                }

                if (line.trim() === '') {
                    flushList();
                    flushBlockquote();
                    continue;
                }

                flushList();
                flushBlockquote();
                if (line.trim() !== '') {
                    html += '<p>' + processInlineMarkdown(line) + '</p>\n';
                }
            }

            flushList();
            flushBlockquote();
            flushTable();

            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Copy code to clipboard
        function copyCode(codeId) {
            const codeElement = document.getElementById(codeId);
            if (!codeElement) return;

            const text = codeElement.textContent;
            navigator.clipboard.writeText(text).then(() => {
                // Find the button that triggered this
                const btn = codeElement.closest('.code-block').querySelector('.copy-btn');
                if (btn) {
                    const originalText = btn.querySelector('span').textContent;
                    btn.classList.add('copied');
                    btn.querySelector('span').textContent = 'Copied!';

                    setTimeout(() => {
                        btn.classList.remove('copied');
                        btn.querySelector('span').textContent = originalText;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Load a page
        function loadPage(pageId) {
            const pageData = Object.values(PAGES).find(p => p.id === pageId);
            if (!pageData) {
                console.error('Page not found:', pageId);
                return;
            }

            const content = parseMarkdown(pageData.content);
            document.getElementById('content').innerHTML = content;

            // Update active nav link
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.dataset.page === pageId) {
                    link.classList.add('active');
                }
            });

            // Scroll to top
            window.scrollTo(0, 0);

            // Update URL hash
            window.location.hash = pageId;
        }

        // Setup navigation
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const pageId = link.dataset.page;
                loadPage(pageId);

                // Close mobile menu
                if (window.innerWidth < 1024) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                }
            });
        });

        // Handle browser back/forward
        window.addEventListener('hashchange', () => {
            const hash = window.location.hash.substring(1);
            if (hash) {
                loadPage(hash);
            }
        });

        // Search functionality
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const searchContainer = document.getElementById('searchContainer');
        const searchToggle = document.getElementById('searchToggle');
        let selectedIndex = -1;
        let currentResults = [];

        // Build search index from PAGES
        function buildSearchIndex() {
            const index = [];
            for (const [title, page] of Object.entries(PAGES)) {
                // Extract section from page ID
                const parts = page.id.split('-');
                let section = '';
                if (parts.length > 1) {
                    section = parts.slice(0, -1).join(' ');
                }

                // Extract headings from content
                const headings = [];
                const headingRegex = /^#+\s+(.+)$/gm;
                let match;
                while ((match = headingRegex.exec(page.content)) !== null) {
                    headings.push(match[1]);
                }

                // Get preview text (first 200 chars, stripped of markdown)
                let preview = page.content
                    .replace(/^#+\s+.+$/gm, '')  // Remove headings
                    .replace(/```[\s\S]*?```/g, '')  // Remove code blocks
                    .replace(/`[^`]+`/g, '')  // Remove inline code
                    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')  // Convert links to text
                    .replace(/\*\*([^*]+)\*\*/g, '$1')  // Remove bold
                    .replace(/\*([^*]+)\*/g, '$1')  // Remove italic
                    .replace(/\n+/g, ' ')  // Normalize whitespace
                    .trim()
                    .substring(0, 200);

                index.push({
                    title: title,
                    pageId: page.id,
                    section: section,
                    headings: headings,
                    content: page.content.toLowerCase(),
                    preview: preview
                });
            }
            return index;
        }

        const searchIndex = buildSearchIndex();

        // Search function
        function search(query) {
            if (!query || query.length < 2) return [];

            const q = query.toLowerCase().trim();
            const results = [];

            for (const item of searchIndex) {
                let score = 0;
                let matchedHeading = null;
                let matchContext = '';

                // Check title (highest priority)
                const titleLower = item.title.toLowerCase();
                if (titleLower === q) {
                    score = 100;
                } else if (titleLower.startsWith(q)) {
                    score = 80;
                } else if (titleLower.includes(q)) {
                    score = 60;
                }

                // Check headings
                for (const heading of item.headings) {
                    const headingLower = heading.toLowerCase();
                    if (headingLower === q) {
                        score = Math.max(score, 50);
                        matchedHeading = heading;
                    } else if (headingLower.includes(q)) {
                        score = Math.max(score, 40);
                        if (!matchedHeading) matchedHeading = heading;
                    }
                }

                // Check content
                if (item.content.includes(q)) {
                    score = Math.max(score, 20);

                    // Find context around the match
                    const idx = item.content.indexOf(q);
                    const start = Math.max(0, idx - 40);
                    const end = Math.min(item.content.length, idx + q.length + 60);
                    matchContext = item.content.substring(start, end);
                    if (start > 0) matchContext = '...' + matchContext;
                    if (end < item.content.length) matchContext = matchContext + '...';
                }

                if (score > 0) {
                    results.push({
                        title: item.title,
                        pageId: item.pageId,
                        section: item.section,
                        score: score,
                        matchedHeading: matchedHeading,
                        preview: matchContext || item.preview,
                        query: q
                    });
                }
            }

            // Sort by score descending
            results.sort((a, b) => b.score - a.score);

            return results.slice(0, 10);  // Limit to 10 results
        }

        // Highlight query in text
        function highlightText(text, query) {
            if (!query) return text;
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }

        // Render search results
        function renderResults(results, query) {
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-no-results">No results found</div>';
                return;
            }

            const html = results.map((result, index) => {
                const titleHtml = highlightText(result.title, query);
                const previewHtml = highlightText(result.preview, query);
                const selectedClass = index === selectedIndex ? ' selected' : '';

                return `
                    <div class="search-result${selectedClass}" data-index="${index}" data-page="${result.pageId}">
                        ${result.section ? `<div class="search-result-section">${result.section}</div>` : ''}
                        <div class="search-result-title">${titleHtml}</div>
                        ${result.matchedHeading ? `<div class="search-result-preview">${highlightText(result.matchedHeading, query)}</div>` : ''}
                        <div class="search-result-preview">${previewHtml}</div>
                    </div>
                `;
            }).join('');

            searchResults.innerHTML = html;

            // Add click handlers
            searchResults.querySelectorAll('.search-result').forEach(el => {
                el.addEventListener('click', () => {
                    const pageId = el.dataset.page;
                    loadPage(pageId);
                    closeSearch();
                });
            });
        }

        // Show search results
        function showResults() {
            searchResults.classList.add('active');
        }

        // Hide search results
        function hideResults() {
            searchResults.classList.remove('active');
            selectedIndex = -1;
        }

        // Close search (mobile)
        function closeSearch() {
            hideResults();
            searchInput.value = '';
            searchInput.blur();
            if (window.innerWidth < 769) {
                searchContainer.classList.remove('active');
            }
        }

        // Debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Handle search input
        const handleSearch = debounce((query) => {
            currentResults = search(query);
            if (query.length >= 2) {
                renderResults(currentResults, query);
                showResults();
            } else {
                hideResults();
            }
        }, 150);

        searchInput.addEventListener('input', (e) => {
            handleSearch(e.target.value);
        });

        // Handle keyboard navigation
        searchInput.addEventListener('keydown', (e) => {
            if (!searchResults.classList.contains('active')) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, currentResults.length - 1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIndex >= 0 && currentResults[selectedIndex]) {
                    loadPage(currentResults[selectedIndex].pageId);
                    closeSearch();
                } else if (currentResults.length > 0) {
                    loadPage(currentResults[0].pageId);
                    closeSearch();
                }
            } else if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Close results when clicking outside
        document.addEventListener('click', (e) => {
            if (!searchContainer.contains(e.target)) {
                hideResults();
            }
        });

        // Focus search on input click
        searchInput.addEventListener('focus', () => {
            if (searchInput.value.length >= 2) {
                handleSearch(searchInput.value);
            }
        });

        // Global keyboard shortcut (Ctrl+K or Cmd+K)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                if (window.innerWidth < 769) {
                    searchContainer.classList.add('active');
                }
                searchInput.focus();
            }
            if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Mobile search toggle
        if (searchToggle) {
            searchToggle.addEventListener('click', () => {
                searchContainer.classList.toggle('active');
                if (searchContainer.classList.contains('active')) {
                    searchInput.focus();
                }
            });
        }

        // Language switcher
        function switchLanguage(filename) {
            const currentHash = window.location.hash;
            window.location.href = filename + currentHash;
        }

        // Load initial page
        const initialHash = window.location.hash.substring(1);
        const firstPageId = Object.values(PAGES)[0].id;
        loadPage(initialHash || firstPageId);
    </script>
</body>
</html>