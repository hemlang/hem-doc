<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hemlock 语言手册</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sage: #9CAF88;
            --pine: #2F4F4F;
            --dark-pine: #1a2f2f;
            --light-sage: #E8F4E1;
            --cream: #FAF9F6;
            --text: #2C3E2C;
            --text-light: #5A6F5A;
            --border: #D4E4CB;
            --code-bg: #F5F9F3;
            --accent: #6B8E6B;
        }

        [data-theme="dark"] {
            --sage: #6B8E6B;
            --pine: #9CAF88;
            --dark-pine: #0d1a1a;
            --light-sage: #1a2f2f;
            --cream: #0f1a1a;
            --text: #e0e8e0;
            --text-light: #a8b8a8;
            --border: #2a4a4a;
            --code-bg: #162626;
            --accent: #9CAF88;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) {
                --sage: #6B8E6B;
                --pine: #9CAF88;
                --dark-pine: #0d1a1a;
                --light-sage: #1a2f2f;
                --cream: #0f1a1a;
                --text: #e0e8e0;
                --text-light: #a8b8a8;
                --border: #2a4a4a;
                --code-bg: #162626;
                --accent: #9CAF88;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            line-height: 1.7;
            color: var(--text);
            background: var(--cream);
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: #2F4F4F;
            color: white;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .header-logo {
            height: 45px;
            margin-right: 1rem;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            margin-right: auto;
        }

        /* Layout */
        .container {
            display: flex;
            margin-top: 70px;
            min-height: calc(100vh - 70px);
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 70px;
            width: 280px;
            height: calc(100vh - 70px);
            background: var(--light-sage);
            border-right: 2px solid var(--border);
            overflow-y: auto;
            padding: 2rem 0;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 900;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        @media (min-width: 1024px) {
            .sidebar {
                transform: translateX(0);
            }
        }

        .nav-section {
            margin-bottom: 1.5rem;
        }

        .nav-section-title {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--pine);
            padding: 0 1.5rem;
            margin-bottom: 0.5rem;
        }

        .nav-link {
            display: block;
            padding: 0.5rem 1.5rem;
            color: var(--text);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .nav-link:hover {
            background: rgba(47, 79, 79, 0.05);
            border-left-color: var(--sage);
        }

        .nav-link.active {
            background: rgba(47, 79, 79, 0.1);
            border-left-color: var(--pine);
            font-weight: 600;
            color: var(--pine);
        }

        /* Mobile Menu Toggle */
        .menu-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 56px;
            height: 56px;
            background: var(--pine);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (min-width: 1024px) {
            .menu-toggle {
                display: none;
            }
        }

        /* Main Content */
        .main-content {
            flex: 1;
            margin-left: 0;
            padding: 3rem 2rem;
            max-width: 900px;
        }

        @media (min-width: 1024px) {
            .main-content {
                margin-left: 280px;
            }
        }

        /* Typography */
        .content h1 {
            font-size: 2.5rem;
            color: var(--pine);
            margin: 2rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--sage);
        }

        .content h2 {
            font-size: 2rem;
            color: var(--pine);
            margin: 3rem 0 1rem;
            padding-top: 1rem;
        }

        .content h3 {
            font-size: 1.5rem;
            color: var(--accent);
            margin: 2rem 0 1rem;
        }

        .content h4 {
            font-size: 1.2rem;
            color: var(--accent);
            margin: 1.5rem 0 0.8rem;
        }

        .content p {
            margin: 1rem 0;
            color: var(--text);
        }

        .content ul, .content ol {
            margin: 1rem 0 1rem 2rem;
        }

        .content li {
            margin: 0.5rem 0;
        }

        .content blockquote {
            border-left: 4px solid var(--sage);
            background: var(--light-sage);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: var(--text-light);
        }

        .content hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }

        /* Code Blocks */
        .content code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--pine);
        }

        .code-block {
            margin: 1.5rem 0;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: var(--code-bg);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--pine);
            color: var(--light-sage);
            font-size: 0.8rem;
        }

        .code-lang {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-weight: 600;
            text-transform: lowercase;
        }

        .copy-btn {
            background: transparent;
            border: 1px solid var(--sage);
            color: var(--light-sage);
            padding: 0.3rem 0.7rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .copy-btn:hover {
            background: var(--sage);
            color: var(--pine);
        }

        .copy-btn.copied {
            background: var(--sage);
            color: var(--pine);
            border-color: var(--sage);
        }

        .copy-btn svg {
            width: 14px;
            height: 14px;
        }

        .content pre {
            background: var(--code-bg);
            margin: 0;
            padding: 1.2rem;
            overflow-x: auto;
        }

        .content pre code {
            background: none;
            padding: 0;
            border-radius: 0;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        /* Standalone pre without code-block wrapper (legacy) */
        .content > pre {
            border: 1px solid var(--border);
            border-left: 4px solid var(--pine);
            border-radius: 4px;
            margin: 1.5rem 0;
        }

        /* Tables */
        .content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        .content th,
        .content td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .content th {
            background: var(--light-sage);
            color: var(--pine);
            font-weight: 600;
        }

        /* Links */
        .content a {
            color: var(--accent);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .content a:hover {
            border-bottom-color: var(--accent);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--cream);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--sage);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* Section anchors */
        .section-anchor {
            scroll-margin-top: 90px;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            .main-content {
                padding: 2rem 1rem;
            }

            .content h1 {
                font-size: 2rem;
            }

            .content h2 {
                font-size: 1.6rem;
            }

            .content h3 {
                font-size: 1.3rem;
            }
        }

        /* Page switching */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* Search */
        .search-container {
            position: relative;
            margin-right: 1rem;
        }

        .search-input {
            width: 200px;
            padding: 0.5rem 1rem;
            padding-left: 2.2rem;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.25);
            width: 280px;
        }

        .search-icon {
            position: absolute;
            left: 0.8rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
        }

        .search-results {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            right: 0;
            min-width: 320px;
            max-height: 400px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1001;
        }

        .search-results.active {
            display: block;
        }

        .search-result {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s;
        }

        .search-result:last-child {
            border-bottom: none;
        }

        .search-result:hover,
        .search-result.selected {
            background: var(--light-sage);
        }

        .search-result-title {
            font-weight: 600;
            color: var(--pine);
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
        }

        .search-result-section {
            font-size: 0.75rem;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .search-result-preview {
            font-size: 0.85rem;
            color: var(--text-light);
            margin-top: 0.25rem;
            line-height: 1.4;
        }

        .search-result-preview mark {
            background: var(--sage);
            color: var(--pine);
            padding: 0 2px;
            border-radius: 2px;
        }

        .search-no-results {
            padding: 1rem;
            text-align: center;
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .search-shortcut {
            display: none;
            margin-left: 0.5rem;
            padding: 0.15rem 0.4rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.8);
        }

        @media (min-width: 768px) {
            .search-shortcut {
                display: inline-block;
            }
        }

        @media (max-width: 768px) {
            .search-container {
                position: fixed;
                top: 70px;
                left: 0;
                right: 0;
                margin: 0;
                padding: 0.5rem;
                background: #1a2f2f;
                display: none;
                z-index: 999;
            }

            .search-container.active {
                display: block;
            }

            .search-input {
                width: 100%;
            }

            .search-input:focus {
                width: 100%;
            }

            .search-results {
                position: fixed;
                top: 120px;
                left: 0.5rem;
                right: 0.5rem;
                min-width: auto;
                max-height: calc(100vh - 140px);
            }

            .search-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
                background: transparent;
                border: none;
                color: white;
                font-size: 1.2rem;
                cursor: pointer;
                padding: 0.5rem;
                margin-left: auto;
            }
        }

        @media (min-width: 769px) {
            .search-toggle {
                display: none;
            }
        }

        /* Theme Toggle */
        .theme-toggle {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            margin-left: 0.5rem;
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .theme-toggle svg {
            width: 20px;
            height: 20px;
        }

        .theme-toggle .sun-icon {
            display: none;
        }

        .theme-toggle .moon-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .sun-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .moon-icon {
            display: none;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) .theme-toggle .sun-icon {
                display: block;
            }
            :root:not([data-theme="light"]) .theme-toggle .moon-icon {
                display: none;
            }
        }

        /* Language Switcher */
        .lang-switcher {
            margin-left: 0.5rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 8px;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }

        .lang-switcher:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher:focus {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher option {
            background: var(--pine);
            color: white;
        }

        [data-theme="dark"] .lang-switcher option {
            background: var(--bg-primary);
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <img src="data:image/png;base64,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" alt="Hemlock Logo" class="header-logo">
        <h1>Hemlock 语言手册</h1>
        <!-- Search -->
        <div class="search-container" id="searchContainer">
            <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
            <input type="text" class="search-input" id="searchInput" placeholder="Search docs..." autocomplete="off">
            <span class="search-shortcut">Ctrl+K</span>
            <div class="search-results" id="searchResults"></div>
        </div>
        <button class="search-toggle" id="searchToggle">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
        </button>
        <select class="lang-switcher" id="langSwitcher" onchange="switchLanguage(this.value)">
            <option value="docs.html" >English</option>
<option value="docs-zh.html" selected>中文</option>
        </select>
        <button class="theme-toggle" id="themeToggle" title="Toggle dark mode">
            <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
            <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
        </button>
    </div>

    <!-- Mobile Menu Toggle -->
    <button class="menu-toggle" id="menuToggle">&#9776;</button>

    <!-- Container -->
    <div class="container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar" id="sidebar">
            <div class="nav-section">
<a href="#language-reference" class="nav-link" data-page="language-reference">Language Reference</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Getting Started</div>
<a href="#getting-started-installation" class="nav-link" data-page="getting-started-installation">Installation</a>
<a href="#getting-started-learning-paths" class="nav-link" data-page="getting-started-learning-paths">Learning Paths</a>
<a href="#getting-started-quick-start" class="nav-link" data-page="getting-started-quick-start">Quick Start</a>
<a href="#getting-started-tutorial" class="nav-link" data-page="getting-started-tutorial">Tutorial</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Language Guide</div>
<a href="#language-guide-arrays" class="nav-link" data-page="language-guide-arrays">Arrays</a>
<a href="#language-guide-control-flow" class="nav-link" data-page="language-guide-control-flow">Control Flow</a>
<a href="#language-guide-error-handling" class="nav-link" data-page="language-guide-error-handling">Error Handling</a>
<a href="#language-guide-functions" class="nav-link" data-page="language-guide-functions">Functions</a>
<a href="#language-guide-memory" class="nav-link" data-page="language-guide-memory">Memory</a>
<a href="#language-guide-modules" class="nav-link" data-page="language-guide-modules">Modules</a>
<a href="#language-guide-objects" class="nav-link" data-page="language-guide-objects">Objects</a>
<a href="#language-guide-pattern-matching" class="nav-link" data-page="language-guide-pattern-matching">Pattern Matching</a>
<a href="#language-guide-runes" class="nav-link" data-page="language-guide-runes">Runes</a>
<a href="#language-guide-strings" class="nav-link" data-page="language-guide-strings">Strings</a>
<a href="#language-guide-syntax" class="nav-link" data-page="language-guide-syntax">Syntax</a>
<a href="#language-guide-types" class="nav-link" data-page="language-guide-types">Types</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Advanced Topics</div>
<a href="#advanced-async-concurrency" class="nav-link" data-page="advanced-async-concurrency">Async Concurrency</a>
<a href="#advanced-atomics" class="nav-link" data-page="advanced-atomics">Atomics</a>
<a href="#advanced-bundling-packaging" class="nav-link" data-page="advanced-bundling-packaging">Bundling Packaging</a>
<a href="#advanced-command-execution" class="nav-link" data-page="advanced-command-execution">Command Execution</a>
<a href="#advanced-command-line-args" class="nav-link" data-page="advanced-command-line-args">Command Line Args</a>
<a href="#advanced-ffi" class="nav-link" data-page="advanced-ffi">Ffi</a>
<a href="#advanced-file-io" class="nav-link" data-page="advanced-file-io">File Io</a>
<a href="#advanced-profiling" class="nav-link" data-page="advanced-profiling">Profiling</a>
<a href="#advanced-signals" class="nav-link" data-page="advanced-signals">Signals</a>
</div>
<div class="nav-section">
<div class="nav-section-title">API Reference</div>
<a href="#reference-array-api" class="nav-link" data-page="reference-array-api">Array API</a>
<a href="#reference-builtins" class="nav-link" data-page="reference-builtins">Builtins</a>
<a href="#reference-concurrency-api" class="nav-link" data-page="reference-concurrency-api">Concurrency API</a>
<a href="#reference-file-api" class="nav-link" data-page="reference-file-api">File API</a>
<a href="#reference-memory-api" class="nav-link" data-page="reference-memory-api">Memory API</a>
<a href="#reference-operators" class="nav-link" data-page="reference-operators">Operators</a>
<a href="#reference-string-api" class="nav-link" data-page="reference-string-api">String API</a>
<a href="#reference-type-system" class="nav-link" data-page="reference-type-system">Type System</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Design & Philosophy</div>
<a href="#design-implementation" class="nav-link" data-page="design-implementation">Implementation</a>
<a href="#design-philosophy" class="nav-link" data-page="design-philosophy">Philosophy</a>
<a href="#design-signature-syntax" class="nav-link" data-page="design-signature-syntax">Signature Syntax</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Contributing</div>
<a href="#contributing-guidelines" class="nav-link" data-page="contributing-guidelines">Guidelines</a>
<a href="#contributing-testing" class="nav-link" data-page="contributing-testing">Testing</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Hpm: Getting Started</div>
<a href="#hpm-installation" class="nav-link" data-page="hpm-installation">Installation</a>
<a href="#hpm-project-setup" class="nav-link" data-page="hpm-project-setup">Project Setup</a>
<a href="#hpm-quick-start" class="nav-link" data-page="hpm-quick-start">Quick Start</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Hpm: User Guide</div>
<a href="#hpm-commands" class="nav-link" data-page="hpm-commands">Commands</a>
<a href="#hpm-configuration" class="nav-link" data-page="hpm-configuration">Configuration</a>
<a href="#hpm-troubleshooting" class="nav-link" data-page="hpm-troubleshooting">Troubleshooting</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Hpm: Package Development</div>
<a href="#hpm-creating-packages" class="nav-link" data-page="hpm-creating-packages">Creating Packages</a>
<a href="#hpm-package-spec" class="nav-link" data-page="hpm-package-spec">Package Spec</a>
<a href="#hpm-versioning" class="nav-link" data-page="hpm-versioning">Versioning</a>
</div>
<div class="nav-section">
<div class="nav-section-title">Hpm: Reference</div>
<a href="#hpm-architecture" class="nav-link" data-page="hpm-architecture">Architecture</a>
<a href="#hpm-exit-codes" class="nav-link" data-page="hpm-exit-codes">Exit Codes</a>
</div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <div class="content" id="content"></div>
        </main>
    </div>

    <script>
        // Embedded documentation pages
        const PAGES = {"Language Reference": {"id": "language-reference", "content": "# Hemlock Language Design Philosophy\n\n> \"A small, unsafe language for writing unsafe things safely.\"\n\nThis document captures the core design principles for AI assistants working with Hemlock.\nFor detailed documentation, see `docs/README.md` and the `stdlib/docs/` directory.\n\n---\n\n## Core Identity\n\nHemlock is a **systems scripting language** with manual memory management and explicit control:\n- The power of C with modern scripting ergonomics\n- Structured async concurrency built-in\n- No hidden behavior or magic\n\n**Hemlock is NOT:** Memory-safe, a GC language, or hiding complexity.\n**Hemlock IS:** Explicit over implicit, educational, a \"C scripting layer\" for systems work.\n\n---\n\n## Design Principles\n\n### 1. Explicit Over Implicit\n- Semicolons mandatory (no ASI)\n- Manual memory management (alloc/free)\n- Type annotations optional but checked at runtime\n\n### 2. Dynamic by Default, Typed by Choice\n- Every value has a runtime type tag\n- Literals infer types: `42` → i32, `5000000000` → i64, `3.14` → f64\n- Optional type annotations enforce runtime checks\n\n### 3. Unsafe is a Feature\n- Pointer arithmetic allowed (user's responsibility)\n- No bounds checking on raw `ptr` (use `buffer` for safety)\n- Double-free crashes allowed\n\n### 4. Structured Concurrency First-Class\n- `async`/`await` built-in with pthread-based parallelism\n- Channels for communication\n- `spawn`/`join`/`detach` for task management\n\n### 5. C-like Syntax\n- `{}` blocks always required\n- Comments: `// line` and `/* block */`\n- Operators match C: `+`, `-`, `*`, `%`, `&&`, `||`, `!`, `&`, `|`, `^`, `<<`, `>>`\n- Increment/decrement: `++x`, `x++`, `--x`, `x--` (prefix and postfix)\n- Compound assignment: `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`\n- `/` always returns float (use `divi()` for integer division)\n- Type syntax: `let x: type = value;`\n\n---\n\n## Quick Reference\n\n### Types\n```\nSigned:   i8, i16, i32, i64\nUnsigned: u8, u16, u32, u64\nFloats:   f32, f64\nOther:    bool, string, rune, array, ptr, buffer, null, object, file, task, channel\nAliases:  integer (i32), number (f64), byte (u8)\n```\n\n**Type promotion:** i8 → i16 → i32 → i64 → f32 → f64 (floats always win, but i64/u64 + f32 → f64 to preserve precision)\n\n### Literals\n```hemlock\nlet x = 42;              // i32\nlet big = 5000000000;    // i64 (> i32 max)\nlet hex = 0xDEADBEEF;    // hex literal\nlet bin = 0b1010;        // binary literal\nlet oct = 0o777;         // octal literal\nlet sep = 1_000_000;     // numeric separators allowed\nlet pi = 3.14;           // f64\nlet half = .5;           // f64 (no leading zero)\nlet s = \"hello\";         // string\nlet esc = \"\\x41\\u{1F600}\"; // hex and unicode escapes\nlet ch = 'A';            // rune\nlet emoji = '🚀';        // rune (Unicode)\nlet arr = [1, 2, 3];     // array\nlet obj = { x: 10 };     // object\n```\n\n### Type Conversion\n```hemlock\n// Type constructor functions - parse strings to types\nlet n = i32(\"42\");       // Parse string to i32\nlet f = f64(\"3.14\");     // Parse string to f64\nlet b = bool(\"true\");    // Parse string to bool (\"true\" or \"false\")\n\n// All numeric types supported\nlet a = i8(\"-128\");      // i8, i16, i32, i64\nlet c = u8(\"255\");       // u8, u16, u32, u64\nlet d = f32(\"1.5\");      // f32, f64\n\n// Hex and negative numbers\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\n\n// Type aliases work too\nlet x = integer(\"100\");  // Same as i32(\"100\")\nlet y = number(\"1.5\");   // Same as f64(\"1.5\")\nlet z = byte(\"200\");     // Same as u8(\"200\")\n\n// Convert between numeric types\nlet big = i64(42);       // i32 to i64\nlet truncated = i32(3.99); // f64 to i32 (truncates to 3)\n\n// Type annotations validate types (but don't parse strings)\nlet f: f64 = 100;        // i32 to f64 via annotation (numeric coercion OK)\n// let n: i32 = \"42\";    // ERROR - use i32(\"42\") for string parsing\n```\n\n### Introspection\n```hemlock\ntypeof(42);              // \"i32\"\ntypeof(\"hello\");         // \"string\"\ntypeof([1, 2, 3]);       // \"array\"\ntypeof(null);            // \"null\"\nlen(\"hello\");            // 5 (string length in bytes)\nlen([1, 2, 3]);          // 3 (array length)\n```\n\n### Memory\n```hemlock\nlet p = alloc(64);       // raw pointer\nlet b = buffer(64);      // safe buffer (bounds checked)\nmemset(p, 0, 64);\nmemcpy(dest, src, 64);\nfree(p);                 // manual cleanup required\n```\n\n### Control Flow\n```hemlock\nif (x > 0) { } else if (x < 0) { } else { }\nwhile (cond) { break; continue; }\nfor (let i = 0; i < 10; i++) { }\nfor (item in array) { }\nloop { if (done) { break; } }   // infinite loop (cleaner than while(true))\nswitch (x) { case 1: break; default: break; }  // C-style fall-through\ndefer cleanup();         // runs when function returns\n\n// Loop labels for targeted break/continue in nested loops\nouter: while (cond) {\n    inner: for (let i = 0; i < 10; i++) {\n        if (i == 5) { break outer; }     // break outer loop\n        if (i == 3) { continue outer; }  // continue outer loop\n    }\n}\n```\n\n### Pattern Matching\n```hemlock\n// Match expression - returns value\nlet result = match (value) {\n    0 => \"zero\",                    // Literal pattern\n    1 | 2 | 3 => \"small\",           // OR pattern\n    n if n < 10 => \"medium\",        // Guard expression\n    n => \"large: \" + n              // Variable binding\n};\n\n// Type patterns\nmatch (val) {\n    n: i32 => \"integer\",\n    s: string => \"string\",\n    _ => \"other\"                    // Wildcard\n}\n\n// Object destructuring\nmatch (point) {\n    { x: 0, y: 0 } => \"origin\",\n    { x, y } => \"at \" + x + \",\" + y\n}\n\n// Array destructuring with rest\nmatch (arr) {\n    [] => \"empty\",\n    [first, ...rest] => \"head: \" + first,\n    _ => \"other\"\n}\n\n// Nested patterns\nmatch (user) {\n    { name, address: { city } } => name + \" in \" + city\n}\n```\n\nSee `docs/language-guide/pattern-matching.md` for full documentation.\n\n### Null Coalescing Operators\n```hemlock\n// Null coalescing (??) - returns left if non-null, else right\nlet name = user.name ?? \"Anonymous\";\nlet first = a ?? b ?? c ?? \"fallback\";\n\n// Null coalescing assignment (??=) - assigns only if null\nlet config = null;\nconfig ??= { timeout: 30 };    // config is now { timeout: 30 }\nconfig ??= { timeout: 60 };    // config unchanged (not null)\n\n// Works with properties and indices\nobj.field ??= \"default\";\narr[0] ??= \"first\";\n\n// Safe navigation (?.) - returns null if object is null\nlet city = user?.address?.city;  // null if any part is null\nlet upper = name?.to_upper();    // safe method call\nlet item = arr?.[0];             // safe indexing\n```\n\n### Functions\n```hemlock\nfn add(a: i32, b: i32): i32 { return a + b; }\nfn greet(name: string, msg?: \"Hello\") { print(msg + \" \" + name); }\nlet f = fn(x) { return x * 2; };  // anonymous/closure\n\n// Expression-bodied functions (arrow syntax)\nfn double(x: i32): i32 => x * 2;\nfn max(a: i32, b: i32): i32 => a > b ? a : b;\nlet square = fn(x: i32): i32 => x * x;  // anonymous expression-bodied\n\n// Parameter modifiers\nfn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // pass-by-reference\nfn print_all(const items: array) { for (i in items) { print(i); } }  // immutable\n```\n\n### Named Arguments\n```hemlock\n// Functions can be called with named arguments\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" is \" + age + \" years old\");\n}\n\n// Positional arguments (traditional)\ncreate_user(\"Alice\", 25, false);\n\n// Named arguments - can be in any order\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n\n// Skip optional parameters by naming what you need\ncreate_user(\"David\", active: false);  // Uses default age=18\n\n// Named arguments must come after positional arguments\ncreate_user(\"Eve\", age: 21);          // OK: positional then named\n// create_user(name: \"Bad\", 25);      // ERROR: positional after named\n```\n\n**Rules:**\n- Named arguments use `name: value` syntax\n- Can appear in any order after positional arguments\n- Positional arguments cannot follow named arguments\n- Works with default/optional parameters\n- Unknown parameter names cause runtime errors\n\n### Objects & Enums\n```hemlock\ndefine Person { name: string, age: i32, active?: true }\nlet p: Person = { name: \"Alice\", age: 30 };\nlet json = p.serialize();\nlet restored = json.deserialize();\n\n// Object shorthand syntax (ES6-style)\nlet name = \"Alice\";\nlet age = 30;\nlet person = { name, age };         // equivalent to { name: name, age: age }\n\n// Object spread operator\nlet defaults = { theme: \"dark\", size: \"medium\" };\nlet config = { ...defaults, size: \"large\" };  // copies defaults, overrides size\n\nenum Color { RED, GREEN, BLUE }\nenum Status { OK = 0, ERROR = 1 }\n```\n\n### Compound Types (Intersection/Duck Types)\n```hemlock\n// Define structural types\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// Compound type: object must satisfy ALL types\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// Function parameters with compound types\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" is \" + p.age);\n}\n\n// Three or more types\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n\n// Extra fields allowed (duck typing)\nlet employee: HasName & HasAge = {\n    name: \"Bob\",\n    age: 25,\n    department: \"Engineering\"  // OK - extra fields ignored\n};\n```\n\nCompound types provide interface-like behavior without a separate `interface` keyword,\nbuilding on the existing `define` and duck typing paradigms.\n\n### Type Aliases\n```hemlock\n// Simple type alias\ntype Integer = i32;\ntype Text = string;\n\n// Function type alias\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// Compound type alias (great for reusable interfaces)\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// Generic type alias\ntype Pair<T> = { first: T, second: T };\n\n// Using type aliases\nlet x: Integer = 42;\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\nType aliases create named shortcuts for complex types, improving readability and maintainability.\n\n### Function Types\n```hemlock\n// Function type annotations for parameters\nfn apply_fn(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Higher-order function returning a function\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Async function types\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n\n// Function types with multiple parameters\ntype BinaryOp = fn(i32, i32): i32;\nlet add: BinaryOp = fn(a, b) { return a + b; };\n```\n\n### Const Parameters\n```hemlock\n// Const parameter - deep immutability\nfn print_all(const items: array) {\n    // items.push(4);  // ERROR: cannot mutate const parameter\n    for (item in items) {\n        print(item);\n    }\n}\n\n// Const with objects - no mutation through any path\nfn describe(const person: object) {\n    print(person.name);       // OK: reading is allowed\n    // person.name = \"Bob\";   // ERROR: cannot mutate\n}\n\n// Nested access is allowed for reading\nfn get_city(const user: object) {\n    return user.address.city;  // OK: reading nested properties\n}\n```\n\nThe `const` modifier prevents any mutation of the parameter, including nested properties.\nThis provides compile-time safety for functions that should not modify their inputs.\n\n### Ref Parameters (Pass-by-Reference)\n```hemlock\n// Ref parameter - caller's variable is modified directly\nfn increment(ref x: i32) {\n    x = x + 1;  // Modifies the original variable\n}\n\nlet count = 10;\nincrement(count);\nprint(count);  // 11 - original was modified\n\n// Classic swap function\nfn swap(ref a: i32, ref b: i32) {\n    let temp = a;\n    a = b;\n    b = temp;\n}\n\nlet x = 1;\nlet y = 2;\nswap(x, y);\nprint(x, y);  // 2 1\n\n// Mix ref and regular parameters\nfn add_to(ref target: i32, amount: i32) {\n    target = target + amount;\n}\n\nlet total = 100;\nadd_to(total, 50);\nprint(total);  // 150\n```\n\nThe `ref` modifier passes a reference to the caller's variable, allowing the function to\nmodify it directly. Without `ref`, primitives are passed by value (copied). Use `ref` when\nyou need to mutate the caller's state without returning a value.\n\n**Rules:**\n- `ref` parameters must be passed variables, not literals or expressions\n- Works with all types (primitives, arrays, objects)\n- Combine with type annotations: `ref x: i32`\n- Cannot combine with `const` (they're opposites)\n\n### Method Signatures in Define\n```hemlock\n// Define with method signatures (interface pattern)\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32   // Required method signature\n}\n\n// Objects must provide the required method\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// Optional methods with ?\ndefine Serializable {\n    fn serialize(): string,        // Required\n    fn pretty?(): string           // Optional method\n}\n\n// Self type refers to the defining type\ndefine Cloneable {\n    fn clone(): Self   // Returns same type as the object\n}\n```\n\nMethod signatures in `define` blocks use comma delimiters (like TypeScript interfaces),\nestablishing contracts that objects must fulfill and enabling interface-like programming\npatterns with Hemlock's duck typing system.\n\n### Error Handling\n```hemlock\ntry { throw \"error\"; } catch (e) { print(e); } finally { cleanup(); }\npanic(\"unrecoverable\");  // exits immediately, not catchable\n```\n\n### Async/Concurrency\n```hemlock\nasync fn compute(n: i32): i32 { return n * n; }\nlet task = spawn(compute, 42);\nlet result = await task;     // or join(task)\ndetach(spawn(background_work));\n\nlet ch = channel(10);\nch.send(value);\nlet val = ch.recv();\nch.close();\n```\n\n**Memory ownership:** Tasks receive copies of primitive values but share pointers. If you pass a `ptr` to a spawned task, you must ensure the memory remains valid until the task completes. Use `join()` before `free()`, or use channels to signal completion.\n\n### User Input\n```hemlock\nlet name = read_line();          // Read line from stdin (blocks)\nprint(\"Hello, \" + name);\neprint(\"Error message\");         // Print to stderr\n\n// read_line() returns null on EOF\nwhile (true) {\n    let line = read_line();\n    if (line == null) { break; }\n    print(\"Got:\", line);\n}\n```\n\n### File I/O\n```hemlock\nlet f = open(\"file.txt\", \"r\");  // modes: r, w, a, r+, w+, a+\nlet content = f.read();\nf.write(\"data\");\nf.seek(0);\nf.close();\n```\n\n### Signals\n```hemlock\nsignal(SIGINT, fn(sig) { print(\"Interrupted\"); });\nraise(SIGUSR1);\n```\n\n---\n\n## String Methods (19)\n\n`substr`, `slice`, `find`, `contains`, `split`, `trim`, `to_upper`, `to_lower`,\n`starts_with`, `ends_with`, `replace`, `replace_all`, `repeat`, `char_at`,\n`byte_at`, `chars`, `bytes`, `to_bytes`, `deserialize`\n\nTemplate strings: `` `Hello ${name}!` ``\n\n**String mutability:** Strings are mutable via index assignment (`s[0] = 'H'`), but all string methods return new strings without modifying the original. This allows in-place mutation when needed while keeping method chaining functional.\n\n**String length properties:**\n```hemlock\nlet s = \"hello 🚀\";\nprint(s.length);       // 7 (character/rune count)\nprint(s.byte_length);  // 10 (byte count - emoji is 4 bytes UTF-8)\n```\n\n## Array Methods (18)\n\n`push`, `pop`, `shift`, `unshift`, `insert`, `remove`, `find`, `contains`,\n`slice`, `join`, `concat`, `reverse`, `first`, `last`, `clear`, `map`, `filter`, `reduce`\n\nTyped arrays: `let nums: array<i32> = [1, 2, 3];`\n\n---\n\n## Standard Library (40 modules)\n\nImport with `@stdlib/` prefix:\n```hemlock\nimport { sin, cos, PI } from \"@stdlib/math\";\nimport { HashMap, Queue, Set } from \"@stdlib/collections\";\nimport { read_file, write_file } from \"@stdlib/fs\";\nimport { TcpStream, UdpSocket } from \"@stdlib/net\";\n```\n\n| Module | Description |\n|--------|-------------|\n| `arena` | Arena memory allocator (bump allocation) |\n| `args` | Command-line argument parsing |\n| `assert` | Assertion utilities |\n| `async` | ThreadPool, parallel_map |\n| `async_fs` | Async file I/O operations |\n| `collections` | HashMap, Queue, Stack, Set, LinkedList, LRUCache |\n| `compression` | gzip, gunzip, deflate |\n| `crypto` | aes_encrypt, rsa_sign, random_bytes |\n| `csv` | CSV parsing and generation |\n| `datetime` | DateTime class, formatting, parsing |\n| `encoding` | base64_encode, hex_encode, url_encode |\n| `env` | getenv, setenv, exit, get_pid |\n| `fmt` | String formatting utilities |\n| `fs` | read_file, write_file, list_dir, exists |\n| `glob` | File pattern matching |\n| `hash` | sha256, sha512, md5, djb2 |\n| `http` | http_get, http_post, http_request |\n| `ipc` | Inter-process communication |\n| `iter` | Iterator utilities |\n| `json` | parse, stringify, pretty, get, set |\n| `logging` | Logger with levels |\n| `math` | sin, cos, sqrt, pow, rand, PI, E |\n| `net` | TcpListener, TcpStream, UdpSocket |\n| `os` | platform, arch, cpu_count, hostname |\n| `path` | File path manipulation |\n| `process` | fork, exec, wait, kill |\n| `random` | Random number generation |\n| `regex` | compile, test (POSIX ERE) |\n| `retry` | Retry logic with backoff |\n| `semver` | Semantic versioning |\n| `shell` | Shell command utilities |\n| `sqlite` | SQLite database, query, exec, transactions |\n| `strings` | pad_left, is_alpha, reverse, lines |\n| `terminal` | ANSI colors and styles |\n| `testing` | describe, test, expect |\n| `time` | now, time_ms, sleep, clock |\n| `toml` | TOML parsing and generation |\n| `url` | URL parsing and manipulation |\n| `uuid` | UUID generation |\n| `websocket` | WebSocket client |\n\nSee `stdlib/docs/` for detailed module documentation.\n\n---\n\n## FFI (Foreign Function Interface)\n\nDeclare and call C functions from shared libraries:\n```hemlock\nimport \"libc.so.6\";\n\nextern fn strlen(s: string): i32;\nextern fn getpid(): i32;\n\nlet len = strlen(\"Hello!\");  // 6\nlet pid = getpid();\n```\n\nExport FFI functions from modules:\n```hemlock\n// string_utils.hml\nimport \"libc.so.6\";\n\nexport extern fn strlen(s: string): i32;\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n```\n\nDynamic FFI (runtime binding):\n```hemlock\nlet lib = ffi_open(\"libc.so.6\");\nlet puts = ffi_bind(lib, \"puts\", [FFI_POINTER], FFI_INT);\nputs(\"Hello from C!\");\nffi_close(lib);\n```\n\nTypes: `FFI_INT`, `FFI_DOUBLE`, `FFI_POINTER`, `FFI_STRING`, `FFI_VOID`, etc.\n\n---\n\n## Atomic Operations\n\nLock-free concurrent programming with atomic operations:\n\n```hemlock\n// Allocate memory for atomic i32\nlet p = alloc(4);\nptr_write_i32(p, 0);\n\n// Atomic load/store\nlet val = atomic_load_i32(p);        // Read atomically\natomic_store_i32(p, 42);             // Write atomically\n\n// Fetch-and-modify operations (return OLD value)\nlet old = atomic_add_i32(p, 10);     // Add, return old\nold = atomic_sub_i32(p, 5);          // Subtract, return old\nold = atomic_and_i32(p, 0xFF);       // Bitwise AND\nold = atomic_or_i32(p, 0x10);        // Bitwise OR\nold = atomic_xor_i32(p, 0x0F);       // Bitwise XOR\n\n// Compare-and-swap (CAS)\nlet success = atomic_cas_i32(p, 42, 100);  // If *p == 42, set to 100\n// Returns true if swap succeeded, false otherwise\n\n// Atomic exchange\nold = atomic_exchange_i32(p, 999);   // Swap, return old\n\nfree(p);\n\n// i64 variants available (atomic_load_i64, atomic_add_i64, etc.)\n\n// Memory fence (full barrier)\natomic_fence();\n```\n\nAll operations use sequential consistency (`memory_order_seq_cst`).\n\n---\n\n## Project Structure\n\n```\nhemlock/\n├── src/\n│   ├── frontend/         # Shared: lexer, parser, AST, modules\n│   ├── backends/\n│   │   ├── interpreter/  # hemlock: tree-walking interpreter\n│   │   └── compiler/     # hemlockc: C code generator\n│   ├── tools/\n│   │   ├── lsp/          # Language Server Protocol\n│   │   └── bundler/      # Bundle/package tools\n├── runtime/              # Compiled program runtime (libhemlock_runtime.a)\n├── stdlib/               # Standard library (40 modules)\n│   └── docs/             # Module documentation\n├── docs/                 # Full documentation\n│   ├── language-guide/   # Types, strings, arrays, etc.\n│   ├── reference/        # API references\n│   └── advanced/         # Async, FFI, signals, etc.\n├── tests/                # 625+ tests\n└── examples/             # Example programs\n```\n\n---\n\n## Code Style Guidelines\n\n### Constants and Magic Numbers\n\nWhen adding numeric constants to the C codebase, follow these guidelines:\n\n1. **Define constants in `include/hemlock_limits.h`** - This file is the central location for all compile-time and runtime limits, capacities, and named constants.\n\n2. **Use descriptive names with `HML_` prefix** - All constants should be prefixed with `HML_` for namespace clarity.\n\n3. **Avoid magic numbers** - Replace hard-coded numeric values with named constants. Examples:\n   - Type range limits: `HML_I8_MIN`, `HML_I8_MAX`, `HML_U32_MAX`\n   - Buffer capacities: `HML_INITIAL_ARRAY_CAPACITY`, `HML_INITIAL_LEXER_BUFFER_CAPACITY`\n   - Time conversions: `HML_NANOSECONDS_PER_SECOND`, `HML_MILLISECONDS_PER_SECOND`\n   - Hash seeds: `HML_DJB2_HASH_SEED`\n   - ASCII values: `HML_ASCII_CASE_OFFSET`, `HML_ASCII_PRINTABLE_START`\n\n4. **Include `hemlock_limits.h`** - Source files should include this header (often via `internal.h`) to access constants.\n\n5. **Document the purpose** - Add a comment explaining what each constant represents.\n\n---\n\n## What NOT to Do\n\n❌ Add implicit behavior (ASI, GC, auto-cleanup)\n❌ Hide complexity (magic optimizations, hidden refcounts)\n❌ Break existing semantics (semicolons, manual memory, mutable strings)\n❌ Lose precision in implicit conversions\n❌ Use magic numbers - define named constants in `hemlock_limits.h` instead\n\n---\n\n## Testing\n\n```bash\nmake test              # Run interpreter tests\nmake test-compiler     # Run compiler tests\nmake parity            # Run parity tests (both must match)\nmake test-all          # Run all test suites\n```\n\n**Important:** Tests may hang due to async/concurrency issues. Always use a timeout when running tests:\n```bash\ntimeout 60 make test   # 60 second timeout\ntimeout 120 make parity\n```\n\nTest categories: primitives, memory, strings, arrays, functions, objects, async, ffi, defer, signals, switch, bitwise, typed_arrays, modules, stdlib_*\n\n---\n\n## Compiler/Interpreter Architecture\n\nHemlock has two execution backends that share a common frontend:\n\n```\nSource (.hml)\n    ↓\n┌─────────────────────────────┐\n│  SHARED FRONTEND            │\n│  - Lexer (src/frontend/)    │\n│  - Parser (src/frontend/)   │\n│  - AST (src/frontend/)      │\n└─────────────────────────────┘\n    ↓                    ↓\n┌────────────┐    ┌────────────┐\n│ INTERPRETER│    │  COMPILER  │\n│ (hemlock)  │    │ (hemlockc) │\n│            │    │            │\n│ Tree-walk  │    │ Type check │\n│ evaluation │    │ AST → C    │\n│            │    │ gcc link   │\n└────────────┘    └────────────┘\n```\n\n### Compiler Type Checking\n\nThe compiler (`hemlockc`) includes compile-time type checking, **enabled by default**:\n\n```bash\nhemlockc program.hml -o program    # Type checks, then compiles\nhemlockc --check program.hml       # Type check only, don't compile\nhemlockc --no-type-check prog.hml  # Disable type checking\nhemlockc --strict-types prog.hml   # Warn on implicit 'any' types\n```\n\nThe type checker:\n- Validates type annotations at compile time\n- Treats untyped code as dynamic (`any` type) - always valid\n- Provides optimization hints for unboxing\n- Uses permissive numeric conversions (range validated at runtime)\n\n### Directory Structure\n\n```\nhemlock/\n├── src/\n│   ├── frontend/           # Shared: lexer, parser, AST, modules\n│   │   ├── lexer.c\n│   │   ├── parser/\n│   │   ├── ast.c\n│   │   └── module.c\n│   ├── backends/\n│   │   ├── interpreter/    # hemlock: tree-walking interpreter\n│   │   │   ├── main.c\n│   │   │   ├── runtime/\n│   │   │   └── builtins/\n│   │   └── compiler/       # hemlockc: C code generator\n│   │       ├── main.c\n│   │       └── codegen/\n│   ├── tools/\n│   │   ├── lsp/            # Language server\n│   │   └── bundler/        # Bundle/package tools\n├── runtime/                # libhemlock_runtime.a for compiled programs\n├── stdlib/                 # Shared standard library\n└── tests/\n    ├── parity/             # Tests that MUST pass both backends\n    ├── interpreter/        # Interpreter-specific tests\n    └── compiler/           # Compiler-specific tests\n```\n\n---\n\n## Parity-First Development\n\n**Both the interpreter and compiler must produce identical output for the same input.**\n\n### Development Policy\n\nWhen adding or modifying language features:\n\n1. **Design** - Define the AST/semantic change in the shared frontend\n2. **Implement interpreter** - Add tree-walking evaluation\n3. **Implement compiler** - Add C code generation\n4. **Add parity test** - Write test in `tests/parity/` with `.expected` file\n5. **Verify** - Run `make parity` before merging\n\n### Parity Test Structure\n\n```\ntests/parity/\n├── language/       # Core language features (control flow, closures, etc.)\n├── builtins/       # Built-in functions (print, typeof, memory, etc.)\n├── methods/        # String and array methods\n└── modules/        # Import/export, stdlib imports\n```\n\nEach test has two files:\n- `feature.hml` - The test program\n- `feature.expected` - Expected output (must match for both backends)\n\n### Parity Test Results\n\n| Status | Meaning |\n|--------|---------|\n| `✓ PASSED` | Both interpreter and compiler match expected output |\n| `◐ INTERP_ONLY` | Interpreter works, compiler fails (needs compiler fix) |\n| `◑ COMPILER_ONLY` | Compiler works, interpreter fails (rare) |\n| `✗ FAILED` | Both fail (test or implementation bug) |\n\n### What Requires Parity\n\n- All language constructs (if, while, for, switch, defer, try/catch)\n- All operators (arithmetic, bitwise, logical, comparison)\n- All built-in functions (print, typeof, alloc, etc.)\n- All string and array methods\n- Type coercion and promotion rules\n- Error messages for runtime errors\n\n### What May Differ\n\n- Performance characteristics\n- Memory layout details\n- Debug/stack trace format\n- Compilation errors (compiler may catch more at compile time)\n\n### Adding a Parity Test\n\n```bash\n# 1. Create test file\ncat > tests/parity/language/my_feature.hml << 'EOF'\n// Test description\nlet x = some_feature();\nprint(x);\nEOF\n\n# 2. Generate expected output from interpreter\n./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected\n\n# 3. Verify parity\nmake parity\n```\n\n---\n\n## Version\n\n**v1.8.0** - Current release with:\n- **Pattern matching** (`match` expressions) - Powerful destructuring and control flow:\n  - Literal, wildcard, and variable binding patterns\n  - OR patterns (`1 | 2 | 3`)\n  - Guard expressions (`n if n > 0`)\n  - Object destructuring (`{ x, y }`)\n  - Array destructuring with rest (`[first, ...rest]`)\n  - Type patterns (`n: i32`)\n  - Full parity between interpreter and compiler\n- **Compiler helper annotations** - 11 optimization annotations for GCC/Clang control:\n  - `@inline`, `@noinline` - function inlining control\n  - `@hot`, `@cold` - branch prediction hints\n  - `@pure`, `@const` - side-effect annotations\n  - `@flatten` - inline all calls within function\n  - `@optimize(level)` - per-function optimization level (\"0\", \"1\", \"2\", \"3\", \"s\", \"fast\")\n  - `@warn_unused` - warn on ignored return values\n  - `@section(name)` - custom ELF section placement (e.g., `@section(\".text.hot\")`)\n- **Expression-bodied functions** (`fn double(x): i32 => x * 2;`) - concise single-expression function syntax\n- **Single-line statements** - braceless `if`, `while`, `for` syntax (e.g., `if (x > 0) print(x);`)\n- **Type aliases** (`type Name = Type;`) - named shortcuts for complex types\n- **Function type annotations** (`fn(i32): i32`) - first-class function types\n- **Const parameters** (`fn(const x: array)`) - deep immutability for parameters\n- **Ref parameters** (`fn(ref x: i32)`) - pass-by-reference for direct caller mutation\n- **Method signatures in define** (`fn method(): Type`) - interface-like contracts (comma-delimited)\n- **Self type** in method signatures - refers to the defining type\n- **Loop keyword** (`loop { }`) - cleaner infinite loops, replaces `while (true)`\n- **Loop labels** (`outer: while`) - targeted break/continue for nested loops\n- **Object shorthand** (`{ name }`) - ES6-style shorthand property syntax\n- **Object spread** (`{ ...obj }`) - copy and merge object fields\n- **Compound duck types** (`A & B & C`) - intersection types for structural typing\n- **Named arguments** for function calls (`foo(name: \"value\", age: 30)`)\n- **Null coalescing operators** (`??`, `??=`, `?.`) for safe null handling\n- **Octal literals** (`0o777`, `0O123`)\n- **Numeric separators** (`1_000_000`, `0xFF_FF`, `0b1111_0000`)\n- **Block comments** (`/* ... */`)\n- **Hex escape sequences** in strings/runes (`\\x41` = 'A')\n- **Unicode escape sequences** in strings (`\\u{1F600}` = 😀)\n- **Float literals without leading zero** (`.5`, `.123`, `.5e2`)\n- **Compile-time type checking** in hemlockc (enabled by default)\n- **LSP integration** with type checking for real-time diagnostics\n- **Compound assignment operators** (`+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`)\n- **Increment/decrement operators** (`++x`, `x++`, `--x`, `x--`)\n- **Type precision fix**: i64/u64 + f32 → f64 to preserve precision\n- Unified type system with unboxing optimization hints\n- Full type system (i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object, enum, file, task, channel)\n- UTF-8 strings with 19 methods\n- Arrays with 18 methods including map/filter/reduce\n- Manual memory management with `talloc()` and `sizeof()`\n- Async/await with true pthread parallelism\n- Atomic operations for lock-free concurrent programming\n- 40 stdlib modules (+ arena, assert, semver, toml, retry, iter, random, shell)\n- FFI for C interop with `export extern fn` for reusable library wrappers\n- FFI struct support in compiler (pass C structs by value)\n- FFI pointer helpers (`ptr_null`, `ptr_read_*`, `ptr_write_*`)\n- defer, try/catch/finally/throw, panic\n- File I/O, signal handling, command execution\n- [hpm](https://github.com/hemlang/hpm) package manager with GitHub-based registry\n- Compiler backend (C code generation) with 100% interpreter parity\n- LSP server with go-to-definition and find-references\n- AST optimization pass and variable resolution for O(1) lookup\n- apply() builtin for dynamic function calls\n- Unbuffered channels and many-params support\n- 159 parity tests (100% pass rate)\n\n---\n\n## Philosophy\n\n> We give you the tools to be safe (`buffer`, type annotations, bounds checking) but we don't force you to use them (`ptr`, manual memory, unsafe operations).\n\n**If you're not sure whether a feature fits Hemlock, ask: \"Does this give the programmer more explicit control, or does it hide something?\"**\n\nIf it hides, it probably doesn't belong in Hemlock.\n"}, "Getting Started -> Installation": {"id": "getting-started-installation", "content": "# 安装指南\n\n本指南将帮助您在系统上构建和安装 Hemlock。\n\n## 快速安装（推荐）\n\n安装 Hemlock 最简单的方法是使用一行安装脚本：\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash\n```\n\n这将为您的平台（Linux 或 macOS，x86_64 或 arm64）下载并安装最新的预编译二进制文件。\n\n### 安装选项\n\n```bash\n# 安装到自定义前缀（默认：~/.local）\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local\n\n# 安装特定版本\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0\n\n# 安装并自动更新 shell PATH\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path\n```\n\n安装后，验证是否正常工作：\n\n```bash\nhemlock --version\n```\n\n---\n\n## 从源代码构建\n\n如果您更喜欢从源代码构建，或者预编译的二进制文件不适用于您的系统，请按照以下说明操作。\n\n## 前置条件\n\n### 必需的依赖项\n\nHemlock 构建需要以下依赖项：\n\n- **C 编译器**：GCC 或 Clang（C11 标准）\n- **Make**：GNU Make\n- **libffi**：外部函数接口库（用于 FFI 支持）\n- **OpenSSL**：加密库（用于哈希函数：md5、sha1、sha256）\n- **libwebsockets**：WebSocket 和 HTTP 客户端/服务器支持\n- **zlib**：压缩库\n\n### 安装依赖项\n\n**macOS：**\n```bash\n# 如果尚未安装，请先安装 Homebrew\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# 安装 Xcode 命令行工具\nxcode-select --install\n\n# 通过 Homebrew 安装依赖项\nbrew install libffi openssl@3 libwebsockets\n```\n\n**macOS 用户注意**：Makefile 会自动检测 Homebrew 安装并设置正确的 include/library 路径。Hemlock 支持 Intel（x86_64）和 Apple Silicon（arm64）架构。\n\n**Ubuntu/Debian：**\n```bash\nsudo apt-get update\nsudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev\n```\n\n**Fedora/RHEL：**\n```bash\nsudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel\n```\n\n**Arch Linux：**\n```bash\nsudo pacman -S base-devel libffi openssl libwebsockets zlib\n```\n\n## 从源代码构建\n\n### 1. 克隆仓库\n\n```bash\ngit clone https://github.com/hemlang/hemlock.git\ncd hemlock\n```\n\n### 2. 构建 Hemlock\n\n```bash\nmake\n```\n\n这将编译 Hemlock 解释器并将可执行文件放在当前目录中。\n\n### 3. 验证安装\n\n```bash\n./hemlock --version\n```\n\n您应该看到 Hemlock 版本信息。\n\n### 4. 测试构建\n\n运行测试套件以确保一切正常工作：\n\n```bash\nmake test\n```\n\n所有测试都应该通过。如果您看到任何失败，请将其作为问题报告。\n\n## 系统级安装（可选）\n\n要在系统级安装 Hemlock（例如，安装到 `/usr/local/bin`）：\n\n```bash\nsudo make install\n```\n\n这允许您从任何位置运行 `hemlock` 而无需指定完整路径。\n\n## 运行 Hemlock\n\n### 交互式 REPL\n\n启动读取-求值-打印循环（REPL）：\n\n```bash\n./hemlock\n```\n\n您将看到一个提示符，可以在其中输入 Hemlock 代码：\n\n```\nHemlock REPL\n> print(\"Hello, World!\");\nHello, World!\n> let x = 42;\n> print(x * 2);\n84\n>\n```\n\n使用 `Ctrl+D` 或 `Ctrl+C` 退出 REPL。\n\n### 运行程序\n\n执行 Hemlock 脚本：\n\n```bash\n./hemlock program.hml\n```\n\n带有命令行参数：\n\n```bash\n./hemlock program.hml arg1 arg2 \"带空格的参数\"\n```\n\n## 目录结构\n\n构建后，您的 Hemlock 目录将如下所示：\n\n```\nhemlock/\n├── hemlock           # 编译的解释器可执行文件\n├── src/              # 源代码\n├── include/          # 头文件\n├── tests/            # 测试套件\n├── examples/         # 示例程序\n├── docs/             # 文档\n├── stdlib/           # 标准库\n├── Makefile          # 构建配置\n└── README.md         # 项目说明\n```\n\n## 构建选项\n\n### 调试构建\n\n使用调试符号和无优化进行构建：\n\n```bash\nmake debug\n```\n\n### 清理构建\n\n删除所有编译的文件：\n\n```bash\nmake clean\n```\n\n从头开始重新构建：\n\n```bash\nmake clean && make\n```\n\n## 故障排除\n\n### macOS：找不到库错误\n\n如果您收到关于缺少库的错误（`-lcrypto`、`-lffi` 等）：\n\n1. 确保已安装 Homebrew 依赖项：\n   ```bash\n   brew install libffi openssl@3 libwebsockets\n   ```\n\n2. 验证 Homebrew 路径：\n   ```bash\n   brew --prefix libffi\n   brew --prefix openssl\n   ```\n\n3. Makefile 应该会自动检测这些路径。如果没有，请检查 `brew` 是否在您的 PATH 中：\n   ```bash\n   which brew\n   ```\n\n### macOS：BSD 类型错误（`u_int`、`u_char` 未找到）\n\n如果您看到关于未知类型名称（如 `u_int` 或 `u_char`）的错误：\n\n1. 这在 v1.0.0+ 中已通过使用 `_DARWIN_C_SOURCE` 而不是 `_POSIX_C_SOURCE` 修复\n2. 确保您拥有最新版本的代码\n3. 清理并重新构建：\n   ```bash\n   make clean && make\n   ```\n\n### Linux：找不到 libffi\n\n如果您收到关于缺少 `ffi.h` 或 `-lffi` 的错误：\n\n1. 确保已安装 `libffi-dev`（请参阅上面的依赖项）\n2. 检查 `pkg-config` 是否能找到它：\n   ```bash\n   pkg-config --cflags --libs libffi\n   ```\n3. 如果未找到，您可能需要设置 `PKG_CONFIG_PATH`：\n   ```bash\n   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH\n   ```\n\n### 编译错误\n\n如果遇到编译错误：\n\n1. 确保您有兼容 C11 的编译器\n2. 在 macOS 上，尝试使用 Clang（默认）：\n   ```bash\n   make CC=clang\n   ```\n3. 在 Linux 上，尝试使用 GCC：\n   ```bash\n   make CC=gcc\n   ```\n4. 检查是否已安装所有依赖项\n5. 尝试从头开始重新构建：\n   ```bash\n   make clean && make\n   ```\n\n### 测试失败\n\n如果测试失败：\n\n1. 检查您是否拥有最新版本的代码\n2. 尝试从头开始重新构建：\n   ```bash\n   make clean && make test\n   ```\n3. 在 macOS 上，确保您拥有最新的 Xcode 命令行工具：\n   ```bash\n   xcode-select --install\n   ```\n4. 在 GitHub 上报告问题，包括：\n   - 您的平台（macOS 版本 / Linux 发行版）\n   - 架构（x86_64 / arm64）\n   - 测试输出\n   - `make -v` 和 `gcc --version`（或 `clang --version`）的输出\n\n## 下一步\n\n- [快速入门指南](#getting-started-quick-start) - 编写您的第一个 Hemlock 程序\n- [教程](#getting-started-tutorial) - 逐步学习 Hemlock\n- [语言指南](#language-guide-syntax) - 探索 Hemlock 特性\n"}, "Getting Started -> Learning Paths": {"id": "getting-started-learning-paths", "content": "# 学习路径\n\n不同的目标需要不同的知识。选择与您想要构建的内容相匹配的路径。\n\n---\n\n## 路径 1：快速脚本和自动化\n\n**目标：** 编写脚本来自动化任务、处理文件并完成工作。\n\n**达到生产力的时间：** 很快 - 您可以立即开始编写有用的脚本。\n\n### 您将学到的内容\n\n1. **[快速入门](#getting-started-quick-start)** - 您的第一个程序，基本语法\n2. **[字符串](#language-guide-strings)** - 文本处理、分割、搜索\n3. **[数组](#language-guide-arrays)** - 列表、过滤、转换数据\n4. **[文件 I/O](#advanced-file-io)** - 读写文件\n5. **[命令行参数](#advanced-command-line-args)** - 获取用户输入\n\n### 暂时跳过\n\n- 内存管理（脚本自动处理）\n- 异步/并发（对于简单脚本来说太复杂）\n- FFI（只有在需要 C 互操作时才需要）\n\n### 示例项目：文件重命名器\n\n```hemlock\nimport { list_dir, rename } from \"@stdlib/fs\";\n\n// 将所有 .txt 文件重命名为 .md\nlet files = list_dir(\".\");\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let new_name = file.replace(\".txt\", \".md\");\n        rename(file, new_name);\n        print(`已重命名：${file} -> ${new_name}`);\n    }\n}\n```\n\n---\n\n## 路径 2：数据处理与分析\n\n**目标：** 解析数据、转换数据、生成报告。\n\n**达到生产力的时间：** 很快 - Hemlock 的字符串和数组方法使这变得很容易。\n\n### 您将学到的内容\n\n1. **[快速入门](#getting-started-quick-start)** - 基础知识\n2. **[字符串](#language-guide-strings)** - 解析、分割、格式化\n3. **[数组](#language-guide-arrays)** - map、filter、reduce 用于数据转换\n4. **[对象](#language-guide-objects)** - 结构化数据\n5. **标准库：**\n   - **[@stdlib/json](#stdlib-json)** - JSON 解析\n   - **[@stdlib/csv](#stdlib-csv)** - CSV 文件\n   - **[@stdlib/fs](#stdlib-fs)** - 文件操作\n\n### 示例项目：CSV 分析器\n\n```hemlock\nimport { read_file } from \"@stdlib/fs\";\nimport { parse } from \"@stdlib/csv\";\n\nlet data = parse(read_file(\"sales.csv\"));\n\n// 计算总销售额\nlet total = 0;\nfor (row in data) {\n    total = total + f64(row.amount);\n}\n\nprint(`总销售额：$${total}`);\n\n// 找出最高销售额\nlet top = data[0];\nfor (row in data) {\n    if (f64(row.amount) > f64(top.amount)) {\n        top = row;\n    }\n}\n\nprint(`最高销售：${top.product} - $${top.amount}`);\n```\n\n---\n\n## 路径 3：Web 和网络编程\n\n**目标：** 构建 HTTP 客户端、使用 API、创建服务器。\n\n**达到生产力的时间：** 中等 - 需要理解异步基础知识。\n\n### 您将学到的内容\n\n1. **[快速入门](#getting-started-quick-start)** - 基础知识\n2. **[函数](#language-guide-functions)** - 回调和闭包\n3. **[错误处理](#language-guide-error-handling)** - 网络错误的 try/catch\n4. **[异步与并发](#advanced-async-concurrency)** - spawn、await、channels\n5. **标准库：**\n   - **[@stdlib/http](#stdlib-http)** - HTTP 请求\n   - **[@stdlib/json](#stdlib-json)** - API 的 JSON\n   - **[@stdlib/net](#stdlib-net)** - TCP/UDP 套接字\n   - **[@stdlib/url](#stdlib-url)** - URL 解析\n\n### 示例项目：API 客户端\n\n```hemlock\nimport { http_get, http_post } from \"@stdlib/http\";\nimport { parse, stringify } from \"@stdlib/json\";\n\n// GET 请求\nlet response = http_get(\"https://api.example.com/users\");\nlet users = parse(response.body);\n\nfor (user in users) {\n    print(`${user.name}：${user.email}`);\n}\n\n// POST 请求\nlet new_user = { name: \"Alice\", email: \"alice@example.com\" };\nlet result = http_post(\"https://api.example.com/users\", {\n    body: stringify(new_user),\n    headers: { \"Content-Type\": \"application/json\" }\n});\n\nprint(`创建的用户 ID：${parse(result.body).id}`);\n```\n\n---\n\n## 路径 4：系统编程\n\n**目标：** 编写底层代码、操作内存、与 C 库交互。\n\n**达到生产力的时间：** 较长 - 需要理解内存管理。\n\n### 您将学到的内容\n\n1. **[快速入门](#getting-started-quick-start)** - 基础知识\n2. **[类型](#language-guide-types)** - 理解 i32、u8、ptr 等\n3. **[内存管理](#language-guide-memory)** - alloc、free、缓冲区\n4. **[FFI](#advanced-ffi)** - 调用 C 函数\n5. **[信号](#advanced-signals)** - 信号处理\n\n### 关键概念\n\n**内存安全清单：**\n- [ ] 每个 `alloc()` 都有对应的 `free()`\n- [ ] 除非需要原始 `ptr`，否则使用 `buffer()`\n- [ ] 释放后将指针设置为 `null`\n- [ ] 使用 `try/finally` 保证清理\n\n**FFI 类型映射：**\n| Hemlock | C |\n|---------|---|\n| `i8` | `char` / `int8_t` |\n| `i32` | `int` |\n| `i64` | `long`（64位）|\n| `u8` | `unsigned char` |\n| `f64` | `double` |\n| `ptr` | `void*` |\n\n### 示例项目：自定义内存池\n\n```hemlock\n// 简单的 bump allocator\nlet pool_size = 1024 * 1024;  // 1MB\nlet pool = alloc(pool_size);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > pool_size) {\n        throw \"内存池已耗尽\";\n    }\n    let p = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return p;\n}\n\nfn pool_reset() {\n    pool_offset = 0;\n}\n\nfn pool_destroy() {\n    free(pool);\n}\n\n// 使用它\nlet a = pool_alloc(100);\nlet b = pool_alloc(200);\nmemset(a, 0, 100);\nmemset(b, 0, 200);\n\npool_reset();  // 重用所有内存\npool_destroy();  // 清理\n```\n\n---\n\n## 路径 5：并行与并发程序\n\n**目标：** 在多个 CPU 核心上运行代码，构建响应式应用程序。\n\n**达到生产力的时间：** 中等 - 异步语法很简单，但并行思维需要练习。\n\n### 您将学到的内容\n\n1. **[快速入门](#getting-started-quick-start)** - 基础知识\n2. **[函数](#language-guide-functions)** - 闭包（对异步很重要）\n3. **[异步与并发](#advanced-async-concurrency)** - 完整深入讲解\n4. **[原子操作](#advanced-atomics)** - 无锁编程\n\n### 关键概念\n\n**Hemlock 的异步模型：**\n- `async fn` - 定义可以在另一个线程上运行的函数\n- `spawn(fn, args...)` - 开始运行它，返回任务句柄\n- `join(task)` 或 `await task` - 等待它完成，获取结果\n- `channel(size)` - 创建用于在任务之间发送数据的队列\n\n**重要：** 任务接收值的*副本*。如果您传递一个指针，您需要负责确保内存在任务完成之前保持有效。\n\n### 示例项目：并行文件处理器\n\n```hemlock\nimport { list_dir, read_file } from \"@stdlib/fs\";\n\nasync fn process_file(path: string): i32 {\n    let content = read_file(path);\n    let lines = content.split(\"\\n\");\n    return lines.length;\n}\n\n// 并行处理所有文件\nlet files = list_dir(\"data/\");\nlet tasks = [];\n\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let task = spawn(process_file, \"data/\" + file);\n        tasks.push({ name: file, task: task });\n    }\n}\n\n// 收集结果\nlet total_lines = 0;\nfor (item in tasks) {\n    let count = join(item.task);\n    print(`${item.name}：${count} 行`);\n    total_lines = total_lines + count;\n}\n\nprint(`总计：${total_lines} 行`);\n```\n\n---\n\n## 任何路径都应该首先学习的内容\n\n无论您的目标是什么，从这些基础知识开始：\n\n### 第 1 周：核心基础\n1. **[快速入门](#getting-started-quick-start)** - 编写并运行您的第一个程序\n2. **[语法](#language-guide-syntax)** - 变量、运算符、控制流\n3. **[函数](#language-guide-functions)** - 定义和调用函数\n\n### 第 2 周：数据处理\n4. **[字符串](#language-guide-strings)** - 文本操作\n5. **[数组](#language-guide-arrays)** - 集合和迭代\n6. **[对象](#language-guide-objects)** - 结构化数据\n\n### 第 3 周：健壮性\n7. **[错误处理](#language-guide-error-handling)** - try/catch/throw\n8. **[模块](#language-guide-modules)** - 导入/导出，使用标准库\n\n### 然后：选择您上面的路径\n\n---\n\n## 速查表：来自其他语言\n\n### 来自 Python\n\n| Python | Hemlock | 注意事项 |\n|--------|---------|----------|\n| `x = 42` | `let x = 42;` | 需要分号 |\n| `def fn():` | `fn name() { }` | 需要花括号 |\n| `if x:` | `if (x) { }` | 需要括号和花括号 |\n| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | C 风格的 for 循环 |\n| `for item in list:` | `for (item in array) { }` | for-in 相同 |\n| `list.append(x)` | `array.push(x);` | 方法名不同 |\n| `len(s)` | `s.length` 或 `len(s)` | 两者都可以 |\n| 自动内存管理 | `ptr` 需要手动管理 | 大多数类型自动清理 |\n\n### 来自 JavaScript\n\n| JavaScript | Hemlock | 注意事项 |\n|------------|---------|----------|\n| `let x = 42` | `let x = 42;` | 相同（需要分号）|\n| `const x = 42` | `let x = 42;` | 没有 const 关键字 |\n| `function fn()` | `fn name() { }` | 不同的关键字 |\n| `() => x` | `fn() { return x; }` | 没有箭头函数 |\n| `async/await` | `async/await` | 相同语法 |\n| `Promise` | `spawn/join` | 不同的模型 |\n| 自动 GC | `ptr` 需要手动管理 | 大多数类型自动清理 |\n\n### 来自 C/C++\n\n| C | Hemlock | 注意事项 |\n|---|---------|----------|\n| `int x = 42;` | `let x: i32 = 42;` | 类型在冒号后 |\n| `malloc(n)` | `alloc(n)` | 相同概念 |\n| `free(p)` | `free(p)` | 相同 |\n| `char* s = \"hi\"` | `let s = \"hi\";` | 字符串是托管的 |\n| `#include` | `import { } from` | 模块导入 |\n| 全部手动管理 | 大多数类型自动 | 只有 `ptr` 需要手动 |\n\n---\n\n## 获取帮助\n\n- **[术语表](../glossary.md)** - 编程术语定义\n- **[示例](../../examples/)** - 完整的工作程序\n- **[测试](../../tests/)** - 查看功能的使用方式\n- **GitHub Issues** - 提问、报告错误\n\n---\n\n## 难度级别\n\n在整个文档中，您会看到这些标记：\n\n| 标记 | 含义 |\n|------|------|\n| **初学者** | 不需要先前的编程经验 |\n| **中级** | 假设具有基本的编程知识 |\n| **高级** | 需要理解系统概念 |\n\n如果标记为\"初学者\"的内容让您困惑，请查看[术语表](../glossary.md)了解术语定义。\n"}, "Getting Started -> Quick Start": {"id": "getting-started-quick-start", "content": "# 快速入门\n\n几分钟内开始使用 Hemlock！\n\n## 您的第一个程序\n\n创建一个名为 `hello.hml` 的文件：\n\n```hemlock\nprint(\"Hello, Hemlock!\");\n```\n\n使用解释器运行：\n\n```bash\n./hemlock hello.hml\n```\n\n或编译为原生可执行文件：\n\n```bash\n./hemlockc hello.hml -o hello\n./hello\n```\n\n输出：\n```\nHello, Hemlock!\n```\n\n### 解释器 vs 编译器\n\nHemlock 提供两种运行程序的方式：\n\n| 工具 | 用例 | 类型检查 |\n|------|------|----------|\n| `hemlock` | 快速脚本、REPL、开发 | 仅运行时 |\n| `hemlockc` | 生产二进制文件、更好的性能 | 编译时（默认）|\n\n编译器（`hemlockc`）在生成可执行文件之前对代码进行类型检查，可以提前捕获错误。\n\n## 基本语法\n\n### 变量\n\n```hemlock\n// 使用 'let' 声明变量\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\n// 类型注解是可选的\nlet count: i32 = 100;\nlet ratio: f64 = 0.618;\n```\n\n**重要**：分号在 Hemlock 中是**必需的**！\n\n### 类型\n\nHemlock 拥有丰富的类型系统：\n\n```hemlock\n// 整数\nlet small: i8 = 127;          // 8位有符号\nlet byte: u8 = 255;           // 8位无符号\nlet num: i32 = 2147483647;    // 32位有符号（默认）\nlet big: i64 = 9223372036854775807;  // 64位有符号\n\n// 浮点数\nlet f: f32 = 3.14;            // 32位浮点\nlet d: f64 = 2.71828;         // 64位浮点（默认）\n\n// 字符串和字符\nlet text: string = \"Hello\";   // UTF-8 字符串\nlet emoji: rune = '🚀';       // Unicode 码点\n\n// 布尔值和空值\nlet flag: bool = true;\nlet empty = null;\n```\n\n### 控制流\n\n```hemlock\n// if 语句\nif (x > 0) {\n    print(\"正数\");\n} else if (x < 0) {\n    print(\"负数\");\n} else {\n    print(\"零\");\n}\n\n// while 循环\nlet i = 0;\nwhile (i < 5) {\n    print(i);\n    i = i + 1;\n}\n\n// for 循环\nfor (let j = 0; j < 10; j = j + 1) {\n    print(j);\n}\n```\n\n### 函数\n\n```hemlock\n// 命名函数\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nlet result = add(5, 3);  // 8\n\n// 匿名函数\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(multiply(4, 7));  // 28\n```\n\n## 字符串操作\n\nHemlock 中的字符串是**可变的**和 **UTF-8** 编码的：\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';              // 现在是 \"Hello\"\nprint(s);\n\n// 字符串方法\nlet upper = s.to_upper();     // \"HELLO\"\nlet words = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\nlet sub = s.substr(1, 3);     // \"ell\"\n\n// 连接\nlet greeting = \"Hello\" + \", \" + \"World!\";\nprint(greeting);  // \"Hello, World!\"\n```\n\n## 数组\n\n支持混合类型的动态数组：\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// 数组方法\nnumbers.push(6);        // [1, 2, 3, 4, 5, 6]\nlet last = numbers.pop();  // 6\nlet slice = numbers.slice(1, 4);  // [2, 3, 4]\n\n// 允许混合类型\nlet mixed = [1, \"two\", true, null];\n```\n\n## 对象\n\nJavaScript 风格的对象：\n\n```hemlock\n// 对象字面量\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nperson.age = 31;     // 修改字段\n\n// 使用 'self' 的方法\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## 内存管理\n\nHemlock 使用**手动内存管理**：\n\n```hemlock\n// 安全缓冲区（推荐）\nlet buf = buffer(64);   // 分配 64 字节\nbuf[0] = 65;            // 将第一个字节设置为 'A'\nprint(buf[0]);          // 65\nfree(buf);              // 释放内存\n\n// 原始指针（高级）\nlet ptr = alloc(100);\nmemset(ptr, 0, 100);    // 用零填充\nfree(ptr);\n```\n\n**重要**：您必须 `free()` 您 `alloc()` 的内存！\n\n## 错误处理\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"除零错误\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"错误：\" + e);\n} finally {\n    print(\"完成\");\n}\n```\n\n## 命令行参数\n\n通过 `args` 数组访问程序参数：\n\n```hemlock\n// script.hml\nprint(\"脚本：\", args[0]);\nprint(`参数数量：${args.length - 1}`);\n\nlet i = 1;\nwhile (i < args.length) {\n    print(`  参数 ${i}：${args[i]}`);\n    i = i + 1;\n}\n```\n\n运行：\n```bash\n./hemlock script.hml hello world\n```\n\n输出：\n```\n脚本：script.hml\n参数数量：2\n  参数 1：hello\n  参数 2：world\n```\n\n## 文件 I/O\n\n```hemlock\n// 写入文件\nlet f = open(\"data.txt\", \"w\");\nf.write(\"Hello, File!\");\nf.close();\n\n// 读取文件\nlet f2 = open(\"data.txt\", \"r\");\nlet content = f2.read();\nprint(content);  // \"Hello, File!\"\nf2.close();\n```\n\n## 接下来学什么？\n\n现在您已经了解了基础知识，可以探索更多内容：\n\n- [教程](#getting-started-tutorial) - 全面的分步指南\n- [语言指南](#language-guide-syntax) - 深入了解所有特性\n- [示例](../../examples/) - 真实世界的示例程序\n- [API 参考](#reference-builtins) - 完整的 API 文档\n\n## 常见陷阱\n\n### 忘记分号\n\n```hemlock\n// ❌ 错误：缺少分号\nlet x = 42\nlet y = 10\n\n// ✅ 正确\nlet x = 42;\nlet y = 10;\n```\n\n### 忘记释放内存\n\n```hemlock\n// ❌ 内存泄漏\nlet buf = buffer(100);\n// ... 使用 buf ...\n// 忘记调用 free(buf)！\n\n// ✅ 正确\nlet buf = buffer(100);\n// ... 使用 buf ...\nfree(buf);\n```\n\n### 花括号是必需的\n\n```hemlock\n// ❌ 错误：缺少花括号\nif (x > 0)\n    print(\"正数\");\n\n// ✅ 正确\nif (x > 0) {\n    print(\"正数\");\n}\n```\n\n## 获取帮助\n\n- 阅读[完整文档](../README.md)\n- 查看[示例目录](../../examples/)\n- 查看[测试文件](../../tests/)了解使用模式\n- 在 GitHub 上报告问题\n"}, "Getting Started -> Tutorial": {"id": "getting-started-tutorial", "content": "# Hemlock 教程\n\n学习 Hemlock 的全面分步指南。\n\n## 目录\n\n1. [Hello World](#hello-world)\n2. [变量和类型](#变量和类型)\n3. [算术和运算](#算术和运算)\n4. [控制流](#控制流)\n5. [函数](#函数)\n6. [字符串和字符](#字符串和字符)\n7. [数组](#数组)\n8. [对象](#对象)\n9. [内存管理](#内存管理)\n10. [错误处理](#错误处理)\n11. [文件 I/O](#文件-io)\n12. [综合示例](#综合示例)\n\n## Hello World\n\n让我们从传统的第一个程序开始：\n\n```hemlock\nprint(\"Hello, World!\");\n```\n\n将其保存为 `hello.hml` 并运行：\n\n```bash\n./hemlock hello.hml\n```\n\n**要点：**\n- `print()` 是一个内置函数，输出到标准输出\n- 字符串用双引号括起来\n- 分号是**必需的**\n\n## 变量和类型\n\n### 声明变量\n\n```hemlock\n// 基本变量声明\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\nprint(x);      // 42\nprint(name);   // Alice\nprint(pi);     // 3.14159\n```\n\n### 类型注解\n\n虽然类型默认是推断的，但您可以显式指定：\n\n```hemlock\nlet age: i32 = 30;\nlet height: f64 = 5.9;\nlet initial: rune = 'A';\nlet active: bool = true;\n```\n\n### 类型推断\n\nHemlock 根据值推断类型：\n\n```hemlock\nlet small = 42;              // i32（适合 32 位）\nlet large = 5000000000;      // i64（对于 i32 太大）\nlet decimal = 3.14;          // f64（浮点数默认值）\nlet text = \"hello\";          // string\nlet flag = true;             // bool\n```\n\n### 类型检查\n\n```hemlock\n// 使用 typeof() 检查类型\nprint(typeof(42));        // \"i32\"\nprint(typeof(3.14));      // \"f64\"\nprint(typeof(\"hello\"));   // \"string\"\nprint(typeof(true));      // \"bool\"\nprint(typeof(null));      // \"null\"\n```\n\n## 算术和运算\n\n### 基本算术\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13\nprint(a - b);   // 7\nprint(a * b);   // 30\nprint(a / b);   // 3（整数除法）\nprint(a == b);  // false\nprint(a > b);   // true\n```\n\n### 类型提升\n\n混合类型时，Hemlock 会提升到更大/更精确的类型：\n\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result 是 f64（10.0 + 3.5 = 13.5）\n\nprint(result);       // 13.5\nprint(typeof(result)); // \"f64\"\n```\n\n### 位运算\n\n```hemlock\nlet a = 12;  // 二进制 1100\nlet b = 10;  // 二进制 1010\n\nprint(a & b);   // 8  (AND)\nprint(a | b);   // 14 (OR)\nprint(a ^ b);   // 6  (XOR)\nprint(a << 1);  // 24（左移）\nprint(a >> 1);  // 6 （右移）\nprint(~a);      // -13 (NOT)\n```\n\n## 控制流\n\n### If 语句\n\n```hemlock\nlet x = 10;\n\nif (x > 0) {\n    print(\"正数\");\n} else if (x < 0) {\n    print(\"负数\");\n} else {\n    print(\"零\");\n}\n```\n\n**注意：** 花括号**始终是必需的**，即使是单个语句也是如此。\n\n### While 循环\n\n```hemlock\nlet count = 0;\nwhile (count < 5) {\n    print(`计数：${count}`);\n    count = count + 1;\n}\n```\n\n### For 循环\n\n```hemlock\n// C 风格的 for 循环\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n\n// for-in 循环（数组）\nlet items = [10, 20, 30, 40];\nfor (let item in items) {\n    print(`项目：${item}`);\n}\n```\n\n### Switch 语句\n\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n        print(\"星期一\");\n        break;\n    case 2:\n        print(\"星期二\");\n        break;\n    case 3:\n        print(\"星期三\");\n        break;\n    default:\n        print(\"其他日子\");\n        break;\n}\n```\n\n### Break 和 Continue\n\n```hemlock\n// Break：提前退出循环\nlet i = 0;\nwhile (i < 10) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// 输出：0, 1, 2, 3, 4\n\n// Continue：跳到下一次迭代\nfor (let j = 0; j < 5; j = j + 1) {\n    if (j == 2) {\n        continue;\n    }\n    print(j);\n}\n// 输出：0, 1, 3, 4\n```\n\n## 函数\n\n### 命名函数\n\n```hemlock\nfn greet(name: string): string {\n    return \"你好，\" + name + \"！\";\n}\n\nlet message = greet(\"Alice\");\nprint(message);  // \"你好，Alice！\"\n```\n\n### 匿名函数\n\n```hemlock\nlet add = fn(a, b) {\n    return a + b;\n};\n\nprint(add(5, 3));  // 8\n```\n\n### 递归\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### 闭包\n\n函数捕获其环境：\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n### 高阶函数\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 21);\nprint(result);  // 42\n```\n\n## 字符串和字符\n\n### 字符串基础\n\n字符串是**可变的**和 **UTF-8** 编码的：\n\n```hemlock\nlet s = \"hello\";\nprint(s.length);      // 5（字符数）\nprint(s.byte_length); // 5（字节数）\n\n// 修改\ns[0] = 'H';\nprint(s);  // \"Hello\"\n```\n\n### 字符串方法\n\n```hemlock\nlet text = \"  Hello, World!  \";\n\n// 大小写转换\nprint(text.to_upper());  // \"  HELLO, WORLD!  \"\nprint(text.to_lower());  // \"  hello, world!  \"\n\n// 去除空白\nprint(text.trim());      // \"Hello, World!\"\n\n// 子字符串提取\nlet hello = text.substr(2, 5);  // \"Hello\"\nlet world = text.slice(9, 14);  // \"World\"\n\n// 搜索\nlet pos = text.find(\"World\");   // 9\nlet has = text.contains(\"o\");   // true\n\n// 分割\nlet parts = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\n\n// 替换\nlet s = \"hello world\".replace(\"world\", \"there\");\nprint(s);  // \"hello there\"\n```\n\n### 字符（Unicode 码点）\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '🚀';\n\nprint(ch);      // 'A'\nprint(emoji);   // U+1F680\n\n// 字符 + 字符串连接\nlet msg = '>' + \" 重要\";\nprint(msg);  // \"> 重要\"\n\n// 字符和整数之间的转换\nlet code: i32 = ch;     // 65（ASCII 码）\nlet r: rune = 128640;   // U+1F680（🚀）\n```\n\n## 数组\n\n### 数组基础\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// 修改元素\nnumbers[2] = 99;\nprint(numbers[2]);  // 99\n```\n\n### 数组方法\n\n```hemlock\nlet arr = [10, 20, 30];\n\n// 在末尾添加/删除\narr.push(40);           // [10, 20, 30, 40]\nlet last = arr.pop();   // 40，arr 现在是 [10, 20, 30]\n\n// 在开头添加/删除\narr.unshift(5);         // [5, 10, 20, 30]\nlet first = arr.shift(); // 5，arr 现在是 [10, 20, 30]\n\n// 在索引处插入/删除\narr.insert(1, 15);      // [10, 15, 20, 30]\nlet removed = arr.remove(2);  // 20\n\n// 搜索\nlet index = arr.find(15);     // 1\nlet has = arr.contains(10);   // true\n\n// 切片\nlet slice = arr.slice(0, 2);  // [10, 15]\n\n// 连接为字符串\nlet text = arr.join(\", \");    // \"10, 15, 30\"\n```\n\n### 迭代\n\n```hemlock\nlet items = [\"苹果\", \"香蕉\", \"樱桃\"];\n\n// for-in 循环\nfor (let item in items) {\n    print(item);\n}\n\n// 手动迭代\nlet i = 0;\nwhile (i < items.length) {\n    print(items[i]);\n    i = i + 1;\n}\n```\n\n## 对象\n\n### 对象字面量\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nprint(person.age);   // 30\n\n// 添加/修改字段\nperson.email = \"alice@example.com\";\nperson.age = 31;\n```\n\n### 方法和 `self`\n\n```hemlock\nlet calculator = {\n    value: 0,\n    add: fn(x) {\n        self.value = self.value + x;\n    },\n    get: fn() {\n        return self.value;\n    }\n};\n\ncalculator.add(10);\ncalculator.add(5);\nprint(calculator.get());  // 15\n```\n\n### 类型定义（鸭子类型）\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,  // 带默认值的可选字段\n}\n\nlet p = { name: \"Bob\", age: 25 };\nlet typed: Person = p;  // 鸭子类型验证结构\n\nprint(typeof(typed));   // \"Person\"\nprint(typed.active);    // true（应用默认值）\n```\n\n### JSON 序列化\n\n```hemlock\nlet obj = { x: 10, y: 20, name: \"test\" };\n\n// 对象到 JSON\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// JSON 到对象\nlet restored = json.deserialize();\nprint(restored.name);  // \"test\"\n```\n\n## 内存管理\n\n### 安全缓冲区（推荐）\n\n```hemlock\n// 分配缓冲区\nlet buf = buffer(10);\nprint(buf.length);    // 10\nprint(buf.capacity);  // 10\n\n// 设置值（边界检查）\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// 访问值\nprint(buf[0]);  // 65\n\n// 完成后必须释放\nfree(buf);\n```\n\n### 原始指针（高级）\n\n```hemlock\n// 分配原始内存\nlet ptr = alloc(100);\n\n// 用零填充\nmemset(ptr, 0, 100);\n\n// 复制数据\nlet src = alloc(50);\nmemcpy(ptr, src, 50);\n\n// 释放两者\nfree(src);\nfree(ptr);\n```\n\n### 内存函数\n\n```hemlock\n// 重新分配\nlet p = alloc(64);\np = realloc(p, 128);  // 调整为 128 字节\nfree(p);\n\n// 类型化分配（未来功能）\n// let arr = talloc(i32, 100);  // 100 个 i32 的数组\n```\n\n## 错误处理\n\n### Try/Catch\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"除零错误\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"错误：\" + e);\n}\n// 输出：错误：除零错误\n```\n\n### Finally 块\n\n```hemlock\nlet file = null;\n\ntry {\n    file = open(\"data.txt\", \"r\");\n    let content = file.read();\n    print(content);\n} catch (e) {\n    print(\"错误：\" + e);\n} finally {\n    // 始终运行\n    if (file != null) {\n        file.close();\n    }\n}\n```\n\n### 抛出对象\n\n```hemlock\ntry {\n    throw { code: 404, message: \"未找到\" };\n} catch (e) {\n    print(`错误 ${e.code}：${e.message}`);\n}\n// 输出：错误 404：未找到\n```\n\n### Panic（不可恢复的错误）\n\n```hemlock\nfn validate(x) {\n    if (x < 0) {\n        panic(\"x 必须是非负数\");\n    }\n    return x * 2;\n}\n\nvalidate(-5);  // 程序退出并显示：panic: x 必须是非负数\n```\n\n## 文件 I/O\n\n### 读取文件\n\n```hemlock\n// 读取整个文件\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n\n// 读取指定字节数\nlet f2 = open(\"data.txt\", \"r\");\nlet chunk = f2.read(100);  // 读取 100 字节\nf2.close();\n```\n\n### 写入文件\n\n```hemlock\n// 写入文本\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Hello, File!\\n\");\nf.write(\"第二行\\n\");\nf.close();\n\n// 追加到文件\nlet f2 = open(\"output.txt\", \"a\");\nf2.write(\"追加的行\\n\");\nf2.close();\n```\n\n### 二进制 I/O\n\n```hemlock\n// 写入二进制数据\nlet buf = buffer(256);\nbuf[0] = 255;\nbuf[1] = 128;\n\nlet f = open(\"data.bin\", \"w\");\nf.write_bytes(buf);\nf.close();\n\n// 读取二进制数据\nlet f2 = open(\"data.bin\", \"r\");\nlet data = f2.read_bytes(256);\nprint(data[0]);  // 255\nf2.close();\n\nfree(buf);\nfree(data);\n```\n\n### 文件属性\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\n\nprint(f.path);    // \"/path/to/file.txt\"\nprint(f.mode);    // \"r\"\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n## 综合示例\n\n让我们构建一个简单的单词计数程序：\n\n```hemlock\n// wordcount.hml - 计算文件中的单词数\n\nfn count_words(filename: string): i32 {\n    let file = null;\n    let count = 0;\n\n    try {\n        file = open(filename, \"r\");\n        let content = file.read();\n\n        // 按空格分割并计数\n        let words = content.split(\" \");\n        count = words.length;\n\n    } catch (e) {\n        print(\"读取文件错误：\" + e);\n        return -1;\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n\n    return count;\n}\n\n// 主程序\nif (args.length < 2) {\n    print(\"用法：\" + args[0] + \" <文件名>\");\n} else {\n    let filename = args[1];\n    let words = count_words(filename);\n\n    if (words >= 0) {\n        print(`单词数：${words}`);\n    }\n}\n```\n\n运行：\n```bash\n./hemlock wordcount.hml data.txt\n```\n\n## 下一步\n\n恭喜！您已经学会了 Hemlock 的基础知识。接下来可以探索：\n\n- [异步与并发](#advanced-async-concurrency) - 真正的多线程\n- [FFI](#advanced-ffi) - 调用 C 函数\n- [信号处理](#advanced-signals) - 进程信号\n- [API 参考](#reference-builtins) - 完整的 API 文档\n- [示例](../../examples/) - 更多真实世界的程序\n\n## 练习题\n\n尝试构建这些程序来练习：\n\n1. **计算器**：实现一个简单的计算器，支持 +、-、*、/\n2. **文件复制**：将一个文件复制到另一个文件\n3. **斐波那契**：生成斐波那契数列\n4. **JSON 解析器**：读取和解析 JSON 文件\n5. **文本处理器**：在文件中查找和替换文本\n\n祝您使用 Hemlock 编程愉快！\n"}, "Language Guide -> Arrays": {"id": "language-guide-arrays", "content": "# 数组\n\nHemlock 提供**动态数组**，具有全面的数据操作和处理方法。数组可以存储混合类型，并根据需要自动增长。\n\n## 概述\n\n```hemlock\n// 数组字面量\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// 允许混合类型\nlet mixed = [1, \"hello\", true, null];\n\n// 动态大小调整\narr.push(6);           // 自动增长\narr.push(7);\nprint(arr.length);     // 7\n```\n\n## 数组字面量\n\n### 基本语法\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet strings = [\"apple\", \"banana\", \"cherry\"];\nlet booleans = [true, false, true];\n```\n\n### 空数组\n\n```hemlock\nlet arr = [];  // 空数组\n\n// 稍后添加元素\narr.push(1);\narr.push(2);\narr.push(3);\n```\n\n### 混合类型\n\n数组可以包含不同类型：\n\n```hemlock\nlet mixed = [\n    42,\n    \"hello\",\n    true,\n    null,\n    [1, 2, 3],\n    { x: 10, y: 20 }\n];\n\nprint(mixed[0]);  // 42\nprint(mixed[1]);  // \"hello\"\nprint(mixed[4]);  // [1, 2, 3]（嵌套数组）\n```\n\n### 嵌套数组\n\n```hemlock\nlet matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\nprint(matrix[0][0]);  // 1\nprint(matrix[1][2]);  // 6\nprint(matrix[2][1]);  // 8\n```\n\n### 类型化数组\n\n数组可以使用类型注解来强制元素类型：\n\n```hemlock\n// 类型化数组语法\nlet nums: array<i32> = [1, 2, 3, 4, 5];\nlet names: array<string> = [\"Alice\", \"Bob\", \"Carol\"];\nlet flags: array<bool> = [true, false, true];\n\n// 运行时类型检查\nlet valid: array<i32> = [1, 2, 3];       // 正确\nlet invalid: array<i32> = [1, \"two\", 3]; // 运行时错误：类型不匹配\n\n// 嵌套类型化数组\nlet matrix: array<array<i32>> = [\n    [1, 2, 3],\n    [4, 5, 6]\n];\n```\n\n**类型注解行为：**\n- 元素在添加到数组时进行类型检查\n- 类型不匹配会导致运行时错误\n- 没有类型注解时，数组接受混合类型\n\n## 索引\n\n### 读取元素\n\n从零开始的索引访问：\n\n```hemlock\nlet arr = [10, 20, 30, 40, 50];\n\nprint(arr[0]);  // 10（第一个元素）\nprint(arr[4]);  // 50（最后一个元素）\n\n// 越界访问返回 null（不报错）\nprint(arr[10]);  // null\n```\n\n### 写入元素\n\n```hemlock\nlet arr = [1, 2, 3];\n\narr[0] = 10;    // 修改现有元素\narr[1] = 20;\nprint(arr);     // [10, 20, 3]\n\n// 可以在超出当前长度的位置赋值（数组会增长）\narr[5] = 60;    // 创建 [10, 20, 3, null, null, 60]\n```\n\n### 负数索引\n\n**不支持** - 只能使用正数索引：\n\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr[-1]);  // 错误或未定义行为\n\n// 使用 length 获取最后一个元素\nprint(arr[arr.length - 1]);  // 3\n```\n\n## 属性\n\n### `.length` 属性\n\n返回元素数量：\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);  // 5\n\n// 空数组\nlet empty = [];\nprint(empty.length);  // 0\n\n// 修改后\narr.push(6);\nprint(arr.length);  // 6\n```\n\n## 数组方法\n\nHemlock 提供 18 个数组方法用于全面的操作。\n\n### 栈操作\n\n**`push(value)`** - 在末尾添加元素：\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\n\nprint(arr.length);     // 5\n```\n\n**`pop()`** - 移除并返回最后一个元素：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet last = arr.pop();  // 返回 5，arr 现在是 [1, 2, 3, 4]\n\nprint(last);           // 5\nprint(arr.length);     // 4\n```\n\n### 队列操作\n\n**`shift()`** - 移除并返回第一个元素：\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();   // 返回 1，arr 现在是 [2, 3]\n\nprint(first);              // 1\nprint(arr);                // [2, 3]\n```\n\n**`unshift(value)`** - 在开头添加元素：\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);            // [1, 2, 3]\narr.unshift(0);            // [0, 1, 2, 3]\n```\n\n### 插入和删除\n\n**`insert(index, value)`** - 在指定索引处插入元素：\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // 在索引 2 处插入 3：[1, 2, 3, 4, 5]\n\narr.insert(0, 0);      // 在开头插入：[0, 1, 2, 3, 4, 5]\n```\n\n**`remove(index)`** - 移除并返回指定索引处的元素：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(2);  // 返回 3，arr 现在是 [1, 2, 4, 5]\n\nprint(removed);               // 3\nprint(arr);                   // [1, 2, 4, 5]\n```\n\n### 搜索操作\n\n**`find(value)`** - 查找首次出现的位置：\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2（首次出现的索引）\nlet idx2 = arr.find(99);     // -1（未找到）\n\n// 适用于任何类型\nlet words = [\"apple\", \"banana\", \"cherry\"];\nlet idx3 = words.find(\"banana\");  // 1\n```\n\n**`contains(value)`** - 检查数组是否包含某值：\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n```\n\n### 提取操作\n\n**`slice(start, end)`** - 提取子数组（end 不包含在内）：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4]（索引 1, 2, 3）\nlet first = arr.slice(0, 2); // [1, 2]\n\n// 原数组不变\nprint(arr);                  // [1, 2, 3, 4, 5]\n```\n\n**`first()`** - 获取第一个元素（不移除）：\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1（不移除）\nprint(arr);                  // [1, 2, 3]（不变）\n```\n\n**`last()`** - 获取最后一个元素（不移除）：\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3（不移除）\nprint(arr);                  // [1, 2, 3]（不变）\n```\n\n### 转换操作\n\n**`reverse()`** - 原地反转数组：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\n\nprint(arr);                  // [5, 4, 3, 2, 1]（已修改）\n```\n\n**`join(delimiter)`** - 将元素连接成字符串：\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// 适用于混合类型\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n```\n\n**`concat(other)`** - 与另一个数组连接：\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]（新数组）\n\n// 原数组不变\nprint(a);                    // [1, 2, 3]\nprint(b);                    // [4, 5, 6]\n```\n\n### 实用操作\n\n**`clear()`** - 移除所有元素：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();                 // []\n\nprint(arr.length);           // 0\nprint(arr);                  // []\n```\n\n## 方法链式调用\n\n返回数组或值的方法可以进行链式调用：\n\n```hemlock\nlet result = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);  // [3, 4, 5]\n\nlet text = [\"apple\", \"banana\", \"cherry\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\nlet numbers = [5, 3, 8, 1, 9]\n    .slice(1, 4)\n    .concat([10, 11]);  // [3, 8, 1, 10, 11]\n```\n\n## 完整方法参考\n\n| 方法 | 参数 | 返回值 | 是否修改原数组 | 描述 |\n|--------|-----------|---------|---------|-------------|\n| `push(value)` | any | void | 是 | 在末尾添加元素 |\n| `pop()` | - | any | 是 | 移除并返回最后一个元素 |\n| `shift()` | - | any | 是 | 移除并返回第一个元素 |\n| `unshift(value)` | any | void | 是 | 在开头添加元素 |\n| `insert(index, value)` | i32, any | void | 是 | 在指定索引处插入 |\n| `remove(index)` | i32 | any | 是 | 移除并返回指定索引处的元素 |\n| `find(value)` | any | i32 | 否 | 查找首次出现的位置（未找到返回 -1） |\n| `contains(value)` | any | bool | 否 | 检查是否包含某值 |\n| `slice(start, end)` | i32, i32 | array | 否 | 提取子数组（新数组） |\n| `join(delimiter)` | string | string | 否 | 连接成字符串 |\n| `concat(other)` | array | array | 否 | 连接数组（新数组） |\n| `reverse()` | - | void | 是 | 原地反转 |\n| `first()` | - | any | 否 | 获取第一个元素 |\n| `last()` | - | any | 否 | 获取最后一个元素 |\n| `clear()` | - | void | 是 | 移除所有元素 |\n| `map(callback)` | fn | array | 否 | 转换每个元素 |\n| `filter(predicate)` | fn | array | 否 | 选择匹配的元素 |\n| `reduce(callback, initial)` | fn, any | any | 否 | 归约为单个值 |\n\n## 实现细节\n\n### 内存模型\n\n- **堆分配** - 动态容量\n- **自动增长** - 超出容量时翻倍\n- **不自动收缩** - 容量不会减少\n- **索引无边界检查** - 使用方法以确保安全\n\n### 容量管理\n\n```hemlock\nlet arr = [];  // 初始容量：0\n\narr.push(1);   // 增长到容量 1\narr.push(2);   // 增长到容量 2\narr.push(3);   // 增长到容量 4（翻倍）\narr.push(4);   // 仍然是容量 4\narr.push(5);   // 增长到容量 8（翻倍）\n```\n\n### 值比较\n\n`find()` 和 `contains()` 使用值相等比较：\n\n```hemlock\n// 基本类型：按值比较\nlet arr = [1, 2, 3];\narr.contains(2);  // true\n\n// 字符串：按值比较\nlet words = [\"hello\", \"world\"];\nwords.contains(\"hello\");  // true\n\n// 对象：按引用比较\nlet obj1 = { x: 10 };\nlet obj2 = { x: 10 };\nlet arr2 = [obj1];\narr2.contains(obj1);  // true（相同引用）\narr2.contains(obj2);  // false（不同引用）\n```\n\n## 常见模式\n\n### 函数式操作（map/filter/reduce）\n\n数组内置 `map`、`filter` 和 `reduce` 方法：\n\n```hemlock\n// map - 转换每个元素\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = numbers.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\n// filter - 选择匹配的元素\nlet evens = numbers.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4]\n\n// reduce - 归约为单个值\nlet sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\n// 链式调用函数式操作\nlet result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]\n    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]\n    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220\n```\n\n### 模式：数组作为栈\n\n```hemlock\nlet stack = [];\n\n// 压入栈\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// 弹出栈\nlet top = stack.pop();    // 3\nlet next = stack.pop();   // 2\n```\n\n### 模式：数组作为队列\n\n```hemlock\nlet queue = [];\n\n// 入队（添加到末尾）\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// 出队（从前面移除）\nlet first = queue.shift();   // 1\nlet second = queue.shift();  // 2\n```\n\n## 最佳实践\n\n1. **使用方法而非直接索引** - 边界检查和代码清晰度\n2. **检查边界** - 直接索引不进行边界检查\n3. **优先使用不可变操作** - 使用 `slice()` 和 `concat()` 而非修改原数组\n4. **预先初始化容量** - 如果知道大小（目前不支持）\n5. **使用 `contains()` 检查成员** - 比手动循环更清晰\n6. **链式调用方法** - 比嵌套调用更易读\n\n## 常见陷阱\n\n### 陷阱：直接索引越界\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// 无边界检查！\narr[10] = 99;  // 创建带有 null 的稀疏数组\nprint(arr.length);  // 11（不是 3！）\n\n// 更好的做法：使用 push() 或检查长度\nif (arr.length <= 10) {\n    arr.push(99);\n}\n```\n\n### 陷阱：修改与新建数组\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// 修改原数组\narr.reverse();\nprint(arr);  // [3, 2, 1]\n\n// 返回新数组\nlet sub = arr.slice(0, 2);\nprint(arr);  // [3, 2, 1]（不变）\nprint(sub);  // [3, 2]\n```\n\n### 陷阱：引用相等\n\n```hemlock\nlet obj = { x: 10 };\nlet arr = [obj];\n\n// 相同引用：true\narr.contains(obj);  // true\n\n// 不同引用：false\narr.contains({ x: 10 });  // false（不同对象）\n```\n\n### 陷阱：长期存活的数组\n\n```hemlock\n// 局部作用域中的数组会自动释放，但全局/长期存活的数组需要注意\nlet global_cache = [];  // 模块级别，持续到程序退出\n\nfn add_to_cache(item) {\n    global_cache.push(item);  // 无限增长\n}\n\n// 对于长期存活的数据，考虑：\n// - 定期清空数组：global_cache.clear();\n// - 提前释放：free(global_cache);\n```\n\n## 示例\n\n### 示例：数组统计\n\n```hemlock\nfn mean(arr) {\n    let sum = 0;\n    let i = 0;\n    while (i < arr.length) {\n        sum = sum + arr[i];\n        i = i + 1;\n    }\n    return sum / arr.length;\n}\n\nfn max(arr) {\n    if (arr.length == 0) {\n        return null;\n    }\n\n    let max_val = arr[0];\n    let i = 1;\n    while (i < arr.length) {\n        if (arr[i] > max_val) {\n            max_val = arr[i];\n        }\n        i = i + 1;\n    }\n    return max_val;\n}\n\nlet numbers = [3, 7, 2, 9, 1];\nprint(mean(numbers));  // 4.4\nprint(max(numbers));   // 9\n```\n\n### 示例：数组去重\n\n```hemlock\nfn unique(arr) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (!result.contains(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet numbers = [1, 2, 2, 3, 1, 4, 3, 5];\nlet uniq = unique(numbers);  // [1, 2, 3, 4, 5]\n```\n\n### 示例：数组分块\n\n```hemlock\nfn chunk(arr, size) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        let chunk = arr.slice(i, i + size);\n        result.push(chunk);\n        i = i + size;\n    }\n\n    return result;\n}\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8];\nlet chunks = chunk(numbers, 3);\n// [[1, 2, 3], [4, 5, 6], [7, 8]]\n```\n\n### 示例：数组扁平化\n\n```hemlock\nfn flatten(arr) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        if (typeof(arr[i]) == \"array\") {\n            // 嵌套数组 - 扁平化它\n            let nested = flatten(arr[i]);\n            let j = 0;\n            while (j < nested.length) {\n                result.push(nested[j]);\n                j = j + 1;\n            }\n        } else {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet nested = [1, [2, 3], [4, [5, 6]], 7];\nlet flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]\n```\n\n### 示例：排序（冒泡排序）\n\n```hemlock\nfn sort(arr) {\n    let n = arr.length;\n    let i = 0;\n\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (arr[j] > arr[j + 1]) {\n                // 交换\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers);  // 原地修改\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## 限制\n\n当前限制：\n\n- **索引无边界检查** - 直接访问不检查边界\n- **对象使用引用相等** - `find()` 和 `contains()` 使用引用比较\n- **无数组解构** - 不支持 `let [a, b] = arr` 语法\n- **无展开运算符** - 不支持 `[...arr1, ...arr2]` 语法\n\n**注意：** 数组使用引用计数，作用域退出时自动释放。详见 [内存管理](memory.md#internal-reference-counting)。\n\n## 相关主题\n\n- [字符串](#language-guide-strings) - 字符串方法与数组方法类似\n- [对象](#language-guide-objects) - 数组也是类对象的\n- [函数](#language-guide-functions) - 数组与高阶函数\n- [控制流](#language-guide-control-flow) - 遍历数组\n\n## 另请参阅\n\n- **动态大小**：数组通过容量翻倍自动增长\n- **方法**：18 个全面的操作方法，包括 map/filter/reduce\n- **内存**：详见 [内存](#language-guide-memory) 了解数组分配细节\n"}, "Language Guide -> Control Flow": {"id": "language-guide-control-flow", "content": "# 控制流\n\nHemlock 提供熟悉的 C 风格控制流，要求强制使用花括号和显式语法。本指南涵盖条件语句、循环、switch 语句和运算符。\n\n## 概述\n\n可用的控制流特性：\n\n- `if`/`else`/`else if` - 条件分支\n- `while` 循环 - 基于条件的迭代\n- `for` 循环 - C 风格和 for-in 迭代\n- `loop` - 无限循环（比 `while (true)` 更清晰）\n- `switch` 语句 - 多路分支\n- `break`/`continue` - 循环控制\n- 循环标签 - 针对嵌套循环的定向 break/continue\n- `defer` - 延迟执行（清理）\n- 布尔运算符：`&&`、`||`、`!`\n- 比较运算符：`==`、`!=`、`<`、`>`、`<=`、`>=`\n- 位运算符：`&`、`|`、`^`、`<<`、`>>`、`~`\n\n## If 语句\n\n### 基本 If/Else\n\n```hemlock\nif (x > 10) {\n    print(\"large\");\n} else {\n    print(\"small\");\n}\n```\n\n**规则：**\n- 所有分支都**必须**使用花括号\n- 条件必须用括号包围\n- 不支持可选花括号（与 C 不同）\n\n### 无 Else 的 If\n\n```hemlock\nif (x > 0) {\n    print(\"positive\");\n}\n// 不需要 else 分支\n```\n\n### Else-If 链\n\n```hemlock\nif (x > 100) {\n    print(\"very large\");\n} else if (x > 50) {\n    print(\"large\");\n} else if (x > 10) {\n    print(\"medium\");\n} else {\n    print(\"small\");\n}\n```\n\n**注意：** `else if` 是嵌套 if 语句的语法糖。以下两种写法等价：\n\n```hemlock\n// else if（语法糖）\nif (a) {\n    foo();\n} else if (b) {\n    bar();\n}\n\n// 等价的嵌套 if\nif (a) {\n    foo();\n} else {\n    if (b) {\n        bar();\n    }\n}\n```\n\n### 嵌套 If 语句\n\n```hemlock\nif (x > 0) {\n    if (x < 10) {\n        print(\"single digit positive\");\n    } else {\n        print(\"multi-digit positive\");\n    }\n} else {\n    print(\"non-positive\");\n}\n```\n\n## While 循环\n\n基于条件的迭代：\n\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n**无限循环（旧式）：**\n```hemlock\nwhile (true) {\n    // ... 执行工作\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**注意：** 对于无限循环，推荐使用 `loop` 关键字（见下文）。\n\n## Loop（无限循环）\n\n`loop` 关键字为无限循环提供更清晰的语法：\n\n```hemlock\nloop {\n    // ... 执行工作\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**等价于 `while (true)`，但意图更明确。**\n\n### 带 Break 的基本 Loop\n\n```hemlock\nlet i = 0;\nloop {\n    if (i >= 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// 输出：0, 1, 2, 3, 4\n```\n\n### 带 Continue 的 Loop\n\n```hemlock\nlet i = 0;\nloop {\n    i = i + 1;\n    if (i > 5) {\n        break;\n    }\n    if (i == 3) {\n        continue;  // 跳过打印 3\n    }\n    print(i);\n}\n// 输出：1, 2, 4, 5\n```\n\n### 嵌套 Loop\n\n```hemlock\nlet x = 0;\nloop {\n    if (x >= 2) { break; }\n    let y = 0;\n    loop {\n        if (y >= 3) { break; }\n        print(x * 10 + y);\n        y = y + 1;\n    }\n    x = x + 1;\n}\n// 输出：0, 1, 2, 10, 11, 12\n```\n\n### 何时使用 Loop\n\n- **使用 `loop`** - 用于故意的无限循环，通过 `break` 退出\n- **使用 `while`** - 当有自然的终止条件时\n- **使用 `for`** - 当迭代已知次数或遍历集合时\n\n## For 循环\n\n### C 风格 For\n\n经典的三段式 for 循环：\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**组成部分：**\n- **初始化器**：`let i = 0` - 循环开始前运行一次\n- **条件**：`i < 10` - 每次迭代前检查\n- **更新**：`i = i + 1` - 每次迭代后运行\n\n**作用域：**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n// i 在这里不可访问（循环作用域）\n```\n\n### For-In 循环\n\n遍历数组元素：\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nfor (let item in arr) {\n    print(item);  // 打印每个元素\n}\n```\n\n**带索引和值：**\n```hemlock\nlet arr = [\"a\", \"b\", \"c\"];\nfor (let i = 0; i < arr.length; i = i + 1) {\n    print(`Index: ${i}, Value: ${arr[i]}`);\n}\n```\n\n## Switch 语句\n\n基于值的多路分支：\n\n### 基本 Switch\n\n```hemlock\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n}\n```\n\n### 带 Default 的 Switch\n\n```hemlock\nlet color = \"blue\";\n\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"yellow\":\n        print(\"slow\");\n        break;\n    case \"green\":\n        print(\"go\");\n        break;\n    default:\n        print(\"unknown color\");\n        break;\n}\n```\n\n**规则：**\n- `default` 在没有其他 case 匹配时执行\n- `default` 可以出现在 switch 体的任何位置\n- 只允许一个 default case\n\n### 贯穿行为\n\n没有 `break` 的 case 会贯穿到下一个 case（C 风格行为）。这是**有意的**，可用于分组 case：\n\n```hemlock\nlet grade = 85;\n\nswitch (grade) {\n    case 100:\n    case 95:\n    case 90:\n        print(\"A\");\n        break;\n    case 85:\n    case 80:\n        print(\"B\");\n        break;\n    default:\n        print(\"C or below\");\n        break;\n}\n```\n\n**显式贯穿示例：**\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n        print(\"Weekday\");\n        break;\n    case 6:\n    case 7:\n        print(\"Weekend\");\n        break;\n}\n```\n\n**重要：** 与一些现代语言不同，Hemlock 不需要显式的 `fallthrough` 关键字。除非用 `break`、`return` 或 `throw` 终止，否则 case 会自动贯穿。始终使用 `break` 防止意外贯穿。\n\n### 带 Return 的 Switch\n\n在函数中，`return` 立即退出 switch：\n\n```hemlock\nfn get_day_name(day: i32): string {\n    switch (day) {\n        case 1:\n            return \"Monday\";\n        case 2:\n            return \"Tuesday\";\n        case 3:\n            return \"Wednesday\";\n        default:\n            return \"Unknown\";\n    }\n}\n```\n\n### Switch 值类型\n\nSwitch 适用于任何值类型：\n\n```hemlock\n// 整数\nswitch (count) {\n    case 0: print(\"zero\"); break;\n    case 1: print(\"one\"); break;\n}\n\n// 字符串\nswitch (name) {\n    case \"Alice\": print(\"A\"); break;\n    case \"Bob\": print(\"B\"); break;\n}\n\n// 布尔值\nswitch (flag) {\n    case true: print(\"on\"); break;\n    case false: print(\"off\"); break;\n}\n```\n\n**注意：** Case 使用值相等性进行比较。\n\n## Break 和 Continue\n\n### Break\n\n退出最内层的循环或 switch：\n\n```hemlock\n// 在循环中\nlet i = 0;\nwhile (true) {\n    if (i >= 10) {\n        break;  // 退出循环\n    }\n    print(i);\n    i = i + 1;\n}\n\n// 在 switch 中\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;  // 退出 switch\n    case 2:\n        print(\"two\");\n        break;\n}\n```\n\n### Continue\n\n跳到循环的下一次迭代：\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;  // 当 i 为 5 时跳过\n    }\n    print(i);  // 打印 0,1,2,3,4,6,7,8,9\n}\n```\n\n**区别：**\n- `break` - 完全退出循环\n- `continue` - 跳到下一次迭代\n\n## 循环标签\n\n循环标签允许 `break` 和 `continue` 针对特定的外层循环，而不仅仅是最内层循环。这在需要从内层循环控制外层循环的嵌套循环中很有用。\n\n### 带标签的 Break\n\n从内层循环退出外层循环：\n\n```hemlock\nouter: while (i < 3) {\n    let j = 0;\n    while (j < 3) {\n        if (i == 1 && j == 1) {\n            break outer;  // 退出外层 while 循环\n        }\n        print(i * 10 + j);\n        j = j + 1;\n    }\n    i = i + 1;\n}\n// 输出：0, 1, 2, 10（在 i=1, j=1 处停止）\n```\n\n### 带标签的 Continue\n\n跳到外层循环的下一次迭代：\n\n```hemlock\nlet i = 0;\nouter: while (i < 3) {\n    i = i + 1;\n    let j = 0;\n    while (j < 3) {\n        j = j + 1;\n        if (i == 2 && j == 1) {\n            continue outer;  // 跳过内层循环剩余部分，继续外层循环\n        }\n        print(i * 10 + j);\n    }\n}\n// 当 i=2, j=1 时：跳到外层循环的下一次迭代\n```\n\n### For 循环中的标签\n\n标签适用于所有循环类型：\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 3; y = y + 1) {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n    }\n}\n```\n\n### For-In 循环中的标签\n\n```hemlock\nlet arr1 = [1, 2, 3];\nlet arr2 = [10, 20, 30];\n\nouter: for (let a in arr1) {\n    for (let b in arr2) {\n        if (a == 2 && b == 20) {\n            break outer;\n        }\n        print(a * 100 + b);\n    }\n}\n```\n\n### Loop 关键字中的标签\n\n```hemlock\nlet x = 0;\nouter: loop {\n    let y = 0;\n    loop {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n        y = y + 1;\n        if (y >= 3) { break; }\n    }\n    x = x + 1;\n    if (x >= 3) { break; }\n}\n```\n\n### 多重标签\n\n可以在不同嵌套层级使用标签：\n\n```hemlock\nouter: for (let a = 0; a < 2; a = a + 1) {\n    inner: for (let b = 0; b < 3; b = b + 1) {\n        for (let c = 0; c < 3; c = c + 1) {\n            if (c == 1) {\n                continue inner;  // 跳到中间循环的下一次迭代\n            }\n            if (a == 1 && b == 1) {\n                break outer;      // 退出最外层循环\n            }\n            print(a * 100 + b * 10 + c);\n        }\n    }\n}\n```\n\n### 带标签循环中的无标签 Break/Continue\n\n无标签的 `break` 和 `continue` 仍然正常工作（影响最内层循环），即使外层循环有标签：\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 5; y = y + 1) {\n        if (y == 2) {\n            break;  // 只退出内层循环\n        }\n        print(x * 10 + y);\n    }\n}\n// 输出：0, 1, 10, 11, 20, 21\n```\n\n### 标签语法\n\n- 标签是标识符后跟冒号\n- 标签必须紧接在循环语句之前（`while`、`for`、`loop`）\n- 标签名遵循标识符规则（字母、数字、下划线）\n- 常见约定：`outer`、`inner`、`row`、`col`、描述性名称\n\n## Defer 语句\n\n`defer` 语句安排代码在当前函数返回时执行。这对于清理操作很有用，如关闭文件、释放资源或解锁。\n\n### 基本 Defer\n\n```hemlock\nfn example() {\n    print(\"start\");\n    defer print(\"cleanup\");  // 函数返回时运行\n    print(\"end\");\n}\n\nexample();\n// 输出：\n// start\n// end\n// cleanup\n```\n\n**关键行为：**\n- 延迟语句在函数体完成**之后**执行\n- 延迟语句在函数返回给调用者**之前**执行\n- 即使函数抛出异常，延迟语句也总是执行\n\n### 多个 Defer（LIFO 顺序）\n\n当使用多个 `defer` 语句时，它们按**相反顺序**执行（后进先出）：\n\n```hemlock\nfn example() {\n    defer print(\"first\");   // 最后执行\n    defer print(\"second\");  // 第二个执行\n    defer print(\"third\");   // 第一个执行\n    print(\"body\");\n}\n\nexample();\n// 输出：\n// body\n// third\n// second\n// first\n```\n\n这种 LIFO 顺序是有意的 - 它符合嵌套资源清理的自然顺序（在外部资源之前关闭内部资源）。\n\n### 带 Return 的 Defer\n\n延迟语句在 `return` 转移控制之前执行：\n\n```hemlock\nfn get_value(): i32 {\n    defer print(\"cleanup\");\n    print(\"before return\");\n    return 42;\n}\n\nlet result = get_value();\nprint(\"result:\", result);\n// 输出：\n// before return\n// cleanup\n// result: 42\n```\n\n### 带异常的 Defer\n\n即使抛出异常，延迟语句也会执行：\n\n```hemlock\nfn risky() {\n    defer print(\"cleanup 1\");\n    defer print(\"cleanup 2\");\n    print(\"before throw\");\n    throw \"error!\";\n    print(\"after throw\");  // 永远不会执行\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(\"Caught:\", e);\n}\n// 输出：\n// before throw\n// cleanup 2\n// cleanup 1\n// Caught: error!\n```\n\n### 资源清理模式\n\n`defer` 的主要用例是确保资源被清理：\n\n```hemlock\nfn process_file(filename: string) {\n    let file = open(filename, \"r\");\n    defer file.close();  // 即使出错也总是关闭\n\n    let content = file.read();\n    // ... 处理内容 ...\n\n    // 函数返回时文件自动关闭\n}\n```\n\n**不使用 defer（容易出错）：**\n```hemlock\nfn process_file_bad(filename: string) {\n    let file = open(filename, \"r\");\n    let content = file.read();\n    // 如果这里抛出异常，file.close() 永远不会被调用！\n    process(content);\n    file.close();\n}\n```\n\n### 带闭包的 Defer\n\nDefer 可以使用闭包来捕获状态：\n\n```hemlock\nfn example() {\n    let resource = acquire_resource();\n    defer fn() {\n        print(\"Releasing resource\");\n        release(resource);\n    }();  // 注意：立即调用的函数表达式\n\n    use_resource(resource);\n}\n```\n\n### 何时使用 Defer\n\n**使用 defer 的场景：**\n- 关闭文件和网络连接\n- 释放分配的内存\n- 释放锁和互斥量\n- 任何获取资源的函数中的清理\n\n**Defer vs Finally：**\n- `defer` 对于单资源清理更简单\n- `try/finally` 对于带恢复的复杂错误处理更好\n\n### 最佳实践\n\n1. **获取资源后立即使用 defer：**\n   ```hemlock\n   let file = open(\"data.txt\", \"r\");\n   defer file.close();\n   // ... 使用文件 ...\n   ```\n\n2. **对多个资源使用多个 defer：**\n   ```hemlock\n   let file1 = open(\"input.txt\", \"r\");\n   defer file1.close();\n\n   let file2 = open(\"output.txt\", \"w\");\n   defer file2.close();\n\n   // 两个文件将按相反顺序关闭\n   ```\n\n3. **记住 LIFO 顺序用于依赖资源：**\n   ```hemlock\n   let outer = acquire_outer();\n   defer release_outer(outer);\n\n   let inner = acquire_inner(outer);\n   defer release_inner(inner);\n\n   // inner 在 outer 之前释放（正确的依赖顺序）\n   ```\n\n## 布尔运算符\n\n### 逻辑与 (`&&`)\n\n两个条件都必须为真：\n\n```hemlock\nif (x > 0 && x < 10) {\n    print(\"single digit positive\");\n}\n```\n\n**短路求值：**\n```hemlock\nif (false && expensive_check()) {\n    // expensive_check() 永远不会被调用\n}\n```\n\n### 逻辑或 (`||`)\n\n至少一个条件必须为真：\n\n```hemlock\nif (x < 0 || x > 100) {\n    print(\"out of range\");\n}\n```\n\n**短路求值：**\n```hemlock\nif (true || expensive_check()) {\n    // expensive_check() 永远不会被调用\n}\n```\n\n### 逻辑非 (`!`)\n\n取反布尔值：\n\n```hemlock\nif (!is_valid) {\n    print(\"invalid\");\n}\n\nif (!(x > 10)) {\n    // 等同于：if (x <= 10)\n}\n```\n\n## 比较运算符\n\n### 相等性\n\n```hemlock\nif (x == 10) { }    // 等于\nif (x != 10) { }    // 不等于\n```\n\n适用于所有类型：\n```hemlock\n\"hello\" == \"hello\"  // true\ntrue == false       // false\nnull == null        // true\n```\n\n### 关系运算符\n\n```hemlock\nif (x < 10) { }     // 小于\nif (x > 10) { }     // 大于\nif (x <= 10) { }    // 小于等于\nif (x >= 10) { }    // 大于等于\n```\n\n**类型提升适用：**\n```hemlock\nlet a: i32 = 10;\nlet b: i64 = 10;\nif (a == b) { }     // true（i32 提升为 i64）\n```\n\n## 位运算符\n\nHemlock 提供用于整数操作的位运算符。这些**只能用于整数类型**（i8-i64、u8-u64）。\n\n### 二元位运算符\n\n**按位与 (`&`)**\n```hemlock\nlet a = 12;  // 二进制 1100\nlet b = 10;  // 二进制 1010\nprint(a & b);   // 8 (1000)\n```\n\n**按位或 (`|`)**\n```hemlock\nprint(a | b);   // 14 (1110)\n```\n\n**按位异或 (`^`)**\n```hemlock\nprint(a ^ b);   // 6 (0110)\n```\n\n**左移 (`<<`)**\n```hemlock\nprint(a << 2);  // 48 (110000) - 左移 2 位\n```\n\n**右移 (`>>`)**\n```hemlock\nprint(a >> 1);  // 6 (110) - 右移 1 位\n```\n\n### 一元位运算符\n\n**按位取反 (`~`)**\n```hemlock\nlet a = 12;\nprint(~a);      // -13（补码）\n\nlet c: u8 = 15;   // 二进制 00001111\nprint(~c);        // 240 (11110000)，u8 类型\n```\n\n### 位运算示例\n\n**使用无符号类型：**\n```hemlock\nlet c: u8 = 15;   // 二进制 00001111\nlet d: u8 = 7;    // 二进制 00000111\n\nprint(c & d);     // 7  (00000111)\nprint(c | d);     // 15 (00001111)\nprint(c ^ d);     // 8  (00001000)\nprint(~c);        // 240 (11110000) - u8 类型\n```\n\n**类型保持：**\n```hemlock\n// 位运算保持操作数的类型\nlet x: u8 = 255;\nlet result = ~x;  // result 是 u8，值为 0\n\nlet y: i32 = 100;\nlet result2 = y << 2;  // result2 是 i32，值为 400\n```\n\n**常见模式：**\n```hemlock\n// 检查位是否设置\nif (flags & 0x04) {\n    print(\"bit 2 is set\");\n}\n\n// 设置位\nflags = flags | 0x08;\n\n// 清除位\nflags = flags & ~0x02;\n\n// 切换位\nflags = flags ^ 0x01;\n```\n\n### 运算符优先级\n\n位运算符遵循 C 风格优先级：\n\n1. `~`（一元取反）- 最高，与 `!` 和 `-` 同级\n2. `<<`、`>>`（位移）- 高于比较，低于 `+`/`-`\n3. `&`（按位与）- 高于 `^` 和 `|`\n4. `^`（按位异或）- 在 `&` 和 `|` 之间\n5. `|`（按位或）- 低于 `&` 和 `^`，高于 `&&`\n6. `&&`、`||`（逻辑）- 最低优先级\n\n**示例：**\n```hemlock\n// & 优先级高于 |\nlet result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12\n\n// 位移优先级高于位运算符\nlet result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12\n\n// 使用括号提高清晰度\nlet result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5\n```\n\n**重要注意事项：**\n- 位运算符只能用于整数类型（不能用于浮点数、字符串等）\n- 类型提升遵循标准规则（较小类型提升为较大类型）\n- 右移 (`>>`) 对有符号类型是算术移位，对无符号类型是逻辑移位\n- 移位量不进行范围检查（大移位量的行为取决于平台）\n\n## 运算符优先级（完整）\n\n从高到低优先级：\n\n1. **一元**：`!`、`-`、`~`\n2. **乘除**：`*`、`/`、`%`\n3. **加减**：`+`、`-`\n4. **位移**：`<<`、`>>`\n5. **关系**：`<`、`>`、`<=`、`>=`\n6. **相等**：`==`、`!=`\n7. **按位与**：`&`\n8. **按位异或**：`^`\n9. **按位或**：`|`\n10. **逻辑与**：`&&`\n11. **逻辑或**：`||`\n\n**使用括号提高清晰度：**\n```hemlock\n// 不清晰\nif (a || b && c) { }\n\n// 清晰\nif (a || (b && c)) { }\nif ((a || b) && c) { }\n```\n\n## 常见模式\n\n### 模式：输入验证\n\n```hemlock\nfn validate_age(age: i32): bool {\n    if (age < 0 || age > 150) {\n        return false;\n    }\n    return true;\n}\n```\n\n### 模式：范围检查\n\n```hemlock\nfn in_range(value: i32, min: i32, max: i32): bool {\n    return value >= min && value <= max;\n}\n\nif (in_range(score, 0, 100)) {\n    print(\"valid score\");\n}\n```\n\n### 模式：状态机\n\n```hemlock\nlet state = \"start\";\n\nwhile (true) {\n    switch (state) {\n        case \"start\":\n            print(\"Starting...\");\n            state = \"running\";\n            break;\n\n        case \"running\":\n            if (should_pause) {\n                state = \"paused\";\n            } else if (should_stop) {\n                state = \"stopped\";\n            }\n            break;\n\n        case \"paused\":\n            if (should_resume) {\n                state = \"running\";\n            }\n            break;\n\n        case \"stopped\":\n            print(\"Stopped\");\n            break;\n    }\n\n    if (state == \"stopped\") {\n        break;\n    }\n}\n```\n\n### 模式：带过滤的迭代\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// 只打印偶数\nfor (let i = 0; i < arr.length; i = i + 1) {\n    if (arr[i] % 2 != 0) {\n        continue;  // 跳过奇数\n    }\n    print(arr[i]);\n}\n```\n\n### 模式：提前退出\n\n```hemlock\nfn find_first_negative(arr: array): i32 {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // 提前退出\n        }\n    }\n    return -1;  // 未找到\n}\n```\n\n## 最佳实践\n\n1. **始终使用花括号** - 即使是单语句块也要（语法强制）\n2. **显式条件** - 使用 `x == 0` 而不是 `!x` 以提高清晰度\n3. **避免深层嵌套** - 将嵌套条件提取到函数中\n4. **使用提前返回** - 用守卫子句减少嵌套\n5. **分解复杂条件** - 拆分为命名的布尔变量\n6. **switch 中使用 default** - 始终包含 default case\n7. **注释贯穿** - 使有意的贯穿明确\n\n## 常见陷阱\n\n### 陷阱：条件中的赋值\n\n```hemlock\n// 这是不允许的（条件中不能赋值）\nif (x = 10) { }  // 错误：语法错误\n\n// 使用比较代替\nif (x == 10) { }  // OK\n```\n\n### 陷阱：Switch 中缺少 Break\n\n```hemlock\n// 意外贯穿\nswitch (x) {\n    case 1:\n        print(\"one\");\n        // 缺少 break - 会贯穿！\n    case 2:\n        print(\"two\");  // 对 1 和 2 都执行\n        break;\n}\n\n// 修复：添加 break\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;  // 现在正确\n    case 2:\n        print(\"two\");\n        break;\n}\n```\n\n### 陷阱：循环变量作用域\n\n```hemlock\n// i 的作用域限于循环\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\nprint(i);  // 错误：i 在这里未定义\n```\n\n## 示例\n\n### 示例：FizzBuzz\n\n```hemlock\nfor (let i = 1; i <= 100; i = i + 1) {\n    if (i % 15 == 0) {\n        print(\"FizzBuzz\");\n    } else if (i % 3 == 0) {\n        print(\"Fizz\");\n    } else if (i % 5 == 0) {\n        print(\"Buzz\");\n    } else {\n        print(i);\n    }\n}\n```\n\n### 示例：素数检查\n\n```hemlock\nfn is_prime(n: i32): bool {\n    if (n < 2) {\n        return false;\n    }\n\n    let i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            return false;\n        }\n        i = i + 1;\n    }\n\n    return true;\n}\n```\n\n### 示例：菜单系统\n\n```hemlock\nfn menu() {\n    while (true) {\n        print(\"1. Start\");\n        print(\"2. Settings\");\n        print(\"3. Exit\");\n\n        let choice = get_input();\n\n        switch (choice) {\n            case 1:\n                start_game();\n                break;\n            case 2:\n                show_settings();\n                break;\n            case 3:\n                print(\"Goodbye!\");\n                return;\n            default:\n                print(\"Invalid choice\");\n                break;\n        }\n    }\n}\n```\n\n## 相关主题\n\n- [Functions](#language-guide-functions) - 函数调用和返回的控制流\n- [Error Handling](#language-guide-error-handling) - 异常的控制流\n- [Types](#language-guide-types) - 条件中的类型转换\n\n## 另请参阅\n\n- **语法**：参见 [Syntax](#language-guide-syntax) 了解语句语法细节\n- **运算符**：参见 [Types](#language-guide-types) 了解运算中的类型提升\n"}, "Language Guide -> Error Handling": {"id": "language-guide-error-handling", "content": "# 错误处理\n\nHemlock 通过 `try`、`catch`、`finally`、`throw` 和 `panic` 支持基于异常的错误处理。本指南涵盖了使用异常处理可恢复错误以及使用 panic 处理不可恢复错误的内容。\n\n## 概述\n\n```hemlock\n// 基本错误处理\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\n// 带清理操作\ntry {\n    process_file();\n} catch (e) {\n    print(\"Failed: \" + e);\n} finally {\n    cleanup();\n}\n\n// 抛出错误\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n```\n\n## Try-Catch-Finally\n\n### 语法\n\n**基本 try/catch：**\n```hemlock\ntry {\n    // 有风险的代码\n} catch (e) {\n    // 处理错误，e 包含抛出的值\n}\n```\n\n**Try/finally：**\n```hemlock\ntry {\n    // 有风险的代码\n} finally {\n    // 始终执行，即使抛出异常\n}\n```\n\n**Try/catch/finally：**\n```hemlock\ntry {\n    // 有风险的代码\n} catch (e) {\n    // 处理错误\n} finally {\n    // 清理代码\n}\n```\n\n### Try 块\n\ntry 块按顺序执行语句：\n\n```hemlock\ntry {\n    print(\"Starting...\");\n    risky_operation();\n    print(\"Success!\");  // 仅在没有异常时执行\n}\n```\n\n**行为：**\n- 按顺序执行语句\n- 如果抛出异常：跳转到 `catch` 或 `finally`\n- 如果没有异常：执行 `finally`（如果存在）然后继续\n\n### Catch 块\n\ncatch 块接收抛出的值：\n\n```hemlock\ntry {\n    throw \"oops\";\n} catch (error) {\n    print(\"Caught: \" + error);  // error = \"oops\"\n    // error 只能在这里访问\n}\n// error 在这里无法访问\n```\n\n**Catch 参数：**\n- 接收抛出的值（任意类型）\n- 作用域仅限于 catch 块\n- 可以命名为任何名称（通常使用 `e`、`err` 或 `error`）\n\n**在 catch 中可以做的事情：**\n```hemlock\ntry {\n    risky_operation();\n} catch (e) {\n    // 记录错误\n    print(\"Error: \" + e);\n\n    // 重新抛出相同错误\n    throw e;\n\n    // 抛出不同错误\n    throw \"different error\";\n\n    // 返回默认值\n    return null;\n\n    // 处理并继续\n    // （不重新抛出）\n}\n```\n\n### Finally 块\n\nfinally 块**始终执行**：\n\n```hemlock\ntry {\n    print(\"1: try\");\n    throw \"error\";\n} catch (e) {\n    print(\"2: catch\");\n} finally {\n    print(\"3: finally\");  // 始终运行\n}\nprint(\"4: after\");\n\n// 输出：1: try, 2: catch, 3: finally, 4: after\n```\n\n**finally 何时运行：**\n- 在 try 块之后（如果没有异常）\n- 在 catch 块之后（如果捕获了异常）\n- 即使 try/catch 包含 `return`、`break` 或 `continue`\n- 在控制流退出 try/catch 之前\n\n**Finally 与 return：**\n```hemlock\nfn example() {\n    try {\n        return 1;  // 在 finally 运行后返回 1\n    } finally {\n        print(\"cleanup\");  // 在返回之前运行\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // finally 的 return 覆盖原值 - 返回 2\n    }\n}\n```\n\n**Finally 与控制流：**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) {\n            break;  // 在 finally 运行后 break\n        }\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```\n\n## Throw 语句\n\n### 基本 Throw\n\n抛出任意值作为异常：\n\n```hemlock\nthrow \"error message\";\nthrow 404;\nthrow { code: 500, message: \"Internal error\" };\nthrow null;\nthrow [\"error\", \"details\"];\n```\n\n**执行过程：**\n1. 计算表达式\n2. 立即跳转到最近的 `catch`\n3. 如果没有 `catch`，向上传播调用栈\n\n### 抛出错误\n\n```hemlock\nfn validate_age(age: i32) {\n    if (age < 0) {\n        throw \"Age cannot be negative\";\n    }\n    if (age > 150) {\n        throw \"Age is unrealistic\";\n    }\n}\n\ntry {\n    validate_age(-5);\n} catch (e) {\n    print(\"Validation error: \" + e);\n}\n```\n\n### 抛出错误对象\n\n创建结构化的错误信息：\n\n```hemlock\nfn read_file(path: string) {\n    if (!file_exists(path)) {\n        throw {\n            type: \"FileNotFound\",\n            path: path,\n            message: \"File does not exist\"\n        };\n    }\n    // ... 读取文件\n}\n\ntry {\n    read_file(\"missing.txt\");\n} catch (e) {\n    if (e.type == \"FileNotFound\") {\n        print(\"File not found: \" + e.path);\n    }\n}\n```\n\n### 重新抛出\n\n捕获并重新抛出错误：\n\n```hemlock\nfn wrapper() {\n    try {\n        risky_operation();\n    } catch (e) {\n        print(\"Logging error: \" + e);\n        throw e;  // 重新抛给调用者\n    }\n}\n\ntry {\n    wrapper();\n} catch (e) {\n    print(\"Caught in main: \" + e);\n}\n```\n\n## 未捕获的异常\n\n如果异常传播到调用栈顶部而未被捕获：\n\n```hemlock\nfn foo() {\n    throw \"uncaught!\";\n}\n\nfoo();  // 崩溃并显示：Runtime error: uncaught!\n```\n\n**行为：**\n- 程序崩溃\n- 向 stderr 打印错误消息\n- 以非零状态码退出\n- 堆栈跟踪将在未来版本中添加\n\n## Panic - 不可恢复错误\n\n### 什么是 Panic？\n\n`panic()` 用于**不可恢复的错误**，应立即终止程序：\n\n```hemlock\npanic();                    // 默认消息：\"panic!\"\npanic(\"custom message\");    // 自定义消息\npanic(42);                  // 非字符串值会被打印\n```\n\n**语义：**\n- **立即退出**程序，退出码为 1\n- 向 stderr 打印错误消息：`panic: <message>`\n- **无法**通过 try/catch 捕获\n- 用于 bug 和不可恢复的错误\n\n### Panic vs Throw\n\n```hemlock\n// throw - 可恢复错误（可以被捕获）\ntry {\n    throw \"recoverable error\";\n} catch (e) {\n    print(\"Caught: \" + e);  // 成功捕获\n}\n\n// panic - 不可恢复错误（无法被捕获）\ntry {\n    panic(\"unrecoverable error\");  // 程序立即退出\n} catch (e) {\n    print(\"This never runs\");       // 永远不会执行\n}\n```\n\n### 何时使用 Panic\n\n**使用 panic 的情况：**\n- **Bug**：到达了不应该到达的代码\n- **无效状态**：检测到数据结构损坏\n- **不可恢复错误**：关键资源不可用\n- **断言失败**：当 `assert()` 不够用时\n\n**示例：**\n```hemlock\n// 不可达代码\nfn process_state(state: i32) {\n    if (state == 1) {\n        return \"ready\";\n    } else if (state == 2) {\n        return \"running\";\n    } else if (state == 3) {\n        return \"stopped\";\n    } else {\n        panic(\"invalid state: \" + typeof(state));  // 不应该发生\n    }\n}\n\n// 关键资源检查\nfn init_system() {\n    let config = read_file(\"config.json\");\n    if (config == null) {\n        panic(\"config.json not found - cannot start\");\n    }\n    // ...\n}\n\n// 数据结构不变量\nfn pop_stack(stack) {\n    if (stack.length == 0) {\n        panic(\"pop() called on empty stack\");\n    }\n    return stack.pop();\n}\n```\n\n### 何时不使用 Panic\n\n**以下情况使用 throw：**\n- 用户输入验证\n- 文件未找到\n- 网络错误\n- 预期的错误条件\n\n```hemlock\n// 不好：对预期错误使用 panic\nfn divide(a, b) {\n    if (b == 0) {\n        panic(\"division by zero\");  // 太严厉了\n    }\n    return a / b;\n}\n\n// 好：对预期错误使用 throw\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";  // 可恢复\n    }\n    return a / b;\n}\n```\n\n## 控制流交互\n\n### Try/Catch/Finally 中的 Return\n\n```hemlock\nfn example() {\n    try {\n        return 1;  // 在 finally 运行后返回 1\n    } finally {\n        print(\"cleanup\");\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // finally 的 return 覆盖 try 的 return - 返回 2\n    }\n}\n```\n\n**规则：** finally 块的返回值会覆盖 try/catch 的返回值。\n\n### Try/Catch/Finally 中的 Break/Continue\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) { break; }  // 在 finally 运行后 break\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```\n\n**规则：** break/continue 在 finally 块之后执行。\n\n### 嵌套 Try/Catch\n\n```hemlock\ntry {\n    try {\n        throw \"inner\";\n    } catch (e) {\n        print(\"Caught: \" + e);  // 打印：Caught: inner\n        throw \"outer\";  // 重新抛出不同错误\n    }\n} catch (e) {\n    print(\"Caught: \" + e);  // 打印：Caught: outer\n}\n```\n\n**规则：** 嵌套的 try/catch 块按预期工作，内层 catch 先执行。\n\n## 常见模式\n\n### 模式：资源清理\n\n始终使用 `finally` 进行清理：\n\n```hemlock\nfn process_file(filename) {\n    let file = null;\n    try {\n        file = open(filename);\n        let content = file.read();\n        process(content);\n    } catch (e) {\n        print(\"Error processing file: \" + e);\n    } finally {\n        if (file != null) {\n            file.close();  // 即使出错也会关闭\n        }\n    }\n}\n```\n\n### 模式：错误包装\n\n用上下文包装底层错误：\n\n```hemlock\nfn load_config(path) {\n    try {\n        let content = read_file(path);\n        return parse_json(content);\n    } catch (e) {\n        throw \"Failed to load config from \" + path + \": \" + e;\n    }\n}\n```\n\n### 模式：错误恢复\n\n出错时提供回退值：\n\n```hemlock\nfn safe_divide(a, b) {\n    try {\n        if (b == 0) {\n            throw \"division by zero\";\n        }\n        return a / b;\n    } catch (e) {\n        print(\"Error: \" + e);\n        return null;  // 回退值\n    }\n}\n```\n\n### 模式：验证\n\n使用异常进行验证：\n\n```hemlock\nfn validate_user(user) {\n    if (user.name == null || user.name == \"\") {\n        throw \"Name is required\";\n    }\n    if (user.age < 0 || user.age > 150) {\n        throw \"Invalid age\";\n    }\n    if (user.email == null || !user.email.contains(\"@\")) {\n        throw \"Invalid email\";\n    }\n}\n\ntry {\n    validate_user({ name: \"Alice\", age: -5, email: \"invalid\" });\n} catch (e) {\n    print(\"Validation failed: \" + e);\n}\n```\n\n### 模式：多种错误类型\n\n使用错误对象区分错误类型：\n\n```hemlock\nfn process_data(data) {\n    if (data == null) {\n        throw { type: \"NullData\", message: \"Data is null\" };\n    }\n\n    if (typeof(data) != \"array\") {\n        throw { type: \"TypeError\", message: \"Expected array\" };\n    }\n\n    if (data.length == 0) {\n        throw { type: \"EmptyData\", message: \"Array is empty\" };\n    }\n\n    // ... 处理\n}\n\ntry {\n    process_data(null);\n} catch (e) {\n    if (e.type == \"NullData\") {\n        print(\"No data provided\");\n    } else if (e.type == \"TypeError\") {\n        print(\"Wrong data type: \" + e.message);\n    } else {\n        print(\"Error: \" + e.message);\n    }\n}\n```\n\n## 最佳实践\n\n1. **对异常情况使用异常** - 不要用于正常控制流\n2. **抛出有意义的错误** - 使用带上下文的字符串或对象\n3. **始终使用 finally 进行清理** - 确保资源被释放\n4. **不要捕获后忽略** - 至少记录错误\n5. **适当时重新抛出** - 如果你无法处理，让调用者处理\n6. **对 bug 使用 panic** - 对不可恢复的错误使用 panic\n7. **文档化异常** - 明确说明哪些函数可能抛出异常\n\n## 常见陷阱\n\n### 陷阱：吞掉错误\n\n```hemlock\n// 不好：静默失败\ntry {\n    risky_operation();\n} catch (e) {\n    // 错误被忽略 - 静默失败\n}\n\n// 好：记录或处理\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Operation failed: \" + e);\n    // 适当处理\n}\n```\n\n### 陷阱：Finally 覆盖\n\n```hemlock\n// 不好：finally 覆盖返回值\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        return 0;  // 返回 0，而不是 42！\n    }\n}\n\n// 好：不要在 finally 中返回\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        cleanup();  // 只做清理，不返回\n    }\n}\n```\n\n### 陷阱：忘记清理\n\n```hemlock\n// 不好：出错时文件可能不会关闭\nfn process() {\n    let file = open(\"data.txt\");\n    let content = file.read();  // 可能抛出异常\n    file.close();  // 如果出错永远不会到达\n}\n\n// 好：使用 finally\nfn process() {\n    let file = null;\n    try {\n        file = open(\"data.txt\");\n        let content = file.read();\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n}\n```\n\n### 陷阱：对预期错误使用 Panic\n\n```hemlock\n// 不好：对预期错误使用 panic\nfn read_config(path) {\n    if (!file_exists(path)) {\n        panic(\"Config file not found\");  // 太严厉了\n    }\n    return read_file(path);\n}\n\n// 好：对预期错误使用 throw\nfn read_config(path) {\n    if (!file_exists(path)) {\n        throw \"Config file not found: \" + path;  // 可恢复\n    }\n    return read_file(path);\n}\n```\n\n## 示例\n\n### 示例：基本错误处理\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    print(divide(10, 0));\n} catch (e) {\n    print(\"Error: \" + e);  // 打印：Error: division by zero\n}\n```\n\n### 示例：资源管理\n\n```hemlock\nfn copy_file(src, dst) {\n    let src_file = null;\n    let dst_file = null;\n\n    try {\n        src_file = open(src, \"r\");\n        dst_file = open(dst, \"w\");\n\n        let content = src_file.read();\n        dst_file.write(content);\n\n        print(\"File copied successfully\");\n    } catch (e) {\n        print(\"Failed to copy file: \" + e);\n        throw e;  // 重新抛出\n    } finally {\n        if (src_file != null) { src_file.close(); }\n        if (dst_file != null) { dst_file.close(); }\n    }\n}\n```\n\n### 示例：嵌套错误处理\n\n```hemlock\nfn process_users(users) {\n    let success_count = 0;\n    let error_count = 0;\n\n    let i = 0;\n    while (i < users.length) {\n        try {\n            validate_user(users[i]);\n            save_user(users[i]);\n            success_count = success_count + 1;\n        } catch (e) {\n            print(\"Failed to process user: \" + e);\n            error_count = error_count + 1;\n        }\n        i = i + 1;\n    }\n\n    print(\"Processed: \" + typeof(success_count) + \" success, \" + typeof(error_count) + \" errors\");\n}\n```\n\n### 示例：自定义错误类型\n\n```hemlock\nfn create_error(type, message, details) {\n    return {\n        type: type,\n        message: message,\n        details: details,\n        toString: fn() {\n            return self.type + \": \" + self.message;\n        }\n    };\n}\n\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" && typeof(a) != \"f64\") {\n        throw create_error(\"TypeError\", \"a must be a number\", { value: a });\n    }\n    if (typeof(b) != \"i32\" && typeof(b) != \"f64\") {\n        throw create_error(\"TypeError\", \"b must be a number\", { value: b });\n    }\n    if (b == 0) {\n        throw create_error(\"DivisionByZero\", \"Cannot divide by zero\", { a: a, b: b });\n    }\n    return a / b;\n}\n\ntry {\n    divide(10, 0);\n} catch (e) {\n    print(e.toString());\n    if (e.type == \"DivisionByZero\") {\n        print(\"Details: a=\" + typeof(e.details.a) + \", b=\" + typeof(e.details.b));\n    }\n}\n```\n\n### 示例：重试逻辑\n\n```hemlock\nfn retry(operation, max_attempts) {\n    let attempt = 0;\n\n    while (attempt < max_attempts) {\n        try {\n            return operation();  // 成功！\n        } catch (e) {\n            attempt = attempt + 1;\n            if (attempt >= max_attempts) {\n                throw \"Operation failed after \" + typeof(max_attempts) + \" attempts: \" + e;\n            }\n            print(\"Attempt \" + typeof(attempt) + \" failed, retrying...\");\n        }\n    }\n}\n\nfn unreliable_operation() {\n    // 模拟不稳定的操作\n    if (random() < 0.7) {\n        throw \"Operation failed\";\n    }\n    return \"Success\";\n}\n\ntry {\n    let result = retry(unreliable_operation, 3);\n    print(result);\n} catch (e) {\n    print(\"All retries failed: \" + e);\n}\n```\n\n## 执行顺序\n\n理解执行顺序：\n\n```hemlock\ntry {\n    print(\"1: try block start\");\n    throw \"error\";\n    print(\"2: never reached\");\n} catch (e) {\n    print(\"3: catch block\");\n} finally {\n    print(\"4: finally block\");\n}\nprint(\"5: after try/catch/finally\");\n\n// 输出：\n// 1: try block start\n// 3: catch block\n// 4: finally block\n// 5: after try/catch/finally\n```\n\n## 当前限制\n\n- **没有堆栈跟踪** - 未捕获的异常不显示堆栈跟踪（已计划）\n- **某些内置函数会退出** - 某些内置函数仍然使用 `exit()` 而不是抛出异常（待审查）\n- **没有自定义异常类型** - 任何值都可以被抛出，但没有正式的异常层次结构\n\n## 相关主题\n\n- [函数](#language-guide-functions) - 异常和函数返回\n- [控制流](#language-guide-control-flow) - 异常如何影响控制流\n- [内存](#language-guide-memory) - 使用 finally 进行内存清理\n\n## 另请参阅\n\n- **异常语义**：参见 CLAUDE.md 中的\"错误处理\"部分\n- **Panic vs Throw**：不同错误类型的不同用例\n- **Finally 保证**：始终执行，即使有 return/break/continue\n"}, "Language Guide -> Functions": {"id": "language-guide-functions", "content": "# 函数\n\nHemlock 中的函数是**一等公民**，可以赋值给变量、作为参数传递以及从其他函数返回。本指南涵盖函数语法、闭包、递归和高级模式。\n\n## 概述\n\n```hemlock\n// 命名函数语法\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\n// 匿名函数\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\n// 闭包\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nprint(add5(3));  // 8\n```\n\n## 函数声明\n\n### 命名函数\n\n```hemlock\nfn greet(name: string): string {\n    return \"Hello, \" + name;\n}\n\nlet msg = greet(\"Alice\");  // \"Hello, Alice\"\n```\n\n**组成部分：**\n- `fn` - 函数关键字\n- `greet` - 函数名\n- `(name: string)` - 带可选类型的参数\n- `: string` - 可选的返回类型\n- `{ ... }` - 函数体\n\n### 匿名函数\n\n没有名称的函数，赋值给变量：\n\n```hemlock\nlet square = fn(x) {\n    return x * x;\n};\n\nprint(square(5));  // 25\n```\n\n**命名函数 vs 匿名函数：**\n```hemlock\n// 这两种方式等价：\nfn add(a, b) { return a + b; }\n\nlet add = fn(a, b) { return a + b; };\n```\n\n**注意：** 命名函数会被解语法糖为带匿名函数的变量赋值。\n\n## 参数\n\n### 基本参数\n\n```hemlock\nfn example(a, b, c) {\n    return a + b + c;\n}\n\nlet result = example(1, 2, 3);  // 6\n```\n\n### 类型注解\n\n参数的可选类型注解：\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);      // OK\nadd(5, 10.5);    // 运行时类型检查会提升为 f64\n```\n\n**类型检查：**\n- 如果有注解，参数类型在调用时检查\n- 隐式类型转换遵循标准提升规则\n- 类型不匹配会导致运行时错误\n\n### 按值传递\n\n所有参数都是**复制**的（按值传递）：\n\n```hemlock\nfn modify(x) {\n    x = 100;  // 只修改本地副本\n}\n\nlet a = 10;\nmodify(a);\nprint(a);  // 仍然是 10（未改变）\n```\n\n**注意：** 对象和数组按引用传递（引用被复制），因此可以修改它们的内容：\n\n```hemlock\nfn modify_array(arr) {\n    arr[0] = 99;  // 修改原始数组\n}\n\nlet a = [1, 2, 3];\nmodify_array(a);\nprint(a[0]);  // 99（已修改）\n```\n\n## 返回值\n\n### Return 语句\n\n```hemlock\nfn get_max(a: i32, b: i32): i32 {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n```\n\n### 返回类型注解\n\n返回值的可选类型注解：\n\n```hemlock\nfn calculate(): f64 {\n    return 3.14159;\n}\n\nfn get_name(): string {\n    return \"Alice\";\n}\n```\n\n**类型检查：**\n- 如果有注解，返回类型在函数返回时检查\n- 类型转换遵循标准提升规则\n\n### 隐式返回\n\n没有返回类型注解的函数隐式返回 `null`：\n\n```hemlock\nfn print_message(msg) {\n    print(msg);\n    // 隐式返回 null\n}\n\nlet result = print_message(\"hello\");  // result 是 null\n```\n\n### 提前返回\n\n```hemlock\nfn find_first_negative(arr) {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // 提前退出\n        }\n    }\n    return -1;  // 未找到\n}\n```\n\n### 无值返回\n\n`return;` 不带值返回 `null`：\n\n```hemlock\nfn maybe_process(value) {\n    if (value < 0) {\n        return;  // 返回 null\n    }\n    return value * 2;\n}\n```\n\n## 一等函数\n\n函数可以像其他值一样被赋值、传递和返回。\n\n### 函数作为变量\n\n```hemlock\nlet operation = fn(x, y) { return x + y; };\n\nprint(operation(5, 3));  // 8\n\n// 重新赋值\noperation = fn(x, y) { return x * y; };\nprint(operation(5, 3));  // 15\n```\n\n### 函数作为参数\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 5);  // 10\n```\n\n### 函数作为返回值\n\n```hemlock\nfn get_operation(op: string) {\n    if (op == \"add\") {\n        return fn(a, b) { return a + b; };\n    } else if (op == \"multiply\") {\n        return fn(a, b) { return a * b; };\n    } else {\n        return fn(a, b) { return 0; };\n    }\n}\n\nlet add = get_operation(\"add\");\nprint(add(5, 3));  // 8\n```\n\n## 闭包\n\n函数捕获其定义环境（词法作用域）。\n\n### 基本闭包\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n**工作原理：**\n- 内部函数从外部作用域捕获 `count`\n- `count` 在返回函数的多次调用间持久化\n- 每次调用 `makeCounter()` 都会创建一个带有自己 `count` 的新闭包\n\n### 带参数的闭包\n\n```hemlock\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\n\nprint(add5(3));   // 8\nprint(add10(3));  // 13\n```\n\n### 多个闭包\n\n```hemlock\nfn makeOperations(x) {\n    let add = fn(y) { return x + y; };\n    let multiply = fn(y) { return x * y; };\n\n    return { add: add, multiply: multiply };\n}\n\nlet ops = makeOperations(5);\nprint(ops.add(3));       // 8\nprint(ops.multiply(3));  // 15\n```\n\n### 词法作用域\n\n函数可以通过词法作用域访问外部作用域变量：\n\n```hemlock\nlet global = 10;\n\nfn outer() {\n    let outer_var = 20;\n\n    fn inner() {\n        // 可以读取 global 和 outer_var\n        print(global);      // 10\n        print(outer_var);   // 20\n    }\n\n    inner();\n}\n\nouter();\n```\n\n闭包通过引用捕获变量，允许读取和修改外部作用域变量（如上面的 `makeCounter` 示例所示）。\n\n## 递归\n\n函数可以调用自身。\n\n### 基本递归\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### 互递归\n\n函数可以互相调用：\n\n```hemlock\nfn is_even(n: i32): bool {\n    if (n == 0) {\n        return true;\n    }\n    return is_odd(n - 1);\n}\n\nfn is_odd(n: i32): bool {\n    if (n == 0) {\n        return false;\n    }\n    return is_even(n - 1);\n}\n\nprint(is_even(4));  // true\nprint(is_odd(4));   // false\n```\n\n### 递归数据处理\n\n```hemlock\nfn sum_array(arr: array, index: i32): i32 {\n    if (index >= arr.length) {\n        return 0;\n    }\n    return arr[index] + sum_array(arr, index + 1);\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(sum_array(numbers, 0));  // 15\n```\n\n**注意：** 尚无尾调用优化 - 深度递归可能导致栈溢出。\n\n## 高阶函数\n\n接受或返回其他函数的函数。\n\n### Map 模式\n\n```hemlock\nfn map(arr, f) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        result.push(f(arr[i]));\n        i = i + 1;\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = map(numbers, double);  // [2, 4, 6, 8, 10]\n```\n\n### Filter 模式\n\n```hemlock\nfn filter(arr, predicate) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (predicate(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nfn is_even(x) { return x % 2 == 0; }\n\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = filter(numbers, is_even);  // [2, 4, 6]\n```\n\n### Reduce 模式\n\n```hemlock\nfn reduce(arr, f, initial) {\n    let accumulator = initial;\n    let i = 0;\n    while (i < arr.length) {\n        accumulator = f(accumulator, arr[i]);\n        i = i + 1;\n    }\n    return accumulator;\n}\n\nfn add(a, b) { return a + b; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = reduce(numbers, add, 0);  // 15\n```\n\n### 函数组合\n\n```hemlock\nfn compose(f, g) {\n    return fn(x) {\n        return f(g(x));\n    };\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\n\nlet double_then_increment = compose(increment, double);\nprint(double_then_increment(5));  // 11 (5*2 + 1)\n```\n\n## 常见模式\n\n### 模式：工厂函数\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```\n\n### 模式：回调函数\n\n```hemlock\nfn process_async(data, callback) {\n    // ... 处理\n    callback(data);\n}\n\nprocess_async(\"test\", fn(result) {\n    print(\"Processing complete: \" + result);\n});\n```\n\n### 模式：部分应用\n\n```hemlock\nfn partial(f, x) {\n    return fn(y) {\n        return f(x, y);\n    };\n}\n\nfn multiply(a, b) {\n    return a * b;\n}\n\nlet double = partial(multiply, 2);\nlet triple = partial(multiply, 3);\n\nprint(double(5));  // 10\nprint(triple(5));  // 15\n```\n\n### 模式：记忆化\n\n```hemlock\nfn memoize(f) {\n    let cache = {};\n\n    return fn(x) {\n        if (cache.has(x)) {\n            return cache[x];\n        }\n\n        let result = f(x);\n        cache[x] = result;\n        return result;\n    };\n}\n\nfn expensive_fibonacci(n) {\n    if (n <= 1) { return n; }\n    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);\n}\n\nlet fast_fib = memoize(expensive_fibonacci);\nprint(fast_fib(10));  // 使用缓存会快很多\n```\n\n## 函数语义\n\n### 返回类型要求\n\n带有返回类型注解的函数**必须**返回值：\n\n```hemlock\nfn get_value(): i32 {\n    // 错误：缺少 return 语句\n}\n\nfn get_value(): i32 {\n    return 42;  // OK\n}\n```\n\n### 类型检查\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);        // OK\nadd(5.5, 10.5);    // 提升为 f64，返回 f64\nadd(\"a\", \"b\");     // 运行时错误：类型不匹配\n```\n\n### 作用域规则\n\n```hemlock\nlet global = \"global\";\n\nfn outer() {\n    let outer_var = \"outer\";\n\n    fn inner() {\n        let inner_var = \"inner\";\n        // 可以访问：inner_var、outer_var、global\n    }\n\n    // 可以访问：outer_var、global\n    // 不能访问：inner_var\n}\n\n// 可以访问：global\n// 不能访问：outer_var、inner_var\n```\n\n## 最佳实践\n\n1. **使用类型注解** - 有助于发现错误并记录意图\n2. **保持函数小巧** - 每个函数应只做一件事\n3. **优先使用纯函数** - 尽可能避免副作用\n4. **命名要清晰** - 使用描述性的动词名称\n5. **提前返回** - 使用守卫子句减少嵌套\n6. **记录复杂闭包** - 明确捕获的变量\n7. **避免深度递归** - 尚无尾调用优化\n\n## 常见陷阱\n\n### 陷阱：递归深度\n\n```hemlock\n// 深度递归可能导致栈溢出\nfn count_down(n) {\n    if (n == 0) { return; }\n    count_down(n - 1);\n}\n\ncount_down(100000);  // 可能因栈溢出而崩溃\n```\n\n### 陷阱：修改捕获的变量\n\n```hemlock\nfn make_counter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // 可以读取和修改捕获的变量\n        return count;\n    };\n}\n```\n\n**注意：** 这是可行的，但要注意所有闭包共享同一个捕获的环境。\n\n## 示例\n\n### 示例：函数管道\n\n```hemlock\nfn pipeline(value, ...functions) {\n    let result = value;\n    for (f in functions) {\n        result = f(result);\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\nfn square(x) { return x * x; }\n\nlet result = pipeline(3, double, increment, square);\nprint(result);  // 49 ((3*2+1)^2)\n```\n\n### 示例：事件处理器\n\n```hemlock\nlet handlers = [];\n\nfn on_event(name: string, handler) {\n    handlers.push({ name: name, handler: handler });\n}\n\nfn trigger_event(name: string, data) {\n    let i = 0;\n    while (i < handlers.length) {\n        if (handlers[i].name == name) {\n            handlers[i].handler(data);\n        }\n        i = i + 1;\n    }\n}\n\non_event(\"click\", fn(data) {\n    print(\"Clicked: \" + data);\n});\n\ntrigger_event(\"click\", \"button1\");\n```\n\n### 示例：自定义比较器排序\n\n```hemlock\nfn sort(arr, compare) {\n    // 使用自定义比较器的冒泡排序\n    let n = arr.length;\n    let i = 0;\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (compare(arr[j], arr[j + 1]) > 0) {\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nfn ascending(a, b) {\n    if (a < b) { return -1; }\n    if (a > b) { return 1; }\n    return 0;\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers, ascending);\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## 可选参数（默认参数）\n\n函数可以使用 `?:` 语法定义带默认值的可选参数：\n\n```hemlock\nfn greet(name, greeting?: \"Hello\") {\n    return greeting + \" \" + name;\n}\n\nprint(greet(\"Alice\"));           // \"Hello Alice\"\nprint(greet(\"Bob\", \"Hi\"));       // \"Hi Bob\"\n\nfn add(a, b?: 10, c?: 100) {\n    return a + b + c;\n}\n\nprint(add(1));          // 111 (1 + 10 + 100)\nprint(add(1, 2));       // 103 (1 + 2 + 100)\nprint(add(1, 2, 3));    // 6   (1 + 2 + 3)\n```\n\n**规则：**\n- 可选参数必须在必需参数之后\n- 默认值可以是任何表达式\n- 省略的参数使用默认值\n\n## 可变参数函数（剩余参数）\n\n函数可以使用剩余参数（`...`）接受可变数量的参数：\n\n```hemlock\nfn sum(...args) {\n    let total = 0;\n    for (arg in args) {\n        total = total + arg;\n    }\n    return total;\n}\n\nprint(sum(1, 2, 3));        // 6\nprint(sum(1, 2, 3, 4, 5));  // 15\nprint(sum());               // 0\n\nfn log(prefix, ...messages) {\n    for (msg in messages) {\n        print(prefix + \": \" + msg);\n    }\n}\n\nlog(\"INFO\", \"Starting\", \"Running\", \"Done\");\n// INFO: Starting\n// INFO: Running\n// INFO: Done\n```\n\n**规则：**\n- 剩余参数必须是最后一个参数\n- 剩余参数将所有剩余参数收集到一个数组中\n- 可以与普通参数和可选参数组合使用\n\n## 函数类型注解\n\n函数类型允许你为函数参数和返回值指定精确的签名：\n\n### 基本函数类型\n\n```hemlock\n// 函数类型语法：fn(param_types): return_type\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\nlet double = fn(n) { return n * 2; };\nlet result = apply(double, 5);  // 10\n```\n\n### 高阶函数类型\n\n```hemlock\n// 返回函数的函数\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\nlet add5 = make_adder(5);\nprint(add5(10));  // 15\n```\n\n### 异步函数类型\n\n```hemlock\n// 异步函数类型\nfn run_task(handler: async fn(): void) {\n    spawn(handler);\n}\n\nrun_task(async fn() {\n    print(\"Running async!\");\n});\n```\n\n### 函数类型别名\n\n```hemlock\n// 创建命名函数类型以提高清晰度\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\nfn filter_with(arr: array, pred: Predicate): array {\n    return arr.filter(pred);\n}\n```\n\n## Const 参数\n\n`const` 修饰符防止在函数内修改参数：\n\n### 基本 Const 参数\n\n```hemlock\nfn print_all(const items: array) {\n    // items.push(4);  // 错误：不能修改 const 参数\n    for (item in items) {\n        print(item);   // OK：允许读取\n    }\n}\n\nlet nums = [1, 2, 3];\nprint_all(nums);\n```\n\n### 深度不可变性\n\nConst 参数强制深度不可变性 - 不能通过任何路径进行修改：\n\n```hemlock\nfn describe(const person: object) {\n    print(person.name);       // OK：允许读取\n    // person.name = \"Bob\";   // 错误：不能修改\n    // person.address.city = \"NYC\";  // 错误：深度 const\n}\n```\n\n### Const 阻止的操作\n\n| 类型 | 被 Const 阻止 | 允许的 |\n|------|--------------|-------|\n| array | push, pop, shift, unshift, insert, remove, clear, reverse | slice, concat, map, filter, find, contains |\n| object | 字段赋值 | 字段读取 |\n| buffer | 索引赋值 | 索引读取 |\n| string | 索引赋值 | 所有方法（返回新字符串） |\n\n## 命名参数\n\n函数可以使用命名参数调用以提高清晰度和灵活性：\n\n### 基本命名参数\n\n```hemlock\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" is \" + age + \" years old\");\n}\n\n// 位置参数（传统方式）\ncreate_user(\"Alice\", 25, false);\n\n// 命名参数 - 可以任意顺序\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n```\n\n### 混合位置参数和命名参数\n\n```hemlock\n// 通过命名来跳过可选参数\ncreate_user(\"David\", active: false);  // 使用默认 age=18\n\n// 命名参数必须在位置参数之后\ncreate_user(\"Eve\", age: 21);          // OK\n// create_user(name: \"Bad\", 25);      // 错误：位置参数在命名参数之后\n```\n\n### 命名参数规则\n\n- 使用 `name: value` 语法表示命名参数\n- 命名参数可以在位置参数之后以任意顺序出现\n- 位置参数不能跟在命名参数之后\n- 与默认/可选参数配合使用\n- 未知的参数名会导致运行时错误\n\n## 限制\n\n需要注意的当前限制：\n\n- **无按引用传递** - `ref` 关键字已解析但未实现\n- **无函数重载** - 每个名称只能有一个函数\n- **无尾调用优化** - 深度递归受栈大小限制\n\n## 相关主题\n\n- [Control Flow](#language-guide-control-flow) - 函数与控制结构的配合使用\n- [Objects](#language-guide-objects) - 方法是存储在对象中的函数\n- [Error Handling](#language-guide-error-handling) - 函数和异常处理\n- [Types](#language-guide-types) - 类型注解和转换\n\n## 另请参阅\n\n- **闭包**：参见 CLAUDE.md 中的\"Functions\"部分了解闭包语义\n- **一等公民**：函数是与其他值一样的值\n- **词法作用域**：函数捕获其定义环境\n"}, "Language Guide -> Memory": {"id": "language-guide-memory", "content": "# 内存管理\n\nHemlock 采用**手动内存管理**，对分配和释放有显式控制。本指南涵盖 Hemlock 的内存模型、两种指针类型以及完整的内存 API。\n\n---\n\n## 内存基础 101\n\n**编程新手？** 从这里开始。如果你已经理解内存管理，可以跳到 [设计理念](#设计理念)。\n\n### 什么是内存管理？\n\n当你的程序需要存储数据（文本、数字、列表）时，它需要空间来放置这些数据。这个空间来自计算机的内存（RAM）。内存管理涉及：\n\n1. **获取空间** - 需要时请求内存\n2. **使用空间** - 读写数据\n3. **归还空间** - 完成后返还内存\n\n### 为什么重要？\n\n想象一个书籍有限的图书馆：\n- 如果你不断借书却从不归还，最终就没有书可借了\n- 如果你试图阅读已经归还的书，会产生混乱或问题\n\n内存的工作方式相同。如果你忘记归还内存，程序会逐渐使用越来越多的内存（\"内存泄漏\"）。如果你在归还后尝试使用内存，会发生糟糕的事情。\n\n### 好消息\n\n**大多数时候，你不需要考虑这些！**\n\nHemlock 自动清理大多数常见类型：\n\n```hemlock\nfn example() {\n    let name = \"Alice\";       // Hemlock 管理这个\n    let numbers = [1, 2, 3];  // 还有这个\n    let person = { age: 30 }; // 还有这个\n\n    // 函数结束时，所有这些都自动清理！\n}\n```\n\n### 何时需要考虑\n\n只有在使用以下情况时才需要手动内存管理：\n\n1. **`alloc()`** - 原始内存分配（返回 `ptr`）\n2. **`buffer()`** - 当你想提前释放时（可选 - 作用域结束时自动释放）\n\n```hemlock\n// 这需要手动清理：\nlet raw = alloc(100);   // 原始内存 - 你必须释放它\n// ... 使用 raw ...\nfree(raw);              // 必需！否则会有内存泄漏\n\n// 这自动清理（但你可以提前释放）：\nlet buf = buffer(100);  // 安全 buffer\n// ... 使用 buf ...\n// free(buf);           // 可选 - 作用域结束时自动释放\n```\n\n### 简单规则\n\n> **如果你调用 `alloc()`，你必须调用 `free()`。**\n>\n> 其他一切都会为你处理。\n\n### 应该使用哪个？\n\n| 场景 | 使用这个 | 原因 |\n|-----------|----------|-----|\n| **刚开始学习** | `buffer()` | 安全、有边界检查、自动清理 |\n| **需要字节存储** | `buffer()` | 安全且简单 |\n| **与 C 库交互（FFI）** | `alloc()` / `ptr` | C 互操作必需 |\n| **最大性能** | `alloc()` / `ptr` | 无边界检查开销 |\n| **不确定** | `buffer()` | 总是更安全的选择 |\n\n### 快速示例：安全与原始\n\n```hemlock\n// 推荐：安全 buffer\nfn safe_example() {\n    let data = buffer(10);\n    data[0] = 65;           // 正确\n    data[5] = 66;           // 正确\n    // data[100] = 67;      // 错误 - Hemlock 阻止你（边界检查）\n    free(data);             // 清理\n}\n\n// 高级：原始指针（仅在需要时使用）\nfn raw_example() {\n    let data = alloc(10);\n    *data = 65;             // 正确\n    *(data + 5) = 66;       // 正确\n    *(data + 100) = 67;     // 危险 - 无边界检查，破坏内存！\n    free(data);             // 清理\n}\n```\n\n**从 `buffer()` 开始。只有在特别需要原始指针时才使用 `alloc()`。**\n\n---\n\n## 设计理念\n\nHemlock 遵循显式内存管理与合理默认值的原则：\n- 无垃圾回收（无不可预测的暂停）\n- 常见类型的内部引用计数（string, array, object, buffer）\n- 原始指针（`ptr`）需要手动 `free()`\n\n这种混合方法在需要时给你完全控制（原始指针），同时防止典型用例的常见错误（引用计数类型在作用域退出时自动释放）。\n\n## 内部引用计数\n\n运行时使用**内部引用计数**来管理对象生命周期。对于大多数引用计数类型的局部变量，清理是自动且确定性的。\n\n### 引用计数处理什么\n\n运行时在以下情况自动管理引用计数：\n\n1. **变量重新赋值** - 旧值被释放：\n   ```hemlock\n   let x = \"first\";   // ref_count = 1\n   x = \"second\";      // \"first\" 内部释放，\"second\" ref_count = 1\n   ```\n\n2. **作用域退出** - 局部变量被释放：\n   ```hemlock\n   fn example() {\n       let arr = [1, 2, 3];  // ref_count = 1\n   }  // 函数返回时 arr 被释放\n   ```\n\n3. **容器被释放** - 元素被释放：\n   ```hemlock\n   let arr = [obj1, obj2];\n   free(arr);  // obj1 和 obj2 的 ref_count 递减\n   ```\n\n### 何时需要 `free()` vs 何时自动\n\n**自动（不需要 `free()`）：** 引用计数类型的局部变量在作用域退出时释放：\n\n```hemlock\nfn process_data() {\n    let arr = [1, 2, 3];\n    let obj = { name: \"test\" };\n    let buf = buffer(64);\n    // ... 使用它们 ...\n}  // 函数返回时全部自动释放 - 不需要 free()\n```\n\n**需要手动 `free()`：**\n\n1. **原始指针** - `alloc()` 没有引用计数：\n   ```hemlock\n   let p = alloc(64);\n   // ... 使用 p ...\n   free(p);  // 总是需要 - 否则会泄漏\n   ```\n\n2. **提前清理** - 在作用域结束前释放以更早释放内存：\n   ```hemlock\n   fn long_running() {\n       let big = buffer(10000000);  // 10MB\n       // ... 用完 big ...\n       free(big);  // 现在释放，不等函数返回\n       // ... 更多不需要 big 的工作 ...\n   }\n   ```\n\n3. **长期存活的数据** - 全局数据或存储在持久结构中的数据：\n   ```hemlock\n   let cache = {};  // 模块级别，除非释放否则存活到程序退出\n\n   fn cleanup() {\n       free(cache);  // 长期存活数据的手动清理\n   }\n   ```\n\n### 引用计数 vs 垃圾回收\n\n| 方面 | Hemlock 引用计数 | 垃圾回收 |\n|--------|---------------------|-------------------|\n| 清理时机 | 确定性（ref 为 0 时立即清理） | 非确定性（GC 决定何时） |\n| 用户责任 | 必须调用 `free()` | 完全自动 |\n| 运行时暂停 | 无 | \"停止世界\"暂停 |\n| 可见性 | 隐藏的实现细节 | 通常不可见 |\n| 循环引用 | 通过 visited-set 跟踪处理 | 通过追踪处理 |\n\n### 哪些类型有引用计数\n\n| 类型 | 引用计数 | 备注 |\n|------|------------|-------|\n| `ptr` | 否 | 总是需要手动 `free()` |\n| `buffer` | 是 | 作用域退出时自动释放；手动 `free()` 用于提前清理 |\n| `array` | 是 | 作用域退出时自动释放；手动 `free()` 用于提前清理 |\n| `object` | 是 | 作用域退出时自动释放；手动 `free()` 用于提前清理 |\n| `string` | 是 | 完全自动，不需要 `free()` |\n| `function` | 是 | 完全自动（闭包环境） |\n| `task` | 是 | 线程安全的原子引用计数 |\n| `channel` | 是 | 线程安全的原子引用计数 |\n| 基本类型 | 否 | 栈分配，无堆分配 |\n\n### 为什么这样设计？\n\n这种混合方法给你：\n- **显式控制** - 你决定何时释放\n- **作用域错误安全** - 重新赋值不会泄漏\n- **可预测性能** - 无 GC 暂停\n- **闭包支持** - 函数可以安全捕获变量\n\n理念保持不变：你在控制，但运行时帮助防止常见错误，如重新赋值时的泄漏或容器中的双重释放。\n\n## 两种指针类型\n\nHemlock 提供两种不同的指针类型，具有不同的安全特性：\n\n### `ptr` - 原始指针（危险）\n\n原始指针**只是地址**，安全保证最少：\n\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // 你必须记得释放\n```\n\n**特性：**\n- 只是一个 8 字节地址\n- 无边界检查\n- 无长度跟踪\n- 用户完全管理生命周期\n- 适合专家和 FFI\n\n**使用场景：**\n- 底层系统编程\n- 外部函数接口（FFI）\n- 性能关键代码\n- 需要完全控制时\n\n**危险：**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // 远超分配范围 - 允许但危险\nfree(p);\nlet x = *p;       // 悬空指针 - 未定义行为\nfree(p);          // 双重释放 - 会崩溃\n```\n\n### `buffer` - 安全包装（推荐）\n\nBuffer 提供**边界检查访问**，同时仍需要手动释放：\n\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // 边界检查\nprint(b.length);        // 64\nfree(b);                // 仍然是手动的\n```\n\n**特性：**\n- 指针 + 长度 + 容量\n- 访问时边界检查\n- 仍需要手动 `free()`\n- 大多数代码的更好默认选择\n\n**属性：**\n```hemlock\nlet buf = buffer(100);\nprint(buf.length);      // 100（当前大小）\nprint(buf.capacity);    // 100（分配的容量）\n```\n\n**边界检查：**\n```hemlock\nlet buf = buffer(10);\nbuf[5] = 42;      // 正确\nbuf[100] = 42;    // 错误：索引越界\n```\n\n## 内存 API\n\n### 核心分配\n\n**`alloc(bytes)` - 分配原始内存**\n```hemlock\nlet p = alloc(1024);  // 分配 1KB，返回 ptr\n// ... 使用内存\nfree(p);\n```\n\n**`buffer(size)` - 分配安全 buffer**\n```hemlock\nlet buf = buffer(256);  // 分配 256 字节 buffer\nbuf[0] = 65;            // 'A'\nbuf[1] = 66;            // 'B'\nfree(buf);\n```\n\n**`free(ptr)` - 释放内存**\n```hemlock\nlet p = alloc(100);\nfree(p);  // 必须释放以避免内存泄漏\n\nlet buf = buffer(100);\nfree(buf);  // 对 ptr 和 buffer 都有效\n```\n\n**重要：** `free()` 对 `ptr` 和 `buffer` 类型都有效。\n\n### 内存操作\n\n**`memset(ptr, byte, size)` - 填充内存**\n```hemlock\nlet p = alloc(100);\nmemset(p, 0, 100);     // 将 100 字节清零\nmemset(p, 65, 10);     // 将前 10 字节填充为 'A'\nfree(p);\n```\n\n**`memcpy(dest, src, size)` - 复制内存**\n```hemlock\nlet src = alloc(50);\nlet dst = alloc(50);\nmemset(src, 42, 50);\nmemcpy(dst, src, 50);  // 从 src 复制 50 字节到 dst\nfree(src);\nfree(dst);\n```\n\n**`realloc(ptr, size)` - 调整分配大小**\n```hemlock\nlet p = alloc(100);\n// ... 使用 100 字节\np = realloc(p, 200);   // 调整为 200 字节\n// ... 使用 200 字节\nfree(p);\n```\n\n**注意：** `realloc()` 后，旧指针可能无效。始终使用返回的指针。\n\n### 类型化分配\n\nHemlock 提供类型化分配辅助函数以方便使用：\n\n```hemlock\nlet arr = talloc(i32, 100);  // 分配 100 个 i32 值（400 字节）\nlet size = sizeof(i32);      // 返回 4（字节）\n```\n\n**`sizeof(type)`** 返回类型的字节大小：\n- `sizeof(i8)` / `sizeof(u8)` -> 1\n- `sizeof(i16)` / `sizeof(u16)` -> 2\n- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` -> 4\n- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` -> 8\n- `sizeof(ptr)` -> 8（64 位系统）\n\n**`talloc(type, count)`** 分配 `count` 个 `type` 类型的元素：\n\n```hemlock\nlet ints = talloc(i32, 10);   // 40 字节用于 10 个 i32 值\nlet floats = talloc(f64, 5);  // 40 字节用于 5 个 f64 值\nfree(ints);\nfree(floats);\n```\n\n## 常见模式\n\n### 模式：分配、使用、释放\n\n内存管理的基本模式：\n\n```hemlock\n// 1. 分配\nlet data = alloc(1024);\n\n// 2. 使用\nmemset(data, 0, 1024);\n// ... 做工作\n\n// 3. 释放\nfree(data);\n```\n\n### 模式：安全 Buffer 使用\n\n优先使用 buffer 进行边界检查访问：\n\n```hemlock\nlet buf = buffer(256);\n\n// 安全迭代\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\nfree(buf);\n```\n\n### 模式：使用 try/finally 管理资源\n\n即使出错也确保清理：\n\n```hemlock\nlet data = alloc(1024);\ntry {\n    // ... 风险操作\n    process(data);\n} finally {\n    free(data);  // 即使出错也会释放\n}\n```\n\n## 内存安全注意事项\n\n### 双重释放\n\n**允许但会崩溃：**\n```hemlock\nlet p = alloc(100);\nfree(p);\nfree(p);  // 崩溃：检测到双重释放\n```\n\n**预防：**\n```hemlock\nlet p = alloc(100);\nfree(p);\np = null;  // 释放后设为 null\n\nif (p != null) {\n    free(p);  // 不会执行\n}\n```\n\n### 悬空指针\n\n**允许但未定义行为：**\n```hemlock\nlet p = alloc(100);\n*p = 42;      // 正确\nfree(p);\nlet x = *p;   // 未定义：读取已释放内存\n```\n\n**预防：** 释放后不要访问内存。\n\n### 内存泄漏\n\n**容易创建，难以调试：**\n```hemlock\nfn leak_memory() {\n    let p = alloc(1000);\n    // 忘记释放！\n    return;  // 内存泄漏\n}\n```\n\n**预防：** 始终将 `alloc()` 与 `free()` 配对：\n```hemlock\nfn safe_function() {\n    let p = alloc(1000);\n    try {\n        // ... 使用 p\n    } finally {\n        free(p);  // 总是释放\n    }\n}\n```\n\n### 指针算术\n\n**允许但危险：**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // 远超分配边界\n*q = 42;          // 未定义：越界写入\nfree(p);\n```\n\n**使用 buffer 进行边界检查：**\n```hemlock\nlet buf = buffer(10);\nbuf[100] = 42;  // 错误：边界检查阻止溢出\n```\n\n## 最佳实践\n\n1. **默认使用 `buffer`** - 除非特别需要原始 `ptr` 否则使用 `buffer`\n2. **匹配 alloc/free** - 每个 `alloc()` 应该有且仅有一个 `free()`\n3. **使用 try/finally** - 使用异常处理确保清理\n4. **释放后置空** - 释放后将指针设为 `null` 以捕获释放后使用\n5. **边界检查** - 使用 buffer 索引进行自动边界检查\n6. **记录所有权** - 明确哪些代码拥有并释放每个分配\n\n## 示例\n\n### 示例：动态字符串构建器\n\n```hemlock\nfn build_message(count: i32): ptr {\n    let size = count * 10;\n    let buf = alloc(size);\n\n    let i = 0;\n    while (i < count) {\n        memset(buf + (i * 10), 65 + i, 10);\n        i = i + 1;\n    }\n\n    return buf;  // 调用者必须释放\n}\n\nlet msg = build_message(5);\n// ... 使用 msg\nfree(msg);\n```\n\n### 示例：安全数组操作\n\n```hemlock\nfn process_array(size: i32) {\n    let arr = buffer(size);\n\n    try {\n        // 填充数组\n        let i = 0;\n        while (i < arr.length) {\n            arr[i] = i * 2;\n            i = i + 1;\n        }\n\n        // 处理\n        i = 0;\n        while (i < arr.length) {\n            print(arr[i]);\n            i = i + 1;\n        }\n    } finally {\n        free(arr);  // 总是清理\n    }\n}\n```\n\n### 示例：内存池模式\n\n```hemlock\n// 简单内存池（简化版）\nlet pool = alloc(10000);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > 10000) {\n        throw \"Pool exhausted\";\n    }\n\n    let ptr = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return ptr;\n}\n\n// 使用池\nlet p1 = pool_alloc(100);\nlet p2 = pool_alloc(200);\n\n// 一次性释放整个池\nfree(pool);\n```\n\n## 限制\n\n需要注意的当前限制：\n\n- **原始指针需要手动释放** - `alloc()` 返回没有引用计数的 `ptr`\n- **无自定义分配器** - 只有系统 malloc/free\n\n**注意：** 引用计数类型（string, array, object, buffer）在作用域退出时自动释放。只有来自 `alloc()` 的原始 `ptr` 需要显式 `free()`。\n\n## 相关主题\n\n- [字符串](#language-guide-strings) - 字符串内存管理和 UTF-8 编码\n- [数组](#language-guide-arrays) - 动态数组及其内存特性\n- [对象](#language-guide-objects) - 对象分配和生命周期\n- [错误处理](#language-guide-error-handling) - 使用 try/finally 进行清理\n\n## 另请参阅\n\n- **设计理念**：参见 CLAUDE.md 中的 \"Memory Management\" 部分\n- **类型系统**：参见 [类型](#language-guide-types) 了解 `ptr` 和 `buffer` 类型详情\n- **FFI**：原始指针对外部函数接口至关重要\n"}, "Language Guide -> Modules": {"id": "language-guide-modules", "content": "# Hemlock 模块系统\n\n本文档描述了为 Hemlock 实现的 ES6 风格 import/export 模块系统。\n\n## 概述\n\nHemlock 支持基于文件的模块系统，使用 ES6 风格的 import/export 语法。模块具有以下特点：\n- **单例**：每个模块只加载一次并被缓存\n- **基于文件**：模块对应磁盘上的 .hml 文件\n- **显式导入**：依赖通过 import 语句声明\n- **拓扑执行**：依赖在依赖者之前执行\n\n有关包管理和第三方依赖，请参阅 [hpm (Hemlock 包管理器)](https://github.com/hemlang/hpm)。\n\n## 语法\n\n### Export 语句\n\n**内联命名导出：**\n```hemlock\nexport fn add(a, b) {\n    return a + b;\n}\n\nexport const PI = 3.14159;\nexport let counter = 0;\n```\n\n**导出列表：**\n```hemlock\nfn add(a, b) { return a + b; }\nfn subtract(a, b) { return a - b; }\n\nexport { add, subtract };\n```\n\n**导出 Extern（FFI 函数）：**\n```hemlock\nimport \"libc.so.6\";\n\n// 导出 FFI 函数供其他模块使用\nexport extern fn strlen(s: string): i32;\nexport extern fn getpid(): i32;\n```\n\n有关导出 FFI 函数的更多详细信息，请参阅 [FFI 文档](../advanced/ffi.md#exporting-ffi-functions)。\n\n**导出 Define（结构体类型）：**\n```hemlock\n// 导出结构体类型定义\nexport define Vector2 {\n    x: f32,\n    y: f32,\n}\n\nexport define Rectangle {\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n}\n```\n\n**重要说明：** 导出的结构体类型在模块加载时全局注册。当你从模块导入任何内容时，它们会自动可用 - 你不需要（也不能）通过名称显式导入它们：\n\n```hemlock\n// 正确 - 任何导入后结构体类型自动可用\nimport { some_function } from \"./my_module.hml\";\nlet v: Vector2 = { x: 1.0, y: 2.0 };  // 可以工作！\n\n// 错误 - 不能显式导入结构体类型\nimport { Vector2 } from \"./my_module.hml\";  // 错误：未定义变量 'Vector2'\n```\n\n有关导出结构体类型的更多详细信息，请参阅 [FFI 文档](../advanced/ffi.md#exporting-struct-types)。\n\n**重新导出：**\n```hemlock\n// 从另一个模块重新导出\nexport { add, subtract } from \"./math.hml\";\n```\n\n### Import 语句\n\n**命名导入：**\n```hemlock\nimport { add, subtract } from \"./math.hml\";\nprint(add(1, 2));  // 3\n```\n\n**命名空间导入：**\n```hemlock\nimport * as math from \"./math.hml\";\nprint(math.add(1, 2));  // 3\nprint(math.PI);  // 3.14159\n```\n\n**别名：**\n```hemlock\nimport { add as sum, subtract as diff } from \"./math.hml\";\nprint(sum(1, 2));  // 3\n```\n\n## 模块解析\n\n### 路径类型\n\n**相对路径：**\n```hemlock\nimport { foo } from \"./module.hml\";       // 同一目录\nimport { bar } from \"../parent.hml\";      // 父目录\nimport { baz } from \"./sub/nested.hml\";   // 子目录\n```\n\n**绝对路径：**\n```hemlock\nimport { foo } from \"/absolute/path/to/module.hml\";\n```\n\n**扩展名处理：**\n- `.hml` 扩展名可以省略 - 会自动添加\n- `./math` 解析为 `./math.hml`\n\n## 特性\n\n### 循环依赖检测\n\n模块系统检测循环依赖并报告错误：\n\n```\nError: Circular dependency detected when loading '/path/to/a.hml'\n```\n\n### 模块缓存\n\n模块只加载一次并被缓存。多次导入同一模块返回相同的实例：\n\n```hemlock\n// counter.hml\nexport let count = 0;\nexport fn increment() {\n    count = count + 1;\n}\n\n// a.hml\nimport { count, increment } from \"./counter.hml\";\nincrement();\nprint(count);  // 1\n\n// b.hml\nimport { count } from \"./counter.hml\";  // 同一实例！\nprint(count);  // 仍然是 1（共享状态）\n```\n\n### 导入不可变性\n\n导入的绑定不能被重新赋值：\n\n```hemlock\nimport { add } from \"./math.hml\";\nadd = fn() { };  // 错误：不能重新赋值导入的绑定\n```\n\n## 实现细节\n\n### 架构\n\n**文件：**\n- `include/module.h` - 模块系统 API\n- `src/module.c` - 模块加载、缓存和执行\n- `src/parser.c` 中的解析器支持\n- `src/interpreter/runtime.c` 中的运行时支持\n\n**关键组件：**\n1. **ModuleCache**：按绝对路径索引维护已加载的模块\n2. **Module**：表示带有 AST 和导出的已加载模块\n3. **路径解析**：将相对/绝对路径解析为规范路径\n4. **拓扑执行**：按依赖顺序执行模块\n\n### 模块加载过程\n\n1. **解析阶段**：对模块文件进行词法分析和语法分析\n2. **依赖解析**：递归加载导入的模块\n3. **循环检测**：检查模块是否已在加载中\n4. **缓存**：按绝对路径将模块存储在缓存中\n5. **执行阶段**：按拓扑顺序执行（依赖优先）\n\n### API\n\n```c\n// 高级 API\nint execute_file_with_modules(const char *file_path,\n                               int argc, char **argv,\n                               ExecutionContext *ctx);\n\n// 低级 API\nModuleCache* module_cache_new(const char *initial_dir);\nvoid module_cache_free(ModuleCache *cache);\nModule* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);\nvoid execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);\n```\n\n## 测试\n\n测试模块位于 `tests/modules/` 和 `tests/parity/modules/`：\n\n- `math.hml` - 带导出的基本模块\n- `test_import_named.hml` - 命名导入测试\n- `test_import_namespace.hml` - 命名空间导入测试\n- `test_import_alias.hml` - 导入别名测试\n- `export_extern.hml` - 导出 extern FFI 函数测试（Linux）\n\n## 包导入（hpm）\n\n安装 [hpm](https://github.com/hemlang/hpm) 后，你可以从 GitHub 导入第三方包：\n\n```hemlock\n// 从包根目录导入（使用 package.json 中的 \"main\"）\nimport { app, router } from \"hemlang/sprout\";\n\n// 从子路径导入\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// 标准库（内置于 Hemlock）\nimport { HashMap } from \"@stdlib/collections\";\n```\n\n包安装到 `hem_modules/` 并使用 GitHub `owner/repo` 语法解析。\n\n```bash\n# 安装包\nhpm install hemlang/sprout\n\n# 带版本约束安装\nhpm install hemlang/sprout@^1.0.0\n```\n\n有关完整详细信息，请参阅 [hpm 文档](https://github.com/hemlang/hpm)。\n\n## 当前限制\n\n1. **不支持动态导入**：`import()` 作为运行时函数不受支持\n2. **不支持条件导出**：导出必须在顶层\n3. **静态库路径**：FFI 库导入使用静态路径（特定于平台）\n\n## 未来工作\n\n- 使用 `import()` 函数的动态导入\n- 条件导出\n- 模块元数据（`import.meta`）\n- Tree shaking 和死代码消除\n\n## 示例\n\n有关模块系统的工作示例，请参阅 `tests/modules/`。\n\n示例模块结构：\n```\nproject/\n├── main.hml\n├── lib/\n│   ├── math.hml\n│   ├── string.hml\n│   └── index.hml (barrel 模块)\n└── utils/\n    └── helpers.hml\n```\n\n示例用法：\n```hemlock\n// lib/math.hml\nexport fn add(a, b) { return a + b; }\nexport fn multiply(a, b) { return a * b; }\n\n// lib/index.hml (barrel)\nexport { add, multiply } from \"./math.hml\";\n\n// main.hml\nimport { add } from \"./lib/index.hml\";\nprint(add(2, 3));  // 5\n```\n"}, "Language Guide -> Objects": {"id": "language-guide-objects", "content": "# 对象\n\nHemlock 实现了 JavaScript 风格的对象，具有堆分配、动态字段、方法和鸭子类型。对象是结合数据和行为的灵活数据结构。\n\n## 概述\n\n```hemlock\n// 匿名对象\nlet person = { name: \"Alice\", age: 30, city: \"NYC\" };\nprint(person.name);  // \"Alice\"\n\n// 带方法的对象\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## 对象字面量\n\n### 基本语法\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n```\n\n**语法：**\n- 花括号 `{}` 包围对象\n- 键值对用逗号分隔\n- 键是标识符（不需要引号）\n- 值可以是任何类型\n\n### 空对象\n\n```hemlock\nlet obj = {};  // 空对象\n\n// 稍后添加字段\nobj.name = \"Alice\";\nobj.age = 30;\n```\n\n### 嵌套对象\n\n```hemlock\nlet user = {\n    info: {\n        name: \"Bob\",\n        age: 25\n    },\n    active: true,\n    settings: {\n        theme: \"dark\",\n        notifications: true\n    }\n};\n\nprint(user.info.name);           // \"Bob\"\nprint(user.settings.theme);      // \"dark\"\n```\n\n### 混合值类型\n\n```hemlock\nlet mixed = {\n    number: 42,\n    text: \"hello\",\n    flag: true,\n    data: null,\n    items: [1, 2, 3],\n    config: { x: 10, y: 20 }\n};\n```\n\n### 简写属性语法\n\n当变量名与属性名匹配时，使用简写语法：\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\nlet active = true;\n\n// 简写：{ name } 等同于 { name: name }\nlet person = { name, age, active };\n\nprint(person.name);   // \"Alice\"\nprint(person.age);    // 30\nprint(person.active); // true\n```\n\n**混合简写和常规属性：**\n```hemlock\nlet city = \"NYC\";\nlet obj = { name, age, city, role: \"admin\" };\n```\n\n### 展开运算符\n\n展开运算符（`...`）将一个对象的所有字段复制到另一个对象中：\n\n```hemlock\nlet base = { x: 1, y: 2 };\nlet extended = { ...base, z: 3 };\n\nprint(extended.x);  // 1\nprint(extended.y);  // 2\nprint(extended.z);  // 3\n```\n\n**使用展开覆盖值：**\n```hemlock\nlet defaults = { theme: \"light\", size: \"medium\", debug: false };\nlet custom = { ...defaults, theme: \"dark\" };\n\nprint(custom.theme);  // \"dark\"（被覆盖）\nprint(custom.size);   // \"medium\"（来自 defaults）\nprint(custom.debug);  // false（来自 defaults）\n```\n\n**多个展开（后面的覆盖前面的）：**\n```hemlock\nlet a = { x: 1 };\nlet b = { y: 2 };\nlet merged = { ...a, ...b, z: 3 };\n\nprint(merged.x);  // 1\nprint(merged.y);  // 2\nprint(merged.z);  // 3\n\n// 后面的展开覆盖前面的\nlet first = { val: \"first\" };\nlet second = { val: \"second\" };\nlet combined = { ...first, ...second };\nprint(combined.val);  // \"second\"\n```\n\n**结合简写和展开：**\n```hemlock\nlet status = \"active\";\nlet data = { id: 1, name: \"Item\" };\nlet full = { ...data, status };\n\nprint(full.id);      // 1\nprint(full.name);    // \"Item\"\nprint(full.status);  // \"active\"\n```\n\n**配置覆盖模式：**\n```hemlock\nlet defaultConfig = {\n    debug: false,\n    timeout: 30,\n    retries: 3\n};\n\nlet prodConfig = { ...defaultConfig, timeout: 60 };\nlet devConfig = { ...defaultConfig, debug: true };\n\nprint(prodConfig.timeout);  // 60\nprint(devConfig.debug);     // true\n```\n\n**注意：** 展开执行浅拷贝。嵌套对象共享引用：\n```hemlock\nlet nested = { inner: { val: 42 } };\nlet copied = { ...nested };\nprint(copied.inner.val);  // 42（与 nested.inner 相同的引用）\n```\n\n## 字段访问\n\n### 点语法\n\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\n\n// 读取字段\nlet name = person.name;      // \"Alice\"\nlet age = person.age;        // 30\n\n// 修改字段\nperson.age = 31;\nprint(person.age);           // 31\n```\n\n### 动态字段添加\n\n在运行时添加新字段：\n\n```hemlock\nlet person = { name: \"Alice\" };\n\n// 添加新字段\nperson.email = \"alice@example.com\";\nperson.phone = \"555-1234\";\n\nprint(person.email);  // \"alice@example.com\"\n```\n\n### 字段删除\n\n**注意：** 目前不支持字段删除。改为设置为 `null`：\n\n```hemlock\nlet obj = { x: 10, y: 20 };\n\n// 无法删除字段（不支持）\n// obj.x = undefined;  // Hemlock 中没有 'undefined'\n\n// 变通方法：设置为 null\nobj.x = null;\n```\n\n## 方法和 `self`\n\n### 定义方法\n\n方法是存储在对象字段中的函数：\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    decrement: fn() {\n        self.count = self.count - 1;\n    },\n    get: fn() {\n        return self.count;\n    }\n};\n```\n\n### `self` 关键字\n\n当函数作为方法调用时，`self` 自动绑定到对象：\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;  // self 指向 counter\n    }\n};\n\ncounter.increment();  // self 绑定到 counter\nprint(counter.count);  // 1\n```\n\n**工作原理：**\n- 通过检查函数表达式是否为属性访问来检测方法调用\n- `self` 在调用时自动绑定到对象\n- `self` 是只读的（无法重新赋值 `self` 本身）\n\n### 方法调用检测\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() {\n        return self.value;\n    }\n};\n\n// 作为方法调用 - self 被绑定\nprint(obj.method());  // 10\n\n// 作为函数调用 - self 为 null（错误）\nlet f = obj.method;\nprint(f());  // 错误：self 未定义\n```\n\n### 带参数的方法\n\n```hemlock\nlet calculator = {\n    result: 0,\n    add: fn(x) {\n        self.result = self.result + x;\n    },\n    multiply: fn(x) {\n        self.result = self.result * x;\n    },\n    get: fn() {\n        return self.result;\n    }\n};\n\ncalculator.add(5);\ncalculator.multiply(2);\nprint(calculator.get());  // 10\n```\n\n## 使用 `define` 进行类型定义\n\n### 基本类型定义\n\n使用 `define` 定义对象结构：\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active: bool,\n}\n\n// 创建对象并赋值给类型化变量\nlet p = { name: \"Alice\", age: 30, active: true };\nlet typed_p: Person = p;  // 鸭子类型验证结构\n\nprint(typeof(typed_p));  // \"Person\"\n```\n\n**`define` 的作用：**\n- 声明具有必需字段的类型\n- 启用鸭子类型验证\n- 为 `typeof()` 设置对象的类型名称\n\n### 鸭子类型\n\n使用**结构兼容性**验证对象是否符合 `define`：\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// 正确：具有所有必需字段\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// 正确：允许额外字段\nlet p2: Person = {\n    name: \"Bob\",\n    age: 25,\n    city: \"NYC\",\n    active: true\n};\n\n// 错误：缺少必需字段 'age'\nlet p3: Person = { name: \"Carol\" };\n\n// 错误：'age' 类型错误\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```\n\n**鸭子类型规则：**\n- 所有必需字段必须存在\n- 字段类型必须匹配\n- 允许额外字段并保留\n- 验证发生在赋值时\n\n### 可选字段\n\n字段可以是可选的，带有默认值：\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,       // 可选，带默认值\n    nickname?: string,   // 可选，默认为 null\n}\n\n// 只有必需字段的对象\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.active);    // true（应用默认值）\nprint(typed_p.nickname);  // null（无默认值）\n\n// 可以覆盖可选字段\nlet p2: Person = { name: \"Bob\", age: 25, active: false };\nprint(p2.active);  // false（被覆盖）\n```\n\n**可选字段语法：**\n- `field?: default_value` - 可选，带默认值\n- `field?: type` - 可选，带类型注解，默认为 null\n- 如果缺少可选字段，在鸭子类型检查时添加\n\n### 类型检查\n\n```hemlock\ndefine Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = { x: 10, y: 20 };\nlet point: Point = p;  // 类型检查发生在这里\n\nprint(typeof(point));  // \"Point\"\nprint(typeof(p));      // \"object\"（原始对象仍是匿名的）\n```\n\n**类型检查发生的时机：**\n- 赋值给类型化变量时\n- 验证所有必需字段存在\n- 验证字段类型匹配（带隐式转换）\n- 设置对象的类型名称\n\n## Define 中的方法签名\n\nDefine 块可以指定方法签名，创建类似接口的契约：\n\n### 必需方法\n\n```hemlock\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32;  // 必需方法签名\n}\n\n// 对象必须提供必需方法\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n```\n\n### 可选方法\n\n```hemlock\ndefine Serializable {\n    fn serialize(): string;       // 必需\n    fn pretty?(): string;         // 可选方法（可能不存在）\n}\n```\n\n### `Self` 类型\n\n`Self` 指向正在定义的类型，支持递归类型定义：\n\n```hemlock\ndefine Cloneable {\n    fn clone(): Self;  // 返回与对象相同的类型\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;  // 接受相同类型作为参数\n    fn equals(other: Self): bool;\n}\n\nlet item: Cloneable = {\n    value: 42,\n    clone: fn() {\n        return { value: self.value, clone: self.clone };\n    }\n};\n```\n\n### 混合字段和方法\n\n```hemlock\ndefine Entity {\n    id: i32,\n    name: string,\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\nlet user: Entity = {\n    id: 1,\n    name: \"Alice\",\n    validate: fn() { return self.id > 0 && self.name != \"\"; },\n    serialize: fn() { return '{\"id\":' + self.id + ',\"name\":\"' + self.name + '\"}'; }\n};\n```\n\n## 复合类型（交叉类型）\n\n复合类型使用 `&` 要求对象满足多个类型定义：\n\n### 基本复合类型\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\n// 复合类型：对象必须满足所有类型\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n```\n\n### 带复合类型的函数参数\n\n```hemlock\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" is \" + p.age);\n}\n\ngreet({ name: \"Bob\", age: 25, city: \"NYC\" });  // 允许额外字段\n```\n\n### 三个或更多类型\n\n```hemlock\ndefine HasEmail { email: string }\n\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n### 复合类型的类型别名\n\n```hemlock\n// 为复合类型创建命名别名\ntype Person = HasName & HasAge;\ntype Employee = HasName & HasAge & HasEmail;\n\nlet emp: Employee = {\n    name: \"Charlie\",\n    age: 35,\n    email: \"charlie@example.com\"\n};\n```\n\n**复合类型的鸭子类型：** 始终允许额外字段 - 对象只需要至少具有所有组成类型要求的字段。\n\n## JSON 序列化\n\n### 序列化为 JSON\n\n将对象转换为 JSON 字符串：\n\n```hemlock\n// obj.serialize() - 将对象转换为 JSON 字符串\nlet obj = { x: 10, y: 20, name: \"test\" };\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// 嵌套对象\nlet nested = { inner: { a: 1, b: 2 }, outer: 3 };\nprint(nested.serialize());  // {\"inner\":{\"a\":1,\"b\":2},\"outer\":3}\n```\n\n### 从 JSON 反序列化\n\n将 JSON 字符串解析回对象：\n\n```hemlock\n// json.deserialize() - 将 JSON 字符串解析为对象\nlet json_str = '{\"x\":10,\"y\":20,\"name\":\"test\"}';\nlet obj = json_str.deserialize();\n\nprint(obj.name);   // \"test\"\nprint(obj.x);      // 10\n```\n\n### 循环引用检测\n\n循环引用会被检测到并导致错误：\n\n```hemlock\nlet obj = { x: 10 };\nobj.me = obj;  // 创建循环引用\n\nobj.serialize();  // 错误：serialize() 检测到循环引用\n```\n\n### 支持的类型\n\nJSON 序列化支持：\n\n- **数字**：i8-i32, u8-u32, f32, f64\n- **布尔值**：true, false\n- **字符串**：带转义序列\n- **Null**：null 值\n- **对象**：嵌套对象\n- **数组**：嵌套数组\n\n**不支持：**\n- 函数（静默省略）\n- 指针（错误）\n- Buffer（错误）\n\n### 错误处理\n\n序列化和反序列化可能抛出错误：\n\n```hemlock\n// 无效 JSON 抛出错误\ntry {\n    let bad = \"not valid json\".deserialize();\n} catch (e) {\n    print(\"Parse error:\", e);\n}\n\n// 指针无法序列化\nlet obj = { ptr: alloc(10) };\ntry {\n    obj.serialize();\n} catch (e) {\n    print(\"Serialize error:\", e);\n}\n```\n\n### 往返示例\n\n序列化和反序列化的完整示例：\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug: bool\n}\n\n// 创建并序列化\nlet config: Config = {\n    host: \"localhost\",\n    port: 8080,\n    debug: true\n};\nlet json = config.serialize();\nprint(json);  // {\"host\":\"localhost\",\"port\":8080,\"debug\":true}\n\n// 反序列化\nlet restored = json.deserialize();\nprint(restored.host);  // \"localhost\"\nprint(restored.port);  // 8080\n```\n\n## 内置函数\n\n### `typeof(value)`\n\n返回类型名称作为字符串：\n\n```hemlock\nlet obj = { x: 10 };\nprint(typeof(obj));  // \"object\"\n\ndefine Person { name: string, age: i32 }\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(typeof(p));    // \"Person\"\n```\n\n**返回值：**\n- 匿名对象：`\"object\"`\n- 类型化对象：自定义类型名称（例如 `\"Person\"`）\n\n## 实现细节\n\n### 内存模型\n\n- **堆分配** - 所有对象都在堆上分配\n- **浅拷贝** - 赋值复制引用，而非对象\n- **动态字段** - 存储为名称/值对的动态数组\n- **引用计数** - 作用域退出时对象自动释放\n\n### 引用语义\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // 浅拷贝（相同引用）\n\nobj2.x = 20;\nprint(obj1.x);  // 20（两者指向相同对象）\n```\n\n### 方法存储\n\n方法只是存储在字段中的函数：\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// method 是存储在 obj.method 中的函数\nprint(typeof(obj.method));  // \"function\"\n```\n\n## 常见模式\n\n### 模式：构造函数\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```\n\n### 模式：对象构建器\n\n```hemlock\nfn PersonBuilder() {\n    return {\n        name: null,\n        age: null,\n\n        setName: fn(n) {\n            self.name = n;\n            return self;  // 支持链式调用\n        },\n\n        setAge: fn(a) {\n            self.age = a;\n            return self;\n        },\n\n        build: fn() {\n            return { name: self.name, age: self.age };\n        }\n    };\n}\n\nlet person = PersonBuilder()\n    .setName(\"Alice\")\n    .setAge(30)\n    .build();\n```\n\n### 模式：状态对象\n\n```hemlock\nlet state = {\n    status: \"idle\",\n    data: null,\n    error: null,\n\n    setState: fn(new_status) {\n        self.status = new_status;\n    },\n\n    setData: fn(new_data) {\n        self.data = new_data;\n        self.status = \"success\";\n    },\n\n    setError: fn(err) {\n        self.error = err;\n        self.status = \"error\";\n    }\n};\n```\n\n### 模式：配置对象\n\n```hemlock\nlet config = {\n    defaults: {\n        timeout: 30,\n        retries: 3,\n        debug: false\n    },\n\n    get: fn(key) {\n        if (self.defaults[key] != null) {\n            return self.defaults[key];\n        }\n        return null;\n    },\n\n    set: fn(key, value) {\n        self.defaults[key] = value;\n    }\n};\n```\n\n## 最佳实践\n\n1. **使用 `define` 定义结构** - 记录预期的对象形状\n2. **优先使用工厂函数** - 使用构造函数创建对象\n3. **保持对象简单** - 不要嵌套太深\n4. **记录 `self` 用法** - 明确方法行为\n5. **在赋值时验证** - 使用鸭子类型尽早捕获错误\n6. **避免循环引用** - 会导致序列化错误\n7. **使用可选字段** - 提供合理的默认值\n\n## 常见陷阱\n\n### 陷阱：引用与值\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // 浅拷贝\n\nobj2.x = 20;\nprint(obj1.x);  // 20（意外！两者都改变了）\n\n// 避免方法：创建新对象\nlet obj3 = { x: obj1.x };  // 深拷贝（手动）\n```\n\n### 陷阱：非方法调用中的 `self`\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// 有效：作为方法调用\nprint(obj.method());  // 10\n\n// 错误：作为函数调用\nlet f = obj.method;\nprint(f());  // 错误：self 未定义\n```\n\n### 陷阱：对象中的原始指针\n\n```hemlock\n// 对象会自动释放，但其中的原始指针不会\nfn create_objects() {\n    let obj = { data: alloc(1000) };  // 原始指针需要手动释放\n    // 作用域退出时 obj 自动释放，但 obj.data 泄漏！\n}\n\n// 解决方案：在作用域退出前释放原始指针\nfn safe_create() {\n    let obj = { data: alloc(1000) };\n    // ... 使用 obj.data ...\n    free(obj.data);  // 显式释放原始指针\n}  // obj 本身自动释放\n```\n\n### 陷阱：类型混淆\n\n```hemlock\nlet obj = { x: 10 };\n\ndefine Point { x: i32, y: i32 }\n\n// 错误：缺少必需字段 'y'\nlet p: Point = obj;\n```\n\n## 示例\n\n### 示例：向量数学\n\n```hemlock\nfn createVector(x, y) {\n    return {\n        x: x,\n        y: y,\n\n        add: fn(other) {\n            return createVector(\n                self.x + other.x,\n                self.y + other.y\n            );\n        },\n\n        length: fn() {\n            return sqrt(self.x * self.x + self.y * self.y);\n        },\n\n        toString: fn() {\n            return \"(\" + typeof(self.x) + \", \" + typeof(self.y) + \")\";\n        }\n    };\n}\n\nlet v1 = createVector(3, 4);\nlet v2 = createVector(1, 2);\nlet v3 = v1.add(v2);\n\nprint(v3.toString());  // \"(4, 6)\"\n```\n\n### 示例：简单数据库\n\n```hemlock\nfn createDatabase() {\n    let records = [];\n    let next_id = 1;\n\n    return {\n        insert: fn(data) {\n            let record = { id: next_id, data: data };\n            records.push(record);\n            next_id = next_id + 1;\n            return record.id;\n        },\n\n        find: fn(id) {\n            let i = 0;\n            while (i < records.length) {\n                if (records[i].id == id) {\n                    return records[i];\n                }\n                i = i + 1;\n            }\n            return null;\n        },\n\n        count: fn() {\n            return records.length;\n        }\n    };\n}\n\nlet db = createDatabase();\nlet id = db.insert({ name: \"Alice\", age: 30 });\nlet record = db.find(id);\nprint(record.data.name);  // \"Alice\"\n```\n\n### 示例：事件发射器\n\n```hemlock\nfn createEventEmitter() {\n    let listeners = {};\n\n    return {\n        on: fn(event, handler) {\n            if (listeners[event] == null) {\n                listeners[event] = [];\n            }\n            listeners[event].push(handler);\n        },\n\n        emit: fn(event, data) {\n            if (listeners[event] != null) {\n                let i = 0;\n                while (i < listeners[event].length) {\n                    listeners[event][i](data);\n                    i = i + 1;\n                }\n            }\n        }\n    };\n}\n\nlet emitter = createEventEmitter();\n\nemitter.on(\"message\", fn(data) {\n    print(\"Received: \" + data);\n});\n\nemitter.emit(\"message\", \"Hello!\");\n```\n\n## 限制\n\n当前限制：\n\n- **无深拷贝** - 必须手动复制嵌套对象（展开是浅拷贝）\n- **无按值传递** - 对象始终按引用传递\n- **无计算属性** - 不支持 `{[key]: value}` 语法\n- **`self` 是只读的** - 无法在方法中重新赋值 `self`\n- **无属性删除** - 一旦添加字段无法删除\n\n**注意：** 对象使用引用计数，作用域退出时自动释放。详见 [内存管理](memory.md#internal-reference-counting)。\n\n## 相关主题\n\n- [函数](#language-guide-functions) - 方法是存储在对象中的函数\n- [数组](#language-guide-arrays) - 数组也是类对象的\n- [类型](#language-guide-types) - 鸭子类型和类型定义\n- [错误处理](#language-guide-error-handling) - 抛出错误对象\n\n## 另请参阅\n\n- **鸭子类型**：参见 CLAUDE.md 中的 \"Objects\" 部分了解鸭子类型详情\n- **JSON**：参见 CLAUDE.md 了解 JSON 序列化详情\n- **内存**：参见 [内存](#language-guide-memory) 了解对象分配\n"}, "Language Guide -> Pattern Matching": {"id": "language-guide-pattern-matching", "content": "# 模式匹配\n\nHemlock 通过 `match` 表达式提供强大的模式匹配功能，提供了一种简洁的方式来解构值、检查类型和处理多种情况。\n\n## 基本语法\n\n```hemlock\nlet result = match (value) {\n    pattern1 => expression1,\n    pattern2 => expression2,\n    _ => default_expression\n};\n```\n\nmatch 表达式按顺序将 `value` 与每个模式进行匹配，返回第一个匹配分支的表达式结果。\n\n## 模式类型\n\n### 字面量模式\n\n匹配精确值：\n\n```hemlock\nlet x = 42;\nlet msg = match (x) {\n    0 => \"zero\",\n    1 => \"one\",\n    42 => \"the answer\",\n    _ => \"other\"\n};\nprint(msg);  // \"the answer\"\n```\n\n支持的字面量：\n- **整数**：`0`、`42`、`-5`\n- **浮点数**：`3.14`、`-0.5`\n- **字符串**：`\"hello\"`、`\"world\"`\n- **布尔值**：`true`、`false`\n- **空值**：`null`\n\n### 通配符模式（`_`）\n\n匹配任何值但不绑定：\n\n```hemlock\nlet x = \"anything\";\nlet result = match (x) {\n    \"specific\" => \"found it\",\n    _ => \"wildcard matched\"\n};\n```\n\n### 变量绑定模式\n\n将匹配的值绑定到变量：\n\n```hemlock\nlet x = 100;\nlet result = match (x) {\n    0 => \"zero\",\n    n => \"value is \" + n  // n 绑定到 100\n};\nprint(result);  // \"value is 100\"\n```\n\n### OR 模式（`|`）\n\n匹配多个替代项：\n\n```hemlock\nlet x = 2;\nlet size = match (x) {\n    1 | 2 | 3 => \"small\",\n    4 | 5 | 6 => \"medium\",\n    _ => \"large\"\n};\n\n// 也适用于字符串\nlet cmd = \"quit\";\nlet action = match (cmd) {\n    \"exit\" | \"quit\" | \"q\" => \"exiting\",\n    \"help\" | \"h\" | \"?\" => \"showing help\",\n    _ => \"unknown\"\n};\n```\n\n### 守卫表达式（`if`）\n\n为模式添加条件：\n\n```hemlock\nlet x = 15;\nlet category = match (x) {\n    n if n < 0 => \"negative\",\n    n if n == 0 => \"zero\",\n    n if n < 10 => \"small\",\n    n if n < 100 => \"medium\",\n    n => \"large: \" + n\n};\nprint(category);  // \"medium\"\n\n// 复杂守卫\nlet y = 12;\nlet result = match (y) {\n    n if n % 2 == 0 && n > 10 => \"even and greater than 10\",\n    n if n % 2 == 0 => \"even\",\n    n => \"odd\"\n};\n```\n\n### 类型模式\n\n基于类型检查和绑定：\n\n```hemlock\nlet val = 42;\nlet desc = match (val) {\n    num: i32 => \"integer: \" + num,\n    str: string => \"string: \" + str,\n    flag: bool => \"boolean: \" + flag,\n    _ => \"other type\"\n};\nprint(desc);  // \"integer: 42\"\n```\n\n支持的类型：`i8`、`i16`、`i32`、`i64`、`u8`、`u16`、`u32`、`u64`、`f32`、`f64`、`bool`、`string`、`array`、`object`\n\n## 解构模式\n\n### 对象解构\n\n从对象中提取字段：\n\n```hemlock\nlet point = { x: 10, y: 20 };\nlet result = match (point) {\n    { x, y } => \"point at \" + x + \",\" + y\n};\nprint(result);  // \"point at 10,20\"\n\n// 带字面量字段值\nlet origin = { x: 0, y: 0 };\nlet name = match (origin) {\n    { x: 0, y: 0 } => \"origin\",\n    { x: 0, y } => \"on y-axis at \" + y,\n    { x, y: 0 } => \"on x-axis at \" + x,\n    { x, y } => \"point at \" + x + \",\" + y\n};\nprint(name);  // \"origin\"\n```\n\n### 数组解构\n\n匹配数组结构和元素：\n\n```hemlock\nlet arr = [1, 2, 3];\nlet desc = match (arr) {\n    [] => \"empty\",\n    [x] => \"single: \" + x,\n    [x, y] => \"pair: \" + x + \",\" + y,\n    [x, y, z] => \"triple: \" + x + \",\" + y + \",\" + z,\n    _ => \"many elements\"\n};\nprint(desc);  // \"triple: 1,2,3\"\n\n// 带字面量值\nlet pair = [1, 2];\nlet result = match (pair) {\n    [0, 0] => \"both zero\",\n    [1, x] => \"starts with 1, second is \" + x,\n    [x, 1] => \"ends with 1\",\n    _ => \"other\"\n};\nprint(result);  // \"starts with 1, second is 2\"\n```\n\n### 数组剩余模式（`...`）\n\n捕获剩余元素：\n\n```hemlock\nlet nums = [1, 2, 3, 4, 5];\n\n// 头部和尾部\nlet result = match (nums) {\n    [first, ...rest] => \"first: \" + first,\n    [] => \"empty\"\n};\nprint(result);  // \"first: 1\"\n\n// 前两个元素\nlet result2 = match (nums) {\n    [a, b, ...rest] => \"first two: \" + a + \",\" + b,\n    _ => \"too short\"\n};\nprint(result2);  // \"first two: 1,2\"\n```\n\n### 嵌套解构\n\n组合模式处理复杂数据：\n\n```hemlock\nlet user = {\n    name: \"Alice\",\n    address: { city: \"NYC\", zip: 10001 }\n};\n\nlet result = match (user) {\n    { name, address: { city, zip } } => name + \" lives in \" + city,\n    _ => \"unknown\"\n};\nprint(result);  // \"Alice lives in NYC\"\n\n// 包含数组的对象\nlet data = { items: [1, 2, 3], count: 3 };\nlet result2 = match (data) {\n    { items: [first, ...rest], count } => \"first: \" + first + \", total: \" + count,\n    _ => \"no items\"\n};\nprint(result2);  // \"first: 1, total: 3\"\n```\n\n## Match 作为表达式\n\nMatch 是一个返回值的表达式：\n\n```hemlock\n// 直接赋值\nlet grade = 85;\nlet letter = match (grade) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    n if n >= 70 => \"C\",\n    n if n >= 60 => \"D\",\n    _ => \"F\"\n};\n\n// 在字符串连接中\nlet msg = \"Grade: \" + match (grade) {\n    n if n >= 70 => \"passing\",\n    _ => \"failing\"\n};\n\n// 在函数返回中\nfn classify(n: i32): string {\n    return match (n) {\n        0 => \"zero\",\n        n if n > 0 => \"positive\",\n        _ => \"negative\"\n    };\n}\n```\n\n## 模式匹配最佳实践\n\n1. **顺序很重要**：模式从上到下检查；将特定模式放在通用模式之前\n2. **使用通配符确保完整性**：除非确定所有情况都已覆盖，否则始终包含 `_` 回退\n3. **优先使用守卫而非嵌套条件**：守卫使意图更清晰\n4. **使用解构而非手动字段访问**：更简洁且更安全\n\n```hemlock\n// 好：使用守卫进行范围检查\nmatch (score) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    _ => \"below B\"\n}\n\n// 好：解构而非访问字段\nmatch (point) {\n    { x: 0, y: 0 } => \"origin\",\n    { x, y } => \"at \" + x + \",\" + y\n}\n\n// 避免：过于复杂的嵌套模式\n// 考虑拆分为多个 match 或使用守卫\n```\n\n## 与其他语言的比较\n\n| 特性 | Hemlock | Rust | JavaScript |\n|---------|---------|------|------------|\n| 基本匹配 | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |\n| 解构 | 是 | 是 | 部分（switch 不解构） |\n| 守卫 | `n if n > 0 =>` | `n if n > 0 =>` | 不适用 |\n| OR 模式 | `1 \\| 2 \\| 3 =>` | `1 \\| 2 \\| 3 =>` | `case 1: case 2: case 3:` |\n| 剩余模式 | `[a, ...rest]` | `[a, rest @ ..]` | 不适用 |\n| 类型模式 | `n: i32` | 通过 `match` 分支的类型 | 不适用 |\n| 返回值 | 是 | 是 | 否（语句） |\n\n## 实现说明\n\n模式匹配在解释器和编译器后端都实现了完全一致性 - 两者对相同输入产生相同的结果。该功能在 Hemlock v1.8.0+ 中可用。\n"}, "Language Guide -> Runes": {"id": "language-guide-runes", "content": "# Rune 字符\n\nRune 表示 **Unicode 码点**（U+0000 到 U+10FFFF），作为 Hemlock 中字符操作的独立类型。与字节（u8）不同，rune 是完整的 Unicode 字符，可以表示任何语言的字符或表情符号。\n\n## 概述\n\n```hemlock\nlet ch = 'A';           // Rune 字面量\nlet emoji = '🚀';       // 多字节字符作为单个 rune\nprint(ch);              // 'A'\nprint(emoji);           // U+1F680\n\nlet s = \"Hello \" + '!'; // 字符串 + rune 连接\nlet r = '>' + \" msg\";   // Rune + 字符串连接\n```\n\n## 什么是 Rune？\n\nRune 是表示 Unicode 码点的 **32 位值**：\n\n- **范围：** 0 到 0x10FFFF（1,114,111 个有效码点）\n- **不是数值类型** - 用于字符表示\n- **与 u8/char 不同** - Rune 是完整的 Unicode，u8 只是字节\n- **字符串索引返回** - `str[0]` 返回 rune，而不是字节\n\n**为什么使用 rune？**\n- Hemlock 字符串是 UTF-8 编码的\n- 单个 Unicode 字符在 UTF-8 中可能是 1-4 个字节\n- Rune 允许处理完整字符，而不是部分字节\n\n## Rune 字面量\n\n### 基本语法\n\n单引号表示 rune 字面量：\n\n```hemlock\nlet a = 'A';            // ASCII 字符\nlet b = '0';            // 数字字符\nlet c = '!';            // 标点符号\nlet d = ' ';            // 空格\n```\n\n### 多字节 UTF-8 字符\n\nRune 可以表示任何 Unicode 字符：\n\n```hemlock\n// 表情符号\nlet rocket = '🚀';      // 表情符号（U+1F680）\nlet heart = '❤';        // 心形（U+2764）\nlet smile = '😀';       // 笑脸（U+1F600）\n\n// CJK 字符\nlet chinese = '中';     // 中文（U+4E2D）\nlet japanese = 'あ';    // 平假名（U+3042）\nlet korean = '한';      // 韩文（U+D55C）\n\n// 符号\nlet check = '✓';        // 对勾（U+2713）\nlet arrow = '→';        // 右箭头（U+2192）\n```\n\n### 转义序列\n\n特殊字符的常用转义序列：\n\n```hemlock\nlet newline = '\\n';     // 换行符（U+000A）\nlet tab = '\\t';         // 制表符（U+0009）\nlet backslash = '\\\\';   // 反斜杠（U+005C）\nlet quote = '\\'';       // 单引号（U+0027）\nlet dquote = '\"';       // 双引号（U+0022）\nlet null_char = '\\0';   // 空字符（U+0000）\nlet cr = '\\r';          // 回车符（U+000D）\n```\n\n**可用的转义序列：**\n- `\\n` - 换行符\n- `\\t` - 水平制表符\n- `\\r` - 回车符\n- `\\0` - 空字符\n- `\\\\` - 反斜杠\n- `\\'` - 单引号\n- `\\\"` - 双引号\n\n### Unicode 转义\n\n使用 `\\u{XXXXXX}` 语法表示 Unicode 码点（最多 6 个十六进制数字）：\n\n```hemlock\nlet rocket = '\\u{1F680}';   // 🚀 通过 Unicode 转义表示的表情符号\nlet heart = '\\u{2764}';     // ❤ 心形\nlet ascii = '\\u{41}';       // 'A' 通过转义表示\nlet max = '\\u{10FFFF}';     // 最大 Unicode 码点\n\n// 前导零是可选的\nlet a = '\\u{41}';           // 与 '\\u{0041}' 相同\nlet b = '\\u{0041}';\n```\n\n**规则：**\n- 范围：`\\u{0}` 到 `\\u{10FFFF}`\n- 十六进制数字：1 到 6 位\n- 不区分大小写：`\\u{1F680}` 或 `\\u{1f680}`\n- 超出有效 Unicode 范围的值会导致错误\n\n## 字符串 + Rune 连接\n\nRune 可以与字符串连接：\n\n```hemlock\n// 字符串 + rune\nlet greeting = \"Hello\" + '!';       // \"Hello!\"\nlet decorated = \"Text\" + '✓';       // \"Text✓\"\n\n// Rune + 字符串\nlet prefix = '>' + \" Message\";      // \"> Message\"\nlet bullet = '•' + \" Item\";         // \"• Item\"\n\n// 多重连接\nlet msg = \"Hi \" + '👋' + \" World \" + '🌍';  // \"Hi 👋 World 🌍\"\n\n// 方法链可以使用\nlet result = ('>' + \" Important\").to_upper();  // \"> IMPORTANT\"\n```\n\n**工作原理：**\n- Rune 自动编码为 UTF-8\n- 在连接过程中转换为字符串\n- 字符串连接运算符透明地处理这一点\n\n## 类型转换\n\nRune 可以与其他类型相互转换。\n\n### 整数 ↔ Rune\n\n在整数和 rune 之间转换以处理码点值：\n\n```hemlock\n// 整数到 rune（码点值）\nlet code: rune = 65;            // 'A'（ASCII 65）\nlet emoji_code: rune = 128640;  // U+1F680（🚀）\n\n// Rune 到整数（获取码点值）\nlet r = 'Z';\nlet value: i32 = r;             // 90（ASCII 值）\n\nlet rocket = '🚀';\nlet code: i32 = rocket;         // 128640（U+1F680）\n```\n\n**范围检查：**\n- 整数到 rune：必须在 [0, 0x10FFFF] 范围内\n- 超出范围的值会导致运行时错误\n- Rune 到整数：始终成功（返回码点）\n\n### Rune → 字符串\n\nRune 可以显式转换为字符串：\n\n```hemlock\n// 显式转换\nlet ch: string = 'H';           // \"H\"\nlet emoji: string = '🚀';       // \"🚀\"\n\n// 连接时自动转换\nlet s = \"\" + 'A';               // \"A\"\nlet s2 = \"x\" + 'y' + \"z\";       // \"xyz\"\n```\n\n### u8（字节）→ Rune\n\n任何 u8 值（0-255）都可以转换为 rune：\n\n```hemlock\n// ASCII 范围（0-127）\nlet byte: u8 = 65;\nlet rune_val: rune = byte;      // 'A'\n\n// 扩展 ASCII / Latin-1（128-255）\nlet extended: u8 = 200;\nlet r: rune = extended;         // U+00C8（È）\n\n// 注意：0-127 是 ASCII，128-255 是 Latin-1\n```\n\n### 链式转换\n\n类型转换可以链式进行：\n\n```hemlock\n// i32 → rune → string\nlet code: i32 = 128512;         // 笑脸码点\nlet r: rune = code;             // 😀\nlet s: string = r;              // \"😀\"\n\n// 在一个表达式中完成\nlet emoji: string = 128640;     // 隐式 i32 → rune → string（🚀）\n```\n\n## Rune 操作\n\n### 打印\n\nRune 的显示方式取决于码点：\n\n```hemlock\nlet ascii = 'A';\nprint(ascii);                   // 'A'（带引号，可打印 ASCII）\n\nlet emoji = '🚀';\nprint(emoji);                   // U+1F680（非 ASCII 的 Unicode 表示法）\n\nlet tab = '\\t';\nprint(tab);                     // U+0009（不可打印字符用十六进制表示）\n\nlet space = ' ';\nprint(space);                   // ' '（可打印）\n```\n\n**打印格式：**\n- 可打印 ASCII（32-126）：带引号的字符 `'A'`\n- 不可打印或 Unicode：十六进制表示法 `U+XXXX`\n\n### 类型检查\n\n使用 `typeof()` 检查值是否为 rune：\n\n```hemlock\nlet r = '🚀';\nprint(typeof(r));               // \"rune\"\n\nlet s = \"text\";\nlet ch = s[0];\nprint(typeof(ch));              // \"rune\"（索引返回 rune）\n\nlet num = 65;\nprint(typeof(num));             // \"i32\"\n```\n\n### 比较\n\nRune 可以进行相等性比较：\n\n```hemlock\nlet a = 'A';\nlet b = 'B';\nprint(a == a);                  // true\nprint(a == b);                  // false\n\n// 区分大小写\nlet upper = 'A';\nlet lower = 'a';\nprint(upper == lower);          // false\n\n// Rune 可以与整数比较（码点值）\nprint(a == 65);                 // true（隐式转换）\nprint('🚀' == 128640);          // true\n```\n\n**比较运算符：**\n- `==` - 相等\n- `!=` - 不相等\n- `<`、`>`、`<=`、`>=` - 码点顺序\n\n```hemlock\nprint('A' < 'B');               // true（65 < 66）\nprint('a' > 'Z');               // true（97 > 90）\n```\n\n## 处理字符串索引\n\n字符串索引返回 rune，而不是字节：\n\n```hemlock\nlet s = \"Hello🚀\";\nlet h = s[0];                   // 'H'（rune）\nlet rocket = s[5];              // '🚀'（rune）\n\nprint(typeof(h));               // \"rune\"\nprint(typeof(rocket));          // \"rune\"\n\n// 如果需要可转换为字符串\nlet h_str: string = h;          // \"H\"\nlet rocket_str: string = rocket; // \"🚀\"\n```\n\n**重要：** 字符串索引使用码点位置，而不是字节偏移：\n\n```hemlock\nlet text = \"Hi🚀!\";\n// 码点位置：0='H', 1='i', 2='🚀', 3='!'\n// 字节位置：0='H', 1='i', 2-5='🚀', 6='!'\n\nlet r = text[2];                // '🚀'（码点 2）\nprint(typeof(r));               // \"rune\"\n```\n\n## 示例\n\n### 示例：字符分类\n\n```hemlock\nfn is_digit(r: rune): bool {\n    return r >= '0' && r <= '9';\n}\n\nfn is_upper(r: rune): bool {\n    return r >= 'A' && r <= 'Z';\n}\n\nfn is_lower(r: rune): bool {\n    return r >= 'a' && r <= 'z';\n}\n\nprint(is_digit('5'));           // true\nprint(is_upper('A'));           // true\nprint(is_lower('z'));           // true\n```\n\n### 示例：大小写转换\n\n```hemlock\nfn to_upper_rune(r: rune): rune {\n    if (r >= 'a' && r <= 'z') {\n        // 转换为大写（减去 32）\n        let code: i32 = r;\n        code = code - 32;\n        return code;\n    }\n    return r;\n}\n\nfn to_lower_rune(r: rune): rune {\n    if (r >= 'A' && r <= 'Z') {\n        // 转换为小写（加上 32）\n        let code: i32 = r;\n        code = code + 32;\n        return code;\n    }\n    return r;\n}\n\nprint(to_upper_rune('a'));      // 'A'\nprint(to_lower_rune('Z'));      // 'z'\n```\n\n### 示例：字符迭代\n\n```hemlock\nfn print_chars(s: string) {\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        print(\"Position \" + typeof(i) + \": \" + typeof(ch));\n        i = i + 1;\n    }\n}\n\nprint_chars(\"Hi🚀\");\n// Position 0: 'H'\n// Position 1: 'i'\n// Position 2: U+1F680\n```\n\n### 示例：从 Rune 构建字符串\n\n```hemlock\nfn repeat_char(ch: rune, count: i32): string {\n    let result = \"\";\n    let i = 0;\n    while (i < count) {\n        result = result + ch;\n        i = i + 1;\n    }\n    return result;\n}\n\nlet line = repeat_char('=', 40);  // \"========================================\"\nlet stars = repeat_char('⭐', 5);  // \"⭐⭐⭐⭐⭐\"\n```\n\n## 常见模式\n\n### 模式：字符过滤\n\n```hemlock\nfn filter_digits(s: string): string {\n    let result = \"\";\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        if (ch >= '0' && ch <= '9') {\n            result = result + ch;\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet text = \"abc123def456\";\nlet digits = filter_digits(text);  // \"123456\"\n```\n\n### 模式：字符计数\n\n```hemlock\nfn count_char(s: string, target: rune): i32 {\n    let count = 0;\n    let i = 0;\n    while (i < s.length) {\n        if (s[i] == target) {\n            count = count + 1;\n        }\n        i = i + 1;\n    }\n    return count;\n}\n\nlet text = \"hello world\";\nlet l_count = count_char(text, 'l');  // 3\nlet o_count = count_char(text, 'o');  // 2\n```\n\n## 最佳实践\n\n1. **对字符操作使用 rune** - 不要尝试用字节处理文本\n2. **字符串索引返回 rune** - 记住 `str[i]` 给你的是 rune\n3. **Unicode 感知的比较** - Rune 可以处理任何 Unicode 字符\n4. **需要时进行转换** - Rune 可以轻松转换为字符串和整数\n5. **用表情符号测试** - 始终用多字节字符测试字符操作\n\n## 常见陷阱\n\n### 陷阱：Rune 与字节混淆\n\n```hemlock\n// 不要：将 rune 当作字节\nlet r: rune = '🚀';\nlet b: u8 = r;              // 错误：Rune 码点 128640 无法放入 u8\n\n// 要：使用适当的转换\nlet r: rune = '🚀';\nlet code: i32 = r;          // 可以：128640\n```\n\n### 陷阱：字符串字节索引\n\n```hemlock\n// 不要：假设字节索引\nlet s = \"🚀\";\nlet byte = s.byte_at(0);    // 240（第一个 UTF-8 字节，不是完整字符）\n\n// 要：使用码点索引\nlet s = \"🚀\";\nlet rune = s[0];            // '🚀'（完整字符）\nlet rune2 = s.char_at(0);   // '🚀'（显式方法）\n```\n\n## 相关主题\n\n- [字符串](#language-guide-strings) - 字符串操作和 UTF-8 处理\n- [类型](#language-guide-types) - 类型系统和转换\n- [控制流](#language-guide-control-flow) - 在比较中使用 rune\n\n## 另请参阅\n\n- **Unicode 标准**：Unicode 码点由 Unicode 联盟定义\n- **UTF-8 编码**：有关 UTF-8 详细信息，请参阅[字符串](#language-guide-strings)\n- **类型转换**：有关转换规则，请参阅[类型](#language-guide-types)\n"}, "Language Guide -> Strings": {"id": "language-guide-strings", "content": "# 字符串\n\nHemlock 字符串是**UTF-8 优先的可变序列**，具有完整的 Unicode 支持和丰富的文本处理方法。与许多语言不同，Hemlock 字符串是可变的，并且原生支持 Unicode 码点操作。\n\n## 概述\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // 使用 rune 修改（现在是 \"Hello\"）\nprint(s.length);        // 5（码点数量）\nlet c = s[0];           // 返回 rune（Unicode 码点）\nlet msg = s + \" world\"; // 连接\nlet emoji = \"🚀\";\nprint(emoji.length);    // 1（一个码点）\nprint(emoji.byte_length); // 4（四个 UTF-8 字节）\n```\n\n## 属性\n\nHemlock 字符串具有以下关键特性：\n\n- **UTF-8 编码** - 完整的 Unicode 支持（U+0000 到 U+10FFFF）\n- **可变** - 与 Python、JavaScript 和 Java 的字符串不同\n- **基于码点的索引** - 返回 `rune`（Unicode 码点），而非字节\n- **堆分配** - 带有内部容量跟踪\n- **两个长度属性**：\n  - `.length` - 码点数量（字符数）\n  - `.byte_length` - 字节数量（UTF-8 编码大小）\n\n## UTF-8 行为\n\n所有字符串操作都使用**码点**（字符），而非字节：\n\n```hemlock\nlet text = \"Hello🚀World\";\nprint(text.length);        // 11（码点）\nprint(text.byte_length);   // 15（字节，emoji 是 4 字节）\n\n// 索引使用码点\nlet h = text[0];           // 'H'（rune）\nlet rocket = text[5];      // '🚀'（rune）\n```\n\n**多字节字符计为一个：**\n```hemlock\n\"Hello\".length;      // 5\n\"🚀\".length;         // 1（一个 emoji）\n\"你好\".length;       // 2（两个中文字符）\n\"café\".length;       // 4（é 是一个码点）\n```\n\n## 字符串字面量\n\n```hemlock\n// 基本字符串\nlet s1 = \"hello\";\nlet s2 = \"world\";\n\n// 带有转义序列\nlet s3 = \"Line 1\\nLine 2\\ttabbed\";\nlet s4 = \"Quote: \\\"Hello\\\"\";\nlet s5 = \"Backslash: \\\\\";\n\n// Unicode 字符\nlet s6 = \"🚀 Emoji\";\nlet s7 = \"中文字符\";\n```\n\n## 模板字符串（字符串插值）\n\n使用反引号创建带有嵌入表达式的模板字符串：\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\n\n// 基本插值\nlet greeting = `Hello, ${name}!`;           // \"Hello, Alice!\"\nlet info = `${name} is ${age} years old`;   // \"Alice is 30 years old\"\n\n// 插值中的表达式\nlet x = 5;\nlet y = 10;\nlet sum = `${x} + ${y} = ${x + y}`;         // \"5 + 10 = 15\"\n\n// 方法调用\nlet upper = `Name: ${name.to_upper()}`;     // \"Name: ALICE\"\n\n// 嵌套对象\nlet person = { name: \"Bob\", city: \"NYC\" };\nlet desc = `${person.name} lives in ${person.city}`;  // \"Bob lives in NYC\"\n\n// 多行（保留换行符）\nlet multi = `Line 1\nLine 2\nLine 3`;\n```\n\n**模板字符串特性：**\n- `${...}` 内的表达式会被求值并转换为字符串\n- 可以使用任何有效表达式（变量、函数调用、算术运算）\n- 反引号字符串支持与普通字符串相同的转义序列\n- 用于构建动态字符串而无需连接操作\n\n### 模板字符串中的转义\n\n要在模板字符串中包含字面量 `${`，请转义美元符号：\n\n```hemlock\nlet price = 100;\nlet text = `Price: \\${price} or ${price}`;\n// \"Price: ${price} or 100\"\n\n// 字面量反引号\nlet code = `Use \\` for template strings`;\n// \"Use ` for template strings\"\n```\n\n### 复杂表达式\n\n模板字符串可以包含任何有效表达式：\n\n```hemlock\n// 类三元表达式\nlet age = 25;\nlet status = `Status: ${age >= 18 ? \"adult\" : \"minor\"}`;\n\n// 数组访问\nlet items = [\"apple\", \"banana\", \"cherry\"];\nlet first = `First item: ${items[0]}`;\n\n// 带参数的函数调用\nfn format_price(p) { return \"$\" + p; }\nlet msg = `Total: ${format_price(99.99)}`;  // \"Total: $99.99\"\n\n// 链式方法调用\nlet name = \"alice\";\nlet formatted = `Hello, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;\n// \"Hello, Alice!\"\n```\n\n### 模板字符串与连接对比\n\n模板字符串通常比连接更清晰：\n\n```hemlock\n// 连接（较难阅读）\nlet msg1 = \"Hello, \" + name + \"! You have \" + count + \" messages.\";\n\n// 模板字符串（更易阅读）\nlet msg2 = `Hello, ${name}! You have ${count} messages.`;\n```\n\n## 索引和修改\n\n### 读取字符\n\n索引返回 `rune`（Unicode 码点）：\n\n```hemlock\nlet s = \"Hello\";\nlet first = s[0];      // 'H'（rune）\nlet last = s[4];       // 'o'（rune）\n\n// UTF-8 示例\nlet emoji = \"Hi🚀!\";\nlet rocket = emoji[2];  // '🚀'（码点索引 2 处的 rune）\n```\n\n### 写入字符\n\n字符串是可变的 - 可以修改单个字符：\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';            // 现在是 \"Hello\"\ns[4] = '!';            // 现在是 \"Hell!\"\n\n// Unicode 示例\nlet msg = \"Go!\";\nmsg[0] = '🚀';         // 现在是 \"🚀o!\"\n```\n\n## 连接\n\n使用 `+` 连接字符串：\n\n```hemlock\nlet greeting = \"Hello\" + \" \" + \"World\";  // \"Hello World\"\n\n// 使用变量\nlet name = \"Alice\";\nlet msg = \"Hi, \" + name + \"!\";  // \"Hi, Alice!\"\n\n// 使用 rune（参见 Runes 文档）\nlet s = \"Hello\" + '!';          // \"Hello!\"\n```\n\n## 字符串方法\n\nHemlock 提供 19 个字符串方法用于全面的文本操作。\n\n### 子字符串和切片\n\n**`substr(start, length)`** - 按位置和长度提取子字符串：\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\"（从 6 开始，长度 5）\nlet first = s.substr(0, 5);     // \"hello\"\n\n// UTF-8 示例\nlet text = \"Hi🚀!\";\nlet emoji = text.substr(2, 1);  // \"🚀\"（位置 2，长度 1）\n```\n\n**`slice(start, end)`** - 按范围提取子字符串（end 不包含在内）：\n```hemlock\nlet s = \"hello world\";\nlet slice = s.slice(0, 5);      // \"hello\"（索引 0 到 4）\nlet slice2 = s.slice(6, 11);    // \"world\"\n```\n\n**区别：**\n- `substr(start, length)` - 使用长度参数\n- `slice(start, end)` - 使用结束索引（不包含）\n\n### 搜索和查找\n\n**`find(needle)`** - 查找首次出现的位置：\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6（首次出现的索引）\nlet pos2 = s.find(\"foo\");       // -1（未找到）\nlet pos3 = s.find(\"l\");         // 2（第一个 'l'）\n```\n\n**`contains(needle)`** - 检查字符串是否包含子字符串：\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n### 分割和修剪\n\n**`split(delimiter)`** - 分割成字符串数组：\n```hemlock\nlet csv = \"apple,banana,cherry\";\nlet parts = csv.split(\",\");     // [\"apple\", \"banana\", \"cherry\"]\n\nlet words = \"one two three\".split(\" \");  // [\"one\", \"two\", \"three\"]\n\n// 空分隔符按字符分割\nlet chars = \"abc\".split(\"\");    // [\"a\", \"b\", \"c\"]\n```\n\n**`trim()`** - 移除前后空白：\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet s2 = \"\\t\\ntext\\n\\t\";\nlet clean2 = s2.trim();         // \"text\"\n```\n\n### 大小写转换\n\n**`to_upper()`** - 转换为大写：\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\n// 保留非 ASCII 字符\nlet s2 = \"café\";\nlet upper2 = s2.to_upper();     // \"CAFÉ\"\n```\n\n**`to_lower()`** - 转换为小写：\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n```\n\n### 前缀/后缀检查\n\n**`starts_with(prefix)`** - 检查是否以前缀开头：\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n**`ends_with(suffix)`** - 检查是否以后缀结尾：\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n### 替换\n\n**`replace(old, new)`** - 替换首次出现：\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");      // \"hello there\"\n\nlet s3 = \"foo foo foo\";\nlet s4 = s3.replace(\"foo\", \"bar\");         // \"bar foo foo\"（仅第一个）\n```\n\n**`replace_all(old, new)`** - 替换所有出现：\n```hemlock\nlet s = \"foo foo foo\";\nlet s2 = s.replace_all(\"foo\", \"bar\");      // \"bar bar bar\"\n\nlet s3 = \"hello world, world!\";\nlet s4 = s3.replace_all(\"world\", \"hemlock\"); // \"hello hemlock, hemlock!\"\n```\n\n### 重复\n\n**`repeat(count)`** - 重复字符串 n 次：\n```hemlock\nlet s = \"ha\";\nlet laugh = s.repeat(3);        // \"hahaha\"\n\nlet line = \"=\".repeat(40);      // \"========================================\"\n```\n\n### 字符和字节访问\n\n**`char_at(index)`** - 获取指定索引处的 Unicode 码点（返回 rune）：\n```hemlock\nlet s = \"hello\";\nlet char = s.char_at(0);        // 'h'（rune）\n\n// UTF-8 示例\nlet emoji = \"🚀\";\nlet rocket = emoji.char_at(0);  // 返回 rune U+1F680\n```\n\n**`chars()`** - 转换为 rune 数组（码点）：\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']（rune 数组）\n\n// UTF-8 示例\nlet text = \"Hi🚀\";\nlet chars2 = text.chars();      // ['H', 'i', '🚀']\n```\n\n**`byte_at(index)`** - 获取指定索引处的字节值（返回 u8）：\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104（'h' 的 ASCII 值）\n\n// UTF-8 示例\nlet emoji = \"🚀\";\nlet first_byte = emoji.byte_at(0);  // 240（第一个 UTF-8 字节）\n```\n\n**`bytes()`** - 转换为字节数组（u8 值）：\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111]（u8 数组）\n\n// UTF-8 示例\nlet emoji = \"🚀\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128]（4 个 UTF-8 字节）\n```\n\n**`to_bytes()`** - 转换为 buffer 以进行底层访问：\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();         // 返回包含 UTF-8 字节的 buffer\nprint(buf.length);              // 5\nfree(buf);                      // 记得释放\n```\n\n## 方法链式调用\n\n所有字符串方法都返回新字符串，支持链式调用：\n\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \")\n    .to_upper();                    // \"FOO | BAR | BAZ\"\n```\n\n## 完整方法参考\n\n| 方法 | 参数 | 返回值 | 描述 |\n|--------|-----------|---------|-------------|\n| `substr(start, length)` | i32, i32 | string | 按位置和长度提取子字符串 |\n| `slice(start, end)` | i32, i32 | string | 按范围提取子字符串（end 不包含在内） |\n| `find(needle)` | string | i32 | 查找首次出现的位置（未找到返回 -1） |\n| `contains(needle)` | string | bool | 检查是否包含子字符串 |\n| `split(delimiter)` | string | array | 分割成字符串数组 |\n| `trim()` | - | string | 移除前后空白 |\n| `to_upper()` | - | string | 转换为大写 |\n| `to_lower()` | - | string | 转换为小写 |\n| `starts_with(prefix)` | string | bool | 检查是否以前缀开头 |\n| `ends_with(suffix)` | string | bool | 检查是否以后缀结尾 |\n| `replace(old, new)` | string, string | string | 替换首次出现 |\n| `replace_all(old, new)` | string, string | string | 替换所有出现 |\n| `repeat(count)` | i32 | string | 重复字符串 n 次 |\n| `char_at(index)` | i32 | rune | 获取指定索引处的码点 |\n| `byte_at(index)` | i32 | u8 | 获取指定索引处的字节值 |\n| `chars()` | - | array | 转换为 rune 数组 |\n| `bytes()` | - | array | 转换为 u8 字节数组 |\n| `to_bytes()` | - | buffer | 转换为 buffer（需要释放） |\n\n## 示例\n\n### 示例：文本处理\n\n```hemlock\nfn process_input(text: string): string {\n    return text\n        .trim()\n        .to_lower()\n        .replace_all(\"  \", \" \");  // 规范化空白\n}\n\nlet input = \"  HELLO   WORLD  \";\nlet clean = process_input(input);  // \"hello world\"\n```\n\n### 示例：CSV 解析器\n\n```hemlock\nfn parse_csv_line(line: string): array {\n    let trimmed = line.trim();\n    let fields = trimmed.split(\",\");\n\n    let result = [];\n    let i = 0;\n    while (i < fields.length) {\n        result.push(fields[i].trim());\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet csv = \"apple, banana , cherry\";\nlet fields = parse_csv_line(csv);  // [\"apple\", \"banana\", \"cherry\"]\n```\n\n### 示例：单词计数器\n\n```hemlock\nfn count_words(text: string): i32 {\n    let words = text.trim().split(\" \");\n    return words.length;\n}\n\nlet sentence = \"The quick brown fox\";\nlet count = count_words(sentence);  // 4\n```\n\n### 示例：字符串验证\n\n```hemlock\nfn is_valid_email(email: string): bool {\n    if (!email.contains(\"@\")) {\n        return false;\n    }\n\n    if (!email.contains(\".\")) {\n        return false;\n    }\n\n    if (email.starts_with(\"@\") || email.ends_with(\"@\")) {\n        return false;\n    }\n\n    return true;\n}\n\nprint(is_valid_email(\"user@example.com\"));  // true\nprint(is_valid_email(\"invalid\"));            // false\n```\n\n## 内存管理\n\n字符串是堆分配的，带有内部引用计数：\n\n- **创建**：在堆上分配，带有容量跟踪\n- **连接**：创建新字符串（旧字符串不变）\n- **方法**：大多数方法返回新字符串\n- **生命周期**：字符串使用引用计数，作用域退出时自动释放\n\n**自动清理：**\n```hemlock\nfn create_strings() {\n    let s = \"hello\";\n    let s2 = s + \" world\";  // 新分配\n}  // 函数返回时 s 和 s2 都自动释放\n```\n\n**注意：** 局部字符串变量在超出作用域时自动清理。仅在需要提前清理（作用域结束前）或处理长期存活/全局数据时使用 `free()`。详见 [内存管理](memory.md#internal-reference-counting)。\n\n## 最佳实践\n\n1. **使用码点索引** - 字符串使用码点位置，而非字节偏移\n2. **使用 Unicode 测试** - 始终使用多字节字符测试字符串操作\n3. **优先使用不可变操作** - 使用返回新字符串的方法，而非直接修改\n4. **检查边界** - 字符串索引不进行边界检查（无效时返回 null/错误）\n5. **规范化输入** - 对用户输入使用 `trim()` 和 `to_lower()`\n\n## 常见陷阱\n\n### 陷阱：字节与码点混淆\n\n```hemlock\nlet emoji = \"🚀\";\nprint(emoji.length);        // 1（码点）\nprint(emoji.byte_length);   // 4（字节）\n\n// 不要混用字节和码点操作\nlet byte = emoji.byte_at(0);  // 240（第一个字节）\nlet char = emoji.char_at(0);  // '🚀'（完整码点）\n```\n\n### 陷阱：修改的意外情况\n\n```hemlock\nlet s1 = \"hello\";\nlet s2 = s1;       // 浅拷贝\ns1[0] = 'H';       // 修改 s1\nprint(s2);         // 仍然是 \"hello\"（字符串是值类型）\n```\n\n## 相关主题\n\n- [Runes](#language-guide-runes) - 字符串索引中使用的 Unicode 码点类型\n- [数组](#language-guide-arrays) - 字符串方法经常返回或使用数组\n- [类型](#language-guide-types) - 字符串类型详情和转换\n\n## 另请参阅\n\n- **UTF-8 编码**：参见 CLAUDE.md 中的 \"Strings\" 部分\n- **类型转换**：参见 [类型](#language-guide-types) 了解字符串转换\n- **内存**：参见 [内存](#language-guide-memory) 了解字符串分配细节\n"}, "Language Guide -> Syntax": {"id": "language-guide-syntax", "content": "# 语法概述\n\n本文档介绍 Hemlock 程序的基本语法规则和结构。\n\n## 核心语法规则\n\n### 分号是必需的\n\n与 JavaScript 或 Python 不同，语句末尾**必须**使用分号：\n\n```hemlock\nlet x = 42;\nlet y = 10;\nprint(x + y);\n```\n\n**以下代码会导致错误：**\n```hemlock\nlet x = 42  // 错误：缺少分号\nlet y = 10  // 错误：缺少分号\n```\n\n### 花括号是必需的\n\n所有控制流代码块都必须使用花括号，即使只有单条语句：\n\n```hemlock\n// 正确\nif (x > 0) {\n    print(\"positive\");\n}\n\n// 错误：缺少花括号\nif (x > 0)\n    print(\"positive\");\n```\n\n### 注释\n\n```hemlock\n// 这是单行注释\n\n/*\n   这是\n   多行注释\n*/\n\nlet x = 42;  // 行内注释\n```\n\n## 变量\n\n### 声明\n\n使用 `let` 声明变量：\n\n```hemlock\nlet count = 0;\nlet name = \"Alice\";\nlet pi = 3.14159;\n```\n\n### 类型注解（可选）\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet flag: bool = true;\nlet text: string = \"hello\";\n```\n\n### 常量\n\n使用 `const` 声明不可变值：\n\n```hemlock\nconst MAX_SIZE: i32 = 1000;\nconst PI: f64 = 3.14159;\n```\n\n尝试重新赋值常量会导致运行时错误：\"Cannot assign to const variable\"。\n\n## 表达式\n\n### 算术运算符\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13 - 加法\nprint(a - b);   // 7  - 减法\nprint(a * b);   // 30 - 乘法\nprint(a / b);   // 3  - 除法（整数）\n```\n\n### 比较运算符\n\n```hemlock\nprint(a == b);  // false - 等于\nprint(a != b);  // true  - 不等于\nprint(a > b);   // true  - 大于\nprint(a < b);   // false - 小于\nprint(a >= b);  // true  - 大于等于\nprint(a <= b);  // false - 小于等于\n```\n\n### 逻辑运算符\n\n```hemlock\nlet x = true;\nlet y = false;\n\nprint(x && y);  // false - 与\nprint(x || y);  // true  - 或\nprint(!x);      // false - 非\n```\n\n### 位运算符\n\n```hemlock\nlet a = 12;  // 1100\nlet b = 10;  // 1010\n\nprint(a & b);   // 8  - 按位与\nprint(a | b);   // 14 - 按位或\nprint(a ^ b);   // 6  - 按位异或\nprint(a << 2);  // 48 - 左移\nprint(a >> 1);  // 6  - 右移\nprint(~a);      // -13 - 按位取反\n```\n\n### 运算符优先级\n\n从高到低：\n\n1. `()` - 分组\n2. `!`, `~`, `-`（一元）- 一元运算符\n3. `*`, `/` - 乘法、除法\n4. `+`, `-` - 加法、减法\n5. `<<`, `>>` - 位移\n6. `<`, `<=`, `>`, `>=` - 比较\n7. `==`, `!=` - 相等性\n8. `&` - 按位与\n9. `^` - 按位异或\n10. `|` - 按位或\n11. `&&` - 逻辑与\n12. `||` - 逻辑或\n\n**示例：**\n```hemlock\nlet x = 2 + 3 * 4;      // 14（不是 20）\nlet y = (2 + 3) * 4;    // 20\nlet z = 5 << 2 + 1;     // 40 (5 << 3)\n```\n\n## 控制流\n\n### If 语句\n\n```hemlock\nif (condition) {\n    // 主体\n}\n\nif (condition) {\n    // then 分支\n} else {\n    // else 分支\n}\n\nif (condition1) {\n    // 分支 1\n} else if (condition2) {\n    // 分支 2\n} else {\n    // 默认分支\n}\n```\n\n### While 循环\n\n```hemlock\nwhile (condition) {\n    // 主体\n}\n```\n\n**示例：**\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n### For 循环\n\n**C 风格 for：**\n```hemlock\nfor (initializer; condition; increment) {\n    // 主体\n}\n```\n\n**示例：**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**For-in（数组）：**\n```hemlock\nfor (let item in array) {\n    // 主体\n}\n```\n\n**示例：**\n```hemlock\nlet items = [10, 20, 30];\nfor (let x in items) {\n    print(x);\n}\n```\n\n### Switch 语句\n\n```hemlock\nswitch (expression) {\n    case value1:\n        // 主体\n        break;\n    case value2:\n        // 主体\n        break;\n    default:\n        // 默认主体\n        break;\n}\n```\n\n**示例：**\n```hemlock\nlet day = 3;\nswitch (day) {\n    case 1:\n        print(\"Monday\");\n        break;\n    case 2:\n        print(\"Tuesday\");\n        break;\n    case 3:\n        print(\"Wednesday\");\n        break;\n    default:\n        print(\"Other\");\n        break;\n}\n```\n\n### Break 和 Continue\n\n```hemlock\n// Break：退出循环\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n}\n\n// Continue：跳到下一次迭代\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;\n    }\n    print(i);\n}\n```\n\n## 函数\n\n### 命名函数\n\n```hemlock\nfn function_name(param1: type1, param2: type2): return_type {\n    // 主体\n    return value;\n}\n```\n\n**示例：**\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### 匿名函数\n\n```hemlock\nlet func = fn(params) {\n    // 主体\n};\n```\n\n**示例：**\n```hemlock\nlet multiply = fn(x, y) {\n    return x * y;\n};\n```\n\n### 类型注解（可选）\n\n```hemlock\n// 无注解（类型推断）\nfn greet(name) {\n    return \"Hello, \" + name;\n}\n\n// 有注解（运行时检查）\nfn divide(a: i32, b: i32): f64 {\n    return a / b;\n}\n```\n\n## 对象\n\n### 对象字面量\n\n```hemlock\nlet obj = {\n    field1: value1,\n    field2: value2,\n};\n```\n\n**示例：**\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    active: true,\n};\n```\n\n### 方法\n\n```hemlock\nlet obj = {\n    method: fn() {\n        self.field = value;\n    },\n};\n```\n\n**示例：**\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n};\n```\n\n### 类型定义\n\n```hemlock\ndefine TypeName {\n    field1: type1,\n    field2: type2,\n    optional_field?: default_value,\n}\n```\n\n**示例：**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,\n}\n```\n\n## 数组\n\n### 数组字面量\n\n```hemlock\nlet arr = [element1, element2, element3];\n```\n\n**示例：**\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];\nlet empty = [];\n```\n\n### 数组索引\n\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);   // 10\narr[1] = 99;     // 修改元素\n```\n\n## 错误处理\n\n### Try/Catch\n\n```hemlock\ntry {\n    // 可能出错的代码\n} catch (e) {\n    // 处理错误\n}\n```\n\n### Try/Finally\n\n```hemlock\ntry {\n    // 可能出错的代码\n} finally {\n    // 总是执行\n}\n```\n\n### Try/Catch/Finally\n\n```hemlock\ntry {\n    // 可能出错的代码\n} catch (e) {\n    // 处理错误\n} finally {\n    // 清理\n}\n```\n\n### Throw\n\n```hemlock\nthrow expression;\n```\n\n**示例：**\n```hemlock\nif (x < 0) {\n    throw \"x must be positive\";\n}\n```\n\n### Panic\n\n```hemlock\npanic(message);\n```\n\n**示例：**\n```hemlock\npanic(\"unrecoverable error\");\n```\n\n## 模块（实验性）\n\n### 导出语句\n\n```hemlock\nexport fn function_name() { }\nexport const CONSTANT = value;\nexport let variable = value;\nexport { name1, name2 };\n```\n\n### 导入语句\n\n```hemlock\nimport { name1, name2 } from \"./module.hml\";\nimport * as namespace from \"./module.hml\";\nimport { name as alias } from \"./module.hml\";\n```\n\n## 异步（实验性）\n\n### 异步函数\n\n```hemlock\nasync fn function_name(params): return_type {\n    // 主体\n}\n```\n\n### Spawn/Join\n\n```hemlock\nlet task = spawn(async_function, arg1, arg2);\nlet result = join(task);\n```\n\n### 通道\n\n```hemlock\nlet ch = channel(capacity);\nch.send(value);\nlet value = ch.recv();\nch.close();\n```\n\n## FFI（外部函数接口）\n\n### 导入共享库\n\n```hemlock\nimport \"library_name.so\";\n```\n\n### 声明外部函数\n\n```hemlock\nextern fn function_name(param: type): return_type;\n```\n\n**示例：**\n```hemlock\nimport \"libc.so.6\";\nextern fn strlen(s: string): i32;\n```\n\n## 字面量\n\n### 整数字面量\n\n```hemlock\nlet decimal = 42;\nlet negative = -100;\nlet large = 5000000000;  // 自动 i64\n\n// 十六进制（0x 前缀）\nlet hex = 0xDEADBEEF;\nlet hex2 = 0xFF;\n\n// 二进制（0b 前缀）\nlet bin = 0b1010;\nlet bin2 = 0b11110000;\n\n// 八进制（0o 前缀）\nlet oct = 0o777;\nlet oct2 = 0O123;\n\n// 数字分隔符提高可读性\nlet million = 1_000_000;\nlet hex_sep = 0xFF_FF_FF;\nlet bin_sep = 0b1111_0000_1010_0101;\nlet oct_sep = 0o77_77;\n```\n\n### 浮点字面量\n\n```hemlock\nlet f = 3.14;\nlet e = 2.71828;\nlet sci = 1.5e-10;       // 科学计数法\nlet sci2 = 2.5E+3;       // 大写 E 也可以\nlet no_lead = .5;        // 无前导零 (0.5)\nlet sep = 3.14_159_265;  // 数字分隔符\n```\n\n### 字符串字面量\n\n```hemlock\nlet s = \"hello\";\nlet escaped = \"line1\\nline2\\ttabbed\";\nlet quote = \"She said \\\"hello\\\"\";\n\n// 十六进制转义序列\nlet hex_esc = \"\\x48\\x65\\x6c\\x6c\\x6f\";  // \"Hello\"\n\n// Unicode 转义序列\nlet emoji = \"\\u{1F600}\";               // 😀\nlet heart = \"\\u{2764}\";                // ❤\nlet mixed = \"Hello \\u{1F30D}!\";        // Hello 🌍!\n```\n\n**转义序列：**\n- `\\n` - 换行\n- `\\t` - 制表符\n- `\\r` - 回车\n- `\\\\` - 反斜杠\n- `\\\"` - 双引号\n- `\\'` - 单引号\n- `\\0` - 空字符\n- `\\xNN` - 十六进制转义（2 位）\n- `\\u{XXXX}` - Unicode 转义（1-6 位）\n\n### Rune 字面量\n\n```hemlock\nlet ch = 'A';\nlet emoji = '🚀';\nlet escaped = '\\n';\nlet unicode = '\\u{1F680}';\nlet hex_rune = '\\x41';      // 'A'\n```\n\n### 布尔字面量\n\n```hemlock\nlet t = true;\nlet f = false;\n```\n\n### Null 字面量\n\n```hemlock\nlet nothing = null;\n```\n\n## 作用域规则\n\n### 块作用域\n\n变量的作用域为最近的封闭块：\n\n```hemlock\nlet x = 1;  // 外部作用域\n\nif (true) {\n    let x = 2;  // 内部作用域（遮蔽外部）\n    print(x);   // 2\n}\n\nprint(x);  // 1\n```\n\n### 函数作用域\n\n函数创建自己的作用域：\n\n```hemlock\nlet global = \"global\";\n\nfn foo() {\n    let local = \"local\";\n    print(global);  // 可以读取外部作用域\n}\n\nfoo();\n// print(local);  // 错误：'local' 在此处未定义\n```\n\n### 闭包作用域\n\n闭包捕获封闭作用域的变量：\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // 捕获 'count'\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\n```\n\n## 空白和格式\n\n### 缩进\n\nHemlock 不强制特定缩进，但建议使用 4 个空格：\n\n```hemlock\nfn example() {\n    if (true) {\n        print(\"indented\");\n    }\n}\n```\n\n### 换行\n\n语句可以跨越多行：\n\n```hemlock\nlet result =\n    very_long_function_name(\n        arg1,\n        arg2,\n        arg3\n    );\n```\n\n## Loop 语句\n\n`loop` 关键字为无限循环提供更清晰的语法：\n\n```hemlock\nloop {\n    // ... 执行工作\n    if (done) {\n        break;\n    }\n}\n```\n\n这等价于 `while (true)`，但意图更明确。\n\n## 保留关键字\n\n以下关键字在 Hemlock 中是保留的：\n\n```\nlet, const, fn, if, else, while, for, in, loop, break, continue,\nreturn, true, false, null, typeof, import, export, from,\ntry, catch, finally, throw, panic, async, await, spawn, join,\ndetach, channel, define, switch, case, default, extern, self,\ntype, defer, enum, ref, buffer, Self\n```\n\n## 下一步\n\n- [类型系统](#language-guide-types) - 了解 Hemlock 的类型系统\n- [控制流](#language-guide-control-flow) - 深入了解控制结构\n- [函数](#language-guide-functions) - 掌握函数和闭包\n- [内存管理](#language-guide-memory) - 理解指针和缓冲区\n"}, "Language Guide -> Types": {"id": "language-guide-types", "content": "# 类型系统\n\nHemlock 具有**动态类型系统**，支持可选的类型注解和运行时类型检查。\n\n---\n\n## 类型选择指南：我应该使用什么类型？\n\n**类型新手？** 从这里开始。如果你熟悉类型系统，可以跳到[设计理念](#设计理念)。\n\n### 简短答案\n\n**让 Hemlock 自动判断：**\n\n```hemlock\nlet count = 42;        // Hemlock 知道这是整数\nlet price = 19.99;     // Hemlock 知道这是小数\nlet name = \"Alice\";    // Hemlock 知道这是文本\nlet active = true;     // Hemlock 知道这是布尔值\n```\n\nHemlock 会自动为你的值选择正确的类型。你*不需要*指定类型。\n\n### 何时添加类型注解\n\n在以下情况下添加类型：\n\n1. **需要指定大小** - `i8` 与 `i64` 对于内存或 FFI 很重要\n2. **记录代码** - 类型显示函数期望什么\n3. **尽早发现错误** - Hemlock 在运行时检查类型\n\n```hemlock\n// 无类型（正常工作）：\nfn add(a, b) {\n    return a + b;\n}\n\n// 有类型（更明确）：\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### 快速参考：选择数字类型\n\n| 存储内容 | 建议类型 | 示例 |\n|---------|---------|------|\n| 普通整数 | `i32`（默认） | `let count = 42;` |\n| 非常大的数字 | `i64` | `let population = 8000000000;` |\n| 永不为负的计数 | `u32` | `let items: u32 = 100;` |\n| 字节 (0-255) | `u8` | `let pixel: u8 = 255;` |\n| 小数/分数 | `f64`（默认） | `let price = 19.99;` |\n| 性能关键的小数 | `f32` | `let x: f32 = 1.5;` |\n\n### 快速参考：所有类型\n\n| 类别 | 类型 | 何时使用 |\n|-----|------|---------|\n| **整数** | `i8`, `i16`, `i32`, `i64` | 计数、ID、年龄等 |\n| **仅正数** | `u8`, `u16`, `u32`, `u64` | 字节、大小、数组长度 |\n| **小数** | `f32`, `f64` | 金额、测量值、数学计算 |\n| **是/否** | `bool` | 标志、条件 |\n| **文本** | `string` | 名称、消息、任何文本 |\n| **单个字符** | `rune` | 单个字母、表情符号 |\n| **列表** | `array` | 值的集合 |\n| **命名字段** | `object` | 分组相关数据 |\n| **原始内存** | `ptr`, `buffer` | 低级编程 |\n| **空值** | `null` | 表示没有值 |\n\n### 常见场景\n\n**\"我只需要一个数字\"**\n```hemlock\nlet x = 42;  // 完成！Hemlock 选择 i32\n```\n\n**\"我需要小数\"**\n```hemlock\nlet price = 19.99;  // 完成！Hemlock 选择 f64\n```\n\n**\"我在处理字节（文件、网络）\"**\n```hemlock\nlet byte: u8 = 255;  // 0-255 范围\n```\n\n**\"我需要非常大的数字\"**\n```hemlock\nlet big = 9000000000000;  // Hemlock 自动选择 i64（> i32 最大值）\n// 或者明确指定：\nlet big: i64 = 9000000000000;\n```\n\n**\"我在存储金额\"**\n```hemlock\n// 选项 1：浮点数（简单，但有精度限制）\nlet price: f64 = 19.99;\n\n// 选项 2：以分为单位存储（更精确）\nlet price_cents: i32 = 1999;  // $19.99 作为整数分\n```\n\n**\"我在向 C 代码传递数据 (FFI)\"**\n```hemlock\n// 精确匹配 C 类型\nlet c_int: i32 = 100;      // C 'int'\nlet c_long: i64 = 100;     // C 'long'（64 位系统）\nlet c_char: u8 = 65;       // C 'char'\nlet c_double: f64 = 3.14;  // C 'double'\n```\n\n### 类型混合时会发生什么？\n\n当你组合不同类型时，Hemlock 会提升为\"更大\"的类型：\n\n```hemlock\nlet a: i32 = 10;\nlet b: f64 = 2.5;\nlet result = a + b;  // result 是 f64 (12.5)\n// 整数自动变成了小数\n```\n\n**经验法则：** 浮点数总是\"赢\" - 任何整数与浮点数混合都会得到浮点数。\n\n### 类型错误\n\n如果你尝试使用错误的类型，Hemlock 会在运行时告诉你：\n\n```hemlock\nlet age: i32 = \"thirty\";  // 错误：类型不匹配 - 期望 i32，得到 string\n```\n\n要转换类型，使用类型构造函数：\n\n```hemlock\nlet text = \"42\";\nlet number = i32(text);   // 解析字符串为整数：42\nlet back = text + \"\";     // 已经是字符串\n```\n\n---\n\n## 设计理念\n\n- **默认动态** - 每个值都有运行时类型标签\n- **可选类型** - 可选的类型注解强制运行时检查\n- **显式转换** - 隐式转换遵循明确的提升规则\n- **类型诚实** - `typeof()` 始终说实话\n\n## 原始类型\n\n### 整数类型\n\n**有符号整数：**\n```hemlock\nlet tiny: i8 = 127;              // 8 位（-128 到 127）\nlet small: i16 = 32767;          // 16 位（-32768 到 32767）\nlet normal: i32 = 2147483647;    // 32 位（默认）\nlet large: i64 = 9223372036854775807;  // 64 位\n```\n\n**无符号整数：**\n```hemlock\nlet byte: u8 = 255;              // 8 位（0 到 255）\nlet word: u16 = 65535;           // 16 位（0 到 65535）\nlet dword: u32 = 4294967295;     // 32 位（0 到 4294967295）\nlet qword: u64 = 18446744073709551615;  // 64 位\n```\n\n**类型别名：**\n```hemlock\nlet i: integer = 42;   // i32 的别名\nlet b: byte = 255;     // u8 的别名\n```\n\n### 浮点类型\n\n```hemlock\nlet f: f32 = 3.14159;        // 32 位浮点数\nlet d: f64 = 2.718281828;    // 64 位浮点数（默认）\nlet n: number = 1.618;       // f64 的别名\n```\n\n### 布尔类型\n\n```hemlock\nlet flag: bool = true;\nlet active: bool = false;\n```\n\n### 字符串类型\n\n```hemlock\nlet text: string = \"Hello, World!\";\nlet empty: string = \"\";\n```\n\n字符串是**可变的**、**UTF-8 编码的**、**堆分配的**。\n\n详见 [Strings](#language-guide-strings)。\n\n### Rune 类型\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '🚀';\nlet newline: rune = '\\n';\nlet unicode: rune = '\\u{1F680}';\n```\n\nRune 表示 **Unicode 码点**（U+0000 到 U+10FFFF）。\n\n详见 [Runes](#language-guide-runes)。\n\n### Null 类型\n\n```hemlock\nlet nothing = null;\nlet uninitialized: string = null;\n```\n\n`null` 是具有单一值的独立类型。\n\n## 复合类型\n\n### 数组类型\n\n```hemlock\nlet numbers: array = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];  // 允许混合类型\nlet empty: array = [];\n```\n\n详见 [Arrays](#language-guide-arrays)。\n\n### 对象类型\n\n```hemlock\nlet obj: object = { x: 10, y: 20 };\nlet person = { name: \"Alice\", age: 30 };\n```\n\n详见 [Objects](#language-guide-objects)。\n\n### 指针类型\n\n**原始指针：**\n```hemlock\nlet p: ptr = alloc(64);\n// 无边界检查，手动生命周期管理\nfree(p);\n```\n\n**安全缓冲区：**\n```hemlock\nlet buf: buffer = buffer(64);\n// 有边界检查，跟踪长度和容量\nfree(buf);\n```\n\n详见 [Memory Management](#language-guide-memory)。\n\n## 枚举类型\n\n枚举定义一组命名常量：\n\n### 基本枚举\n\n```hemlock\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nlet c = Color.RED;\nprint(c);              // 0\nprint(typeof(c));      // \"Color\"\n\n// 比较\nif (c == Color.RED) {\n    print(\"It's red!\");\n}\n\n// 在枚举上使用 switch\nswitch (c) {\n    case Color.RED:\n        print(\"Stop\");\n        break;\n    case Color.GREEN:\n        print(\"Go\");\n        break;\n    case Color.BLUE:\n        print(\"Blue?\");\n        break;\n}\n```\n\n### 带值的枚举\n\n枚举可以有显式的整数值：\n\n```hemlock\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 2\n}\n\nprint(Status.OK);      // 0\nprint(Status.ERROR);   // 1\n\nenum HttpCode {\n    OK = 200,\n    NOT_FOUND = 404,\n    SERVER_ERROR = 500\n}\n\nlet code = HttpCode.NOT_FOUND;\nprint(code);           // 404\n```\n\n### 自动递增值\n\n没有显式值时，枚举从 0 自动递增：\n\n```hemlock\nenum Priority {\n    LOW,       // 0\n    MEDIUM,    // 1\n    HIGH,      // 2\n    CRITICAL   // 3\n}\n\n// 可以混合显式和自动值\nenum Level {\n    DEBUG = 10,\n    INFO,      // 11\n    WARN,      // 12\n    ERROR = 50,\n    FATAL      // 51\n}\n```\n\n### 枚举使用模式\n\n```hemlock\n// 作为函数参数\nfn set_priority(p: Priority) {\n    if (p == Priority.CRITICAL) {\n        print(\"Urgent!\");\n    }\n}\n\nset_priority(Priority.HIGH);\n\n// 在对象中\ndefine Task {\n    name: string,\n    priority: Priority\n}\n\nlet task: Task = {\n    name: \"Fix bug\",\n    priority: Priority.HIGH\n};\n```\n\n## 特殊类型\n\n### 文件类型\n\n```hemlock\nlet f: file = open(\"data.txt\", \"r\");\nf.close();\n```\n\n表示打开的文件句柄。\n\n### 任务类型\n\n```hemlock\nasync fn compute(): i32 { return 42; }\nlet task = spawn(compute);\nlet result: i32 = join(task);\n```\n\n表示异步任务句柄。\n\n### 通道类型\n\n```hemlock\nlet ch: channel = channel(10);\nch.send(42);\nlet value = ch.recv();\n```\n\n表示任务之间的通信通道。\n\n### Void 类型\n\n```hemlock\nextern fn exit(code: i32): void;\n```\n\n用于不返回值的函数（仅限 FFI）。\n\n## 类型推断\n\n### 整数字面量推断\n\nHemlock 根据值范围推断整数类型：\n\n```hemlock\nlet a = 42;              // i32（适合 32 位）\nlet b = 5000000000;      // i64（> i32 最大值）\nlet c = 128;             // i32\nlet d: u8 = 128;         // u8（显式注解）\n```\n\n**规则：**\n- i32 范围内的值（-2147483648 到 2147483647）：推断为 `i32`\n- 超出 i32 范围但在 i64 范围内的值：推断为 `i64`\n- 其他类型（i8、i16、u8、u16、u32、u64）使用显式注解\n\n### 浮点字面量推断\n\n```hemlock\nlet x = 3.14;        // f64（默认）\nlet y: f32 = 3.14;   // f32（显式）\n```\n\n### 科学计数法\n\nHemlock 支持数字字面量的科学计数法：\n\n```hemlock\nlet a = 1e10;        // 10000000000.0 (f64)\nlet b = 1e-12;       // 0.000000000001 (f64)\nlet c = 3.14e2;      // 314.0 (f64)\nlet d = 2.5e-3;      // 0.0025 (f64)\nlet e = 1E10;        // 大小写不敏感\nlet f = 1e+5;        // 显式正指数\n```\n\n**注意：** 使用科学计数法的任何字面量始终推断为 `f64`。\n\n### 其他类型推断\n\n```hemlock\nlet s = \"hello\";     // string\nlet ch = 'A';        // rune\nlet flag = true;     // bool\nlet arr = [1, 2, 3]; // array\nlet obj = { x: 10 }; // object\nlet nothing = null;  // null\n```\n\n## 类型注解\n\n### 变量注解\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet name: string = \"Alice\";\n```\n\n### 函数参数注解\n\n```hemlock\nfn greet(name: string, age: i32) {\n    print(\"Hello, \" + name + \"!\");\n}\n```\n\n### 函数返回类型注解\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### 对象类型注解（鸭子类型）\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\n```\n\n## 类型检查\n\n### 运行时类型检查\n\n类型注解在**运行时**检查，而不是编译时：\n\n```hemlock\nlet x: i32 = 42;     // OK\nlet y: i32 = 3.14;   // 运行时错误：类型不匹配\n\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 3);           // OK\nadd(5, \"hello\");     // 运行时错误：类型不匹配\n```\n\n### 类型查询\n\n使用 `typeof()` 检查值类型：\n\n```hemlock\nprint(typeof(42));         // \"i32\"\nprint(typeof(3.14));       // \"f64\"\nprint(typeof(\"hello\"));    // \"string\"\nprint(typeof(true));       // \"bool\"\nprint(typeof(null));       // \"null\"\nprint(typeof([1, 2, 3]));  // \"array\"\nprint(typeof({ x: 10 }));  // \"object\"\n```\n\n## 类型转换\n\n### 隐式类型提升\n\n当操作中混合类型时，Hemlock 提升为\"更高\"的类型：\n\n**提升层次（从低到高）：**\n```\ni8 → i16 → i32 → u32 → i64 → u64 → f32 → f64\n      ↑     ↑     ↑\n     u8    u16\n```\n\n**浮点数总是赢：**\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result 是 f64 (13.5)\n```\n\n**更大的尺寸赢：**\n```hemlock\nlet a: i32 = 100;\nlet b: i64 = 200;\nlet sum = a + b;     // sum 是 i64 (300)\n```\n\n**精度保持：** 当 64 位整数与 f32 混合时，Hemlock 提升为 f64 以避免精度损失（f32 只有 24 位尾数，不足以表示 i64/u64）：\n```hemlock\nlet big: i64 = 9007199254740993;\nlet small: f32 = 1.0;\nlet result = big + small;  // result 是 f64，不是 f32！\n```\n\n**示例：**\n```hemlock\nu8 + i32  → i32\ni32 + i64 → i64\nu32 + u64 → u64\ni32 + f32 → f32    // f32 足以表示 i32\ni64 + f32 → f64    // 需要 f64 来保持 i64 精度\ni64 + f64 → f64\ni8 + f64  → f64\n```\n\n### 显式类型转换\n\n**整数与浮点数转换：**\n```hemlock\nlet i: i32 = 42;\nlet f: f64 = i;      // i32 → f64 (42.0)\n\nlet x: f64 = 3.14;\nlet n: i32 = x;      // f64 → i32 (3，截断)\n```\n\n**整数与 Rune 转换：**\n```hemlock\nlet code: i32 = 65;\nlet ch: rune = code;  // i32 → rune ('A')\n\nlet r: rune = 'Z';\nlet value: i32 = r;   // rune → i32 (90)\n```\n\n**Rune 转字符串：**\n```hemlock\nlet ch: rune = '🚀';\nlet s: string = ch;   // rune → string (\"🚀\")\n```\n\n**u8 转 Rune：**\n```hemlock\nlet b: u8 = 65;\nlet r: rune = b;      // u8 → rune ('A')\n```\n\n### 类型构造函数\n\n类型名称可以用作函数来转换或解析值：\n\n**解析字符串为数字：**\n```hemlock\nlet n = i32(\"42\");       // 解析字符串为 i32：42\nlet f = f64(\"3.14159\");  // 解析字符串为 f64：3.14159\nlet b = bool(\"true\");    // 解析字符串为 bool：true\n\n// 支持所有数字类型\nlet a = i8(\"-128\");      // 解析为 i8\nlet c = u8(\"255\");       // 解析为 u8\nlet d = i16(\"1000\");     // 解析为 i16\nlet e = u16(\"50000\");    // 解析为 u16\nlet g = i64(\"9000000000000\"); // 解析为 i64\nlet h = u64(\"18000000000000\"); // 解析为 u64\nlet j = f32(\"1.5\");      // 解析为 f32\n```\n\n**十六进制和负数：**\n```hemlock\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\nlet bin = i32(\"0b1010\"); // 10（二进制）\n```\n\n**类型别名也可以：**\n```hemlock\nlet x = integer(\"100\");  // 等同于 i32(\"100\")\nlet y = number(\"1.5\");   // 等同于 f64(\"1.5\")\nlet z = byte(\"200\");     // 等同于 u8(\"200\")\n```\n\n**数字类型之间转换：**\n```hemlock\nlet big = i64(42);           // i32 转 i64\nlet truncated = i32(3.99);   // f64 转 i32（截断为 3）\nlet promoted = f64(100);     // i32 转 f64 (100.0)\nlet narrowed = i8(127);      // i32 转 i8\n```\n\n**类型注解执行数字强制转换（但不解析字符串）：**\n```hemlock\nlet f: f64 = 100;        // 通过注解 i32 转 f64（OK）\nlet s: string = 'A';     // 通过注解 Rune 转 string（OK）\nlet code: i32 = 'A';     // 通过注解 Rune 转 i32（获取码点，OK）\n\n// 字符串解析需要显式类型构造函数：\nlet n = i32(\"42\");       // 使用类型构造函数解析字符串\n// let x: i32 = \"42\";    // 错误 - 类型注解不解析字符串\n```\n\n**错误处理：**\n```hemlock\n// 使用类型构造函数时，无效字符串会抛出错误\nlet bad = i32(\"hello\");  // 运行时错误：无法将 \"hello\" 解析为 i32\nlet overflow = u8(\"256\"); // 运行时错误：256 超出 u8 范围\n```\n\n**布尔解析：**\n```hemlock\nlet t = bool(\"true\");    // true\nlet f = bool(\"false\");   // false\nlet bad = bool(\"yes\");   // 运行时错误：必须是 \"true\" 或 \"false\"\n```\n\n## 范围检查\n\n类型注解在赋值时强制范围检查：\n\n```hemlock\nlet x: u8 = 255;    // OK\nlet y: u8 = 256;    // 错误：超出 u8 范围\n\nlet a: i8 = 127;    // OK\nlet b: i8 = 128;    // 错误：超出 i8 范围\n\nlet c: i64 = 2147483647;   // OK\nlet d: u64 = 4294967295;   // OK\nlet e: u64 = -1;           // 错误：u64 不能为负\n```\n\n## 类型提升示例\n\n### 混合整数类型\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet sum = a + b;     // i32 (30)\n\nlet c: u8 = 100;\nlet d: u32 = 200;\nlet total = c + d;   // u32 (300)\n```\n\n### 整数 + 浮点数\n\n```hemlock\nlet i: i32 = 5;\nlet f: f32 = 2.5;\nlet result = i * f;  // f32 (12.5)\n```\n\n### 复杂表达式\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet c: f64 = 3.0;\n\nlet result = a + b * c;  // f64 (70.0)\n// 计算过程：b * c → f64(60.0)\n//           a + f64(60.0) → f64(70.0)\n```\n\n## 鸭子类型（对象）\n\n对象使用**结构类型**（鸭子类型）：\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK：有所有必需字段\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK：允许额外字段\nlet p2: Person = { name: \"Bob\", age: 25, city: \"NYC\" };\n\n// 错误：缺少 'age' 字段\nlet p3: Person = { name: \"Carol\" };\n\n// 错误：'age' 类型错误\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```\n\n**类型检查在赋值时进行：**\n- 验证所有必需字段存在\n- 验证字段类型匹配\n- 允许并保留额外字段\n- 为 `typeof()` 设置对象的类型名称\n\n## 可选字段\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug?: false,     // 带默认值的可选字段\n    timeout?: i32,     // 可选，默认为 null\n}\n\nlet cfg1: Config = { host: \"localhost\", port: 8080 };\nprint(cfg1.debug);    // false（默认）\nprint(cfg1.timeout);  // null\n\nlet cfg2: Config = { host: \"0.0.0.0\", port: 80, debug: true };\nprint(cfg2.debug);    // true（已覆盖）\n```\n\n## 类型别名\n\nHemlock 使用 `type` 关键字支持自定义类型别名：\n\n### 基本类型别名\n\n```hemlock\n// 简单类型别名\ntype Integer = i32;\ntype Text = string;\n\n// 使用别名\nlet x: Integer = 42;\nlet msg: Text = \"hello\";\n```\n\n### 函数类型别名\n\n```hemlock\n// 函数类型别名\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// 使用函数类型别名\nlet cb: Callback = fn(n) { print(n); };\nlet isEven: Predicate = fn(n) { return n % 2 == 0; };\n```\n\n### 复合类型别名\n\n```hemlock\n// 将多个 define 组合成一个类型\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\ntype Person = HasName & HasAge;\n\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\n### 泛型类型别名\n\n```hemlock\n// 泛型类型别名\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// 使用泛型别名\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**注意：** 类型别名是透明的 - `typeof()` 返回底层类型名称，而不是别名。\n\n## 类型系统限制\n\n当前限制：\n\n- **函数无泛型** - 尚不支持函数类型参数\n- **无联合类型** - 无法表达 \"A 或 B\"\n- **无可空类型** - 所有类型都可以为 null（使用 `?` 后缀表示显式可空）\n\n**注意：** 编译器（`hemlockc`）提供编译时类型检查。解释器仅执行运行时类型检查。详见[编译器文档](#design-implementation)。\n\n## 最佳实践\n\n### 何时使用类型注解\n\n**应该使用注解的情况：**\n- 精确类型很重要（例如，字节值使用 `u8`）\n- 记录函数接口\n- 强制约束（例如，范围检查）\n\n```hemlock\nfn hash(data: buffer, length: u32): u64 {\n    // 实现\n}\n```\n\n**不需要使用注解的情况：**\n- 类型从字面量明显可知\n- 内部实现细节\n- 不必要的形式化\n\n```hemlock\n// 不必要\nlet x: i32 = 42;\n\n// 更好\nlet x = 42;\n```\n\n### 类型安全模式\n\n**使用前检查：**\n```hemlock\nif (typeof(value) == \"i32\") {\n    // 可以安全地作为 i32 使用\n}\n```\n\n**验证函数参数：**\n```hemlock\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" || typeof(b) != \"i32\") {\n        throw \"arguments must be integers\";\n    }\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n```\n\n**使用鸭子类型获得灵活性：**\n```hemlock\ndefine Printable {\n    toString: fn,\n}\n\nfn print_item(item: Printable) {\n    print(item.toString());\n}\n```\n\n## 下一步\n\n- [Strings](#language-guide-strings) - UTF-8 字符串类型和操作\n- [Runes](#language-guide-runes) - Unicode 码点类型\n- [Arrays](#language-guide-arrays) - 动态数组类型\n- [Objects](#language-guide-objects) - 对象字面量和鸭子类型\n- [Memory](#language-guide-memory) - 指针和缓冲区类型\n"}, "Advanced Topics -> Async Concurrency": {"id": "advanced-async-concurrency", "content": "# Hemlock 异步/并发编程\n\nHemlock 提供**结构化并发**，支持 async/await 语法、任务生成和通道通信。实现基于 POSIX 线程（pthreads），实现**真正的多线程并行**。\n\n## 目录\n\n- [概述](#概述)\n- [线程模型](#线程模型)\n- [异步函数](#异步函数)\n- [任务生成](#任务生成)\n- [通道](#通道)\n- [异常传播](#异常传播)\n- [实现细节](#实现细节)\n- [最佳实践](#最佳实践)\n- [性能特性](#性能特性)\n- [当前限制](#当前限制)\n\n## 概述\n\n**这意味着：**\n- 真正的操作系统线程 - 每个生成的任务运行在独立的 pthread（POSIX 线程）上\n- 真正的并行 - 任务在多个 CPU 核心上同时执行\n- 内核调度 - 操作系统调度器将任务分配到可用的核心上\n- 线程安全的通道 - 使用 pthread 互斥锁和条件变量进行同步\n\n**这不是：**\n- 不是绿色线程 - 不是用户空间的协作式多任务\n- 不是 async/await 协程 - 不是像 JavaScript/Python asyncio 那样的单线程事件循环\n- 不是模拟并发 - 不是模拟的并行\n\n这与 **C、C++ 和 Rust** 使用操作系统线程时的**线程模型相同**。你可以获得跨多个核心的真正并行执行。\n\n## 线程模型\n\n### 1:1 线程模型\n\nHemlock 使用 **1:1 线程模型**，其中：\n- 每个生成的任务通过 `pthread_create()` 创建专用的操作系统线程\n- 操作系统内核在可用的 CPU 核心间调度线程\n- 抢占式多任务 - 操作系统可以中断并在线程之间切换\n- **无 GIL** - 不像 Python，没有全局解释器锁限制并行性\n\n### 同步机制\n\n- **互斥锁** - 通道使用 `pthread_mutex_t` 实现线程安全访问\n- **条件变量** - 阻塞的发送/接收使用 `pthread_cond_t` 实现高效等待\n- **无锁操作** - 任务状态转换是原子的\n\n## 异步函数\n\n函数可以声明为 `async`，表示它们设计用于并发执行：\n\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n```\n\n### 要点\n\n- `async fn` 声明异步函数\n- 异步函数可以使用 `spawn()` 作为并发任务生成\n- 异步函数也可以直接调用（在当前线程同步运行）\n- 生成时，每个任务运行在**自己的操作系统线程**上（不是协程！）\n- `await` 关键字保留供将来使用\n\n### 示例：直接调用 vs 生成\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// 直接调用 - 同步运行\nlet result1 = factorial(5);  // 120\n\n// 生成任务 - 在独立线程上运行\nlet task = spawn(factorial, 5);\nlet result2 = join(task);  // 120\n```\n\n## 任务生成\n\n使用 `spawn()` 在**独立的操作系统线程上并行**运行异步函数：\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// 生成多个任务 - 这些在不同的 CPU 核心上并行运行！\nlet t1 = spawn(factorial, 5);  // 线程 1\nlet t2 = spawn(factorial, 6);  // 线程 2\nlet t3 = spawn(factorial, 7);  // 线程 3\n\n// 三个任务现在正在同时计算！\n\n// 等待结果\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\n```\n\n### 内置函数\n\n#### spawn(async_fn, arg1, arg2, ...)\n\n在新的 pthread 上创建新任务，返回任务句柄。\n\n**参数：**\n- `async_fn` - 要执行的异步函数\n- `arg1, arg2, ...` - 传递给函数的参数\n\n**返回：** 任务句柄（与 `join()` 或 `detach()` 一起使用的不透明值）\n\n**示例：**\n```hemlock\nasync fn process(data: string, count: i32): i32 {\n    // ... 处理逻辑\n    return count * 2;\n}\n\nlet task = spawn(process, \"test\", 42);\n```\n\n#### join(task)\n\n等待任务完成（阻塞直到线程结束），返回结果。\n\n**参数：**\n- `task` - 从 `spawn()` 返回的任务句柄\n\n**返回：** 异步函数返回的值\n\n**示例：**\n```hemlock\nlet task = spawn(compute, 1000);\nlet result = join(task);  // 阻塞直到 compute() 完成\nprint(result);\n```\n\n**重要：** 每个任务只能 join 一次。后续的 join 将会报错。\n\n#### detach(task)\n\n即发即忘执行（线程独立运行，不允许 join）。\n\n**参数：**\n- `task` - 从 `spawn()` 返回的任务句柄\n\n**返回：** `null`\n\n**示例：**\n```hemlock\nasync fn background_work() {\n    // 长时间运行的后台任务\n    // ...\n}\n\nlet task = spawn(background_work);\ndetach(task);  // 任务独立运行，无法 join\n```\n\n**重要：** 分离的任务无法 join。当任务完成时，pthread 和 Task 结构都会自动清理。\n\n## 通道\n\n通道使用有界缓冲区和阻塞语义，提供任务间的线程安全通信。\n\n### 创建通道\n\n```hemlock\nlet ch = channel(10);  // 创建缓冲区大小为 10 的通道\n```\n\n**参数：**\n- `capacity` (i32) - 通道可容纳的最大值数量\n\n**返回：** 通道对象\n\n### 通道方法\n\n#### send(value)\n\n向通道发送值（如果已满则阻塞）。\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet task = spawn(producer, ch, 5);\n```\n\n**行为：**\n- 如果通道有空间，值会立即添加\n- 如果通道已满，发送者阻塞直到有空间可用\n- 如果通道已关闭，抛出异常\n\n#### recv()\n\n从通道接收值（如果为空则阻塞）。\n\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet task = spawn(consumer, ch, 5);\n```\n\n**行为：**\n- 如果通道有值，立即返回下一个值\n- 如果通道为空，接收者阻塞直到有值可用\n- 如果通道已关闭且为空，返回 `null`\n\n#### close()\n\n关闭通道（在已关闭的通道上 recv 返回 null）。\n\n```hemlock\nch.close();\n```\n\n**行为：**\n- 阻止进一步的 `send()` 操作（将抛出异常）\n- 允许挂起的 `recv()` 操作完成\n- 一旦为空，`recv()` 返回 `null`\n\n### 使用 select() 多路复用\n\n`select()` 函数允许同时等待多个通道，当任何通道有数据可用时返回。\n\n**签名：**\n```hemlock\nselect(channels: array, timeout_ms?: i32): object | null\n```\n\n**参数：**\n- `channels` - 通道值数组\n- `timeout_ms`（可选）- 超时毫秒数（-1 或省略表示无限等待）\n\n**返回：**\n- `{ channel, value }` - 包含有数据的通道和接收到的值的对象\n- `null` - 超时时（如果指定了超时）\n\n**示例：**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// 生产者任务\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"from channel 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"from channel 2\");\n});\n\n// 等待第一个结果（ch2 应该更快）\nlet result = select([ch1, ch2]);\nprint(result.value);  // \"from channel 2\"\n\n// 等待第二个结果\nlet result2 = select([ch1, ch2]);\nprint(result2.value);  // \"from channel 1\"\n```\n\n**带超时：**\n```hemlock\nlet ch = channel(1);\n\n// 没有发送者，将超时\nlet result = select([ch], 100);  // 100ms 超时\nif (result == null) {\n    print(\"Timed out!\");\n}\n```\n\n**使用场景：**\n- 等待多个数据源中最快的一个\n- 在通道操作上实现超时\n- 具有多个事件源的事件循环模式\n- 扇入：将多个通道合并为一个\n\n**扇入模式：**\n```hemlock\nfn fan_in(channels: array, output: channel) {\n    while (true) {\n        let result = select(channels);\n        if (result == null) {\n            break;  // 所有通道已关闭\n        }\n        output.send(result.value);\n    }\n    output.close();\n}\n```\n\n### 完整的生产者-消费者示例\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// 创建带缓冲区大小的通道\nlet ch = channel(10);\n\n// 生成生产者和消费者\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// 等待完成\njoin(p);\nlet total = join(c);  // 100 (0+10+20+30+40)\nprint(total);\n```\n\n### 多生产者，多消费者\n\n通道可以在多个生产者和消费者之间安全共享：\n\n```hemlock\nasync fn producer(id: i32, ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(id * 100 + i);\n        i = i + 1;\n    }\n}\n\nasync fn consumer(id: i32, ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(20);\n\n// 多个生产者\nlet p1 = spawn(producer, 1, ch, 5);\nlet p2 = spawn(producer, 2, ch, 5);\n\n// 多个消费者\nlet c1 = spawn(consumer, 1, ch, 5);\nlet c2 = spawn(consumer, 2, ch, 5);\n\n// 等待所有\njoin(p1);\njoin(p2);\nlet sum1 = join(c1);\nlet sum2 = join(c2);\nprint(sum1 + sum2);\n```\n\n## 异常传播\n\n在生成的任务中抛出的异常会在 join 时传播：\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Caught: \" + e);  // \"Caught: Task failed!\"\n}\n```\n\n### 异常处理模式\n\n**模式 1：在任务中处理**\n```hemlock\nasync fn safe_task() {\n    try {\n        // 有风险的操作\n    } catch (e) {\n        print(\"Error in task: \" + e);\n        return null;\n    }\n}\n\nlet task = spawn(safe_task);\njoin(task);  // 没有异常传播\n```\n\n**模式 2：传播给调用者**\n```hemlock\nasync fn task_that_throws() {\n    throw \"error\";\n}\n\nlet task = spawn(task_that_throws);\ntry {\n    join(task);\n} catch (e) {\n    print(\"Caught from task: \" + e);\n}\n```\n\n**模式 3：带异常的分离任务**\n```hemlock\nasync fn detached_task() {\n    try {\n        // 工作\n    } catch (e) {\n        // 必须在内部处理 - 无法传播\n        print(\"Error: \" + e);\n    }\n}\n\nlet task = spawn(detached_task);\ndetach(task);  // 无法从分离的任务捕获异常\n```\n\n## 实现细节\n\n### 线程架构\n\n- **1:1 线程** - 每个生成的任务通过 `pthread_create()` 创建专用的操作系统线程\n- **内核调度** - 操作系统内核在可用的 CPU 核心间调度线程\n- **抢占式多任务** - 操作系统可以中断并在线程之间切换\n- **无 GIL** - 不像 Python，没有全局解释器锁限制并行性\n\n### 通道实现\n\n通道使用带 pthread 同步的循环缓冲区：\n\n```\n通道结构：\n- buffer[] - 固定大小的 Values 数组\n- capacity - 最大元素数\n- size - 当前元素数\n- head - 读取位置\n- tail - 写入位置\n- mutex - pthread_mutex_t 用于线程安全访问\n- not_empty - pthread_cond_t 用于阻塞 recv\n- not_full - pthread_cond_t 用于阻塞 send\n- closed - 布尔标志\n- refcount - 用于清理的引用计数\n```\n\n**阻塞行为：**\n- 在满通道上 `send()`：等待 `not_full` 条件变量\n- 在空通道上 `recv()`：等待 `not_empty` 条件变量\n- 两者都由相反的操作在适当时发出信号\n\n### 内存和清理\n\n- **已 join 的任务：** 在 `join()` 返回后自动清理\n- **分离的任务：** 在任务完成时自动清理\n- **通道：** 引用计数，不再使用时释放\n\n## 最佳实践\n\n### 1. 始终关闭通道\n\n```hemlock\nasync fn producer(ch) {\n    // ... 发送值\n    ch.close();  // 重要：表示没有更多的值\n}\n```\n\n### 2. 使用结构化并发\n\n在同一作用域中生成任务并 join 它们：\n\n```hemlock\nfn process_data(data) {\n    // 生成任务\n    let t1 = spawn(worker, data);\n    let t2 = spawn(worker, data);\n\n    // 返回前始终 join\n    let r1 = join(t1);\n    let r2 = join(t2);\n\n    return r1 + r2;\n}\n```\n\n### 3. 适当处理异常\n\n```hemlock\nasync fn task() {\n    try {\n        // 有风险的操作\n    } catch (e) {\n        // 记录错误\n        throw e;  // 如果调用者需要知道则重新抛出\n    }\n}\n```\n\n### 4. 使用适当的通道容量\n\n- **小容量（1-10）：** 用于协调/信号\n- **中等容量（10-100）：** 用于一般生产者-消费者\n- **大容量（100+）：** 用于高吞吐量场景\n\n```hemlock\nlet signal_ch = channel(1);      // 协调\nlet work_ch = channel(50);       // 工作队列\nlet buffer_ch = channel(1000);   // 高吞吐量\n```\n\n### 5. 仅在必要时分离\n\n优先使用 `join()` 而不是 `detach()` 以更好地管理资源：\n\n```hemlock\n// 好：Join 并获取结果\nlet task = spawn(work);\nlet result = join(task);\n\n// 仅对真正的即发即忘使用 detach\nlet bg_task = spawn(background_logging);\ndetach(bg_task);  // 将独立运行\n```\n\n## 性能特性\n\n### 真正的并行\n\n- **N 个生成的任务可以同时利用 N 个 CPU 核心**\n- 经验证的加速 - 压力测试显示 CPU 时间 vs 墙钟时间为 8-9 倍（多核工作）\n- 随核心数线性扩展（直到线程数）\n\n### 线程开销\n\n- 每个任务有约 8KB 栈 + pthread 开销\n- 线程创建成本：约 10-20 微秒\n- 上下文切换成本：约 1-5 微秒\n\n### 何时使用异步\n\n**好的使用场景：**\n- 可并行化的 CPU 密集型计算\n- I/O 密集型操作（尽管 I/O 仍然是阻塞的）\n- 独立数据的并发处理\n- 使用通道的流水线架构\n\n**不理想的场景：**\n- 非常短的任务（线程开销占主导）\n- 有大量同步的任务（竞争开销）\n- 单核系统（没有并行性收益）\n\n### 阻塞 I/O 安全\n\n一个任务中的阻塞操作不会阻塞其他任务：\n\n```hemlock\nasync fn reader(filename: string) {\n    let f = open(filename, \"r\");  // 只阻塞此线程\n    let content = f.read();       // 只阻塞此线程\n    f.close();\n    return content;\n}\n\n// 两者并发读取（在不同线程上）\nlet t1 = spawn(reader, \"file1.txt\");\nlet t2 = spawn(reader, \"file2.txt\");\n\nlet c1 = join(t1);\nlet c2 = join(t2);\n```\n\n## 线程安全模型\n\nHemlock 使用**消息传递**并发模型，任务通过通道而不是共享可变状态进行通信。\n\n### 参数隔离\n\n当你生成任务时，**参数会深拷贝**以防止数据竞争：\n\n```hemlock\nasync fn modify_array(arr: array): array {\n    arr.push(999);    // 修改的是副本，不是原始数组\n    arr[0] = -1;\n    return arr;\n}\n\nlet original = [1, 2, 3];\nlet task = spawn(modify_array, original);\nlet modified = join(task);\n\nprint(original.length);  // 3 - 未改变！\nprint(modified.length);  // 4 - 有新元素\n```\n\n**会深拷贝的：**\n- 数组（及所有元素递归）\n- 对象（及所有字段递归）\n- 字符串\n- 缓冲区\n\n**会共享的（保留引用）：**\n- 通道（通信机制 - 故意共享）\n- 任务句柄（用于协调）\n- 函数（代码是不可变的）\n- 文件句柄（操作系统管理并发访问）\n- 套接字句柄（操作系统管理并发访问）\n\n**不能传递的：**\n- 原始指针（`ptr`）- 改用 `buffer`\n\n### 为什么使用消息传递？\n\n这遵循 Hemlock 的\"显式优于隐式\"哲学：\n\n```hemlock\n// 不好：共享可变状态（会导致数据竞争）\nlet counter = { value: 0 };\nlet t1 = spawn(fn() { counter.value = counter.value + 1; });  // 竞争！\nlet t2 = spawn(fn() { counter.value = counter.value + 1; });  // 竞争！\n\n// 好：通过通道的消息传递\nasync fn increment(ch) {\n    let val = ch.recv();\n    ch.send(val + 1);\n}\n\nlet ch = channel(1);\nch.send(0);\nlet t1 = spawn(increment, ch);\njoin(t1);\nlet result = ch.recv();  // 1 - 没有竞争条件\n```\n\n### 引用计数线程安全\n\n所有引用计数操作使用**原子操作**以防止释放后使用错误：\n- `string_retain/release` - 原子\n- `array_retain/release` - 原子\n- `object_retain/release` - 原子\n- `buffer_retain/release` - 原子\n- `function_retain/release` - 原子\n- `channel_retain/release` - 原子\n- `task_retain/release` - 原子\n\n这确保即使值跨线程共享也能安全地进行内存管理。\n\n### 闭包环境访问\n\n任务可以访问闭包环境：\n- 内置函数（`print`、`len` 等）\n- 全局函数定义\n- 常量和变量\n\n闭包环境由每个环境的互斥锁保护，使并发读写线程安全：\n\n```hemlock\nlet x = 10;\n\nasync fn read_closure(): i32 {\n    return x;  // OK：读取闭包变量（线程安全）\n}\n\nasync fn modify_closure() {\n    x = 20;  // OK：写入闭包变量（与互斥锁同步）\n}\n```\n\n**注意：** 虽然并发访问是同步的，但从多个任务修改共享状态仍可能导致逻辑竞争条件（非确定性顺序）。为了可预测的行为，使用通道进行任务通信或使用任务返回值。\n\n如果需要从任务返回数据，使用返回值或通道。\n\n## 当前限制\n\n### 1. 没有工作窃取调度器\n\n每个任务使用 1 个线程，对于许多短任务可能效率不高。\n\n**当前：** 1000 个任务 = 1000 个线程（开销大）\n\n**计划中：** 带工作窃取的线程池以提高效率\n\n### 3. 没有异步 I/O 集成\n\n文件/网络操作仍然阻塞线程：\n\n```hemlock\nasync fn read_file(path: string) {\n    let f = open(path, \"r\");\n    let content = f.read();  // 阻塞线程\n    f.close();\n    return content;\n}\n```\n\n**变通方法：** 使用多线程进行并发 I/O 操作\n\n### 4. 固定通道容量\n\n通道容量在创建时设置，无法调整大小：\n\n```hemlock\nlet ch = channel(10);\n// 无法动态调整到 20\n```\n\n### 5. 通道大小固定\n\n通道缓冲区大小在创建后无法更改。\n\n## 常见模式\n\n### 并行 Map\n\n```hemlock\nasync fn map_worker(ch_in, ch_out, fn_transform) {\n    while (true) {\n        let val = ch_in.recv();\n        if (val == null) { break; }\n\n        let result = fn_transform(val);\n        ch_out.send(result);\n    }\n    ch_out.close();\n}\n\nfn parallel_map(data, fn_transform, workers: i32) {\n    let ch_in = channel(100);\n    let ch_out = channel(100);\n\n    // 生成工作者\n    let tasks = [];\n    let i = 0;\n    while (i < workers) {\n        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));\n        i = i + 1;\n    }\n\n    // 发送数据\n    let i = 0;\n    while (i < data.length) {\n        ch_in.send(data[i]);\n        i = i + 1;\n    }\n    ch_in.close();\n\n    // 收集结果\n    let results = [];\n    let i = 0;\n    while (i < data.length) {\n        results.push(ch_out.recv());\n        i = i + 1;\n    }\n\n    // 等待工作者\n    let i = 0;\n    while (i < tasks.length) {\n        join(tasks[i]);\n        i = i + 1;\n    }\n\n    return results;\n}\n```\n\n### 流水线架构\n\n```hemlock\nasync fn stage1(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val * 2);\n    }\n    output_ch.close();\n}\n\nasync fn stage2(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val + 10);\n    }\n    output_ch.close();\n}\n\n// 创建流水线\nlet ch1 = channel(10);\nlet ch2 = channel(10);\nlet ch3 = channel(10);\n\nlet s1 = spawn(stage1, ch1, ch2);\nlet s2 = spawn(stage2, ch2, ch3);\n\n// 输入数据\nch1.send(1);\nch1.send(2);\nch1.send(3);\nch1.close();\n\n// 收集输出\nprint(ch3.recv());  // 12 (1 * 2 + 10)\nprint(ch3.recv());  // 14 (2 * 2 + 10)\nprint(ch3.recv());  // 16 (3 * 2 + 10)\n\njoin(s1);\njoin(s2);\n```\n\n### 扇出，扇入\n\n```hemlock\nasync fn worker(id: i32, input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n\n        // 处理值\n        let result = val * id;\n        output_ch.send(result);\n    }\n}\n\nlet input = channel(10);\nlet output = channel(10);\n\n// 扇出：多个工作者\nlet workers = 4;\nlet tasks = [];\nlet i = 0;\nwhile (i < workers) {\n    tasks.push(spawn(worker, i, input, output));\n    i = i + 1;\n}\n\n// 发送工作\nlet i = 0;\nwhile (i < 10) {\n    input.send(i);\n    i = i + 1;\n}\ninput.close();\n\n// 扇入：收集所有结果\nlet results = [];\nlet i = 0;\nwhile (i < 10) {\n    results.push(output.recv());\n    i = i + 1;\n}\n\n// 等待所有工作者\nlet i = 0;\nwhile (i < tasks.length) {\n    join(tasks[i]);\n    i = i + 1;\n}\n```\n\n## 总结\n\nHemlock 的异步/并发模型提供：\n\n- 使用操作系统线程的真正多线程并行\n- 简单的结构化并发原语\n- 线程安全的通道通信\n- 跨任务的异常传播\n- 在多核系统上经验证的性能\n- **参数隔离** - 深拷贝防止数据竞争\n- **原子引用计数** - 跨线程安全的内存管理\n\n这使 Hemlock 适用于：\n- 并行计算\n- 并发 I/O 操作\n- 流水线架构\n- 生产者-消费者模式\n\n同时避免以下复杂性：\n- 手动线程管理\n- 低级同步原语\n- 容易死锁的基于锁的设计\n- 共享可变状态错误\n"}, "Advanced Topics -> Atomics": {"id": "advanced-atomics", "content": "# 原子操作\n\nHemlock 提供原子操作用于**无锁并发编程**。这些操作使得在多个线程间安全操作共享内存成为可能，无需传统的锁或互斥锁。\n\n## 目录\n\n- [概述](#概述)\n- [何时使用原子操作](#何时使用原子操作)\n- [内存模型](#内存模型)\n- [原子加载和存储](#原子加载和存储)\n- [获取并修改操作](#获取并修改操作)\n- [比较并交换 (CAS)](#比较并交换-cas)\n- [原子交换](#原子交换)\n- [内存栅栏](#内存栅栏)\n- [函数参考](#函数参考)\n- [常见模式](#常见模式)\n- [最佳实践](#最佳实践)\n- [限制](#限制)\n\n---\n\n## 概述\n\n原子操作是**不可分割的**操作，完成时不可能被中断。当一个线程执行原子操作时，其他线程无法观察到操作的部分完成状态。\n\n**主要特性：**\n- 所有操作使用**顺序一致性**（`memory_order_seq_cst`）\n- 支持的类型：**i32** 和 **i64**\n- 操作适用于通过 `alloc()` 分配的原始指针\n- 无需显式锁即可保证线程安全\n\n**可用操作：**\n- Load/Store - 原子读取和写入值\n- Add/Sub - 返回旧值的算术操作\n- And/Or/Xor - 返回旧值的位运算操作\n- CAS - 条件更新的比较并交换\n- Exchange - 原子交换值\n- Fence - 完整内存屏障\n\n---\n\n## 何时使用原子操作\n\n**使用原子操作的场景：**\n- 跨任务共享的计数器（如请求计数、进度跟踪）\n- 标志和状态指示器\n- 无锁数据结构\n- 简单的同步原语\n- 性能关键的并发代码\n\n**改用通道的场景：**\n- 在任务间传递复杂数据\n- 实现生产者-消费者模式\n- 需要消息传递语义时\n\n**示例用例 - 共享计数器：**\n```hemlock\n// 分配共享计数器\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nasync fn worker(counter: ptr, id: i32) {\n    let i = 0;\n    while (i < 1000) {\n        atomic_add_i32(counter, 1);\n        i = i + 1;\n    }\n}\n\n// 生成多个工作者\nlet t1 = spawn(worker, counter, 1);\nlet t2 = spawn(worker, counter, 2);\nlet t3 = spawn(worker, counter, 3);\n\njoin(t1);\njoin(t2);\njoin(t3);\n\n// 计数器将恰好是 3000（无数据竞争）\nprint(atomic_load_i32(counter));\n\nfree(counter);\n```\n\n---\n\n## 内存模型\n\n所有 Hemlock 原子操作使用**顺序一致性**（`memory_order_seq_cst`），提供最强的内存排序保证：\n\n1. **原子性**：每个操作都是不可分割的\n2. **全局排序**：所有线程看到相同的操作顺序\n3. **无重排序**：操作不会被编译器或 CPU 重排序\n\n这使得并发代码的推理更简单，但与较弱的内存排序相比可能有一些性能成本。\n\n---\n\n## 原子加载和存储\n\n### atomic_load_i32 / atomic_load_i64\n\n原子地从内存读取值。\n\n**签名：**\n```hemlock\natomic_load_i32(ptr: ptr): i32\natomic_load_i64(ptr: ptr): i64\n```\n\n**参数：**\n- `ptr` - 指向内存位置的指针（必须正确对齐）\n\n**返回：** 内存位置的值\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\n\nlet value = atomic_load_i32(p);\nprint(value);  // 42\n\nfree(p);\n```\n\n---\n\n### atomic_store_i32 / atomic_store_i64\n\n原子地向内存写入值。\n\n**签名：**\n```hemlock\natomic_store_i32(ptr: ptr, value: i32): null\natomic_store_i64(ptr: ptr, value: i64): null\n```\n\n**参数：**\n- `ptr` - 指向内存位置的指针\n- `value` - 要存储的值\n\n**返回：** `null`\n\n**示例：**\n```hemlock\nlet p = alloc(8);\n\natomic_store_i64(p, 5000000000);\nprint(atomic_load_i64(p));  // 5000000000\n\nfree(p);\n```\n\n---\n\n## 获取并修改操作\n\n这些操作原子地修改值并返回**旧的**（之前的）值。\n\n### atomic_add_i32 / atomic_add_i64\n\n原子地加法。\n\n**签名：**\n```hemlock\natomic_add_i32(ptr: ptr, value: i32): i32\natomic_add_i64(ptr: ptr, value: i64): i64\n```\n\n**返回：** **旧的**值（加法之前）\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_add_i32(p, 10);\nprint(old);                    // 100（旧值）\nprint(atomic_load_i32(p));     // 110（新值）\n\nfree(p);\n```\n\n---\n\n### atomic_sub_i32 / atomic_sub_i64\n\n原子地减法。\n\n**签名：**\n```hemlock\natomic_sub_i32(ptr: ptr, value: i32): i32\natomic_sub_i64(ptr: ptr, value: i64): i64\n```\n\n**返回：** **旧的**值（减法之前）\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_sub_i32(p, 25);\nprint(old);                    // 100（旧值）\nprint(atomic_load_i32(p));     // 75（新值）\n\nfree(p);\n```\n\n---\n\n### atomic_and_i32 / atomic_and_i64\n\n原子地执行按位与。\n\n**签名：**\n```hemlock\natomic_and_i32(ptr: ptr, value: i32): i32\natomic_and_i64(ptr: ptr, value: i64): i64\n```\n\n**返回：** **旧的**值（与运算之前）\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xFF);  // 二进制 255：11111111\n\nlet old = atomic_and_i32(p, 0x0F);  // 与 00001111 进行与运算\nprint(old);                    // 255（旧值）\nprint(atomic_load_i32(p));     // 15 (0xFF & 0x0F = 0x0F)\n\nfree(p);\n```\n\n---\n\n### atomic_or_i32 / atomic_or_i64\n\n原子地执行按位或。\n\n**签名：**\n```hemlock\natomic_or_i32(ptr: ptr, value: i32): i32\natomic_or_i64(ptr: ptr, value: i64): i64\n```\n\n**返回：** **旧的**值（或运算之前）\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0x0F);  // 二进制 15：00001111\n\nlet old = atomic_or_i32(p, 0xF0);  // 与 11110000 进行或运算\nprint(old);                    // 15（旧值）\nprint(atomic_load_i32(p));     // 255 (0x0F | 0xF0 = 0xFF)\n\nfree(p);\n```\n\n---\n\n### atomic_xor_i32 / atomic_xor_i64\n\n原子地执行按位异或。\n\n**签名：**\n```hemlock\natomic_xor_i32(ptr: ptr, value: i32): i32\natomic_xor_i64(ptr: ptr, value: i64): i64\n```\n\n**返回：** **旧的**值（异或运算之前）\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xAA);  // 二进制 170：10101010\n\nlet old = atomic_xor_i32(p, 0xFF);  // 与 11111111 进行异或运算\nprint(old);                    // 170（旧值）\nprint(atomic_load_i32(p));     // 85 (0xAA ^ 0xFF = 0x55)\n\nfree(p);\n```\n\n---\n\n## 比较并交换 (CAS)\n\n最强大的原子操作。原子地将当前值与期望值比较，如果匹配则替换为新值。\n\n### atomic_cas_i32 / atomic_cas_i64\n\n**签名：**\n```hemlock\natomic_cas_i32(ptr: ptr, expected: i32, desired: i32): bool\natomic_cas_i64(ptr: ptr, expected: i64, desired: i64): bool\n```\n\n**参数：**\n- `ptr` - 指向内存位置的指针\n- `expected` - 我们期望找到的值\n- `desired` - 如果期望匹配则存储的值\n\n**返回：**\n- `true` - 交换成功（值是 `expected`，现在是 `desired`）\n- `false` - 交换失败（值不是 `expected`，未改变）\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\n// CAS 成功：值是 100，交换为 999\nlet success1 = atomic_cas_i32(p, 100, 999);\nprint(success1);               // true\nprint(atomic_load_i32(p));     // 999\n\n// CAS 失败：值是 999，不是 100\nlet success2 = atomic_cas_i32(p, 100, 888);\nprint(success2);               // false\nprint(atomic_load_i32(p));     // 999（未改变）\n\nfree(p);\n```\n\n**用例：**\n- 实现锁和信号量\n- 无锁数据结构\n- 乐观并发控制\n- 原子条件更新\n\n---\n\n## 原子交换\n\n原子地交换值，返回旧值。\n\n### atomic_exchange_i32 / atomic_exchange_i64\n\n**签名：**\n```hemlock\natomic_exchange_i32(ptr: ptr, value: i32): i32\natomic_exchange_i64(ptr: ptr, value: i64): i64\n```\n\n**参数：**\n- `ptr` - 指向内存位置的指针\n- `value` - 要存储的新值\n\n**返回：** **旧的**值（交换之前）\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_exchange_i32(p, 200);\nprint(old);                    // 100（旧值）\nprint(atomic_load_i32(p));     // 200（新值）\n\nfree(p);\n```\n\n---\n\n## 内存栅栏\n\n完整的内存屏障，确保栅栏之前的所有内存操作对所有线程可见，然后才执行栅栏之后的任何操作。\n\n### atomic_fence\n\n**签名：**\n```hemlock\natomic_fence(): null\n```\n\n**返回：** `null`\n\n**示例：**\n```hemlock\n// 确保之前的所有写入对其他线程可见\natomic_fence();\n```\n\n**注意：** 在大多数情况下，你不需要显式的栅栏，因为所有原子操作已经使用顺序一致性。栅栏在需要同步非原子内存操作时很有用。\n\n---\n\n## 函数参考\n\n### i32 操作\n\n| 函数 | 签名 | 返回 | 描述 |\n|------|------|------|------|\n| `atomic_load_i32` | `(ptr)` | `i32` | 原子加载值 |\n| `atomic_store_i32` | `(ptr, value)` | `null` | 原子存储值 |\n| `atomic_add_i32` | `(ptr, value)` | `i32` | 加法并返回旧值 |\n| `atomic_sub_i32` | `(ptr, value)` | `i32` | 减法并返回旧值 |\n| `atomic_and_i32` | `(ptr, value)` | `i32` | 按位与并返回旧值 |\n| `atomic_or_i32` | `(ptr, value)` | `i32` | 按位或并返回旧值 |\n| `atomic_xor_i32` | `(ptr, value)` | `i32` | 按位异或并返回旧值 |\n| `atomic_cas_i32` | `(ptr, expected, desired)` | `bool` | 比较并交换 |\n| `atomic_exchange_i32` | `(ptr, value)` | `i32` | 交换并返回旧值 |\n\n### i64 操作\n\n| 函数 | 签名 | 返回 | 描述 |\n|------|------|------|------|\n| `atomic_load_i64` | `(ptr)` | `i64` | 原子加载值 |\n| `atomic_store_i64` | `(ptr, value)` | `null` | 原子存储值 |\n| `atomic_add_i64` | `(ptr, value)` | `i64` | 加法并返回旧值 |\n| `atomic_sub_i64` | `(ptr, value)` | `i64` | 减法并返回旧值 |\n| `atomic_and_i64` | `(ptr, value)` | `i64` | 按位与并返回旧值 |\n| `atomic_or_i64` | `(ptr, value)` | `i64` | 按位或并返回旧值 |\n| `atomic_xor_i64` | `(ptr, value)` | `i64` | 按位异或并返回旧值 |\n| `atomic_cas_i64` | `(ptr, expected, desired)` | `bool` | 比较并交换 |\n| `atomic_exchange_i64` | `(ptr, value)` | `i64` | 交换并返回旧值 |\n\n### 内存屏障\n\n| 函数 | 签名 | 返回 | 描述 |\n|------|------|------|------|\n| `atomic_fence` | `()` | `null` | 完整内存屏障 |\n\n---\n\n## 常见模式\n\n### 模式：原子计数器\n\n```hemlock\n// 线程安全的计数器\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nfn increment(): i32 {\n    return atomic_add_i32(counter, 1);\n}\n\nfn decrement(): i32 {\n    return atomic_sub_i32(counter, 1);\n}\n\nfn get_count(): i32 {\n    return atomic_load_i32(counter);\n}\n\n// 使用\nincrement();  // 返回 0（旧值）\nincrement();  // 返回 1\nincrement();  // 返回 2\nprint(get_count());  // 3\n\nfree(counter);\n```\n\n### 模式：自旋锁\n\n```hemlock\n// 简单的自旋锁实现\nlet lock = alloc(4);\nptr_write_i32(lock, 0);  // 0 = 未锁定，1 = 已锁定\n\nfn acquire() {\n    // 自旋直到成功将锁从 0 设置为 1\n    while (!atomic_cas_i32(lock, 0, 1)) {\n        // 忙等待\n    }\n}\n\nfn release() {\n    atomic_store_i32(lock, 0);\n}\n\n// 使用\nacquire();\n// ... 临界区 ...\nrelease();\n\nfree(lock);\n```\n\n### 模式：一次性初始化\n\n```hemlock\nlet initialized = alloc(4);\nptr_write_i32(initialized, 0);  // 0 = 未初始化，1 = 已初始化\n\nfn ensure_initialized() {\n    // 尝试成为初始化者\n    if (atomic_cas_i32(initialized, 0, 1)) {\n        // 我们赢得了竞争，执行初始化\n        do_expensive_init();\n    }\n    // 否则，已经初始化过了\n}\n```\n\n### 模式：原子标志\n\n```hemlock\nlet flag = alloc(4);\nptr_write_i32(flag, 0);\n\nfn set_flag() {\n    atomic_store_i32(flag, 1);\n}\n\nfn clear_flag() {\n    atomic_store_i32(flag, 0);\n}\n\nfn test_and_set(): bool {\n    // 如果标志已经设置则返回 true\n    return atomic_exchange_i32(flag, 1) == 1;\n}\n\nfn check_flag(): bool {\n    return atomic_load_i32(flag) == 1;\n}\n```\n\n### 模式：有界计数器\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\nlet max_value = 100;\n\nfn try_increment(): bool {\n    while (true) {\n        let current = atomic_load_i32(counter);\n        if (current >= max_value) {\n            return false;  // 已达最大值\n        }\n        if (atomic_cas_i32(counter, current, current + 1)) {\n            return true;  // 成功递增\n        }\n        // CAS 失败，另一个线程修改了值 - 重试\n    }\n}\n```\n\n---\n\n## 最佳实践\n\n### 1. 使用正确的对齐\n\n指针必须为数据类型正确对齐：\n- i32：4 字节对齐\n- i64：8 字节对齐\n\n来自 `alloc()` 的内存通常是正确对齐的。\n\n### 2. 优先使用更高级的抽象\n\n如果可能，使用通道进行任务间通信。原子操作是更底层的，需要仔细推理。\n\n```hemlock\n// 优先这样：\nlet ch = channel(10);\nspawn(fn() { ch.send(result); });\nlet value = ch.recv();\n\n// 而不是在适当时使用手动原子协调\n```\n\n### 3. 注意 ABA 问题\n\nCAS 可能遭受 ABA 问题：值从 A 变为 B 然后又变回 A。你的 CAS 成功了，但状态可能在中间已经改变。\n\n### 4. 在共享之前初始化\n\n始终在生成访问原子变量的任务之前初始化它们：\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);  // 在生成之前初始化\n\nlet task = spawn(worker, counter);\n```\n\n### 5. 在所有任务完成后释放\n\n不要在任务可能仍在访问原子内存时释放它：\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nlet t1 = spawn(worker, counter);\nlet t2 = spawn(worker, counter);\n\njoin(t1);\njoin(t2);\n\n// 现在可以安全释放\nfree(counter);\n```\n\n---\n\n## 限制\n\n### 当前限制\n\n1. **仅支持 i32 和 i64** - 其他类型没有原子操作\n2. **没有指针原子操作** - 无法原子地加载/存储指针\n3. **仅顺序一致性** - 没有较弱的内存排序可用\n4. **没有原子浮点数** - 如果需要请使用整数表示\n\n### 平台说明\n\n- 原子操作底层使用 C11 `<stdatomic.h>`\n- 在所有支持 POSIX 线程的平台上可用\n- 在现代 64 位系统上保证无锁\n\n---\n\n## 另请参阅\n\n- [异步/并发](#advanced-async-concurrency) - 任务生成和通道\n- [内存管理](#language-guide-memory) - 指针和缓冲区分配\n- [内存 API](#reference-memory-api) - 分配函数\n"}, "Advanced Topics -> Bundling Packaging": {"id": "advanced-bundling-packaging", "content": "# 打包与分发\n\nHemlock 提供内置工具，可将多文件项目打包成单个可分发文件并创建独立的可执行文件。\n\n## 概述\n\n| 命令 | 输出 | 用例 |\n|------|------|------|\n| `--bundle` | `.hmlc` 或 `.hmlb` | 分发字节码（需要 Hemlock 运行） |\n| `--package` | 可执行文件 | 独立二进制文件（无依赖） |\n| `--compile` | `.hmlc` | 编译单个文件（无导入解析） |\n\n## 打包\n\n打包器从入口点解析所有 `import` 语句，并将它们展平为单个文件。\n\n### 基本用法\n\n```bash\n# 将 app.hml 及其所有导入打包成 app.hmlc\nhemlock --bundle app.hml\n\n# 指定输出路径\nhemlock --bundle app.hml -o dist/app.hmlc\n\n# 创建压缩包（.hmlb）- 更小的文件大小\nhemlock --bundle app.hml --compress -o app.hmlb\n\n# 详细输出（显示解析的模块）\nhemlock --bundle app.hml --verbose\n```\n\n### 输出格式\n\n**`.hmlc`（未压缩）**\n- 序列化的 AST 格式\n- 加载和执行速度快\n- 默认输出格式\n\n**`.hmlb`（压缩）**\n- zlib 压缩的 `.hmlc`\n- 文件大小更小（通常减少 50-70%）\n- 由于解压缩，启动稍慢\n\n### 运行打包文件\n\n```bash\n# 运行未压缩包\nhemlock app.hmlc\n\n# 运行压缩包\nhemlock app.hmlb\n\n# 传递参数\nhemlock app.hmlc arg1 arg2\n```\n\n### 示例：多模块项目\n\n```\nmyapp/\n├── main.hml\n├── lib/\n│   ├── math.hml\n│   └── utils.hml\n└── config.hml\n```\n\n```hemlock\n// main.hml\nimport { add, multiply } from \"./lib/math.hml\";\nimport { log } from \"./lib/utils.hml\";\nimport { VERSION } from \"./config.hml\";\n\nlog(`App v${VERSION}`);\nprint(add(2, 3));\n```\n\n```bash\nhemlock --bundle myapp/main.hml -o myapp.hmlc\nhemlock myapp.hmlc  # 运行时所有依赖都已打包\n```\n\n### stdlib 导入\n\n打包器自动解析 `@stdlib/` 导入：\n\n```hemlock\nimport { HashMap } from \"@stdlib/collections\";\nimport { now } from \"@stdlib/time\";\n```\n\n打包时，stdlib 模块会包含在输出中。\n\n## 封装\n\n封装通过将打包的字节码嵌入 Hemlock 解释器副本来创建独立的可执行文件。\n\n### 基本用法\n\n```bash\n# 从 app.hml 创建可执行文件\nhemlock --package app.hml\n\n# 指定输出名称\nhemlock --package app.hml -o myapp\n\n# 跳过压缩（启动更快，文件更大）\nhemlock --package app.hml --no-compress\n\n# 详细输出\nhemlock --package app.hml --verbose\n```\n\n### 运行封装的可执行文件\n\n```bash\n# 封装的可执行文件直接运行\n./myapp\n\n# 参数传递给脚本\n./myapp arg1 arg2\n```\n\n### 封装格式\n\n封装的可执行文件使用 HMLP 格式：\n\n```\n[hemlock 二进制文件][HMLB/HMLC 载荷][payload_size:u64][HMLP 魔数:u32]\n```\n\n当封装的可执行文件运行时：\n1. 检查文件末尾是否有嵌入的载荷\n2. 如果找到，解压缩并执行载荷\n3. 如果未找到，作为普通 Hemlock 解释器运行\n\n### 压缩选项\n\n| 标志 | 格式 | 启动 | 大小 |\n|------|------|------|------|\n| （默认） | HMLB | 正常 | 较小 |\n| `--no-compress` | HMLC | 更快 | 较大 |\n\n对于启动时间重要的 CLI 工具，使用 `--no-compress`。\n\n## 检查包\n\n使用 `--info` 检查打包或编译的文件：\n\n```bash\nhemlock --info app.hmlc\n```\n\n输出：\n```\n=== File Info: app.hmlc ===\nSize: 12847 bytes\nFormat: HMLC (compiled AST)\nVersion: 1\nFlags: 0x0001 [DEBUG]\nStrings: 42\nStatements: 156\n```\n\n```bash\nhemlock --info app.hmlb\n```\n\n输出：\n```\n=== File Info: app.hmlb ===\nSize: 5234 bytes\nFormat: HMLB (compressed bundle)\nVersion: 1\nUncompressed: 12847 bytes\nCompressed: 5224 bytes\nRatio: 59.3% reduction\n```\n\n## 原生编译\n\n要获得真正的原生可执行文件（无解释器），使用 Hemlock 编译器：\n\n```bash\n# 通过 C 编译为原生可执行文件\nhemlockc app.hml -o app\n\n# 保留生成的 C 代码\nhemlockc app.hml -o app --keep-c\n\n# 仅生成 C（不编译）\nhemlockc app.hml -c -o app.c\n\n# 优化级别\nhemlockc app.hml -o app -O2\n```\n\n编译器生成 C 代码并调用 GCC 产生原生二进制文件。这需要：\n- Hemlock 运行时库（`libhemlock_runtime`）\n- C 编译器（默认 GCC）\n\n### 编译器选项\n\n| 选项 | 描述 |\n|------|------|\n| `-o <file>` | 输出可执行文件名 |\n| `-c` | 仅生成 C 代码 |\n| `--emit-c <file>` | 将 C 写入指定文件 |\n| `-k, --keep-c` | 编译后保留生成的 C |\n| `-O<level>` | 优化级别（0-3） |\n| `--cc <path>` | 使用的 C 编译器 |\n| `--runtime <path>` | 运行时库路径 |\n| `-v, --verbose` | 详细输出 |\n\n## 比较\n\n| 方法 | 可移植性 | 启动 | 大小 | 依赖 |\n|------|----------|------|------|------|\n| `.hml` | 仅源码 | 解析时间 | 最小 | Hemlock |\n| `.hmlc` | 仅 Hemlock | 快 | 小 | Hemlock |\n| `.hmlb` | 仅 Hemlock | 快 | 更小 | Hemlock |\n| `--package` | 独立 | 快 | 较大 | 无 |\n| `hemlockc` | 原生 | 最快 | 不定 | 运行时库 |\n\n## 最佳实践\n\n1. **开发**：直接运行 `.hml` 文件以快速迭代\n2. **分发（有 Hemlock）**：使用 `--compress` 打包以获得更小的文件\n3. **分发（独立）**：封装以实现零依赖部署\n4. **性能关键**：使用 `hemlockc` 进行原生编译\n\n## 故障排除\n\n### \"Cannot find stdlib\"\n\n打包器在以下位置查找 stdlib：\n1. `./stdlib`（相对于可执行文件）\n2. `../stdlib`（相对于可执行文件）\n3. `/usr/local/lib/hemlock/stdlib`\n\n确保 Hemlock 已正确安装或从源目录运行。\n\n### 循环依赖\n\n```\nError: Circular dependency detected when loading 'path/to/module.hml'\n```\n\n重构你的导入以打破循环。考虑使用共享模块存放公共类型。\n\n### 封装大小过大\n\n- 使用默认压缩（不要使用 `--no-compress`）\n- 封装大小包含完整解释器（基础约 500KB-1MB）\n- 要获得最小大小，使用 `hemlockc` 进行原生编译\n"}, "Advanced Topics -> Command Execution": {"id": "advanced-command-execution", "content": "# Hemlock 命令执行\n\nHemlock 提供 **`exec()` 内置函数**来执行 shell 命令并捕获输出。\n\n## 目录\n\n- [概述](#概述)\n- [exec() 函数](#exec-函数)\n- [结果对象](#结果对象)\n- [基本用法](#基本用法)\n- [高级示例](#高级示例)\n- [错误处理](#错误处理)\n- [实现细节](#实现细节)\n- [安全考虑](#安全考虑)\n- [限制](#限制)\n- [用例](#用例)\n- [最佳实践](#最佳实践)\n- [完整示例](#完整示例)\n\n## 概述\n\n`exec()` 函数允许 Hemlock 程序：\n- 执行 shell 命令\n- 捕获标准输出（stdout）\n- 检查退出状态码\n- 使用 shell 特性（管道、重定向等）\n- 与系统工具集成\n\n**重要：** 命令通过 `/bin/sh` 执行，提供完整的 shell 功能，但也引入了安全考虑。\n\n## exec() 函数\n\n### 签名\n\n```hemlock\nexec(command: string): object\n```\n\n**参数：**\n- `command` (string) - 要执行的 shell 命令\n\n**返回：** 包含两个字段的对象：\n- `output` (string) - 命令的 stdout 输出\n- `exit_code` (i32) - 命令的退出状态码\n\n### 基本示例\n\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n```\n\n## 结果对象\n\n`exec()` 返回的对象具有以下结构：\n\n```hemlock\n{\n    output: string,      // 命令 stdout（捕获的输出）\n    exit_code: i32       // 进程退出状态（0 = 成功）\n}\n```\n\n### output 字段\n\n包含命令写入 stdout 的所有文本。\n\n**属性：**\n- 如果命令没有输出则为空字符串\n- 原样包含换行符和空白\n- 多行输出保留\n- 大小无限制（动态分配）\n\n**示例：**\n```hemlock\nlet r1 = exec(\"echo test\");\nprint(r1.output);  // \"test\\n\"\n\nlet r2 = exec(\"ls\");\nprint(r2.output);  // 带换行符的目录列表\n\nlet r3 = exec(\"true\");\nprint(r3.output);  // \"\"（空字符串）\n```\n\n### exit_code 字段\n\n命令的退出状态码。\n\n**值：**\n- `0` 通常表示成功\n- `1-255` 表示错误（约定因命令而异）\n- `-1` 如果命令无法执行或异常终止\n\n**示例：**\n```hemlock\nlet r1 = exec(\"true\");\nprint(r1.exit_code);  // 0（成功）\n\nlet r2 = exec(\"false\");\nprint(r2.exit_code);  // 1（失败）\n\nlet r3 = exec(\"ls /nonexistent\");\nprint(r3.exit_code);  // 2（文件未找到，因命令而异）\n```\n\n## 基本用法\n\n### 简单命令\n\n```hemlock\nlet r = exec(\"ls -la\");\nprint(r.output);\nprint(\"Exit code: \" + typeof(r.exit_code));\n```\n\n### 检查退出状态\n\n```hemlock\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Found: \" + r.output);\n} else {\n    print(\"Pattern not found\");\n}\n```\n\n### 带管道的命令\n\n```hemlock\nlet r = exec(\"ps aux | grep hemlock\");\nprint(r.output);\n```\n\n### 多条命令\n\n```hemlock\nlet r = exec(\"cd /tmp && ls -la\");\nprint(r.output);\n```\n\n### 命令替换\n\n```hemlock\nlet r = exec(\"echo $(date)\");\nprint(r.output);  // 当前日期\n```\n\n## 高级示例\n\n### 处理失败\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\nif (r.exit_code != 0) {\n    print(\"Command failed with code: \" + typeof(r.exit_code));\n    print(\"Error output: \" + r.output);  // 注意：stderr 未捕获\n}\n```\n\n### 处理多行输出\n\n```hemlock\nlet r = exec(\"cat file.txt\");\nlet lines = r.output.split(\"\\n\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### 命令链\n\n**使用 &&（与）：**\n```hemlock\nlet r1 = exec(\"mkdir -p /tmp/test && touch /tmp/test/file.txt\");\nif (r1.exit_code == 0) {\n    print(\"Setup complete\");\n}\n```\n\n**使用 ||（或）：**\n```hemlock\nlet r = exec(\"command1 || command2\");\n// 仅当 command1 失败时运行 command2\n```\n\n**使用 ;（顺序）：**\n```hemlock\nlet r = exec(\"command1; command2\");\n// 无论成功/失败都运行两者\n```\n\n### 使用管道\n\n```hemlock\nlet r = exec(\"echo 'data' | base64\");\nprint(\"Base64: \" + r.output);\n```\n\n**复杂管道：**\n```hemlock\nlet r = exec(\"cat /etc/passwd | grep root | cut -d: -f1\");\nprint(r.output);\n```\n\n### 退出码模式\n\n不同的退出码表示不同的条件：\n\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n} else if (r.exit_code == 1) {\n    print(\"File does not exist\");\n} else {\n    print(\"Test command failed: \" + typeof(r.exit_code));\n}\n```\n\n### 输出重定向\n\n```hemlock\n// 将 stdout 重定向到文件（在 shell 内）\nlet r1 = exec(\"echo 'test' > /tmp/output.txt\");\n\n// 将 stderr 重定向到 stdout（注意：Hemlock 仍未捕获 stderr）\nlet r2 = exec(\"command 2>&1\");\n```\n\n### 环境变量\n\n```hemlock\nlet r = exec(\"export VAR=value && echo $VAR\");\nprint(r.output);  // \"value\\n\"\n```\n\n### 工作目录更改\n\n```hemlock\nlet r = exec(\"cd /tmp && pwd\");\nprint(r.output);  // \"/tmp\\n\"\n```\n\n## 错误处理\n\n### exec() 何时抛出异常\n\n如果命令无法执行，`exec()` 函数会抛出异常：\n\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command_xyz\");\n} catch (e) {\n    print(\"Failed to execute: \" + e);\n}\n```\n\n**抛出异常的情况：**\n- `popen()` 失败（如无法创建管道）\n- 系统资源限制超出\n- 内存分配失败\n\n### exec() 何时不抛出异常\n\n```hemlock\n// 命令运行但返回非零退出码\nlet r1 = exec(\"false\");\nprint(r1.exit_code);  // 1（不是异常）\n\n// 命令没有输出\nlet r2 = exec(\"true\");\nprint(r2.output);  // \"\"（不是异常）\n\n// shell 找不到命令\nlet r3 = exec(\"nonexistent_cmd\");\nprint(r3.exit_code);  // 127（不是异常）\n```\n\n### 安全执行模式\n\n```hemlock\nfn safe_exec(command: string) {\n    try {\n        let r = exec(command);\n        if (r.exit_code != 0) {\n            print(\"Warning: Command failed with code \" + typeof(r.exit_code));\n            return \"\";\n        }\n        return r.output;\n    } catch (e) {\n        print(\"Error executing command: \" + e);\n        return \"\";\n    }\n}\n\nlet output = safe_exec(\"ls -la\");\n```\n\n## 实现细节\n\n### 工作原理\n\n**底层实现：**\n- 使用 `popen()` 通过 `/bin/sh` 执行命令\n- 仅捕获 stdout（stderr 未捕获）\n- 输出动态缓冲（从 4KB 开始，按需增长）\n- 使用 `WIFEXITED()` 和 `WEXITSTATUS()` 宏提取退出状态\n- 输出字符串正确以 null 结尾\n\n**进程流程：**\n1. `popen(command, \"r\")` 创建管道并 fork 进程\n2. 子进程执行 `/bin/sh -c \"command\"`\n3. 父进程通过管道将 stdout 读入增长的缓冲区\n4. `pclose()` 等待子进程并返回退出状态\n5. 提取退出状态并存储在结果对象中\n\n### 性能考虑\n\n**开销：**\n- 每次调用创建新的 shell 进程（约 1-5ms 开销）\n- 输出完全存储在内存中（非流式）\n- 不支持流式传输（等待命令完成）\n- 适用于输出大小合理的命令\n\n**优化：**\n- 缓冲区从 4KB 开始，满时翻倍（高效内存使用）\n- 单一读取循环最小化系统调用\n- 无额外字符串复制\n\n**何时使用：**\n- 短时运行的命令（< 1 秒）\n- 中等输出大小（< 10MB）\n- 具有合理间隔的批量操作\n\n**何时不使用：**\n- 长时运行的守护进程或服务\n- 产生 GB 级输出的命令\n- 实时流数据处理\n- 高频执行（> 100 次/秒）\n\n## 安全考虑\n\n### Shell 注入风险\n\n**关键：** 命令由 shell（`/bin/sh`）执行，这意味着 **shell 注入是可能的**。\n\n**易受攻击的代码：**\n```hemlock\n// 危险 - 不要这样做\nlet filename = args[1];  // 用户输入\nlet r = exec(\"cat \" + filename);  // Shell 注入！\n```\n\n**攻击：**\n```bash\n./hemlock script.hml \"; rm -rf /; echo pwned\"\n# 执行: cat ; rm -rf /; echo pwned\n```\n\n### 安全实践\n\n**1. 永远不要使用未经净化的用户输入：**\n```hemlock\n// 不好\nlet user_input = args[1];\nlet r = exec(\"process \" + user_input);  // 危险\n\n// 好 - 先验证\nfn is_safe_filename(name: string): bool {\n    // 只允许字母数字、破折号、下划线、点\n    let i = 0;\n    while (i < name.length) {\n        let c = name[i];\n        if (!(c >= 'a' && c <= 'z') &&\n            !(c >= 'A' && c <= 'Z') &&\n            !(c >= '0' && c <= '9') &&\n            c != '-' && c != '_' && c != '.') {\n            return false;\n        }\n        i = i + 1;\n    }\n    return true;\n}\n\nlet filename = args[1];\nif (is_safe_filename(filename)) {\n    let r = exec(\"cat \" + filename);\n} else {\n    print(\"Invalid filename\");\n}\n```\n\n**2. 使用白名单，而不是黑名单：**\n```hemlock\n// 好 - 严格的白名单\nlet allowed_commands = [\"status\", \"start\", \"stop\", \"restart\"];\nlet cmd = args[1];\n\nlet found = false;\nfor (let allowed in allowed_commands) {\n    if (cmd == allowed) {\n        found = true;\n        break;\n    }\n}\n\nif (found) {\n    exec(\"service myapp \" + cmd);\n} else {\n    print(\"Invalid command\");\n}\n```\n\n**3. 转义特殊字符：**\n```hemlock\nfn shell_escape(s: string): string {\n    // 简单转义 - 用单引号包裹并转义单引号\n    let escaped = s.replace_all(\"'\", \"'\\\\''\");\n    return \"'\" + escaped + \"'\";\n}\n\nlet user_file = args[1];\nlet safe = shell_escape(user_file);\nlet r = exec(\"cat \" + safe);\n```\n\n**4. 避免对文件操作使用 exec()：**\n```hemlock\n// 不好 - 使用 exec 进行文件操作\nlet r = exec(\"cat file.txt\");\n\n// 好 - 使用 Hemlock 的文件 API\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### 权限考虑\n\n命令以与 Hemlock 进程相同的权限运行：\n\n```hemlock\n// 如果 Hemlock 以 root 运行，exec() 命令也以 root 运行！\nlet r = exec(\"rm -rf /important\");  // 如果以 root 运行则危险\n```\n\n**最佳实践：** 以所需的最小权限运行 Hemlock。\n\n## 限制\n\n### 1. 无 stderr 捕获\n\n只捕获 stdout，stderr 输出到终端：\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\n// r.output 为空\n// 错误消息出现在终端上，未捕获\n```\n\n**变通方法 - 将 stderr 重定向到 stdout：**\n```hemlock\nlet r = exec(\"ls /nonexistent 2>&1\");\n// 现在错误消息在 r.output 中\n```\n\n### 2. 无流式传输\n\n必须等待命令完成：\n\n```hemlock\nlet r = exec(\"long_running_command\");\n// 阻塞直到命令完成\n// 无法增量处理输出\n```\n\n### 3. 无超时\n\n命令可以无限期运行：\n\n```hemlock\nlet r = exec(\"sleep 1000\");\n// 阻塞 1000 秒\n// 无法超时或取消\n```\n\n**变通方法 - 使用 timeout 命令：**\n```hemlock\nlet r = exec(\"timeout 5 long_command\");\n// 5 秒后超时\n```\n\n### 4. 无信号处理\n\n无法向运行中的命令发送信号：\n\n```hemlock\nlet r = exec(\"long_command\");\n// 无法向命令发送 SIGINT、SIGTERM 等\n```\n\n### 5. 无进程控制\n\n启动后无法与命令交互：\n\n```hemlock\nlet r = exec(\"interactive_program\");\n// 无法向程序发送输入\n// 无法控制执行\n```\n\n## 用例\n\n### 适合的用例\n\n**1. 运行系统工具：**\n```hemlock\nlet r = exec(\"ls -la\");\nlet r = exec(\"grep pattern file.txt\");\nlet r = exec(\"find /path -name '*.txt'\");\n```\n\n**2. 使用 Unix 工具快速处理数据：**\n```hemlock\nlet r = exec(\"cat data.txt | sort | uniq | wc -l\");\nprint(\"Unique lines: \" + r.output);\n```\n\n**3. 检查系统状态：**\n```hemlock\nlet r = exec(\"df -h\");\nprint(\"Disk usage:\\n\" + r.output);\n```\n\n**4. 文件存在性检查：**\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n}\n```\n\n**5. 生成报告：**\n```hemlock\nlet r = exec(\"ps aux | grep myapp | wc -l\");\nlet count = r.output.trim();\nprint(\"Running instances: \" + count);\n```\n\n**6. 自动化脚本：**\n```hemlock\nexec(\"git add .\");\nexec(\"git commit -m 'Auto commit'\");\nlet r = exec(\"git push\");\nif (r.exit_code != 0) {\n    print(\"Push failed\");\n}\n```\n\n### 不推荐的用例\n\n**1. 长时运行的服务：**\n```hemlock\n// 不好\nlet r = exec(\"nginx\");  // 永远阻塞\n```\n\n**2. 交互式命令：**\n```hemlock\n// 不好 - 无法提供输入\nlet r = exec(\"ssh user@host\");\n```\n\n**3. 产生巨大输出的命令：**\n```hemlock\n// 不好 - 将整个输出加载到内存\nlet r = exec(\"cat 10GB_file.log\");\n```\n\n**4. 实时流式传输：**\n```hemlock\n// 不好 - 无法增量处理输出\nlet r = exec(\"tail -f /var/log/app.log\");\n```\n\n**5. 关键任务错误处理：**\n```hemlock\n// 不好 - stderr 未捕获\nlet r = exec(\"critical_operation\");\n// 无法看到详细错误消息\n```\n\n## 最佳实践\n\n### 1. 始终检查退出码\n\n```hemlock\nlet r = exec(\"important_command\");\nif (r.exit_code != 0) {\n    print(\"Command failed!\");\n    // 处理错误\n}\n```\n\n### 2. 需要时修剪输出\n\n```hemlock\nlet r = exec(\"echo test\");\nlet clean = r.output.trim();  // 移除尾随换行符\nprint(clean);  // \"test\"（无换行符）\n```\n\n### 3. 执行前验证\n\n```hemlock\nfn is_valid_command(cmd: string): bool {\n    // 验证命令是否安全\n    return true;  // 你的验证逻辑\n}\n\nif (is_valid_command(user_cmd)) {\n    exec(user_cmd);\n}\n```\n\n### 4. 对关键操作使用 try/catch\n\n```hemlock\ntry {\n    let r = exec(\"critical_command\");\n    if (r.exit_code != 0) {\n        throw \"Command failed\";\n    }\n} catch (e) {\n    print(\"Error: \" + e);\n    // 清理或恢复\n}\n```\n\n### 5. 优先使用 Hemlock API 而不是 exec()\n\n```hemlock\n// 不好 - 使用 exec 进行文件操作\nlet r = exec(\"cat file.txt\");\n\n// 好 - 使用 Hemlock 的文件 API\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### 6. 需要时捕获 stderr\n\n```hemlock\n// 将 stderr 重定向到 stdout\nlet r = exec(\"command 2>&1\");\n// 现在 r.output 同时包含 stdout 和 stderr\n```\n\n### 7. 明智使用 Shell 特性\n\n```hemlock\n// 使用管道提高效率\nlet r = exec(\"cat large.txt | grep pattern | head -n 10\");\n\n// 使用命令替换\nlet r = exec(\"echo Current user: $(whoami)\");\n\n// 使用条件执行\nlet r = exec(\"test -f file.txt && cat file.txt\");\n```\n\n## 完整示例\n\n### 示例 1：系统信息收集器\n\n```hemlock\nfn get_system_info() {\n    print(\"=== System Information ===\");\n\n    // 主机名\n    let r1 = exec(\"hostname\");\n    print(\"Hostname: \" + r1.output.trim());\n\n    // 运行时间\n    let r2 = exec(\"uptime\");\n    print(\"Uptime: \" + r2.output.trim());\n\n    // 磁盘使用\n    let r3 = exec(\"df -h /\");\n    print(\"\\nDisk Usage:\");\n    print(r3.output);\n\n    // 内存使用\n    let r4 = exec(\"free -h\");\n    print(\"Memory Usage:\");\n    print(r4.output);\n}\n\nget_system_info();\n```\n\n### 示例 2：日志分析器\n\n```hemlock\nfn analyze_log(logfile: string) {\n    print(\"Analyzing log: \" + logfile);\n\n    // 统计总行数\n    let r1 = exec(\"wc -l \" + logfile);\n    print(\"Total lines: \" + r1.output.trim());\n\n    // 统计错误数\n    let r2 = exec(\"grep -c ERROR \" + logfile + \" 2>/dev/null\");\n    let errors = r2.output.trim();\n    if (r2.exit_code == 0) {\n        print(\"Errors: \" + errors);\n    } else {\n        print(\"Errors: 0\");\n    }\n\n    // 统计警告数\n    let r3 = exec(\"grep -c WARN \" + logfile + \" 2>/dev/null\");\n    let warnings = r3.output.trim();\n    if (r3.exit_code == 0) {\n        print(\"Warnings: \" + warnings);\n    } else {\n        print(\"Warnings: 0\");\n    }\n\n    // 最近的错误\n    print(\"\\nRecent errors:\");\n    let r4 = exec(\"grep ERROR \" + logfile + \" | tail -n 5\");\n    print(r4.output);\n}\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <logfile>\");\n} else {\n    analyze_log(args[1]);\n}\n```\n\n### 示例 3：Git 助手\n\n```hemlock\nfn git_status() {\n    let r = exec(\"git status --short\");\n    if (r.exit_code != 0) {\n        print(\"Error: Not a git repository\");\n        return;\n    }\n\n    if (r.output == \"\") {\n        print(\"Working directory clean\");\n    } else {\n        print(\"Changes:\");\n        print(r.output);\n    }\n}\n\nfn git_quick_commit(message: string) {\n    print(\"Adding all changes...\");\n    let r1 = exec(\"git add -A\");\n    if (r1.exit_code != 0) {\n        print(\"Error adding files\");\n        return;\n    }\n\n    print(\"Committing...\");\n    let safe_msg = message.replace_all(\"'\", \"'\\\\''\");\n    let r2 = exec(\"git commit -m '\" + safe_msg + \"'\");\n    if (r2.exit_code != 0) {\n        print(\"Error committing\");\n        return;\n    }\n\n    print(\"Committed successfully\");\n    print(r2.output);\n}\n\n// 用法\ngit_status();\nif (args.length > 1) {\n    git_quick_commit(args[1]);\n}\n```\n\n### 示例 4：备份脚本\n\n```hemlock\nfn backup_directory(source: string, dest: string) {\n    print(\"Backing up \" + source + \" to \" + dest);\n\n    // 创建备份目录\n    let r1 = exec(\"mkdir -p \" + dest);\n    if (r1.exit_code != 0) {\n        print(\"Error creating backup directory\");\n        return false;\n    }\n\n    // 创建带时间戳的压缩包\n    let r2 = exec(\"date +%Y%m%d_%H%M%S\");\n    let timestamp = r2.output.trim();\n    let backup_file = dest + \"/backup_\" + timestamp + \".tar.gz\";\n\n    print(\"Creating archive: \" + backup_file);\n    let r3 = exec(\"tar -czf \" + backup_file + \" \" + source + \" 2>&1\");\n    if (r3.exit_code != 0) {\n        print(\"Error creating backup:\");\n        print(r3.output);\n        return false;\n    }\n\n    print(\"Backup completed successfully\");\n\n    // 显示备份大小\n    let r4 = exec(\"du -h \" + backup_file);\n    print(\"Backup size: \" + r4.output.trim());\n\n    return true;\n}\n\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <source> <destination>\");\n} else {\n    backup_directory(args[1], args[2]);\n}\n```\n\n## 总结\n\nHemlock 的 `exec()` 函数提供：\n\n- 简单的 shell 命令执行\n- 输出捕获（stdout）\n- 退出码检查\n- 完整的 shell 特性访问（管道、重定向等）\n- 与系统工具的集成\n\n请记住：\n- 始终检查退出码\n- 注意安全隐患（shell 注入）\n- 在命令中使用前验证用户输入\n- 可用时优先使用 Hemlock API 而不是 exec()\n- stderr 未捕获（使用 `2>&1` 重定向）\n- 命令阻塞直到完成\n- 用于短时运行的工具，不是长时运行的服务\n\n**安全检查清单：**\n- 永远不要使用未经净化的用户输入\n- 验证所有输入\n- 对命令使用白名单\n- 必要时转义特殊字符\n- 以最小权限运行\n- 优先使用 Hemlock API 而不是 shell 命令\n"}, "Advanced Topics -> Command Line Args": {"id": "advanced-command-line-args", "content": "# Hemlock 命令行参数\n\nHemlock 程序可以通过内置的 **`args` 数组**访问命令行参数，该数组在程序启动时自动填充。\n\n## 目录\n\n- [概述](#概述)\n- [args 数组](#args-数组)\n- [属性](#属性)\n- [迭代模式](#迭代模式)\n- [常见用例](#常见用例)\n- [参数解析模式](#参数解析模式)\n- [最佳实践](#最佳实践)\n- [完整示例](#完整示例)\n\n## 概述\n\n`args` 数组提供对传递给 Hemlock 程序的命令行参数的访问：\n\n- **始终可用** - 所有 Hemlock 程序中的内置全局变量\n- **包含脚本名称** - `args[0]` 始终包含脚本路径/名称\n- **字符串数组** - 所有参数都是字符串\n- **从零开始索引** - 标准数组索引（0、1、2、...）\n\n## args 数组\n\n### 基本结构\n\n```hemlock\n// args[0] 始终是脚本文件名\n// args[1] 到 args[n-1] 是实际参数\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // 参数总数（包括脚本名称）\n```\n\n### 使用示例\n\n**命令：**\n```bash\n./hemlock script.hml hello world \"test 123\"\n```\n\n**在 script.hml 中：**\n```hemlock\nprint(\"Script name: \" + args[0]);     // \"script.hml\"\nprint(\"Total args: \" + typeof(args.length));  // \"4\"\nprint(\"First arg: \" + args[1]);       // \"hello\"\nprint(\"Second arg: \" + args[2]);      // \"world\"\nprint(\"Third arg: \" + args[3]);       // \"test 123\"\n```\n\n### 索引参考\n\n| 索引 | 包含 | 示例值 |\n|-------|----------|---------------|\n| `args[0]` | 脚本路径/名称 | `\"script.hml\"` 或 `\"./script.hml\"` |\n| `args[1]` | 第一个参数 | `\"hello\"` |\n| `args[2]` | 第二个参数 | `\"world\"` |\n| `args[3]` | 第三个参数 | `\"test 123\"` |\n| ... | ... | ... |\n| `args[n-1]` | 最后一个参数 | （不定） |\n\n## 属性\n\n### 始终存在\n\n`args` 是**所有** Hemlock 程序中可用的全局数组：\n\n```hemlock\n// 无需声明或导入\nprint(args.length);  // 立即可用\n```\n\n### 包含脚本名称\n\n`args[0]` 始终包含脚本路径/名称：\n\n```hemlock\nprint(\"Running: \" + args[0]);\n```\n\n**args[0] 的可能值：**\n- `\"script.hml\"` - 仅文件名\n- `\"./script.hml\"` - 相对路径\n- `\"/home/user/script.hml\"` - 绝对路径\n- 取决于脚本的调用方式\n\n### 类型：字符串数组\n\n所有参数都存储为字符串：\n\n```hemlock\n// 参数: ./hemlock script.hml 42 3.14 true\n\nprint(args[1]);  // \"42\"（字符串，不是数字）\nprint(args[2]);  // \"3.14\"（字符串，不是数字）\nprint(args[3]);  // \"true\"（字符串，不是布尔值）\n\n// 根据需要转换：\nlet num = 42;  // 如需要可手动解析\n```\n\n### 最小长度\n\n始终至少为 1（脚本名称）：\n\n```hemlock\nprint(args.length);  // 最小值: 1\n```\n\n**即使没有参数：**\n```bash\n./hemlock script.hml\n```\n\n```hemlock\n// 在 script.hml 中：\nprint(args.length);  // 1（仅脚本名称）\n```\n\n### REPL 行为\n\n在 REPL 中，`args.length` 为 0（空数组）：\n\n```hemlock\n# REPL 会话\n> print(args.length);\n0\n```\n\n## 迭代模式\n\n### 基本迭代\n\n跳过 `args[0]`（脚本名称）并处理实际参数：\n\n```hemlock\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument \" + typeof(i) + \": \" + args[i]);\n    i = i + 1;\n}\n```\n\n**对于 `./hemlock script.hml foo bar baz` 的输出：**\n```\nArgument 1: foo\nArgument 2: bar\nArgument 3: baz\n```\n\n### For-In 迭代（包括脚本名称）\n\n```hemlock\nfor (let arg in args) {\n    print(arg);\n}\n```\n\n**输出：**\n```\nscript.hml\nfoo\nbar\nbaz\n```\n\n### 检查参数数量\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <argument>\");\n    // 退出或返回\n} else {\n    let arg = args[1];\n    // 处理 arg\n}\n```\n\n### 处理除脚本名称外的所有参数\n\n```hemlock\nlet actual_args = args.slice(1, args.length);\n\nfor (let arg in actual_args) {\n    print(\"Processing: \" + arg);\n}\n```\n\n## 常见用例\n\n### 1. 简单参数处理\n\n检查必需参数：\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    print(\"Processing file: \" + filename);\n    // ... 处理文件\n}\n```\n\n**用法：**\n```bash\n./hemlock script.hml data.txt\n# 输出: Processing file: data.txt\n```\n\n### 2. 多个参数\n\n```hemlock\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <input> <output>\");\n} else {\n    let input_file = args[1];\n    let output_file = args[2];\n\n    print(\"Input: \" + input_file);\n    print(\"Output: \" + output_file);\n\n    // 处理文件...\n}\n```\n\n**用法：**\n```bash\n./hemlock convert.hml input.txt output.txt\n```\n\n### 3. 可变数量的参数\n\n处理所有提供的参数：\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        print(\"  \" + args[i]);\n        process_file(args[i]);\n        i = i + 1;\n    }\n}\n```\n\n**用法：**\n```bash\n./hemlock batch.hml file1.txt file2.txt file3.txt\n```\n\n### 4. 帮助信息\n\n```hemlock\nif (args.length < 2 || args[1] == \"--help\" || args[1] == \"-h\") {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show this help message\");\n    print(\"  -v, --verbose  Enable verbose output\");\n} else {\n    // 正常处理\n}\n```\n\n### 5. 参数验证\n\n```hemlock\nfn validate_file(filename: string): bool {\n    // 检查文件是否存在（示例）\n    return filename != \"\";\n}\n\nif (args.length < 2) {\n    print(\"Error: No filename provided\");\n} else if (!validate_file(args[1])) {\n    print(\"Error: Invalid file: \" + args[1]);\n} else {\n    print(\"Processing: \" + args[1]);\n}\n```\n\n## 参数解析模式\n\n### 命名参数（标志）\n\n命名参数的简单模式：\n\n```hemlock\nlet verbose = false;\nlet output_file = \"\";\nlet input_file = \"\";\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\" || args[i] == \"-v\") {\n        verbose = true;\n    } else if (args[i] == \"--output\" || args[i] == \"-o\") {\n        i = i + 1;\n        if (i < args.length) {\n            output_file = args[i];\n        }\n    } else {\n        input_file = args[i];\n    }\n    i = i + 1;\n}\n\nif (verbose) {\n    print(\"Verbose mode enabled\");\n}\nprint(\"Input: \" + input_file);\nprint(\"Output: \" + output_file);\n```\n\n**用法：**\n```bash\n./hemlock script.hml --verbose --output out.txt input.txt\n./hemlock script.hml -v -o out.txt input.txt\n```\n\n### 布尔标志\n\n```hemlock\nlet debug = false;\nlet verbose = false;\nlet force = false;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--debug\") {\n        debug = true;\n    } else if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else if (args[i] == \"--force\") {\n        force = true;\n    }\n    i = i + 1;\n}\n```\n\n### 值参数\n\n```hemlock\nlet config_file = \"default.conf\";\nlet port = 8080;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--config\") {\n        i = i + 1;\n        if (i < args.length) {\n            config_file = args[i];\n        }\n    } else if (args[i] == \"--port\") {\n        i = i + 1;\n        if (i < args.length) {\n            port = 8080;  // 需要将字符串解析为整数\n        }\n    }\n    i = i + 1;\n}\n```\n\n### 混合位置参数和命名参数\n\n```hemlock\nlet input_file = \"\";\nlet output_file = \"\";\nlet verbose = false;\n\nlet i = 1;\nlet positional = [];\n\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else {\n        // 作为位置参数处理\n        positional.push(args[i]);\n    }\n    i = i + 1;\n}\n\n// 分配位置参数\nif (positional.length > 0) {\n    input_file = positional[0];\n}\nif (positional.length > 1) {\n    output_file = positional[1];\n}\n```\n\n### 参数解析器辅助函数\n\n```hemlock\nfn parse_args() {\n    let options = {\n        verbose: false,\n        output: \"\",\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            options.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                options.output = args[i];\n            }\n        } else {\n            // 位置参数\n            options.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return options;\n}\n\nlet opts = parse_args();\nprint(\"Verbose: \" + typeof(opts.verbose));\nprint(\"Output: \" + opts.output);\nprint(\"Files: \" + typeof(opts.files.length));\n```\n\n## 最佳实践\n\n### 1. 始终检查参数数量\n\n```hemlock\n// 好的做法\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file>\");\n} else {\n    process_file(args[1]);\n}\n\n// 不好的做法 - 如果没有参数可能会崩溃\nprocess_file(args[1]);  // 如果 args.length == 1 会出错\n```\n\n### 2. 提供用法信息\n\n```hemlock\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show help\");\n    print(\"  -v, --verbose  Verbose output\");\n}\n\nif (args.length < 2) {\n    show_usage();\n}\n```\n\n### 3. 验证参数\n\n```hemlock\nfn validate_args() {\n    if (args.length < 2) {\n        print(\"Error: Missing required argument\");\n        return false;\n    }\n\n    if (args[1] == \"\") {\n        print(\"Error: Empty argument\");\n        return false;\n    }\n\n    return true;\n}\n\nif (!validate_args()) {\n    // 退出或显示用法\n}\n```\n\n### 4. 使用描述性变量名\n\n```hemlock\n// 好的做法\nlet input_filename = args[1];\nlet output_filename = args[2];\nlet max_iterations = args[3];\n\n// 不好的做法\nlet a = args[1];\nlet b = args[2];\nlet c = args[3];\n```\n\n### 5. 处理带空格的引号参数\n\nShell 会自动处理：\n\n```bash\n./hemlock script.hml \"file with spaces.txt\"\n```\n\n```hemlock\nprint(args[1]);  // \"file with spaces.txt\"\n```\n\n### 6. 创建参数对象\n\n```hemlock\nfn get_args() {\n    return {\n        script: args[0],\n        input: args[1],\n        output: args[2]\n    };\n}\n\nlet arguments = get_args();\nprint(\"Input: \" + arguments.input);\n```\n\n## 完整示例\n\n### 示例 1：文件处理器\n\n```hemlock\n// 用法: ./hemlock process.hml <input> <output>\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <input_file> <output_file>\");\n}\n\nif (args.length < 3) {\n    show_usage();\n} else {\n    let input = args[1];\n    let output = args[2];\n\n    print(\"Processing \" + input + \" -> \" + output);\n\n    // 处理文件\n    let f_in = open(input, \"r\");\n    let f_out = open(output, \"w\");\n\n    try {\n        let content = f_in.read();\n        let processed = content.to_upper();  // 示例处理\n        f_out.write(processed);\n\n        print(\"Done!\");\n    } finally {\n        f_in.close();\n        f_out.close();\n    }\n}\n```\n\n### 示例 2：批量文件处理器\n\n```hemlock\n// 用法: ./hemlock batch.hml <file1> <file2> <file3> ...\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        let filename = args[i];\n        print(\"  Processing: \" + filename);\n\n        try {\n            let f = open(filename, \"r\");\n            let content = f.read();\n            f.close();\n\n            // 处理内容...\n            print(\"    \" + typeof(content.length) + \" bytes\");\n        } catch (e) {\n            print(\"    Error: \" + e);\n        }\n\n        i = i + 1;\n    }\n\n    print(\"Done!\");\n}\n```\n\n### 示例 3：高级参数解析器\n\n```hemlock\n// 用法: ./hemlock app.hml [OPTIONS] <files...>\n// 选项:\n//   --verbose, -v     启用详细输出\n//   --output, -o FILE 设置输出文件\n//   --help, -h        显示帮助\n\nfn parse_arguments() {\n    let config = {\n        verbose: false,\n        output: \"output.txt\",\n        help: false,\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            config.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                config.output = args[i];\n            } else {\n                print(\"Error: --output requires a value\");\n            }\n        } else if (arg == \"--help\" || arg == \"-h\") {\n            config.help = true;\n        } else if (arg.starts_with(\"--\")) {\n            print(\"Error: Unknown option: \" + arg);\n        } else {\n            config.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return config;\n}\n\nfn show_help() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <files...>\");\n    print(\"Options:\");\n    print(\"  --verbose, -v     Enable verbose output\");\n    print(\"  --output, -o FILE Set output file\");\n    print(\"  --help, -h        Show this help\");\n}\n\nlet config = parse_arguments();\n\nif (config.help) {\n    show_help();\n} else if (config.files.length == 0) {\n    print(\"Error: No input files specified\");\n    show_help();\n} else {\n    if (config.verbose) {\n        print(\"Verbose mode enabled\");\n        print(\"Output file: \" + config.output);\n        print(\"Input files: \" + typeof(config.files.length));\n    }\n\n    // 处理文件\n    for (let file in config.files) {\n        if (config.verbose) {\n            print(\"Processing: \" + file);\n        }\n        // ... 处理文件\n    }\n}\n```\n\n### 示例 4：配置工具\n\n```hemlock\n// 用法: ./hemlock config.hml <action> [arguments]\n// 操作:\n//   get <key>\n//   set <key> <value>\n//   list\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <action> [arguments]\");\n    print(\"Actions:\");\n    print(\"  get <key>         Get configuration value\");\n    print(\"  set <key> <value> Set configuration value\");\n    print(\"  list              List all configuration\");\n}\n\nif (args.length < 2) {\n    show_usage();\n} else {\n    let action = args[1];\n\n    if (action == \"get\") {\n        if (args.length < 3) {\n            print(\"Error: 'get' requires a key\");\n        } else {\n            let key = args[2];\n            print(\"Getting: \" + key);\n            // ... 从配置获取\n        }\n    } else if (action == \"set\") {\n        if (args.length < 4) {\n            print(\"Error: 'set' requires key and value\");\n        } else {\n            let key = args[2];\n            let value = args[3];\n            print(\"Setting \" + key + \" = \" + value);\n            // ... 设置配置\n        }\n    } else if (action == \"list\") {\n        print(\"Listing all configuration:\");\n        // ... 列出配置\n    } else {\n        print(\"Error: Unknown action: \" + action);\n        show_usage();\n    }\n}\n```\n\n## 总结\n\nHemlock 的命令行参数支持提供：\n\n- 全局可用的内置 `args` 数组\n- 简单的基于数组的参数访问\n- 脚本名称在 `args[0]`\n- 所有参数都是字符串\n- 可用的数组方法（.length、.slice 等）\n\n请记住：\n- 访问元素前始终检查 `args.length`\n- `args[0]` 是脚本名称\n- 实际参数从 `args[1]` 开始\n- 所有参数都是字符串 - 根据需要转换\n- 为用户友好的工具提供用法信息\n- 处理前验证参数\n\n常见模式：\n- 简单位置参数\n- 命名/标志参数（--flag）\n- 值参数（--option value）\n- 帮助信息（--help）\n- 参数验证\n"}, "Advanced Topics -> Ffi": {"id": "advanced-ffi", "content": "# Hemlock 外部函数接口（FFI）\n\nHemlock 提供 **FFI（外部函数接口）**，可使用 libffi 调用共享库中的 C 函数，实现与现有 C 库和系统 API 的集成。\n\n## 目录\n\n- [概述](#概述)\n- [当前状态](#当前状态)\n- [支持的类型](#支持的类型)\n- [基本概念](#基本概念)\n- [导出 FFI 函数](#导出-ffi-函数)\n- [用例](#用例)\n- [未来发展](#未来发展)\n- [FFI 回调](#ffi-回调)\n- [FFI 结构体](#ffi-结构体)\n- [当前限制](#当前限制)\n- [最佳实践](#最佳实践)\n\n## 概述\n\n外部函数接口（FFI）允许 Hemlock 程序：\n- 从共享库（.so、.dylib、.dll）调用 C 函数\n- 使用现有 C 库而无需编写包装代码\n- 直接访问系统 API\n- 与第三方原生库集成\n- 将 Hemlock 与底层系统功能桥接\n\n**关键能力：**\n- 动态库加载\n- C 函数绑定\n- Hemlock 和 C 类型之间的自动类型转换\n- 支持所有原始类型\n- 基于 libffi 的实现，具有可移植性\n\n## 当前状态\n\nHemlock 中的 FFI 支持具有以下特性：\n\n**已实现：**\n- 从共享库调用 C 函数\n- 支持所有原始类型（整数、浮点数、指针）\n- 自动类型转换\n- 基于 libffi 的实现\n- 动态库加载\n- **函数指针回调** - 将 Hemlock 函数传递给 C\n- **导出 extern 函数** - 跨模块共享 FFI 绑定\n- **结构体传递和返回值** - 按值传递 C 兼容的结构体\n- **完整的指针辅助函数** - 读写所有类型（i8-i64, u8-u64, f32, f64, ptr）\n- **缓冲区/指针转换** - `buffer_ptr()`、`ptr_to_buffer()`\n- **FFI 类型大小** - `ffi_sizeof()` 用于平台感知的类型大小\n- **平台类型** - 支持 `size_t`、`usize`、`isize`、`intptr_t`\n\n**开发中：**\n- 字符串封送辅助函数\n- 错误处理改进\n\n## 支持的类型\n\n### 原始类型\n\n以下 Hemlock 类型可以传递给 C 函数或从 C 函数返回：\n\n| Hemlock 类型 | C 类型 | 大小 | 说明 |\n|--------------|--------|------|------|\n| `i8` | `int8_t` | 1 字节 | 有符号 8 位整数 |\n| `i16` | `int16_t` | 2 字节 | 有符号 16 位整数 |\n| `i32` | `int32_t` | 4 字节 | 有符号 32 位整数 |\n| `i64` | `int64_t` | 8 字节 | 有符号 64 位整数 |\n| `u8` | `uint8_t` | 1 字节 | 无符号 8 位整数 |\n| `u16` | `uint16_t` | 2 字节 | 无符号 16 位整数 |\n| `u32` | `uint32_t` | 4 字节 | 无符号 32 位整数 |\n| `u64` | `uint64_t` | 8 字节 | 无符号 64 位整数 |\n| `f32` | `float` | 4 字节 | 32 位浮点数 |\n| `f64` | `double` | 8 字节 | 64 位浮点数 |\n| `ptr` | `void*` | 8 字节 | 原始指针 |\n\n### 类型转换\n\n**自动转换：**\n- Hemlock 整数 -> C 整数（带范围检查）\n- Hemlock 浮点数 -> C 浮点数\n- Hemlock 指针 -> C 指针\n- C 返回值 -> Hemlock 值\n\n**示例类型映射：**\n```hemlock\n// Hemlock -> C\nlet i: i32 = 42;         // -> int32_t (4 字节)\nlet f: f64 = 3.14;       // -> double (8 字节)\nlet p: ptr = alloc(64);  // -> void* (8 字节)\n\n// C -> Hemlock（返回值）\n// int32_t foo() -> i32\n// double bar() -> f64\n// void* baz() -> ptr\n```\n\n## 基本概念\n\n### 共享库\n\nFFI 与编译后的共享库配合使用：\n\n**Linux:** `.so` 文件\n```\nlibexample.so\n/usr/lib/libm.so\n```\n\n**macOS:** `.dylib` 文件\n```\nlibexample.dylib\n/usr/lib/libSystem.dylib\n```\n\n**Windows:** `.dll` 文件\n```\nexample.dll\nkernel32.dll\n```\n\n### 函数签名\n\nC 函数必须具有已知的签名才能让 FFI 正常工作：\n\n```c\n// 示例 C 函数签名\nint add(int a, int b);\ndouble sqrt(double x);\nvoid* malloc(size_t size);\nvoid free(void* ptr);\n```\n\n一旦加载库并绑定函数，就可以从 Hemlock 调用这些函数。\n\n### 平台兼容性\n\nFFI 使用 **libffi** 实现可移植性：\n- 适用于 x86、x86-64、ARM、ARM64\n- 自动处理调用约定\n- 抽象平台特定的 ABI 细节\n- 支持 Linux、macOS、Windows（需要适当的 libffi）\n\n## 导出 FFI 函数\n\n使用 `extern fn` 声明的 FFI 函数可以从模块导出，允许您创建可跨多个文件共享的可重用库包装器。\n\n### 基本导出语法\n\n```hemlock\n// string_utils.hml - 包装 C 字符串函数的库模块\nimport \"libc.so.6\";\n\n// 直接导出 extern 函数\nexport extern fn strlen(s: string): i32;\nexport extern fn strcmp(s1: string, s2: string): i32;\n\n// 您也可以在 extern 函数旁边导出包装函数\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n\nexport fn strings_equal(a: string, b: string): bool {\n    return strcmp(a, b) == 0;\n}\n```\n\n### 导入导出的 FFI 函数\n\n```hemlock\n// main.hml - 使用导出的 FFI 函数\nimport { strlen, string_length, strings_equal } from \"./string_utils.hml\";\n\nlet msg = \"Hello, World!\";\nprint(strlen(msg));           // 13 - 直接 extern 调用\nprint(string_length(msg));    // 13 - 包装函数\n\nprint(strings_equal(\"foo\", \"foo\"));  // true\nprint(strings_equal(\"foo\", \"bar\"));  // false\n```\n\n### Export Extern 的用例\n\n**1. 平台抽象**\n```hemlock\n// platform.hml - 抽象平台差异\nimport \"libc.so.6\";  // Linux\n\nexport extern fn getpid(): i32;\nexport extern fn getuid(): i32;\nexport extern fn geteuid(): i32;\n```\n\n**2. 库包装器**\n```hemlock\n// crypto_lib.hml - 包装加密库函数\nimport \"libcrypto.so\";\n\nexport extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;\nexport extern fn MD5(data: ptr, len: u64, out: ptr): ptr;\n\n// 添加 Hemlock 友好的包装器\nexport fn sha256_string(s: string): string {\n    // 使用 extern 函数的实现\n}\n```\n\n**3. 集中式 FFI 声明**\n```hemlock\n// libc.hml - libc 绑定的中央模块\nimport \"libc.so.6\";\n\n// 字符串函数\nexport extern fn strlen(s: string): i32;\nexport extern fn strcpy(dest: ptr, src: string): ptr;\nexport extern fn strcat(dest: ptr, src: string): ptr;\n\n// 内存函数\nexport extern fn malloc(size: u64): ptr;\nexport extern fn realloc(p: ptr, size: u64): ptr;\nexport extern fn calloc(nmemb: u64, size: u64): ptr;\n\n// 进程函数\nexport extern fn getpid(): i32;\nexport extern fn getppid(): i32;\nexport extern fn getenv(name: string): ptr;\n```\n\n然后在整个项目中使用：\n```hemlock\nimport { strlen, malloc, getpid } from \"./libc.hml\";\n```\n\n## 用例\n\n### 1. 系统库\n\n访问标准 C 库函数：\n\n**数学函数：**\n```hemlock\n// 从 libm 调用 sqrt\nlet result = sqrt(16.0);  // 4.0\n```\n\n**内存分配：**\n```hemlock\n// 从 libc 调用 malloc/free\nlet ptr = malloc(1024);\nfree(ptr);\n```\n\n### 2. 第三方库\n\n使用现有的 C 库：\n\n**示例：图像处理**\n```hemlock\n// 加载 libpng 或 libjpeg\n// 使用 C 库函数处理图像\n```\n\n**示例：加密**\n```hemlock\n// 使用 OpenSSL 或 libsodium\n// 通过 FFI 进行加密/解密\n```\n\n### 3. 系统 API\n\n直接系统调用：\n\n**示例：POSIX API**\n```hemlock\n// 调用 getpid、getuid 等\n// 访问底层系统功能\n```\n\n### 4. 性能关键代码\n\n调用优化的 C 实现：\n\n```hemlock\n// 使用高度优化的 C 库\n// SIMD 操作、向量化代码\n// 硬件加速函数\n```\n\n## FFI 回调\n\nHemlock 支持使用 libffi 闭包将函数作为回调传递给 C 代码。这使得能够与期望函数指针的 C API 集成，如 `qsort`、事件循环和基于回调的库。\n\n### 创建回调\n\n使用 `callback()` 从 Hemlock 函数创建 C 可调用的函数指针：\n\n```hemlock\n// callback(function, param_types, return_type) -> ptr\nlet cb = callback(my_function, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n**参数：**\n- `function`：要包装的 Hemlock 函数\n- `param_types`：类型名称字符串数组（如 `[\"ptr\", \"i32\"]`）\n- `return_type`：返回类型字符串（如 `\"i32\"`、`\"void\"`）\n\n**支持的回调类型：**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - 有符号整数\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - 无符号整数\n- `\"f32\"`, `\"f64\"` - 浮点数\n- `\"ptr\"` - 指针\n- `\"void\"` - 无返回值\n- `\"bool\"` - 布尔值\n\n### 示例：qsort\n\n```hemlock\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// 整数比较函数（升序）\nfn compare_ints(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va < vb) { return -1; }\n    if (va > vb) { return 1; }\n    return 0;\n}\n\n// 分配 5 个整数的数组\nlet arr = alloc(20);  // 5 * 4 字节\nptr_write_i32(arr, 5);\nptr_write_i32(ptr_offset(arr, 1, 4), 2);\nptr_write_i32(ptr_offset(arr, 2, 4), 8);\nptr_write_i32(ptr_offset(arr, 3, 4), 1);\nptr_write_i32(ptr_offset(arr, 4, 4), 9);\n\n// 创建回调并排序\nlet cmp = callback(compare_ints, [\"ptr\", \"ptr\"], \"i32\");\nqsort(arr, 5, 4, cmp);\n\n// 数组现在已排序：[1, 2, 5, 8, 9]\n\n// 清理\ncallback_free(cmp);\nfree(arr);\n```\n\n### 指针辅助函数\n\nHemlock 提供全面的辅助函数用于处理原始指针。这些对于 FFI 回调和直接内存操作至关重要。\n\n#### 整数类型辅助函数\n\n| 函数 | 描述 |\n|------|------|\n| `ptr_deref_i8(ptr)` | 解引用指针，读取 i8 |\n| `ptr_deref_i16(ptr)` | 解引用指针，读取 i16 |\n| `ptr_deref_i32(ptr)` | 解引用指针，读取 i32 |\n| `ptr_deref_i64(ptr)` | 解引用指针，读取 i64 |\n| `ptr_deref_u8(ptr)` | 解引用指针，读取 u8 |\n| `ptr_deref_u16(ptr)` | 解引用指针，读取 u16 |\n| `ptr_deref_u32(ptr)` | 解引用指针，读取 u32 |\n| `ptr_deref_u64(ptr)` | 解引用指针，读取 u64 |\n| `ptr_write_i8(ptr, value)` | 向指针位置写入 i8 |\n| `ptr_write_i16(ptr, value)` | 向指针位置写入 i16 |\n| `ptr_write_i32(ptr, value)` | 向指针位置写入 i32 |\n| `ptr_write_i64(ptr, value)` | 向指针位置写入 i64 |\n| `ptr_write_u8(ptr, value)` | 向指针位置写入 u8 |\n| `ptr_write_u16(ptr, value)` | 向指针位置写入 u16 |\n| `ptr_write_u32(ptr, value)` | 向指针位置写入 u32 |\n| `ptr_write_u64(ptr, value)` | 向指针位置写入 u64 |\n\n#### 浮点类型辅助函数\n\n| 函数 | 描述 |\n|------|------|\n| `ptr_deref_f32(ptr)` | 解引用指针，读取 f32 (float) |\n| `ptr_deref_f64(ptr)` | 解引用指针，读取 f64 (double) |\n| `ptr_write_f32(ptr, value)` | 向指针位置写入 f32 |\n| `ptr_write_f64(ptr, value)` | 向指针位置写入 f64 |\n\n#### 指针类型辅助函数\n\n| 函数 | 描述 |\n|------|------|\n| `ptr_deref_ptr(ptr)` | 解引用指向指针的指针 |\n| `ptr_write_ptr(ptr, value)` | 向指针位置写入指针 |\n| `ptr_offset(ptr, index, size)` | 计算偏移：`ptr + index * size` |\n| `ptr_read_i32(ptr)` | 通过指向指针的指针读取 i32（用于 qsort 回调） |\n| `ptr_null()` | 获取空指针常量 |\n\n#### 缓冲区转换辅助函数\n\n| 函数 | 描述 |\n|------|------|\n| `buffer_ptr(buffer)` | 从缓冲区获取原始指针 |\n| `ptr_to_buffer(ptr, size)` | 从指针复制数据到新缓冲区 |\n\n#### FFI 实用函数\n\n| 函数 | 描述 |\n|------|------|\n| `ffi_sizeof(type_name)` | 获取 FFI 类型的字节大小 |\n\n**`ffi_sizeof` 支持的类型名称：**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - 有符号整数（1, 2, 4, 8 字节）\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - 无符号整数（1, 2, 4, 8 字节）\n- `\"f32\"`, `\"f64\"` - 浮点数（4, 8 字节）\n- `\"ptr\"` - 指针（64 位系统上 8 字节）\n- `\"size_t\"`, `\"usize\"` - 平台相关的大小类型\n- `\"intptr_t\"`, `\"isize\"` - 平台相关的有符号指针类型\n\n### 释放回调\n\n**重要：** 始终在使用完回调后释放它们以防止内存泄漏：\n\n```hemlock\nlet cb = callback(my_fn, [\"ptr\"], \"void\");\n// ... 使用回调 ...\ncallback_free(cb);  // 使用完后释放\n```\n\n程序退出时回调也会自动释放。\n\n### 回调中的闭包\n\n回调捕获其闭包环境，因此可以访问外部作用域变量：\n\n```hemlock\nlet multiplier = 10;\n\nfn scale(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    // 可以访问外部作用域的 'multiplier'\n    return (va * multiplier) - (vb * multiplier);\n}\n\nlet cmp = callback(scale, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n### 线程安全\n\n回调调用通过互斥锁序列化以确保线程安全，因为 Hemlock 解释器不是完全线程安全的。这意味着：\n- 一次只能执行一个回调\n- 可以安全地与多线程 C 库一起使用\n- 如果回调从多个线程频繁调用，可能影响性能\n\n### 回调中的错误处理\n\n在回调中抛出的异常无法传播到 C 代码。相反：\n- 向 stderr 打印警告\n- 回调返回默认值（0 或 NULL）\n- 异常被记录但不传播\n\n```hemlock\nfn risky_callback(a: ptr): i32 {\n    throw \"Something went wrong\";  // 打印警告，返回 0\n}\n```\n\n为了健壮的错误处理，请验证输入并避免在回调中抛出异常。\n\n## FFI 结构体\n\nHemlock 支持按值向 C 函数传递结构体。当您使用类型注解定义结构体时，结构体类型会自动为 FFI 注册。\n\n### 定义 FFI 兼容的结构体\n\n当所有字段都具有使用 FFI 兼容类型的显式类型注解时，结构体就是 FFI 兼容的：\n\n```hemlock\n// FFI 兼容的结构体\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\n// 具有多种字段类型的 FFI 兼容结构体\ndefine Rectangle {\n    top_left: Point,      // 嵌套结构体\n    width: f64,\n    height: f64,\n}\n\n// 不是 FFI 兼容的（字段没有类型注解）\ndefine DynamicObject {\n    name,                 // 没有类型 - 不能用于 FFI\n    value,\n}\n```\n\n### 在 FFI 中使用结构体\n\n声明使用结构体类型的 extern 函数：\n\n```hemlock\n// 定义结构体类型\ndefine Vector2D {\n    x: f64,\n    y: f64,\n}\n\n// 导入 C 库\nimport \"libmath.so\";\n\n// 声明接受/返回结构体的 extern 函数\nextern fn vector_add(a: Vector2D, b: Vector2D): Vector2D;\nextern fn vector_length(v: Vector2D): f64;\n\n// 自然地使用它\nlet a: Vector2D = { x: 3.0, y: 0.0 };\nlet b: Vector2D = { x: 0.0, y: 4.0 };\nlet result = vector_add(a, b);\nprint(result.x);  // 3.0\nprint(result.y);  // 4.0\n\nlet len = vector_length(result);\nprint(len);       // 5.0\n```\n\n### 支持的字段类型\n\n结构体字段必须使用以下 FFI 兼容类型：\n\n| Hemlock 类型 | C 类型 | 大小 |\n|--------------|--------|------|\n| `i8` | `int8_t` | 1 字节 |\n| `i16` | `int16_t` | 2 字节 |\n| `i32` | `int32_t` | 4 字节 |\n| `i64` | `int64_t` | 8 字节 |\n| `u8` | `uint8_t` | 1 字节 |\n| `u16` | `uint16_t` | 2 字节 |\n| `u32` | `uint32_t` | 4 字节 |\n| `u64` | `uint64_t` | 8 字节 |\n| `f32` | `float` | 4 字节 |\n| `f64` | `double` | 8 字节 |\n| `ptr` | `void*` | 8 字节 |\n| `string` | `char*` | 8 字节 |\n| `bool` | `int` | 可变 |\n| 嵌套结构体 | struct | 可变 |\n\n### 结构体布局\n\nHemlock 使用平台的原生结构体布局规则（匹配 C ABI）：\n- 字段按其类型对齐\n- 根据需要插入填充\n- 总大小填充以对齐最大成员\n\n```hemlock\n// 示例：C 兼容布局\ndefine Mixed {\n    a: i8,    // 偏移 0，大小 1\n              // 3 字节填充\n    b: i32,   // 偏移 4，大小 4\n}\n// 总大小：8 字节（包含填充）\n\ndefine Point3D {\n    x: f64,   // 偏移 0，大小 8\n    y: f64,   // 偏移 8，大小 8\n    z: f64,   // 偏移 16，大小 8\n}\n// 总大小：24 字节（不需要填充）\n```\n\n### 嵌套结构体\n\n结构体可以包含其他结构体：\n\n```hemlock\ndefine Inner {\n    x: i32,\n    y: i32,\n}\n\ndefine Outer {\n    inner: Inner,\n    z: i32,\n}\n\nimport \"mylib.so\";\nextern fn process_nested(data: Outer): i32;\n\nlet obj: Outer = {\n    inner: { x: 1, y: 2 },\n    z: 3,\n};\nlet result = process_nested(obj);\n```\n\n### 结构体返回值\n\nC 函数可以返回结构体：\n\n```hemlock\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\nimport \"libmath.so\";\nextern fn get_origin(): Point;\n\nlet p = get_origin();\nprint(p.x);  // 0.0\nprint(p.y);  // 0.0\n```\n\n### 限制\n\n- **结构体字段必须有类型注解** - 没有类型的字段不是 FFI 兼容的\n- **结构体中没有数组** - 改用指针\n- **没有联合体** - 仅支持结构体类型\n- **回调不能返回结构体** - 回调返回值使用指针\n\n## 当前限制\n\nFFI 有以下限制：\n\n**1. 手动类型转换**\n- 必须手动管理字符串转换\n- 没有自动的 Hemlock 字符串 <-> C 字符串转换\n\n**2. 有限的错误处理**\n- 基本错误报告\n- 回调中的异常无法传播到 C\n\n**3. 手动库加载**\n- 必须手动加载库\n- 没有自动绑定生成\n\n**4. 平台特定代码**\n- 库路径因平台而异\n- 必须处理 .so vs .dylib vs .dll\n\n## 最佳实践\n\n虽然全面的 FFI 文档仍在开发中，以下是一般的最佳实践：\n\n### 1. 类型安全\n\n```hemlock\n// 明确类型\nlet x: i32 = 42;\nlet result: f64 = c_function(x);\n```\n\n### 2. 内存管理\n\n```hemlock\n// 记住释放分配的内存\nlet ptr = c_malloc(1024);\n// ... 使用 ptr\nc_free(ptr);\n```\n\n### 3. 错误检查\n\n```hemlock\n// 检查返回值\nlet result = c_function();\nif (result == null) {\n    print(\"C function failed\");\n}\n```\n\n### 4. 平台兼容性\n\n```hemlock\n// 处理平台差异\n// 使用适当的库扩展名（.so、.dylib、.dll）\n```\n\n## 总结\n\nHemlock 的 FFI 提供：\n\n- 从共享库调用 C 函数\n- 原始类型支持（i8-i64, u8-u64, f32, f64, ptr）\n- 自动类型转换\n- 基于 libffi 的可移植性\n- 原生库集成基础\n- **函数指针回调** - 将 Hemlock 函数传递给 C\n- **导出 extern 函数** - 跨模块共享 FFI 绑定\n- **结构体传递和返回** - 按值传递 C 兼容的结构体\n- **导出 define** - 跨模块共享结构体类型定义（自动全局导入）\n- **完整的指针辅助函数** - 读写所有类型（i8-i64, u8-u64, f32, f64, ptr）\n- **缓冲区/指针转换** - 用于数据封送的 `buffer_ptr()`、`ptr_to_buffer()`\n- **FFI 类型大小** - 平台感知类型大小的 `ffi_sizeof()`\n- **平台类型** - 支持 `size_t`、`usize`、`isize`、`intptr_t`、`uintptr_t`\n\n**当前状态：** FFI 功能完备，支持原始类型、结构体、回调、模块导出和完整的指针辅助函数\n\n**未来：** 字符串封送辅助函数\n\n**用例：** 系统库、第三方库、qsort、事件循环、基于回调的 API、可重用的库包装器\n"}, "Advanced Topics -> File Io": {"id": "advanced-file-io", "content": "# Hemlock 文件 I/O\n\nHemlock 提供**文件对象 API**用于文件操作，具有适当的错误处理和资源管理。\n\n## 目录\n\n- [概述](#概述)\n- [打开文件](#打开文件)\n- [文件方法](#文件方法)\n- [文件属性](#文件属性)\n- [错误处理](#错误处理)\n- [资源管理](#资源管理)\n- [完整 API 参考](#完整-api-参考)\n- [常见模式](#常见模式)\n- [最佳实践](#最佳实践)\n\n## 概述\n\n文件对象 API 提供：\n\n- **显式资源管理** - 文件必须手动关闭\n- **多种打开模式** - 读取、写入、追加、读写\n- **文本和二进制操作** - 读写文本和二进制数据\n- **定位支持** - 文件内的随机访问\n- **全面的错误消息** - 上下文感知的错误报告\n\n**重要：** 文件不会自动关闭。您必须调用 `f.close()` 以避免文件描述符泄漏。\n\n## 打开文件\n\n使用 `open(path, mode?)` 打开文件：\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");     // 读取模式（默认）\nlet f2 = open(\"output.txt\", \"w\");  // 写入模式（截断）\nlet f3 = open(\"log.txt\", \"a\");     // 追加模式\nlet f4 = open(\"data.bin\", \"r+\");   // 读写模式\n```\n\n### 打开模式\n\n| 模式 | 描述 | 文件必须存在 | 截断 | 位置 |\n|------|------|------------|------|------|\n| `\"r\"` | 读取（默认） | 是 | 否 | 开始 |\n| `\"w\"` | 写入 | 否（创建） | 是 | 开始 |\n| `\"a\"` | 追加 | 否（创建） | 否 | 结束 |\n| `\"r+\"` | 读写 | 是 | 否 | 开始 |\n| `\"w+\"` | 读写 | 否（创建） | 是 | 开始 |\n| `\"a+\"` | 读取和追加 | 否（创建） | 否 | 结束 |\n\n### 示例\n\n**读取现有文件：**\n```hemlock\nlet f = open(\"config.json\", \"r\");\n// 或简单地：\nlet f = open(\"config.json\");  // \"r\" 是默认值\n```\n\n**创建新文件用于写入：**\n```hemlock\nlet f = open(\"output.txt\", \"w\");  // 创建或截断\n```\n\n**追加到文件：**\n```hemlock\nlet f = open(\"log.txt\", \"a\");  // 如果不存在则创建\n```\n\n**读写模式：**\n```hemlock\nlet f = open(\"data.bin\", \"r+\");  // 现有文件，可读写\n```\n\n## 文件方法\n\n### 读取\n\n#### read(size?: i32): string\n\n从文件读取文本（可选的大小参数）。\n\n**不带大小（读取全部）：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet all = f.read();  // 从当前位置读取到 EOF\nf.close();\n```\n\n**带大小（读取指定字节）：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet chunk = f.read(1024);  // 读取最多 1024 字节\nlet next = f.read(1024);   // 读取下一个 1024 字节\nf.close();\n```\n\n**返回：** 包含读取数据的字符串，如果在 EOF 则返回空字符串\n\n**示例 - 读取整个文件：**\n```hemlock\nlet f = open(\"poem.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n```\n\n**示例 - 分块读取：**\n```hemlock\nlet f = open(\"large.txt\", \"r\");\nwhile (true) {\n    let chunk = f.read(4096);  // 4KB 块\n    if (chunk == \"\") { break; }  // 到达 EOF\n    process(chunk);\n}\nf.close();\n```\n\n#### read_bytes(size: i32): buffer\n\n读取二进制数据（返回缓冲区）。\n\n**参数：**\n- `size` (i32) - 要读取的字节数\n\n**返回：** 包含读取字节的缓冲区\n\n```hemlock\nlet f = open(\"image.png\", \"r\");\nlet binary = f.read_bytes(256);  // 读取 256 字节\nprint(binary.length);  // 256（如果 EOF 则更少）\n\n// 访问单个字节\nlet first_byte = binary[0];\nprint(first_byte);\n\nf.close();\n```\n\n### 写入\n\n#### write(data: string): i32\n\n向文件写入文本（返回写入的字节数）。\n\n**参数：**\n- `data` (string) - 要写入的文本\n\n**返回：** 写入的字节数 (i32)\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Wrote \" + typeof(written) + \" bytes\");  // \"Wrote 14 bytes\"\nf.close();\n```\n\n**示例 - 写入多行：**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Line 1\\n\");\nf.write(\"Line 2\\n\");\nf.write(\"Line 3\\n\");\nf.close();\n```\n\n**示例 - 追加到日志文件：**\n```hemlock\nlet f = open(\"app.log\", \"a\");\nf.write(\"[INFO] Application started\\n\");\nf.write(\"[INFO] User logged in\\n\");\nf.close();\n```\n\n#### write_bytes(data: buffer): i32\n\n写入二进制数据（返回写入的字节数）。\n\n**参数：**\n- `data` (buffer) - 要写入的二进制数据\n\n**返回：** 写入的字节数 (i32)\n\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// 创建二进制数据\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\nlet bytes = f.write_bytes(buf);\nprint(\"Wrote \" + typeof(bytes) + \" bytes\");\n\nf.close();\n```\n\n### 定位\n\n#### seek(position: i32): i32\n\n移动到指定位置（返回新位置）。\n\n**参数：**\n- `position` (i32) - 从文件开头的字节偏移量\n\n**返回：** 新位置 (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// 移动到第 100 字节\nf.seek(100);\n\n// 从位置 100 读取\nlet data = f.read(50);\n\n// 重置到开头\nf.seek(0);\n\nf.close();\n```\n\n**示例 - 随机访问：**\n```hemlock\nlet f = open(\"records.dat\", \"r\");\n\n// 读取偏移量 1000 处的记录\nf.seek(1000);\nlet record1 = f.read_bytes(100);\n\n// 读取偏移量 2000 处的记录\nf.seek(2000);\nlet record2 = f.read_bytes(100);\n\nf.close();\n```\n\n#### tell(): i32\n\n获取文件中的当前位置。\n\n**返回：** 当前字节偏移量 (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet pos1 = f.tell();  // 0（在开始处）\n\nf.read(100);\nlet pos2 = f.tell();  // 100（读取 100 字节后）\n\nf.seek(500);\nlet pos3 = f.tell();  // 500（定位后）\n\nf.close();\n```\n\n### 关闭\n\n#### close()\n\n关闭文件（幂等，可以多次调用）。\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n// ... 使用文件\nf.close();\nf.close();  // 安全 - 第二次关闭不报错\n```\n\n**重要说明：**\n- 始终在使用完后关闭文件以避免文件描述符泄漏\n- 关闭是幂等的 - 可以安全地多次调用\n- 关闭后，所有其他操作将报错\n- 使用 `finally` 块确保即使出错也能关闭文件\n\n## 文件属性\n\n文件对象有三个只读属性：\n\n### path: string\n\n用于打开文件的文件路径。\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);  // \"/path/to/file.txt\"\nf.close();\n```\n\n### mode: string\n\n文件打开时使用的模式。\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);  // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);  // \"w\"\nf2.close();\n```\n\n### closed: bool\n\n文件是否已关闭。\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n**示例 - 检查文件是否打开：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... 处理内容\n}\n\nf.close();\n\nif (f.closed) {\n    print(\"File is now closed\");\n}\n```\n\n## 错误处理\n\n所有文件操作都包含带上下文的适当错误消息。\n\n### 常见错误\n\n**文件未找到：**\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// 错误：Failed to open 'missing.txt': No such file or directory\n```\n\n**从已关闭的文件读取：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// 错误：Cannot read from closed file 'data.txt'\n```\n\n**向只读文件写入：**\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// 错误：Cannot write to file 'readonly.txt' opened in read-only mode\n```\n\n**从只写文件读取：**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.read();\n// 错误：Cannot read from file 'output.txt' opened in write-only mode\n```\n\n### 使用 try/catch\n\n```hemlock\ntry {\n    let f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    f.close();\n    process(content);\n} catch (e) {\n    print(\"Error reading file: \" + e);\n}\n```\n\n## 资源管理\n\n### 基本模式\n\n始终显式关闭文件：\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### 带错误处理（推荐）\n\n使用 `finally` 确保即使出错也能关闭文件：\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // 始终关闭，即使出错\n}\n```\n\n### 多个文件\n\n```hemlock\nlet src = null;\nlet dst = null;\n\ntry {\n    src = open(\"input.txt\", \"r\");\n    dst = open(\"output.txt\", \"w\");\n\n    let content = src.read();\n    dst.write(content);\n} finally {\n    if (src != null) { src.close(); }\n    if (dst != null) { dst.close(); }\n}\n```\n\n### 辅助函数模式\n\n```hemlock\nfn with_file(path: string, mode: string, callback) {\n    let f = open(path, mode);\n    try {\n        return callback(f);\n    } finally {\n        f.close();\n    }\n}\n\n// 使用：\nwith_file(\"data.txt\", \"r\", fn(f) {\n    return f.read();\n});\n```\n\n## 完整 API 参考\n\n### 函数\n\n| 函数 | 参数 | 返回 | 描述 |\n|------|------|------|------|\n| `open(path, mode?)` | path: string, mode?: string | File | 打开文件（模式默认为 \"r\"） |\n\n### 方法\n\n| 方法 | 参数 | 返回 | 描述 |\n|------|------|------|------|\n| `read(size?)` | size?: i32 | string | 读取文本（全部或指定字节） |\n| `read_bytes(size)` | size: i32 | buffer | 读取二进制数据 |\n| `write(data)` | data: string | i32 | 写入文本，返回写入的字节数 |\n| `write_bytes(data)` | data: buffer | i32 | 写入二进制数据，返回写入的字节数 |\n| `seek(position)` | position: i32 | i32 | 定位到位置，返回新位置 |\n| `tell()` | - | i32 | 获取当前位置 |\n| `close()` | - | null | 关闭文件（幂等） |\n\n### 属性（只读）\n\n| 属性 | 类型 | 描述 |\n|------|------|------|\n| `path` | string | 文件路径 |\n| `mode` | string | 打开模式 |\n| `closed` | bool | 文件是否已关闭 |\n\n## 常见模式\n\n### 读取整个文件\n\n```hemlock\nfn read_file(path: string): string {\n    let f = open(path, \"r\");\n    try {\n        return f.read();\n    } finally {\n        f.close();\n    }\n}\n\nlet content = read_file(\"config.json\");\n```\n\n### 写入整个文件\n\n```hemlock\nfn write_file(path: string, content: string) {\n    let f = open(path, \"w\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\");\n```\n\n### 追加到文件\n\n```hemlock\nfn append_file(path: string, content: string) {\n    let f = open(path, \"a\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nappend_file(\"log.txt\", \"[INFO] Event occurred\\n\");\n```\n\n### 读取行\n\n```hemlock\nfn read_lines(path: string) {\n    let f = open(path, \"r\");\n    try {\n        let content = f.read();\n        return content.split(\"\\n\");\n    } finally {\n        f.close();\n    }\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### 分块处理大文件\n\n```hemlock\nfn process_large_file(path: string) {\n    let f = open(path, \"r\");\n    try {\n        while (true) {\n            let chunk = f.read(4096);  // 4KB 块\n            if (chunk == \"\") { break; }\n\n            // 处理块\n            process_chunk(chunk);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n### 二进制文件复制\n\n```hemlock\nfn copy_file(src_path: string, dst_path: string) {\n    let src = null;\n    let dst = null;\n\n    try {\n        src = open(src_path, \"r\");\n        dst = open(dst_path, \"w\");\n\n        while (true) {\n            let chunk = src.read_bytes(4096);\n            if (chunk.length == 0) { break; }\n\n            dst.write_bytes(chunk);\n        }\n    } finally {\n        if (src != null) { src.close(); }\n        if (dst != null) { dst.close(); }\n    }\n}\n\ncopy_file(\"input.dat\", \"output.dat\");\n```\n\n### 文件截断\n\n```hemlock\nfn truncate_file(path: string) {\n    let f = open(path, \"w\");  // \"w\" 模式截断\n    f.close();\n}\n\ntruncate_file(\"empty_me.txt\");\n```\n\n### 随机访问读取\n\n```hemlock\nfn read_at_offset(path: string, offset: i32, size: i32): string {\n    let f = open(path, \"r\");\n    try {\n        f.seek(offset);\n        return f.read(size);\n    } finally {\n        f.close();\n    }\n}\n\nlet data = read_at_offset(\"records.dat\", 1000, 100);\n```\n\n## 最佳实践\n\n### 1. 始终使用 try/finally\n\n```hemlock\n// 好\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();\n}\n\n// 不好 - 出错时文件可能不关闭\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprocess(content);  // 如果这里抛出异常，文件泄漏\nf.close();\n```\n\n### 2. 操作前检查文件状态\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... 使用内容\n}\n\nf.close();\n```\n\n### 3. 使用适当的模式\n\n```hemlock\n// 只读？使用 \"r\"\nlet f = open(\"config.json\", \"r\");\n\n// 完全替换？使用 \"w\"\nlet f = open(\"output.txt\", \"w\");\n\n// 添加到末尾？使用 \"a\"\nlet f = open(\"log.txt\", \"a\");\n```\n\n### 4. 优雅地处理错误\n\n```hemlock\nfn safe_read_file(path: string): string {\n    try {\n        let f = open(path, \"r\");\n        try {\n            return f.read();\n        } finally {\n            f.close();\n        }\n    } catch (e) {\n        print(\"Warning: Could not read \" + path + \": \" + e);\n        return \"\";\n    }\n}\n```\n\n### 5. 按打开的相反顺序关闭文件\n\n```hemlock\nlet f1 = null;\nlet f2 = null;\nlet f3 = null;\n\ntry {\n    f1 = open(\"file1.txt\", \"r\");\n    f2 = open(\"file2.txt\", \"r\");\n    f3 = open(\"file3.txt\", \"r\");\n\n    // ... 使用文件\n} finally {\n    // 按相反顺序关闭\n    if (f3 != null) { f3.close(); }\n    if (f2 != null) { f2.close(); }\n    if (f1 != null) { f1.close(); }\n}\n```\n\n### 6. 避免完全读取大文件\n\n```hemlock\n// 对大文件不好\nlet f = open(\"huge.log\", \"r\");\nlet content = f.read();  // 将整个文件加载到内存\nf.close();\n\n// 好 - 分块处理\nlet f = open(\"huge.log\", \"r\");\ntry {\n    while (true) {\n        let chunk = f.read(4096);\n        if (chunk == \"\") { break; }\n        process_chunk(chunk);\n    }\n} finally {\n    f.close();\n}\n```\n\n## 总结\n\nHemlock 的文件 I/O API 提供：\n\n- 简单、显式的文件操作\n- 文本和二进制支持\n- 使用 seek/tell 的随机访问\n- 带上下文的清晰错误消息\n- 幂等的关闭操作\n\n请记住：\n- 始终手动关闭文件\n- 使用 try/finally 确保资源安全\n- 选择适当的打开模式\n- 优雅地处理错误\n- 分块处理大文件\n"}, "Advanced Topics -> Profiling": {"id": "advanced-profiling", "content": "# 性能分析\n\nHemlock 包含一个内置的性能分析器，用于 **CPU 时间分析**、**内存跟踪**和**泄漏检测**。分析器帮助识别程序中的性能瓶颈和内存问题。\n\n## 目录\n\n- [概述](#概述)\n- [快速开始](#快速开始)\n- [分析模式](#分析模式)\n- [输出格式](#输出格式)\n- [泄漏检测](#泄漏检测)\n- [理解报告](#理解报告)\n- [火焰图生成](#火焰图生成)\n- [最佳实践](#最佳实践)\n\n---\n\n## 概述\n\n通过 `profile` 子命令访问分析器：\n\n```bash\nhemlock profile [OPTIONS] <FILE>\n```\n\n**主要特性：**\n- **CPU 分析** - 测量每个函数花费的时间（自身时间和总时间）\n- **内存分析** - 跟踪所有分配及其源位置\n- **泄漏检测** - 识别从未释放的内存\n- **多种输出格式** - 文本、JSON 和火焰图兼容的输出\n- **每函数内存统计** - 查看哪些函数分配最多内存\n\n---\n\n## 快速开始\n\n### 分析 CPU 时间（默认）\n\n```bash\nhemlock profile script.hml\n```\n\n### 分析内存分配\n\n```bash\nhemlock profile --memory script.hml\n```\n\n### 检测内存泄漏\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n### 生成火焰图数据\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\nflamegraph.pl profile.folded > profile.svg\n```\n\n---\n\n## 分析模式\n\n### CPU 分析（默认）\n\n测量每个函数花费的时间，区分：\n- **自身时间** - 执行函数自身代码花费的时间\n- **总时间** - 自身时间加上调用的函数花费的时间\n\n```bash\nhemlock profile script.hml\nhemlock profile --cpu script.hml  # 显式指定\n```\n\n**示例输出：**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 1.234ms\nFunctions called: 5 unique\n\n--- Top 5 by Self Time ---\n\nFunction                        Self      Total   Calls\n--------                        ----      -----   -----\nexpensive_calc              0.892ms    0.892ms     100  (72.3%)\nprocess_data                0.234ms    1.126ms      10  (19.0%)\nhelper                      0.067ms    0.067ms     500  (5.4%)\nmain                        0.041ms    1.234ms       1  (3.3%)\n```\n\n---\n\n### 内存分析\n\n跟踪所有内存分配（`alloc`、`buffer`、`talloc`、`realloc`）及其源位置。\n\n```bash\nhemlock profile --memory script.hml\n```\n\n**示例输出：**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 0.543ms\nFunctions called: 3 unique\nTotal allocations: 15 (4.2KB)\n\n--- Top 3 by Self Time ---\n\nFunction                        Self      Total   Calls      Alloc      Count\n--------                        ----      -----   -----      -----      -----\nallocator                   0.312ms    0.312ms      10      3.2KB         10  (57.5%)\nbuffer_ops                  0.156ms    0.156ms       5       1KB          5  (28.7%)\nmain                        0.075ms    0.543ms       1        0B          0  (13.8%)\n\n--- Top 10 Allocation Sites ---\n\nLocation                                      Total    Count\n--------                                      -----    -----\nsrc/data.hml:42                               1.5KB        5\nsrc/data.hml:67                               1.0KB       10\nsrc/main.hml:15                               512B         1\n```\n\n---\n\n### 调用计数模式\n\n最小开销模式，仅计算函数调用（无计时）。\n\n```bash\nhemlock profile --calls script.hml\n```\n\n---\n\n## 输出格式\n\n### 文本（默认）\n\n带表格的人类可读摘要。\n\n```bash\nhemlock profile script.hml\n```\n\n---\n\n### JSON\n\n机器可读格式，用于与其他工具集成。\n\n```bash\nhemlock profile --json script.hml\n```\n\n**示例输出：**\n```json\n{\n  \"total_time_ns\": 1234567,\n  \"function_count\": 5,\n  \"total_alloc_bytes\": 4096,\n  \"total_alloc_count\": 15,\n  \"functions\": [\n    {\n      \"name\": \"expensive_calc\",\n      \"source_file\": \"script.hml\",\n      \"line\": 10,\n      \"self_time_ns\": 892000,\n      \"total_time_ns\": 892000,\n      \"call_count\": 100,\n      \"alloc_bytes\": 0,\n      \"alloc_count\": 0\n    }\n  ],\n  \"alloc_sites\": [\n    {\n      \"source_file\": \"script.hml\",\n      \"line\": 42,\n      \"total_bytes\": 1536,\n      \"alloc_count\": 5,\n      \"current_bytes\": 0\n    }\n  ]\n}\n```\n\n---\n\n### 火焰图\n\n生成与 [flamegraph.pl](https://github.com/brendangregg/FlameGraph) 兼容的折叠栈格式。\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\n\n# 使用 flamegraph.pl 生成 SVG\nflamegraph.pl profile.folded > profile.svg\n```\n\n**折叠输出示例：**\n```\nmain;process_data;expensive_calc 892\nmain;process_data;helper 67\nmain;process_data 234\nmain 41\n```\n\n---\n\n## 泄漏检测\n\n`--leaks` 标志仅显示从未释放的分配，使内存泄漏的识别变得容易。\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n**有泄漏的示例程序：**\n```hemlock\nfn leaky() {\n    let p1 = alloc(100);    // 泄漏 - 从未释放\n    let p2 = alloc(200);    // OK - 下面释放了\n    free(p2);\n}\n\nfn clean() {\n    let b = buffer(64);\n    free(b);                // 正确释放\n}\n\nleaky();\nclean();\n```\n\n**带 --leaks 的输出：**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 0.034ms\nFunctions called: 2 unique\nTotal allocations: 3 (388B)\n\n--- Top 2 by Self Time ---\n\nFunction                        Self      Total   Calls      Alloc      Count\n--------                        ----      -----   -----      -----      -----\nleaky                       0.021ms    0.021ms       1       300B          2  (61.8%)\nclean                       0.013ms    0.013ms       1        88B          1  (38.2%)\n\n--- Memory Leaks (1 site) ---\n\nLocation                                     Leaked      Total    Count\n--------                                     ------      -----    -----\nscript.hml:2                                   100B       100B        1\n```\n\n泄漏报告显示：\n- **Leaked** - 程序退出时当前未释放的字节\n- **Total** - 在此位置曾经分配的总字节\n- **Count** - 在此位置的分配次数\n\n---\n\n## 理解报告\n\n### 函数统计\n\n| 列 | 描述 |\n|------|------|\n| Function | 函数名 |\n| Self | 函数中花费的时间（不包括被调用者） |\n| Total | 包括所有被调用函数的时间 |\n| Calls | 函数被调用的次数 |\n| Alloc | 此函数分配的总字节数 |\n| Count | 此函数的分配次数 |\n| (%) | 占程序总时间的百分比 |\n\n### 分配位置\n\n| 列 | 描述 |\n|------|------|\n| Location | 源文件和行号 |\n| Total | 在此位置分配的总字节数 |\n| Count | 分配次数 |\n| Leaked | 程序退出时仍分配的字节（仅 --leaks） |\n\n### 时间单位\n\n分析器自动选择适当的单位：\n- `ns` - 纳秒（< 1微秒）\n- `us` - 微秒（< 1毫秒）\n- `ms` - 毫秒（< 1秒）\n- `s` - 秒\n\n---\n\n## 命令参考\n\n```\nhemlock profile [OPTIONS] <FILE>\n\nOPTIONS:\n    --cpu           CPU/时间分析（默认）\n    --memory        内存分配分析\n    --calls         仅调用计数（最小开销）\n    --leaks         仅显示未释放的分配（隐含 --memory）\n    --json          以 JSON 格式输出\n    --flamegraph    以火焰图兼容格式输出\n    --top N         显示前 N 条记录（默认：20）\n```\n\n---\n\n## 火焰图生成\n\n火焰图可视化程序花费时间的位置，较宽的条表示花费更多时间。\n\n### 生成火焰图\n\n1. 安装 flamegraph.pl：\n   ```bash\n   git clone https://github.com/brendangregg/FlameGraph\n   ```\n\n2. 分析你的程序：\n   ```bash\n   hemlock profile --flamegraph script.hml > profile.folded\n   ```\n\n3. 生成 SVG：\n   ```bash\n   ./FlameGraph/flamegraph.pl profile.folded > profile.svg\n   ```\n\n4. 在浏览器中打开 `profile.svg` 获得交互式可视化。\n\n### 阅读火焰图\n\n- **X 轴**：总时间的百分比（宽度 = 时间比例）\n- **Y 轴**：调用栈深度（底部 = 入口点，顶部 = 叶函数）\n- **颜色**：随机，仅用于视觉区分\n- **点击**：放大一个函数以查看其被调用者\n\n---\n\n## 最佳实践\n\n### 1. 分析代表性工作负载\n\n使用真实数据和使用模式进行分析。小的测试用例可能无法揭示真正的瓶颈。\n\n```bash\n# 好：使用类似生产的数据进行分析\nhemlock profile --memory process_large_file.hml large_input.txt\n\n# 不太有用：微小的测试用例\nhemlock profile quick_test.hml\n```\n\n### 2. 在开发过程中使用 --leaks\n\n定期运行泄漏检测以尽早发现内存泄漏：\n\n```bash\nhemlock profile --leaks my_program.hml\n```\n\n### 3. 优化前后对比\n\n在优化前后进行分析以测量影响：\n\n```bash\n# 优化前\nhemlock profile --json script.hml > before.json\n\n# 优化后\nhemlock profile --json script.hml > after.json\n\n# 比较结果\n```\n\n### 4. 对大型程序使用 --top\n\n限制输出以关注最重要的函数：\n\n```bash\nhemlock profile --top 10 large_program.hml\n```\n\n### 5. 结合火焰图使用\n\n对于复杂的调用模式，火焰图提供比文本输出更好的可视化：\n\n```bash\nhemlock profile --flamegraph complex_app.hml > app.folded\nflamegraph.pl app.folded > app.svg\n```\n\n---\n\n## 分析器开销\n\n分析器会给程序执行增加一些开销：\n\n| 模式 | 开销 | 用例 |\n|------|------|------|\n| `--calls` | 最小 | 仅计算函数调用 |\n| `--cpu` | 低 | 一般性能分析 |\n| `--memory` | 中等 | 内存分析和泄漏检测 |\n\n为了获得最准确的结果，多次分析并寻找一致的模式。\n\n---\n\n## 另请参阅\n\n- [内存管理](#language-guide-memory) - 指针和缓冲区\n- [内存 API](#reference-memory-api) - alloc、free、buffer 函数\n- [异步/并发](#advanced-async-concurrency) - 分析异步代码\n"}, "Advanced Topics -> Signals": {"id": "advanced-signals", "content": "# Hemlock 信号处理\n\nHemlock 提供 **POSIX 信号处理**，用于管理系统信号如 SIGINT（Ctrl+C）、SIGTERM 和自定义信号。这使得底层进程控制和进程间通信成为可能。\n\n## 目录\n\n- [概述](#概述)\n- [信号 API](#信号-api)\n- [信号常量](#信号常量)\n- [基本信号处理](#基本信号处理)\n- [高级模式](#高级模式)\n- [信号处理器行为](#信号处理器行为)\n- [安全考虑](#安全考虑)\n- [常见用例](#常见用例)\n- [完整示例](#完整示例)\n\n## 概述\n\n信号处理允许程序：\n- 响应用户中断（Ctrl+C、Ctrl+Z）\n- 实现优雅关闭\n- 处理终止请求\n- 使用自定义信号进行进程间通信\n- 创建警报/定时器机制\n\n**重要：** 按照 Hemlock 的哲学，信号处理**本质上是不安全的**。处理器可以在任何时候被调用，中断正常执行。用户负责适当的同步。\n\n## 信号 API\n\n### signal(signum, handler_fn)\n\n注册信号处理函数。\n\n**参数：**\n- `signum` (i32) - 信号编号（如 SIGINT、SIGTERM 常量）\n- `handler_fn` (function 或 null) - 接收到信号时调用的函数，或 `null` 重置为默认\n\n**返回：** 之前的处理函数（如果没有则返回 `null`）\n\n**示例：**\n```hemlock\nfn my_handler(sig) {\n    print(\"Caught signal: \" + typeof(sig));\n}\n\nlet old_handler = signal(SIGINT, my_handler);\n```\n\n**重置为默认：**\n```hemlock\nsignal(SIGINT, null);  // 将 SIGINT 重置为默认行为\n```\n\n### raise(signum)\n\n向当前进程发送信号。\n\n**参数：**\n- `signum` (i32) - 要发送的信号编号\n\n**返回：** `null`\n\n**示例：**\n```hemlock\nraise(SIGUSR1);  // 触发 SIGUSR1 处理器\n```\n\n## 信号常量\n\nHemlock 提供标准 POSIX 信号常量作为 i32 值。\n\n### 中断和终止\n\n| 常量 | 值 | 描述 | 常见触发 |\n|------|------|------|----------|\n| `SIGINT` | 2 | 键盘中断 | Ctrl+C |\n| `SIGTERM` | 15 | 终止请求 | `kill` 命令 |\n| `SIGQUIT` | 3 | 键盘退出 | Ctrl+\\ |\n| `SIGHUP` | 1 | 检测到挂断 | 终端关闭 |\n| `SIGABRT` | 6 | 中止信号 | `abort()` 函数 |\n\n**示例：**\n```hemlock\nsignal(SIGINT, handle_interrupt);   // Ctrl+C\nsignal(SIGTERM, handle_terminate);  // kill 命令\nsignal(SIGHUP, handle_hangup);      // 终端关闭\n```\n\n### 用户定义信号\n\n| 常量 | 值 | 描述 | 用例 |\n|------|------|------|------|\n| `SIGUSR1` | 10 | 用户定义信号 1 | 自定义 IPC |\n| `SIGUSR2` | 12 | 用户定义信号 2 | 自定义 IPC |\n\n**示例：**\n```hemlock\n// 用于自定义通信\nsignal(SIGUSR1, reload_config);\nsignal(SIGUSR2, rotate_logs);\n```\n\n### 进程控制\n\n| 常量 | 值 | 描述 | 说明 |\n|------|------|------|------|\n| `SIGALRM` | 14 | 警报时钟定时器 | `alarm()` 后 |\n| `SIGCHLD` | 17 | 子进程状态改变 | 进程管理 |\n| `SIGCONT` | 18 | 如果停止则继续 | 在 SIGSTOP 后恢复 |\n| `SIGSTOP` | 19 | 停止进程 | **无法捕获** |\n| `SIGTSTP` | 20 | 终端停止 | Ctrl+Z |\n\n**示例：**\n```hemlock\nsignal(SIGALRM, handle_timeout);\nsignal(SIGCHLD, handle_child_exit);\n```\n\n### I/O 信号\n\n| 常量 | 值 | 描述 | 何时发送 |\n|------|------|------|----------|\n| `SIGPIPE` | 13 | 管道断开 | 写入已关闭的管道 |\n| `SIGTTIN` | 21 | 后台从终端读取 | 后台进程读取 TTY |\n| `SIGTTOU` | 22 | 后台写入终端 | 后台进程写入 TTY |\n\n**示例：**\n```hemlock\nsignal(SIGPIPE, handle_broken_pipe);\n```\n\n## 基本信号处理\n\n### 捕获 Ctrl+C\n\n```hemlock\nlet interrupted = false;\n\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n    interrupted = true;\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// 程序继续运行...\n// 用户按 Ctrl+C -> 调用 handle_interrupt()\n\nwhile (!interrupted) {\n    // 做工作...\n}\n\nprint(\"Exiting due to interrupt\");\n```\n\n### 处理函数签名\n\n信号处理器接收一个参数：信号编号 (i32)\n\n```hemlock\nfn my_handler(signum) {\n    print(\"Received signal: \" + typeof(signum));\n    // signum 包含信号编号（如 SIGINT 为 2）\n\n    if (signum == SIGINT) {\n        print(\"This is SIGINT\");\n    }\n}\n\nsignal(SIGINT, my_handler);\nsignal(SIGTERM, my_handler);  // 多个信号使用同一处理器\n```\n\n### 多个信号处理器\n\n不同信号使用不同处理器：\n\n```hemlock\nfn handle_int(sig) {\n    print(\"SIGINT received\");\n}\n\nfn handle_term(sig) {\n    print(\"SIGTERM received\");\n}\n\nfn handle_usr1(sig) {\n    print(\"SIGUSR1 received\");\n}\n\nsignal(SIGINT, handle_int);\nsignal(SIGTERM, handle_term);\nsignal(SIGUSR1, handle_usr1);\n```\n\n### 重置为默认行为\n\n传递 `null` 作为处理器以重置为默认行为：\n\n```hemlock\n// 注册自定义处理器\nsignal(SIGINT, my_handler);\n\n// 稍后，重置为默认（SIGINT 时终止）\nsignal(SIGINT, null);\n```\n\n### 手动触发信号\n\n向自己的进程发送信号：\n\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\n// 手动触发处理器\nraise(SIGUSR1);\nraise(SIGUSR1);\n\nprint(count);  // 2\n```\n\n## 高级模式\n\n### 优雅关闭模式\n\n终止时清理的常见模式：\n\n```hemlock\nlet should_exit = false;\n\nfn handle_shutdown(sig) {\n    print(\"Shutting down gracefully...\");\n    should_exit = true;\n}\n\nsignal(SIGINT, handle_shutdown);\nsignal(SIGTERM, handle_shutdown);\n\n// 主循环\nwhile (!should_exit) {\n    // 做工作...\n    // 定期检查 should_exit 标志\n}\n\nprint(\"Cleanup complete\");\n```\n\n### 信号计数器\n\n跟踪接收的信号数量：\n\n```hemlock\nlet signal_count = 0;\n\nfn count_signals(sig) {\n    signal_count = signal_count + 1;\n    print(\"Received \" + typeof(signal_count) + \" signals\");\n}\n\nsignal(SIGUSR1, count_signals);\n\n// 稍后...\nprint(\"Total signals: \" + typeof(signal_count));\n```\n\n### 信号重新加载配置\n\n```hemlock\nlet config = load_config();\n\nfn reload_config(sig) {\n    print(\"Reloading configuration...\");\n    config = load_config();\n    print(\"Configuration reloaded\");\n}\n\nsignal(SIGHUP, reload_config);  // 收到 SIGHUP 时重新加载\n\n// 从 shell 发送 SIGHUP 到进程以重新加载配置\n// kill -HUP <pid>\n```\n\n### 使用 SIGALRM 的超时\n\n```hemlock\nlet timed_out = false;\n\nfn handle_alarm(sig) {\n    print(\"Timeout!\");\n    timed_out = true;\n}\n\nsignal(SIGALRM, handle_alarm);\n\n// 设置警报（Hemlock 中尚未实现，仅示例）\n// alarm(5);  // 5 秒超时\n\nwhile (!timed_out) {\n    // 带超时的工作\n}\n```\n\n### 基于信号的状态机\n\n```hemlock\nlet state = 0;\n\nfn next_state(sig) {\n    state = (state + 1) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nfn prev_state(sig) {\n    state = (state - 1 + 3) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nsignal(SIGUSR1, next_state);  // 前进状态\nsignal(SIGUSR2, prev_state);  // 后退状态\n\n// 控制状态机：\n// kill -USR1 <pid>  # 下一状态\n// kill -USR2 <pid>  # 上一状态\n```\n\n## 信号处理器行为\n\n### 重要说明\n\n**处理器执行：**\n- 处理器在接收到信号时**同步**调用\n- 处理器在当前进程上下文中执行\n- 信号处理器共享定义它们的函数的闭包环境\n- 处理器可以访问和修改外部作用域变量（如全局变量或捕获的变量）\n\n**最佳实践：**\n- 保持处理器简单快速 - 避免长时间运行的操作\n- 设置标志而不是执行复杂逻辑\n- 避免调用可能获取锁的函数\n- 注意处理器可以中断任何操作\n\n### 哪些信号可以捕获\n\n**可以捕获和处理：**\n- SIGINT、SIGTERM、SIGUSR1、SIGUSR2、SIGHUP、SIGQUIT\n- SIGALRM、SIGCHLD、SIGCONT、SIGTSTP\n- SIGPIPE、SIGTTIN、SIGTTOU\n- SIGABRT（但处理器返回后程序将中止）\n\n**无法捕获：**\n- `SIGKILL` (9) - 始终终止进程\n- `SIGSTOP` (19) - 始终停止进程\n\n**系统相关：**\n- 某些信号的默认行为可能因系统而异\n- 查看您平台的信号文档了解详情\n\n### 处理器限制\n\n```hemlock\nfn complex_handler(sig) {\n    // 在信号处理器中避免这些：\n\n    // ❌ 长时间运行的操作\n    // process_large_file();\n\n    // ❌ 阻塞 I/O\n    // let f = open(\"log.txt\", \"a\");\n    // f.write(\"Signal received\\n\");\n\n    // ❌ 复杂的状态更改\n    // rebuild_entire_data_structure();\n\n    // ✅ 简单的标志设置是安全的\n    let should_stop = true;\n\n    // ✅ 简单的计数器更新通常是安全的\n    let signal_count = signal_count + 1;\n}\n```\n\n## 安全考虑\n\n按照 Hemlock 的哲学，信号处理**本质上是不安全的**。\n\n### 竞争条件\n\n处理器可以在任何时候被调用，中断正常执行：\n\n```hemlock\nlet counter = 0;\n\nfn increment(sig) {\n    counter = counter + 1;  // 如果在 counter 更新期间调用会有竞争条件\n}\n\nsignal(SIGUSR1, increment);\n\n// 主代码也修改 counter\ncounter = counter + 1;  // 可能被信号处理器中断\n```\n\n**问题：** 如果信号在主代码更新 `counter` 时到达，结果是不可预测的。\n\n### 异步信号安全\n\nHemlock **不**保证异步信号安全：\n- 处理器可以调用任何 Hemlock 代码（不像 C 的受限异步信号安全函数）\n- 这提供了灵活性但需要用户谨慎\n- 如果处理器修改共享状态，可能出现竞争条件\n\n### 安全信号处理的最佳实践\n\n**1. 使用原子标志**\n\n简单的布尔赋值通常是安全的：\n\n```hemlock\nlet should_exit = false;\n\nfn handler(sig) {\n    should_exit = true;  // 简单赋值是安全的\n}\n\nsignal(SIGINT, handler);\n\nwhile (!should_exit) {\n    // 工作...\n}\n```\n\n**2. 最小化共享状态**\n\n```hemlock\nlet interrupt_count = 0;\n\nfn handler(sig) {\n    // 只修改这一个变量\n    interrupt_count = interrupt_count + 1;\n}\n```\n\n**3. 延迟复杂操作**\n\n```hemlock\nlet pending_reload = false;\n\nfn signal_reload(sig) {\n    pending_reload = true;  // 只设置标志\n}\n\nsignal(SIGHUP, signal_reload);\n\n// 在主循环中：\nwhile (true) {\n    if (pending_reload) {\n        reload_config();  // 在这里执行复杂工作\n        pending_reload = false;\n    }\n\n    // 正常工作...\n}\n```\n\n**4. 避免重入问题**\n\n```hemlock\nlet in_critical_section = false;\nlet data = [];\n\nfn careful_handler(sig) {\n    if (in_critical_section) {\n        // 主代码使用数据时不要修改它\n        return;\n    }\n    // 可以安全继续\n}\n```\n\n## 常见用例\n\n### 1. 优雅的服务器关闭\n\n```hemlock\nlet running = true;\n\nfn shutdown(sig) {\n    print(\"Shutdown signal received\");\n    running = false;\n}\n\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// 服务器主循环\nwhile (running) {\n    handle_client_request();\n}\n\ncleanup_resources();\nprint(\"Server stopped\");\n```\n\n### 2. 配置重新加载（无需重启）\n\n```hemlock\nlet config = load_config(\"app.conf\");\nlet reload_needed = false;\n\nfn trigger_reload(sig) {\n    reload_needed = true;\n}\n\nsignal(SIGHUP, trigger_reload);\n\nwhile (true) {\n    if (reload_needed) {\n        print(\"Reloading configuration...\");\n        config = load_config(\"app.conf\");\n        reload_needed = false;\n    }\n\n    // 使用配置...\n}\n```\n\n### 3. 日志轮转\n\n```hemlock\nlet log_file = open(\"app.log\", \"a\");\nlet rotate_needed = false;\n\nfn trigger_rotate(sig) {\n    rotate_needed = true;\n}\n\nsignal(SIGUSR1, trigger_rotate);\n\nwhile (true) {\n    if (rotate_needed) {\n        log_file.close();\n        // 重命名旧日志，打开新的\n        exec(\"mv app.log app.log.old\");\n        log_file = open(\"app.log\", \"a\");\n        rotate_needed = false;\n    }\n\n    // 正常日志记录...\n    log_file.write(\"Log entry\\n\");\n}\n```\n\n### 4. 状态报告\n\n```hemlock\nlet requests_handled = 0;\n\nfn report_status(sig) {\n    print(\"Status: \" + typeof(requests_handled) + \" requests handled\");\n}\n\nsignal(SIGUSR1, report_status);\n\nwhile (true) {\n    handle_request();\n    requests_handled = requests_handled + 1;\n}\n\n// 从 shell：kill -USR1 <pid>\n```\n\n### 5. 调试模式切换\n\n```hemlock\nlet debug_mode = false;\n\nfn toggle_debug(sig) {\n    debug_mode = !debug_mode;\n    if (debug_mode) {\n        print(\"Debug mode: ON\");\n    } else {\n        print(\"Debug mode: OFF\");\n    }\n}\n\nsignal(SIGUSR2, toggle_debug);\n\n// 从 shell：kill -USR2 <pid> 切换\n```\n\n## 完整示例\n\n### 示例 1：带清理的中断处理器\n\n```hemlock\nlet running = true;\nlet signal_count = 0;\n\nfn handle_signal(signum) {\n    signal_count = signal_count + 1;\n\n    if (signum == SIGINT) {\n        print(\"Interrupt detected (Ctrl+C)\");\n        running = false;\n    }\n\n    if (signum == SIGUSR1) {\n        print(\"User signal 1 received\");\n    }\n}\n\n// 注册处理器\nsignal(SIGINT, handle_signal);\nsignal(SIGUSR1, handle_signal);\n\n// 模拟一些工作\nlet i = 0;\nwhile (running && i < 100) {\n    print(\"Working... \" + typeof(i));\n\n    // 每 10 次迭代触发 SIGUSR1\n    if (i == 10 || i == 20) {\n        raise(SIGUSR1);\n    }\n\n    i = i + 1;\n}\n\nprint(\"Total signals received: \" + typeof(signal_count));\n```\n\n### 示例 2：多信号状态机\n\n```hemlock\nlet state = \"idle\";\nlet request_count = 0;\n\nfn start_processing(sig) {\n    state = \"processing\";\n    print(\"State: \" + state);\n}\n\nfn stop_processing(sig) {\n    state = \"idle\";\n    print(\"State: \" + state);\n}\n\nfn report_stats(sig) {\n    print(\"State: \" + state);\n    print(\"Requests: \" + typeof(request_count));\n}\n\nsignal(SIGUSR1, start_processing);\nsignal(SIGUSR2, stop_processing);\nsignal(SIGHUP, report_stats);\n\nwhile (true) {\n    if (state == \"processing\") {\n        // 做工作\n        request_count = request_count + 1;\n    }\n\n    // 每次迭代检查...\n}\n```\n\n### 示例 3：工作池控制器\n\n```hemlock\nlet worker_count = 4;\nlet should_exit = false;\n\nfn increase_workers(sig) {\n    worker_count = worker_count + 1;\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn decrease_workers(sig) {\n    if (worker_count > 1) {\n        worker_count = worker_count - 1;\n    }\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn shutdown(sig) {\n    print(\"Shutting down...\");\n    should_exit = true;\n}\n\nsignal(SIGUSR1, increase_workers);\nsignal(SIGUSR2, decrease_workers);\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// 主循环根据 worker_count 调整工作池\nwhile (!should_exit) {\n    // 根据 worker_count 管理工作者\n    // ...\n}\n```\n\n## 调试信号处理器\n\n### 添加诊断打印\n\n```hemlock\nfn debug_handler(sig) {\n    print(\"Handler called for signal: \" + typeof(sig));\n    print(\"Stack: (not yet available)\");\n\n    // 你的处理器逻辑...\n}\n\nsignal(SIGINT, debug_handler);\n```\n\n### 计数信号调用\n\n```hemlock\nlet handler_calls = 0;\n\nfn counting_handler(sig) {\n    handler_calls = handler_calls + 1;\n    print(\"Handler call #\" + typeof(handler_calls));\n\n    // 你的处理器逻辑...\n}\n```\n\n### 使用 raise() 测试\n\n```hemlock\nfn test_handler(sig) {\n    print(\"Test signal received: \" + typeof(sig));\n}\n\nsignal(SIGUSR1, test_handler);\n\n// 通过手动触发测试\nraise(SIGUSR1);\nprint(\"Handler should have been called\");\n```\n\n## 总结\n\nHemlock 的信号处理提供：\n\n- 用于底层进程控制的 POSIX 信号处理\n- 15 个标准信号常量\n- 简单的 signal() 和 raise() API\n- 灵活的处理函数，支持闭包\n- 多个信号可以共享处理器\n\n请记住：\n- 信号处理本质上是不安全的 - 谨慎使用\n- 保持处理器简单快速\n- 使用标志进行状态更改，而不是复杂操作\n- 处理器可以在任何时候中断执行\n- 无法捕获 SIGKILL 或 SIGSTOP\n- 使用 raise() 彻底测试处理器\n\n常见模式：\n- 优雅关闭（SIGINT、SIGTERM）\n- 配置重新加载（SIGHUP）\n- 日志轮转（SIGUSR1）\n- 状态报告（SIGUSR1/SIGUSR2）\n- 调试模式切换（SIGUSR2）\n"}, "API Reference -> Array API": {"id": "reference-array-api", "content": "# Array API Reference\n\nComplete reference for Hemlock's array type and all 18 array methods.\n\n---\n\n## Overview\n\nArrays in Hemlock are **dynamic, heap-allocated** sequences that can hold mixed types. They provide comprehensive methods for data manipulation and processing.\n\n**Key Features:**\n- Dynamic sizing (automatic growth)\n- Zero-indexed\n- Mixed types allowed\n- 18 built-in methods\n- Heap-allocated with capacity tracking\n\n---\n\n## Array Type\n\n**Type:** `array`\n\n**Properties:**\n- `.length` - Number of elements (i32)\n\n**Literal Syntax:** Square brackets `[elem1, elem2, ...]`\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);     // 5\n\n// Mixed types\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.length);   // 4\n\n// Empty array\nlet empty = [];\nprint(empty.length);   // 0\n```\n\n---\n\n## Indexing\n\nArrays support zero-based indexing using `[]`:\n\n**Read Access:**\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);         // 10\nprint(arr[1]);         // 20\nprint(arr[2]);         // 30\n```\n\n**Write Access:**\n```hemlock\nlet arr = [10, 20, 30];\narr[0] = 99;\narr[1] = 88;\nprint(arr);            // [99, 88, 30]\n```\n\n**Note:** Direct indexing has no bounds checking. Use methods for safety.\n\n---\n\n## Array Properties\n\n### .length\n\nGet the number of elements in the array.\n\n**Type:** `i32`\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr.length);     // 3\n\nlet empty = [];\nprint(empty.length);   // 0\n\n// Length changes dynamically\narr.push(4);\nprint(arr.length);     // 4\n\narr.pop();\nprint(arr.length);     // 3\n```\n\n---\n\n## Array Methods\n\n### Stack Operations\n\n#### push\n\nAdd element to end of array.\n\n**Signature:**\n```hemlock\narray.push(value: any): null\n```\n\n**Parameters:**\n- `value` - Element to add\n\n**Returns:** `null`\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\narr.push(\"hello\");     // [1, 2, 3, 4, 5, \"hello\"]\n```\n\n---\n\n#### pop\n\nRemove and return last element.\n\n**Signature:**\n```hemlock\narray.pop(): any\n```\n\n**Returns:** Last element (removed from array)\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3];\nlet last = arr.pop();  // 3\nprint(arr);            // [1, 2]\n\nlet last2 = arr.pop(); // 2\nprint(arr);            // [1]\n```\n\n**Error:** Runtime error if array is empty.\n\n---\n\n### Queue Operations\n\n#### shift\n\nRemove and return first element.\n\n**Signature:**\n```hemlock\narray.shift(): any\n```\n\n**Returns:** First element (removed from array)\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();  // 1\nprint(arr);               // [2, 3]\n\nlet first2 = arr.shift(); // 2\nprint(arr);               // [3]\n```\n\n**Error:** Runtime error if array is empty.\n\n---\n\n#### unshift\n\nAdd element to beginning of array.\n\n**Signature:**\n```hemlock\narray.unshift(value: any): null\n```\n\n**Parameters:**\n- `value` - Element to add\n\n**Returns:** `null`\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);        // [1, 2, 3]\narr.unshift(0);        // [0, 1, 2, 3]\n```\n\n---\n\n### Insertion & Removal\n\n#### insert\n\nInsert element at specific index.\n\n**Signature:**\n```hemlock\narray.insert(index: i32, value: any): null\n```\n\n**Parameters:**\n- `index` - Position to insert at (0-based)\n- `value` - Element to insert\n\n**Returns:** `null`\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // [1, 2, 3, 4, 5]\n\nlet arr2 = [1, 3];\narr2.insert(1, 2);     // [1, 2, 3]\n\n// Insert at end\narr2.insert(arr2.length, 4);  // [1, 2, 3, 4]\n```\n\n**Behavior:** Shifts elements at and after index to the right.\n\n---\n\n#### remove\n\nRemove and return element at index.\n\n**Signature:**\n```hemlock\narray.remove(index: i32): any\n```\n\n**Parameters:**\n- `index` - Position to remove from (0-based)\n\n**Returns:** Removed element\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(0);  // 1\nprint(arr);                   // [2, 3, 4, 5]\n\nlet removed2 = arr.remove(2); // 4\nprint(arr);                   // [2, 3, 5]\n```\n\n**Behavior:** Shifts elements after index to the left.\n\n**Error:** Runtime error if index out of bounds.\n\n---\n\n### Search & Find\n\n#### find\n\nFind first occurrence of value.\n\n**Signature:**\n```hemlock\narray.find(value: any): i32\n```\n\n**Parameters:**\n- `value` - Value to search for\n\n**Returns:** Index of first occurrence, or `-1` if not found\n\n**Examples:**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2\nlet idx2 = arr.find(99);     // -1 (not found)\n\n// Find first duplicate\nlet arr2 = [1, 2, 3, 2, 4];\nlet idx3 = arr2.find(2);     // 1 (first occurrence)\n```\n\n**Comparison:** Uses value equality for primitives and strings.\n\n---\n\n#### contains\n\nCheck if array contains value.\n\n**Signature:**\n```hemlock\narray.contains(value: any): bool\n```\n\n**Parameters:**\n- `value` - Value to search for\n\n**Returns:** `true` if found, `false` otherwise\n\n**Examples:**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n\n// Works with strings\nlet words = [\"hello\", \"world\"];\nlet has3 = words.contains(\"hello\");  // true\n```\n\n---\n\n### Slicing & Extraction\n\n#### slice\n\nExtract subarray by range (end exclusive).\n\n**Signature:**\n```hemlock\narray.slice(start: i32, end: i32): array\n```\n\n**Parameters:**\n- `start` - Starting index (0-based, inclusive)\n- `end` - Ending index (exclusive)\n\n**Returns:** New array with elements from [start, end)\n\n**Mutates:** No (returns new array)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4]\nlet first_three = arr.slice(0, 3);  // [1, 2, 3]\nlet last_two = arr.slice(3, 5);     // [4, 5]\n\n// Empty slice\nlet empty = arr.slice(2, 2); // []\n```\n\n---\n\n#### first\n\nGet first element without removing.\n\n**Signature:**\n```hemlock\narray.first(): any\n```\n\n**Returns:** First element\n\n**Mutates:** No\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1\nprint(arr);                  // [1, 2, 3] (unchanged)\n```\n\n**Error:** Runtime error if array is empty.\n\n---\n\n#### last\n\nGet last element without removing.\n\n**Signature:**\n```hemlock\narray.last(): any\n```\n\n**Returns:** Last element\n\n**Mutates:** No\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3\nprint(arr);                  // [1, 2, 3] (unchanged)\n```\n\n**Error:** Runtime error if array is empty.\n\n---\n\n### Array Manipulation\n\n#### reverse\n\nReverse array in place.\n\n**Signature:**\n```hemlock\narray.reverse(): null\n```\n\n**Returns:** `null`\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\nprint(arr);                  // [5, 4, 3, 2, 1]\n\nlet words = [\"hello\", \"world\"];\nwords.reverse();             // [\"world\", \"hello\"]\n```\n\n---\n\n#### clear\n\nRemove all elements from array.\n\n**Signature:**\n```hemlock\narray.clear(): null\n```\n\n**Returns:** `null`\n\n**Mutates:** Yes (modifies array in place)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();\nprint(arr);                  // []\nprint(arr.length);           // 0\n```\n\n---\n\n### Array Combination\n\n#### concat\n\nConcatenate with another array.\n\n**Signature:**\n```hemlock\narray.concat(other: array): array\n```\n\n**Parameters:**\n- `other` - Array to concatenate\n\n**Returns:** New array with elements from both arrays\n\n**Mutates:** No (returns new array)\n\n**Examples:**\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]\nprint(a);                    // [1, 2, 3] (unchanged)\nprint(b);                    // [4, 5, 6] (unchanged)\n\n// Chain concatenations\nlet c = [7, 8];\nlet all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n---\n\n### Functional Operations\n\n#### map\n\nTransform each element using a callback function.\n\n**Signature:**\n```hemlock\narray.map(callback: fn): array\n```\n\n**Parameters:**\n- `callback` - Function that takes an element and returns transformed value\n\n**Returns:** New array with transformed elements\n\n**Mutates:** No (returns new array)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet doubled = arr.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\nlet names = [\"alice\", \"bob\"];\nlet upper = names.map(fn(s) { return s.to_upper(); });\nprint(upper);  // [\"ALICE\", \"BOB\"]\n```\n\n---\n\n#### filter\n\nSelect elements that match a predicate.\n\n**Signature:**\n```hemlock\narray.filter(predicate: fn): array\n```\n\n**Parameters:**\n- `predicate` - Function that takes an element and returns bool\n\n**Returns:** New array with elements where predicate returned true\n\n**Mutates:** No (returns new array)\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6];\nlet evens = arr.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4, 6]\n\nlet words = [\"hello\", \"hi\", \"hey\", \"goodbye\"];\nlet short = words.filter(fn(s) { return s.length < 4; });\nprint(short);  // [\"hi\", \"hey\"]\n```\n\n---\n\n#### reduce\n\nReduce array to single value using accumulator.\n\n**Signature:**\n```hemlock\narray.reduce(callback: fn, initial: any): any\n```\n\n**Parameters:**\n- `callback` - Function that takes (accumulator, element) and returns new accumulator\n- `initial` - Starting value for the accumulator\n\n**Returns:** Final accumulated value\n\n**Mutates:** No\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sum = arr.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\nlet product = arr.reduce(fn(acc, x) { return acc * x; }, 1);\nprint(product);  // 120\n\n// Find max value\nlet max = arr.reduce(fn(acc, x) {\n    if (x > acc) { return x; }\n    return acc;\n}, arr[0]);\nprint(max);  // 5\n```\n\n---\n\n### String Conversion\n\n#### join\n\nJoin elements into string with delimiter.\n\n**Signature:**\n```hemlock\narray.join(delimiter: string): string\n```\n\n**Parameters:**\n- `delimiter` - String to place between elements\n\n**Returns:** String with all elements joined\n\n**Examples:**\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// Works with mixed types\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n\n// Empty delimiter\nlet arr = [\"a\", \"b\", \"c\"];\nlet s = arr.join(\"\");          // \"abc\"\n```\n\n**Behavior:** Automatically converts all elements to strings.\n\n---\n\n## Method Chaining\n\nArray methods can be chained for concise operations:\n\n**Examples:**\n```hemlock\n// Chain slice and join\nlet result = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\n// Chain concat and slice\nlet combined = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);    // [3, 4, 5]\n\n// Complex chaining\nlet words = [\"hello\", \"world\", \"foo\", \"bar\"];\nlet result2 = words\n    .slice(0, 3)\n    .concat([\"baz\"])\n    .join(\"-\");      // \"hello-world-foo-baz\"\n```\n\n---\n\n## Complete Method Summary\n\n### Mutating Methods\n\nMethods that modify the array in place:\n\n| Method     | Signature                  | Returns   | Description                    |\n|------------|----------------------------|-----------|--------------------------------|\n| `push`     | `(value: any)`             | `null`    | Add to end                     |\n| `pop`      | `()`                       | `any`     | Remove from end                |\n| `shift`    | `()`                       | `any`     | Remove from start              |\n| `unshift`  | `(value: any)`             | `null`    | Add to start                   |\n| `insert`   | `(index: i32, value: any)` | `null`    | Insert at index                |\n| `remove`   | `(index: i32)`             | `any`     | Remove at index                |\n| `reverse`  | `()`                       | `null`    | Reverse in place               |\n| `clear`    | `()`                       | `null`    | Remove all elements            |\n\n### Non-Mutating Methods\n\nMethods that return new values without modifying the original:\n\n| Method     | Signature                  | Returns   | Description                    |\n|------------|----------------------------|-----------|--------------------------------|\n| `find`     | `(value: any)`             | `i32`     | Find first occurrence          |\n| `contains` | `(value: any)`             | `bool`    | Check if contains value        |\n| `slice`    | `(start: i32, end: i32)`   | `array`   | Extract subarray               |\n| `first`    | `()`                       | `any`     | Get first element              |\n| `last`     | `()`                       | `any`     | Get last element               |\n| `concat`   | `(other: array)`           | `array`   | Concatenate arrays             |\n| `join`     | `(delimiter: string)`      | `string`  | Join elements into string      |\n| `map`      | `(callback: fn)`           | `array`   | Transform each element         |\n| `filter`   | `(predicate: fn)`          | `array`   | Select matching elements       |\n| `reduce`   | `(callback: fn, initial: any)` | `any` | Reduce to single value         |\n\n---\n\n## Usage Patterns\n\n### Stack Usage\n\n```hemlock\nlet stack = [];\n\n// Push elements\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Pop elements\nwhile (stack.length > 0) {\n    let item = stack.pop();\n    print(item);  // 3, 2, 1\n}\n```\n\n### Queue Usage\n\n```hemlock\nlet queue = [];\n\n// Enqueue\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// Dequeue\nwhile (queue.length > 0) {\n    let item = queue.shift();\n    print(item);  // 1, 2, 3\n}\n```\n\n### Array Transformation\n\n```hemlock\n// Filter (manual)\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = [];\nlet i = 0;\nwhile (i < numbers.length) {\n    if (numbers[i] % 2 == 0) {\n        evens.push(numbers[i]);\n    }\n    i = i + 1;\n}\n\n// Map (manual)\nlet numbers2 = [1, 2, 3, 4, 5];\nlet doubled = [];\nlet j = 0;\nwhile (j < numbers2.length) {\n    doubled.push(numbers2[j] * 2);\n    j = j + 1;\n}\n```\n\n### Building Arrays\n\n```hemlock\nlet arr = [];\n\n// Build array with loop\nlet i = 0;\nwhile (i < 10) {\n    arr.push(i * 10);\n    i = i + 1;\n}\n\nprint(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n```\n\n---\n\n## Implementation Details\n\n**Capacity Management:**\n- Arrays automatically grow when needed\n- Capacity doubles when exceeded\n- No manual capacity control\n\n**Value Comparison:**\n- `find()` and `contains()` use value equality\n- Works correctly for primitives and strings\n- Objects/arrays compared by reference\n\n**Memory:**\n- Heap-allocated\n- No automatic freeing (manual memory management)\n- No bounds checking on direct index access\n\n---\n\n## See Also\n\n- [Type System](#reference-type-system) - Array type details\n- [String API](#reference-string-api) - String join() results\n- [Operators](#reference-operators) - Array indexing operator\n"}, "API Reference -> Builtins": {"id": "reference-builtins", "content": "# Built-in Functions Reference\n\nComplete reference for all built-in functions and constants in Hemlock.\n\n---\n\n## Overview\n\nHemlock provides a set of built-in functions for I/O, type introspection, memory management, concurrency, and system interaction. All built-ins are available globally without imports.\n\n---\n\n## I/O Functions\n\n### print\n\nPrint values to stdout with newline.\n\n**Signature:**\n```hemlock\nprint(...values): null\n```\n\n**Parameters:**\n- `...values` - Any number of values to print\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nprint(\"Hello, World!\");\nprint(42);\nprint(3.14);\nprint(true);\nprint([1, 2, 3]);\nprint({ x: 10, y: 20 });\n\n// Multiple values\nprint(\"x =\", 10, \"y =\", 20);\n```\n\n**Behavior:**\n- Converts all values to strings\n- Separates multiple values with spaces\n- Adds newline at end\n- Flushes stdout\n\n---\n\n### read_line\n\nRead a line of text from stdin (user input).\n\n**Signature:**\n```hemlock\nread_line(): string | null\n```\n\n**Parameters:** None\n\n**Returns:**\n- `string` - The line read from stdin (newline stripped)\n- `null` - On EOF (end of file/input)\n\n**Examples:**\n```hemlock\n// Simple prompt\nprint(\"What is your name?\");\nlet name = read_line();\nprint(\"Hello, \" + name + \"!\");\n\n// Reading numbers (requires manual parsing)\nprint(\"Enter a number:\");\nlet input = read_line();\nlet num = parse_int(input);  // See below for parse_int\nprint(\"Double:\", num * 2);\n\n// Handle EOF\nlet line = read_line();\nif (line == null) {\n    print(\"End of input\");\n}\n\n// Read multiple lines\nprint(\"Enter lines (Ctrl+D to stop):\");\nwhile (true) {\n    let line = read_line();\n    if (line == null) {\n        break;\n    }\n    print(\"You said:\", line);\n}\n```\n\n**Behavior:**\n- Blocks until user presses Enter\n- Strips trailing newline (`\\n`) and carriage return (`\\r`)\n- Returns `null` on EOF (Ctrl+D on Unix, Ctrl+Z on Windows)\n- Reads from stdin only (not from files)\n\n**Parsing User Input:**\n\nSince `read_line()` always returns a string, you need to parse numeric input manually:\n\n```hemlock\n// Simple integer parser\nfn parse_int(s: string): i32 {\n    let result: i32 = 0;\n    let negative = false;\n    let i = 0;\n\n    if (s.length > 0 && s.char_at(0) == '-') {\n        negative = true;\n        i = 1;\n    }\n\n    while (i < s.length) {\n        let c = s.char_at(i);\n        let code: i32 = c;\n        if (code >= 48 && code <= 57) {\n            result = result * 10 + (code - 48);\n        } else {\n            break;\n        }\n        i = i + 1;\n    }\n\n    if (negative) {\n        return -result;\n    }\n    return result;\n}\n\n// Usage\nprint(\"Enter your age:\");\nlet age = parse_int(read_line());\nprint(\"In 10 years you'll be\", age + 10);\n```\n\n**See Also:** [File API](#reference-file-api) for reading from files\n\n---\n\n### eprint\n\nPrint a value to stderr with newline.\n\n**Signature:**\n```hemlock\neprint(value: any): null\n```\n\n**Parameters:**\n- `value` - Single value to print to stderr\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\neprint(\"Error: file not found\");\neprint(404);\neprint(\"Warning: \" + message);\n\n// Typical error handling pattern\nfn load_config(path: string) {\n    if (!exists(path)) {\n        eprint(\"Error: config file not found: \" + path);\n        return null;\n    }\n    // ...\n}\n```\n\n**Behavior:**\n- Prints to stderr (standard error stream)\n- Adds newline at end\n- Only accepts one argument (unlike `print`)\n- Useful for error messages that shouldn't mix with normal output\n\n**Difference from print:**\n- `print()` → stdout (normal output, can be redirected with `>`)\n- `eprint()` → stderr (error output, can be redirected with `2>`)\n\n```bash\n# Shell example: separate stdout and stderr\n./hemlock script.hml > output.txt 2> errors.txt\n```\n\n---\n\n## Type Introspection\n\n### typeof\n\nGet the type name of a value.\n\n**Signature:**\n```hemlock\ntypeof(value: any): string\n```\n\n**Parameters:**\n- `value` - Any value\n\n**Returns:** Type name as string\n\n**Examples:**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof(null));            // \"null\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\n// Typed objects\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n\n// Other types\nprint(typeof(alloc(10)));       // \"ptr\"\nprint(typeof(buffer(10)));      // \"buffer\"\nprint(typeof(open(\"file.txt\"))); // \"file\"\n```\n\n**Type Names:**\n- Primitives: `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- Composites: `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- Special: `\"file\"`, `\"task\"`, `\"channel\"`\n- Custom: User-defined type names from `define`\n\n**See Also:** [Type System](#reference-type-system)\n\n---\n\n## Command Execution\n\n### exec\n\nExecute shell command and capture output.\n\n**Signature:**\n```hemlock\nexec(command: string): object\n```\n\n**Parameters:**\n- `command` - Shell command to execute\n\n**Returns:** Object with fields:\n- `output` (string) - Command's stdout\n- `exit_code` (i32) - Exit status code (0 = success)\n\n**Examples:**\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n\n// Check exit status\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Found:\", r.output);\n} else {\n    print(\"Pattern not found\");\n}\n\n// Process multi-line output\nlet r2 = exec(\"ls -la\");\nlet lines = r2.output.split(\"\\n\");\n```\n\n**Behavior:**\n- Executes command via `/bin/sh`\n- Captures stdout only (stderr goes to terminal)\n- Blocks until command completes\n- Returns empty string if no output\n\n**Error Handling:**\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command\");\n} catch (e) {\n    print(\"Failed to execute:\", e);\n}\n```\n\n**Security Warning:** ⚠️ Vulnerable to shell injection. Always validate/sanitize user input.\n\n**Limitations:**\n- No stderr capture\n- No streaming\n- No timeout\n- No signal handling\n\n---\n\n### exec_argv\n\nExecute a command with explicit argument array (no shell interpretation).\n\n**Signature:**\n```hemlock\nexec_argv(argv: array): object\n```\n\n**Parameters:**\n- `argv` - Array of strings: `[command, arg1, arg2, ...]`\n\n**Returns:** Object with fields:\n- `output` (string) - Command's stdout\n- `exit_code` (i32) - Exit status code (0 = success)\n\n**Examples:**\n```hemlock\n// Simple command\nlet result = exec_argv([\"ls\", \"-la\"]);\nprint(result.output);\n\n// Command with arguments containing spaces (safe!)\nlet r = exec_argv([\"grep\", \"hello world\", \"file.txt\"]);\n\n// Run a script with arguments\nlet r2 = exec_argv([\"python\", \"script.py\", \"--input\", \"data.json\"]);\nprint(r2.exit_code);\n```\n\n**Difference from exec:**\n```hemlock\n// exec() uses shell - UNSAFE with user input\nexec(\"ls \" + user_input);  // Shell injection risk!\n\n// exec_argv() bypasses shell - SAFE\nexec_argv([\"ls\", user_input]);  // No injection possible\n```\n\n**When to use:**\n- When arguments contain spaces, quotes, or special characters\n- When processing user input (security)\n- When you need predictable argument parsing\n\n**See Also:** `exec()` for simple shell commands\n\n---\n\n## Error Handling\n\n### throw\n\nThrow an exception.\n\n**Signature:**\n```hemlock\nthrow expression\n```\n\n**Parameters:**\n- `expression` - Value to throw (any type)\n\n**Returns:** Never returns (transfers control)\n\n**Examples:**\n```hemlock\nthrow \"error message\";\nthrow 404;\nthrow { code: 500, message: \"Internal error\" };\nthrow null;\n```\n\n**See Also:** try/catch/finally statements\n\n---\n\n### panic\n\nImmediately terminate program with error message (unrecoverable).\n\n**Signature:**\n```hemlock\npanic(message?: any): never\n```\n\n**Parameters:**\n- `message` (optional) - Error message to print\n\n**Returns:** Never returns (program exits)\n\n**Examples:**\n```hemlock\npanic();                          // Default: \"panic!\"\npanic(\"unreachable code reached\");\npanic(42);\n\n// Common use case\nfn process_state(state: i32): string {\n    if (state == 1) { return \"ready\"; }\n    if (state == 2) { return \"running\"; }\n    panic(\"invalid state: \" + typeof(state));\n}\n```\n\n**Behavior:**\n- Prints error to stderr: `panic: <message>`\n- Exits with code 1\n- **NOT catchable** with try/catch\n- Use for bugs and unrecoverable errors\n\n**Panic vs Throw:**\n- `panic()` - Unrecoverable error, exits immediately\n- `throw` - Recoverable error, can be caught\n\n---\n\n### assert\n\nAssert that a condition is true, or terminate with an error message.\n\n**Signature:**\n```hemlock\nassert(condition: any, message?: string): null\n```\n\n**Parameters:**\n- `condition` - Value to check for truthiness\n- `message` (optional) - Custom error message if assertion fails\n\n**Returns:** `null` (if assertion passes)\n\n**Examples:**\n```hemlock\n// Basic assertions\nassert(x > 0);\nassert(name != null);\nassert(arr.length > 0, \"Array must not be empty\");\n\n// With custom messages\nfn divide(a: i32, b: i32): f64 {\n    assert(b != 0, \"Division by zero\");\n    return a / b;\n}\n\n// Validate function arguments\nfn process_data(data: array) {\n    assert(data != null, \"data cannot be null\");\n    assert(data.length > 0, \"data cannot be empty\");\n    // ...\n}\n```\n\n**Behavior:**\n- If condition is truthy: returns `null`, execution continues\n- If condition is falsy: prints error and exits with code 1\n- Falsy values: `false`, `0`, `0.0`, `null`, `\"\"` (empty string)\n- Truthy values: everything else\n\n**Output on failure:**\n```\nAssertion failed: Array must not be empty\n```\n\n**When to use:**\n- Validating function preconditions\n- Checking invariants during development\n- Catching programmer errors early\n\n**assert vs panic:**\n- `assert(cond, msg)` - Checks a condition, fails if false\n- `panic(msg)` - Always fails unconditionally\n\n---\n\n## Signal Handling\n\n### signal\n\nRegister or reset signal handler.\n\n**Signature:**\n```hemlock\nsignal(signum: i32, handler: function | null): function | null\n```\n\n**Parameters:**\n- `signum` - Signal number (use constants like `SIGINT`)\n- `handler` - Function to call when signal received, or `null` to reset to default\n\n**Returns:** Previous handler function, or `null`\n\n**Examples:**\n```hemlock\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// Reset to default\nsignal(SIGINT, null);\n```\n\n**Handler Signature:**\n```hemlock\nfn handler(signum: i32) {\n    // signum contains the signal number\n}\n```\n\n**See Also:**\n- [Signal constants](#signal-constants)\n- `raise()`\n\n---\n\n### raise\n\nSend signal to current process.\n\n**Signature:**\n```hemlock\nraise(signum: i32): null\n```\n\n**Parameters:**\n- `signum` - Signal number to raise\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\nraise(SIGUSR1);\nraise(SIGUSR1);\nprint(count);  // 2\n```\n\n---\n\n## Global Variables\n\n### args\n\nCommand-line arguments array.\n\n**Type:** `array` of strings\n\n**Structure:**\n- `args[0]` - Script filename\n- `args[1..n]` - Command-line arguments\n\n**Examples:**\n```bash\n# Command: ./hemlock script.hml hello world\n```\n\n```hemlock\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // 3\nprint(args[1]);        // \"hello\"\nprint(args[2]);        // \"world\"\n\n// Iterate arguments\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument\", i, \":\", args[i]);\n    i = i + 1;\n}\n```\n\n**REPL Behavior:** In the REPL, `args.length` is 0 (empty array)\n\n---\n\n## Signal Constants\n\nStandard POSIX signal constants (i32 values):\n\n### Interrupt & Termination\n\n| Constant   | Value | Description                            |\n|------------|-------|----------------------------------------|\n| `SIGINT`   | 2     | Interrupt from keyboard (Ctrl+C)       |\n| `SIGTERM`  | 15    | Termination request                    |\n| `SIGQUIT`  | 3     | Quit from keyboard (Ctrl+\\)            |\n| `SIGHUP`   | 1     | Hangup detected on controlling terminal|\n| `SIGABRT`  | 6     | Abort signal                           |\n\n### User-Defined\n\n| Constant   | Value | Description                |\n|------------|-------|----------------------------|\n| `SIGUSR1`  | 10    | User-defined signal 1      |\n| `SIGUSR2`  | 12    | User-defined signal 2      |\n\n### Process Control\n\n| Constant   | Value | Description                     |\n|------------|-------|---------------------------------|\n| `SIGALRM`  | 14    | Alarm clock timer               |\n| `SIGCHLD`  | 17    | Child process status change     |\n| `SIGCONT`  | 18    | Continue if stopped             |\n| `SIGSTOP`  | 19    | Stop process (cannot be caught) |\n| `SIGTSTP`  | 20    | Terminal stop (Ctrl+Z)          |\n\n### I/O\n\n| Constant   | Value | Description                        |\n|------------|-------|------------------------------------|\n| `SIGPIPE`  | 13    | Broken pipe                        |\n| `SIGTTIN`  | 21    | Background read from terminal      |\n| `SIGTTOU`  | 22    | Background write to terminal       |\n\n**Examples:**\n```hemlock\nfn handle_signal(sig) {\n    if (sig == SIGINT) {\n        print(\"Interrupt detected\");\n    }\n    if (sig == SIGTERM) {\n        print(\"Termination requested\");\n    }\n}\n\nsignal(SIGINT, handle_signal);\nsignal(SIGTERM, handle_signal);\n```\n\n**Note:** `SIGKILL` (9) and `SIGSTOP` (19) cannot be caught or ignored.\n\n---\n\n## Math/Arithmetic Functions\n\n### div\n\nFloor division returning a float.\n\n**Signature:**\n```hemlock\ndiv(a: number, b: number): f64\n```\n\n**Parameters:**\n- `a` - Dividend\n- `b` - Divisor\n\n**Returns:** Floor of `a / b` as a float (f64)\n\n**Examples:**\n```hemlock\nlet result = div(7, 2);    // 3.0 (not 3.5)\nlet result2 = div(10, 3);  // 3.0\nlet result3 = div(-7, 2);  // -4.0 (floor rounds toward negative infinity)\n```\n\n**Note:** In Hemlock, the `/` operator always returns a float. Use `div()` for floor division when you need the integer part as a float, or `divi()` when you need an integer result.\n\n---\n\n### divi\n\nFloor division returning an integer.\n\n**Signature:**\n```hemlock\ndivi(a: number, b: number): i64\n```\n\n**Parameters:**\n- `a` - Dividend\n- `b` - Divisor\n\n**Returns:** Floor of `a / b` as an integer (i64)\n\n**Examples:**\n```hemlock\nlet result = divi(7, 2);    // 3\nlet result2 = divi(10, 3);  // 3\nlet result3 = divi(-7, 2);  // -4 (floor rounds toward negative infinity)\n```\n\n**Comparison:**\n```hemlock\nprint(7 / 2);      // 3.5 (regular division, always float)\nprint(div(7, 2));  // 3.0 (floor division, float result)\nprint(divi(7, 2)); // 3   (floor division, integer result)\n```\n\n---\n\n## Memory Management Functions\n\nSee [Memory API](#reference-memory-api) for complete reference:\n- `alloc(size)` - Allocate raw memory\n- `free(ptr)` - Free memory\n- `buffer(size)` - Allocate safe buffer\n- `memset(ptr, byte, size)` - Fill memory\n- `memcpy(dest, src, size)` - Copy memory\n- `realloc(ptr, new_size)` - Resize allocation\n\n### sizeof\n\nGet the size of a type in bytes.\n\n**Signature:**\n```hemlock\nsizeof(type): i32\n```\n\n**Parameters:**\n- `type` - A type constant (`i32`, `f64`, `ptr`, etc.) or type name string\n\n**Returns:** Size in bytes as `i32`\n\n**Examples:**\n```hemlock\nprint(sizeof(i8));       // 1\nprint(sizeof(i16));      // 2\nprint(sizeof(i32));      // 4\nprint(sizeof(i64));      // 8\nprint(sizeof(f32));      // 4\nprint(sizeof(f64));      // 8\nprint(sizeof(ptr));      // 8\nprint(sizeof(rune));     // 4\n\n// Using type aliases\nprint(sizeof(byte));     // 1 (same as u8)\nprint(sizeof(integer));  // 4 (same as i32)\nprint(sizeof(number));   // 8 (same as f64)\n\n// String form also works\nprint(sizeof(\"i32\"));    // 4\n```\n\n**Supported Types:**\n| Type | Size | Aliases |\n|------|------|---------|\n| `i8` | 1 | - |\n| `i16` | 2 | - |\n| `i32` | 4 | `integer` |\n| `i64` | 8 | - |\n| `u8` | 1 | `byte` |\n| `u16` | 2 | - |\n| `u32` | 4 | - |\n| `u64` | 8 | - |\n| `f32` | 4 | - |\n| `f64` | 8 | `number` |\n| `ptr` | 8 | - |\n| `rune` | 4 | - |\n| `bool` | 1 | - |\n\n**See Also:** `talloc()` for typed allocation\n\n---\n\n### talloc\n\nAllocate memory for a typed array (type-aware allocation).\n\n**Signature:**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**Parameters:**\n- `type` - A type constant (`i32`, `f64`, `ptr`, etc.)\n- `count` - Number of elements to allocate\n\n**Returns:** `ptr` to allocated memory, or `null` on failure\n\n**Examples:**\n```hemlock\n// Allocate array of 10 i32s (40 bytes)\nlet int_arr = talloc(i32, 10);\nptr_write_i32(int_arr, 42);\nptr_write_i32(ptr_offset(int_arr, 1, 4), 100);\n\n// Allocate array of 5 f64s (40 bytes)\nlet float_arr = talloc(f64, 5);\n\n// Allocate array of 100 bytes\nlet byte_arr = talloc(u8, 100);\n\n// Don't forget to free!\nfree(int_arr);\nfree(float_arr);\nfree(byte_arr);\n```\n\n**Comparison with alloc:**\n```hemlock\n// These are equivalent:\nlet p1 = talloc(i32, 10);      // Type-aware: 10 i32s\nlet p2 = alloc(sizeof(i32) * 10);  // Manual calculation\n\n// talloc is clearer and less error-prone\n```\n\n**Error Handling:**\n- Returns `null` if allocation fails\n- Exits with error if count is not positive\n- Checks for size overflow (count * element_size)\n\n**See Also:** `alloc()`, `sizeof()`, `free()`\n\n---\n\n## FFI Pointer Helpers\n\nThese functions help read and write typed values to raw memory, useful for FFI and low-level memory manipulation.\n\n### ptr_null\n\nCreate a null pointer.\n\n**Signature:**\n```hemlock\nptr_null(): ptr\n```\n\n**Returns:** A null pointer\n\n**Example:**\n```hemlock\nlet p = ptr_null();\nif (p == null) {\n    print(\"Pointer is null\");\n}\n```\n\n---\n\n### ptr_offset\n\nCalculate pointer offset (pointer arithmetic).\n\n**Signature:**\n```hemlock\nptr_offset(ptr: ptr, index: i32, element_size: i32): ptr\n```\n\n**Parameters:**\n- `ptr` - Base pointer\n- `index` - Element index\n- `element_size` - Size of each element in bytes\n\n**Returns:** Pointer to the element at the given index\n\n**Example:**\n```hemlock\nlet arr = talloc(i32, 10);\nptr_write_i32(arr, 100);                      // arr[0] = 100\nptr_write_i32(ptr_offset(arr, 1, 4), 200);    // arr[1] = 200\nptr_write_i32(ptr_offset(arr, 2, 4), 300);    // arr[2] = 300\n\nprint(ptr_read_i32(ptr_offset(arr, 1, 4)));   // 200\nfree(arr);\n```\n\n---\n\n### Pointer Read Functions\n\nRead typed values from memory.\n\n| Function | Signature | Returns | Description |\n|----------|-----------|---------|-------------|\n| `ptr_read_i8` | `(ptr)` | `i8` | Read signed 8-bit integer |\n| `ptr_read_i16` | `(ptr)` | `i16` | Read signed 16-bit integer |\n| `ptr_read_i32` | `(ptr)` | `i32` | Read signed 32-bit integer |\n| `ptr_read_i64` | `(ptr)` | `i64` | Read signed 64-bit integer |\n| `ptr_read_u8` | `(ptr)` | `u8` | Read unsigned 8-bit integer |\n| `ptr_read_u16` | `(ptr)` | `u16` | Read unsigned 16-bit integer |\n| `ptr_read_u32` | `(ptr)` | `u32` | Read unsigned 32-bit integer |\n| `ptr_read_u64` | `(ptr)` | `u64` | Read unsigned 64-bit integer |\n| `ptr_read_f32` | `(ptr)` | `f32` | Read 32-bit float |\n| `ptr_read_f64` | `(ptr)` | `f64` | Read 64-bit float |\n| `ptr_read_ptr` | `(ptr)` | `ptr` | Read pointer value |\n\n**Example:**\n```hemlock\nlet p = alloc(8);\nptr_write_f64(p, 3.14159);\nlet value = ptr_read_f64(p);\nprint(value);  // 3.14159\nfree(p);\n```\n\n---\n\n### Pointer Write Functions\n\nWrite typed values to memory.\n\n| Function | Signature | Returns | Description |\n|----------|-----------|---------|-------------|\n| `ptr_write_i8` | `(ptr, value)` | `null` | Write signed 8-bit integer |\n| `ptr_write_i16` | `(ptr, value)` | `null` | Write signed 16-bit integer |\n| `ptr_write_i32` | `(ptr, value)` | `null` | Write signed 32-bit integer |\n| `ptr_write_i64` | `(ptr, value)` | `null` | Write signed 64-bit integer |\n| `ptr_write_u8` | `(ptr, value)` | `null` | Write unsigned 8-bit integer |\n| `ptr_write_u16` | `(ptr, value)` | `null` | Write unsigned 16-bit integer |\n| `ptr_write_u32` | `(ptr, value)` | `null` | Write unsigned 32-bit integer |\n| `ptr_write_u64` | `(ptr, value)` | `null` | Write unsigned 64-bit integer |\n| `ptr_write_f32` | `(ptr, value)` | `null` | Write 32-bit float |\n| `ptr_write_f64` | `(ptr, value)` | `null` | Write 64-bit float |\n| `ptr_write_ptr` | `(ptr, value)` | `null` | Write pointer value |\n\n**Example:**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\nprint(ptr_read_i32(p));  // 42\nfree(p);\n```\n\n---\n\n### Buffer/Pointer Conversion\n\n#### buffer_ptr\n\nGet raw pointer from a buffer.\n\n**Signature:**\n```hemlock\nbuffer_ptr(buf: buffer): ptr\n```\n\n**Example:**\n```hemlock\nlet buf = buffer(64);\nlet p = buffer_ptr(buf);\n// Now p points to the same memory as buf\n```\n\n#### ptr_to_buffer\n\nCreate a buffer wrapper around a raw pointer.\n\n**Signature:**\n```hemlock\nptr_to_buffer(ptr: ptr, size: i32): buffer\n```\n\n**Example:**\n```hemlock\nlet p = alloc(64);\nlet buf = ptr_to_buffer(p, 64);\nbuf[0] = 65;  // Now has bounds checking\n// Note: freeing buf will free the underlying memory\n```\n\n---\n\n## File I/O Functions\n\nSee [File API](#reference-file-api) for complete reference:\n- `open(path, mode?)` - Open file\n\n---\n\n## Concurrency Functions\n\nSee [Concurrency API](#reference-concurrency-api) for complete reference:\n- `spawn(fn, args...)` - Spawn task\n- `join(task)` - Wait for task\n- `detach(task)` - Detach task\n- `channel(capacity)` - Create channel\n\n### apply\n\nCall a function dynamically with an array of arguments.\n\n**Signature:**\n```hemlock\napply(fn: function, args: array): any\n```\n\n**Parameters:**\n- `fn` - The function to call\n- `args` - Array of arguments to pass to the function\n\n**Returns:** The return value of the called function\n\n**Examples:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\n// Call with array of arguments\nlet result = apply(add, [2, 3]);\nprint(result);  // 5\n\n// Dynamic dispatch\nlet operations = {\n    add: fn(a, b) { return a + b; },\n    mul: fn(a, b) { return a * b; },\n    sub: fn(a, b) { return a - b; }\n};\n\nfn calculate(op: string, args: array) {\n    return apply(operations[op], args);\n}\n\nprint(calculate(\"add\", [10, 5]));  // 15\nprint(calculate(\"mul\", [10, 5]));  // 50\nprint(calculate(\"sub\", [10, 5]));  // 5\n\n// Variable arguments\nfn sum(...nums) {\n    let total = 0;\n    for (n in nums) {\n        total = total + n;\n    }\n    return total;\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(apply(sum, numbers));  // 15\n```\n\n**Use Cases:**\n- Dynamic function dispatch based on runtime values\n- Calling functions with variable argument lists\n- Implementing higher-order utilities (map, filter, etc.)\n- Plugin/extension systems\n\n---\n\n### select\n\nWait for data from multiple channels, returning when any has data.\n\n**Signature:**\n```hemlock\nselect(channels: array, timeout_ms?: i32): object | null\n```\n\n**Parameters:**\n- `channels` - Array of channel values\n- `timeout_ms` (optional) - Timeout in milliseconds (-1 or omit for infinite)\n\n**Returns:**\n- `{ channel, value }` - Object with the channel that had data and the received value\n- `null` - On timeout\n\n**Examples:**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// Producer tasks\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"from channel 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"from channel 2\");\n});\n\n// Wait for first message\nlet result = select([ch1, ch2]);\nprint(result.value);  // \"from channel 2\" (arrived first)\n\n// With timeout\nlet result2 = select([ch1, ch2], 1000);  // Wait up to 1 second\nif (result2 == null) {\n    print(\"Timeout - no data received\");\n} else {\n    print(\"Received:\", result2.value);\n}\n\n// Continuous select loop\nwhile (true) {\n    let msg = select([ch1, ch2], 5000);\n    if (msg == null) {\n        print(\"No activity for 5 seconds\");\n        break;\n    }\n    print(\"Got message:\", msg.value);\n}\n```\n\n**Behavior:**\n- Blocks until one channel has data or timeout expires\n- Returns immediately if a channel already has data\n- If channel is closed and empty, returns `{ channel, value: null }`\n- Polls channels in order (first ready channel wins)\n\n**Use Cases:**\n- Multiplexing multiple producers\n- Implementing timeouts on channel operations\n- Building event loops with multiple sources\n\n---\n\n## Summary Table\n\n### Functions\n\n| Function   | Category        | Returns      | Description                     |\n|------------|-----------------|--------------|----------------------------------|\n| `print`    | I/O             | `null`       | Print to stdout                  |\n| `read_line`| I/O             | `string?`    | Read line from stdin             |\n| `eprint`   | I/O             | `null`       | Print to stderr                  |\n| `typeof`   | Type            | `string`     | Get type name                    |\n| `exec`     | Command         | `object`     | Execute shell command            |\n| `exec_argv`| Command         | `object`     | Execute with argument array      |\n| `assert`   | Error           | `null`       | Assert condition or exit         |\n| `panic`    | Error           | `never`      | Unrecoverable error (exits)      |\n| `signal`   | Signal          | `function?`  | Register signal handler          |\n| `raise`    | Signal          | `null`       | Send signal to process           |\n| `alloc`    | Memory          | `ptr`        | Allocate raw memory              |\n| `talloc`   | Memory          | `ptr`        | Typed allocation                 |\n| `sizeof`   | Memory          | `i32`        | Get type size in bytes           |\n| `free`     | Memory          | `null`       | Free memory                      |\n| `buffer`   | Memory          | `buffer`     | Allocate safe buffer             |\n| `memset`   | Memory          | `null`       | Fill memory                      |\n| `memcpy`   | Memory          | `null`       | Copy memory                      |\n| `realloc`  | Memory          | `ptr`        | Resize allocation                |\n| `open`     | File I/O        | `file`       | Open file                        |\n| `spawn`    | Concurrency     | `task`       | Spawn concurrent task            |\n| `join`     | Concurrency     | `any`        | Wait for task result             |\n| `detach`   | Concurrency     | `null`       | Detach task                      |\n| `channel`  | Concurrency     | `channel`    | Create communication channel     |\n| `select`   | Concurrency     | `object?`    | Wait on multiple channels        |\n| `apply`    | Functions       | `any`        | Call function with args array    |\n\n### Global Variables\n\n| Variable   | Type     | Description                       |\n|------------|----------|-----------------------------------|\n| `args`     | `array`  | Command-line arguments            |\n\n### Constants\n\n| Constant   | Type  | Category | Value | Description               |\n|------------|-------|----------|-------|---------------------------|\n| `SIGINT`   | `i32` | Signal   | 2     | Keyboard interrupt        |\n| `SIGTERM`  | `i32` | Signal   | 15    | Termination request       |\n| `SIGQUIT`  | `i32` | Signal   | 3     | Keyboard quit             |\n| `SIGHUP`   | `i32` | Signal   | 1     | Hangup                    |\n| `SIGABRT`  | `i32` | Signal   | 6     | Abort                     |\n| `SIGUSR1`  | `i32` | Signal   | 10    | User-defined 1            |\n| `SIGUSR2`  | `i32` | Signal   | 12    | User-defined 2            |\n| `SIGALRM`  | `i32` | Signal   | 14    | Alarm timer               |\n| `SIGCHLD`  | `i32` | Signal   | 17    | Child status change       |\n| `SIGCONT`  | `i32` | Signal   | 18    | Continue                  |\n| `SIGSTOP`  | `i32` | Signal   | 19    | Stop (uncatchable)        |\n| `SIGTSTP`  | `i32` | Signal   | 20    | Terminal stop             |\n| `SIGPIPE`  | `i32` | Signal   | 13    | Broken pipe               |\n| `SIGTTIN`  | `i32` | Signal   | 21    | Background terminal read  |\n| `SIGTTOU`  | `i32` | Signal   | 22    | Background terminal write |\n\n---\n\n## See Also\n\n- [Type System](#reference-type-system) - Types and conversions\n- [Memory API](#reference-memory-api) - Memory allocation functions\n- [File API](#reference-file-api) - File I/O functions\n- [Concurrency API](#reference-concurrency-api) - Async/concurrency functions\n- [String API](#reference-string-api) - String methods\n- [Array API](#reference-array-api) - Array methods\n"}, "API Reference -> Concurrency API": {"id": "reference-concurrency-api", "content": "# Concurrency API Reference\n\nComplete reference for Hemlock's async/concurrency system.\n\n---\n\n## Overview\n\nHemlock provides **structured concurrency** with true multi-threaded parallelism using POSIX threads (pthreads). Each spawned task runs on a separate OS thread, enabling actual parallel execution across multiple CPU cores.\n\n**Key Features:**\n- True multi-threaded parallelism (not green threads)\n- Async function syntax\n- Task spawning and joining\n- Thread-safe channels\n- Exception propagation\n\n**Threading Model:**\n- ✅ Real OS threads (POSIX pthreads)\n- ✅ True parallelism (multiple CPU cores)\n- ✅ Kernel-scheduled (pre-emptive multitasking)\n- ✅ Thread-safe synchronization (mutexes, condition variables)\n\n---\n\n## Async Functions\n\n### Async Function Declaration\n\nFunctions can be declared as `async` to indicate they're designed for concurrent execution.\n\n**Syntax:**\n```hemlock\nasync fn function_name(params): return_type {\n    // function body\n}\n```\n\n**Examples:**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nasync fn process_data(data: string) {\n    print(\"Processing:\", data);\n    return null;\n}\n```\n\n**Behavior:**\n- `async fn` declares an asynchronous function\n- Can be called synchronously (runs in current thread)\n- Can be spawned as concurrent task (runs on new thread)\n- When spawned, runs on its own OS thread\n\n**Note:** The `await` keyword is reserved for future use but not currently implemented.\n\n---\n\n## Task Management\n\n### spawn\n\nCreate and start a new concurrent task.\n\n**Signature:**\n```hemlock\nspawn(async_fn: function, ...args): task\n```\n\n**Parameters:**\n- `async_fn` - Async function to execute\n- `...args` - Arguments to pass to function\n\n**Returns:** Task handle\n\n**Examples:**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn single task\nlet t = spawn(compute, 1000);\nlet result = join(t);\nprint(result);\n\n// Spawn multiple tasks (run in parallel!)\nlet t1 = spawn(compute, 100);\nlet t2 = spawn(compute, 200);\nlet t3 = spawn(compute, 300);\n\n// All three are running simultaneously\nlet r1 = join(t1);\nlet r2 = join(t2);\nlet r3 = join(t3);\n```\n\n**Behavior:**\n- Creates new OS thread via `pthread_create()`\n- Starts executing function immediately\n- Returns task handle for later joining\n- Tasks run in parallel on separate CPU cores\n\n---\n\n### join\n\nWait for task completion and retrieve result.\n\n**Signature:**\n```hemlock\njoin(task: task): any\n```\n\n**Parameters:**\n- `task` - Task handle from `spawn()`\n\n**Returns:** Task's return value\n\n**Examples:**\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nlet t = spawn(factorial, 10);\nlet result = join(t);  // Blocks until task completes\nprint(result);         // 3628800\n```\n\n**Behavior:**\n- Blocks current thread until task completes\n- Returns task's return value\n- Propagates exceptions thrown by task\n- Cleans up task resources after returning\n\n**Error Handling:**\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Caught:\", e);  // \"Caught: Task failed!\"\n}\n```\n\n---\n\n### detach\n\nDetach task (fire-and-forget execution).\n\n**Signature:**\n```hemlock\ndetach(task: task): null\n```\n\n**Parameters:**\n- `task` - Task handle from `spawn()`\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nasync fn background_work() {\n    print(\"Working in background...\");\n    return null;\n}\n\nlet t = spawn(background_work);\ndetach(t);  // Task continues running independently\n\n// Cannot join detached task\n// join(t);  // ERROR\n```\n\n**Behavior:**\n- Task continues running independently\n- Cannot `join()` detached task\n- Task and thread are automatically cleaned up when the task completes\n\n**Use Cases:**\n- Fire-and-forget background tasks\n- Logging/monitoring tasks\n- Tasks that don't need to return values\n\n---\n\n## Channels\n\nChannels provide thread-safe communication between tasks.\n\n### channel\n\nCreate a buffered channel.\n\n**Signature:**\n```hemlock\nchannel(capacity: i32): channel\n```\n\n**Parameters:**\n- `capacity` - Buffer size (number of values)\n\n**Returns:** Channel object\n\n**Examples:**\n```hemlock\nlet ch = channel(10);  // Buffered channel with capacity 10\nlet ch2 = channel(1);  // Minimal buffer (synchronous)\nlet ch3 = channel(100); // Large buffer\n```\n\n**Behavior:**\n- Creates thread-safe channel\n- Uses pthread mutexes for synchronization\n- Capacity is fixed at creation time\n\n---\n\n### Channel Methods\n\n#### send\n\nSend value to channel (blocks if full).\n\n**Signature:**\n```hemlock\nchannel.send(value: any): null\n```\n\n**Parameters:**\n- `value` - Value to send (any type)\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet t = spawn(producer, ch, 5);\n```\n\n**Behavior:**\n- Sends value to channel\n- Blocks if channel is full\n- Thread-safe (uses mutex)\n- Returns after value is sent\n\n---\n\n#### recv\n\nReceive value from channel (blocks if empty).\n\n**Signature:**\n```hemlock\nchannel.recv(): any\n```\n\n**Returns:** Value from channel, or `null` if channel is closed and empty\n\n**Examples:**\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet t = spawn(consumer, ch, 5);\n```\n\n**Behavior:**\n- Receives value from channel\n- Blocks if channel is empty\n- Returns `null` if channel is closed and empty\n- Thread-safe (uses mutex)\n\n---\n\n#### close\n\nClose channel (no more sends allowed).\n\n**Signature:**\n```hemlock\nchannel.close(): null\n```\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nasync fn producer(ch) {\n    ch.send(1);\n    ch.send(2);\n    ch.send(3);\n    ch.close();  // Signal no more values\n    return null;\n}\n\nasync fn consumer(ch) {\n    while (true) {\n        let val = ch.recv();\n        if (val == null) {\n            break;  // Channel closed\n        }\n        print(val);\n    }\n    return null;\n}\n```\n\n**Behavior:**\n- Closes channel\n- No more sends allowed\n- `recv()` returns `null` when channel is empty\n- Thread-safe\n\n---\n\n## Complete Concurrency Example\n\n### Producer-Consumer Pattern\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        print(\"Producing:\", i);\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        print(\"Consuming:\", val);\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Create channel\nlet ch = channel(10);\n\n// Spawn producer and consumer\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// Wait for completion\njoin(p);\nlet total = join(c);\nprint(\"Total:\", total);  // 0+10+20+30+40 = 100\n```\n\n---\n\n## Parallel Computation\n\n### Multiple Tasks Example\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// Spawn multiple tasks (run in parallel!)\nlet t1 = spawn(factorial, 5);   // Thread 1\nlet t2 = spawn(factorial, 6);   // Thread 2\nlet t3 = spawn(factorial, 7);   // Thread 3\nlet t4 = spawn(factorial, 8);   // Thread 4\n\n// All four are computing simultaneously!\n\n// Wait for results\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\nlet f8 = join(t4);  // 40320\n\nprint(f5, f6, f7, f8);\n```\n\n---\n\n## Task Lifecycle\n\n### State Transitions\n\n1. **Created** - Task spawned but not yet running\n2. **Running** - Task executing on OS thread\n3. **Completed** - Task finished (result available)\n4. **Joined** - Result retrieved, resources cleaned up\n5. **Detached** - Task continues independently\n\n### Lifecycle Example\n\n```hemlock\nasync fn work(n: i32): i32 {\n    return n * 2;\n}\n\n// 1. Create task\nlet t = spawn(work, 21);  // State: Running\n\n// Task executes on separate thread...\n\n// 2. Join task\nlet result = join(t);     // State: Completed → Joined\nprint(result);            // 42\n\n// Task resources cleaned up after join\n```\n\n### Detached Lifecycle\n\n```hemlock\nasync fn background() {\n    print(\"Background task running\");\n    return null;\n}\n\n// 1. Create task\nlet t = spawn(background);  // State: Running\n\n// 2. Detach task\ndetach(t);                  // State: Detached\n\n// Task continues running independently\n// Resources cleaned up by OS when done\n```\n\n---\n\n## Error Handling\n\n### Exception Propagation\n\nExceptions thrown in tasks are propagated when joined:\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\n// Task that succeeds\nlet t1 = spawn(risky_operation, 0);\nlet result1 = join(t1);  // 42\n\n// Task that fails\nlet t2 = spawn(risky_operation, 1);\ntry {\n    let result2 = join(t2);\n} catch (e) {\n    print(\"Caught:\", e);  // \"Caught: Task failed!\"\n}\n```\n\n### Handling Multiple Tasks\n\n```hemlock\nasync fn work(id: i32, should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task \" + typeof(id) + \" failed\";\n    }\n    return id * 10;\n}\n\nlet t1 = spawn(work, 1, 0);\nlet t2 = spawn(work, 2, 1);  // Will fail\nlet t3 = spawn(work, 3, 0);\n\n// Join with error handling\ntry {\n    let r1 = join(t1);  // OK\n    print(\"Task 1:\", r1);\n\n    let r2 = join(t2);  // Throws\n    print(\"Task 2:\", r2);  // Never reached\n} catch (e) {\n    print(\"Error:\", e);  // \"Error: Task 2 failed\"\n}\n\n// Can still join remaining task\nlet r3 = join(t3);\nprint(\"Task 3:\", r3);\n```\n\n---\n\n## Performance Characteristics\n\n### True Parallelism\n\n```hemlock\nasync fn cpu_intensive(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Sequential execution\nlet start = get_time();\nlet r1 = cpu_intensive(10000000);\nlet r2 = cpu_intensive(10000000);\nlet sequential_time = get_time() - start;\n\n// Parallel execution\nlet start2 = get_time();\nlet t1 = spawn(cpu_intensive, 10000000);\nlet t2 = spawn(cpu_intensive, 10000000);\njoin(t1);\njoin(t2);\nlet parallel_time = get_time() - start2;\n\n// parallel_time should be ~50% of sequential_time on multi-core systems\n```\n\n**Proven Characteristics:**\n- N tasks can utilize N CPU cores simultaneously\n- Stress tests show 8-9x CPU time vs wall time (proof of parallelism)\n- Thread overhead: ~8KB stack + pthread overhead per task\n- Blocking operations in one task don't block others\n\n---\n\n## Implementation Details\n\n### Threading Model\n\n- **1:1 threading** - Each task = 1 OS thread (`pthread`)\n- **Kernel-scheduled** - OS kernel distributes threads across cores\n- **Pre-emptive multitasking** - OS can interrupt and switch threads\n- **No GIL** - No Global Interpreter Lock (unlike Python)\n\n### Synchronization\n\n- **Mutexes** - Channels use `pthread_mutex_t`\n- **Condition variables** - Blocking send/recv use `pthread_cond_t`\n- **Lock-free operations** - Task state transitions are atomic\n\n### Memory & Cleanup\n\n- **Joined tasks** - Automatically cleaned up after `join()`\n- **Detached tasks** - Automatically cleaned up when the task completes\n- **Channels** - Reference-counted, freed when no longer used\n\n---\n\n## Limitations\n\n- No `select()` for multiplexing multiple channels\n- No work-stealing scheduler (1 thread per task)\n- No async I/O integration (file/network operations block)\n- Channel capacity fixed at creation time\n\n---\n\n## Complete API Summary\n\n### Functions\n\n| Function  | Signature                         | Returns   | Description                    |\n|-----------|-----------------------------------|-----------|--------------------------------|\n| `spawn`   | `(async_fn: function, ...args)`   | `task`    | Create and start concurrent task|\n| `join`    | `(task: task)`                    | `any`     | Wait for task, get result      |\n| `detach`  | `(task: task)`                    | `null`    | Detach task (fire-and-forget)  |\n| `channel` | `(capacity: i32)`                 | `channel` | Create thread-safe channel     |\n\n### Channel Methods\n\n| Method  | Signature       | Returns | Description                      |\n|---------|-----------------|---------|----------------------------------|\n| `send`  | `(value: any)`  | `null`  | Send value (blocks if full)      |\n| `recv`  | `()`            | `any`   | Receive value (blocks if empty)  |\n| `close` | `()`            | `null`  | Close channel                    |\n\n### Types\n\n| Type      | Description                          |\n|-----------|--------------------------------------|\n| `task`    | Handle for concurrent task           |\n| `channel` | Thread-safe communication channel    |\n\n---\n\n## Best Practices\n\n### Do's\n\n✅ Use channels for communication between tasks\n✅ Handle exceptions from joined tasks\n✅ Close channels when done sending\n✅ Use `join()` to get results and clean up\n✅ Spawn async functions only\n\n### Don'ts\n\n❌ Don't share mutable state without synchronization\n❌ Don't join the same task twice\n❌ Don't send on closed channels\n❌ Don't spawn non-async functions\n❌ Don't forget to join tasks (unless detached)\n\n---\n\n## See Also\n\n- [Built-in Functions](#reference-builtins) - `spawn()`, `join()`, `detach()`, `channel()`\n- [Type System](#reference-type-system) - Task and channel types\n"}, "API Reference -> File API": {"id": "reference-file-api", "content": "# File API Reference\n\nComplete reference for Hemlock's File I/O system.\n\n---\n\n## Overview\n\nHemlock provides a **File object API** for file operations with proper error handling and resource management. Files must be manually opened and closed.\n\n**Key Features:**\n- File object with methods\n- Read/write text and binary data\n- Seeking and positioning\n- Proper error messages\n- Manual resource management (no RAII)\n\n---\n\n## File Type\n\n**Type:** `file`\n\n**Description:** File handle for I/O operations\n\n**Properties (Read-Only):**\n- `.path` - File path (string)\n- `.mode` - Open mode (string)\n- `.closed` - Whether file is closed (bool)\n\n---\n\n## Opening Files\n\n### open\n\nOpen a file for reading, writing, or both.\n\n**Signature:**\n```hemlock\nopen(path: string, mode?: string): file\n```\n\n**Parameters:**\n- `path` - File path (relative or absolute)\n- `mode` (optional) - Open mode (default: `\"r\"`)\n\n**Returns:** File object\n\n**Modes:**\n- `\"r\"` - Read (default)\n- `\"w\"` - Write (truncate existing file)\n- `\"a\"` - Append\n- `\"r+\"` - Read and write\n- `\"w+\"` - Read and write (truncate)\n- `\"a+\"` - Read and append\n\n**Examples:**\n```hemlock\n// Read mode (default)\nlet f = open(\"data.txt\");\nlet f_read = open(\"data.txt\", \"r\");\n\n// Write mode (truncate)\nlet f_write = open(\"output.txt\", \"w\");\n\n// Append mode\nlet f_append = open(\"log.txt\", \"a\");\n\n// Read/write mode\nlet f_rw = open(\"data.bin\", \"r+\");\n\n// Read/write (truncate)\nlet f_rw_trunc = open(\"output.bin\", \"w+\");\n\n// Read/append\nlet f_ra = open(\"log.txt\", \"a+\");\n```\n\n**Error Handling:**\n```hemlock\ntry {\n    let f = open(\"missing.txt\", \"r\");\n} catch (e) {\n    print(\"Failed to open:\", e);\n    // Error: Failed to open 'missing.txt': No such file or directory\n}\n```\n\n**Important:** Files must be closed manually with `f.close()` to avoid file descriptor leaks.\n\n---\n\n## File Methods\n\n### Reading\n\n#### read\n\nRead text from file.\n\n**Signature:**\n```hemlock\nfile.read(size?: i32): string\n```\n\n**Parameters:**\n- `size` (optional) - Number of bytes to read (if omitted, reads to EOF)\n\n**Returns:** String with file contents\n\n**Examples:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Read entire file\nlet all = f.read();\nprint(all);\n\n// Read specific number of bytes\nlet chunk = f.read(1024);\n\nf.close();\n```\n\n**Behavior:**\n- Reads from current file position\n- Returns empty string at EOF\n- Advances file position\n\n**Errors:**\n- Reading from closed file\n- Reading from write-only file\n\n---\n\n#### read_bytes\n\nRead binary data from file.\n\n**Signature:**\n```hemlock\nfile.read_bytes(size: i32): buffer\n```\n\n**Parameters:**\n- `size` - Number of bytes to read\n\n**Returns:** Buffer with binary data\n\n**Examples:**\n```hemlock\nlet f = open(\"data.bin\", \"r\");\n\n// Read 256 bytes\nlet binary = f.read_bytes(256);\nprint(binary.length);       // 256\n\n// Process binary data\nlet i = 0;\nwhile (i < binary.length) {\n    print(binary[i]);\n    i = i + 1;\n}\n\nf.close();\n```\n\n**Behavior:**\n- Reads exact number of bytes\n- Returns buffer (not string)\n- Advances file position\n\n---\n\n### Writing\n\n#### write\n\nWrite text to file.\n\n**Signature:**\n```hemlock\nfile.write(data: string): i32\n```\n\n**Parameters:**\n- `data` - String to write\n\n**Returns:** Number of bytes written (i32)\n\n**Examples:**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\n\n// Write text\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Wrote\", written, \"bytes\");\n\n// Multiple writes\nf.write(\"Line 1\\n\");\nf.write(\"Line 2\\n\");\nf.write(\"Line 3\\n\");\n\nf.close();\n```\n\n**Behavior:**\n- Writes at current file position\n- Returns number of bytes written\n- Advances file position\n\n**Errors:**\n- Writing to closed file\n- Writing to read-only file\n\n---\n\n#### write_bytes\n\nWrite binary data to file.\n\n**Signature:**\n```hemlock\nfile.write_bytes(data: buffer): i32\n```\n\n**Parameters:**\n- `data` - Buffer to write\n\n**Returns:** Number of bytes written (i32)\n\n**Examples:**\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// Create buffer\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// Write buffer\nlet written = f.write_bytes(buf);\nprint(\"Wrote\", written, \"bytes\");\n\nf.close();\n```\n\n**Behavior:**\n- Writes buffer contents to file\n- Returns number of bytes written\n- Advances file position\n\n---\n\n### Seeking\n\n#### seek\n\nMove file position to specific byte offset.\n\n**Signature:**\n```hemlock\nfile.seek(position: i32): i32\n```\n\n**Parameters:**\n- `position` - Byte offset from beginning of file\n\n**Returns:** New file position (i32)\n\n**Examples:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// Jump to byte 100\nf.seek(100);\n\n// Read from that position\nlet chunk = f.read(50);\n\n// Reset to beginning\nf.seek(0);\n\n// Read from start\nlet all = f.read();\n\nf.close();\n```\n\n**Behavior:**\n- Sets file position to absolute offset\n- Returns new position\n- Seeking past EOF is allowed (creates hole in file when writing)\n\n---\n\n#### tell\n\nGet current file position.\n\n**Signature:**\n```hemlock\nfile.tell(): i32\n```\n\n**Returns:** Current byte offset from beginning of file (i32)\n\n**Examples:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nprint(f.tell());        // 0 (at start)\n\nf.read(100);\nprint(f.tell());        // 100 (after reading)\n\nf.seek(50);\nprint(f.tell());        // 50 (after seeking)\n\nf.close();\n```\n\n---\n\n### Closing\n\n#### close\n\nClose file (idempotent).\n\n**Signature:**\n```hemlock\nfile.close(): null\n```\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\n// Safe to call multiple times\nf.close();  // No error\nf.close();  // No error\n```\n\n**Behavior:**\n- Closes file handle\n- Flushes any pending writes\n- Idempotent (safe to call multiple times)\n- Sets `.closed` property to `true`\n\n**Important:** Always close files when done to avoid file descriptor leaks.\n\n---\n\n## File Properties\n\n### .path\n\nGet file path.\n\n**Type:** `string`\n\n**Access:** Read-only\n\n**Examples:**\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);          // \"/path/to/file.txt\"\nf.close();\n```\n\n---\n\n### .mode\n\nGet open mode.\n\n**Type:** `string`\n\n**Access:** Read-only\n\n**Examples:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);          // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);         // \"w\"\nf2.close();\n```\n\n---\n\n### .closed\n\nCheck if file is closed.\n\n**Type:** `bool`\n\n**Access:** Read-only\n\n**Examples:**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);        // false\n\nf.close();\nprint(f.closed);        // true\n```\n\n---\n\n## Error Handling\n\nAll file operations include proper error messages with context:\n\n### File Not Found\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// Error: Failed to open 'missing.txt': No such file or directory\n```\n\n### Reading from Closed File\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// Error: Cannot read from closed file 'data.txt'\n```\n\n### Writing to Read-Only File\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// Error: Cannot write to file 'readonly.txt' opened in read-only mode\n```\n\n### Using try/catch\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    print(content);\n} catch (e) {\n    print(\"File error:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## Resource Management Patterns\n\n### Basic Pattern\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### With Error Handling\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // Always close, even on error\n}\n```\n\n### Safe Pattern\n\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    // ... process content ...\n} catch (e) {\n    print(\"Error:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## Usage Examples\n\n### Read Entire File\n\n```hemlock\nfn read_file(filename: string): string {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content;\n}\n\nlet text = read_file(\"data.txt\");\nprint(text);\n```\n\n### Write Text File\n\n```hemlock\nfn write_file(filename: string, content: string) {\n    let f = open(filename, \"w\");\n    f.write(content);\n    f.close();\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\\n\");\n```\n\n### Append to File\n\n```hemlock\nfn append_file(filename: string, line: string) {\n    let f = open(filename, \"a\");\n    f.write(line + \"\\n\");\n    f.close();\n}\n\nappend_file(\"log.txt\", \"Log entry 1\");\nappend_file(\"log.txt\", \"Log entry 2\");\n```\n\n### Read Binary File\n\n```hemlock\nfn read_binary(filename: string, size: i32): buffer {\n    let f = open(filename, \"r\");\n    let data = f.read_bytes(size);\n    f.close();\n    return data;\n}\n\nlet binary = read_binary(\"data.bin\", 256);\nprint(\"Read\", binary.length, \"bytes\");\n```\n\n### Write Binary File\n\n```hemlock\nfn write_binary(filename: string, data: buffer) {\n    let f = open(filename, \"w\");\n    f.write_bytes(data);\n    f.close();\n}\n\nlet buf = buffer(10);\nbuf[0] = 65;\nwrite_binary(\"output.bin\", buf);\n```\n\n### Read File Line by Line\n\n```hemlock\nfn read_lines(filename: string): array {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content.split(\"\\n\");\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line\", i, \":\", lines[i]);\n    i = i + 1;\n}\n```\n\n### Copy File\n\n```hemlock\nfn copy_file(src: string, dest: string) {\n    let f_in = open(src, \"r\");\n    let f_out = open(dest, \"w\");\n\n    let content = f_in.read();\n    f_out.write(content);\n\n    f_in.close();\n    f_out.close();\n}\n\ncopy_file(\"input.txt\", \"output.txt\");\n```\n\n### Read File in Chunks\n\n```hemlock\nfn process_chunks(filename: string) {\n    let f = open(filename, \"r\");\n\n    while (true) {\n        let chunk = f.read(1024);  // Read 1KB at a time\n        if (chunk.length == 0) {\n            break;  // EOF\n        }\n\n        // Process chunk\n        print(\"Processing\", chunk.length, \"bytes\");\n    }\n\n    f.close();\n}\n\nprocess_chunks(\"large_file.txt\");\n```\n\n---\n\n## Complete Method Summary\n\n| Method        | Signature                | Returns   | Description                  |\n|---------------|--------------------------|-----------|------------------------------|\n| `read`        | `(size?: i32)`           | `string`  | Read text                    |\n| `read_bytes`  | `(size: i32)`            | `buffer`  | Read binary data             |\n| `write`       | `(data: string)`         | `i32`     | Write text                   |\n| `write_bytes` | `(data: buffer)`         | `i32`     | Write binary data            |\n| `seek`        | `(position: i32)`        | `i32`     | Set file position            |\n| `tell`        | `()`                     | `i32`     | Get file position            |\n| `close`       | `()`                     | `null`    | Close file (idempotent)      |\n\n---\n\n## Complete Property Summary\n\n| Property  | Type     | Access     | Description              |\n|-----------|----------|------------|--------------------------|\n| `.path`   | `string` | Read-only  | File path                |\n| `.mode`   | `string` | Read-only  | Open mode                |\n| `.closed` | `bool`   | Read-only  | Whether file is closed   |\n\n---\n\n## Migration from Old API\n\n**Old API (Removed):**\n- `read_file(path)` - Use `open(path, \"r\").read()`\n- `write_file(path, data)` - Use `open(path, \"w\").write(data)`\n- `append_file(path, data)` - Use `open(path, \"a\").write(data)`\n- `file_exists(path)` - No replacement yet\n\n**Migration Example:**\n```hemlock\n// Old (v0.0)\nlet content = read_file(\"data.txt\");\nwrite_file(\"output.txt\", content);\n\n// New (v0.1)\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nf2.write(content);\nf2.close();\n```\n\n---\n\n## See Also\n\n- [Built-in Functions](#reference-builtins) - `open()` function\n- [Memory API](#reference-memory-api) - Buffer type\n- [String API](#reference-string-api) - String methods for text processing\n"}, "API Reference -> Memory API": {"id": "reference-memory-api", "content": "# Memory API Reference\n\nComplete reference for Hemlock's memory management functions and pointer types.\n\n---\n\n## Overview\n\nHemlock provides **manual memory management** with explicit allocation and deallocation. Memory is managed through two pointer types: raw pointers (`ptr`) and safe buffers (`buffer`).\n\n**Key Principles:**\n- Explicit allocation and deallocation\n- No garbage collection\n- User responsible for calling `free()`\n- Internal refcounting for scope/reassignment safety (see below)\n\n### Internal Reference Counting\n\nThe runtime uses reference counting internally to manage object lifetimes through scopes. For most local variables, cleanup is automatic.\n\n**Automatic (no `free()` needed):**\n- Local variables of refcounted types (buffer, array, object, string) are freed when scope exits\n- Old values are released when variables are reassigned\n- Container elements are released when containers are freed\n\n**Manual `free()` required:**\n- Raw pointers from `alloc()` - always\n- Early cleanup before scope ends\n- Long-lived/global data\n\nSee [Memory Management Guide](../language-guide/memory.md#internal-reference-counting) for details.\n\n---\n\n## Pointer Types\n\n### ptr (Raw Pointer)\n\n**Type:** `ptr`\n\n**Description:** Raw memory address with no bounds checking or tracking.\n\n**Size:** 8 bytes\n\n**Use Cases:**\n- Low-level memory operations\n- FFI (Foreign Function Interface)\n- Maximum performance (no overhead)\n\n**Safety:** Unsafe - no bounds checking, user must track lifetime\n\n**Examples:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n---\n\n### buffer (Safe Buffer)\n\n**Type:** `buffer`\n\n**Description:** Safe pointer wrapper with bounds checking.\n\n**Structure:** Pointer + length + capacity + ref_count\n\n**Properties:**\n- `.length` - Buffer size (i32)\n- `.capacity` - Allocated capacity (i32)\n\n**Use Cases:**\n- Most memory allocations\n- When safety is important\n- Dynamic arrays\n\n**Safety:** Bounds-checked on index access\n\n**Refcounting:** Buffers are internally refcounted. Automatically freed when scope exits or variable is reassigned. Use `free()` for early cleanup or long-lived data.\n\n**Examples:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Bounds checked\nprint(b.length);        // 64\nfree(b);\n```\n\n---\n\n## Memory Allocation Functions\n\n### alloc\n\nAllocate raw memory.\n\n**Signature:**\n```hemlock\nalloc(size: i32): ptr\n```\n\n**Parameters:**\n- `size` - Number of bytes to allocate\n\n**Returns:** Pointer to allocated memory (`ptr`)\n\n**Examples:**\n```hemlock\nlet p = alloc(1024);        // Allocate 1KB\nmemset(p, 0, 1024);         // Initialize to zero\nfree(p);                    // Free when done\n\n// Allocate for structure\nlet struct_size = 16;\nlet p2 = alloc(struct_size);\n```\n\n**Behavior:**\n- Returns uninitialized memory\n- Memory must be manually freed\n- Returns `null` on allocation failure (caller must check)\n\n**See Also:** `buffer()` for safer alternative\n\n---\n\n### buffer\n\nAllocate safe buffer with bounds checking.\n\n**Signature:**\n```hemlock\nbuffer(size: i32): buffer\n```\n\n**Parameters:**\n- `size` - Buffer size in bytes\n\n**Returns:** Buffer object\n\n**Examples:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\nprint(buf.capacity);        // 256\n\n// Access with bounds checking\nbuf[0] = 65;                // 'A'\nbuf[255] = 90;              // 'Z'\n// buf[256] = 0;            // ERROR: out of bounds\n\nfree(buf);\n```\n\n**Properties:**\n- `.length` - Current size (i32)\n- `.capacity` - Allocated capacity (i32)\n\n**Behavior:**\n- Initializes memory to zero\n- Provides bounds checking on index access\n- Returns `null` on allocation failure (caller must check)\n- Must be manually freed\n\n---\n\n### free\n\nFree allocated memory.\n\n**Signature:**\n```hemlock\nfree(ptr: ptr | buffer): null\n```\n\n**Parameters:**\n- `ptr` - Pointer or buffer to free\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\n// Free raw pointer\nlet p = alloc(1024);\nfree(p);\n\n// Free buffer\nlet buf = buffer(256);\nfree(buf);\n```\n\n**Behavior:**\n- Frees memory allocated by `alloc()` or `buffer()`\n- Double-free causes crash (user's responsibility to avoid)\n- Freeing invalid pointers causes undefined behavior\n\n**Important:** You allocate, you free. No automatic cleanup.\n\n---\n\n### realloc\n\nResize allocated memory.\n\n**Signature:**\n```hemlock\nrealloc(ptr: ptr, new_size: i32): ptr\n```\n\n**Parameters:**\n- `ptr` - Pointer to resize\n- `new_size` - New size in bytes\n\n**Returns:** Pointer to resized memory (may be different address)\n\n**Examples:**\n```hemlock\nlet p = alloc(100);\n// ... use memory ...\n\n// Need more space\np = realloc(p, 200);        // Now 200 bytes\n// ... use expanded memory ...\n\nfree(p);\n```\n\n**Behavior:**\n- May move memory to new location\n- Preserves existing data (up to minimum of old/new size)\n- Old pointer is invalid after successful realloc (use returned pointer)\n- If new_size is smaller, data is truncated\n- Returns `null` on allocation failure (original pointer remains valid)\n\n**Important:** Always check for `null` and update your pointer variable with the result.\n\n---\n\n## Memory Operations\n\n### memset\n\nFill memory with byte value.\n\n**Signature:**\n```hemlock\nmemset(ptr: ptr, byte: i32, size: i32): null\n```\n\n**Parameters:**\n- `ptr` - Pointer to memory\n- `byte` - Byte value to fill (0-255)\n- `size` - Number of bytes to fill\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nlet p = alloc(100);\n\n// Zero out memory\nmemset(p, 0, 100);\n\n// Fill with specific value\nmemset(p, 0xFF, 100);\n\n// Initialize buffer\nlet buf = alloc(256);\nmemset(buf, 65, 256);       // Fill with 'A'\n\nfree(p);\nfree(buf);\n```\n\n**Behavior:**\n- Writes byte value to each byte in range\n- Byte value is truncated to 8 bits (0-255)\n- No bounds checking (unsafe)\n\n---\n\n### memcpy\n\nCopy memory from source to destination.\n\n**Signature:**\n```hemlock\nmemcpy(dest: ptr, src: ptr, size: i32): null\n```\n\n**Parameters:**\n- `dest` - Destination pointer\n- `src` - Source pointer\n- `size` - Number of bytes to copy\n\n**Returns:** `null`\n\n**Examples:**\n```hemlock\nlet src = alloc(100);\nlet dest = alloc(100);\n\n// Initialize source\nmemset(src, 65, 100);\n\n// Copy to destination\nmemcpy(dest, src, 100);\n\n// dest now contains same data as src\n\nfree(src);\nfree(dest);\n```\n\n**Behavior:**\n- Copies byte-by-byte from src to dest\n- No bounds checking (unsafe)\n- Overlapping regions have undefined behavior (use carefully)\n\n---\n\n## Typed Memory Operations\n\n### sizeof\n\nGet size of type in bytes.\n\n**Signature:**\n```hemlock\nsizeof(type): i32\n```\n\n**Parameters:**\n- `type` - Type identifier (e.g., `i32`, `f64`, `ptr`)\n\n**Returns:** Size in bytes (i32)\n\n**Type Sizes:**\n\n| Type | Size (bytes) |\n|------|--------------|\n| `i8` | 1 |\n| `i16` | 2 |\n| `i32`, `integer` | 4 |\n| `i64` | 8 |\n| `u8`, `byte` | 1 |\n| `u16` | 2 |\n| `u32` | 4 |\n| `u64` | 8 |\n| `f32` | 4 |\n| `f64`, `number` | 8 |\n| `bool` | 1 |\n| `ptr` | 8 |\n| `rune` | 4 |\n\n**Examples:**\n```hemlock\nlet int_size = sizeof(i32);      // 4\nlet ptr_size = sizeof(ptr);      // 8\nlet float_size = sizeof(f64);    // 8\nlet byte_size = sizeof(u8);      // 1\nlet rune_size = sizeof(rune);    // 4\n\n// Calculate array allocation size\nlet count = 100;\nlet total = sizeof(i32) * count; // 400 bytes\n```\n\n**Behavior:**\n- Returns 0 for unknown types\n- Accepts both type identifiers and type strings\n\n---\n\n### talloc\n\nAllocate array of typed values.\n\n**Signature:**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**Parameters:**\n- `type` - Type to allocate (e.g., `i32`, `f64`, `ptr`)\n- `count` - Number of elements (must be positive)\n\n**Returns:** Pointer to allocated array, or `null` on allocation failure\n\n**Examples:**\n```hemlock\nlet arr = talloc(i32, 100);      // Array of 100 i32s (400 bytes)\nlet floats = talloc(f64, 50);    // Array of 50 f64s (400 bytes)\nlet bytes = talloc(u8, 1024);    // Array of 1024 bytes\n\n// Always check for allocation failure\nif (arr == null) {\n    panic(\"allocation failed\");\n}\n\n// Use the allocated memory\n// ...\n\nfree(arr);\nfree(floats);\nfree(bytes);\n```\n\n**Behavior:**\n- Allocates `sizeof(type) * count` bytes\n- Returns uninitialized memory\n- Memory must be manually freed with `free()`\n- Returns `null` on allocation failure (caller must check)\n- Panics if count is not positive\n\n---\n\n## Buffer Properties\n\n### .length\n\nGet buffer size.\n\n**Type:** `i32`\n\n**Access:** Read-only\n\n**Examples:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\n\nlet buf2 = buffer(1024);\nprint(buf2.length);         // 1024\n```\n\n---\n\n### .capacity\n\nGet buffer capacity.\n\n**Type:** `i32`\n\n**Access:** Read-only\n\n**Examples:**\n```hemlock\nlet buf = buffer(256);\nprint(buf.capacity);        // 256\n```\n\n**Note:** Currently, `.length` and `.capacity` are the same for buffers created with `buffer()`.\n\n---\n\n## Usage Patterns\n\n### Basic Allocation Pattern\n\n```hemlock\n// Allocate\nlet p = alloc(1024);\nif (p == null) {\n    panic(\"allocation failed\");\n}\n\n// Use\nmemset(p, 0, 1024);\n\n// Free\nfree(p);\n```\n\n### Safe Buffer Pattern\n\n```hemlock\n// Allocate buffer\nlet buf = buffer(256);\nif (buf == null) {\n    panic(\"buffer allocation failed\");\n}\n\n// Use with bounds checking\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\n// Free\nfree(buf);\n```\n\n### Dynamic Growth Pattern\n\n```hemlock\nlet size = 100;\nlet p = alloc(size);\nif (p == null) {\n    panic(\"allocation failed\");\n}\n\n// ... use memory ...\n\n// Need more space - check for failure\nlet new_p = realloc(p, 200);\nif (new_p == null) {\n    // Original pointer still valid, clean up\n    free(p);\n    panic(\"realloc failed\");\n}\np = new_p;\nsize = 200;\n\n// ... use expanded memory ...\n\nfree(p);\n```\n\n### Memory Copy Pattern\n\n```hemlock\nlet original = alloc(100);\nmemset(original, 65, 100);\n\n// Create copy\nlet copy = alloc(100);\nmemcpy(copy, original, 100);\n\nfree(original);\nfree(copy);\n```\n\n---\n\n## Safety Considerations\n\n**Hemlock memory management is UNSAFE by design:**\n\n### Common Pitfalls\n\n**1. Memory Leaks**\n```hemlock\n// BAD: Memory leak\nfn create_buffer() {\n    let p = alloc(1024);\n    return null;  // Memory leaked!\n}\n\n// GOOD: Proper cleanup\nfn create_buffer() {\n    let p = alloc(1024);\n    // ... use memory ...\n    free(p);\n    return null;\n}\n```\n\n**2. Use After Free**\n```hemlock\n// BAD: Use after free\nlet p = alloc(100);\nfree(p);\nmemset(p, 0, 100);  // CRASH: using freed memory\n\n// GOOD: Don't use after free\nlet p2 = alloc(100);\nmemset(p2, 0, 100);\nfree(p2);\n// Don't touch p2 after this\n```\n\n**3. Double Free**\n```hemlock\n// BAD: Double free\nlet p = alloc(100);\nfree(p);\nfree(p);  // CRASH: double free\n\n// GOOD: Free once\nlet p2 = alloc(100);\nfree(p2);\n```\n\n**4. Buffer Overflow (ptr)**\n```hemlock\n// BAD: Buffer overflow with ptr\nlet p = alloc(10);\nmemset(p, 65, 100);  // CRASH: writing past allocation\n\n// GOOD: Use buffer for bounds checking\nlet buf = buffer(10);\n// buf[100] = 65;  // ERROR: bounds check fails\n```\n\n**5. Dangling Pointers**\n```hemlock\n// BAD: Dangling pointer\nlet p1 = alloc(100);\nlet p2 = p1;\nfree(p1);\nmemset(p2, 0, 100);  // CRASH: p2 is dangling\n\n// GOOD: Track ownership carefully\nlet p = alloc(100);\n// ... use p ...\nfree(p);\n// Don't keep other references to p\n```\n\n**6. Unchecked Allocation Failure**\n```hemlock\n// BAD: Not checking for null\nlet p = alloc(1000000000);  // May fail on low memory\nmemset(p, 0, 1000000000);   // CRASH: p is null\n\n// GOOD: Always check allocation result\nlet p2 = alloc(1000000000);\nif (p2 == null) {\n    panic(\"out of memory\");\n}\nmemset(p2, 0, 1000000000);\nfree(p2);\n```\n\n---\n\n## When to Use What\n\n### Use `buffer()` when:\n- You need bounds checking\n- Working with dynamic data\n- Safety is important\n- Learning Hemlock\n\n### Use `alloc()` when:\n- Maximum performance needed\n- FFI/interfacing with C\n- You know exact memory layout\n- You're an expert\n\n### Use `realloc()` when:\n- Growing/shrinking allocations\n- Dynamic arrays\n- You need to preserve data\n\n---\n\n## Complete Function Summary\n\n| Function  | Signature                              | Returns  | Description                |\n|-----------|----------------------------------------|----------|----------------------------|\n| `alloc`   | `(size: i32)`                          | `ptr`    | Allocate raw memory        |\n| `buffer`  | `(size: i32)`                          | `buffer` | Allocate safe buffer       |\n| `free`    | `(ptr: ptr \\| buffer)`                 | `null`   | Free memory                |\n| `realloc` | `(ptr: ptr, new_size: i32)`            | `ptr`    | Resize allocation          |\n| `memset`  | `(ptr: ptr, byte: i32, size: i32)`     | `null`   | Fill memory                |\n| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`     | `null`   | Copy memory                |\n| `sizeof`  | `(type)`                               | `i32`    | Get type size in bytes     |\n| `talloc`  | `(type, count: i32)`                   | `ptr`    | Allocate typed array       |\n\n---\n\n## See Also\n\n- [Type System](#reference-type-system) - Pointer and buffer types\n- [Built-in Functions](#reference-builtins) - All built-in functions\n- [String API](#reference-string-api) - String `.to_bytes()` method\n"}, "API Reference -> Operators": {"id": "reference-operators", "content": "# Operators Reference\n\nComplete reference for all operators in Hemlock, including precedence, associativity, and behavior.\n\n---\n\n## Overview\n\nHemlock provides C-style operators with explicit precedence rules. All operators follow strict typing rules with automatic type promotion where applicable.\n\n---\n\n## Arithmetic Operators\n\n### Binary Arithmetic\n\n| Operator | Name           | Example    | Description                  |\n|----------|----------------|------------|------------------------------|\n| `+`      | Addition       | `a + b`    | Add two values               |\n| `-`      | Subtraction    | `a - b`    | Subtract b from a            |\n| `*`      | Multiplication | `a * b`    | Multiply two values          |\n| `/`      | Division       | `a / b`    | Divide a by b                |\n\n**Type Promotion:**\nResults follow type promotion rules (see [Type System](type-system.md#type-promotion-rules)).\n\n**Examples:**\n```hemlock\nlet a = 10 + 5;        // 15 (i32)\nlet b = 10 - 3;        // 7 (i32)\nlet c = 4 * 5;         // 20 (i32)\nlet d = 20 / 4;        // 5 (i32)\n\n// Float division\nlet e = 10.0 / 3.0;    // 3.333... (f64)\n\n// Mixed types\nlet f: u8 = 10;\nlet g: i32 = 20;\nlet h = f + g;         // 30 (i32, promoted)\n```\n\n**Division by Zero:**\n- Integer division by zero: Runtime error\n- Float division by zero: Returns `inf` or `-inf`\n\n---\n\n### Unary Arithmetic\n\n| Operator | Name     | Example | Description          |\n|----------|----------|---------|----------------------|\n| `-`      | Negation | `-a`    | Negate value         |\n| `+`      | Plus     | `+a`    | Identity (no-op)     |\n\n**Examples:**\n```hemlock\nlet a = 5;\nlet b = -a;            // -5\nlet c = +a;            // 5 (no change)\n\nlet x = -3.14;         // -3.14\n```\n\n---\n\n## Comparison Operators\n\n| Operator | Name                  | Example    | Returns |\n|----------|-----------------------|------------|---------|\n| `==`     | Equal                 | `a == b`   | `bool`  |\n| `!=`     | Not equal             | `a != b`   | `bool`  |\n| `<`      | Less than             | `a < b`    | `bool`  |\n| `>`      | Greater than          | `a > b`    | `bool`  |\n| `<=`     | Less than or equal    | `a <= b`   | `bool`  |\n| `>=`     | Greater than or equal | `a >= b`   | `bool`  |\n\n**Type Promotion:**\nOperands are promoted before comparison.\n\n**Examples:**\n```hemlock\nprint(5 == 5);         // true\nprint(10 != 5);        // true\nprint(3 < 7);          // true\nprint(10 > 5);         // true\nprint(5 <= 5);         // true\nprint(10 >= 5);        // true\n\n// String comparison\nprint(\"hello\" == \"hello\");  // true\nprint(\"abc\" < \"def\");       // true (lexicographic)\n\n// Mixed types\nlet a: u8 = 10;\nlet b: i32 = 10;\nprint(a == b);         // true (promoted to i32)\n```\n\n---\n\n## Logical Operators\n\n| Operator | Name        | Example      | Description              |\n|----------|-------------|--------------|--------------------------|\n| `&&`     | Logical AND | `a && b`     | True if both are true    |\n| `||`     | Logical OR  | `a || b`     | True if either is true   |\n| `!`      | Logical NOT | `!a`         | Negate boolean           |\n\n**Short-Circuit Evaluation:**\n- `&&` - Stops at first false value\n- `||` - Stops at first true value\n\n**Examples:**\n```hemlock\nlet a = true;\nlet b = false;\n\nprint(a && b);         // false\nprint(a || b);         // true\nprint(!a);             // false\nprint(!b);             // true\n\n// Short-circuit\nif (x != 0 && (10 / x) > 2) {\n    print(\"safe\");\n}\n\nif (x == 0 || (10 / x) > 2) {\n    print(\"safe\");\n}\n```\n\n---\n\n## Bitwise Operators\n\n**Restriction:** Integer types only (i8-i64, u8-u64)\n\n### Binary Bitwise\n\n| Operator | Name         | Example    | Description              |\n|----------|--------------|------------|--------------------------|\n| `&`      | Bitwise AND  | `a & b`    | AND each bit             |\n| `|`      | Bitwise OR   | `a | b`    | OR each bit              |\n| `^`      | Bitwise XOR  | `a ^ b`    | XOR each bit             |\n| `<<`     | Left shift   | `a << b`   | Shift left by b bits     |\n| `>>`     | Right shift  | `a >> b`   | Shift right by b bits    |\n\n**Type Preservation:**\nResult type matches operand types (with type promotion).\n\n**Examples:**\n```hemlock\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\n\nprint(a & b);          // 8  (1000)\nprint(a | b);          // 14 (1110)\nprint(a ^ b);          // 6  (0110)\nprint(a << 2);         // 48 (110000)\nprint(a >> 1);         // 6  (110)\n```\n\n**Unsigned Example:**\n```hemlock\nlet c: u8 = 15;        // 00001111\nlet d: u8 = 7;         // 00000111\n\nprint(c & d);          // 7  (00000111)\nprint(c | d);          // 15 (00001111)\nprint(c ^ d);          // 8  (00001000)\n```\n\n**Right Shift Behavior:**\n- Signed types: Arithmetic shift (sign-extends)\n- Unsigned types: Logical shift (zero-fills)\n\n---\n\n### Unary Bitwise\n\n| Operator | Name        | Example | Description              |\n|----------|-------------|---------|--------------------------|\n| `~`      | Bitwise NOT | `~a`    | Flip all bits            |\n\n**Examples:**\n```hemlock\nlet a = 12;            // 00001100 (i32)\nprint(~a);             // -13 (two's complement)\n\nlet b: u8 = 15;        // 00001111\nprint(~b);             // 240 (11110000)\n```\n\n---\n\n## String Operators\n\n### Concatenation\n\n| Operator | Name           | Example    | Description        |\n|----------|----------------|------------|--------------------|\n| `+`      | Concatenation  | `a + b`    | Join strings       |\n\n**Examples:**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n\n// String + rune\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\n\n// Rune + string\nlet prefix = '>' + \" Message\";     // \"> Message\"\n```\n\n---\n\n## Assignment Operators\n\n### Basic Assignment\n\n| Operator | Name       | Example    | Description              |\n|----------|------------|------------|--------------------------|\n| `=`      | Assignment | `a = b`    | Assign value to variable |\n\n**Examples:**\n```hemlock\nlet x = 10;\nx = 20;\n\nlet arr = [1, 2, 3];\narr[0] = 99;\n\nlet obj = { x: 10 };\nobj.x = 20;\n```\n\n### Compound Assignment\n\n#### Arithmetic Compound Assignment\n\n| Operator | Name            | Example    | Equivalent         |\n|----------|-----------------|------------|--------------------|\n| `+=`     | Add assign      | `a += b`   | `a = a + b`        |\n| `-=`     | Subtract assign | `a -= b`   | `a = a - b`        |\n| `*=`     | Multiply assign | `a *= b`   | `a = a * b`        |\n| `/=`     | Divide assign   | `a /= b`   | `a = a / b`        |\n| `%=`     | Modulo assign   | `a %= b`   | `a = a % b`        |\n\n**Examples:**\n```hemlock\nlet x = 10;\nx += 5;      // x is now 15\nx -= 3;      // x is now 12\nx *= 2;      // x is now 24\nx /= 4;      // x is now 6\n\nlet count = 0;\ncount += 1;  // Increment by 1\n```\n\n#### Bitwise Compound Assignment\n\n| Operator | Name               | Example     | Equivalent          |\n|----------|--------------------|-------------|---------------------|\n| `&=`     | Bitwise AND assign | `a &= b`    | `a = a & b`         |\n| `\\|=`    | Bitwise OR assign  | `a \\|= b`   | `a = a \\| b`        |\n| `^=`     | Bitwise XOR assign | `a ^= b`    | `a = a ^ b`         |\n| `<<=`    | Left shift assign  | `a <<= b`   | `a = a << b`        |\n| `>>=`    | Right shift assign | `a >>= b`   | `a = a >> b`        |\n\n**Examples:**\n```hemlock\nlet flags = 0b1111;\nflags &= 0b0011;   // flags is now 0b0011 (mask off upper bits)\nflags |= 0b1000;   // flags is now 0b1011 (set a bit)\nflags ^= 0b0001;   // flags is now 0b1010 (toggle a bit)\n\nlet x = 1;\nx <<= 4;           // x is now 16 (shift left by 4)\nx >>= 2;           // x is now 4 (shift right by 2)\n```\n\n### Increment/Decrement\n\n| Operator | Name       | Example | Description              |\n|----------|------------|---------|--------------------------|\n| `++`     | Increment  | `a++`   | Increment by 1 (postfix) |\n| `--`     | Decrement  | `a--`   | Decrement by 1 (postfix) |\n\n**Examples:**\n```hemlock\nlet i = 0;\ni++;         // i is now 1\ni++;         // i is now 2\ni--;         // i is now 1\n\n// Common in loops\nfor (let j = 0; j < 10; j++) {\n    print(j);\n}\n```\n\n**Note:** Both `++` and `--` are postfix operators (value is returned before increment/decrement)\n\n---\n\n## Null Safety Operators\n\n### Null Coalescing (`??`)\n\nReturns the left operand if it's not null, otherwise returns the right operand.\n\n| Operator | Name             | Example      | Description                    |\n|----------|------------------|--------------|--------------------------------|\n| `??`     | Null coalescing  | `a ?? b`     | Return a if not null, else b   |\n\n**Examples:**\n```hemlock\nlet name = null;\nlet display = name ?? \"Anonymous\";  // \"Anonymous\"\n\nlet value = 42;\nlet result = value ?? 0;            // 42\n\n// Chaining\nlet a = null;\nlet b = null;\nlet c = \"found\";\nlet result2 = a ?? b ?? c;          // \"found\"\n\n// With function calls\nfn get_config() { return null; }\nlet config = get_config() ?? { default: true };\n```\n\n---\n\n### Optional Chaining (`?.`)\n\nSafely access properties or call methods on potentially null values.\n\n| Operator | Name              | Example        | Description                      |\n|----------|-------------------|----------------|----------------------------------|\n| `?.`     | Optional chaining | `a?.b`         | Return a.b if a not null, else null |\n| `?.[`    | Optional index    | `a?.[0]`       | Return a[0] if a not null, else null |\n| `?.(`    | Optional call     | `a?.()`        | Call a() if a not null, else null |\n\n**Examples:**\n```hemlock\nlet user = null;\nlet name = user?.name;              // null (no error)\n\nlet person = { name: \"Alice\", address: null };\nlet city = person?.address?.city;   // null (safe navigation)\n\n// With arrays\nlet arr = null;\nlet first = arr?.[0];               // null\n\nlet items = [1, 2, 3];\nlet second = items?.[1];            // 2\n\n// With method calls\nlet obj = { greet: fn() { return \"Hello\"; } };\nlet greeting = obj?.greet?.();      // \"Hello\"\n\nlet empty = null;\nlet result = empty?.method?.();     // null\n```\n\n**Behavior:**\n- If the left operand is null, the entire expression short-circuits to null\n- If the left operand is not null, the access proceeds normally\n- Can be chained for deep property access\n\n---\n\n## Member Access Operators\n\n### Dot Operator\n\n| Operator | Name             | Example      | Description           |\n|----------|------------------|--------------|-----------------------|\n| `.`      | Member access    | `obj.field`  | Access object field   |\n| `.`      | Property access  | `arr.length` | Access property       |\n\n**Examples:**\n```hemlock\n// Object field access\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);        // \"Alice\"\n\n// Array property\nlet arr = [1, 2, 3];\nprint(arr.length);         // 3\n\n// String property\nlet s = \"hello\";\nprint(s.length);           // 5\n\n// Method call\nlet result = s.to_upper(); // \"HELLO\"\n```\n\n---\n\n### Index Operator\n\n| Operator | Name    | Example   | Description          |\n|----------|---------|-----------|----------------------|\n| `[]`     | Index   | `arr[i]`  | Access element       |\n\n**Examples:**\n```hemlock\n// Array indexing\nlet arr = [10, 20, 30];\nprint(arr[0]);             // 10\narr[1] = 99;\n\n// String indexing (returns rune)\nlet s = \"hello\";\nprint(s[0]);               // 'h'\ns[0] = 'H';                // \"Hello\"\n\n// Buffer indexing\nlet buf = buffer(10);\nbuf[0] = 65;\nprint(buf[0]);             // 65\n```\n\n---\n\n## Function Call Operator\n\n| Operator | Name          | Example      | Description        |\n|----------|---------------|--------------|--------------------|\n| `()`     | Function call | `f(a, b)`    | Call function      |\n\n**Examples:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet result = add(5, 3);    // 8\n\n// Method call\nlet s = \"hello\";\nlet upper = s.to_upper();  // \"HELLO\"\n\n// Builtin call\nprint(\"message\");\n```\n\n---\n\n## Operator Precedence\n\nOperators are listed from highest to lowest precedence:\n\n| Precedence | Operators                  | Description                    | Associativity |\n|------------|----------------------------|--------------------------------|---------------|\n| 1          | `()` `[]` `.` `?.`         | Call, index, member access, optional chain | Left-to-right |\n| 2          | `++` `--`                  | Postfix increment/decrement    | Left-to-right |\n| 3          | `!` `~` `-` (unary) `+` (unary) | Logical NOT, bitwise NOT, negation | Right-to-left |\n| 4          | `*` `/` `%`                | Multiplication, division, modulo | Left-to-right |\n| 5          | `+` `-`                    | Addition, subtraction          | Left-to-right |\n| 6          | `<<` `>>`                  | Bit shifts                     | Left-to-right |\n| 7          | `<` `<=` `>` `>=`          | Relational                     | Left-to-right |\n| 8          | `==` `!=`                  | Equality                       | Left-to-right |\n| 9          | `&`                        | Bitwise AND                    | Left-to-right |\n| 10         | `^`                        | Bitwise XOR                    | Left-to-right |\n| 11         | `|`                        | Bitwise OR                     | Left-to-right |\n| 12         | `&&`                       | Logical AND                    | Left-to-right |\n| 13         | `||`                       | Logical OR                     | Left-to-right |\n| 14         | `??`                       | Null coalescing                | Left-to-right |\n| 15         | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\\|=` `^=` `<<=` `>>=` | Assignment | Right-to-left |\n\n---\n\n## Precedence Examples\n\n### Example 1: Arithmetic and Comparison\n```hemlock\nlet result = 5 + 3 * 2;\n// Evaluated as: 5 + (3 * 2) = 11\n// Multiplication has higher precedence than addition\n\nlet cmp = 10 > 5 + 3;\n// Evaluated as: 10 > (5 + 3) = true\n// Addition has higher precedence than comparison\n```\n\n### Example 2: Bitwise Operators\n```hemlock\nlet result1 = 12 | 10 & 8;\n// Evaluated as: 12 | (10 & 8) = 12 | 8 = 12\n// & has higher precedence than |\n\nlet result2 = 8 | 1 << 2;\n// Evaluated as: 8 | (1 << 2) = 8 | 4 = 12\n// Shift has higher precedence than bitwise OR\n\n// Use parentheses for clarity\nlet result3 = (5 & 3) | (2 << 1);\n// Evaluated as: 1 | 4 = 5\n```\n\n### Example 3: Logical Operators\n```hemlock\nlet result = true || false && false;\n// Evaluated as: true || (false && false) = true\n// && has higher precedence than ||\n\nlet cmp = 5 < 10 && 10 < 20;\n// Evaluated as: (5 < 10) && (10 < 20) = true\n// Comparison has higher precedence than &&\n```\n\n### Example 4: Using Parentheses\n```hemlock\n// Without parentheses\nlet a = 2 + 3 * 4;        // 14\n\n// With parentheses\nlet b = (2 + 3) * 4;      // 20\n\n// Complex expression\nlet c = (a + b) * (a - b);\n```\n\n---\n\n## Type-Specific Operator Behavior\n\n### Division (Always Float)\n\nThe `/` operator **always returns a float** (f64), regardless of operand types:\n\n```hemlock\nprint(10 / 3);             // 3.333... (f64)\nprint(5 / 2);              // 2.5 (f64)\nprint(10.0 / 4.0);         // 2.5 (f64)\nprint(-7 / 3);             // -2.333... (f64)\n```\n\nThis prevents the common bug of unexpected integer truncation.\n\n### Floor Division (div / divi)\n\nFor floor division (like integer division in other languages), use the `div()` and `divi()` functions:\n\n```hemlock\n// div(a, b) - floor division returning float\nprint(div(5, 2));          // 2 (f64)\nprint(div(-7, 3));         // -3 (f64)  -- floors toward -infinity\n\n// divi(a, b) - floor division returning integer\nprint(divi(5, 2));         // 2 (i64)\nprint(divi(-7, 3));        // -3 (i64)\nprint(typeof(divi(5, 2))); // i64\n```\n\n**Integer-returning math functions:**\nFor other rounding operations that return integers:\n\n```hemlock\nprint(floori(3.7));        // 3 (i64)\nprint(ceili(3.2));         // 4 (i64)\nprint(roundi(3.5));        // 4 (i64)\nprint(trunci(3.9));        // 3 (i64)\n\n// These can be used directly as array indices\nlet arr = [10, 20, 30, 40];\nprint(arr[floori(1.9)]);   // 20 (index 1)\n```\n\n### String Comparison\n\nStrings are compared lexicographically:\n\n```hemlock\nprint(\"abc\" < \"def\");      // true\nprint(\"apple\" > \"banana\"); // false\nprint(\"hello\" == \"hello\"); // true\n```\n\n### Null Comparison\n\n```hemlock\nlet x = null;\n\nprint(x == null);          // true\nprint(x != null);          // false\n```\n\n### Type Errors\n\nSome operations are not allowed between incompatible types:\n\n```hemlock\n// ERROR: Cannot use bitwise operators on floats\nlet x = 3.14 & 2.71;\n\n// ERROR: Cannot use bitwise operators on strings\nlet y = \"hello\" & \"world\";\n\n// OK: Type promotion for arithmetic\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet c = a + b;             // i32 (promoted)\n```\n\n---\n\n## See Also\n\n- [Type System](#reference-type-system) - Type promotion and conversion rules\n- [Built-in Functions](#reference-builtins) - Built-in operations\n- [String API](#reference-string-api) - String concatenation and methods\n"}, "API Reference -> String API": {"id": "reference-string-api", "content": "# String API Reference\n\nComplete reference for Hemlock's string type and all 19 string methods.\n\n---\n\n## Overview\n\nStrings in Hemlock are **UTF-8 encoded, mutable, heap-allocated** sequences with full Unicode support. All operations work with **codepoints** (characters), not bytes.\n\n**Key Features:**\n- UTF-8 encoding (U+0000 to U+10FFFF)\n- Mutable (can modify characters in place)\n- Codepoint-based indexing\n- 19 built-in methods\n- Automatic concatenation with `+` operator\n\n---\n\n## String Type\n\n**Type:** `string`\n\n**Properties:**\n- `.length` - Number of codepoints (characters)\n- `.byte_length` - Number of UTF-8 bytes\n\n**Literal Syntax:** Double quotes `\"text\"`\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5 (codepoints)\nprint(s.byte_length);   // 5 (bytes)\n\nlet emoji = \"🚀\";\nprint(emoji.length);        // 1 (one codepoint)\nprint(emoji.byte_length);   // 4 (four UTF-8 bytes)\n```\n\n---\n\n## Indexing\n\nStrings support codepoint-based indexing using `[]`:\n\n**Read Access:**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Returns rune 'h'\n```\n\n**Write Access:**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Mutate with rune (now \"Hello\")\n```\n\n**UTF-8 Example:**\n```hemlock\nlet text = \"Hi🚀!\";\nprint(text[0]);         // 'H'\nprint(text[1]);         // 'i'\nprint(text[2]);         // '🚀' (one codepoint)\nprint(text[3]);         // '!'\n```\n\n---\n\n## Concatenation\n\nUse the `+` operator to concatenate strings and runes:\n\n**String + String:**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n```\n\n**String + Rune:**\n```hemlock\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\nlet decorated = \"Text\" + '✓';      // \"Text✓\"\n```\n\n**Rune + String:**\n```hemlock\nlet prefix = '>' + \" Message\";     // \"> Message\"\nlet bullet = '•' + \" Item\";        // \"• Item\"\n```\n\n**Multiple Concatenations:**\n```hemlock\nlet msg = \"Hi \" + '👋' + \" World \" + '🌍';  // \"Hi 👋 World 🌍\"\n```\n\n---\n\n## String Properties\n\n### .length\n\nGet the number of Unicode codepoints (characters).\n\n**Type:** `i32`\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5\n\nlet emoji = \"🚀\";\nprint(emoji.length);    // 1 (one codepoint)\n\nlet text = \"Hello 🌍!\";\nprint(text.length);     // 8 (7 ASCII + 1 emoji)\n```\n\n---\n\n### .byte_length\n\nGet the number of UTF-8 bytes.\n\n**Type:** `i32`\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nprint(s.byte_length);   // 5 (1 byte per ASCII char)\n\nlet emoji = \"🚀\";\nprint(emoji.byte_length); // 4 (emoji is 4 UTF-8 bytes)\n\nlet text = \"Hello 🌍!\";\nprint(text.byte_length);  // 11 (7 ASCII + 4 for emoji)\n```\n\n---\n\n## String Methods\n\n### Substring & Slicing\n\n#### substr\n\nExtract substring by position and length.\n\n**Signature:**\n```hemlock\nstring.substr(start: i32, length: i32): string\n```\n\n**Parameters:**\n- `start` - Starting codepoint index (0-based)\n- `length` - Number of codepoints to extract\n\n**Returns:** New string\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\"\nlet first = s.substr(0, 5);     // \"hello\"\n\n// UTF-8 example\nlet text = \"Hi🚀!\";\nlet emoji = text.substr(2, 1);  // \"🚀\"\n```\n\n---\n\n#### slice\n\nExtract substring by range (end exclusive).\n\n**Signature:**\n```hemlock\nstring.slice(start: i32, end: i32): string\n```\n\n**Parameters:**\n- `start` - Starting codepoint index (0-based)\n- `end` - Ending codepoint index (exclusive)\n\n**Returns:** New string\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.slice(0, 5);        // \"hello\"\nlet world = s.slice(6, 11);     // \"world\"\n\n// UTF-8 example\nlet text = \"Hi🚀!\";\nlet first_three = text.slice(0, 3);  // \"Hi🚀\"\n```\n\n---\n\n### Search & Find\n\n#### find\n\nFind first occurrence of substring.\n\n**Signature:**\n```hemlock\nstring.find(needle: string): i32\n```\n\n**Parameters:**\n- `needle` - Substring to search for\n\n**Returns:** Codepoint index of first occurrence, or `-1` if not found\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6\nlet pos2 = s.find(\"foo\");       // -1 (not found)\nlet pos3 = s.find(\"l\");         // 2 (first 'l')\n```\n\n---\n\n#### contains\n\nCheck if string contains substring.\n\n**Signature:**\n```hemlock\nstring.contains(needle: string): bool\n```\n\n**Parameters:**\n- `needle` - Substring to search for\n\n**Returns:** `true` if found, `false` otherwise\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n---\n\n### Split & Join\n\n#### split\n\nSplit string into array by delimiter.\n\n**Signature:**\n```hemlock\nstring.split(delimiter: string): array\n```\n\n**Parameters:**\n- `delimiter` - String to split on\n\n**Returns:** Array of strings\n\n**Examples:**\n```hemlock\nlet csv = \"a,b,c\";\nlet parts = csv.split(\",\");     // [\"a\", \"b\", \"c\"]\n\nlet path = \"/usr/local/bin\";\nlet dirs = path.split(\"/\");     // [\"\", \"usr\", \"local\", \"bin\"]\n\nlet text = \"hello world foo\";\nlet words = text.split(\" \");    // [\"hello\", \"world\", \"foo\"]\n```\n\n---\n\n#### trim\n\nRemove leading and trailing whitespace.\n\n**Signature:**\n```hemlock\nstring.trim(): string\n```\n\n**Returns:** New string with whitespace removed\n\n**Examples:**\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet text = \"\\n\\t  world  \\n\";\nlet clean2 = text.trim();       // \"world\"\n```\n\n---\n\n### Case Conversion\n\n#### to_upper\n\nConvert string to uppercase.\n\n**Signature:**\n```hemlock\nstring.to_upper(): string\n```\n\n**Returns:** New string in uppercase\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\nlet mixed = \"HeLLo\";\nlet upper2 = mixed.to_upper();  // \"HELLO\"\n```\n\n---\n\n#### to_lower\n\nConvert string to lowercase.\n\n**Signature:**\n```hemlock\nstring.to_lower(): string\n```\n\n**Returns:** New string in lowercase\n\n**Examples:**\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n\nlet mixed = \"HeLLo\";\nlet lower2 = mixed.to_lower();  // \"hello\"\n```\n\n---\n\n### Prefix & Suffix\n\n#### starts_with\n\nCheck if string starts with prefix.\n\n**Signature:**\n```hemlock\nstring.starts_with(prefix: string): bool\n```\n\n**Parameters:**\n- `prefix` - Prefix to check\n\n**Returns:** `true` if string starts with prefix, `false` otherwise\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n---\n\n#### ends_with\n\nCheck if string ends with suffix.\n\n**Signature:**\n```hemlock\nstring.ends_with(suffix: string): bool\n```\n\n**Parameters:**\n- `suffix` - Suffix to check\n\n**Returns:** `true` if string ends with suffix, `false` otherwise\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n---\n\n### Replacement\n\n#### replace\n\nReplace first occurrence of substring.\n\n**Signature:**\n```hemlock\nstring.replace(old: string, new: string): string\n```\n\n**Parameters:**\n- `old` - Substring to replace\n- `new` - Replacement string\n\n**Returns:** New string with first occurrence replaced\n\n**Examples:**\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");  // \"hello there\"\n\nlet text = \"foo foo foo\";\nlet text2 = text.replace(\"foo\", \"bar\"); // \"bar foo foo\" (only first)\n```\n\n---\n\n#### replace_all\n\nReplace all occurrences of substring.\n\n**Signature:**\n```hemlock\nstring.replace_all(old: string, new: string): string\n```\n\n**Parameters:**\n- `old` - Substring to replace\n- `new` - Replacement string\n\n**Returns:** New string with all occurrences replaced\n\n**Examples:**\n```hemlock\nlet text = \"foo foo foo\";\nlet text2 = text.replace_all(\"foo\", \"bar\"); // \"bar bar bar\"\n\nlet s = \"hello world hello\";\nlet s2 = s.replace_all(\"hello\", \"hi\");      // \"hi world hi\"\n```\n\n---\n\n### Repetition\n\n#### repeat\n\nRepeat string n times.\n\n**Signature:**\n```hemlock\nstring.repeat(count: i32): string\n```\n\n**Parameters:**\n- `count` - Number of repetitions\n\n**Returns:** New string repeated count times\n\n**Examples:**\n```hemlock\nlet s = \"ha\";\nlet repeated = s.repeat(3);     // \"hahaha\"\n\nlet line = \"-\";\nlet separator = line.repeat(40); // \"----------------------------------------\"\n```\n\n---\n\n### Character Access\n\n#### char_at\n\nGet Unicode codepoint at index.\n\n**Signature:**\n```hemlock\nstring.char_at(index: i32): rune\n```\n\n**Parameters:**\n- `index` - Codepoint index (0-based)\n\n**Returns:** Rune (Unicode codepoint)\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nlet ch = s.char_at(0);          // 'h'\nlet ch2 = s.char_at(1);         // 'e'\n\n// UTF-8 example\nlet emoji = \"🚀\";\nlet ch3 = emoji.char_at(0);     // U+1F680 (rocket)\n```\n\n---\n\n#### chars\n\nConvert string to array of runes.\n\n**Signature:**\n```hemlock\nstring.chars(): array\n```\n\n**Returns:** Array of runes (codepoints)\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']\n\n// UTF-8 example\nlet text = \"Hi🚀!\";\nlet chars2 = text.chars();      // ['H', 'i', '🚀', '!']\n```\n\n---\n\n### Byte Access\n\n#### byte_at\n\nGet byte value at index.\n\n**Signature:**\n```hemlock\nstring.byte_at(index: i32): u8\n```\n\n**Parameters:**\n- `index` - Byte index (0-based, NOT codepoint index)\n\n**Returns:** Byte value (u8)\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (ASCII 'h')\nlet byte2 = s.byte_at(1);       // 101 (ASCII 'e')\n\n// UTF-8 example\nlet emoji = \"🚀\";\nlet byte3 = emoji.byte_at(0);   // 240 (first UTF-8 byte)\n```\n\n---\n\n#### bytes\n\nConvert string to array of bytes.\n\n**Signature:**\n```hemlock\nstring.bytes(): array\n```\n\n**Returns:** Array of u8 bytes\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111]\n\n// UTF-8 example\nlet emoji = \"🚀\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 UTF-8 bytes)\n```\n\n---\n\n#### to_bytes\n\nConvert string to buffer.\n\n**Signature:**\n```hemlock\nstring.to_bytes(): buffer\n```\n\n**Returns:** Buffer containing UTF-8 bytes\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();\nprint(buf.length);              // 5\n\n// UTF-8 example\nlet emoji = \"🚀\";\nlet buf2 = emoji.to_bytes();\nprint(buf2.length);             // 4\n```\n\n**Note:** This is a legacy method. Prefer `.bytes()` for most use cases.\n\n---\n\n### JSON Deserialization\n\n#### deserialize\n\nParse JSON string to value.\n\n**Signature:**\n```hemlock\nstring.deserialize(): any\n```\n\n**Returns:** Parsed value (object, array, number, string, bool, or null)\n\n**Examples:**\n```hemlock\nlet json = '{\"x\":10,\"y\":20}';\nlet obj = json.deserialize();\nprint(obj.x);                   // 10\nprint(obj.y);                   // 20\n\nlet arr_json = '[1,2,3]';\nlet arr = arr_json.deserialize();\nprint(arr[0]);                  // 1\n\nlet num_json = '42';\nlet num = num_json.deserialize();\nprint(num);                     // 42\n```\n\n**Supported Types:**\n- Objects: `{\"key\": value}`\n- Arrays: `[1, 2, 3]`\n- Numbers: `42`, `3.14`\n- Strings: `\"text\"`\n- Booleans: `true`, `false`\n- Null: `null`\n\n**See Also:** Object `.serialize()` method\n\n---\n\n## Method Chaining\n\nString methods can be chained for concise operations:\n\n**Examples:**\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \");                  // \"foo | bar | baz\"\n\nlet cleaned = \"  HELLO  \"\n    .trim()\n    .to_lower();                   // \"hello\"\n```\n\n---\n\n## Complete Method Summary\n\n| Method         | Signature                                    | Returns   | Description                           |\n|----------------|----------------------------------------------|-----------|---------------------------------------|\n| `substr`       | `(start: i32, length: i32)`                  | `string`  | Extract substring by position/length  |\n| `slice`        | `(start: i32, end: i32)`                     | `string`  | Extract substring by range            |\n| `find`         | `(needle: string)`                           | `i32`     | Find first occurrence (-1 if not found)|\n| `contains`     | `(needle: string)`                           | `bool`    | Check if contains substring           |\n| `split`        | `(delimiter: string)`                        | `array`   | Split into array                      |\n| `trim`         | `()`                                         | `string`  | Remove whitespace                     |\n| `to_upper`     | `()`                                         | `string`  | Convert to uppercase                  |\n| `to_lower`     | `()`                                         | `string`  | Convert to lowercase                  |\n| `starts_with`  | `(prefix: string)`                           | `bool`    | Check if starts with prefix           |\n| `ends_with`    | `(suffix: string)`                           | `bool`    | Check if ends with suffix             |\n| `replace`      | `(old: string, new: string)`                 | `string`  | Replace first occurrence              |\n| `replace_all`  | `(old: string, new: string)`                 | `string`  | Replace all occurrences               |\n| `repeat`       | `(count: i32)`                               | `string`  | Repeat string n times                 |\n| `char_at`      | `(index: i32)`                               | `rune`    | Get codepoint at index                |\n| `byte_at`      | `(index: i32)`                               | `u8`      | Get byte at index                     |\n| `chars`        | `()`                                         | `array`   | Convert to array of runes             |\n| `bytes`        | `()`                                         | `array`   | Convert to array of bytes             |\n| `to_bytes`     | `()`                                         | `buffer`  | Convert to buffer (legacy)            |\n| `deserialize`  | `()`                                         | `any`     | Parse JSON string                     |\n\n---\n\n## See Also\n\n- [Type System](#reference-type-system) - String type details\n- [Array API](#reference-array-api) - Array methods for split() results\n- [Operators](#reference-operators) - String concatenation operator\n"}, "API Reference -> Type System": {"id": "reference-type-system", "content": "# Type System Reference\n\nComplete reference for Hemlock's type system, including all primitive and composite types.\n\n---\n\n## Overview\n\nHemlock uses a **dynamic type system** with runtime type tags and optional type annotations. Every value has a runtime type, and type conversions follow explicit promotion rules.\n\n**Key Features:**\n- Runtime type checking (interpreter)\n- Compile-time type checking (hemlockc - enabled by default)\n- Optional type annotations\n- Automatic type inference for literals\n- Explicit type promotion rules\n- No implicit conversions that lose precision\n\n---\n\n## Compile-Time Type Checking (hemlockc)\n\nThe Hemlock compiler (`hemlockc`) includes a compile-time type checker that validates your code before generating executables. This catches type errors early without needing to run the program.\n\n### Default Behavior\n\nType checking is **enabled by default** in hemlockc:\n\n```bash\n# Type checking happens automatically\nhemlockc program.hml -o program\n\n# Errors are reported before compilation\nhemlockc bad_types.hml\n# Output: 1 type error found\n```\n\n### Compiler Flags\n\n| Flag | Description |\n|------|-------------|\n| `--check` | Check types only, don't compile (exit after validation) |\n| `--no-type-check` | Disable type checking (not recommended) |\n| `--strict-types` | Enable stricter type warnings |\n\n**Examples:**\n\n```bash\n# Just validate types without compiling\nhemlockc --check program.hml\n# Output: program.hml: no type errors\n\n# Disable type checking (use with caution)\nhemlockc --no-type-check dynamic_code.hml -o program\n\n# Enable strict warnings for implicit any types\nhemlockc --strict-types program.hml -o program\n```\n\n### What the Type Checker Validates\n\n1. **Type annotations** - Ensures assigned values match declared types\n2. **Function calls** - Validates argument types against parameter types\n3. **Return types** - Checks return statements match declared return type\n4. **Operator usage** - Verifies operands are compatible\n5. **Property access** - Validates object field types for typed objects\n\n### Permissive Numeric Conversions\n\nThe type checker allows numeric type conversions at compile time, with range validation happening at runtime:\n\n```hemlock\nlet x: i8 = 100;      // OK - 100 fits in i8 (validated at runtime)\nlet y: u8 = 255;      // OK - within u8 range\nlet z: f64 = 42;      // OK - i32 to f64 is safe\n```\n\n### Dynamic Code Support\n\nCode without type annotations is treated as dynamic (`any` type) and always passes the type checker:\n\n```hemlock\nlet x = get_value();  // Dynamic - no annotation\nprocess(x);           // OK - dynamic values accepted anywhere\n```\n\n---\n\n## Primitive Types\n\n### Numeric Types\n\n#### Signed Integers\n\n| Type   | Size    | Range                                      | Alias     |\n|--------|---------|-------------------------------------------|-----------|\n| `i8`   | 1 byte  | -128 to 127                               | -         |\n| `i16`  | 2 bytes | -32,768 to 32,767                         | -         |\n| `i32`  | 4 bytes | -2,147,483,648 to 2,147,483,647           | `integer` |\n| `i64`  | 8 bytes | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | - |\n\n**Examples:**\n```hemlock\nlet a: i8 = 127;\nlet b: i16 = 32000;\nlet c: i32 = 1000000;\nlet d: i64 = 9223372036854775807;\n\n// Type alias\nlet x: integer = 42;  // Same as i32\n```\n\n#### Unsigned Integers\n\n| Type   | Size    | Range                     | Alias  |\n|--------|---------|---------------------------|--------|\n| `u8`   | 1 byte  | 0 to 255                  | `byte` |\n| `u16`  | 2 bytes | 0 to 65,535               | -      |\n| `u32`  | 4 bytes | 0 to 4,294,967,295        | -      |\n| `u64`  | 8 bytes | 0 to 18,446,744,073,709,551,615 | - |\n\n**Examples:**\n```hemlock\nlet a: u8 = 255;\nlet b: u16 = 65535;\nlet c: u32 = 4294967295;\nlet d: u64 = 18446744073709551615;\n\n// Type alias\nlet byte_val: byte = 65;  // Same as u8\n```\n\n#### Floating Point\n\n| Type   | Size    | Precision      | Alias    |\n|--------|---------|----------------|----------|\n| `f32`  | 4 bytes | ~7 digits      | -        |\n| `f64`  | 8 bytes | ~15 digits     | `number` |\n\n**Examples:**\n```hemlock\nlet pi: f32 = 3.14159;\nlet precise: f64 = 3.14159265359;\n\n// Type alias\nlet x: number = 2.718;  // Same as f64\n```\n\n---\n\n### Integer Literal Inference\n\nInteger literals are automatically typed based on their value:\n\n**Rules:**\n- Values in i32 range (-2,147,483,648 to 2,147,483,647): infer as `i32`\n- Values outside i32 range but within i64 range: infer as `i64`\n- Use explicit type annotations for other types (i8, i16, u8, u16, u32, u64)\n\n**Examples:**\n```hemlock\nlet small = 42;                    // i32 (fits in i32)\nlet large = 5000000000;            // i64 (> i32 max)\nlet max_i64 = 9223372036854775807; // i64 (INT64_MAX)\nlet explicit: u32 = 100;           // u32 (type annotation overrides)\n```\n\n---\n\n### Boolean Type\n\n**Type:** `bool`\n\n**Values:** `true`, `false`\n\n**Size:** 1 byte (internally)\n\n**Examples:**\n```hemlock\nlet is_active: bool = true;\nlet done = false;\n\nif (is_active && !done) {\n    print(\"working\");\n}\n```\n\n---\n\n### Character Types\n\n#### Rune\n\n**Type:** `rune`\n\n**Description:** Unicode codepoint (U+0000 to U+10FFFF)\n\n**Size:** 4 bytes (32-bit value)\n\n**Range:** 0 to 0x10FFFF (1,114,111)\n\n**Literal Syntax:** Single quotes `'x'`\n\n**Examples:**\n```hemlock\n// ASCII\nlet a = 'A';\nlet digit = '0';\n\n// Multi-byte UTF-8\nlet rocket = '🚀';      // U+1F680\nlet heart = '❤';        // U+2764\nlet chinese = '中';     // U+4E2D\n\n// Escape sequences\nlet newline = '\\n';\nlet tab = '\\t';\nlet backslash = '\\\\';\nlet quote = '\\'';\nlet null = '\\0';\n\n// Unicode escapes\nlet emoji = '\\u{1F680}';   // Up to 6 hex digits\nlet max = '\\u{10FFFF}';    // Maximum codepoint\n```\n\n**Type Conversions:**\n```hemlock\n// Integer to rune\nlet code: rune = 65;        // 'A'\nlet r: rune = 128640;       // 🚀\n\n// Rune to integer\nlet value: i32 = 'Z';       // 90\n\n// Rune to string\nlet s: string = 'H';        // \"H\"\n\n// u8 to rune\nlet byte: u8 = 65;\nlet rune_val: rune = byte;  // 'A'\n```\n\n**See Also:** [String API](#reference-string-api) for string + rune concatenation\n\n---\n\n### String Type\n\n**Type:** `string`\n\n**Description:** UTF-8 encoded, mutable, heap-allocated text\n\n**Encoding:** UTF-8 (U+0000 to U+10FFFF)\n\n**Mutability:** Mutable (unlike most languages)\n\n**Properties:**\n- `.length` - Codepoint count (number of characters)\n- `.byte_length` - Byte count (UTF-8 encoding size)\n\n**Literal Syntax:** Double quotes `\"text\"`\n\n**Examples:**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Mutate (now \"Hello\")\nprint(s.length);        // 5 (codepoint count)\nprint(s.byte_length);   // 5 (UTF-8 bytes)\n\nlet emoji = \"🚀\";\nprint(emoji.length);        // 1 (one codepoint)\nprint(emoji.byte_length);   // 4 (four UTF-8 bytes)\n```\n\n**Indexing:**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Returns rune 'h'\ns[0] = 'H';             // Set with rune\n```\n\n**See Also:** [String API](#reference-string-api) for complete method reference\n\n---\n\n### Null Type\n\n**Type:** `null`\n\n**Description:** The null value (absence of value)\n\n**Size:** 8 bytes (internally)\n\n**Value:** `null`\n\n**Examples:**\n```hemlock\nlet x = null;\nlet y: i32 = null;  // ERROR: type mismatch\n\nif (x == null) {\n    print(\"x is null\");\n}\n```\n\n---\n\n## Composite Types\n\n### Array Type\n\n**Type:** `array`\n\n**Description:** Dynamic, heap-allocated, mixed-type array\n\n**Properties:**\n- `.length` - Number of elements\n\n**Zero-indexed:** Yes\n\n**Literal Syntax:** `[elem1, elem2, ...]`\n\n**Examples:**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Mixed types\nlet mixed = [1, \"hello\", true, null];\n```\n\n**See Also:** [Array API](#reference-array-api) for complete method reference\n\n---\n\n### Object Type\n\n**Type:** `object`\n\n**Description:** JavaScript-style object with dynamic fields\n\n**Literal Syntax:** `{ field: value, ... }`\n\n**Examples:**\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);  // \"Alice\"\n\n// Add field dynamically\nperson.email = \"alice@example.com\";\n```\n\n**Type Definitions:**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: bool,  // Optional field\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\nprint(typeof(p));  // \"Person\"\n```\n\n---\n\n### Pointer Types\n\n#### Raw Pointer (ptr)\n\n**Type:** `ptr`\n\n**Description:** Raw memory address (unsafe)\n\n**Size:** 8 bytes\n\n**Bounds Checking:** None\n\n**Examples:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n#### Buffer (buffer)\n\n**Type:** `buffer`\n\n**Description:** Safe pointer wrapper with bounds checking\n\n**Structure:** Pointer + length + capacity\n\n**Properties:**\n- `.length` - Buffer size\n- `.capacity` - Allocated capacity\n\n**Examples:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Bounds checked\nprint(b.length);        // 64\nfree(b);\n```\n\n**See Also:** [Memory API](#reference-memory-api) for allocation functions\n\n---\n\n## Special Types\n\n### File Type\n\n**Type:** `file`\n\n**Description:** File handle for I/O operations\n\n**Properties:**\n- `.path` - File path (string)\n- `.mode` - Open mode (string)\n- `.closed` - Whether file is closed (bool)\n\n**See Also:** [File API](#reference-file-api)\n\n---\n\n### Task Type\n\n**Type:** `task`\n\n**Description:** Handle for concurrent task\n\n**See Also:** [Concurrency API](#reference-concurrency-api)\n\n---\n\n### Channel Type\n\n**Type:** `channel`\n\n**Description:** Thread-safe communication channel\n\n**See Also:** [Concurrency API](#reference-concurrency-api)\n\n---\n\n### Function Type\n\n**Type:** `function`\n\n**Description:** First-class function value\n\n**Examples:**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(typeof(add));      // \"function\"\nprint(typeof(multiply)); // \"function\"\n```\n\n---\n\n### Void Type\n\n**Type:** `void`\n\n**Description:** Absence of return value (internal use)\n\n---\n\n## Type Promotion Rules\n\nWhen mixing types in operations, Hemlock promotes to the \"higher\" type:\n\n**Promotion Hierarchy:**\n```\nf64 (highest precision)\n ↑\nf32\n ↑\nu64\n ↑\ni64\n ↑\nu32\n ↑\ni32\n ↑\nu16\n ↑\ni16\n ↑\nu8\n ↑\ni8 (lowest)\n```\n\n**Rules:**\n1. Float always wins over integer\n2. Larger size wins within same category (int/uint/float)\n3. Both operands are promoted to result type\n4. **Precision preservation:** i64/u64 + f32 promotes to f64 (not f32)\n\n**Examples:**\n```hemlock\n// Size promotion\nu8 + i32    → i32    // Larger size wins\ni32 + i64   → i64    // Larger size wins\nu32 + u64   → u64    // Larger size wins\n\n// Float promotion\ni32 + f32   → f32    // Float wins, f32 sufficient for i32\ni64 + f32   → f64    // Promotes to f64 to preserve i64 precision\ni64 + f64   → f64    // Float always wins\ni8 + f64    → f64    // Float + largest wins\n```\n\n**Why i64 + f32 → f64?**\n\nf32 has only a 24-bit mantissa, which cannot precisely represent integers larger\nthan 2^24 (16,777,216). Since i64 can hold values up to 2^63, mixing i64 with f32\nwould cause severe precision loss. Hemlock promotes to f64 (53-bit mantissa) instead.\n\n---\n\n## Range Checking\n\nType annotations enforce range checks at assignment:\n\n**Valid Assignments:**\n```hemlock\nlet x: u8 = 255;             // OK\nlet y: i8 = 127;             // OK\nlet a: i64 = 2147483647;     // OK\nlet b: u64 = 4294967295;     // OK\n```\n\n**Invalid Assignments (Runtime Error):**\n```hemlock\nlet x: u8 = 256;             // ERROR: out of range\nlet y: i8 = 128;             // ERROR: max is 127\nlet z: u64 = -1;             // ERROR: u64 cannot be negative\n```\n\n---\n\n## Type Introspection\n\n### typeof(value)\n\nReturns the type name as a string.\n\n**Signature:**\n```hemlock\ntypeof(value: any): string\n```\n\n**Returns:**\n- Primitive types: `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"`, `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"`, `\"f32\"`, `\"f64\"`, `\"bool\"`, `\"string\"`, `\"rune\"`, `\"null\"`\n- Composite types: `\"array\"`, `\"object\"`, `\"ptr\"`, `\"buffer\"`, `\"function\"`\n- Special types: `\"file\"`, `\"task\"`, `\"channel\"`\n- Typed objects: Custom type name (e.g., `\"Person\"`)\n\n**Examples:**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n```\n\n**See Also:** [Built-in Functions](builtins.md#typeof)\n\n---\n\n## Type Conversions\n\n### Implicit Conversions\n\nHemlock performs implicit type conversions in arithmetic operations following the type promotion rules.\n\n**Examples:**\n```hemlock\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet result = a + b;     // result is i32 (promoted)\n```\n\n### Explicit Conversions\n\nUse type annotations for explicit conversions:\n\n**Examples:**\n```hemlock\n// Integer to float\nlet i: i32 = 42;\nlet f: f64 = i;         // 42.0\n\n// Float to integer (truncates)\nlet x: f64 = 3.14;\nlet y: i32 = x;         // 3\n\n// Integer to rune\nlet code: rune = 65;    // 'A'\n\n// Rune to integer\nlet value: i32 = 'Z';   // 90\n\n// Rune to string\nlet s: string = 'H';    // \"H\"\n```\n\n---\n\n## Type Aliases\n\n### Built-in Aliases\n\nHemlock provides built-in type aliases for common types:\n\n| Alias     | Actual Type | Usage                    |\n|-----------|-------------|--------------------------|\n| `integer` | `i32`       | General-purpose integers |\n| `number`  | `f64`       | General-purpose floats   |\n| `byte`    | `u8`        | Byte values              |\n\n**Examples:**\n```hemlock\nlet count: integer = 100;       // Same as i32\nlet price: number = 19.99;      // Same as f64\nlet b: byte = 255;              // Same as u8\n```\n\n### Custom Type Aliases\n\nDefine custom type aliases using the `type` keyword:\n\n```hemlock\n// Simple aliases\ntype Integer = i32;\ntype Text = string;\n\n// Function type aliases\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\n// Compound type aliases\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// Generic type aliases\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n```\n\n**Using custom aliases:**\n```hemlock\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**Note:** Type aliases are transparent - `typeof()` returns the underlying type name.\n\n---\n\n## Function Types\n\nFunction types specify the signature of function values:\n\n### Syntax\n\n```hemlock\nfn(param_types): return_type\n```\n\n### Examples\n\n```hemlock\n// Basic function type\nlet add: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// Function parameter\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Higher-order function returning function\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Async function type\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n```\n\n---\n\n## Compound Types (Intersection)\n\nCompound types use `&` to require multiple type constraints:\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// Object must satisfy all types\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// Three or more types\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n---\n\n## Summary Table\n\n| Type       | Size     | Mutable | Heap-allocated | Description                    |\n|------------|----------|---------|----------------|--------------------------------|\n| `i8`-`i64` | 1-8 bytes| No      | No             | Signed integers                |\n| `u8`-`u64` | 1-8 bytes| No      | No             | Unsigned integers              |\n| `f32`      | 4 bytes  | No      | No             | Single-precision float         |\n| `f64`      | 8 bytes  | No      | No             | Double-precision float         |\n| `bool`     | 1 byte   | No      | No             | Boolean                        |\n| `rune`     | 4 bytes  | No      | No             | Unicode codepoint              |\n| `string`   | Variable | Yes     | Yes            | UTF-8 text                     |\n| `array`    | Variable | Yes     | Yes            | Dynamic array                  |\n| `object`   | Variable | Yes     | Yes            | Dynamic object                 |\n| `ptr`      | 8 bytes  | No      | No             | Raw pointer                    |\n| `buffer`   | Variable | Yes     | Yes            | Safe pointer wrapper           |\n| `file`     | Opaque   | Yes     | Yes            | File handle                    |\n| `task`     | Opaque   | No      | Yes            | Concurrent task handle         |\n| `channel`  | Opaque   | Yes     | Yes            | Thread-safe channel            |\n| `function` | Opaque   | No      | Yes            | Function value                 |\n| `null`     | 8 bytes  | No      | No             | Null value                     |\n\n---\n\n## See Also\n\n- [Operators Reference](#reference-operators) - Type behavior in operations\n- [Built-in Functions](#reference-builtins) - Type introspection and conversion\n- [String API](#reference-string-api) - String type methods\n- [Array API](#reference-array-api) - Array type methods\n- [Memory API](#reference-memory-api) - Pointer and buffer operations\n"}, "Design & Philosophy -> Implementation": {"id": "design-implementation", "content": "# Hemlock Implementation Details\n\nThis document describes the technical implementation of the Hemlock language, including project structure, compilation pipeline, runtime architecture, and design decisions.\n\n---\n\n## Table of Contents\n\n- [Project Structure](#project-structure)\n- [Compilation Pipeline](#compilation-pipeline)\n- [Modular Interpreter Design](#modular-interpreter-design)\n- [Runtime Architecture](#runtime-architecture)\n- [Value Representation](#value-representation)\n- [Type System Implementation](#type-system-implementation)\n- [Memory Management](#memory-management)\n- [Concurrency Model](#concurrency-model)\n- [Future Plans](#future-plans)\n\n---\n\n## Project Structure\n\n```\nhemlock/\n├── src/\n│   ├── frontend/              # Shared: lexer, parser, AST\n│   │   ├── lexer.c            # Tokenization\n│   │   ├── parser/            # Recursive descent parser\n│   │   ├── ast.c              # AST node management\n│   │   └── module.c           # Module resolution\n│   ├── backends/\n│   │   ├── interpreter/       # hemlock: tree-walking interpreter\n│   │   │   ├── main.c         # CLI entry point\n│   │   │   ├── runtime.c      # Expression/statement evaluation\n│   │   │   ├── builtins.c     # Built-in functions\n│   │   │   └── ...\n│   │   └── compiler/          # hemlockc: C code generator\n│   │       ├── main.c         # CLI, orchestration\n│   │       ├── type_check.c   # Compile-time type checking\n│   │       ├── codegen.c      # Code generation context\n│   │       ├── codegen_expr.c # Expression codegen\n│   │       ├── codegen_stmt.c # Statement codegen\n│   │       └── ...\n│   ├── tools/\n│   │   ├── lsp/               # Language Server Protocol\n│   │   └── bundler/           # Bundle/package tools\n├── runtime/                   # libhemlock_runtime.a (for compiled programs)\n├── stdlib/                    # Standard library (39 modules)\n│   └── docs/                  # Module documentation\n├── tests/\n│   ├── parity/                # Tests that must pass both backends\n│   ├── interpreter/           # Interpreter-specific tests\n│   └── compiler/              # Compiler-specific tests\n├── examples/                  # Example programs\n└── docs/                      # Documentation\n```\n\n### Directory Organization\n\n**`include/`** - Public API headers that define the interface between components:\n- Clean separation between lexer, parser, AST, and interpreter\n- Forward declarations to minimize dependencies\n- Public API for embedding Hemlock in other programs\n\n**`src/`** - Implementation files:\n- Top-level files handle lexing, parsing, AST management\n- `main.c` provides CLI and REPL\n- Interpreter is modularized into separate subsystems\n\n**`src/interpreter/`** - Modular interpreter implementation:\n- Each module has a single, clear responsibility\n- Internal API defined in `internal.h` for inter-module communication\n- Modules can be compiled independently for faster builds\n\n**`tests/`** - Comprehensive test suite:\n- Organized by feature area\n- Each directory contains focused test cases\n- `run_tests.sh` orchestrates test execution\n\n---\n\n## Compilation Pipeline\n\nHemlock uses a traditional compilation pipeline with distinct phases:\n\n### Phase 1: Lexical Analysis (Lexer)\n\n**Input:** Source code text\n**Output:** Token stream\n**Implementation:** `src/lexer.c`\n\n```\nSource: \"let x = 42;\"\n   ↓\nTokens: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n```\n\n**Key features:**\n- Recognizes keywords, identifiers, literals, operators, punctuation\n- Handles UTF-8 string literals and rune literals\n- Reports line numbers for error messages\n- Single-pass, no backtracking\n\n### Phase 2: Syntax Analysis (Parser)\n\n**Input:** Token stream\n**Output:** Abstract Syntax Tree (AST)\n**Implementation:** `src/parser.c`\n\n```\nTokens: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n   ↓\nAST: LetStmt {\n    name: \"x\",\n    type: null,\n    value: IntLiteral(42)\n}\n```\n\n**Key features:**\n- Recursive descent parser\n- Builds tree representation of program structure\n- Handles operator precedence\n- Validates syntax (braces, semicolons, etc.)\n- No semantic analysis yet (done at runtime)\n\n**Operator Precedence (lowest to highest):**\n1. Assignment: `=`\n2. Logical OR: `||`\n3. Logical AND: `&&`\n4. Bitwise OR: `|`\n5. Bitwise XOR: `^`\n6. Bitwise AND: `&`\n7. Equality: `==`, `!=`\n8. Comparison: `<`, `>`, `<=`, `>=`\n9. Bitwise shifts: `<<`, `>>`\n10. Addition/Subtraction: `+`, `-`\n11. Multiplication/Division/Modulo: `*`, `/`, `%`\n12. Unary: `!`, `-`, `~`\n13. Call/Index/Member: `()`, `[]`, `.`\n\n### Phase 3a: Interpretation (Tree-Walking)\n\n**Input:** AST\n**Output:** Program execution\n**Implementation:** `src/backends/interpreter/runtime.c`\n\n```\nAST: LetStmt { ... }\n   ↓\nExecution: Evaluates AST nodes recursively\n   ↓\nResult: Variable x created with value 42\n```\n\n**Key features:**\n- Direct AST traversal (tree-walking interpreter)\n- Dynamic type checking at runtime\n- Environment-based variable storage\n\n### Phase 3b: Compilation (hemlockc)\n\n**Input:** AST\n**Output:** Native executable via C code generation\n**Implementation:** `src/backends/compiler/`\n\n```\nAST: LetStmt { ... }\n   ↓\nType Check: Validate types at compile time\n   ↓\nC Codegen: Generate equivalent C code\n   ↓\nGCC: Compile C to native binary\n   ↓\nResult: Standalone executable\n```\n\n**Key features:**\n- Compile-time type checking (enabled by default)\n- C code generation for portability\n- Links against `libhemlock_runtime.a`\n- Significantly faster execution than interpreter\n\n---\n\n## Compiler Backend (hemlockc)\n\nThe Hemlock compiler generates C code from the AST, which is then compiled to a native executable using GCC.\n\n### Compiler Architecture\n\n```\nsrc/backends/compiler/\n├── main.c              # CLI, argument parsing, orchestration\n├── codegen.c           # Core code generation context\n├── codegen_expr.c      # Expression code generation\n├── codegen_stmt.c      # Statement code generation\n├── codegen_call.c      # Function call generation\n├── codegen_closure.c   # Closure implementation\n├── codegen_program.c   # Top-level program generation\n├── codegen_module.c    # Module/import handling\n├── type_check.c        # Compile-time type checking\n└── type_check.h        # Type checker API\n```\n\n### Type Checking\n\nThe compiler includes a unified type checking system that:\n\n1. **Validates types at compile time** - Catches type errors before execution\n2. **Supports dynamic code** - Untyped code treated as `any` (always valid)\n3. **Provides optimization hints** - Identifies variables that can be unboxed\n\n**Type Checking Flags:**\n\n| Flag | Description |\n|------|-------------|\n| (default) | Type checking enabled |\n| `--check` | Type check only, don't compile |\n| `--no-type-check` | Disable type checking |\n| `--strict-types` | Warn on implicit `any` types |\n\n**Type Checker Implementation:**\n\n```c\n// type_check.h - Key structures\ntypedef struct TypeCheckContext {\n    const char *filename;\n    int error_count;\n    int warning_count;\n    UnboxableVar *unboxable_vars;  // Optimization hints\n    // ... type environment, definitions, etc.\n} TypeCheckContext;\n\n// Main entry point\nint type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);\n```\n\n### Code Generation\n\nThe codegen phase translates AST nodes to C code:\n\n**Expression Mapping:**\n```\nHemlock                 →  Generated C\n----------------------------------------\nlet x = 42;            →  HmlValue x = hml_val_i32(42);\nx + y                  →  hml_add(x, y)\narr[i]                 →  hml_array_get(arr, i)\nobj.field              →  hml_object_get_field(obj, \"field\")\nfn(a, b) { ... }       →  Closure with environment capture\n```\n\n**Runtime Integration:**\n\nGenerated C code links against `libhemlock_runtime.a` which provides:\n- `HmlValue` tagged union type\n- Memory management (reference counting)\n- Built-in functions (print, typeof, etc.)\n- Concurrency primitives (tasks, channels)\n- FFI support\n\n### Unboxing Optimization\n\nThe type checker identifies variables that can use native C types instead of boxed `HmlValue`:\n\n**Unboxable Patterns:**\n- Loop counters with known integer type\n- Accumulator variables in loops\n- Variables with explicit type annotations (i32, i64, f64, bool)\n\n```hemlock\n// Loop counter 'i' can be unboxed to native int32_t\nfor (let i: i32 = 0; i < 1000000; i = i + 1) {\n    sum = sum + i;\n}\n```\n\n---\n\n## Modular Interpreter Design\n\nThe interpreter is split into focused modules for maintainability and scalability.\n\n### Module Responsibilities\n\n#### 1. Environment (`environment.c`) - 121 lines\n\n**Purpose:** Variable scoping and name resolution\n\n**Key functions:**\n- `env_create()` - Create new environment with optional parent\n- `env_define()` - Define new variable in current scope\n- `env_get()` - Lookup variable in current or parent scopes\n- `env_set()` - Update existing variable value\n- `env_free()` - Free environment and all variables\n\n**Design:**\n- Linked scopes (each environment has pointer to parent)\n- HashMap for fast variable lookup\n- Supports lexical scoping for closures\n\n#### 2. Values (`values.c`) - 394 lines\n\n**Purpose:** Value constructors and data structure management\n\n**Key functions:**\n- `value_create_*()` - Constructors for each value type\n- `value_copy()` - Deep/shallow copying logic\n- `value_free()` - Cleanup and memory deallocation\n- `value_to_string()` - String representation for printing\n\n**Data structures:**\n- Objects (dynamic field arrays)\n- Arrays (dynamic resizing)\n- Buffers (ptr + length + capacity)\n- Closures (function + captured environment)\n- Tasks and Channels (concurrency primitives)\n\n#### 3. Types (`types.c`) - 440 lines\n\n**Purpose:** Type system, conversions, and duck typing\n\n**Key functions:**\n- `type_check()` - Runtime type validation\n- `type_convert()` - Implicit type conversions/promotions\n- `duck_type_check()` - Structural type checking for objects\n- `type_name()` - Get printable type name\n\n**Features:**\n- Type promotion hierarchy (i8 → i16 → i32 → i64 → f32 → f64, with i64/u64 + f32 → f64)\n- Range checking for numeric types\n- Duck typing for object type definitions\n- Optional field defaults\n\n#### 4. Builtins (`builtins.c`) - 955 lines\n\n**Purpose:** Built-in functions and global registration\n\n**Key functions:**\n- `register_builtins()` - Register all built-in functions and constants\n- Built-in function implementations (print, typeof, alloc, free, etc.)\n- Signal handling functions\n- Command execution (exec)\n\n**Categories of builtins:**\n- I/O: print, open, read_file, write_file\n- Memory: alloc, free, memset, memcpy, realloc\n- Types: typeof, assert\n- Concurrency: spawn, join, detach, channel\n- System: exec, signal, raise, panic\n- FFI: dlopen, dlsym, dlcall, dlclose\n\n#### 5. I/O (`io.c`) - 449 lines\n\n**Purpose:** File I/O and JSON serialization\n\n**Key functions:**\n- File object methods (read, write, seek, tell, close)\n- JSON serialization/deserialization\n- Circular reference detection\n\n**Features:**\n- File object with properties (path, mode, closed)\n- UTF-8 aware text I/O\n- Binary I/O support\n- JSON round-tripping for objects and arrays\n\n#### 6. FFI (`ffi.c`) - Foreign Function Interface\n\n**Purpose:** Calling C functions from shared libraries\n\n**Key functions:**\n- `dlopen()` - Load shared library\n- `dlsym()` - Get function pointer by name\n- `dlcall()` - Call C function with type conversion\n- `dlclose()` - Unload library\n\n**Features:**\n- Integration with libffi for dynamic function calls\n- Automatic type conversion (Hemlock ↔ C types)\n- Support for all primitive types\n- Pointer and buffer support\n\n#### 7. Runtime (`runtime.c`) - 865 lines\n\n**Purpose:** Expression evaluation and statement execution\n\n**Key functions:**\n- `eval_expr()` - Evaluate expressions (recursive)\n- `eval_stmt()` - Execute statements\n- Control flow handling (if, while, for, switch, etc.)\n- Exception handling (try/catch/finally/throw)\n\n**Features:**\n- Recursive expression evaluation\n- Short-circuit boolean evaluation\n- Method call detection and `self` binding\n- Exception propagation\n- Break/continue/return handling\n\n### Benefits of Modular Design\n\n**1. Separation of Concerns**\n- Each module has one clear responsibility\n- Easy to find where features are implemented\n- Reduces cognitive load when making changes\n\n**2. Faster Incremental Builds**\n- Only modified modules need recompilation\n- Parallel compilation possible\n- Shorter iteration times during development\n\n**3. Easier Testing and Debugging**\n- Modules can be tested in isolation\n- Bugs are localized to specific subsystems\n- Mock implementations possible for testing\n\n**4. Scalability**\n- New features can be added to appropriate modules\n- Modules can be refactored independently\n- Code size per file stays manageable\n\n**5. Code Organization**\n- Logical grouping of related functionality\n- Clear dependency graph\n- Easier onboarding for new contributors\n\n---\n\n## Runtime Architecture\n\n### Value Representation\n\nAll values in Hemlock are represented by the `Value` struct using a tagged union:\n\n```c\ntypedef struct Value {\n    ValueType type;  // Runtime type tag\n    union {\n        int32_t i32_value;\n        int64_t i64_value;\n        uint8_t u8_value;\n        uint32_t u32_value;\n        uint64_t u64_value;\n        float f32_value;\n        double f64_value;\n        bool bool_value;\n        char *string_value;\n        uint32_t rune_value;\n        void *ptr_value;\n        Buffer *buffer_value;\n        Array *array_value;\n        Object *object_value;\n        Function *function_value;\n        File *file_value;\n        Task *task_value;\n        Channel *channel_value;\n    };\n} Value;\n```\n\n**Design decisions:**\n- **Tagged union** for type safety while maintaining flexibility\n- **Runtime type tags** enable dynamic typing with type checking\n- **Direct value storage** for primitives (no boxing)\n- **Pointer storage** for heap-allocated types (strings, objects, arrays)\n\n### Memory Layout Examples\n\n**Integer (i32):**\n```\nValue {\n    type: TYPE_I32,\n    i32_value: 42\n}\n```\n- Total size: ~16 bytes (8-byte tag + 8-byte union)\n- Stack allocated\n- No heap allocation needed\n\n**String:**\n```\nValue {\n    type: TYPE_STRING,\n    string_value: 0x7f8a4c000000  // Pointer to heap\n}\n\nHeap: \"hello\\0\" (6 bytes, null-terminated UTF-8)\n```\n- Value is 16 bytes on stack\n- String data is heap-allocated\n- Must be freed manually\n\n**Object:**\n```\nValue {\n    type: TYPE_OBJECT,\n    object_value: 0x7f8a4c001000  // Pointer to heap\n}\n\nHeap: Object {\n    type_name: \"Person\",\n    fields: [\n        { name: \"name\", value: Value{TYPE_STRING, \"Alice\"} },\n        { name: \"age\", value: Value{TYPE_I32, 30} }\n    ],\n    field_count: 2,\n    capacity: 4\n}\n```\n- Object structure on heap\n- Fields stored in dynamic array\n- Field values are embedded Value structs\n\n### Environment Implementation\n\nVariables are stored in environment chains:\n\n```c\ntypedef struct Environment {\n    HashMap *bindings;           // name → Value\n    struct Environment *parent;  // Lexical parent scope\n} Environment;\n```\n\n**Scope chain example:**\n```\nGlobal Scope: { print: <builtin>, args: <array> }\n    ↑\nFunction Scope: { x: 10, y: 20 }\n    ↑\nBlock Scope: { i: 0 }\n```\n\n**Lookup algorithm:**\n1. Check current environment's hashmap\n2. If not found, check parent environment\n3. Repeat until found or reach global scope\n4. Error if not found in any scope\n\n---\n\n## Type System Implementation\n\n### Type Checking Strategy\n\nHemlock uses **runtime type checking** with **optional type annotations**:\n\n```hemlock\nlet x = 42;           // No type check, infers i32\nlet y: u8 = 255;      // Runtime check: value must fit in u8\nlet z: i32 = x + y;   // Runtime check + type promotion\n```\n\n**Implementation flow:**\n1. **Literal inference** - Lexer/parser determine initial type from literal\n2. **Type annotation check** - If annotation present, validate at assignment\n3. **Promotion** - Binary operations promote to common type\n4. **Conversion** - Explicit conversions happen on demand\n\n### Type Promotion Implementation\n\nType promotion follows a fixed hierarchy with precision preservation:\n\n```c\n// Simplified promotion logic\nValueType promote_types(ValueType a, ValueType b) {\n    // f64 always wins\n    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;\n\n    // f32 with i64/u64 promotes to f64 (precision preservation)\n    if (a == TYPE_F32 || b == TYPE_F32) {\n        ValueType other = (a == TYPE_F32) ? b : a;\n        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;\n        return TYPE_F32;\n    }\n\n    // Larger integer types win\n    int rank_a = get_type_rank(a);\n    int rank_b = get_type_rank(b);\n    return (rank_a > rank_b) ? a : b;\n}\n```\n\n**Type ranks:**\n- i8: 0\n- u8: 1\n- i16: 2\n- u16: 3\n- i32: 4\n- u32: 5\n- i64: 6\n- u64: 7\n- f32: 8\n- f64: 9\n\n### Duck Typing Implementation\n\nObject type checking uses structural comparison:\n\n```c\nbool duck_type_check(Object *obj, TypeDef *type_def) {\n    // Check all required fields\n    for (each field in type_def) {\n        if (!object_has_field(obj, field.name)) {\n            return false;  // Missing field\n        }\n\n        Value *field_value = object_get_field(obj, field.name);\n        if (!type_matches(field_value, field.type)) {\n            return false;  // Wrong type\n        }\n    }\n\n    return true;  // All required fields present and correct type\n}\n```\n\n**Duck typing allows:**\n- Extra fields in objects (ignored)\n- Substructural typing (object can have more than required)\n- Type name assignment after validation\n\n---\n\n## Memory Management\n\n### Allocation Strategy\n\nHemlock uses **manual memory management** with two allocation primitives:\n\n**1. Raw pointers (`ptr`):**\n```c\nvoid *alloc(size_t bytes) {\n    void *ptr = malloc(bytes);\n    if (!ptr) {\n        fprintf(stderr, \"Out of memory\\n\");\n        exit(1);\n    }\n    return ptr;\n}\n```\n- Direct malloc/free\n- No tracking\n- User responsibility to free\n\n**2. Buffers (`buffer`):**\n```c\ntypedef struct Buffer {\n    void *data;\n    size_t length;\n    size_t capacity;\n} Buffer;\n\nBuffer *create_buffer(size_t size) {\n    Buffer *buf = malloc(sizeof(Buffer));\n    buf->data = malloc(size);\n    buf->length = size;\n    buf->capacity = size;\n    return buf;\n}\n```\n- Tracks size and capacity\n- Bounds checking on access\n- Still requires manual free\n\n### Heap-Allocated Types\n\n**Strings:**\n- UTF-8 byte array on heap\n- Null-terminated for C interop\n- Mutable (can modify in place)\n- Refcounted (auto-freed when scope exits)\n\n**Objects:**\n- Dynamic field array\n- Field names and values on heap\n- Refcounted (auto-freed when scope exits)\n- Circular references possible (handled with visited-set tracking)\n\n**Arrays:**\n- Dynamic capacity doubling growth\n- Elements are embedded Value structs\n- Automatic reallocation on growth\n- Refcounted (auto-freed when scope exits)\n\n**Closures:**\n- Captures environment by reference\n- Environment is heap-allocated\n- Closure environments are properly freed when no longer referenced\n\n---\n\n## Concurrency Model\n\n### Threading Architecture\n\nHemlock uses **1:1 threading** with POSIX threads (pthreads):\n\n```\nUser Task          OS Thread          CPU Core\n---------          ---------          --------\nspawn(f1) ------>  pthread_create --> Core 0\nspawn(f2) ------>  pthread_create --> Core 1\nspawn(f3) ------>  pthread_create --> Core 2\n```\n\n**Key characteristics:**\n- Each `spawn()` creates a new pthread\n- Kernel schedules threads across cores\n- True parallel execution (no GIL)\n- Pre-emptive multitasking\n\n### Task Implementation\n\n```c\ntypedef struct Task {\n    pthread_t thread;        // OS thread handle\n    Value result;            // Return value\n    char *error;             // Exception message (if thrown)\n    pthread_mutex_t lock;    // Protects state\n    TaskState state;         // RUNNING, FINISHED, ERROR\n} Task;\n```\n\n**Task lifecycle:**\n1. `spawn(func, args)` → Create Task, start pthread\n2. Thread runs function with arguments\n3. On return: Store result, set state to FINISHED\n4. On exception: Store error message, set state to ERROR\n5. `join(task)` → Wait for thread, return result or throw exception\n\n### Channel Implementation\n\n```c\ntypedef struct Channel {\n    void **buffer;           // Circular buffer of Value*\n    size_t capacity;         // Maximum buffered items\n    size_t count;            // Current items in buffer\n    size_t read_index;       // Next read position\n    size_t write_index;      // Next write position\n    bool closed;             // Channel closed flag\n    pthread_mutex_t lock;    // Protects buffer\n    pthread_cond_t not_full; // Signal when space available\n    pthread_cond_t not_empty;// Signal when data available\n} Channel;\n```\n\n**Send operation:**\n1. Lock mutex\n2. Wait if buffer full (cond_wait on not_full)\n3. Write value to buffer[write_index]\n4. Increment write_index (circular)\n5. Signal not_empty\n6. Unlock mutex\n\n**Receive operation:**\n1. Lock mutex\n2. Wait if buffer empty (cond_wait on not_empty)\n3. Read value from buffer[read_index]\n4. Increment read_index (circular)\n5. Signal not_full\n6. Unlock mutex\n\n**Synchronization guarantees:**\n- Thread-safe send/recv (protected by mutex)\n- Blocking semantics (producer waits if full, consumer waits if empty)\n- Ordered delivery (FIFO within a channel)\n\n---\n\n## Future Plans\n\n### Completed: Compiler Backend ✓\n\nThe compiler backend (`hemlockc`) has been implemented with:\n- C code generation from AST\n- Compile-time type checking (enabled by default)\n- Runtime library (`libhemlock_runtime.a`)\n- Full parity with interpreter (98% test pass rate)\n- Unboxing optimization framework\n\n### Current Focus: Type System Enhancements\n\n**Recent improvements:**\n- Unified type checking and type inference systems\n- Compile-time type checking enabled by default\n- `--check` flag for type-only validation\n- Type context passed to codegen for optimization hints\n\n### Future Enhancements\n\n**Potential additions:**\n- Generics/templates\n- Pattern matching\n- LSP integration for type-aware IDE support\n- More aggressive unboxing optimizations\n- Escape analysis for stack allocation\n\n### Long-term Optimizations\n\n**Possible improvements:**\n- Inline caching for method calls\n- JIT compilation for hot code paths\n- Work-stealing scheduler for better concurrency\n- Profile-guided optimization\n\n---\n\n## Implementation Guidelines\n\n### Adding New Features\n\nWhen implementing new features, follow these guidelines:\n\n**1. Choose the right module:**\n- New value types → `values.c`\n- Type conversions → `types.c`\n- Built-in functions → `builtins.c`\n- I/O operations → `io.c`\n- Control flow → `runtime.c`\n\n**2. Update all layers:**\n- Add AST node types if needed (`ast.h`, `ast.c`)\n- Add lexer tokens if needed (`lexer.c`)\n- Add parser rules (`parser.c`)\n- Implement runtime behavior (`runtime.c` or appropriate module)\n- Add tests (`tests/`)\n\n**3. Maintain consistency:**\n- Follow existing code style\n- Use consistent naming conventions\n- Document public API in headers\n- Keep error messages clear and consistent\n\n**4. Test thoroughly:**\n- Add test cases before implementing\n- Test success and error paths\n- Test edge cases\n- Verify no memory leaks (valgrind)\n\n### Performance Considerations\n\n**Current bottlenecks:**\n- HashMap lookups for variable access\n- Recursive function calls (no TCO)\n- String concatenation (allocates new string each time)\n- Type checking overhead on every operation\n\n**Optimization opportunities:**\n- Cache variable locations (inline caching)\n- Tail call optimization\n- String builder for concatenation\n- Type inference to skip runtime checks\n\n### Debugging Tips\n\n**Useful tools:**\n- `valgrind` - Memory leak detection\n- `gdb` - Debugging crashes\n- `-g` flag - Debug symbols\n- `printf` debugging - Simple but effective\n\n**Common issues:**\n- Segfault → Null pointer dereference (check return values)\n- Memory leak → Missing free() call (check value_free paths)\n- Type error → Check type_convert() and type_check() logic\n- Crash in threads → Race condition (check mutex usage)\n\n---\n\n## Conclusion\n\nHemlock's implementation prioritizes:\n- **Modularity** - Clean separation of concerns\n- **Simplicity** - Straightforward implementation\n- **Explicitness** - No hidden magic\n- **Maintainability** - Easy to understand and modify\n\nThe current tree-walking interpreter is intentionally simple to facilitate rapid feature development and experimentation. Future compiler backend will improve performance while maintaining the same semantics.\n"}, "Design & Philosophy -> Philosophy": {"id": "design-philosophy", "content": "# Hemlock Language Design Philosophy\n\n> \"A small, unsafe language for writing unsafe things safely.\"\n\nThis document captures the core design principles and philosophy of Hemlock. Read this first before making any changes or additions to the language.\n\n---\n\n## Table of Contents\n\n- [Core Identity](#core-identity)\n- [Design Principles](#design-principles)\n- [Philosophy on Safety](#philosophy-on-safety)\n- [What NOT to Add](#what-not-to-add)\n- [Future Considerations](#future-considerations)\n- [Final Thoughts](#final-thoughts)\n\n---\n\n## Core Identity\n\nHemlock is a **systems scripting language** that embraces manual memory management and explicit control. It's designed for programmers who want:\n\n- The power of C\n- The ergonomics of modern scripting languages\n- Structured async concurrency built-in\n- No hidden behavior or magic\n\n### What Hemlock IS NOT\n\n- **Memory-safe** (dangling pointers are your responsibility)\n- **A replacement for Rust, Go, or Lua**\n- **A language that hides complexity from you**\n\n### What Hemlock IS\n\n- **Explicit over implicit, always**\n- **Educational and experimental**\n- **A \"C scripting layer\" for systems work**\n- **Honest about tradeoffs**\n\n---\n\n## Design Principles\n\n### 1. Explicit Over Implicit\n\nHemlock favors explicitness in all language constructs. There should be no surprises, no magic, and no hidden behavior.\n\n**Bad (implicit):**\n```hemlock\nlet x = 5  // Missing semicolon - should error\n```\n\n**Good (explicit):**\n```hemlock\nlet x = 5;\nfree(ptr);  // You allocated it, you free it\n```\n\n**Key aspects:**\n- Semicolons are mandatory (no automatic semicolon insertion)\n- No garbage collection\n- Manual memory management (alloc/free)\n- Type annotations are optional but checked at runtime\n- No automatic resource cleanup (no RAII), but `defer` provides explicit cleanup\n\n### 2. Dynamic by Default, Typed by Choice\n\nEvery value has a runtime type tag, but the system is designed to be flexible while still catching errors.\n\n**Type inference:**\n- Small integers (fits in i32): `42` → `i32`\n- Large integers (> i32 range): `9223372036854775807` → `i64`\n- Floats: `3.14` → `f64`\n\n**Explicit typing when needed:**\n```hemlock\nlet x = 42;              // i32 inferred (small value)\nlet y: u8 = 255;         // explicit u8\nlet z = x + y;           // promotes to i32\nlet big = 5000000000;    // i64 inferred (> i32 max)\n```\n\n**Type promotion rules** follow a clear hierarchy from smallest to largest, with floats always winning over integers.\n\n### 3. Unsafe is a Feature, Not a Bug\n\nHemlock doesn't try to prevent all errors. Instead, it gives you the tools to be safe while allowing you to opt into unsafe behavior when needed.\n\n**Examples of intentional unsafety:**\n- Pointer arithmetic can overflow (user's responsibility)\n- No bounds checking on raw `ptr` (use `buffer` if you want safety)\n- Double-free crashes are allowed (manual memory management)\n- Type system prevents accidents but allows footguns when needed\n\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // Way past allocation - allowed but dangerous\n```\n\n**The philosophy:** The type system should prevent *accidents* but allow *intentional* unsafe operations.\n\n### 4. Structured Concurrency First-Class\n\nConcurrency is not an afterthought in Hemlock. It's built into the language from the ground up.\n\n**Key features:**\n- `async`/`await` built into the language\n- Channels for communication\n- `spawn`/`join`/`detach` for task management\n- No raw threads, no locks - structured only\n- True multi-threaded parallelism using POSIX threads\n\n**Not an event loop or green threads** - Hemlock uses real OS threads for true parallelism across multiple CPU cores.\n\n### 5. C-like Syntax, Low Ceremony\n\nHemlock should feel familiar to systems programmers while reducing boilerplate.\n\n**Design choices:**\n- `{}` blocks always, no optional braces\n- Operators match C: `+`, `-`, `*`, `/`, `&&`, `||`, `!`\n- Type syntax matches Rust/TypeScript: `let x: type = value;`\n- Functions are first-class values\n- Minimal keywords and special forms\n\n---\n\n## Philosophy on Safety\n\n**Hemlock's take on safety:**\n\n> \"We give you the tools to be safe (`buffer`, type annotations, bounds checking) but we don't force you to use them (`ptr`, manual memory, unsafe operations).\n>\n> The default should guide toward safety, but the escape hatch should always be available.\"\n\n### Safety Tools Provided\n\n**1. Safe buffer type:**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // bounds checked\nprint(b.length);        // 64\nfree(b);                // still manual\n```\n\n**2. Unsafe raw pointers:**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // You must remember to free\n```\n\n**3. Type annotations:**\n```hemlock\nlet x: u8 = 255;   // OK\nlet y: u8 = 256;   // ERROR: out of range\n```\n\n**4. Runtime type checking:**\n```hemlock\nlet val = some_function();\nif (typeof(val) == \"i32\") {\n    // Safe to use as integer\n}\n```\n\n### Guiding Principles\n\n1. **Default to safe patterns in documentation** - Show `buffer` before `ptr`, encourage type annotations\n2. **Make unsafe operations obvious** - Raw pointer arithmetic should look intentional\n3. **Provide escape hatches** - Don't prevent experienced users from doing low-level work\n4. **Be honest about tradeoffs** - Document what can go wrong\n\n### Examples of Safety vs. Unsafety\n\n| Safe Pattern | Unsafe Pattern | When to Use Unsafe |\n|-------------|----------------|-------------------|\n| `buffer` type | `ptr` type | FFI, performance-critical code |\n| Type annotations | No annotations | External interfaces, validation |\n| Bounds-checked access | Pointer arithmetic | Low-level memory operations |\n| Exception handling | Returning null/error codes | When exceptions are too heavyweight |\n\n---\n\n## What NOT to Add\n\nUnderstanding what **not** to add is as important as knowing what to add.\n\n### ❌ Don't Add Implicit Behavior\n\n**Bad examples:**\n\n```hemlock\n// BAD: Automatic semicolon insertion\nlet x = 5\nlet y = 10\n\n// BAD: Implicit type conversions that lose precision\nlet x: i32 = 3.14  // Should truncate or error?\n```\n\n**Why:** Implicit behavior creates surprises and makes code harder to reason about.\n\n### ❌ Don't Hide Complexity\n\n**Bad examples:**\n\n```hemlock\n// BAD: Magic behind-the-scenes optimization\nlet arr = [1, 2, 3]  // Is this stack or heap? User should know! (Heap, refcounted)\n\n// BAD: Raw pointer auto-freed\nlet p = alloc(100)  // Does this auto-free? NO! Raw ptrs always need free()\n```\n\n**Note on refcounting:** Hemlock uses internal refcounting for strings, arrays, objects, and buffers - these ARE auto-freed when scope exits. This is explicit and predictable (deterministic cleanup when ref hits 0, no GC pauses). Raw pointers (`ptr` from `alloc()`) are NOT refcounted and always require manual `free()`.\n\n**Why:** Hidden complexity makes it impossible to predict performance and debug issues.\n\n### ❌ Don't Break Existing Semantics\n\n**Never change these core decisions:**\n- Semicolons are mandatory - don't make them optional\n- Manual memory management - don't add GC\n- Mutable strings - don't make them immutable\n- Runtime type checking - don't remove it\n\n**Why:** Consistency and stability are more important than trendy features.\n\n### ❌ Don't Add \"Convenient\" Features That Reduce Explicitness\n\n**Examples of features to avoid:**\n- Operator overloading (maybe for user types, but carefully)\n- Implicit type coercion that loses information\n- Automatic resource cleanup (RAII)\n- Method chaining that hides complexity\n- DSLs and magic syntax\n\n**Exception:** Convenience features are OK if they're **explicit sugar** over simple operations:\n- `else if` is fine (it's just nested if statements)\n- String interpolation might be OK if it's clearly syntactic sugar\n- Method syntax for objects is fine (it's explicit what it does)\n\n---\n\n## Future Considerations\n\n### Maybe Add (Under Discussion)\n\nThese features align with Hemlock's philosophy but need careful design:\n\n**1. Pattern matching**\n```hemlock\nmatch (value) {\n    case i32: print(\"integer\");\n    case string: print(\"text\");\n    case _: print(\"other\");\n}\n```\n- Explicit type checking\n- No hidden costs\n- Compile-time exhaustiveness checking possible\n\n**2. Error types (`Result<T, E>`)**\n```hemlock\nfn divide(a: i32, b: i32): Result<i32, string> {\n    if (b == 0) {\n        return Err(\"division by zero\");\n    }\n    return Ok(a / b);\n}\n```\n- Explicit error handling\n- Forces users to think about errors\n- Alternative to exceptions\n\n**3. Array/slice types**\n- Already have dynamic arrays\n- Could add fixed-size arrays for stack allocation\n- Would need to be explicit about stack vs. heap\n\n**4. Improved memory safety tools**\n- Optional bounds checking flag\n- Memory leak detection in debug builds\n- Sanitizer integration\n\n### Probably Never Add\n\nThese features violate core principles:\n\n**1. Garbage collection**\n- Hides memory management complexity\n- Unpredictable performance\n- Against explicit control principle\n\n**2. Automatic memory management**\n- Same reasons as GC\n- Reference counting might be OK if explicit\n\n**3. Implicit type conversions that lose data**\n- Goes against \"explicit over implicit\"\n- Source of subtle bugs\n\n**4. Macros (complex ones)**\n- Too much power, too much complexity\n- Simple macro system might be OK\n- Prefer code generation or functions\n\n**5. Class-based OOP with inheritance**\n- Too much implicit behavior\n- Duck typing and objects are sufficient\n- Composition over inheritance\n\n**6. Module system with complex resolution**\n- Keep imports simple and explicit\n- No magic search paths\n- No version resolution (use OS package manager)\n\n---\n\n## Final Thoughts\n\n### Trust and Responsibility\n\nHemlock is about **trust and responsibility**. We trust the programmer to:\n\n- Manage memory correctly\n- Use types appropriately\n- Handle errors properly\n- Understand the tradeoffs\n\nIn return, Hemlock provides:\n\n- No hidden costs\n- No surprise behavior\n- Full control when needed\n- Safety tools when wanted\n\n### The Guiding Question\n\n**When considering a new feature, ask:**\n\n> \"Does this give the programmer more explicit control, or does it hide something?\"\n\n- If it **adds explicit control** → probably fits Hemlock\n- If it **hides complexity** → probably doesn't belong\n- If it's **optional sugar** that's clearly documented → might be OK\n\n### Examples of Good Additions\n\n✅ **Switch statements** - Explicit control flow, no magic, clear semantics\n\n✅ **Async/await with pthreads** - Explicit concurrency, true parallelism, user controls spawning\n\n✅ **Buffer type alongside ptr** - Gives choice between safe and unsafe\n\n✅ **Optional type annotations** - Helps catch bugs without forcing strictness\n\n✅ **Try/catch/finally** - Explicit error handling with clear control flow\n\n### Examples of Bad Additions\n\n❌ **Automatic semicolon insertion** - Hides syntax errors, makes code ambiguous\n\n❌ **RAII/destructors** - Automatic cleanup hides when resources are released\n\n❌ **Implicit null coalescing** - Hides null checks, makes code harder to reason about\n\n❌ **Auto-growing strings** - Hides memory allocation, unpredictable performance\n\n---\n\n## Conclusion\n\nHemlock is not trying to be the safest language, the fastest language, or the most feature-rich language.\n\n**Hemlock is trying to be the most *honest* language.**\n\nIt tells you exactly what it's doing, gives you control when you need it, and doesn't hide the sharp edges. It's a language for people who want to understand their code at a low level while still enjoying modern ergonomics.\n\nIf you're not sure whether a feature belongs in Hemlock, remember:\n\n> **Explicit over implicit, always.**\n> **Unsafe is a feature, not a bug.**\n> **The user is responsible, and that's OK.**\n"}, "Design & Philosophy -> Signature Syntax": {"id": "design-signature-syntax", "content": "# Signature Syntax Design\n\n> Extending Hemlock's type system with function types, nullable modifiers, type aliases, const parameters, and method signatures.\n\n**Status:** Implemented (v1.7.0)\n**Version:** 1.0\n**Author:** Claude\n\n---\n\n## Overview\n\nThis document proposes five interconnected type system extensions that build on Hemlock's existing infrastructure:\n\n1. **Function Type Annotations** - First-class function types\n2. **Nullable Type Modifiers** - Explicit null handling (extends existing `nullable` flag)\n3. **Type Aliases** - Named type abbreviations\n4. **Const Parameters** - Immutability contracts\n5. **Method Signatures in Define** - Interface-like behavior\n\nThese features share the philosophy: **explicit over implicit, optional but enforced when used**.\n\n---\n\n## 1. Function Type Annotations\n\n### Motivation\n\nCurrently, there's no way to express a function's signature as a type:\n\n```hemlock\n// Current: callback has no type information\nfn map(arr: array, callback) { ... }\n\n// Proposed: explicit function type\nfn map(arr: array, callback: fn(any, i32): any): array { ... }\n```\n\n### Syntax\n\n```hemlock\n// Basic function type\nfn(i32, i32): i32\n\n// With parameter names (documentation only, not enforced)\nfn(a: i32, b: i32): i32\n\n// No return value (void)\nfn(string): void\nfn(string)              // Shorthand: omit `: void`\n\n// Nullable return\nfn(i32): string?\n\n// Optional parameters\nfn(name: string, age?: i32): void\n\n// Rest parameters\nfn(...args: array): i32\n\n// No parameters\nfn(): bool\n\n// Higher-order: function returning function\nfn(i32): fn(i32): i32\n\n// Async function type\nasync fn(i32): i32\n```\n\n### Usage Examples\n\n```hemlock\n// Variable with function type\nlet add: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// Function parameter\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Return type is function\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Array of functions\nlet ops: array<fn(i32, i32): i32> = [add, subtract, multiply];\n\n// Object field\ndefine EventHandler {\n    name: string;\n    callback: fn(Event): void;\n}\n```\n\n### AST Changes\n\n```c\n// In TypeKind enum (include/ast.h)\ntypedef enum {\n    // ... existing types ...\n    TYPE_FUNCTION,      // NEW: Function type\n} TypeKind;\n\n// In Type struct (include/ast.h)\nstruct Type {\n    TypeKind kind;\n    // ... existing fields ...\n\n    // For TYPE_FUNCTION:\n    struct Type **param_types;      // Parameter types\n    char **param_names;             // Optional parameter names (docs)\n    int *param_optional;            // Which params are optional\n    int num_params;\n    char *rest_param_name;          // Rest parameter name or NULL\n    struct Type *rest_param_type;   // Rest parameter type\n    struct Type *return_type;       // Return type (NULL = void)\n    int is_async;                   // async fn type\n};\n```\n\n### Parsing\n\nFunction types begin with `fn` (or `async fn`) followed by parameter list:\n\n```\nfunction_type := [\"async\"] \"fn\" \"(\" [param_type_list] \")\" [\":\" type]\nparam_type_list := param_type (\",\" param_type)*\nparam_type := [identifier \":\"] [\"?\"] type | \"...\" [identifier] [\":\" type]\n```\n\n**Disambiguation:** When parsing a type and `fn` is encountered:\n- If followed by `(`, it's a function type\n- Otherwise, syntax error (bare `fn` is not a valid type)\n\n### Type Compatibility\n\n```hemlock\n// Exact match required for function types\nlet f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // OK\n\n// Parameter contravariance (accepting broader types is OK)\nlet g: fn(any): i32 = fn(x: i32): i32 { return x; };  // OK: i32 <: any\n\n// Return covariance (returning narrower types is OK)\nlet h: fn(i32): any = fn(x: i32): i32 { return x; };  // OK: i32 <: any\n\n// Arity must match\nlet bad: fn(i32): i32 = fn(a, b) { return a; };       // ERROR: arity mismatch\n\n// Optional parameters compatible with required\nlet opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // OK\n```\n\n---\n\n## 2. Nullable Type Modifiers\n\n### Motivation\n\nThe `?` suffix makes null-acceptance explicit in signatures:\n\n```hemlock\n// Current: unclear if null is valid\nfn find(arr: array, val: any): i32 { ... }\n\n// Proposed: explicit nullable return\nfn find(arr: array, val: any): i32? { ... }\n```\n\n### Syntax\n\n```hemlock\n// Nullable types with ? suffix\nstring?           // string or null\ni32?              // i32 or null\nUser?             // User or null\narray<i32>?       // array or null\nfn(i32): i32?     // function returning i32 or null\n\n// Composing with function types\nfn(string?): i32          // Accepts string or null\nfn(string): i32?          // Returns i32 or null\nfn(string?): i32?         // Both nullable\n\n// In define\ndefine Result {\n    value: any?;\n    error: string?;\n}\n```\n\n### Implementation Notes\n\n**Already exists:** The `Type.nullable` flag is already in the AST. This feature primarily needs:\n1. Parser support for `?` suffix on any type (verify/extend)\n2. Proper composition with function types\n3. Runtime enforcement\n\n### Type Compatibility\n\n```hemlock\n// Non-nullable assignable to nullable\nlet x: i32? = 42;           // OK\nlet y: i32? = null;         // OK\n\n// Nullable NOT assignable to non-nullable\nlet z: i32 = x;             // ERROR: x might be null\n\n// Null coalescing to unwrap\nlet z: i32 = x ?? 0;        // OK: ?? provides default\n\n// Optional chaining returns nullable\nlet name: string? = user?.name;\n```\n\n---\n\n## 3. Type Aliases\n\n### Motivation\n\nComplex types benefit from named abbreviations:\n\n```hemlock\n// Current: repetitive compound types\nfn process(entity: HasName & HasId & HasTimestamp) { ... }\nfn validate(entity: HasName & HasId & HasTimestamp) { ... }\n\n// Proposed: named alias\ntype Entity = HasName & HasId & HasTimestamp;\nfn process(entity: Entity) { ... }\nfn validate(entity: Entity) { ... }\n```\n\n### Syntax\n\n```hemlock\n// Basic alias\ntype Integer = i32;\ntype Text = string;\n\n// Compound type alias\ntype Entity = HasName & HasId;\ntype Auditable = HasCreatedAt & HasUpdatedAt & HasCreatedBy;\n\n// Function type alias\ntype Callback = fn(Event): void;\ntype Predicate = fn(any): bool;\ntype Reducer = fn(acc: any, val: any): any;\ntype AsyncTask = async fn(): any;\n\n// Nullable alias\ntype OptionalString = string?;\n\n// Generic alias (if we support generic type aliases)\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// Array type alias\ntype IntArray = array<i32>;\ntype Matrix = array<array<f64>>;\n```\n\n### Scope and Visibility\n\n```hemlock\n// Module-scoped by default\ntype Callback = fn(Event): void;\n\n// Exportable\nexport type Handler = fn(Request): Response;\n\n// In another file\nimport { Handler } from \"./handlers.hml\";\nfn register(h: Handler) { ... }\n```\n\n### AST Changes\n\n```c\n// New statement kind\ntypedef enum {\n    // ... existing statements ...\n    STMT_TYPE_ALIAS,    // NEW\n} StmtKind;\n\n// In Stmt union\nstruct {\n    char *name;                 // Alias name\n    char **type_params;         // Generic params: <T, U>\n    int num_type_params;\n    Type *aliased_type;         // The actual type\n} type_alias;\n```\n\n### Parsing\n\n```\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n```\n\n**Note:** `type` is a new keyword. Check for conflicts with existing identifiers.\n\n### Resolution\n\nType aliases are resolved at:\n- **Parse time:** Alias recorded in type environment\n- **Check time:** Alias expanded to underlying type\n- **Runtime:** Alias is transparent (same as underlying type)\n\n```hemlock\ntype MyInt = i32;\nlet x: MyInt = 42;\ntypeof(x);           // \"i32\" (not \"MyInt\")\n```\n\n---\n\n## 4. Const Parameters\n\n### Motivation\n\nSignal immutability intent in function signatures:\n\n```hemlock\n// Current: unclear if array will be modified\nfn print_all(items: array) { ... }\n\n// Proposed: explicit immutability contract\nfn print_all(const items: array) { ... }\n```\n\n### Syntax\n\n```hemlock\n// Const parameter\nfn process(const data: buffer) {\n    // data[0] = 0;        // ERROR: cannot mutate const\n    let x = data[0];       // OK: reading allowed\n    return x;\n}\n\n// Multiple const params\nfn compare(const a: array, const b: array): bool { ... }\n\n// Mixed const and mutable\nfn update(const source: array, target: array) {\n    for (item in source) {\n        target.push(item);   // OK: target is mutable\n    }\n}\n\n// Const with type inference\nfn log(const msg) {\n    print(msg);\n}\n\n// Const in function types\ntype Reader = fn(const buffer): i32;\n```\n\n### What Const Prevents\n\n```hemlock\nfn bad(const arr: array) {\n    arr.push(1);         // ERROR: mutating method\n    arr.pop();           // ERROR: mutating method\n    arr[0] = 5;          // ERROR: index assignment\n    arr.clear();         // ERROR: mutating method\n}\n\nfn ok(const arr: array) {\n    let x = arr[0];      // OK: reading\n    let len = len(arr);  // OK: length check\n    let copy = arr.slice(0, 10);  // OK: creates new array\n    for (item in arr) {  // OK: iteration\n        print(item);\n    }\n}\n```\n\n### Mutating vs Non-Mutating Methods\n\n| Type | Mutating (blocked by const) | Non-Mutating (allowed) |\n|------|----------------------------|------------------------|\n| array | push, pop, shift, unshift, insert, remove, clear, reverse (in-place) | slice, concat, map, filter, find, contains, first, last, join |\n| string | index assignment (`s[0] = 'x'`) | all methods (return new strings) |\n| buffer | index assignment, memset, memcpy (to) | index read, slice |\n| object | field assignment | field read |\n\n### AST Changes\n\n```c\n// In function expression (include/ast.h)\nstruct {\n    // ... existing fields ...\n    int *param_is_const;    // NEW: 1 if const, 0 otherwise\n} function;\n\n// In Type struct for function types\nstruct Type {\n    // ... existing fields ...\n    int *param_is_const;    // For TYPE_FUNCTION\n};\n```\n\n### Enforcement\n\n**Interpreter:**\n- Track const-ness in variable bindings\n- Check before mutation operations\n- Runtime error on const violation\n\n**Compiler:**\n- Emit const-qualified C variables where beneficial\n- Static analysis for const violations\n- Warning/error at compile time\n\n---\n\n## 5. Method Signatures in Define\n\n### Motivation\n\nAllow `define` blocks to specify expected methods, not just data fields:\n\n```hemlock\n// Current: only data fields\ndefine User {\n    name: string;\n    age: i32;\n}\n\n// Proposed: method signatures\ndefine Comparable {\n    fn compare(other: Self): i32;\n}\n\ndefine Serializable {\n    fn serialize(): string;\n    fn deserialize(data: string): Self;  // Static method\n}\n```\n\n### Syntax\n\n```hemlock\n// Method signature (no body)\ndefine Hashable {\n    fn hash(): i32;\n}\n\n// Multiple methods\ndefine Collection {\n    fn size(): i32;\n    fn is_empty(): bool;\n    fn contains(item: any): bool;\n}\n\n// Mixed fields and methods\ndefine Entity {\n    id: i32;\n    name: string;\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\n// Using Self type\ndefine Cloneable {\n    fn clone(): Self;\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;\n    fn equals(other: Self): bool;\n}\n\n// Optional methods\ndefine Printable {\n    fn to_string(): string;\n    fn debug_string?(): string;  // Optional method (may be absent)\n}\n\n// Methods with default implementations\ndefine Ordered {\n    fn compare(other: Self): i32;  // Required\n\n    // Default implementations (inherited if not overridden)\n    fn less_than(other: Self): bool {\n        return self.compare(other) < 0;\n    }\n    fn greater_than(other: Self): bool {\n        return self.compare(other) > 0;\n    }\n    fn equals(other: Self): bool {\n        return self.compare(other) == 0;\n    }\n}\n```\n\n### The `Self` Type\n\n`Self` refers to the concrete type implementing the interface:\n\n```hemlock\ndefine Addable {\n    fn add(other: Self): Self;\n}\n\n// When used:\nlet a: Addable = {\n    value: 10,\n    add: fn(other) {\n        return { value: self.value + other.value, add: self.add };\n    }\n};\n```\n\n### Structural Typing (Duck Typing)\n\nMethod signatures use the same duck typing as fields:\n\n```hemlock\ndefine Stringifiable {\n    fn to_string(): string;\n}\n\n// Any object with to_string() method satisfies Stringifiable\nlet x: Stringifiable = {\n    name: \"test\",\n    to_string: fn() { return self.name; }\n};\n\n// Compound types with methods\ndefine Named { name: string; }\ndefine Printable { fn to_string(): string; }\n\ntype NamedPrintable = Named & Printable;\n\nlet y: NamedPrintable = {\n    name: \"Alice\",\n    to_string: fn() { return \"Name: \" + self.name; }\n};\n```\n\n### AST Changes\n\n```c\n// Extend define_object in Stmt union\nstruct {\n    char *name;\n    char **type_params;\n    int num_type_params;\n\n    // Fields (existing)\n    char **field_names;\n    Type **field_types;\n    int *field_optional;\n    Expr **field_defaults;\n    int num_fields;\n\n    // Methods (NEW)\n    char **method_names;\n    Type **method_types;        // TYPE_FUNCTION\n    int *method_optional;       // Optional methods (fn name?(): type)\n    Expr **method_defaults;     // Default implementations (NULL if signature only)\n    int num_methods;\n} define_object;\n```\n\n### Type Checking\n\nWhen checking `value: InterfaceType`:\n1. Check all required fields exist with compatible types\n2. Check all required methods exist with compatible signatures\n3. Optional fields/methods may be absent\n\n```hemlock\ndefine Sortable {\n    fn compare(other: Self): i32;\n}\n\n// Valid: has compare method\nlet valid: Sortable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// Invalid: missing compare\nlet invalid: Sortable = { value: 10 };  // ERROR: missing method 'compare'\n\n// Invalid: wrong signature\nlet wrong: Sortable = {\n    compare: fn() { return 0; }  // ERROR: expected (Self): i32\n};\n```\n\n---\n\n## Interaction Examples\n\n### Combining All Features\n\n```hemlock\n// Type alias for complex function type\ntype EventCallback = fn(event: Event, context: Context?): bool;\n\n// Type alias for compound interface\ntype Entity = HasId & HasName & Serializable;\n\n// Define with method signatures\ndefine Repository<T> {\n    fn find(id: i32): T?;\n    fn save(const entity: T): bool;\n    fn delete(id: i32): bool;\n    fn find_all(predicate: fn(T): bool): array<T>;\n}\n\n// Using it all together\nfn create_user_repo(): Repository<User> {\n    let users: array<User> = [];\n\n    return {\n        find: fn(id) {\n            for (u in users) {\n                if (u.id == id) { return u; }\n            }\n            return null;\n        },\n        save: fn(const entity) {\n            users.push(entity);\n            return true;\n        },\n        delete: fn(id) {\n            // ...\n            return true;\n        },\n        find_all: fn(predicate) {\n            return users.filter(predicate);\n        }\n    };\n}\n```\n\n### Callbacks with Explicit Types\n\n```hemlock\ntype ClickHandler = fn(event: MouseEvent): void;\ntype KeyHandler = fn(event: KeyEvent, modifiers: i32): bool;\n\ndefine Widget {\n    x: i32;\n    y: i32;\n    on_click: ClickHandler?;\n    on_key: KeyHandler?;\n}\n\nfn create_button(label: string, handler: ClickHandler): Widget {\n    return {\n        x: 0, y: 0,\n        on_click: handler,\n        on_key: null\n    };\n}\n```\n\n### Nullable Function Types\n\n```hemlock\n// Optional callback\nfn fetch(url: string, on_complete: fn(Response): void?): void {\n    let response = http_get(url);\n    if (on_complete != null) {\n        on_complete(response);\n    }\n}\n\n// Nullable return from function type\ntype Parser = fn(input: string): AST?;\n\nfn try_parse(parsers: array<Parser>, input: string): AST? {\n    for (p in parsers) {\n        let result = p(input);\n        if (result != null) {\n            return result;\n        }\n    }\n    return null;\n}\n```\n\n---\n\n## Implementation Roadmap\n\n### Phase 1: Core Infrastructure\n1. Add `TYPE_FUNCTION` to TypeKind enum\n2. Extend Type struct with function type fields\n3. Add `CHECKED_FUNCTION` to compiler type checker\n4. Add `Self` type support (TYPE_SELF)\n\n### Phase 2: Parsing\n1. Implement `parse_function_type()` in parser\n2. Handle `fn(...)` in type position\n3. Add `type` keyword and `STMT_TYPE_ALIAS` parsing\n4. Add `const` parameter modifier parsing\n5. Extend define parsing for method signatures\n\n### Phase 3: Type Checking\n1. Function type compatibility rules\n2. Type alias resolution and expansion\n3. Const parameter mutation checking\n4. Method signature validation in define types\n5. Self type resolution\n\n### Phase 4: Runtime\n1. Function type validation at call sites\n2. Const violation detection\n3. Type alias transparency\n\n### Phase 5: Parity Tests\n1. Function type annotation tests\n2. Nullable composition tests\n3. Type alias tests\n4. Const parameter tests\n5. Method signature tests\n\n---\n\n## Design Decisions\n\n### 1. Generic Type Aliases: **YES**\n\nType aliases support generic parameters:\n\n```hemlock\n// Generic type aliases\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\ntype Mapper<T, U> = fn(T): U;\ntype AsyncResult<T> = async fn(): T?;\n\n// Usage\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\nlet result: Result<User, string> = { value: user, error: null };\nlet transform: Mapper<i32, string> = fn(n) { return n.to_string(); };\n```\n\n### 2. Const Propagation: **DEEP**\n\nConst parameters are fully immutable - no mutation through any path:\n\n```hemlock\nfn process(const arr: array<object>) {\n    arr.push({});        // ERROR: cannot mutate const array\n    arr[0] = {};         // ERROR: cannot mutate const array\n    arr[0].x = 5;        // ERROR: cannot mutate through const (DEEP)\n\n    let x = arr[0].x;    // OK: reading is fine\n    let copy = arr[0];   // OK: creates a copy\n    copy.x = 5;          // OK: copy is not const\n}\n\nfn nested(const obj: object) {\n    obj.user.name = \"x\"; // ERROR: deep const prevents nested mutation\n    obj.items[0] = 1;    // ERROR: deep const prevents nested mutation\n}\n```\n\n**Rationale:** Deep const provides stronger guarantees and is more useful for\nensuring data integrity. If you need to mutate nested data, make a copy first.\n\n### 3. Self in Standalone Type Aliases: **NO**\n\n`Self` is only valid inside `define` blocks where it has clear meaning:\n\n```hemlock\n// Valid: Self refers to the defined type\ndefine Comparable {\n    fn compare(other: Self): i32;\n}\n\n// Invalid: Self has no meaning here\ntype Cloner = fn(Self): Self;  // ERROR: Self outside define context\n\n// Instead, use generics:\ntype Cloner<T> = fn(T): T;\n```\n\n### 4. Method Default Implementations: **YES (Simple Only)**\n\nAllow default implementations for simple/utility methods:\n\n```hemlock\ndefine Comparable {\n    // Required: must be implemented\n    fn compare(other: Self): i32;\n\n    // Default implementations (simple convenience methods)\n    fn equals(other: Self): bool {\n        return self.compare(other) == 0;\n    }\n    fn less_than(other: Self): bool {\n        return self.compare(other) < 0;\n    }\n    fn greater_than(other: Self): bool {\n        return self.compare(other) > 0;\n    }\n}\n\ndefine Printable {\n    fn to_string(): string;\n\n    // Default: delegates to required method\n    fn print() {\n        print(self.to_string());\n    }\n    fn println() {\n        print(self.to_string() + \"\\n\");\n    }\n}\n\n// Object only needs to implement required methods\nlet item: Comparable = {\n    value: 42,\n    compare: fn(other) { return self.value - other.value; }\n    // equals, less_than, greater_than are inherited from defaults\n};\n\nitem.less_than({ value: 50, compare: item.compare });  // true\n```\n\n**Guidelines for defaults:**\n- Keep them simple (1-3 lines)\n- Should delegate to required methods\n- No complex logic or side effects\n- Primitives and straightforward compositions only\n\n### 5. Variance: **INFERRED (No Explicit Annotations)**\n\nVariance is inferred from how type parameters are used:\n\n```hemlock\n// Variance is automatic based on position\ntype Producer<T> = fn(): T;           // T in return = covariant\ntype Consumer<T> = fn(T): void;       // T in param = contravariant\ntype Transformer<T> = fn(T): T;       // T in both = invariant\n\n// Example: Dog <: Animal (Dog is subtype of Animal)\nlet dog_producer: Producer<Dog> = fn() { return new_dog(); };\nlet animal_producer: Producer<Animal> = dog_producer;  // OK: covariant\n\nlet animal_consumer: Consumer<Animal> = fn(a) { print(a); };\nlet dog_consumer: Consumer<Dog> = animal_consumer;     // OK: contravariant\n```\n\n**Why infer?**\n- Less boilerplate (`<out T>` / `<in T>` adds noise)\n- Follows \"explicit over implicit\" - the position IS explicit\n- Matches how most languages handle function type variance\n- Errors are clear when variance rules are violated\n\n---\n\n## Appendix: Grammar Changes\n\n```ebnf\n(* Types *)\ntype := simple_type | compound_type | function_type\nsimple_type := base_type [\"?\"] | identifier [\"<\" type_args \">\"] [\"?\"]\ncompound_type := simple_type (\"&\" simple_type)+\nfunction_type := [\"async\"] \"fn\" \"(\" [param_types] \")\" [\":\" type]\n\nbase_type := \"i8\" | \"i16\" | \"i32\" | \"i64\"\n           | \"u8\" | \"u16\" | \"u32\" | \"u64\"\n           | \"f32\" | \"f64\" | \"bool\" | \"string\" | \"rune\"\n           | \"ptr\" | \"buffer\" | \"void\" | \"null\"\n           | \"array\" [\"<\" type \">\"]\n           | \"object\"\n           | \"Self\"\n\nparam_types := param_type (\",\" param_type)*\nparam_type := [\"const\"] [identifier \":\"] [\"?\"] type\n            | \"...\" [identifier] [\":\" type]\n\ntype_args := type (\",\" type)*\n\n(* Statements *)\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n\ndefine_stmt := \"define\" identifier [\"<\" type_params \">\"] \"{\" define_members \"}\"\ndefine_members := (field_def | method_def)*\nfield_def := identifier (\":\" type [\"=\" expr] | \"?:\" (type | expr)) \";\"?\nmethod_def := \"fn\" identifier [\"?\"] \"(\" [param_types] \")\" [\":\" type] (block | \";\")\n            (* \"?\" marks optional method, block provides default implementation *)\n\n(* Parameters *)\nparam := [\"const\"] [\"ref\"] identifier [\":\" type] [\"?:\" expr]\n       | \"...\" identifier [\":\" type]\n```\n"}, "Contributing -> Guidelines": {"id": "contributing-guidelines", "content": "# Contributing to Hemlock\n\nThank you for your interest in contributing to Hemlock! This guide will help you understand how to contribute effectively while maintaining the language's design philosophy and code quality.\n\n---\n\n## Table of Contents\n\n- [Before You Start](#before-you-start)\n- [Contribution Workflow](#contribution-workflow)\n- [Code Style Guidelines](#code-style-guidelines)\n- [What to Contribute](#what-to-contribute)\n- [What NOT to Contribute](#what-not-to-contribute)\n- [Common Patterns](#common-patterns)\n- [Adding New Features](#adding-new-features)\n- [Code Review Process](#code-review-process)\n\n---\n\n## Before You Start\n\n### Required Reading\n\nBefore contributing, please read these documents in order:\n\n1. **`/home/user/hemlock/docs/design/philosophy.md`** - Understand Hemlock's core principles\n2. **`/home/user/hemlock/docs/design/implementation.md`** - Learn the codebase structure\n3. **`/home/user/hemlock/docs/contributing/testing.md`** - Understand testing requirements\n4. **This document** - Learn contribution guidelines\n\n### Prerequisites\n\n**Required knowledge:**\n- C programming (pointers, memory management, structs)\n- Compiler/interpreter basics (lexing, parsing, AST)\n- Git and GitHub workflow\n- Unix/Linux command line\n\n**Required tools:**\n- GCC or Clang compiler\n- Make build system\n- Git version control\n- Valgrind (for memory leak detection)\n- Basic text editor or IDE\n\n### Communication Channels\n\n**Where to ask questions:**\n- GitHub Issues - Bug reports and feature requests\n- GitHub Discussions - General questions and design discussions\n- Pull Request comments - Specific code feedback\n\n---\n\n## Contribution Workflow\n\n### 1. Find or Create an Issue\n\n**Before writing code:**\n- Check if an issue exists for your contribution\n- If not, create one describing what you want to do\n- Wait for maintainer feedback before starting large changes\n- Small bug fixes can skip this step\n\n**Good issue descriptions include:**\n- Problem statement (what's broken or missing)\n- Proposed solution (how you plan to fix it)\n- Examples (code snippets showing the issue)\n- Rationale (why this change aligns with Hemlock's philosophy)\n\n### 2. Fork and Clone\n\n```bash\n# Fork the repository on GitHub first, then:\ngit clone https://github.com/YOUR_USERNAME/hemlock.git\ncd hemlock\ngit checkout -b feature/your-feature-name\n```\n\n### 3. Make Your Changes\n\nFollow these guidelines:\n- Write tests first (TDD approach)\n- Implement the feature\n- Ensure all tests pass\n- Check for memory leaks\n- Update documentation\n\n### 4. Test Your Changes\n\n```bash\n# Run the full test suite\nmake test\n\n# Run specific test category\n./tests/run_tests.sh tests/category/\n\n# Check for memory leaks\nvalgrind ./hemlock tests/your_test.hml\n\n# Build and test\nmake clean && make && make test\n```\n\n### 5. Commit Your Changes\n\n**Good commit messages:**\n```\nAdd bitwise operators for integer types\n\n- Implement &, |, ^, <<, >>, ~ operators\n- Add type checking to ensure integer-only operations\n- Update operator precedence table\n- Add comprehensive tests for all operators\n\nCloses #42\n```\n\n**Commit message format:**\n- First line: Brief summary (50 chars max)\n- Blank line\n- Detailed explanation (wrap at 72 chars)\n- Reference issue numbers\n\n### 6. Submit a Pull Request\n\n**Before submitting:**\n- Rebase on latest main branch\n- Ensure all tests pass\n- Run valgrind to check for leaks\n- Update CLAUDE.md if adding user-facing features\n\n**Pull request description should include:**\n- What problem this solves\n- How it solves it\n- Breaking changes (if any)\n- Examples of new syntax or behavior\n- Test coverage summary\n\n---\n\n## Code Style Guidelines\n\n### C Code Style\n\n**Formatting:**\n```c\n// Indent with 4 spaces (no tabs)\n// K&R brace style for functions\nvoid function_name(int arg1, char *arg2)\n{\n    if (condition) {\n        // Brace on same line for control structures\n        do_something();\n    }\n}\n\n// Line length: 100 characters max\n// Use spaces around operators\nint result = (a + b) * c;\n\n// Pointer asterisk with type\nchar *string;   // Good\nchar* string;   // Avoid\nchar * string;  // Avoid\n```\n\n**Naming conventions:**\n```c\n// Functions: lowercase_with_underscores\nvoid eval_expression(ASTNode *node);\n\n// Types: PascalCase\ntypedef struct Value Value;\ntypedef enum ValueType ValueType;\n\n// Constants: UPPERCASE_WITH_UNDERSCORES\n#define MAX_BUFFER_SIZE 4096\n\n// Variables: lowercase_with_underscores\nint item_count;\nValue *current_value;\n\n// Enums: TYPE_PREFIX_NAME\ntypedef enum {\n    TYPE_I32,\n    TYPE_STRING,\n    TYPE_OBJECT\n} ValueType;\n```\n\n**Comments:**\n```c\n// Single-line comments for brief explanations\n// Use complete sentences with proper capitalization\n\n/*\n * Multi-line comments for longer explanations\n * Align asterisks for readability\n */\n\n/**\n * Function documentation comment\n * @param node - AST node to evaluate\n * @return Evaluated value\n */\nValue eval_expr(ASTNode *node);\n```\n\n**Error handling:**\n```c\n// Check all malloc calls\nchar *buffer = malloc(size);\nif (!buffer) {\n    fprintf(stderr, \"Error: Out of memory\\n\");\n    exit(1);\n}\n\n// Provide context in error messages\nif (file == NULL) {\n    fprintf(stderr, \"Error: Failed to open '%s': %s\\n\",\n            filename, strerror(errno));\n    exit(1);\n}\n\n// Use meaningful error messages\n// Bad: \"Error: Invalid value\"\n// Good: \"Error: Expected integer, got string\"\n```\n\n**Memory management:**\n```c\n// Always free what you allocate\nValue *val = value_create_i32(42);\n// ... use val\nvalue_free(val);\n\n// Set pointers to NULL after freeing (prevents double-free)\nfree(ptr);\nptr = NULL;\n\n// Document ownership in comments\n// This function takes ownership of 'value' and will free it\nvoid store_value(Value *value);\n\n// This function does NOT take ownership (caller must free)\nValue *get_value(void);\n```\n\n### Code Organization\n\n**File structure:**\n```c\n// 1. Includes (system headers first, then local)\n#include <stdio.h>\n#include <stdlib.h>\n#include \"internal.h\"\n#include \"values.h\"\n\n// 2. Constants and macros\n#define INITIAL_CAPACITY 16\n\n// 3. Type definitions\ntypedef struct Foo Foo;\n\n// 4. Static function declarations (internal helpers)\nstatic void helper_function(void);\n\n// 5. Public function implementations\nvoid public_api_function(void)\n{\n    // Implementation\n}\n\n// 6. Static function implementations\nstatic void helper_function(void)\n{\n    // Implementation\n}\n```\n\n**Header files:**\n```c\n// Use header guards\n#ifndef HEMLOCK_MODULE_H\n#define HEMLOCK_MODULE_H\n\n// Forward declarations\ntypedef struct Value Value;\n\n// Public API only in headers\nvoid public_function(Value *val);\n\n// Document parameters and return values\n/**\n * Evaluates an expression AST node\n * @param node - The AST node to evaluate\n * @param env - The current environment\n * @return The result value\n */\nValue *eval_expr(ASTNode *node, Environment *env);\n\n#endif // HEMLOCK_MODULE_H\n```\n\n---\n\n## What to Contribute\n\n### ✅ Encouraged Contributions\n\n**Bug fixes:**\n- Memory leaks\n- Segmentation faults\n- Incorrect behavior\n- Error message improvements\n\n**Documentation:**\n- Code comments\n- API documentation\n- User guides and tutorials\n- Example programs\n- Test case documentation\n\n**Tests:**\n- Additional test cases for existing features\n- Edge case coverage\n- Regression tests for fixed bugs\n- Performance benchmarks\n\n**Small feature additions:**\n- New built-in functions (if they fit the philosophy)\n- String/array methods\n- Utility functions\n- Error handling improvements\n\n**Performance improvements:**\n- Faster algorithms (without changing semantics)\n- Memory usage reduction\n- Benchmark suite\n- Profiling tools\n\n**Tooling:**\n- Editor syntax highlighting\n- Language server protocol (LSP)\n- Debugger integration\n- Build system improvements\n\n### 🤔 Discuss First\n\n**Major features:**\n- New language constructs\n- Type system changes\n- Syntax additions\n- Concurrency primitives\n\n**How to discuss:**\n1. Open a GitHub issue or discussion\n2. Describe the feature and rationale\n3. Show example code\n4. Explain how it fits Hemlock's philosophy\n5. Wait for maintainer feedback\n6. Iterate on design before implementing\n\n---\n\n## What NOT to Contribute\n\n### ❌ Discouraged Contributions\n\n**Don't add features that:**\n- Hide complexity from the user\n- Make behavior implicit or magical\n- Break existing semantics or syntax\n- Add garbage collection or automatic memory management\n- Violate the \"explicit over implicit\" principle\n\n**Examples of rejected contributions:**\n\n**1. Automatic semicolon insertion**\n```hemlock\n// BAD: This would be rejected\nlet x = 5  // No semicolon\nlet y = 10 // No semicolon\n```\nWhy: Makes syntax ambiguous, hides errors\n\n**2. RAII/destructors**\n```hemlock\n// BAD: This would be rejected\nlet f = open(\"file.txt\");\n// File automatically closed at end of scope\n```\nWhy: Hides when resources are released, not explicit\n\n**3. Implicit type coercion that loses data**\n```hemlock\n// BAD: This would be rejected\nlet x: i32 = 3.14;  // Silently truncates to 3\n```\nWhy: Data loss should be explicit, not silent\n\n**4. Garbage collection**\n```c\n// BAD: This would be rejected\nvoid *gc_malloc(size_t size) {\n    // Track allocation for automatic cleanup\n}\n```\nWhy: Hides memory management, unpredictable performance\n\n**5. Complex macro system**\n```hemlock\n// BAD: This would be rejected\nmacro repeat($n, $block) {\n    for (let i = 0; i < $n; i++) $block\n}\n```\nWhy: Too much magic, makes code hard to reason about\n\n### Common Rejection Reasons\n\n**\"This is too implicit\"**\n- Solution: Make the behavior explicit and document it\n\n**\"This hides complexity\"**\n- Solution: Expose the complexity but make it ergonomic\n\n**\"This breaks existing code\"**\n- Solution: Find a non-breaking alternative or discuss versioning\n\n**\"This doesn't fit Hemlock's philosophy\"**\n- Solution: Re-read philosophy.md and reconsider the approach\n\n---\n\n## Common Patterns\n\n### Error Handling Pattern\n\n```c\n// Use this pattern for recoverable errors in Hemlock code\nValue *divide(Value *a, Value *b)\n{\n    // Check preconditions\n    if (b->type != TYPE_I32) {\n        // Return error value or throw exception\n        return create_error(\"Expected integer divisor\");\n    }\n\n    if (b->i32_value == 0) {\n        return create_error(\"Division by zero\");\n    }\n\n    // Perform operation\n    return value_create_i32(a->i32_value / b->i32_value);\n}\n```\n\n### Memory Management Pattern\n\n```c\n// Pattern: Allocate, use, free\nvoid process_data(void)\n{\n    // Allocate\n    Buffer *buf = create_buffer(1024);\n    char *str = malloc(256);\n\n    // Use\n    if (buf && str) {\n        // ... do work\n    }\n\n    // Free (in reverse order of allocation)\n    free(str);\n    free_buffer(buf);\n}\n```\n\n### Value Creation Pattern\n\n```c\n// Create values using constructors\nValue *create_integer(int32_t n)\n{\n    Value *val = malloc(sizeof(Value));\n    if (!val) {\n        fprintf(stderr, \"Out of memory\\n\");\n        exit(1);\n    }\n\n    val->type = TYPE_I32;\n    val->i32_value = n;\n    return val;\n}\n```\n\n### Type Checking Pattern\n\n```c\n// Check types before operations\nValue *add_values(Value *a, Value *b)\n{\n    // Type checking\n    if (a->type != TYPE_I32 || b->type != TYPE_I32) {\n        return create_error(\"Type mismatch\");\n    }\n\n    // Safe to proceed\n    return value_create_i32(a->i32_value + b->i32_value);\n}\n```\n\n### String Building Pattern\n\n```c\n// Build strings efficiently\nvoid build_error_message(char *buffer, size_t size, const char *detail)\n{\n    snprintf(buffer, size, \"Error: %s (line %d)\", detail, line_number);\n}\n```\n\n---\n\n## Adding New Features\n\n### Feature Addition Checklist\n\nWhen adding a new feature, follow these steps:\n\n#### 1. Design Phase\n\n- [ ] Read philosophy.md to ensure alignment\n- [ ] Create GitHub issue describing the feature\n- [ ] Get maintainer approval for design\n- [ ] Write specification (syntax, semantics, examples)\n- [ ] Consider edge cases and error conditions\n\n#### 2. Implementation Phase\n\n**If adding a language construct:**\n\n- [ ] Add token type to `lexer.h` (if needed)\n- [ ] Add lexer rule in `lexer.c` (if needed)\n- [ ] Add AST node type in `ast.h`\n- [ ] Add AST constructor in `ast.c`\n- [ ] Add parser rule in `parser.c`\n- [ ] Add runtime behavior in `runtime.c` or appropriate module\n- [ ] Handle cleanup in AST free functions\n\n**If adding a built-in function:**\n\n- [ ] Add function implementation in `builtins.c`\n- [ ] Register function in `register_builtins()`\n- [ ] Handle all parameter type combinations\n- [ ] Return appropriate error values\n- [ ] Document parameters and return type\n\n**If adding a value type:**\n\n- [ ] Add type enum in `values.h`\n- [ ] Add field to Value union\n- [ ] Add constructor in `values.c`\n- [ ] Add to `value_free()` for cleanup\n- [ ] Add to `value_copy()` for copying\n- [ ] Add to `value_to_string()` for printing\n- [ ] Add type promotion rules if numeric\n\n#### 3. Testing Phase\n\n- [ ] Write test cases (see testing.md)\n- [ ] Test success cases\n- [ ] Test error cases\n- [ ] Test edge cases\n- [ ] Run full test suite (`make test`)\n- [ ] Check for memory leaks with valgrind\n- [ ] Test on multiple platforms (if possible)\n\n#### 4. Documentation Phase\n\n- [ ] Update CLAUDE.md with user-facing documentation\n- [ ] Add code comments explaining implementation\n- [ ] Create examples in `examples/`\n- [ ] Update relevant docs/ files\n- [ ] Document any breaking changes\n\n#### 5. Submission Phase\n\n- [ ] Clean up debug code and comments\n- [ ] Verify code style compliance\n- [ ] Rebase on latest main\n- [ ] Create pull request with detailed description\n- [ ] Respond to code review feedback\n\n### Example: Adding a New Operator\n\nLet's walk through adding the modulo operator `%` as an example:\n\n**1. Lexer (lexer.c):**\n```c\n// Add to switch statement in get_next_token()\ncase '%':\n    return create_token(TOKEN_PERCENT, \"%\", line);\n```\n\n**2. Lexer header (lexer.h):**\n```c\ntypedef enum {\n    // ... existing tokens\n    TOKEN_PERCENT,\n    // ...\n} TokenType;\n```\n\n**3. AST (ast.h):**\n```c\ntypedef enum {\n    // ... existing operators\n    OP_MOD,\n    // ...\n} BinaryOp;\n```\n\n**4. Parser (parser.c):**\n```c\n// Add to parse_multiplicative() or appropriate precedence level\nif (match(TOKEN_PERCENT)) {\n    BinaryOp op = OP_MOD;\n    ASTNode *right = parse_unary();\n    left = create_binary_op_node(op, left, right);\n}\n```\n\n**5. Runtime (runtime.c):**\n```c\n// Add to eval_binary_op()\ncase OP_MOD:\n    // Type checking\n    if (left->type == TYPE_I32 && right->type == TYPE_I32) {\n        if (right->i32_value == 0) {\n            fprintf(stderr, \"Error: Modulo by zero\\n\");\n            exit(1);\n        }\n        return value_create_i32(left->i32_value % right->i32_value);\n    }\n    // ... handle other type combinations\n    break;\n```\n\n**6. Tests (tests/operators/modulo.hml):**\n```hemlock\n// Basic modulo\nprint(10 % 3);  // Expect: 2\n\n// Negative modulo\nprint(-10 % 3); // Expect: -1\n\n// Error case (should fail)\n// print(10 % 0);  // Division by zero\n```\n\n**7. Documentation (CLAUDE.md):**\n```markdown\n### Arithmetic Operators\n- `+` - Addition\n- `-` - Subtraction\n- `*` - Multiplication\n- `/` - Division\n- `%` - Modulo (remainder)\n```\n\n---\n\n## Code Review Process\n\n### What Reviewers Look For\n\n**1. Correctness**\n- Does the code do what it claims?\n- Are edge cases handled?\n- Are there memory leaks?\n- Are errors handled properly?\n\n**2. Philosophy Alignment**\n- Does this fit Hemlock's design principles?\n- Is it explicit or implicit?\n- Does it hide complexity?\n\n**3. Code Quality**\n- Is the code readable and maintainable?\n- Are variable names descriptive?\n- Are functions reasonably sized?\n- Is there adequate documentation?\n\n**4. Testing**\n- Are there sufficient test cases?\n- Do tests cover success and failure paths?\n- Are edge cases tested?\n\n**5. Documentation**\n- Is user-facing documentation updated?\n- Are code comments clear?\n- Are examples provided?\n\n### Responding to Feedback\n\n**Do:**\n- Thank reviewers for their time\n- Ask clarifying questions if you don't understand\n- Explain your reasoning if you disagree\n- Make requested changes promptly\n- Update the PR description if scope changes\n\n**Don't:**\n- Take criticism personally\n- Argue defensively\n- Ignore feedback\n- Force-push over review comments (unless rebasing)\n- Add unrelated changes to the PR\n\n### Getting Your PR Merged\n\n**Requirements for merge:**\n- [ ] All tests pass\n- [ ] No memory leaks (valgrind clean)\n- [ ] Code review approval from maintainer\n- [ ] Documentation updated\n- [ ] Follows code style guidelines\n- [ ] Aligns with Hemlock's philosophy\n\n**Timeline:**\n- Small PRs (bug fixes): Usually reviewed within a few days\n- Medium PRs (new features): May take 1-2 weeks\n- Large PRs (major changes): Requires extensive discussion\n\n---\n\n## Additional Resources\n\n### Learning Resources\n\n**Understanding interpreters:**\n- \"Crafting Interpreters\" by Robert Nystrom\n- \"Writing An Interpreter In Go\" by Thorsten Ball\n- \"Modern Compiler Implementation in C\" by Andrew Appel\n\n**C programming:**\n- \"The C Programming Language\" by K&R\n- \"Expert C Programming\" by Peter van der Linden\n- \"C Interfaces and Implementations\" by David Hanson\n\n**Memory management:**\n- Valgrind documentation\n- \"Understanding and Using C Pointers\" by Richard Reese\n\n### Useful Commands\n\n```bash\n# Build with debug symbols\nmake clean && make CFLAGS=\"-g -O0\"\n\n# Run with valgrind\nvalgrind --leak-check=full ./hemlock script.hml\n\n# Run specific test category\n./tests/run_tests.sh tests/strings/\n\n# Generate tags file for code navigation\nctags -R .\n\n# Find all TODOs and FIXMEs\ngrep -rn \"TODO\\|FIXME\" src/ include/\n```\n\n---\n\n## Questions?\n\nIf you have questions about contributing:\n\n1. Check the documentation in `docs/`\n2. Search existing GitHub issues\n3. Ask in GitHub Discussions\n4. Open a new issue with your question\n\n**Thank you for contributing to Hemlock!**\n"}, "Contributing -> Testing": {"id": "contributing-testing", "content": "# Testing Guide for Hemlock\n\nThis guide explains Hemlock's testing philosophy, how to write tests, and how to run the test suite.\n\n---\n\n## Table of Contents\n\n- [Testing Philosophy](#testing-philosophy)\n- [Test Suite Structure](#test-suite-structure)\n- [Running Tests](#running-tests)\n- [Writing Tests](#writing-tests)\n- [Test Categories](#test-categories)\n- [Memory Leak Testing](#memory-leak-testing)\n- [Continuous Integration](#continuous-integration)\n- [Best Practices](#best-practices)\n\n---\n\n## Testing Philosophy\n\n### Core Principles\n\n**1. Test-Driven Development (TDD)**\n\nWrite tests **before** implementing features:\n\n```\n1. Write a failing test\n2. Implement the feature\n3. Run the test (should pass)\n4. Refactor if needed\n5. Repeat\n```\n\n**Benefits:**\n- Ensures features actually work\n- Prevents regressions\n- Documents expected behavior\n- Makes refactoring safer\n\n**2. Comprehensive Coverage**\n\nTest both success and failure cases:\n\n```hemlock\n// Success case\nlet x: u8 = 255;  // Should work\n\n// Failure case\nlet y: u8 = 256;  // Should error\n```\n\n**3. Test Early and Often**\n\nRun tests:\n- Before committing code\n- After making changes\n- Before submitting pull requests\n- During code review\n\n**Rule:** All tests must pass before merging.\n\n### What to Test\n\n**Always test:**\n- ✅ Basic functionality (happy path)\n- ✅ Error conditions (sad path)\n- ✅ Edge cases (boundary conditions)\n- ✅ Type checking and conversions\n- ✅ Memory management (no leaks)\n- ✅ Concurrency and race conditions\n\n**Example test coverage:**\n```hemlock\n// Feature: String.substr(start, length)\n\n// Happy path\nprint(\"hello\".substr(0, 5));  // \"hello\"\n\n// Edge cases\nprint(\"hello\".substr(0, 0));  // \"\" (empty)\nprint(\"hello\".substr(5, 0));  // \"\" (at end)\nprint(\"hello\".substr(2, 100)); // \"llo\" (past end)\n\n// Error cases\n// \"hello\".substr(-1, 5);  // Error: negative index\n// \"hello\".substr(0, -1);  // Error: negative length\n```\n\n---\n\n## Test Suite Structure\n\n### Directory Organization\n\n```\ntests/\n├── run_tests.sh          # Main test runner script\n├── primitives/           # Type system tests\n│   ├── integers.hml\n│   ├── floats.hml\n│   ├── booleans.hml\n│   ├── i64.hml\n│   └── u64.hml\n├── conversions/          # Type conversion tests\n│   ├── int_to_float.hml\n│   ├── promotion.hml\n│   └── rune_conversions.hml\n├── memory/               # Pointer/buffer tests\n│   ├── alloc.hml\n│   ├── buffer.hml\n│   └── memcpy.hml\n├── strings/              # String operation tests\n│   ├── concat.hml\n│   ├── methods.hml\n│   ├── utf8.hml\n│   └── runes.hml\n├── control/              # Control flow tests\n│   ├── if.hml\n│   ├── switch.hml\n│   └── while.hml\n├── functions/            # Function and closure tests\n│   ├── basics.hml\n│   ├── closures.hml\n│   └── recursion.hml\n├── objects/              # Object tests\n│   ├── literals.hml\n│   ├── methods.hml\n│   ├── duck_typing.hml\n│   └── serialization.hml\n├── arrays/               # Array operation tests\n│   ├── basics.hml\n│   ├── methods.hml\n│   └── slicing.hml\n├── loops/                # Loop tests\n│   ├── for.hml\n│   ├── while.hml\n│   ├── break.hml\n│   └── continue.hml\n├── exceptions/           # Error handling tests\n│   ├── try_catch.hml\n│   ├── finally.hml\n│   └── throw.hml\n├── io/                   # File I/O tests\n│   ├── file_object.hml\n│   ├── read_write.hml\n│   └── seek.hml\n├── async/                # Concurrency tests\n│   ├── spawn_join.hml\n│   ├── channels.hml\n│   └── exceptions.hml\n├── ffi/                  # FFI tests\n│   ├── basic_call.hml\n│   ├── types.hml\n│   └── dlopen.hml\n├── signals/              # Signal handling tests\n│   ├── basic.hml\n│   ├── handlers.hml\n│   └── raise.hml\n└── args/                 # Command-line args tests\n    └── basic.hml\n```\n\n### Test File Naming\n\n**Conventions:**\n- Use descriptive names: `method_chaining.hml` not `test1.hml`\n- Group related tests: `string_substr.hml`, `string_slice.hml`\n- One feature area per file\n- Keep files focused and small\n\n---\n\n## Running Tests\n\n### Run All Tests\n\n```bash\n# From hemlock root directory\nmake test\n\n# Or directly\n./tests/run_tests.sh\n```\n\n**Output:**\n```\nRunning tests in tests/primitives/...\n  ✓ integers.hml\n  ✓ floats.hml\n  ✓ booleans.hml\n\nRunning tests in tests/strings/...\n  ✓ concat.hml\n  ✓ methods.hml\n\n...\n\nTotal: 251 tests\nPassed: 251\nFailed: 0\n```\n\n### Run Specific Category\n\n```bash\n# Run only string tests\n./tests/run_tests.sh tests/strings/\n\n# Run only one test file\n./tests/run_tests.sh tests/strings/concat.hml\n\n# Run multiple categories\n./tests/run_tests.sh tests/strings/ tests/arrays/\n```\n\n### Run with Valgrind (Memory Leak Check)\n\n```bash\n# Check single test for leaks\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\n\n# Check all tests (slow!)\nfor test in tests/**/*.hml; do\n    echo \"Testing $test\"\n    valgrind --leak-check=full --error-exitcode=1 ./hemlock \"$test\"\ndone\n```\n\n### Debug Failed Tests\n\n```bash\n# Run with verbose output\n./hemlock tests/failing_test.hml\n\n# Run with gdb\ngdb --args ./hemlock tests/failing_test.hml\n(gdb) run\n(gdb) backtrace  # if it crashes\n```\n\n---\n\n## Writing Tests\n\n### Test File Format\n\nTest files are just Hemlock programs with expected output:\n\n**Example: tests/primitives/integers.hml**\n```hemlock\n// Test basic integer literals\nlet x = 42;\nprint(x);  // Expect: 42\n\nlet y: i32 = 100;\nprint(y);  // Expect: 100\n\n// Test arithmetic\nlet sum = x + y;\nprint(sum);  // Expect: 142\n\n// Test type inference\nlet small = 10;\nprint(typeof(small));  // Expect: i32\n\nlet large = 5000000000;\nprint(typeof(large));  // Expect: i64\n```\n\n**How tests work:**\n1. Test runner executes the .hml file\n2. Captures stdout output\n3. Compares with expected output (from comments or separate .out file)\n4. Reports pass/fail\n\n### Expected Output Methods\n\n**Method 1: Inline comments (recommended for simple tests)**\n\n```hemlock\nprint(\"hello\");  // Expect: hello\nprint(42);       // Expect: 42\n```\n\nThe test runner parses `// Expect: ...` comments.\n\n**Method 2: Separate .out file**\n\nCreate `test_name.hml.out` with expected output:\n\n**test_name.hml:**\n```hemlock\nprint(\"line 1\");\nprint(\"line 2\");\nprint(\"line 3\");\n```\n\n**test_name.hml.out:**\n```\nline 1\nline 2\nline 3\n```\n\n### Testing Error Cases\n\nError tests should cause the program to exit with non-zero status:\n\n**Example: tests/primitives/range_error.hml**\n```hemlock\n// This should fail with a type error\nlet x: u8 = 256;  // Out of range for u8\n```\n\n**Expected behavior:**\n- Program exits with non-zero status\n- Prints error message to stderr\n\n**Test runner handling:**\n- Tests expecting errors should be in separate files\n- Use naming convention: `*_error.hml` or `*_fail.hml`\n- Document expected error in comments\n\n### Testing Success Cases\n\n**Example: tests/strings/methods.hml**\n```hemlock\n// Test substr\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);\nprint(sub);  // Expect: world\n\n// Test find\nlet pos = s.find(\"world\");\nprint(pos);  // Expect: 6\n\n// Test contains\nlet has = s.contains(\"lo\");\nprint(has);  // Expect: true\n\n// Test trim\nlet padded = \"  hello  \";\nlet trimmed = padded.trim();\nprint(trimmed);  // Expect: hello\n```\n\n### Testing Edge Cases\n\n**Example: tests/arrays/edge_cases.hml**\n```hemlock\n// Empty array\nlet empty = [];\nprint(empty.length);  // Expect: 0\n\n// Single element\nlet single = [42];\nprint(single[0]);  // Expect: 42\n\n// Negative index (should error in separate test file)\n// print(single[-1]);  // Error\n\n// Past-end index (should error)\n// print(single[100]);  // Error\n\n// Boundary conditions\nlet arr = [1, 2, 3];\nprint(arr.slice(0, 0));  // Expect: [] (empty)\nprint(arr.slice(3, 3));  // Expect: [] (empty)\nprint(arr.slice(1, 2));  // Expect: [2]\n```\n\n### Testing Type System\n\n**Example: tests/conversions/promotion.hml**\n```hemlock\n// Test type promotion in binary operations\n\n// i32 + i64 -> i64\nlet a: i32 = 10;\nlet b: i64 = 20;\nlet c = a + b;\nprint(typeof(c));  // Expect: i64\n\n// i32 + f32 -> f32\nlet d: i32 = 10;\nlet e: f32 = 3.14;\nlet f = d + e;\nprint(typeof(f));  // Expect: f32\n\n// u8 + i32 -> i32\nlet g: u8 = 5;\nlet h: i32 = 10;\nlet i = g + h;\nprint(typeof(i));  // Expect: i32\n```\n\n### Testing Concurrency\n\n**Example: tests/async/basic.hml**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// Spawn tasks\nlet t1 = spawn(compute, 10);\nlet t2 = spawn(compute, 20);\n\n// Join and print results\nlet r1 = join(t1);\nlet r2 = join(t2);\nprint(r1);  // Expect: 45\nprint(r2);  // Expect: 190\n```\n\n### Testing Exceptions\n\n**Example: tests/exceptions/try_catch.hml**\n```hemlock\n// Test basic try/catch\ntry {\n    throw \"error message\";\n} catch (e) {\n    print(\"Caught: \" + e);  // Expect: Caught: error message\n}\n\n// Test finally\nlet executed = false;\ntry {\n    print(\"try\");  // Expect: try\n} finally {\n    executed = true;\n    print(\"finally\");  // Expect: finally\n}\n\n// Test exception propagation\nfn risky(): i32 {\n    throw \"failure\";\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(e);  // Expect: failure\n}\n```\n\n---\n\n## Test Categories\n\n### Primitives Tests\n\n**What to test:**\n- Integer types (i8, i16, i32, i64, u8, u16, u32, u64)\n- Float types (f32, f64)\n- Boolean type\n- String type\n- Rune type\n- Null type\n\n**Example areas:**\n- Literal syntax\n- Type inference\n- Range checking\n- Overflow behavior\n- Type annotations\n\n### Conversion Tests\n\n**What to test:**\n- Implicit type promotion\n- Explicit type conversion\n- Lossy conversions (should error)\n- Type promotion in operations\n- Cross-type comparisons\n\n### Memory Tests\n\n**What to test:**\n- alloc/free correctness\n- Buffer creation and access\n- Bounds checking on buffers\n- memset, memcpy, realloc\n- Memory leak detection (valgrind)\n\n### String Tests\n\n**What to test:**\n- Concatenation\n- All 18 string methods\n- UTF-8 handling\n- Rune indexing\n- String + rune concatenation\n- Edge cases (empty strings, single char, etc.)\n\n### Control Flow Tests\n\n**What to test:**\n- if/else/else if\n- while loops\n- for loops\n- switch statements\n- break/continue\n- return statements\n\n### Function Tests\n\n**What to test:**\n- Function definition and calling\n- Parameter passing\n- Return values\n- Recursion\n- Closures and capture\n- First-class functions\n- Anonymous functions\n\n### Object Tests\n\n**What to test:**\n- Object literals\n- Field access and assignment\n- Methods and self binding\n- Duck typing\n- Optional fields\n- JSON serialization/deserialization\n- Circular reference detection\n\n### Array Tests\n\n**What to test:**\n- Array creation\n- Indexing and assignment\n- All 15 array methods\n- Mixed types\n- Dynamic resizing\n- Edge cases (empty, single element)\n\n### Exception Tests\n\n**What to test:**\n- try/catch/finally\n- throw statement\n- Exception propagation\n- Nested try/catch\n- Return in try/catch/finally\n- Uncaught exceptions\n\n### I/O Tests\n\n**What to test:**\n- File opening modes\n- Read/write operations\n- Seek/tell\n- File properties\n- Error handling (missing files, etc.)\n- Resource cleanup\n\n### Async Tests\n\n**What to test:**\n- spawn/join/detach\n- Channel send/recv\n- Exception propagation in tasks\n- Multiple concurrent tasks\n- Channel blocking behavior\n\n### FFI Tests\n\n**What to test:**\n- dlopen/dlclose\n- dlsym\n- dlcall with various types\n- Type conversion\n- Error handling\n\n---\n\n## Memory Leak Testing\n\n### Using Valgrind\n\n**Basic usage:**\n```bash\nvalgrind --leak-check=full ./hemlock test.hml\n```\n\n**Example output (no leaks):**\n```\n==12345== HEAP SUMMARY:\n==12345==     in use at exit: 0 bytes in 0 blocks\n==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated\n==12345==\n==12345== All heap blocks were freed -- no leaks are possible\n```\n\n**Example output (with leak):**\n```\n==12345== LEAK SUMMARY:\n==12345==    definitely lost: 64 bytes in 1 blocks\n==12345==    indirectly lost: 0 bytes in 0 blocks\n==12345==      possibly lost: 0 bytes in 0 blocks\n==12345==    still reachable: 0 bytes in 0 blocks\n==12345==         suppressed: 0 bytes in 0 blocks\n```\n\n### Common Leak Sources\n\n**1. Missing free() calls:**\n```c\n// BAD\nchar *str = malloc(100);\n// ... use str\n// Forgot to free!\n\n// GOOD\nchar *str = malloc(100);\n// ... use str\nfree(str);\n```\n\n**2. Lost pointers:**\n```c\n// BAD\nchar *ptr = malloc(100);\nptr = malloc(200);  // Lost reference to first allocation!\n\n// GOOD\nchar *ptr = malloc(100);\nfree(ptr);\nptr = malloc(200);\n```\n\n**3. Exception paths:**\n```c\n// BAD\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        return;  // Leak!\n    }\n    free(data);\n}\n\n// GOOD\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        free(data);\n        return;\n    }\n    free(data);\n}\n```\n\n### Known Acceptable Leaks\n\nSome small \"leaks\" are intentional startup allocations:\n\n**Global built-ins:**\n```hemlock\n// Built-in functions, FFI types, and constants are allocated at startup\n// and not freed at exit (typically ~200 bytes)\n```\n\nThese are not true leaks - they're one-time allocations that persist for the program lifetime and are cleaned up by the OS on exit.\n\n---\n\n## Continuous Integration\n\n### GitHub Actions (Future)\n\nOnce CI is set up, all tests will run automatically on:\n- Push to main branch\n- Pull request creation/update\n- Scheduled daily runs\n\n**CI workflow:**\n1. Build Hemlock\n2. Run test suite\n3. Check for memory leaks (valgrind)\n4. Report results on PR\n\n### Pre-Commit Checks\n\nBefore committing, run:\n\n```bash\n# Build fresh\nmake clean && make\n\n# Run all tests\nmake test\n\n# Check a few tests for leaks\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\nvalgrind --leak-check=full ./hemlock tests/strings/concat.hml\n```\n\n---\n\n## Best Practices\n\n### Do's\n\n✅ **Write tests first (TDD)**\n```bash\n1. Create tests/feature/new_feature.hml\n2. Implement feature in src/\n3. Run tests until they pass\n```\n\n✅ **Test both success and failure**\n```hemlock\n// Success: tests/feature/success.hml\nlet result = do_thing();\nprint(result);  // Expect: expected value\n\n// Failure: tests/feature/failure.hml\ndo_invalid_thing();  // Should error\n```\n\n✅ **Use descriptive test names**\n```\nGood: tests/strings/substr_utf8_boundary.hml\nBad:  tests/test1.hml\n```\n\n✅ **Keep tests focused**\n- One feature area per file\n- Clear setup and assertions\n- Minimal code\n\n✅ **Add comments explaining tricky tests**\n```hemlock\n// Test that closure captures outer variable by reference\nfn outer() {\n    let x = 10;\n    let f = fn() { return x; };\n    x = 20;  // Modify after closure creation\n    return f();  // Should return 20, not 10\n}\n```\n\n✅ **Test edge cases**\n- Empty inputs\n- Null values\n- Boundary values (min/max)\n- Large inputs\n- Negative values\n\n### Don'ts\n\n❌ **Don't skip tests**\n- All tests must pass before merging\n- Don't comment out failing tests\n- Fix the bug or remove the feature\n\n❌ **Don't write tests that depend on each other**\n```hemlock\n// BAD: test2.hml depends on test1.hml output\n// Tests should be independent\n```\n\n❌ **Don't use random values in tests**\n```hemlock\n// BAD: Non-deterministic\nlet x = random();\nprint(x);  // Can't predict output\n\n// GOOD: Deterministic\nlet x = 42;\nprint(x);  // Expect: 42\n```\n\n❌ **Don't test implementation details**\n```hemlock\n// BAD: Testing internal structure\nlet obj = { x: 10 };\n// Don't check internal field order, capacity, etc.\n\n// GOOD: Testing behavior\nprint(obj.x);  // Expect: 10\n```\n\n❌ **Don't ignore memory leaks**\n- All tests should be valgrind-clean\n- Document known/acceptable leaks\n- Fix leaks before merging\n\n### Test Maintenance\n\n**When to update tests:**\n- Feature behavior changes\n- Bug fixes require new test cases\n- Edge cases discovered\n- Performance improvements\n\n**When to remove tests:**\n- Feature removed from language\n- Test duplicates existing coverage\n- Test was incorrect\n\n**Refactoring tests:**\n- Group related tests together\n- Extract common setup code\n- Use consistent naming\n- Keep tests simple and readable\n\n---\n\n## Example Test Session\n\nHere's a complete example of adding a feature with tests:\n\n### Feature: Add `array.first()` method\n\n**1. Write the test first:**\n\n```bash\n# Create test file\ncat > tests/arrays/first_method.hml << 'EOF'\n// Test array.first() method\n\n// Basic case\nlet arr = [1, 2, 3];\nprint(arr.first());  // Expect: 1\n\n// Single element\nlet single = [42];\nprint(single.first());  // Expect: 42\n\n// Empty array (should error - separate test file)\n// let empty = [];\n// print(empty.first());  // Error\nEOF\n```\n\n**2. Run the test (should fail):**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n# Error: Method 'first' not found on array\n```\n\n**3. Implement the feature:**\n\nEdit `src/interpreter/builtins.c`:\n\n```c\n// Add array_first method\nValue *array_first(Value *self, Value **args, int arg_count)\n{\n    if (self->array_value->length == 0) {\n        fprintf(stderr, \"Error: Cannot get first element of empty array\\n\");\n        exit(1);\n    }\n\n    return value_copy(&self->array_value->elements[0]);\n}\n\n// Register in array method table\n// ... add to array method registration\n```\n\n**4. Run the test (should pass):**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n1\n42\n# Success!\n```\n\n**5. Check for memory leaks:**\n\n```bash\nvalgrind --leak-check=full ./hemlock tests/arrays/first_method.hml\n# All heap blocks were freed -- no leaks are possible\n```\n\n**6. Run full test suite:**\n\n```bash\nmake test\n# Total: 252 tests (251 + new one)\n# Passed: 252\n# Failed: 0\n```\n\n**7. Commit:**\n\n```bash\ngit add tests/arrays/first_method.hml src/interpreter/builtins.c\ngit commit -m \"Add array.first() method with tests\"\n```\n\n---\n\n## Summary\n\n**Remember:**\n- Write tests first (TDD)\n- Test success and failure cases\n- Run all tests before committing\n- Check for memory leaks\n- Document known issues\n- Keep tests simple and focused\n\n**Test quality is just as important as code quality!**\n"}, "hpm: Getting Started -> Installation": {"id": "hpm-installation", "content": "# 安装\n\n本指南介绍如何在你的系统上安装 hpm。\n\n## 快速安装（推荐）\n\n使用单个命令安装最新版本：\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\n这会自动：\n- 检测你的操作系统（Linux、macOS）\n- 检测你的架构（x86_64、arm64）\n- 下载相应的预编译二进制文件\n- 安装到 `/usr/local/bin`（如需要会使用 sudo）\n\n### 安装选项\n\n```bash\n# 安装到自定义位置（无需 sudo）\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local\n\n# 安装特定版本\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5\n\n# 组合选项\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5\n```\n\n### 支持的平台\n\n| 平台 | 架构 | 状态 |\n|----------|--------------|--------|\n| Linux    | x86_64       | 支持 |\n| macOS    | x86_64       | 支持 |\n| macOS    | arm64 (M1/M2/M3) | 支持 |\n| Linux    | arm64        | 从源码构建 |\n\n## 从源码构建\n\n如果你希望从源码构建，或需要预编译二进制文件未覆盖的平台，请按以下说明操作。\n\n### 前提条件\n\nhpm 需要先安装 [Hemlock](https://github.com/hemlang/hemlock)。请先按照 Hemlock 安装说明进行操作。\n\n验证 Hemlock 是否已安装：\n\n```bash\nhemlock --version\n```\n\n## 安装方法\n\n### 方法 1：Make Install\n\n从源码构建并安装。\n\n```bash\n# 克隆仓库\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# 安装到 /usr/local/bin（需要 sudo）\nsudo make install\n```\n\n安装后，验证是否正常工作：\n\n```bash\nhpm --version\n```\n\n### 方法 2：自定义位置\n\n安装到自定义目录（无需 sudo）：\n\n```bash\n# 克隆仓库\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# 安装到 ~/.local/bin\nmake install PREFIX=$HOME/.local\n\n# 或任何自定义位置\nmake install PREFIX=/opt/hemlock\n```\n\n确保你的自定义 bin 目录在 PATH 中：\n\n```bash\n# 添加到 ~/.bashrc 或 ~/.zshrc\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n### 方法 3：不安装直接运行\n\n你可以直接运行 hpm 而无需安装：\n\n```bash\n# 克隆仓库\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# 创建本地包装脚本\nmake\n\n# 从 hpm 目录运行\n./hpm --help\n\n# 或直接通过 hemlock 运行\nhemlock src/main.hml --help\n```\n\n### 方法 4：手动安装\n\n创建你自己的包装脚本：\n\n```bash\n# 克隆到永久位置\ngit clone https://github.com/hemlang/hpm.git ~/.hpm-source\n\n# 创建包装脚本\ncat > ~/.local/bin/hpm << 'EOF'\n#!/bin/sh\nexec hemlock \"$HOME/.hpm-source/src/main.hml\" \"$@\"\nEOF\n\nchmod +x ~/.local/bin/hpm\n```\n\n## 安装变量\n\nMakefile 支持以下变量：\n\n| 变量 | 默认值 | 描述 |\n|----------|---------|-------------|\n| `PREFIX` | `/usr/local` | 安装前缀 |\n| `BINDIR` | `$(PREFIX)/bin` | 二进制文件目录 |\n| `HEMLOCK` | `hemlock` | hemlock 解释器路径 |\n\n使用自定义变量的示例：\n\n```bash\nmake install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock\n```\n\n## 工作原理\n\n安装程序创建一个 shell 包装脚本，使用 hpm 源代码调用 Hemlock 解释器：\n\n```bash\n#!/bin/sh\nexec hemlock \"/path/to/hpm/src/main.hml\" \"$@\"\n```\n\n这种方法：\n- 无需编译\n- 始终运行最新源代码\n- 在所有平台上可靠运行\n\n## 更新 hpm\n\n要将 hpm 更新到最新版本：\n\n```bash\ncd /path/to/hpm\ngit pull origin main\n\n# 如果路径改变了，重新安装\nsudo make install\n```\n\n## 卸载\n\n从系统中移除 hpm：\n\n```bash\ncd /path/to/hpm\nsudo make uninstall\n```\n\n或手动移除：\n\n```bash\nsudo rm /usr/local/bin/hpm\n```\n\n## 验证安装\n\n安装后，验证一切正常：\n\n```bash\n# 检查版本\nhpm --version\n\n# 查看帮助\nhpm --help\n\n# 测试初始化（在空目录中）\nmkdir test-project && cd test-project\nhpm init --yes\ncat package.json\n```\n\n## 故障排除\n\n### \"hemlock: command not found\"\n\nHemlock 未安装或不在 PATH 中。请先安装 Hemlock：\n\n```bash\n# 检查 hemlock 是否存在\nwhich hemlock\n\n# 如果未找到，从 https://github.com/hemlang/hemlock 安装 Hemlock\n```\n\n### \"Permission denied\"\n\n使用 sudo 进行系统范围安装，或安装到用户目录：\n\n```bash\n# 选项 1：使用 sudo\nsudo make install\n\n# 选项 2：安装到用户目录\nmake install PREFIX=$HOME/.local\n```\n\n### 安装后 \"hpm: command not found\"\n\n你的 PATH 可能不包含安装目录：\n\n```bash\n# 检查 hpm 安装位置\nls -la /usr/local/bin/hpm\n\n# 如果使用自定义位置，添加到 PATH\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## 平台特定说明\n\n### Linux\n\n标准安装适用于所有 Linux 发行版。某些发行版可能需要：\n\n```bash\n# Debian/Ubuntu：确保安装构建工具\nsudo apt-get install build-essential git\n\n# Fedora/RHEL\nsudo dnf install make git\n```\n\n### macOS\n\n标准安装可用。如果使用 Homebrew：\n\n```bash\n# 确保安装 Xcode 命令行工具\nxcode-select --install\n```\n\n### Windows (WSL)\n\nhpm 在 Windows Subsystem for Linux 中可用：\n\n```bash\n# 在 WSL 终端中\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\nmake install PREFIX=$HOME/.local\n```\n\n## 后续步骤\n\n安装后：\n\n1. [快速开始](#hpm-installation-quick-start) - 创建你的第一个项目\n2. [命令参考](#hpm-installation-commands) - 学习所有命令\n3. [配置](#hpm-installation-configuration) - 配置 hpm\n"}, "hpm: Getting Started -> Project Setup": {"id": "hpm-project-setup", "content": "# 项目设置\n\n使用 hpm 设置 Hemlock 项目的完整指南。\n\n## 创建新项目\n\n### 基本设置\n\n从头创建新项目：\n\n```bash\n# 创建项目目录\nmkdir my-project\ncd my-project\n\n# 初始化 package.json\nhpm init\n\n# 创建目录结构\nmkdir -p src test\n```\n\n### 项目模板\n\n以下是不同用例的常见项目结构：\n\n#### 库包\n\n用于可复用的库：\n\n```\nmy-library/\n├── package.json\n├── README.md\n├── LICENSE\n├── src/\n│   ├── index.hml          # 主入口，导出公共 API\n│   ├── core.hml           # 核心功能\n│   ├── utils.hml          # 工具函数\n│   └── types.hml          # 类型定义\n└── test/\n    ├── framework.hml      # 测试框架\n    ├── run.hml            # 测试运行器\n    └── test_core.hml      # 测试\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-library\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A reusable Hemlock library\",\n  \"main\": \"src/index.hml\",\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {}\n}\n```\n\n#### 应用程序\n\n用于独立应用程序：\n\n```\nmy-app/\n├── package.json\n├── README.md\n├── src/\n│   ├── main.hml           # 应用程序入口点\n│   ├── config.hml         # 配置\n│   ├── commands/          # CLI 命令\n│   │   ├── index.hml\n│   │   └── run.hml\n│   └── lib/               # 内部库\n│       └── utils.hml\n├── test/\n│   └── run.hml\n└── data/                  # 数据文件\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Hemlock application\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {}\n}\n```\n\n#### Web 应用程序\n\n用于 Web 服务器：\n\n```\nmy-web-app/\n├── package.json\n├── README.md\n├── src/\n│   ├── main.hml           # 服务器入口点\n│   ├── routes/            # 路由处理器\n│   │   ├── index.hml\n│   │   ├── api.hml\n│   │   └── auth.hml\n│   ├── middleware/        # 中间件\n│   │   ├── index.hml\n│   │   └── auth.hml\n│   ├── models/            # 数据模型\n│   │   └── user.hml\n│   └── services/          # 业务逻辑\n│       └── user.hml\n├── test/\n│   └── run.hml\n├── static/                # 静态文件\n│   ├── css/\n│   └── js/\n└── views/                 # 模板\n    └── index.hml\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-web-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Hemlock web application\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\",\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  }\n}\n```\n\n## package.json 文件\n\n### 必需字段\n\n```json\n{\n  \"name\": \"owner/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n### 所有字段\n\n```json\n{\n  \"name\": \"yourusername/my-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Package description\",\n  \"author\": \"Your Name <you@example.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/yourusername/my-package\",\n  \"homepage\": \"https://yourusername.github.io/my-package\",\n  \"bugs\": \"https://github.com/yourusername/my-package/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"utility\", \"parser\"],\n  \"dependencies\": {\n    \"owner/package\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"owner/test-lib\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n### 字段参考\n\n| 字段 | 类型 | 描述 |\n|-------|------|-------------|\n| `name` | string | owner/repo 格式的包名称（必需） |\n| `version` | string | 语义化版本（必需） |\n| `description` | string | 简短描述 |\n| `author` | string | 作者姓名和邮箱 |\n| `license` | string | 许可证标识符（MIT、Apache-2.0 等） |\n| `repository` | string | 仓库 URL |\n| `homepage` | string | 项目主页 |\n| `bugs` | string | 问题跟踪器 URL |\n| `main` | string | 入口点文件（默认：src/index.hml） |\n| `keywords` | array | 搜索关键词 |\n| `dependencies` | object | 运行时依赖 |\n| `devDependencies` | object | 开发依赖 |\n| `scripts` | object | 命名脚本 |\n| `files` | array | 发布时包含的文件 |\n| `native` | object | 原生库要求 |\n\n## package-lock.json 文件\n\n锁定文件自动生成，应提交到版本控制。它确保可重现的安装。\n\n```json\n{\n  \"lockVersion\": 1,\n  \"hemlock\": \"1.0.0\",\n  \"dependencies\": {\n    \"hemlang/sprout\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz\",\n      \"integrity\": \"sha256-abc123...\",\n      \"dependencies\": {\n        \"hemlang/router\": \"^1.5.0\"\n      }\n    },\n    \"hemlang/router\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://github.com/hemlang/router/archive/v1.5.0.tar.gz\",\n      \"integrity\": \"sha256-def456...\",\n      \"dependencies\": {}\n    }\n  }\n}\n```\n\n### 锁定文件最佳实践\n\n- **提交** package-lock.json 到版本控制\n- **不要手动编辑** - 它是自动生成的\n- **拉取更改后运行 `hpm install`**\n- **如果损坏则删除并重新生成**：\n  ```bash\n  rm package-lock.json\n  hpm install\n  ```\n\n## hem_modules 目录\n\n已安装的包存储在 `hem_modules/` 中：\n\n```\nhem_modules/\n├── hemlang/\n│   ├── sprout/\n│   │   ├── package.json\n│   │   └── src/\n│   └── router/\n│       ├── package.json\n│       └── src/\n└── alice/\n    └── http-client/\n        ├── package.json\n        └── src/\n```\n\n### hem_modules 最佳实践\n\n- **添加到 .gitignore** - 不要提交依赖\n- **不要修改** - 更改会被覆盖\n- **删除以重新安装**：\n  ```bash\n  rm -rf hem_modules\n  hpm install\n  ```\n\n## .gitignore\n\nHemlock 项目推荐的 .gitignore：\n\n```gitignore\n# Dependencies\nhem_modules/\n\n# Build output\ndist/\n*.hmlc\n\n# IDE files\n.idea/\n.vscode/\n*.swp\n*.swo\n\n# OS files\n.DS_Store\nThumbs.db\n\n# Logs\n*.log\nlogs/\n\n# Environment\n.env\n.env.local\n\n# Test coverage\ncoverage/\n```\n\n## 使用依赖\n\n### 添加依赖\n\n```bash\n# 添加运行时依赖\nhpm install hemlang/json\n\n# 使用版本约束添加\nhpm install hemlang/sprout@^2.0.0\n\n# 添加开发依赖\nhpm install hemlang/test-utils --dev\n```\n\n### 导入依赖\n\n```hemlock\n// Import from package (uses \"main\" entry)\nimport { parse, stringify } from \"hemlang/json\";\n\n// Import from subpath\nimport { Router } from \"hemlang/sprout/router\";\n\n// Import standard library\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile, writeFile } from \"@stdlib/fs\";\n```\n\n### 导入解析\n\nhpm 按以下顺序解析导入：\n\n1. **标准库**：`@stdlib/*` 导入内置模块\n2. **包根目录**：`owner/repo` 使用 `main` 字段\n3. **子路径**：`owner/repo/path` 检查：\n   - `hem_modules/owner/repo/path.hml`\n   - `hem_modules/owner/repo/path/index.hml`\n   - `hem_modules/owner/repo/src/path.hml`\n   - `hem_modules/owner/repo/src/path/index.hml`\n\n## 脚本\n\n### 定义脚本\n\n在 package.json 中添加脚本：\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n### 运行脚本\n\n```bash\nhpm run start\nhpm run dev\nhpm run build\n\n# test 的简写\nhpm test\n\n# 传递参数\nhpm run test -- --verbose --filter=unit\n```\n\n### 脚本命名约定\n\n| 脚本 | 用途 |\n|--------|---------|\n| `start` | 运行应用程序 |\n| `dev` | 以开发模式运行 |\n| `test` | 运行所有测试 |\n| `build` | 为生产环境构建 |\n| `clean` | 移除生成的文件 |\n| `lint` | 检查代码风格 |\n| `format` | 格式化代码 |\n\n## 开发工作流\n\n### 初始设置\n\n```bash\n# 克隆项目\ngit clone https://github.com/yourusername/my-project.git\ncd my-project\n\n# 安装依赖\nhpm install\n\n# 运行测试\nhpm test\n\n# 开始开发\nhpm run dev\n```\n\n### 日常工作流\n\n```bash\n# 拉取最新更改\ngit pull\n\n# 安装任何新依赖\nhpm install\n\n# 进行更改...\n\n# 运行测试\nhpm test\n\n# 提交\ngit add .\ngit commit -m \"Add feature\"\ngit push\n```\n\n### 添加新功能\n\n```bash\n# 创建功能分支\ngit checkout -b feature/new-feature\n\n# 如果需要，添加新依赖\nhpm install hemlang/new-lib\n\n# 实现功能...\n\n# 测试\nhpm test\n\n# 提交并推送\ngit add .\ngit commit -m \"Add new feature\"\ngit push -u origin feature/new-feature\n```\n\n## 环境特定配置\n\n### 使用环境变量\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nlet db_host = getenv(\"DATABASE_HOST\") ?? \"localhost\";\nlet api_key = getenv(\"API_KEY\") ?? \"\";\n\nif api_key == \"\" {\n    print(\"Warning: API_KEY not set\");\n}\n```\n\n### 配置文件\n\n**config.hml:**\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nexport let config = {\n    environment: getenv(\"HEMLOCK_ENV\") ?? \"development\",\n    database: {\n        host: getenv(\"DB_HOST\") ?? \"localhost\",\n        port: int(getenv(\"DB_PORT\") ?? \"5432\"),\n        name: getenv(\"DB_NAME\") ?? \"myapp\"\n    },\n    server: {\n        port: int(getenv(\"PORT\") ?? \"3000\"),\n        host: getenv(\"HOST\") ?? \"0.0.0.0\"\n    }\n};\n\nexport fn is_production(): bool {\n    return config.environment == \"production\";\n}\n```\n\n## 另请参阅\n\n- [快速开始](#hpm-project-setup-quick-start) - 快速入门\n- [命令](#hpm-project-setup-commands) - 命令参考\n- [创建包](#hpm-project-setup-creating-packages) - 发布包\n- [配置](#hpm-project-setup-configuration) - hpm 配置\n"}, "hpm: Getting Started -> Quick Start": {"id": "hpm-quick-start", "content": "# 快速开始\n\n5 分钟内开始使用 hpm。\n\n## 安装 hpm\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\n更多安装选项请参阅[安装指南](#hpm-quick-start-installation)。\n\n## 创建新项目\n\n首先创建一个新目录并初始化包：\n\n```bash\nmkdir my-project\ncd my-project\nhpm init\n```\n\n系统会提示你输入项目详情：\n\n```\nPackage name (owner/repo): myname/my-project\nVersion (1.0.0):\nDescription: My awesome Hemlock project\nAuthor: Your Name <you@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n使用 `--yes` 接受所有默认值：\n\n```bash\nhpm init --yes\n```\n\n## 项目结构\n\n创建基本项目结构：\n\n```\nmy-project/\n├── package.json        # 项目清单\n├── src/\n│   └── index.hml      # 主入口点\n└── test/\n    └── test.hml       # 测试文件\n```\n\n创建主文件：\n\n```bash\nmkdir -p src test\n```\n\n**src/index.hml:**\n```hemlock\n// Main entry point\nexport fn greet(name: string): string {\n    return \"Hello, \" + name + \"!\";\n}\n\nexport fn main() {\n    print(greet(\"World\"));\n}\n```\n\n## 安装依赖\n\n在 GitHub 上搜索包（包使用 `owner/repo` 格式）：\n\n```bash\n# 安装一个包\nhpm install hemlang/sprout\n\n# 使用版本约束安装\nhpm install hemlang/json@^1.0.0\n\n# 安装为开发依赖\nhpm install hemlang/test-utils --dev\n```\n\n安装后，你的项目结构将包含 `hem_modules/`：\n\n```\nmy-project/\n├── package.json\n├── package-lock.json   # 锁定文件（自动生成）\n├── hem_modules/        # 已安装的包\n│   └── hemlang/\n│       └── sprout/\n├── src/\n│   └── index.hml\n└── test/\n    └── test.hml\n```\n\n## 使用已安装的包\n\n使用 GitHub 路径导入包：\n\n```hemlock\n// Import from installed package\nimport { app, router } from \"hemlang/sprout\";\nimport { parse, stringify } from \"hemlang/json\";\n\n// Import from subpath\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// Standard library (built-in)\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile } from \"@stdlib/fs\";\n```\n\n## 添加脚本\n\n在 `package.json` 中添加脚本：\n\n```json\n{\n  \"name\": \"myname/my-project\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/test.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\n使用 `hpm run` 运行脚本：\n\n```bash\nhpm run start\nhpm run build\n\n# test 的简写形式\nhpm test\n```\n\n## 常用工作流\n\n### 安装所有依赖\n\n当你克隆一个带有 `package.json` 的项目时：\n\n```bash\ngit clone https://github.com/someone/project.git\ncd project\nhpm install\n```\n\n### 更新依赖\n\n将所有包更新到约束范围内的最新版本：\n\n```bash\nhpm update\n```\n\n更新特定的包：\n\n```bash\nhpm update hemlang/sprout\n```\n\n### 查看已安装的包\n\n列出所有已安装的包：\n\n```bash\nhpm list\n```\n\n输出显示依赖树：\n\n```\nmy-project@1.0.0\n├── hemlang/sprout@2.1.0\n│   └── hemlang/router@1.5.0\n└── hemlang/json@1.2.3\n```\n\n### 检查更新\n\n查看哪些包有更新版本：\n\n```bash\nhpm outdated\n```\n\n### 移除包\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n## 示例：Web 应用\n\n这是一个使用 Web 框架的完整示例：\n\n**package.json:**\n```json\n{\n  \"name\": \"myname/my-web-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A web application\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"dev\": \"hemlock --watch src/index.hml\"\n  }\n}\n```\n\n**src/index.hml:**\n```hemlock\nimport { App, Router } from \"hemlang/sprout\";\n\nfn main() {\n    let app = App.new();\n    let router = Router.new();\n\n    router.get(\"/\", fn(req, res) {\n        res.send(\"Hello, World!\");\n    });\n\n    router.get(\"/api/status\", fn(req, res) {\n        res.json({ status: \"ok\" });\n    });\n\n    app.use(router);\n    app.listen(3000);\n\n    print(\"Server running on http://localhost:3000\");\n}\n```\n\n运行应用：\n\n```bash\nhpm install\nhpm run start\n```\n\n## 后续步骤\n\n- [命令参考](#hpm-quick-start-commands) - 学习所有 hpm 命令\n- [创建包](#hpm-quick-start-creating-packages) - 发布你自己的包\n- [配置](#hpm-quick-start-configuration) - 配置 hpm 和 GitHub token\n- [项目设置](#hpm-quick-start-project-setup) - 详细的项目配置\n"}, "hpm: User Guide -> Commands": {"id": "hpm-commands", "content": "# 命令参考\n\n所有 hpm 命令的完整参考。\n\n## 全局选项\n\n这些选项适用于任何命令：\n\n| 选项 | 描述 |\n|--------|-------------|\n| `--help`, `-h` | 显示帮助信息 |\n| `--version`, `-v` | 显示 hpm 版本 |\n| `--verbose` | 显示详细输出 |\n\n## 命令\n\n### hpm init\n\n创建新的 `package.json` 文件。\n\n```bash\nhpm init        # 交互模式\nhpm init --yes  # 接受所有默认值\nhpm init -y     # 简写形式\n```\n\n**选项：**\n\n| 选项 | 描述 |\n|--------|-------------|\n| `--yes`, `-y` | 对所有提示接受默认值 |\n\n**交互提示：**\n- 包名称（owner/repo 格式）\n- 版本（默认：1.0.0）\n- 描述\n- 作者\n- 许可证（默认：MIT）\n- 主文件（默认：src/index.hml）\n\n**示例：**\n\n```bash\n$ hpm init\nPackage name (owner/repo): alice/my-lib\nVersion (1.0.0):\nDescription: A utility library\nAuthor: Alice <alice@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n---\n\n### hpm install\n\n安装依赖或添加新包。\n\n```bash\nhpm install                           # 从 package.json 安装所有依赖\nhpm install owner/repo                # 添加并安装包\nhpm install owner/repo@^1.0.0        # 使用版本约束\nhpm install owner/repo --dev         # 作为开发依赖\nhpm i owner/repo                      # 简写形式\n```\n\n**选项：**\n\n| 选项 | 描述 |\n|--------|-------------|\n| `--dev`, `-D` | 添加到 devDependencies |\n| `--verbose` | 显示详细进度 |\n| `--dry-run` | 预览而不安装 |\n| `--offline` | 仅从缓存安装（无网络） |\n| `--parallel` | 启用并行下载（实验性） |\n\n**版本约束语法：**\n\n| 语法 | 示例 | 含义 |\n|--------|---------|---------|\n| （无） | `owner/repo` | 最新版本 |\n| 精确 | `owner/repo@1.2.3` | 正好是 1.2.3 |\n| 插入符 | `owner/repo@^1.2.3` | >=1.2.3 <2.0.0 |\n| 波浪号 | `owner/repo@~1.2.3` | >=1.2.3 <1.3.0 |\n| 范围 | `owner/repo@>=1.0.0` | 至少 1.0.0 |\n\n**示例：**\n\n```bash\n# 安装所有依赖\nhpm install\n\n# 安装特定包\nhpm install hemlang/json\n\n# 使用版本约束安装\nhpm install hemlang/sprout@^2.0.0\n\n# 安装为开发依赖\nhpm install hemlang/test-utils --dev\n\n# 预览将要安装的内容\nhpm install hemlang/sprout --dry-run\n\n# 详细输出\nhpm install --verbose\n\n# 仅从缓存安装（离线）\nhpm install --offline\n```\n\n**输出：**\n\n```\nInstalling dependencies...\n  + hemlang/sprout@2.1.0\n  + hemlang/router@1.5.0 (dependency of hemlang/sprout)\n\nInstalled 2 packages in 1.2s\n```\n\n---\n\n### hpm uninstall\n\n移除一个包。\n\n```bash\nhpm uninstall owner/repo\nhpm rm owner/repo          # 简写形式\nhpm remove owner/repo      # 替代形式\n```\n\n**示例：**\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n**输出：**\n\n```\nRemoved hemlang/sprout@2.1.0\nUpdated package.json\nUpdated package-lock.json\n```\n\n---\n\n### hpm update\n\n将包更新到约束范围内的最新版本。\n\n```bash\nhpm update              # 更新所有包\nhpm update owner/repo   # 更新特定包\nhpm up owner/repo       # 简写形式\n```\n\n**选项：**\n\n| 选项 | 描述 |\n|--------|-------------|\n| `--verbose` | 显示详细进度 |\n| `--dry-run` | 预览而不更新 |\n\n**示例：**\n\n```bash\n# 更新所有包\nhpm update\n\n# 更新特定包\nhpm update hemlang/sprout\n\n# 预览更新\nhpm update --dry-run\n```\n\n**输出：**\n\n```\nUpdating dependencies...\n  hemlang/sprout: 2.0.0 → 2.1.0\n  hemlang/router: 1.4.0 → 1.5.0\n\nUpdated 2 packages\n```\n\n---\n\n### hpm list\n\n显示已安装的包。\n\n```bash\nhpm list              # 显示完整依赖树\nhpm list --depth=0    # 仅直接依赖\nhpm list --depth=1    # 一级传递依赖\nhpm ls                # 简写形式\n```\n\n**选项：**\n\n| 选项 | 描述 |\n|--------|-------------|\n| `--depth=N` | 限制树深度（默认：全部） |\n\n**示例：**\n\n```bash\n$ hpm list\nmy-project@1.0.0\n├── hemlang/sprout@2.1.0\n│   ├── hemlang/router@1.5.0\n│   └── hemlang/middleware@1.2.0\n├── hemlang/json@1.2.3\n└── hemlang/test-utils@1.0.0 (dev)\n\n$ hpm list --depth=0\nmy-project@1.0.0\n├── hemlang/sprout@2.1.0\n├── hemlang/json@1.2.3\n└── hemlang/test-utils@1.0.0 (dev)\n```\n\n---\n\n### hpm outdated\n\n显示有更新版本的包。\n\n```bash\nhpm outdated\n```\n\n**输出：**\n\n```\nPackage            Current  Wanted  Latest\nhemlang/sprout     2.0.0    2.0.5   2.1.0\nhemlang/router     1.4.0    1.4.2   1.5.0\n```\n\n- **Current**：已安装版本\n- **Wanted**：符合约束的最高版本\n- **Latest**：最新可用版本\n\n---\n\n### hpm run\n\n执行 package.json 中的脚本。\n\n```bash\nhpm run <script>\nhpm run <script> -- <args>\n```\n\n**示例：**\n\n给定以下 package.json：\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\n运行脚本：\n\n```bash\nhpm run start\nhpm run test\nhpm run build\n\n# 向脚本传递参数\nhpm run test -- --verbose\n```\n\n---\n\n### hpm test\n\n`hpm run test` 的简写。\n\n```bash\nhpm test\nhpm test -- --verbose\n```\n\n等同于：\n\n```bash\nhpm run test\n```\n\n---\n\n### hpm why\n\n解释为什么安装了某个包（显示依赖链）。\n\n```bash\nhpm why owner/repo\n```\n\n**示例：**\n\n```bash\n$ hpm why hemlang/router\n\nhemlang/router@1.5.0 is installed because:\n\nmy-project@1.0.0\n└── hemlang/sprout@2.1.0\n    └── hemlang/router@1.5.0\n```\n\n---\n\n### hpm cache\n\n管理全局包缓存。\n\n```bash\nhpm cache list    # 列出缓存的包\nhpm cache clean   # 清除所有缓存的包\n```\n\n**子命令：**\n\n| 子命令 | 描述 |\n|------------|-------------|\n| `list` | 显示所有缓存的包及大小 |\n| `clean` | 移除所有缓存的包 |\n\n**示例：**\n\n```bash\n$ hpm cache list\nCached packages in ~/.hpm/cache:\n\nhemlang/sprout\n  2.0.0 (1.2 MB)\n  2.1.0 (1.3 MB)\nhemlang/router\n  1.5.0 (450 KB)\n\nTotal: 2.95 MB\n\n$ hpm cache clean\nCleared cache (2.95 MB freed)\n```\n\n---\n\n## 命令快捷方式\n\n为方便起见，多个命令有简短别名：\n\n| 命令 | 快捷方式 |\n|---------|-----------|\n| `install` | `i` |\n| `uninstall` | `rm`, `remove` |\n| `list` | `ls` |\n| `update` | `up` |\n\n**示例：**\n\n```bash\nhpm i hemlang/sprout        # hpm install hemlang/sprout\nhpm rm hemlang/sprout       # hpm uninstall hemlang/sprout\nhpm ls                      # hpm list\nhpm up                      # hpm update\n```\n\n---\n\n## 退出码\n\nhpm 使用特定的退出码来指示不同的错误条件：\n\n| 代码 | 含义 |\n|------|---------|\n| 0 | 成功 |\n| 1 | 依赖冲突 |\n| 2 | 包未找到 |\n| 3 | 版本未找到 |\n| 4 | 网络错误 |\n| 5 | 无效的 package.json |\n| 6 | 完整性检查失败 |\n| 7 | 超出 GitHub 速率限制 |\n| 8 | 循环依赖 |\n\n在脚本中使用退出码：\n\n```bash\nhpm install\nif [ $? -ne 0 ]; then\n    echo \"Installation failed\"\n    exit 1\nfi\n```\n\n---\n\n## 环境变量\n\nhpm 支持以下环境变量：\n\n| 变量 | 描述 |\n|----------|-------------|\n| `GITHUB_TOKEN` | GitHub API token 用于认证 |\n| `HPM_CACHE_DIR` | 覆盖缓存目录位置 |\n| `HOME` | 用户主目录（用于配置/缓存） |\n\n**示例：**\n\n```bash\n# 使用 GitHub token 获得更高的速率限制\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# 使用自定义缓存目录\nexport HPM_CACHE_DIR=/tmp/hpm-cache\nhpm install\n```\n\n---\n\n## 另请参阅\n\n- [配置](#hpm-commands-configuration) - 配置文件\n- [包规范](#hpm-commands-package-spec) - package.json 格式\n- [故障排除](#hpm-commands-troubleshooting) - 常见问题\n"}, "hpm: User Guide -> Configuration": {"id": "hpm-configuration", "content": "# 配置\n\n本指南涵盖 hpm 的所有配置选项。\n\n## 概述\n\nhpm 可以通过以下方式配置：\n\n1. **环境变量** - 用于运行时设置\n2. **全局配置文件** - `~/.hpm/config.json`\n3. **项目文件** - `package.json` 和 `package-lock.json`\n\n## 环境变量\n\n### GITHUB_TOKEN\n\n用于认证的 GitHub API token。\n\n```bash\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n```\n\n**认证的好处：**\n- 更高的 API 速率限制（5000 vs 60 请求/小时）\n- 访问私有仓库\n- 更快的依赖解析\n\n**创建 token：**\n\n1. 前往 GitHub → Settings → Developer settings → Personal access tokens\n2. 点击 \"Generate new token (classic)\"\n3. 选择权限范围：\n   - `repo` - 用于私有仓库访问\n   - `read:packages` - 用于 GitHub Packages（如果使用）\n4. 生成并复制 token\n\n### HPM_CACHE_DIR\n\n覆盖默认缓存目录。\n\n```bash\nexport HPM_CACHE_DIR=/custom/cache/path\n```\n\n默认值：`~/.hpm/cache`\n\n**使用场景：**\n- 具有自定义缓存位置的 CI/CD 系统\n- 跨项目共享缓存\n- 隔离构建的临时缓存\n\n### HOME\n\n用户主目录。用于定位：\n- 配置目录：`$HOME/.hpm/`\n- 缓存目录：`$HOME/.hpm/cache/`\n\n通常由系统设置；仅在需要时覆盖。\n\n### .bashrc / .zshrc 示例\n\n```bash\n# GitHub authentication (recommended)\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n\n# Custom cache location (optional)\n# export HPM_CACHE_DIR=/path/to/cache\n\n# Add hpm to PATH (if using custom install location)\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## 全局配置文件\n\n### 位置\n\n`~/.hpm/config.json`\n\n### 格式\n\n```json\n{\n  \"github_token\": \"ghp_xxxxxxxxxxxxxxxxxxxx\"\n}\n```\n\n### 创建配置文件\n\n```bash\n# Create config directory\nmkdir -p ~/.hpm\n\n# Create config file\ncat > ~/.hpm/config.json << 'EOF'\n{\n  \"github_token\": \"ghp_your_token_here\"\n}\nEOF\n\n# Secure the file (recommended)\nchmod 600 ~/.hpm/config.json\n```\n\n### Token 优先级\n\n如果两者都设置，环境变量优先：\n\n1. `GITHUB_TOKEN` 环境变量（最高）\n2. `~/.hpm/config.json` 的 `github_token` 字段\n3. 无认证（默认）\n\n## 目录结构\n\n### 全局目录\n\n```\n~/.hpm/\n├── config.json          # 全局配置\n└── cache/               # 包缓存\n    └── owner/\n        └── repo/\n            └── 1.0.0.tar.gz\n```\n\n### 项目目录\n\n```\nmy-project/\n├── package.json         # 项目清单\n├── package-lock.json    # 依赖锁定文件\n├── hem_modules/         # 已安装的包\n│   └── owner/\n│       └── repo/\n│           ├── package.json\n│           └── src/\n├── src/                 # 源代码\n└── test/                # 测试\n```\n\n## 包缓存\n\n### 位置\n\n默认：`~/.hpm/cache/`\n\n使用 `HPM_CACHE_DIR` 环境变量覆盖\n\n### 结构\n\n```\n~/.hpm/cache/\n├── hemlang/\n│   ├── sprout/\n│   │   ├── 2.0.0.tar.gz\n│   │   └── 2.1.0.tar.gz\n│   └── router/\n│       └── 1.5.0.tar.gz\n└── alice/\n    └── http-client/\n        └── 1.0.0.tar.gz\n```\n\n### 管理缓存\n\n```bash\n# 查看缓存的包\nhpm cache list\n\n# 清除整个缓存\nhpm cache clean\n```\n\n### 缓存行为\n\n- 包在首次下载后被缓存\n- 后续安装使用缓存版本\n- 使用 `--offline` 仅从缓存安装\n- 缓存在所有项目间共享\n\n## GitHub API 速率限制\n\n### 无认证\n\n- **每小时 60 个请求**，按 IP 地址计算\n- 在同一 IP 上的所有未认证用户间共享\n- 在 CI/CD 或有多个依赖时会很快耗尽\n\n### 有认证\n\n- **每小时 5000 个请求**，按认证用户计算\n- 个人速率限制，不共享\n\n### 处理速率限制\n\nhpm 自动：\n- 使用指数退避重试（1秒、2秒、4秒、8秒）\n- 以退出码 7 报告速率限制错误\n- 如果被速率限制则建议认证\n\n**速率限制时的解决方案：**\n\n```bash\n# 选项 1：使用 GitHub token 认证\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# 选项 2：等待速率限制重置\n# （限制每小时重置）\n\n# 选项 3：使用离线模式（如果包已缓存）\nhpm install --offline\n```\n\n## 离线模式\n\n无网络访问时安装包：\n\n```bash\nhpm install --offline\n```\n\n**要求：**\n- 所有包必须在缓存中\n- 锁定文件必须存在且有精确版本\n\n**使用场景：**\n- 隔离网络的环境\n- 更快的 CI/CD 构建（有热缓存）\n- 避免速率限制\n\n## CI/CD 配置\n\n### GitHub Actions\n\n```yaml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Setup Hemlock\n      run: |\n        # Install Hemlock (adjust based on your setup)\n        curl -sSL https://hemlock.dev/install.sh | sh\n\n    - name: Cache hpm packages\n      uses: actions/cache@v3\n      with:\n        path: ~/.hpm/cache\n        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}\n        restore-keys: |\n          ${{ runner.os }}-hpm-\n\n    - name: Install dependencies\n      run: hpm install\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Run tests\n      run: hpm test\n```\n\n### GitLab CI\n\n```yaml\nstages:\n  - build\n  - test\n\nvariables:\n  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache\n\ncache:\n  paths:\n    - .hpm-cache/\n  key: $CI_COMMIT_REF_SLUG\n\nbuild:\n  stage: build\n  script:\n    - hpm install\n  artifacts:\n    paths:\n      - hem_modules/\n\ntest:\n  stage: test\n  script:\n    - hpm test\n```\n\n### Docker\n\n**Dockerfile:**\n\n```dockerfile\nFROM hemlock:latest\n\nWORKDIR /app\n\n# Copy package files first (for layer caching)\nCOPY package.json package-lock.json ./\n\n# Install dependencies\nRUN hpm install\n\n# Copy source code\nCOPY . .\n\n# Run application\nCMD [\"hemlock\", \"src/main.hml\"]\n```\n\n**docker-compose.yml:**\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    environment:\n      - GITHUB_TOKEN=${GITHUB_TOKEN}\n    volumes:\n      - hpm-cache:/root/.hpm/cache\n\nvolumes:\n  hpm-cache:\n```\n\n## 代理配置\n\n对于代理后面的环境，在系统级别配置：\n\n```bash\nexport HTTP_PROXY=http://proxy.example.com:8080\nexport HTTPS_PROXY=http://proxy.example.com:8080\nexport NO_PROXY=localhost,127.0.0.1\n\nhpm install\n```\n\n## 安全最佳实践\n\n### Token 安全\n\n1. **永远不要提交 token** 到版本控制\n2. **在 CI/CD 中使用环境变量**\n3. **将 token 权限范围限制**到最小需要\n4. **定期轮换 token**\n5. **保护配置文件**：\n   ```bash\n   chmod 600 ~/.hpm/config.json\n   ```\n\n### 私有仓库\n\n要访问私有包：\n\n1. 创建具有 `repo` 权限范围的 token\n2. 配置认证（环境变量或配置文件）\n3. 确保 token 有仓库访问权限\n\n```bash\n# 测试访问\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install yourorg/private-package\n```\n\n## 配置故障排除\n\n### 验证配置\n\n```bash\n# 检查 token 是否设置\necho $GITHUB_TOKEN | head -c 10\n\n# 检查配置文件\ncat ~/.hpm/config.json\n\n# 检查缓存目录\nls -la ~/.hpm/cache/\n\n# 使用详细输出测试\nhpm install --verbose\n```\n\n### 常见问题\n\n**\"GitHub rate limit exceeded\"**\n- 使用 `GITHUB_TOKEN` 设置认证\n- 等待速率限制重置\n- 如果包已缓存，使用 `--offline`\n\n**缓存上的 \"Permission denied\"**\n```bash\n# 修复缓存权限\nchmod -R u+rw ~/.hpm/cache\n```\n\n**\"Config file not found\"**\n```bash\n# 创建配置目录\nmkdir -p ~/.hpm\ntouch ~/.hpm/config.json\n```\n\n## 另请参阅\n\n- [安装](#hpm-configuration-installation) - 安装 hpm\n- [故障排除](#hpm-configuration-troubleshooting) - 常见问题\n- [命令](#hpm-configuration-commands) - 命令参考\n"}, "hpm: User Guide -> Troubleshooting": {"id": "hpm-troubleshooting", "content": "# 故障排除\n\n常见 hpm 问题的解决方案。\n\n## 安装问题\n\n### \"hemlock: command not found\"\n\n**原因：** Hemlock 未安装或不在 PATH 中。\n\n**解决方案：**\n\n```bash\n# 检查 hemlock 是否存在\nwhich hemlock\n\n# 如果未找到，请先安装 Hemlock\n# 访问：https://github.com/hemlang/hemlock\n\n# 安装后，验证\nhemlock --version\n```\n\n### \"hpm: command not found\"\n\n**原因：** hpm 未安装或不在 PATH 中。\n\n**解决方案：**\n\n```bash\n# 检查 hpm 安装位置\nls -la /usr/local/bin/hpm\nls -la ~/.local/bin/hpm\n\n# 如果使用自定义位置，添加到 PATH\nexport PATH=\"$HOME/.local/bin:$PATH\"\n\n# 添加到 ~/.bashrc 或 ~/.zshrc 以持久化\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc\nsource ~/.bashrc\n\n# 如需要重新安装\ncd /path/to/hpm\nsudo make install\n```\n\n### 安装时 \"Permission denied\"\n\n**原因：** 对安装目录没有写权限。\n\n**解决方案：**\n\n```bash\n# 选项 1：使用 sudo 进行系统范围安装\nsudo make install\n\n# 选项 2：安装到用户目录（无需 sudo）\nmake install PREFIX=$HOME/.local\n```\n\n## 依赖问题\n\n### \"Package not found\"（退出码 2）\n\n**原因：** 包在 GitHub 上不存在。\n\n**解决方案：**\n\n```bash\n# 验证包是否存在\n# 检查：https://github.com/owner/repo\n\n# 验证拼写\nhpm install hemlang/sprout  # 正确\nhpm install hemlan/sprout   # 错误的 owner\nhpm install hemlang/spout   # 错误的 repo\n\n# 检查 package.json 中的拼写错误\ncat package.json | grep -A 5 dependencies\n```\n\n### \"Version not found\"（退出码 3）\n\n**原因：** 没有发布版本匹配版本约束。\n\n**解决方案：**\n\n```bash\n# 列出可用版本（检查 GitHub releases/tags）\n# 标签必须以 'v' 开头（例如 v1.0.0）\n\n# 使用有效的版本约束\nhpm install owner/repo@^1.0.0\n\n# 尝试最新版本\nhpm install owner/repo\n\n# 在 GitHub 上检查可用标签\n# https://github.com/owner/repo/tags\n```\n\n### \"Dependency conflict\"（退出码 1）\n\n**原因：** 两个包需要不兼容版本的依赖。\n\n**解决方案：**\n\n```bash\n# 查看冲突\nhpm install --verbose\n\n# 检查什么需要该依赖\nhpm why conflicting/package\n\n# 解决方案：\n# 1. 更新冲突的包\nhpm update problem/package\n\n# 2. 更改 package.json 中的版本约束\n# 编辑以允许兼容的版本\n\n# 3. 移除冲突的包之一\nhpm uninstall one/package\n```\n\n### \"Circular dependency\"（退出码 8）\n\n**原因：** 包 A 依赖 B，B 又依赖 A。\n\n**解决方案：**\n\n```bash\n# 识别循环\nhpm install --verbose\n\n# 这通常是包中的 bug\n# 联系包维护者\n\n# 变通方法：避免使用其中一个包\n```\n\n## 网络问题\n\n### \"Network error\"（退出码 4）\n\n**原因：** 无法连接到 GitHub API。\n\n**解决方案：**\n\n```bash\n# 检查网络连接\nping github.com\n\n# 检查 GitHub API 是否可访问\ncurl -I https://api.github.com\n\n# 重试（hpm 会自动重试）\nhpm install\n\n# 如果包已缓存，使用离线模式\nhpm install --offline\n\n# 如果在防火墙后面，检查代理设置\nexport HTTPS_PROXY=http://proxy:8080\nhpm install\n```\n\n### \"GitHub rate limit exceeded\"（退出码 7）\n\n**原因：** 未认证时 API 请求过多。\n\n**解决方案：**\n\n```bash\n# 选项 1：使用 GitHub token 认证（推荐）\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# 创建 token：GitHub → Settings → Developer settings → Personal access tokens\n\n# 选项 2：将 token 保存在配置文件中\nmkdir -p ~/.hpm\necho '{\"github_token\": \"ghp_xxxxxxxxxxxx\"}' > ~/.hpm/config.json\n\n# 选项 3：等待速率限制重置（每小时重置）\n\n# 选项 4：使用离线模式\nhpm install --offline\n```\n\n### 连接超时\n\n**原因：** 网络慢或 GitHub API 问题。\n\n**解决方案：**\n\n```bash\n# hpm 会自动使用指数退避重试\n\n# 检查 GitHub 是否有问题\n# 访问：https://www.githubstatus.com\n\n# 稍后重试\nhpm install\n\n# 使用缓存的包\nhpm install --offline\n```\n\n## Package.json 问题\n\n### \"Invalid package.json\"（退出码 5）\n\n**原因：** 格式错误或缺少必需字段。\n\n**解决方案：**\n\n```bash\n# 验证 JSON 语法\ncat package.json | python -m json.tool\n\n# 检查必需字段\ncat package.json\n\n# 必需字段：\n# - \"name\"：owner/repo 格式\n# - \"version\"：X.Y.Z 格式\n\n# 如需要重新生成\nrm package.json\nhpm init\n```\n\n### \"name\" 格式错误\n\n**原因：** 包名称不是 `owner/repo` 格式。\n\n**解决方案：**\n\n```json\n// 错误\n{\n  \"name\": \"my-package\"\n}\n\n// 正确\n{\n  \"name\": \"yourusername/my-package\"\n}\n```\n\n### \"version\" 格式错误\n\n**原因：** 版本不是 semver 格式。\n\n**解决方案：**\n\n```json\n// 错误\n{\n  \"version\": \"1.0\"\n}\n\n// 正确\n{\n  \"version\": \"1.0.0\"\n}\n```\n\n## 锁定文件问题\n\n### 锁定文件不同步\n\n**原因：** package.json 修改后未运行 install。\n\n**解决方案：**\n\n```bash\n# 重新生成锁定文件\nrm package-lock.json\nhpm install\n```\n\n### 锁定文件损坏\n\n**原因：** 无效的 JSON 或手动编辑。\n\n**解决方案：**\n\n```bash\n# 检查 JSON 有效性\ncat package-lock.json | python -m json.tool\n\n# 重新生成\nrm package-lock.json\nhpm install\n```\n\n## hem_modules 问题\n\n### 包未安装\n\n**原因：** 各种可能的问题。\n\n**解决方案：**\n\n```bash\n# 清理并重新安装\nrm -rf hem_modules\nhpm install\n\n# 检查详细输出\nhpm install --verbose\n```\n\n### Import 不工作\n\n**原因：** 包未正确安装或导入路径错误。\n\n**解决方案：**\n\n```bash\n# 验证包已安装\nls hem_modules/owner/repo/\n\n# 检查 package.json 的 main 字段\ncat hem_modules/owner/repo/package.json\n\n# 正确的导入格式\nimport { x } from \"owner/repo\";          # 使用 main 入口\nimport { y } from \"owner/repo/subpath\";  # 子路径导入\n```\n\n### \"Module not found\" 错误\n\n**原因：** 导入路径未解析到文件。\n\n**解决方案：**\n\n```bash\n# 检查导入路径\nls hem_modules/owner/repo/src/\n\n# 检查 index.hml\nls hem_modules/owner/repo/src/index.hml\n\n# 验证 package.json 中的 main 字段\ncat hem_modules/owner/repo/package.json | grep main\n```\n\n## 缓存问题\n\n### 缓存占用太多空间\n\n**解决方案：**\n\n```bash\n# 查看缓存大小\nhpm cache list\n\n# 清除缓存\nhpm cache clean\n```\n\n### 缓存权限\n\n**解决方案：**\n\n```bash\n# 修复权限\nchmod -R u+rw ~/.hpm/cache\n\n# 或移除并重新安装\nrm -rf ~/.hpm/cache\nhpm install\n```\n\n### 使用错误的缓存\n\n**解决方案：**\n\n```bash\n# 检查缓存位置\necho $HPM_CACHE_DIR\nls ~/.hpm/cache\n\n# 如果不正确，清除环境变量\nunset HPM_CACHE_DIR\n```\n\n## 脚本问题\n\n### \"Script not found\"\n\n**原因：** 脚本名称在 package.json 中不存在。\n\n**解决方案：**\n\n```bash\n# 列出可用脚本\ncat package.json | grep -A 20 scripts\n\n# 检查拼写\nhpm run test    # 正确\nhpm run tests   # 如果脚本名为 \"test\" 则错误\n```\n\n### 脚本失败\n\n**原因：** 脚本命令中有错误。\n\n**解决方案：**\n\n```bash\n# 直接运行命令以查看错误\nhemlock test/run.hml\n\n# 检查脚本定义\ncat package.json | grep test\n```\n\n## 调试\n\n### 启用详细输出\n\n```bash\nhpm install --verbose\n```\n\n### 检查 hpm 版本\n\n```bash\nhpm --version\n```\n\n### 检查 hemlock 版本\n\n```bash\nhemlock --version\n```\n\n### 干运行\n\n预览而不进行更改：\n\n```bash\nhpm install --dry-run\n```\n\n### 从头开始\n\n重新开始：\n\n```bash\nrm -rf hem_modules package-lock.json\nhpm install\n```\n\n## 获取帮助\n\n### 命令帮助\n\n```bash\nhpm --help\nhpm install --help\n```\n\n### 报告问题\n\n如果遇到 bug：\n\n1. 检查现有问题：https://github.com/hemlang/hpm/issues\n2. 创建新问题，包含：\n   - hpm 版本（`hpm --version`）\n   - Hemlock 版本（`hemlock --version`）\n   - 操作系统\n   - 重现步骤\n   - 错误消息（使用 `--verbose`）\n\n## 退出码参考\n\n| 代码 | 含义 | 常见解决方案 |\n|------|---------|-----------------|\n| 0 | 成功 | - |\n| 1 | 依赖冲突 | 更新或更改约束 |\n| 2 | 包未找到 | 检查拼写，验证仓库存在 |\n| 3 | 版本未找到 | 在 GitHub 上检查可用版本 |\n| 4 | 网络错误 | 检查连接，重试 |\n| 5 | 无效的 package.json | 修复 JSON 语法和必需字段 |\n| 6 | 完整性检查失败 | 清除缓存，重新安装 |\n| 7 | GitHub 速率限制 | 添加 GITHUB_TOKEN |\n| 8 | 循环依赖 | 联系包维护者 |\n\n## 另请参阅\n\n- [安装](#hpm-troubleshooting-installation) - 安装指南\n- [配置](#hpm-troubleshooting-configuration) - 配置选项\n- [命令](#hpm-troubleshooting-commands) - 命令参考\n"}, "hpm: Package Development -> Creating Packages": {"id": "hpm-creating-packages", "content": "# 创建包\n\n本指南介绍如何创建、组织和发布 Hemlock 包。\n\n## 概述\n\nhpm 使用 GitHub 作为其包注册表。包通过其 GitHub `owner/repo` 路径标识，版本是 Git 标签。发布只需推送带标签的发布版本。\n\n## 创建新包\n\n### 1. 初始化包\n\n创建新目录并初始化：\n\n```bash\nmkdir my-package\ncd my-package\nhpm init\n```\n\n回答提示：\n\n```\nPackage name (owner/repo): yourusername/my-package\nVersion (1.0.0):\nDescription: A useful Hemlock package\nAuthor: Your Name <you@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n### 2. 创建项目结构\n\n包的推荐结构：\n\n```\nmy-package/\n├── package.json          # 包清单\n├── README.md             # 文档\n├── LICENSE               # 许可证文件\n├── src/\n│   ├── index.hml         # 主入口点（导出公共 API）\n│   ├── utils.hml         # 内部工具\n│   └── types.hml         # 类型定义\n└── test/\n    ├── framework.hml     # 测试框架\n    └── test_utils.hml    # 测试\n```\n\n### 3. 定义你的公共 API\n\n**src/index.hml** - 主入口点：\n\n```hemlock\n// Re-export public API\nexport { parse, stringify } from \"./parser.hml\";\nexport { Config, Options } from \"./types.hml\";\nexport { process } from \"./processor.hml\";\n\n// Direct exports\nexport fn create(options: Options): Config {\n    // Implementation\n}\n\nexport fn validate(config: Config): bool {\n    // Implementation\n}\n```\n\n### 4. 编写你的 package.json\n\n完整的 package.json 示例：\n\n```json\n{\n  \"name\": \"yourusername/my-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A useful Hemlock package\",\n  \"author\": \"Your Name <you@example.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/yourusername/my-package\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/bundle.hmlc\"\n  },\n  \"keywords\": [\"utility\", \"parser\", \"config\"],\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n## 包命名\n\n### 要求\n\n- 必须是 `owner/repo` 格式\n- `owner` 应该是你的 GitHub 用户名或组织\n- `repo` 应该是仓库名称\n- 多词名称使用小写字母和连字符\n\n### 好的名称\n\n```\nhemlang/sprout\nalice/http-client\nmyorg/json-utils\nbob/date-formatter\n```\n\n### 避免\n\n```\nmy-package          # 缺少 owner\nalice/MyPackage     # PascalCase\nalice/my_package    # 下划线\n```\n\n## 包结构最佳实践\n\n### 入口点\n\npackage.json 中的 `main` 字段指定入口点：\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\n此文件应导出你的公共 API：\n\n```hemlock\n// Export everything users need\nexport { Parser, parse } from \"./parser.hml\";\nexport { Formatter, format } from \"./formatter.hml\";\n\n// Types\nexport type { Config, Options } from \"./types.hml\";\n```\n\n### 内部与公共\n\n保持内部实现细节私有：\n\n```\nsrc/\n├── index.hml          # 公共：导出的 API\n├── parser.hml         # 公共：被 index.hml 使用\n├── formatter.hml      # 公共：被 index.hml 使用\n└── internal/\n    ├── helpers.hml    # 私有：仅供内部使用\n    └── constants.hml  # 私有：仅供内部使用\n```\n\n用户从你的包根目录导入：\n\n```hemlock\n// Good - imports from public API\nimport { parse, Parser } from \"yourusername/my-package\";\n\n// Also works - subpath import\nimport { validate } from \"yourusername/my-package/validator\";\n\n// Discouraged - accessing internals\nimport { helper } from \"yourusername/my-package/internal/helpers\";\n```\n\n### 子路径导出\n\n支持从子路径导入：\n\n```\nsrc/\n├── index.hml              # 主入口\n├── parser/\n│   └── index.hml          # yourusername/pkg/parser\n├── formatter/\n│   └── index.hml          # yourusername/pkg/formatter\n└── utils/\n    └── index.hml          # yourusername/pkg/utils\n```\n\n用户可以导入：\n\n```hemlock\nimport { parse } from \"yourusername/my-package\";           // Main\nimport { Parser } from \"yourusername/my-package/parser\";   // Subpath\nimport { format } from \"yourusername/my-package/formatter\";\n```\n\n## 依赖\n\n### 添加依赖\n\n```bash\n# 运行时依赖\nhpm install hemlang/json\n\n# 开发依赖\nhpm install hemlang/test-utils --dev\n```\n\n### 依赖最佳实践\n\n1. **大多数依赖使用插入符范围**：\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     }\n   }\n   ```\n\n2. **仅在必要时锁定版本**（API 不稳定）：\n   ```json\n   {\n     \"dependencies\": {\n       \"unstable/lib\": \"1.2.3\"\n     }\n   }\n   ```\n\n3. **避免过于严格的范围**：\n   ```json\n   // Bad: too restrictive\n   \"hemlang/json\": \">=1.2.3 <1.2.5\"\n\n   // Good: allows compatible updates\n   \"hemlang/json\": \"^1.2.3\"\n   ```\n\n4. **分离开发依赖**：\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     },\n     \"devDependencies\": {\n       \"hemlang/test-utils\": \"^1.0.0\"\n     }\n   }\n   ```\n\n## 测试你的包\n\n### 编写测试\n\n**test/run.hml:**\n\n```hemlock\nimport { suite, test, assert_eq } from \"./framework.hml\";\nimport { parse, stringify } from \"../src/index.hml\";\n\nfn run_tests() {\n    suite(\"Parser\", fn() {\n        test(\"parses valid input\", fn() {\n            let result = parse(\"hello\");\n            assert_eq(result.value, \"hello\");\n        });\n\n        test(\"handles empty input\", fn() {\n            let result = parse(\"\");\n            assert_eq(result.value, \"\");\n        });\n    });\n\n    suite(\"Stringify\", fn() {\n        test(\"stringifies object\", fn() {\n            let obj = { name: \"test\" };\n            let result = stringify(obj);\n            assert_eq(result, '{\"name\":\"test\"}');\n        });\n    });\n}\n\nrun_tests();\n```\n\n### 运行测试\n\n添加测试脚本：\n\n```json\n{\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\n运行：\n\n```bash\nhpm test\n```\n\n## 发布\n\n### 前提条件\n\n1. 创建与你的包名称匹配的 GitHub 仓库\n2. 确保 `package.json` 完整有效\n3. 所有测试通过\n\n### 发布流程\n\n发布只需推送 Git 标签：\n\n```bash\n# 1. 确保所有内容已提交\ngit add .\ngit commit -m \"Prepare v1.0.0 release\"\n\n# 2. 创建版本标签（必须以 'v' 开头）\ngit tag v1.0.0\n\n# 3. 推送代码和标签\ngit push origin main\ngit push origin v1.0.0\n# 或一次推送所有标签\ngit push origin main --tags\n```\n\n### 版本标签\n\n标签必须遵循 `vX.Y.Z` 格式：\n\n```bash\ngit tag v1.0.0      # 发布版\ngit tag v1.0.1      # 补丁\ngit tag v1.1.0      # 次要版本\ngit tag v2.0.0      # 主要版本\ngit tag v1.0.0-beta.1  # 预发布\n```\n\n### 发布清单\n\n发布新版本之前：\n\n1. **更新** package.json 中的版本\n2. **运行测试**：`hpm test`\n3. **更新 CHANGELOG**（如果有的话）\n4. **更新 README**（如果 API 改变了）\n5. **提交更改**\n6. **创建标签**\n7. **推送到 GitHub**\n\n### 自动化示例\n\n创建发布脚本：\n\n```bash\n#!/bin/bash\n# release.sh - Release a new version\n\nVERSION=$1\n\nif [ -z \"$VERSION\" ]; then\n    echo \"Usage: ./release.sh 1.0.0\"\n    exit 1\nfi\n\n# Run tests\nhpm test || exit 1\n\n# Update version in package.json\nsed -i \"s/\\\"version\\\": \\\".*\\\"/\\\"version\\\": \\\"$VERSION\\\"/\" package.json\n\n# Commit and tag\ngit add package.json\ngit commit -m \"Release v$VERSION\"\ngit tag \"v$VERSION\"\n\n# Push\ngit push origin main --tags\n\necho \"Released v$VERSION\"\n```\n\n## 用户安装你的包\n\n发布后，用户可以安装：\n\n```bash\n# 最新版本\nhpm install yourusername/my-package\n\n# 特定版本\nhpm install yourusername/my-package@1.0.0\n\n# 版本约束\nhpm install yourusername/my-package@^1.0.0\n```\n\n并导入：\n\n```hemlock\nimport { parse, stringify } from \"yourusername/my-package\";\n```\n\n## 文档\n\n### README.md\n\n每个包都应该有 README：\n\n```markdown\n# my-package\n\nA brief description of what this package does.\n\n## Installation\n\n\\`\\`\\`bash\nhpm install yourusername/my-package\n\\`\\`\\`\n\n## Usage\n\n\\`\\`\\`hemlock\nimport { parse } from \"yourusername/my-package\";\n\nlet result = parse(\"input\");\n\\`\\`\\`\n\n## API\n\n### parse(input: string): Result\n\nParses the input string.\n\n### stringify(obj: any): string\n\nConverts object to string.\n\n## License\n\nMIT\n```\n\n### API 文档\n\n记录所有公共导出：\n\n```hemlock\n/// Parses the input string into a structured Result.\n///\n/// # Arguments\n/// * `input` - The string to parse\n///\n/// # Returns\n/// A Result containing the parsed data or an error\n///\n/// # Example\n/// ```\n/// let result = parse(\"hello world\");\n/// print(result.value);\n/// ```\nexport fn parse(input: string): Result {\n    // Implementation\n}\n```\n\n## 版本指南\n\n遵循[语义化版本](https://semver.org/)：\n\n- **MAJOR**（1.0.0 → 2.0.0）：破坏性更改\n- **MINOR**（1.0.0 → 1.1.0）：新功能，向后兼容\n- **PATCH**（1.0.0 → 1.0.1）：错误修复，向后兼容\n\n### 何时递增\n\n| 更改类型 | 版本递增 |\n|-------------|--------------|\n| 破坏性 API 更改 | MAJOR |\n| 移除函数/类型 | MAJOR |\n| 更改函数签名 | MAJOR |\n| 添加新函数 | MINOR |\n| 添加新功能 | MINOR |\n| 错误修复 | PATCH |\n| 文档更新 | PATCH |\n| 内部重构 | PATCH |\n\n## 另请参阅\n\n- [包规范](#hpm-creating-packages-package-spec) - 完整的 package.json 参考\n- [版本控制](#hpm-creating-packages-versioning) - 语义化版本详情\n- [配置](#hpm-creating-packages-configuration) - GitHub 认证\n"}, "hpm: Package Development -> Package Spec": {"id": "hpm-package-spec", "content": "# 包规范\n\n`package.json` 文件格式的完整参考。\n\n## 概述\n\n每个 hpm 包都需要在项目根目录中有一个 `package.json` 文件。此文件定义包元数据、依赖项和脚本。\n\n## 最小示例\n\n```json\n{\n  \"name\": \"owner/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n## 完整示例\n\n```json\n{\n  \"name\": \"hemlang/example-package\",\n  \"version\": \"1.2.3\",\n  \"description\": \"An example Hemlock package\",\n  \"author\": \"Hemlock Team <team@hemlock.dev>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/hemlang/example-package\",\n  \"homepage\": \"https://hemlang.github.io/example-package\",\n  \"bugs\": \"https://github.com/hemlang/example-package/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"example\", \"utility\", \"hemlock\"],\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"^2.1.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/bundle.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n## 字段参考\n\n### name（必需）\n\n`owner/repo` 格式的包名称。\n\n```json\n{\n  \"name\": \"hemlang/sprout\"\n}\n```\n\n**要求：**\n- 必须是 `owner/repo` 格式\n- `owner` 应该是你的 GitHub 用户名或组织\n- `repo` 应该是仓库名称\n- 使用小写字母、数字和连字符\n- 总共最多 214 个字符\n\n**有效名称：**\n```\nhemlang/sprout\nalice/http-client\nmyorg/json-utils\nbob123/my-lib\n```\n\n**无效名称：**\n```\nmy-package          # 缺少 owner\nhemlang/My_Package  # 大写和下划线\nhemlang             # 缺少 repo\n```\n\n### version（必需）\n\n遵循[语义化版本](https://semver.org/)的包版本。\n\n```json\n{\n  \"version\": \"1.2.3\"\n}\n```\n\n**格式：** `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`\n\n**有效版本：**\n```\n1.0.0\n2.1.3\n1.0.0-alpha\n1.0.0-beta.1\n1.0.0-rc.1+build.123\n0.1.0\n```\n\n### description\n\n包的简短描述。\n\n```json\n{\n  \"description\": \"A fast JSON parser for Hemlock\"\n}\n```\n\n- 保持在 200 个字符以内\n- 描述包做什么，而不是怎么做\n\n### author\n\n包作者信息。\n\n```json\n{\n  \"author\": \"Your Name <email@example.com>\"\n}\n```\n\n**接受的格式：**\n```json\n\"author\": \"Your Name\"\n\"author\": \"Your Name <email@example.com>\"\n\"author\": \"Your Name <email@example.com> (https://website.com)\"\n```\n\n### license\n\n许可证标识符。\n\n```json\n{\n  \"license\": \"MIT\"\n}\n```\n\n**常见许可证：**\n- `MIT` - MIT 许可证\n- `Apache-2.0` - Apache 许可证 2.0\n- `GPL-3.0` - GNU 通用公共许可证 v3.0\n- `BSD-3-Clause` - BSD 3-Clause 许可证\n- `ISC` - ISC 许可证\n- `UNLICENSED` - 专有/私有\n\n尽可能使用 [SPDX 标识符](https://spdx.org/licenses/)。\n\n### repository\n\n源仓库链接。\n\n```json\n{\n  \"repository\": \"https://github.com/hemlang/sprout\"\n}\n```\n\n### homepage\n\n项目主页 URL。\n\n```json\n{\n  \"homepage\": \"https://sprout.hemlock.dev\"\n}\n```\n\n### bugs\n\n问题跟踪器 URL。\n\n```json\n{\n  \"bugs\": \"https://github.com/hemlang/sprout/issues\"\n}\n```\n\n### main\n\n包的入口点文件。\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\n**默认值：** `src/index.hml`\n\n当用户导入你的包时：\n```hemlock\nimport { x } from \"owner/repo\";\n```\n\nhpm 加载 `main` 中指定的文件。\n\n**导入的解析顺序：**\n1. 精确路径：`src/index.hml`\n2. 带 .hml 扩展名：`src/index` → `src/index.hml`\n3. 索引文件：`src/index/` → `src/index/index.hml`\n\n### keywords\n\n用于可发现性的关键词数组。\n\n```json\n{\n  \"keywords\": [\"json\", \"parser\", \"utility\", \"hemlock\"]\n}\n```\n\n- 使用小写\n- 具体且相关\n- 如果适当，包含语言（\"hemlock\"）\n\n### dependencies\n\n包工作所需的运行时依赖。\n\n```json\n{\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"~2.1.0\",\n    \"alice/logger\": \">=1.0.0 <2.0.0\"\n  }\n}\n```\n\n**键：** 包名称（`owner/repo`）\n**值：** 版本约束\n\n**版本约束语法：**\n\n| 约束 | 含义 |\n|------------|---------|\n| `1.2.3` | 精确版本 |\n| `^1.2.3` | >=1.2.3 <2.0.0 |\n| `~1.2.3` | >=1.2.3 <1.3.0 |\n| `>=1.0.0` | 至少 1.0.0 |\n| `>=1.0.0 <2.0.0` | 范围 |\n| `*` | 任意版本 |\n\n### devDependencies\n\n仅用于开发的依赖（测试、构建等）。\n\n```json\n{\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\",\n    \"hemlang/linter\": \"^2.0.0\"\n  }\n}\n```\n\n开发依赖是：\n- 在开发期间安装\n- 当包作为依赖使用时不安装\n- 用于测试、构建、检查等\n\n### scripts\n\n可以使用 `hpm run` 运行的命名命令。\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n**运行脚本：**\n```bash\nhpm run start\nhpm run build\nhpm test        # 'hpm run test' 的简写\n```\n\n**传递参数：**\n```bash\nhpm run test -- --verbose --filter=unit\n```\n\n**常见脚本：**\n\n| 脚本 | 用途 |\n|--------|---------|\n| `start` | 启动应用程序 |\n| `dev` | 带热重载的开发模式 |\n| `test` | 运行测试 |\n| `build` | 为生产环境构建 |\n| `clean` | 移除构建产物 |\n| `lint` | 检查代码风格 |\n| `format` | 格式化代码 |\n\n### files\n\n安装包时要包含的文件和目录。\n\n```json\n{\n  \"files\": [\n    \"src/\",\n    \"lib/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n**默认行为：** 如果未指定，包含：\n- 仓库中的所有文件\n- 排除 `.git/`、`node_modules/`、`hem_modules/`\n\n**用于：**\n- 减少包大小\n- 从分发中排除测试文件\n- 仅包含必要文件\n\n### native\n\n原生库要求。\n\n```json\n{\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\", \"sqlite3\"]\n  }\n}\n```\n\n记录必须在系统上安装的原生依赖。\n\n## 验证\n\nhpm 在各种操作中验证 package.json。常见验证错误：\n\n### 缺少必需字段\n\n```\nError: package.json missing required field: name\n```\n\n**修复：** 添加必需字段。\n\n### 无效的名称格式\n\n```\nError: Invalid package name. Must be in owner/repo format.\n```\n\n**修复：** 使用 `owner/repo` 格式。\n\n### 无效的版本\n\n```\nError: Invalid version \"1.0\". Must be semver format (X.Y.Z).\n```\n\n**修复：** 使用完整的 semver 格式（`1.0.0`）。\n\n### 无效的 JSON\n\n```\nError: package.json is not valid JSON\n```\n\n**修复：** 检查 JSON 语法（逗号、引号、括号）。\n\n## 创建 package.json\n\n### 交互式\n\n```bash\nhpm init\n```\n\n交互式提示每个字段。\n\n### 使用默认值\n\n```bash\nhpm init --yes\n```\n\n使用默认值创建：\n```json\n{\n  \"name\": \"directory-name/directory-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\n### 手动\n\n手动创建文件：\n\n```bash\ncat > package.json << 'EOF'\n{\n  \"name\": \"yourname/your-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Your package description\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\nEOF\n```\n\n## 最佳实践\n\n1. **始终指定 main** - 不要依赖默认值\n2. **使用插入符范围** - 大多数依赖使用 `^1.0.0`\n3. **分离开发依赖** - 将测试/构建依赖放在 devDependencies 中\n4. **包含关键词** - 帮助用户找到你的包\n5. **记录脚本** - 清晰命名脚本\n6. **指定许可证** - 开源项目必需\n7. **添加描述** - 帮助用户理解用途\n\n## 另请参阅\n\n- [创建包](#hpm-package-spec-creating-packages) - 发布指南\n- [版本控制](#hpm-package-spec-versioning) - 版本约束\n- [项目设置](#hpm-package-spec-project-setup) - 项目结构\n"}, "hpm: Package Development -> Versioning": {"id": "hpm-versioning", "content": "# 版本控制\n\nhpm 中语义化版本控制的完整指南。\n\n## 语义化版本\n\nhpm 使用[语义化版本 2.0.0](https://semver.org/)（semver）进行包版本管理。\n\n### 版本格式\n\n```\nMAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]\n```\n\n**示例：**\n```\n1.0.0           # 发布版本\n2.1.3           # 发布版本\n1.0.0-alpha     # 预发布\n1.0.0-beta.1    # 带编号的预发布\n1.0.0-rc.1      # 候选发布\n1.0.0+20231201  # 带构建元数据\n1.0.0-beta+exp  # 预发布带构建元数据\n```\n\n### 版本组成部分\n\n| 组成部分 | 描述 | 示例 |\n|-----------|-------------|---------|\n| MAJOR | 破坏性更改 | `1.0.0` → `2.0.0` |\n| MINOR | 新功能（向后兼容） | `1.0.0` → `1.1.0` |\n| PATCH | 错误修复（向后兼容） | `1.0.0` → `1.0.1` |\n| PRERELEASE | 预发布标识符 | `1.0.0-alpha` |\n| BUILD | 构建元数据（比较时忽略） | `1.0.0+build123` |\n\n### 何时递增\n\n| 更改类型 | 递增 | 示例 |\n|-------------|-----------|---------|\n| 破坏性 API 更改 | MAJOR | 移除函数 |\n| 重命名公共函数 | MAJOR | `parse()` → `decode()` |\n| 更改函数签名 | MAJOR | 添加必需参数 |\n| 添加新函数 | MINOR | 添加 `validate()` |\n| 添加可选参数 | MINOR | 新的可选 `options` 参数 |\n| 错误修复 | PATCH | 修复空指针 |\n| 性能改进 | PATCH | 更快的算法 |\n| 内部重构 | PATCH | 无 API 更改 |\n\n## 版本约束\n\n### 约束语法\n\n| 语法 | 含义 | 解析为 |\n|--------|---------|-------------|\n| `1.2.3` | 精确版本 | 仅 1.2.3 |\n| `^1.2.3` | 插入符（兼容） | ≥1.2.3 且 <2.0.0 |\n| `~1.2.3` | 波浪号（补丁更新） | ≥1.2.3 且 <1.3.0 |\n| `>=1.0.0` | 至少 | 1.0.0 或更高 |\n| `>1.0.0` | 大于 | 高于 1.0.0 |\n| `<2.0.0` | 小于 | 低于 2.0.0 |\n| `<=2.0.0` | 最多 | 2.0.0 或更低 |\n| `>=1.0.0 <2.0.0` | 范围 | 在 1.0.0 和 2.0.0 之间 |\n| `*` | 任意 | 任意版本 |\n\n### 插入符范围 (^)\n\n插入符（`^`）允许不修改最左边非零数字的更改：\n\n```\n^1.2.3  →  >=1.2.3 <2.0.0   # 允许 1.x.x\n^0.2.3  →  >=0.2.3 <0.3.0   # 允许 0.2.x\n^0.0.3  →  >=0.0.3 <0.0.4   # 仅允许 0.0.3\n```\n\n**使用场景：** 你希望在主版本内获得兼容更新。\n\n**最常见的约束** - 推荐用于大多数依赖。\n\n### 波浪号范围 (~)\n\n波浪号（`~`）仅允许补丁级别的更改：\n\n```\n~1.2.3  →  >=1.2.3 <1.3.0   # 允许 1.2.x\n~1.2    →  >=1.2.0 <1.3.0   # 允许 1.2.x\n~1      →  >=1.0.0 <2.0.0   # 允许 1.x.x\n```\n\n**使用场景：** 你只希望获得错误修复，不要新功能。\n\n### 比较范围\n\n组合比较运算符进行精确控制：\n\n```json\n{\n  \"dependencies\": {\n    \"owner/pkg\": \">=1.0.0 <2.0.0\",\n    \"owner/other\": \">1.5.0 <=2.1.0\"\n  }\n}\n```\n\n### 任意版本 (*)\n\n匹配任意版本：\n\n```json\n{\n  \"dependencies\": {\n    \"owner/pkg\": \"*\"\n  }\n}\n```\n\n**警告：** 不推荐用于生产环境。将始终获取最新版本。\n\n## 预发布版本\n\n### 预发布标识符\n\n预发布版本的优先级低于正式发布版本：\n\n```\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0\n```\n\n### 常见预发布标签\n\n| 标签 | 含义 | 阶段 |\n|-----|---------|-------|\n| `alpha` | 早期开发 | 非常不稳定 |\n| `beta` | 功能完整 | 测试中 |\n| `rc` | 候选发布 | 最终测试 |\n| `dev` | 开发快照 | 不稳定 |\n\n### 约束中的预发布\n\n约束默认不匹配预发布版本：\n\n```\n^1.0.0    # 不匹配 1.1.0-beta\n>=1.0.0   # 不匹配 2.0.0-alpha\n```\n\n要包含预发布版本，请明确引用它们：\n\n```\n>=1.0.0-alpha <2.0.0   # 包含所有 1.x 预发布版本\n```\n\n## 版本比较\n\n### 比较规则\n\n1. 按数值比较 MAJOR、MINOR、PATCH\n2. 发布版本 > 相同版本号的预发布版本\n3. 预发布版本按字母数字顺序比较\n4. 构建元数据被忽略\n\n### 示例\n\n```\n1.0.0 < 1.0.1 < 1.1.0 < 2.0.0\n\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0\n\n1.0.0 = 1.0.0+build123  # 构建元数据被忽略\n```\n\n### 排序\n\n版本按升序排序：\n\n```\n1.0.0\n1.0.1\n1.1.0\n1.1.1\n2.0.0-alpha\n2.0.0-beta\n2.0.0\n```\n\n## 版本解析\n\n### 解析算法\n\n当多个包需要同一个依赖时：\n\n1. 收集所有约束\n2. 找到所有范围的交集\n3. 选择交集中的最高版本\n4. 如果没有版本满足所有约束则报错\n\n### 解析示例\n\n```\npackage-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npackage-b requires hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)\n\nIntersection: >=1.2.0 <1.3.0\nAvailable: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]\nResolved: 1.2.5 (highest in intersection)\n```\n\n### 冲突检测\n\n当没有版本满足所有约束时发生冲突：\n\n```\npackage-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npackage-b requires hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)\n\nIntersection: (empty)\nResult: CONFLICT - no version satisfies both\n```\n\n## 最佳实践\n\n### 对于包使用者\n\n1. **大多数依赖使用插入符范围**：\n   ```json\n   \"hemlang/json\": \"^1.2.0\"\n   ```\n\n2. **关键依赖使用波浪号范围**：\n   ```json\n   \"critical/lib\": \"~1.2.0\"\n   ```\n\n3. **仅在必要时锁定版本**：\n   ```json\n   \"unstable/pkg\": \"1.2.3\"\n   ```\n\n4. **提交锁定文件**以实现可重现的构建\n\n5. **定期更新**以获取安全修复：\n   ```bash\n   hpm update\n   hpm outdated\n   ```\n\n### 对于包作者\n\n1. **初始开发从 0.1.0 开始**：\n   - API 可能频繁更改\n   - 用户预期不稳定\n\n2. **API 稳定后升级到 1.0.0**：\n   - 对稳定性的公开承诺\n   - 破坏性更改需要递增主版本\n\n3. **严格遵循 semver**：\n   - 破坏性更改 = MAJOR\n   - 新功能 = MINOR\n   - 错误修复 = PATCH\n\n4. **使用预发布版本进行测试**：\n   ```bash\n   git tag v2.0.0-beta.1\n   git push --tags\n   ```\n\n5. **在 CHANGELOG 中记录破坏性更改**\n\n## 发布版本\n\n### 创建发布\n\n```bash\n# Update version in package.json\n# Edit package.json: \"version\": \"1.1.0\"\n\n# Commit version change\ngit add package.json\ngit commit -m \"Bump version to 1.1.0\"\n\n# Create and push tag\ngit tag v1.1.0\ngit push origin main --tags\n```\n\n### 标签格式\n\n标签**必须**以 `v` 开头：\n\n```\nv1.0.0      ✓ 正确\nv1.0.0-beta ✓ 正确\n1.0.0       ✗ 不会被识别\n```\n\n### 发布工作流\n\n```bash\n# 1. Ensure tests pass\nhpm test\n\n# 2. Update version in package.json\n# 3. Update CHANGELOG.md\n# 4. Commit changes\ngit add -A\ngit commit -m \"Release v1.2.0\"\n\n# 5. Create tag\ngit tag v1.2.0\n\n# 6. Push everything\ngit push origin main --tags\n```\n\n## 检查版本\n\n### 列出已安装版本\n\n```bash\nhpm list\n```\n\n### 检查更新\n\n```bash\nhpm outdated\n```\n\n输出：\n```\nPackage         Current  Wanted  Latest\nhemlang/json    1.0.0    1.0.5   1.2.0\nhemlang/sprout  2.0.0    2.0.3   2.1.0\n```\n\n- **Current**：已安装版本\n- **Wanted**：符合约束的最高版本\n- **Latest**：最新可用版本\n\n### 更新包\n\n```bash\n# 更新所有\nhpm update\n\n# 更新特定包\nhpm update hemlang/json\n```\n\n## 另请参阅\n\n- [创建包](#hpm-versioning-creating-packages) - 发布指南\n- [包规范](#hpm-versioning-package-spec) - package.json 格式\n- [命令](#hpm-versioning-commands) - CLI 参考\n"}, "hpm: Reference -> Architecture": {"id": "hpm-architecture", "content": "# 架构\n\nhpm 的内部架构和设计。本文档面向贡献者和有兴趣了解 hpm 工作原理的人。\n\n## 概述\n\nhpm 使用 Hemlock 编写，由多个模块组成，处理包管理的不同方面：\n\n```\nsrc/\n├── main.hml        # CLI 入口点和命令路由\n├── manifest.hml    # package.json 处理\n├── lockfile.hml    # package-lock.json 处理\n├── semver.hml      # 语义化版本\n├── resolver.hml    # 依赖解析\n├── github.hml      # GitHub API 客户端\n├── installer.hml   # 包下载和提取\n└── cache.hml       # 全局缓存管理\n```\n\n## 模块职责\n\n### main.hml\n\nCLI 应用程序的入口点。\n\n**职责：**\n- 解析命令行参数\n- 将命令路由到适当的处理器\n- 显示帮助和版本信息\n- 处理全局标志（--verbose、--dry-run 等）\n- 以适当的代码退出\n\n**关键函数：**\n- `main()` - 入口点，解析参数并分派命令\n- `cmd_init()` - 处理 `hpm init`\n- `cmd_install()` - 处理 `hpm install`\n- `cmd_uninstall()` - 处理 `hpm uninstall`\n- `cmd_update()` - 处理 `hpm update`\n- `cmd_list()` - 处理 `hpm list`\n- `cmd_outdated()` - 处理 `hpm outdated`\n- `cmd_run()` - 处理 `hpm run`\n- `cmd_why()` - 处理 `hpm why`\n- `cmd_cache()` - 处理 `hpm cache`\n\n**命令快捷方式：**\n```hemlock\nlet shortcuts = {\n    \"i\": \"install\",\n    \"rm\": \"uninstall\",\n    \"remove\": \"uninstall\",\n    \"ls\": \"list\",\n    \"up\": \"update\"\n};\n```\n\n### manifest.hml\n\n处理 `package.json` 文件的读写。\n\n**职责：**\n- 读写 package.json\n- 验证包结构\n- 管理依赖\n- 解析包说明符（owner/repo@version）\n\n**关键函数：**\n```hemlock\ncreate_default(): Manifest           // 创建空清单\nread_manifest(): Manifest            // 从文件读取\nwrite_manifest(m: Manifest)          // 写入文件\nvalidate(m: Manifest): bool          // 验证结构\nget_all_dependencies(m): Map         // 获取 deps + devDeps\nadd_dependency(m, pkg, ver, dev)     // 添加依赖\nremove_dependency(m, pkg)            // 移除依赖\nparse_specifier(spec): (name, ver)   // 解析 \"owner/repo@^1.0.0\"\nsplit_name(name): (owner, repo)      // 解析 \"owner/repo\"\n```\n\n**Manifest 结构：**\n```hemlock\ntype Manifest = {\n    name: string,\n    version: string,\n    description: string?,\n    author: string?,\n    license: string?,\n    repository: string?,\n    main: string?,\n    dependencies: Map<string, string>,\n    devDependencies: Map<string, string>,\n    scripts: Map<string, string>\n};\n```\n\n### lockfile.hml\n\n管理 `package-lock.json` 文件以实现可重现的安装。\n\n**职责：**\n- 创建/读取/写入锁定文件\n- 跟踪精确解析的版本\n- 存储下载 URL 和完整性哈希\n- 清理孤立的依赖\n\n**关键函数：**\n```hemlock\ncreate_empty(): Lockfile              // 创建空锁定文件\nread_lockfile(): Lockfile             // 从文件读取\nwrite_lockfile(l: Lockfile)           // 写入文件\ncreate_entry(ver, url, hash, deps)    // 创建锁定条目\nget_locked(l, pkg): LockEntry?        // 获取锁定版本\nset_locked(l, pkg, entry)             // 设置锁定版本\nremove_locked(l, pkg)                 // 移除条目\nprune(l, keep: Set)                   // 移除孤立项\nneeds_update(l, m): bool              // 检查是否不同步\n```\n\n**Lockfile 结构：**\n```hemlock\ntype Lockfile = {\n    lockVersion: int,\n    hemlock: string,\n    dependencies: Map<string, LockEntry>\n};\n\ntype LockEntry = {\n    version: string,\n    resolved: string,     // 下载 URL\n    integrity: string,    // SHA256 哈希\n    dependencies: Map<string, string>\n};\n```\n\n### semver.hml\n\n语义化版本 2.0.0 的完整实现。\n\n**职责：**\n- 解析版本字符串\n- 比较版本\n- 解析和评估版本约束\n- 查找满足约束的版本\n\n**关键函数：**\n```hemlock\n// 解析\nparse(s: string): Version             // \"1.2.3-beta+build\" → Version\nstringify(v: Version): string         // Version → \"1.2.3-beta+build\"\n\n// 比较\ncompare(a, b: Version): int           // -1、0 或 1\ngt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool\n\n// 约束\nparse_constraint(s: string): Constraint    // \"^1.2.3\" → Constraint\nsatisfies(v: Version, c: Constraint): bool // 检查 v 是否匹配 c\nmax_satisfying(versions, c): Version?      // 查找最高匹配\nsort(versions): [Version]                  // 升序排序\n\n// 工具\nconstraints_overlap(a, b: Constraint): bool  // 检查兼容性\n```\n\n**Version 结构：**\n```hemlock\ntype Version = {\n    major: int,\n    minor: int,\n    patch: int,\n    prerelease: [string]?,  // 例如 [\"beta\", \"1\"]\n    build: string?          // 例如 \"20230101\"\n};\n```\n\n**Constraint 类型：**\n```hemlock\ntype Constraint =\n    | Exact(Version)           // \"1.2.3\"\n    | Caret(Version)           // \"^1.2.3\" → >=1.2.3 <2.0.0\n    | Tilde(Version)           // \"~1.2.3\" → >=1.2.3 <1.3.0\n    | Range(op, Version)       // \">=1.0.0\", \"<2.0.0\"\n    | And(Constraint, Constraint)  // 组合范围\n    | Any;                     // \"*\"\n```\n\n### resolver.hml\n\n实现 npm 风格的依赖解析。\n\n**职责：**\n- 解析依赖树\n- 检测版本冲突\n- 检测循环依赖\n- 构建可视化树\n\n**关键函数：**\n```hemlock\nresolve(manifest, lockfile): ResolveResult\n    // 主解析器：返回所有依赖及解析版本的扁平映射\n\nresolve_version(pkg, constraints: [string]): ResolvedPackage?\n    // 查找满足所有约束的版本\n\ndetect_cycles(deps: Map): [Cycle]?\n    // 使用 DFS 查找循环依赖\n\nbuild_tree(lockfile): Tree\n    // 创建用于显示的树结构\n\nfind_why(pkg, lockfile): [Chain]\n    // 查找解释为什么安装 pkg 的依赖链\n```\n\n**解析算法：**\n\n1. **收集约束**：遍历清单和传递依赖\n2. **解析每个包**：对于每个包：\n   - 从依赖方获取所有版本约束\n   - 从 GitHub 获取可用版本\n   - 查找满足所有约束的最高版本\n   - 如果没有版本满足所有约束则报错（冲突）\n3. **检测循环**：运行 DFS 查找循环依赖\n4. **返回扁平映射**：包名 → 解析的版本信息\n\n**ResolveResult 结构：**\n```hemlock\ntype ResolveResult = {\n    packages: Map<string, ResolvedPackage>,\n    conflicts: [Conflict]?,\n    cycles: [Cycle]?\n};\n\ntype ResolvedPackage = {\n    name: string,\n    version: Version,\n    url: string,\n    dependencies: Map<string, string>\n};\n```\n\n### github.hml\n\n用于包发现和下载的 GitHub API 客户端。\n\n**职责：**\n- 获取可用版本（标签）\n- 从仓库下载 package.json\n- 下载发布 tarball\n- 处理认证和速率限制\n\n**关键函数：**\n```hemlock\nget_token(): string?\n    // 从环境或配置获取 token\n\ngithub_request(url, headers?): Response\n    // 带重试的 API 请求\n\nget_tags(owner, repo): [string]\n    // 获取版本标签（v1.0.0、v1.1.0 等）\n\nget_package_json(owner, repo, ref): Manifest\n    // 在特定标签/提交处获取 package.json\n\ndownload_tarball(owner, repo, tag): bytes\n    // 下载发布归档\n\nrepo_exists(owner, repo): bool\n    // 检查仓库是否存在\n\nget_repo_info(owner, repo): RepoInfo\n    // 获取仓库元数据\n```\n\n**重试逻辑：**\n- 指数退避：1秒、2秒、4秒、8秒\n- 重试条件：403（速率限制）、5xx（服务器错误）、网络错误\n- 最多 4 次重试\n- 清晰报告速率限制错误\n\n**使用的 API 端点：**\n```\nGET /repos/{owner}/{repo}/tags\nGET /repos/{owner}/{repo}/contents/package.json?ref={tag}\nGET /repos/{owner}/{repo}/tarball/{tag}\nGET /repos/{owner}/{repo}\n```\n\n### installer.hml\n\n处理包的下载和提取。\n\n**职责：**\n- 从 GitHub 下载包\n- 将 tarball 提取到 hem_modules\n- 检查/使用缓存的包\n- 安装/卸载包\n\n**关键函数：**\n```hemlock\ninstall_package(pkg: ResolvedPackage): bool\n    // 下载并安装单个包\n\ninstall_all(packages: Map, options): InstallResult\n    // 安装所有解析的包\n\nuninstall_package(name: string): bool\n    // 从 hem_modules 移除包\n\nget_installed(): Map<string, string>\n    // 列出当前已安装的包\n\nverify_integrity(pkg): bool\n    // 验证包完整性\n\nprefetch_packages(packages: Map): void\n    // 并行下载到缓存（实验性）\n```\n\n**安装过程：**\n\n1. 检查是否已安装正确版本\n2. 检查缓存中的 tarball\n3. 如果未缓存，从 GitHub 下载\n4. 存储到缓存供将来使用\n5. 提取到 `hem_modules/owner/repo/`\n6. 验证安装\n\n**创建的目录结构：**\n```\nhem_modules/\n└── owner/\n    └── repo/\n        ├── package.json\n        ├── src/\n        └── ...\n```\n\n### cache.hml\n\n管理全局包缓存。\n\n**职责：**\n- 存储下载的 tarball\n- 检索缓存的包\n- 列出缓存的包\n- 清除缓存\n- 管理配置\n\n**关键函数：**\n```hemlock\nget_cache_dir(): string\n    // 获取缓存目录（尊重 HPM_CACHE_DIR）\n\nget_config_dir(): string\n    // 获取配置目录（~/.hpm）\n\nis_cached(owner, repo, version): bool\n    // 检查 tarball 是否已缓存\n\nget_cached_path(owner, repo, version): string\n    // 获取缓存 tarball 的路径\n\nstore_tarball_file(owner, repo, version, data): void\n    // 将 tarball 保存到缓存\n\nlist_cached(): [CachedPackage]\n    // 列出所有缓存的包\n\nclear_cache(): int\n    // 移除所有缓存的包，返回释放的字节数\n\nget_cache_size(): int\n    // 计算缓存总大小\n\nread_config(): Config\n    // 读取 ~/.hpm/config.json\n\nwrite_config(c: Config): void\n    // 写入配置文件\n```\n\n**缓存结构：**\n```\n~/.hpm/\n├── config.json\n└── cache/\n    └── owner/\n        └── repo/\n            ├── 1.0.0.tar.gz\n            └── 1.1.0.tar.gz\n```\n\n## 数据流\n\n### Install 命令流程\n\n```\nhpm install owner/repo@^1.0.0\n         │\n         ▼\n    ┌─────────┐\n    │ main.hml │ 解析参数，调用 cmd_install\n    └────┬────┘\n         │\n         ▼\n    ┌──────────┐\n    │manifest.hml│ 读取 package.json，添加依赖\n    └────┬─────┘\n         │\n         ▼\n    ┌──────────┐\n    │resolver.hml│ 解析所有依赖\n    └────┬─────┘\n         │\n         ├───────────────┐\n         ▼               ▼\n    ┌──────────┐    ┌─────────┐\n    │ github.hml│    │ semver.hml│ 获取版本，查找满足条件的版本\n    └────┬─────┘    └─────────┘\n         │\n         ▼\n    ┌───────────┐\n    │installer.hml│ 下载并提取包\n    └────┬──────┘\n         │\n         ├───────────────┐\n         ▼               ▼\n    ┌──────────┐    ┌─────────┐\n    │ github.hml│    │ cache.hml│ 下载或使用缓存\n    └──────────┘    └─────────┘\n         │\n         ▼\n    ┌──────────┐\n    │lockfile.hml│ 更新 package-lock.json\n    └──────────┘\n```\n\n### 解析算法详情\n\n```\n输入：manifest.dependencies、manifest.devDependencies、现有 lockfile\n\n1. 初始化：\n   - constraints = {} // Map<string, [Constraint]>\n   - resolved = {}    // Map<string, ResolvedPackage>\n   - queue = [直接依赖]\n\n2. 当队列不为空时：\n   a. pkg = queue.pop()\n   b. 如果 pkg 已解析，跳过\n   c. 从依赖方获取 pkg 的所有约束\n   d. 从 GitHub 获取可用版本（已缓存）\n   e. 查找满足所有约束的最高版本\n   f. 如果未找到：冲突\n   g. resolved[pkg] = {version, url, deps}\n   h. 将 pkg 的依赖添加到队列\n\n3. 在解析图中检测循环\n   - 如果发现循环：错误\n\n4. 返回解析映射\n```\n\n## 错误处理\n\n### 退出码\n\n在 main.hml 中定义：\n\n```hemlock\nlet EXIT_SUCCESS = 0;\nlet EXIT_CONFLICT = 1;\nlet EXIT_NOT_FOUND = 2;\nlet EXIT_VERSION_NOT_FOUND = 3;\nlet EXIT_NETWORK = 4;\nlet EXIT_INVALID_MANIFEST = 5;\nlet EXIT_INTEGRITY = 6;\nlet EXIT_RATE_LIMIT = 7;\nlet EXIT_CIRCULAR = 8;\n```\n\n### 错误传播\n\n错误通过返回值向上冒泡：\n\n```hemlock\nfn resolve_version(pkg): Result<Version, ResolveError> {\n    let versions = github.get_tags(owner, repo)?;  // ? 传播错误\n    // ...\n}\n```\n\n## 测试\n\n### 测试框架\n\n`test/framework.hml` 中的自定义测试框架：\n\n```hemlock\nfn suite(name: string, tests: fn()) {\n    print(\"Suite: \" + name);\n    tests();\n}\n\nfn test(name: string, body: fn()) {\n    try {\n        body();\n        print(\"  ✓ \" + name);\n    } catch e {\n        print(\"  ✗ \" + name + \": \" + e);\n        failed += 1;\n    }\n}\n\nfn assert_eq<T>(actual: T, expected: T) {\n    if actual != expected {\n        throw \"Expected \" + expected + \", got \" + actual;\n    }\n}\n```\n\n### 测试文件\n\n- `test/test_semver.hml` - 版本解析、比较、约束\n- `test/test_manifest.hml` - 清单读写、验证\n- `test/test_lockfile.hml` - 锁定文件操作\n- `test/test_cache.hml` - 缓存管理\n\n### 运行测试\n\n```bash\n# 所有测试\nmake test\n\n# 特定测试\nmake test-semver\nmake test-manifest\nmake test-lockfile\nmake test-cache\n```\n\n## 未来改进\n\n### 计划功能\n\n1. **完整性验证** - 完整的 SHA256 哈希检查\n2. **工作区** - Monorepo 支持\n3. **插件系统** - 可扩展命令\n4. **审计** - 安全漏洞检查\n5. **私有注册表** - 自托管包托管\n\n### 已知限制\n\n1. **打包器 bug** - 无法创建独立可执行文件\n2. **并行下载** - 实验性，可能有竞态条件\n3. **完整性** - SHA256 未完全实现\n\n## 贡献\n\n### 代码风格\n\n- 使用 4 空格缩进\n- 函数应该只做一件事\n- 注释复杂逻辑\n- 为新功能编写测试\n\n### 添加命令\n\n1. 在 `main.hml` 中添加处理器：\n   ```hemlock\n   fn cmd_newcmd(args: [string]) {\n       // Implementation\n   }\n   ```\n\n2. 添加到命令分派：\n   ```hemlock\n   match command {\n       \"newcmd\" => cmd_newcmd(args),\n       // ...\n   }\n   ```\n\n3. 更新帮助文本\n\n### 添加模块\n\n1. 创建 `src/newmodule.hml`\n2. 导出公共接口\n3. 在需要它的模块中导入\n4. 在 `test/test_newmodule.hml` 中添加测试\n\n## 另请参阅\n\n- [命令](#hpm-architecture-commands) - CLI 参考\n- [创建包](#hpm-architecture-creating-packages) - 包开发\n- [版本控制](#hpm-architecture-versioning) - 语义化版本\n"}, "hpm: Reference -> Exit Codes": {"id": "hpm-exit-codes", "content": "# 退出码\n\nhpm 退出码及其含义的参考。\n\n## 退出码表\n\n| 代码 | 名称 | 描述 |\n|------|------|-------------|\n| 0 | SUCCESS | 命令成功完成 |\n| 1 | CONFLICT | 依赖版本冲突 |\n| 2 | NOT_FOUND | 包未找到 |\n| 3 | VERSION_NOT_FOUND | 请求的版本未找到 |\n| 4 | NETWORK | 网络错误 |\n| 5 | INVALID_MANIFEST | 无效的 package.json |\n| 6 | INTEGRITY | 完整性检查失败 |\n| 7 | RATE_LIMIT | 超出 GitHub API 速率限制 |\n| 8 | CIRCULAR | 检测到循环依赖 |\n\n## 详细描述\n\n### 退出码 0: SUCCESS\n\n命令成功完成。\n\n```bash\n$ hpm install\nInstalled 5 packages\n$ echo $?\n0\n```\n\n### 退出码 1: CONFLICT\n\n两个或多个包需要不兼容版本的依赖。\n\n**示例：**\n```\nError: Dependency conflict for hemlang/json\n\n  package-a requires hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)\n  package-b requires hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)\n\nNo version satisfies all constraints.\n```\n\n**解决方案：**\n1. 检查哪些包有冲突：\n   ```bash\n   hpm why hemlang/json\n   ```\n2. 更新冲突的包：\n   ```bash\n   hpm update package-a\n   ```\n3. 放宽 package.json 中的版本约束\n4. 移除冲突的包之一\n\n### 退出码 2: NOT_FOUND\n\n指定的包在 GitHub 上不存在。\n\n**示例：**\n```\nError: Package not found: hemlang/nonexistent\n\nThe repository hemlang/nonexistent does not exist on GitHub.\n```\n\n**解决方案：**\n1. 验证包名称拼写\n2. 检查仓库是否存在：`https://github.com/owner/repo`\n3. 验证你有访问权限（对于私有仓库，设置 GITHUB_TOKEN）\n\n### 退出码 3: VERSION_NOT_FOUND\n\n没有版本匹配指定的约束。\n\n**示例：**\n```\nError: No version of hemlang/json matches constraint ^5.0.0\n\nAvailable versions: 1.0.0, 1.1.0, 1.2.0, 2.0.0\n```\n\n**解决方案：**\n1. 在 GitHub releases/tags 上检查可用版本\n2. 使用有效的版本约束\n3. 版本标签必须以 'v' 开头（例如 `v1.0.0`）\n\n### 退出码 4: NETWORK\n\n发生网络相关错误。\n\n**示例：**\n```\nError: Network error: could not connect to api.github.com\n\nPlease check your internet connection and try again.\n```\n\n**解决方案：**\n1. 检查网络连接\n2. 检查 GitHub 是否可访问\n3. 如果在防火墙后面，验证代理设置\n4. 如果包已缓存，使用 `--offline`：\n   ```bash\n   hpm install --offline\n   ```\n5. 等待并重试（hpm 会自动重试）\n\n### 退出码 5: INVALID_MANIFEST\n\npackage.json 文件无效或格式错误。\n\n**示例：**\n```\nError: Invalid package.json\n\n  - Missing required field: name\n  - Invalid version format: \"1.0\"\n```\n\n**解决方案：**\n1. 检查 JSON 语法（使用 JSON 验证器）\n2. 确保必需字段存在（`name`、`version`）\n3. 验证字段格式：\n   - name：`owner/repo` 格式\n   - version：`X.Y.Z` semver 格式\n4. 重新生成：\n   ```bash\n   rm package.json\n   hpm init\n   ```\n\n### 退出码 6: INTEGRITY\n\n包完整性验证失败。\n\n**示例：**\n```\nError: Integrity check failed for hemlang/json@1.0.0\n\nExpected: sha256-abc123...\nActual:   sha256-def456...\n\nThe downloaded package may be corrupted.\n```\n\n**解决方案：**\n1. 清除缓存并重新安装：\n   ```bash\n   hpm cache clean\n   hpm install\n   ```\n2. 检查网络问题（部分下载）\n3. 验证包未被篡改\n\n### 退出码 7: RATE_LIMIT\n\n超出 GitHub API 速率限制。\n\n**示例：**\n```\nError: GitHub API rate limit exceeded\n\nUnauthenticated rate limit: 60 requests/hour\nCurrent usage: 60/60\n\nRate limit resets at: 2024-01-15 10:30:00 UTC\n```\n\n**解决方案：**\n1. **使用 GitHub 认证**（推荐）：\n   ```bash\n   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx\n   hpm install\n   ```\n2. 等待速率限制重置（每小时重置）\n3. 如果包已缓存，使用离线模式：\n   ```bash\n   hpm install --offline\n   ```\n\n### 退出码 8: CIRCULAR\n\n在依赖图中检测到循环依赖。\n\n**示例：**\n```\nError: Circular dependency detected\n\n  package-a@1.0.0\n  └── package-b@1.0.0\n      └── package-a@1.0.0  (circular!)\n\nCannot resolve dependency tree.\n```\n\n**解决方案：**\n1. 这通常是包本身的 bug\n2. 联系包维护者\n3. 避免使用循环包之一\n\n## 在脚本中使用退出码\n\n### Bash\n\n```bash\n#!/bin/bash\n\nhpm install\nexit_code=$?\n\ncase $exit_code in\n  0)\n    echo \"Installation successful\"\n    ;;\n  1)\n    echo \"Dependency conflict - check version constraints\"\n    exit 1\n    ;;\n  2)\n    echo \"Package not found - check package name\"\n    exit 1\n    ;;\n  4)\n    echo \"Network error - check connection\"\n    exit 1\n    ;;\n  7)\n    echo \"Rate limited - set GITHUB_TOKEN\"\n    exit 1\n    ;;\n  *)\n    echo \"Unknown error: $exit_code\"\n    exit 1\n    ;;\nesac\n```\n\n### CI/CD\n\n```yaml\n# GitHub Actions\n- name: Install dependencies\n  run: |\n    hpm install\n    if [ $? -eq 7 ]; then\n      echo \"::error::GitHub rate limit exceeded. Add GITHUB_TOKEN.\"\n      exit 1\n    fi\n  env:\n    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n### Make\n\n```makefile\ninstall:\n\t@hpm install || (echo \"Installation failed with code $$?\"; exit 1)\n\ntest: install\n\t@hpm test\n```\n\n## 按退出码故障排除\n\n### 快速参考\n\n| 代码 | 首先检查 |\n|------|---------------------|\n| 1 | 运行 `hpm why <package>` 查看冲突 |\n| 2 | 在 GitHub 上验证包名称 |\n| 3 | 在 GitHub 标签上检查可用版本 |\n| 4 | 检查网络连接 |\n| 5 | 验证 package.json 语法 |\n| 6 | 运行 `hpm cache clean && hpm install` |\n| 7 | 设置 `GITHUB_TOKEN` 环境变量 |\n| 8 | 联系包维护者 |\n\n## 另请参阅\n\n- [故障排除](#hpm-exit-codes-troubleshooting) - 详细解决方案\n- [命令](#hpm-exit-codes-commands) - 命令参考\n- [配置](#hpm-exit-codes-configuration) - 设置 GitHub token\n"}};

        // Mobile menu toggle
        const menuToggle = document.getElementById('menuToggle');
        const sidebar = document.getElementById('sidebar');

        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
            menuToggle.textContent = sidebar.classList.contains('open') ? '\u00d7' : '\u2630';
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth < 1024) {
                if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                }
            }
        });

        // Theme toggle functionality
        const themeToggle = document.getElementById('themeToggle');
        const root = document.documentElement;

        // Get saved theme or detect system preference
        function getPreferredTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                return savedTheme;
            }
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        // Apply theme
        function setTheme(theme) {
            root.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        }

        // Initialize theme
        const initialTheme = getPreferredTheme();
        if (localStorage.getItem('theme')) {
            setTheme(initialTheme);
        }

        // Toggle theme on button click
        themeToggle.addEventListener('click', () => {
            const currentTheme = root.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            // Determine current effective theme
            let effectiveTheme;
            if (currentTheme) {
                effectiveTheme = currentTheme;
            } else {
                effectiveTheme = prefersDark ? 'dark' : 'light';
            }

            // Toggle to opposite theme
            const newTheme = effectiveTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        });

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!localStorage.getItem('theme')) {
                // Only auto-switch if user hasn't manually set a preference
                root.removeAttribute('data-theme');
            }
        });

        // Markdown parser
        function parseMarkdown(md) {
            let lines = md.split('\n');
            let html = '';
            let inCodeBlock = false;
            let codeBlockContent = '';
            let codeBlockLang = '';
            let inList = false;
            let listContent = '';
            let inBlockquote = false;
            let blockquoteContent = '';
            let inTable = false;
            let tableRows = [];
            let tableHasHeader = false;

            function processInlineMarkdown(text) {
                text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
                text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
                return text;
            }

            function makeId(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/^-+|-+$/g, '');
            }

            function flushList() {
                if (inList && listContent) {
                    html += '<ul>\n' + listContent + '</ul>\n';
                    listContent = '';
                    inList = false;
                }
            }

            function flushBlockquote() {
                if (inBlockquote && blockquoteContent) {
                    html += '<blockquote>' + processInlineMarkdown(blockquoteContent.trim()) + '</blockquote>\n';
                    blockquoteContent = '';
                    inBlockquote = false;
                }
            }

            function flushTable() {
                if (inTable && tableRows.length > 0) {
                    html += '<table>\n';
                    for (let r = 0; r < tableRows.length; r++) {
                        const row = tableRows[r];
                        const isHeader = tableHasHeader && r === 0;
                        const tag = isHeader ? 'th' : 'td';
                        html += '<tr>\n';
                        for (const cell of row) {
                            html += '<' + tag + '>' + processInlineMarkdown(cell.trim()) + '</' + tag + '>\n';
                        }
                        html += '</tr>\n';
                    }
                    html += '</table>\n';
                    tableRows = [];
                    inTable = false;
                    tableHasHeader = false;
                }
            }

            function isTableSeparator(line) {
                return /^\|?[\s-:|]+\|[\s-:|]+\|?$/.test(line) && line.includes('-');
            }

            function parseTableRow(line) {
                let cells = line.split('|');
                // Remove empty first/last cells from leading/trailing |
                if (cells.length > 0 && cells[0].trim() === '') cells.shift();
                if (cells.length > 0 && cells[cells.length - 1].trim() === '') cells.pop();
                return cells;
            }

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                const trimmedLine = line.trim();

                // Handle code blocks (including indented ones in lists)
                if (trimmedLine.startsWith('```')) {
                    if (inCodeBlock) {
                        const codeId = 'code-' + Math.random().toString(36).substr(2, 9);
                        const langDisplay = codeBlockLang || 'code';
                        const copyIcon = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>';
                        html += `<div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">${langDisplay}</span>
                                <button class="copy-btn" onclick="copyCode('${codeId}')">${copyIcon}<span>Copy</span></button>
                            </div>
                            <pre><code id="${codeId}">` + escapeHtml(codeBlockContent) + '</code></pre></div>\n';
                        codeBlockContent = '';
                        codeBlockLang = '';
                        inCodeBlock = false;
                    } else {
                        flushList();
                        flushBlockquote();
                        inCodeBlock = true;
                        codeBlockLang = trimmedLine.substring(3).trim();
                    }
                    continue;
                }

                if (inCodeBlock) {
                    codeBlockContent += line + '\n';
                    continue;
                }

                // Table handling
                if (trimmedLine.includes('|')) {
                    if (trimmedLine.startsWith('|') || trimmedLine.endsWith('|')) {
                        flushList();
                        flushBlockquote();
                        if (isTableSeparator(trimmedLine)) {
                            // This is the separator row (|---|---|), mark header
                            if (tableRows.length === 1) {
                                tableHasHeader = true;
                            }
                        } else {
                            // Regular table row
                            tableRows.push(parseTableRow(trimmedLine));
                            inTable = true;
                        }
                        continue;
                    }
                }
                // Flush table if we hit a non-table line
                if (inTable) {
                    flushTable();
                }

                if (line.startsWith('# ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    const id = makeId(text);
                    html += `<h1 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h1>\n`;
                    continue;
                }
                if (line.startsWith('## ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(3).trim();
                    const id = makeId(text);
                    html += `<h2 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h2>\n`;
                    continue;
                }
                if (line.startsWith('### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(4).trim();
                    const id = makeId(text);
                    html += `<h3 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h3>\n`;
                    continue;
                }
                if (line.startsWith('#### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(5).trim();
                    const id = makeId(text);
                    html += `<h4 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h4>\n`;
                    continue;
                }

                if (line.trim() === '---') {
                    flushList();
                    flushBlockquote();
                    html += '<hr>\n';
                    continue;
                }

                if (line.startsWith('> ')) {
                    flushList();
                    blockquoteContent += line.substring(2) + ' ';
                    inBlockquote = true;
                    continue;
                } else if (inBlockquote && line.trim() === '') {
                    flushBlockquote();
                    continue;
                }

                if (line.startsWith('- ') || line.startsWith('* ')) {
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    listContent += '<li>' + processInlineMarkdown(text) + '</li>\n';
                    inList = true;
                    continue;
                } else if (inList && line.trim() !== '' && !line.startsWith('#')) {
                    listContent = listContent.trimEnd();
                    if (listContent.endsWith('</li>')) {
                        listContent = listContent.substring(0, listContent.length - 5);
                        listContent += ' ' + processInlineMarkdown(line.trim()) + '</li>\n';
                    }
                    continue;
                } else if (inList && line.trim() === '') {
                    flushList();
                    continue;
                }

                if (line.trim() === '') {
                    flushList();
                    flushBlockquote();
                    continue;
                }

                flushList();
                flushBlockquote();
                if (line.trim() !== '') {
                    html += '<p>' + processInlineMarkdown(line) + '</p>\n';
                }
            }

            flushList();
            flushBlockquote();
            flushTable();

            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Copy code to clipboard
        function copyCode(codeId) {
            const codeElement = document.getElementById(codeId);
            if (!codeElement) return;

            const text = codeElement.textContent;
            navigator.clipboard.writeText(text).then(() => {
                // Find the button that triggered this
                const btn = codeElement.closest('.code-block').querySelector('.copy-btn');
                if (btn) {
                    const originalText = btn.querySelector('span').textContent;
                    btn.classList.add('copied');
                    btn.querySelector('span').textContent = 'Copied!';

                    setTimeout(() => {
                        btn.classList.remove('copied');
                        btn.querySelector('span').textContent = originalText;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Load a page
        function loadPage(pageId) {
            const pageData = Object.values(PAGES).find(p => p.id === pageId);
            if (!pageData) {
                console.error('Page not found:', pageId);
                return;
            }

            const content = parseMarkdown(pageData.content);
            document.getElementById('content').innerHTML = content;

            // Update active nav link
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.dataset.page === pageId) {
                    link.classList.add('active');
                }
            });

            // Scroll to top
            window.scrollTo(0, 0);

            // Update URL hash
            window.location.hash = pageId;
        }

        // Setup navigation
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const pageId = link.dataset.page;
                loadPage(pageId);

                // Close mobile menu
                if (window.innerWidth < 1024) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                }
            });
        });

        // Handle browser back/forward
        window.addEventListener('hashchange', () => {
            const hash = window.location.hash.substring(1);
            if (hash) {
                loadPage(hash);
            }
        });

        // Search functionality
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const searchContainer = document.getElementById('searchContainer');
        const searchToggle = document.getElementById('searchToggle');
        let selectedIndex = -1;
        let currentResults = [];

        // Build search index from PAGES
        function buildSearchIndex() {
            const index = [];
            for (const [title, page] of Object.entries(PAGES)) {
                // Extract section from page ID
                const parts = page.id.split('-');
                let section = '';
                if (parts.length > 1) {
                    section = parts.slice(0, -1).join(' ');
                }

                // Extract headings from content
                const headings = [];
                const headingRegex = /^#+\s+(.+)$/gm;
                let match;
                while ((match = headingRegex.exec(page.content)) !== null) {
                    headings.push(match[1]);
                }

                // Get preview text (first 200 chars, stripped of markdown)
                let preview = page.content
                    .replace(/^#+\s+.+$/gm, '')  // Remove headings
                    .replace(/```[\s\S]*?```/g, '')  // Remove code blocks
                    .replace(/`[^`]+`/g, '')  // Remove inline code
                    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')  // Convert links to text
                    .replace(/\*\*([^*]+)\*\*/g, '$1')  // Remove bold
                    .replace(/\*([^*]+)\*/g, '$1')  // Remove italic
                    .replace(/\n+/g, ' ')  // Normalize whitespace
                    .trim()
                    .substring(0, 200);

                index.push({
                    title: title,
                    pageId: page.id,
                    section: section,
                    headings: headings,
                    content: page.content.toLowerCase(),
                    preview: preview
                });
            }
            return index;
        }

        const searchIndex = buildSearchIndex();

        // Search function
        function search(query) {
            if (!query || query.length < 2) return [];

            const q = query.toLowerCase().trim();
            const results = [];

            for (const item of searchIndex) {
                let score = 0;
                let matchedHeading = null;
                let matchContext = '';

                // Check title (highest priority)
                const titleLower = item.title.toLowerCase();
                if (titleLower === q) {
                    score = 100;
                } else if (titleLower.startsWith(q)) {
                    score = 80;
                } else if (titleLower.includes(q)) {
                    score = 60;
                }

                // Check headings
                for (const heading of item.headings) {
                    const headingLower = heading.toLowerCase();
                    if (headingLower === q) {
                        score = Math.max(score, 50);
                        matchedHeading = heading;
                    } else if (headingLower.includes(q)) {
                        score = Math.max(score, 40);
                        if (!matchedHeading) matchedHeading = heading;
                    }
                }

                // Check content
                if (item.content.includes(q)) {
                    score = Math.max(score, 20);

                    // Find context around the match
                    const idx = item.content.indexOf(q);
                    const start = Math.max(0, idx - 40);
                    const end = Math.min(item.content.length, idx + q.length + 60);
                    matchContext = item.content.substring(start, end);
                    if (start > 0) matchContext = '...' + matchContext;
                    if (end < item.content.length) matchContext = matchContext + '...';
                }

                if (score > 0) {
                    results.push({
                        title: item.title,
                        pageId: item.pageId,
                        section: item.section,
                        score: score,
                        matchedHeading: matchedHeading,
                        preview: matchContext || item.preview,
                        query: q
                    });
                }
            }

            // Sort by score descending
            results.sort((a, b) => b.score - a.score);

            return results.slice(0, 10);  // Limit to 10 results
        }

        // Highlight query in text
        function highlightText(text, query) {
            if (!query) return text;
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }

        // Render search results
        function renderResults(results, query) {
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-no-results">No results found</div>';
                return;
            }

            const html = results.map((result, index) => {
                const titleHtml = highlightText(result.title, query);
                const previewHtml = highlightText(result.preview, query);
                const selectedClass = index === selectedIndex ? ' selected' : '';

                return `
                    <div class="search-result${selectedClass}" data-index="${index}" data-page="${result.pageId}">
                        ${result.section ? `<div class="search-result-section">${result.section}</div>` : ''}
                        <div class="search-result-title">${titleHtml}</div>
                        ${result.matchedHeading ? `<div class="search-result-preview">${highlightText(result.matchedHeading, query)}</div>` : ''}
                        <div class="search-result-preview">${previewHtml}</div>
                    </div>
                `;
            }).join('');

            searchResults.innerHTML = html;

            // Add click handlers
            searchResults.querySelectorAll('.search-result').forEach(el => {
                el.addEventListener('click', () => {
                    const pageId = el.dataset.page;
                    loadPage(pageId);
                    closeSearch();
                });
            });
        }

        // Show search results
        function showResults() {
            searchResults.classList.add('active');
        }

        // Hide search results
        function hideResults() {
            searchResults.classList.remove('active');
            selectedIndex = -1;
        }

        // Close search (mobile)
        function closeSearch() {
            hideResults();
            searchInput.value = '';
            searchInput.blur();
            if (window.innerWidth < 769) {
                searchContainer.classList.remove('active');
            }
        }

        // Debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Handle search input
        const handleSearch = debounce((query) => {
            currentResults = search(query);
            if (query.length >= 2) {
                renderResults(currentResults, query);
                showResults();
            } else {
                hideResults();
            }
        }, 150);

        searchInput.addEventListener('input', (e) => {
            handleSearch(e.target.value);
        });

        // Handle keyboard navigation
        searchInput.addEventListener('keydown', (e) => {
            if (!searchResults.classList.contains('active')) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, currentResults.length - 1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIndex >= 0 && currentResults[selectedIndex]) {
                    loadPage(currentResults[selectedIndex].pageId);
                    closeSearch();
                } else if (currentResults.length > 0) {
                    loadPage(currentResults[0].pageId);
                    closeSearch();
                }
            } else if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Close results when clicking outside
        document.addEventListener('click', (e) => {
            if (!searchContainer.contains(e.target)) {
                hideResults();
            }
        });

        // Focus search on input click
        searchInput.addEventListener('focus', () => {
            if (searchInput.value.length >= 2) {
                handleSearch(searchInput.value);
            }
        });

        // Global keyboard shortcut (Ctrl+K or Cmd+K)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                if (window.innerWidth < 769) {
                    searchContainer.classList.add('active');
                }
                searchInput.focus();
            }
            if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Mobile search toggle
        if (searchToggle) {
            searchToggle.addEventListener('click', () => {
                searchContainer.classList.toggle('active');
                if (searchContainer.classList.contains('active')) {
                    searchInput.focus();
                }
            });
        }

        // Language switcher
        function switchLanguage(filename) {
            const currentHash = window.location.hash;
            window.location.href = filename + currentHash;
        }

        // Load initial page
        const initialHash = window.location.hash.substring(1);
        const firstPageId = Object.values(PAGES)[0].id;
        loadPage(initialHash || firstPageId);
    </script>
</body>
</html>