<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hemlock 语言手册</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --sage: #9CAF88;
            --pine: #2F4F4F;
            --dark-pine: #1a2f2f;
            --light-sage: #E8F4E1;
            --cream: #FAF9F6;
            --text: #2C3E2C;
            --text-light: #5A6F5A;
            --border: #D4E4CB;
            --code-bg: #F5F9F3;
            --accent: #6B8E6B;
        }

        [data-theme="dark"] {
            --sage: #6B8E6B;
            --pine: #9CAF88;
            --dark-pine: #0d1a1a;
            --light-sage: #1a2f2f;
            --cream: #0f1a1a;
            --text: #e0e8e0;
            --text-light: #a8b8a8;
            --border: #2a4a4a;
            --code-bg: #162626;
            --accent: #9CAF88;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) {
                --sage: #6B8E6B;
                --pine: #9CAF88;
                --dark-pine: #0d1a1a;
                --light-sage: #1a2f2f;
                --cream: #0f1a1a;
                --text: #e0e8e0;
                --text-light: #a8b8a8;
                --border: #2a4a4a;
                --code-bg: #162626;
                --accent: #9CAF88;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            line-height: 1.7;
            color: var(--text);
            background: var(--cream);
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            background: #2F4F4F;
            color: white;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 1rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .header-logo {
            height: 45px;
            margin-right: 1rem;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            margin-right: auto;
        }

        @media (max-width: 1023px) {
            .header {
                justify-content: flex-start;
            }
            .header h1 {
                display: none;
            }
        }

        /* Layout */
        .container {
            display: flex;
            margin-top: 70px;
            min-height: calc(100vh - 70px);
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 70px;
            width: 280px;
            height: calc(100vh - 70px);
            background: var(--light-sage);
            border-right: 2px solid var(--border);
            overflow-y: auto;
            padding: 2rem 0;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 900;
        }

        .sidebar.open {
            transform: translateX(0);
        }

        @media (min-width: 1024px) {
            .sidebar {
                transform: translateX(0);
            }
        }

        .nav-section {
            margin-bottom: 1.5rem;
        }

        .nav-section-title {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--pine);
            padding: 0 1.5rem;
            margin-bottom: 0.5rem;
        }

        .nav-link {
            display: block;
            padding: 0.5rem 1.5rem;
            color: var(--text);
            text-decoration: none;
            font-size: 0.9rem;
            transition: all 0.2s;
            border-left: 3px solid transparent;
            cursor: pointer;
        }

        .nav-link:hover {
            background: rgba(47, 79, 79, 0.05);
            border-left-color: var(--sage);
        }

        .nav-link.active {
            background: rgba(47, 79, 79, 0.1);
            border-left-color: var(--pine);
            font-weight: 600;
            color: var(--pine);
        }

        /* Mobile Menu Toggle */
        .menu-toggle {
            display: none;
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            margin-right: 0.5rem;
        }

        @media (max-width: 1023px) {
            .menu-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }

        /* Main Content */
        .main-content {
            flex: 1;
            margin-left: 0;
            padding: 3rem 2rem;
            max-width: 900px;
        }

        @media (min-width: 1024px) {
            .main-content {
                margin-left: 280px;
            }
        }

        /* Typography */
        .content h1 {
            font-size: 2.5rem;
            color: var(--pine);
            margin: 2rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--sage);
        }

        .content h2 {
            font-size: 2rem;
            color: var(--pine);
            margin: 3rem 0 1rem;
            padding-top: 1rem;
        }

        .content h3 {
            font-size: 1.5rem;
            color: var(--accent);
            margin: 2rem 0 1rem;
        }

        .content h4 {
            font-size: 1.2rem;
            color: var(--accent);
            margin: 1.5rem 0 0.8rem;
        }

        .content p {
            margin: 1rem 0;
            color: var(--text);
        }

        .content ul, .content ol {
            margin: 1rem 0 1rem 2rem;
        }

        .content li {
            margin: 0.5rem 0;
        }

        .content blockquote {
            border-left: 4px solid var(--sage);
            background: var(--light-sage);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            font-style: italic;
            color: var(--text-light);
        }

        .content hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
        }

        /* Code Blocks */
        .content code {
            background: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--pine);
        }

        .code-block {
            margin: 1.5rem 0;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
            background: var(--code-bg);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--pine);
            color: var(--light-sage);
            font-size: 0.8rem;
        }

        .code-lang {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-weight: 600;
            text-transform: lowercase;
        }

        .copy-btn {
            background: transparent;
            border: 1px solid var(--sage);
            color: var(--light-sage);
            padding: 0.3rem 0.7rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .copy-btn:hover {
            background: var(--sage);
            color: var(--pine);
        }

        .copy-btn.copied {
            background: var(--sage);
            color: var(--pine);
            border-color: var(--sage);
        }

        .copy-btn svg {
            width: 14px;
            height: 14px;
        }

        .content pre {
            background: var(--code-bg);
            margin: 0;
            padding: 1.2rem;
            overflow-x: auto;
        }

        .content pre code {
            background: none;
            padding: 0;
            border-radius: 0;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        /* Standalone pre without code-block wrapper (legacy) */
        .content > pre {
            border: 1px solid var(--border);
            border-left: 4px solid var(--pine);
            border-radius: 4px;
            margin: 1.5rem 0;
        }

        /* Tables */
        .content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }

        .content th,
        .content td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .content th {
            background: var(--light-sage);
            color: var(--pine);
            font-weight: 600;
        }

        /* Links */
        .content a {
            color: var(--accent);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }

        .content a:hover {
            border-bottom-color: var(--accent);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--cream);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--sage);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* Section anchors */
        .section-anchor {
            scroll-margin-top: 90px;
        }

        /* Mobile adjustments */
        @media (max-width: 1023px) {
            .main-content {
                padding: 2rem 1rem;
            }

            .content h1 {
                font-size: 2rem;
            }

            .content h2 {
                font-size: 1.6rem;
            }

            .content h3 {
                font-size: 1.3rem;
            }
        }

        /* Page switching */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        /* Search */
        .search-container {
            position: relative;
            margin-right: 1rem;
        }

        .search-input {
            width: 200px;
            padding: 0.5rem 1rem;
            padding-left: 2.2rem;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .search-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.25);
            width: 280px;
        }

        .search-icon {
            position: absolute;
            left: 0.8rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
        }

        .search-results {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            right: 0;
            min-width: 320px;
            max-height: 400px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: none;
            z-index: 1001;
        }

        .search-results.active {
            display: block;
        }

        .search-result {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s;
        }

        .search-result:last-child {
            border-bottom: none;
        }

        .search-result:hover,
        .search-result.selected {
            background: var(--light-sage);
        }

        .search-result-title {
            font-weight: 600;
            color: var(--pine);
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
        }

        .search-result-section {
            font-size: 0.75rem;
            color: var(--text-light);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .search-result-preview {
            font-size: 0.85rem;
            color: var(--text-light);
            margin-top: 0.25rem;
            line-height: 1.4;
        }

        .search-result-preview mark {
            background: var(--sage);
            color: var(--pine);
            padding: 0 2px;
            border-radius: 2px;
        }

        .search-no-results {
            padding: 1rem;
            text-align: center;
            color: var(--text-light);
            font-size: 0.9rem;
        }

        .search-shortcut {
            display: none;
            margin-left: 0.5rem;
            padding: 0.15rem 0.4rem;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.8);
        }

        @media (min-width: 1024px) {
            .search-shortcut {
                display: inline-block;
            }
        }

        @media (max-width: 1023px) {
            .search-container {
                position: fixed;
                top: 70px;
                left: 0;
                right: 0;
                margin: 0;
                padding: 0.5rem;
                background: #1a2f2f;
                display: none;
                z-index: 999;
            }

            .search-container.active {
                display: block;
            }

            .search-input {
                width: 100%;
            }

            .search-input:focus {
                width: 100%;
            }

            .search-results {
                position: fixed;
                top: 120px;
                left: 0.5rem;
                right: 0.5rem;
                min-width: auto;
                max-height: calc(100vh - 140px);
            }

            .search-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
                background: transparent;
                border: none;
                color: white;
                font-size: 1.2rem;
                cursor: pointer;
                padding: 0.5rem;
                margin-left: auto;
            }
        }

        @media (min-width: 1024px) {
            .search-toggle {
                display: none;
            }
        }

        /* Theme Toggle */
        .theme-toggle {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            margin-left: 4px;
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .theme-toggle svg {
            width: 20px;
            height: 20px;
        }

        .theme-toggle .sun-icon {
            display: none;
        }

        .theme-toggle .moon-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .sun-icon {
            display: block;
        }

        [data-theme="dark"] .theme-toggle .moon-icon {
            display: none;
        }

        @media (prefers-color-scheme: dark) {
            :root:not([data-theme="light"]) .theme-toggle .sun-icon {
                display: block;
            }
            :root:not([data-theme="light"]) .theme-toggle .moon-icon {
                display: none;
            }
        }

        /* Language Switcher */
        .lang-switcher {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.4rem 0.4rem;
            border-radius: 8px;
            font-size: 0.85rem;
            cursor: pointer;
            outline: none;
        }

        .lang-switcher:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher:focus {
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lang-switcher option {
            background: var(--pine);
            color: white;
        }

        [data-theme="dark"] .lang-switcher option {
            background: var(--bg-primary);
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <button class="menu-toggle" id="menuToggle" aria-label="Toggle navigation menu" aria-expanded="false">&#9776;</button>
        <img src="data:image/png;base64,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" alt="Hemlock Logo" class="header-logo">
        <h1>Hemlock 语言手册</h1>
        <!-- Search -->
        <div class="search-container" id="searchContainer">
            <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
            <input type="text" class="search-input" id="searchInput" placeholder="Search docs..." autocomplete="off" aria-label="Search documentation">
            <span class="search-shortcut">Ctrl+K</span>
            <div class="search-results" id="searchResults" role="listbox" aria-label="Search results"></div>
        </div>
        <button class="search-toggle" id="searchToggle" aria-label="Toggle search">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="M21 21l-4.35-4.35"></path>
            </svg>
        </button>
        <select class="lang-switcher" id="langSwitcher" onchange="switchLanguage(this.value)" aria-label="Select language">
            <option value="docs.html" >English</option>
<option value="docs-zh.html" selected>中文</option>
<option value="docs-de.html" >Deutsch</option>
<option value="docs-es.html" >Español</option>
<option value="docs-fr.html" >Français</option>
<option value="docs-it.html" >Italiano</option>
<option value="docs-ja.html" >日本語</option>
<option value="docs-pt.html" >Português</option>
<option value="docs-ru.html" >Русский</option>
        </select>
        <button class="theme-toggle" id="themeToggle" title="Toggle dark mode" aria-label="Toggle dark mode">
            <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
            <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
        </button>
    </div>

    <!-- Container -->
    <div class="container">
        <!-- Sidebar Navigation -->
        <nav class="sidebar" id="sidebar" aria-label="Documentation navigation">
            <div class="nav-section">
<a href="#welcome" class="nav-link" data-page="welcome">欢迎</a>
</div>
<a href="#language-reference" class="nav-link" data-page="language-reference">语言参考</a>
<div class="nav-section">
<div class="nav-section-title">快速入门</div>
<a href="#getting-started-learning-paths" class="nav-link" data-page="getting-started-learning-paths">学习路径</a>
<a href="#getting-started-installation" class="nav-link" data-page="getting-started-installation">安装</a>
<a href="#getting-started-quick-start" class="nav-link" data-page="getting-started-quick-start">快速开始</a>
<a href="#getting-started-tutorial" class="nav-link" data-page="getting-started-tutorial">教程</a>
</div>
<div class="nav-section">
<div class="nav-section-title">语言指南</div>
<a href="#language-guide-memory" class="nav-link" data-page="language-guide-memory">内存管理</a>
<a href="#language-guide-functions" class="nav-link" data-page="language-guide-functions">函数</a>
<a href="#language-guide-runes" class="nav-link" data-page="language-guide-runes">字符(Rune)</a>
<a href="#language-guide-strings" class="nav-link" data-page="language-guide-strings">字符串</a>
<a href="#language-guide-objects" class="nav-link" data-page="language-guide-objects">对象</a>
<a href="#language-guide-control-flow" class="nav-link" data-page="language-guide-control-flow">控制流</a>
<a href="#language-guide-arrays" class="nav-link" data-page="language-guide-arrays">数组</a>
<a href="#language-guide-modules" class="nav-link" data-page="language-guide-modules">模块</a>
<a href="#language-guide-pattern-matching" class="nav-link" data-page="language-guide-pattern-matching">模式匹配</a>
<a href="#language-guide-types" class="nav-link" data-page="language-guide-types">类型</a>
<a href="#language-guide-syntax" class="nav-link" data-page="language-guide-syntax">语法</a>
<a href="#language-guide-error-handling" class="nav-link" data-page="language-guide-error-handling">错误处理</a>
</div>
<div class="nav-section">
<div class="nav-section-title">高级主题</div>
<a href="#advanced-ffi" class="nav-link" data-page="advanced-ffi">FFI</a>
<a href="#advanced-file-io" class="nav-link" data-page="advanced-file-io">File IO</a>
<a href="#advanced-memory-ownership" class="nav-link" data-page="advanced-memory-ownership">Memory Ownership</a>
<a href="#advanced-signals" class="nav-link" data-page="advanced-signals">信号处理</a>
<a href="#advanced-atomics" class="nav-link" data-page="advanced-atomics">原子操作</a>
<a href="#advanced-command-execution" class="nav-link" data-page="advanced-command-execution">命令执行</a>
<a href="#advanced-command-line-args" class="nav-link" data-page="advanced-command-line-args">命令行参数</a>
<a href="#advanced-async-concurrency" class="nav-link" data-page="advanced-async-concurrency">异步与并发</a>
<a href="#advanced-profiling" class="nav-link" data-page="advanced-profiling">性能分析</a>
<a href="#advanced-bundling-packaging" class="nav-link" data-page="advanced-bundling-packaging">打包与发布</a>
</div>
<div class="nav-section">
<div class="nav-section-title">API 参考</div>
<a href="#reference-memory-api" class="nav-link" data-page="reference-memory-api">内存 API</a>
<a href="#reference-builtins" class="nav-link" data-page="reference-builtins">内置函数</a>
<a href="#reference-string-api" class="nav-link" data-page="reference-string-api">字符串 API</a>
<a href="#reference-concurrency-api" class="nav-link" data-page="reference-concurrency-api">并发 API</a>
<a href="#reference-array-api" class="nav-link" data-page="reference-array-api">数组 API</a>
<a href="#reference-file-api" class="nav-link" data-page="reference-file-api">文件 API</a>
<a href="#reference-type-system" class="nav-link" data-page="reference-type-system">类型系统</a>
<a href="#reference-operators" class="nav-link" data-page="reference-operators">运算符</a>
</div>
<div class="nav-section">
<div class="nav-section-title">设计与理念</div>
<a href="#design-implementation" class="nav-link" data-page="design-implementation">实现细节</a>
<a href="#design-signature-syntax" class="nav-link" data-page="design-signature-syntax">签名语法</a>
<a href="#design-philosophy" class="nav-link" data-page="design-philosophy">设计理念</a>
</div>
<div class="nav-section">
<div class="nav-section-title">贡献指南</div>
<a href="#contributing-testing" class="nav-link" data-page="contributing-testing">测试</a>
<a href="#contributing-guidelines" class="nav-link" data-page="contributing-guidelines">贡献指南</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: 快速入门</div>
<a href="#hpm-installation" class="nav-link" data-page="hpm-installation">安装</a>
<a href="#hpm-quick-start" class="nav-link" data-page="hpm-quick-start">快速开始</a>
<a href="#hpm-project-setup" class="nav-link" data-page="hpm-project-setup">项目设置</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: 用户指南</div>
<a href="#hpm-commands" class="nav-link" data-page="hpm-commands">命令</a>
<a href="#hpm-troubleshooting" class="nav-link" data-page="hpm-troubleshooting">故障排除</a>
<a href="#hpm-configuration" class="nav-link" data-page="hpm-configuration">配置</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: 包开发</div>
<a href="#hpm-creating-packages" class="nav-link" data-page="hpm-creating-packages">创建包</a>
<a href="#hpm-package-spec" class="nav-link" data-page="hpm-package-spec">包规范</a>
<a href="#hpm-versioning" class="nav-link" data-page="hpm-versioning">版本控制</a>
</div>
<div class="nav-section">
<div class="nav-section-title">HPM: 参考</div>
<a href="#hpm-architecture" class="nav-link" data-page="hpm-architecture">架构</a>
<a href="#hpm-exit-codes" class="nav-link" data-page="hpm-exit-codes">退出码</a>
</div>
        </nav>

        <!-- Main Content -->
        <main class="main-content">
            <div class="content" id="content"></div>
        </main>
    </div>

    <script>
        // Embedded documentation pages
        const PAGES = {"欢迎": {"id": "welcome", "content": "# 欢迎使用 Hemlock\n\n> \"一门小巧的非安全语言，用于安全地编写不安全的东西。\"\n\n**Hemlock** 是一门系统级脚本语言，将 C 语言的强大功能与现代脚本的便捷性相结合。它具有手动内存管理、显式控制以及内置的结构化异步并发。\n\n## 什么是 Hemlock？\n\nHemlock 专为以下程序员设计：\n\n- **显式控制** 内存和执行流程\n- **类 C 语法** 配合现代便捷特性\n- **无隐藏行为** 或魔法\n- **真正的并行异步**，基于 pthread 的并发\n\nHemlock 不是一门带有垃圾回收的内存安全语言。相反，它为您提供安全工具（`buffer`、类型注解、边界检查），但不强制您使用它们（`ptr`、手动内存管理、不安全操作）。\n\n## 快速示例\n\n```hemlock\n// 你好，Hemlock！\nfn greet(name: string): string {\n    return `你好，${name}！`;\n}\n\nlet message = greet(\"世界\");\nprint(message);\n\n// 手动内存管理\nlet buf = buffer(64);\nbuf[0] = 72;  // 'H'\nbuf[1] = 105; // 'i'\nprint(buf);\nfree(buf);\n```\n\n## 功能概览\n\n| 功能 | 描述 |\n|------|------|\n| **类型系统** | i8-i64、u8-u64、f32/f64、bool、string、rune、ptr、buffer、array、object |\n| **内存** | 使用 `alloc()`、`buffer()`、`free()` 进行手动管理 |\n| **异步** | 内置 `async`/`await`，支持真正的 pthread 并行 |\n| **FFI** | 直接从共享库调用 C 函数 |\n| **标准库** | 40 个模块，包括 crypto、http、sqlite、json 等 |\n\n## 快速入门\n\n准备好开始了吗？以下是开始步骤：\n\n1. **[安装](#getting-started-installation)** - 下载并设置 Hemlock\n2. **[快速开始](#getting-started-quick-start)** - 几分钟内编写您的第一个程序\n3. **[教程](#getting-started-tutorial)** - 逐步学习 Hemlock\n\n## 文档章节\n\n- **快速入门** - 安装、快速开始指南和教程\n- **语言指南** - 深入了解语法、类型、函数等\n- **高级主题** - 异步编程、FFI、信号和原子操作\n- **API 参考** - 内置函数和标准库的完整参考\n- **设计与理念** - 理解 Hemlock 为何如此设计\n\n## 包管理器\n\nHemlock 自带 **hpm** 包管理器，用于管理依赖：\n\n```bash\nhpm init my-project\nhpm add some-package\nhpm run\n```\n\n请参阅 hpm 文档章节了解更多详情。\n\n---\n\n使用左侧导航浏览文档，或使用搜索栏查找特定主题。\n"}, "语言参考": {"id": "language-reference", "content": "# Hemlock 语言设计理念\n\n> \"一门小巧、非安全的语言，用于安全地编写非安全代码。\"\n\n本文档概述了 Hemlock 的设计理念，并提供语言快速参考。\n请浏览其他文档章节，获取详细指南和 API 参考。\n\n---\n\n## 核心定位\n\nHemlock 是一门**系统脚本语言**，具有手动内存管理和显式控制：\n- 拥有 C 语言的能力，同时具备现代脚本的便利性\n- 内置结构化异步并发\n- 无隐藏行为或魔法\n\n**Hemlock 不是：** 内存安全的、带垃圾回收的语言，也不会隐藏复杂性。\n**Hemlock 是：** 显式优于隐式、具有教育意义、系统工作的\"C 脚本层\"。\n\n---\n\n## 设计原则\n\n### 1. 显式优于隐式\n- 分号是强制性的（无自动分号插入）\n- 手动内存管理（alloc/free）\n- 类型注解可选，但在运行时检查\n\n### 2. 默认动态，可选类型\n- 每个值都有运行时类型标签\n- 字面量推断类型：`42` → i32，`5000000000` → i64，`3.14` → f64\n- 可选的类型注解强制执行运行时检查\n\n### 3. 非安全是特性\n- 允许指针运算（用户自行负责）\n- 原始 `ptr` 无边界检查（使用 `buffer` 获得安全性）\n- 允许双重释放导致崩溃\n\n### 4. 结构化并发是一等公民\n- 内置 `async`/`await`，基于 pthread 的并行\n- 用于通信的 channel\n- `spawn`/`join`/`detach` 用于任务管理\n\n### 5. 类 C 语法\n- `{}` 块总是必需的\n- 注释：`// 行注释` 和 `/* 块注释 */`\n- 运算符与 C 一致：`+`、`-`、`*`、`%`、`&&`、`||`、`!`、`&`、`|`、`^`、`<<`、`>>`\n- 自增/自减：`++x`、`x++`、`--x`、`x--`（前缀和后缀）\n- 复合赋值：`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`|=`、`^=`、`<<=`、`>>=`\n- `/` 总是返回浮点数（使用 `divi()` 进行整数除法）\n- 类型语法：`let x: type = value;`\n\n---\n\n## 快速参考\n\n### 类型\n```\n有符号：  i8, i16, i32, i64\n无符号：  u8, u16, u32, u64\n浮点：    f32, f64\n其他：    bool, string, rune, array, ptr, buffer, null, object, file, task, channel\n别名：    integer (i32), number (f64), byte (u8)\n```\n\n**类型提升：** i8 → i16 → i32 → i64 → f32 → f64（浮点总是赢，但 i64/u64 + f32 → f64 以保持精度）\n\n### 字面量\n```hemlock\nlet x = 42;              // i32\nlet big = 5000000000;    // i64 (> i32 最大值)\nlet hex = 0xDEADBEEF;    // 十六进制字面量\nlet bin = 0b1010;        // 二进制字面量\nlet oct = 0o777;         // 八进制字面量\nlet sep = 1_000_000;     // 允许数字分隔符\nlet pi = 3.14;           // f64\nlet half = .5;           // f64 (无前导零)\nlet s = \"hello\";         // string\nlet esc = \"\\x41\\u{1F600}\"; // 十六进制和 Unicode 转义\nlet ch = 'A';            // rune\nlet emoji = '🚀';        // rune (Unicode)\nlet arr = [1, 2, 3];     // array\nlet obj = { x: 10 };     // object\n```\n\n### 类型转换\n```hemlock\n// 类型构造函数 - 将字符串解析为类型\nlet n = i32(\"42\");       // 将字符串解析为 i32\nlet f = f64(\"3.14\");     // 将字符串解析为 f64\nlet b = bool(\"true\");    // 将字符串解析为 bool (\"true\" 或 \"false\")\n\n// 支持所有数值类型\nlet a = i8(\"-128\");      // i8, i16, i32, i64\nlet c = u8(\"255\");       // u8, u16, u32, u64\nlet d = f32(\"1.5\");      // f32, f64\n\n// 十六进制和负数\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\n\n// 类型别名也适用\nlet x = integer(\"100\");  // 等同于 i32(\"100\")\nlet y = number(\"1.5\");   // 等同于 f64(\"1.5\")\nlet z = byte(\"200\");     // 等同于 u8(\"200\")\n\n// 数值类型之间的转换\nlet big = i64(42);       // i32 转 i64\nlet truncated = i32(3.99); // f64 转 i32 (截断为 3)\n\n// 类型注解验证类型（但不解析字符串）\nlet f: f64 = 100;        // 通过注解将 i32 转为 f64（数值强制转换可行）\n// let n: i32 = \"42\";    // 错误 - 使用 i32(\"42\") 解析字符串\n```\n\n### 内省\n```hemlock\ntypeof(42);              // \"i32\"\ntypeof(\"hello\");         // \"string\"\ntypeof([1, 2, 3]);       // \"array\"\ntypeof(null);            // \"null\"\nlen(\"hello\");            // 5 (字符串字节长度)\nlen([1, 2, 3]);          // 3 (数组长度)\n```\n\n### 内存\n```hemlock\nlet p = alloc(64);       // 原始指针\nlet b = buffer(64);      // 安全缓冲区（边界检查）\nmemset(p, 0, 64);\nmemcpy(dest, src, 64);\nfree(p);                 // 需要手动清理\n```\n\n### 控制流\n```hemlock\nif (x > 0) { } else if (x < 0) { } else { }\nwhile (cond) { break; continue; }\nfor (let i = 0; i < 10; i++) { }\nfor (item in array) { }\nloop { if (done) { break; } }   // 无限循环（比 while(true) 更清晰）\nswitch (x) { case 1: break; default: break; }  // C 风格贯穿\ndefer cleanup();         // 函数返回时执行\n\n// 循环标签用于嵌套循环中的定向 break/continue\nouter: while (cond) {\n    inner: for (let i = 0; i < 10; i++) {\n        if (i == 5) { break outer; }     // 跳出外层循环\n        if (i == 3) { continue outer; }  // 继续外层循环\n    }\n}\n```\n\n### 模式匹配\n```hemlock\n// match 表达式 - 返回值\nlet result = match (value) {\n    0 => \"zero\",                    // 字面量模式\n    1 | 2 | 3 => \"small\",           // OR 模式\n    n if n < 10 => \"medium\",        // 守卫表达式\n    n => \"large: \" + n              // 变量绑定\n};\n\n// 类型模式\nmatch (val) {\n    n: i32 => \"integer\",\n    s: string => \"string\",\n    _ => \"other\"                    // 通配符\n}\n\n// 对象解构\nmatch (point) {\n    { x: 0, y: 0 } => \"origin\",\n    { x, y } => \"at \" + x + \",\" + y\n}\n\n// 带剩余部分的数组解构\nmatch (arr) {\n    [] => \"empty\",\n    [first, ...rest] => \"head: \" + first,\n    _ => \"other\"\n}\n\n// 嵌套模式\nmatch (user) {\n    { name, address: { city } } => name + \" in \" + city\n}\n```\n\n完整文档请参阅 `docs/language-guide/pattern-matching.md`。\n\n### 空值合并运算符\n```hemlock\n// 空值合并 (??) - 如果左侧非空则返回左侧，否则返回右侧\nlet name = user.name ?? \"Anonymous\";\nlet first = a ?? b ?? c ?? \"fallback\";\n\n// 空值合并赋值 (??=) - 仅当为空时赋值\nlet config = null;\nconfig ??= { timeout: 30 };    // config 现在是 { timeout: 30 }\nconfig ??= { timeout: 60 };    // config 不变（非空）\n\n// 适用于属性和索引\nobj.field ??= \"default\";\narr[0] ??= \"first\";\n\n// 安全导航 (?.) - 如果对象为空则返回 null\nlet city = user?.address?.city;  // 如果任何部分为空则为 null\nlet upper = name?.to_upper();    // 安全方法调用\nlet item = arr?.[0];             // 安全索引\n```\n\n### 函数\n```hemlock\nfn add(a: i32, b: i32): i32 { return a + b; }\nfn greet(name: string, msg?: \"Hello\") { print(msg + \" \" + name); }\nlet f = fn(x) { return x * 2; };  // 匿名/闭包\n\n// 表达式体函数（箭头语法）\nfn double(x: i32): i32 => x * 2;\nfn max(a: i32, b: i32): i32 => a > b ? a : b;\nlet square = fn(x: i32): i32 => x * x;  // 匿名表达式体\n\n// 参数修饰符\nfn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // 按引用传递\nfn print_all(const items: array) { for (i in items) { print(i); } }  // 不可变\n```\n\n### 命名参数\n```hemlock\n// 函数可以使用命名参数调用\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" is \" + age + \" years old\");\n}\n\n// 位置参数（传统方式）\ncreate_user(\"Alice\", 25, false);\n\n// 命名参数 - 可以任意顺序\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n\n// 通过命名所需参数来跳过可选参数\ncreate_user(\"David\", active: false);  // 使用默认 age=18\n\n// 命名参数必须在位置参数之后\ncreate_user(\"Eve\", age: 21);          // 正确：位置参数在前，命名参数在后\n// create_user(name: \"Bad\", 25);      // 错误：位置参数在命名参数之后\n```\n\n**规则：**\n- 命名参数使用 `name: value` 语法\n- 可以在位置参数之后以任意顺序出现\n- 位置参数不能跟在命名参数之后\n- 与默认/可选参数配合使用\n- 未知参数名会导致运行时错误\n\n### 对象和枚举\n```hemlock\ndefine Person { name: string, age: i32, active?: true }\nlet p: Person = { name: \"Alice\", age: 30 };\nlet json = p.serialize();\nlet restored = json.deserialize();\n\n// 对象简写语法（ES6 风格）\nlet name = \"Alice\";\nlet age = 30;\nlet person = { name, age };         // 等同于 { name: name, age: age }\n\n// 对象展开运算符\nlet defaults = { theme: \"dark\", size: \"medium\" };\nlet config = { ...defaults, size: \"large\" };  // 复制 defaults，覆盖 size\n\nenum Color { RED, GREEN, BLUE }\nenum Status { OK = 0, ERROR = 1 }\n```\n\n### 复合类型（交叉/鸭子类型）\n```hemlock\n// 定义结构类型\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// 复合类型：对象必须满足所有类型\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// 带复合类型的函数参数\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" is \" + p.age);\n}\n\n// 三个或更多类型\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n\n// 允许额外字段（鸭子类型）\nlet employee: HasName & HasAge = {\n    name: \"Bob\",\n    age: 25,\n    department: \"Engineering\"  // 正确 - 额外字段被忽略\n};\n```\n\n复合类型提供类似接口的行为，无需单独的 `interface` 关键字，\n构建在现有的 `define` 和鸭子类型范式之上。\n\n### 类型别名\n```hemlock\n// 简单类型别名\ntype Integer = i32;\ntype Text = string;\n\n// 函数类型别名\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// 复合类型别名（适合可重用接口）\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// 泛型类型别名\ntype Pair<T> = { first: T, second: T };\n\n// 使用类型别名\nlet x: Integer = 42;\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\n类型别名为复杂类型创建命名快捷方式，提高可读性和可维护性。\n\n### 函数类型\n```hemlock\n// 函数类型注解用于参数\nfn apply_fn(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// 返回函数的高阶函数\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// 异步函数类型\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n\n// 多参数函数类型\ntype BinaryOp = fn(i32, i32): i32;\nlet add: BinaryOp = fn(a, b) { return a + b; };\n```\n\n### Const 参数\n```hemlock\n// Const 参数 - 深度不可变性\nfn print_all(const items: array) {\n    // items.push(4);  // 错误：无法修改 const 参数\n    for (item in items) {\n        print(item);\n    }\n}\n\n// 对象的 const - 无法通过任何路径修改\nfn describe(const person: object) {\n    print(person.name);       // 正确：允许读取\n    // person.name = \"Bob\";   // 错误：无法修改\n}\n\n// 允许嵌套读取访问\nfn get_city(const user: object) {\n    return user.address.city;  // 正确：读取嵌套属性\n}\n```\n\n`const` 修饰符防止对参数的任何修改，包括嵌套属性。\n这为不应修改其输入的函数提供了编译时安全性。\n\n### Ref 参数（按引用传递）\n```hemlock\n// Ref 参数 - 直接修改调用者的变量\nfn increment(ref x: i32) {\n    x = x + 1;  // 修改原始变量\n}\n\nlet count = 10;\nincrement(count);\nprint(count);  // 11 - 原始值已修改\n\n// 经典交换函数\nfn swap(ref a: i32, ref b: i32) {\n    let temp = a;\n    a = b;\n    b = temp;\n}\n\nlet x = 1;\nlet y = 2;\nswap(x, y);\nprint(x, y);  // 2 1\n\n// 混合 ref 和普通参数\nfn add_to(ref target: i32, amount: i32) {\n    target = target + amount;\n}\n\nlet total = 100;\nadd_to(total, 50);\nprint(total);  // 150\n```\n\n`ref` 修饰符传递对调用者变量的引用，允许函数直接修改它。\n没有 `ref` 时，原始类型按值传递（复制）。当需要在不返回值的情况下\n修改调用者状态时，使用 `ref`。\n\n**规则：**\n- `ref` 参数必须传递变量，不能是字面量或表达式\n- 适用于所有类型（原始类型、数组、对象）\n- 与类型注解结合：`ref x: i32`\n- 不能与 `const` 结合（它们是对立的）\n\n### Define 中的方法签名\n```hemlock\n// 带方法签名的 define（接口模式）\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32   // 必需的方法签名\n}\n\n// 对象必须提供必需的方法\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// 使用 ? 表示可选方法\ndefine Serializable {\n    fn serialize(): string,        // 必需\n    fn pretty?(): string           // 可选方法\n}\n\n// Self 类型指向定义类型\ndefine Cloneable {\n    fn clone(): Self   // 返回与对象相同的类型\n}\n```\n\n`define` 块中的方法签名使用逗号分隔（类似 TypeScript 接口），\n建立对象必须满足的契约，并通过 Hemlock 的鸭子类型系统实现\n类似接口的编程模式。\n\n### 错误处理\n```hemlock\ntry { throw \"error\"; } catch (e) { print(e); } finally { cleanup(); }\npanic(\"unrecoverable\");  // 立即退出，不可捕获\n```\n\n### 异步/并发\n```hemlock\nasync fn compute(n: i32): i32 { return n * n; }\nlet task = spawn(compute, 42);\nlet result = await task;     // 或 join(task)\ndetach(spawn(background_work));\n\nlet ch = channel(10);\nch.send(value);\nlet val = ch.recv();\nch.close();\n```\n\n**内存所有权：** 任务接收原始值的副本，但共享指针。如果将 `ptr` 传递给派生任务，\n必须确保内存在任务完成前保持有效。在 `free()` 之前使用 `join()`，\n或使用 channel 信号通知完成。\n\n### 用户输入\n```hemlock\nlet name = read_line();          // 从 stdin 读取行（阻塞）\nprint(\"Hello, \" + name);\neprint(\"Error message\");         // 输出到 stderr\n\n// read_line() 在 EOF 时返回 null\nwhile (true) {\n    let line = read_line();\n    if (line == null) { break; }\n    print(\"Got:\", line);\n}\n```\n\n### 文件 I/O\n```hemlock\nlet f = open(\"file.txt\", \"r\");  // 模式：r, w, a, r+, w+, a+\nlet content = f.read();\nf.write(\"data\");\nf.seek(0);\nf.close();\n```\n\n### 信号\n```hemlock\nsignal(SIGINT, fn(sig) { print(\"Interrupted\"); });\nraise(SIGUSR1);\n```\n\n---\n\n## 字符串方法 (19 个)\n\n`substr`、`slice`、`find`、`contains`、`split`、`trim`、`to_upper`、`to_lower`、\n`starts_with`、`ends_with`、`replace`、`replace_all`、`repeat`、`char_at`、\n`byte_at`、`chars`、`bytes`、`to_bytes`、`deserialize`\n\n模板字符串：`` `Hello ${name}!` ``\n\n**字符串可变性：** 字符串可通过索引赋值修改（`s[0] = 'H'`），但所有字符串方法\n返回新字符串而不修改原字符串。这允许在需要时进行原地修改，同时保持方法链的函数式风格。\n\n**字符串长度属性：**\n```hemlock\nlet s = \"hello 🚀\";\nprint(s.length);       // 7 (字符/rune 计数)\nprint(s.byte_length);  // 10 (字节计数 - emoji 是 4 字节 UTF-8)\n```\n\n## 数组方法 (18 个)\n\n`push`、`pop`、`shift`、`unshift`、`insert`、`remove`、`find`、`contains`、\n`slice`、`join`、`concat`、`reverse`、`first`、`last`、`clear`、`map`、`filter`、`reduce`\n\n类型化数组：`let nums: array<i32> = [1, 2, 3];`\n\n---\n\n## 标准库 (40 个模块)\n\n使用 `@stdlib/` 前缀导入：\n```hemlock\nimport { sin, cos, PI } from \"@stdlib/math\";\nimport { HashMap, Queue, Set } from \"@stdlib/collections\";\nimport { read_file, write_file } from \"@stdlib/fs\";\nimport { TcpStream, UdpSocket } from \"@stdlib/net\";\n```\n\n| 模块 | 描述 |\n|--------|-------------|\n| `arena` | 竞技场内存分配器（bump 分配） |\n| `args` | 命令行参数解析 |\n| `assert` | 断言工具 |\n| `async` | ThreadPool、parallel_map |\n| `async_fs` | 异步文件 I/O 操作 |\n| `collections` | HashMap、Queue、Stack、Set、LinkedList、LRUCache |\n| `compression` | gzip、gunzip、deflate |\n| `crypto` | aes_encrypt、rsa_sign、random_bytes |\n| `csv` | CSV 解析和生成 |\n| `datetime` | DateTime 类、格式化、解析 |\n| `encoding` | base64_encode、hex_encode、url_encode |\n| `env` | getenv、setenv、exit、get_pid |\n| `fmt` | 字符串格式化工具 |\n| `fs` | read_file、write_file、list_dir、exists |\n| `glob` | 文件模式匹配 |\n| `hash` | sha256、sha512、md5、djb2 |\n| `http` | http_get、http_post、http_request |\n| `ipc` | 进程间通信 |\n| `iter` | 迭代器工具 |\n| `json` | parse、stringify、pretty、get、set |\n| `logging` | 带级别的日志记录器 |\n| `math` | sin、cos、sqrt、pow、rand、PI、E |\n| `net` | TcpListener、TcpStream、UdpSocket |\n| `os` | platform、arch、cpu_count、hostname |\n| `path` | 文件路径操作 |\n| `process` | fork、exec、wait、kill |\n| `random` | 随机数生成 |\n| `regex` | compile、test (POSIX ERE) |\n| `retry` | 带退避的重试逻辑 |\n| `semver` | 语义化版本控制 |\n| `shell` | Shell 命令工具 |\n| `sqlite` | SQLite 数据库、query、exec、事务 |\n| `strings` | pad_left、is_alpha、reverse、lines |\n| `terminal` | ANSI 颜色和样式 |\n| `testing` | describe、test、expect |\n| `time` | now、time_ms、sleep、clock |\n| `toml` | TOML 解析和生成 |\n| `url` | URL 解析和操作 |\n| `uuid` | UUID 生成 |\n| `websocket` | WebSocket 客户端 |\n\n详细模块文档请参阅 `stdlib/docs/`。\n\n---\n\n## FFI（外部函数接口）\n\n从共享库声明和调用 C 函数：\n```hemlock\nimport \"libc.so.6\";\n\nextern fn strlen(s: string): i32;\nextern fn getpid(): i32;\n\nlet len = strlen(\"Hello!\");  // 6\nlet pid = getpid();\n```\n\n从模块导出 FFI 函数：\n```hemlock\n// string_utils.hml\nimport \"libc.so.6\";\n\nexport extern fn strlen(s: string): i32;\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n```\n\n动态 FFI（运行时绑定）：\n```hemlock\nlet lib = ffi_open(\"libc.so.6\");\nlet puts = ffi_bind(lib, \"puts\", [FFI_POINTER], FFI_INT);\nputs(\"Hello from C!\");\nffi_close(lib);\n```\n\n类型：`FFI_INT`、`FFI_DOUBLE`、`FFI_POINTER`、`FFI_STRING`、`FFI_VOID` 等。\n\n---\n\n## 原子操作\n\n使用原子操作进行无锁并发编程：\n\n```hemlock\n// 为原子 i32 分配内存\nlet p = alloc(4);\nptr_write_i32(p, 0);\n\n// 原子加载/存储\nlet val = atomic_load_i32(p);        // 原子读取\natomic_store_i32(p, 42);             // 原子写入\n\n// 获取并修改操作（返回旧值）\nlet old = atomic_add_i32(p, 10);     // 加法，返回旧值\nold = atomic_sub_i32(p, 5);          // 减法，返回旧值\nold = atomic_and_i32(p, 0xFF);       // 按位与\nold = atomic_or_i32(p, 0x10);        // 按位或\nold = atomic_xor_i32(p, 0x0F);       // 按位异或\n\n// 比较并交换 (CAS)\nlet success = atomic_cas_i32(p, 42, 100);  // 如果 *p == 42，设置为 100\n// 如果交换成功返回 true，否则返回 false\n\n// 原子交换\nold = atomic_exchange_i32(p, 999);   // 交换，返回旧值\n\nfree(p);\n\n// 可用 i64 变体 (atomic_load_i64, atomic_add_i64, 等)\n\n// 内存屏障（完全屏障）\natomic_fence();\n```\n\n所有操作使用顺序一致性（`memory_order_seq_cst`）。\n\n---\n\n## 项目结构\n\n```\nhemlock/\n├── src/\n│   ├── frontend/         # 共享：词法分析器、解析器、AST、模块\n│   ├── backends/\n│   │   ├── interpreter/  # hemlock：树遍历解释器\n│   │   └── compiler/     # hemlockc：C 代码生成器\n│   ├── tools/\n│   │   ├── lsp/          # 语言服务器协议\n│   │   └── bundler/      # 打包/包工具\n├── runtime/              # 编译程序运行时 (libhemlock_runtime.a)\n├── stdlib/               # 标准库 (40 个模块)\n│   └── docs/             # 模块文档\n├── docs/                 # 完整文档\n│   ├── language-guide/   # 类型、字符串、数组等\n│   ├── reference/        # API 参考\n│   └── advanced/         # 异步、FFI、信号等\n├── tests/                # 625+ 测试\n└── examples/             # 示例程序\n```\n\n---\n\n## 代码风格指南\n\n### 常量和魔法数字\n\n在向 C 代码库添加数值常量时，请遵循以下准则：\n\n1. **在 `include/hemlock_limits.h` 中定义常量** - 此文件是所有编译时和运行时限制、容量和命名常量的集中位置。\n\n2. **使用 `HML_` 前缀的描述性名称** - 所有常量应以 `HML_` 为前缀以明确命名空间。\n\n3. **避免魔法数字** - 用命名常量替换硬编码的数值。示例：\n   - 类型范围限制：`HML_I8_MIN`、`HML_I8_MAX`、`HML_U32_MAX`\n   - 缓冲区容量：`HML_INITIAL_ARRAY_CAPACITY`、`HML_INITIAL_LEXER_BUFFER_CAPACITY`\n   - 时间转换：`HML_NANOSECONDS_PER_SECOND`、`HML_MILLISECONDS_PER_SECOND`\n   - 哈希种子：`HML_DJB2_HASH_SEED`\n   - ASCII 值：`HML_ASCII_CASE_OFFSET`、`HML_ASCII_PRINTABLE_START`\n\n4. **包含 `hemlock_limits.h`** - 源文件应包含此头文件（通常通过 `internal.h`）以访问常量。\n\n5. **记录用途** - 添加注释说明每个常量代表什么。\n\n---\n\n## 禁止事项\n\n- 添加隐式行为（ASI、GC、自动清理）\n- 隐藏复杂性（魔法优化、隐藏引用计数）\n- 破坏现有语义（分号、手动内存、可变字符串）\n- 在隐式转换中丢失精度\n- 使用魔法数字 - 改为在 `hemlock_limits.h` 中定义命名常量\n\n---\n\n## 测试\n\n```bash\nmake test              # 运行解释器测试\nmake test-compiler     # 运行编译器测试\nmake parity            # 运行对等测试（两者必须匹配）\nmake test-all          # 运行所有测试套件\n```\n\n**重要：** 由于异步/并发问题，测试可能会挂起。运行测试时始终使用超时：\n```bash\ntimeout 60 make test   # 60 秒超时\ntimeout 120 make parity\n```\n\n测试类别：primitives、memory、strings、arrays、functions、objects、async、ffi、defer、signals、switch、bitwise、typed_arrays、modules、stdlib_*\n\n---\n\n## 编译器/解释器架构\n\nHemlock 有两个共享通用前端的执行后端：\n\n```\n源码 (.hml)\n    ↓\n┌─────────────────────────────┐\n│  共享前端                    │\n│  - 词法分析器 (src/frontend/)│\n│  - 解析器 (src/frontend/)    │\n│  - AST (src/frontend/)       │\n└─────────────────────────────┘\n    ↓                    ↓\n┌────────────┐    ┌────────────┐\n│   解释器    │    │   编译器    │\n│ (hemlock)  │    │ (hemlockc) │\n│            │    │            │\n│ 树遍历     │    │ 类型检查   │\n│ 求值       │    │ AST → C    │\n│            │    │ gcc 链接   │\n└────────────┘    └────────────┘\n```\n\n### 编译器类型检查\n\n编译器（`hemlockc`）包含编译时类型检查，**默认启用**：\n\n```bash\nhemlockc program.hml -o program    # 类型检查，然后编译\nhemlockc --check program.hml       # 仅类型检查，不编译\nhemlockc --no-type-check prog.hml  # 禁用类型检查\nhemlockc --strict-types prog.hml   # 对隐式 'any' 类型发出警告\n```\n\n类型检查器：\n- 在编译时验证类型注解\n- 将无类型代码视为动态（`any` 类型）- 始终有效\n- 为拆箱提供优化提示\n- 使用宽松的数值转换（范围在运行时验证）\n\n### 目录结构\n\n```\nhemlock/\n├── src/\n│   ├── frontend/           # 共享：词法分析器、解析器、AST、模块\n│   │   ├── lexer.c\n│   │   ├── parser/\n│   │   ├── ast.c\n│   │   └── module.c\n│   ├── backends/\n│   │   ├── interpreter/    # hemlock：树遍历解释器\n│   │   │   ├── main.c\n│   │   │   ├── runtime/\n│   │   │   └── builtins/\n│   │   └── compiler/       # hemlockc：C 代码生成器\n│   │       ├── main.c\n│   │       └── codegen/\n│   ├── tools/\n│   │   ├── lsp/            # 语言服务器\n│   │   └── bundler/        # 打包/包工具\n├── runtime/                # 编译程序的 libhemlock_runtime.a\n├── stdlib/                 # 共享标准库\n└── tests/\n    ├── parity/             # 必须通过两个后端的测试\n    ├── interpreter/        # 解释器特定测试\n    └── compiler/           # 编译器特定测试\n```\n\n---\n\n## 对等优先开发\n\n**解释器和编译器必须对相同输入产生相同输出。**\n\n### 开发策略\n\n添加或修改语言特性时：\n\n1. **设计** - 在共享前端定义 AST/语义更改\n2. **实现解释器** - 添加树遍历求值\n3. **实现编译器** - 添加 C 代码生成\n4. **添加对等测试** - 在 `tests/parity/` 中编写带 `.expected` 文件的测试\n5. **验证** - 合并前运行 `make parity`\n\n### 对等测试结构\n\n```\ntests/parity/\n├── language/       # 核心语言特性（控制流、闭包等）\n├── builtins/       # 内置函数（print、typeof、memory 等）\n├── methods/        # 字符串和数组方法\n└── modules/        # import/export、stdlib 导入\n```\n\n每个测试有两个文件：\n- `feature.hml` - 测试程序\n- `feature.expected` - 预期输出（两个后端必须匹配）\n\n### 对等测试结果\n\n| 状态 | 含义 |\n|--------|---------|\n| `PASSED` | 解释器和编译器都匹配预期输出 |\n| `INTERP_ONLY` | 解释器工作，编译器失败（需要修复编译器） |\n| `COMPILER_ONLY` | 编译器工作，解释器失败（罕见） |\n| `FAILED` | 两者都失败（测试或实现错误） |\n\n### 需要对等的内容\n\n- 所有语言结构（if、while、for、switch、defer、try/catch）\n- 所有运算符（算术、位、逻辑、比较）\n- 所有内置函数（print、typeof、alloc 等）\n- 所有字符串和数组方法\n- 类型强制和提升规则\n- 运行时错误的错误消息\n\n### 可能不同的内容\n\n- 性能特征\n- 内存布局细节\n- 调试/堆栈跟踪格式\n- 编译错误（编译器可能在编译时捕获更多）\n\n### 添加对等测试\n\n```bash\n# 1. 创建测试文件\ncat > tests/parity/language/my_feature.hml << 'EOF'\n// 测试描述\nlet x = some_feature();\nprint(x);\nEOF\n\n# 2. 从解释器生成预期输出\n./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected\n\n# 3. 验证对等\nmake parity\n```\n\n---\n\n## 版本\n\n**v1.8.0** - 当前版本特性：\n- **模式匹配**（`match` 表达式）- 强大的解构和控制流：\n  - 字面量、通配符和变量绑定模式\n  - OR 模式（`1 | 2 | 3`）\n  - 守卫表达式（`n if n > 0`）\n  - 对象解构（`{ x, y }`）\n  - 带剩余部分的数组解构（`[first, ...rest]`）\n  - 类型模式（`n: i32`）\n  - 解释器和编译器完全对等\n- **编译器辅助注解** - 11 个用于 GCC/Clang 控制的优化注解：\n  - `@inline`、`@noinline` - 函数内联控制\n  - `@hot`、`@cold` - 分支预测提示\n  - `@pure`、`@const` - 副作用注解\n  - `@flatten` - 内联函数内的所有调用\n  - `@optimize(level)` - 每函数优化级别（\"0\"、\"1\"、\"2\"、\"3\"、\"s\"、\"fast\"）\n  - `@warn_unused` - 忽略返回值时警告\n  - `@section(name)` - 自定义 ELF 节放置（例如 `@section(\".text.hot\")`）\n- **表达式体函数**（`fn double(x): i32 => x * 2;`）- 简洁的单表达式函数语法\n- **单行语句** - 无花括号的 `if`、`while`、`for` 语法（例如 `if (x > 0) print(x);`）\n- **类型别名**（`type Name = Type;`）- 复杂类型的命名快捷方式\n- **函数类型注解**（`fn(i32): i32`）- 一等函数类型\n- **Const 参数**（`fn(const x: array)`）- 参数的深度不可变性\n- **Ref 参数**（`fn(ref x: i32)`）- 按引用传递用于直接修改调用者\n- **define 中的方法签名**（`fn method(): Type`）- 类似接口的契约（逗号分隔）\n- 方法签名中的 **Self 类型** - 指向定义类型\n- **loop 关键字**（`loop { }`）- 更清晰的无限循环，替代 `while (true)`\n- **循环标签**（`outer: while`）- 嵌套循环的定向 break/continue\n- **对象简写**（`{ name }`）- ES6 风格简写属性语法\n- **对象展开**（`{ ...obj }`）- 复制和合并对象字段\n- **复合鸭子类型**（`A & B & C`）- 结构类型的交叉类型\n- 函数调用的**命名参数**（`foo(name: \"value\", age: 30)`）\n- **空值合并运算符**（`??`、`??=`、`?.`）用于安全的空值处理\n- **八进制字面量**（`0o777`、`0O123`）\n- **数字分隔符**（`1_000_000`、`0xFF_FF`、`0b1111_0000`）\n- **块注释**（`/* ... */`）\n- 字符串/rune 中的**十六进制转义序列**（`\\x41` = 'A'）\n- 字符串中的 **Unicode 转义序列**（`\\u{1F600}` = 😀）\n- **无前导零的浮点字面量**（`.5`、`.123`、`.5e2`）\n- hemlockc 中的**编译时类型检查**（默认启用）\n- **LSP 集成**，带实时诊断的类型检查\n- **复合赋值运算符**（`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`|=`、`^=`、`<<=`、`>>=`）\n- **自增/自减运算符**（`++x`、`x++`、`--x`、`x--`）\n- **类型精度修复**：i64/u64 + f32 → f64 以保持精度\n- 带拆箱优化提示的统一类型系统\n- 完整类型系统（i8-i64、u8-u64、f32/f64、bool、string、rune、ptr、buffer、array、object、enum、file、task、channel）\n- 带 19 个方法的 UTF-8 字符串\n- 带 18 个方法的数组，包括 map/filter/reduce\n- 带 `talloc()` 和 `sizeof()` 的手动内存管理\n- 带真正 pthread 并行的 async/await\n- 用于无锁并发编程的原子操作\n- 40 个 stdlib 模块（+ arena、assert、semver、toml、retry、iter、random、shell）\n- C 互操作的 FFI，带 `export extern fn` 用于可重用库包装\n- 编译器中的 FFI 结构支持（按值传递 C 结构）\n- FFI 指针辅助函数（`ptr_null`、`ptr_read_*`、`ptr_write_*`）\n- defer、try/catch/finally/throw、panic\n- 文件 I/O、信号处理、命令执行\n- [hpm](https://github.com/hemlang/hpm) 包管理器，带基于 GitHub 的注册表\n- 编译器后端（C 代码生成），100% 解释器对等\n- LSP 服务器，带跳转到定义和查找引用\n- AST 优化遍历和 O(1) 查找的变量解析\n- apply() 内置函数用于动态函数调用\n- 无缓冲 channel 和多参数支持\n- 159 个对等测试（100% 通过率）\n\n---\n\n## 理念\n\n> 我们提供安全的工具（`buffer`、类型注解、边界检查），但不强制你使用它们（`ptr`、手动内存、非安全操作）。\n\n**如果你不确定某个特性是否适合 Hemlock，请问自己：\"这是给程序员更多显式控制，还是隐藏了什么？\"**\n\n如果是隐藏，它可能不属于 Hemlock。\n"}, "快速入门 -> 学习路径": {"id": "getting-started-learning-paths", "content": "# 学习路径\n\n不同的目标需要不同的知识。选择与您想要构建的内容相匹配的路径。\n\n---\n\n## 路径 1：快速脚本和自动化\n\n**目标：** 编写脚本来自动化任务、处理文件并完成工作。\n\n**达到生产力的时间：** 很快 - 您可以立即开始编写有用的脚本。\n\n### 您将学到的内容\n\n1. **[快速入门](#getting-started-quick-start)** - 您的第一个程序，基本语法\n2. **[字符串](#language-guide-strings)** - 文本处理、分割、搜索\n3. **[数组](#language-guide-arrays)** - 列表、过滤、转换数据\n4. **[文件 I/O](#advanced-file-io)** - 读写文件\n5. **[命令行参数](#advanced-command-line-args)** - 获取用户输入\n\n### 暂时跳过\n\n- 内存管理（脚本自动处理）\n- 异步/并发（对于简单脚本来说太复杂）\n- FFI（只有在需要 C 互操作时才需要）\n\n### 示例项目：文件重命名器\n\n```hemlock\nimport { list_dir, rename } from \"@stdlib/fs\";\n\n// 将所有 .txt 文件重命名为 .md\nlet files = list_dir(\".\");\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let new_name = file.replace(\".txt\", \".md\");\n        rename(file, new_name);\n        print(`已重命名：${file} -> ${new_name}`);\n    }\n}\n```\n\n---\n\n## 路径 2：数据处理与分析\n\n**目标：** 解析数据、转换数据、生成报告。\n\n**达到生产力的时间：** 很快 - Hemlock 的字符串和数组方法使这变得很容易。\n\n### 您将学到的内容\n\n1. **[快速入门](#getting-started-quick-start)** - 基础知识\n2. **[字符串](#language-guide-strings)** - 解析、分割、格式化\n3. **[数组](#language-guide-arrays)** - map、filter、reduce 用于数据转换\n4. **[对象](#language-guide-objects)** - 结构化数据\n5. **标准库：**\n   - **[@stdlib/json](#stdlib-json)** - JSON 解析\n   - **[@stdlib/csv](#stdlib-csv)** - CSV 文件\n   - **[@stdlib/fs](#stdlib-fs)** - 文件操作\n\n### 示例项目：CSV 分析器\n\n```hemlock\nimport { read_file } from \"@stdlib/fs\";\nimport { parse } from \"@stdlib/csv\";\n\nlet data = parse(read_file(\"sales.csv\"));\n\n// 计算总销售额\nlet total = 0;\nfor (row in data) {\n    total = total + f64(row.amount);\n}\n\nprint(`总销售额：$${total}`);\n\n// 找出最高销售额\nlet top = data[0];\nfor (row in data) {\n    if (f64(row.amount) > f64(top.amount)) {\n        top = row;\n    }\n}\n\nprint(`最高销售：${top.product} - $${top.amount}`);\n```\n\n---\n\n## 路径 3：Web 和网络编程\n\n**目标：** 构建 HTTP 客户端、使用 API、创建服务器。\n\n**达到生产力的时间：** 中等 - 需要理解异步基础知识。\n\n### 您将学到的内容\n\n1. **[快速入门](#getting-started-quick-start)** - 基础知识\n2. **[函数](#language-guide-functions)** - 回调和闭包\n3. **[错误处理](#language-guide-error-handling)** - 网络错误的 try/catch\n4. **[异步与并发](#advanced-async-concurrency)** - spawn、await、channels\n5. **标准库：**\n   - **[@stdlib/http](#stdlib-http)** - HTTP 请求\n   - **[@stdlib/json](#stdlib-json)** - API 的 JSON\n   - **[@stdlib/net](#stdlib-net)** - TCP/UDP 套接字\n   - **[@stdlib/url](#stdlib-url)** - URL 解析\n\n### 示例项目：API 客户端\n\n```hemlock\nimport { http_get, http_post } from \"@stdlib/http\";\nimport { parse, stringify } from \"@stdlib/json\";\n\n// GET 请求\nlet response = http_get(\"https://api.example.com/users\");\nlet users = parse(response.body);\n\nfor (user in users) {\n    print(`${user.name}：${user.email}`);\n}\n\n// POST 请求\nlet new_user = { name: \"Alice\", email: \"alice@example.com\" };\nlet result = http_post(\"https://api.example.com/users\", {\n    body: stringify(new_user),\n    headers: { \"Content-Type\": \"application/json\" }\n});\n\nprint(`创建的用户 ID：${parse(result.body).id}`);\n```\n\n---\n\n## 路径 4：系统编程\n\n**目标：** 编写底层代码、操作内存、与 C 库交互。\n\n**达到生产力的时间：** 较长 - 需要理解内存管理。\n\n### 您将学到的内容\n\n1. **[快速入门](#getting-started-quick-start)** - 基础知识\n2. **[类型](#language-guide-types)** - 理解 i32、u8、ptr 等\n3. **[内存管理](#language-guide-memory)** - alloc、free、缓冲区\n4. **[FFI](#advanced-ffi)** - 调用 C 函数\n5. **[信号](#advanced-signals)** - 信号处理\n\n### 关键概念\n\n**内存安全清单：**\n- [ ] 每个 `alloc()` 都有对应的 `free()`\n- [ ] 除非需要原始 `ptr`，否则使用 `buffer()`\n- [ ] 释放后将指针设置为 `null`\n- [ ] 使用 `try/finally` 保证清理\n\n**FFI 类型映射：**\n| Hemlock | C |\n|---------|---|\n| `i8` | `char` / `int8_t` |\n| `i32` | `int` |\n| `i64` | `long`（64位）|\n| `u8` | `unsigned char` |\n| `f64` | `double` |\n| `ptr` | `void*` |\n\n### 示例项目：自定义内存池\n\n```hemlock\n// 简单的 bump allocator\nlet pool_size = 1024 * 1024;  // 1MB\nlet pool = alloc(pool_size);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > pool_size) {\n        throw \"内存池已耗尽\";\n    }\n    let p = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return p;\n}\n\nfn pool_reset() {\n    pool_offset = 0;\n}\n\nfn pool_destroy() {\n    free(pool);\n}\n\n// 使用它\nlet a = pool_alloc(100);\nlet b = pool_alloc(200);\nmemset(a, 0, 100);\nmemset(b, 0, 200);\n\npool_reset();  // 重用所有内存\npool_destroy();  // 清理\n```\n\n---\n\n## 路径 5：并行与并发程序\n\n**目标：** 在多个 CPU 核心上运行代码，构建响应式应用程序。\n\n**达到生产力的时间：** 中等 - 异步语法很简单，但并行思维需要练习。\n\n### 您将学到的内容\n\n1. **[快速入门](#getting-started-quick-start)** - 基础知识\n2. **[函数](#language-guide-functions)** - 闭包（对异步很重要）\n3. **[异步与并发](#advanced-async-concurrency)** - 完整深入讲解\n4. **[原子操作](#advanced-atomics)** - 无锁编程\n\n### 关键概念\n\n**Hemlock 的异步模型：**\n- `async fn` - 定义可以在另一个线程上运行的函数\n- `spawn(fn, args...)` - 开始运行它，返回任务句柄\n- `join(task)` 或 `await task` - 等待它完成，获取结果\n- `channel(size)` - 创建用于在任务之间发送数据的队列\n\n**重要：** 任务接收值的*副本*。如果您传递一个指针，您需要负责确保内存在任务完成之前保持有效。\n\n### 示例项目：并行文件处理器\n\n```hemlock\nimport { list_dir, read_file } from \"@stdlib/fs\";\n\nasync fn process_file(path: string): i32 {\n    let content = read_file(path);\n    let lines = content.split(\"\\n\");\n    return lines.length;\n}\n\n// 并行处理所有文件\nlet files = list_dir(\"data/\");\nlet tasks = [];\n\nfor (file in files) {\n    if (file.ends_with(\".txt\")) {\n        let task = spawn(process_file, \"data/\" + file);\n        tasks.push({ name: file, task: task });\n    }\n}\n\n// 收集结果\nlet total_lines = 0;\nfor (item in tasks) {\n    let count = join(item.task);\n    print(`${item.name}：${count} 行`);\n    total_lines = total_lines + count;\n}\n\nprint(`总计：${total_lines} 行`);\n```\n\n---\n\n## 任何路径都应该首先学习的内容\n\n无论您的目标是什么，从这些基础知识开始：\n\n### 第 1 周：核心基础\n1. **[快速入门](#getting-started-quick-start)** - 编写并运行您的第一个程序\n2. **[语法](#language-guide-syntax)** - 变量、运算符、控制流\n3. **[函数](#language-guide-functions)** - 定义和调用函数\n\n### 第 2 周：数据处理\n4. **[字符串](#language-guide-strings)** - 文本操作\n5. **[数组](#language-guide-arrays)** - 集合和迭代\n6. **[对象](#language-guide-objects)** - 结构化数据\n\n### 第 3 周：健壮性\n7. **[错误处理](#language-guide-error-handling)** - try/catch/throw\n8. **[模块](#language-guide-modules)** - 导入/导出，使用标准库\n\n### 然后：选择您上面的路径\n\n---\n\n## 速查表：来自其他语言\n\n### 来自 Python\n\n| Python | Hemlock | 注意事项 |\n|--------|---------|----------|\n| `x = 42` | `let x = 42;` | 需要分号 |\n| `def fn():` | `fn name() { }` | 需要花括号 |\n| `if x:` | `if (x) { }` | 需要括号和花括号 |\n| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | C 风格的 for 循环 |\n| `for item in list:` | `for (item in array) { }` | for-in 相同 |\n| `list.append(x)` | `array.push(x);` | 方法名不同 |\n| `len(s)` | `s.length` 或 `len(s)` | 两者都可以 |\n| 自动内存管理 | `ptr` 需要手动管理 | 大多数类型自动清理 |\n\n### 来自 JavaScript\n\n| JavaScript | Hemlock | 注意事项 |\n|------------|---------|----------|\n| `let x = 42` | `let x = 42;` | 相同（需要分号）|\n| `const x = 42` | `let x = 42;` | 没有 const 关键字 |\n| `function fn()` | `fn name() { }` | 不同的关键字 |\n| `() => x` | `fn() { return x; }` | 没有箭头函数 |\n| `async/await` | `async/await` | 相同语法 |\n| `Promise` | `spawn/join` | 不同的模型 |\n| 自动 GC | `ptr` 需要手动管理 | 大多数类型自动清理 |\n\n### 来自 C/C++\n\n| C | Hemlock | 注意事项 |\n|---|---------|----------|\n| `int x = 42;` | `let x: i32 = 42;` | 类型在冒号后 |\n| `malloc(n)` | `alloc(n)` | 相同概念 |\n| `free(p)` | `free(p)` | 相同 |\n| `char* s = \"hi\"` | `let s = \"hi\";` | 字符串是托管的 |\n| `#include` | `import { } from` | 模块导入 |\n| 全部手动管理 | 大多数类型自动 | 只有 `ptr` 需要手动 |\n\n---\n\n## 获取帮助\n\n- **[术语表](../glossary.md)** - 编程术语定义\n- **[示例](../../examples/)** - 完整的工作程序\n- **[测试](../../tests/)** - 查看功能的使用方式\n- **GitHub Issues** - 提问、报告错误\n\n---\n\n## 难度级别\n\n在整个文档中，您会看到这些标记：\n\n| 标记 | 含义 |\n|------|------|\n| **初学者** | 不需要先前的编程经验 |\n| **中级** | 假设具有基本的编程知识 |\n| **高级** | 需要理解系统概念 |\n\n如果标记为\"初学者\"的内容让您困惑，请查看[术语表](../glossary.md)了解术语定义。\n"}, "快速入门 -> 安装": {"id": "getting-started-installation", "content": "# 安装指南\n\n本指南将帮助您在系统上构建和安装 Hemlock。\n\n## 快速安装（推荐）\n\n安装 Hemlock 最简单的方法是使用一行安装脚本：\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash\n```\n\n这将为您的平台（Linux 或 macOS，x86_64 或 arm64）下载并安装最新的预编译二进制文件。\n\n### 安装选项\n\n```bash\n# 安装到自定义前缀（默认：~/.local）\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local\n\n# 安装特定版本\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0\n\n# 安装并自动更新 shell PATH\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path\n```\n\n安装后，验证是否正常工作：\n\n```bash\nhemlock --version\n```\n\n---\n\n## 从源代码构建\n\n如果您更喜欢从源代码构建，或者预编译的二进制文件不适用于您的系统，请按照以下说明操作。\n\n## 前置条件\n\n### 必需的依赖项\n\nHemlock 构建需要以下依赖项：\n\n- **C 编译器**：GCC 或 Clang（C11 标准）\n- **Make**：GNU Make\n- **libffi**：外部函数接口库（用于 FFI 支持）\n- **OpenSSL**：加密库（用于哈希函数：md5、sha1、sha256）\n- **libwebsockets**：WebSocket 和 HTTP 客户端/服务器支持\n- **zlib**：压缩库\n\n### 安装依赖项\n\n**macOS：**\n```bash\n# 如果尚未安装，请先安装 Homebrew\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# 安装 Xcode 命令行工具\nxcode-select --install\n\n# 通过 Homebrew 安装依赖项\nbrew install libffi openssl@3 libwebsockets\n```\n\n**macOS 用户注意**：Makefile 会自动检测 Homebrew 安装并设置正确的 include/library 路径。Hemlock 支持 Intel（x86_64）和 Apple Silicon（arm64）架构。\n\n**Ubuntu/Debian：**\n```bash\nsudo apt-get update\nsudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev\n```\n\n**Fedora/RHEL：**\n```bash\nsudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel\n```\n\n**Arch Linux：**\n```bash\nsudo pacman -S base-devel libffi openssl libwebsockets zlib\n```\n\n## 从源代码构建\n\n### 1. 克隆仓库\n\n```bash\ngit clone https://github.com/hemlang/hemlock.git\ncd hemlock\n```\n\n### 2. 构建 Hemlock\n\n```bash\nmake\n```\n\n这将编译 Hemlock 解释器并将可执行文件放在当前目录中。\n\n### 3. 验证安装\n\n```bash\n./hemlock --version\n```\n\n您应该看到 Hemlock 版本信息。\n\n### 4. 测试构建\n\n运行测试套件以确保一切正常工作：\n\n```bash\nmake test\n```\n\n所有测试都应该通过。如果您看到任何失败，请将其作为问题报告。\n\n## 系统级安装（可选）\n\n要在系统级安装 Hemlock（例如，安装到 `/usr/local/bin`）：\n\n```bash\nsudo make install\n```\n\n这允许您从任何位置运行 `hemlock` 而无需指定完整路径。\n\n## 运行 Hemlock\n\n### 交互式 REPL\n\n启动读取-求值-打印循环（REPL）：\n\n```bash\n./hemlock\n```\n\n您将看到一个提示符，可以在其中输入 Hemlock 代码：\n\n```\nHemlock REPL\n> print(\"Hello, World!\");\nHello, World!\n> let x = 42;\n> print(x * 2);\n84\n>\n```\n\n使用 `Ctrl+D` 或 `Ctrl+C` 退出 REPL。\n\n### 运行程序\n\n执行 Hemlock 脚本：\n\n```bash\n./hemlock program.hml\n```\n\n带有命令行参数：\n\n```bash\n./hemlock program.hml arg1 arg2 \"带空格的参数\"\n```\n\n## 目录结构\n\n构建后，您的 Hemlock 目录将如下所示：\n\n```\nhemlock/\n├── hemlock           # 编译的解释器可执行文件\n├── src/              # 源代码\n├── include/          # 头文件\n├── tests/            # 测试套件\n├── examples/         # 示例程序\n├── docs/             # 文档\n├── stdlib/           # 标准库\n├── Makefile          # 构建配置\n└── README.md         # 项目说明\n```\n\n## 构建选项\n\n### 调试构建\n\n使用调试符号和无优化进行构建：\n\n```bash\nmake debug\n```\n\n### 清理构建\n\n删除所有编译的文件：\n\n```bash\nmake clean\n```\n\n从头开始重新构建：\n\n```bash\nmake clean && make\n```\n\n## 故障排除\n\n### macOS：找不到库错误\n\n如果您收到关于缺少库的错误（`-lcrypto`、`-lffi` 等）：\n\n1. 确保已安装 Homebrew 依赖项：\n   ```bash\n   brew install libffi openssl@3 libwebsockets\n   ```\n\n2. 验证 Homebrew 路径：\n   ```bash\n   brew --prefix libffi\n   brew --prefix openssl\n   ```\n\n3. Makefile 应该会自动检测这些路径。如果没有，请检查 `brew` 是否在您的 PATH 中：\n   ```bash\n   which brew\n   ```\n\n### macOS：BSD 类型错误（`u_int`、`u_char` 未找到）\n\n如果您看到关于未知类型名称（如 `u_int` 或 `u_char`）的错误：\n\n1. 这在 v1.0.0+ 中已通过使用 `_DARWIN_C_SOURCE` 而不是 `_POSIX_C_SOURCE` 修复\n2. 确保您拥有最新版本的代码\n3. 清理并重新构建：\n   ```bash\n   make clean && make\n   ```\n\n### Linux：找不到 libffi\n\n如果您收到关于缺少 `ffi.h` 或 `-lffi` 的错误：\n\n1. 确保已安装 `libffi-dev`（请参阅上面的依赖项）\n2. 检查 `pkg-config` 是否能找到它：\n   ```bash\n   pkg-config --cflags --libs libffi\n   ```\n3. 如果未找到，您可能需要设置 `PKG_CONFIG_PATH`：\n   ```bash\n   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH\n   ```\n\n### 编译错误\n\n如果遇到编译错误：\n\n1. 确保您有兼容 C11 的编译器\n2. 在 macOS 上，尝试使用 Clang（默认）：\n   ```bash\n   make CC=clang\n   ```\n3. 在 Linux 上，尝试使用 GCC：\n   ```bash\n   make CC=gcc\n   ```\n4. 检查是否已安装所有依赖项\n5. 尝试从头开始重新构建：\n   ```bash\n   make clean && make\n   ```\n\n### 测试失败\n\n如果测试失败：\n\n1. 检查您是否拥有最新版本的代码\n2. 尝试从头开始重新构建：\n   ```bash\n   make clean && make test\n   ```\n3. 在 macOS 上，确保您拥有最新的 Xcode 命令行工具：\n   ```bash\n   xcode-select --install\n   ```\n4. 在 GitHub 上报告问题，包括：\n   - 您的平台（macOS 版本 / Linux 发行版）\n   - 架构（x86_64 / arm64）\n   - 测试输出\n   - `make -v` 和 `gcc --version`（或 `clang --version`）的输出\n\n## 下一步\n\n- [快速入门指南](#getting-started-quick-start) - 编写您的第一个 Hemlock 程序\n- [教程](#getting-started-tutorial) - 逐步学习 Hemlock\n- [语言指南](#language-guide-syntax) - 探索 Hemlock 特性\n"}, "快速入门 -> 快速开始": {"id": "getting-started-quick-start", "content": "# 快速入门\n\n几分钟内开始使用 Hemlock！\n\n## 您的第一个程序\n\n创建一个名为 `hello.hml` 的文件：\n\n```hemlock\nprint(\"Hello, Hemlock!\");\n```\n\n使用解释器运行：\n\n```bash\n./hemlock hello.hml\n```\n\n或编译为原生可执行文件：\n\n```bash\n./hemlockc hello.hml -o hello\n./hello\n```\n\n输出：\n```\nHello, Hemlock!\n```\n\n### 解释器 vs 编译器\n\nHemlock 提供两种运行程序的方式：\n\n| 工具 | 用例 | 类型检查 |\n|------|------|----------|\n| `hemlock` | 快速脚本、REPL、开发 | 仅运行时 |\n| `hemlockc` | 生产二进制文件、更好的性能 | 编译时（默认）|\n\n编译器（`hemlockc`）在生成可执行文件之前对代码进行类型检查，可以提前捕获错误。\n\n## 基本语法\n\n### 变量\n\n```hemlock\n// 使用 'let' 声明变量\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\n// 类型注解是可选的\nlet count: i32 = 100;\nlet ratio: f64 = 0.618;\n```\n\n**重要**：分号在 Hemlock 中是**必需的**！\n\n### 类型\n\nHemlock 拥有丰富的类型系统：\n\n```hemlock\n// 整数\nlet small: i8 = 127;          // 8位有符号\nlet byte: u8 = 255;           // 8位无符号\nlet num: i32 = 2147483647;    // 32位有符号（默认）\nlet big: i64 = 9223372036854775807;  // 64位有符号\n\n// 浮点数\nlet f: f32 = 3.14;            // 32位浮点\nlet d: f64 = 2.71828;         // 64位浮点（默认）\n\n// 字符串和字符\nlet text: string = \"Hello\";   // UTF-8 字符串\nlet emoji: rune = '🚀';       // Unicode 码点\n\n// 布尔值和空值\nlet flag: bool = true;\nlet empty = null;\n```\n\n### 控制流\n\n```hemlock\n// if 语句\nif (x > 0) {\n    print(\"正数\");\n} else if (x < 0) {\n    print(\"负数\");\n} else {\n    print(\"零\");\n}\n\n// while 循环\nlet i = 0;\nwhile (i < 5) {\n    print(i);\n    i = i + 1;\n}\n\n// for 循环\nfor (let j = 0; j < 10; j = j + 1) {\n    print(j);\n}\n```\n\n### 函数\n\n```hemlock\n// 命名函数\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nlet result = add(5, 3);  // 8\n\n// 匿名函数\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(multiply(4, 7));  // 28\n```\n\n## 字符串操作\n\nHemlock 中的字符串是**可变的**和 **UTF-8** 编码的：\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';              // 现在是 \"Hello\"\nprint(s);\n\n// 字符串方法\nlet upper = s.to_upper();     // \"HELLO\"\nlet words = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\nlet sub = s.substr(1, 3);     // \"ell\"\n\n// 连接\nlet greeting = \"Hello\" + \", \" + \"World!\";\nprint(greeting);  // \"Hello, World!\"\n```\n\n## 数组\n\n支持混合类型的动态数组：\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// 数组方法\nnumbers.push(6);        // [1, 2, 3, 4, 5, 6]\nlet last = numbers.pop();  // 6\nlet slice = numbers.slice(1, 4);  // [2, 3, 4]\n\n// 允许混合类型\nlet mixed = [1, \"two\", true, null];\n```\n\n## 对象\n\nJavaScript 风格的对象：\n\n```hemlock\n// 对象字面量\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nperson.age = 31;     // 修改字段\n\n// 使用 'self' 的方法\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## 内存管理\n\nHemlock 使用**手动内存管理**：\n\n```hemlock\n// 安全缓冲区（推荐）\nlet buf = buffer(64);   // 分配 64 字节\nbuf[0] = 65;            // 将第一个字节设置为 'A'\nprint(buf[0]);          // 65\nfree(buf);              // 释放内存\n\n// 原始指针（高级）\nlet ptr = alloc(100);\nmemset(ptr, 0, 100);    // 用零填充\nfree(ptr);\n```\n\n**重要**：您必须 `free()` 您 `alloc()` 的内存！\n\n## 错误处理\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"除零错误\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"错误：\" + e);\n} finally {\n    print(\"完成\");\n}\n```\n\n## 命令行参数\n\n通过 `args` 数组访问程序参数：\n\n```hemlock\n// script.hml\nprint(\"脚本：\", args[0]);\nprint(`参数数量：${args.length - 1}`);\n\nlet i = 1;\nwhile (i < args.length) {\n    print(`  参数 ${i}：${args[i]}`);\n    i = i + 1;\n}\n```\n\n运行：\n```bash\n./hemlock script.hml hello world\n```\n\n输出：\n```\n脚本：script.hml\n参数数量：2\n  参数 1：hello\n  参数 2：world\n```\n\n## 文件 I/O\n\n```hemlock\n// 写入文件\nlet f = open(\"data.txt\", \"w\");\nf.write(\"Hello, File!\");\nf.close();\n\n// 读取文件\nlet f2 = open(\"data.txt\", \"r\");\nlet content = f2.read();\nprint(content);  // \"Hello, File!\"\nf2.close();\n```\n\n## 接下来学什么？\n\n现在您已经了解了基础知识，可以探索更多内容：\n\n- [教程](#getting-started-tutorial) - 全面的分步指南\n- [语言指南](#language-guide-syntax) - 深入了解所有特性\n- [示例](../../examples/) - 真实世界的示例程序\n- [API 参考](#reference-builtins) - 完整的 API 文档\n\n## 常见陷阱\n\n### 忘记分号\n\n```hemlock\n// ❌ 错误：缺少分号\nlet x = 42\nlet y = 10\n\n// ✅ 正确\nlet x = 42;\nlet y = 10;\n```\n\n### 忘记释放内存\n\n```hemlock\n// ❌ 内存泄漏\nlet buf = buffer(100);\n// ... 使用 buf ...\n// 忘记调用 free(buf)！\n\n// ✅ 正确\nlet buf = buffer(100);\n// ... 使用 buf ...\nfree(buf);\n```\n\n### 花括号是必需的\n\n```hemlock\n// ❌ 错误：缺少花括号\nif (x > 0)\n    print(\"正数\");\n\n// ✅ 正确\nif (x > 0) {\n    print(\"正数\");\n}\n```\n\n## 获取帮助\n\n- 阅读[完整文档](../README.md)\n- 查看[示例目录](../../examples/)\n- 查看[测试文件](../../tests/)了解使用模式\n- 在 GitHub 上报告问题\n"}, "快速入门 -> 教程": {"id": "getting-started-tutorial", "content": "# Hemlock 教程\n\n学习 Hemlock 的全面分步指南。\n\n## 目录\n\n1. [Hello World](#hello-world)\n2. [变量和类型](#变量和类型)\n3. [算术和运算](#算术和运算)\n4. [控制流](#控制流)\n5. [函数](#函数)\n6. [字符串和字符](#字符串和字符)\n7. [数组](#数组)\n8. [对象](#对象)\n9. [内存管理](#内存管理)\n10. [错误处理](#错误处理)\n11. [文件 I/O](#文件-io)\n12. [综合示例](#综合示例)\n\n## Hello World\n\n让我们从传统的第一个程序开始：\n\n```hemlock\nprint(\"Hello, World!\");\n```\n\n将其保存为 `hello.hml` 并运行：\n\n```bash\n./hemlock hello.hml\n```\n\n**要点：**\n- `print()` 是一个内置函数，输出到标准输出\n- 字符串用双引号括起来\n- 分号是**必需的**\n\n## 变量和类型\n\n### 声明变量\n\n```hemlock\n// 基本变量声明\nlet x = 42;\nlet name = \"Alice\";\nlet pi = 3.14159;\n\nprint(x);      // 42\nprint(name);   // Alice\nprint(pi);     // 3.14159\n```\n\n### 类型注解\n\n虽然类型默认是推断的，但您可以显式指定：\n\n```hemlock\nlet age: i32 = 30;\nlet height: f64 = 5.9;\nlet initial: rune = 'A';\nlet active: bool = true;\n```\n\n### 类型推断\n\nHemlock 根据值推断类型：\n\n```hemlock\nlet small = 42;              // i32（适合 32 位）\nlet large = 5000000000;      // i64（对于 i32 太大）\nlet decimal = 3.14;          // f64（浮点数默认值）\nlet text = \"hello\";          // string\nlet flag = true;             // bool\n```\n\n### 类型检查\n\n```hemlock\n// 使用 typeof() 检查类型\nprint(typeof(42));        // \"i32\"\nprint(typeof(3.14));      // \"f64\"\nprint(typeof(\"hello\"));   // \"string\"\nprint(typeof(true));      // \"bool\"\nprint(typeof(null));      // \"null\"\n```\n\n## 算术和运算\n\n### 基本算术\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13\nprint(a - b);   // 7\nprint(a * b);   // 30\nprint(a / b);   // 3（整数除法）\nprint(a == b);  // false\nprint(a > b);   // true\n```\n\n### 类型提升\n\n混合类型时，Hemlock 会提升到更大/更精确的类型：\n\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result 是 f64（10.0 + 3.5 = 13.5）\n\nprint(result);       // 13.5\nprint(typeof(result)); // \"f64\"\n```\n\n### 位运算\n\n```hemlock\nlet a = 12;  // 二进制 1100\nlet b = 10;  // 二进制 1010\n\nprint(a & b);   // 8  (AND)\nprint(a | b);   // 14 (OR)\nprint(a ^ b);   // 6  (XOR)\nprint(a << 1);  // 24（左移）\nprint(a >> 1);  // 6 （右移）\nprint(~a);      // -13 (NOT)\n```\n\n## 控制流\n\n### If 语句\n\n```hemlock\nlet x = 10;\n\nif (x > 0) {\n    print(\"正数\");\n} else if (x < 0) {\n    print(\"负数\");\n} else {\n    print(\"零\");\n}\n```\n\n**注意：** 花括号**始终是必需的**，即使是单个语句也是如此。\n\n### While 循环\n\n```hemlock\nlet count = 0;\nwhile (count < 5) {\n    print(`计数：${count}`);\n    count = count + 1;\n}\n```\n\n### For 循环\n\n```hemlock\n// C 风格的 for 循环\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n\n// for-in 循环（数组）\nlet items = [10, 20, 30, 40];\nfor (let item in items) {\n    print(`项目：${item}`);\n}\n```\n\n### Switch 语句\n\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n        print(\"星期一\");\n        break;\n    case 2:\n        print(\"星期二\");\n        break;\n    case 3:\n        print(\"星期三\");\n        break;\n    default:\n        print(\"其他日子\");\n        break;\n}\n```\n\n### Break 和 Continue\n\n```hemlock\n// Break：提前退出循环\nlet i = 0;\nwhile (i < 10) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// 输出：0, 1, 2, 3, 4\n\n// Continue：跳到下一次迭代\nfor (let j = 0; j < 5; j = j + 1) {\n    if (j == 2) {\n        continue;\n    }\n    print(j);\n}\n// 输出：0, 1, 3, 4\n```\n\n## 函数\n\n### 命名函数\n\n```hemlock\nfn greet(name: string): string {\n    return \"你好，\" + name + \"！\";\n}\n\nlet message = greet(\"Alice\");\nprint(message);  // \"你好，Alice！\"\n```\n\n### 匿名函数\n\n```hemlock\nlet add = fn(a, b) {\n    return a + b;\n};\n\nprint(add(5, 3));  // 8\n```\n\n### 递归\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### 闭包\n\n函数捕获其环境：\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n### 高阶函数\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 21);\nprint(result);  // 42\n```\n\n## 字符串和字符\n\n### 字符串基础\n\n字符串是**可变的**和 **UTF-8** 编码的：\n\n```hemlock\nlet s = \"hello\";\nprint(s.length);      // 5（字符数）\nprint(s.byte_length); // 5（字节数）\n\n// 修改\ns[0] = 'H';\nprint(s);  // \"Hello\"\n```\n\n### 字符串方法\n\n```hemlock\nlet text = \"  Hello, World!  \";\n\n// 大小写转换\nprint(text.to_upper());  // \"  HELLO, WORLD!  \"\nprint(text.to_lower());  // \"  hello, world!  \"\n\n// 去除空白\nprint(text.trim());      // \"Hello, World!\"\n\n// 子字符串提取\nlet hello = text.substr(2, 5);  // \"Hello\"\nlet world = text.slice(9, 14);  // \"World\"\n\n// 搜索\nlet pos = text.find(\"World\");   // 9\nlet has = text.contains(\"o\");   // true\n\n// 分割\nlet parts = \"a,b,c\".split(\",\"); // [\"a\", \"b\", \"c\"]\n\n// 替换\nlet s = \"hello world\".replace(\"world\", \"there\");\nprint(s);  // \"hello there\"\n```\n\n### 字符（Unicode 码点）\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '🚀';\n\nprint(ch);      // 'A'\nprint(emoji);   // U+1F680\n\n// 字符 + 字符串连接\nlet msg = '>' + \" 重要\";\nprint(msg);  // \"> 重要\"\n\n// 字符和整数之间的转换\nlet code: i32 = ch;     // 65（ASCII 码）\nlet r: rune = 128640;   // U+1F680（🚀）\n```\n\n## 数组\n\n### 数组基础\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nprint(numbers[0]);      // 1\nprint(numbers.length);  // 5\n\n// 修改元素\nnumbers[2] = 99;\nprint(numbers[2]);  // 99\n```\n\n### 数组方法\n\n```hemlock\nlet arr = [10, 20, 30];\n\n// 在末尾添加/删除\narr.push(40);           // [10, 20, 30, 40]\nlet last = arr.pop();   // 40，arr 现在是 [10, 20, 30]\n\n// 在开头添加/删除\narr.unshift(5);         // [5, 10, 20, 30]\nlet first = arr.shift(); // 5，arr 现在是 [10, 20, 30]\n\n// 在索引处插入/删除\narr.insert(1, 15);      // [10, 15, 20, 30]\nlet removed = arr.remove(2);  // 20\n\n// 搜索\nlet index = arr.find(15);     // 1\nlet has = arr.contains(10);   // true\n\n// 切片\nlet slice = arr.slice(0, 2);  // [10, 15]\n\n// 连接为字符串\nlet text = arr.join(\", \");    // \"10, 15, 30\"\n```\n\n### 迭代\n\n```hemlock\nlet items = [\"苹果\", \"香蕉\", \"樱桃\"];\n\n// for-in 循环\nfor (let item in items) {\n    print(item);\n}\n\n// 手动迭代\nlet i = 0;\nwhile (i < items.length) {\n    print(items[i]);\n    i = i + 1;\n}\n```\n\n## 对象\n\n### 对象字面量\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n\nprint(person.name);  // \"Alice\"\nprint(person.age);   // 30\n\n// 添加/修改字段\nperson.email = \"alice@example.com\";\nperson.age = 31;\n```\n\n### 方法和 `self`\n\n```hemlock\nlet calculator = {\n    value: 0,\n    add: fn(x) {\n        self.value = self.value + x;\n    },\n    get: fn() {\n        return self.value;\n    }\n};\n\ncalculator.add(10);\ncalculator.add(5);\nprint(calculator.get());  // 15\n```\n\n### 类型定义（鸭子类型）\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,  // 带默认值的可选字段\n}\n\nlet p = { name: \"Bob\", age: 25 };\nlet typed: Person = p;  // 鸭子类型验证结构\n\nprint(typeof(typed));   // \"Person\"\nprint(typed.active);    // true（应用默认值）\n```\n\n### JSON 序列化\n\n```hemlock\nlet obj = { x: 10, y: 20, name: \"test\" };\n\n// 对象到 JSON\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// JSON 到对象\nlet restored = json.deserialize();\nprint(restored.name);  // \"test\"\n```\n\n## 内存管理\n\n### 安全缓冲区（推荐）\n\n```hemlock\n// 分配缓冲区\nlet buf = buffer(10);\nprint(buf.length);    // 10\nprint(buf.capacity);  // 10\n\n// 设置值（边界检查）\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// 访问值\nprint(buf[0]);  // 65\n\n// 完成后必须释放\nfree(buf);\n```\n\n### 原始指针（高级）\n\n```hemlock\n// 分配原始内存\nlet ptr = alloc(100);\n\n// 用零填充\nmemset(ptr, 0, 100);\n\n// 复制数据\nlet src = alloc(50);\nmemcpy(ptr, src, 50);\n\n// 释放两者\nfree(src);\nfree(ptr);\n```\n\n### 内存函数\n\n```hemlock\n// 重新分配\nlet p = alloc(64);\np = realloc(p, 128);  // 调整为 128 字节\nfree(p);\n\n// 类型化分配（未来功能）\n// let arr = talloc(i32, 100);  // 100 个 i32 的数组\n```\n\n## 错误处理\n\n### Try/Catch\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"除零错误\";\n    }\n    return a / b;\n}\n\ntry {\n    let result = divide(10, 0);\n    print(result);\n} catch (e) {\n    print(\"错误：\" + e);\n}\n// 输出：错误：除零错误\n```\n\n### Finally 块\n\n```hemlock\nlet file = null;\n\ntry {\n    file = open(\"data.txt\", \"r\");\n    let content = file.read();\n    print(content);\n} catch (e) {\n    print(\"错误：\" + e);\n} finally {\n    // 始终运行\n    if (file != null) {\n        file.close();\n    }\n}\n```\n\n### 抛出对象\n\n```hemlock\ntry {\n    throw { code: 404, message: \"未找到\" };\n} catch (e) {\n    print(`错误 ${e.code}：${e.message}`);\n}\n// 输出：错误 404：未找到\n```\n\n### Panic（不可恢复的错误）\n\n```hemlock\nfn validate(x) {\n    if (x < 0) {\n        panic(\"x 必须是非负数\");\n    }\n    return x * 2;\n}\n\nvalidate(-5);  // 程序退出并显示：panic: x 必须是非负数\n```\n\n## 文件 I/O\n\n### 读取文件\n\n```hemlock\n// 读取整个文件\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n\n// 读取指定字节数\nlet f2 = open(\"data.txt\", \"r\");\nlet chunk = f2.read(100);  // 读取 100 字节\nf2.close();\n```\n\n### 写入文件\n\n```hemlock\n// 写入文本\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Hello, File!\\n\");\nf.write(\"第二行\\n\");\nf.close();\n\n// 追加到文件\nlet f2 = open(\"output.txt\", \"a\");\nf2.write(\"追加的行\\n\");\nf2.close();\n```\n\n### 二进制 I/O\n\n```hemlock\n// 写入二进制数据\nlet buf = buffer(256);\nbuf[0] = 255;\nbuf[1] = 128;\n\nlet f = open(\"data.bin\", \"w\");\nf.write_bytes(buf);\nf.close();\n\n// 读取二进制数据\nlet f2 = open(\"data.bin\", \"r\");\nlet data = f2.read_bytes(256);\nprint(data[0]);  // 255\nf2.close();\n\nfree(buf);\nfree(data);\n```\n\n### 文件属性\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\n\nprint(f.path);    // \"/path/to/file.txt\"\nprint(f.mode);    // \"r\"\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n## 综合示例\n\n让我们构建一个简单的单词计数程序：\n\n```hemlock\n// wordcount.hml - 计算文件中的单词数\n\nfn count_words(filename: string): i32 {\n    let file = null;\n    let count = 0;\n\n    try {\n        file = open(filename, \"r\");\n        let content = file.read();\n\n        // 按空格分割并计数\n        let words = content.split(\" \");\n        count = words.length;\n\n    } catch (e) {\n        print(\"读取文件错误：\" + e);\n        return -1;\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n\n    return count;\n}\n\n// 主程序\nif (args.length < 2) {\n    print(\"用法：\" + args[0] + \" <文件名>\");\n} else {\n    let filename = args[1];\n    let words = count_words(filename);\n\n    if (words >= 0) {\n        print(`单词数：${words}`);\n    }\n}\n```\n\n运行：\n```bash\n./hemlock wordcount.hml data.txt\n```\n\n## 下一步\n\n恭喜！您已经学会了 Hemlock 的基础知识。接下来可以探索：\n\n- [异步与并发](#advanced-async-concurrency) - 真正的多线程\n- [FFI](#advanced-ffi) - 调用 C 函数\n- [信号处理](#advanced-signals) - 进程信号\n- [API 参考](#reference-builtins) - 完整的 API 文档\n- [示例](../../examples/) - 更多真实世界的程序\n\n## 练习题\n\n尝试构建这些程序来练习：\n\n1. **计算器**：实现一个简单的计算器，支持 +、-、*、/\n2. **文件复制**：将一个文件复制到另一个文件\n3. **斐波那契**：生成斐波那契数列\n4. **JSON 解析器**：读取和解析 JSON 文件\n5. **文本处理器**：在文件中查找和替换文本\n\n祝您使用 Hemlock 编程愉快！\n"}, "语言指南 -> 内存管理": {"id": "language-guide-memory", "content": "# 内存管理\n\nHemlock 采用**手动内存管理**，对分配和释放有显式控制。本指南涵盖 Hemlock 的内存模型、两种指针类型以及完整的内存 API。\n\n---\n\n## 内存基础 101\n\n**编程新手？** 从这里开始。如果你已经理解内存管理，可以跳到 [设计理念](#设计理念)。\n\n### 什么是内存管理？\n\n当你的程序需要存储数据（文本、数字、列表）时，它需要空间来放置这些数据。这个空间来自计算机的内存（RAM）。内存管理涉及：\n\n1. **获取空间** - 需要时请求内存\n2. **使用空间** - 读写数据\n3. **归还空间** - 完成后返还内存\n\n### 为什么重要？\n\n想象一个书籍有限的图书馆：\n- 如果你不断借书却从不归还，最终就没有书可借了\n- 如果你试图阅读已经归还的书，会产生混乱或问题\n\n内存的工作方式相同。如果你忘记归还内存，程序会逐渐使用越来越多的内存（\"内存泄漏\"）。如果你在归还后尝试使用内存，会发生糟糕的事情。\n\n### 好消息\n\n**大多数时候，你不需要考虑这些！**\n\nHemlock 自动清理大多数常见类型：\n\n```hemlock\nfn example() {\n    let name = \"Alice\";       // Hemlock 管理这个\n    let numbers = [1, 2, 3];  // 还有这个\n    let person = { age: 30 }; // 还有这个\n\n    // 函数结束时，所有这些都自动清理！\n}\n```\n\n### 何时需要考虑\n\n只有在使用以下情况时才需要手动内存管理：\n\n1. **`alloc()`** - 原始内存分配（返回 `ptr`）\n2. **`buffer()`** - 当你想提前释放时（可选 - 作用域结束时自动释放）\n\n```hemlock\n// 这需要手动清理：\nlet raw = alloc(100);   // 原始内存 - 你必须释放它\n// ... 使用 raw ...\nfree(raw);              // 必需！否则会有内存泄漏\n\n// 这自动清理（但你可以提前释放）：\nlet buf = buffer(100);  // 安全 buffer\n// ... 使用 buf ...\n// free(buf);           // 可选 - 作用域结束时自动释放\n```\n\n### 简单规则\n\n> **如果你调用 `alloc()`，你必须调用 `free()`。**\n>\n> 其他一切都会为你处理。\n\n### 应该使用哪个？\n\n| 场景 | 使用这个 | 原因 |\n|-----------|----------|-----|\n| **刚开始学习** | `buffer()` | 安全、有边界检查、自动清理 |\n| **需要字节存储** | `buffer()` | 安全且简单 |\n| **与 C 库交互（FFI）** | `alloc()` / `ptr` | C 互操作必需 |\n| **最大性能** | `alloc()` / `ptr` | 无边界检查开销 |\n| **不确定** | `buffer()` | 总是更安全的选择 |\n\n### 快速示例：安全与原始\n\n```hemlock\n// 推荐：安全 buffer\nfn safe_example() {\n    let data = buffer(10);\n    data[0] = 65;           // 正确\n    data[5] = 66;           // 正确\n    // data[100] = 67;      // 错误 - Hemlock 阻止你（边界检查）\n    free(data);             // 清理\n}\n\n// 高级：原始指针（仅在需要时使用）\nfn raw_example() {\n    let data = alloc(10);\n    *data = 65;             // 正确\n    *(data + 5) = 66;       // 正确\n    *(data + 100) = 67;     // 危险 - 无边界检查，破坏内存！\n    free(data);             // 清理\n}\n```\n\n**从 `buffer()` 开始。只有在特别需要原始指针时才使用 `alloc()`。**\n\n---\n\n## 设计理念\n\nHemlock 遵循显式内存管理与合理默认值的原则：\n- 无垃圾回收（无不可预测的暂停）\n- 常见类型的内部引用计数（string, array, object, buffer）\n- 原始指针（`ptr`）需要手动 `free()`\n\n这种混合方法在需要时给你完全控制（原始指针），同时防止典型用例的常见错误（引用计数类型在作用域退出时自动释放）。\n\n## 内部引用计数\n\n运行时使用**内部引用计数**来管理对象生命周期。对于大多数引用计数类型的局部变量，清理是自动且确定性的。\n\n### 引用计数处理什么\n\n运行时在以下情况自动管理引用计数：\n\n1. **变量重新赋值** - 旧值被释放：\n   ```hemlock\n   let x = \"first\";   // ref_count = 1\n   x = \"second\";      // \"first\" 内部释放，\"second\" ref_count = 1\n   ```\n\n2. **作用域退出** - 局部变量被释放：\n   ```hemlock\n   fn example() {\n       let arr = [1, 2, 3];  // ref_count = 1\n   }  // 函数返回时 arr 被释放\n   ```\n\n3. **容器被释放** - 元素被释放：\n   ```hemlock\n   let arr = [obj1, obj2];\n   free(arr);  // obj1 和 obj2 的 ref_count 递减\n   ```\n\n### 何时需要 `free()` vs 何时自动\n\n**自动（不需要 `free()`）：** 引用计数类型的局部变量在作用域退出时释放：\n\n```hemlock\nfn process_data() {\n    let arr = [1, 2, 3];\n    let obj = { name: \"test\" };\n    let buf = buffer(64);\n    // ... 使用它们 ...\n}  // 函数返回时全部自动释放 - 不需要 free()\n```\n\n**需要手动 `free()`：**\n\n1. **原始指针** - `alloc()` 没有引用计数：\n   ```hemlock\n   let p = alloc(64);\n   // ... 使用 p ...\n   free(p);  // 总是需要 - 否则会泄漏\n   ```\n\n2. **提前清理** - 在作用域结束前释放以更早释放内存：\n   ```hemlock\n   fn long_running() {\n       let big = buffer(10000000);  // 10MB\n       // ... 用完 big ...\n       free(big);  // 现在释放，不等函数返回\n       // ... 更多不需要 big 的工作 ...\n   }\n   ```\n\n3. **长期存活的数据** - 全局数据或存储在持久结构中的数据：\n   ```hemlock\n   let cache = {};  // 模块级别，除非释放否则存活到程序退出\n\n   fn cleanup() {\n       free(cache);  // 长期存活数据的手动清理\n   }\n   ```\n\n### 引用计数 vs 垃圾回收\n\n| 方面 | Hemlock 引用计数 | 垃圾回收 |\n|--------|---------------------|-------------------|\n| 清理时机 | 确定性（ref 为 0 时立即清理） | 非确定性（GC 决定何时） |\n| 用户责任 | 必须调用 `free()` | 完全自动 |\n| 运行时暂停 | 无 | \"停止世界\"暂停 |\n| 可见性 | 隐藏的实现细节 | 通常不可见 |\n| 循环引用 | 通过 visited-set 跟踪处理 | 通过追踪处理 |\n\n### 哪些类型有引用计数\n\n| 类型 | 引用计数 | 备注 |\n|------|------------|-------|\n| `ptr` | 否 | 总是需要手动 `free()` |\n| `buffer` | 是 | 作用域退出时自动释放；手动 `free()` 用于提前清理 |\n| `array` | 是 | 作用域退出时自动释放；手动 `free()` 用于提前清理 |\n| `object` | 是 | 作用域退出时自动释放；手动 `free()` 用于提前清理 |\n| `string` | 是 | 完全自动，不需要 `free()` |\n| `function` | 是 | 完全自动（闭包环境） |\n| `task` | 是 | 线程安全的原子引用计数 |\n| `channel` | 是 | 线程安全的原子引用计数 |\n| 基本类型 | 否 | 栈分配，无堆分配 |\n\n### 为什么这样设计？\n\n这种混合方法给你：\n- **显式控制** - 你决定何时释放\n- **作用域错误安全** - 重新赋值不会泄漏\n- **可预测性能** - 无 GC 暂停\n- **闭包支持** - 函数可以安全捕获变量\n\n理念保持不变：你在控制，但运行时帮助防止常见错误，如重新赋值时的泄漏或容器中的双重释放。\n\n## 两种指针类型\n\nHemlock 提供两种不同的指针类型，具有不同的安全特性：\n\n### `ptr` - 原始指针（危险）\n\n原始指针**只是地址**，安全保证最少：\n\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // 你必须记得释放\n```\n\n**特性：**\n- 只是一个 8 字节地址\n- 无边界检查\n- 无长度跟踪\n- 用户完全管理生命周期\n- 适合专家和 FFI\n\n**使用场景：**\n- 底层系统编程\n- 外部函数接口（FFI）\n- 性能关键代码\n- 需要完全控制时\n\n**危险：**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // 远超分配范围 - 允许但危险\nfree(p);\nlet x = *p;       // 悬空指针 - 未定义行为\nfree(p);          // 双重释放 - 会崩溃\n```\n\n### `buffer` - 安全包装（推荐）\n\nBuffer 提供**边界检查访问**，同时仍需要手动释放：\n\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // 边界检查\nprint(b.length);        // 64\nfree(b);                // 仍然是手动的\n```\n\n**特性：**\n- 指针 + 长度 + 容量\n- 访问时边界检查\n- 仍需要手动 `free()`\n- 大多数代码的更好默认选择\n\n**属性：**\n```hemlock\nlet buf = buffer(100);\nprint(buf.length);      // 100（当前大小）\nprint(buf.capacity);    // 100（分配的容量）\n```\n\n**边界检查：**\n```hemlock\nlet buf = buffer(10);\nbuf[5] = 42;      // 正确\nbuf[100] = 42;    // 错误：索引越界\n```\n\n## 内存 API\n\n### 核心分配\n\n**`alloc(bytes)` - 分配原始内存**\n```hemlock\nlet p = alloc(1024);  // 分配 1KB，返回 ptr\n// ... 使用内存\nfree(p);\n```\n\n**`buffer(size)` - 分配安全 buffer**\n```hemlock\nlet buf = buffer(256);  // 分配 256 字节 buffer\nbuf[0] = 65;            // 'A'\nbuf[1] = 66;            // 'B'\nfree(buf);\n```\n\n**`free(ptr)` - 释放内存**\n```hemlock\nlet p = alloc(100);\nfree(p);  // 必须释放以避免内存泄漏\n\nlet buf = buffer(100);\nfree(buf);  // 对 ptr 和 buffer 都有效\n```\n\n**重要：** `free()` 对 `ptr` 和 `buffer` 类型都有效。\n\n### 内存操作\n\n**`memset(ptr, byte, size)` - 填充内存**\n```hemlock\nlet p = alloc(100);\nmemset(p, 0, 100);     // 将 100 字节清零\nmemset(p, 65, 10);     // 将前 10 字节填充为 'A'\nfree(p);\n```\n\n**`memcpy(dest, src, size)` - 复制内存**\n```hemlock\nlet src = alloc(50);\nlet dst = alloc(50);\nmemset(src, 42, 50);\nmemcpy(dst, src, 50);  // 从 src 复制 50 字节到 dst\nfree(src);\nfree(dst);\n```\n\n**`realloc(ptr, size)` - 调整分配大小**\n```hemlock\nlet p = alloc(100);\n// ... 使用 100 字节\np = realloc(p, 200);   // 调整为 200 字节\n// ... 使用 200 字节\nfree(p);\n```\n\n**注意：** `realloc()` 后，旧指针可能无效。始终使用返回的指针。\n\n### 类型化分配\n\nHemlock 提供类型化分配辅助函数以方便使用：\n\n```hemlock\nlet arr = talloc(i32, 100);  // 分配 100 个 i32 值（400 字节）\nlet size = sizeof(i32);      // 返回 4（字节）\n```\n\n**`sizeof(type)`** 返回类型的字节大小：\n- `sizeof(i8)` / `sizeof(u8)` -> 1\n- `sizeof(i16)` / `sizeof(u16)` -> 2\n- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` -> 4\n- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` -> 8\n- `sizeof(ptr)` -> 8（64 位系统）\n\n**`talloc(type, count)`** 分配 `count` 个 `type` 类型的元素：\n\n```hemlock\nlet ints = talloc(i32, 10);   // 40 字节用于 10 个 i32 值\nlet floats = talloc(f64, 5);  // 40 字节用于 5 个 f64 值\nfree(ints);\nfree(floats);\n```\n\n## 常见模式\n\n### 模式：分配、使用、释放\n\n内存管理的基本模式：\n\n```hemlock\n// 1. 分配\nlet data = alloc(1024);\n\n// 2. 使用\nmemset(data, 0, 1024);\n// ... 做工作\n\n// 3. 释放\nfree(data);\n```\n\n### 模式：安全 Buffer 使用\n\n优先使用 buffer 进行边界检查访问：\n\n```hemlock\nlet buf = buffer(256);\n\n// 安全迭代\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\nfree(buf);\n```\n\n### 模式：使用 try/finally 管理资源\n\n即使出错也确保清理：\n\n```hemlock\nlet data = alloc(1024);\ntry {\n    // ... 风险操作\n    process(data);\n} finally {\n    free(data);  // 即使出错也会释放\n}\n```\n\n## 内存安全注意事项\n\n### 双重释放\n\n**允许但会崩溃：**\n```hemlock\nlet p = alloc(100);\nfree(p);\nfree(p);  // 崩溃：检测到双重释放\n```\n\n**预防：**\n```hemlock\nlet p = alloc(100);\nfree(p);\np = null;  // 释放后设为 null\n\nif (p != null) {\n    free(p);  // 不会执行\n}\n```\n\n### 悬空指针\n\n**允许但未定义行为：**\n```hemlock\nlet p = alloc(100);\n*p = 42;      // 正确\nfree(p);\nlet x = *p;   // 未定义：读取已释放内存\n```\n\n**预防：** 释放后不要访问内存。\n\n### 内存泄漏\n\n**容易创建，难以调试：**\n```hemlock\nfn leak_memory() {\n    let p = alloc(1000);\n    // 忘记释放！\n    return;  // 内存泄漏\n}\n```\n\n**预防：** 始终将 `alloc()` 与 `free()` 配对：\n```hemlock\nfn safe_function() {\n    let p = alloc(1000);\n    try {\n        // ... 使用 p\n    } finally {\n        free(p);  // 总是释放\n    }\n}\n```\n\n### 指针算术\n\n**允许但危险：**\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // 远超分配边界\n*q = 42;          // 未定义：越界写入\nfree(p);\n```\n\n**使用 buffer 进行边界检查：**\n```hemlock\nlet buf = buffer(10);\nbuf[100] = 42;  // 错误：边界检查阻止溢出\n```\n\n## 最佳实践\n\n1. **默认使用 `buffer`** - 除非特别需要原始 `ptr` 否则使用 `buffer`\n2. **匹配 alloc/free** - 每个 `alloc()` 应该有且仅有一个 `free()`\n3. **使用 try/finally** - 使用异常处理确保清理\n4. **释放后置空** - 释放后将指针设为 `null` 以捕获释放后使用\n5. **边界检查** - 使用 buffer 索引进行自动边界检查\n6. **记录所有权** - 明确哪些代码拥有并释放每个分配\n\n## 示例\n\n### 示例：动态字符串构建器\n\n```hemlock\nfn build_message(count: i32): ptr {\n    let size = count * 10;\n    let buf = alloc(size);\n\n    let i = 0;\n    while (i < count) {\n        memset(buf + (i * 10), 65 + i, 10);\n        i = i + 1;\n    }\n\n    return buf;  // 调用者必须释放\n}\n\nlet msg = build_message(5);\n// ... 使用 msg\nfree(msg);\n```\n\n### 示例：安全数组操作\n\n```hemlock\nfn process_array(size: i32) {\n    let arr = buffer(size);\n\n    try {\n        // 填充数组\n        let i = 0;\n        while (i < arr.length) {\n            arr[i] = i * 2;\n            i = i + 1;\n        }\n\n        // 处理\n        i = 0;\n        while (i < arr.length) {\n            print(arr[i]);\n            i = i + 1;\n        }\n    } finally {\n        free(arr);  // 总是清理\n    }\n}\n```\n\n### 示例：内存池模式\n\n```hemlock\n// 简单内存池（简化版）\nlet pool = alloc(10000);\nlet pool_offset = 0;\n\nfn pool_alloc(size: i32): ptr {\n    if (pool_offset + size > 10000) {\n        throw \"Pool exhausted\";\n    }\n\n    let ptr = pool + pool_offset;\n    pool_offset = pool_offset + size;\n    return ptr;\n}\n\n// 使用池\nlet p1 = pool_alloc(100);\nlet p2 = pool_alloc(200);\n\n// 一次性释放整个池\nfree(pool);\n```\n\n## 限制\n\n需要注意的当前限制：\n\n- **原始指针需要手动释放** - `alloc()` 返回没有引用计数的 `ptr`\n- **无自定义分配器** - 只有系统 malloc/free\n\n**注意：** 引用计数类型（string, array, object, buffer）在作用域退出时自动释放。只有来自 `alloc()` 的原始 `ptr` 需要显式 `free()`。\n\n## 相关主题\n\n- [字符串](#language-guide-strings) - 字符串内存管理和 UTF-8 编码\n- [数组](#language-guide-arrays) - 动态数组及其内存特性\n- [对象](#language-guide-objects) - 对象分配和生命周期\n- [错误处理](#language-guide-error-handling) - 使用 try/finally 进行清理\n\n## 另请参阅\n\n- **设计理念**：参见 CLAUDE.md 中的 \"Memory Management\" 部分\n- **类型系统**：参见 [类型](#language-guide-types) 了解 `ptr` 和 `buffer` 类型详情\n- **FFI**：原始指针对外部函数接口至关重要\n"}, "语言指南 -> 函数": {"id": "language-guide-functions", "content": "# 函数\n\nHemlock 中的函数是**一等公民**，可以赋值给变量、作为参数传递以及从其他函数返回。本指南涵盖函数语法、闭包、递归和高级模式。\n\n## 概述\n\n```hemlock\n// 命名函数语法\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\n// 匿名函数\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\n// 闭包\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nprint(add5(3));  // 8\n```\n\n## 函数声明\n\n### 命名函数\n\n```hemlock\nfn greet(name: string): string {\n    return \"Hello, \" + name;\n}\n\nlet msg = greet(\"Alice\");  // \"Hello, Alice\"\n```\n\n**组成部分：**\n- `fn` - 函数关键字\n- `greet` - 函数名\n- `(name: string)` - 带可选类型的参数\n- `: string` - 可选的返回类型\n- `{ ... }` - 函数体\n\n### 匿名函数\n\n没有名称的函数，赋值给变量：\n\n```hemlock\nlet square = fn(x) {\n    return x * x;\n};\n\nprint(square(5));  // 25\n```\n\n**命名函数 vs 匿名函数：**\n```hemlock\n// 这两种方式等价：\nfn add(a, b) { return a + b; }\n\nlet add = fn(a, b) { return a + b; };\n```\n\n**注意：** 命名函数会被解语法糖为带匿名函数的变量赋值。\n\n## 参数\n\n### 基本参数\n\n```hemlock\nfn example(a, b, c) {\n    return a + b + c;\n}\n\nlet result = example(1, 2, 3);  // 6\n```\n\n### 类型注解\n\n参数的可选类型注解：\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);      // OK\nadd(5, 10.5);    // 运行时类型检查会提升为 f64\n```\n\n**类型检查：**\n- 如果有注解，参数类型在调用时检查\n- 隐式类型转换遵循标准提升规则\n- 类型不匹配会导致运行时错误\n\n### 按值传递\n\n所有参数都是**复制**的（按值传递）：\n\n```hemlock\nfn modify(x) {\n    x = 100;  // 只修改本地副本\n}\n\nlet a = 10;\nmodify(a);\nprint(a);  // 仍然是 10（未改变）\n```\n\n**注意：** 对象和数组按引用传递（引用被复制），因此可以修改它们的内容：\n\n```hemlock\nfn modify_array(arr) {\n    arr[0] = 99;  // 修改原始数组\n}\n\nlet a = [1, 2, 3];\nmodify_array(a);\nprint(a[0]);  // 99（已修改）\n```\n\n## 返回值\n\n### Return 语句\n\n```hemlock\nfn get_max(a: i32, b: i32): i32 {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n```\n\n### 返回类型注解\n\n返回值的可选类型注解：\n\n```hemlock\nfn calculate(): f64 {\n    return 3.14159;\n}\n\nfn get_name(): string {\n    return \"Alice\";\n}\n```\n\n**类型检查：**\n- 如果有注解，返回类型在函数返回时检查\n- 类型转换遵循标准提升规则\n\n### 隐式返回\n\n没有返回类型注解的函数隐式返回 `null`：\n\n```hemlock\nfn print_message(msg) {\n    print(msg);\n    // 隐式返回 null\n}\n\nlet result = print_message(\"hello\");  // result 是 null\n```\n\n### 提前返回\n\n```hemlock\nfn find_first_negative(arr) {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // 提前退出\n        }\n    }\n    return -1;  // 未找到\n}\n```\n\n### 无值返回\n\n`return;` 不带值返回 `null`：\n\n```hemlock\nfn maybe_process(value) {\n    if (value < 0) {\n        return;  // 返回 null\n    }\n    return value * 2;\n}\n```\n\n## 一等函数\n\n函数可以像其他值一样被赋值、传递和返回。\n\n### 函数作为变量\n\n```hemlock\nlet operation = fn(x, y) { return x + y; };\n\nprint(operation(5, 3));  // 8\n\n// 重新赋值\noperation = fn(x, y) { return x * y; };\nprint(operation(5, 3));  // 15\n```\n\n### 函数作为参数\n\n```hemlock\nfn apply(f, x) {\n    return f(x);\n}\n\nfn double(n) {\n    return n * 2;\n}\n\nlet result = apply(double, 5);  // 10\n```\n\n### 函数作为返回值\n\n```hemlock\nfn get_operation(op: string) {\n    if (op == \"add\") {\n        return fn(a, b) { return a + b; };\n    } else if (op == \"multiply\") {\n        return fn(a, b) { return a * b; };\n    } else {\n        return fn(a, b) { return 0; };\n    }\n}\n\nlet add = get_operation(\"add\");\nprint(add(5, 3));  // 8\n```\n\n## 闭包\n\n函数捕获其定义环境（词法作用域）。\n\n### 基本闭包\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\nprint(counter());  // 3\n```\n\n**工作原理：**\n- 内部函数从外部作用域捕获 `count`\n- `count` 在返回函数的多次调用间持久化\n- 每次调用 `makeCounter()` 都会创建一个带有自己 `count` 的新闭包\n\n### 带参数的闭包\n\n```hemlock\nfn makeAdder(x) {\n    return fn(y) {\n        return x + y;\n    };\n}\n\nlet add5 = makeAdder(5);\nlet add10 = makeAdder(10);\n\nprint(add5(3));   // 8\nprint(add10(3));  // 13\n```\n\n### 多个闭包\n\n```hemlock\nfn makeOperations(x) {\n    let add = fn(y) { return x + y; };\n    let multiply = fn(y) { return x * y; };\n\n    return { add: add, multiply: multiply };\n}\n\nlet ops = makeOperations(5);\nprint(ops.add(3));       // 8\nprint(ops.multiply(3));  // 15\n```\n\n### 词法作用域\n\n函数可以通过词法作用域访问外部作用域变量：\n\n```hemlock\nlet global = 10;\n\nfn outer() {\n    let outer_var = 20;\n\n    fn inner() {\n        // 可以读取 global 和 outer_var\n        print(global);      // 10\n        print(outer_var);   // 20\n    }\n\n    inner();\n}\n\nouter();\n```\n\n闭包通过引用捕获变量，允许读取和修改外部作用域变量（如上面的 `makeCounter` 示例所示）。\n\n## 递归\n\n函数可以调用自身。\n\n### 基本递归\n\n```hemlock\nfn factorial(n: i32): i32 {\n    if (n <= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\nprint(factorial(5));  // 120\n```\n\n### 互递归\n\n函数可以互相调用：\n\n```hemlock\nfn is_even(n: i32): bool {\n    if (n == 0) {\n        return true;\n    }\n    return is_odd(n - 1);\n}\n\nfn is_odd(n: i32): bool {\n    if (n == 0) {\n        return false;\n    }\n    return is_even(n - 1);\n}\n\nprint(is_even(4));  // true\nprint(is_odd(4));   // false\n```\n\n### 递归数据处理\n\n```hemlock\nfn sum_array(arr: array, index: i32): i32 {\n    if (index >= arr.length) {\n        return 0;\n    }\n    return arr[index] + sum_array(arr, index + 1);\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(sum_array(numbers, 0));  // 15\n```\n\n**注意：** 尚无尾调用优化 - 深度递归可能导致栈溢出。\n\n## 高阶函数\n\n接受或返回其他函数的函数。\n\n### Map 模式\n\n```hemlock\nfn map(arr, f) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        result.push(f(arr[i]));\n        i = i + 1;\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = map(numbers, double);  // [2, 4, 6, 8, 10]\n```\n\n### Filter 模式\n\n```hemlock\nfn filter(arr, predicate) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (predicate(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nfn is_even(x) { return x % 2 == 0; }\n\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = filter(numbers, is_even);  // [2, 4, 6]\n```\n\n### Reduce 模式\n\n```hemlock\nfn reduce(arr, f, initial) {\n    let accumulator = initial;\n    let i = 0;\n    while (i < arr.length) {\n        accumulator = f(accumulator, arr[i]);\n        i = i + 1;\n    }\n    return accumulator;\n}\n\nfn add(a, b) { return a + b; }\n\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = reduce(numbers, add, 0);  // 15\n```\n\n### 函数组合\n\n```hemlock\nfn compose(f, g) {\n    return fn(x) {\n        return f(g(x));\n    };\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\n\nlet double_then_increment = compose(increment, double);\nprint(double_then_increment(5));  // 11 (5*2 + 1)\n```\n\n## 常见模式\n\n### 模式：工厂函数\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```\n\n### 模式：回调函数\n\n```hemlock\nfn process_async(data, callback) {\n    // ... 处理\n    callback(data);\n}\n\nprocess_async(\"test\", fn(result) {\n    print(\"Processing complete: \" + result);\n});\n```\n\n### 模式：部分应用\n\n```hemlock\nfn partial(f, x) {\n    return fn(y) {\n        return f(x, y);\n    };\n}\n\nfn multiply(a, b) {\n    return a * b;\n}\n\nlet double = partial(multiply, 2);\nlet triple = partial(multiply, 3);\n\nprint(double(5));  // 10\nprint(triple(5));  // 15\n```\n\n### 模式：记忆化\n\n```hemlock\nfn memoize(f) {\n    let cache = {};\n\n    return fn(x) {\n        if (cache.has(x)) {\n            return cache[x];\n        }\n\n        let result = f(x);\n        cache[x] = result;\n        return result;\n    };\n}\n\nfn expensive_fibonacci(n) {\n    if (n <= 1) { return n; }\n    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);\n}\n\nlet fast_fib = memoize(expensive_fibonacci);\nprint(fast_fib(10));  // 使用缓存会快很多\n```\n\n## 函数语义\n\n### 返回类型要求\n\n带有返回类型注解的函数**必须**返回值：\n\n```hemlock\nfn get_value(): i32 {\n    // 错误：缺少 return 语句\n}\n\nfn get_value(): i32 {\n    return 42;  // OK\n}\n```\n\n### 类型检查\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 10);        // OK\nadd(5.5, 10.5);    // 提升为 f64，返回 f64\nadd(\"a\", \"b\");     // 运行时错误：类型不匹配\n```\n\n### 作用域规则\n\n```hemlock\nlet global = \"global\";\n\nfn outer() {\n    let outer_var = \"outer\";\n\n    fn inner() {\n        let inner_var = \"inner\";\n        // 可以访问：inner_var、outer_var、global\n    }\n\n    // 可以访问：outer_var、global\n    // 不能访问：inner_var\n}\n\n// 可以访问：global\n// 不能访问：outer_var、inner_var\n```\n\n## 最佳实践\n\n1. **使用类型注解** - 有助于发现错误并记录意图\n2. **保持函数小巧** - 每个函数应只做一件事\n3. **优先使用纯函数** - 尽可能避免副作用\n4. **命名要清晰** - 使用描述性的动词名称\n5. **提前返回** - 使用守卫子句减少嵌套\n6. **记录复杂闭包** - 明确捕获的变量\n7. **避免深度递归** - 尚无尾调用优化\n\n## 常见陷阱\n\n### 陷阱：递归深度\n\n```hemlock\n// 深度递归可能导致栈溢出\nfn count_down(n) {\n    if (n == 0) { return; }\n    count_down(n - 1);\n}\n\ncount_down(100000);  // 可能因栈溢出而崩溃\n```\n\n### 陷阱：修改捕获的变量\n\n```hemlock\nfn make_counter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // 可以读取和修改捕获的变量\n        return count;\n    };\n}\n```\n\n**注意：** 这是可行的，但要注意所有闭包共享同一个捕获的环境。\n\n## 示例\n\n### 示例：函数管道\n\n```hemlock\nfn pipeline(value, ...functions) {\n    let result = value;\n    for (f in functions) {\n        result = f(result);\n    }\n    return result;\n}\n\nfn double(x) { return x * 2; }\nfn increment(x) { return x + 1; }\nfn square(x) { return x * x; }\n\nlet result = pipeline(3, double, increment, square);\nprint(result);  // 49 ((3*2+1)^2)\n```\n\n### 示例：事件处理器\n\n```hemlock\nlet handlers = [];\n\nfn on_event(name: string, handler) {\n    handlers.push({ name: name, handler: handler });\n}\n\nfn trigger_event(name: string, data) {\n    let i = 0;\n    while (i < handlers.length) {\n        if (handlers[i].name == name) {\n            handlers[i].handler(data);\n        }\n        i = i + 1;\n    }\n}\n\non_event(\"click\", fn(data) {\n    print(\"Clicked: \" + data);\n});\n\ntrigger_event(\"click\", \"button1\");\n```\n\n### 示例：自定义比较器排序\n\n```hemlock\nfn sort(arr, compare) {\n    // 使用自定义比较器的冒泡排序\n    let n = arr.length;\n    let i = 0;\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (compare(arr[j], arr[j + 1]) > 0) {\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nfn ascending(a, b) {\n    if (a < b) { return -1; }\n    if (a > b) { return 1; }\n    return 0;\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers, ascending);\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## 可选参数（默认参数）\n\n函数可以使用 `?:` 语法定义带默认值的可选参数：\n\n```hemlock\nfn greet(name, greeting?: \"Hello\") {\n    return greeting + \" \" + name;\n}\n\nprint(greet(\"Alice\"));           // \"Hello Alice\"\nprint(greet(\"Bob\", \"Hi\"));       // \"Hi Bob\"\n\nfn add(a, b?: 10, c?: 100) {\n    return a + b + c;\n}\n\nprint(add(1));          // 111 (1 + 10 + 100)\nprint(add(1, 2));       // 103 (1 + 2 + 100)\nprint(add(1, 2, 3));    // 6   (1 + 2 + 3)\n```\n\n**规则：**\n- 可选参数必须在必需参数之后\n- 默认值可以是任何表达式\n- 省略的参数使用默认值\n\n## 可变参数函数（剩余参数）\n\n函数可以使用剩余参数（`...`）接受可变数量的参数：\n\n```hemlock\nfn sum(...args) {\n    let total = 0;\n    for (arg in args) {\n        total = total + arg;\n    }\n    return total;\n}\n\nprint(sum(1, 2, 3));        // 6\nprint(sum(1, 2, 3, 4, 5));  // 15\nprint(sum());               // 0\n\nfn log(prefix, ...messages) {\n    for (msg in messages) {\n        print(prefix + \": \" + msg);\n    }\n}\n\nlog(\"INFO\", \"Starting\", \"Running\", \"Done\");\n// INFO: Starting\n// INFO: Running\n// INFO: Done\n```\n\n**规则：**\n- 剩余参数必须是最后一个参数\n- 剩余参数将所有剩余参数收集到一个数组中\n- 可以与普通参数和可选参数组合使用\n\n## 函数类型注解\n\n函数类型允许你为函数参数和返回值指定精确的签名：\n\n### 基本函数类型\n\n```hemlock\n// 函数类型语法：fn(param_types): return_type\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\nlet double = fn(n) { return n * 2; };\nlet result = apply(double, 5);  // 10\n```\n\n### 高阶函数类型\n\n```hemlock\n// 返回函数的函数\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\nlet add5 = make_adder(5);\nprint(add5(10));  // 15\n```\n\n### 异步函数类型\n\n```hemlock\n// 异步函数类型\nfn run_task(handler: async fn(): void) {\n    spawn(handler);\n}\n\nrun_task(async fn() {\n    print(\"Running async!\");\n});\n```\n\n### 函数类型别名\n\n```hemlock\n// 创建命名函数类型以提高清晰度\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\nfn filter_with(arr: array, pred: Predicate): array {\n    return arr.filter(pred);\n}\n```\n\n## Const 参数\n\n`const` 修饰符防止在函数内修改参数：\n\n### 基本 Const 参数\n\n```hemlock\nfn print_all(const items: array) {\n    // items.push(4);  // 错误：不能修改 const 参数\n    for (item in items) {\n        print(item);   // OK：允许读取\n    }\n}\n\nlet nums = [1, 2, 3];\nprint_all(nums);\n```\n\n### 深度不可变性\n\nConst 参数强制深度不可变性 - 不能通过任何路径进行修改：\n\n```hemlock\nfn describe(const person: object) {\n    print(person.name);       // OK：允许读取\n    // person.name = \"Bob\";   // 错误：不能修改\n    // person.address.city = \"NYC\";  // 错误：深度 const\n}\n```\n\n### Const 阻止的操作\n\n| 类型 | 被 Const 阻止 | 允许的 |\n|------|--------------|-------|\n| array | push, pop, shift, unshift, insert, remove, clear, reverse | slice, concat, map, filter, find, contains |\n| object | 字段赋值 | 字段读取 |\n| buffer | 索引赋值 | 索引读取 |\n| string | 索引赋值 | 所有方法（返回新字符串） |\n\n## 命名参数\n\n函数可以使用命名参数调用以提高清晰度和灵活性：\n\n### 基本命名参数\n\n```hemlock\nfn create_user(name: string, age?: 18, active?: true) {\n    print(name + \" is \" + age + \" years old\");\n}\n\n// 位置参数（传统方式）\ncreate_user(\"Alice\", 25, false);\n\n// 命名参数 - 可以任意顺序\ncreate_user(name: \"Bob\", age: 30);\ncreate_user(age: 25, name: \"Charlie\", active: false);\n```\n\n### 混合位置参数和命名参数\n\n```hemlock\n// 通过命名来跳过可选参数\ncreate_user(\"David\", active: false);  // 使用默认 age=18\n\n// 命名参数必须在位置参数之后\ncreate_user(\"Eve\", age: 21);          // OK\n// create_user(name: \"Bad\", 25);      // 错误：位置参数在命名参数之后\n```\n\n### 命名参数规则\n\n- 使用 `name: value` 语法表示命名参数\n- 命名参数可以在位置参数之后以任意顺序出现\n- 位置参数不能跟在命名参数之后\n- 与默认/可选参数配合使用\n- 未知的参数名会导致运行时错误\n\n## 限制\n\n需要注意的当前限制：\n\n- **无按引用传递** - `ref` 关键字已解析但未实现\n- **无函数重载** - 每个名称只能有一个函数\n- **无尾调用优化** - 深度递归受栈大小限制\n\n## 相关主题\n\n- [Control Flow](#language-guide-control-flow) - 函数与控制结构的配合使用\n- [Objects](#language-guide-objects) - 方法是存储在对象中的函数\n- [Error Handling](#language-guide-error-handling) - 函数和异常处理\n- [Types](#language-guide-types) - 类型注解和转换\n\n## 另请参阅\n\n- **闭包**：参见 CLAUDE.md 中的\"Functions\"部分了解闭包语义\n- **一等公民**：函数是与其他值一样的值\n- **词法作用域**：函数捕获其定义环境\n"}, "语言指南 -> 字符(Rune)": {"id": "language-guide-runes", "content": "# Rune 字符\n\nRune 表示 **Unicode 码点**（U+0000 到 U+10FFFF），作为 Hemlock 中字符操作的独立类型。与字节（u8）不同，rune 是完整的 Unicode 字符，可以表示任何语言的字符或表情符号。\n\n## 概述\n\n```hemlock\nlet ch = 'A';           // Rune 字面量\nlet emoji = '🚀';       // 多字节字符作为单个 rune\nprint(ch);              // 'A'\nprint(emoji);           // U+1F680\n\nlet s = \"Hello \" + '!'; // 字符串 + rune 连接\nlet r = '>' + \" msg\";   // Rune + 字符串连接\n```\n\n## 什么是 Rune？\n\nRune 是表示 Unicode 码点的 **32 位值**：\n\n- **范围：** 0 到 0x10FFFF（1,114,111 个有效码点）\n- **不是数值类型** - 用于字符表示\n- **与 u8/char 不同** - Rune 是完整的 Unicode，u8 只是字节\n- **字符串索引返回** - `str[0]` 返回 rune，而不是字节\n\n**为什么使用 rune？**\n- Hemlock 字符串是 UTF-8 编码的\n- 单个 Unicode 字符在 UTF-8 中可能是 1-4 个字节\n- Rune 允许处理完整字符，而不是部分字节\n\n## Rune 字面量\n\n### 基本语法\n\n单引号表示 rune 字面量：\n\n```hemlock\nlet a = 'A';            // ASCII 字符\nlet b = '0';            // 数字字符\nlet c = '!';            // 标点符号\nlet d = ' ';            // 空格\n```\n\n### 多字节 UTF-8 字符\n\nRune 可以表示任何 Unicode 字符：\n\n```hemlock\n// 表情符号\nlet rocket = '🚀';      // 表情符号（U+1F680）\nlet heart = '❤';        // 心形（U+2764）\nlet smile = '😀';       // 笑脸（U+1F600）\n\n// CJK 字符\nlet chinese = '中';     // 中文（U+4E2D）\nlet japanese = 'あ';    // 平假名（U+3042）\nlet korean = '한';      // 韩文（U+D55C）\n\n// 符号\nlet check = '✓';        // 对勾（U+2713）\nlet arrow = '→';        // 右箭头（U+2192）\n```\n\n### 转义序列\n\n特殊字符的常用转义序列：\n\n```hemlock\nlet newline = '\\n';     // 换行符（U+000A）\nlet tab = '\\t';         // 制表符（U+0009）\nlet backslash = '\\\\';   // 反斜杠（U+005C）\nlet quote = '\\'';       // 单引号（U+0027）\nlet dquote = '\"';       // 双引号（U+0022）\nlet null_char = '\\0';   // 空字符（U+0000）\nlet cr = '\\r';          // 回车符（U+000D）\n```\n\n**可用的转义序列：**\n- `\\n` - 换行符\n- `\\t` - 水平制表符\n- `\\r` - 回车符\n- `\\0` - 空字符\n- `\\\\` - 反斜杠\n- `\\'` - 单引号\n- `\\\"` - 双引号\n\n### Unicode 转义\n\n使用 `\\u{XXXXXX}` 语法表示 Unicode 码点（最多 6 个十六进制数字）：\n\n```hemlock\nlet rocket = '\\u{1F680}';   // 🚀 通过 Unicode 转义表示的表情符号\nlet heart = '\\u{2764}';     // ❤ 心形\nlet ascii = '\\u{41}';       // 'A' 通过转义表示\nlet max = '\\u{10FFFF}';     // 最大 Unicode 码点\n\n// 前导零是可选的\nlet a = '\\u{41}';           // 与 '\\u{0041}' 相同\nlet b = '\\u{0041}';\n```\n\n**规则：**\n- 范围：`\\u{0}` 到 `\\u{10FFFF}`\n- 十六进制数字：1 到 6 位\n- 不区分大小写：`\\u{1F680}` 或 `\\u{1f680}`\n- 超出有效 Unicode 范围的值会导致错误\n\n## 字符串 + Rune 连接\n\nRune 可以与字符串连接：\n\n```hemlock\n// 字符串 + rune\nlet greeting = \"Hello\" + '!';       // \"Hello!\"\nlet decorated = \"Text\" + '✓';       // \"Text✓\"\n\n// Rune + 字符串\nlet prefix = '>' + \" Message\";      // \"> Message\"\nlet bullet = '•' + \" Item\";         // \"• Item\"\n\n// 多重连接\nlet msg = \"Hi \" + '👋' + \" World \" + '🌍';  // \"Hi 👋 World 🌍\"\n\n// 方法链可以使用\nlet result = ('>' + \" Important\").to_upper();  // \"> IMPORTANT\"\n```\n\n**工作原理：**\n- Rune 自动编码为 UTF-8\n- 在连接过程中转换为字符串\n- 字符串连接运算符透明地处理这一点\n\n## 类型转换\n\nRune 可以与其他类型相互转换。\n\n### 整数 ↔ Rune\n\n在整数和 rune 之间转换以处理码点值：\n\n```hemlock\n// 整数到 rune（码点值）\nlet code: rune = 65;            // 'A'（ASCII 65）\nlet emoji_code: rune = 128640;  // U+1F680（🚀）\n\n// Rune 到整数（获取码点值）\nlet r = 'Z';\nlet value: i32 = r;             // 90（ASCII 值）\n\nlet rocket = '🚀';\nlet code: i32 = rocket;         // 128640（U+1F680）\n```\n\n**范围检查：**\n- 整数到 rune：必须在 [0, 0x10FFFF] 范围内\n- 超出范围的值会导致运行时错误\n- Rune 到整数：始终成功（返回码点）\n\n### Rune → 字符串\n\nRune 可以显式转换为字符串：\n\n```hemlock\n// 显式转换\nlet ch: string = 'H';           // \"H\"\nlet emoji: string = '🚀';       // \"🚀\"\n\n// 连接时自动转换\nlet s = \"\" + 'A';               // \"A\"\nlet s2 = \"x\" + 'y' + \"z\";       // \"xyz\"\n```\n\n### u8（字节）→ Rune\n\n任何 u8 值（0-255）都可以转换为 rune：\n\n```hemlock\n// ASCII 范围（0-127）\nlet byte: u8 = 65;\nlet rune_val: rune = byte;      // 'A'\n\n// 扩展 ASCII / Latin-1（128-255）\nlet extended: u8 = 200;\nlet r: rune = extended;         // U+00C8（È）\n\n// 注意：0-127 是 ASCII，128-255 是 Latin-1\n```\n\n### 链式转换\n\n类型转换可以链式进行：\n\n```hemlock\n// i32 → rune → string\nlet code: i32 = 128512;         // 笑脸码点\nlet r: rune = code;             // 😀\nlet s: string = r;              // \"😀\"\n\n// 在一个表达式中完成\nlet emoji: string = 128640;     // 隐式 i32 → rune → string（🚀）\n```\n\n## Rune 操作\n\n### 打印\n\nRune 的显示方式取决于码点：\n\n```hemlock\nlet ascii = 'A';\nprint(ascii);                   // 'A'（带引号，可打印 ASCII）\n\nlet emoji = '🚀';\nprint(emoji);                   // U+1F680（非 ASCII 的 Unicode 表示法）\n\nlet tab = '\\t';\nprint(tab);                     // U+0009（不可打印字符用十六进制表示）\n\nlet space = ' ';\nprint(space);                   // ' '（可打印）\n```\n\n**打印格式：**\n- 可打印 ASCII（32-126）：带引号的字符 `'A'`\n- 不可打印或 Unicode：十六进制表示法 `U+XXXX`\n\n### 类型检查\n\n使用 `typeof()` 检查值是否为 rune：\n\n```hemlock\nlet r = '🚀';\nprint(typeof(r));               // \"rune\"\n\nlet s = \"text\";\nlet ch = s[0];\nprint(typeof(ch));              // \"rune\"（索引返回 rune）\n\nlet num = 65;\nprint(typeof(num));             // \"i32\"\n```\n\n### 比较\n\nRune 可以进行相等性比较：\n\n```hemlock\nlet a = 'A';\nlet b = 'B';\nprint(a == a);                  // true\nprint(a == b);                  // false\n\n// 区分大小写\nlet upper = 'A';\nlet lower = 'a';\nprint(upper == lower);          // false\n\n// Rune 可以与整数比较（码点值）\nprint(a == 65);                 // true（隐式转换）\nprint('🚀' == 128640);          // true\n```\n\n**比较运算符：**\n- `==` - 相等\n- `!=` - 不相等\n- `<`、`>`、`<=`、`>=` - 码点顺序\n\n```hemlock\nprint('A' < 'B');               // true（65 < 66）\nprint('a' > 'Z');               // true（97 > 90）\n```\n\n## 处理字符串索引\n\n字符串索引返回 rune，而不是字节：\n\n```hemlock\nlet s = \"Hello🚀\";\nlet h = s[0];                   // 'H'（rune）\nlet rocket = s[5];              // '🚀'（rune）\n\nprint(typeof(h));               // \"rune\"\nprint(typeof(rocket));          // \"rune\"\n\n// 如果需要可转换为字符串\nlet h_str: string = h;          // \"H\"\nlet rocket_str: string = rocket; // \"🚀\"\n```\n\n**重要：** 字符串索引使用码点位置，而不是字节偏移：\n\n```hemlock\nlet text = \"Hi🚀!\";\n// 码点位置：0='H', 1='i', 2='🚀', 3='!'\n// 字节位置：0='H', 1='i', 2-5='🚀', 6='!'\n\nlet r = text[2];                // '🚀'（码点 2）\nprint(typeof(r));               // \"rune\"\n```\n\n## 示例\n\n### 示例：字符分类\n\n```hemlock\nfn is_digit(r: rune): bool {\n    return r >= '0' && r <= '9';\n}\n\nfn is_upper(r: rune): bool {\n    return r >= 'A' && r <= 'Z';\n}\n\nfn is_lower(r: rune): bool {\n    return r >= 'a' && r <= 'z';\n}\n\nprint(is_digit('5'));           // true\nprint(is_upper('A'));           // true\nprint(is_lower('z'));           // true\n```\n\n### 示例：大小写转换\n\n```hemlock\nfn to_upper_rune(r: rune): rune {\n    if (r >= 'a' && r <= 'z') {\n        // 转换为大写（减去 32）\n        let code: i32 = r;\n        code = code - 32;\n        return code;\n    }\n    return r;\n}\n\nfn to_lower_rune(r: rune): rune {\n    if (r >= 'A' && r <= 'Z') {\n        // 转换为小写（加上 32）\n        let code: i32 = r;\n        code = code + 32;\n        return code;\n    }\n    return r;\n}\n\nprint(to_upper_rune('a'));      // 'A'\nprint(to_lower_rune('Z'));      // 'z'\n```\n\n### 示例：字符迭代\n\n```hemlock\nfn print_chars(s: string) {\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        print(\"Position \" + typeof(i) + \": \" + typeof(ch));\n        i = i + 1;\n    }\n}\n\nprint_chars(\"Hi🚀\");\n// Position 0: 'H'\n// Position 1: 'i'\n// Position 2: U+1F680\n```\n\n### 示例：从 Rune 构建字符串\n\n```hemlock\nfn repeat_char(ch: rune, count: i32): string {\n    let result = \"\";\n    let i = 0;\n    while (i < count) {\n        result = result + ch;\n        i = i + 1;\n    }\n    return result;\n}\n\nlet line = repeat_char('=', 40);  // \"========================================\"\nlet stars = repeat_char('⭐', 5);  // \"⭐⭐⭐⭐⭐\"\n```\n\n## 常见模式\n\n### 模式：字符过滤\n\n```hemlock\nfn filter_digits(s: string): string {\n    let result = \"\";\n    let i = 0;\n    while (i < s.length) {\n        let ch = s[i];\n        if (ch >= '0' && ch <= '9') {\n            result = result + ch;\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet text = \"abc123def456\";\nlet digits = filter_digits(text);  // \"123456\"\n```\n\n### 模式：字符计数\n\n```hemlock\nfn count_char(s: string, target: rune): i32 {\n    let count = 0;\n    let i = 0;\n    while (i < s.length) {\n        if (s[i] == target) {\n            count = count + 1;\n        }\n        i = i + 1;\n    }\n    return count;\n}\n\nlet text = \"hello world\";\nlet l_count = count_char(text, 'l');  // 3\nlet o_count = count_char(text, 'o');  // 2\n```\n\n## 最佳实践\n\n1. **对字符操作使用 rune** - 不要尝试用字节处理文本\n2. **字符串索引返回 rune** - 记住 `str[i]` 给你的是 rune\n3. **Unicode 感知的比较** - Rune 可以处理任何 Unicode 字符\n4. **需要时进行转换** - Rune 可以轻松转换为字符串和整数\n5. **用表情符号测试** - 始终用多字节字符测试字符操作\n\n## 常见陷阱\n\n### 陷阱：Rune 与字节混淆\n\n```hemlock\n// 不要：将 rune 当作字节\nlet r: rune = '🚀';\nlet b: u8 = r;              // 错误：Rune 码点 128640 无法放入 u8\n\n// 要：使用适当的转换\nlet r: rune = '🚀';\nlet code: i32 = r;          // 可以：128640\n```\n\n### 陷阱：字符串字节索引\n\n```hemlock\n// 不要：假设字节索引\nlet s = \"🚀\";\nlet byte = s.byte_at(0);    // 240（第一个 UTF-8 字节，不是完整字符）\n\n// 要：使用码点索引\nlet s = \"🚀\";\nlet rune = s[0];            // '🚀'（完整字符）\nlet rune2 = s.char_at(0);   // '🚀'（显式方法）\n```\n\n## 相关主题\n\n- [字符串](#language-guide-strings) - 字符串操作和 UTF-8 处理\n- [类型](#language-guide-types) - 类型系统和转换\n- [控制流](#language-guide-control-flow) - 在比较中使用 rune\n\n## 另请参阅\n\n- **Unicode 标准**：Unicode 码点由 Unicode 联盟定义\n- **UTF-8 编码**：有关 UTF-8 详细信息，请参阅[字符串](#language-guide-strings)\n- **类型转换**：有关转换规则，请参阅[类型](#language-guide-types)\n"}, "语言指南 -> 字符串": {"id": "language-guide-strings", "content": "# 字符串\n\nHemlock 字符串是**UTF-8 优先的可变序列**，具有完整的 Unicode 支持和丰富的文本处理方法。与许多语言不同，Hemlock 字符串是可变的，并且原生支持 Unicode 码点操作。\n\n## 概述\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // 使用 rune 修改（现在是 \"Hello\"）\nprint(s.length);        // 5（码点数量）\nlet c = s[0];           // 返回 rune（Unicode 码点）\nlet msg = s + \" world\"; // 连接\nlet emoji = \"🚀\";\nprint(emoji.length);    // 1（一个码点）\nprint(emoji.byte_length); // 4（四个 UTF-8 字节）\n```\n\n## 属性\n\nHemlock 字符串具有以下关键特性：\n\n- **UTF-8 编码** - 完整的 Unicode 支持（U+0000 到 U+10FFFF）\n- **可变** - 与 Python、JavaScript 和 Java 的字符串不同\n- **基于码点的索引** - 返回 `rune`（Unicode 码点），而非字节\n- **堆分配** - 带有内部容量跟踪\n- **两个长度属性**：\n  - `.length` - 码点数量（字符数）\n  - `.byte_length` - 字节数量（UTF-8 编码大小）\n\n## UTF-8 行为\n\n所有字符串操作都使用**码点**（字符），而非字节：\n\n```hemlock\nlet text = \"Hello🚀World\";\nprint(text.length);        // 11（码点）\nprint(text.byte_length);   // 15（字节，emoji 是 4 字节）\n\n// 索引使用码点\nlet h = text[0];           // 'H'（rune）\nlet rocket = text[5];      // '🚀'（rune）\n```\n\n**多字节字符计为一个：**\n```hemlock\n\"Hello\".length;      // 5\n\"🚀\".length;         // 1（一个 emoji）\n\"你好\".length;       // 2（两个中文字符）\n\"café\".length;       // 4（é 是一个码点）\n```\n\n## 字符串字面量\n\n```hemlock\n// 基本字符串\nlet s1 = \"hello\";\nlet s2 = \"world\";\n\n// 带有转义序列\nlet s3 = \"Line 1\\nLine 2\\ttabbed\";\nlet s4 = \"Quote: \\\"Hello\\\"\";\nlet s5 = \"Backslash: \\\\\";\n\n// Unicode 字符\nlet s6 = \"🚀 Emoji\";\nlet s7 = \"中文字符\";\n```\n\n## 模板字符串（字符串插值）\n\n使用反引号创建带有嵌入表达式的模板字符串：\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\n\n// 基本插值\nlet greeting = `Hello, ${name}!`;           // \"Hello, Alice!\"\nlet info = `${name} is ${age} years old`;   // \"Alice is 30 years old\"\n\n// 插值中的表达式\nlet x = 5;\nlet y = 10;\nlet sum = `${x} + ${y} = ${x + y}`;         // \"5 + 10 = 15\"\n\n// 方法调用\nlet upper = `Name: ${name.to_upper()}`;     // \"Name: ALICE\"\n\n// 嵌套对象\nlet person = { name: \"Bob\", city: \"NYC\" };\nlet desc = `${person.name} lives in ${person.city}`;  // \"Bob lives in NYC\"\n\n// 多行（保留换行符）\nlet multi = `Line 1\nLine 2\nLine 3`;\n```\n\n**模板字符串特性：**\n- `${...}` 内的表达式会被求值并转换为字符串\n- 可以使用任何有效表达式（变量、函数调用、算术运算）\n- 反引号字符串支持与普通字符串相同的转义序列\n- 用于构建动态字符串而无需连接操作\n\n### 模板字符串中的转义\n\n要在模板字符串中包含字面量 `${`，请转义美元符号：\n\n```hemlock\nlet price = 100;\nlet text = `Price: \\${price} or ${price}`;\n// \"Price: ${price} or 100\"\n\n// 字面量反引号\nlet code = `Use \\` for template strings`;\n// \"Use ` for template strings\"\n```\n\n### 复杂表达式\n\n模板字符串可以包含任何有效表达式：\n\n```hemlock\n// 类三元表达式\nlet age = 25;\nlet status = `Status: ${age >= 18 ? \"adult\" : \"minor\"}`;\n\n// 数组访问\nlet items = [\"apple\", \"banana\", \"cherry\"];\nlet first = `First item: ${items[0]}`;\n\n// 带参数的函数调用\nfn format_price(p) { return \"$\" + p; }\nlet msg = `Total: ${format_price(99.99)}`;  // \"Total: $99.99\"\n\n// 链式方法调用\nlet name = \"alice\";\nlet formatted = `Hello, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;\n// \"Hello, Alice!\"\n```\n\n### 模板字符串与连接对比\n\n模板字符串通常比连接更清晰：\n\n```hemlock\n// 连接（较难阅读）\nlet msg1 = \"Hello, \" + name + \"! You have \" + count + \" messages.\";\n\n// 模板字符串（更易阅读）\nlet msg2 = `Hello, ${name}! You have ${count} messages.`;\n```\n\n## 索引和修改\n\n### 读取字符\n\n索引返回 `rune`（Unicode 码点）：\n\n```hemlock\nlet s = \"Hello\";\nlet first = s[0];      // 'H'（rune）\nlet last = s[4];       // 'o'（rune）\n\n// UTF-8 示例\nlet emoji = \"Hi🚀!\";\nlet rocket = emoji[2];  // '🚀'（码点索引 2 处的 rune）\n```\n\n### 写入字符\n\n字符串是可变的 - 可以修改单个字符：\n\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';            // 现在是 \"Hello\"\ns[4] = '!';            // 现在是 \"Hell!\"\n\n// Unicode 示例\nlet msg = \"Go!\";\nmsg[0] = '🚀';         // 现在是 \"🚀o!\"\n```\n\n## 连接\n\n使用 `+` 连接字符串：\n\n```hemlock\nlet greeting = \"Hello\" + \" \" + \"World\";  // \"Hello World\"\n\n// 使用变量\nlet name = \"Alice\";\nlet msg = \"Hi, \" + name + \"!\";  // \"Hi, Alice!\"\n\n// 使用 rune（参见 Runes 文档）\nlet s = \"Hello\" + '!';          // \"Hello!\"\n```\n\n## 字符串方法\n\nHemlock 提供 19 个字符串方法用于全面的文本操作。\n\n### 子字符串和切片\n\n**`substr(start, length)`** - 按位置和长度提取子字符串：\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\"（从 6 开始，长度 5）\nlet first = s.substr(0, 5);     // \"hello\"\n\n// UTF-8 示例\nlet text = \"Hi🚀!\";\nlet emoji = text.substr(2, 1);  // \"🚀\"（位置 2，长度 1）\n```\n\n**`slice(start, end)`** - 按范围提取子字符串（end 不包含在内）：\n```hemlock\nlet s = \"hello world\";\nlet slice = s.slice(0, 5);      // \"hello\"（索引 0 到 4）\nlet slice2 = s.slice(6, 11);    // \"world\"\n```\n\n**区别：**\n- `substr(start, length)` - 使用长度参数\n- `slice(start, end)` - 使用结束索引（不包含）\n\n### 搜索和查找\n\n**`find(needle)`** - 查找首次出现的位置：\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6（首次出现的索引）\nlet pos2 = s.find(\"foo\");       // -1（未找到）\nlet pos3 = s.find(\"l\");         // 2（第一个 'l'）\n```\n\n**`contains(needle)`** - 检查字符串是否包含子字符串：\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n### 分割和修剪\n\n**`split(delimiter)`** - 分割成字符串数组：\n```hemlock\nlet csv = \"apple,banana,cherry\";\nlet parts = csv.split(\",\");     // [\"apple\", \"banana\", \"cherry\"]\n\nlet words = \"one two three\".split(\" \");  // [\"one\", \"two\", \"three\"]\n\n// 空分隔符按字符分割\nlet chars = \"abc\".split(\"\");    // [\"a\", \"b\", \"c\"]\n```\n\n**`trim()`** - 移除前后空白：\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet s2 = \"\\t\\ntext\\n\\t\";\nlet clean2 = s2.trim();         // \"text\"\n```\n\n### 大小写转换\n\n**`to_upper()`** - 转换为大写：\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\n// 保留非 ASCII 字符\nlet s2 = \"café\";\nlet upper2 = s2.to_upper();     // \"CAFÉ\"\n```\n\n**`to_lower()`** - 转换为小写：\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n```\n\n### 前缀/后缀检查\n\n**`starts_with(prefix)`** - 检查是否以前缀开头：\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n**`ends_with(suffix)`** - 检查是否以后缀结尾：\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n### 替换\n\n**`replace(old, new)`** - 替换首次出现：\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");      // \"hello there\"\n\nlet s3 = \"foo foo foo\";\nlet s4 = s3.replace(\"foo\", \"bar\");         // \"bar foo foo\"（仅第一个）\n```\n\n**`replace_all(old, new)`** - 替换所有出现：\n```hemlock\nlet s = \"foo foo foo\";\nlet s2 = s.replace_all(\"foo\", \"bar\");      // \"bar bar bar\"\n\nlet s3 = \"hello world, world!\";\nlet s4 = s3.replace_all(\"world\", \"hemlock\"); // \"hello hemlock, hemlock!\"\n```\n\n### 重复\n\n**`repeat(count)`** - 重复字符串 n 次：\n```hemlock\nlet s = \"ha\";\nlet laugh = s.repeat(3);        // \"hahaha\"\n\nlet line = \"=\".repeat(40);      // \"========================================\"\n```\n\n### 字符和字节访问\n\n**`char_at(index)`** - 获取指定索引处的 Unicode 码点（返回 rune）：\n```hemlock\nlet s = \"hello\";\nlet char = s.char_at(0);        // 'h'（rune）\n\n// UTF-8 示例\nlet emoji = \"🚀\";\nlet rocket = emoji.char_at(0);  // 返回 rune U+1F680\n```\n\n**`chars()`** - 转换为 rune 数组（码点）：\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']（rune 数组）\n\n// UTF-8 示例\nlet text = \"Hi🚀\";\nlet chars2 = text.chars();      // ['H', 'i', '🚀']\n```\n\n**`byte_at(index)`** - 获取指定索引处的字节值（返回 u8）：\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104（'h' 的 ASCII 值）\n\n// UTF-8 示例\nlet emoji = \"🚀\";\nlet first_byte = emoji.byte_at(0);  // 240（第一个 UTF-8 字节）\n```\n\n**`bytes()`** - 转换为字节数组（u8 值）：\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111]（u8 数组）\n\n// UTF-8 示例\nlet emoji = \"🚀\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128]（4 个 UTF-8 字节）\n```\n\n**`to_bytes()`** - 转换为 buffer 以进行底层访问：\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();         // 返回包含 UTF-8 字节的 buffer\nprint(buf.length);              // 5\nfree(buf);                      // 记得释放\n```\n\n## 方法链式调用\n\n所有字符串方法都返回新字符串，支持链式调用：\n\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \")\n    .to_upper();                    // \"FOO | BAR | BAZ\"\n```\n\n## 完整方法参考\n\n| 方法 | 参数 | 返回值 | 描述 |\n|--------|-----------|---------|-------------|\n| `substr(start, length)` | i32, i32 | string | 按位置和长度提取子字符串 |\n| `slice(start, end)` | i32, i32 | string | 按范围提取子字符串（end 不包含在内） |\n| `find(needle)` | string | i32 | 查找首次出现的位置（未找到返回 -1） |\n| `contains(needle)` | string | bool | 检查是否包含子字符串 |\n| `split(delimiter)` | string | array | 分割成字符串数组 |\n| `trim()` | - | string | 移除前后空白 |\n| `to_upper()` | - | string | 转换为大写 |\n| `to_lower()` | - | string | 转换为小写 |\n| `starts_with(prefix)` | string | bool | 检查是否以前缀开头 |\n| `ends_with(suffix)` | string | bool | 检查是否以后缀结尾 |\n| `replace(old, new)` | string, string | string | 替换首次出现 |\n| `replace_all(old, new)` | string, string | string | 替换所有出现 |\n| `repeat(count)` | i32 | string | 重复字符串 n 次 |\n| `char_at(index)` | i32 | rune | 获取指定索引处的码点 |\n| `byte_at(index)` | i32 | u8 | 获取指定索引处的字节值 |\n| `chars()` | - | array | 转换为 rune 数组 |\n| `bytes()` | - | array | 转换为 u8 字节数组 |\n| `to_bytes()` | - | buffer | 转换为 buffer（需要释放） |\n\n## 示例\n\n### 示例：文本处理\n\n```hemlock\nfn process_input(text: string): string {\n    return text\n        .trim()\n        .to_lower()\n        .replace_all(\"  \", \" \");  // 规范化空白\n}\n\nlet input = \"  HELLO   WORLD  \";\nlet clean = process_input(input);  // \"hello world\"\n```\n\n### 示例：CSV 解析器\n\n```hemlock\nfn parse_csv_line(line: string): array {\n    let trimmed = line.trim();\n    let fields = trimmed.split(\",\");\n\n    let result = [];\n    let i = 0;\n    while (i < fields.length) {\n        result.push(fields[i].trim());\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet csv = \"apple, banana , cherry\";\nlet fields = parse_csv_line(csv);  // [\"apple\", \"banana\", \"cherry\"]\n```\n\n### 示例：单词计数器\n\n```hemlock\nfn count_words(text: string): i32 {\n    let words = text.trim().split(\" \");\n    return words.length;\n}\n\nlet sentence = \"The quick brown fox\";\nlet count = count_words(sentence);  // 4\n```\n\n### 示例：字符串验证\n\n```hemlock\nfn is_valid_email(email: string): bool {\n    if (!email.contains(\"@\")) {\n        return false;\n    }\n\n    if (!email.contains(\".\")) {\n        return false;\n    }\n\n    if (email.starts_with(\"@\") || email.ends_with(\"@\")) {\n        return false;\n    }\n\n    return true;\n}\n\nprint(is_valid_email(\"user@example.com\"));  // true\nprint(is_valid_email(\"invalid\"));            // false\n```\n\n## 内存管理\n\n字符串是堆分配的，带有内部引用计数：\n\n- **创建**：在堆上分配，带有容量跟踪\n- **连接**：创建新字符串（旧字符串不变）\n- **方法**：大多数方法返回新字符串\n- **生命周期**：字符串使用引用计数，作用域退出时自动释放\n\n**自动清理：**\n```hemlock\nfn create_strings() {\n    let s = \"hello\";\n    let s2 = s + \" world\";  // 新分配\n}  // 函数返回时 s 和 s2 都自动释放\n```\n\n**注意：** 局部字符串变量在超出作用域时自动清理。仅在需要提前清理（作用域结束前）或处理长期存活/全局数据时使用 `free()`。详见 [内存管理](memory.md#internal-reference-counting)。\n\n## 最佳实践\n\n1. **使用码点索引** - 字符串使用码点位置，而非字节偏移\n2. **使用 Unicode 测试** - 始终使用多字节字符测试字符串操作\n3. **优先使用不可变操作** - 使用返回新字符串的方法，而非直接修改\n4. **检查边界** - 字符串索引不进行边界检查（无效时返回 null/错误）\n5. **规范化输入** - 对用户输入使用 `trim()` 和 `to_lower()`\n\n## 常见陷阱\n\n### 陷阱：字节与码点混淆\n\n```hemlock\nlet emoji = \"🚀\";\nprint(emoji.length);        // 1（码点）\nprint(emoji.byte_length);   // 4（字节）\n\n// 不要混用字节和码点操作\nlet byte = emoji.byte_at(0);  // 240（第一个字节）\nlet char = emoji.char_at(0);  // '🚀'（完整码点）\n```\n\n### 陷阱：修改的意外情况\n\n```hemlock\nlet s1 = \"hello\";\nlet s2 = s1;       // 浅拷贝\ns1[0] = 'H';       // 修改 s1\nprint(s2);         // 仍然是 \"hello\"（字符串是值类型）\n```\n\n## 相关主题\n\n- [Runes](#language-guide-runes) - 字符串索引中使用的 Unicode 码点类型\n- [数组](#language-guide-arrays) - 字符串方法经常返回或使用数组\n- [类型](#language-guide-types) - 字符串类型详情和转换\n\n## 另请参阅\n\n- **UTF-8 编码**：参见 CLAUDE.md 中的 \"Strings\" 部分\n- **类型转换**：参见 [类型](#language-guide-types) 了解字符串转换\n- **内存**：参见 [内存](#language-guide-memory) 了解字符串分配细节\n"}, "语言指南 -> 对象": {"id": "language-guide-objects", "content": "# 对象\n\nHemlock 实现了 JavaScript 风格的对象，具有堆分配、动态字段、方法和鸭子类型。对象是结合数据和行为的灵活数据结构。\n\n## 概述\n\n```hemlock\n// 匿名对象\nlet person = { name: \"Alice\", age: 30, city: \"NYC\" };\nprint(person.name);  // \"Alice\"\n\n// 带方法的对象\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    }\n};\n\ncounter.increment();\nprint(counter.count);  // 1\n```\n\n## 对象字面量\n\n### 基本语法\n\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    city: \"NYC\"\n};\n```\n\n**语法：**\n- 花括号 `{}` 包围对象\n- 键值对用逗号分隔\n- 键是标识符（不需要引号）\n- 值可以是任何类型\n\n### 空对象\n\n```hemlock\nlet obj = {};  // 空对象\n\n// 稍后添加字段\nobj.name = \"Alice\";\nobj.age = 30;\n```\n\n### 嵌套对象\n\n```hemlock\nlet user = {\n    info: {\n        name: \"Bob\",\n        age: 25\n    },\n    active: true,\n    settings: {\n        theme: \"dark\",\n        notifications: true\n    }\n};\n\nprint(user.info.name);           // \"Bob\"\nprint(user.settings.theme);      // \"dark\"\n```\n\n### 混合值类型\n\n```hemlock\nlet mixed = {\n    number: 42,\n    text: \"hello\",\n    flag: true,\n    data: null,\n    items: [1, 2, 3],\n    config: { x: 10, y: 20 }\n};\n```\n\n### 简写属性语法\n\n当变量名与属性名匹配时，使用简写语法：\n\n```hemlock\nlet name = \"Alice\";\nlet age = 30;\nlet active = true;\n\n// 简写：{ name } 等同于 { name: name }\nlet person = { name, age, active };\n\nprint(person.name);   // \"Alice\"\nprint(person.age);    // 30\nprint(person.active); // true\n```\n\n**混合简写和常规属性：**\n```hemlock\nlet city = \"NYC\";\nlet obj = { name, age, city, role: \"admin\" };\n```\n\n### 展开运算符\n\n展开运算符（`...`）将一个对象的所有字段复制到另一个对象中：\n\n```hemlock\nlet base = { x: 1, y: 2 };\nlet extended = { ...base, z: 3 };\n\nprint(extended.x);  // 1\nprint(extended.y);  // 2\nprint(extended.z);  // 3\n```\n\n**使用展开覆盖值：**\n```hemlock\nlet defaults = { theme: \"light\", size: \"medium\", debug: false };\nlet custom = { ...defaults, theme: \"dark\" };\n\nprint(custom.theme);  // \"dark\"（被覆盖）\nprint(custom.size);   // \"medium\"（来自 defaults）\nprint(custom.debug);  // false（来自 defaults）\n```\n\n**多个展开（后面的覆盖前面的）：**\n```hemlock\nlet a = { x: 1 };\nlet b = { y: 2 };\nlet merged = { ...a, ...b, z: 3 };\n\nprint(merged.x);  // 1\nprint(merged.y);  // 2\nprint(merged.z);  // 3\n\n// 后面的展开覆盖前面的\nlet first = { val: \"first\" };\nlet second = { val: \"second\" };\nlet combined = { ...first, ...second };\nprint(combined.val);  // \"second\"\n```\n\n**结合简写和展开：**\n```hemlock\nlet status = \"active\";\nlet data = { id: 1, name: \"Item\" };\nlet full = { ...data, status };\n\nprint(full.id);      // 1\nprint(full.name);    // \"Item\"\nprint(full.status);  // \"active\"\n```\n\n**配置覆盖模式：**\n```hemlock\nlet defaultConfig = {\n    debug: false,\n    timeout: 30,\n    retries: 3\n};\n\nlet prodConfig = { ...defaultConfig, timeout: 60 };\nlet devConfig = { ...defaultConfig, debug: true };\n\nprint(prodConfig.timeout);  // 60\nprint(devConfig.debug);     // true\n```\n\n**注意：** 展开执行浅拷贝。嵌套对象共享引用：\n```hemlock\nlet nested = { inner: { val: 42 } };\nlet copied = { ...nested };\nprint(copied.inner.val);  // 42（与 nested.inner 相同的引用）\n```\n\n## 字段访问\n\n### 点语法\n\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\n\n// 读取字段\nlet name = person.name;      // \"Alice\"\nlet age = person.age;        // 30\n\n// 修改字段\nperson.age = 31;\nprint(person.age);           // 31\n```\n\n### 动态字段添加\n\n在运行时添加新字段：\n\n```hemlock\nlet person = { name: \"Alice\" };\n\n// 添加新字段\nperson.email = \"alice@example.com\";\nperson.phone = \"555-1234\";\n\nprint(person.email);  // \"alice@example.com\"\n```\n\n### 字段删除\n\n**注意：** 目前不支持字段删除。改为设置为 `null`：\n\n```hemlock\nlet obj = { x: 10, y: 20 };\n\n// 无法删除字段（不支持）\n// obj.x = undefined;  // Hemlock 中没有 'undefined'\n\n// 变通方法：设置为 null\nobj.x = null;\n```\n\n## 方法和 `self`\n\n### 定义方法\n\n方法是存储在对象字段中的函数：\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n    decrement: fn() {\n        self.count = self.count - 1;\n    },\n    get: fn() {\n        return self.count;\n    }\n};\n```\n\n### `self` 关键字\n\n当函数作为方法调用时，`self` 自动绑定到对象：\n\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;  // self 指向 counter\n    }\n};\n\ncounter.increment();  // self 绑定到 counter\nprint(counter.count);  // 1\n```\n\n**工作原理：**\n- 通过检查函数表达式是否为属性访问来检测方法调用\n- `self` 在调用时自动绑定到对象\n- `self` 是只读的（无法重新赋值 `self` 本身）\n\n### 方法调用检测\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() {\n        return self.value;\n    }\n};\n\n// 作为方法调用 - self 被绑定\nprint(obj.method());  // 10\n\n// 作为函数调用 - self 为 null（错误）\nlet f = obj.method;\nprint(f());  // 错误：self 未定义\n```\n\n### 带参数的方法\n\n```hemlock\nlet calculator = {\n    result: 0,\n    add: fn(x) {\n        self.result = self.result + x;\n    },\n    multiply: fn(x) {\n        self.result = self.result * x;\n    },\n    get: fn() {\n        return self.result;\n    }\n};\n\ncalculator.add(5);\ncalculator.multiply(2);\nprint(calculator.get());  // 10\n```\n\n## 使用 `define` 进行类型定义\n\n### 基本类型定义\n\n使用 `define` 定义对象结构：\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active: bool,\n}\n\n// 创建对象并赋值给类型化变量\nlet p = { name: \"Alice\", age: 30, active: true };\nlet typed_p: Person = p;  // 鸭子类型验证结构\n\nprint(typeof(typed_p));  // \"Person\"\n```\n\n**`define` 的作用：**\n- 声明具有必需字段的类型\n- 启用鸭子类型验证\n- 为 `typeof()` 设置对象的类型名称\n\n### 鸭子类型\n\n使用**结构兼容性**验证对象是否符合 `define`：\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// 正确：具有所有必需字段\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// 正确：允许额外字段\nlet p2: Person = {\n    name: \"Bob\",\n    age: 25,\n    city: \"NYC\",\n    active: true\n};\n\n// 错误：缺少必需字段 'age'\nlet p3: Person = { name: \"Carol\" };\n\n// 错误：'age' 类型错误\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```\n\n**鸭子类型规则：**\n- 所有必需字段必须存在\n- 字段类型必须匹配\n- 允许额外字段并保留\n- 验证发生在赋值时\n\n### 可选字段\n\n字段可以是可选的，带有默认值：\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,       // 可选，带默认值\n    nickname?: string,   // 可选，默认为 null\n}\n\n// 只有必需字段的对象\nlet p = { name: \"Alice\", age: 30 };\nlet typed_p: Person = p;\n\nprint(typed_p.active);    // true（应用默认值）\nprint(typed_p.nickname);  // null（无默认值）\n\n// 可以覆盖可选字段\nlet p2: Person = { name: \"Bob\", age: 25, active: false };\nprint(p2.active);  // false（被覆盖）\n```\n\n**可选字段语法：**\n- `field?: default_value` - 可选，带默认值\n- `field?: type` - 可选，带类型注解，默认为 null\n- 如果缺少可选字段，在鸭子类型检查时添加\n\n### 类型检查\n\n```hemlock\ndefine Point {\n    x: i32,\n    y: i32,\n}\n\nlet p = { x: 10, y: 20 };\nlet point: Point = p;  // 类型检查发生在这里\n\nprint(typeof(point));  // \"Point\"\nprint(typeof(p));      // \"object\"（原始对象仍是匿名的）\n```\n\n**类型检查发生的时机：**\n- 赋值给类型化变量时\n- 验证所有必需字段存在\n- 验证字段类型匹配（带隐式转换）\n- 设置对象的类型名称\n\n## Define 中的方法签名\n\nDefine 块可以指定方法签名，创建类似接口的契约：\n\n### 必需方法\n\n```hemlock\ndefine Comparable {\n    value: i32,\n    fn compare(other: Self): i32;  // 必需方法签名\n}\n\n// 对象必须提供必需方法\nlet a: Comparable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n```\n\n### 可选方法\n\n```hemlock\ndefine Serializable {\n    fn serialize(): string;       // 必需\n    fn pretty?(): string;         // 可选方法（可能不存在）\n}\n```\n\n### `Self` 类型\n\n`Self` 指向正在定义的类型，支持递归类型定义：\n\n```hemlock\ndefine Cloneable {\n    fn clone(): Self;  // 返回与对象相同的类型\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;  // 接受相同类型作为参数\n    fn equals(other: Self): bool;\n}\n\nlet item: Cloneable = {\n    value: 42,\n    clone: fn() {\n        return { value: self.value, clone: self.clone };\n    }\n};\n```\n\n### 混合字段和方法\n\n```hemlock\ndefine Entity {\n    id: i32,\n    name: string,\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\nlet user: Entity = {\n    id: 1,\n    name: \"Alice\",\n    validate: fn() { return self.id > 0 && self.name != \"\"; },\n    serialize: fn() { return '{\"id\":' + self.id + ',\"name\":\"' + self.name + '\"}'; }\n};\n```\n\n## 复合类型（交叉类型）\n\n复合类型使用 `&` 要求对象满足多个类型定义：\n\n### 基本复合类型\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\n// 复合类型：对象必须满足所有类型\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n```\n\n### 带复合类型的函数参数\n\n```hemlock\nfn greet(p: HasName & HasAge) {\n    print(p.name + \" is \" + p.age);\n}\n\ngreet({ name: \"Bob\", age: 25, city: \"NYC\" });  // 允许额外字段\n```\n\n### 三个或更多类型\n\n```hemlock\ndefine HasEmail { email: string }\n\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n### 复合类型的类型别名\n\n```hemlock\n// 为复合类型创建命名别名\ntype Person = HasName & HasAge;\ntype Employee = HasName & HasAge & HasEmail;\n\nlet emp: Employee = {\n    name: \"Charlie\",\n    age: 35,\n    email: \"charlie@example.com\"\n};\n```\n\n**复合类型的鸭子类型：** 始终允许额外字段 - 对象只需要至少具有所有组成类型要求的字段。\n\n## JSON 序列化\n\n### 序列化为 JSON\n\n将对象转换为 JSON 字符串：\n\n```hemlock\n// obj.serialize() - 将对象转换为 JSON 字符串\nlet obj = { x: 10, y: 20, name: \"test\" };\nlet json = obj.serialize();\nprint(json);  // {\"x\":10,\"y\":20,\"name\":\"test\"}\n\n// 嵌套对象\nlet nested = { inner: { a: 1, b: 2 }, outer: 3 };\nprint(nested.serialize());  // {\"inner\":{\"a\":1,\"b\":2},\"outer\":3}\n```\n\n### 从 JSON 反序列化\n\n将 JSON 字符串解析回对象：\n\n```hemlock\n// json.deserialize() - 将 JSON 字符串解析为对象\nlet json_str = '{\"x\":10,\"y\":20,\"name\":\"test\"}';\nlet obj = json_str.deserialize();\n\nprint(obj.name);   // \"test\"\nprint(obj.x);      // 10\n```\n\n### 循环引用检测\n\n循环引用会被检测到并导致错误：\n\n```hemlock\nlet obj = { x: 10 };\nobj.me = obj;  // 创建循环引用\n\nobj.serialize();  // 错误：serialize() 检测到循环引用\n```\n\n### 支持的类型\n\nJSON 序列化支持：\n\n- **数字**：i8-i32, u8-u32, f32, f64\n- **布尔值**：true, false\n- **字符串**：带转义序列\n- **Null**：null 值\n- **对象**：嵌套对象\n- **数组**：嵌套数组\n\n**不支持：**\n- 函数（静默省略）\n- 指针（错误）\n- Buffer（错误）\n\n### 错误处理\n\n序列化和反序列化可能抛出错误：\n\n```hemlock\n// 无效 JSON 抛出错误\ntry {\n    let bad = \"not valid json\".deserialize();\n} catch (e) {\n    print(\"Parse error:\", e);\n}\n\n// 指针无法序列化\nlet obj = { ptr: alloc(10) };\ntry {\n    obj.serialize();\n} catch (e) {\n    print(\"Serialize error:\", e);\n}\n```\n\n### 往返示例\n\n序列化和反序列化的完整示例：\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug: bool\n}\n\n// 创建并序列化\nlet config: Config = {\n    host: \"localhost\",\n    port: 8080,\n    debug: true\n};\nlet json = config.serialize();\nprint(json);  // {\"host\":\"localhost\",\"port\":8080,\"debug\":true}\n\n// 反序列化\nlet restored = json.deserialize();\nprint(restored.host);  // \"localhost\"\nprint(restored.port);  // 8080\n```\n\n## 内置函数\n\n### `typeof(value)`\n\n返回类型名称作为字符串：\n\n```hemlock\nlet obj = { x: 10 };\nprint(typeof(obj));  // \"object\"\n\ndefine Person { name: string, age: i32 }\nlet p: Person = { name: \"Alice\", age: 30 };\nprint(typeof(p));    // \"Person\"\n```\n\n**返回值：**\n- 匿名对象：`\"object\"`\n- 类型化对象：自定义类型名称（例如 `\"Person\"`）\n\n## 实现细节\n\n### 内存模型\n\n- **堆分配** - 所有对象都在堆上分配\n- **浅拷贝** - 赋值复制引用，而非对象\n- **动态字段** - 存储为名称/值对的动态数组\n- **引用计数** - 作用域退出时对象自动释放\n\n### 引用语义\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // 浅拷贝（相同引用）\n\nobj2.x = 20;\nprint(obj1.x);  // 20（两者指向相同对象）\n```\n\n### 方法存储\n\n方法只是存储在字段中的函数：\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// method 是存储在 obj.method 中的函数\nprint(typeof(obj.method));  // \"function\"\n```\n\n## 常见模式\n\n### 模式：构造函数\n\n```hemlock\nfn createPerson(name: string, age: i32) {\n    return {\n        name: name,\n        age: age,\n        greet: fn() {\n            return \"Hi, I'm \" + self.name;\n        }\n    };\n}\n\nlet person = createPerson(\"Alice\", 30);\nprint(person.greet());  // \"Hi, I'm Alice\"\n```\n\n### 模式：对象构建器\n\n```hemlock\nfn PersonBuilder() {\n    return {\n        name: null,\n        age: null,\n\n        setName: fn(n) {\n            self.name = n;\n            return self;  // 支持链式调用\n        },\n\n        setAge: fn(a) {\n            self.age = a;\n            return self;\n        },\n\n        build: fn() {\n            return { name: self.name, age: self.age };\n        }\n    };\n}\n\nlet person = PersonBuilder()\n    .setName(\"Alice\")\n    .setAge(30)\n    .build();\n```\n\n### 模式：状态对象\n\n```hemlock\nlet state = {\n    status: \"idle\",\n    data: null,\n    error: null,\n\n    setState: fn(new_status) {\n        self.status = new_status;\n    },\n\n    setData: fn(new_data) {\n        self.data = new_data;\n        self.status = \"success\";\n    },\n\n    setError: fn(err) {\n        self.error = err;\n        self.status = \"error\";\n    }\n};\n```\n\n### 模式：配置对象\n\n```hemlock\nlet config = {\n    defaults: {\n        timeout: 30,\n        retries: 3,\n        debug: false\n    },\n\n    get: fn(key) {\n        if (self.defaults[key] != null) {\n            return self.defaults[key];\n        }\n        return null;\n    },\n\n    set: fn(key, value) {\n        self.defaults[key] = value;\n    }\n};\n```\n\n## 最佳实践\n\n1. **使用 `define` 定义结构** - 记录预期的对象形状\n2. **优先使用工厂函数** - 使用构造函数创建对象\n3. **保持对象简单** - 不要嵌套太深\n4. **记录 `self` 用法** - 明确方法行为\n5. **在赋值时验证** - 使用鸭子类型尽早捕获错误\n6. **避免循环引用** - 会导致序列化错误\n7. **使用可选字段** - 提供合理的默认值\n\n## 常见陷阱\n\n### 陷阱：引用与值\n\n```hemlock\nlet obj1 = { x: 10 };\nlet obj2 = obj1;  // 浅拷贝\n\nobj2.x = 20;\nprint(obj1.x);  // 20（意外！两者都改变了）\n\n// 避免方法：创建新对象\nlet obj3 = { x: obj1.x };  // 深拷贝（手动）\n```\n\n### 陷阱：非方法调用中的 `self`\n\n```hemlock\nlet obj = {\n    value: 10,\n    method: fn() { return self.value; }\n};\n\n// 有效：作为方法调用\nprint(obj.method());  // 10\n\n// 错误：作为函数调用\nlet f = obj.method;\nprint(f());  // 错误：self 未定义\n```\n\n### 陷阱：对象中的原始指针\n\n```hemlock\n// 对象会自动释放，但其中的原始指针不会\nfn create_objects() {\n    let obj = { data: alloc(1000) };  // 原始指针需要手动释放\n    // 作用域退出时 obj 自动释放，但 obj.data 泄漏！\n}\n\n// 解决方案：在作用域退出前释放原始指针\nfn safe_create() {\n    let obj = { data: alloc(1000) };\n    // ... 使用 obj.data ...\n    free(obj.data);  // 显式释放原始指针\n}  // obj 本身自动释放\n```\n\n### 陷阱：类型混淆\n\n```hemlock\nlet obj = { x: 10 };\n\ndefine Point { x: i32, y: i32 }\n\n// 错误：缺少必需字段 'y'\nlet p: Point = obj;\n```\n\n## 示例\n\n### 示例：向量数学\n\n```hemlock\nfn createVector(x, y) {\n    return {\n        x: x,\n        y: y,\n\n        add: fn(other) {\n            return createVector(\n                self.x + other.x,\n                self.y + other.y\n            );\n        },\n\n        length: fn() {\n            return sqrt(self.x * self.x + self.y * self.y);\n        },\n\n        toString: fn() {\n            return \"(\" + typeof(self.x) + \", \" + typeof(self.y) + \")\";\n        }\n    };\n}\n\nlet v1 = createVector(3, 4);\nlet v2 = createVector(1, 2);\nlet v3 = v1.add(v2);\n\nprint(v3.toString());  // \"(4, 6)\"\n```\n\n### 示例：简单数据库\n\n```hemlock\nfn createDatabase() {\n    let records = [];\n    let next_id = 1;\n\n    return {\n        insert: fn(data) {\n            let record = { id: next_id, data: data };\n            records.push(record);\n            next_id = next_id + 1;\n            return record.id;\n        },\n\n        find: fn(id) {\n            let i = 0;\n            while (i < records.length) {\n                if (records[i].id == id) {\n                    return records[i];\n                }\n                i = i + 1;\n            }\n            return null;\n        },\n\n        count: fn() {\n            return records.length;\n        }\n    };\n}\n\nlet db = createDatabase();\nlet id = db.insert({ name: \"Alice\", age: 30 });\nlet record = db.find(id);\nprint(record.data.name);  // \"Alice\"\n```\n\n### 示例：事件发射器\n\n```hemlock\nfn createEventEmitter() {\n    let listeners = {};\n\n    return {\n        on: fn(event, handler) {\n            if (listeners[event] == null) {\n                listeners[event] = [];\n            }\n            listeners[event].push(handler);\n        },\n\n        emit: fn(event, data) {\n            if (listeners[event] != null) {\n                let i = 0;\n                while (i < listeners[event].length) {\n                    listeners[event][i](data);\n                    i = i + 1;\n                }\n            }\n        }\n    };\n}\n\nlet emitter = createEventEmitter();\n\nemitter.on(\"message\", fn(data) {\n    print(\"Received: \" + data);\n});\n\nemitter.emit(\"message\", \"Hello!\");\n```\n\n## 限制\n\n当前限制：\n\n- **无深拷贝** - 必须手动复制嵌套对象（展开是浅拷贝）\n- **无按值传递** - 对象始终按引用传递\n- **无计算属性** - 不支持 `{[key]: value}` 语法\n- **`self` 是只读的** - 无法在方法中重新赋值 `self`\n- **无属性删除** - 一旦添加字段无法删除\n\n**注意：** 对象使用引用计数，作用域退出时自动释放。详见 [内存管理](memory.md#internal-reference-counting)。\n\n## 相关主题\n\n- [函数](#language-guide-functions) - 方法是存储在对象中的函数\n- [数组](#language-guide-arrays) - 数组也是类对象的\n- [类型](#language-guide-types) - 鸭子类型和类型定义\n- [错误处理](#language-guide-error-handling) - 抛出错误对象\n\n## 另请参阅\n\n- **鸭子类型**：参见 CLAUDE.md 中的 \"Objects\" 部分了解鸭子类型详情\n- **JSON**：参见 CLAUDE.md 了解 JSON 序列化详情\n- **内存**：参见 [内存](#language-guide-memory) 了解对象分配\n"}, "语言指南 -> 控制流": {"id": "language-guide-control-flow", "content": "# 控制流\n\nHemlock 提供熟悉的 C 风格控制流，要求强制使用花括号和显式语法。本指南涵盖条件语句、循环、switch 语句和运算符。\n\n## 概述\n\n可用的控制流特性：\n\n- `if`/`else`/`else if` - 条件分支\n- `while` 循环 - 基于条件的迭代\n- `for` 循环 - C 风格和 for-in 迭代\n- `loop` - 无限循环（比 `while (true)` 更清晰）\n- `switch` 语句 - 多路分支\n- `break`/`continue` - 循环控制\n- 循环标签 - 针对嵌套循环的定向 break/continue\n- `defer` - 延迟执行（清理）\n- 布尔运算符：`&&`、`||`、`!`\n- 比较运算符：`==`、`!=`、`<`、`>`、`<=`、`>=`\n- 位运算符：`&`、`|`、`^`、`<<`、`>>`、`~`\n\n## If 语句\n\n### 基本 If/Else\n\n```hemlock\nif (x > 10) {\n    print(\"large\");\n} else {\n    print(\"small\");\n}\n```\n\n**规则：**\n- 所有分支都**必须**使用花括号\n- 条件必须用括号包围\n- 不支持可选花括号（与 C 不同）\n\n### 无 Else 的 If\n\n```hemlock\nif (x > 0) {\n    print(\"positive\");\n}\n// 不需要 else 分支\n```\n\n### Else-If 链\n\n```hemlock\nif (x > 100) {\n    print(\"very large\");\n} else if (x > 50) {\n    print(\"large\");\n} else if (x > 10) {\n    print(\"medium\");\n} else {\n    print(\"small\");\n}\n```\n\n**注意：** `else if` 是嵌套 if 语句的语法糖。以下两种写法等价：\n\n```hemlock\n// else if（语法糖）\nif (a) {\n    foo();\n} else if (b) {\n    bar();\n}\n\n// 等价的嵌套 if\nif (a) {\n    foo();\n} else {\n    if (b) {\n        bar();\n    }\n}\n```\n\n### 嵌套 If 语句\n\n```hemlock\nif (x > 0) {\n    if (x < 10) {\n        print(\"single digit positive\");\n    } else {\n        print(\"multi-digit positive\");\n    }\n} else {\n    print(\"non-positive\");\n}\n```\n\n## While 循环\n\n基于条件的迭代：\n\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n**无限循环（旧式）：**\n```hemlock\nwhile (true) {\n    // ... 执行工作\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**注意：** 对于无限循环，推荐使用 `loop` 关键字（见下文）。\n\n## Loop（无限循环）\n\n`loop` 关键字为无限循环提供更清晰的语法：\n\n```hemlock\nloop {\n    // ... 执行工作\n    if (should_exit) {\n        break;\n    }\n}\n```\n\n**等价于 `while (true)`，但意图更明确。**\n\n### 带 Break 的基本 Loop\n\n```hemlock\nlet i = 0;\nloop {\n    if (i >= 5) {\n        break;\n    }\n    print(i);\n    i = i + 1;\n}\n// 输出：0, 1, 2, 3, 4\n```\n\n### 带 Continue 的 Loop\n\n```hemlock\nlet i = 0;\nloop {\n    i = i + 1;\n    if (i > 5) {\n        break;\n    }\n    if (i == 3) {\n        continue;  // 跳过打印 3\n    }\n    print(i);\n}\n// 输出：1, 2, 4, 5\n```\n\n### 嵌套 Loop\n\n```hemlock\nlet x = 0;\nloop {\n    if (x >= 2) { break; }\n    let y = 0;\n    loop {\n        if (y >= 3) { break; }\n        print(x * 10 + y);\n        y = y + 1;\n    }\n    x = x + 1;\n}\n// 输出：0, 1, 2, 10, 11, 12\n```\n\n### 何时使用 Loop\n\n- **使用 `loop`** - 用于故意的无限循环，通过 `break` 退出\n- **使用 `while`** - 当有自然的终止条件时\n- **使用 `for`** - 当迭代已知次数或遍历集合时\n\n## For 循环\n\n### C 风格 For\n\n经典的三段式 for 循环：\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**组成部分：**\n- **初始化器**：`let i = 0` - 循环开始前运行一次\n- **条件**：`i < 10` - 每次迭代前检查\n- **更新**：`i = i + 1` - 每次迭代后运行\n\n**作用域：**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n// i 在这里不可访问（循环作用域）\n```\n\n### For-In 循环\n\n遍历数组元素：\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nfor (let item in arr) {\n    print(item);  // 打印每个元素\n}\n```\n\n**带索引和值：**\n```hemlock\nlet arr = [\"a\", \"b\", \"c\"];\nfor (let i = 0; i < arr.length; i = i + 1) {\n    print(`Index: ${i}, Value: ${arr[i]}`);\n}\n```\n\n## Switch 语句\n\n基于值的多路分支：\n\n### 基本 Switch\n\n```hemlock\nlet x = 2;\n\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;\n    case 2:\n        print(\"two\");\n        break;\n    case 3:\n        print(\"three\");\n        break;\n}\n```\n\n### 带 Default 的 Switch\n\n```hemlock\nlet color = \"blue\";\n\nswitch (color) {\n    case \"red\":\n        print(\"stop\");\n        break;\n    case \"yellow\":\n        print(\"slow\");\n        break;\n    case \"green\":\n        print(\"go\");\n        break;\n    default:\n        print(\"unknown color\");\n        break;\n}\n```\n\n**规则：**\n- `default` 在没有其他 case 匹配时执行\n- `default` 可以出现在 switch 体的任何位置\n- 只允许一个 default case\n\n### 贯穿行为\n\n没有 `break` 的 case 会贯穿到下一个 case（C 风格行为）。这是**有意的**，可用于分组 case：\n\n```hemlock\nlet grade = 85;\n\nswitch (grade) {\n    case 100:\n    case 95:\n    case 90:\n        print(\"A\");\n        break;\n    case 85:\n    case 80:\n        print(\"B\");\n        break;\n    default:\n        print(\"C or below\");\n        break;\n}\n```\n\n**显式贯穿示例：**\n```hemlock\nlet day = 3;\n\nswitch (day) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n        print(\"Weekday\");\n        break;\n    case 6:\n    case 7:\n        print(\"Weekend\");\n        break;\n}\n```\n\n**重要：** 与一些现代语言不同，Hemlock 不需要显式的 `fallthrough` 关键字。除非用 `break`、`return` 或 `throw` 终止，否则 case 会自动贯穿。始终使用 `break` 防止意外贯穿。\n\n### 带 Return 的 Switch\n\n在函数中，`return` 立即退出 switch：\n\n```hemlock\nfn get_day_name(day: i32): string {\n    switch (day) {\n        case 1:\n            return \"Monday\";\n        case 2:\n            return \"Tuesday\";\n        case 3:\n            return \"Wednesday\";\n        default:\n            return \"Unknown\";\n    }\n}\n```\n\n### Switch 值类型\n\nSwitch 适用于任何值类型：\n\n```hemlock\n// 整数\nswitch (count) {\n    case 0: print(\"zero\"); break;\n    case 1: print(\"one\"); break;\n}\n\n// 字符串\nswitch (name) {\n    case \"Alice\": print(\"A\"); break;\n    case \"Bob\": print(\"B\"); break;\n}\n\n// 布尔值\nswitch (flag) {\n    case true: print(\"on\"); break;\n    case false: print(\"off\"); break;\n}\n```\n\n**注意：** Case 使用值相等性进行比较。\n\n## Break 和 Continue\n\n### Break\n\n退出最内层的循环或 switch：\n\n```hemlock\n// 在循环中\nlet i = 0;\nwhile (true) {\n    if (i >= 10) {\n        break;  // 退出循环\n    }\n    print(i);\n    i = i + 1;\n}\n\n// 在 switch 中\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;  // 退出 switch\n    case 2:\n        print(\"two\");\n        break;\n}\n```\n\n### Continue\n\n跳到循环的下一次迭代：\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;  // 当 i 为 5 时跳过\n    }\n    print(i);  // 打印 0,1,2,3,4,6,7,8,9\n}\n```\n\n**区别：**\n- `break` - 完全退出循环\n- `continue` - 跳到下一次迭代\n\n## 循环标签\n\n循环标签允许 `break` 和 `continue` 针对特定的外层循环，而不仅仅是最内层循环。这在需要从内层循环控制外层循环的嵌套循环中很有用。\n\n### 带标签的 Break\n\n从内层循环退出外层循环：\n\n```hemlock\nouter: while (i < 3) {\n    let j = 0;\n    while (j < 3) {\n        if (i == 1 && j == 1) {\n            break outer;  // 退出外层 while 循环\n        }\n        print(i * 10 + j);\n        j = j + 1;\n    }\n    i = i + 1;\n}\n// 输出：0, 1, 2, 10（在 i=1, j=1 处停止）\n```\n\n### 带标签的 Continue\n\n跳到外层循环的下一次迭代：\n\n```hemlock\nlet i = 0;\nouter: while (i < 3) {\n    i = i + 1;\n    let j = 0;\n    while (j < 3) {\n        j = j + 1;\n        if (i == 2 && j == 1) {\n            continue outer;  // 跳过内层循环剩余部分，继续外层循环\n        }\n        print(i * 10 + j);\n    }\n}\n// 当 i=2, j=1 时：跳到外层循环的下一次迭代\n```\n\n### For 循环中的标签\n\n标签适用于所有循环类型：\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 3; y = y + 1) {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n    }\n}\n```\n\n### For-In 循环中的标签\n\n```hemlock\nlet arr1 = [1, 2, 3];\nlet arr2 = [10, 20, 30];\n\nouter: for (let a in arr1) {\n    for (let b in arr2) {\n        if (a == 2 && b == 20) {\n            break outer;\n        }\n        print(a * 100 + b);\n    }\n}\n```\n\n### Loop 关键字中的标签\n\n```hemlock\nlet x = 0;\nouter: loop {\n    let y = 0;\n    loop {\n        if (x == 1 && y == 1) {\n            break outer;\n        }\n        print(x * 10 + y);\n        y = y + 1;\n        if (y >= 3) { break; }\n    }\n    x = x + 1;\n    if (x >= 3) { break; }\n}\n```\n\n### 多重标签\n\n可以在不同嵌套层级使用标签：\n\n```hemlock\nouter: for (let a = 0; a < 2; a = a + 1) {\n    inner: for (let b = 0; b < 3; b = b + 1) {\n        for (let c = 0; c < 3; c = c + 1) {\n            if (c == 1) {\n                continue inner;  // 跳到中间循环的下一次迭代\n            }\n            if (a == 1 && b == 1) {\n                break outer;      // 退出最外层循环\n            }\n            print(a * 100 + b * 10 + c);\n        }\n    }\n}\n```\n\n### 带标签循环中的无标签 Break/Continue\n\n无标签的 `break` 和 `continue` 仍然正常工作（影响最内层循环），即使外层循环有标签：\n\n```hemlock\nouter: for (let x = 0; x < 3; x = x + 1) {\n    for (let y = 0; y < 5; y = y + 1) {\n        if (y == 2) {\n            break;  // 只退出内层循环\n        }\n        print(x * 10 + y);\n    }\n}\n// 输出：0, 1, 10, 11, 20, 21\n```\n\n### 标签语法\n\n- 标签是标识符后跟冒号\n- 标签必须紧接在循环语句之前（`while`、`for`、`loop`）\n- 标签名遵循标识符规则（字母、数字、下划线）\n- 常见约定：`outer`、`inner`、`row`、`col`、描述性名称\n\n## Defer 语句\n\n`defer` 语句安排代码在当前函数返回时执行。这对于清理操作很有用，如关闭文件、释放资源或解锁。\n\n### 基本 Defer\n\n```hemlock\nfn example() {\n    print(\"start\");\n    defer print(\"cleanup\");  // 函数返回时运行\n    print(\"end\");\n}\n\nexample();\n// 输出：\n// start\n// end\n// cleanup\n```\n\n**关键行为：**\n- 延迟语句在函数体完成**之后**执行\n- 延迟语句在函数返回给调用者**之前**执行\n- 即使函数抛出异常，延迟语句也总是执行\n\n### 多个 Defer（LIFO 顺序）\n\n当使用多个 `defer` 语句时，它们按**相反顺序**执行（后进先出）：\n\n```hemlock\nfn example() {\n    defer print(\"first\");   // 最后执行\n    defer print(\"second\");  // 第二个执行\n    defer print(\"third\");   // 第一个执行\n    print(\"body\");\n}\n\nexample();\n// 输出：\n// body\n// third\n// second\n// first\n```\n\n这种 LIFO 顺序是有意的 - 它符合嵌套资源清理的自然顺序（在外部资源之前关闭内部资源）。\n\n### 带 Return 的 Defer\n\n延迟语句在 `return` 转移控制之前执行：\n\n```hemlock\nfn get_value(): i32 {\n    defer print(\"cleanup\");\n    print(\"before return\");\n    return 42;\n}\n\nlet result = get_value();\nprint(\"result:\", result);\n// 输出：\n// before return\n// cleanup\n// result: 42\n```\n\n### 带异常的 Defer\n\n即使抛出异常，延迟语句也会执行：\n\n```hemlock\nfn risky() {\n    defer print(\"cleanup 1\");\n    defer print(\"cleanup 2\");\n    print(\"before throw\");\n    throw \"error!\";\n    print(\"after throw\");  // 永远不会执行\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(\"Caught:\", e);\n}\n// 输出：\n// before throw\n// cleanup 2\n// cleanup 1\n// Caught: error!\n```\n\n### 资源清理模式\n\n`defer` 的主要用例是确保资源被清理：\n\n```hemlock\nfn process_file(filename: string) {\n    let file = open(filename, \"r\");\n    defer file.close();  // 即使出错也总是关闭\n\n    let content = file.read();\n    // ... 处理内容 ...\n\n    // 函数返回时文件自动关闭\n}\n```\n\n**不使用 defer（容易出错）：**\n```hemlock\nfn process_file_bad(filename: string) {\n    let file = open(filename, \"r\");\n    let content = file.read();\n    // 如果这里抛出异常，file.close() 永远不会被调用！\n    process(content);\n    file.close();\n}\n```\n\n### 带闭包的 Defer\n\nDefer 可以使用闭包来捕获状态：\n\n```hemlock\nfn example() {\n    let resource = acquire_resource();\n    defer fn() {\n        print(\"Releasing resource\");\n        release(resource);\n    }();  // 注意：立即调用的函数表达式\n\n    use_resource(resource);\n}\n```\n\n### 何时使用 Defer\n\n**使用 defer 的场景：**\n- 关闭文件和网络连接\n- 释放分配的内存\n- 释放锁和互斥量\n- 任何获取资源的函数中的清理\n\n**Defer vs Finally：**\n- `defer` 对于单资源清理更简单\n- `try/finally` 对于带恢复的复杂错误处理更好\n\n### 最佳实践\n\n1. **获取资源后立即使用 defer：**\n   ```hemlock\n   let file = open(\"data.txt\", \"r\");\n   defer file.close();\n   // ... 使用文件 ...\n   ```\n\n2. **对多个资源使用多个 defer：**\n   ```hemlock\n   let file1 = open(\"input.txt\", \"r\");\n   defer file1.close();\n\n   let file2 = open(\"output.txt\", \"w\");\n   defer file2.close();\n\n   // 两个文件将按相反顺序关闭\n   ```\n\n3. **记住 LIFO 顺序用于依赖资源：**\n   ```hemlock\n   let outer = acquire_outer();\n   defer release_outer(outer);\n\n   let inner = acquire_inner(outer);\n   defer release_inner(inner);\n\n   // inner 在 outer 之前释放（正确的依赖顺序）\n   ```\n\n## 布尔运算符\n\n### 逻辑与 (`&&`)\n\n两个条件都必须为真：\n\n```hemlock\nif (x > 0 && x < 10) {\n    print(\"single digit positive\");\n}\n```\n\n**短路求值：**\n```hemlock\nif (false && expensive_check()) {\n    // expensive_check() 永远不会被调用\n}\n```\n\n### 逻辑或 (`||`)\n\n至少一个条件必须为真：\n\n```hemlock\nif (x < 0 || x > 100) {\n    print(\"out of range\");\n}\n```\n\n**短路求值：**\n```hemlock\nif (true || expensive_check()) {\n    // expensive_check() 永远不会被调用\n}\n```\n\n### 逻辑非 (`!`)\n\n取反布尔值：\n\n```hemlock\nif (!is_valid) {\n    print(\"invalid\");\n}\n\nif (!(x > 10)) {\n    // 等同于：if (x <= 10)\n}\n```\n\n## 比较运算符\n\n### 相等性\n\n```hemlock\nif (x == 10) { }    // 等于\nif (x != 10) { }    // 不等于\n```\n\n适用于所有类型：\n```hemlock\n\"hello\" == \"hello\"  // true\ntrue == false       // false\nnull == null        // true\n```\n\n### 关系运算符\n\n```hemlock\nif (x < 10) { }     // 小于\nif (x > 10) { }     // 大于\nif (x <= 10) { }    // 小于等于\nif (x >= 10) { }    // 大于等于\n```\n\n**类型提升适用：**\n```hemlock\nlet a: i32 = 10;\nlet b: i64 = 10;\nif (a == b) { }     // true（i32 提升为 i64）\n```\n\n## 位运算符\n\nHemlock 提供用于整数操作的位运算符。这些**只能用于整数类型**（i8-i64、u8-u64）。\n\n### 二元位运算符\n\n**按位与 (`&`)**\n```hemlock\nlet a = 12;  // 二进制 1100\nlet b = 10;  // 二进制 1010\nprint(a & b);   // 8 (1000)\n```\n\n**按位或 (`|`)**\n```hemlock\nprint(a | b);   // 14 (1110)\n```\n\n**按位异或 (`^`)**\n```hemlock\nprint(a ^ b);   // 6 (0110)\n```\n\n**左移 (`<<`)**\n```hemlock\nprint(a << 2);  // 48 (110000) - 左移 2 位\n```\n\n**右移 (`>>`)**\n```hemlock\nprint(a >> 1);  // 6 (110) - 右移 1 位\n```\n\n### 一元位运算符\n\n**按位取反 (`~`)**\n```hemlock\nlet a = 12;\nprint(~a);      // -13（补码）\n\nlet c: u8 = 15;   // 二进制 00001111\nprint(~c);        // 240 (11110000)，u8 类型\n```\n\n### 位运算示例\n\n**使用无符号类型：**\n```hemlock\nlet c: u8 = 15;   // 二进制 00001111\nlet d: u8 = 7;    // 二进制 00000111\n\nprint(c & d);     // 7  (00000111)\nprint(c | d);     // 15 (00001111)\nprint(c ^ d);     // 8  (00001000)\nprint(~c);        // 240 (11110000) - u8 类型\n```\n\n**类型保持：**\n```hemlock\n// 位运算保持操作数的类型\nlet x: u8 = 255;\nlet result = ~x;  // result 是 u8，值为 0\n\nlet y: i32 = 100;\nlet result2 = y << 2;  // result2 是 i32，值为 400\n```\n\n**常见模式：**\n```hemlock\n// 检查位是否设置\nif (flags & 0x04) {\n    print(\"bit 2 is set\");\n}\n\n// 设置位\nflags = flags | 0x08;\n\n// 清除位\nflags = flags & ~0x02;\n\n// 切换位\nflags = flags ^ 0x01;\n```\n\n### 运算符优先级\n\n位运算符遵循 C 风格优先级：\n\n1. `~`（一元取反）- 最高，与 `!` 和 `-` 同级\n2. `<<`、`>>`（位移）- 高于比较，低于 `+`/`-`\n3. `&`（按位与）- 高于 `^` 和 `|`\n4. `^`（按位异或）- 在 `&` 和 `|` 之间\n5. `|`（按位或）- 低于 `&` 和 `^`，高于 `&&`\n6. `&&`、`||`（逻辑）- 最低优先级\n\n**示例：**\n```hemlock\n// & 优先级高于 |\nlet result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12\n\n// 位移优先级高于位运算符\nlet result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12\n\n// 使用括号提高清晰度\nlet result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5\n```\n\n**重要注意事项：**\n- 位运算符只能用于整数类型（不能用于浮点数、字符串等）\n- 类型提升遵循标准规则（较小类型提升为较大类型）\n- 右移 (`>>`) 对有符号类型是算术移位，对无符号类型是逻辑移位\n- 移位量不进行范围检查（大移位量的行为取决于平台）\n\n## 运算符优先级（完整）\n\n从高到低优先级：\n\n1. **一元**：`!`、`-`、`~`\n2. **乘除**：`*`、`/`、`%`\n3. **加减**：`+`、`-`\n4. **位移**：`<<`、`>>`\n5. **关系**：`<`、`>`、`<=`、`>=`\n6. **相等**：`==`、`!=`\n7. **按位与**：`&`\n8. **按位异或**：`^`\n9. **按位或**：`|`\n10. **逻辑与**：`&&`\n11. **逻辑或**：`||`\n\n**使用括号提高清晰度：**\n```hemlock\n// 不清晰\nif (a || b && c) { }\n\n// 清晰\nif (a || (b && c)) { }\nif ((a || b) && c) { }\n```\n\n## 常见模式\n\n### 模式：输入验证\n\n```hemlock\nfn validate_age(age: i32): bool {\n    if (age < 0 || age > 150) {\n        return false;\n    }\n    return true;\n}\n```\n\n### 模式：范围检查\n\n```hemlock\nfn in_range(value: i32, min: i32, max: i32): bool {\n    return value >= min && value <= max;\n}\n\nif (in_range(score, 0, 100)) {\n    print(\"valid score\");\n}\n```\n\n### 模式：状态机\n\n```hemlock\nlet state = \"start\";\n\nwhile (true) {\n    switch (state) {\n        case \"start\":\n            print(\"Starting...\");\n            state = \"running\";\n            break;\n\n        case \"running\":\n            if (should_pause) {\n                state = \"paused\";\n            } else if (should_stop) {\n                state = \"stopped\";\n            }\n            break;\n\n        case \"paused\":\n            if (should_resume) {\n                state = \"running\";\n            }\n            break;\n\n        case \"stopped\":\n            print(\"Stopped\");\n            break;\n    }\n\n    if (state == \"stopped\") {\n        break;\n    }\n}\n```\n\n### 模式：带过滤的迭代\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// 只打印偶数\nfor (let i = 0; i < arr.length; i = i + 1) {\n    if (arr[i] % 2 != 0) {\n        continue;  // 跳过奇数\n    }\n    print(arr[i]);\n}\n```\n\n### 模式：提前退出\n\n```hemlock\nfn find_first_negative(arr: array): i32 {\n    for (let i = 0; i < arr.length; i = i + 1) {\n        if (arr[i] < 0) {\n            return i;  // 提前退出\n        }\n    }\n    return -1;  // 未找到\n}\n```\n\n## 最佳实践\n\n1. **始终使用花括号** - 即使是单语句块也要（语法强制）\n2. **显式条件** - 使用 `x == 0` 而不是 `!x` 以提高清晰度\n3. **避免深层嵌套** - 将嵌套条件提取到函数中\n4. **使用提前返回** - 用守卫子句减少嵌套\n5. **分解复杂条件** - 拆分为命名的布尔变量\n6. **switch 中使用 default** - 始终包含 default case\n7. **注释贯穿** - 使有意的贯穿明确\n\n## 常见陷阱\n\n### 陷阱：条件中的赋值\n\n```hemlock\n// 这是不允许的（条件中不能赋值）\nif (x = 10) { }  // 错误：语法错误\n\n// 使用比较代替\nif (x == 10) { }  // OK\n```\n\n### 陷阱：Switch 中缺少 Break\n\n```hemlock\n// 意外贯穿\nswitch (x) {\n    case 1:\n        print(\"one\");\n        // 缺少 break - 会贯穿！\n    case 2:\n        print(\"two\");  // 对 1 和 2 都执行\n        break;\n}\n\n// 修复：添加 break\nswitch (x) {\n    case 1:\n        print(\"one\");\n        break;  // 现在正确\n    case 2:\n        print(\"two\");\n        break;\n}\n```\n\n### 陷阱：循环变量作用域\n\n```hemlock\n// i 的作用域限于循环\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\nprint(i);  // 错误：i 在这里未定义\n```\n\n## 示例\n\n### 示例：FizzBuzz\n\n```hemlock\nfor (let i = 1; i <= 100; i = i + 1) {\n    if (i % 15 == 0) {\n        print(\"FizzBuzz\");\n    } else if (i % 3 == 0) {\n        print(\"Fizz\");\n    } else if (i % 5 == 0) {\n        print(\"Buzz\");\n    } else {\n        print(i);\n    }\n}\n```\n\n### 示例：素数检查\n\n```hemlock\nfn is_prime(n: i32): bool {\n    if (n < 2) {\n        return false;\n    }\n\n    let i = 2;\n    while (i * i <= n) {\n        if (n % i == 0) {\n            return false;\n        }\n        i = i + 1;\n    }\n\n    return true;\n}\n```\n\n### 示例：菜单系统\n\n```hemlock\nfn menu() {\n    while (true) {\n        print(\"1. Start\");\n        print(\"2. Settings\");\n        print(\"3. Exit\");\n\n        let choice = get_input();\n\n        switch (choice) {\n            case 1:\n                start_game();\n                break;\n            case 2:\n                show_settings();\n                break;\n            case 3:\n                print(\"Goodbye!\");\n                return;\n            default:\n                print(\"Invalid choice\");\n                break;\n        }\n    }\n}\n```\n\n## 相关主题\n\n- [Functions](#language-guide-functions) - 函数调用和返回的控制流\n- [Error Handling](#language-guide-error-handling) - 异常的控制流\n- [Types](#language-guide-types) - 条件中的类型转换\n\n## 另请参阅\n\n- **语法**：参见 [Syntax](#language-guide-syntax) 了解语句语法细节\n- **运算符**：参见 [Types](#language-guide-types) 了解运算中的类型提升\n"}, "语言指南 -> 数组": {"id": "language-guide-arrays", "content": "# 数组\n\nHemlock 提供**动态数组**，具有全面的数据操作和处理方法。数组可以存储混合类型，并根据需要自动增长。\n\n## 概述\n\n```hemlock\n// 数组字面量\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// 允许混合类型\nlet mixed = [1, \"hello\", true, null];\n\n// 动态大小调整\narr.push(6);           // 自动增长\narr.push(7);\nprint(arr.length);     // 7\n```\n\n## 数组字面量\n\n### 基本语法\n\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet strings = [\"apple\", \"banana\", \"cherry\"];\nlet booleans = [true, false, true];\n```\n\n### 空数组\n\n```hemlock\nlet arr = [];  // 空数组\n\n// 稍后添加元素\narr.push(1);\narr.push(2);\narr.push(3);\n```\n\n### 混合类型\n\n数组可以包含不同类型：\n\n```hemlock\nlet mixed = [\n    42,\n    \"hello\",\n    true,\n    null,\n    [1, 2, 3],\n    { x: 10, y: 20 }\n];\n\nprint(mixed[0]);  // 42\nprint(mixed[1]);  // \"hello\"\nprint(mixed[4]);  // [1, 2, 3]（嵌套数组）\n```\n\n### 嵌套数组\n\n```hemlock\nlet matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n];\n\nprint(matrix[0][0]);  // 1\nprint(matrix[1][2]);  // 6\nprint(matrix[2][1]);  // 8\n```\n\n### 类型化数组\n\n数组可以使用类型注解来强制元素类型：\n\n```hemlock\n// 类型化数组语法\nlet nums: array<i32> = [1, 2, 3, 4, 5];\nlet names: array<string> = [\"Alice\", \"Bob\", \"Carol\"];\nlet flags: array<bool> = [true, false, true];\n\n// 运行时类型检查\nlet valid: array<i32> = [1, 2, 3];       // 正确\nlet invalid: array<i32> = [1, \"two\", 3]; // 运行时错误：类型不匹配\n\n// 嵌套类型化数组\nlet matrix: array<array<i32>> = [\n    [1, 2, 3],\n    [4, 5, 6]\n];\n```\n\n**类型注解行为：**\n- 元素在添加到数组时进行类型检查\n- 类型不匹配会导致运行时错误\n- 没有类型注解时，数组接受混合类型\n\n## 索引\n\n### 读取元素\n\n从零开始的索引访问：\n\n```hemlock\nlet arr = [10, 20, 30, 40, 50];\n\nprint(arr[0]);  // 10（第一个元素）\nprint(arr[4]);  // 50（最后一个元素）\n\n// 越界访问返回 null（不报错）\nprint(arr[10]);  // null\n```\n\n### 写入元素\n\n```hemlock\nlet arr = [1, 2, 3];\n\narr[0] = 10;    // 修改现有元素\narr[1] = 20;\nprint(arr);     // [10, 20, 3]\n\n// 可以在超出当前长度的位置赋值（数组会增长）\narr[5] = 60;    // 创建 [10, 20, 3, null, null, 60]\n```\n\n### 负数索引\n\n**不支持** - 只能使用正数索引：\n\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr[-1]);  // 错误或未定义行为\n\n// 使用 length 获取最后一个元素\nprint(arr[arr.length - 1]);  // 3\n```\n\n## 属性\n\n### `.length` 属性\n\n返回元素数量：\n\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);  // 5\n\n// 空数组\nlet empty = [];\nprint(empty.length);  // 0\n\n// 修改后\narr.push(6);\nprint(arr.length);  // 6\n```\n\n## 数组方法\n\nHemlock 提供 18 个数组方法用于全面的操作。\n\n### 栈操作\n\n**`push(value)`** - 在末尾添加元素：\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\n\nprint(arr.length);     // 5\n```\n\n**`pop()`** - 移除并返回最后一个元素：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet last = arr.pop();  // 返回 5，arr 现在是 [1, 2, 3, 4]\n\nprint(last);           // 5\nprint(arr.length);     // 4\n```\n\n### 队列操作\n\n**`shift()`** - 移除并返回第一个元素：\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();   // 返回 1，arr 现在是 [2, 3]\n\nprint(first);              // 1\nprint(arr);                // [2, 3]\n```\n\n**`unshift(value)`** - 在开头添加元素：\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);            // [1, 2, 3]\narr.unshift(0);            // [0, 1, 2, 3]\n```\n\n### 插入和删除\n\n**`insert(index, value)`** - 在指定索引处插入元素：\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // 在索引 2 处插入 3：[1, 2, 3, 4, 5]\n\narr.insert(0, 0);      // 在开头插入：[0, 1, 2, 3, 4, 5]\n```\n\n**`remove(index)`** - 移除并返回指定索引处的元素：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(2);  // 返回 3，arr 现在是 [1, 2, 4, 5]\n\nprint(removed);               // 3\nprint(arr);                   // [1, 2, 4, 5]\n```\n\n### 搜索操作\n\n**`find(value)`** - 查找首次出现的位置：\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2（首次出现的索引）\nlet idx2 = arr.find(99);     // -1（未找到）\n\n// 适用于任何类型\nlet words = [\"apple\", \"banana\", \"cherry\"];\nlet idx3 = words.find(\"banana\");  // 1\n```\n\n**`contains(value)`** - 检查数组是否包含某值：\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n```\n\n### 提取操作\n\n**`slice(start, end)`** - 提取子数组（end 不包含在内）：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4]（索引 1, 2, 3）\nlet first = arr.slice(0, 2); // [1, 2]\n\n// 原数组不变\nprint(arr);                  // [1, 2, 3, 4, 5]\n```\n\n**`first()`** - 获取第一个元素（不移除）：\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1（不移除）\nprint(arr);                  // [1, 2, 3]（不变）\n```\n\n**`last()`** - 获取最后一个元素（不移除）：\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3（不移除）\nprint(arr);                  // [1, 2, 3]（不变）\n```\n\n### 转换操作\n\n**`reverse()`** - 原地反转数组：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\n\nprint(arr);                  // [5, 4, 3, 2, 1]（已修改）\n```\n\n**`join(delimiter)`** - 将元素连接成字符串：\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// 适用于混合类型\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n```\n\n**`concat(other)`** - 与另一个数组连接：\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]（新数组）\n\n// 原数组不变\nprint(a);                    // [1, 2, 3]\nprint(b);                    // [4, 5, 6]\n```\n\n### 实用操作\n\n**`clear()`** - 移除所有元素：\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();                 // []\n\nprint(arr.length);           // 0\nprint(arr);                  // []\n```\n\n## 方法链式调用\n\n返回数组或值的方法可以进行链式调用：\n\n```hemlock\nlet result = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);  // [3, 4, 5]\n\nlet text = [\"apple\", \"banana\", \"cherry\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\nlet numbers = [5, 3, 8, 1, 9]\n    .slice(1, 4)\n    .concat([10, 11]);  // [3, 8, 1, 10, 11]\n```\n\n## 完整方法参考\n\n| 方法 | 参数 | 返回值 | 是否修改原数组 | 描述 |\n|--------|-----------|---------|---------|-------------|\n| `push(value)` | any | void | 是 | 在末尾添加元素 |\n| `pop()` | - | any | 是 | 移除并返回最后一个元素 |\n| `shift()` | - | any | 是 | 移除并返回第一个元素 |\n| `unshift(value)` | any | void | 是 | 在开头添加元素 |\n| `insert(index, value)` | i32, any | void | 是 | 在指定索引处插入 |\n| `remove(index)` | i32 | any | 是 | 移除并返回指定索引处的元素 |\n| `find(value)` | any | i32 | 否 | 查找首次出现的位置（未找到返回 -1） |\n| `contains(value)` | any | bool | 否 | 检查是否包含某值 |\n| `slice(start, end)` | i32, i32 | array | 否 | 提取子数组（新数组） |\n| `join(delimiter)` | string | string | 否 | 连接成字符串 |\n| `concat(other)` | array | array | 否 | 连接数组（新数组） |\n| `reverse()` | - | void | 是 | 原地反转 |\n| `first()` | - | any | 否 | 获取第一个元素 |\n| `last()` | - | any | 否 | 获取最后一个元素 |\n| `clear()` | - | void | 是 | 移除所有元素 |\n| `map(callback)` | fn | array | 否 | 转换每个元素 |\n| `filter(predicate)` | fn | array | 否 | 选择匹配的元素 |\n| `reduce(callback, initial)` | fn, any | any | 否 | 归约为单个值 |\n\n## 实现细节\n\n### 内存模型\n\n- **堆分配** - 动态容量\n- **自动增长** - 超出容量时翻倍\n- **不自动收缩** - 容量不会减少\n- **索引无边界检查** - 使用方法以确保安全\n\n### 容量管理\n\n```hemlock\nlet arr = [];  // 初始容量：0\n\narr.push(1);   // 增长到容量 1\narr.push(2);   // 增长到容量 2\narr.push(3);   // 增长到容量 4（翻倍）\narr.push(4);   // 仍然是容量 4\narr.push(5);   // 增长到容量 8（翻倍）\n```\n\n### 值比较\n\n`find()` 和 `contains()` 使用值相等比较：\n\n```hemlock\n// 基本类型：按值比较\nlet arr = [1, 2, 3];\narr.contains(2);  // true\n\n// 字符串：按值比较\nlet words = [\"hello\", \"world\"];\nwords.contains(\"hello\");  // true\n\n// 对象：按引用比较\nlet obj1 = { x: 10 };\nlet obj2 = { x: 10 };\nlet arr2 = [obj1];\narr2.contains(obj1);  // true（相同引用）\narr2.contains(obj2);  // false（不同引用）\n```\n\n## 常见模式\n\n### 函数式操作（map/filter/reduce）\n\n数组内置 `map`、`filter` 和 `reduce` 方法：\n\n```hemlock\n// map - 转换每个元素\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = numbers.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\n// filter - 选择匹配的元素\nlet evens = numbers.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4]\n\n// reduce - 归约为单个值\nlet sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\n// 链式调用函数式操作\nlet result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]\n    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]\n    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220\n```\n\n### 模式：数组作为栈\n\n```hemlock\nlet stack = [];\n\n// 压入栈\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// 弹出栈\nlet top = stack.pop();    // 3\nlet next = stack.pop();   // 2\n```\n\n### 模式：数组作为队列\n\n```hemlock\nlet queue = [];\n\n// 入队（添加到末尾）\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// 出队（从前面移除）\nlet first = queue.shift();   // 1\nlet second = queue.shift();  // 2\n```\n\n## 最佳实践\n\n1. **使用方法而非直接索引** - 边界检查和代码清晰度\n2. **检查边界** - 直接索引不进行边界检查\n3. **优先使用不可变操作** - 使用 `slice()` 和 `concat()` 而非修改原数组\n4. **预先初始化容量** - 如果知道大小（目前不支持）\n5. **使用 `contains()` 检查成员** - 比手动循环更清晰\n6. **链式调用方法** - 比嵌套调用更易读\n\n## 常见陷阱\n\n### 陷阱：直接索引越界\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// 无边界检查！\narr[10] = 99;  // 创建带有 null 的稀疏数组\nprint(arr.length);  // 11（不是 3！）\n\n// 更好的做法：使用 push() 或检查长度\nif (arr.length <= 10) {\n    arr.push(99);\n}\n```\n\n### 陷阱：修改与新建数组\n\n```hemlock\nlet arr = [1, 2, 3];\n\n// 修改原数组\narr.reverse();\nprint(arr);  // [3, 2, 1]\n\n// 返回新数组\nlet sub = arr.slice(0, 2);\nprint(arr);  // [3, 2, 1]（不变）\nprint(sub);  // [3, 2]\n```\n\n### 陷阱：引用相等\n\n```hemlock\nlet obj = { x: 10 };\nlet arr = [obj];\n\n// 相同引用：true\narr.contains(obj);  // true\n\n// 不同引用：false\narr.contains({ x: 10 });  // false（不同对象）\n```\n\n### 陷阱：长期存活的数组\n\n```hemlock\n// 局部作用域中的数组会自动释放，但全局/长期存活的数组需要注意\nlet global_cache = [];  // 模块级别，持续到程序退出\n\nfn add_to_cache(item) {\n    global_cache.push(item);  // 无限增长\n}\n\n// 对于长期存活的数据，考虑：\n// - 定期清空数组：global_cache.clear();\n// - 提前释放：free(global_cache);\n```\n\n## 示例\n\n### 示例：数组统计\n\n```hemlock\nfn mean(arr) {\n    let sum = 0;\n    let i = 0;\n    while (i < arr.length) {\n        sum = sum + arr[i];\n        i = i + 1;\n    }\n    return sum / arr.length;\n}\n\nfn max(arr) {\n    if (arr.length == 0) {\n        return null;\n    }\n\n    let max_val = arr[0];\n    let i = 1;\n    while (i < arr.length) {\n        if (arr[i] > max_val) {\n            max_val = arr[i];\n        }\n        i = i + 1;\n    }\n    return max_val;\n}\n\nlet numbers = [3, 7, 2, 9, 1];\nprint(mean(numbers));  // 4.4\nprint(max(numbers));   // 9\n```\n\n### 示例：数组去重\n\n```hemlock\nfn unique(arr) {\n    let result = [];\n    let i = 0;\n    while (i < arr.length) {\n        if (!result.contains(arr[i])) {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n    return result;\n}\n\nlet numbers = [1, 2, 2, 3, 1, 4, 3, 5];\nlet uniq = unique(numbers);  // [1, 2, 3, 4, 5]\n```\n\n### 示例：数组分块\n\n```hemlock\nfn chunk(arr, size) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        let chunk = arr.slice(i, i + size);\n        result.push(chunk);\n        i = i + size;\n    }\n\n    return result;\n}\n\nlet numbers = [1, 2, 3, 4, 5, 6, 7, 8];\nlet chunks = chunk(numbers, 3);\n// [[1, 2, 3], [4, 5, 6], [7, 8]]\n```\n\n### 示例：数组扁平化\n\n```hemlock\nfn flatten(arr) {\n    let result = [];\n    let i = 0;\n\n    while (i < arr.length) {\n        if (typeof(arr[i]) == \"array\") {\n            // 嵌套数组 - 扁平化它\n            let nested = flatten(arr[i]);\n            let j = 0;\n            while (j < nested.length) {\n                result.push(nested[j]);\n                j = j + 1;\n            }\n        } else {\n            result.push(arr[i]);\n        }\n        i = i + 1;\n    }\n\n    return result;\n}\n\nlet nested = [1, [2, 3], [4, [5, 6]], 7];\nlet flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]\n```\n\n### 示例：排序（冒泡排序）\n\n```hemlock\nfn sort(arr) {\n    let n = arr.length;\n    let i = 0;\n\n    while (i < n) {\n        let j = 0;\n        while (j < n - i - 1) {\n            if (arr[j] > arr[j + 1]) {\n                // 交换\n                let temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n}\n\nlet numbers = [5, 2, 8, 1, 9];\nsort(numbers);  // 原地修改\nprint(numbers);  // [1, 2, 5, 8, 9]\n```\n\n## 限制\n\n当前限制：\n\n- **索引无边界检查** - 直接访问不检查边界\n- **对象使用引用相等** - `find()` 和 `contains()` 使用引用比较\n- **无数组解构** - 不支持 `let [a, b] = arr` 语法\n- **无展开运算符** - 不支持 `[...arr1, ...arr2]` 语法\n\n**注意：** 数组使用引用计数，作用域退出时自动释放。详见 [内存管理](memory.md#internal-reference-counting)。\n\n## 相关主题\n\n- [字符串](#language-guide-strings) - 字符串方法与数组方法类似\n- [对象](#language-guide-objects) - 数组也是类对象的\n- [函数](#language-guide-functions) - 数组与高阶函数\n- [控制流](#language-guide-control-flow) - 遍历数组\n\n## 另请参阅\n\n- **动态大小**：数组通过容量翻倍自动增长\n- **方法**：18 个全面的操作方法，包括 map/filter/reduce\n- **内存**：详见 [内存](#language-guide-memory) 了解数组分配细节\n"}, "语言指南 -> 模块": {"id": "language-guide-modules", "content": "# Hemlock 模块系统\n\n本文档描述了为 Hemlock 实现的 ES6 风格 import/export 模块系统。\n\n## 概述\n\nHemlock 支持基于文件的模块系统，使用 ES6 风格的 import/export 语法。模块具有以下特点：\n- **单例**：每个模块只加载一次并被缓存\n- **基于文件**：模块对应磁盘上的 .hml 文件\n- **显式导入**：依赖通过 import 语句声明\n- **拓扑执行**：依赖在依赖者之前执行\n\n有关包管理和第三方依赖，请参阅 [hpm (Hemlock 包管理器)](https://github.com/hemlang/hpm)。\n\n## 语法\n\n### Export 语句\n\n**内联命名导出：**\n```hemlock\nexport fn add(a, b) {\n    return a + b;\n}\n\nexport const PI = 3.14159;\nexport let counter = 0;\n```\n\n**导出列表：**\n```hemlock\nfn add(a, b) { return a + b; }\nfn subtract(a, b) { return a - b; }\n\nexport { add, subtract };\n```\n\n**导出 Extern（FFI 函数）：**\n```hemlock\nimport \"libc.so.6\";\n\n// 导出 FFI 函数供其他模块使用\nexport extern fn strlen(s: string): i32;\nexport extern fn getpid(): i32;\n```\n\n有关导出 FFI 函数的更多详细信息，请参阅 [FFI 文档](../advanced/ffi.md#exporting-ffi-functions)。\n\n**导出 Define（结构体类型）：**\n```hemlock\n// 导出结构体类型定义\nexport define Vector2 {\n    x: f32,\n    y: f32,\n}\n\nexport define Rectangle {\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n}\n```\n\n**重要说明：** 导出的结构体类型在模块加载时全局注册。当你从模块导入任何内容时，它们会自动可用 - 你不需要（也不能）通过名称显式导入它们：\n\n```hemlock\n// 正确 - 任何导入后结构体类型自动可用\nimport { some_function } from \"./my_module.hml\";\nlet v: Vector2 = { x: 1.0, y: 2.0 };  // 可以工作！\n\n// 错误 - 不能显式导入结构体类型\nimport { Vector2 } from \"./my_module.hml\";  // 错误：未定义变量 'Vector2'\n```\n\n有关导出结构体类型的更多详细信息，请参阅 [FFI 文档](../advanced/ffi.md#exporting-struct-types)。\n\n**重新导出：**\n```hemlock\n// 从另一个模块重新导出\nexport { add, subtract } from \"./math.hml\";\n```\n\n### Import 语句\n\n**命名导入：**\n```hemlock\nimport { add, subtract } from \"./math.hml\";\nprint(add(1, 2));  // 3\n```\n\n**命名空间导入：**\n```hemlock\nimport * as math from \"./math.hml\";\nprint(math.add(1, 2));  // 3\nprint(math.PI);  // 3.14159\n```\n\n**别名：**\n```hemlock\nimport { add as sum, subtract as diff } from \"./math.hml\";\nprint(sum(1, 2));  // 3\n```\n\n## 模块解析\n\n### 路径类型\n\n**相对路径：**\n```hemlock\nimport { foo } from \"./module.hml\";       // 同一目录\nimport { bar } from \"../parent.hml\";      // 父目录\nimport { baz } from \"./sub/nested.hml\";   // 子目录\n```\n\n**绝对路径：**\n```hemlock\nimport { foo } from \"/absolute/path/to/module.hml\";\n```\n\n**扩展名处理：**\n- `.hml` 扩展名可以省略 - 会自动添加\n- `./math` 解析为 `./math.hml`\n\n## 特性\n\n### 循环依赖检测\n\n模块系统检测循环依赖并报告错误：\n\n```\nError: Circular dependency detected when loading '/path/to/a.hml'\n```\n\n### 模块缓存\n\n模块只加载一次并被缓存。多次导入同一模块返回相同的实例：\n\n```hemlock\n// counter.hml\nexport let count = 0;\nexport fn increment() {\n    count = count + 1;\n}\n\n// a.hml\nimport { count, increment } from \"./counter.hml\";\nincrement();\nprint(count);  // 1\n\n// b.hml\nimport { count } from \"./counter.hml\";  // 同一实例！\nprint(count);  // 仍然是 1（共享状态）\n```\n\n### 导入不可变性\n\n导入的绑定不能被重新赋值：\n\n```hemlock\nimport { add } from \"./math.hml\";\nadd = fn() { };  // 错误：不能重新赋值导入的绑定\n```\n\n## 实现细节\n\n### 架构\n\n**文件：**\n- `include/module.h` - 模块系统 API\n- `src/module.c` - 模块加载、缓存和执行\n- `src/parser.c` 中的解析器支持\n- `src/interpreter/runtime.c` 中的运行时支持\n\n**关键组件：**\n1. **ModuleCache**：按绝对路径索引维护已加载的模块\n2. **Module**：表示带有 AST 和导出的已加载模块\n3. **路径解析**：将相对/绝对路径解析为规范路径\n4. **拓扑执行**：按依赖顺序执行模块\n\n### 模块加载过程\n\n1. **解析阶段**：对模块文件进行词法分析和语法分析\n2. **依赖解析**：递归加载导入的模块\n3. **循环检测**：检查模块是否已在加载中\n4. **缓存**：按绝对路径将模块存储在缓存中\n5. **执行阶段**：按拓扑顺序执行（依赖优先）\n\n### API\n\n```c\n// 高级 API\nint execute_file_with_modules(const char *file_path,\n                               int argc, char **argv,\n                               ExecutionContext *ctx);\n\n// 低级 API\nModuleCache* module_cache_new(const char *initial_dir);\nvoid module_cache_free(ModuleCache *cache);\nModule* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);\nvoid execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);\n```\n\n## 测试\n\n测试模块位于 `tests/modules/` 和 `tests/parity/modules/`：\n\n- `math.hml` - 带导出的基本模块\n- `test_import_named.hml` - 命名导入测试\n- `test_import_namespace.hml` - 命名空间导入测试\n- `test_import_alias.hml` - 导入别名测试\n- `export_extern.hml` - 导出 extern FFI 函数测试（Linux）\n\n## 包导入（hpm）\n\n安装 [hpm](https://github.com/hemlang/hpm) 后，你可以从 GitHub 导入第三方包：\n\n```hemlock\n// 从包根目录导入（使用 package.json 中的 \"main\"）\nimport { app, router } from \"hemlang/sprout\";\n\n// 从子路径导入\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// 标准库（内置于 Hemlock）\nimport { HashMap } from \"@stdlib/collections\";\n```\n\n包安装到 `hem_modules/` 并使用 GitHub `owner/repo` 语法解析。\n\n```bash\n# 安装包\nhpm install hemlang/sprout\n\n# 带版本约束安装\nhpm install hemlang/sprout@^1.0.0\n```\n\n有关完整详细信息，请参阅 [hpm 文档](https://github.com/hemlang/hpm)。\n\n## 当前限制\n\n1. **不支持动态导入**：`import()` 作为运行时函数不受支持\n2. **不支持条件导出**：导出必须在顶层\n3. **静态库路径**：FFI 库导入使用静态路径（特定于平台）\n\n## 未来工作\n\n- 使用 `import()` 函数的动态导入\n- 条件导出\n- 模块元数据（`import.meta`）\n- Tree shaking 和死代码消除\n\n## 示例\n\n有关模块系统的工作示例，请参阅 `tests/modules/`。\n\n示例模块结构：\n```\nproject/\n├── main.hml\n├── lib/\n│   ├── math.hml\n│   ├── string.hml\n│   └── index.hml (barrel 模块)\n└── utils/\n    └── helpers.hml\n```\n\n示例用法：\n```hemlock\n// lib/math.hml\nexport fn add(a, b) { return a + b; }\nexport fn multiply(a, b) { return a * b; }\n\n// lib/index.hml (barrel)\nexport { add, multiply } from \"./math.hml\";\n\n// main.hml\nimport { add } from \"./lib/index.hml\";\nprint(add(2, 3));  // 5\n```\n"}, "语言指南 -> 模式匹配": {"id": "language-guide-pattern-matching", "content": "# 模式匹配\n\nHemlock 通过 `match` 表达式提供强大的模式匹配功能，提供了一种简洁的方式来解构值、检查类型和处理多种情况。\n\n## 基本语法\n\n```hemlock\nlet result = match (value) {\n    pattern1 => expression1,\n    pattern2 => expression2,\n    _ => default_expression\n};\n```\n\nmatch 表达式按顺序将 `value` 与每个模式进行匹配，返回第一个匹配分支的表达式结果。\n\n## 模式类型\n\n### 字面量模式\n\n匹配精确值：\n\n```hemlock\nlet x = 42;\nlet msg = match (x) {\n    0 => \"zero\",\n    1 => \"one\",\n    42 => \"the answer\",\n    _ => \"other\"\n};\nprint(msg);  // \"the answer\"\n```\n\n支持的字面量：\n- **整数**：`0`、`42`、`-5`\n- **浮点数**：`3.14`、`-0.5`\n- **字符串**：`\"hello\"`、`\"world\"`\n- **布尔值**：`true`、`false`\n- **空值**：`null`\n\n### 通配符模式（`_`）\n\n匹配任何值但不绑定：\n\n```hemlock\nlet x = \"anything\";\nlet result = match (x) {\n    \"specific\" => \"found it\",\n    _ => \"wildcard matched\"\n};\n```\n\n### 变量绑定模式\n\n将匹配的值绑定到变量：\n\n```hemlock\nlet x = 100;\nlet result = match (x) {\n    0 => \"zero\",\n    n => \"value is \" + n  // n 绑定到 100\n};\nprint(result);  // \"value is 100\"\n```\n\n### OR 模式（`|`）\n\n匹配多个替代项：\n\n```hemlock\nlet x = 2;\nlet size = match (x) {\n    1 | 2 | 3 => \"small\",\n    4 | 5 | 6 => \"medium\",\n    _ => \"large\"\n};\n\n// 也适用于字符串\nlet cmd = \"quit\";\nlet action = match (cmd) {\n    \"exit\" | \"quit\" | \"q\" => \"exiting\",\n    \"help\" | \"h\" | \"?\" => \"showing help\",\n    _ => \"unknown\"\n};\n```\n\n### 守卫表达式（`if`）\n\n为模式添加条件：\n\n```hemlock\nlet x = 15;\nlet category = match (x) {\n    n if n < 0 => \"negative\",\n    n if n == 0 => \"zero\",\n    n if n < 10 => \"small\",\n    n if n < 100 => \"medium\",\n    n => \"large: \" + n\n};\nprint(category);  // \"medium\"\n\n// 复杂守卫\nlet y = 12;\nlet result = match (y) {\n    n if n % 2 == 0 && n > 10 => \"even and greater than 10\",\n    n if n % 2 == 0 => \"even\",\n    n => \"odd\"\n};\n```\n\n### 类型模式\n\n基于类型检查和绑定：\n\n```hemlock\nlet val = 42;\nlet desc = match (val) {\n    num: i32 => \"integer: \" + num,\n    str: string => \"string: \" + str,\n    flag: bool => \"boolean: \" + flag,\n    _ => \"other type\"\n};\nprint(desc);  // \"integer: 42\"\n```\n\n支持的类型：`i8`、`i16`、`i32`、`i64`、`u8`、`u16`、`u32`、`u64`、`f32`、`f64`、`bool`、`string`、`array`、`object`\n\n## 解构模式\n\n### 对象解构\n\n从对象中提取字段：\n\n```hemlock\nlet point = { x: 10, y: 20 };\nlet result = match (point) {\n    { x, y } => \"point at \" + x + \",\" + y\n};\nprint(result);  // \"point at 10,20\"\n\n// 带字面量字段值\nlet origin = { x: 0, y: 0 };\nlet name = match (origin) {\n    { x: 0, y: 0 } => \"origin\",\n    { x: 0, y } => \"on y-axis at \" + y,\n    { x, y: 0 } => \"on x-axis at \" + x,\n    { x, y } => \"point at \" + x + \",\" + y\n};\nprint(name);  // \"origin\"\n```\n\n### 数组解构\n\n匹配数组结构和元素：\n\n```hemlock\nlet arr = [1, 2, 3];\nlet desc = match (arr) {\n    [] => \"empty\",\n    [x] => \"single: \" + x,\n    [x, y] => \"pair: \" + x + \",\" + y,\n    [x, y, z] => \"triple: \" + x + \",\" + y + \",\" + z,\n    _ => \"many elements\"\n};\nprint(desc);  // \"triple: 1,2,3\"\n\n// 带字面量值\nlet pair = [1, 2];\nlet result = match (pair) {\n    [0, 0] => \"both zero\",\n    [1, x] => \"starts with 1, second is \" + x,\n    [x, 1] => \"ends with 1\",\n    _ => \"other\"\n};\nprint(result);  // \"starts with 1, second is 2\"\n```\n\n### 数组剩余模式（`...`）\n\n捕获剩余元素：\n\n```hemlock\nlet nums = [1, 2, 3, 4, 5];\n\n// 头部和尾部\nlet result = match (nums) {\n    [first, ...rest] => \"first: \" + first,\n    [] => \"empty\"\n};\nprint(result);  // \"first: 1\"\n\n// 前两个元素\nlet result2 = match (nums) {\n    [a, b, ...rest] => \"first two: \" + a + \",\" + b,\n    _ => \"too short\"\n};\nprint(result2);  // \"first two: 1,2\"\n```\n\n### 嵌套解构\n\n组合模式处理复杂数据：\n\n```hemlock\nlet user = {\n    name: \"Alice\",\n    address: { city: \"NYC\", zip: 10001 }\n};\n\nlet result = match (user) {\n    { name, address: { city, zip } } => name + \" lives in \" + city,\n    _ => \"unknown\"\n};\nprint(result);  // \"Alice lives in NYC\"\n\n// 包含数组的对象\nlet data = { items: [1, 2, 3], count: 3 };\nlet result2 = match (data) {\n    { items: [first, ...rest], count } => \"first: \" + first + \", total: \" + count,\n    _ => \"no items\"\n};\nprint(result2);  // \"first: 1, total: 3\"\n```\n\n## Match 作为表达式\n\nMatch 是一个返回值的表达式：\n\n```hemlock\n// 直接赋值\nlet grade = 85;\nlet letter = match (grade) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    n if n >= 70 => \"C\",\n    n if n >= 60 => \"D\",\n    _ => \"F\"\n};\n\n// 在字符串连接中\nlet msg = \"Grade: \" + match (grade) {\n    n if n >= 70 => \"passing\",\n    _ => \"failing\"\n};\n\n// 在函数返回中\nfn classify(n: i32): string {\n    return match (n) {\n        0 => \"zero\",\n        n if n > 0 => \"positive\",\n        _ => \"negative\"\n    };\n}\n```\n\n## 模式匹配最佳实践\n\n1. **顺序很重要**：模式从上到下检查；将特定模式放在通用模式之前\n2. **使用通配符确保完整性**：除非确定所有情况都已覆盖，否则始终包含 `_` 回退\n3. **优先使用守卫而非嵌套条件**：守卫使意图更清晰\n4. **使用解构而非手动字段访问**：更简洁且更安全\n\n```hemlock\n// 好：使用守卫进行范围检查\nmatch (score) {\n    n if n >= 90 => \"A\",\n    n if n >= 80 => \"B\",\n    _ => \"below B\"\n}\n\n// 好：解构而非访问字段\nmatch (point) {\n    { x: 0, y: 0 } => \"origin\",\n    { x, y } => \"at \" + x + \",\" + y\n}\n\n// 避免：过于复杂的嵌套模式\n// 考虑拆分为多个 match 或使用守卫\n```\n\n## 与其他语言的比较\n\n| 特性 | Hemlock | Rust | JavaScript |\n|---------|---------|------|------------|\n| 基本匹配 | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |\n| 解构 | 是 | 是 | 部分（switch 不解构） |\n| 守卫 | `n if n > 0 =>` | `n if n > 0 =>` | 不适用 |\n| OR 模式 | `1 \\| 2 \\| 3 =>` | `1 \\| 2 \\| 3 =>` | `case 1: case 2: case 3:` |\n| 剩余模式 | `[a, ...rest]` | `[a, rest @ ..]` | 不适用 |\n| 类型模式 | `n: i32` | 通过 `match` 分支的类型 | 不适用 |\n| 返回值 | 是 | 是 | 否（语句） |\n\n## 实现说明\n\n模式匹配在解释器和编译器后端都实现了完全一致性 - 两者对相同输入产生相同的结果。该功能在 Hemlock v1.8.0+ 中可用。\n"}, "语言指南 -> 类型": {"id": "language-guide-types", "content": "# 类型系统\n\nHemlock 具有**动态类型系统**，支持可选的类型注解和运行时类型检查。\n\n---\n\n## 类型选择指南：我应该使用什么类型？\n\n**类型新手？** 从这里开始。如果你熟悉类型系统，可以跳到[设计理念](#设计理念)。\n\n### 简短答案\n\n**让 Hemlock 自动判断：**\n\n```hemlock\nlet count = 42;        // Hemlock 知道这是整数\nlet price = 19.99;     // Hemlock 知道这是小数\nlet name = \"Alice\";    // Hemlock 知道这是文本\nlet active = true;     // Hemlock 知道这是布尔值\n```\n\nHemlock 会自动为你的值选择正确的类型。你*不需要*指定类型。\n\n### 何时添加类型注解\n\n在以下情况下添加类型：\n\n1. **需要指定大小** - `i8` 与 `i64` 对于内存或 FFI 很重要\n2. **记录代码** - 类型显示函数期望什么\n3. **尽早发现错误** - Hemlock 在运行时检查类型\n\n```hemlock\n// 无类型（正常工作）：\nfn add(a, b) {\n    return a + b;\n}\n\n// 有类型（更明确）：\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### 快速参考：选择数字类型\n\n| 存储内容 | 建议类型 | 示例 |\n|---------|---------|------|\n| 普通整数 | `i32`（默认） | `let count = 42;` |\n| 非常大的数字 | `i64` | `let population = 8000000000;` |\n| 永不为负的计数 | `u32` | `let items: u32 = 100;` |\n| 字节 (0-255) | `u8` | `let pixel: u8 = 255;` |\n| 小数/分数 | `f64`（默认） | `let price = 19.99;` |\n| 性能关键的小数 | `f32` | `let x: f32 = 1.5;` |\n\n### 快速参考：所有类型\n\n| 类别 | 类型 | 何时使用 |\n|-----|------|---------|\n| **整数** | `i8`, `i16`, `i32`, `i64` | 计数、ID、年龄等 |\n| **仅正数** | `u8`, `u16`, `u32`, `u64` | 字节、大小、数组长度 |\n| **小数** | `f32`, `f64` | 金额、测量值、数学计算 |\n| **是/否** | `bool` | 标志、条件 |\n| **文本** | `string` | 名称、消息、任何文本 |\n| **单个字符** | `rune` | 单个字母、表情符号 |\n| **列表** | `array` | 值的集合 |\n| **命名字段** | `object` | 分组相关数据 |\n| **原始内存** | `ptr`, `buffer` | 低级编程 |\n| **空值** | `null` | 表示没有值 |\n\n### 常见场景\n\n**\"我只需要一个数字\"**\n```hemlock\nlet x = 42;  // 完成！Hemlock 选择 i32\n```\n\n**\"我需要小数\"**\n```hemlock\nlet price = 19.99;  // 完成！Hemlock 选择 f64\n```\n\n**\"我在处理字节（文件、网络）\"**\n```hemlock\nlet byte: u8 = 255;  // 0-255 范围\n```\n\n**\"我需要非常大的数字\"**\n```hemlock\nlet big = 9000000000000;  // Hemlock 自动选择 i64（> i32 最大值）\n// 或者明确指定：\nlet big: i64 = 9000000000000;\n```\n\n**\"我在存储金额\"**\n```hemlock\n// 选项 1：浮点数（简单，但有精度限制）\nlet price: f64 = 19.99;\n\n// 选项 2：以分为单位存储（更精确）\nlet price_cents: i32 = 1999;  // $19.99 作为整数分\n```\n\n**\"我在向 C 代码传递数据 (FFI)\"**\n```hemlock\n// 精确匹配 C 类型\nlet c_int: i32 = 100;      // C 'int'\nlet c_long: i64 = 100;     // C 'long'（64 位系统）\nlet c_char: u8 = 65;       // C 'char'\nlet c_double: f64 = 3.14;  // C 'double'\n```\n\n### 类型混合时会发生什么？\n\n当你组合不同类型时，Hemlock 会提升为\"更大\"的类型：\n\n```hemlock\nlet a: i32 = 10;\nlet b: f64 = 2.5;\nlet result = a + b;  // result 是 f64 (12.5)\n// 整数自动变成了小数\n```\n\n**经验法则：** 浮点数总是\"赢\" - 任何整数与浮点数混合都会得到浮点数。\n\n### 类型错误\n\n如果你尝试使用错误的类型，Hemlock 会在运行时告诉你：\n\n```hemlock\nlet age: i32 = \"thirty\";  // 错误：类型不匹配 - 期望 i32，得到 string\n```\n\n要转换类型，使用类型构造函数：\n\n```hemlock\nlet text = \"42\";\nlet number = i32(text);   // 解析字符串为整数：42\nlet back = text + \"\";     // 已经是字符串\n```\n\n---\n\n## 设计理念\n\n- **默认动态** - 每个值都有运行时类型标签\n- **可选类型** - 可选的类型注解强制运行时检查\n- **显式转换** - 隐式转换遵循明确的提升规则\n- **类型诚实** - `typeof()` 始终说实话\n\n## 原始类型\n\n### 整数类型\n\n**有符号整数：**\n```hemlock\nlet tiny: i8 = 127;              // 8 位（-128 到 127）\nlet small: i16 = 32767;          // 16 位（-32768 到 32767）\nlet normal: i32 = 2147483647;    // 32 位（默认）\nlet large: i64 = 9223372036854775807;  // 64 位\n```\n\n**无符号整数：**\n```hemlock\nlet byte: u8 = 255;              // 8 位（0 到 255）\nlet word: u16 = 65535;           // 16 位（0 到 65535）\nlet dword: u32 = 4294967295;     // 32 位（0 到 4294967295）\nlet qword: u64 = 18446744073709551615;  // 64 位\n```\n\n**类型别名：**\n```hemlock\nlet i: integer = 42;   // i32 的别名\nlet b: byte = 255;     // u8 的别名\n```\n\n### 浮点类型\n\n```hemlock\nlet f: f32 = 3.14159;        // 32 位浮点数\nlet d: f64 = 2.718281828;    // 64 位浮点数（默认）\nlet n: number = 1.618;       // f64 的别名\n```\n\n### 布尔类型\n\n```hemlock\nlet flag: bool = true;\nlet active: bool = false;\n```\n\n### 字符串类型\n\n```hemlock\nlet text: string = \"Hello, World!\";\nlet empty: string = \"\";\n```\n\n字符串是**可变的**、**UTF-8 编码的**、**堆分配的**。\n\n详见 [Strings](#language-guide-strings)。\n\n### Rune 类型\n\n```hemlock\nlet ch: rune = 'A';\nlet emoji: rune = '🚀';\nlet newline: rune = '\\n';\nlet unicode: rune = '\\u{1F680}';\n```\n\nRune 表示 **Unicode 码点**（U+0000 到 U+10FFFF）。\n\n详见 [Runes](#language-guide-runes)。\n\n### Null 类型\n\n```hemlock\nlet nothing = null;\nlet uninitialized: string = null;\n```\n\n`null` 是具有单一值的独立类型。\n\n## 复合类型\n\n### 数组类型\n\n```hemlock\nlet numbers: array = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];  // 允许混合类型\nlet empty: array = [];\n```\n\n详见 [Arrays](#language-guide-arrays)。\n\n### 对象类型\n\n```hemlock\nlet obj: object = { x: 10, y: 20 };\nlet person = { name: \"Alice\", age: 30 };\n```\n\n详见 [Objects](#language-guide-objects)。\n\n### 指针类型\n\n**原始指针：**\n```hemlock\nlet p: ptr = alloc(64);\n// 无边界检查，手动生命周期管理\nfree(p);\n```\n\n**安全缓冲区：**\n```hemlock\nlet buf: buffer = buffer(64);\n// 有边界检查，跟踪长度和容量\nfree(buf);\n```\n\n详见 [Memory Management](#language-guide-memory)。\n\n## 枚举类型\n\n枚举定义一组命名常量：\n\n### 基本枚举\n\n```hemlock\nenum Color {\n    RED,\n    GREEN,\n    BLUE\n}\n\nlet c = Color.RED;\nprint(c);              // 0\nprint(typeof(c));      // \"Color\"\n\n// 比较\nif (c == Color.RED) {\n    print(\"It's red!\");\n}\n\n// 在枚举上使用 switch\nswitch (c) {\n    case Color.RED:\n        print(\"Stop\");\n        break;\n    case Color.GREEN:\n        print(\"Go\");\n        break;\n    case Color.BLUE:\n        print(\"Blue?\");\n        break;\n}\n```\n\n### 带值的枚举\n\n枚举可以有显式的整数值：\n\n```hemlock\nenum Status {\n    OK = 0,\n    ERROR = 1,\n    PENDING = 2\n}\n\nprint(Status.OK);      // 0\nprint(Status.ERROR);   // 1\n\nenum HttpCode {\n    OK = 200,\n    NOT_FOUND = 404,\n    SERVER_ERROR = 500\n}\n\nlet code = HttpCode.NOT_FOUND;\nprint(code);           // 404\n```\n\n### 自动递增值\n\n没有显式值时，枚举从 0 自动递增：\n\n```hemlock\nenum Priority {\n    LOW,       // 0\n    MEDIUM,    // 1\n    HIGH,      // 2\n    CRITICAL   // 3\n}\n\n// 可以混合显式和自动值\nenum Level {\n    DEBUG = 10,\n    INFO,      // 11\n    WARN,      // 12\n    ERROR = 50,\n    FATAL      // 51\n}\n```\n\n### 枚举使用模式\n\n```hemlock\n// 作为函数参数\nfn set_priority(p: Priority) {\n    if (p == Priority.CRITICAL) {\n        print(\"Urgent!\");\n    }\n}\n\nset_priority(Priority.HIGH);\n\n// 在对象中\ndefine Task {\n    name: string,\n    priority: Priority\n}\n\nlet task: Task = {\n    name: \"Fix bug\",\n    priority: Priority.HIGH\n};\n```\n\n## 特殊类型\n\n### 文件类型\n\n```hemlock\nlet f: file = open(\"data.txt\", \"r\");\nf.close();\n```\n\n表示打开的文件句柄。\n\n### 任务类型\n\n```hemlock\nasync fn compute(): i32 { return 42; }\nlet task = spawn(compute);\nlet result: i32 = join(task);\n```\n\n表示异步任务句柄。\n\n### 通道类型\n\n```hemlock\nlet ch: channel = channel(10);\nch.send(42);\nlet value = ch.recv();\n```\n\n表示任务之间的通信通道。\n\n### Void 类型\n\n```hemlock\nextern fn exit(code: i32): void;\n```\n\n用于不返回值的函数（仅限 FFI）。\n\n## 类型推断\n\n### 整数字面量推断\n\nHemlock 根据值范围推断整数类型：\n\n```hemlock\nlet a = 42;              // i32（适合 32 位）\nlet b = 5000000000;      // i64（> i32 最大值）\nlet c = 128;             // i32\nlet d: u8 = 128;         // u8（显式注解）\n```\n\n**规则：**\n- i32 范围内的值（-2147483648 到 2147483647）：推断为 `i32`\n- 超出 i32 范围但在 i64 范围内的值：推断为 `i64`\n- 其他类型（i8、i16、u8、u16、u32、u64）使用显式注解\n\n### 浮点字面量推断\n\n```hemlock\nlet x = 3.14;        // f64（默认）\nlet y: f32 = 3.14;   // f32（显式）\n```\n\n### 科学计数法\n\nHemlock 支持数字字面量的科学计数法：\n\n```hemlock\nlet a = 1e10;        // 10000000000.0 (f64)\nlet b = 1e-12;       // 0.000000000001 (f64)\nlet c = 3.14e2;      // 314.0 (f64)\nlet d = 2.5e-3;      // 0.0025 (f64)\nlet e = 1E10;        // 大小写不敏感\nlet f = 1e+5;        // 显式正指数\n```\n\n**注意：** 使用科学计数法的任何字面量始终推断为 `f64`。\n\n### 其他类型推断\n\n```hemlock\nlet s = \"hello\";     // string\nlet ch = 'A';        // rune\nlet flag = true;     // bool\nlet arr = [1, 2, 3]; // array\nlet obj = { x: 10 }; // object\nlet nothing = null;  // null\n```\n\n## 类型注解\n\n### 变量注解\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet name: string = \"Alice\";\n```\n\n### 函数参数注解\n\n```hemlock\nfn greet(name: string, age: i32) {\n    print(\"Hello, \" + name + \"!\");\n}\n```\n\n### 函数返回类型注解\n\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### 对象类型注解（鸭子类型）\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\n```\n\n## 类型检查\n\n### 运行时类型检查\n\n类型注解在**运行时**检查，而不是编译时：\n\n```hemlock\nlet x: i32 = 42;     // OK\nlet y: i32 = 3.14;   // 运行时错误：类型不匹配\n\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n\nadd(5, 3);           // OK\nadd(5, \"hello\");     // 运行时错误：类型不匹配\n```\n\n### 类型查询\n\n使用 `typeof()` 检查值类型：\n\n```hemlock\nprint(typeof(42));         // \"i32\"\nprint(typeof(3.14));       // \"f64\"\nprint(typeof(\"hello\"));    // \"string\"\nprint(typeof(true));       // \"bool\"\nprint(typeof(null));       // \"null\"\nprint(typeof([1, 2, 3]));  // \"array\"\nprint(typeof({ x: 10 }));  // \"object\"\n```\n\n## 类型转换\n\n### 隐式类型提升\n\n当操作中混合类型时，Hemlock 提升为\"更高\"的类型：\n\n**提升层次（从低到高）：**\n```\ni8 → i16 → i32 → u32 → i64 → u64 → f32 → f64\n      ↑     ↑     ↑\n     u8    u16\n```\n\n**浮点数总是赢：**\n```hemlock\nlet x: i32 = 10;\nlet y: f64 = 3.5;\nlet result = x + y;  // result 是 f64 (13.5)\n```\n\n**更大的尺寸赢：**\n```hemlock\nlet a: i32 = 100;\nlet b: i64 = 200;\nlet sum = a + b;     // sum 是 i64 (300)\n```\n\n**精度保持：** 当 64 位整数与 f32 混合时，Hemlock 提升为 f64 以避免精度损失（f32 只有 24 位尾数，不足以表示 i64/u64）：\n```hemlock\nlet big: i64 = 9007199254740993;\nlet small: f32 = 1.0;\nlet result = big + small;  // result 是 f64，不是 f32！\n```\n\n**示例：**\n```hemlock\nu8 + i32  → i32\ni32 + i64 → i64\nu32 + u64 → u64\ni32 + f32 → f32    // f32 足以表示 i32\ni64 + f32 → f64    // 需要 f64 来保持 i64 精度\ni64 + f64 → f64\ni8 + f64  → f64\n```\n\n### 显式类型转换\n\n**整数与浮点数转换：**\n```hemlock\nlet i: i32 = 42;\nlet f: f64 = i;      // i32 → f64 (42.0)\n\nlet x: f64 = 3.14;\nlet n: i32 = x;      // f64 → i32 (3，截断)\n```\n\n**整数与 Rune 转换：**\n```hemlock\nlet code: i32 = 65;\nlet ch: rune = code;  // i32 → rune ('A')\n\nlet r: rune = 'Z';\nlet value: i32 = r;   // rune → i32 (90)\n```\n\n**Rune 转字符串：**\n```hemlock\nlet ch: rune = '🚀';\nlet s: string = ch;   // rune → string (\"🚀\")\n```\n\n**u8 转 Rune：**\n```hemlock\nlet b: u8 = 65;\nlet r: rune = b;      // u8 → rune ('A')\n```\n\n### 类型构造函数\n\n类型名称可以用作函数来转换或解析值：\n\n**解析字符串为数字：**\n```hemlock\nlet n = i32(\"42\");       // 解析字符串为 i32：42\nlet f = f64(\"3.14159\");  // 解析字符串为 f64：3.14159\nlet b = bool(\"true\");    // 解析字符串为 bool：true\n\n// 支持所有数字类型\nlet a = i8(\"-128\");      // 解析为 i8\nlet c = u8(\"255\");       // 解析为 u8\nlet d = i16(\"1000\");     // 解析为 i16\nlet e = u16(\"50000\");    // 解析为 u16\nlet g = i64(\"9000000000000\"); // 解析为 i64\nlet h = u64(\"18000000000000\"); // 解析为 u64\nlet j = f32(\"1.5\");      // 解析为 f32\n```\n\n**十六进制和负数：**\n```hemlock\nlet hex = i32(\"0xFF\");   // 255\nlet neg = i32(\"-42\");    // -42\nlet bin = i32(\"0b1010\"); // 10（二进制）\n```\n\n**类型别名也可以：**\n```hemlock\nlet x = integer(\"100\");  // 等同于 i32(\"100\")\nlet y = number(\"1.5\");   // 等同于 f64(\"1.5\")\nlet z = byte(\"200\");     // 等同于 u8(\"200\")\n```\n\n**数字类型之间转换：**\n```hemlock\nlet big = i64(42);           // i32 转 i64\nlet truncated = i32(3.99);   // f64 转 i32（截断为 3）\nlet promoted = f64(100);     // i32 转 f64 (100.0)\nlet narrowed = i8(127);      // i32 转 i8\n```\n\n**类型注解执行数字强制转换（但不解析字符串）：**\n```hemlock\nlet f: f64 = 100;        // 通过注解 i32 转 f64（OK）\nlet s: string = 'A';     // 通过注解 Rune 转 string（OK）\nlet code: i32 = 'A';     // 通过注解 Rune 转 i32（获取码点，OK）\n\n// 字符串解析需要显式类型构造函数：\nlet n = i32(\"42\");       // 使用类型构造函数解析字符串\n// let x: i32 = \"42\";    // 错误 - 类型注解不解析字符串\n```\n\n**错误处理：**\n```hemlock\n// 使用类型构造函数时，无效字符串会抛出错误\nlet bad = i32(\"hello\");  // 运行时错误：无法将 \"hello\" 解析为 i32\nlet overflow = u8(\"256\"); // 运行时错误：256 超出 u8 范围\n```\n\n**布尔解析：**\n```hemlock\nlet t = bool(\"true\");    // true\nlet f = bool(\"false\");   // false\nlet bad = bool(\"yes\");   // 运行时错误：必须是 \"true\" 或 \"false\"\n```\n\n## 范围检查\n\n类型注解在赋值时强制范围检查：\n\n```hemlock\nlet x: u8 = 255;    // OK\nlet y: u8 = 256;    // 错误：超出 u8 范围\n\nlet a: i8 = 127;    // OK\nlet b: i8 = 128;    // 错误：超出 i8 范围\n\nlet c: i64 = 2147483647;   // OK\nlet d: u64 = 4294967295;   // OK\nlet e: u64 = -1;           // 错误：u64 不能为负\n```\n\n## 类型提升示例\n\n### 混合整数类型\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet sum = a + b;     // i32 (30)\n\nlet c: u8 = 100;\nlet d: u32 = 200;\nlet total = c + d;   // u32 (300)\n```\n\n### 整数 + 浮点数\n\n```hemlock\nlet i: i32 = 5;\nlet f: f32 = 2.5;\nlet result = i * f;  // f32 (12.5)\n```\n\n### 复杂表达式\n\n```hemlock\nlet a: i8 = 10;\nlet b: i32 = 20;\nlet c: f64 = 3.0;\n\nlet result = a + b * c;  // f64 (70.0)\n// 计算过程：b * c → f64(60.0)\n//           a + f64(60.0) → f64(70.0)\n```\n\n## 鸭子类型（对象）\n\n对象使用**结构类型**（鸭子类型）：\n\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n}\n\n// OK：有所有必需字段\nlet p1: Person = { name: \"Alice\", age: 30 };\n\n// OK：允许额外字段\nlet p2: Person = { name: \"Bob\", age: 25, city: \"NYC\" };\n\n// 错误：缺少 'age' 字段\nlet p3: Person = { name: \"Carol\" };\n\n// 错误：'age' 类型错误\nlet p4: Person = { name: \"Dave\", age: \"thirty\" };\n```\n\n**类型检查在赋值时进行：**\n- 验证所有必需字段存在\n- 验证字段类型匹配\n- 允许并保留额外字段\n- 为 `typeof()` 设置对象的类型名称\n\n## 可选字段\n\n```hemlock\ndefine Config {\n    host: string,\n    port: i32,\n    debug?: false,     // 带默认值的可选字段\n    timeout?: i32,     // 可选，默认为 null\n}\n\nlet cfg1: Config = { host: \"localhost\", port: 8080 };\nprint(cfg1.debug);    // false（默认）\nprint(cfg1.timeout);  // null\n\nlet cfg2: Config = { host: \"0.0.0.0\", port: 80, debug: true };\nprint(cfg2.debug);    // true（已覆盖）\n```\n\n## 类型别名\n\nHemlock 使用 `type` 关键字支持自定义类型别名：\n\n### 基本类型别名\n\n```hemlock\n// 简单类型别名\ntype Integer = i32;\ntype Text = string;\n\n// 使用别名\nlet x: Integer = 42;\nlet msg: Text = \"hello\";\n```\n\n### 函数类型别名\n\n```hemlock\n// 函数类型别名\ntype Callback = fn(i32): void;\ntype Predicate = fn(i32): bool;\ntype AsyncHandler = async fn(string): i32;\n\n// 使用函数类型别名\nlet cb: Callback = fn(n) { print(n); };\nlet isEven: Predicate = fn(n) { return n % 2 == 0; };\n```\n\n### 复合类型别名\n\n```hemlock\n// 将多个 define 组合成一个类型\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\n\ntype Person = HasName & HasAge;\n\nlet p: Person = { name: \"Alice\", age: 30 };\n```\n\n### 泛型类型别名\n\n```hemlock\n// 泛型类型别名\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// 使用泛型别名\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**注意：** 类型别名是透明的 - `typeof()` 返回底层类型名称，而不是别名。\n\n## 类型系统限制\n\n当前限制：\n\n- **函数无泛型** - 尚不支持函数类型参数\n- **无联合类型** - 无法表达 \"A 或 B\"\n- **无可空类型** - 所有类型都可以为 null（使用 `?` 后缀表示显式可空）\n\n**注意：** 编译器（`hemlockc`）提供编译时类型检查。解释器仅执行运行时类型检查。详见[编译器文档](#design-implementation)。\n\n## 最佳实践\n\n### 何时使用类型注解\n\n**应该使用注解的情况：**\n- 精确类型很重要（例如，字节值使用 `u8`）\n- 记录函数接口\n- 强制约束（例如，范围检查）\n\n```hemlock\nfn hash(data: buffer, length: u32): u64 {\n    // 实现\n}\n```\n\n**不需要使用注解的情况：**\n- 类型从字面量明显可知\n- 内部实现细节\n- 不必要的形式化\n\n```hemlock\n// 不必要\nlet x: i32 = 42;\n\n// 更好\nlet x = 42;\n```\n\n### 类型安全模式\n\n**使用前检查：**\n```hemlock\nif (typeof(value) == \"i32\") {\n    // 可以安全地作为 i32 使用\n}\n```\n\n**验证函数参数：**\n```hemlock\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" || typeof(b) != \"i32\") {\n        throw \"arguments must be integers\";\n    }\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n```\n\n**使用鸭子类型获得灵活性：**\n```hemlock\ndefine Printable {\n    toString: fn,\n}\n\nfn print_item(item: Printable) {\n    print(item.toString());\n}\n```\n\n## 下一步\n\n- [Strings](#language-guide-strings) - UTF-8 字符串类型和操作\n- [Runes](#language-guide-runes) - Unicode 码点类型\n- [Arrays](#language-guide-arrays) - 动态数组类型\n- [Objects](#language-guide-objects) - 对象字面量和鸭子类型\n- [Memory](#language-guide-memory) - 指针和缓冲区类型\n"}, "语言指南 -> 语法": {"id": "language-guide-syntax", "content": "# 语法概述\n\n本文档介绍 Hemlock 程序的基本语法规则和结构。\n\n## 核心语法规则\n\n### 分号是必需的\n\n与 JavaScript 或 Python 不同，语句末尾**必须**使用分号：\n\n```hemlock\nlet x = 42;\nlet y = 10;\nprint(x + y);\n```\n\n**以下代码会导致错误：**\n```hemlock\nlet x = 42  // 错误：缺少分号\nlet y = 10  // 错误：缺少分号\n```\n\n### 花括号是必需的\n\n所有控制流代码块都必须使用花括号，即使只有单条语句：\n\n```hemlock\n// 正确\nif (x > 0) {\n    print(\"positive\");\n}\n\n// 错误：缺少花括号\nif (x > 0)\n    print(\"positive\");\n```\n\n### 注释\n\n```hemlock\n// 这是单行注释\n\n/*\n   这是\n   多行注释\n*/\n\nlet x = 42;  // 行内注释\n```\n\n## 变量\n\n### 声明\n\n使用 `let` 声明变量：\n\n```hemlock\nlet count = 0;\nlet name = \"Alice\";\nlet pi = 3.14159;\n```\n\n### 类型注解（可选）\n\n```hemlock\nlet age: i32 = 30;\nlet ratio: f64 = 1.618;\nlet flag: bool = true;\nlet text: string = \"hello\";\n```\n\n### 常量\n\n使用 `const` 声明不可变值：\n\n```hemlock\nconst MAX_SIZE: i32 = 1000;\nconst PI: f64 = 3.14159;\n```\n\n尝试重新赋值常量会导致运行时错误：\"Cannot assign to const variable\"。\n\n## 表达式\n\n### 算术运算符\n\n```hemlock\nlet a = 10;\nlet b = 3;\n\nprint(a + b);   // 13 - 加法\nprint(a - b);   // 7  - 减法\nprint(a * b);   // 30 - 乘法\nprint(a / b);   // 3  - 除法（整数）\n```\n\n### 比较运算符\n\n```hemlock\nprint(a == b);  // false - 等于\nprint(a != b);  // true  - 不等于\nprint(a > b);   // true  - 大于\nprint(a < b);   // false - 小于\nprint(a >= b);  // true  - 大于等于\nprint(a <= b);  // false - 小于等于\n```\n\n### 逻辑运算符\n\n```hemlock\nlet x = true;\nlet y = false;\n\nprint(x && y);  // false - 与\nprint(x || y);  // true  - 或\nprint(!x);      // false - 非\n```\n\n### 位运算符\n\n```hemlock\nlet a = 12;  // 1100\nlet b = 10;  // 1010\n\nprint(a & b);   // 8  - 按位与\nprint(a | b);   // 14 - 按位或\nprint(a ^ b);   // 6  - 按位异或\nprint(a << 2);  // 48 - 左移\nprint(a >> 1);  // 6  - 右移\nprint(~a);      // -13 - 按位取反\n```\n\n### 运算符优先级\n\n从高到低：\n\n1. `()` - 分组\n2. `!`, `~`, `-`（一元）- 一元运算符\n3. `*`, `/` - 乘法、除法\n4. `+`, `-` - 加法、减法\n5. `<<`, `>>` - 位移\n6. `<`, `<=`, `>`, `>=` - 比较\n7. `==`, `!=` - 相等性\n8. `&` - 按位与\n9. `^` - 按位异或\n10. `|` - 按位或\n11. `&&` - 逻辑与\n12. `||` - 逻辑或\n\n**示例：**\n```hemlock\nlet x = 2 + 3 * 4;      // 14（不是 20）\nlet y = (2 + 3) * 4;    // 20\nlet z = 5 << 2 + 1;     // 40 (5 << 3)\n```\n\n## 控制流\n\n### If 语句\n\n```hemlock\nif (condition) {\n    // 主体\n}\n\nif (condition) {\n    // then 分支\n} else {\n    // else 分支\n}\n\nif (condition1) {\n    // 分支 1\n} else if (condition2) {\n    // 分支 2\n} else {\n    // 默认分支\n}\n```\n\n### While 循环\n\n```hemlock\nwhile (condition) {\n    // 主体\n}\n```\n\n**示例：**\n```hemlock\nlet i = 0;\nwhile (i < 10) {\n    print(i);\n    i = i + 1;\n}\n```\n\n### For 循环\n\n**C 风格 for：**\n```hemlock\nfor (initializer; condition; increment) {\n    // 主体\n}\n```\n\n**示例：**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    print(i);\n}\n```\n\n**For-in（数组）：**\n```hemlock\nfor (let item in array) {\n    // 主体\n}\n```\n\n**示例：**\n```hemlock\nlet items = [10, 20, 30];\nfor (let x in items) {\n    print(x);\n}\n```\n\n### Switch 语句\n\n```hemlock\nswitch (expression) {\n    case value1:\n        // 主体\n        break;\n    case value2:\n        // 主体\n        break;\n    default:\n        // 默认主体\n        break;\n}\n```\n\n**示例：**\n```hemlock\nlet day = 3;\nswitch (day) {\n    case 1:\n        print(\"Monday\");\n        break;\n    case 2:\n        print(\"Tuesday\");\n        break;\n    case 3:\n        print(\"Wednesday\");\n        break;\n    default:\n        print(\"Other\");\n        break;\n}\n```\n\n### Break 和 Continue\n\n```hemlock\n// Break：退出循环\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        break;\n    }\n    print(i);\n}\n\n// Continue：跳到下一次迭代\nfor (let i = 0; i < 10; i = i + 1) {\n    if (i == 5) {\n        continue;\n    }\n    print(i);\n}\n```\n\n## 函数\n\n### 命名函数\n\n```hemlock\nfn function_name(param1: type1, param2: type2): return_type {\n    // 主体\n    return value;\n}\n```\n\n**示例：**\n```hemlock\nfn add(a: i32, b: i32): i32 {\n    return a + b;\n}\n```\n\n### 匿名函数\n\n```hemlock\nlet func = fn(params) {\n    // 主体\n};\n```\n\n**示例：**\n```hemlock\nlet multiply = fn(x, y) {\n    return x * y;\n};\n```\n\n### 类型注解（可选）\n\n```hemlock\n// 无注解（类型推断）\nfn greet(name) {\n    return \"Hello, \" + name;\n}\n\n// 有注解（运行时检查）\nfn divide(a: i32, b: i32): f64 {\n    return a / b;\n}\n```\n\n## 对象\n\n### 对象字面量\n\n```hemlock\nlet obj = {\n    field1: value1,\n    field2: value2,\n};\n```\n\n**示例：**\n```hemlock\nlet person = {\n    name: \"Alice\",\n    age: 30,\n    active: true,\n};\n```\n\n### 方法\n\n```hemlock\nlet obj = {\n    method: fn() {\n        self.field = value;\n    },\n};\n```\n\n**示例：**\n```hemlock\nlet counter = {\n    count: 0,\n    increment: fn() {\n        self.count = self.count + 1;\n    },\n};\n```\n\n### 类型定义\n\n```hemlock\ndefine TypeName {\n    field1: type1,\n    field2: type2,\n    optional_field?: default_value,\n}\n```\n\n**示例：**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: true,\n}\n```\n\n## 数组\n\n### 数组字面量\n\n```hemlock\nlet arr = [element1, element2, element3];\n```\n\n**示例：**\n```hemlock\nlet numbers = [1, 2, 3, 4, 5];\nlet mixed = [1, \"two\", true, null];\nlet empty = [];\n```\n\n### 数组索引\n\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);   // 10\narr[1] = 99;     // 修改元素\n```\n\n## 错误处理\n\n### Try/Catch\n\n```hemlock\ntry {\n    // 可能出错的代码\n} catch (e) {\n    // 处理错误\n}\n```\n\n### Try/Finally\n\n```hemlock\ntry {\n    // 可能出错的代码\n} finally {\n    // 总是执行\n}\n```\n\n### Try/Catch/Finally\n\n```hemlock\ntry {\n    // 可能出错的代码\n} catch (e) {\n    // 处理错误\n} finally {\n    // 清理\n}\n```\n\n### Throw\n\n```hemlock\nthrow expression;\n```\n\n**示例：**\n```hemlock\nif (x < 0) {\n    throw \"x must be positive\";\n}\n```\n\n### Panic\n\n```hemlock\npanic(message);\n```\n\n**示例：**\n```hemlock\npanic(\"unrecoverable error\");\n```\n\n## 模块（实验性）\n\n### 导出语句\n\n```hemlock\nexport fn function_name() { }\nexport const CONSTANT = value;\nexport let variable = value;\nexport { name1, name2 };\n```\n\n### 导入语句\n\n```hemlock\nimport { name1, name2 } from \"./module.hml\";\nimport * as namespace from \"./module.hml\";\nimport { name as alias } from \"./module.hml\";\n```\n\n## 异步（实验性）\n\n### 异步函数\n\n```hemlock\nasync fn function_name(params): return_type {\n    // 主体\n}\n```\n\n### Spawn/Join\n\n```hemlock\nlet task = spawn(async_function, arg1, arg2);\nlet result = join(task);\n```\n\n### 通道\n\n```hemlock\nlet ch = channel(capacity);\nch.send(value);\nlet value = ch.recv();\nch.close();\n```\n\n## FFI（外部函数接口）\n\n### 导入共享库\n\n```hemlock\nimport \"library_name.so\";\n```\n\n### 声明外部函数\n\n```hemlock\nextern fn function_name(param: type): return_type;\n```\n\n**示例：**\n```hemlock\nimport \"libc.so.6\";\nextern fn strlen(s: string): i32;\n```\n\n## 字面量\n\n### 整数字面量\n\n```hemlock\nlet decimal = 42;\nlet negative = -100;\nlet large = 5000000000;  // 自动 i64\n\n// 十六进制（0x 前缀）\nlet hex = 0xDEADBEEF;\nlet hex2 = 0xFF;\n\n// 二进制（0b 前缀）\nlet bin = 0b1010;\nlet bin2 = 0b11110000;\n\n// 八进制（0o 前缀）\nlet oct = 0o777;\nlet oct2 = 0O123;\n\n// 数字分隔符提高可读性\nlet million = 1_000_000;\nlet hex_sep = 0xFF_FF_FF;\nlet bin_sep = 0b1111_0000_1010_0101;\nlet oct_sep = 0o77_77;\n```\n\n### 浮点字面量\n\n```hemlock\nlet f = 3.14;\nlet e = 2.71828;\nlet sci = 1.5e-10;       // 科学计数法\nlet sci2 = 2.5E+3;       // 大写 E 也可以\nlet no_lead = .5;        // 无前导零 (0.5)\nlet sep = 3.14_159_265;  // 数字分隔符\n```\n\n### 字符串字面量\n\n```hemlock\nlet s = \"hello\";\nlet escaped = \"line1\\nline2\\ttabbed\";\nlet quote = \"She said \\\"hello\\\"\";\n\n// 十六进制转义序列\nlet hex_esc = \"\\x48\\x65\\x6c\\x6c\\x6f\";  // \"Hello\"\n\n// Unicode 转义序列\nlet emoji = \"\\u{1F600}\";               // 😀\nlet heart = \"\\u{2764}\";                // ❤\nlet mixed = \"Hello \\u{1F30D}!\";        // Hello 🌍!\n```\n\n**转义序列：**\n- `\\n` - 换行\n- `\\t` - 制表符\n- `\\r` - 回车\n- `\\\\` - 反斜杠\n- `\\\"` - 双引号\n- `\\'` - 单引号\n- `\\0` - 空字符\n- `\\xNN` - 十六进制转义（2 位）\n- `\\u{XXXX}` - Unicode 转义（1-6 位）\n\n### Rune 字面量\n\n```hemlock\nlet ch = 'A';\nlet emoji = '🚀';\nlet escaped = '\\n';\nlet unicode = '\\u{1F680}';\nlet hex_rune = '\\x41';      // 'A'\n```\n\n### 布尔字面量\n\n```hemlock\nlet t = true;\nlet f = false;\n```\n\n### Null 字面量\n\n```hemlock\nlet nothing = null;\n```\n\n## 作用域规则\n\n### 块作用域\n\n变量的作用域为最近的封闭块：\n\n```hemlock\nlet x = 1;  // 外部作用域\n\nif (true) {\n    let x = 2;  // 内部作用域（遮蔽外部）\n    print(x);   // 2\n}\n\nprint(x);  // 1\n```\n\n### 函数作用域\n\n函数创建自己的作用域：\n\n```hemlock\nlet global = \"global\";\n\nfn foo() {\n    let local = \"local\";\n    print(global);  // 可以读取外部作用域\n}\n\nfoo();\n// print(local);  // 错误：'local' 在此处未定义\n```\n\n### 闭包作用域\n\n闭包捕获封闭作用域的变量：\n\n```hemlock\nfn makeCounter() {\n    let count = 0;\n    return fn() {\n        count = count + 1;  // 捕获 'count'\n        return count;\n    };\n}\n\nlet counter = makeCounter();\nprint(counter());  // 1\nprint(counter());  // 2\n```\n\n## 空白和格式\n\n### 缩进\n\nHemlock 不强制特定缩进，但建议使用 4 个空格：\n\n```hemlock\nfn example() {\n    if (true) {\n        print(\"indented\");\n    }\n}\n```\n\n### 换行\n\n语句可以跨越多行：\n\n```hemlock\nlet result =\n    very_long_function_name(\n        arg1,\n        arg2,\n        arg3\n    );\n```\n\n## Loop 语句\n\n`loop` 关键字为无限循环提供更清晰的语法：\n\n```hemlock\nloop {\n    // ... 执行工作\n    if (done) {\n        break;\n    }\n}\n```\n\n这等价于 `while (true)`，但意图更明确。\n\n## 保留关键字\n\n以下关键字在 Hemlock 中是保留的：\n\n```\nlet, const, fn, if, else, while, for, in, loop, break, continue,\nreturn, true, false, null, typeof, import, export, from,\ntry, catch, finally, throw, panic, async, await, spawn, join,\ndetach, channel, define, switch, case, default, extern, self,\ntype, defer, enum, ref, buffer, Self\n```\n\n## 下一步\n\n- [类型系统](#language-guide-types) - 了解 Hemlock 的类型系统\n- [控制流](#language-guide-control-flow) - 深入了解控制结构\n- [函数](#language-guide-functions) - 掌握函数和闭包\n- [内存管理](#language-guide-memory) - 理解指针和缓冲区\n"}, "语言指南 -> 错误处理": {"id": "language-guide-error-handling", "content": "# 错误处理\n\nHemlock 通过 `try`、`catch`、`finally`、`throw` 和 `panic` 支持基于异常的错误处理。本指南涵盖了使用异常处理可恢复错误以及使用 panic 处理不可恢复错误的内容。\n\n## 概述\n\n```hemlock\n// 基本错误处理\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Error: \" + e);\n}\n\n// 带清理操作\ntry {\n    process_file();\n} catch (e) {\n    print(\"Failed: \" + e);\n} finally {\n    cleanup();\n}\n\n// 抛出错误\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n```\n\n## Try-Catch-Finally\n\n### 语法\n\n**基本 try/catch：**\n```hemlock\ntry {\n    // 有风险的代码\n} catch (e) {\n    // 处理错误，e 包含抛出的值\n}\n```\n\n**Try/finally：**\n```hemlock\ntry {\n    // 有风险的代码\n} finally {\n    // 始终执行，即使抛出异常\n}\n```\n\n**Try/catch/finally：**\n```hemlock\ntry {\n    // 有风险的代码\n} catch (e) {\n    // 处理错误\n} finally {\n    // 清理代码\n}\n```\n\n### Try 块\n\ntry 块按顺序执行语句：\n\n```hemlock\ntry {\n    print(\"Starting...\");\n    risky_operation();\n    print(\"Success!\");  // 仅在没有异常时执行\n}\n```\n\n**行为：**\n- 按顺序执行语句\n- 如果抛出异常：跳转到 `catch` 或 `finally`\n- 如果没有异常：执行 `finally`（如果存在）然后继续\n\n### Catch 块\n\ncatch 块接收抛出的值：\n\n```hemlock\ntry {\n    throw \"oops\";\n} catch (error) {\n    print(\"Caught: \" + error);  // error = \"oops\"\n    // error 只能在这里访问\n}\n// error 在这里无法访问\n```\n\n**Catch 参数：**\n- 接收抛出的值（任意类型）\n- 作用域仅限于 catch 块\n- 可以命名为任何名称（通常使用 `e`、`err` 或 `error`）\n\n**在 catch 中可以做的事情：**\n```hemlock\ntry {\n    risky_operation();\n} catch (e) {\n    // 记录错误\n    print(\"Error: \" + e);\n\n    // 重新抛出相同错误\n    throw e;\n\n    // 抛出不同错误\n    throw \"different error\";\n\n    // 返回默认值\n    return null;\n\n    // 处理并继续\n    // （不重新抛出）\n}\n```\n\n### Finally 块\n\nfinally 块**始终执行**：\n\n```hemlock\ntry {\n    print(\"1: try\");\n    throw \"error\";\n} catch (e) {\n    print(\"2: catch\");\n} finally {\n    print(\"3: finally\");  // 始终运行\n}\nprint(\"4: after\");\n\n// 输出：1: try, 2: catch, 3: finally, 4: after\n```\n\n**finally 何时运行：**\n- 在 try 块之后（如果没有异常）\n- 在 catch 块之后（如果捕获了异常）\n- 即使 try/catch 包含 `return`、`break` 或 `continue`\n- 在控制流退出 try/catch 之前\n\n**Finally 与 return：**\n```hemlock\nfn example() {\n    try {\n        return 1;  // 在 finally 运行后返回 1\n    } finally {\n        print(\"cleanup\");  // 在返回之前运行\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // finally 的 return 覆盖原值 - 返回 2\n    }\n}\n```\n\n**Finally 与控制流：**\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) {\n            break;  // 在 finally 运行后 break\n        }\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```\n\n## Throw 语句\n\n### 基本 Throw\n\n抛出任意值作为异常：\n\n```hemlock\nthrow \"error message\";\nthrow 404;\nthrow { code: 500, message: \"Internal error\" };\nthrow null;\nthrow [\"error\", \"details\"];\n```\n\n**执行过程：**\n1. 计算表达式\n2. 立即跳转到最近的 `catch`\n3. 如果没有 `catch`，向上传播调用栈\n\n### 抛出错误\n\n```hemlock\nfn validate_age(age: i32) {\n    if (age < 0) {\n        throw \"Age cannot be negative\";\n    }\n    if (age > 150) {\n        throw \"Age is unrealistic\";\n    }\n}\n\ntry {\n    validate_age(-5);\n} catch (e) {\n    print(\"Validation error: \" + e);\n}\n```\n\n### 抛出错误对象\n\n创建结构化的错误信息：\n\n```hemlock\nfn read_file(path: string) {\n    if (!file_exists(path)) {\n        throw {\n            type: \"FileNotFound\",\n            path: path,\n            message: \"File does not exist\"\n        };\n    }\n    // ... 读取文件\n}\n\ntry {\n    read_file(\"missing.txt\");\n} catch (e) {\n    if (e.type == \"FileNotFound\") {\n        print(\"File not found: \" + e.path);\n    }\n}\n```\n\n### 重新抛出\n\n捕获并重新抛出错误：\n\n```hemlock\nfn wrapper() {\n    try {\n        risky_operation();\n    } catch (e) {\n        print(\"Logging error: \" + e);\n        throw e;  // 重新抛给调用者\n    }\n}\n\ntry {\n    wrapper();\n} catch (e) {\n    print(\"Caught in main: \" + e);\n}\n```\n\n## 未捕获的异常\n\n如果异常传播到调用栈顶部而未被捕获：\n\n```hemlock\nfn foo() {\n    throw \"uncaught!\";\n}\n\nfoo();  // 崩溃并显示：Runtime error: uncaught!\n```\n\n**行为：**\n- 程序崩溃\n- 向 stderr 打印错误消息\n- 以非零状态码退出\n- 堆栈跟踪将在未来版本中添加\n\n## Panic - 不可恢复错误\n\n### 什么是 Panic？\n\n`panic()` 用于**不可恢复的错误**，应立即终止程序：\n\n```hemlock\npanic();                    // 默认消息：\"panic!\"\npanic(\"custom message\");    // 自定义消息\npanic(42);                  // 非字符串值会被打印\n```\n\n**语义：**\n- **立即退出**程序，退出码为 1\n- 向 stderr 打印错误消息：`panic: <message>`\n- **无法**通过 try/catch 捕获\n- 用于 bug 和不可恢复的错误\n\n### Panic vs Throw\n\n```hemlock\n// throw - 可恢复错误（可以被捕获）\ntry {\n    throw \"recoverable error\";\n} catch (e) {\n    print(\"Caught: \" + e);  // 成功捕获\n}\n\n// panic - 不可恢复错误（无法被捕获）\ntry {\n    panic(\"unrecoverable error\");  // 程序立即退出\n} catch (e) {\n    print(\"This never runs\");       // 永远不会执行\n}\n```\n\n### 何时使用 Panic\n\n**使用 panic 的情况：**\n- **Bug**：到达了不应该到达的代码\n- **无效状态**：检测到数据结构损坏\n- **不可恢复错误**：关键资源不可用\n- **断言失败**：当 `assert()` 不够用时\n\n**示例：**\n```hemlock\n// 不可达代码\nfn process_state(state: i32) {\n    if (state == 1) {\n        return \"ready\";\n    } else if (state == 2) {\n        return \"running\";\n    } else if (state == 3) {\n        return \"stopped\";\n    } else {\n        panic(\"invalid state: \" + typeof(state));  // 不应该发生\n    }\n}\n\n// 关键资源检查\nfn init_system() {\n    let config = read_file(\"config.json\");\n    if (config == null) {\n        panic(\"config.json not found - cannot start\");\n    }\n    // ...\n}\n\n// 数据结构不变量\nfn pop_stack(stack) {\n    if (stack.length == 0) {\n        panic(\"pop() called on empty stack\");\n    }\n    return stack.pop();\n}\n```\n\n### 何时不使用 Panic\n\n**以下情况使用 throw：**\n- 用户输入验证\n- 文件未找到\n- 网络错误\n- 预期的错误条件\n\n```hemlock\n// 不好：对预期错误使用 panic\nfn divide(a, b) {\n    if (b == 0) {\n        panic(\"division by zero\");  // 太严厉了\n    }\n    return a / b;\n}\n\n// 好：对预期错误使用 throw\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";  // 可恢复\n    }\n    return a / b;\n}\n```\n\n## 控制流交互\n\n### Try/Catch/Finally 中的 Return\n\n```hemlock\nfn example() {\n    try {\n        return 1;  // 在 finally 运行后返回 1\n    } finally {\n        print(\"cleanup\");\n    }\n}\n\nfn example2() {\n    try {\n        return 1;\n    } finally {\n        return 2;  // finally 的 return 覆盖 try 的 return - 返回 2\n    }\n}\n```\n\n**规则：** finally 块的返回值会覆盖 try/catch 的返回值。\n\n### Try/Catch/Finally 中的 Break/Continue\n\n```hemlock\nfor (let i = 0; i < 10; i = i + 1) {\n    try {\n        if (i == 5) { break; }  // 在 finally 运行后 break\n    } finally {\n        print(\"cleanup \" + typeof(i));\n    }\n}\n```\n\n**规则：** break/continue 在 finally 块之后执行。\n\n### 嵌套 Try/Catch\n\n```hemlock\ntry {\n    try {\n        throw \"inner\";\n    } catch (e) {\n        print(\"Caught: \" + e);  // 打印：Caught: inner\n        throw \"outer\";  // 重新抛出不同错误\n    }\n} catch (e) {\n    print(\"Caught: \" + e);  // 打印：Caught: outer\n}\n```\n\n**规则：** 嵌套的 try/catch 块按预期工作，内层 catch 先执行。\n\n## 常见模式\n\n### 模式：资源清理\n\n始终使用 `finally` 进行清理：\n\n```hemlock\nfn process_file(filename) {\n    let file = null;\n    try {\n        file = open(filename);\n        let content = file.read();\n        process(content);\n    } catch (e) {\n        print(\"Error processing file: \" + e);\n    } finally {\n        if (file != null) {\n            file.close();  // 即使出错也会关闭\n        }\n    }\n}\n```\n\n### 模式：错误包装\n\n用上下文包装底层错误：\n\n```hemlock\nfn load_config(path) {\n    try {\n        let content = read_file(path);\n        return parse_json(content);\n    } catch (e) {\n        throw \"Failed to load config from \" + path + \": \" + e;\n    }\n}\n```\n\n### 模式：错误恢复\n\n出错时提供回退值：\n\n```hemlock\nfn safe_divide(a, b) {\n    try {\n        if (b == 0) {\n            throw \"division by zero\";\n        }\n        return a / b;\n    } catch (e) {\n        print(\"Error: \" + e);\n        return null;  // 回退值\n    }\n}\n```\n\n### 模式：验证\n\n使用异常进行验证：\n\n```hemlock\nfn validate_user(user) {\n    if (user.name == null || user.name == \"\") {\n        throw \"Name is required\";\n    }\n    if (user.age < 0 || user.age > 150) {\n        throw \"Invalid age\";\n    }\n    if (user.email == null || !user.email.contains(\"@\")) {\n        throw \"Invalid email\";\n    }\n}\n\ntry {\n    validate_user({ name: \"Alice\", age: -5, email: \"invalid\" });\n} catch (e) {\n    print(\"Validation failed: \" + e);\n}\n```\n\n### 模式：多种错误类型\n\n使用错误对象区分错误类型：\n\n```hemlock\nfn process_data(data) {\n    if (data == null) {\n        throw { type: \"NullData\", message: \"Data is null\" };\n    }\n\n    if (typeof(data) != \"array\") {\n        throw { type: \"TypeError\", message: \"Expected array\" };\n    }\n\n    if (data.length == 0) {\n        throw { type: \"EmptyData\", message: \"Array is empty\" };\n    }\n\n    // ... 处理\n}\n\ntry {\n    process_data(null);\n} catch (e) {\n    if (e.type == \"NullData\") {\n        print(\"No data provided\");\n    } else if (e.type == \"TypeError\") {\n        print(\"Wrong data type: \" + e.message);\n    } else {\n        print(\"Error: \" + e.message);\n    }\n}\n```\n\n## 最佳实践\n\n1. **对异常情况使用异常** - 不要用于正常控制流\n2. **抛出有意义的错误** - 使用带上下文的字符串或对象\n3. **始终使用 finally 进行清理** - 确保资源被释放\n4. **不要捕获后忽略** - 至少记录错误\n5. **适当时重新抛出** - 如果你无法处理，让调用者处理\n6. **对 bug 使用 panic** - 对不可恢复的错误使用 panic\n7. **文档化异常** - 明确说明哪些函数可能抛出异常\n\n## 常见陷阱\n\n### 陷阱：吞掉错误\n\n```hemlock\n// 不好：静默失败\ntry {\n    risky_operation();\n} catch (e) {\n    // 错误被忽略 - 静默失败\n}\n\n// 好：记录或处理\ntry {\n    risky_operation();\n} catch (e) {\n    print(\"Operation failed: \" + e);\n    // 适当处理\n}\n```\n\n### 陷阱：Finally 覆盖\n\n```hemlock\n// 不好：finally 覆盖返回值\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        return 0;  // 返回 0，而不是 42！\n    }\n}\n\n// 好：不要在 finally 中返回\nfn get_value() {\n    try {\n        return 42;\n    } finally {\n        cleanup();  // 只做清理，不返回\n    }\n}\n```\n\n### 陷阱：忘记清理\n\n```hemlock\n// 不好：出错时文件可能不会关闭\nfn process() {\n    let file = open(\"data.txt\");\n    let content = file.read();  // 可能抛出异常\n    file.close();  // 如果出错永远不会到达\n}\n\n// 好：使用 finally\nfn process() {\n    let file = null;\n    try {\n        file = open(\"data.txt\");\n        let content = file.read();\n    } finally {\n        if (file != null) {\n            file.close();\n        }\n    }\n}\n```\n\n### 陷阱：对预期错误使用 Panic\n\n```hemlock\n// 不好：对预期错误使用 panic\nfn read_config(path) {\n    if (!file_exists(path)) {\n        panic(\"Config file not found\");  // 太严厉了\n    }\n    return read_file(path);\n}\n\n// 好：对预期错误使用 throw\nfn read_config(path) {\n    if (!file_exists(path)) {\n        throw \"Config file not found: \" + path;  // 可恢复\n    }\n    return read_file(path);\n}\n```\n\n## 示例\n\n### 示例：基本错误处理\n\n```hemlock\nfn divide(a, b) {\n    if (b == 0) {\n        throw \"division by zero\";\n    }\n    return a / b;\n}\n\ntry {\n    print(divide(10, 0));\n} catch (e) {\n    print(\"Error: \" + e);  // 打印：Error: division by zero\n}\n```\n\n### 示例：资源管理\n\n```hemlock\nfn copy_file(src, dst) {\n    let src_file = null;\n    let dst_file = null;\n\n    try {\n        src_file = open(src, \"r\");\n        dst_file = open(dst, \"w\");\n\n        let content = src_file.read();\n        dst_file.write(content);\n\n        print(\"File copied successfully\");\n    } catch (e) {\n        print(\"Failed to copy file: \" + e);\n        throw e;  // 重新抛出\n    } finally {\n        if (src_file != null) { src_file.close(); }\n        if (dst_file != null) { dst_file.close(); }\n    }\n}\n```\n\n### 示例：嵌套错误处理\n\n```hemlock\nfn process_users(users) {\n    let success_count = 0;\n    let error_count = 0;\n\n    let i = 0;\n    while (i < users.length) {\n        try {\n            validate_user(users[i]);\n            save_user(users[i]);\n            success_count = success_count + 1;\n        } catch (e) {\n            print(\"Failed to process user: \" + e);\n            error_count = error_count + 1;\n        }\n        i = i + 1;\n    }\n\n    print(\"Processed: \" + typeof(success_count) + \" success, \" + typeof(error_count) + \" errors\");\n}\n```\n\n### 示例：自定义错误类型\n\n```hemlock\nfn create_error(type, message, details) {\n    return {\n        type: type,\n        message: message,\n        details: details,\n        toString: fn() {\n            return self.type + \": \" + self.message;\n        }\n    };\n}\n\nfn divide(a, b) {\n    if (typeof(a) != \"i32\" && typeof(a) != \"f64\") {\n        throw create_error(\"TypeError\", \"a must be a number\", { value: a });\n    }\n    if (typeof(b) != \"i32\" && typeof(b) != \"f64\") {\n        throw create_error(\"TypeError\", \"b must be a number\", { value: b });\n    }\n    if (b == 0) {\n        throw create_error(\"DivisionByZero\", \"Cannot divide by zero\", { a: a, b: b });\n    }\n    return a / b;\n}\n\ntry {\n    divide(10, 0);\n} catch (e) {\n    print(e.toString());\n    if (e.type == \"DivisionByZero\") {\n        print(\"Details: a=\" + typeof(e.details.a) + \", b=\" + typeof(e.details.b));\n    }\n}\n```\n\n### 示例：重试逻辑\n\n```hemlock\nfn retry(operation, max_attempts) {\n    let attempt = 0;\n\n    while (attempt < max_attempts) {\n        try {\n            return operation();  // 成功！\n        } catch (e) {\n            attempt = attempt + 1;\n            if (attempt >= max_attempts) {\n                throw \"Operation failed after \" + typeof(max_attempts) + \" attempts: \" + e;\n            }\n            print(\"Attempt \" + typeof(attempt) + \" failed, retrying...\");\n        }\n    }\n}\n\nfn unreliable_operation() {\n    // 模拟不稳定的操作\n    if (random() < 0.7) {\n        throw \"Operation failed\";\n    }\n    return \"Success\";\n}\n\ntry {\n    let result = retry(unreliable_operation, 3);\n    print(result);\n} catch (e) {\n    print(\"All retries failed: \" + e);\n}\n```\n\n## 执行顺序\n\n理解执行顺序：\n\n```hemlock\ntry {\n    print(\"1: try block start\");\n    throw \"error\";\n    print(\"2: never reached\");\n} catch (e) {\n    print(\"3: catch block\");\n} finally {\n    print(\"4: finally block\");\n}\nprint(\"5: after try/catch/finally\");\n\n// 输出：\n// 1: try block start\n// 3: catch block\n// 4: finally block\n// 5: after try/catch/finally\n```\n\n## 当前限制\n\n- **没有堆栈跟踪** - 未捕获的异常不显示堆栈跟踪（已计划）\n- **某些内置函数会退出** - 某些内置函数仍然使用 `exit()` 而不是抛出异常（待审查）\n- **没有自定义异常类型** - 任何值都可以被抛出，但没有正式的异常层次结构\n\n## 相关主题\n\n- [函数](#language-guide-functions) - 异常和函数返回\n- [控制流](#language-guide-control-flow) - 异常如何影响控制流\n- [内存](#language-guide-memory) - 使用 finally 进行内存清理\n\n## 另请参阅\n\n- **异常语义**：参见 CLAUDE.md 中的\"错误处理\"部分\n- **Panic vs Throw**：不同错误类型的不同用例\n- **Finally 保证**：始终执行，即使有 return/break/continue\n"}, "高级主题 -> FFI": {"id": "advanced-ffi", "content": "# Hemlock 外部函数接口（FFI）\n\nHemlock 提供 **FFI（外部函数接口）**，可使用 libffi 调用共享库中的 C 函数，实现与现有 C 库和系统 API 的集成。\n\n## 目录\n\n- [概述](#概述)\n- [当前状态](#当前状态)\n- [支持的类型](#支持的类型)\n- [基本概念](#基本概念)\n- [导出 FFI 函数](#导出-ffi-函数)\n- [用例](#用例)\n- [未来发展](#未来发展)\n- [FFI 回调](#ffi-回调)\n- [FFI 结构体](#ffi-结构体)\n- [当前限制](#当前限制)\n- [最佳实践](#最佳实践)\n\n## 概述\n\n外部函数接口（FFI）允许 Hemlock 程序：\n- 从共享库（.so、.dylib、.dll）调用 C 函数\n- 使用现有 C 库而无需编写包装代码\n- 直接访问系统 API\n- 与第三方原生库集成\n- 将 Hemlock 与底层系统功能桥接\n\n**关键能力：**\n- 动态库加载\n- C 函数绑定\n- Hemlock 和 C 类型之间的自动类型转换\n- 支持所有原始类型\n- 基于 libffi 的实现，具有可移植性\n\n## 当前状态\n\nHemlock 中的 FFI 支持具有以下特性：\n\n**已实现：**\n- 从共享库调用 C 函数\n- 支持所有原始类型（整数、浮点数、指针）\n- 自动类型转换\n- 基于 libffi 的实现\n- 动态库加载\n- **函数指针回调** - 将 Hemlock 函数传递给 C\n- **导出 extern 函数** - 跨模块共享 FFI 绑定\n- **结构体传递和返回值** - 按值传递 C 兼容的结构体\n- **完整的指针辅助函数** - 读写所有类型（i8-i64, u8-u64, f32, f64, ptr）\n- **缓冲区/指针转换** - `buffer_ptr()`、`ptr_to_buffer()`\n- **FFI 类型大小** - `ffi_sizeof()` 用于平台感知的类型大小\n- **平台类型** - 支持 `size_t`、`usize`、`isize`、`intptr_t`\n\n**开发中：**\n- 字符串封送辅助函数\n- 错误处理改进\n\n## 支持的类型\n\n### 原始类型\n\n以下 Hemlock 类型可以传递给 C 函数或从 C 函数返回：\n\n| Hemlock 类型 | C 类型 | 大小 | 说明 |\n|--------------|--------|------|------|\n| `i8` | `int8_t` | 1 字节 | 有符号 8 位整数 |\n| `i16` | `int16_t` | 2 字节 | 有符号 16 位整数 |\n| `i32` | `int32_t` | 4 字节 | 有符号 32 位整数 |\n| `i64` | `int64_t` | 8 字节 | 有符号 64 位整数 |\n| `u8` | `uint8_t` | 1 字节 | 无符号 8 位整数 |\n| `u16` | `uint16_t` | 2 字节 | 无符号 16 位整数 |\n| `u32` | `uint32_t` | 4 字节 | 无符号 32 位整数 |\n| `u64` | `uint64_t` | 8 字节 | 无符号 64 位整数 |\n| `f32` | `float` | 4 字节 | 32 位浮点数 |\n| `f64` | `double` | 8 字节 | 64 位浮点数 |\n| `ptr` | `void*` | 8 字节 | 原始指针 |\n\n### 类型转换\n\n**自动转换：**\n- Hemlock 整数 -> C 整数（带范围检查）\n- Hemlock 浮点数 -> C 浮点数\n- Hemlock 指针 -> C 指针\n- C 返回值 -> Hemlock 值\n\n**示例类型映射：**\n```hemlock\n// Hemlock -> C\nlet i: i32 = 42;         // -> int32_t (4 字节)\nlet f: f64 = 3.14;       // -> double (8 字节)\nlet p: ptr = alloc(64);  // -> void* (8 字节)\n\n// C -> Hemlock（返回值）\n// int32_t foo() -> i32\n// double bar() -> f64\n// void* baz() -> ptr\n```\n\n## 基本概念\n\n### 共享库\n\nFFI 与编译后的共享库配合使用：\n\n**Linux:** `.so` 文件\n```\nlibexample.so\n/usr/lib/libm.so\n```\n\n**macOS:** `.dylib` 文件\n```\nlibexample.dylib\n/usr/lib/libSystem.dylib\n```\n\n**Windows:** `.dll` 文件\n```\nexample.dll\nkernel32.dll\n```\n\n### 函数签名\n\nC 函数必须具有已知的签名才能让 FFI 正常工作：\n\n```c\n// 示例 C 函数签名\nint add(int a, int b);\ndouble sqrt(double x);\nvoid* malloc(size_t size);\nvoid free(void* ptr);\n```\n\n一旦加载库并绑定函数，就可以从 Hemlock 调用这些函数。\n\n### 平台兼容性\n\nFFI 使用 **libffi** 实现可移植性：\n- 适用于 x86、x86-64、ARM、ARM64\n- 自动处理调用约定\n- 抽象平台特定的 ABI 细节\n- 支持 Linux、macOS、Windows（需要适当的 libffi）\n\n## 导出 FFI 函数\n\n使用 `extern fn` 声明的 FFI 函数可以从模块导出，允许您创建可跨多个文件共享的可重用库包装器。\n\n### 基本导出语法\n\n```hemlock\n// string_utils.hml - 包装 C 字符串函数的库模块\nimport \"libc.so.6\";\n\n// 直接导出 extern 函数\nexport extern fn strlen(s: string): i32;\nexport extern fn strcmp(s1: string, s2: string): i32;\n\n// 您也可以在 extern 函数旁边导出包装函数\nexport fn string_length(s: string): i32 {\n    return strlen(s);\n}\n\nexport fn strings_equal(a: string, b: string): bool {\n    return strcmp(a, b) == 0;\n}\n```\n\n### 导入导出的 FFI 函数\n\n```hemlock\n// main.hml - 使用导出的 FFI 函数\nimport { strlen, string_length, strings_equal } from \"./string_utils.hml\";\n\nlet msg = \"Hello, World!\";\nprint(strlen(msg));           // 13 - 直接 extern 调用\nprint(string_length(msg));    // 13 - 包装函数\n\nprint(strings_equal(\"foo\", \"foo\"));  // true\nprint(strings_equal(\"foo\", \"bar\"));  // false\n```\n\n### Export Extern 的用例\n\n**1. 平台抽象**\n```hemlock\n// platform.hml - 抽象平台差异\nimport \"libc.so.6\";  // Linux\n\nexport extern fn getpid(): i32;\nexport extern fn getuid(): i32;\nexport extern fn geteuid(): i32;\n```\n\n**2. 库包装器**\n```hemlock\n// crypto_lib.hml - 包装加密库函数\nimport \"libcrypto.so\";\n\nexport extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;\nexport extern fn MD5(data: ptr, len: u64, out: ptr): ptr;\n\n// 添加 Hemlock 友好的包装器\nexport fn sha256_string(s: string): string {\n    // 使用 extern 函数的实现\n}\n```\n\n**3. 集中式 FFI 声明**\n```hemlock\n// libc.hml - libc 绑定的中央模块\nimport \"libc.so.6\";\n\n// 字符串函数\nexport extern fn strlen(s: string): i32;\nexport extern fn strcpy(dest: ptr, src: string): ptr;\nexport extern fn strcat(dest: ptr, src: string): ptr;\n\n// 内存函数\nexport extern fn malloc(size: u64): ptr;\nexport extern fn realloc(p: ptr, size: u64): ptr;\nexport extern fn calloc(nmemb: u64, size: u64): ptr;\n\n// 进程函数\nexport extern fn getpid(): i32;\nexport extern fn getppid(): i32;\nexport extern fn getenv(name: string): ptr;\n```\n\n然后在整个项目中使用：\n```hemlock\nimport { strlen, malloc, getpid } from \"./libc.hml\";\n```\n\n## 用例\n\n### 1. 系统库\n\n访问标准 C 库函数：\n\n**数学函数：**\n```hemlock\n// 从 libm 调用 sqrt\nlet result = sqrt(16.0);  // 4.0\n```\n\n**内存分配：**\n```hemlock\n// 从 libc 调用 malloc/free\nlet ptr = malloc(1024);\nfree(ptr);\n```\n\n### 2. 第三方库\n\n使用现有的 C 库：\n\n**示例：图像处理**\n```hemlock\n// 加载 libpng 或 libjpeg\n// 使用 C 库函数处理图像\n```\n\n**示例：加密**\n```hemlock\n// 使用 OpenSSL 或 libsodium\n// 通过 FFI 进行加密/解密\n```\n\n### 3. 系统 API\n\n直接系统调用：\n\n**示例：POSIX API**\n```hemlock\n// 调用 getpid、getuid 等\n// 访问底层系统功能\n```\n\n### 4. 性能关键代码\n\n调用优化的 C 实现：\n\n```hemlock\n// 使用高度优化的 C 库\n// SIMD 操作、向量化代码\n// 硬件加速函数\n```\n\n## FFI 回调\n\nHemlock 支持使用 libffi 闭包将函数作为回调传递给 C 代码。这使得能够与期望函数指针的 C API 集成，如 `qsort`、事件循环和基于回调的库。\n\n### 创建回调\n\n使用 `callback()` 从 Hemlock 函数创建 C 可调用的函数指针：\n\n```hemlock\n// callback(function, param_types, return_type) -> ptr\nlet cb = callback(my_function, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n**参数：**\n- `function`：要包装的 Hemlock 函数\n- `param_types`：类型名称字符串数组（如 `[\"ptr\", \"i32\"]`）\n- `return_type`：返回类型字符串（如 `\"i32\"`、`\"void\"`）\n\n**支持的回调类型：**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - 有符号整数\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - 无符号整数\n- `\"f32\"`, `\"f64\"` - 浮点数\n- `\"ptr\"` - 指针\n- `\"void\"` - 无返回值\n- `\"bool\"` - 布尔值\n\n### 示例：qsort\n\n```hemlock\nimport \"libc.so.6\";\nextern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;\n\n// 整数比较函数（升序）\nfn compare_ints(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    if (va < vb) { return -1; }\n    if (va > vb) { return 1; }\n    return 0;\n}\n\n// 分配 5 个整数的数组\nlet arr = alloc(20);  // 5 * 4 字节\nptr_write_i32(arr, 5);\nptr_write_i32(ptr_offset(arr, 1, 4), 2);\nptr_write_i32(ptr_offset(arr, 2, 4), 8);\nptr_write_i32(ptr_offset(arr, 3, 4), 1);\nptr_write_i32(ptr_offset(arr, 4, 4), 9);\n\n// 创建回调并排序\nlet cmp = callback(compare_ints, [\"ptr\", \"ptr\"], \"i32\");\nqsort(arr, 5, 4, cmp);\n\n// 数组现在已排序：[1, 2, 5, 8, 9]\n\n// 清理\ncallback_free(cmp);\nfree(arr);\n```\n\n### 指针辅助函数\n\nHemlock 提供全面的辅助函数用于处理原始指针。这些对于 FFI 回调和直接内存操作至关重要。\n\n#### 整数类型辅助函数\n\n| 函数 | 描述 |\n|------|------|\n| `ptr_deref_i8(ptr)` | 解引用指针，读取 i8 |\n| `ptr_deref_i16(ptr)` | 解引用指针，读取 i16 |\n| `ptr_deref_i32(ptr)` | 解引用指针，读取 i32 |\n| `ptr_deref_i64(ptr)` | 解引用指针，读取 i64 |\n| `ptr_deref_u8(ptr)` | 解引用指针，读取 u8 |\n| `ptr_deref_u16(ptr)` | 解引用指针，读取 u16 |\n| `ptr_deref_u32(ptr)` | 解引用指针，读取 u32 |\n| `ptr_deref_u64(ptr)` | 解引用指针，读取 u64 |\n| `ptr_write_i8(ptr, value)` | 向指针位置写入 i8 |\n| `ptr_write_i16(ptr, value)` | 向指针位置写入 i16 |\n| `ptr_write_i32(ptr, value)` | 向指针位置写入 i32 |\n| `ptr_write_i64(ptr, value)` | 向指针位置写入 i64 |\n| `ptr_write_u8(ptr, value)` | 向指针位置写入 u8 |\n| `ptr_write_u16(ptr, value)` | 向指针位置写入 u16 |\n| `ptr_write_u32(ptr, value)` | 向指针位置写入 u32 |\n| `ptr_write_u64(ptr, value)` | 向指针位置写入 u64 |\n\n#### 浮点类型辅助函数\n\n| 函数 | 描述 |\n|------|------|\n| `ptr_deref_f32(ptr)` | 解引用指针，读取 f32 (float) |\n| `ptr_deref_f64(ptr)` | 解引用指针，读取 f64 (double) |\n| `ptr_write_f32(ptr, value)` | 向指针位置写入 f32 |\n| `ptr_write_f64(ptr, value)` | 向指针位置写入 f64 |\n\n#### 指针类型辅助函数\n\n| 函数 | 描述 |\n|------|------|\n| `ptr_deref_ptr(ptr)` | 解引用指向指针的指针 |\n| `ptr_write_ptr(ptr, value)` | 向指针位置写入指针 |\n| `ptr_offset(ptr, index, size)` | 计算偏移：`ptr + index * size` |\n| `ptr_read_i32(ptr)` | 通过指向指针的指针读取 i32（用于 qsort 回调） |\n| `ptr_null()` | 获取空指针常量 |\n\n#### 缓冲区转换辅助函数\n\n| 函数 | 描述 |\n|------|------|\n| `buffer_ptr(buffer)` | 从缓冲区获取原始指针 |\n| `ptr_to_buffer(ptr, size)` | 从指针复制数据到新缓冲区 |\n\n#### FFI 实用函数\n\n| 函数 | 描述 |\n|------|------|\n| `ffi_sizeof(type_name)` | 获取 FFI 类型的字节大小 |\n\n**`ffi_sizeof` 支持的类型名称：**\n- `\"i8\"`, `\"i16\"`, `\"i32\"`, `\"i64\"` - 有符号整数（1, 2, 4, 8 字节）\n- `\"u8\"`, `\"u16\"`, `\"u32\"`, `\"u64\"` - 无符号整数（1, 2, 4, 8 字节）\n- `\"f32\"`, `\"f64\"` - 浮点数（4, 8 字节）\n- `\"ptr\"` - 指针（64 位系统上 8 字节）\n- `\"size_t\"`, `\"usize\"` - 平台相关的大小类型\n- `\"intptr_t\"`, `\"isize\"` - 平台相关的有符号指针类型\n\n### 释放回调\n\n**重要：** 始终在使用完回调后释放它们以防止内存泄漏：\n\n```hemlock\nlet cb = callback(my_fn, [\"ptr\"], \"void\");\n// ... 使用回调 ...\ncallback_free(cb);  // 使用完后释放\n```\n\n程序退出时回调也会自动释放。\n\n### 回调中的闭包\n\n回调捕获其闭包环境，因此可以访问外部作用域变量：\n\n```hemlock\nlet multiplier = 10;\n\nfn scale(a: ptr, b: ptr): i32 {\n    let va = ptr_deref_i32(a);\n    let vb = ptr_deref_i32(b);\n    // 可以访问外部作用域的 'multiplier'\n    return (va * multiplier) - (vb * multiplier);\n}\n\nlet cmp = callback(scale, [\"ptr\", \"ptr\"], \"i32\");\n```\n\n### 线程安全\n\n回调调用通过互斥锁序列化以确保线程安全，因为 Hemlock 解释器不是完全线程安全的。这意味着：\n- 一次只能执行一个回调\n- 可以安全地与多线程 C 库一起使用\n- 如果回调从多个线程频繁调用，可能影响性能\n\n### 回调中的错误处理\n\n在回调中抛出的异常无法传播到 C 代码。相反：\n- 向 stderr 打印警告\n- 回调返回默认值（0 或 NULL）\n- 异常被记录但不传播\n\n```hemlock\nfn risky_callback(a: ptr): i32 {\n    throw \"Something went wrong\";  // 打印警告，返回 0\n}\n```\n\n为了健壮的错误处理，请验证输入并避免在回调中抛出异常。\n\n## FFI 结构体\n\nHemlock 支持按值向 C 函数传递结构体。当您使用类型注解定义结构体时，结构体类型会自动为 FFI 注册。\n\n### 定义 FFI 兼容的结构体\n\n当所有字段都具有使用 FFI 兼容类型的显式类型注解时，结构体就是 FFI 兼容的：\n\n```hemlock\n// FFI 兼容的结构体\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\n// 具有多种字段类型的 FFI 兼容结构体\ndefine Rectangle {\n    top_left: Point,      // 嵌套结构体\n    width: f64,\n    height: f64,\n}\n\n// 不是 FFI 兼容的（字段没有类型注解）\ndefine DynamicObject {\n    name,                 // 没有类型 - 不能用于 FFI\n    value,\n}\n```\n\n### 在 FFI 中使用结构体\n\n声明使用结构体类型的 extern 函数：\n\n```hemlock\n// 定义结构体类型\ndefine Vector2D {\n    x: f64,\n    y: f64,\n}\n\n// 导入 C 库\nimport \"libmath.so\";\n\n// 声明接受/返回结构体的 extern 函数\nextern fn vector_add(a: Vector2D, b: Vector2D): Vector2D;\nextern fn vector_length(v: Vector2D): f64;\n\n// 自然地使用它\nlet a: Vector2D = { x: 3.0, y: 0.0 };\nlet b: Vector2D = { x: 0.0, y: 4.0 };\nlet result = vector_add(a, b);\nprint(result.x);  // 3.0\nprint(result.y);  // 4.0\n\nlet len = vector_length(result);\nprint(len);       // 5.0\n```\n\n### 支持的字段类型\n\n结构体字段必须使用以下 FFI 兼容类型：\n\n| Hemlock 类型 | C 类型 | 大小 |\n|--------------|--------|------|\n| `i8` | `int8_t` | 1 字节 |\n| `i16` | `int16_t` | 2 字节 |\n| `i32` | `int32_t` | 4 字节 |\n| `i64` | `int64_t` | 8 字节 |\n| `u8` | `uint8_t` | 1 字节 |\n| `u16` | `uint16_t` | 2 字节 |\n| `u32` | `uint32_t` | 4 字节 |\n| `u64` | `uint64_t` | 8 字节 |\n| `f32` | `float` | 4 字节 |\n| `f64` | `double` | 8 字节 |\n| `ptr` | `void*` | 8 字节 |\n| `string` | `char*` | 8 字节 |\n| `bool` | `int` | 可变 |\n| 嵌套结构体 | struct | 可变 |\n\n### 结构体布局\n\nHemlock 使用平台的原生结构体布局规则（匹配 C ABI）：\n- 字段按其类型对齐\n- 根据需要插入填充\n- 总大小填充以对齐最大成员\n\n```hemlock\n// 示例：C 兼容布局\ndefine Mixed {\n    a: i8,    // 偏移 0，大小 1\n              // 3 字节填充\n    b: i32,   // 偏移 4，大小 4\n}\n// 总大小：8 字节（包含填充）\n\ndefine Point3D {\n    x: f64,   // 偏移 0，大小 8\n    y: f64,   // 偏移 8，大小 8\n    z: f64,   // 偏移 16，大小 8\n}\n// 总大小：24 字节（不需要填充）\n```\n\n### 嵌套结构体\n\n结构体可以包含其他结构体：\n\n```hemlock\ndefine Inner {\n    x: i32,\n    y: i32,\n}\n\ndefine Outer {\n    inner: Inner,\n    z: i32,\n}\n\nimport \"mylib.so\";\nextern fn process_nested(data: Outer): i32;\n\nlet obj: Outer = {\n    inner: { x: 1, y: 2 },\n    z: 3,\n};\nlet result = process_nested(obj);\n```\n\n### 结构体返回值\n\nC 函数可以返回结构体：\n\n```hemlock\ndefine Point {\n    x: f64,\n    y: f64,\n}\n\nimport \"libmath.so\";\nextern fn get_origin(): Point;\n\nlet p = get_origin();\nprint(p.x);  // 0.0\nprint(p.y);  // 0.0\n```\n\n### 限制\n\n- **结构体字段必须有类型注解** - 没有类型的字段不是 FFI 兼容的\n- **结构体中没有数组** - 改用指针\n- **没有联合体** - 仅支持结构体类型\n- **回调不能返回结构体** - 回调返回值使用指针\n\n## 当前限制\n\nFFI 有以下限制：\n\n**1. 手动类型转换**\n- 必须手动管理字符串转换\n- 没有自动的 Hemlock 字符串 <-> C 字符串转换\n\n**2. 有限的错误处理**\n- 基本错误报告\n- 回调中的异常无法传播到 C\n\n**3. 手动库加载**\n- 必须手动加载库\n- 没有自动绑定生成\n\n**4. 平台特定代码**\n- 库路径因平台而异\n- 必须处理 .so vs .dylib vs .dll\n\n## 最佳实践\n\n虽然全面的 FFI 文档仍在开发中，以下是一般的最佳实践：\n\n### 1. 类型安全\n\n```hemlock\n// 明确类型\nlet x: i32 = 42;\nlet result: f64 = c_function(x);\n```\n\n### 2. 内存管理\n\n```hemlock\n// 记住释放分配的内存\nlet ptr = c_malloc(1024);\n// ... 使用 ptr\nc_free(ptr);\n```\n\n### 3. 错误检查\n\n```hemlock\n// 检查返回值\nlet result = c_function();\nif (result == null) {\n    print(\"C function failed\");\n}\n```\n\n### 4. 平台兼容性\n\n```hemlock\n// 处理平台差异\n// 使用适当的库扩展名（.so、.dylib、.dll）\n```\n\n## 总结\n\nHemlock 的 FFI 提供：\n\n- 从共享库调用 C 函数\n- 原始类型支持（i8-i64, u8-u64, f32, f64, ptr）\n- 自动类型转换\n- 基于 libffi 的可移植性\n- 原生库集成基础\n- **函数指针回调** - 将 Hemlock 函数传递给 C\n- **导出 extern 函数** - 跨模块共享 FFI 绑定\n- **结构体传递和返回** - 按值传递 C 兼容的结构体\n- **导出 define** - 跨模块共享结构体类型定义（自动全局导入）\n- **完整的指针辅助函数** - 读写所有类型（i8-i64, u8-u64, f32, f64, ptr）\n- **缓冲区/指针转换** - 用于数据封送的 `buffer_ptr()`、`ptr_to_buffer()`\n- **FFI 类型大小** - 平台感知类型大小的 `ffi_sizeof()`\n- **平台类型** - 支持 `size_t`、`usize`、`isize`、`intptr_t`、`uintptr_t`\n\n**当前状态：** FFI 功能完备，支持原始类型、结构体、回调、模块导出和完整的指针辅助函数\n\n**未来：** 字符串封送辅助函数\n\n**用例：** 系统库、第三方库、qsort、事件循环、基于回调的 API、可重用的库包装器\n"}, "高级主题 -> File IO": {"id": "advanced-file-io", "content": "# Hemlock 文件 I/O\n\nHemlock 提供**文件对象 API**用于文件操作，具有适当的错误处理和资源管理。\n\n## 目录\n\n- [概述](#概述)\n- [打开文件](#打开文件)\n- [文件方法](#文件方法)\n- [文件属性](#文件属性)\n- [错误处理](#错误处理)\n- [资源管理](#资源管理)\n- [完整 API 参考](#完整-api-参考)\n- [常见模式](#常见模式)\n- [最佳实践](#最佳实践)\n\n## 概述\n\n文件对象 API 提供：\n\n- **显式资源管理** - 文件必须手动关闭\n- **多种打开模式** - 读取、写入、追加、读写\n- **文本和二进制操作** - 读写文本和二进制数据\n- **定位支持** - 文件内的随机访问\n- **全面的错误消息** - 上下文感知的错误报告\n\n**重要：** 文件不会自动关闭。您必须调用 `f.close()` 以避免文件描述符泄漏。\n\n## 打开文件\n\n使用 `open(path, mode?)` 打开文件：\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");     // 读取模式（默认）\nlet f2 = open(\"output.txt\", \"w\");  // 写入模式（截断）\nlet f3 = open(\"log.txt\", \"a\");     // 追加模式\nlet f4 = open(\"data.bin\", \"r+\");   // 读写模式\n```\n\n### 打开模式\n\n| 模式 | 描述 | 文件必须存在 | 截断 | 位置 |\n|------|------|------------|------|------|\n| `\"r\"` | 读取（默认） | 是 | 否 | 开始 |\n| `\"w\"` | 写入 | 否（创建） | 是 | 开始 |\n| `\"a\"` | 追加 | 否（创建） | 否 | 结束 |\n| `\"r+\"` | 读写 | 是 | 否 | 开始 |\n| `\"w+\"` | 读写 | 否（创建） | 是 | 开始 |\n| `\"a+\"` | 读取和追加 | 否（创建） | 否 | 结束 |\n\n### 示例\n\n**读取现有文件：**\n```hemlock\nlet f = open(\"config.json\", \"r\");\n// 或简单地：\nlet f = open(\"config.json\");  // \"r\" 是默认值\n```\n\n**创建新文件用于写入：**\n```hemlock\nlet f = open(\"output.txt\", \"w\");  // 创建或截断\n```\n\n**追加到文件：**\n```hemlock\nlet f = open(\"log.txt\", \"a\");  // 如果不存在则创建\n```\n\n**读写模式：**\n```hemlock\nlet f = open(\"data.bin\", \"r+\");  // 现有文件，可读写\n```\n\n## 文件方法\n\n### 读取\n\n#### read(size?: i32): string\n\n从文件读取文本（可选的大小参数）。\n\n**不带大小（读取全部）：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet all = f.read();  // 从当前位置读取到 EOF\nf.close();\n```\n\n**带大小（读取指定字节）：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet chunk = f.read(1024);  // 读取最多 1024 字节\nlet next = f.read(1024);   // 读取下一个 1024 字节\nf.close();\n```\n\n**返回：** 包含读取数据的字符串，如果在 EOF 则返回空字符串\n\n**示例 - 读取整个文件：**\n```hemlock\nlet f = open(\"poem.txt\", \"r\");\nlet content = f.read();\nprint(content);\nf.close();\n```\n\n**示例 - 分块读取：**\n```hemlock\nlet f = open(\"large.txt\", \"r\");\nwhile (true) {\n    let chunk = f.read(4096);  // 4KB 块\n    if (chunk == \"\") { break; }  // 到达 EOF\n    process(chunk);\n}\nf.close();\n```\n\n#### read_bytes(size: i32): buffer\n\n读取二进制数据（返回缓冲区）。\n\n**参数：**\n- `size` (i32) - 要读取的字节数\n\n**返回：** 包含读取字节的缓冲区\n\n```hemlock\nlet f = open(\"image.png\", \"r\");\nlet binary = f.read_bytes(256);  // 读取 256 字节\nprint(binary.length);  // 256（如果 EOF 则更少）\n\n// 访问单个字节\nlet first_byte = binary[0];\nprint(first_byte);\n\nf.close();\n```\n\n### 写入\n\n#### write(data: string): i32\n\n向文件写入文本（返回写入的字节数）。\n\n**参数：**\n- `data` (string) - 要写入的文本\n\n**返回：** 写入的字节数 (i32)\n\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Wrote \" + typeof(written) + \" bytes\");  // \"Wrote 14 bytes\"\nf.close();\n```\n\n**示例 - 写入多行：**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.write(\"Line 1\\n\");\nf.write(\"Line 2\\n\");\nf.write(\"Line 3\\n\");\nf.close();\n```\n\n**示例 - 追加到日志文件：**\n```hemlock\nlet f = open(\"app.log\", \"a\");\nf.write(\"[INFO] Application started\\n\");\nf.write(\"[INFO] User logged in\\n\");\nf.close();\n```\n\n#### write_bytes(data: buffer): i32\n\n写入二进制数据（返回写入的字节数）。\n\n**参数：**\n- `data` (buffer) - 要写入的二进制数据\n\n**返回：** 写入的字节数 (i32)\n\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// 创建二进制数据\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\nlet bytes = f.write_bytes(buf);\nprint(\"Wrote \" + typeof(bytes) + \" bytes\");\n\nf.close();\n```\n\n### 定位\n\n#### seek(position: i32): i32\n\n移动到指定位置（返回新位置）。\n\n**参数：**\n- `position` (i32) - 从文件开头的字节偏移量\n\n**返回：** 新位置 (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// 移动到第 100 字节\nf.seek(100);\n\n// 从位置 100 读取\nlet data = f.read(50);\n\n// 重置到开头\nf.seek(0);\n\nf.close();\n```\n\n**示例 - 随机访问：**\n```hemlock\nlet f = open(\"records.dat\", \"r\");\n\n// 读取偏移量 1000 处的记录\nf.seek(1000);\nlet record1 = f.read_bytes(100);\n\n// 读取偏移量 2000 处的记录\nf.seek(2000);\nlet record2 = f.read_bytes(100);\n\nf.close();\n```\n\n#### tell(): i32\n\n获取文件中的当前位置。\n\n**返回：** 当前字节偏移量 (i32)\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nlet pos1 = f.tell();  // 0（在开始处）\n\nf.read(100);\nlet pos2 = f.tell();  // 100（读取 100 字节后）\n\nf.seek(500);\nlet pos3 = f.tell();  // 500（定位后）\n\nf.close();\n```\n\n### 关闭\n\n#### close()\n\n关闭文件（幂等，可以多次调用）。\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n// ... 使用文件\nf.close();\nf.close();  // 安全 - 第二次关闭不报错\n```\n\n**重要说明：**\n- 始终在使用完后关闭文件以避免文件描述符泄漏\n- 关闭是幂等的 - 可以安全地多次调用\n- 关闭后，所有其他操作将报错\n- 使用 `finally` 块确保即使出错也能关闭文件\n\n## 文件属性\n\n文件对象有三个只读属性：\n\n### path: string\n\n用于打开文件的文件路径。\n\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);  // \"/path/to/file.txt\"\nf.close();\n```\n\n### mode: string\n\n文件打开时使用的模式。\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);  // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);  // \"w\"\nf2.close();\n```\n\n### closed: bool\n\n文件是否已关闭。\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);  // false\n\nf.close();\nprint(f.closed);  // true\n```\n\n**示例 - 检查文件是否打开：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... 处理内容\n}\n\nf.close();\n\nif (f.closed) {\n    print(\"File is now closed\");\n}\n```\n\n## 错误处理\n\n所有文件操作都包含带上下文的适当错误消息。\n\n### 常见错误\n\n**文件未找到：**\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// 错误：Failed to open 'missing.txt': No such file or directory\n```\n\n**从已关闭的文件读取：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// 错误：Cannot read from closed file 'data.txt'\n```\n\n**向只读文件写入：**\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// 错误：Cannot write to file 'readonly.txt' opened in read-only mode\n```\n\n**从只写文件读取：**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\nf.read();\n// 错误：Cannot read from file 'output.txt' opened in write-only mode\n```\n\n### 使用 try/catch\n\n```hemlock\ntry {\n    let f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    f.close();\n    process(content);\n} catch (e) {\n    print(\"Error reading file: \" + e);\n}\n```\n\n## 资源管理\n\n### 基本模式\n\n始终显式关闭文件：\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### 带错误处理（推荐）\n\n使用 `finally` 确保即使出错也能关闭文件：\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // 始终关闭，即使出错\n}\n```\n\n### 多个文件\n\n```hemlock\nlet src = null;\nlet dst = null;\n\ntry {\n    src = open(\"input.txt\", \"r\");\n    dst = open(\"output.txt\", \"w\");\n\n    let content = src.read();\n    dst.write(content);\n} finally {\n    if (src != null) { src.close(); }\n    if (dst != null) { dst.close(); }\n}\n```\n\n### 辅助函数模式\n\n```hemlock\nfn with_file(path: string, mode: string, callback) {\n    let f = open(path, mode);\n    try {\n        return callback(f);\n    } finally {\n        f.close();\n    }\n}\n\n// 使用：\nwith_file(\"data.txt\", \"r\", fn(f) {\n    return f.read();\n});\n```\n\n## 完整 API 参考\n\n### 函数\n\n| 函数 | 参数 | 返回 | 描述 |\n|------|------|------|------|\n| `open(path, mode?)` | path: string, mode?: string | File | 打开文件（模式默认为 \"r\"） |\n\n### 方法\n\n| 方法 | 参数 | 返回 | 描述 |\n|------|------|------|------|\n| `read(size?)` | size?: i32 | string | 读取文本（全部或指定字节） |\n| `read_bytes(size)` | size: i32 | buffer | 读取二进制数据 |\n| `write(data)` | data: string | i32 | 写入文本，返回写入的字节数 |\n| `write_bytes(data)` | data: buffer | i32 | 写入二进制数据，返回写入的字节数 |\n| `seek(position)` | position: i32 | i32 | 定位到位置，返回新位置 |\n| `tell()` | - | i32 | 获取当前位置 |\n| `close()` | - | null | 关闭文件（幂等） |\n\n### 属性（只读）\n\n| 属性 | 类型 | 描述 |\n|------|------|------|\n| `path` | string | 文件路径 |\n| `mode` | string | 打开模式 |\n| `closed` | bool | 文件是否已关闭 |\n\n## 常见模式\n\n### 读取整个文件\n\n```hemlock\nfn read_file(path: string): string {\n    let f = open(path, \"r\");\n    try {\n        return f.read();\n    } finally {\n        f.close();\n    }\n}\n\nlet content = read_file(\"config.json\");\n```\n\n### 写入整个文件\n\n```hemlock\nfn write_file(path: string, content: string) {\n    let f = open(path, \"w\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\");\n```\n\n### 追加到文件\n\n```hemlock\nfn append_file(path: string, content: string) {\n    let f = open(path, \"a\");\n    try {\n        f.write(content);\n    } finally {\n        f.close();\n    }\n}\n\nappend_file(\"log.txt\", \"[INFO] Event occurred\\n\");\n```\n\n### 读取行\n\n```hemlock\nfn read_lines(path: string) {\n    let f = open(path, \"r\");\n    try {\n        let content = f.read();\n        return content.split(\"\\n\");\n    } finally {\n        f.close();\n    }\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### 分块处理大文件\n\n```hemlock\nfn process_large_file(path: string) {\n    let f = open(path, \"r\");\n    try {\n        while (true) {\n            let chunk = f.read(4096);  // 4KB 块\n            if (chunk == \"\") { break; }\n\n            // 处理块\n            process_chunk(chunk);\n        }\n    } finally {\n        f.close();\n    }\n}\n```\n\n### 二进制文件复制\n\n```hemlock\nfn copy_file(src_path: string, dst_path: string) {\n    let src = null;\n    let dst = null;\n\n    try {\n        src = open(src_path, \"r\");\n        dst = open(dst_path, \"w\");\n\n        while (true) {\n            let chunk = src.read_bytes(4096);\n            if (chunk.length == 0) { break; }\n\n            dst.write_bytes(chunk);\n        }\n    } finally {\n        if (src != null) { src.close(); }\n        if (dst != null) { dst.close(); }\n    }\n}\n\ncopy_file(\"input.dat\", \"output.dat\");\n```\n\n### 文件截断\n\n```hemlock\nfn truncate_file(path: string) {\n    let f = open(path, \"w\");  // \"w\" 模式截断\n    f.close();\n}\n\ntruncate_file(\"empty_me.txt\");\n```\n\n### 随机访问读取\n\n```hemlock\nfn read_at_offset(path: string, offset: i32, size: i32): string {\n    let f = open(path, \"r\");\n    try {\n        f.seek(offset);\n        return f.read(size);\n    } finally {\n        f.close();\n    }\n}\n\nlet data = read_at_offset(\"records.dat\", 1000, 100);\n```\n\n## 最佳实践\n\n### 1. 始终使用 try/finally\n\n```hemlock\n// 好\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();\n}\n\n// 不好 - 出错时文件可能不关闭\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nprocess(content);  // 如果这里抛出异常，文件泄漏\nf.close();\n```\n\n### 2. 操作前检查文件状态\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nif (!f.closed) {\n    let content = f.read();\n    // ... 使用内容\n}\n\nf.close();\n```\n\n### 3. 使用适当的模式\n\n```hemlock\n// 只读？使用 \"r\"\nlet f = open(\"config.json\", \"r\");\n\n// 完全替换？使用 \"w\"\nlet f = open(\"output.txt\", \"w\");\n\n// 添加到末尾？使用 \"a\"\nlet f = open(\"log.txt\", \"a\");\n```\n\n### 4. 优雅地处理错误\n\n```hemlock\nfn safe_read_file(path: string): string {\n    try {\n        let f = open(path, \"r\");\n        try {\n            return f.read();\n        } finally {\n            f.close();\n        }\n    } catch (e) {\n        print(\"Warning: Could not read \" + path + \": \" + e);\n        return \"\";\n    }\n}\n```\n\n### 5. 按打开的相反顺序关闭文件\n\n```hemlock\nlet f1 = null;\nlet f2 = null;\nlet f3 = null;\n\ntry {\n    f1 = open(\"file1.txt\", \"r\");\n    f2 = open(\"file2.txt\", \"r\");\n    f3 = open(\"file3.txt\", \"r\");\n\n    // ... 使用文件\n} finally {\n    // 按相反顺序关闭\n    if (f3 != null) { f3.close(); }\n    if (f2 != null) { f2.close(); }\n    if (f1 != null) { f1.close(); }\n}\n```\n\n### 6. 避免完全读取大文件\n\n```hemlock\n// 对大文件不好\nlet f = open(\"huge.log\", \"r\");\nlet content = f.read();  // 将整个文件加载到内存\nf.close();\n\n// 好 - 分块处理\nlet f = open(\"huge.log\", \"r\");\ntry {\n    while (true) {\n        let chunk = f.read(4096);\n        if (chunk == \"\") { break; }\n        process_chunk(chunk);\n    }\n} finally {\n    f.close();\n}\n```\n\n## 总结\n\nHemlock 的文件 I/O API 提供：\n\n- 简单、显式的文件操作\n- 文本和二进制支持\n- 使用 seek/tell 的随机访问\n- 带上下文的清晰错误消息\n- 幂等的关闭操作\n\n请记住：\n- 始终手动关闭文件\n- 使用 try/finally 确保资源安全\n- 选择适当的打开模式\n- 优雅地处理错误\n- 分块处理大文件\n"}, "高级主题 -> Memory Ownership": {"id": "advanced-memory-ownership", "content": "# Hemlock 中的内存所有权\n\n> \"我们给你安全的工具，但不强迫你使用它们。\"\n\n本文档描述了 Hemlock 中的内存所有权语义，涵盖程序员管理的内存和运行时管理的值。\n\n## 目录\n\n1. [契约](#契约)\n2. [程序员管理的内存](#程序员管理的内存)\n3. [运行时管理的值](#运行时管理的值)\n4. [所有权转移点](#所有权转移点)\n5. [异步和并发](#异步和并发)\n6. [FFI 内存规则](#ffi-内存规则)\n7. [异常安全性](#异常安全性)\n8. [最佳实践](#最佳实践)\n\n---\n\n## 契约\n\nHemlock 对内存管理责任有明确的划分：\n\n| 内存类型 | 管理者 | 清理方法 |\n|----------|--------|----------|\n| 原始指针 (`ptr`) | **程序员** | `free(ptr)` |\n| 缓冲区 (`buffer`) | **程序员** | `free(buf)` |\n| 字符串、数组、对象 | **运行时** | 自动（引用计数） |\n| 函数、闭包 | **运行时** | 自动（引用计数） |\n| 任务、通道 | **运行时** | 自动（引用计数） |\n\n**核心原则：** 如果你显式分配，就显式释放。其他一切都自动处理。\n\n---\n\n## 程序员管理的内存\n\n### 原始指针\n\n```hemlock\nlet p = alloc(64);       // 分配 64 字节\nmemset(p, 0, 64);        // 初始化\n// ... 使用内存 ...\nfree(p);                 // 你的责任！\n```\n\n**规则：**\n- `alloc()` 返回你拥有的内存\n- 使用完毕后必须调用 `free()`\n- 双重释放会崩溃（故意设计）\n- 释放后使用是未定义行为\n- 允许指针算术但不检查\n\n### 类型化分配\n\n```hemlock\nlet arr = talloc(\"i32\", 100);  // 分配 100 个 i32（400 字节）\nptr_write_i32(arr, 0, 42);     // 写入索引 0\nlet val = ptr_read_i32(arr, 0); // 从索引 0 读取\nfree(arr);                      // 仍然是你的责任\n```\n\n### 缓冲区（安全替代）\n\n```hemlock\nlet buf = buffer(64);    // 有边界检查的缓冲区\nbuf[0] = 42;             // 安全的索引访问\n// buf[100] = 1;         // 运行时错误：越界\nfree(buf);               // 仍需要显式 free\n```\n\n**关键区别：** 缓冲区提供边界检查，原始指针不提供。\n\n---\n\n## 运行时管理的值\n\n### 引用计数\n\n堆分配的值使用原子引用计数：\n\n```hemlock\nlet s1 = \"hello\";        // 字符串分配，refcount = 1\nlet s2 = s1;             // s2 共享 s1，refcount = 2\n// 当两者都离开作用域时，refcount → 0，内存释放\n```\n\n**引用计数类型：**\n- `string` - UTF-8 文本\n- `array` - 动态数组\n- `object` - 键值对象\n- `function` - 闭包\n- `task` - 异步任务句柄\n- `channel` - 通信通道\n\n### 循环检测\n\n运行时处理对象图中的循环：\n\n```hemlock\nlet a = { ref: null };\nlet b = { ref: a };\na.ref = b;               // 循环: a → b → a\n// 运行时使用已访问集合在清理期间检测和打破循环\n```\n\n---\n\n## 所有权转移点\n\n### 变量绑定\n\n```hemlock\nlet x = [1, 2, 3];       // 创建数组，refcount 为 1\n                         // x 拥有引用\n```\n\n### 函数返回\n\n```hemlock\nfn make_array() {\n    return [1, 2, 3];    // 数组所有权转移给调用者\n}\nlet arr = make_array();  // arr 现在拥有引用\n```\n\n### 赋值\n\n```hemlock\nlet a = \"hello\";\nlet b = a;               // 共享引用（refcount 增加）\nb = \"world\";             // a 仍然是 \"hello\"，b 是 \"world\"\n```\n\n### 通道操作\n\n```hemlock\nlet ch = channel(10);\nch.send(\"message\");      // 值复制到通道缓冲区\n                         // 原始值仍然有效\n\nlet msg = ch.recv();     // 从通道接收所有权\n```\n\n### 任务生成\n\n```hemlock\nlet data = { x: 1 };\nlet task = spawn(worker, data);  // data 被深拷贝以实现隔离\ndata.x = 2;                       // 安全 - 任务有自己的副本\nlet result = join(task);          // result 所有权转移给调用者\n```\n\n---\n\n## 异步和并发\n\n### 线程隔离\n\n生成的任务接收可变参数的**深拷贝**：\n\n```hemlock\nasync fn worker(data) {\n    data.x = 100;        // 只修改任务的副本\n    return data;\n}\n\nlet obj = { x: 1 };\nlet task = spawn(worker, obj);\nobj.x = 2;               // 安全 - 不影响任务\nlet result = join(task);\nprint(obj.x);            // 2（未被任务改变）\nprint(result.x);         // 100（任务修改的副本）\n```\n\n### 共享协调对象\n\n某些类型通过引用共享（不复制）：\n- **通道** - 用于任务间通信\n- **任务** - 用于协调（join/detach）\n\n```hemlock\nlet ch = channel(1);\nspawn(producer, ch);     // 同一个通道，不是副本\nspawn(consumer, ch);     // 两个任务共享通道\n```\n\n### 任务结果\n\n```hemlock\nlet task = spawn(compute);\nlet result = join(task);  // 调用者拥有结果\n                          // 任务引用在任务释放时释放\n```\n\n### 分离的任务\n\n```hemlock\ndetach(spawn(background_work));\n// 任务独立运行\n// 任务完成时结果自动释放\n// 即使没人调用 join() 也不会泄漏\n```\n\n---\n\n## FFI 内存规则\n\n### 传递给 C 函数\n\n```hemlock\nextern fn strlen(s: string): i32;\n\nlet s = \"hello\";\nlet len = strlen(s);     // Hemlock 保留所有权\n                         // 字符串在调用期间有效\n                         // C 函数不应释放它\n```\n\n### 从 C 函数接收\n\n```hemlock\nextern fn strdup(s: string): ptr;\n\nlet copy = strdup(\"hello\");  // C 分配了这块内存\nfree(copy);                   // 你有责任释放\n```\n\n### 结构体传递（仅编译器）\n\n```hemlock\n// 定义 C 结构体布局\nffi_struct Point { x: f64, y: f64 }\n\nextern fn make_point(x: f64, y: f64): Point;\n\nlet p = make_point(1.0, 2.0);  // 按值返回，已复制\n                                // 栈上结构体不需要清理\n```\n\n### 回调内存\n\n```hemlock\n// 当 C 回调到 Hemlock 时：\n// - 参数属于 C（不要释放）\n// - 返回值所有权转移给 C\n```\n\n---\n\n## 异常安全性\n\n### 保证\n\n运行时提供以下保证：\n\n1. **正常退出无泄漏** - 所有运行时管理的值都被清理\n2. **异常时无泄漏** - 临时值在栈展开期间释放\n3. **异常时 defer 执行** - 清理代码会执行\n\n### 表达式求值\n\n```hemlock\n// 如果在数组创建期间抛出：\nlet arr = [f(), g(), h()];  // 部分数组被释放\n\n// 如果在函数调用期间抛出：\nfoo(a(), b(), c());         // 之前求值的参数被释放\n```\n\n### 用于清理的 Defer\n\n```hemlock\nfn process_file() {\n    let f = open(\"data.txt\", \"r\");\n    defer f.close();         // 在 return 或异常时运行\n\n    let data = f.read();\n    if (data == \"\") {\n        throw \"Empty file\";  // f.close() 仍会运行！\n    }\n    return data;\n}\n```\n\n---\n\n## 最佳实践\n\n### 1. 优先使用运行时管理的类型\n\n```hemlock\n// 优先这样：\nlet data = [1, 2, 3, 4, 5];\n\n// 而不是这样（除非需要底层控制）：\nlet data = talloc(\"i32\", 5);\n// ... 必须记得释放 ...\n```\n\n### 2. 对手动内存使用 Defer\n\n```hemlock\nfn process() {\n    let buf = alloc(1024);\n    defer free(buf);        // 保证清理\n\n    // ... 使用 buf ...\n    // 不需要在每个返回点释放\n}\n```\n\n### 3. 在异步中避免原始指针\n\n```hemlock\n// 错误 - 指针可能在任务完成前被释放\nlet p = alloc(64);\nspawn(worker, p);          // 任务获得指针值\nfree(p);                   // 糟糕！任务还在使用它\n\n// 正确 - 使用通道或复制数据\nlet ch = channel(1);\nlet data = buffer(64);\n// ... 填充 data ...\nch.send(data);             // 深拷贝\nspawn(worker, ch);\nfree(data);                // 安全 - 任务有自己的副本\n```\n\n### 4. 完成后关闭通道\n\n```hemlock\nlet ch = channel(10);\n// ... 使用通道 ...\nch.close();                // 排空并释放缓冲的值\n```\n\n### 5. Join 或 Detach 任务\n\n```hemlock\nlet task = spawn(work);\n\n// 选项 1：等待结果\nlet result = join(task);\n\n// 选项 2：Fire and forget\n// detach(task);\n\n// 不要：让任务句柄离开作用域而不 join 或 detach\n// （它会被清理，但结果可能泄漏）\n```\n\n---\n\n## 调试内存问题\n\n### 启用 ASAN\n\n```bash\nmake asan\nASAN_OPTIONS=detect_leaks=1 ./hemlock script.hml\n```\n\n### 运行泄漏回归测试\n\n```bash\nmake leak-regression       # 完整套件\nmake leak-regression-quick # 跳过全面测试\n```\n\n### Valgrind\n\n```bash\nmake valgrind-check FILE=script.hml\n```\n\n---\n\n## 总结\n\n| 操作 | 内存行为 |\n|------|----------|\n| `alloc(n)` | 分配，你释放 |\n| `buffer(n)` | 带边界检查分配，你释放 |\n| `\"string\"` | 运行时管理 |\n| `[array]` | 运行时管理 |\n| `{object}` | 运行时管理 |\n| `spawn(fn)` | 深拷贝参数，运行时管理任务 |\n| `join(task)` | 调用者拥有结果 |\n| `detach(task)` | 完成时运行时释放结果 |\n| `ch.send(v)` | 复制值到通道 |\n| `ch.recv()` | 调用者拥有接收的值 |\n| `ch.close()` | 排空并释放缓冲的值 |\n"}, "高级主题 -> 信号处理": {"id": "advanced-signals", "content": "# Hemlock 信号处理\n\nHemlock 提供 **POSIX 信号处理**，用于管理系统信号如 SIGINT（Ctrl+C）、SIGTERM 和自定义信号。这使得底层进程控制和进程间通信成为可能。\n\n## 目录\n\n- [概述](#概述)\n- [信号 API](#信号-api)\n- [信号常量](#信号常量)\n- [基本信号处理](#基本信号处理)\n- [高级模式](#高级模式)\n- [信号处理器行为](#信号处理器行为)\n- [安全考虑](#安全考虑)\n- [常见用例](#常见用例)\n- [完整示例](#完整示例)\n\n## 概述\n\n信号处理允许程序：\n- 响应用户中断（Ctrl+C、Ctrl+Z）\n- 实现优雅关闭\n- 处理终止请求\n- 使用自定义信号进行进程间通信\n- 创建警报/定时器机制\n\n**重要：** 按照 Hemlock 的哲学，信号处理**本质上是不安全的**。处理器可以在任何时候被调用，中断正常执行。用户负责适当的同步。\n\n## 信号 API\n\n### signal(signum, handler_fn)\n\n注册信号处理函数。\n\n**参数：**\n- `signum` (i32) - 信号编号（如 SIGINT、SIGTERM 常量）\n- `handler_fn` (function 或 null) - 接收到信号时调用的函数，或 `null` 重置为默认\n\n**返回：** 之前的处理函数（如果没有则返回 `null`）\n\n**示例：**\n```hemlock\nfn my_handler(sig) {\n    print(\"Caught signal: \" + typeof(sig));\n}\n\nlet old_handler = signal(SIGINT, my_handler);\n```\n\n**重置为默认：**\n```hemlock\nsignal(SIGINT, null);  // 将 SIGINT 重置为默认行为\n```\n\n### raise(signum)\n\n向当前进程发送信号。\n\n**参数：**\n- `signum` (i32) - 要发送的信号编号\n\n**返回：** `null`\n\n**示例：**\n```hemlock\nraise(SIGUSR1);  // 触发 SIGUSR1 处理器\n```\n\n## 信号常量\n\nHemlock 提供标准 POSIX 信号常量作为 i32 值。\n\n### 中断和终止\n\n| 常量 | 值 | 描述 | 常见触发 |\n|------|------|------|----------|\n| `SIGINT` | 2 | 键盘中断 | Ctrl+C |\n| `SIGTERM` | 15 | 终止请求 | `kill` 命令 |\n| `SIGQUIT` | 3 | 键盘退出 | Ctrl+\\ |\n| `SIGHUP` | 1 | 检测到挂断 | 终端关闭 |\n| `SIGABRT` | 6 | 中止信号 | `abort()` 函数 |\n\n**示例：**\n```hemlock\nsignal(SIGINT, handle_interrupt);   // Ctrl+C\nsignal(SIGTERM, handle_terminate);  // kill 命令\nsignal(SIGHUP, handle_hangup);      // 终端关闭\n```\n\n### 用户定义信号\n\n| 常量 | 值 | 描述 | 用例 |\n|------|------|------|------|\n| `SIGUSR1` | 10 | 用户定义信号 1 | 自定义 IPC |\n| `SIGUSR2` | 12 | 用户定义信号 2 | 自定义 IPC |\n\n**示例：**\n```hemlock\n// 用于自定义通信\nsignal(SIGUSR1, reload_config);\nsignal(SIGUSR2, rotate_logs);\n```\n\n### 进程控制\n\n| 常量 | 值 | 描述 | 说明 |\n|------|------|------|------|\n| `SIGALRM` | 14 | 警报时钟定时器 | `alarm()` 后 |\n| `SIGCHLD` | 17 | 子进程状态改变 | 进程管理 |\n| `SIGCONT` | 18 | 如果停止则继续 | 在 SIGSTOP 后恢复 |\n| `SIGSTOP` | 19 | 停止进程 | **无法捕获** |\n| `SIGTSTP` | 20 | 终端停止 | Ctrl+Z |\n\n**示例：**\n```hemlock\nsignal(SIGALRM, handle_timeout);\nsignal(SIGCHLD, handle_child_exit);\n```\n\n### I/O 信号\n\n| 常量 | 值 | 描述 | 何时发送 |\n|------|------|------|----------|\n| `SIGPIPE` | 13 | 管道断开 | 写入已关闭的管道 |\n| `SIGTTIN` | 21 | 后台从终端读取 | 后台进程读取 TTY |\n| `SIGTTOU` | 22 | 后台写入终端 | 后台进程写入 TTY |\n\n**示例：**\n```hemlock\nsignal(SIGPIPE, handle_broken_pipe);\n```\n\n## 基本信号处理\n\n### 捕获 Ctrl+C\n\n```hemlock\nlet interrupted = false;\n\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n    interrupted = true;\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// 程序继续运行...\n// 用户按 Ctrl+C -> 调用 handle_interrupt()\n\nwhile (!interrupted) {\n    // 做工作...\n}\n\nprint(\"Exiting due to interrupt\");\n```\n\n### 处理函数签名\n\n信号处理器接收一个参数：信号编号 (i32)\n\n```hemlock\nfn my_handler(signum) {\n    print(\"Received signal: \" + typeof(signum));\n    // signum 包含信号编号（如 SIGINT 为 2）\n\n    if (signum == SIGINT) {\n        print(\"This is SIGINT\");\n    }\n}\n\nsignal(SIGINT, my_handler);\nsignal(SIGTERM, my_handler);  // 多个信号使用同一处理器\n```\n\n### 多个信号处理器\n\n不同信号使用不同处理器：\n\n```hemlock\nfn handle_int(sig) {\n    print(\"SIGINT received\");\n}\n\nfn handle_term(sig) {\n    print(\"SIGTERM received\");\n}\n\nfn handle_usr1(sig) {\n    print(\"SIGUSR1 received\");\n}\n\nsignal(SIGINT, handle_int);\nsignal(SIGTERM, handle_term);\nsignal(SIGUSR1, handle_usr1);\n```\n\n### 重置为默认行为\n\n传递 `null` 作为处理器以重置为默认行为：\n\n```hemlock\n// 注册自定义处理器\nsignal(SIGINT, my_handler);\n\n// 稍后，重置为默认（SIGINT 时终止）\nsignal(SIGINT, null);\n```\n\n### 手动触发信号\n\n向自己的进程发送信号：\n\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\n// 手动触发处理器\nraise(SIGUSR1);\nraise(SIGUSR1);\n\nprint(count);  // 2\n```\n\n## 高级模式\n\n### 优雅关闭模式\n\n终止时清理的常见模式：\n\n```hemlock\nlet should_exit = false;\n\nfn handle_shutdown(sig) {\n    print(\"Shutting down gracefully...\");\n    should_exit = true;\n}\n\nsignal(SIGINT, handle_shutdown);\nsignal(SIGTERM, handle_shutdown);\n\n// 主循环\nwhile (!should_exit) {\n    // 做工作...\n    // 定期检查 should_exit 标志\n}\n\nprint(\"Cleanup complete\");\n```\n\n### 信号计数器\n\n跟踪接收的信号数量：\n\n```hemlock\nlet signal_count = 0;\n\nfn count_signals(sig) {\n    signal_count = signal_count + 1;\n    print(\"Received \" + typeof(signal_count) + \" signals\");\n}\n\nsignal(SIGUSR1, count_signals);\n\n// 稍后...\nprint(\"Total signals: \" + typeof(signal_count));\n```\n\n### 信号重新加载配置\n\n```hemlock\nlet config = load_config();\n\nfn reload_config(sig) {\n    print(\"Reloading configuration...\");\n    config = load_config();\n    print(\"Configuration reloaded\");\n}\n\nsignal(SIGHUP, reload_config);  // 收到 SIGHUP 时重新加载\n\n// 从 shell 发送 SIGHUP 到进程以重新加载配置\n// kill -HUP <pid>\n```\n\n### 使用 SIGALRM 的超时\n\n```hemlock\nlet timed_out = false;\n\nfn handle_alarm(sig) {\n    print(\"Timeout!\");\n    timed_out = true;\n}\n\nsignal(SIGALRM, handle_alarm);\n\n// 设置警报（Hemlock 中尚未实现，仅示例）\n// alarm(5);  // 5 秒超时\n\nwhile (!timed_out) {\n    // 带超时的工作\n}\n```\n\n### 基于信号的状态机\n\n```hemlock\nlet state = 0;\n\nfn next_state(sig) {\n    state = (state + 1) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nfn prev_state(sig) {\n    state = (state - 1 + 3) % 3;\n    print(\"State: \" + typeof(state));\n}\n\nsignal(SIGUSR1, next_state);  // 前进状态\nsignal(SIGUSR2, prev_state);  // 后退状态\n\n// 控制状态机：\n// kill -USR1 <pid>  # 下一状态\n// kill -USR2 <pid>  # 上一状态\n```\n\n## 信号处理器行为\n\n### 重要说明\n\n**处理器执行：**\n- 处理器在接收到信号时**同步**调用\n- 处理器在当前进程上下文中执行\n- 信号处理器共享定义它们的函数的闭包环境\n- 处理器可以访问和修改外部作用域变量（如全局变量或捕获的变量）\n\n**最佳实践：**\n- 保持处理器简单快速 - 避免长时间运行的操作\n- 设置标志而不是执行复杂逻辑\n- 避免调用可能获取锁的函数\n- 注意处理器可以中断任何操作\n\n### 哪些信号可以捕获\n\n**可以捕获和处理：**\n- SIGINT、SIGTERM、SIGUSR1、SIGUSR2、SIGHUP、SIGQUIT\n- SIGALRM、SIGCHLD、SIGCONT、SIGTSTP\n- SIGPIPE、SIGTTIN、SIGTTOU\n- SIGABRT（但处理器返回后程序将中止）\n\n**无法捕获：**\n- `SIGKILL` (9) - 始终终止进程\n- `SIGSTOP` (19) - 始终停止进程\n\n**系统相关：**\n- 某些信号的默认行为可能因系统而异\n- 查看您平台的信号文档了解详情\n\n### 处理器限制\n\n```hemlock\nfn complex_handler(sig) {\n    // 在信号处理器中避免这些：\n\n    // ❌ 长时间运行的操作\n    // process_large_file();\n\n    // ❌ 阻塞 I/O\n    // let f = open(\"log.txt\", \"a\");\n    // f.write(\"Signal received\\n\");\n\n    // ❌ 复杂的状态更改\n    // rebuild_entire_data_structure();\n\n    // ✅ 简单的标志设置是安全的\n    let should_stop = true;\n\n    // ✅ 简单的计数器更新通常是安全的\n    let signal_count = signal_count + 1;\n}\n```\n\n## 安全考虑\n\n按照 Hemlock 的哲学，信号处理**本质上是不安全的**。\n\n### 竞争条件\n\n处理器可以在任何时候被调用，中断正常执行：\n\n```hemlock\nlet counter = 0;\n\nfn increment(sig) {\n    counter = counter + 1;  // 如果在 counter 更新期间调用会有竞争条件\n}\n\nsignal(SIGUSR1, increment);\n\n// 主代码也修改 counter\ncounter = counter + 1;  // 可能被信号处理器中断\n```\n\n**问题：** 如果信号在主代码更新 `counter` 时到达，结果是不可预测的。\n\n### 异步信号安全\n\nHemlock **不**保证异步信号安全：\n- 处理器可以调用任何 Hemlock 代码（不像 C 的受限异步信号安全函数）\n- 这提供了灵活性但需要用户谨慎\n- 如果处理器修改共享状态，可能出现竞争条件\n\n### 安全信号处理的最佳实践\n\n**1. 使用原子标志**\n\n简单的布尔赋值通常是安全的：\n\n```hemlock\nlet should_exit = false;\n\nfn handler(sig) {\n    should_exit = true;  // 简单赋值是安全的\n}\n\nsignal(SIGINT, handler);\n\nwhile (!should_exit) {\n    // 工作...\n}\n```\n\n**2. 最小化共享状态**\n\n```hemlock\nlet interrupt_count = 0;\n\nfn handler(sig) {\n    // 只修改这一个变量\n    interrupt_count = interrupt_count + 1;\n}\n```\n\n**3. 延迟复杂操作**\n\n```hemlock\nlet pending_reload = false;\n\nfn signal_reload(sig) {\n    pending_reload = true;  // 只设置标志\n}\n\nsignal(SIGHUP, signal_reload);\n\n// 在主循环中：\nwhile (true) {\n    if (pending_reload) {\n        reload_config();  // 在这里执行复杂工作\n        pending_reload = false;\n    }\n\n    // 正常工作...\n}\n```\n\n**4. 避免重入问题**\n\n```hemlock\nlet in_critical_section = false;\nlet data = [];\n\nfn careful_handler(sig) {\n    if (in_critical_section) {\n        // 主代码使用数据时不要修改它\n        return;\n    }\n    // 可以安全继续\n}\n```\n\n## 常见用例\n\n### 1. 优雅的服务器关闭\n\n```hemlock\nlet running = true;\n\nfn shutdown(sig) {\n    print(\"Shutdown signal received\");\n    running = false;\n}\n\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// 服务器主循环\nwhile (running) {\n    handle_client_request();\n}\n\ncleanup_resources();\nprint(\"Server stopped\");\n```\n\n### 2. 配置重新加载（无需重启）\n\n```hemlock\nlet config = load_config(\"app.conf\");\nlet reload_needed = false;\n\nfn trigger_reload(sig) {\n    reload_needed = true;\n}\n\nsignal(SIGHUP, trigger_reload);\n\nwhile (true) {\n    if (reload_needed) {\n        print(\"Reloading configuration...\");\n        config = load_config(\"app.conf\");\n        reload_needed = false;\n    }\n\n    // 使用配置...\n}\n```\n\n### 3. 日志轮转\n\n```hemlock\nlet log_file = open(\"app.log\", \"a\");\nlet rotate_needed = false;\n\nfn trigger_rotate(sig) {\n    rotate_needed = true;\n}\n\nsignal(SIGUSR1, trigger_rotate);\n\nwhile (true) {\n    if (rotate_needed) {\n        log_file.close();\n        // 重命名旧日志，打开新的\n        exec(\"mv app.log app.log.old\");\n        log_file = open(\"app.log\", \"a\");\n        rotate_needed = false;\n    }\n\n    // 正常日志记录...\n    log_file.write(\"Log entry\\n\");\n}\n```\n\n### 4. 状态报告\n\n```hemlock\nlet requests_handled = 0;\n\nfn report_status(sig) {\n    print(\"Status: \" + typeof(requests_handled) + \" requests handled\");\n}\n\nsignal(SIGUSR1, report_status);\n\nwhile (true) {\n    handle_request();\n    requests_handled = requests_handled + 1;\n}\n\n// 从 shell：kill -USR1 <pid>\n```\n\n### 5. 调试模式切换\n\n```hemlock\nlet debug_mode = false;\n\nfn toggle_debug(sig) {\n    debug_mode = !debug_mode;\n    if (debug_mode) {\n        print(\"Debug mode: ON\");\n    } else {\n        print(\"Debug mode: OFF\");\n    }\n}\n\nsignal(SIGUSR2, toggle_debug);\n\n// 从 shell：kill -USR2 <pid> 切换\n```\n\n## 完整示例\n\n### 示例 1：带清理的中断处理器\n\n```hemlock\nlet running = true;\nlet signal_count = 0;\n\nfn handle_signal(signum) {\n    signal_count = signal_count + 1;\n\n    if (signum == SIGINT) {\n        print(\"Interrupt detected (Ctrl+C)\");\n        running = false;\n    }\n\n    if (signum == SIGUSR1) {\n        print(\"User signal 1 received\");\n    }\n}\n\n// 注册处理器\nsignal(SIGINT, handle_signal);\nsignal(SIGUSR1, handle_signal);\n\n// 模拟一些工作\nlet i = 0;\nwhile (running && i < 100) {\n    print(\"Working... \" + typeof(i));\n\n    // 每 10 次迭代触发 SIGUSR1\n    if (i == 10 || i == 20) {\n        raise(SIGUSR1);\n    }\n\n    i = i + 1;\n}\n\nprint(\"Total signals received: \" + typeof(signal_count));\n```\n\n### 示例 2：多信号状态机\n\n```hemlock\nlet state = \"idle\";\nlet request_count = 0;\n\nfn start_processing(sig) {\n    state = \"processing\";\n    print(\"State: \" + state);\n}\n\nfn stop_processing(sig) {\n    state = \"idle\";\n    print(\"State: \" + state);\n}\n\nfn report_stats(sig) {\n    print(\"State: \" + state);\n    print(\"Requests: \" + typeof(request_count));\n}\n\nsignal(SIGUSR1, start_processing);\nsignal(SIGUSR2, stop_processing);\nsignal(SIGHUP, report_stats);\n\nwhile (true) {\n    if (state == \"processing\") {\n        // 做工作\n        request_count = request_count + 1;\n    }\n\n    // 每次迭代检查...\n}\n```\n\n### 示例 3：工作池控制器\n\n```hemlock\nlet worker_count = 4;\nlet should_exit = false;\n\nfn increase_workers(sig) {\n    worker_count = worker_count + 1;\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn decrease_workers(sig) {\n    if (worker_count > 1) {\n        worker_count = worker_count - 1;\n    }\n    print(\"Workers: \" + typeof(worker_count));\n}\n\nfn shutdown(sig) {\n    print(\"Shutting down...\");\n    should_exit = true;\n}\n\nsignal(SIGUSR1, increase_workers);\nsignal(SIGUSR2, decrease_workers);\nsignal(SIGINT, shutdown);\nsignal(SIGTERM, shutdown);\n\n// 主循环根据 worker_count 调整工作池\nwhile (!should_exit) {\n    // 根据 worker_count 管理工作者\n    // ...\n}\n```\n\n## 调试信号处理器\n\n### 添加诊断打印\n\n```hemlock\nfn debug_handler(sig) {\n    print(\"Handler called for signal: \" + typeof(sig));\n    print(\"Stack: (not yet available)\");\n\n    // 你的处理器逻辑...\n}\n\nsignal(SIGINT, debug_handler);\n```\n\n### 计数信号调用\n\n```hemlock\nlet handler_calls = 0;\n\nfn counting_handler(sig) {\n    handler_calls = handler_calls + 1;\n    print(\"Handler call #\" + typeof(handler_calls));\n\n    // 你的处理器逻辑...\n}\n```\n\n### 使用 raise() 测试\n\n```hemlock\nfn test_handler(sig) {\n    print(\"Test signal received: \" + typeof(sig));\n}\n\nsignal(SIGUSR1, test_handler);\n\n// 通过手动触发测试\nraise(SIGUSR1);\nprint(\"Handler should have been called\");\n```\n\n## 总结\n\nHemlock 的信号处理提供：\n\n- 用于底层进程控制的 POSIX 信号处理\n- 15 个标准信号常量\n- 简单的 signal() 和 raise() API\n- 灵活的处理函数，支持闭包\n- 多个信号可以共享处理器\n\n请记住：\n- 信号处理本质上是不安全的 - 谨慎使用\n- 保持处理器简单快速\n- 使用标志进行状态更改，而不是复杂操作\n- 处理器可以在任何时候中断执行\n- 无法捕获 SIGKILL 或 SIGSTOP\n- 使用 raise() 彻底测试处理器\n\n常见模式：\n- 优雅关闭（SIGINT、SIGTERM）\n- 配置重新加载（SIGHUP）\n- 日志轮转（SIGUSR1）\n- 状态报告（SIGUSR1/SIGUSR2）\n- 调试模式切换（SIGUSR2）\n"}, "高级主题 -> 原子操作": {"id": "advanced-atomics", "content": "# 原子操作\n\nHemlock 提供原子操作用于**无锁并发编程**。这些操作使得在多个线程间安全操作共享内存成为可能，无需传统的锁或互斥锁。\n\n## 目录\n\n- [概述](#概述)\n- [何时使用原子操作](#何时使用原子操作)\n- [内存模型](#内存模型)\n- [原子加载和存储](#原子加载和存储)\n- [获取并修改操作](#获取并修改操作)\n- [比较并交换 (CAS)](#比较并交换-cas)\n- [原子交换](#原子交换)\n- [内存栅栏](#内存栅栏)\n- [函数参考](#函数参考)\n- [常见模式](#常见模式)\n- [最佳实践](#最佳实践)\n- [限制](#限制)\n\n---\n\n## 概述\n\n原子操作是**不可分割的**操作，完成时不可能被中断。当一个线程执行原子操作时，其他线程无法观察到操作的部分完成状态。\n\n**主要特性：**\n- 所有操作使用**顺序一致性**（`memory_order_seq_cst`）\n- 支持的类型：**i32** 和 **i64**\n- 操作适用于通过 `alloc()` 分配的原始指针\n- 无需显式锁即可保证线程安全\n\n**可用操作：**\n- Load/Store - 原子读取和写入值\n- Add/Sub - 返回旧值的算术操作\n- And/Or/Xor - 返回旧值的位运算操作\n- CAS - 条件更新的比较并交换\n- Exchange - 原子交换值\n- Fence - 完整内存屏障\n\n---\n\n## 何时使用原子操作\n\n**使用原子操作的场景：**\n- 跨任务共享的计数器（如请求计数、进度跟踪）\n- 标志和状态指示器\n- 无锁数据结构\n- 简单的同步原语\n- 性能关键的并发代码\n\n**改用通道的场景：**\n- 在任务间传递复杂数据\n- 实现生产者-消费者模式\n- 需要消息传递语义时\n\n**示例用例 - 共享计数器：**\n```hemlock\n// 分配共享计数器\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nasync fn worker(counter: ptr, id: i32) {\n    let i = 0;\n    while (i < 1000) {\n        atomic_add_i32(counter, 1);\n        i = i + 1;\n    }\n}\n\n// 生成多个工作者\nlet t1 = spawn(worker, counter, 1);\nlet t2 = spawn(worker, counter, 2);\nlet t3 = spawn(worker, counter, 3);\n\njoin(t1);\njoin(t2);\njoin(t3);\n\n// 计数器将恰好是 3000（无数据竞争）\nprint(atomic_load_i32(counter));\n\nfree(counter);\n```\n\n---\n\n## 内存模型\n\n所有 Hemlock 原子操作使用**顺序一致性**（`memory_order_seq_cst`），提供最强的内存排序保证：\n\n1. **原子性**：每个操作都是不可分割的\n2. **全局排序**：所有线程看到相同的操作顺序\n3. **无重排序**：操作不会被编译器或 CPU 重排序\n\n这使得并发代码的推理更简单，但与较弱的内存排序相比可能有一些性能成本。\n\n---\n\n## 原子加载和存储\n\n### atomic_load_i32 / atomic_load_i64\n\n原子地从内存读取值。\n\n**签名：**\n```hemlock\natomic_load_i32(ptr: ptr): i32\natomic_load_i64(ptr: ptr): i64\n```\n\n**参数：**\n- `ptr` - 指向内存位置的指针（必须正确对齐）\n\n**返回：** 内存位置的值\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\n\nlet value = atomic_load_i32(p);\nprint(value);  // 42\n\nfree(p);\n```\n\n---\n\n### atomic_store_i32 / atomic_store_i64\n\n原子地向内存写入值。\n\n**签名：**\n```hemlock\natomic_store_i32(ptr: ptr, value: i32): null\natomic_store_i64(ptr: ptr, value: i64): null\n```\n\n**参数：**\n- `ptr` - 指向内存位置的指针\n- `value` - 要存储的值\n\n**返回：** `null`\n\n**示例：**\n```hemlock\nlet p = alloc(8);\n\natomic_store_i64(p, 5000000000);\nprint(atomic_load_i64(p));  // 5000000000\n\nfree(p);\n```\n\n---\n\n## 获取并修改操作\n\n这些操作原子地修改值并返回**旧的**（之前的）值。\n\n### atomic_add_i32 / atomic_add_i64\n\n原子地加法。\n\n**签名：**\n```hemlock\natomic_add_i32(ptr: ptr, value: i32): i32\natomic_add_i64(ptr: ptr, value: i64): i64\n```\n\n**返回：** **旧的**值（加法之前）\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_add_i32(p, 10);\nprint(old);                    // 100（旧值）\nprint(atomic_load_i32(p));     // 110（新值）\n\nfree(p);\n```\n\n---\n\n### atomic_sub_i32 / atomic_sub_i64\n\n原子地减法。\n\n**签名：**\n```hemlock\natomic_sub_i32(ptr: ptr, value: i32): i32\natomic_sub_i64(ptr: ptr, value: i64): i64\n```\n\n**返回：** **旧的**值（减法之前）\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_sub_i32(p, 25);\nprint(old);                    // 100（旧值）\nprint(atomic_load_i32(p));     // 75（新值）\n\nfree(p);\n```\n\n---\n\n### atomic_and_i32 / atomic_and_i64\n\n原子地执行按位与。\n\n**签名：**\n```hemlock\natomic_and_i32(ptr: ptr, value: i32): i32\natomic_and_i64(ptr: ptr, value: i64): i64\n```\n\n**返回：** **旧的**值（与运算之前）\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xFF);  // 二进制 255：11111111\n\nlet old = atomic_and_i32(p, 0x0F);  // 与 00001111 进行与运算\nprint(old);                    // 255（旧值）\nprint(atomic_load_i32(p));     // 15 (0xFF & 0x0F = 0x0F)\n\nfree(p);\n```\n\n---\n\n### atomic_or_i32 / atomic_or_i64\n\n原子地执行按位或。\n\n**签名：**\n```hemlock\natomic_or_i32(ptr: ptr, value: i32): i32\natomic_or_i64(ptr: ptr, value: i64): i64\n```\n\n**返回：** **旧的**值（或运算之前）\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0x0F);  // 二进制 15：00001111\n\nlet old = atomic_or_i32(p, 0xF0);  // 与 11110000 进行或运算\nprint(old);                    // 15（旧值）\nprint(atomic_load_i32(p));     // 255 (0x0F | 0xF0 = 0xFF)\n\nfree(p);\n```\n\n---\n\n### atomic_xor_i32 / atomic_xor_i64\n\n原子地执行按位异或。\n\n**签名：**\n```hemlock\natomic_xor_i32(ptr: ptr, value: i32): i32\natomic_xor_i64(ptr: ptr, value: i64): i64\n```\n\n**返回：** **旧的**值（异或运算之前）\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 0xAA);  // 二进制 170：10101010\n\nlet old = atomic_xor_i32(p, 0xFF);  // 与 11111111 进行异或运算\nprint(old);                    // 170（旧值）\nprint(atomic_load_i32(p));     // 85 (0xAA ^ 0xFF = 0x55)\n\nfree(p);\n```\n\n---\n\n## 比较并交换 (CAS)\n\n最强大的原子操作。原子地将当前值与期望值比较，如果匹配则替换为新值。\n\n### atomic_cas_i32 / atomic_cas_i64\n\n**签名：**\n```hemlock\natomic_cas_i32(ptr: ptr, expected: i32, desired: i32): bool\natomic_cas_i64(ptr: ptr, expected: i64, desired: i64): bool\n```\n\n**参数：**\n- `ptr` - 指向内存位置的指针\n- `expected` - 我们期望找到的值\n- `desired` - 如果期望匹配则存储的值\n\n**返回：**\n- `true` - 交换成功（值是 `expected`，现在是 `desired`）\n- `false` - 交换失败（值不是 `expected`，未改变）\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\n// CAS 成功：值是 100，交换为 999\nlet success1 = atomic_cas_i32(p, 100, 999);\nprint(success1);               // true\nprint(atomic_load_i32(p));     // 999\n\n// CAS 失败：值是 999，不是 100\nlet success2 = atomic_cas_i32(p, 100, 888);\nprint(success2);               // false\nprint(atomic_load_i32(p));     // 999（未改变）\n\nfree(p);\n```\n\n**用例：**\n- 实现锁和信号量\n- 无锁数据结构\n- 乐观并发控制\n- 原子条件更新\n\n---\n\n## 原子交换\n\n原子地交换值，返回旧值。\n\n### atomic_exchange_i32 / atomic_exchange_i64\n\n**签名：**\n```hemlock\natomic_exchange_i32(ptr: ptr, value: i32): i32\natomic_exchange_i64(ptr: ptr, value: i64): i64\n```\n\n**参数：**\n- `ptr` - 指向内存位置的指针\n- `value` - 要存储的新值\n\n**返回：** **旧的**值（交换之前）\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 100);\n\nlet old = atomic_exchange_i32(p, 200);\nprint(old);                    // 100（旧值）\nprint(atomic_load_i32(p));     // 200（新值）\n\nfree(p);\n```\n\n---\n\n## 内存栅栏\n\n完整的内存屏障，确保栅栏之前的所有内存操作对所有线程可见，然后才执行栅栏之后的任何操作。\n\n### atomic_fence\n\n**签名：**\n```hemlock\natomic_fence(): null\n```\n\n**返回：** `null`\n\n**示例：**\n```hemlock\n// 确保之前的所有写入对其他线程可见\natomic_fence();\n```\n\n**注意：** 在大多数情况下，你不需要显式的栅栏，因为所有原子操作已经使用顺序一致性。栅栏在需要同步非原子内存操作时很有用。\n\n---\n\n## 函数参考\n\n### i32 操作\n\n| 函数 | 签名 | 返回 | 描述 |\n|------|------|------|------|\n| `atomic_load_i32` | `(ptr)` | `i32` | 原子加载值 |\n| `atomic_store_i32` | `(ptr, value)` | `null` | 原子存储值 |\n| `atomic_add_i32` | `(ptr, value)` | `i32` | 加法并返回旧值 |\n| `atomic_sub_i32` | `(ptr, value)` | `i32` | 减法并返回旧值 |\n| `atomic_and_i32` | `(ptr, value)` | `i32` | 按位与并返回旧值 |\n| `atomic_or_i32` | `(ptr, value)` | `i32` | 按位或并返回旧值 |\n| `atomic_xor_i32` | `(ptr, value)` | `i32` | 按位异或并返回旧值 |\n| `atomic_cas_i32` | `(ptr, expected, desired)` | `bool` | 比较并交换 |\n| `atomic_exchange_i32` | `(ptr, value)` | `i32` | 交换并返回旧值 |\n\n### i64 操作\n\n| 函数 | 签名 | 返回 | 描述 |\n|------|------|------|------|\n| `atomic_load_i64` | `(ptr)` | `i64` | 原子加载值 |\n| `atomic_store_i64` | `(ptr, value)` | `null` | 原子存储值 |\n| `atomic_add_i64` | `(ptr, value)` | `i64` | 加法并返回旧值 |\n| `atomic_sub_i64` | `(ptr, value)` | `i64` | 减法并返回旧值 |\n| `atomic_and_i64` | `(ptr, value)` | `i64` | 按位与并返回旧值 |\n| `atomic_or_i64` | `(ptr, value)` | `i64` | 按位或并返回旧值 |\n| `atomic_xor_i64` | `(ptr, value)` | `i64` | 按位异或并返回旧值 |\n| `atomic_cas_i64` | `(ptr, expected, desired)` | `bool` | 比较并交换 |\n| `atomic_exchange_i64` | `(ptr, value)` | `i64` | 交换并返回旧值 |\n\n### 内存屏障\n\n| 函数 | 签名 | 返回 | 描述 |\n|------|------|------|------|\n| `atomic_fence` | `()` | `null` | 完整内存屏障 |\n\n---\n\n## 常见模式\n\n### 模式：原子计数器\n\n```hemlock\n// 线程安全的计数器\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nfn increment(): i32 {\n    return atomic_add_i32(counter, 1);\n}\n\nfn decrement(): i32 {\n    return atomic_sub_i32(counter, 1);\n}\n\nfn get_count(): i32 {\n    return atomic_load_i32(counter);\n}\n\n// 使用\nincrement();  // 返回 0（旧值）\nincrement();  // 返回 1\nincrement();  // 返回 2\nprint(get_count());  // 3\n\nfree(counter);\n```\n\n### 模式：自旋锁\n\n```hemlock\n// 简单的自旋锁实现\nlet lock = alloc(4);\nptr_write_i32(lock, 0);  // 0 = 未锁定，1 = 已锁定\n\nfn acquire() {\n    // 自旋直到成功将锁从 0 设置为 1\n    while (!atomic_cas_i32(lock, 0, 1)) {\n        // 忙等待\n    }\n}\n\nfn release() {\n    atomic_store_i32(lock, 0);\n}\n\n// 使用\nacquire();\n// ... 临界区 ...\nrelease();\n\nfree(lock);\n```\n\n### 模式：一次性初始化\n\n```hemlock\nlet initialized = alloc(4);\nptr_write_i32(initialized, 0);  // 0 = 未初始化，1 = 已初始化\n\nfn ensure_initialized() {\n    // 尝试成为初始化者\n    if (atomic_cas_i32(initialized, 0, 1)) {\n        // 我们赢得了竞争，执行初始化\n        do_expensive_init();\n    }\n    // 否则，已经初始化过了\n}\n```\n\n### 模式：原子标志\n\n```hemlock\nlet flag = alloc(4);\nptr_write_i32(flag, 0);\n\nfn set_flag() {\n    atomic_store_i32(flag, 1);\n}\n\nfn clear_flag() {\n    atomic_store_i32(flag, 0);\n}\n\nfn test_and_set(): bool {\n    // 如果标志已经设置则返回 true\n    return atomic_exchange_i32(flag, 1) == 1;\n}\n\nfn check_flag(): bool {\n    return atomic_load_i32(flag) == 1;\n}\n```\n\n### 模式：有界计数器\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\nlet max_value = 100;\n\nfn try_increment(): bool {\n    while (true) {\n        let current = atomic_load_i32(counter);\n        if (current >= max_value) {\n            return false;  // 已达最大值\n        }\n        if (atomic_cas_i32(counter, current, current + 1)) {\n            return true;  // 成功递增\n        }\n        // CAS 失败，另一个线程修改了值 - 重试\n    }\n}\n```\n\n---\n\n## 最佳实践\n\n### 1. 使用正确的对齐\n\n指针必须为数据类型正确对齐：\n- i32：4 字节对齐\n- i64：8 字节对齐\n\n来自 `alloc()` 的内存通常是正确对齐的。\n\n### 2. 优先使用更高级的抽象\n\n如果可能，使用通道进行任务间通信。原子操作是更底层的，需要仔细推理。\n\n```hemlock\n// 优先这样：\nlet ch = channel(10);\nspawn(fn() { ch.send(result); });\nlet value = ch.recv();\n\n// 而不是在适当时使用手动原子协调\n```\n\n### 3. 注意 ABA 问题\n\nCAS 可能遭受 ABA 问题：值从 A 变为 B 然后又变回 A。你的 CAS 成功了，但状态可能在中间已经改变。\n\n### 4. 在共享之前初始化\n\n始终在生成访问原子变量的任务之前初始化它们：\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);  // 在生成之前初始化\n\nlet task = spawn(worker, counter);\n```\n\n### 5. 在所有任务完成后释放\n\n不要在任务可能仍在访问原子内存时释放它：\n\n```hemlock\nlet counter = alloc(4);\nptr_write_i32(counter, 0);\n\nlet t1 = spawn(worker, counter);\nlet t2 = spawn(worker, counter);\n\njoin(t1);\njoin(t2);\n\n// 现在可以安全释放\nfree(counter);\n```\n\n---\n\n## 限制\n\n### 当前限制\n\n1. **仅支持 i32 和 i64** - 其他类型没有原子操作\n2. **没有指针原子操作** - 无法原子地加载/存储指针\n3. **仅顺序一致性** - 没有较弱的内存排序可用\n4. **没有原子浮点数** - 如果需要请使用整数表示\n\n### 平台说明\n\n- 原子操作底层使用 C11 `<stdatomic.h>`\n- 在所有支持 POSIX 线程的平台上可用\n- 在现代 64 位系统上保证无锁\n\n---\n\n## 另请参阅\n\n- [异步/并发](#advanced-async-concurrency) - 任务生成和通道\n- [内存管理](#language-guide-memory) - 指针和缓冲区分配\n- [内存 API](#reference-memory-api) - 分配函数\n"}, "高级主题 -> 命令执行": {"id": "advanced-command-execution", "content": "# Hemlock 命令执行\n\nHemlock 提供 **`exec()` 内置函数**来执行 shell 命令并捕获输出。\n\n## 目录\n\n- [概述](#概述)\n- [exec() 函数](#exec-函数)\n- [结果对象](#结果对象)\n- [基本用法](#基本用法)\n- [高级示例](#高级示例)\n- [错误处理](#错误处理)\n- [实现细节](#实现细节)\n- [安全考虑](#安全考虑)\n- [限制](#限制)\n- [用例](#用例)\n- [最佳实践](#最佳实践)\n- [完整示例](#完整示例)\n\n## 概述\n\n`exec()` 函数允许 Hemlock 程序：\n- 执行 shell 命令\n- 捕获标准输出（stdout）\n- 检查退出状态码\n- 使用 shell 特性（管道、重定向等）\n- 与系统工具集成\n\n**重要：** 命令通过 `/bin/sh` 执行，提供完整的 shell 功能，但也引入了安全考虑。\n\n## exec() 函数\n\n### 签名\n\n```hemlock\nexec(command: string): object\n```\n\n**参数：**\n- `command` (string) - 要执行的 shell 命令\n\n**返回：** 包含两个字段的对象：\n- `output` (string) - 命令的 stdout 输出\n- `exit_code` (i32) - 命令的退出状态码\n\n### 基本示例\n\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n```\n\n## 结果对象\n\n`exec()` 返回的对象具有以下结构：\n\n```hemlock\n{\n    output: string,      // 命令 stdout（捕获的输出）\n    exit_code: i32       // 进程退出状态（0 = 成功）\n}\n```\n\n### output 字段\n\n包含命令写入 stdout 的所有文本。\n\n**属性：**\n- 如果命令没有输出则为空字符串\n- 原样包含换行符和空白\n- 多行输出保留\n- 大小无限制（动态分配）\n\n**示例：**\n```hemlock\nlet r1 = exec(\"echo test\");\nprint(r1.output);  // \"test\\n\"\n\nlet r2 = exec(\"ls\");\nprint(r2.output);  // 带换行符的目录列表\n\nlet r3 = exec(\"true\");\nprint(r3.output);  // \"\"（空字符串）\n```\n\n### exit_code 字段\n\n命令的退出状态码。\n\n**值：**\n- `0` 通常表示成功\n- `1-255` 表示错误（约定因命令而异）\n- `-1` 如果命令无法执行或异常终止\n\n**示例：**\n```hemlock\nlet r1 = exec(\"true\");\nprint(r1.exit_code);  // 0（成功）\n\nlet r2 = exec(\"false\");\nprint(r2.exit_code);  // 1（失败）\n\nlet r3 = exec(\"ls /nonexistent\");\nprint(r3.exit_code);  // 2（文件未找到，因命令而异）\n```\n\n## 基本用法\n\n### 简单命令\n\n```hemlock\nlet r = exec(\"ls -la\");\nprint(r.output);\nprint(\"Exit code: \" + typeof(r.exit_code));\n```\n\n### 检查退出状态\n\n```hemlock\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Found: \" + r.output);\n} else {\n    print(\"Pattern not found\");\n}\n```\n\n### 带管道的命令\n\n```hemlock\nlet r = exec(\"ps aux | grep hemlock\");\nprint(r.output);\n```\n\n### 多条命令\n\n```hemlock\nlet r = exec(\"cd /tmp && ls -la\");\nprint(r.output);\n```\n\n### 命令替换\n\n```hemlock\nlet r = exec(\"echo $(date)\");\nprint(r.output);  // 当前日期\n```\n\n## 高级示例\n\n### 处理失败\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\nif (r.exit_code != 0) {\n    print(\"Command failed with code: \" + typeof(r.exit_code));\n    print(\"Error output: \" + r.output);  // 注意：stderr 未捕获\n}\n```\n\n### 处理多行输出\n\n```hemlock\nlet r = exec(\"cat file.txt\");\nlet lines = r.output.split(\"\\n\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line \" + typeof(i) + \": \" + lines[i]);\n    i = i + 1;\n}\n```\n\n### 命令链\n\n**使用 &&（与）：**\n```hemlock\nlet r1 = exec(\"mkdir -p /tmp/test && touch /tmp/test/file.txt\");\nif (r1.exit_code == 0) {\n    print(\"Setup complete\");\n}\n```\n\n**使用 ||（或）：**\n```hemlock\nlet r = exec(\"command1 || command2\");\n// 仅当 command1 失败时运行 command2\n```\n\n**使用 ;（顺序）：**\n```hemlock\nlet r = exec(\"command1; command2\");\n// 无论成功/失败都运行两者\n```\n\n### 使用管道\n\n```hemlock\nlet r = exec(\"echo 'data' | base64\");\nprint(\"Base64: \" + r.output);\n```\n\n**复杂管道：**\n```hemlock\nlet r = exec(\"cat /etc/passwd | grep root | cut -d: -f1\");\nprint(r.output);\n```\n\n### 退出码模式\n\n不同的退出码表示不同的条件：\n\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n} else if (r.exit_code == 1) {\n    print(\"File does not exist\");\n} else {\n    print(\"Test command failed: \" + typeof(r.exit_code));\n}\n```\n\n### 输出重定向\n\n```hemlock\n// 将 stdout 重定向到文件（在 shell 内）\nlet r1 = exec(\"echo 'test' > /tmp/output.txt\");\n\n// 将 stderr 重定向到 stdout（注意：Hemlock 仍未捕获 stderr）\nlet r2 = exec(\"command 2>&1\");\n```\n\n### 环境变量\n\n```hemlock\nlet r = exec(\"export VAR=value && echo $VAR\");\nprint(r.output);  // \"value\\n\"\n```\n\n### 工作目录更改\n\n```hemlock\nlet r = exec(\"cd /tmp && pwd\");\nprint(r.output);  // \"/tmp\\n\"\n```\n\n## 错误处理\n\n### exec() 何时抛出异常\n\n如果命令无法执行，`exec()` 函数会抛出异常：\n\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command_xyz\");\n} catch (e) {\n    print(\"Failed to execute: \" + e);\n}\n```\n\n**抛出异常的情况：**\n- `popen()` 失败（如无法创建管道）\n- 系统资源限制超出\n- 内存分配失败\n\n### exec() 何时不抛出异常\n\n```hemlock\n// 命令运行但返回非零退出码\nlet r1 = exec(\"false\");\nprint(r1.exit_code);  // 1（不是异常）\n\n// 命令没有输出\nlet r2 = exec(\"true\");\nprint(r2.output);  // \"\"（不是异常）\n\n// shell 找不到命令\nlet r3 = exec(\"nonexistent_cmd\");\nprint(r3.exit_code);  // 127（不是异常）\n```\n\n### 安全执行模式\n\n```hemlock\nfn safe_exec(command: string) {\n    try {\n        let r = exec(command);\n        if (r.exit_code != 0) {\n            print(\"Warning: Command failed with code \" + typeof(r.exit_code));\n            return \"\";\n        }\n        return r.output;\n    } catch (e) {\n        print(\"Error executing command: \" + e);\n        return \"\";\n    }\n}\n\nlet output = safe_exec(\"ls -la\");\n```\n\n## 实现细节\n\n### 工作原理\n\n**底层实现：**\n- 使用 `popen()` 通过 `/bin/sh` 执行命令\n- 仅捕获 stdout（stderr 未捕获）\n- 输出动态缓冲（从 4KB 开始，按需增长）\n- 使用 `WIFEXITED()` 和 `WEXITSTATUS()` 宏提取退出状态\n- 输出字符串正确以 null 结尾\n\n**进程流程：**\n1. `popen(command, \"r\")` 创建管道并 fork 进程\n2. 子进程执行 `/bin/sh -c \"command\"`\n3. 父进程通过管道将 stdout 读入增长的缓冲区\n4. `pclose()` 等待子进程并返回退出状态\n5. 提取退出状态并存储在结果对象中\n\n### 性能考虑\n\n**开销：**\n- 每次调用创建新的 shell 进程（约 1-5ms 开销）\n- 输出完全存储在内存中（非流式）\n- 不支持流式传输（等待命令完成）\n- 适用于输出大小合理的命令\n\n**优化：**\n- 缓冲区从 4KB 开始，满时翻倍（高效内存使用）\n- 单一读取循环最小化系统调用\n- 无额外字符串复制\n\n**何时使用：**\n- 短时运行的命令（< 1 秒）\n- 中等输出大小（< 10MB）\n- 具有合理间隔的批量操作\n\n**何时不使用：**\n- 长时运行的守护进程或服务\n- 产生 GB 级输出的命令\n- 实时流数据处理\n- 高频执行（> 100 次/秒）\n\n## 安全考虑\n\n### Shell 注入风险\n\n**关键：** 命令由 shell（`/bin/sh`）执行，这意味着 **shell 注入是可能的**。\n\n**易受攻击的代码：**\n```hemlock\n// 危险 - 不要这样做\nlet filename = args[1];  // 用户输入\nlet r = exec(\"cat \" + filename);  // Shell 注入！\n```\n\n**攻击：**\n```bash\n./hemlock script.hml \"; rm -rf /; echo pwned\"\n# 执行: cat ; rm -rf /; echo pwned\n```\n\n### 安全实践\n\n**1. 永远不要使用未经净化的用户输入：**\n```hemlock\n// 不好\nlet user_input = args[1];\nlet r = exec(\"process \" + user_input);  // 危险\n\n// 好 - 先验证\nfn is_safe_filename(name: string): bool {\n    // 只允许字母数字、破折号、下划线、点\n    let i = 0;\n    while (i < name.length) {\n        let c = name[i];\n        if (!(c >= 'a' && c <= 'z') &&\n            !(c >= 'A' && c <= 'Z') &&\n            !(c >= '0' && c <= '9') &&\n            c != '-' && c != '_' && c != '.') {\n            return false;\n        }\n        i = i + 1;\n    }\n    return true;\n}\n\nlet filename = args[1];\nif (is_safe_filename(filename)) {\n    let r = exec(\"cat \" + filename);\n} else {\n    print(\"Invalid filename\");\n}\n```\n\n**2. 使用白名单，而不是黑名单：**\n```hemlock\n// 好 - 严格的白名单\nlet allowed_commands = [\"status\", \"start\", \"stop\", \"restart\"];\nlet cmd = args[1];\n\nlet found = false;\nfor (let allowed in allowed_commands) {\n    if (cmd == allowed) {\n        found = true;\n        break;\n    }\n}\n\nif (found) {\n    exec(\"service myapp \" + cmd);\n} else {\n    print(\"Invalid command\");\n}\n```\n\n**3. 转义特殊字符：**\n```hemlock\nfn shell_escape(s: string): string {\n    // 简单转义 - 用单引号包裹并转义单引号\n    let escaped = s.replace_all(\"'\", \"'\\\\''\");\n    return \"'\" + escaped + \"'\";\n}\n\nlet user_file = args[1];\nlet safe = shell_escape(user_file);\nlet r = exec(\"cat \" + safe);\n```\n\n**4. 避免对文件操作使用 exec()：**\n```hemlock\n// 不好 - 使用 exec 进行文件操作\nlet r = exec(\"cat file.txt\");\n\n// 好 - 使用 Hemlock 的文件 API\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### 权限考虑\n\n命令以与 Hemlock 进程相同的权限运行：\n\n```hemlock\n// 如果 Hemlock 以 root 运行，exec() 命令也以 root 运行！\nlet r = exec(\"rm -rf /important\");  // 如果以 root 运行则危险\n```\n\n**最佳实践：** 以所需的最小权限运行 Hemlock。\n\n## 限制\n\n### 1. 无 stderr 捕获\n\n只捕获 stdout，stderr 输出到终端：\n\n```hemlock\nlet r = exec(\"ls /nonexistent\");\n// r.output 为空\n// 错误消息出现在终端上，未捕获\n```\n\n**变通方法 - 将 stderr 重定向到 stdout：**\n```hemlock\nlet r = exec(\"ls /nonexistent 2>&1\");\n// 现在错误消息在 r.output 中\n```\n\n### 2. 无流式传输\n\n必须等待命令完成：\n\n```hemlock\nlet r = exec(\"long_running_command\");\n// 阻塞直到命令完成\n// 无法增量处理输出\n```\n\n### 3. 无超时\n\n命令可以无限期运行：\n\n```hemlock\nlet r = exec(\"sleep 1000\");\n// 阻塞 1000 秒\n// 无法超时或取消\n```\n\n**变通方法 - 使用 timeout 命令：**\n```hemlock\nlet r = exec(\"timeout 5 long_command\");\n// 5 秒后超时\n```\n\n### 4. 无信号处理\n\n无法向运行中的命令发送信号：\n\n```hemlock\nlet r = exec(\"long_command\");\n// 无法向命令发送 SIGINT、SIGTERM 等\n```\n\n### 5. 无进程控制\n\n启动后无法与命令交互：\n\n```hemlock\nlet r = exec(\"interactive_program\");\n// 无法向程序发送输入\n// 无法控制执行\n```\n\n## 用例\n\n### 适合的用例\n\n**1. 运行系统工具：**\n```hemlock\nlet r = exec(\"ls -la\");\nlet r = exec(\"grep pattern file.txt\");\nlet r = exec(\"find /path -name '*.txt'\");\n```\n\n**2. 使用 Unix 工具快速处理数据：**\n```hemlock\nlet r = exec(\"cat data.txt | sort | uniq | wc -l\");\nprint(\"Unique lines: \" + r.output);\n```\n\n**3. 检查系统状态：**\n```hemlock\nlet r = exec(\"df -h\");\nprint(\"Disk usage:\\n\" + r.output);\n```\n\n**4. 文件存在性检查：**\n```hemlock\nlet r = exec(\"test -f myfile.txt\");\nif (r.exit_code == 0) {\n    print(\"File exists\");\n}\n```\n\n**5. 生成报告：**\n```hemlock\nlet r = exec(\"ps aux | grep myapp | wc -l\");\nlet count = r.output.trim();\nprint(\"Running instances: \" + count);\n```\n\n**6. 自动化脚本：**\n```hemlock\nexec(\"git add .\");\nexec(\"git commit -m 'Auto commit'\");\nlet r = exec(\"git push\");\nif (r.exit_code != 0) {\n    print(\"Push failed\");\n}\n```\n\n### 不推荐的用例\n\n**1. 长时运行的服务：**\n```hemlock\n// 不好\nlet r = exec(\"nginx\");  // 永远阻塞\n```\n\n**2. 交互式命令：**\n```hemlock\n// 不好 - 无法提供输入\nlet r = exec(\"ssh user@host\");\n```\n\n**3. 产生巨大输出的命令：**\n```hemlock\n// 不好 - 将整个输出加载到内存\nlet r = exec(\"cat 10GB_file.log\");\n```\n\n**4. 实时流式传输：**\n```hemlock\n// 不好 - 无法增量处理输出\nlet r = exec(\"tail -f /var/log/app.log\");\n```\n\n**5. 关键任务错误处理：**\n```hemlock\n// 不好 - stderr 未捕获\nlet r = exec(\"critical_operation\");\n// 无法看到详细错误消息\n```\n\n## 最佳实践\n\n### 1. 始终检查退出码\n\n```hemlock\nlet r = exec(\"important_command\");\nif (r.exit_code != 0) {\n    print(\"Command failed!\");\n    // 处理错误\n}\n```\n\n### 2. 需要时修剪输出\n\n```hemlock\nlet r = exec(\"echo test\");\nlet clean = r.output.trim();  // 移除尾随换行符\nprint(clean);  // \"test\"（无换行符）\n```\n\n### 3. 执行前验证\n\n```hemlock\nfn is_valid_command(cmd: string): bool {\n    // 验证命令是否安全\n    return true;  // 你的验证逻辑\n}\n\nif (is_valid_command(user_cmd)) {\n    exec(user_cmd);\n}\n```\n\n### 4. 对关键操作使用 try/catch\n\n```hemlock\ntry {\n    let r = exec(\"critical_command\");\n    if (r.exit_code != 0) {\n        throw \"Command failed\";\n    }\n} catch (e) {\n    print(\"Error: \" + e);\n    // 清理或恢复\n}\n```\n\n### 5. 优先使用 Hemlock API 而不是 exec()\n\n```hemlock\n// 不好 - 使用 exec 进行文件操作\nlet r = exec(\"cat file.txt\");\n\n// 好 - 使用 Hemlock 的文件 API\nlet f = open(\"file.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### 6. 需要时捕获 stderr\n\n```hemlock\n// 将 stderr 重定向到 stdout\nlet r = exec(\"command 2>&1\");\n// 现在 r.output 同时包含 stdout 和 stderr\n```\n\n### 7. 明智使用 Shell 特性\n\n```hemlock\n// 使用管道提高效率\nlet r = exec(\"cat large.txt | grep pattern | head -n 10\");\n\n// 使用命令替换\nlet r = exec(\"echo Current user: $(whoami)\");\n\n// 使用条件执行\nlet r = exec(\"test -f file.txt && cat file.txt\");\n```\n\n## 完整示例\n\n### 示例 1：系统信息收集器\n\n```hemlock\nfn get_system_info() {\n    print(\"=== System Information ===\");\n\n    // 主机名\n    let r1 = exec(\"hostname\");\n    print(\"Hostname: \" + r1.output.trim());\n\n    // 运行时间\n    let r2 = exec(\"uptime\");\n    print(\"Uptime: \" + r2.output.trim());\n\n    // 磁盘使用\n    let r3 = exec(\"df -h /\");\n    print(\"\\nDisk Usage:\");\n    print(r3.output);\n\n    // 内存使用\n    let r4 = exec(\"free -h\");\n    print(\"Memory Usage:\");\n    print(r4.output);\n}\n\nget_system_info();\n```\n\n### 示例 2：日志分析器\n\n```hemlock\nfn analyze_log(logfile: string) {\n    print(\"Analyzing log: \" + logfile);\n\n    // 统计总行数\n    let r1 = exec(\"wc -l \" + logfile);\n    print(\"Total lines: \" + r1.output.trim());\n\n    // 统计错误数\n    let r2 = exec(\"grep -c ERROR \" + logfile + \" 2>/dev/null\");\n    let errors = r2.output.trim();\n    if (r2.exit_code == 0) {\n        print(\"Errors: \" + errors);\n    } else {\n        print(\"Errors: 0\");\n    }\n\n    // 统计警告数\n    let r3 = exec(\"grep -c WARN \" + logfile + \" 2>/dev/null\");\n    let warnings = r3.output.trim();\n    if (r3.exit_code == 0) {\n        print(\"Warnings: \" + warnings);\n    } else {\n        print(\"Warnings: 0\");\n    }\n\n    // 最近的错误\n    print(\"\\nRecent errors:\");\n    let r4 = exec(\"grep ERROR \" + logfile + \" | tail -n 5\");\n    print(r4.output);\n}\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <logfile>\");\n} else {\n    analyze_log(args[1]);\n}\n```\n\n### 示例 3：Git 助手\n\n```hemlock\nfn git_status() {\n    let r = exec(\"git status --short\");\n    if (r.exit_code != 0) {\n        print(\"Error: Not a git repository\");\n        return;\n    }\n\n    if (r.output == \"\") {\n        print(\"Working directory clean\");\n    } else {\n        print(\"Changes:\");\n        print(r.output);\n    }\n}\n\nfn git_quick_commit(message: string) {\n    print(\"Adding all changes...\");\n    let r1 = exec(\"git add -A\");\n    if (r1.exit_code != 0) {\n        print(\"Error adding files\");\n        return;\n    }\n\n    print(\"Committing...\");\n    let safe_msg = message.replace_all(\"'\", \"'\\\\''\");\n    let r2 = exec(\"git commit -m '\" + safe_msg + \"'\");\n    if (r2.exit_code != 0) {\n        print(\"Error committing\");\n        return;\n    }\n\n    print(\"Committed successfully\");\n    print(r2.output);\n}\n\n// 用法\ngit_status();\nif (args.length > 1) {\n    git_quick_commit(args[1]);\n}\n```\n\n### 示例 4：备份脚本\n\n```hemlock\nfn backup_directory(source: string, dest: string) {\n    print(\"Backing up \" + source + \" to \" + dest);\n\n    // 创建备份目录\n    let r1 = exec(\"mkdir -p \" + dest);\n    if (r1.exit_code != 0) {\n        print(\"Error creating backup directory\");\n        return false;\n    }\n\n    // 创建带时间戳的压缩包\n    let r2 = exec(\"date +%Y%m%d_%H%M%S\");\n    let timestamp = r2.output.trim();\n    let backup_file = dest + \"/backup_\" + timestamp + \".tar.gz\";\n\n    print(\"Creating archive: \" + backup_file);\n    let r3 = exec(\"tar -czf \" + backup_file + \" \" + source + \" 2>&1\");\n    if (r3.exit_code != 0) {\n        print(\"Error creating backup:\");\n        print(r3.output);\n        return false;\n    }\n\n    print(\"Backup completed successfully\");\n\n    // 显示备份大小\n    let r4 = exec(\"du -h \" + backup_file);\n    print(\"Backup size: \" + r4.output.trim());\n\n    return true;\n}\n\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <source> <destination>\");\n} else {\n    backup_directory(args[1], args[2]);\n}\n```\n\n## 总结\n\nHemlock 的 `exec()` 函数提供：\n\n- 简单的 shell 命令执行\n- 输出捕获（stdout）\n- 退出码检查\n- 完整的 shell 特性访问（管道、重定向等）\n- 与系统工具的集成\n\n请记住：\n- 始终检查退出码\n- 注意安全隐患（shell 注入）\n- 在命令中使用前验证用户输入\n- 可用时优先使用 Hemlock API 而不是 exec()\n- stderr 未捕获（使用 `2>&1` 重定向）\n- 命令阻塞直到完成\n- 用于短时运行的工具，不是长时运行的服务\n\n**安全检查清单：**\n- 永远不要使用未经净化的用户输入\n- 验证所有输入\n- 对命令使用白名单\n- 必要时转义特殊字符\n- 以最小权限运行\n- 优先使用 Hemlock API 而不是 shell 命令\n"}, "高级主题 -> 命令行参数": {"id": "advanced-command-line-args", "content": "# Hemlock 命令行参数\n\nHemlock 程序可以通过内置的 **`args` 数组**访问命令行参数，该数组在程序启动时自动填充。\n\n## 目录\n\n- [概述](#概述)\n- [args 数组](#args-数组)\n- [属性](#属性)\n- [迭代模式](#迭代模式)\n- [常见用例](#常见用例)\n- [参数解析模式](#参数解析模式)\n- [最佳实践](#最佳实践)\n- [完整示例](#完整示例)\n\n## 概述\n\n`args` 数组提供对传递给 Hemlock 程序的命令行参数的访问：\n\n- **始终可用** - 所有 Hemlock 程序中的内置全局变量\n- **包含脚本名称** - `args[0]` 始终包含脚本路径/名称\n- **字符串数组** - 所有参数都是字符串\n- **从零开始索引** - 标准数组索引（0、1、2、...）\n\n## args 数组\n\n### 基本结构\n\n```hemlock\n// args[0] 始终是脚本文件名\n// args[1] 到 args[n-1] 是实际参数\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // 参数总数（包括脚本名称）\n```\n\n### 使用示例\n\n**命令：**\n```bash\n./hemlock script.hml hello world \"test 123\"\n```\n\n**在 script.hml 中：**\n```hemlock\nprint(\"Script name: \" + args[0]);     // \"script.hml\"\nprint(\"Total args: \" + typeof(args.length));  // \"4\"\nprint(\"First arg: \" + args[1]);       // \"hello\"\nprint(\"Second arg: \" + args[2]);      // \"world\"\nprint(\"Third arg: \" + args[3]);       // \"test 123\"\n```\n\n### 索引参考\n\n| 索引 | 包含 | 示例值 |\n|-------|----------|---------------|\n| `args[0]` | 脚本路径/名称 | `\"script.hml\"` 或 `\"./script.hml\"` |\n| `args[1]` | 第一个参数 | `\"hello\"` |\n| `args[2]` | 第二个参数 | `\"world\"` |\n| `args[3]` | 第三个参数 | `\"test 123\"` |\n| ... | ... | ... |\n| `args[n-1]` | 最后一个参数 | （不定） |\n\n## 属性\n\n### 始终存在\n\n`args` 是**所有** Hemlock 程序中可用的全局数组：\n\n```hemlock\n// 无需声明或导入\nprint(args.length);  // 立即可用\n```\n\n### 包含脚本名称\n\n`args[0]` 始终包含脚本路径/名称：\n\n```hemlock\nprint(\"Running: \" + args[0]);\n```\n\n**args[0] 的可能值：**\n- `\"script.hml\"` - 仅文件名\n- `\"./script.hml\"` - 相对路径\n- `\"/home/user/script.hml\"` - 绝对路径\n- 取决于脚本的调用方式\n\n### 类型：字符串数组\n\n所有参数都存储为字符串：\n\n```hemlock\n// 参数: ./hemlock script.hml 42 3.14 true\n\nprint(args[1]);  // \"42\"（字符串，不是数字）\nprint(args[2]);  // \"3.14\"（字符串，不是数字）\nprint(args[3]);  // \"true\"（字符串，不是布尔值）\n\n// 根据需要转换：\nlet num = 42;  // 如需要可手动解析\n```\n\n### 最小长度\n\n始终至少为 1（脚本名称）：\n\n```hemlock\nprint(args.length);  // 最小值: 1\n```\n\n**即使没有参数：**\n```bash\n./hemlock script.hml\n```\n\n```hemlock\n// 在 script.hml 中：\nprint(args.length);  // 1（仅脚本名称）\n```\n\n### REPL 行为\n\n在 REPL 中，`args.length` 为 0（空数组）：\n\n```hemlock\n# REPL 会话\n> print(args.length);\n0\n```\n\n## 迭代模式\n\n### 基本迭代\n\n跳过 `args[0]`（脚本名称）并处理实际参数：\n\n```hemlock\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument \" + typeof(i) + \": \" + args[i]);\n    i = i + 1;\n}\n```\n\n**对于 `./hemlock script.hml foo bar baz` 的输出：**\n```\nArgument 1: foo\nArgument 2: bar\nArgument 3: baz\n```\n\n### For-In 迭代（包括脚本名称）\n\n```hemlock\nfor (let arg in args) {\n    print(arg);\n}\n```\n\n**输出：**\n```\nscript.hml\nfoo\nbar\nbaz\n```\n\n### 检查参数数量\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <argument>\");\n    // 退出或返回\n} else {\n    let arg = args[1];\n    // 处理 arg\n}\n```\n\n### 处理除脚本名称外的所有参数\n\n```hemlock\nlet actual_args = args.slice(1, args.length);\n\nfor (let arg in actual_args) {\n    print(\"Processing: \" + arg);\n}\n```\n\n## 常见用例\n\n### 1. 简单参数处理\n\n检查必需参数：\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <filename>\");\n} else {\n    let filename = args[1];\n    print(\"Processing file: \" + filename);\n    // ... 处理文件\n}\n```\n\n**用法：**\n```bash\n./hemlock script.hml data.txt\n# 输出: Processing file: data.txt\n```\n\n### 2. 多个参数\n\n```hemlock\nif (args.length < 3) {\n    print(\"Usage: \" + args[0] + \" <input> <output>\");\n} else {\n    let input_file = args[1];\n    let output_file = args[2];\n\n    print(\"Input: \" + input_file);\n    print(\"Output: \" + output_file);\n\n    // 处理文件...\n}\n```\n\n**用法：**\n```bash\n./hemlock convert.hml input.txt output.txt\n```\n\n### 3. 可变数量的参数\n\n处理所有提供的参数：\n\n```hemlock\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        print(\"  \" + args[i]);\n        process_file(args[i]);\n        i = i + 1;\n    }\n}\n```\n\n**用法：**\n```bash\n./hemlock batch.hml file1.txt file2.txt file3.txt\n```\n\n### 4. 帮助信息\n\n```hemlock\nif (args.length < 2 || args[1] == \"--help\" || args[1] == \"-h\") {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show this help message\");\n    print(\"  -v, --verbose  Enable verbose output\");\n} else {\n    // 正常处理\n}\n```\n\n### 5. 参数验证\n\n```hemlock\nfn validate_file(filename: string): bool {\n    // 检查文件是否存在（示例）\n    return filename != \"\";\n}\n\nif (args.length < 2) {\n    print(\"Error: No filename provided\");\n} else if (!validate_file(args[1])) {\n    print(\"Error: Invalid file: \" + args[1]);\n} else {\n    print(\"Processing: \" + args[1]);\n}\n```\n\n## 参数解析模式\n\n### 命名参数（标志）\n\n命名参数的简单模式：\n\n```hemlock\nlet verbose = false;\nlet output_file = \"\";\nlet input_file = \"\";\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\" || args[i] == \"-v\") {\n        verbose = true;\n    } else if (args[i] == \"--output\" || args[i] == \"-o\") {\n        i = i + 1;\n        if (i < args.length) {\n            output_file = args[i];\n        }\n    } else {\n        input_file = args[i];\n    }\n    i = i + 1;\n}\n\nif (verbose) {\n    print(\"Verbose mode enabled\");\n}\nprint(\"Input: \" + input_file);\nprint(\"Output: \" + output_file);\n```\n\n**用法：**\n```bash\n./hemlock script.hml --verbose --output out.txt input.txt\n./hemlock script.hml -v -o out.txt input.txt\n```\n\n### 布尔标志\n\n```hemlock\nlet debug = false;\nlet verbose = false;\nlet force = false;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--debug\") {\n        debug = true;\n    } else if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else if (args[i] == \"--force\") {\n        force = true;\n    }\n    i = i + 1;\n}\n```\n\n### 值参数\n\n```hemlock\nlet config_file = \"default.conf\";\nlet port = 8080;\n\nlet i = 1;\nwhile (i < args.length) {\n    if (args[i] == \"--config\") {\n        i = i + 1;\n        if (i < args.length) {\n            config_file = args[i];\n        }\n    } else if (args[i] == \"--port\") {\n        i = i + 1;\n        if (i < args.length) {\n            port = 8080;  // 需要将字符串解析为整数\n        }\n    }\n    i = i + 1;\n}\n```\n\n### 混合位置参数和命名参数\n\n```hemlock\nlet input_file = \"\";\nlet output_file = \"\";\nlet verbose = false;\n\nlet i = 1;\nlet positional = [];\n\nwhile (i < args.length) {\n    if (args[i] == \"--verbose\") {\n        verbose = true;\n    } else {\n        // 作为位置参数处理\n        positional.push(args[i]);\n    }\n    i = i + 1;\n}\n\n// 分配位置参数\nif (positional.length > 0) {\n    input_file = positional[0];\n}\nif (positional.length > 1) {\n    output_file = positional[1];\n}\n```\n\n### 参数解析器辅助函数\n\n```hemlock\nfn parse_args() {\n    let options = {\n        verbose: false,\n        output: \"\",\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            options.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                options.output = args[i];\n            }\n        } else {\n            // 位置参数\n            options.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return options;\n}\n\nlet opts = parse_args();\nprint(\"Verbose: \" + typeof(opts.verbose));\nprint(\"Output: \" + opts.output);\nprint(\"Files: \" + typeof(opts.files.length));\n```\n\n## 最佳实践\n\n### 1. 始终检查参数数量\n\n```hemlock\n// 好的做法\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file>\");\n} else {\n    process_file(args[1]);\n}\n\n// 不好的做法 - 如果没有参数可能会崩溃\nprocess_file(args[1]);  // 如果 args.length == 1 会出错\n```\n\n### 2. 提供用法信息\n\n```hemlock\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <file>\");\n    print(\"Options:\");\n    print(\"  -h, --help     Show help\");\n    print(\"  -v, --verbose  Verbose output\");\n}\n\nif (args.length < 2) {\n    show_usage();\n}\n```\n\n### 3. 验证参数\n\n```hemlock\nfn validate_args() {\n    if (args.length < 2) {\n        print(\"Error: Missing required argument\");\n        return false;\n    }\n\n    if (args[1] == \"\") {\n        print(\"Error: Empty argument\");\n        return false;\n    }\n\n    return true;\n}\n\nif (!validate_args()) {\n    // 退出或显示用法\n}\n```\n\n### 4. 使用描述性变量名\n\n```hemlock\n// 好的做法\nlet input_filename = args[1];\nlet output_filename = args[2];\nlet max_iterations = args[3];\n\n// 不好的做法\nlet a = args[1];\nlet b = args[2];\nlet c = args[3];\n```\n\n### 5. 处理带空格的引号参数\n\nShell 会自动处理：\n\n```bash\n./hemlock script.hml \"file with spaces.txt\"\n```\n\n```hemlock\nprint(args[1]);  // \"file with spaces.txt\"\n```\n\n### 6. 创建参数对象\n\n```hemlock\nfn get_args() {\n    return {\n        script: args[0],\n        input: args[1],\n        output: args[2]\n    };\n}\n\nlet arguments = get_args();\nprint(\"Input: \" + arguments.input);\n```\n\n## 完整示例\n\n### 示例 1：文件处理器\n\n```hemlock\n// 用法: ./hemlock process.hml <input> <output>\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <input_file> <output_file>\");\n}\n\nif (args.length < 3) {\n    show_usage();\n} else {\n    let input = args[1];\n    let output = args[2];\n\n    print(\"Processing \" + input + \" -> \" + output);\n\n    // 处理文件\n    let f_in = open(input, \"r\");\n    let f_out = open(output, \"w\");\n\n    try {\n        let content = f_in.read();\n        let processed = content.to_upper();  // 示例处理\n        f_out.write(processed);\n\n        print(\"Done!\");\n    } finally {\n        f_in.close();\n        f_out.close();\n    }\n}\n```\n\n### 示例 2：批量文件处理器\n\n```hemlock\n// 用法: ./hemlock batch.hml <file1> <file2> <file3> ...\n\nif (args.length < 2) {\n    print(\"Usage: \" + args[0] + \" <file1> [file2] [file3] ...\");\n} else {\n    print(\"Processing \" + typeof(args.length - 1) + \" files:\");\n\n    let i = 1;\n    while (i < args.length) {\n        let filename = args[i];\n        print(\"  Processing: \" + filename);\n\n        try {\n            let f = open(filename, \"r\");\n            let content = f.read();\n            f.close();\n\n            // 处理内容...\n            print(\"    \" + typeof(content.length) + \" bytes\");\n        } catch (e) {\n            print(\"    Error: \" + e);\n        }\n\n        i = i + 1;\n    }\n\n    print(\"Done!\");\n}\n```\n\n### 示例 3：高级参数解析器\n\n```hemlock\n// 用法: ./hemlock app.hml [OPTIONS] <files...>\n// 选项:\n//   --verbose, -v     启用详细输出\n//   --output, -o FILE 设置输出文件\n//   --help, -h        显示帮助\n\nfn parse_arguments() {\n    let config = {\n        verbose: false,\n        output: \"output.txt\",\n        help: false,\n        files: []\n    };\n\n    let i = 1;\n    while (i < args.length) {\n        let arg = args[i];\n\n        if (arg == \"--verbose\" || arg == \"-v\") {\n            config.verbose = true;\n        } else if (arg == \"--output\" || arg == \"-o\") {\n            i = i + 1;\n            if (i < args.length) {\n                config.output = args[i];\n            } else {\n                print(\"Error: --output requires a value\");\n            }\n        } else if (arg == \"--help\" || arg == \"-h\") {\n            config.help = true;\n        } else if (arg.starts_with(\"--\")) {\n            print(\"Error: Unknown option: \" + arg);\n        } else {\n            config.files.push(arg);\n        }\n\n        i = i + 1;\n    }\n\n    return config;\n}\n\nfn show_help() {\n    print(\"Usage: \" + args[0] + \" [OPTIONS] <files...>\");\n    print(\"Options:\");\n    print(\"  --verbose, -v     Enable verbose output\");\n    print(\"  --output, -o FILE Set output file\");\n    print(\"  --help, -h        Show this help\");\n}\n\nlet config = parse_arguments();\n\nif (config.help) {\n    show_help();\n} else if (config.files.length == 0) {\n    print(\"Error: No input files specified\");\n    show_help();\n} else {\n    if (config.verbose) {\n        print(\"Verbose mode enabled\");\n        print(\"Output file: \" + config.output);\n        print(\"Input files: \" + typeof(config.files.length));\n    }\n\n    // 处理文件\n    for (let file in config.files) {\n        if (config.verbose) {\n            print(\"Processing: \" + file);\n        }\n        // ... 处理文件\n    }\n}\n```\n\n### 示例 4：配置工具\n\n```hemlock\n// 用法: ./hemlock config.hml <action> [arguments]\n// 操作:\n//   get <key>\n//   set <key> <value>\n//   list\n\nfn show_usage() {\n    print(\"Usage: \" + args[0] + \" <action> [arguments]\");\n    print(\"Actions:\");\n    print(\"  get <key>         Get configuration value\");\n    print(\"  set <key> <value> Set configuration value\");\n    print(\"  list              List all configuration\");\n}\n\nif (args.length < 2) {\n    show_usage();\n} else {\n    let action = args[1];\n\n    if (action == \"get\") {\n        if (args.length < 3) {\n            print(\"Error: 'get' requires a key\");\n        } else {\n            let key = args[2];\n            print(\"Getting: \" + key);\n            // ... 从配置获取\n        }\n    } else if (action == \"set\") {\n        if (args.length < 4) {\n            print(\"Error: 'set' requires key and value\");\n        } else {\n            let key = args[2];\n            let value = args[3];\n            print(\"Setting \" + key + \" = \" + value);\n            // ... 设置配置\n        }\n    } else if (action == \"list\") {\n        print(\"Listing all configuration:\");\n        // ... 列出配置\n    } else {\n        print(\"Error: Unknown action: \" + action);\n        show_usage();\n    }\n}\n```\n\n## 总结\n\nHemlock 的命令行参数支持提供：\n\n- 全局可用的内置 `args` 数组\n- 简单的基于数组的参数访问\n- 脚本名称在 `args[0]`\n- 所有参数都是字符串\n- 可用的数组方法（.length、.slice 等）\n\n请记住：\n- 访问元素前始终检查 `args.length`\n- `args[0]` 是脚本名称\n- 实际参数从 `args[1]` 开始\n- 所有参数都是字符串 - 根据需要转换\n- 为用户友好的工具提供用法信息\n- 处理前验证参数\n\n常见模式：\n- 简单位置参数\n- 命名/标志参数（--flag）\n- 值参数（--option value）\n- 帮助信息（--help）\n- 参数验证\n"}, "高级主题 -> 异步与并发": {"id": "advanced-async-concurrency", "content": "# Hemlock 异步/并发编程\n\nHemlock 提供**结构化并发**，支持 async/await 语法、任务生成和通道通信。实现基于 POSIX 线程（pthreads），实现**真正的多线程并行**。\n\n## 目录\n\n- [概述](#概述)\n- [线程模型](#线程模型)\n- [异步函数](#异步函数)\n- [任务生成](#任务生成)\n- [通道](#通道)\n- [异常传播](#异常传播)\n- [实现细节](#实现细节)\n- [最佳实践](#最佳实践)\n- [性能特性](#性能特性)\n- [当前限制](#当前限制)\n\n## 概述\n\n**这意味着：**\n- 真正的操作系统线程 - 每个生成的任务运行在独立的 pthread（POSIX 线程）上\n- 真正的并行 - 任务在多个 CPU 核心上同时执行\n- 内核调度 - 操作系统调度器将任务分配到可用的核心上\n- 线程安全的通道 - 使用 pthread 互斥锁和条件变量进行同步\n\n**这不是：**\n- 不是绿色线程 - 不是用户空间的协作式多任务\n- 不是 async/await 协程 - 不是像 JavaScript/Python asyncio 那样的单线程事件循环\n- 不是模拟并发 - 不是模拟的并行\n\n这与 **C、C++ 和 Rust** 使用操作系统线程时的**线程模型相同**。你可以获得跨多个核心的真正并行执行。\n\n## 线程模型\n\n### 1:1 线程模型\n\nHemlock 使用 **1:1 线程模型**，其中：\n- 每个生成的任务通过 `pthread_create()` 创建专用的操作系统线程\n- 操作系统内核在可用的 CPU 核心间调度线程\n- 抢占式多任务 - 操作系统可以中断并在线程之间切换\n- **无 GIL** - 不像 Python，没有全局解释器锁限制并行性\n\n### 同步机制\n\n- **互斥锁** - 通道使用 `pthread_mutex_t` 实现线程安全访问\n- **条件变量** - 阻塞的发送/接收使用 `pthread_cond_t` 实现高效等待\n- **无锁操作** - 任务状态转换是原子的\n\n## 异步函数\n\n函数可以声明为 `async`，表示它们设计用于并发执行：\n\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n```\n\n### 要点\n\n- `async fn` 声明异步函数\n- 异步函数可以使用 `spawn()` 作为并发任务生成\n- 异步函数也可以直接调用（在当前线程同步运行）\n- 生成时，每个任务运行在**自己的操作系统线程**上（不是协程！）\n- `await` 关键字保留供将来使用\n\n### 示例：直接调用 vs 生成\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// 直接调用 - 同步运行\nlet result1 = factorial(5);  // 120\n\n// 生成任务 - 在独立线程上运行\nlet task = spawn(factorial, 5);\nlet result2 = join(task);  // 120\n```\n\n## 任务生成\n\n使用 `spawn()` 在**独立的操作系统线程上并行**运行异步函数：\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// 生成多个任务 - 这些在不同的 CPU 核心上并行运行！\nlet t1 = spawn(factorial, 5);  // 线程 1\nlet t2 = spawn(factorial, 6);  // 线程 2\nlet t3 = spawn(factorial, 7);  // 线程 3\n\n// 三个任务现在正在同时计算！\n\n// 等待结果\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\n```\n\n### 内置函数\n\n#### spawn(async_fn, arg1, arg2, ...)\n\n在新的 pthread 上创建新任务，返回任务句柄。\n\n**参数：**\n- `async_fn` - 要执行的异步函数\n- `arg1, arg2, ...` - 传递给函数的参数\n\n**返回：** 任务句柄（与 `join()` 或 `detach()` 一起使用的不透明值）\n\n**示例：**\n```hemlock\nasync fn process(data: string, count: i32): i32 {\n    // ... 处理逻辑\n    return count * 2;\n}\n\nlet task = spawn(process, \"test\", 42);\n```\n\n#### join(task)\n\n等待任务完成（阻塞直到线程结束），返回结果。\n\n**参数：**\n- `task` - 从 `spawn()` 返回的任务句柄\n\n**返回：** 异步函数返回的值\n\n**示例：**\n```hemlock\nlet task = spawn(compute, 1000);\nlet result = join(task);  // 阻塞直到 compute() 完成\nprint(result);\n```\n\n**重要：** 每个任务只能 join 一次。后续的 join 将会报错。\n\n#### detach(task)\n\n即发即忘执行（线程独立运行，不允许 join）。\n\n**参数：**\n- `task` - 从 `spawn()` 返回的任务句柄\n\n**返回：** `null`\n\n**示例：**\n```hemlock\nasync fn background_work() {\n    // 长时间运行的后台任务\n    // ...\n}\n\nlet task = spawn(background_work);\ndetach(task);  // 任务独立运行，无法 join\n```\n\n**重要：** 分离的任务无法 join。当任务完成时，pthread 和 Task 结构都会自动清理。\n\n## 通道\n\n通道使用有界缓冲区和阻塞语义，提供任务间的线程安全通信。\n\n### 创建通道\n\n```hemlock\nlet ch = channel(10);  // 创建缓冲区大小为 10 的通道\n```\n\n**参数：**\n- `capacity` (i32) - 通道可容纳的最大值数量\n\n**返回：** 通道对象\n\n### 通道方法\n\n#### send(value)\n\n向通道发送值（如果已满则阻塞）。\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet task = spawn(producer, ch, 5);\n```\n\n**行为：**\n- 如果通道有空间，值会立即添加\n- 如果通道已满，发送者阻塞直到有空间可用\n- 如果通道已关闭，抛出异常\n\n#### recv()\n\n从通道接收值（如果为空则阻塞）。\n\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet task = spawn(consumer, ch, 5);\n```\n\n**行为：**\n- 如果通道有值，立即返回下一个值\n- 如果通道为空，接收者阻塞直到有值可用\n- 如果通道已关闭且为空，返回 `null`\n\n#### close()\n\n关闭通道（在已关闭的通道上 recv 返回 null）。\n\n```hemlock\nch.close();\n```\n\n**行为：**\n- 阻止进一步的 `send()` 操作（将抛出异常）\n- 允许挂起的 `recv()` 操作完成\n- 一旦为空，`recv()` 返回 `null`\n\n### 使用 select() 多路复用\n\n`select()` 函数允许同时等待多个通道，当任何通道有数据可用时返回。\n\n**签名：**\n```hemlock\nselect(channels: array, timeout_ms?: i32): object | null\n```\n\n**参数：**\n- `channels` - 通道值数组\n- `timeout_ms`（可选）- 超时毫秒数（-1 或省略表示无限等待）\n\n**返回：**\n- `{ channel, value }` - 包含有数据的通道和接收到的值的对象\n- `null` - 超时时（如果指定了超时）\n\n**示例：**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// 生产者任务\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"from channel 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"from channel 2\");\n});\n\n// 等待第一个结果（ch2 应该更快）\nlet result = select([ch1, ch2]);\nprint(result.value);  // \"from channel 2\"\n\n// 等待第二个结果\nlet result2 = select([ch1, ch2]);\nprint(result2.value);  // \"from channel 1\"\n```\n\n**带超时：**\n```hemlock\nlet ch = channel(1);\n\n// 没有发送者，将超时\nlet result = select([ch], 100);  // 100ms 超时\nif (result == null) {\n    print(\"Timed out!\");\n}\n```\n\n**使用场景：**\n- 等待多个数据源中最快的一个\n- 在通道操作上实现超时\n- 具有多个事件源的事件循环模式\n- 扇入：将多个通道合并为一个\n\n**扇入模式：**\n```hemlock\nfn fan_in(channels: array, output: channel) {\n    while (true) {\n        let result = select(channels);\n        if (result == null) {\n            break;  // 所有通道已关闭\n        }\n        output.send(result.value);\n    }\n    output.close();\n}\n```\n\n### 完整的生产者-消费者示例\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// 创建带缓冲区大小的通道\nlet ch = channel(10);\n\n// 生成生产者和消费者\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// 等待完成\njoin(p);\nlet total = join(c);  // 100 (0+10+20+30+40)\nprint(total);\n```\n\n### 多生产者，多消费者\n\n通道可以在多个生产者和消费者之间安全共享：\n\n```hemlock\nasync fn producer(id: i32, ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(id * 100 + i);\n        i = i + 1;\n    }\n}\n\nasync fn consumer(id: i32, ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(20);\n\n// 多个生产者\nlet p1 = spawn(producer, 1, ch, 5);\nlet p2 = spawn(producer, 2, ch, 5);\n\n// 多个消费者\nlet c1 = spawn(consumer, 1, ch, 5);\nlet c2 = spawn(consumer, 2, ch, 5);\n\n// 等待所有\njoin(p1);\njoin(p2);\nlet sum1 = join(c1);\nlet sum2 = join(c2);\nprint(sum1 + sum2);\n```\n\n## 异常传播\n\n在生成的任务中抛出的异常会在 join 时传播：\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Caught: \" + e);  // \"Caught: Task failed!\"\n}\n```\n\n### 异常处理模式\n\n**模式 1：在任务中处理**\n```hemlock\nasync fn safe_task() {\n    try {\n        // 有风险的操作\n    } catch (e) {\n        print(\"Error in task: \" + e);\n        return null;\n    }\n}\n\nlet task = spawn(safe_task);\njoin(task);  // 没有异常传播\n```\n\n**模式 2：传播给调用者**\n```hemlock\nasync fn task_that_throws() {\n    throw \"error\";\n}\n\nlet task = spawn(task_that_throws);\ntry {\n    join(task);\n} catch (e) {\n    print(\"Caught from task: \" + e);\n}\n```\n\n**模式 3：带异常的分离任务**\n```hemlock\nasync fn detached_task() {\n    try {\n        // 工作\n    } catch (e) {\n        // 必须在内部处理 - 无法传播\n        print(\"Error: \" + e);\n    }\n}\n\nlet task = spawn(detached_task);\ndetach(task);  // 无法从分离的任务捕获异常\n```\n\n## 实现细节\n\n### 线程架构\n\n- **1:1 线程** - 每个生成的任务通过 `pthread_create()` 创建专用的操作系统线程\n- **内核调度** - 操作系统内核在可用的 CPU 核心间调度线程\n- **抢占式多任务** - 操作系统可以中断并在线程之间切换\n- **无 GIL** - 不像 Python，没有全局解释器锁限制并行性\n\n### 通道实现\n\n通道使用带 pthread 同步的循环缓冲区：\n\n```\n通道结构：\n- buffer[] - 固定大小的 Values 数组\n- capacity - 最大元素数\n- size - 当前元素数\n- head - 读取位置\n- tail - 写入位置\n- mutex - pthread_mutex_t 用于线程安全访问\n- not_empty - pthread_cond_t 用于阻塞 recv\n- not_full - pthread_cond_t 用于阻塞 send\n- closed - 布尔标志\n- refcount - 用于清理的引用计数\n```\n\n**阻塞行为：**\n- 在满通道上 `send()`：等待 `not_full` 条件变量\n- 在空通道上 `recv()`：等待 `not_empty` 条件变量\n- 两者都由相反的操作在适当时发出信号\n\n### 内存和清理\n\n- **已 join 的任务：** 在 `join()` 返回后自动清理\n- **分离的任务：** 在任务完成时自动清理\n- **通道：** 引用计数，不再使用时释放\n\n## 最佳实践\n\n### 1. 始终关闭通道\n\n```hemlock\nasync fn producer(ch) {\n    // ... 发送值\n    ch.close();  // 重要：表示没有更多的值\n}\n```\n\n### 2. 使用结构化并发\n\n在同一作用域中生成任务并 join 它们：\n\n```hemlock\nfn process_data(data) {\n    // 生成任务\n    let t1 = spawn(worker, data);\n    let t2 = spawn(worker, data);\n\n    // 返回前始终 join\n    let r1 = join(t1);\n    let r2 = join(t2);\n\n    return r1 + r2;\n}\n```\n\n### 3. 适当处理异常\n\n```hemlock\nasync fn task() {\n    try {\n        // 有风险的操作\n    } catch (e) {\n        // 记录错误\n        throw e;  // 如果调用者需要知道则重新抛出\n    }\n}\n```\n\n### 4. 使用适当的通道容量\n\n- **小容量（1-10）：** 用于协调/信号\n- **中等容量（10-100）：** 用于一般生产者-消费者\n- **大容量（100+）：** 用于高吞吐量场景\n\n```hemlock\nlet signal_ch = channel(1);      // 协调\nlet work_ch = channel(50);       // 工作队列\nlet buffer_ch = channel(1000);   // 高吞吐量\n```\n\n### 5. 仅在必要时分离\n\n优先使用 `join()` 而不是 `detach()` 以更好地管理资源：\n\n```hemlock\n// 好：Join 并获取结果\nlet task = spawn(work);\nlet result = join(task);\n\n// 仅对真正的即发即忘使用 detach\nlet bg_task = spawn(background_logging);\ndetach(bg_task);  // 将独立运行\n```\n\n## 性能特性\n\n### 真正的并行\n\n- **N 个生成的任务可以同时利用 N 个 CPU 核心**\n- 经验证的加速 - 压力测试显示 CPU 时间 vs 墙钟时间为 8-9 倍（多核工作）\n- 随核心数线性扩展（直到线程数）\n\n### 线程开销\n\n- 每个任务有约 8KB 栈 + pthread 开销\n- 线程创建成本：约 10-20 微秒\n- 上下文切换成本：约 1-5 微秒\n\n### 何时使用异步\n\n**好的使用场景：**\n- 可并行化的 CPU 密集型计算\n- I/O 密集型操作（尽管 I/O 仍然是阻塞的）\n- 独立数据的并发处理\n- 使用通道的流水线架构\n\n**不理想的场景：**\n- 非常短的任务（线程开销占主导）\n- 有大量同步的任务（竞争开销）\n- 单核系统（没有并行性收益）\n\n### 阻塞 I/O 安全\n\n一个任务中的阻塞操作不会阻塞其他任务：\n\n```hemlock\nasync fn reader(filename: string) {\n    let f = open(filename, \"r\");  // 只阻塞此线程\n    let content = f.read();       // 只阻塞此线程\n    f.close();\n    return content;\n}\n\n// 两者并发读取（在不同线程上）\nlet t1 = spawn(reader, \"file1.txt\");\nlet t2 = spawn(reader, \"file2.txt\");\n\nlet c1 = join(t1);\nlet c2 = join(t2);\n```\n\n## 线程安全模型\n\nHemlock 使用**消息传递**并发模型，任务通过通道而不是共享可变状态进行通信。\n\n### 参数隔离\n\n当你生成任务时，**参数会深拷贝**以防止数据竞争：\n\n```hemlock\nasync fn modify_array(arr: array): array {\n    arr.push(999);    // 修改的是副本，不是原始数组\n    arr[0] = -1;\n    return arr;\n}\n\nlet original = [1, 2, 3];\nlet task = spawn(modify_array, original);\nlet modified = join(task);\n\nprint(original.length);  // 3 - 未改变！\nprint(modified.length);  // 4 - 有新元素\n```\n\n**会深拷贝的：**\n- 数组（及所有元素递归）\n- 对象（及所有字段递归）\n- 字符串\n- 缓冲区\n\n**会共享的（保留引用）：**\n- 通道（通信机制 - 故意共享）\n- 任务句柄（用于协调）\n- 函数（代码是不可变的）\n- 文件句柄（操作系统管理并发访问）\n- 套接字句柄（操作系统管理并发访问）\n\n**不能传递的：**\n- 原始指针（`ptr`）- 改用 `buffer`\n\n### 为什么使用消息传递？\n\n这遵循 Hemlock 的\"显式优于隐式\"哲学：\n\n```hemlock\n// 不好：共享可变状态（会导致数据竞争）\nlet counter = { value: 0 };\nlet t1 = spawn(fn() { counter.value = counter.value + 1; });  // 竞争！\nlet t2 = spawn(fn() { counter.value = counter.value + 1; });  // 竞争！\n\n// 好：通过通道的消息传递\nasync fn increment(ch) {\n    let val = ch.recv();\n    ch.send(val + 1);\n}\n\nlet ch = channel(1);\nch.send(0);\nlet t1 = spawn(increment, ch);\njoin(t1);\nlet result = ch.recv();  // 1 - 没有竞争条件\n```\n\n### 引用计数线程安全\n\n所有引用计数操作使用**原子操作**以防止释放后使用错误：\n- `string_retain/release` - 原子\n- `array_retain/release` - 原子\n- `object_retain/release` - 原子\n- `buffer_retain/release` - 原子\n- `function_retain/release` - 原子\n- `channel_retain/release` - 原子\n- `task_retain/release` - 原子\n\n这确保即使值跨线程共享也能安全地进行内存管理。\n\n### 闭包环境访问\n\n任务可以访问闭包环境：\n- 内置函数（`print`、`len` 等）\n- 全局函数定义\n- 常量和变量\n\n闭包环境由每个环境的互斥锁保护，使并发读写线程安全：\n\n```hemlock\nlet x = 10;\n\nasync fn read_closure(): i32 {\n    return x;  // OK：读取闭包变量（线程安全）\n}\n\nasync fn modify_closure() {\n    x = 20;  // OK：写入闭包变量（与互斥锁同步）\n}\n```\n\n**注意：** 虽然并发访问是同步的，但从多个任务修改共享状态仍可能导致逻辑竞争条件（非确定性顺序）。为了可预测的行为，使用通道进行任务通信或使用任务返回值。\n\n如果需要从任务返回数据，使用返回值或通道。\n\n## 当前限制\n\n### 1. 没有工作窃取调度器\n\n每个任务使用 1 个线程，对于许多短任务可能效率不高。\n\n**当前：** 1000 个任务 = 1000 个线程（开销大）\n\n**计划中：** 带工作窃取的线程池以提高效率\n\n### 3. 没有异步 I/O 集成\n\n文件/网络操作仍然阻塞线程：\n\n```hemlock\nasync fn read_file(path: string) {\n    let f = open(path, \"r\");\n    let content = f.read();  // 阻塞线程\n    f.close();\n    return content;\n}\n```\n\n**变通方法：** 使用多线程进行并发 I/O 操作\n\n### 4. 固定通道容量\n\n通道容量在创建时设置，无法调整大小：\n\n```hemlock\nlet ch = channel(10);\n// 无法动态调整到 20\n```\n\n### 5. 通道大小固定\n\n通道缓冲区大小在创建后无法更改。\n\n## 常见模式\n\n### 并行 Map\n\n```hemlock\nasync fn map_worker(ch_in, ch_out, fn_transform) {\n    while (true) {\n        let val = ch_in.recv();\n        if (val == null) { break; }\n\n        let result = fn_transform(val);\n        ch_out.send(result);\n    }\n    ch_out.close();\n}\n\nfn parallel_map(data, fn_transform, workers: i32) {\n    let ch_in = channel(100);\n    let ch_out = channel(100);\n\n    // 生成工作者\n    let tasks = [];\n    let i = 0;\n    while (i < workers) {\n        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));\n        i = i + 1;\n    }\n\n    // 发送数据\n    let i = 0;\n    while (i < data.length) {\n        ch_in.send(data[i]);\n        i = i + 1;\n    }\n    ch_in.close();\n\n    // 收集结果\n    let results = [];\n    let i = 0;\n    while (i < data.length) {\n        results.push(ch_out.recv());\n        i = i + 1;\n    }\n\n    // 等待工作者\n    let i = 0;\n    while (i < tasks.length) {\n        join(tasks[i]);\n        i = i + 1;\n    }\n\n    return results;\n}\n```\n\n### 流水线架构\n\n```hemlock\nasync fn stage1(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val * 2);\n    }\n    output_ch.close();\n}\n\nasync fn stage2(input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n        output_ch.send(val + 10);\n    }\n    output_ch.close();\n}\n\n// 创建流水线\nlet ch1 = channel(10);\nlet ch2 = channel(10);\nlet ch3 = channel(10);\n\nlet s1 = spawn(stage1, ch1, ch2);\nlet s2 = spawn(stage2, ch2, ch3);\n\n// 输入数据\nch1.send(1);\nch1.send(2);\nch1.send(3);\nch1.close();\n\n// 收集输出\nprint(ch3.recv());  // 12 (1 * 2 + 10)\nprint(ch3.recv());  // 14 (2 * 2 + 10)\nprint(ch3.recv());  // 16 (3 * 2 + 10)\n\njoin(s1);\njoin(s2);\n```\n\n### 扇出，扇入\n\n```hemlock\nasync fn worker(id: i32, input_ch, output_ch) {\n    while (true) {\n        let val = input_ch.recv();\n        if (val == null) { break; }\n\n        // 处理值\n        let result = val * id;\n        output_ch.send(result);\n    }\n}\n\nlet input = channel(10);\nlet output = channel(10);\n\n// 扇出：多个工作者\nlet workers = 4;\nlet tasks = [];\nlet i = 0;\nwhile (i < workers) {\n    tasks.push(spawn(worker, i, input, output));\n    i = i + 1;\n}\n\n// 发送工作\nlet i = 0;\nwhile (i < 10) {\n    input.send(i);\n    i = i + 1;\n}\ninput.close();\n\n// 扇入：收集所有结果\nlet results = [];\nlet i = 0;\nwhile (i < 10) {\n    results.push(output.recv());\n    i = i + 1;\n}\n\n// 等待所有工作者\nlet i = 0;\nwhile (i < tasks.length) {\n    join(tasks[i]);\n    i = i + 1;\n}\n```\n\n## 总结\n\nHemlock 的异步/并发模型提供：\n\n- 使用操作系统线程的真正多线程并行\n- 简单的结构化并发原语\n- 线程安全的通道通信\n- 跨任务的异常传播\n- 在多核系统上经验证的性能\n- **参数隔离** - 深拷贝防止数据竞争\n- **原子引用计数** - 跨线程安全的内存管理\n\n这使 Hemlock 适用于：\n- 并行计算\n- 并发 I/O 操作\n- 流水线架构\n- 生产者-消费者模式\n\n同时避免以下复杂性：\n- 手动线程管理\n- 低级同步原语\n- 容易死锁的基于锁的设计\n- 共享可变状态错误\n"}, "高级主题 -> 性能分析": {"id": "advanced-profiling", "content": "# 性能分析\n\nHemlock 包含一个内置的性能分析器，用于 **CPU 时间分析**、**内存跟踪**和**泄漏检测**。分析器帮助识别程序中的性能瓶颈和内存问题。\n\n## 目录\n\n- [概述](#概述)\n- [快速开始](#快速开始)\n- [分析模式](#分析模式)\n- [输出格式](#输出格式)\n- [泄漏检测](#泄漏检测)\n- [理解报告](#理解报告)\n- [火焰图生成](#火焰图生成)\n- [最佳实践](#最佳实践)\n\n---\n\n## 概述\n\n通过 `profile` 子命令访问分析器：\n\n```bash\nhemlock profile [OPTIONS] <FILE>\n```\n\n**主要特性：**\n- **CPU 分析** - 测量每个函数花费的时间（自身时间和总时间）\n- **内存分析** - 跟踪所有分配及其源位置\n- **泄漏检测** - 识别从未释放的内存\n- **多种输出格式** - 文本、JSON 和火焰图兼容的输出\n- **每函数内存统计** - 查看哪些函数分配最多内存\n\n---\n\n## 快速开始\n\n### 分析 CPU 时间（默认）\n\n```bash\nhemlock profile script.hml\n```\n\n### 分析内存分配\n\n```bash\nhemlock profile --memory script.hml\n```\n\n### 检测内存泄漏\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n### 生成火焰图数据\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\nflamegraph.pl profile.folded > profile.svg\n```\n\n---\n\n## 分析模式\n\n### CPU 分析（默认）\n\n测量每个函数花费的时间，区分：\n- **自身时间** - 执行函数自身代码花费的时间\n- **总时间** - 自身时间加上调用的函数花费的时间\n\n```bash\nhemlock profile script.hml\nhemlock profile --cpu script.hml  # 显式指定\n```\n\n**示例输出：**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 1.234ms\nFunctions called: 5 unique\n\n--- Top 5 by Self Time ---\n\nFunction                        Self      Total   Calls\n--------                        ----      -----   -----\nexpensive_calc              0.892ms    0.892ms     100  (72.3%)\nprocess_data                0.234ms    1.126ms      10  (19.0%)\nhelper                      0.067ms    0.067ms     500  (5.4%)\nmain                        0.041ms    1.234ms       1  (3.3%)\n```\n\n---\n\n### 内存分析\n\n跟踪所有内存分配（`alloc`、`buffer`、`talloc`、`realloc`）及其源位置。\n\n```bash\nhemlock profile --memory script.hml\n```\n\n**示例输出：**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 0.543ms\nFunctions called: 3 unique\nTotal allocations: 15 (4.2KB)\n\n--- Top 3 by Self Time ---\n\nFunction                        Self      Total   Calls      Alloc      Count\n--------                        ----      -----   -----      -----      -----\nallocator                   0.312ms    0.312ms      10      3.2KB         10  (57.5%)\nbuffer_ops                  0.156ms    0.156ms       5       1KB          5  (28.7%)\nmain                        0.075ms    0.543ms       1        0B          0  (13.8%)\n\n--- Top 10 Allocation Sites ---\n\nLocation                                      Total    Count\n--------                                      -----    -----\nsrc/data.hml:42                               1.5KB        5\nsrc/data.hml:67                               1.0KB       10\nsrc/main.hml:15                               512B         1\n```\n\n---\n\n### 调用计数模式\n\n最小开销模式，仅计算函数调用（无计时）。\n\n```bash\nhemlock profile --calls script.hml\n```\n\n---\n\n## 输出格式\n\n### 文本（默认）\n\n带表格的人类可读摘要。\n\n```bash\nhemlock profile script.hml\n```\n\n---\n\n### JSON\n\n机器可读格式，用于与其他工具集成。\n\n```bash\nhemlock profile --json script.hml\n```\n\n**示例输出：**\n```json\n{\n  \"total_time_ns\": 1234567,\n  \"function_count\": 5,\n  \"total_alloc_bytes\": 4096,\n  \"total_alloc_count\": 15,\n  \"functions\": [\n    {\n      \"name\": \"expensive_calc\",\n      \"source_file\": \"script.hml\",\n      \"line\": 10,\n      \"self_time_ns\": 892000,\n      \"total_time_ns\": 892000,\n      \"call_count\": 100,\n      \"alloc_bytes\": 0,\n      \"alloc_count\": 0\n    }\n  ],\n  \"alloc_sites\": [\n    {\n      \"source_file\": \"script.hml\",\n      \"line\": 42,\n      \"total_bytes\": 1536,\n      \"alloc_count\": 5,\n      \"current_bytes\": 0\n    }\n  ]\n}\n```\n\n---\n\n### 火焰图\n\n生成与 [flamegraph.pl](https://github.com/brendangregg/FlameGraph) 兼容的折叠栈格式。\n\n```bash\nhemlock profile --flamegraph script.hml > profile.folded\n\n# 使用 flamegraph.pl 生成 SVG\nflamegraph.pl profile.folded > profile.svg\n```\n\n**折叠输出示例：**\n```\nmain;process_data;expensive_calc 892\nmain;process_data;helper 67\nmain;process_data 234\nmain 41\n```\n\n---\n\n## 泄漏检测\n\n`--leaks` 标志仅显示从未释放的分配，使内存泄漏的识别变得容易。\n\n```bash\nhemlock profile --leaks script.hml\n```\n\n**有泄漏的示例程序：**\n```hemlock\nfn leaky() {\n    let p1 = alloc(100);    // 泄漏 - 从未释放\n    let p2 = alloc(200);    // OK - 下面释放了\n    free(p2);\n}\n\nfn clean() {\n    let b = buffer(64);\n    free(b);                // 正确释放\n}\n\nleaky();\nclean();\n```\n\n**带 --leaks 的输出：**\n```\n=== Hemlock Profiler Report ===\n\nTotal time: 0.034ms\nFunctions called: 2 unique\nTotal allocations: 3 (388B)\n\n--- Top 2 by Self Time ---\n\nFunction                        Self      Total   Calls      Alloc      Count\n--------                        ----      -----   -----      -----      -----\nleaky                       0.021ms    0.021ms       1       300B          2  (61.8%)\nclean                       0.013ms    0.013ms       1        88B          1  (38.2%)\n\n--- Memory Leaks (1 site) ---\n\nLocation                                     Leaked      Total    Count\n--------                                     ------      -----    -----\nscript.hml:2                                   100B       100B        1\n```\n\n泄漏报告显示：\n- **Leaked** - 程序退出时当前未释放的字节\n- **Total** - 在此位置曾经分配的总字节\n- **Count** - 在此位置的分配次数\n\n---\n\n## 理解报告\n\n### 函数统计\n\n| 列 | 描述 |\n|------|------|\n| Function | 函数名 |\n| Self | 函数中花费的时间（不包括被调用者） |\n| Total | 包括所有被调用函数的时间 |\n| Calls | 函数被调用的次数 |\n| Alloc | 此函数分配的总字节数 |\n| Count | 此函数的分配次数 |\n| (%) | 占程序总时间的百分比 |\n\n### 分配位置\n\n| 列 | 描述 |\n|------|------|\n| Location | 源文件和行号 |\n| Total | 在此位置分配的总字节数 |\n| Count | 分配次数 |\n| Leaked | 程序退出时仍分配的字节（仅 --leaks） |\n\n### 时间单位\n\n分析器自动选择适当的单位：\n- `ns` - 纳秒（< 1微秒）\n- `us` - 微秒（< 1毫秒）\n- `ms` - 毫秒（< 1秒）\n- `s` - 秒\n\n---\n\n## 命令参考\n\n```\nhemlock profile [OPTIONS] <FILE>\n\nOPTIONS:\n    --cpu           CPU/时间分析（默认）\n    --memory        内存分配分析\n    --calls         仅调用计数（最小开销）\n    --leaks         仅显示未释放的分配（隐含 --memory）\n    --json          以 JSON 格式输出\n    --flamegraph    以火焰图兼容格式输出\n    --top N         显示前 N 条记录（默认：20）\n```\n\n---\n\n## 火焰图生成\n\n火焰图可视化程序花费时间的位置，较宽的条表示花费更多时间。\n\n### 生成火焰图\n\n1. 安装 flamegraph.pl：\n   ```bash\n   git clone https://github.com/brendangregg/FlameGraph\n   ```\n\n2. 分析你的程序：\n   ```bash\n   hemlock profile --flamegraph script.hml > profile.folded\n   ```\n\n3. 生成 SVG：\n   ```bash\n   ./FlameGraph/flamegraph.pl profile.folded > profile.svg\n   ```\n\n4. 在浏览器中打开 `profile.svg` 获得交互式可视化。\n\n### 阅读火焰图\n\n- **X 轴**：总时间的百分比（宽度 = 时间比例）\n- **Y 轴**：调用栈深度（底部 = 入口点，顶部 = 叶函数）\n- **颜色**：随机，仅用于视觉区分\n- **点击**：放大一个函数以查看其被调用者\n\n---\n\n## 最佳实践\n\n### 1. 分析代表性工作负载\n\n使用真实数据和使用模式进行分析。小的测试用例可能无法揭示真正的瓶颈。\n\n```bash\n# 好：使用类似生产的数据进行分析\nhemlock profile --memory process_large_file.hml large_input.txt\n\n# 不太有用：微小的测试用例\nhemlock profile quick_test.hml\n```\n\n### 2. 在开发过程中使用 --leaks\n\n定期运行泄漏检测以尽早发现内存泄漏：\n\n```bash\nhemlock profile --leaks my_program.hml\n```\n\n### 3. 优化前后对比\n\n在优化前后进行分析以测量影响：\n\n```bash\n# 优化前\nhemlock profile --json script.hml > before.json\n\n# 优化后\nhemlock profile --json script.hml > after.json\n\n# 比较结果\n```\n\n### 4. 对大型程序使用 --top\n\n限制输出以关注最重要的函数：\n\n```bash\nhemlock profile --top 10 large_program.hml\n```\n\n### 5. 结合火焰图使用\n\n对于复杂的调用模式，火焰图提供比文本输出更好的可视化：\n\n```bash\nhemlock profile --flamegraph complex_app.hml > app.folded\nflamegraph.pl app.folded > app.svg\n```\n\n---\n\n## 分析器开销\n\n分析器会给程序执行增加一些开销：\n\n| 模式 | 开销 | 用例 |\n|------|------|------|\n| `--calls` | 最小 | 仅计算函数调用 |\n| `--cpu` | 低 | 一般性能分析 |\n| `--memory` | 中等 | 内存分析和泄漏检测 |\n\n为了获得最准确的结果，多次分析并寻找一致的模式。\n\n---\n\n## 另请参阅\n\n- [内存管理](#language-guide-memory) - 指针和缓冲区\n- [内存 API](#reference-memory-api) - alloc、free、buffer 函数\n- [异步/并发](#advanced-async-concurrency) - 分析异步代码\n"}, "高级主题 -> 打包与发布": {"id": "advanced-bundling-packaging", "content": "# 打包与分发\n\nHemlock 提供内置工具，可将多文件项目打包成单个可分发文件并创建独立的可执行文件。\n\n## 概述\n\n| 命令 | 输出 | 用例 |\n|------|------|------|\n| `--bundle` | `.hmlc` 或 `.hmlb` | 分发字节码（需要 Hemlock 运行） |\n| `--package` | 可执行文件 | 独立二进制文件（无依赖） |\n| `--compile` | `.hmlc` | 编译单个文件（无导入解析） |\n\n## 打包\n\n打包器从入口点解析所有 `import` 语句，并将它们展平为单个文件。\n\n### 基本用法\n\n```bash\n# 将 app.hml 及其所有导入打包成 app.hmlc\nhemlock --bundle app.hml\n\n# 指定输出路径\nhemlock --bundle app.hml -o dist/app.hmlc\n\n# 创建压缩包（.hmlb）- 更小的文件大小\nhemlock --bundle app.hml --compress -o app.hmlb\n\n# 详细输出（显示解析的模块）\nhemlock --bundle app.hml --verbose\n```\n\n### 输出格式\n\n**`.hmlc`（未压缩）**\n- 序列化的 AST 格式\n- 加载和执行速度快\n- 默认输出格式\n\n**`.hmlb`（压缩）**\n- zlib 压缩的 `.hmlc`\n- 文件大小更小（通常减少 50-70%）\n- 由于解压缩，启动稍慢\n\n### 运行打包文件\n\n```bash\n# 运行未压缩包\nhemlock app.hmlc\n\n# 运行压缩包\nhemlock app.hmlb\n\n# 传递参数\nhemlock app.hmlc arg1 arg2\n```\n\n### 示例：多模块项目\n\n```\nmyapp/\n├── main.hml\n├── lib/\n│   ├── math.hml\n│   └── utils.hml\n└── config.hml\n```\n\n```hemlock\n// main.hml\nimport { add, multiply } from \"./lib/math.hml\";\nimport { log } from \"./lib/utils.hml\";\nimport { VERSION } from \"./config.hml\";\n\nlog(`App v${VERSION}`);\nprint(add(2, 3));\n```\n\n```bash\nhemlock --bundle myapp/main.hml -o myapp.hmlc\nhemlock myapp.hmlc  # 运行时所有依赖都已打包\n```\n\n### stdlib 导入\n\n打包器自动解析 `@stdlib/` 导入：\n\n```hemlock\nimport { HashMap } from \"@stdlib/collections\";\nimport { now } from \"@stdlib/time\";\n```\n\n打包时，stdlib 模块会包含在输出中。\n\n## 封装\n\n封装通过将打包的字节码嵌入 Hemlock 解释器副本来创建独立的可执行文件。\n\n### 基本用法\n\n```bash\n# 从 app.hml 创建可执行文件\nhemlock --package app.hml\n\n# 指定输出名称\nhemlock --package app.hml -o myapp\n\n# 跳过压缩（启动更快，文件更大）\nhemlock --package app.hml --no-compress\n\n# 详细输出\nhemlock --package app.hml --verbose\n```\n\n### 运行封装的可执行文件\n\n```bash\n# 封装的可执行文件直接运行\n./myapp\n\n# 参数传递给脚本\n./myapp arg1 arg2\n```\n\n### 封装格式\n\n封装的可执行文件使用 HMLP 格式：\n\n```\n[hemlock 二进制文件][HMLB/HMLC 载荷][payload_size:u64][HMLP 魔数:u32]\n```\n\n当封装的可执行文件运行时：\n1. 检查文件末尾是否有嵌入的载荷\n2. 如果找到，解压缩并执行载荷\n3. 如果未找到，作为普通 Hemlock 解释器运行\n\n### 压缩选项\n\n| 标志 | 格式 | 启动 | 大小 |\n|------|------|------|------|\n| （默认） | HMLB | 正常 | 较小 |\n| `--no-compress` | HMLC | 更快 | 较大 |\n\n对于启动时间重要的 CLI 工具，使用 `--no-compress`。\n\n## 检查包\n\n使用 `--info` 检查打包或编译的文件：\n\n```bash\nhemlock --info app.hmlc\n```\n\n输出：\n```\n=== File Info: app.hmlc ===\nSize: 12847 bytes\nFormat: HMLC (compiled AST)\nVersion: 1\nFlags: 0x0001 [DEBUG]\nStrings: 42\nStatements: 156\n```\n\n```bash\nhemlock --info app.hmlb\n```\n\n输出：\n```\n=== File Info: app.hmlb ===\nSize: 5234 bytes\nFormat: HMLB (compressed bundle)\nVersion: 1\nUncompressed: 12847 bytes\nCompressed: 5224 bytes\nRatio: 59.3% reduction\n```\n\n## 原生编译\n\n要获得真正的原生可执行文件（无解释器），使用 Hemlock 编译器：\n\n```bash\n# 通过 C 编译为原生可执行文件\nhemlockc app.hml -o app\n\n# 保留生成的 C 代码\nhemlockc app.hml -o app --keep-c\n\n# 仅生成 C（不编译）\nhemlockc app.hml -c -o app.c\n\n# 优化级别\nhemlockc app.hml -o app -O2\n```\n\n编译器生成 C 代码并调用 GCC 产生原生二进制文件。这需要：\n- Hemlock 运行时库（`libhemlock_runtime`）\n- C 编译器（默认 GCC）\n\n### 编译器选项\n\n| 选项 | 描述 |\n|------|------|\n| `-o <file>` | 输出可执行文件名 |\n| `-c` | 仅生成 C 代码 |\n| `--emit-c <file>` | 将 C 写入指定文件 |\n| `-k, --keep-c` | 编译后保留生成的 C |\n| `-O<level>` | 优化级别（0-3） |\n| `--cc <path>` | 使用的 C 编译器 |\n| `--runtime <path>` | 运行时库路径 |\n| `-v, --verbose` | 详细输出 |\n\n## 比较\n\n| 方法 | 可移植性 | 启动 | 大小 | 依赖 |\n|------|----------|------|------|------|\n| `.hml` | 仅源码 | 解析时间 | 最小 | Hemlock |\n| `.hmlc` | 仅 Hemlock | 快 | 小 | Hemlock |\n| `.hmlb` | 仅 Hemlock | 快 | 更小 | Hemlock |\n| `--package` | 独立 | 快 | 较大 | 无 |\n| `hemlockc` | 原生 | 最快 | 不定 | 运行时库 |\n\n## 最佳实践\n\n1. **开发**：直接运行 `.hml` 文件以快速迭代\n2. **分发（有 Hemlock）**：使用 `--compress` 打包以获得更小的文件\n3. **分发（独立）**：封装以实现零依赖部署\n4. **性能关键**：使用 `hemlockc` 进行原生编译\n\n## 故障排除\n\n### \"Cannot find stdlib\"\n\n打包器在以下位置查找 stdlib：\n1. `./stdlib`（相对于可执行文件）\n2. `../stdlib`（相对于可执行文件）\n3. `/usr/local/lib/hemlock/stdlib`\n\n确保 Hemlock 已正确安装或从源目录运行。\n\n### 循环依赖\n\n```\nError: Circular dependency detected when loading 'path/to/module.hml'\n```\n\n重构你的导入以打破循环。考虑使用共享模块存放公共类型。\n\n### 封装大小过大\n\n- 使用默认压缩（不要使用 `--no-compress`）\n- 封装大小包含完整解释器（基础约 500KB-1MB）\n- 要获得最小大小，使用 `hemlockc` 进行原生编译\n"}, "API 参考 -> 内存 API": {"id": "reference-memory-api", "content": "# 内存 API 参考\n\nHemlock 内存管理函数和指针类型的完整参考文档。\n\n---\n\n## 概述\n\nHemlock 提供**手动内存管理**，具有显式的分配和释放。内存通过两种指针类型管理：原始指针（`ptr`）和安全缓冲区（`buffer`）。\n\n**核心原则：**\n- 显式分配和释放\n- 无垃圾回收\n- 用户负责调用 `free()`\n- 内部引用计数用于作用域/重新赋值安全（见下文）\n\n### 内部引用计数\n\n运行时内部使用引用计数来管理对象在作用域中的生命周期。对于大多数局部变量，清理是自动的。\n\n**自动（无需 `free()`）：**\n- 引用计数类型（buffer、array、object、string）的局部变量在作用域退出时释放\n- 变量重新赋值时释放旧值\n- 容器释放时释放容器元素\n\n**需要手动 `free()`：**\n- 来自 `alloc()` 的原始指针 - 始终需要\n- 作用域结束前的提前清理\n- 长期存在/全局数据\n\n详见 [内存管理指南](../language-guide/memory.md#internal-reference-counting)。\n\n---\n\n## 指针类型\n\n### ptr（原始指针）\n\n**类型：** `ptr`\n\n**描述：** 原始内存地址，无边界检查或跟踪。\n\n**大小：** 8 字节\n\n**用例：**\n- 底层内存操作\n- FFI（外部函数接口）\n- 最高性能（无开销）\n\n**安全性：** 不安全 - 无边界检查，用户必须跟踪生命周期\n\n**示例：**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n---\n\n### buffer（安全缓冲区）\n\n**类型：** `buffer`\n\n**描述：** 带边界检查的安全指针包装器。\n\n**结构：** 指针 + 长度 + 容量 + 引用计数\n\n**属性：**\n- `.length` - 缓冲区大小 (i32)\n- `.capacity` - 已分配容量 (i32)\n\n**用例：**\n- 大多数内存分配\n- 安全性重要时\n- 动态数组\n\n**安全性：** 索引访问时进行边界检查\n\n**引用计数：** 缓冲区内部进行引用计数。作用域退出或变量重新赋值时自动释放。使用 `free()` 进行提前清理或用于长期存在的数据。\n\n**示例：**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // 边界检查\nprint(b.length);        // 64\nfree(b);\n```\n\n---\n\n## 内存分配函数\n\n### alloc\n\n分配原始内存。\n\n**签名：**\n```hemlock\nalloc(size: i32): ptr\n```\n\n**参数：**\n- `size` - 要分配的字节数\n\n**返回值：** 指向已分配内存的指针 (`ptr`)\n\n**示例：**\n```hemlock\nlet p = alloc(1024);        // 分配 1KB\nmemset(p, 0, 1024);         // 初始化为零\nfree(p);                    // 完成后释放\n\n// 为结构分配\nlet struct_size = 16;\nlet p2 = alloc(struct_size);\n```\n\n**行为：**\n- 返回未初始化的内存\n- 必须手动释放内存\n- 分配失败时返回 `null`（调用者必须检查）\n\n**另请参阅：** `buffer()` 作为更安全的替代方案\n\n---\n\n### buffer\n\n分配带边界检查的安全缓冲区。\n\n**签名：**\n```hemlock\nbuffer(size: i32): buffer\n```\n\n**参数：**\n- `size` - 缓冲区大小（字节）\n\n**返回值：** 缓冲区对象\n\n**示例：**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\nprint(buf.capacity);        // 256\n\n// 带边界检查的访问\nbuf[0] = 65;                // 'A'\nbuf[255] = 90;              // 'Z'\n// buf[256] = 0;            // 错误：越界\n\nfree(buf);\n```\n\n**属性：**\n- `.length` - 当前大小 (i32)\n- `.capacity` - 已分配容量 (i32)\n\n**行为：**\n- 将内存初始化为零\n- 在索引访问时提供边界检查\n- 分配失败时返回 `null`（调用者必须检查）\n- 必须手动释放\n\n---\n\n### free\n\n释放已分配的内存。\n\n**签名：**\n```hemlock\nfree(ptr: ptr | buffer): null\n```\n\n**参数：**\n- `ptr` - 要释放的指针或缓冲区\n\n**返回值：** `null`\n\n**示例：**\n```hemlock\n// 释放原始指针\nlet p = alloc(1024);\nfree(p);\n\n// 释放缓冲区\nlet buf = buffer(256);\nfree(buf);\n```\n\n**行为：**\n- 释放由 `alloc()` 或 `buffer()` 分配的内存\n- 双重释放会导致崩溃（用户有责任避免）\n- 释放无效指针会导致未定义行为\n\n**重要：** 你分配，你释放。没有自动清理。\n\n---\n\n### realloc\n\n调整已分配内存的大小。\n\n**签名：**\n```hemlock\nrealloc(ptr: ptr, new_size: i32): ptr\n```\n\n**参数：**\n- `ptr` - 要调整大小的指针\n- `new_size` - 新大小（字节）\n\n**返回值：** 指向调整大小后内存的指针（可能是不同的地址）\n\n**示例：**\n```hemlock\nlet p = alloc(100);\n// ... 使用内存 ...\n\n// 需要更多空间\np = realloc(p, 200);        // 现在是 200 字节\n// ... 使用扩展的内存 ...\n\nfree(p);\n```\n\n**行为：**\n- 可能将内存移动到新位置\n- 保留现有数据（直到旧/新大小的最小值）\n- 成功 realloc 后旧指针无效（使用返回的指针）\n- 如果 new_size 更小，数据会被截断\n- 分配失败时返回 `null`（原始指针仍然有效）\n\n**重要：** 始终检查 `null` 并用结果更新指针变量。\n\n---\n\n## 内存操作\n\n### memset\n\n用字节值填充内存。\n\n**签名：**\n```hemlock\nmemset(ptr: ptr, byte: i32, size: i32): null\n```\n\n**参数：**\n- `ptr` - 指向内存的指针\n- `byte` - 要填充的字节值 (0-255)\n- `size` - 要填充的字节数\n\n**返回值：** `null`\n\n**示例：**\n```hemlock\nlet p = alloc(100);\n\n// 清零内存\nmemset(p, 0, 100);\n\n// 用特定值填充\nmemset(p, 0xFF, 100);\n\n// 初始化缓冲区\nlet buf = alloc(256);\nmemset(buf, 65, 256);       // 用 'A' 填充\n\nfree(p);\nfree(buf);\n```\n\n**行为：**\n- 将字节值写入范围内的每个字节\n- 字节值截断为 8 位 (0-255)\n- 无边界检查（不安全）\n\n---\n\n### memcpy\n\n从源复制内存到目标。\n\n**签名：**\n```hemlock\nmemcpy(dest: ptr, src: ptr, size: i32): null\n```\n\n**参数：**\n- `dest` - 目标指针\n- `src` - 源指针\n- `size` - 要复制的字节数\n\n**返回值：** `null`\n\n**示例：**\n```hemlock\nlet src = alloc(100);\nlet dest = alloc(100);\n\n// 初始化源\nmemset(src, 65, 100);\n\n// 复制到目标\nmemcpy(dest, src, 100);\n\n// dest 现在包含与 src 相同的数据\n\nfree(src);\nfree(dest);\n```\n\n**行为：**\n- 逐字节从 src 复制到 dest\n- 无边界检查（不安全）\n- 重叠区域行为未定义（小心使用）\n\n---\n\n## 类型化内存操作\n\n### sizeof\n\n获取类型的字节大小。\n\n**签名：**\n```hemlock\nsizeof(type): i32\n```\n\n**参数：**\n- `type` - 类型标识符（例如 `i32`、`f64`、`ptr`）\n\n**返回值：** 字节大小 (i32)\n\n**类型大小：**\n\n| 类型 | 大小（字节）|\n|------|--------------|\n| `i8` | 1 |\n| `i16` | 2 |\n| `i32`、`integer` | 4 |\n| `i64` | 8 |\n| `u8`、`byte` | 1 |\n| `u16` | 2 |\n| `u32` | 4 |\n| `u64` | 8 |\n| `f32` | 4 |\n| `f64`、`number` | 8 |\n| `bool` | 1 |\n| `ptr` | 8 |\n| `rune` | 4 |\n\n**示例：**\n```hemlock\nlet int_size = sizeof(i32);      // 4\nlet ptr_size = sizeof(ptr);      // 8\nlet float_size = sizeof(f64);    // 8\nlet byte_size = sizeof(u8);      // 1\nlet rune_size = sizeof(rune);    // 4\n\n// 计算数组分配大小\nlet count = 100;\nlet total = sizeof(i32) * count; // 400 字节\n```\n\n**行为：**\n- 对未知类型返回 0\n- 接受类型标识符和类型字符串\n\n---\n\n### talloc\n\n分配类型化值数组。\n\n**签名：**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**参数：**\n- `type` - 要分配的类型（例如 `i32`、`f64`、`ptr`）\n- `count` - 元素数量（必须为正数）\n\n**返回值：** 指向已分配数组的指针，分配失败时返回 `null`\n\n**示例：**\n```hemlock\nlet arr = talloc(i32, 100);      // 100 个 i32 的数组（400 字节）\nlet floats = talloc(f64, 50);    // 50 个 f64 的数组（400 字节）\nlet bytes = talloc(u8, 1024);    // 1024 字节的数组\n\n// 始终检查分配失败\nif (arr == null) {\n    panic(\"allocation failed\");\n}\n\n// 使用已分配的内存\n// ...\n\nfree(arr);\nfree(floats);\nfree(bytes);\n```\n\n**行为：**\n- 分配 `sizeof(type) * count` 字节\n- 返回未初始化的内存\n- 必须使用 `free()` 手动释放内存\n- 分配失败时返回 `null`（调用者必须检查）\n- 如果 count 不是正数则 panic\n\n---\n\n## 缓冲区属性\n\n### .length\n\n获取缓冲区大小。\n\n**类型：** `i32`\n\n**访问：** 只读\n\n**示例：**\n```hemlock\nlet buf = buffer(256);\nprint(buf.length);          // 256\n\nlet buf2 = buffer(1024);\nprint(buf2.length);         // 1024\n```\n\n---\n\n### .capacity\n\n获取缓冲区容量。\n\n**类型：** `i32`\n\n**访问：** 只读\n\n**示例：**\n```hemlock\nlet buf = buffer(256);\nprint(buf.capacity);        // 256\n```\n\n**注意：** 目前，对于使用 `buffer()` 创建的缓冲区，`.length` 和 `.capacity` 相同。\n\n---\n\n## 使用模式\n\n### 基本分配模式\n\n```hemlock\n// 分配\nlet p = alloc(1024);\nif (p == null) {\n    panic(\"allocation failed\");\n}\n\n// 使用\nmemset(p, 0, 1024);\n\n// 释放\nfree(p);\n```\n\n### 安全缓冲区模式\n\n```hemlock\n// 分配缓冲区\nlet buf = buffer(256);\nif (buf == null) {\n    panic(\"buffer allocation failed\");\n}\n\n// 带边界检查使用\nlet i = 0;\nwhile (i < buf.length) {\n    buf[i] = i;\n    i = i + 1;\n}\n\n// 释放\nfree(buf);\n```\n\n### 动态增长模式\n\n```hemlock\nlet size = 100;\nlet p = alloc(size);\nif (p == null) {\n    panic(\"allocation failed\");\n}\n\n// ... 使用内存 ...\n\n// 需要更多空间 - 检查失败\nlet new_p = realloc(p, 200);\nif (new_p == null) {\n    // 原始指针仍然有效，清理\n    free(p);\n    panic(\"realloc failed\");\n}\np = new_p;\nsize = 200;\n\n// ... 使用扩展的内存 ...\n\nfree(p);\n```\n\n### 内存复制模式\n\n```hemlock\nlet original = alloc(100);\nmemset(original, 65, 100);\n\n// 创建副本\nlet copy = alloc(100);\nmemcpy(copy, original, 100);\n\nfree(original);\nfree(copy);\n```\n\n---\n\n## 安全注意事项\n\n**Hemlock 内存管理设计上是不安全的：**\n\n### 常见陷阱\n\n**1. 内存泄漏**\n```hemlock\n// 错误：内存泄漏\nfn create_buffer() {\n    let p = alloc(1024);\n    return null;  // 内存泄漏！\n}\n\n// 正确：适当清理\nfn create_buffer() {\n    let p = alloc(1024);\n    // ... 使用内存 ...\n    free(p);\n    return null;\n}\n```\n\n**2. 释放后使用**\n```hemlock\n// 错误：释放后使用\nlet p = alloc(100);\nfree(p);\nmemset(p, 0, 100);  // 崩溃：使用已释放的内存\n\n// 正确：释放后不使用\nlet p2 = alloc(100);\nmemset(p2, 0, 100);\nfree(p2);\n// 此后不要使用 p2\n```\n\n**3. 双重释放**\n```hemlock\n// 错误：双重释放\nlet p = alloc(100);\nfree(p);\nfree(p);  // 崩溃：双重释放\n\n// 正确：只释放一次\nlet p2 = alloc(100);\nfree(p2);\n```\n\n**4. 缓冲区溢出（ptr）**\n```hemlock\n// 错误：ptr 的缓冲区溢出\nlet p = alloc(10);\nmemset(p, 65, 100);  // 崩溃：写入超过分配范围\n\n// 正确：使用 buffer 进行边界检查\nlet buf = buffer(10);\n// buf[100] = 65;  // 错误：边界检查失败\n```\n\n**5. 悬空指针**\n```hemlock\n// 错误：悬空指针\nlet p1 = alloc(100);\nlet p2 = p1;\nfree(p1);\nmemset(p2, 0, 100);  // 崩溃：p2 是悬空的\n\n// 正确：仔细跟踪所有权\nlet p = alloc(100);\n// ... 使用 p ...\nfree(p);\n// 不要保留对 p 的其他引用\n```\n\n**6. 未检查的分配失败**\n```hemlock\n// 错误：不检查 null\nlet p = alloc(1000000000);  // 在低内存时可能失败\nmemset(p, 0, 1000000000);   // 崩溃：p 是 null\n\n// 正确：始终检查分配结果\nlet p2 = alloc(1000000000);\nif (p2 == null) {\n    panic(\"out of memory\");\n}\nmemset(p2, 0, 1000000000);\nfree(p2);\n```\n\n---\n\n## 何时使用什么\n\n### 使用 `buffer()` 当：\n- 需要边界检查时\n- 处理动态数据时\n- 安全性重要时\n- 学习 Hemlock 时\n\n### 使用 `alloc()` 当：\n- 需要最高性能时\n- FFI/与 C 接口时\n- 知道确切的内存布局时\n- 你是专家时\n\n### 使用 `realloc()` 当：\n- 增长/缩小分配时\n- 动态数组\n- 需要保留数据时\n\n---\n\n## 完整函数总结\n\n| 函数      | 签名                                   | 返回值   | 描述                       |\n|-----------|----------------------------------------|----------|----------------------------|\n| `alloc`   | `(size: i32)`                          | `ptr`    | 分配原始内存               |\n| `buffer`  | `(size: i32)`                          | `buffer` | 分配安全缓冲区             |\n| `free`    | `(ptr: ptr \\| buffer)`                 | `null`   | 释放内存                   |\n| `realloc` | `(ptr: ptr, new_size: i32)`            | `ptr`    | 调整分配大小               |\n| `memset`  | `(ptr: ptr, byte: i32, size: i32)`     | `null`   | 填充内存                   |\n| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`     | `null`   | 复制内存                   |\n| `sizeof`  | `(type)`                               | `i32`    | 获取类型字节大小           |\n| `talloc`  | `(type, count: i32)`                   | `ptr`    | 分配类型化数组             |\n\n---\n\n## 另请参阅\n\n- [类型系统](#reference-type-system) - 指针和缓冲区类型\n- [内置函数](#reference-builtins) - 所有内置函数\n- [字符串 API](#reference-string-api) - 字符串 `.to_bytes()` 方法\n"}, "API 参考 -> 内置函数": {"id": "reference-builtins", "content": "# 内置函数参考\n\nHemlock 所有内置函数和常量的完整参考文档。\n\n---\n\n## 概述\n\nHemlock 提供了一组内置函数，用于 I/O、类型自省、内存管理、并发和系统交互。所有内置函数全局可用，无需导入。\n\n---\n\n## I/O 函数\n\n### print\n\n将值打印到标准输出并换行。\n\n**签名：**\n```hemlock\nprint(...values): null\n```\n\n**参数：**\n- `...values` - 任意数量的要打印的值\n\n**返回值：** `null`\n\n**示例：**\n```hemlock\nprint(\"Hello, World!\");\nprint(42);\nprint(3.14);\nprint(true);\nprint([1, 2, 3]);\nprint({ x: 10, y: 20 });\n\n// 多个值\nprint(\"x =\", 10, \"y =\", 20);\n```\n\n**行为：**\n- 将所有值转换为字符串\n- 多个值之间用空格分隔\n- 末尾添加换行符\n- 刷新标准输出\n\n---\n\n### read_line\n\n从标准输入读取一行文本（用户输入）。\n\n**签名：**\n```hemlock\nread_line(): string | null\n```\n\n**参数：** 无\n\n**返回值：**\n- `string` - 从标准输入读取的行（已去除换行符）\n- `null` - 在 EOF（文件结束/输入结束）时\n\n**示例：**\n```hemlock\n// 简单提示\nprint(\"What is your name?\");\nlet name = read_line();\nprint(\"Hello, \" + name + \"!\");\n\n// 读取数字（需要手动解析）\nprint(\"Enter a number:\");\nlet input = read_line();\nlet num = parse_int(input);  // 参见下面的 parse_int\nprint(\"Double:\", num * 2);\n\n// 处理 EOF\nlet line = read_line();\nif (line == null) {\n    print(\"End of input\");\n}\n\n// 读取多行\nprint(\"Enter lines (Ctrl+D to stop):\");\nwhile (true) {\n    let line = read_line();\n    if (line == null) {\n        break;\n    }\n    print(\"You said:\", line);\n}\n```\n\n**行为：**\n- 阻塞直到用户按下回车\n- 去除尾部的换行符（`\\n`）和回车符（`\\r`）\n- 在 EOF 时返回 `null`（Unix 上为 Ctrl+D，Windows 上为 Ctrl+Z）\n- 仅从标准输入读取（不从文件读取）\n\n**解析用户输入：**\n\n由于 `read_line()` 总是返回字符串，你需要手动解析数字输入：\n\n```hemlock\n// 简单的整数解析器\nfn parse_int(s: string): i32 {\n    let result: i32 = 0;\n    let negative = false;\n    let i = 0;\n\n    if (s.length > 0 && s.char_at(0) == '-') {\n        negative = true;\n        i = 1;\n    }\n\n    while (i < s.length) {\n        let c = s.char_at(i);\n        let code: i32 = c;\n        if (code >= 48 && code <= 57) {\n            result = result * 10 + (code - 48);\n        } else {\n            break;\n        }\n        i = i + 1;\n    }\n\n    if (negative) {\n        return -result;\n    }\n    return result;\n}\n\n// 使用\nprint(\"Enter your age:\");\nlet age = parse_int(read_line());\nprint(\"In 10 years you'll be\", age + 10);\n```\n\n**另请参阅：** [文件 API](#reference-file-api) 从文件读取\n\n---\n\n### eprint\n\n将值打印到标准错误并换行。\n\n**签名：**\n```hemlock\neprint(value: any): null\n```\n\n**参数：**\n- `value` - 要打印到标准错误的单个值\n\n**返回值：** `null`\n\n**示例：**\n```hemlock\neprint(\"Error: file not found\");\neprint(404);\neprint(\"Warning: \" + message);\n\n// 典型的错误处理模式\nfn load_config(path: string) {\n    if (!exists(path)) {\n        eprint(\"Error: config file not found: \" + path);\n        return null;\n    }\n    // ...\n}\n```\n\n**行为：**\n- 打印到标准错误（stderr）\n- 末尾添加换行符\n- 只接受一个参数（与 `print` 不同）\n- 适用于不应与正常输出混合的错误消息\n\n**与 print 的区别：**\n- `print()` → stdout（正常输出，可用 `>` 重定向）\n- `eprint()` → stderr（错误输出，可用 `2>` 重定向）\n\n```bash\n# Shell 示例：分离 stdout 和 stderr\n./hemlock script.hml > output.txt 2> errors.txt\n```\n\n---\n\n## 类型自省\n\n### typeof\n\n获取值的类型名称。\n\n**签名：**\n```hemlock\ntypeof(value: any): string\n```\n\n**参数：**\n- `value` - 任意值\n\n**返回值：** 类型名称字符串\n\n**示例：**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof(null));            // \"null\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\n// 类型化对象\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n\n// 其他类型\nprint(typeof(alloc(10)));       // \"ptr\"\nprint(typeof(buffer(10)));      // \"buffer\"\nprint(typeof(open(\"file.txt\"))); // \"file\"\n```\n\n**类型名称：**\n- 基本类型：`\"i8\"`、`\"i16\"`、`\"i32\"`、`\"i64\"`、`\"u8\"`、`\"u16\"`、`\"u32\"`、`\"u64\"`、`\"f32\"`、`\"f64\"`、`\"bool\"`、`\"string\"`、`\"rune\"`、`\"null\"`\n- 复合类型：`\"array\"`、`\"object\"`、`\"ptr\"`、`\"buffer\"`、`\"function\"`\n- 特殊类型：`\"file\"`、`\"task\"`、`\"channel\"`\n- 自定义类型：来自 `define` 的用户定义类型名称\n\n**另请参阅：** [类型系统](#reference-type-system)\n\n---\n\n## 命令执行\n\n### exec\n\n执行 shell 命令并捕获输出。\n\n**签名：**\n```hemlock\nexec(command: string): object\n```\n\n**参数：**\n- `command` - 要执行的 shell 命令\n\n**返回值：** 包含以下字段的对象：\n- `output` (string) - 命令的标准输出\n- `exit_code` (i32) - 退出状态码（0 = 成功）\n\n**示例：**\n```hemlock\nlet result = exec(\"echo hello\");\nprint(result.output);      // \"hello\\n\"\nprint(result.exit_code);   // 0\n\n// 检查退出状态\nlet r = exec(\"grep pattern file.txt\");\nif (r.exit_code == 0) {\n    print(\"Found:\", r.output);\n} else {\n    print(\"Pattern not found\");\n}\n\n// 处理多行输出\nlet r2 = exec(\"ls -la\");\nlet lines = r2.output.split(\"\\n\");\n```\n\n**行为：**\n- 通过 `/bin/sh` 执行命令\n- 仅捕获标准输出（标准错误输出到终端）\n- 阻塞直到命令完成\n- 如果没有输出则返回空字符串\n\n**错误处理：**\n```hemlock\ntry {\n    let r = exec(\"nonexistent_command\");\n} catch (e) {\n    print(\"Failed to execute:\", e);\n}\n```\n\n**安全警告：** 存在 shell 注入风险。始终验证/清理用户输入。\n\n**限制：**\n- 无标准错误捕获\n- 无流式处理\n- 无超时\n- 无信号处理\n\n---\n\n### exec_argv\n\n使用显式参数数组执行命令（无 shell 解释）。\n\n**签名：**\n```hemlock\nexec_argv(argv: array): object\n```\n\n**参数：**\n- `argv` - 字符串数组：`[command, arg1, arg2, ...]`\n\n**返回值：** 包含以下字段的对象：\n- `output` (string) - 命令的标准输出\n- `exit_code` (i32) - 退出状态码（0 = 成功）\n\n**示例：**\n```hemlock\n// 简单命令\nlet result = exec_argv([\"ls\", \"-la\"]);\nprint(result.output);\n\n// 包含空格的参数（安全！）\nlet r = exec_argv([\"grep\", \"hello world\", \"file.txt\"]);\n\n// 带参数运行脚本\nlet r2 = exec_argv([\"python\", \"script.py\", \"--input\", \"data.json\"]);\nprint(r2.exit_code);\n```\n\n**与 exec 的区别：**\n```hemlock\n// exec() 使用 shell - 对用户输入不安全\nexec(\"ls \" + user_input);  // Shell 注入风险！\n\n// exec_argv() 绕过 shell - 安全\nexec_argv([\"ls\", user_input]);  // 不可能注入\n```\n\n**何时使用：**\n- 当参数包含空格、引号或特殊字符时\n- 处理用户输入时（安全性）\n- 当需要可预测的参数解析时\n\n**另请参阅：** 简单 shell 命令使用 `exec()`\n\n---\n\n## 错误处理\n\n### throw\n\n抛出异常。\n\n**签名：**\n```hemlock\nthrow expression\n```\n\n**参数：**\n- `expression` - 要抛出的值（任意类型）\n\n**返回值：** 永不返回（转移控制权）\n\n**示例：**\n```hemlock\nthrow \"error message\";\nthrow 404;\nthrow { code: 500, message: \"Internal error\" };\nthrow null;\n```\n\n**另请参阅：** try/catch/finally 语句\n\n---\n\n### panic\n\n立即终止程序并显示错误消息（不可恢复）。\n\n**签名：**\n```hemlock\npanic(message?: any): never\n```\n\n**参数：**\n- `message`（可选）- 要打印的错误消息\n\n**返回值：** 永不返回（程序退出）\n\n**示例：**\n```hemlock\npanic();                          // 默认：\"panic!\"\npanic(\"unreachable code reached\");\npanic(42);\n\n// 常见用例\nfn process_state(state: i32): string {\n    if (state == 1) { return \"ready\"; }\n    if (state == 2) { return \"running\"; }\n    panic(\"invalid state: \" + typeof(state));\n}\n```\n\n**行为：**\n- 将错误打印到标准错误：`panic: <message>`\n- 以代码 1 退出\n- **不能**用 try/catch 捕获\n- 用于 bug 和不可恢复的错误\n\n**panic 与 throw 的区别：**\n- `panic()` - 不可恢复的错误，立即退出\n- `throw` - 可恢复的错误，可以被捕获\n\n---\n\n### assert\n\n断言条件为真，否则终止并显示错误消息。\n\n**签名：**\n```hemlock\nassert(condition: any, message?: string): null\n```\n\n**参数：**\n- `condition` - 要检查是否为真的值\n- `message`（可选）- 断言失败时的自定义错误消息\n\n**返回值：** `null`（如果断言通过）\n\n**示例：**\n```hemlock\n// 基本断言\nassert(x > 0);\nassert(name != null);\nassert(arr.length > 0, \"Array must not be empty\");\n\n// 带自定义消息\nfn divide(a: i32, b: i32): f64 {\n    assert(b != 0, \"Division by zero\");\n    return a / b;\n}\n\n// 验证函数参数\nfn process_data(data: array) {\n    assert(data != null, \"data cannot be null\");\n    assert(data.length > 0, \"data cannot be empty\");\n    // ...\n}\n```\n\n**行为：**\n- 如果条件为真：返回 `null`，继续执行\n- 如果条件为假：打印错误并以代码 1 退出\n- 假值：`false`、`0`、`0.0`、`null`、`\"\"`（空字符串）\n- 真值：其他所有值\n\n**失败时的输出：**\n```\nAssertion failed: Array must not be empty\n```\n\n**何时使用：**\n- 验证函数前置条件\n- 在开发期间检查不变量\n- 尽早捕获程序员错误\n\n**assert 与 panic 的区别：**\n- `assert(cond, msg)` - 检查条件，如果为假则失败\n- `panic(msg)` - 无条件失败\n\n---\n\n## 信号处理\n\n### signal\n\n注册或重置信号处理程序。\n\n**签名：**\n```hemlock\nsignal(signum: i32, handler: function | null): function | null\n```\n\n**参数：**\n- `signum` - 信号编号（使用 `SIGINT` 等常量）\n- `handler` - 收到信号时调用的函数，或 `null` 重置为默认值\n\n**返回值：** 先前的处理程序函数，或 `null`\n\n**示例：**\n```hemlock\nfn handle_interrupt(sig) {\n    print(\"Caught SIGINT!\");\n}\n\nsignal(SIGINT, handle_interrupt);\n\n// 重置为默认\nsignal(SIGINT, null);\n```\n\n**处理程序签名：**\n```hemlock\nfn handler(signum: i32) {\n    // signum 包含信号编号\n}\n```\n\n**另请参阅：**\n- [信号常量](#信号常量)\n- `raise()`\n\n---\n\n### raise\n\n向当前进程发送信号。\n\n**签名：**\n```hemlock\nraise(signum: i32): null\n```\n\n**参数：**\n- `signum` - 要发送的信号编号\n\n**返回值：** `null`\n\n**示例：**\n```hemlock\nlet count = 0;\n\nfn increment(sig) {\n    count = count + 1;\n}\n\nsignal(SIGUSR1, increment);\n\nraise(SIGUSR1);\nraise(SIGUSR1);\nprint(count);  // 2\n```\n\n---\n\n## 全局变量\n\n### args\n\n命令行参数数组。\n\n**类型：** 字符串 `array`\n\n**结构：**\n- `args[0]` - 脚本文件名\n- `args[1..n]` - 命令行参数\n\n**示例：**\n```bash\n# 命令：./hemlock script.hml hello world\n```\n\n```hemlock\nprint(args[0]);        // \"script.hml\"\nprint(args.length);    // 3\nprint(args[1]);        // \"hello\"\nprint(args[2]);        // \"world\"\n\n// 遍历参数\nlet i = 1;\nwhile (i < args.length) {\n    print(\"Argument\", i, \":\", args[i]);\n    i = i + 1;\n}\n```\n\n**REPL 行为：** 在 REPL 中，`args.length` 为 0（空数组）\n\n---\n\n## 信号常量\n\n标准 POSIX 信号常量（i32 值）：\n\n### 中断和终止\n\n| 常量       | 值    | 描述                               |\n|------------|-------|----------------------------------------|\n| `SIGINT`   | 2     | 来自键盘的中断（Ctrl+C）               |\n| `SIGTERM`  | 15    | 终止请求                               |\n| `SIGQUIT`  | 3     | 来自键盘的退出（Ctrl+\\）               |\n| `SIGHUP`   | 1     | 在控制终端上检测到挂断                 |\n| `SIGABRT`  | 6     | 中止信号                               |\n\n### 用户定义\n\n| 常量       | 值    | 描述                     |\n|------------|-------|--------------------------|\n| `SIGUSR1`  | 10    | 用户定义信号 1           |\n| `SIGUSR2`  | 12    | 用户定义信号 2           |\n\n### 进程控制\n\n| 常量       | 值    | 描述                          |\n|------------|-------|-------------------------------|\n| `SIGALRM`  | 14    | 闹钟定时器                    |\n| `SIGCHLD`  | 17    | 子进程状态变化                |\n| `SIGCONT`  | 18    | 如果停止则继续                |\n| `SIGSTOP`  | 19    | 停止进程（不能被捕获）        |\n| `SIGTSTP`  | 20    | 终端停止（Ctrl+Z）            |\n\n### I/O\n\n| 常量       | 值    | 描述                           |\n|------------|-------|--------------------------------|\n| `SIGPIPE`  | 13    | 管道破裂                       |\n| `SIGTTIN`  | 21    | 后台从终端读取                 |\n| `SIGTTOU`  | 22    | 后台写入终端                   |\n\n**示例：**\n```hemlock\nfn handle_signal(sig) {\n    if (sig == SIGINT) {\n        print(\"Interrupt detected\");\n    }\n    if (sig == SIGTERM) {\n        print(\"Termination requested\");\n    }\n}\n\nsignal(SIGINT, handle_signal);\nsignal(SIGTERM, handle_signal);\n```\n\n**注意：** `SIGKILL` (9) 和 `SIGSTOP` (19) 不能被捕获或忽略。\n\n---\n\n## 数学/算术函数\n\n### div\n\n返回浮点数的向下整除。\n\n**签名：**\n```hemlock\ndiv(a: number, b: number): f64\n```\n\n**参数：**\n- `a` - 被除数\n- `b` - 除数\n\n**返回值：** `a / b` 的向下取整结果，作为浮点数 (f64)\n\n**示例：**\n```hemlock\nlet result = div(7, 2);    // 3.0（不是 3.5）\nlet result2 = div(10, 3);  // 3.0\nlet result3 = div(-7, 2);  // -4.0（向下取整朝向负无穷）\n```\n\n**注意：** 在 Hemlock 中，`/` 运算符总是返回浮点数。当需要整数部分作为浮点数时使用 `div()`，或者当需要整数结果时使用 `divi()`。\n\n---\n\n### divi\n\n返回整数的向下整除。\n\n**签名：**\n```hemlock\ndivi(a: number, b: number): i64\n```\n\n**参数：**\n- `a` - 被除数\n- `b` - 除数\n\n**返回值：** `a / b` 的向下取整结果，作为整数 (i64)\n\n**示例：**\n```hemlock\nlet result = divi(7, 2);    // 3\nlet result2 = divi(10, 3);  // 3\nlet result3 = divi(-7, 2);  // -4（向下取整朝向负无穷）\n```\n\n**比较：**\n```hemlock\nprint(7 / 2);      // 3.5（常规除法，总是浮点数）\nprint(div(7, 2));  // 3.0（向下整除，浮点数结果）\nprint(divi(7, 2)); // 3  （向下整除，整数结果）\n```\n\n---\n\n## 内存管理函数\n\n参见 [内存 API](#reference-memory-api) 获取完整参考：\n- `alloc(size)` - 分配原始内存\n- `free(ptr)` - 释放内存\n- `buffer(size)` - 分配安全缓冲区\n- `memset(ptr, byte, size)` - 填充内存\n- `memcpy(dest, src, size)` - 复制内存\n- `realloc(ptr, new_size)` - 调整分配大小\n\n### sizeof\n\n获取类型的字节大小。\n\n**签名：**\n```hemlock\nsizeof(type): i32\n```\n\n**参数：**\n- `type` - 类型常量（`i32`、`f64`、`ptr` 等）或类型名称字符串\n\n**返回值：** 字节大小，作为 `i32`\n\n**示例：**\n```hemlock\nprint(sizeof(i8));       // 1\nprint(sizeof(i16));      // 2\nprint(sizeof(i32));      // 4\nprint(sizeof(i64));      // 8\nprint(sizeof(f32));      // 4\nprint(sizeof(f64));      // 8\nprint(sizeof(ptr));      // 8\nprint(sizeof(rune));     // 4\n\n// 使用类型别名\nprint(sizeof(byte));     // 1（与 u8 相同）\nprint(sizeof(integer));  // 4（与 i32 相同）\nprint(sizeof(number));   // 8（与 f64 相同）\n\n// 字符串形式也可以\nprint(sizeof(\"i32\"));    // 4\n```\n\n**支持的类型：**\n| 类型 | 大小 | 别名 |\n|------|------|---------|\n| `i8` | 1 | - |\n| `i16` | 2 | - |\n| `i32` | 4 | `integer` |\n| `i64` | 8 | - |\n| `u8` | 1 | `byte` |\n| `u16` | 2 | - |\n| `u32` | 4 | - |\n| `u64` | 8 | - |\n| `f32` | 4 | - |\n| `f64` | 8 | `number` |\n| `ptr` | 8 | - |\n| `rune` | 4 | - |\n| `bool` | 1 | - |\n\n**另请参阅：** `talloc()` 用于类型化分配\n\n---\n\n### talloc\n\n为类型化数组分配内存（类型感知分配）。\n\n**签名：**\n```hemlock\ntalloc(type, count: i32): ptr\n```\n\n**参数：**\n- `type` - 类型常量（`i32`、`f64`、`ptr` 等）\n- `count` - 要分配的元素数量\n\n**返回值：** 指向已分配内存的 `ptr`，失败时返回 `null`\n\n**示例：**\n```hemlock\n// 分配 10 个 i32 的数组（40 字节）\nlet int_arr = talloc(i32, 10);\nptr_write_i32(int_arr, 42);\nptr_write_i32(ptr_offset(int_arr, 1, 4), 100);\n\n// 分配 5 个 f64 的数组（40 字节）\nlet float_arr = talloc(f64, 5);\n\n// 分配 100 字节的数组\nlet byte_arr = talloc(u8, 100);\n\n// 别忘了释放！\nfree(int_arr);\nfree(float_arr);\nfree(byte_arr);\n```\n\n**与 alloc 的比较：**\n```hemlock\n// 这些是等价的：\nlet p1 = talloc(i32, 10);      // 类型感知：10 个 i32\nlet p2 = alloc(sizeof(i32) * 10);  // 手动计算\n\n// talloc 更清晰，更不容易出错\n```\n\n**错误处理：**\n- 分配失败时返回 `null`\n- 如果 count 不是正数则退出并报错\n- 检查大小溢出（count * element_size）\n\n**另请参阅：** `alloc()`、`sizeof()`、`free()`\n\n---\n\n## FFI 指针辅助函数\n\n这些函数帮助读写原始内存中的类型化值，对 FFI 和底层内存操作很有用。\n\n### ptr_null\n\n创建空指针。\n\n**签名：**\n```hemlock\nptr_null(): ptr\n```\n\n**返回值：** 空指针\n\n**示例：**\n```hemlock\nlet p = ptr_null();\nif (p == null) {\n    print(\"Pointer is null\");\n}\n```\n\n---\n\n### ptr_offset\n\n计算指针偏移（指针算术）。\n\n**签名：**\n```hemlock\nptr_offset(ptr: ptr, index: i32, element_size: i32): ptr\n```\n\n**参数：**\n- `ptr` - 基指针\n- `index` - 元素索引\n- `element_size` - 每个元素的字节大小\n\n**返回值：** 指向给定索引处元素的指针\n\n**示例：**\n```hemlock\nlet arr = talloc(i32, 10);\nptr_write_i32(arr, 100);                      // arr[0] = 100\nptr_write_i32(ptr_offset(arr, 1, 4), 200);    // arr[1] = 200\nptr_write_i32(ptr_offset(arr, 2, 4), 300);    // arr[2] = 300\n\nprint(ptr_read_i32(ptr_offset(arr, 1, 4)));   // 200\nfree(arr);\n```\n\n---\n\n### 指针读取函数\n\n从内存读取类型化值。\n\n| 函数 | 签名 | 返回值 | 描述 |\n|----------|-----------|---------|-------------|\n| `ptr_read_i8` | `(ptr)` | `i8` | 读取有符号 8 位整数 |\n| `ptr_read_i16` | `(ptr)` | `i16` | 读取有符号 16 位整数 |\n| `ptr_read_i32` | `(ptr)` | `i32` | 读取有符号 32 位整数 |\n| `ptr_read_i64` | `(ptr)` | `i64` | 读取有符号 64 位整数 |\n| `ptr_read_u8` | `(ptr)` | `u8` | 读取无符号 8 位整数 |\n| `ptr_read_u16` | `(ptr)` | `u16` | 读取无符号 16 位整数 |\n| `ptr_read_u32` | `(ptr)` | `u32` | 读取无符号 32 位整数 |\n| `ptr_read_u64` | `(ptr)` | `u64` | 读取无符号 64 位整数 |\n| `ptr_read_f32` | `(ptr)` | `f32` | 读取 32 位浮点数 |\n| `ptr_read_f64` | `(ptr)` | `f64` | 读取 64 位浮点数 |\n| `ptr_read_ptr` | `(ptr)` | `ptr` | 读取指针值 |\n\n**示例：**\n```hemlock\nlet p = alloc(8);\nptr_write_f64(p, 3.14159);\nlet value = ptr_read_f64(p);\nprint(value);  // 3.14159\nfree(p);\n```\n\n---\n\n### 指针写入函数\n\n向内存写入类型化值。\n\n| 函数 | 签名 | 返回值 | 描述 |\n|----------|-----------|---------|-------------|\n| `ptr_write_i8` | `(ptr, value)` | `null` | 写入有符号 8 位整数 |\n| `ptr_write_i16` | `(ptr, value)` | `null` | 写入有符号 16 位整数 |\n| `ptr_write_i32` | `(ptr, value)` | `null` | 写入有符号 32 位整数 |\n| `ptr_write_i64` | `(ptr, value)` | `null` | 写入有符号 64 位整数 |\n| `ptr_write_u8` | `(ptr, value)` | `null` | 写入无符号 8 位整数 |\n| `ptr_write_u16` | `(ptr, value)` | `null` | 写入无符号 16 位整数 |\n| `ptr_write_u32` | `(ptr, value)` | `null` | 写入无符号 32 位整数 |\n| `ptr_write_u64` | `(ptr, value)` | `null` | 写入无符号 64 位整数 |\n| `ptr_write_f32` | `(ptr, value)` | `null` | 写入 32 位浮点数 |\n| `ptr_write_f64` | `(ptr, value)` | `null` | 写入 64 位浮点数 |\n| `ptr_write_ptr` | `(ptr, value)` | `null` | 写入指针值 |\n\n**示例：**\n```hemlock\nlet p = alloc(4);\nptr_write_i32(p, 42);\nprint(ptr_read_i32(p));  // 42\nfree(p);\n```\n\n---\n\n### 缓冲区/指针转换\n\n#### buffer_ptr\n\n从缓冲区获取原始指针。\n\n**签名：**\n```hemlock\nbuffer_ptr(buf: buffer): ptr\n```\n\n**示例：**\n```hemlock\nlet buf = buffer(64);\nlet p = buffer_ptr(buf);\n// 现在 p 指向与 buf 相同的内存\n```\n\n#### ptr_to_buffer\n\n围绕原始指针创建缓冲区包装器。\n\n**签名：**\n```hemlock\nptr_to_buffer(ptr: ptr, size: i32): buffer\n```\n\n**示例：**\n```hemlock\nlet p = alloc(64);\nlet buf = ptr_to_buffer(p, 64);\nbuf[0] = 65;  // 现在有边界检查\n// 注意：释放 buf 将释放底层内存\n```\n\n---\n\n## 文件 I/O 函数\n\n参见 [文件 API](#reference-file-api) 获取完整参考：\n- `open(path, mode?)` - 打开文件\n\n---\n\n## 并发函数\n\n参见 [并发 API](#reference-concurrency-api) 获取完整参考：\n- `spawn(fn, args...)` - 派生任务\n- `join(task)` - 等待任务\n- `detach(task)` - 分离任务\n- `channel(capacity)` - 创建通道\n\n### apply\n\n使用参数数组动态调用函数。\n\n**签名：**\n```hemlock\napply(fn: function, args: array): any\n```\n\n**参数：**\n- `fn` - 要调用的函数\n- `args` - 要传递给函数的参数数组\n\n**返回值：** 被调用函数的返回值\n\n**示例：**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\n// 使用参数数组调用\nlet result = apply(add, [2, 3]);\nprint(result);  // 5\n\n// 动态分派\nlet operations = {\n    add: fn(a, b) { return a + b; },\n    mul: fn(a, b) { return a * b; },\n    sub: fn(a, b) { return a - b; }\n};\n\nfn calculate(op: string, args: array) {\n    return apply(operations[op], args);\n}\n\nprint(calculate(\"add\", [10, 5]));  // 15\nprint(calculate(\"mul\", [10, 5]));  // 50\nprint(calculate(\"sub\", [10, 5]));  // 5\n\n// 可变参数\nfn sum(...nums) {\n    let total = 0;\n    for (n in nums) {\n        total = total + n;\n    }\n    return total;\n}\n\nlet numbers = [1, 2, 3, 4, 5];\nprint(apply(sum, numbers));  // 15\n```\n\n**用例：**\n- 基于运行时值的动态函数分派\n- 调用具有可变参数列表的函数\n- 实现高阶工具（map、filter 等）\n- 插件/扩展系统\n\n---\n\n### select\n\n等待多个通道的数据，当任一通道有数据时返回。\n\n**签名：**\n```hemlock\nselect(channels: array, timeout_ms?: i32): object | null\n```\n\n**参数：**\n- `channels` - 通道值数组\n- `timeout_ms`（可选）- 超时毫秒数（-1 或省略表示无限等待）\n\n**返回值：**\n- `{ channel, value }` - 包含有数据的通道和接收到的值的对象\n- `null` - 超时时\n\n**示例：**\n```hemlock\nlet ch1 = channel(1);\nlet ch2 = channel(1);\n\n// 生产者任务\nspawn(fn() {\n    sleep(100);\n    ch1.send(\"from channel 1\");\n});\n\nspawn(fn() {\n    sleep(50);\n    ch2.send(\"from channel 2\");\n});\n\n// 等待第一条消息\nlet result = select([ch1, ch2]);\nprint(result.value);  // \"from channel 2\"（先到达）\n\n// 带超时\nlet result2 = select([ch1, ch2], 1000);  // 等待最多 1 秒\nif (result2 == null) {\n    print(\"Timeout - no data received\");\n} else {\n    print(\"Received:\", result2.value);\n}\n\n// 连续 select 循环\nwhile (true) {\n    let msg = select([ch1, ch2], 5000);\n    if (msg == null) {\n        print(\"No activity for 5 seconds\");\n        break;\n    }\n    print(\"Got message:\", msg.value);\n}\n```\n\n**行为：**\n- 阻塞直到一个通道有数据或超时到期\n- 如果通道已有数据则立即返回\n- 如果通道已关闭且为空，返回 `{ channel, value: null }`\n- 按顺序轮询通道（第一个就绪的通道获胜）\n\n**用例：**\n- 多路复用多个生产者\n- 在通道操作上实现超时\n- 构建具有多个源的事件循环\n\n---\n\n## 总结表\n\n### 函数\n\n| 函数       | 类别            | 返回值       | 描述                            |\n|------------|-----------------|--------------|----------------------------------|\n| `print`    | I/O             | `null`       | 打印到标准输出                   |\n| `read_line`| I/O             | `string?`    | 从标准输入读取行                 |\n| `eprint`   | I/O             | `null`       | 打印到标准错误                   |\n| `typeof`   | 类型            | `string`     | 获取类型名称                     |\n| `exec`     | 命令            | `object`     | 执行 shell 命令                  |\n| `exec_argv`| 命令            | `object`     | 使用参数数组执行                 |\n| `assert`   | 错误            | `null`       | 断言条件或退出                   |\n| `panic`    | 错误            | `never`      | 不可恢复的错误（退出）           |\n| `signal`   | 信号            | `function?`  | 注册信号处理程序                 |\n| `raise`    | 信号            | `null`       | 向进程发送信号                   |\n| `alloc`    | 内存            | `ptr`        | 分配原始内存                     |\n| `talloc`   | 内存            | `ptr`        | 类型化分配                       |\n| `sizeof`   | 内存            | `i32`        | 获取类型字节大小                 |\n| `free`     | 内存            | `null`       | 释放内存                         |\n| `buffer`   | 内存            | `buffer`     | 分配安全缓冲区                   |\n| `memset`   | 内存            | `null`       | 填充内存                         |\n| `memcpy`   | 内存            | `null`       | 复制内存                         |\n| `realloc`  | 内存            | `ptr`        | 调整分配大小                     |\n| `open`     | 文件 I/O        | `file`       | 打开文件                         |\n| `spawn`    | 并发            | `task`       | 派生并发任务                     |\n| `join`     | 并发            | `any`        | 等待任务结果                     |\n| `detach`   | 并发            | `null`       | 分离任务                         |\n| `channel`  | 并发            | `channel`    | 创建通信通道                     |\n| `select`   | 并发            | `object?`    | 等待多个通道                     |\n| `apply`    | 函数            | `any`        | 使用参数数组调用函数             |\n\n### 全局变量\n\n| 变量       | 类型     | 描述                              |\n|------------|----------|-----------------------------------|\n| `args`     | `array`  | 命令行参数                        |\n\n### 常量\n\n| 常量       | 类型  | 类别   | 值    | 描述                      |\n|------------|-------|--------|-------|---------------------------|\n| `SIGINT`   | `i32` | 信号   | 2     | 键盘中断                  |\n| `SIGTERM`  | `i32` | 信号   | 15    | 终止请求                  |\n| `SIGQUIT`  | `i32` | 信号   | 3     | 键盘退出                  |\n| `SIGHUP`   | `i32` | 信号   | 1     | 挂断                      |\n| `SIGABRT`  | `i32` | 信号   | 6     | 中止                      |\n| `SIGUSR1`  | `i32` | 信号   | 10    | 用户定义 1                |\n| `SIGUSR2`  | `i32` | 信号   | 12    | 用户定义 2                |\n| `SIGALRM`  | `i32` | 信号   | 14    | 闹钟定时器                |\n| `SIGCHLD`  | `i32` | 信号   | 17    | 子进程状态变化            |\n| `SIGCONT`  | `i32` | 信号   | 18    | 继续                      |\n| `SIGSTOP`  | `i32` | 信号   | 19    | 停止（不可捕获）          |\n| `SIGTSTP`  | `i32` | 信号   | 20    | 终端停止                  |\n| `SIGPIPE`  | `i32` | 信号   | 13    | 管道破裂                  |\n| `SIGTTIN`  | `i32` | 信号   | 21    | 后台终端读取              |\n| `SIGTTOU`  | `i32` | 信号   | 22    | 后台终端写入              |\n\n---\n\n## 另请参阅\n\n- [类型系统](#reference-type-system) - 类型和转换\n- [内存 API](#reference-memory-api) - 内存分配函数\n- [文件 API](#reference-file-api) - 文件 I/O 函数\n- [并发 API](#reference-concurrency-api) - 异步/并发函数\n- [字符串 API](#reference-string-api) - 字符串方法\n- [数组 API](#reference-array-api) - 数组方法\n"}, "API 参考 -> 字符串 API": {"id": "reference-string-api", "content": "# 字符串 API 参考\n\nHemlock 字符串类型及全部 19 个字符串方法的完整参考。\n\n---\n\n## 概述\n\nHemlock 中的字符串是 **UTF-8 编码、可变、堆分配**的序列，具有完整的 Unicode 支持。所有操作都基于**码点**（字符）而非字节。\n\n**主要特性：**\n- UTF-8 编码 (U+0000 到 U+10FFFF)\n- 可变（可以原地修改字符）\n- 基于码点的索引\n- 19 个内置方法\n- 使用 `+` 运算符自动连接\n\n---\n\n## 字符串类型\n\n**类型：** `string`\n\n**属性：**\n- `.length` - 码点（字符）数量\n- `.byte_length` - UTF-8 字节数量\n\n**字面量语法：** 双引号 `\"text\"`\n\n**示例：**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5 (codepoints)\nprint(s.byte_length);   // 5 (bytes)\n\nlet emoji = \"🚀\";\nprint(emoji.length);        // 1 (one codepoint)\nprint(emoji.byte_length);   // 4 (four UTF-8 bytes)\n```\n\n---\n\n## 索引\n\n字符串支持使用 `[]` 进行基于码点的索引：\n\n**读取访问：**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Returns rune 'h'\n```\n\n**写入访问：**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Mutate with rune (now \"Hello\")\n```\n\n**UTF-8 示例：**\n```hemlock\nlet text = \"Hi🚀!\";\nprint(text[0]);         // 'H'\nprint(text[1]);         // 'i'\nprint(text[2]);         // '🚀' (one codepoint)\nprint(text[3]);         // '!'\n```\n\n---\n\n## 连接\n\n使用 `+` 运算符连接字符串和 rune：\n\n**字符串 + 字符串：**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n```\n\n**字符串 + Rune：**\n```hemlock\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\nlet decorated = \"Text\" + '✓';      // \"Text✓\"\n```\n\n**Rune + 字符串：**\n```hemlock\nlet prefix = '>' + \" Message\";     // \"> Message\"\nlet bullet = '•' + \" Item\";        // \"• Item\"\n```\n\n**多重连接：**\n```hemlock\nlet msg = \"Hi \" + '👋' + \" World \" + '🌍';  // \"Hi 👋 World 🌍\"\n```\n\n---\n\n## 字符串属性\n\n### .length\n\n获取 Unicode 码点（字符）数量。\n\n**类型：** `i32`\n\n**示例：**\n```hemlock\nlet s = \"hello\";\nprint(s.length);        // 5\n\nlet emoji = \"🚀\";\nprint(emoji.length);    // 1 (one codepoint)\n\nlet text = \"Hello 🌍!\";\nprint(text.length);     // 8 (7 ASCII + 1 emoji)\n```\n\n---\n\n### .byte_length\n\n获取 UTF-8 字节数量。\n\n**类型：** `i32`\n\n**示例：**\n```hemlock\nlet s = \"hello\";\nprint(s.byte_length);   // 5 (1 byte per ASCII char)\n\nlet emoji = \"🚀\";\nprint(emoji.byte_length); // 4 (emoji is 4 UTF-8 bytes)\n\nlet text = \"Hello 🌍!\";\nprint(text.byte_length);  // 11 (7 ASCII + 4 for emoji)\n```\n\n---\n\n## 字符串方法\n\n### 子字符串和切片\n\n#### substr\n\n按位置和长度提取子字符串。\n\n**签名：**\n```hemlock\nstring.substr(start: i32, length: i32): string\n```\n\n**参数：**\n- `start` - 起始码点索引（从 0 开始）\n- `length` - 要提取的码点数量\n\n**返回值：** 新字符串\n\n**示例：**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);       // \"world\"\nlet first = s.substr(0, 5);     // \"hello\"\n\n// UTF-8 example\nlet text = \"Hi🚀!\";\nlet emoji = text.substr(2, 1);  // \"🚀\"\n```\n\n---\n\n#### slice\n\n按范围提取子字符串（结束位置不包含）。\n\n**签名：**\n```hemlock\nstring.slice(start: i32, end: i32): string\n```\n\n**参数：**\n- `start` - 起始码点索引（从 0 开始）\n- `end` - 结束码点索引（不包含）\n\n**返回值：** 新字符串\n\n**示例：**\n```hemlock\nlet s = \"hello world\";\nlet sub = s.slice(0, 5);        // \"hello\"\nlet world = s.slice(6, 11);     // \"world\"\n\n// UTF-8 example\nlet text = \"Hi🚀!\";\nlet first_three = text.slice(0, 3);  // \"Hi🚀\"\n```\n\n---\n\n### 搜索和查找\n\n#### find\n\n查找子字符串的第一次出现。\n\n**签名：**\n```hemlock\nstring.find(needle: string): i32\n```\n\n**参数：**\n- `needle` - 要搜索的子字符串\n\n**返回值：** 第一次出现的码点索引，如果未找到则返回 `-1`\n\n**示例：**\n```hemlock\nlet s = \"hello world\";\nlet pos = s.find(\"world\");      // 6\nlet pos2 = s.find(\"foo\");       // -1 (not found)\nlet pos3 = s.find(\"l\");         // 2 (first 'l')\n```\n\n---\n\n#### contains\n\n检查字符串是否包含子字符串。\n\n**签名：**\n```hemlock\nstring.contains(needle: string): bool\n```\n\n**参数：**\n- `needle` - 要搜索的子字符串\n\n**返回值：** 如果找到返回 `true`，否则返回 `false`\n\n**示例：**\n```hemlock\nlet s = \"hello world\";\nlet has = s.contains(\"world\");  // true\nlet has2 = s.contains(\"foo\");   // false\n```\n\n---\n\n### 分割和连接\n\n#### split\n\n按分隔符将字符串分割为数组。\n\n**签名：**\n```hemlock\nstring.split(delimiter: string): array\n```\n\n**参数：**\n- `delimiter` - 分割依据的字符串\n\n**返回值：** 字符串数组\n\n**示例：**\n```hemlock\nlet csv = \"a,b,c\";\nlet parts = csv.split(\",\");     // [\"a\", \"b\", \"c\"]\n\nlet path = \"/usr/local/bin\";\nlet dirs = path.split(\"/\");     // [\"\", \"usr\", \"local\", \"bin\"]\n\nlet text = \"hello world foo\";\nlet words = text.split(\" \");    // [\"hello\", \"world\", \"foo\"]\n```\n\n---\n\n#### trim\n\n移除首尾空白字符。\n\n**签名：**\n```hemlock\nstring.trim(): string\n```\n\n**返回值：** 移除空白后的新字符串\n\n**示例：**\n```hemlock\nlet s = \"  hello  \";\nlet clean = s.trim();           // \"hello\"\n\nlet text = \"\\n\\t  world  \\n\";\nlet clean2 = text.trim();       // \"world\"\n```\n\n---\n\n### 大小写转换\n\n#### to_upper\n\n将字符串转换为大写。\n\n**签名：**\n```hemlock\nstring.to_upper(): string\n```\n\n**返回值：** 大写的新字符串\n\n**示例：**\n```hemlock\nlet s = \"hello world\";\nlet upper = s.to_upper();       // \"HELLO WORLD\"\n\nlet mixed = \"HeLLo\";\nlet upper2 = mixed.to_upper();  // \"HELLO\"\n```\n\n---\n\n#### to_lower\n\n将字符串转换为小写。\n\n**签名：**\n```hemlock\nstring.to_lower(): string\n```\n\n**返回值：** 小写的新字符串\n\n**示例：**\n```hemlock\nlet s = \"HELLO WORLD\";\nlet lower = s.to_lower();       // \"hello world\"\n\nlet mixed = \"HeLLo\";\nlet lower2 = mixed.to_lower();  // \"hello\"\n```\n\n---\n\n### 前缀和后缀\n\n#### starts_with\n\n检查字符串是否以指定前缀开始。\n\n**签名：**\n```hemlock\nstring.starts_with(prefix: string): bool\n```\n\n**参数：**\n- `prefix` - 要检查的前缀\n\n**返回值：** 如果字符串以该前缀开始返回 `true`，否则返回 `false`\n\n**示例：**\n```hemlock\nlet s = \"hello world\";\nlet starts = s.starts_with(\"hello\");  // true\nlet starts2 = s.starts_with(\"world\"); // false\n```\n\n---\n\n#### ends_with\n\n检查字符串是否以指定后缀结束。\n\n**签名：**\n```hemlock\nstring.ends_with(suffix: string): bool\n```\n\n**参数：**\n- `suffix` - 要检查的后缀\n\n**返回值：** 如果字符串以该后缀结束返回 `true`，否则返回 `false`\n\n**示例：**\n```hemlock\nlet s = \"hello world\";\nlet ends = s.ends_with(\"world\");      // true\nlet ends2 = s.ends_with(\"hello\");     // false\n```\n\n---\n\n### 替换\n\n#### replace\n\n替换子字符串的第一次出现。\n\n**签名：**\n```hemlock\nstring.replace(old: string, new: string): string\n```\n\n**参数：**\n- `old` - 要替换的子字符串\n- `new` - 替换字符串\n\n**返回值：** 替换第一次出现后的新字符串\n\n**示例：**\n```hemlock\nlet s = \"hello world\";\nlet s2 = s.replace(\"world\", \"there\");  // \"hello there\"\n\nlet text = \"foo foo foo\";\nlet text2 = text.replace(\"foo\", \"bar\"); // \"bar foo foo\" (only first)\n```\n\n---\n\n#### replace_all\n\n替换子字符串的所有出现。\n\n**签名：**\n```hemlock\nstring.replace_all(old: string, new: string): string\n```\n\n**参数：**\n- `old` - 要替换的子字符串\n- `new` - 替换字符串\n\n**返回值：** 替换所有出现后的新字符串\n\n**示例：**\n```hemlock\nlet text = \"foo foo foo\";\nlet text2 = text.replace_all(\"foo\", \"bar\"); // \"bar bar bar\"\n\nlet s = \"hello world hello\";\nlet s2 = s.replace_all(\"hello\", \"hi\");      // \"hi world hi\"\n```\n\n---\n\n### 重复\n\n#### repeat\n\n将字符串重复 n 次。\n\n**签名：**\n```hemlock\nstring.repeat(count: i32): string\n```\n\n**参数：**\n- `count` - 重复次数\n\n**返回值：** 重复 count 次后的新字符串\n\n**示例：**\n```hemlock\nlet s = \"ha\";\nlet repeated = s.repeat(3);     // \"hahaha\"\n\nlet line = \"-\";\nlet separator = line.repeat(40); // \"----------------------------------------\"\n```\n\n---\n\n### 字符访问\n\n#### char_at\n\n获取指定索引处的 Unicode 码点。\n\n**签名：**\n```hemlock\nstring.char_at(index: i32): rune\n```\n\n**参数：**\n- `index` - 码点索引（从 0 开始）\n\n**返回值：** Rune（Unicode 码点）\n\n**示例：**\n```hemlock\nlet s = \"hello\";\nlet ch = s.char_at(0);          // 'h'\nlet ch2 = s.char_at(1);         // 'e'\n\n// UTF-8 example\nlet emoji = \"🚀\";\nlet ch3 = emoji.char_at(0);     // U+1F680 (rocket)\n```\n\n---\n\n#### chars\n\n将字符串转换为 rune 数组。\n\n**签名：**\n```hemlock\nstring.chars(): array\n```\n\n**返回值：** rune（码点）数组\n\n**示例：**\n```hemlock\nlet s = \"hello\";\nlet chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']\n\n// UTF-8 example\nlet text = \"Hi🚀!\";\nlet chars2 = text.chars();      // ['H', 'i', '🚀', '!']\n```\n\n---\n\n### 字节访问\n\n#### byte_at\n\n获取指定索引处的字节值。\n\n**签名：**\n```hemlock\nstring.byte_at(index: i32): u8\n```\n\n**参数：**\n- `index` - 字节索引（从 0 开始，不是码点索引）\n\n**返回值：** 字节值 (u8)\n\n**示例：**\n```hemlock\nlet s = \"hello\";\nlet byte = s.byte_at(0);        // 104 (ASCII 'h')\nlet byte2 = s.byte_at(1);       // 101 (ASCII 'e')\n\n// UTF-8 example\nlet emoji = \"🚀\";\nlet byte3 = emoji.byte_at(0);   // 240 (first UTF-8 byte)\n```\n\n---\n\n#### bytes\n\n将字符串转换为字节数组。\n\n**签名：**\n```hemlock\nstring.bytes(): array\n```\n\n**返回值：** u8 字节数组\n\n**示例：**\n```hemlock\nlet s = \"hello\";\nlet bytes = s.bytes();          // [104, 101, 108, 108, 111]\n\n// UTF-8 example\nlet emoji = \"🚀\";\nlet bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 UTF-8 bytes)\n```\n\n---\n\n#### to_bytes\n\n将字符串转换为缓冲区。\n\n**签名：**\n```hemlock\nstring.to_bytes(): buffer\n```\n\n**返回值：** 包含 UTF-8 字节的缓冲区\n\n**示例：**\n```hemlock\nlet s = \"hello\";\nlet buf = s.to_bytes();\nprint(buf.length);              // 5\n\n// UTF-8 example\nlet emoji = \"🚀\";\nlet buf2 = emoji.to_bytes();\nprint(buf2.length);             // 4\n```\n\n**注意：** 这是一个遗留方法。大多数情况下推荐使用 `.bytes()`。\n\n---\n\n### JSON 反序列化\n\n#### deserialize\n\n将 JSON 字符串解析为值。\n\n**签名：**\n```hemlock\nstring.deserialize(): any\n```\n\n**返回值：** 解析后的值（对象、数组、数字、字符串、布尔值或 null）\n\n**示例：**\n```hemlock\nlet json = '{\"x\":10,\"y\":20}';\nlet obj = json.deserialize();\nprint(obj.x);                   // 10\nprint(obj.y);                   // 20\n\nlet arr_json = '[1,2,3]';\nlet arr = arr_json.deserialize();\nprint(arr[0]);                  // 1\n\nlet num_json = '42';\nlet num = num_json.deserialize();\nprint(num);                     // 42\n```\n\n**支持的类型：**\n- 对象：`{\"key\": value}`\n- 数组：`[1, 2, 3]`\n- 数字：`42`、`3.14`\n- 字符串：`\"text\"`\n- 布尔值：`true`、`false`\n- 空值：`null`\n\n**另请参阅：** 对象的 `.serialize()` 方法\n\n---\n\n## 方法链\n\n字符串方法可以链接起来进行简洁的操作：\n\n**示例：**\n```hemlock\nlet result = \"  Hello World  \"\n    .trim()\n    .to_lower()\n    .replace(\"world\", \"hemlock\");  // \"hello hemlock\"\n\nlet processed = \"foo,bar,baz\"\n    .split(\",\")\n    .join(\" | \");                  // \"foo | bar | baz\"\n\nlet cleaned = \"  HELLO  \"\n    .trim()\n    .to_lower();                   // \"hello\"\n```\n\n---\n\n## 完整方法汇总\n\n| 方法           | 签名                                         | 返回值    | 描述                            |\n|----------------|----------------------------------------------|-----------|--------------------------------|\n| `substr`       | `(start: i32, length: i32)`                  | `string`  | 按位置/长度提取子字符串         |\n| `slice`        | `(start: i32, end: i32)`                     | `string`  | 按范围提取子字符串              |\n| `find`         | `(needle: string)`                           | `i32`     | 查找第一次出现（未找到返回 -1） |\n| `contains`     | `(needle: string)`                           | `bool`    | 检查是否包含子字符串            |\n| `split`        | `(delimiter: string)`                        | `array`   | 分割为数组                      |\n| `trim`         | `()`                                         | `string`  | 移除空白字符                    |\n| `to_upper`     | `()`                                         | `string`  | 转换为大写                      |\n| `to_lower`     | `()`                                         | `string`  | 转换为小写                      |\n| `starts_with`  | `(prefix: string)`                           | `bool`    | 检查是否以前缀开始              |\n| `ends_with`    | `(suffix: string)`                           | `bool`    | 检查是否以后缀结束              |\n| `replace`      | `(old: string, new: string)`                 | `string`  | 替换第一次出现                  |\n| `replace_all`  | `(old: string, new: string)`                 | `string`  | 替换所有出现                    |\n| `repeat`       | `(count: i32)`                               | `string`  | 将字符串重复 n 次               |\n| `char_at`      | `(index: i32)`                               | `rune`    | 获取指定索引处的码点            |\n| `byte_at`      | `(index: i32)`                               | `u8`      | 获取指定索引处的字节            |\n| `chars`        | `()`                                         | `array`   | 转换为 rune 数组                |\n| `bytes`        | `()`                                         | `array`   | 转换为字节数组                  |\n| `to_bytes`     | `()`                                         | `buffer`  | 转换为缓冲区（遗留）            |\n| `deserialize`  | `()`                                         | `any`     | 解析 JSON 字符串                |\n\n---\n\n## 另请参阅\n\n- [类型系统](#reference-type-system) - 字符串类型详情\n- [数组 API](#reference-array-api) - split() 结果的数组方法\n- [运算符](#reference-operators) - 字符串连接运算符\n"}, "API 参考 -> 并发 API": {"id": "reference-concurrency-api", "content": "# 并发 API 参考\n\nHemlock 异步/并发系统的完整参考文档。\n\n---\n\n## 概述\n\nHemlock 使用 POSIX 线程（pthreads）提供**结构化并发**和真正的多线程并行。每个派生的任务都在单独的操作系统线程上运行，支持跨多个 CPU 核心的实际并行执行。\n\n**主要特性：**\n- 真正的多线程并行（不是绿色线程）\n- 异步函数语法\n- 任务派生和加入\n- 线程安全通道\n- 异常传播\n\n**线程模型：**\n- 真正的操作系统线程（POSIX pthreads）\n- 真正的并行性（多个 CPU 核心）\n- 内核调度（抢占式多任务）\n- 线程安全同步（互斥锁、条件变量）\n\n---\n\n## 异步函数\n\n### 异步函数声明\n\n函数可以声明为 `async`，表示它们是为并发执行设计的。\n\n**语法：**\n```hemlock\nasync fn function_name(params): return_type {\n    // 函数体\n}\n```\n\n**示例：**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nasync fn process_data(data: string) {\n    print(\"Processing:\", data);\n    return null;\n}\n```\n\n**行为：**\n- `async fn` 声明一个异步函数\n- 可以同步调用（在当前线程运行）\n- 可以作为并发任务派生（在新线程运行）\n- 派生时，在自己的操作系统线程上运行\n\n**注意：** `await` 关键字保留供将来使用，但目前未实现。\n\n---\n\n## 任务管理\n\n### spawn\n\n创建并启动一个新的并发任务。\n\n**签名：**\n```hemlock\nspawn(async_fn: function, ...args): task\n```\n\n**参数：**\n- `async_fn` - 要执行的异步函数\n- `...args` - 传递给函数的参数\n\n**返回值：** 任务句柄\n\n**示例：**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// 派生单个任务\nlet t = spawn(compute, 1000);\nlet result = join(t);\nprint(result);\n\n// 派生多个任务（并行运行！）\nlet t1 = spawn(compute, 100);\nlet t2 = spawn(compute, 200);\nlet t3 = spawn(compute, 300);\n\n// 三个任务同时运行\nlet r1 = join(t1);\nlet r2 = join(t2);\nlet r3 = join(t3);\n```\n\n**行为：**\n- 通过 `pthread_create()` 创建新的操作系统线程\n- 立即开始执行函数\n- 返回任务句柄供后续加入\n- 任务在单独的 CPU 核心上并行运行\n\n---\n\n### join\n\n等待任务完成并获取结果。\n\n**签名：**\n```hemlock\njoin(task: task): any\n```\n\n**参数：**\n- `task` - 来自 `spawn()` 的任务句柄\n\n**返回值：** 任务的返回值\n\n**示例：**\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\nlet t = spawn(factorial, 10);\nlet result = join(t);  // 阻塞直到任务完成\nprint(result);         // 3628800\n```\n\n**行为：**\n- 阻塞当前线程直到任务完成\n- 返回任务的返回值\n- 传播任务抛出的异常\n- 返回后清理任务资源\n\n**错误处理：**\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\nlet t = spawn(risky_operation, 1);\ntry {\n    let result = join(t);\n} catch (e) {\n    print(\"Caught:\", e);  // \"Caught: Task failed!\"\n}\n```\n\n---\n\n### detach\n\n分离任务（即发即弃执行）。\n\n**签名：**\n```hemlock\ndetach(task: task): null\n```\n\n**参数：**\n- `task` - 来自 `spawn()` 的任务句柄\n\n**返回值：** `null`\n\n**示例：**\n```hemlock\nasync fn background_work() {\n    print(\"Working in background...\");\n    return null;\n}\n\nlet t = spawn(background_work);\ndetach(t);  // 任务继续独立运行\n\n// 不能加入已分离的任务\n// join(t);  // 错误\n```\n\n**行为：**\n- 任务继续独立运行\n- 不能 `join()` 已分离的任务\n- 任务完成时自动清理任务和线程\n\n**用例：**\n- 即发即弃的后台任务\n- 日志/监控任务\n- 不需要返回值的任务\n\n---\n\n## 通道\n\n通道提供任务之间的线程安全通信。\n\n### channel\n\n创建一个缓冲通道。\n\n**签名：**\n```hemlock\nchannel(capacity: i32): channel\n```\n\n**参数：**\n- `capacity` - 缓冲区大小（值的数量）\n\n**返回值：** 通道对象\n\n**示例：**\n```hemlock\nlet ch = channel(10);  // 容量为 10 的缓冲通道\nlet ch2 = channel(1);  // 最小缓冲区（同步）\nlet ch3 = channel(100); // 大缓冲区\n```\n\n**行为：**\n- 创建线程安全通道\n- 使用 pthread 互斥锁进行同步\n- 容量在创建时固定\n\n---\n\n### 通道方法\n\n#### send\n\n向通道发送值（如果已满则阻塞）。\n\n**签名：**\n```hemlock\nchannel.send(value: any): null\n```\n\n**参数：**\n- `value` - 要发送的值（任意类型）\n\n**返回值：** `null`\n\n**示例：**\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nlet ch = channel(10);\nlet t = spawn(producer, ch, 5);\n```\n\n**行为：**\n- 向通道发送值\n- 如果通道已满则阻塞\n- 线程安全（使用互斥锁）\n- 值发送后返回\n\n---\n\n#### recv\n\n从通道接收值（如果为空则阻塞）。\n\n**签名：**\n```hemlock\nchannel.recv(): any\n```\n\n**返回值：** 来自通道的值，如果通道已关闭且为空则返回 `null`\n\n**示例：**\n```hemlock\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\nlet ch = channel(10);\nlet t = spawn(consumer, ch, 5);\n```\n\n**行为：**\n- 从通道接收值\n- 如果通道为空则阻塞\n- 如果通道已关闭且为空则返回 `null`\n- 线程安全（使用互斥锁）\n\n---\n\n#### close\n\n关闭通道（不再允许发送）。\n\n**签名：**\n```hemlock\nchannel.close(): null\n```\n\n**返回值：** `null`\n\n**示例：**\n```hemlock\nasync fn producer(ch) {\n    ch.send(1);\n    ch.send(2);\n    ch.send(3);\n    ch.close();  // 表示没有更多值\n    return null;\n}\n\nasync fn consumer(ch) {\n    while (true) {\n        let val = ch.recv();\n        if (val == null) {\n            break;  // 通道已关闭\n        }\n        print(val);\n    }\n    return null;\n}\n```\n\n**行为：**\n- 关闭通道\n- 不再允许发送\n- 通道为空时 `recv()` 返回 `null`\n- 线程安全\n\n---\n\n## 完整并发示例\n\n### 生产者-消费者模式\n\n```hemlock\nasync fn producer(ch, count: i32) {\n    let i = 0;\n    while (i < count) {\n        print(\"Producing:\", i);\n        ch.send(i * 10);\n        i = i + 1;\n    }\n    ch.close();\n    return null;\n}\n\nasync fn consumer(ch, count: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < count) {\n        let val = ch.recv();\n        print(\"Consuming:\", val);\n        sum = sum + val;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// 创建通道\nlet ch = channel(10);\n\n// 派生生产者和消费者\nlet p = spawn(producer, ch, 5);\nlet c = spawn(consumer, ch, 5);\n\n// 等待完成\njoin(p);\nlet total = join(c);\nprint(\"Total:\", total);  // 0+10+20+30+40 = 100\n```\n\n---\n\n## 并行计算\n\n### 多任务示例\n\n```hemlock\nasync fn factorial(n: i32): i32 {\n    if (n <= 1) { return 1; }\n    return n * factorial(n - 1);\n}\n\n// 派生多个任务（并行运行！）\nlet t1 = spawn(factorial, 5);   // 线程 1\nlet t2 = spawn(factorial, 6);   // 线程 2\nlet t3 = spawn(factorial, 7);   // 线程 3\nlet t4 = spawn(factorial, 8);   // 线程 4\n\n// 四个任务同时计算！\n\n// 等待结果\nlet f5 = join(t1);  // 120\nlet f6 = join(t2);  // 720\nlet f7 = join(t3);  // 5040\nlet f8 = join(t4);  // 40320\n\nprint(f5, f6, f7, f8);\n```\n\n---\n\n## 任务生命周期\n\n### 状态转换\n\n1. **已创建** - 任务已派生但尚未运行\n2. **运行中** - 任务在操作系统线程上执行\n3. **已完成** - 任务已完成（结果可用）\n4. **已加入** - 结果已获取，资源已清理\n5. **已分离** - 任务继续独立运行\n\n### 生命周期示例\n\n```hemlock\nasync fn work(n: i32): i32 {\n    return n * 2;\n}\n\n// 1. 创建任务\nlet t = spawn(work, 21);  // 状态：运行中\n\n// 任务在单独线程上执行...\n\n// 2. 加入任务\nlet result = join(t);     // 状态：已完成 → 已加入\nprint(result);            // 42\n\n// 加入后任务资源被清理\n```\n\n### 分离生命周期\n\n```hemlock\nasync fn background() {\n    print(\"Background task running\");\n    return null;\n}\n\n// 1. 创建任务\nlet t = spawn(background);  // 状态：运行中\n\n// 2. 分离任务\ndetach(t);                  // 状态：已分离\n\n// 任务继续独立运行\n// 完成后由操作系统清理资源\n```\n\n---\n\n## 错误处理\n\n### 异常传播\n\n任务中抛出的异常在加入时被传播：\n\n```hemlock\nasync fn risky_operation(should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task failed!\";\n    }\n    return 42;\n}\n\n// 成功的任务\nlet t1 = spawn(risky_operation, 0);\nlet result1 = join(t1);  // 42\n\n// 失败的任务\nlet t2 = spawn(risky_operation, 1);\ntry {\n    let result2 = join(t2);\n} catch (e) {\n    print(\"Caught:\", e);  // \"Caught: Task failed!\"\n}\n```\n\n### 处理多个任务\n\n```hemlock\nasync fn work(id: i32, should_fail: i32): i32 {\n    if (should_fail == 1) {\n        throw \"Task \" + typeof(id) + \" failed\";\n    }\n    return id * 10;\n}\n\nlet t1 = spawn(work, 1, 0);\nlet t2 = spawn(work, 2, 1);  // 将失败\nlet t3 = spawn(work, 3, 0);\n\n// 带错误处理的加入\ntry {\n    let r1 = join(t1);  // 正常\n    print(\"Task 1:\", r1);\n\n    let r2 = join(t2);  // 抛出异常\n    print(\"Task 2:\", r2);  // 永远不会到达\n} catch (e) {\n    print(\"Error:\", e);  // \"Error: Task 2 failed\"\n}\n\n// 仍然可以加入剩余任务\nlet r3 = join(t3);\nprint(\"Task 3:\", r3);\n```\n\n---\n\n## 性能特性\n\n### 真正的并行性\n\n```hemlock\nasync fn cpu_intensive(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// 顺序执行\nlet start = get_time();\nlet r1 = cpu_intensive(10000000);\nlet r2 = cpu_intensive(10000000);\nlet sequential_time = get_time() - start;\n\n// 并行执行\nlet start2 = get_time();\nlet t1 = spawn(cpu_intensive, 10000000);\nlet t2 = spawn(cpu_intensive, 10000000);\njoin(t1);\njoin(t2);\nlet parallel_time = get_time() - start2;\n\n// 在多核系统上 parallel_time 应该约为 sequential_time 的 50%\n```\n\n**已证实的特性：**\n- N 个任务可以同时利用 N 个 CPU 核心\n- 压力测试显示 CPU 时间与墙钟时间之比为 8-9 倍（并行性的证明）\n- 线程开销：每个任务约 8KB 栈 + pthread 开销\n- 一个任务中的阻塞操作不会阻塞其他任务\n\n---\n\n## 实现细节\n\n### 线程模型\n\n- **1:1 线程** - 每个任务 = 1 个操作系统线程（`pthread`）\n- **内核调度** - 操作系统内核在核心之间分配线程\n- **抢占式多任务** - 操作系统可以中断和切换线程\n- **无 GIL** - 没有全局解释器锁（与 Python 不同）\n\n### 同步\n\n- **互斥锁** - 通道使用 `pthread_mutex_t`\n- **条件变量** - 阻塞的 send/recv 使用 `pthread_cond_t`\n- **无锁操作** - 任务状态转换是原子的\n\n### 内存和清理\n\n- **已加入的任务** - `join()` 后自动清理\n- **已分离的任务** - 任务完成时自动清理\n- **通道** - 引用计数，不再使用时释放\n\n---\n\n## 限制\n\n- 没有用于多路复用多个通道的 `select()`\n- 没有工作窃取调度器（每个任务 1 个线程）\n- 没有异步 I/O 集成（文件/网络操作会阻塞）\n- 通道容量在创建时固定\n\n---\n\n## 完整 API 总结\n\n### 函数\n\n| 函数      | 签名                              | 返回值    | 描述                           |\n|-----------|-----------------------------------|-----------|--------------------------------|\n| `spawn`   | `(async_fn: function, ...args)`   | `task`    | 创建并启动并发任务             |\n| `join`    | `(task: task)`                    | `any`     | 等待任务，获取结果             |\n| `detach`  | `(task: task)`                    | `null`    | 分离任务（即发即弃）           |\n| `channel` | `(capacity: i32)`                 | `channel` | 创建线程安全通道               |\n\n### 通道方法\n\n| 方法    | 签名            | 返回值  | 描述                           |\n|---------|-----------------|---------|--------------------------------|\n| `send`  | `(value: any)`  | `null`  | 发送值（如果已满则阻塞）       |\n| `recv`  | `()`            | `any`   | 接收值（如果为空则阻塞）       |\n| `close` | `()`            | `null`  | 关闭通道                       |\n\n### 类型\n\n| 类型      | 描述                                 |\n|-----------|--------------------------------------|\n| `task`    | 并发任务的句柄                       |\n| `channel` | 线程安全通信通道                     |\n\n---\n\n## 最佳实践\n\n### 应该做的\n\n- 使用通道进行任务之间的通信\n- 处理已加入任务的异常\n- 发送完成后关闭通道\n- 使用 `join()` 获取结果并清理\n- 只派生异步函数\n\n### 不应该做的\n\n- 不要在没有同步的情况下共享可变状态\n- 不要对同一任务加入两次\n- 不要向已关闭的通道发送\n- 不要派生非异步函数\n- 不要忘记加入任务（除非已分离）\n\n---\n\n## 另请参阅\n\n- [内置函数](#reference-builtins) - `spawn()`、`join()`、`detach()`、`channel()`\n- [类型系统](#reference-type-system) - 任务和通道类型\n"}, "API 参考 -> 数组 API": {"id": "reference-array-api", "content": "# 数组 API 参考\n\nHemlock 数组类型及其全部 18 个数组方法的完整参考文档。\n\n---\n\n## 概述\n\nHemlock 中的数组是**动态的、堆分配的**序列，可以存储混合类型。它们提供了全面的数据操作和处理方法。\n\n**主要特性：**\n- 动态大小（自动增长）\n- 从零开始索引\n- 允许混合类型\n- 18 个内置方法\n- 堆分配并跟踪容量\n\n---\n\n## 数组类型\n\n**类型：** `array`\n\n**属性：**\n- `.length` - 元素数量 (i32)\n\n**字面量语法：** 方括号 `[elem1, elem2, ...]`\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr.length);     // 5\n\n// 混合类型\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.length);   // 4\n\n// 空数组\nlet empty = [];\nprint(empty.length);   // 0\n```\n\n---\n\n## 索引\n\n数组支持使用 `[]` 进行从零开始的索引：\n\n**读取访问：**\n```hemlock\nlet arr = [10, 20, 30];\nprint(arr[0]);         // 10\nprint(arr[1]);         // 20\nprint(arr[2]);         // 30\n```\n\n**写入访问：**\n```hemlock\nlet arr = [10, 20, 30];\narr[0] = 99;\narr[1] = 88;\nprint(arr);            // [99, 88, 30]\n```\n\n**注意：** 直接索引不进行边界检查。请使用方法以确保安全。\n\n---\n\n## 数组属性\n\n### .length\n\n获取数组中的元素数量。\n\n**类型：** `i32`\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3];\nprint(arr.length);     // 3\n\nlet empty = [];\nprint(empty.length);   // 0\n\n// 长度动态变化\narr.push(4);\nprint(arr.length);     // 4\n\narr.pop();\nprint(arr.length);     // 3\n```\n\n---\n\n## 数组方法\n\n### 栈操作\n\n#### push\n\n将元素添加到数组末尾。\n\n**签名：**\n```hemlock\narray.push(value: any): null\n```\n\n**参数：**\n- `value` - 要添加的元素\n\n**返回值：** `null`\n\n**是否修改原数组：** 是（原地修改数组）\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3];\narr.push(4);           // [1, 2, 3, 4]\narr.push(5);           // [1, 2, 3, 4, 5]\narr.push(\"hello\");     // [1, 2, 3, 4, 5, \"hello\"]\n```\n\n---\n\n#### pop\n\n移除并返回最后一个元素。\n\n**签名：**\n```hemlock\narray.pop(): any\n```\n\n**返回值：** 最后一个元素（从数组中移除）\n\n**是否修改原数组：** 是（原地修改数组）\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3];\nlet last = arr.pop();  // 3\nprint(arr);            // [1, 2]\n\nlet last2 = arr.pop(); // 2\nprint(arr);            // [1]\n```\n\n**错误：** 如果数组为空则抛出运行时错误。\n\n---\n\n### 队列操作\n\n#### shift\n\n移除并返回第一个元素。\n\n**签名：**\n```hemlock\narray.shift(): any\n```\n\n**返回值：** 第一个元素（从数组中移除）\n\n**是否修改原数组：** 是（原地修改数组）\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3];\nlet first = arr.shift();  // 1\nprint(arr);               // [2, 3]\n\nlet first2 = arr.shift(); // 2\nprint(arr);               // [3]\n```\n\n**错误：** 如果数组为空则抛出运行时错误。\n\n---\n\n#### unshift\n\n将元素添加到数组开头。\n\n**签名：**\n```hemlock\narray.unshift(value: any): null\n```\n\n**参数：**\n- `value` - 要添加的元素\n\n**返回值：** `null`\n\n**是否修改原数组：** 是（原地修改数组）\n\n**示例：**\n```hemlock\nlet arr = [2, 3];\narr.unshift(1);        // [1, 2, 3]\narr.unshift(0);        // [0, 1, 2, 3]\n```\n\n---\n\n### 插入与删除\n\n#### insert\n\n在指定索引位置插入元素。\n\n**签名：**\n```hemlock\narray.insert(index: i32, value: any): null\n```\n\n**参数：**\n- `index` - 插入位置（从 0 开始）\n- `value` - 要插入的元素\n\n**返回值：** `null`\n\n**是否修改原数组：** 是（原地修改数组）\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 4, 5];\narr.insert(2, 3);      // [1, 2, 3, 4, 5]\n\nlet arr2 = [1, 3];\narr2.insert(1, 2);     // [1, 2, 3]\n\n// 在末尾插入\narr2.insert(arr2.length, 4);  // [1, 2, 3, 4]\n```\n\n**行为：** 将索引位置及其后的元素向右移动。\n\n---\n\n#### remove\n\n移除并返回指定索引位置的元素。\n\n**签名：**\n```hemlock\narray.remove(index: i32): any\n```\n\n**参数：**\n- `index` - 要移除的位置（从 0 开始）\n\n**返回值：** 被移除的元素\n\n**是否修改原数组：** 是（原地修改数组）\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet removed = arr.remove(0);  // 1\nprint(arr);                   // [2, 3, 4, 5]\n\nlet removed2 = arr.remove(2); // 4\nprint(arr);                   // [2, 3, 5]\n```\n\n**行为：** 将索引位置后的元素向左移动。\n\n**错误：** 如果索引超出边界则抛出运行时错误。\n\n---\n\n### 搜索与查找\n\n#### find\n\n查找值的第一次出现位置。\n\n**签名：**\n```hemlock\narray.find(value: any): i32\n```\n\n**参数：**\n- `value` - 要搜索的值\n\n**返回值：** 第一次出现的索引，如果未找到则返回 `-1`\n\n**示例：**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet idx = arr.find(30);      // 2\nlet idx2 = arr.find(99);     // -1（未找到）\n\n// 查找第一个重复项\nlet arr2 = [1, 2, 3, 2, 4];\nlet idx3 = arr2.find(2);     // 1（第一次出现）\n```\n\n**比较方式：** 对基本类型和字符串使用值相等比较。\n\n---\n\n#### contains\n\n检查数组是否包含某个值。\n\n**签名：**\n```hemlock\narray.contains(value: any): bool\n```\n\n**参数：**\n- `value` - 要搜索的值\n\n**返回值：** 如果找到返回 `true`，否则返回 `false`\n\n**示例：**\n```hemlock\nlet arr = [10, 20, 30, 40];\nlet has = arr.contains(20);  // true\nlet has2 = arr.contains(99); // false\n\n// 对字符串也适用\nlet words = [\"hello\", \"world\"];\nlet has3 = words.contains(\"hello\");  // true\n```\n\n---\n\n### 切片与提取\n\n#### slice\n\n按范围提取子数组（结束位置不包含）。\n\n**签名：**\n```hemlock\narray.slice(start: i32, end: i32): array\n```\n\n**参数：**\n- `start` - 起始索引（从 0 开始，包含）\n- `end` - 结束索引（不包含）\n\n**返回值：** 包含 [start, end) 范围内元素的新数组\n\n**是否修改原数组：** 否（返回新数组）\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sub = arr.slice(1, 4);   // [2, 3, 4]\nlet first_three = arr.slice(0, 3);  // [1, 2, 3]\nlet last_two = arr.slice(3, 5);     // [4, 5]\n\n// 空切片\nlet empty = arr.slice(2, 2); // []\n```\n\n---\n\n#### first\n\n获取第一个元素但不移除。\n\n**签名：**\n```hemlock\narray.first(): any\n```\n\n**返回值：** 第一个元素\n\n**是否修改原数组：** 否\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3];\nlet f = arr.first();         // 1\nprint(arr);                  // [1, 2, 3]（未改变）\n```\n\n**错误：** 如果数组为空则抛出运行时错误。\n\n---\n\n#### last\n\n获取最后一个元素但不移除。\n\n**签名：**\n```hemlock\narray.last(): any\n```\n\n**返回值：** 最后一个元素\n\n**是否修改原数组：** 否\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3];\nlet l = arr.last();          // 3\nprint(arr);                  // [1, 2, 3]（未改变）\n```\n\n**错误：** 如果数组为空则抛出运行时错误。\n\n---\n\n### 数组操作\n\n#### reverse\n\n原地反转数组。\n\n**签名：**\n```hemlock\narray.reverse(): null\n```\n\n**返回值：** `null`\n\n**是否修改原数组：** 是（原地修改数组）\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();               // [5, 4, 3, 2, 1]\nprint(arr);                  // [5, 4, 3, 2, 1]\n\nlet words = [\"hello\", \"world\"];\nwords.reverse();             // [\"world\", \"hello\"]\n```\n\n---\n\n#### clear\n\n移除数组中的所有元素。\n\n**签名：**\n```hemlock\narray.clear(): null\n```\n\n**返回值：** `null`\n\n**是否修改原数组：** 是（原地修改数组）\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\narr.clear();\nprint(arr);                  // []\nprint(arr.length);           // 0\n```\n\n---\n\n### 数组合并\n\n#### concat\n\n与另一个数组连接。\n\n**签名：**\n```hemlock\narray.concat(other: array): array\n```\n\n**参数：**\n- `other` - 要连接的数组\n\n**返回值：** 包含两个数组元素的新数组\n\n**是否修改原数组：** 否（返回新数组）\n\n**示例：**\n```hemlock\nlet a = [1, 2, 3];\nlet b = [4, 5, 6];\nlet combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]\nprint(a);                    // [1, 2, 3]（未改变）\nprint(b);                    // [4, 5, 6]（未改变）\n\n// 链式连接\nlet c = [7, 8];\nlet all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n---\n\n### 函数式操作\n\n#### map\n\n使用回调函数转换每个元素。\n\n**签名：**\n```hemlock\narray.map(callback: fn): array\n```\n\n**参数：**\n- `callback` - 接收一个元素并返回转换后值的函数\n\n**返回值：** 包含转换后元素的新数组\n\n**是否修改原数组：** 否（返回新数组）\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet doubled = arr.map(fn(x) { return x * 2; });\nprint(doubled);  // [2, 4, 6, 8, 10]\n\nlet names = [\"alice\", \"bob\"];\nlet upper = names.map(fn(s) { return s.to_upper(); });\nprint(upper);  // [\"ALICE\", \"BOB\"]\n```\n\n---\n\n#### filter\n\n选择匹配谓词的元素。\n\n**签名：**\n```hemlock\narray.filter(predicate: fn): array\n```\n\n**参数：**\n- `predicate` - 接收一个元素并返回 bool 的函数\n\n**返回值：** 包含谓词返回 true 的元素的新数组\n\n**是否修改原数组：** 否（返回新数组）\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5, 6];\nlet evens = arr.filter(fn(x) { return x % 2 == 0; });\nprint(evens);  // [2, 4, 6]\n\nlet words = [\"hello\", \"hi\", \"hey\", \"goodbye\"];\nlet short = words.filter(fn(s) { return s.length < 4; });\nprint(short);  // [\"hi\", \"hey\"]\n```\n\n---\n\n#### reduce\n\n使用累加器将数组归约为单个值。\n\n**签名：**\n```hemlock\narray.reduce(callback: fn, initial: any): any\n```\n\n**参数：**\n- `callback` - 接收 (累加器, 元素) 并返回新累加器的函数\n- `initial` - 累加器的初始值\n\n**返回值：** 最终累加值\n\n**是否修改原数组：** 否\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nlet sum = arr.reduce(fn(acc, x) { return acc + x; }, 0);\nprint(sum);  // 15\n\nlet product = arr.reduce(fn(acc, x) { return acc * x; }, 1);\nprint(product);  // 120\n\n// 查找最大值\nlet max = arr.reduce(fn(acc, x) {\n    if (x > acc) { return x; }\n    return acc;\n}, arr[0]);\nprint(max);  // 5\n```\n\n---\n\n### 字符串转换\n\n#### join\n\n使用分隔符将元素连接成字符串。\n\n**签名：**\n```hemlock\narray.join(delimiter: string): string\n```\n\n**参数：**\n- `delimiter` - 放置在元素之间的字符串\n\n**返回值：** 连接所有元素的字符串\n\n**示例：**\n```hemlock\nlet words = [\"hello\", \"world\", \"foo\"];\nlet joined = words.join(\" \");  // \"hello world foo\"\n\nlet numbers = [1, 2, 3];\nlet csv = numbers.join(\",\");   // \"1,2,3\"\n\n// 对混合类型也适用\nlet mixed = [1, \"hello\", true, null];\nprint(mixed.join(\" | \"));  // \"1 | hello | true | null\"\n\n// 空分隔符\nlet arr = [\"a\", \"b\", \"c\"];\nlet s = arr.join(\"\");          // \"abc\"\n```\n\n**行为：** 自动将所有元素转换为字符串。\n\n---\n\n## 方法链式调用\n\n数组方法可以链式调用以实现简洁的操作：\n\n**示例：**\n```hemlock\n// 链式调用 slice 和 join\nlet result = [\"apple\", \"banana\", \"cherry\", \"date\"]\n    .slice(0, 2)\n    .join(\" and \");  // \"apple and banana\"\n\n// 链式调用 concat 和 slice\nlet combined = [1, 2, 3]\n    .concat([4, 5, 6])\n    .slice(2, 5);    // [3, 4, 5]\n\n// 复杂链式调用\nlet words = [\"hello\", \"world\", \"foo\", \"bar\"];\nlet result2 = words\n    .slice(0, 3)\n    .concat([\"baz\"])\n    .join(\"-\");      // \"hello-world-foo-baz\"\n```\n\n---\n\n## 完整方法总结\n\n### 修改原数组的方法\n\n原地修改数组的方法：\n\n| 方法       | 签名                       | 返回值    | 描述                           |\n|------------|----------------------------|-----------|--------------------------------|\n| `push`     | `(value: any)`             | `null`    | 添加到末尾                     |\n| `pop`      | `()`                       | `any`     | 从末尾移除                     |\n| `shift`    | `()`                       | `any`     | 从开头移除                     |\n| `unshift`  | `(value: any)`             | `null`    | 添加到开头                     |\n| `insert`   | `(index: i32, value: any)` | `null`    | 在索引位置插入                 |\n| `remove`   | `(index: i32)`             | `any`     | 在索引位置移除                 |\n| `reverse`  | `()`                       | `null`    | 原地反转                       |\n| `clear`    | `()`                       | `null`    | 移除所有元素                   |\n\n### 不修改原数组的方法\n\n返回新值而不修改原数组的方法：\n\n| 方法       | 签名                       | 返回值    | 描述                           |\n|------------|----------------------------|-----------|--------------------------------|\n| `find`     | `(value: any)`             | `i32`     | 查找第一次出现位置             |\n| `contains` | `(value: any)`             | `bool`    | 检查是否包含值                 |\n| `slice`    | `(start: i32, end: i32)`   | `array`   | 提取子数组                     |\n| `first`    | `()`                       | `any`     | 获取第一个元素                 |\n| `last`     | `()`                       | `any`     | 获取最后一个元素               |\n| `concat`   | `(other: array)`           | `array`   | 连接数组                       |\n| `join`     | `(delimiter: string)`      | `string`  | 将元素连接成字符串             |\n| `map`      | `(callback: fn)`           | `array`   | 转换每个元素                   |\n| `filter`   | `(predicate: fn)`          | `array`   | 选择匹配的元素                 |\n| `reduce`   | `(callback: fn, initial: any)` | `any` | 归约为单个值                   |\n\n---\n\n## 使用模式\n\n### 栈用法\n\n```hemlock\nlet stack = [];\n\n// 压栈\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// 弹栈\nwhile (stack.length > 0) {\n    let item = stack.pop();\n    print(item);  // 3, 2, 1\n}\n```\n\n### 队列用法\n\n```hemlock\nlet queue = [];\n\n// 入队\nqueue.push(1);\nqueue.push(2);\nqueue.push(3);\n\n// 出队\nwhile (queue.length > 0) {\n    let item = queue.shift();\n    print(item);  // 1, 2, 3\n}\n```\n\n### 数组转换\n\n```hemlock\n// 过滤（手动方式）\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet evens = [];\nlet i = 0;\nwhile (i < numbers.length) {\n    if (numbers[i] % 2 == 0) {\n        evens.push(numbers[i]);\n    }\n    i = i + 1;\n}\n\n// 映射（手动方式）\nlet numbers2 = [1, 2, 3, 4, 5];\nlet doubled = [];\nlet j = 0;\nwhile (j < numbers2.length) {\n    doubled.push(numbers2[j] * 2);\n    j = j + 1;\n}\n```\n\n### 构建数组\n\n```hemlock\nlet arr = [];\n\n// 使用循环构建数组\nlet i = 0;\nwhile (i < 10) {\n    arr.push(i * 10);\n    i = i + 1;\n}\n\nprint(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n```\n\n---\n\n## 实现细节\n\n**容量管理：**\n- 数组在需要时自动增长\n- 超出容量时容量翻倍\n- 无手动容量控制\n\n**值比较：**\n- `find()` 和 `contains()` 使用值相等比较\n- 对基本类型和字符串正确工作\n- 对象/数组按引用比较\n\n**内存：**\n- 堆分配\n- 无自动释放（手动内存管理）\n- 直接索引访问无边界检查\n\n---\n\n## 另请参阅\n\n- [类型系统](#reference-type-system) - 数组类型详情\n- [字符串 API](#reference-string-api) - 字符串 join() 结果\n- [运算符](#reference-operators) - 数组索引运算符\n"}, "API 参考 -> 文件 API": {"id": "reference-file-api", "content": "# 文件 API 参考\n\nHemlock 文件 I/O 系统的完整参考文档。\n\n---\n\n## 概述\n\nHemlock 提供了一个**文件对象 API**，用于具有适当错误处理和资源管理的文件操作。文件必须手动打开和关闭。\n\n**主要特性：**\n- 带有方法的文件对象\n- 读写文本和二进制数据\n- 定位和位置操作\n- 适当的错误消息\n- 手动资源管理（无 RAII）\n\n---\n\n## 文件类型\n\n**类型：** `file`\n\n**描述：** 用于 I/O 操作的文件句柄\n\n**属性（只读）：**\n- `.path` - 文件路径 (string)\n- `.mode` - 打开模式 (string)\n- `.closed` - 文件是否已关闭 (bool)\n\n---\n\n## 打开文件\n\n### open\n\n打开文件用于读取、写入或两者兼顾。\n\n**签名：**\n```hemlock\nopen(path: string, mode?: string): file\n```\n\n**参数：**\n- `path` - 文件路径（相对或绝对）\n- `mode`（可选）- 打开模式（默认：`\"r\"`）\n\n**返回值：** 文件对象\n\n**模式：**\n- `\"r\"` - 读取（默认）\n- `\"w\"` - 写入（截断现有文件）\n- `\"a\"` - 追加\n- `\"r+\"` - 读写\n- `\"w+\"` - 读写（截断）\n- `\"a+\"` - 读取和追加\n\n**示例：**\n```hemlock\n// 读取模式（默认）\nlet f = open(\"data.txt\");\nlet f_read = open(\"data.txt\", \"r\");\n\n// 写入模式（截断）\nlet f_write = open(\"output.txt\", \"w\");\n\n// 追加模式\nlet f_append = open(\"log.txt\", \"a\");\n\n// 读写模式\nlet f_rw = open(\"data.bin\", \"r+\");\n\n// 读写（截断）\nlet f_rw_trunc = open(\"output.bin\", \"w+\");\n\n// 读取/追加\nlet f_ra = open(\"log.txt\", \"a+\");\n```\n\n**错误处理：**\n```hemlock\ntry {\n    let f = open(\"missing.txt\", \"r\");\n} catch (e) {\n    print(\"Failed to open:\", e);\n    // 错误：Failed to open 'missing.txt': No such file or directory\n}\n```\n\n**重要：** 文件必须使用 `f.close()` 手动关闭以避免文件描述符泄漏。\n\n---\n\n## 文件方法\n\n### 读取\n\n#### read\n\n从文件读取文本。\n\n**签名：**\n```hemlock\nfile.read(size?: i32): string\n```\n\n**参数：**\n- `size`（可选）- 要读取的字节数（如果省略，读取到文件末尾）\n\n**返回值：** 包含文件内容的字符串\n\n**示例：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// 读取整个文件\nlet all = f.read();\nprint(all);\n\n// 读取指定数量的字节\nlet chunk = f.read(1024);\n\nf.close();\n```\n\n**行为：**\n- 从当前文件位置读取\n- 在文件末尾返回空字符串\n- 前进文件位置\n\n**错误：**\n- 从已关闭的文件读取\n- 从只写文件读取\n\n---\n\n#### read_bytes\n\n从文件读取二进制数据。\n\n**签名：**\n```hemlock\nfile.read_bytes(size: i32): buffer\n```\n\n**参数：**\n- `size` - 要读取的字节数\n\n**返回值：** 包含二进制数据的缓冲区\n\n**示例：**\n```hemlock\nlet f = open(\"data.bin\", \"r\");\n\n// 读取 256 字节\nlet binary = f.read_bytes(256);\nprint(binary.length);       // 256\n\n// 处理二进制数据\nlet i = 0;\nwhile (i < binary.length) {\n    print(binary[i]);\n    i = i + 1;\n}\n\nf.close();\n```\n\n**行为：**\n- 读取确切数量的字节\n- 返回缓冲区（不是字符串）\n- 前进文件位置\n\n---\n\n### 写入\n\n#### write\n\n向文件写入文本。\n\n**签名：**\n```hemlock\nfile.write(data: string): i32\n```\n\n**参数：**\n- `data` - 要写入的字符串\n\n**返回值：** 写入的字节数 (i32)\n\n**示例：**\n```hemlock\nlet f = open(\"output.txt\", \"w\");\n\n// 写入文本\nlet written = f.write(\"Hello, World!\\n\");\nprint(\"Wrote\", written, \"bytes\");\n\n// 多次写入\nf.write(\"Line 1\\n\");\nf.write(\"Line 2\\n\");\nf.write(\"Line 3\\n\");\n\nf.close();\n```\n\n**行为：**\n- 在当前文件位置写入\n- 返回写入的字节数\n- 前进文件位置\n\n**错误：**\n- 向已关闭的文件写入\n- 向只读文件写入\n\n---\n\n#### write_bytes\n\n向文件写入二进制数据。\n\n**签名：**\n```hemlock\nfile.write_bytes(data: buffer): i32\n```\n\n**参数：**\n- `data` - 要写入的缓冲区\n\n**返回值：** 写入的字节数 (i32)\n\n**示例：**\n```hemlock\nlet f = open(\"output.bin\", \"w\");\n\n// 创建缓冲区\nlet buf = buffer(10);\nbuf[0] = 65;  // 'A'\nbuf[1] = 66;  // 'B'\nbuf[2] = 67;  // 'C'\n\n// 写入缓冲区\nlet written = f.write_bytes(buf);\nprint(\"Wrote\", written, \"bytes\");\n\nf.close();\n```\n\n**行为：**\n- 将缓冲区内容写入文件\n- 返回写入的字节数\n- 前进文件位置\n\n---\n\n### 定位\n\n#### seek\n\n将文件位置移动到指定的字节偏移量。\n\n**签名：**\n```hemlock\nfile.seek(position: i32): i32\n```\n\n**参数：**\n- `position` - 从文件开头的字节偏移量\n\n**返回值：** 新的文件位置 (i32)\n\n**示例：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\n// 跳转到第 100 字节\nf.seek(100);\n\n// 从该位置读取\nlet chunk = f.read(50);\n\n// 重置到开头\nf.seek(0);\n\n// 从开头读取\nlet all = f.read();\n\nf.close();\n```\n\n**行为：**\n- 将文件位置设置为绝对偏移量\n- 返回新位置\n- 允许定位到文件末尾之后（写入时会在文件中创建空洞）\n\n---\n\n#### tell\n\n获取当前文件位置。\n\n**签名：**\n```hemlock\nfile.tell(): i32\n```\n\n**返回值：** 从文件开头的当前字节偏移量 (i32)\n\n**示例：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\n\nprint(f.tell());        // 0（在开头）\n\nf.read(100);\nprint(f.tell());        // 100（读取后）\n\nf.seek(50);\nprint(f.tell());        // 50（定位后）\n\nf.close();\n```\n\n---\n\n### 关闭\n\n#### close\n\n关闭文件（幂等）。\n\n**签名：**\n```hemlock\nfile.close(): null\n```\n\n**返回值：** `null`\n\n**示例：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\n// 可以安全地多次调用\nf.close();  // 无错误\nf.close();  // 无错误\n```\n\n**行为：**\n- 关闭文件句柄\n- 刷新任何待处理的写入\n- 幂等（可以安全地多次调用）\n- 将 `.closed` 属性设置为 `true`\n\n**重要：** 完成后始终关闭文件以避免文件描述符泄漏。\n\n---\n\n## 文件属性\n\n### .path\n\n获取文件路径。\n\n**类型：** `string`\n\n**访问：** 只读\n\n**示例：**\n```hemlock\nlet f = open(\"/path/to/file.txt\", \"r\");\nprint(f.path);          // \"/path/to/file.txt\"\nf.close();\n```\n\n---\n\n### .mode\n\n获取打开模式。\n\n**类型：** `string`\n\n**访问：** 只读\n\n**示例：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.mode);          // \"r\"\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nprint(f2.mode);         // \"w\"\nf2.close();\n```\n\n---\n\n### .closed\n\n检查文件是否已关闭。\n\n**类型：** `bool`\n\n**访问：** 只读\n\n**示例：**\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nprint(f.closed);        // false\n\nf.close();\nprint(f.closed);        // true\n```\n\n---\n\n## 错误处理\n\n所有文件操作都包含带有上下文的适当错误消息：\n\n### 文件未找到\n```hemlock\nlet f = open(\"missing.txt\", \"r\");\n// 错误：Failed to open 'missing.txt': No such file or directory\n```\n\n### 从已关闭的文件读取\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nf.close();\nf.read();\n// 错误：Cannot read from closed file 'data.txt'\n```\n\n### 向只读文件写入\n```hemlock\nlet f = open(\"readonly.txt\", \"r\");\nf.write(\"data\");\n// 错误：Cannot write to file 'readonly.txt' opened in read-only mode\n```\n\n### 使用 try/catch\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    print(content);\n} catch (e) {\n    print(\"File error:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## 资源管理模式\n\n### 基本模式\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n```\n\n### 带错误处理\n\n```hemlock\nlet f = open(\"data.txt\", \"r\");\ntry {\n    let content = f.read();\n    process(content);\n} finally {\n    f.close();  // 始终关闭，即使出错\n}\n```\n\n### 安全模式\n\n```hemlock\nlet f = null;\ntry {\n    f = open(\"data.txt\", \"r\");\n    let content = f.read();\n    // ... 处理内容 ...\n} catch (e) {\n    print(\"Error:\", e);\n} finally {\n    if (f != null && !f.closed) {\n        f.close();\n    }\n}\n```\n\n---\n\n## 使用示例\n\n### 读取整个文件\n\n```hemlock\nfn read_file(filename: string): string {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content;\n}\n\nlet text = read_file(\"data.txt\");\nprint(text);\n```\n\n### 写入文本文件\n\n```hemlock\nfn write_file(filename: string, content: string) {\n    let f = open(filename, \"w\");\n    f.write(content);\n    f.close();\n}\n\nwrite_file(\"output.txt\", \"Hello, World!\\n\");\n```\n\n### 追加到文件\n\n```hemlock\nfn append_file(filename: string, line: string) {\n    let f = open(filename, \"a\");\n    f.write(line + \"\\n\");\n    f.close();\n}\n\nappend_file(\"log.txt\", \"Log entry 1\");\nappend_file(\"log.txt\", \"Log entry 2\");\n```\n\n### 读取二进制文件\n\n```hemlock\nfn read_binary(filename: string, size: i32): buffer {\n    let f = open(filename, \"r\");\n    let data = f.read_bytes(size);\n    f.close();\n    return data;\n}\n\nlet binary = read_binary(\"data.bin\", 256);\nprint(\"Read\", binary.length, \"bytes\");\n```\n\n### 写入二进制文件\n\n```hemlock\nfn write_binary(filename: string, data: buffer) {\n    let f = open(filename, \"w\");\n    f.write_bytes(data);\n    f.close();\n}\n\nlet buf = buffer(10);\nbuf[0] = 65;\nwrite_binary(\"output.bin\", buf);\n```\n\n### 逐行读取文件\n\n```hemlock\nfn read_lines(filename: string): array {\n    let f = open(filename, \"r\");\n    let content = f.read();\n    f.close();\n    return content.split(\"\\n\");\n}\n\nlet lines = read_lines(\"data.txt\");\nlet i = 0;\nwhile (i < lines.length) {\n    print(\"Line\", i, \":\", lines[i]);\n    i = i + 1;\n}\n```\n\n### 复制文件\n\n```hemlock\nfn copy_file(src: string, dest: string) {\n    let f_in = open(src, \"r\");\n    let f_out = open(dest, \"w\");\n\n    let content = f_in.read();\n    f_out.write(content);\n\n    f_in.close();\n    f_out.close();\n}\n\ncopy_file(\"input.txt\", \"output.txt\");\n```\n\n### 分块读取文件\n\n```hemlock\nfn process_chunks(filename: string) {\n    let f = open(filename, \"r\");\n\n    while (true) {\n        let chunk = f.read(1024);  // 每次读取 1KB\n        if (chunk.length == 0) {\n            break;  // 文件末尾\n        }\n\n        // 处理块\n        print(\"Processing\", chunk.length, \"bytes\");\n    }\n\n    f.close();\n}\n\nprocess_chunks(\"large_file.txt\");\n```\n\n---\n\n## 完整方法总结\n\n| 方法          | 签名                     | 返回值    | 描述                         |\n|---------------|--------------------------|-----------|------------------------------|\n| `read`        | `(size?: i32)`           | `string`  | 读取文本                     |\n| `read_bytes`  | `(size: i32)`            | `buffer`  | 读取二进制数据               |\n| `write`       | `(data: string)`         | `i32`     | 写入文本                     |\n| `write_bytes` | `(data: buffer)`         | `i32`     | 写入二进制数据               |\n| `seek`        | `(position: i32)`        | `i32`     | 设置文件位置                 |\n| `tell`        | `()`                     | `i32`     | 获取文件位置                 |\n| `close`       | `()`                     | `null`    | 关闭文件（幂等）             |\n\n---\n\n## 完整属性总结\n\n| 属性      | 类型     | 访问       | 描述                     |\n|-----------|----------|------------|--------------------------|\n| `.path`   | `string` | 只读       | 文件路径                 |\n| `.mode`   | `string` | 只读       | 打开模式                 |\n| `.closed` | `bool`   | 只读       | 文件是否已关闭           |\n\n---\n\n## 从旧 API 迁移\n\n**旧 API（已移除）：**\n- `read_file(path)` - 使用 `open(path, \"r\").read()`\n- `write_file(path, data)` - 使用 `open(path, \"w\").write(data)`\n- `append_file(path, data)` - 使用 `open(path, \"a\").write(data)`\n- `file_exists(path)` - 暂无替代\n\n**迁移示例：**\n```hemlock\n// 旧版（v0.0）\nlet content = read_file(\"data.txt\");\nwrite_file(\"output.txt\", content);\n\n// 新版（v0.1）\nlet f = open(\"data.txt\", \"r\");\nlet content = f.read();\nf.close();\n\nlet f2 = open(\"output.txt\", \"w\");\nf2.write(content);\nf2.close();\n```\n\n---\n\n## 另请参阅\n\n- [内置函数](#reference-builtins) - `open()` 函数\n- [内存 API](#reference-memory-api) - 缓冲区类型\n- [字符串 API](#reference-string-api) - 用于文本处理的字符串方法\n"}, "API 参考 -> 类型系统": {"id": "reference-type-system", "content": "# 类型系统参考\n\nHemlock 类型系统的完整参考，包括所有原始类型和复合类型。\n\n---\n\n## 概述\n\nHemlock 使用**动态类型系统**，具有运行时类型标签和可选的类型注解。每个值都有运行时类型，类型转换遵循明确的提升规则。\n\n**主要特性：**\n- 运行时类型检查（解释器）\n- 编译时类型检查（hemlockc - 默认启用）\n- 可选类型注解\n- 字面量自动类型推断\n- 明确的类型提升规则\n- 不会隐式转换导致精度损失\n\n---\n\n## 编译时类型检查 (hemlockc)\n\nHemlock 编译器（`hemlockc`）包含编译时类型检查器，在生成可执行文件之前验证您的代码。这可以在不运行程序的情况下及早发现类型错误。\n\n### 默认行为\n\n类型检查在 hemlockc 中**默认启用**：\n\n```bash\n# Type checking happens automatically\nhemlockc program.hml -o program\n\n# Errors are reported before compilation\nhemlockc bad_types.hml\n# Output: 1 type error found\n```\n\n### 编译器标志\n\n| 标志 | 描述 |\n|------|------|\n| `--check` | 仅检查类型，不编译（验证后退出） |\n| `--no-type-check` | 禁用类型检查（不推荐） |\n| `--strict-types` | 启用更严格的类型警告 |\n\n**示例：**\n\n```bash\n# Just validate types without compiling\nhemlockc --check program.hml\n# Output: program.hml: no type errors\n\n# Disable type checking (use with caution)\nhemlockc --no-type-check dynamic_code.hml -o program\n\n# Enable strict warnings for implicit any types\nhemlockc --strict-types program.hml -o program\n```\n\n### 类型检查器验证的内容\n\n1. **类型注解** - 确保赋值的值与声明的类型匹配\n2. **函数调用** - 验证参数类型与参数类型匹配\n3. **返回类型** - 检查返回语句与声明的返回类型匹配\n4. **运算符使用** - 验证操作数兼容\n5. **属性访问** - 验证类型化对象的对象字段类型\n\n### 宽松的数值转换\n\n类型检查器允许在编译时进行数值类型转换，范围验证在运行时进行：\n\n```hemlock\nlet x: i8 = 100;      // OK - 100 fits in i8 (validated at runtime)\nlet y: u8 = 255;      // OK - within u8 range\nlet z: f64 = 42;      // OK - i32 to f64 is safe\n```\n\n### 动态代码支持\n\n没有类型注解的代码被视为动态的（`any` 类型），始终通过类型检查器：\n\n```hemlock\nlet x = get_value();  // Dynamic - no annotation\nprocess(x);           // OK - dynamic values accepted anywhere\n```\n\n---\n\n## 原始类型\n\n### 数值类型\n\n#### 有符号整数\n\n| 类型   | 大小    | 范围                                       | 别名      |\n|--------|---------|-------------------------------------------|-----------|\n| `i8`   | 1 字节  | -128 到 127                               | -         |\n| `i16`  | 2 字节  | -32,768 到 32,767                         | -         |\n| `i32`  | 4 字节  | -2,147,483,648 到 2,147,483,647           | `integer` |\n| `i64`  | 8 字节  | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | - |\n\n**示例：**\n```hemlock\nlet a: i8 = 127;\nlet b: i16 = 32000;\nlet c: i32 = 1000000;\nlet d: i64 = 9223372036854775807;\n\n// Type alias\nlet x: integer = 42;  // Same as i32\n```\n\n#### 无符号整数\n\n| 类型   | 大小    | 范围                      | 别名   |\n|--------|---------|---------------------------|--------|\n| `u8`   | 1 字节  | 0 到 255                  | `byte` |\n| `u16`  | 2 字节  | 0 到 65,535               | -      |\n| `u32`  | 4 字节  | 0 到 4,294,967,295        | -      |\n| `u64`  | 8 字节  | 0 到 18,446,744,073,709,551,615 | - |\n\n**示例：**\n```hemlock\nlet a: u8 = 255;\nlet b: u16 = 65535;\nlet c: u32 = 4294967295;\nlet d: u64 = 18446744073709551615;\n\n// Type alias\nlet byte_val: byte = 65;  // Same as u8\n```\n\n#### 浮点数\n\n| 类型   | 大小    | 精度         | 别名     |\n|--------|---------|--------------|----------|\n| `f32`  | 4 字节  | 约 7 位数字  | -        |\n| `f64`  | 8 字节  | 约 15 位数字 | `number` |\n\n**示例：**\n```hemlock\nlet pi: f32 = 3.14159;\nlet precise: f64 = 3.14159265359;\n\n// Type alias\nlet x: number = 2.718;  // Same as f64\n```\n\n---\n\n### 整数字面量推断\n\n整数字面量根据其值自动确定类型：\n\n**规则：**\n- 在 i32 范围内的值（-2,147,483,648 到 2,147,483,647）：推断为 `i32`\n- 超出 i32 范围但在 i64 范围内的值：推断为 `i64`\n- 其他类型（i8、i16、u8、u16、u32、u64）使用显式类型注解\n\n**示例：**\n```hemlock\nlet small = 42;                    // i32 (fits in i32)\nlet large = 5000000000;            // i64 (> i32 max)\nlet max_i64 = 9223372036854775807; // i64 (INT64_MAX)\nlet explicit: u32 = 100;           // u32 (type annotation overrides)\n```\n\n---\n\n### 布尔类型\n\n**类型：** `bool`\n\n**值：** `true`、`false`\n\n**大小：** 1 字节（内部）\n\n**示例：**\n```hemlock\nlet is_active: bool = true;\nlet done = false;\n\nif (is_active && !done) {\n    print(\"working\");\n}\n```\n\n---\n\n### 字符类型\n\n#### Rune\n\n**类型：** `rune`\n\n**描述：** Unicode 码点 (U+0000 到 U+10FFFF)\n\n**大小：** 4 字节（32 位值）\n\n**范围：** 0 到 0x10FFFF (1,114,111)\n\n**字面量语法：** 单引号 `'x'`\n\n**示例：**\n```hemlock\n// ASCII\nlet a = 'A';\nlet digit = '0';\n\n// Multi-byte UTF-8\nlet rocket = '🚀';      // U+1F680\nlet heart = '❤';        // U+2764\nlet chinese = '中';     // U+4E2D\n\n// Escape sequences\nlet newline = '\\n';\nlet tab = '\\t';\nlet backslash = '\\\\';\nlet quote = '\\'';\nlet null = '\\0';\n\n// Unicode escapes\nlet emoji = '\\u{1F680}';   // Up to 6 hex digits\nlet max = '\\u{10FFFF}';    // Maximum codepoint\n```\n\n**类型转换：**\n```hemlock\n// Integer to rune\nlet code: rune = 65;        // 'A'\nlet r: rune = 128640;       // 🚀\n\n// Rune to integer\nlet value: i32 = 'Z';       // 90\n\n// Rune to string\nlet s: string = 'H';        // \"H\"\n\n// u8 to rune\nlet byte: u8 = 65;\nlet rune_val: rune = byte;  // 'A'\n```\n\n**另请参阅：** [字符串 API](#reference-string-api) 了解字符串 + rune 连接\n\n---\n\n### 字符串类型\n\n**类型：** `string`\n\n**描述：** UTF-8 编码、可变、堆分配的文本\n\n**编码：** UTF-8 (U+0000 到 U+10FFFF)\n\n**可变性：** 可变（与大多数语言不同）\n\n**属性：**\n- `.length` - 码点数（字符数）\n- `.byte_length` - 字节数（UTF-8 编码大小）\n\n**字面量语法：** 双引号 `\"text\"`\n\n**示例：**\n```hemlock\nlet s = \"hello\";\ns[0] = 'H';             // Mutate (now \"Hello\")\nprint(s.length);        // 5 (codepoint count)\nprint(s.byte_length);   // 5 (UTF-8 bytes)\n\nlet emoji = \"🚀\";\nprint(emoji.length);        // 1 (one codepoint)\nprint(emoji.byte_length);   // 4 (four UTF-8 bytes)\n```\n\n**索引：**\n```hemlock\nlet s = \"hello\";\nlet ch = s[0];          // Returns rune 'h'\ns[0] = 'H';             // Set with rune\n```\n\n**另请参阅：** [字符串 API](#reference-string-api) 了解完整的方法参考\n\n---\n\n### 空值类型\n\n**类型：** `null`\n\n**描述：** 空值（表示值的缺失）\n\n**大小：** 8 字节（内部）\n\n**值：** `null`\n\n**示例：**\n```hemlock\nlet x = null;\nlet y: i32 = null;  // ERROR: type mismatch\n\nif (x == null) {\n    print(\"x is null\");\n}\n```\n\n---\n\n## 复合类型\n\n### 数组类型\n\n**类型：** `array`\n\n**描述：** 动态、堆分配、混合类型数组\n\n**属性：**\n- `.length` - 元素数量\n\n**从零开始索引：** 是\n\n**字面量语法：** `[elem1, elem2, ...]`\n\n**示例：**\n```hemlock\nlet arr = [1, 2, 3, 4, 5];\nprint(arr[0]);         // 1\nprint(arr.length);     // 5\n\n// Mixed types\nlet mixed = [1, \"hello\", true, null];\n```\n\n**另请参阅：** [数组 API](#reference-array-api) 了解完整的方法参考\n\n---\n\n### 对象类型\n\n**类型：** `object`\n\n**描述：** JavaScript 风格的动态字段对象\n\n**字面量语法：** `{ field: value, ... }`\n\n**示例：**\n```hemlock\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);  // \"Alice\"\n\n// Add field dynamically\nperson.email = \"alice@example.com\";\n```\n\n**类型定义：**\n```hemlock\ndefine Person {\n    name: string,\n    age: i32,\n    active?: bool,  // Optional field\n}\n\nlet p: Person = { name: \"Bob\", age: 25 };\nprint(typeof(p));  // \"Person\"\n```\n\n---\n\n### 指针类型\n\n#### 原始指针 (ptr)\n\n**类型：** `ptr`\n\n**描述：** 原始内存地址（不安全）\n\n**大小：** 8 字节\n\n**边界检查：** 无\n\n**示例：**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);\n```\n\n#### 缓冲区 (buffer)\n\n**类型：** `buffer`\n\n**描述：** 带边界检查的安全指针包装器\n\n**结构：** 指针 + 长度 + 容量\n\n**属性：**\n- `.length` - 缓冲区大小\n- `.capacity` - 分配的容量\n\n**示例：**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // Bounds checked\nprint(b.length);        // 64\nfree(b);\n```\n\n**另请参阅：** [内存 API](#reference-memory-api) 了解分配函数\n\n---\n\n## 特殊类型\n\n### 文件类型\n\n**类型：** `file`\n\n**描述：** 用于 I/O 操作的文件句柄\n\n**属性：**\n- `.path` - 文件路径（字符串）\n- `.mode` - 打开模式（字符串）\n- `.closed` - 文件是否已关闭（布尔值）\n\n**另请参阅：** [文件 API](#reference-file-api)\n\n---\n\n### 任务类型\n\n**类型：** `task`\n\n**描述：** 并发任务的句柄\n\n**另请参阅：** [并发 API](#reference-concurrency-api)\n\n---\n\n### 通道类型\n\n**类型：** `channel`\n\n**描述：** 线程安全的通信通道\n\n**另请参阅：** [并发 API](#reference-concurrency-api)\n\n---\n\n### 函数类型\n\n**类型：** `function`\n\n**描述：** 一等函数值\n\n**示例：**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet multiply = fn(x, y) {\n    return x * y;\n};\n\nprint(typeof(add));      // \"function\"\nprint(typeof(multiply)); // \"function\"\n```\n\n---\n\n### Void 类型\n\n**类型：** `void`\n\n**描述：** 表示没有返回值（内部使用）\n\n---\n\n## 类型提升规则\n\n当在操作中混合类型时，Hemlock 会提升到\"更高\"的类型：\n\n**提升层级：**\n```\nf64 (highest precision)\n ↑\nf32\n ↑\nu64\n ↑\ni64\n ↑\nu32\n ↑\ni32\n ↑\nu16\n ↑\ni16\n ↑\nu8\n ↑\ni8 (lowest)\n```\n\n**规则：**\n1. 浮点数始终优先于整数\n2. 在相同类别（整数/无符号整数/浮点数）中较大的大小优先\n3. 两个操作数都会提升到结果类型\n4. **精度保持：** i64/u64 + f32 提升到 f64（而不是 f32）\n\n**示例：**\n```hemlock\n// Size promotion\nu8 + i32    → i32    // Larger size wins\ni32 + i64   → i64    // Larger size wins\nu32 + u64   → u64    // Larger size wins\n\n// Float promotion\ni32 + f32   → f32    // Float wins, f32 sufficient for i32\ni64 + f32   → f64    // Promotes to f64 to preserve i64 precision\ni64 + f64   → f64    // Float always wins\ni8 + f64    → f64    // Float + largest wins\n```\n\n**为什么 i64 + f32 → f64？**\n\nf32 只有 24 位尾数，无法精确表示大于 2^24（16,777,216）的整数。由于 i64 可以保存高达 2^63 的值，将 i64 与 f32 混合会导致严重的精度损失。Hemlock 改为提升到 f64（53 位尾数）。\n\n---\n\n## 范围检查\n\n类型注解在赋值时强制进行范围检查：\n\n**有效赋值：**\n```hemlock\nlet x: u8 = 255;             // OK\nlet y: i8 = 127;             // OK\nlet a: i64 = 2147483647;     // OK\nlet b: u64 = 4294967295;     // OK\n```\n\n**无效赋值（运行时错误）：**\n```hemlock\nlet x: u8 = 256;             // ERROR: out of range\nlet y: i8 = 128;             // ERROR: max is 127\nlet z: u64 = -1;             // ERROR: u64 cannot be negative\n```\n\n---\n\n## 类型内省\n\n### typeof(value)\n\n以字符串形式返回类型名称。\n\n**签名：**\n```hemlock\ntypeof(value: any): string\n```\n\n**返回值：**\n- 原始类型：`\"i8\"`、`\"i16\"`、`\"i32\"`、`\"i64\"`、`\"u8\"`、`\"u16\"`、`\"u32\"`、`\"u64\"`、`\"f32\"`、`\"f64\"`、`\"bool\"`、`\"string\"`、`\"rune\"`、`\"null\"`\n- 复合类型：`\"array\"`、`\"object\"`、`\"ptr\"`、`\"buffer\"`、`\"function\"`\n- 特殊类型：`\"file\"`、`\"task\"`、`\"channel\"`\n- 类型化对象：自定义类型名称（例如 `\"Person\"`）\n\n**示例：**\n```hemlock\nprint(typeof(42));              // \"i32\"\nprint(typeof(3.14));            // \"f64\"\nprint(typeof(\"hello\"));         // \"string\"\nprint(typeof('A'));             // \"rune\"\nprint(typeof(true));            // \"bool\"\nprint(typeof([1, 2, 3]));       // \"array\"\nprint(typeof({ x: 10 }));       // \"object\"\n\ndefine Person { name: string }\nlet p: Person = { name: \"Alice\" };\nprint(typeof(p));               // \"Person\"\n```\n\n**另请参阅：** [内置函数](builtins.md#typeof)\n\n---\n\n## 类型转换\n\n### 隐式转换\n\nHemlock 在算术运算中按照类型提升规则执行隐式类型转换。\n\n**示例：**\n```hemlock\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet result = a + b;     // result is i32 (promoted)\n```\n\n### 显式转换\n\n使用类型注解进行显式转换：\n\n**示例：**\n```hemlock\n// Integer to float\nlet i: i32 = 42;\nlet f: f64 = i;         // 42.0\n\n// Float to integer (truncates)\nlet x: f64 = 3.14;\nlet y: i32 = x;         // 3\n\n// Integer to rune\nlet code: rune = 65;    // 'A'\n\n// Rune to integer\nlet value: i32 = 'Z';   // 90\n\n// Rune to string\nlet s: string = 'H';    // \"H\"\n```\n\n---\n\n## 类型别名\n\n### 内置别名\n\nHemlock 为常用类型提供内置类型别名：\n\n| 别名      | 实际类型 | 用途           |\n|-----------|----------|----------------|\n| `integer` | `i32`    | 通用整数       |\n| `number`  | `f64`    | 通用浮点数     |\n| `byte`    | `u8`     | 字节值         |\n\n**示例：**\n```hemlock\nlet count: integer = 100;       // Same as i32\nlet price: number = 19.99;      // Same as f64\nlet b: byte = 255;              // Same as u8\n```\n\n### 自定义类型别名\n\n使用 `type` 关键字定义自定义类型别名：\n\n```hemlock\n// Simple aliases\ntype Integer = i32;\ntype Text = string;\n\n// Function type aliases\ntype Callback = fn(i32): void;\ntype Predicate = fn(any): bool;\ntype BinaryOp = fn(i32, i32): i32;\n\n// Compound type aliases\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ntype Person = HasName & HasAge;\n\n// Generic type aliases\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n```\n\n**使用自定义别名：**\n```hemlock\nlet cb: Callback = fn(n) { print(n); };\nlet p: Person = { name: \"Alice\", age: 30 };\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\n```\n\n**注意：** 类型别名是透明的 - `typeof()` 返回底层类型名称。\n\n---\n\n## 函数类型\n\n函数类型指定函数值的签名：\n\n### 语法\n\n```hemlock\nfn(param_types): return_type\n```\n\n### 示例\n\n```hemlock\n// Basic function type\nlet add: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// Function parameter\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// Higher-order function returning function\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// Async function type\nfn run_async(handler: async fn(): void) {\n    spawn(handler);\n}\n```\n\n---\n\n## 复合类型（交叉类型）\n\n复合类型使用 `&` 来要求多个类型约束：\n\n```hemlock\ndefine HasName { name: string }\ndefine HasAge { age: i32 }\ndefine HasEmail { email: string }\n\n// Object must satisfy all types\nlet person: HasName & HasAge = { name: \"Alice\", age: 30 };\n\n// Three or more types\nfn describe(p: HasName & HasAge & HasEmail) {\n    print(p.name + \" <\" + p.email + \">\");\n}\n```\n\n---\n\n## 汇总表\n\n| 类型       | 大小     | 可变 | 堆分配 | 描述                   |\n|------------|----------|------|--------|------------------------|\n| `i8`-`i64` | 1-8 字节 | 否   | 否     | 有符号整数             |\n| `u8`-`u64` | 1-8 字节 | 否   | 否     | 无符号整数             |\n| `f32`      | 4 字节   | 否   | 否     | 单精度浮点数           |\n| `f64`      | 8 字节   | 否   | 否     | 双精度浮点数           |\n| `bool`     | 1 字节   | 否   | 否     | 布尔值                 |\n| `rune`     | 4 字节   | 否   | 否     | Unicode 码点           |\n| `string`   | 可变     | 是   | 是     | UTF-8 文本             |\n| `array`    | 可变     | 是   | 是     | 动态数组               |\n| `object`   | 可变     | 是   | 是     | 动态对象               |\n| `ptr`      | 8 字节   | 否   | 否     | 原始指针               |\n| `buffer`   | 可变     | 是   | 是     | 安全指针包装器         |\n| `file`     | 不透明   | 是   | 是     | 文件句柄               |\n| `task`     | 不透明   | 否   | 是     | 并发任务句柄           |\n| `channel`  | 不透明   | 是   | 是     | 线程安全通道           |\n| `function` | 不透明   | 否   | 是     | 函数值                 |\n| `null`     | 8 字节   | 否   | 否     | 空值                   |\n\n---\n\n## 另请参阅\n\n- [运算符参考](#reference-operators) - 运算中的类型行为\n- [内置函数](#reference-builtins) - 类型内省和转换\n- [字符串 API](#reference-string-api) - 字符串类型方法\n- [数组 API](#reference-array-api) - 数组类型方法\n- [内存 API](#reference-memory-api) - 指针和缓冲区操作\n"}, "API 参考 -> 运算符": {"id": "reference-operators", "content": "# 运算符参考\n\nHemlock 中所有运算符的完整参考，包括优先级、结合性和行为。\n\n---\n\n## 概述\n\nHemlock 提供 C 风格的运算符，具有明确的优先级规则。所有运算符遵循严格的类型规则，在适用时自动进行类型提升。\n\n---\n\n## 算术运算符\n\n### 二元算术\n\n| 运算符 | 名称   | 示例       | 描述           |\n|--------|--------|------------|----------------|\n| `+`    | 加法   | `a + b`    | 将两个值相加   |\n| `-`    | 减法   | `a - b`    | 从 a 中减去 b  |\n| `*`    | 乘法   | `a * b`    | 将两个值相乘   |\n| `/`    | 除法   | `a / b`    | 将 a 除以 b    |\n\n**类型提升：**\n结果遵循类型提升规则（参见 [类型系统](type-system.md#type-promotion-rules)）。\n\n**示例：**\n```hemlock\nlet a = 10 + 5;        // 15 (i32)\nlet b = 10 - 3;        // 7 (i32)\nlet c = 4 * 5;         // 20 (i32)\nlet d = 20 / 4;        // 5 (i32)\n\n// Float division\nlet e = 10.0 / 3.0;    // 3.333... (f64)\n\n// Mixed types\nlet f: u8 = 10;\nlet g: i32 = 20;\nlet h = f + g;         // 30 (i32, promoted)\n```\n\n**除以零：**\n- 整数除以零：运行时错误\n- 浮点数除以零：返回 `inf` 或 `-inf`\n\n---\n\n### 一元算术\n\n| 运算符 | 名称 | 示例    | 描述         |\n|--------|------|---------|--------------|\n| `-`    | 取负 | `-a`    | 对值取负     |\n| `+`    | 正号 | `+a`    | 恒等（无操作）|\n\n**示例：**\n```hemlock\nlet a = 5;\nlet b = -a;            // -5\nlet c = +a;            // 5 (no change)\n\nlet x = -3.14;         // -3.14\n```\n\n---\n\n## 比较运算符\n\n| 运算符 | 名称       | 示例       | 返回值   |\n|--------|------------|------------|----------|\n| `==`   | 等于       | `a == b`   | `bool`   |\n| `!=`   | 不等于     | `a != b`   | `bool`   |\n| `<`    | 小于       | `a < b`    | `bool`   |\n| `>`    | 大于       | `a > b`    | `bool`   |\n| `<=`   | 小于或等于 | `a <= b`   | `bool`   |\n| `>=`   | 大于或等于 | `a >= b`   | `bool`   |\n\n**类型提升：**\n操作数在比较前会进行提升。\n\n**示例：**\n```hemlock\nprint(5 == 5);         // true\nprint(10 != 5);        // true\nprint(3 < 7);          // true\nprint(10 > 5);         // true\nprint(5 <= 5);         // true\nprint(10 >= 5);        // true\n\n// String comparison\nprint(\"hello\" == \"hello\");  // true\nprint(\"abc\" < \"def\");       // true (lexicographic)\n\n// Mixed types\nlet a: u8 = 10;\nlet b: i32 = 10;\nprint(a == b);         // true (promoted to i32)\n```\n\n---\n\n## 逻辑运算符\n\n| 运算符 | 名称     | 示例         | 描述                 |\n|--------|----------|--------------|----------------------|\n| `&&`   | 逻辑与   | `a && b`     | 两者都为真时返回真   |\n| `||`   | 逻辑或   | `a || b`     | 任一为真时返回真     |\n| `!`    | 逻辑非   | `!a`         | 对布尔值取反         |\n\n**短路求值：**\n- `&&` - 遇到第一个假值时停止\n- `||` - 遇到第一个真值时停止\n\n**示例：**\n```hemlock\nlet a = true;\nlet b = false;\n\nprint(a && b);         // false\nprint(a || b);         // true\nprint(!a);             // false\nprint(!b);             // true\n\n// Short-circuit\nif (x != 0 && (10 / x) > 2) {\n    print(\"safe\");\n}\n\nif (x == 0 || (10 / x) > 2) {\n    print(\"safe\");\n}\n```\n\n---\n\n## 位运算符\n\n**限制：** 仅适用于整数类型 (i8-i64, u8-u64)\n\n### 二元位运算\n\n| 运算符 | 名称     | 示例       | 描述               |\n|--------|----------|------------|--------------------|\n| `&`    | 按位与   | `a & b`    | 对每一位进行与运算 |\n| `|`    | 按位或   | `a | b`    | 对每一位进行或运算 |\n| `^`    | 按位异或 | `a ^ b`    | 对每一位进行异或运算 |\n| `<<`   | 左移     | `a << b`   | 向左移动 b 位      |\n| `>>`   | 右移     | `a >> b`   | 向右移动 b 位      |\n\n**类型保持：**\n结果类型与操作数类型匹配（经过类型提升）。\n\n**示例：**\n```hemlock\nlet a = 12;  // 1100 in binary\nlet b = 10;  // 1010 in binary\n\nprint(a & b);          // 8  (1000)\nprint(a | b);          // 14 (1110)\nprint(a ^ b);          // 6  (0110)\nprint(a << 2);         // 48 (110000)\nprint(a >> 1);         // 6  (110)\n```\n\n**无符号示例：**\n```hemlock\nlet c: u8 = 15;        // 00001111\nlet d: u8 = 7;         // 00000111\n\nprint(c & d);          // 7  (00000111)\nprint(c | d);          // 15 (00001111)\nprint(c ^ d);          // 8  (00001000)\n```\n\n**右移行为：**\n- 有符号类型：算术移位（符号扩展）\n- 无符号类型：逻辑移位（零填充）\n\n---\n\n### 一元位运算\n\n| 运算符 | 名称     | 示例    | 描述           |\n|--------|----------|---------|----------------|\n| `~`    | 按位取反 | `~a`    | 翻转所有位     |\n\n**示例：**\n```hemlock\nlet a = 12;            // 00001100 (i32)\nprint(~a);             // -13 (two's complement)\n\nlet b: u8 = 15;        // 00001111\nprint(~b);             // 240 (11110000)\n```\n\n---\n\n## 字符串运算符\n\n### 连接\n\n| 运算符 | 名称   | 示例       | 描述       |\n|--------|--------|------------|------------|\n| `+`    | 连接   | `a + b`    | 连接字符串 |\n\n**示例：**\n```hemlock\nlet s = \"hello\" + \" \" + \"world\";  // \"hello world\"\nlet msg = \"Count: \" + typeof(42); // \"Count: 42\"\n\n// String + rune\nlet greeting = \"Hello\" + '!';      // \"Hello!\"\n\n// Rune + string\nlet prefix = '>' + \" Message\";     // \"> Message\"\n```\n\n---\n\n## 赋值运算符\n\n### 基本赋值\n\n| 运算符 | 名称   | 示例       | 描述           |\n|--------|--------|------------|----------------|\n| `=`    | 赋值   | `a = b`    | 将值赋给变量   |\n\n**示例：**\n```hemlock\nlet x = 10;\nx = 20;\n\nlet arr = [1, 2, 3];\narr[0] = 99;\n\nlet obj = { x: 10 };\nobj.x = 20;\n```\n\n### 复合赋值\n\n#### 算术复合赋值\n\n| 运算符 | 名称       | 示例       | 等价于             |\n|--------|------------|------------|--------------------|\n| `+=`   | 加法赋值   | `a += b`   | `a = a + b`        |\n| `-=`   | 减法赋值   | `a -= b`   | `a = a - b`        |\n| `*=`   | 乘法赋值   | `a *= b`   | `a = a * b`        |\n| `/=`   | 除法赋值   | `a /= b`   | `a = a / b`        |\n| `%=`   | 取模赋值   | `a %= b`   | `a = a % b`        |\n\n**示例：**\n```hemlock\nlet x = 10;\nx += 5;      // x is now 15\nx -= 3;      // x is now 12\nx *= 2;      // x is now 24\nx /= 4;      // x is now 6\n\nlet count = 0;\ncount += 1;  // Increment by 1\n```\n\n#### 位运算复合赋值\n\n| 运算符 | 名称           | 示例        | 等价于              |\n|--------|----------------|-------------|---------------------|\n| `&=`   | 按位与赋值     | `a &= b`    | `a = a & b`         |\n| `\\|=`  | 按位或赋值     | `a \\|= b`   | `a = a \\| b`        |\n| `^=`   | 按位异或赋值   | `a ^= b`    | `a = a ^ b`         |\n| `<<=`  | 左移赋值       | `a <<= b`   | `a = a << b`        |\n| `>>=`  | 右移赋值       | `a >>= b`   | `a = a >> b`        |\n\n**示例：**\n```hemlock\nlet flags = 0b1111;\nflags &= 0b0011;   // flags is now 0b0011 (mask off upper bits)\nflags |= 0b1000;   // flags is now 0b1011 (set a bit)\nflags ^= 0b0001;   // flags is now 0b1010 (toggle a bit)\n\nlet x = 1;\nx <<= 4;           // x is now 16 (shift left by 4)\nx >>= 2;           // x is now 4 (shift right by 2)\n```\n\n### 自增/自减\n\n| 运算符 | 名称   | 示例    | 描述                 |\n|--------|--------|---------|----------------------|\n| `++`   | 自增   | `a++`   | 加 1（后缀）         |\n| `--`   | 自减   | `a--`   | 减 1（后缀）         |\n\n**示例：**\n```hemlock\nlet i = 0;\ni++;         // i is now 1\ni++;         // i is now 2\ni--;         // i is now 1\n\n// Common in loops\nfor (let j = 0; j < 10; j++) {\n    print(j);\n}\n```\n\n**注意：** `++` 和 `--` 都是后缀运算符（在自增/自减之前返回值）\n\n---\n\n## 空值安全运算符\n\n### 空值合并 (`??`)\n\n如果左操作数不为空则返回左操作数，否则返回右操作数。\n\n| 运算符 | 名称       | 示例         | 描述                       |\n|--------|------------|--------------|----------------------------|\n| `??`   | 空值合并   | `a ?? b`     | 如果 a 非空返回 a，否则返回 b |\n\n**示例：**\n```hemlock\nlet name = null;\nlet display = name ?? \"Anonymous\";  // \"Anonymous\"\n\nlet value = 42;\nlet result = value ?? 0;            // 42\n\n// Chaining\nlet a = null;\nlet b = null;\nlet c = \"found\";\nlet result2 = a ?? b ?? c;          // \"found\"\n\n// With function calls\nfn get_config() { return null; }\nlet config = get_config() ?? { default: true };\n```\n\n---\n\n### 可选链 (`?.`)\n\n安全地访问可能为空的值的属性或调用方法。\n\n| 运算符 | 名称       | 示例           | 描述                             |\n|--------|------------|----------------|----------------------------------|\n| `?.`   | 可选链     | `a?.b`         | 如果 a 非空返回 a.b，否则返回 null |\n| `?.[`  | 可选索引   | `a?.[0]`       | 如果 a 非空返回 a[0]，否则返回 null |\n| `?.(`  | 可选调用   | `a?.()`        | 如果 a 非空调用 a()，否则返回 null |\n\n**示例：**\n```hemlock\nlet user = null;\nlet name = user?.name;              // null (no error)\n\nlet person = { name: \"Alice\", address: null };\nlet city = person?.address?.city;   // null (safe navigation)\n\n// With arrays\nlet arr = null;\nlet first = arr?.[0];               // null\n\nlet items = [1, 2, 3];\nlet second = items?.[1];            // 2\n\n// With method calls\nlet obj = { greet: fn() { return \"Hello\"; } };\nlet greeting = obj?.greet?.();      // \"Hello\"\n\nlet empty = null;\nlet result = empty?.method?.();     // null\n```\n\n**行为：**\n- 如果左操作数为空，整个表达式短路返回 null\n- 如果左操作数非空，正常进行访问\n- 可以链接用于深层属性访问\n\n---\n\n## 成员访问运算符\n\n### 点运算符\n\n| 运算符 | 名称       | 示例         | 描述           |\n|--------|------------|--------------|----------------|\n| `.`    | 成员访问   | `obj.field`  | 访问对象字段   |\n| `.`    | 属性访问   | `arr.length` | 访问属性       |\n\n**示例：**\n```hemlock\n// Object field access\nlet person = { name: \"Alice\", age: 30 };\nprint(person.name);        // \"Alice\"\n\n// Array property\nlet arr = [1, 2, 3];\nprint(arr.length);         // 3\n\n// String property\nlet s = \"hello\";\nprint(s.length);           // 5\n\n// Method call\nlet result = s.to_upper(); // \"HELLO\"\n```\n\n---\n\n### 索引运算符\n\n| 运算符 | 名称   | 示例      | 描述       |\n|--------|--------|-----------|------------|\n| `[]`   | 索引   | `arr[i]`  | 访问元素   |\n\n**示例：**\n```hemlock\n// Array indexing\nlet arr = [10, 20, 30];\nprint(arr[0]);             // 10\narr[1] = 99;\n\n// String indexing (returns rune)\nlet s = \"hello\";\nprint(s[0]);               // 'h'\ns[0] = 'H';                // \"Hello\"\n\n// Buffer indexing\nlet buf = buffer(10);\nbuf[0] = 65;\nprint(buf[0]);             // 65\n```\n\n---\n\n## 函数调用运算符\n\n| 运算符 | 名称       | 示例         | 描述       |\n|--------|------------|--------------|------------|\n| `()`   | 函数调用   | `f(a, b)`    | 调用函数   |\n\n**示例：**\n```hemlock\nfn add(a, b) {\n    return a + b;\n}\n\nlet result = add(5, 3);    // 8\n\n// Method call\nlet s = \"hello\";\nlet upper = s.to_upper();  // \"HELLO\"\n\n// Builtin call\nprint(\"message\");\n```\n\n---\n\n## 运算符优先级\n\n运算符按从高到低的优先级排列：\n\n| 优先级 | 运算符                       | 描述                           | 结合性     |\n|--------|------------------------------|--------------------------------|------------|\n| 1      | `()` `[]` `.` `?.`           | 调用、索引、成员访问、可选链   | 从左到右   |\n| 2      | `++` `--`                    | 后缀自增/自减                  | 从左到右   |\n| 3      | `!` `~` `-` (一元) `+` (一元)| 逻辑非、按位取反、取负         | 从右到左   |\n| 4      | `*` `/` `%`                  | 乘法、除法、取模               | 从左到右   |\n| 5      | `+` `-`                      | 加法、减法                     | 从左到右   |\n| 6      | `<<` `>>`                    | 位移                           | 从左到右   |\n| 7      | `<` `<=` `>` `>=`            | 关系运算                       | 从左到右   |\n| 8      | `==` `!=`                    | 相等运算                       | 从左到右   |\n| 9      | `&`                          | 按位与                         | 从左到右   |\n| 10     | `^`                          | 按位异或                       | 从左到右   |\n| 11     | `|`                          | 按位或                         | 从左到右   |\n| 12     | `&&`                         | 逻辑与                         | 从左到右   |\n| 13     | `||`                         | 逻辑或                         | 从左到右   |\n| 14     | `??`                         | 空值合并                       | 从左到右   |\n| 15     | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\\|=` `^=` `<<=` `>>=` | 赋值 | 从右到左   |\n\n---\n\n## 优先级示例\n\n### 示例 1：算术和比较\n```hemlock\nlet result = 5 + 3 * 2;\n// Evaluated as: 5 + (3 * 2) = 11\n// Multiplication has higher precedence than addition\n\nlet cmp = 10 > 5 + 3;\n// Evaluated as: 10 > (5 + 3) = true\n// Addition has higher precedence than comparison\n```\n\n### 示例 2：位运算符\n```hemlock\nlet result1 = 12 | 10 & 8;\n// Evaluated as: 12 | (10 & 8) = 12 | 8 = 12\n// & has higher precedence than |\n\nlet result2 = 8 | 1 << 2;\n// Evaluated as: 8 | (1 << 2) = 8 | 4 = 12\n// Shift has higher precedence than bitwise OR\n\n// Use parentheses for clarity\nlet result3 = (5 & 3) | (2 << 1);\n// Evaluated as: 1 | 4 = 5\n```\n\n### 示例 3：逻辑运算符\n```hemlock\nlet result = true || false && false;\n// Evaluated as: true || (false && false) = true\n// && has higher precedence than ||\n\nlet cmp = 5 < 10 && 10 < 20;\n// Evaluated as: (5 < 10) && (10 < 20) = true\n// Comparison has higher precedence than &&\n```\n\n### 示例 4：使用括号\n```hemlock\n// Without parentheses\nlet a = 2 + 3 * 4;        // 14\n\n// With parentheses\nlet b = (2 + 3) * 4;      // 20\n\n// Complex expression\nlet c = (a + b) * (a - b);\n```\n\n---\n\n## 类型特定的运算符行为\n\n### 除法（始终返回浮点数）\n\n`/` 运算符**始终返回浮点数** (f64)，无论操作数类型：\n\n```hemlock\nprint(10 / 3);             // 3.333... (f64)\nprint(5 / 2);              // 2.5 (f64)\nprint(10.0 / 4.0);         // 2.5 (f64)\nprint(-7 / 3);             // -2.333... (f64)\n```\n\n这可以防止常见的意外整数截断错误。\n\n### 地板除法 (div / divi)\n\n对于地板除法（类似其他语言中的整数除法），使用 `div()` 和 `divi()` 函数：\n\n```hemlock\n// div(a, b) - floor division returning float\nprint(div(5, 2));          // 2 (f64)\nprint(div(-7, 3));         // -3 (f64)  -- floors toward -infinity\n\n// divi(a, b) - floor division returning integer\nprint(divi(5, 2));         // 2 (i64)\nprint(divi(-7, 3));        // -3 (i64)\nprint(typeof(divi(5, 2))); // i64\n```\n\n**返回整数的数学函数：**\n对于其他返回整数的舍入操作：\n\n```hemlock\nprint(floori(3.7));        // 3 (i64)\nprint(ceili(3.2));         // 4 (i64)\nprint(roundi(3.5));        // 4 (i64)\nprint(trunci(3.9));        // 3 (i64)\n\n// These can be used directly as array indices\nlet arr = [10, 20, 30, 40];\nprint(arr[floori(1.9)]);   // 20 (index 1)\n```\n\n### 字符串比较\n\n字符串按字典序比较：\n\n```hemlock\nprint(\"abc\" < \"def\");      // true\nprint(\"apple\" > \"banana\"); // false\nprint(\"hello\" == \"hello\"); // true\n```\n\n### 空值比较\n\n```hemlock\nlet x = null;\n\nprint(x == null);          // true\nprint(x != null);          // false\n```\n\n### 类型错误\n\n某些操作不允许在不兼容的类型之间进行：\n\n```hemlock\n// ERROR: Cannot use bitwise operators on floats\nlet x = 3.14 & 2.71;\n\n// ERROR: Cannot use bitwise operators on strings\nlet y = \"hello\" & \"world\";\n\n// OK: Type promotion for arithmetic\nlet a: u8 = 10;\nlet b: i32 = 20;\nlet c = a + b;             // i32 (promoted)\n```\n\n---\n\n## 另请参阅\n\n- [类型系统](#reference-type-system) - 类型提升和转换规则\n- [内置函数](#reference-builtins) - 内置操作\n- [字符串 API](#reference-string-api) - 字符串连接和方法\n"}, "设计与理念 -> 实现细节": {"id": "design-implementation", "content": "# Hemlock 实现细节\n\n本文档描述了 Hemlock 语言的技术实现，包括项目结构、编译流水线、运行时架构和设计决策。\n\n---\n\n## 目录\n\n- [项目结构](#项目结构)\n- [编译流水线](#编译流水线)\n- [模块化解释器设计](#模块化解释器设计)\n- [运行时架构](#运行时架构)\n- [值表示](#值表示)\n- [类型系统实现](#类型系统实现)\n- [内存管理](#内存管理)\n- [并发模型](#并发模型)\n- [未来计划](#未来计划)\n\n---\n\n## 项目结构\n\n```\nhemlock/\n├── src/\n│   ├── frontend/              # 共享：词法分析器、解析器、AST\n│   │   ├── lexer.c            # 词法分析\n│   │   ├── parser/            # 递归下降解析器\n│   │   ├── ast.c              # AST 节点管理\n│   │   └── module.c           # 模块解析\n│   ├── backends/\n│   │   ├── interpreter/       # hemlock：树遍历解释器\n│   │   │   ├── main.c         # CLI 入口点\n│   │   │   ├── runtime.c      # 表达式/语句求值\n│   │   │   ├── builtins.c     # 内置函数\n│   │   │   └── ...\n│   │   └── compiler/          # hemlockc：C 代码生成器\n│   │       ├── main.c         # CLI、编排\n│   │       ├── type_check.c   # 编译时类型检查\n│   │       ├── codegen.c      # 代码生成上下文\n│   │       ├── codegen_expr.c # 表达式代码生成\n│   │       ├── codegen_stmt.c # 语句代码生成\n│   │       └── ...\n│   ├── tools/\n│   │   ├── lsp/               # 语言服务器协议\n│   │   └── bundler/           # 打包/包工具\n├── runtime/                   # libhemlock_runtime.a（用于编译后的程序）\n├── stdlib/                    # 标准库（39 个模块）\n│   └── docs/                  # 模块文档\n├── tests/\n│   ├── parity/                # 必须在两个后端都通过的测试\n│   ├── interpreter/           # 解释器特定测试\n│   └── compiler/              # 编译器特定测试\n├── examples/                  # 示例程序\n└── docs/                      # 文档\n```\n\n### 目录组织\n\n**`include/`** - 定义组件间接口的公共 API 头文件：\n- 词法分析器、解析器、AST 和解释器之间的清晰分离\n- 前向声明以最小化依赖\n- 用于在其他程序中嵌入 Hemlock 的公共 API\n\n**`src/`** - 实现文件：\n- 顶层文件处理词法分析、解析、AST 管理\n- `main.c` 提供 CLI 和 REPL\n- 解释器模块化为独立的子系统\n\n**`src/interpreter/`** - 模块化解释器实现：\n- 每个模块有单一、清晰的职责\n- 内部 API 在 `internal.h` 中定义用于模块间通信\n- 模块可以独立编译以加快构建速度\n\n**`tests/`** - 全面的测试套件：\n- 按功能区域组织\n- 每个目录包含专注的测试用例\n- `run_tests.sh` 编排测试执行\n\n---\n\n## 编译流水线\n\nHemlock 使用传统的编译流水线，具有不同的阶段：\n\n### 阶段 1：词法分析（Lexer）\n\n**输入：**源代码文本\n**输出：**Token 流\n**实现：**`src/lexer.c`\n\n```\n源码: \"let x = 42;\"\n   ↓\nTokens: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n```\n\n**主要特性：**\n- 识别关键字、标识符、字面量、运算符、标点符号\n- 处理 UTF-8 字符串字面量和 rune 字面量\n- 报告行号用于错误消息\n- 单遍，无回溯\n\n### 阶段 2：语法分析（Parser）\n\n**输入：**Token 流\n**输出：**抽象语法树（AST）\n**实现：**`src/parser.c`\n\n```\nTokens: [LET, IDENTIFIER(\"x\"), EQUALS, INTEGER(42), SEMICOLON]\n   ↓\nAST: LetStmt {\n    name: \"x\",\n    type: null,\n    value: IntLiteral(42)\n}\n```\n\n**主要特性：**\n- 递归下降解析器\n- 构建程序结构的树表示\n- 处理运算符优先级\n- 验证语法（大括号、分号等）\n- 还没有语义分析（在运行时完成）\n\n**运算符优先级（从低到高）：**\n1. 赋值：`=`\n2. 逻辑或：`||`\n3. 逻辑与：`&&`\n4. 按位或：`|`\n5. 按位异或：`^`\n6. 按位与：`&`\n7. 相等：`==`、`!=`\n8. 比较：`<`、`>`、`<=`、`>=`\n9. 位移：`<<`、`>>`\n10. 加法/减法：`+`、`-`\n11. 乘法/除法/取模：`*`、`/`、`%`\n12. 一元：`!`、`-`、`~`\n13. 调用/索引/成员：`()`、`[]`、`.`\n\n### 阶段 3a：解释执行（树遍历）\n\n**输入：**AST\n**输出：**程序执行\n**实现：**`src/backends/interpreter/runtime.c`\n\n```\nAST: LetStmt { ... }\n   ↓\n执行: 递归求值 AST 节点\n   ↓\n结果: 创建值为 42 的变量 x\n```\n\n**主要特性：**\n- 直接 AST 遍历（树遍历解释器）\n- 运行时动态类型检查\n- 基于环境的变量存储\n\n### 阶段 3b：编译（hemlockc）\n\n**输入：**AST\n**输出：**通过 C 代码生成的原生可执行文件\n**实现：**`src/backends/compiler/`\n\n```\nAST: LetStmt { ... }\n   ↓\n类型检查: 编译时验证类型\n   ↓\nC 代码生成: 生成等效的 C 代码\n   ↓\nGCC: 将 C 编译为原生二进制文件\n   ↓\n结果: 独立可执行文件\n```\n\n**主要特性：**\n- 编译时类型检查（默认启用）\n- C 代码生成以实现可移植性\n- 链接 `libhemlock_runtime.a`\n- 比解释器执行速度显著更快\n\n---\n\n## 编译器后端（hemlockc）\n\nHemlock 编译器从 AST 生成 C 代码，然后使用 GCC 编译为原生可执行文件。\n\n### 编译器架构\n\n```\nsrc/backends/compiler/\n├── main.c              # CLI、参数解析、编排\n├── codegen.c           # 核心代码生成上下文\n├── codegen_expr.c      # 表达式代码生成\n├── codegen_stmt.c      # 语句代码生成\n├── codegen_call.c      # 函数调用生成\n├── codegen_closure.c   # 闭包实现\n├── codegen_program.c   # 顶层程序生成\n├── codegen_module.c    # 模块/导入处理\n├── type_check.c        # 编译时类型检查\n└── type_check.h        # 类型检查器 API\n```\n\n### 类型检查\n\n编译器包含统一的类型检查系统，可以：\n\n1. **编译时验证类型** - 在执行前捕获类型错误\n2. **支持动态代码** - 无类型代码视为 `any`（始终有效）\n3. **提供优化提示** - 识别可以拆箱的变量\n\n**类型检查标志：**\n\n| 标志 | 描述 |\n|------|-------------|\n| （默认） | 启用类型检查 |\n| `--check` | 仅类型检查，不编译 |\n| `--no-type-check` | 禁用类型检查 |\n| `--strict-types` | 对隐式 `any` 类型发出警告 |\n\n**类型检查器实现：**\n\n```c\n// type_check.h - 关键结构\ntypedef struct TypeCheckContext {\n    const char *filename;\n    int error_count;\n    int warning_count;\n    UnboxableVar *unboxable_vars;  // 优化提示\n    // ... 类型环境、定义等\n} TypeCheckContext;\n\n// 主入口点\nint type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);\n```\n\n### 代码生成\n\n代码生成阶段将 AST 节点转换为 C 代码：\n\n**表达式映射：**\n```\nHemlock                 →  生成的 C\n----------------------------------------\nlet x = 42;            →  HmlValue x = hml_val_i32(42);\nx + y                  →  hml_add(x, y)\narr[i]                 →  hml_array_get(arr, i)\nobj.field              →  hml_object_get_field(obj, \"field\")\nfn(a, b) { ... }       →  带环境捕获的闭包\n```\n\n**运行时集成：**\n\n生成的 C 代码链接 `libhemlock_runtime.a`，它提供：\n- `HmlValue` 标记联合类型\n- 内存管理（引用计数）\n- 内置函数（print、typeof 等）\n- 并发原语（任务、通道）\n- FFI 支持\n\n### 拆箱优化\n\n类型检查器识别可以使用原生 C 类型而不是装箱 `HmlValue` 的变量：\n\n**可拆箱模式：**\n- 已知整数类型的循环计数器\n- 循环中的累加器变量\n- 带显式类型注解的变量（i32、i64、f64、bool）\n\n```hemlock\n// 循环计数器 'i' 可以拆箱为原生 int32_t\nfor (let i: i32 = 0; i < 1000000; i = i + 1) {\n    sum = sum + i;\n}\n```\n\n---\n\n## 模块化解释器设计\n\n解释器被分割成专注的模块以提高可维护性和可扩展性。\n\n### 模块职责\n\n#### 1. 环境（`environment.c`）- 121 行\n\n**目的：**变量作用域和名称解析\n\n**关键函数：**\n- `env_create()` - 创建带可选父级的新环境\n- `env_define()` - 在当前作用域定义新变量\n- `env_get()` - 在当前或父作用域查找变量\n- `env_set()` - 更新现有变量值\n- `env_free()` - 释放环境及所有变量\n\n**设计：**\n- 链式作用域（每个环境有指向父级的指针）\n- HashMap 用于快速变量查找\n- 支持闭包的词法作用域\n\n#### 2. 值（`values.c`）- 394 行\n\n**目的：**值构造函数和数据结构管理\n\n**关键函数：**\n- `value_create_*()` - 每种值类型的构造函数\n- `value_copy()` - 深拷贝/浅拷贝逻辑\n- `value_free()` - 清理和内存释放\n- `value_to_string()` - 用于打印的字符串表示\n\n**数据结构：**\n- 对象（动态字段数组）\n- 数组（动态调整大小）\n- 缓冲区（ptr + length + capacity）\n- 闭包（函数 + 捕获的环境）\n- 任务和通道（并发原语）\n\n#### 3. 类型（`types.c`）- 440 行\n\n**目的：**类型系统、转换和鸭子类型\n\n**关键函数：**\n- `type_check()` - 运行时类型验证\n- `type_convert()` - 隐式类型转换/提升\n- `duck_type_check()` - 对象的结构类型检查\n- `type_name()` - 获取可打印的类型名称\n\n**特性：**\n- 类型提升层次（i8 → i16 → i32 → i64 → f32 → f64，i64/u64 + f32 → f64）\n- 数值类型的范围检查\n- 对象类型定义的鸭子类型\n- 可选字段默认值\n\n#### 4. 内置函数（`builtins.c`）- 955 行\n\n**目的：**内置函数和全局注册\n\n**关键函数：**\n- `register_builtins()` - 注册所有内置函数和常量\n- 内置函数实现（print、typeof、alloc、free 等）\n- 信号处理函数\n- 命令执行（exec）\n\n**内置函数类别：**\n- I/O：print、open、read_file、write_file\n- 内存：alloc、free、memset、memcpy、realloc\n- 类型：typeof、assert\n- 并发：spawn、join、detach、channel\n- 系统：exec、signal、raise、panic\n- FFI：dlopen、dlsym、dlcall、dlclose\n\n#### 5. I/O（`io.c`）- 449 行\n\n**目的：**文件 I/O 和 JSON 序列化\n\n**关键函数：**\n- 文件对象方法（read、write、seek、tell、close）\n- JSON 序列化/反序列化\n- 循环引用检测\n\n**特性：**\n- 带属性的文件对象（path、mode、closed）\n- UTF-8 感知的文本 I/O\n- 二进制 I/O 支持\n- 对象和数组的 JSON 往返\n\n#### 6. FFI（`ffi.c`）- 外部函数接口\n\n**目的：**从共享库调用 C 函数\n\n**关键函数：**\n- `dlopen()` - 加载共享库\n- `dlsym()` - 按名称获取函数指针\n- `dlcall()` - 调用带类型转换的 C 函数\n- `dlclose()` - 卸载库\n\n**特性：**\n- 与 libffi 集成用于动态函数调用\n- 自动类型转换（Hemlock ↔ C 类型）\n- 支持所有原始类型\n- 指针和缓冲区支持\n\n#### 7. 运行时（`runtime.c`）- 865 行\n\n**目的：**表达式求值和语句执行\n\n**关键函数：**\n- `eval_expr()` - 求值表达式（递归）\n- `eval_stmt()` - 执行语句\n- 控制流处理（if、while、for、switch 等）\n- 异常处理（try/catch/finally/throw）\n\n**特性：**\n- 递归表达式求值\n- 短路布尔求值\n- 方法调用检测和 `self` 绑定\n- 异常传播\n- break/continue/return 处理\n\n### 模块化设计的好处\n\n**1. 关注点分离**\n- 每个模块有一个清晰的职责\n- 容易找到特性的实现位置\n- 减少更改时的认知负担\n\n**2. 更快的增量构建**\n- 只有修改的模块需要重新编译\n- 可能进行并行编译\n- 开发期间更短的迭代时间\n\n**3. 更容易的测试和调试**\n- 模块可以独立测试\n- 错误定位到特定子系统\n- 可能使用模拟实现进行测试\n\n**4. 可扩展性**\n- 新特性可以添加到适当的模块\n- 模块可以独立重构\n- 每个文件的代码量保持可管理\n\n**5. 代码组织**\n- 相关功能的逻辑分组\n- 清晰的依赖图\n- 新贡献者更容易上手\n\n---\n\n## 运行时架构\n\n### 值表示\n\nHemlock 中的所有值都由使用标记联合的 `Value` 结构表示：\n\n```c\ntypedef struct Value {\n    ValueType type;  // 运行时类型标签\n    union {\n        int32_t i32_value;\n        int64_t i64_value;\n        uint8_t u8_value;\n        uint32_t u32_value;\n        uint64_t u64_value;\n        float f32_value;\n        double f64_value;\n        bool bool_value;\n        char *string_value;\n        uint32_t rune_value;\n        void *ptr_value;\n        Buffer *buffer_value;\n        Array *array_value;\n        Object *object_value;\n        Function *function_value;\n        File *file_value;\n        Task *task_value;\n        Channel *channel_value;\n    };\n} Value;\n```\n\n**设计决策：**\n- **标记联合**用于类型安全同时保持灵活性\n- **运行时类型标签**启用带类型检查的动态类型\n- **直接值存储**用于原始类型（无装箱）\n- **指针存储**用于堆分配类型（字符串、对象、数组）\n\n### 内存布局示例\n\n**整数（i32）：**\n```\nValue {\n    type: TYPE_I32,\n    i32_value: 42\n}\n```\n- 总大小：约 16 字节（8 字节标签 + 8 字节联合）\n- 栈分配\n- 不需要堆分配\n\n**字符串：**\n```\nValue {\n    type: TYPE_STRING,\n    string_value: 0x7f8a4c000000  // 指向堆的指针\n}\n\n堆: \"hello\\0\"（6 字节，以 null 结尾的 UTF-8）\n```\n- 值在栈上占 16 字节\n- 字符串数据是堆分配的\n- 必须手动释放\n\n**对象：**\n```\nValue {\n    type: TYPE_OBJECT,\n    object_value: 0x7f8a4c001000  // 指向堆的指针\n}\n\n堆: Object {\n    type_name: \"Person\",\n    fields: [\n        { name: \"name\", value: Value{TYPE_STRING, \"Alice\"} },\n        { name: \"age\", value: Value{TYPE_I32, 30} }\n    ],\n    field_count: 2,\n    capacity: 4\n}\n```\n- 对象结构在堆上\n- 字段存储在动态数组中\n- 字段值是嵌入的 Value 结构\n\n### 环境实现\n\n变量存储在环境链中：\n\n```c\ntypedef struct Environment {\n    HashMap *bindings;           // name → Value\n    struct Environment *parent;  // 词法父作用域\n} Environment;\n```\n\n**作用域链示例：**\n```\n全局作用域: { print: <builtin>, args: <array> }\n    ↑\n函数作用域: { x: 10, y: 20 }\n    ↑\n块作用域: { i: 0 }\n```\n\n**查找算法：**\n1. 检查当前环境的 hashmap\n2. 如果未找到，检查父环境\n3. 重复直到找到或到达全局作用域\n4. 如果在任何作用域都未找到则报错\n\n---\n\n## 类型系统实现\n\n### 类型检查策略\n\nHemlock 使用**运行时类型检查**和**可选类型注解**：\n\n```hemlock\nlet x = 42;           // 无类型检查，推断为 i32\nlet y: u8 = 255;      // 运行时检查：值必须适合 u8\nlet z: i32 = x + y;   // 运行时检查 + 类型提升\n```\n\n**实现流程：**\n1. **字面量推断** - 词法分析器/解析器从字面量确定初始类型\n2. **类型注解检查** - 如果存在注解，在赋值时验证\n3. **提升** - 二元操作提升到公共类型\n4. **转换** - 显式转换按需发生\n\n### 类型提升实现\n\n类型提升遵循固定层次并保持精度：\n\n```c\n// 简化的提升逻辑\nValueType promote_types(ValueType a, ValueType b) {\n    // f64 始终获胜\n    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;\n\n    // f32 与 i64/u64 提升到 f64（精度保持）\n    if (a == TYPE_F32 || b == TYPE_F32) {\n        ValueType other = (a == TYPE_F32) ? b : a;\n        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;\n        return TYPE_F32;\n    }\n\n    // 较大的整数类型获胜\n    int rank_a = get_type_rank(a);\n    int rank_b = get_type_rank(b);\n    return (rank_a > rank_b) ? a : b;\n}\n```\n\n**类型等级：**\n- i8: 0\n- u8: 1\n- i16: 2\n- u16: 3\n- i32: 4\n- u32: 5\n- i64: 6\n- u64: 7\n- f32: 8\n- f64: 9\n\n### 鸭子类型实现\n\n对象类型检查使用结构比较：\n\n```c\nbool duck_type_check(Object *obj, TypeDef *type_def) {\n    // 检查所有必需字段\n    for (each field in type_def) {\n        if (!object_has_field(obj, field.name)) {\n            return false;  // 缺少字段\n        }\n\n        Value *field_value = object_get_field(obj, field.name);\n        if (!type_matches(field_value, field.type)) {\n            return false;  // 类型错误\n        }\n    }\n\n    return true;  // 所有必需字段存在且类型正确\n}\n```\n\n**鸭子类型允许：**\n- 对象中的额外字段（被忽略）\n- 子结构类型（对象可以有比要求更多的）\n- 验证后的类型名称分配\n\n---\n\n## 内存管理\n\n### 分配策略\n\nHemlock 使用**手动内存管理**，有两种分配原语：\n\n**1. 原始指针（`ptr`）：**\n```c\nvoid *alloc(size_t bytes) {\n    void *ptr = malloc(bytes);\n    if (!ptr) {\n        fprintf(stderr, \"Out of memory\\n\");\n        exit(1);\n    }\n    return ptr;\n}\n```\n- 直接 malloc/free\n- 无跟踪\n- 用户负责释放\n\n**2. 缓冲区（`buffer`）：**\n```c\ntypedef struct Buffer {\n    void *data;\n    size_t length;\n    size_t capacity;\n} Buffer;\n\nBuffer *create_buffer(size_t size) {\n    Buffer *buf = malloc(sizeof(Buffer));\n    buf->data = malloc(size);\n    buf->length = size;\n    buf->capacity = size;\n    return buf;\n}\n```\n- 跟踪大小和容量\n- 访问时边界检查\n- 仍然需要手动 free\n\n### 堆分配类型\n\n**字符串：**\n- 堆上的 UTF-8 字节数组\n- 以 null 结尾用于 C 互操作\n- 可变（可以原地修改）\n- 引用计数（作用域退出时自动释放）\n\n**对象：**\n- 动态字段数组\n- 字段名和值在堆上\n- 引用计数（作用域退出时自动释放）\n- 可能存在循环引用（用 visited-set 跟踪处理）\n\n**数组：**\n- 动态容量倍增增长\n- 元素是嵌入的 Value 结构\n- 增长时自动重新分配\n- 引用计数（作用域退出时自动释放）\n\n**闭包：**\n- 通过引用捕获环境\n- 环境是堆分配的\n- 闭包环境在不再引用时正确释放\n\n---\n\n## 并发模型\n\n### 线程架构\n\nHemlock 使用 POSIX 线程（pthreads）的 **1:1 线程**模型：\n\n```\n用户任务          操作系统线程          CPU 核心\n---------          ---------          --------\nspawn(f1) ------>  pthread_create --> Core 0\nspawn(f2) ------>  pthread_create --> Core 1\nspawn(f3) ------>  pthread_create --> Core 2\n```\n\n**主要特征：**\n- 每个 `spawn()` 创建一个新的 pthread\n- 内核在核心间调度线程\n- 真正的并行执行（没有 GIL）\n- 抢占式多任务\n\n### 任务实现\n\n```c\ntypedef struct Task {\n    pthread_t thread;        // 操作系统线程句柄\n    Value result;            // 返回值\n    char *error;             // 异常消息（如果抛出）\n    pthread_mutex_t lock;    // 保护状态\n    TaskState state;         // RUNNING、FINISHED、ERROR\n} Task;\n```\n\n**任务生命周期：**\n1. `spawn(func, args)` → 创建 Task，启动 pthread\n2. 线程用参数运行函数\n3. 返回时：存储结果，设置状态为 FINISHED\n4. 异常时：存储错误消息，设置状态为 ERROR\n5. `join(task)` → 等待线程，返回结果或抛出异常\n\n### 通道实现\n\n```c\ntypedef struct Channel {\n    void **buffer;           // Value* 的循环缓冲区\n    size_t capacity;         // 最大缓冲项目数\n    size_t count;            // 缓冲区中的当前项目数\n    size_t read_index;       // 下一个读取位置\n    size_t write_index;      // 下一个写入位置\n    bool closed;             // 通道关闭标志\n    pthread_mutex_t lock;    // 保护缓冲区\n    pthread_cond_t not_full; // 有空间时发信号\n    pthread_cond_t not_empty;// 有数据时发信号\n} Channel;\n```\n\n**发送操作：**\n1. 锁定 mutex\n2. 如果缓冲区满则等待（cond_wait on not_full）\n3. 将值写入 buffer[write_index]\n4. 递增 write_index（循环）\n5. 信号 not_empty\n6. 解锁 mutex\n\n**接收操作：**\n1. 锁定 mutex\n2. 如果缓冲区空则等待（cond_wait on not_empty）\n3. 从 buffer[read_index] 读取值\n4. 递增 read_index（循环）\n5. 信号 not_full\n6. 解锁 mutex\n\n**同步保证：**\n- 线程安全的 send/recv（由 mutex 保护）\n- 阻塞语义（满时生产者等待，空时消费者等待）\n- 有序交付（通道内 FIFO）\n\n---\n\n## 未来计划\n\n### 已完成：编译器后端\n\n编译器后端（`hemlockc`）已实现：\n- 从 AST 生成 C 代码\n- 编译时类型检查（默认启用）\n- 运行时库（`libhemlock_runtime.a`）\n- 与解释器完全一致（98% 测试通过率）\n- 拆箱优化框架\n\n### 当前重点：类型系统增强\n\n**最近改进：**\n- 统一的类型检查和类型推断系统\n- 编译时类型检查默认启用\n- 用于仅类型验证的 `--check` 标志\n- 传递给代码生成的类型上下文用于优化提示\n\n### 未来增强\n\n**可能的添加：**\n- 泛型/模板\n- 模式匹配\n- LSP 集成用于类型感知的 IDE 支持\n- 更激进的拆箱优化\n- 用于栈分配的逃逸分析\n\n### 长期优化\n\n**可能的改进：**\n- 方法调用的内联缓存\n- 热代码路径的 JIT 编译\n- 用于更好并发的工作窃取调度器\n- 配置文件引导的优化\n\n---\n\n## 实现指南\n\n### 添加新特性\n\n实现新特性时，遵循以下指南：\n\n**1. 选择正确的模块：**\n- 新值类型 → `values.c`\n- 类型转换 → `types.c`\n- 内置函数 → `builtins.c`\n- I/O 操作 → `io.c`\n- 控制流 → `runtime.c`\n\n**2. 更新所有层：**\n- 如需要添加 AST 节点类型（`ast.h`、`ast.c`）\n- 如需要添加词法分析器 token（`lexer.c`）\n- 添加解析器规则（`parser.c`）\n- 实现运行时行为（`runtime.c` 或适当的模块）\n- 添加测试（`tests/`）\n\n**3. 保持一致性：**\n- 遵循现有代码风格\n- 使用一致的命名约定\n- 在头文件中记录公共 API\n- 保持错误消息清晰一致\n\n**4. 彻底测试：**\n- 实现前添加测试用例\n- 测试成功和错误路径\n- 测试边界情况\n- 验证没有内存泄漏（valgrind）\n\n### 性能考虑\n\n**当前瓶颈：**\n- 变量访问的 HashMap 查找\n- 递归函数调用（没有 TCO）\n- 字符串连接（每次分配新字符串）\n- 每次操作的类型检查开销\n\n**优化机会：**\n- 缓存变量位置（内联缓存）\n- 尾调用优化\n- 用于连接的字符串构建器\n- 类型推断以跳过运行时检查\n\n### 调试技巧\n\n**有用的工具：**\n- `valgrind` - 内存泄漏检测\n- `gdb` - 调试崩溃\n- `-g` 标志 - 调试符号\n- `printf` 调试 - 简单但有效\n\n**常见问题：**\n- 段错误 → 空指针解引用（检查返回值）\n- 内存泄漏 → 缺少 free() 调用（检查 value_free 路径）\n- 类型错误 → 检查 type_convert() 和 type_check() 逻辑\n- 线程崩溃 → 竞争条件（检查 mutex 使用）\n\n---\n\n## 总结\n\nHemlock 的实现优先考虑：\n- **模块化** - 清晰的关注点分离\n- **简单性** - 直接的实现\n- **显式性** - 没有隐藏的魔法\n- **可维护性** - 易于理解和修改\n\n当前的树遍历解释器有意保持简单，以促进快速特性开发和实验。未来的编译器后端将在保持相同语义的同时提高性能。\n"}, "设计与理念 -> 签名语法": {"id": "design-signature-syntax", "content": "# 签名语法设计\n\n> 用函数类型、可空修饰符、类型别名、const 参数和方法签名扩展 Hemlock 的类型系统。\n\n**状态：**已实现（v1.7.0）\n**版本：**1.0\n**作者：**Claude\n\n---\n\n## 概述\n\n本文档提出了五个相互关联的类型系统扩展，它们建立在 Hemlock 现有基础设施之上：\n\n1. **函数类型注解** - 一等函数类型\n2. **可空类型修饰符** - 显式的 null 处理（扩展现有的 `nullable` 标志）\n3. **类型别名** - 命名的类型缩写\n4. **Const 参数** - 不可变性契约\n5. **Define 中的方法签名** - 类接口行为\n\n这些特性共享相同的理念：**显式优于隐式，可选但使用时强制执行**。\n\n---\n\n## 1. 函数类型注解\n\n### 动机\n\n目前，没有办法将函数的签名表达为类型：\n\n```hemlock\n// 当前：callback 没有类型信息\nfn map(arr: array, callback) { ... }\n\n// 提议：显式函数类型\nfn map(arr: array, callback: fn(any, i32): any): array { ... }\n```\n\n### 语法\n\n```hemlock\n// 基本函数类型\nfn(i32, i32): i32\n\n// 带参数名（仅用于文档，不强制执行）\nfn(a: i32, b: i32): i32\n\n// 无返回值（void）\nfn(string): void\nfn(string)              // 简写：省略 `: void`\n\n// 可空返回\nfn(i32): string?\n\n// 可选参数\nfn(name: string, age?: i32): void\n\n// Rest 参数\nfn(...args: array): i32\n\n// 无参数\nfn(): bool\n\n// 高阶：返回函数的函数\nfn(i32): fn(i32): i32\n\n// 异步函数类型\nasync fn(i32): i32\n```\n\n### 使用示例\n\n```hemlock\n// 带函数类型的变量\nlet add: fn(i32, i32): i32 = fn(a, b) { return a + b; };\n\n// 函数参数\nfn apply(f: fn(i32): i32, x: i32): i32 {\n    return f(x);\n}\n\n// 返回类型是函数\nfn make_adder(n: i32): fn(i32): i32 {\n    return fn(x) { return x + n; };\n}\n\n// 函数数组\nlet ops: array<fn(i32, i32): i32> = [add, subtract, multiply];\n\n// 对象字段\ndefine EventHandler {\n    name: string;\n    callback: fn(Event): void;\n}\n```\n\n### AST 更改\n\n```c\n// 在 TypeKind 枚举中（include/ast.h）\ntypedef enum {\n    // ... 现有类型 ...\n    TYPE_FUNCTION,      // 新增：函数类型\n} TypeKind;\n\n// 在 Type 结构中（include/ast.h）\nstruct Type {\n    TypeKind kind;\n    // ... 现有字段 ...\n\n    // 用于 TYPE_FUNCTION：\n    struct Type **param_types;      // 参数类型\n    char **param_names;             // 可选参数名（文档）\n    int *param_optional;            // 哪些参数是可选的\n    int num_params;\n    char *rest_param_name;          // Rest 参数名或 NULL\n    struct Type *rest_param_type;   // Rest 参数类型\n    struct Type *return_type;       // 返回类型（NULL = void）\n    int is_async;                   // async fn 类型\n};\n```\n\n### 解析\n\n函数类型以 `fn`（或 `async fn`）开始，后跟参数列表：\n\n```\nfunction_type := [\"async\"] \"fn\" \"(\" [param_type_list] \")\" [\":\" type]\nparam_type_list := param_type (\",\" param_type)*\nparam_type := [identifier \":\"] [\"?\"] type | \"...\" [identifier] [\":\" type]\n```\n\n**消歧义：**解析类型时遇到 `fn`：\n- 如果后跟 `(`，则是函数类型\n- 否则，语法错误（裸 `fn` 不是有效类型）\n\n### 类型兼容性\n\n```hemlock\n// 函数类型需要精确匹配\nlet f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // 正确\n\n// 参数逆变（接受更宽类型是可以的）\nlet g: fn(any): i32 = fn(x: i32): i32 { return x; };  // 正确：i32 <: any\n\n// 返回协变（返回更窄类型是可以的）\nlet h: fn(i32): any = fn(x: i32): i32 { return x; };  // 正确：i32 <: any\n\n// 参数数量必须匹配\nlet bad: fn(i32): i32 = fn(a, b) { return a; };       // 错误：参数数量不匹配\n\n// 可选参数与必需参数兼容\nlet opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // 正确\n```\n\n---\n\n## 2. 可空类型修饰符\n\n### 动机\n\n`?` 后缀使签名中的 null 接受变得显式：\n\n```hemlock\n// 当前：不清楚 null 是否有效\nfn find(arr: array, val: any): i32 { ... }\n\n// 提议：显式可空返回\nfn find(arr: array, val: any): i32? { ... }\n```\n\n### 语法\n\n```hemlock\n// 带 ? 后缀的可空类型\nstring?           // string 或 null\ni32?              // i32 或 null\nUser?             // User 或 null\narray<i32>?       // array 或 null\nfn(i32): i32?     // 返回 i32 或 null 的函数\n\n// 与函数类型组合\nfn(string?): i32          // 接受 string 或 null\nfn(string): i32?          // 返回 i32 或 null\nfn(string?): i32?         // 两者都可空\n\n// 在 define 中\ndefine Result {\n    value: any?;\n    error: string?;\n}\n```\n\n### 实现说明\n\n**已存在：**`Type.nullable` 标志已在 AST 中。此特性主要需要：\n1. 对任何类型的 `?` 后缀的解析器支持（验证/扩展）\n2. 与函数类型的正确组合\n3. 运行时强制执行\n\n### 类型兼容性\n\n```hemlock\n// 非空可赋值给可空\nlet x: i32? = 42;           // 正确\nlet y: i32? = null;         // 正确\n\n// 可空不能赋值给非空\nlet z: i32 = x;             // 错误：x 可能是 null\n\n// 空值合并以解包\nlet z: i32 = x ?? 0;        // 正确：?? 提供默认值\n\n// 可选链返回可空\nlet name: string? = user?.name;\n```\n\n---\n\n## 3. 类型别名\n\n### 动机\n\n复杂类型受益于命名缩写：\n\n```hemlock\n// 当前：重复的复合类型\nfn process(entity: HasName & HasId & HasTimestamp) { ... }\nfn validate(entity: HasName & HasId & HasTimestamp) { ... }\n\n// 提议：命名别名\ntype Entity = HasName & HasId & HasTimestamp;\nfn process(entity: Entity) { ... }\nfn validate(entity: Entity) { ... }\n```\n\n### 语法\n\n```hemlock\n// 基本别名\ntype Integer = i32;\ntype Text = string;\n\n// 复合类型别名\ntype Entity = HasName & HasId;\ntype Auditable = HasCreatedAt & HasUpdatedAt & HasCreatedBy;\n\n// 函数类型别名\ntype Callback = fn(Event): void;\ntype Predicate = fn(any): bool;\ntype Reducer = fn(acc: any, val: any): any;\ntype AsyncTask = async fn(): any;\n\n// 可空别名\ntype OptionalString = string?;\n\n// 泛型别名（如果我们支持泛型类型别名）\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\n\n// 数组类型别名\ntype IntArray = array<i32>;\ntype Matrix = array<array<f64>>;\n```\n\n### 作用域和可见性\n\n```hemlock\n// 默认模块作用域\ntype Callback = fn(Event): void;\n\n// 可导出\nexport type Handler = fn(Request): Response;\n\n// 在另一个文件中\nimport { Handler } from \"./handlers.hml\";\nfn register(h: Handler) { ... }\n```\n\n### AST 更改\n\n```c\n// 新语句类型\ntypedef enum {\n    // ... 现有语句 ...\n    STMT_TYPE_ALIAS,    // 新增\n} StmtKind;\n\n// 在 Stmt union 中\nstruct {\n    char *name;                 // 别名名称\n    char **type_params;         // 泛型参数：<T, U>\n    int num_type_params;\n    Type *aliased_type;         // 实际类型\n} type_alias;\n```\n\n### 解析\n\n```\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n```\n\n**注意：**`type` 是一个新关键字。检查与现有标识符的冲突。\n\n### 解析\n\n类型别名在以下时机解析：\n- **解析时：**别名记录在类型环境中\n- **检查时：**别名展开为底层类型\n- **运行时：**别名是透明的（与底层类型相同）\n\n```hemlock\ntype MyInt = i32;\nlet x: MyInt = 42;\ntypeof(x);           // \"i32\"（不是 \"MyInt\"）\n```\n\n---\n\n## 4. Const 参数\n\n### 动机\n\n在函数签名中表示不可变性意图：\n\n```hemlock\n// 当前：不清楚 array 是否会被修改\nfn print_all(items: array) { ... }\n\n// 提议：显式不可变性契约\nfn print_all(const items: array) { ... }\n```\n\n### 语法\n\n```hemlock\n// Const 参数\nfn process(const data: buffer) {\n    // data[0] = 0;        // 错误：不能修改 const\n    let x = data[0];       // 正确：允许读取\n    return x;\n}\n\n// 多个 const 参数\nfn compare(const a: array, const b: array): bool { ... }\n\n// 混合 const 和可变\nfn update(const source: array, target: array) {\n    for (item in source) {\n        target.push(item);   // 正确：target 是可变的\n    }\n}\n\n// Const 与类型推断\nfn log(const msg) {\n    print(msg);\n}\n\n// 函数类型中的 const\ntype Reader = fn(const buffer): i32;\n```\n\n### Const 阻止的操作\n\n```hemlock\nfn bad(const arr: array) {\n    arr.push(1);         // 错误：修改方法\n    arr.pop();           // 错误：修改方法\n    arr[0] = 5;          // 错误：索引赋值\n    arr.clear();         // 错误：修改方法\n}\n\nfn ok(const arr: array) {\n    let x = arr[0];      // 正确：读取\n    let len = len(arr);  // 正确：长度检查\n    let copy = arr.slice(0, 10);  // 正确：创建新数组\n    for (item in arr) {  // 正确：迭代\n        print(item);\n    }\n}\n```\n\n### 修改方法与非修改方法\n\n| 类型 | 修改（被 const 阻止） | 非修改（允许） |\n|------|----------------------------|------------------------|\n| array | push、pop、shift、unshift、insert、remove、clear、reverse（原地） | slice、concat、map、filter、find、contains、first、last、join |\n| string | 索引赋值（`s[0] = 'x'`） | 所有方法（返回新字符串） |\n| buffer | 索引赋值、memset、memcpy（目标） | 索引读取、slice |\n| object | 字段赋值 | 字段读取 |\n\n### AST 更改\n\n```c\n// 在函数表达式中（include/ast.h）\nstruct {\n    // ... 现有字段 ...\n    int *param_is_const;    // 新增：1 表示 const，0 表示否\n} function;\n\n// 在函数类型的 Type 结构中\nstruct Type {\n    // ... 现有字段 ...\n    int *param_is_const;    // 用于 TYPE_FUNCTION\n};\n```\n\n### 强制执行\n\n**解释器：**\n- 在变量绑定中跟踪 const 性\n- 在修改操作前检查\n- const 违规时运行时错误\n\n**编译器：**\n- 在有益时生成 const 限定的 C 变量\n- const 违规的静态分析\n- 编译时警告/错误\n\n---\n\n## 5. Define 中的方法签名\n\n### 动机\n\n允许 `define` 块指定预期的方法，不仅是数据字段：\n\n```hemlock\n// 当前：仅数据字段\ndefine User {\n    name: string;\n    age: i32;\n}\n\n// 提议：方法签名\ndefine Comparable {\n    fn compare(other: Self): i32;\n}\n\ndefine Serializable {\n    fn serialize(): string;\n    fn deserialize(data: string): Self;  // 静态方法\n}\n```\n\n### 语法\n\n```hemlock\n// 方法签名（无方法体）\ndefine Hashable {\n    fn hash(): i32;\n}\n\n// 多个方法\ndefine Collection {\n    fn size(): i32;\n    fn is_empty(): bool;\n    fn contains(item: any): bool;\n}\n\n// 混合字段和方法\ndefine Entity {\n    id: i32;\n    name: string;\n    fn validate(): bool;\n    fn serialize(): string;\n}\n\n// 使用 Self 类型\ndefine Cloneable {\n    fn clone(): Self;\n}\n\ndefine Comparable {\n    fn compare(other: Self): i32;\n    fn equals(other: Self): bool;\n}\n\n// 可选方法\ndefine Printable {\n    fn to_string(): string;\n    fn debug_string?(): string;  // 可选方法（可能不存在）\n}\n\n// 带默认实现的方法\ndefine Ordered {\n    fn compare(other: Self): i32;  // 必需\n\n    // 默认实现（如果未覆盖则继承）\n    fn less_than(other: Self): bool {\n        return self.compare(other) < 0;\n    }\n    fn greater_than(other: Self): bool {\n        return self.compare(other) > 0;\n    }\n    fn equals(other: Self): bool {\n        return self.compare(other) == 0;\n    }\n}\n```\n\n### `Self` 类型\n\n`Self` 指的是实现接口的具体类型：\n\n```hemlock\ndefine Addable {\n    fn add(other: Self): Self;\n}\n\n// 使用时：\nlet a: Addable = {\n    value: 10,\n    add: fn(other) {\n        return { value: self.value + other.value, add: self.add };\n    }\n};\n```\n\n### 结构类型（鸭子类型）\n\n方法签名使用与字段相同的鸭子类型：\n\n```hemlock\ndefine Stringifiable {\n    fn to_string(): string;\n}\n\n// 任何有 to_string() 方法的对象都满足 Stringifiable\nlet x: Stringifiable = {\n    name: \"test\",\n    to_string: fn() { return self.name; }\n};\n\n// 带方法的复合类型\ndefine Named { name: string; }\ndefine Printable { fn to_string(): string; }\n\ntype NamedPrintable = Named & Printable;\n\nlet y: NamedPrintable = {\n    name: \"Alice\",\n    to_string: fn() { return \"Name: \" + self.name; }\n};\n```\n\n### AST 更改\n\n```c\n// 扩展 Stmt union 中的 define_object\nstruct {\n    char *name;\n    char **type_params;\n    int num_type_params;\n\n    // 字段（现有）\n    char **field_names;\n    Type **field_types;\n    int *field_optional;\n    Expr **field_defaults;\n    int num_fields;\n\n    // 方法（新增）\n    char **method_names;\n    Type **method_types;        // TYPE_FUNCTION\n    int *method_optional;       // 可选方法（fn name?(): type）\n    Expr **method_defaults;     // 默认实现（如果仅签名则为 NULL）\n    int num_methods;\n} define_object;\n```\n\n### 类型检查\n\n检查 `value: InterfaceType` 时：\n1. 检查所有必需字段存在且类型兼容\n2. 检查所有必需方法存在且签名兼容\n3. 可选字段/方法可以不存在\n\n```hemlock\ndefine Sortable {\n    fn compare(other: Self): i32;\n}\n\n// 有效：有 compare 方法\nlet valid: Sortable = {\n    value: 10,\n    compare: fn(other) { return self.value - other.value; }\n};\n\n// 无效：缺少 compare\nlet invalid: Sortable = { value: 10 };  // 错误：缺少方法 'compare'\n\n// 无效：签名错误\nlet wrong: Sortable = {\n    compare: fn() { return 0; }  // 错误：期望 (Self): i32\n};\n```\n\n---\n\n## 交互示例\n\n### 组合所有特性\n\n```hemlock\n// 复杂函数类型的类型别名\ntype EventCallback = fn(event: Event, context: Context?): bool;\n\n// 复合接口的类型别名\ntype Entity = HasId & HasName & Serializable;\n\n// 带方法签名的 Define\ndefine Repository<T> {\n    fn find(id: i32): T?;\n    fn save(const entity: T): bool;\n    fn delete(id: i32): bool;\n    fn find_all(predicate: fn(T): bool): array<T>;\n}\n\n// 将所有组合在一起使用\nfn create_user_repo(): Repository<User> {\n    let users: array<User> = [];\n\n    return {\n        find: fn(id) {\n            for (u in users) {\n                if (u.id == id) { return u; }\n            }\n            return null;\n        },\n        save: fn(const entity) {\n            users.push(entity);\n            return true;\n        },\n        delete: fn(id) {\n            // ...\n            return true;\n        },\n        find_all: fn(predicate) {\n            return users.filter(predicate);\n        }\n    };\n}\n```\n\n### 显式类型的回调\n\n```hemlock\ntype ClickHandler = fn(event: MouseEvent): void;\ntype KeyHandler = fn(event: KeyEvent, modifiers: i32): bool;\n\ndefine Widget {\n    x: i32;\n    y: i32;\n    on_click: ClickHandler?;\n    on_key: KeyHandler?;\n}\n\nfn create_button(label: string, handler: ClickHandler): Widget {\n    return {\n        x: 0, y: 0,\n        on_click: handler,\n        on_key: null\n    };\n}\n```\n\n### 可空函数类型\n\n```hemlock\n// 可选回调\nfn fetch(url: string, on_complete: fn(Response): void?): void {\n    let response = http_get(url);\n    if (on_complete != null) {\n        on_complete(response);\n    }\n}\n\n// 函数类型的可空返回\ntype Parser = fn(input: string): AST?;\n\nfn try_parse(parsers: array<Parser>, input: string): AST? {\n    for (p in parsers) {\n        let result = p(input);\n        if (result != null) {\n            return result;\n        }\n    }\n    return null;\n}\n```\n\n---\n\n## 实现路线图\n\n### 阶段 1：核心基础设施\n1. 将 `TYPE_FUNCTION` 添加到 TypeKind 枚举\n2. 用函数类型字段扩展 Type 结构\n3. 将 `CHECKED_FUNCTION` 添加到编译器类型检查器\n4. 添加 `Self` 类型支持（TYPE_SELF）\n\n### 阶段 2：解析\n1. 在解析器中实现 `parse_function_type()`\n2. 在类型位置处理 `fn(...)`\n3. 添加 `type` 关键字和 `STMT_TYPE_ALIAS` 解析\n4. 添加 `const` 参数修饰符解析\n5. 扩展 define 解析以支持方法签名\n\n### 阶段 3：类型检查\n1. 函数类型兼容性规则\n2. 类型别名解析和展开\n3. Const 参数修改检查\n4. define 类型中的方法签名验证\n5. Self 类型解析\n\n### 阶段 4：运行时\n1. 调用点的函数类型验证\n2. Const 违规检测\n3. 类型别名透明性\n\n### 阶段 5：一致性测试\n1. 函数类型注解测试\n2. 可空组合测试\n3. 类型别名测试\n4. Const 参数测试\n5. 方法签名测试\n\n---\n\n## 设计决策\n\n### 1. 泛型类型别名：**是**\n\n类型别名支持泛型参数：\n\n```hemlock\n// 泛型类型别名\ntype Pair<T> = { first: T, second: T };\ntype Result<T, E> = { value: T?, error: E? };\ntype Mapper<T, U> = fn(T): U;\ntype AsyncResult<T> = async fn(): T?;\n\n// 使用\nlet coords: Pair<f64> = { first: 3.14, second: 2.71 };\nlet result: Result<User, string> = { value: user, error: null };\nlet transform: Mapper<i32, string> = fn(n) { return n.to_string(); };\n```\n\n### 2. Const 传播：**深层**\n\nConst 参数是完全不可变的 - 通过任何路径都不能修改：\n\n```hemlock\nfn process(const arr: array<object>) {\n    arr.push({});        // 错误：不能修改 const 数组\n    arr[0] = {};         // 错误：不能修改 const 数组\n    arr[0].x = 5;        // 错误：不能通过 const 修改（深层）\n\n    let x = arr[0].x;    // 正确：读取没问题\n    let copy = arr[0];   // 正确：创建副本\n    copy.x = 5;          // 正确：副本不是 const\n}\n\nfn nested(const obj: object) {\n    obj.user.name = \"x\"; // 错误：深层 const 阻止嵌套修改\n    obj.items[0] = 1;    // 错误：深层 const 阻止嵌套修改\n}\n```\n\n**理由：**深层 const 提供更强的保证，对于确保数据完整性更有用。如果需要修改嵌套数据，先复制。\n\n### 3. 独立类型别名中的 Self：**否**\n\n`Self` 仅在 `define` 块内有效，在那里它有明确的含义：\n\n```hemlock\n// 有效：Self 指的是定义的类型\ndefine Comparable {\n    fn compare(other: Self): i32;\n}\n\n// 无效：Self 在这里没有意义\ntype Cloner = fn(Self): Self;  // 错误：Self 在 define 上下文之外\n\n// 改用泛型：\ntype Cloner<T> = fn(T): T;\n```\n\n### 4. 方法默认实现：**是（仅简单的）**\n\n允许简单/实用方法的默认实现：\n\n```hemlock\ndefine Comparable {\n    // 必需：必须实现\n    fn compare(other: Self): i32;\n\n    // 默认实现（简单便利方法）\n    fn equals(other: Self): bool {\n        return self.compare(other) == 0;\n    }\n    fn less_than(other: Self): bool {\n        return self.compare(other) < 0;\n    }\n    fn greater_than(other: Self): bool {\n        return self.compare(other) > 0;\n    }\n}\n\ndefine Printable {\n    fn to_string(): string;\n\n    // 默认：委托给必需方法\n    fn print() {\n        print(self.to_string());\n    }\n    fn println() {\n        print(self.to_string() + \"\\n\");\n    }\n}\n\n// 对象只需实现必需方法\nlet item: Comparable = {\n    value: 42,\n    compare: fn(other) { return self.value - other.value; }\n    // equals、less_than、greater_than 从默认继承\n};\n\nitem.less_than({ value: 50, compare: item.compare });  // true\n```\n\n**默认实现指南：**\n- 保持简单（1-3 行）\n- 应该委托给必需方法\n- 无复杂逻辑或副作用\n- 仅限原始类型和直接组合\n\n### 5. 型变：**推断（无显式注解）**\n\n型变根据类型参数的使用方式推断：\n\n```hemlock\n// 型变根据位置自动确定\ntype Producer<T> = fn(): T;           // T 在返回位置 = 协变\ntype Consumer<T> = fn(T): void;       // T 在参数位置 = 逆变\ntype Transformer<T> = fn(T): T;       // T 在两个位置 = 不变\n\n// 示例：Dog <: Animal（Dog 是 Animal 的子类型）\nlet dog_producer: Producer<Dog> = fn() { return new_dog(); };\nlet animal_producer: Producer<Animal> = dog_producer;  // 正确：协变\n\nlet animal_consumer: Consumer<Animal> = fn(a) { print(a); };\nlet dog_consumer: Consumer<Dog> = animal_consumer;     // 正确：逆变\n```\n\n**为什么推断？**\n- 更少的样板代码（`<out T>` / `<in T>` 增加噪音）\n- 遵循\"显式优于隐式\" - 位置本身就是显式的\n- 与大多数语言处理函数类型型变的方式一致\n- 违反型变规则时错误清晰\n\n---\n\n## 附录：语法更改\n\n```ebnf\n(* 类型 *)\ntype := simple_type | compound_type | function_type\nsimple_type := base_type [\"?\"] | identifier [\"<\" type_args \">\"] [\"?\"]\ncompound_type := simple_type (\"&\" simple_type)+\nfunction_type := [\"async\"] \"fn\" \"(\" [param_types] \")\" [\":\" type]\n\nbase_type := \"i8\" | \"i16\" | \"i32\" | \"i64\"\n           | \"u8\" | \"u16\" | \"u32\" | \"u64\"\n           | \"f32\" | \"f64\" | \"bool\" | \"string\" | \"rune\"\n           | \"ptr\" | \"buffer\" | \"void\" | \"null\"\n           | \"array\" [\"<\" type \">\"]\n           | \"object\"\n           | \"Self\"\n\nparam_types := param_type (\",\" param_type)*\nparam_type := [\"const\"] [identifier \":\"] [\"?\"] type\n            | \"...\" [identifier] [\":\" type]\n\ntype_args := type (\",\" type)*\n\n(* 语句 *)\ntype_alias := \"type\" identifier [\"<\" type_params \">\"] \"=\" type \";\"\n\ndefine_stmt := \"define\" identifier [\"<\" type_params \">\"] \"{\" define_members \"}\"\ndefine_members := (field_def | method_def)*\nfield_def := identifier (\":\" type [\"=\" expr] | \"?:\" (type | expr)) \";\"?\nmethod_def := \"fn\" identifier [\"?\"] \"(\" [param_types] \")\" [\":\" type] (block | \";\")\n            (* \"?\" 标记可选方法，block 提供默认实现 *)\n\n(* 参数 *)\nparam := [\"const\"] [\"ref\"] identifier [\":\" type] [\"?:\" expr]\n       | \"...\" identifier [\":\" type]\n```\n"}, "设计与理念 -> 设计理念": {"id": "design-philosophy", "content": "# Hemlock 语言设计理念\n\n> \"一个小巧的、非安全的语言，用于安全地编写非安全的代码。\"\n\n本文档记录了 Hemlock 的核心设计原则和理念。在对语言进行任何更改或添加之前，请先阅读本文档。\n\n---\n\n## 目录\n\n- [核心定位](#核心定位)\n- [设计原则](#设计原则)\n- [安全性理念](#安全性理念)\n- [不应添加的特性](#不应添加的特性)\n- [未来考虑](#未来考虑)\n- [结语](#结语)\n\n---\n\n## 核心定位\n\nHemlock 是一种**系统脚本语言**，采用手动内存管理和显式控制。它专为以下需求的程序员设计：\n\n- C 语言的强大能力\n- 现代脚本语言的易用性\n- 内置的结构化异步并发\n- 无隐藏行为或魔法\n\n### Hemlock 不是什么\n\n- **内存安全的**（悬空指针是你的责任）\n- **Rust、Go 或 Lua 的替代品**\n- **向你隐藏复杂性的语言**\n\n### Hemlock 是什么\n\n- **永远显式优于隐式**\n- **教育性和实验性的**\n- **用于系统工作的 \"C 脚本层\"**\n- **诚实地对待权衡**\n\n---\n\n## 设计原则\n\n### 1. 显式优于隐式\n\nHemlock 在所有语言结构中偏向显式。不应有惊喜、魔法和隐藏行为。\n\n**不好的做法（隐式）：**\n```hemlock\nlet x = 5  // 缺少分号 - 应该报错\n```\n\n**好的做法（显式）：**\n```hemlock\nlet x = 5;\nfree(ptr);  // 你分配的，你释放\n```\n\n**关键要点：**\n- 分号是强制的（没有自动分号插入）\n- 没有垃圾回收\n- 手动内存管理（alloc/free）\n- 类型注解是可选的，但在运行时会被检查\n- 没有自动资源清理（没有 RAII），但 `defer` 提供显式清理\n\n### 2. 默认动态，可选类型\n\n每个值都有运行时类型标签，但系统设计为灵活的同时仍能捕获错误。\n\n**类型推断：**\n- 小整数（适合 i32）：`42` → `i32`\n- 大整数（超过 i32 范围）：`9223372036854775807` → `i64`\n- 浮点数：`3.14` → `f64`\n\n**需要时显式类型：**\n```hemlock\nlet x = 42;              // 推断为 i32（小值）\nlet y: u8 = 255;         // 显式 u8\nlet z = x + y;           // 提升为 i32\nlet big = 5000000000;    // 推断为 i64（超过 i32 最大值）\n```\n\n**类型提升规则**遵循从最小到最大的清晰层次，浮点数始终优先于整数。\n\n### 3. 非安全是特性，不是缺陷\n\nHemlock 不试图阻止所有错误。相反，它给你安全的工具，同时允许你在需要时选择非安全行为。\n\n**有意的非安全性示例：**\n- 指针运算可能溢出（用户的责任）\n- 原始 `ptr` 没有边界检查（如果需要安全性，使用 `buffer`）\n- 允许双重释放崩溃（手动内存管理）\n- 类型系统防止意外但允许需要时的危险操作\n\n```hemlock\nlet p = alloc(10);\nlet q = p + 100;  // 远超分配范围 - 允许但危险\n```\n\n**理念：**类型系统应该防止*意外*，但允许*有意的*非安全操作。\n\n### 4. 结构化并发作为一等公民\n\n并发不是 Hemlock 的事后考虑。它从一开始就内置于语言中。\n\n**主要特性：**\n- `async`/`await` 内置于语言中\n- 用于通信的 Channel\n- 用于任务管理的 `spawn`/`join`/`detach`\n- 没有原始线程，没有锁 - 仅结构化\n- 使用 POSIX 线程实现真正的多线程并行\n\n**不是事件循环或绿色线程** - Hemlock 使用真正的操作系统线程在多个 CPU 核心上实现真正的并行。\n\n### 5. 类 C 语法，低仪式感\n\nHemlock 对系统程序员来说应该感觉熟悉，同时减少样板代码。\n\n**设计选择：**\n- 始终使用 `{}` 块，没有可选大括号\n- 运算符与 C 匹配：`+`、`-`、`*`、`/`、`&&`、`||`、`!`\n- 类型语法与 Rust/TypeScript 匹配：`let x: type = value;`\n- 函数是一等值\n- 最少的关键字和特殊形式\n\n---\n\n## 安全性理念\n\n**Hemlock 对安全性的看法：**\n\n> \"我们给你安全的工具（`buffer`、类型注解、边界检查），但我们不强迫你使用它们（`ptr`、手动内存、非安全操作）。\n>\n> 默认应该引导向安全，但逃生舱口应该始终可用。\"\n\n### 提供的安全工具\n\n**1. 安全的 buffer 类型：**\n```hemlock\nlet b: buffer = buffer(64);\nb[0] = 65;              // 边界检查\nprint(b.length);        // 64\nfree(b);                // 仍然是手动的\n```\n\n**2. 非安全的原始指针：**\n```hemlock\nlet p: ptr = alloc(64);\nmemset(p, 0, 64);\nfree(p);  // 你必须记得释放\n```\n\n**3. 类型注解：**\n```hemlock\nlet x: u8 = 255;   // 正确\nlet y: u8 = 256;   // 错误：超出范围\n```\n\n**4. 运行时类型检查：**\n```hemlock\nlet val = some_function();\nif (typeof(val) == \"i32\") {\n    // 可以安全地作为整数使用\n}\n```\n\n### 指导原则\n\n1. **文档中默认使用安全模式** - 在 `ptr` 之前展示 `buffer`，鼓励类型注解\n2. **使非安全操作显眼** - 原始指针运算应该看起来是有意的\n3. **提供逃生舱口** - 不阻止有经验的用户进行底层工作\n4. **诚实地对待权衡** - 记录可能出错的地方\n\n### 安全与非安全示例\n\n| 安全模式 | 非安全模式 | 何时使用非安全 |\n|-------------|----------------|-------------------|\n| `buffer` 类型 | `ptr` 类型 | FFI、性能关键代码 |\n| 类型注解 | 无注解 | 外部接口、验证 |\n| 边界检查访问 | 指针运算 | 底层内存操作 |\n| 异常处理 | 返回 null/错误码 | 当异常太重量级时 |\n\n---\n\n## 不应添加的特性\n\n理解**不应**添加什么与知道应该添加什么同样重要。\n\n### 不要添加隐式行为\n\n**不好的示例：**\n\n```hemlock\n// 不好：自动分号插入\nlet x = 5\nlet y = 10\n\n// 不好：丢失精度的隐式类型转换\nlet x: i32 = 3.14  // 应该截断还是报错？\n```\n\n**原因：**隐式行为会造成惊喜，使代码更难理解。\n\n### 不要隐藏复杂性\n\n**不好的示例：**\n\n```hemlock\n// 不好：幕后的魔法优化\nlet arr = [1, 2, 3]  // 这是栈还是堆？用户应该知道！（堆，引用计数）\n\n// 不好：原始指针自动释放\nlet p = alloc(100)  // 这会自动释放吗？不会！原始指针总是需要 free()\n```\n\n**关于引用计数的说明：**Hemlock 对字符串、数组、对象和缓冲区使用内部引用计数 - 这些在作用域退出时会自动释放。这是显式且可预测的（当引用计数为 0 时确定性清理，没有 GC 暂停）。原始指针（来自 `alloc()` 的 `ptr`）不是引用计数的，始终需要手动 `free()`。\n\n**原因：**隐藏的复杂性使得无法预测性能和调试问题。\n\n### 不要破坏现有语义\n\n**永远不要改变这些核心决定：**\n- 分号是强制的 - 不要使它们可选\n- 手动内存管理 - 不要添加 GC\n- 可变字符串 - 不要使它们不可变\n- 运行时类型检查 - 不要移除它\n\n**原因：**一致性和稳定性比时髦的特性更重要。\n\n### 不要添加降低显式性的\"便利\"特性\n\n**应避免的特性示例：**\n- 运算符重载（用户类型可能可以，但要谨慎）\n- 丢失信息的隐式类型强制转换\n- 自动资源清理（RAII）\n- 隐藏复杂性的方法链\n- DSL 和魔法语法\n\n**例外：**如果便利特性是简单操作的**显式语法糖**，则可以：\n- `else if` 可以（它只是嵌套的 if 语句）\n- 字符串插值可能可以，如果它明显是语法糖\n- 对象的方法语法可以（它做什么是显式的）\n\n---\n\n## 未来考虑\n\n### 可能添加（讨论中）\n\n这些特性符合 Hemlock 的理念，但需要仔细设计：\n\n**1. 模式匹配**\n```hemlock\nmatch (value) {\n    case i32: print(\"integer\");\n    case string: print(\"text\");\n    case _: print(\"other\");\n}\n```\n- 显式类型检查\n- 没有隐藏成本\n- 可能进行编译时穷尽性检查\n\n**2. 错误类型（`Result<T, E>`）**\n```hemlock\nfn divide(a: i32, b: i32): Result<i32, string> {\n    if (b == 0) {\n        return Err(\"division by zero\");\n    }\n    return Ok(a / b);\n}\n```\n- 显式错误处理\n- 强制用户考虑错误\n- 异常的替代方案\n\n**3. 数组/切片类型**\n- 已经有动态数组\n- 可以添加固定大小数组用于栈分配\n- 需要显式说明栈与堆\n\n**4. 改进的内存安全工具**\n- 可选的边界检查标志\n- 调试构建中的内存泄漏检测\n- Sanitizer 集成\n\n### 可能永远不会添加\n\n这些特性违反核心原则：\n\n**1. 垃圾回收**\n- 隐藏内存管理复杂性\n- 不可预测的性能\n- 违背显式控制原则\n\n**2. 自动内存管理**\n- 与 GC 相同的原因\n- 如果显式的话，引用计数可能可以\n\n**3. 丢失数据的隐式类型转换**\n- 违背\"显式优于隐式\"\n- 微妙错误的来源\n\n**4. 宏（复杂的）**\n- 太多能力，太多复杂性\n- 简单的宏系统可能可以\n- 优先使用代码生成或函数\n\n**5. 基于类的带继承的面向对象编程**\n- 太多隐式行为\n- 鸭子类型和对象就足够了\n- 组合优于继承\n\n**6. 具有复杂解析的模块系统**\n- 保持导入简单和显式\n- 没有魔法搜索路径\n- 没有版本解析（使用操作系统包管理器）\n\n---\n\n## 结语\n\n### 信任与责任\n\nHemlock 是关于**信任与责任**的。我们信任程序员能够：\n\n- 正确管理内存\n- 适当使用类型\n- 正确处理错误\n- 理解权衡\n\n作为回报，Hemlock 提供：\n\n- 无隐藏成本\n- 无意外行为\n- 需要时的完全控制\n- 需要时的安全工具\n\n### 指导问题\n\n**当考虑新特性时，问：**\n\n> \"这是给程序员更多显式控制，还是隐藏了某些东西？\"\n\n- 如果它**增加显式控制** → 可能适合 Hemlock\n- 如果它**隐藏复杂性** → 可能不属于这里\n- 如果它是**可选的语法糖**且有清晰文档 → 可能可以\n\n### 好的添加示例\n\n- **Switch 语句** - 显式控制流，没有魔法，清晰的语义\n\n- **带 pthreads 的 Async/await** - 显式并发，真正的并行，用户控制生成\n\n- **Buffer 类型与 ptr 并存** - 在安全和非安全之间提供选择\n\n- **可选类型注解** - 帮助捕获错误而不强制严格\n\n- **Try/catch/finally** - 带清晰控制流的显式错误处理\n\n### 不好的添加示例\n\n- **自动分号插入** - 隐藏语法错误，使代码模糊\n\n- **RAII/析构函数** - 自动清理隐藏资源何时释放\n\n- **隐式空值合并** - 隐藏空值检查，使代码更难理解\n\n- **自动增长的字符串** - 隐藏内存分配，不可预测的性能\n\n---\n\n## 总结\n\nHemlock 不是试图成为最安全的语言、最快的语言或功能最丰富的语言。\n\n**Hemlock 试图成为最*诚实*的语言。**\n\n它确切地告诉你它在做什么，在你需要时给你控制权，不隐藏锋利的边缘。它是为那些想在底层理解代码同时仍享受现代易用性的人设计的语言。\n\n如果你不确定某个特性是否属于 Hemlock，请记住：\n\n> **永远显式优于隐式。**\n> **非安全是特性，不是缺陷。**\n> **用户负责，这没问题。**\n"}, "贡献指南 -> 测试": {"id": "contributing-testing", "content": "# Hemlock 测试指南\n\n本指南解释了 Hemlock 的测试理念、如何编写测试以及如何运行测试套件。\n\n---\n\n## 目录\n\n- [测试理念](#测试理念)\n- [测试套件结构](#测试套件结构)\n- [运行测试](#运行测试)\n- [编写测试](#编写测试)\n- [测试类别](#测试类别)\n- [内存泄漏测试](#内存泄漏测试)\n- [持续集成](#持续集成)\n- [最佳实践](#最佳实践)\n\n---\n\n## 测试理念\n\n### 核心原则\n\n**1. 测试驱动开发（TDD）**\n\n在实现功能**之前**编写测试：\n\n```\n1. 编写一个失败的测试\n2. 实现功能\n3. 运行测试（应该通过）\n4. 如果需要，进行重构\n5. 重复\n```\n\n**好处：**\n- 确保功能确实有效\n- 防止回归\n- 记录预期行为\n- 使重构更安全\n\n**2. 全面覆盖**\n\n测试成功和失败情况：\n\n```hemlock\n// 成功情况\nlet x: u8 = 255;  // 应该成功\n\n// 失败情况\nlet y: u8 = 256;  // 应该出错\n```\n\n**3. 尽早且频繁地测试**\n\n运行测试：\n- 在提交代码之前\n- 在进行更改之后\n- 在提交 pull request 之前\n- 在代码审查期间\n\n**规则：** 合并之前所有测试必须通过。\n\n### 测试什么\n\n**始终测试：**\n- 基本功能（正常路径）\n- 错误条件（异常路径）\n- 边界情况（边界条件）\n- 类型检查和转换\n- 内存管理（无泄漏）\n- 并发和竞态条件\n\n**示例测试覆盖：**\n```hemlock\n// 功能：String.substr(start, length)\n\n// 正常路径\nprint(\"hello\".substr(0, 5));  // \"hello\"\n\n// 边界情况\nprint(\"hello\".substr(0, 0));  // \"\"（空）\nprint(\"hello\".substr(5, 0));  // \"\"（在末尾）\nprint(\"hello\".substr(2, 100)); // \"llo\"（超过末尾）\n\n// 错误情况\n// \"hello\".substr(-1, 5);  // 错误：负索引\n// \"hello\".substr(0, -1);  // 错误：负长度\n```\n\n---\n\n## 测试套件结构\n\n### 目录组织\n\n```\ntests/\n├── run_tests.sh          # 主测试运行脚本\n├── primitives/           # 类型系统测试\n│   ├── integers.hml\n│   ├── floats.hml\n│   ├── booleans.hml\n│   ├── i64.hml\n│   └── u64.hml\n├── conversions/          # 类型转换测试\n│   ├── int_to_float.hml\n│   ├── promotion.hml\n│   └── rune_conversions.hml\n├── memory/               # 指针/缓冲区测试\n│   ├── alloc.hml\n│   ├── buffer.hml\n│   └── memcpy.hml\n├── strings/              # 字符串操作测试\n│   ├── concat.hml\n│   ├── methods.hml\n│   ├── utf8.hml\n│   └── runes.hml\n├── control/              # 控制流测试\n│   ├── if.hml\n│   ├── switch.hml\n│   └── while.hml\n├── functions/            # 函数和闭包测试\n│   ├── basics.hml\n│   ├── closures.hml\n│   └── recursion.hml\n├── objects/              # 对象测试\n│   ├── literals.hml\n│   ├── methods.hml\n│   ├── duck_typing.hml\n│   └── serialization.hml\n├── arrays/               # 数组操作测试\n│   ├── basics.hml\n│   ├── methods.hml\n│   └── slicing.hml\n├── loops/                # 循环测试\n│   ├── for.hml\n│   ├── while.hml\n│   ├── break.hml\n│   └── continue.hml\n├── exceptions/           # 错误处理测试\n│   ├── try_catch.hml\n│   ├── finally.hml\n│   └── throw.hml\n├── io/                   # 文件 I/O 测试\n│   ├── file_object.hml\n│   ├── read_write.hml\n│   └── seek.hml\n├── async/                # 并发测试\n│   ├── spawn_join.hml\n│   ├── channels.hml\n│   └── exceptions.hml\n├── ffi/                  # FFI 测试\n│   ├── basic_call.hml\n│   ├── types.hml\n│   └── dlopen.hml\n├── signals/              # 信号处理测试\n│   ├── basic.hml\n│   ├── handlers.hml\n│   └── raise.hml\n└── args/                 # 命令行参数测试\n    └── basic.hml\n```\n\n### 测试文件命名\n\n**约定：**\n- 使用描述性名称：`method_chaining.hml` 而不是 `test1.hml`\n- 分组相关测试：`string_substr.hml`、`string_slice.hml`\n- 每个文件一个功能区域\n- 保持文件专注且小巧\n\n---\n\n## 运行测试\n\n### 运行所有测试\n\n```bash\n# 从 hemlock 根目录\nmake test\n\n# 或直接\n./tests/run_tests.sh\n```\n\n**输出：**\n```\nRunning tests in tests/primitives/...\n  ✓ integers.hml\n  ✓ floats.hml\n  ✓ booleans.hml\n\nRunning tests in tests/strings/...\n  ✓ concat.hml\n  ✓ methods.hml\n\n...\n\nTotal: 251 tests\nPassed: 251\nFailed: 0\n```\n\n### 运行特定类别\n\n```bash\n# 只运行字符串测试\n./tests/run_tests.sh tests/strings/\n\n# 只运行一个测试文件\n./tests/run_tests.sh tests/strings/concat.hml\n\n# 运行多个类别\n./tests/run_tests.sh tests/strings/ tests/arrays/\n```\n\n### 使用 Valgrind 运行（内存泄漏检查）\n\n```bash\n# 检查单个测试的泄漏\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\n\n# 检查所有测试（很慢！）\nfor test in tests/**/*.hml; do\n    echo \"Testing $test\"\n    valgrind --leak-check=full --error-exitcode=1 ./hemlock \"$test\"\ndone\n```\n\n### 调试失败的测试\n\n```bash\n# 使用详细输出运行\n./hemlock tests/failing_test.hml\n\n# 使用 gdb 运行\ngdb --args ./hemlock tests/failing_test.hml\n(gdb) run\n(gdb) backtrace  # 如果崩溃\n```\n\n---\n\n## 编写测试\n\n### 测试文件格式\n\n测试文件只是带有预期输出的 Hemlock 程序：\n\n**示例：tests/primitives/integers.hml**\n```hemlock\n// 测试基本整数字面量\nlet x = 42;\nprint(x);  // Expect: 42\n\nlet y: i32 = 100;\nprint(y);  // Expect: 100\n\n// 测试算术\nlet sum = x + y;\nprint(sum);  // Expect: 142\n\n// 测试类型推断\nlet small = 10;\nprint(typeof(small));  // Expect: i32\n\nlet large = 5000000000;\nprint(typeof(large));  // Expect: i64\n```\n\n**测试如何工作：**\n1. 测试运行器执行 .hml 文件\n2. 捕获 stdout 输出\n3. 与预期输出比较（从注释或单独的 .out 文件）\n4. 报告通过/失败\n\n### 预期输出方法\n\n**方法 1：内联注释（推荐用于简单测试）**\n\n```hemlock\nprint(\"hello\");  // Expect: hello\nprint(42);       // Expect: 42\n```\n\n测试运行器解析 `// Expect: ...` 注释。\n\n**方法 2：单独的 .out 文件**\n\n创建 `test_name.hml.out` 包含预期输出：\n\n**test_name.hml：**\n```hemlock\nprint(\"line 1\");\nprint(\"line 2\");\nprint(\"line 3\");\n```\n\n**test_name.hml.out：**\n```\nline 1\nline 2\nline 3\n```\n\n### 测试错误情况\n\n错误测试应该导致程序以非零状态退出：\n\n**示例：tests/primitives/range_error.hml**\n```hemlock\n// 这应该因类型错误而失败\nlet x: u8 = 256;  // 超出 u8 范围\n```\n\n**预期行为：**\n- 程序以非零状态退出\n- 向 stderr 打印错误消息\n\n**测试运行器处理：**\n- 期望出错的测试应该在单独的文件中\n- 使用命名约定：`*_error.hml` 或 `*_fail.hml`\n- 在注释中记录预期错误\n\n### 测试成功情况\n\n**示例：tests/strings/methods.hml**\n```hemlock\n// 测试 substr\nlet s = \"hello world\";\nlet sub = s.substr(6, 5);\nprint(sub);  // Expect: world\n\n// 测试 find\nlet pos = s.find(\"world\");\nprint(pos);  // Expect: 6\n\n// 测试 contains\nlet has = s.contains(\"lo\");\nprint(has);  // Expect: true\n\n// 测试 trim\nlet padded = \"  hello  \";\nlet trimmed = padded.trim();\nprint(trimmed);  // Expect: hello\n```\n\n### 测试边界情况\n\n**示例：tests/arrays/edge_cases.hml**\n```hemlock\n// 空数组\nlet empty = [];\nprint(empty.length);  // Expect: 0\n\n// 单个元素\nlet single = [42];\nprint(single[0]);  // Expect: 42\n\n// 负索引（应该在单独的测试文件中出错）\n// print(single[-1]);  // 错误\n\n// 超出末尾索引（应该出错）\n// print(single[100]);  // 错误\n\n// 边界条件\nlet arr = [1, 2, 3];\nprint(arr.slice(0, 0));  // Expect: []（空）\nprint(arr.slice(3, 3));  // Expect: []（空）\nprint(arr.slice(1, 2));  // Expect: [2]\n```\n\n### 测试类型系统\n\n**示例：tests/conversions/promotion.hml**\n```hemlock\n// 测试二元运算中的类型提升\n\n// i32 + i64 -> i64\nlet a: i32 = 10;\nlet b: i64 = 20;\nlet c = a + b;\nprint(typeof(c));  // Expect: i64\n\n// i32 + f32 -> f32\nlet d: i32 = 10;\nlet e: f32 = 3.14;\nlet f = d + e;\nprint(typeof(f));  // Expect: f32\n\n// u8 + i32 -> i32\nlet g: u8 = 5;\nlet h: i32 = 10;\nlet i = g + h;\nprint(typeof(i));  // Expect: i32\n```\n\n### 测试并发\n\n**示例：tests/async/basic.hml**\n```hemlock\nasync fn compute(n: i32): i32 {\n    let sum = 0;\n    let i = 0;\n    while (i < n) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n\n// 生成任务\nlet t1 = spawn(compute, 10);\nlet t2 = spawn(compute, 20);\n\n// 等待并打印结果\nlet r1 = join(t1);\nlet r2 = join(t2);\nprint(r1);  // Expect: 45\nprint(r2);  // Expect: 190\n```\n\n### 测试异常\n\n**示例：tests/exceptions/try_catch.hml**\n```hemlock\n// 测试基本 try/catch\ntry {\n    throw \"error message\";\n} catch (e) {\n    print(\"Caught: \" + e);  // Expect: Caught: error message\n}\n\n// 测试 finally\nlet executed = false;\ntry {\n    print(\"try\");  // Expect: try\n} finally {\n    executed = true;\n    print(\"finally\");  // Expect: finally\n}\n\n// 测试异常传播\nfn risky(): i32 {\n    throw \"failure\";\n}\n\ntry {\n    risky();\n} catch (e) {\n    print(e);  // Expect: failure\n}\n```\n\n---\n\n## 测试类别\n\n### 原始类型测试\n\n**测试什么：**\n- 整数类型（i8、i16、i32、i64、u8、u16、u32、u64）\n- 浮点类型（f32、f64）\n- 布尔类型\n- 字符串类型\n- Rune 类型\n- Null 类型\n\n**示例领域：**\n- 字面量语法\n- 类型推断\n- 范围检查\n- 溢出行为\n- 类型注解\n\n### 转换测试\n\n**测试什么：**\n- 隐式类型提升\n- 显式类型转换\n- 有损转换（应该出错）\n- 运算中的类型提升\n- 跨类型比较\n\n### 内存测试\n\n**测试什么：**\n- alloc/free 正确性\n- Buffer 创建和访问\n- 缓冲区边界检查\n- memset、memcpy、realloc\n- 内存泄漏检测（valgrind）\n\n### 字符串测试\n\n**测试什么：**\n- 连接\n- 所有 18 个字符串方法\n- UTF-8 处理\n- Rune 索引\n- 字符串 + rune 连接\n- 边界情况（空字符串、单字符等）\n\n### 控制流测试\n\n**测试什么：**\n- if/else/else if\n- while 循环\n- for 循环\n- switch 语句\n- break/continue\n- return 语句\n\n### 函数测试\n\n**测试什么：**\n- 函数定义和调用\n- 参数传递\n- 返回值\n- 递归\n- 闭包和捕获\n- 一等函数\n- 匿名函数\n\n### 对象测试\n\n**测试什么：**\n- 对象字面量\n- 字段访问和赋值\n- 方法和 self 绑定\n- 鸭子类型\n- 可选字段\n- JSON 序列化/反序列化\n- 循环引用检测\n\n### 数组测试\n\n**测试什么：**\n- 数组创建\n- 索引和赋值\n- 所有 15 个数组方法\n- 混合类型\n- 动态调整大小\n- 边界情况（空、单个元素）\n\n### 异常测试\n\n**测试什么：**\n- try/catch/finally\n- throw 语句\n- 异常传播\n- 嵌套 try/catch\n- try/catch/finally 中的 return\n- 未捕获的异常\n\n### I/O 测试\n\n**测试什么：**\n- 文件打开模式\n- 读/写操作\n- Seek/tell\n- 文件属性\n- 错误处理（缺少文件等）\n- 资源清理\n\n### 异步测试\n\n**测试什么：**\n- spawn/join/detach\n- Channel send/recv\n- 任务中的异常传播\n- 多个并发任务\n- Channel 阻塞行为\n\n### FFI 测试\n\n**测试什么：**\n- dlopen/dlclose\n- dlsym\n- 各种类型的 dlcall\n- 类型转换\n- 错误处理\n\n---\n\n## 内存泄漏测试\n\n### 使用 Valgrind\n\n**基本用法：**\n```bash\nvalgrind --leak-check=full ./hemlock test.hml\n```\n\n**示例输出（无泄漏）：**\n```\n==12345== HEAP SUMMARY:\n==12345==     in use at exit: 0 bytes in 0 blocks\n==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated\n==12345==\n==12345== All heap blocks were freed -- no leaks are possible\n```\n\n**示例输出（有泄漏）：**\n```\n==12345== LEAK SUMMARY:\n==12345==    definitely lost: 64 bytes in 1 blocks\n==12345==    indirectly lost: 0 bytes in 0 blocks\n==12345==      possibly lost: 0 bytes in 0 blocks\n==12345==    still reachable: 0 bytes in 0 blocks\n==12345==         suppressed: 0 bytes in 0 blocks\n```\n\n### 常见泄漏来源\n\n**1. 缺少 free() 调用：**\n```c\n// 差\nchar *str = malloc(100);\n// ... 使用 str\n// 忘记释放！\n\n// 好\nchar *str = malloc(100);\n// ... 使用 str\nfree(str);\n```\n\n**2. 丢失的指针：**\n```c\n// 差\nchar *ptr = malloc(100);\nptr = malloc(200);  // 丢失了对第一次分配的引用！\n\n// 好\nchar *ptr = malloc(100);\nfree(ptr);\nptr = malloc(200);\n```\n\n**3. 异常路径：**\n```c\n// 差\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        return;  // 泄漏！\n    }\n    free(data);\n}\n\n// 好\nvoid func() {\n    char *data = malloc(100);\n    if (error_condition) {\n        free(data);\n        return;\n    }\n    free(data);\n}\n```\n\n### 已知可接受的泄漏\n\n一些小的\"泄漏\"是有意的启动分配：\n\n**全局内置：**\n```hemlock\n// 内置函数、FFI 类型和常量在启动时分配\n// 并且在退出时不释放（通常约 200 字节）\n```\n\n这些不是真正的泄漏 - 它们是一次性分配，在程序生命周期内持续存在，并在退出时由操作系统清理。\n\n---\n\n## 持续集成\n\n### GitHub Actions（未来）\n\n一旦设置了 CI，所有测试将自动运行：\n- 推送到 main 分支\n- Pull request 创建/更新\n- 每日定时运行\n\n**CI 工作流程：**\n1. 构建 Hemlock\n2. 运行测试套件\n3. 检查内存泄漏（valgrind）\n4. 在 PR 上报告结果\n\n### 提交前检查\n\n在提交之前，运行：\n\n```bash\n# 全新构建\nmake clean && make\n\n# 运行所有测试\nmake test\n\n# 检查一些测试的泄漏\nvalgrind --leak-check=full ./hemlock tests/memory/alloc.hml\nvalgrind --leak-check=full ./hemlock tests/strings/concat.hml\n```\n\n---\n\n## 最佳实践\n\n### 应该做的\n\n**先编写测试（TDD）**\n```bash\n1. 创建 tests/feature/new_feature.hml\n2. 在 src/ 中实现功能\n3. 运行测试直到通过\n```\n\n**测试成功和失败两种情况**\n```hemlock\n// 成功：tests/feature/success.hml\nlet result = do_thing();\nprint(result);  // Expect: expected value\n\n// 失败：tests/feature/failure.hml\ndo_invalid_thing();  // 应该出错\n```\n\n**使用描述性测试名称**\n```\n好：tests/strings/substr_utf8_boundary.hml\n差：tests/test1.hml\n```\n\n**保持测试专注**\n- 每个文件一个功能区域\n- 清晰的设置和断言\n- 最少的代码\n\n**添加解释棘手测试的注释**\n```hemlock\n// 测试闭包通过引用捕获外部变量\nfn outer() {\n    let x = 10;\n    let f = fn() { return x; };\n    x = 20;  // 在闭包创建后修改\n    return f();  // 应该返回 20，而不是 10\n}\n```\n\n**测试边界情况**\n- 空输入\n- Null 值\n- 边界值（最小/最大）\n- 大输入\n- 负值\n\n### 不应该做的\n\n**不要跳过测试**\n- 合并前所有测试必须通过\n- 不要注释掉失败的测试\n- 修复错误或删除功能\n\n**不要编写相互依赖的测试**\n```hemlock\n// 差：test2.hml 依赖于 test1.hml 的输出\n// 测试应该是独立的\n```\n\n**不要在测试中使用随机值**\n```hemlock\n// 差：不确定性\nlet x = random();\nprint(x);  // 无法预测输出\n\n// 好：确定性\nlet x = 42;\nprint(x);  // Expect: 42\n```\n\n**不要测试实现细节**\n```hemlock\n// 差：测试内部结构\nlet obj = { x: 10 };\n// 不要检查内部字段顺序、容量等\n\n// 好：测试行为\nprint(obj.x);  // Expect: 10\n```\n\n**不要忽略内存泄漏**\n- 所有测试应该是 valgrind 清洁的\n- 记录已知/可接受的泄漏\n- 在合并前修复泄漏\n\n### 测试维护\n\n**何时更新测试：**\n- 功能行为更改\n- 错误修复需要新的测试用例\n- 发现边界情况\n- 性能改进\n\n**何时删除测试：**\n- 功能从语言中删除\n- 测试重复了现有覆盖\n- 测试是错误的\n\n**重构测试：**\n- 将相关测试分组在一起\n- 提取公共设置代码\n- 使用一致的命名\n- 保持测试简单和可读\n\n---\n\n## 示例测试会话\n\n这是添加带有测试的功能的完整示例：\n\n### 功能：添加 `array.first()` 方法\n\n**1. 先编写测试：**\n\n```bash\n# 创建测试文件\ncat > tests/arrays/first_method.hml << 'EOF'\n// 测试 array.first() 方法\n\n// 基本情况\nlet arr = [1, 2, 3];\nprint(arr.first());  // Expect: 1\n\n// 单个元素\nlet single = [42];\nprint(single.first());  // Expect: 42\n\n// 空数组（应该出错 - 单独的测试文件）\n// let empty = [];\n// print(empty.first());  // 错误\nEOF\n```\n\n**2. 运行测试（应该失败）：**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n# Error: Method 'first' not found on array\n```\n\n**3. 实现功能：**\n\n编辑 `src/interpreter/builtins.c`：\n\n```c\n// 添加 array_first 方法\nValue *array_first(Value *self, Value **args, int arg_count)\n{\n    if (self->array_value->length == 0) {\n        fprintf(stderr, \"Error: Cannot get first element of empty array\\n\");\n        exit(1);\n    }\n\n    return value_copy(&self->array_value->elements[0]);\n}\n\n// 在数组方法表中注册\n// ... 添加到数组方法注册\n```\n\n**4. 运行测试（应该通过）：**\n\n```bash\n./hemlock tests/arrays/first_method.hml\n1\n42\n# 成功！\n```\n\n**5. 检查内存泄漏：**\n\n```bash\nvalgrind --leak-check=full ./hemlock tests/arrays/first_method.hml\n# All heap blocks were freed -- no leaks are possible\n```\n\n**6. 运行完整测试套件：**\n\n```bash\nmake test\n# Total: 252 tests（251 + 新的）\n# Passed: 252\n# Failed: 0\n```\n\n**7. 提交：**\n\n```bash\ngit add tests/arrays/first_method.hml src/interpreter/builtins.c\ngit commit -m \"Add array.first() method with tests\"\n```\n\n---\n\n## 总结\n\n**记住：**\n- 先编写测试（TDD）\n- 测试成功和失败情况\n- 在提交前运行所有测试\n- 检查内存泄漏\n- 记录已知问题\n- 保持测试简单和专注\n\n**测试质量与代码质量同样重要！**\n"}, "贡献指南 -> 贡献指南": {"id": "contributing-guidelines", "content": "# Hemlock 贡献指南\n\n感谢您有兴趣为 Hemlock 做贡献！本指南将帮助您了解如何有效地贡献代码，同时保持语言的设计理念和代码质量。\n\n---\n\n## 目录\n\n- [开始之前](#开始之前)\n- [贡献工作流程](#贡献工作流程)\n- [代码风格指南](#代码风格指南)\n- [应该贡献什么](#应该贡献什么)\n- [不应该贡献什么](#不应该贡献什么)\n- [常见模式](#常见模式)\n- [添加新功能](#添加新功能)\n- [代码审查流程](#代码审查流程)\n\n---\n\n## 开始之前\n\n### 必读文档\n\n在贡献之前，请按顺序阅读以下文档：\n\n1. **`/home/user/hemlock/docs/design/philosophy.md`** - 了解 Hemlock 的核心原则\n2. **`/home/user/hemlock/docs/design/implementation.md`** - 学习代码库结构\n3. **`/home/user/hemlock/docs/contributing/testing.md`** - 了解测试要求\n4. **本文档** - 学习贡献指南\n\n### 前置条件\n\n**所需知识：**\n- C 编程（指针、内存管理、结构体）\n- 编译器/解释器基础（词法分析、语法分析、AST）\n- Git 和 GitHub 工作流程\n- Unix/Linux 命令行\n\n**所需工具：**\n- GCC 或 Clang 编译器\n- Make 构建系统\n- Git 版本控制\n- Valgrind（用于内存泄漏检测）\n- 基本的文本编辑器或 IDE\n\n### 沟通渠道\n\n**在哪里提问：**\n- GitHub Issues - 错误报告和功能请求\n- GitHub Discussions - 一般问题和设计讨论\n- Pull Request 评论 - 特定代码反馈\n\n---\n\n## 贡献工作流程\n\n### 1. 查找或创建 Issue\n\n**在编写代码之前：**\n- 检查您的贡献是否已有相关 issue\n- 如果没有，创建一个描述您想做什么的 issue\n- 在开始大型更改之前等待维护者反馈\n- 小的错误修复可以跳过此步骤\n\n**良好的 issue 描述包括：**\n- 问题陈述（什么损坏或缺失）\n- 建议的解决方案（您计划如何修复）\n- 示例（展示问题的代码片段）\n- 理由（为什么此更改符合 Hemlock 的理念）\n\n### 2. Fork 和 Clone\n\n```bash\n# 首先在 GitHub 上 fork 仓库，然后：\ngit clone https://github.com/YOUR_USERNAME/hemlock.git\ncd hemlock\ngit checkout -b feature/your-feature-name\n```\n\n### 3. 进行更改\n\n遵循以下指南：\n- 先编写测试（TDD 方法）\n- 实现功能\n- 确保所有测试通过\n- 检查内存泄漏\n- 更新文档\n\n### 4. 测试您的更改\n\n```bash\n# 运行完整测试套件\nmake test\n\n# 运行特定测试类别\n./tests/run_tests.sh tests/category/\n\n# 检查内存泄漏\nvalgrind ./hemlock tests/your_test.hml\n\n# 构建并测试\nmake clean && make && make test\n```\n\n### 5. 提交您的更改\n\n**良好的提交消息：**\n```\nAdd bitwise operators for integer types\n\n- Implement &, |, ^, <<, >>, ~ operators\n- Add type checking to ensure integer-only operations\n- Update operator precedence table\n- Add comprehensive tests for all operators\n\nCloses #42\n```\n\n**提交消息格式：**\n- 第一行：简短摘要（最多 50 个字符）\n- 空行\n- 详细说明（每行 72 个字符换行）\n- 引用 issue 编号\n\n### 6. 提交 Pull Request\n\n**提交之前：**\n- 在最新的 main 分支上 rebase\n- 确保所有测试通过\n- 运行 valgrind 检查泄漏\n- 如果添加面向用户的功能，更新 CLAUDE.md\n\n**Pull request 描述应包括：**\n- 这解决了什么问题\n- 如何解决的\n- 破坏性更改（如果有）\n- 新语法或行为的示例\n- 测试覆盖摘要\n\n---\n\n## 代码风格指南\n\n### C 代码风格\n\n**格式化：**\n```c\n// 使用 4 个空格缩进（不使用制表符）\n// 函数使用 K&R 大括号风格\nvoid function_name(int arg1, char *arg2)\n{\n    if (condition) {\n        // 控制结构大括号在同一行\n        do_something();\n    }\n}\n\n// 行长度：最多 100 个字符\n// 运算符周围使用空格\nint result = (a + b) * c;\n\n// 指针星号与类型一起\nchar *string;   // 正确\nchar* string;   // 避免\nchar * string;  // 避免\n```\n\n**命名约定：**\n```c\n// 函数：小写加下划线\nvoid eval_expression(ASTNode *node);\n\n// 类型：PascalCase\ntypedef struct Value Value;\ntypedef enum ValueType ValueType;\n\n// 常量：大写加下划线\n#define MAX_BUFFER_SIZE 4096\n\n// 变量：小写加下划线\nint item_count;\nValue *current_value;\n\n// 枚举：TYPE_PREFIX_NAME\ntypedef enum {\n    TYPE_I32,\n    TYPE_STRING,\n    TYPE_OBJECT\n} ValueType;\n```\n\n**注释：**\n```c\n// 单行注释用于简短解释\n// 使用完整的句子和正确的大写\n\n/*\n * 多行注释用于较长的解释\n * 对齐星号以提高可读性\n */\n\n/**\n * 函数文档注释\n * @param node - 要评估的 AST 节点\n * @return 评估后的值\n */\nValue eval_expr(ASTNode *node);\n```\n\n**错误处理：**\n```c\n// 检查所有 malloc 调用\nchar *buffer = malloc(size);\nif (!buffer) {\n    fprintf(stderr, \"Error: Out of memory\\n\");\n    exit(1);\n}\n\n// 在错误消息中提供上下文\nif (file == NULL) {\n    fprintf(stderr, \"Error: Failed to open '%s': %s\\n\",\n            filename, strerror(errno));\n    exit(1);\n}\n\n// 使用有意义的错误消息\n// 差：Error: Invalid value\n// 好：Error: Expected integer, got string\n```\n\n**内存管理：**\n```c\n// 始终释放您分配的内存\nValue *val = value_create_i32(42);\n// ... 使用 val\nvalue_free(val);\n\n// 释放后将指针设置为 NULL（防止双重释放）\nfree(ptr);\nptr = NULL;\n\n// 在注释中记录所有权\n// 此函数获取 'value' 的所有权并将释放它\nvoid store_value(Value *value);\n\n// 此函数不获取所有权（调用者必须释放）\nValue *get_value(void);\n```\n\n### 代码组织\n\n**文件结构：**\n```c\n// 1. 包含（系统头文件优先，然后是本地头文件）\n#include <stdio.h>\n#include <stdlib.h>\n#include \"internal.h\"\n#include \"values.h\"\n\n// 2. 常量和宏\n#define INITIAL_CAPACITY 16\n\n// 3. 类型定义\ntypedef struct Foo Foo;\n\n// 4. 静态函数声明（内部辅助函数）\nstatic void helper_function(void);\n\n// 5. 公共函数实现\nvoid public_api_function(void)\n{\n    // 实现\n}\n\n// 6. 静态函数实现\nstatic void helper_function(void)\n{\n    // 实现\n}\n```\n\n**头文件：**\n```c\n// 使用头文件保护\n#ifndef HEMLOCK_MODULE_H\n#define HEMLOCK_MODULE_H\n\n// 前向声明\ntypedef struct Value Value;\n\n// 头文件中只放公共 API\nvoid public_function(Value *val);\n\n// 记录参数和返回值\n/**\n * 评估表达式 AST 节点\n * @param node - 要评估的 AST 节点\n * @param env - 当前环境\n * @return 结果值\n */\nValue *eval_expr(ASTNode *node, Environment *env);\n\n#endif // HEMLOCK_MODULE_H\n```\n\n---\n\n## 应该贡献什么\n\n### 鼓励的贡献\n\n**错误修复：**\n- 内存泄漏\n- 段错误\n- 不正确的行为\n- 错误消息改进\n\n**文档：**\n- 代码注释\n- API 文档\n- 用户指南和教程\n- 示例程序\n- 测试用例文档\n\n**测试：**\n- 现有功能的额外测试用例\n- 边界情况覆盖\n- 已修复错误的回归测试\n- 性能基准测试\n\n**小功能添加：**\n- 新的内置函数（如果符合理念）\n- 字符串/数组方法\n- 实用函数\n- 错误处理改进\n\n**性能改进：**\n- 更快的算法（不改变语义）\n- 减少内存使用\n- 基准测试套件\n- 性能分析工具\n\n**工具：**\n- 编辑器语法高亮\n- 语言服务器协议（LSP）\n- 调试器集成\n- 构建系统改进\n\n### 先讨论\n\n**主要功能：**\n- 新的语言结构\n- 类型系统更改\n- 语法添加\n- 并发原语\n\n**如何讨论：**\n1. 打开 GitHub issue 或 discussion\n2. 描述功能和理由\n3. 展示示例代码\n4. 解释它如何符合 Hemlock 的理念\n5. 等待维护者反馈\n6. 在实现之前迭代设计\n\n---\n\n## 不应该贡献什么\n\n### 不鼓励的贡献\n\n**不要添加以下功能：**\n- 对用户隐藏复杂性\n- 使行为隐式或神奇\n- 破坏现有语义或语法\n- 添加垃圾回收或自动内存管理\n- 违反\"显式优于隐式\"原则\n\n**被拒绝的贡献示例：**\n\n**1. 自动分号插入**\n```hemlock\n// 差：这会被拒绝\nlet x = 5  // 没有分号\nlet y = 10 // 没有分号\n```\n原因：使语法模糊，隐藏错误\n\n**2. RAII/析构函数**\n```hemlock\n// 差：这会被拒绝\nlet f = open(\"file.txt\");\n// 文件在作用域结束时自动关闭\n```\n原因：隐藏资源释放时间，不够显式\n\n**3. 丢失数据的隐式类型转换**\n```hemlock\n// 差：这会被拒绝\nlet x: i32 = 3.14;  // 静默截断为 3\n```\n原因：数据丢失应该是显式的，不是静默的\n\n**4. 垃圾回收**\n```c\n// 差：这会被拒绝\nvoid *gc_malloc(size_t size) {\n    // 跟踪分配以进行自动清理\n}\n```\n原因：隐藏内存管理，性能不可预测\n\n**5. 复杂的宏系统**\n```hemlock\n// 差：这会被拒绝\nmacro repeat($n, $block) {\n    for (let i = 0; i < $n; i++) $block\n}\n```\n原因：太多魔法，使代码难以推理\n\n### 常见拒绝原因\n\n**\"这太隐式了\"**\n- 解决方案：使行为显式并记录它\n\n**\"这隐藏了复杂性\"**\n- 解决方案：暴露复杂性但使其符合人体工程学\n\n**\"这破坏了现有代码\"**\n- 解决方案：找到非破坏性替代方案或讨论版本控制\n\n**\"这不符合 Hemlock 的理念\"**\n- 解决方案：重新阅读 philosophy.md 并重新考虑方法\n\n---\n\n## 常见模式\n\n### 错误处理模式\n\n```c\n// 在 Hemlock 代码中对可恢复错误使用此模式\nValue *divide(Value *a, Value *b)\n{\n    // 检查前置条件\n    if (b->type != TYPE_I32) {\n        // 返回错误值或抛出异常\n        return create_error(\"Expected integer divisor\");\n    }\n\n    if (b->i32_value == 0) {\n        return create_error(\"Division by zero\");\n    }\n\n    // 执行操作\n    return value_create_i32(a->i32_value / b->i32_value);\n}\n```\n\n### 内存管理模式\n\n```c\n// 模式：分配、使用、释放\nvoid process_data(void)\n{\n    // 分配\n    Buffer *buf = create_buffer(1024);\n    char *str = malloc(256);\n\n    // 使用\n    if (buf && str) {\n        // ... 执行工作\n    }\n\n    // 释放（按分配的相反顺序）\n    free(str);\n    free_buffer(buf);\n}\n```\n\n### 值创建模式\n\n```c\n// 使用构造函数创建值\nValue *create_integer(int32_t n)\n{\n    Value *val = malloc(sizeof(Value));\n    if (!val) {\n        fprintf(stderr, \"Out of memory\\n\");\n        exit(1);\n    }\n\n    val->type = TYPE_I32;\n    val->i32_value = n;\n    return val;\n}\n```\n\n### 类型检查模式\n\n```c\n// 在操作之前检查类型\nValue *add_values(Value *a, Value *b)\n{\n    // 类型检查\n    if (a->type != TYPE_I32 || b->type != TYPE_I32) {\n        return create_error(\"Type mismatch\");\n    }\n\n    // 可以安全进行\n    return value_create_i32(a->i32_value + b->i32_value);\n}\n```\n\n### 字符串构建模式\n\n```c\n// 高效构建字符串\nvoid build_error_message(char *buffer, size_t size, const char *detail)\n{\n    snprintf(buffer, size, \"Error: %s (line %d)\", detail, line_number);\n}\n```\n\n---\n\n## 添加新功能\n\n### 功能添加清单\n\n添加新功能时，请遵循以下步骤：\n\n#### 1. 设计阶段\n\n- [ ] 阅读 philosophy.md 以确保一致性\n- [ ] 创建描述功能的 GitHub issue\n- [ ] 获得维护者对设计的批准\n- [ ] 编写规范（语法、语义、示例）\n- [ ] 考虑边界情况和错误条件\n\n#### 2. 实现阶段\n\n**如果添加语言结构：**\n\n- [ ] 在 `lexer.h` 中添加 token 类型（如果需要）\n- [ ] 在 `lexer.c` 中添加词法规则（如果需要）\n- [ ] 在 `ast.h` 中添加 AST 节点类型\n- [ ] 在 `ast.c` 中添加 AST 构造函数\n- [ ] 在 `parser.c` 中添加解析规则\n- [ ] 在 `runtime.c` 或适当的模块中添加运行时行为\n- [ ] 在 AST 释放函数中处理清理\n\n**如果添加内置函数：**\n\n- [ ] 在 `builtins.c` 中添加函数实现\n- [ ] 在 `register_builtins()` 中注册函数\n- [ ] 处理所有参数类型组合\n- [ ] 返回适当的错误值\n- [ ] 记录参数和返回类型\n\n**如果添加值类型：**\n\n- [ ] 在 `values.h` 中添加类型枚举\n- [ ] 向 Value 联合添加字段\n- [ ] 在 `values.c` 中添加构造函数\n- [ ] 添加到 `value_free()` 进行清理\n- [ ] 添加到 `value_copy()` 进行复制\n- [ ] 添加到 `value_to_string()` 进行打印\n- [ ] 如果是数字类型，添加类型提升规则\n\n#### 3. 测试阶段\n\n- [ ] 编写测试用例（参见 testing.md）\n- [ ] 测试成功情况\n- [ ] 测试错误情况\n- [ ] 测试边界情况\n- [ ] 运行完整测试套件（`make test`）\n- [ ] 使用 valgrind 检查内存泄漏\n- [ ] 在多个平台上测试（如果可能）\n\n#### 4. 文档阶段\n\n- [ ] 使用面向用户的文档更新 CLAUDE.md\n- [ ] 添加解释实现的代码注释\n- [ ] 在 `examples/` 中创建示例\n- [ ] 更新相关的 docs/ 文件\n- [ ] 记录任何破坏性更改\n\n#### 5. 提交阶段\n\n- [ ] 清理调试代码和注释\n- [ ] 验证代码风格合规性\n- [ ] 在最新的 main 上 rebase\n- [ ] 创建带有详细描述的 pull request\n- [ ] 响应代码审查反馈\n\n### 示例：添加新运算符\n\n让我们以添加取模运算符 `%` 为例：\n\n**1. 词法分析器（lexer.c）：**\n```c\n// 在 get_next_token() 的 switch 语句中添加\ncase '%':\n    return create_token(TOKEN_PERCENT, \"%\", line);\n```\n\n**2. 词法分析器头文件（lexer.h）：**\n```c\ntypedef enum {\n    // ... 现有 token\n    TOKEN_PERCENT,\n    // ...\n} TokenType;\n```\n\n**3. AST（ast.h）：**\n```c\ntypedef enum {\n    // ... 现有运算符\n    OP_MOD,\n    // ...\n} BinaryOp;\n```\n\n**4. 解析器（parser.c）：**\n```c\n// 添加到 parse_multiplicative() 或适当的优先级级别\nif (match(TOKEN_PERCENT)) {\n    BinaryOp op = OP_MOD;\n    ASTNode *right = parse_unary();\n    left = create_binary_op_node(op, left, right);\n}\n```\n\n**5. 运行时（runtime.c）：**\n```c\n// 添加到 eval_binary_op()\ncase OP_MOD:\n    // 类型检查\n    if (left->type == TYPE_I32 && right->type == TYPE_I32) {\n        if (right->i32_value == 0) {\n            fprintf(stderr, \"Error: Modulo by zero\\n\");\n            exit(1);\n        }\n        return value_create_i32(left->i32_value % right->i32_value);\n    }\n    // ... 处理其他类型组合\n    break;\n```\n\n**6. 测试（tests/operators/modulo.hml）：**\n```hemlock\n// 基本取模\nprint(10 % 3);  // Expect: 2\n\n// 负数取模\nprint(-10 % 3); // Expect: -1\n\n// 错误情况（应该失败）\n// print(10 % 0);  // Division by zero\n```\n\n**7. 文档（CLAUDE.md）：**\n```markdown\n### 算术运算符\n- `+` - 加法\n- `-` - 减法\n- `*` - 乘法\n- `/` - 除法\n- `%` - 取模（余数）\n```\n\n---\n\n## 代码审查流程\n\n### 审查者关注什么\n\n**1. 正确性**\n- 代码是否做了它声称的事情？\n- 是否处理了边界情况？\n- 是否有内存泄漏？\n- 是否正确处理了错误？\n\n**2. 理念一致性**\n- 这是否符合 Hemlock 的设计原则？\n- 是显式的还是隐式的？\n- 是否隐藏了复杂性？\n\n**3. 代码质量**\n- 代码是否可读和可维护？\n- 变量名是否具有描述性？\n- 函数大小是否合理？\n- 是否有足够的文档？\n\n**4. 测试**\n- 是否有足够的测试用例？\n- 测试是否覆盖成功和失败路径？\n- 是否测试了边界情况？\n\n**5. 文档**\n- 面向用户的文档是否已更新？\n- 代码注释是否清晰？\n- 是否提供了示例？\n\n### 响应反馈\n\n**应该做的：**\n- 感谢审查者的时间\n- 如果不理解，请提出澄清问题\n- 如果不同意，解释您的理由\n- 及时进行请求的更改\n- 如果范围更改，更新 PR 描述\n\n**不应该做的：**\n- 把批评当作个人攻击\n- 防御性地争论\n- 忽略反馈\n- 在审查评论上强制推送（除非 rebase）\n- 向 PR 添加不相关的更改\n\n### 让您的 PR 合并\n\n**合并要求：**\n- [ ] 所有测试通过\n- [ ] 无内存泄漏（valgrind 清洁）\n- [ ] 维护者的代码审查批准\n- [ ] 文档已更新\n- [ ] 遵循代码风格指南\n- [ ] 符合 Hemlock 的理念\n\n**时间线：**\n- 小型 PR（错误修复）：通常在几天内审查\n- 中型 PR（新功能）：可能需要 1-2 周\n- 大型 PR（重大更改）：需要广泛讨论\n\n---\n\n## 其他资源\n\n### 学习资源\n\n**理解解释器：**\n- \"Crafting Interpreters\" by Robert Nystrom\n- \"Writing An Interpreter In Go\" by Thorsten Ball\n- \"Modern Compiler Implementation in C\" by Andrew Appel\n\n**C 编程：**\n- \"The C Programming Language\" by K&R\n- \"Expert C Programming\" by Peter van der Linden\n- \"C Interfaces and Implementations\" by David Hanson\n\n**内存管理：**\n- Valgrind 文档\n- \"Understanding and Using C Pointers\" by Richard Reese\n\n### 有用的命令\n\n```bash\n# 使用调试符号构建\nmake clean && make CFLAGS=\"-g -O0\"\n\n# 使用 valgrind 运行\nvalgrind --leak-check=full ./hemlock script.hml\n\n# 运行特定测试类别\n./tests/run_tests.sh tests/strings/\n\n# 生成用于代码导航的 tags 文件\nctags -R .\n\n# 查找所有 TODO 和 FIXME\ngrep -rn \"TODO\\|FIXME\" src/ include/\n```\n\n---\n\n## 有问题？\n\n如果您对贡献有疑问：\n\n1. 查看 `docs/` 中的文档\n2. 搜索现有的 GitHub issues\n3. 在 GitHub Discussions 中提问\n4. 用您的问题打开一个新 issue\n\n**感谢您为 Hemlock 做贡献！**\n"}, "hpm: 快速入门 -> 安装": {"id": "hpm-installation", "content": "# 安装\n\n本指南介绍如何在你的系统上安装 hpm。\n\n## 快速安装（推荐）\n\n使用单个命令安装最新版本：\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\n这会自动：\n- 检测你的操作系统（Linux、macOS）\n- 检测你的架构（x86_64、arm64）\n- 下载相应的预编译二进制文件\n- 安装到 `/usr/local/bin`（如需要会使用 sudo）\n\n### 安装选项\n\n```bash\n# 安装到自定义位置（无需 sudo）\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local\n\n# 安装特定版本\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5\n\n# 组合选项\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5\n```\n\n### 支持的平台\n\n| 平台 | 架构 | 状态 |\n|----------|--------------|--------|\n| Linux    | x86_64       | 支持 |\n| macOS    | x86_64       | 支持 |\n| macOS    | arm64 (M1/M2/M3) | 支持 |\n| Linux    | arm64        | 从源码构建 |\n\n## 从源码构建\n\n如果你希望从源码构建，或需要预编译二进制文件未覆盖的平台，请按以下说明操作。\n\n### 前提条件\n\nhpm 需要先安装 [Hemlock](https://github.com/hemlang/hemlock)。请先按照 Hemlock 安装说明进行操作。\n\n验证 Hemlock 是否已安装：\n\n```bash\nhemlock --version\n```\n\n## 安装方法\n\n### 方法 1：Make Install\n\n从源码构建并安装。\n\n```bash\n# 克隆仓库\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# 安装到 /usr/local/bin（需要 sudo）\nsudo make install\n```\n\n安装后，验证是否正常工作：\n\n```bash\nhpm --version\n```\n\n### 方法 2：自定义位置\n\n安装到自定义目录（无需 sudo）：\n\n```bash\n# 克隆仓库\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# 安装到 ~/.local/bin\nmake install PREFIX=$HOME/.local\n\n# 或任何自定义位置\nmake install PREFIX=/opt/hemlock\n```\n\n确保你的自定义 bin 目录在 PATH 中：\n\n```bash\n# 添加到 ~/.bashrc 或 ~/.zshrc\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n### 方法 3：不安装直接运行\n\n你可以直接运行 hpm 而无需安装：\n\n```bash\n# 克隆仓库\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\n\n# 创建本地包装脚本\nmake\n\n# 从 hpm 目录运行\n./hpm --help\n\n# 或直接通过 hemlock 运行\nhemlock src/main.hml --help\n```\n\n### 方法 4：手动安装\n\n创建你自己的包装脚本：\n\n```bash\n# 克隆到永久位置\ngit clone https://github.com/hemlang/hpm.git ~/.hpm-source\n\n# 创建包装脚本\ncat > ~/.local/bin/hpm << 'EOF'\n#!/bin/sh\nexec hemlock \"$HOME/.hpm-source/src/main.hml\" \"$@\"\nEOF\n\nchmod +x ~/.local/bin/hpm\n```\n\n## 安装变量\n\nMakefile 支持以下变量：\n\n| 变量 | 默认值 | 描述 |\n|----------|---------|-------------|\n| `PREFIX` | `/usr/local` | 安装前缀 |\n| `BINDIR` | `$(PREFIX)/bin` | 二进制文件目录 |\n| `HEMLOCK` | `hemlock` | hemlock 解释器路径 |\n\n使用自定义变量的示例：\n\n```bash\nmake install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock\n```\n\n## 工作原理\n\n安装程序创建一个 shell 包装脚本，使用 hpm 源代码调用 Hemlock 解释器：\n\n```bash\n#!/bin/sh\nexec hemlock \"/path/to/hpm/src/main.hml\" \"$@\"\n```\n\n这种方法：\n- 无需编译\n- 始终运行最新源代码\n- 在所有平台上可靠运行\n\n## 更新 hpm\n\n要将 hpm 更新到最新版本：\n\n```bash\ncd /path/to/hpm\ngit pull origin main\n\n# 如果路径改变了，重新安装\nsudo make install\n```\n\n## 卸载\n\n从系统中移除 hpm：\n\n```bash\ncd /path/to/hpm\nsudo make uninstall\n```\n\n或手动移除：\n\n```bash\nsudo rm /usr/local/bin/hpm\n```\n\n## 验证安装\n\n安装后，验证一切正常：\n\n```bash\n# 检查版本\nhpm --version\n\n# 查看帮助\nhpm --help\n\n# 测试初始化（在空目录中）\nmkdir test-project && cd test-project\nhpm init --yes\ncat package.json\n```\n\n## 故障排除\n\n### \"hemlock: command not found\"\n\nHemlock 未安装或不在 PATH 中。请先安装 Hemlock：\n\n```bash\n# 检查 hemlock 是否存在\nwhich hemlock\n\n# 如果未找到，从 https://github.com/hemlang/hemlock 安装 Hemlock\n```\n\n### \"Permission denied\"\n\n使用 sudo 进行系统范围安装，或安装到用户目录：\n\n```bash\n# 选项 1：使用 sudo\nsudo make install\n\n# 选项 2：安装到用户目录\nmake install PREFIX=$HOME/.local\n```\n\n### 安装后 \"hpm: command not found\"\n\n你的 PATH 可能不包含安装目录：\n\n```bash\n# 检查 hpm 安装位置\nls -la /usr/local/bin/hpm\n\n# 如果使用自定义位置，添加到 PATH\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## 平台特定说明\n\n### Linux\n\n标准安装适用于所有 Linux 发行版。某些发行版可能需要：\n\n```bash\n# Debian/Ubuntu：确保安装构建工具\nsudo apt-get install build-essential git\n\n# Fedora/RHEL\nsudo dnf install make git\n```\n\n### macOS\n\n标准安装可用。如果使用 Homebrew：\n\n```bash\n# 确保安装 Xcode 命令行工具\nxcode-select --install\n```\n\n### Windows (WSL)\n\nhpm 在 Windows Subsystem for Linux 中可用：\n\n```bash\n# 在 WSL 终端中\ngit clone https://github.com/hemlang/hpm.git\ncd hpm\nmake install PREFIX=$HOME/.local\n```\n\n## 后续步骤\n\n安装后：\n\n1. [快速开始](#hpm-installation-quick-start) - 创建你的第一个项目\n2. [命令参考](#hpm-installation-commands) - 学习所有命令\n3. [配置](#hpm-installation-configuration) - 配置 hpm\n"}, "hpm: 快速入门 -> 快速开始": {"id": "hpm-quick-start", "content": "# 快速开始\n\n5 分钟内开始使用 hpm。\n\n## 安装 hpm\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh\n```\n\n更多安装选项请参阅[安装指南](#hpm-quick-start-installation)。\n\n## 创建新项目\n\n首先创建一个新目录并初始化包：\n\n```bash\nmkdir my-project\ncd my-project\nhpm init\n```\n\n系统会提示你输入项目详情：\n\n```\nPackage name (owner/repo): myname/my-project\nVersion (1.0.0):\nDescription: My awesome Hemlock project\nAuthor: Your Name <you@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n使用 `--yes` 接受所有默认值：\n\n```bash\nhpm init --yes\n```\n\n## 项目结构\n\n创建基本项目结构：\n\n```\nmy-project/\n├── package.json        # 项目清单\n├── src/\n│   └── index.hml      # 主入口点\n└── test/\n    └── test.hml       # 测试文件\n```\n\n创建主文件：\n\n```bash\nmkdir -p src test\n```\n\n**src/index.hml:**\n```hemlock\n// Main entry point\nexport fn greet(name: string): string {\n    return \"Hello, \" + name + \"!\";\n}\n\nexport fn main() {\n    print(greet(\"World\"));\n}\n```\n\n## 安装依赖\n\n在 GitHub 上搜索包（包使用 `owner/repo` 格式）：\n\n```bash\n# 安装一个包\nhpm install hemlang/sprout\n\n# 使用版本约束安装\nhpm install hemlang/json@^1.0.0\n\n# 安装为开发依赖\nhpm install hemlang/test-utils --dev\n```\n\n安装后，你的项目结构将包含 `hem_modules/`：\n\n```\nmy-project/\n├── package.json\n├── package-lock.json   # 锁定文件（自动生成）\n├── hem_modules/        # 已安装的包\n│   └── hemlang/\n│       └── sprout/\n├── src/\n│   └── index.hml\n└── test/\n    └── test.hml\n```\n\n## 使用已安装的包\n\n使用 GitHub 路径导入包：\n\n```hemlock\n// Import from installed package\nimport { app, router } from \"hemlang/sprout\";\nimport { parse, stringify } from \"hemlang/json\";\n\n// Import from subpath\nimport { middleware } from \"hemlang/sprout/middleware\";\n\n// Standard library (built-in)\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile } from \"@stdlib/fs\";\n```\n\n## 添加脚本\n\n在 `package.json` 中添加脚本：\n\n```json\n{\n  \"name\": \"myname/my-project\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/test.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\n使用 `hpm run` 运行脚本：\n\n```bash\nhpm run start\nhpm run build\n\n# test 的简写形式\nhpm test\n```\n\n## 常用工作流\n\n### 安装所有依赖\n\n当你克隆一个带有 `package.json` 的项目时：\n\n```bash\ngit clone https://github.com/someone/project.git\ncd project\nhpm install\n```\n\n### 更新依赖\n\n将所有包更新到约束范围内的最新版本：\n\n```bash\nhpm update\n```\n\n更新特定的包：\n\n```bash\nhpm update hemlang/sprout\n```\n\n### 查看已安装的包\n\n列出所有已安装的包：\n\n```bash\nhpm list\n```\n\n输出显示依赖树：\n\n```\nmy-project@1.0.0\n├── hemlang/sprout@2.1.0\n│   └── hemlang/router@1.5.0\n└── hemlang/json@1.2.3\n```\n\n### 检查更新\n\n查看哪些包有更新版本：\n\n```bash\nhpm outdated\n```\n\n### 移除包\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n## 示例：Web 应用\n\n这是一个使用 Web 框架的完整示例：\n\n**package.json:**\n```json\n{\n  \"name\": \"myname/my-web-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A web application\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"dev\": \"hemlock --watch src/index.hml\"\n  }\n}\n```\n\n**src/index.hml:**\n```hemlock\nimport { App, Router } from \"hemlang/sprout\";\n\nfn main() {\n    let app = App.new();\n    let router = Router.new();\n\n    router.get(\"/\", fn(req, res) {\n        res.send(\"Hello, World!\");\n    });\n\n    router.get(\"/api/status\", fn(req, res) {\n        res.json({ status: \"ok\" });\n    });\n\n    app.use(router);\n    app.listen(3000);\n\n    print(\"Server running on http://localhost:3000\");\n}\n```\n\n运行应用：\n\n```bash\nhpm install\nhpm run start\n```\n\n## 后续步骤\n\n- [命令参考](#hpm-quick-start-commands) - 学习所有 hpm 命令\n- [创建包](#hpm-quick-start-creating-packages) - 发布你自己的包\n- [配置](#hpm-quick-start-configuration) - 配置 hpm 和 GitHub token\n- [项目设置](#hpm-quick-start-project-setup) - 详细的项目配置\n"}, "hpm: 快速入门 -> 项目设置": {"id": "hpm-project-setup", "content": "# 项目设置\n\n使用 hpm 设置 Hemlock 项目的完整指南。\n\n## 创建新项目\n\n### 基本设置\n\n从头创建新项目：\n\n```bash\n# 创建项目目录\nmkdir my-project\ncd my-project\n\n# 初始化 package.json\nhpm init\n\n# 创建目录结构\nmkdir -p src test\n```\n\n### 项目模板\n\n以下是不同用例的常见项目结构：\n\n#### 库包\n\n用于可复用的库：\n\n```\nmy-library/\n├── package.json\n├── README.md\n├── LICENSE\n├── src/\n│   ├── index.hml          # 主入口，导出公共 API\n│   ├── core.hml           # 核心功能\n│   ├── utils.hml          # 工具函数\n│   └── types.hml          # 类型定义\n└── test/\n    ├── framework.hml      # 测试框架\n    ├── run.hml            # 测试运行器\n    └── test_core.hml      # 测试\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-library\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A reusable Hemlock library\",\n  \"main\": \"src/index.hml\",\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {}\n}\n```\n\n#### 应用程序\n\n用于独立应用程序：\n\n```\nmy-app/\n├── package.json\n├── README.md\n├── src/\n│   ├── main.hml           # 应用程序入口点\n│   ├── config.hml         # 配置\n│   ├── commands/          # CLI 命令\n│   │   ├── index.hml\n│   │   └── run.hml\n│   └── lib/               # 内部库\n│       └── utils.hml\n├── test/\n│   └── run.hml\n└── data/                  # 数据文件\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Hemlock application\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {}\n}\n```\n\n#### Web 应用程序\n\n用于 Web 服务器：\n\n```\nmy-web-app/\n├── package.json\n├── README.md\n├── src/\n│   ├── main.hml           # 服务器入口点\n│   ├── routes/            # 路由处理器\n│   │   ├── index.hml\n│   │   ├── api.hml\n│   │   └── auth.hml\n│   ├── middleware/        # 中间件\n│   │   ├── index.hml\n│   │   └── auth.hml\n│   ├── models/            # 数据模型\n│   │   └── user.hml\n│   └── services/          # 业务逻辑\n│       └── user.hml\n├── test/\n│   └── run.hml\n├── static/                # 静态文件\n│   ├── css/\n│   └── js/\n└── views/                 # 模板\n    └── index.hml\n```\n\n**package.json:**\n\n```json\n{\n  \"name\": \"yourusername/my-web-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A Hemlock web application\",\n  \"main\": \"src/main.hml\",\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\"\n  },\n  \"dependencies\": {\n    \"hemlang/sprout\": \"^2.0.0\",\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  }\n}\n```\n\n## package.json 文件\n\n### 必需字段\n\n```json\n{\n  \"name\": \"owner/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n### 所有字段\n\n```json\n{\n  \"name\": \"yourusername/my-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Package description\",\n  \"author\": \"Your Name <you@example.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/yourusername/my-package\",\n  \"homepage\": \"https://yourusername.github.io/my-package\",\n  \"bugs\": \"https://github.com/yourusername/my-package/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"utility\", \"parser\"],\n  \"dependencies\": {\n    \"owner/package\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"owner/test-lib\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n### 字段参考\n\n| 字段 | 类型 | 描述 |\n|-------|------|-------------|\n| `name` | string | owner/repo 格式的包名称（必需） |\n| `version` | string | 语义化版本（必需） |\n| `description` | string | 简短描述 |\n| `author` | string | 作者姓名和邮箱 |\n| `license` | string | 许可证标识符（MIT、Apache-2.0 等） |\n| `repository` | string | 仓库 URL |\n| `homepage` | string | 项目主页 |\n| `bugs` | string | 问题跟踪器 URL |\n| `main` | string | 入口点文件（默认：src/index.hml） |\n| `keywords` | array | 搜索关键词 |\n| `dependencies` | object | 运行时依赖 |\n| `devDependencies` | object | 开发依赖 |\n| `scripts` | object | 命名脚本 |\n| `files` | array | 发布时包含的文件 |\n| `native` | object | 原生库要求 |\n\n## package-lock.json 文件\n\n锁定文件自动生成，应提交到版本控制。它确保可重现的安装。\n\n```json\n{\n  \"lockVersion\": 1,\n  \"hemlock\": \"1.0.0\",\n  \"dependencies\": {\n    \"hemlang/sprout\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz\",\n      \"integrity\": \"sha256-abc123...\",\n      \"dependencies\": {\n        \"hemlang/router\": \"^1.5.0\"\n      }\n    },\n    \"hemlang/router\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://github.com/hemlang/router/archive/v1.5.0.tar.gz\",\n      \"integrity\": \"sha256-def456...\",\n      \"dependencies\": {}\n    }\n  }\n}\n```\n\n### 锁定文件最佳实践\n\n- **提交** package-lock.json 到版本控制\n- **不要手动编辑** - 它是自动生成的\n- **拉取更改后运行 `hpm install`**\n- **如果损坏则删除并重新生成**：\n  ```bash\n  rm package-lock.json\n  hpm install\n  ```\n\n## hem_modules 目录\n\n已安装的包存储在 `hem_modules/` 中：\n\n```\nhem_modules/\n├── hemlang/\n│   ├── sprout/\n│   │   ├── package.json\n│   │   └── src/\n│   └── router/\n│       ├── package.json\n│       └── src/\n└── alice/\n    └── http-client/\n        ├── package.json\n        └── src/\n```\n\n### hem_modules 最佳实践\n\n- **添加到 .gitignore** - 不要提交依赖\n- **不要修改** - 更改会被覆盖\n- **删除以重新安装**：\n  ```bash\n  rm -rf hem_modules\n  hpm install\n  ```\n\n## .gitignore\n\nHemlock 项目推荐的 .gitignore：\n\n```gitignore\n# Dependencies\nhem_modules/\n\n# Build output\ndist/\n*.hmlc\n\n# IDE files\n.idea/\n.vscode/\n*.swp\n*.swo\n\n# OS files\n.DS_Store\nThumbs.db\n\n# Logs\n*.log\nlogs/\n\n# Environment\n.env\n.env.local\n\n# Test coverage\ncoverage/\n```\n\n## 使用依赖\n\n### 添加依赖\n\n```bash\n# 添加运行时依赖\nhpm install hemlang/json\n\n# 使用版本约束添加\nhpm install hemlang/sprout@^2.0.0\n\n# 添加开发依赖\nhpm install hemlang/test-utils --dev\n```\n\n### 导入依赖\n\n```hemlock\n// Import from package (uses \"main\" entry)\nimport { parse, stringify } from \"hemlang/json\";\n\n// Import from subpath\nimport { Router } from \"hemlang/sprout/router\";\n\n// Import standard library\nimport { HashMap } from \"@stdlib/collections\";\nimport { readFile, writeFile } from \"@stdlib/fs\";\n```\n\n### 导入解析\n\nhpm 按以下顺序解析导入：\n\n1. **标准库**：`@stdlib/*` 导入内置模块\n2. **包根目录**：`owner/repo` 使用 `main` 字段\n3. **子路径**：`owner/repo/path` 检查：\n   - `hem_modules/owner/repo/path.hml`\n   - `hem_modules/owner/repo/path/index.hml`\n   - `hem_modules/owner/repo/src/path.hml`\n   - `hem_modules/owner/repo/src/path/index.hml`\n\n## 脚本\n\n### 定义脚本\n\n在 package.json 中添加脚本：\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n### 运行脚本\n\n```bash\nhpm run start\nhpm run dev\nhpm run build\n\n# test 的简写\nhpm test\n\n# 传递参数\nhpm run test -- --verbose --filter=unit\n```\n\n### 脚本命名约定\n\n| 脚本 | 用途 |\n|--------|---------|\n| `start` | 运行应用程序 |\n| `dev` | 以开发模式运行 |\n| `test` | 运行所有测试 |\n| `build` | 为生产环境构建 |\n| `clean` | 移除生成的文件 |\n| `lint` | 检查代码风格 |\n| `format` | 格式化代码 |\n\n## 开发工作流\n\n### 初始设置\n\n```bash\n# 克隆项目\ngit clone https://github.com/yourusername/my-project.git\ncd my-project\n\n# 安装依赖\nhpm install\n\n# 运行测试\nhpm test\n\n# 开始开发\nhpm run dev\n```\n\n### 日常工作流\n\n```bash\n# 拉取最新更改\ngit pull\n\n# 安装任何新依赖\nhpm install\n\n# 进行更改...\n\n# 运行测试\nhpm test\n\n# 提交\ngit add .\ngit commit -m \"Add feature\"\ngit push\n```\n\n### 添加新功能\n\n```bash\n# 创建功能分支\ngit checkout -b feature/new-feature\n\n# 如果需要，添加新依赖\nhpm install hemlang/new-lib\n\n# 实现功能...\n\n# 测试\nhpm test\n\n# 提交并推送\ngit add .\ngit commit -m \"Add new feature\"\ngit push -u origin feature/new-feature\n```\n\n## 环境特定配置\n\n### 使用环境变量\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nlet db_host = getenv(\"DATABASE_HOST\") ?? \"localhost\";\nlet api_key = getenv(\"API_KEY\") ?? \"\";\n\nif api_key == \"\" {\n    print(\"Warning: API_KEY not set\");\n}\n```\n\n### 配置文件\n\n**config.hml:**\n\n```hemlock\nimport { getenv } from \"@stdlib/env\";\n\nexport let config = {\n    environment: getenv(\"HEMLOCK_ENV\") ?? \"development\",\n    database: {\n        host: getenv(\"DB_HOST\") ?? \"localhost\",\n        port: int(getenv(\"DB_PORT\") ?? \"5432\"),\n        name: getenv(\"DB_NAME\") ?? \"myapp\"\n    },\n    server: {\n        port: int(getenv(\"PORT\") ?? \"3000\"),\n        host: getenv(\"HOST\") ?? \"0.0.0.0\"\n    }\n};\n\nexport fn is_production(): bool {\n    return config.environment == \"production\";\n}\n```\n\n## 另请参阅\n\n- [快速开始](#hpm-project-setup-quick-start) - 快速入门\n- [命令](#hpm-project-setup-commands) - 命令参考\n- [创建包](#hpm-project-setup-creating-packages) - 发布包\n- [配置](#hpm-project-setup-configuration) - hpm 配置\n"}, "hpm: 用户指南 -> 命令": {"id": "hpm-commands", "content": "# 命令参考\n\n所有 hpm 命令的完整参考。\n\n## 全局选项\n\n这些选项适用于任何命令：\n\n| 选项 | 描述 |\n|--------|-------------|\n| `--help`, `-h` | 显示帮助信息 |\n| `--version`, `-v` | 显示 hpm 版本 |\n| `--verbose` | 显示详细输出 |\n\n## 命令\n\n### hpm init\n\n创建新的 `package.json` 文件。\n\n```bash\nhpm init        # 交互模式\nhpm init --yes  # 接受所有默认值\nhpm init -y     # 简写形式\n```\n\n**选项：**\n\n| 选项 | 描述 |\n|--------|-------------|\n| `--yes`, `-y` | 对所有提示接受默认值 |\n\n**交互提示：**\n- 包名称（owner/repo 格式）\n- 版本（默认：1.0.0）\n- 描述\n- 作者\n- 许可证（默认：MIT）\n- 主文件（默认：src/index.hml）\n\n**示例：**\n\n```bash\n$ hpm init\nPackage name (owner/repo): alice/my-lib\nVersion (1.0.0):\nDescription: A utility library\nAuthor: Alice <alice@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n---\n\n### hpm install\n\n安装依赖或添加新包。\n\n```bash\nhpm install                           # 从 package.json 安装所有依赖\nhpm install owner/repo                # 添加并安装包\nhpm install owner/repo@^1.0.0        # 使用版本约束\nhpm install owner/repo --dev         # 作为开发依赖\nhpm i owner/repo                      # 简写形式\n```\n\n**选项：**\n\n| 选项 | 描述 |\n|--------|-------------|\n| `--dev`, `-D` | 添加到 devDependencies |\n| `--verbose` | 显示详细进度 |\n| `--dry-run` | 预览而不安装 |\n| `--offline` | 仅从缓存安装（无网络） |\n| `--parallel` | 启用并行下载（实验性） |\n\n**版本约束语法：**\n\n| 语法 | 示例 | 含义 |\n|--------|---------|---------|\n| （无） | `owner/repo` | 最新版本 |\n| 精确 | `owner/repo@1.2.3` | 正好是 1.2.3 |\n| 插入符 | `owner/repo@^1.2.3` | >=1.2.3 <2.0.0 |\n| 波浪号 | `owner/repo@~1.2.3` | >=1.2.3 <1.3.0 |\n| 范围 | `owner/repo@>=1.0.0` | 至少 1.0.0 |\n\n**示例：**\n\n```bash\n# 安装所有依赖\nhpm install\n\n# 安装特定包\nhpm install hemlang/json\n\n# 使用版本约束安装\nhpm install hemlang/sprout@^2.0.0\n\n# 安装为开发依赖\nhpm install hemlang/test-utils --dev\n\n# 预览将要安装的内容\nhpm install hemlang/sprout --dry-run\n\n# 详细输出\nhpm install --verbose\n\n# 仅从缓存安装（离线）\nhpm install --offline\n```\n\n**输出：**\n\n```\nInstalling dependencies...\n  + hemlang/sprout@2.1.0\n  + hemlang/router@1.5.0 (dependency of hemlang/sprout)\n\nInstalled 2 packages in 1.2s\n```\n\n---\n\n### hpm uninstall\n\n移除一个包。\n\n```bash\nhpm uninstall owner/repo\nhpm rm owner/repo          # 简写形式\nhpm remove owner/repo      # 替代形式\n```\n\n**示例：**\n\n```bash\nhpm uninstall hemlang/sprout\n```\n\n**输出：**\n\n```\nRemoved hemlang/sprout@2.1.0\nUpdated package.json\nUpdated package-lock.json\n```\n\n---\n\n### hpm update\n\n将包更新到约束范围内的最新版本。\n\n```bash\nhpm update              # 更新所有包\nhpm update owner/repo   # 更新特定包\nhpm up owner/repo       # 简写形式\n```\n\n**选项：**\n\n| 选项 | 描述 |\n|--------|-------------|\n| `--verbose` | 显示详细进度 |\n| `--dry-run` | 预览而不更新 |\n\n**示例：**\n\n```bash\n# 更新所有包\nhpm update\n\n# 更新特定包\nhpm update hemlang/sprout\n\n# 预览更新\nhpm update --dry-run\n```\n\n**输出：**\n\n```\nUpdating dependencies...\n  hemlang/sprout: 2.0.0 → 2.1.0\n  hemlang/router: 1.4.0 → 1.5.0\n\nUpdated 2 packages\n```\n\n---\n\n### hpm list\n\n显示已安装的包。\n\n```bash\nhpm list              # 显示完整依赖树\nhpm list --depth=0    # 仅直接依赖\nhpm list --depth=1    # 一级传递依赖\nhpm ls                # 简写形式\n```\n\n**选项：**\n\n| 选项 | 描述 |\n|--------|-------------|\n| `--depth=N` | 限制树深度（默认：全部） |\n\n**示例：**\n\n```bash\n$ hpm list\nmy-project@1.0.0\n├── hemlang/sprout@2.1.0\n│   ├── hemlang/router@1.5.0\n│   └── hemlang/middleware@1.2.0\n├── hemlang/json@1.2.3\n└── hemlang/test-utils@1.0.0 (dev)\n\n$ hpm list --depth=0\nmy-project@1.0.0\n├── hemlang/sprout@2.1.0\n├── hemlang/json@1.2.3\n└── hemlang/test-utils@1.0.0 (dev)\n```\n\n---\n\n### hpm outdated\n\n显示有更新版本的包。\n\n```bash\nhpm outdated\n```\n\n**输出：**\n\n```\nPackage            Current  Wanted  Latest\nhemlang/sprout     2.0.0    2.0.5   2.1.0\nhemlang/router     1.4.0    1.4.2   1.5.0\n```\n\n- **Current**：已安装版本\n- **Wanted**：符合约束的最高版本\n- **Latest**：最新可用版本\n\n---\n\n### hpm run\n\n执行 package.json 中的脚本。\n\n```bash\nhpm run <script>\nhpm run <script> -- <args>\n```\n\n**示例：**\n\n给定以下 package.json：\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/index.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/app.hmlc\"\n  }\n}\n```\n\n运行脚本：\n\n```bash\nhpm run start\nhpm run test\nhpm run build\n\n# 向脚本传递参数\nhpm run test -- --verbose\n```\n\n---\n\n### hpm test\n\n`hpm run test` 的简写。\n\n```bash\nhpm test\nhpm test -- --verbose\n```\n\n等同于：\n\n```bash\nhpm run test\n```\n\n---\n\n### hpm why\n\n解释为什么安装了某个包（显示依赖链）。\n\n```bash\nhpm why owner/repo\n```\n\n**示例：**\n\n```bash\n$ hpm why hemlang/router\n\nhemlang/router@1.5.0 is installed because:\n\nmy-project@1.0.0\n└── hemlang/sprout@2.1.0\n    └── hemlang/router@1.5.0\n```\n\n---\n\n### hpm cache\n\n管理全局包缓存。\n\n```bash\nhpm cache list    # 列出缓存的包\nhpm cache clean   # 清除所有缓存的包\n```\n\n**子命令：**\n\n| 子命令 | 描述 |\n|------------|-------------|\n| `list` | 显示所有缓存的包及大小 |\n| `clean` | 移除所有缓存的包 |\n\n**示例：**\n\n```bash\n$ hpm cache list\nCached packages in ~/.hpm/cache:\n\nhemlang/sprout\n  2.0.0 (1.2 MB)\n  2.1.0 (1.3 MB)\nhemlang/router\n  1.5.0 (450 KB)\n\nTotal: 2.95 MB\n\n$ hpm cache clean\nCleared cache (2.95 MB freed)\n```\n\n---\n\n## 命令快捷方式\n\n为方便起见，多个命令有简短别名：\n\n| 命令 | 快捷方式 |\n|---------|-----------|\n| `install` | `i` |\n| `uninstall` | `rm`, `remove` |\n| `list` | `ls` |\n| `update` | `up` |\n\n**示例：**\n\n```bash\nhpm i hemlang/sprout        # hpm install hemlang/sprout\nhpm rm hemlang/sprout       # hpm uninstall hemlang/sprout\nhpm ls                      # hpm list\nhpm up                      # hpm update\n```\n\n---\n\n## 退出码\n\nhpm 使用特定的退出码来指示不同的错误条件：\n\n| 代码 | 含义 |\n|------|---------|\n| 0 | 成功 |\n| 1 | 依赖冲突 |\n| 2 | 包未找到 |\n| 3 | 版本未找到 |\n| 4 | 网络错误 |\n| 5 | 无效的 package.json |\n| 6 | 完整性检查失败 |\n| 7 | 超出 GitHub 速率限制 |\n| 8 | 循环依赖 |\n\n在脚本中使用退出码：\n\n```bash\nhpm install\nif [ $? -ne 0 ]; then\n    echo \"Installation failed\"\n    exit 1\nfi\n```\n\n---\n\n## 环境变量\n\nhpm 支持以下环境变量：\n\n| 变量 | 描述 |\n|----------|-------------|\n| `GITHUB_TOKEN` | GitHub API token 用于认证 |\n| `HPM_CACHE_DIR` | 覆盖缓存目录位置 |\n| `HOME` | 用户主目录（用于配置/缓存） |\n\n**示例：**\n\n```bash\n# 使用 GitHub token 获得更高的速率限制\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# 使用自定义缓存目录\nexport HPM_CACHE_DIR=/tmp/hpm-cache\nhpm install\n```\n\n---\n\n## 另请参阅\n\n- [配置](#hpm-commands-configuration) - 配置文件\n- [包规范](#hpm-commands-package-spec) - package.json 格式\n- [故障排除](#hpm-commands-troubleshooting) - 常见问题\n"}, "hpm: 用户指南 -> 故障排除": {"id": "hpm-troubleshooting", "content": "# 故障排除\n\n常见 hpm 问题的解决方案。\n\n## 安装问题\n\n### \"hemlock: command not found\"\n\n**原因：** Hemlock 未安装或不在 PATH 中。\n\n**解决方案：**\n\n```bash\n# 检查 hemlock 是否存在\nwhich hemlock\n\n# 如果未找到，请先安装 Hemlock\n# 访问：https://github.com/hemlang/hemlock\n\n# 安装后，验证\nhemlock --version\n```\n\n### \"hpm: command not found\"\n\n**原因：** hpm 未安装或不在 PATH 中。\n\n**解决方案：**\n\n```bash\n# 检查 hpm 安装位置\nls -la /usr/local/bin/hpm\nls -la ~/.local/bin/hpm\n\n# 如果使用自定义位置，添加到 PATH\nexport PATH=\"$HOME/.local/bin:$PATH\"\n\n# 添加到 ~/.bashrc 或 ~/.zshrc 以持久化\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc\nsource ~/.bashrc\n\n# 如需要重新安装\ncd /path/to/hpm\nsudo make install\n```\n\n### 安装时 \"Permission denied\"\n\n**原因：** 对安装目录没有写权限。\n\n**解决方案：**\n\n```bash\n# 选项 1：使用 sudo 进行系统范围安装\nsudo make install\n\n# 选项 2：安装到用户目录（无需 sudo）\nmake install PREFIX=$HOME/.local\n```\n\n## 依赖问题\n\n### \"Package not found\"（退出码 2）\n\n**原因：** 包在 GitHub 上不存在。\n\n**解决方案：**\n\n```bash\n# 验证包是否存在\n# 检查：https://github.com/owner/repo\n\n# 验证拼写\nhpm install hemlang/sprout  # 正确\nhpm install hemlan/sprout   # 错误的 owner\nhpm install hemlang/spout   # 错误的 repo\n\n# 检查 package.json 中的拼写错误\ncat package.json | grep -A 5 dependencies\n```\n\n### \"Version not found\"（退出码 3）\n\n**原因：** 没有发布版本匹配版本约束。\n\n**解决方案：**\n\n```bash\n# 列出可用版本（检查 GitHub releases/tags）\n# 标签必须以 'v' 开头（例如 v1.0.0）\n\n# 使用有效的版本约束\nhpm install owner/repo@^1.0.0\n\n# 尝试最新版本\nhpm install owner/repo\n\n# 在 GitHub 上检查可用标签\n# https://github.com/owner/repo/tags\n```\n\n### \"Dependency conflict\"（退出码 1）\n\n**原因：** 两个包需要不兼容版本的依赖。\n\n**解决方案：**\n\n```bash\n# 查看冲突\nhpm install --verbose\n\n# 检查什么需要该依赖\nhpm why conflicting/package\n\n# 解决方案：\n# 1. 更新冲突的包\nhpm update problem/package\n\n# 2. 更改 package.json 中的版本约束\n# 编辑以允许兼容的版本\n\n# 3. 移除冲突的包之一\nhpm uninstall one/package\n```\n\n### \"Circular dependency\"（退出码 8）\n\n**原因：** 包 A 依赖 B，B 又依赖 A。\n\n**解决方案：**\n\n```bash\n# 识别循环\nhpm install --verbose\n\n# 这通常是包中的 bug\n# 联系包维护者\n\n# 变通方法：避免使用其中一个包\n```\n\n## 网络问题\n\n### \"Network error\"（退出码 4）\n\n**原因：** 无法连接到 GitHub API。\n\n**解决方案：**\n\n```bash\n# 检查网络连接\nping github.com\n\n# 检查 GitHub API 是否可访问\ncurl -I https://api.github.com\n\n# 重试（hpm 会自动重试）\nhpm install\n\n# 如果包已缓存，使用离线模式\nhpm install --offline\n\n# 如果在防火墙后面，检查代理设置\nexport HTTPS_PROXY=http://proxy:8080\nhpm install\n```\n\n### \"GitHub rate limit exceeded\"（退出码 7）\n\n**原因：** 未认证时 API 请求过多。\n\n**解决方案：**\n\n```bash\n# 选项 1：使用 GitHub token 认证（推荐）\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# 创建 token：GitHub → Settings → Developer settings → Personal access tokens\n\n# 选项 2：将 token 保存在配置文件中\nmkdir -p ~/.hpm\necho '{\"github_token\": \"ghp_xxxxxxxxxxxx\"}' > ~/.hpm/config.json\n\n# 选项 3：等待速率限制重置（每小时重置）\n\n# 选项 4：使用离线模式\nhpm install --offline\n```\n\n### 连接超时\n\n**原因：** 网络慢或 GitHub API 问题。\n\n**解决方案：**\n\n```bash\n# hpm 会自动使用指数退避重试\n\n# 检查 GitHub 是否有问题\n# 访问：https://www.githubstatus.com\n\n# 稍后重试\nhpm install\n\n# 使用缓存的包\nhpm install --offline\n```\n\n## Package.json 问题\n\n### \"Invalid package.json\"（退出码 5）\n\n**原因：** 格式错误或缺少必需字段。\n\n**解决方案：**\n\n```bash\n# 验证 JSON 语法\ncat package.json | python -m json.tool\n\n# 检查必需字段\ncat package.json\n\n# 必需字段：\n# - \"name\"：owner/repo 格式\n# - \"version\"：X.Y.Z 格式\n\n# 如需要重新生成\nrm package.json\nhpm init\n```\n\n### \"name\" 格式错误\n\n**原因：** 包名称不是 `owner/repo` 格式。\n\n**解决方案：**\n\n```json\n// 错误\n{\n  \"name\": \"my-package\"\n}\n\n// 正确\n{\n  \"name\": \"yourusername/my-package\"\n}\n```\n\n### \"version\" 格式错误\n\n**原因：** 版本不是 semver 格式。\n\n**解决方案：**\n\n```json\n// 错误\n{\n  \"version\": \"1.0\"\n}\n\n// 正确\n{\n  \"version\": \"1.0.0\"\n}\n```\n\n## 锁定文件问题\n\n### 锁定文件不同步\n\n**原因：** package.json 修改后未运行 install。\n\n**解决方案：**\n\n```bash\n# 重新生成锁定文件\nrm package-lock.json\nhpm install\n```\n\n### 锁定文件损坏\n\n**原因：** 无效的 JSON 或手动编辑。\n\n**解决方案：**\n\n```bash\n# 检查 JSON 有效性\ncat package-lock.json | python -m json.tool\n\n# 重新生成\nrm package-lock.json\nhpm install\n```\n\n## hem_modules 问题\n\n### 包未安装\n\n**原因：** 各种可能的问题。\n\n**解决方案：**\n\n```bash\n# 清理并重新安装\nrm -rf hem_modules\nhpm install\n\n# 检查详细输出\nhpm install --verbose\n```\n\n### Import 不工作\n\n**原因：** 包未正确安装或导入路径错误。\n\n**解决方案：**\n\n```bash\n# 验证包已安装\nls hem_modules/owner/repo/\n\n# 检查 package.json 的 main 字段\ncat hem_modules/owner/repo/package.json\n\n# 正确的导入格式\nimport { x } from \"owner/repo\";          # 使用 main 入口\nimport { y } from \"owner/repo/subpath\";  # 子路径导入\n```\n\n### \"Module not found\" 错误\n\n**原因：** 导入路径未解析到文件。\n\n**解决方案：**\n\n```bash\n# 检查导入路径\nls hem_modules/owner/repo/src/\n\n# 检查 index.hml\nls hem_modules/owner/repo/src/index.hml\n\n# 验证 package.json 中的 main 字段\ncat hem_modules/owner/repo/package.json | grep main\n```\n\n## 缓存问题\n\n### 缓存占用太多空间\n\n**解决方案：**\n\n```bash\n# 查看缓存大小\nhpm cache list\n\n# 清除缓存\nhpm cache clean\n```\n\n### 缓存权限\n\n**解决方案：**\n\n```bash\n# 修复权限\nchmod -R u+rw ~/.hpm/cache\n\n# 或移除并重新安装\nrm -rf ~/.hpm/cache\nhpm install\n```\n\n### 使用错误的缓存\n\n**解决方案：**\n\n```bash\n# 检查缓存位置\necho $HPM_CACHE_DIR\nls ~/.hpm/cache\n\n# 如果不正确，清除环境变量\nunset HPM_CACHE_DIR\n```\n\n## 脚本问题\n\n### \"Script not found\"\n\n**原因：** 脚本名称在 package.json 中不存在。\n\n**解决方案：**\n\n```bash\n# 列出可用脚本\ncat package.json | grep -A 20 scripts\n\n# 检查拼写\nhpm run test    # 正确\nhpm run tests   # 如果脚本名为 \"test\" 则错误\n```\n\n### 脚本失败\n\n**原因：** 脚本命令中有错误。\n\n**解决方案：**\n\n```bash\n# 直接运行命令以查看错误\nhemlock test/run.hml\n\n# 检查脚本定义\ncat package.json | grep test\n```\n\n## 调试\n\n### 启用详细输出\n\n```bash\nhpm install --verbose\n```\n\n### 检查 hpm 版本\n\n```bash\nhpm --version\n```\n\n### 检查 hemlock 版本\n\n```bash\nhemlock --version\n```\n\n### 干运行\n\n预览而不进行更改：\n\n```bash\nhpm install --dry-run\n```\n\n### 从头开始\n\n重新开始：\n\n```bash\nrm -rf hem_modules package-lock.json\nhpm install\n```\n\n## 获取帮助\n\n### 命令帮助\n\n```bash\nhpm --help\nhpm install --help\n```\n\n### 报告问题\n\n如果遇到 bug：\n\n1. 检查现有问题：https://github.com/hemlang/hpm/issues\n2. 创建新问题，包含：\n   - hpm 版本（`hpm --version`）\n   - Hemlock 版本（`hemlock --version`）\n   - 操作系统\n   - 重现步骤\n   - 错误消息（使用 `--verbose`）\n\n## 退出码参考\n\n| 代码 | 含义 | 常见解决方案 |\n|------|---------|-----------------|\n| 0 | 成功 | - |\n| 1 | 依赖冲突 | 更新或更改约束 |\n| 2 | 包未找到 | 检查拼写，验证仓库存在 |\n| 3 | 版本未找到 | 在 GitHub 上检查可用版本 |\n| 4 | 网络错误 | 检查连接，重试 |\n| 5 | 无效的 package.json | 修复 JSON 语法和必需字段 |\n| 6 | 完整性检查失败 | 清除缓存，重新安装 |\n| 7 | GitHub 速率限制 | 添加 GITHUB_TOKEN |\n| 8 | 循环依赖 | 联系包维护者 |\n\n## 另请参阅\n\n- [安装](#hpm-troubleshooting-installation) - 安装指南\n- [配置](#hpm-troubleshooting-configuration) - 配置选项\n- [命令](#hpm-troubleshooting-commands) - 命令参考\n"}, "hpm: 用户指南 -> 配置": {"id": "hpm-configuration", "content": "# 配置\n\n本指南涵盖 hpm 的所有配置选项。\n\n## 概述\n\nhpm 可以通过以下方式配置：\n\n1. **环境变量** - 用于运行时设置\n2. **全局配置文件** - `~/.hpm/config.json`\n3. **项目文件** - `package.json` 和 `package-lock.json`\n\n## 环境变量\n\n### GITHUB_TOKEN\n\n用于认证的 GitHub API token。\n\n```bash\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n```\n\n**认证的好处：**\n- 更高的 API 速率限制（5000 vs 60 请求/小时）\n- 访问私有仓库\n- 更快的依赖解析\n\n**创建 token：**\n\n1. 前往 GitHub → Settings → Developer settings → Personal access tokens\n2. 点击 \"Generate new token (classic)\"\n3. 选择权限范围：\n   - `repo` - 用于私有仓库访问\n   - `read:packages` - 用于 GitHub Packages（如果使用）\n4. 生成并复制 token\n\n### HPM_CACHE_DIR\n\n覆盖默认缓存目录。\n\n```bash\nexport HPM_CACHE_DIR=/custom/cache/path\n```\n\n默认值：`~/.hpm/cache`\n\n**使用场景：**\n- 具有自定义缓存位置的 CI/CD 系统\n- 跨项目共享缓存\n- 隔离构建的临时缓存\n\n### HOME\n\n用户主目录。用于定位：\n- 配置目录：`$HOME/.hpm/`\n- 缓存目录：`$HOME/.hpm/cache/`\n\n通常由系统设置；仅在需要时覆盖。\n\n### .bashrc / .zshrc 示例\n\n```bash\n# GitHub authentication (recommended)\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx\n\n# Custom cache location (optional)\n# export HPM_CACHE_DIR=/path/to/cache\n\n# Add hpm to PATH (if using custom install location)\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n## 全局配置文件\n\n### 位置\n\n`~/.hpm/config.json`\n\n### 格式\n\n```json\n{\n  \"github_token\": \"ghp_xxxxxxxxxxxxxxxxxxxx\"\n}\n```\n\n### 创建配置文件\n\n```bash\n# Create config directory\nmkdir -p ~/.hpm\n\n# Create config file\ncat > ~/.hpm/config.json << 'EOF'\n{\n  \"github_token\": \"ghp_your_token_here\"\n}\nEOF\n\n# Secure the file (recommended)\nchmod 600 ~/.hpm/config.json\n```\n\n### Token 优先级\n\n如果两者都设置，环境变量优先：\n\n1. `GITHUB_TOKEN` 环境变量（最高）\n2. `~/.hpm/config.json` 的 `github_token` 字段\n3. 无认证（默认）\n\n## 目录结构\n\n### 全局目录\n\n```\n~/.hpm/\n├── config.json          # 全局配置\n└── cache/               # 包缓存\n    └── owner/\n        └── repo/\n            └── 1.0.0.tar.gz\n```\n\n### 项目目录\n\n```\nmy-project/\n├── package.json         # 项目清单\n├── package-lock.json    # 依赖锁定文件\n├── hem_modules/         # 已安装的包\n│   └── owner/\n│       └── repo/\n│           ├── package.json\n│           └── src/\n├── src/                 # 源代码\n└── test/                # 测试\n```\n\n## 包缓存\n\n### 位置\n\n默认：`~/.hpm/cache/`\n\n使用 `HPM_CACHE_DIR` 环境变量覆盖\n\n### 结构\n\n```\n~/.hpm/cache/\n├── hemlang/\n│   ├── sprout/\n│   │   ├── 2.0.0.tar.gz\n│   │   └── 2.1.0.tar.gz\n│   └── router/\n│       └── 1.5.0.tar.gz\n└── alice/\n    └── http-client/\n        └── 1.0.0.tar.gz\n```\n\n### 管理缓存\n\n```bash\n# 查看缓存的包\nhpm cache list\n\n# 清除整个缓存\nhpm cache clean\n```\n\n### 缓存行为\n\n- 包在首次下载后被缓存\n- 后续安装使用缓存版本\n- 使用 `--offline` 仅从缓存安装\n- 缓存在所有项目间共享\n\n## GitHub API 速率限制\n\n### 无认证\n\n- **每小时 60 个请求**，按 IP 地址计算\n- 在同一 IP 上的所有未认证用户间共享\n- 在 CI/CD 或有多个依赖时会很快耗尽\n\n### 有认证\n\n- **每小时 5000 个请求**，按认证用户计算\n- 个人速率限制，不共享\n\n### 处理速率限制\n\nhpm 自动：\n- 使用指数退避重试（1秒、2秒、4秒、8秒）\n- 以退出码 7 报告速率限制错误\n- 如果被速率限制则建议认证\n\n**速率限制时的解决方案：**\n\n```bash\n# 选项 1：使用 GitHub token 认证\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install\n\n# 选项 2：等待速率限制重置\n# （限制每小时重置）\n\n# 选项 3：使用离线模式（如果包已缓存）\nhpm install --offline\n```\n\n## 离线模式\n\n无网络访问时安装包：\n\n```bash\nhpm install --offline\n```\n\n**要求：**\n- 所有包必须在缓存中\n- 锁定文件必须存在且有精确版本\n\n**使用场景：**\n- 隔离网络的环境\n- 更快的 CI/CD 构建（有热缓存）\n- 避免速率限制\n\n## CI/CD 配置\n\n### GitHub Actions\n\n```yaml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n\n    - name: Setup Hemlock\n      run: |\n        # Install Hemlock (adjust based on your setup)\n        curl -sSL https://hemlock.dev/install.sh | sh\n\n    - name: Cache hpm packages\n      uses: actions/cache@v3\n      with:\n        path: ~/.hpm/cache\n        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}\n        restore-keys: |\n          ${{ runner.os }}-hpm-\n\n    - name: Install dependencies\n      run: hpm install\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Run tests\n      run: hpm test\n```\n\n### GitLab CI\n\n```yaml\nstages:\n  - build\n  - test\n\nvariables:\n  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache\n\ncache:\n  paths:\n    - .hpm-cache/\n  key: $CI_COMMIT_REF_SLUG\n\nbuild:\n  stage: build\n  script:\n    - hpm install\n  artifacts:\n    paths:\n      - hem_modules/\n\ntest:\n  stage: test\n  script:\n    - hpm test\n```\n\n### Docker\n\n**Dockerfile:**\n\n```dockerfile\nFROM hemlock:latest\n\nWORKDIR /app\n\n# Copy package files first (for layer caching)\nCOPY package.json package-lock.json ./\n\n# Install dependencies\nRUN hpm install\n\n# Copy source code\nCOPY . .\n\n# Run application\nCMD [\"hemlock\", \"src/main.hml\"]\n```\n\n**docker-compose.yml:**\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    environment:\n      - GITHUB_TOKEN=${GITHUB_TOKEN}\n    volumes:\n      - hpm-cache:/root/.hpm/cache\n\nvolumes:\n  hpm-cache:\n```\n\n## 代理配置\n\n对于代理后面的环境，在系统级别配置：\n\n```bash\nexport HTTP_PROXY=http://proxy.example.com:8080\nexport HTTPS_PROXY=http://proxy.example.com:8080\nexport NO_PROXY=localhost,127.0.0.1\n\nhpm install\n```\n\n## 安全最佳实践\n\n### Token 安全\n\n1. **永远不要提交 token** 到版本控制\n2. **在 CI/CD 中使用环境变量**\n3. **将 token 权限范围限制**到最小需要\n4. **定期轮换 token**\n5. **保护配置文件**：\n   ```bash\n   chmod 600 ~/.hpm/config.json\n   ```\n\n### 私有仓库\n\n要访问私有包：\n\n1. 创建具有 `repo` 权限范围的 token\n2. 配置认证（环境变量或配置文件）\n3. 确保 token 有仓库访问权限\n\n```bash\n# 测试访问\nexport GITHUB_TOKEN=ghp_xxxxxxxxxxxx\nhpm install yourorg/private-package\n```\n\n## 配置故障排除\n\n### 验证配置\n\n```bash\n# 检查 token 是否设置\necho $GITHUB_TOKEN | head -c 10\n\n# 检查配置文件\ncat ~/.hpm/config.json\n\n# 检查缓存目录\nls -la ~/.hpm/cache/\n\n# 使用详细输出测试\nhpm install --verbose\n```\n\n### 常见问题\n\n**\"GitHub rate limit exceeded\"**\n- 使用 `GITHUB_TOKEN` 设置认证\n- 等待速率限制重置\n- 如果包已缓存，使用 `--offline`\n\n**缓存上的 \"Permission denied\"**\n```bash\n# 修复缓存权限\nchmod -R u+rw ~/.hpm/cache\n```\n\n**\"Config file not found\"**\n```bash\n# 创建配置目录\nmkdir -p ~/.hpm\ntouch ~/.hpm/config.json\n```\n\n## 另请参阅\n\n- [安装](#hpm-configuration-installation) - 安装 hpm\n- [故障排除](#hpm-configuration-troubleshooting) - 常见问题\n- [命令](#hpm-configuration-commands) - 命令参考\n"}, "hpm: 包开发 -> 创建包": {"id": "hpm-creating-packages", "content": "# 创建包\n\n本指南介绍如何创建、组织和发布 Hemlock 包。\n\n## 概述\n\nhpm 使用 GitHub 作为其包注册表。包通过其 GitHub `owner/repo` 路径标识，版本是 Git 标签。发布只需推送带标签的发布版本。\n\n## 创建新包\n\n### 1. 初始化包\n\n创建新目录并初始化：\n\n```bash\nmkdir my-package\ncd my-package\nhpm init\n```\n\n回答提示：\n\n```\nPackage name (owner/repo): yourusername/my-package\nVersion (1.0.0):\nDescription: A useful Hemlock package\nAuthor: Your Name <you@example.com>\nLicense (MIT):\nMain file (src/index.hml):\n\nCreated package.json\n```\n\n### 2. 创建项目结构\n\n包的推荐结构：\n\n```\nmy-package/\n├── package.json          # 包清单\n├── README.md             # 文档\n├── LICENSE               # 许可证文件\n├── src/\n│   ├── index.hml         # 主入口点（导出公共 API）\n│   ├── utils.hml         # 内部工具\n│   └── types.hml         # 类型定义\n└── test/\n    ├── framework.hml     # 测试框架\n    └── test_utils.hml    # 测试\n```\n\n### 3. 定义你的公共 API\n\n**src/index.hml** - 主入口点：\n\n```hemlock\n// Re-export public API\nexport { parse, stringify } from \"./parser.hml\";\nexport { Config, Options } from \"./types.hml\";\nexport { process } from \"./processor.hml\";\n\n// Direct exports\nexport fn create(options: Options): Config {\n    // Implementation\n}\n\nexport fn validate(config: Config): bool {\n    // Implementation\n}\n```\n\n### 4. 编写你的 package.json\n\n完整的 package.json 示例：\n\n```json\n{\n  \"name\": \"yourusername/my-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A useful Hemlock package\",\n  \"author\": \"Your Name <you@example.com>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/yourusername/my-package\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/index.hml -o dist/bundle.hmlc\"\n  },\n  \"keywords\": [\"utility\", \"parser\", \"config\"],\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n## 包命名\n\n### 要求\n\n- 必须是 `owner/repo` 格式\n- `owner` 应该是你的 GitHub 用户名或组织\n- `repo` 应该是仓库名称\n- 多词名称使用小写字母和连字符\n\n### 好的名称\n\n```\nhemlang/sprout\nalice/http-client\nmyorg/json-utils\nbob/date-formatter\n```\n\n### 避免\n\n```\nmy-package          # 缺少 owner\nalice/MyPackage     # PascalCase\nalice/my_package    # 下划线\n```\n\n## 包结构最佳实践\n\n### 入口点\n\npackage.json 中的 `main` 字段指定入口点：\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\n此文件应导出你的公共 API：\n\n```hemlock\n// Export everything users need\nexport { Parser, parse } from \"./parser.hml\";\nexport { Formatter, format } from \"./formatter.hml\";\n\n// Types\nexport type { Config, Options } from \"./types.hml\";\n```\n\n### 内部与公共\n\n保持内部实现细节私有：\n\n```\nsrc/\n├── index.hml          # 公共：导出的 API\n├── parser.hml         # 公共：被 index.hml 使用\n├── formatter.hml      # 公共：被 index.hml 使用\n└── internal/\n    ├── helpers.hml    # 私有：仅供内部使用\n    └── constants.hml  # 私有：仅供内部使用\n```\n\n用户从你的包根目录导入：\n\n```hemlock\n// Good - imports from public API\nimport { parse, Parser } from \"yourusername/my-package\";\n\n// Also works - subpath import\nimport { validate } from \"yourusername/my-package/validator\";\n\n// Discouraged - accessing internals\nimport { helper } from \"yourusername/my-package/internal/helpers\";\n```\n\n### 子路径导出\n\n支持从子路径导入：\n\n```\nsrc/\n├── index.hml              # 主入口\n├── parser/\n│   └── index.hml          # yourusername/pkg/parser\n├── formatter/\n│   └── index.hml          # yourusername/pkg/formatter\n└── utils/\n    └── index.hml          # yourusername/pkg/utils\n```\n\n用户可以导入：\n\n```hemlock\nimport { parse } from \"yourusername/my-package\";           // Main\nimport { Parser } from \"yourusername/my-package/parser\";   // Subpath\nimport { format } from \"yourusername/my-package/formatter\";\n```\n\n## 依赖\n\n### 添加依赖\n\n```bash\n# 运行时依赖\nhpm install hemlang/json\n\n# 开发依赖\nhpm install hemlang/test-utils --dev\n```\n\n### 依赖最佳实践\n\n1. **大多数依赖使用插入符范围**：\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     }\n   }\n   ```\n\n2. **仅在必要时锁定版本**（API 不稳定）：\n   ```json\n   {\n     \"dependencies\": {\n       \"unstable/lib\": \"1.2.3\"\n     }\n   }\n   ```\n\n3. **避免过于严格的范围**：\n   ```json\n   // Bad: too restrictive\n   \"hemlang/json\": \">=1.2.3 <1.2.5\"\n\n   // Good: allows compatible updates\n   \"hemlang/json\": \"^1.2.3\"\n   ```\n\n4. **分离开发依赖**：\n   ```json\n   {\n     \"dependencies\": {\n       \"hemlang/json\": \"^1.0.0\"\n     },\n     \"devDependencies\": {\n       \"hemlang/test-utils\": \"^1.0.0\"\n     }\n   }\n   ```\n\n## 测试你的包\n\n### 编写测试\n\n**test/run.hml:**\n\n```hemlock\nimport { suite, test, assert_eq } from \"./framework.hml\";\nimport { parse, stringify } from \"../src/index.hml\";\n\nfn run_tests() {\n    suite(\"Parser\", fn() {\n        test(\"parses valid input\", fn() {\n            let result = parse(\"hello\");\n            assert_eq(result.value, \"hello\");\n        });\n\n        test(\"handles empty input\", fn() {\n            let result = parse(\"\");\n            assert_eq(result.value, \"\");\n        });\n    });\n\n    suite(\"Stringify\", fn() {\n        test(\"stringifies object\", fn() {\n            let obj = { name: \"test\" };\n            let result = stringify(obj);\n            assert_eq(result, '{\"name\":\"test\"}');\n        });\n    });\n}\n\nrun_tests();\n```\n\n### 运行测试\n\n添加测试脚本：\n\n```json\n{\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\n运行：\n\n```bash\nhpm test\n```\n\n## 发布\n\n### 前提条件\n\n1. 创建与你的包名称匹配的 GitHub 仓库\n2. 确保 `package.json` 完整有效\n3. 所有测试通过\n\n### 发布流程\n\n发布只需推送 Git 标签：\n\n```bash\n# 1. 确保所有内容已提交\ngit add .\ngit commit -m \"Prepare v1.0.0 release\"\n\n# 2. 创建版本标签（必须以 'v' 开头）\ngit tag v1.0.0\n\n# 3. 推送代码和标签\ngit push origin main\ngit push origin v1.0.0\n# 或一次推送所有标签\ngit push origin main --tags\n```\n\n### 版本标签\n\n标签必须遵循 `vX.Y.Z` 格式：\n\n```bash\ngit tag v1.0.0      # 发布版\ngit tag v1.0.1      # 补丁\ngit tag v1.1.0      # 次要版本\ngit tag v2.0.0      # 主要版本\ngit tag v1.0.0-beta.1  # 预发布\n```\n\n### 发布清单\n\n发布新版本之前：\n\n1. **更新** package.json 中的版本\n2. **运行测试**：`hpm test`\n3. **更新 CHANGELOG**（如果有的话）\n4. **更新 README**（如果 API 改变了）\n5. **提交更改**\n6. **创建标签**\n7. **推送到 GitHub**\n\n### 自动化示例\n\n创建发布脚本：\n\n```bash\n#!/bin/bash\n# release.sh - Release a new version\n\nVERSION=$1\n\nif [ -z \"$VERSION\" ]; then\n    echo \"Usage: ./release.sh 1.0.0\"\n    exit 1\nfi\n\n# Run tests\nhpm test || exit 1\n\n# Update version in package.json\nsed -i \"s/\\\"version\\\": \\\".*\\\"/\\\"version\\\": \\\"$VERSION\\\"/\" package.json\n\n# Commit and tag\ngit add package.json\ngit commit -m \"Release v$VERSION\"\ngit tag \"v$VERSION\"\n\n# Push\ngit push origin main --tags\n\necho \"Released v$VERSION\"\n```\n\n## 用户安装你的包\n\n发布后，用户可以安装：\n\n```bash\n# 最新版本\nhpm install yourusername/my-package\n\n# 特定版本\nhpm install yourusername/my-package@1.0.0\n\n# 版本约束\nhpm install yourusername/my-package@^1.0.0\n```\n\n并导入：\n\n```hemlock\nimport { parse, stringify } from \"yourusername/my-package\";\n```\n\n## 文档\n\n### README.md\n\n每个包都应该有 README：\n\n```markdown\n# my-package\n\nA brief description of what this package does.\n\n## Installation\n\n\\`\\`\\`bash\nhpm install yourusername/my-package\n\\`\\`\\`\n\n## Usage\n\n\\`\\`\\`hemlock\nimport { parse } from \"yourusername/my-package\";\n\nlet result = parse(\"input\");\n\\`\\`\\`\n\n## API\n\n### parse(input: string): Result\n\nParses the input string.\n\n### stringify(obj: any): string\n\nConverts object to string.\n\n## License\n\nMIT\n```\n\n### API 文档\n\n记录所有公共导出：\n\n```hemlock\n/// Parses the input string into a structured Result.\n///\n/// # Arguments\n/// * `input` - The string to parse\n///\n/// # Returns\n/// A Result containing the parsed data or an error\n///\n/// # Example\n/// ```\n/// let result = parse(\"hello world\");\n/// print(result.value);\n/// ```\nexport fn parse(input: string): Result {\n    // Implementation\n}\n```\n\n## 版本指南\n\n遵循[语义化版本](https://semver.org/)：\n\n- **MAJOR**（1.0.0 → 2.0.0）：破坏性更改\n- **MINOR**（1.0.0 → 1.1.0）：新功能，向后兼容\n- **PATCH**（1.0.0 → 1.0.1）：错误修复，向后兼容\n\n### 何时递增\n\n| 更改类型 | 版本递增 |\n|-------------|--------------|\n| 破坏性 API 更改 | MAJOR |\n| 移除函数/类型 | MAJOR |\n| 更改函数签名 | MAJOR |\n| 添加新函数 | MINOR |\n| 添加新功能 | MINOR |\n| 错误修复 | PATCH |\n| 文档更新 | PATCH |\n| 内部重构 | PATCH |\n\n## 另请参阅\n\n- [包规范](#hpm-creating-packages-package-spec) - 完整的 package.json 参考\n- [版本控制](#hpm-creating-packages-versioning) - 语义化版本详情\n- [配置](#hpm-creating-packages-configuration) - GitHub 认证\n"}, "hpm: 包开发 -> 包规范": {"id": "hpm-package-spec", "content": "# 包规范\n\n`package.json` 文件格式的完整参考。\n\n## 概述\n\n每个 hpm 包都需要在项目根目录中有一个 `package.json` 文件。此文件定义包元数据、依赖项和脚本。\n\n## 最小示例\n\n```json\n{\n  \"name\": \"owner/repo\",\n  \"version\": \"1.0.0\"\n}\n```\n\n## 完整示例\n\n```json\n{\n  \"name\": \"hemlang/example-package\",\n  \"version\": \"1.2.3\",\n  \"description\": \"An example Hemlock package\",\n  \"author\": \"Hemlock Team <team@hemlock.dev>\",\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/hemlang/example-package\",\n  \"homepage\": \"https://hemlang.github.io/example-package\",\n  \"bugs\": \"https://github.com/hemlang/example-package/issues\",\n  \"main\": \"src/index.hml\",\n  \"keywords\": [\"example\", \"utility\", \"hemlock\"],\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"^2.1.0\"\n  },\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/bundle.hmlc\"\n  },\n  \"files\": [\n    \"src/\",\n    \"LICENSE\",\n    \"README.md\"\n  ],\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\"]\n  }\n}\n```\n\n## 字段参考\n\n### name（必需）\n\n`owner/repo` 格式的包名称。\n\n```json\n{\n  \"name\": \"hemlang/sprout\"\n}\n```\n\n**要求：**\n- 必须是 `owner/repo` 格式\n- `owner` 应该是你的 GitHub 用户名或组织\n- `repo` 应该是仓库名称\n- 使用小写字母、数字和连字符\n- 总共最多 214 个字符\n\n**有效名称：**\n```\nhemlang/sprout\nalice/http-client\nmyorg/json-utils\nbob123/my-lib\n```\n\n**无效名称：**\n```\nmy-package          # 缺少 owner\nhemlang/My_Package  # 大写和下划线\nhemlang             # 缺少 repo\n```\n\n### version（必需）\n\n遵循[语义化版本](https://semver.org/)的包版本。\n\n```json\n{\n  \"version\": \"1.2.3\"\n}\n```\n\n**格式：** `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`\n\n**有效版本：**\n```\n1.0.0\n2.1.3\n1.0.0-alpha\n1.0.0-beta.1\n1.0.0-rc.1+build.123\n0.1.0\n```\n\n### description\n\n包的简短描述。\n\n```json\n{\n  \"description\": \"A fast JSON parser for Hemlock\"\n}\n```\n\n- 保持在 200 个字符以内\n- 描述包做什么，而不是怎么做\n\n### author\n\n包作者信息。\n\n```json\n{\n  \"author\": \"Your Name <email@example.com>\"\n}\n```\n\n**接受的格式：**\n```json\n\"author\": \"Your Name\"\n\"author\": \"Your Name <email@example.com>\"\n\"author\": \"Your Name <email@example.com> (https://website.com)\"\n```\n\n### license\n\n许可证标识符。\n\n```json\n{\n  \"license\": \"MIT\"\n}\n```\n\n**常见许可证：**\n- `MIT` - MIT 许可证\n- `Apache-2.0` - Apache 许可证 2.0\n- `GPL-3.0` - GNU 通用公共许可证 v3.0\n- `BSD-3-Clause` - BSD 3-Clause 许可证\n- `ISC` - ISC 许可证\n- `UNLICENSED` - 专有/私有\n\n尽可能使用 [SPDX 标识符](https://spdx.org/licenses/)。\n\n### repository\n\n源仓库链接。\n\n```json\n{\n  \"repository\": \"https://github.com/hemlang/sprout\"\n}\n```\n\n### homepage\n\n项目主页 URL。\n\n```json\n{\n  \"homepage\": \"https://sprout.hemlock.dev\"\n}\n```\n\n### bugs\n\n问题跟踪器 URL。\n\n```json\n{\n  \"bugs\": \"https://github.com/hemlang/sprout/issues\"\n}\n```\n\n### main\n\n包的入口点文件。\n\n```json\n{\n  \"main\": \"src/index.hml\"\n}\n```\n\n**默认值：** `src/index.hml`\n\n当用户导入你的包时：\n```hemlock\nimport { x } from \"owner/repo\";\n```\n\nhpm 加载 `main` 中指定的文件。\n\n**导入的解析顺序：**\n1. 精确路径：`src/index.hml`\n2. 带 .hml 扩展名：`src/index` → `src/index.hml`\n3. 索引文件：`src/index/` → `src/index/index.hml`\n\n### keywords\n\n用于可发现性的关键词数组。\n\n```json\n{\n  \"keywords\": [\"json\", \"parser\", \"utility\", \"hemlock\"]\n}\n```\n\n- 使用小写\n- 具体且相关\n- 如果适当，包含语言（\"hemlock\"）\n\n### dependencies\n\n包工作所需的运行时依赖。\n\n```json\n{\n  \"dependencies\": {\n    \"hemlang/json\": \"^1.0.0\",\n    \"hemlang/http\": \"~2.1.0\",\n    \"alice/logger\": \">=1.0.0 <2.0.0\"\n  }\n}\n```\n\n**键：** 包名称（`owner/repo`）\n**值：** 版本约束\n\n**版本约束语法：**\n\n| 约束 | 含义 |\n|------------|---------|\n| `1.2.3` | 精确版本 |\n| `^1.2.3` | >=1.2.3 <2.0.0 |\n| `~1.2.3` | >=1.2.3 <1.3.0 |\n| `>=1.0.0` | 至少 1.0.0 |\n| `>=1.0.0 <2.0.0` | 范围 |\n| `*` | 任意版本 |\n\n### devDependencies\n\n仅用于开发的依赖（测试、构建等）。\n\n```json\n{\n  \"devDependencies\": {\n    \"hemlang/test-utils\": \"^1.0.0\",\n    \"hemlang/linter\": \"^2.0.0\"\n  }\n}\n```\n\n开发依赖是：\n- 在开发期间安装\n- 当包作为依赖使用时不安装\n- 用于测试、构建、检查等\n\n### scripts\n\n可以使用 `hpm run` 运行的命名命令。\n\n```json\n{\n  \"scripts\": {\n    \"start\": \"hemlock src/main.hml\",\n    \"dev\": \"hemlock --watch src/main.hml\",\n    \"test\": \"hemlock test/run.hml\",\n    \"test:unit\": \"hemlock test/unit/run.hml\",\n    \"test:integration\": \"hemlock test/integration/run.hml\",\n    \"build\": \"hemlock --bundle src/main.hml -o dist/app.hmlc\",\n    \"clean\": \"rm -rf dist hem_modules\",\n    \"lint\": \"hemlock-lint src/\",\n    \"format\": \"hemlock-fmt src/\"\n  }\n}\n```\n\n**运行脚本：**\n```bash\nhpm run start\nhpm run build\nhpm test        # 'hpm run test' 的简写\n```\n\n**传递参数：**\n```bash\nhpm run test -- --verbose --filter=unit\n```\n\n**常见脚本：**\n\n| 脚本 | 用途 |\n|--------|---------|\n| `start` | 启动应用程序 |\n| `dev` | 带热重载的开发模式 |\n| `test` | 运行测试 |\n| `build` | 为生产环境构建 |\n| `clean` | 移除构建产物 |\n| `lint` | 检查代码风格 |\n| `format` | 格式化代码 |\n\n### files\n\n安装包时要包含的文件和目录。\n\n```json\n{\n  \"files\": [\n    \"src/\",\n    \"lib/\",\n    \"LICENSE\",\n    \"README.md\"\n  ]\n}\n```\n\n**默认行为：** 如果未指定，包含：\n- 仓库中的所有文件\n- 排除 `.git/`、`node_modules/`、`hem_modules/`\n\n**用于：**\n- 减少包大小\n- 从分发中排除测试文件\n- 仅包含必要文件\n\n### native\n\n原生库要求。\n\n```json\n{\n  \"native\": {\n    \"requires\": [\"libcurl\", \"openssl\", \"sqlite3\"]\n  }\n}\n```\n\n记录必须在系统上安装的原生依赖。\n\n## 验证\n\nhpm 在各种操作中验证 package.json。常见验证错误：\n\n### 缺少必需字段\n\n```\nError: package.json missing required field: name\n```\n\n**修复：** 添加必需字段。\n\n### 无效的名称格式\n\n```\nError: Invalid package name. Must be in owner/repo format.\n```\n\n**修复：** 使用 `owner/repo` 格式。\n\n### 无效的版本\n\n```\nError: Invalid version \"1.0\". Must be semver format (X.Y.Z).\n```\n\n**修复：** 使用完整的 semver 格式（`1.0.0`）。\n\n### 无效的 JSON\n\n```\nError: package.json is not valid JSON\n```\n\n**修复：** 检查 JSON 语法（逗号、引号、括号）。\n\n## 创建 package.json\n\n### 交互式\n\n```bash\nhpm init\n```\n\n交互式提示每个字段。\n\n### 使用默认值\n\n```bash\nhpm init --yes\n```\n\n使用默认值创建：\n```json\n{\n  \"name\": \"directory-name/directory-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\n```\n\n### 手动\n\n手动创建文件：\n\n```bash\ncat > package.json << 'EOF'\n{\n  \"name\": \"yourname/your-package\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Your package description\",\n  \"main\": \"src/index.hml\",\n  \"dependencies\": {},\n  \"scripts\": {\n    \"test\": \"hemlock test/run.hml\"\n  }\n}\nEOF\n```\n\n## 最佳实践\n\n1. **始终指定 main** - 不要依赖默认值\n2. **使用插入符范围** - 大多数依赖使用 `^1.0.0`\n3. **分离开发依赖** - 将测试/构建依赖放在 devDependencies 中\n4. **包含关键词** - 帮助用户找到你的包\n5. **记录脚本** - 清晰命名脚本\n6. **指定许可证** - 开源项目必需\n7. **添加描述** - 帮助用户理解用途\n\n## 另请参阅\n\n- [创建包](#hpm-package-spec-creating-packages) - 发布指南\n- [版本控制](#hpm-package-spec-versioning) - 版本约束\n- [项目设置](#hpm-package-spec-project-setup) - 项目结构\n"}, "hpm: 包开发 -> 版本控制": {"id": "hpm-versioning", "content": "# 版本控制\n\nhpm 中语义化版本控制的完整指南。\n\n## 语义化版本\n\nhpm 使用[语义化版本 2.0.0](https://semver.org/)（semver）进行包版本管理。\n\n### 版本格式\n\n```\nMAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]\n```\n\n**示例：**\n```\n1.0.0           # 发布版本\n2.1.3           # 发布版本\n1.0.0-alpha     # 预发布\n1.0.0-beta.1    # 带编号的预发布\n1.0.0-rc.1      # 候选发布\n1.0.0+20231201  # 带构建元数据\n1.0.0-beta+exp  # 预发布带构建元数据\n```\n\n### 版本组成部分\n\n| 组成部分 | 描述 | 示例 |\n|-----------|-------------|---------|\n| MAJOR | 破坏性更改 | `1.0.0` → `2.0.0` |\n| MINOR | 新功能（向后兼容） | `1.0.0` → `1.1.0` |\n| PATCH | 错误修复（向后兼容） | `1.0.0` → `1.0.1` |\n| PRERELEASE | 预发布标识符 | `1.0.0-alpha` |\n| BUILD | 构建元数据（比较时忽略） | `1.0.0+build123` |\n\n### 何时递增\n\n| 更改类型 | 递增 | 示例 |\n|-------------|-----------|---------|\n| 破坏性 API 更改 | MAJOR | 移除函数 |\n| 重命名公共函数 | MAJOR | `parse()` → `decode()` |\n| 更改函数签名 | MAJOR | 添加必需参数 |\n| 添加新函数 | MINOR | 添加 `validate()` |\n| 添加可选参数 | MINOR | 新的可选 `options` 参数 |\n| 错误修复 | PATCH | 修复空指针 |\n| 性能改进 | PATCH | 更快的算法 |\n| 内部重构 | PATCH | 无 API 更改 |\n\n## 版本约束\n\n### 约束语法\n\n| 语法 | 含义 | 解析为 |\n|--------|---------|-------------|\n| `1.2.3` | 精确版本 | 仅 1.2.3 |\n| `^1.2.3` | 插入符（兼容） | ≥1.2.3 且 <2.0.0 |\n| `~1.2.3` | 波浪号（补丁更新） | ≥1.2.3 且 <1.3.0 |\n| `>=1.0.0` | 至少 | 1.0.0 或更高 |\n| `>1.0.0` | 大于 | 高于 1.0.0 |\n| `<2.0.0` | 小于 | 低于 2.0.0 |\n| `<=2.0.0` | 最多 | 2.0.0 或更低 |\n| `>=1.0.0 <2.0.0` | 范围 | 在 1.0.0 和 2.0.0 之间 |\n| `*` | 任意 | 任意版本 |\n\n### 插入符范围 (^)\n\n插入符（`^`）允许不修改最左边非零数字的更改：\n\n```\n^1.2.3  →  >=1.2.3 <2.0.0   # 允许 1.x.x\n^0.2.3  →  >=0.2.3 <0.3.0   # 允许 0.2.x\n^0.0.3  →  >=0.0.3 <0.0.4   # 仅允许 0.0.3\n```\n\n**使用场景：** 你希望在主版本内获得兼容更新。\n\n**最常见的约束** - 推荐用于大多数依赖。\n\n### 波浪号范围 (~)\n\n波浪号（`~`）仅允许补丁级别的更改：\n\n```\n~1.2.3  →  >=1.2.3 <1.3.0   # 允许 1.2.x\n~1.2    →  >=1.2.0 <1.3.0   # 允许 1.2.x\n~1      →  >=1.0.0 <2.0.0   # 允许 1.x.x\n```\n\n**使用场景：** 你只希望获得错误修复，不要新功能。\n\n### 比较范围\n\n组合比较运算符进行精确控制：\n\n```json\n{\n  \"dependencies\": {\n    \"owner/pkg\": \">=1.0.0 <2.0.0\",\n    \"owner/other\": \">1.5.0 <=2.1.0\"\n  }\n}\n```\n\n### 任意版本 (*)\n\n匹配任意版本：\n\n```json\n{\n  \"dependencies\": {\n    \"owner/pkg\": \"*\"\n  }\n}\n```\n\n**警告：** 不推荐用于生产环境。将始终获取最新版本。\n\n## 预发布版本\n\n### 预发布标识符\n\n预发布版本的优先级低于正式发布版本：\n\n```\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0\n```\n\n### 常见预发布标签\n\n| 标签 | 含义 | 阶段 |\n|-----|---------|-------|\n| `alpha` | 早期开发 | 非常不稳定 |\n| `beta` | 功能完整 | 测试中 |\n| `rc` | 候选发布 | 最终测试 |\n| `dev` | 开发快照 | 不稳定 |\n\n### 约束中的预发布\n\n约束默认不匹配预发布版本：\n\n```\n^1.0.0    # 不匹配 1.1.0-beta\n>=1.0.0   # 不匹配 2.0.0-alpha\n```\n\n要包含预发布版本，请明确引用它们：\n\n```\n>=1.0.0-alpha <2.0.0   # 包含所有 1.x 预发布版本\n```\n\n## 版本比较\n\n### 比较规则\n\n1. 按数值比较 MAJOR、MINOR、PATCH\n2. 发布版本 > 相同版本号的预发布版本\n3. 预发布版本按字母数字顺序比较\n4. 构建元数据被忽略\n\n### 示例\n\n```\n1.0.0 < 1.0.1 < 1.1.0 < 2.0.0\n\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0\n\n1.0.0 = 1.0.0+build123  # 构建元数据被忽略\n```\n\n### 排序\n\n版本按升序排序：\n\n```\n1.0.0\n1.0.1\n1.1.0\n1.1.1\n2.0.0-alpha\n2.0.0-beta\n2.0.0\n```\n\n## 版本解析\n\n### 解析算法\n\n当多个包需要同一个依赖时：\n\n1. 收集所有约束\n2. 找到所有范围的交集\n3. 选择交集中的最高版本\n4. 如果没有版本满足所有约束则报错\n\n### 解析示例\n\n```\npackage-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npackage-b requires hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)\n\nIntersection: >=1.2.0 <1.3.0\nAvailable: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]\nResolved: 1.2.5 (highest in intersection)\n```\n\n### 冲突检测\n\n当没有版本满足所有约束时发生冲突：\n\n```\npackage-a requires hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)\npackage-b requires hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)\n\nIntersection: (empty)\nResult: CONFLICT - no version satisfies both\n```\n\n## 最佳实践\n\n### 对于包使用者\n\n1. **大多数依赖使用插入符范围**：\n   ```json\n   \"hemlang/json\": \"^1.2.0\"\n   ```\n\n2. **关键依赖使用波浪号范围**：\n   ```json\n   \"critical/lib\": \"~1.2.0\"\n   ```\n\n3. **仅在必要时锁定版本**：\n   ```json\n   \"unstable/pkg\": \"1.2.3\"\n   ```\n\n4. **提交锁定文件**以实现可重现的构建\n\n5. **定期更新**以获取安全修复：\n   ```bash\n   hpm update\n   hpm outdated\n   ```\n\n### 对于包作者\n\n1. **初始开发从 0.1.0 开始**：\n   - API 可能频繁更改\n   - 用户预期不稳定\n\n2. **API 稳定后升级到 1.0.0**：\n   - 对稳定性的公开承诺\n   - 破坏性更改需要递增主版本\n\n3. **严格遵循 semver**：\n   - 破坏性更改 = MAJOR\n   - 新功能 = MINOR\n   - 错误修复 = PATCH\n\n4. **使用预发布版本进行测试**：\n   ```bash\n   git tag v2.0.0-beta.1\n   git push --tags\n   ```\n\n5. **在 CHANGELOG 中记录破坏性更改**\n\n## 发布版本\n\n### 创建发布\n\n```bash\n# Update version in package.json\n# Edit package.json: \"version\": \"1.1.0\"\n\n# Commit version change\ngit add package.json\ngit commit -m \"Bump version to 1.1.0\"\n\n# Create and push tag\ngit tag v1.1.0\ngit push origin main --tags\n```\n\n### 标签格式\n\n标签**必须**以 `v` 开头：\n\n```\nv1.0.0      ✓ 正确\nv1.0.0-beta ✓ 正确\n1.0.0       ✗ 不会被识别\n```\n\n### 发布工作流\n\n```bash\n# 1. Ensure tests pass\nhpm test\n\n# 2. Update version in package.json\n# 3. Update CHANGELOG.md\n# 4. Commit changes\ngit add -A\ngit commit -m \"Release v1.2.0\"\n\n# 5. Create tag\ngit tag v1.2.0\n\n# 6. Push everything\ngit push origin main --tags\n```\n\n## 检查版本\n\n### 列出已安装版本\n\n```bash\nhpm list\n```\n\n### 检查更新\n\n```bash\nhpm outdated\n```\n\n输出：\n```\nPackage         Current  Wanted  Latest\nhemlang/json    1.0.0    1.0.5   1.2.0\nhemlang/sprout  2.0.0    2.0.3   2.1.0\n```\n\n- **Current**：已安装版本\n- **Wanted**：符合约束的最高版本\n- **Latest**：最新可用版本\n\n### 更新包\n\n```bash\n# 更新所有\nhpm update\n\n# 更新特定包\nhpm update hemlang/json\n```\n\n## 另请参阅\n\n- [创建包](#hpm-versioning-creating-packages) - 发布指南\n- [包规范](#hpm-versioning-package-spec) - package.json 格式\n- [命令](#hpm-versioning-commands) - CLI 参考\n"}, "hpm: 参考 -> 架构": {"id": "hpm-architecture", "content": "# 架构\n\nhpm 的内部架构和设计。本文档面向贡献者和有兴趣了解 hpm 工作原理的人。\n\n## 概述\n\nhpm 使用 Hemlock 编写，由多个模块组成，处理包管理的不同方面：\n\n```\nsrc/\n├── main.hml        # CLI 入口点和命令路由\n├── manifest.hml    # package.json 处理\n├── lockfile.hml    # package-lock.json 处理\n├── semver.hml      # 语义化版本\n├── resolver.hml    # 依赖解析\n├── github.hml      # GitHub API 客户端\n├── installer.hml   # 包下载和提取\n└── cache.hml       # 全局缓存管理\n```\n\n## 模块职责\n\n### main.hml\n\nCLI 应用程序的入口点。\n\n**职责：**\n- 解析命令行参数\n- 将命令路由到适当的处理器\n- 显示帮助和版本信息\n- 处理全局标志（--verbose、--dry-run 等）\n- 以适当的代码退出\n\n**关键函数：**\n- `main()` - 入口点，解析参数并分派命令\n- `cmd_init()` - 处理 `hpm init`\n- `cmd_install()` - 处理 `hpm install`\n- `cmd_uninstall()` - 处理 `hpm uninstall`\n- `cmd_update()` - 处理 `hpm update`\n- `cmd_list()` - 处理 `hpm list`\n- `cmd_outdated()` - 处理 `hpm outdated`\n- `cmd_run()` - 处理 `hpm run`\n- `cmd_why()` - 处理 `hpm why`\n- `cmd_cache()` - 处理 `hpm cache`\n\n**命令快捷方式：**\n```hemlock\nlet shortcuts = {\n    \"i\": \"install\",\n    \"rm\": \"uninstall\",\n    \"remove\": \"uninstall\",\n    \"ls\": \"list\",\n    \"up\": \"update\"\n};\n```\n\n### manifest.hml\n\n处理 `package.json` 文件的读写。\n\n**职责：**\n- 读写 package.json\n- 验证包结构\n- 管理依赖\n- 解析包说明符（owner/repo@version）\n\n**关键函数：**\n```hemlock\ncreate_default(): Manifest           // 创建空清单\nread_manifest(): Manifest            // 从文件读取\nwrite_manifest(m: Manifest)          // 写入文件\nvalidate(m: Manifest): bool          // 验证结构\nget_all_dependencies(m): Map         // 获取 deps + devDeps\nadd_dependency(m, pkg, ver, dev)     // 添加依赖\nremove_dependency(m, pkg)            // 移除依赖\nparse_specifier(spec): (name, ver)   // 解析 \"owner/repo@^1.0.0\"\nsplit_name(name): (owner, repo)      // 解析 \"owner/repo\"\n```\n\n**Manifest 结构：**\n```hemlock\ntype Manifest = {\n    name: string,\n    version: string,\n    description: string?,\n    author: string?,\n    license: string?,\n    repository: string?,\n    main: string?,\n    dependencies: Map<string, string>,\n    devDependencies: Map<string, string>,\n    scripts: Map<string, string>\n};\n```\n\n### lockfile.hml\n\n管理 `package-lock.json` 文件以实现可重现的安装。\n\n**职责：**\n- 创建/读取/写入锁定文件\n- 跟踪精确解析的版本\n- 存储下载 URL 和完整性哈希\n- 清理孤立的依赖\n\n**关键函数：**\n```hemlock\ncreate_empty(): Lockfile              // 创建空锁定文件\nread_lockfile(): Lockfile             // 从文件读取\nwrite_lockfile(l: Lockfile)           // 写入文件\ncreate_entry(ver, url, hash, deps)    // 创建锁定条目\nget_locked(l, pkg): LockEntry?        // 获取锁定版本\nset_locked(l, pkg, entry)             // 设置锁定版本\nremove_locked(l, pkg)                 // 移除条目\nprune(l, keep: Set)                   // 移除孤立项\nneeds_update(l, m): bool              // 检查是否不同步\n```\n\n**Lockfile 结构：**\n```hemlock\ntype Lockfile = {\n    lockVersion: int,\n    hemlock: string,\n    dependencies: Map<string, LockEntry>\n};\n\ntype LockEntry = {\n    version: string,\n    resolved: string,     // 下载 URL\n    integrity: string,    // SHA256 哈希\n    dependencies: Map<string, string>\n};\n```\n\n### semver.hml\n\n语义化版本 2.0.0 的完整实现。\n\n**职责：**\n- 解析版本字符串\n- 比较版本\n- 解析和评估版本约束\n- 查找满足约束的版本\n\n**关键函数：**\n```hemlock\n// 解析\nparse(s: string): Version             // \"1.2.3-beta+build\" → Version\nstringify(v: Version): string         // Version → \"1.2.3-beta+build\"\n\n// 比较\ncompare(a, b: Version): int           // -1、0 或 1\ngt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool\n\n// 约束\nparse_constraint(s: string): Constraint    // \"^1.2.3\" → Constraint\nsatisfies(v: Version, c: Constraint): bool // 检查 v 是否匹配 c\nmax_satisfying(versions, c): Version?      // 查找最高匹配\nsort(versions): [Version]                  // 升序排序\n\n// 工具\nconstraints_overlap(a, b: Constraint): bool  // 检查兼容性\n```\n\n**Version 结构：**\n```hemlock\ntype Version = {\n    major: int,\n    minor: int,\n    patch: int,\n    prerelease: [string]?,  // 例如 [\"beta\", \"1\"]\n    build: string?          // 例如 \"20230101\"\n};\n```\n\n**Constraint 类型：**\n```hemlock\ntype Constraint =\n    | Exact(Version)           // \"1.2.3\"\n    | Caret(Version)           // \"^1.2.3\" → >=1.2.3 <2.0.0\n    | Tilde(Version)           // \"~1.2.3\" → >=1.2.3 <1.3.0\n    | Range(op, Version)       // \">=1.0.0\", \"<2.0.0\"\n    | And(Constraint, Constraint)  // 组合范围\n    | Any;                     // \"*\"\n```\n\n### resolver.hml\n\n实现 npm 风格的依赖解析。\n\n**职责：**\n- 解析依赖树\n- 检测版本冲突\n- 检测循环依赖\n- 构建可视化树\n\n**关键函数：**\n```hemlock\nresolve(manifest, lockfile): ResolveResult\n    // 主解析器：返回所有依赖及解析版本的扁平映射\n\nresolve_version(pkg, constraints: [string]): ResolvedPackage?\n    // 查找满足所有约束的版本\n\ndetect_cycles(deps: Map): [Cycle]?\n    // 使用 DFS 查找循环依赖\n\nbuild_tree(lockfile): Tree\n    // 创建用于显示的树结构\n\nfind_why(pkg, lockfile): [Chain]\n    // 查找解释为什么安装 pkg 的依赖链\n```\n\n**解析算法：**\n\n1. **收集约束**：遍历清单和传递依赖\n2. **解析每个包**：对于每个包：\n   - 从依赖方获取所有版本约束\n   - 从 GitHub 获取可用版本\n   - 查找满足所有约束的最高版本\n   - 如果没有版本满足所有约束则报错（冲突）\n3. **检测循环**：运行 DFS 查找循环依赖\n4. **返回扁平映射**：包名 → 解析的版本信息\n\n**ResolveResult 结构：**\n```hemlock\ntype ResolveResult = {\n    packages: Map<string, ResolvedPackage>,\n    conflicts: [Conflict]?,\n    cycles: [Cycle]?\n};\n\ntype ResolvedPackage = {\n    name: string,\n    version: Version,\n    url: string,\n    dependencies: Map<string, string>\n};\n```\n\n### github.hml\n\n用于包发现和下载的 GitHub API 客户端。\n\n**职责：**\n- 获取可用版本（标签）\n- 从仓库下载 package.json\n- 下载发布 tarball\n- 处理认证和速率限制\n\n**关键函数：**\n```hemlock\nget_token(): string?\n    // 从环境或配置获取 token\n\ngithub_request(url, headers?): Response\n    // 带重试的 API 请求\n\nget_tags(owner, repo): [string]\n    // 获取版本标签（v1.0.0、v1.1.0 等）\n\nget_package_json(owner, repo, ref): Manifest\n    // 在特定标签/提交处获取 package.json\n\ndownload_tarball(owner, repo, tag): bytes\n    // 下载发布归档\n\nrepo_exists(owner, repo): bool\n    // 检查仓库是否存在\n\nget_repo_info(owner, repo): RepoInfo\n    // 获取仓库元数据\n```\n\n**重试逻辑：**\n- 指数退避：1秒、2秒、4秒、8秒\n- 重试条件：403（速率限制）、5xx（服务器错误）、网络错误\n- 最多 4 次重试\n- 清晰报告速率限制错误\n\n**使用的 API 端点：**\n```\nGET /repos/{owner}/{repo}/tags\nGET /repos/{owner}/{repo}/contents/package.json?ref={tag}\nGET /repos/{owner}/{repo}/tarball/{tag}\nGET /repos/{owner}/{repo}\n```\n\n### installer.hml\n\n处理包的下载和提取。\n\n**职责：**\n- 从 GitHub 下载包\n- 将 tarball 提取到 hem_modules\n- 检查/使用缓存的包\n- 安装/卸载包\n\n**关键函数：**\n```hemlock\ninstall_package(pkg: ResolvedPackage): bool\n    // 下载并安装单个包\n\ninstall_all(packages: Map, options): InstallResult\n    // 安装所有解析的包\n\nuninstall_package(name: string): bool\n    // 从 hem_modules 移除包\n\nget_installed(): Map<string, string>\n    // 列出当前已安装的包\n\nverify_integrity(pkg): bool\n    // 验证包完整性\n\nprefetch_packages(packages: Map): void\n    // 并行下载到缓存（实验性）\n```\n\n**安装过程：**\n\n1. 检查是否已安装正确版本\n2. 检查缓存中的 tarball\n3. 如果未缓存，从 GitHub 下载\n4. 存储到缓存供将来使用\n5. 提取到 `hem_modules/owner/repo/`\n6. 验证安装\n\n**创建的目录结构：**\n```\nhem_modules/\n└── owner/\n    └── repo/\n        ├── package.json\n        ├── src/\n        └── ...\n```\n\n### cache.hml\n\n管理全局包缓存。\n\n**职责：**\n- 存储下载的 tarball\n- 检索缓存的包\n- 列出缓存的包\n- 清除缓存\n- 管理配置\n\n**关键函数：**\n```hemlock\nget_cache_dir(): string\n    // 获取缓存目录（尊重 HPM_CACHE_DIR）\n\nget_config_dir(): string\n    // 获取配置目录（~/.hpm）\n\nis_cached(owner, repo, version): bool\n    // 检查 tarball 是否已缓存\n\nget_cached_path(owner, repo, version): string\n    // 获取缓存 tarball 的路径\n\nstore_tarball_file(owner, repo, version, data): void\n    // 将 tarball 保存到缓存\n\nlist_cached(): [CachedPackage]\n    // 列出所有缓存的包\n\nclear_cache(): int\n    // 移除所有缓存的包，返回释放的字节数\n\nget_cache_size(): int\n    // 计算缓存总大小\n\nread_config(): Config\n    // 读取 ~/.hpm/config.json\n\nwrite_config(c: Config): void\n    // 写入配置文件\n```\n\n**缓存结构：**\n```\n~/.hpm/\n├── config.json\n└── cache/\n    └── owner/\n        └── repo/\n            ├── 1.0.0.tar.gz\n            └── 1.1.0.tar.gz\n```\n\n## 数据流\n\n### Install 命令流程\n\n```\nhpm install owner/repo@^1.0.0\n         │\n         ▼\n    ┌─────────┐\n    │ main.hml │ 解析参数，调用 cmd_install\n    └────┬────┘\n         │\n         ▼\n    ┌──────────┐\n    │manifest.hml│ 读取 package.json，添加依赖\n    └────┬─────┘\n         │\n         ▼\n    ┌──────────┐\n    │resolver.hml│ 解析所有依赖\n    └────┬─────┘\n         │\n         ├───────────────┐\n         ▼               ▼\n    ┌──────────┐    ┌─────────┐\n    │ github.hml│    │ semver.hml│ 获取版本，查找满足条件的版本\n    └────┬─────┘    └─────────┘\n         │\n         ▼\n    ┌───────────┐\n    │installer.hml│ 下载并提取包\n    └────┬──────┘\n         │\n         ├───────────────┐\n         ▼               ▼\n    ┌──────────┐    ┌─────────┐\n    │ github.hml│    │ cache.hml│ 下载或使用缓存\n    └──────────┘    └─────────┘\n         │\n         ▼\n    ┌──────────┐\n    │lockfile.hml│ 更新 package-lock.json\n    └──────────┘\n```\n\n### 解析算法详情\n\n```\n输入：manifest.dependencies、manifest.devDependencies、现有 lockfile\n\n1. 初始化：\n   - constraints = {} // Map<string, [Constraint]>\n   - resolved = {}    // Map<string, ResolvedPackage>\n   - queue = [直接依赖]\n\n2. 当队列不为空时：\n   a. pkg = queue.pop()\n   b. 如果 pkg 已解析，跳过\n   c. 从依赖方获取 pkg 的所有约束\n   d. 从 GitHub 获取可用版本（已缓存）\n   e. 查找满足所有约束的最高版本\n   f. 如果未找到：冲突\n   g. resolved[pkg] = {version, url, deps}\n   h. 将 pkg 的依赖添加到队列\n\n3. 在解析图中检测循环\n   - 如果发现循环：错误\n\n4. 返回解析映射\n```\n\n## 错误处理\n\n### 退出码\n\n在 main.hml 中定义：\n\n```hemlock\nlet EXIT_SUCCESS = 0;\nlet EXIT_CONFLICT = 1;\nlet EXIT_NOT_FOUND = 2;\nlet EXIT_VERSION_NOT_FOUND = 3;\nlet EXIT_NETWORK = 4;\nlet EXIT_INVALID_MANIFEST = 5;\nlet EXIT_INTEGRITY = 6;\nlet EXIT_RATE_LIMIT = 7;\nlet EXIT_CIRCULAR = 8;\n```\n\n### 错误传播\n\n错误通过返回值向上冒泡：\n\n```hemlock\nfn resolve_version(pkg): Result<Version, ResolveError> {\n    let versions = github.get_tags(owner, repo)?;  // ? 传播错误\n    // ...\n}\n```\n\n## 测试\n\n### 测试框架\n\n`test/framework.hml` 中的自定义测试框架：\n\n```hemlock\nfn suite(name: string, tests: fn()) {\n    print(\"Suite: \" + name);\n    tests();\n}\n\nfn test(name: string, body: fn()) {\n    try {\n        body();\n        print(\"  ✓ \" + name);\n    } catch e {\n        print(\"  ✗ \" + name + \": \" + e);\n        failed += 1;\n    }\n}\n\nfn assert_eq<T>(actual: T, expected: T) {\n    if actual != expected {\n        throw \"Expected \" + expected + \", got \" + actual;\n    }\n}\n```\n\n### 测试文件\n\n- `test/test_semver.hml` - 版本解析、比较、约束\n- `test/test_manifest.hml` - 清单读写、验证\n- `test/test_lockfile.hml` - 锁定文件操作\n- `test/test_cache.hml` - 缓存管理\n\n### 运行测试\n\n```bash\n# 所有测试\nmake test\n\n# 特定测试\nmake test-semver\nmake test-manifest\nmake test-lockfile\nmake test-cache\n```\n\n## 未来改进\n\n### 计划功能\n\n1. **完整性验证** - 完整的 SHA256 哈希检查\n2. **工作区** - Monorepo 支持\n3. **插件系统** - 可扩展命令\n4. **审计** - 安全漏洞检查\n5. **私有注册表** - 自托管包托管\n\n### 已知限制\n\n1. **打包器 bug** - 无法创建独立可执行文件\n2. **并行下载** - 实验性，可能有竞态条件\n3. **完整性** - SHA256 未完全实现\n\n## 贡献\n\n### 代码风格\n\n- 使用 4 空格缩进\n- 函数应该只做一件事\n- 注释复杂逻辑\n- 为新功能编写测试\n\n### 添加命令\n\n1. 在 `main.hml` 中添加处理器：\n   ```hemlock\n   fn cmd_newcmd(args: [string]) {\n       // Implementation\n   }\n   ```\n\n2. 添加到命令分派：\n   ```hemlock\n   match command {\n       \"newcmd\" => cmd_newcmd(args),\n       // ...\n   }\n   ```\n\n3. 更新帮助文本\n\n### 添加模块\n\n1. 创建 `src/newmodule.hml`\n2. 导出公共接口\n3. 在需要它的模块中导入\n4. 在 `test/test_newmodule.hml` 中添加测试\n\n## 另请参阅\n\n- [命令](#hpm-architecture-commands) - CLI 参考\n- [创建包](#hpm-architecture-creating-packages) - 包开发\n- [版本控制](#hpm-architecture-versioning) - 语义化版本\n"}, "hpm: 参考 -> 退出码": {"id": "hpm-exit-codes", "content": "# 退出码\n\nhpm 退出码及其含义的参考。\n\n## 退出码表\n\n| 代码 | 名称 | 描述 |\n|------|------|-------------|\n| 0 | SUCCESS | 命令成功完成 |\n| 1 | CONFLICT | 依赖版本冲突 |\n| 2 | NOT_FOUND | 包未找到 |\n| 3 | VERSION_NOT_FOUND | 请求的版本未找到 |\n| 4 | NETWORK | 网络错误 |\n| 5 | INVALID_MANIFEST | 无效的 package.json |\n| 6 | INTEGRITY | 完整性检查失败 |\n| 7 | RATE_LIMIT | 超出 GitHub API 速率限制 |\n| 8 | CIRCULAR | 检测到循环依赖 |\n\n## 详细描述\n\n### 退出码 0: SUCCESS\n\n命令成功完成。\n\n```bash\n$ hpm install\nInstalled 5 packages\n$ echo $?\n0\n```\n\n### 退出码 1: CONFLICT\n\n两个或多个包需要不兼容版本的依赖。\n\n**示例：**\n```\nError: Dependency conflict for hemlang/json\n\n  package-a requires hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)\n  package-b requires hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)\n\nNo version satisfies all constraints.\n```\n\n**解决方案：**\n1. 检查哪些包有冲突：\n   ```bash\n   hpm why hemlang/json\n   ```\n2. 更新冲突的包：\n   ```bash\n   hpm update package-a\n   ```\n3. 放宽 package.json 中的版本约束\n4. 移除冲突的包之一\n\n### 退出码 2: NOT_FOUND\n\n指定的包在 GitHub 上不存在。\n\n**示例：**\n```\nError: Package not found: hemlang/nonexistent\n\nThe repository hemlang/nonexistent does not exist on GitHub.\n```\n\n**解决方案：**\n1. 验证包名称拼写\n2. 检查仓库是否存在：`https://github.com/owner/repo`\n3. 验证你有访问权限（对于私有仓库，设置 GITHUB_TOKEN）\n\n### 退出码 3: VERSION_NOT_FOUND\n\n没有版本匹配指定的约束。\n\n**示例：**\n```\nError: No version of hemlang/json matches constraint ^5.0.0\n\nAvailable versions: 1.0.0, 1.1.0, 1.2.0, 2.0.0\n```\n\n**解决方案：**\n1. 在 GitHub releases/tags 上检查可用版本\n2. 使用有效的版本约束\n3. 版本标签必须以 'v' 开头（例如 `v1.0.0`）\n\n### 退出码 4: NETWORK\n\n发生网络相关错误。\n\n**示例：**\n```\nError: Network error: could not connect to api.github.com\n\nPlease check your internet connection and try again.\n```\n\n**解决方案：**\n1. 检查网络连接\n2. 检查 GitHub 是否可访问\n3. 如果在防火墙后面，验证代理设置\n4. 如果包已缓存，使用 `--offline`：\n   ```bash\n   hpm install --offline\n   ```\n5. 等待并重试（hpm 会自动重试）\n\n### 退出码 5: INVALID_MANIFEST\n\npackage.json 文件无效或格式错误。\n\n**示例：**\n```\nError: Invalid package.json\n\n  - Missing required field: name\n  - Invalid version format: \"1.0\"\n```\n\n**解决方案：**\n1. 检查 JSON 语法（使用 JSON 验证器）\n2. 确保必需字段存在（`name`、`version`）\n3. 验证字段格式：\n   - name：`owner/repo` 格式\n   - version：`X.Y.Z` semver 格式\n4. 重新生成：\n   ```bash\n   rm package.json\n   hpm init\n   ```\n\n### 退出码 6: INTEGRITY\n\n包完整性验证失败。\n\n**示例：**\n```\nError: Integrity check failed for hemlang/json@1.0.0\n\nExpected: sha256-abc123...\nActual:   sha256-def456...\n\nThe downloaded package may be corrupted.\n```\n\n**解决方案：**\n1. 清除缓存并重新安装：\n   ```bash\n   hpm cache clean\n   hpm install\n   ```\n2. 检查网络问题（部分下载）\n3. 验证包未被篡改\n\n### 退出码 7: RATE_LIMIT\n\n超出 GitHub API 速率限制。\n\n**示例：**\n```\nError: GitHub API rate limit exceeded\n\nUnauthenticated rate limit: 60 requests/hour\nCurrent usage: 60/60\n\nRate limit resets at: 2024-01-15 10:30:00 UTC\n```\n\n**解决方案：**\n1. **使用 GitHub 认证**（推荐）：\n   ```bash\n   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx\n   hpm install\n   ```\n2. 等待速率限制重置（每小时重置）\n3. 如果包已缓存，使用离线模式：\n   ```bash\n   hpm install --offline\n   ```\n\n### 退出码 8: CIRCULAR\n\n在依赖图中检测到循环依赖。\n\n**示例：**\n```\nError: Circular dependency detected\n\n  package-a@1.0.0\n  └── package-b@1.0.0\n      └── package-a@1.0.0  (circular!)\n\nCannot resolve dependency tree.\n```\n\n**解决方案：**\n1. 这通常是包本身的 bug\n2. 联系包维护者\n3. 避免使用循环包之一\n\n## 在脚本中使用退出码\n\n### Bash\n\n```bash\n#!/bin/bash\n\nhpm install\nexit_code=$?\n\ncase $exit_code in\n  0)\n    echo \"Installation successful\"\n    ;;\n  1)\n    echo \"Dependency conflict - check version constraints\"\n    exit 1\n    ;;\n  2)\n    echo \"Package not found - check package name\"\n    exit 1\n    ;;\n  4)\n    echo \"Network error - check connection\"\n    exit 1\n    ;;\n  7)\n    echo \"Rate limited - set GITHUB_TOKEN\"\n    exit 1\n    ;;\n  *)\n    echo \"Unknown error: $exit_code\"\n    exit 1\n    ;;\nesac\n```\n\n### CI/CD\n\n```yaml\n# GitHub Actions\n- name: Install dependencies\n  run: |\n    hpm install\n    if [ $? -eq 7 ]; then\n      echo \"::error::GitHub rate limit exceeded. Add GITHUB_TOKEN.\"\n      exit 1\n    fi\n  env:\n    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n### Make\n\n```makefile\ninstall:\n\t@hpm install || (echo \"Installation failed with code $$?\"; exit 1)\n\ntest: install\n\t@hpm test\n```\n\n## 按退出码故障排除\n\n### 快速参考\n\n| 代码 | 首先检查 |\n|------|---------------------|\n| 1 | 运行 `hpm why <package>` 查看冲突 |\n| 2 | 在 GitHub 上验证包名称 |\n| 3 | 在 GitHub 标签上检查可用版本 |\n| 4 | 检查网络连接 |\n| 5 | 验证 package.json 语法 |\n| 6 | 运行 `hpm cache clean && hpm install` |\n| 7 | 设置 `GITHUB_TOKEN` 环境变量 |\n| 8 | 联系包维护者 |\n\n## 另请参阅\n\n- [故障排除](#hpm-exit-codes-troubleshooting) - 详细解决方案\n- [命令](#hpm-exit-codes-commands) - 命令参考\n- [配置](#hpm-exit-codes-configuration) - 设置 GitHub token\n"}};

        // Mobile menu toggle
        const menuToggle = document.getElementById('menuToggle');
        const sidebar = document.getElementById('sidebar');

        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
            const isOpen = sidebar.classList.contains('open');
            menuToggle.textContent = isOpen ? '\u00d7' : '\u2630';
            menuToggle.setAttribute('aria-expanded', isOpen);
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth < 1024) {
                if (!sidebar.contains(e.target) && !menuToggle.contains(e.target)) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                    menuToggle.setAttribute('aria-expanded', 'false');
                }
            }
        });

        // Theme toggle functionality
        const themeToggle = document.getElementById('themeToggle');
        const root = document.documentElement;

        // Get saved theme or detect system preference
        function getPreferredTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                return savedTheme;
            }
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        // Apply theme
        function setTheme(theme) {
            root.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        }

        // Initialize theme
        const initialTheme = getPreferredTheme();
        if (localStorage.getItem('theme')) {
            setTheme(initialTheme);
        }

        // Toggle theme on button click
        themeToggle.addEventListener('click', () => {
            const currentTheme = root.getAttribute('data-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

            // Determine current effective theme
            let effectiveTheme;
            if (currentTheme) {
                effectiveTheme = currentTheme;
            } else {
                effectiveTheme = prefersDark ? 'dark' : 'light';
            }

            // Toggle to opposite theme
            const newTheme = effectiveTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        });

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!localStorage.getItem('theme')) {
                // Only auto-switch if user hasn't manually set a preference
                root.removeAttribute('data-theme');
            }
        });

        // Markdown parser
        function parseMarkdown(md) {
            let lines = md.split('\n');
            let html = '';
            let inCodeBlock = false;
            let codeBlockContent = '';
            let codeBlockLang = '';
            let inList = false;
            let listContent = '';
            let inBlockquote = false;
            let blockquoteContent = '';
            let inTable = false;
            let tableRows = [];
            let tableHasHeader = false;

            function processInlineMarkdown(text) {
                text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
                text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
                return text;
            }

            function makeId(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s-]/g, '')
                    .replace(/\s+/g, '-')
                    .replace(/^-+|-+$/g, '');
            }

            function flushList() {
                if (inList && listContent) {
                    html += '<ul>\n' + listContent + '</ul>\n';
                    listContent = '';
                    inList = false;
                }
            }

            function flushBlockquote() {
                if (inBlockquote && blockquoteContent) {
                    html += '<blockquote>' + processInlineMarkdown(blockquoteContent.trim()) + '</blockquote>\n';
                    blockquoteContent = '';
                    inBlockquote = false;
                }
            }

            function flushTable() {
                if (inTable && tableRows.length > 0) {
                    html += '<table>\n';
                    for (let r = 0; r < tableRows.length; r++) {
                        const row = tableRows[r];
                        const isHeader = tableHasHeader && r === 0;
                        const tag = isHeader ? 'th' : 'td';
                        html += '<tr>\n';
                        for (const cell of row) {
                            html += '<' + tag + '>' + processInlineMarkdown(cell.trim()) + '</' + tag + '>\n';
                        }
                        html += '</tr>\n';
                    }
                    html += '</table>\n';
                    tableRows = [];
                    inTable = false;
                    tableHasHeader = false;
                }
            }

            function isTableSeparator(line) {
                return /^\|?[\s-:|]+\|[\s-:|]+\|?$/.test(line) && line.includes('-');
            }

            function parseTableRow(line) {
                let cells = line.split('|');
                // Remove empty first/last cells from leading/trailing |
                if (cells.length > 0 && cells[0].trim() === '') cells.shift();
                if (cells.length > 0 && cells[cells.length - 1].trim() === '') cells.pop();
                return cells;
            }

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                const trimmedLine = line.trim();

                // Handle code blocks (including indented ones in lists)
                if (trimmedLine.startsWith('```')) {
                    if (inCodeBlock) {
                        const codeId = 'code-' + Math.random().toString(36).substr(2, 9);
                        const langDisplay = codeBlockLang || 'code';
                        const copyIcon = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>';
                        html += `<div class="code-block">
                            <div class="code-header">
                                <span class="code-lang">${langDisplay}</span>
                                <button class="copy-btn" onclick="copyCode('${codeId}')" aria-label="Copy code">${copyIcon}<span>Copy</span></button>
                            </div>
                            <pre><code id="${codeId}">` + escapeHtml(codeBlockContent) + '</code></pre></div>\n';
                        codeBlockContent = '';
                        codeBlockLang = '';
                        inCodeBlock = false;
                    } else {
                        flushList();
                        flushBlockquote();
                        inCodeBlock = true;
                        codeBlockLang = trimmedLine.substring(3).trim();
                    }
                    continue;
                }

                if (inCodeBlock) {
                    codeBlockContent += line + '\n';
                    continue;
                }

                // Table handling
                if (trimmedLine.includes('|')) {
                    if (trimmedLine.startsWith('|') || trimmedLine.endsWith('|')) {
                        flushList();
                        flushBlockquote();
                        if (isTableSeparator(trimmedLine)) {
                            // This is the separator row (|---|---|), mark header
                            if (tableRows.length === 1) {
                                tableHasHeader = true;
                            }
                        } else {
                            // Regular table row
                            tableRows.push(parseTableRow(trimmedLine));
                            inTable = true;
                        }
                        continue;
                    }
                }
                // Flush table if we hit a non-table line
                if (inTable) {
                    flushTable();
                }

                if (line.startsWith('# ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    const id = makeId(text);
                    html += `<h1 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h1>\n`;
                    continue;
                }
                if (line.startsWith('## ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(3).trim();
                    const id = makeId(text);
                    html += `<h2 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h2>\n`;
                    continue;
                }
                if (line.startsWith('### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(4).trim();
                    const id = makeId(text);
                    html += `<h3 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h3>\n`;
                    continue;
                }
                if (line.startsWith('#### ')) {
                    flushList();
                    flushBlockquote();
                    const text = line.substring(5).trim();
                    const id = makeId(text);
                    html += `<h4 class="section-anchor" id="${id}">${processInlineMarkdown(text)}</h4>\n`;
                    continue;
                }

                if (line.trim() === '---') {
                    flushList();
                    flushBlockquote();
                    html += '<hr>\n';
                    continue;
                }

                if (line.startsWith('> ')) {
                    flushList();
                    blockquoteContent += line.substring(2) + ' ';
                    inBlockquote = true;
                    continue;
                } else if (inBlockquote && line.trim() === '') {
                    flushBlockquote();
                    continue;
                }

                if (line.startsWith('- ') || line.startsWith('* ')) {
                    flushBlockquote();
                    const text = line.substring(2).trim();
                    listContent += '<li>' + processInlineMarkdown(text) + '</li>\n';
                    inList = true;
                    continue;
                } else if (inList && line.trim() !== '' && !line.startsWith('#')) {
                    listContent = listContent.trimEnd();
                    if (listContent.endsWith('</li>')) {
                        listContent = listContent.substring(0, listContent.length - 5);
                        listContent += ' ' + processInlineMarkdown(line.trim()) + '</li>\n';
                    }
                    continue;
                } else if (inList && line.trim() === '') {
                    flushList();
                    continue;
                }

                if (line.trim() === '') {
                    flushList();
                    flushBlockquote();
                    continue;
                }

                flushList();
                flushBlockquote();
                if (line.trim() !== '') {
                    html += '<p>' + processInlineMarkdown(line) + '</p>\n';
                }
            }

            flushList();
            flushBlockquote();
            flushTable();

            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Copy code to clipboard
        function copyCode(codeId) {
            const codeElement = document.getElementById(codeId);
            if (!codeElement) return;

            const text = codeElement.textContent;
            navigator.clipboard.writeText(text).then(() => {
                // Find the button that triggered this
                const btn = codeElement.closest('.code-block').querySelector('.copy-btn');
                if (btn) {
                    const originalText = btn.querySelector('span').textContent;
                    btn.classList.add('copied');
                    btn.querySelector('span').textContent = 'Copied!';

                    setTimeout(() => {
                        btn.classList.remove('copied');
                        btn.querySelector('span').textContent = originalText;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Load a page
        function loadPage(pageId) {
            const pageData = Object.values(PAGES).find(p => p.id === pageId);
            if (!pageData) {
                console.error('Page not found:', pageId);
                return;
            }

            const content = parseMarkdown(pageData.content);
            document.getElementById('content').innerHTML = content;

            // Update active nav link
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                if (link.dataset.page === pageId) {
                    link.classList.add('active');
                }
            });

            // Scroll to top
            window.scrollTo(0, 0);

            // Update URL hash
            window.location.hash = pageId;
        }

        // Setup navigation
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const pageId = link.dataset.page;
                loadPage(pageId);

                // Close mobile menu
                if (window.innerWidth < 1024) {
                    sidebar.classList.remove('open');
                    menuToggle.textContent = '\u2630';
                }
            });
        });

        // Handle browser back/forward
        window.addEventListener('hashchange', () => {
            const hash = window.location.hash.substring(1);
            if (hash) {
                loadPage(hash);
            }
        });

        // Search functionality
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        const searchContainer = document.getElementById('searchContainer');
        const searchToggle = document.getElementById('searchToggle');
        let selectedIndex = -1;
        let currentResults = [];

        // Build search index from PAGES
        function buildSearchIndex() {
            const index = [];
            for (const [title, page] of Object.entries(PAGES)) {
                // Extract section from page ID
                const parts = page.id.split('-');
                let section = '';
                if (parts.length > 1) {
                    section = parts.slice(0, -1).join(' ');
                }

                // Extract headings from content
                const headings = [];
                const headingRegex = /^#+\s+(.+)$/gm;
                let match;
                while ((match = headingRegex.exec(page.content)) !== null) {
                    headings.push(match[1]);
                }

                // Get preview text (first 200 chars, stripped of markdown)
                let preview = page.content
                    .replace(/^#+\s+.+$/gm, '')  // Remove headings
                    .replace(/```[\s\S]*?```/g, '')  // Remove code blocks
                    .replace(/`[^`]+`/g, '')  // Remove inline code
                    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')  // Convert links to text
                    .replace(/\*\*([^*]+)\*\*/g, '$1')  // Remove bold
                    .replace(/\*([^*]+)\*/g, '$1')  // Remove italic
                    .replace(/\n+/g, ' ')  // Normalize whitespace
                    .trim()
                    .substring(0, 200);

                index.push({
                    title: title,
                    pageId: page.id,
                    section: section,
                    headings: headings,
                    content: page.content.toLowerCase(),
                    preview: preview
                });
            }
            return index;
        }

        const searchIndex = buildSearchIndex();

        // Search function
        function search(query) {
            if (!query || query.length < 2) return [];

            const q = query.toLowerCase().trim();
            const results = [];

            for (const item of searchIndex) {
                let score = 0;
                let matchedHeading = null;
                let matchContext = '';

                // Check title (highest priority)
                const titleLower = item.title.toLowerCase();
                if (titleLower === q) {
                    score = 100;
                } else if (titleLower.startsWith(q)) {
                    score = 80;
                } else if (titleLower.includes(q)) {
                    score = 60;
                }

                // Check headings
                for (const heading of item.headings) {
                    const headingLower = heading.toLowerCase();
                    if (headingLower === q) {
                        score = Math.max(score, 50);
                        matchedHeading = heading;
                    } else if (headingLower.includes(q)) {
                        score = Math.max(score, 40);
                        if (!matchedHeading) matchedHeading = heading;
                    }
                }

                // Check content
                if (item.content.includes(q)) {
                    score = Math.max(score, 20);

                    // Find context around the match
                    const idx = item.content.indexOf(q);
                    const start = Math.max(0, idx - 40);
                    const end = Math.min(item.content.length, idx + q.length + 60);
                    matchContext = item.content.substring(start, end);
                    if (start > 0) matchContext = '...' + matchContext;
                    if (end < item.content.length) matchContext = matchContext + '...';
                }

                if (score > 0) {
                    results.push({
                        title: item.title,
                        pageId: item.pageId,
                        section: item.section,
                        score: score,
                        matchedHeading: matchedHeading,
                        preview: matchContext || item.preview,
                        query: q
                    });
                }
            }

            // Sort by score descending
            results.sort((a, b) => b.score - a.score);

            return results.slice(0, 10);  // Limit to 10 results
        }

        // Highlight query in text
        function highlightText(text, query) {
            if (!query) return text;
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return text.replace(regex, '<mark>$1</mark>');
        }

        // Render search results
        function renderResults(results, query) {
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-no-results">No results found</div>';
                return;
            }

            const html = results.map((result, index) => {
                const titleHtml = highlightText(result.title, query);
                const previewHtml = highlightText(result.preview, query);
                const selectedClass = index === selectedIndex ? ' selected' : '';

                return `
                    <div class="search-result${selectedClass}" data-index="${index}" data-page="${result.pageId}">
                        ${result.section ? `<div class="search-result-section">${result.section}</div>` : ''}
                        <div class="search-result-title">${titleHtml}</div>
                        ${result.matchedHeading ? `<div class="search-result-preview">${highlightText(result.matchedHeading, query)}</div>` : ''}
                        <div class="search-result-preview">${previewHtml}</div>
                    </div>
                `;
            }).join('');

            searchResults.innerHTML = html;

            // Add click handlers
            searchResults.querySelectorAll('.search-result').forEach(el => {
                el.addEventListener('click', () => {
                    const pageId = el.dataset.page;
                    loadPage(pageId);
                    closeSearch();
                });
            });
        }

        // Show search results
        function showResults() {
            searchResults.classList.add('active');
        }

        // Hide search results
        function hideResults() {
            searchResults.classList.remove('active');
            selectedIndex = -1;
        }

        // Close search (mobile)
        function closeSearch() {
            hideResults();
            searchInput.value = '';
            searchInput.blur();
            if (window.innerWidth < 769) {
                searchContainer.classList.remove('active');
            }
        }

        // Debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Handle search input
        const handleSearch = debounce((query) => {
            currentResults = search(query);
            if (query.length >= 2) {
                renderResults(currentResults, query);
                showResults();
            } else {
                hideResults();
            }
        }, 150);

        searchInput.addEventListener('input', (e) => {
            handleSearch(e.target.value);
        });

        // Handle keyboard navigation
        searchInput.addEventListener('keydown', (e) => {
            if (!searchResults.classList.contains('active')) return;

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, currentResults.length - 1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                renderResults(currentResults, searchInput.value);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedIndex >= 0 && currentResults[selectedIndex]) {
                    loadPage(currentResults[selectedIndex].pageId);
                    closeSearch();
                } else if (currentResults.length > 0) {
                    loadPage(currentResults[0].pageId);
                    closeSearch();
                }
            } else if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Close results when clicking outside
        document.addEventListener('click', (e) => {
            if (!searchContainer.contains(e.target)) {
                hideResults();
            }
        });

        // Focus search on input click
        searchInput.addEventListener('focus', () => {
            if (searchInput.value.length >= 2) {
                handleSearch(searchInput.value);
            }
        });

        // Global keyboard shortcut (Ctrl+K or Cmd+K)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                if (window.innerWidth < 769) {
                    searchContainer.classList.add('active');
                }
                searchInput.focus();
            }
            if (e.key === 'Escape') {
                closeSearch();
            }
        });

        // Mobile search toggle
        if (searchToggle) {
            searchToggle.addEventListener('click', () => {
                searchContainer.classList.toggle('active');
                if (searchContainer.classList.contains('active')) {
                    searchInput.focus();
                }
            });
        }

        // Language switcher
        function switchLanguage(filename) {
            const currentHash = window.location.hash;
            window.location.href = filename + currentHash;
        }

        // Load initial page
        const initialHash = window.location.hash.substring(1);
        const firstPageId = Object.values(PAGES)[0].id;
        loadPage(initialHash || firstPageId);
    </script>
</body>
</html>