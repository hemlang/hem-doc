================================================================================
HEMLOCK PROGRAMMING LANGUAGE - COMPLETE DOCUMENTATION (Deutsch)
================================================================================

This file contains the complete documentation for the Hemlock programming
language and the hpm package manager in Deutsch.
It is optimized for LLM consumption.

Source: https://github.com/hemlang/hem-doc

--------------------------------------------------------------------------------
TABLE OF CONTENTS
--------------------------------------------------------------------------------

  1. Willkommen
  2. Sprachreferenz

[Erste Schritte]
  3. Installation
  4. Lernpfade
  5. Schnellstart
  6. Tutorial

[Sprachhandbuch]
  7. Arrays
  8. Fehlerbehandlung
  9. Funktionen
  10. Kontrollfluss
  11. Module
  12. Musterabgleich
  13. Objekte
  14. Runen
  15. Speicherverwaltung
  16. Syntax
  17. Typen
  18. Zeichenketten

[Fortgeschrittene Themen]
  19. Asynchronit√§t & Nebenl√§ufigkeit
  20. Atomare Operationen
  21. Befehlsausf√ºhrung
  22. B√ºndeln & Paketieren
  23. FFI
  24. File IO
  25. Kommandozeilenargumente
  26. Memory Ownership
  27. Profilerstellung
  28. Signalverarbeitung

[API-Referenz]
  29. Array-API
  30. Datei-API
  31. Eingebaute Funktionen
  32. Nebenl√§ufigkeits-API
  33. Operatoren
  34. Speicher-API
  35. String-API
  36. Typsystem

[Design & Philosophie]
  37. Designphilosophie
  38. Implementierung
  39. Signatur-Syntax

[Mitwirken]
  40. Richtlinien
  41. Testen

[hpm: Erste Schritte]
  42. Installation
  43. Projekteinrichtung
  44. Schnellstart

[hpm: Benutzerhandbuch]
  45. Befehle
  46. Fehlerbehebung
  47. Konfiguration

[hpm: Paketentwicklung]
  48. Pakete erstellen
  49. Paketspezifikation
  50. Versionierung

[hpm: Referenz]
  51. Architektur
  52. Exit-Codes


================================================================================
DOCUMENTATION
================================================================================

--------------------------------------------------------------------------------
## Willkommen
--------------------------------------------------------------------------------

# Willkommen bei Hemlock

> "Eine kleine, unsichere Sprache zum sicheren Schreiben unsicherer Dinge."

**Hemlock** ist eine System-Skriptsprache, die die Leistungsf√§higkeit von C mit modernen Skript-Annehmlichkeiten verbindet. Sie bietet manuelle Speicherverwaltung, explizite Kontrolle und eingebaute strukturierte asynchrone Nebenl√§ufigkeit.

## Was ist Hemlock?

Hemlock ist f√ºr Programmierer konzipiert, die Folgendes w√ºnschen:

- **Explizite Kontrolle** √ºber Speicher und Ausf√ºhrung
- **C-√§hnliche Syntax** mit modernen Annehmlichkeiten
- **Kein verstecktes Verhalten** oder Magie
- **Echte parallele Asynchronit√§t** mit pthread-basierter Nebenl√§ufigkeit

Hemlock ist keine speichersichere Sprache mit Garbage Collection. Stattdessen gibt es Ihnen die Werkzeuge zur Sicherheit (`buffer`, Typ-Annotationen, Grenzpr√ºfungen), zwingt Sie aber nicht, diese zu verwenden (`ptr`, manuelle Speicherverwaltung, unsichere Operationen).

## Schnelles Beispiel

```hemlock
// Hallo, Hemlock!
fn greet(name: string): string {
    return `Hallo, ${name}!`;
}

let message = greet("Welt");
print(message);

// Manuelle Speicherverwaltung
let buf = buffer(64);
buf[0] = 72;  // 'H'
buf[1] = 105; // 'i'
print(buf);
free(buf);
```

## Funktionen auf einen Blick

| Funktion | Beschreibung |
|----------|--------------|
| **Typsystem** | i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object |
| **Speicher** | Manuelle Verwaltung mit `alloc()`, `buffer()`, `free()` |
| **Async** | Eingebautes `async`/`await` mit echter pthread-Parallelit√§t |
| **FFI** | C-Funktionen direkt aus gemeinsam genutzten Bibliotheken aufrufen |
| **Standardbibliothek** | 40 Module einschlie√ülich crypto, http, sqlite, json und mehr |

## Erste Schritte

Bereit loszulegen? So beginnen Sie:

1. **[Installation](#getting-started-installation)** - Hemlock herunterladen und einrichten
2. **[Schnellstart](#getting-started-quick-start)** - Schreiben Sie Ihr erstes Programm in Minuten
3. **[Tutorial](#getting-started-tutorial)** - Lernen Sie Hemlock Schritt f√ºr Schritt

## Dokumentationsabschnitte

- **Erste Schritte** - Installation, Schnellstartanleitung und Tutorials
- **Sprachhandbuch** - Tiefgehende Einblicke in Syntax, Typen, Funktionen und mehr
- **Fortgeschrittene Themen** - Asynchrone Programmierung, FFI, Signale und Atomics
- **API-Referenz** - Vollst√§ndige Referenz f√ºr eingebaute Funktionen und Standardbibliothek
- **Design & Philosophie** - Verstehen Sie, warum Hemlock so ist, wie es ist

## Paketmanager

Hemlock wird mit **hpm** geliefert, einem Paketmanager zur Verwaltung von Abh√§ngigkeiten:

```bash
hpm init my-project
hpm add some-package
hpm run
```

Weitere Details finden Sie in den hpm-Dokumentationsabschnitten.

---

Verwenden Sie die Navigation auf der linken Seite, um die Dokumentation zu erkunden, oder nutzen Sie die Suchleiste, um bestimmte Themen zu finden.


--------------------------------------------------------------------------------
## Sprachreferenz
--------------------------------------------------------------------------------

# Hemlock Sprachdesign-Philosophie

> "Eine kleine, unsichere Sprache, um unsichere Dinge sicher zu schreiben."

Dieses Dokument bietet einen √úberblick √ºber Hemlocks Designphilosophie und eine Kurzreferenz f√ºr die Sprache.
Erkunden Sie die anderen Dokumentationsabschnitte f√ºr detaillierte Anleitungen und API-Referenzen.

---

## Kernidentit√§t

Hemlock ist eine **System-Skriptsprache** mit manueller Speicherverwaltung und expliziter Kontrolle:
- Die Macht von C mit modernen Skripting-Ergonomien
- Strukturierte async Nebenl√§ufigkeit integriert
- Kein verstecktes Verhalten oder Magie

**Hemlock ist NICHT:** Speichersicher, eine GC-Sprache oder versteckt Komplexit√§t.
**Hemlock IST:** Explizit statt implizit, lehrreich, eine "C-Skriptschicht" f√ºr Systemarbeit.

---

## Designprinzipien

### 1. Explizit statt Implizit
- Semikolons obligatorisch (kein ASI)
- Manuelle Speicherverwaltung (alloc/free)
- Typannotationen optional, aber zur Laufzeit gepr√ºft

### 2. Dynamisch standardm√§√üig, typisiert nach Wahl
- Jeder Wert hat ein Laufzeit-Typ-Tag
- Literale inferieren Typen: `42` ‚Üí i32, `5000000000` ‚Üí i64, `3.14` ‚Üí f64
- Optionale Typannotationen erzwingen Laufzeitpr√ºfungen

### 3. Unsicher ist ein Feature
- Zeigerarithmetik erlaubt (Verantwortung des Benutzers)
- Keine Grenzpr√ºfung bei rohem `ptr` (verwende `buffer` f√ºr Sicherheit)
- Double-Free-Abst√ºrze erlaubt

### 4. Strukturierte Nebenl√§ufigkeit erstklassig
- `async`/`await` eingebaut mit pthread-basierter Parallelit√§t
- Kan√§le f√ºr Kommunikation
- `spawn`/`join`/`detach` f√ºr Aufgabenverwaltung

### 5. C-√§hnliche Syntax
- `{}` Bl√∂cke immer erforderlich
- Kommentare: `// Zeile` und `/* Block */`
- Operatoren entsprechen C: `+`, `-`, `*`, `%`, `&&`, `||`, `!`, `&`, `|`, `^`, `<<`, `>>`
- Inkrement/Dekrement: `++x`, `x++`, `--x`, `x--` (Pr√§fix und Postfix)
- Zusammengesetzte Zuweisung: `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`
- `/` gibt immer Float zur√ºck (verwende `divi()` f√ºr Integer-Division)
- Typsyntax: `let x: type = value;`

---

## Kurzreferenz

### Typen
```
Vorzeichenbehaftet: i8, i16, i32, i64
Vorzeichenlos:      u8, u16, u32, u64
Flie√ükomma:        f32, f64
Andere:             bool, string, rune, array, ptr, buffer, null, object, file, task, channel
Aliase:             integer (i32), number (f64), byte (u8)
```

**Typ-Promotion:** i8 ‚Üí i16 ‚Üí i32 ‚Üí i64 ‚Üí f32 ‚Üí f64 (Flie√ükomma gewinnt immer, aber i64/u64 + f32 ‚Üí f64 um Pr√§zision zu erhalten)

### Literale
```hemlock
let x = 42;              // i32
let big = 5000000000;    // i64 (> i32 max)
let hex = 0xDEADBEEF;    // Hex-Literal
let bin = 0b1010;        // Bin√§r-Literal
let oct = 0o777;         // Oktal-Literal
let sep = 1_000_000;     // Numerische Trennzeichen erlaubt
let pi = 3.14;           // f64
let half = .5;           // f64 (keine f√ºhrende Null)
let s = "hello";         // string
let esc = "\x41\u{1F600}"; // Hex- und Unicode-Escapes
let ch = 'A';            // rune
let emoji = 'üöÄ';        // rune (Unicode)
let arr = [1, 2, 3];     // array
let obj = { x: 10 };     // object
```

### Typkonvertierung
```hemlock
// Typkonstruktorfunktionen - String zu Typ parsen
let n = i32("42");       // String zu i32 parsen
let f = f64("3.14");     // String zu f64 parsen
let b = bool("true");    // String zu bool parsen ("true" oder "false")

// Alle numerischen Typen unterst√ºtzt
let a = i8("-128");      // i8, i16, i32, i64
let c = u8("255");       // u8, u16, u32, u64
let d = f32("1.5");      // f32, f64

// Hex und negative Zahlen
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42

// Typaliase funktionieren auch
let x = integer("100");  // Gleich wie i32("100")
let y = number("1.5");   // Gleich wie f64("1.5")
let z = byte("200");     // Gleich wie u8("200")

// Zwischen numerischen Typen konvertieren
let big = i64(42);       // i32 zu i64
let truncated = i32(3.99); // f64 zu i32 (schneidet auf 3 ab)

// Typannotationen validieren Typen (aber parsen keine Strings)
let f: f64 = 100;        // i32 zu f64 via Annotation (numerische Umwandlung OK)
// let n: i32 = "42";    // FEHLER - verwende i32("42") f√ºr String-Parsing
```

### Introspektion
```hemlock
typeof(42);              // "i32"
typeof("hello");         // "string"
typeof([1, 2, 3]);       // "array"
typeof(null);            // "null"
len("hello");            // 5 (Stringl√§nge in Bytes)
len([1, 2, 3]);          // 3 (Arrayl√§nge)
```

### Speicher
```hemlock
let p = alloc(64);       // roher Zeiger
let b = buffer(64);      // sicherer Buffer (grenzgepr√ºft)
memset(p, 0, 64);
memcpy(dest, src, 64);
free(p);                 // manuelle Bereinigung erforderlich
```

### Kontrollfluss
```hemlock
if (x > 0) { } else if (x < 0) { } else { }
while (cond) { break; continue; }
for (let i = 0; i < 10; i++) { }
for (item in array) { }
loop { if (done) { break; } }   // Endlosschleife (sauberer als while(true))
switch (x) { case 1: break; default: break; }  // C-artiges Fall-Through
defer cleanup();         // l√§uft wenn Funktion zur√ºckkehrt

// Schleifenlabels f√ºr gezieltes break/continue in verschachtelten Schleifen
outer: while (cond) {
    inner: for (let i = 0; i < 10; i++) {
        if (i == 5) { break outer; }     // √§u√üere Schleife beenden
        if (i == 3) { continue outer; }  // √§u√üere Schleife fortsetzen
    }
}
```

### Musterabgleich
```hemlock
// Match-Ausdruck - gibt Wert zur√ºck
let result = match (value) {
    0 => "null",                        // Literal-Muster
    1 | 2 | 3 => "klein",               // ODER-Muster
    n if n < 10 => "mittel",            // Guard-Ausdruck
    n => "gro√ü: " + n                  // Variablenbindung
};

// Typmuster
match (val) {
    n: i32 => "ganzzahl",
    s: string => "zeichenkette",
    _ => "anderes"                      // Platzhalter
}

// Objekt-Destrukturierung
match (point) {
    { x: 0, y: 0 } => "ursprung",
    { x, y } => "bei " + x + "," + y
}

// Array-Destrukturierung mit Rest
match (arr) {
    [] => "leer",
    [first, ...rest] => "kopf: " + first,
    _ => "anderes"
}

// Verschachtelte Muster
match (user) {
    { name, address: { city } } => name + " in " + city
}
```

Siehe `docs/language-guide/pattern-matching.md` f√ºr vollst√§ndige Dokumentation.

### Null-Koaleszenz-Operatoren
```hemlock
// Null-Koaleszenz (??) - gibt links zur√ºck wenn nicht-null, sonst rechts
let name = user.name ?? "Anonym";
let first = a ?? b ?? c ?? "fallback";

// Null-Koaleszenz-Zuweisung (??=) - weist nur zu wenn null
let config = null;
config ??= { timeout: 30 };    // config ist jetzt { timeout: 30 }
config ??= { timeout: 60 };    // config unver√§ndert (nicht null)

// Funktioniert mit Eigenschaften und Indizes
obj.field ??= "standard";
arr[0] ??= "erstes";

// Sichere Navigation (?.) - gibt null zur√ºck wenn Objekt null ist
let city = user?.address?.city;  // null wenn irgendein Teil null ist
let upper = name?.to_upper();    // sicherer Methodenaufruf
let item = arr?.[0];             // sichere Indizierung
```

### Funktionen
```hemlock
fn add(a: i32, b: i32): i32 { return a + b; }
fn greet(name: string, msg?: "Hallo") { print(msg + " " + name); }
let f = fn(x) { return x * 2; };  // anonym/Closure

// Ausdrucksk√∂rper-Funktionen (Pfeilsyntax)
fn double(x: i32): i32 => x * 2;
fn max(a: i32, b: i32): i32 => a > b ? a : b;
let square = fn(x: i32): i32 => x * x;  // anonyme Ausdrucksk√∂rper

// Parametermodifikatoren
fn swap(ref a: i32, ref b: i32) { let t = a; a = b; b = t; }  // √úbergabe per Referenz
fn print_all(const items: array) { for (i in items) { print(i); } }  // unver√§nderlich
```

### Benannte Argumente
```hemlock
// Funktionen k√∂nnen mit benannten Argumenten aufgerufen werden
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " ist " + age + " Jahre alt");
}

// Positionelle Argumente (traditionell)
create_user("Alice", 25, false);

// Benannte Argumente - k√∂nnen in beliebiger Reihenfolge sein
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);

// Optionale Parameter durch Benennung √ºberspringen
create_user("David", active: false);  // Verwendet Standard age=18

// Benannte Argumente m√ºssen nach positionellen kommen
create_user("Eve", age: 21);          // OK: positionell dann benannt
// create_user(name: "Bad", 25);      // FEHLER: positionell nach benannt
```

**Regeln:**
- Benannte Argumente verwenden `name: value` Syntax
- K√∂nnen in beliebiger Reihenfolge nach positionellen Argumenten erscheinen
- Positionelle Argumente k√∂nnen nicht nach benannten Argumenten folgen
- Funktioniert mit Standard-/optionalen Parametern
- Unbekannte Parameternamen verursachen Laufzeitfehler

### Objekte & Enums
```hemlock
define Person { name: string, age: i32, active?: true }
let p: Person = { name: "Alice", age: 30 };
let json = p.serialize();
let restored = json.deserialize();

// Objekt-Kurzschreibweise (ES6-Stil)
let name = "Alice";
let age = 30;
let person = { name, age };         // √§quivalent zu { name: name, age: age }

// Objekt-Spread-Operator
let defaults = { theme: "dark", size: "medium" };
let config = { ...defaults, size: "large" };  // kopiert defaults, √ºberschreibt size

enum Color { RED, GREEN, BLUE }
enum Status { OK = 0, ERROR = 1 }
```

### Zusammengesetzte Typen (Schnittmengen-/Duck-Typen)
```hemlock
// Strukturelle Typen definieren
define HasName { name: string }
define HasAge { age: i32 }
define HasEmail { email: string }

// Zusammengesetzter Typ: Objekt muss ALLE Typen erf√ºllen
let person: HasName & HasAge = { name: "Alice", age: 30 };

// Funktionsparameter mit zusammengesetzten Typen
fn greet(p: HasName & HasAge) {
    print(p.name + " ist " + p.age);
}

// Drei oder mehr Typen
fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}

// Zus√§tzliche Felder erlaubt (Duck-Typing)
let employee: HasName & HasAge = {
    name: "Bob",
    age: 25,
    department: "Engineering"  // OK - zus√§tzliche Felder ignoriert
};
```

Zusammengesetzte Typen bieten Interface-√§hnliches Verhalten ohne separates `interface`-Schl√ºsselwort,
aufbauend auf den bestehenden `define`- und Duck-Typing-Paradigmen.

### Typaliase
```hemlock
// Einfacher Typalias
type Integer = i32;
type Text = string;

// Funktionstyp-Alias
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// Zusammengesetzter Typalias (grossartig f√ºr wiederverwendbare Interfaces)
define HasName { name: string }
define HasAge { age: i32 }
type Person = HasName & HasAge;

// Generischer Typalias
type Pair<T> = { first: T, second: T };

// Typaliase verwenden
let x: Integer = 42;
let cb: Callback = fn(n) { print(n); };
let p: Person = { name: "Alice", age: 30 };
```

Typaliase erstellen benannte Abk√ºrzungen f√ºr komplexe Typen und verbessern Lesbarkeit und Wartbarkeit.

### Funktionstypen
```hemlock
// Funktionstyp-Annotationen f√ºr Parameter
fn apply_fn(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// H√∂here Funktion die eine Funktion zur√ºckgibt
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Async-Funktionstypen
fn run_async(handler: async fn(): void) {
    spawn(handler);
}

// Funktionstypen mit mehreren Parametern
type BinaryOp = fn(i32, i32): i32;
let add: BinaryOp = fn(a, b) { return a + b; };
```

### Const-Parameter
```hemlock
// Const-Parameter - tiefe Unver√§nderlichkeit
fn print_all(const items: array) {
    // items.push(4);  // FEHLER: kann const-Parameter nicht mutieren
    for (item in items) {
        print(item);
    }
}

// Const mit Objekten - keine Mutation √ºber irgendeinen Pfad
fn describe(const person: object) {
    print(person.name);       // OK: Lesen ist erlaubt
    // person.name = "Bob";   // FEHLER: kann nicht mutieren
}

// Verschachtelter Zugriff ist zum Lesen erlaubt
fn get_city(const user: object) {
    return user.address.city;  // OK: verschachtelte Eigenschaften lesen
}
```

Der `const`-Modifikator verhindert jede Mutation des Parameters, einschlie√ülich verschachtelter Eigenschaften.
Dies bietet Kompilierzeit-Sicherheit f√ºr Funktionen, die ihre Eingaben nicht modifizieren sollten.

### Ref-Parameter (√úbergabe per Referenz)
```hemlock
// Ref-Parameter - Variable des Aufrufers wird direkt modifiziert
fn increment(ref x: i32) {
    x = x + 1;  // Modifiziert die urspr√ºngliche Variable
}

let count = 10;
increment(count);
print(count);  // 11 - Original wurde modifiziert

// Klassische Swap-Funktion
fn swap(ref a: i32, ref b: i32) {
    let temp = a;
    a = b;
    b = temp;
}

let x = 1;
let y = 2;
swap(x, y);
print(x, y);  // 2 1

// Ref und regul√§re Parameter mischen
fn add_to(ref target: i32, amount: i32) {
    target = target + amount;
}

let total = 100;
add_to(total, 50);
print(total);  // 150
```

Der `ref`-Modifikator √ºbergibt eine Referenz zur Variable des Aufrufers, sodass die Funktion
sie direkt modifizieren kann. Ohne `ref` werden Primitives per Wert √ºbergeben (kopiert). Verwende `ref` wenn
du den Zustand des Aufrufers mutieren musst, ohne einen Wert zur√ºckzugeben.

**Regeln:**
- `ref`-Parameter m√ºssen Variablen √ºbergeben werden, keine Literale oder Ausdr√ºcke
- Funktioniert mit allen Typen (Primitives, Arrays, Objekte)
- Kombiniere mit Typannotationen: `ref x: i32`
- Kann nicht mit `const` kombiniert werden (sie sind Gegens√§tze)

### Methodensignaturen in Define
```hemlock
// Define mit Methodensignaturen (Interface-Muster)
define Comparable {
    value: i32,
    fn compare(other: Self): i32   // Erforderliche Methodensignatur
}

// Objekte m√ºssen die erforderliche Methode bereitstellen
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};

// Optionale Methoden mit ?
define Serializable {
    fn serialize(): string,        // Erforderlich
    fn pretty?(): string           // Optionale Methode
}

// Self-Typ bezieht sich auf den definierenden Typ
define Cloneable {
    fn clone(): Self   // Gibt gleichen Typ wie das Objekt zur√ºck
}
```

Methodensignaturen in `define`-Bl√∂cken verwenden Komma-Trennzeichen (wie TypeScript-Interfaces),
etablieren Vertr√§ge, die Objekte erf√ºllen m√ºssen, und erm√∂glichen Interface-artige Programmier-
muster mit Hemlocks Duck-Typing-System.

### Fehlerbehandlung
```hemlock
try { throw "fehler"; } catch (e) { print(e); } finally { cleanup(); }
panic("nicht behebbar");  // beendet sofort, nicht abfangbar
```

### Async/Nebenl√§ufigkeit
```hemlock
async fn compute(n: i32): i32 { return n * n; }
let task = spawn(compute, 42);
let result = await task;     // oder join(task)
detach(spawn(background_work));

let ch = channel(10);
ch.send(value);
let val = ch.recv();
ch.close();
```

**Speicherbesitz:** Tasks erhalten Kopien von Primitivwerten, teilen aber Zeiger. Wenn du einen `ptr` an einen gespawnten Task √ºbergibst, musst du sicherstellen, dass der Speicher g√ºltig bleibt, bis der Task abgeschlossen ist. Verwende `join()` vor `free()`, oder verwende Kan√§le, um Abschluss zu signalisieren.

### Benutzereingabe
```hemlock
let name = read_line();          // Zeile von stdin lesen (blockiert)
print("Hallo, " + name);
eprint("Fehlermeldung");         // Auf stderr ausgeben

// read_line() gibt null bei EOF zur√ºck
while (true) {
    let line = read_line();
    if (line == null) { break; }
    print("Erhalten:", line);
}
```

### Datei-I/O
```hemlock
let f = open("datei.txt", "r");  // Modi: r, w, a, r+, w+, a+
let content = f.read();
f.write("daten");
f.seek(0);
f.close();
```

### Signale
```hemlock
signal(SIGINT, fn(sig) { print("Unterbrochen"); });
raise(SIGUSR1);
```

---

## String-Methoden (19)

`substr`, `slice`, `find`, `contains`, `split`, `trim`, `to_upper`, `to_lower`,
`starts_with`, `ends_with`, `replace`, `replace_all`, `repeat`, `char_at`,
`byte_at`, `chars`, `bytes`, `to_bytes`, `deserialize`

Template-Strings: `` `Hallo ${name}!` ``

**String-Mutabilit√§t:** Strings sind per Indexzuweisung mutierbar (`s[0] = 'H'`), aber alle String-Methoden geben neue Strings zur√ºck, ohne das Original zu modifizieren. Dies erlaubt In-Place-Mutation wenn n√∂tig, w√§hrend Methodenverkettung funktional bleibt.

**String-L√§ngeneigenschaften:**
```hemlock
let s = "hallo üöÄ";
print(s.length);       // 7 (Zeichen-/Rune-Anzahl)
print(s.byte_length);  // 10 (Byte-Anzahl - Emoji ist 4 Bytes UTF-8)
```

## Array-Methoden (18)

`push`, `pop`, `shift`, `unshift`, `insert`, `remove`, `find`, `contains`,
`slice`, `join`, `concat`, `reverse`, `first`, `last`, `clear`, `map`, `filter`, `reduce`

Typisierte Arrays: `let nums: array<i32> = [1, 2, 3];`

---

## Standardbibliothek (40 Module)

Importieren mit `@stdlib/`-Pr√§fix:
```hemlock
import { sin, cos, PI } from "@stdlib/math";
import { HashMap, Queue, Set } from "@stdlib/collections";
import { read_file, write_file } from "@stdlib/fs";
import { TcpStream, UdpSocket } from "@stdlib/net";
```

| Modul | Beschreibung |
|-------|--------------|
| `arena` | Arena-Speicherallokator (Bump-Allocation) |
| `args` | Kommandozeilenargument-Parsing |
| `assert` | Assertions-Utilities |
| `async` | ThreadPool, parallel_map |
| `async_fs` | Asynchrone Datei-I/O-Operationen |
| `collections` | HashMap, Queue, Stack, Set, LinkedList, LRUCache |
| `compression` | gzip, gunzip, deflate |
| `crypto` | aes_encrypt, rsa_sign, random_bytes |
| `csv` | CSV-Parsing und -Generierung |
| `datetime` | DateTime-Klasse, Formatierung, Parsing |
| `encoding` | base64_encode, hex_encode, url_encode |
| `env` | getenv, setenv, exit, get_pid |
| `fmt` | String-Formatierungs-Utilities |
| `fs` | read_file, write_file, list_dir, exists |
| `glob` | Datei-Musterabgleich |
| `hash` | sha256, sha512, md5, djb2 |
| `http` | http_get, http_post, http_request |
| `ipc` | Inter-Prozess-Kommunikation |
| `iter` | Iterator-Utilities |
| `json` | parse, stringify, pretty, get, set |
| `logging` | Logger mit Stufen |
| `math` | sin, cos, sqrt, pow, rand, PI, E |
| `net` | TcpListener, TcpStream, UdpSocket |
| `os` | platform, arch, cpu_count, hostname |
| `path` | Dateipfad-Manipulation |
| `process` | fork, exec, wait, kill |
| `random` | Zufallszahlengenerierung |
| `regex` | compile, test (POSIX ERE) |
| `retry` | Wiederholungslogik mit Backoff |
| `semver` | Semantische Versionierung |
| `shell` | Shell-Befehls-Utilities |
| `sqlite` | SQLite-Datenbank, query, exec, Transaktionen |
| `strings` | pad_left, is_alpha, reverse, lines |
| `terminal` | ANSI-Farben und -Stile |
| `testing` | describe, test, expect |
| `time` | now, time_ms, sleep, clock |
| `toml` | TOML-Parsing und -Generierung |
| `url` | URL-Parsing und -Manipulation |
| `uuid` | UUID-Generierung |
| `websocket` | WebSocket-Client |

Siehe `stdlib/docs/` f√ºr detaillierte Moduldokumentation.

---

## FFI (Foreign Function Interface)

C-Funktionen aus Shared Libraries deklarieren und aufrufen:
```hemlock
import "libc.so.6";

extern fn strlen(s: string): i32;
extern fn getpid(): i32;

let len = strlen("Hallo!");  // 6
let pid = getpid();
```

FFI-Funktionen aus Modulen exportieren:
```hemlock
// string_utils.hml
import "libc.so.6";

export extern fn strlen(s: string): i32;
export fn string_length(s: string): i32 {
    return strlen(s);
}
```

Dynamisches FFI (Laufzeit-Binding):
```hemlock
let lib = ffi_open("libc.so.6");
let puts = ffi_bind(lib, "puts", [FFI_POINTER], FFI_INT);
puts("Hallo von C!");
ffi_close(lib);
```

Typen: `FFI_INT`, `FFI_DOUBLE`, `FFI_POINTER`, `FFI_STRING`, `FFI_VOID`, etc.

---

## Atomare Operationen

Lock-freie nebenlaeufige Programmierung mit atomaren Operationen:

```hemlock
// Speicher f√ºr atomares i32 allokieren
let p = alloc(4);
ptr_write_i32(p, 0);

// Atomares Laden/Speichern
let val = atomic_load_i32(p);        // Atomar lesen
atomic_store_i32(p, 42);             // Atomar schreiben

// Fetch-and-Modify-Operationen (geben ALTEN Wert zur√ºck)
let old = atomic_add_i32(p, 10);     // Addieren, alten zur√ºckgeben
old = atomic_sub_i32(p, 5);          // Subtrahieren, alten zur√ºckgeben
old = atomic_and_i32(p, 0xFF);       // Bitweises UND
old = atomic_or_i32(p, 0x10);        // Bitweises ODER
old = atomic_xor_i32(p, 0x0F);       // Bitweises XOR

// Compare-and-Swap (CAS)
let success = atomic_cas_i32(p, 42, 100);  // Wenn *p == 42, auf 100 setzen
// Gibt true zur√ºck wenn Swap erfolgreich, sonst false

// Atomarer Austausch
old = atomic_exchange_i32(p, 999);   // Tauschen, alten zur√ºckgeben

free(p);

// i64-Varianten verf√ºgbar (atomic_load_i64, atomic_add_i64, etc.)

// Speicherbarriere (vollst√§ndige Barriere)
atomic_fence();
```

Alle Operationen verwenden sequenzielle Konsistenz (`memory_order_seq_cst`).

---

## Projektstruktur

```
hemlock/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ frontend/         # Gemeinsam: Lexer, Parser, AST, Module
‚îÇ   ‚îú‚îÄ‚îÄ backends/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interpreter/  # hemlock: Tree-Walking-Interpreter
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ compiler/     # hemlockc: C-Code-Generator
‚îÇ   ‚îú‚îÄ‚îÄ tools/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lsp/          # Language Server Protocol
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ bundler/      # Bundle-/Paket-Tools
‚îú‚îÄ‚îÄ runtime/              # Kompilierte Programm-Laufzeit (libhemlock_runtime.a)
‚îú‚îÄ‚îÄ stdlib/               # Standardbibliothek (40 Module)
‚îÇ   ‚îî‚îÄ‚îÄ docs/             # Moduldokumentation
‚îú‚îÄ‚îÄ docs/                 # Vollst√§ndige Dokumentation
‚îÇ   ‚îú‚îÄ‚îÄ language-guide/   # Typen, Strings, Arrays, etc.
‚îÇ   ‚îú‚îÄ‚îÄ reference/        # API-Referenzen
‚îÇ   ‚îî‚îÄ‚îÄ advanced/         # Async, FFI, Signale, etc.
‚îú‚îÄ‚îÄ tests/                # 625+ Tests
‚îî‚îÄ‚îÄ examples/             # Beispielprogramme
```

---

## Code-Stil-Richtlinien

### Konstanten und magische Zahlen

Beim Hinzuf√ºgen von numerischen Konstanten zur C-Codebasis folge diesen Richtlinien:

1. **Definiere Konstanten in `include/hemlock_limits.h`** - Diese Datei ist der zentrale Ort f√ºr alle Kompilierzeit- und Laufzeitlimits, Kapazitaeten und benannte Konstanten.

2. **Verwende beschreibende Namen mit `HML_`-Pr√§fix** - Alle Konstanten sollten mit `HML_` pr√§fixiert werden f√ºr Namensraum-Klarheit.

3. **Vermeide magische Zahlen** - Ersetze hart-codierte numerische Werte durch benannte Konstanten. Beispiele:
   - Typbereichslimits: `HML_I8_MIN`, `HML_I8_MAX`, `HML_U32_MAX`
   - Pufferkapazitaeten: `HML_INITIAL_ARRAY_CAPACITY`, `HML_INITIAL_LEXER_BUFFER_CAPACITY`
   - Zeitumrechnungen: `HML_NANOSECONDS_PER_SECOND`, `HML_MILLISECONDS_PER_SECOND`
   - Hash-Seeds: `HML_DJB2_HASH_SEED`
   - ASCII-Werte: `HML_ASCII_CASE_OFFSET`, `HML_ASCII_PRINTABLE_START`

4. **Inkludiere `hemlock_limits.h`** - Quelldateien sollten diesen Header einbinden (oft via `internal.h`) um auf Konstanten zuzugreifen.

5. **Dokumentiere den Zweck** - Fuege einen Kommentar hinzu, der erkl√§rt, was jede Konstante repraesentiert.

---

## Was man NICHT tun sollte

- Implizites Verhalten hinzuf√ºgen (ASI, GC, Auto-Cleanup)
- Komplexit√§t verstecken (magische Optimierungen, versteckte Refcounts)
- Bestehende Semantik brechen (Semikolons, manueller Speicher, mutable Strings)
- Pr√§zision bei impliziten Konvertierungen verlieren
- Magische Zahlen verwenden - definiere stattdessen benannte Konstanten in `hemlock_limits.h`

---

## Testen

```bash
make test              # Interpreter-Tests ausf√ºhren
make test-compiler     # Compiler-Tests ausf√ºhren
make parity            # Paritaetstests ausf√ºhren (beide m√ºssen √ºbereinstimmen)
make test-all          # Alle Testsuiten ausf√ºhren
```

**Wichtig:** Tests k√∂nnen aufgrund von async/Nebenlaeufigkeitsproblemen haengen bleiben. Verwende immer einen Timeout beim Ausf√ºhren von Tests:
```bash
timeout 60 make test   # 60 Sekunden Timeout
timeout 120 make parity
```

Testkategorien: primitives, memory, strings, arrays, functions, objects, async, ffi, defer, signals, switch, bitwise, typed_arrays, modules, stdlib_*

---

## Compiler/Interpreter-Architektur

Hemlock hat zwei Ausfuehrungsbackends, die ein gemeinsames Frontend teilen:

```
Quellcode (.hml)
    ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  GEMEINSAMES FRONTEND       ‚îÇ
‚îÇ  - Lexer (src/frontend/)    ‚îÇ
‚îÇ  - Parser (src/frontend/)   ‚îÇ
‚îÇ  - AST (src/frontend/)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚Üì                    ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ INTERPRETER‚îÇ    ‚îÇ  COMPILER  ‚îÇ
‚îÇ (hemlock)  ‚îÇ    ‚îÇ (hemlockc) ‚îÇ
‚îÇ            ‚îÇ    ‚îÇ            ‚îÇ
‚îÇ Tree-Walk  ‚îÇ    ‚îÇ Typcheck   ‚îÇ
‚îÇ Auswertung ‚îÇ    ‚îÇ AST ‚Üí C    ‚îÇ
‚îÇ            ‚îÇ    ‚îÇ gcc Link   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Compiler-Typpr√ºfung

Der Compiler (`hemlockc`) beinhaltet Kompilierzeit-Typpr√ºfung, **standardm√§√üig aktiviert**:

```bash
hemlockc program.hml -o program    # Typprueft, dann kompiliert
hemlockc --check program.hml       # Nur Typpr√ºfung, nicht kompilieren
hemlockc --no-type-check prog.hml  # Typpr√ºfung deaktivieren
hemlockc --strict-types prog.hml   # Warnung bei impliziten 'any'-Typen
```

Der Typchecker:
- Validiert Typannotationen zur Kompilierzeit
- Behandelt untypisierten Code als dynamisch (`any`-Typ) - immer g√ºltig
- Bietet Optimierungshinweise f√ºr Unboxing
- Verwendet permissive numerische Konvertierungen (Bereich zur Laufzeit validiert)

### Verzeichnisstruktur

```
hemlock/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ frontend/           # Gemeinsam: Lexer, Parser, AST, Module
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lexer.c
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ parser/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ast.c
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ module.c
‚îÇ   ‚îú‚îÄ‚îÄ backends/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interpreter/    # hemlock: Tree-Walking-Interpreter
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ runtime/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ builtins/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ compiler/       # hemlockc: C-Code-Generator
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ main.c
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ codegen/
‚îÇ   ‚îú‚îÄ‚îÄ tools/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lsp/            # Language Server
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ bundler/        # Bundle-/Paket-Tools
‚îú‚îÄ‚îÄ runtime/                # libhemlock_runtime.a f√ºr kompilierte Programme
‚îú‚îÄ‚îÄ stdlib/                 # Gemeinsame Standardbibliothek
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ parity/             # Tests die BEIDE Backends bestehen MUESSEN
    ‚îú‚îÄ‚îÄ interpreter/        # Interpreter-spezifische Tests
    ‚îî‚îÄ‚îÄ compiler/           # Compiler-spezifische Tests
```

---

## Paritaets-zuerst-Entwicklung

**Sowohl der Interpreter als auch der Compiler m√ºssen identische Ausgabe f√ºr die gleiche Eingabe produzieren.**

### Entwicklungsrichtlinie

Beim Hinzuf√ºgen oder Modifizieren von Sprachfeatures:

1. **Design** - Definiere die AST-/semantische √Ñnderung im gemeinsamen Frontend
2. **Interpreter implementieren** - Tree-Walking-Auswertung hinzuf√ºgen
3. **Compiler implementieren** - C-Code-Generierung hinzuf√ºgen
4. **Paritaetstest hinzuf√ºgen** - Test in `tests/parity/` mit `.expected`-Datei schreiben
5. **Verifizieren** - Fuehre `make parity` vor dem Mergen aus

### Paritaetsteststruktur

```
tests/parity/
‚îú‚îÄ‚îÄ language/       # Kern-Sprachfeatures (Kontrollfluss, Closures, etc.)
‚îú‚îÄ‚îÄ builtins/       # Eingebaute Funktionen (print, typeof, memory, etc.)
‚îú‚îÄ‚îÄ methods/        # String- und Array-Methoden
‚îî‚îÄ‚îÄ modules/        # Import/Export, Stdlib-Imports
```

Jeder Test hat zwei Dateien:
- `feature.hml` - Das Testprogramm
- `feature.expected` - Erwartete Ausgabe (muss f√ºr beide Backends √ºbereinstimmen)

### Paritaetstestergebnisse

| Status | Bedeutung |
|--------|-----------|
| `‚úì PASSED` | Sowohl Interpreter als auch Compiler stimmen mit erwarteter Ausgabe √ºberein |
| `‚óê INTERP_ONLY` | Interpreter funktioniert, Compiler scheitert (braucht Compiler-Fix) |
| `‚óë COMPILER_ONLY` | Compiler funktioniert, Interpreter scheitert (selten) |
| `‚úó FAILED` | Beide scheitern (Test- oder Implementierungsfehler) |

### Was Paritaet erfordert

- Alle Sprachkonstrukte (if, while, for, switch, defer, try/catch)
- Alle Operatoren (arithmetisch, bitweise, logisch, Vergleich)
- Alle eingebauten Funktionen (print, typeof, alloc, etc.)
- Alle String- und Array-Methoden
- Typzwangs- und Promotionsregeln
- Fehlermeldungen f√ºr Laufzeitfehler

### Was sich unterscheiden darf

- Leistungscharakteristiken
- Speicherlayout-Details
- Debug-/Stacktrace-Format
- Kompilierungsfehler (Compiler kann mehr zur Kompilierzeit erkennen)

### Einen Paritaetstest hinzuf√ºgen

```bash
# 1. Testdatei erstellen
cat > tests/parity/language/my_feature.hml << 'EOF'
// Testbeschreibung
let x = some_feature();
print(x);
EOF

# 2. Erwartete Ausgabe vom Interpreter generieren
./hemlock tests/parity/language/my_feature.hml > tests/parity/language/my_feature.expected

# 3. Paritaet verifizieren
make parity
```

---

## Version

**v1.8.0** - Aktuelles Release mit:
- **Musterabgleich** (`match`-Ausdr√ºcke) - M√§chtige Destrukturierung und Kontrollfluss:
  - Literal-, Platzhalter- und Variablenbindungsmuster
  - ODER-Muster (`1 | 2 | 3`)
  - Guard-Ausdr√ºcke (`n if n > 0`)
  - Objekt-Destrukturierung (`{ x, y }`)
  - Array-Destrukturierung mit Rest (`[first, ...rest]`)
  - Typmuster (`n: i32`)
  - Volle Paritaet zwischen Interpreter und Compiler
- **Compiler-Hilfsannotationen** - 11 Optimierungsannotationen f√ºr GCC/Clang-Kontrolle:
  - `@inline`, `@noinline` - Funktions-Inlining-Kontrolle
  - `@hot`, `@cold` - Branch-Prediction-Hinweise
  - `@pure`, `@const` - Seiteneffekt-Annotationen
  - `@flatten` - alle Aufrufe innerhalb der Funktion inlinen
  - `@optimize(level)` - Pro-Funktion-Optimierungsstufe ("0", "1", "2", "3", "s", "fast")
  - `@warn_unused` - Warnung bei ignorierten Rueckgabewerten
  - `@section(name)` - Benutzerdefinierte ELF-Sektionsplatzierung (z.B. `@section(".text.hot")`)
- **Ausdrucksk√∂rper-Funktionen** (`fn double(x): i32 => x * 2;`) - praegnante Einzelausdruck-Funktionssyntax
- **Einzeilige Anweisungen** - klammerlose `if`, `while`, `for`-Syntax (z.B. `if (x > 0) print(x);`)
- **Typaliase** (`type Name = Type;`) - benannte Abk√ºrzungen f√ºr komplexe Typen
- **Funktionstyp-Annotationen** (`fn(i32): i32`) - erstklassige Funktionstypen
- **Const-Parameter** (`fn(const x: array)`) - tiefe Unver√§nderlichkeit f√ºr Parameter
- **Ref-Parameter** (`fn(ref x: i32)`) - √úbergabe per Referenz f√ºr direkte Aufrufer-Mutation
- **Methodensignaturen in define** (`fn method(): Type`) - Interface-artige Vertr√§ge (komma-getrennt)
- **Self-Typ** in Methodensignaturen - bezieht sich auf den definierenden Typ
- **Loop-Schl√ºsselwort** (`loop { }`) - sauberere Endlosschleifen, ersetzt `while (true)`
- **Schleifenlabels** (`outer: while`) - gezieltes break/continue f√ºr verschachtelte Schleifen
- **Objekt-Kurzschreibweise** (`{ name }`) - ES6-Stil-Kurzeigenschaften-Syntax
- **Objekt-Spread** (`{ ...obj }`) - Objektfelder kopieren und zusammenfuehren
- **Zusammengesetzte Duck-Typen** (`A & B & C`) - Schnittmengentypen f√ºr strukturelle Typisierung
- **Benannte Argumente** f√ºr Funktionsaufrufe (`foo(name: "value", age: 30)`)
- **Null-Koaleszenz-Operatoren** (`??`, `??=`, `?.`) f√ºr sichere Null-Behandlung
- **Oktal-Literale** (`0o777`, `0O123`)
- **Numerische Trennzeichen** (`1_000_000`, `0xFF_FF`, `0b1111_0000`)
- **Blockkommentare** (`/* ... */`)
- **Hex-Escape-Sequenzen** in Strings/Runes (`\x41` = 'A')
- **Unicode-Escape-Sequenzen** in Strings (`\u{1F600}` = üòÄ)
- **Float-Literale ohne f√ºhrende Null** (`.5`, `.123`, `.5e2`)
- **Kompilierzeit-Typpr√ºfung** in hemlockc (standardm√§√üig aktiviert)
- **LSP-Integration** mit Typpr√ºfung f√ºr Echtzeit-Diagnosen
- **Zusammengesetzte Zuweisungsoperatoren** (`+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`)
- **Inkrement/Dekrement-Operatoren** (`++x`, `x++`, `--x`, `x--`)
- **Typ-Praezisions-Fix**: i64/u64 + f32 ‚Üí f64 um Pr√§zision zu erhalten
- Vereinheitlichtes Typsystem mit Unboxing-Optimierungshinweisen
- Volles Typsystem (i8-i64, u8-u64, f32/f64, bool, string, rune, ptr, buffer, array, object, enum, file, task, channel)
- UTF-8-Strings mit 19 Methoden
- Arrays mit 18 Methoden einschlie√ülich map/filter/reduce
- Manuelle Speicherverwaltung mit `talloc()` und `sizeof()`
- Async/await mit echter pthread-Parallelit√§t
- Atomare Operationen f√ºr lock-freie nebenlaeufige Programmierung
- 40 Stdlib-Module (+ arena, assert, semver, toml, retry, iter, random, shell)
- FFI f√ºr C-Interop mit `export extern fn` f√ºr wiederverwendbare Bibliotheks-Wrapper
- FFI-Struct-Unterst√ºtzung im Compiler (C-Structs per Wert √ºbergeben)
- FFI-Zeiger-Helfer (`ptr_null`, `ptr_read_*`, `ptr_write_*`)
- defer, try/catch/finally/throw, panic
- Datei-I/O, Signalbehandlung, Befehlsausfuehrung
- [hpm](https://github.com/hemlang/hpm) Paketmanager mit GitHub-basierter Registry
- Compiler-Backend (C-Code-Generierung) mit 100% Interpreter-Paritaet
- LSP-Server mit Go-to-Definition und Find-References
- AST-Optimierungspass und Variablenaufloesung f√ºr O(1)-Lookup
- apply()-Builtin f√ºr dynamische Funktionsaufrufe
- Ungepufferte Kan√§le und Many-Params-Unterst√ºtzung
- 159 Paritaetstests (100% Erfolgsrate)

---

## Philosophie

> Wir geben dir die Werkzeuge, um sicher zu sein (`buffer`, Typannotationen, Grenzpr√ºfung), aber wir zwingen dich nicht, sie zu verwenden (`ptr`, manueller Speicher, unsichere Operationen).

**Wenn du unsicher bist, ob ein Feature zu Hemlock passt, frage: "Gibt dies dem Programmierer mehr explizite Kontrolle, oder versteckt es etwas?"**

Wenn es versteckt, geh√∂rt es wahrscheinlich nicht in Hemlock.



################################################################################
# ERSTE SCHRITTE
################################################################################

--------------------------------------------------------------------------------
## Installation
--------------------------------------------------------------------------------

# Installation

Diese Anleitung hilft Ihnen bei der Installation von Hemlock auf Ihrem System.

## Schnellinstallation (Empfohlen)

Der einfachste Weg, Hemlock zu installieren, ist das einzeilige Installationsskript:

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash
```

Dies l√§dt die neueste vorkompilierte Bin√§rdatei f√ºr Ihre Plattform herunter und installiert sie (Linux oder macOS, x86_64 oder arm64).

### Installationsoptionen

```bash
# Installation in ein benutzerdefiniertes Pr√§fix (Standard: ~/.local)
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --prefix /usr/local

# Installation einer bestimmten Version
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --version v1.6.0

# Installation und automatische Aktualisierung des Shell-PATH
curl -fsSL https://raw.githubusercontent.com/hemlang/hemlock/main/install.sh | bash -s -- --update-path
```

Nach der Installation √ºberpr√ºfen Sie die Funktionsf√§higkeit:

```bash
hemlock --version
```

---

## Aus dem Quellcode kompilieren

Wenn Sie lieber aus dem Quellcode kompilieren m√∂chten oder die vorkompilierten Bin√§rdateien f√ºr Ihr System nicht funktionieren, folgen Sie den nachstehenden Anweisungen.

## Voraussetzungen

### Erforderliche Abh√§ngigkeiten

Hemlock ben√∂tigt folgende Abh√§ngigkeiten zum Kompilieren:

- **C-Compiler**: GCC oder Clang (C11-Standard)
- **Make**: GNU Make
- **libffi**: Foreign Function Interface-Bibliothek (f√ºr FFI-Unterst√ºtzung)
- **OpenSSL**: Kryptografie-Bibliothek (f√ºr Hash-Funktionen: md5, sha1, sha256)
- **libwebsockets**: WebSocket- und HTTP-Client/Server-Unterst√ºtzung
- **zlib**: Kompressionsbibliothek

### Abh√§ngigkeiten installieren

**macOS:**
```bash
# Homebrew installieren, falls noch nicht vorhanden
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Xcode Command Line Tools installieren
xcode-select --install

# Abh√§ngigkeiten √ºber Homebrew installieren
brew install libffi openssl@3 libwebsockets
```

**Hinweis f√ºr macOS-Benutzer**: Das Makefile erkennt automatisch Homebrew-Installationen und setzt die korrekten Include-/Bibliothekspfade. Hemlock unterst√ºtzt sowohl Intel- (x86_64) als auch Apple-Silicon- (arm64) Architekturen.

**Ubuntu/Debian:**
```bash
sudo apt-get update
sudo apt-get install build-essential libffi-dev libssl-dev libwebsockets-dev zlib1g-dev
```

**Fedora/RHEL:**
```bash
sudo dnf install gcc make libffi-devel openssl-devel libwebsockets-devel zlib-devel
```

**Arch Linux:**
```bash
sudo pacman -S base-devel libffi openssl libwebsockets zlib
```

## Aus dem Quellcode kompilieren

### 1. Repository klonen

```bash
git clone https://github.com/hemlang/hemlock.git
cd hemlock
```

### 2. Hemlock kompilieren

```bash
make
```

Dies kompiliert den Hemlock-Interpreter und platziert die ausf√ºhrbare Datei im aktuellen Verzeichnis.

### 3. Installation √ºberpr√ºfen

```bash
./hemlock --version
```

Sie sollten die Hemlock-Versionsinformationen sehen.

### 4. Build testen

F√ºhren Sie die Testsuite aus, um sicherzustellen, dass alles korrekt funktioniert:

```bash
make test
```

Alle Tests sollten bestehen. Falls Fehler auftreten, melden Sie diese bitte als Issue.

## Systemweite Installation (Optional)

Um Hemlock systemweit zu installieren (z.B. in `/usr/local/bin`):

```bash
sudo make install
```

Dies erm√∂glicht es Ihnen, `hemlock` von √ºberall auszuf√ºhren, ohne den vollst√§ndigen Pfad anzugeben.

## Hemlock ausf√ºhren

### Interaktive REPL

Starten Sie die Read-Eval-Print-Schleife:

```bash
./hemlock
```

Sie sehen eine Eingabeaufforderung, in der Sie Hemlock-Code eingeben k√∂nnen:

```
Hemlock REPL
> print("Hallo, Welt!");
Hallo, Welt!
> let x = 42;
> print(x * 2);
84
>
```

Beenden Sie die REPL mit `Ctrl+D` oder `Ctrl+C`.

### Programme ausf√ºhren

F√ºhren Sie ein Hemlock-Skript aus:

```bash
./hemlock programm.hml
```

Mit Kommandozeilenargumenten:

```bash
./hemlock programm.hml arg1 arg2 "Argument mit Leerzeichen"
```

## Verzeichnisstruktur

Nach dem Kompilieren sieht Ihr Hemlock-Verzeichnis so aus:

```
hemlock/
‚îú‚îÄ‚îÄ hemlock           # Kompilierte Interpreter-Ausf√ºhrungsdatei
‚îú‚îÄ‚îÄ src/              # Quellcode
‚îú‚îÄ‚îÄ include/          # Header-Dateien
‚îú‚îÄ‚îÄ tests/            # Testsuite
‚îú‚îÄ‚îÄ examples/         # Beispielprogramme
‚îú‚îÄ‚îÄ docs/             # Dokumentation
‚îú‚îÄ‚îÄ stdlib/           # Standardbibliothek
‚îú‚îÄ‚îÄ Makefile          # Build-Konfiguration
‚îî‚îÄ‚îÄ README.md         # Projekt-README
```

## Build-Optionen

### Debug-Build

Mit Debug-Symbolen und ohne Optimierung kompilieren:

```bash
make debug
```

### Bereinigter Build

Alle kompilierten Dateien entfernen:

```bash
make clean
```

Von Grund auf neu kompilieren:

```bash
make clean && make
```

## Fehlerbehebung

### macOS: Bibliothek nicht gefunden

Wenn Sie Fehler √ºber fehlende Bibliotheken erhalten (`-lcrypto`, `-lffi`, usw.):

1. Stellen Sie sicher, dass die Homebrew-Abh√§ngigkeiten installiert sind:
   ```bash
   brew install libffi openssl@3 libwebsockets
   ```

2. √úberpr√ºfen Sie die Homebrew-Pfade:
   ```bash
   brew --prefix libffi
   brew --prefix openssl
   ```

3. Das Makefile sollte diese Pfade automatisch erkennen. Falls nicht, √ºberpr√ºfen Sie, ob `brew` in Ihrem PATH ist:
   ```bash
   which brew
   ```

### macOS: BSD-Typfehler (`u_int`, `u_char` nicht gefunden)

Wenn Sie Fehler √ºber unbekannte Typnamen wie `u_int` oder `u_char` sehen:

1. Dies wurde in v1.0.0+ durch Verwendung von `_DARWIN_C_SOURCE` anstelle von `_POSIX_C_SOURCE` behoben
2. Stellen Sie sicher, dass Sie die neueste Version des Codes haben
3. Bereinigen und neu kompilieren:
   ```bash
   make clean && make
   ```

### Linux: libffi nicht gefunden

Wenn Sie Fehler √ºber fehlende `ffi.h` oder `-lffi` erhalten:

1. Stellen Sie sicher, dass `libffi-dev` installiert ist (siehe Abh√§ngigkeiten oben)
2. Pr√ºfen Sie, ob `pkg-config` es finden kann:
   ```bash
   pkg-config --cflags --libs libffi
   ```
3. Falls nicht gefunden, m√ºssen Sie m√∂glicherweise `PKG_CONFIG_PATH` setzen:
   ```bash
   export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH
   ```

### Kompilierungsfehler

Wenn Kompilierungsfehler auftreten:

1. Stellen Sie sicher, dass Sie einen C11-kompatiblen Compiler haben
2. Unter macOS versuchen Sie Clang (Standard):
   ```bash
   make CC=clang
   ```
3. Unter Linux versuchen Sie GCC:
   ```bash
   make CC=gcc
   ```
4. √úberpr√ºfen Sie, ob alle Abh√§ngigkeiten installiert sind
5. Versuchen Sie, von Grund auf neu zu kompilieren:
   ```bash
   make clean && make
   ```

### Testfehler

Wenn Tests fehlschlagen:

1. Stellen Sie sicher, dass Sie die neueste Version des Codes haben
2. Versuchen Sie, von Grund auf neu zu kompilieren:
   ```bash
   make clean && make test
   ```
3. Unter macOS stellen Sie sicher, dass Sie die neuesten Xcode Command Line Tools haben:
   ```bash
   xcode-select --install
   ```
4. Melden Sie das Problem auf GitHub mit:
   - Ihrer Plattform (macOS-Version / Linux-Distribution)
   - Architektur (x86_64 / arm64)
   - Testausgabe
   - Ausgabe von `make -v` und `gcc --version` (oder `clang --version`)

## N√§chste Schritte

- [Schnellstart-Anleitung](#getting-started-quick-start) - Schreiben Sie Ihr erstes Hemlock-Programm
- [Tutorial](#getting-started-tutorial) - Lernen Sie Hemlock Schritt f√ºr Schritt
- [Sprachhandbuch](#language-guide-syntax) - Entdecken Sie Hemlock-Funktionen


--------------------------------------------------------------------------------
## Lernpfade
--------------------------------------------------------------------------------

# Lernpfade

Verschiedene Ziele erfordern unterschiedliches Wissen. W√§hlen Sie den Pfad, der zu dem passt, was Sie erstellen m√∂chten.

---

## Pfad 1: Schnelle Skripte & Automatisierung

**Ziel:** Skripte schreiben, um Aufgaben zu automatisieren, Dateien zu verarbeiten und Dinge zu erledigen.

**Zeit bis zur Produktivit√§t:** Schnell - Sie k√∂nnen sofort mit dem Schreiben n√ºtzlicher Skripte beginnen.

### Was Sie lernen werden

1. **[Schnellstart](#getting-started-quick-start)** - Ihr erstes Programm, grundlegende Syntax
2. **[Zeichenketten](#language-guide-strings)** - Textverarbeitung, Aufteilen, Suchen
3. **[Arrays](#language-guide-arrays)** - Listen, Filtern, Daten transformieren
4. **[Datei-I/O](#advanced-file-io)** - Dateien lesen und schreiben
5. **[Kommandozeilenargumente](#advanced-command-line-args)** - Eingaben von Benutzern erhalten

### Vorerst √ºberspringen

- Speicherverwaltung (automatisch f√ºr Skripte)
- Async/Nebenl√§ufigkeit (√ºbertrieben f√ºr einfache Skripte)
- FFI (nur f√ºr C-Interop ben√∂tigt)

### Beispielprojekt: Datei-Umbenenner

```hemlock
import { list_dir, rename } from "@stdlib/fs";

// Alle .txt-Dateien in .md umbenennen
let files = list_dir(".");
for (file in files) {
    if (file.ends_with(".txt")) {
        let new_name = file.replace(".txt", ".md");
        rename(file, new_name);
        print(`Umbenannt: ${file} -> ${new_name}`);
    }
}
```

---

## Pfad 2: Datenverarbeitung & Analyse

**Ziel:** Daten parsen, transformieren, Berichte generieren.

**Zeit bis zur Produktivit√§t:** Schnell - Hemlocks String- und Array-Methoden machen dies einfach.

### Was Sie lernen werden

1. **[Schnellstart](#getting-started-quick-start)** - Grundlagen
2. **[Zeichenketten](#language-guide-strings)** - Parsen, Aufteilen, Formatieren
3. **[Arrays](#language-guide-arrays)** - map, filter, reduce f√ºr Datentransformation
4. **[Objekte](#language-guide-objects)** - Strukturierte Daten
5. **Standardbibliothek:**
   - **[@stdlib/json](#stdlib-json)** - JSON-Parsing
   - **[@stdlib/csv](#stdlib-csv)** - CSV-Dateien
   - **[@stdlib/fs](#stdlib-fs)** - Dateioperationen

### Beispielprojekt: CSV-Analysator

```hemlock
import { read_file } from "@stdlib/fs";
import { parse } from "@stdlib/csv";

let data = parse(read_file("sales.csv"));

// Gesamtumsatz berechnen
let total = 0;
for (row in data) {
    total = total + f64(row.amount);
}

print(`Gesamtumsatz: ${total}‚Ç¨`);

// Top-Verk√§ufer finden
let top = data[0];
for (row in data) {
    if (f64(row.amount) > f64(top.amount)) {
        top = row;
    }
}

print(`Top-Verkauf: ${top.product} - ${top.amount}‚Ç¨`);
```

---

## Pfad 3: Web- & Netzwerkprogrammierung

**Ziel:** HTTP-Clients erstellen, mit APIs arbeiten, Server erstellen.

**Zeit bis zur Produktivit√§t:** Mittel - erfordert Verst√§ndnis der Async-Grundlagen.

### Was Sie lernen werden

1. **[Schnellstart](#getting-started-quick-start)** - Grundlagen
2. **[Funktionen](#language-guide-functions)** - Callbacks und Closures
3. **[Fehlerbehandlung](#language-guide-error-handling)** - try/catch f√ºr Netzwerkfehler
4. **[Async & Nebenl√§ufigkeit](#advanced-async-concurrency)** - spawn, await, Channels
5. **Standardbibliothek:**
   - **[@stdlib/http](#stdlib-http)** - HTTP-Anfragen
   - **[@stdlib/json](#stdlib-json)** - JSON f√ºr APIs
   - **[@stdlib/net](#stdlib-net)** - TCP/UDP-Sockets
   - **[@stdlib/url](#stdlib-url)** - URL-Parsing

### Beispielprojekt: API-Client

```hemlock
import { http_get, http_post } from "@stdlib/http";
import { parse, stringify } from "@stdlib/json";

// GET-Anfrage
let response = http_get("https://api.example.com/users");
let users = parse(response.body);

for (user in users) {
    print(`${user.name}: ${user.email}`);
}

// POST-Anfrage
let new_user = { name: "Alice", email: "alice@example.com" };
let result = http_post("https://api.example.com/users", {
    body: stringify(new_user),
    headers: { "Content-Type": "application/json" }
});

print(`Benutzer erstellt mit ID: ${parse(result.body).id}`);
```

---

## Pfad 4: Systemprogrammierung

**Ziel:** Low-Level-Code schreiben, mit Speicher arbeiten, mit C-Bibliotheken interagieren.

**Zeit bis zur Produktivit√§t:** L√§nger - erfordert Verst√§ndnis der Speicherverwaltung.

### Was Sie lernen werden

1. **[Schnellstart](#getting-started-quick-start)** - Grundlagen
2. **[Typen](#language-guide-types)** - i32, u8, ptr usw. verstehen
3. **[Speicherverwaltung](#language-guide-memory)** - alloc, free, Puffer
4. **[FFI](#advanced-ffi)** - C-Funktionen aufrufen
5. **[Signale](#advanced-signals)** - Signalverarbeitung

### Schl√ºsselkonzepte

**Speichersicherheits-Checkliste:**
- [ ] Jedes `alloc()` hat ein entsprechendes `free()`
- [ ] `buffer()` verwenden, es sei denn, Sie ben√∂tigen rohe `ptr`
- [ ] Zeiger nach dem Freigeben auf `null` setzen
- [ ] `try/finally` verwenden, um Bereinigung zu garantieren

**Typ-Mapping f√ºr FFI:**
| Hemlock | C |
|---------|---|
| `i8` | `char` / `int8_t` |
| `i32` | `int` |
| `i64` | `long` (64-Bit) |
| `u8` | `unsigned char` |
| `f64` | `double` |
| `ptr` | `void*` |

### Beispielprojekt: Benutzerdefinierter Speicherpool

```hemlock
// Einfacher Bump-Allocator
let pool_size = 1024 * 1024;  // 1MB
let pool = alloc(pool_size);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > pool_size) {
        throw "Pool ersch√∂pft";
    }
    let p = pool + pool_offset;
    pool_offset = pool_offset + size;
    return p;
}

fn pool_reset() {
    pool_offset = 0;
}

fn pool_destroy() {
    free(pool);
}

// Verwenden
let a = pool_alloc(100);
let b = pool_alloc(200);
memset(a, 0, 100);
memset(b, 0, 200);

pool_reset();  // Gesamten Speicher wiederverwenden
pool_destroy();  // Aufr√§umen
```

---

## Pfad 5: Parallele & Nebenl√§ufige Programme

**Ziel:** Code auf mehreren CPU-Kernen ausf√ºhren, reaktionsf√§hige Anwendungen erstellen.

**Zeit bis zur Produktivit√§t:** Mittel - Async-Syntax ist unkompliziert, aber das Nachdenken √ºber Parallelit√§t erfordert √úbung.

### Was Sie lernen werden

1. **[Schnellstart](#getting-started-quick-start)** - Grundlagen
2. **[Funktionen](#language-guide-functions)** - Closures (wichtig f√ºr Async)
3. **[Async & Nebenl√§ufigkeit](#advanced-async-concurrency)** - Vollst√§ndiger Tiefgang
4. **[Atomics](#advanced-atomics)** - Lock-freie Programmierung

### Schl√ºsselkonzepte

**Hemlocks Async-Modell:**
- `async fn` - Definiert eine Funktion, die auf einem anderen Thread laufen kann
- `spawn(fn, args...)` - Startet die Ausf√ºhrung, gibt ein Task-Handle zur√ºck
- `join(task)` oder `await task` - Warten auf Fertigstellung, Ergebnis abrufen
- `channel(size)` - Warteschlange zum Senden von Daten zwischen Tasks erstellen

**Wichtig:** Tasks erhalten *Kopien* von Werten. Wenn Sie einen Zeiger √ºbergeben, sind Sie daf√ºr verantwortlich, sicherzustellen, dass der Speicher g√ºltig bleibt, bis der Task abgeschlossen ist.

### Beispielprojekt: Paralleler Dateiprozessor

```hemlock
import { list_dir, read_file } from "@stdlib/fs";

async fn process_file(path: string): i32 {
    let content = read_file(path);
    let lines = content.split("\n");
    return lines.length;
}

// Alle Dateien parallel verarbeiten
let files = list_dir("data/");
let tasks = [];

for (file in files) {
    if (file.ends_with(".txt")) {
        let task = spawn(process_file, "data/" + file);
        tasks.push({ name: file, task: task });
    }
}

// Ergebnisse sammeln
let total_lines = 0;
for (item in tasks) {
    let count = join(item.task);
    print(`${item.name}: ${count} Zeilen`);
    total_lines = total_lines + count;
}

print(`Gesamt: ${total_lines} Zeilen`);
```

---

## Was zuerst lernen (Jeder Pfad)

Egal welches Ziel, beginnen Sie mit diesen Grundlagen:

### Woche 1: Kerngrundlagen
1. **[Schnellstart](#getting-started-quick-start)** - Schreiben und f√ºhren Sie Ihr erstes Programm aus
2. **[Syntax](#language-guide-syntax)** - Variablen, Operatoren, Kontrollfluss
3. **[Funktionen](#language-guide-functions)** - Funktionen definieren und aufrufen

### Woche 2: Datenverarbeitung
4. **[Zeichenketten](#language-guide-strings)** - Textmanipulation
5. **[Arrays](#language-guide-arrays)** - Sammlungen und Iteration
6. **[Objekte](#language-guide-objects)** - Strukturierte Daten

### Woche 3: Robustheit
7. **[Fehlerbehandlung](#language-guide-error-handling)** - try/catch/throw
8. **[Module](#language-guide-modules)** - Import/Export, Stdlib verwenden

### Dann: W√§hlen Sie Ihren Pfad oben

---

## Spickzettel: Kommend von anderen Sprachen

### Von Python

| Python | Hemlock | Hinweise |
|--------|---------|----------|
| `x = 42` | `let x = 42;` | Semikolons erforderlich |
| `def fn():` | `fn name() { }` | Geschweifte Klammern erforderlich |
| `if x:` | `if (x) { }` | Klammern und geschweifte Klammern erforderlich |
| `for i in range(10):` | `for (let i = 0; i < 10; i++) { }` | C-√§hnliche For-Schleifen |
| `for item in list:` | `for (item in array) { }` | For-in funktioniert gleich |
| `list.append(x)` | `array.push(x);` | Anderer Methodenname |
| `len(s)` | `s.length` oder `len(s)` | Beides funktioniert |
| Automatischer Speicher | Manuell f√ºr `ptr` | Die meisten Typen r√§umen automatisch auf |

### Von JavaScript

| JavaScript | Hemlock | Hinweise |
|------------|---------|----------|
| `let x = 42` | `let x = 42;` | Gleich (Semikolons erforderlich) |
| `const x = 42` | `let x = 42;` | Kein const-Schl√ºsselwort |
| `function fn()` | `fn name() { }` | Anderes Schl√ºsselwort |
| `() => x` | `fn() { return x; }` | Keine Pfeilfunktionen |
| `async/await` | `async/await` | Gleiche Syntax |
| `Promise` | `spawn/join` | Anderes Modell |
| Automatische GC | Manuell f√ºr `ptr` | Die meisten Typen r√§umen automatisch auf |

### Von C/C++

| C | Hemlock | Hinweise |
|---|---------|----------|
| `int x = 42;` | `let x: i32 = 42;` | Typ nach Doppelpunkt |
| `malloc(n)` | `alloc(n)` | Gleiches Konzept |
| `free(p)` | `free(p)` | Gleich |
| `char* s = "hi"` | `let s = "hi";` | Strings werden verwaltet |
| `#include` | `import { } from` | Modul-Imports |
| Manuell f√ºr alles | Auto f√ºr die meisten Typen | Nur `ptr` braucht manuell |

---

## Hilfe erhalten

- **[Glossar](../glossary.md)** - Definitionen von Programmierbegriffen
- **[Beispiele](../../examples/)** - Vollst√§ndige funktionierende Programme
- **[Tests](../../tests/)** - Sehen Sie, wie Funktionen verwendet werden
- **GitHub Issues** - Fragen stellen, Fehler melden

---

## Schwierigkeitsstufen

In der gesamten Dokumentation sehen Sie diese Markierungen:

| Markierung | Bedeutung |
|------------|-----------|
| **Anf√§nger** | Keine vorherige Programmiererfahrung erforderlich |
| **Fortgeschritten** | Setzt grundlegende Programmierkenntnisse voraus |
| **Experte** | Erfordert Verst√§ndnis von Systemkonzepten |

Wenn Sie etwas, das als "Anf√§nger" markiert ist, verwirrt, schauen Sie im [Glossar](../glossary.md) nach Begriffsdefinitionen.


--------------------------------------------------------------------------------
## Schnellstart
--------------------------------------------------------------------------------

# Schnellstart

Starten Sie mit Hemlock in wenigen Minuten!

## Ihr erstes Programm

Erstellen Sie eine Datei namens `hello.hml`:

```hemlock
print("Hallo, Hemlock!");
```

F√ºhren Sie es mit dem Interpreter aus:

```bash
./hemlock hello.hml
```

Oder kompilieren Sie es zu einer nativen ausf√ºhrbaren Datei:

```bash
./hemlockc hello.hml -o hello
./hello
```

Ausgabe:
```
Hallo, Hemlock!
```

### Interpreter vs. Compiler

Hemlock bietet zwei M√∂glichkeiten, Programme auszuf√ºhren:

| Werkzeug | Anwendungsfall | Typpr√ºfung |
|----------|----------------|------------|
| `hemlock` | Schnelle Skripte, REPL, Entwicklung | Nur zur Laufzeit |
| `hemlockc` | Produktionsbin√§rdateien, bessere Leistung | Zur Kompilierzeit (Standard) |

Der Compiler (`hemlockc`) pr√ºft Ihren Code auf Typfehler, bevor er eine ausf√ºhrbare Datei generiert, und erkennt Fehler fr√ºhzeitig.

## Grundlegende Syntax

### Variablen

```hemlock
// Variablen werden mit 'let' deklariert
let x = 42;
let name = "Alice";
let pi = 3.14159;

// Typannotationen sind optional
let count: i32 = 100;
let ratio: f64 = 0.618;
```

**Wichtig**: Semikolons sind in Hemlock **obligatorisch**!

### Typen

Hemlock hat ein reichhaltiges Typsystem:

```hemlock
// Ganzzahlen
let small: i8 = 127;          // 8-Bit mit Vorzeichen
let byte: u8 = 255;           // 8-Bit ohne Vorzeichen
let num: i32 = 2147483647;    // 32-Bit mit Vorzeichen (Standard)
let big: i64 = 9223372036854775807;  // 64-Bit mit Vorzeichen

// Gleitkommazahlen
let f: f32 = 3.14;            // 32-Bit Gleitkomma
let d: f64 = 2.71828;         // 64-Bit Gleitkomma (Standard)

// Zeichenketten und Zeichen
let text: string = "Hallo";   // UTF-8-Zeichenkette
let emoji: rune = 'üöÄ';       // Unicode-Codepunkt

// Boolean und null
let flag: bool = true;
let empty = null;
```

### Kontrollfluss

```hemlock
// If-Anweisungen
if (x > 0) {
    print("positiv");
} else if (x < 0) {
    print("negativ");
} else {
    print("null");
}

// While-Schleifen
let i = 0;
while (i < 5) {
    print(i);
    i = i + 1;
}

// For-Schleifen
for (let j = 0; j < 10; j = j + 1) {
    print(j);
}
```

### Funktionen

```hemlock
// Benannte Funktion
fn add(a: i32, b: i32): i32 {
    return a + b;
}

let result = add(5, 3);  // 8

// Anonyme Funktion
let multiply = fn(x, y) {
    return x * y;
};

print(multiply(4, 7));  // 28
```

## Mit Zeichenketten arbeiten

Zeichenketten in Hemlock sind **ver√§nderbar** und **UTF-8**:

```hemlock
let s = "hallo";
s[0] = 'H';              // Jetzt "Hallo"
print(s);

// Zeichenketten-Methoden
let upper = s.to_upper();     // "HALLO"
let words = "a,b,c".split(","); // ["a", "b", "c"]
let sub = s.substr(1, 3);     // "all"

// Verkettung
let greeting = "Hallo" + ", " + "Welt!";
print(greeting);  // "Hallo, Welt!"
```

## Arrays

Dynamische Arrays mit gemischten Typen:

```hemlock
let numbers = [1, 2, 3, 4, 5];
print(numbers[0]);      // 1
print(numbers.length);  // 5

// Array-Methoden
numbers.push(6);        // [1, 2, 3, 4, 5, 6]
let last = numbers.pop();  // 6
let slice = numbers.slice(1, 4);  // [2, 3, 4]

// Gemischte Typen erlaubt
let mixed = [1, "zwei", true, null];
```

## Objekte

JavaScript-√§hnliche Objekte:

```hemlock
// Objekt-Literal
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};

print(person.name);  // "Alice"
person.age = 31;     // Feld √§ndern

// Methoden mit 'self'
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    }
};

counter.increment();
print(counter.count);  // 1
```

## Speicherverwaltung

Hemlock verwendet **manuelle Speicherverwaltung**:

```hemlock
// Sicherer Puffer (empfohlen)
let buf = buffer(64);   // 64 Bytes allokieren
buf[0] = 65;            // Erstes Byte auf 'A' setzen
print(buf[0]);          // 65
free(buf);              // Speicher freigeben

// Roher Zeiger (fortgeschritten)
let ptr = alloc(100);
memset(ptr, 0, 100);    // Mit Nullen f√ºllen
free(ptr);
```

**Wichtig**: Sie m√ºssen `free()` aufrufen, was Sie `alloc()`iert haben!

## Fehlerbehandlung

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "Division durch Null";
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    print(result);
} catch (e) {
    print("Fehler: " + e);
} finally {
    print("Fertig");
}
```

## Kommandozeilenargumente

Zugriff auf Programmargumente √ºber das `args`-Array:

```hemlock
// script.hml
print("Skript:", args[0]);
print(`Argumente: ${args.length - 1}`);

let i = 1;
while (i < args.length) {
    print(`  arg ${i}: ${args[i]}`);
    i = i + 1;
}
```

Ausf√ºhren mit:
```bash
./hemlock script.hml hallo welt
```

Ausgabe:
```
Skript: script.hml
Argumente: 2
  arg 1: hallo
  arg 2: welt
```

## Datei-I/O

```hemlock
// In Datei schreiben
let f = open("daten.txt", "w");
f.write("Hallo, Datei!");
f.close();

// Aus Datei lesen
let f2 = open("daten.txt", "r");
let content = f2.read();
print(content);  // "Hallo, Datei!"
f2.close();
```

## Was kommt als N√§chstes?

Nachdem Sie nun die Grundlagen gesehen haben, erkunden Sie mehr:

- [Tutorial](#getting-started-tutorial) - Umfassende Schritt-f√ºr-Schritt-Anleitung
- [Sprachhandbuch](#language-guide-syntax) - Tiefer Einblick in alle Funktionen
- [Beispiele](../../examples/) - Praxisnahe Beispielprogramme
- [API-Referenz](#reference-builtins) - Vollst√§ndige API-Dokumentation

## H√§ufige Fallstricke

### Semikolons vergessen

```hemlock
// ‚ùå FEHLER: Semikolon fehlt
let x = 42
let y = 10

// ‚úÖ KORREKT
let x = 42;
let y = 10;
```

### Speicherfreigabe vergessen

```hemlock
// ‚ùå SPEICHERLECK
let buf = buffer(100);
// ... buf verwenden ...
// Vergessen, free(buf) aufzurufen!

// ‚úÖ KORREKT
let buf = buffer(100);
// ... buf verwenden ...
free(buf);
```

### Geschweifte Klammern sind erforderlich

```hemlock
// ‚ùå FEHLER: Geschweifte Klammern fehlen
if (x > 0)
    print("positiv");

// ‚úÖ KORREKT
if (x > 0) {
    print("positiv");
}
```

## Hilfe erhalten

- Lesen Sie die [vollst√§ndige Dokumentation](../README.md)
- Schauen Sie sich das [Beispielverzeichnis](../../examples/) an
- Betrachten Sie [Testdateien](../../tests/) f√ºr Verwendungsmuster
- Melden Sie Probleme auf GitHub


--------------------------------------------------------------------------------
## Tutorial
--------------------------------------------------------------------------------

# Hemlock Tutorial

Eine umfassende Schritt-f√ºr-Schritt-Anleitung zum Erlernen von Hemlock.

## Inhaltsverzeichnis

1. [Hallo Welt](#hallo-welt)
2. [Variablen und Typen](#variablen-und-typen)
3. [Arithmetik und Operationen](#arithmetik-und-operationen)
4. [Kontrollfluss](#kontrollfluss)
5. [Funktionen](#funktionen)
6. [Zeichenketten und Runen](#zeichenketten-und-runen)
7. [Arrays](#arrays)
8. [Objekte](#objekte)
9. [Speicherverwaltung](#speicherverwaltung)
10. [Fehlerbehandlung](#fehlerbehandlung)
11. [Datei-I/O](#datei-io)
12. [Alles zusammenf√ºgen](#alles-zusammenf√ºgen)

## Hallo Welt

Beginnen wir mit dem traditionellen ersten Programm:

```hemlock
print("Hallo, Welt!");
```

Speichern Sie dies als `hello.hml` und f√ºhren Sie es aus:

```bash
./hemlock hello.hml
```

**Wichtige Punkte:**
- `print()` ist eine eingebaute Funktion, die auf stdout ausgibt
- Zeichenketten werden in doppelte Anf√ºhrungszeichen eingeschlossen
- Semikolons sind **obligatorisch**

## Variablen und Typen

### Variablen deklarieren

```hemlock
// Einfache Variablendeklaration
let x = 42;
let name = "Alice";
let pi = 3.14159;

print(x);      // 42
print(name);   // Alice
print(pi);     // 3.14159
```

### Typannotationen

W√§hrend Typen standardm√§√üig abgeleitet werden, k√∂nnen Sie explizit sein:

```hemlock
let age: i32 = 30;
let height: f64 = 5.9;
let initial: rune = 'A';
let active: bool = true;
```

### Typinferenz

Hemlock leitet Typen basierend auf Werten ab:

```hemlock
let small = 42;              // i32 (passt in 32-Bit)
let large = 5000000000;      // i64 (zu gro√ü f√ºr i32)
let decimal = 3.14;          // f64 (Standard f√ºr Gleitkomma)
let text = "hallo";          // string
let flag = true;             // bool
```

### Typpr√ºfung

```hemlock
// Typen mit typeof() pr√ºfen
print(typeof(42));        // "i32"
print(typeof(3.14));      // "f64"
print(typeof("hallo"));   // "string"
print(typeof(true));      // "bool"
print(typeof(null));      // "null"
```

## Arithmetik und Operationen

### Grundlegende Arithmetik

```hemlock
let a = 10;
let b = 3;

print(a + b);   // 13
print(a - b);   // 7
print(a * b);   // 30
print(a / b);   // 3 (Ganzzahldivision)
print(a == b);  // false
print(a > b);   // true
```

### Typpromotion

Beim Mischen von Typen f√∂rdert Hemlock zum gr√∂√üeren/genaueren Typ:

```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // result ist f64 (10.0 + 3.5 = 13.5)

print(result);       // 13.5
print(typeof(result)); // "f64"
```

### Bitweise Operationen

```hemlock
let a = 12;  // 1100 in Bin√§r
let b = 10;  // 1010 in Bin√§r

print(a & b);   // 8  (UND)
print(a | b);   // 14 (ODER)
print(a ^ b);   // 6  (XOR)
print(a << 1);  // 24 (Linksverschiebung)
print(a >> 1);  // 6  (Rechtsverschiebung)
print(~a);      // -13 (NICHT)
```

## Kontrollfluss

### If-Anweisungen

```hemlock
let x = 10;

if (x > 0) {
    print("positiv");
} else if (x < 0) {
    print("negativ");
} else {
    print("null");
}
```

**Hinweis:** Geschweifte Klammern sind **immer erforderlich**, auch f√ºr einzelne Anweisungen.

### While-Schleifen

```hemlock
let count = 0;
while (count < 5) {
    print(`Z√§hler: ${count}`);
    count = count + 1;
}
```

### For-Schleifen

```hemlock
// C-√§hnliche For-Schleife
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}

// For-in-Schleife (Arrays)
let items = [10, 20, 30, 40];
for (let item in items) {
    print(`Element: ${item}`);
}
```

### Switch-Anweisungen

```hemlock
let day = 3;

switch (day) {
    case 1:
        print("Montag");
        break;
    case 2:
        print("Dienstag");
        break;
    case 3:
        print("Mittwoch");
        break;
    default:
        print("Anderer Tag");
        break;
}
```

### Break und Continue

```hemlock
// Break: Schleife vorzeitig verlassen
let i = 0;
while (i < 10) {
    if (i == 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// Gibt aus: 0, 1, 2, 3, 4

// Continue: zur n√§chsten Iteration springen
for (let j = 0; j < 5; j = j + 1) {
    if (j == 2) {
        continue;
    }
    print(j);
}
// Gibt aus: 0, 1, 3, 4
```

## Funktionen

### Benannte Funktionen

```hemlock
fn greet(name: string): string {
    return "Hallo, " + name + "!";
}

let message = greet("Alice");
print(message);  // "Hallo, Alice!"
```

### Anonyme Funktionen

```hemlock
let add = fn(a, b) {
    return a + b;
};

print(add(5, 3));  // 8
```

### Rekursion

```hemlock
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

print(factorial(5));  // 120
```

### Closures

Funktionen erfassen ihre Umgebung:

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
print(counter());  // 3
```

### Funktionen h√∂herer Ordnung

```hemlock
fn apply(f, x) {
    return f(x);
}

fn double(n) {
    return n * 2;
}

let result = apply(double, 21);
print(result);  // 42
```

## Zeichenketten und Runen

### Grundlagen von Zeichenketten

Zeichenketten sind **ver√§nderbar** und **UTF-8**:

```hemlock
let s = "hallo";
print(s.length);      // 5 (Zeichenanzahl)
print(s.byte_length); // 5 (Byteanzahl)

// Ver√§nderung
s[0] = 'H';
print(s);  // "Hallo"
```

### Zeichenketten-Methoden

```hemlock
let text = "  Hallo, Welt!  ";

// Gro√ü-/Kleinschreibung
print(text.to_upper());  // "  HALLO, WELT!  "
print(text.to_lower());  // "  hallo, welt!  "

// Trimmen
print(text.trim());      // "Hallo, Welt!"

// Teilstring-Extraktion
let hello = text.substr(2, 5);  // "Hallo"
let world = text.slice(9, 13);  // "Welt"

// Suchen
let pos = text.find("Welt");    // 9
let has = text.contains("o");   // true

// Aufteilen
let parts = "a,b,c".split(","); // ["a", "b", "c"]

// Ersetzen
let s = "hallo welt".replace("welt", "dort");
print(s);  // "hallo dort"
```

### Runen (Unicode-Codepunkte)

```hemlock
let ch: rune = 'A';
let emoji: rune = 'üöÄ';

print(ch);      // 'A'
print(emoji);   // U+1F680

// Rune + String-Verkettung
let msg = '>' + " Wichtig";
print(msg);  // "> Wichtig"

// Zwischen Rune und Integer konvertieren
let code: i32 = ch;     // 65 (ASCII-Code)
let r: rune = 128640;   // U+1F680 (üöÄ)
```

## Arrays

### Array-Grundlagen

```hemlock
let numbers = [1, 2, 3, 4, 5];
print(numbers[0]);      // 1
print(numbers.length);  // 5

// Elemente √§ndern
numbers[2] = 99;
print(numbers[2]);  // 99
```

### Array-Methoden

```hemlock
let arr = [10, 20, 30];

// Am Ende hinzuf√ºgen/entfernen
arr.push(40);           // [10, 20, 30, 40]
let last = arr.pop();   // 40, arr ist jetzt [10, 20, 30]

// Am Anfang hinzuf√ºgen/entfernen
arr.unshift(5);         // [5, 10, 20, 30]
let first = arr.shift(); // 5, arr ist jetzt [10, 20, 30]

// An Index einf√ºgen/entfernen
arr.insert(1, 15);      // [10, 15, 20, 30]
let removed = arr.remove(2);  // 20

// Suchen
let index = arr.find(15);     // 1
let has = arr.contains(10);   // true

// Slice
let slice = arr.slice(0, 2);  // [10, 15]

// Zu String verbinden
let text = arr.join(", ");    // "10, 15, 30"
```

### Iteration

```hemlock
let items = ["apfel", "banane", "kirsche"];

// For-in-Schleife
for (let item in items) {
    print(item);
}

// Manuelle Iteration
let i = 0;
while (i < items.length) {
    print(items[i]);
    i = i + 1;
}
```

## Objekte

### Objekt-Literale

```hemlock
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};

print(person.name);  // "Alice"
print(person.age);   // 30

// Felder hinzuf√ºgen/√§ndern
person.email = "alice@example.com";
person.age = 31;
```

### Methoden und `self`

```hemlock
let calculator = {
    value: 0,
    add: fn(x) {
        self.value = self.value + x;
    },
    get: fn() {
        return self.value;
    }
};

calculator.add(10);
calculator.add(5);
print(calculator.get());  // 15
```

### Typdefinitionen (Duck Typing)

```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,  // Optional mit Standard
}

let p = { name: "Bob", age: 25 };
let typed: Person = p;  // Duck Typing validiert Struktur

print(typeof(typed));   // "Person"
print(typed.active);    // true (Standard angewendet)
```

### JSON-Serialisierung

```hemlock
let obj = { x: 10, y: 20, name: "test" };

// Objekt zu JSON
let json = obj.serialize();
print(json);  // {"x":10,"y":20,"name":"test"}

// JSON zu Objekt
let restored = json.deserialize();
print(restored.name);  // "test"
```

## Speicherverwaltung

### Sichere Puffer (Empfohlen)

```hemlock
// Puffer allokieren
let buf = buffer(10);
print(buf.length);    // 10
print(buf.capacity);  // 10

// Werte setzen (mit Grenzpr√ºfung)
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

// Werte zugreifen
print(buf[0]);  // 65

// Muss freigegeben werden, wenn fertig
free(buf);
```

### Rohe Zeiger (Fortgeschritten)

```hemlock
// Rohen Speicher allokieren
let ptr = alloc(100);

// Mit Nullen f√ºllen
memset(ptr, 0, 100);

// Daten kopieren
let src = alloc(50);
memcpy(ptr, src, 50);

// Beide freigeben
free(src);
free(ptr);
```

### Speicherfunktionen

```hemlock
// Neu allokieren
let p = alloc(64);
p = realloc(p, 128);  // Auf 128 Bytes vergr√∂√üern
free(p);

// Typisierte Allokation (zuk√ºnftig)
// let arr = talloc(i32, 100);  // Array von 100 i32s
```

## Fehlerbehandlung

### Try/Catch

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "Division durch Null";
    }
    return a / b;
}

try {
    let result = divide(10, 0);
    print(result);
} catch (e) {
    print("Fehler: " + e);
}
// Ausgabe: Fehler: Division durch Null
```

### Finally-Block

```hemlock
let file = null;

try {
    file = open("daten.txt", "r");
    let content = file.read();
    print(content);
} catch (e) {
    print("Fehler: " + e);
} finally {
    // Wird immer ausgef√ºhrt
    if (file != null) {
        file.close();
    }
}
```

### Objekte werfen

```hemlock
try {
    throw { code: 404, message: "Nicht gefunden" };
} catch (e) {
    print(`Fehler ${e.code}: ${e.message}`);
}
// Ausgabe: Fehler 404: Nicht gefunden
```

### Panic (Nicht behebbare Fehler)

```hemlock
fn validate(x) {
    if (x < 0) {
        panic("x muss nicht-negativ sein");
    }
    return x * 2;
}

validate(-5);  // Programm beendet mit: panic: x muss nicht-negativ sein
```

## Datei-I/O

### Dateien lesen

```hemlock
// Ganze Datei lesen
let f = open("daten.txt", "r");
let content = f.read();
print(content);
f.close();

// Bestimmte Anzahl Bytes lesen
let f2 = open("daten.txt", "r");
let chunk = f2.read(100);  // 100 Bytes lesen
f2.close();
```

### Dateien schreiben

```hemlock
// Text schreiben
let f = open("ausgabe.txt", "w");
f.write("Hallo, Datei!\n");
f.write("Zweite Zeile\n");
f.close();

// An Datei anh√§ngen
let f2 = open("ausgabe.txt", "a");
f2.write("Angeh√§ngte Zeile\n");
f2.close();
```

### Bin√§r-I/O

```hemlock
// Bin√§rdaten schreiben
let buf = buffer(256);
buf[0] = 255;
buf[1] = 128;

let f = open("daten.bin", "w");
f.write_bytes(buf);
f.close();

// Bin√§rdaten lesen
let f2 = open("daten.bin", "r");
let data = f2.read_bytes(256);
print(data[0]);  // 255
f2.close();

free(buf);
free(data);
```

### Dateieigenschaften

```hemlock
let f = open("/pfad/zur/datei.txt", "r");

print(f.path);    // "/pfad/zur/datei.txt"
print(f.mode);    // "r"
print(f.closed);  // false

f.close();
print(f.closed);  // true
```

## Alles zusammenf√ºgen

Lassen Sie uns ein einfaches Wortz√§hler-Programm erstellen:

```hemlock
// wordcount.hml - W√∂rter in einer Datei z√§hlen

fn count_words(filename: string): i32 {
    let file = null;
    let count = 0;

    try {
        file = open(filename, "r");
        let content = file.read();

        // Nach Leerzeichen aufteilen und z√§hlen
        let words = content.split(" ");
        count = words.length;

    } catch (e) {
        print("Fehler beim Lesen der Datei: " + e);
        return -1;
    } finally {
        if (file != null) {
            file.close();
        }
    }

    return count;
}

// Hauptprogramm
if (args.length < 2) {
    print("Verwendung: " + args[0] + " <dateiname>");
} else {
    let filename = args[1];
    let words = count_words(filename);

    if (words >= 0) {
        print(`Wortanzahl: ${words}`);
    }
}
```

Ausf√ºhren mit:
```bash
./hemlock wordcount.hml daten.txt
```

## N√§chste Schritte

Herzlichen Gl√ºckwunsch! Sie haben die Grundlagen von Hemlock gelernt. Hier ist, was Sie als N√§chstes erkunden k√∂nnen:

- [Async & Nebenl√§ufigkeit](#advanced-async-concurrency) - Echtes Multi-Threading
- [FFI](#advanced-ffi) - C-Funktionen aufrufen
- [Signalverarbeitung](#advanced-signals) - Prozesssignale
- [API-Referenz](#reference-builtins) - Vollst√§ndige API-Dokumentation
- [Beispiele](../../examples/) - Weitere praxisnahe Programme

## √úbungsaufgaben

Versuchen Sie, diese Programme zu erstellen, um zu √ºben:

1. **Taschenrechner**: Implementieren Sie einen einfachen Rechner mit +, -, *, /
2. **Dateikopierer**: Kopieren Sie eine Datei in eine andere
3. **Fibonacci**: Generieren Sie Fibonacci-Zahlen
4. **JSON-Parser**: Lesen und parsen Sie JSON-Dateien
5. **Textprozessor**: Suchen und ersetzen Sie Text in Dateien

Viel Spa√ü beim Programmieren mit Hemlock! üöÄ



################################################################################
# SPRACHHANDBUCH
################################################################################

--------------------------------------------------------------------------------
## Arrays
--------------------------------------------------------------------------------

# Arrays

Hemlock bietet **dynamische Arrays** mit umfassenden Methoden zur Datenmanipulation und -verarbeitung. Arrays k√∂nnen gemischte Typen enthalten und wachsen bei Bedarf automatisch.

## √úbersicht

```hemlock
// Array-Literale
let arr = [1, 2, 3, 4, 5];
print(arr[0]);         // 1
print(arr.length);     // 5

// Gemischte Typen erlaubt
let mixed = [1, "hello", true, null];

// Dynamische Gr√∂√üenanpassung
arr.push(6);           // W√§chst automatisch
arr.push(7);
print(arr.length);     // 7
```

## Array-Literale

### Grundlegende Syntax

```hemlock
let numbers = [1, 2, 3, 4, 5];
let strings = ["apple", "banana", "cherry"];
let booleans = [true, false, true];
```

### Leere Arrays

```hemlock
let arr = [];  // Leeres Array

// Elemente sp√§ter hinzuf√ºgen
arr.push(1);
arr.push(2);
arr.push(3);
```

### Gemischte Typen

Arrays k√∂nnen verschiedene Typen enthalten:

```hemlock
let mixed = [
    42,
    "hello",
    true,
    null,
    [1, 2, 3],
    { x: 10, y: 20 }
];

print(mixed[0]);  // 42
print(mixed[1]);  // "hello"
print(mixed[4]);  // [1, 2, 3] (verschachteltes Array)
```

### Verschachtelte Arrays

```hemlock
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

print(matrix[0][0]);  // 1
print(matrix[1][2]);  // 6
print(matrix[2][1]);  // 8
```

### Typisierte Arrays

Arrays k√∂nnen Typannotationen haben, um Elementtypen zu erzwingen:

```hemlock
// Typisierte Array-Syntax
let nums: array<i32> = [1, 2, 3, 4, 5];
let names: array<string> = ["Alice", "Bob", "Carol"];
let flags: array<bool> = [true, false, true];

// Typ√ºberpr√ºfung zur Laufzeit
let valid: array<i32> = [1, 2, 3];       // OK
let invalid: array<i32> = [1, "two", 3]; // Laufzeitfehler: Typkonflikt

// Verschachtelte typisierte Arrays
let matrix: array<array<i32>> = [
    [1, 2, 3],
    [4, 5, 6]
];
```

**Typannotations-Verhalten:**
- Elemente werden beim Hinzuf√ºgen zum Array typ√ºberpr√ºft
- Typkonflikte verursachen Laufzeitfehler
- Ohne Typannotation akzeptieren Arrays gemischte Typen

## Indizierung

### Elemente lesen

Nullbasierter Zugriff:

```hemlock
let arr = [10, 20, 30, 40, 50];

print(arr[0]);  // 10 (erstes Element)
print(arr[4]);  // 50 (letztes Element)

// Zugriff au√üerhalb der Grenzen gibt null zur√ºck (kein Fehler)
print(arr[10]);  // null
```

### Elemente schreiben

```hemlock
let arr = [1, 2, 3];

arr[0] = 10;    // Bestehendes √§ndern
arr[1] = 20;
print(arr);     // [10, 20, 3]

// Kann √ºber aktuelle L√§nge hinaus zuweisen (Array w√§chst)
arr[5] = 60;    // Erstellt [10, 20, 3, null, null, 60]
```

### Negative Indizes

**Nicht unterst√ºtzt** - Verwende nur positive Indizes:

```hemlock
let arr = [1, 2, 3];
print(arr[-1]);  // FEHLER oder undefiniertes Verhalten

// Verwende length f√ºr letztes Element
print(arr[arr.length - 1]);  // 3
```

## Eigenschaften

### `.length`-Eigenschaft

Gibt die Anzahl der Elemente zur√ºck:

```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);  // 5

// Leeres Array
let empty = [];
print(empty.length);  // 0

// Nach √Ñnderungen
arr.push(6);
print(arr.length);  // 6
```

## Array-Methoden

Hemlock bietet 18 Array-Methoden f√ºr umfassende Manipulation.

### Stack-Operationen

**`push(value)`** - Element am Ende hinzuf√ºgen:
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]

print(arr.length);     // 5
```

**`pop()`** - Letztes Element entfernen und zur√ºckgeben:
```hemlock
let arr = [1, 2, 3, 4, 5];
let last = arr.pop();  // Gibt 5 zur√ºck, arr ist jetzt [1, 2, 3, 4]

print(last);           // 5
print(arr.length);     // 4
```

### Queue-Operationen

**`shift()`** - Erstes Element entfernen und zur√ºckgeben:
```hemlock
let arr = [1, 2, 3];
let first = arr.shift();   // Gibt 1 zur√ºck, arr ist jetzt [2, 3]

print(first);              // 1
print(arr);                // [2, 3]
```

**`unshift(value)`** - Element am Anfang hinzuf√ºgen:
```hemlock
let arr = [2, 3];
arr.unshift(1);            // [1, 2, 3]
arr.unshift(0);            // [0, 1, 2, 3]
```

### Einf√ºge- und Entfernungsoperationen

**`insert(index, value)`** - Element an Index einf√ºgen:
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // 3 an Index 2 einf√ºgen: [1, 2, 3, 4, 5]

arr.insert(0, 0);      // Am Anfang einf√ºgen: [0, 1, 2, 3, 4, 5]
```

**`remove(index)`** - Element an Index entfernen und zur√ºckgeben:
```hemlock
let arr = [1, 2, 3, 4, 5];
let removed = arr.remove(2);  // Gibt 3 zur√ºck, arr ist jetzt [1, 2, 4, 5]

print(removed);               // 3
print(arr);                   // [1, 2, 4, 5]
```

### Suchoperationen

**`find(value)`** - Erstes Vorkommen finden:
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2 (Index des ersten Vorkommens)
let idx2 = arr.find(99);     // -1 (nicht gefunden)

// Funktioniert mit jedem Typ
let words = ["apple", "banana", "cherry"];
let idx3 = words.find("banana");  // 1
```

**`contains(value)`** - Pr√ºfen ob Array Wert enth√§lt:
```hemlock
let arr = [10, 20, 30, 40];
let has = arr.contains(20);  // true
let has2 = arr.contains(99); // false
```

### Extraktionsoperationen

**`slice(start, end)`** - Teilarray extrahieren (Ende exklusiv):
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);   // [2, 3, 4] (Indizes 1, 2, 3)
let first = arr.slice(0, 2); // [1, 2]

// Original unver√§ndert
print(arr);                  // [1, 2, 3, 4, 5]
```

**`first()`** - Erstes Element holen (ohne Entfernen):
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1 (ohne Entfernen)
print(arr);                  // [1, 2, 3] (unver√§ndert)
```

**`last()`** - Letztes Element holen (ohne Entfernen):
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3 (ohne Entfernen)
print(arr);                  // [1, 2, 3] (unver√§ndert)
```

### Transformationsoperationen

**`reverse()`** - Array an Ort und Stelle umkehren:
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]

print(arr);                  // [5, 4, 3, 2, 1] (ge√§ndert)
```

**`join(delimiter)`** - Elemente zu String verbinden:
```hemlock
let words = ["hello", "world", "foo"];
let joined = words.join(" ");  // "hello world foo"

let numbers = [1, 2, 3];
let csv = numbers.join(",");   // "1,2,3"

// Funktioniert mit gemischten Typen
let mixed = [1, "hello", true, null];
print(mixed.join(" | "));  // "1 | hello | true | null"
```

**`concat(other)`** - Mit anderem Array verketten:
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combined = a.concat(b);  // [1, 2, 3, 4, 5, 6] (neues Array)

// Originale unver√§ndert
print(a);                    // [1, 2, 3]
print(b);                    // [4, 5, 6]
```

### Hilfsoperationen

**`clear()`** - Alle Elemente entfernen:
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();                 // []

print(arr.length);           // 0
print(arr);                  // []
```

## Methodenverkettung

Methoden, die Arrays oder Werte zur√ºckgeben, erm√∂glichen Verkettung:

```hemlock
let result = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);  // [3, 4, 5]

let text = ["apple", "banana", "cherry"]
    .slice(0, 2)
    .join(" and ");  // "apple and banana"

let numbers = [5, 3, 8, 1, 9]
    .slice(1, 4)
    .concat([10, 11]);  // [3, 8, 1, 10, 11]
```

## Vollst√§ndige Methodenreferenz

| Methode | Parameter | R√ºckgabe | Mutiert | Beschreibung |
|--------|-----------|---------|---------|-------------|
| `push(value)` | any | void | Ja | Element am Ende hinzuf√ºgen |
| `pop()` | - | any | Ja | Letztes entfernen und zur√ºckgeben |
| `shift()` | - | any | Ja | Erstes entfernen und zur√ºckgeben |
| `unshift(value)` | any | void | Ja | Element am Anfang hinzuf√ºgen |
| `insert(index, value)` | i32, any | void | Ja | An Index einf√ºgen |
| `remove(index)` | i32 | any | Ja | An Index entfernen und zur√ºckgeben |
| `find(value)` | any | i32 | Nein | Erstes Vorkommen finden (-1 wenn nicht gefunden) |
| `contains(value)` | any | bool | Nein | Pr√ºfen ob Wert enthalten |
| `slice(start, end)` | i32, i32 | array | Nein | Teilarray extrahieren (neues Array) |
| `join(delimiter)` | string | string | Nein | Zu String verbinden |
| `concat(other)` | array | array | Nein | Verketten (neues Array) |
| `reverse()` | - | void | Ja | An Ort und Stelle umkehren |
| `first()` | - | any | Nein | Erstes Element holen |
| `last()` | - | any | Nein | Letztes Element holen |
| `clear()` | - | void | Ja | Alle Elemente entfernen |
| `map(callback)` | fn | array | Nein | Jedes Element transformieren |
| `filter(predicate)` | fn | array | Nein | Passende Elemente ausw√§hlen |
| `reduce(callback, initial)` | fn, any | any | Nein | Auf einzelnen Wert reduzieren |

## Implementierungsdetails

### Speichermodell

- **Heap-allokiert** - Dynamische Kapazit√§t
- **Automatisches Wachstum** - Verdoppelt Kapazit√§t bei √úberschreitung
- **Kein automatisches Schrumpfen** - Kapazit√§t nimmt nicht ab
- **Keine Grenzpr√ºfung bei Indizierung** - Verwende Methoden f√ºr Sicherheit

### Kapazit√§tsverwaltung

```hemlock
let arr = [];  // Anfangskapazit√§t: 0

arr.push(1);   // W√§chst auf Kapazit√§t 1
arr.push(2);   // W√§chst auf Kapazit√§t 2
arr.push(3);   // W√§chst auf Kapazit√§t 4 (verdoppelt)
arr.push(4);   // Immer noch Kapazit√§t 4
arr.push(5);   // W√§chst auf Kapazit√§t 8 (verdoppelt)
```

### Wertvergleich

`find()` und `contains()` verwenden Wertgleichheit:

```hemlock
// Primitive: Vergleich nach Wert
let arr = [1, 2, 3];
arr.contains(2);  // true

// Strings: Vergleich nach Wert
let words = ["hello", "world"];
words.contains("hello");  // true

// Objekte: Vergleich nach Referenz
let obj1 = { x: 10 };
let obj2 = { x: 10 };
let arr2 = [obj1];
arr2.contains(obj1);  // true (gleiche Referenz)
arr2.contains(obj2);  // false (verschiedene Referenz)
```

## H√§ufige Muster

### Funktionale Operationen (map/filter/reduce)

Arrays haben eingebaute `map`, `filter` und `reduce` Methoden:

```hemlock
// map - jedes Element transformieren
let numbers = [1, 2, 3, 4, 5];
let doubled = numbers.map(fn(x) { return x * 2; });
print(doubled);  // [2, 4, 6, 8, 10]

// filter - passende Elemente ausw√§hlen
let evens = numbers.filter(fn(x) { return x % 2 == 0; });
print(evens);  // [2, 4]

// reduce - auf einzelnen Wert akkumulieren
let sum = numbers.reduce(fn(acc, x) { return acc + x; }, 0);
print(sum);  // 15

// Funktionale Operationen verketten
let result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    .filter(fn(x) { return x % 2 == 0; })  // [2, 4, 6, 8, 10]
    .map(fn(x) { return x * x; })          // [4, 16, 36, 64, 100]
    .reduce(fn(acc, x) { return acc + x; }, 0);  // 220
```

### Muster: Array als Stack

```hemlock
let stack = [];

// Auf Stack legen
stack.push(1);
stack.push(2);
stack.push(3);

// Vom Stack nehmen
let top = stack.pop();    // 3
let next = stack.pop();   // 2
```

### Muster: Array als Queue

```hemlock
let queue = [];

// Einreihen (am Ende hinzuf√ºgen)
queue.push(1);
queue.push(2);
queue.push(3);

// Ausreihen (vom Anfang entfernen)
let first = queue.shift();   // 1
let second = queue.shift();  // 2
```

## Best Practices

1. **Verwende Methoden statt direkter Indizierung** - Grenzpr√ºfung und Klarheit
2. **Pruefe Grenzen** - Direkte Indizierung pr√ºft keine Grenzen
3. **Bevorzuge unver√§nderliche Operationen** - Verwende `slice()` und `concat()` statt Mutation
4. **Initialisiere mit Kapazit√§t** - Wenn du die Gr√∂√üe kennst (derzeit nicht unterst√ºtzt)
5. **Verwende `contains()` f√ºr Zugeh√∂rigkeit** - Klarer als manuelle Schleifen
6. **Verkette Methoden** - Lesbarer als verschachtelte Aufrufe

## H√§ufige Fallstricke

### Fallstrick: Direkter Index au√üerhalb der Grenzen

```hemlock
let arr = [1, 2, 3];

// Keine Grenzpr√ºfung!
arr[10] = 99;  // Erstellt duenn besetztes Array mit nulls
print(arr.length);  // 11 (nicht 3!)

// Besser: Verwende push() oder pruefe L√§nge
if (arr.length <= 10) {
    arr.push(99);
}
```

### Fallstrick: Mutation vs. Neues Array

```hemlock
let arr = [1, 2, 3];

// Mutiert Original
arr.reverse();
print(arr);  // [3, 2, 1]

// Gibt neues Array zur√ºck
let sub = arr.slice(0, 2);
print(arr);  // [3, 2, 1] (unver√§ndert)
print(sub);  // [3, 2]
```

### Fallstrick: Referenzgleichheit

```hemlock
let obj = { x: 10 };
let arr = [obj];

// Gleiche Referenz: true
arr.contains(obj);  // true

// Verschiedene Referenz: false
arr.contains({ x: 10 });  // false (verschiedenes Objekt)
```

### Fallstrick: Langlebige Arrays

```hemlock
// Arrays im lokalen Scope werden automatisch freigegeben, aber globale/langlebige Arrays brauchen Aufmerksamkeit
let global_cache = [];  // Modulebene, existiert bis Programmende

fn add_to_cache(item) {
    global_cache.push(item);  // W√§chst unbegrenzt
}

// F√ºr langlebige Daten, erwaege:
// - Array periodisch leeren: global_cache.clear();
// - Frueh freigeben wenn fertig: free(global_cache);
```

## Beispiele

### Beispiel: Array-Statistiken

```hemlock
fn mean(arr) {
    let sum = 0;
    let i = 0;
    while (i < arr.length) {
        sum = sum + arr[i];
        i = i + 1;
    }
    return sum / arr.length;
}

fn max(arr) {
    if (arr.length == 0) {
        return null;
    }

    let max_val = arr[0];
    let i = 1;
    while (i < arr.length) {
        if (arr[i] > max_val) {
            max_val = arr[i];
        }
        i = i + 1;
    }
    return max_val;
}

let numbers = [3, 7, 2, 9, 1];
print(mean(numbers));  // 4.4
print(max(numbers));   // 9
```

### Beispiel: Array-Deduplizierung

```hemlock
fn unique(arr) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        if (!result.contains(arr[i])) {
            result.push(arr[i]);
        }
        i = i + 1;
    }
    return result;
}

let numbers = [1, 2, 2, 3, 1, 4, 3, 5];
let uniq = unique(numbers);  // [1, 2, 3, 4, 5]
```

### Beispiel: Array-Chunking

```hemlock
fn chunk(arr, size) {
    let result = [];
    let i = 0;

    while (i < arr.length) {
        let chunk = arr.slice(i, i + size);
        result.push(chunk);
        i = i + size;
    }

    return result;
}

let numbers = [1, 2, 3, 4, 5, 6, 7, 8];
let chunks = chunk(numbers, 3);
// [[1, 2, 3], [4, 5, 6], [7, 8]]
```

### Beispiel: Array-Flachung

```hemlock
fn flatten(arr) {
    let result = [];
    let i = 0;

    while (i < arr.length) {
        if (typeof(arr[i]) == "array") {
            // Verschachteltes Array - flach machen
            let nested = flatten(arr[i]);
            let j = 0;
            while (j < nested.length) {
                result.push(nested[j]);
                j = j + 1;
            }
        } else {
            result.push(arr[i]);
        }
        i = i + 1;
    }

    return result;
}

let nested = [1, [2, 3], [4, [5, 6]], 7];
let flat = flatten(nested);  // [1, 2, 3, 4, 5, 6, 7]
```

### Beispiel: Sortierung (Bubble Sort)

```hemlock
fn sort(arr) {
    let n = arr.length;
    let i = 0;

    while (i < n) {
        let j = 0;
        while (j < n - i - 1) {
            if (arr[j] > arr[j + 1]) {
                // Tauschen
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

let numbers = [5, 2, 8, 1, 9];
sort(numbers);  // Aendert an Ort und Stelle
print(numbers);  // [1, 2, 5, 8, 9]
```

## Einschr√§nkungen

Aktuelle Einschr√§nkungen:

- **Keine Grenzpr√ºfung bei Indizierung** - Direkter Zugriff ist ungepr√ºft
- **Referenzgleichheit f√ºr Objekte** - `find()` und `contains()` verwenden Referenzvergleich
- **Keine Array-Destrukturierung** - Keine `let [a, b] = arr` Syntax
- **Kein Spread-Operator** - Keine `[...arr1, ...arr2]` Syntax

**Hinweis:** Arrays sind referenzgez√§hlt und werden automatisch freigegeben, wenn der Scope endet. Siehe [Speicherverwaltung](memory.md#internal-reference-counting) f√ºr Details.

## Verwandte Themen

- [Strings](#language-guide-strings) - String-Methoden √§hnlich wie Array-Methoden
- [Objekte](#language-guide-objects) - Arrays sind auch objektaehnlich
- [Funktionen](#language-guide-functions) - H√∂here Ordnung Funktionen mit Arrays
- [Kontrollfluss](#language-guide-control-flow) - √úber Arrays iterieren

## Siehe auch

- **Dynamische Gr√∂√üenanpassung**: Arrays wachsen automatisch mit Kapazit√§tsverdopplung
- **Methoden**: 18 umfassende Methoden zur Manipulation inklusive map/filter/reduce
- **Speicher**: Siehe [Speicher](#language-guide-memory) f√ºr Array-Allokationsdetails


--------------------------------------------------------------------------------
## Fehlerbehandlung
--------------------------------------------------------------------------------

# Fehlerbehandlung

Hemlock unterst√ºtzt ausnahmebasierte Fehlerbehandlung mit `try`, `catch`, `finally`, `throw` und `panic`. Diese Anleitung behandelt behebbare Fehler mit Ausnahmen und nicht behebbare Fehler mit panic.

## √úberblick

```hemlock
// Grundlegende Fehlerbehandlung
try {
    risky_operation();
} catch (e) {
    print("Fehler: " + e);
}

// Mit Bereinigung
try {
    process_file();
} catch (e) {
    print("Fehlgeschlagen: " + e);
} finally {
    cleanup();
}

// Fehler werfen
fn divide(a, b) {
    if (b == 0) {
        throw "Division durch Null";
    }
    return a / b;
}
```

## Try-Catch-Finally

### Syntax

**Einfaches try/catch:**
```hemlock
try {
    // riskanter Code
} catch (e) {
    // Fehler behandeln, e enth√§lt den geworfenen Wert
}
```

**Try/finally:**
```hemlock
try {
    // riskanter Code
} finally {
    // wird immer ausgef√ºhrt, auch wenn Ausnahme geworfen
}
```

**Try/catch/finally:**
```hemlock
try {
    // riskanter Code
} catch (e) {
    // Fehler behandeln
} finally {
    // Bereinigungscode
}
```

### Try-Block

Der try-Block f√ºhrt Anweisungen sequentiell aus:

```hemlock
try {
    print("Starte...");
    risky_operation();
    print("Erfolg!");  // Nur wenn keine Ausnahme
}
```

**Verhalten:**
- Fuehrt Anweisungen der Reihe nach aus
- Wenn Ausnahme geworfen: springt zu `catch` oder `finally`
- Wenn keine Ausnahme: f√ºhrt `finally` aus (falls vorhanden), dann weiter

### Catch-Block

Der catch-Block empfaengt den geworfenen Wert:

```hemlock
try {
    throw "hoppla";
} catch (error) {
    print("Gefangen: " + error);  // error = "hoppla"
    // error nur hier zug√§nglich
}
// error hier nicht zug√§nglich
```

**Catch-Parameter:**
- Empfaengt den geworfenen Wert (beliebiger Typ)
- Auf den catch-Block beschr√§nkt
- Kann beliebig benannt werden (konventionell `e`, `err` oder `error`)

**Was Sie im catch tun k√∂nnen:**
```hemlock
try {
    risky_operation();
} catch (e) {
    // Fehler protokollieren
    print("Fehler: " + e);

    // Gleichen Fehler erneut werfen
    throw e;

    // Anderen Fehler werfen
    throw "anderer Fehler";

    // Standardwert zur√ºckgeben
    return null;

    // Behandeln und fortfahren
    // (kein erneutes Werfen)
}
```

### Finally-Block

Der finally-Block wird **immer ausgef√ºhrt**:

```hemlock
try {
    print("1: try-Block");
    throw "Fehler";
} catch (e) {
    print("2: catch-Block");
} finally {
    print("3: finally-Block");  // Wird immer ausgef√ºhrt
}
print("4: nach try/catch/finally");

// Ausgabe: 1: try-Block, 2: catch-Block, 3: finally-Block, 4: nach try/catch/finally
```

**Wann finally ausgef√ºhrt wird:**
- Nach dem try-Block (wenn keine Ausnahme)
- Nach dem catch-Block (wenn Ausnahme gefangen)
- Auch wenn try/catch `return`, `break` oder `continue` enth√§lt
- Bevor der Kontrollfluss try/catch verl√§sst

**Finally mit return:**
```hemlock
fn example() {
    try {
        return 1;  // Gibt 1 zur√ºck nach finally-Ausf√ºhrung
    } finally {
        print("bereinigung");  // Wird vor R√ºckgabe ausgef√ºhrt
    }
}

fn example2() {
    try {
        return 1;
    } finally {
        return 2;  // Finally-return √ºberschreibt - gibt 2 zur√ºck
    }
}
```

**Finally mit Kontrollfluss:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    try {
        if (i == 5) {
            break;  // Bricht nach finally-Ausf√ºhrung ab
        }
    } finally {
        print("bereinigung " + typeof(i));
    }
}
```

## Throw-Anweisung

### Einfaches Throw

Jeden Wert als Ausnahme werfen:

```hemlock
throw "Fehlermeldung";
throw 404;
throw { code: 500, message: "Interner Fehler" };
throw null;
throw ["fehler", "details"];
```

**Ausf√ºhrung:**
1. Wertet den Ausdruck aus
2. Springt sofort zum n√§chsten umschliessenden `catch`
3. Wenn kein `catch`, propagiert nach oben im Aufrufstapel

### Fehler werfen

```hemlock
fn validate_age(age: i32) {
    if (age < 0) {
        throw "Alter kann nicht negativ sein";
    }
    if (age > 150) {
        throw "Alter ist unrealistisch";
    }
}

try {
    validate_age(-5);
} catch (e) {
    print("Validierungsfehler: " + e);
}
```

### Fehlerobjekte werfen

Strukturierte Fehlerinformationen erstellen:

```hemlock
fn read_file(path: string) {
    if (!file_exists(path)) {
        throw {
            type: "FileNotFound",
            path: path,
            message: "Datei existiert nicht"
        };
    }
    // ... Datei lesen
}

try {
    read_file("missing.txt");
} catch (e) {
    if (e.type == "FileNotFound") {
        print("Datei nicht gefunden: " + e.path);
    }
}
```

### Erneutes Werfen

Fehler fangen und erneut werfen:

```hemlock
fn wrapper() {
    try {
        risky_operation();
    } catch (e) {
        print("Fehler protokollieren: " + e);
        throw e;  // An Aufrufer erneut werfen
    }
}

try {
    wrapper();
} catch (e) {
    print("In main gefangen: " + e);
}
```

## Nicht gefangene Ausnahmen

Wenn eine Ausnahme ohne gefangen zu werden bis zum Anfang des Aufrufstapels propagiert:

```hemlock
fn foo() {
    throw "nicht gefangen!";
}

foo();  // Stuerzt ab mit: Laufzeitfehler: nicht gefangen!
```

**Verhalten:**
- Programm stuerzt ab
- Gibt Fehlermeldung auf stderr aus
- Beendet mit nicht-null Statuscode
- Stack-Trace wird in zukuenftigen Versionen hinzugef√ºgt

## Panic - Nicht behebbare Fehler

### Was ist Panic?

`panic()` ist f√ºr **nicht behebbare Fehler**, die das Programm sofort beenden sollen:

```hemlock
panic();                    // Standardmeldung: "panic!"
panic("benutzerdefinierte Meldung");    // Benutzerdefinierte Meldung
panic(42);                  // Nicht-String-Werte werden ausgegeben
```

**Semantik:**
- **Beendet sofort** das Programm mit Exit-Code 1
- Gibt Fehlermeldung auf stderr aus: `panic: <meldung>`
- **NICHT fangbar** mit try/catch
- F√ºr Bugs und nicht behebbare Fehler verwenden

### Panic vs. Throw

```hemlock
// throw - Behebbarer Fehler (kann gefangen werden)
try {
    throw "behebbarer Fehler";
} catch (e) {
    print("Gefangen: " + e);  // Erfolgreich gefangen
}

// panic - Nicht behebbarer Fehler (kann nicht gefangen werden)
try {
    panic("nicht behebbarer Fehler");  // Programm beendet sofort
} catch (e) {
    print("Das wird nie ausgef√ºhrt");       // Wird nie ausgef√ºhrt
}
```

### Wann Panic verwenden

**Panic verwenden f√ºr:**
- **Bugs**: Unerreichbarer Code wurde erreicht
- **Ungueltiger Zustand**: Datenstrukturkorruption erkannt
- **Nicht behebbare Fehler**: Kritische Ressource nicht verf√ºgbar
- **Assertionsfehler**: Wenn `assert()` nicht ausreicht

**Beispiele:**
```hemlock
// Unerreichbarer Code
fn process_state(state: i32) {
    if (state == 1) {
        return "ready";
    } else if (state == 2) {
        return "running";
    } else if (state == 3) {
        return "stopped";
    } else {
        panic("ungueltiger Zustand: " + typeof(state));  // Sollte nie passieren
    }
}

// Kritische Ressourcenpruefung
fn init_system() {
    let config = read_file("config.json");
    if (config == null) {
        panic("config.json nicht gefunden - kann nicht starten");
    }
    // ...
}

// Datenstruktur-Invariante
fn pop_stack(stack) {
    if (stack.length == 0) {
        panic("pop() auf leerem Stack aufgerufen");
    }
    return stack.pop();
}
```

### Wann NICHT Panic verwenden

**Throw stattdessen verwenden f√ºr:**
- Benutzereingabe-Validierung
- Datei nicht gefunden
- Netzwerkfehler
- Erwartete Fehlerbedingungen

```hemlock
// SCHLECHT: Panic f√ºr erwartete Fehler
fn divide(a, b) {
    if (b == 0) {
        panic("Division durch Null");  // Zu hart
    }
    return a / b;
}

// GUT: Throw f√ºr erwartete Fehler
fn divide(a, b) {
    if (b == 0) {
        throw "Division durch Null";  // Behebbar
    }
    return a / b;
}
```

## Kontrollfluss-Interaktionen

### Return innerhalb Try/Catch/Finally

```hemlock
fn example() {
    try {
        return 1;  // Gibt 1 zur√ºck nach finally-Ausf√ºhrung
    } finally {
        print("bereinigung");
    }
}

fn example2() {
    try {
        return 1;
    } finally {
        return 2;  // Finally-return √ºberschreibt try-return - gibt 2 zur√ºck
    }
}
```

**Regel:** Finally-Block-Rueckgabewerte ueberschreiben try/catch-Rueckgabewerte.

### Break/Continue innerhalb Try/Catch/Finally

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    try {
        if (i == 5) { break; }  // Bricht nach finally-Ausf√ºhrung ab
    } finally {
        print("bereinigung " + typeof(i));
    }
}
```

**Regel:** Break/continue werden nach dem finally-Block ausgef√ºhrt.

### Verschachteltes Try/Catch

```hemlock
try {
    try {
        throw "inner";
    } catch (e) {
        print("Gefangen: " + e);  // Gibt aus: Gefangen: inner
        throw "outer";  // Anderen Fehler erneut werfen
    }
} catch (e) {
    print("Gefangen: " + e);  // Gibt aus: Gefangen: outer
}
```

**Regel:** Verschachtelte try/catch-Bl√∂cke funktionieren wie erwartet, innere catches geschehen zuerst.

## G√§ngige Muster

### Muster: Ressourcenbereinigung

Immer `finally` f√ºr Bereinigung verwenden:

```hemlock
fn process_file(filename) {
    let file = null;
    try {
        file = open(filename);
        let content = file.read();
        process(content);
    } catch (e) {
        print("Fehler beim Verarbeiten der Datei: " + e);
    } finally {
        if (file != null) {
            file.close();  // Schliesst immer, auch bei Fehler
        }
    }
}
```

### Muster: Fehler-Wrapping

Niedrigstufige Fehler mit Kontext umwickeln:

```hemlock
fn load_config(path) {
    try {
        let content = read_file(path);
        return parse_json(content);
    } catch (e) {
        throw "Fehler beim Laden der Konfiguration von " + path + ": " + e;
    }
}
```

### Muster: Fehlerwiederherstellung

Fallback bei Fehler bereitstellen:

```hemlock
fn safe_divide(a, b) {
    try {
        if (b == 0) {
            throw "Division durch Null";
        }
        return a / b;
    } catch (e) {
        print("Fehler: " + e);
        return null;  // Fallback-Wert
    }
}
```

### Muster: Validierung

Ausnahmen f√ºr Validierung verwenden:

```hemlock
fn validate_user(user) {
    if (user.name == null || user.name == "") {
        throw "Name ist erforderlich";
    }
    if (user.age < 0 || user.age > 150) {
        throw "Ungueltiges Alter";
    }
    if (user.email == null || !user.email.contains("@")) {
        throw "Ungueltige E-Mail";
    }
}

try {
    validate_user({ name: "Alice", age: -5, email: "ung√ºltig" });
} catch (e) {
    print("Validierung fehlgeschlagen: " + e);
}
```

### Muster: Mehrere Fehlertypen

Fehlerobjekte verwenden, um Fehlertypen zu unterscheiden:

```hemlock
fn process_data(data) {
    if (data == null) {
        throw { type: "NullData", message: "Daten sind null" };
    }

    if (typeof(data) != "array") {
        throw { type: "TypeError", message: "Array erwartet" };
    }

    if (data.length == 0) {
        throw { type: "EmptyData", message: "Array ist leer" };
    }

    // ... verarbeiten
}

try {
    process_data(null);
} catch (e) {
    if (e.type == "NullData") {
        print("Keine Daten bereitgestellt");
    } else if (e.type == "TypeError") {
        print("Falscher Datentyp: " + e.message);
    } else {
        print("Fehler: " + e.message);
    }
}
```

## Best Practices

1. **Ausnahmen f√ºr Ausnahmefaelle verwenden** - Nicht f√ºr normalen Kontrollfluss
2. **Aussagekraeftige Fehler werfen** - Strings oder Objekte mit Kontext verwenden
3. **Immer finally f√ºr Bereinigung verwenden** - Stellt sicher, dass Ressourcen freigegeben werden
4. **Nicht fangen und ignorieren** - Mindestens den Fehler protokollieren
5. **Bei Bedarf erneut werfen** - Aufrufer behandeln lassen, wenn Sie nicht k√∂nnen
6. **Panic f√ºr Bugs** - Panic f√ºr nicht behebbare Fehler verwenden
7. **Ausnahmen dokumentieren** - Klar machen, welche Funktionen werfen k√∂nnen

## H√§ufige Fallstricke

### Fallstrick: Fehler verschlucken

```hemlock
// SCHLECHT: Stilles Scheitern
try {
    risky_operation();
} catch (e) {
    // Fehler ignoriert - stilles Scheitern
}

// GUT: Protokollieren oder behandeln
try {
    risky_operation();
} catch (e) {
    print("Operation fehlgeschlagen: " + e);
    // Angemessen behandeln
}
```

### Fallstrick: Finally-Ueberschreibung

```hemlock
// SCHLECHT: Finally √ºberschreibt return
fn get_value() {
    try {
        return 42;
    } finally {
        return 0;  // Gibt 0 zur√ºck, nicht 42!
    }
}

// GUT: Nicht in finally returnen
fn get_value() {
    try {
        return 42;
    } finally {
        cleanup();  // Nur bereinigen, kein return
    }
}
```

### Fallstrick: Bereinigung vergessen

```hemlock
// SCHLECHT: Datei wird bei Fehler moeglicherweise nicht geschlossen
fn process() {
    let file = open("data.txt");
    let content = file.read();  // Kann werfen
    file.close();  // Wird bei Fehler nie erreicht
}

// GUT: Finally verwenden
fn process() {
    let file = null;
    try {
        file = open("data.txt");
        let content = file.read();
    } finally {
        if (file != null) {
            file.close();
        }
    }
}
```

### Fallstrick: Panic f√ºr erwartete Fehler verwenden

```hemlock
// SCHLECHT: Panic f√ºr erwarteten Fehler
fn read_config(path) {
    if (!file_exists(path)) {
        panic("Konfigurationsdatei nicht gefunden");  // Zu hart
    }
    return read_file(path);
}

// GUT: Throw f√ºr erwarteten Fehler
fn read_config(path) {
    if (!file_exists(path)) {
        throw "Konfigurationsdatei nicht gefunden: " + path;  // Behebbar
    }
    return read_file(path);
}
```

## Beispiele

### Beispiel: Grundlegende Fehlerbehandlung

```hemlock
fn divide(a, b) {
    if (b == 0) {
        throw "Division durch Null";
    }
    return a / b;
}

try {
    print(divide(10, 0));
} catch (e) {
    print("Fehler: " + e);  // Gibt aus: Fehler: Division durch Null
}
```

### Beispiel: Ressourcenverwaltung

```hemlock
fn copy_file(src, dst) {
    let src_file = null;
    let dst_file = null;

    try {
        src_file = open(src, "r");
        dst_file = open(dst, "w");

        let content = src_file.read();
        dst_file.write(content);

        print("Datei erfolgreich kopiert");
    } catch (e) {
        print("Fehler beim Kopieren der Datei: " + e);
        throw e;  // Erneut werfen
    } finally {
        if (src_file != null) { src_file.close(); }
        if (dst_file != null) { dst_file.close(); }
    }
}
```

### Beispiel: Verschachtelte Fehlerbehandlung

```hemlock
fn process_users(users) {
    let success_count = 0;
    let error_count = 0;

    let i = 0;
    while (i < users.length) {
        try {
            validate_user(users[i]);
            save_user(users[i]);
            success_count = success_count + 1;
        } catch (e) {
            print("Fehler beim Verarbeiten des Benutzers: " + e);
            error_count = error_count + 1;
        }
        i = i + 1;
    }

    print("Verarbeitet: " + typeof(success_count) + " erfolgreich, " + typeof(error_count) + " Fehler");
}
```

### Beispiel: Benutzerdefinierte Fehlertypen

```hemlock
fn create_error(type, message, details) {
    return {
        type: type,
        message: message,
        details: details,
        toString: fn() {
            return self.type + ": " + self.message;
        }
    };
}

fn divide(a, b) {
    if (typeof(a) != "i32" && typeof(a) != "f64") {
        throw create_error("TypeError", "a muss eine Zahl sein", { value: a });
    }
    if (typeof(b) != "i32" && typeof(b) != "f64") {
        throw create_error("TypeError", "b muss eine Zahl sein", { value: b });
    }
    if (b == 0) {
        throw create_error("DivisionByZero", "Division durch Null nicht m√∂glich", { a: a, b: b });
    }
    return a / b;
}

try {
    divide(10, 0);
} catch (e) {
    print(e.toString());
    if (e.type == "DivisionByZero") {
        print("Details: a=" + typeof(e.details.a) + ", b=" + typeof(e.details.b));
    }
}
```

### Beispiel: Wiederholungslogik

```hemlock
fn retry(operation, max_attempts) {
    let attempt = 0;

    while (attempt < max_attempts) {
        try {
            return operation();  // Erfolg!
        } catch (e) {
            attempt = attempt + 1;
            if (attempt >= max_attempts) {
                throw "Operation fehlgeschlagen nach " + typeof(max_attempts) + " Versuchen: " + e;
            }
            print("Versuch " + typeof(attempt) + " fehlgeschlagen, wiederhole...");
        }
    }
}

fn unreliable_operation() {
    // Simulierte unzuverlaessige Operation
    if (random() < 0.7) {
        throw "Operation fehlgeschlagen";
    }
    return "Erfolg";
}

try {
    let result = retry(unreliable_operation, 3);
    print(result);
} catch (e) {
    print("Alle Wiederholungen fehlgeschlagen: " + e);
}
```

## Ausfuehrungsreihenfolge

Verst√§ndnis der Ausfuehrungsreihenfolge:

```hemlock
try {
    print("1: try-Block Start");
    throw "fehler";
    print("2: nie erreicht");
} catch (e) {
    print("3: catch-Block");
} finally {
    print("4: finally-Block");
}
print("5: nach try/catch/finally");

// Ausgabe:
// 1: try-Block Start
// 3: catch-Block
// 4: finally-Block
// 5: nach try/catch/finally
```

## Aktuelle Einschr√§nkungen

- **Kein Stack-Trace** - Nicht gefangene Ausnahmen zeigen keinen Stack-Trace (geplant)
- **Einige Builtins beenden** - Einige eingebaute Funktionen rufen noch `exit()` statt zu werfen auf (wird √ºberpr√ºft)
- **Keine benutzerdefinierten Ausnahmetypen** - Jeder Wert kann geworfen werden, aber keine formale Ausnahmehierarchie

## Verwandte Themen

- [Functions](#language-guide-functions) - Ausnahmen und Funktionsrueckgaben
- [Control Flow](#language-guide-control-flow) - Wie Ausnahmen den Kontrollfluss beeinflussen
- [Memory](#language-guide-memory) - Finally f√ºr Speicherbereinigung verwenden

## Siehe auch

- **Ausnahmesemantik**: Siehe CLAUDE.md Abschnitt "Error Handling"
- **Panic vs. Throw**: Verschiedene Anwendungsfaelle f√ºr verschiedene Fehlertypen
- **Finally-Garantie**: Wird immer ausgef√ºhrt, auch bei return/break/continue


--------------------------------------------------------------------------------
## Funktionen
--------------------------------------------------------------------------------

# Funktionen

Funktionen in Hemlock sind **erstklassige Werte**, die Variablen zugewiesen, als Argumente √ºbergeben und von anderen Funktionen zur√ºckgegeben werden k√∂nnen. Diese Anleitung behandelt Funktionssyntax, Closures, Rekursion und fortgeschrittene Muster.

## √úbersicht

```hemlock
// Benannte Funktionssyntax
fn add(a: i32, b: i32): i32 {
    return a + b;
}

// Anonyme Funktion
let multiply = fn(x, y) {
    return x * y;
};

// Closures
fn makeAdder(x) {
    return fn(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
print(add5(3));  // 8
```

## Funktionsdeklaration

### Benannte Funktionen

```hemlock
fn greet(name: string): string {
    return "Hello, " + name;
}

let msg = greet("Alice");  // "Hello, Alice"
```

**Komponenten:**
- `fn` - Funktionsschluesselwort
- `greet` - Funktionsname
- `(name: string)` - Parameter mit optionalen Typen
- `: string` - Optionaler R√ºckgabetyp
- `{ ... }` - Funktionsk√∂rper

### Anonyme Funktionen

Funktionen ohne Namen, die Variablen zugewiesen werden:

```hemlock
let square = fn(x) {
    return x * x;
};

print(square(5));  // 25
```

**Benannt vs. Anonym:**
```hemlock
// Diese sind √§quivalent:
fn add(a, b) { return a + b; }

let add = fn(a, b) { return a + b; };
```

**Hinweis:** Benannte Funktionen werden intern zu Variablenzuweisungen mit anonymen Funktionen umgewandelt.

## Parameter

### Grundlegende Parameter

```hemlock
fn example(a, b, c) {
    return a + b + c;
}

let result = example(1, 2, 3);  // 6
```

### Typannotationen

Optionale Typannotationen f√ºr Parameter:

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 10);      // OK
add(5, 10.5);    // Laufzeit-Typ√ºberpr√ºfung konvertiert zu f64
```

**Typ√ºberpr√ºfung:**
- Parametertypen werden beim Aufruf √ºberpr√ºft, wenn annotiert
- Implizite Typkonvertierungen folgen Standard-Promotionsregeln
- Typkonflikte verursachen Laufzeitfehler

### Wertuebergabe (Pass-by-Value)

Alle Argumente werden **kopiert** (Wertuebergabe):

```hemlock
fn modify(x) {
    x = 100;  // Aendert nur die lokale Kopie
}

let a = 10;
modify(a);
print(a);  // Immer noch 10 (unver√§ndert)
```

**Hinweis:** Objekte und Arrays werden per Referenz √ºbergeben (die Referenz wird kopiert), sodass deren Inhalt ge√§ndert werden kann:

```hemlock
fn modify_array(arr) {
    arr[0] = 99;  // Aendert das Original-Array
}

let a = [1, 2, 3];
modify_array(a);
print(a[0]);  // 99 (ge√§ndert)
```

## Rueckgabewerte

### Return-Anweisung

```hemlock
fn get_max(a: i32, b: i32): i32 {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}
```

### R√ºckgabetyp-Annotationen

Optionale Typannotation f√ºr den R√ºckgabewert:

```hemlock
fn calculate(): f64 {
    return 3.14159;
}

fn get_name(): string {
    return "Alice";
}
```

**Typ√ºberpr√ºfung:**
- Rueckgabetypen werden beim Zur√ºckgeben gepr√ºft (wenn annotiert)
- Typkonvertierungen folgen Standard-Promotionsregeln

### Implizite R√ºckgabe

Funktionen ohne R√ºckgabetyp-Annotation geben implizit `null` zur√ºck:

```hemlock
fn print_message(msg) {
    print(msg);
    // Gibt implizit null zur√ºck
}

let result = print_message("hello");  // result ist null
```

### Fruehe R√ºckgabe

```hemlock
fn find_first_negative(arr) {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // Fruehes Beenden
        }
    }
    return -1;  // Nicht gefunden
}
```

### R√ºckgabe ohne Wert

`return;` ohne Wert gibt `null` zur√ºck:

```hemlock
fn maybe_process(value) {
    if (value < 0) {
        return;  // Gibt null zur√ºck
    }
    return value * 2;
}
```

## Erstklassige Funktionen

Funktionen k√∂nnen wie jeder andere Wert zugewiesen, √ºbergeben und zur√ºckgegeben werden.

### Funktionen als Variablen

```hemlock
let operation = fn(x, y) { return x + y; };

print(operation(5, 3));  // 8

// Neu zuweisen
operation = fn(x, y) { return x * y; };
print(operation(5, 3));  // 15
```

### Funktionen als Argumente

```hemlock
fn apply(f, x) {
    return f(x);
}

fn double(n) {
    return n * 2;
}

let result = apply(double, 5);  // 10
```

### Funktionen als Rueckgabewerte

```hemlock
fn get_operation(op: string) {
    if (op == "add") {
        return fn(a, b) { return a + b; };
    } else if (op == "multiply") {
        return fn(a, b) { return a * b; };
    } else {
        return fn(a, b) { return 0; };
    }
}

let add = get_operation("add");
print(add(5, 3));  // 8
```

## Closures

Funktionen erfassen ihre definierende Umgebung (lexikalisches Scoping).

### Grundlegende Closures

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
print(counter());  // 3
```

**Wie es funktioniert:**
- Die innere Funktion erfasst `count` aus dem √§u√üeren Scope
- `count` bleibt √ºber Aufrufe der zurueckgegebenen Funktion erhalten
- Jeder Aufruf von `makeCounter()` erstellt eine neue Closure mit eigenem `count`

### Closure mit Parametern

```hemlock
fn makeAdder(x) {
    return fn(y) {
        return x + y;
    };
}

let add5 = makeAdder(5);
let add10 = makeAdder(10);

print(add5(3));   // 8
print(add10(3));  // 13
```

### Mehrere Closures

```hemlock
fn makeOperations(x) {
    let add = fn(y) { return x + y; };
    let multiply = fn(y) { return x * y; };

    return { add: add, multiply: multiply };
}

let ops = makeOperations(5);
print(ops.add(3));       // 8
print(ops.multiply(3));  // 15
```

### Lexikalisches Scoping

Funktionen k√∂nnen durch lexikalisches Scoping auf Variablen des √§u√üeren Scopes zugreifen:

```hemlock
let global = 10;

fn outer() {
    let outer_var = 20;

    fn inner() {
        // Kann global und outer_var lesen
        print(global);      // 10
        print(outer_var);   // 20
    }

    inner();
}

outer();
```

Closures erfassen Variablen per Referenz, was sowohl Lesen als auch Mutation von Variablen des √§u√üeren Scopes erm√∂glicht (wie im `makeCounter`-Beispiel oben gezeigt).

## Rekursion

Funktionen k√∂nnen sich selbst aufrufen.

### Grundlegende Rekursion

```hemlock
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

print(factorial(5));  // 120
```

### Wechselseitige Rekursion

Funktionen k√∂nnen sich gegenseitig aufrufen:

```hemlock
fn is_even(n: i32): bool {
    if (n == 0) {
        return true;
    }
    return is_odd(n - 1);
}

fn is_odd(n: i32): bool {
    if (n == 0) {
        return false;
    }
    return is_even(n - 1);
}

print(is_even(4));  // true
print(is_odd(4));   // false
```

### Rekursive Datenverarbeitung

```hemlock
fn sum_array(arr: array, index: i32): i32 {
    if (index >= arr.length) {
        return 0;
    }
    return arr[index] + sum_array(arr, index + 1);
}

let numbers = [1, 2, 3, 4, 5];
print(sum_array(numbers, 0));  // 15
```

**Hinweis:** Noch keine Tail-Call-Optimierung - tiefe Rekursion kann zu Stack-√úberlauf f√ºhren.

## H√∂here Ordnung Funktionen

Funktionen, die andere Funktionen entgegennehmen oder zur√ºckgeben.

### Map-Muster

```hemlock
fn map(arr, f) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        result.push(f(arr[i]));
        i = i + 1;
    }
    return result;
}

fn double(x) { return x * 2; }

let numbers = [1, 2, 3, 4, 5];
let doubled = map(numbers, double);  // [2, 4, 6, 8, 10]
```

### Filter-Muster

```hemlock
fn filter(arr, predicate) {
    let result = [];
    let i = 0;
    while (i < arr.length) {
        if (predicate(arr[i])) {
            result.push(arr[i]);
        }
        i = i + 1;
    }
    return result;
}

fn is_even(x) { return x % 2 == 0; }

let numbers = [1, 2, 3, 4, 5, 6];
let evens = filter(numbers, is_even);  // [2, 4, 6]
```

### Reduce-Muster

```hemlock
fn reduce(arr, f, initial) {
    let accumulator = initial;
    let i = 0;
    while (i < arr.length) {
        accumulator = f(accumulator, arr[i]);
        i = i + 1;
    }
    return accumulator;
}

fn add(a, b) { return a + b; }

let numbers = [1, 2, 3, 4, 5];
let sum = reduce(numbers, add, 0);  // 15
```

### Funktionskomposition

```hemlock
fn compose(f, g) {
    return fn(x) {
        return f(g(x));
    };
}

fn double(x) { return x * 2; }
fn increment(x) { return x + 1; }

let double_then_increment = compose(increment, double);
print(double_then_increment(5));  // 11 (5*2 + 1)
```

## H√§ufige Muster

### Muster: Factory-Funktionen

```hemlock
fn createPerson(name: string, age: i32) {
    return {
        name: name,
        age: age,
        greet: fn() {
            return "Hi, I'm " + self.name;
        }
    };
}

let person = createPerson("Alice", 30);
print(person.greet());  // "Hi, I'm Alice"
```

### Muster: Callback-Funktionen

```hemlock
fn process_async(data, callback) {
    // ... Verarbeitung durchfuehren
    callback(data);
}

process_async("test", fn(result) {
    print("Processing complete: " + result);
});
```

### Muster: Partielle Anwendung

```hemlock
fn partial(f, x) {
    return fn(y) {
        return f(x, y);
    };
}

fn multiply(a, b) {
    return a * b;
}

let double = partial(multiply, 2);
let triple = partial(multiply, 3);

print(double(5));  // 10
print(triple(5));  // 15
```

### Muster: Memoisierung

```hemlock
fn memoize(f) {
    let cache = {};

    return fn(x) {
        if (cache.has(x)) {
            return cache[x];
        }

        let result = f(x);
        cache[x] = result;
        return result;
    };
}

fn expensive_fibonacci(n) {
    if (n <= 1) { return n; }
    return expensive_fibonacci(n - 1) + expensive_fibonacci(n - 2);
}

let fast_fib = memoize(expensive_fibonacci);
print(fast_fib(10));  // Viel schneller mit Caching
```

## Funktionssemantik

### R√ºckgabetyp-Anforderungen

Funktionen mit R√ºckgabetyp-Annotation **m√ºssen** einen Wert zur√ºckgeben:

```hemlock
fn get_value(): i32 {
    // FEHLER: Fehlende Return-Anweisung
}

fn get_value(): i32 {
    return 42;  // OK
}
```

### Typ√ºberpr√ºfung

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 10);        // OK
add(5.5, 10.5);    // Konvertiert zu f64, gibt f64 zur√ºck
add("a", "b");     // Laufzeitfehler: Typkonflikt
```

### Scope-Regeln

```hemlock
let global = "global";

fn outer() {
    let outer_var = "outer";

    fn inner() {
        let inner_var = "inner";
        // Kann zugreifen auf: inner_var, outer_var, global
    }

    // Kann zugreifen auf: outer_var, global
    // Kann nicht zugreifen auf: inner_var
}

// Kann zugreifen auf: global
// Kann nicht zugreifen auf: outer_var, inner_var
```

## Best Practices

1. **Verwende Typannotationen** - Hilft Fehler zu finden und dokumentiert die Absicht
2. **Halte Funktionen klein** - Jede Funktion sollte eine Sache tun
3. **Bevorzuge reine Funktionen** - Vermeide Seiteneffekte wenn m√∂glich
4. **Benenne Funktionen klar** - Verwende beschreibende Verb-Namen
5. **Fruehe R√ºckgabe** - Verwende Guard-Klauseln um Verschachtelung zu reduzieren
6. **Dokumentiere komplexe Closures** - Mache erfasste Variablen explizit
7. **Vermeide tiefe Rekursion** - Noch keine Tail-Call-Optimierung

## H√§ufige Fallstricke

### Fallstrick: Rekursionstiefe

```hemlock
// Tiefe Rekursion kann Stack-√úberlauf verursachen
fn count_down(n) {
    if (n == 0) { return; }
    count_down(n - 1);
}

count_down(100000);  // Kann mit Stack-√úberlauf abstuerzen
```

### Fallstrick: √Ñndern erfasster Variablen

```hemlock
fn make_counter() {
    let count = 0;
    return fn() {
        count = count + 1;  // Kann erfasste Variablen lesen und √§ndern
        return count;
    };
}
```

**Hinweis:** Das funktioniert, aber sei dir bewusst, dass alle Closures dieselbe erfasste Umgebung teilen.

## Beispiele

### Beispiel: Funktions-Pipeline

```hemlock
fn pipeline(value, ...functions) {
    let result = value;
    for (f in functions) {
        result = f(result);
    }
    return result;
}

fn double(x) { return x * 2; }
fn increment(x) { return x + 1; }
fn square(x) { return x * x; }

let result = pipeline(3, double, increment, square);
print(result);  // 49 ((3*2+1)^2)
```

### Beispiel: Event-Handler

```hemlock
let handlers = [];

fn on_event(name: string, handler) {
    handlers.push({ name: name, handler: handler });
}

fn trigger_event(name: string, data) {
    let i = 0;
    while (i < handlers.length) {
        if (handlers[i].name == name) {
            handlers[i].handler(data);
        }
        i = i + 1;
    }
}

on_event("click", fn(data) {
    print("Clicked: " + data);
});

trigger_event("click", "button1");
```

### Beispiel: Sortierung mit benutzerdefiniertem Vergleicher

```hemlock
fn sort(arr, compare) {
    // Bubble-Sort mit benutzerdefiniertem Vergleicher
    let n = arr.length;
    let i = 0;
    while (i < n) {
        let j = 0;
        while (j < n - i - 1) {
            if (compare(arr[j], arr[j + 1]) > 0) {
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

fn ascending(a, b) {
    if (a < b) { return -1; }
    if (a > b) { return 1; }
    return 0;
}

let numbers = [5, 2, 8, 1, 9];
sort(numbers, ascending);
print(numbers);  // [1, 2, 5, 8, 9]
```

## Optionale Parameter (Standardargumente)

Funktionen k√∂nnen optionale Parameter mit Standardwerten haben, unter Verwendung der `?:`-Syntax:

```hemlock
fn greet(name, greeting?: "Hello") {
    return greeting + " " + name;
}

print(greet("Alice"));           // "Hello Alice"
print(greet("Bob", "Hi"));       // "Hi Bob"

fn add(a, b?: 10, c?: 100) {
    return a + b + c;
}

print(add(1));          // 111 (1 + 10 + 100)
print(add(1, 2));       // 103 (1 + 2 + 100)
print(add(1, 2, 3));    // 6   (1 + 2 + 3)
```

**Regeln:**
- Optionale Parameter m√ºssen nach erforderlichen Parametern kommen
- Standardwerte k√∂nnen beliebige Ausdr√ºcke sein
- Ausgelassene Argumente verwenden den Standardwert

## Variadische Funktionen (Rest-Parameter)

Funktionen k√∂nnen eine variable Anzahl von Argumenten akzeptieren, unter Verwendung von Rest-Parametern (`...`):

```hemlock
fn sum(...args) {
    let total = 0;
    for (arg in args) {
        total = total + arg;
    }
    return total;
}

print(sum(1, 2, 3));        // 6
print(sum(1, 2, 3, 4, 5));  // 15
print(sum());               // 0

fn log(prefix, ...messages) {
    for (msg in messages) {
        print(prefix + ": " + msg);
    }
}

log("INFO", "Starting", "Running", "Done");
// INFO: Starting
// INFO: Running
// INFO: Done
```

**Regeln:**
- Der Rest-Parameter muss der letzte Parameter sein
- Der Rest-Parameter sammelt alle verbleibenden Argumente in einem Array
- Kann mit regulaeren und optionalen Parametern kombiniert werden

## Funktionstyp-Annotationen

Funktionstypen erm√∂glichen es, die genaue Signatur f√ºr Funktionsparameter und Rueckgabewerte zu spezifizieren:

### Grundlegende Funktionstypen

```hemlock
// Funktionstyp-Syntax: fn(param_types): return_type
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

let double = fn(n) { return n * 2; };
let result = apply(double, 5);  // 10
```

### H√∂here Ordnung Funktionstypen

```hemlock
// Funktion die eine Funktion zur√ºckgibt
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

let add5 = make_adder(5);
print(add5(10));  // 15
```

### Async-Funktionstypen

```hemlock
// Async-Funktionstyp
fn run_task(handler: async fn(): void) {
    spawn(handler);
}

run_task(async fn() {
    print("Running async!");
});
```

### Funktionstyp-Aliase

```hemlock
// Benannte Funktionstypen f√ºr Klarheit erstellen
type Callback = fn(i32): void;
type Predicate = fn(any): bool;
type BinaryOp = fn(i32, i32): i32;

fn filter_with(arr: array, pred: Predicate): array {
    return arr.filter(pred);
}
```

## Const-Parameter

Der `const`-Modifikator verhindert, dass ein Parameter innerhalb der Funktion veraendert wird:

### Grundlegende Const-Parameter

```hemlock
fn print_all(const items: array) {
    // items.push(4);  // FEHLER: kann const-Parameter nicht veraendern
    for (item in items) {
        print(item);   // OK: Lesen ist erlaubt
    }
}

let nums = [1, 2, 3];
print_all(nums);
```

### Tiefe Unver√§nderlichkeit

Const-Parameter erzwingen tiefe Unver√§nderlichkeit - keine Mutation √ºber irgendeinen Pfad:

```hemlock
fn describe(const person: object) {
    print(person.name);       // OK: Lesen ist erlaubt
    // person.name = "Bob";   // FEHLER: kann nicht veraendern
    // person.address.city = "NYC";  // FEHLER: tiefes const
}
```

### Was Const verhindert

| Typ | Durch Const blockiert | Erlaubt |
|------|-----------------|---------|
| array | push, pop, shift, unshift, insert, remove, clear, reverse | slice, concat, map, filter, find, contains |
| object | Feldzuweisung | Feldlesen |
| buffer | Indexzuweisung | Indexlesen |
| string | Indexzuweisung | alle Methoden (geben neue Strings zur√ºck) |

## Benannte Argumente

Funktionen k√∂nnen mit benannten Argumenten aufgerufen werden f√ºr Klarheit und Flexibilitaet:

### Grundlegende benannte Argumente

```hemlock
fn create_user(name: string, age?: 18, active?: true) {
    print(name + " is " + age + " years old");
}

// Positionsargumente (traditionell)
create_user("Alice", 25, false);

// Benannte Argumente - k√∂nnen in beliebiger Reihenfolge sein
create_user(name: "Bob", age: 30);
create_user(age: 25, name: "Charlie", active: false);
```

### Mischen von Positions- und benannten Argumenten

```hemlock
// Optionale Parameter √ºberspringen durch Benennen des Benotigten
create_user("David", active: false);  // Verwendet Standard-age=18

// Benannte Argumente m√ºssen nach Positionsargumenten kommen
create_user("Eve", age: 21);          // OK
// create_user(name: "Bad", 25);      // FEHLER: Positionsargument nach benanntem
```

### Regeln f√ºr benannte Argumente

- Verwende `name: wert`-Syntax f√ºr benannte Argumente
- Benannte Argumente k√∂nnen in beliebiger Reihenfolge nach Positionsargumenten erscheinen
- Positionsargumente k√∂nnen nicht auf benannte Argumente folgen
- Funktioniert mit Standard/optionalen Parametern
- Unbekannte Parameternamen verursachen Laufzeitfehler

## Einschr√§nkungen

Aktuelle Einschr√§nkungen, die zu beachten sind:

- **Keine Referenzuebergabe** - `ref`-Schl√ºsselwort wird geparst aber nicht implementiert
- **Kein Funktionsueberladen** - Eine Funktion pro Name
- **Keine Tail-Call-Optimierung** - Tiefe Rekursion durch Stack-Gr√∂√üe begrenzt

## Verwandte Themen

- [Kontrollfluss](#language-guide-control-flow) - Funktionen mit Kontrollstrukturen verwenden
- [Objekte](#language-guide-objects) - Methoden sind Funktionen in Objekten gespeichert
- [Fehlerbehandlung](#language-guide-error-handling) - Funktionen und Ausnahmebehandlung
- [Typen](#language-guide-types) - Typannotationen und Konvertierungen

## Siehe auch

- **Closures**: Siehe CLAUDE.md Abschnitt "Functions" f√ºr Closure-Semantik
- **Erstklassige Werte**: Funktionen sind Werte wie alle anderen
- **Lexikalisches Scoping**: Funktionen erfassen ihre definierende Umgebung


--------------------------------------------------------------------------------
## Kontrollfluss
--------------------------------------------------------------------------------

# Kontrollfluss

Hemlock bietet vertrauten C-√§hnlichen Kontrollfluss mit obligatorischen geschweiften Klammern und expliziter Syntax. Diese Anleitung behandelt Bedingungen, Schleifen, Switch-Anweisungen und Operatoren.

## √úberblick

Verfuegbare Kontrollfluss-Funktionen:

- `if`/`else`/`else if` - Bedingte Verzweigungen
- `while`-Schleifen - Bedingungsbasierte Iteration
- `for`-Schleifen - C-artige und for-in-Iteration
- `loop` - Endlosschleifen (sauberer als `while (true)`)
- `switch`-Anweisungen - Mehrfachverzweigung
- `break`/`continue` - Schleifensteuerung
- Schleifen-Labels - Gezieltes break/continue f√ºr verschachtelte Schleifen
- `defer` - Verz√∂gerte Ausf√ºhrung (Bereinigung)
- Boolesche Operatoren: `&&`, `||`, `!`
- Vergleichsoperatoren: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Bitweise Operatoren: `&`, `|`, `^`, `<<`, `>>`, `~`

## If-Anweisungen

### Einfaches If/Else

```hemlock
if (x > 10) {
    print("gro√ü");
} else {
    print("klein");
}
```

**Regeln:**
- Geschweifte Klammern sind **immer erforderlich** f√ºr alle Zweige
- Bedingungen m√ºssen in Klammern eingeschlossen sein
- Keine optionalen geschweiften Klammern (anders als C)

### If ohne Else

```hemlock
if (x > 0) {
    print("positiv");
}
// Kein else-Zweig n√∂tig
```

### Else-If-Ketten

```hemlock
if (x > 100) {
    print("sehr gro√ü");
} else if (x > 50) {
    print("gro√ü");
} else if (x > 10) {
    print("mittel");
} else {
    print("klein");
}
```

**Hinweis:** `else if` ist syntaktischer Zucker f√ºr verschachtelte if-Anweisungen. Diese sind √§quivalent:

```hemlock
// else if (syntaktischer Zucker)
if (a) {
    foo();
} else if (b) {
    bar();
}

// √Ñquivalentes verschachteltes if
if (a) {
    foo();
} else {
    if (b) {
        bar();
    }
}
```

### Verschachtelte If-Anweisungen

```hemlock
if (x > 0) {
    if (x < 10) {
        print("einstellig positiv");
    } else {
        print("mehrstellig positiv");
    }
} else {
    print("nicht positiv");
}
```

## While-Schleifen

Bedingungsbasierte Iteration:

```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

**Endlosschleifen (alter Stil):**
```hemlock
while (true) {
    // ... Arbeit erledigen
    if (should_exit) {
        break;
    }
}
```

**Hinweis:** F√ºr Endlosschleifen bevorzugen Sie das `loop`-Schl√ºsselwort (siehe unten).

## Loop (Endlosschleife)

Das Schl√ºsselwort `loop` bietet eine sauberere Syntax f√ºr Endlosschleifen:

```hemlock
loop {
    // ... Arbeit erledigen
    if (should_exit) {
        break;
    }
}
```

**√Ñquivalent zu `while (true)`, aber expliziter in der Absicht.**

### Einfache Schleife mit Break

```hemlock
let i = 0;
loop {
    if (i >= 5) {
        break;
    }
    print(i);
    i = i + 1;
}
// Gibt aus: 0, 1, 2, 3, 4
```

### Schleife mit Continue

```hemlock
let i = 0;
loop {
    i = i + 1;
    if (i > 5) {
        break;
    }
    if (i == 3) {
        continue;  // √úberspringt Ausgabe von 3
    }
    print(i);
}
// Gibt aus: 1, 2, 4, 5
```

### Verschachtelte Schleifen

```hemlock
let x = 0;
loop {
    if (x >= 2) { break; }
    let y = 0;
    loop {
        if (y >= 3) { break; }
        print(x * 10 + y);
        y = y + 1;
    }
    x = x + 1;
}
// Gibt aus: 0, 1, 2, 10, 11, 12
```

### Wann Loop verwenden

- **`loop` verwenden** f√ºr absichtlich unendliche Schleifen, die via `break` beendet werden
- **`while` verwenden** wenn es eine natuerliche Abbruchbedingung gibt
- **`for` verwenden** beim Iterieren einer bekannten Anzahl von Malen oder √ºber eine Sammlung

## For-Schleifen

### C-artige For-Schleife

Klassische dreiteilige For-Schleife:

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**Komponenten:**
- **Initialisierer**: `let i = 0` - Wird einmal vor der Schleife ausgef√ºhrt
- **Bedingung**: `i < 10` - Wird vor jeder Iteration gepr√ºft
- **Aktualisierung**: `i = i + 1` - Wird nach jeder Iteration ausgef√ºhrt

**G√ºltigkeitsbereich:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
// i ist hier nicht zug√§nglich (schleifenbezogen)
```

### For-In-Schleifen

√úber Array-Elemente iterieren:

```hemlock
let arr = [1, 2, 3, 4, 5];
for (let item in arr) {
    print(item);  // Gibt jedes Element aus
}
```

**Mit Index und Wert:**
```hemlock
let arr = ["a", "b", "c"];
for (let i = 0; i < arr.length; i = i + 1) {
    print(`Index: ${i}, Wert: ${arr[i]}`);
}
```

## Switch-Anweisungen

Mehrfachverzweigung basierend auf Wert:

### Einfacher Switch

```hemlock
let x = 2;

switch (x) {
    case 1:
        print("eins");
        break;
    case 2:
        print("zwei");
        break;
    case 3:
        print("drei");
        break;
}
```

### Switch mit Default

```hemlock
let color = "blue";

switch (color) {
    case "red":
        print("stop");
        break;
    case "yellow":
        print("langsam");
        break;
    case "green":
        print("los");
        break;
    default:
        print("unbekannte Farbe");
        break;
}
```

**Regeln:**
- `default` trifft zu, wenn kein anderer Fall zutrifft
- `default` kann √ºberall im Switch-K√∂rper erscheinen
- Nur ein default-Fall erlaubt

### Fall-Through-Verhalten

Faelle ohne `break` fallen durch zum n√§chsten Fall (C-artiges Verhalten). Dies ist **beabsichtigt** und kann zum Gruppieren von Faellen verwendet werden:

```hemlock
let grade = 85;

switch (grade) {
    case 100:
    case 95:
    case 90:
        print("A");
        break;
    case 85:
    case 80:
        print("B");
        break;
    default:
        print("C oder schlechter");
        break;
}
```

**Explizites Fall-Through-Beispiel:**
```hemlock
let day = 3;

switch (day) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        print("Wochentag");
        break;
    case 6:
    case 7:
        print("Wochenende");
        break;
}
```

**Wichtig:** Anders als einige moderne Sprachen erfordert Hemlock KEIN explizites `fallthrough`-Schl√ºsselwort. Faelle fallen automatisch durch, es sei denn, sie werden durch `break`, `return` oder `throw` beendet. Verwenden Sie immer `break`, um unbeabsichtigtes Fall-Through zu verhindern.

### Switch mit Return

In Funktionen beendet `return` den Switch sofort:

```hemlock
fn get_day_name(day: i32): string {
    switch (day) {
        case 1:
            return "Montag";
        case 2:
            return "Dienstag";
        case 3:
            return "Mittwoch";
        default:
            return "Unbekannt";
    }
}
```

### Switch-Werttypen

Switch funktioniert mit jedem Werttyp:

```hemlock
// Ganzzahlen
switch (count) {
    case 0: print("null"); break;
    case 1: print("eins"); break;
}

// Strings
switch (name) {
    case "Alice": print("A"); break;
    case "Bob": print("B"); break;
}

// Booleans
switch (flag) {
    case true: print("an"); break;
    case false: print("aus"); break;
}
```

**Hinweis:** Faelle werden mittels Wertgleichheit verglichen.

## Break und Continue

### Break

Verlasst die innerste Schleife oder Switch:

```hemlock
// In Schleifen
let i = 0;
while (true) {
    if (i >= 10) {
        break;  // Schleife verlassen
    }
    print(i);
    i = i + 1;
}

// In Switch
switch (x) {
    case 1:
        print("eins");
        break;  // Switch verlassen
    case 2:
        print("zwei");
        break;
}
```

### Continue

Springt zur n√§chsten Iteration der Schleife:

```hemlock
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;  // Iteration √ºberspringen wenn i 5 ist
    }
    print(i);  // Gibt aus: 0,1,2,3,4,6,7,8,9
}
```

**Unterschied:**
- `break` - Verlasst Schleife vollst√§ndig
- `continue` - Springt zur n√§chsten Iteration

## Schleifen-Labels

Schleifen-Labels erlauben `break` und `continue`, spezifische √§u√üere Schleifen anzusprechen, statt nur die innerste Schleife. Dies ist n√ºtzlich f√ºr verschachtelte Schleifen, wo Sie eine √§u√üere Schleife von einer inneren aus steuern m√ºssen.

### Labeled Break

Eine √§u√üere Schleife von einer inneren verlassen:

```hemlock
outer: while (i < 3) {
    let j = 0;
    while (j < 3) {
        if (i == 1 && j == 1) {
            break outer;  // √Ñu√üere while-Schleife verlassen
        }
        print(i * 10 + j);
        j = j + 1;
    }
    i = i + 1;
}
// Gibt aus: 0, 1, 2, 10 (stoppt bei i=1, j=1)
```

### Labeled Continue

Zur n√§chsten Iteration einer √§u√üeren Schleife springen:

```hemlock
let i = 0;
outer: while (i < 3) {
    i = i + 1;
    let j = 0;
    while (j < 3) {
        j = j + 1;
        if (i == 2 && j == 1) {
            continue outer;  // Rest der inneren Schleife √ºberspringen, √§u√üere fortsetzen
        }
        print(i * 10 + j);
    }
}
// Wenn i=2, j=1: springt zur n√§chsten √§u√üeren Iteration
```

### Labels mit For-Schleifen

Labels funktionieren mit allen Schleifentypen:

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 3; y = y + 1) {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
    }
}
```

### Labels mit For-In-Schleifen

```hemlock
let arr1 = [1, 2, 3];
let arr2 = [10, 20, 30];

outer: for (let a in arr1) {
    for (let b in arr2) {
        if (a == 2 && b == 20) {
            break outer;
        }
        print(a * 100 + b);
    }
}
```

### Labels mit Loop-Schl√ºsselwort

```hemlock
let x = 0;
outer: loop {
    let y = 0;
    loop {
        if (x == 1 && y == 1) {
            break outer;
        }
        print(x * 10 + y);
        y = y + 1;
        if (y >= 3) { break; }
    }
    x = x + 1;
    if (x >= 3) { break; }
}
```

### Mehrere Labels

Sie k√∂nnen Labels auf verschiedenen Verschachtelungsebenen haben:

```hemlock
outer: for (let a = 0; a < 2; a = a + 1) {
    inner: for (let b = 0; b < 3; b = b + 1) {
        for (let c = 0; c < 3; c = c + 1) {
            if (c == 1) {
                continue inner;  // Zur n√§chsten Iteration der mittleren Schleife springen
            }
            if (a == 1 && b == 1) {
                break outer;      // √Ñu√üerste Schleife verlassen
            }
            print(a * 100 + b * 10 + c);
        }
    }
}
```

### Unlabeled Break/Continue mit gelabelten Schleifen

Unlabeled `break` und `continue` funktionieren weiterhin normal (betreffen die innerste Schleife), auch wenn √§u√üere Schleifen Labels haben:

```hemlock
outer: for (let x = 0; x < 3; x = x + 1) {
    for (let y = 0; y < 5; y = y + 1) {
        if (y == 2) {
            break;  // Bricht nur innere Schleife ab
        }
        print(x * 10 + y);
    }
}
// Gibt aus: 0, 1, 10, 11, 20, 21
```

### Label-Syntax

- Labels sind Bezeichner gefolgt von einem Doppelpunkt
- Labels m√ºssen direkt vor einer Schleifenanweisung stehen (`while`, `for`, `loop`)
- Label-Namen folgen Bezeichnerregeln (Buchstaben, Ziffern, Unterstriche)
- G√§ngige Konventionen: `outer`, `inner`, `row`, `col`, beschreibende Namen

## Defer-Anweisung

Die `defer`-Anweisung plant Code zur Ausf√ºhrung, wenn die aktuelle Funktion zur√ºckkehrt. Dies ist n√ºtzlich f√ºr Bereinigungsoperationen wie Dateien schlie√üen, Ressourcen freigeben oder Sperren l√∂sen.

### Einfaches Defer

```hemlock
fn example() {
    print("start");
    defer print("bereinigung");  // Wird ausgef√ºhrt, wenn Funktion zur√ºckkehrt
    print("ende");
}

example();
// Ausgabe:
// start
// ende
// bereinigung
```

**Kernverhalten:**
- Deferred-Anweisungen werden **nach** Abschluss des Funktionskoerpers ausgef√ºhrt
- Deferred-Anweisungen werden **vor** der R√ºckkehr der Funktion an ihren Aufrufer ausgef√ºhrt
- Deferred-Anweisungen werden immer ausgef√ºhrt, auch wenn die Funktion eine Ausnahme wirft

### Mehrere Defers (LIFO-Reihenfolge)

Wenn mehrere `defer`-Anweisungen verwendet werden, werden sie in **umgekehrter Reihenfolge** ausgef√ºhrt (Last-In-First-Out):

```hemlock
fn example() {
    defer print("erstes");   // Wird zuletzt ausgef√ºhrt
    defer print("zweites");  // Wird als zweites ausgef√ºhrt
    defer print("drittes");  // Wird zuerst ausgef√ºhrt
    print("k√∂rper");
}

example();
// Ausgabe:
// k√∂rper
// drittes
// zweites
// erstes
```

Diese LIFO-Reihenfolge ist beabsichtigt - sie entspricht der natuerlichen Reihenfolge f√ºr verschachtelte Ressourcenbereinigung (innere Ressourcen vor √§u√üeren schlie√üen).

### Defer mit Return

Deferred-Anweisungen werden ausgef√ºhrt, bevor `return` die Kontrolle √ºbergibt:

```hemlock
fn get_value(): i32 {
    defer print("bereinigung");
    print("vor return");
    return 42;
}

let result = get_value();
print("ergebnis:", result);
// Ausgabe:
// vor return
// bereinigung
// ergebnis: 42
```

### Defer mit Ausnahmen

Deferred-Anweisungen werden auch ausgef√ºhrt, wenn eine Ausnahme geworfen wird:

```hemlock
fn risky() {
    defer print("bereinigung 1");
    defer print("bereinigung 2");
    print("vor throw");
    throw "fehler!";
    print("nach throw");  // Wird nie erreicht
}

try {
    risky();
} catch (e) {
    print("Gefangen:", e);
}
// Ausgabe:
// vor throw
// bereinigung 2
// bereinigung 1
// Gefangen: fehler!
```

### Ressourcenbereinigungsmuster

Der Hauptanwendungsfall f√ºr `defer` ist sicherzustellen, dass Ressourcen bereinigt werden:

```hemlock
fn process_file(filename: string) {
    let file = open(filename, "r");
    defer file.close();  // Schliesst immer, auch bei Fehler

    let content = file.read();
    // ... Inhalt verarbeiten ...

    // Datei wird automatisch geschlossen, wenn Funktion zur√ºckkehrt
}
```

**Ohne defer (fehleranfaellig):**
```hemlock
fn process_file_bad(filename: string) {
    let file = open(filename, "r");
    let content = file.read();
    // Wenn dies wirft, wird file.close() nie aufgerufen!
    process(content);
    file.close();
}
```

### Defer mit Closures

Defer kann Closures verwenden, um Zustand zu erfassen:

```hemlock
fn example() {
    let resource = acquire_resource();
    defer fn() {
        print("Ressource freigeben");
        release(resource);
    }();  // Hinweis: sofort aufgerufener Funktionsausdruck

    use_resource(resource);
}
```

### Wann Defer verwenden

**Defer verwenden f√ºr:**
- Dateien und Netzwerkverbindungen schlie√üen
- Allokierten Speicher freigeben
- Sperren und Mutexe freigeben
- Bereinigung in jeder Funktion, die Ressourcen erwirbt

**Defer vs. Finally:**
- `defer` ist einfacher f√ºr Einzelressourcen-Bereinigung
- `try/finally` ist besser f√ºr komplexe Fehlerbehandlung mit Wiederherstellung

### Best Practices

1. **Defer sofort nach Ressourcenerwerb platzieren:**
   ```hemlock
   let file = open("data.txt", "r");
   defer file.close();
   // ... Datei verwenden ...
   ```

2. **Mehrere Defers f√ºr mehrere Ressourcen verwenden:**
   ```hemlock
   let file1 = open("input.txt", "r");
   defer file1.close();

   let file2 = open("output.txt", "w");
   defer file2.close();

   // Beide Dateien werden in umgekehrter Reihenfolge geschlossen
   ```

3. **LIFO-Reihenfolge f√ºr abhaengige Ressourcen beachten:**
   ```hemlock
   let outer = acquire_outer();
   defer release_outer(outer);

   let inner = acquire_inner(outer);
   defer release_inner(inner);

   // inner wird vor outer freigegeben (korrekte Abhaengigkeitsreihenfolge)
   ```

## Boolesche Operatoren

### Logisches UND (`&&`)

Beide Bedingungen m√ºssen wahr sein:

```hemlock
if (x > 0 && x < 10) {
    print("einstellig positiv");
}
```

**Kurzschlussauswertung:**
```hemlock
if (false && expensive_check()) {
    // expensive_check() wird nie aufgerufen
}
```

### Logisches ODER (`||`)

Mindestens eine Bedingung muss wahr sein:

```hemlock
if (x < 0 || x > 100) {
    print("au√üerhalb des Bereichs");
}
```

**Kurzschlussauswertung:**
```hemlock
if (true || expensive_check()) {
    // expensive_check() wird nie aufgerufen
}
```

### Logisches NICHT (`!`)

Negiert booleschen Wert:

```hemlock
if (!is_valid) {
    print("ung√ºltig");
}

if (!(x > 10)) {
    // Gleich wie: if (x <= 10)
}
```

## Vergleichsoperatoren

### Gleichheit

```hemlock
if (x == 10) { }    // Gleich
if (x != 10) { }    // Ungleich
```

Funktioniert mit allen Typen:
```hemlock
"hello" == "hello"  // true
true == false       // false
null == null        // true
```

### Relational

```hemlock
if (x < 10) { }     // Kleiner als
if (x > 10) { }     // Gr√∂√üer als
if (x <= 10) { }    // Kleiner oder gleich
if (x >= 10) { }    // Gr√∂√üer oder gleich
```

**Typpromotion gilt:**
```hemlock
let a: i32 = 10;
let b: i64 = 10;
if (a == b) { }     // true (i32 wird zu i64 bef√∂rdert)
```

## Bitweise Operatoren

Hemlock bietet bitweise Operatoren f√ºr Ganzzahlmanipulation. Diese funktionieren **nur mit Ganzzahltypen** (i8-i64, u8-u64).

### Bin√§re bitweise Operatoren

**Bitweises UND (`&`)**
```hemlock
let a = 12;  // 1100 in bin√§r
let b = 10;  // 1010 in bin√§r
print(a & b);   // 8 (1000)
```

**Bitweises ODER (`|`)**
```hemlock
print(a | b);   // 14 (1110)
```

**Bitweises XOR (`^`)**
```hemlock
print(a ^ b);   // 6 (0110)
```

**Linksshift (`<<`)**
```hemlock
print(a << 2);  // 48 (110000) - 2 nach links schieben
```

**Rechtsshift (`>>`)**
```hemlock
print(a >> 1);  // 6 (110) - 1 nach rechts schieben
```

### Unaerer bitweiser Operator

**Bitweises NICHT (`~`)**
```hemlock
let a = 12;
print(~a);      // -13 (Zweierkomplement)

let c: u8 = 15;   // 00001111 in bin√§r
print(~c);        // 240 (11110000) in u8
```

### Bitweise Beispiele

**Mit vorzeichenlosen Typen:**
```hemlock
let c: u8 = 15;   // 00001111 in bin√§r
let d: u8 = 7;    // 00000111 in bin√§r

print(c & d);     // 7  (00000111)
print(c | d);     // 15 (00001111)
print(c ^ d);     // 8  (00001000)
print(~c);        // 240 (11110000) - in u8
```

**Typerhaltung:**
```hemlock
// Bitweise Operationen erhalten den Typ der Operanden
let x: u8 = 255;
let result = ~x;  // result ist u8 mit Wert 0

let y: i32 = 100;
let result2 = y << 2;  // result2 ist i32 mit Wert 400
```

**G√§ngige Muster:**
```hemlock
// Pr√ºfen, ob Bit gesetzt ist
if (flags & 0x04) {
    print("Bit 2 ist gesetzt");
}

// Bit setzen
flags = flags | 0x08;

// Bit l√∂schen
flags = flags & ~0x02;

// Bit umschalten
flags = flags ^ 0x01;
```

### Operatorpraezedenz

Bitweise Operatoren folgen C-artiger Pr√§zedenz:

1. `~` (unaeres NICHT) - hoechste, gleiche Ebene wie `!` und `-`
2. `<<`, `>>` (Shifts) - h√∂her als Vergleiche, niedriger als `+`/`-`
3. `&` (bitweises UND) - h√∂her als `^` und `|`
4. `^` (bitweises XOR) - zwischen `&` und `|`
5. `|` (bitweises ODER) - niedriger als `&` und `^`, h√∂her als `&&`
6. `&&`, `||` (logisch) - niedrigste Pr√§zedenz

**Beispiele:**
```hemlock
// & hat h√∂here Pr√§zedenz als |
let result1 = 12 | 10 & 8;  // (10 & 8) | 12 = 8 | 12 = 12

// Shift hat h√∂here Pr√§zedenz als bitweise Operatoren
let result2 = 8 | 1 << 2;   // 8 | (1 << 2) = 8 | 4 = 12

// Klammern f√ºr Klarheit verwenden
let result3 = (5 & 3) | (2 << 1);  // 1 | 4 = 5
```

**Wichtige Hinweise:**
- Bitweise Operatoren funktionieren nur mit Ganzzahltypen (nicht Floats, Strings, etc.)
- Typpromotion folgt Standardregeln (kleinere Typen werden zu groesseren bef√∂rdert)
- Rechtsshift (`>>`) ist arithmetisch f√ºr vorzeichenbehaftete Typen, logisch f√ºr vorzeichenlose
- Shift-Betraege werden nicht bereichsgeprueft (Verhalten ist plattformabhaengig f√ºr gro√üe Shifts)

## Operatorpraezedenz (Vollst√§ndig)

Von hoechster zu niedrigster Pr√§zedenz:

1. **Unaer**: `!`, `-`, `~`
2. **Multiplikativ**: `*`, `/`, `%`
3. **Additiv**: `+`, `-`
4. **Shift**: `<<`, `>>`
5. **Relational**: `<`, `>`, `<=`, `>=`
6. **Gleichheit**: `==`, `!=`
7. **Bitweises UND**: `&`
8. **Bitweises XOR**: `^`
9. **Bitweises ODER**: `|`
10. **Logisches UND**: `&&`
11. **Logisches ODER**: `||`

**Klammern f√ºr Klarheit verwenden:**
```hemlock
// Unklar
if (a || b && c) { }

// Klar
if (a || (b && c)) { }
if ((a || b) && c) { }
```

## G√§ngige Muster

### Muster: Eingabevalidierung

```hemlock
fn validate_age(age: i32): bool {
    if (age < 0 || age > 150) {
        return false;
    }
    return true;
}
```

### Muster: Bereichspr√ºfung

```hemlock
fn in_range(value: i32, min: i32, max: i32): bool {
    return value >= min && value <= max;
}

if (in_range(score, 0, 100)) {
    print("gueltige Punktzahl");
}
```

### Muster: Zustandsmaschine

```hemlock
let state = "start";

while (true) {
    switch (state) {
        case "start":
            print("Starte...");
            state = "running";
            break;

        case "running":
            if (should_pause) {
                state = "paused";
            } else if (should_stop) {
                state = "stopped";
            }
            break;

        case "paused":
            if (should_resume) {
                state = "running";
            }
            break;

        case "stopped":
            print("Gestoppt");
            break;
    }

    if (state == "stopped") {
        break;
    }
}
```

### Muster: Iteration mit Filterung

```hemlock
let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Nur gerade Zahlen ausgeben
for (let i = 0; i < arr.length; i = i + 1) {
    if (arr[i] % 2 != 0) {
        continue;  // Ungerade Zahlen √ºberspringen
    }
    print(arr[i]);
}
```

### Muster: Fruehes Beenden

```hemlock
fn find_first_negative(arr: array): i32 {
    for (let i = 0; i < arr.length; i = i + 1) {
        if (arr[i] < 0) {
            return i;  // Fruehes Beenden
        }
    }
    return -1;  // Nicht gefunden
}
```

## Best Practices

1. **Immer geschweifte Klammern verwenden** - Auch f√ºr einzeilige Bl√∂cke (durch Syntax erzwungen)
2. **Explizite Bedingungen** - `x == 0` statt `!x` f√ºr Klarheit verwenden
3. **Tiefe Verschachtelung vermeiden** - Verschachtelte Bedingungen in Funktionen extrahieren
4. **Fruehe Returns verwenden** - Verschachtelung mit Guard-Klauseln reduzieren
5. **Komplexe Bedingungen aufteilen** - In benannte boolesche Variablen aufteilen
6. **Default in Switch** - Immer einen Default-Fall einschliessen
7. **Fall-Through kommentieren** - Beabsichtigtes Fall-Through explizit machen

## H√§ufige Fallstricke

### Fallstrick: Zuweisung in Bedingung

```hemlock
// Das ist NICHT erlaubt (keine Zuweisung in Bedingungen)
if (x = 10) { }  // FEHLER: Syntaxfehler

// Vergleich stattdessen verwenden
if (x == 10) { }  // OK
```

### Fallstrick: Fehlendes Break in Switch

```hemlock
// Unbeabsichtigtes Fall-Through
switch (x) {
    case 1:
        print("eins");
        // Fehlendes break - faellt durch!
    case 2:
        print("zwei");  // Wird f√ºr 1 und 2 ausgef√ºhrt
        break;
}

// Korrektur: Break hinzuf√ºgen
switch (x) {
    case 1:
        print("eins");
        break;  // Jetzt korrekt
    case 2:
        print("zwei");
        break;
}
```

### Fallstrick: Schleifenvariablen-G√ºltigkeitsbereich

```hemlock
// i ist auf die Schleife beschr√§nkt
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
print(i);  // FEHLER: i ist hier nicht definiert
```

## Beispiele

### Beispiel: FizzBuzz

```hemlock
for (let i = 1; i <= 100; i = i + 1) {
    if (i % 15 == 0) {
        print("FizzBuzz");
    } else if (i % 3 == 0) {
        print("Fizz");
    } else if (i % 5 == 0) {
        print("Buzz");
    } else {
        print(i);
    }
}
```

### Beispiel: Primzahlpruefung

```hemlock
fn is_prime(n: i32): bool {
    if (n < 2) {
        return false;
    }

    let i = 2;
    while (i * i <= n) {
        if (n % i == 0) {
            return false;
        }
        i = i + 1;
    }

    return true;
}
```

### Beispiel: Menuesystem

```hemlock
fn menu() {
    while (true) {
        print("1. Start");
        print("2. Einstellungen");
        print("3. Beenden");

        let choice = get_input();

        switch (choice) {
            case 1:
                start_game();
                break;
            case 2:
                show_settings();
                break;
            case 3:
                print("Auf Wiedersehen!");
                return;
            default:
                print("Ungueltige Auswahl");
                break;
        }
    }
}
```

## Verwandte Themen

- [Functions](#language-guide-functions) - Kontrollfluss mit Funktionsaufrufen und Returns
- [Error Handling](#language-guide-error-handling) - Kontrollfluss mit Ausnahmen
- [Types](#language-guide-types) - Typkonvertierungen in Bedingungen

## Siehe auch

- **Syntax**: Siehe [Syntax](#language-guide-syntax) f√ºr Anweisungssyntax-Details
- **Operatoren**: Siehe [Types](#language-guide-types) f√ºr Typpromotion bei Operationen


--------------------------------------------------------------------------------
## Module
--------------------------------------------------------------------------------

# Hemlock Modulsystem

Dieses Dokument beschreibt das ES6-artige Import/Export-Modulsystem von Hemlock.

## √úbersicht

Hemlock unterst√ºtzt ein dateibasiertes Modulsystem mit ES6-artiger Import/Export-Syntax. Module sind:
- **Singletons**: Jedes Modul wird einmal geladen und gecacht
- **Dateibasiert**: Module entsprechen .hml-Dateien auf der Festplatte
- **Explizit importiert**: Abh√§ngigkeiten werden mit Import-Anweisungen deklariert
- **Topologisch ausgef√ºhrt**: Abh√§ngigkeiten werden vor abh√§ngigen Modulen ausgef√ºhrt

F√ºr Paketverwaltung und Drittanbieter-Abh√§ngigkeiten siehe [hpm (Hemlock Package Manager)](https://github.com/hemlang/hpm).

## Syntax

### Export-Anweisungen

**Inline benannte Exports:**
```hemlock
export fn add(a, b) {
    return a + b;
}

export const PI = 3.14159;
export let counter = 0;
```

**Export-Liste:**
```hemlock
fn add(a, b) { return a + b; }
fn subtract(a, b) { return a - b; }

export { add, subtract };
```

**Export Extern (FFI-Funktionen):**
```hemlock
import "libc.so.6";

// FFI-Funktionen zur Verwendung in anderen Modulen exportieren
export extern fn strlen(s: string): i32;
export extern fn getpid(): i32;
```

Siehe [FFI-Dokumentation](../advanced/ffi.md#exporting-ffi-functions) f√ºr weitere Details zum Exportieren von FFI-Funktionen.

**Export Define (Struct-Typen):**
```hemlock
// Struct-Typdefinitionen exportieren
export define Vector2 {
    x: f32,
    y: f32,
}

export define Rectangle {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
}
```

**Wichtig:** Exportierte Struct-Typen werden global registriert, wenn das Modul geladen wird. Sie werden automatisch verf√ºgbar, wenn Sie etwas aus dem Modul importieren - Sie m√ºssen (und k√∂nnen) sie NICHT explizit nach Namen importieren:

```hemlock
// GUT - Struct-Typen sind nach jedem Import automatisch verf√ºgbar
import { some_function } from "./my_module.hml";
let v: Vector2 = { x: 1.0, y: 2.0 };  // Funktioniert!

// SCHLECHT - Struct-Typen k√∂nnen nicht explizit importiert werden
import { Vector2 } from "./my_module.hml";  // Fehler: Undefinierte Variable 'Vector2'
```

Siehe [FFI-Dokumentation](../advanced/ffi.md#exporting-struct-types) f√ºr weitere Details zum Exportieren von Struct-Typen.

**Re-Exports:**
```hemlock
// Aus einem anderen Modul re-exportieren
export { add, subtract } from "./math.hml";
```

### Import-Anweisungen

**Benannte Imports:**
```hemlock
import { add, subtract } from "./math.hml";
print(add(1, 2));  // 3
```

**Namespace-Import:**
```hemlock
import * as math from "./math.hml";
print(math.add(1, 2));  // 3
print(math.PI);  // 3.14159
```

**Aliasing:**
```hemlock
import { add as sum, subtract as diff } from "./math.hml";
print(sum(1, 2));  // 3
```

## Modulaufloesung

### Pfadtypen

**Relative Pfade:**
```hemlock
import { foo } from "./module.hml";       // Gleiches Verzeichnis
import { bar } from "../parent.hml";      // Uebergeordnetes Verzeichnis
import { baz } from "./sub/nested.hml";   // Unterverzeichnis
```

**Absolute Pfade:**
```hemlock
import { foo } from "/absolute/path/to/module.hml";
```

**Erweiterungsbehandlung:**
- Die `.hml`-Erweiterung kann weggelassen werden - sie wird automatisch hinzugef√ºgt
- `./math` wird zu `./math.hml` aufgel√∂st

## Funktionen

### Erkennung zirkulaerer Abh√§ngigkeiten

Das Modulsystem erkennt zirkulaere Abh√§ngigkeiten und meldet einen Fehler:

```
Error: Circular dependency detected when loading '/path/to/a.hml'
```

### Modul-Caching

Module werden einmal geladen und gecacht. Mehrere Imports desselben Moduls geben dieselbe Instanz zur√ºck:

```hemlock
// counter.hml
export let count = 0;
export fn increment() {
    count = count + 1;
}

// a.hml
import { count, increment } from "./counter.hml";
increment();
print(count);  // 1

// b.hml
import { count } from "./counter.hml";  // Dieselbe Instanz!
print(count);  // Immer noch 1 (geteilter Zustand)
```

### Import-Unver√§nderlichkeit

Importierte Bindungen k√∂nnen nicht neu zugewiesen werden:

```hemlock
import { add } from "./math.hml";
add = fn() { };  // FEHLER: kann importierte Bindung nicht neu zuweisen
```

## Implementierungsdetails

### Architektur

**Dateien:**
- `include/module.h` - Modulsystem-API
- `src/module.c` - Modulladen, Caching und Ausf√ºhrung
- Parser-Unterst√ºtzung in `src/parser.c`
- Laufzeit-Unterst√ºtzung in `src/interpreter/runtime.c`

**Schluesselkomponenten:**
1. **ModuleCache**: Verwaltet geladene Module, indiziert nach absolutem Pfad
2. **Module**: Repraesentiert ein geladenes Modul mit seinem AST und Exports
3. **Pfadaufloesung**: Loest relative/absolute Pfade zu kanonischen Pfaden auf
4. **Topologische Ausf√ºhrung**: Fuehrt Module in Abhaengigkeitsreihenfolge aus

### Modulladeprozess

1. **Parse-Phase**: Tokenisieren und Parsen der Moduldatei
2. **Abhaengigkeitsaufloesung**: Rekursives Laden importierter Module
3. **Zykluserkennung**: Pr√ºfen, ob das Modul bereits geladen wird
4. **Caching**: Modul im Cache nach absolutem Pfad speichern
5. **Ausfuehrungsphase**: Ausf√ºhrung in topologischer Reihenfolge (Abh√§ngigkeiten zuerst)

### API

```c
// High-Level-API
int execute_file_with_modules(const char *file_path,
                               int argc, char **argv,
                               ExecutionContext *ctx);

// Low-Level-API
ModuleCache* module_cache_new(const char *initial_dir);
void module_cache_free(ModuleCache *cache);
Module* load_module(ModuleCache *cache, const char *module_path, ExecutionContext *ctx);
void execute_module(Module *module, ModuleCache *cache, ExecutionContext *ctx);
```

## Testen

Testmodule befinden sich in `tests/modules/` und `tests/parity/modules/`:

- `math.hml` - Basismodul mit Exports
- `test_import_named.hml` - Test f√ºr benannte Imports
- `test_import_namespace.hml` - Test f√ºr Namespace-Imports
- `test_import_alias.hml` - Test f√ºr Import-Aliasing
- `export_extern.hml` - Test f√ºr Export extern FFI-Funktion (Linux)

## Paket-Imports (hpm)

Mit installiertem [hpm](https://github.com/hemlang/hpm) k√∂nnen Sie Drittanbieter-Pakete von GitHub importieren:

```hemlock
// Import aus Paket-Root (verwendet "main" aus package.json)
import { app, router } from "hemlang/sprout";

// Import aus Unterpfad
import { middleware } from "hemlang/sprout/middleware";

// Standardbibliothek (in Hemlock eingebaut)
import { HashMap } from "@stdlib/collections";
```

Pakete werden in `hem_modules/` installiert und mit GitHub `owner/repo`-Syntax aufgel√∂st.

```bash
# Ein Paket installieren
hpm install hemlang/sprout

# Mit Versionsbeschraenkung installieren
hpm install hemlang/sprout@^1.0.0
```

Siehe die [hpm-Dokumentation](https://github.com/hemlang/hpm) f√ºr vollst√§ndige Details.

## Aktuelle Einschr√§nkungen

1. **Keine dynamischen Imports**: `import()` als Laufzeitfunktion wird nicht unterst√ºtzt
2. **Keine bedingten Exports**: Exports m√ºssen auf oberster Ebene sein
3. **Statische Bibliothekspfade**: FFI-Bibliotheksimports verwenden statische Pfade (plattformspezifisch)

## Zukuenftige Arbeit

- Dynamische Imports mit `import()`-Funktion
- Bedingte Exports
- Modul-Metadaten (`import.meta`)
- Tree Shaking und Eliminierung von totem Code

## Beispiele

Siehe `tests/modules/` f√ºr funktionierende Beispiele des Modulsystems.

Beispiel-Modulstruktur:
```
project/
‚îú‚îÄ‚îÄ main.hml
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ math.hml
‚îÇ   ‚îú‚îÄ‚îÄ string.hml
‚îÇ   ‚îî‚îÄ‚îÄ index.hml (Barrel-Modul)
‚îî‚îÄ‚îÄ utils/
    ‚îî‚îÄ‚îÄ helpers.hml
```

Beispielverwendung:
```hemlock
// lib/math.hml
export fn add(a, b) { return a + b; }
export fn multiply(a, b) { return a * b; }

// lib/index.hml (Barrel)
export { add, multiply } from "./math.hml";

// main.hml
import { add } from "./lib/index.hml";
print(add(2, 3));  // 5
```


--------------------------------------------------------------------------------
## Musterabgleich
--------------------------------------------------------------------------------

# Pattern Matching

Hemlock bietet leistungsfaehiges Pattern Matching durch `match`-Ausdr√ºcke, die eine praegnante M√∂glichkeit bieten, Werte zu destrukturieren, Typen zu pr√ºfen und mehrere Faelle zu behandeln.

## Grundlegende Syntax

```hemlock
let result = match (value) {
    pattern1 => expression1,
    pattern2 => expression2,
    _ => default_expression
};
```

Match-Ausdr√ºcke werten `value` gegen jedes Pattern der Reihe nach aus und geben das Ergebnis des Ausdrucks des ersten passenden Arms zur√ºck.

## Pattern-Typen

### Literal-Patterns

Exakte Werte abgleichen:

```hemlock
let x = 42;
let msg = match (x) {
    0 => "null",
    1 => "eins",
    42 => "die Antwort",
    _ => "andere"
};
print(msg);  // "die Antwort"
```

Unterstuetzte Literale:
- **Ganzzahlen**: `0`, `42`, `-5`
- **Fliesskommazahlen**: `3.14`, `-0.5`
- **Strings**: `"hello"`, `"world"`
- **Booleans**: `true`, `false`
- **Null**: `null`

### Wildcard-Pattern (`_`)

Passt auf jeden Wert ohne Bindung:

```hemlock
let x = "anything";
let result = match (x) {
    "specific" => "gefunden",
    _ => "wildcard matched"
};
```

### Variablenbindungs-Patterns

Den gematchten Wert an eine Variable binden:

```hemlock
let x = 100;
let result = match (x) {
    0 => "null",
    n => "Wert ist " + n  // n wird an 100 gebunden
};
print(result);  // "Wert ist 100"
```

### ODER-Patterns (`|`)

Mehrere Alternativen abgleichen:

```hemlock
let x = 2;
let size = match (x) {
    1 | 2 | 3 => "klein",
    4 | 5 | 6 => "mittel",
    _ => "gro√ü"
};

// Funktioniert auch mit Strings
let cmd = "quit";
let action = match (cmd) {
    "exit" | "quit" | "q" => "beende",
    "help" | "h" | "?" => "zeige Hilfe",
    _ => "unbekannt"
};
```

### Guard-Ausdr√ºcke (`if`)

Bedingungen zu Patterns hinzuf√ºgen:

```hemlock
let x = 15;
let category = match (x) {
    n if n < 0 => "negativ",
    n if n == 0 => "null",
    n if n < 10 => "klein",
    n if n < 100 => "mittel",
    n => "gro√ü: " + n
};
print(category);  // "mittel"

// Komplexe Guards
let y = 12;
let result = match (y) {
    n if n % 2 == 0 && n > 10 => "gerade und gr√∂√üer als 10",
    n if n % 2 == 0 => "gerade",
    n => "ungerade"
};
```

### Typ-Patterns

Basierend auf Typ pr√ºfen und binden:

```hemlock
let val = 42;
let desc = match (val) {
    num: i32 => "Ganzzahl: " + num,
    str: string => "String: " + str,
    flag: bool => "Boolean: " + flag,
    _ => "anderer Typ"
};
print(desc);  // "Ganzzahl: 42"
```

Unterstuetzte Typen: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`, `bool`, `string`, `array`, `object`

## Destrukturierungs-Patterns

### Objekt-Destrukturierung

Felder aus Objekten extrahieren:

```hemlock
let point = { x: 10, y: 20 };
let result = match (point) {
    { x, y } => "Punkt bei " + x + "," + y
};
print(result);  // "Punkt bei 10,20"

// Mit literalen Feldwerten
let origin = { x: 0, y: 0 };
let name = match (origin) {
    { x: 0, y: 0 } => "Ursprung",
    { x: 0, y } => "auf y-Achse bei " + y,
    { x, y: 0 } => "auf x-Achse bei " + x,
    { x, y } => "Punkt bei " + x + "," + y
};
print(name);  // "Ursprung"
```

### Array-Destrukturierung

Array-Struktur und Elemente abgleichen:

```hemlock
let arr = [1, 2, 3];
let desc = match (arr) {
    [] => "leer",
    [x] => "einzeln: " + x,
    [x, y] => "Paar: " + x + "," + y,
    [x, y, z] => "Tripel: " + x + "," + y + "," + z,
    _ => "viele Elemente"
};
print(desc);  // "Tripel: 1,2,3"

// Mit literalen Werten
let pair = [1, 2];
let result = match (pair) {
    [0, 0] => "beide null",
    [1, x] => "beginnt mit 1, zweites ist " + x,
    [x, 1] => "endet mit 1",
    _ => "andere"
};
print(result);  // "beginnt mit 1, zweites ist 2"
```

### Array-Rest-Patterns (`...`)

Verbleibende Elemente erfassen:

```hemlock
let nums = [1, 2, 3, 4, 5];

// Kopf und Rest
let result = match (nums) {
    [first, ...rest] => "erstes: " + first,
    [] => "leer"
};
print(result);  // "erstes: 1"

// Erste zwei Elemente
let result2 = match (nums) {
    [a, b, ...rest] => "erste zwei: " + a + "," + b,
    _ => "zu kurz"
};
print(result2);  // "erste zwei: 1,2"
```

### Verschachtelte Destrukturierung

Patterns f√ºr komplexe Daten kombinieren:

```hemlock
let user = {
    name: "Alice",
    address: { city: "NYC", zip: 10001 }
};

let result = match (user) {
    { name, address: { city, zip } } => name + " lebt in " + city,
    _ => "unbekannt"
};
print(result);  // "Alice lebt in NYC"

// Objekt mit Array
let data = { items: [1, 2, 3], count: 3 };
let result2 = match (data) {
    { items: [first, ...rest], count } => "erstes: " + first + ", gesamt: " + count,
    _ => "keine Elemente"
};
print(result2);  // "erstes: 1, gesamt: 3"
```

## Match als Ausdruck

Match ist ein Ausdruck, der einen Wert zur√ºckgibt:

```hemlock
// Direkte Zuweisung
let grade = 85;
let letter = match (grade) {
    n if n >= 90 => "A",
    n if n >= 80 => "B",
    n if n >= 70 => "C",
    n if n >= 60 => "D",
    _ => "F"
};

// In String-Verkettung
let msg = "Note: " + match (grade) {
    n if n >= 70 => "bestanden",
    _ => "durchgefallen"
};

// In Funktionsrueckgabe
fn classify(n: i32): string {
    return match (n) {
        0 => "null",
        n if n > 0 => "positiv",
        _ => "negativ"
    };
}
```

## Best Practices f√ºr Pattern Matching

1. **Reihenfolge ist wichtig**: Patterns werden von oben nach unten gepr√ºft; setzen Sie spezifische Patterns vor allgemeine
2. **Wildcards f√ºr Vollstaendigkeit**: Fuegen Sie immer einen `_`-Fallback ein, au√üer Sie sind sicher, dass alle Faelle abgedeckt sind
3. **Guards statt verschachtelter Bedingungen bevorzugen**: Guards machen die Absicht klarer
4. **Destrukturierung statt manuellem Feldzugriff bevorzugen**: Praegnanter und sicherer

```hemlock
// Gut: Guards f√ºr Bereichspr√ºfung
match (score) {
    n if n >= 90 => "A",
    n if n >= 80 => "B",
    _ => "unter B"
}

// Gut: Destrukturieren statt Feldzugriff
match (point) {
    { x: 0, y: 0 } => "Ursprung",
    { x, y } => "bei " + x + "," + y
}

// Vermeiden: Ueberkomplexe verschachtelte Patterns
// Stattdessen in mehrere Matches aufteilen oder Guards verwenden
```

## Vergleich mit anderen Sprachen

| Feature | Hemlock | Rust | JavaScript |
|---------|---------|------|------------|
| Basis-Matching | `match (x) { ... }` | `match x { ... }` | `switch (x) { ... }` |
| Destrukturierung | Ja | Ja | Teilweise (switch destrukturiert nicht) |
| Guards | `n if n > 0 =>` | `n if n > 0 =>` | N/A |
| ODER-Patterns | `1 \| 2 \| 3 =>` | `1 \| 2 \| 3 =>` | `case 1: case 2: case 3:` |
| Rest-Patterns | `[a, ...rest]` | `[a, rest @ ..]` | N/A |
| Typ-Patterns | `n: i32` | Typ via `match`-Arm | N/A |
| Gibt Wert zur√ºck | Ja | Ja | Nein (Statement) |

## Implementierungshinweise

Pattern Matching ist sowohl im Interpreter- als auch im Compiler-Backend mit voller Paritaet implementiert - beide erzeugen identische Ergebnisse f√ºr dieselbe Eingabe. Das Feature ist ab Hemlock v1.8.0 verf√ºgbar.


--------------------------------------------------------------------------------
## Objekte
--------------------------------------------------------------------------------

# Objekte

Hemlock implementiert JavaScript-√§hnliche Objekte mit Heap-Allokation, dynamischen Feldern, Methoden und Duck-Typing. Objekte sind flexible Datenstrukturen, die Daten und Verhalten kombinieren.

## √úberblick

```hemlock
// Anonymes Objekt
let person = { name: "Alice", age: 30, city: "NYC" };
print(person.name);  // "Alice"

// Objekt mit Methoden
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    }
};

counter.increment();
print(counter.count);  // 1
```

## Objektliterale

### Grundlegende Syntax

```hemlock
let person = {
    name: "Alice",
    age: 30,
    city: "NYC"
};
```

**Syntax:**
- Geschweifte Klammern `{}` umschliessen das Objekt
- Schl√ºssel-Wert-Paare durch Kommas getrennt
- Schl√ºssel sind Bezeichner (keine Anf√ºhrungszeichen n√∂tig)
- Werte k√∂nnen jeden Typ haben

### Leere Objekte

```hemlock
let obj = {};  // Leeres Objekt

// Felder sp√§ter hinzuf√ºgen
obj.name = "Alice";
obj.age = 30;
```

### Verschachtelte Objekte

```hemlock
let user = {
    info: {
        name: "Bob",
        age: 25
    },
    active: true,
    settings: {
        theme: "dark",
        notifications: true
    }
};

print(user.info.name);           // "Bob"
print(user.settings.theme);      // "dark"
```

### Gemischte Werttypen

```hemlock
let mixed = {
    number: 42,
    text: "hello",
    flag: true,
    data: null,
    items: [1, 2, 3],
    config: { x: 10, y: 20 }
};
```

### Kurzschreibweise f√ºr Eigenschaften

Wenn ein Variablenname mit dem Eigenschaftsnamen √ºbereinstimmt, verwenden Sie die Kurzschreibweise:

```hemlock
let name = "Alice";
let age = 30;
let active = true;

// Kurzschreibweise: { name } ist √§quivalent zu { name: name }
let person = { name, age, active };

print(person.name);   // "Alice"
print(person.age);    // 30
print(person.active); // true
```

**Kurzschreibweise mit regulaeren Eigenschaften mischen:**
```hemlock
let city = "NYC";
let obj = { name, age, city, role: "admin" };
```

### Spread-Operator

Der Spread-Operator (`...`) kopiert alle Felder von einem Objekt in ein anderes:

```hemlock
let base = { x: 1, y: 2 };
let extended = { ...base, z: 3 };

print(extended.x);  // 1
print(extended.y);  // 2
print(extended.z);  // 3
```

**Werte mit Spread ueberschreiben:**
```hemlock
let defaults = { theme: "light", size: "medium", debug: false };
let custom = { ...defaults, theme: "dark" };

print(custom.theme);  // "dark" (√ºberschrieben)
print(custom.size);   // "medium" (von defaults)
print(custom.debug);  // false (von defaults)
```

**Mehrere Spreads (sp√§tere Spreads ueberschreiben fruehere):**
```hemlock
let a = { x: 1 };
let b = { y: 2 };
let merged = { ...a, ...b, z: 3 };

print(merged.x);  // 1
print(merged.y);  // 2
print(merged.z);  // 3

// Spaeterer Spread √ºberschreibt frueheren
let first = { val: "first" };
let second = { val: "second" };
let combined = { ...first, ...second };
print(combined.val);  // "second"
```

**Kurzschreibweise und Spread kombinieren:**
```hemlock
let status = "active";
let data = { id: 1, name: "Item" };
let full = { ...data, status };

print(full.id);      // 1
print(full.name);    // "Item"
print(full.status);  // "active"
```

**Konfigurationsueberschreibungsmuster:**
```hemlock
let defaultConfig = {
    debug: false,
    timeout: 30,
    retries: 3
};

let prodConfig = { ...defaultConfig, timeout: 60 };
let devConfig = { ...defaultConfig, debug: true };

print(prodConfig.timeout);  // 60
print(devConfig.debug);     // true
```

**Hinweis:** Spread f√ºhrt eine flache Kopie durch. Verschachtelte Objekte teilen Referenzen:
```hemlock
let nested = { inner: { val: 42 } };
let copied = { ...nested };
print(copied.inner.val);  // 42 (gleiche Referenz wie nested.inner)
```

## Feldzugriff

### Punkt-Notation

```hemlock
let person = { name: "Alice", age: 30 };

// Feld lesen
let name = person.name;      // "Alice"
let age = person.age;        // 30

// Feld √§ndern
person.age = 31;
print(person.age);           // 31
```

### Dynamisches Hinzuf√ºgen von Feldern

Neue Felder zur Laufzeit hinzuf√ºgen:

```hemlock
let person = { name: "Alice" };

// Neues Feld hinzuf√ºgen
person.email = "alice@example.com";
person.phone = "555-1234";

print(person.email);  // "alice@example.com"
```

### Feldloeschung

**Hinweis:** Feldloeschung wird derzeit nicht unterst√ºtzt. Setzen Sie stattdessen auf `null`:

```hemlock
let obj = { x: 10, y: 20 };

// Felder k√∂nnen nicht gel√∂scht werden (nicht unterst√ºtzt)
// obj.x = undefined;  // Kein 'undefined' in Hemlock

// Workaround: Auf null setzen
obj.x = null;
```

## Methoden und `self`

### Methoden definieren

Methoden sind Funktionen, die in Objektfeldern gespeichert sind:

```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    },
    decrement: fn() {
        self.count = self.count - 1;
    },
    get: fn() {
        return self.count;
    }
};
```

### Das Schl√ºsselwort `self`

Wenn eine Funktion als Methode aufgerufen wird, wird `self` automatisch an das Objekt gebunden:

```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;  // self verweist auf counter
    }
};

counter.increment();  // self ist an counter gebunden
print(counter.count);  // 1
```

**Funktionsweise:**
- Methodenaufrufe werden erkannt, indem gepr√ºft wird, ob der Funktionsausdruck ein Eigenschaftszugriff ist
- `self` wird automatisch zum Aufrufzeitpunkt an das Objekt gebunden
- `self` ist schreibgeschuetzt (man kann `self` selbst nicht neu zuweisen)

### Methodenaufruf-Erkennung

```hemlock
let obj = {
    value: 10,
    method: fn() {
        return self.value;
    }
};

// Als Methode aufgerufen - self ist gebunden
print(obj.method());  // 10

// Als Funktion aufgerufen - self ist null (Fehler)
let f = obj.method;
print(f());  // FEHLER: self ist nicht definiert
```

### Methoden mit Parametern

```hemlock
let calculator = {
    result: 0,
    add: fn(x) {
        self.result = self.result + x;
    },
    multiply: fn(x) {
        self.result = self.result * x;
    },
    get: fn() {
        return self.result;
    }
};

calculator.add(5);
calculator.multiply(2);
print(calculator.get());  // 10
```

## Typdefinitionen mit `define`

### Grundlegende Typdefinition

Objektstrukturen mit `define` definieren:

```hemlock
define Person {
    name: string,
    age: i32,
    active: bool,
}

// Objekt erstellen und typisierter Variable zuweisen
let p = { name: "Alice", age: 30, active: true };
let typed_p: Person = p;  // Duck-Typing validiert Struktur

print(typeof(typed_p));  // "Person"
```

**Was `define` macht:**
- Deklariert einen Typ mit erforderlichen Feldern
- Erm√∂glicht Duck-Typing-Validierung
- Setzt den Typnamen des Objekts f√ºr `typeof()`

### Duck-Typing

Objekte werden gegen `define` mittels **struktureller Kompatibilitaet** validiert:

```hemlock
define Person {
    name: string,
    age: i32,
}

// OK: Hat alle erforderlichen Felder
let p1: Person = { name: "Alice", age: 30 };

// OK: Zus√§tzliche Felder sind erlaubt
let p2: Person = {
    name: "Bob",
    age: 25,
    city: "NYC",
    active: true
};

// FEHLER: Fehlendes erforderliches Feld 'age'
let p3: Person = { name: "Carol" };

// FEHLER: Falscher Typ f√ºr 'age'
let p4: Person = { name: "Dave", age: "dreissig" };
```

**Duck-Typing-Regeln:**
- Alle erforderlichen Felder m√ºssen vorhanden sein
- Feldtypen m√ºssen √ºbereinstimmen
- Zus√§tzliche Felder sind erlaubt und werden beibehalten
- Validierung erfolgt zum Zuweisungszeitpunkt

### Optionale Felder

Felder k√∂nnen mit Standardwerten optional sein:

```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,       // Optional mit Standardwert
    nickname?: string,   // Optional, Standard ist null
}

// Objekt mit nur erforderlichen Feldern
let p = { name: "Alice", age: 30 };
let typed_p: Person = p;

print(typed_p.active);    // true (Standard angewendet)
print(typed_p.nickname);  // null (kein Standard)

// Optionale Felder k√∂nnen √ºberschrieben werden
let p2: Person = { name: "Bob", age: 25, active: false };
print(p2.active);  // false (√ºberschrieben)
```

**Syntax f√ºr optionale Felder:**
- `field?: default_value` - Optional mit Standard
- `field?: type` - Optional mit Typannotation, Standard ist null
- Optionale Felder werden beim Duck-Typing hinzugef√ºgt, falls fehlend

### Typpr√ºfung

```hemlock
define Point {
    x: i32,
    y: i32,
}

let p = { x: 10, y: 20 };
let point: Point = p;  // Typpr√ºfung erfolgt hier

print(typeof(point));  // "Point"
print(typeof(p));      // "object" (Original ist immer noch anonym)
```

**Wann Typpr√ºfung erfolgt:**
- Zum Zuweisungszeitpunkt an typisierte Variable
- Validiert, dass alle erforderlichen Felder vorhanden sind
- Validiert, dass Feldtypen √ºbereinstimmen (mit impliziten Konvertierungen)
- Setzt den Typnamen des Objekts

## Methodensignaturen in Define

Define-Bl√∂cke k√∂nnen Methodensignaturen spezifizieren und erstellen Interface-√§hnliche Vertr√§ge:

### Erforderliche Methoden

```hemlock
define Comparable {
    value: i32,
    fn compare(other: Self): i32;  // Erforderliche Methodensignatur
}

// Objekte m√ºssen die erforderliche Methode bereitstellen
let a: Comparable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};
```

### Optionale Methoden

```hemlock
define Serializable {
    fn serialize(): string;       // Erforderlich
    fn pretty?(): string;         // Optionale Methode (kann fehlen)
}
```

### Der `Self`-Typ

`Self` verweist auf den zu definierenden Typ und erm√∂glicht rekursive Typdefinitionen:

```hemlock
define Cloneable {
    fn clone(): Self;  // Gibt denselben Typ wie das Objekt zur√ºck
}

define Comparable {
    fn compare(other: Self): i32;  // Nimmt denselben Typ als Parameter
    fn equals(other: Self): bool;
}

let item: Cloneable = {
    value: 42,
    clone: fn() {
        return { value: self.value, clone: self.clone };
    }
};
```

### Gemischte Felder und Methoden

```hemlock
define Entity {
    id: i32,
    name: string,
    fn validate(): bool;
    fn serialize(): string;
}

let user: Entity = {
    id: 1,
    name: "Alice",
    validate: fn() { return self.id > 0 && self.name != ""; },
    serialize: fn() { return '{"id":' + self.id + ',"name":"' + self.name + '"}'; }
};
```

## Zusammengesetzte Typen (Schnittmengentypen)

Zusammengesetzte Typen verwenden `&`, um zu verlangen, dass ein Objekt mehrere Typdefinitionen erf√ºllt:

### Grundlegende zusammengesetzte Typen

```hemlock
define HasName { name: string }
define HasAge { age: i32 }

// Zusammengesetzter Typ: Objekt muss ALLE Typen erf√ºllen
let person: HasName & HasAge = { name: "Alice", age: 30 };
```

### Funktionsparameter mit zusammengesetzten Typen

```hemlock
fn greet(p: HasName & HasAge) {
    print(p.name + " ist " + p.age);
}

greet({ name: "Bob", age: 25, city: "NYC" });  // Zus√§tzliche Felder OK
```

### Drei oder mehr Typen

```hemlock
define HasEmail { email: string }

fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}
```

### Typaliasse f√ºr zusammengesetzte Typen

```hemlock
// Benannten Alias f√ºr zusammengesetzten Typ erstellen
type Person = HasName & HasAge;
type Employee = HasName & HasAge & HasEmail;

let emp: Employee = {
    name: "Charlie",
    age: 35,
    email: "charlie@example.com"
};
```

**Duck-Typing mit zusammengesetzten Typen:** Zus√§tzliche Felder sind immer erlaubt - das Objekt muss nur mindestens die von allen Komponententypen geforderten Felder haben.

## JSON-Serialisierung

### Zu JSON serialisieren

Objekte in JSON-Strings konvertieren:

```hemlock
// obj.serialize() - Objekt in JSON-String konvertieren
let obj = { x: 10, y: 20, name: "test" };
let json = obj.serialize();
print(json);  // {"x":10,"y":20,"name":"test"}

// Verschachtelte Objekte
let nested = { inner: { a: 1, b: 2 }, outer: 3 };
print(nested.serialize());  // {"inner":{"a":1,"b":2},"outer":3}
```

### Von JSON deserialisieren

JSON-Strings zur√ºck in Objekte parsen:

```hemlock
// json.deserialize() - JSON-String in Objekt parsen
let json_str = '{"x":10,"y":20,"name":"test"}';
let obj = json_str.deserialize();

print(obj.name);   // "test"
print(obj.x);      // 10
```

### Zyklenerkennung

Zirkulaere Referenzen werden erkannt und verursachen Fehler:

```hemlock
let obj = { x: 10 };
obj.me = obj;  // Zirkulaere Referenz erstellen

obj.serialize();  // FEHLER: serialize() hat zirkulaere Referenz erkannt
```

### Unterstuetzte Typen

JSON-Serialisierung unterst√ºtzt:

- **Zahlen**: i8-i32, u8-u32, f32, f64
- **Booleans**: true, false
- **Strings**: Mit Escape-Sequenzen
- **Null**: null-Wert
- **Objekte**: Verschachtelte Objekte
- **Arrays**: Verschachtelte Arrays

**Nicht unterst√ºtzt:**
- Funktionen (werden still ausgelassen)
- Pointer (Fehler)
- Buffer (Fehler)

### Fehlerbehandlung

Serialisierung und Deserialisierung k√∂nnen Fehler werfen:

```hemlock
// Ungueltiges JSON wirft einen Fehler
try {
    let bad = "kein gueltiges json".deserialize();
} catch (e) {
    print("Parse-Fehler:", e);
}

// Pointer k√∂nnen nicht serialisiert werden
let obj = { ptr: alloc(10) };
try {
    obj.serialize();
} catch (e) {
    print("Serialisierungsfehler:", e);
}
```

### Round-Trip-Beispiel

Vollstaendiges Beispiel f√ºr Serialisierung und Deserialisierung:

```hemlock
define Config {
    host: string,
    port: i32,
    debug: bool
}

// Erstellen und serialisieren
let config: Config = {
    host: "localhost",
    port: 8080,
    debug: true
};
let json = config.serialize();
print(json);  // {"host":"localhost","port":8080,"debug":true}

// Zur√ºck deserialisieren
let restored = json.deserialize();
print(restored.host);  // "localhost"
print(restored.port);  // 8080
```

## Eingebaute Funktionen

### `typeof(value)`

Gibt den Typnamen als String zur√ºck:

```hemlock
let obj = { x: 10 };
print(typeof(obj));  // "object"

define Person { name: string, age: i32 }
let p: Person = { name: "Alice", age: 30 };
print(typeof(p));    // "Person"
```

**Rueckgabewerte:**
- Anonyme Objekte: `"object"`
- Typisierte Objekte: Benutzerdefinierter Typname (z.B. `"Person"`)

## Implementierungsdetails

### Speichermodell

- **Heap-allokiert** - Alle Objekte werden auf dem Heap allokiert
- **Flache Kopie** - Zuweisung kopiert die Referenz, nicht das Objekt
- **Dynamische Felder** - Gespeichert als dynamische Arrays von Name/Wert-Paaren
- **Referenzgez√§hlt** - Objekte werden automatisch freigegeben, wenn der G√ºltigkeitsbereich endet

### Referenzsemantik

```hemlock
let obj1 = { x: 10 };
let obj2 = obj1;  // Flache Kopie (gleiche Referenz)

obj2.x = 20;
print(obj1.x);  // 20 (beide verweisen auf dasselbe Objekt)
```

### Methodenspeicherung

Methoden sind einfach Funktionen, die in Feldern gespeichert sind:

```hemlock
let obj = {
    value: 10,
    method: fn() { return self.value; }
};

// method ist eine Funktion, die in obj.method gespeichert ist
print(typeof(obj.method));  // "function"
```

## G√§ngige Muster

### Muster: Konstruktorfunktion

```hemlock
fn createPerson(name: string, age: i32) {
    return {
        name: name,
        age: age,
        greet: fn() {
            return "Hallo, ich bin " + self.name;
        }
    };
}

let person = createPerson("Alice", 30);
print(person.greet());  // "Hallo, ich bin Alice"
```

### Muster: Objekt-Builder

```hemlock
fn PersonBuilder() {
    return {
        name: null,
        age: null,

        setName: fn(n) {
            self.name = n;
            return self;  // Verkettung erm√∂glichen
        },

        setAge: fn(a) {
            self.age = a;
            return self;
        },

        build: fn() {
            return { name: self.name, age: self.age };
        }
    };
}

let person = PersonBuilder()
    .setName("Alice")
    .setAge(30)
    .build();
```

### Muster: Zustandsobjekt

```hemlock
let state = {
    status: "idle",
    data: null,
    error: null,

    setState: fn(new_status) {
        self.status = new_status;
    },

    setData: fn(new_data) {
        self.data = new_data;
        self.status = "success";
    },

    setError: fn(err) {
        self.error = err;
        self.status = "error";
    }
};
```

### Muster: Konfigurationsobjekt

```hemlock
let config = {
    defaults: {
        timeout: 30,
        retries: 3,
        debug: false
    },

    get: fn(key) {
        if (self.defaults[key] != null) {
            return self.defaults[key];
        }
        return null;
    },

    set: fn(key, value) {
        self.defaults[key] = value;
    }
};
```

## Best Practices

1. **`define` f√ºr Struktur verwenden** - Erwartete Objektstrukturen dokumentieren
2. **Factory-Funktionen bevorzugen** - Objekte mit Konstruktoren erstellen
3. **Objekte einfach halten** - Nicht zu tief verschachteln
4. **`self`-Verwendung dokumentieren** - Methodenverhalten klar machen
5. **Bei Zuweisung validieren** - Duck-Typing verwenden, um Fehler frueh zu erkennen
6. **Zirkulaere Referenzen vermeiden** - Verursachen Serialisierungsfehler
7. **Optionale Felder verwenden** - Sinnvolle Standardwerte bereitstellen

## H√§ufige Fallstricke

### Fallstrick: Referenz vs. Wert

```hemlock
let obj1 = { x: 10 };
let obj2 = obj1;  // Flache Kopie

obj2.x = 20;
print(obj1.x);  // 20 (Ueberraschung! Beide haben sich ge√§ndert)

// Um das zu vermeiden: Neues Objekt erstellen
let obj3 = { x: obj1.x };  // Tiefe Kopie (manuell)
```

### Fallstrick: `self` bei Nicht-Methodenaufrufen

```hemlock
let obj = {
    value: 10,
    method: fn() { return self.value; }
};

// Funktioniert: Als Methode aufgerufen
print(obj.method());  // 10

// FEHLER: Als Funktion aufgerufen
let f = obj.method;
print(f());  // FEHLER: self ist nicht definiert
```

### Fallstrick: Rohe Pointer in Objekten

```hemlock
// Objekte werden automatisch freigegeben, aber rohe Pointer darin NICHT
fn create_objects() {
    let obj = { data: alloc(1000) };  // roher ptr braucht manuelles free
    // obj wird automatisch freigegeben, wenn Bereich endet, aber obj.data leckt!
}

// L√∂sung: Rohe Pointer vor Bereichsende freigeben
fn safe_create() {
    let obj = { data: alloc(1000) };
    // ... obj.data verwenden ...
    free(obj.data);  // Rohen Pointer explizit freigeben
}  // obj selbst wird automatisch freigegeben
```

### Fallstrick: Typverwirrung

```hemlock
let obj = { x: 10 };

define Point { x: i32, y: i32 }

// FEHLER: Fehlendes erforderliches Feld 'y'
let p: Point = obj;
```

## Beispiele

### Beispiel: Vektormathematik

```hemlock
fn createVector(x, y) {
    return {
        x: x,
        y: y,

        add: fn(other) {
            return createVector(
                self.x + other.x,
                self.y + other.y
            );
        },

        length: fn() {
            return sqrt(self.x * self.x + self.y * self.y);
        },

        toString: fn() {
            return "(" + typeof(self.x) + ", " + typeof(self.y) + ")";
        }
    };
}

let v1 = createVector(3, 4);
let v2 = createVector(1, 2);
let v3 = v1.add(v2);

print(v3.toString());  // "(4, 6)"
```

### Beispiel: Einfache Datenbank

```hemlock
fn createDatabase() {
    let records = [];
    let next_id = 1;

    return {
        insert: fn(data) {
            let record = { id: next_id, data: data };
            records.push(record);
            next_id = next_id + 1;
            return record.id;
        },

        find: fn(id) {
            let i = 0;
            while (i < records.length) {
                if (records[i].id == id) {
                    return records[i];
                }
                i = i + 1;
            }
            return null;
        },

        count: fn() {
            return records.length;
        }
    };
}

let db = createDatabase();
let id = db.insert({ name: "Alice", age: 30 });
let record = db.find(id);
print(record.data.name);  // "Alice"
```

### Beispiel: Event-Emitter

```hemlock
fn createEventEmitter() {
    let listeners = {};

    return {
        on: fn(event, handler) {
            if (listeners[event] == null) {
                listeners[event] = [];
            }
            listeners[event].push(handler);
        },

        emit: fn(event, data) {
            if (listeners[event] != null) {
                let i = 0;
                while (i < listeners[event].length) {
                    listeners[event][i](data);
                    i = i + 1;
                }
            }
        }
    };
}

let emitter = createEventEmitter();

emitter.on("message", fn(data) {
    print("Empfangen: " + data);
});

emitter.emit("message", "Hallo!");
```

## Einschr√§nkungen

Aktuelle Einschr√§nkungen:

- **Keine tiefe Kopie** - Verschachtelte Objekte m√ºssen manuell kopiert werden (Spread ist flach)
- **Keine Wertuebergabe** - Objekte werden immer als Referenz √ºbergeben
- **Keine berechneten Eigenschaften** - Keine `{[key]: value}`-Syntax
- **`self` ist schreibgeschuetzt** - Kann `self` in Methoden nicht neu zuweisen
- **Keine Eigenschaftsloeschung** - Felder k√∂nnen nicht entfernt werden, sobald sie hinzugef√ºgt sind

**Hinweis:** Objekte sind referenzgez√§hlt und werden automatisch freigegeben, wenn der G√ºltigkeitsbereich endet. Siehe [Speicherverwaltung](memory.md#internal-reference-counting) f√ºr Details.

## Verwandte Themen

- [Functions](#language-guide-functions) - Methoden sind Funktionen, die in Objekten gespeichert sind
- [Arrays](#language-guide-arrays) - Arrays sind ebenfalls objektaehnlich
- [Types](#language-guide-types) - Duck-Typing und Typdefinitionen
- [Error Handling](#language-guide-error-handling) - Fehlerobjekte werfen

## Siehe auch

- **Duck-Typing**: Siehe CLAUDE.md Abschnitt "Objects" f√ºr Duck-Typing-Details
- **JSON**: Siehe CLAUDE.md f√ºr JSON-Serialisierungsdetails
- **Speicher**: Siehe [Memory](#language-guide-memory) f√ºr Objekt-Allokation


--------------------------------------------------------------------------------
## Runen
--------------------------------------------------------------------------------

# Runes

Runes repraesentieren **Unicode-Codepoints** (U+0000 bis U+10FFFF) als eigenstaendigen Typ f√ºr Zeichenmanipulation in Hemlock. Im Gegensatz zu Bytes (u8) sind Runes vollst√§ndige Unicode-Zeichen, die jedes Zeichen in jeder Sprache oder Emoji darstellen k√∂nnen.

## √úberblick

```hemlock
let ch = 'A';           // Rune-Literal
let emoji = 'üöÄ';       // Multi-Byte-Zeichen als einzelne Rune
print(ch);              // 'A'
print(emoji);           // U+1F680

let s = "Hello " + '!'; // String + Rune Verkettung
let r = '>' + " msg";   // Rune + String Verkettung
```

## Was ist eine Rune?

Eine Rune ist ein **32-Bit-Wert**, der einen Unicode-Codepoint repraesentiert:

- **Bereich:** 0 bis 0x10FFFF (1.114.111 gueltige Codepoints)
- **Kein numerischer Typ** - Wird f√ºr Zeichendarstellung verwendet
- **Unterschiedlich von u8/char** - Runes sind volles Unicode, u8 sind nur Bytes
- **Von String-Indexierung zur√ºckgegeben** - `str[0]` gibt eine Rune zur√ºck, kein Byte

**Warum Runes?**
- Hemlock-Strings sind UTF-8-kodiert
- Ein einzelnes Unicode-Zeichen kann 1-4 Bytes in UTF-8 sein
- Runes erm√∂glichen die Arbeit mit vollstaendigen Zeichen, nicht mit Teilbytes

## Rune-Literale

### Grundlegende Syntax

Einfache Anf√ºhrungszeichen kennzeichnen Rune-Literale:

```hemlock
let a = 'A';            // ASCII-Zeichen
let b = '0';            // Ziffernzeichen
let c = '!';            // Satzzeichen
let d = ' ';            // Leerzeichen
```

### Multi-Byte UTF-8 Zeichen

Runes k√∂nnen jedes Unicode-Zeichen darstellen:

```hemlock
// Emoji
let rocket = 'üöÄ';      // Emoji (U+1F680)
let heart = '‚ù§';        // Herz (U+2764)
let smile = 'üòÄ';       // Grinsendes Gesicht (U+1F600)

// CJK-Zeichen
let chinese = '‰∏≠';     // Chinesisch (U+4E2D)
let japanese = '„ÅÇ';    // Hiragana (U+3042)
let korean = 'Ìïú';      // Hangul (U+D55C)

// Symbole
let check = '‚úì';        // Haekchen (U+2713)
let arrow = '‚Üí';        // Pfeil nach rechts (U+2192)
```

### Escape-Sequenzen

G√§ngige Escape-Sequenzen f√ºr Sonderzeichen:

```hemlock
let newline = '\n';     // Zeilenumbruch (U+000A)
let tab = '\t';         // Tabulator (U+0009)
let backslash = '\\';   // Backslash (U+005C)
let quote = '\'';       // Einfaches Anf√ºhrungszeichen (U+0027)
let dquote = '"';       // Doppeltes Anf√ºhrungszeichen (U+0022)
let null_char = '\0';   // Null-Zeichen (U+0000)
let cr = '\r';          // Wagenruecklauf (U+000D)
```

**Verfuegbare Escape-Sequenzen:**
- `\n` - Zeilenumbruch (Line Feed)
- `\t` - Horizontaler Tabulator
- `\r` - Wagenruecklauf
- `\0` - Null-Zeichen
- `\\` - Backslash
- `\'` - Einfaches Anf√ºhrungszeichen
- `\"` - Doppeltes Anf√ºhrungszeichen

### Unicode-Escapes

Verwenden Sie `\u{XXXXXX}`-Syntax f√ºr Unicode-Codepoints (bis zu 6 Hex-Ziffern):

```hemlock
let rocket = '\u{1F680}';   // üöÄ Emoji via Unicode-Escape
let heart = '\u{2764}';     // ‚ù§ Herz
let ascii = '\u{41}';       // 'A' via Escape
let max = '\u{10FFFF}';     // Maximaler Unicode-Codepoint

// F√ºhrende Nullen optional
let a = '\u{41}';           // Gleich wie '\u{0041}'
let b = '\u{0041}';
```

**Regeln:**
- Bereich: `\u{0}` bis `\u{10FFFF}`
- Hex-Ziffern: 1 bis 6 Ziffern
- Gro√ü-/Kleinschreibung egal: `\u{1F680}` oder `\u{1f680}`
- Werte au√üerhalb des gueltigen Unicode-Bereichs verursachen Fehler

## String + Rune Verkettung

Runes k√∂nnen mit Strings verkettet werden:

```hemlock
// String + Rune
let greeting = "Hello" + '!';       // "Hello!"
let decorated = "Text" + '‚úì';       // "Text‚úì"

// Rune + String
let prefix = '>' + " Nachricht";    // "> Nachricht"
let bullet = '‚Ä¢' + " Element";      // "‚Ä¢ Element"

// Mehrfache Verkettungen
let msg = "Hi " + 'üëã' + " Welt " + 'üåç';  // "Hi üëã Welt üåç"

// Method-Chaining funktioniert
let result = ('>' + " Wichtig").to_upper();  // "> WICHTIG"
```

**Wie es funktioniert:**
- Runes werden automatisch in UTF-8 kodiert
- W√§hrend der Verkettung in Strings konvertiert
- Der String-Verkettungsoperator behandelt dies transparent

## Typkonvertierungen

Runes k√∂nnen in/von anderen Typen konvertiert werden.

### Integer <-> Rune

Konvertieren zwischen Integers und Runes um mit Codepoint-Werten zu arbeiten:

```hemlock
// Integer zu Rune (Codepoint-Wert)
let code: rune = 65;            // 'A' (ASCII 65)
let emoji_code: rune = 128640;  // U+1F680 (üöÄ)

// Rune zu Integer (Codepoint-Wert erhalten)
let r = 'Z';
let value: i32 = r;             // 90 (ASCII-Wert)

let rocket = 'üöÄ';
let code: i32 = rocket;         // 128640 (U+1F680)
```

**Bereichspr√ºfung:**
- Integer zu Rune: Muss in [0, 0x10FFFF] sein
- Werte au√üerhalb des Bereichs verursachen Laufzeitfehler
- Rune zu Integer: Funktioniert immer (gibt Codepoint zur√ºck)

### Rune -> String

Runes k√∂nnen explizit in Strings konvertiert werden:

```hemlock
// Explizite Konvertierung
let ch: string = 'H';           // "H"
let emoji: string = 'üöÄ';       // "üöÄ"

// Automatisch w√§hrend Verkettung
let s = "" + 'A';               // "A"
let s2 = "x" + 'y' + "z";       // "xyz"
```

### u8 (Byte) -> Rune

Jeder u8-Wert (0-255) kann in Rune konvertiert werden:

```hemlock
// ASCII-Bereich (0-127)
let byte: u8 = 65;
let rune_val: rune = byte;      // 'A'

// Erweitertes ASCII / Latin-1 (128-255)
let extended: u8 = 200;
let r: rune = extended;         // U+00C8 (E)

// Hinweis: Werte 0-127 sind ASCII, 128-255 sind Latin-1
```

### Verkettete Konvertierungen

Typkonvertierungen k√∂nnen verkettet werden:

```hemlock
// i32 -> Rune -> String
let code: i32 = 128512;         // Grinsendes Gesicht Codepoint
let r: rune = code;             // üòÄ
let s: string = r;              // "üòÄ"

// Alles in einem Ausdruck
let emoji: string = 128640;     // Implizit i32 -> Rune -> String (üöÄ)
```

## Rune-Operationen

### Ausgabe

Wie Runes angezeigt werden haengt vom Codepoint ab:

```hemlock
let ascii = 'A';
print(ascii);                   // 'A' (in Anf√ºhrungszeichen, druckbares ASCII)

let emoji = 'üöÄ';
print(emoji);                   // U+1F680 (Unicode-Notation f√ºr Nicht-ASCII)

let tab = '\t';
print(tab);                     // U+0009 (nicht-druckbar als Hex)

let space = ' ';
print(space);                   // ' ' (druckbar)
```

**Ausgabeformat:**
- Druckbares ASCII (32-126): Zeichen in Anf√ºhrungszeichen `'A'`
- Nicht-druckbar oder Unicode: Hex-Notation `U+XXXX`

### Typpr√ºfung

Verwenden Sie `typeof()` um zu pr√ºfen ob ein Wert eine Rune ist:

```hemlock
let r = 'üöÄ';
print(typeof(r));               // "rune"

let s = "text";
let ch = s[0];
print(typeof(ch));              // "rune" (Indexierung gibt Runes zur√ºck)

let num = 65;
print(typeof(num));             // "i32"
```

### Vergleich

Runes k√∂nnen auf Gleichheit verglichen werden:

```hemlock
let a = 'A';
let b = 'B';
print(a == a);                  // true
print(a == b);                  // false

// Gro√ü-/Kleinschreibung sensitiv
let upper = 'A';
let lower = 'a';
print(upper == lower);          // false

// Runes k√∂nnen mit Integers verglichen werden (Codepoint-Werte)
print(a == 65);                 // true (implizite Konvertierung)
print('üöÄ' == 128640);          // true
```

**Vergleichsoperatoren:**
- `==` - Gleich
- `!=` - Ungleich
- `<`, `>`, `<=`, `>=` - Codepoint-Reihenfolge

```hemlock
print('A' < 'B');               // true (65 < 66)
print('a' > 'Z');               // true (97 > 90)
```

## Arbeiten mit String-Indexierung

String-Indexierung gibt Runes zur√ºck, keine Bytes:

```hemlock
let s = "HelloüöÄ";
let h = s[0];                   // 'H' (Rune)
let rocket = s[5];              // 'üöÄ' (Rune)

print(typeof(h));               // "rune"
print(typeof(rocket));          // "rune"

// Bei Bedarf in String konvertieren
let h_str: string = h;          // "H"
let rocket_str: string = rocket; // "üöÄ"
```

**Wichtig:** String-Indexierung verwendet Codepoint-Positionen, keine Byte-Offsets:

```hemlock
let text = "HiüöÄ!";
// Codepoint-Positionen: 0='H', 1='i', 2='üöÄ', 3='!'
// Byte-Positionen:      0='H', 1='i', 2-5='üöÄ', 6='!'

let r = text[2];                // 'üöÄ' (Codepoint 2)
print(typeof(r));               // "rune"
```

## Beispiele

### Beispiel: Zeichenklassifikation

```hemlock
fn is_digit(r: rune): bool {
    return r >= '0' && r <= '9';
}

fn is_upper(r: rune): bool {
    return r >= 'A' && r <= 'Z';
}

fn is_lower(r: rune): bool {
    return r >= 'a' && r <= 'z';
}

print(is_digit('5'));           // true
print(is_upper('A'));           // true
print(is_lower('z'));           // true
```

### Beispiel: Gro√ü-/Kleinschreibung Konvertierung

```hemlock
fn to_upper_rune(r: rune): rune {
    if (r >= 'a' && r <= 'z') {
        // In Grossbuchstaben konvertieren (32 subtrahieren)
        let code: i32 = r;
        code = code - 32;
        return code;
    }
    return r;
}

fn to_lower_rune(r: rune): rune {
    if (r >= 'A' && r <= 'Z') {
        // In Kleinbuchstaben konvertieren (32 addieren)
        let code: i32 = r;
        code = code + 32;
        return code;
    }
    return r;
}

print(to_upper_rune('a'));      // 'A'
print(to_lower_rune('Z'));      // 'z'
```

### Beispiel: Zeichen-Iteration

```hemlock
fn print_chars(s: string) {
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        print("Position " + typeof(i) + ": " + typeof(ch));
        i = i + 1;
    }
}

print_chars("HiüöÄ");
// Position 0: 'H'
// Position 1: 'i'
// Position 2: U+1F680
```

### Beispiel: Strings aus Runes bauen

```hemlock
fn repeat_char(ch: rune, count: i32): string {
    let result = "";
    let i = 0;
    while (i < count) {
        result = result + ch;
        i = i + 1;
    }
    return result;
}

let line = repeat_char('=', 40);  // "========================================"
let stars = repeat_char('‚≠ê', 5);  // "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê"
```

## G√§ngige Muster

### Muster: Zeichenfilter

```hemlock
fn filter_digits(s: string): string {
    let result = "";
    let i = 0;
    while (i < s.length) {
        let ch = s[i];
        if (ch >= '0' && ch <= '9') {
            result = result + ch;
        }
        i = i + 1;
    }
    return result;
}

let text = "abc123def456";
let digits = filter_digits(text);  // "123456"
```

### Muster: Zeichen zaehlen

```hemlock
fn count_char(s: string, target: rune): i32 {
    let count = 0;
    let i = 0;
    while (i < s.length) {
        if (s[i] == target) {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

let text = "hello world";
let l_count = count_char(text, 'l');  // 3
let o_count = count_char(text, 'o');  // 2
```

## Best Practices

1. **Runes f√ºr Zeichenoperationen verwenden** - Versuchen Sie nicht mit Bytes f√ºr Text zu arbeiten
2. **String-Indexierung gibt Runes zur√ºck** - Denken Sie daran dass `str[i]` Ihnen eine Rune gibt
3. **Unicode-bewusste Vergleiche** - Runes behandeln jedes Unicode-Zeichen
4. **Bei Bedarf konvertieren** - Runes konvertieren einfach in Strings und Integers
5. **Mit Emoji testen** - Testen Sie Zeichenoperationen immer mit Multi-Byte-Zeichen

## H√§ufige Fallstricke

### Fallstrick: Rune vs. Byte Verwechslung

```hemlock
// NICHT: Runes als Bytes behandeln
let r: rune = 'üöÄ';
let b: u8 = r;              // FEHLER: Rune-Codepoint 128640 passt nicht in u8

// RICHTIG: Passende Konvertierungen verwenden
let r: rune = 'üöÄ';
let code: i32 = r;          // OK: 128640
```

### Fallstrick: String Byte-Indexierung

```hemlock
// NICHT: Byte-Indexierung annehmen
let s = "üöÄ";
let byte = s.byte_at(0);    // 240 (erstes UTF-8 Byte, nicht vollstaendiges Zeichen)

// RICHTIG: Codepoint-Indexierung verwenden
let s = "üöÄ";
let rune = s[0];            // 'üöÄ' (vollstaendiges Zeichen)
let rune2 = s.char_at(0);   // 'üöÄ' (explizite Methode)
```

## Verwandte Themen

- [Strings](#language-guide-strings) - String-Operationen und UTF-8-Behandlung
- [Types](#language-guide-types) - Typsystem und Konvertierungen
- [Control Flow](#language-guide-control-flow) - Verwendung von Runes in Vergleichen

## Siehe auch

- **Unicode-Standard**: Unicode-Codepoints werden vom Unicode Consortium definiert
- **UTF-8-Kodierung**: Siehe [Strings](#language-guide-strings) f√ºr UTF-8-Details
- **Typkonvertierungen**: Siehe [Types](#language-guide-types) f√ºr Konvertierungsregeln


--------------------------------------------------------------------------------
## Speicherverwaltung
--------------------------------------------------------------------------------

# Speicherverwaltung

Hemlock setzt auf **manuelle Speicherverwaltung** mit expliziter Kontrolle √ºber Allokation und Deallokation. Dieser Leitfaden behandelt Hemlocks Speichermodell, die zwei Zeigertypen und die vollst√§ndige Speicher-API.

---

## Speicher 101: Die Grundlagen

**Neu in der Programmierung?** Beginnen Sie hier. Wenn Sie Speicherverwaltung bereits verstehen, springen Sie zu [Philosophie](#philosophie).

### Was ist Speicherverwaltung?

Wenn Ihr Programm Daten speichern muss (Text, Zahlen, Listen), braucht es Platz dafuer. Dieser Platz kommt aus dem Arbeitsspeicher Ihres Computers (RAM). Bei der Speicherverwaltung geht es um:

1. **Platz bekommen** - Speicher anfordern, wenn Sie ihn brauchen
2. **Platz nutzen** - Ihre Daten lesen und schreiben
3. **Zur√ºckgeben** - Speicher zur√ºckgeben, wenn Sie fertig sind

### Warum ist das wichtig?

Stellen Sie sich eine Bibliothek mit begrenzten Buechern vor:
- Wenn Sie st√§ndig Buecher ausleihen und nie zur√ºckgeben, gibt es irgendwann keine mehr
- Wenn Sie versuchen, ein bereits zurueckgegebenes Buch zu lesen, werden Sie verwirrt oder verursachen Probleme

Speicher funktioniert genauso. Wenn Sie vergessen, Speicher zur√ºckzugeben, verbraucht Ihr Programm langsam immer mehr (ein "Speicherleck"). Wenn Sie versuchen, Speicher nach der R√ºckgabe zu nutzen, passieren schlimme Dinge.

### Die gute Nachricht

**Meistens m√ºssen Sie nicht darueber nachdenken!**

Hemlock raumt die meisten gaengigen Typen automatisch auf:

```hemlock
fn example() {
    let name = "Alice";       // Hemlock verwaltet dies
    let numbers = [1, 2, 3];  // Und dies
    let person = { age: 30 }; // Und dies auch

    // Wenn die Funktion endet, wird alles automatisch aufgeraeumt!
}
```

### Wann Sie darueber nachdenken MUESSEN

Sie brauchen manuelle Speicherverwaltung nur bei der Verwendung von:

1. **`alloc()`** - rohe Speicherallokation (gibt `ptr` zur√ºck)
2. **`buffer()`** - wenn Sie frueh freigeben m√∂chten (optional - wird am Scope-Ende automatisch freigegeben)

```hemlock
// Dies braucht manuelle Bereinigung:
let raw = alloc(100);   // Roher Speicher - SIE m√ºssen ihn freigeben
// ... raw verwenden ...
free(raw);              // Erforderlich! Sonst haben Sie ein Speicherleck

// Dies wird automatisch aufgeraeumt (aber Sie KOENNEN frueh freigeben):
let buf = buffer(100);  // Sicherer Buffer
// ... buf verwenden ...
// free(buf);           // Optional - wird automatisch freigegeben wenn Scope endet
```

### Die einfache Regel

> **Wenn Sie `alloc()` aufrufen, m√ºssen Sie `free()` aufrufen.**
>
> Alles andere wird f√ºr Sie erledigt.

### Was sollten Sie verwenden?

| Situation | Verwenden Sie dies | Warum |
|-----------|-------------------|-------|
| **Gerade erst angefangen** | `buffer()` | Sicher, mit Bereichspr√ºfung, automatische Bereinigung |
| **Byte-Speicherung ben√∂tigt** | `buffer()` | Sicher und einfach |
| **Arbeit mit C-Bibliotheken (FFI)** | `alloc()` / `ptr` | Erforderlich f√ºr C-Interop |
| **Maximale Leistung** | `alloc()` / `ptr` | Kein Overhead durch Bereichspr√ºfung |
| **Nicht sicher** | `buffer()` | Immer die sicherere Wahl |

### Schnelles Beispiel: Sicher vs Roh

```hemlock
// EMPFOHLEN: Sicherer Buffer
fn safe_example() {
    let data = buffer(10);
    data[0] = 65;           // OK
    data[5] = 66;           // OK
    // data[100] = 67;      // FEHLER - Hemlock stoppt Sie (Bereichspr√ºfung)
    free(data);             // Aufraeumen
}

// FORTGESCHRITTEN: Roher Zeiger (nur wenn Sie ihn brauchen)
fn raw_example() {
    let data = alloc(10);
    *data = 65;             // OK
    *(data + 5) = 66;       // OK
    *(data + 100) = 67;     // GEFAHR - Keine Bereichspr√ºfung, beschaedigt Speicher!
    free(data);             // Aufraeumen
}
```

**Beginnen Sie mit `buffer()`. Verwenden Sie `alloc()` nur, wenn Sie speziell rohe Zeiger brauchen.**

---

## Philosophie

Hemlock folgt dem Prinzip der expliziten Speicherverwaltung mit vernuenftigen Standardeinstellungen:
- Keine Garbage Collection (keine unvorhersehbaren Pausen)
- Internes Referenzzaehlen f√ºr g√§ngige Typen (String, Array, Object, Buffer)
- Rohe Zeiger (`ptr`) erfordern manuelles `free()`

Dieser hybride Ansatz gibt Ihnen vollst√§ndige Kontrolle, wenn n√∂tig (rohe Zeiger), w√§hrend er g√§ngige Fehler f√ºr typische Anwendungsfaelle verhindert (referenzgezaehlte Typen werden beim Scope-Ende automatisch freigegeben).

## Internes Referenzzaehlen

Die Laufzeitumgebung verwendet **internes Referenzzaehlen** zur Verwaltung von Objektlebenszeiten. F√ºr die meisten lokalen Variablen referenzgezaehlter Typen ist die Bereinigung automatisch und deterministisch.

### Was Referenzzaehlen handhabt

Die Laufzeitumgebung verwaltet Referenzzaehler automatisch, wenn:

1. **Variablen neu zugewiesen werden** - der alte Wert wird freigegeben:
   ```hemlock
   let x = "first";   // ref_count = 1
   x = "second";      // "first" wird intern freigegeben, "second" ref_count = 1
   ```

2. **Scopes beendet werden** - lokale Variablen werden freigegeben:
   ```hemlock
   fn example() {
       let arr = [1, 2, 3];  // ref_count = 1
   }  // arr wird freigegeben wenn Funktion zur√ºckkehrt
   ```

3. **Container freigegeben werden** - Elemente werden freigegeben:
   ```hemlock
   let arr = [obj1, obj2];
   free(arr);  // ref_counts von obj1 und obj2 werden dekrementiert
   ```

### Wann Sie `free()` brauchen vs Wann es automatisch ist

**Automatisch (kein `free()` n√∂tig):** Lokale Variablen referenzgezaehlter Typen werden freigegeben, wenn der Scope endet:

```hemlock
fn process_data() {
    let arr = [1, 2, 3];
    let obj = { name: "test" };
    let buf = buffer(64);
    // ... verwenden ...
}  // Alles wird automatisch freigegeben wenn Funktion zur√ºckkehrt - kein free() n√∂tig
```

**Manuelles `free()` erforderlich:**

1. **Rohe Zeiger** - `alloc()` hat kein Referenzzaehlen:
   ```hemlock
   let p = alloc(64);
   // ... p verwenden ...
   free(p);  // Immer erforderlich - leckt sonst
   ```

2. **Fruehe Bereinigung** - vor Scope-Ende freigeben um Speicher frueher freizugeben:
   ```hemlock
   fn long_running() {
       let big = buffer(10000000);  // 10MB
       // ... fertig mit big ...
       free(big);  // Jetzt freigeben, nicht auf Funktionsrueckkehr warten
       // ... mehr Arbeit die big nicht braucht ...
   }
   ```

3. **Langlebige Daten** - globale oder in persistenten Strukturen gespeicherte Daten:
   ```hemlock
   let cache = {};  // Modul-Ebene, lebt bis Programmende wenn nicht freigegeben

   fn cleanup() {
       free(cache);  // Manuelle Bereinigung f√ºr langlebige Daten
   }
   ```

### Referenzzaehlen vs Garbage Collection

| Aspekt | Hemlock Referenzzaehlen | Garbage Collection |
|--------|------------------------|-------------------|
| Bereinigungszeitpunkt | Deterministisch (sofort wenn ref 0 erreicht) | Nicht-deterministisch (GC entscheidet wann) |
| Benutzerverantwortung | Muss `free()` aufrufen | Vollautomatisch |
| Laufzeitpausen | Keine | "Stop the World"-Pausen |
| Sichtbarkeit | Verstecktes Implementierungsdetail | Normalerweise unsichtbar |
| Zyklen | Mit visited-set Tracking behandelt | Durch Tracing behandelt |

### Welche Typen haben Referenzzaehlen

| Typ | Referenzgez√§hlt | Anmerkungen |
|-----|-----------------|-------------|
| `ptr` | Nein | Erfordert immer manuelles `free()` |
| `buffer` | Ja | Auto-Freigabe bei Scope-Ende; manuelles `free()` f√ºr fruehe Bereinigung |
| `array` | Ja | Auto-Freigabe bei Scope-Ende; manuelles `free()` f√ºr fruehe Bereinigung |
| `object` | Ja | Auto-Freigabe bei Scope-Ende; manuelles `free()` f√ºr fruehe Bereinigung |
| `string` | Ja | Vollautomatisch, kein `free()` n√∂tig |
| `function` | Ja | Vollautomatisch (Closure-Umgebungen) |
| `task` | Ja | Thread-sicheres atomares Referenzzaehlen |
| `channel` | Ja | Thread-sicheres atomares Referenzzaehlen |
| Primitive | Nein | Stack-allokiert, keine Heap-Allokation |

### Warum dieses Design?

Dieser hybride Ansatz gibt Ihnen:
- **Explizite Kontrolle** - Sie entscheiden, wann deallokiert wird
- **Sicherheit vor Scope-Fehlern** - Neuzuweisung leckt nicht
- **Vorhersagbare Leistung** - Keine GC-Pausen
- **Closure-Unterst√ºtzung** - Funktionen k√∂nnen sicher Variablen erfassen

Die Philosophie bleibt: Sie haben die Kontrolle, aber die Laufzeit hilft, g√§ngige Fehler wie Lecks bei Neuzuweisung oder Doppel-Freigabe in Containern zu verhindern.

## Die zwei Zeigertypen

Hemlock bietet zwei unterschiedliche Zeigertypen, jeder mit verschiedenen Sicherheitseigenschaften:

### `ptr` - Roher Zeiger (Gefaehrlich)

Rohe Zeiger sind **nur Adressen** mit minimalen Sicherheitsgarantien:

```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // Sie m√ºssen daran denken freizugeben
```

**Eigenschaften:**
- Nur eine 8-Byte-Adresse
- Keine Bereichspr√ºfung
- Keine Laengenverfolgung
- Benutzer verwaltet Lebensdauer vollst√§ndig
- F√ºr Experten und FFI

**Anwendungsfaelle:**
- Low-Level-Systemprogrammierung
- Foreign Function Interface (FFI)
- Leistungskritischer Code
- Wenn Sie vollst√§ndige Kontrolle brauchen

**Gefahren:**
```hemlock
let p = alloc(10);
let q = p + 100;  // Weit √ºber Allokation hinaus - erlaubt aber gefaehrlich
free(p);
let x = *p;       // Dangling Pointer - undefiniertes Verhalten
free(p);          // Double-Free - wird abstuerzen
```

### `buffer` - Sichere Huelle (Empfohlen)

Buffer bieten **bereichsgeprueften Zugriff** w√§hrend sie weiterhin manuelle Deallokation erfordern:

```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // bereichsgeprueft
print(b.length);        // 64
free(b);                // weiterhin manuell
```

**Eigenschaften:**
- Zeiger + L√§nge + Kapazit√§t
- Bereichsgeprueft bei Zugriff
- Erfordert weiterhin manuelles `free()`
- Bessere Standardwahl f√ºr den meisten Code

**Properties:**
```hemlock
let buf = buffer(100);
print(buf.length);      // 100 (aktuelle Gr√∂√üe)
print(buf.capacity);    // 100 (allokierte Kapazit√§t)
```

**Bereichspr√ºfung:**
```hemlock
let buf = buffer(10);
buf[5] = 42;      // OK
buf[100] = 42;    // FEHLER: Index au√üerhalb der Grenzen
```

## Speicher-API

### Kernallokation

**`alloc(bytes)` - Rohen Speicher allokieren**
```hemlock
let p = alloc(1024);  // 1KB allokieren, gibt ptr zur√ºck
// ... Speicher verwenden
free(p);
```

**`buffer(size)` - Sicheren Buffer allokieren**
```hemlock
let buf = buffer(256);  // 256-Byte-Buffer allokieren
buf[0] = 65;            // 'A'
buf[1] = 66;            // 'B'
free(buf);
```

**`free(ptr)` - Speicher freigeben**
```hemlock
let p = alloc(100);
free(p);  // Muss freigegeben werden um Speicherleck zu vermeiden

let buf = buffer(100);
free(buf);  // Funktioniert sowohl f√ºr ptr als auch buffer
```

**Wichtig:** `free()` funktioniert sowohl f√ºr `ptr`- als auch f√ºr `buffer`-Typen.

### Speicheroperationen

**`memset(ptr, byte, size)` - Speicher fuellen**
```hemlock
let p = alloc(100);
memset(p, 0, 100);     // 100 Bytes nullen
memset(p, 65, 10);     // Erste 10 Bytes mit 'A' fuellen
free(p);
```

**`memcpy(dest, src, size)` - Speicher kopieren**
```hemlock
let src = alloc(50);
let dst = alloc(50);
memset(src, 42, 50);
memcpy(dst, src, 50);  // 50 Bytes von src nach dst kopieren
free(src);
free(dst);
```

**`realloc(ptr, size)` - Allokation anpassen**
```hemlock
let p = alloc(100);
// ... 100 Bytes verwenden
p = realloc(p, 200);   // Auf 200 Bytes anpassen
// ... 200 Bytes verwenden
free(p);
```

**Hinweis:** Nach `realloc()` kann der alte Zeiger ung√ºltig sein. Verwenden Sie immer den zurueckgegebenen Zeiger.

### Typisierte Allokation

Hemlock bietet typisierte Allokationshelfer f√ºr Bequemlichkeit:

```hemlock
let arr = talloc(i32, 100);  // 100 i32-Werte allokieren (400 Bytes)
let size = sizeof(i32);      // Gibt 4 zur√ºck (Bytes)
```

**`sizeof(type)`** gibt die Gr√∂√üe in Bytes eines Typs zur√ºck:
- `sizeof(i8)` / `sizeof(u8)` -> 1
- `sizeof(i16)` / `sizeof(u16)` -> 2
- `sizeof(i32)` / `sizeof(u32)` / `sizeof(f32)` -> 4
- `sizeof(i64)` / `sizeof(u64)` / `sizeof(f64)` -> 8
- `sizeof(ptr)` -> 8 (auf 64-Bit-Systemen)

**`talloc(type, count)`** allokiert `count` Elemente vom Typ `type`:

```hemlock
let ints = talloc(i32, 10);   // 40 Bytes f√ºr 10 i32-Werte
let floats = talloc(f64, 5);  // 40 Bytes f√ºr 5 f64-Werte
free(ints);
free(floats);
```

## G√§ngige Muster

### Muster: Allokieren, Verwenden, Freigeben

Das grundlegende Muster f√ºr Speicherverwaltung:

```hemlock
// 1. Allokieren
let data = alloc(1024);

// 2. Verwenden
memset(data, 0, 1024);
// ... Arbeit erledigen

// 3. Freigeben
free(data);
```

### Muster: Sichere Buffer-Verwendung

Bevorzugen Sie Buffer f√ºr bereichsgeprueften Zugriff:

```hemlock
let buf = buffer(256);

// Sichere Iteration
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

free(buf);
```

### Muster: Ressourcenverwaltung mit try/finally

Sicherstellen der Bereinigung auch bei Fehlern:

```hemlock
let data = alloc(1024);
try {
    // ... riskante Operationen
    process(data);
} finally {
    free(data);  // Immer freigegeben, auch bei Fehler
}
```

## Ueberlegungen zur Speichersicherheit

### Double-Free

**Erlaubt aber wird abstuerzen:**
```hemlock
let p = alloc(100);
free(p);
free(p);  // ABSTURZ: Double-Free erkannt
```

**Praevention:**
```hemlock
let p = alloc(100);
free(p);
p = null;  // Nach Freigabe auf null setzen

if (p != null) {
    free(p);  // Wird nicht ausgef√ºhrt
}
```

### Dangling Pointers

**Erlaubt aber undefiniertes Verhalten:**
```hemlock
let p = alloc(100);
*p = 42;      // OK
free(p);
let x = *p;   // UNDEFINIERT: Lesen von freigegebenem Speicher
```

**Praevention:** Greifen Sie nach der Freigabe nicht auf Speicher zu.

### Speicherlecks

**Leicht zu erstellen, schwer zu debuggen:**
```hemlock
fn leak_memory() {
    let p = alloc(1000);
    // Vergessen freizugeben!
    return;  // Speicher leckt
}
```

**Praevention:** Paaren Sie immer `alloc()` mit `free()`:
```hemlock
fn safe_function() {
    let p = alloc(1000);
    try {
        // ... p verwenden
    } finally {
        free(p);  // Immer freigegeben
    }
}
```

### Zeigerarithmetik

**Erlaubt aber gefaehrlich:**
```hemlock
let p = alloc(10);
let q = p + 100;  // Weit √ºber Allokationsgrenze hinaus
*q = 42;          // UNDEFINIERT: Schreiben au√üerhalb der Grenzen
free(p);
```

**Verwenden Sie Buffer f√ºr Bereichspr√ºfung:**
```hemlock
let buf = buffer(10);
buf[100] = 42;  // FEHLER: Bereichspr√ºfung verhindert √úberlauf
```

## Best Practices

1. **Standardm√§√üig `buffer`** - Verwenden Sie `buffer` au√üer Sie brauchen speziell rohe `ptr`
2. **alloc/free abgleichen** - Jedes `alloc()` sollte genau ein `free()` haben
3. **try/finally verwenden** - Bereinigung mit Ausnahmebehandlung sicherstellen
4. **Nach free auf null setzen** - Zeiger nach Freigabe auf `null` setzen um Use-after-free zu erkennen
5. **Bereichspr√ºfung** - Buffer-Indexierung f√ºr automatische Bereichspr√ºfung verwenden
6. **Ownership dokumentieren** - Klar machen, welcher Code jede Allokation besitzt und freigibt

## Beispiele

### Beispiel: Dynamischer String Builder

```hemlock
fn build_message(count: i32): ptr {
    let size = count * 10;
    let buf = alloc(size);

    let i = 0;
    while (i < count) {
        memset(buf + (i * 10), 65 + i, 10);
        i = i + 1;
    }

    return buf;  // Aufrufer muss freigeben
}

let msg = build_message(5);
// ... msg verwenden
free(msg);
```

### Beispiel: Sichere Array-Operationen

```hemlock
fn process_array(size: i32) {
    let arr = buffer(size);

    try {
        // Array fuellen
        let i = 0;
        while (i < arr.length) {
            arr[i] = i * 2;
            i = i + 1;
        }

        // Verarbeiten
        i = 0;
        while (i < arr.length) {
            print(arr[i]);
            i = i + 1;
        }
    } finally {
        free(arr);  // Immer aufraeumen
    }
}
```

### Beispiel: Memory Pool Muster

```hemlock
// Einfacher Memory Pool (vereinfacht)
let pool = alloc(10000);
let pool_offset = 0;

fn pool_alloc(size: i32): ptr {
    if (pool_offset + size > 10000) {
        throw "Pool erschoepft";
    }

    let ptr = pool + pool_offset;
    pool_offset = pool_offset + size;
    return ptr;
}

// Pool verwenden
let p1 = pool_alloc(100);
let p2 = pool_alloc(200);

// Gesamten Pool auf einmal freigeben
free(pool);
```

## Einschr√§nkungen

Aktuelle Einschr√§nkungen, die zu beachten sind:

- **Rohe Zeiger erfordern manuelles free** - `alloc()` gibt `ptr` ohne Referenzzaehlen zur√ºck
- **Keine benutzerdefinierten Allokatoren** - Nur System malloc/free

**Hinweis:** Referenzgezaehlte Typen (String, Array, Object, Buffer) werden automatisch freigegeben, wenn der Scope endet. Nur rohe `ptr` von `alloc()` erfordert explizites `free()`.

## Verwandte Themen

- [Strings](#language-guide-strings) - String-Speicherverwaltung und UTF-8-Kodierung
- [Arrays](#language-guide-arrays) - Dynamische Arrays und ihre Speichereigenschaften
- [Objects](#language-guide-objects) - Objekt-Allokation und Lebensdauer
- [Error Handling](#language-guide-error-handling) - Verwendung von try/finally f√ºr Bereinigung

## Siehe auch

- **Design-Philosophie**: Siehe CLAUDE.md Abschnitt "Memory Management"
- **Typsystem**: Siehe [Types](#language-guide-types) f√ºr `ptr` und `buffer` Typdetails
- **FFI**: Rohe Zeiger sind essentiell f√ºr Foreign Function Interface


--------------------------------------------------------------------------------
## Syntax
--------------------------------------------------------------------------------

# Syntax-√úbersicht

Dieses Dokument behandelt die grundlegenden Syntaxregeln und die Struktur von Hemlock-Programmen.

## Grundlegende Syntaxregeln

### Semikolons sind erforderlich

Im Gegensatz zu JavaScript oder Python sind Semikolons **immer erforderlich** am Ende von Anweisungen:

```hemlock
let x = 42;
let y = 10;
print(x + y);
```

**Dies verursacht einen Fehler:**
```hemlock
let x = 42  // FEHLER: Fehlendes Semikolon
let y = 10  // FEHLER: Fehlendes Semikolon
```

### Geschweifte Klammern sind immer erforderlich

Alle Kontrollfluss-Bl√∂cke m√ºssen geschweifte Klammern verwenden, auch bei einzelnen Anweisungen:

```hemlock
// RICHTIG
if (x > 0) {
    print("positiv");
}

// FEHLER: Fehlende Klammern
if (x > 0)
    print("positiv");
```

### Kommentare

```hemlock
// Dies ist ein einzeiliger Kommentar

/*
   Dies ist ein
   mehrzeiliger Kommentar
*/

let x = 42;  // Inline-Kommentar
```

## Variablen

### Deklaration

Variablen werden mit `let` deklariert:

```hemlock
let count = 0;
let name = "Alice";
let pi = 3.14159;
```

### Typannotationen (Optional)

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let flag: bool = true;
let text: string = "hallo";
```

### Konstanten

Verwenden Sie `const` f√ºr unver√§nderliche Werte:

```hemlock
const MAX_SIZE: i32 = 1000;
const PI: f64 = 3.14159;
```

Der Versuch, eine Konstante neu zuzuweisen, f√ºhrt zu einem Laufzeitfehler: "Cannot assign to const variable".

## Ausdr√ºcke

### Arithmetische Operatoren

```hemlock
let a = 10;
let b = 3;

print(a + b);   // 13 - Addition
print(a - b);   // 7  - Subtraktion
print(a * b);   // 30 - Multiplikation
print(a / b);   // 3  - Division (ganzzahlig)
```

### Vergleichsoperatoren

```hemlock
print(a == b);  // false - Gleich
print(a != b);  // true  - Ungleich
print(a > b);   // true  - Gr√∂√üer als
print(a < b);   // false - Kleiner als
print(a >= b);  // true  - Gr√∂√üer oder gleich
print(a <= b);  // false - Kleiner oder gleich
```

### Logische Operatoren

```hemlock
let x = true;
let y = false;

print(x && y);  // false - UND
print(x || y);  // true  - ODER
print(!x);      // false - NICHT
```

### Bitweise Operatoren

```hemlock
let a = 12;  // 1100
let b = 10;  // 1010

print(a & b);   // 8  - Bitweises UND
print(a | b);   // 14 - Bitweises ODER
print(a ^ b);   // 6  - Bitweises XOR
print(a << 2);  // 48 - Linksverschiebung
print(a >> 1);  // 6  - Rechtsverschiebung
print(~a);      // -13 - Bitweises NICHT
```

### Operatorrangfolge

Von hoechster zu niedrigster Priorit√§t:

1. `()` - Gruppierung
2. `!`, `~`, `-` (unaer) - Unaere Operatoren
3. `*`, `/` - Multiplikation, Division
4. `+`, `-` - Addition, Subtraktion
5. `<<`, `>>` - Bitverschiebungen
6. `<`, `<=`, `>`, `>=` - Vergleiche
7. `==`, `!=` - Gleichheit
8. `&` - Bitweises UND
9. `^` - Bitweises XOR
10. `|` - Bitweises ODER
11. `&&` - Logisches UND
12. `||` - Logisches ODER

**Beispiele:**
```hemlock
let x = 2 + 3 * 4;      // 14 (nicht 20)
let y = (2 + 3) * 4;    // 20
let z = 5 << 2 + 1;     // 40 (5 << 3)
```

## Kontrollfluss

### If-Anweisungen

```hemlock
if (condition) {
    // K√∂rper
}

if (condition) {
    // Then-Zweig
} else {
    // Else-Zweig
}

if (condition1) {
    // Zweig 1
} else if (condition2) {
    // Zweig 2
} else {
    // Standard-Zweig
}
```

### While-Schleifen

```hemlock
while (condition) {
    // K√∂rper
}
```

**Beispiel:**
```hemlock
let i = 0;
while (i < 10) {
    print(i);
    i = i + 1;
}
```

### For-Schleifen

**C-artige for-Schleife:**
```hemlock
for (initializer; condition; increment) {
    // K√∂rper
}
```

**Beispiel:**
```hemlock
for (let i = 0; i < 10; i = i + 1) {
    print(i);
}
```

**For-in (Arrays):**
```hemlock
for (let item in array) {
    // K√∂rper
}
```

**Beispiel:**
```hemlock
let items = [10, 20, 30];
for (let x in items) {
    print(x);
}
```

### Switch-Anweisungen

```hemlock
switch (expression) {
    case value1:
        // K√∂rper
        break;
    case value2:
        // K√∂rper
        break;
    default:
        // Standard-K√∂rper
        break;
}
```

**Beispiel:**
```hemlock
let day = 3;
switch (day) {
    case 1:
        print("Montag");
        break;
    case 2:
        print("Dienstag");
        break;
    case 3:
        print("Mittwoch");
        break;
    default:
        print("Anderer Tag");
        break;
}
```

### Break und Continue

```hemlock
// Break: Schleife verlassen
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        break;
    }
    print(i);
}

// Continue: Zur n√§chsten Iteration springen
for (let i = 0; i < 10; i = i + 1) {
    if (i == 5) {
        continue;
    }
    print(i);
}
```

## Funktionen

### Benannte Funktionen

```hemlock
fn function_name(param1: type1, param2: type2): return_type {
    // K√∂rper
    return value;
}
```

**Beispiel:**
```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Anonyme Funktionen

```hemlock
let func = fn(params) {
    // K√∂rper
};
```

**Beispiel:**
```hemlock
let multiply = fn(x, y) {
    return x * y;
};
```

### Typannotationen (Optional)

```hemlock
// Ohne Annotationen (Typen werden abgeleitet)
fn greet(name) {
    return "Hallo, " + name;
}

// Mit Annotationen (zur Laufzeit gepr√ºft)
fn divide(a: i32, b: i32): f64 {
    return a / b;
}
```

## Objekte

### Objektliterale

```hemlock
let obj = {
    field1: value1,
    field2: value2,
};
```

**Beispiel:**
```hemlock
let person = {
    name: "Alice",
    age: 30,
    active: true,
};
```

### Methoden

```hemlock
let obj = {
    method: fn() {
        self.field = value;
    },
};
```

**Beispiel:**
```hemlock
let counter = {
    count: 0,
    increment: fn() {
        self.count = self.count + 1;
    },
};
```

### Typdefinitionen

```hemlock
define TypeName {
    field1: type1,
    field2: type2,
    optional_field?: default_value,
}
```

**Beispiel:**
```hemlock
define Person {
    name: string,
    age: i32,
    active?: true,
}
```

## Arrays

### Array-Literale

```hemlock
let arr = [element1, element2, element3];
```

**Beispiel:**
```hemlock
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, "zwei", true, null];
let empty = [];
```

### Array-Indizierung

```hemlock
let arr = [10, 20, 30];
print(arr[0]);   // 10
arr[1] = 99;     // Element √§ndern
```

## Fehlerbehandlung

### Try/Catch

```hemlock
try {
    // Riskanter Code
} catch (e) {
    // Fehler behandeln
}
```

### Try/Finally

```hemlock
try {
    // Riskanter Code
} finally {
    // Wird immer ausgef√ºhrt
}
```

### Try/Catch/Finally

```hemlock
try {
    // Riskanter Code
} catch (e) {
    // Fehler behandeln
} finally {
    // Aufraeumen
}
```

### Throw

```hemlock
throw expression;
```

**Beispiel:**
```hemlock
if (x < 0) {
    throw "x muss positiv sein";
}
```

### Panic

```hemlock
panic(message);
```

**Beispiel:**
```hemlock
panic("nicht behebbarer Fehler");
```

## Module (Experimentell)

### Export-Anweisungen

```hemlock
export fn function_name() { }
export const CONSTANT = value;
export let variable = value;
export { name1, name2 };
```

### Import-Anweisungen

```hemlock
import { name1, name2 } from "./module.hml";
import * as namespace from "./module.hml";
import { name as alias } from "./module.hml";
```

## Async (Experimentell)

### Async-Funktionen

```hemlock
async fn function_name(params): return_type {
    // K√∂rper
}
```

### Spawn/Join

```hemlock
let task = spawn(async_function, arg1, arg2);
let result = join(task);
```

### Channels

```hemlock
let ch = channel(capacity);
ch.send(value);
let value = ch.recv();
ch.close();
```

## FFI (Foreign Function Interface)

### Shared Library importieren

```hemlock
import "library_name.so";
```

### Externe Funktion deklarieren

```hemlock
extern fn function_name(param: type): return_type;
```

**Beispiel:**
```hemlock
import "libc.so.6";
extern fn strlen(s: string): i32;
```

## Literale

### Ganzzahl-Literale

```hemlock
let decimal = 42;
let negative = -100;
let large = 5000000000;  // Automatisch i64

// Hexadezimal (0x-Pr√§fix)
let hex = 0xDEADBEEF;
let hex2 = 0xFF;

// Bin√§r (0b-Pr√§fix)
let bin = 0b1010;
let bin2 = 0b11110000;

// Oktal (0o-Pr√§fix)
let oct = 0o777;
let oct2 = 0O123;

// Numerische Trennzeichen f√ºr Lesbarkeit
let million = 1_000_000;
let hex_sep = 0xFF_FF_FF;
let bin_sep = 0b1111_0000_1010_0101;
let oct_sep = 0o77_77;
```

### Gleitkomma-Literale

```hemlock
let f = 3.14;
let e = 2.71828;
let sci = 1.5e-10;       // Wissenschaftliche Notation
let sci2 = 2.5E+3;       // Grosses E funktioniert auch
let no_lead = .5;        // Ohne f√ºhrende Null (0.5)
let sep = 3.14_159_265;  // Numerische Trennzeichen
```

### String-Literale

```hemlock
let s = "hallo";
let escaped = "zeile1\nzeile2\ttabuliert";
let quote = "Sie sagte \"hallo\"";

// Hex-Escape-Sequenzen
let hex_esc = "\x48\x65\x6c\x6c\x6f";  // "Hello"

// Unicode-Escape-Sequenzen
let emoji = "\u{1F600}";               // (Smiley)
let heart = "\u{2764}";                // (Herz)
let mixed = "Hallo \u{1F30D}!";        // Hallo (Erde)!
```

**Escape-Sequenzen:**
- `\n` - Zeilenumbruch
- `\t` - Tabulator
- `\r` - Wagenruecklauf
- `\\` - Backslash
- `\"` - Anf√ºhrungszeichen
- `\'` - Apostroph
- `\0` - Null-Zeichen
- `\xNN` - Hex-Escape (2 Ziffern)
- `\u{XXXX}` - Unicode-Escape (1-6 Ziffern)

### Rune-Literale

```hemlock
let ch = 'A';
let emoji = '(Rakete)';
let escaped = '\n';
let unicode = '\u{1F680}';
let hex_rune = '\x41';      // 'A'
```

### Boolesche Literale

```hemlock
let t = true;
let f = false;
```

### Null-Literal

```hemlock
let nothing = null;
```

## Gueltigkeitsbereichsregeln

### Block-G√ºltigkeitsbereich

Variablen sind auf den n√§chsten umschliessenden Block beschr√§nkt:

```hemlock
let x = 1;  // Aeusserer G√ºltigkeitsbereich

if (true) {
    let x = 2;  // Innerer G√ºltigkeitsbereich (ueberdeckt √§u√üeren)
    print(x);   // 2
}

print(x);  // 1
```

### Funktions-G√ºltigkeitsbereich

Funktionen erstellen ihren eigenen G√ºltigkeitsbereich:

```hemlock
let global = "global";

fn foo() {
    let local = "lokal";
    print(global);  // Kann √§u√üeren G√ºltigkeitsbereich lesen
}

foo();
// print(local);  // FEHLER: 'local' ist hier nicht definiert
```

### Closure-G√ºltigkeitsbereich

Closures erfassen Variablen aus dem umschliessenden G√ºltigkeitsbereich:

```hemlock
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;  // Erfasst 'count'
        return count;
    };
}

let counter = makeCounter();
print(counter());  // 1
print(counter());  // 2
```

## Whitespace und Formatierung

### Einrueckung

Hemlock erzwingt keine bestimmte Einrueckung, aber 4 Leerzeichen werden empfohlen:

```hemlock
fn example() {
    if (true) {
        print("eingerueckt");
    }
}
```

### Zeilenumbrueche

Anweisungen k√∂nnen mehrere Zeilen umfassen:

```hemlock
let result =
    very_long_function_name(
        arg1,
        arg2,
        arg3
    );
```

## Loop-Anweisung

Das `loop`-Schl√ºsselwort bietet eine sauberere Syntax f√ºr Endlosschleifen:

```hemlock
loop {
    // ... Arbeit ausf√ºhren
    if (done) {
        break;
    }
}
```

Dies entspricht `while (true)`, macht aber die Absicht deutlicher.

## Reservierte Schl√ºsselw√∂rter

Die folgenden Schl√ºsselw√∂rter sind in Hemlock reserviert:

```
let, const, fn, if, else, while, for, in, loop, break, continue,
return, true, false, null, typeof, import, export, from,
try, catch, finally, throw, panic, async, await, spawn, join,
detach, channel, define, switch, case, default, extern, self,
type, defer, enum, ref, buffer, Self
```

## N√§chste Schritte

- [Typsystem](#language-guide-types) - Erfahren Sie mehr √ºber das Hemlock-Typsystem
- [Kontrollfluss](#language-guide-control-flow) - Vertiefte Betrachtung der Kontrollstrukturen
- [Funktionen](#language-guide-functions) - Beherrschen Sie Funktionen und Closures
- [Speicherverwaltung](#language-guide-memory) - Verstehen Sie Pointer und Buffer


--------------------------------------------------------------------------------
## Typen
--------------------------------------------------------------------------------

# Typsystem

Hemlock verfuegt √ºber ein **dynamisches Typsystem** mit optionalen Typannotationen und Laufzeit-Typ√ºberpr√ºfung.

---

## Typauswahl-Leitfaden: Welchen Typ sollte ich verwenden?

**Neu bei Typen?** Beginnen Sie hier. Wenn Sie mit Typsystemen vertraut sind, springen Sie zu [Philosophie](#philosophie).

### Die kurze Antwort

**Lassen Sie Hemlock es einfach herausfinden:**

```hemlock
let count = 42;        // Hemlock wei√ü, dass dies eine Ganzzahl ist
let price = 19.99;     // Hemlock wei√ü, dass dies eine Dezimalzahl ist
let name = "Alice";    // Hemlock wei√ü, dass dies Text ist
let active = true;     // Hemlock wei√ü, dass dies ja/nein ist
```

Hemlock waehlt automatisch den richtigen Typ f√ºr Ihre Werte. Sie *m√ºssen* keine Typen angeben.

### Wann Typannotationen hinzuf√ºgen

Fuegen Sie Typen hinzu, wenn Sie:

1. **Genau √ºber die Gr√∂√üe sein wollen** - `i8` vs `i64` ist wichtig f√ºr Speicher oder FFI
2. **Ihren Code dokumentieren** - Typen zeigen, was eine Funktion erwartet
3. **Fehler frueh erkennen wollen** - Hemlock pr√ºft Typen zur Laufzeit

```hemlock
// Ohne Typen (funktioniert gut):
fn add(a, b) {
    return a + b;
}

// Mit Typen (expliziter):
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Schnellreferenz: Zahlentypen w√§hlen

| Was Sie speichern | Empfohlener Typ | Beispiel |
|-------------------|-----------------|----------|
| Normale Ganzzahlen | `i32` (Standard) | `let count = 42;` |
| Sehr gro√üe Zahlen | `i64` | `let population = 8000000000;` |
| Nie-negative Z√§hler | `u32` | `let items: u32 = 100;` |
| Bytes (0-255) | `u8` | `let pixel: u8 = 255;` |
| Dezimalzahlen/Brueche | `f64` (Standard) | `let price = 19.99;` |
| Leistungskritische Dezimalzahlen | `f32` | `let x: f32 = 1.5;` |

### Schnellreferenz: Alle Typen

| Kategorie | Typen | Wann verwenden |
|-----------|-------|----------------|
| **Ganzzahlen** | `i8`, `i16`, `i32`, `i64` | Zaehlen, IDs, Alter, usw. |
| **Nur-positive Zahlen** | `u8`, `u16`, `u32`, `u64` | Bytes, Groessen, Array-L√§ngen |
| **Dezimalzahlen** | `f32`, `f64` | Geld, Messungen, Mathematik |
| **Ja/Nein** | `bool` | Flags, Bedingungen |
| **Text** | `string` | Namen, Nachrichten, jeder Text |
| **Einzelnes Zeichen** | `rune` | Einzelne Buchstaben, Emoji |
| **Listen** | `array` | Sammlungen von Werten |
| **Benannte Felder** | `object` | Gruppierung verwandter Daten |
| **Roher Speicher** | `ptr`, `buffer` | Low-Level-Programmierung |
| **Nichts** | `null` | Abwesenheit eines Wertes |

### H√§ufige Szenarien

**"Ich brauche nur eine Zahl"**
```hemlock
let x = 42;  // Fertig! Hemlock waehlt i32
```

**"Ich brauche Dezimalzahlen"**
```hemlock
let price = 19.99;  // Fertig! Hemlock waehlt f64
```

**"Ich arbeite mit Bytes (Dateien, Netzwerk)"**
```hemlock
let byte: u8 = 255;  // 0-255 Bereich
```

**"Ich brauche wirklich gro√üe Zahlen"**
```hemlock
let big = 9000000000000;  // Hemlock waehlt automatisch i64 (> i32 max)
// Oder explizit:
let big: i64 = 9000000000000;
```

**"Ich speichere Geld"**
```hemlock
// Option 1: Float (einfach, aber hat Praezisionsgrenzen)
let price: f64 = 19.99;

// Option 2: Als Cent speichern (praeziser)
let price_cents: i32 = 1999;  // 19.99 EUR als Ganzzahl-Cent
```

**"Ich uebergebe Daten an C-Code (FFI)"**
```hemlock
// C-Typen genau entsprechen
let c_int: i32 = 100;      // C 'int'
let c_long: i64 = 100;     // C 'long' (auf 64-bit)
let c_char: u8 = 65;       // C 'char'
let c_double: f64 = 3.14;  // C 'double'
```

### Was passiert, wenn Typen gemischt werden?

Wenn Sie verschiedene Typen kombinieren, bef√∂rdert Hemlock zum "groesseren" Typ:

```hemlock
let a: i32 = 10;
let b: f64 = 2.5;
let result = a + b;  // result ist f64 (12.5)
// Die Ganzzahl wurde automatisch zur Dezimalzahl
```

**Faustregel:** Floats "gewinnen" immer - das Mischen einer Ganzzahl mit einem Float ergibt einen Float.

### Typfehler

Wenn Sie versuchen, den falschen Typ zu verwenden, sagt Ihnen Hemlock dies zur Laufzeit:

```hemlock
let age: i32 = "dreissig";  // FEHLER: Typenkonflikt - erwartet i32, erhalten string
```

Um Typen zu konvertieren, verwenden Sie Typ-Konstruktorfunktionen:

```hemlock
let text = "42";
let number = i32(text);   // String zu Ganzzahl parsen: 42
let back = text + "";     // Bereits ein String
```

---

## Philosophie

- **Standardm√§√üig dynamisch** - Jeder Wert hat ein Laufzeit-Typ-Tag
- **Typisiert nach Wahl** - Optionale Typannotationen erzwingen Laufzeitpr√ºfungen
- **Explizite Konvertierungen** - Implizite Konvertierungen folgen klaren Befoerderungsregeln
- **Ehrlich √ºber Typen** - `typeof()` sagt immer die Wahrheit

## Primitive Typen

### Ganzzahltypen

**Vorzeichenbehaftete Ganzzahlen:**
```hemlock
let tiny: i8 = 127;              // 8-Bit  (-128 bis 127)
let small: i16 = 32767;          // 16-Bit (-32768 bis 32767)
let normal: i32 = 2147483647;    // 32-Bit (Standard)
let large: i64 = 9223372036854775807;  // 64-Bit
```

**Vorzeichenlose Ganzzahlen:**
```hemlock
let byte: u8 = 255;              // 8-Bit  (0 bis 255)
let word: u16 = 65535;           // 16-Bit (0 bis 65535)
let dword: u32 = 4294967295;     // 32-Bit (0 bis 4294967295)
let qword: u64 = 18446744073709551615;  // 64-Bit
```

**Typ-Aliase:**
```hemlock
let i: integer = 42;   // Alias f√ºr i32
let b: byte = 255;     // Alias f√ºr u8
```

### Gleitkommatypen

```hemlock
let f: f32 = 3.14159;        // 32-Bit Float
let d: f64 = 2.718281828;    // 64-Bit Float (Standard)
let n: number = 1.618;       // Alias f√ºr f64
```

### Boolescher Typ

```hemlock
let flag: bool = true;
let active: bool = false;
```

### String-Typ

```hemlock
let text: string = "Hallo, Welt!";
let empty: string = "";
```

Strings sind **ver√§nderlich**, **UTF-8-kodiert** und **heap-allokiert**.

Siehe [Strings](#language-guide-strings) f√ºr vollst√§ndige Details.

### Rune-Typ

```hemlock
let ch: rune = 'A';
let emoji: rune = '(Rakete)';
let newline: rune = '\n';
let unicode: rune = '\u{1F680}';
```

Runes repraesentieren **Unicode-Codepoints** (U+0000 bis U+10FFFF).

Siehe [Runes](#language-guide-runes) f√ºr vollst√§ndige Details.

### Null-Typ

```hemlock
let nothing = null;
let uninitialized: string = null;
```

`null` ist sein eigener Typ mit einem einzelnen Wert.

## Zusammengesetzte Typen

### Array-Typ

```hemlock
let numbers: array = [1, 2, 3, 4, 5];
let mixed = [1, "zwei", true, null];  // Gemischte Typen erlaubt
let empty: array = [];
```

Siehe [Arrays](#language-guide-arrays) f√ºr vollst√§ndige Details.

### Object-Typ

```hemlock
let obj: object = { x: 10, y: 20 };
let person = { name: "Alice", age: 30 };
```

Siehe [Objects](#language-guide-objects) f√ºr vollst√§ndige Details.

### Pointer-Typen

**Roher Pointer:**
```hemlock
let p: ptr = alloc(64);
// Keine Grenzpr√ºfung, manuelle Lebenszeitverwaltung
free(p);
```

**Sicherer Buffer:**
```hemlock
let buf: buffer = buffer(64);
// Grenzgeprueft, verfolgt L√§nge und Kapazit√§t
free(buf);
```

Siehe [Speicherverwaltung](#language-guide-memory) f√ºr vollst√§ndige Details.

## Enum-Typen

Enums definieren eine Menge benannter Konstanten:

### Einfache Enums

```hemlock
enum Color {
    RED,
    GREEN,
    BLUE
}

let c = Color.RED;
print(c);              // 0
print(typeof(c));      // "Color"

// Vergleich
if (c == Color.RED) {
    print("Es ist rot!");
}

// Switch auf Enum
switch (c) {
    case Color.RED:
        print("Stopp");
        break;
    case Color.GREEN:
        print("Los");
        break;
    case Color.BLUE:
        print("Blau?");
        break;
}
```

### Enums mit Werten

Enums k√∂nnen explizite Ganzzahlwerte haben:

```hemlock
enum Status {
    OK = 0,
    ERROR = 1,
    PENDING = 2
}

print(Status.OK);      // 0
print(Status.ERROR);   // 1

enum HttpCode {
    OK = 200,
    NOT_FOUND = 404,
    SERVER_ERROR = 500
}

let code = HttpCode.NOT_FOUND;
print(code);           // 404
```

### Auto-inkrementierende Werte

Ohne explizite Werte inkrementieren Enums automatisch von 0:

```hemlock
enum Priority {
    LOW,       // 0
    MEDIUM,    // 1
    HIGH,      // 2
    CRITICAL   // 3
}

// Kann explizite und Auto-Werte mischen
enum Level {
    DEBUG = 10,
    INFO,      // 11
    WARN,      // 12
    ERROR = 50,
    FATAL      // 51
}
```

### Enum-Verwendungsmuster

```hemlock
// Als Funktionsparameter
fn set_priority(p: Priority) {
    if (p == Priority.CRITICAL) {
        print("Dringend!");
    }
}

set_priority(Priority.HIGH);

// In Objekten
define Task {
    name: string,
    priority: Priority
}

let task: Task = {
    name: "Fehler beheben",
    priority: Priority.HIGH
};
```

## Spezielle Typen

### File-Typ

```hemlock
let f: file = open("data.txt", "r");
f.close();
```

Repraesentiert ein offenes Datei-Handle.

### Task-Typ

```hemlock
async fn compute(): i32 { return 42; }
let task = spawn(compute);
let result: i32 = join(task);
```

Repraesentiert ein Async-Task-Handle.

### Channel-Typ

```hemlock
let ch: channel = channel(10);
ch.send(42);
let value = ch.recv();
```

Repraesentiert einen Kommunikationskanal zwischen Tasks.

### Void-Typ

```hemlock
extern fn exit(code: i32): void;
```

Wird f√ºr Funktionen verwendet, die keinen Wert zur√ºckgeben (nur FFI).

## Typinferenz

### Ganzzahl-Literal-Inferenz

Hemlock leitet Ganzzahltypen basierend auf dem Wertebereich ab:

```hemlock
let a = 42;              // i32 (passt in 32-Bit)
let b = 5000000000;      // i64 (> i32 max)
let c = 128;             // i32
let d: u8 = 128;         // u8 (explizite Annotation)
```

**Regeln:**
- Werte im i32-Bereich (-2147483648 bis 2147483647): als `i32` abgeleitet
- Werte au√üerhalb des i32-Bereichs aber innerhalb von i64: als `i64` abgeleitet
- Verwenden Sie explizite Annotationen f√ºr andere Typen (i8, i16, u8, u16, u32, u64)

### Float-Literal-Inferenz

```hemlock
let x = 3.14;        // f64 (Standard)
let y: f32 = 3.14;   // f32 (explizit)
```

### Wissenschaftliche Notation

Hemlock unterst√ºtzt wissenschaftliche Notation f√ºr numerische Literale:

```hemlock
let a = 1e10;        // 10000000000.0 (f64)
let b = 1e-12;       // 0.000000000001 (f64)
let c = 3.14e2;      // 314.0 (f64)
let d = 2.5e-3;      // 0.0025 (f64)
let e = 1E10;        // Gro√ü-/Kleinschreibung egal
let f = 1e+5;        // Explizit positiver Exponent
```

**Hinweis:** Jedes Literal mit wissenschaftlicher Notation wird immer als `f64` abgeleitet.

### Andere Typinferenz

```hemlock
let s = "hallo";     // string
let ch = 'A';        // rune
let flag = true;     // bool
let arr = [1, 2, 3]; // array
let obj = { x: 10 }; // object
let nothing = null;  // null
```

## Typannotationen

### Variablenannotationen

```hemlock
let age: i32 = 30;
let ratio: f64 = 1.618;
let name: string = "Alice";
```

### Funktionsparameter-Annotationen

```hemlock
fn greet(name: string, age: i32) {
    print("Hallo, " + name + "!");
}
```

### Funktions-R√ºckgabetyp-Annotationen

```hemlock
fn add(a: i32, b: i32): i32 {
    return a + b;
}
```

### Object-Typannotationen (Duck Typing)

```hemlock
define Person {
    name: string,
    age: i32,
}

let p: Person = { name: "Bob", age: 25 };
```

## Typ√ºberpr√ºfung

### Laufzeit-Typ√ºberpr√ºfung

Typannotationen werden zur **Laufzeit** gepr√ºft, nicht zur Kompilierzeit:

```hemlock
let x: i32 = 42;     // OK
let y: i32 = 3.14;   // Laufzeitfehler: Typenkonflikt

fn add(a: i32, b: i32): i32 {
    return a + b;
}

add(5, 3);           // OK
add(5, "hallo");     // Laufzeitfehler: Typenkonflikt
```

### Typabfragen

Verwenden Sie `typeof()` um Werttypen zu pr√ºfen:

```hemlock
print(typeof(42));         // "i32"
print(typeof(3.14));       // "f64"
print(typeof("hallo"));    // "string"
print(typeof(true));       // "bool"
print(typeof(null));       // "null"
print(typeof([1, 2, 3]));  // "array"
print(typeof({ x: 10 }));  // "object"
```

## Typkonvertierungen

### Implizite Typbefoerderung

Beim Mischen von Typen in Operationen bef√∂rdert Hemlock zum "hoeheren" Typ:

**Befoerderungshierarchie (niedrigste zu hoechste):**
```
i8 -> i16 -> i32 -> u32 -> i64 -> u64 -> f32 -> f64
      ^      ^      ^
     u8     u16
```

**Float gewinnt immer:**
```hemlock
let x: i32 = 10;
let y: f64 = 3.5;
let result = x + y;  // result ist f64 (13.5)
```

**Gr√∂√üere Gr√∂√üe gewinnt:**
```hemlock
let a: i32 = 100;
let b: i64 = 200;
let sum = a + b;     // sum ist i64 (300)
```

**Praezisionserhaltung:** Beim Mischen von 64-Bit-Ganzzahlen mit f32 bef√∂rdert Hemlock
zu f64, um Praezisionsverlust zu vermeiden (f32 hat nur 24-Bit-Mantisse, unzureichend f√ºr i64/u64):
```hemlock
let big: i64 = 9007199254740993;
let small: f32 = 1.0;
let result = big + small;  // result ist f64, nicht f32!
```

**Beispiele:**
```hemlock
u8 + i32  -> i32
i32 + i64 -> i64
u32 + u64 -> u64
i32 + f32 -> f32    // f32 ausreichend f√ºr i32
i64 + f32 -> f64    // f64 n√∂tig um i64-Pr√§zision zu erhalten
i64 + f64 -> f64
i8 + f64  -> f64
```

### Explizite Typkonvertierung

**Ganzzahl <-> Float:**
```hemlock
let i: i32 = 42;
let f: f64 = i;      // i32 -> f64 (42.0)

let x: f64 = 3.14;
let n: i32 = x;      // f64 -> i32 (3, abgeschnitten)
```

**Ganzzahl <-> Rune:**
```hemlock
let code: i32 = 65;
let ch: rune = code;  // i32 -> rune ('A')

let r: rune = 'Z';
let value: i32 = r;   // rune -> i32 (90)
```

**Rune -> String:**
```hemlock
let ch: rune = '(Rakete)';
let s: string = ch;   // rune -> string ("(Rakete)")
```

**u8 -> Rune:**
```hemlock
let b: u8 = 65;
let r: rune = b;      // u8 -> rune ('A')
```

### Typ-Konstruktorfunktionen

Typnamen k√∂nnen als Funktionen verwendet werden, um Werte zu konvertieren oder zu parsen:

**Strings zu Zahlen parsen:**
```hemlock
let n = i32("42");       // String zu i32 parsen: 42
let f = f64("3.14159");  // String zu f64 parsen: 3.14159
let b = bool("true");    // String zu bool parsen: true

// Alle numerischen Typen unterst√ºtzt
let a = i8("-128");      // Zu i8 parsen
let c = u8("255");       // Zu u8 parsen
let d = i16("1000");     // Zu i16 parsen
let e = u16("50000");    // Zu u16 parsen
let g = i64("9000000000000"); // Zu i64 parsen
let h = u64("18000000000000"); // Zu u64 parsen
let j = f32("1.5");      // Zu f32 parsen
```

**Hex und negative Zahlen:**
```hemlock
let hex = i32("0xFF");   // 255
let neg = i32("-42");    // -42
let bin = i32("0b1010"); // 10 (bin√§r)
```

**Typ-Aliase funktionieren auch:**
```hemlock
let x = integer("100");  // Gleich wie i32("100")
let y = number("1.5");   // Gleich wie f64("1.5")
let z = byte("200");     // Gleich wie u8("200")
```

**Zwischen numerischen Typen konvertieren:**
```hemlock
let big = i64(42);           // i32 zu i64
let truncated = i32(3.99);   // f64 zu i32 (schneidet auf 3 ab)
let promoted = f64(100);     // i32 zu f64 (100.0)
let narrowed = i8(127);      // i32 zu i8
```

**Typannotationen f√ºhren numerische Koersion durch (aber KEIN String-Parsen):**
```hemlock
let f: f64 = 100;        // i32 zu f64 via Annotation (OK)
let s: string = 'A';     // Rune zu String via Annotation (OK)
let code: i32 = 'A';     // Rune zu i32 via Annotation (erh√§lt Codepoint, OK)

// String-Parsen erfordert explizite Typ-Konstruktoren:
let n = i32("42");       // Typ-Konstruktor f√ºr String-Parsen verwenden
// let x: i32 = "42";    // FEHLER - Typannotationen parsen keine Strings
```

**Fehlerbehandlung:**
```hemlock
// Ungueltige Strings werfen Fehler bei Verwendung von Typ-Konstruktoren
let bad = i32("hallo");  // Laufzeitfehler: kann "hallo" nicht als i32 parsen
let overflow = u8("256"); // Laufzeitfehler: 256 au√üerhalb des Bereichs f√ºr u8
```

**Boolean-Parsen:**
```hemlock
let t = bool("true");    // true
let f = bool("false");   // false
let bad = bool("ja");    // Laufzeitfehler: muss "true" oder "false" sein
```

## Bereichspr√ºfung

Typannotationen erzwingen Bereichspruefungen bei Zuweisung:

```hemlock
let x: u8 = 255;    // OK
let y: u8 = 256;    // FEHLER: au√üerhalb des Bereichs f√ºr u8

let a: i8 = 127;    // OK
let b: i8 = 128;    // FEHLER: au√üerhalb des Bereichs f√ºr i8

let c: i64 = 2147483647;   // OK
let d: u64 = 4294967295;   // OK
let e: u64 = -1;           // FEHLER: u64 kann nicht negativ sein
```

## Typbefoerderungs-Beispiele

### Gemischte Ganzzahltypen

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let sum = a + b;     // i32 (30)

let c: u8 = 100;
let d: u32 = 200;
let total = c + d;   // u32 (300)
```

### Ganzzahl + Float

```hemlock
let i: i32 = 5;
let f: f32 = 2.5;
let result = i * f;  // f32 (12.5)
```

### Komplexe Ausdr√ºcke

```hemlock
let a: i8 = 10;
let b: i32 = 20;
let c: f64 = 3.0;

let result = a + b * c;  // f64 (70.0)
// Auswertung: b * c -> f64(60.0)
//             a + f64(60.0) -> f64(70.0)
```

## Duck Typing (Objects)

Objects verwenden **strukturelle Typisierung** (Duck Typing):

```hemlock
define Person {
    name: string,
    age: i32,
}

// OK: Hat alle erforderlichen Felder
let p1: Person = { name: "Alice", age: 30 };

// OK: Zus√§tzliche Felder erlaubt
let p2: Person = { name: "Bob", age: 25, city: "NYC" };

// FEHLER: Fehlendes 'age'-Feld
let p3: Person = { name: "Carol" };

// FEHLER: Falscher Typ f√ºr 'age'
let p4: Person = { name: "Dave", age: "dreissig" };
```

**Typ√ºberpr√ºfung erfolgt bei Zuweisung:**
- Validiert, dass alle erforderlichen Felder vorhanden sind
- Validiert, dass Feldtypen √ºbereinstimmen
- Zus√§tzliche Felder sind erlaubt und werden beibehalten
- Setzt den Typnamen des Objects f√ºr `typeof()`

## Optionale Felder

```hemlock
define Config {
    host: string,
    port: i32,
    debug?: false,     // Optional mit Standard
    timeout?: i32,     // Optional, Standard ist null
}

let cfg1: Config = { host: "localhost", port: 8080 };
print(cfg1.debug);    // false (Standard)
print(cfg1.timeout);  // null

let cfg2: Config = { host: "0.0.0.0", port: 80, debug: true };
print(cfg2.debug);    // true (√ºberschrieben)
```

## Typ-Aliase

Hemlock unterst√ºtzt benutzerdefinierte Typ-Aliase mit dem `type`-Schl√ºsselwort:

### Einfache Typ-Aliase

```hemlock
// Einfacher Typ-Alias
type Integer = i32;
type Text = string;

// Alias verwenden
let x: Integer = 42;
let msg: Text = "hallo";
```

### Funktionstyp-Aliase

```hemlock
// Funktionstyp-Alias
type Callback = fn(i32): void;
type Predicate = fn(i32): bool;
type AsyncHandler = async fn(string): i32;

// Funktionstyp-Aliase verwenden
let cb: Callback = fn(n) { print(n); };
let isEven: Predicate = fn(n) { return n % 2 == 0; };
```

### Zusammengesetzte Typ-Aliase

```hemlock
// Mehrere defines zu einem Typ kombinieren
define HasName { name: string }
define HasAge { age: i32 }

type Person = HasName & HasAge;

let p: Person = { name: "Alice", age: 30 };
```

### Generische Typ-Aliase

```hemlock
// Generischer Typ-Alias
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };

// Generische Aliase verwenden
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
```

**Hinweis:** Typ-Aliase sind transparent - `typeof()` gibt den zugrunde liegenden Typnamen zur√ºck, nicht den Alias.

## Typsystem-Einschr√§nkungen

Aktuelle Einschr√§nkungen:

- **Keine Generics bei Funktionen** - Funktions-Typparameter noch nicht unterst√ºtzt
- **Keine Union-Typen** - Kann "A oder B" nicht ausdr√ºcken
- **Keine Nullable-Typen** - Alle Typen k√∂nnen null sein (verwenden Sie `?`-Suffix f√ºr explizite Nullability)

**Hinweis:** Der Compiler (`hemlockc`) bietet Kompilierzeit-Typ√ºberpr√ºfung. Der Interpreter f√ºhrt nur Laufzeit-Typ√ºberpr√ºfung durch. Siehe die [Compiler-Dokumentation](#design-implementation) f√ºr Details.

## Best Practices

### Wann Typannotationen verwenden

**Verwenden Sie Annotationen, wenn:**
- Praeziser Typ wichtig ist (z.B. `u8` f√ºr Byte-Werte)
- Funktionsschnittstellen dokumentieren
- Einschr√§nkungen erzwingen (z.B. Bereichspruefungen)

```hemlock
fn hash(data: buffer, length: u32): u64 {
    // Implementierung
}
```

**Verwenden Sie keine Annotationen, wenn:**
- Der Typ aus dem Literal offensichtlich ist
- Interne Implementierungsdetails
- Unnoetige Zeremonie

```hemlock
// Unn√∂tig
let x: i32 = 42;

// Besser
let x = 42;
```

### Typsicherheits-Muster

**Vor Verwendung pr√ºfen:**
```hemlock
if (typeof(value) == "i32") {
    // Sicher als i32 zu verwenden
}
```

**Funktionsargumente validieren:**
```hemlock
fn divide(a, b) {
    if (typeof(a) != "i32" || typeof(b) != "i32") {
        throw "Argumente m√ºssen Ganzzahlen sein";
    }
    if (b == 0) {
        throw "Division durch Null";
    }
    return a / b;
}
```

**Duck Typing f√ºr Flexibilitaet verwenden:**
```hemlock
define Printable {
    toString: fn,
}

fn print_item(item: Printable) {
    print(item.toString());
}
```

## N√§chste Schritte

- [Strings](#language-guide-strings) - UTF-8-String-Typ und Operationen
- [Runes](#language-guide-runes) - Unicode-Codepoint-Typ
- [Arrays](#language-guide-arrays) - Dynamischer Array-Typ
- [Objects](#language-guide-objects) - Object-Literale und Duck Typing
- [Memory](#language-guide-memory) - Pointer- und Buffer-Typen


--------------------------------------------------------------------------------
## Zeichenketten
--------------------------------------------------------------------------------

# Strings

Hemlock-Strings sind **UTF-8 erstklassige veraenderbare Sequenzen** mit voller Unicode-Unterst√ºtzung und einem umfangreichen Satz von Methoden zur Textverarbeitung. Anders als in vielen Sprachen sind Hemlock-Strings veraenderbar und arbeiten nativ mit Unicode-Codepoints.

## √úberblick

```hemlock
let s = "hello";
s[0] = 'H';             // veraendern mit Rune (jetzt "Hello")
print(s.length);        // 5 (Codepoint-Anzahl)
let c = s[0];           // gibt Rune zur√ºck (Unicode-Codepoint)
let msg = s + " world"; // Verkettung
let emoji = "üöÄ";
print(emoji.length);    // 1 (ein Codepoint)
print(emoji.byte_length); // 4 (vier UTF-8-Bytes)
```

## Eigenschaften

Hemlock-Strings haben diese Hauptmerkmale:

- **UTF-8-kodiert** - Volle Unicode-Unterst√ºtzung (U+0000 bis U+10FFFF)
- **Veraenderbar** - Anders als Python-, JavaScript- und Java-Strings
- **Codepoint-basierte Indizierung** - Gibt `rune` (Unicode-Codepoint) zur√ºck, nicht Byte
- **Heap-allokiert** - Mit interner Kapazitaetsverfolgung
- **Zwei L√§ngeneigenschaften**:
  - `.length` - Codepoint-Anzahl (Anzahl der Zeichen)
  - `.byte_length` - Byte-Anzahl (UTF-8-Kodierungsgroesse)

## UTF-8-Verhalten

Alle String-Operationen arbeiten mit **Codepoints** (Zeichen), nicht mit Bytes:

```hemlock
let text = "HelloüöÄWorld";
print(text.length);        // 11 (Codepoints)
print(text.byte_length);   // 15 (Bytes, Emoji ist 4 Bytes)

// Indizierung verwendet Codepoints
let h = text[0];           // 'H' (Rune)
let rocket = text[5];      // 'üöÄ' (Rune)
```

**Mehrbyte-Zeichen zaehlen als eins:**
```hemlock
"Hello".length;      // 5
"üöÄ".length;         // 1 (ein Emoji)
"‰Ω†Â•Ω".length;       // 2 (zwei chinesische Zeichen)
"caf√©".length;       // 4 (√© ist ein Codepoint)
```

## String-Literale

```hemlock
// Einfache Strings
let s1 = "hello";
let s2 = "world";

// Mit Escape-Sequenzen
let s3 = "Zeile 1\nZeile 2\teingerueckt";
let s4 = "Zitat: \"Hallo\"";
let s5 = "Backslash: \\";

// Unicode-Zeichen
let s6 = "üöÄ Emoji";
let s7 = "‰∏≠ÊñáÂ≠óÁ¨¶";
```

## Template-Strings (String-Interpolation)

Verwenden Sie Backticks f√ºr Template-Strings mit eingebetteten Ausdr√ºcken:

```hemlock
let name = "Alice";
let age = 30;

// Einfache Interpolation
let greeting = `Hallo, ${name}!`;           // "Hallo, Alice!"
let info = `${name} ist ${age} Jahre alt`;  // "Alice ist 30 Jahre alt"

// Ausdr√ºcke in der Interpolation
let x = 5;
let y = 10;
let sum = `${x} + ${y} = ${x + y}`;         // "5 + 10 = 15"

// Methodenaufrufe
let upper = `Name: ${name.to_upper()}`;     // "Name: ALICE"

// Verschachtelte Objekte
let person = { name: "Bob", city: "NYC" };
let desc = `${person.name} lebt in ${person.city}`;  // "Bob lebt in NYC"

// Mehrzeilig (beh√§lt Zeilenumbrueche bei)
let multi = `Zeile 1
Zeile 2
Zeile 3`;
```

**Template-String-Funktionen:**
- Ausdr√ºcke innerhalb von `${...}` werden ausgewertet und in Strings konvertiert
- Jeder gueltige Ausdruck kann verwendet werden (Variablen, Funktionsaufrufe, Arithmetik)
- Backtick-Strings unterst√ºtzen dieselben Escape-Sequenzen wie regul√§re Strings
- N√ºtzlich zum Erstellen dynamischer Strings ohne Verkettung

### Escaping in Template-Strings

Um ein literales `${` in einem Template-String einzufuegen, escapen Sie das Dollarzeichen:

```hemlock
let price = 100;
let text = `Preis: \${price} oder ${price}`;
// "Preis: ${price} oder 100"

// Literaler Backtick
let code = `Verwende \` f√ºr Template-Strings`;
// "Verwende ` f√ºr Template-Strings"
```

### Komplexe Ausdr√ºcke

Template-Strings k√∂nnen jeden gueltigen Ausdruck enthalten:

```hemlock
// Ternaer-√§hnliche Ausdr√ºcke
let age = 25;
let status = `Status: ${age >= 18 ? "erwachsen" : "minderjaehrig"}`;

// Array-Zugriff
let items = ["Apfel", "Banane", "Kirsche"];
let first = `Erstes Element: ${items[0]}`;

// Funktionsaufrufe mit Argumenten
fn format_price(p) { return p + " EUR"; }
let msg = `Gesamt: ${format_price(99.99)}`;  // "Gesamt: 99.99 EUR"

// Verkettete Methodenaufrufe
let name = "alice";
let formatted = `Hallo, ${name.to_upper().slice(0, 1)}${name.slice(1)}!`;
// "Hallo, Alice!"
```

### Template-Strings vs. Verkettung

Template-Strings sind oft sauberer als Verkettung:

```hemlock
// Verkettung (schwerer zu lesen)
let msg1 = "Hallo, " + name + "! Du hast " + count + " Nachrichten.";

// Template-String (leichter zu lesen)
let msg2 = `Hallo, ${name}! Du hast ${count} Nachrichten.`;
```

## Indizierung und Veraenderung

### Zeichen lesen

Indizierung gibt eine `rune` (Unicode-Codepoint) zur√ºck:

```hemlock
let s = "Hello";
let first = s[0];      // 'H' (Rune)
let last = s[4];       // 'o' (Rune)

// UTF-8-Beispiel
let emoji = "HiüöÄ!";
let rocket = emoji[2];  // 'üöÄ' (Rune an Codepoint-Index 2)
```

### Zeichen schreiben

Strings sind veraenderbar - Sie k√∂nnen einzelne Zeichen modifizieren:

```hemlock
let s = "hello";
s[0] = 'H';            // Jetzt "Hello"
s[4] = '!';            // Jetzt "Hell!"

// Mit Unicode
let msg = "Go!";
msg[0] = 'üöÄ';         // Jetzt "üöÄo!"
```

## Verkettung

Verwenden Sie `+` um Strings zu verketten:

```hemlock
let greeting = "Hello" + " " + "World";  // "Hello World"

// Mit Variablen
let name = "Alice";
let msg = "Hallo, " + name + "!";  // "Hallo, Alice!"

// Mit Runen (siehe Runes-Dokumentation)
let s = "Hello" + '!';          // "Hello!"
```

## String-Methoden

Hemlock bietet 19 String-Methoden f√ºr umfassende Textmanipulation.

### Teilstring & Slicing

**`substr(start, length)`** - Teilstring nach Position und L√§nge extrahieren:
```hemlock
let s = "hello world";
let sub = s.substr(6, 5);       // "world" (Start bei 6, L√§nge 5)
let first = s.substr(0, 5);     // "hello"

// UTF-8-Beispiel
let text = "HiüöÄ!";
let emoji = text.substr(2, 1);  // "üöÄ" (Position 2, L√§nge 1)
```

**`slice(start, end)`** - Teilstring nach Bereich extrahieren (Ende exklusiv):
```hemlock
let s = "hello world";
let slice = s.slice(0, 5);      // "hello" (Index 0 bis 4)
let slice2 = s.slice(6, 11);    // "world"
```

**Unterschied:**
- `substr(start, length)` - Verwendet Laengenparameter
- `slice(start, end)` - Verwendet Endindex (exklusiv)

### Suchen & Finden

**`find(needle)`** - Erstes Vorkommen finden:
```hemlock
let s = "hello world";
let pos = s.find("world");      // 6 (Index des ersten Vorkommens)
let pos2 = s.find("foo");       // -1 (nicht gefunden)
let pos3 = s.find("l");         // 2 (erstes 'l')
```

**`contains(needle)`** - Pr√ºfen, ob String Teilstring enth√§lt:
```hemlock
let s = "hello world";
let has = s.contains("world");  // true
let has2 = s.contains("foo");   // false
```

### Aufteilen & Trimmen

**`split(delimiter)`** - In Array von Strings aufteilen:
```hemlock
let csv = "Apfel,Banane,Kirsche";
let parts = csv.split(",");     // ["Apfel", "Banane", "Kirsche"]

let words = "eins zwei drei".split(" ");  // ["eins", "zwei", "drei"]

// Leerer Delimiter teilt nach Zeichen
let chars = "abc".split("");    // ["a", "b", "c"]
```

**`trim()`** - F√ºhrende/nachfolgende Leerzeichen entfernen:
```hemlock
let s = "  hello  ";
let clean = s.trim();           // "hello"

let s2 = "\t\ntext\n\t";
let clean2 = s2.trim();         // "text"
```

### Gro√ü-/Kleinschreibung

**`to_upper()`** - In Grossbuchstaben umwandeln:
```hemlock
let s = "hello world";
let upper = s.to_upper();       // "HELLO WORLD"

// Behaelt Nicht-ASCII bei
let s2 = "caf√©";
let upper2 = s2.to_upper();     // "CAF√â"
```

**`to_lower()`** - In Kleinbuchstaben umwandeln:
```hemlock
let s = "HELLO WORLD";
let lower = s.to_lower();       // "hello world"
```

### Pr√§fix-/Suffix-Pr√ºfung

**`starts_with(prefix)`** - Pr√ºfen, ob mit Pr√§fix beginnt:
```hemlock
let s = "hello world";
let starts = s.starts_with("hello");  // true
let starts2 = s.starts_with("world"); // false
```

**`ends_with(suffix)`** - Pr√ºfen, ob mit Suffix endet:
```hemlock
let s = "hello world";
let ends = s.ends_with("world");      // true
let ends2 = s.ends_with("hello");     // false
```

### Ersetzen

**`replace(old, new)`** - Erstes Vorkommen ersetzen:
```hemlock
let s = "hello world";
let s2 = s.replace("world", "there");      // "hello there"

let s3 = "foo foo foo";
let s4 = s3.replace("foo", "bar");         // "bar foo foo" (nur erstes)
```

**`replace_all(old, new)`** - Alle Vorkommen ersetzen:
```hemlock
let s = "foo foo foo";
let s2 = s.replace_all("foo", "bar");      // "bar bar bar"

let s3 = "hello world, world!";
let s4 = s3.replace_all("world", "hemlock"); // "hello hemlock, hemlock!"
```

### Wiederholung

**`repeat(count)`** - String n-mal wiederholen:
```hemlock
let s = "ha";
let laugh = s.repeat(3);        // "hahaha"

let line = "=".repeat(40);      // "========================================"
```

### Zeichen- & Byte-Zugriff

**`char_at(index)`** - Unicode-Codepoint an Index abrufen (gibt Rune zur√ºck):
```hemlock
let s = "hello";
let char = s.char_at(0);        // 'h' (Rune)

// UTF-8-Beispiel
let emoji = "üöÄ";
let rocket = emoji.char_at(0);  // Gibt Rune U+1F680 zur√ºck
```

**`chars()`** - In Array von Runen (Codepoints) umwandeln:
```hemlock
let s = "hello";
let chars = s.chars();          // ['h', 'e', 'l', 'l', 'o'] (Array von Runen)

// UTF-8-Beispiel
let text = "HiüöÄ";
let chars2 = text.chars();      // ['H', 'i', 'üöÄ']
```

**`byte_at(index)`** - Byte-Wert an Index abrufen (gibt u8 zur√ºck):
```hemlock
let s = "hello";
let byte = s.byte_at(0);        // 104 (ASCII-Wert von 'h')

// UTF-8-Beispiel
let emoji = "üöÄ";
let first_byte = emoji.byte_at(0);  // 240 (erstes UTF-8-Byte)
```

**`bytes()`** - In Array von Bytes (u8-Werte) umwandeln:
```hemlock
let s = "hello";
let bytes = s.bytes();          // [104, 101, 108, 108, 111] (Array von u8)

// UTF-8-Beispiel
let emoji = "üöÄ";
let bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 UTF-8-Bytes)
```

**`to_bytes()`** - In Buffer f√ºr Low-Level-Zugriff umwandeln:
```hemlock
let s = "hello";
let buf = s.to_bytes();         // Gibt Buffer mit UTF-8-Bytes zur√ºck
print(buf.length);              // 5
free(buf);                      // Nicht vergessen freizugeben
```

## Methodenverkettung

Alle String-Methoden geben neue Strings zur√ºck, was Verkettung erm√∂glicht:

```hemlock
let result = "  Hello World  "
    .trim()
    .to_lower()
    .replace("world", "hemlock");  // "hello hemlock"

let processed = "foo,bar,baz"
    .split(",")
    .join(" | ")
    .to_upper();                    // "FOO | BAR | BAZ"
```

## Vollst√§ndige Methodenreferenz

| Methode | Parameter | R√ºckgabe | Beschreibung |
|---------|-----------|-----------|--------------|
| `substr(start, length)` | i32, i32 | string | Teilstring nach Position und L√§nge extrahieren |
| `slice(start, end)` | i32, i32 | string | Teilstring nach Bereich extrahieren (Ende exklusiv) |
| `find(needle)` | string | i32 | Erstes Vorkommen finden (-1 wenn nicht gefunden) |
| `contains(needle)` | string | bool | Pr√ºfen, ob Teilstring enthalten ist |
| `split(delimiter)` | string | array | In Array von Strings aufteilen |
| `trim()` | - | string | F√ºhrende/nachfolgende Leerzeichen entfernen |
| `to_upper()` | - | string | In Grossbuchstaben umwandeln |
| `to_lower()` | - | string | In Kleinbuchstaben umwandeln |
| `starts_with(prefix)` | string | bool | Pr√ºfen, ob mit Pr√§fix beginnt |
| `ends_with(suffix)` | string | bool | Pr√ºfen, ob mit Suffix endet |
| `replace(old, new)` | string, string | string | Erstes Vorkommen ersetzen |
| `replace_all(old, new)` | string, string | string | Alle Vorkommen ersetzen |
| `repeat(count)` | i32 | string | String n-mal wiederholen |
| `char_at(index)` | i32 | rune | Codepoint an Index abrufen |
| `byte_at(index)` | i32 | u8 | Byte-Wert an Index abrufen |
| `chars()` | - | array | In Array von Runen umwandeln |
| `bytes()` | - | array | In Array von u8-Bytes umwandeln |
| `to_bytes()` | - | buffer | In Buffer umwandeln (muss freigegeben werden) |

## Beispiele

### Beispiel: Textverarbeitung

```hemlock
fn process_input(text: string): string {
    return text
        .trim()
        .to_lower()
        .replace_all("  ", " ");  // Leerzeichen normalisieren
}

let input = "  HELLO   WORLD  ";
let clean = process_input(input);  // "hello world"
```

### Beispiel: CSV-Parser

```hemlock
fn parse_csv_line(line: string): array {
    let trimmed = line.trim();
    let fields = trimmed.split(",");

    let result = [];
    let i = 0;
    while (i < fields.length) {
        result.push(fields[i].trim());
        i = i + 1;
    }

    return result;
}

let csv = "Apfel, Banane , Kirsche";
let fields = parse_csv_line(csv);  // ["Apfel", "Banane", "Kirsche"]
```

### Beispiel: W√∂rter zaehlen

```hemlock
fn count_words(text: string): i32 {
    let words = text.trim().split(" ");
    return words.length;
}

let sentence = "Der schnelle braune Fuchs";
let count = count_words(sentence);  // 4
```

### Beispiel: String-Validierung

```hemlock
fn is_valid_email(email: string): bool {
    if (!email.contains("@")) {
        return false;
    }

    if (!email.contains(".")) {
        return false;
    }

    if (email.starts_with("@") || email.ends_with("@")) {
        return false;
    }

    return true;
}

print(is_valid_email("user@example.com"));  // true
print(is_valid_email("ung√ºltig"));         // false
```

## Speicherverwaltung

Strings sind heap-allokiert mit interner Referenzzaehlung:

- **Erstellung**: Auf dem Heap allokiert mit Kapazitaetsverfolgung
- **Verkettung**: Erzeugt neuen String (alte Strings unver√§ndert)
- **Methoden**: Die meisten Methoden geben neue Strings zur√ºck
- **Lebensdauer**: Strings sind referenzgez√§hlt und werden automatisch freigegeben, wenn der G√ºltigkeitsbereich endet

**Automatische Bereinigung:**
```hemlock
fn create_strings() {
    let s = "hello";
    let s2 = s + " world";  // Neue Allokation
}  // Sowohl s als auch s2 werden automatisch freigegeben, wenn die Funktion zur√ºckkehrt
```

**Hinweis:** Lokale String-Variablen werden automatisch bereinigt, wenn sie den G√ºltigkeitsbereich verlassen. Verwenden Sie `free()` nur f√ºr fruehe Bereinigung vor Bereichsende oder f√ºr langlebige/globale Daten. Siehe [Speicherverwaltung](memory.md#internal-reference-counting) f√ºr Details.

## Best Practices

1. **Codepoint-Indizierung verwenden** - Strings verwenden Codepoint-Positionen, nicht Byte-Offsets
2. **Mit Unicode testen** - String-Operationen immer mit Mehrbyte-Zeichen testen
3. **Unver√§nderliche Operationen bevorzugen** - Methoden verwenden, die neue Strings zur√ºckgeben, statt Mutation
4. **Grenzen pr√ºfen** - String-Indizierung f√ºhrt keine Grenzpr√ºfung durch (gibt null/Fehler bei ung√ºltig zur√ºck)
5. **Eingabe normalisieren** - `trim()` und `to_lower()` f√ºr Benutzereingaben verwenden

## H√§ufige Fallstricke

### Fallstrick: Byte vs. Codepoint-Verwirrung

```hemlock
let emoji = "üöÄ";
print(emoji.length);        // 1 (Codepoint)
print(emoji.byte_length);   // 4 (Bytes)

// Byte- und Codepoint-Operationen nicht mischen
let byte = emoji.byte_at(0);  // 240 (erstes Byte)
let char = emoji.char_at(0);  // 'üöÄ' (vollstaendiger Codepoint)
```

### Fallstrick: Mutations-Ueberraschungen

```hemlock
let s1 = "hello";
let s2 = s1;       // Flache Kopie
s1[0] = 'H';       // Veraendert s1
print(s2);         // Immer noch "hello" (Strings sind Werttypen)
```

## Verwandte Themen

- [Runes](#language-guide-runes) - Unicode-Codepoint-Typ, der bei String-Indizierung verwendet wird
- [Arrays](#language-guide-arrays) - String-Methoden geben oft Arrays zur√ºck oder arbeiten mit ihnen
- [Types](#language-guide-types) - String-Typ-Details und Konvertierungen

## Siehe auch

- **UTF-8-Kodierung**: Siehe CLAUDE.md Abschnitt "Strings"
- **Typkonvertierungen**: Siehe [Types](#language-guide-types) f√ºr String-Konvertierungen
- **Speicher**: Siehe [Memory](#language-guide-memory) f√ºr String-Allokationsdetails



################################################################################
# FORTGESCHRITTENE THEMEN
################################################################################

--------------------------------------------------------------------------------
## Asynchronit√§t & Nebenl√§ufigkeit
--------------------------------------------------------------------------------

# Async/Nebenl√§ufigkeit in Hemlock

Hemlock bietet **strukturierte Nebenl√§ufigkeit** mit async/await-Syntax, Task-Spawning und Channels zur Kommunikation. Die Implementierung verwendet POSIX-Threads (pthreads) f√ºr **echte Multithread-Parallelit√§t**.

## Inhaltsverzeichnis

- [√úberblick](#√ºberblick)
- [Threading-Modell](#threading-modell)
- [Async-Funktionen](#async-funktionen)
- [Task-Spawning](#task-spawning)
- [Channels](#channels)
- [Ausnahmeweiterleitung](#ausnahmeweiterleitung)
- [Implementierungsdetails](#implementierungsdetails)
- [Best Practices](#best-practices)
- [Leistungsmerkmale](#leistungsmerkmale)
- [Aktuelle Einschr√§nkungen](#aktuelle-einschr√§nkungen)

## √úberblick

**Was das bedeutet:**
- ‚úÖ **Echte OS-Threads** - Jeder gespawnte Task l√§uft auf einem separaten pthread (POSIX-Thread)
- ‚úÖ **Echte Parallelit√§t** - Tasks werden gleichzeitig auf mehreren CPU-Kernen ausgef√ºhrt
- ‚úÖ **Kernel-geplant** - Der OS-Scheduler verteilt Tasks auf verf√ºgbare Kerne
- ‚úÖ **Thread-sichere Channels** - Verwendet pthread-Mutexe und Bedingungsvariablen zur Synchronisation

**Was das NICHT ist:**
- ‚ùå **KEINE Green Threads** - Kein User-Space-kooperatives Multitasking
- ‚ùå **KEINE async/await-Coroutinen** - Keine Single-Threaded Event-Loop wie JavaScript/Python asyncio
- ‚ùå **KEINE emulierte Nebenl√§ufigkeit** - Keine simulierte Parallelit√§t

Dies ist das **gleiche Threading-Modell wie C, C++ und Rust** bei Verwendung von OS-Threads. Sie erhalten echte parallele Ausf√ºhrung √ºber mehrere Kerne.

## Threading-Modell

### 1:1 Threading

Hemlock verwendet ein **1:1 Threading-Modell**, wobei:
- Jeder gespawnte Task einen dedizierten OS-Thread √ºber `pthread_create()` erstellt
- Der OS-Kernel Threads auf verf√ºgbare CPU-Kerne verteilt
- Pr√§emptives Multitasking - das OS kann Threads unterbrechen und zwischen ihnen wechseln
- **Kein GIL** - Anders als Python gibt es keinen Global Interpreter Lock, der die Parallelit√§t einschr√§nkt

### Synchronisationsmechanismen

- **Mutexe** - Channels verwenden `pthread_mutex_t` f√ºr thread-sicheren Zugriff
- **Bedingungsvariablen** - Blockierendes send/recv verwendet `pthread_cond_t` f√ºr effizientes Warten
- **Lock-freie Operationen** - Task-Zustands√ºberg√§nge sind atomar

## Async-Funktionen

Funktionen k√∂nnen als `async` deklariert werden, um anzuzeigen, dass sie f√ºr nebenl√§ufige Ausf√ºhrung konzipiert sind:

```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}
```

### Wichtige Punkte

- `async fn` deklariert eine asynchrone Funktion
- Async-Funktionen k√∂nnen als nebenl√§ufige Tasks mit `spawn()` gestartet werden
- Async-Funktionen k√∂nnen auch direkt aufgerufen werden (l√§uft synchron im aktuellen Thread)
- Wenn gespawnt, l√§uft jeder Task auf seinem **eigenen OS-Thread** (keine Coroutine!)
- Das `await`-Schl√ºsselwort ist f√ºr zuk√ºnftige Verwendung reserviert

### Beispiel: Direkter Aufruf vs Spawn

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Direkter Aufruf - l√§uft synchron
let result1 = factorial(5);  // 120

// Gespawnter Task - l√§uft auf separatem Thread
let task = spawn(factorial, 5);
let result2 = join(task);  // 120
```

## Task-Spawning

Verwenden Sie `spawn()`, um async-Funktionen **parallel auf separaten OS-Threads** auszuf√ºhren:

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Mehrere Tasks spawnen - diese laufen PARALLEL auf verschiedenen CPU-Kernen!
let t1 = spawn(factorial, 5);  // Thread 1
let t2 = spawn(factorial, 6);  // Thread 2
let t3 = spawn(factorial, 7);  // Thread 3

// Alle drei rechnen gerade gleichzeitig!

// Auf Ergebnisse warten
let f5 = join(t1);  // 120
let f6 = join(t2);  // 720
let f7 = join(t3);  // 5040
```

### Eingebaute Funktionen

#### spawn(async_fn, arg1, arg2, ...)

Erstellt einen neuen Task auf einem neuen pthread, gibt Task-Handle zur√ºck.

**Parameter:**
- `async_fn` - Die auszuf√ºhrende async-Funktion
- `arg1, arg2, ...` - Argumente, die an die Funktion √ºbergeben werden

**R√ºckgabe:** Task-Handle (opaker Wert, der mit `join()` oder `detach()` verwendet wird)

**Beispiel:**
```hemlock
async fn process(data: string, count: i32): i32 {
    // ... Verarbeitungslogik
    return count * 2;
}

let task = spawn(process, "test", 42);
```

#### join(task)

Warte auf Task-Abschluss (blockiert bis Thread fertig ist), gibt Ergebnis zur√ºck.

**Parameter:**
- `task` - Task-Handle, das von `spawn()` zur√ºckgegeben wurde

**R√ºckgabe:** Der von der async-Funktion zur√ºckgegebene Wert

**Beispiel:**
```hemlock
let task = spawn(compute, 1000);
let result = join(task);  // Blockiert bis compute() fertig ist
print(result);
```

**Wichtig:** Jeder Task kann nur einmal gejoined werden. Nachfolgende Joins werden einen Fehler verursachen.

#### detach(task)

Fire-and-Forget-Ausf√ºhrung (Thread l√§uft unabh√§ngig, kein Join erlaubt).

**Parameter:**
- `task` - Task-Handle, das von `spawn()` zur√ºckgegeben wurde

**R√ºckgabe:** `null`

**Beispiel:**
```hemlock
async fn background_work() {
    // Lang laufender Hintergrund-Task
    // ...
}

let task = spawn(background_work);
detach(task);  // Task l√§uft unabh√§ngig, kann nicht gejoined werden
```

**Wichtig:** Losgel√∂ste Tasks k√∂nnen nicht gejoined werden. Sowohl der pthread als auch die Task-Struktur werden automatisch bereinigt, wenn der Task abgeschlossen ist.

## Channels

Channels bieten thread-sichere Kommunikation zwischen Tasks unter Verwendung eines begrenzten Puffers mit blockierender Semantik.

### Channels erstellen

```hemlock
let ch = channel(10);  // Channel mit Puffergr√∂√üe 10 erstellen
```

**Parameter:**
- `capacity` (i32) - Maximale Anzahl von Werten, die der Channel halten kann

**R√ºckgabe:** Channel-Objekt

### Channel-Methoden

#### send(value)

Sende Wert an Channel (blockiert wenn voll).

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

let ch = channel(10);
let task = spawn(producer, ch, 5);
```

**Verhalten:**
- Wenn Channel Platz hat, wird Wert sofort hinzugef√ºgt
- Wenn Channel voll ist, blockiert der Sender bis Platz verf√ºgbar wird
- Wenn Channel geschlossen ist, wird Ausnahme geworfen

#### recv()

Empfange Wert von Channel (blockiert wenn leer).

```hemlock
async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(10);
let task = spawn(consumer, ch, 5);
```

**Verhalten:**
- Wenn Channel Werte hat, wird n√§chster Wert sofort zur√ºckgegeben
- Wenn Channel leer ist, blockiert der Empf√§nger bis Wert verf√ºgbar
- Wenn Channel geschlossen und leer ist, gibt `null` zur√ºck

#### close()

Schlie√üe Channel (recv auf geschlossenem Channel gibt null zur√ºck).

```hemlock
ch.close();
```

**Verhalten:**
- Verhindert weitere `send()`-Operationen (wirft Ausnahme)
- Erlaubt ausstehenden `recv()`-Operationen abzuschlie√üen
- Sobald leer, gibt `recv()` `null` zur√ºck

### Multiplexing mit select()

Die `select()`-Funktion erm√∂glicht das gleichzeitige Warten auf mehrere Channels und gibt zur√ºck, wenn ein Channel Daten verf√ºgbar hat.

**Signatur:**
```hemlock
select(channels: array, timeout_ms?: i32): object | null
```

**Parameter:**
- `channels` - Array von Channel-Werten
- `timeout_ms` (optional) - Timeout in Millisekunden (-1 oder weglassen f√ºr unendliches Warten)

**R√ºckgabe:**
- `{ channel, value }` - Objekt mit dem Channel, der Daten hatte, und dem empfangenen Wert
- `null` - Bei Timeout (wenn Timeout angegeben wurde)

**Beispiel:**
```hemlock
let ch1 = channel(1);
let ch2 = channel(1);

// Producer-Tasks
spawn(fn() {
    sleep(100);
    ch1.send("von Channel 1");
});

spawn(fn() {
    sleep(50);
    ch2.send("von Channel 2");
});

// Auf erstes Ergebnis warten (ch2 sollte schneller sein)
let result = select([ch1, ch2]);
print(result.value);  // "von Channel 2"

// Auf zweites Ergebnis warten
let result2 = select([ch1, ch2]);
print(result2.value);  // "von Channel 1"
```

**Mit Timeout:**
```hemlock
let ch = channel(1);

// Kein Sender, wird Timeout erreichen
let result = select([ch], 100);  // 100ms Timeout
if (result == null) {
    print("Timeout!");
}
```

**Anwendungsf√§lle:**
- Warten auf die schnellste von mehreren Datenquellen
- Implementierung von Timeouts bei Channel-Operationen
- Event-Loop-Muster mit mehreren Ereignisquellen
- Fan-in: Zusammenf√ºhren mehrerer Channels zu einem

**Fan-in-Muster:**
```hemlock
fn fan_in(channels: array, output: channel) {
    while (true) {
        let result = select(channels);
        if (result == null) {
            break;  // Alle Channels geschlossen
        }
        output.send(result.value);
    }
    output.close();
}
```

### Vollst√§ndiges Producer-Consumer-Beispiel

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

// Channel mit Puffergr√∂√üe erstellen
let ch = channel(10);

// Producer und Consumer spawnen
let p = spawn(producer, ch, 5);
let c = spawn(consumer, ch, 5);

// Auf Abschluss warten
join(p);
let total = join(c);  // 100 (0+10+20+30+40)
print(total);
```

### Multi-Producer, Multi-Consumer

Channels k√∂nnen sicher zwischen mehreren Producern und Consumern geteilt werden:

```hemlock
async fn producer(id: i32, ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(id * 100 + i);
        i = i + 1;
    }
}

async fn consumer(id: i32, ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(20);

// Mehrere Producer
let p1 = spawn(producer, 1, ch, 5);
let p2 = spawn(producer, 2, ch, 5);

// Mehrere Consumer
let c1 = spawn(consumer, 1, ch, 5);
let c2 = spawn(consumer, 2, ch, 5);

// Auf alle warten
join(p1);
join(p2);
let sum1 = join(c1);
let sum2 = join(c2);
print(sum1 + sum2);
```

## Ausnahmeweiterleitung

Ausnahmen, die in gespawnten Tasks geworfen werden, werden beim Join weitergeleitet:

```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Task fehlgeschlagen!";
    }
    return 42;
}

let t = spawn(risky_operation, 1);
try {
    let result = join(t);
} catch (e) {
    print("Gefangen: " + e);  // "Gefangen: Task fehlgeschlagen!"
}
```

### Ausnahmebehandlungsmuster

**Muster 1: Im Task behandeln**
```hemlock
async fn safe_task() {
    try {
        // riskante Operation
    } catch (e) {
        print("Fehler im Task: " + e);
        return null;
    }
}

let task = spawn(safe_task);
join(task);  // Keine Ausnahme weitergeleitet
```

**Muster 2: An Aufrufer weiterleiten**
```hemlock
async fn task_that_throws() {
    throw "fehler";
}

let task = spawn(task_that_throws);
try {
    join(task);
} catch (e) {
    print("Von Task gefangen: " + e);
}
```

**Muster 3: Losgel√∂ste Tasks mit Ausnahmen**
```hemlock
async fn detached_task() {
    try {
        // Arbeit
    } catch (e) {
        // Muss intern behandelt werden - kann nicht weitergeleitet werden
        print("Fehler: " + e);
    }
}

let task = spawn(detached_task);
detach(task);  // Kann keine Ausnahmen von losgel√∂sten Tasks fangen
```

## Implementierungsdetails

### Threading-Architektur

- **1:1 Threading** - Jeder gespawnte Task erstellt einen dedizierten OS-Thread √ºber `pthread_create()`
- **Kernel-geplant** - Der OS-Kernel verteilt Threads auf verf√ºgbare CPU-Kerne
- **Pr√§emptives Multitasking** - Das OS kann Threads unterbrechen und zwischen ihnen wechseln
- **Kein GIL** - Anders als Python gibt es keinen Global Interpreter Lock, der die Parallelit√§t einschr√§nkt

### Channel-Implementierung

Channels verwenden einen Ringpuffer mit pthread-Synchronisation:

```
Channel-Struktur:
- buffer[] - Array fester Gr√∂√üe von Values
- capacity - Maximale Anzahl von Elementen
- size - Aktuelle Anzahl von Elementen
- head - Leseposition
- tail - Schreibposition
- mutex - pthread_mutex_t f√ºr thread-sicheren Zugriff
- not_empty - pthread_cond_t f√ºr blockierendes recv
- not_full - pthread_cond_t f√ºr blockierendes send
- closed - Boolean-Flag
- refcount - Referenzz√§hler f√ºr Bereinigung
```

**Blockierendes Verhalten:**
- `send()` auf vollem Channel: wartet auf `not_full` Bedingungsvariable
- `recv()` auf leerem Channel: wartet auf `not_empty` Bedingungsvariable
- Beide werden durch die gegenteilige Operation entsprechend signalisiert

### Speicher & Bereinigung

- **Gejoinede Tasks:** Werden automatisch bereinigt, nachdem `join()` zur√ºckkehrt
- **Losgel√∂ste Tasks:** Werden automatisch bereinigt, wenn der Task abgeschlossen ist
- **Channels:** Referenzgez√§hlt und freigegeben, wenn nicht mehr verwendet

## Best Practices

### 1. Channels immer schlie√üen

```hemlock
async fn producer(ch) {
    // ... Werte senden
    ch.close();  // Wichtig: signalisiert, dass keine weiteren Werte kommen
}
```

### 2. Strukturierte Nebenl√§ufigkeit verwenden

Tasks spawnen und im selben Scope joinen:

```hemlock
fn process_data(data) {
    // Tasks spawnen
    let t1 = spawn(worker, data);
    let t2 = spawn(worker, data);

    // Immer vor dem R√ºckgeben joinen
    let r1 = join(t1);
    let r2 = join(t2);

    return r1 + r2;
}
```

### 3. Ausnahmen angemessen behandeln

```hemlock
async fn task() {
    try {
        // riskante Operation
    } catch (e) {
        // Fehler loggen
        throw e;  // Erneut werfen, wenn Aufrufer es wissen soll
    }
}
```

### 4. Angemessene Channel-Kapazit√§t verwenden

- **Kleine Kapazit√§t (1-10):** F√ºr Koordination/Signalisierung
- **Mittlere Kapazit√§t (10-100):** F√ºr allgemeines Producer-Consumer
- **Gro√üe Kapazit√§t (100+):** F√ºr Hochdurchsatz-Szenarien

```hemlock
let signal_ch = channel(1);      // Koordination
let work_ch = channel(50);       // Arbeits-Warteschlange
let buffer_ch = channel(1000);   // Hoher Durchsatz
```

### 5. Nur bei Bedarf losl√∂sen

Bevorzugen Sie `join()` gegen√ºber `detach()` f√ºr besseres Ressourcenmanagement:

```hemlock
// Gut: Join und Ergebnis erhalten
let task = spawn(work);
let result = join(task);

// Detach nur f√ºr echtes Fire-and-Forget verwenden
let bg_task = spawn(background_logging);
detach(bg_task);  // L√§uft unabh√§ngig
```

## Leistungsmerkmale

### Echte Parallelit√§t

- **N gespawnte Tasks k√∂nnen N CPU-Kerne gleichzeitig nutzen**
- Nachgewiesene Beschleunigung - Stresstests zeigen 8-9x CPU-Zeit vs Wandzeit (mehrere Kerne arbeiten)
- Lineare Skalierung mit Anzahl der Kerne (bis zur Thread-Anzahl)

### Thread-Overhead

- Jeder Task hat ~8KB Stack + pthread-Overhead
- Thread-Erstellungskosten: ~10-20Œºs
- Kontextwechselkosten: ~1-5Œºs

### Wann Async verwenden

**Gute Anwendungsf√§lle:**
- CPU-intensive Berechnungen, die parallelisiert werden k√∂nnen
- I/O-gebundene Operationen (obwohl I/O immer noch blockiert)
- Nebenl√§ufige Verarbeitung unabh√§ngiger Daten
- Pipeline-Architekturen mit Channels

**Nicht ideal f√ºr:**
- Sehr kurze Tasks (Thread-Overhead dominiert)
- Tasks mit starker Synchronisation (Contention-Overhead)
- Single-Core-Systeme (kein Parallelit√§tsvorteil)

### Blockierendes I/O sicher

Blockierende Operationen in einem Task blockieren keine anderen:

```hemlock
async fn reader(filename: string) {
    let f = open(filename, "r");  // Blockiert nur diesen Thread
    let content = f.read();       // Blockiert nur diesen Thread
    f.close();
    return content;
}

// Beide lesen nebenl√§ufig (auf verschiedenen Threads)
let t1 = spawn(reader, "file1.txt");
let t2 = spawn(reader, "file2.txt");

let c1 = join(t1);
let c2 = join(t2);
```

## Thread-Sicherheitsmodell

Hemlock verwendet ein **Message-Passing**-Nebenl√§ufigkeitsmodell, bei dem Tasks √ºber Channels kommunizieren, anstatt gemeinsamen ver√§nderlichen Zustand zu verwenden.

### Argument-Isolation

Wenn Sie einen Task spawnen, werden **Argumente tief kopiert**, um Data Races zu verhindern:

```hemlock
async fn modify_array(arr: array): array {
    arr.push(999);    // Modifiziert die KOPIE, nicht das Original
    arr[0] = -1;
    return arr;
}

let original = [1, 2, 3];
let task = spawn(modify_array, original);
let modified = join(task);

print(original.length);  // 3 - unver√§ndert!
print(modified.length);  // 4 - hat neues Element
```

**Was tief kopiert wird:**
- Arrays (und alle Elemente rekursiv)
- Objekte (und alle Felder rekursiv)
- Strings
- Buffer

**Was geteilt wird (Referenz beibehalten):**
- Channels (der Kommunikationsmechanismus - absichtlich geteilt)
- Task-Handles (f√ºr Koordination)
- Funktionen (Code ist unver√§nderlich)
- Datei-Handles (OS verwaltet nebenl√§ufigen Zugriff)
- Socket-Handles (OS verwaltet nebenl√§ufigen Zugriff)

**Was nicht √ºbergeben werden kann:**
- Rohe Pointer (`ptr`) - verwenden Sie stattdessen `buffer`

### Warum Message-Passing?

Dies folgt Hemlocks "explizit statt implizit"-Philosophie:

```hemlock
// SCHLECHT: Gemeinsamer ver√§nderlicher Zustand (w√ºrde Data Races verursachen)
let counter = { value: 0 };
let t1 = spawn(fn() { counter.value = counter.value + 1; });  // Race!
let t2 = spawn(fn() { counter.value = counter.value + 1; });  // Race!

// GUT: Message-Passing √ºber Channels
async fn increment(ch) {
    let val = ch.recv();
    ch.send(val + 1);
}

let ch = channel(1);
ch.send(0);
let t1 = spawn(increment, ch);
join(t1);
let result = ch.recv();  // 1 - keine Race Condition
```

### Thread-Sicherheit der Referenzz√§hlung

Alle Referenzz√§hlungsoperationen verwenden **atomare Operationen**, um Use-after-Free-Bugs zu verhindern:
- `string_retain/release` - atomar
- `array_retain/release` - atomar
- `object_retain/release` - atomar
- `buffer_retain/release` - atomar
- `function_retain/release` - atomar
- `channel_retain/release` - atomar
- `task_retain/release` - atomar

Dies gew√§hrleistet sicheres Speichermanagement auch wenn Werte √ºber Threads geteilt werden.

### Closure-Umgebungszugriff

Tasks haben Zugriff auf die Closure-Umgebung f√ºr:
- Eingebaute Funktionen (`print`, `len`, etc.)
- Globale Funktionsdefinitionen
- Konstanten und Variablen

Die Closure-Umgebung wird durch einen pro-Umgebung-Mutex gesch√ºtzt, was
nebenl√§ufige Lese- und Schreibzugriffe thread-sicher macht:

```hemlock
let x = 10;

async fn read_closure(): i32 {
    return x;  // OK: Lesen von Closure-Variable (thread-sicher)
}

async fn modify_closure() {
    x = 20;  // OK: Schreiben von Closure-Variable (synchronisiert mit Mutex)
}
```

**Hinweis:** Obwohl nebenl√§ufiger Zugriff synchronisiert ist, kann das Modifizieren von gemeinsam genutztem Zustand aus mehreren Tasks immer noch zu logischen Race Conditions f√ºhren (nicht-deterministische Reihenfolge). F√ºr vorhersehbares Verhalten verwenden Sie Channels f√ºr Task-Kommunikation oder R√ºckgabewerte von Tasks.

Wenn Sie Daten von einem Task zur√ºckgeben m√ºssen, verwenden Sie den R√ºckgabewert oder Channels.

## Aktuelle Einschr√§nkungen

### 1. Kein Work-Stealing-Scheduler

Verwendet 1 Thread pro Task, was bei vielen kurzen Tasks ineffizient sein kann.

**Aktuell:** 1000 Tasks = 1000 Threads (hoher Overhead)

**Geplant:** Thread-Pool mit Work-Stealing f√ºr bessere Effizienz

### 3. Keine Async-I/O-Integration

Datei-/Netzwerkoperationen blockieren immer noch den Thread:

```hemlock
async fn read_file(path: string) {
    let f = open(path, "r");
    let content = f.read();  // Blockiert den Thread
    f.close();
    return content;
}
```

**Workaround:** Verwenden Sie mehrere Threads f√ºr nebenl√§ufige I/O-Operationen

### 4. Feste Channel-Kapazit√§t

Channel-Kapazit√§t wird bei der Erstellung festgelegt und kann nicht ge√§ndert werden:

```hemlock
let ch = channel(10);
// Kann nicht dynamisch auf 20 ge√§ndert werden
```

### 5. Channel-Gr√∂√üe ist fest

Channel-Puffergr√∂√üe kann nach der Erstellung nicht ge√§ndert werden.

## H√§ufige Muster

### Paralleles Map

```hemlock
async fn map_worker(ch_in, ch_out, fn_transform) {
    while (true) {
        let val = ch_in.recv();
        if (val == null) { break; }

        let result = fn_transform(val);
        ch_out.send(result);
    }
    ch_out.close();
}

fn parallel_map(data, fn_transform, workers: i32) {
    let ch_in = channel(100);
    let ch_out = channel(100);

    // Worker spawnen
    let tasks = [];
    let i = 0;
    while (i < workers) {
        tasks.push(spawn(map_worker, ch_in, ch_out, fn_transform));
        i = i + 1;
    }

    // Daten senden
    let i = 0;
    while (i < data.length) {
        ch_in.send(data[i]);
        i = i + 1;
    }
    ch_in.close();

    // Ergebnisse sammeln
    let results = [];
    let i = 0;
    while (i < data.length) {
        results.push(ch_out.recv());
        i = i + 1;
    }

    // Auf Worker warten
    let i = 0;
    while (i < tasks.length) {
        join(tasks[i]);
        i = i + 1;
    }

    return results;
}
```

### Pipeline-Architektur

```hemlock
async fn stage1(input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }
        output_ch.send(val * 2);
    }
    output_ch.close();
}

async fn stage2(input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }
        output_ch.send(val + 10);
    }
    output_ch.close();
}

// Pipeline erstellen
let ch1 = channel(10);
let ch2 = channel(10);
let ch3 = channel(10);

let s1 = spawn(stage1, ch1, ch2);
let s2 = spawn(stage2, ch2, ch3);

// Eingabe einspeisen
ch1.send(1);
ch1.send(2);
ch1.send(3);
ch1.close();

// Ausgabe sammeln
print(ch3.recv());  // 12 (1 * 2 + 10)
print(ch3.recv());  // 14 (2 * 2 + 10)
print(ch3.recv());  // 16 (3 * 2 + 10)

join(s1);
join(s2);
```

### Fan-Out, Fan-In

```hemlock
async fn worker(id: i32, input_ch, output_ch) {
    while (true) {
        let val = input_ch.recv();
        if (val == null) { break; }

        // Wert verarbeiten
        let result = val * id;
        output_ch.send(result);
    }
}

let input = channel(10);
let output = channel(10);

// Fan-out: Mehrere Worker
let workers = 4;
let tasks = [];
let i = 0;
while (i < workers) {
    tasks.push(spawn(worker, i, input, output));
    i = i + 1;
}

// Arbeit senden
let i = 0;
while (i < 10) {
    input.send(i);
    i = i + 1;
}
input.close();

// Fan-in: Alle Ergebnisse sammeln
let results = [];
let i = 0;
while (i < 10) {
    results.push(output.recv());
    i = i + 1;
}

// Auf alle Worker warten
let i = 0;
while (i < tasks.length) {
    join(tasks[i]);
    i = i + 1;
}
```

## Zusammenfassung

Hemlocks Async/Nebenl√§ufigkeitsmodell bietet:

- ‚úÖ Echte Multithread-Parallelit√§t mit OS-Threads
- ‚úÖ Einfache, strukturierte Nebenl√§ufigkeitsprimitive
- ‚úÖ Thread-sichere Channels f√ºr Kommunikation
- ‚úÖ Ausnahmeweiterleitung √ºber Tasks
- ‚úÖ Nachgewiesene Leistung auf Multi-Core-Systemen
- ‚úÖ **Argument-Isolation** - Tiefe Kopie verhindert Data Races
- ‚úÖ **Atomare Referenzz√§hlung** - Sicheres Speichermanagement √ºber Threads

Dies macht Hemlock geeignet f√ºr:
- Parallele Berechnungen
- Nebenl√§ufige I/O-Operationen
- Pipeline-Architekturen
- Producer-Consumer-Muster

W√§hrend die Komplexit√§t vermieden wird von:
- Manuellem Thread-Management
- Low-Level-Synchronisationsprimitiven
- Deadlock-anf√§lligen Lock-basierten Designs
- Bugs durch gemeinsamen ver√§nderlichen Zustand


--------------------------------------------------------------------------------
## Atomare Operationen
--------------------------------------------------------------------------------

# Atomare Operationen

Hemlock bietet atomare Operationen f√ºr **lock-freie nebenl√§ufige Programmierung**. Diese Operationen erm√∂glichen sichere Manipulation von gemeinsamem Speicher √ºber mehrere Threads ohne traditionelle Locks oder Mutexe.

## Inhaltsverzeichnis

- [√úberblick](#√ºberblick)
- [Wann Atomics verwenden](#wann-atomics-verwenden)
- [Speichermodell](#speichermodell)
- [Atomares Laden und Speichern](#atomares-laden-und-speichern)
- [Fetch-and-Modify-Operationen](#fetch-and-modify-operationen)
- [Compare-and-Swap (CAS)](#compare-and-swap-cas)
- [Atomarer Austausch](#atomarer-austausch)
- [Speicherbarriere](#speicherbarriere)
- [Funktionsreferenz](#funktionsreferenz)
- [H√§ufige Muster](#h√§ufige-muster)
- [Best Practices](#best-practices)
- [Einschr√§nkungen](#einschr√§nkungen)

---

## √úberblick

Atomare Operationen sind **unteilbare** Operationen, die ohne M√∂glichkeit der Unterbrechung abgeschlossen werden. Wenn ein Thread eine atomare Operation ausf√ºhrt, kann kein anderer Thread die Operation in einem teilweise abgeschlossenen Zustand beobachten.

**Hauptmerkmale:**
- Alle Operationen verwenden **sequenzielle Konsistenz** (`memory_order_seq_cst`)
- Unterst√ºtzte Typen: **i32** und **i64**
- Operationen arbeiten mit Rohpointern, die mit `alloc()` alloziert wurden
- Thread-sicher ohne explizite Locks

**Verf√ºgbare Operationen:**
- Load/Store - Werte atomar lesen und schreiben
- Add/Sub - Arithmetische Operationen, die den alten Wert zur√ºckgeben
- And/Or/Xor - Bitweise Operationen, die den alten Wert zur√ºckgeben
- CAS - Compare-and-Swap f√ºr bedingte Aktualisierungen
- Exchange - Werte atomar tauschen
- Fence - Vollst√§ndige Speicherbarriere

---

## Wann Atomics verwenden

**Verwenden Sie Atomics f√ºr:**
- Z√§hler, die √ºber Tasks geteilt werden (z.B. Anfragez√§hler, Fortschrittsverfolgung)
- Flags und Statusindikatoren
- Lock-freie Datenstrukturen
- Einfache Synchronisationsprimitive
- Leistungskritischen nebenl√§ufigen Code

**Verwenden Sie stattdessen Channels wenn:**
- Komplexe Daten zwischen Tasks √ºbergeben werden
- Producer-Consumer-Muster implementiert werden
- Message-Passing-Semantik ben√∂tigt wird

**Beispiel-Anwendungsfall - Geteilter Z√§hler:**
```hemlock
// Geteilten Z√§hler allozieren
let counter = alloc(4);
ptr_write_i32(counter, 0);

async fn worker(counter: ptr, id: i32) {
    let i = 0;
    while (i < 1000) {
        atomic_add_i32(counter, 1);
        i = i + 1;
    }
}

// Mehrere Worker spawnen
let t1 = spawn(worker, counter, 1);
let t2 = spawn(worker, counter, 2);
let t3 = spawn(worker, counter, 3);

join(t1);
join(t2);
join(t3);

// Z√§hler wird exakt 3000 sein (keine Data Races)
print(atomic_load_i32(counter));

free(counter);
```

---

## Speichermodell

Alle atomaren Operationen in Hemlock verwenden **sequenzielle Konsistenz** (`memory_order_seq_cst`), was die st√§rksten Speicherordnungsgarantien bietet:

1. **Atomarit√§t**: Jede Operation ist unteilbar
2. **Totale Ordnung**: Alle Threads sehen die gleiche Reihenfolge von Operationen
3. **Keine Umordnung**: Operationen werden nicht vom Compiler oder der CPU umgeordnet

Dies macht das Nachdenken √ºber nebenl√§ufigen Code einfacher, auf Kosten von etwas potentieller Leistung im Vergleich zu schw√§cheren Speicherordnungen.

---

## Atomares Laden und Speichern

### atomic_load_i32 / atomic_load_i64

Atomar einen Wert aus dem Speicher lesen.

**Signatur:**
```hemlock
atomic_load_i32(ptr: ptr): i32
atomic_load_i64(ptr: ptr): i64
```

**Parameter:**
- `ptr` - Pointer auf die Speicherstelle (muss korrekt ausgerichtet sein)

**R√ºckgabe:** Der Wert an der Speicherstelle

**Beispiel:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);

let value = atomic_load_i32(p);
print(value);  // 42

free(p);
```

---

### atomic_store_i32 / atomic_store_i64

Atomar einen Wert in den Speicher schreiben.

**Signatur:**
```hemlock
atomic_store_i32(ptr: ptr, value: i32): null
atomic_store_i64(ptr: ptr, value: i64): null
```

**Parameter:**
- `ptr` - Pointer auf die Speicherstelle
- `value` - Zu speichernder Wert

**R√ºckgabe:** `null`

**Beispiel:**
```hemlock
let p = alloc(8);

atomic_store_i64(p, 5000000000);
print(atomic_load_i64(p));  // 5000000000

free(p);
```

---

## Fetch-and-Modify-Operationen

Diese Operationen modifizieren atomar einen Wert und geben den **alten** (vorherigen) Wert zur√ºck.

### atomic_add_i32 / atomic_add_i64

Atomar zu einem Wert addieren.

**Signatur:**
```hemlock
atomic_add_i32(ptr: ptr, value: i32): i32
atomic_add_i64(ptr: ptr, value: i64): i64
```

**R√ºckgabe:** Der **alte** Wert (vor der Addition)

**Beispiel:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_add_i32(p, 10);
print(old);                    // 100 (alter Wert)
print(atomic_load_i32(p));     // 110 (neuer Wert)

free(p);
```

---

### atomic_sub_i32 / atomic_sub_i64

Atomar von einem Wert subtrahieren.

**Signatur:**
```hemlock
atomic_sub_i32(ptr: ptr, value: i32): i32
atomic_sub_i64(ptr: ptr, value: i64): i64
```

**R√ºckgabe:** Der **alte** Wert (vor der Subtraktion)

**Beispiel:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_sub_i32(p, 25);
print(old);                    // 100 (alter Wert)
print(atomic_load_i32(p));     // 75 (neuer Wert)

free(p);
```

---

### atomic_and_i32 / atomic_and_i64

Atomar bitweises UND ausf√ºhren.

**Signatur:**
```hemlock
atomic_and_i32(ptr: ptr, value: i32): i32
atomic_and_i64(ptr: ptr, value: i64): i64
```

**R√ºckgabe:** Der **alte** Wert (vor dem UND)

**Beispiel:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xFF);  // 255 in bin√§r: 11111111

let old = atomic_and_i32(p, 0x0F);  // UND mit 00001111
print(old);                    // 255 (alter Wert)
print(atomic_load_i32(p));     // 15 (0xFF & 0x0F = 0x0F)

free(p);
```

---

### atomic_or_i32 / atomic_or_i64

Atomar bitweises ODER ausf√ºhren.

**Signatur:**
```hemlock
atomic_or_i32(ptr: ptr, value: i32): i32
atomic_or_i64(ptr: ptr, value: i64): i64
```

**R√ºckgabe:** Der **alte** Wert (vor dem ODER)

**Beispiel:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0x0F);  // 15 in bin√§r: 00001111

let old = atomic_or_i32(p, 0xF0);  // ODER mit 11110000
print(old);                    // 15 (alter Wert)
print(atomic_load_i32(p));     // 255 (0x0F | 0xF0 = 0xFF)

free(p);
```

---

### atomic_xor_i32 / atomic_xor_i64

Atomar bitweises XOR ausf√ºhren.

**Signatur:**
```hemlock
atomic_xor_i32(ptr: ptr, value: i32): i32
atomic_xor_i64(ptr: ptr, value: i64): i64
```

**R√ºckgabe:** Der **alte** Wert (vor dem XOR)

**Beispiel:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 0xAA);  // 170 in bin√§r: 10101010

let old = atomic_xor_i32(p, 0xFF);  // XOR mit 11111111
print(old);                    // 170 (alter Wert)
print(atomic_load_i32(p));     // 85 (0xAA ^ 0xFF = 0x55)

free(p);
```

---

## Compare-and-Swap (CAS)

Die m√§chtigste atomare Operation. Vergleicht atomar den aktuellen Wert mit einem erwarteten Wert und ersetzt ihn bei √úbereinstimmung durch einen neuen Wert.

### atomic_cas_i32 / atomic_cas_i64

**Signatur:**
```hemlock
atomic_cas_i32(ptr: ptr, expected: i32, desired: i32): bool
atomic_cas_i64(ptr: ptr, expected: i64, desired: i64): bool
```

**Parameter:**
- `ptr` - Pointer auf die Speicherstelle
- `expected` - Wert, den wir erwarten vorzufinden
- `desired` - Wert, der gespeichert wird, wenn die Erwartung √ºbereinstimmt

**R√ºckgabe:**
- `true` - Tausch erfolgreich (Wert war `expected`, ist jetzt `desired`)
- `false` - Tausch fehlgeschlagen (Wert war nicht `expected`, unver√§ndert)

**Beispiel:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

// CAS erfolgreich: Wert ist 100, tausche zu 999
let success1 = atomic_cas_i32(p, 100, 999);
print(success1);               // true
print(atomic_load_i32(p));     // 999

// CAS fehlgeschlagen: Wert ist 999, nicht 100
let success2 = atomic_cas_i32(p, 100, 888);
print(success2);               // false
print(atomic_load_i32(p));     // 999 (unver√§ndert)

free(p);
```

**Anwendungsf√§lle:**
- Implementierung von Locks und Semaphoren
- Lock-freie Datenstrukturen
- Optimistische Nebenl√§ufigkeitskontrolle
- Atomare bedingte Aktualisierungen

---

## Atomarer Austausch

Atomar einen Wert tauschen und den alten Wert zur√ºckgeben.

### atomic_exchange_i32 / atomic_exchange_i64

**Signatur:**
```hemlock
atomic_exchange_i32(ptr: ptr, value: i32): i32
atomic_exchange_i64(ptr: ptr, value: i64): i64
```

**Parameter:**
- `ptr` - Pointer auf die Speicherstelle
- `value` - Neuer zu speichernder Wert

**R√ºckgabe:** Der **alte** Wert (vor dem Austausch)

**Beispiel:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 100);

let old = atomic_exchange_i32(p, 200);
print(old);                    // 100 (alter Wert)
print(atomic_load_i32(p));     // 200 (neuer Wert)

free(p);
```

---

## Speicherbarriere

Eine vollst√§ndige Speicherbarriere, die sicherstellt, dass alle Speicheroperationen vor der Barriere f√ºr alle Threads sichtbar sind, bevor irgendwelche Operationen nach der Barriere.

### atomic_fence

**Signatur:**
```hemlock
atomic_fence(): null
```

**R√ºckgabe:** `null`

**Beispiel:**
```hemlock
// Sicherstellen, dass alle vorherigen Schreiboperationen sichtbar sind
atomic_fence();
```

**Hinweis:** In den meisten F√§llen ben√∂tigen Sie keine expliziten Barrieren, da alle atomaren Operationen bereits sequenzielle Konsistenz verwenden. Barrieren sind n√ºtzlich, wenn Sie nicht-atomare Speicheroperationen synchronisieren m√ºssen.

---

## Funktionsreferenz

### i32-Operationen

| Funktion | Signatur | R√ºckgabe | Beschreibung |
|----------|----------|----------|--------------|
| `atomic_load_i32` | `(ptr)` | `i32` | Wert atomar laden |
| `atomic_store_i32` | `(ptr, value)` | `null` | Wert atomar speichern |
| `atomic_add_i32` | `(ptr, value)` | `i32` | Addieren und alten Wert zur√ºckgeben |
| `atomic_sub_i32` | `(ptr, value)` | `i32` | Subtrahieren und alten Wert zur√ºckgeben |
| `atomic_and_i32` | `(ptr, value)` | `i32` | Bitweises UND und alten Wert zur√ºckgeben |
| `atomic_or_i32` | `(ptr, value)` | `i32` | Bitweises ODER und alten Wert zur√ºckgeben |
| `atomic_xor_i32` | `(ptr, value)` | `i32` | Bitweises XOR und alten Wert zur√ºckgeben |
| `atomic_cas_i32` | `(ptr, expected, desired)` | `bool` | Compare-and-Swap |
| `atomic_exchange_i32` | `(ptr, value)` | `i32` | Austauschen und alten Wert zur√ºckgeben |

### i64-Operationen

| Funktion | Signatur | R√ºckgabe | Beschreibung |
|----------|----------|----------|--------------|
| `atomic_load_i64` | `(ptr)` | `i64` | Wert atomar laden |
| `atomic_store_i64` | `(ptr, value)` | `null` | Wert atomar speichern |
| `atomic_add_i64` | `(ptr, value)` | `i64` | Addieren und alten Wert zur√ºckgeben |
| `atomic_sub_i64` | `(ptr, value)` | `i64` | Subtrahieren und alten Wert zur√ºckgeben |
| `atomic_and_i64` | `(ptr, value)` | `i64` | Bitweises UND und alten Wert zur√ºckgeben |
| `atomic_or_i64` | `(ptr, value)` | `i64` | Bitweises ODER und alten Wert zur√ºckgeben |
| `atomic_xor_i64` | `(ptr, value)` | `i64` | Bitweises XOR und alten Wert zur√ºckgeben |
| `atomic_cas_i64` | `(ptr, expected, desired)` | `bool` | Compare-and-Swap |
| `atomic_exchange_i64` | `(ptr, value)` | `i64` | Austauschen und alten Wert zur√ºckgeben |

### Speicherbarriere

| Funktion | Signatur | R√ºckgabe | Beschreibung |
|----------|----------|----------|--------------|
| `atomic_fence` | `()` | `null` | Vollst√§ndige Speicherbarriere |

---

## H√§ufige Muster

### Muster: Atomarer Z√§hler

```hemlock
// Thread-sicherer Z√§hler
let counter = alloc(4);
ptr_write_i32(counter, 0);

fn increment(): i32 {
    return atomic_add_i32(counter, 1);
}

fn decrement(): i32 {
    return atomic_sub_i32(counter, 1);
}

fn get_count(): i32 {
    return atomic_load_i32(counter);
}

// Verwendung
increment();  // Gibt 0 zur√ºck (alter Wert)
increment();  // Gibt 1 zur√ºck
increment();  // Gibt 2 zur√ºck
print(get_count());  // 3

free(counter);
```

### Muster: Spinlock

```hemlock
// Einfache Spinlock-Implementierung
let lock = alloc(4);
ptr_write_i32(lock, 0);  // 0 = entsperrt, 1 = gesperrt

fn acquire() {
    // Drehen bis wir erfolgreich Lock von 0 auf 1 setzen
    while (!atomic_cas_i32(lock, 0, 1)) {
        // Busy-Wait
    }
}

fn release() {
    atomic_store_i32(lock, 0);
}

// Verwendung
acquire();
// ... kritischer Abschnitt ...
release();

free(lock);
```

### Muster: Einmalige Initialisierung

```hemlock
let initialized = alloc(4);
ptr_write_i32(initialized, 0);  // 0 = nicht initialisiert, 1 = initialisiert

fn ensure_initialized() {
    // Versuchen, derjenige zu sein, der initialisiert
    if (atomic_cas_i32(initialized, 0, 1)) {
        // Wir haben das Rennen gewonnen, f√ºhre Initialisierung durch
        do_expensive_init();
    }
    // Andernfalls bereits initialisiert
}
```

### Muster: Atomares Flag

```hemlock
let flag = alloc(4);
ptr_write_i32(flag, 0);

fn set_flag() {
    atomic_store_i32(flag, 1);
}

fn clear_flag() {
    atomic_store_i32(flag, 0);
}

fn test_and_set(): bool {
    // Gibt true zur√ºck, wenn Flag bereits gesetzt war
    return atomic_exchange_i32(flag, 1) == 1;
}

fn check_flag(): bool {
    return atomic_load_i32(flag) == 1;
}
```

### Muster: Begrenzter Z√§hler

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);
let max_value = 100;

fn try_increment(): bool {
    while (true) {
        let current = atomic_load_i32(counter);
        if (current >= max_value) {
            return false;  // Am Maximum
        }
        if (atomic_cas_i32(counter, current, current + 1)) {
            return true;  // Erfolgreich inkrementiert
        }
        // CAS fehlgeschlagen, ein anderer Thread hat modifiziert - erneut versuchen
    }
}
```

---

## Best Practices

### 1. Korrekte Ausrichtung verwenden

Pointer m√ºssen f√ºr den Datentyp korrekt ausgerichtet sein:
- i32: 4-Byte-Ausrichtung
- i64: 8-Byte-Ausrichtung

Speicher von `alloc()` ist typischerweise korrekt ausgerichtet.

### 2. Abstraktionen h√∂herer Ebene bevorzugen

Wenn m√∂glich, verwenden Sie Channels f√ºr Inter-Task-Kommunikation. Atomics sind auf niedrigerer Ebene und erfordern sorgf√§ltiges Nachdenken.

```hemlock
// Bevorzugen Sie dies:
let ch = channel(10);
spawn(fn() { ch.send(result); });
let value = ch.recv();

// Gegen√ºber manueller atomarer Koordination, wenn angemessen
```

### 3. ABA-Problem beachten

CAS kann unter dem ABA-Problem leiden: ein Wert √§ndert sich von A zu B und zur√ºck zu A. Ihr CAS ist erfolgreich, aber der Zustand k√∂nnte sich dazwischen ge√§ndert haben.

### 4. Vor dem Teilen initialisieren

Initialisieren Sie atomare Variablen immer, bevor Sie Tasks spawnen, die auf sie zugreifen:

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);  // Initialisieren VOR dem Spawnen

let task = spawn(worker, counter);
```

### 5. Nach Abschluss aller Tasks freigeben

Geben Sie atomaren Speicher nicht frei, w√§hrend Tasks m√∂glicherweise noch darauf zugreifen:

```hemlock
let counter = alloc(4);
ptr_write_i32(counter, 0);

let t1 = spawn(worker, counter);
let t2 = spawn(worker, counter);

join(t1);
join(t2);

// Jetzt sicher zum Freigeben
free(counter);
```

---

## Einschr√§nkungen

### Aktuelle Einschr√§nkungen

1. **Nur i32 und i64 unterst√ºtzt** - Keine atomaren Operationen f√ºr andere Typen
2. **Keine Pointer-Atomics** - K√∂nnen Pointer nicht atomar laden/speichern
3. **Nur sequenzielle Konsistenz** - Keine schw√§cheren Speicherordnungen verf√ºgbar
4. **Keine atomaren Flie√ükommazahlen** - Verwenden Sie bei Bedarf Integer-Darstellung

### Plattformhinweise

- Atomare Operationen verwenden unter der Haube C11 `<stdatomic.h>`
- Verf√ºgbar auf allen Plattformen, die POSIX-Threads unterst√ºtzen
- Garantiert lock-frei auf modernen 64-Bit-Systemen

---

## Siehe auch

- [Async/Nebenl√§ufigkeit](#advanced-async-concurrency) - Task-Spawning und Channels
- [Speicherverwaltung](#language-guide-memory) - Pointer- und Buffer-Allokation
- [Speicher-API](#reference-memory-api) - Allokationsfunktionen


--------------------------------------------------------------------------------
## Befehlsausf√ºhrung
--------------------------------------------------------------------------------

# Befehlsausf√ºhrung in Hemlock

Hemlock bietet die **eingebaute Funktion `exec()`**, um Shell-Befehle auszuf√ºhren und ihre Ausgabe zu erfassen.

## Inhaltsverzeichnis

- [√úberblick](#√ºberblick)
- [Die exec()-Funktion](#die-exec-funktion)
- [Ergebnisobjekt](#ergebnisobjekt)
- [Grundlegende Verwendung](#grundlegende-verwendung)
- [Fortgeschrittene Beispiele](#fortgeschrittene-beispiele)
- [Fehlerbehandlung](#fehlerbehandlung)
- [Implementierungsdetails](#implementierungsdetails)
- [Sicherheits√ºberlegungen](#sicherheits√ºberlegungen)
- [Einschr√§nkungen](#einschr√§nkungen)
- [Anwendungsf√§lle](#anwendungsf√§lle)
- [Best Practices](#best-practices)
- [Vollst√§ndige Beispiele](#vollst√§ndige-beispiele)

## √úberblick

Die `exec()`-Funktion erm√∂glicht Hemlock-Programmen:
- Shell-Befehle auszuf√ºhren
- Standardausgabe (stdout) zu erfassen
- Exit-Statuscodes zu pr√ºfen
- Shell-Funktionen zu nutzen (Pipes, Umleitungen, etc.)
- Mit System-Dienstprogrammen zu integrieren

**Wichtig:** Befehle werden √ºber `/bin/sh` ausgef√ºhrt, was volle Shell-Funktionalit√§t bietet, aber auch Sicherheits√ºberlegungen mit sich bringt.

## Die exec()-Funktion

### Signatur

```hemlock
exec(command: string): object
```

**Parameter:**
- `command` (string) - Auszuf√ºhrender Shell-Befehl

**R√ºckgabe:** Ein Objekt mit zwei Feldern:
- `output` (string) - Die stdout-Ausgabe des Befehls
- `exit_code` (i32) - Der Exit-Statuscode des Befehls

### Einfaches Beispiel

```hemlock
let result = exec("echo hello");
print(result.output);      // "hello\n"
print(result.exit_code);   // 0
```

## Ergebnisobjekt

Das von `exec()` zur√ºckgegebene Objekt hat folgende Struktur:

```hemlock
{
    output: string,      // Befehl stdout (erfasste Ausgabe)
    exit_code: i32       // Prozess-Exit-Status (0 = Erfolg)
}
```

### output-Feld

Enth√§lt den gesamten Text, der vom Befehl auf stdout geschrieben wurde.

**Eigenschaften:**
- Leerer String, wenn Befehl keine Ausgabe erzeugt
- Enth√§lt Zeilenumbr√ºche und Leerzeichen wie vorhanden
- Mehrzeilige Ausgabe bleibt erhalten
- Nicht gr√∂√üenbeschr√§nkt (dynamisch alloziert)

**Beispiele:**
```hemlock
let r1 = exec("echo test");
print(r1.output);  // "test\n"

let r2 = exec("ls");
print(r2.output);  // Verzeichnisliste mit Zeilenumbr√ºchen

let r3 = exec("true");
print(r3.output);  // "" (leerer String)
```

### exit_code-Feld

Der Exit-Statuscode des Befehls.

**Werte:**
- `0` zeigt typischerweise Erfolg an
- `1-255` zeigen Fehler an (Konvention variiert nach Befehl)
- `-1` wenn Befehl nicht ausgef√ºhrt werden konnte oder abnormal beendet wurde

**Beispiele:**
```hemlock
let r1 = exec("true");
print(r1.exit_code);  // 0 (Erfolg)

let r2 = exec("false");
print(r2.exit_code);  // 1 (Fehler)

let r3 = exec("ls /nonexistent");
print(r3.exit_code);  // 2 (Datei nicht gefunden, variiert nach Befehl)
```

## Grundlegende Verwendung

### Einfacher Befehl

```hemlock
let r = exec("ls -la");
print(r.output);
print("Exit-Code: " + typeof(r.exit_code));
```

### Exit-Status pr√ºfen

```hemlock
let r = exec("grep pattern file.txt");
if (r.exit_code == 0) {
    print("Gefunden: " + r.output);
} else {
    print("Muster nicht gefunden");
}
```

### Befehle mit Pipes

```hemlock
let r = exec("ps aux | grep hemlock");
print(r.output);
```

### Mehrere Befehle

```hemlock
let r = exec("cd /tmp && ls -la");
print(r.output);
```

### Befehlsersetzung

```hemlock
let r = exec("echo $(date)");
print(r.output);  // Aktuelles Datum
```

## Fortgeschrittene Beispiele

### Fehler behandeln

```hemlock
let r = exec("ls /nonexistent");
if (r.exit_code != 0) {
    print("Befehl fehlgeschlagen mit Code: " + typeof(r.exit_code));
    print("Fehlerausgabe: " + r.output);  // Hinweis: stderr wird nicht erfasst
}
```

### Mehrzeilige Ausgabe verarbeiten

```hemlock
let r = exec("cat file.txt");
let lines = r.output.split("\n");
let i = 0;
while (i < lines.length) {
    print("Zeile " + typeof(i) + ": " + lines[i]);
    i = i + 1;
}
```

### Befehlsverkettung

**Mit && (UND):**
```hemlock
let r1 = exec("mkdir -p /tmp/test && touch /tmp/test/file.txt");
if (r1.exit_code == 0) {
    print("Setup abgeschlossen");
}
```

**Mit || (ODER):**
```hemlock
let r = exec("command1 || command2");
// F√ºhrt command2 nur aus, wenn command1 fehlschl√§gt
```

**Mit ; (Sequenz):**
```hemlock
let r = exec("command1; command2");
// F√ºhrt beide aus, unabh√§ngig von Erfolg/Fehler
```

### Pipes verwenden

```hemlock
let r = exec("echo 'data' | base64");
print("Base64: " + r.output);
```

**Komplexe Pipelines:**
```hemlock
let r = exec("cat /etc/passwd | grep root | cut -d: -f1");
print(r.output);
```

### Exit-Code-Muster

Verschiedene Exit-Codes zeigen verschiedene Bedingungen an:

```hemlock
let r = exec("test -f myfile.txt");
if (r.exit_code == 0) {
    print("Datei existiert");
} else if (r.exit_code == 1) {
    print("Datei existiert nicht");
} else {
    print("Test-Befehl fehlgeschlagen: " + typeof(r.exit_code));
}
```

### Ausgabe-Umleitungen

```hemlock
// stdout in Datei umleiten (innerhalb der Shell)
let r1 = exec("echo 'test' > /tmp/output.txt");

// stderr zu stdout umleiten (Hinweis: stderr wird von Hemlock immer noch nicht erfasst)
let r2 = exec("command 2>&1");
```

### Umgebungsvariablen

```hemlock
let r = exec("export VAR=value && echo $VAR");
print(r.output);  // "value\n"
```

### Arbeitsverzeichnis-√Ñnderungen

```hemlock
let r = exec("cd /tmp && pwd");
print(r.output);  // "/tmp\n"
```

## Fehlerbehandlung

### Wann exec() Ausnahmen wirft

Die `exec()`-Funktion wirft eine Ausnahme, wenn der Befehl nicht ausgef√ºhrt werden kann:

```hemlock
try {
    let r = exec("nonexistent_command_xyz");
} catch (e) {
    print("Ausf√ºhrung fehlgeschlagen: " + e);
}
```

**Ausnahmen werden geworfen wenn:**
- `popen()` fehlschl√§gt (z.B. Pipe kann nicht erstellt werden)
- Systemressourcengrenzen √ºberschritten werden
- Speicherallokationsfehler auftreten

### Wann exec() NICHT wirft

```hemlock
// Befehl l√§uft, gibt aber Nicht-Null-Exit-Code zur√ºck
let r1 = exec("false");
print(r1.exit_code);  // 1 (keine Ausnahme)

// Befehl erzeugt keine Ausgabe
let r2 = exec("true");
print(r2.output);  // "" (keine Ausnahme)

// Befehl von Shell nicht gefunden
let r3 = exec("nonexistent_cmd");
print(r3.exit_code);  // 127 (keine Ausnahme)
```

### Sicheres Ausf√ºhrungsmuster

```hemlock
fn safe_exec(command: string) {
    try {
        let r = exec(command);
        if (r.exit_code != 0) {
            print("Warnung: Befehl fehlgeschlagen mit Code " + typeof(r.exit_code));
            return "";
        }
        return r.output;
    } catch (e) {
        print("Fehler beim Ausf√ºhren des Befehls: " + e);
        return "";
    }
}

let output = safe_exec("ls -la");
```

## Implementierungsdetails

### Wie es funktioniert

**Unter der Haube:**
- Verwendet `popen()`, um Befehle √ºber `/bin/sh` auszuf√ºhren
- Erfasst nur stdout (stderr wird nicht erfasst)
- Ausgabe wird dynamisch gepuffert (beginnt bei 4KB, w√§chst bei Bedarf)
- Exit-Status wird mit `WIFEXITED()` und `WEXITSTATUS()` Makros extrahiert
- Ausgabe-String wird korrekt null-terminiert

**Prozessablauf:**
1. `popen(command, "r")` erstellt Pipe und forkt Prozess
2. Kindprozess f√ºhrt `/bin/sh -c "command"` aus
3. Elternprozess liest stdout √ºber Pipe in wachsenden Puffer
4. `pclose()` wartet auf Kind und gibt Exit-Status zur√ºck
5. Exit-Status wird extrahiert und im Ergebnisobjekt gespeichert

### Leistungs√ºberlegungen

**Kosten:**
- Erstellt einen neuen Shell-Prozess f√ºr jeden Aufruf (~1-5ms Overhead)
- Ausgabe wird vollst√§ndig im Speicher gehalten (nicht gestreamt)
- Keine Streaming-Unterst√ºtzung (wartet auf Befehlsabschluss)
- Geeignet f√ºr Befehle mit vern√ºnftigen Ausgabegr√∂√üen

**Optimierungen:**
- Puffer beginnt bei 4KB und verdoppelt sich bei F√ºllung (effiziente Speichernutzung)
- Einzelne Leseschleife minimiert Systemaufrufe
- Kein zus√§tzliches String-Kopieren

**Wann zu verwenden:**
- Kurz laufende Befehle (< 1 Sekunde)
- Moderate Ausgabegr√∂√üe (< 10MB)
- Batch-Operationen mit vern√ºnftigen Intervallen

**Wann NICHT zu verwenden:**
- Lang laufende Daemons oder Dienste
- Befehle, die Gigabytes an Ausgabe erzeugen
- Echtzeit-Streaming-Datenverarbeitung
- Hochfrequente Ausf√ºhrung (> 100 Aufrufe/Sekunde)

## Sicherheits√ºberlegungen

### Shell-Injection-Risiko

‚ö†Ô∏è **KRITISCH:** Befehle werden von der Shell (`/bin/sh`) ausgef√ºhrt, was bedeutet, dass **Shell-Injection m√∂glich** ist.

**Verwundbarer Code:**
```hemlock
// GEF√ÑHRLICH - TUN SIE DAS NICHT
let filename = args[1];  // Benutzereingabe
let r = exec("cat " + filename);  // Shell-Injection!
```

**Angriff:**
```bash
./hemlock script.hml "; rm -rf /; echo pwned"
# F√ºhrt aus: cat ; rm -rf /; echo pwned
```

### Sichere Praktiken

**1. Niemals unsanitisierte Benutzereingaben verwenden:**
```hemlock
// Schlecht
let user_input = args[1];
let r = exec("process " + user_input);  // GEF√ÑHRLICH

// Gut - zuerst validieren
fn is_safe_filename(name: string): bool {
    // Nur alphanumerische Zeichen, Bindestrich, Unterstrich, Punkt erlauben
    let i = 0;
    while (i < name.length) {
        let c = name[i];
        if (!(c >= 'a' && c <= 'z') &&
            !(c >= 'A' && c <= 'Z') &&
            !(c >= '0' && c <= '9') &&
            c != '-' && c != '_' && c != '.') {
            return false;
        }
        i = i + 1;
    }
    return true;
}

let filename = args[1];
if (is_safe_filename(filename)) {
    let r = exec("cat " + filename);
} else {
    print("Ung√ºltiger Dateiname");
}
```

**2. Allowlists verwenden, nicht Denylists:**
```hemlock
// Gut - strikte Allowlist
let allowed_commands = ["status", "start", "stop", "restart"];
let cmd = args[1];

let found = false;
for (let allowed in allowed_commands) {
    if (cmd == allowed) {
        found = true;
        break;
    }
}

if (found) {
    exec("service myapp " + cmd);
} else {
    print("Ung√ºltiger Befehl");
}
```

**3. Sonderzeichen escapen:**
```hemlock
fn shell_escape(s: string): string {
    // Einfaches Escapen - in einfache Anf√ºhrungszeichen setzen und einfache Anf√ºhrungszeichen escapen
    let escaped = s.replace_all("'", "'\\''");
    return "'" + escaped + "'";
}

let user_file = args[1];
let safe = shell_escape(user_file);
let r = exec("cat " + safe);
```

**4. exec() f√ºr Dateioperationen vermeiden:**
```hemlock
// Schlecht - exec f√ºr Dateioperationen verwenden
let r = exec("cat file.txt");

// Gut - Hemlocks Datei-API verwenden
let f = open("file.txt", "r");
let content = f.read();
f.close();
```

### Berechtigungs√ºberlegungen

Befehle laufen mit den gleichen Berechtigungen wie der Hemlock-Prozess:

```hemlock
// Wenn Hemlock als root l√§uft, laufen exec()-Befehle auch als root!
let r = exec("rm -rf /important");  // GEF√ÑHRLICH wenn als root
```

**Best Practice:** Hemlock mit den geringstm√∂glichen Rechten ausf√ºhren.

## Einschr√§nkungen

### 1. Keine stderr-Erfassung

Nur stdout wird erfasst, stderr geht zum Terminal:

```hemlock
let r = exec("ls /nonexistent");
// r.output ist leer
// Fehlermeldung erscheint im Terminal, wird nicht erfasst
```

**Workaround - stderr zu stdout umleiten:**
```hemlock
let r = exec("ls /nonexistent 2>&1");
// Jetzt sind Fehlermeldungen in r.output
```

### 2. Kein Streaming

Muss auf Befehlsabschluss warten:

```hemlock
let r = exec("long_running_command");
// Blockiert bis Befehl fertig
// Kann Ausgabe nicht inkrementell verarbeiten
```

### 3. Kein Timeout

Befehle k√∂nnen unbegrenzt laufen:

```hemlock
let r = exec("sleep 1000");
// Blockiert f√ºr 1000 Sekunden
// Keine M√∂glichkeit f√ºr Timeout oder Abbruch
```

**Workaround - timeout-Befehl verwenden:**
```hemlock
let r = exec("timeout 5 long_command");
// Timeout nach 5 Sekunden
```

### 4. Keine Signalbehandlung

Kann keine Signale an laufende Befehle senden:

```hemlock
let r = exec("long_command");
// Kann SIGINT, SIGTERM, etc. nicht an den Befehl senden
```

### 5. Keine Prozesssteuerung

Kann nicht mit Befehl nach dem Start interagieren:

```hemlock
let r = exec("interactive_program");
// Kann keine Eingabe an das Programm senden
// Kann Ausf√ºhrung nicht steuern
```

## Anwendungsf√§lle

### Gute Anwendungsf√§lle

**1. System-Dienstprogramme ausf√ºhren:**
```hemlock
let r = exec("ls -la");
let r = exec("grep pattern file.txt");
let r = exec("find /path -name '*.txt'");
```

**2. Schnelle Datenverarbeitung mit Unix-Tools:**
```hemlock
let r = exec("cat data.txt | sort | uniq | wc -l");
print("Eindeutige Zeilen: " + r.output);
```

**3. Systemstatus pr√ºfen:**
```hemlock
let r = exec("df -h");
print("Festplattennutzung:\n" + r.output);
```

**4. Dateiexistenz-Pr√ºfungen:**
```hemlock
let r = exec("test -f myfile.txt");
if (r.exit_code == 0) {
    print("Datei existiert");
}
```

**5. Berichte generieren:**
```hemlock
let r = exec("ps aux | grep myapp | wc -l");
let count = r.output.trim();
print("Laufende Instanzen: " + count);
```

**6. Automatisierungsskripte:**
```hemlock
exec("git add .");
exec("git commit -m 'Auto commit'");
let r = exec("git push");
if (r.exit_code != 0) {
    print("Push fehlgeschlagen");
}
```

### Nicht empfohlen f√ºr

**1. Lang laufende Dienste:**
```hemlock
// Schlecht
let r = exec("nginx");  // Blockiert f√ºr immer
```

**2. Interaktive Befehle:**
```hemlock
// Schlecht - kann keine Eingabe bereitstellen
let r = exec("ssh user@host");
```

**3. Befehle mit riesiger Ausgabe:**
```hemlock
// Schlecht - l√§dt gesamte Ausgabe in Speicher
let r = exec("cat 10GB_file.log");
```

**4. Echtzeit-Streaming:**
```hemlock
// Schlecht - kann Ausgabe nicht inkrementell verarbeiten
let r = exec("tail -f /var/log/app.log");
```

**5. Missionskritische Fehlerbehandlung:**
```hemlock
// Schlecht - stderr wird nicht erfasst
let r = exec("critical_operation");
// Kann detaillierte Fehlermeldungen nicht sehen
```

## Best Practices

### 1. Immer Exit-Codes pr√ºfen

```hemlock
let r = exec("important_command");
if (r.exit_code != 0) {
    print("Befehl fehlgeschlagen!");
    // Fehler behandeln
}
```

### 2. Ausgabe bei Bedarf trimmen

```hemlock
let r = exec("echo test");
let clean = r.output.trim();  // Abschlie√üenden Zeilenumbruch entfernen
print(clean);  // "test" (kein Zeilenumbruch)
```

### 3. Vor dem Ausf√ºhren validieren

```hemlock
fn is_valid_command(cmd: string): bool {
    // Validieren, dass Befehl sicher ist
    return true;  // Ihre Validierungslogik
}

if (is_valid_command(user_cmd)) {
    exec(user_cmd);
}
```

### 4. try/catch f√ºr kritische Operationen verwenden

```hemlock
try {
    let r = exec("critical_command");
    if (r.exit_code != 0) {
        throw "Befehl fehlgeschlagen";
    }
} catch (e) {
    print("Fehler: " + e);
    // Bereinigung oder Wiederherstellung
}
```

### 5. Hemlock-APIs gegen√ºber exec() bevorzugen

```hemlock
// Schlecht - exec f√ºr Dateioperationen verwenden
let r = exec("cat file.txt");

// Gut - Hemlocks Datei-API verwenden
let f = open("file.txt", "r");
let content = f.read();
f.close();
```

### 6. stderr bei Bedarf erfassen

```hemlock
// stderr zu stdout umleiten
let r = exec("command 2>&1");
// Jetzt enth√§lt r.output sowohl stdout als auch stderr
```

### 7. Shell-Funktionen weise nutzen

```hemlock
// Pipes f√ºr Effizienz verwenden
let r = exec("cat large.txt | grep pattern | head -n 10");

// Befehlsersetzung verwenden
let r = exec("echo Aktueller Benutzer: $(whoami)");

// Bedingte Ausf√ºhrung verwenden
let r = exec("test -f file.txt && cat file.txt");
```

## Vollst√§ndige Beispiele

### Beispiel 1: Systeminformationen sammeln

```hemlock
fn get_system_info() {
    print("=== Systeminformationen ===");

    // Hostname
    let r1 = exec("hostname");
    print("Hostname: " + r1.output.trim());

    // Betriebszeit
    let r2 = exec("uptime");
    print("Betriebszeit: " + r2.output.trim());

    // Festplattennutzung
    let r3 = exec("df -h /");
    print("\nFestplattennutzung:");
    print(r3.output);

    // Speichernutzung
    let r4 = exec("free -h");
    print("Speichernutzung:");
    print(r4.output);
}

get_system_info();
```

### Beispiel 2: Log-Analysator

```hemlock
fn analyze_log(logfile: string) {
    print("Analysiere Log: " + logfile);

    // Gesamtzeilen z√§hlen
    let r1 = exec("wc -l " + logfile);
    print("Gesamtzeilen: " + r1.output.trim());

    // Fehler z√§hlen
    let r2 = exec("grep -c ERROR " + logfile + " 2>/dev/null");
    let errors = r2.output.trim();
    if (r2.exit_code == 0) {
        print("Fehler: " + errors);
    } else {
        print("Fehler: 0");
    }

    // Warnungen z√§hlen
    let r3 = exec("grep -c WARN " + logfile + " 2>/dev/null");
    let warnings = r3.output.trim();
    if (r3.exit_code == 0) {
        print("Warnungen: " + warnings);
    } else {
        print("Warnungen: 0");
    }

    // Letzte Fehler
    print("\nLetzte Fehler:");
    let r4 = exec("grep ERROR " + logfile + " | tail -n 5");
    print(r4.output);
}

if (args.length < 2) {
    print("Verwendung: " + args[0] + " <logfile>");
} else {
    analyze_log(args[1]);
}
```

### Beispiel 3: Git-Helfer

```hemlock
fn git_status() {
    let r = exec("git status --short");
    if (r.exit_code != 0) {
        print("Fehler: Kein Git-Repository");
        return;
    }

    if (r.output == "") {
        print("Arbeitsverzeichnis sauber");
    } else {
        print("√Ñnderungen:");
        print(r.output);
    }
}

fn git_quick_commit(message: string) {
    print("F√ºge alle √Ñnderungen hinzu...");
    let r1 = exec("git add -A");
    if (r1.exit_code != 0) {
        print("Fehler beim Hinzuf√ºgen von Dateien");
        return;
    }

    print("Committe...");
    let safe_msg = message.replace_all("'", "'\\''");
    let r2 = exec("git commit -m '" + safe_msg + "'");
    if (r2.exit_code != 0) {
        print("Fehler beim Committen");
        return;
    }

    print("Erfolgreich committed");
    print(r2.output);
}

// Verwendung
git_status();
if (args.length > 1) {
    git_quick_commit(args[1]);
}
```

### Beispiel 4: Backup-Skript

```hemlock
fn backup_directory(source: string, dest: string) {
    print("Sichere " + source + " nach " + dest);

    // Backup-Verzeichnis erstellen
    let r1 = exec("mkdir -p " + dest);
    if (r1.exit_code != 0) {
        print("Fehler beim Erstellen des Backup-Verzeichnisses");
        return false;
    }

    // Tarball mit Zeitstempel erstellen
    let r2 = exec("date +%Y%m%d_%H%M%S");
    let timestamp = r2.output.trim();
    let backup_file = dest + "/backup_" + timestamp + ".tar.gz";

    print("Erstelle Archiv: " + backup_file);
    let r3 = exec("tar -czf " + backup_file + " " + source + " 2>&1");
    if (r3.exit_code != 0) {
        print("Fehler beim Erstellen des Backups:");
        print(r3.output);
        return false;
    }

    print("Backup erfolgreich abgeschlossen");

    // Backup-Gr√∂√üe anzeigen
    let r4 = exec("du -h " + backup_file);
    print("Backup-Gr√∂√üe: " + r4.output.trim());

    return true;
}

if (args.length < 3) {
    print("Verwendung: " + args[0] + " <source> <destination>");
} else {
    backup_directory(args[1], args[2]);
}
```

## Zusammenfassung

Hemlocks `exec()`-Funktion bietet:

- ‚úÖ Einfache Shell-Befehlsausf√ºhrung
- ‚úÖ Ausgabeerfassung (stdout)
- ‚úÖ Exit-Code-Pr√ºfung
- ‚úÖ Voller Zugang zu Shell-Funktionen (Pipes, Umleitungen, etc.)
- ‚úÖ Integration mit System-Dienstprogrammen

Denken Sie daran:
- Immer Exit-Codes pr√ºfen
- Sich der Sicherheitsimplikationen bewusst sein (Shell-Injection)
- Benutzereingaben vor der Verwendung in Befehlen validieren
- Hemlock-APIs gegen√ºber exec() bevorzugen, wenn verf√ºgbar
- stderr wird nicht erfasst (verwenden Sie `2>&1` zum Umleiten)
- Befehle blockieren bis zur Fertigstellung
- F√ºr kurz laufende Dienstprogramme verwenden, nicht f√ºr lang laufende Dienste

**Sicherheitscheckliste:**
- ‚ùå Niemals unsanitisierte Benutzereingaben verwenden
- ‚úÖ Alle Eingaben validieren
- ‚úÖ Allowlists f√ºr Befehle verwenden
- ‚úÖ Sonderzeichen bei Bedarf escapen
- ‚úÖ Mit geringstm√∂glichen Rechten ausf√ºhren
- ‚úÖ Hemlock-APIs gegen√ºber Shell-Befehlen bevorzugen


--------------------------------------------------------------------------------
## B√ºndeln & Paketieren
--------------------------------------------------------------------------------

# Bundling & Paketierung

Hemlock bietet eingebaute Werkzeuge, um Multi-Datei-Projekte in einzelne verteilbare Dateien zu b√ºndeln und eigenst√§ndige ausf√ºhrbare Dateien zu erstellen.

## √úberblick

| Befehl | Ausgabe | Anwendungsfall |
|--------|---------|----------------|
| `--bundle` | `.hmlc` oder `.hmlb` | Bytecode verteilen (erfordert Hemlock zur Ausf√ºhrung) |
| `--package` | Ausf√ºhrbare Datei | Eigenst√§ndige Bin√§rdatei (keine Abh√§ngigkeiten) |
| `--compile` | `.hmlc` | Einzelne Datei kompilieren (keine Import-Aufl√∂sung) |

## Bundling

Der Bundler l√∂st alle `import`-Anweisungen von einem Einstiegspunkt auf und flacht sie in eine einzelne Datei ab.

### Grundlegende Verwendung

```bash
# app.hml und alle Imports in app.hmlc b√ºndeln
hemlock --bundle app.hml

# Ausgabepfad angeben
hemlock --bundle app.hml -o dist/app.hmlc

# Komprimiertes Bundle erstellen (.hmlb) - kleinere Dateigr√∂√üe
hemlock --bundle app.hml --compress -o app.hmlb

# Ausf√ºhrliche Ausgabe (zeigt aufgel√∂ste Module)
hemlock --bundle app.hml --verbose
```

### Ausgabeformate

**`.hmlc` (Unkomprimiert)**
- Serialisiertes AST-Format
- Schnell zu laden und auszuf√ºhren
- Standard-Ausgabeformat

**`.hmlb` (Komprimiert)**
- zlib-komprimiertes `.hmlc`
- Kleinere Dateigr√∂√üe (typischerweise 50-70% Reduktion)
- Etwas langsamerer Start durch Dekomprimierung

### Geb√ºndelte Dateien ausf√ºhren

```bash
# Unkomprimiertes Bundle ausf√ºhren
hemlock app.hmlc

# Komprimiertes Bundle ausf√ºhren
hemlock app.hmlb

# Argumente √ºbergeben
hemlock app.hmlc arg1 arg2
```

### Beispiel: Multi-Modul-Projekt

```
myapp/
‚îú‚îÄ‚îÄ main.hml
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ math.hml
‚îÇ   ‚îî‚îÄ‚îÄ utils.hml
‚îî‚îÄ‚îÄ config.hml
```

```hemlock
// main.hml
import { add, multiply } from "./lib/math.hml";
import { log } from "./lib/utils.hml";
import { VERSION } from "./config.hml";

log(`App v${VERSION}`);
print(add(2, 3));
```

```bash
hemlock --bundle myapp/main.hml -o myapp.hmlc
hemlock myapp.hmlc  # L√§uft mit allen geb√ºndelten Abh√§ngigkeiten
```

### stdlib-Imports

Der Bundler l√∂st automatisch `@stdlib/`-Imports auf:

```hemlock
import { HashMap } from "@stdlib/collections";
import { now } from "@stdlib/time";
```

Beim B√ºndeln werden stdlib-Module in die Ausgabe einbezogen.

## Paketierung

Paketierung erstellt eine eigenst√§ndige ausf√ºhrbare Datei, indem der geb√ºndelte Bytecode in eine Kopie des Hemlock-Interpreters eingebettet wird.

### Grundlegende Verwendung

```bash
# Ausf√ºhrbare Datei aus app.hml erstellen
hemlock --package app.hml

# Ausgabenamen angeben
hemlock --package app.hml -o myapp

# Komprimierung √ºberspringen (schnellerer Start, gr√∂√üere Datei)
hemlock --package app.hml --no-compress

# Ausf√ºhrliche Ausgabe
hemlock --package app.hml --verbose
```

### Paketierte ausf√ºhrbare Dateien ausf√ºhren

```bash
# Die paketierte ausf√ºhrbare Datei l√§uft direkt
./myapp

# Argumente werden an das Skript √ºbergeben
./myapp arg1 arg2
```

### Paketformat

Paketierte ausf√ºhrbare Dateien verwenden das HMLP-Format:

```
[hemlock binary][HMLB/HMLC payload][payload_size:u64][HMLP magic:u32]
```

Wenn eine paketierte ausf√ºhrbare Datei l√§uft:
1. Sie pr√ºft auf ein eingebettetes Payload am Ende der Datei
2. Falls gefunden, dekomprimiert und f√ºhrt sie das Payload aus
3. Falls nicht gefunden, verh√§lt sie sich wie ein normaler Hemlock-Interpreter

### Komprimierungsoptionen

| Flag | Format | Start | Gr√∂√üe |
|------|--------|-------|-------|
| (Standard) | HMLB | Normal | Kleiner |
| `--no-compress` | HMLC | Schneller | Gr√∂√üer |

F√ºr CLI-Tools, bei denen Startzeit wichtig ist, verwenden Sie `--no-compress`.

## Bundles inspizieren

Verwenden Sie `--info`, um geb√ºndelte oder kompilierte Dateien zu inspizieren:

```bash
hemlock --info app.hmlc
```

Ausgabe:
```
=== Datei-Info: app.hmlc ===
Gr√∂√üe: 12847 Bytes
Format: HMLC (kompilierter AST)
Version: 1
Flags: 0x0001 [DEBUG]
Strings: 42
Anweisungen: 156
```

```bash
hemlock --info app.hmlb
```

Ausgabe:
```
=== Datei-Info: app.hmlb ===
Gr√∂√üe: 5234 Bytes
Format: HMLB (komprimiertes Bundle)
Version: 1
Unkomprimiert: 12847 Bytes
Komprimiert: 5224 Bytes
Verh√§ltnis: 59,3% Reduktion
```

## Native Kompilierung

F√ºr echte native ausf√ºhrbare Dateien (kein Interpreter) verwenden Sie den Hemlock-Compiler:

```bash
# Zu nativer ausf√ºhrbarer Datei √ºber C kompilieren
hemlockc app.hml -o app

# Generierten C-Code behalten
hemlockc app.hml -o app --keep-c

# Nur C ausgeben (nicht kompilieren)
hemlockc app.hml -c -o app.c

# Optimierungsstufe
hemlockc app.hml -o app -O2
```

Der Compiler generiert C-Code und ruft GCC auf, um eine native Bin√§rdatei zu erzeugen. Dies erfordert:
- Die Hemlock-Laufzeitbibliothek (`libhemlock_runtime`)
- Einen C-Compiler (standardm√§√üig GCC)

### Compiler-Optionen

| Option | Beschreibung |
|--------|--------------|
| `-o <file>` | Name der ausf√ºhrbaren Ausgabedatei |
| `-c` | Nur C-Code ausgeben |
| `--emit-c <file>` | C in angegebene Datei schreiben |
| `-k, --keep-c` | Generierten C-Code nach Kompilierung behalten |
| `-O<level>` | Optimierungsstufe (0-3) |
| `--cc <path>` | Zu verwendender C-Compiler |
| `--runtime <path>` | Pfad zur Laufzeitbibliothek |
| `-v, --verbose` | Ausf√ºhrliche Ausgabe |

## Vergleich

| Ansatz | Portabilit√§t | Start | Gr√∂√üe | Abh√§ngigkeiten |
|--------|--------------|-------|-------|----------------|
| `.hml` | Nur Quellcode | Parse-Zeit | Kleinste | Hemlock |
| `.hmlc` | Nur Hemlock | Schnell | Klein | Hemlock |
| `.hmlb` | Nur Hemlock | Schnell | Kleiner | Hemlock |
| `--package` | Eigenst√§ndig | Schnell | Gr√∂√üer | Keine |
| `hemlockc` | Nativ | Schnellste | Variiert | Laufzeit-Libs |

## Best Practices

1. **Entwicklung**: `.hml`-Dateien direkt ausf√ºhren f√ºr schnelle Iteration
2. **Verteilung (mit Hemlock)**: Mit `--compress` f√ºr kleinere Dateien b√ºndeln
3. **Verteilung (eigenst√§ndig)**: Paketieren f√ºr Deployment ohne Abh√§ngigkeiten
4. **Leistungskritisch**: `hemlockc` f√ºr native Kompilierung verwenden

## Fehlerbehebung

### "Cannot find stdlib"

Der Bundler sucht nach stdlib in:
1. `./stdlib` (relativ zur ausf√ºhrbaren Datei)
2. `../stdlib` (relativ zur ausf√ºhrbaren Datei)
3. `/usr/local/lib/hemlock/stdlib`

Stellen Sie sicher, dass Hemlock ordnungsgem√§√ü installiert ist oder f√ºhren Sie es aus dem Quellverzeichnis aus.

### Zirkul√§re Abh√§ngigkeiten

```
Fehler: Zirkul√§re Abh√§ngigkeit beim Laden von 'path/to/module.hml' erkannt
```

Refaktorieren Sie Ihre Imports, um den Zyklus zu durchbrechen. Erw√§gen Sie die Verwendung eines gemeinsamen Moduls f√ºr gemeinsame Typen.

### Gro√üe Paketgr√∂√üe

- Verwenden Sie die Standardkomprimierung (verwenden Sie nicht `--no-compress`)
- Die paketierte Gr√∂√üe beinhaltet den vollst√§ndigen Interpreter (~500KB-1MB Basis)
- F√ºr minimale Gr√∂√üe verwenden Sie `hemlockc` f√ºr native Kompilierung


--------------------------------------------------------------------------------
## FFI
--------------------------------------------------------------------------------

# Foreign Function Interface (FFI) in Hemlock

Hemlock bietet **FFI (Foreign Function Interface)**, um C-Funktionen aus Shared Libraries unter Verwendung von libffi aufzurufen, was die Integration mit bestehenden C-Bibliotheken und System-APIs erm√∂glicht.

## Inhaltsverzeichnis

- [√úberblick](#√ºberblick)
- [Aktueller Status](#aktueller-status)
- [Unterst√ºtzte Typen](#unterst√ºtzte-typen)
- [Grundkonzepte](#grundkonzepte)
- [FFI-Funktionen exportieren](#ffi-funktionen-exportieren)
- [Anwendungsf√§lle](#anwendungsf√§lle)
- [Zuk√ºnftige Entwicklung](#zuk√ºnftige-entwicklung)
- [FFI-Callbacks](#ffi-callbacks)
- [FFI-Structs](#ffi-structs)
- [Struct-Typen exportieren](#struct-typen-exportieren)
- [Aktuelle Einschr√§nkungen](#aktuelle-einschr√§nkungen)
- [Best Practices](#best-practices)

## √úberblick

Das Foreign Function Interface (FFI) erm√∂glicht Hemlock-Programmen:
- C-Funktionen aus Shared Libraries (.so, .dylib, .dll) aufzurufen
- Bestehende C-Bibliotheken ohne Wrapper-Code zu verwenden
- Direkt auf System-APIs zuzugreifen
- Mit nativen Bibliotheken von Drittanbietern zu integrieren
- Hemlock mit Low-Level-Systemfunktionalit√§t zu verbinden

**Hauptf√§higkeiten:**
- Dynamisches Laden von Bibliotheken
- C-Funktionsbindung
- Automatische Typkonvertierung zwischen Hemlock- und C-Typen
- Unterst√ºtzung f√ºr alle primitiven Typen
- libffi-basierte Implementierung f√ºr Portabilit√§t

## Aktueller Status

FFI-Unterst√ºtzung ist in Hemlock mit folgenden Funktionen verf√ºgbar:

**Implementiert:**
- ‚úÖ C-Funktionen aus Shared Libraries aufrufen
- ‚úÖ Unterst√ºtzung f√ºr alle primitiven Typen (Integer, Floats, Pointer)
- ‚úÖ Automatische Typkonvertierung
- ‚úÖ libffi-basierte Implementierung
- ‚úÖ Dynamisches Laden von Bibliotheken
- ‚úÖ **Funktionspointer-Callbacks** - Hemlock-Funktionen an C √ºbergeben
- ‚úÖ **Extern-Funktionen exportieren** - FFI-Bindungen √ºber Module teilen
- ‚úÖ **Struct-√úbergabe und R√ºckgabewerte** - C-kompatible Structs by Value √ºbergeben
- ‚úÖ **Vollst√§ndige Pointer-Hilfsfunktionen** - Alle Typen lesen/schreiben (i8-i64, u8-u64, f32, f64, ptr)
- ‚úÖ **Buffer/Pointer-Konvertierung** - `buffer_ptr()`, `ptr_to_buffer()`
- ‚úÖ **FFI-Typgr√∂√üen** - `ffi_sizeof()` f√ºr plattformbewusste Typgr√∂√üen
- ‚úÖ **Plattformtypen** - `size_t`, `usize`, `isize`, `intptr_t`-Unterst√ºtzung

**In Entwicklung:**
- üîÑ String-Marshaling-Hilfsfunktionen
- üîÑ Fehlerbehandlungsverbesserungen

**Testabdeckung:**
- FFI-Tests bestanden einschlie√ülich Callback-Tests
- Grundlegende Funktionsaufrufe verifiziert
- Typkonvertierung getestet
- qsort-Callback-Integration getestet

## Unterst√ºtzte Typen

### Primitive Typen

Die folgenden Hemlock-Typen k√∂nnen an C-Funktionen √ºbergeben/von ihnen empfangen werden:

| Hemlock-Typ | C-Typ | Gr√∂√üe | Hinweise |
|-------------|-------|-------|----------|
| `i8` | `int8_t` | 1 Byte | Vorzeichenbehafteter 8-Bit-Integer |
| `i16` | `int16_t` | 2 Bytes | Vorzeichenbehafteter 16-Bit-Integer |
| `i32` | `int32_t` | 4 Bytes | Vorzeichenbehafteter 32-Bit-Integer |
| `i64` | `int64_t` | 8 Bytes | Vorzeichenbehafteter 64-Bit-Integer |
| `u8` | `uint8_t` | 1 Byte | Vorzeichenloser 8-Bit-Integer |
| `u16` | `uint16_t` | 2 Bytes | Vorzeichenloser 16-Bit-Integer |
| `u32` | `uint32_t` | 4 Bytes | Vorzeichenloser 32-Bit-Integer |
| `u64` | `uint64_t` | 8 Bytes | Vorzeichenloser 64-Bit-Integer |
| `f32` | `float` | 4 Bytes | 32-Bit-Flie√ükommazahl |
| `f64` | `double` | 8 Bytes | 64-Bit-Flie√ükommazahl |
| `ptr` | `void*` | 8 Bytes | Rohpointer |

### Typkonvertierung

**Automatische Konvertierungen:**
- Hemlock-Integer ‚Üí C-Integer (mit Bereichspr√ºfung)
- Hemlock-Floats ‚Üí C-Floats
- Hemlock-Pointer ‚Üí C-Pointer
- C-R√ºckgabewerte ‚Üí Hemlock-Werte

**Beispiel-Typzuordnungen:**
```hemlock
// Hemlock ‚Üí C
let i: i32 = 42;         // ‚Üí int32_t (4 Bytes)
let f: f64 = 3.14;       // ‚Üí double (8 Bytes)
let p: ptr = alloc(64);  // ‚Üí void* (8 Bytes)

// C ‚Üí Hemlock (R√ºckgabewerte)
// int32_t foo() ‚Üí i32
// double bar() ‚Üí f64
// void* baz() ‚Üí ptr
```

## Grundkonzepte

### Shared Libraries

FFI arbeitet mit kompilierten Shared Libraries:

**Linux:** `.so`-Dateien
```
libexample.so
/usr/lib/libm.so
```

**macOS:** `.dylib`-Dateien
```
libexample.dylib
/usr/lib/libSystem.dylib
```

**Windows:** `.dll`-Dateien
```
example.dll
kernel32.dll
```

### Funktionssignaturen

C-Funktionen m√ºssen bekannte Signaturen haben, damit FFI korrekt funktioniert:

```c
// Beispiel-C-Funktionssignaturen
int add(int a, int b);
double sqrt(double x);
void* malloc(size_t size);
void free(void* ptr);
```

Diese k√∂nnen von Hemlock aufgerufen werden, sobald die Bibliothek geladen und Funktionen gebunden sind.

### Plattformkompatibilit√§t

FFI verwendet **libffi** f√ºr Portabilit√§t:
- Funktioniert auf x86, x86-64, ARM, ARM64
- Behandelt Aufrufkonventionen automatisch
- Abstrahiert plattformspezifische ABI-Details
- Unterst√ºtzt Linux, macOS, Windows (mit entsprechendem libffi)

## FFI-Funktionen exportieren

FFI-Funktionen, die mit `extern fn` deklariert sind, k√∂nnen aus Modulen exportiert werden, sodass Sie wiederverwendbare Bibliotheks-Wrapper erstellen k√∂nnen, die √ºber mehrere Dateien geteilt werden.

### Grundlegende Export-Syntax

```hemlock
// string_utils.hml - Ein Bibliotheksmodul, das C-String-Funktionen umh√ºllt
import "libc.so.6";

// Die extern-Funktion direkt exportieren
export extern fn strlen(s: string): i32;
export extern fn strcmp(s1: string, s2: string): i32;

// Sie k√∂nnen auch Wrapper-Funktionen neben extern-Funktionen exportieren
export fn string_length(s: string): i32 {
    return strlen(s);
}

export fn strings_equal(a: string, b: string): bool {
    return strcmp(a, b) == 0;
}
```

### Exportierte FFI-Funktionen importieren

```hemlock
// main.hml - Die exportierten FFI-Funktionen verwenden
import { strlen, string_length, strings_equal } from "./string_utils.hml";

let msg = "Hallo, Welt!";
print(strlen(msg));           // 12 - direkter extern-Aufruf
print(string_length(msg));    // 12 - Wrapper-Funktion

print(strings_equal("foo", "foo"));  // true
print(strings_equal("foo", "bar"));  // false
```

### Anwendungsf√§lle f√ºr Export Extern

**1. Plattformabstraktion**
```hemlock
// platform.hml - Plattformunterschiede abstrahieren
import "libc.so.6";  // Linux

export extern fn getpid(): i32;
export extern fn getuid(): i32;
export extern fn geteuid(): i32;
```

**2. Bibliotheks-Wrapper**
```hemlock
// crypto_lib.hml - Kryptobibliotheks-Funktionen umh√ºllen
import "libcrypto.so";

export extern fn SHA256(data: ptr, len: u64, out: ptr): ptr;
export extern fn MD5(data: ptr, len: u64, out: ptr): ptr;

// Hemlock-freundliche Wrapper hinzuf√ºgen
export fn sha256_string(s: string): string {
    // Implementierung mit der extern-Funktion
}
```

**3. Zentrale FFI-Deklarationen**
```hemlock
// libc.hml - Zentrales Modul f√ºr libc-Bindungen
import "libc.so.6";

// String-Funktionen
export extern fn strlen(s: string): i32;
export extern fn strcpy(dest: ptr, src: string): ptr;
export extern fn strcat(dest: ptr, src: string): ptr;

// Speicherfunktionen
export extern fn malloc(size: u64): ptr;
export extern fn realloc(p: ptr, size: u64): ptr;
export extern fn calloc(nmemb: u64, size: u64): ptr;

// Prozessfunktionen
export extern fn getpid(): i32;
export extern fn getppid(): i32;
export extern fn getenv(name: string): ptr;
```

Dann im gesamten Projekt verwenden:
```hemlock
import { strlen, malloc, getpid } from "./libc.hml";
```

### Mit regul√§ren Exports kombinieren

Sie k√∂nnen exportierte extern-Funktionen mit regul√§ren Funktionsexporten mischen:

```hemlock
// math_extended.hml
import "libm.so.6";

// Rohe C-Funktionen exportieren
export extern fn sin(x: f64): f64;
export extern fn cos(x: f64): f64;
export extern fn tan(x: f64): f64;

// Hemlock-Funktionen exportieren, die sie verwenden
export fn deg_to_rad(degrees: f64): f64 {
    return degrees * 3.14159265359 / 180.0;
}

export fn sin_degrees(degrees: f64): f64 {
    return sin(deg_to_rad(degrees));
}
```

### Plattformspezifische Bibliotheken

Beim Exportieren von extern-Funktionen beachten, dass Bibliotheksnamen je nach Plattform unterschiedlich sind:

```hemlock
// F√ºr Linux
import "libc.so.6";

// F√ºr macOS (anderer Ansatz erforderlich)
import "libSystem.B.dylib";
```

Derzeit verwendet Hemlocks `import "library"`-Syntax statische Bibliothekspfade, daher k√∂nnen plattformspezifische Module f√ºr plattform√ºbergreifenden FFI-Code erforderlich sein.

## Anwendungsf√§lle

### 1. Systembibliotheken

Zugriff auf Standard-C-Bibliotheksfunktionen:

**Mathematikfunktionen:**
```hemlock
// sqrt aus libm aufrufen
let result = sqrt(16.0);  // 4.0
```

**Speicherallokation:**
```hemlock
// malloc/free aus libc aufrufen
let ptr = malloc(1024);
free(ptr);
```

### 2. Drittanbieter-Bibliotheken

Bestehende C-Bibliotheken verwenden:

**Beispiel: Bildverarbeitung**
```hemlock
// libpng oder libjpeg laden
// Bilder mit C-Bibliotheksfunktionen verarbeiten
```

**Beispiel: Kryptografie**
```hemlock
// OpenSSL oder libsodium verwenden
// Verschl√ºsselung/Entschl√ºsselung √ºber FFI
```

### 3. System-APIs

Direkte Systemaufrufe:

**Beispiel: POSIX-APIs**
```hemlock
// getpid, getuid, etc. aufrufen
// Auf Low-Level-Systemfunktionalit√§t zugreifen
```

### 4. Leistungskritischer Code

Optimierte C-Implementierungen aufrufen:

```hemlock
// Hochoptimierte C-Bibliotheken verwenden
// SIMD-Operationen, vektorisierter Code
// Hardware-beschleunigte Funktionen
```

### 5. Hardware-Zugriff

Schnittstelle zu Hardware-Bibliotheken:

```hemlock
// GPIO-Steuerung auf eingebetteten Systemen
// USB-Ger√§tekommunikation
// Serieller Port-Zugriff
```

### 6. Integration von Legacy-Code

Bestehende C-Codebasen wiederverwenden:

```hemlock
// Funktionen aus Legacy-C-Anwendungen aufrufen
// Schrittweise zu Hemlock migrieren
// Funktionierenden C-Code bewahren
```

## Zuk√ºnftige Entwicklung

### Geplante Funktionen

**1. Struct-Unterst√ºtzung**
```hemlock
// Zukunft: C-Structs √ºbergeben/zur√ºckgeben
define Point {
    x: f64,
    y: f64,
}

let p = Point { x: 1.0, y: 2.0 };
c_function_with_struct(p);
```

**2. Array/Buffer-Behandlung**
```hemlock
// Zukunft: Bessere Array-√úbergabe
let arr = [1, 2, 3, 4, 5];
process_array(arr);  // An C-Funktion √ºbergeben
```

**3. Funktionspointer-Callbacks** ‚úÖ (Implementiert!)
```hemlock
// Hemlock-Funktionen als Callbacks an C √ºbergeben
fn my_compare(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    return va - vb;
}

// C-aufrufbaren Funktionspointer erstellen
let cmp = callback(my_compare, ["ptr", "ptr"], "i32");

// Mit qsort oder jeder C-Funktion verwenden, die einen Callback erwartet
qsort(arr, count, elem_size, cmp);

// Aufr√§umen wenn fertig
callback_free(cmp);
```

**4. String-Marshaling**
```hemlock
// Zukunft: Automatische String-Konvertierung
let s = "hello";
c_string_function(s);  // Automatisch zu C-String konvertieren
```

**5. Fehlerbehandlung**
```hemlock
// Zukunft: Bessere Fehlerberichterstattung
try {
    let result = risky_c_function();
} catch (e) {
    print("FFI-Fehler: " + e);
}
```

**6. Typsicherheit**
```hemlock
// Zukunft: Typannotationen f√ºr FFI
@ffi("libm.so")
fn sqrt(x: f64): f64;

let result = sqrt(16.0);  // Typgepr√ºft
```

### Funktionen

**v1.0:**
- ‚úÖ Grundlegendes FFI mit primitiven Typen
- ‚úÖ Dynamisches Laden von Bibliotheken
- ‚úÖ Funktionsaufrufe
- ‚úÖ Callback-Unterst√ºtzung √ºber libffi-Closures

**Zukunft:**
- Struct-Unterst√ºtzung
- Array-Behandlungsverbesserungen
- Automatische Bindungsgenerierung

## FFI-Callbacks

Hemlock unterst√ºtzt das √úbergeben von Funktionen an C-Code als Callbacks unter Verwendung von libffi-Closures. Dies erm√∂glicht die Integration mit C-APIs, die Funktionspointer erwarten, wie `qsort`, Event-Loops und callback-basierte Bibliotheken.

### Callbacks erstellen

Verwenden Sie `callback()`, um einen C-aufrufbaren Funktionspointer aus einer Hemlock-Funktion zu erstellen:

```hemlock
// callback(function, param_types, return_type) -> ptr
let cb = callback(my_function, ["ptr", "ptr"], "i32");
```

**Parameter:**
- `function`: Eine Hemlock-Funktion zum Umh√ºllen
- `param_types`: Array von Typnamen-Strings (z.B. `["ptr", "i32"]`)
- `return_type`: R√ºckgabetyp-String (z.B. `"i32"`, `"void"`)

**Unterst√ºtzte Callback-Typen:**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - Vorzeichenbehaftete Integer
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - Vorzeichenlose Integer
- `"f32"`, `"f64"` - Flie√ükommazahlen
- `"ptr"` - Pointer
- `"void"` - Kein R√ºckgabewert
- `"bool"` - Boolean

### Beispiel: qsort

```hemlock
import "libc.so.6";
extern fn qsort(base: ptr, nmemb: u64, size: u64, compar: ptr): void;

// Vergleichsfunktion f√ºr Integer (aufsteigend)
fn compare_ints(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    if (va < vb) { return -1; }
    if (va > vb) { return 1; }
    return 0;
}

// Array von 5 Integern allozieren
let arr = alloc(20);  // 5 * 4 Bytes
ptr_write_i32(arr, 5);
ptr_write_i32(ptr_offset(arr, 1, 4), 2);
ptr_write_i32(ptr_offset(arr, 2, 4), 8);
ptr_write_i32(ptr_offset(arr, 3, 4), 1);
ptr_write_i32(ptr_offset(arr, 4, 4), 9);

// Callback erstellen und sortieren
let cmp = callback(compare_ints, ["ptr", "ptr"], "i32");
qsort(arr, 5, 4, cmp);

// Array ist jetzt sortiert: [1, 2, 5, 8, 9]

// Aufr√§umen
callback_free(cmp);
free(arr);
```

### Pointer-Hilfsfunktionen

Hemlock bietet umfassende Hilfsfunktionen f√ºr die Arbeit mit Rohpointern. Diese sind essentiell f√ºr FFI-Callbacks und direkte Speichermanipulation.

#### Integer-Typ-Helfer

| Funktion | Beschreibung |
|----------|--------------|
| `ptr_deref_i8(ptr)` | Pointer dereferenzieren, i8 lesen |
| `ptr_deref_i16(ptr)` | Pointer dereferenzieren, i16 lesen |
| `ptr_deref_i32(ptr)` | Pointer dereferenzieren, i32 lesen |
| `ptr_deref_i64(ptr)` | Pointer dereferenzieren, i64 lesen |
| `ptr_deref_u8(ptr)` | Pointer dereferenzieren, u8 lesen |
| `ptr_deref_u16(ptr)` | Pointer dereferenzieren, u16 lesen |
| `ptr_deref_u32(ptr)` | Pointer dereferenzieren, u32 lesen |
| `ptr_deref_u64(ptr)` | Pointer dereferenzieren, u64 lesen |
| `ptr_write_i8(ptr, value)` | i8 an Pointer-Position schreiben |
| `ptr_write_i16(ptr, value)` | i16 an Pointer-Position schreiben |
| `ptr_write_i32(ptr, value)` | i32 an Pointer-Position schreiben |
| `ptr_write_i64(ptr, value)` | i64 an Pointer-Position schreiben |
| `ptr_write_u8(ptr, value)` | u8 an Pointer-Position schreiben |
| `ptr_write_u16(ptr, value)` | u16 an Pointer-Position schreiben |
| `ptr_write_u32(ptr, value)` | u32 an Pointer-Position schreiben |
| `ptr_write_u64(ptr, value)` | u64 an Pointer-Position schreiben |

#### Float-Typ-Helfer

| Funktion | Beschreibung |
|----------|--------------|
| `ptr_deref_f32(ptr)` | Pointer dereferenzieren, f32 (float) lesen |
| `ptr_deref_f64(ptr)` | Pointer dereferenzieren, f64 (double) lesen |
| `ptr_write_f32(ptr, value)` | f32 an Pointer-Position schreiben |
| `ptr_write_f64(ptr, value)` | f64 an Pointer-Position schreiben |

#### Pointer-Typ-Helfer

| Funktion | Beschreibung |
|----------|--------------|
| `ptr_deref_ptr(ptr)` | Pointer-zu-Pointer dereferenzieren |
| `ptr_write_ptr(ptr, value)` | Pointer an Pointer-Position schreiben |
| `ptr_offset(ptr, index, size)` | Offset berechnen: `ptr + index * size` |
| `ptr_read_i32(ptr)` | i32 durch Pointer-zu-Pointer lesen (f√ºr qsort-Callbacks) |
| `ptr_null()` | Null-Pointer-Konstante erhalten |

#### Buffer-Konvertierungs-Helfer

| Funktion | Beschreibung |
|----------|--------------|
| `buffer_ptr(buffer)` | Rohpointer aus Buffer erhalten |
| `ptr_to_buffer(ptr, size)` | Daten von Pointer in neuen Buffer kopieren |

#### FFI-Hilfsfunktionen

| Funktion | Beschreibung |
|----------|--------------|
| `ffi_sizeof(type_name)` | Gr√∂√üe in Bytes eines FFI-Typs erhalten |

**Unterst√ºtzte Typnamen f√ºr `ffi_sizeof`:**
- `"i8"`, `"i16"`, `"i32"`, `"i64"` - Vorzeichenbehaftete Integer (1, 2, 4, 8 Bytes)
- `"u8"`, `"u16"`, `"u32"`, `"u64"` - Vorzeichenlose Integer (1, 2, 4, 8 Bytes)
- `"f32"`, `"f64"` - Floats (4, 8 Bytes)
- `"ptr"` - Pointer (8 Bytes auf 64-Bit)
- `"size_t"`, `"usize"` - Plattformabh√§ngiger Gr√∂√üentyp
- `"intptr_t"`, `"isize"` - Plattformabh√§ngiger vorzeichenbehafteter Pointer-Typ

#### Beispiel: Mit verschiedenen Typen arbeiten

```hemlock
let p = alloc(64);

// Integer schreiben und lesen
ptr_write_i8(p, 42);
print(ptr_deref_i8(p));  // 42

ptr_write_i64(ptr_offset(p, 1, 8), 9000000000);
print(ptr_deref_i64(ptr_offset(p, 1, 8)));  // 9000000000

// Floats schreiben und lesen
ptr_write_f64(p, 3.14159);
print(ptr_deref_f64(p));  // 3.14159

// Pointer-zu-Pointer
let inner = alloc(4);
ptr_write_i32(inner, 999);
ptr_write_ptr(p, inner);
let retrieved = ptr_deref_ptr(p);
print(ptr_deref_i32(retrieved));  // 999

// Typgr√∂√üen erhalten
print(ffi_sizeof("i64"));  // 8
print(ffi_sizeof("ptr"));  // 8 (auf 64-Bit)

// Buffer-Konvertierung
let buf = buffer(64);
ptr_write_i32(buffer_ptr(buf), 12345);
print(ptr_deref_i32(buffer_ptr(buf)));  // 12345

free(inner);
free(p);
```

### Callbacks freigeben

**Wichtig:** Callbacks immer freigeben wenn fertig, um Speicherlecks zu vermeiden:

```hemlock
let cb = callback(my_fn, ["ptr"], "void");
// ... Callback verwenden ...
callback_free(cb);  // Freigeben wenn fertig
```

Callbacks werden auch automatisch freigegeben wenn das Programm beendet wird.

### Closures in Callbacks

Callbacks erfassen ihre Closure-Umgebung, sodass sie auf √§u√üere Scope-Variablen zugreifen k√∂nnen:

```hemlock
let multiplier = 10;

fn scale(a: ptr, b: ptr): i32 {
    let va = ptr_deref_i32(a);
    let vb = ptr_deref_i32(b);
    // Kann auf 'multiplier' aus √§u√üerem Scope zugreifen
    return (va * multiplier) - (vb * multiplier);
}

let cmp = callback(scale, ["ptr", "ptr"], "i32");
```

### Thread-Sicherheit

Callback-Aufrufe werden mit einem Mutex serialisiert, um Thread-Sicherheit zu gew√§hrleisten, da der Hemlock-Interpreter nicht vollst√§ndig thread-sicher ist. Das bedeutet:
- Nur ein Callback kann gleichzeitig ausgef√ºhrt werden
- Sicher mit Multi-Thread-C-Bibliotheken verwendbar
- Kann die Leistung beeinflussen, wenn Callbacks sehr h√§ufig von mehreren Threads aufgerufen werden

### Fehlerbehandlung in Callbacks

Ausnahmen, die in Callbacks geworfen werden, k√∂nnen nicht an C-Code weitergeleitet werden. Stattdessen:
- Eine Warnung wird auf stderr ausgegeben
- Der Callback gibt einen Standardwert zur√ºck (0 oder NULL)
- Die Ausnahme wird protokolliert, aber nicht weitergeleitet

```hemlock
fn risky_callback(a: ptr): i32 {
    throw "Etwas ist schiefgelaufen";  // Warnung wird ausgegeben, gibt 0 zur√ºck
}
```

F√ºr robuste Fehlerbehandlung validieren Sie Eingaben und vermeiden Sie das Werfen in Callbacks.

## FFI-Structs

Hemlock unterst√ºtzt das √úbergeben von Structs by Value an C-Funktionen. Struct-Typen werden automatisch f√ºr FFI registriert, wenn Sie sie mit Typannotationen definieren.

### FFI-kompatible Structs definieren

Ein Struct ist FFI-kompatibel, wenn alle Felder explizite Typannotationen mit FFI-kompatiblen Typen haben:

```hemlock
// FFI-kompatibles Struct
define Point {
    x: f64,
    y: f64,
}

// FFI-kompatibles Struct mit mehreren Feldtypen
define Rectangle {
    top_left: Point,      // Verschachteltes Struct
    width: f64,
    height: f64,
}

// NICHT FFI-kompatibel (Feld ohne Typannotation)
define DynamicObject {
    name,                 // Kein Typ - nicht in FFI verwendbar
    value,
}
```

### Structs in FFI verwenden

Extern-Funktionen deklarieren, die Struct-Typen verwenden:

```hemlock
// Den Struct-Typ definieren
define Vector2D {
    x: f64,
    y: f64,
}

// Die C-Bibliothek importieren
import "libmath.so";

// Extern-Funktion deklarieren, die Structs nimmt/zur√ºckgibt
extern fn vector_add(a: Vector2D, b: Vector2D): Vector2D;
extern fn vector_length(v: Vector2D): f64;

// Nat√ºrlich verwenden
let a: Vector2D = { x: 3.0, y: 0.0 };
let b: Vector2D = { x: 0.0, y: 4.0 };
let result = vector_add(a, b);
print(result.x);  // 3.0
print(result.y);  // 4.0

let len = vector_length(result);
print(len);       // 5.0
```

### Unterst√ºtzte Feldtypen

Struct-Felder m√ºssen diese FFI-kompatiblen Typen verwenden:

| Hemlock-Typ | C-Typ | Gr√∂√üe |
|-------------|-------|-------|
| `i8` | `int8_t` | 1 Byte |
| `i16` | `int16_t` | 2 Bytes |
| `i32` | `int32_t` | 4 Bytes |
| `i64` | `int64_t` | 8 Bytes |
| `u8` | `uint8_t` | 1 Byte |
| `u16` | `uint16_t` | 2 Bytes |
| `u32` | `uint32_t` | 4 Bytes |
| `u64` | `uint64_t` | 8 Bytes |
| `f32` | `float` | 4 Bytes |
| `f64` | `double` | 8 Bytes |
| `ptr` | `void*` | 8 Bytes |
| `string` | `char*` | 8 Bytes |
| `bool` | `int` | variiert |
| Verschachteltes Struct | struct | variiert |

### Struct-Layout

Hemlock verwendet die nativen Struct-Layout-Regeln der Plattform (passend zum C-ABI):
- Felder werden entsprechend ihrem Typ ausgerichtet
- Padding wird nach Bedarf eingef√ºgt
- Gesamtgr√∂√üe wird auf das gr√∂√üte Element aufgef√ºllt

```hemlock
// Beispiel: C-kompatibles Layout
define Mixed {
    a: i8,    // Offset 0, Gr√∂√üe 1
              // 3 Bytes Padding
    b: i32,   // Offset 4, Gr√∂√üe 4
}
// Gesamtgr√∂√üe: 8 Bytes (mit Padding)

define Point3D {
    x: f64,   // Offset 0, Gr√∂√üe 8
    y: f64,   // Offset 8, Gr√∂√üe 8
    z: f64,   // Offset 16, Gr√∂√üe 8
}
// Gesamtgr√∂√üe: 24 Bytes (kein Padding erforderlich)
```

### Verschachtelte Structs

Structs k√∂nnen andere Structs enthalten:

```hemlock
define Inner {
    x: i32,
    y: i32,
}

define Outer {
    inner: Inner,
    z: i32,
}

import "mylib.so";
extern fn process_nested(data: Outer): i32;

let obj: Outer = {
    inner: { x: 1, y: 2 },
    z: 3,
};
let result = process_nested(obj);
```

### Struct-R√ºckgabewerte

C-Funktionen k√∂nnen Structs zur√ºckgeben:

```hemlock
define Point {
    x: f64,
    y: f64,
}

import "libmath.so";
extern fn get_origin(): Point;

let p = get_origin();
print(p.x);  // 0.0
print(p.y);  // 0.0
```

### Einschr√§nkungen

- **Struct-Felder m√ºssen Typannotationen haben** - Felder ohne Typen sind nicht FFI-kompatibel
- **Keine Arrays in Structs** - stattdessen Pointer verwenden
- **Keine Unions** - nur Struct-Typen werden unterst√ºtzt
- **Callbacks k√∂nnen keine Structs zur√ºckgeben** - Pointer f√ºr Callback-R√ºckgabewerte verwenden

### Struct-Typen exportieren

Sie k√∂nnen Struct-Typdefinitionen aus einem Modul mit `export define` exportieren:

```hemlock
// geometry.hml
export define Vector2 {
    x: f32,
    y: f32,
}

export define Rectangle {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
}

export fn create_rect(x: f32, y: f32, w: f32, h: f32): Rectangle {
    return { x: x, y: y, width: w, height: h };
}
```

**Wichtig:** Exportierte Struct-Typen werden **global** registriert, wenn das Modul geladen wird. Sie werden automatisch verf√ºgbar, wenn Sie irgendetwas aus dem Modul importieren. Sie m√ºssen (und k√∂nnen) sie NICHT explizit nach Namen importieren:

```hemlock
// main.hml

// GUT - Struct-Typen sind nach jedem Import aus dem Modul automatisch verf√ºgbar
import { create_rect } from "./geometry.hml";
let v: Vector2 = { x: 1.0, y: 2.0 };      // Funktioniert - Vector2 ist global verf√ºgbar
let r: Rectangle = create_rect(0.0, 0.0, 100.0, 50.0);  // Funktioniert

// SCHLECHT - kann Struct-Typen nicht explizit nach Namen importieren
import { Vector2 } from "./geometry.hml";  // Fehler: Undefinierte Variable 'Vector2'
```

Dieses Verhalten existiert, weil Struct-Typen in der globalen Typ-Registry registriert werden, wenn das Modul l√§dt, anstatt als Werte in der Export-Umgebung des Moduls gespeichert zu werden. Der Typ wird f√ºr allen Code verf√ºgbar, der aus dem Modul importiert.

## Aktuelle Einschr√§nkungen

FFI hat die folgenden Einschr√§nkungen:

**1. Manuelle Typkonvertierung**
- Muss String-Konvertierungen manuell verwalten
- Keine automatische Hemlock-String ‚Üî C-String-Konvertierung

**2. Begrenzte Fehlerbehandlung**
- Grundlegende Fehlerberichterstattung
- Ausnahmen in Callbacks k√∂nnen nicht an C weitergeleitet werden

**3. Manuelles Laden von Bibliotheken**
- Muss Bibliotheken manuell laden
- Keine automatische Bindungsgenerierung

**4. Plattformspezifischer Code**
- Bibliothekspfade unterscheiden sich nach Plattform
- Muss .so vs .dylib vs .dll behandeln

## Best Practices

W√§hrend umfassende FFI-Dokumentation noch entwickelt wird, hier allgemeine Best Practices:

### 1. Typsicherheit

```hemlock
// Explizit bei Typen sein
let x: i32 = 42;
let result: f64 = c_function(x);
```

### 2. Speicherverwaltung

```hemlock
// Daran denken, allozierten Speicher freizugeben
let ptr = c_malloc(1024);
// ... ptr verwenden
c_free(ptr);
```

### 3. Fehlerpr√ºfung

```hemlock
// R√ºckgabewerte pr√ºfen
let result = c_function();
if (result == null) {
    print("C-Funktion fehlgeschlagen");
}
```

### 4. Plattformkompatibilit√§t

```hemlock
// Plattformunterschiede behandeln
// Entsprechende Bibliothekserweiterungen verwenden (.so, .dylib, .dll)
```

## Beispiele

F√ºr funktionierende Beispiele siehe:
- Callback-Tests: `/tests/ffi_callbacks/` - qsort-Callback-Beispiele
- Stdlib FFI-Verwendung: `/stdlib/hash.hml`, `/stdlib/regex.hml`, `/stdlib/crypto.hml`
- Beispielprogramme: `/examples/` (falls verf√ºgbar)

## Hilfe erhalten

FFI ist ein neueres Feature in Hemlock. Bei Fragen oder Problemen:

1. Test-Suite auf funktionierende Beispiele pr√ºfen
2. libffi-Dokumentation f√ºr Low-Level-Details heranziehen
3. Bugs melden oder Features √ºber Projekt-Issues anfragen

## Zusammenfassung

Hemlocks FFI bietet:

- ‚úÖ C-Funktionsaufruf aus Shared Libraries
- ‚úÖ Primitive Typunterst√ºtzung (i8-i64, u8-u64, f32, f64, ptr)
- ‚úÖ Automatische Typkonvertierung
- ‚úÖ libffi-basierte Portabilit√§t
- ‚úÖ Grundlage f√ºr native Bibliotheksintegration
- ‚úÖ **Funktionspointer-Callbacks** - Hemlock-Funktionen an C √ºbergeben
- ‚úÖ **Extern-Funktionen exportieren** - FFI-Bindungen √ºber Module teilen
- ‚úÖ **Struct-√úbergabe und -R√ºckgabe** - C-kompatible Structs by Value √ºbergeben
- ‚úÖ **Export define** - Struct-Typdefinitionen √ºber Module teilen (automatisch global importiert)
- ‚úÖ **Vollst√§ndige Pointer-Helfer** - Alle Typen lesen/schreiben (i8-i64, u8-u64, f32, f64, ptr)
- ‚úÖ **Buffer/Pointer-Konvertierung** - `buffer_ptr()`, `ptr_to_buffer()` f√ºr Daten-Marshaling
- ‚úÖ **FFI-Typgr√∂√üen** - `ffi_sizeof()` f√ºr plattformbewusste Typgr√∂√üen
- ‚úÖ **Plattformtypen** - `size_t`, `usize`, `isize`, `intptr_t`, `uintptr_t`-Unterst√ºtzung

**Aktueller Status:** FFI voll ausgestattet mit primitiven Typen, Structs, Callbacks, Modul-Exports und vollst√§ndigen Pointer-Hilfsfunktionen

**Zukunft:** String-Marshaling-Hilfsfunktionen

**Anwendungsf√§lle:** Systembibliotheken, Drittanbieter-Bibliotheken, qsort, Event-Loops, callback-basierte APIs, wiederverwendbare Bibliotheks-Wrapper

## Beitragen

FFI-Dokumentation wird erweitert. Wenn Sie mit FFI arbeiten:
- Dokumentieren Sie Ihre Anwendungsf√§lle
- Teilen Sie Beispielcode
- Melden Sie Probleme oder Einschr√§nkungen
- Schlagen Sie Verbesserungen vor

Das FFI-System ist darauf ausgelegt, praktisch und sicher zu sein, w√§hrend es bei Bedarf Low-Level-Zugriff bietet, gem√§√ü Hemlocks Philosophie von "explizit statt implizit" und "unsafe ist ein Feature, kein Bug".


--------------------------------------------------------------------------------
## File IO
--------------------------------------------------------------------------------

# Datei-I/O in Hemlock

Hemlock bietet eine **Dateiobjekt-API** f√ºr Dateioperationen mit ordnungsgem√§√üer Fehlerbehandlung und Ressourcenverwaltung.

## Inhaltsverzeichnis

- [√úberblick](#√ºberblick)
- [Dateien √∂ffnen](#dateien-√∂ffnen)
- [Dateimethoden](#dateimethoden)
- [Dateieigenschaften](#dateieigenschaften)
- [Fehlerbehandlung](#fehlerbehandlung)
- [Ressourcenverwaltung](#ressourcenverwaltung)
- [Vollst√§ndige API-Referenz](#vollst√§ndige-api-referenz)
- [H√§ufige Muster](#h√§ufige-muster)
- [Best Practices](#best-practices)

## √úberblick

Die Dateiobjekt-API bietet:

- **Explizite Ressourcenverwaltung** - Dateien m√ºssen manuell geschlossen werden
- **Mehrere √ñffnungsmodi** - Lesen, Schreiben, Anh√§ngen, Lesen/Schreiben
- **Text- und Bin√§roperationen** - Sowohl Text- als auch Bin√§rdaten lesen/schreiben
- **Seek-Unterst√ºtzung** - Wahlfreier Zugriff innerhalb von Dateien
- **Umfassende Fehlermeldungen** - Kontextbewusste Fehlerberichterstattung

**Wichtig:** Dateien werden nicht automatisch geschlossen. Sie m√ºssen `f.close()` aufrufen, um Dateideskriptor-Lecks zu vermeiden.

## Dateien √∂ffnen

Verwenden Sie `open(path, mode?)`, um eine Datei zu √∂ffnen:

```hemlock
let f = open("data.txt", "r");     // Lesemodus (Standard)
let f2 = open("output.txt", "w");  // Schreibmodus (abschneiden)
let f3 = open("log.txt", "a");     // Anh√§ngemodus
let f4 = open("data.bin", "r+");   // Lese-/Schreibmodus
```

### √ñffnungsmodi

| Modus | Beschreibung | Datei muss existieren | Schneidet ab | Position |
|-------|--------------|----------------------|--------------|----------|
| `"r"` | Lesen (Standard) | Ja | Nein | Anfang |
| `"w"` | Schreiben | Nein (erstellt) | Ja | Anfang |
| `"a"` | Anh√§ngen | Nein (erstellt) | Nein | Ende |
| `"r+"` | Lesen und Schreiben | Ja | Nein | Anfang |
| `"w+"` | Lesen und Schreiben | Nein (erstellt) | Ja | Anfang |
| `"a+"` | Lesen und Anh√§ngen | Nein (erstellt) | Nein | Ende |

### Beispiele

**Bestehende Datei lesen:**
```hemlock
let f = open("config.json", "r");
// oder einfach:
let f = open("config.json");  // "r" ist Standard
```

**Neue Datei zum Schreiben erstellen:**
```hemlock
let f = open("output.txt", "w");  // Erstellt oder schneidet ab
```

**An Datei anh√§ngen:**
```hemlock
let f = open("log.txt", "a");  // Erstellt wenn nicht existiert
```

**Lese- und Schreibmodus:**
```hemlock
let f = open("data.bin", "r+");  // Bestehende Datei, kann lesen/schreiben
```

## Dateimethoden

### Lesen

#### read(size?: i32): string

Text aus Datei lesen (optionaler size-Parameter).

**Ohne size (alles lesen):**
```hemlock
let f = open("data.txt", "r");
let all = f.read();  // Von aktueller Position bis EOF lesen
f.close();
```

**Mit size (bestimmte Bytes lesen):**
```hemlock
let f = open("data.txt", "r");
let chunk = f.read(1024);  // Bis zu 1024 Bytes lesen
let next = f.read(1024);   // N√§chste 1024 Bytes lesen
f.close();
```

**R√ºckgabe:** String mit den gelesenen Daten, oder leerer String bei EOF

**Beispiel - Gesamte Datei lesen:**
```hemlock
let f = open("poem.txt", "r");
let content = f.read();
print(content);
f.close();
```

**Beispiel - In Chunks lesen:**
```hemlock
let f = open("large.txt", "r");
while (true) {
    let chunk = f.read(4096);  // 4KB Chunks
    if (chunk == "") { break; }  // EOF erreicht
    process(chunk);
}
f.close();
```

#### read_bytes(size: i32): buffer

Bin√§rdaten lesen (gibt Buffer zur√ºck).

**Parameter:**
- `size` (i32) - Anzahl der zu lesenden Bytes

**R√ºckgabe:** Buffer mit den gelesenen Bytes

```hemlock
let f = open("image.png", "r");
let binary = f.read_bytes(256);  // 256 Bytes lesen
print(binary.length);  // 256 (oder weniger bei EOF)

// Auf einzelne Bytes zugreifen
let first_byte = binary[0];
print(first_byte);

f.close();
```

**Beispiel - Gesamte Bin√§rdatei lesen:**
```hemlock
let f = open("data.bin", "r");
let size = 10240;  // Erwartete Gr√∂√üe
let data = f.read_bytes(size);
f.close();

// Bin√§rdaten verarbeiten
let i = 0;
while (i < data.length) {
    let byte = data[i];
    // ... Byte verarbeiten
    i = i + 1;
}
```

### Schreiben

#### write(data: string): i32

Text in Datei schreiben (gibt geschriebene Bytes zur√ºck).

**Parameter:**
- `data` (string) - Zu schreibender Text

**R√ºckgabe:** Anzahl der geschriebenen Bytes (i32)

```hemlock
let f = open("output.txt", "w");
let written = f.write("Hallo, Welt!\n");
print("Schrieb " + typeof(written) + " Bytes");  // "Schrieb 13 Bytes"
f.close();
```

**Beispiel - Mehrere Zeilen schreiben:**
```hemlock
let f = open("output.txt", "w");
f.write("Zeile 1\n");
f.write("Zeile 2\n");
f.write("Zeile 3\n");
f.close();
```

**Beispiel - An Log-Datei anh√§ngen:**
```hemlock
let f = open("app.log", "a");
f.write("[INFO] Anwendung gestartet\n");
f.write("[INFO] Benutzer angemeldet\n");
f.close();
```

#### write_bytes(data: buffer): i32

Bin√§rdaten schreiben (gibt geschriebene Bytes zur√ºck).

**Parameter:**
- `data` (buffer) - Zu schreibende Bin√§rdaten

**R√ºckgabe:** Anzahl der geschriebenen Bytes (i32)

```hemlock
let f = open("output.bin", "w");

// Bin√§rdaten erstellen
let buf = buffer(10);
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

let bytes = f.write_bytes(buf);
print("Schrieb " + typeof(bytes) + " Bytes");

f.close();
```

**Beispiel - Bin√§rdatei kopieren:**
```hemlock
let src = open("input.bin", "r");
let dst = open("output.bin", "w");

let data = src.read_bytes(1024);
while (data.length > 0) {
    dst.write_bytes(data);
    data = src.read_bytes(1024);
}

src.close();
dst.close();
```

### Positionierung

#### seek(position: i32): i32

Zu bestimmter Position bewegen (gibt neue Position zur√ºck).

**Parameter:**
- `position` (i32) - Byte-Offset vom Dateianfang

**R√ºckgabe:** Neue Position (i32)

```hemlock
let f = open("data.txt", "r");

// Zu Byte 100 bewegen
f.seek(100);

// Ab Position 100 lesen
let data = f.read(50);

// Zum Anfang zur√ºcksetzen
f.seek(0);

f.close();
```

**Beispiel - Wahlfreier Zugriff:**
```hemlock
let f = open("records.dat", "r");

// Datensatz an Offset 1000 lesen
f.seek(1000);
let record1 = f.read_bytes(100);

// Datensatz an Offset 2000 lesen
f.seek(2000);
let record2 = f.read_bytes(100);

f.close();
```

#### tell(): i32

Aktuelle Position in Datei erhalten.

**R√ºckgabe:** Aktueller Byte-Offset (i32)

```hemlock
let f = open("data.txt", "r");

let pos1 = f.tell();  // 0 (am Anfang)

f.read(100);
let pos2 = f.tell();  // 100 (nach Lesen von 100 Bytes)

f.seek(500);
let pos3 = f.tell();  // 500 (nach Seek)

f.close();
```

**Beispiel - Gelesene Menge messen:**
```hemlock
let f = open("data.txt", "r");

let start = f.tell();
let content = f.read();
let end = f.tell();

let bytes_read = end - start;
print("Las " + typeof(bytes_read) + " Bytes");

f.close();
```

### Schlie√üen

#### close()

Datei schlie√üen (idempotent, kann mehrfach aufgerufen werden).

```hemlock
let f = open("data.txt", "r");
// ... Datei verwenden
f.close();
f.close();  // Sicher - kein Fehler beim zweiten Schlie√üen
```

**Wichtige Hinweise:**
- Dateien immer schlie√üen wenn fertig, um Dateideskriptor-Lecks zu vermeiden
- Schlie√üen ist idempotent - kann mehrfach sicher aufgerufen werden
- Nach dem Schlie√üen werden alle anderen Operationen einen Fehler verursachen
- `finally`-Bl√∂cke verwenden, um sicherzustellen, dass Dateien auch bei Fehlern geschlossen werden

## Dateieigenschaften

Dateiobjekte haben drei schreibgesch√ºtzte Eigenschaften:

### path: string

Der zum √ñffnen der Datei verwendete Dateipfad.

```hemlock
let f = open("/path/to/file.txt", "r");
print(f.path);  // "/path/to/file.txt"
f.close();
```

### mode: string

Der Modus, mit dem die Datei ge√∂ffnet wurde.

```hemlock
let f = open("data.txt", "r");
print(f.mode);  // "r"
f.close();

let f2 = open("output.txt", "w");
print(f2.mode);  // "w"
f2.close();
```

### closed: bool

Ob die Datei geschlossen ist.

```hemlock
let f = open("data.txt", "r");
print(f.closed);  // false

f.close();
print(f.closed);  // true
```

**Beispiel - Pr√ºfen ob Datei ge√∂ffnet ist:**
```hemlock
let f = open("data.txt", "r");

if (!f.closed) {
    let content = f.read();
    // ... Inhalt verarbeiten
}

f.close();

if (f.closed) {
    print("Datei ist jetzt geschlossen");
}
```

## Fehlerbehandlung

Alle Dateioperationen enthalten ordnungsgem√§√üe Fehlermeldungen mit Kontext.

### H√§ufige Fehler

**Datei nicht gefunden:**
```hemlock
let f = open("missing.txt", "r");
// Fehler: Konnte 'missing.txt' nicht √∂ffnen: Keine solche Datei oder Verzeichnis
```

**Von geschlossener Datei lesen:**
```hemlock
let f = open("data.txt", "r");
f.close();
f.read();
// Fehler: Kann nicht von geschlossener Datei 'data.txt' lesen
```

**In schreibgesch√ºtzte Datei schreiben:**
```hemlock
let f = open("readonly.txt", "r");
f.write("data");
// Fehler: Kann nicht in Datei 'readonly.txt' schreiben, die im Nur-Lese-Modus ge√∂ffnet wurde
```

**Von schreibgesch√ºtzter Datei lesen:**
```hemlock
let f = open("output.txt", "w");
f.read();
// Fehler: Kann nicht von Datei 'output.txt' lesen, die im Nur-Schreib-Modus ge√∂ffnet wurde
```

### try/catch verwenden

```hemlock
try {
    let f = open("data.txt", "r");
    let content = f.read();
    f.close();
    process(content);
} catch (e) {
    print("Fehler beim Lesen der Datei: " + e);
}
```

## Ressourcenverwaltung

### Grundmuster

Dateien immer explizit schlie√üen:

```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();
```

### Mit Fehlerbehandlung (empfohlen)

`finally` verwenden, um sicherzustellen, dass Dateien auch bei Fehlern geschlossen werden:

```hemlock
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();  // Immer schlie√üen, auch bei Fehler
}
```

### Mehrere Dateien

```hemlock
let src = null;
let dst = null;

try {
    src = open("input.txt", "r");
    dst = open("output.txt", "w");

    let content = src.read();
    dst.write(content);
} finally {
    if (src != null) { src.close(); }
    if (dst != null) { dst.close(); }
}
```

### Hilfsfunktions-Muster

```hemlock
fn with_file(path: string, mode: string, callback) {
    let f = open(path, mode);
    try {
        return callback(f);
    } finally {
        f.close();
    }
}

// Verwendung:
with_file("data.txt", "r", fn(f) {
    return f.read();
});
```

## Vollst√§ndige API-Referenz

### Funktionen

| Funktion | Parameter | R√ºckgabe | Beschreibung |
|----------|-----------|----------|--------------|
| `open(path, mode?)` | path: string, mode?: string | File | Datei √∂ffnen (mode Standard ist "r") |

### Methoden

| Methode | Parameter | R√ºckgabe | Beschreibung |
|---------|-----------|----------|--------------|
| `read(size?)` | size?: i32 | string | Text lesen (alles oder bestimmte Bytes) |
| `read_bytes(size)` | size: i32 | buffer | Bin√§rdaten lesen |
| `write(data)` | data: string | i32 | Text schreiben, gibt geschriebene Bytes zur√ºck |
| `write_bytes(data)` | data: buffer | i32 | Bin√§rdaten schreiben, gibt geschriebene Bytes zur√ºck |
| `seek(position)` | position: i32 | i32 | Zu Position springen, gibt neue Position zur√ºck |
| `tell()` | - | i32 | Aktuelle Position erhalten |
| `close()` | - | null | Datei schlie√üen (idempotent) |

### Eigenschaften (schreibgesch√ºtzt)

| Eigenschaft | Typ | Beschreibung |
|-------------|-----|--------------|
| `path` | string | Dateipfad |
| `mode` | string | √ñffnungsmodus |
| `closed` | bool | Ob Datei geschlossen ist |

## H√§ufige Muster

### Gesamte Datei lesen

```hemlock
fn read_file(path: string): string {
    let f = open(path, "r");
    try {
        return f.read();
    } finally {
        f.close();
    }
}

let content = read_file("config.json");
```

### Gesamte Datei schreiben

```hemlock
fn write_file(path: string, content: string) {
    let f = open(path, "w");
    try {
        f.write(content);
    } finally {
        f.close();
    }
}

write_file("output.txt", "Hallo, Welt!");
```

### An Datei anh√§ngen

```hemlock
fn append_file(path: string, content: string) {
    let f = open(path, "a");
    try {
        f.write(content);
    } finally {
        f.close();
    }
}

append_file("log.txt", "[INFO] Ereignis aufgetreten\n");
```

### Zeilen lesen

```hemlock
fn read_lines(path: string) {
    let f = open(path, "r");
    try {
        let content = f.read();
        return content.split("\n");
    } finally {
        f.close();
    }
}

let lines = read_lines("data.txt");
let i = 0;
while (i < lines.length) {
    print("Zeile " + typeof(i) + ": " + lines[i]);
    i = i + 1;
}
```

### Gro√üe Dateien in Chunks verarbeiten

```hemlock
fn process_large_file(path: string) {
    let f = open(path, "r");
    try {
        while (true) {
            let chunk = f.read(4096);  // 4KB Chunks
            if (chunk == "") { break; }

            // Chunk verarbeiten
            process_chunk(chunk);
        }
    } finally {
        f.close();
    }
}
```

### Bin√§rdatei kopieren

```hemlock
fn copy_file(src_path: string, dst_path: string) {
    let src = null;
    let dst = null;

    try {
        src = open(src_path, "r");
        dst = open(dst_path, "w");

        while (true) {
            let chunk = src.read_bytes(4096);
            if (chunk.length == 0) { break; }

            dst.write_bytes(chunk);
        }
    } finally {
        if (src != null) { src.close(); }
        if (dst != null) { dst.close(); }
    }
}

copy_file("input.dat", "output.dat");
```

### Datei abschneiden

```hemlock
fn truncate_file(path: string) {
    let f = open(path, "w");  // "w"-Modus schneidet ab
    f.close();
}

truncate_file("empty_me.txt");
```

### Wahlfreies Lesen

```hemlock
fn read_at_offset(path: string, offset: i32, size: i32): string {
    let f = open(path, "r");
    try {
        f.seek(offset);
        return f.read(size);
    } finally {
        f.close();
    }
}

let data = read_at_offset("records.dat", 1000, 100);
```

### Dateigr√∂√üe

```hemlock
fn file_size(path: string): i32 {
    let f = open(path, "r");
    try {
        // Zum Ende springen
        let end = f.seek(999999999);  // Gro√üe Zahl
        f.seek(0);  // Zur√ºcksetzen
        return end;
    } finally {
        f.close();
    }
}

let size = file_size("data.txt");
print("Dateigr√∂√üe: " + typeof(size) + " Bytes");
```

### Bedingtes Lesen/Schreiben

```hemlock
fn update_file(path: string, condition, new_content: string) {
    let f = open(path, "r+");
    try {
        let content = f.read();

        if (condition(content)) {
            f.seek(0);  // Zum Anfang zur√ºcksetzen
            f.write(new_content);
        }
    } finally {
        f.close();
    }
}
```

## Best Practices

### 1. Immer try/finally verwenden

```hemlock
// Gut
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();
}

// Schlecht - Datei wird bei Fehler m√∂glicherweise nicht geschlossen
let f = open("data.txt", "r");
let content = f.read();
process(content);  // Wenn das wirft, Datei-Leck
f.close();
```

### 2. Dateizustand vor Operationen pr√ºfen

```hemlock
let f = open("data.txt", "r");

if (!f.closed) {
    let content = f.read();
    // ... Inhalt verwenden
}

f.close();
```

### 3. Geeignete Modi verwenden

```hemlock
// Nur Lesen? "r" verwenden
let f = open("config.json", "r");

// Komplett ersetzen? "w" verwenden
let f = open("output.txt", "w");

// Am Ende hinzuf√ºgen? "a" verwenden
let f = open("log.txt", "a");
```

### 4. Fehler elegant behandeln

```hemlock
fn safe_read_file(path: string): string {
    try {
        let f = open(path, "r");
        try {
            return f.read();
        } finally {
            f.close();
        }
    } catch (e) {
        print("Warnung: Konnte " + path + " nicht lesen: " + e);
        return "";
    }
}
```

### 5. Dateien in umgekehrter Reihenfolge des √ñffnens schlie√üen

```hemlock
let f1 = null;
let f2 = null;
let f3 = null;

try {
    f1 = open("file1.txt", "r");
    f2 = open("file2.txt", "r");
    f3 = open("file3.txt", "r");

    // ... Dateien verwenden
} finally {
    // In umgekehrter Reihenfolge schlie√üen
    if (f3 != null) { f3.close(); }
    if (f2 != null) { f2.close(); }
    if (f1 != null) { f1.close(); }
}
```

### 6. Gro√üe Dateien nicht vollst√§ndig lesen

```hemlock
// Schlecht f√ºr gro√üe Dateien
let f = open("huge.log", "r");
let content = f.read();  // L√§dt gesamte Datei in Speicher
f.close();

// Gut - in Chunks verarbeiten
let f = open("huge.log", "r");
try {
    while (true) {
        let chunk = f.read(4096);
        if (chunk == "") { break; }
        process_chunk(chunk);
    }
} finally {
    f.close();
}
```

## Zusammenfassung

Hemlocks Datei-I/O-API bietet:

- ‚úÖ Einfache, explizite Dateioperationen
- ‚úÖ Text- und Bin√§runterst√ºtzung
- ‚úÖ Wahlfreier Zugriff mit seek/tell
- ‚úÖ Klare Fehlermeldungen mit Kontext
- ‚úÖ Idempotente close-Operation

Denken Sie daran:
- Dateien immer manuell schlie√üen
- try/finally f√ºr Ressourcensicherheit verwenden
- Geeignete √ñffnungsmodi w√§hlen
- Fehler elegant behandeln
- Gro√üe Dateien in Chunks verarbeiten


--------------------------------------------------------------------------------
## Kommandozeilenargumente
--------------------------------------------------------------------------------

# Kommandozeilenargumente in Hemlock

Hemlock-Programme k√∂nnen auf Kommandozeilenargumente √ºber ein eingebautes **`args`-Array** zugreifen, das automatisch beim Programmstart bef√ºllt wird.

## Inhaltsverzeichnis

- [√úberblick](#√ºberblick)
- [Das args-Array](#das-args-array)
- [Eigenschaften](#eigenschaften)
- [Iterationsmuster](#iterationsmuster)
- [H√§ufige Anwendungsf√§lle](#h√§ufige-anwendungsf√§lle)
- [Argument-Parsing-Muster](#argument-parsing-muster)
- [Best Practices](#best-practices)
- [Vollst√§ndige Beispiele](#vollst√§ndige-beispiele)

## √úberblick

Das `args`-Array bietet Zugriff auf Kommandozeilenargumente, die an Ihr Hemlock-Programm √ºbergeben werden:

- **Immer verf√ºgbar** - Eingebaute globale Variable in allen Hemlock-Programmen
- **Skriptname enthalten** - `args[0]` enth√§lt immer den Skriptpfad/-namen
- **Array von Strings** - Alle Argumente sind Strings
- **Nullbasiert** - Standardm√§√üige Array-Indizierung (0, 1, 2, ...)

## Das args-Array

### Grundstruktur

```hemlock
// args[0] ist immer der Skript-Dateiname
// args[1] bis args[n-1] sind die eigentlichen Argumente
print(args[0]);        // "script.hml"
print(args.length);    // Gesamtzahl der Argumente (einschlie√ülich Skriptname)
```

### Beispielverwendung

**Befehl:**
```bash
./hemlock script.hml hello world "test 123"
```

**In script.hml:**
```hemlock
print("Skriptname: " + args[0]);     // "script.hml"
print("Anzahl args: " + typeof(args.length));  // "4"
print("Erstes arg: " + args[1]);       // "hello"
print("Zweites arg: " + args[2]);      // "world"
print("Drittes arg: " + args[3]);      // "test 123"
```

### Index-Referenz

| Index | Enth√§lt | Beispielwert |
|-------|---------|--------------|
| `args[0]` | Skriptpfad/-name | `"script.hml"` oder `"./script.hml"` |
| `args[1]` | Erstes Argument | `"hello"` |
| `args[2]` | Zweites Argument | `"world"` |
| `args[3]` | Drittes Argument | `"test 123"` |
| ... | ... | ... |
| `args[n-1]` | Letztes Argument | (variiert) |

## Eigenschaften

### Immer vorhanden

`args` ist ein globales Array, das in **allen** Hemlock-Programmen verf√ºgbar ist:

```hemlock
// Keine Deklaration oder Import erforderlich
print(args.length);  // Funktioniert sofort
```

### Skriptname enthalten

`args[0]` enth√§lt immer den Skriptpfad/-namen:

```hemlock
print("F√ºhre aus: " + args[0]);
```

**M√∂gliche Werte f√ºr args[0]:**
- `"script.hml"` - Nur der Dateiname
- `"./script.hml"` - Relativer Pfad
- `"/home/user/script.hml"` - Absoluter Pfad
- H√§ngt davon ab, wie das Skript aufgerufen wurde

### Typ: Array von Strings

Alle Argumente werden als Strings gespeichert:

```hemlock
// Argumente: ./hemlock script.hml 42 3.14 true

print(args[1]);  // "42" (String, keine Zahl)
print(args[2]);  // "3.14" (String, keine Zahl)
print(args[3]);  // "true" (String, kein Boolean)

// Bei Bedarf konvertieren:
let num = 42;  // Bei Bedarf manuell parsen
```

### Minimale L√§nge

Immer mindestens 1 (der Skriptname):

```hemlock
print(args.length);  // Minimum: 1
```

**Auch ohne Argumente:**
```bash
./hemlock script.hml
```

```hemlock
// In script.hml:
print(args.length);  // 1 (nur Skriptname)
```

### REPL-Verhalten

Im REPL ist `args.length` 0 (leeres Array):

```hemlock
# REPL-Sitzung
> print(args.length);
0
```

## Iterationsmuster

### Einfache Iteration

`args[0]` (Skriptname) √ºberspringen und eigentliche Argumente verarbeiten:

```hemlock
let i = 1;
while (i < args.length) {
    print("Argument " + typeof(i) + ": " + args[i]);
    i = i + 1;
}
```

**Ausgabe f√ºr: `./hemlock script.hml foo bar baz`**
```
Argument 1: foo
Argument 2: bar
Argument 3: baz
```

### For-In-Iteration (einschlie√ülich Skriptname)

```hemlock
for (let arg in args) {
    print(arg);
}
```

**Ausgabe:**
```
script.hml
foo
bar
baz
```

### Argumentanzahl pr√ºfen

```hemlock
if (args.length < 2) {
    print("Verwendung: " + args[0] + " <argument>");
    // exit oder return
} else {
    let arg = args[1];
    // arg verarbeiten
}
```

### Alle Argumente au√üer Skriptname verarbeiten

```hemlock
let actual_args = args.slice(1, args.length);

for (let arg in actual_args) {
    print("Verarbeite: " + arg);
}
```

## H√§ufige Anwendungsf√§lle

### 1. Einfache Argumentverarbeitung

Auf erforderliches Argument pr√ºfen:

```hemlock
if (args.length < 2) {
    print("Verwendung: " + args[0] + " <filename>");
} else {
    let filename = args[1];
    print("Verarbeite Datei: " + filename);
    // ... Datei verarbeiten
}
```

**Verwendung:**
```bash
./hemlock script.hml data.txt
# Ausgabe: Verarbeite Datei: data.txt
```

### 2. Mehrere Argumente

```hemlock
if (args.length < 3) {
    print("Verwendung: " + args[0] + " <input> <output>");
} else {
    let input_file = args[1];
    let output_file = args[2];

    print("Eingabe: " + input_file);
    print("Ausgabe: " + output_file);

    // Dateien verarbeiten...
}
```

**Verwendung:**
```bash
./hemlock convert.hml input.txt output.txt
```

### 3. Variable Anzahl von Argumenten

Alle bereitgestellten Argumente verarbeiten:

```hemlock
if (args.length < 2) {
    print("Verwendung: " + args[0] + " <file1> [file2] [file3] ...");
} else {
    print("Verarbeite " + typeof(args.length - 1) + " Dateien:");

    let i = 1;
    while (i < args.length) {
        print("  " + args[i]);
        process_file(args[i]);
        i = i + 1;
    }
}
```

**Verwendung:**
```bash
./hemlock batch.hml file1.txt file2.txt file3.txt
```

### 4. Hilfenachricht

```hemlock
if (args.length < 2 || args[1] == "--help" || args[1] == "-h") {
    print("Verwendung: " + args[0] + " [OPTIONEN] <file>");
    print("Optionen:");
    print("  -h, --help     Diese Hilfenachricht anzeigen");
    print("  -v, --verbose  Ausf√ºhrliche Ausgabe aktivieren");
} else {
    // Normal verarbeiten
}
```

### 5. Argumentvalidierung

```hemlock
fn validate_file(filename: string): bool {
    // Pr√ºfen, ob Datei existiert (Beispiel)
    return filename != "";
}

if (args.length < 2) {
    print("Fehler: Kein Dateiname angegeben");
} else if (!validate_file(args[1])) {
    print("Fehler: Ung√ºltige Datei: " + args[1]);
} else {
    print("Verarbeite: " + args[1]);
}
```

## Argument-Parsing-Muster

### Benannte Argumente (Flags)

Einfaches Muster f√ºr benannte Argumente:

```hemlock
let verbose = false;
let output_file = "";
let input_file = "";

let i = 1;
while (i < args.length) {
    if (args[i] == "--verbose" || args[i] == "-v") {
        verbose = true;
    } else if (args[i] == "--output" || args[i] == "-o") {
        i = i + 1;
        if (i < args.length) {
            output_file = args[i];
        }
    } else {
        input_file = args[i];
    }
    i = i + 1;
}

if (verbose) {
    print("Ausf√ºhrlicher Modus aktiviert");
}
print("Eingabe: " + input_file);
print("Ausgabe: " + output_file);
```

**Verwendung:**
```bash
./hemlock script.hml --verbose --output out.txt input.txt
./hemlock script.hml -v -o out.txt input.txt
```

### Boolean-Flags

```hemlock
let debug = false;
let verbose = false;
let force = false;

let i = 1;
while (i < args.length) {
    if (args[i] == "--debug") {
        debug = true;
    } else if (args[i] == "--verbose") {
        verbose = true;
    } else if (args[i] == "--force") {
        force = true;
    }
    i = i + 1;
}
```

### Wert-Argumente

```hemlock
let config_file = "default.conf";
let port = 8080;

let i = 1;
while (i < args.length) {
    if (args[i] == "--config") {
        i = i + 1;
        if (i < args.length) {
            config_file = args[i];
        }
    } else if (args[i] == "--port") {
        i = i + 1;
        if (i < args.length) {
            port = 8080;  // M√ºsste String zu Int parsen
        }
    }
    i = i + 1;
}
```

### Gemischte positionelle und benannte Argumente

```hemlock
let input_file = "";
let output_file = "";
let verbose = false;

let i = 1;
let positional = [];

while (i < args.length) {
    if (args[i] == "--verbose") {
        verbose = true;
    } else {
        // Als positionelles Argument behandeln
        positional.push(args[i]);
    }
    i = i + 1;
}

// Positionelle Argumente zuweisen
if (positional.length > 0) {
    input_file = positional[0];
}
if (positional.length > 1) {
    output_file = positional[1];
}
```

### Argument-Parser-Hilfsfunktion

```hemlock
fn parse_args() {
    let options = {
        verbose: false,
        output: "",
        files: []
    };

    let i = 1;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--verbose" || arg == "-v") {
            options.verbose = true;
        } else if (arg == "--output" || arg == "-o") {
            i = i + 1;
            if (i < args.length) {
                options.output = args[i];
            }
        } else {
            // Positionelles Argument
            options.files.push(arg);
        }

        i = i + 1;
    }

    return options;
}

let opts = parse_args();
print("Verbose: " + typeof(opts.verbose));
print("Ausgabe: " + opts.output);
print("Dateien: " + typeof(opts.files.length));
```

## Best Practices

### 1. Immer Argumentanzahl pr√ºfen

```hemlock
// Gut
if (args.length < 2) {
    print("Verwendung: " + args[0] + " <file>");
} else {
    process_file(args[1]);
}

// Schlecht - kann abst√ºrzen wenn keine Argumente
process_file(args[1]);  // Fehler wenn args.length == 1
```

### 2. Verwendungsinformationen bereitstellen

```hemlock
fn show_usage() {
    print("Verwendung: " + args[0] + " [OPTIONEN] <file>");
    print("Optionen:");
    print("  -h, --help     Hilfe anzeigen");
    print("  -v, --verbose  Ausf√ºhrliche Ausgabe");
}

if (args.length < 2) {
    show_usage();
}
```

### 3. Argumente validieren

```hemlock
fn validate_args() {
    if (args.length < 2) {
        print("Fehler: Erforderliches Argument fehlt");
        return false;
    }

    if (args[1] == "") {
        print("Fehler: Leeres Argument");
        return false;
    }

    return true;
}

if (!validate_args()) {
    // exit oder Verwendung anzeigen
}
```

### 4. Aussagekr√§ftige Variablennamen verwenden

```hemlock
// Gut
let input_filename = args[1];
let output_filename = args[2];
let max_iterations = args[3];

// Schlecht
let a = args[1];
let b = args[2];
let c = args[3];
```

### 5. Argumente mit Leerzeichen in Anf√ºhrungszeichen behandeln

Shell behandelt dies automatisch:

```bash
./hemlock script.hml "file with spaces.txt"
```

```hemlock
print(args[1]);  // "file with spaces.txt"
```

### 6. Argumentobjekte erstellen

```hemlock
fn get_args() {
    return {
        script: args[0],
        input: args[1],
        output: args[2]
    };
}

let arguments = get_args();
print("Eingabe: " + arguments.input);
```

## Vollst√§ndige Beispiele

### Beispiel 1: Dateiverarbeiter

```hemlock
// Verwendung: ./hemlock process.hml <input> <output>

fn show_usage() {
    print("Verwendung: " + args[0] + " <input_file> <output_file>");
}

if (args.length < 3) {
    show_usage();
} else {
    let input = args[1];
    let output = args[2];

    print("Verarbeite " + input + " -> " + output);

    // Dateien verarbeiten
    let f_in = open(input, "r");
    let f_out = open(output, "w");

    try {
        let content = f_in.read();
        let processed = content.to_upper();  // Beispielverarbeitung
        f_out.write(processed);

        print("Fertig!");
    } finally {
        f_in.close();
        f_out.close();
    }
}
```

### Beispiel 2: Stapel-Dateiverarbeiter

```hemlock
// Verwendung: ./hemlock batch.hml <file1> <file2> <file3> ...

if (args.length < 2) {
    print("Verwendung: " + args[0] + " <file1> [file2] [file3] ...");
} else {
    print("Verarbeite " + typeof(args.length - 1) + " Dateien:");

    let i = 1;
    while (i < args.length) {
        let filename = args[i];
        print("  Verarbeite: " + filename);

        try {
            let f = open(filename, "r");
            let content = f.read();
            f.close();

            // Inhalt verarbeiten...
            print("    " + typeof(content.length) + " Bytes");
        } catch (e) {
            print("    Fehler: " + e);
        }

        i = i + 1;
    }

    print("Fertig!");
}
```

### Beispiel 3: Fortgeschrittener Argument-Parser

```hemlock
// Verwendung: ./hemlock app.hml [OPTIONEN] <files...>
// Optionen:
//   --verbose, -v     Ausf√ºhrliche Ausgabe aktivieren
//   --output, -o FILE Ausgabedatei festlegen
//   --help, -h        Hilfe anzeigen

fn parse_arguments() {
    let config = {
        verbose: false,
        output: "output.txt",
        help: false,
        files: []
    };

    let i = 1;
    while (i < args.length) {
        let arg = args[i];

        if (arg == "--verbose" || arg == "-v") {
            config.verbose = true;
        } else if (arg == "--output" || arg == "-o") {
            i = i + 1;
            if (i < args.length) {
                config.output = args[i];
            } else {
                print("Fehler: --output erfordert einen Wert");
            }
        } else if (arg == "--help" || arg == "-h") {
            config.help = true;
        } else if (arg.starts_with("--")) {
            print("Fehler: Unbekannte Option: " + arg);
        } else {
            config.files.push(arg);
        }

        i = i + 1;
    }

    return config;
}

fn show_help() {
    print("Verwendung: " + args[0] + " [OPTIONEN] <files...>");
    print("Optionen:");
    print("  --verbose, -v     Ausf√ºhrliche Ausgabe aktivieren");
    print("  --output, -o FILE Ausgabedatei festlegen");
    print("  --help, -h        Diese Hilfe anzeigen");
}

let config = parse_arguments();

if (config.help) {
    show_help();
} else if (config.files.length == 0) {
    print("Fehler: Keine Eingabedateien angegeben");
    show_help();
} else {
    if (config.verbose) {
        print("Ausf√ºhrlicher Modus aktiviert");
        print("Ausgabedatei: " + config.output);
        print("Eingabedateien: " + typeof(config.files.length));
    }

    // Dateien verarbeiten
    for (let file in config.files) {
        if (config.verbose) {
            print("Verarbeite: " + file);
        }
        // ... Datei verarbeiten
    }
}
```

### Beispiel 4: Konfigurationswerkzeug

```hemlock
// Verwendung: ./hemlock config.hml <action> [arguments]
// Aktionen:
//   get <key>
//   set <key> <value>
//   list

fn show_usage() {
    print("Verwendung: " + args[0] + " <action> [arguments]");
    print("Aktionen:");
    print("  get <key>         Konfigurationswert abrufen");
    print("  set <key> <value> Konfigurationswert setzen");
    print("  list              Alle Konfigurationen auflisten");
}

if (args.length < 2) {
    show_usage();
} else {
    let action = args[1];

    if (action == "get") {
        if (args.length < 3) {
            print("Fehler: 'get' erfordert einen Schl√ºssel");
        } else {
            let key = args[2];
            print("Hole: " + key);
            // ... aus Konfiguration holen
        }
    } else if (action == "set") {
        if (args.length < 4) {
            print("Fehler: 'set' erfordert Schl√ºssel und Wert");
        } else {
            let key = args[2];
            let value = args[3];
            print("Setze " + key + " = " + value);
            // ... in Konfiguration setzen
        }
    } else if (action == "list") {
        print("Liste alle Konfigurationen auf:");
        // ... Konfiguration auflisten
    } else {
        print("Fehler: Unbekannte Aktion: " + action);
        show_usage();
    }
}
```

## Zusammenfassung

Hemlocks Kommandozeilenargument-Unterst√ºtzung bietet:

- ‚úÖ Eingebautes `args`-Array global verf√ºgbar
- ‚úÖ Einfacher Array-basierter Zugriff auf Argumente
- ‚úÖ Skriptname in `args[0]`
- ‚úÖ Alle Argumente als Strings
- ‚úÖ Array-Methoden verf√ºgbar (.length, .slice, etc.)

Denken Sie daran:
- Immer `args.length` pr√ºfen, bevor auf Elemente zugegriffen wird
- `args[0]` ist der Skriptname
- Eigentliche Argumente beginnen bei `args[1]`
- Alle Argumente sind Strings - bei Bedarf konvertieren
- Verwendungsinformationen f√ºr benutzerfreundliche Tools bereitstellen
- Argumente vor der Verarbeitung validieren

H√§ufige Muster:
- Einfache positionelle Argumente
- Benannte/Flag-Argumente (--flag)
- Wert-Argumente (--option wert)
- Hilfenachrichten (--help)
- Argumentvalidierung


--------------------------------------------------------------------------------
## Memory Ownership
--------------------------------------------------------------------------------

# Speicherverwaltung in Hemlock

> "Wir geben dir die Werkzeuge, um sicher zu sein, aber wir zwingen dich nicht, sie zu benutzen."

Dieses Dokument beschreibt die Speicherverwaltungssemantik in Hemlock und behandelt sowohl programmierverwalteten Speicher als auch laufzeitverwaltete Werte.

## Inhaltsverzeichnis

1. [Der Vertrag](#der-vertrag)
2. [Programmierverwalteter Speicher](#programmierverwalteter-speicher)
3. [Laufzeitverwaltete Werte](#laufzeitverwaltete-werte)
4. [Eigentums√ºbergabepunkte](#eigentums√ºbergabepunkte)
5. [Async und Nebenl√§ufigkeit](#async-und-nebenl√§ufigkeit)
6. [FFI-Speicherregeln](#ffi-speicherregeln)
7. [Ausnahmesicherheit](#ausnahmesicherheit)
8. [Best Practices](#best-practices)

---

## Der Vertrag

Hemlock hat eine klare Aufteilung der Speicherverwaltungsverantwortung:

| Speichertyp | Verwaltet von | Bereinigungsmethode |
|-------------|---------------|---------------------|
| Rohe Zeiger (`ptr`) | **Programmierer** | `free(ptr)` |
| Buffer (`buffer`) | **Programmierer** | `free(buf)` |
| Strings, Arrays, Objekte | **Laufzeit** | Automatisch (Referenzz√§hlung) |
| Funktionen, Closures | **Laufzeit** | Automatisch (Referenzz√§hlung) |
| Tasks, Channels | **Laufzeit** | Automatisch (Referenzz√§hlung) |

**Das Kernprinzip:** Wenn du es explizit allokierst, gibst du es explizit frei. Alles andere wird automatisch behandelt.

---

## Programmierverwalteter Speicher

### Rohe Zeiger

```hemlock
let p = alloc(64);       // 64 Bytes allokieren
memset(p, 0, 64);        // Initialisieren
// ... Speicher verwenden ...
free(p);                 // Deine Verantwortung!
```

**Regeln:**
- `alloc()` gibt Speicher zur√ºck, den du besitzt
- Du musst `free()` aufrufen, wenn du fertig bist
- Double-free wird abst√ºrzen (absichtlich)
- Use-after-free ist undefiniertes Verhalten
- Zeigerarithmetik ist erlaubt, aber ungepr√ºft

### Typisierte Allokation

```hemlock
let arr = talloc("i32", 100);  // 100 i32s allokieren (400 Bytes)
ptr_write_i32(arr, 0, 42);     // In Index 0 schreiben
let val = ptr_read_i32(arr, 0); // Von Index 0 lesen
free(arr);                      // Immer noch deine Verantwortung
```

### Buffer (Sichere Alternative)

```hemlock
let buf = buffer(64);    // Grenzengepr√ºfter Buffer
buf[0] = 42;             // Sicherer Zugriff
// buf[100] = 1;         // Laufzeitfehler: au√üerhalb der Grenzen
free(buf);               // Braucht immer noch explizites free
```

**Hauptunterschied:** Buffer bieten Grenzenpr√ºfung, rohe Zeiger nicht.

---

## Laufzeitverwaltete Werte

### Referenzz√§hlung

Heap-allokierte Werte verwenden atomare Referenzz√§hlung:

```hemlock
let s1 = "hello";        // String allokiert, refcount = 1
let s2 = s1;             // s2 teilt s1, refcount = 2
// Wenn beide aus dem Scope gehen, refcount ‚Üí 0, Speicher freigegeben
```

**Referenzgez√§hlte Typen:**
- `string` - UTF-8 Text
- `array` - Dynamische Arrays
- `object` - Schl√ºssel-Wert Objekte
- `function` - Closures
- `task` - Async Task Handles
- `channel` - Kommunikationskan√§le

### Zyklenerkennung

Die Laufzeit behandelt Zyklen in Objektgraphen:

```hemlock
let a = { ref: null };
let b = { ref: a };
a.ref = b;               // Zyklus: a ‚Üí b ‚Üí a
// Laufzeit verwendet visited sets um Zyklen w√§hrend der Bereinigung zu erkennen und zu brechen
```

---

## Eigentums√ºbergabepunkte

### Variablenbindung

```hemlock
let x = [1, 2, 3];       // Array erstellt mit refcount 1
                         // x besitzt die Referenz
```

### Funktionsr√ºckgaben

```hemlock
fn make_array() {
    return [1, 2, 3];    // Array-Eigentum wird an Aufrufer √ºbertragen
}
let arr = make_array();  // arr besitzt jetzt die Referenz
```

### Zuweisung

```hemlock
let a = "hello";
let b = a;               // Geteilte Referenz (refcount erh√∂ht)
b = "world";             // a hat immer noch "hello", b hat "world"
```

### Channel-Operationen

```hemlock
let ch = channel(10);
ch.send("message");      // Wert wird in Channel-Buffer kopiert
                         // Original bleibt g√ºltig

let msg = ch.recv();     // Erh√§lt Eigentum vom Channel
```

### Task-Spawning

```hemlock
let data = { x: 1 };
let task = spawn(worker, data);  // data wird TIEF KOPIERT f√ºr Isolation
data.x = 2;                       // Sicher - Task hat eigene Kopie
let result = join(task);          // result Eigentum wird an Aufrufer √ºbertragen
```

---

## Async und Nebenl√§ufigkeit

### Thread-Isolation

Gespawnte Tasks erhalten **tiefe Kopien** von ver√§nderlichen Argumenten:

```hemlock
async fn worker(data) {
    data.x = 100;        // Modifiziert nur die Kopie des Tasks
    return data;
}

let obj = { x: 1 };
let task = spawn(worker, obj);
obj.x = 2;               // Sicher - beeinflusst Task nicht
let result = join(task);
print(obj.x);            // 2 (unver√§ndert durch Task)
print(result.x);         // 100 (modifizierte Kopie des Tasks)
```

### Geteilte Koordinationsobjekte

Einige Typen werden per Referenz geteilt (nicht kopiert):
- **Channels** - F√ºr Inter-Task Kommunikation
- **Tasks** - F√ºr Koordination (join/detach)

```hemlock
let ch = channel(1);
spawn(producer, ch);     // Gleicher Channel, keine Kopie
spawn(consumer, ch);     // Beide Tasks teilen den Channel
```

### Task-Ergebnisse

```hemlock
let task = spawn(compute);
let result = join(task);  // Aufrufer besitzt das Ergebnis
                          // Task-Referenz wird freigegeben wenn Task beendet
```

### Losgel√∂ste Tasks

```hemlock
detach(spawn(background_work));
// Task l√§uft unabh√§ngig
// Ergebnis wird automatisch freigegeben wenn Task abgeschlossen
// Kein Leak obwohl niemand join() aufruft
```

---

## FFI-Speicherregeln

### An C-Funktionen √ºbergeben

```hemlock
extern fn strlen(s: string): i32;

let s = "hello";
let len = strlen(s);     // Hemlock beh√§lt Eigentum
                         // String ist w√§hrend des Aufrufs g√ºltig
                         // C-Funktion sollte ihn NICHT freigeben
```

### Von C-Funktionen empfangen

```hemlock
extern fn strdup(s: string): ptr;

let copy = strdup("hello");  // C hat diesen Speicher allokiert
free(copy);                   // Deine Verantwortung freizugeben
```

### Struct-√úbergabe (Nur Compiler)

```hemlock
// C struct Layout definieren
ffi_struct Point { x: f64, y: f64 }

extern fn make_point(x: f64, y: f64): Point;

let p = make_point(1.0, 2.0);  // Per Wert zur√ºckgegeben, kopiert
                                // Keine Bereinigung f√ºr Stack-Structs n√∂tig
```

### Callback-Speicher

```hemlock
// Wenn C zur√ºck nach Hemlock ruft:
// - Argumente geh√∂ren C (nicht freigeben)
// - R√ºckgabewert-Eigentum wird an C √ºbertragen
```

---

## Ausnahmesicherheit

### Garantien

Die Laufzeit bietet diese Garantien:

1. **Kein Leak bei normalem Exit** - Alle laufzeitverwalteten Werte werden bereinigt
2. **Kein Leak bei Ausnahme** - Tempor√§re werden w√§hrend Stack-Unwinding freigegeben
3. **Defer l√§uft bei Ausnahme** - Bereinigungscode wird ausgef√ºhrt

### Ausdrucksauswertung

```hemlock
// Wenn dies w√§hrend Array-Erstellung wirft:
let arr = [f(), g(), h()];  // Teilweises Array wird freigegeben

// Wenn dies w√§hrend Funktionsaufruf wirft:
foo(a(), b(), c());         // Zuvor ausgewertete Args werden freigegeben
```

### Defer f√ºr Bereinigung

```hemlock
fn process_file() {
    let f = open("data.txt", "r");
    defer f.close();         // L√§uft bei return ODER Ausnahme

    let data = f.read();
    if (data == "") {
        throw "Empty file";  // f.close() l√§uft trotzdem!
    }
    return data;
}
```

---

## Best Practices

### 1. Bevorzuge Laufzeitverwaltete Typen

```hemlock
// Bevorzuge dies:
let data = [1, 2, 3, 4, 5];

// Statt dies (au√üer du brauchst Low-Level Kontrolle):
let data = talloc("i32", 5);
// ... muss daran denken freizugeben ...
```

### 2. Verwende Defer f√ºr Manuellen Speicher

```hemlock
fn process() {
    let buf = alloc(1024);
    defer free(buf);        // Garantierte Bereinigung

    // ... buf verwenden ...
    // Kein free an jedem Return-Punkt n√∂tig
}
```

### 3. Vermeide Rohe Zeiger in Async

```hemlock
// FALSCH - Zeiger k√∂nnte freigegeben werden bevor Task abgeschlossen
let p = alloc(64);
spawn(worker, p);          // Task bekommt den Zeigerwert
free(p);                   // Hoppla! Task verwendet ihn noch

// RICHTIG - verwende Channels oder kopiere Daten
let ch = channel(1);
let data = buffer(64);
// ... data f√ºllen ...
ch.send(data);             // Tief kopiert
spawn(worker, ch);
free(data);                // Sicher - Task hat eigene Kopie
```

### 4. Schlie√üe Channels wenn Fertig

```hemlock
let ch = channel(10);
// ... channel verwenden ...
ch.close();                // Leert und gibt gepufferte Werte frei
```

### 5. Join oder Detach Tasks

```hemlock
let task = spawn(work);

// Option 1: Auf Ergebnis warten
let result = join(task);

// Option 2: Fire and forget
// detach(task);

// NICHT: Task-Handle aus Scope gehen lassen ohne join oder detach
// (Es wird bereinigt, aber Ergebnis k√∂nnte leaken)
```

---

## Speicherprobleme Debuggen

### ASAN Aktivieren

```bash
make asan
ASAN_OPTIONS=detect_leaks=1 ./hemlock script.hml
```

### Leak-Regressionstests Ausf√ºhren

```bash
make leak-regression       # Vollst√§ndige Suite
make leak-regression-quick # Umfassenden Test √ºberspringen
```

### Valgrind

```bash
make valgrind-check FILE=script.hml
```

---

## Zusammenfassung

| Operation | Speicherverhalten |
|-----------|-------------------|
| `alloc(n)` | Allokiert, du gibst frei |
| `buffer(n)` | Allokiert mit Grenzenpr√ºfung, du gibst frei |
| `"string"` | Laufzeit verwaltet |
| `[array]` | Laufzeit verwaltet |
| `{object}` | Laufzeit verwaltet |
| `spawn(fn)` | Kopiert Args tief, Laufzeit verwaltet Task |
| `join(task)` | Aufrufer besitzt Ergebnis |
| `detach(task)` | Laufzeit gibt Ergebnis frei wenn fertig |
| `ch.send(v)` | Kopiert Wert in Channel |
| `ch.recv()` | Aufrufer besitzt empfangenen Wert |
| `ch.close()` | Leert und gibt gepufferte Werte frei |


--------------------------------------------------------------------------------
## Profilerstellung
--------------------------------------------------------------------------------

# Profiling

Hemlock enth√§lt einen integrierten Profiler f√ºr **CPU-Zeit-Analyse**, **Speicherverfolgung** und **Leak-Erkennung**. Der Profiler hilft dabei, Leistungsengp√§sse und Speicherprobleme in Ihren Programmen zu identifizieren.

## Inhaltsverzeichnis

- [√úberblick](#√ºberblick)
- [Schnellstart](#schnellstart)
- [Profiling-Modi](#profiling-modi)
- [Ausgabeformate](#ausgabeformate)
- [Leak-Erkennung](#leak-erkennung)
- [Berichte verstehen](#berichte-verstehen)
- [Flamegraph-Generierung](#flamegraph-generierung)
- [Best Practices](#best-practices)

---

## √úberblick

Der Profiler wird √ºber den `profile`-Unterbefehl aufgerufen:

```bash
hemlock profile [OPTIONEN] <DATEI>
```

**Hauptfunktionen:**
- **CPU-Profiling** - Zeit messen, die in jeder Funktion verbracht wird (Self-Time und Total-Time)
- **Speicher-Profiling** - Alle Allokationen mit Quellcode-Positionen verfolgen
- **Leak-Erkennung** - Speicher identifizieren, der nie freigegeben wurde
- **Mehrere Ausgabeformate** - Text, JSON und Flamegraph-kompatible Ausgabe
- **Pro-Funktion-Speicherstatistiken** - Sehen, welche Funktionen am meisten Speicher allozieren

---

## Schnellstart

### CPU-Zeit profilen (Standard)

```bash
hemlock profile script.hml
```

### Speicherallokationen profilen

```bash
hemlock profile --memory script.hml
```

### Speicherlecks erkennen

```bash
hemlock profile --leaks script.hml
```

### Flamegraph-Daten generieren

```bash
hemlock profile --flamegraph script.hml > profile.folded
flamegraph.pl profile.folded > profile.svg
```

---

## Profiling-Modi

### CPU-Profiling (Standard)

Misst Zeit, die in jeder Funktion verbracht wird, unterscheidend zwischen:
- **Self-Time** - Zeit, die mit der Ausf√ºhrung des eigenen Codes der Funktion verbracht wird
- **Total-Time** - Self-Time plus Zeit in aufgerufenen Funktionen

```bash
hemlock profile script.hml
hemlock profile --cpu script.hml  # Explizit
```

**Beispielausgabe:**
```
=== Hemlock Profiler-Bericht ===

Gesamtzeit: 1.234ms
Aufgerufene Funktionen: 5 eindeutige

--- Top 5 nach Self-Time ---

Funktion                        Self      Total   Aufrufe
--------                        ----      -----   -------
expensive_calc              0.892ms    0.892ms     100  (72.3%)
process_data                0.234ms    1.126ms      10  (19.0%)
helper                      0.067ms    0.067ms     500  (5.4%)
main                        0.041ms    1.234ms       1  (3.3%)
```

---

### Speicher-Profiling

Verfolgt alle Speicherallokationen (`alloc`, `buffer`, `talloc`, `realloc`) mit Quellcode-Positionen.

```bash
hemlock profile --memory script.hml
```

**Beispielausgabe:**
```
=== Hemlock Profiler-Bericht ===

Gesamtzeit: 0.543ms
Aufgerufene Funktionen: 3 eindeutige
Gesamte Allokationen: 15 (4.2KB)

--- Top 3 nach Self-Time ---

Funktion                        Self      Total   Aufrufe      Allok      Anzahl
--------                        ----      -----   -------      -----      ------
allocator                   0.312ms    0.312ms      10      3.2KB         10  (57.5%)
buffer_ops                  0.156ms    0.156ms       5       1KB          5  (28.7%)
main                        0.075ms    0.543ms       1        0B          0  (13.8%)

--- Top 10 Allokationsstellen ---

Position                                      Gesamt   Anzahl
--------                                      ------   ------
src/data.hml:42                               1.5KB        5
src/data.hml:67                               1.0KB       10
src/main.hml:15                               512B         1
```

---

### Aufrufz√§hler-Modus

Minimaler Overhead-Modus, der nur Funktionsaufrufe z√§hlt (keine Zeitmessung).

```bash
hemlock profile --calls script.hml
```

---

## Ausgabeformate

### Text (Standard)

Menschenlesbare Zusammenfassung mit Tabellen.

```bash
hemlock profile script.hml
```

---

### JSON

Maschinenlesbares Format f√ºr Integration mit anderen Werkzeugen.

```bash
hemlock profile --json script.hml
```

**Beispielausgabe:**
```json
{
  "total_time_ns": 1234567,
  "function_count": 5,
  "total_alloc_bytes": 4096,
  "total_alloc_count": 15,
  "functions": [
    {
      "name": "expensive_calc",
      "source_file": "script.hml",
      "line": 10,
      "self_time_ns": 892000,
      "total_time_ns": 892000,
      "call_count": 100,
      "alloc_bytes": 0,
      "alloc_count": 0
    }
  ],
  "alloc_sites": [
    {
      "source_file": "script.hml",
      "line": 42,
      "total_bytes": 1536,
      "alloc_count": 5,
      "current_bytes": 0
    }
  ]
}
```

---

### Flamegraph

Generiert zusammengeklapptes Stack-Format, kompatibel mit [flamegraph.pl](https://github.com/brendangregg/FlameGraph).

```bash
hemlock profile --flamegraph script.hml > profile.folded

# SVG mit flamegraph.pl generieren
flamegraph.pl profile.folded > profile.svg
```

**Beispiel zusammengeklappte Ausgabe:**
```
main;process_data;expensive_calc 892
main;process_data;helper 67
main;process_data 234
main 41
```

---

## Leak-Erkennung

Das `--leaks`-Flag zeigt nur Allokationen, die nie freigegeben wurden, was das Identifizieren von Speicherlecks erleichtert.

```bash
hemlock profile --leaks script.hml
```

**Beispielprogramm mit Lecks:**
```hemlock
fn leaky() {
    let p1 = alloc(100);    // Leck - nie freigegeben
    let p2 = alloc(200);    // OK - unten freigegeben
    free(p2);
}

fn clean() {
    let b = buffer(64);
    free(b);                // Ordnungsgem√§√ü freigegeben
}

leaky();
clean();
```

**Ausgabe mit --leaks:**
```
=== Hemlock Profiler-Bericht ===

Gesamtzeit: 0.034ms
Aufgerufene Funktionen: 2 eindeutige
Gesamte Allokationen: 3 (388B)

--- Top 2 nach Self-Time ---

Funktion                        Self      Total   Aufrufe      Allok      Anzahl
--------                        ----      -----   -------      -----      ------
leaky                       0.021ms    0.021ms       1       300B          2  (61.8%)
clean                       0.013ms    0.013ms       1        88B          1  (38.2%)

--- Speicherlecks (1 Stelle) ---

Position                                     Leck        Gesamt    Anzahl
--------                                     ----        ------    ------
script.hml:2                                 100B        100B         1
```

Der Leak-Bericht zeigt:
- **Leck** - Bytes, die bei Programmende noch nicht freigegeben sind
- **Gesamt** - Gesamte jemals an dieser Stelle allozierte Bytes
- **Anzahl** - Anzahl der Allokationen an dieser Stelle

---

## Berichte verstehen

### Funktionsstatistiken

| Spalte | Beschreibung |
|--------|--------------|
| Funktion | Funktionsname |
| Self | Zeit in Funktion ohne aufgerufene Funktionen |
| Total | Zeit einschlie√ülich aller aufgerufenen Funktionen |
| Aufrufe | Anzahl der Funktionsaufrufe |
| Allok | Gesamte von dieser Funktion allozierte Bytes |
| Anzahl | Anzahl der Allokationen durch diese Funktion |
| (%) | Prozentsatz der gesamten Programmzeit |

### Allokationsstellen

| Spalte | Beschreibung |
|--------|--------------|
| Position | Quelldatei und Zeilennummer |
| Gesamt | Gesamte an dieser Position allozierte Bytes |
| Anzahl | Anzahl der Allokationen |
| Leck | Bytes, die bei Programmende noch alloziert sind (nur --leaks) |

### Zeiteinheiten

Der Profiler w√§hlt automatisch geeignete Einheiten:
- `ns` - Nanosekunden (< 1us)
- `us` - Mikrosekunden (< 1ms)
- `ms` - Millisekunden (< 1s)
- `s` - Sekunden

---

## Befehlsreferenz

```
hemlock profile [OPTIONEN] <DATEI>

OPTIONEN:
    --cpu           CPU/Zeit-Profiling (Standard)
    --memory        Speicherallokations-Profiling
    --calls         Nur Aufrufz√§hlung (minimaler Overhead)
    --leaks         Nur nicht freigegebene Allokationen zeigen (impliziert --memory)
    --json          Ausgabe im JSON-Format
    --flamegraph    Ausgabe im Flamegraph-kompatiblen Format
    --top N         Top N Eintr√§ge zeigen (Standard: 20)
```

---

## Flamegraph-Generierung

Flamegraphs visualisieren, wo Ihr Programm Zeit verbringt, wobei breitere Balken mehr verbrachte Zeit anzeigen.

### Flamegraph generieren

1. flamegraph.pl installieren:
   ```bash
   git clone https://github.com/brendangregg/FlameGraph
   ```

2. Ihr Programm profilen:
   ```bash
   hemlock profile --flamegraph script.hml > profile.folded
   ```

3. SVG generieren:
   ```bash
   ./FlameGraph/flamegraph.pl profile.folded > profile.svg
   ```

4. `profile.svg` im Browser √∂ffnen f√ºr eine interaktive Visualisierung.

### Flamegraphs lesen

- **X-Achse**: Prozentsatz der Gesamtzeit (Breite = Zeitanteil)
- **Y-Achse**: Call-Stack-Tiefe (unten = Einstiegspunkt, oben = Blattfunktionen)
- **Farbe**: Zuf√§llig, nur zur visuellen Unterscheidung
- **Klick**: In eine Funktion hineinzoomen, um ihre aufgerufenen Funktionen zu sehen

---

## Best Practices

### 1. Repr√§sentative Workloads profilen

Mit realistischen Daten und Nutzungsmustern profilen. Kleine Testf√§lle enth√ºllen m√∂glicherweise nicht die echten Engp√§sse.

```bash
# Gut: Mit produktions√§hnlichen Daten profilen
hemlock profile --memory process_large_file.hml large_input.txt

# Weniger n√ºtzlich: Kleiner Testfall
hemlock profile quick_test.hml
```

### 2. --leaks w√§hrend der Entwicklung verwenden

Leak-Erkennung regelm√§√üig ausf√ºhren, um Speicherlecks fr√ºh zu finden:

```bash
hemlock profile --leaks my_program.hml
```

### 3. Vorher und Nachher vergleichen

Vor und nach Optimierungen profilen, um die Auswirkung zu messen:

```bash
# Vor Optimierung
hemlock profile --json script.hml > before.json

# Nach Optimierung
hemlock profile --json script.hml > after.json

# Ergebnisse vergleichen
```

### 4. --top f√ºr gro√üe Programme verwenden

Ausgabe begrenzen, um sich auf die wichtigsten Funktionen zu konzentrieren:

```bash
hemlock profile --top 10 large_program.hml
```

### 5. Mit Flamegraphs kombinieren

F√ºr komplexe Aufrufmuster bieten Flamegraphs eine bessere Visualisierung als Textausgabe:

```bash
hemlock profile --flamegraph complex_app.hml > app.folded
flamegraph.pl app.folded > app.svg
```

---

## Profiler-Overhead

Der Profiler f√ºgt etwas Overhead zur Programmausf√ºhrung hinzu:

| Modus | Overhead | Anwendungsfall |
|-------|----------|----------------|
| `--calls` | Minimal | Nur Funktionsaufrufe z√§hlen |
| `--cpu` | Niedrig | Allgemeines Leistungs-Profiling |
| `--memory` | Moderat | Speicheranalyse und Leak-Erkennung |

F√ºr die genauesten Ergebnisse mehrfach profilen und nach konsistenten Mustern suchen.

---

## Siehe auch

- [Speicherverwaltung](#language-guide-memory) - Pointer und Buffer
- [Speicher-API](#reference-memory-api) - alloc, free, buffer-Funktionen
- [Async/Nebenl√§ufigkeit](#advanced-async-concurrency) - Async-Code profilen


--------------------------------------------------------------------------------
## Signalverarbeitung
--------------------------------------------------------------------------------

# Signalbehandlung in Hemlock

Hemlock bietet **POSIX-Signalbehandlung** f√ºr die Verwaltung von Systemsignalen wie SIGINT (Strg+C), SIGTERM und benutzerdefinierten Signalen. Dies erm√∂glicht Low-Level-Prozesssteuerung und Inter-Prozess-Kommunikation.

## Inhaltsverzeichnis

- [√úberblick](#√ºberblick)
- [Signal-API](#signal-api)
- [Signal-Konstanten](#signal-konstanten)
- [Grundlegende Signalbehandlung](#grundlegende-signalbehandlung)
- [Fortgeschrittene Muster](#fortgeschrittene-muster)
- [Signal-Handler-Verhalten](#signal-handler-verhalten)
- [Sicherheits√ºberlegungen](#sicherheits√ºberlegungen)
- [H√§ufige Anwendungsf√§lle](#h√§ufige-anwendungsf√§lle)
- [Vollst√§ndige Beispiele](#vollst√§ndige-beispiele)

## √úberblick

Signalbehandlung erm√∂glicht Programmen:
- Auf Benutzerunterbrechungen reagieren (Strg+C, Strg+Z)
- Graceful Shutdown implementieren
- Beendigungsanfragen behandeln
- Benutzerdefinierte Signale f√ºr Inter-Prozess-Kommunikation verwenden
- Alarm-/Timer-Mechanismen erstellen

**Wichtig:** Signalbehandlung ist in Hemlocks Philosophie **inh√§rent unsicher**. Handler k√∂nnen jederzeit aufgerufen werden und die normale Ausf√ºhrung unterbrechen. Der Benutzer ist f√ºr die ordnungsgem√§√üe Synchronisation verantwortlich.

## Signal-API

### signal(signum, handler_fn)

Einen Signal-Handler registrieren.

**Parameter:**
- `signum` (i32) - Signalnummer (Konstante wie SIGINT, SIGTERM)
- `handler_fn` (function oder null) - Funktion, die aufgerufen wird wenn Signal empfangen wird, oder `null` um auf Standard zur√ºckzusetzen

**R√ºckgabe:** Der vorherige Handler (oder `null` wenn keiner)

**Beispiel:**
```hemlock
fn my_handler(sig) {
    print("Signal empfangen: " + typeof(sig));
}

let old_handler = signal(SIGINT, my_handler);
```

**Auf Standard zur√ºcksetzen:**
```hemlock
signal(SIGINT, null);  // SIGINT auf Standardverhalten zur√ºcksetzen
```

### raise(signum)

Ein Signal an den aktuellen Prozess senden.

**Parameter:**
- `signum` (i32) - Zu sendende Signalnummer

**R√ºckgabe:** `null`

**Beispiel:**
```hemlock
raise(SIGUSR1);  // SIGUSR1-Handler ausl√∂sen
```

## Signal-Konstanten

Hemlock bietet Standard-POSIX-Signal-Konstanten als i32-Werte.

### Unterbrechung & Beendigung

| Konstante | Wert | Beschreibung | H√§ufiger Ausl√∂ser |
|-----------|------|--------------|-------------------|
| `SIGINT` | 2 | Unterbrechung von Tastatur | Strg+C |
| `SIGTERM` | 15 | Beendigungsanfrage | `kill`-Befehl |
| `SIGQUIT` | 3 | Beenden von Tastatur | Strg+\ |
| `SIGHUP` | 1 | Hangup erkannt | Terminal geschlossen |
| `SIGABRT` | 6 | Abort-Signal | `abort()`-Funktion |

**Beispiele:**
```hemlock
signal(SIGINT, handle_interrupt);   // Strg+C
signal(SIGTERM, handle_terminate);  // kill-Befehl
signal(SIGHUP, handle_hangup);      // Terminal schlie√üt
```

### Benutzerdefinierte Signale

| Konstante | Wert | Beschreibung | Anwendungsfall |
|-----------|------|--------------|----------------|
| `SIGUSR1` | 10 | Benutzerdefiniertes Signal 1 | Benutzerdefinierte IPC |
| `SIGUSR2` | 12 | Benutzerdefiniertes Signal 2 | Benutzerdefinierte IPC |

**Beispiele:**
```hemlock
// F√ºr benutzerdefinierte Kommunikation verwenden
signal(SIGUSR1, reload_config);
signal(SIGUSR2, rotate_logs);
```

### Prozesssteuerung

| Konstante | Wert | Beschreibung | Hinweise |
|-----------|------|--------------|----------|
| `SIGALRM` | 14 | Alarm-Timer | Nach `alarm()` |
| `SIGCHLD` | 17 | Kindprozess-Status√§nderung | Prozessverwaltung |
| `SIGCONT` | 18 | Fortsetzen wenn gestoppt | Nach SIGSTOP fortsetzen |
| `SIGSTOP` | 19 | Prozess stoppen | **Kann nicht abgefangen werden** |
| `SIGTSTP` | 20 | Terminal-Stop | Strg+Z |

**Beispiele:**
```hemlock
signal(SIGALRM, handle_timeout);
signal(SIGCHLD, handle_child_exit);
```

### I/O-Signale

| Konstante | Wert | Beschreibung | Wann gesendet |
|-----------|------|--------------|---------------|
| `SIGPIPE` | 13 | Gebrochene Pipe | Schreiben in geschlossene Pipe |
| `SIGTTIN` | 21 | Hintergrund-Lesen von Terminal | BG-Prozess liest TTY |
| `SIGTTOU` | 22 | Hintergrund-Schreiben zu Terminal | BG-Prozess schreibt TTY |

**Beispiele:**
```hemlock
signal(SIGPIPE, handle_broken_pipe);
```

## Grundlegende Signalbehandlung

### Strg+C abfangen

```hemlock
let interrupted = false;

fn handle_interrupt(sig) {
    print("SIGINT empfangen!");
    interrupted = true;
}

signal(SIGINT, handle_interrupt);

// Programm l√§uft weiter...
// Benutzer dr√ºckt Strg+C -> handle_interrupt() wird aufgerufen

while (!interrupted) {
    // Arbeit erledigen...
}

print("Beende wegen Unterbrechung");
```

### Handler-Funktionssignatur

Signal-Handler empfangen ein Argument: die Signalnummer (i32)

```hemlock
fn my_handler(signum) {
    print("Signal empfangen: " + typeof(signum));
    // signum enth√§lt die Signalnummer (z.B. 2 f√ºr SIGINT)

    if (signum == SIGINT) {
        print("Das ist SIGINT");
    }
}

signal(SIGINT, my_handler);
signal(SIGTERM, my_handler);  // Gleicher Handler f√ºr mehrere Signale
```

### Mehrere Signal-Handler

Verschiedene Handler f√ºr verschiedene Signale:

```hemlock
fn handle_int(sig) {
    print("SIGINT empfangen");
}

fn handle_term(sig) {
    print("SIGTERM empfangen");
}

fn handle_usr1(sig) {
    print("SIGUSR1 empfangen");
}

signal(SIGINT, handle_int);
signal(SIGTERM, handle_term);
signal(SIGUSR1, handle_usr1);
```

### Auf Standardverhalten zur√ºcksetzen

`null` als Handler √ºbergeben, um auf Standardverhalten zur√ºckzusetzen:

```hemlock
// Benutzerdefinierten Handler registrieren
signal(SIGINT, my_handler);

// Sp√§ter, auf Standard zur√ºcksetzen (bei SIGINT beenden)
signal(SIGINT, null);
```

### Signale manuell ausl√∂sen

Signale an den eigenen Prozess senden:

```hemlock
let count = 0;

fn increment(sig) {
    count = count + 1;
}

signal(SIGUSR1, increment);

// Handler manuell ausl√∂sen
raise(SIGUSR1);
raise(SIGUSR1);

print(count);  // 2
```

## Fortgeschrittene Muster

### Graceful-Shutdown-Muster

H√§ufiges Muster f√ºr Bereinigung bei Beendigung:

```hemlock
let should_exit = false;

fn handle_shutdown(sig) {
    print("Fahre graceful herunter...");
    should_exit = true;
}

signal(SIGINT, handle_shutdown);
signal(SIGTERM, handle_shutdown);

// Hauptschleife
while (!should_exit) {
    // Arbeit erledigen...
    // should_exit-Flag regelm√§√üig pr√ºfen
}

print("Bereinigung abgeschlossen");
```

### Signal-Z√§hler

Anzahl empfangener Signale verfolgen:

```hemlock
let signal_count = 0;

fn count_signals(sig) {
    signal_count = signal_count + 1;
    print(typeof(signal_count) + " Signale empfangen");
}

signal(SIGUSR1, count_signals);

// Sp√§ter...
print("Gesamte Signale: " + typeof(signal_count));
```

### Konfiguration bei Signal neu laden

```hemlock
let config = load_config();

fn reload_config(sig) {
    print("Lade Konfiguration neu...");
    config = load_config();
    print("Konfiguration neu geladen");
}

signal(SIGHUP, reload_config);  // Bei SIGHUP neu laden

// SIGHUP an Prozess senden, um Konfiguration neu zu laden
// Von Shell: kill -HUP <pid>
```

### Timeout mit SIGALRM

```hemlock
let timed_out = false;

fn handle_alarm(sig) {
    print("Timeout!");
    timed_out = true;
}

signal(SIGALRM, handle_alarm);

// Alarm setzen (noch nicht in Hemlock implementiert, nur Beispiel)
// alarm(5);  // 5 Sekunden Timeout

while (!timed_out) {
    // Arbeit mit Timeout erledigen
}
```

### Signal-basierte Zustandsmaschine

```hemlock
let state = 0;

fn next_state(sig) {
    state = (state + 1) % 3;
    print("Zustand: " + typeof(state));
}

fn prev_state(sig) {
    state = (state - 1 + 3) % 3;
    print("Zustand: " + typeof(state));
}

signal(SIGUSR1, next_state);  // Zustand vorw√§rts
signal(SIGUSR2, prev_state);  // Zustand zur√ºck

// Zustandsmaschine steuern:
// kill -USR1 <pid>  # N√§chster Zustand
// kill -USR2 <pid>  # Vorheriger Zustand
```

## Signal-Handler-Verhalten

### Wichtige Hinweise

**Handler-Ausf√ºhrung:**
- Handler werden **synchron** aufgerufen, wenn das Signal empfangen wird
- Handler werden im aktuellen Prozesskontext ausgef√ºhrt
- Signal-Handler teilen die Closure-Umgebung der Funktion, in der sie definiert wurden
- Handler k√∂nnen auf √§u√üere Scope-Variablen zugreifen und diese modifizieren (wie Globals oder erfasste Variablen)

**Best Practices:**
- Handler einfach und schnell halten - lange Operationen vermeiden
- Flags setzen statt komplexe Logik auszuf√ºhren
- Funktionen vermeiden, die m√∂glicherweise Locks nehmen
- Bewusst sein, dass Handler jede Operation unterbrechen k√∂nnen

### Welche Signale abgefangen werden k√∂nnen

**Kann abfangen und behandeln:**
- SIGINT, SIGTERM, SIGUSR1, SIGUSR2, SIGHUP, SIGQUIT
- SIGALRM, SIGCHLD, SIGCONT, SIGTSTP
- SIGPIPE, SIGTTIN, SIGTTOU
- SIGABRT (aber Programm wird nach Handler-R√ºckkehr abbrechen)

**Kann nicht abfangen:**
- `SIGKILL` (9) - Beendet Prozess immer
- `SIGSTOP` (19) - Stoppt Prozess immer

**Systemabh√§ngig:**
- Einige Signale haben Standardverhalten, die je nach System unterschiedlich sein k√∂nnen
- Pr√ºfen Sie die Signal-Dokumentation Ihrer Plattform f√ºr Details

### Handler-Einschr√§nkungen

```hemlock
fn complex_handler(sig) {
    // Vermeiden Sie diese in Signal-Handlern:

    // ‚ùå Lang laufende Operationen
    // process_large_file();

    // ‚ùå Blockierende I/O
    // let f = open("log.txt", "a");
    // f.write("Signal empfangen\n");

    // ‚ùå Komplexe Zustands√§nderungen
    // rebuild_entire_data_structure();

    // ‚úÖ Einfaches Flag-Setzen ist sicher
    let should_stop = true;

    // ‚úÖ Einfache Z√§hler-Updates sind normalerweise sicher
    let signal_count = signal_count + 1;
}
```

## Sicherheits√ºberlegungen

Signalbehandlung ist in Hemlocks Philosophie **inh√§rent unsicher**.

### Race Conditions

Handler k√∂nnen jederzeit aufgerufen werden und normale Ausf√ºhrung unterbrechen:

```hemlock
let counter = 0;

fn increment(sig) {
    counter = counter + 1;  // Race Condition wenn w√§hrend counter-Update aufgerufen
}

signal(SIGUSR1, increment);

// Hauptcode modifiziert auch counter
counter = counter + 1;  // K√∂nnte von Signal-Handler unterbrochen werden
```

**Problem:** Wenn Signal ankommt w√§hrend Hauptcode `counter` aktualisiert, ist das Ergebnis unvorhersehbar.

### Async-Signal-Sicherheit

Hemlock garantiert **keine** Async-Signal-Sicherheit:
- Handler k√∂nnen jeden Hemlock-Code aufrufen (anders als Cs eingeschr√§nkte async-signal-sichere Funktionen)
- Dies bietet Flexibilit√§t, erfordert aber Benutzer-Vorsicht
- Race Conditions sind m√∂glich, wenn Handler gemeinsamen Zustand modifiziert

### Best Practices f√ºr sichere Signalbehandlung

**1. Atomare Flags verwenden**

Einfache Boolean-Zuweisungen sind im Allgemeinen sicher:

```hemlock
let should_exit = false;

fn handler(sig) {
    should_exit = true;  // Einfache Zuweisung ist sicher
}

signal(SIGINT, handler);

while (!should_exit) {
    // Arbeit...
}
```

**2. Gemeinsamen Zustand minimieren**

```hemlock
let interrupt_count = 0;

fn handler(sig) {
    // Nur diese eine Variable modifizieren
    interrupt_count = interrupt_count + 1;
}
```

**3. Komplexe Operationen aufschieben**

```hemlock
let pending_reload = false;

fn signal_reload(sig) {
    pending_reload = true;  // Nur Flag setzen
}

signal(SIGHUP, signal_reload);

// In Hauptschleife:
while (true) {
    if (pending_reload) {
        reload_config();  // Komplexe Arbeit hier erledigen
        pending_reload = false;
    }

    // Normale Arbeit...
}
```

**4. Wiedereintrittsprobleme vermeiden**

```hemlock
let in_critical_section = false;
let data = [];

fn careful_handler(sig) {
    if (in_critical_section) {
        // Daten nicht modifizieren w√§hrend Hauptcode sie verwendet
        return;
    }
    // Sicher fortzufahren
}
```

## H√§ufige Anwendungsf√§lle

### 1. Graceful Server-Shutdown

```hemlock
let running = true;

fn shutdown(sig) {
    print("Shutdown-Signal empfangen");
    running = false;
}

signal(SIGINT, shutdown);
signal(SIGTERM, shutdown);

// Server-Hauptschleife
while (running) {
    handle_client_request();
}

cleanup_resources();
print("Server gestoppt");
```

### 2. Konfiguration neu laden (ohne Neustart)

```hemlock
let config = load_config("app.conf");
let reload_needed = false;

fn trigger_reload(sig) {
    reload_needed = true;
}

signal(SIGHUP, trigger_reload);

while (true) {
    if (reload_needed) {
        print("Lade Konfiguration neu...");
        config = load_config("app.conf");
        reload_needed = false;
    }

    // config verwenden...
}
```

### 3. Log-Rotation

```hemlock
let log_file = open("app.log", "a");
let rotate_needed = false;

fn trigger_rotate(sig) {
    rotate_needed = true;
}

signal(SIGUSR1, trigger_rotate);

while (true) {
    if (rotate_needed) {
        log_file.close();
        // Altes Log umbenennen, neues √∂ffnen
        exec("mv app.log app.log.old");
        log_file = open("app.log", "a");
        rotate_needed = false;
    }

    // Normales Logging...
    log_file.write("Log-Eintrag\n");
}
```

### 4. Statusberichterstattung

```hemlock
let requests_handled = 0;

fn report_status(sig) {
    print("Status: " + typeof(requests_handled) + " Anfragen bearbeitet");
}

signal(SIGUSR1, report_status);

while (true) {
    handle_request();
    requests_handled = requests_handled + 1;
}

// Von Shell: kill -USR1 <pid>
```

### 5. Debug-Modus umschalten

```hemlock
let debug_mode = false;

fn toggle_debug(sig) {
    debug_mode = !debug_mode;
    if (debug_mode) {
        print("Debug-Modus: AN");
    } else {
        print("Debug-Modus: AUS");
    }
}

signal(SIGUSR2, toggle_debug);

// Von Shell: kill -USR2 <pid> zum Umschalten
```

## Vollst√§ndige Beispiele

### Beispiel 1: Unterbrechungs-Handler mit Bereinigung

```hemlock
let running = true;
let signal_count = 0;

fn handle_signal(signum) {
    signal_count = signal_count + 1;

    if (signum == SIGINT) {
        print("Unterbrechung erkannt (Strg+C)");
        running = false;
    }

    if (signum == SIGUSR1) {
        print("Benutzersignal 1 empfangen");
    }
}

// Handler registrieren
signal(SIGINT, handle_signal);
signal(SIGUSR1, handle_signal);

// Arbeit simulieren
let i = 0;
while (running && i < 100) {
    print("Arbeite... " + typeof(i));

    // SIGUSR1 alle 10 Iterationen ausl√∂sen
    if (i == 10 || i == 20) {
        raise(SIGUSR1);
    }

    i = i + 1;
}

print("Gesamte empfangene Signale: " + typeof(signal_count));
```

### Beispiel 2: Multi-Signal-Zustandsmaschine

```hemlock
let state = "idle";
let request_count = 0;

fn start_processing(sig) {
    state = "processing";
    print("Zustand: " + state);
}

fn stop_processing(sig) {
    state = "idle";
    print("Zustand: " + state);
}

fn report_stats(sig) {
    print("Zustand: " + state);
    print("Anfragen: " + typeof(request_count));
}

signal(SIGUSR1, start_processing);
signal(SIGUSR2, stop_processing);
signal(SIGHUP, report_stats);

while (true) {
    if (state == "processing") {
        // Arbeit erledigen
        request_count = request_count + 1;
    }

    // Bei jeder Iteration pr√ºfen...
}
```

### Beispiel 3: Worker-Pool-Controller

```hemlock
let worker_count = 4;
let should_exit = false;

fn increase_workers(sig) {
    worker_count = worker_count + 1;
    print("Worker: " + typeof(worker_count));
}

fn decrease_workers(sig) {
    if (worker_count > 1) {
        worker_count = worker_count - 1;
    }
    print("Worker: " + typeof(worker_count));
}

fn shutdown(sig) {
    print("Fahre herunter...");
    should_exit = true;
}

signal(SIGUSR1, increase_workers);
signal(SIGUSR2, decrease_workers);
signal(SIGINT, shutdown);
signal(SIGTERM, shutdown);

// Hauptschleife passt Worker-Pool basierend auf worker_count an
while (!should_exit) {
    // Worker basierend auf worker_count verwalten
    // ...
}
```

### Beispiel 4: Timeout-Muster

```hemlock
let operation_complete = false;
let timed_out = false;

fn timeout_handler(sig) {
    timed_out = true;
}

signal(SIGALRM, timeout_handler);

// Lange Operation starten
async fn long_operation() {
    // ... Arbeit
    operation_complete = true;
}

let task = spawn(long_operation);

// Mit Timeout warten (manuelle Pr√ºfung)
let elapsed = 0;
while (!operation_complete && elapsed < 1000) {
    // Schlafen oder pr√ºfen
    elapsed = elapsed + 1;
}

if (!operation_complete) {
    print("Operation hat Timeout erreicht");
    detach(task);  // Warten aufgeben
} else {
    join(task);
    print("Operation abgeschlossen");
}
```

## Signal-Handler debuggen

### Diagnose-Prints hinzuf√ºgen

```hemlock
fn debug_handler(sig) {
    print("Handler aufgerufen f√ºr Signal: " + typeof(sig));
    print("Stack: (noch nicht verf√ºgbar)");

    // Ihre Handler-Logik...
}

signal(SIGINT, debug_handler);
```

### Signal-Aufrufe z√§hlen

```hemlock
let handler_calls = 0;

fn counting_handler(sig) {
    handler_calls = handler_calls + 1;
    print("Handler-Aufruf #" + typeof(handler_calls));

    // Ihre Handler-Logik...
}
```

### Mit raise() testen

```hemlock
fn test_handler(sig) {
    print("Test-Signal empfangen: " + typeof(sig));
}

signal(SIGUSR1, test_handler);

// Durch manuelles Ausl√∂sen testen
raise(SIGUSR1);
print("Handler sollte aufgerufen worden sein");
```

## Zusammenfassung

Hemlocks Signalbehandlung bietet:

- ‚úÖ POSIX-Signalbehandlung f√ºr Low-Level-Prozesssteuerung
- ‚úÖ 15 Standard-Signal-Konstanten
- ‚úÖ Einfache signal()- und raise()-API
- ‚úÖ Flexible Handler-Funktionen mit Closure-Unterst√ºtzung
- ‚úÖ Mehrere Signale k√∂nnen Handler teilen

Denken Sie daran:
- Signalbehandlung ist inh√§rent unsicher - mit Vorsicht verwenden
- Handler einfach und schnell halten
- Flags f√ºr Zustands√§nderungen verwenden, nicht komplexe Operationen
- Handler k√∂nnen Ausf√ºhrung jederzeit unterbrechen
- SIGKILL oder SIGSTOP k√∂nnen nicht abgefangen werden
- Handler gr√ºndlich mit raise() testen

H√§ufige Muster:
- Graceful Shutdown (SIGINT, SIGTERM)
- Konfiguration neu laden (SIGHUP)
- Log-Rotation (SIGUSR1)
- Statusberichterstattung (SIGUSR1/SIGUSR2)
- Debug-Modus umschalten (SIGUSR2)



################################################################################
# API-REFERENZ
################################################################################

--------------------------------------------------------------------------------
## Array-API
--------------------------------------------------------------------------------

# Array-API-Referenz

Vollst√§ndige Referenz f√ºr Hemlocks Array-Typ und alle 18 Array-Methoden.

---

## √úbersicht

Arrays in Hemlock sind **dynamische, heap-allokierte** Sequenzen, die gemischte Typen enthalten k√∂nnen. Sie bieten umfassende Methoden zur Datenmanipulation und -verarbeitung.

**Hauptmerkmale:**
- Dynamische Gr√∂√üenanpassung (automatisches Wachstum)
- Nullbasierte Indizierung
- Gemischte Typen erlaubt
- 18 eingebaute Methoden
- Heap-allokiert mit Kapazitaetsverfolgung

---

## Array-Typ

**Typ:** `array`

**Eigenschaften:**
- `.length` - Anzahl der Elemente (i32)

**Literal-Syntax:** Eckige Klammern `[elem1, elem2, ...]`

**Beispiele:**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr.length);     // 5

// Gemischte Typen
let mixed = [1, "hello", true, null];
print(mixed.length);   // 4

// Leeres Array
let empty = [];
print(empty.length);   // 0
```

---

## Indizierung

Arrays unterst√ºtzen nullbasierte Indizierung mit `[]`:

**Lesezugriff:**
```hemlock
let arr = [10, 20, 30];
print(arr[0]);         // 10
print(arr[1]);         // 20
print(arr[2]);         // 30
```

**Schreibzugriff:**
```hemlock
let arr = [10, 20, 30];
arr[0] = 99;
arr[1] = 88;
print(arr);            // [99, 88, 30]
```

**Hinweis:** Direkter Indexzugriff hat keine Grenzenpr√ºfung. Verwenden Sie Methoden f√ºr Sicherheit.

---

## Array-Eigenschaften

### .length

Gibt die Anzahl der Elemente im Array zur√ºck.

**Typ:** `i32`

**Beispiele:**
```hemlock
let arr = [1, 2, 3];
print(arr.length);     // 3

let empty = [];
print(empty.length);   // 0

// L√§nge √§ndert sich dynamisch
arr.push(4);
print(arr.length);     // 4

arr.pop();
print(arr.length);     // 3
```

---

## Array-Methoden

### Stack-Operationen

#### push

Fuegt ein Element am Ende des Arrays hinzu.

**Signatur:**
```hemlock
array.push(value: any): null
```

**Parameter:**
- `value` - Element zum Hinzuf√ºgen

**R√ºckgabe:** `null`

**Mutiert:** Ja (modifiziert Array direkt)

**Beispiele:**
```hemlock
let arr = [1, 2, 3];
arr.push(4);           // [1, 2, 3, 4]
arr.push(5);           // [1, 2, 3, 4, 5]
arr.push("hello");     // [1, 2, 3, 4, 5, "hello"]
```

---

#### pop

Entfernt und gibt das letzte Element zur√ºck.

**Signatur:**
```hemlock
array.pop(): any
```

**R√ºckgabe:** Letztes Element (aus Array entfernt)

**Mutiert:** Ja (modifiziert Array direkt)

**Beispiele:**
```hemlock
let arr = [1, 2, 3];
let last = arr.pop();  // 3
print(arr);            // [1, 2]

let last2 = arr.pop(); // 2
print(arr);            // [1]
```

**Fehler:** Laufzeitfehler wenn Array leer ist.

---

### Warteschlangen-Operationen

#### shift

Entfernt und gibt das erste Element zur√ºck.

**Signatur:**
```hemlock
array.shift(): any
```

**R√ºckgabe:** Erstes Element (aus Array entfernt)

**Mutiert:** Ja (modifiziert Array direkt)

**Beispiele:**
```hemlock
let arr = [1, 2, 3];
let first = arr.shift();  // 1
print(arr);               // [2, 3]

let first2 = arr.shift(); // 2
print(arr);               // [3]
```

**Fehler:** Laufzeitfehler wenn Array leer ist.

---

#### unshift

Fuegt ein Element am Anfang des Arrays hinzu.

**Signatur:**
```hemlock
array.unshift(value: any): null
```

**Parameter:**
- `value` - Element zum Hinzuf√ºgen

**R√ºckgabe:** `null`

**Mutiert:** Ja (modifiziert Array direkt)

**Beispiele:**
```hemlock
let arr = [2, 3];
arr.unshift(1);        // [1, 2, 3]
arr.unshift(0);        // [0, 1, 2, 3]
```

---

### Einfuegen & Entfernen

#### insert

Fuegt ein Element an einem bestimmten Index ein.

**Signatur:**
```hemlock
array.insert(index: i32, value: any): null
```

**Parameter:**
- `index` - Position zum Einfuegen (nullbasiert)
- `value` - Element zum Einfuegen

**R√ºckgabe:** `null`

**Mutiert:** Ja (modifiziert Array direkt)

**Beispiele:**
```hemlock
let arr = [1, 2, 4, 5];
arr.insert(2, 3);      // [1, 2, 3, 4, 5]

let arr2 = [1, 3];
arr2.insert(1, 2);     // [1, 2, 3]

// Am Ende einf√ºgen
arr2.insert(arr2.length, 4);  // [1, 2, 3, 4]
```

**Verhalten:** Verschiebt Elemente ab dem Index nach rechts.

---

#### remove

Entfernt und gibt das Element am Index zur√ºck.

**Signatur:**
```hemlock
array.remove(index: i32): any
```

**Parameter:**
- `index` - Position zum Entfernen (nullbasiert)

**R√ºckgabe:** Entferntes Element

**Mutiert:** Ja (modifiziert Array direkt)

**Beispiele:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let removed = arr.remove(0);  // 1
print(arr);                   // [2, 3, 4, 5]

let removed2 = arr.remove(2); // 4
print(arr);                   // [2, 3, 5]
```

**Verhalten:** Verschiebt Elemente nach dem Index nach links.

**Fehler:** Laufzeitfehler wenn Index au√üerhalb der Grenzen.

---

### Suchen & Finden

#### find

Findet das erste Vorkommen eines Wertes.

**Signatur:**
```hemlock
array.find(value: any): i32
```

**Parameter:**
- `value` - Zu suchender Wert

**R√ºckgabe:** Index des ersten Vorkommens, oder `-1` wenn nicht gefunden

**Beispiele:**
```hemlock
let arr = [10, 20, 30, 40];
let idx = arr.find(30);      // 2
let idx2 = arr.find(99);     // -1 (nicht gefunden)

// Erstes Duplikat finden
let arr2 = [1, 2, 3, 2, 4];
let idx3 = arr2.find(2);     // 1 (erstes Vorkommen)
```

**Vergleich:** Verwendet Wertgleichheit f√ºr Primitive und Strings.

---

#### contains

Prueft ob das Array einen Wert enth√§lt.

**Signatur:**
```hemlock
array.contains(value: any): bool
```

**Parameter:**
- `value` - Zu suchender Wert

**R√ºckgabe:** `true` wenn gefunden, `false` sonst

**Beispiele:**
```hemlock
let arr = [10, 20, 30, 40];
let has = arr.contains(20);  // true
let has2 = arr.contains(99); // false

// Funktioniert mit Strings
let words = ["hello", "world"];
let has3 = words.contains("hello");  // true
```

---

### Slicing & Extraktion

#### slice

Extrahiert ein Teilarray nach Bereich (Ende exklusiv).

**Signatur:**
```hemlock
array.slice(start: i32, end: i32): array
```

**Parameter:**
- `start` - Startindex (nullbasiert, inklusiv)
- `end` - Endindex (exklusiv)

**R√ºckgabe:** Neues Array mit Elementen von [start, end)

**Mutiert:** Nein (gibt neues Array zur√ºck)

**Beispiele:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sub = arr.slice(1, 4);   // [2, 3, 4]
let first_three = arr.slice(0, 3);  // [1, 2, 3]
let last_two = arr.slice(3, 5);     // [4, 5]

// Leerer Slice
let empty = arr.slice(2, 2); // []
```

---

#### first

Gibt das erste Element zur√ºck ohne es zu entfernen.

**Signatur:**
```hemlock
array.first(): any
```

**R√ºckgabe:** Erstes Element

**Mutiert:** Nein

**Beispiele:**
```hemlock
let arr = [1, 2, 3];
let f = arr.first();         // 1
print(arr);                  // [1, 2, 3] (unver√§ndert)
```

**Fehler:** Laufzeitfehler wenn Array leer ist.

---

#### last

Gibt das letzte Element zur√ºck ohne es zu entfernen.

**Signatur:**
```hemlock
array.last(): any
```

**R√ºckgabe:** Letztes Element

**Mutiert:** Nein

**Beispiele:**
```hemlock
let arr = [1, 2, 3];
let l = arr.last();          // 3
print(arr);                  // [1, 2, 3] (unver√§ndert)
```

**Fehler:** Laufzeitfehler wenn Array leer ist.

---

### Array-Manipulation

#### reverse

Kehrt das Array an Ort und Stelle um.

**Signatur:**
```hemlock
array.reverse(): null
```

**R√ºckgabe:** `null`

**Mutiert:** Ja (modifiziert Array direkt)

**Beispiele:**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.reverse();               // [5, 4, 3, 2, 1]
print(arr);                  // [5, 4, 3, 2, 1]

let words = ["hello", "world"];
words.reverse();             // ["world", "hello"]
```

---

#### clear

Entfernt alle Elemente aus dem Array.

**Signatur:**
```hemlock
array.clear(): null
```

**R√ºckgabe:** `null`

**Mutiert:** Ja (modifiziert Array direkt)

**Beispiele:**
```hemlock
let arr = [1, 2, 3, 4, 5];
arr.clear();
print(arr);                  // []
print(arr.length);           // 0
```

---

### Array-Kombination

#### concat

Verkettet mit einem anderen Array.

**Signatur:**
```hemlock
array.concat(other: array): array
```

**Parameter:**
- `other` - Array zum Verketten

**R√ºckgabe:** Neues Array mit Elementen aus beiden Arrays

**Mutiert:** Nein (gibt neues Array zur√ºck)

**Beispiele:**
```hemlock
let a = [1, 2, 3];
let b = [4, 5, 6];
let combined = a.concat(b);  // [1, 2, 3, 4, 5, 6]
print(a);                    // [1, 2, 3] (unver√§ndert)
print(b);                    // [4, 5, 6] (unver√§ndert)

// Verkettungen verketten
let c = [7, 8];
let all = a.concat(b).concat(c);  // [1, 2, 3, 4, 5, 6, 7, 8]
```

---

### Funktionale Operationen

#### map

Transformiert jedes Element mit einer Callback-Funktion.

**Signatur:**
```hemlock
array.map(callback: fn): array
```

**Parameter:**
- `callback` - Funktion die ein Element nimmt und transformierten Wert zur√ºckgibt

**R√ºckgabe:** Neues Array mit transformierten Elementen

**Mutiert:** Nein (gibt neues Array zur√ºck)

**Beispiele:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let doubled = arr.map(fn(x) { return x * 2; });
print(doubled);  // [2, 4, 6, 8, 10]

let names = ["alice", "bob"];
let upper = names.map(fn(s) { return s.to_upper(); });
print(upper);  // ["ALICE", "BOB"]
```

---

#### filter

Waehlt Elemente aus die einem Praedikat entsprechen.

**Signatur:**
```hemlock
array.filter(predicate: fn): array
```

**Parameter:**
- `predicate` - Funktion die ein Element nimmt und bool zur√ºckgibt

**R√ºckgabe:** Neues Array mit Elementen wo Praedikat true zurueckgab

**Mutiert:** Nein (gibt neues Array zur√ºck)

**Beispiele:**
```hemlock
let arr = [1, 2, 3, 4, 5, 6];
let evens = arr.filter(fn(x) { return x % 2 == 0; });
print(evens);  // [2, 4, 6]

let words = ["hello", "hi", "hey", "goodbye"];
let short = words.filter(fn(s) { return s.length < 4; });
print(short);  // ["hi", "hey"]
```

---

#### reduce

Reduziert Array auf einen einzelnen Wert mit Akkumulator.

**Signatur:**
```hemlock
array.reduce(callback: fn, initial: any): any
```

**Parameter:**
- `callback` - Funktion die (Akkumulator, Element) nimmt und neuen Akkumulator zur√ºckgibt
- `initial` - Startwert f√ºr den Akkumulator

**R√ºckgabe:** Endgueltiger akkumulierter Wert

**Mutiert:** Nein

**Beispiele:**
```hemlock
let arr = [1, 2, 3, 4, 5];
let sum = arr.reduce(fn(acc, x) { return acc + x; }, 0);
print(sum);  // 15

let product = arr.reduce(fn(acc, x) { return acc * x; }, 1);
print(product);  // 120

// Maximalwert finden
let max = arr.reduce(fn(acc, x) {
    if (x > acc) { return x; }
    return acc;
}, arr[0]);
print(max);  // 5
```

---

### String-Konvertierung

#### join

Verbindet Elemente zu einem String mit Trennzeichen.

**Signatur:**
```hemlock
array.join(delimiter: string): string
```

**Parameter:**
- `delimiter` - String der zwischen Elementen platziert wird

**R√ºckgabe:** String mit allen verbundenen Elementen

**Beispiele:**
```hemlock
let words = ["hello", "world", "foo"];
let joined = words.join(" ");  // "hello world foo"

let numbers = [1, 2, 3];
let csv = numbers.join(",");   // "1,2,3"

// Funktioniert mit gemischten Typen
let mixed = [1, "hello", true, null];
print(mixed.join(" | "));  // "1 | hello | true | null"

// Leeres Trennzeichen
let arr = ["a", "b", "c"];
let s = arr.join("");          // "abc"
```

**Verhalten:** Konvertiert automatisch alle Elemente zu Strings.

---

## Methoden-Verkettung

Array-Methoden k√∂nnen f√ºr praegnante Operationen verkettet werden:

**Beispiele:**
```hemlock
// slice und join verketten
let result = ["apple", "banana", "cherry", "date"]
    .slice(0, 2)
    .join(" and ");  // "apple and banana"

// concat und slice verketten
let combined = [1, 2, 3]
    .concat([4, 5, 6])
    .slice(2, 5);    // [3, 4, 5]

// Komplexe Verkettung
let words = ["hello", "world", "foo", "bar"];
let result2 = words
    .slice(0, 3)
    .concat(["baz"])
    .join("-");      // "hello-world-foo-baz"
```

---

## Vollst√§ndige Methodenuebersicht

### Mutierende Methoden

Methoden die das Array direkt modifizieren:

| Methode    | Signatur                   | R√ºckgabe | Beschreibung                   |
|------------|----------------------------|-----------|--------------------------------|
| `push`     | `(value: any)`             | `null`    | Am Ende hinzuf√ºgen            |
| `pop`      | `()`                       | `any`     | Vom Ende entfernen             |
| `shift`    | `()`                       | `any`     | Vom Anfang entfernen           |
| `unshift`  | `(value: any)`             | `null`    | Am Anfang hinzuf√ºgen          |
| `insert`   | `(index: i32, value: any)` | `null`    | An Index einf√ºgen             |
| `remove`   | `(index: i32)`             | `any`     | An Index entfernen             |
| `reverse`  | `()`                       | `null`    | An Ort und Stelle umkehren     |
| `clear`    | `()`                       | `null`    | Alle Elemente entfernen        |

### Nicht-mutierende Methoden

Methoden die neue Werte zur√ºckgeben ohne das Original zu modifizieren:

| Methode    | Signatur                   | R√ºckgabe | Beschreibung                   |
|------------|----------------------------|-----------|--------------------------------|
| `find`     | `(value: any)`             | `i32`     | Erstes Vorkommen finden        |
| `contains` | `(value: any)`             | `bool`    | Pr√ºfen ob Wert enthalten      |
| `slice`    | `(start: i32, end: i32)`   | `array`   | Teilarray extrahieren          |
| `first`    | `()`                       | `any`     | Erstes Element holen           |
| `last`     | `()`                       | `any`     | Letztes Element holen          |
| `concat`   | `(other: array)`           | `array`   | Arrays verketten               |
| `join`     | `(delimiter: string)`      | `string`  | Elemente zu String verbinden   |
| `map`      | `(callback: fn)`           | `array`   | Jedes Element transformieren   |
| `filter`   | `(predicate: fn)`          | `array`   | Passende Elemente ausw√§hlen   |
| `reduce`   | `(callback: fn, initial: any)` | `any` | Auf einzelnen Wert reduzieren  |

---

## Verwendungsmuster

### Stack-Verwendung

```hemlock
let stack = [];

// Elemente pushen
stack.push(1);
stack.push(2);
stack.push(3);

// Elemente poppen
while (stack.length > 0) {
    let item = stack.pop();
    print(item);  // 3, 2, 1
}
```

### Warteschlangen-Verwendung

```hemlock
let queue = [];

// Einreihen
queue.push(1);
queue.push(2);
queue.push(3);

// Ausreihen
while (queue.length > 0) {
    let item = queue.shift();
    print(item);  // 1, 2, 3
}
```

### Array-Transformation

```hemlock
// Filtern (manuell)
let numbers = [1, 2, 3, 4, 5, 6];
let evens = [];
let i = 0;
while (i < numbers.length) {
    if (numbers[i] % 2 == 0) {
        evens.push(numbers[i]);
    }
    i = i + 1;
}

// Abbilden (manuell)
let numbers2 = [1, 2, 3, 4, 5];
let doubled = [];
let j = 0;
while (j < numbers2.length) {
    doubled.push(numbers2[j] * 2);
    j = j + 1;
}
```

### Arrays aufbauen

```hemlock
let arr = [];

// Array mit Schleife aufbauen
let i = 0;
while (i < 10) {
    arr.push(i * 10);
    i = i + 1;
}

print(arr);  // [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
```

---

## Implementierungsdetails

**Kapazit√§tsverwaltung:**
- Arrays wachsen automatisch bei Bedarf
- Kapazit√§t verdoppelt sich bei √úberschreitung
- Keine manuelle Kapazitaetssteuerung

**Wertvergleich:**
- `find()` und `contains()` verwenden Wertgleichheit
- Funktioniert korrekt f√ºr Primitive und Strings
- Objekte/Arrays werden per Referenz verglichen

**Speicher:**
- Heap-allokiert
- Keine automatische Freigabe (manuelle Speicherverwaltung)
- Keine Grenzenpr√ºfung bei direktem Indexzugriff

---

## Siehe auch

- [Typsystem](#reference-type-system) - Array-Typ-Details
- [String-API](#reference-string-api) - String join()-Ergebnisse
- [Operatoren](#reference-operators) - Array-Indizierungsoperator


--------------------------------------------------------------------------------
## Datei-API
--------------------------------------------------------------------------------

# Datei-API-Referenz

Vollst√§ndige Referenz f√ºr Hemlocks Datei-I/O-System.

---

## √úbersicht

Hemlock bietet eine **Dateiobjekt-API** f√ºr Dateioperationen mit ordnungsgemaesser Fehlerbehandlung und Ressourcenverwaltung. Dateien m√ºssen manuell ge√∂ffnet und geschlossen werden.

**Hauptmerkmale:**
- Dateiobjekt mit Methoden
- Text- und Binaerdaten lesen/schreiben
- Positionierung und Suchen
- Ordnungsgemaesse Fehlermeldungen
- Manuelle Ressourcenverwaltung (kein RAII)

---

## Datei-Typ

**Typ:** `file`

**Beschreibung:** Dateihandle f√ºr I/O-Operationen

**Eigenschaften (Nur-Lesen):**
- `.path` - Dateipfad (string)
- `.mode` - Oeffnungsmodus (string)
- `.closed` - Ob Datei geschlossen (bool)

---

## Dateien √∂ffnen

### open

Oeffnet eine Datei zum Lesen, Schreiben oder beides.

**Signatur:**
```hemlock
open(path: string, mode?: string): file
```

**Parameter:**
- `path` - Dateipfad (relativ oder absolut)
- `mode` (optional) - Oeffnungsmodus (Standard: `"r"`)

**R√ºckgabe:** Dateiobjekt

**Modi:**
- `"r"` - Lesen (Standard)
- `"w"` - Schreiben (bestehende Datei abschneiden)
- `"a"` - Anhaengen
- `"r+"` - Lesen und Schreiben
- `"w+"` - Lesen und Schreiben (abschneiden)
- `"a+"` - Lesen und Anhaengen

**Beispiele:**
```hemlock
// Lesemodus (Standard)
let f = open("data.txt");
let f_read = open("data.txt", "r");

// Schreibmodus (abschneiden)
let f_write = open("output.txt", "w");

// Anhaengemodus
let f_append = open("log.txt", "a");

// Lesen/Schreiben-Modus
let f_rw = open("data.bin", "r+");

// Lesen/Schreiben (abschneiden)
let f_rw_trunc = open("output.bin", "w+");

// Lesen/Anhaengen
let f_ra = open("log.txt", "a+");
```

**Fehlerbehandlung:**
```hemlock
try {
    let f = open("missing.txt", "r");
} catch (e) {
    print("√ñffnen fehlgeschlagen:", e);
    // Fehler: Konnte 'missing.txt' nicht √∂ffnen: Datei oder Verzeichnis nicht gefunden
}
```

**Wichtig:** Dateien m√ºssen manuell mit `f.close()` geschlossen werden um Dateideskriptor-Lecks zu vermeiden.

---

## Datei-Methoden

### Lesen

#### read

Liest Text aus Datei.

**Signatur:**
```hemlock
file.read(size?: i32): string
```

**Parameter:**
- `size` (optional) - Anzahl der zu lesenden Bytes (wenn weggelassen, bis EOF lesen)

**R√ºckgabe:** String mit Dateiinhalt

**Beispiele:**
```hemlock
let f = open("data.txt", "r");

// Gesamte Datei lesen
let all = f.read();
print(all);

// Bestimmte Anzahl Bytes lesen
let chunk = f.read(1024);

f.close();
```

**Verhalten:**
- Liest ab aktueller Dateiposition
- Gibt leeren String bei EOF zur√ºck
- Bewegt Dateiposition vorw√§rts

**Fehler:**
- Lesen aus geschlossener Datei
- Lesen aus Nur-Schreiben-Datei

---

#### read_bytes

Liest Binaerdaten aus Datei.

**Signatur:**
```hemlock
file.read_bytes(size: i32): buffer
```

**Parameter:**
- `size` - Anzahl der zu lesenden Bytes

**R√ºckgabe:** Buffer mit Binaerdaten

**Beispiele:**
```hemlock
let f = open("data.bin", "r");

// 256 Bytes lesen
let binary = f.read_bytes(256);
print(binary.length);       // 256

// Binaerdaten verarbeiten
let i = 0;
while (i < binary.length) {
    print(binary[i]);
    i = i + 1;
}

f.close();
```

**Verhalten:**
- Liest exakte Anzahl Bytes
- Gibt Buffer zur√ºck (kein String)
- Bewegt Dateiposition vorw√§rts

---

### Schreiben

#### write

Schreibt Text in Datei.

**Signatur:**
```hemlock
file.write(data: string): i32
```

**Parameter:**
- `data` - Zu schreibender String

**R√ºckgabe:** Anzahl geschriebener Bytes (i32)

**Beispiele:**
```hemlock
let f = open("output.txt", "w");

// Text schreiben
let written = f.write("Hello, World!\n");
print("Geschrieben", written, "Bytes");

// Mehrere Schreibvorgaenge
f.write("Zeile 1\n");
f.write("Zeile 2\n");
f.write("Zeile 3\n");

f.close();
```

**Verhalten:**
- Schreibt an aktueller Dateiposition
- Gibt Anzahl geschriebener Bytes zur√ºck
- Bewegt Dateiposition vorw√§rts

**Fehler:**
- Schreiben in geschlossene Datei
- Schreiben in Nur-Lesen-Datei

---

#### write_bytes

Schreibt Binaerdaten in Datei.

**Signatur:**
```hemlock
file.write_bytes(data: buffer): i32
```

**Parameter:**
- `data` - Zu schreibender Buffer

**R√ºckgabe:** Anzahl geschriebener Bytes (i32)

**Beispiele:**
```hemlock
let f = open("output.bin", "w");

// Buffer erstellen
let buf = buffer(10);
buf[0] = 65;  // 'A'
buf[1] = 66;  // 'B'
buf[2] = 67;  // 'C'

// Buffer schreiben
let written = f.write_bytes(buf);
print("Geschrieben", written, "Bytes");

f.close();
```

**Verhalten:**
- Schreibt Buffer-Inhalt in Datei
- Gibt Anzahl geschriebener Bytes zur√ºck
- Bewegt Dateiposition vorw√§rts

---

### Positionieren

#### seek

Bewegt Dateiposition zu bestimmtem Byte-Offset.

**Signatur:**
```hemlock
file.seek(position: i32): i32
```

**Parameter:**
- `position` - Byte-Offset vom Dateianfang

**R√ºckgabe:** Neue Dateiposition (i32)

**Beispiele:**
```hemlock
let f = open("data.txt", "r");

// Zu Byte 100 springen
f.seek(100);

// Von dieser Position lesen
let chunk = f.read(50);

// Zum Anfang zur√ºcksetzen
f.seek(0);

// Vom Anfang lesen
let all = f.read();

f.close();
```

**Verhalten:**
- Setzt Dateiposition auf absoluten Offset
- Gibt neue Position zur√ºck
- Suchen hinter EOF ist erlaubt (erzeugt Loch in Datei beim Schreiben)

---

#### tell

Gibt aktuelle Dateiposition zur√ºck.

**Signatur:**
```hemlock
file.tell(): i32
```

**R√ºckgabe:** Aktueller Byte-Offset vom Dateianfang (i32)

**Beispiele:**
```hemlock
let f = open("data.txt", "r");

print(f.tell());        // 0 (am Anfang)

f.read(100);
print(f.tell());        // 100 (nach Lesen)

f.seek(50);
print(f.tell());        // 50 (nach Suchen)

f.close();
```

---

### Schlie√üen

#### close

Schliesst Datei (idempotent).

**Signatur:**
```hemlock
file.close(): null
```

**R√ºckgabe:** `null`

**Beispiele:**
```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();

// Sicher mehrmals aufzurufen
f.close();  // Kein Fehler
f.close();  // Kein Fehler
```

**Verhalten:**
- Schliesst Dateihandle
- Leert ausstehende Schreibvorgaenge
- Idempotent (sicher mehrmals aufzurufen)
- Setzt `.closed`-Eigenschaft auf `true`

**Wichtig:** Schlie√üen Sie Dateien immer wenn fertig um Dateideskriptor-Lecks zu vermeiden.

---

## Datei-Eigenschaften

### .path

Gibt Dateipfad zur√ºck.

**Typ:** `string`

**Zugriff:** Nur-Lesen

**Beispiele:**
```hemlock
let f = open("/path/to/file.txt", "r");
print(f.path);          // "/path/to/file.txt"
f.close();
```

---

### .mode

Gibt Oeffnungsmodus zur√ºck.

**Typ:** `string`

**Zugriff:** Nur-Lesen

**Beispiele:**
```hemlock
let f = open("data.txt", "r");
print(f.mode);          // "r"
f.close();

let f2 = open("output.txt", "w");
print(f2.mode);         // "w"
f2.close();
```

---

### .closed

Prueft ob Datei geschlossen ist.

**Typ:** `bool`

**Zugriff:** Nur-Lesen

**Beispiele:**
```hemlock
let f = open("data.txt", "r");
print(f.closed);        // false

f.close();
print(f.closed);        // true
```

---

## Fehlerbehandlung

Alle Dateioperationen enthalten ordnungsgemaesse Fehlermeldungen mit Kontext:

### Datei nicht gefunden
```hemlock
let f = open("missing.txt", "r");
// Fehler: Konnte 'missing.txt' nicht √∂ffnen: Datei oder Verzeichnis nicht gefunden
```

### Lesen aus geschlossener Datei
```hemlock
let f = open("data.txt", "r");
f.close();
f.read();
// Fehler: Kann nicht aus geschlossener Datei 'data.txt' lesen
```

### Schreiben in Nur-Lesen-Datei
```hemlock
let f = open("readonly.txt", "r");
f.write("data");
// Fehler: Kann nicht in Datei 'readonly.txt' schreiben, die im Nur-Lesen-Modus ge√∂ffnet wurde
```

### Mit try/catch
```hemlock
let f = null;
try {
    f = open("data.txt", "r");
    let content = f.read();
    print(content);
} catch (e) {
    print("Dateifehler:", e);
} finally {
    if (f != null && !f.closed) {
        f.close();
    }
}
```

---

## Ressourcenverwaltungsmuster

### Grundmuster

```hemlock
let f = open("data.txt", "r");
let content = f.read();
f.close();
```

### Mit Fehlerbehandlung

```hemlock
let f = open("data.txt", "r");
try {
    let content = f.read();
    process(content);
} finally {
    f.close();  // Immer schlie√üen, auch bei Fehler
}
```

### Sicheres Muster

```hemlock
let f = null;
try {
    f = open("data.txt", "r");
    let content = f.read();
    // ... Inhalt verarbeiten ...
} catch (e) {
    print("Fehler:", e);
} finally {
    if (f != null && !f.closed) {
        f.close();
    }
}
```

---

## Verwendungsbeispiele

### Gesamte Datei lesen

```hemlock
fn read_file(filename: string): string {
    let f = open(filename, "r");
    let content = f.read();
    f.close();
    return content;
}

let text = read_file("data.txt");
print(text);
```

### Textdatei schreiben

```hemlock
fn write_file(filename: string, content: string) {
    let f = open(filename, "w");
    f.write(content);
    f.close();
}

write_file("output.txt", "Hello, World!\n");
```

### An Datei anhaengen

```hemlock
fn append_file(filename: string, line: string) {
    let f = open(filename, "a");
    f.write(line + "\n");
    f.close();
}

append_file("log.txt", "Log-Eintrag 1");
append_file("log.txt", "Log-Eintrag 2");
```

### Binaerdatei lesen

```hemlock
fn read_binary(filename: string, size: i32): buffer {
    let f = open(filename, "r");
    let data = f.read_bytes(size);
    f.close();
    return data;
}

let binary = read_binary("data.bin", 256);
print("Gelesen", binary.length, "Bytes");
```

### Binaerdatei schreiben

```hemlock
fn write_binary(filename: string, data: buffer) {
    let f = open(filename, "w");
    f.write_bytes(data);
    f.close();
}

let buf = buffer(10);
buf[0] = 65;
write_binary("output.bin", buf);
```

### Datei Zeile f√ºr Zeile lesen

```hemlock
fn read_lines(filename: string): array {
    let f = open(filename, "r");
    let content = f.read();
    f.close();
    return content.split("\n");
}

let lines = read_lines("data.txt");
let i = 0;
while (i < lines.length) {
    print("Zeile", i, ":", lines[i]);
    i = i + 1;
}
```

### Datei kopieren

```hemlock
fn copy_file(src: string, dest: string) {
    let f_in = open(src, "r");
    let f_out = open(dest, "w");

    let content = f_in.read();
    f_out.write(content);

    f_in.close();
    f_out.close();
}

copy_file("input.txt", "output.txt");
```

### Datei in Stuecken lesen

```hemlock
fn process_chunks(filename: string) {
    let f = open(filename, "r");

    while (true) {
        let chunk = f.read(1024);  // 1KB auf einmal lesen
        if (chunk.length == 0) {
            break;  // EOF
        }

        // St√ºck verarbeiten
        print("Verarbeite", chunk.length, "Bytes");
    }

    f.close();
}

process_chunks("large_file.txt");
```

---

## Vollst√§ndige Methodenuebersicht

| Methode       | Signatur                 | R√ºckgabe | Beschreibung                 |
|---------------|--------------------------|-----------|------------------------------|
| `read`        | `(size?: i32)`           | `string`  | Text lesen                   |
| `read_bytes`  | `(size: i32)`            | `buffer`  | Binaerdaten lesen            |
| `write`       | `(data: string)`         | `i32`     | Text schreiben               |
| `write_bytes` | `(data: buffer)`         | `i32`     | Binaerdaten schreiben        |
| `seek`        | `(position: i32)`        | `i32`     | Dateiposition setzen         |
| `tell`        | `()`                     | `i32`     | Dateiposition holen          |
| `close`       | `()`                     | `null`    | Datei schlie√üen (idempotent)|

---

## Vollst√§ndige Eigenschaftsuebersicht

| Eigenschaft | Typ      | Zugriff    | Beschreibung             |
|-------------|----------|------------|--------------------------|
| `.path`     | `string` | Nur-Lesen  | Dateipfad                |
| `.mode`     | `string` | Nur-Lesen  | Oeffnungsmodus           |
| `.closed`   | `bool`   | Nur-Lesen  | Ob Datei geschlossen     |

---

## Migration von alter API

**Alte API (Entfernt):**
- `read_file(path)` - Verwenden Sie `open(path, "r").read()`
- `write_file(path, data)` - Verwenden Sie `open(path, "w").write(data)`
- `append_file(path, data)` - Verwenden Sie `open(path, "a").write(data)`
- `file_exists(path)` - Noch kein Ersatz

**Migrationsbeispiel:**
```hemlock
// Alt (v0.0)
let content = read_file("data.txt");
write_file("output.txt", content);

// Neu (v0.1)
let f = open("data.txt", "r");
let content = f.read();
f.close();

let f2 = open("output.txt", "w");
f2.write(content);
f2.close();
```

---

## Siehe auch

- [Eingebaute Funktionen](#reference-builtins) - `open()`-Funktion
- [Speicher-API](#reference-memory-api) - Buffer-Typ
- [String-API](#reference-string-api) - String-Methoden zur Textverarbeitung


--------------------------------------------------------------------------------
## Eingebaute Funktionen
--------------------------------------------------------------------------------

# Eingebaute Funktionen Referenz

Vollst√§ndige Referenz f√ºr alle eingebauten Funktionen und Konstanten in Hemlock.

---

## √úbersicht

Hemlock bietet eine Reihe von eingebauten Funktionen f√ºr I/O, Typ-Introspektion, Speicherverwaltung, Nebenl√§ufigkeit und Systeminteraktion. Alle eingebauten Funktionen sind global verf√ºgbar ohne Imports.

---

## I/O-Funktionen

### print

Gibt Werte auf stdout mit Zeilenumbruch aus.

**Signatur:**
```hemlock
print(...values): null
```

**Parameter:**
- `...values` - Beliebige Anzahl von Werten zum Ausgeben

**R√ºckgabe:** `null`

**Beispiele:**
```hemlock
print("Hello, World!");
print(42);
print(3.14);
print(true);
print([1, 2, 3]);
print({ x: 10, y: 20 });

// Mehrere Werte
print("x =", 10, "y =", 20);
```

**Verhalten:**
- Konvertiert alle Werte zu Strings
- Trennt mehrere Werte mit Leerzeichen
- Fuegt Zeilenumbruch am Ende hinzu
- Leert stdout

---

### read_line

Liest eine Zeile Text von stdin (Benutzereingabe).

**Signatur:**
```hemlock
read_line(): string | null
```

**Parameter:** Keine

**R√ºckgabe:**
- `string` - Die von stdin gelesene Zeile (Zeilenumbruch entfernt)
- `null` - Bei EOF (Ende der Datei/Eingabe)

**Beispiele:**
```hemlock
// Einfache Eingabeaufforderung
print("Wie ist dein Name?");
let name = read_line();
print("Hallo, " + name + "!");

// Zahlen lesen (erfordert manuelles Parsen)
print("Gib eine Zahl ein:");
let input = read_line();
let num = parse_int(input);  // Siehe unten f√ºr parse_int
print("Das Doppelte:", num * 2);

// EOF behandeln
let line = read_line();
if (line == null) {
    print("Ende der Eingabe");
}

// Mehrere Zeilen lesen
print("Gib Zeilen ein (Strg+D zum Beenden):");
while (true) {
    let line = read_line();
    if (line == null) {
        break;
    }
    print("Du sagtest:", line);
}
```

**Verhalten:**
- Blockiert bis Benutzer Enter drueckt
- Entfernt nachfolgenden Zeilenumbruch (`\n`) und Wagenruecklauf (`\r`)
- Gibt `null` bei EOF zur√ºck (Strg+D auf Unix, Strg+Z auf Windows)
- Liest nur von stdin (nicht von Dateien)

**Benutzereingabe parsen:**

Da `read_line()` immer einen String zur√ºckgibt, m√ºssen Sie numerische Eingaben manuell parsen:

```hemlock
// Einfacher Integer-Parser
fn parse_int(s: string): i32 {
    let result: i32 = 0;
    let negative = false;
    let i = 0;

    if (s.length > 0 && s.char_at(0) == '-') {
        negative = true;
        i = 1;
    }

    while (i < s.length) {
        let c = s.char_at(i);
        let code: i32 = c;
        if (code >= 48 && code <= 57) {
            result = result * 10 + (code - 48);
        } else {
            break;
        }
        i = i + 1;
    }

    if (negative) {
        return -result;
    }
    return result;
}

// Verwendung
print("Gib dein Alter ein:");
let age = parse_int(read_line());
print("In 10 Jahren wirst du", age + 10, "sein");
```

**Siehe auch:** [Datei-API](#reference-file-api) zum Lesen aus Dateien

---

### eprint

Gibt einen Wert auf stderr mit Zeilenumbruch aus.

**Signatur:**
```hemlock
eprint(value: any): null
```

**Parameter:**
- `value` - Einzelner Wert zum Ausgeben auf stderr

**R√ºckgabe:** `null`

**Beispiele:**
```hemlock
eprint("Fehler: Datei nicht gefunden");
eprint(404);
eprint("Warnung: " + message);

// Typisches Fehlerbehandlungsmuster
fn load_config(path: string) {
    if (!exists(path)) {
        eprint("Fehler: Konfigurationsdatei nicht gefunden: " + path);
        return null;
    }
    // ...
}
```

**Verhalten:**
- Gibt auf stderr aus (Standardfehlerausgabe)
- Fuegt Zeilenumbruch am Ende hinzu
- Akzeptiert nur ein Argument (anders als `print`)
- N√ºtzlich f√ºr Fehlermeldungen die sich nicht mit normaler Ausgabe vermischen sollen

**Unterschied zu print:**
- `print()` ‚Üí stdout (normale Ausgabe, kann mit `>` umgeleitet werden)
- `eprint()` ‚Üí stderr (Fehlerausgabe, kann mit `2>` umgeleitet werden)

```bash
# Shell-Beispiel: stdout und stderr trennen
./hemlock script.hml > output.txt 2> errors.txt
```

---

## Typ-Introspektion

### typeof

Gibt den Typnamen eines Wertes zur√ºck.

**Signatur:**
```hemlock
typeof(value: any): string
```

**Parameter:**
- `value` - Beliebiger Wert

**R√ºckgabe:** Typname als String

**Beispiele:**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("hello"));         // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof(null));            // "null"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"

// Typisierte Objekte
define Person { name: string }
let p: Person = { name: "Alice" };
print(typeof(p));               // "Person"

// Andere Typen
print(typeof(alloc(10)));       // "ptr"
print(typeof(buffer(10)));      // "buffer"
print(typeof(open("file.txt"))); // "file"
```

**Typnamen:**
- Primitive: `"i8"`, `"i16"`, `"i32"`, `"i64"`, `"u8"`, `"u16"`, `"u32"`, `"u64"`, `"f32"`, `"f64"`, `"bool"`, `"string"`, `"rune"`, `"null"`
- Zusammengesetzt: `"array"`, `"object"`, `"ptr"`, `"buffer"`, `"function"`
- Speziell: `"file"`, `"task"`, `"channel"`
- Benutzerdefiniert: Benutzerdefinierte Typnamen aus `define`

**Siehe auch:** [Typsystem](#reference-type-system)

---

## Befehlsausfuehrung

### exec

Fuehrt Shell-Befehl aus und erfasst Ausgabe.

**Signatur:**
```hemlock
exec(command: string): object
```

**Parameter:**
- `command` - Auszufuehrender Shell-Befehl

**R√ºckgabe:** Objekt mit Feldern:
- `output` (string) - stdout des Befehls
- `exit_code` (i32) - Exit-Statuscode (0 = Erfolg)

**Beispiele:**
```hemlock
let result = exec("echo hello");
print(result.output);      // "hello\n"
print(result.exit_code);   // 0

// Exit-Status pr√ºfen
let r = exec("grep pattern file.txt");
if (r.exit_code == 0) {
    print("Gefunden:", r.output);
} else {
    print("Muster nicht gefunden");
}

// Mehrzeilige Ausgabe verarbeiten
let r2 = exec("ls -la");
let lines = r2.output.split("\n");
```

**Verhalten:**
- Fuehrt Befehl √ºber `/bin/sh` aus
- Erfasst nur stdout (stderr geht zum Terminal)
- Blockiert bis Befehl abgeschlossen ist
- Gibt leeren String zur√ºck wenn keine Ausgabe

**Fehlerbehandlung:**
```hemlock
try {
    let r = exec("nonexistent_command");
} catch (e) {
    print("Ausf√ºhrung fehlgeschlagen:", e);
}
```

**Sicherheitswarnung:** Anfaellig f√ºr Shell-Injection. Validieren/bereinigen Sie immer Benutzereingaben.

**Einschr√§nkungen:**
- Keine stderr-Erfassung
- Kein Streaming
- Kein Timeout
- Keine Signalbehandlung

---

### exec_argv

Fuehrt einen Befehl mit explizitem Argument-Array aus (keine Shell-Interpretation).

**Signatur:**
```hemlock
exec_argv(argv: array): object
```

**Parameter:**
- `argv` - Array von Strings: `[befehl, arg1, arg2, ...]`

**R√ºckgabe:** Objekt mit Feldern:
- `output` (string) - stdout des Befehls
- `exit_code` (i32) - Exit-Statuscode (0 = Erfolg)

**Beispiele:**
```hemlock
// Einfacher Befehl
let result = exec_argv(["ls", "-la"]);
print(result.output);

// Befehl mit Argumenten die Leerzeichen enthalten (sicher!)
let r = exec_argv(["grep", "hello world", "file.txt"]);

// Skript mit Argumenten ausf√ºhren
let r2 = exec_argv(["python", "script.py", "--input", "data.json"]);
print(r2.exit_code);
```

**Unterschied zu exec:**
```hemlock
// exec() verwendet Shell - UNSICHER mit Benutzereingaben
exec("ls " + user_input);  // Shell-Injection-Risiko!

// exec_argv() umgeht Shell - SICHER
exec_argv(["ls", user_input]);  // Keine Injection m√∂glich
```

**Wann verwenden:**
- Wenn Argumente Leerzeichen, Anf√ºhrungszeichen oder Sonderzeichen enthalten
- Bei Verarbeitung von Benutzereingaben (Sicherheit)
- Wenn vorhersagbares Argument-Parsing ben√∂tigt wird

**Siehe auch:** `exec()` f√ºr einfache Shell-Befehle

---

## Fehlerbehandlung

### throw

Wirft eine Ausnahme.

**Signatur:**
```hemlock
throw expression
```

**Parameter:**
- `expression` - Zu werfender Wert (beliebiger Typ)

**R√ºckgabe:** Gibt nie zur√ºck (√ºbertr√§gt Kontrolle)

**Beispiele:**
```hemlock
throw "Fehlermeldung";
throw 404;
throw { code: 500, message: "Interner Fehler" };
throw null;
```

**Siehe auch:** try/catch/finally-Anweisungen

---

### panic

Beendet Programm sofort mit Fehlermeldung (nicht wiederherstellbar).

**Signatur:**
```hemlock
panic(message?: any): never
```

**Parameter:**
- `message` (optional) - Auszugebende Fehlermeldung

**R√ºckgabe:** Gibt nie zur√ºck (Programm beendet sich)

**Beispiele:**
```hemlock
panic();                          // Standard: "panic!"
panic("Unerreichbarer Code erreicht");
panic(42);

// Haeufiger Anwendungsfall
fn process_state(state: i32): string {
    if (state == 1) { return "bereit"; }
    if (state == 2) { return "l√§uft"; }
    panic("Ungueltiger Status: " + typeof(state));
}
```

**Verhalten:**
- Gibt Fehler auf stderr aus: `panic: <message>`
- Beendet mit Code 1
- **NICHT abfangbar** mit try/catch
- Verwenden f√ºr Bugs und nicht wiederherstellbare Fehler

**Panic vs Throw:**
- `panic()` - Nicht wiederherstellbarer Fehler, beendet sofort
- `throw` - Wiederherstellbarer Fehler, kann abgefangen werden

---

### assert

Stellt sicher dass eine Bedingung wahr ist, oder beendet mit Fehlermeldung.

**Signatur:**
```hemlock
assert(condition: any, message?: string): null
```

**Parameter:**
- `condition` - Auf Wahrheit zu pruefender Wert
- `message` (optional) - Benutzerdefinierte Fehlermeldung bei fehlgeschlagener Pr√ºfung

**R√ºckgabe:** `null` (wenn Pr√ºfung erfolgreich)

**Beispiele:**
```hemlock
// Grundlegende Pr√ºfungen
assert(x > 0);
assert(name != null);
assert(arr.length > 0, "Array darf nicht leer sein");

// Mit benutzerdefinierten Meldungen
fn divide(a: i32, b: i32): f64 {
    assert(b != 0, "Division durch Null");
    return a / b;
}

// Funktionsargumente validieren
fn process_data(data: array) {
    assert(data != null, "data darf nicht null sein");
    assert(data.length > 0, "data darf nicht leer sein");
    // ...
}
```

**Verhalten:**
- Wenn Bedingung wahr: gibt `null` zur√ºck, Ausf√ºhrung fortgesetzt
- Wenn Bedingung falsch: gibt Fehler aus und beendet mit Code 1
- Falsche Werte: `false`, `0`, `0.0`, `null`, `""` (leerer String)
- Wahre Werte: alles andere

**Ausgabe bei Fehlschlag:**
```
Assertion failed: Array darf nicht leer sein
```

**Wann verwenden:**
- Validierung von Funktionsvorbedingungen
- Pr√ºfen von Invarianten w√§hrend der Entwicklung
- Fruehzeitiges Erkennen von Programmierfehlern

**assert vs panic:**
- `assert(cond, msg)` - Prueft eine Bedingung, schlaegt fehl wenn falsch
- `panic(msg)` - Schlaegt immer bedingungslos fehl

---

## Signalbehandlung

### signal

Registriert oder setzt Signal-Handler zur√ºck.

**Signatur:**
```hemlock
signal(signum: i32, handler: function | null): function | null
```

**Parameter:**
- `signum` - Signalnummer (verwenden Sie Konstanten wie `SIGINT`)
- `handler` - Funktion die bei Signalempfang aufgerufen wird, oder `null` zum Zur√ºcksetzen auf Standard

**R√ºckgabe:** Vorherige Handler-Funktion, oder `null`

**Beispiele:**
```hemlock
fn handle_interrupt(sig) {
    print("SIGINT abgefangen!");
}

signal(SIGINT, handle_interrupt);

// Auf Standard zur√ºcksetzen
signal(SIGINT, null);
```

**Handler-Signatur:**
```hemlock
fn handler(signum: i32) {
    // signum enth√§lt die Signalnummer
}
```

**Siehe auch:**
- [Signalkonstanten](#signalkonstanten)
- `raise()`

---

### raise

Sendet Signal an aktuellen Prozess.

**Signatur:**
```hemlock
raise(signum: i32): null
```

**Parameter:**
- `signum` - Zu sendende Signalnummer

**R√ºckgabe:** `null`

**Beispiele:**
```hemlock
let count = 0;

fn increment(sig) {
    count = count + 1;
}

signal(SIGUSR1, increment);

raise(SIGUSR1);
raise(SIGUSR1);
print(count);  // 2
```

---

## Globale Variablen

### args

Kommandozeilenargumente-Array.

**Typ:** `array` von Strings

**Struktur:**
- `args[0]` - Skriptdateiname
- `args[1..n]` - Kommandozeilenargumente

**Beispiele:**
```bash
# Befehl: ./hemlock script.hml hello world
```

```hemlock
print(args[0]);        // "script.hml"
print(args.length);    // 3
print(args[1]);        // "hello"
print(args[2]);        // "world"

// Argumente durchlaufen
let i = 1;
while (i < args.length) {
    print("Argument", i, ":", args[i]);
    i = i + 1;
}
```

**REPL-Verhalten:** Im REPL ist `args.length` 0 (leeres Array)

---

## Signalkonstanten

Standard-POSIX-Signalkonstanten (i32-Werte):

### Unterbrechung & Beendigung

| Konstante  | Wert  | Beschreibung                                |
|------------|-------|---------------------------------------------|
| `SIGINT`   | 2     | Unterbrechung von Tastatur (Strg+C)         |
| `SIGTERM`  | 15    | Beendigungsanforderung                      |
| `SIGQUIT`  | 3     | Beenden von Tastatur (Strg+\)               |
| `SIGHUP`   | 1     | Aufhaengen am steuernden Terminal erkannt   |
| `SIGABRT`  | 6     | Abbruchsignal                               |

### Benutzerdefiniert

| Konstante  | Wert  | Beschreibung               |
|------------|-------|----------------------------|
| `SIGUSR1`  | 10    | Benutzerdefiniertes Signal 1 |
| `SIGUSR2`  | 12    | Benutzerdefiniertes Signal 2 |

### Prozesssteuerung

| Konstante  | Wert  | Beschreibung                      |
|------------|-------|-----------------------------------|
| `SIGALRM`  | 14    | Wecker-Timer                      |
| `SIGCHLD`  | 17    | Kindprozess-Statusaenderung       |
| `SIGCONT`  | 18    | Fortsetzen wenn gestoppt          |
| `SIGSTOP`  | 19    | Prozess stoppen (nicht abfangbar) |
| `SIGTSTP`  | 20    | Terminal-Stopp (Strg+Z)           |

### I/O

| Konstante  | Wert  | Beschreibung                           |
|------------|-------|----------------------------------------|
| `SIGPIPE`  | 13    | Unterbrochene Pipe                     |
| `SIGTTIN`  | 21    | Hintergrund-Lesen vom Terminal         |
| `SIGTTOU`  | 22    | Hintergrund-Schreiben zum Terminal     |

**Beispiele:**
```hemlock
fn handle_signal(sig) {
    if (sig == SIGINT) {
        print("Unterbrechung erkannt");
    }
    if (sig == SIGTERM) {
        print("Beendigung angefordert");
    }
}

signal(SIGINT, handle_signal);
signal(SIGTERM, handle_signal);
```

**Hinweis:** `SIGKILL` (9) und `SIGSTOP` (19) k√∂nnen nicht abgefangen oder ignoriert werden.

---

## Mathematik/Arithmetik-Funktionen

### div

Ganzzahldivision die eine Gleitkommazahl zur√ºckgibt.

**Signatur:**
```hemlock
div(a: number, b: number): f64
```

**Parameter:**
- `a` - Dividend
- `b` - Divisor

**R√ºckgabe:** Abrundung von `a / b` als Gleitkommazahl (f64)

**Beispiele:**
```hemlock
let result = div(7, 2);    // 3.0 (nicht 3.5)
let result2 = div(10, 3);  // 3.0
let result3 = div(-7, 2);  // -4.0 (Abrundung richtet sich nach negativer Unendlichkeit)
```

**Hinweis:** In Hemlock gibt der `/`-Operator immer eine Gleitkommazahl zur√ºck. Verwenden Sie `div()` f√ºr Ganzzahldivision wenn Sie den ganzzahligen Teil als Gleitkommazahl ben√∂tigen, oder `divi()` wenn Sie ein ganzzahliges Ergebnis ben√∂tigen.

---

### divi

Ganzzahldivision die eine Ganzzahl zur√ºckgibt.

**Signatur:**
```hemlock
divi(a: number, b: number): i64
```

**Parameter:**
- `a` - Dividend
- `b` - Divisor

**R√ºckgabe:** Abrundung von `a / b` als Ganzzahl (i64)

**Beispiele:**
```hemlock
let result = divi(7, 2);    // 3
let result2 = divi(10, 3);  // 3
let result3 = divi(-7, 2);  // -4 (Abrundung richtet sich nach negativer Unendlichkeit)
```

**Vergleich:**
```hemlock
print(7 / 2);      // 3.5 (normale Division, immer Gleitkomma)
print(div(7, 2));  // 3.0 (Ganzzahldivision, Gleitkommaergebnis)
print(divi(7, 2)); // 3   (Ganzzahldivision, Ganzzahlergebnis)
```

---

## Speicherverwaltungsfunktionen

Siehe [Speicher-API](#reference-memory-api) f√ºr vollst√§ndige Referenz:
- `alloc(size)` - Rohen Speicher allokieren
- `free(ptr)` - Speicher freigeben
- `buffer(size)` - Sicheren Buffer allokieren
- `memset(ptr, byte, size)` - Speicher fuellen
- `memcpy(dest, src, size)` - Speicher kopieren
- `realloc(ptr, new_size)` - Allokation vergroessern/verkleinern

### sizeof

Gibt die Gr√∂√üe eines Typs in Bytes zur√ºck.

**Signatur:**
```hemlock
sizeof(type): i32
```

**Parameter:**
- `type` - Eine Typkonstante (`i32`, `f64`, `ptr`, etc.) oder Typname-String

**R√ºckgabe:** Gr√∂√üe in Bytes als `i32`

**Beispiele:**
```hemlock
print(sizeof(i8));       // 1
print(sizeof(i16));      // 2
print(sizeof(i32));      // 4
print(sizeof(i64));      // 8
print(sizeof(f32));      // 4
print(sizeof(f64));      // 8
print(sizeof(ptr));      // 8
print(sizeof(rune));     // 4

// Mit Typ-Aliasen
print(sizeof(byte));     // 1 (gleich wie u8)
print(sizeof(integer));  // 4 (gleich wie i32)
print(sizeof(number));   // 8 (gleich wie f64)

// String-Form funktioniert auch
print(sizeof("i32"));    // 4
```

**Unterstuetzte Typen:**
| Typ | Gr√∂√üe | Aliase |
|-----|---------|--------|
| `i8` | 1 | - |
| `i16` | 2 | - |
| `i32` | 4 | `integer` |
| `i64` | 8 | - |
| `u8` | 1 | `byte` |
| `u16` | 2 | - |
| `u32` | 4 | - |
| `u64` | 8 | - |
| `f32` | 4 | - |
| `f64` | 8 | `number` |
| `ptr` | 8 | - |
| `rune` | 4 | - |
| `bool` | 1 | - |

**Siehe auch:** `talloc()` f√ºr typisierte Allokation

---

### talloc

Allokiert Speicher f√ºr ein typisiertes Array (typbewusste Allokation).

**Signatur:**
```hemlock
talloc(type, count: i32): ptr
```

**Parameter:**
- `type` - Eine Typkonstante (`i32`, `f64`, `ptr`, etc.)
- `count` - Anzahl der zu allokierenden Elemente

**R√ºckgabe:** `ptr` zum allokierten Speicher, oder `null` bei Fehlschlag

**Beispiele:**
```hemlock
// Array von 10 i32s allokieren (40 Bytes)
let int_arr = talloc(i32, 10);
ptr_write_i32(int_arr, 42);
ptr_write_i32(ptr_offset(int_arr, 1, 4), 100);

// Array von 5 f64s allokieren (40 Bytes)
let float_arr = talloc(f64, 5);

// Array von 100 Bytes allokieren
let byte_arr = talloc(u8, 100);

// Nicht vergessen freizugeben!
free(int_arr);
free(float_arr);
free(byte_arr);
```

**Vergleich mit alloc:**
```hemlock
// Diese sind √§quivalent:
let p1 = talloc(i32, 10);      // Typbewusst: 10 i32s
let p2 = alloc(sizeof(i32) * 10);  // Manuelle Berechnung

// talloc ist klarer und weniger fehleranfaellig
```

**Fehlerbehandlung:**
- Gibt `null` zur√ºck wenn Allokation fehlschlaegt
- Beendet mit Fehler wenn count nicht positiv ist
- Prueft auf Groessenueberlauf (count * element_size)

**Siehe auch:** `alloc()`, `sizeof()`, `free()`

---

## FFI-Pointer-Hilfsfunktionen

Diese Funktionen helfen beim Lesen und Schreiben von typisierten Werten im Rohspeicher, n√ºtzlich f√ºr FFI und Low-Level-Speichermanipulation.

### ptr_null

Erstellt einen Null-Pointer.

**Signatur:**
```hemlock
ptr_null(): ptr
```

**R√ºckgabe:** Ein Null-Pointer

**Beispiel:**
```hemlock
let p = ptr_null();
if (p == null) {
    print("Pointer ist null");
}
```

---

### ptr_offset

Berechnet Pointer-Offset (Pointer-Arithmetik).

**Signatur:**
```hemlock
ptr_offset(ptr: ptr, index: i32, element_size: i32): ptr
```

**Parameter:**
- `ptr` - Basis-Pointer
- `index` - Element-Index
- `element_size` - Gr√∂√üe jedes Elements in Bytes

**R√ºckgabe:** Pointer zum Element am gegebenen Index

**Beispiel:**
```hemlock
let arr = talloc(i32, 10);
ptr_write_i32(arr, 100);                      // arr[0] = 100
ptr_write_i32(ptr_offset(arr, 1, 4), 200);    // arr[1] = 200
ptr_write_i32(ptr_offset(arr, 2, 4), 300);    // arr[2] = 300

print(ptr_read_i32(ptr_offset(arr, 1, 4)));   // 200
free(arr);
```

---

### Pointer-Lesefunktionen

Liest typisierte Werte aus dem Speicher.

| Funktion | Signatur | R√ºckgabe | Beschreibung |
|----------|----------|-----------|--------------|
| `ptr_read_i8` | `(ptr)` | `i8` | Liest vorzeichenbehaftete 8-Bit-Ganzzahl |
| `ptr_read_i16` | `(ptr)` | `i16` | Liest vorzeichenbehaftete 16-Bit-Ganzzahl |
| `ptr_read_i32` | `(ptr)` | `i32` | Liest vorzeichenbehaftete 32-Bit-Ganzzahl |
| `ptr_read_i64` | `(ptr)` | `i64` | Liest vorzeichenbehaftete 64-Bit-Ganzzahl |
| `ptr_read_u8` | `(ptr)` | `u8` | Liest vorzeichenlose 8-Bit-Ganzzahl |
| `ptr_read_u16` | `(ptr)` | `u16` | Liest vorzeichenlose 16-Bit-Ganzzahl |
| `ptr_read_u32` | `(ptr)` | `u32` | Liest vorzeichenlose 32-Bit-Ganzzahl |
| `ptr_read_u64` | `(ptr)` | `u64` | Liest vorzeichenlose 64-Bit-Ganzzahl |
| `ptr_read_f32` | `(ptr)` | `f32` | Liest 32-Bit-Gleitkommazahl |
| `ptr_read_f64` | `(ptr)` | `f64` | Liest 64-Bit-Gleitkommazahl |
| `ptr_read_ptr` | `(ptr)` | `ptr` | Liest Pointer-Wert |

**Beispiel:**
```hemlock
let p = alloc(8);
ptr_write_f64(p, 3.14159);
let value = ptr_read_f64(p);
print(value);  // 3.14159
free(p);
```

---

### Pointer-Schreibfunktionen

Schreibt typisierte Werte in den Speicher.

| Funktion | Signatur | R√ºckgabe | Beschreibung |
|----------|----------|-----------|--------------|
| `ptr_write_i8` | `(ptr, value)` | `null` | Schreibt vorzeichenbehaftete 8-Bit-Ganzzahl |
| `ptr_write_i16` | `(ptr, value)` | `null` | Schreibt vorzeichenbehaftete 16-Bit-Ganzzahl |
| `ptr_write_i32` | `(ptr, value)` | `null` | Schreibt vorzeichenbehaftete 32-Bit-Ganzzahl |
| `ptr_write_i64` | `(ptr, value)` | `null` | Schreibt vorzeichenbehaftete 64-Bit-Ganzzahl |
| `ptr_write_u8` | `(ptr, value)` | `null` | Schreibt vorzeichenlose 8-Bit-Ganzzahl |
| `ptr_write_u16` | `(ptr, value)` | `null` | Schreibt vorzeichenlose 16-Bit-Ganzzahl |
| `ptr_write_u32` | `(ptr, value)` | `null` | Schreibt vorzeichenlose 32-Bit-Ganzzahl |
| `ptr_write_u64` | `(ptr, value)` | `null` | Schreibt vorzeichenlose 64-Bit-Ganzzahl |
| `ptr_write_f32` | `(ptr, value)` | `null` | Schreibt 32-Bit-Gleitkommazahl |
| `ptr_write_f64` | `(ptr, value)` | `null` | Schreibt 64-Bit-Gleitkommazahl |
| `ptr_write_ptr` | `(ptr, value)` | `null` | Schreibt Pointer-Wert |

**Beispiel:**
```hemlock
let p = alloc(4);
ptr_write_i32(p, 42);
print(ptr_read_i32(p));  // 42
free(p);
```

---

### Buffer/Pointer-Konvertierung

#### buffer_ptr

Holt rohen Pointer aus einem Buffer.

**Signatur:**
```hemlock
buffer_ptr(buf: buffer): ptr
```

**Beispiel:**
```hemlock
let buf = buffer(64);
let p = buffer_ptr(buf);
// Jetzt zeigt p auf denselben Speicher wie buf
```

#### ptr_to_buffer

Erstellt einen Buffer-Wrapper um einen rohen Pointer.

**Signatur:**
```hemlock
ptr_to_buffer(ptr: ptr, size: i32): buffer
```

**Beispiel:**
```hemlock
let p = alloc(64);
let buf = ptr_to_buffer(p, 64);
buf[0] = 65;  // Hat jetzt Grenzenpr√ºfung
// Hinweis: Freigeben von buf gibt den zugrundeliegenden Speicher frei
```

---

## Datei-I/O-Funktionen

Siehe [Datei-API](#reference-file-api) f√ºr vollst√§ndige Referenz:
- `open(path, mode?)` - Datei √∂ffnen

---

## Nebenlaeufigkeitsfunktionen

Siehe [Nebenlaeufigkeits-API](#reference-concurrency-api) f√ºr vollst√§ndige Referenz:
- `spawn(fn, args...)` - Task starten
- `join(task)` - Auf Task warten
- `detach(task)` - Task abl√∂sen
- `channel(capacity)` - Kanal erstellen

### apply

Ruft eine Funktion dynamisch mit einem Array von Argumenten auf.

**Signatur:**
```hemlock
apply(fn: function, args: array): any
```

**Parameter:**
- `fn` - Die aufzurufende Funktion
- `args` - Array von Argumenten die an die Funktion √ºbergeben werden

**R√ºckgabe:** Der R√ºckgabewert der aufgerufenen Funktion

**Beispiele:**
```hemlock
fn add(a, b) {
    return a + b;
}

// Mit Array von Argumenten aufrufen
let result = apply(add, [2, 3]);
print(result);  // 5

// Dynamischer Dispatch
let operations = {
    add: fn(a, b) { return a + b; },
    mul: fn(a, b) { return a * b; },
    sub: fn(a, b) { return a - b; }
};

fn calculate(op: string, args: array) {
    return apply(operations[op], args);
}

print(calculate("add", [10, 5]));  // 15
print(calculate("mul", [10, 5]));  // 50
print(calculate("sub", [10, 5]));  // 5

// Variable Argumente
fn sum(...nums) {
    let total = 0;
    for (n in nums) {
        total = total + n;
    }
    return total;
}

let numbers = [1, 2, 3, 4, 5];
print(apply(sum, numbers));  // 15
```

**Anwendungsfaelle:**
- Dynamischer Funktionsdispatch basierend auf Laufzeitwerten
- Aufrufen von Funktionen mit variablen Argumentlisten
- Implementierung von Higher-Order-Utilities (map, filter, etc.)
- Plugin/Erweiterungssysteme

---

### select

Wartet auf Daten von mehreren Kanaelen, gibt zur√ºck wenn einer Daten hat.

**Signatur:**
```hemlock
select(channels: array, timeout_ms?: i32): object | null
```

**Parameter:**
- `channels` - Array von Kanalwerten
- `timeout_ms` (optional) - Timeout in Millisekunden (-1 oder weglassen f√ºr unendlich)

**R√ºckgabe:**
- `{ channel, value }` - Objekt mit dem Kanal der Daten hatte und dem empfangenen Wert
- `null` - Bei Timeout

**Beispiele:**
```hemlock
let ch1 = channel(1);
let ch2 = channel(1);

// Produzenten-Tasks
spawn(fn() {
    sleep(100);
    ch1.send("von Kanal 1");
});

spawn(fn() {
    sleep(50);
    ch2.send("von Kanal 2");
});

// Auf erste Nachricht warten
let result = select([ch1, ch2]);
print(result.value);  // "von Kanal 2" (kam zuerst an)

// Mit Timeout
let result2 = select([ch1, ch2], 1000);  // Warte bis zu 1 Sekunde
if (result2 == null) {
    print("Timeout - keine Daten empfangen");
} else {
    print("Empfangen:", result2.value);
}

// Kontinuierliche Select-Schleife
while (true) {
    let msg = select([ch1, ch2], 5000);
    if (msg == null) {
        print("Keine Aktivitaet f√ºr 5 Sekunden");
        break;
    }
    print("Nachricht erhalten:", msg.value);
}
```

**Verhalten:**
- Blockiert bis ein Kanal Daten hat oder Timeout abl√§uft
- Gibt sofort zur√ºck wenn ein Kanal bereits Daten hat
- Wenn Kanal geschlossen und leer ist, gibt `{ channel, value: null }` zur√ºck
- Prueft Kan√§le der Reihe nach (erster bereiter Kanal gewinnt)

**Anwendungsfaelle:**
- Multiplexen mehrerer Produzenten
- Implementierung von Timeouts bei Kanaloperationen
- Aufbau von Event-Loops mit mehreren Quellen

---

## Zusammenfassungstabelle

### Funktionen

| Funktion   | Kategorie       | R√ºckgabe    | Beschreibung                     |
|------------|-----------------|--------------|----------------------------------|
| `print`    | I/O             | `null`       | Auf stdout ausgeben              |
| `read_line`| I/O             | `string?`    | Zeile von stdin lesen            |
| `eprint`   | I/O             | `null`       | Auf stderr ausgeben              |
| `typeof`   | Typ             | `string`     | Typname holen                    |
| `exec`     | Befehl          | `object`     | Shell-Befehl ausf√ºhren          |
| `exec_argv`| Befehl          | `object`     | Mit Argument-Array ausf√ºhren    |
| `assert`   | Fehler          | `null`       | Bedingung pr√ºfen oder beenden   |
| `panic`    | Fehler          | `never`      | Nicht wiederherstellbarer Fehler (beendet) |
| `signal`   | Signal          | `function?`  | Signal-Handler registrieren      |
| `raise`    | Signal          | `null`       | Signal an Prozess senden         |
| `alloc`    | Speicher        | `ptr`        | Rohen Speicher allokieren        |
| `talloc`   | Speicher        | `ptr`        | Typisierte Allokation            |
| `sizeof`   | Speicher        | `i32`        | Typgroesse in Bytes holen        |
| `free`     | Speicher        | `null`       | Speicher freigeben               |
| `buffer`   | Speicher        | `buffer`     | Sicheren Buffer allokieren       |
| `memset`   | Speicher        | `null`       | Speicher fuellen                 |
| `memcpy`   | Speicher        | `null`       | Speicher kopieren                |
| `realloc`  | Speicher        | `ptr`        | Allokation vergroessern          |
| `open`     | Datei-I/O       | `file`       | Datei √∂ffnen                    |
| `spawn`    | Nebenl√§ufigkeit| `task`       | Nebenlaeufigen Task starten      |
| `join`     | Nebenl√§ufigkeit| `any`        | Auf Task-Ergebnis warten         |
| `detach`   | Nebenl√§ufigkeit| `null`       | Task abloesen                    |
| `channel`  | Nebenl√§ufigkeit| `channel`    | Kommunikationskanal erstellen    |
| `select`   | Nebenl√§ufigkeit| `object?`    | Auf mehrere Kan√§le warten       |
| `apply`    | Funktionen      | `any`        | Funktion mit Args-Array aufrufen |

### Globale Variablen

| Variable   | Typ      | Beschreibung                      |
|------------|----------|-----------------------------------|
| `args`     | `array`  | Kommandozeilenargumente           |

### Konstanten

| Konstante  | Typ   | Kategorie | Wert  | Beschreibung              |
|------------|-------|-----------|-------|---------------------------|
| `SIGINT`   | `i32` | Signal    | 2     | Tastatur-Unterbrechung    |
| `SIGTERM`  | `i32` | Signal    | 15    | Beendigungsanforderung    |
| `SIGQUIT`  | `i32` | Signal    | 3     | Tastatur-Beenden          |
| `SIGHUP`   | `i32` | Signal    | 1     | Aufhaengen                |
| `SIGABRT`  | `i32` | Signal    | 6     | Abbruch                   |
| `SIGUSR1`  | `i32` | Signal    | 10    | Benutzerdefiniert 1       |
| `SIGUSR2`  | `i32` | Signal    | 12    | Benutzerdefiniert 2       |
| `SIGALRM`  | `i32` | Signal    | 14    | Wecker-Timer              |
| `SIGCHLD`  | `i32` | Signal    | 17    | Kind-Statusaenderung      |
| `SIGCONT`  | `i32` | Signal    | 18    | Fortsetzen                |
| `SIGSTOP`  | `i32` | Signal    | 19    | Stopp (nicht abfangbar)   |
| `SIGTSTP`  | `i32` | Signal    | 20    | Terminal-Stopp            |
| `SIGPIPE`  | `i32` | Signal    | 13    | Unterbrochene Pipe        |
| `SIGTTIN`  | `i32` | Signal    | 21    | Hintergrund-Terminal-Lesen |
| `SIGTTOU`  | `i32` | Signal    | 22    | Hintergrund-Terminal-Schreiben |

---

## Siehe auch

- [Typsystem](#reference-type-system) - Typen und Konvertierungen
- [Speicher-API](#reference-memory-api) - Speicherallokationsfunktionen
- [Datei-API](#reference-file-api) - Datei-I/O-Funktionen
- [Nebenlaeufigkeits-API](#reference-concurrency-api) - Async/Nebenlaeufigkeitsfunktionen
- [String-API](#reference-string-api) - String-Methoden
- [Array-API](#reference-array-api) - Array-Methoden


--------------------------------------------------------------------------------
## Nebenl√§ufigkeits-API
--------------------------------------------------------------------------------

# Nebenlaeufigkeits-API-Referenz

Vollst√§ndige Referenz f√ºr Hemlocks Async/Nebenlaeufigkeitssystem.

---

## √úbersicht

Hemlock bietet **strukturierte Nebenl√§ufigkeit** mit echter Multi-Thread-Parallelit√§t unter Verwendung von POSIX-Threads (pthreads). Jeder gestartete Task l√§uft auf einem separaten OS-Thread, was echte parallele Ausf√ºhrung √ºber mehrere CPU-Kerne erm√∂glicht.

**Hauptmerkmale:**
- Echte Multi-Thread-Parallelit√§t (keine Green Threads)
- Async-Funktionssyntax
- Task-Starten und -Beitreten
- Thread-sichere Kan√§le
- Ausnahme-Propagierung

**Threading-Modell:**
- Echte OS-Threads (POSIX pthreads)
- Echte Parallelit√§t (mehrere CPU-Kerne)
- Kernel-geplant (praeemptives Multitasking)
- Thread-sichere Synchronisation (Mutexes, Bedingungsvariablen)

---

## Async-Funktionen

### Async-Funktionsdeklaration

Funktionen k√∂nnen als `async` deklariert werden um anzuzeigen, dass sie f√ºr nebenlaeufige Ausf√ºhrung konzipiert sind.

**Syntax:**
```hemlock
async fn function_name(params): return_type {
    // Funktionsk√∂rper
}
```

**Beispiele:**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

async fn process_data(data: string) {
    print("Verarbeite:", data);
    return null;
}
```

**Verhalten:**
- `async fn` deklariert eine asynchrone Funktion
- Kann synchron aufgerufen werden (l√§uft im aktuellen Thread)
- Kann als nebenlaeufiger Task gestartet werden (l√§uft auf neuem Thread)
- Wenn gestartet, l√§uft auf eigenem OS-Thread

**Hinweis:** Das `await`-Schl√ºsselwort ist f√ºr zukuenftige Verwendung reserviert, aber derzeit nicht implementiert.

---

## Task-Verwaltung

### spawn

Erstellt und startet einen neuen nebenlaeufigen Task.

**Signatur:**
```hemlock
spawn(async_fn: function, ...args): task
```

**Parameter:**
- `async_fn` - Auszufuehrende Async-Funktion
- `...args` - An die Funktion zu uebergebende Argumente

**R√ºckgabe:** Task-Handle

**Beispiele:**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Einzelnen Task starten
let t = spawn(compute, 1000);
let result = join(t);
print(result);

// Mehrere Tasks starten (laufen parallel!)
let t1 = spawn(compute, 100);
let t2 = spawn(compute, 200);
let t3 = spawn(compute, 300);

// Alle drei laufen gleichzeitig
let r1 = join(t1);
let r2 = join(t2);
let r3 = join(t3);
```

**Verhalten:**
- Erstellt neuen OS-Thread via `pthread_create()`
- Beginnt sofort mit der Ausf√ºhrung der Funktion
- Gibt Task-Handle f√ºr spaeteres Beitreten zur√ºck
- Tasks laufen parallel auf separaten CPU-Kernen

---

### join

Wartet auf Task-Abschluss und ruft Ergebnis ab.

**Signatur:**
```hemlock
join(task: task): any
```

**Parameter:**
- `task` - Task-Handle von `spawn()`

**R√ºckgabe:** R√ºckgabewert des Tasks

**Beispiele:**
```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

let t = spawn(factorial, 10);
let result = join(t);  // Blockiert bis Task fertig
print(result);         // 3628800
```

**Verhalten:**
- Blockiert aktuellen Thread bis Task abgeschlossen
- Gibt R√ºckgabewert des Tasks zur√ºck
- Propagiert vom Task geworfene Ausnahmen
- Raeumt Task-Ressourcen nach R√ºckkehr auf

**Fehlerbehandlung:**
```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Task fehlgeschlagen!";
    }
    return 42;
}

let t = spawn(risky_operation, 1);
try {
    let result = join(t);
} catch (e) {
    print("Abgefangen:", e);  // "Abgefangen: Task fehlgeschlagen!"
}
```

---

### detach

Loest Task ab (Fire-and-Forget-Ausf√ºhrung).

**Signatur:**
```hemlock
detach(task: task): null
```

**Parameter:**
- `task` - Task-Handle von `spawn()`

**R√ºckgabe:** `null`

**Beispiele:**
```hemlock
async fn background_work() {
    print("Arbeite im Hintergrund...");
    return null;
}

let t = spawn(background_work);
detach(t);  // Task l√§uft unabh√§ngig weiter

// Kann abgeloesten Task nicht beitreten
// join(t);  // FEHLER
```

**Verhalten:**
- Task l√§uft unabh√§ngig weiter
- Kann abgeloesten Task nicht `join()`en
- Task und Thread werden automatisch aufgeraeumt wenn Task abgeschlossen

**Anwendungsfaelle:**
- Fire-and-Forget-Hintergrundtasks
- Logging/Monitoring-Tasks
- Tasks die keine Werte zur√ºckgeben m√ºssen

---

## Kan√§le

Kan√§le bieten thread-sichere Kommunikation zwischen Tasks.

### channel

Erstellt einen gepufferten Kanal.

**Signatur:**
```hemlock
channel(capacity: i32): channel
```

**Parameter:**
- `capacity` - Puffergroesse (Anzahl der Werte)

**R√ºckgabe:** Kanal-Objekt

**Beispiele:**
```hemlock
let ch = channel(10);  // Gepufferter Kanal mit Kapazit√§t 10
let ch2 = channel(1);  // Minimaler Puffer (synchron)
let ch3 = channel(100); // Grosser Puffer
```

**Verhalten:**
- Erstellt thread-sicheren Kanal
- Verwendet pthread-Mutexes zur Synchronisation
- Kapazit√§t ist bei Erstellung fest

---

### Kanal-Methoden

#### send

Sendet Wert an Kanal (blockiert wenn voll).

**Signatur:**
```hemlock
channel.send(value: any): null
```

**Parameter:**
- `value` - Zu sendender Wert (beliebiger Typ)

**R√ºckgabe:** `null`

**Beispiele:**
```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

let ch = channel(10);
let t = spawn(producer, ch, 5);
```

**Verhalten:**
- Sendet Wert an Kanal
- Blockiert wenn Kanal voll
- Thread-sicher (verwendet Mutex)
- Gibt zur√ºck nachdem Wert gesendet wurde

---

#### recv

Empfaengt Wert von Kanal (blockiert wenn leer).

**Signatur:**
```hemlock
channel.recv(): any
```

**R√ºckgabe:** Wert vom Kanal, oder `null` wenn Kanal geschlossen und leer

**Beispiele:**
```hemlock
async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

let ch = channel(10);
let t = spawn(consumer, ch, 5);
```

**Verhalten:**
- Empfaengt Wert vom Kanal
- Blockiert wenn Kanal leer
- Gibt `null` zur√ºck wenn Kanal geschlossen und leer
- Thread-sicher (verwendet Mutex)

---

#### close

Schliesst Kanal (keine weiteren Sends erlaubt).

**Signatur:**
```hemlock
channel.close(): null
```

**R√ºckgabe:** `null`

**Beispiele:**
```hemlock
async fn producer(ch) {
    ch.send(1);
    ch.send(2);
    ch.send(3);
    ch.close();  // Signalisiert keine weiteren Werte
    return null;
}

async fn consumer(ch) {
    while (true) {
        let val = ch.recv();
        if (val == null) {
            break;  // Kanal geschlossen
        }
        print(val);
    }
    return null;
}
```

**Verhalten:**
- Schliesst Kanal
- Keine weiteren Sends erlaubt
- `recv()` gibt `null` zur√ºck wenn Kanal leer
- Thread-sicher

---

## Vollstaendiges Nebenlaeufigkeitsbeispiel

### Producer-Consumer-Muster

```hemlock
async fn producer(ch, count: i32) {
    let i = 0;
    while (i < count) {
        print("Produziere:", i);
        ch.send(i * 10);
        i = i + 1;
    }
    ch.close();
    return null;
}

async fn consumer(ch, count: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < count) {
        let val = ch.recv();
        print("Konsumiere:", val);
        sum = sum + val;
        i = i + 1;
    }
    return sum;
}

// Kanal erstellen
let ch = channel(10);

// Producer und Consumer starten
let p = spawn(producer, ch, 5);
let c = spawn(consumer, ch, 5);

// Auf Abschluss warten
join(p);
let total = join(c);
print("Gesamt:", total);  // 0+10+20+30+40 = 100
```

---

## Parallele Berechnung

### Beispiel mit mehreren Tasks

```hemlock
async fn factorial(n: i32): i32 {
    if (n <= 1) { return 1; }
    return n * factorial(n - 1);
}

// Mehrere Tasks starten (laufen parallel!)
let t1 = spawn(factorial, 5);   // Thread 1
let t2 = spawn(factorial, 6);   // Thread 2
let t3 = spawn(factorial, 7);   // Thread 3
let t4 = spawn(factorial, 8);   // Thread 4

// Alle vier berechnen gleichzeitig!

// Auf Ergebnisse warten
let f5 = join(t1);  // 120
let f6 = join(t2);  // 720
let f7 = join(t3);  // 5040
let f8 = join(t4);  // 40320

print(f5, f6, f7, f8);
```

---

## Task-Lebenszyklus

### Zustandsuebergaenge

1. **Erstellt** - Task gestartet aber noch nicht laufend
2. **Laufend** - Task l√§uft auf OS-Thread
3. **Abgeschlossen** - Task beendet (Ergebnis verf√ºgbar)
4. **Beigetreten** - Ergebnis abgerufen, Ressourcen aufgeraeumt
5. **Abgeloest** - Task l√§uft unabh√§ngig weiter

### Lebenszyklus-Beispiel

```hemlock
async fn work(n: i32): i32 {
    return n * 2;
}

// 1. Task erstellen
let t = spawn(work, 21);  // Zustand: Laufend

// Task l√§uft auf separatem Thread...

// 2. Task beitreten
let result = join(t);     // Zustand: Abgeschlossen ‚Üí Beigetreten
print(result);            // 42

// Task-Ressourcen nach join aufgeraeumt
```

### Abgeloester Lebenszyklus

```hemlock
async fn background() {
    print("Hintergrund-Task l√§uft");
    return null;
}

// 1. Task erstellen
let t = spawn(background);  // Zustand: Laufend

// 2. Task abloesen
detach(t);                  // Zustand: Abgeloest

// Task l√§uft unabh√§ngig weiter
// Ressourcen werden vom OS aufgeraeumt wenn fertig
```

---

## Fehlerbehandlung

### Ausnahme-Propagierung

Ausnahmen die in Tasks geworfen werden, werden beim Beitreten propagiert:

```hemlock
async fn risky_operation(should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Task fehlgeschlagen!";
    }
    return 42;
}

// Task der erfolgreich ist
let t1 = spawn(risky_operation, 0);
let result1 = join(t1);  // 42

// Task der fehlschlaegt
let t2 = spawn(risky_operation, 1);
try {
    let result2 = join(t2);
} catch (e) {
    print("Abgefangen:", e);  // "Abgefangen: Task fehlgeschlagen!"
}
```

### Umgang mit mehreren Tasks

```hemlock
async fn work(id: i32, should_fail: i32): i32 {
    if (should_fail == 1) {
        throw "Task " + typeof(id) + " fehlgeschlagen";
    }
    return id * 10;
}

let t1 = spawn(work, 1, 0);
let t2 = spawn(work, 2, 1);  // Wird fehlschlagen
let t3 = spawn(work, 3, 0);

// Beitreten mit Fehlerbehandlung
try {
    let r1 = join(t1);  // OK
    print("Task 1:", r1);

    let r2 = join(t2);  // Wirft
    print("Task 2:", r2);  // Nie erreicht
} catch (e) {
    print("Fehler:", e);  // "Fehler: Task 2 fehlgeschlagen"
}

// Kann verbleibenden Task noch beitreten
let r3 = join(t3);
print("Task 3:", r3);
```

---

## Leistungscharakteristiken

### Echte Parallelit√§t

```hemlock
async fn cpu_intensive(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Sequentielle Ausf√ºhrung
let start = get_time();
let r1 = cpu_intensive(10000000);
let r2 = cpu_intensive(10000000);
let sequential_time = get_time() - start;

// Parallele Ausf√ºhrung
let start2 = get_time();
let t1 = spawn(cpu_intensive, 10000000);
let t2 = spawn(cpu_intensive, 10000000);
join(t1);
join(t2);
let parallel_time = get_time() - start2;

// parallel_time sollte ~50% von sequential_time auf Multi-Core-Systemen sein
```

**Bewiesene Charakteristiken:**
- N Tasks k√∂nnen N CPU-Kerne gleichzeitig nutzen
- Stresstests zeigen 8-9x CPU-Zeit vs. Wandzeit (Beweis der Parallelit√§t)
- Thread-Overhead: ~8KB Stack + pthread-Overhead pro Task
- Blockierende Operationen in einem Task blockieren andere nicht

---

## Implementierungsdetails

### Threading-Modell

- **1:1 Threading** - Jeder Task = 1 OS-Thread (`pthread`)
- **Kernel-geplant** - OS-Kernel verteilt Threads auf Kerne
- **Praeemptives Multitasking** - OS kann Threads unterbrechen und wechseln
- **Kein GIL** - Kein Global Interpreter Lock (anders als Python)

### Synchronisation

- **Mutexes** - Kan√§le verwenden `pthread_mutex_t`
- **Bedingungsvariablen** - Blockierendes send/recv verwendet `pthread_cond_t`
- **Lock-freie Operationen** - Task-Zustandsuebergaenge sind atomar

### Speicher & Aufraeumen

- **Beigetretene Tasks** - Automatisch aufgeraeumt nach `join()`
- **Abgeloeste Tasks** - Automatisch aufgeraeumt wenn Task abgeschlossen
- **Kan√§le** - Referenzgez√§hlt, freigegeben wenn nicht mehr verwendet

---

## Einschr√§nkungen

- Kein `select()` f√ºr Multiplexen mehrerer Kan√§le
- Kein Work-Stealing-Scheduler (1 Thread pro Task)
- Keine async I/O-Integration (Datei/Netzwerk-Operationen blockieren)
- Kanalkapazitaet bei Erstellung fest

---

## Vollst√§ndige API-Zusammenfassung

### Funktionen

| Funktion  | Signatur                          | R√ºckgabe | Beschreibung                     |
|-----------|-----------------------------------|-----------|----------------------------------|
| `spawn`   | `(async_fn: function, ...args)`   | `task`    | Nebenlaeufigen Task erstellen und starten |
| `join`    | `(task: task)`                    | `any`     | Auf Task warten, Ergebnis holen  |
| `detach`  | `(task: task)`                    | `null`    | Task abloesen (Fire-and-Forget)  |
| `channel` | `(capacity: i32)`                 | `channel` | Thread-sicheren Kanal erstellen  |

### Kanal-Methoden

| Methode | Signatur        | R√ºckgabe | Beschreibung                       |
|---------|-----------------|-----------|-----------------------------------|
| `send`  | `(value: any)`  | `null`    | Wert senden (blockiert wenn voll) |
| `recv`  | `()`            | `any`     | Wert empfangen (blockiert wenn leer) |
| `close` | `()`            | `null`    | Kanal schlie√üen                  |

### Typen

| Typ       | Beschreibung                         |
|-----------|--------------------------------------|
| `task`    | Handle f√ºr nebenlaeufigen Task      |
| `channel` | Thread-sicherer Kommunikationskanal  |

---

## Best Practices

### Empfohlen

- Verwenden Sie Kan√§le f√ºr Kommunikation zwischen Tasks
- Behandeln Sie Ausnahmen von beigetretenen Tasks
- Schlie√üen Sie Kan√§le wenn Senden beendet
- Verwenden Sie `join()` um Ergebnisse zu holen und aufzuraeumen
- Starten Sie nur async-Funktionen

### Vermeiden

- Teilen Sie keinen veraenderbaren Zustand ohne Synchronisation
- Treten Sie demselben Task nicht zweimal bei
- Senden Sie nicht auf geschlossenen Kanaelen
- Starten Sie keine nicht-async-Funktionen
- Vergessen Sie nicht Tasks beizutreten (au√üer wenn abgeloest)

---

## Siehe auch

- [Eingebaute Funktionen](#reference-builtins) - `spawn()`, `join()`, `detach()`, `channel()`
- [Typsystem](#reference-type-system) - Task- und Kanal-Typen


--------------------------------------------------------------------------------
## Operatoren
--------------------------------------------------------------------------------

# Operatoren-Referenz

Vollst√§ndige Referenz f√ºr alle Operatoren in Hemlock, einschlie√ülich Pr√§zedenz, Assoziativitaet und Verhalten.

---

## √úbersicht

Hemlock bietet C-√§hnliche Operatoren mit expliziten Praezedenzregeln. Alle Operatoren folgen strikten Typisierungsregeln mit automatischer Typpromovierung wo anwendbar.

---

## Arithmetische Operatoren

### Bin√§re Arithmetik

| Operator | Name            | Beispiel   | Beschreibung               |
|----------|-----------------|------------|----------------------------|
| `+`      | Addition        | `a + b`    | Zwei Werte addieren        |
| `-`      | Subtraktion     | `a - b`    | b von a subtrahieren       |
| `*`      | Multiplikation  | `a * b`    | Zwei Werte multiplizieren  |
| `/`      | Division        | `a / b`    | a durch b dividieren       |

**Typpromovierung:**
Ergebnisse folgen Typpromovierungsregeln (siehe [Typsystem](type-system.md#type-promotion-rules)).

**Beispiele:**
```hemlock
let a = 10 + 5;        // 15 (i32)
let b = 10 - 3;        // 7 (i32)
let c = 4 * 5;         // 20 (i32)
let d = 20 / 4;        // 5 (i32)

// Gleitkomma-Division
let e = 10.0 / 3.0;    // 3.333... (f64)

// Gemischte Typen
let f: u8 = 10;
let g: i32 = 20;
let h = f + g;         // 30 (i32, promoviert)
```

**Division durch Null:**
- Ganzzahl-Division durch Null: Laufzeitfehler
- Gleitkomma-Division durch Null: Gibt `inf` oder `-inf` zur√ºck

---

### Unaere Arithmetik

| Operator | Name     | Beispiel | Beschreibung          |
|----------|----------|----------|-----------------------|
| `-`      | Negation | `-a`     | Wert negieren         |
| `+`      | Plus     | `+a`     | Identit√§t (keine √Ñnderung) |

**Beispiele:**
```hemlock
let a = 5;
let b = -a;            // -5
let c = +a;            // 5 (keine √Ñnderung)

let x = -3.14;         // -3.14
```

---

## Vergleichsoperatoren

| Operator | Name                    | Beispiel   | R√ºckgabe |
|----------|-------------------------|------------|-----------|
| `==`     | Gleich                  | `a == b`   | `bool`    |
| `!=`     | Ungleich                | `a != b`   | `bool`    |
| `<`      | Kleiner als             | `a < b`    | `bool`    |
| `>`      | Gr√∂√üer als            | `a > b`    | `bool`    |
| `<=`     | Kleiner oder gleich     | `a <= b`   | `bool`    |
| `>=`     | Gr√∂√üer oder gleich    | `a >= b`   | `bool`    |

**Typpromovierung:**
Operanden werden vor Vergleich promoviert.

**Beispiele:**
```hemlock
print(5 == 5);         // true
print(10 != 5);        // true
print(3 < 7);          // true
print(10 > 5);         // true
print(5 <= 5);         // true
print(10 >= 5);        // true

// String-Vergleich
print("hello" == "hello");  // true
print("abc" < "def");       // true (lexikografisch)

// Gemischte Typen
let a: u8 = 10;
let b: i32 = 10;
print(a == b);         // true (auf i32 promoviert)
```

---

## Logische Operatoren

| Operator | Name         | Beispiel     | Beschreibung              |
|----------|--------------|--------------|---------------------------|
| `&&`     | Logisches UND| `a && b`     | Wahr wenn beide wahr      |
| `||`     | Logisches ODER| `a || b`    | Wahr wenn einer wahr      |
| `!`      | Logisches NICHT| `!a`       | Boolean negieren          |

**Kurzschluss-Auswertung:**
- `&&` - Stoppt beim ersten falschen Wert
- `||` - Stoppt beim ersten wahren Wert

**Beispiele:**
```hemlock
let a = true;
let b = false;

print(a && b);         // false
print(a || b);         // true
print(!a);             // false
print(!b);             // true

// Kurzschluss
if (x != 0 && (10 / x) > 2) {
    print("sicher");
}

if (x == 0 || (10 / x) > 2) {
    print("sicher");
}
```

---

## Bitweise Operatoren

**Einschr√§nkung:** Nur Ganzzahltypen (i8-i64, u8-u64)

### Bin√§re Bitweise

| Operator | Name           | Beispiel   | Beschreibung              |
|----------|----------------|------------|---------------------------|
| `&`      | Bitweises UND  | `a & b`    | UND jedes Bit             |
| `|`      | Bitweises ODER | `a | b`    | ODER jedes Bit            |
| `^`      | Bitweises XOR  | `a ^ b`    | XOR jedes Bit             |
| `<<`     | Linksverschiebung | `a << b` | Um b Bits nach links verschieben |
| `>>`     | Rechtsverschiebung| `a >> b` | Um b Bits nach rechts verschieben |

**Typerhaltung:**
Ergebnistyp entspricht Operandentypen (mit Typpromovierung).

**Beispiele:**
```hemlock
let a = 12;  // 1100 in Bin√§r
let b = 10;  // 1010 in Bin√§r

print(a & b);          // 8  (1000)
print(a | b);          // 14 (1110)
print(a ^ b);          // 6  (0110)
print(a << 2);         // 48 (110000)
print(a >> 1);         // 6  (110)
```

**Beispiel mit Unsigned:**
```hemlock
let c: u8 = 15;        // 00001111
let d: u8 = 7;         // 00000111

print(c & d);          // 7  (00000111)
print(c | d);          // 15 (00001111)
print(c ^ d);          // 8  (00001000)
```

**Rechtsverschiebungs-Verhalten:**
- Vorzeichenbehaftete Typen: Arithmetische Verschiebung (Vorzeichenerweiterung)
- Vorzeichenlose Typen: Logische Verschiebung (Null-Fuellung)

---

### Unaere Bitweise

| Operator | Name          | Beispiel | Beschreibung              |
|----------|---------------|----------|---------------------------|
| `~`      | Bitweises NICHT| `~a`    | Alle Bits umkehren        |

**Beispiele:**
```hemlock
let a = 12;            // 00001100 (i32)
print(~a);             // -13 (Zweierkomplement)

let b: u8 = 15;        // 00001111
print(~b);             // 240 (11110000)
```

---

## String-Operatoren

### Verkettung

| Operator | Name        | Beispiel   | Beschreibung        |
|----------|-------------|------------|---------------------|
| `+`      | Verkettung  | `a + b`    | Strings verbinden   |

**Beispiele:**
```hemlock
let s = "hello" + " " + "world";  // "hello world"
let msg = "Count: " + typeof(42); // "Count: 42"

// String + Rune
let greeting = "Hello" + '!';      // "Hello!"

// Rune + String
let prefix = '>' + " Message";     // "> Message"
```

---

## Zuweisungsoperatoren

### Einfache Zuweisung

| Operator | Name       | Beispiel   | Beschreibung                  |
|----------|------------|------------|-------------------------------|
| `=`      | Zuweisung  | `a = b`    | Wert an Variable zuweisen     |

**Beispiele:**
```hemlock
let x = 10;
x = 20;

let arr = [1, 2, 3];
arr[0] = 99;

let obj = { x: 10 };
obj.x = 20;
```

### Zusammengesetzte Zuweisung

#### Arithmetische zusammengesetzte Zuweisung

| Operator | Name               | Beispiel   | √Ñquivalent        |
|----------|--------------------|------------|--------------------|
| `+=`     | Addieren und zuweisen | `a += b` | `a = a + b`        |
| `-=`     | Subtrahieren und zuweisen | `a -= b` | `a = a - b`    |
| `*=`     | Multiplizieren und zuweisen | `a *= b` | `a = a * b`  |
| `/=`     | Dividieren und zuweisen | `a /= b` | `a = a / b`      |
| `%=`     | Modulo und zuweisen | `a %= b`   | `a = a % b`        |

**Beispiele:**
```hemlock
let x = 10;
x += 5;      // x ist jetzt 15
x -= 3;      // x ist jetzt 12
x *= 2;      // x ist jetzt 24
x /= 4;      // x ist jetzt 6

let count = 0;
count += 1;  // Um 1 erh√∂hen
```

#### Bitweise zusammengesetzte Zuweisung

| Operator | Name                      | Beispiel    | √Ñquivalent         |
|----------|---------------------------|-------------|---------------------|
| `&=`     | Bitweises UND und zuweisen | `a &= b`   | `a = a & b`         |
| `\|=`    | Bitweises ODER und zuweisen| `a \|= b`  | `a = a \| b`        |
| `^=`     | Bitweises XOR und zuweisen | `a ^= b`   | `a = a ^ b`         |
| `<<=`    | Linksverschiebung und zuweisen | `a <<= b` | `a = a << b`     |
| `>>=`    | Rechtsverschiebung und zuweisen | `a >>= b` | `a = a >> b`   |

**Beispiele:**
```hemlock
let flags = 0b1111;
flags &= 0b0011;   // flags ist jetzt 0b0011 (obere Bits maskieren)
flags |= 0b1000;   // flags ist jetzt 0b1011 (Bit setzen)
flags ^= 0b0001;   // flags ist jetzt 0b1010 (Bit umschalten)

let x = 1;
x <<= 4;           // x ist jetzt 16 (um 4 nach links verschieben)
x >>= 2;           // x ist jetzt 4 (um 2 nach rechts verschieben)
```

### Inkrement/Dekrement

| Operator | Name       | Beispiel | Beschreibung                  |
|----------|------------|----------|-------------------------------|
| `++`     | Inkrement  | `a++`    | Um 1 erh√∂hen (Postfix)       |
| `--`     | Dekrement  | `a--`    | Um 1 verringern (Postfix)     |

**Beispiele:**
```hemlock
let i = 0;
i++;         // i ist jetzt 1
i++;         // i ist jetzt 2
i--;         // i ist jetzt 1

// H√§ufig in Schleifen
for (let j = 0; j < 10; j++) {
    print(j);
}
```

**Hinweis:** Sowohl `++` als auch `--` sind Postfix-Operatoren (Wert wird vor Inkrement/Dekrement zur√ºckgegeben)

---

## Null-Sicherheitsoperatoren

### Null-Koaleszenz (`??`)

Gibt den linken Operanden zur√ºck wenn er nicht null ist, sonst den rechten Operanden.

| Operator | Name             | Beispiel     | Beschreibung                    |
|----------|------------------|--------------|--------------------------------|
| `??`     | Null-Koaleszenz  | `a ?? b`     | a zur√ºckgeben wenn nicht null, sonst b |

**Beispiele:**
```hemlock
let name = null;
let display = name ?? "Anonym";  // "Anonym"

let value = 42;
let result = value ?? 0;            // 42

// Verkettung
let a = null;
let b = null;
let c = "gefunden";
let result2 = a ?? b ?? c;          // "gefunden"

// Mit Funktionsaufrufen
fn get_config() { return null; }
let config = get_config() ?? { default: true };
```

---

### Optionale Verkettung (`?.`)

Sicherer Zugriff auf Eigenschaften oder Aufruf von Methoden auf potenziell null-Werten.

| Operator | Name                 | Beispiel       | Beschreibung                      |
|----------|----------------------|----------------|-----------------------------------|
| `?.`     | Optionale Verkettung | `a?.b`         | a.b zur√ºckgeben wenn a nicht null, sonst null |
| `?.[`    | Optionaler Index     | `a?.[0]`       | a[0] zur√ºckgeben wenn a nicht null, sonst null |
| `?.(`    | Optionaler Aufruf    | `a?.()`        | a() aufrufen wenn a nicht null, sonst null |

**Beispiele:**
```hemlock
let user = null;
let name = user?.name;              // null (kein Fehler)

let person = { name: "Alice", address: null };
let city = person?.address?.city;   // null (sichere Navigation)

// Mit Arrays
let arr = null;
let first = arr?.[0];               // null

let items = [1, 2, 3];
let second = items?.[1];            // 2

// Mit Methodenaufrufen
let obj = { greet: fn() { return "Hallo"; } };
let greeting = obj?.greet?.();      // "Hallo"

let empty = null;
let result = empty?.method?.();     // null
```

**Verhalten:**
- Wenn linker Operand null, wird gesamter Ausdruck auf null kurzgeschlossen
- Wenn linker Operand nicht null, wird Zugriff normal durchgef√ºhrt
- Kann f√ºr tiefen Eigenschaftszugriff verkettet werden

---

## Elementzugriffsoperatoren

### Punkt-Operator

| Operator | Name               | Beispiel     | Beschreibung           |
|----------|--------------------|--------------|-----------------------|
| `.`      | Elementzugriff     | `obj.field`  | Objektfeld zugreifen   |
| `.`      | Eigenschaftszugriff| `arr.length` | Eigenschaft zugreifen  |

**Beispiele:**
```hemlock
// Objektfeld-Zugriff
let person = { name: "Alice", age: 30 };
print(person.name);        // "Alice"

// Array-Eigenschaft
let arr = [1, 2, 3];
print(arr.length);         // 3

// String-Eigenschaft
let s = "hello";
print(s.length);           // 5

// Methodenaufruf
let result = s.to_upper(); // "HELLO"
```

---

### Index-Operator

| Operator | Name    | Beispiel  | Beschreibung          |
|----------|---------|-----------|----------------------|
| `[]`     | Index   | `arr[i]`  | Element zugreifen     |

**Beispiele:**
```hemlock
// Array-Indizierung
let arr = [10, 20, 30];
print(arr[0]);             // 10
arr[1] = 99;

// String-Indizierung (gibt Rune zur√ºck)
let s = "hello";
print(s[0]);               // 'h'
s[0] = 'H';                // "Hello"

// Buffer-Indizierung
let buf = buffer(10);
buf[0] = 65;
print(buf[0]);             // 65
```

---

## Funktionsaufruf-Operator

| Operator | Name           | Beispiel     | Beschreibung        |
|----------|----------------|--------------|---------------------|
| `()`     | Funktionsaufruf| `f(a, b)`    | Funktion aufrufen   |

**Beispiele:**
```hemlock
fn add(a, b) {
    return a + b;
}

let result = add(5, 3);    // 8

// Methodenaufruf
let s = "hello";
let upper = s.to_upper();  // "HELLO"

// Eingebauter Aufruf
print("message");
```

---

## Operatorpraezedenz

Operatoren von hoechster zu niedrigster Pr√§zedenz:

| Pr√§zedenz | Operatoren                 | Beschreibung                    | Assoziativitaet |
|------------|----------------------------|--------------------------------|----------------|
| 1          | `()` `[]` `.` `?.`         | Aufruf, Index, Elementzugriff, optionale Verkettung | Links-nach-rechts |
| 2          | `++` `--`                  | Postfix-Inkrement/Dekrement    | Links-nach-rechts |
| 3          | `!` `~` `-` (unaer) `+` (unaer) | Logisches NICHT, bitweises NICHT, Negation | Rechts-nach-links |
| 4          | `*` `/` `%`                | Multiplikation, Division, Modulo | Links-nach-rechts |
| 5          | `+` `-`                    | Addition, Subtraktion          | Links-nach-rechts |
| 6          | `<<` `>>`                  | Bitverschiebungen              | Links-nach-rechts |
| 7          | `<` `<=` `>` `>=`          | Relational                     | Links-nach-rechts |
| 8          | `==` `!=`                  | Gleichheit                     | Links-nach-rechts |
| 9          | `&`                        | Bitweises UND                  | Links-nach-rechts |
| 10         | `^`                        | Bitweises XOR                  | Links-nach-rechts |
| 11         | `|`                        | Bitweises ODER                 | Links-nach-rechts |
| 12         | `&&`                       | Logisches UND                  | Links-nach-rechts |
| 13         | `||`                       | Logisches ODER                 | Links-nach-rechts |
| 14         | `??`                       | Null-Koaleszenz                | Links-nach-rechts |
| 15         | `=` `+=` `-=` `*=` `/=` `%=` `&=` `\|=` `^=` `<<=` `>>=` | Zuweisung | Rechts-nach-links |

---

## Pr√§zedenz-Beispiele

### Beispiel 1: Arithmetik und Vergleich
```hemlock
let result = 5 + 3 * 2;
// Ausgewertet als: 5 + (3 * 2) = 11
// Multiplikation hat h√∂here Pr√§zedenz als Addition

let cmp = 10 > 5 + 3;
// Ausgewertet als: 10 > (5 + 3) = true
// Addition hat h√∂here Pr√§zedenz als Vergleich
```

### Beispiel 2: Bitweise Operatoren
```hemlock
let result1 = 12 | 10 & 8;
// Ausgewertet als: 12 | (10 & 8) = 12 | 8 = 12
// & hat h√∂here Pr√§zedenz als |

let result2 = 8 | 1 << 2;
// Ausgewertet als: 8 | (1 << 2) = 8 | 4 = 12
// Verschiebung hat h√∂here Pr√§zedenz als bitweises ODER

// Klammern f√ºr Klarheit verwenden
let result3 = (5 & 3) | (2 << 1);
// Ausgewertet als: 1 | 4 = 5
```

### Beispiel 3: Logische Operatoren
```hemlock
let result = true || false && false;
// Ausgewertet als: true || (false && false) = true
// && hat h√∂here Pr√§zedenz als ||

let cmp = 5 < 10 && 10 < 20;
// Ausgewertet als: (5 < 10) && (10 < 20) = true
// Vergleich hat h√∂here Pr√§zedenz als &&
```

### Beispiel 4: Klammern verwenden
```hemlock
// Ohne Klammern
let a = 2 + 3 * 4;        // 14

// Mit Klammern
let b = (2 + 3) * 4;      // 20

// Komplexer Ausdruck
let c = (a + b) * (a - b);
```

---

## Typspezifisches Operatorverhalten

### Division (immer Gleitkomma)

Der `/`-Operator **gibt immer eine Gleitkommazahl zur√ºck** (f64), unabh√§ngig von Operandentypen:

```hemlock
print(10 / 3);             // 3.333... (f64)
print(5 / 2);              // 2.5 (f64)
print(10.0 / 4.0);         // 2.5 (f64)
print(-7 / 3);             // -2.333... (f64)
```

Dies verhindert den haeufigen Bug unerwarteter Ganzzahl-Trunkierung.

### Ganzzahl-Division (div / divi)

F√ºr Ganzzahl-Division (wie Integer-Division in anderen Sprachen) verwenden Sie die `div()` und `divi()` Funktionen:

```hemlock
// div(a, b) - Ganzzahl-Division gibt Gleitkomma zur√ºck
print(div(5, 2));          // 2 (f64)
print(div(-7, 3));         // -3 (f64)  -- rundet Richtung -unendlich

// divi(a, b) - Ganzzahl-Division gibt Ganzzahl zur√ºck
print(divi(5, 2));         // 2 (i64)
print(divi(-7, 3));        // -3 (i64)
print(typeof(divi(5, 2))); // i64
```

**Ganzzahl-zurueckgebende Mathematikfunktionen:**
F√ºr andere Rundungsoperationen die Ganzzahlen zur√ºckgeben:

```hemlock
print(floori(3.7));        // 3 (i64)
print(ceili(3.2));         // 4 (i64)
print(roundi(3.5));        // 4 (i64)
print(trunci(3.9));        // 3 (i64)

// Diese k√∂nnen direkt als Array-Indizes verwendet werden
let arr = [10, 20, 30, 40];
print(arr[floori(1.9)]);   // 20 (Index 1)
```

### String-Vergleich

Strings werden lexikografisch verglichen:

```hemlock
print("abc" < "def");      // true
print("apple" > "banana"); // false
print("hello" == "hello"); // true
```

### Null-Vergleich

```hemlock
let x = null;

print(x == null);          // true
print(x != null);          // false
```

### Typfehler

Manche Operationen sind zwischen inkompatiblen Typen nicht erlaubt:

```hemlock
// FEHLER: Kann bitweise Operatoren nicht auf Gleitkomma anwenden
let x = 3.14 & 2.71;

// FEHLER: Kann bitweise Operatoren nicht auf Strings anwenden
let y = "hello" & "world";

// OK: Typpromovierung f√ºr Arithmetik
let a: u8 = 10;
let b: i32 = 20;
let c = a + b;             // i32 (promoviert)
```

---

## Siehe auch

- [Typsystem](#reference-type-system) - Typpromovierungs- und Konvertierungsregeln
- [Eingebaute Funktionen](#reference-builtins) - Eingebaute Operationen
- [String-API](#reference-string-api) - String-Verkettung und -Methoden


--------------------------------------------------------------------------------
## Speicher-API
--------------------------------------------------------------------------------

# Speicher-API-Referenz

Vollst√§ndige Referenz f√ºr Hemlocks Speicherverwaltungsfunktionen und Pointer-Typen.

---

## √úbersicht

Hemlock bietet **manuelle Speicherverwaltung** mit expliziter Allokation und Deallokation. Speicher wird durch zwei Pointer-Typen verwaltet: Roh-Pointer (`ptr`) und sichere Buffer (`buffer`).

**Grundprinzipien:**
- Explizite Allokation und Deallokation
- Keine Garbage Collection
- Benutzer verantwortlich f√ºr Aufruf von `free()`
- Interne Referenzzaehlung f√ºr Scope/Neuzuweisungssicherheit (siehe unten)

### Interne Referenzzaehlung

Die Laufzeit verwendet Referenzzaehlung intern zur Verwaltung von Objektlebenszeiten √ºber Scopes. F√ºr die meisten lokalen Variablen ist die Bereinigung automatisch.

**Automatisch (kein `free()` n√∂tig):**
- Lokale Variablen von referenzgezaehlten Typen (buffer, array, object, string) werden freigegeben wenn Scope endet
- Alte Werte werden freigegeben wenn Variablen neu zugewiesen werden
- Container-Elemente werden freigegeben wenn Container freigegeben werden

**Manuelles `free()` erforderlich:**
- Roh-Pointer von `alloc()` - immer
- Fruehe Bereinigung vor Scope-Ende
- Langlebige/globale Daten

Siehe [Speicherverwaltungs-Leitfaden](../language-guide/memory.md#internal-reference-counting) f√ºr Details.

---

## Pointer-Typen

### ptr (Roh-Pointer)

**Typ:** `ptr`

**Beschreibung:** Rohe Speicheradresse ohne Grenzenpr√ºfung oder Verfolgung.

**Gr√∂√üe:** 8 Bytes

**Anwendungsfaelle:**
- Low-Level-Speicheroperationen
- FFI (Foreign Function Interface)
- Maximale Leistung (kein Overhead)

**Sicherheit:** Unsicher - keine Grenzenpr√ºfung, Benutzer muss Lebensdauer verfolgen

**Beispiele:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

---

### buffer (Sicherer Buffer)

**Typ:** `buffer`

**Beschreibung:** Sicherer Pointer-Wrapper mit Grenzenpr√ºfung.

**Struktur:** Pointer + L√§nge + Kapazit√§t + Referenzzaehler

**Eigenschaften:**
- `.length` - Buffergroesse (i32)
- `.capacity` - Allokierte Kapazit√§t (i32)

**Anwendungsfaelle:**
- Die meisten Speicherallokationen
- Wenn Sicherheit wichtig ist
- Dynamische Arrays

**Sicherheit:** Grenzenpr√ºfung bei Indexzugriff

**Referenzzaehlung:** Buffer sind intern referenzgez√§hlt. Automatisch freigegeben wenn Scope endet oder Variable neu zugewiesen wird. Verwenden Sie `free()` f√ºr fruehe Bereinigung oder langlebige Daten.

**Beispiele:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // Grenzenpr√ºfung
print(b.length);        // 64
free(b);
```

---

## Speicherallokationsfunktionen

### alloc

Allokiert Roh-Speicher.

**Signatur:**
```hemlock
alloc(size: i32): ptr
```

**Parameter:**
- `size` - Anzahl der zu allokierenden Bytes

**R√ºckgabe:** Pointer zum allokierten Speicher (`ptr`)

**Beispiele:**
```hemlock
let p = alloc(1024);        // 1KB allokieren
memset(p, 0, 1024);         // Auf Null initialisieren
free(p);                    // Wenn fertig freigeben

// F√ºr Struktur allokieren
let struct_size = 16;
let p2 = alloc(struct_size);
```

**Verhalten:**
- Gibt uninitialisierten Speicher zur√ºck
- Speicher muss manuell freigegeben werden
- Gibt `null` bei Allokationsfehler zur√ºck (Aufrufer muss pr√ºfen)

**Siehe auch:** `buffer()` f√ºr sicherere Alternative

---

### buffer

Allokiert sicheren Buffer mit Grenzenpr√ºfung.

**Signatur:**
```hemlock
buffer(size: i32): buffer
```

**Parameter:**
- `size` - Buffergroesse in Bytes

**R√ºckgabe:** Buffer-Objekt

**Beispiele:**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256
print(buf.capacity);        // 256

// Zugriff mit Grenzenpr√ºfung
buf[0] = 65;                // 'A'
buf[255] = 90;              // 'Z'
// buf[256] = 0;            // FEHLER: au√üerhalb der Grenzen

free(buf);
```

**Eigenschaften:**
- `.length` - Aktuelle Gr√∂√üe (i32)
- `.capacity` - Allokierte Kapazit√§t (i32)

**Verhalten:**
- Initialisiert Speicher auf Null
- Bietet Grenzenpr√ºfung bei Indexzugriff
- Gibt `null` bei Allokationsfehler zur√ºck (Aufrufer muss pr√ºfen)
- Muss manuell freigegeben werden

---

### free

Gibt allokierten Speicher frei.

**Signatur:**
```hemlock
free(ptr: ptr | buffer): null
```

**Parameter:**
- `ptr` - Pointer oder Buffer zum Freigeben

**R√ºckgabe:** `null`

**Beispiele:**
```hemlock
// Roh-Pointer freigeben
let p = alloc(1024);
free(p);

// Buffer freigeben
let buf = buffer(256);
free(buf);
```

**Verhalten:**
- Gibt mit `alloc()` oder `buffer()` allokierten Speicher frei
- Doppeltes Freigeben verursacht Absturz (Benutzerverantwortung zu vermeiden)
- Freigeben ung√ºltiger Pointer verursacht undefiniertes Verhalten

**Wichtig:** Was Sie allokieren, geben Sie frei. Keine automatische Bereinigung.

---

### realloc

Aendert Gr√∂√üe von allokiertem Speicher.

**Signatur:**
```hemlock
realloc(ptr: ptr, new_size: i32): ptr
```

**Parameter:**
- `ptr` - Pointer zur Groessenaenderung
- `new_size` - Neue Gr√∂√üe in Bytes

**R√ºckgabe:** Pointer zum vergroesserten Speicher (kann andere Adresse sein)

**Beispiele:**
```hemlock
let p = alloc(100);
// ... Speicher verwenden ...

// Mehr Platz ben√∂tigt
p = realloc(p, 200);        // Jetzt 200 Bytes
// ... erweiterten Speicher verwenden ...

free(p);
```

**Verhalten:**
- Kann Speicher an neue Position verschieben
- Erh√§lt vorhandene Daten (bis Minimum aus alter/neuer Gr√∂√üe)
- Alter Pointer ist nach erfolgreichem realloc ung√ºltig (zurueckgegebenen Pointer verwenden)
- Wenn new_size kleiner, werden Daten abgeschnitten
- Gibt `null` bei Allokationsfehler zur√ºck (Original-Pointer bleibt g√ºltig)

**Wichtig:** Immer auf `null` pr√ºfen und Pointer-Variable mit Ergebnis aktualisieren.

---

## Speicheroperationen

### memset

Fuellt Speicher mit Byte-Wert.

**Signatur:**
```hemlock
memset(ptr: ptr, byte: i32, size: i32): null
```

**Parameter:**
- `ptr` - Pointer zum Speicher
- `byte` - Byte-Wert zum Fuellen (0-255)
- `size` - Anzahl der zu fuellenden Bytes

**R√ºckgabe:** `null`

**Beispiele:**
```hemlock
let p = alloc(100);

// Speicher nullen
memset(p, 0, 100);

// Mit bestimmtem Wert fuellen
memset(p, 0xFF, 100);

// Buffer initialisieren
let buf = alloc(256);
memset(buf, 65, 256);       // Mit 'A' fuellen

free(p);
free(buf);
```

**Verhalten:**
- Schreibt Byte-Wert in jedes Byte im Bereich
- Byte-Wert wird auf 8 Bits abgeschnitten (0-255)
- Keine Grenzenpr√ºfung (unsicher)

---

### memcpy

Kopiert Speicher von Quelle zu Ziel.

**Signatur:**
```hemlock
memcpy(dest: ptr, src: ptr, size: i32): null
```

**Parameter:**
- `dest` - Ziel-Pointer
- `src` - Quell-Pointer
- `size` - Anzahl der zu kopierenden Bytes

**R√ºckgabe:** `null`

**Beispiele:**
```hemlock
let src = alloc(100);
let dest = alloc(100);

// Quelle initialisieren
memset(src, 65, 100);

// Zum Ziel kopieren
memcpy(dest, src, 100);

// dest enth√§lt jetzt gleiche Daten wie src

free(src);
free(dest);
```

**Verhalten:**
- Kopiert Byte f√ºr Byte von src zu dest
- Keine Grenzenpr√ºfung (unsicher)
- Ueberlappende Bereiche haben undefiniertes Verhalten (vorsichtig verwenden)

---

## Typisierte Speicheroperationen

### sizeof

Gibt Gr√∂√üe eines Typs in Bytes zur√ºck.

**Signatur:**
```hemlock
sizeof(type): i32
```

**Parameter:**
- `type` - Typ-Bezeichner (z.B. `i32`, `f64`, `ptr`)

**R√ºckgabe:** Gr√∂√üe in Bytes (i32)

**Typgroessen:**

| Typ | Gr√∂√üe (Bytes) |
|-----|-----------------|
| `i8` | 1 |
| `i16` | 2 |
| `i32`, `integer` | 4 |
| `i64` | 8 |
| `u8`, `byte` | 1 |
| `u16` | 2 |
| `u32` | 4 |
| `u64` | 8 |
| `f32` | 4 |
| `f64`, `number` | 8 |
| `bool` | 1 |
| `ptr` | 8 |
| `rune` | 4 |

**Beispiele:**
```hemlock
let int_size = sizeof(i32);      // 4
let ptr_size = sizeof(ptr);      // 8
let float_size = sizeof(f64);    // 8
let byte_size = sizeof(u8);      // 1
let rune_size = sizeof(rune);    // 4

// Array-Allokationsgroesse berechnen
let count = 100;
let total = sizeof(i32) * count; // 400 Bytes
```

**Verhalten:**
- Gibt 0 f√ºr unbekannte Typen zur√ºck
- Akzeptiert sowohl Typ-Bezeichner als auch Typ-Strings

---

### talloc

Allokiert Array von typisierten Werten.

**Signatur:**
```hemlock
talloc(type, count: i32): ptr
```

**Parameter:**
- `type` - Zu allokierender Typ (z.B. `i32`, `f64`, `ptr`)
- `count` - Anzahl der Elemente (muss positiv sein)

**R√ºckgabe:** Pointer zum allokierten Array, oder `null` bei Allokationsfehler

**Beispiele:**
```hemlock
let arr = talloc(i32, 100);      // Array von 100 i32s (400 Bytes)
let floats = talloc(f64, 50);    // Array von 50 f64s (400 Bytes)
let bytes = talloc(u8, 1024);    // Array von 1024 Bytes

// Immer auf Allokationsfehler pr√ºfen
if (arr == null) {
    panic("Allokation fehlgeschlagen");
}

// Allokierten Speicher verwenden
// ...

free(arr);
free(floats);
free(bytes);
```

**Verhalten:**
- Allokiert `sizeof(type) * count` Bytes
- Gibt uninitialisierten Speicher zur√ºck
- Speicher muss manuell mit `free()` freigegeben werden
- Gibt `null` bei Allokationsfehler zur√ºck (Aufrufer muss pr√ºfen)
- Bricht ab wenn count nicht positiv ist

---

## Buffer-Eigenschaften

### .length

Gibt Buffergroesse zur√ºck.

**Typ:** `i32`

**Zugriff:** Nur-Lesen

**Beispiele:**
```hemlock
let buf = buffer(256);
print(buf.length);          // 256

let buf2 = buffer(1024);
print(buf2.length);         // 1024
```

---

### .capacity

Gibt Bufferkapazitaet zur√ºck.

**Typ:** `i32`

**Zugriff:** Nur-Lesen

**Beispiele:**
```hemlock
let buf = buffer(256);
print(buf.capacity);        // 256
```

**Hinweis:** Derzeit sind `.length` und `.capacity` f√ºr mit `buffer()` erstellte Buffer gleich.

---

## Verwendungsmuster

### Grundlegendes Allokationsmuster

```hemlock
// Allokieren
let p = alloc(1024);
if (p == null) {
    panic("Allokation fehlgeschlagen");
}

// Verwenden
memset(p, 0, 1024);

// Freigeben
free(p);
```

### Sicheres Buffer-Muster

```hemlock
// Buffer allokieren
let buf = buffer(256);
if (buf == null) {
    panic("Buffer-Allokation fehlgeschlagen");
}

// Mit Grenzenpr√ºfung verwenden
let i = 0;
while (i < buf.length) {
    buf[i] = i;
    i = i + 1;
}

// Freigeben
free(buf);
```

### Dynamisches Wachstumsmuster

```hemlock
let size = 100;
let p = alloc(size);
if (p == null) {
    panic("Allokation fehlgeschlagen");
}

// ... Speicher verwenden ...

// Mehr Platz ben√∂tigt - auf Fehler pr√ºfen
let new_p = realloc(p, 200);
if (new_p == null) {
    // Original-Pointer noch g√ºltig, aufraeumen
    free(p);
    panic("Realloc fehlgeschlagen");
}
p = new_p;
size = 200;

// ... erweiterten Speicher verwenden ...

free(p);
```

### Speicherkopie-Muster

```hemlock
let original = alloc(100);
memset(original, 65, 100);

// Kopie erstellen
let copy = alloc(100);
memcpy(copy, original, 100);

free(original);
free(copy);
```

---

## Sicherheitsueberlegungen

**Hemlocks Speicherverwaltung ist UNSICHER by Design:**

### H√§ufige Fallstricke

**1. Speicherlecks**
```hemlock
// SCHLECHT: Speicherleck
fn create_buffer() {
    let p = alloc(1024);
    return null;  // Speicher geleakt!
}

// GUT: Ordnungsgemaesse Bereinigung
fn create_buffer() {
    let p = alloc(1024);
    // ... Speicher verwenden ...
    free(p);
    return null;
}
```

**2. Verwendung nach Freigabe**
```hemlock
// SCHLECHT: Verwendung nach Freigabe
let p = alloc(100);
free(p);
memset(p, 0, 100);  // ABSTURZ: Verwendung von freigegebenem Speicher

// GUT: Nach Freigabe nicht verwenden
let p2 = alloc(100);
memset(p2, 0, 100);
free(p2);
// p2 nach hier nicht beruehren
```

**3. Doppelte Freigabe**
```hemlock
// SCHLECHT: Doppelte Freigabe
let p = alloc(100);
free(p);
free(p);  // ABSTURZ: Doppelte Freigabe

// GUT: Einmal freigeben
let p2 = alloc(100);
free(p2);
```

**4. Buffer-√úberlauf (ptr)**
```hemlock
// SCHLECHT: Buffer-√úberlauf mit ptr
let p = alloc(10);
memset(p, 65, 100);  // ABSTURZ: Schreiben √ºber Allokation hinaus

// GUT: Buffer f√ºr Grenzenpr√ºfung verwenden
let buf = buffer(10);
// buf[100] = 65;  // FEHLER: Grenzenpr√ºfung schlaegt fehl
```

**5. Haengende Pointer**
```hemlock
// SCHLECHT: Haengender Pointer
let p1 = alloc(100);
let p2 = p1;
free(p1);
memset(p2, 0, 100);  // ABSTURZ: p2 haengt

// GUT: Eigentum sorgfaeltig verfolgen
let p = alloc(100);
// ... p verwenden ...
free(p);
// Keine anderen Referenzen auf p behalten
```

**6. Ungepr√ºfter Allokationsfehler**
```hemlock
// SCHLECHT: Nicht auf null pr√ºfen
let p = alloc(1000000000);  // Kann bei wenig Speicher fehlschlagen
memset(p, 0, 1000000000);   // ABSTURZ: p ist null

// GUT: Immer Allokationsergebnis pr√ºfen
let p2 = alloc(1000000000);
if (p2 == null) {
    panic("Speicher erschoepft");
}
memset(p2, 0, 1000000000);
free(p2);
```

---

## Wann was verwenden

### `buffer()` verwenden wenn:
- Sie Grenzenpr√ºfung ben√∂tigen
- Mit dynamischen Daten arbeiten
- Sicherheit wichtig ist
- Hemlock lernen

### `alloc()` verwenden wenn:
- Maximale Leistung ben√∂tigt
- FFI/Schnittstelle zu C
- Sie exaktes Speicherlayout kennen
- Sie ein Experte sind

### `realloc()` verwenden wenn:
- Allokationen vergroessern/verkleinern
- Dynamische Arrays
- Sie Daten erhalten m√ºssen

---

## Vollst√§ndige Funktionsuebersicht

| Funktion  | Signatur                               | R√ºckgabe | Beschreibung               |
|-----------|----------------------------------------|-----------|----------------------------|
| `alloc`   | `(size: i32)`                          | `ptr`     | Roh-Speicher allokieren    |
| `buffer`  | `(size: i32)`                          | `buffer`  | Sicheren Buffer allokieren |
| `free`    | `(ptr: ptr \| buffer)`                 | `null`    | Speicher freigeben         |
| `realloc` | `(ptr: ptr, new_size: i32)`            | `ptr`     | Allokation vergroessern    |
| `memset`  | `(ptr: ptr, byte: i32, size: i32)`     | `null`    | Speicher fuellen           |
| `memcpy`  | `(dest: ptr, src: ptr, size: i32)`     | `null`    | Speicher kopieren          |
| `sizeof`  | `(type)`                               | `i32`     | Typgroesse in Bytes holen  |
| `talloc`  | `(type, count: i32)`                   | `ptr`     | Typisiertes Array allokieren |

---

## Siehe auch

- [Typsystem](#reference-type-system) - Pointer- und Buffer-Typen
- [Eingebaute Funktionen](#reference-builtins) - Alle eingebauten Funktionen
- [String-API](#reference-string-api) - String `.to_bytes()`-Methode


--------------------------------------------------------------------------------
## String-API
--------------------------------------------------------------------------------

# String-API-Referenz

Vollst√§ndige Referenz f√ºr Hemlocks String-Typ und alle 19 String-Methoden.

---

## √úbersicht

Strings in Hemlock sind **UTF-8-kodierte, veraenderbare, heap-allokierte** Sequenzen mit vollstaendiger Unicode-Unterst√ºtzung. Alle Operationen arbeiten mit **Codepoints** (Zeichen), nicht Bytes.

**Hauptmerkmale:**
- UTF-8-Kodierung (U+0000 bis U+10FFFF)
- Veraenderbar (kann Zeichen direkt √§ndern)
- Codepoint-basierte Indizierung
- 19 eingebaute Methoden
- Automatische Verkettung mit `+`-Operator

---

## String-Typ

**Typ:** `string`

**Eigenschaften:**
- `.length` - Anzahl der Codepoints (Zeichen)
- `.byte_length` - Anzahl der UTF-8-Bytes

**Literal-Syntax:** Doppelte Anf√ºhrungszeichen `"text"`

**Beispiele:**
```hemlock
let s = "hello";
print(s.length);        // 5 (Codepoints)
print(s.byte_length);   // 5 (Bytes)

let emoji = "üöÄ";
print(emoji.length);        // 1 (ein Codepoint)
print(emoji.byte_length);   // 4 (vier UTF-8-Bytes)
```

---

## Indizierung

Strings unterst√ºtzen Codepoint-basierte Indizierung mit `[]`:

**Lesezugriff:**
```hemlock
let s = "hello";
let ch = s[0];          // Gibt Rune 'h' zur√ºck
```

**Schreibzugriff:**
```hemlock
let s = "hello";
s[0] = 'H';             // Mit Rune √§ndern (jetzt "Hello")
```

**UTF-8-Beispiel:**
```hemlock
let text = "HiüöÄ!";
print(text[0]);         // 'H'
print(text[1]);         // 'i'
print(text[2]);         // 'üöÄ' (ein Codepoint)
print(text[3]);         // '!'
```

---

## Verkettung

Verwenden Sie den `+`-Operator um Strings und Runes zu verketten:

**String + String:**
```hemlock
let s = "hello" + " " + "world";  // "hello world"
let msg = "Count: " + typeof(42); // "Count: 42"
```

**String + Rune:**
```hemlock
let greeting = "Hello" + '!';      // "Hello!"
let decorated = "Text" + '‚úì';      // "Text‚úì"
```

**Rune + String:**
```hemlock
let prefix = '>' + " Message";     // "> Message"
let bullet = '‚Ä¢' + " Item";        // "‚Ä¢ Item"
```

**Mehrfache Verkettungen:**
```hemlock
let msg = "Hi " + 'üëã' + " World " + 'üåç';  // "Hi üëã World üåç"
```

---

## String-Eigenschaften

### .length

Gibt die Anzahl der Unicode-Codepoints (Zeichen) zur√ºck.

**Typ:** `i32`

**Beispiele:**
```hemlock
let s = "hello";
print(s.length);        // 5

let emoji = "üöÄ";
print(emoji.length);    // 1 (ein Codepoint)

let text = "Hello üåç!";
print(text.length);     // 8 (7 ASCII + 1 Emoji)
```

---

### .byte_length

Gibt die Anzahl der UTF-8-Bytes zur√ºck.

**Typ:** `i32`

**Beispiele:**
```hemlock
let s = "hello";
print(s.byte_length);   // 5 (1 Byte pro ASCII-Zeichen)

let emoji = "üöÄ";
print(emoji.byte_length); // 4 (Emoji ist 4 UTF-8-Bytes)

let text = "Hello üåç!";
print(text.byte_length);  // 11 (7 ASCII + 4 f√ºr Emoji)
```

---

## String-Methoden

### Teilstring & Slicing

#### substr

Extrahiert Teilstring nach Position und L√§nge.

**Signatur:**
```hemlock
string.substr(start: i32, length: i32): string
```

**Parameter:**
- `start` - Start-Codepoint-Index (nullbasiert)
- `length` - Anzahl der zu extrahierenden Codepoints

**R√ºckgabe:** Neuer String

**Beispiele:**
```hemlock
let s = "hello world";
let sub = s.substr(6, 5);       // "world"
let first = s.substr(0, 5);     // "hello"

// UTF-8-Beispiel
let text = "HiüöÄ!";
let emoji = text.substr(2, 1);  // "üöÄ"
```

---

#### slice

Extrahiert Teilstring nach Bereich (Ende exklusiv).

**Signatur:**
```hemlock
string.slice(start: i32, end: i32): string
```

**Parameter:**
- `start` - Start-Codepoint-Index (nullbasiert)
- `end` - End-Codepoint-Index (exklusiv)

**R√ºckgabe:** Neuer String

**Beispiele:**
```hemlock
let s = "hello world";
let sub = s.slice(0, 5);        // "hello"
let world = s.slice(6, 11);     // "world"

// UTF-8-Beispiel
let text = "HiüöÄ!";
let first_three = text.slice(0, 3);  // "HiüöÄ"
```

---

### Suchen & Finden

#### find

Findet erstes Vorkommen eines Teilstrings.

**Signatur:**
```hemlock
string.find(needle: string): i32
```

**Parameter:**
- `needle` - Zu suchender Teilstring

**R√ºckgabe:** Codepoint-Index des ersten Vorkommens, oder `-1` wenn nicht gefunden

**Beispiele:**
```hemlock
let s = "hello world";
let pos = s.find("world");      // 6
let pos2 = s.find("foo");       // -1 (nicht gefunden)
let pos3 = s.find("l");         // 2 (erstes 'l')
```

---

#### contains

Prueft ob String Teilstring enth√§lt.

**Signatur:**
```hemlock
string.contains(needle: string): bool
```

**Parameter:**
- `needle` - Zu suchender Teilstring

**R√ºckgabe:** `true` wenn gefunden, `false` sonst

**Beispiele:**
```hemlock
let s = "hello world";
let has = s.contains("world");  // true
let has2 = s.contains("foo");   // false
```

---

### Teilen & Verbinden

#### split

Teilt String in Array nach Trennzeichen.

**Signatur:**
```hemlock
string.split(delimiter: string): array
```

**Parameter:**
- `delimiter` - String zum Teilen

**R√ºckgabe:** Array von Strings

**Beispiele:**
```hemlock
let csv = "a,b,c";
let parts = csv.split(",");     // ["a", "b", "c"]

let path = "/usr/local/bin";
let dirs = path.split("/");     // ["", "usr", "local", "bin"]

let text = "hello world foo";
let words = text.split(" ");    // ["hello", "world", "foo"]
```

---

#### trim

Entfernt f√ºhrende und nachfolgende Leerzeichen.

**Signatur:**
```hemlock
string.trim(): string
```

**R√ºckgabe:** Neuer String ohne Leerzeichen

**Beispiele:**
```hemlock
let s = "  hello  ";
let clean = s.trim();           // "hello"

let text = "\n\t  world  \n";
let clean2 = text.trim();       // "world"
```

---

### Gro√ü-/Kleinschreibung

#### to_upper

Konvertiert String zu Grossbuchstaben.

**Signatur:**
```hemlock
string.to_upper(): string
```

**R√ºckgabe:** Neuer String in Grossbuchstaben

**Beispiele:**
```hemlock
let s = "hello world";
let upper = s.to_upper();       // "HELLO WORLD"

let mixed = "HeLLo";
let upper2 = mixed.to_upper();  // "HELLO"
```

---

#### to_lower

Konvertiert String zu Kleinbuchstaben.

**Signatur:**
```hemlock
string.to_lower(): string
```

**R√ºckgabe:** Neuer String in Kleinbuchstaben

**Beispiele:**
```hemlock
let s = "HELLO WORLD";
let lower = s.to_lower();       // "hello world"

let mixed = "HeLLo";
let lower2 = mixed.to_lower();  // "hello"
```

---

### Pr√§fix & Suffix

#### starts_with

Prueft ob String mit Pr√§fix beginnt.

**Signatur:**
```hemlock
string.starts_with(prefix: string): bool
```

**Parameter:**
- `prefix` - Zu pruefendes Pr√§fix

**R√ºckgabe:** `true` wenn String mit Pr√§fix beginnt, `false` sonst

**Beispiele:**
```hemlock
let s = "hello world";
let starts = s.starts_with("hello");  // true
let starts2 = s.starts_with("world"); // false
```

---

#### ends_with

Prueft ob String mit Suffix endet.

**Signatur:**
```hemlock
string.ends_with(suffix: string): bool
```

**Parameter:**
- `suffix` - Zu pruefendes Suffix

**R√ºckgabe:** `true` wenn String mit Suffix endet, `false` sonst

**Beispiele:**
```hemlock
let s = "hello world";
let ends = s.ends_with("world");      // true
let ends2 = s.ends_with("hello");     // false
```

---

### Ersetzen

#### replace

Ersetzt erstes Vorkommen eines Teilstrings.

**Signatur:**
```hemlock
string.replace(old: string, new: string): string
```

**Parameter:**
- `old` - Zu ersetzender Teilstring
- `new` - Ersetzungsstring

**R√ºckgabe:** Neuer String mit erstem Vorkommen ersetzt

**Beispiele:**
```hemlock
let s = "hello world";
let s2 = s.replace("world", "there");  // "hello there"

let text = "foo foo foo";
let text2 = text.replace("foo", "bar"); // "bar foo foo" (nur erstes)
```

---

#### replace_all

Ersetzt alle Vorkommen eines Teilstrings.

**Signatur:**
```hemlock
string.replace_all(old: string, new: string): string
```

**Parameter:**
- `old` - Zu ersetzender Teilstring
- `new` - Ersetzungsstring

**R√ºckgabe:** Neuer String mit allen Vorkommen ersetzt

**Beispiele:**
```hemlock
let text = "foo foo foo";
let text2 = text.replace_all("foo", "bar"); // "bar bar bar"

let s = "hello world hello";
let s2 = s.replace_all("hello", "hi");      // "hi world hi"
```

---

### Wiederholung

#### repeat

Wiederholt String n-mal.

**Signatur:**
```hemlock
string.repeat(count: i32): string
```

**Parameter:**
- `count` - Anzahl der Wiederholungen

**R√ºckgabe:** Neuer String count-mal wiederholt

**Beispiele:**
```hemlock
let s = "ha";
let repeated = s.repeat(3);     // "hahaha"

let line = "-";
let separator = line.repeat(40); // "----------------------------------------"
```

---

### Zeichenzugriff

#### char_at

Gibt Unicode-Codepoint am Index zur√ºck.

**Signatur:**
```hemlock
string.char_at(index: i32): rune
```

**Parameter:**
- `index` - Codepoint-Index (nullbasiert)

**R√ºckgabe:** Rune (Unicode-Codepoint)

**Beispiele:**
```hemlock
let s = "hello";
let ch = s.char_at(0);          // 'h'
let ch2 = s.char_at(1);         // 'e'

// UTF-8-Beispiel
let emoji = "üöÄ";
let ch3 = emoji.char_at(0);     // U+1F680 (Rakete)
```

---

#### chars

Konvertiert String zu Array von Runes.

**Signatur:**
```hemlock
string.chars(): array
```

**R√ºckgabe:** Array von Runes (Codepoints)

**Beispiele:**
```hemlock
let s = "hello";
let chars = s.chars();          // ['h', 'e', 'l', 'l', 'o']

// UTF-8-Beispiel
let text = "HiüöÄ!";
let chars2 = text.chars();      // ['H', 'i', 'üöÄ', '!']
```

---

### Byte-Zugriff

#### byte_at

Gibt Byte-Wert am Index zur√ºck.

**Signatur:**
```hemlock
string.byte_at(index: i32): u8
```

**Parameter:**
- `index` - Byte-Index (nullbasiert, NICHT Codepoint-Index)

**R√ºckgabe:** Byte-Wert (u8)

**Beispiele:**
```hemlock
let s = "hello";
let byte = s.byte_at(0);        // 104 (ASCII 'h')
let byte2 = s.byte_at(1);       // 101 (ASCII 'e')

// UTF-8-Beispiel
let emoji = "üöÄ";
let byte3 = emoji.byte_at(0);   // 240 (erstes UTF-8-Byte)
```

---

#### bytes

Konvertiert String zu Array von Bytes.

**Signatur:**
```hemlock
string.bytes(): array
```

**R√ºckgabe:** Array von u8-Bytes

**Beispiele:**
```hemlock
let s = "hello";
let bytes = s.bytes();          // [104, 101, 108, 108, 111]

// UTF-8-Beispiel
let emoji = "üöÄ";
let bytes2 = emoji.bytes();     // [240, 159, 154, 128] (4 UTF-8-Bytes)
```

---

#### to_bytes

Konvertiert String zu Buffer.

**Signatur:**
```hemlock
string.to_bytes(): buffer
```

**R√ºckgabe:** Buffer mit UTF-8-Bytes

**Beispiele:**
```hemlock
let s = "hello";
let buf = s.to_bytes();
print(buf.length);              // 5

// UTF-8-Beispiel
let emoji = "üöÄ";
let buf2 = emoji.to_bytes();
print(buf2.length);             // 4
```

**Hinweis:** Dies ist eine Legacy-Methode. Bevorzugen Sie `.bytes()` f√ºr die meisten Anwendungsfaelle.

---

### JSON-Deserialisierung

#### deserialize

Parst JSON-String zu Wert.

**Signatur:**
```hemlock
string.deserialize(): any
```

**R√ºckgabe:** Geparster Wert (Objekt, Array, Zahl, String, Bool oder null)

**Beispiele:**
```hemlock
let json = '{"x":10,"y":20}';
let obj = json.deserialize();
print(obj.x);                   // 10
print(obj.y);                   // 20

let arr_json = '[1,2,3]';
let arr = arr_json.deserialize();
print(arr[0]);                  // 1

let num_json = '42';
let num = num_json.deserialize();
print(num);                     // 42
```

**Unterstuetzte Typen:**
- Objekte: `{"key": value}`
- Arrays: `[1, 2, 3]`
- Zahlen: `42`, `3.14`
- Strings: `"text"`
- Booleans: `true`, `false`
- Null: `null`

**Siehe auch:** Objekt `.serialize()`-Methode

---

## Methoden-Verkettung

String-Methoden k√∂nnen f√ºr praegnante Operationen verkettet werden:

**Beispiele:**
```hemlock
let result = "  Hello World  "
    .trim()
    .to_lower()
    .replace("world", "hemlock");  // "hello hemlock"

let processed = "foo,bar,baz"
    .split(",")
    .join(" | ");                  // "foo | bar | baz"

let cleaned = "  HELLO  "
    .trim()
    .to_lower();                   // "hello"
```

---

## Vollst√§ndige Methodenuebersicht

| Methode        | Signatur                                     | R√ºckgabe | Beschreibung                          |
|----------------|----------------------------------------------|-----------|---------------------------------------|
| `substr`       | `(start: i32, length: i32)`                  | `string`  | Teilstring nach Position/L√§nge extrahieren |
| `slice`        | `(start: i32, end: i32)`                     | `string`  | Teilstring nach Bereich extrahieren   |
| `find`         | `(needle: string)`                           | `i32`     | Erstes Vorkommen finden (-1 wenn nicht gefunden) |
| `contains`     | `(needle: string)`                           | `bool`    | Pr√ºfen ob Teilstring enthalten       |
| `split`        | `(delimiter: string)`                        | `array`   | In Array teilen                       |
| `trim`         | `()`                                         | `string`  | Leerzeichen entfernen                 |
| `to_upper`     | `()`                                         | `string`  | Zu Grossbuchstaben konvertieren       |
| `to_lower`     | `()`                                         | `string`  | Zu Kleinbuchstaben konvertieren       |
| `starts_with`  | `(prefix: string)`                           | `bool`    | Pr√ºfen ob mit Pr√§fix beginnt        |
| `ends_with`    | `(suffix: string)`                           | `bool`    | Pr√ºfen ob mit Suffix endet           |
| `replace`      | `(old: string, new: string)`                 | `string`  | Erstes Vorkommen ersetzen             |
| `replace_all`  | `(old: string, new: string)`                 | `string`  | Alle Vorkommen ersetzen               |
| `repeat`       | `(count: i32)`                               | `string`  | String n-mal wiederholen              |
| `char_at`      | `(index: i32)`                               | `rune`    | Codepoint am Index holen              |
| `byte_at`      | `(index: i32)`                               | `u8`      | Byte am Index holen                   |
| `chars`        | `()`                                         | `array`   | Zu Array von Runes konvertieren       |
| `bytes`        | `()`                                         | `array`   | Zu Array von Bytes konvertieren       |
| `to_bytes`     | `()`                                         | `buffer`  | Zu Buffer konvertieren (Legacy)       |
| `deserialize`  | `()`                                         | `any`     | JSON-String parsen                    |

---

## Siehe auch

- [Typsystem](#reference-type-system) - String-Typ-Details
- [Array-API](#reference-array-api) - Array-Methoden f√ºr split()-Ergebnisse
- [Operatoren](#reference-operators) - String-Verkettungsoperator


--------------------------------------------------------------------------------
## Typsystem
--------------------------------------------------------------------------------

# Typsystem-Referenz

Vollst√§ndige Referenz f√ºr Hemlocks Typsystem, einschlie√ülich aller primitiven und zusammengesetzten Typen.

---

## √úbersicht

Hemlock verwendet ein **dynamisches Typsystem** mit Laufzeit-Typ-Tags und optionalen Typannotationen. Jeder Wert hat einen Laufzeittyp, und Typkonvertierungen folgen expliziten Promovierungsregeln.

**Hauptmerkmale:**
- Laufzeit-Typpr√ºfung (Interpreter)
- Kompilierzeit-Typpr√ºfung (hemlockc - standardm√§√üig aktiviert)
- Optionale Typannotationen
- Automatische Typinferenz f√ºr Literale
- Explizite Typpromovierungsregeln
- Keine impliziten Konvertierungen die Pr√§zision verlieren

---

## Kompilierzeit-Typpr√ºfung (hemlockc)

Der Hemlock-Compiler (`hemlockc`) enth√§lt einen Kompilierzeit-Typchecker der Ihren Code vor der Generierung von ausfuehrbaren Dateien validiert. Dies erkennt Typfehler frueh ohne das Programm ausf√ºhren zu m√ºssen.

### Standardverhalten

Typpr√ºfung ist in hemlockc **standardm√§√üig aktiviert**:

```bash
# Typpr√ºfung erfolgt automatisch
hemlockc program.hml -o program

# Fehler werden vor Kompilierung gemeldet
hemlockc bad_types.hml
# Ausgabe: 1 Typfehler gefunden
```

### Compiler-Flags

| Flag | Beschreibung |
|------|--------------|
| `--check` | Nur Typen pr√ºfen, nicht kompilieren (nach Validierung beenden) |
| `--no-type-check` | Typpr√ºfung deaktivieren (nicht empfohlen) |
| `--strict-types` | Strengere Typwarnungen aktivieren |

**Beispiele:**

```bash
# Nur Typen validieren ohne zu kompilieren
hemlockc --check program.hml
# Ausgabe: program.hml: keine Typfehler

# Typpr√ºfung deaktivieren (mit Vorsicht verwenden)
hemlockc --no-type-check dynamic_code.hml -o program

# Strenge Warnungen f√ºr implizite any-Typen aktivieren
hemlockc --strict-types program.hml -o program
```

### Was der Typchecker validiert

1. **Typannotationen** - Stellt sicher dass zugewiesene Werte deklarierten Typen entsprechen
2. **Funktionsaufrufe** - Validiert Argumenttypen gegen Parametertypen
3. **Rueckgabetypen** - Prueft ob return-Anweisungen deklariertem R√ºckgabetyp entsprechen
4. **Operatorverwendung** - Verifiziert dass Operanden kompatibel sind
5. **Eigenschaftszugriff** - Validiert Objektfeldtypen f√ºr typisierte Objekte

### Tolerante numerische Konvertierungen

Der Typchecker erlaubt numerische Typkonvertierungen zur Kompilierzeit, mit Bereichsvalidierung zur Laufzeit:

```hemlock
let x: i8 = 100;      // OK - 100 passt in i8 (zur Laufzeit validiert)
let y: u8 = 255;      // OK - innerhalb u8-Bereich
let z: f64 = 42;      // OK - i32 zu f64 ist sicher
```

### Dynamischer Code-Support

Code ohne Typannotationen wird als dynamisch (`any`-Typ) behandelt und besteht immer den Typchecker:

```hemlock
let x = get_value();  // Dynamisch - keine Annotation
process(x);           // OK - dynamische Werte √ºberall akzeptiert
```

---

## Primitive Typen

### Numerische Typen

#### Vorzeichenbehaftete Ganzzahlen

| Typ    | Gr√∂√üe  | Bereich                                     | Alias     |
|--------|----------|---------------------------------------------|-----------|
| `i8`   | 1 Byte   | -128 bis 127                                | -         |
| `i16`  | 2 Bytes  | -32.768 bis 32.767                          | -         |
| `i32`  | 4 Bytes  | -2.147.483.648 bis 2.147.483.647            | `integer` |
| `i64`  | 8 Bytes  | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807 | - |

**Beispiele:**
```hemlock
let a: i8 = 127;
let b: i16 = 32000;
let c: i32 = 1000000;
let d: i64 = 9223372036854775807;

// Typ-Alias
let x: integer = 42;  // Gleich wie i32
```

#### Vorzeichenlose Ganzzahlen

| Typ    | Gr√∂√üe  | Bereich                          | Alias  |
|--------|----------|----------------------------------|--------|
| `u8`   | 1 Byte   | 0 bis 255                        | `byte` |
| `u16`  | 2 Bytes  | 0 bis 65.535                     | -      |
| `u32`  | 4 Bytes  | 0 bis 4.294.967.295              | -      |
| `u64`  | 8 Bytes  | 0 bis 18.446.744.073.709.551.615 | -      |

**Beispiele:**
```hemlock
let a: u8 = 255;
let b: u16 = 65535;
let c: u32 = 4294967295;
let d: u64 = 18446744073709551615;

// Typ-Alias
let byte_val: byte = 65;  // Gleich wie u8
```

#### Gleitkomma

| Typ    | Gr√∂√üe  | Pr√§zision     | Alias    |
|--------|----------|----------------|----------|
| `f32`  | 4 Bytes  | ~7 Stellen     | -        |
| `f64`  | 8 Bytes  | ~15 Stellen    | `number` |

**Beispiele:**
```hemlock
let pi: f32 = 3.14159;
let precise: f64 = 3.14159265359;

// Typ-Alias
let x: number = 2.718;  // Gleich wie f64
```

---

### Ganzzahl-Literal-Inferenz

Ganzzahl-Literale werden automatisch basierend auf ihrem Wert typisiert:

**Regeln:**
- Werte im i32-Bereich (-2.147.483.648 bis 2.147.483.647): als `i32` inferiert
- Werte au√üerhalb i32-Bereich aber innerhalb i64-Bereich: als `i64` inferiert
- Verwenden Sie explizite Typannotationen f√ºr andere Typen (i8, i16, u8, u16, u32, u64)

**Beispiele:**
```hemlock
let small = 42;                    // i32 (passt in i32)
let large = 5000000000;            // i64 (> i32 max)
let max_i64 = 9223372036854775807; // i64 (INT64_MAX)
let explicit: u32 = 100;           // u32 (Typannotation √ºberschreibt)
```

---

### Boolean-Typ

**Typ:** `bool`

**Werte:** `true`, `false`

**Gr√∂√üe:** 1 Byte (intern)

**Beispiele:**
```hemlock
let is_active: bool = true;
let done = false;

if (is_active && !done) {
    print("arbeite");
}
```

---

### Zeichen-Typen

#### Rune

**Typ:** `rune`

**Beschreibung:** Unicode-Codepoint (U+0000 bis U+10FFFF)

**Gr√∂√üe:** 4 Bytes (32-Bit-Wert)

**Bereich:** 0 bis 0x10FFFF (1.114.111)

**Literal-Syntax:** Einfache Anf√ºhrungszeichen `'x'`

**Beispiele:**
```hemlock
// ASCII
let a = 'A';
let digit = '0';

// Mehrbyte-UTF-8
let rocket = 'üöÄ';      // U+1F680
let heart = '‚ù§';        // U+2764
let chinese = '‰∏≠';     // U+4E2D

// Escape-Sequenzen
let newline = '\n';
let tab = '\t';
let backslash = '\\';
let quote = '\'';
let null = '\0';

// Unicode-Escapes
let emoji = '\u{1F680}';   // Bis zu 6 Hex-Ziffern
let max = '\u{10FFFF}';    // Maximaler Codepoint
```

**Typkonvertierungen:**
```hemlock
// Ganzzahl zu Rune
let code: rune = 65;        // 'A'
let r: rune = 128640;       // üöÄ

// Rune zu Ganzzahl
let value: i32 = 'Z';       // 90

// Rune zu String
let s: string = 'H';        // "H"

// u8 zu Rune
let byte: u8 = 65;
let rune_val: rune = byte;  // 'A'
```

**Siehe auch:** [String-API](#reference-string-api) f√ºr String + Rune Verkettung

---

### String-Typ

**Typ:** `string`

**Beschreibung:** UTF-8-kodierter, veraenderbarer, heap-allokierter Text

**Kodierung:** UTF-8 (U+0000 bis U+10FFFF)

**Veraenderbarkeit:** Veraenderbar (anders als in den meisten Sprachen)

**Eigenschaften:**
- `.length` - Codepoint-Anzahl (Anzahl der Zeichen)
- `.byte_length` - Byte-Anzahl (UTF-8-Kodierungsgroesse)

**Literal-Syntax:** Doppelte Anf√ºhrungszeichen `"text"`

**Beispiele:**
```hemlock
let s = "hello";
s[0] = 'H';             // √Ñndern (jetzt "Hello")
print(s.length);        // 5 (Codepoint-Anzahl)
print(s.byte_length);   // 5 (UTF-8-Bytes)

let emoji = "üöÄ";
print(emoji.length);        // 1 (ein Codepoint)
print(emoji.byte_length);   // 4 (vier UTF-8-Bytes)
```

**Indizierung:**
```hemlock
let s = "hello";
let ch = s[0];          // Gibt Rune 'h' zur√ºck
s[0] = 'H';             // Mit Rune setzen
```

**Siehe auch:** [String-API](#reference-string-api) f√ºr vollst√§ndige Methodenreferenz

---

### Null-Typ

**Typ:** `null`

**Beschreibung:** Der Null-Wert (Abwesenheit eines Wertes)

**Gr√∂√üe:** 8 Bytes (intern)

**Wert:** `null`

**Beispiele:**
```hemlock
let x = null;
let y: i32 = null;  // FEHLER: Typfehlanpassung

if (x == null) {
    print("x ist null");
}
```

---

## Zusammengesetzte Typen

### Array-Typ

**Typ:** `array`

**Beschreibung:** Dynamisches, heap-allokiertes Array mit gemischten Typen

**Eigenschaften:**
- `.length` - Anzahl der Elemente

**Nullbasiert:** Ja

**Literal-Syntax:** `[elem1, elem2, ...]`

**Beispiele:**
```hemlock
let arr = [1, 2, 3, 4, 5];
print(arr[0]);         // 1
print(arr.length);     // 5

// Gemischte Typen
let mixed = [1, "hello", true, null];
```

**Siehe auch:** [Array-API](#reference-array-api) f√ºr vollst√§ndige Methodenreferenz

---

### Objekt-Typ

**Typ:** `object`

**Beschreibung:** JavaScript-√§hnliches Objekt mit dynamischen Feldern

**Literal-Syntax:** `{ field: value, ... }`

**Beispiele:**
```hemlock
let person = { name: "Alice", age: 30 };
print(person.name);  // "Alice"

// Feld dynamisch hinzuf√ºgen
person.email = "alice@example.com";
```

**Typdefinitionen:**
```hemlock
define Person {
    name: string,
    age: i32,
    active?: bool,  // Optionales Feld
}

let p: Person = { name: "Bob", age: 25 };
print(typeof(p));  // "Person"
```

---

### Pointer-Typen

#### Roh-Pointer (ptr)

**Typ:** `ptr`

**Beschreibung:** Rohe Speicheradresse (unsicher)

**Gr√∂√üe:** 8 Bytes

**Grenzenpr√ºfung:** Keine

**Beispiele:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);
```

#### Buffer (buffer)

**Typ:** `buffer`

**Beschreibung:** Sicherer Pointer-Wrapper mit Grenzenpr√ºfung

**Struktur:** Pointer + L√§nge + Kapazit√§t

**Eigenschaften:**
- `.length` - Buffergroesse
- `.capacity` - Allokierte Kapazit√§t

**Beispiele:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // Grenzenpr√ºfung
print(b.length);        // 64
free(b);
```

**Siehe auch:** [Speicher-API](#reference-memory-api) f√ºr Allokationsfunktionen

---

## Spezielle Typen

### Datei-Typ

**Typ:** `file`

**Beschreibung:** Dateihandle f√ºr I/O-Operationen

**Eigenschaften:**
- `.path` - Dateipfad (string)
- `.mode` - Oeffnungsmodus (string)
- `.closed` - Ob Datei geschlossen (bool)

**Siehe auch:** [Datei-API](#reference-file-api)

---

### Task-Typ

**Typ:** `task`

**Beschreibung:** Handle f√ºr nebenlaeufigen Task

**Siehe auch:** [Nebenlaeufigkeits-API](#reference-concurrency-api)

---

### Kanal-Typ

**Typ:** `channel`

**Beschreibung:** Thread-sicherer Kommunikationskanal

**Siehe auch:** [Nebenlaeufigkeits-API](#reference-concurrency-api)

---

### Funktions-Typ

**Typ:** `function`

**Beschreibung:** First-Class-Funktionswert

**Beispiele:**
```hemlock
fn add(a, b) {
    return a + b;
}

let multiply = fn(x, y) {
    return x * y;
};

print(typeof(add));      // "function"
print(typeof(multiply)); // "function"
```

---

### Void-Typ

**Typ:** `void`

**Beschreibung:** Abwesenheit eines Rueckgabewertes (interne Verwendung)

---

## Typpromovierungsregeln

Beim Mischen von Typen in Operationen promoviert Hemlock zum "hoeheren" Typ:

**Promovierungshierarchie:**
```
f64 (hoechste Pr√§zision)
 ‚Üë
f32
 ‚Üë
u64
 ‚Üë
i64
 ‚Üë
u32
 ‚Üë
i32
 ‚Üë
u16
 ‚Üë
i16
 ‚Üë
u8
 ‚Üë
i8 (niedrigste)
```

**Regeln:**
1. Float gewinnt immer √ºber Ganzzahl
2. Gr√∂√üere Gr√∂√üe gewinnt innerhalb gleicher Kategorie (int/uint/float)
3. Beide Operanden werden zum Ergebnistyp promoviert
4. **Praezisionserhaltung:** i64/u64 + f32 promoviert zu f64 (nicht f32)

**Beispiele:**
```hemlock
// Groessenpromovierung
u8 + i32    ‚Üí i32    // Gr√∂√üere Gr√∂√üe gewinnt
i32 + i64   ‚Üí i64    // Gr√∂√üere Gr√∂√üe gewinnt
u32 + u64   ‚Üí u64    // Gr√∂√üere Gr√∂√üe gewinnt

// Float-Promovierung
i32 + f32   ‚Üí f32    // Float gewinnt, f32 ausreichend f√ºr i32
i64 + f32   ‚Üí f64    // Promoviert zu f64 um i64-Pr√§zision zu erhalten
i64 + f64   ‚Üí f64    // Float gewinnt immer
i8 + f64    ‚Üí f64    // Float + groesster gewinnt
```

**Warum i64 + f32 ‚Üí f64?**

f32 hat nur eine 24-Bit-Mantisse, die Ganzzahlen gr√∂√üer als 2^24 (16.777.216) nicht praezise darstellen kann. Da i64 Werte bis 2^63 halten kann, w√ºrde das Mischen von i64 mit f32 schweren Praezisionsverlust verursachen. Hemlock promoviert stattdessen zu f64 (53-Bit-Mantisse).

---

## Bereichspr√ºfung

Typannotationen erzwingen Bereichspr√ºfungen bei Zuweisung:

**Gueltige Zuweisungen:**
```hemlock
let x: u8 = 255;             // OK
let y: i8 = 127;             // OK
let a: i64 = 2147483647;     // OK
let b: u64 = 4294967295;     // OK
```

**Ungueltige Zuweisungen (Laufzeitfehler):**
```hemlock
let x: u8 = 256;             // FEHLER: au√üerhalb des Bereichs
let y: i8 = 128;             // FEHLER: max ist 127
let z: u64 = -1;             // FEHLER: u64 kann nicht negativ sein
```

---

## Typ-Introspektion

### typeof(value)

Gibt den Typnamen als String zur√ºck.

**Signatur:**
```hemlock
typeof(value: any): string
```

**R√ºckgabe:**
- Primitive Typen: `"i8"`, `"i16"`, `"i32"`, `"i64"`, `"u8"`, `"u16"`, `"u32"`, `"u64"`, `"f32"`, `"f64"`, `"bool"`, `"string"`, `"rune"`, `"null"`
- Zusammengesetzte Typen: `"array"`, `"object"`, `"ptr"`, `"buffer"`, `"function"`
- Spezielle Typen: `"file"`, `"task"`, `"channel"`
- Typisierte Objekte: Benutzerdefinierter Typname (z.B. `"Person"`)

**Beispiele:**
```hemlock
print(typeof(42));              // "i32"
print(typeof(3.14));            // "f64"
print(typeof("hello"));         // "string"
print(typeof('A'));             // "rune"
print(typeof(true));            // "bool"
print(typeof([1, 2, 3]));       // "array"
print(typeof({ x: 10 }));       // "object"

define Person { name: string }
let p: Person = { name: "Alice" };
print(typeof(p));               // "Person"
```

**Siehe auch:** [Eingebaute Funktionen](builtins.md#typeof)

---

## Typkonvertierungen

### Implizite Konvertierungen

Hemlock f√ºhrt implizite Typkonvertierungen in arithmetischen Operationen nach den Typpromovierungsregeln durch.

**Beispiele:**
```hemlock
let a: u8 = 10;
let b: i32 = 20;
let result = a + b;     // result ist i32 (promoviert)
```

### Explizite Konvertierungen

Verwenden Sie Typannotationen f√ºr explizite Konvertierungen:

**Beispiele:**
```hemlock
// Ganzzahl zu Float
let i: i32 = 42;
let f: f64 = i;         // 42.0

// Float zu Ganzzahl (trunciert)
let x: f64 = 3.14;
let y: i32 = x;         // 3

// Ganzzahl zu Rune
let code: rune = 65;    // 'A'

// Rune zu Ganzzahl
let value: i32 = 'Z';   // 90

// Rune zu String
let s: string = 'H';    // "H"
```

---

## Typ-Aliase

### Eingebaute Aliase

Hemlock bietet eingebaute Typ-Aliase f√ºr h√§ufige Typen:

| Alias     | Tatsaechlicher Typ | Verwendung                 |
|-----------|-------------------|----------------------------|
| `integer` | `i32`             | Allzweck-Ganzzahlen        |
| `number`  | `f64`             | Allzweck-Gleitkomma        |
| `byte`    | `u8`              | Byte-Werte                 |

**Beispiele:**
```hemlock
let count: integer = 100;       // Gleich wie i32
let price: number = 19.99;      // Gleich wie f64
let b: byte = 255;              // Gleich wie u8
```

### Benutzerdefinierte Typ-Aliase

Definieren Sie benutzerdefinierte Typ-Aliase mit dem `type`-Schl√ºsselwort:

```hemlock
// Einfache Aliase
type Integer = i32;
type Text = string;

// Funktionstyp-Aliase
type Callback = fn(i32): void;
type Predicate = fn(any): bool;
type BinaryOp = fn(i32, i32): i32;

// Zusammengesetzte Typ-Aliase
define HasName { name: string }
define HasAge { age: i32 }
type Person = HasName & HasAge;

// Generische Typ-Aliase
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };
```

**Benutzerdefinierte Aliase verwenden:**
```hemlock
let cb: Callback = fn(n) { print(n); };
let p: Person = { name: "Alice", age: 30 };
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
```

**Hinweis:** Typ-Aliase sind transparent - `typeof()` gibt den zugrundeliegenden Typnamen zur√ºck.

---

## Funktionstypen

Funktionstypen spezifizieren die Signatur von Funktionswerten:

### Syntax

```hemlock
fn(param_types): return_type
```

### Beispiele

```hemlock
// Grundlegender Funktionstyp
let add: fn(i32, i32): i32 = fn(a, b) { return a + b; };

// Funktionsparameter
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// Higher-Order-Funktion die Funktion zur√ºckgibt
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Async-Funktionstyp
fn run_async(handler: async fn(): void) {
    spawn(handler);
}
```

---

## Zusammengesetzte Typen (Schnittmenge)

Zusammengesetzte Typen verwenden `&` um mehrere Typanforderungen zu verlangen:

```hemlock
define HasName { name: string }
define HasAge { age: i32 }
define HasEmail { email: string }

// Objekt muss alle Typen erf√ºllen
let person: HasName & HasAge = { name: "Alice", age: 30 };

// Drei oder mehr Typen
fn describe(p: HasName & HasAge & HasEmail) {
    print(p.name + " <" + p.email + ">");
}
```

---

## Zusammenfassungstabelle

| Typ        | Gr√∂√üe   | Veraenderbar | Heap-allokiert | Beschreibung                   |
|------------|-----------|--------------|----------------|--------------------------------|
| `i8`-`i64` | 1-8 Bytes | Nein         | Nein           | Vorzeichenbehaftete Ganzzahlen |
| `u8`-`u64` | 1-8 Bytes | Nein         | Nein           | Vorzeichenlose Ganzzahlen      |
| `f32`      | 4 Bytes   | Nein         | Nein           | Einfach-Praezisions-Float      |
| `f64`      | 8 Bytes   | Nein         | Nein           | Doppel-Praezisions-Float       |
| `bool`     | 1 Byte    | Nein         | Nein           | Boolean                        |
| `rune`     | 4 Bytes   | Nein         | Nein           | Unicode-Codepoint              |
| `string`   | Variabel  | Ja           | Ja             | UTF-8-Text                     |
| `array`    | Variabel  | Ja           | Ja             | Dynamisches Array              |
| `object`   | Variabel  | Ja           | Ja             | Dynamisches Objekt             |
| `ptr`      | 8 Bytes   | Nein         | Nein           | Roh-Pointer                    |
| `buffer`   | Variabel  | Ja           | Ja             | Sicherer Pointer-Wrapper       |
| `file`     | Opak      | Ja           | Ja             | Dateihandle                    |
| `task`     | Opak      | Nein         | Ja             | Nebenlaeufiger Task-Handle     |
| `channel`  | Opak      | Ja           | Ja             | Thread-sicherer Kanal          |
| `function` | Opak      | Nein         | Ja             | Funktionswert                  |
| `null`     | 8 Bytes   | Nein         | Nein           | Null-Wert                      |

---

## Siehe auch

- [Operatoren-Referenz](#reference-operators) - Typverhalten in Operationen
- [Eingebaute Funktionen](#reference-builtins) - Typ-Introspektion und Konvertierung
- [String-API](#reference-string-api) - String-Typ-Methoden
- [Array-API](#reference-array-api) - Array-Typ-Methoden
- [Speicher-API](#reference-memory-api) - Pointer- und Buffer-Operationen



################################################################################
# DESIGN & PHILOSOPHIE
################################################################################

--------------------------------------------------------------------------------
## Designphilosophie
--------------------------------------------------------------------------------

# Hemlock Sprachdesign-Philosophie

> "Eine kleine, unsichere Sprache, um unsichere Dinge sicher zu schreiben."

Dieses Dokument beschreibt die grundlegenden Designprinzipien und die Philosophie von Hemlock. Lesen Sie dies zuerst, bevor Sie √Ñnderungen oder Erg√§nzungen an der Sprache vornehmen.

---

## Inhaltsverzeichnis

- [Kernidentit√§t](#kernidentit√§t)
- [Designprinzipien](#designprinzipien)
- [Philosophie zur Sicherheit](#philosophie-zur-sicherheit)
- [Was NICHT hinzugef√ºgt werden sollte](#was-nicht-hinzugef√ºgt-werden-sollte)
- [Zuk√ºnftige √úberlegungen](#zuk√ºnftige-√ºberlegungen)
- [Abschlie√üende Gedanken](#abschlie√üende-gedanken)

---

## Kernidentit√§t

Hemlock ist eine **Systemskripting-Sprache**, die manuelle Speicherverwaltung und explizite Kontrolle umfasst. Sie ist f√ºr Programmierer konzipiert, die Folgendes wollen:

- Die Leistungsf√§higkeit von C
- Die Ergonomie moderner Skriptsprachen
- Eingebaute strukturierte asynchrone Nebenl√§ufigkeit
- Kein verstecktes Verhalten oder Magie

### Was Hemlock NICHT ist

- **Speichersicher** (baumelnde Zeiger sind Ihre Verantwortung)
- **Ein Ersatz f√ºr Rust, Go oder Lua**
- **Eine Sprache, die Komplexit√§t vor Ihnen verbirgt**

### Was Hemlock IST

- **Explizit statt implizit, immer**
- **Lehrreich und experimentell**
- **Eine "C-Skriptschicht" f√ºr Systemarbeit**
- **Ehrlich √ºber Kompromisse**

---

## Designprinzipien

### 1. Explizit statt implizit

Hemlock bevorzugt Explizitheit in allen Sprachkonstrukten. Es sollte keine √úberraschungen, keine Magie und kein verstecktes Verhalten geben.

**Schlecht (implizit):**
```hemlock
let x = 5  // Fehlendes Semikolon - sollte einen Fehler erzeugen
```

**Gut (explizit):**
```hemlock
let x = 5;
free(ptr);  // Sie haben es allokiert, Sie geben es frei
```

**Schl√ºsselaspekte:**
- Semikolons sind obligatorisch (keine automatische Semikolon-Einf√ºgung)
- Keine Garbage Collection
- Manuelle Speicherverwaltung (alloc/free)
- Typannotationen sind optional, werden aber zur Laufzeit gepr√ºft
- Keine automatische Ressourcenbereinigung (kein RAII), aber `defer` bietet explizite Bereinigung

### 2. Dynamisch standardm√§√üig, typisiert nach Wahl

Jeder Wert hat ein Laufzeit-Typ-Tag, aber das System ist so konzipiert, dass es flexibel ist und dennoch Fehler erkennt.

**Typinferenz:**
- Kleine Ganzzahlen (passen in i32): `42` ‚Üí `i32`
- Gro√üe Ganzzahlen (> i32-Bereich): `9223372036854775807` ‚Üí `i64`
- Gleitkommazahlen: `3.14` ‚Üí `f64`

**Explizite Typisierung bei Bedarf:**
```hemlock
let x = 42;              // i32 inferiert (kleiner Wert)
let y: u8 = 255;         // explizites u8
let z = x + y;           // wird zu i32 hochgestuft
let big = 5000000000;    // i64 inferiert (> i32 max)
```

**Typpromotionsregeln** folgen einer klaren Hierarchie vom kleinsten zum gr√∂√üten, wobei Gleitkommazahlen immer √ºber Ganzzahlen gewinnen.

### 3. Unsicherheit ist ein Feature, kein Bug

Hemlock versucht nicht, alle Fehler zu verhindern. Stattdessen gibt es Ihnen die Werkzeuge, um sicher zu sein, w√§hrend Sie bei Bedarf unsicheres Verhalten w√§hlen k√∂nnen.

**Beispiele f√ºr beabsichtigte Unsicherheit:**
- Zeigerarithmetik kann √ºberlaufen (Verantwortung des Benutzers)
- Keine Bereichspr√ºfung bei rohem `ptr` (verwenden Sie `buffer`, wenn Sie Sicherheit wollen)
- Double-free-Abst√ºrze sind erlaubt (manuelle Speicherverwaltung)
- Das Typsystem verhindert Unf√§lle, erlaubt aber Risiken bei Bedarf

```hemlock
let p = alloc(10);
let q = p + 100;  // Weit √ºber die Allokation hinaus - erlaubt, aber gef√§hrlich
```

**Die Philosophie:** Das Typsystem sollte *Unf√§lle* verhindern, aber *beabsichtigte* unsichere Operationen erlauben.

### 4. Strukturierte Nebenl√§ufigkeit erstklassig

Nebenl√§ufigkeit ist in Hemlock kein nachtr√§glicher Gedanke. Sie ist von Grund auf in die Sprache eingebaut.

**Schl√ºsselfunktionen:**
- `async`/`await` in die Sprache eingebaut
- Kan√§le f√ºr Kommunikation
- `spawn`/`join`/`detach` f√ºr Aufgabenverwaltung
- Keine rohen Threads, keine Sperren - nur strukturiert
- Echte Mehrfaden-Parallelit√§t mit POSIX-Threads

**Kein Event-Loop oder Green Threads** - Hemlock verwendet echte Betriebssystem-Threads f√ºr echte Parallelit√§t √ºber mehrere CPU-Kerne.

### 5. C-√§hnliche Syntax, wenig Zeremonie

Hemlock sollte Systemprogrammierern vertraut vorkommen und gleichzeitig Boilerplate reduzieren.

**Designentscheidungen:**
- `{}`-Bl√∂cke immer, keine optionalen Klammern
- Operatoren entsprechen C: `+`, `-`, `*`, `/`, `&&`, `||`, `!`
- Typsyntax entspricht Rust/TypeScript: `let x: type = value;`
- Funktionen sind erstklassige Werte
- Minimale Schl√ºsselw√∂rter und Sonderformen

---

## Philosophie zur Sicherheit

**Hemlocks Haltung zur Sicherheit:**

> "Wir geben Ihnen die Werkzeuge, um sicher zu sein (`buffer`, Typannotationen, Bereichspr√ºfung), aber wir zwingen Sie nicht, sie zu verwenden (`ptr`, manuelle Speicherverwaltung, unsichere Operationen).
>
> Der Standard sollte zur Sicherheit f√ºhren, aber die Hintert√ºr sollte immer verf√ºgbar sein."

### Bereitgestellte Sicherheitswerkzeuge

**1. Sicherer Buffer-Typ:**
```hemlock
let b: buffer = buffer(64);
b[0] = 65;              // bereichsgepr√ºft
print(b.length);        // 64
free(b);                // immer noch manuell
```

**2. Unsichere rohe Zeiger:**
```hemlock
let p: ptr = alloc(64);
memset(p, 0, 64);
free(p);  // Sie m√ºssen daran denken, free aufzurufen
```

**3. Typannotationen:**
```hemlock
let x: u8 = 255;   // OK
let y: u8 = 256;   // FEHLER: au√üerhalb des Bereichs
```

**4. Laufzeit-Typpr√ºfung:**
```hemlock
let val = some_function();
if (typeof(val) == "i32") {
    // Sicher als Ganzzahl zu verwenden
}
```

### Leitprinzipien

1. **Standard auf sichere Muster in der Dokumentation** - Zeigen Sie `buffer` vor `ptr`, ermutigen Sie zu Typannotationen
2. **Machen Sie unsichere Operationen offensichtlich** - Rohe Zeigerarithmetik sollte beabsichtigt aussehen
3. **Bieten Sie Hintert√ºren** - Verhindern Sie nicht, dass erfahrene Benutzer Low-Level-Arbeit leisten
4. **Seien Sie ehrlich √ºber Kompromisse** - Dokumentieren Sie, was schiefgehen kann

### Beispiele f√ºr Sicherheit vs. Unsicherheit

| Sicheres Muster | Unsicheres Muster | Wann unsicher verwenden |
|-----------------|-------------------|-------------------------|
| `buffer`-Typ | `ptr`-Typ | FFI, leistungskritischer Code |
| Typannotationen | Keine Annotationen | Externe Schnittstellen, Validierung |
| Bereichsgepr√ºfter Zugriff | Zeigerarithmetik | Low-Level-Speicheroperationen |
| Ausnahmebehandlung | R√ºckgabe von null/Fehlercodes | Wenn Ausnahmen zu schwergewichtig sind |

---

## Was NICHT hinzugef√ºgt werden sollte

Zu verstehen, was **nicht** hinzugef√ºgt werden sollte, ist genauso wichtig wie zu wissen, was hinzugef√ºgt werden soll.

### Kein implizites Verhalten hinzuf√ºgen

**Schlechte Beispiele:**

```hemlock
// SCHLECHT: Automatische Semikolon-Einf√ºgung
let x = 5
let y = 10

// SCHLECHT: Implizite Typkonvertierungen, die Pr√§zision verlieren
let x: i32 = 3.14  // Sollte abschneiden oder Fehler erzeugen?
```

**Warum:** Implizites Verhalten erzeugt √úberraschungen und macht Code schwerer nachvollziehbar.

### Keine Komplexit√§t verbergen

**Schlechte Beispiele:**

```hemlock
// SCHLECHT: Magische Hinter-den-Kulissen-Optimierung
let arr = [1, 2, 3]  // Ist das Stack oder Heap? Der Benutzer sollte es wissen! (Heap, refgez√§hlt)

// SCHLECHT: Roher Zeiger automatisch freigegeben
let p = alloc(100)  // Wird das automatisch freigegeben? NEIN! Rohe Zeiger brauchen immer free()
```

**Hinweis zum Refcounting:** Hemlock verwendet internes Refcounting f√ºr Strings, Arrays, Objekte und Buffer - diese WERDEN automatisch freigegeben, wenn der Scope verlassen wird. Dies ist explizit und vorhersehbar (deterministische Bereinigung, wenn ref 0 erreicht, keine GC-Pausen). Rohe Zeiger (`ptr` von `alloc()`) sind NICHT refgez√§hlt und erfordern immer manuelles `free()`.

**Warum:** Versteckte Komplexit√§t macht es unm√∂glich, Leistung vorherzusagen und Probleme zu debuggen.

### Keine bestehenden Semantiken brechen

**√Ñndern Sie niemals diese Kernentscheidungen:**
- Semikolons sind obligatorisch - machen Sie sie nicht optional
- Manuelle Speicherverwaltung - f√ºgen Sie keine GC hinzu
- Ver√§nderbare Strings - machen Sie sie nicht unver√§nderbar
- Laufzeit-Typpr√ºfung - entfernen Sie sie nicht

**Warum:** Konsistenz und Stabilit√§t sind wichtiger als trendige Features.

### Keine "praktischen" Features hinzuf√ºgen, die Explizitheit reduzieren

**Beispiele f√ºr zu vermeidende Features:**
- Operator√ºberladung (vielleicht f√ºr Benutzertypen, aber vorsichtig)
- Implizite Typumwandlung, die Informationen verliert
- Automatische Ressourcenbereinigung (RAII)
- Methodenverkettung, die Komplexit√§t verbirgt
- DSLs und magische Syntax

**Ausnahme:** Praktische Features sind OK, wenn sie **expliziter Zucker** √ºber einfache Operationen sind:
- `else if` ist in Ordnung (es sind nur verschachtelte if-Anweisungen)
- String-Interpolation k√∂nnte OK sein, wenn es klar syntaktischer Zucker ist
- Methodensyntax f√ºr Objekte ist in Ordnung (es ist explizit, was es tut)

---

## Zuk√ºnftige √úberlegungen

### Vielleicht hinzuf√ºgen (in Diskussion)

Diese Features passen zur Philosophie von Hemlock, ben√∂tigen aber sorgf√§ltiges Design:

**1. Pattern Matching**
```hemlock
match (value) {
    case i32: print("Ganzzahl");
    case string: print("Text");
    case _: print("anderes");
}
```
- Explizite Typpr√ºfung
- Keine versteckten Kosten
- Kompilierzeit-Vollst√§ndigkeitspr√ºfung m√∂glich

**2. Fehlertypen (`Result<T, E>`)**
```hemlock
fn divide(a: i32, b: i32): Result<i32, string> {
    if (b == 0) {
        return Err("Division durch Null");
    }
    return Ok(a / b);
}
```
- Explizite Fehlerbehandlung
- Zwingt Benutzer, √ºber Fehler nachzudenken
- Alternative zu Ausnahmen

**3. Array/Slice-Typen**
- Haben bereits dynamische Arrays
- K√∂nnten Arrays fester Gr√∂√üe f√ºr Stack-Allokation hinzuf√ºgen
- M√ºsste explizit √ºber Stack vs. Heap sein

**4. Verbesserte Speichersicherheitswerkzeuge**
- Optionales Bereichspr√ºfungs-Flag
- Speicherleckerkennung in Debug-Builds
- Sanitizer-Integration

### Wahrscheinlich niemals hinzuf√ºgen

Diese Features verletzen Kernprinzipien:

**1. Garbage Collection**
- Verbirgt Speicherverwaltungskomplexit√§t
- Unvorhersehbare Leistung
- Gegen das Prinzip der expliziten Kontrolle

**2. Automatische Speicherverwaltung**
- Gleiche Gr√ºnde wie GC
- Reference Counting k√∂nnte OK sein, wenn explizit

**3. Implizite Typkonvertierungen, die Daten verlieren**
- Widerspricht "explizit statt implizit"
- Quelle subtiler Bugs

**4. Makros (komplexe)**
- Zu viel Macht, zu viel Komplexit√§t
- Einfaches Makrosystem k√∂nnte OK sein
- Bevorzugen Sie Codegenerierung oder Funktionen

**5. Klassenbasierte OOP mit Vererbung**
- Zu viel implizites Verhalten
- Duck Typing und Objekte sind ausreichend
- Komposition statt Vererbung

**6. Modulsystem mit komplexer Aufl√∂sung**
- Halten Sie Importe einfach und explizit
- Keine magischen Suchpfade
- Keine Versionsaufl√∂sung (verwenden Sie den OS-Paketmanager)

---

## Abschlie√üende Gedanken

### Vertrauen und Verantwortung

Bei Hemlock geht es um **Vertrauen und Verantwortung**. Wir vertrauen dem Programmierer:

- Speicher korrekt zu verwalten
- Typen angemessen zu verwenden
- Fehler ordnungsgem√§√ü zu behandeln
- Die Kompromisse zu verstehen

Im Gegenzug bietet Hemlock:

- Keine versteckten Kosten
- Kein √ºberraschendes Verhalten
- Volle Kontrolle bei Bedarf
- Sicherheitswerkzeuge bei Wunsch

### Die Leitfrage

**Wenn Sie ein neues Feature in Betracht ziehen, fragen Sie:**

> "Gibt dies dem Programmierer mehr explizite Kontrolle, oder verbirgt es etwas?"

- Wenn es **explizite Kontrolle hinzuf√ºgt** ‚Üí passt wahrscheinlich zu Hemlock
- Wenn es **Komplexit√§t verbirgt** ‚Üí geh√∂rt wahrscheinlich nicht dazu
- Wenn es **optionaler Zucker** ist, der klar dokumentiert ist ‚Üí k√∂nnte OK sein

### Beispiele f√ºr gute Erg√§nzungen

- **Switch-Anweisungen** - Expliziter Kontrollfluss, keine Magie, klare Semantik

- **Async/await mit pthreads** - Explizite Nebenl√§ufigkeit, echte Parallelit√§t, Benutzer kontrolliert das Spawning

- **Buffer-Typ neben ptr** - Gibt Wahl zwischen sicher und unsicher

- **Optionale Typannotationen** - Hilft Bugs zu erkennen, ohne Striktheit zu erzwingen

- **Try/catch/finally** - Explizite Fehlerbehandlung mit klarem Kontrollfluss

### Beispiele f√ºr schlechte Erg√§nzungen

- **Automatische Semikolon-Einf√ºgung** - Verbirgt Syntaxfehler, macht Code mehrdeutig

- **RAII/Destruktoren** - Automatische Bereinigung verbirgt, wann Ressourcen freigegeben werden

- **Implizite Null-Koaleszenz** - Verbirgt Null-Pr√ºfungen, macht Code schwerer nachvollziehbar

- **Automatisch wachsende Strings** - Verbirgt Speicherallokation, unvorhersehbare Leistung

---

## Fazit

Hemlock versucht nicht, die sicherste Sprache, die schnellste Sprache oder die funktionsreichste Sprache zu sein.

**Hemlock versucht, die *ehrlichste* Sprache zu sein.**

Sie sagt Ihnen genau, was sie tut, gibt Ihnen Kontrolle, wenn Sie sie brauchen, und verbirgt die scharfen Kanten nicht. Es ist eine Sprache f√ºr Menschen, die ihren Code auf niedriger Ebene verstehen wollen, w√§hrend sie moderne Ergonomie genie√üen.

Wenn Sie sich nicht sicher sind, ob ein Feature zu Hemlock geh√∂rt, denken Sie daran:

> **Explizit statt implizit, immer.**
> **Unsicherheit ist ein Feature, kein Bug.**
> **Der Benutzer ist verantwortlich, und das ist OK.**


--------------------------------------------------------------------------------
## Implementierung
--------------------------------------------------------------------------------

# Hemlock Implementierungsdetails

Dieses Dokument beschreibt die technische Implementierung der Hemlock-Sprache, einschlie√ülich Projektstruktur, Kompilierungspipeline, Laufzeitarchitektur und Designentscheidungen.

---

## Inhaltsverzeichnis

- [Projektstruktur](#projektstruktur)
- [Kompilierungspipeline](#kompilierungspipeline)
- [Modulares Interpreter-Design](#modulares-interpreter-design)
- [Laufzeitarchitektur](#laufzeitarchitektur)
- [Wertdarstellung](#wertdarstellung)
- [Typsystem-Implementierung](#typsystem-implementierung)
- [Speicherverwaltung](#speicherverwaltung)
- [Nebenl√§ufigkeitsmodell](#nebenl√§ufigkeitsmodell)
- [Zukunftspl√§ne](#zukunftspl√§ne)

---

## Projektstruktur

```
hemlock/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ frontend/              # Gemeinsam: Lexer, Parser, AST
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lexer.c            # Tokenisierung
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ parser/            # Rekursiver Abstiegsparser
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ast.c              # AST-Knotenverwaltung
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ module.c           # Modulaufl√∂sung
‚îÇ   ‚îú‚îÄ‚îÄ backends/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interpreter/       # hemlock: Tree-Walking-Interpreter
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.c         # CLI-Einstiegspunkt
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ runtime.c      # Ausdrucks-/Anweisungsauswertung
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ builtins.c     # Eingebaute Funktionen
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ compiler/          # hemlockc: C-Code-Generator
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ main.c         # CLI, Orchestrierung
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ type_check.c   # Kompilierzeit-Typpr√ºfung
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ codegen.c      # Code-Generierungskontext
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ codegen_expr.c # Ausdrucks-Codegen
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ codegen_stmt.c # Anweisungs-Codegen
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ tools/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lsp/               # Language Server Protocol
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ bundler/           # Bundle-/Paket-Werkzeuge
‚îú‚îÄ‚îÄ runtime/                   # libhemlock_runtime.a (f√ºr kompilierte Programme)
‚îú‚îÄ‚îÄ stdlib/                    # Standardbibliothek (39 Module)
‚îÇ   ‚îî‚îÄ‚îÄ docs/                  # Moduldokumentation
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ parity/                # Tests, die beide Backends bestehen m√ºssen
‚îÇ   ‚îú‚îÄ‚îÄ interpreter/           # Interpreter-spezifische Tests
‚îÇ   ‚îî‚îÄ‚îÄ compiler/              # Compiler-spezifische Tests
‚îú‚îÄ‚îÄ examples/                  # Beispielprogramme
‚îî‚îÄ‚îÄ docs/                      # Dokumentation
```

### Verzeichnisorganisation

**`include/`** - √ñffentliche API-Header, die die Schnittstelle zwischen Komponenten definieren:
- Saubere Trennung zwischen Lexer, Parser, AST und Interpreter
- Vorw√§rtsdeklarationen zur Minimierung von Abh√§ngigkeiten
- √ñffentliche API zum Einbetten von Hemlock in andere Programme

**`src/`** - Implementierungsdateien:
- Dateien auf oberster Ebene behandeln Lexing, Parsing, AST-Verwaltung
- `main.c` bietet CLI und REPL
- Der Interpreter ist in separate Subsysteme modularisiert

**`src/interpreter/`** - Modulare Interpreter-Implementierung:
- Jedes Modul hat eine einzelne, klare Verantwortung
- Interne API in `internal.h` f√ºr Inter-Modul-Kommunikation definiert
- Module k√∂nnen unabh√§ngig kompiliert werden f√ºr schnellere Builds

**`tests/`** - Umfassende Testsuite:
- Nach Funktionsbereich organisiert
- Jedes Verzeichnis enth√§lt fokussierte Testf√§lle
- `run_tests.sh` orchestriert die Testausf√ºhrung

---

## Kompilierungspipeline

Hemlock verwendet eine traditionelle Kompilierungspipeline mit verschiedenen Phasen:

### Phase 1: Lexikalische Analyse (Lexer)

**Eingabe:** Quellcode-Text
**Ausgabe:** Token-Strom
**Implementierung:** `src/lexer.c`

```
Quelle: "let x = 42;"
   ‚Üì
Tokens: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
```

**Schl√ºsselfunktionen:**
- Erkennt Schl√ºsselw√∂rter, Bezeichner, Literale, Operatoren, Interpunktion
- Behandelt UTF-8-Stringliterale und Rune-Literale
- Meldet Zeilennummern f√ºr Fehlermeldungen
- Einziger Durchlauf, kein Backtracking

### Phase 2: Syntaxanalyse (Parser)

**Eingabe:** Token-Strom
**Ausgabe:** Abstrakter Syntaxbaum (AST)
**Implementierung:** `src/parser.c`

```
Tokens: [LET, IDENTIFIER("x"), EQUALS, INTEGER(42), SEMICOLON]
   ‚Üì
AST: LetStmt {
    name: "x",
    type: null,
    value: IntLiteral(42)
}
```

**Schl√ºsselfunktionen:**
- Rekursiver Abstiegsparser
- Baut Baumdarstellung der Programmstruktur auf
- Behandelt Operatorpriorit√§t
- Validiert Syntax (Klammern, Semikolons usw.)
- Noch keine semantische Analyse (erfolgt zur Laufzeit)

**Operatorpriorit√§t (niedrigste bis h√∂chste):**
1. Zuweisung: `=`
2. Logisches ODER: `||`
3. Logisches UND: `&&`
4. Bitweises ODER: `|`
5. Bitweises XOR: `^`
6. Bitweises UND: `&`
7. Gleichheit: `==`, `!=`
8. Vergleich: `<`, `>`, `<=`, `>=`
9. Bitweise Verschiebungen: `<<`, `>>`
10. Addition/Subtraktion: `+`, `-`
11. Multiplikation/Division/Modulo: `*`, `/`, `%`
12. Un√§r: `!`, `-`, `~`
13. Aufruf/Index/Element: `()`, `[]`, `.`

### Phase 3a: Interpretation (Tree-Walking)

**Eingabe:** AST
**Ausgabe:** Programmausf√ºhrung
**Implementierung:** `src/backends/interpreter/runtime.c`

```
AST: LetStmt { ... }
   ‚Üì
Ausf√ºhrung: Wertet AST-Knoten rekursiv aus
   ‚Üì
Ergebnis: Variable x mit Wert 42 erstellt
```

**Schl√ºsselfunktionen:**
- Direkte AST-Traversierung (Tree-Walking-Interpreter)
- Dynamische Typpr√ºfung zur Laufzeit
- Umgebungsbasierte Variablenspeicherung

### Phase 3b: Kompilierung (hemlockc)

**Eingabe:** AST
**Ausgabe:** Native ausf√ºhrbare Datei √ºber C-Codegenerierung
**Implementierung:** `src/backends/compiler/`

```
AST: LetStmt { ... }
   ‚Üì
Typpr√ºfung: Typen zur Kompilierzeit validieren
   ‚Üì
C-Codegen: √Ñquivalenten C-Code generieren
   ‚Üì
GCC: C zu nativer Bin√§rdatei kompilieren
   ‚Üì
Ergebnis: Eigenst√§ndige ausf√ºhrbare Datei
```

**Schl√ºsselfunktionen:**
- Kompilierzeit-Typpr√ºfung (standardm√§√üig aktiviert)
- C-Codegenerierung f√ºr Portabilit√§t
- Linkt gegen `libhemlock_runtime.a`
- Deutlich schnellere Ausf√ºhrung als Interpreter

---

## Compiler-Backend (hemlockc)

Der Hemlock-Compiler generiert C-Code aus dem AST, der dann mit GCC zu einer nativen ausf√ºhrbaren Datei kompiliert wird.

### Compiler-Architektur

```
src/backends/compiler/
‚îú‚îÄ‚îÄ main.c              # CLI, Argumentparsing, Orchestrierung
‚îú‚îÄ‚îÄ codegen.c           # Kern-Codegenerierungskontext
‚îú‚îÄ‚îÄ codegen_expr.c      # Ausdrucks-Codegenerierung
‚îú‚îÄ‚îÄ codegen_stmt.c      # Anweisungs-Codegenerierung
‚îú‚îÄ‚îÄ codegen_call.c      # Funktionsaufruf-Generierung
‚îú‚îÄ‚îÄ codegen_closure.c   # Closure-Implementierung
‚îú‚îÄ‚îÄ codegen_program.c   # Programm-Generierung auf oberster Ebene
‚îú‚îÄ‚îÄ codegen_module.c    # Modul-/Import-Behandlung
‚îú‚îÄ‚îÄ type_check.c        # Kompilierzeit-Typpr√ºfung
‚îî‚îÄ‚îÄ type_check.h        # Typpr√ºfer-API
```

### Typpr√ºfung

Der Compiler enth√§lt ein vereinheitlichtes Typpr√ºfungssystem, das:

1. **Typen zur Kompilierzeit validiert** - Erkennt Typfehler vor der Ausf√ºhrung
2. **Dynamischen Code unterst√ºtzt** - Untypisierter Code wird als `any` behandelt (immer g√ºltig)
3. **Optimierungshinweise liefert** - Identifiziert Variablen, die unboxed werden k√∂nnen

**Typpr√ºfungs-Flags:**

| Flag | Beschreibung |
|------|--------------|
| (Standard) | Typpr√ºfung aktiviert |
| `--check` | Nur Typpr√ºfung, nicht kompilieren |
| `--no-type-check` | Typpr√ºfung deaktivieren |
| `--strict-types` | Warnung bei impliziten `any`-Typen |

**Typpr√ºfer-Implementierung:**

```c
// type_check.h - Schl√ºsselstrukturen
typedef struct TypeCheckContext {
    const char *filename;
    int error_count;
    int warning_count;
    UnboxableVar *unboxable_vars;  // Optimierungshinweise
    // ... Typumgebung, Definitionen usw.
} TypeCheckContext;

// Haupteinstiegspunkt
int type_check_program(TypeCheckContext *ctx, Stmt **stmts, int count);
```

### Codegenerierung

Die Codegen-Phase √ºbersetzt AST-Knoten in C-Code:

**Ausdruckszuordnung:**
```
Hemlock                 ‚Üí  Generiertes C
----------------------------------------
let x = 42;            ‚Üí  HmlValue x = hml_val_i32(42);
x + y                  ‚Üí  hml_add(x, y)
arr[i]                 ‚Üí  hml_array_get(arr, i)
obj.field              ‚Üí  hml_object_get_field(obj, "field")
fn(a, b) { ... }       ‚Üí  Closure mit Umgebungserfassung
```

**Laufzeit-Integration:**

Generierter C-Code linkt gegen `libhemlock_runtime.a`, die bereitstellt:
- `HmlValue` tagged union-Typ
- Speicherverwaltung (Reference Counting)
- Eingebaute Funktionen (print, typeof usw.)
- Nebenl√§ufigkeitsprimitiven (Tasks, Kan√§le)
- FFI-Unterst√ºtzung

### Unboxing-Optimierung

Der Typpr√ºfer identifiziert Variablen, die native C-Typen anstelle von geboxten `HmlValue` verwenden k√∂nnen:

**Unboxbare Muster:**
- Schleifenz√§hler mit bekanntem Integer-Typ
- Akkumulatorvariablen in Schleifen
- Variablen mit expliziten Typannotationen (i32, i64, f64, bool)

```hemlock
// Schleifenz√§hler 'i' kann zu nativem int32_t unboxed werden
for (let i: i32 = 0; i < 1000000; i = i + 1) {
    sum = sum + i;
}
```

---

## Modulares Interpreter-Design

Der Interpreter ist f√ºr Wartbarkeit und Skalierbarkeit in fokussierte Module aufgeteilt.

### Modulverantwortlichkeiten

#### 1. Umgebung (`environment.c`) - 121 Zeilen

**Zweck:** Variablen-Scoping und Namensaufl√∂sung

**Schl√ºsselfunktionen:**
- `env_create()` - Neue Umgebung mit optionalem Elternteil erstellen
- `env_define()` - Neue Variable im aktuellen Scope definieren
- `env_get()` - Variable im aktuellen oder Eltern-Scope nachschlagen
- `env_set()` - Bestehenden Variablenwert aktualisieren
- `env_free()` - Umgebung und alle Variablen freigeben

**Design:**
- Verkn√ºpfte Scopes (jede Umgebung hat Zeiger auf Elternteil)
- HashMap f√ºr schnelle Variablensuche
- Unterst√ºtzt lexikalisches Scoping f√ºr Closures

#### 2. Werte (`values.c`) - 394 Zeilen

**Zweck:** Wertkonstruktoren und Datenstrukturverwaltung

**Schl√ºsselfunktionen:**
- `value_create_*()` - Konstruktoren f√ºr jeden Werttyp
- `value_copy()` - Tiefe/flache Kopierlogik
- `value_free()` - Bereinigung und Speicherfreigabe
- `value_to_string()` - Stringdarstellung f√ºr Ausgabe

**Datenstrukturen:**
- Objekte (dynamische Feldarrays)
- Arrays (dynamische Gr√∂√üen√§nderung)
- Buffer (ptr + L√§nge + Kapazit√§t)
- Closures (Funktion + erfasste Umgebung)
- Tasks und Kan√§le (Nebenl√§ufigkeitsprimitiven)

#### 3. Typen (`types.c`) - 440 Zeilen

**Zweck:** Typsystem, Konvertierungen und Duck-Typing

**Schl√ºsselfunktionen:**
- `type_check()` - Laufzeit-Typvalidierung
- `type_convert()` - Implizite Typkonvertierungen/-promotionen
- `duck_type_check()` - Strukturelle Typpr√ºfung f√ºr Objekte
- `type_name()` - Druckbaren Typnamen abrufen

**Funktionen:**
- Typpromotionshierarchie (i8 ‚Üí i16 ‚Üí i32 ‚Üí i64 ‚Üí f32 ‚Üí f64, wobei i64/u64 + f32 ‚Üí f64)
- Bereichspr√ºfung f√ºr numerische Typen
- Duck-Typing f√ºr Objekttypdefinitionen
- Optionale Feldstandards

#### 4. Builtins (`builtins.c`) - 955 Zeilen

**Zweck:** Eingebaute Funktionen und globale Registrierung

**Schl√ºsselfunktionen:**
- `register_builtins()` - Alle eingebauten Funktionen und Konstanten registrieren
- Implementierungen eingebauter Funktionen (print, typeof, alloc, free usw.)
- Signalbehandlungsfunktionen
- Befehlsausf√ºhrung (exec)

**Kategorien von Builtins:**
- I/O: print, open, read_file, write_file
- Speicher: alloc, free, memset, memcpy, realloc
- Typen: typeof, assert
- Nebenl√§ufigkeit: spawn, join, detach, channel
- System: exec, signal, raise, panic
- FFI: dlopen, dlsym, dlcall, dlclose

#### 5. I/O (`io.c`) - 449 Zeilen

**Zweck:** Datei-I/O und JSON-Serialisierung

**Schl√ºsselfunktionen:**
- Dateiobjektmethoden (read, write, seek, tell, close)
- JSON-Serialisierung/Deserialisierung
- Erkennung zirkul√§rer Referenzen

**Funktionen:**
- Dateiobjekt mit Eigenschaften (Pfad, Modus, geschlossen)
- UTF-8-bewusste Text-I/O
- Bin√§re I/O-Unterst√ºtzung
- JSON-Roundtripping f√ºr Objekte und Arrays

#### 6. FFI (`ffi.c`) - Foreign Function Interface

**Zweck:** Aufrufen von C-Funktionen aus gemeinsam genutzten Bibliotheken

**Schl√ºsselfunktionen:**
- `dlopen()` - Gemeinsam genutzte Bibliothek laden
- `dlsym()` - Funktionszeiger nach Namen abrufen
- `dlcall()` - C-Funktion mit Typkonvertierung aufrufen
- `dlclose()` - Bibliothek entladen

**Funktionen:**
- Integration mit libffi f√ºr dynamische Funktionsaufrufe
- Automatische Typkonvertierung (Hemlock ‚Üî C-Typen)
- Unterst√ºtzung f√ºr alle primitiven Typen
- Zeiger- und Buffer-Unterst√ºtzung

#### 7. Laufzeit (`runtime.c`) - 865 Zeilen

**Zweck:** Ausdrucksauswertung und Anweisungsausf√ºhrung

**Schl√ºsselfunktionen:**
- `eval_expr()` - Ausdr√ºcke auswerten (rekursiv)
- `eval_stmt()` - Anweisungen ausf√ºhren
- Kontrollflussbehandlung (if, while, for, switch usw.)
- Ausnahmebehandlung (try/catch/finally/throw)

**Funktionen:**
- Rekursive Ausdrucksauswertung
- Kurzschluss-Auswertung f√ºr boolesche Ausdr√ºcke
- Methodenaufruferkennung und `self`-Bindung
- Ausnahmepropagierung
- Break/continue/return-Behandlung

### Vorteile des modularen Designs

**1. Trennung der Zust√§ndigkeiten**
- Jedes Modul hat eine klare Verantwortung
- Leicht zu finden, wo Funktionen implementiert sind
- Reduziert kognitive Belastung bei √Ñnderungen

**2. Schnellere inkrementelle Builds**
- Nur modifizierte Module m√ºssen neu kompiliert werden
- Parallele Kompilierung m√∂glich
- K√ºrzere Iterationszeiten w√§hrend der Entwicklung

**3. Einfacheres Testen und Debuggen**
- Module k√∂nnen isoliert getestet werden
- Bugs sind auf spezifische Subsysteme lokalisiert
- Mock-Implementierungen f√ºr Tests m√∂glich

**4. Skalierbarkeit**
- Neue Funktionen k√∂nnen zu geeigneten Modulen hinzugef√ºgt werden
- Module k√∂nnen unabh√§ngig refaktoriert werden
- Codegr√∂√üe pro Datei bleibt handhabbar

**5. Code-Organisation**
- Logische Gruppierung verwandter Funktionalit√§t
- Klarer Abh√§ngigkeitsgraph
- Einfacheres Onboarding f√ºr neue Mitwirkende

---

## Laufzeitarchitektur

### Wertdarstellung

Alle Werte in Hemlock werden durch die `Value`-Struktur unter Verwendung einer tagged union dargestellt:

```c
typedef struct Value {
    ValueType type;  // Laufzeit-Typ-Tag
    union {
        int32_t i32_value;
        int64_t i64_value;
        uint8_t u8_value;
        uint32_t u32_value;
        uint64_t u64_value;
        float f32_value;
        double f64_value;
        bool bool_value;
        char *string_value;
        uint32_t rune_value;
        void *ptr_value;
        Buffer *buffer_value;
        Array *array_value;
        Object *object_value;
        Function *function_value;
        File *file_value;
        Task *task_value;
        Channel *channel_value;
    };
} Value;
```

**Designentscheidungen:**
- **Tagged Union** f√ºr Typsicherheit bei gleichzeitiger Flexibilit√§t
- **Laufzeit-Typ-Tags** erm√∂glichen dynamische Typisierung mit Typpr√ºfung
- **Direkte Wertspeicherung** f√ºr Primitiven (kein Boxing)
- **Zeigerspeicherung** f√ºr heap-allokierte Typen (Strings, Objekte, Arrays)

### Beispiele f√ºr Speicherlayout

**Ganzzahl (i32):**
```
Value {
    type: TYPE_I32,
    i32_value: 42
}
```
- Gesamtgr√∂√üe: ~16 Bytes (8-Byte-Tag + 8-Byte-Union)
- Stack-allokiert
- Keine Heap-Allokation erforderlich

**String:**
```
Value {
    type: TYPE_STRING,
    string_value: 0x7f8a4c000000  // Zeiger auf Heap
}

Heap: "hello\0" (6 Bytes, nullterminiertes UTF-8)
```
- Wert ist 16 Bytes auf dem Stack
- Stringdaten sind heap-allokiert
- Muss manuell freigegeben werden

**Objekt:**
```
Value {
    type: TYPE_OBJECT,
    object_value: 0x7f8a4c001000  // Zeiger auf Heap
}

Heap: Object {
    type_name: "Person",
    fields: [
        { name: "name", value: Value{TYPE_STRING, "Alice"} },
        { name: "age", value: Value{TYPE_I32, 30} }
    ],
    field_count: 2,
    capacity: 4
}
```
- Objektstruktur auf dem Heap
- Felder in dynamischem Array gespeichert
- Feldwerte sind eingebettete Value-Structs

### Umgebungsimplementierung

Variablen werden in Umgebungsketten gespeichert:

```c
typedef struct Environment {
    HashMap *bindings;           // Name ‚Üí Value
    struct Environment *parent;  // Lexikalischer Eltern-Scope
} Environment;
```

**Scope-Ketten-Beispiel:**
```
Globaler Scope: { print: <builtin>, args: <array> }
    ‚Üë
Funktions-Scope: { x: 10, y: 20 }
    ‚Üë
Block-Scope: { i: 0 }
```

**Suchalgorithmus:**
1. Hashmap der aktuellen Umgebung pr√ºfen
2. Falls nicht gefunden, Elternumgebung pr√ºfen
3. Wiederholen bis gefunden oder globaler Scope erreicht
4. Fehler wenn in keinem Scope gefunden

---

## Typsystem-Implementierung

### Typpr√ºfungsstrategie

Hemlock verwendet **Laufzeit-Typpr√ºfung** mit **optionalen Typannotationen**:

```hemlock
let x = 42;           // Keine Typpr√ºfung, inferiert i32
let y: u8 = 255;      // Laufzeitpr√ºfung: Wert muss in u8 passen
let z: i32 = x + y;   // Laufzeitpr√ºfung + Typpromotion
```

**Implementierungsfluss:**
1. **Literalinferenz** - Lexer/Parser bestimmen initialen Typ aus Literal
2. **Typannotationspr√ºfung** - Falls Annotation vorhanden, bei Zuweisung validieren
3. **Promotion** - Bin√§re Operationen werden zu gemeinsamem Typ hochgestuft
4. **Konvertierung** - Explizite Konvertierungen erfolgen bei Bedarf

### Typpromotionsimplementierung

Typpromotion folgt einer festen Hierarchie mit Pr√§zisionserhaltung:

```c
// Vereinfachte Promotionslogik
ValueType promote_types(ValueType a, ValueType b) {
    // f64 gewinnt immer
    if (a == TYPE_F64 || b == TYPE_F64) return TYPE_F64;

    // f32 mit i64/u64 wird zu f64 hochgestuft (Pr√§zisionserhaltung)
    if (a == TYPE_F32 || b == TYPE_F32) {
        ValueType other = (a == TYPE_F32) ? b : a;
        if (other == TYPE_I64 || other == TYPE_U64) return TYPE_F64;
        return TYPE_F32;
    }

    // Gr√∂√üere Integer-Typen gewinnen
    int rank_a = get_type_rank(a);
    int rank_b = get_type_rank(b);
    return (rank_a > rank_b) ? a : b;
}
```

**Typr√§nge:**
- i8: 0
- u8: 1
- i16: 2
- u16: 3
- i32: 4
- u32: 5
- i64: 6
- u64: 7
- f32: 8
- f64: 9

### Duck-Typing-Implementierung

Objekttyppr√ºfung verwendet strukturellen Vergleich:

```c
bool duck_type_check(Object *obj, TypeDef *type_def) {
    // Alle erforderlichen Felder pr√ºfen
    for (each field in type_def) {
        if (!object_has_field(obj, field.name)) {
            return false;  // Fehlendes Feld
        }

        Value *field_value = object_get_field(obj, field.name);
        if (!type_matches(field_value, field.type)) {
            return false;  // Falscher Typ
        }
    }

    return true;  // Alle erforderlichen Felder vorhanden und korrekter Typ
}
```

**Duck-Typing erlaubt:**
- Zus√§tzliche Felder in Objekten (ignoriert)
- Substrukturelle Typisierung (Objekt kann mehr als erforderlich haben)
- Typnamenzuweisung nach Validierung

---

## Speicherverwaltung

### Allokationsstrategie

Hemlock verwendet **manuelle Speicherverwaltung** mit zwei Allokationsprimitiven:

**1. Rohe Zeiger (`ptr`):**
```c
void *alloc(size_t bytes) {
    void *ptr = malloc(bytes);
    if (!ptr) {
        fprintf(stderr, "Kein Speicher mehr\n");
        exit(1);
    }
    return ptr;
}
```
- Direktes malloc/free
- Kein Tracking
- Benutzerverantwortung zur Freigabe

**2. Buffer (`buffer`):**
```c
typedef struct Buffer {
    void *data;
    size_t length;
    size_t capacity;
} Buffer;

Buffer *create_buffer(size_t size) {
    Buffer *buf = malloc(sizeof(Buffer));
    buf->data = malloc(size);
    buf->length = size;
    buf->capacity = size;
    return buf;
}
```
- Verfolgt Gr√∂√üe und Kapazit√§t
- Bereichspr√ºfung beim Zugriff
- Erfordert immer noch manuelles free

### Heap-allokierte Typen

**Strings:**
- UTF-8-Byte-Array auf dem Heap
- Nullterminiert f√ºr C-Interoperabilit√§t
- Ver√§nderbar (kann an Ort und Stelle modifiziert werden)
- Refgez√§hlt (automatisch freigegeben, wenn Scope verlassen wird)

**Objekte:**
- Dynamisches Feldarray
- Feldnamen und Werte auf dem Heap
- Refgez√§hlt (automatisch freigegeben, wenn Scope verlassen wird)
- Zirkul√§re Referenzen m√∂glich (behandelt mit Visited-Set-Tracking)

**Arrays:**
- Dynamisches Kapazit√§tsverdopplungswachstum
- Elemente sind eingebettete Value-Structs
- Automatische Neuzuweisung bei Wachstum
- Refgez√§hlt (automatisch freigegeben, wenn Scope verlassen wird)

**Closures:**
- Erfassen Umgebung per Referenz
- Umgebung ist heap-allokiert
- Closure-Umgebungen werden ordnungsgem√§√ü freigegeben, wenn nicht mehr referenziert

---

## Nebenl√§ufigkeitsmodell

### Threading-Architektur

Hemlock verwendet **1:1-Threading** mit POSIX-Threads (pthreads):

```
Benutzer-Task          OS-Thread          CPU-Kern
------------          ---------          --------
spawn(f1) ------>  pthread_create --> Kern 0
spawn(f2) ------>  pthread_create --> Kern 1
spawn(f3) ------>  pthread_create --> Kern 2
```

**Schl√ºsseleigenschaften:**
- Jedes `spawn()` erstellt einen neuen pthread
- Kernel plant Threads √ºber Kerne
- Echte parallele Ausf√ºhrung (kein GIL)
- Pr√§emptives Multitasking

### Task-Implementierung

```c
typedef struct Task {
    pthread_t thread;        // OS-Thread-Handle
    Value result;            // R√ºckgabewert
    char *error;             // Ausnahmemeldung (falls geworfen)
    pthread_mutex_t lock;    // Sch√ºtzt Zustand
    TaskState state;         // RUNNING, FINISHED, ERROR
} Task;
```

**Task-Lebenszyklus:**
1. `spawn(func, args)` ‚Üí Task erstellen, pthread starten
2. Thread f√ºhrt Funktion mit Argumenten aus
3. Bei R√ºckgabe: Ergebnis speichern, Zustand auf FINISHED setzen
4. Bei Ausnahme: Fehlermeldung speichern, Zustand auf ERROR setzen
5. `join(task)` ‚Üí Auf Thread warten, Ergebnis zur√ºckgeben oder Ausnahme werfen

### Kanal-Implementierung

```c
typedef struct Channel {
    void **buffer;           // Zirkul√§rer Puffer von Value*
    size_t capacity;         // Maximale gepufferte Elemente
    size_t count;            // Aktuelle Elemente im Puffer
    size_t read_index;       // N√§chste Leseposition
    size_t write_index;      // N√§chste Schreibposition
    bool closed;             // Kanal-geschlossen-Flag
    pthread_mutex_t lock;    // Sch√ºtzt Puffer
    pthread_cond_t not_full; // Signal wenn Platz verf√ºgbar
    pthread_cond_t not_empty;// Signal wenn Daten verf√ºgbar
} Channel;
```

**Sende-Operation:**
1. Mutex sperren
2. Warten wenn Puffer voll (cond_wait auf not_full)
3. Wert in buffer[write_index] schreiben
4. write_index inkrementieren (zirkul√§r)
5. not_empty signalisieren
6. Mutex entsperren

**Empfangs-Operation:**
1. Mutex sperren
2. Warten wenn Puffer leer (cond_wait auf not_empty)
3. Wert aus buffer[read_index] lesen
4. read_index inkrementieren (zirkul√§r)
5. not_full signalisieren
6. Mutex entsperren

**Synchronisationsgarantien:**
- Thread-sicheres Senden/Empfangen (durch Mutex gesch√ºtzt)
- Blockierende Semantik (Produzent wartet wenn voll, Konsument wartet wenn leer)
- Geordnete Zustellung (FIFO innerhalb eines Kanals)

---

## Zukunftspl√§ne

### Abgeschlossen: Compiler-Backend ‚úì

Das Compiler-Backend (`hemlockc`) wurde implementiert mit:
- C-Codegenerierung aus AST
- Kompilierzeit-Typpr√ºfung (standardm√§√üig aktiviert)
- Laufzeitbibliothek (`libhemlock_runtime.a`)
- Volle Parit√§t mit Interpreter (98% Testbestehensrate)
- Unboxing-Optimierungsframework

### Aktueller Fokus: Typsystem-Erweiterungen

**Aktuelle Verbesserungen:**
- Vereinheitlichte Typpr√ºfungs- und Typinferenzsysteme
- Kompilierzeit-Typpr√ºfung standardm√§√üig aktiviert
- `--check`-Flag f√ºr Nur-Typ-Validierung
- Typkontext wird an Codegen f√ºr Optimierungshinweise √ºbergeben

### Zuk√ºnftige Erweiterungen

**Potenzielle Erg√§nzungen:**
- Generics/Templates
- Pattern Matching
- LSP-Integration f√ºr typbewusste IDE-Unterst√ºtzung
- Aggressivere Unboxing-Optimierungen
- Escape-Analyse f√ºr Stack-Allokation

### Langfristige Optimierungen

**M√∂gliche Verbesserungen:**
- Inline-Caching f√ºr Methodenaufrufe
- JIT-Kompilierung f√ºr hei√üe Codepfade
- Work-Stealing-Scheduler f√ºr bessere Nebenl√§ufigkeit
- Profilgef√ºhrte Optimierung

---

## Implementierungsrichtlinien

### Hinzuf√ºgen neuer Features

Beim Implementieren neuer Features befolgen Sie diese Richtlinien:

**1. Das richtige Modul w√§hlen:**
- Neue Werttypen ‚Üí `values.c`
- Typkonvertierungen ‚Üí `types.c`
- Eingebaute Funktionen ‚Üí `builtins.c`
- I/O-Operationen ‚Üí `io.c`
- Kontrollfluss ‚Üí `runtime.c`

**2. Alle Schichten aktualisieren:**
- AST-Knotentypen hinzuf√ºgen falls n√∂tig (`ast.h`, `ast.c`)
- Lexer-Token hinzuf√ºgen falls n√∂tig (`lexer.c`)
- Parser-Regeln hinzuf√ºgen (`parser.c`)
- Laufzeitverhalten implementieren (`runtime.c` oder geeignetes Modul)
- Tests hinzuf√ºgen (`tests/`)

**3. Konsistenz beibehalten:**
- Bestehendem Codestil folgen
- Konsistente Namenskonventionen verwenden
- √ñffentliche API in Headern dokumentieren
- Fehlermeldungen klar und konsistent halten

**4. Gr√ºndlich testen:**
- Testf√§lle vor der Implementierung hinzuf√ºgen
- Erfolgs- und Fehlerpfade testen
- Randf√§lle testen
- Keine Speicherlecks verifizieren (valgrind)

### Leistungs√ºberlegungen

**Aktuelle Engp√§sse:**
- HashMap-Suchen f√ºr Variablenzugriff
- Rekursive Funktionsaufrufe (keine TCO)
- String-Verkettung (allokiert jedes Mal neuen String)
- Typpr√ºfungs-Overhead bei jeder Operation

**Optimierungsm√∂glichkeiten:**
- Variablenpositionen cachen (Inline-Caching)
- Endrekursionsoptimierung
- String-Builder f√ºr Verkettung
- Typinferenz um Laufzeitpr√ºfungen zu √ºberspringen

### Debugging-Tipps

**N√ºtzliche Werkzeuge:**
- `valgrind` - Speicherleckerkennung
- `gdb` - Abst√ºrze debuggen
- `-g`-Flag - Debug-Symbole
- `printf`-Debugging - Einfach aber effektiv

**H√§ufige Probleme:**
- Segfault ‚Üí Nullzeiger-Dereferenzierung (R√ºckgabewerte pr√ºfen)
- Speicherleck ‚Üí Fehlender free()-Aufruf (value_free-Pfade pr√ºfen)
- Typfehler ‚Üí type_convert()- und type_check()-Logik pr√ºfen
- Absturz in Threads ‚Üí Race Condition (Mutex-Verwendung pr√ºfen)

---

## Fazit

Hemlocks Implementierung priorisiert:
- **Modularit√§t** - Saubere Trennung der Zust√§ndigkeiten
- **Einfachheit** - Geradlinige Implementierung
- **Explizitheit** - Keine versteckte Magie
- **Wartbarkeit** - Leicht zu verstehen und zu modifizieren

Der aktuelle Tree-Walking-Interpreter ist absichtlich einfach, um schnelle Feature-Entwicklung und Experimente zu erm√∂glichen. Das zuk√ºnftige Compiler-Backend wird die Leistung verbessern und dabei die gleiche Semantik beibehalten.


--------------------------------------------------------------------------------
## Signatur-Syntax
--------------------------------------------------------------------------------

# Design der Signatur-Syntax

> Erweiterung des Typsystems von Hemlock um Funktionstypen, Nullable-Modifikatoren, Typaliase, Const-Parameter und Methodensignaturen.

**Status:** Implementiert (v1.7.0)
**Version:** 1.0
**Autor:** Claude

---

## √úberblick

Dieses Dokument schl√§gt f√ºnf zusammenh√§ngende Typsystem-Erweiterungen vor, die auf der bestehenden Infrastruktur von Hemlock aufbauen:

1. **Funktionstyp-Annotationen** - Erstklassige Funktionstypen
2. **Nullable-Typ-Modifikatoren** - Explizite Null-Behandlung (erweitert bestehendes `nullable`-Flag)
3. **Typaliase** - Benannte Typabk√ºrzungen
4. **Const-Parameter** - Unver√§nderlichkeitsvertr√§ge
5. **Methodensignaturen in Define** - Interface-√§hnliches Verhalten

Diese Features teilen die Philosophie: **explizit statt implizit, optional aber durchgesetzt wenn verwendet**.

---

## 1. Funktionstyp-Annotationen

### Motivation

Derzeit gibt es keine M√∂glichkeit, die Signatur einer Funktion als Typ auszudr√ºcken:

```hemlock
// Aktuell: callback hat keine Typinformation
fn map(arr: array, callback) { ... }

// Vorgeschlagen: expliziter Funktionstyp
fn map(arr: array, callback: fn(any, i32): any): array { ... }
```

### Syntax

```hemlock
// Einfacher Funktionstyp
fn(i32, i32): i32

// Mit Parameternamen (nur Dokumentation, nicht durchgesetzt)
fn(a: i32, b: i32): i32

// Kein R√ºckgabewert (void)
fn(string): void
fn(string)              // Kurzform: `: void` weglassen

// Nullbarer R√ºckgabewert
fn(i32): string?

// Optionale Parameter
fn(name: string, age?: i32): void

// Rest-Parameter
fn(...args: array): i32

// Keine Parameter
fn(): bool

// H√∂herer Ordnung: Funktion, die Funktion zur√ºckgibt
fn(i32): fn(i32): i32

// Async-Funktionstyp
async fn(i32): i32
```

### Verwendungsbeispiele

```hemlock
// Variable mit Funktionstyp
let add: fn(i32, i32): i32 = fn(a, b) { return a + b; };

// Funktionsparameter
fn apply(f: fn(i32): i32, x: i32): i32 {
    return f(x);
}

// R√ºckgabetyp ist Funktion
fn make_adder(n: i32): fn(i32): i32 {
    return fn(x) { return x + n; };
}

// Array von Funktionen
let ops: array<fn(i32, i32): i32> = [add, subtract, multiply];

// Objektfeld
define EventHandler {
    name: string;
    callback: fn(Event): void;
}
```

### AST-√Ñnderungen

```c
// In TypeKind-Enum (include/ast.h)
typedef enum {
    // ... bestehende Typen ...
    TYPE_FUNCTION,      // NEU: Funktionstyp
} TypeKind;

// In Type-Struct (include/ast.h)
struct Type {
    TypeKind kind;
    // ... bestehende Felder ...

    // F√ºr TYPE_FUNCTION:
    struct Type **param_types;      // Parametertypen
    char **param_names;             // Optionale Parameternamen (Doku)
    int *param_optional;            // Welche Parameter optional sind
    int num_params;
    char *rest_param_name;          // Rest-Parametername oder NULL
    struct Type *rest_param_type;   // Rest-Parametertyp
    struct Type *return_type;       // R√ºckgabetyp (NULL = void)
    int is_async;                   // async fn-Typ
};
```

### Parsing

Funktionstypen beginnen mit `fn` (oder `async fn`) gefolgt von Parameterliste:

```
function_type := ["async"] "fn" "(" [param_type_list] ")" [":" type]
param_type_list := param_type ("," param_type)*
param_type := [identifier ":"] ["?"] type | "..." [identifier] [":" type]
```

**Disambiguierung:** Beim Parsen eines Typs und `fn` wird angetroffen:
- Falls gefolgt von `(`, ist es ein Funktionstyp
- Sonst Syntaxfehler (blo√ües `fn` ist kein g√ºltiger Typ)

### Typkompatibilit√§t

```hemlock
// Exakte √úbereinstimmung f√ºr Funktionstypen erforderlich
let f: fn(i32): i32 = fn(x: i32): i32 { return x; };  // OK

// Parameter-Kontravarianz (breitere Typen akzeptieren ist OK)
let g: fn(any): i32 = fn(x: i32): i32 { return x; };  // OK: i32 <: any

// R√ºckgabe-Kovarianz (engere Typen zur√ºckgeben ist OK)
let h: fn(i32): any = fn(x: i32): i32 { return x; };  // OK: i32 <: any

// Arit√§t muss √ºbereinstimmen
let bad: fn(i32): i32 = fn(a, b) { return a; };       // FEHLER: Arit√§t stimmt nicht √ºberein

// Optionale Parameter kompatibel mit erforderlichen
let opt: fn(i32, i32?): i32 = fn(a, b?: 0) { return a + b; };  // OK
```

---

## 2. Nullable-Typ-Modifikatoren

### Motivation

Das `?`-Suffix macht Null-Akzeptanz in Signaturen explizit:

```hemlock
// Aktuell: unklar ob null g√ºltig ist
fn find(arr: array, val: any): i32 { ... }

// Vorgeschlagen: explizit nullbarer R√ºckgabewert
fn find(arr: array, val: any): i32? { ... }
```

### Syntax

```hemlock
// Nullbare Typen mit ?-Suffix
string?           // String oder null
i32?              // i32 oder null
User?             // User oder null
array<i32>?       // Array oder null
fn(i32): i32?     // Funktion, die i32 oder null zur√ºckgibt

// Kombination mit Funktionstypen
fn(string?): i32          // Akzeptiert String oder null
fn(string): i32?          // Gibt i32 oder null zur√ºck
fn(string?): i32?         // Beide nullbar

// In Define
define Result {
    value: any?;
    error: string?;
}
```

### Implementierungshinweise

**Existiert bereits:** Das `Type.nullable`-Flag ist bereits im AST. Dieses Feature ben√∂tigt haupts√§chlich:
1. Parser-Unterst√ºtzung f√ºr `?`-Suffix bei jedem Typ (verifizieren/erweitern)
2. Ordnungsgem√§√üe Komposition mit Funktionstypen
3. Laufzeit-Durchsetzung

### Typkompatibilit√§t

```hemlock
// Nicht-nullbar kann nullbar zugewiesen werden
let x: i32? = 42;           // OK
let y: i32? = null;         // OK

// Nullbar kann NICHT nicht-nullbar zugewiesen werden
let z: i32 = x;             // FEHLER: x k√∂nnte null sein

// Null-Koaleszenz zum Auspacken
let z: i32 = x ?? 0;        // OK: ?? liefert Standardwert

// Optionale Verkettung gibt nullbar zur√ºck
let name: string? = user?.name;
```

---

## 3. Typaliase

### Motivation

Komplexe Typen profitieren von benannten Abk√ºrzungen:

```hemlock
// Aktuell: repetitive zusammengesetzte Typen
fn process(entity: HasName & HasId & HasTimestamp) { ... }
fn validate(entity: HasName & HasId & HasTimestamp) { ... }

// Vorgeschlagen: benannter Alias
type Entity = HasName & HasId & HasTimestamp;
fn process(entity: Entity) { ... }
fn validate(entity: Entity) { ... }
```

### Syntax

```hemlock
// Einfacher Alias
type Integer = i32;
type Text = string;

// Zusammengesetzter Typ-Alias
type Entity = HasName & HasId;
type Auditable = HasCreatedAt & HasUpdatedAt & HasCreatedBy;

// Funktionstyp-Alias
type Callback = fn(Event): void;
type Predicate = fn(any): bool;
type Reducer = fn(acc: any, val: any): any;
type AsyncTask = async fn(): any;

// Nullbarer Alias
type OptionalString = string?;

// Generischer Alias (falls generische Typaliase unterst√ºtzt werden)
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };

// Array-Typ-Alias
type IntArray = array<i32>;
type Matrix = array<array<f64>>;
```

### Scope und Sichtbarkeit

```hemlock
// Standardm√§√üig modul-begrenzt
type Callback = fn(Event): void;

// Exportierbar
export type Handler = fn(Request): Response;

// In einer anderen Datei
import { Handler } from "./handlers.hml";
fn register(h: Handler) { ... }
```

### AST-√Ñnderungen

```c
// Neuer Statement-Typ
typedef enum {
    // ... bestehende Statements ...
    STMT_TYPE_ALIAS,    // NEU
} StmtKind;

// In Stmt-Union
struct {
    char *name;                 // Aliasname
    char **type_params;         // Generische Parameter: <T, U>
    int num_type_params;
    Type *aliased_type;         // Der eigentliche Typ
} type_alias;
```

### Parsing

```
type_alias := "type" identifier ["<" type_params ">"] "=" type ";"
```

**Hinweis:** `type` ist ein neues Schl√ºsselwort. Auf Konflikte mit bestehenden Bezeichnern pr√ºfen.

### Aufl√∂sung

Typaliase werden aufgel√∂st bei:
- **Parse-Zeit:** Alias wird in Typumgebung aufgezeichnet
- **Pr√ºf-Zeit:** Alias wird zum zugrunde liegenden Typ erweitert
- **Laufzeit:** Alias ist transparent (gleich wie zugrunde liegender Typ)

```hemlock
type MyInt = i32;
let x: MyInt = 42;
typeof(x);           // "i32" (nicht "MyInt")
```

---

## 4. Const-Parameter

### Motivation

Unver√§nderlichkeitsabsicht in Funktionssignaturen signalisieren:

```hemlock
// Aktuell: unklar ob Array modifiziert wird
fn print_all(items: array) { ... }

// Vorgeschlagen: expliziter Unver√§nderlichkeitsvertrag
fn print_all(const items: array) { ... }
```

### Syntax

```hemlock
// Const-Parameter
fn process(const data: buffer) {
    // data[0] = 0;        // FEHLER: kann const nicht mutieren
    let x = data[0];       // OK: Lesen erlaubt
    return x;
}

// Mehrere Const-Parameter
fn compare(const a: array, const b: array): bool { ... }

// Gemischte const und ver√§nderliche
fn update(const source: array, target: array) {
    for (item in source) {
        target.push(item);   // OK: target ist ver√§nderlich
    }
}

// Const mit Typinferenz
fn log(const msg) {
    print(msg);
}

// Const in Funktionstypen
type Reader = fn(const buffer): i32;
```

### Was Const verhindert

```hemlock
fn bad(const arr: array) {
    arr.push(1);         // FEHLER: mutierende Methode
    arr.pop();           // FEHLER: mutierende Methode
    arr[0] = 5;          // FEHLER: Index-Zuweisung
    arr.clear();         // FEHLER: mutierende Methode
}

fn ok(const arr: array) {
    let x = arr[0];      // OK: Lesen
    let len = len(arr);  // OK: L√§ngenpr√ºfung
    let copy = arr.slice(0, 10);  // OK: erstellt neues Array
    for (item in arr) {  // OK: Iteration
        print(item);
    }
}
```

### Mutierende vs. nicht-mutierende Methoden

| Typ | Mutierend (blockiert durch const) | Nicht-mutierend (erlaubt) |
|-----|-----------------------------------|---------------------------|
| array | push, pop, shift, unshift, insert, remove, clear, reverse (in-place) | slice, concat, map, filter, find, contains, first, last, join |
| string | Index-Zuweisung (`s[0] = 'x'`) | alle Methoden (geben neue Strings zur√ºck) |
| buffer | Index-Zuweisung, memset, memcpy (an) | Index-Lesen, slice |
| object | Feld-Zuweisung | Feld-Lesen |

### AST-√Ñnderungen

```c
// In Funktionsausdruck (include/ast.h)
struct {
    // ... bestehende Felder ...
    int *param_is_const;    // NEU: 1 wenn const, 0 sonst
} function;

// In Type-Struct f√ºr Funktionstypen
struct Type {
    // ... bestehende Felder ...
    int *param_is_const;    // F√ºr TYPE_FUNCTION
};
```

### Durchsetzung

**Interpreter:**
- Const-heit in Variablenbindungen verfolgen
- Vor Mutationsoperationen pr√ºfen
- Laufzeitfehler bei Const-Verletzung

**Compiler:**
- Const-qualifizierte C-Variablen emittieren wo vorteilhaft
- Statische Analyse f√ºr Const-Verletzungen
- Warnung/Fehler zur Kompilierzeit

---

## 5. Methodensignaturen in Define

### Motivation

`define`-Bl√∂cken erlauben, erwartete Methoden zu spezifizieren, nicht nur Datenfelder:

```hemlock
// Aktuell: nur Datenfelder
define User {
    name: string;
    age: i32;
}

// Vorgeschlagen: Methodensignaturen
define Comparable {
    fn compare(other: Self): i32;
}

define Serializable {
    fn serialize(): string;
    fn deserialize(data: string): Self;  // Statische Methode
}
```

### Syntax

```hemlock
// Methodensignatur (kein Body)
define Hashable {
    fn hash(): i32;
}

// Mehrere Methoden
define Collection {
    fn size(): i32;
    fn is_empty(): bool;
    fn contains(item: any): bool;
}

// Gemischte Felder und Methoden
define Entity {
    id: i32;
    name: string;
    fn validate(): bool;
    fn serialize(): string;
}

// Self-Typ verwenden
define Cloneable {
    fn clone(): Self;
}

define Comparable {
    fn compare(other: Self): i32;
    fn equals(other: Self): bool;
}

// Optionale Methoden
define Printable {
    fn to_string(): string;
    fn debug_string?(): string;  // Optionale Methode (kann fehlen)
}

// Methoden mit Standard-Implementierungen
define Ordered {
    fn compare(other: Self): i32;  // Erforderlich

    // Standard-Implementierungen (geerbt wenn nicht √ºberschrieben)
    fn less_than(other: Self): bool {
        return self.compare(other) < 0;
    }
    fn greater_than(other: Self): bool {
        return self.compare(other) > 0;
    }
    fn equals(other: Self): bool {
        return self.compare(other) == 0;
    }
}
```

### Der `Self`-Typ

`Self` bezieht sich auf den konkreten Typ, der das Interface implementiert:

```hemlock
define Addable {
    fn add(other: Self): Self;
}

// Bei Verwendung:
let a: Addable = {
    value: 10,
    add: fn(other) {
        return { value: self.value + other.value, add: self.add };
    }
};
```

### Strukturelle Typisierung (Duck-Typing)

Methodensignaturen verwenden das gleiche Duck-Typing wie Felder:

```hemlock
define Stringifiable {
    fn to_string(): string;
}

// Jedes Objekt mit to_string()-Methode erf√ºllt Stringifiable
let x: Stringifiable = {
    name: "test",
    to_string: fn() { return self.name; }
};

// Zusammengesetzte Typen mit Methoden
define Named { name: string; }
define Printable { fn to_string(): string; }

type NamedPrintable = Named & Printable;

let y: NamedPrintable = {
    name: "Alice",
    to_string: fn() { return "Name: " + self.name; }
};
```

### AST-√Ñnderungen

```c
// define_object in Stmt-Union erweitern
struct {
    char *name;
    char **type_params;
    int num_type_params;

    // Felder (bestehend)
    char **field_names;
    Type **field_types;
    int *field_optional;
    Expr **field_defaults;
    int num_fields;

    // Methoden (NEU)
    char **method_names;
    Type **method_types;        // TYPE_FUNCTION
    int *method_optional;       // Optionale Methoden (fn name?(): type)
    Expr **method_defaults;     // Standard-Implementierungen (NULL wenn nur Signatur)
    int num_methods;
} define_object;
```

### Typpr√ºfung

Beim Pr√ºfen von `value: InterfaceType`:
1. Pr√ºfen dass alle erforderlichen Felder mit kompatiblen Typen existieren
2. Pr√ºfen dass alle erforderlichen Methoden mit kompatiblen Signaturen existieren
3. Optionale Felder/Methoden d√ºrfen fehlen

```hemlock
define Sortable {
    fn compare(other: Self): i32;
}

// G√ºltig: hat compare-Methode
let valid: Sortable = {
    value: 10,
    compare: fn(other) { return self.value - other.value; }
};

// Ung√ºltig: fehlendes compare
let invalid: Sortable = { value: 10 };  // FEHLER: fehlende Methode 'compare'

// Ung√ºltig: falsche Signatur
let wrong: Sortable = {
    compare: fn() { return 0; }  // FEHLER: erwartet (Self): i32
};
```

---

## Interaktionsbeispiele

### Alle Features kombinieren

```hemlock
// Typalias f√ºr komplexen Funktionstyp
type EventCallback = fn(event: Event, context: Context?): bool;

// Typalias f√ºr zusammengesetztes Interface
type Entity = HasId & HasName & Serializable;

// Define mit Methodensignaturen
define Repository<T> {
    fn find(id: i32): T?;
    fn save(const entity: T): bool;
    fn delete(id: i32): bool;
    fn find_all(predicate: fn(T): bool): array<T>;
}

// Alles zusammen verwenden
fn create_user_repo(): Repository<User> {
    let users: array<User> = [];

    return {
        find: fn(id) {
            for (u in users) {
                if (u.id == id) { return u; }
            }
            return null;
        },
        save: fn(const entity) {
            users.push(entity);
            return true;
        },
        delete: fn(id) {
            // ...
            return true;
        },
        find_all: fn(predicate) {
            return users.filter(predicate);
        }
    };
}
```

### Callbacks mit expliziten Typen

```hemlock
type ClickHandler = fn(event: MouseEvent): void;
type KeyHandler = fn(event: KeyEvent, modifiers: i32): bool;

define Widget {
    x: i32;
    y: i32;
    on_click: ClickHandler?;
    on_key: KeyHandler?;
}

fn create_button(label: string, handler: ClickHandler): Widget {
    return {
        x: 0, y: 0,
        on_click: handler,
        on_key: null
    };
}
```

### Nullbare Funktionstypen

```hemlock
// Optionaler Callback
fn fetch(url: string, on_complete: fn(Response): void?): void {
    let response = http_get(url);
    if (on_complete != null) {
        on_complete(response);
    }
}

// Nullbarer R√ºckgabewert vom Funktionstyp
type Parser = fn(input: string): AST?;

fn try_parse(parsers: array<Parser>, input: string): AST? {
    for (p in parsers) {
        let result = p(input);
        if (result != null) {
            return result;
        }
    }
    return null;
}
```

---

## Implementierungs-Roadmap

### Phase 1: Kern-Infrastruktur
1. `TYPE_FUNCTION` zum TypeKind-Enum hinzuf√ºgen
2. Type-Struct mit Funktionstyp-Feldern erweitern
3. `CHECKED_FUNCTION` zum Compiler-Typpr√ºfer hinzuf√ºgen
4. `Self`-Typ-Unterst√ºtzung hinzuf√ºgen (TYPE_SELF)

### Phase 2: Parsing
1. `parse_function_type()` im Parser implementieren
2. `fn(...)` in Typposition behandeln
3. `type`-Schl√ºsselwort und `STMT_TYPE_ALIAS`-Parsing hinzuf√ºgen
4. `const`-Parameter-Modifikator-Parsing hinzuf√ºgen
5. Define-Parsing f√ºr Methodensignaturen erweitern

### Phase 3: Typpr√ºfung
1. Funktionstyp-Kompatibilit√§tsregeln
2. Typalias-Aufl√∂sung und -Erweiterung
3. Const-Parameter-Mutationspr√ºfung
4. Methodensignatur-Validierung in Define-Typen
5. Self-Typ-Aufl√∂sung

### Phase 4: Laufzeit
1. Funktionstyp-Validierung an Aufrufstellen
2. Const-Verletzungserkennung
3. Typalias-Transparenz

### Phase 5: Parit√§tstests
1. Funktionstyp-Annotationstests
2. Nullable-Kompositionstests
3. Typalias-Tests
4. Const-Parameter-Tests
5. Methodensignatur-Tests

---

## Designentscheidungen

### 1. Generische Typaliase: **JA**

Typaliase unterst√ºtzen generische Parameter:

```hemlock
// Generische Typaliase
type Pair<T> = { first: T, second: T };
type Result<T, E> = { value: T?, error: E? };
type Mapper<T, U> = fn(T): U;
type AsyncResult<T> = async fn(): T?;

// Verwendung
let coords: Pair<f64> = { first: 3.14, second: 2.71 };
let result: Result<User, string> = { value: user, error: null };
let transform: Mapper<i32, string> = fn(n) { return n.to_string(); };
```

### 2. Const-Propagierung: **TIEF**

Const-Parameter sind vollst√§ndig unver√§nderlich - keine Mutation √ºber irgendeinen Pfad:

```hemlock
fn process(const arr: array<object>) {
    arr.push({});        // FEHLER: kann const-Array nicht mutieren
    arr[0] = {};         // FEHLER: kann const-Array nicht mutieren
    arr[0].x = 5;        // FEHLER: kann nicht durch const mutieren (TIEF)

    let x = arr[0].x;    // OK: Lesen ist in Ordnung
    let copy = arr[0];   // OK: erstellt eine Kopie
    copy.x = 5;          // OK: Kopie ist nicht const
}

fn nested(const obj: object) {
    obj.user.name = "x"; // FEHLER: tiefes const verhindert verschachtelte Mutation
    obj.items[0] = 1;    // FEHLER: tiefes const verhindert verschachtelte Mutation
}
```

**Begr√ºndung:** Tiefes const bietet st√§rkere Garantien und ist n√ºtzlicher, um
Datenintegrit√§t zu gew√§hrleisten. Wenn Sie verschachtelte Daten mutieren m√ºssen, erstellen Sie zuerst eine Kopie.

### 3. Self in eigenst√§ndigen Typaliasen: **NEIN**

`Self` ist nur innerhalb von `define`-Bl√∂cken g√ºltig, wo es eine klare Bedeutung hat:

```hemlock
// G√ºltig: Self bezieht sich auf den definierten Typ
define Comparable {
    fn compare(other: Self): i32;
}

// Ung√ºltig: Self hat hier keine Bedeutung
type Cloner = fn(Self): Self;  // FEHLER: Self au√üerhalb des Define-Kontexts

// Stattdessen Generics verwenden:
type Cloner<T> = fn(T): T;
```

### 4. Methoden-Standard-Implementierungen: **JA (nur einfache)**

Erlauben Sie Standard-Implementierungen f√ºr einfache/Hilfsmethoden:

```hemlock
define Comparable {
    // Erforderlich: muss implementiert werden
    fn compare(other: Self): i32;

    // Standard-Implementierungen (einfache Hilfsmethoden)
    fn equals(other: Self): bool {
        return self.compare(other) == 0;
    }
    fn less_than(other: Self): bool {
        return self.compare(other) < 0;
    }
    fn greater_than(other: Self): bool {
        return self.compare(other) > 0;
    }
}

define Printable {
    fn to_string(): string;

    // Standard: delegiert an erforderliche Methode
    fn print() {
        print(self.to_string());
    }
    fn println() {
        print(self.to_string() + "\n");
    }
}

// Objekt muss nur erforderliche Methoden implementieren
let item: Comparable = {
    value: 42,
    compare: fn(other) { return self.value - other.value; }
    // equals, less_than, greater_than werden von Standards geerbt
};

item.less_than({ value: 50, compare: item.compare });  // true
```

**Richtlinien f√ºr Standards:**
- Halten Sie sie einfach (1-3 Zeilen)
- Sollten an erforderliche Methoden delegieren
- Keine komplexe Logik oder Nebeneffekte
- Nur Primitiven und einfache Kompositionen

### 5. Varianz: **INFERIERT (keine expliziten Annotationen)**

Varianz wird aus der Verwendung von Typparametern inferiert:

```hemlock
// Varianz ist automatisch basierend auf Position
type Producer<T> = fn(): T;           // T in R√ºckgabe = kovariant
type Consumer<T> = fn(T): void;       // T in Parameter = kontravariant
type Transformer<T> = fn(T): T;       // T in beiden = invariant

// Beispiel: Dog <: Animal (Dog ist Subtyp von Animal)
let dog_producer: Producer<Dog> = fn() { return new_dog(); };
let animal_producer: Producer<Animal> = dog_producer;  // OK: kovariant

let animal_consumer: Consumer<Animal> = fn(a) { print(a); };
let dog_consumer: Consumer<Dog> = animal_consumer;     // OK: kontravariant
```

**Warum inferieren?**
- Weniger Boilerplate (`<out T>` / `<in T>` f√ºgt Rauschen hinzu)
- Folgt "explizit statt implizit" - die Position IST explizit
- Entspricht der Behandlung von Funktionstyp-Varianz in den meisten Sprachen
- Fehler sind klar, wenn Varianzregeln verletzt werden

---

## Anhang: Grammatik-√Ñnderungen

```ebnf
(* Typen *)
type := simple_type | compound_type | function_type
simple_type := base_type ["?"] | identifier ["<" type_args ">"] ["?"]
compound_type := simple_type ("&" simple_type)+
function_type := ["async"] "fn" "(" [param_types] ")" [":" type]

base_type := "i8" | "i16" | "i32" | "i64"
           | "u8" | "u16" | "u32" | "u64"
           | "f32" | "f64" | "bool" | "string" | "rune"
           | "ptr" | "buffer" | "void" | "null"
           | "array" ["<" type ">"]
           | "object"
           | "Self"

param_types := param_type ("," param_type)*
param_type := ["const"] [identifier ":"] ["?"] type
            | "..." [identifier] [":" type]

type_args := type ("," type)*

(* Statements *)
type_alias := "type" identifier ["<" type_params ">"] "=" type ";"

define_stmt := "define" identifier ["<" type_params ">"] "{" define_members "}"
define_members := (field_def | method_def)*
field_def := identifier (":" type ["=" expr] | "?:" (type | expr)) ";"?
method_def := "fn" identifier ["?"] "(" [param_types] ")" [":" type] (block | ";")
            (* "?" markiert optionale Methode, block liefert Standard-Implementierung *)

(* Parameter *)
param := ["const"] ["ref"] identifier [":" type] ["?:" expr]
       | "..." identifier [":" type]
```



################################################################################
# MITWIRKEN
################################################################################

--------------------------------------------------------------------------------
## Richtlinien
--------------------------------------------------------------------------------

# Beitragen zu Hemlock

Vielen Dank f√ºr Ihr Interesse, zu Hemlock beizutragen! Diese Anleitung hilft Ihnen zu verstehen, wie Sie effektiv beitragen k√∂nnen, w√§hrend Sie die Designphilosophie und Codequalit√§t der Sprache beibehalten.

---

## Inhaltsverzeichnis

- [Bevor Sie beginnen](#bevor-sie-beginnen)
- [Beitrags-Workflow](#beitrags-workflow)
- [Code-Stilrichtlinien](#code-stilrichtlinien)
- [Was Sie beitragen k√∂nnen](#was-sie-beitragen-k√∂nnen)
- [Was Sie NICHT beitragen sollten](#was-sie-nicht-beitragen-sollten)
- [H√§ufige Muster](#h√§ufige-muster)
- [Neue Funktionen hinzuf√ºgen](#neue-funktionen-hinzuf√ºgen)
- [Code-Review-Prozess](#code-review-prozess)

---

## Bevor Sie beginnen

### Erforderliche Lekt√ºre

Bevor Sie beitragen, lesen Sie bitte diese Dokumente in der angegebenen Reihenfolge:

1. **`/home/user/hemlock/docs/design/philosophy.md`** - Verstehen Sie Hemlocks Kernprinzipien
2. **`/home/user/hemlock/docs/design/implementation.md`** - Lernen Sie die Codebase-Struktur kennen
3. **`/home/user/hemlock/docs/contributing/testing.md`** - Verstehen Sie die Testanforderungen
4. **Dieses Dokument** - Lernen Sie die Beitragsrichtlinien kennen

### Voraussetzungen

**Erforderliches Wissen:**
- C-Programmierung (Zeiger, Speicherverwaltung, Strukturen)
- Compiler-/Interpreter-Grundlagen (Lexing, Parsing, AST)
- Git- und GitHub-Workflow
- Unix/Linux-Kommandozeile

**Erforderliche Werkzeuge:**
- GCC- oder Clang-Compiler
- Make-Build-System
- Git-Versionskontrolle
- Valgrind (zur Erkennung von Speicherlecks)
- Einfacher Texteditor oder IDE

### Kommunikationskan√§le

**Wo Sie Fragen stellen k√∂nnen:**
- GitHub Issues - Fehlerberichte und Feature-Anfragen
- GitHub Discussions - Allgemeine Fragen und Design-Diskussionen
- Pull-Request-Kommentare - Spezifisches Code-Feedback

---

## Beitrags-Workflow

### 1. Ein Issue finden oder erstellen

**Bevor Sie Code schreiben:**
- Pr√ºfen Sie, ob ein Issue f√ºr Ihren Beitrag existiert
- Falls nicht, erstellen Sie eines, das beschreibt, was Sie tun m√∂chten
- Warten Sie auf Feedback der Maintainer, bevor Sie gro√üe √Ñnderungen beginnen
- Kleine Fehlerbehebungen k√∂nnen diesen Schritt √ºberspringen

**Gute Issue-Beschreibungen enthalten:**
- Problembeschreibung (was defekt ist oder fehlt)
- Vorgeschlagene L√∂sung (wie Sie es beheben m√∂chten)
- Beispiele (Code-Snippets, die das Problem zeigen)
- Begr√ºndung (warum diese √Ñnderung zu Hemlocks Philosophie passt)

### 2. Fork und Clone

```bash
# Forken Sie zuerst das Repository auf GitHub, dann:
git clone https://github.com/IHR_BENUTZERNAME/hemlock.git
cd hemlock
git checkout -b feature/ihr-feature-name
```

### 3. Ihre √Ñnderungen vornehmen

Befolgen Sie diese Richtlinien:
- Schreiben Sie zuerst Tests (TDD-Ansatz)
- Implementieren Sie das Feature
- Stellen Sie sicher, dass alle Tests bestehen
- Pr√ºfen Sie auf Speicherlecks
- Aktualisieren Sie die Dokumentation

### 4. Ihre √Ñnderungen testen

```bash
# F√ºhren Sie die vollst√§ndige Test-Suite aus
make test

# F√ºhren Sie eine bestimmte Testkategorie aus
./tests/run_tests.sh tests/category/

# Pr√ºfen Sie auf Speicherlecks
valgrind ./hemlock tests/your_test.hml

# Bauen und testen
make clean && make && make test
```

### 5. Ihre √Ñnderungen committen

**Gute Commit-Nachrichten:**
```
Add bitwise operators for integer types

- Implement &, |, ^, <<, >>, ~ operators
- Add type checking to ensure integer-only operations
- Update operator precedence table
- Add comprehensive tests for all operators

Closes #42
```

**Commit-Nachrichten-Format:**
- Erste Zeile: Kurze Zusammenfassung (max. 50 Zeichen)
- Leerzeile
- Detaillierte Erkl√§rung (Zeilenumbruch bei 72 Zeichen)
- Issue-Nummern referenzieren

### 6. Einen Pull Request einreichen

**Vor dem Einreichen:**
- Rebasen Sie auf den neuesten Main-Branch
- Stellen Sie sicher, dass alle Tests bestehen
- F√ºhren Sie Valgrind aus, um auf Lecks zu pr√ºfen
- Aktualisieren Sie CLAUDE.md, wenn Sie benutzersichtbare Features hinzuf√ºgen

**Die Pull-Request-Beschreibung sollte enthalten:**
- Welches Problem dies l√∂st
- Wie es gel√∂st wird
- Breaking Changes (falls vorhanden)
- Beispiele f√ºr neue Syntax oder Verhaltensweisen
- Testabdeckungs-Zusammenfassung

---

## Code-Stilrichtlinien

### C-Code-Stil

**Formatierung:**
```c
// Mit 4 Leerzeichen einr√ºcken (keine Tabs)
// K&R-Klammerstil f√ºr Funktionen
void function_name(int arg1, char *arg2)
{
    if (condition) {
        // Klammer auf derselben Zeile f√ºr Kontrollstrukturen
        do_something();
    }
}

// Zeilenl√§nge: maximal 100 Zeichen
// Leerzeichen um Operatoren verwenden
int result = (a + b) * c;

// Zeiger-Sternchen beim Typ
char *string;   // Gut
char* string;   // Vermeiden
char * string;  // Vermeiden
```

**Namenskonventionen:**
```c
// Funktionen: kleinbuchstaben_mit_unterstrichen
void eval_expression(ASTNode *node);

// Typen: PascalCase
typedef struct Value Value;
typedef enum ValueType ValueType;

// Konstanten: GROSSBUCHSTABEN_MIT_UNTERSTRICHEN
#define MAX_BUFFER_SIZE 4096

// Variablen: kleinbuchstaben_mit_unterstrichen
int item_count;
Value *current_value;

// Enums: TYP_PRAEFIX_NAME
typedef enum {
    TYPE_I32,
    TYPE_STRING,
    TYPE_OBJECT
} ValueType;
```

**Kommentare:**
```c
// Einzeilige Kommentare f√ºr kurze Erkl√§rungen
// Vollst√§ndige S√§tze mit korrekter Gro√üschreibung verwenden

/*
 * Mehrzeilige Kommentare f√ºr l√§ngere Erkl√§rungen
 * Sternchen f√ºr Lesbarkeit ausrichten
 */

/**
 * Funktionsdokumentations-Kommentar
 * @param node - AST-Knoten zur Auswertung
 * @return Ausgewerteter Wert
 */
Value eval_expr(ASTNode *node);
```

**Fehlerbehandlung:**
```c
// Alle malloc-Aufrufe pr√ºfen
char *buffer = malloc(size);
if (!buffer) {
    fprintf(stderr, "Fehler: Speicher ersch√∂pft\n");
    exit(1);
}

// Kontext in Fehlermeldungen bereitstellen
if (file == NULL) {
    fprintf(stderr, "Fehler: Konnte '%s' nicht √∂ffnen: %s\n",
            filename, strerror(errno));
    exit(1);
}

// Aussagekr√§ftige Fehlermeldungen verwenden
// Schlecht: "Fehler: Ung√ºltiger Wert"
// Gut: "Fehler: Integer erwartet, String erhalten"
```

**Speicherverwaltung:**
```c
// Immer freigeben, was Sie allokieren
Value *val = value_create_i32(42);
// ... val verwenden
value_free(val);

// Zeiger nach dem Freigeben auf NULL setzen (verhindert Double-Free)
free(ptr);
ptr = NULL;

// Eigent√ºmerschaft in Kommentaren dokumentieren
// Diese Funktion √ºbernimmt das Eigentum von 'value' und wird es freigeben
void store_value(Value *value);

// Diese Funktion √ºbernimmt NICHT das Eigentum (Aufrufer muss freigeben)
Value *get_value(void);
```

### Code-Organisation

**Dateistruktur:**
```c
// 1. Includes (System-Header zuerst, dann lokale)
#include <stdio.h>
#include <stdlib.h>
#include "internal.h"
#include "values.h"

// 2. Konstanten und Makros
#define INITIAL_CAPACITY 16

// 3. Typdefinitionen
typedef struct Foo Foo;

// 4. Statische Funktionsdeklarationen (interne Hilfsfunktionen)
static void helper_function(void);

// 5. √ñffentliche Funktionsimplementierungen
void public_api_function(void)
{
    // Implementierung
}

// 6. Statische Funktionsimplementierungen
static void helper_function(void)
{
    // Implementierung
}
```

**Header-Dateien:**
```c
// Header-Guards verwenden
#ifndef HEMLOCK_MODULE_H
#define HEMLOCK_MODULE_H

// Forward-Deklarationen
typedef struct Value Value;

// Nur √∂ffentliche API in Headern
void public_function(Value *val);

// Parameter und R√ºckgabewerte dokumentieren
/**
 * Wertet einen Ausdrucks-AST-Knoten aus
 * @param node - Der auszuwertende AST-Knoten
 * @param env - Die aktuelle Umgebung
 * @return Der Ergebniswert
 */
Value *eval_expr(ASTNode *node, Environment *env);

#endif // HEMLOCK_MODULE_H
```

---

## Was Sie beitragen k√∂nnen

### Erw√ºnschte Beitr√§ge

**Fehlerbehebungen:**
- Speicherlecks
- Segmentation Faults
- Fehlerhaftes Verhalten
- Verbesserungen von Fehlermeldungen

**Dokumentation:**
- Code-Kommentare
- API-Dokumentation
- Benutzerhandb√ºcher und Tutorials
- Beispielprogramme
- Testfall-Dokumentation

**Tests:**
- Zus√§tzliche Testf√§lle f√ºr bestehende Features
- Abdeckung von Randf√§llen
- Regressionstests f√ºr behobene Fehler
- Performance-Benchmarks

**Kleine Feature-Erg√§nzungen:**
- Neue eingebaute Funktionen (wenn sie zur Philosophie passen)
- String-/Array-Methoden
- Hilfsfunktionen
- Verbesserungen der Fehlerbehandlung

**Performance-Verbesserungen:**
- Schnellere Algorithmen (ohne √Ñnderung der Semantik)
- Reduzierung des Speicherverbrauchs
- Benchmark-Suite
- Profiling-Werkzeuge

**Tooling:**
- Editor-Syntaxhervorhebung
- Language Server Protocol (LSP)
- Debugger-Integration
- Build-System-Verbesserungen

### Erst diskutieren

**Gr√∂√üere Features:**
- Neue Sprachkonstrukte
- Typsystem-√Ñnderungen
- Syntax-Erg√§nzungen
- Nebenl√§ufigkeits-Primitive

**Wie diskutieren:**
1. Er√∂ffnen Sie ein GitHub-Issue oder eine Diskussion
2. Beschreiben Sie das Feature und die Begr√ºndung
3. Zeigen Sie Beispielcode
4. Erkl√§ren Sie, wie es zu Hemlocks Philosophie passt
5. Warten Sie auf Feedback der Maintainer
6. Iterieren Sie am Design vor der Implementierung

---

## Was Sie NICHT beitragen sollten

### Unerw√ºnschte Beitr√§ge

**F√ºgen Sie keine Features hinzu, die:**
- Komplexit√§t vor dem Benutzer verstecken
- Verhalten implizit oder magisch machen
- Bestehende Semantik oder Syntax brechen
- Garbage Collection oder automatische Speicherverwaltung hinzuf√ºgen
- Das Prinzip "explizit vor implizit" verletzen

**Beispiele f√ºr abgelehnte Beitr√§ge:**

**1. Automatisches Einf√ºgen von Semikolons**
```hemlock
// SCHLECHT: Dies w√ºrde abgelehnt werden
let x = 5  // Kein Semikolon
let y = 10 // Kein Semikolon
```
Warum: Macht Syntax mehrdeutig, versteckt Fehler

**2. RAII/Destruktoren**
```hemlock
// SCHLECHT: Dies w√ºrde abgelehnt werden
let f = open("file.txt");
// Datei wird automatisch am Ende des Scopes geschlossen
```
Warum: Versteckt, wann Ressourcen freigegeben werden, nicht explizit

**3. Implizite Typkonvertierung mit Datenverlust**
```hemlock
// SCHLECHT: Dies w√ºrde abgelehnt werden
let x: i32 = 3.14;  // Schneidet stillschweigend auf 3 ab
```
Warum: Datenverlust sollte explizit sein, nicht stillschweigend

**4. Garbage Collection**
```c
// SCHLECHT: Dies w√ºrde abgelehnt werden
void *gc_malloc(size_t size) {
    // Allokation f√ºr automatische Bereinigung verfolgen
}
```
Warum: Versteckt Speicherverwaltung, unvorhersehbare Performance

**5. Komplexes Makrosystem**
```hemlock
// SCHLECHT: Dies w√ºrde abgelehnt werden
macro repeat($n, $block) {
    for (let i = 0; i < $n; i++) $block
}
```
Warum: Zu viel Magie, macht Code schwer nachvollziehbar

### H√§ufige Ablehnungsgr√ºnde

**"Das ist zu implizit"**
- L√∂sung: Machen Sie das Verhalten explizit und dokumentieren Sie es

**"Das versteckt Komplexit√§t"**
- L√∂sung: Legen Sie die Komplexit√§t offen, aber machen Sie sie ergonomisch

**"Das bricht bestehenden Code"**
- L√∂sung: Finden Sie eine nicht-brechende Alternative oder diskutieren Sie Versionierung

**"Das passt nicht zu Hemlocks Philosophie"**
- L√∂sung: Lesen Sie philosophy.md erneut und √ºberdenken Sie den Ansatz

---

## H√§ufige Muster

### Fehlerbehandlungsmuster

```c
// Verwenden Sie dieses Muster f√ºr behebbare Fehler im Hemlock-Code
Value *divide(Value *a, Value *b)
{
    // Vorbedingungen pr√ºfen
    if (b->type != TYPE_I32) {
        // Fehlerwert zur√ºckgeben oder Exception werfen
        return create_error("Integer-Divisor erwartet");
    }

    if (b->i32_value == 0) {
        return create_error("Division durch Null");
    }

    // Operation ausf√ºhren
    return value_create_i32(a->i32_value / b->i32_value);
}
```

### Speicherverwaltungsmuster

```c
// Muster: Allokieren, verwenden, freigeben
void process_data(void)
{
    // Allokieren
    Buffer *buf = create_buffer(1024);
    char *str = malloc(256);

    // Verwenden
    if (buf && str) {
        // ... Arbeit erledigen
    }

    // Freigeben (in umgekehrter Reihenfolge der Allokation)
    free(str);
    free_buffer(buf);
}
```

### Wert-Erstellungsmuster

```c
// Werte mit Konstruktoren erstellen
Value *create_integer(int32_t n)
{
    Value *val = malloc(sizeof(Value));
    if (!val) {
        fprintf(stderr, "Speicher ersch√∂pft\n");
        exit(1);
    }

    val->type = TYPE_I32;
    val->i32_value = n;
    return val;
}
```

### Typpr√ºfungsmuster

```c
// Typen vor Operationen pr√ºfen
Value *add_values(Value *a, Value *b)
{
    // Typpr√ºfung
    if (a->type != TYPE_I32 || b->type != TYPE_I32) {
        return create_error("Typkonflikt");
    }

    // Sicher fortzufahren
    return value_create_i32(a->i32_value + b->i32_value);
}
```

### String-Aufbaumuster

```c
// Strings effizient aufbauen
void build_error_message(char *buffer, size_t size, const char *detail)
{
    snprintf(buffer, size, "Fehler: %s (Zeile %d)", detail, line_number);
}
```

---

## Neue Funktionen hinzuf√ºgen

### Checkliste f√ºr Feature-Erg√§nzungen

Beim Hinzuf√ºgen eines neuen Features befolgen Sie diese Schritte:

#### 1. Design-Phase

- [ ] Lesen Sie philosophy.md, um die Ausrichtung sicherzustellen
- [ ] Erstellen Sie ein GitHub-Issue, das das Feature beschreibt
- [ ] Holen Sie Maintainer-Genehmigung f√ºr das Design ein
- [ ] Schreiben Sie eine Spezifikation (Syntax, Semantik, Beispiele)
- [ ] Ber√ºcksichtigen Sie Randf√§lle und Fehlerbedingungen

#### 2. Implementierungsphase

**Wenn Sie ein Sprachkonstrukt hinzuf√ºgen:**

- [ ] F√ºgen Sie Token-Typ zu `lexer.h` hinzu (falls n√∂tig)
- [ ] F√ºgen Sie Lexer-Regel in `lexer.c` hinzu (falls n√∂tig)
- [ ] F√ºgen Sie AST-Knotentyp in `ast.h` hinzu
- [ ] F√ºgen Sie AST-Konstruktor in `ast.c` hinzu
- [ ] F√ºgen Sie Parser-Regel in `parser.c` hinzu
- [ ] F√ºgen Sie Laufzeitverhalten in `runtime.c` oder dem entsprechenden Modul hinzu
- [ ] Behandeln Sie Aufr√§umen in AST-Free-Funktionen

**Wenn Sie eine eingebaute Funktion hinzuf√ºgen:**

- [ ] F√ºgen Sie Funktionsimplementierung in `builtins.c` hinzu
- [ ] Registrieren Sie die Funktion in `register_builtins()`
- [ ] Behandeln Sie alle Parameter-Typ-Kombinationen
- [ ] Geben Sie entsprechende Fehlerwerte zur√ºck
- [ ] Dokumentieren Sie Parameter und R√ºckgabetyp

**Wenn Sie einen Werttyp hinzuf√ºgen:**

- [ ] F√ºgen Sie Typ-Enum in `values.h` hinzu
- [ ] F√ºgen Sie Feld zur Value-Union hinzu
- [ ] F√ºgen Sie Konstruktor in `values.c` hinzu
- [ ] F√ºgen Sie zu `value_free()` f√ºr Aufr√§umen hinzu
- [ ] F√ºgen Sie zu `value_copy()` f√ºr Kopieren hinzu
- [ ] F√ºgen Sie zu `value_to_string()` f√ºr Ausgabe hinzu
- [ ] F√ºgen Sie Typ-Promotion-Regeln hinzu, falls numerisch

#### 3. Testphase

- [ ] Schreiben Sie Testf√§lle (siehe testing.md)
- [ ] Testen Sie Erfolgsf√§lle
- [ ] Testen Sie Fehlerf√§lle
- [ ] Testen Sie Randf√§lle
- [ ] F√ºhren Sie die vollst√§ndige Test-Suite aus (`make test`)
- [ ] Pr√ºfen Sie auf Speicherlecks mit Valgrind
- [ ] Testen Sie auf mehreren Plattformen (wenn m√∂glich)

#### 4. Dokumentationsphase

- [ ] Aktualisieren Sie CLAUDE.md mit benutzersichtbarer Dokumentation
- [ ] F√ºgen Sie Code-Kommentare hinzu, die die Implementierung erkl√§ren
- [ ] Erstellen Sie Beispiele in `examples/`
- [ ] Aktualisieren Sie relevante docs/-Dateien
- [ ] Dokumentieren Sie alle Breaking Changes

#### 5. Einreichungsphase

- [ ] Bereinigen Sie Debug-Code und Kommentare
- [ ] √úberpr√ºfen Sie die Einhaltung des Code-Stils
- [ ] Rebasen Sie auf den neuesten Main-Branch
- [ ] Erstellen Sie einen Pull Request mit detaillierter Beschreibung
- [ ] Reagieren Sie auf Code-Review-Feedback

### Beispiel: Einen neuen Operator hinzuf√ºgen

Lassen Sie uns das Hinzuf√ºgen des Modulo-Operators `%` als Beispiel durchgehen:

**1. Lexer (lexer.c):**
```c
// Zur Switch-Anweisung in get_next_token() hinzuf√ºgen
case '%':
    return create_token(TOKEN_PERCENT, "%", line);
```

**2. Lexer-Header (lexer.h):**
```c
typedef enum {
    // ... bestehende Token
    TOKEN_PERCENT,
    // ...
} TokenType;
```

**3. AST (ast.h):**
```c
typedef enum {
    // ... bestehende Operatoren
    OP_MOD,
    // ...
} BinaryOp;
```

**4. Parser (parser.c):**
```c
// Zu parse_multiplicative() oder entsprechender Pr√§zedenzebene hinzuf√ºgen
if (match(TOKEN_PERCENT)) {
    BinaryOp op = OP_MOD;
    ASTNode *right = parse_unary();
    left = create_binary_op_node(op, left, right);
}
```

**5. Laufzeit (runtime.c):**
```c
// Zu eval_binary_op() hinzuf√ºgen
case OP_MOD:
    // Typpr√ºfung
    if (left->type == TYPE_I32 && right->type == TYPE_I32) {
        if (right->i32_value == 0) {
            fprintf(stderr, "Fehler: Modulo durch Null\n");
            exit(1);
        }
        return value_create_i32(left->i32_value % right->i32_value);
    }
    // ... andere Typkombinationen behandeln
    break;
```

**6. Tests (tests/operators/modulo.hml):**
```hemlock
// Grundlegendes Modulo
print(10 % 3);  // Erwartet: 2

// Negatives Modulo
print(-10 % 3); // Erwartet: -1

// Fehlerfall (sollte fehlschlagen)
// print(10 % 0);  // Division durch Null
```

**7. Dokumentation (CLAUDE.md):**
```markdown
### Arithmetische Operatoren
- `+` - Addition
- `-` - Subtraktion
- `*` - Multiplikation
- `/` - Division
- `%` - Modulo (Rest)
```

---

## Code-Review-Prozess

### Worauf Reviewer achten

**1. Korrektheit**
- Macht der Code, was er behauptet?
- Werden Randf√§lle behandelt?
- Gibt es Speicherlecks?
- Werden Fehler richtig behandelt?

**2. Philosophie-Ausrichtung**
- Passt dies zu Hemlocks Designprinzipien?
- Ist es explizit oder implizit?
- Versteckt es Komplexit√§t?

**3. Code-Qualit√§t**
- Ist der Code lesbar und wartbar?
- Sind Variablennamen aussagekr√§ftig?
- Haben Funktionen eine angemessene Gr√∂√üe?
- Gibt es ausreichende Dokumentation?

**4. Tests**
- Gibt es ausreichende Testf√§lle?
- Decken Tests Erfolgs- und Fehlerpfade ab?
- Werden Randf√§lle getestet?

**5. Dokumentation**
- Ist die benutzersichtbare Dokumentation aktualisiert?
- Sind Code-Kommentare klar?
- Werden Beispiele bereitgestellt?

### Auf Feedback reagieren

**Tun Sie:**
- Danken Sie Reviewern f√ºr ihre Zeit
- Stellen Sie kl√§rende Fragen, wenn Sie etwas nicht verstehen
- Erkl√§ren Sie Ihre Begr√ºndung, wenn Sie anderer Meinung sind
- Nehmen Sie angeforderte √Ñnderungen zeitnah vor
- Aktualisieren Sie die PR-Beschreibung, wenn sich der Umfang √§ndert

**Tun Sie nicht:**
- Kritik pers√∂nlich nehmen
- Defensiv argumentieren
- Feedback ignorieren
- Force-Push √ºber Review-Kommentare (au√üer beim Rebasen)
- Nicht zusammenh√§ngende √Ñnderungen zum PR hinzuf√ºgen

### Ihren PR gemergt bekommen

**Anforderungen f√ºr Merge:**
- [ ] Alle Tests bestehen
- [ ] Keine Speicherlecks (Valgrind-sauber)
- [ ] Code-Review-Genehmigung vom Maintainer
- [ ] Dokumentation aktualisiert
- [ ] Befolgt Code-Stilrichtlinien
- [ ] Passt zu Hemlocks Philosophie

**Zeitrahmen:**
- Kleine PRs (Fehlerbehebungen): Normalerweise innerhalb weniger Tage gepr√ºft
- Mittlere PRs (neue Features): Kann 1-2 Wochen dauern
- Gro√üe PRs (gr√∂√üere √Ñnderungen): Erfordert ausf√ºhrliche Diskussion

---

## Zus√§tzliche Ressourcen

### Lernressourcen

**Interpreter verstehen:**
- "Crafting Interpreters" von Robert Nystrom
- "Writing An Interpreter In Go" von Thorsten Ball
- "Modern Compiler Implementation in C" von Andrew Appel

**C-Programmierung:**
- "The C Programming Language" von K&R
- "Expert C Programming" von Peter van der Linden
- "C Interfaces and Implementations" von David Hanson

**Speicherverwaltung:**
- Valgrind-Dokumentation
- "Understanding and Using C Pointers" von Richard Reese

### N√ºtzliche Befehle

```bash
# Mit Debug-Symbolen bauen
make clean && make CFLAGS="-g -O0"

# Mit Valgrind ausf√ºhren
valgrind --leak-check=full ./hemlock script.hml

# Bestimmte Testkategorie ausf√ºhren
./tests/run_tests.sh tests/strings/

# Tags-Datei f√ºr Code-Navigation generieren
ctags -R .

# Alle TODOs und FIXMEs finden
grep -rn "TODO\|FIXME" src/ include/
```

---

## Fragen?

Wenn Sie Fragen zum Beitragen haben:

1. Pr√ºfen Sie die Dokumentation in `docs/`
2. Suchen Sie in bestehenden GitHub-Issues
3. Fragen Sie in GitHub Discussions
4. Er√∂ffnen Sie ein neues Issue mit Ihrer Frage

**Vielen Dank f√ºr Ihren Beitrag zu Hemlock!**


--------------------------------------------------------------------------------
## Testen
--------------------------------------------------------------------------------

# Test-Leitfaden f√ºr Hemlock

Dieser Leitfaden erkl√§rt Hemlocks Test-Philosophie, wie man Tests schreibt und wie man die Test-Suite ausf√ºhrt.

---

## Inhaltsverzeichnis

- [Test-Philosophie](#test-philosophie)
- [Test-Suite-Struktur](#test-suite-struktur)
- [Tests ausf√ºhren](#tests-ausf√ºhren)
- [Tests schreiben](#tests-schreiben)
- [Testkategorien](#testkategorien)
- [Speicherleck-Tests](#speicherleck-tests)
- [Continuous Integration](#continuous-integration)
- [Best Practices](#best-practices)

---

## Test-Philosophie

### Kernprinzipien

**1. Testgetriebene Entwicklung (TDD)**

Schreiben Sie Tests **bevor** Sie Features implementieren:

```
1. Schreiben Sie einen fehlschlagenden Test
2. Implementieren Sie das Feature
3. F√ºhren Sie den Test aus (sollte bestehen)
4. Refaktorieren Sie bei Bedarf
5. Wiederholen
```

**Vorteile:**
- Stellt sicher, dass Features tats√§chlich funktionieren
- Verhindert Regressionen
- Dokumentiert erwartetes Verhalten
- Macht Refactoring sicherer

**2. Umfassende Abdeckung**

Testen Sie sowohl Erfolgs- als auch Fehlerf√§lle:

```hemlock
// Erfolgsfall
let x: u8 = 255;  // Sollte funktionieren

// Fehlerfall
let y: u8 = 256;  // Sollte einen Fehler werfen
```

**3. Fr√ºh und oft testen**

F√ºhren Sie Tests aus:
- Vor dem Committen von Code
- Nach dem Vornehmen von √Ñnderungen
- Vor dem Einreichen von Pull Requests
- W√§hrend des Code-Reviews

**Regel:** Alle Tests m√ºssen vor dem Mergen bestehen.

### Was zu testen ist

**Immer testen:**
- Grundfunktionalit√§t (Happy Path)
- Fehlerbedingungen (Sad Path)
- Randf√§lle (Grenzwertbedingungen)
- Typpr√ºfung und -konvertierungen
- Speicherverwaltung (keine Lecks)
- Nebenl√§ufigkeit und Race Conditions

**Beispiel f√ºr Testabdeckung:**
```hemlock
// Feature: String.substr(start, length)

// Happy Path
print("hello".substr(0, 5));  // "hello"

// Randf√§lle
print("hello".substr(0, 0));  // "" (leer)
print("hello".substr(5, 0));  // "" (am Ende)
print("hello".substr(2, 100)); // "llo" (√ºber Ende hinaus)

// Fehlerf√§lle
// "hello".substr(-1, 5);  // Fehler: negativer Index
// "hello".substr(0, -1);  // Fehler: negative L√§nge
```

---

## Test-Suite-Struktur

### Verzeichnisorganisation

```
tests/
‚îú‚îÄ‚îÄ run_tests.sh          # Haupt-Testrunner-Skript
‚îú‚îÄ‚îÄ primitives/           # Typsystem-Tests
‚îÇ   ‚îú‚îÄ‚îÄ integers.hml
‚îÇ   ‚îú‚îÄ‚îÄ floats.hml
‚îÇ   ‚îú‚îÄ‚îÄ booleans.hml
‚îÇ   ‚îú‚îÄ‚îÄ i64.hml
‚îÇ   ‚îî‚îÄ‚îÄ u64.hml
‚îú‚îÄ‚îÄ conversions/          # Typkonvertierungs-Tests
‚îÇ   ‚îú‚îÄ‚îÄ int_to_float.hml
‚îÇ   ‚îú‚îÄ‚îÄ promotion.hml
‚îÇ   ‚îî‚îÄ‚îÄ rune_conversions.hml
‚îú‚îÄ‚îÄ memory/               # Zeiger-/Buffer-Tests
‚îÇ   ‚îú‚îÄ‚îÄ alloc.hml
‚îÇ   ‚îú‚îÄ‚îÄ buffer.hml
‚îÇ   ‚îî‚îÄ‚îÄ memcpy.hml
‚îú‚îÄ‚îÄ strings/              # String-Operationstests
‚îÇ   ‚îú‚îÄ‚îÄ concat.hml
‚îÇ   ‚îú‚îÄ‚îÄ methods.hml
‚îÇ   ‚îú‚îÄ‚îÄ utf8.hml
‚îÇ   ‚îî‚îÄ‚îÄ runes.hml
‚îú‚îÄ‚îÄ control/              # Kontrollfluss-Tests
‚îÇ   ‚îú‚îÄ‚îÄ if.hml
‚îÇ   ‚îú‚îÄ‚îÄ switch.hml
‚îÇ   ‚îî‚îÄ‚îÄ while.hml
‚îú‚îÄ‚îÄ functions/            # Funktions- und Closure-Tests
‚îÇ   ‚îú‚îÄ‚îÄ basics.hml
‚îÇ   ‚îú‚îÄ‚îÄ closures.hml
‚îÇ   ‚îî‚îÄ‚îÄ recursion.hml
‚îú‚îÄ‚îÄ objects/              # Objekt-Tests
‚îÇ   ‚îú‚îÄ‚îÄ literals.hml
‚îÇ   ‚îú‚îÄ‚îÄ methods.hml
‚îÇ   ‚îú‚îÄ‚îÄ duck_typing.hml
‚îÇ   ‚îî‚îÄ‚îÄ serialization.hml
‚îú‚îÄ‚îÄ arrays/               # Array-Operationstests
‚îÇ   ‚îú‚îÄ‚îÄ basics.hml
‚îÇ   ‚îú‚îÄ‚îÄ methods.hml
‚îÇ   ‚îî‚îÄ‚îÄ slicing.hml
‚îú‚îÄ‚îÄ loops/                # Schleifen-Tests
‚îÇ   ‚îú‚îÄ‚îÄ for.hml
‚îÇ   ‚îú‚îÄ‚îÄ while.hml
‚îÇ   ‚îú‚îÄ‚îÄ break.hml
‚îÇ   ‚îî‚îÄ‚îÄ continue.hml
‚îú‚îÄ‚îÄ exceptions/           # Fehlerbehandlungs-Tests
‚îÇ   ‚îú‚îÄ‚îÄ try_catch.hml
‚îÇ   ‚îú‚îÄ‚îÄ finally.hml
‚îÇ   ‚îî‚îÄ‚îÄ throw.hml
‚îú‚îÄ‚îÄ io/                   # Datei-I/O-Tests
‚îÇ   ‚îú‚îÄ‚îÄ file_object.hml
‚îÇ   ‚îú‚îÄ‚îÄ read_write.hml
‚îÇ   ‚îî‚îÄ‚îÄ seek.hml
‚îú‚îÄ‚îÄ async/                # Nebenl√§ufigkeits-Tests
‚îÇ   ‚îú‚îÄ‚îÄ spawn_join.hml
‚îÇ   ‚îú‚îÄ‚îÄ channels.hml
‚îÇ   ‚îî‚îÄ‚îÄ exceptions.hml
‚îú‚îÄ‚îÄ ffi/                  # FFI-Tests
‚îÇ   ‚îú‚îÄ‚îÄ basic_call.hml
‚îÇ   ‚îú‚îÄ‚îÄ types.hml
‚îÇ   ‚îî‚îÄ‚îÄ dlopen.hml
‚îú‚îÄ‚îÄ signals/              # Signal-Behandlungs-Tests
‚îÇ   ‚îú‚îÄ‚îÄ basic.hml
‚îÇ   ‚îú‚îÄ‚îÄ handlers.hml
‚îÇ   ‚îî‚îÄ‚îÄ raise.hml
‚îî‚îÄ‚îÄ args/                 # Kommandozeilen-Argument-Tests
    ‚îî‚îÄ‚îÄ basic.hml
```

### Testdatei-Benennung

**Konventionen:**
- Verwenden Sie beschreibende Namen: `method_chaining.hml` nicht `test1.hml`
- Gruppieren Sie verwandte Tests: `string_substr.hml`, `string_slice.hml`
- Ein Feature-Bereich pro Datei
- Halten Sie Dateien fokussiert und klein

---

## Tests ausf√ºhren

### Alle Tests ausf√ºhren

```bash
# Vom Hemlock-Stammverzeichnis
make test

# Oder direkt
./tests/run_tests.sh
```

**Ausgabe:**
```
Running tests in tests/primitives/...
  ‚úì integers.hml
  ‚úì floats.hml
  ‚úì booleans.hml

Running tests in tests/strings/...
  ‚úì concat.hml
  ‚úì methods.hml

...

Total: 251 tests
Passed: 251
Failed: 0
```

### Bestimmte Kategorie ausf√ºhren

```bash
# Nur String-Tests ausf√ºhren
./tests/run_tests.sh tests/strings/

# Nur eine Testdatei ausf√ºhren
./tests/run_tests.sh tests/strings/concat.hml

# Mehrere Kategorien ausf√ºhren
./tests/run_tests.sh tests/strings/ tests/arrays/
```

### Mit Valgrind ausf√ºhren (Speicherleck-Pr√ºfung)

```bash
# Einzelnen Test auf Lecks pr√ºfen
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml

# Alle Tests pr√ºfen (langsam!)
for test in tests/**/*.hml; do
    echo "Testing $test"
    valgrind --leak-check=full --error-exitcode=1 ./hemlock "$test"
done
```

### Fehlgeschlagene Tests debuggen

```bash
# Mit ausf√ºhrlicher Ausgabe ausf√ºhren
./hemlock tests/failing_test.hml

# Mit gdb ausf√ºhren
gdb --args ./hemlock tests/failing_test.hml
(gdb) run
(gdb) backtrace  # bei Absturz
```

---

## Tests schreiben

### Testdatei-Format

Testdateien sind einfach Hemlock-Programme mit erwarteter Ausgabe:

**Beispiel: tests/primitives/integers.hml**
```hemlock
// Grundlegende Integer-Literale testen
let x = 42;
print(x);  // Erwartet: 42

let y: i32 = 100;
print(y);  // Erwartet: 100

// Arithmetik testen
let sum = x + y;
print(sum);  // Erwartet: 142

// Typinferenz testen
let small = 10;
print(typeof(small));  // Erwartet: i32

let large = 5000000000;
print(typeof(large));  // Erwartet: i64
```

**Wie Tests funktionieren:**
1. Der Testrunner f√ºhrt die .hml-Datei aus
2. Erfasst die stdout-Ausgabe
3. Vergleicht mit erwarteter Ausgabe (aus Kommentaren oder separater .out-Datei)
4. Meldet Bestanden/Fehlgeschlagen

### Methoden f√ºr erwartete Ausgabe

**Methode 1: Inline-Kommentare (empfohlen f√ºr einfache Tests)**

```hemlock
print("hello");  // Erwartet: hello
print(42);       // Erwartet: 42
```

Der Testrunner parst `// Erwartet: ...`-Kommentare.

**Methode 2: Separate .out-Datei**

Erstellen Sie `test_name.hml.out` mit erwarteter Ausgabe:

**test_name.hml:**
```hemlock
print("line 1");
print("line 2");
print("line 3");
```

**test_name.hml.out:**
```
line 1
line 2
line 3
```

### Fehlerf√§lle testen

Fehler-Tests sollten das Programm mit einem Nicht-Null-Status beenden:

**Beispiel: tests/primitives/range_error.hml**
```hemlock
// Dies sollte mit einem Typfehler fehlschlagen
let x: u8 = 256;  // Au√üerhalb des Bereichs f√ºr u8
```

**Erwartetes Verhalten:**
- Programm beendet sich mit Nicht-Null-Status
- Gibt Fehlermeldung auf stderr aus

**Testrunner-Behandlung:**
- Tests, die Fehler erwarten, sollten in separaten Dateien sein
- Verwenden Sie die Namenskonvention: `*_error.hml` oder `*_fail.hml`
- Dokumentieren Sie den erwarteten Fehler in Kommentaren

### Erfolgsf√§lle testen

**Beispiel: tests/strings/methods.hml**
```hemlock
// substr testen
let s = "hello world";
let sub = s.substr(6, 5);
print(sub);  // Erwartet: world

// find testen
let pos = s.find("world");
print(pos);  // Erwartet: 6

// contains testen
let has = s.contains("lo");
print(has);  // Erwartet: true

// trim testen
let padded = "  hello  ";
let trimmed = padded.trim();
print(trimmed);  // Erwartet: hello
```

### Randf√§lle testen

**Beispiel: tests/arrays/edge_cases.hml**
```hemlock
// Leeres Array
let empty = [];
print(empty.length);  // Erwartet: 0

// Einzelnes Element
let single = [42];
print(single[0]);  // Erwartet: 42

// Negativer Index (sollte in separater Testdatei fehlschlagen)
// print(single[-1]);  // Fehler

// Index √ºber Ende hinaus (sollte fehlschlagen)
// print(single[100]);  // Fehler

// Grenzwertbedingungen
let arr = [1, 2, 3];
print(arr.slice(0, 0));  // Erwartet: [] (leer)
print(arr.slice(3, 3));  // Erwartet: [] (leer)
print(arr.slice(1, 2));  // Erwartet: [2]
```

### Typsystem testen

**Beispiel: tests/conversions/promotion.hml**
```hemlock
// Typ-Promotion bei bin√§ren Operationen testen

// i32 + i64 -> i64
let a: i32 = 10;
let b: i64 = 20;
let c = a + b;
print(typeof(c));  // Erwartet: i64

// i32 + f32 -> f32
let d: i32 = 10;
let e: f32 = 3.14;
let f = d + e;
print(typeof(f));  // Erwartet: f32

// u8 + i32 -> i32
let g: u8 = 5;
let h: i32 = 10;
let i = g + h;
print(typeof(i));  // Erwartet: i32
```

### Nebenl√§ufigkeit testen

**Beispiel: tests/async/basic.hml**
```hemlock
async fn compute(n: i32): i32 {
    let sum = 0;
    let i = 0;
    while (i < n) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}

// Tasks spawnen
let t1 = spawn(compute, 10);
let t2 = spawn(compute, 20);

// Joinen und Ergebnisse ausgeben
let r1 = join(t1);
let r2 = join(t2);
print(r1);  // Erwartet: 45
print(r2);  // Erwartet: 190
```

### Exceptions testen

**Beispiel: tests/exceptions/try_catch.hml**
```hemlock
// Grundlegendes try/catch testen
try {
    throw "error message";
} catch (e) {
    print("Gefangen: " + e);  // Erwartet: Gefangen: error message
}

// finally testen
let executed = false;
try {
    print("try");  // Erwartet: try
} finally {
    executed = true;
    print("finally");  // Erwartet: finally
}

// Exception-Propagierung testen
fn risky(): i32 {
    throw "failure";
}

try {
    risky();
} catch (e) {
    print(e);  // Erwartet: failure
}
```

---

## Testkategorien

### Primitiven-Tests

**Was zu testen ist:**
- Integer-Typen (i8, i16, i32, i64, u8, u16, u32, u64)
- Float-Typen (f32, f64)
- Boolean-Typ
- String-Typ
- Rune-Typ
- Null-Typ

**Beispielbereiche:**
- Literal-Syntax
- Typinferenz
- Bereichspr√ºfung
- √úberlaufverhalten
- Typannotationen

### Konvertierungstests

**Was zu testen ist:**
- Implizite Typ-Promotion
- Explizite Typkonvertierung
- Verlustbehaftete Konvertierungen (sollten fehlschlagen)
- Typ-Promotion bei Operationen
- Typ-√ºbergreifende Vergleiche

### Speichertests

**Was zu testen ist:**
- alloc/free-Korrektheit
- Buffer-Erstellung und -Zugriff
- Grenzpr√ºfung bei Buffern
- memset, memcpy, realloc
- Speicherleck-Erkennung (Valgrind)

### String-Tests

**Was zu testen ist:**
- Konkatenation
- Alle 18 String-Methoden
- UTF-8-Behandlung
- Rune-Indizierung
- String + Rune-Konkatenation
- Randf√§lle (leere Strings, einzelnes Zeichen, etc.)

### Kontrollfluss-Tests

**Was zu testen ist:**
- if/else/else if
- while-Schleifen
- for-Schleifen
- switch-Anweisungen
- break/continue
- return-Anweisungen

### Funktions-Tests

**Was zu testen ist:**
- Funktionsdefinition und -aufruf
- Parameter√ºbergabe
- R√ºckgabewerte
- Rekursion
- Closures und Capture
- First-Class-Funktionen
- Anonyme Funktionen

### Objekt-Tests

**Was zu testen ist:**
- Objekt-Literale
- Feldzugriff und -zuweisung
- Methoden und self-Bindung
- Duck Typing
- Optionale Felder
- JSON-Serialisierung/Deserialisierung
- Erkennung zirkul√§rer Referenzen

### Array-Tests

**Was zu testen ist:**
- Array-Erstellung
- Indizierung und Zuweisung
- Alle 15 Array-Methoden
- Gemischte Typen
- Dynamische Gr√∂√üenanpassung
- Randf√§lle (leer, einzelnes Element)

### Exception-Tests

**Was zu testen ist:**
- try/catch/finally
- throw-Anweisung
- Exception-Propagierung
- Verschachtelte try/catch
- Return in try/catch/finally
- Nicht gefangene Exceptions

### I/O-Tests

**Was zu testen ist:**
- Datei-√ñffnungsmodi
- Lese-/Schreiboperationen
- Seek/Tell
- Dateieigenschaften
- Fehlerbehandlung (fehlende Dateien, etc.)
- Ressourcen-Aufr√§umen

### Async-Tests

**Was zu testen ist:**
- spawn/join/detach
- Channel send/recv
- Exception-Propagierung in Tasks
- Mehrere gleichzeitige Tasks
- Channel-Blockierungsverhalten

### FFI-Tests

**Was zu testen ist:**
- dlopen/dlclose
- dlsym
- dlcall mit verschiedenen Typen
- Typkonvertierung
- Fehlerbehandlung

---

## Speicherleck-Tests

### Valgrind verwenden

**Grundlegende Verwendung:**
```bash
valgrind --leak-check=full ./hemlock test.hml
```

**Beispielausgabe (keine Lecks):**
```
==12345== HEAP SUMMARY:
==12345==     in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 10 allocs, 10 frees, 1,024 bytes allocated
==12345==
==12345== All heap blocks were freed -- no leaks are possible
```

**Beispielausgabe (mit Leck):**
```
==12345== LEAK SUMMARY:
==12345==    definitely lost: 64 bytes in 1 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==      possibly lost: 0 bytes in 0 blocks
==12345==    still reachable: 0 bytes in 0 blocks
==12345==         suppressed: 0 bytes in 0 blocks
```

### H√§ufige Leck-Quellen

**1. Fehlende free()-Aufrufe:**
```c
// SCHLECHT
char *str = malloc(100);
// ... str verwenden
// Vergessen freizugeben!

// GUT
char *str = malloc(100);
// ... str verwenden
free(str);
```

**2. Verlorene Zeiger:**
```c
// SCHLECHT
char *ptr = malloc(100);
ptr = malloc(200);  // Referenz zur ersten Allokation verloren!

// GUT
char *ptr = malloc(100);
free(ptr);
ptr = malloc(200);
```

**3. Exception-Pfade:**
```c
// SCHLECHT
void func() {
    char *data = malloc(100);
    if (error_condition) {
        return;  // Leck!
    }
    free(data);
}

// GUT
void func() {
    char *data = malloc(100);
    if (error_condition) {
        free(data);
        return;
    }
    free(data);
}
```

### Bekannte akzeptable Lecks

Einige kleine "Lecks" sind beabsichtigte Start-Allokationen:

**Globale Built-ins:**
```hemlock
// Eingebaute Funktionen, FFI-Typen und Konstanten werden beim Start allokiert
// und beim Beenden nicht freigegeben (typischerweise ~200 Bytes)
```

Dies sind keine echten Lecks - es sind einmalige Allokationen, die f√ºr die Programmlebensdauer bestehen bleiben und beim Beenden vom Betriebssystem bereinigt werden.

---

## Continuous Integration

### GitHub Actions (Zukunft)

Sobald CI eingerichtet ist, werden alle Tests automatisch ausgef√ºhrt bei:
- Push zum Main-Branch
- Pull-Request-Erstellung/-Aktualisierung
- Geplante t√§gliche L√§ufe

**CI-Workflow:**
1. Hemlock bauen
2. Test-Suite ausf√ºhren
3. Auf Speicherlecks pr√ºfen (Valgrind)
4. Ergebnisse im PR melden

### Pre-Commit-Pr√ºfungen

Vor dem Committen ausf√ºhren:

```bash
# Frisch bauen
make clean && make

# Alle Tests ausf√ºhren
make test

# Einige Tests auf Lecks pr√ºfen
valgrind --leak-check=full ./hemlock tests/memory/alloc.hml
valgrind --leak-check=full ./hemlock tests/strings/concat.hml
```

---

## Best Practices

### Dos

**Tests zuerst schreiben (TDD)**
```bash
1. tests/feature/new_feature.hml erstellen
2. Feature in src/ implementieren
3. Tests ausf√ºhren, bis sie bestehen
```

**Sowohl Erfolg als auch Fehler testen**
```hemlock
// Erfolg: tests/feature/success.hml
let result = do_thing();
print(result);  // Erwartet: erwarteter Wert

// Fehler: tests/feature/failure.hml
do_invalid_thing();  // Sollte fehlschlagen
```

**Beschreibende Testnamen verwenden**
```
Gut: tests/strings/substr_utf8_boundary.hml
Schlecht:  tests/test1.hml
```

**Tests fokussiert halten**
- Ein Feature-Bereich pro Datei
- Klares Setup und Assertions
- Minimaler Code

**Kommentare hinzuf√ºgen, die knifflige Tests erkl√§ren**
```hemlock
// Testen, dass Closure √§u√üere Variable per Referenz erfasst
fn outer() {
    let x = 10;
    let f = fn() { return x; };
    x = 20;  // Nach Closure-Erstellung modifizieren
    return f();  // Sollte 20 zur√ºckgeben, nicht 10
}
```

**Randf√§lle testen**
- Leere Eingaben
- Null-Werte
- Grenzwerte (min/max)
- Gro√üe Eingaben
- Negative Werte

### Don'ts

**Tests nicht √ºberspringen**
- Alle Tests m√ºssen vor dem Mergen bestehen
- Kommentieren Sie fehlschlagende Tests nicht aus
- Beheben Sie den Fehler oder entfernen Sie das Feature

**Keine Tests schreiben, die voneinander abh√§ngen**
```hemlock
// SCHLECHT: test2.hml h√§ngt von test1.hml-Ausgabe ab
// Tests sollten unabh√§ngig sein
```

**Keine Zufallswerte in Tests verwenden**
```hemlock
// SCHLECHT: Nicht-deterministisch
let x = random();
print(x);  // Ausgabe nicht vorhersagbar

// GUT: Deterministisch
let x = 42;
print(x);  // Erwartet: 42
```

**Keine Implementierungsdetails testen**
```hemlock
// SCHLECHT: Interne Struktur testen
let obj = { x: 10 };
// Nicht interne Feldreihenfolge, Kapazit√§t etc. pr√ºfen

// GUT: Verhalten testen
print(obj.x);  // Erwartet: 10
```

**Speicherlecks nicht ignorieren**
- Alle Tests sollten Valgrind-sauber sein
- Bekannte/akzeptable Lecks dokumentieren
- Lecks vor dem Mergen beheben

### Test-Wartung

**Wann Tests aktualisieren:**
- Feature-Verhalten √§ndert sich
- Fehlerbehebungen erfordern neue Testf√§lle
- Randf√§lle entdeckt
- Performance-Verbesserungen

**Wann Tests entfernen:**
- Feature aus der Sprache entfernt
- Test dupliziert bestehende Abdeckung
- Test war falsch

**Tests refaktorieren:**
- Verwandte Tests zusammen gruppieren
- Gemeinsamen Setup-Code extrahieren
- Einheitliche Benennung verwenden
- Tests einfach und lesbar halten

---

## Beispiel-Testsitzung

Hier ist ein vollst√§ndiges Beispiel f√ºr das Hinzuf√ºgen eines Features mit Tests:

### Feature: `array.first()`-Methode hinzuf√ºgen

**1. Zuerst den Test schreiben:**

```bash
# Testdatei erstellen
cat > tests/arrays/first_method.hml << 'EOF'
// array.first()-Methode testen

// Grundfall
let arr = [1, 2, 3];
print(arr.first());  // Erwartet: 1

// Einzelnes Element
let single = [42];
print(single.first());  // Erwartet: 42

// Leeres Array (sollte fehlschlagen - separate Testdatei)
// let empty = [];
// print(empty.first());  // Fehler
EOF
```

**2. Den Test ausf√ºhren (sollte fehlschlagen):**

```bash
./hemlock tests/arrays/first_method.hml
# Fehler: Methode 'first' nicht auf Array gefunden
```

**3. Das Feature implementieren:**

`src/interpreter/builtins.c` bearbeiten:

```c
// array_first-Methode hinzuf√ºgen
Value *array_first(Value *self, Value **args, int arg_count)
{
    if (self->array_value->length == 0) {
        fprintf(stderr, "Fehler: Kann erstes Element eines leeren Arrays nicht holen\n");
        exit(1);
    }

    return value_copy(&self->array_value->elements[0]);
}

// In Array-Methoden-Tabelle registrieren
// ... zur Array-Methodenregistrierung hinzuf√ºgen
```

**4. Den Test ausf√ºhren (sollte bestehen):**

```bash
./hemlock tests/arrays/first_method.hml
1
42
# Erfolg!
```

**5. Auf Speicherlecks pr√ºfen:**

```bash
valgrind --leak-check=full ./hemlock tests/arrays/first_method.hml
# All heap blocks were freed -- no leaks are possible
```

**6. Vollst√§ndige Test-Suite ausf√ºhren:**

```bash
make test
# Total: 252 tests (251 + neuer)
# Passed: 252
# Failed: 0
```

**7. Committen:**

```bash
git add tests/arrays/first_method.hml src/interpreter/builtins.c
git commit -m "Add array.first() method with tests"
```

---

## Zusammenfassung

**Denken Sie daran:**
- Tests zuerst schreiben (TDD)
- Erfolgs- und Fehlerf√§lle testen
- Alle Tests vor dem Committen ausf√ºhren
- Auf Speicherlecks pr√ºfen
- Bekannte Probleme dokumentieren
- Tests einfach und fokussiert halten

**Testqualit√§t ist genauso wichtig wie Code-Qualit√§t!**



################################################################################
# HPM: ERSTE SCHRITTE
################################################################################

--------------------------------------------------------------------------------
## Installation
--------------------------------------------------------------------------------

# Installation

Diese Anleitung beschreibt, wie Sie hpm auf Ihrem System installieren.

## Schnellinstallation (Empfohlen)

Installieren Sie die neueste Version mit einem einzigen Befehl:

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh
```

Dies geschieht automatisch:
- Erkennung Ihres Betriebssystems (Linux, macOS)
- Erkennung Ihrer Architektur (x86_64, arm64)
- Herunterladen der passenden vorkompilierten Bin√§rdatei
- Installation nach `/usr/local/bin` (oder mit sudo falls erforderlich)

### Installationsoptionen

```bash
# An einem benutzerdefinierten Ort installieren (kein sudo erforderlich)
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local

# Eine bestimmte Version installieren
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --version 1.0.5

# Optionen kombinieren
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh -s -- --prefix ~/.local --version 1.0.5
```

### Unterst√ºtzte Plattformen

| Plattform | Architektur | Status |
|-----------|-------------|--------|
| Linux     | x86_64      | ‚úì Unterst√ºtzt |
| macOS     | x86_64      | ‚úì Unterst√ºtzt |
| macOS     | arm64 (M1/M2/M3) | ‚úì Unterst√ºtzt |
| Linux     | arm64       | Aus Quellcode bauen |

## Aus Quellcode bauen

Wenn Sie lieber aus dem Quellcode bauen m√∂chten oder eine Plattform ben√∂tigen, die nicht durch vorkompilierte Bin√§rdateien abgedeckt ist, folgen Sie diesen Anweisungen.

### Voraussetzungen

hpm erfordert, dass [Hemlock](https://github.com/hemlang/hemlock) zuerst installiert wird. Folgen Sie den Hemlock-Installationsanweisungen, bevor Sie fortfahren.

√úberpr√ºfen Sie, ob Hemlock installiert ist:

```bash
hemlock --version
```

## Installationsmethoden

### Methode 1: Make Install

Aus dem Quellcode bauen und installieren.

```bash
# Repository klonen
git clone https://github.com/hemlang/hpm.git
cd hpm

# Nach /usr/local/bin installieren (erfordert sudo)
sudo make install
```

Nach der Installation √ºberpr√ºfen Sie, ob es funktioniert:

```bash
hpm --version
```

### Methode 2: Benutzerdefinierter Speicherort

An einem benutzerdefinierten Verzeichnis installieren (kein sudo erforderlich):

```bash
# Repository klonen
git clone https://github.com/hemlang/hpm.git
cd hpm

# Nach ~/.local/bin installieren
make install PREFIX=$HOME/.local

# Oder an einem beliebigen benutzerdefinierten Ort
make install PREFIX=/opt/hemlock
```

Stellen Sie sicher, dass Ihr benutzerdefiniertes bin-Verzeichnis in Ihrem PATH ist:

```bash
# Zu ~/.bashrc oder ~/.zshrc hinzuf√ºgen
export PATH="$HOME/.local/bin:$PATH"
```

### Methode 3: Ohne Installation ausf√ºhren

Sie k√∂nnen hpm direkt ohne Installation ausf√ºhren:

```bash
# Repository klonen
git clone https://github.com/hemlang/hpm.git
cd hpm

# Lokales Wrapper-Skript erstellen
make

# Aus dem hpm-Verzeichnis ausf√ºhren
./hpm --help

# Oder direkt √ºber hemlock ausf√ºhren
hemlock src/main.hml --help
```

### Methode 4: Manuelle Installation

Erstellen Sie Ihr eigenes Wrapper-Skript:

```bash
# An einen permanenten Ort klonen
git clone https://github.com/hemlang/hpm.git ~/.hpm-source

# Wrapper-Skript erstellen
cat > ~/.local/bin/hpm << 'EOF'
#!/bin/sh
exec hemlock "$HOME/.hpm-source/src/main.hml" "$@"
EOF

chmod +x ~/.local/bin/hpm
```

## Installationsvariablen

Das Makefile unterst√ºtzt diese Variablen:

| Variable | Standard | Beschreibung |
|----------|----------|--------------|
| `PREFIX` | `/usr/local` | Installationspr√§fix |
| `BINDIR` | `$(PREFIX)/bin` | Bin√§rverzeichnis |
| `HEMLOCK` | `hemlock` | Pfad zum Hemlock-Interpreter |

Beispiel mit benutzerdefinierten Variablen:

```bash
make install PREFIX=/opt/hemlock BINDIR=/opt/hemlock/bin HEMLOCK=/usr/bin/hemlock
```

## Funktionsweise

Der Installer erstellt ein Shell-Wrapper-Skript, das den Hemlock-Interpreter mit dem hpm-Quellcode aufruft:

```bash
#!/bin/sh
exec hemlock "/path/to/hpm/src/main.hml" "$@"
```

Dieser Ansatz:
- Erfordert keine Kompilierung
- F√ºhrt immer den neuesten Quellcode aus
- Funktioniert zuverl√§ssig auf allen Plattformen

## hpm aktualisieren

Um hpm auf die neueste Version zu aktualisieren:

```bash
cd /path/to/hpm
git pull origin main

# Bei Pfad√§nderung neu installieren
sudo make install
```

## Deinstallation

hpm von Ihrem System entfernen:

```bash
cd /path/to/hpm
sudo make uninstall
```

Oder manuell entfernen:

```bash
sudo rm /usr/local/bin/hpm
```

## Installation √ºberpr√ºfen

Nach der Installation √ºberpr√ºfen Sie, ob alles funktioniert:

```bash
# Version pr√ºfen
hpm --version

# Hilfe anzeigen
hpm --help

# Initialisierung testen (in einem leeren Verzeichnis)
mkdir test-project && cd test-project
hpm init --yes
cat package.json
```

## Fehlerbehebung

### "hemlock: command not found"

Hemlock ist nicht installiert oder nicht in Ihrem PATH. Installieren Sie zuerst Hemlock:

```bash
# Pr√ºfen, ob hemlock existiert
which hemlock

# Falls nicht gefunden, Hemlock von https://github.com/hemlang/hemlock installieren
```

### "Permission denied"

Verwenden Sie sudo f√ºr die systemweite Installation oder installieren Sie in einem Benutzerverzeichnis:

```bash
# Option 1: sudo verwenden
sudo make install

# Option 2: In Benutzerverzeichnis installieren
make install PREFIX=$HOME/.local
```

### "hpm: command not found" nach der Installation

Ihr PATH enth√§lt m√∂glicherweise nicht das Installationsverzeichnis:

```bash
# Pr√ºfen, wo hpm installiert wurde
ls -la /usr/local/bin/hpm

# Zum PATH hinzuf√ºgen, wenn benutzerdefinierter Speicherort verwendet wird
export PATH="$HOME/.local/bin:$PATH"
```

## Plattformspezifische Hinweise

### Linux

Die Standardinstallation funktioniert auf allen Linux-Distributionen. Einige Distributionen erfordern m√∂glicherweise:

```bash
# Debian/Ubuntu: Build-Essentials sicherstellen
sudo apt-get install build-essential git

# Fedora/RHEL
sudo dnf install make git
```

### macOS

Die Standardinstallation funktioniert. Bei Verwendung von Homebrew:

```bash
# Xcode-Kommandozeilentools sicherstellen
xcode-select --install
```

### Windows (WSL)

hpm funktioniert im Windows Subsystem for Linux:

```bash
# Im WSL-Terminal
git clone https://github.com/hemlang/hpm.git
cd hpm
make install PREFIX=$HOME/.local
```

## N√§chste Schritte

Nach der Installation:

1. [Schnellstart](#hpm-installation-quick-start) - Erstellen Sie Ihr erstes Projekt
2. [Befehlsreferenz](#hpm-installation-commands) - Lernen Sie alle Befehle
3. [Konfiguration](#hpm-installation-configuration) - hpm konfigurieren


--------------------------------------------------------------------------------
## Projekteinrichtung
--------------------------------------------------------------------------------

# Projekteinrichtung

Vollst√§ndige Anleitung zur Einrichtung von Hemlock-Projekten mit hpm.

## Ein neues Projekt starten

### Grundlegende Einrichtung

Ein neues Projekt von Grund auf erstellen:

```bash
# Projektverzeichnis erstellen
mkdir my-project
cd my-project

# package.json initialisieren
hpm init

# Verzeichnisstruktur erstellen
mkdir -p src test
```

### Projektvorlagen

Hier sind g√§ngige Projektstrukturen f√ºr verschiedene Anwendungsf√§lle:

#### Bibliothekspaket

F√ºr wiederverwendbare Bibliotheken:

```
my-library/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ index.hml          # Haupteinstiegspunkt, exportiert √∂ffentliche API
‚îÇ   ‚îú‚îÄ‚îÄ core.hml           # Kernfunktionalit√§t
‚îÇ   ‚îú‚îÄ‚îÄ utils.hml          # Hilfsfunktionen
‚îÇ   ‚îî‚îÄ‚îÄ types.hml          # Typdefinitionen
‚îî‚îÄ‚îÄ test/
    ‚îú‚îÄ‚îÄ framework.hml      # Test-Framework
    ‚îú‚îÄ‚îÄ run.hml            # Test-Runner
    ‚îî‚îÄ‚îÄ test_core.hml      # Tests
```

**package.json:**

```json
{
  "name": "yourusername/my-library",
  "version": "1.0.0",
  "description": "Eine wiederverwendbare Hemlock-Bibliothek",
  "main": "src/index.hml",
  "scripts": {
    "test": "hemlock test/run.hml"
  },
  "dependencies": {},
  "devDependencies": {}
}
```

#### Anwendung

F√ºr eigenst√§ndige Anwendungen:

```
my-app/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.hml           # Anwendungseinstiegspunkt
‚îÇ   ‚îú‚îÄ‚îÄ config.hml         # Konfiguration
‚îÇ   ‚îú‚îÄ‚îÄ commands/          # CLI-Befehle
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.hml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ run.hml
‚îÇ   ‚îî‚îÄ‚îÄ lib/               # Interne Bibliotheken
‚îÇ       ‚îî‚îÄ‚îÄ utils.hml
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îî‚îÄ‚îÄ run.hml
‚îî‚îÄ‚îÄ data/                  # Datendateien
```

**package.json:**

```json
{
  "name": "yourusername/my-app",
  "version": "1.0.0",
  "description": "Eine Hemlock-Anwendung",
  "main": "src/main.hml",
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc"
  },
  "dependencies": {
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {}
}
```

#### Webanwendung

F√ºr Webserver:

```
my-web-app/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.hml           # Server-Einstiegspunkt
‚îÇ   ‚îú‚îÄ‚îÄ routes/            # Route-Handler
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.hml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.hml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.hml
‚îÇ   ‚îú‚îÄ‚îÄ middleware/        # Middleware
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.hml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.hml
‚îÇ   ‚îú‚îÄ‚îÄ models/            # Datenmodelle
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.hml
‚îÇ   ‚îî‚îÄ‚îÄ services/          # Gesch√§ftslogik
‚îÇ       ‚îî‚îÄ‚îÄ user.hml
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îî‚îÄ‚îÄ run.hml
‚îú‚îÄ‚îÄ static/                # Statische Dateien
‚îÇ   ‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îî‚îÄ‚îÄ js/
‚îî‚îÄ‚îÄ views/                 # Templates
    ‚îî‚îÄ‚îÄ index.hml
```

**package.json:**

```json
{
  "name": "yourusername/my-web-app",
  "version": "1.0.0",
  "description": "Eine Hemlock-Webanwendung",
  "main": "src/main.hml",
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml"
  },
  "dependencies": {
    "hemlang/sprout": "^2.0.0",
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  }
}
```

## Die package.json-Datei

### Erforderliche Felder

```json
{
  "name": "owner/repo",
  "version": "1.0.0"
}
```

### Alle Felder

```json
{
  "name": "yourusername/my-package",
  "version": "1.0.0",
  "description": "Paketbeschreibung",
  "author": "Ihr Name <sie@beispiel.com>",
  "license": "MIT",
  "repository": "https://github.com/yourusername/my-package",
  "homepage": "https://yourusername.github.io/my-package",
  "bugs": "https://github.com/yourusername/my-package/issues",
  "main": "src/index.hml",
  "keywords": ["utility", "parser"],
  "dependencies": {
    "owner/package": "^1.0.0"
  },
  "devDependencies": {
    "owner/test-lib": "^1.0.0"
  },
  "scripts": {
    "start": "hemlock src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc"
  },
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ],
  "native": {
    "requires": ["libcurl", "openssl"]
  }
}
```

### Feldreferenz

| Feld | Typ | Beschreibung |
|------|-----|--------------|
| `name` | string | Paketname im owner/repo-Format (erforderlich) |
| `version` | string | Semantische Version (erforderlich) |
| `description` | string | Kurze Beschreibung |
| `author` | string | Autorname und E-Mail |
| `license` | string | Lizenz-Identifikator (MIT, Apache-2.0, etc.) |
| `repository` | string | Repository-URL |
| `homepage` | string | Projekt-Homepage |
| `bugs` | string | Issue-Tracker-URL |
| `main` | string | Einstiegspunktdatei (Standard: src/index.hml) |
| `keywords` | array | Such-Schl√ºsselw√∂rter |
| `dependencies` | object | Laufzeitabh√§ngigkeiten |
| `devDependencies` | object | Entwicklungsabh√§ngigkeiten |
| `scripts` | object | Benannte Skripte |
| `files` | array | Dateien, die beim Ver√∂ffentlichen enthalten sein sollen |
| `native` | object | Native Bibliotheksanforderungen |

## Die package-lock.json-Datei

Die Lock-Datei wird automatisch generiert und sollte zur Versionskontrolle committet werden. Sie gew√§hrleistet reproduzierbare Installationen.

```json
{
  "lockVersion": 1,
  "hemlock": "1.0.0",
  "dependencies": {
    "hemlang/sprout": {
      "version": "2.1.0",
      "resolved": "https://github.com/hemlang/sprout/archive/v2.1.0.tar.gz",
      "integrity": "sha256-abc123...",
      "dependencies": {
        "hemlang/router": "^1.5.0"
      }
    },
    "hemlang/router": {
      "version": "1.5.0",
      "resolved": "https://github.com/hemlang/router/archive/v1.5.0.tar.gz",
      "integrity": "sha256-def456...",
      "dependencies": {}
    }
  }
}
```

### Best Practices f√ºr Lock-Dateien

- **Committen** Sie package-lock.json zur Versionskontrolle
- **Nicht manuell bearbeiten** - sie wird automatisch generiert
- **`hpm install` ausf√ºhren** nach dem Pullen von √Ñnderungen
- **L√∂schen und neu generieren** falls besch√§digt:
  ```bash
  rm package-lock.json
  hpm install
  ```

## Das hem_modules-Verzeichnis

Installierte Pakete werden in `hem_modules/` gespeichert:

```
hem_modules/
‚îú‚îÄ‚îÄ hemlang/
‚îÇ   ‚îú‚îÄ‚îÄ sprout/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ router/
‚îÇ       ‚îú‚îÄ‚îÄ package.json
‚îÇ       ‚îî‚îÄ‚îÄ src/
‚îî‚îÄ‚îÄ alice/
    ‚îî‚îÄ‚îÄ http-client/
        ‚îú‚îÄ‚îÄ package.json
        ‚îî‚îÄ‚îÄ src/
```

### Best Practices f√ºr hem_modules

- **Zu .gitignore hinzuf√ºgen** - Abh√§ngigkeiten nicht committen
- **Nicht modifizieren** - √Ñnderungen werden √ºberschrieben
- **L√∂schen zum Neu-Installieren**:
  ```bash
  rm -rf hem_modules
  hpm install
  ```

## .gitignore

Empfohlene .gitignore f√ºr Hemlock-Projekte:

```gitignore
# Abh√§ngigkeiten
hem_modules/

# Build-Ausgabe
dist/
*.hmlc

# IDE-Dateien
.idea/
.vscode/
*.swp
*.swo

# OS-Dateien
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Umgebung
.env
.env.local

# Testabdeckung
coverage/
```

## Mit Abh√§ngigkeiten arbeiten

### Abh√§ngigkeiten hinzuf√ºgen

```bash
# Laufzeitabh√§ngigkeit hinzuf√ºgen
hpm install hemlang/json

# Mit Versionseinschr√§nkung hinzuf√ºgen
hpm install hemlang/sprout@^2.0.0

# Entwicklungsabh√§ngigkeit hinzuf√ºgen
hpm install hemlang/test-utils --dev
```

### Abh√§ngigkeiten importieren

```hemlock
// Aus Paket importieren (verwendet "main"-Eintrag)
import { parse, stringify } from "hemlang/json";

// Aus Unterpfad importieren
import { Router } from "hemlang/sprout/router";

// Standardbibliothek importieren
import { HashMap } from "@stdlib/collections";
import { readFile, writeFile } from "@stdlib/fs";
```

### Import-Aufl√∂sung

hpm l√∂st Importe in dieser Reihenfolge auf:

1. **Standardbibliothek**: `@stdlib/*` importiert eingebaute Module
2. **Paket-Root**: `owner/repo` verwendet das `main`-Feld
3. **Unterpfad**: `owner/repo/path` pr√ºft:
   - `hem_modules/owner/repo/path.hml`
   - `hem_modules/owner/repo/path/index.hml`
   - `hem_modules/owner/repo/src/path.hml`
   - `hem_modules/owner/repo/src/path/index.hml`

## Skripte

### Skripte definieren

Skripte zur package.json hinzuf√ºgen:

```json
{
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "test:unit": "hemlock test/unit/run.hml",
    "test:integration": "hemlock test/integration/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc",
    "clean": "rm -rf dist hem_modules",
    "lint": "hemlock-lint src/",
    "format": "hemlock-fmt src/"
  }
}
```

### Skripte ausf√ºhren

```bash
hpm run start
hpm run dev
hpm run build

# Kurzform f√ºr test
hpm test

# Argumente √ºbergeben
hpm run test -- --verbose --filter=unit
```

### Skript-Namenskonventionen

| Skript | Zweck |
|--------|-------|
| `start` | Anwendung ausf√ºhren |
| `dev` | Im Entwicklungsmodus ausf√ºhren |
| `test` | Alle Tests ausf√ºhren |
| `build` | F√ºr Produktion bauen |
| `clean` | Generierte Dateien entfernen |
| `lint` | Code-Stil pr√ºfen |
| `format` | Code formatieren |

## Entwicklungsworkflow

### Ersteinrichtung

```bash
# Projekt klonen
git clone https://github.com/yourusername/my-project.git
cd my-project

# Abh√§ngigkeiten installieren
hpm install

# Tests ausf√ºhren
hpm test

# Entwicklung starten
hpm run dev
```

### T√§glicher Workflow

```bash
# Neueste √Ñnderungen pullen
git pull

# Neue Abh√§ngigkeiten installieren
hpm install

# √Ñnderungen vornehmen...

# Tests ausf√ºhren
hpm test

# Committen
git add .
git commit -m "Feature hinzugef√ºgt"
git push
```

### Neues Feature hinzuf√ºgen

```bash
# Feature-Branch erstellen
git checkout -b feature/new-feature

# Bei Bedarf neue Abh√§ngigkeit hinzuf√ºgen
hpm install hemlang/new-lib

# Feature implementieren...

# Testen
hpm test

# Committen und pushen
git add .
git commit -m "Neues Feature hinzugef√ºgt"
git push -u origin feature/new-feature
```

## Umgebungsspezifische Konfiguration

### Umgebungsvariablen verwenden

```hemlock
import { getenv } from "@stdlib/env";

let db_host = getenv("DATABASE_HOST") ?? "localhost";
let api_key = getenv("API_KEY") ?? "";

if api_key == "" {
    print("Warnung: API_KEY nicht gesetzt");
}
```

### Konfigurationsdatei

**config.hml:**

```hemlock
import { getenv } from "@stdlib/env";

export let config = {
    environment: getenv("HEMLOCK_ENV") ?? "development",
    database: {
        host: getenv("DB_HOST") ?? "localhost",
        port: int(getenv("DB_PORT") ?? "5432"),
        name: getenv("DB_NAME") ?? "myapp"
    },
    server: {
        port: int(getenv("PORT") ?? "3000"),
        host: getenv("HOST") ?? "0.0.0.0"
    }
};

export fn is_production(): bool {
    return config.environment == "production";
}
```

## Siehe auch

- [Schnellstart](#hpm-project-setup-quick-start) - Schnell loslegen
- [Befehle](#hpm-project-setup-commands) - Befehlsreferenz
- [Pakete erstellen](#hpm-project-setup-creating-packages) - Pakete ver√∂ffentlichen
- [Konfiguration](#hpm-project-setup-configuration) - hpm-Konfiguration


--------------------------------------------------------------------------------
## Schnellstart
--------------------------------------------------------------------------------

# Schnellstart

Starten Sie mit hpm in 5 Minuten.

## hpm installieren

```bash
curl -fsSL https://raw.githubusercontent.com/hemlang/hpm/main/install.sh | sh
```

F√ºr weitere Installationsoptionen siehe die [Installationsanleitung](#hpm-quick-start-installation).

## Ein neues Projekt erstellen

Beginnen Sie mit dem Erstellen eines neuen Verzeichnisses und der Initialisierung eines Pakets:

```bash
mkdir my-project
cd my-project
hpm init
```

Sie werden nach Projektdetails gefragt:

```
Package name (owner/repo): myname/my-project
Version (1.0.0):
Description: Mein tolles Hemlock-Projekt
Author: Ihr Name <sie@beispiel.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

Verwenden Sie `--yes`, um alle Standardwerte zu akzeptieren:

```bash
hpm init --yes
```

## Projektstruktur

Erstellen Sie die grundlegende Projektstruktur:

```
my-project/
‚îú‚îÄ‚îÄ package.json        # Projektmanifest
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ index.hml      # Haupteinstiegspunkt
‚îî‚îÄ‚îÄ test/
    ‚îî‚îÄ‚îÄ test.hml       # Tests
```

Erstellen Sie Ihre Hauptdatei:

```bash
mkdir -p src test
```

**src/index.hml:**
```hemlock
// Haupteinstiegspunkt
export fn greet(name: string): string {
    return "Hallo, " + name + "!";
}

export fn main() {
    print(greet("Welt"));
}
```

## Abh√§ngigkeiten installieren

Suchen Sie nach Paketen auf GitHub (Pakete verwenden das `owner/repo`-Format):

```bash
# Ein Paket installieren
hpm install hemlang/sprout

# Mit Versionseinschr√§nkung installieren
hpm install hemlang/json@^1.0.0

# Als Entwicklungsabh√§ngigkeit installieren
hpm install hemlang/test-utils --dev
```

Nach der Installation enth√§lt Ihre Projektstruktur `hem_modules/`:

```
my-project/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ package-lock.json   # Lock-Datei (automatisch generiert)
‚îú‚îÄ‚îÄ hem_modules/        # Installierte Pakete
‚îÇ   ‚îî‚îÄ‚îÄ hemlang/
‚îÇ       ‚îî‚îÄ‚îÄ sprout/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ index.hml
‚îî‚îÄ‚îÄ test/
    ‚îî‚îÄ‚îÄ test.hml
```

## Installierte Pakete verwenden

Importieren Sie Pakete mit ihrem GitHub-Pfad:

```hemlock
// Aus installiertem Paket importieren
import { app, router } from "hemlang/sprout";
import { parse, stringify } from "hemlang/json";

// Aus Unterpfad importieren
import { middleware } from "hemlang/sprout/middleware";

// Standardbibliothek (eingebaut)
import { HashMap } from "@stdlib/collections";
import { readFile } from "@stdlib/fs";
```

## Skripte hinzuf√ºgen

F√ºgen Sie Skripte zu Ihrer `package.json` hinzu:

```json
{
  "name": "myname/my-project",
  "version": "1.0.0",
  "scripts": {
    "start": "hemlock src/index.hml",
    "test": "hemlock test/test.hml",
    "build": "hemlock --bundle src/index.hml -o dist/app.hmlc"
  }
}
```

F√ºhren Sie Skripte mit `hpm run` aus:

```bash
hpm run start
hpm run build

# Kurzform f√ºr test
hpm test
```

## H√§ufige Arbeitsabl√§ufe

### Alle Abh√§ngigkeiten installieren

Wenn Sie ein Projekt mit einer `package.json` klonen:

```bash
git clone https://github.com/someone/project.git
cd project
hpm install
```

### Abh√§ngigkeiten aktualisieren

Alle Pakete auf die neuesten Versionen innerhalb der Einschr√§nkungen aktualisieren:

```bash
hpm update
```

Ein bestimmtes Paket aktualisieren:

```bash
hpm update hemlang/sprout
```

### Installierte Pakete anzeigen

Alle installierten Pakete auflisten:

```bash
hpm list
```

Die Ausgabe zeigt den Abh√§ngigkeitsbaum:

```
my-project@1.0.0
‚îú‚îÄ‚îÄ hemlang/sprout@2.1.0
‚îÇ   ‚îî‚îÄ‚îÄ hemlang/router@1.5.0
‚îî‚îÄ‚îÄ hemlang/json@1.2.3
```

### Nach Updates suchen

Sehen Sie, welche Pakete neuere Versionen haben:

```bash
hpm outdated
```

### Ein Paket entfernen

```bash
hpm uninstall hemlang/sprout
```

## Beispiel: Webanwendung

Hier ist ein vollst√§ndiges Beispiel mit einem Web-Framework:

**package.json:**
```json
{
  "name": "myname/my-web-app",
  "version": "1.0.0",
  "description": "Eine Webanwendung",
  "main": "src/index.hml",
  "dependencies": {
    "hemlang/sprout": "^2.0.0"
  },
  "scripts": {
    "start": "hemlock src/index.hml",
    "dev": "hemlock --watch src/index.hml"
  }
}
```

**src/index.hml:**
```hemlock
import { App, Router } from "hemlang/sprout";

fn main() {
    let app = App.new();
    let router = Router.new();

    router.get("/", fn(req, res) {
        res.send("Hallo, Welt!");
    });

    router.get("/api/status", fn(req, res) {
        res.json({ status: "ok" });
    });

    app.use(router);
    app.listen(3000);

    print("Server l√§uft auf http://localhost:3000");
}
```

F√ºhren Sie die Anwendung aus:

```bash
hpm install
hpm run start
```

## N√§chste Schritte

- [Befehlsreferenz](#hpm-quick-start-commands) - Lernen Sie alle hpm-Befehle
- [Pakete erstellen](#hpm-quick-start-creating-packages) - Ver√∂ffentlichen Sie Ihre eigenen Pakete
- [Konfiguration](#hpm-quick-start-configuration) - hpm und GitHub-Tokens konfigurieren
- [Projekteinrichtung](#hpm-quick-start-project-setup) - Detaillierte Projektkonfiguration



################################################################################
# HPM: BENUTZERHANDBUCH
################################################################################

--------------------------------------------------------------------------------
## Befehle
--------------------------------------------------------------------------------

# Befehlsreferenz

Vollst√§ndige Referenz f√ºr alle hpm-Befehle.

## Globale Optionen

Diese Optionen funktionieren mit jedem Befehl:

| Option | Beschreibung |
|--------|--------------|
| `--help`, `-h` | Hilfemeldung anzeigen |
| `--version`, `-v` | hpm-Version anzeigen |
| `--verbose` | Detaillierte Ausgabe anzeigen |

## Befehle

### hpm init

Erstellt eine neue `package.json`-Datei.

```bash
hpm init        # Interaktiver Modus
hpm init --yes  # Alle Standardwerte akzeptieren
hpm init -y     # Kurzform
```

**Optionen:**

| Option | Beschreibung |
|--------|--------------|
| `--yes`, `-y` | Standardwerte f√ºr alle Eingabeaufforderungen akzeptieren |

**Interaktive Eingabeaufforderungen:**
- Paketname (owner/repo-Format)
- Version (Standard: 1.0.0)
- Beschreibung
- Autor
- Lizenz (Standard: MIT)
- Hauptdatei (Standard: src/index.hml)

**Beispiel:**

```bash
$ hpm init
Package name (owner/repo): alice/my-lib
Version (1.0.0):
Description: Eine Hilfsbibliothek
Author: Alice <alice@example.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

---

### hpm install

Abh√§ngigkeiten installieren oder neue Pakete hinzuf√ºgen.

```bash
hpm install                           # Alle aus package.json installieren
hpm install owner/repo                # Paket hinzuf√ºgen und installieren
hpm install owner/repo@^1.0.0        # Mit Versionseinschr√§nkung
hpm install owner/repo --dev         # Als Entwicklungsabh√§ngigkeit
hpm i owner/repo                      # Kurzform
```

**Optionen:**

| Option | Beschreibung |
|--------|--------------|
| `--dev`, `-D` | Zu devDependencies hinzuf√ºgen |
| `--verbose` | Detaillierten Fortschritt anzeigen |
| `--dry-run` | Vorschau ohne Installation |
| `--offline` | Nur aus dem Cache installieren (kein Netzwerk) |
| `--parallel` | Parallele Downloads aktivieren (experimentell) |

**Syntax f√ºr Versionseinschr√§nkungen:**

| Syntax | Beispiel | Bedeutung |
|--------|----------|-----------|
| (keine) | `owner/repo` | Neueste Version |
| Exakt | `owner/repo@1.2.3` | Genau 1.2.3 |
| Caret | `owner/repo@^1.2.3` | >=1.2.3 <2.0.0 |
| Tilde | `owner/repo@~1.2.3` | >=1.2.3 <1.3.0 |
| Bereich | `owner/repo@>=1.0.0` | Mindestens 1.0.0 |

**Beispiele:**

```bash
# Alle Abh√§ngigkeiten installieren
hpm install

# Bestimmtes Paket installieren
hpm install hemlang/json

# Mit Versionseinschr√§nkung installieren
hpm install hemlang/sprout@^2.0.0

# Als Entwicklungsabh√§ngigkeit installieren
hpm install hemlang/test-utils --dev

# Vorschau, was installiert werden w√ºrde
hpm install hemlang/sprout --dry-run

# Ausf√ºhrliche Ausgabe
hpm install --verbose

# Nur aus dem Cache installieren (offline)
hpm install --offline
```

**Ausgabe:**

```
Installing dependencies...
  + hemlang/sprout@2.1.0
  + hemlang/router@1.5.0 (Abh√§ngigkeit von hemlang/sprout)

Installed 2 packages in 1.2s
```

---

### hpm uninstall

Ein Paket entfernen.

```bash
hpm uninstall owner/repo
hpm rm owner/repo          # Kurzform
hpm remove owner/repo      # Alternative
```

**Beispiele:**

```bash
hpm uninstall hemlang/sprout
```

**Ausgabe:**

```
Removed hemlang/sprout@2.1.0
Updated package.json
Updated package-lock.json
```

---

### hpm update

Pakete auf die neuesten Versionen innerhalb der Einschr√§nkungen aktualisieren.

```bash
hpm update              # Alle Pakete aktualisieren
hpm update owner/repo   # Bestimmtes Paket aktualisieren
hpm up owner/repo       # Kurzform
```

**Optionen:**

| Option | Beschreibung |
|--------|--------------|
| `--verbose` | Detaillierten Fortschritt anzeigen |
| `--dry-run` | Vorschau ohne Aktualisierung |

**Beispiele:**

```bash
# Alle Pakete aktualisieren
hpm update

# Bestimmtes Paket aktualisieren
hpm update hemlang/sprout

# Aktualisierungen vorab anzeigen
hpm update --dry-run
```

**Ausgabe:**

```
Updating dependencies...
  hemlang/sprout: 2.0.0 ‚Üí 2.1.0
  hemlang/router: 1.4.0 ‚Üí 1.5.0

Updated 2 packages
```

---

### hpm list

Installierte Pakete anzeigen.

```bash
hpm list              # Vollst√§ndigen Abh√§ngigkeitsbaum anzeigen
hpm list --depth=0    # Nur direkte Abh√§ngigkeiten
hpm list --depth=1    # Eine Ebene transitiver Abh√§ngigkeiten
hpm ls                # Kurzform
```

**Optionen:**

| Option | Beschreibung |
|--------|--------------|
| `--depth=N` | Baumtiefe begrenzen (Standard: alle) |

**Beispiele:**

```bash
$ hpm list
my-project@1.0.0
‚îú‚îÄ‚îÄ hemlang/sprout@2.1.0
‚îÇ   ‚îú‚îÄ‚îÄ hemlang/router@1.5.0
‚îÇ   ‚îî‚îÄ‚îÄ hemlang/middleware@1.2.0
‚îú‚îÄ‚îÄ hemlang/json@1.2.3
‚îî‚îÄ‚îÄ hemlang/test-utils@1.0.0 (dev)

$ hpm list --depth=0
my-project@1.0.0
‚îú‚îÄ‚îÄ hemlang/sprout@2.1.0
‚îú‚îÄ‚îÄ hemlang/json@1.2.3
‚îî‚îÄ‚îÄ hemlang/test-utils@1.0.0 (dev)
```

---

### hpm outdated

Pakete mit neueren verf√ºgbaren Versionen anzeigen.

```bash
hpm outdated
```

**Ausgabe:**

```
Package            Current  Wanted  Latest
hemlang/sprout     2.0.0    2.0.5   2.1.0
hemlang/router     1.4.0    1.4.2   1.5.0
```

- **Current**: Installierte Version
- **Wanted**: H√∂chste Version, die der Einschr√§nkung entspricht
- **Latest**: Neueste verf√ºgbare Version

---

### hpm run

Ein Skript aus package.json ausf√ºhren.

```bash
hpm run <script>
hpm run <script> -- <args>
```

**Beispiele:**

Bei dieser package.json:

```json
{
  "scripts": {
    "start": "hemlock src/index.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/index.hml -o dist/app.hmlc"
  }
}
```

Skripte ausf√ºhren:

```bash
hpm run start
hpm run test
hpm run build

# Argumente an das Skript √ºbergeben
hpm run test -- --verbose
```

---

### hpm test

Kurzform f√ºr `hpm run test`.

```bash
hpm test
hpm test -- --verbose
```

Entspricht:

```bash
hpm run test
```

---

### hpm why

Erkl√§ren, warum ein Paket installiert ist (Abh√§ngigkeitskette anzeigen).

```bash
hpm why owner/repo
```

**Beispiel:**

```bash
$ hpm why hemlang/router

hemlang/router@1.5.0 ist installiert, weil:

my-project@1.0.0
‚îî‚îÄ‚îÄ hemlang/sprout@2.1.0
    ‚îî‚îÄ‚îÄ hemlang/router@1.5.0
```

---

### hpm cache

Den globalen Paket-Cache verwalten.

```bash
hpm cache list    # Gecachte Pakete auflisten
hpm cache clean   # Alle gecachten Pakete l√∂schen
```

**Unterbefehle:**

| Unterbefehl | Beschreibung |
|-------------|--------------|
| `list` | Alle gecachten Pakete und Gr√∂√üen anzeigen |
| `clean` | Alle gecachten Pakete entfernen |

**Beispiele:**

```bash
$ hpm cache list
Cached packages in ~/.hpm/cache:

hemlang/sprout
  2.0.0 (1.2 MB)
  2.1.0 (1.3 MB)
hemlang/router
  1.5.0 (450 KB)

Total: 2.95 MB

$ hpm cache clean
Cleared cache (2.95 MB freed)
```

---

## Befehlsk√ºrzel

Der Einfachheit halber haben mehrere Befehle kurze Aliase:

| Befehl | K√ºrzel |
|--------|--------|
| `install` | `i` |
| `uninstall` | `rm`, `remove` |
| `list` | `ls` |
| `update` | `up` |

**Beispiele:**

```bash
hpm i hemlang/sprout        # hpm install hemlang/sprout
hpm rm hemlang/sprout       # hpm uninstall hemlang/sprout
hpm ls                      # hpm list
hpm up                      # hpm update
```

---

## Exit-Codes

hpm verwendet spezifische Exit-Codes, um verschiedene Fehlerbedingungen anzuzeigen:

| Code | Bedeutung |
|------|-----------|
| 0 | Erfolg |
| 1 | Abh√§ngigkeitskonflikt |
| 2 | Paket nicht gefunden |
| 3 | Version nicht gefunden |
| 4 | Netzwerkfehler |
| 5 | Ung√ºltige package.json |
| 6 | Integrit√§tspr√ºfung fehlgeschlagen |
| 7 | GitHub-Rate-Limit √ºberschritten |
| 8 | Zirkul√§re Abh√§ngigkeit |

Exit-Codes in Skripten verwenden:

```bash
hpm install
if [ $? -ne 0 ]; then
    echo "Installation fehlgeschlagen"
    exit 1
fi
```

---

## Umgebungsvariablen

hpm ber√ºcksichtigt diese Umgebungsvariablen:

| Variable | Beschreibung |
|----------|--------------|
| `GITHUB_TOKEN` | GitHub-API-Token f√ºr Authentifizierung |
| `HPM_CACHE_DIR` | Cache-Verzeichnis √ºberschreiben |
| `HOME` | Benutzer-Home-Verzeichnis (f√ºr Konfiguration/Cache) |

**Beispiele:**

```bash
# GitHub-Token f√ºr h√∂here Rate-Limits verwenden
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Benutzerdefiniertes Cache-Verzeichnis verwenden
export HPM_CACHE_DIR=/tmp/hpm-cache
hpm install
```

---

## Siehe auch

- [Konfiguration](#hpm-commands-configuration) - Konfigurationsdateien
- [Paketspezifikation](#hpm-commands-package-spec) - package.json-Format
- [Fehlerbehebung](#hpm-commands-troubleshooting) - H√§ufige Probleme


--------------------------------------------------------------------------------
## Fehlerbehebung
--------------------------------------------------------------------------------

# Fehlerbehebung

L√∂sungen f√ºr h√§ufige hpm-Probleme.

## Installationsprobleme

### "hemlock: command not found"

**Ursache:** Hemlock ist nicht installiert oder nicht im PATH.

**L√∂sung:**

```bash
# Pr√ºfen, ob hemlock existiert
which hemlock

# Falls nicht gefunden, zuerst Hemlock installieren
# Besuchen Sie: https://github.com/hemlang/hemlock

# Nach der Installation √ºberpr√ºfen
hemlock --version
```

### "hpm: command not found"

**Ursache:** hpm ist nicht installiert oder nicht im PATH.

**L√∂sung:**

```bash
# Pr√ºfen, wo hpm installiert ist
ls -la /usr/local/bin/hpm
ls -la ~/.local/bin/hpm

# Bei benutzerdefiniertem Speicherort zum PATH hinzuf√ºgen
export PATH="$HOME/.local/bin:$PATH"

# F√ºr Persistenz zu ~/.bashrc oder ~/.zshrc hinzuf√ºgen
echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc

# Bei Bedarf neu installieren
cd /path/to/hpm
sudo make install
```

### "Permission denied" bei Installation

**Ursache:** Keine Schreibberechtigung f√ºr das Installationsverzeichnis.

**L√∂sung:**

```bash
# Option 1: sudo f√ºr systemweite Installation verwenden
sudo make install

# Option 2: In Benutzerverzeichnis installieren (kein sudo)
make install PREFIX=$HOME/.local
```

## Abh√§ngigkeitsprobleme

### "Package not found" (Exit-Code 2)

**Ursache:** Das Paket existiert nicht auf GitHub.

**L√∂sung:**

```bash
# Pr√ºfen, ob das Paket existiert
# Besuchen Sie: https://github.com/owner/repo

# Rechtschreibung √ºberpr√ºfen
hpm install hemlang/sprout  # Richtig
hpm install hemlan/sprout   # Falscher Owner
hpm install hemlang/spout   # Falscher Repo

# Auf Tippfehler in package.json pr√ºfen
cat package.json | grep -A 5 dependencies
```

### "Version not found" (Exit-Code 3)

**Ursache:** Kein Release entspricht der Versionseinschr√§nkung.

**L√∂sung:**

```bash
# Verf√ºgbare Versionen auflisten (GitHub-Releases/Tags pr√ºfen)
# Tags m√ºssen mit 'v' beginnen (z.B. v1.0.0)

# Eine g√ºltige Versionseinschr√§nkung verwenden
hpm install owner/repo@^1.0.0

# Neueste Version versuchen
hpm install owner/repo

# Verf√ºgbare Tags auf GitHub pr√ºfen
# https://github.com/owner/repo/tags
```

### "Dependency conflict" (Exit-Code 1)

**Ursache:** Zwei Pakete ben√∂tigen inkompatible Versionen einer Abh√§ngigkeit.

**L√∂sung:**

```bash
# Konflikt anzeigen
hpm install --verbose

# Pr√ºfen, was die Abh√§ngigkeit ben√∂tigt
hpm why conflicting/package

# L√∂sungen:
# 1. Das konfliktverursachende Paket aktualisieren
hpm update problem/package

# 2. Versionseinschr√§nkungen in package.json √§ndern
# Bearbeiten, um kompatible Versionen zu erlauben

# 3. Eines der konfliktverursachenden Pakete entfernen
hpm uninstall one/package
```

### "Circular dependency" (Exit-Code 8)

**Ursache:** Paket A h√§ngt von B ab, das wiederum von A abh√§ngt.

**L√∂sung:**

```bash
# Den Zyklus identifizieren
hpm install --verbose

# Dies ist normalerweise ein Bug in den Paketen
# Paket-Maintainer kontaktieren

# Workaround: eines der Pakete vermeiden
```

## Netzwerkprobleme

### "Network error" (Exit-Code 4)

**Ursache:** Keine Verbindung zur GitHub-API m√∂glich.

**L√∂sung:**

```bash
# Internetverbindung pr√ºfen
ping github.com

# Pr√ºfen, ob GitHub-API erreichbar ist
curl -I https://api.github.com

# Erneut versuchen (hpm wiederholt automatisch)
hpm install

# Offline-Modus verwenden, wenn Pakete gecacht sind
hpm install --offline

# Proxy-Einstellungen pr√ºfen, falls hinter Firewall
export HTTPS_PROXY=http://proxy:8080
hpm install
```

### "GitHub rate limit exceeded" (Exit-Code 7)

**Ursache:** Zu viele API-Anfragen ohne Authentifizierung.

**L√∂sung:**

```bash
# Option 1: Mit GitHub-Token authentifizieren (empfohlen)
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Token erstellen: GitHub ‚Üí Einstellungen ‚Üí Entwicklereinstellungen ‚Üí Personal access tokens

# Option 2: Token in Konfigurationsdatei speichern
mkdir -p ~/.hpm
echo '{"github_token": "ghp_xxxxxxxxxxxx"}' > ~/.hpm/config.json

# Option 3: Auf Rate-Limit-Reset warten (wird st√ºndlich zur√ºckgesetzt)

# Option 4: Offline-Modus verwenden
hpm install --offline
```

### Verbindungs-Timeout

**Ursache:** Langsames Netzwerk oder GitHub-API-Probleme.

**L√∂sung:**

```bash
# hpm wiederholt automatisch mit exponentiellem Backoff

# Pr√ºfen, ob GitHub Probleme hat
# Besuchen Sie: https://www.githubstatus.com

# Sp√§ter erneut versuchen
hpm install

# Gecachte Pakete verwenden
hpm install --offline
```

## Package.json-Probleme

### "Invalid package.json" (Exit-Code 5)

**Ursache:** Fehlerhafte oder fehlende erforderliche Felder.

**L√∂sung:**

```bash
# JSON-Syntax validieren
cat package.json | python -m json.tool

# Erforderliche Felder pr√ºfen
cat package.json

# Erforderliche Felder:
# - "name": "owner/repo"-Format
# - "version": "X.Y.Z"-Format

# Bei Bedarf neu generieren
rm package.json
hpm init
```

### "name"-Formatfehler

**Ursache:** Paketname nicht im `owner/repo`-Format.

**L√∂sung:**

```json
// Falsch
{
  "name": "my-package"
}

// Richtig
{
  "name": "yourusername/my-package"
}
```

### "version"-Formatfehler

**Ursache:** Version nicht im Semver-Format.

**L√∂sung:**

```json
// Falsch
{
  "version": "1.0"
}

// Richtig
{
  "version": "1.0.0"
}
```

## Lock-Datei-Probleme

### Lock-Datei nicht synchron

**Ursache:** package.json ge√§ndert ohne install auszuf√ºhren.

**L√∂sung:**

```bash
# Lock-Datei neu generieren
rm package-lock.json
hpm install
```

### Besch√§digte Lock-Datei

**Ursache:** Ung√ºltiges JSON oder manuelle Bearbeitungen.

**L√∂sung:**

```bash
# JSON-G√ºltigkeit pr√ºfen
cat package-lock.json | python -m json.tool

# Neu generieren
rm package-lock.json
hpm install
```

## hem_modules-Probleme

### Pakete werden nicht installiert

**Ursache:** Verschiedene m√∂gliche Probleme.

**L√∂sung:**

```bash
# Bereinigen und neu installieren
rm -rf hem_modules
hpm install

# Ausf√ºhrliche Ausgabe pr√ºfen
hpm install --verbose
```

### Import funktioniert nicht

**Ursache:** Paket nicht korrekt installiert oder falscher Importpfad.

**L√∂sung:**

```bash
# √úberpr√ºfen, ob Paket installiert ist
ls hem_modules/owner/repo/

# main-Feld in package.json pr√ºfen
cat hem_modules/owner/repo/package.json

# Korrektes Import-Format
import { x } from "owner/repo";          # Verwendet main-Eintrag
import { y } from "owner/repo/subpath";  # Unterpfad-Import
```

### "Module not found"-Fehler

**Ursache:** Importpfad l√∂st nicht zu einer Datei auf.

**L√∂sung:**

```bash
# Importpfad pr√ºfen
ls hem_modules/owner/repo/src/

# Auf index.hml pr√ºfen
ls hem_modules/owner/repo/src/index.hml

# main-Feld in package.json √ºberpr√ºfen
cat hem_modules/owner/repo/package.json | grep main
```

## Cache-Probleme

### Cache belegt zu viel Speicherplatz

**L√∂sung:**

```bash
# Cache-Gr√∂√üe anzeigen
hpm cache list

# Cache leeren
hpm cache clean
```

### Cache-Berechtigungen

**L√∂sung:**

```bash
# Berechtigungen reparieren
chmod -R u+rw ~/.hpm/cache

# Oder entfernen und neu installieren
rm -rf ~/.hpm/cache
hpm install
```

### Falschen Cache verwenden

**L√∂sung:**

```bash
# Cache-Speicherort pr√ºfen
echo $HPM_CACHE_DIR
ls ~/.hpm/cache

# Umgebungsvariable l√∂schen, falls falsch
unset HPM_CACHE_DIR
```

## Skript-Probleme

### "Script not found"

**Ursache:** Skriptname existiert nicht in package.json.

**L√∂sung:**

```bash
# Verf√ºgbare Skripte auflisten
cat package.json | grep -A 20 scripts

# Rechtschreibung pr√ºfen
hpm run test    # Richtig
hpm run tests   # Falsch, wenn Skript "test" hei√üt
```

### Skript schl√§gt fehl

**Ursache:** Fehler im Skriptbefehl.

**L√∂sung:**

```bash
# Befehl direkt ausf√ºhren, um Fehler zu sehen
hemlock test/run.hml

# Skriptdefinition pr√ºfen
cat package.json | grep test
```

## Debugging

### Ausf√ºhrliche Ausgabe aktivieren

```bash
hpm install --verbose
```

### hpm-Version pr√ºfen

```bash
hpm --version
```

### Hemlock-Version pr√ºfen

```bash
hemlock --version
```

### Trockenlauf

Vorschau ohne √Ñnderungen:

```bash
hpm install --dry-run
```

### Neuanfang

Frisch starten:

```bash
rm -rf hem_modules package-lock.json
hpm install
```

## Hilfe erhalten

### Befehlshilfe

```bash
hpm --help
hpm install --help
```

### Probleme melden

Wenn Sie einen Bug finden:

1. Bestehende Issues pr√ºfen: https://github.com/hemlang/hpm/issues
2. Neues Issue erstellen mit:
   - hpm-Version (`hpm --version`)
   - Hemlock-Version (`hemlock --version`)
   - Betriebssystem
   - Schritte zum Reproduzieren
   - Fehlermeldung (mit `--verbose`)

## Exit-Code-Referenz

| Code | Bedeutung | H√§ufige L√∂sung |
|------|-----------|----------------|
| 0 | Erfolg | - |
| 1 | Abh√§ngigkeitskonflikt | Aktualisieren oder Einschr√§nkungen √§ndern |
| 2 | Paket nicht gefunden | Rechtschreibung pr√ºfen, Repo-Existenz verifizieren |
| 3 | Version nicht gefunden | Verf√ºgbare Versionen auf GitHub pr√ºfen |
| 4 | Netzwerkfehler | Verbindung pr√ºfen, erneut versuchen |
| 5 | Ung√ºltige package.json | JSON-Syntax und erforderliche Felder reparieren |
| 6 | Integrit√§tspr√ºfung fehlgeschlagen | Cache leeren, neu installieren |
| 7 | GitHub-Rate-Limit | GITHUB_TOKEN hinzuf√ºgen |
| 8 | Zirkul√§re Abh√§ngigkeit | Paket-Maintainer kontaktieren |

## Siehe auch

- [Installation](#hpm-troubleshooting-installation) - Installationsanleitung
- [Konfiguration](#hpm-troubleshooting-configuration) - Konfigurationsoptionen
- [Befehle](#hpm-troubleshooting-commands) - Befehlsreferenz


--------------------------------------------------------------------------------
## Konfiguration
--------------------------------------------------------------------------------

# Konfiguration

Diese Anleitung behandelt alle Konfigurationsoptionen f√ºr hpm.

## √úbersicht

hpm kann konfiguriert werden durch:

1. **Umgebungsvariablen** - F√ºr Laufzeiteinstellungen
2. **Globale Konfigurationsdatei** - `~/.hpm/config.json`
3. **Projektdateien** - `package.json` und `package-lock.json`

## Umgebungsvariablen

### GITHUB_TOKEN

GitHub-API-Token f√ºr Authentifizierung.

```bash
export GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx
```

**Vorteile der Authentifizierung:**
- H√∂here API-Rate-Limits (5000 statt 60 Anfragen/Stunde)
- Zugriff auf private Repositories
- Schnellere Abh√§ngigkeitsaufl√∂sung

**Token erstellen:**

1. Gehen Sie zu GitHub ‚Üí Einstellungen ‚Üí Entwicklereinstellungen ‚Üí Personal access tokens
2. Klicken Sie auf "Generate new token (classic)"
3. W√§hlen Sie Berechtigungen:
   - `repo` - F√ºr Zugriff auf private Repositories
   - `read:packages` - F√ºr GitHub Packages (falls verwendet)
4. Generieren und Token kopieren

### HPM_CACHE_DIR

Das Standard-Cache-Verzeichnis √ºberschreiben.

```bash
export HPM_CACHE_DIR=/custom/cache/path
```

Standard: `~/.hpm/cache`

**Anwendungsf√§lle:**
- CI/CD-Systeme mit benutzerdefinierten Cache-Speicherorten
- Gemeinsamer Cache √ºber Projekte hinweg
- Tempor√§rer Cache f√ºr isolierte Builds

### HOME

Benutzer-Home-Verzeichnis. Wird verwendet, um zu finden:
- Konfigurationsverzeichnis: `$HOME/.hpm/`
- Cache-Verzeichnis: `$HOME/.hpm/cache/`

Normalerweise vom System gesetzt; nur bei Bedarf √ºberschreiben.

### Beispiel .bashrc / .zshrc

```bash
# GitHub-Authentifizierung (empfohlen)
export GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx

# Benutzerdefinierter Cache-Speicherort (optional)
# export HPM_CACHE_DIR=/path/to/cache

# hpm zum PATH hinzuf√ºgen (bei benutzerdefiniertem Installationsort)
export PATH="$HOME/.local/bin:$PATH"
```

## Globale Konfigurationsdatei

### Speicherort

`~/.hpm/config.json`

### Format

```json
{
  "github_token": "ghp_xxxxxxxxxxxxxxxxxxxx"
}
```

### Konfigurationsdatei erstellen

```bash
# Konfigurationsverzeichnis erstellen
mkdir -p ~/.hpm

# Konfigurationsdatei erstellen
cat > ~/.hpm/config.json << 'EOF'
{
  "github_token": "ghp_your_token_here"
}
EOF

# Datei sichern (empfohlen)
chmod 600 ~/.hpm/config.json
```

### Token-Priorit√§t

Wenn beide gesetzt sind, hat die Umgebungsvariable Vorrang:

1. `GITHUB_TOKEN` Umgebungsvariable (h√∂chste)
2. `~/.hpm/config.json` `github_token`-Feld
3. Keine Authentifizierung (Standard)

## Verzeichnisstruktur

### Globale Verzeichnisse

```
~/.hpm/
‚îú‚îÄ‚îÄ config.json          # Globale Konfiguration
‚îî‚îÄ‚îÄ cache/               # Paket-Cache
    ‚îî‚îÄ‚îÄ owner/
        ‚îî‚îÄ‚îÄ repo/
            ‚îî‚îÄ‚îÄ 1.0.0.tar.gz
```

### Projektverzeichnisse

```
my-project/
‚îú‚îÄ‚îÄ package.json         # Projektmanifest
‚îú‚îÄ‚îÄ package-lock.json    # Abh√§ngigkeits-Lock-Datei
‚îú‚îÄ‚îÄ hem_modules/         # Installierte Pakete
‚îÇ   ‚îî‚îÄ‚îÄ owner/
‚îÇ       ‚îî‚îÄ‚îÄ repo/
‚îÇ           ‚îú‚îÄ‚îÄ package.json
‚îÇ           ‚îî‚îÄ‚îÄ src/
‚îú‚îÄ‚îÄ src/                 # Quellcode
‚îî‚îÄ‚îÄ test/                # Tests
```

## Paket-Cache

### Speicherort

Standard: `~/.hpm/cache/`

√úberschreiben mit: `HPM_CACHE_DIR` Umgebungsvariable

### Struktur

```
~/.hpm/cache/
‚îú‚îÄ‚îÄ hemlang/
‚îÇ   ‚îú‚îÄ‚îÄ sprout/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 2.0.0.tar.gz
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 2.1.0.tar.gz
‚îÇ   ‚îî‚îÄ‚îÄ router/
‚îÇ       ‚îî‚îÄ‚îÄ 1.5.0.tar.gz
‚îî‚îÄ‚îÄ alice/
    ‚îî‚îÄ‚îÄ http-client/
        ‚îî‚îÄ‚îÄ 1.0.0.tar.gz
```

### Cache verwalten

```bash
# Gecachte Pakete anzeigen
hpm cache list

# Gesamten Cache leeren
hpm cache clean
```

### Cache-Verhalten

- Pakete werden nach dem ersten Download gecacht
- Nachfolgende Installationen verwenden gecachte Versionen
- Verwenden Sie `--offline`, um nur aus dem Cache zu installieren
- Der Cache wird √ºber alle Projekte geteilt

## GitHub-API-Rate-Limits

### Ohne Authentifizierung

- **60 Anfragen pro Stunde** pro IP-Adresse
- Geteilt unter allen nicht authentifizierten Benutzern derselben IP
- Schnell ersch√∂pft bei CI/CD oder vielen Abh√§ngigkeiten

### Mit Authentifizierung

- **5000 Anfragen pro Stunde** pro authentifiziertem Benutzer
- Pers√∂nliches Rate-Limit, nicht geteilt

### Rate-Limits behandeln

hpm macht automatisch:
- Wiederholungen mit exponentiellem Backoff (1s, 2s, 4s, 8s)
- Meldet Rate-Limit-Fehler mit Exit-Code 7
- Schl√§gt Authentifizierung vor, wenn Rate-Limit erreicht

**L√∂sungen bei Rate-Limit:**

```bash
# Option 1: Mit GitHub-Token authentifizieren
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install

# Option 2: Auf Rate-Limit-Reset warten
# (Limits werden st√ºndlich zur√ºckgesetzt)

# Option 3: Offline-Modus verwenden (wenn Pakete gecacht sind)
hpm install --offline
```

## Offline-Modus

Pakete ohne Netzwerkzugriff installieren:

```bash
hpm install --offline
```

**Voraussetzungen:**
- Alle Pakete m√ºssen im Cache sein
- Lock-Datei muss mit exakten Versionen existieren

**Anwendungsf√§lle:**
- Air-Gapped-Umgebungen
- Schnellere CI/CD-Builds (mit warmem Cache)
- Rate-Limits vermeiden

## CI/CD-Konfiguration

### GitHub Actions

```yaml
name: CI

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Hemlock einrichten
      run: |
        # Hemlock installieren (anpassen basierend auf Ihrem Setup)
        curl -sSL https://hemlock.dev/install.sh | sh

    - name: hpm-Pakete cachen
      uses: actions/cache@v3
      with:
        path: ~/.hpm/cache
        key: ${{ runner.os }}-hpm-${{ hashFiles('package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-hpm-

    - name: Abh√§ngigkeiten installieren
      run: hpm install
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Tests ausf√ºhren
      run: hpm test
```

### GitLab CI

```yaml
stages:
  - build
  - test

variables:
  HPM_CACHE_DIR: $CI_PROJECT_DIR/.hpm-cache

cache:
  paths:
    - .hpm-cache/
  key: $CI_COMMIT_REF_SLUG

build:
  stage: build
  script:
    - hpm install
  artifacts:
    paths:
      - hem_modules/

test:
  stage: test
  script:
    - hpm test
```

### Docker

**Dockerfile:**

```dockerfile
FROM hemlock:latest

WORKDIR /app

# Paketdateien zuerst kopieren (f√ºr Layer-Caching)
COPY package.json package-lock.json ./

# Abh√§ngigkeiten installieren
RUN hpm install

# Quellcode kopieren
COPY . .

# Anwendung ausf√ºhren
CMD ["hemlock", "src/main.hml"]
```

**docker-compose.yml:**

```yaml
version: '3.8'

services:
  app:
    build: .
    environment:
      - GITHUB_TOKEN=${GITHUB_TOKEN}
    volumes:
      - hpm-cache:/root/.hpm/cache

volumes:
  hpm-cache:
```

## Proxy-Konfiguration

F√ºr Umgebungen hinter einem Proxy auf Systemebene konfigurieren:

```bash
export HTTP_PROXY=http://proxy.example.com:8080
export HTTPS_PROXY=http://proxy.example.com:8080
export NO_PROXY=localhost,127.0.0.1

hpm install
```

## Sicherheits-Best-Practices

### Token-Sicherheit

1. **Tokens niemals committen** zur Versionskontrolle
2. **Umgebungsvariablen verwenden** in CI/CD
3. **Token-Berechtigungen einschr√§nken** auf das erforderliche Minimum
4. **Tokens regelm√§√üig rotieren**
5. **Konfigurationsdatei sichern**:
   ```bash
   chmod 600 ~/.hpm/config.json
   ```

### Private Repositories

Um auf private Pakete zuzugreifen:

1. Token mit `repo`-Berechtigung erstellen
2. Authentifizierung konfigurieren (Umgebungsvariable oder Konfigurationsdatei)
3. Sicherstellen, dass das Token Zugriff auf das Repository hat

```bash
# Zugriff testen
export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
hpm install yourorg/private-package
```

## Konfiguration-Fehlerbehebung

### Konfiguration √ºberpr√ºfen

```bash
# Pr√ºfen, ob Token gesetzt ist
echo $GITHUB_TOKEN | head -c 10

# Konfigurationsdatei pr√ºfen
cat ~/.hpm/config.json

# Cache-Verzeichnis pr√ºfen
ls -la ~/.hpm/cache/

# Mit ausf√ºhrlicher Ausgabe testen
hpm install --verbose
```

### H√§ufige Probleme

**"GitHub rate limit exceeded"**
- Authentifizierung mit `GITHUB_TOKEN` einrichten
- Auf Rate-Limit-Reset warten
- `--offline` verwenden, wenn Pakete gecacht sind

**"Permission denied" beim Cache**
```bash
# Cache-Berechtigungen reparieren
chmod -R u+rw ~/.hpm/cache
```

**"Config file not found"**
```bash
# Konfigurationsverzeichnis erstellen
mkdir -p ~/.hpm
touch ~/.hpm/config.json
```

## Siehe auch

- [Installation](#hpm-configuration-installation) - hpm installieren
- [Fehlerbehebung](#hpm-configuration-troubleshooting) - H√§ufige Probleme
- [Befehle](#hpm-configuration-commands) - Befehlsreferenz



################################################################################
# HPM: PAKETENTWICKLUNG
################################################################################

--------------------------------------------------------------------------------
## Pakete erstellen
--------------------------------------------------------------------------------

# Pakete erstellen

Diese Anleitung behandelt, wie man Hemlock-Pakete erstellt, strukturiert und ver√∂ffentlicht.

## √úbersicht

hpm verwendet GitHub als Paketregistrierung. Pakete werden durch ihren GitHub-`owner/repo`-Pfad identifiziert, und Versionen sind Git-Tags. Ver√∂ffentlichen bedeutet einfach, ein getaggtes Release zu pushen.

## Ein neues Paket erstellen

### 1. Das Paket initialisieren

Ein neues Verzeichnis erstellen und initialisieren:

```bash
mkdir my-package
cd my-package
hpm init
```

Die Eingabeaufforderungen beantworten:

```
Package name (owner/repo): yourusername/my-package
Version (1.0.0):
Description: Ein n√ºtzliches Hemlock-Paket
Author: Ihr Name <sie@beispiel.com>
License (MIT):
Main file (src/index.hml):

Created package.json
```

### 2. Die Projektstruktur erstellen

Empfohlene Struktur f√ºr Pakete:

```
my-package/
‚îú‚îÄ‚îÄ package.json          # Paketmanifest
‚îú‚îÄ‚îÄ README.md             # Dokumentation
‚îú‚îÄ‚îÄ LICENSE               # Lizenzdatei
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ index.hml         # Haupteinstiegspunkt (exportiert √∂ffentliche API)
‚îÇ   ‚îú‚îÄ‚îÄ utils.hml         # Interne Hilfsfunktionen
‚îÇ   ‚îî‚îÄ‚îÄ types.hml         # Typdefinitionen
‚îî‚îÄ‚îÄ test/
    ‚îú‚îÄ‚îÄ framework.hml     # Test-Framework
    ‚îî‚îÄ‚îÄ test_utils.hml    # Tests
```

### 3. Ihre √∂ffentliche API definieren

**src/index.hml** - Haupteinstiegspunkt:

```hemlock
// √ñffentliche API re-exportieren
export { parse, stringify } from "./parser.hml";
export { Config, Options } from "./types.hml";
export { process } from "./processor.hml";

// Direkte Exporte
export fn create(options: Options): Config {
    // Implementierung
}

export fn validate(config: Config): bool {
    // Implementierung
}
```

### 4. Ihre package.json schreiben

Vollst√§ndiges package.json-Beispiel:

```json
{
  "name": "yourusername/my-package",
  "version": "1.0.0",
  "description": "Ein n√ºtzliches Hemlock-Paket",
  "author": "Ihr Name <sie@beispiel.com>",
  "license": "MIT",
  "repository": "https://github.com/yourusername/my-package",
  "main": "src/index.hml",
  "dependencies": {
    "hemlang/json": "^1.0.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  },
  "scripts": {
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/index.hml -o dist/bundle.hmlc"
  },
  "keywords": ["utility", "parser", "config"],
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ]
}
```

## Paketbenennung

### Anforderungen

- Muss im `owner/repo`-Format sein
- `owner` sollte Ihr GitHub-Benutzername oder Ihre Organisation sein
- `repo` sollte der Repository-Name sein
- Kleinbuchstaben mit Bindestrichen f√ºr mehrwortige Namen verwenden

### Gute Namen

```
hemlang/sprout
alice/http-client
myorg/json-utils
bob/date-formatter
```

### Vermeiden

```
my-package          # Owner fehlt
alice/MyPackage     # PascalCase
alice/my_package    # Unterstriche
```

## Best Practices f√ºr Paketstruktur

### Einstiegspunkt

Das `main`-Feld in package.json gibt den Einstiegspunkt an:

```json
{
  "main": "src/index.hml"
}
```

Diese Datei sollte Ihre √∂ffentliche API exportieren:

```hemlock
// Alles exportieren, was Benutzer brauchen
export { Parser, parse } from "./parser.hml";
export { Formatter, format } from "./formatter.hml";

// Typen
export type { Config, Options } from "./types.hml";
```

### Intern vs √ñffentlich

Interne Implementierungsdetails privat halten:

```
src/
‚îú‚îÄ‚îÄ index.hml          # √ñffentlich: exportierte API
‚îú‚îÄ‚îÄ parser.hml         # √ñffentlich: von index.hml verwendet
‚îú‚îÄ‚îÄ formatter.hml      # √ñffentlich: von index.hml verwendet
‚îî‚îÄ‚îÄ internal/
    ‚îú‚îÄ‚îÄ helpers.hml    # Privat: nur interne Verwendung
    ‚îî‚îÄ‚îÄ constants.hml  # Privat: nur interne Verwendung
```

Benutzer importieren vom Paket-Root:

```hemlock
// Gut - importiert aus √∂ffentlicher API
import { parse, Parser } from "yourusername/my-package";

// Funktioniert auch - Unterpfad-Import
import { validate } from "yourusername/my-package/validator";

// Nicht empfohlen - Zugriff auf Interna
import { helper } from "yourusername/my-package/internal/helpers";
```

### Unterpfad-Exporte

Unterst√ºtzung f√ºr Importe aus Unterpfaden:

```
src/
‚îú‚îÄ‚îÄ index.hml              # Haupteinstieg
‚îú‚îÄ‚îÄ parser/
‚îÇ   ‚îî‚îÄ‚îÄ index.hml          # yourusername/pkg/parser
‚îú‚îÄ‚îÄ formatter/
‚îÇ   ‚îî‚îÄ‚îÄ index.hml          # yourusername/pkg/formatter
‚îî‚îÄ‚îÄ utils/
    ‚îî‚îÄ‚îÄ index.hml          # yourusername/pkg/utils
```

Benutzer k√∂nnen importieren:

```hemlock
import { parse } from "yourusername/my-package";           # Haupt
import { Parser } from "yourusername/my-package/parser";   # Unterpfad
import { format } from "yourusername/my-package/formatter";
```

## Abh√§ngigkeiten

### Abh√§ngigkeiten hinzuf√ºgen

```bash
# Laufzeitabh√§ngigkeit
hpm install hemlang/json

# Entwicklungsabh√§ngigkeit
hpm install hemlang/test-utils --dev
```

### Best Practices f√ºr Abh√§ngigkeiten

1. **Caret-Bereiche verwenden** f√ºr die meisten Abh√§ngigkeiten:
   ```json
   {
     "dependencies": {
       "hemlang/json": "^1.0.0"
     }
   }
   ```

2. **Versionen nur bei Bedarf pinnen** (API-Instabilit√§t):
   ```json
   {
     "dependencies": {
       "unstable/lib": "1.2.3"
     }
   }
   ```

3. **Zu restriktive Bereiche vermeiden**:
   ```json
   // Schlecht: zu restriktiv
   "hemlang/json": ">=1.2.3 <1.2.5"

   // Gut: erlaubt kompatible Updates
   "hemlang/json": "^1.2.3"
   ```

4. **Dev-Abh√§ngigkeiten getrennt halten**:
   ```json
   {
     "dependencies": {
       "hemlang/json": "^1.0.0"
     },
     "devDependencies": {
       "hemlang/test-utils": "^1.0.0"
     }
   }
   ```

## Ihr Paket testen

### Tests schreiben

**test/run.hml:**

```hemlock
import { suite, test, assert_eq } from "./framework.hml";
import { parse, stringify } from "../src/index.hml";

fn run_tests() {
    suite("Parser", fn() {
        test("parst g√ºltige Eingabe", fn() {
            let result = parse("hello");
            assert_eq(result.value, "hello");
        });

        test("behandelt leere Eingabe", fn() {
            let result = parse("");
            assert_eq(result.value, "");
        });
    });

    suite("Stringify", fn() {
        test("stringifiziert Objekt", fn() {
            let obj = { name: "test" };
            let result = stringify(obj);
            assert_eq(result, '{"name":"test"}');
        });
    });
}

run_tests();
```

### Tests ausf√ºhren

Test-Skript hinzuf√ºgen:

```json
{
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
```

Ausf√ºhren mit:

```bash
hpm test
```

## Ver√∂ffentlichen

### Voraussetzungen

1. GitHub-Repository erstellen, das Ihrem Paketnamen entspricht
2. Sicherstellen, dass `package.json` vollst√§ndig und g√ºltig ist
3. Alle Tests bestehen

### Ver√∂ffentlichungsprozess

Ver√∂ffentlichen bedeutet einfach, einen Git-Tag zu pushen:

```bash
# 1. Sicherstellen, dass alles committet ist
git add .
git commit -m "Prepare v1.0.0 release"

# 2. Versions-Tag erstellen (muss mit 'v' beginnen)
git tag v1.0.0

# 3. Code und Tags pushen
git push origin main
git push origin v1.0.0
# Oder alle Tags auf einmal pushen
git push origin main --tags
```

### Versions-Tags

Tags m√ºssen dem Format `vX.Y.Z` folgen:

```bash
git tag v1.0.0      # Release
git tag v1.0.1      # Patch
git tag v1.1.0      # Minor
git tag v2.0.0      # Major
git tag v1.0.0-beta.1  # Pre-Release
```

### Release-Checkliste

Vor dem Ver√∂ffentlichen einer neuen Version:

1. **Version aktualisieren** in package.json
2. **Tests ausf√ºhren**: `hpm test`
3. **CHANGELOG aktualisieren** (falls vorhanden)
4. **README aktualisieren**, falls API ge√§ndert
5. **√Ñnderungen committen**
6. **Tag erstellen**
7. **Zu GitHub pushen**

### Automatisiertes Beispiel

Release-Skript erstellen:

```bash
#!/bin/bash
# release.sh - Neue Version ver√∂ffentlichen

VERSION=$1

if [ -z "$VERSION" ]; then
    echo "Verwendung: ./release.sh 1.0.0"
    exit 1
fi

# Tests ausf√ºhren
hpm test || exit 1

# Version in package.json aktualisieren
sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json

# Committen und taggen
git add package.json
git commit -m "Release v$VERSION"
git tag "v$VERSION"

# Pushen
git push origin main --tags

echo "v$VERSION ver√∂ffentlicht"
```

## Benutzer installieren Ihr Paket

Nach der Ver√∂ffentlichung k√∂nnen Benutzer installieren:

```bash
# Neueste Version
hpm install yourusername/my-package

# Bestimmte Version
hpm install yourusername/my-package@1.0.0

# Versionseinschr√§nkung
hpm install yourusername/my-package@^1.0.0
```

Und importieren:

```hemlock
import { parse, stringify } from "yourusername/my-package";
```

## Dokumentation

### README.md

Jedes Paket sollte eine README haben:

```markdown
# my-package

Eine kurze Beschreibung, was dieses Paket tut.

## Installation

\`\`\`bash
hpm install yourusername/my-package
\`\`\`

## Verwendung

\`\`\`hemlock
import { parse } from "yourusername/my-package";

let result = parse("input");
\`\`\`

## API

### parse(input: string): Result

Parst die Eingabezeichenkette.

### stringify(obj: any): string

Konvertiert Objekt in Zeichenkette.

## Lizenz

MIT
```

### API-Dokumentation

Alle √∂ffentlichen Exporte dokumentieren:

```hemlock
/// Parst die Eingabezeichenkette in ein strukturiertes Result.
///
/// # Argumente
/// * `input` - Die zu parsende Zeichenkette
///
/// # R√ºckgabe
/// Ein Result mit den geparsten Daten oder einem Fehler
///
/// # Beispiel
/// ```
/// let result = parse("hello world");
/// print(result.value);
/// ```
export fn parse(input: string): Result {
    // Implementierung
}
```

## Versionierungsrichtlinien

Folgen Sie [Semantic Versioning](https://semver.org/):

- **MAJOR** (1.0.0 ‚Üí 2.0.0): Breaking Changes
- **MINOR** (1.0.0 ‚Üí 1.1.0): Neue Features, abw√§rtskompatibel
- **PATCH** (1.0.0 ‚Üí 1.0.1): Bugfixes, abw√§rtskompatibel

### Wann erh√∂hen

| √Ñnderungstyp | Versionsbump |
|--------------|--------------|
| Breaking API-√Ñnderung | MAJOR |
| Funktion/Typ entfernen | MAJOR |
| Funktionssignatur √§ndern | MAJOR |
| Neue Funktion hinzuf√ºgen | MINOR |
| Neues Feature hinzuf√ºgen | MINOR |
| Bugfix | PATCH |
| Dokumentations-Update | PATCH |
| Internes Refactoring | PATCH |

## Siehe auch

- [Paketspezifikation](#hpm-creating-packages-package-spec) - Vollst√§ndige package.json-Referenz
- [Versionierung](#hpm-creating-packages-versioning) - Details zur semantischen Versionierung
- [Konfiguration](#hpm-creating-packages-configuration) - GitHub-Authentifizierung


--------------------------------------------------------------------------------
## Paketspezifikation
--------------------------------------------------------------------------------

# Paketspezifikation

Vollst√§ndige Referenz f√ºr das `package.json`-Dateiformat.

## √úbersicht

Jedes hpm-Paket erfordert eine `package.json`-Datei im Projektstammverzeichnis. Diese Datei definiert Paketmetadaten, Abh√§ngigkeiten und Skripte.

## Minimales Beispiel

```json
{
  "name": "owner/repo",
  "version": "1.0.0"
}
```

## Vollst√§ndiges Beispiel

```json
{
  "name": "hemlang/example-package",
  "version": "1.2.3",
  "description": "Ein Beispiel-Hemlock-Paket",
  "author": "Hemlock Team <team@hemlock.dev>",
  "license": "MIT",
  "repository": "https://github.com/hemlang/example-package",
  "homepage": "https://hemlang.github.io/example-package",
  "bugs": "https://github.com/hemlang/example-package/issues",
  "main": "src/index.hml",
  "keywords": ["example", "utility", "hemlock"],
  "dependencies": {
    "hemlang/json": "^1.0.0",
    "hemlang/http": "^2.1.0"
  },
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0"
  },
  "scripts": {
    "start": "hemlock src/main.hml",
    "test": "hemlock test/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/bundle.hmlc"
  },
  "files": [
    "src/",
    "LICENSE",
    "README.md"
  ],
  "native": {
    "requires": ["libcurl", "openssl"]
  }
}
```

## Feldreferenz

### name (erforderlich)

Der Paketname im `owner/repo`-Format.

```json
{
  "name": "hemlang/sprout"
}
```

**Anforderungen:**
- Muss im `owner/repo`-Format sein
- `owner` sollte Ihr GitHub-Benutzername oder Ihre Organisation sein
- `repo` sollte der Repository-Name sein
- Kleinbuchstaben, Zahlen und Bindestriche verwenden
- Maximal 214 Zeichen insgesamt

**G√ºltige Namen:**
```
hemlang/sprout
alice/http-client
myorg/json-utils
bob123/my-lib
```

**Ung√ºltige Namen:**
```
my-package          # Owner fehlt
hemlang/My_Package  # Gro√übuchstaben und Unterstrich
hemlang             # Repo fehlt
```

### version (erforderlich)

Die Paketversion nach [Semantic Versioning](https://semver.org/).

```json
{
  "version": "1.2.3"
}
```

**Format:** `MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]`

**G√ºltige Versionen:**
```
1.0.0
2.1.3
1.0.0-alpha
1.0.0-beta.1
1.0.0-rc.1+build.123
0.1.0
```

### description

Kurze Beschreibung des Pakets.

```json
{
  "description": "Ein schneller JSON-Parser f√ºr Hemlock"
}
```

- Unter 200 Zeichen halten
- Beschreiben, was das Paket tut, nicht wie

### author

Informationen zum Paketautor.

```json
{
  "author": "Ihr Name <email@beispiel.com>"
}
```

**Akzeptierte Formate:**
```json
"author": "Ihr Name"
"author": "Ihr Name <email@beispiel.com>"
"author": "Ihr Name <email@beispiel.com> (https://website.com)"
```

### license

Der Lizenz-Identifikator.

```json
{
  "license": "MIT"
}
```

**H√§ufige Lizenzen:**
- `MIT` - MIT-Lizenz
- `Apache-2.0` - Apache-Lizenz 2.0
- `GPL-3.0` - GNU General Public License v3.0
- `BSD-3-Clause` - BSD 3-Clause-Lizenz
- `ISC` - ISC-Lizenz
- `UNLICENSED` - Propriet√§r/privat

Verwenden Sie wenn m√∂glich [SPDX-Identifikatoren](https://spdx.org/licenses/).

### repository

Link zum Quell-Repository.

```json
{
  "repository": "https://github.com/hemlang/sprout"
}
```

### homepage

Projekt-Homepage-URL.

```json
{
  "homepage": "https://sprout.hemlock.dev"
}
```

### bugs

Issue-Tracker-URL.

```json
{
  "bugs": "https://github.com/hemlang/sprout/issues"
}
```

### main

Einstiegspunktdatei f√ºr das Paket.

```json
{
  "main": "src/index.hml"
}
```

**Standard:** `src/index.hml`

Wenn Benutzer Ihr Paket importieren:
```hemlock
import { x } from "owner/repo";
```

hpm l√§dt die in `main` angegebene Datei.

**Aufl√∂sungsreihenfolge f√ºr Importe:**
1. Exakter Pfad: `src/index.hml`
2. Mit .hml-Erweiterung: `src/index` ‚Üí `src/index.hml`
3. Index-Datei: `src/index/` ‚Üí `src/index/index.hml`

### keywords

Array von Schl√ºsselw√∂rtern f√ºr die Auffindbarkeit.

```json
{
  "keywords": ["json", "parser", "utility", "hemlock"]
}
```

- Kleinbuchstaben verwenden
- Spezifisch und relevant sein
- Sprache ("hemlock") einschlie√üen, falls angemessen

### dependencies

Laufzeitabh√§ngigkeiten, die f√ºr das Funktionieren des Pakets erforderlich sind.

```json
{
  "dependencies": {
    "hemlang/json": "^1.0.0",
    "hemlang/http": "~2.1.0",
    "alice/logger": ">=1.0.0 <2.0.0"
  }
}
```

**Schl√ºssel:** Paketname (`owner/repo`)
**Wert:** Versionseinschr√§nkung

**Syntax f√ºr Versionseinschr√§nkungen:**

| Einschr√§nkung | Bedeutung |
|---------------|-----------|
| `1.2.3` | Exakte Version |
| `^1.2.3` | >=1.2.3 <2.0.0 |
| `~1.2.3` | >=1.2.3 <1.3.0 |
| `>=1.0.0` | Mindestens 1.0.0 |
| `>=1.0.0 <2.0.0` | Bereich |
| `*` | Beliebige Version |

### devDependencies

Nur f√ºr die Entwicklung ben√∂tigte Abh√§ngigkeiten (Testen, Bauen, etc.).

```json
{
  "devDependencies": {
    "hemlang/test-utils": "^1.0.0",
    "hemlang/linter": "^2.0.0"
  }
}
```

Dev-Abh√§ngigkeiten werden:
- W√§hrend der Entwicklung installiert
- Nicht installiert, wenn das Paket als Abh√§ngigkeit verwendet wird
- F√ºr Testen, Bauen, Linting usw. verwendet

### scripts

Benannte Befehle, die mit `hpm run` ausgef√ºhrt werden k√∂nnen.

```json
{
  "scripts": {
    "start": "hemlock src/main.hml",
    "dev": "hemlock --watch src/main.hml",
    "test": "hemlock test/run.hml",
    "test:unit": "hemlock test/unit/run.hml",
    "test:integration": "hemlock test/integration/run.hml",
    "build": "hemlock --bundle src/main.hml -o dist/app.hmlc",
    "clean": "rm -rf dist hem_modules",
    "lint": "hemlock-lint src/",
    "format": "hemlock-fmt src/"
  }
}
```

**Skripte ausf√ºhren:**
```bash
hpm run start
hpm run build
hpm test        # Kurzform f√ºr 'hpm run test'
```

**Argumente √ºbergeben:**
```bash
hpm run test -- --verbose --filter=unit
```

**H√§ufige Skripte:**

| Skript | Zweck |
|--------|-------|
| `start` | Anwendung starten |
| `dev` | Entwicklungsmodus mit Hot Reload |
| `test` | Tests ausf√ºhren |
| `build` | F√ºr Produktion bauen |
| `clean` | Build-Artefakte entfernen |
| `lint` | Code-Stil pr√ºfen |
| `format` | Code formatieren |

### files

Dateien und Verzeichnisse, die beim Installieren des Pakets enthalten sein sollen.

```json
{
  "files": [
    "src/",
    "lib/",
    "LICENSE",
    "README.md"
  ]
}
```

**Standardverhalten:** Falls nicht angegeben, enth√§lt:
- Alle Dateien im Repository
- Ausgenommen `.git/`, `node_modules/`, `hem_modules/`

**Verwenden um:**
- Paketgr√∂√üe zu reduzieren
- Testdateien von der Distribution auszuschlie√üen
- Nur notwendige Dateien einzuschlie√üen

### native

Native Bibliotheksanforderungen.

```json
{
  "native": {
    "requires": ["libcurl", "openssl", "sqlite3"]
  }
}
```

Dokumentiert native Abh√§ngigkeiten, die auf dem System installiert sein m√ºssen.

## Validierung

hpm validiert package.json bei verschiedenen Operationen. H√§ufige Validierungsfehler:

### Fehlende erforderliche Felder

```
Error: package.json missing required field: name
```

**L√∂sung:** Das erforderliche Feld hinzuf√ºgen.

### Ung√ºltiges Namensformat

```
Error: Invalid package name. Must be in owner/repo format.
```

**L√∂sung:** `owner/repo`-Format verwenden.

### Ung√ºltige Version

```
Error: Invalid version "1.0". Must be semver format (X.Y.Z).
```

**L√∂sung:** Vollst√§ndiges Semver-Format verwenden (`1.0.0`).

### Ung√ºltiges JSON

```
Error: package.json is not valid JSON
```

**L√∂sung:** JSON-Syntax pr√ºfen (Kommas, Anf√ºhrungszeichen, Klammern).

## package.json erstellen

### Interaktiv

```bash
hpm init
```

Fragt interaktiv nach jedem Feld.

### Mit Standardwerten

```bash
hpm init --yes
```

Erstellt mit Standardwerten:
```json
{
  "name": "directory-name/directory-name",
  "version": "1.0.0",
  "description": "",
  "author": "",
  "license": "MIT",
  "main": "src/index.hml",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
```

### Manuell

Die Datei manuell erstellen:

```bash
cat > package.json << 'EOF'
{
  "name": "yourname/your-package",
  "version": "1.0.0",
  "description": "Ihre Paketbeschreibung",
  "main": "src/index.hml",
  "dependencies": {},
  "scripts": {
    "test": "hemlock test/run.hml"
  }
}
EOF
```

## Best Practices

1. **Immer main angeben** - Nicht auf Standard verlassen
2. **Caret-Bereiche verwenden** - `^1.0.0` f√ºr die meisten Abh√§ngigkeiten
3. **Dev-Abh√§ngigkeiten trennen** - Test/Build-Deps in devDependencies
4. **Keywords einschlie√üen** - Helfen Benutzern, Ihr Paket zu finden
5. **Skripte dokumentieren** - Skripte klar benennen
6. **Lizenz angeben** - Erforderlich f√ºr Open Source
7. **Beschreibung hinzuf√ºgen** - Helfen Benutzern, den Zweck zu verstehen

## Siehe auch

- [Pakete erstellen](#hpm-package-spec-creating-packages) - Ver√∂ffentlichungsanleitung
- [Versionierung](#hpm-package-spec-versioning) - Versionseinschr√§nkungen
- [Projekteinrichtung](#hpm-package-spec-project-setup) - Projektstruktur


--------------------------------------------------------------------------------
## Versionierung
--------------------------------------------------------------------------------

# Versionierung

Vollst√§ndige Anleitung zur semantischen Versionierung in hpm.

## Semantische Versionierung

hpm verwendet [Semantic Versioning 2.0.0](https://semver.org/) (semver) f√ºr Paketversionen.

### Versionsformat

```
MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]
```

**Beispiele:**
```
1.0.0           # Release-Version
2.1.3           # Release-Version
1.0.0-alpha     # Pre-Release
1.0.0-beta.1    # Pre-Release mit Nummer
1.0.0-rc.1      # Release Candidate
1.0.0+20231201  # Mit Build-Metadaten
1.0.0-beta+exp  # Pre-Release mit Build-Metadaten
```

### Versionskomponenten

| Komponente | Beschreibung | Beispiel |
|------------|--------------|----------|
| MAJOR | Breaking Changes | `1.0.0` ‚Üí `2.0.0` |
| MINOR | Neue Features (abw√§rtskompatibel) | `1.0.0` ‚Üí `1.1.0` |
| PATCH | Bugfixes (abw√§rtskompatibel) | `1.0.0` ‚Üí `1.0.1` |
| PRERELEASE | Pre-Release-Identifikator | `1.0.0-alpha` |
| BUILD | Build-Metadaten (bei Vergleich ignoriert) | `1.0.0+build123` |

### Wann erh√∂hen

| √Ñnderungstyp | Erh√∂hen | Beispiel |
|--------------|---------|----------|
| Breaking API-√Ñnderung | MAJOR | Funktion entfernen |
| √ñffentliche Funktion umbenennen | MAJOR | `parse()` ‚Üí `decode()` |
| Funktionssignatur √§ndern | MAJOR | Erforderlichen Parameter hinzuf√ºgen |
| Neue Funktion hinzuf√ºgen | MINOR | `validate()` hinzuf√ºgen |
| Optionalen Parameter hinzuf√ºgen | MINOR | Neues optionales `options`-Arg |
| Bugfix | PATCH | Null-Pointer beheben |
| Leistungsverbesserung | PATCH | Schnellerer Algorithmus |
| Internes Refactoring | PATCH | Keine API-√Ñnderung |

## Versionseinschr√§nkungen

### Einschr√§nkungssyntax

| Syntax | Bedeutung | L√∂st auf zu |
|--------|-----------|-------------|
| `1.2.3` | Exakte Version | Nur 1.2.3 |
| `^1.2.3` | Caret (kompatibel) | ‚â•1.2.3 und <2.0.0 |
| `~1.2.3` | Tilde (Patch-Updates) | ‚â•1.2.3 und <1.3.0 |
| `>=1.0.0` | Mindestens | 1.0.0 oder h√∂her |
| `>1.0.0` | Gr√∂√üer als | H√∂her als 1.0.0 |
| `<2.0.0` | Kleiner als | Niedriger als 2.0.0 |
| `<=2.0.0` | H√∂chstens | 2.0.0 oder niedriger |
| `>=1.0.0 <2.0.0` | Bereich | Zwischen 1.0.0 und 2.0.0 |
| `*` | Beliebig | Beliebige Version |

### Caret-Bereiche (^)

Das Caret (`^`) erlaubt √Ñnderungen, die die linkeste Nicht-Null-Ziffer nicht modifizieren:

```
^1.2.3  ‚Üí  >=1.2.3 <2.0.0   # Erlaubt 1.x.x
^0.2.3  ‚Üí  >=0.2.3 <0.3.0   # Erlaubt 0.2.x
^0.0.3  ‚Üí  >=0.0.3 <0.0.4   # Erlaubt nur 0.0.3
```

**Verwenden wenn:** Sie kompatible Updates innerhalb einer Major-Version wollen.

**H√§ufigste Einschr√§nkung** - f√ºr die meisten Abh√§ngigkeiten empfohlen.

### Tilde-Bereiche (~)

Die Tilde (`~`) erlaubt nur Patch-Level-√Ñnderungen:

```
~1.2.3  ‚Üí  >=1.2.3 <1.3.0   # Erlaubt 1.2.x
~1.2    ‚Üí  >=1.2.0 <1.3.0   # Erlaubt 1.2.x
~1      ‚Üí  >=1.0.0 <2.0.0   # Erlaubt 1.x.x
```

**Verwenden wenn:** Sie nur Bugfixes wollen, keine neuen Features.

### Vergleichsbereiche

Vergleichsoperatoren f√ºr pr√§zise Kontrolle kombinieren:

```json
{
  "dependencies": {
    "owner/pkg": ">=1.0.0 <2.0.0",
    "owner/other": ">1.5.0 <=2.1.0"
  }
}
```

### Beliebige Version (*)

Entspricht jeder Version:

```json
{
  "dependencies": {
    "owner/pkg": "*"
  }
}
```

**Warnung:** Nicht f√ºr Produktion empfohlen. Wird immer die neueste Version holen.

## Pre-Release-Versionen

### Pre-Release-Identifikatoren

Pre-Releases haben niedrigere Priorit√§t als Releases:

```
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0-rc.1 < 1.0.0
```

### H√§ufige Pre-Release-Tags

| Tag | Bedeutung | Stadium |
|-----|-----------|---------|
| `alpha` | Fr√ºhe Entwicklung | Sehr instabil |
| `beta` | Feature-vollst√§ndig | Testen |
| `rc` | Release Candidate | Finales Testen |
| `dev` | Entwicklungs-Snapshot | Instabil |

### Pre-Release in Einschr√§nkungen

Einschr√§nkungen entsprechen standardm√§√üig keinen Pre-Releases:

```
^1.0.0    # Entspricht NICHT 1.1.0-beta
>=1.0.0   # Entspricht NICHT 2.0.0-alpha
```

Um Pre-Releases einzuschlie√üen, explizit referenzieren:

```
>=1.0.0-alpha <2.0.0   # Schlie√üt alle 1.x Pre-Releases ein
```

## Versionsvergleich

### Vergleichsregeln

1. MAJOR, MINOR, PATCH numerisch vergleichen
2. Release > Pre-Release mit gleicher Version
3. Pre-Releases alphanumerisch vergleichen
4. Build-Metadaten werden ignoriert

### Beispiele

```
1.0.0 < 1.0.1 < 1.1.0 < 2.0.0

1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta < 1.0.0

1.0.0 = 1.0.0+build123  # Build-Metadaten ignoriert
```

### Sortierung

Versionen werden aufsteigend sortiert:

```
1.0.0
1.0.1
1.1.0
1.1.1
2.0.0-alpha
2.0.0-beta
2.0.0
```

## Versionsaufl√∂sung

### Aufl√∂sungsalgorithmus

Wenn mehrere Pakete dieselbe Abh√§ngigkeit ben√∂tigen:

1. Alle Einschr√§nkungen sammeln
2. Schnittmenge aller Bereiche finden
3. H√∂chste Version in der Schnittmenge w√§hlen
4. Fehler, wenn keine Version alle erf√ºllt

### Beispiel-Aufl√∂sung

```
package-a erfordert hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)
package-b erfordert hemlang/json@~1.2.0  (>=1.2.0 <1.3.0)

Schnittmenge: >=1.2.0 <1.3.0
Verf√ºgbar: [1.0.0, 1.1.0, 1.2.0, 1.2.1, 1.2.5, 1.3.0]
Aufgel√∂st: 1.2.5 (h√∂chste in Schnittmenge)
```

### Konflikterkennung

Konflikt tritt auf, wenn keine Version alle Einschr√§nkungen erf√ºllt:

```
package-a erfordert hemlang/json@^1.0.0  (>=1.0.0 <2.0.0)
package-b erfordert hemlang/json@^2.0.0  (>=2.0.0 <3.0.0)

Schnittmenge: (leer)
Ergebnis: KONFLIKT - keine Version erf√ºllt beide
```

## Best Practices

### F√ºr Paket-Konsumenten

1. **Caret-Bereiche verwenden** f√ºr die meisten Abh√§ngigkeiten:
   ```json
   "hemlang/json": "^1.2.0"
   ```

2. **Tilde-Bereiche verwenden** f√ºr kritische Abh√§ngigkeiten:
   ```json
   "critical/lib": "~1.2.0"
   ```

3. **Versionen nur bei Bedarf pinnen**:
   ```json
   "unstable/pkg": "1.2.3"
   ```

4. **Lock-Datei committen** f√ºr reproduzierbare Builds

5. **Regelm√§√üig aktualisieren** um Sicherheitsfixes zu erhalten:
   ```bash
   hpm update
   hpm outdated
   ```

### F√ºr Paket-Autoren

1. **Bei 0.1.0 starten** f√ºr die anf√§ngliche Entwicklung:
   - API kann sich h√§ufig √§ndern
   - Benutzer erwarten Instabilit√§t

2. **Zu 1.0.0 wechseln**, wenn API stabil ist:
   - √ñffentliche Verpflichtung zur Stabilit√§t
   - Breaking Changes erfordern Major-Bump

3. **Semver strikt folgen**:
   - Breaking Change = MAJOR
   - Neues Feature = MINOR
   - Bugfix = PATCH

4. **Pre-Releases f√ºr Tests verwenden**:
   ```bash
   git tag v2.0.0-beta.1
   git push --tags
   ```

5. **Breaking Changes dokumentieren** im CHANGELOG

## Versionen ver√∂ffentlichen

### Releases erstellen

```bash
# Version in package.json aktualisieren
# package.json bearbeiten: "version": "1.1.0"

# Versions√§nderung committen
git add package.json
git commit -m "Bump version to 1.1.0"

# Tag erstellen und pushen
git tag v1.1.0
git push origin main --tags
```

### Tag-Format

Tags **m√ºssen** mit `v` beginnen:

```
v1.0.0      ‚úì Richtig
v1.0.0-beta ‚úì Richtig
1.0.0       ‚úó Wird nicht erkannt
```

### Release-Workflow

```bash
# 1. Sicherstellen, dass Tests bestehen
hpm test

# 2. Version in package.json aktualisieren
# 3. CHANGELOG.md aktualisieren
# 4. √Ñnderungen committen
git add -A
git commit -m "Release v1.2.0"

# 5. Tag erstellen
git tag v1.2.0

# 6. Alles pushen
git push origin main --tags
```

## Versionen pr√ºfen

### Installierte Versionen auflisten

```bash
hpm list
```

### Nach Updates suchen

```bash
hpm outdated
```

Ausgabe:
```
Package         Current  Wanted  Latest
hemlang/json    1.0.0    1.0.5   1.2.0
hemlang/sprout  2.0.0    2.0.3   2.1.0
```

- **Current**: Installierte Version
- **Wanted**: H√∂chste, die Einschr√§nkung entspricht
- **Latest**: Neueste verf√ºgbar

### Pakete aktualisieren

```bash
# Alle aktualisieren
hpm update

# Bestimmtes Paket aktualisieren
hpm update hemlang/json
```

## Siehe auch

- [Pakete erstellen](#hpm-versioning-creating-packages) - Ver√∂ffentlichungsanleitung
- [Paketspezifikation](#hpm-versioning-package-spec) - package.json-Format
- [Befehle](#hpm-versioning-commands) - CLI-Referenz



################################################################################
# HPM: REFERENZ
################################################################################

--------------------------------------------------------------------------------
## Architektur
--------------------------------------------------------------------------------

# Architektur

Interne Architektur und Design von hpm. Dieses Dokument richtet sich an Mitwirkende und diejenigen, die verstehen m√∂chten, wie hpm funktioniert.

## √úbersicht

hpm ist in Hemlock geschrieben und besteht aus mehreren Modulen, die verschiedene Aspekte der Paketverwaltung behandeln:

```
src/
‚îú‚îÄ‚îÄ main.hml        # CLI-Einstiegspunkt und Befehlsrouting
‚îú‚îÄ‚îÄ manifest.hml    # package.json-Verarbeitung
‚îú‚îÄ‚îÄ lockfile.hml    # package-lock.json-Verarbeitung
‚îú‚îÄ‚îÄ semver.hml      # Semantische Versionierung
‚îú‚îÄ‚îÄ resolver.hml    # Abh√§ngigkeitsaufl√∂sung
‚îú‚îÄ‚îÄ github.hml      # GitHub-API-Client
‚îú‚îÄ‚îÄ installer.hml   # Paket-Download und -Extraktion
‚îî‚îÄ‚îÄ cache.hml       # Globale Cache-Verwaltung
```

## Modulverantwortlichkeiten

### main.hml

Der Einstiegspunkt f√ºr die CLI-Anwendung.

**Verantwortlichkeiten:**
- Kommandozeilenargumente parsen
- Befehle an entsprechende Handler weiterleiten
- Hilfe- und Versionsinformationen anzeigen
- Globale Flags behandeln (--verbose, --dry-run, etc.)
- Mit entsprechenden Codes beenden

**Hauptfunktionen:**
- `main()` - Einstiegspunkt, parst Args und verteilt Befehle
- `cmd_init()` - `hpm init` behandeln
- `cmd_install()` - `hpm install` behandeln
- `cmd_uninstall()` - `hpm uninstall` behandeln
- `cmd_update()` - `hpm update` behandeln
- `cmd_list()` - `hpm list` behandeln
- `cmd_outdated()` - `hpm outdated` behandeln
- `cmd_run()` - `hpm run` behandeln
- `cmd_why()` - `hpm why` behandeln
- `cmd_cache()` - `hpm cache` behandeln

**Befehlsk√ºrzel:**
```hemlock
let shortcuts = {
    "i": "install",
    "rm": "uninstall",
    "remove": "uninstall",
    "ls": "list",
    "up": "update"
};
```

### manifest.hml

Behandelt das Lesen und Schreiben von `package.json`-Dateien.

**Verantwortlichkeiten:**
- package.json lesen/schreiben
- Paketstruktur validieren
- Abh√§ngigkeiten verwalten
- Paketspezifizierer parsen (owner/repo@version)

**Hauptfunktionen:**
```hemlock
create_default(): Manifest           // Leeres Manifest erstellen
read_manifest(): Manifest            // Aus Datei lesen
write_manifest(m: Manifest)          // In Datei schreiben
validate(m: Manifest): bool          // Struktur validieren
get_all_dependencies(m): Map         // deps + devDeps holen
add_dependency(m, pkg, ver, dev)     // Abh√§ngigkeit hinzuf√ºgen
remove_dependency(m, pkg)            // Abh√§ngigkeit entfernen
parse_specifier(spec): (name, ver)   // "owner/repo@^1.0.0" parsen
split_name(name): (owner, repo)      // "owner/repo" parsen
```

**Manifest-Struktur:**
```hemlock
type Manifest = {
    name: string,
    version: string,
    description: string?,
    author: string?,
    license: string?,
    repository: string?,
    main: string?,
    dependencies: Map<string, string>,
    devDependencies: Map<string, string>,
    scripts: Map<string, string>
};
```

### lockfile.hml

Verwaltet die `package-lock.json`-Datei f√ºr reproduzierbare Installationen.

**Verantwortlichkeiten:**
- Lock-Dateien erstellen/lesen/schreiben
- Exakt aufgel√∂ste Versionen verfolgen
- Download-URLs und Integrit√§ts-Hashes speichern
- Verwaiste Abh√§ngigkeiten bereinigen

**Hauptfunktionen:**
```hemlock
create_empty(): Lockfile              // Leere Lockfile erstellen
read_lockfile(): Lockfile             // Aus Datei lesen
write_lockfile(l: Lockfile)           // In Datei schreiben
create_entry(ver, url, hash, deps)    // Lock-Eintrag erstellen
get_locked(l, pkg): LockEntry?        // Gesperrte Version holen
set_locked(l, pkg, entry)             // Gesperrte Version setzen
remove_locked(l, pkg)                 // Eintrag entfernen
prune(l, keep: Set)                   // Verwaiste entfernen
needs_update(l, m): bool              // Pr√ºfen, ob nicht synchron
```

**Lockfile-Struktur:**
```hemlock
type Lockfile = {
    lockVersion: int,
    hemlock: string,
    dependencies: Map<string, LockEntry>
};

type LockEntry = {
    version: string,
    resolved: string,     // Download-URL
    integrity: string,    // SHA256-Hash
    dependencies: Map<string, string>
};
```

### semver.hml

Vollst√§ndige Implementierung von Semantic Versioning 2.0.0.

**Verantwortlichkeiten:**
- Versionszeichenketten parsen
- Versionen vergleichen
- Versionseinschr√§nkungen parsen und auswerten
- Versionen finden, die Einschr√§nkungen erf√ºllen

**Hauptfunktionen:**
```hemlock
// Parsen
parse(s: string): Version             // "1.2.3-beta+build" ‚Üí Version
stringify(v: Version): string         // Version ‚Üí "1.2.3-beta+build"

// Vergleich
compare(a, b: Version): int           // -1, 0 oder 1
gt(a, b), gte(a, b), lt(a, b), lte(a, b), eq(a, b): bool

// Einschr√§nkungen
parse_constraint(s: string): Constraint    // "^1.2.3" ‚Üí Constraint
satisfies(v: Version, c: Constraint): bool // Pr√ºfen, ob v c entspricht
max_satisfying(versions, c): Version?      // H√∂chste √úbereinstimmung finden
sort(versions): [Version]                  // Aufsteigend sortieren

// Hilfsfunktionen
constraints_overlap(a, b: Constraint): bool  // Kompatibilit√§t pr√ºfen
```

**Version-Struktur:**
```hemlock
type Version = {
    major: int,
    minor: int,
    patch: int,
    prerelease: [string]?,  // z.B. ["beta", "1"]
    build: string?          // z.B. "20230101"
};
```

**Constraint-Typen:**
```hemlock
type Constraint =
    | Exact(Version)           // "1.2.3"
    | Caret(Version)           // "^1.2.3" ‚Üí >=1.2.3 <2.0.0
    | Tilde(Version)           // "~1.2.3" ‚Üí >=1.2.3 <1.3.0
    | Range(op, Version)       // ">=1.0.0", "<2.0.0"
    | And(Constraint, Constraint)  // Kombinierte Bereiche
    | Any;                     // "*"
```

### resolver.hml

Implementiert npm-artige Abh√§ngigkeitsaufl√∂sung.

**Verantwortlichkeiten:**
- Abh√§ngigkeitsb√§ume aufl√∂sen
- Versionskonflikte erkennen
- Zirkul√§re Abh√§ngigkeiten erkennen
- Visualisierungsb√§ume erstellen

**Hauptfunktionen:**
```hemlock
resolve(manifest, lockfile): ResolveResult
    // Haupt-Resolver: gibt flache Map aller Abh√§ngigkeiten mit aufgel√∂sten Versionen zur√ºck

resolve_version(pkg, constraints: [string]): ResolvedPackage?
    // Version finden, die alle Einschr√§nkungen erf√ºllt

detect_cycles(deps: Map): [Cycle]?
    // Zirkul√§re Abh√§ngigkeiten mit DFS finden

build_tree(lockfile): Tree
    // Baumstruktur f√ºr Anzeige erstellen

find_why(pkg, lockfile): [Chain]
    // Abh√§ngigkeitsketten finden, die erkl√§ren warum pkg installiert ist
```

**Aufl√∂sungsalgorithmus:**

1. **Einschr√§nkungen sammeln**: Manifest und transitive Abh√§ngigkeiten durchgehen
2. **Jedes Paket aufl√∂sen**: F√ºr jedes Paket:
   - Alle Versionseinschr√§nkungen von Abh√§ngigen holen
   - Verf√ºgbare Versionen von GitHub abrufen (gecacht)
   - H√∂chste Version finden, die ALLE Einschr√§nkungen erf√ºllt
   - Fehler, wenn keine Version alle erf√ºllt (Konflikt)
3. **Zyklen erkennen**: DFS ausf√ºhren, um zirkul√§re Abh√§ngigkeiten zu finden
4. **Flache Map zur√ºckgeben**: Paketname ‚Üí aufgel√∂ste Versionsinformation

**ResolveResult-Struktur:**
```hemlock
type ResolveResult = {
    packages: Map<string, ResolvedPackage>,
    conflicts: [Conflict]?,
    cycles: [Cycle]?
};

type ResolvedPackage = {
    name: string,
    version: Version,
    url: string,
    dependencies: Map<string, string>
};
```

### github.hml

GitHub-API-Client f√ºr Paketentdeckung und Downloads.

**Verantwortlichkeiten:**
- Verf√ºgbare Versionen (Tags) abrufen
- package.json aus Repositories herunterladen
- Release-Tarballs herunterladen
- Authentifizierung und Rate-Limits behandeln

**Hauptfunktionen:**
```hemlock
get_token(): string?
    // Token aus Umgebung oder Konfiguration holen

github_request(url, headers?): Response
    // API-Anfrage mit Wiederholungen machen

get_tags(owner, repo): [string]
    // Versions-Tags holen (v1.0.0, v1.1.0, etc.)

get_package_json(owner, repo, ref): Manifest
    // package.json bei bestimmtem Tag/Commit abrufen

download_tarball(owner, repo, tag): bytes
    // Release-Archiv herunterladen

repo_exists(owner, repo): bool
    // Pr√ºfen, ob Repository existiert

get_repo_info(owner, repo): RepoInfo
    // Repository-Metadaten holen
```

**Wiederholungslogik:**
- Exponentieller Backoff: 1s, 2s, 4s, 8s
- Wiederholungen bei: 403 (Rate-Limit), 5xx (Serverfehler), Netzwerkfehler
- Maximal 4 Wiederholungen
- Rate-Limit-Fehler klar melden

**Verwendete API-Endpunkte:**
```
GET /repos/{owner}/{repo}/tags
GET /repos/{owner}/{repo}/contents/package.json?ref={tag}
GET /repos/{owner}/{repo}/tarball/{tag}
GET /repos/{owner}/{repo}
```

### installer.hml

Behandelt das Herunterladen und Extrahieren von Paketen.

**Verantwortlichkeiten:**
- Pakete von GitHub herunterladen
- Tarballs nach hem_modules extrahieren
- Gecachte Pakete pr√ºfen/verwenden
- Pakete installieren/deinstallieren

**Hauptfunktionen:**
```hemlock
install_package(pkg: ResolvedPackage): bool
    // Einzelnes Paket herunterladen und installieren

install_all(packages: Map, options): InstallResult
    // Alle aufgel√∂sten Pakete installieren

uninstall_package(name: string): bool
    // Paket aus hem_modules entfernen

get_installed(): Map<string, string>
    // Aktuell installierte Pakete auflisten

verify_integrity(pkg): bool
    // Paketintegrit√§t √ºberpr√ºfen

prefetch_packages(packages: Map): void
    // Paralleler Download in Cache (experimentell)
```

**Installationsprozess:**

1. Pr√ºfen, ob bereits in korrekter Version installiert
2. Cache auf Tarball pr√ºfen
3. Wenn nicht gecacht, von GitHub herunterladen
4. Im Cache f√ºr zuk√ºnftige Verwendung speichern
5. Nach `hem_modules/owner/repo/` extrahieren
6. Installation verifizieren

**Erstellte Verzeichnisstruktur:**
```
hem_modules/
‚îî‚îÄ‚îÄ owner/
    ‚îî‚îÄ‚îÄ repo/
        ‚îú‚îÄ‚îÄ package.json
        ‚îú‚îÄ‚îÄ src/
        ‚îî‚îÄ‚îÄ ...
```

### cache.hml

Verwaltet den globalen Paket-Cache.

**Verantwortlichkeiten:**
- Heruntergeladene Tarballs speichern
- Gecachte Pakete abrufen
- Gecachte Pakete auflisten
- Cache leeren
- Konfiguration verwalten

**Hauptfunktionen:**
```hemlock
get_cache_dir(): string
    // Cache-Verzeichnis holen (ber√ºcksichtigt HPM_CACHE_DIR)

get_config_dir(): string
    // Konfigurationsverzeichnis holen (~/.hpm)

is_cached(owner, repo, version): bool
    // Pr√ºfen, ob Tarball gecacht ist

get_cached_path(owner, repo, version): string
    // Pfad zu gecachtem Tarball holen

store_tarball_file(owner, repo, version, data): void
    // Tarball im Cache speichern

list_cached(): [CachedPackage]
    // Alle gecachten Pakete auflisten

clear_cache(): int
    // Alle gecachten Pakete entfernen, freigegebene Bytes zur√ºckgeben

get_cache_size(): int
    // Gesamte Cache-Gr√∂√üe berechnen

read_config(): Config
    // ~/.hpm/config.json lesen

write_config(c: Config): void
    // Konfigurationsdatei schreiben
```

**Cache-Struktur:**
```
~/.hpm/
‚îú‚îÄ‚îÄ config.json
‚îî‚îÄ‚îÄ cache/
    ‚îî‚îÄ‚îÄ owner/
        ‚îî‚îÄ‚îÄ repo/
            ‚îú‚îÄ‚îÄ 1.0.0.tar.gz
            ‚îî‚îÄ‚îÄ 1.1.0.tar.gz
```

## Datenfluss

### Install-Befehl-Ablauf

```
hpm install owner/repo@^1.0.0
         ‚îÇ
         ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ main.hml ‚îÇ Args parsen, cmd_install aufrufen
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇmanifest.hml‚îÇ package.json lesen, Abh√§ngigkeit hinzuf√ºgen
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇresolver.hml‚îÇ Alle Abh√§ngigkeiten aufl√∂sen
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚ñº               ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ github.hml‚îÇ    ‚îÇ semver.hml‚îÇ Versionen holen, passende finden
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇinstaller.hml‚îÇ Pakete herunterladen und extrahieren
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚ñº               ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ github.hml‚îÇ    ‚îÇ cache.hml‚îÇ Herunterladen oder Cache verwenden
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇlockfile.hml‚îÇ package-lock.json aktualisieren
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Aufl√∂sungsalgorithmus-Detail

```
Eingabe: manifest.dependencies, manifest.devDependencies, bestehende Lockfile

1. Initialisieren:
   - constraints = {} // Map<string, [Constraint]>
   - resolved = {}    // Map<string, ResolvedPackage>
   - queue = [direkte Abh√§ngigkeiten]

2. Solange Queue nicht leer:
   a. pkg = queue.pop()
   b. Wenn pkg bereits aufgel√∂st, √ºberspringen
   c. Alle Einschr√§nkungen f√ºr pkg von Abh√§ngigen holen
   d. Verf√ºgbare Versionen von GitHub abrufen (gecacht)
   e. Max Version finden, die alle Einschr√§nkungen erf√ºllt
   f. Wenn keine gefunden: KONFLIKT
   g. resolved[pkg] = {version, url, deps}
   h. pkg's Abh√§ngigkeiten zur Queue hinzuf√ºgen

3. Zyklen im aufgel√∂sten Graphen erkennen
   - Wenn Zyklus gefunden: FEHLER

4. Aufgel√∂ste Map zur√ºckgeben
```

## Fehlerbehandlung

### Exit-Codes

Definiert in main.hml:

```hemlock
let EXIT_SUCCESS = 0;
let EXIT_CONFLICT = 1;
let EXIT_NOT_FOUND = 2;
let EXIT_VERSION_NOT_FOUND = 3;
let EXIT_NETWORK = 4;
let EXIT_INVALID_MANIFEST = 5;
let EXIT_INTEGRITY = 6;
let EXIT_RATE_LIMIT = 7;
let EXIT_CIRCULAR = 8;
```

### Fehler-Propagierung

Fehler steigen durch R√ºckgabewerte auf:

```hemlock
fn resolve_version(pkg): Result<Version, ResolveError> {
    let versions = github.get_tags(owner, repo)?;  // ? propagiert
    // ...
}
```

## Testen

### Test-Framework

Eigenes Test-Framework in `test/framework.hml`:

```hemlock
fn suite(name: string, tests: fn()) {
    print("Suite: " + name);
    tests();
}

fn test(name: string, body: fn()) {
    try {
        body();
        print("  ‚úì " + name);
    } catch e {
        print("  ‚úó " + name + ": " + e);
        failed += 1;
    }
}

fn assert_eq<T>(actual: T, expected: T) {
    if actual != expected {
        throw "Erwartet " + expected + ", bekam " + actual;
    }
}
```

### Testdateien

- `test/test_semver.hml` - Versionsparsen, Vergleich, Einschr√§nkungen
- `test/test_manifest.hml` - Manifest-Lesen/Schreiben, Validierung
- `test/test_lockfile.hml` - Lockfile-Operationen
- `test/test_cache.hml` - Cache-Verwaltung

### Tests ausf√ºhren

```bash
# Alle Tests
make test

# Spezifische Tests
make test-semver
make test-manifest
make test-lockfile
make test-cache
```

## Zuk√ºnftige Verbesserungen

### Geplante Features

1. **Integrit√§tsverifikation** - Vollst√§ndige SHA256-Hash-Pr√ºfung
2. **Workspaces** - Monorepo-Unterst√ºtzung
3. **Plugin-System** - Erweiterbare Befehle
4. **Audit** - Sicherheitsl√ºcken-Pr√ºfung
5. **Private Registry** - Selbst-gehostetes Paket-Hosting

### Bekannte Einschr√§nkungen

1. **Bundler-Bug** - Kann keine eigenst√§ndige Executable erstellen
2. **Parallele Downloads** - Experimentell, kann Race Conditions haben
3. **Integrit√§t** - SHA256 nicht vollst√§ndig implementiert

## Mitwirken

### Code-Stil

- 4 Leerzeichen Einr√ºckung verwenden
- Funktionen sollten eine Sache tun
- Komplexe Logik kommentieren
- Tests f√ºr neue Features schreiben

### Befehl hinzuf√ºgen

1. Handler in `main.hml` hinzuf√ºgen:
   ```hemlock
   fn cmd_newcmd(args: [string]) {
       // Implementierung
   }
   ```

2. Zur Befehlsverteilung hinzuf√ºgen:
   ```hemlock
   match command {
       "newcmd" => cmd_newcmd(args),
       // ...
   }
   ```

3. Hilfetext aktualisieren

### Modul hinzuf√ºgen

1. `src/newmodule.hml` erstellen
2. √ñffentliche Schnittstelle exportieren
3. In Modulen importieren, die es ben√∂tigen
4. Tests in `test/test_newmodule.hml` hinzuf√ºgen

## Siehe auch

- [Befehle](#hpm-architecture-commands) - CLI-Referenz
- [Pakete erstellen](#hpm-architecture-creating-packages) - Paketentwicklung
- [Versionierung](#hpm-architecture-versioning) - Semantische Versionierung


--------------------------------------------------------------------------------
## Exit-Codes
--------------------------------------------------------------------------------

# Exit-Codes

Referenz f√ºr hpm-Exit-Codes und ihre Bedeutungen.

## Exit-Code-Tabelle

| Code | Name | Beschreibung |
|------|------|--------------|
| 0 | SUCCESS | Befehl erfolgreich abgeschlossen |
| 1 | CONFLICT | Abh√§ngigkeits-Versionskonflikt |
| 2 | NOT_FOUND | Paket nicht gefunden |
| 3 | VERSION_NOT_FOUND | Angeforderte Version nicht gefunden |
| 4 | NETWORK | Netzwerkfehler |
| 5 | INVALID_MANIFEST | Ung√ºltige package.json |
| 6 | INTEGRITY | Integrit√§tspr√ºfung fehlgeschlagen |
| 7 | RATE_LIMIT | GitHub-API-Rate-Limit √ºberschritten |
| 8 | CIRCULAR | Zirkul√§re Abh√§ngigkeit erkannt |

## Detaillierte Beschreibungen

### Exit-Code 0: SUCCESS

Der Befehl wurde erfolgreich abgeschlossen.

```bash
$ hpm install
Installed 5 packages
$ echo $?
0
```

### Exit-Code 1: CONFLICT

Zwei oder mehr Pakete erfordern inkompatible Versionen einer Abh√§ngigkeit.

**Beispiel:**
```
Error: Dependency conflict for hemlang/json

  package-a requires hemlang/json@^1.0.0 (>=1.0.0 <2.0.0)
  package-b requires hemlang/json@^2.0.0 (>=2.0.0 <3.0.0)

No version satisfies all constraints.
```

**L√∂sungen:**
1. Pr√ºfen, welche Pakete den Konflikt haben:
   ```bash
   hpm why hemlang/json
   ```
2. Das konfliktverursachende Paket aktualisieren:
   ```bash
   hpm update package-a
   ```
3. Versionseinschr√§nkungen in package.json lockern
4. Eines der konfliktverursachenden Pakete entfernen

### Exit-Code 2: NOT_FOUND

Das angegebene Paket existiert nicht auf GitHub.

**Beispiel:**
```
Error: Package not found: hemlang/nonexistent

The repository hemlang/nonexistent does not exist on GitHub.
```

**L√∂sungen:**
1. Paketnamen-Schreibweise √ºberpr√ºfen
2. Pr√ºfen, ob Repository existiert: `https://github.com/owner/repo`
3. √úberpr√ºfen, ob Sie Zugriff haben (f√ºr private Repos, GITHUB_TOKEN setzen)

### Exit-Code 3: VERSION_NOT_FOUND

Keine Version entspricht der angegebenen Einschr√§nkung.

**Beispiel:**
```
Error: No version of hemlang/json matches constraint ^5.0.0

Available versions: 1.0.0, 1.1.0, 1.2.0, 2.0.0
```

**L√∂sungen:**
1. Verf√ºgbare Versionen auf GitHub-Releases/Tags pr√ºfen
2. Eine g√ºltige Versionseinschr√§nkung verwenden
3. Versions-Tags m√ºssen mit 'v' beginnen (z.B. `v1.0.0`)

### Exit-Code 4: NETWORK

Ein netzwerkbezogener Fehler ist aufgetreten.

**Beispiel:**
```
Error: Network error: could not connect to api.github.com

Please check your internet connection and try again.
```

**L√∂sungen:**
1. Internetverbindung pr√ºfen
2. Pr√ºfen, ob GitHub erreichbar ist
3. Proxy-Einstellungen √ºberpr√ºfen, falls hinter Firewall
4. `--offline` verwenden, wenn Pakete gecacht sind:
   ```bash
   hpm install --offline
   ```
5. Warten und erneut versuchen (hpm wiederholt automatisch)

### Exit-Code 5: INVALID_MANIFEST

Die package.json-Datei ist ung√ºltig oder fehlerhaft.

**Beispiel:**
```
Error: Invalid package.json

  - Missing required field: name
  - Invalid version format: "1.0"
```

**L√∂sungen:**
1. JSON-Syntax pr√ºfen (JSON-Validator verwenden)
2. Sicherstellen, dass erforderliche Felder existieren (`name`, `version`)
3. Feldformate √ºberpr√ºfen:
   - name: `owner/repo`-Format
   - version: `X.Y.Z` Semver-Format
4. Neu generieren:
   ```bash
   rm package.json
   hpm init
   ```

### Exit-Code 6: INTEGRITY

Paket-Integrit√§tsverifikation fehlgeschlagen.

**Beispiel:**
```
Error: Integrity check failed for hemlang/json@1.0.0

Expected: sha256-abc123...
Actual:   sha256-def456...

The downloaded package may be corrupted.
```

**L√∂sungen:**
1. Cache leeren und neu installieren:
   ```bash
   hpm cache clean
   hpm install
   ```
2. Auf Netzwerkprobleme pr√ºfen (unvollst√§ndige Downloads)
3. √úberpr√ºfen, ob das Paket manipuliert wurde

### Exit-Code 7: RATE_LIMIT

GitHub-API-Rate-Limit wurde √ºberschritten.

**Beispiel:**
```
Error: GitHub API rate limit exceeded

Unauthenticated rate limit: 60 requests/hour
Current usage: 60/60

Rate limit resets at: 2024-01-15 10:30:00 UTC
```

**L√∂sungen:**
1. **Mit GitHub authentifizieren** (empfohlen):
   ```bash
   export GITHUB_TOKEN=ghp_xxxxxxxxxxxx
   hpm install
   ```
2. Auf Rate-Limit-Reset warten (wird st√ºndlich zur√ºckgesetzt)
3. Offline-Modus verwenden, wenn Pakete gecacht sind:
   ```bash
   hpm install --offline
   ```

### Exit-Code 8: CIRCULAR

Zirkul√§re Abh√§ngigkeit im Abh√§ngigkeitsgraphen erkannt.

**Beispiel:**
```
Error: Circular dependency detected

  package-a@1.0.0
  ‚îî‚îÄ‚îÄ package-b@1.0.0
      ‚îî‚îÄ‚îÄ package-a@1.0.0  (zirkul√§r!)

Cannot resolve dependency tree.
```

**L√∂sungen:**
1. Dies ist normalerweise ein Bug in den Paketen selbst
2. Paket-Maintainer kontaktieren
3. Eines der zirkul√§ren Pakete nicht verwenden

## Exit-Codes in Skripten verwenden

### Bash

```bash
#!/bin/bash

hpm install
exit_code=$?

case $exit_code in
  0)
    echo "Installation erfolgreich"
    ;;
  1)
    echo "Abh√§ngigkeitskonflikt - Versionseinschr√§nkungen pr√ºfen"
    exit 1
    ;;
  2)
    echo "Paket nicht gefunden - Paketnamen pr√ºfen"
    exit 1
    ;;
  4)
    echo "Netzwerkfehler - Verbindung pr√ºfen"
    exit 1
    ;;
  7)
    echo "Rate-limitiert - GITHUB_TOKEN setzen"
    exit 1
    ;;
  *)
    echo "Unbekannter Fehler: $exit_code"
    exit 1
    ;;
esac
```

### CI/CD

```yaml
# GitHub Actions
- name: Abh√§ngigkeiten installieren
  run: |
    hpm install
    if [ $? -eq 7 ]; then
      echo "::error::GitHub-Rate-Limit √ºberschritten. GITHUB_TOKEN hinzuf√ºgen."
      exit 1
    fi
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### Make

```makefile
install:
	@hpm install || (echo "Installation fehlgeschlagen mit Code $$?"; exit 1)

test: install
	@hpm test
```

## Fehlerbehebung nach Exit-Code

### Kurzreferenz

| Code | Zuerst pr√ºfen |
|------|---------------|
| 1 | `hpm why <package>` ausf√ºhren, um Konflikt zu sehen |
| 2 | Paketnamen auf GitHub √ºberpr√ºfen |
| 3 | Verf√ºgbare Versionen auf GitHub-Tags pr√ºfen |
| 4 | Internetverbindung pr√ºfen |
| 5 | package.json-Syntax validieren |
| 6 | `hpm cache clean && hpm install` ausf√ºhren |
| 7 | `GITHUB_TOKEN`-Umgebungsvariable setzen |
| 8 | Paket-Maintainer kontaktieren |

## Siehe auch

- [Fehlerbehebung](#hpm-exit-codes-troubleshooting) - Detaillierte L√∂sungen
- [Befehle](#hpm-exit-codes-commands) - Befehlsreferenz
- [Konfiguration](#hpm-exit-codes-configuration) - GitHub-Token einrichten



================================================================================
END OF DOCUMENTATION
================================================================================